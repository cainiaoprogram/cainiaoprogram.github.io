<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f89f61550e2abef0416cefb292ce9cb0/" rel="bookmark">
			controller接受localDateTime系列的日期参数配置方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		controller接受localDateTime系列的日期参数时, 需要在实体类的日期字段上添加DateTimeFormat注解. 但是这种方式比较麻烦,
因为每个日期字段, 每个实体类都需要添加, 可以使用配置的方式进行统一的配置
@Bean public Formatter&lt;LocalDateTime&gt; localDateTimeFormatter() { return new Formatter&lt;LocalDateTime&gt;() { /** * 解析参数 * * @param text 传入日期字符串参数 * @param locale 地区 * @return 解析后的日期 */ @Override public LocalDateTime parse(String text, Locale locale) { return LocalDateTime.parse(text, DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss", locale)); } /** * 这个暂时不知道怎么使用, 也不知道干什么的... * * @param object 日期 * @param locale 地区 * @return 输出字符串 */ @Override public String print(LocalDateTime object, Locale locale) { return DateTimeFormatter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f89f61550e2abef0416cefb292ce9cb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d773743731e74605f49dd375be712d1/" rel="bookmark">
			xml文件中的CDATA标识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;![CDATA[ sql语句 ]]&gt; 例如&lt;![CDATA[ &lt; ]]&gt; 表示 &lt; ；
使用改格式的sql将会被认为是纯文本，此标记用于xml文件中；
为了方便起见，使用&lt;![CDATA[]]&gt;来包含不被xml解析器解析的内容。但要注意的是：
(1) 此部分不能再包含”]]&gt;”；
(2) 不允许嵌套使用；
(3)”]]&gt;”这部分不能包含空格或者换行。
&lt;![CDATA[]]&gt;和xml转义字符的关系： 它们的功能是一样的，只是应用场景和需求有些不同：
(1)&lt;![CDATA[]]&gt;不能适用所有情况，转义字符可以；
(2) 对于短字符串&lt;![CDATA[]]&gt;写起来啰嗦，对于长字符串转义字符写起来可读性差；
(3) &lt;![CDATA[]]&gt;表示xml解析器忽略解析，所以更快。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/553ec071e6db2699b42454338f79512c/" rel="bookmark">
			CentOS：Linux基本命令熟悉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于CentOS，进行Linux基本命令的操作，了解Linux操作系统的启动与登陆方法。熟悉Linux字符界面、窗口系统的常用指令。
Linux的文件系统管理
常用的操作命令 1)、pwd：用于显示用户当前所在的目录。
2)、cd：cd命令不仅显示当前状态，还可以改变当前状态。
cd … 可进入上一层目录
cd - 可进入上一个进入的目录，
cd ~可进入用户的home目录。
3)、ls：用于显示当前目录的内容。其参数为：
a 显示指定目录下所有子目录与文件，包括隐藏文件。A 显示指定目录下所有子目录与文件，包括隐藏文件。但不列出“.”和 “…”。b 对文件名中的不可显示字符用八进制字符显示。c 按文件的修改时间排序。l 以长格式来显示文件的详细信息。这个选项最常用。ls –l 命令， 就可以显示目录内容的详细信息。 如果目录下的文件太多，用一屏显示不了，可以用ls -l |more分屏显示 。 4)、find：find命令用于查找文件。这个命令可以按文件名、建立或修改日期、所有者(通常是建立文件的用户)、文件长度或文件类型进行搜索。
5)、mkdir: 这个命令很简单，用于建立目录。
6)、cp: cp命令用于复制文件或目录。 cp命令可以一次复制多个文件
7)、rm : rm命令用于删除文件或目录。 rm命令会强制删除文件， 删除目录，可用rm -r命令。
8)、mv ：mv命令用于移动文件和更名文件。
实际案例 在根目录（/）下新建一目录 test
mkdir test
改变当前目录至 /test ，在该目录下 ，以自己名字的英文缩写建一个空的文件 ，再建两个子目录（xh）与（ah）；
touch zyn; mkdir xh; mkdir ah
进入到（xh）子目录中，新建一个空文件text1；
cd xh; touch text1
进入到（ah）子目录中， 再新建一个子目录（abc）,同时建立空文件text2；
cd …;cd ah; mkdir abc; touch text2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/553ec071e6db2699b42454338f79512c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37cf6f2b7450229faf46d224a37ad96c/" rel="bookmark">
			fMRI技术指南总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能磁共振成像技术 本文是根据我学习一年fMRI相关知识所总结的内容，我将会以我目前所学知识从使用的开发工具，处理步骤逐步介绍以及当前所研究的方向进行介绍。文中涉及的各种资料我将上传到我的Github中
功能性磁共振成像(functional magnetic resonance imaging,fMRI)通过使用BOLD信号应用于研究脑科学和认知科学。
处理工具 工欲善其事，必先利其器。借助优秀的开发工具可以达到事半功倍的效果。我比较常用的工具如下：
开发平台 Matlab2016b：该版本对于各种下面介绍的Toolbox有较好的支持能力，但是不能支持在Python中调用Matlab中工具包及工具包对应的函数，如果想要进行Python与Matlab之间的通讯推荐使用Matlab2018b，其中涉及Matlab中的Python引擎(Engine)，推荐教程Python 3.6.X：该版本的python对于目前流行的各种第三方包和各种框架有较好的支持。Anaconda，Pycharm 根据需求选用，这里不做推荐 Toolbox及小插件 SPM12：用于预处理数据的工具包，支持PET,VBM,EEG,MEG,fMRI等。该版本众多研究文献中所常用的版本，也有些文献仍然在使用SPM8，不过在SPM12中也存在着之前版本的操作，官方下载链接，之前我根据官方给出的Manual所记录的学习笔记链接SPM入门案例1，SPM入门案例2,SPM入门案例3这是我在学习初期所记录的笔记。DCMsort：将从机器中导出的数据进行按照不同数据分类形成文件夹，有很多类似的软件Dcm2Analysis.exe、Dcmsort.exe，(软件链接)[http://dicomsort.com/]，各个类型的使用操作大体相似，产生如下的文件夹分类，具体各个文件夹所指自行百度。
Xjview12：用于观察大脑激活结果的工具，比SPM中自带的display好用的多。MRIcron：装机必备墙裂推荐,其中包含两个比较重要的可执行文件，分别是dcm2niigui.exe以及mricron.exe,dcm2niigui.exe是带有GUI的一个程序用于将DICOM文件，俗称原始数据文件，转换为可执行的NIFTI，后缀为nii格式的文件。 通过将所选择的文件夹（这里强调一下是一个被试的单个试次，即一个Session内的文件夹）拖入即可，程序会自动在该文件夹下生成若干个nii的文件，产生的nii文件数量与进行扫描的time points的数量有关，通常一个time point代表机器扫描一个全脑。文件可以选择转换成3D或者4D的文件，通常推荐采用4D文件即一个文件中包含了Time points个数量的全脑扫描图像
其中的MRIcron.exe可以用于查看扫描的数据，比如扫描的时间点，扫描的层数等多种参数
DPABI： 对fMRI影像数据实施批处理，提高生产力的强大工具,墙裂推荐,装机必备，一般使用他的DPARSF子模块全称Data Processing Assistant for Resting-state fMRI，下载链接,后面会详细介绍DPABI处理流程RESTplus：与DPABI类似，没怎么多使用过，如果有兴趣的可以尝试，上手较快,下载链接BrainNetViewer：用于生成大脑脑区之间的连接，墙裂推荐,装机必备，下载地址，展示一个炫酷的脑图，具体如何绘制，我后面会阐述
GRETNA：用于研究图论的工具，装机可选，好评推荐，适合研究小世界网络属性，下载链接GroupICA：很不错的软件，推荐值得一试，下载链接
处理流程 我总结了目前文献中常用获取解算指标(ICA、ReHo、FC、ALFF)的处理流程，如下图所示，不同的目的会采用不同的处理过程。还可以获取的研究的解算指标有dFC、graph attribute、multifractal等，这些指标的解释及原理可以百度和查阅以及相关文献，这里就不展开了。
步骤解释 这一部分的内容就到此结束啦~欢迎各位批评指正！
o(￣▽￣)ブ
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3bfe6c70cf91a9e44eb24e4a4c17048/" rel="bookmark">
			灰色关联分析笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么时候用灰色关联分析？ 灰色关联分析 是根据因素之间发展趋势的相似或相异程度，亦即“灰色关联度”，作为衡量因素间关联程度的一种方法
【若两个因素变化的趋势具有一致性，即同步变化程度较高，即可谓二者关联程度较高；反之，则较低】
当样本个数 n 较大时，用标准化回归（第7讲学），当样本个数 n 较少时，用灰色关联分析
灰色关联分析的顺序 ① 正向化（若已经全是极大型 则不需要）
② 预处理（每一个元素都被预处理）
③ 构造母序列和子序列（若题目本身已给出 则不需要）
④ 计算各个指标与母序列的灰色关联度（每一列 都可以求出一个灰色关联度）
⑤ 针对各个指标的权重 计算每一个元素的得分（若每一列的灰色关联度都一样 则不需要）
⑥ 对得分进行归一化 并排序
下图引用自 数学建模灰色关联分析法——学习笔记（一）
使用灰色关联分析的两种套路 ① 用于系统分析（比较母序列与哪个子序列最接近） 我们以下图举例，分析国内生产总值与哪一个产业的影响最大？
load gdp.mat	% 导入数据 Mean = mean(gdp); % 求出每一列的均值以供后续的数据预处理 gdp = gdp ./ repmat(Mean,size(gdp,1),1); % 将矩阵进行复制为和gdp同等大小，然后使用点除（对应元素相除） disp('预处理后的矩阵为：'); disp(gdp) Y = gdp(:,1); % 母序列 X = gdp(:,2:end); % 子序列 absX0_Xi = abs(X - repmat(Y,1,size(X,2))) % 计算|Y-Xi|矩阵 a = min(min(absX0_Xi)) % 计算两级最小差a b = max(max(absX0_Xi)) % 计算两级最大差b rho = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3bfe6c70cf91a9e44eb24e4a4c17048/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e74f02d029dc969ca9e1f0a26ac68a0e/" rel="bookmark">
			软件工程笔记：通用职责分配模式(grasp)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 通用职责分配模式(grasp) — 笔记整理自 北京理工大学 计算机学院
什么是GRASP? General Responsibility Assignment Software Patterns(通用职责分配软件模式)GRASP包括4个基本模式和5个扩展模式，描述了对象设计和职责分配的基本原则职责是一个类的契约或义务“做”型职责是通过类的方法来实现的“知道”型职责是通过类内部封装的属性以及类间关系来 体现GRASP是如何设计一个面向对象系统的基础 GRASP的9个模式 专家 :应该将职责分配给信息专家(谁的数据谁负责)创建者 :创建对象的职责(何时，由谁来创建和销毁)低耦合 :类间的关系代表了类之间的耦合程度高内聚 :一个类的职责之间的相关程度和集中程度控制者 :把协调处理系统消息的职责分配给不同控制类多态 :为不同的派生类分配具体的工作，具有相同接口纯虚构 :非实体类，从其他类中抽取相关高内聚职责中介者 :隔离藕合度过大的多个类，可能是虚构的受保护变化:把易于变化部分封装起来便于扩展 信息专家 Information Expert信息专家模式是面向对象设计的最基本原则如果某个类拥有完成某个职责所需要的所有信息，那么这个职责就应该分配给这个类来实现示例:网上购物系统的购物车设计 需求:需要让每种商品只在购物车内出现一次，购买相同商品，只需要更新商品的数量即可方案1:判断相同的职责与商品ID相关，它存在商品类中方案2:商品类为实体类，商品ID相关职责太多，应分散 创建者 尽可能少的建立对象之间的耦合和依赖关系一般情况下，只在下列情况下才由类A来创建类B，即A是B的创建者: 1.A是B的聚合2.A是B的容器3.A持有初始化B的信息(数据)4.A记录B的实例5.A频繁使用B 低耦合 低耦合降低了因一个类的变化而影响其他类的范围，而且让类更简单，更容易理解造成类A、B之间耦合的情况: A是B的属性A调用B的实例的方法A的方法中引用了B，包括B是A方法的返回值或参数A是B的子类，或者A实现了B 遵循一些面向对象设计的基本原则可以降低类间耦合，如LoD，信息专家(职责迁移)，避免夸模块类之间的直接访问等 高内聚 给类尽量分配内聚的职责，即功能性内聚的职责功能性紧密相关的职责应该放在一个类里，并共同完成有限的功能高内聚更有利于类的理解和重用，也便于类的维护高内聚也是一种隔离 控制者 将处理系统事件消息的职责分派给代表下列事物的类:
代表整个系统的类代表整个企业或组织的类代表真实世界中参与职责的主动对象类代表一个用例中所有事件的人工处理者类 控制者模式的相关原则:
1.系统事件的接收与处理通常由一个高级控制者类来代替2.一个子系统会有很多控制者类，分别处理不同的事务3.控制者一般将需要完成的工作分配给其他对象 多态 含义同面向对象的基本特性中的多态当相关的可选择的方法或行为随着类型变化时，将行为的职责分配给那些行为变化的类型典型编程应用:用多态的方法判断具体应该用哪个类，而不是用if来判断类该执行什么行为指导:尽量对抽象层编程 纯虚构 纯虚构与纯虚函数意思相近高内聚低耦合是系统设计的终极目标从某种角度看，内聚和耦合永远都是矛盾对立的高内聚要求拆分出更多的类，但对象之间需要更多的协作来完成任务，这又造成了高耦合，反之亦然。用纯虚构模式，由一个纯虚构的类来协调内聚和耦合，可以在一定程度上解决二者之间的矛盾 中介者 当多个类之间存在复杂的信息交互时，引入一个中介者类，把多个类之间的关联职责分配给它，从而降低类之间的耦合程度
备注：图片托管于github，请确保网络的可访问性
受保护变化 预先找出不稳定的变化点，使用统一的接口封装起来，如果未来发生变化的时候，可以通过接口扩展新的功能，而不需要去 修改原来旧的实现与OCP(开闭原则)类似，即一个软件实体应当对扩展开发，对修改关闭在设计一个模块的时候，要保证这个模块可以在不需要被修改 的前提下可以得到扩展通过扩展给系统提供了新的职责，以满足新的需求，同时又没有改变系统原来的功能 在迭代中使用GRASP 使用GRASP的根本原因是为了满足需求的变更敏捷方法通过快速的迭代来刺激变化，让变化及早暴露，再根据变化进行相应改动，并让这种改动遵循GRASP，力图使代码以及代码所表达的设计保持干净软件开发活动就是各种权衡:在简单与复杂之间权衡，在一种方案与另一种方案之间权衡不可能把每个问题、每个权衡的利弊都考虑清楚和全面 GRASP与设计模式 GRASP是学习使用设计模式的基础GRASP着重考虑设计类的原则及职责分配，比设计模式更重要设计模式是关于类和对象的一种高效、灵活的使用方式，是对面向对象的基本原则的多种良好的实现或经验的总结GoF设计模式提供具体的类结构，考虑设计的实现、类的交互和软件的质量GoF设计模式背后都遵循的就是永恒的设计原则和模式GoF设计模式就是符合GRASP模式要求的面向对象设计模式 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13a8430bac3f69246b16fa2dba233a36/" rel="bookmark">
			Tensorflow官方Android demo运行步骤和遇到的问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在部署自己训练好的模型前，首先运行一下tensorflow发布的官方demo，运行成功，特此记录！
首先说明一下我在Android studio运行的，我运行时，主要参考https://www.jianshu.com/p/99ff23a164ed，中间也遇到了很多问题，最终一一解决成功在虚拟设备上运行成功，最终也安装到自己的手机上运行了，成功！
1.首先下载tensorflow的源码 下载地址为：https://github.com/tensorflow/tensorflow
2.使用Android studio打开android工程 具体位置为：tensorflow-master\tensorflow\examples\android
第一次打开时会出现一些错误，没关系。
3.修改build.gradle文件 修改的地方一共有3处，不然会报错
将原来的内容如上图所示的屏蔽，然后添加新的内容：
1. maven { url 'http://maven.aliyun.com/nexus/content/groups/public/' }//阿里云镜像服务 jcenter { url "https://jcenter.bintray.com" } 2. maven { url "https://jitpack.io" } maven { url 'http://maven.aliyun.com/nexus/content/groups/public/' }//阿里云镜像服务 jcenter { url "https://jcenter.bintray.com" } 3. def nativeBuildSystem = 'none' 4.修改download-models.gradle文件 修改内容为2处如下图所示，屏蔽原来的jcenter()，然后添加
maven { url 'http://maven.aliyun.com/nexus/content/groups/public/' }//阿里云镜像服务 jcenter { url "https://jcenter.bintray.com" } 将如图2的位置全部屏蔽掉，这个部分在网上下载模型，我们直接下载好，然后放到相应的文件夹就行了
5.下载模型并添加到特定的文件夹下 下载地址如下：4个压缩包，一个一个的下载
https://storage.googleapis.com/download.tensorflow.org/models/inception_v1.zip https://storage.googleapis.com/download.tensorflow.org/models/object_detection/ssd_mobilenet_v1_android_export.zip https://storage.googleapis.com/download.tensorflow.org/models/stylize_v1.zip https://storage.googleapis.com/download.tensorflow.org/models/speech_commands_conv_actions.zip 全部下载之后，在android下新建gradleBuild文件夹，方法如下图所示：
然后在gradleBuild文件夹下，新建downloads文件夹，然后把我们下载好的4个模型的压缩包放到文件夹中，最后的效果如下图所示：
6.点击Sync Project with Gradle File 这时会遇见一个错误，好像是NDK的版本不匹配，NDK version=4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13a8430bac3f69246b16fa2dba233a36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ef7167efa03ac690997a78ea5fadae9/" rel="bookmark">
			使用n管理模块切换安装不同node版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装yarn
npm install -g yarn 没安装，提示 bash: yarn: command not found
安装nodejs版本管理模块n
npm install -g n 或者
sudo npm install -g n 升级npm
sudo npm install npm@latest -g 查看node版本，npm 版本
node -v npm -v 安装指定node版本
sudo n 10.0.0 管理node 包 源的工具nrm
npm install -g nrm Nrm ls 可以查看当前有多少镜像
nrm use xxx 可以设置镜像（切换）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a332e0e83ae9a26c8505fe015cda5f46/" rel="bookmark">
			QTableWidget显示提示消息气泡(单元格文本超出单元格长度显示提示)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QTabaleWidget控件，其中的每一个Item中显示的文字内容比较多，如果设置Item过大的话，文字虽然可以显示出来，但是整个页面就会显示的Item比较少。所以为了多显示Item，每个Item的大小设置还是要适中一些，带来的问题就是每个Item中显示的内容不全。但是还必须要让用户了解每一个Item中的内容，所有就想到了使用“气泡”来显示其中的内容。具体的显示效果如下：
在实现的以上功能的时候，有两个地方需要注意：
1. 必须开启界面的鼠标捕获功能：
ui.tableWidget-&gt;setMouseTracking(true);//开启捕获鼠标功能 2. 接收QTableWidget的信号cellEntered(int,int)：
This signal is emitted when the mouse cursor enters a cell. The cell is specified by row and column. 当鼠标进入单元格中的时候，这个信号会被发射。
具体的源码：
#pragma once #include &lt;QtWidgets/QMainWindow&gt; #include "ui_TableWidgetTip.h" class QMouseEvent; class TableWidgetTip : public QMainWindow { Q_OBJECT public: TableWidgetTip(QWidget *parent = Q_NULLPTR); private: void init(); private slots: void slotCellEnter(int r, int c); private: Ui::TableWidgetTipClass ui; }; #include "TableWidgetTip.h" #include &lt;QMouseEvent&gt; #include &lt;QToolTip&gt; #include &lt;QDebug&gt; TableWidgetTip::TableWidgetTip(QWidget *parent) : QMainWindow(parent) { ui.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a332e0e83ae9a26c8505fe015cda5f46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49b4391cc07bda64f3c60a79d461f3f8/" rel="bookmark">
			2020最新整理：好用的免费/收费的第三方域名解析服务平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国外免费域名解析服务平台：
Godaddy ：不在Godaddy注册域名，也可以使用Godaddy的域名解析服务，使用方法很简单，登录Godaddy网站后，点击“Add Off-site DNS”即可添加用户的域名，之后将用户域名的DNS设置为Godaddy指定的地址，域名DNS生效后，即可点击添加的域名进行DNS解析设置。
NameCheap ：知名的域名注册商NameCheap也和Godaddy一样，提供免费DNS域名解析，点击“FreeDNS”后，即可添加用户域名，用户可以通过修改DNS或域名邮件来验证自己的域名，NameCheap的解析服务支持的功能有：网址转发（可隐藏原URL、支持301重定向）、邮件转发、A记录、CNAME别名记录、MX邮件记录、TXT文本记录、NS记录、AAAA记录（IPV6）、动态域名解析等等。
ZoneEdit ：美国著名的老牌免费域名DNS解析服务，成立于1999年。免费帐户最多可添加5个域名。解析类型：A记录、AAAA记录、 TXT文本记录、LOC记录、PTR记录、CNAME别名记录、MX邮件记录、网址转发、邮件转发等。界面超级简洁，速度快，稳定。
HE.NET ：是美国老牌IDC，成立于1994年，在技术领域比较强，尤其是IPV6应用。这个免费DNS解析服务最多可以添加50个域名，可以设置A记录、AAAA记录、CNAME别名记录、MX邮件记录、NS记录、TXT记录、SRV记录。
FreeDNS ：一家美国免费域名DNS解析服务网站，界面简洁，注册简单，支持添加任何后缀的域名，支持Google Apps服务。免费域名DNS解析服务有三种模式：简单模式可直接设置IP指向、转发模式可设置301永久重定向和302临时重定向、高级模式可设置A记录、AAAA记录、CNAME记录、MX记录、PTR记录、TXT记录。
afraid ：美国一家免费域名解析服务，运营了相当长的时间了，值得提醒的是按照官方规定六个月账号必须有一次登录，否则账号会被锁定 。
CDN服务自带域名解析
CloudFlare ：虽然它的主营业务是CDN（Anycast），但丝毫不影响它作为免费DNS的声誉，况且这个免费DNS是真的全球分布（12个节点），且使用了CDN技术。
国内免费/收费域名解析服务提供商
DNSPod ：DNSPod是国内运营较久的免费DNS解析服务，除了免费服务外，还提供多项收费服务。DNSPod的功能较多，支持电信、网通、教育网双线或者三线智能DNS解析，在中国国内解析速度较快，但对于国外的Google爬虫来说经常出现无法访问的情况。
DNS.La ：也是类似DNSPod的免费DNS解析服务，可以为同时有电信、联通、教育网服务器的网站提供免费智能DNS的解析。
EDNS ：易名中国提供的免费域名解析服务，非易名中国用户也可使用。
HihostDNS ： 国外的第三方DNS解析平台可以免费使用，非域名直接用户也可以额外订购该第三方域名解析服务。特点是全中文界面，对国人及其友好，域名无需验证备案，解析速度快，全球27个DNS轮播节点，最快可以设置TTL解析1分钟生效，支持域名解析各种类型，支持带端口的网址显性或隐性转发。其次是性价比高，基本上没有哪个平台能比得过，最低3元/月的价格。非常适合域名解析速度过慢或解析不生效的情况下使用。
百度云加速 ：云加速也主要是CDN业务，顺带提供DNS域名解析，提供抗CC攻击、免费DNS解析、免费分省解析、防黑客攻击、黑链暗链防护、页面篡改防护服务，但是域名必须要有备案号才可以接入使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/772046eb7d7de5627f981978feb2cab0/" rel="bookmark">
			使用 EndNote 9 引用参考文献
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EndNote 9 是用于书写科技论文时的一把利器，现在我将这个EndNote使用方法分享给大家，希望能够提高各位学习EndNote的效率，如果有描述和阐述不正确的地方请各位批评指正！
基本使用规则介绍 【1】表示导入文献按钮，该按钮所在一栏为菜单栏
【2】搜索框，可以检索用户存入EndNote数据库中的论文，可以根据字段指定匹配搜索方式，比如可以通过author, title, year, journal等
【3】文献存储位置，可以根据用户需求创建指定的群组名称，将存储的参考文献从All references 拖入 指定群组内即可
【4】存储于某个群组中的参考文献，从左边的一列开始表示的意义是：小圆圈表示该行的文献是否阅读过，阅读过则可以通过点击小圆圈使其消失（有无阅读过根据自己对小圆圈的理解即可），作者名字，发表时间，文献全程，Rating（重要性，读者可根据文献对自己研究的重要程度分别就行标星，最高可以标注为5星）
【5】文献的自身信息，如果该部分信息不完整或者缺失那么当导入自己的论文时可能无法正常显示
导入参考文献 通过点击【1】中所示，导入按钮，即可出现如下图所示，这里我介绍本人常用的方法，如果各位有更多的方法，欢迎评论区留言
首先点击Import Option选择导入文献的格式，我通常在下载的文献为PDF格式然后点击Import File选择下载的文献即可点击Import按钮即可完成文献导入 注：我们有时下载的PDF导入之后没有出现如【5】中关于文献的详细参考信息，那么可以进行一下操作
登陆Web of Science按照自己的检索格式，完成检索 2. 按图中所示1，勾选所需文献，并点击2的导出按钮
3. 点击导入为 EndNote Desktop，将自动下载后缀为ciw格式的文件
4. 按照前一个部分所述步骤选择ISI-CE即可，并选择步骤3中的ciw文件即可导入
文献批注 通过点击【5】中的PDF文件即可出现。如果你导入时发现5中不存在你的PDF文件，通过选中本条文献记录，右键点击出现菜单选中File Attachments，然后选择Attach File将之前下载好的PDF文件与其绑定即可。选择红色框中的操作对文献中的进行批注即可 导出文献 选择所需要的记录，点击右键选择Copy或者Ctrl+C，粘贴入Word 指定引入文献的位置即可（我使用的是office 2016，WPS是否支持我不清楚，大家尝试之后可以评论留言）
【1】为导出参考文献格式的名称
【2】为更新全文参考文献的小标题值
【3】统计每篇文献在该次论文写作中引用的频数
参考文献格式 如果Word【1】中下拉菜单包含的样式不够怎么办呢？
点击Edit之后，点击Output Styles，然后点击Open Style Manager
弹出以下窗口，左侧为更多的参考文献或者期刊参考格式，右下角Style Info/Preview为所选参考格式的预览，Edit表示编辑某一个参考文献的格式
自定义参考文献格式 如果EndNote自带的参考文献格式无法满足你的投稿要求也没有关系，以下有两种办法
选择期刊或者会议提供的参考文献格式的package导入，自行百度，不在此赘述如果目标期刊没有给出具体的格式该怎么做呢？ 找到以前投稿该期刊或者会议的论文，并研究参考文献的格式，下面会阐述，这里不讲太多根据前一个部分的操作，我们任选一个序号格式看起来比较接近参考文献的，选择Edit根据下图提示，选择Bibliography下的Templates
这部分分别对应不同的引用文献的类型，笔者为了投 ICBBE 研究出的这里以期刊参考文献为例，其他大致相同，希望给各位抛砖引玉
ICBBE 2019年的文献参考格式如下图
我们选择22为例如下，首先观察该文献格式的排布方式顺序：Author.Year.Title.Journal.Volume,ISSUE(Year),Pages.DOI.
注意，每个类型数据之间有的是 , 有的是 . 一定要看清楚 Smyth, G.K. 2004. Linear Models and Empirical Bayes Methods for Assessing Differential Expression in Microarray Experiments.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/772046eb7d7de5627f981978feb2cab0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87423357fdf96a575f0630ca6dfb9785/" rel="bookmark">
			duilib设计器 DuiEditor简易教程 (DuiDesigner)  （一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DuiEditor简易教程 一，DuiEditor是什么？
DuiEditor是duilib界面库的界面设计器，编写过程中参考了老版DuiDesignner的大量代码，改名只是为了稍作区分，没有任何剽窃或不尊重原作者之意。其实这个工具已经写了好几年了，提不起太大的兴趣写什么教程，自己好用就行，毫无疑问的，设计器比手写xml大大的提高了效率。DuiEditor已经开源，任何公司或个人可以随意修改拷贝使用。
代码共享地址：
https://gitee.com/Liqs99/DuiLib_DuiEditor
https://github.com/xfcanyue/DuiLib_DuiEditor
https://download.csdn.net/download/mmcanyu/12524759
duilib设计器交流群：819272442
DuiEditor和老版DuiDesigner相比较有几个明显的优点：
1，控件和控件的属性维护太困难。如果duilib一直有专门的维护团队，这么写没什么问题。但是现在的duilib有大量的个人维护版本，一点小改动就要修改设计器，实在头大。为此，DuiEditor提供了文件载入的方式，duilib.xml保存了所有控件和控件属性，使用者只要修改这个文件就行了。
2，默认插入控件都是float方式，float布局其实用的非常的少。DuiEditor可以选择插入方式，默认是普通布局。
3，属性值冗余。DuiEditor会在保存文档时，与duilib.xml设置的默认属性比较，过滤掉默认属性。
4，DuiEditor嵌入了xml编辑界面，看起来有点像NodePad++，并且相应的加入了部分语法提示。会一点手写是非常必要的，特别是需要改动布局结构时，只用设计器是无法做到的。
大概就罗列这么几点。duilib的开发人员说起duilib设计器，总会说到有个DuiDesigner但是不好用。先别急着拒绝啊，你可以试用用看啊。
我的考虑，和你的需求，其实是一致的。你为什么不试试呢？
二，使用说明
界面展示：
这个与老版的DuiDesginer差别并不大，工具栏增加了放大缩小，float布局选项，以及设计和代码的切换。
接下来我们就以360界面为范例，从无到有做出来。这个范例可以从官方的demo中找到。
1，新建UI文件。
控件视图中选中window，设置属性值，size=800,572。
控件视图选择VerticalLayout，设置属性值，bkcolor=d1e8f5, bkcolor2=c6e0f1, bordercolor=768d9b, bordersize=1.
大致分析一下360的界面，这是一个典型纵向布局框架，标题栏、工具栏、客户区、状态栏。工具栏和客户区中间还有一条分割线。
控件视图选择VerticalLayout，在控件箱选中HorizontalLayout，然后在设计页面中单击鼠标左键，遍成功在VerticalLayout纵向布局容器中插入了一个子控件。依此操作5次即可。等一下，这样太繁琐了。我们点击工具栏的代码按钮，切换到手撸xml。
复制&lt;HorizontalLayout /&gt; ，在贴上四个&lt;HorizontalLayout /&gt;。
点击工具栏设计按钮，回到设计界面。
保存文件，就保存到skin.xml的同目录，命名为skin2.xml
2，设计标题栏
选择控件树中第一个HorizontalLayout，设置height=24。
在它的下面添加2个子控件HorizontalLayout，为了好区分，我们假设添加的第一个是HA，第二个是HB。
HA设置属性，childvaligin=true。
在HA中添加一个Control, width=16, height=16, 设置bkimage=icon.png。
在HA再添加一个Text控件，valign=true，text=360安全卫士7.3。
与范例对比一下，标题的字体颜色不对，logo图标太靠近边框了。
选中HA，设置inset="5,0,0,0"。
DuiEditor菜单---&gt;编辑---&gt;Inset Font Node，设置字体参数。
选中刚刚添加的Text控件，设置属性，font=0，textcolor=447aa1。
再看一下范例的界面，右上角求助和论坛是2个文本按钮，还有菜单、最小化、最大化、恢复大小、关闭。一共7个按钮。
选中HB，在它下面插入7个按钮。顺手把第1第2个按钮的text属性填上。
求助和论坛这2个文本按钮，范例中使用html标签实现的字体下划线。我们也照着做，第一个按钮text属性设置为“{u}求助{/u}”，showhtml=true。第2个按钮text属性设置为“{u}论坛{/u}”，showhtml=true。
选中menubtn，在属性窗口中找到normalimage，点击进入图片选择页面。
左边文件列表选中sys_dlg_menu.png，右侧IMAGE设置source="52, 0, 78, 17"，source指的是我们需要引用的区域。点击保存。
依次我们要设置normalimage，hotimage, pushimage三个属性图片，分别对应鼠标三种状态：普通状态，悬停状态，按下状态。
后面的几个按钮，依葫芦画瓢，分别设置按钮的三种状态图。效果如下图
看起来很丑啊，还要再微调一下。
选中HB，设置width=188, inset="0,1,3,0"。
menubtn，设置width=26, height=17。
minbtn，设置width=26, height=17。
maxbtn，设置width=26, height=17。
restorebtn，设置width=26, height=17。visible=false。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87423357fdf96a575f0630ca6dfb9785/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d75a44284d15aca04cd24d6da72f7dab/" rel="bookmark">
			计算机视觉（1）关于cvThreshold二值化函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机视觉（1）关于cvThreshold二值化函数 opencv中文说明中是这样说的：
Threshold 对数组元素进行固定阈值操作
void cvThreshold( const CvArr* src, CvArr* dst, double threshold, double max_value, int threshold_type );
src：原始 数组 (单通道 , 8-bit of 32-bit 浮点数)。 dst：输出数组，必须与 src 的类型一致，或者为 8-bit。 threshold：阈值 max_value：使用 CV_THRESH_BINARY 和 CV_THRESH_BINARY_INV 的最大值。 threshold_type：阈值类型 threshold_type=CV_THRESH_BINARY:如果 src(x,y)&gt;threshold ,dst(x,y) = max_value; 否则,dst（x,y）=0; threshold_type=CV_THRESH_BINARY_INV:如果 src(x,y)&gt;threshold,dst(x,y) = 0; 否则,dst(x,y) = max_value. threshold_type=CV_THRESH_TRUNC:如果 src(x,y)&gt;threshold，dst(x,y) = max_value; 否则dst(x,y) = src(x,y). threshold_type=CV_THRESH_TOZERO:如果src(x,y)&gt;threshold，dst(x,y) = src(x,y) ; 否则 dst(x,y) = 0。 threshold_type=CV_THRESH_TOZERO_INV:如果 src(x,y)&gt;threshold，dst(x,y) = 0 ; 否则dst(x,y) = src(x,y).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d75a44284d15aca04cd24d6da72f7dab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e4e2d550bd15d2af7b46f5959bde865/" rel="bookmark">
			SpringBoot 配置文件中 @profileActive@
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 @profileActive@ 是配合 maven profile 进行选择不同配置文件进行开发
application.properties 中配置 spring.profiles.active=@profileActive@ pom 中配置 我测试了下，不在pom中做如下配置，默认启动的也是 dev
[2020-06-29 09:31:38,008] [INFO ] [cn.yto.MainApplication] [main] [] [] The following profiles are active: dev
&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;profileActive&gt;dev&lt;/profileActive&gt; &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;profileActive&gt;prod&lt;/profileActive&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; 打包命令 mvn package -P dev -DskipTests mvn package -P prod -DskipTests 相关文章 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a4d4c401fc7d1ecf9c8df29acafb4a/" rel="bookmark">
			华为RH2288 V5服务器安装centos7.2系统安装网卡驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为RH2288 V5服务器，貌似官方说不支持centos7.2，所以装7.2的时候有些板载的网卡识别不了，通过ibmc查看板载网卡芯片型号为x722的，经过适配，这个资源一键执行脚本就可以激活，完全适配可用 这个包有3个文件（install_network.sh、ixx-2.10.19.82.tar.gz、package.tar.gz），安装时，给install_network.sh执行权限，直接执行即可（就是激活图中圈好这4个板载网卡）
资源地址：https://download.csdn.net/download/qq_28046487/12524022
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9c3f32910eef8c5d46c3da04989dad7/" rel="bookmark">
			QGraphicsScene管理QGraphicsItem(单击/选择/移动/缩放/删除）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言简述操作细节示例效果源码 疑问自解自答：那么正方形旋转参照的是哪个点那？ 前言 本文参考博文https://blog.csdn.net/liang19890820/article/details/53504323
简述 在图形视图框架中，QGraphicsScene 提供一个快速的接口，用于管理大量 item，QGraphicsItem 是场景中 item 的基类。
图形视图提供了一些典型形状的标准 item，当然，我们也可以自定义 item。除此之外，QGraphicsItem 还支持以下特性：
​ 鼠标按下、移动、释放和双击事件，以及鼠标悬浮事件、滚轮事件和上下文菜单事件
​ 键盘输入焦点和键盘事件
​ 拖放
​ 分组：通过父子关系，或 QGraphicsItemGroup
​ 碰撞检测
下面，一起来看看 QGraphicsScene 对 QGraphicsItem 的管理，主要包括：单击、选择、移动、缩放、删除等。
操作细节 为了实现以上功能，我们主要实现了 QGraphicsScene 和 QGraphicsItem 对应的事件，通过鼠标和键盘来操作。
操作细节主要包括：
​ 选择：点击左键、按 Shift 键可以单选，按下 Ctrl 可进行多选。
​ 添加：点击左键
​ 删除：点击右键，删除鼠标下的 item；当按下 Ctrl 选择多个 items 时，按下 Backspace 键，将选中的全部删除。
​ 移动：点击左键，选择 item，然后移动鼠标；当按下 Ctrl 选择多个 items 时，可以移动选中的 items。
​ 缩放：按 Alt 键，然后鼠标拖拽 item 的边界。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9c3f32910eef8c5d46c3da04989dad7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7667c5fcf5e0b10cf7ce342ea285069/" rel="bookmark">
			Xtrabackup介绍与原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Xtrabackup介绍
MySQL冷备、mysqldump、MySQL热拷贝都无法实现对数据库进行增量备份。在实际生产环境中增量备份是非常实用的，如果数据大于50G或100G，存储空间足够的情况下，可以每天进行完整备份，如果每天产生的数据量较大，需要定制数据备份策略。例如每周实用完整备份，周一到周六实用增量备份。而Percona-Xtrabackup就是为了实现增量备份而出现的一款主流备份工具，xtrabakackup有2个工具，分别是xtrabakup、innobakupe。
Percona-xtrabackup是 Percona公司开发的一个用于MySQL数据库物理热备的备份工具，支持MySQL、Percona server和MariaDB，开源免费，是目前较为受欢迎的主流备份工具。xtrabackup只能备份innoDB和xtraDB两种数据引擎的表，而不能备份MyISAM数据表。
二、Xtrabackup优点
（1）备份速度快，物理备份可靠
（2）备份过程不会打断正在执行的事务（无需锁表）
（3）能够基于压缩等功能节约磁盘空间和流量
（4）自动备份校验
（5）还原速度快
（6）可以流传将备份传输到另外一台机器上
（7）在不增加服务器负载的情况备份数据
三、Xtrabackup备份原理
Xtrabackup备份流程图：
（1）innobackupex启动后，会先fork一个进程，用于启动xtrabackup，然后等待xtrabackup备份ibd数据文件；
（2）xtrabackup在备份innoDB数据是，有2种线程：redo拷贝线程和ibd数据拷贝线程。xtrabackup进程开始执行后，会启动一个redo拷贝的线程，用于从最新的checkpoint点开始顺序拷贝redo.log；再启动ibd数据拷贝线程，进行拷贝ibd数据。这里是先启动redo拷贝线程的。在此阶段，innobackupex进行处于等待状态（等待文件被创建）
（4）xtrabackup拷贝完成ibd数据文件后，会通知innobackupex（通过创建文件），同时xtrabackup进入等待状态（redo线程依旧在拷贝redo.log）
（5）innobackupex收到xtrabackup通知后哦，执行FLUSH TABLES WITH READ LOCK（FTWRL），取得一致性位点，然后开始备份非InnoDB文件（如frm、MYD、MYI、CSV、opt、par等格式的文件），在拷贝非InnoDB文件的过程当中，数据库处于全局只读状态。
（6）当innobackup拷贝完所有的非InnoDB文件后，会通知xtrabackup，通知完成后，进入等待状态；
（7）xtrabackup收到innobackupex备份完成的通知后，会停止redo拷贝线程，然后通知innobackupex，redo.log文件拷贝完成；
（8）innobackupex收到redo.log备份完成后，就进行解锁操作，执行：UNLOCK TABLES；
（9）最后innbackupex和xtrabackup进程各自释放资源，写备份元数据信息等，innobackupex等xtrabackup子进程结束后退出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d238cebb256483d2bd4ccad7a08dabb1/" rel="bookmark">
			python操作excel获取每行的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import xlrd class ExelUtil(object): def __init__(self, excel_path=None, index=None): if excel_path == None: excel_path = r"D:\PycharmProjects\2020study\config\case_data.xls" if index == None: index = 0 self.data = xlrd.open_workbook(excel_path) self.table = self.data.sheets()[index] # 行数 self.rows = self.table.nrows #[[],[],[]] def get_data(self): result = [] for i in range(self.rows): col = self.table.row_values(i) print(col) result.append(col) if __name__ == '__main__': ec = ExelUtil() ec.get_data() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2cbc8e3b4daaf27c7b07bf80b2a4e75/" rel="bookmark">
			python 中列表与树状结构的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言数组结构与树状结构python 实现将一个数组元素添加到，树状结构中如何把一棵树还原成一个list 前言 我们再 html 端json 以及 mongodb 存储的时候 ，经常会遇到 json的嵌套树状结构，但是在 python 处理数据时 ，list 有很方便，两者的转换通常是难以避免的
而且，很多时候，我们需要把一个 list 数据嵌入到一个 树状结构中去。
所以实现了，这个把 list 作为一条路径嵌入 dict 中的方法
数组结构与树状结构 数组结构 = [ [中国，河南，鹤壁] ,
[中国，河南，郑州] ,
[中国，北京，朝阳] ,
]
树状结构 = { 中国 ：{ 河南 ：{ 鹤壁，郑州 } ， 北京 ：{ 朝阳 } } }
python 实现 将一个数组元素添加到，树状结构中 # 把一个 路径集合 变成一个 树状字典 # list 转 dict class MyTree: def __init__(self): self.tree={} # onepoint 是 list def append_Point_to_tree(self, onepoint): nowPositon = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2cbc8e3b4daaf27c7b07bf80b2a4e75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/302126020c8e6b2cd18cd4bfa9a6dbbf/" rel="bookmark">
			【洛谷】P1439 【模板】求最长公共子序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【洛谷】P1439 【模板题】求最长公共子序列 1.题意 给出两个序列，如何求出其最长公共子序列？
2.分析 本题其实很简单，关键是 思维的转换 。如果使用最基本的 O(N*N) 算法，会因为N较大而TLE。那么有没有一种更优的方法呢？回想如何求最长不下降子序列的过程。我讲到过如何使用 O(NlogN) 的算法求出最长子序列，可以参看我的博客。
结合本题的数据，可以猜到这肯定是要使用O(NlogN)的算法。那么能不能用求最长不下降子序列的方法去求最长公共子序列呢？是可以的。
因为本题给出的是求指定范围内数字的最长公共子序列，也就是两个序列的值有明显的关系特点。当把第一个子序列映射成1-n的序列时，那么序列2按照上面的映射关系就可以相应的修改成另外一个序列。因为第一个序列已经是有序的了（1-n）。所以我们只需要求第二个子序列的最长不下降子序列即可。
举例如下：
序列a[]: 3 1 2=&gt; 对应映射成 1 2 3【也就是3-&gt;1, 1-&gt;2, 2 -&gt; 3 】
序列b[]: 1 2 3=&gt; 按照映射关系可以修改成序列：2 3 1
因为映射后的序列a已经是有序的了，所以只需要求出序列b映射后的最长不下降子序列即可。
3.代码 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;map&gt; using namespace std; const int maxN = 1e3+5; int n; int a[maxN], b[maxN]; //输入两个数组的值 int tail[maxN];//tail[i]表示长度为i 的最长不下降子序列结尾中的最小值 map&lt;int,int&gt; tran;//做一个映射 void proc(){ int cnt = 1; for(int i = 1;i&lt;=n;i++){ tran[a[i]] = cnt; cnt ++; } for(int i = 1;i&lt;=n;i++){ b[i] = tran[b[i]]; } } int main(){ cin &gt;&gt; n; for(int i = 1;i&lt;= n;i++) cin &gt;&gt; a[i]; for(int i = 1;i&lt;= n;i++) cin &gt;&gt; b[i]; //step1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/302126020c8e6b2cd18cd4bfa9a6dbbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a49ef05bc2b652978b0fd0d619e6a59/" rel="bookmark">
			iview 动态实现增减输入框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端模版
要点说明(仅是自己在调试中总结的个人理解，非官方，认知有限)
v-model是用来绑定数据的，和数据结构中的字段名保持一致，否则无法取得数据prop和和v-model的字段名相同，由于这里是动态生成input标签，所以prop属性也应该是动态的，因为rules是根据prop来校验的，所以rules在formItem域中单独设置如果设置了非空的规则，输入数据后检查不通过，则应该是prop和v-model设置的不同原因导致为了使两个输入框同行显示，这里每列设置单独的formItem(尝试了N中写法实现的) &lt;Form ref="applyInfo" :model="applyInfo" :rules="rules"&gt; &lt;Card&gt; &lt;p slot="title"&gt; &lt;Icon type="ios-chatboxes"&gt;&lt;/Icon&gt; 生产者白名单新增 &lt;/p&gt; &lt;div id="produce"&gt; &lt;FormItem&gt; &lt;Row&gt; &lt;Col span="12"&gt; &lt;Button type="primary" @click="addProduceData"&gt;添加&lt;/Button&gt; &lt;/Col&gt; &lt;/Row&gt; &lt;/FormItem&gt; &lt;Row v-for="(item, index) in applyInfo.produceData.items" v-if="item.status" :key="index"&gt; &lt;Col span="6" &gt; &lt;FormItem label="topic" :prop="'produceData.items.'+index+'.value.topic'" :label-width=110 :rules="[{required:true,message:'topic不能为空',trigger:'blur'}]"&gt; &lt;Input v-model="item.value.topic" placeholder="输入topic名称"/&gt; &lt;/FormItem&gt; &lt;/Col&gt; &lt;Col span="6" offset=1&gt; &lt;FormItem label="白名单bns" :prop="'produceData.items.'+index+'.value.bns'" :label-width=110 :rules="[{required:true,message:'topic不能为空',trigger:'blur'}]"&gt; &lt;Input v-model="item.value.bns" placeholder="输入生产者bns白名单"/&gt; &lt;/FormItem&gt; &lt;/Col&gt; &lt;Col span="6" offset="1"&gt; &lt;Button type="error" @click="deleteRow(index)"&gt;删除&lt;/Button&gt; &lt;/Col&gt; &lt;/Row&gt; &lt;/div&gt; &lt;/Card&gt; &lt;/form&gt; js部分
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a49ef05bc2b652978b0fd0d619e6a59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/096295e4d5c695c02f31204e514653ec/" rel="bookmark">
			自定义QGraphicsItem
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言：简述自定义 QGraphicsItemBoundingRect() 和 Shape()的区别参照模型使用示例效果源码 前言： 本文参考https://blog.csdn.net/liang19890820/article/details/53132180
简述 继承 QGraphicsItem，自定义item。
自定义 QGraphicsItem 要实现自定义 item，需要覆盖 QGraphicsItem 的两个纯虚函数：
void paint()
QRectF boundingRect()
​ 注意：坐标为item坐标系
tips：关于信号/槽、事件、算法相关的内容，本节暂时不做讲解，放到后面章节。
BoundingRect() 和 Shape()的区别 参照模型 要实现这个效果很简单，可以逐步分解：
整体（最外侧的圆）眼睛（左眼/右眼）嘴（笑容） 分别计算出各部分的区域坐标、大小，然后根据形状进行绘制。
上述图案标识的是绝对位置，为了适应各种大小， 可以进行比例及相对位置换算，将各部分进行逐一转换。
使用示例 效果 下图显示了 3 个不同大小的笑脸：（不好意思，为了简便，没画眼球，成了柯大侠了，哈哈。）
源码 SmileItem.h：
#pragma once #include &lt;QGraphicsItem&gt; #include &lt;QRectF&gt; class SmileItem : public QGraphicsItem { public: explicit SmileItem(QGraphicsItem* parent = NULL); explicit SmileItem(const QRectF &amp; rect, QGraphicsItem * parent); explicit SmileItem(qreal x, qreal y, qreal w, qreal h, QGraphicsItem * parent); QRectF rect() const; void setRect(const QRectF &amp; rect); ~SmileItem(); protected: QRectF boundingRect() const; //override void paint(QPainter * painter, const QStyleOptionGraphicsItem * option, QWidget * widget); //override private: QRectF m_rect; mutable QRectF m_boundingRect; void updateRect(); inline void setRect(qreal ax, qreal ay, qreal w, qreal h); // 缩放比例 double m_dScale; // 左眼、右眼、嘴的中点 QPointF m_leftEyeCenter; QPointF m_rightEyecenter; QPointF m_smileCenter; // 眼睛的宽度、高度 double m_dEyeWidth; double m_dEyeHeight; // 嘴的高度、宽度 double m_dSmileWidth; double m_dSmileHeight; }; SmileItem.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/096295e4d5c695c02f31204e514653ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/757a51ec79b96055ca96447632a4449d/" rel="bookmark">
			顺序消息分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		顺序消息 消息有序指的是可以按照消息的发送顺序来消费(FIFO)。RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。
顺序消费的原理解析，在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue(分区队列)；而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。但是如果控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取，则就保证了顺序。当发送和消费参与的queue只有一个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。
下面用订单进行分区有序的示例。一个订单的顺序流程是：创建、付款、推送、完成。订单号相同的消息会被先后发送到同一个队列中，消费时，同一个OrderId获取到的肯定是同一个队列。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1386d349e843927f4d60674f42e4da3f/" rel="bookmark">
			plotly绘图原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：数据分析与统计学之美
来源：黄伟呢
r1.plotly库的相关介绍 1）相关说明 plotly是一个基于javascript的绘图库，plotly绘图种类丰富，效果美观；
易于保存与分享plotly的绘图结果，并且可以与Web无缝集成；
ploty默认的绘图结果，是一个HTML网页文件，通过浏览器可以直接查看；
2）plotly与matplotlib、seaborn的关系 需要注意的是，ployly绘图库与matplotlib绘图库、seaborn绘图库并没有什么关系。也就是说说plotly是一个单独的绘图库，有自己独特的绘图语法、绘图参数和绘图原理，因此我们需要单独学习它。
2.导入相关库 对于我们做数据分析的人员来说，一般用的都是离线绘图库。在线绘图库需要的话，可以自己百度研究。
import os import numpy as np import pandas as pd import plotly as py import plotly.graph_objs as go import plotly.expression as px from plotly import tools import warnings warnings.filterwarnings("ignore") 3.plotly绘图原理 1）ployly常用的两个绘图模块：graph_objs和expression graph_objs和expression是plotly里面两个很常用的绘图库，graph_objs相当于matplotlib，在数据组织上比较费劲，但是仍然比起matplotlib绘图更简单、更好看。这里说的费劲是相对于expression库来说的。expression库相当于seaborn的地位，在数据组织上较为容易，绘图比起seaborn来说，也更加容易。这里你心里有个印象即可，知道这两个绘图库很牛，就行了。
对于graph_objs绘图库，我们常命名为go(import plotly.graph_objs as go)；对于expression绘图库，我们常命名为px(import plotly.expression as px)。
2）graph_objs("go")库的绘图原理 ① 简单的案例说明 df = pd.read_excel("plot.xlsx") # 步骤一 trace0 = go.Scatter(x=df["年份"],y=df["城镇居民"],name="城镇居民") trace1 = go.Scatter(x=df["年份"],y=df["农村居民"],name="农村居民") # 步骤二 data = [trace0,trace1] # 步骤三 fig = go.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1386d349e843927f4d60674f42e4da3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dba30823c72bbd53aec439b449f9ad60/" rel="bookmark">
			Gradle IDEA war not found for the web module.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我之前用的Gradle作为编译器，导致了开启服务器时，Tomcat找不到web模块，就会导致开启服务器时候报类似 XXXX.war not found for the web module 的错误
因为Gradle编译器不会给你自动创建exploded目录，但是Tomcat找的时候是去哪个目录找的，所以改回用IDEA做编译器就好了，我之前也试过改Tomcat寻找war包的路径，但是出现了很多问题，所以索性最后直接用IDEA编译最后直接就好了。
至于我之前为什么用的Gradle编译器，我也没弄明白，正常IDEA默认的编译器就是IDEA，不过我最近建立的两个新项目默认都是Gradle，希望对大家有帮助
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/916ba132c207c99cda421a10fe192b7e/" rel="bookmark">
			图形算法与实战：1.滤波专题 (2)中值滤波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2 中值滤波 本文作者：图像与视觉InSight 行者 杨尚朋 转载请注明
目录
2 中值滤波
2.1 处理效果展示
图像处理前后对比1
图像处理前后对比2
2.2 中值滤波原理
2.3 代码展示
2.1 处理效果展示 图像处理前后对比1 图1 原图
图2 椒盐噪声处理图
图3 对椒盐噪声图像用中值滤波处理
图像处理前后对比2 图4 原图
图5 用椒盐噪声处理后的图像
图6 对椒盐噪声图像用中值滤波处理
2.2 中值滤波原理 中值滤波法是一种非线性平滑技术，它将每一像素点的灰度值设置为该点某邻域窗口内的所有像素点灰度值的中位值。
中值滤波，是基于排序统计理论的一种能有效抑制噪声的非线性信号处理技术。中值滤波的基本原理是把数字图像或数字序列中一点的值用该点的一个邻域中各点值的中位值代替，让周围的像素值接近的真实值，从而消除孤立的噪声点。
中值滤波是用某种结构的二维滑动模板，将模版内像素按照像素值的大小进行排序，生成单调上升（或下降）的为二维数据序列。二维中值滤波输出为g（x,y）=med{f(x-k,y-l),(k,l∈W)} ，其中，f(x,y)，g(x,y)分别为原始图像和处理后图像。W为二维模板，通常为3×3，5×5区域，也可以是不同的的形状，如线状，圆形，十字形，圆环形等。
2.3 代码展示 #include &lt;opencv2\opencv.hpp&gt; #include &lt;opencv2\highgui\highgui.hpp&gt; #include &lt;opencv2\imgcodecs\imgcodecs.hpp&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;math.h&gt; #include&lt;iomanip&gt; using namespace cv; using namespace std; void salt( Mat image, int n); void pepper( Mat image, int n); int main() {	Mat image = imread("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/916ba132c207c99cda421a10fe192b7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/145b9b840d09b26c71773dc87558bb78/" rel="bookmark">
			Java实现简单的GUI登录和注册界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看效果图： 登陆界面:
注册界面：
实现代码如下： 一、登陆界面： package cn.bms.view; import java.awt.Color; import java.awt.Dimension; import java.awt.Font; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import javax.swing.ImageIcon; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JTextField; import javax.swing.border.MatteBorder; import cn.bms.tools.GUITools; /* * 登录窗口 */ @SuppressWarnings("serial") public class AdminLogin extends JFrame { private JPanel contentPanel = new JPanel(); // Label标签存放背景图片 private JLabel label; // 设置按钮组件 private JButton login = new JButton("登录"), register = new JButton("注册"); private JLabel jlb1 = new JLabel("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/145b9b840d09b26c71773dc87558bb78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99b97e3135a387a6b6456b932848476c/" rel="bookmark">
			解决测试dns服务时出现；； connection timed out；no servers could be reached错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天打开linux，兴高采烈的想测试一下昨天配好的dns服务，结果出现了这个错误，甚至连网都连不上了
就很气，在网上找了半天答案也没有解决，后来突然想起来自己没有开启dns服务（我也不知道我为啥没设置开机启动），然后急忙开启了dns服务（service named restart）
然后果然可以进行正常的测试了
但是，开启dns服务之后必须等一会才可以联网。
好了，这就是我的经验，希望可以帮到大家。也希望有哪位大佬跟我说一下，如何把dns设置成开机启动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6696005c67184b96de83554593ba0c68/" rel="bookmark">
			VSCode 快速创建和运行 flutter 项目和热更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		省略 下载，配置环境变量，设置代码提示 等步骤。。。
第一步：在终端上切换到需要创建 Flutter 项目的文件夹
第二步：创建 flutter 项目 -&gt; 运行 【flutter create 项目名】 命令
第三步：运行 flutter 项目 -&gt; 运行 【flutter run】命令
第四步：实现热更新 -&gt; 不终止项目的情况下输入【r】
补充： p 网格，o IOS风格
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aa5679b81067ec70cd8edfaa8fdf81f/" rel="bookmark">
			模糊算子计算逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矩阵的基本计算方式大家知道吧，左边矩阵的行数和右边的矩阵的列数相等，然后左边的行和右边的列依次进行计算。
然后算子中，∧表示取小，∨表示取大，· 表示相乘，圆圈中一个加号表示求和。
第一个算子是先取小再取大。这张图为例，先看等号左边，左边的第一个数字0.3和右边第一列的第一个数字0.5进行比较，取小者为结果，就是0.3；然后左边的第二个数字0.3和右边第一列的第二个数字0.3进行比较，取小者，为0.3；左边第三个数字0.4和右边第一列第三个数字0.2进行比较，取小为0.2；取小过程结束，然后再取大，就是这三个结果进行比较，取大者为最终结果：因为上边算出的三个结果分别是0.3，0.3，0.2，取大者即为0.3。这便是等号右边第一个数字0.3的由来。
同样的，左边矩阵与右边矩阵的第二列依次比较取小后再取大，便得出了等号右边第二个数字0.3.以此类推。
第二个算子是先相乘再取大。同上边的计算方法一样，不同的只在于上边是取小，这里是相乘，即左边的第一个数字0.3和右边第一列的第一个数字0.5相乘，左边的第二个数字0.3和右边第一列的第二个数字0.3，左边第三个数字0.4和右边第一列第三个数字0.2相乘，然后这三个结果中取大。
第三个算子是先取小再求和，也是一样的：第一步得出的三个结果是0.3，0.3，0.2，将这三个求和即得等号右边第一个数字0.8。不过这个求和要注意，如果求和得出的结果比1大，那么结果是取1。
第四个算子是先相乘再求和。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42b13e66fcacbc43bc6c8ffcd489e33c/" rel="bookmark">
			scrapy中如何设置应用cookies
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文：https://blog.csdn.net/Thoms_/article/details/82977036
本人是python3.6
总的来说，scrapy框架中设置cookie有三种方式。
第一种：setting文件中设置cookie
当COOKIES_ENABLED是注释的时候scrapy默认没有开启cookie
当COOKIES_ENABLED没有注释设置为False的时候scrapy默认使用了settings里面的cookie
当COOKIES_ENABLED设置为True的时候scrapy就会把settings的cookie关掉，使用自定义cookie
所以当我使用settings的cookie的时候，又把COOKIES_ENABLED设置为True，scrapy就会把settings的cookie关闭，
而且我也没使用自定义cookie，导致整个请求根本没有cookie,导致获取页面失败。
总结：
如果使用自定义cookie就把COOKIES_ENABLED设置为True
如果使用settings的cookie就把COOKIES_ENABLED设置为False
第二种：middlewares中设置cookie
在middlewares中的downloadermiddleware中的process_request中配置cookie，配置如下：
request.cookies={
'':'',
'':'',
}
等等。里面的cookie内容要以键值对的形式存在。
第三种：在spider爬虫主文件中，重写start_request方法，在scrapy的Request函数的参数中传递cookies
# 重载start_requests方法 def start_requests(self): headers = { "User-Agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:59.0) Gecko/20100101 Firefox/59.0"} # 指定cookies cookies = { 'uuid': '66a0f5e7546b4e068497.1542881406.1.0.0', '_lxsdk_cuid': '1673ae5bfd3c8-0ab24c91d32ccc8-143d7240-144000-1673ae5bfd4c8', '__mta': '222746148.1542881402495.1542881402495.1542881402495.1', 'ci': '20', 'rvct': '20%2C92%2C282%2C281%2C1', '_lx_utm': 'utm_source%3DBaidu%26utm_medium%3Dorganic', '_lxsdk_s': '1674f401e2a-d02-c7d-438%7C%7C35'} # 再次请求到详情页，并且声明回调函数callback，dont_filter=True 不进行域名过滤，meta给回调函数传递数据 yield Request(detailUrl, headers=headers, cookies=cookies, callback=self.detail_parse, meta={'myItem': item}, dont_filter=True) 同时还要在setting中设置：
ROBOTSTXT_OBEY=False 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b817dca1772e33fd4d0aa29ab84647fe/" rel="bookmark">
			lotus-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一些概念与主要结构
1、复制证明与时空证明
1、复制证明(PoRep)：一种新颖的存储证明，它允许服务器(即证明者P)说服用户(即验证者V)某些数据D已被复制到其自己的唯一专用物理存储设备上了
addpiece
preCommit1
preCommit2
Commit1
Commit2 Fetch
2、时空证明(PoSt)：要求存储矿工每隔一段时间(例如5分钟)来发送一次存储证明到区块链网络,但是Filecoin每次交互的通信都比较复杂，有各种加密
签名,如此频繁的 网络通信将会成为整个系统的瓶颈，所以需要调整 epoch(时间间隔) 的值，使系统达到一个平衡点，或者使用其他的更优的解决方案。 2、message：可以把它理解成一条信息,比如A向B转一笔账,然后Filecoin就往区块链上记录一条message,就像以太坊上发送一笔交易(send a transaction)一样。
actor定义(lotus/chain/types/actor.go)：
type Actor struct {
Code cid.Cid `refmt:",omitempty"` //待执行的智能合约代码(对应的枚举:https://github.com/filecoin-project/specs-actors/actors/builtin/codes.go)
Head cid.Cid `refmt:",omitempty"` //
Nonce types.Uint64 //这个跟以太坊一样，用来对抗重放攻击
Balance *types.AttoFIL //账户余额
} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a20424a233652bff01f9897bdfbd2986/" rel="bookmark">
			button绑定onclick无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我遇见一个问题，在测试onclick和addEventListener(‘click’,fn)是否生效的时候，发现onclick的方法一直无法触发，我以为是不能同时生效
box.addEventListener( 'click', () =&gt; { console.log(1) }) &lt;button type="submit" id="box" οnclick="click()"&gt;321312&lt;/button&gt; function click() { console.log(4) } 然后我继续测试 ，发现是取名的问题，fn在取名的时候不应该和dom中的属性同名，否则可能会导致一些错误
当我把fn名称改为btnClick的时候就生效了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6be64e693c1eea0ac6dfc172e9fa6225/" rel="bookmark">
			下一个手机游戏选择哪个平台？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本文中，我们探索了几个游戏引擎和框架，重点介绍了它们各自提供的一些关键优势。 阅读本文之后，您将有几个选择可供选择，以取得更大的成功。 请注意，我们仅关注这些平台的2D方面。 让我们开始吧。 1. Cocos2D Cocos2d是一个免费的开源框架，与Swift和Objective-C都兼容。 它支持iOS和OS X，并且还通过SpriteBuilder Android插件支持Android，前提是您的代码是用Objective-C编写的。 Swift正在为Android提供支持。 Cocos2d中的项目是通过SpriteBuilder创建的， SpriteBuilder是一个图形设计环境，您可以使用它来快速制作原型和构建游戏。 您不需要使用SpriteBuilder来构建游戏，但是，必须通过SpriteBuilder完成项目创建。 场景管理通过CCDirector类完成，该类可以与CCTransition类一起使用众多Transitions。 它通过CCAnimation类及其CCAnimation类提供动画，包括移动，缩放和旋转等CCAction 。 Cocos2D中具有与粒子系统支持CCParticleSystem类，并有瓷砖的地图，支持CCTiledMap类。 Cocos2d还使用OpenGL作为其渲染引擎。 它使用Chipmunk作为其物理引擎。 如果您喜欢Objective-C或Swift，并且想要针对多个平台（iOS和Android）进行开发，那么Cocos2d是值得考虑的框架。 2. Cocos2d-x Cocos2d-x是Cocos2d的C ++端口，可以编译到许多其他平台。 Cocos2d-x可以编译为iOS，Android，Windows Phone，OS X，Windows和Linux。 SpriteBuilder不附带Cocos2d-x。 但是，它确实有一些有趣的项目，例如Cocos Creator ，它提供了框架，场景编辑，调试，游戏预览以及发布到多个平台。 3.团结 Unity是一个移动游戏引擎，支持C＃和UnityScript ，这是一种专门为Unity设计并以JavaScript建模的语言。 它是跨平台的，可以部署到许多平台，包括PlayStation和Xbox。 提供免费版本和提供更多功能的专业版本。 有关更多信息，请访问Unity 网站 。 有一个内置的精灵编辑器 ，您可以在其中可视化地切片图像，还可以使用动画制作器窗口来布局和组织动画，以及将关键帧动画添加到精灵中。 也可以在Unity编辑器中直观地设计粒子系统 。 Unity使用自己的专有物理引擎。 Unity具有内置的摄像头，这使得在游戏世界中的导航变得简单。 您可以在视觉上对场景进行布局，Unity的用户界面系统包含按钮，滑块和菜单等组件。 Unity编辑器中还支持精灵打包 。 在游戏引擎方面，Unity是强大的力量。 如果您需要一种跨平台的解决方案，该解决方案能够支持多种设备，并且希望使用C＃或UnityScript进行编程，那么Unity是一个不错的选择。 关于Unity的另一件事是资产商店 ，您可以在其中找到或购买可以在游戏中使用的资产。 4. SpriteKit SpriteKit是Apple专有的2D游戏开发框架。 它仅在iOS和OS X上可用。SpriteKit同时支持Swift和Objective-C。 现场管理与done SKView类，并有多种与过渡SKTransition类。 SpriteKit的核心是动作，即SKAction类的实例，用于移动，旋转和缩放游戏对象。 动作也可以用来播放声音和执行自定义代码。 SpriteKit具有一个场景编辑器，您可以在其中直观地设计游戏的关卡。 还可以使用粒子编辑器，在其中可以直观地设计粒子系统。 可以使用许多预先设计的粒子系统，例如火和雨。 SpriteKit使用Box2D作为其物理引擎。 SpriteKit为Box2D提供了一个友好的包装器，使它非常易于使用。 SpriteKit还具有一个通过SKCameraNode类的内置摄像头，可以轻松浏览游戏世界。 如果您与Apple生态系统息息相关，那么SpriteKit是一个很好的选择。 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6be64e693c1eea0ac6dfc172e9fa6225/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67a89585f7265b4bd84141d102a803dc/" rel="bookmark">
			Xavier NX安装opencv3.4.7~3.4.15
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xavier NX自带的opencv4的版本，版本太高。项目程序使用的版本是opencv3。只能重新安装配置opencv3的版本，以ubuntu1804系统——配置opencv3.4.7（此配置流程也适用于opencv3.4.15版本）为例进行说明：
下载地址：Releases - OpenCV解压下载的zip包 unzip opencv-3.4.7.zip
安装所有的依赖包： 1）sudo apt-get install build-essential
2）sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev
3）sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev
4）sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev liblapacke-dev
5）sudo apt-get install libxvidcore-dev libx264-dev
6）sudo apt-get install libatlas-base-dev gfortran
7）sudo apt-get install ffmpeg
cd /home/yd/opencv-3.4.7sudo apt-get install cmakesudo mkdir buildcd buildsudo cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67a89585f7265b4bd84141d102a803dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ad58e40620e3ba764cbb50ff4d89d87/" rel="bookmark">
			修改NuGet包缓存位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 NuGet包太大了，占用了大量的C盘空间。将他们迁移到D盘去才好呀。
NuGet包默认缓存位置：C:\Users\{username}\.nuget\packages
本地包的默认位置：C:\Program Files (x86)\Microsoft SDKs\NuGetPackages //使用VS 工具 选项 Nuget包管理器 这里面也可以看到 配置文件地址：C:\Program Files (x86)\NuGet\Config 1、修改本地包的默认位置
将C:\Program Files (x86)\Microsoft SDKs\NuGetPackages内容剪切到D:\Program Files (x86)\Nuget\NuGetPackages下面。
将Microsoft.VisualStudio.Offline.config复制到桌面，然后修改 Microsoft.VisualStudio.Offline.config配置中的本地包的默认位置为“D:\Program Files (x86)\Nuget\NuGetPackages”；保存后替换掉原来的文件。 在原目录下不允许直接修改文件
2、修改NuGet包默认缓存位置
将C:\Users\{username}\.nuget\packages下的文件剪切到D:\Program Files (x86)\Nuget\.nuget；否则会重新下载项目中用到的NuGet包。
在桌面创建文件：NuGet.Config ; 内容如下; 复制到C:\Program Files (x86)\NuGet\Config 下
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;configuration&gt; &lt;config&gt; &lt;add key="globalPackagesFolder" value="D:\Program Files (x86)\Nuget\.nuget" /&gt; &lt;/config&gt; &lt;/configuration&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7837de6f4cce6fbf58f4d48917f95a0d/" rel="bookmark">
			shell-$0, $#, $*, $@, $?, $$的含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、$0
当前脚本的文件名
2、$n
传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。
3、$#
传递给脚本或函数的参数个数。
4、$*
传递给脚本或函数的所有参数。
5、$@
传递给脚本或函数的所有参数。
6、$* 和 $@ 的区别
$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(" “)包含时，都以”$1" “2&amp;quot;…&amp;quot;2&amp;quot; … &amp;quot;2"…"n” 的形式输出所有参数
当它们被双引号(" “)包含时，”$*" 会将所有的参数作为一个整体，以"$1 $2 … n&amp;quot;的形式输出所有参数；&amp;quot;n&amp;quot;的形式输出所有参数；&amp;quot;n"的形式输出所有参数；"@" 会将各个参数分开，以"$1" “2&amp;quot;…&amp;quot;2&amp;quot; … &amp;quot;2"…"n” 的形式输出所有参数。
7、$?
上个命令的退出状态，或函数的返回值。
8、$$
当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。
下面写个脚本测试一下 vim parameter.sh
#!/bin/bash echo $0 echo $1 echo $2 echo "参数nums:$#" echo "*"$* for M in $* do echo $M done echo "@" $@ for M in $@ do echo $M done echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7837de6f4cce6fbf58f4d48917f95a0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35e5c213e2d49c6a3e73bcf9125c9e67/" rel="bookmark">
			使用Python和Numpy构建神经网络模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一：波士顿房价预测任务1：线性回归模型2：线性回归模型的神经网络结构 二：构建波士顿房价预测任务的神经网络模型1：数据处理2：读入数据3：数据形状变换4：数据集划分5：数据归一化处理6:：封装成load data函数7：模型设计8：训练配置9：训练过程10：梯度下降法11：计算梯度12：使用Numpy进行梯度计算13：确定损失函数更小的点14：代码封装Train函数15：随机梯度下降法（ Stochastic Gradient Descent）16：数据处理代码修改17:训练过程代码修改 一：波士顿房价预测任务 上一节我们初步认识了神经网络的基本概念（如神经元、多层连接、前向计算、计算图）和模型结构三要素（模型假设、评价函数和优化算法）。本节将以“波士顿房价”任务为例，向读者介绍使用Python语言和Numpy库来构建神经网络模型的思考过程和操作方法。
波士顿房价预测是一个经典的机器学习任务，类似于程序员世界的“Hello World”。和大家对房价的普遍认知相同，波士顿地区的房价是由诸多因素影响的。该数据集统计了13种可能影响房价的因素和该类型房屋的均价，期望构建一个基于13个因素进行房价预测的模型，如 图1 所示。
图1：波士顿房价影响因素示意图
对于预测问题，可以根据预测输出的类型是连续的实数值，还是离散的标签，区分为回归任务和分类任务。因为房价是一个连续值，所以房价预测显然是一个回归任务。下面我们尝试用最简单的线性回归模型解决这个问题，并用神经网络来实现这个模型。
1：线性回归模型 假设房价和各影响因素之间能够用线性关系来描述：
模型的求解即是通过数据拟合出每个w和b。其中，wj和b分别表示该线性模型的权重和偏置。一维情况下，wj 和 b 是直线的斜率和截距。
线性回归模型使用均方误差作为损失函数（Loss），用以衡量预测房价和真实房价的差异，公式如下：
思考：
为什么要以均方误差作为损失函数？即将模型在每个训练样本上的预测误差加和，来衡量整体样本的准确性。这是因为损失函数的设计不仅仅要考虑“合理性”，同样需要考虑“易解性”，这个问题在后面的内容中会详细阐述。
2：线性回归模型的神经网络结构 神经网络的标准结构中每个神经元由加权和与非线性变换构成，然后将多个神经元分层的摆放并连接形成神经网络。线性回归模型可以认为是神经网络模型的一种极简特例，是一个只有加权和、没有非线性变换的神经元（无需形成网络），如 图2 所示。
图2：线性回归模型的神经网络结构
二：构建波士顿房价预测任务的神经网络模型 深度学习不仅实现了实现模型的端到端学习，还推动了人工智能进入工业大生产阶段，产生了标准化、自动化和模块化的通用框架。不同场景的深度学习模型具具备一定的通用性，五个步骤即可完成模型的构建和训练，如 图3 所示。
图3：构建神经网络/深度学习模型的基本步骤
正是由于深度学习的建模和训练的过程存在通用性，在构建不同的模型时，只有模型三要素不同，其它步骤基本一致，深度学习框架才有用武之地。
1：数据处理 数据处理包含五个部分：数据导入、数据形状变换、数据集划分、数据归一化处理和封装load data函数。数据预处理后，才能被模型调用。
说明：
本教程中的代码都可以在AIStudio上直接运行，Print结果都是基于程序真实运行的结果。
由于是真实案例，代码之前存在依赖关系，因此需要读者逐条、全部运行，否则会导致Print时报错。
2：读入数据 通过如下代码读入数据，了解下波士顿房价的数据集结构，数据存放在本地目录下housing.data文件中。
# 导入包 import numpy as np import json # 读入数据 filedata ="/home/aistudio/data/data2943/housing.data" data=np.fromfile(filedata) print(data) 3：数据形状变换 由于读入的原始数据是1维的，所有数据都连在一起。因此需要我们将数据的形状进行变换，形成一个2维的矩阵，每行为一个数据样本（14个值），每个数据样本包含13个X（影响房价的特征）和一个Y（该类型房屋的均价）。
# 读入之后的数据被转化成1维array，其中array的第0-13项是第一条数据，第14-27项是第二条数据，以此类推.... # 这里对原始数据做reshape，变成N x 14的形式 feature_names = [ 'CRIM', 'ZN', 'INDUS', 'CHAS', 'NOX', 'RM', 'AGE','DIS', 'RAD', 'TAX', 'PTRATIO', 'B', 'LSTAT', 'MEDV' ] feature_num = len(feature_names) data = data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35e5c213e2d49c6a3e73bcf9125c9e67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f65cb45c17b7f1ff8728b3d5859dfe00/" rel="bookmark">
			Qt——错误总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 此问题均是笔者遇到的，解决成功的方案。
问题一：driver not loaded 问题分析：
QT要成功连接mysql，需要3个dll文件配合
QT: qsqlmysql.dll qsqlmysqld.dll (我的路径：E:\Qt\5.6.3\msvc2015_64\plugins\sqldrivers目录下）
mysql: libmysql.dll （我的路径：E:\mysql\mysql-5.7.15-winx64\lib目录下）
解决办法:
把mysql安装路径的 libmysql.dll 拷贝到qt的安装路径 E:\Qt\5.6.3\msvc2015_64\bin下
如果还不能解决问题，这很有可能是 qt的版本与mysql不兼容。去mysql官网https://dev.mysql.com/downloads/connector/cpp/下个mysql-connector-c-6.1.6-win32.msi装一下，装好后安装目录中找到libmysql.dll，然后拷贝到qt的安装路径 E:\mysql\mysql-5.7.15-winx64\lib下
问题二：VS+Qt创建项目时，Include提示错误：无法打开源文件 解决方案：
右击解决方案 —&gt;属性（到达项目属性页面）—&gt;配置属性(左侧) —&gt;C/C++ —&gt; 常规—&gt; 附加包含目录。
将Qt的Include文件路径添加进去（qt的include路径在安装路径下面，我的是 E:\Qt\Qt5.5.1\5.5\msvc2010\include）
问题三：VS+QT无法找到ui_XXXX.h头文件问题（使用Qtpackage建立的qt项目） 解决方案：
在VS下，右键 .ui文件 -&gt; 编译
把Generated Files下生成的ui_XXXX.h文件移到Header Files (点着ui_XXXX.h文件拖到Header Files就行）
问题四：VS+QT使用qDebug()的设置 解决方法：
想在QT程序中使用qDebug()&lt;&lt; ,需要有头文件和参数才可以。
首先要包含头文件：#include &lt;qdebug&gt;
然后：配置属性-&gt;C/C++ -&gt;预处理器（第三项） -&gt;预处理定义（第一项）
在新的一行中添加Console 就可以了。
问题五：VS+QT#include QNetworkAccessManager&gt;报错 解决办法：
实际上会报错是因为包含没写全：
#include &lt;QtNetwork/QNetworkAccessManager&gt;
问题六：VS+QT"WFlags" ：不是"Qt"的成员 解决办法。
把Qt::WFlags 改成 Qt::WindowFlags即可
问题七：关于vs2019自动更新qt扩展为2.51产生的问题，error reading VS project settings 解决方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f65cb45c17b7f1ff8728b3d5859dfe00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3892cb3ab0aa63c075eea59b9095d118/" rel="bookmark">
			lecture 5 ： policy gradient introduction
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lecture 5 ： policy gradient introduction 求 时运用了 如下一个技巧：
于是，
由于 则 变为：
在代码实现的时候，用trajactory的平均来估计，即：
接下来又分析了 vanila policy gradient 方法 的 high varience ：
直观上的理解就是，某个概率分布（如图中的r(r), 受数据的偏移影响较大）
为了减少varience, 开始如下分析：
由于某个时刻 前面的reward 对现在时刻的微分没有影响，所以 变为：
之后又加了baseline， 如下所示： b 可以取任何值(不依赖于cita) , 为什么要减？因为要减少varience （计算方差的公式前面的平方项的效果不后面那一项大)
减去b 之后，有无影响？ 没有（也可以认为 是 unbiased 的项) ，因为：
/******************************************************************************************************************/
课程中也讨论了， b 该取何值？从计算方差的定义出发：
后面那一项，与没有减之前相等，所以消去，前一项对b 求偏导得 ：
直观的理解就是 weighted expeted reward, weight 由 gradient 决定。
/******************************************************************************************************************/
以上policy gradient 是 on-policy 方法， 即由 pilicy 运行产生的data 进行训练，所以此时的方法 是data inefficient 的因为它用过一个数据之后就把它丢弃了。 一个解决方法是 off-policy的 policy gradient 方法： important sampling: 通过其他的分布来估计现有分布的值。 可以看到 的微分由 的分布决定。 至此，算法变为了off-policy, 即通过不是该策略产生的数据来训练参数。通过等式可以看出，要通过importance ratio 进行调整。其中 ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3892cb3ab0aa63c075eea59b9095d118/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/965be8df9a799ae36537b9da61b847c4/" rel="bookmark">
			工作三年四面（技术面）里巴巴拿offer阿定级P6，月薪36K（Java岗）章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里技术岗位要求及体系图：
好多人对阿里巴巴技术岗的体系结构及级别的技术要求设置不太清楚，想去面试也不知道面试什么级别的岗位，下面说说阿里的技术体系又是一个怎么样的水平划分！
阿里P6(技术主管)
工作要求：
能独立解决问题，制定系统的技术实现方案，考核会涉及部分技术深度。
技能要求：
除P5的技能外，还需掌握以下技能，以下技能至少需要做到熟悉。
架构设计，运维能力，操作系统。
技术四面面试题如下
一面（问了数据结构、jvm、锁等）：
1.自我介绍和项目
2.HashMap底层如何实现？
3.Hash一致算法？
4.说说HashMap和ConcurrentHashMap的区别？treemap和HashMap的区别？
5.java的内存分区？
6.java对象的回收方式，回收算法？
7.CMS和G1了解吗？
8.CMS解决什么问题，说一下回收的过程？
9.CMS回收停顿了几次？
10.java栈什么时候会内存溢出，java堆呢，说一种场景？
11.集合类如何解决这个问题（软引用和弱引用），讲下这个两个引用的区别？
12.java里的锁了解哪些?
13.synchronized锁升级的过程（偏向锁到轻量锁再到重量级锁），分别如何实现的，解决的是哪些问题？
14.Tomcat的基本架构是什么？
15.什么是类加载器？
16.说说双亲委派模型机制？
17.GC的机制是什么？GC算法和回收策略？
18.未来的职业规划？
二面（线程、数据库、缓存、协议等）：
1.讲一下项目
2.线程池由哪些组件组成？
3.有哪些线程池，分别怎么使用？拒绝策略有哪些？
4.什么时候多线程会发生死锁，写一个例子？
5.Redis的数据结构是什么？线程模型说一下？
6.讲讲Redis的数据淘汰机制？
7.说说Redis的数据一致性问题？
8.Redis的分布式怎么做？
9.RPC讲一下？
10.三次握手和四次挥手？如果没有三次握手有问题吗?
11.Http请求过程，DNS解析的过程？
12.InnoDB支持的四种事务隔离级别名称是什么？有什么区别？说说MySQL隔离级别？
13.事务的特性及慢查询？
14.BTree机制说一下？
15.说说MySQL常用的优化方法？
三面（分布式，消息队列等）：
1.自我介绍
2.cap了解吗，分别指什么？
3.强一致性和弱一致性有什么方法来实现的？
4.负载均衡怎么实现？为什么这么做？
5.缓存雪崩说下？
6.MySQL主从复制怎么实现的？具体原理是什么？有什么优缺点？
7.讲讲分布式事务？
8.消息队列，用到什么场景（削峰，限流，异步）？
9.zk的性能瓶颈怎么克服？
10.讲了下kafka，怎么保证数据不丢失？确保消息不会重复消费？
11.消息送达确认是怎么实现的？
四面（从项目讲起）：
1.说了自己的项目
2.主要用到的架构，做了些什么？
3.比较复杂的业务逻辑讲一下？
4.遇到很难解决的问题和突破收货
5.以后的打算和未来的职业发展，谈谈自己的看法
并发编程：
1.什么是多线程并发和并行？
2.什么是线程安全问题？
3.什么是共享变量的内存可见性问题？
4.什么是Java中原子性操作？
5.什么是Java中的CAS操作,AtomicLong实现原理？
6.什么是Java指令重排序？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/965be8df9a799ae36537b9da61b847c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a26ee95b077ae9a5ba7a4e28706b223/" rel="bookmark">
			Java实现的表达式求值算法（包括加减乘除以及括号运算）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、表达式求值简单说明： 1、求值表达式主要包括加减乘除四种基本运算，其实表达式可以看做由一个个二元运算构成，前一个二元运算的结果作为后一个二元运算的输入。
举个例子： “1+2-4=”，“1+2”就是一个二元运算，1和2是操作数，+是运算符，它们的运算结果3作为下一个二元运算的输入，所以下一个二元运算是“3-4”，这样经过两次二元运算后得出结果-1，此时碰到表达式结束符号“=”，那么表达式运算结束，最终值为-1。当然有时候表达式不是以等号作为结束符号的，这种场景要特别注意下。
2、加减乘除四种运算符是有优先级的，乘法和除法同级，且比加法和减法优先级高，也就是说同级的运算顺序是从左到右，高优先级的二元运算优先执行。
举个例子：“1+2*3=”，“2*3”这个二元运算因为乘法的优先级高，所以优先执行，执行结果作为+二元运算的第二个操作数。
3、括号运算其实相当于嵌套一个子表达式，而子表达式的优先级比括号外的加减乘数二元运算高，子表达式的计算结果作为主表达式的一个操作数。
4、由上面的说明可知，表达式有两个基本元素，那就是操作数和运算符，运算符一般占用一个字符，而操作数可能是1, 2, 3这样的个位整数，也可能是1.0, 1.89这样的浮点数，也可能是100, 189这样的多位整数。所以我们在从表达式解析出操作数时要完整的解析出整个操作数。
5、表达式一般以等号作为表达式结束标记，当然有不以等号作为结束标记的场景，详情看下面代码处理逻辑。
二、算法思想简单说明： 1、表达式由正则模式 "[0-9\\.+-/*()= ]+" 来校验合法性。
2、表达式的操作数将push到一个数值栈中，而运算符将push到运算符栈中，解析表达式时，采用逐个读取字符的形式，特别注意操作数是多位字符的场景，可以采用一个追加器将字符先缓存起来，当完整读取一个数值时再讲数值push到数值栈中。
3、当准备push到运算符栈的当前运算符，优先级同级于或低于栈顶运算符时，将触发一次二元运算，参与二元运算的为运算符栈的栈顶元素以及数值栈栈顶的两个操作数。二元运算得支持高精度运算，同时避免精度丢失问题。
举个例子： “2 * 3 - 1=”，在读取到运算符 “-” 前，运算符栈中已有元素[“*”]，数值栈中有元素[“3”、“2”]，因为运算符“-”的优先级比栈顶运算符“*”的优先级低，所以触发二元运算 “2 * 3”，相关操作数和运算符出栈，运算结果“6”作为新的操作数push到数值栈中。特别注意，此时如果运算符栈中栈顶还有元素，那么优先级比对还得继续，这是一个递归操作，直到运算符栈没有元素或者当前运算符“-”的优先级高于栈顶元素，那么当前运算符push到运算符栈，继续读取表达式的下一个元素。
4、括号运算，相等于子表达式运算，当表达式解析到左括号时，将左括号push到运算符栈，当解析到右括号时，将递归运算整个子表达式的所有二元运算操作，直到碰到左括号才停止，此时子表达式的计算结果作为新的操作数push到数值栈中。
举个例子： “2 * (3 - 1*2)=”，在解析到右括号“)”前，运算符栈中已有元素[“*”，“-”，“(”，“*”]，数值栈已有元素[“2”、“1”、“3”、“2”]。 【温馨提示，这里元素从左到右依次表示从栈顶到栈底，没有用更直观的图示，请见谅。】
当碰到右括号时，触发一次二元运算，即“1*2”，运算符栈的栈顶元素“*”出栈，数值栈的栈顶元素“2”和“1”分别出栈，二元运算得出结果“2”，结果值push到数值栈。此时运算符栈中已有元素[“-”，“(”，“*”]，数值栈已有元素[“2”、“3”、“2”]。
子表达式还没运算结束，继续递归触发二元运算，即“3-2”，运算符栈的栈顶元素“-”出栈，数值栈的栈顶元素“2”和“3”分别出栈，二元运算得出结果“1”，结果值push到数值栈。此时运算符栈中已有元素[“(”，“*”]，数值栈已有元素[“1”、“2”]。
继续读取运算符栈顶元素，发现是左括号“(”，此时栈顶元素出栈，而无需触发二元计算，此时运算符栈中已有元素[“*”]，数值栈已有元素[“1”、“2”]。
表达式继续解析，此时发现读取到等号“=”，递归触发表达式的所有二元运算，即“2*1”，得出最终结果2，计算结束。
5、浮点数比较是否相等，因为浮点数有精度原因，所以要用精度范围的方式，参考下面代码实现。
三、完整可运行算法实现如下： package com.example.demo.java; import com.greenpineyu.fel.FelEngine; import com.greenpineyu.fel.FelEngineImpl; import java.math.BigDecimal; import java.util.HashMap; import java.util.Map; import java.util.Stack; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * @author Anzepeng * @title: Calculator * @projectName demo * @description: TODO * @date 2020/6/10 0010下午 15:02 */ public class Calculator { // 表达式字符合法性校验正则模式，静态常量化可以降低每次使用都要编译地消耗 private static final Pattern EXPRESSION_PATTERN = Pattern.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a26ee95b077ae9a5ba7a4e28706b223/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfe79bfb273e852f4f9a27fa74123d4e/" rel="bookmark">
			解决matplotlib画图中文乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载字体 以SimHei字体为例，下载SimHei.ttf文件
在python环境下输入
import matplotlib print(matplotlib.__path__) 输出matplotlib的安装环境，放在该路径下的mpl-data/fonts/ttf/
二、修改配置文件 修改matplotlib的安装环境下的，mpl-data/matplotlibrc文件，解开以下三行的注释
font.family : sans-serif font.sans-serif : SimHei, Bitstream Vera Sans, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serif axes.unicode_minus:False 三、代码reload 在代码中加入
from matplotlib.font_manager import _rebuild _rebuild() #reload一下 大功告成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/700a46e1f80677f5376e61d0369553d3/" rel="bookmark">
			论TCP客户端如何快速判断与服务器断联
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP客户端如何快速判断与服务器断联 问题产生的背景说明 我曾经对接中国电信的服务器的时候，遇到了该问题。中国电信要求和服务器断联之后(异常或者正常断联，其中包括拔掉网线)能够在30s之内连接上中国电信服务器并且接收服务器下发的无线配置。客户端重启无线，能够用无线扫描工具扫描该无线ssid已经被同步。该需求当时面临如下几个问题：
1.客户端在和服务器连接的时候需要通过一系列的鉴权机制(dh秘钥协商)，然后才可以和服务器通信
2. 无线配置到生效(ssid改变)，需要花费一定的时间。
为了满足这一系列的动作，需要优化如下几点： 能够快速判断和服务器已经断开(正常或者异常)必须优化无线生效时间，尽可能短在拔掉网线再插上网线，必须尽快拿到分配的ip地址，尽快和服务器建立连接 今天我们来讨论如何快速的检测和服务器已经断联。
目前检测客户端和服务器断联的方法 epoll(能够检测正常的断开连接，事件触发机制。优点是快速)read方式检测keeplive方式检测自定义心跳包方式检测getsockopt 下面我们逐个分析上述方式的优缺点
epoll epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。
相比较select和poll的方式，epoll对于监听的文件描述符没有限制(唯一的限制就是内核本身支持的文件描述符个数-可修改)。
我们在注册epoll的时候主要是监听两类事件(EPOLLIN和EPOLLOUT)，这两类事件分别代表着可读和可写。我们可以创建读写回调函数，当检测到对应事件的时候，调用对应的程序。为了检测客户端和服务器已经断开我们需要注册另一类事件(EPOLLRDHUP)。该事件代表的是读关闭，当服务器close的时候，会触发该事件。
说明：EPOLLERR 只有采取动作时，才能知道是否对方异常。即对方突然断掉，是不可能有此事件发生的。只有自己采取动作（当然自己此刻也不知道），read，write时，出EPOLLERR错，说明对方已经异常断开。
总结: epoll的事件触发机制不满足上述需求(插拔网线是检测不到的)。但是它的优缺点不言而喻(文件描述符监听不受限制，事件触发)。
read方式检测 但我们不采用epoll的时候(即不采用事件触发机制的时候)。我们可以创建一个单独的读线程，文件描述符设置为非阻塞。那么在读线程中死循环调用read函数。这时候可以根据read的返回值来判断socket连接是否已经出了问题。检测方式如下:
调用了read函数读取socket，如果read的返回值为小于0同时错误码不为errno == EAGAIN || errno == EWOULDBLOCK)，则代表和服务器的连接已经断开。
说明:该方式适用于各种异常情况，但是因为需要read循环接收，必须开辟线程。系统创建线程是需要有开销的，所以我不推荐该方式。
自定义心跳包检测方式 该方式对于大家都不陌生，说的直白一点就是定时发送心跳包给服务器。如果发送失败或者服务器没有定时回复，则认为连接已经断开。该方式通用、常见并且有效。在一些实时性要求不高的地方推荐这种方式。(基本现在的cs架构都有心跳机制)。但是该方式不适合我上述需求，因为心跳包是有间隔的，有间隔就代表有延时。同时又不能把心跳包设置的太短，这样会增加服务器负荷。
keeplive机制 关于keeplive机制，我在这里不详细说明。说白了就是利用系统发送心跳包。和上述心跳包检测方式一致
getsockopt机制 在应用程序中可以通过调用如下代码来判断连接是否断开
struct tcp_info info; int len = sizeof(struct tcp_info); getsockopt(g_fd, IPPROTO_TCP, TCP_INFO, &amp;info, (socklen_t *)&amp;len); if ((info.tcpi_state == TCP_ESTABLISHED)) { // myprintf("socket connected\n"); return 1; } else { printf("===========socket disconnected"); // myprintf("socket disconnected\n"); return 0; } 运行结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/700a46e1f80677f5376e61d0369553d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e19ac1baa5f32542b38fb995299fb62f/" rel="bookmark">
			时间复杂度和空间复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、说明 时间复杂度和空间复杂度是用来评价算法效率高低的2个标准，身为开发者肯定会经常会听到这2个概念，但它们分别是什么意思呢?
其实这两个概念从字面意思上也能看出一二：
时间复杂度：就是说执行算法需要消耗的时间长短，越快越好。比如你在电脑上打开计算器，如果一个普通的运算要消耗1分钟时间，那谁还会用它呢，还不如自己口算呢。时间复杂度是非常重要算法考察指标，甚至比空间复杂度更重要。因为现在大多数条件下，计算机的内存和存储都是足够充裕的。但是短时间能够出结果，用户体验会更好。
空间复杂度：就是说执行当前算法需要消耗的存储空间大小，也是越少越好。本来计算机的存储资源就是有限的，如果你的算法总是需要耗费很大的存储空间，这样也会给机器带来很大的负担。尤其是在嵌入式开发领域，内存和存储空间是非常有限的，因此会非常重视算法的空间复杂度。
二、时间复杂度的计算 表示方法
我们一般用“大O符号表示法”来表示时间复杂度：T(n) = O(f(n))
n是影响复杂度变化的因子，f(n)是复杂度具体的算法。
常见的时间复杂度量级
常数阶O(1)线性阶O(n)对数阶O(logN)线性对数阶O(nlogN)平方阶O(n²)立方阶O(n³)K次方阶O(n^k)指数阶(2^n) 接下来再看一下不同的复杂度所对应的算法类型。
常数阶O(1)
int a = 1; int b = 2; int c = 3; 我们假定每执行一行代码所需要消耗的时间为1个时间单位，那么以上3行代码就消耗了3个时间单位。那是不是这段代码的时间复杂度表示为O(n)呢 ？
其实不是的，因为大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。
上面的算法并没有随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。
线性阶O(n)
for(i = 1; i &lt;= n; i++) { j = i; j++; } 看这段代码会执行多少次呢？
第1行会执行1次，第2行和第3行会分别执行n次，总的执行时间也就是 2n + 1 次，那它的时间复杂度表示是 O(2n + 1) 吗？ No !
还是那句话：“大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的”。
所以它的时间复杂度其实是O(n);
对数阶O(logN)
int i = 1; while(i &lt; n) { i = i * 2; } 可以看到每次循环的时候 i 都会乘2，那么总共循环的次数就是log2n，因此这个代码的时间复杂度为O(logn)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e19ac1baa5f32542b38fb995299fb62f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5437ed73232e88ced9ed3aa3510bf433/" rel="bookmark">
			windows下配置安装 Mycat详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows
第一步
下载MyCat：
https://github.com/MyCATApache/Mycat-Server/releases 第二步
解压压缩包得到以下目录。
第三步
新建一个系统变量：MYCAT_HOME，值为 d:\mycat
第四步
编辑path环境变量，增加 %MYCAT_HOME%\bin;
第五步
然后直接双击运行bin目录下的startup_nowrap.bat文件，如果运行成功会显示如下：
主要配置介绍
server.xml ：定义用户以及系统相关变量，如端口等；
schema.xml ：定义逻辑库，表、分片节点等内容；
rule.xml ：定义分片规则。
server.xml
在server.xml中主要配置mycat。如：访问mycat的用户密码、端口号等。如下图
&lt;!-- name：mycat用户名 --&gt; &lt;user name="root" defaultAccount="true"&gt; &lt;!-- mycat密码 --&gt; &lt;property name="password"&gt;maluole&lt;/property&gt; &lt;!-- 对应schema.xml文件中的schema标签的name --&gt; &lt;property name="schemas"&gt;mycat1&lt;/property&gt; &lt;/user&gt; schema.xml
schema.xml文件中，主要对逻辑库，表、分片节点等内容
&lt;?xml version="1.0"?&gt; &lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt; &lt;mycat:schema xmlns:mycat="http://io.mycat/"&gt; &lt;!-- name：自定义名字，对应server.xml中的schemas checkSQLschema：查询时是否增加库名称。如db1.table。false不加 sqlMaxLimit ：一次最大读取行数 --&gt; &lt;schema name="mycat1" checkSQLschema="true" sqlMaxLimit="100"&gt; &lt;!-- table为需要分库分表的数据表 name：对应数据库中的表名 dataNode：对应下面dataNode节点的名字，即：需要拆分到的库。多个用逗号分隔 primaryKey：当前数据库表中对应的主键 rule：排序规则名称，对应rule.xml文件tableRule的name --&gt; &lt;table name="books" dataNode="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5437ed73232e88ced9ed3aa3510bf433/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f7bb0fadbaa50015406562abe3a32e9/" rel="bookmark">
			excel批量插入图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用EXCEL的VBA功能，在代码窗口输入如下代码，作相应的修改，然后执行就可以了：
Sub 批量插入图片()
On Error Resume Next
Dim i As Integer
Dim 末行行号 As Integer
Dim 图片路径 As String '图片的完整路径
末行行号 = Cells.SpecialCells(11).Row
For i = ActiveCell.Row To 末行行号
Cells(i, 1).Select图片路径 = Cells(i, 2) &amp; Cells(i, 3) '此处要根据实际作相应的修改
With ActiveSheet.Pictures.Insert(图片路径)
.ShapeRange.Height = 9.75 '这个数值是图片的高度，要根据要求作修改
.ShapeRange.Width = 28.5 '这个数值是图片的宽度，要根据要求作修改
End With
Next i
End Sub
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf4cca96e76c0872fc83df0108db179f/" rel="bookmark">
			解决Linux docker不能显示中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 三步可解决问题
1、打开profile文件
vim /etc/profile 2、将下述命令添加进文件末尾，并保存退出
export LANG="C.UTF-8" 3、执行命令 ，即可正常显示中文
source /etc/profile 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acad429d776e2e37c76244440005e013/" rel="bookmark">
			IntelliJ idea  登录和退出账户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先打开账户界面
选择菜单栏的help --&gt; register
二、登录账户
在username和password填写自己的账户和密码，然后单击Activate登录就ok了
三、退出账户
在出现的菜单中选择remove license，然后单击确定就okle
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e59faf2fa21fae57dec9ac993c2dcd90/" rel="bookmark">
			轻量级卷积神经网络综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		inception 最初的版本 Inception/GoogleNet，其核心思想是利用多尺寸卷积核去观察输入数据，
于是我们的网络就变胖了，通过增加网络的宽度，提高了对于不同尺度的适应程度。但这样的话，计算量有点大了。
2.2 Pointwise Conv 为了减少在上面结构的参数量并降低计算量，于是在 Inception V1 的基础版本上加上了 1x1 卷积核，这就形成了 Inception V1 的最终网络结构，如 Figure 2。
这个 1x1 卷积就是 Pointwise Convolution（逐点卷积），简称 PW。利用它的目的主要是为了减少维度，还用于引入更多的非线性。
我们来简单计算下：假定上一层输出的 feature map 维度为 100x100x128，经过256个大小为 5x5 的卷积后，输出的 feature map 大小为 100x100x256。这里卷积参数为 256∗5∗5∗128=819,200。而假如上一层的输出先经过 32 个大小为 1x1 的卷积后，再经过256个大小为 5x5 的卷积，那么输出维度保持不变的情况下，卷积参数减少为 128∗1∗1∗32 + 32∗5∗5∗256=204,800，降低为原来的1/4。
PW 主要用于数据降维，减少参数量。也有使用 PW 做升维的，在 MobileNet v2 中就使用 PW 将 feature map 的宽度扩张了6倍，丰富输入数据的特征。
2.3 Kernel Replace Inception V2 和 V3 版本为了进一步降低卷积参数采用小卷积来替换大卷积，同 VGG 套路。
大尺寸的卷积核可以带来更大的感受野，但也意味着会产生更多的参数，比如 5x5 卷积核的参数有 25 个，3x3 卷积核的参数有 9 个，前者是后者的 25/9=2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e59faf2fa21fae57dec9ac993c2dcd90/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/364/">«</a>
	<span class="pagination__item pagination__item--current">365/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/366/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>