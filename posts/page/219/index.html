<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4faa950658e3fabc16818af9de4bc251/" rel="bookmark">
			入门：如何搭建一个简单的静态网站，apache服务器，https，SSL(TLS)握手过程和发送包的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.安装httpd，并将访问apache服务器的首页修改为hello.html, 且内容为: "My Home Page is hello"
2.虚拟主机：虚拟两台主机ip为100,200, 对应访问目录：/www/ip/100, /www/ip/200并创建首页文件index.html 3.配置不同端口的虚拟主机访问apache服务器
1.安装httpd，并将访问apache服务器的首页修改为hello.html, 且内容为: "My Home Page is hello" 我们定义的静态页面在/var/www/html目录中，静态网页的名字必须是index.html，这个文件存放在/var/www/html目录下，在访问页面时默认打开这个目录中的index.html文件。
[root@localhost ~]# yum install httpd -y
[root@localhost ~]# systemctl status firewalld #查看防火墙状态
[root@localhostr ~]# systemctl stop firewalld # 关闭防火墙
[root@localhost conf]# cd /var/www/html
[root@localhost html]# vim hello.html [root@localhost html]# systemctl restart httpd
我们还得将首页文件名改为index.html，然后重启httpd服务，就可以在服务器中访问到了。
[root@localhost conf]# cd /var/www/html
[root@localhost html]# mv hello.html index.html
[root@localhost html]# systemctl restart httpd
2.虚拟主机：虚拟两台主机ip为100,200, 对应访问目录：/www/ip/100, /www/ip/200并创建首页文件index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4faa950658e3fabc16818af9de4bc251/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5d6af0d4d68f67abd5f26eadd081547/" rel="bookmark">
			【云原生之k8s】kubeadm搭建k8s集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【云原生之k8s】kubeadm搭建k8s集群 前言一、集群介绍(1)集群搭建方法(2)集群架构 二、集群部署(1)环境部署①所有节点，关闭防火墙规则，关闭selinux，关闭swap交换②修改主机名，并写入三台服务器的host中③调整内核参数④所有节点安装Docker (2)k8s集群部署①所有节点配置K8S源②所有节点安装kubeadm，kubelet和kubectl③部署kubernetes Master节点（master节点上执行）④token制作⑤k8s-node 节点加入 master 节点（两个 node 执行）⑥master节点安装部署pod网络插件（flannel）⑦给node节点添加标签⑧master检查⑨查询服务是否正常 (3)测试结果 前言 本文将介绍使用工具安装k8s的详细步骤
一、集群介绍 (1)集群搭建方法 目前生产部署Kubernetes 集群主要有两种方式：
Kubeadm
Kubeadm是一个K8s 部署工具，提供 kubeadm init 和 kubeadm join，用于快速部署Kubernetes 集群。二进制包
从github 下载发行版的二进制包，手动部署每个组件，组成Kubernetes 集群。 Kubeadm 降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署Kubernetes 集群，虽然手动部署麻烦点，期间可以学习很多工作原理，也利于后期维护。
(2)集群架构 目前搭建集群一般采取一主一从、多主多从的集群架构（高可用）
二、集群部署 (1)环境部署 ①所有节点，关闭防火墙规则，关闭selinux，关闭swap交换 #所有节点，关闭防火墙规则，关闭selinux，关闭swap交换 systemctl stop firewalld systemctl disable firewalld setenforce 0 iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X swapoff -a	#交换分区必须要关闭 sed -ri 's/.*swap.*/#&amp;/' /etc/fstab	#永久关闭swap分区，&amp;符号在sed命令中代表上次匹配的结果 ②修改主机名，并写入三台服务器的host中 cat &gt;&gt; /etc/hosts &lt;&lt; EOF 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5d6af0d4d68f67abd5f26eadd081547/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e4c982519a72442c4096d215486bc97/" rel="bookmark">
			vagrant和VirtualBox配置时出现的一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现下面这个错误，是因为VirtualBox的路径中有中文，去VirtualBox的全局设置中更改路径即可
’F:/Vagrant/embedded/gems/2.2.19/gems/i18n-1.8.11/lib/i18n/interpolate/ruby.rb:23:in `gsub': incompatible character encodings: GBK and UTF-8 (Encoding::CompatibilityError)
出现下面这个错误是Vagrant的VagrantFile所处的目录有中文，更改即可，详细请看此地址（https://www.jianshu.com/p/c5d8b8385f2d?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation）
F:/Vagrant/embedded/gems/2.2.19/gems/childprocess-4.1.0/lib/childprocess/windows/process_builder.rb:48:in `join': incompatible character encodings: GBK and UTF-8 (Encoding::CompatibilityError)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25ad4d0bfca8e0e57e7c82d45fb03938/" rel="bookmark">
			《利用python进行数据分析.第2版》第5章 pandas入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pandas库含有使数据清洗和分析工作变得更快更简单的数据结构和操作工具。
5.1 pandas的数据结构介绍 两个主要数据结构：Series和Dataframe
Series Series是一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成。仅由一组数据即可产生最简单的Series：
pandas的isnull和notnull函数可用于检测缺失数据：
In [32]: pd.isnull(obj4) Out[32]: California True Ohio False Oregon False Texas False dtype: bool In [33]: pd.notnull(obj4) Out[33]: California False Ohio True Oregon True Texas True dtype: bool DataFrame
DataFrame是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，它可以被看做由Series组成的字典（共用同一个索引）。DataFrame中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）。
建DataFrame的办法有很多，最常用的一种是直接传入一个由等长列表或NumPy数组组成的字典：
data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'], 'year': [2000, 2001, 2002, 2001, 2002, 2003], 'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]} frame = pd.DataFrame(data) 结果DataFrame会自动加上索引（跟Series一样），且全部列会被有序排列：
In [45]: frame Out[45]: pop state year 0 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25ad4d0bfca8e0e57e7c82d45fb03938/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e73cc4a6cbb20105b0822e1abfff9e0a/" rel="bookmark">
			【计网】（四）物理层、数据链路层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章接着介绍四层协议中的物理层和数据链路层。出发……
文章目录 一、物理层✅数字信号、模拟信号✅数据通信模型✅信道（单工、半双工、全双工） 二、数据链路层✅数据链路层的特征一：封装成帧✅数据链路层的特征二：透明传输✅数据链路层的特征三：差错校验✅CSMA/CD 协议✅Ethernet V2帧的格式、Ethernet V2标准✅PPP协议 （Point to Point Protocol） 一、物理层 物理层（或称物理层，Physical Layer）是计算机网络OSI模型中最低的一层。物理层规定:为传输数据所需要的物理链路创建、维持、拆除，而提供具有机械的，电子的，功能的和规范的特性。简单的说，物理层确保原始的数据可在各种物理媒体上传输。它定义了接口标准、线缆标准、传输速率、传输方式等。
✅数字信号、模拟信号 数字信号（Digital Signal）：1、它是离散的信号，不适合长距离传输。2、它的抗干扰能力强，受到干扰后，波形失真是可以修复的。
模拟信号（Analog Signal）：1、它是连续的信号，适合长距离传输；2、它的抗干扰能力差，受到干扰时波形变形后很难修复。
✅数据通信模型 数据通信的类型分为两种：局域网和广域网的情况。
局域网通信模型。运用在小型网络中，比如教室、办公室等。
补充：网线（双绞线）的长度不能超过100米，超过之后信号会有所衰减。
广域网通信模型。在很久以前，家里上网时，牵的网线是搭在电话线上的，现在搭在电话线上的应该很少见了，这种情况用的猫也叫调制解调器。这种猫之间传输的是模拟信号； 而随着科技的进步，现在基本上都是光纤入户了，光纤牵到家里就要使用到光猫（光电转换器），光猫之间传输的是光信号。
✅信道（单工、半双工、全双工） 信道：信息传输的通道，一条传输介质上可以有很多条信道。比如网线。
单工通信。指的是信号只能往一个方向发送，任何时候都不能改变信号的传输方向。常见的是无线电广播、有线电视广播。半双工通信。信号可以在一个信道上双向传输，但是必须是交替进行的，也就是说同一时刻，只能有一端发送，另一端接收。例如对讲机。全双工通信。信号可以随时在一个信道上双向传输，也就是说一端可以同时做到发送和接收信号。例如手机打电话时，可以听说同时进行。 二、数据链路层 链路：指的是从1个节点到相邻节点的一段物理线路（有线或无线），中间没有其他交换节点。如下图：
数据链路：指的是在一条链路上传输数据时，需要有对应的通信协议来控制数据的传输。而不同类型的数据链路，所用的通信协议可能也是不同的。比如：1、广播信道：CSMA/CD协议。运用在同轴电缆、集线器等组成的网络。2、点对点信道：PPP协议。运用在路由器与路由器之间的信道。
✅数据链路层的特征一：封装成帧 如上图，一个数据帧的大致结构就是这样。
帧的数据部分：是由上一层网络层传递下来的IP数据包，而这个数据包在帧这一层，是有一定的大小的，即上图中的MTU(Maximum Transfer Unit)，也称为最大传输单元。 而在每一种数据链路层协议中，规定的这个MTU的上限可能是不同的。比如以太网帧规定的MTU上限是1500字节。 ✅数据链路层的特征二：透明传输 SOH(Start Of Header)：称为帧开始符。EOT(End Of Transmission)：称为帧结束符。 而使用上述两个开始符和结束符，可能会存在一定的问题。就如上图所示，假设由网络层传递下来的数据部分里面就含有EOT，则接收端在接收数据的时候，可能就会出现上图所示的情况，导致误认为有一部分无效帧，从而被丢弃。
这种情况，在日常开发中也很常见，比如Windows环境下的路径，即可以用"/“，也可以用”\"，后者就容易使其变成转义字符，所以就需要写两个\的。
在这里也是一样的，在数据部分的EOT，使其转义即可。
✅数据链路层的特征三：差错校验 FCS：是帧尾的一部分，它是根据帧的数据部分+数据链路层首部计算出来的。数据链路层首部是帧头的一部分。
接收端在接收到数据后会计算出FCS，并进行比较，如果发现不一致，网卡就会把这条信息丢弃，这种情况下，抓包工具是抓不到的。
在数据经过不同的数据链路层时，对应的层会把之前的帧开始和帧结束符替换为自己的协议帧。
✅CSMA/CD 协议 CSMA/CD（Carrier Sense Multiple Access with Collision Detectio）：载波侦听多路访问/冲突检测。运用在同轴电缆、集线器等网络上，上文提及过。
而使用了CSMA/CS 的网络称为以太网，它传输的是以太网帧。以太网帧的格式有两种：
Ethernet V2标准IEEE的802.3标准 当然，使用最多的就是Ethernet V2标准。用交换机组建的网络，已经是支持全双工通信，不需要再使用CSMA/CD，但它传输的帧依然是以太网帧。
为了能够检测到正在发送的帧是否产生了冲突，所以以太网的帧至少是需要64字节的。
✅Ethernet V2帧的格式、Ethernet V2标准 如上图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e73cc4a6cbb20105b0822e1abfff9e0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe108809c29ccb5037c69be688d1995/" rel="bookmark">
			全尺度表示的上下文非局部对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【写在前面】 基于文本的人物搜索旨在使用人物的描述性句子在图像库中检索目标人物。这是一个非常具有挑战性的问题，因为模态差异使得有效提取鉴别特征更加困难。此外，行人图像和描述的类间方差很小。因此，需要综合信息来在所有尺度上对齐视觉和文本线索。大多数现有方法仅考虑单个尺度（例如仅全局尺度或仅部分尺度）内图像和文本之间的局部对齐，或仅在每个尺度上单独构建对齐。为了解决这个问题，作者提出了一种能够跨所有尺度自适应对齐图像和文本特征的方法，称为NAFS（即全尺度表示的非局部对齐）。首先，提出了一种新的阶梯网络结构来提取局部性更好的全尺度图像特征。其次，提出了一种局部注意力训练的BERT，以获得不同尺度下的描述表示。然后，不是在每个尺度上单独对齐特征，而是应用一种新的上下文非局部注意机制来同时发现所有尺度上的潜在对齐。实验结果表明，在基于文本的个人搜索数据集上，本文的方法在top-1和top-5方面分别优于最先进的方法5.53%和5.35%。
1. 论文和代码地址 Contextual Non-Local Alignment over Full-Scale Representation for Text-Based Person Search
论文地址：https://arxiv.org/abs/2101.03036[1]
代码地址：https://github.com/TencentYoutuResearch/PersonReID-NAFS[2]
2. Motivation 基于文本的人物搜索旨在使用人物的描述性句子在图像库中检索目标人物。与经典的人物再识别（Reid）相比，它不需要目标人物的图像作为查询。此外，基于文本的人员搜索更易于用户使用，因为它可以支持开放式自然语言查询。因此，它具有更广泛的应用潜力。
与一幅图像可能包含多个对象的一般图像-文本匹配任务相比，基于文本的人员搜索是一项更具挑战性的任务，因为不同行人图像之间的高层语义非常相似，导致行人图像和文本描述的类间差异很小。因此，为了探索更有特色和更全面的信息，基于文本的人搜索需要一种算法来从所有尺度中提取图像和文本特征。例如，上图中的图像和文本描述都可以分解为不同比例的表示。这个句子可以用短句来表示，例如在3级的“黑色短裤”，或者在2级的更长的子句。类似地，图像也可以按比例3和比例2划分为不同大小的子区域。由于这些图像表示和文本表示之间的正确对齐是图像-文本匹配任务的基础，因此必须在所有尺度上表示图像和文本描述。在本文中，作者称之为全尺度表示。然而，不同尺度下的复杂相关性使得很难建立合理的对齐方案。如上图所示，在大多数情况下，对齐发生在相似的比例下，例如子句“一件黑色衬衫，上面有一个灰色十字架”和比例2中的图像区域。但偶尔也会在不同的尺度上发生对齐。例如，如上图中的红色箭头所示，比例3中的单个单词“woman”与比例1中的整个图像对齐。这些现象说明了在相似尺度和不同尺度下联合对齐图像和描述的重要性。因此，一种合理的基于文本的人员搜索方法通常包含两个关键部分。一个是以从粗到细的方式学习所有尺度下的图像和文本表示，另一个是探索适当的对齐方式，以自动和自适应地匹配这些不同尺度的表示。
现有的大多数作品无法完全满足上述两个角度。一方面，对于多尺度表示，大多数方法仅在一定尺度上学习图像和文本描述的表示。几种粗粒度方法侧重于在全局尺度上学习表示，即上图比例1所示的整个图像和句子。细粒度方法以最小比例对图像和文本描述进行建模，例如上图比例3中所示的图像区域和短短语。尽管一些细粒度方法[考虑将最小尺度与全局尺度相结合，但它们仍然缺乏中尺度信息，导致一些描述段（图像区域）无法与适当的图像区域（描述段）正确对齐。
另一方面，对于跨尺度对齐，现有方法尝试使用预先定义的规则来对齐不同尺度的图像和文本描述。一些方法只考虑图像和文本描述的全局匹配。其他一些方法添加了短短语和图像区域之间的对齐，如图1比例3所示，但忽略了不同比例之间的对齐。最近，一些方法进一步增加了整个图像和短句之间的额外对齐，以及小图像条纹和整个句子之间的对齐。这些方法表明，利用多尺度特征可以显著提高性能。然而，它们都预先定义了不同尺度（例如全局-全局、局部-局部）的图像表示和文本表示之间的几种对齐规则，并分别在这些固定尺度对内建立对齐。因此，它将对齐限制在一定范围内，导致完全忽略比例对之外的图像表示和文本表示之间的对齐。
为了解决上述问题，在本文中，作者提出了一种新的基于文本的人员搜索方法，该方法为图像和文本表示构建全尺度表示，并在所有尺度上自适应对齐它们，称为NAFS（全尺度表示上的非局部对齐）。首先，作者提出了一种新的阶梯网络将更好的局部性结合到学习的全尺寸图像特征中的条纹分割操作。然后，通过添加局部约束注意的改进BERT语言模型来提取全尺度文本特征。接下来，作者开发了一种更灵活的对齐机制，称为语境非局部注意，它能够联合将所有尺度的图像表示和文本表示作为输入，然后自适应地在所有尺度上建立对齐，而不是在几个预先定义的尺度下对齐特征（例如，局部-局部、全局-全局）。最后，提出了一种新的基于最近视觉邻域的重新排序算法，以进一步提高排序质量。
本文的主要贡献可以总结如下：（1）专门开发了一种新的阶梯CNN网络和局部约束BERT模型来提取全尺度图像和文本表示。（2） 提出了一种上下文非局部注意机制，用于在所有尺度上自适应对齐学习的表示。（3） 该框架在具有挑战性的数据集CUHK-PEDES上实现了最先进的结果。广泛的消融研究清楚地证明了本文方法中每个成分的有效性。
3. 方法 在本节中，首先，作者介绍了提取视觉和文本表示的过程。然后作者描述了本文的语境非局部注意机制。最后，作者介绍了所提出的通过视觉邻居重新排序的方法，以进一步提高性能。
3.1. 提取视觉表示 楼梯主干结构 首先，作者详细阐述了所提出的楼梯网络的实现细节。如上图所示，它包含三个分支，每个分支负责从粗到细提取不同尺度的视觉特征，即全局分支（蓝色）、区域分支（黄色）和patch分支（绿色）。一般的ResNet网络用作主干网。1） 全局分支用于提取全局和最粗糙的特征。2） 区域分支从图像中的大子区域中提取内部特征。它将全局分支第二阶段的特征映射作为输入，然后输入到两个连续的res块中，在区域尺度上提取特征。然后将区域分支的输出特征映射水平分割为个条带，每个条带进一步编码为特定区域的局部特征。3） patch分支从图像中的小patch中提取最新特征。它将全局分支第三阶段的特征图作为输入，然后将其输入到一个res块中，以在小patch尺度上提取特征。然后，作者将输出的特征图水平分割成条条纹，以提取局部patch的个特征向量。
拆分和shufﬂe操作 基于条带的ReID模型面临的一个挑战是，由于CNN模型的感知域很大，深层特征图的条带可能也包含全局信息。因此，为了保证多尺度图像特征具有更好的局部性，作者引入了一种新的分割&amp;shuffle操作。它将中间特征映射作为输入，然后将特征映射平均划分为几个水平条带，表示为列表，其中是从特征映射顶部开始的第i个条带。然后，对这组分区条纹沿纵轴进行随机分解和重新连接形成完整的特征图作为输出。第2阶段和第3阶段的特征图将在分别输入范围和patch分支之前首先分割和细化。通过随机分割条纹，它可以打破连续条纹之间的相互关系，使模型能够专注于每个条纹内的信息。由于本文的上下文非局部注意力不依赖于特征图片段的顺序，因此没有必要将分割的条纹重新组织为原始顺序。
视觉表征提取模块将行人图像作为输入，然后可以获得不同尺度的图像特征列表，并将其表示为，其中。
3.2. 提取文本表示 给定文本描述，作者在BERT中添加局部约束以提取的不同尺度表示。在本文的方法中，文本描述将分别在三个尺度中表示。1） 在句子层面，作者在句子的开头添加了一个特殊的分类token（[CLS]）。与该token对应的最终隐藏状态可以用作整个句子在全局视图中的句子层面表示。2） 在中间层，作者用逗号分隔句子，从而得到一系列较短的子句子。对于列表中的每个子句，[CLS] token也附加到子句的开头，其最终隐藏状态也用作每个子句的表示。3） 在词级，每个词的最终隐藏状态直接用作词级表示。
对于常见的基于BERT的模型，所有token的隐藏变量具有相同的全局感知场。每个token都可以处理整个输入句子中的任何token。为了为句子中的子区域表示（子句子的[CLS]标记）提供局部性，作者提出了一个局部性约束注意模块来关注一定范围内的token。与原始BERT类似，假设查询对应于子实体（表示为）的[CLS] token，局部约束注意力计算如下：
其中和分别表示对应于句子中所有token的键和值。U是该子句子范围内的token集，是一个指示函数，当第i个token在U中时返回1。
文本表示提取模块将行人描述作为输入，然后可以获得不同尺度的文本嵌入列表，并表示为，其中。
3.3. 语境非局部注意机制 如上图所示，语境非局部注意需要两个输入：一组视觉特征和一组文本特征。注意力模块的输出是衡量图像-文本对相关性的相似性分数。简言之，语境非局部注意使跨模态特征能够根据其语义以从粗到细的方式相互对齐，而不仅仅是使用预先定义和固定的规则（例如，局部-局部、全局-全局）。
受自注意力的启发，作者可以将本文提出的注意力机制解释为将查询和一组键值对映射到输出。对于视觉特征，使用两个学习的线性投影将I映射到视觉查询和视觉值。类似地，探索了两个线性投影，以将T映射到文本键和文本值。基于，作者从图像-文本和文本-图像两个方面介绍了本文提出的注意机制。
图像-文本上下文非局部注意 提出的图像-文本注意模块包括两个阶段。首先，每个视觉查询关注文本键，以获得相应的关注文本值。然后，考虑所有视觉值及其相关文本值，可以确定图像-文本对之间的相似性。具体来说，为了获得关注的文本值，作者首先计算和的余弦相似矩阵以获得上的权重：
其中，表示第a个视觉查询和第b个文本键之间的相似性。此外，作者将其归一化为。此外，为了滤除不相关的文本值，作者使用焦点注意力技巧，其中。然后，作者计算加权文本值为：
其中是softmax函数的inverse temperature。
在第二阶段，作者利用和之间的余弦相似性确定视觉值与其相应文本语境之间的相关性：
通过平均所有，得到图像-文本对的相似性为：
每个视觉特征都更加关注相关的文本特征。相关的文本特征可能来自一个单词、一个短语或整个句子，这仅仅取决于视觉特征和文本特征是否具有相似的语义。相反，以前的方法倾向于以固定的方式建立对应关系。作者通过启用基于语义的注意机制来建立跨不同尺度的对应关系，从而放松了这些约束，这有助于更自适应、更正确地对齐图像-文本对。
文本-图像上下文非局部注意 与图像-文本上下文非局部注意类似，作者分别将文本键视为查询和视觉查询视为键，并针对视觉查询关注文本键。然后，利用文本值和关注的视觉值，计算图像-文本对之间的相似性。具体而言，第b个视觉值相对于第a个文本值的权重定义为。归一化和聚焦加权定义为。
加权视觉值定义为。
使用加权视觉值 和文本值，作者计算他们的相似度。然后通过平均操作获得他们最终的相似度。
对齐目标 作者引入了一个名为跨尺度对齐损失（CSAL）的目标函数来优化该算法。给定一batch图像，标题和所有图像-文本对，如果是匹配对，则，否则为0，作者将的图像-文本相似性定义为，将文本-图像相似性定义为。为了最大化匹配对之间的相似性并抑制不匹配对的作者将CSAL定义为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fe108809c29ccb5037c69be688d1995/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/670c0efa958c3fc2b7b4aaf3c0f8c2bd/" rel="bookmark">
			Centos7把home目录下多余的空间转移到/根目录下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过df-h发现，根目录只有32G，而home目录可用的，居然有142G。我现在想分出70G给根目录
把你需要挂载的机器的逻辑卷记住（上面的图，左边是逻辑卷，右边是虚拟磁盘）
/dev/mapper/cl-home 物理地址（逻辑卷）
其中的cl就是这个类，不能修改，记住cl，在第四步后要用，你的可能是叫其他名，都是df -h，后显示的结果，cl-home，取-前面的值
首先第一步，进行备份，一定要备份。
mkdir /home-bak mv /home/* /home-bak 第二步，取消挂载，一定要询问使用这台机器的所有人，有没有在home下挂服务
umount /home 如果，不能取消，说明有其他程序在使用，找到他们，杀死他们。
查看谁在使用它
fuser -k /home
然后，只复制前面的数字(进程号），就可以杀死
kill -9 数字
第三步（卸载逻辑卷）
lvremove /dev/mapper/cl-home 第四步（创建卷，为home目录，卷名为centos）
lvcreate -L 70G -n home cl 第五步（将逻辑卷，拓展到磁盘系统,磁盘名字要与之前df-h的逻辑卷保持一致）
mkfs -t xfs /dev/mapper/cl-home 第六步（将磁盘系统的逻辑卷，与磁盘目录做映射）
mount /dev/mapper/cl-home /home 拓展，原有磁盘
先加到逻辑卷（df -h ，根目录，左边对应的就是逻辑卷）
lvextend -L +70G /dev/mapper/cl-root
在加到文件系统
xfs_growfs /dev/mapper/cl-root
df -h查看
最后不要忘记，把/home-bak目录中备份的东西，还到/home里
mv /home-bak/* /home
参考文章:
target is busy. (In some cases useful info about processes that use the device is found by lsof(8) or fuser(1)) | 杨龙
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/670c0efa958c3fc2b7b4aaf3c0f8c2bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1a6585dcbfcb59ae77d27ae34d0b433/" rel="bookmark">
			操作系统学习——文件系统（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、磁盘 linux中的普通文件和目录文件保存在称为块物理设备的磁盘上。每个磁盘可以定义多个文件系统。
一个文件系统由逻辑块的序列组成，一个逻辑盘空间一般划分为几个用途各不相同的部分，即引导块、超级块、inode区以及数据区。
（1）引导区：是一个扇区，用来存放引导程序，用于读入并启动操作系统。
（2）超级块：用于记录文件系统的管理信息，如块个数、块大小、空闲块
（3）inode区：一个文件占据一个inode点（目录也是文件）
第一个索引节点是该文件系统的 / 根节点，
（4）数据区：用于存放文件数据或管理数据
二、文件系统 1.概念：文件系统是操作系统中负责把用户文件存到磁盘硬件中，它的基本数据单位是文件，目的是为了对磁盘上的文件进行组织管理。
2.linux会为每个文件分配两个数据结构：索引节点和目录项。用来记录文件的元信息和目录层次结构。
（1）inode(索引节点)：用来记录文件的元信息
比如inode号，文件大小，访问权限，创建时间，修改时间，数据在磁盘的位置等。存储在硬盘当中
（2）denty(目录项)：
用来记录文件的名字、索引节点指针以及其他目录项的层级关联关系，多个目录项形成目录结构。
目录项是内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。而目录是个文件，存储在磁盘中。其实目录项也是从磁盘的目录文件里读来的，只是为了效率，会把已经读过的目录用目录项这个数据结构缓存在内存。
(3)目录项和索引节点的关系是多对一
一个文件可以有多个别名，而文件的inode号唯一，目录项中存放文件的名字，所以目录项与索引节点的关系是多对一。如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。
3. 文件数据如何存储在磁盘上？
磁盘读取的最小单位是扇区，512B；为了提高效率，多个扇区被组成一个逻辑块，每次读取的最小单位都是逻辑块（Linux中大小为4KB）。 并不会把超级块和索引节点全部加载进内存； 只有在使用的时候才把索引节点和超级块，才将其加载进内存。超级块：文件系统挂载时加入内存。索引节点区：文件被访问时进入内存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/100436a6e39c23c430704e507c1b3078/" rel="bookmark">
			七大测试用例设计方法与案例分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、等价类划分法（解决穷举场景）
二、边界值分析法（解决边界限制问题）
三、判定表法（解决多条件有依赖关系测试问题）
四、场景法/流程图法（解决业务逻辑测试）
五、错误推测法
六、因果图（作为判定表的辅助）
七、正交表（正交排列法）
一、等价类划分法（解决穷举场景） 1、说明：在所有测试数据中，具有某种共同特征的数据集合进行划分。
2、分类：（1）有效等价类：满足需求的数据集合。
（2）无效等价类：不满足需求的数据集合。
3、步骤：（1）明确需求。
（2）确定有效和无效等价类。
（3）提取数据编写测试用例。
4、适用场景：需要有大量数据测试输入，但是没法穷举测试的地方。
例如：输入框、下拉列表、单选复选框
5、等价类划分法案例：
二、边界值分析法（解决边界限制问题） 提示：有关范围限制，最多7条用例（未优化），只能解决位数限制问题。
1、边界范围节点：选取正好等于、刚好大于、刚好小于边界的值作为测试数据。
（1）上点：边界上的点（刚好等于）。
（2）离点：距离上点最近的点（刚好大于、刚好小于）。
（3）内点：范围内的点（区间范围内的数据）。
2、边界值法设计用例步骤：
（1）明确需求。
（2）确定有效和无效等价类。
（3）确定边界范围值。
（4）提取数据编写测试用例。
3、优化：7个优化为5个点
上点：必选（不考虑区间开闭）。
内点：必选（建议选择中间范围）。
离点：开内闭外（考虑区间开闭，开区间选择内部离点，闭区间选择外部离点）。
4、使用场景：
（1）在等价类的基础上针对有边界范围的测试数据输入的地方（重点关注边界）。
（2）常见词语描述：大小、尺寸、重量、最大、最小、至多、至少等修饰词语。
（3）典型代表：有边界范围的输入框测试。
5、边界值分析法案例：
三、判定表法（解决多条件有依赖关系测试问题） 1、定义：是一种以表格形式表达多条件逻辑判断的工具
2、组成：
（1）条件桩：列出问题中的所有条件，列出条件的次序无关紧要。
（2）动作桩：列出问题中可能采取的操作，操作的排列顺序没有约束。
（3）条件项：列出条件对应的取值，所有可能情况下的真假值。
（4）动作项：列出条件项的、各种取值情况下应该采取的动作结果。
3、规则：
（1）判定表中贯穿条件项和动作项的一列就是一条规则。
（2）假设有n个条件，每个条件的取值有两个（0,1），全组合有2的n次方种规则。
4、判定表法设计用例步骤：
（1）明确需求。
（2）画出判定表：
列出条件桩和动作桩 填写条件项，对条件进行组合 根据条件项的组合确定动作项 简化、合并相似规则（有相同动作） （3）根据规则编写测试用例。
5、使用场景：
（1）有多个输入条件，多个输出结果，输入条件之间有组合关系，输入条件和输出结果之间有依赖关系。
（2）判定表法一般适用于条件组合数量较少的情况（比如4个条件以下）。
注：条件超过4个可以使用正交法解决。
6、判定表法案例：
四、场景法/流程图法（解决业务逻辑测试） 1、流程图的作用：
（1）能够看懂流程图，设计业务用例。
（2）当需求文档信息不全时，能够根据需求，梳理出流程。
2、介绍：场景法也叫做流程图法，是用流程图描述用户的使用场景，然后通过覆盖流程路径来设计测试用例。
3、意义：
（1）用户使用角度：用户平时使用的不是单个功能，而是多个功能组合起来进行使用。
（2）测试人员角度：平时测试的都是单个功能点进行测试，容易忽略多个功能的组合测试。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/100436a6e39c23c430704e507c1b3078/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f19b2cf8699fb7b4803b619e04353cb7/" rel="bookmark">
			nuxt页面访问速度优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在网上查询如何提高网站访问率的问题，看到其中一条是页面访问速度也占很大的比例，于是就看看自己的网站打开速度怎么样，于是打开chrome 浏览器 -&gt;清楚缓存 -&gt;打开google调试工具 -&gt; 打开网页。
速度有点慢！！！
打开google调试工具查看具体是什么加载慢！
每次都清除缓存太麻烦！可以使用chrome浏览器的无痕模式，每次都是重新加载！
前端优化
首先就是处理加载速度很慢的东西！但nuxt 打包过后，js大部分的时候都是改了名的，看不出来是什么js，点击加载的资源，根据里面的代码 大概猜出来是什么东西!
第一个：是一个时间格式化的js，moment ,不知道这个东西为什么这么慢，其实大小也不大，我的代码也有自己的格式化工具，于是就移除了这个js。
第二个：element-ui,由于创建项目的时候，选择了element-ui,创建的模板代码默认使用的是全局加载，会加载一下没有使用的东西，于改成了按需加载。
首先安装babel-plugin-component
yarn add babel-plugin-component 然后 修改 nuxt.config.js 去掉 element-ui 的css ，babel-plugin-component 会按需加载 babel: { "plugins": [ [ "component", { "libraryName": "element-ui", "styleLibraryName": "theme-chalk" } ] ] } 然后修改 plugins/element-ui.js 修改前 import Vue from 'vue' import Element from 'element-ui' import locale from 'element-ui/lib/locale/lang/en' Vue.use(Element, { locale }) 修改后
这两个优化完后，在访问一下，发现速度是好点了，但是还是不是很快，再看下请求时间，发现element-ui的图标库加载很慢，浪费了我1.2s，目前项目中使用的并不是很多，就一两个地方，于是去掉icon的方式，直接加载图片，以后探索使用svg。
这个去掉之后，速度提升很大。前端优化到此差不多了，毕竟项目不是很复杂。
后端优化
给Nginx配置一个资源压缩：
#配置压缩 加速页面打开 gzip on; #开启资源压缩 gzip_min_length 2k;#设置页面允许压缩的最小字节 gzip_buffers 4 16k;#设置压缩的内存大小 按16k大小的 4倍申请内存 gzip_http_version 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f19b2cf8699fb7b4803b619e04353cb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/730bb0e2cb2fc7b1ddf4cc907fe75cf9/" rel="bookmark">
			如何快速学会Sass
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定义变量进行多处引用
生成页面
二、颜色透明度
当我们仅知道16进制的表示法，但要同时设置透明度，Sass可以自动转换成合法形式
=》
三、语法的嵌套（这个比较常用）
使用Sass对于代码的结构非常清晰，具体如何使用下图可以进行表示
1、这是html页面的嵌套关系
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;span&gt;&lt;/span&gt; &lt;div class="app2"&gt; &lt;a href="#" class="a"&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2、这是Sass页面如何进行的嵌套
#app{ span{ background-color: black; } .app2{ .a{ height: 20px; } } } 3、这是转换后css页面的代码
#app span { background-color: black; } #app .app2 .a { height: 20px; } 四、各种简便CSS写法技巧
1、当我们对伪类进行引用时，为了避免代码的重复我们可以使用 &amp; 符号来代替当前的元素，也称为父元素
转换为
2、!global 局部变量变成全局变量
转换为
3、extend =》继承
顾名思义，当我们想要继承父元素的任何元素，都可以使用extend来进行实现（但在目前开发中我认为这个属性可以完全使用类元素进行实现）
4、if-else 条件语句（和我们学的其他语言用法差不多，在使用前多加一个@符号即可，但是目前感觉没啥用）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/730bb0e2cb2fc7b1ddf4cc907fe75cf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a503a3768d957b0f5410cba663d6eadd/" rel="bookmark">
			MDK--KEIL超级实用插件安装，墙裂推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KEIL5安装实用插件，实现格式化代码、文件注释、函数注释等功能 1. 插件包下载：资料包下载 使用步骤 2. 配置操作3. 注释内容模板设置4. 快捷键配置配置完成使用效果展示 1. 插件包下载： 资料包下载 方式1：平台链接：keil5插件包下载
方式2：某云链接：
https://pan.baidu&lt;&lt;可爱的尖括号，使用请删除这段括号&gt;&gt;.com/s/1J33d616PWlCBV3ci_cfzgQ?pwd=yyds 提取码: yyds
好用，麻烦点个赞支持一下。拒绝做伸手党~
使用步骤 2. 配置操作 复制插件“tools”到自己的keil安装目录。
打开keil5，如图
添加插件，选择对应路径文件，输入对应Arguments。
步骤图：
配置截图：
Arguments："$E*.c" "$E*.h"
Arguments：!E
Arguments：!E ~E
Arguments：!E ~E ^E
Arguments：!E ~E ^E T
以上配置完，理论是可以用了
3. 注释内容模板设置 根据自己需求来修改
{FileName} :{}里面自动加载文件名，如：main.c
a源文件代码注释模板：File.c
/** ************************************* Copyright ****************************** * * (C) Copyright {Year},楠瘦,China, GCU. * All Rights Reserved * * By(nanshou) * * * FileName : {FileName} * Version : v1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a503a3768d957b0f5410cba663d6eadd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/278dcf0b2fca6746edcba31c86d7ae09/" rel="bookmark">
			【VUE】elementUI日期组件报错“dateStr.match is not a function“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因为页面有rules
不能和value-fomatter共存
需要删掉value-fomatter
使用@change 写格式转化函数代替
更新：
这样设置后可达到需求
&lt;el-date-picker v-model="form.cartWarrantyTime" type="date" placeholder="选择日期" :placeholder="$t('placeholder.select')" format="yyyy-MM-dd" value-format="yyyy-MM-dd" :editable="false" //设置不可编辑 &gt; &lt;/el-date-picker&gt; rules: [ { required: true, message: '请输入', { field: '输入错误', }), trigger: 'blur', }, ], 注意
如果不加value-foemat，时间会是选定的时间前一天的16:00:00 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3836b1eefe3172694e0e2a82152cfec6/" rel="bookmark">
			一文带你弄懂 CDN 技术的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀 优质资源分享 🚀 学习路线指引（点击解锁）知识定位人群定位🧡 Python实战微信订餐小程序 🧡进阶级本课程是python flask+微信小程序的完美结合，从项目搭建到腾讯云部署上线，打造一个全栈订餐系统。💛Python量化交易实战💛入门级手把手带你打造一个易扩展、更安全、效率更高的量化交易系统目录* 浏览器的网络请求 什么是 CDN ？CDN 工作原理总结 对于 CDN 这个东西，相信大家都有耳闻，感觉既陌生但又熟悉。最近深入了解了一下 CDN，这才发现原来 CDN 如此重要！今天就跟大家科普一下 CDN 是什么，以及为啥要有 CDN，最后再讲一下 CDN 的工作过程！
浏览器的网络请求 要理解 CDN 这件事情，我们就得先理解浏览器发出一个请求的过程是怎样的，其整体过程如下图所示。
用户在浏览器中输入要访问的网址域名。浏览器向本地 DNS 服务器请求对域名的解析。如果本地 DNS 服务器有域名的解析结果，那么直接响应用户请求，返回该域名对应的 IP 地址。如果本地 DNS 服务器没有域名的解析结果，那么则会递归地向 DNS 系统请求解析，随后将该结果返回给用户。浏览器得到域名解析结果后，其实也就是域名对应的 IP 地址。随后浏览器向服务器请求内容。服务器将用户请求内容返回给浏览器。 通过这么复杂的步骤，用户就可以看到页面内容了。但实际上，在第 6、7 这两步的时候，其中间也经过了非常复杂的过程。为了更清晰地表述，我们可以将这个过程分为 3 个主要节点，如下图所示。
网站服务器通过公网出口，再通过长途骨干网，最后通过用户的宽带广猫到达用户所在的局域网，最终才到达用户电脑的浏览器。其中长途骨干网的传输是最为耗时的，它需要经过网站服务器所在的机房、骨干网、用户所在城域网、用户所在接入网等，其物理传输距离非常遥远。 在这种情况下，如果传输的数据非常多，访问的用户特别大，那么就会出现很长的延时，影响用户体验。同时，每请求一次数据都需要经过漫长的数据传输，对于长途骨干网来说，都是一次负担。
刚刚说的这个场景，很形象的一个例子是春节抢票的场景。当我们春节抢票时，我们都会登陆 12306 网站，网站上肯定有不少图片资源。这时候可能同时会有 1 个亿的人，同时去请求一张一模一样的图片。这时候如果我们都按照上面的过程去请求一次图片数据，那么将会产生 1 亿次的网络数据传输，这对于我们整个国家的互联网基础设施是个灾难啊！
但事实情况是：12306 貌似也没有挂掉呀！
那么他们是如何解决这个问题呢？答案就是：CDN！
什么是 CDN ？ 其实 CDN 就是内容分发网络的意思，其英文全称为 Content Delivery Network。简单地说，CDN 可以提前把数据存在离用户最近的数据节点，从而避免长途跋涉经过长途骨干网，最终达到减少骨干网负担、提高访问速度的目的。 按照我们上面的场景，如果没有 CDN 的话，每次请求都需要从网站服务器经过公网出口、长途骨干网、用户接入局域网，最终到达浏览器。但是当有了 CDN 之后，可能就变成了下面这样：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3836b1eefe3172694e0e2a82152cfec6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa145374a1cc18f0ae2f9d70ef61dc71/" rel="bookmark">
			Vue单文件中加载arcgis显示地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div id="content"&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import {loadModules} from 'esri-loader'; import esriConfig from "@arcgis/core/config"; export default { methods: { //创建地图 _createMapView: function() { var _self = this; //定义一个_self防止后续操作中this丢失 var option = { //定义一个包含有JS API中js开发包和css样式文件的对象 url: 'https://js.arcgis.com/4.24/', css: 'https://js.arcgis.com/4.24/esri/themes/light/main.css', }; loadModules(['esri/Map', 'esri/views/MapView'], option) .then(([Map, MapView]) =&gt; { esriConfig.apiKey = "AAPK446e5881d29248d39795a47b359bb81dDvA3xEEUCvMH0qKmoUjUVcqJJ5Yxl27H39r3b7ye41irXy5PnnfbA-XBimuo94Nr"; //业务代码在此处编写 var map = new Map({ //实例化地图 basemap: "topo-vector" }); var view = new MapView({ //实例化地图视图 container: "content", map: map, zoom: 11, center: [104.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa145374a1cc18f0ae2f9d70ef61dc71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c00a0554bff93a7698cd97341753700/" rel="bookmark">
			六自由度机器人（机械臂）运动学建模及运动规划系列（二）——运动学分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇主要介绍六轴机械臂的运动学分析。
运动学分析是工业机器人研究和应用的重要内容，是运动控制的基础，主要研究机器人末端坐标系与基坐标系的转换关系，分为正运动学和逆运动学分析两部分。
另外，对于刚刚学习机器人理论的小伙伴，推荐看一下蔡自兴老师的《机器人学》这本书，里面对机器人介绍，运动学及动力学分析，以及运动规划等内容介绍的非常详细。
本篇目录 一、数理基础1. 空间位姿描述2. 空间坐标变换2. 齐次矩阵与齐次变换 二、运动学建模1.建立连杆坐标系2. 确定连杆参数 三、运动学分析1. 正运动学求解2. 逆运动学求解2.1 求逆解时的注意点： 四、总结 一、数理基础 在对机器人进行运动学分析时，一般将其各组成部分视为刚体，下面介绍运动学分析过程中用到的数理知识。
1. 空间位姿描述 位姿表示刚体的位置和姿态。任何一个刚体在空间基坐标系B（OXYZ）中的位置状态都可以用位姿来准确描述。
位置描述：表示刚体上的点p在空间基坐标系中的位置，可用一个三维列向量来表示：
姿态描述：在刚体上建立坐标系E（O^’ X^’ Y’Z’）并与刚体固连，则刚体坐标系在与基坐标系同原点时，相对于基坐标系的转动即为刚体的姿态描述，可用一个3×3的姿态矩阵来表示：)
在机器人运动运动学分析中，在连杆末端建立坐标系。求得末端坐标系原点在基坐标系中的位置向量以及姿态矩阵后，连杆的位置状态便随之确定。
2. 空间坐标变换 坐标系在机械系统的分析中起着至关重要的作用，系统中不同构件之间的关系都需要用坐标系来描述。在机器人系统中，常常需要定义各类坐标系，如基坐标系，末端坐标系及工具坐标系等。因此进行系统分析时，会涉及到用不同坐标系描述同一个连杆的问题，需要得到从一个坐标系描述到另一个坐标系描述的转换关系。这种转换关系包括平移，旋转，复合变换等。
1）平移变换
若坐标系{E}和坐标系{B}的姿态相同但原点不重合，则P点在两个坐标系中的位置描述满足：
2）旋转变换
若坐标系{E}和坐标系{B}的原点重合但姿态不相同，则P点在两个坐标系中的位置描述满足：
3）复合变换
若坐标系{E}和坐标系{B}的原点不重合且姿态不相同，则将前面两种变换结合在一起，P点的位置描述满足：
2. 齐次矩阵与齐次变换 在机器人学中，将位置向量和姿态矩阵结合起来，形成一个4×4的矩阵，称为齐次矩阵，来统一描述构件的位置和姿态，齐次矩阵表示为：
齐次矩阵不但可以描述构件在空间中的位姿，还可以描述不同坐标系的位姿变换过程。在描述点的坐标时，通过在三维坐标中加入比例因子1，将其变为齐次坐标：
用P点的齐次坐标左乘齐次变换矩阵，得到其在不同坐标系下的位置描述，这种变换称为齐次变换，变换过程可以表示为：
拥有以上数理基础后，可以进行运动学建模及分析。
二、运动学建模 对于多关节串联型的工业机器人，一般采用D-H法建模。D-H 法是 Denavit和Hartenberg在1955年提出的，通过在机器人所有连杆上建立固连坐标系，用齐次变换矩阵描述相邻连杆的关系。下图为D-H法的通用连杆-关节示意图。
D-H法分为标准D-H法和改进D-H法两种，两者在连杆参数定义及变换顺序上略有不同。两种方法均定义了四个参数，包括关节转角θ，关节偏距d，连杆扭角α以及连杆长度a。两种建模方法的不同如下表所示：
D-H法改进D-H法固连坐标系以连杆后一个关节坐标系为其固连坐标系以连杆前一个关节坐标系为其固连坐标系相邻关节坐标系变换顺序θ，d，a，αa，α，d，θ或者α，a，θ，d 1.建立连杆坐标系 D-H法建模的第一步，需要根据机器人确定连杆坐标系。其中，各个坐标系的Z轴方向与关节旋转方向相同，X轴与Y轴的确定可具体查阅资料，D-H法和改进D-H法确定X轴的方式也是不同的。建好的坐标系如下图：
2. 确定连杆参数 这里以改进D-H法为例，介绍四个参数的确定方法。
连杆i-1坐标系经过2次旋转和2次平移可以变换到连杆i的坐标系。这4次变换分别为:
(1) 沿Xi-1轴平移ai-1, 将Oi-1移动到O′i-1;
(2) 以Xi-1为转轴, 旋转αi-1角度, 使新的Zi-1轴与Zi轴同向;
(3) 沿Zi平移di, 使O′i-1移动到Oi;
(4) 以Zi轴为转轴, 旋转θi角度, 使新的Xi-1轴与Xi轴同向。
通过四次变换，便可得到各连杆参数表。对应上图的连杆参数表如下：
三、运动学分析 求解机器人各连杆关节的运动关系称为机器人运动学。已知各连杆夹角以及其余连杆坐标系参数，求解末端执行器的位姿，称为机器人的正运动学求解，反之称为逆运动学求解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c00a0554bff93a7698cd97341753700/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aa8ca124bfc8049cbea8f5bb54b4f67/" rel="bookmark">
			word中表格标题设置重复显示时不成功且表格自动换页问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一篇文档中，表格跨行，需要设置重复标题行，有两种方法
第一种：选中标题行，选择表格属性-行-在各页顶端以标题行形式重复出现；
第二种：选择标题行-布局-重复标题行
但有时会碰到，使用其中任意一种方法后，会出现标题行没有重复出现，但是表格跟文字却分页了，设置不成功的情况。
解决方法：使用第二种方法，即布局的方法，第一次不成功，就取消重复标题行，再设置一次就可以了，如图所示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33d9976a4705d23d08e68275d161ba2b/" rel="bookmark">
			OpenCV——图像细化算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像细化算法 1.基础概念2.细化过程3.代码实现4.实验结果 1.基础概念 图像细化（Image Thinning），一般指二值图像的骨架化（Image Skeletonization）的一种操作运算。细化是将图像的线条从多像素宽度减少到单位像素宽度过程的简称，一些文章经常将细化结果描述为“骨架化”、“中轴转换”和“对称轴转换”。
细化技术的一个主要应用领域是位图矢量化的预处理阶段，相关研究表明，利用细化技术生成的位图的骨架质量受到多种因素的影响，其中包括图像自身的噪声、线条粗细不均匀、端点的确定以及线条交叉点选定等，因而对线划图像进行细化从而生成高质量骨架的方法进行研究具有现实意义。
根据算法处理步骤的不同，细化算法分为迭代细化算法和非迭代细化算法。根据检查像素方法的不同，迭代细化算法又分为串行细化算法和并行细化算法。
迭代算法：即重复删除图像边缘满足一定条件的像素，最终得到单像素宽带骨架。
迭代方法依据其检查像素的方法又可以再分成：
串行算法：在串行算法中，通过在每次迭代中用固定的次序检查像素来判断是否删除像素，在第n次迭代中像素p的删除取决于到执行过的所有操作，也就是必须在第(n-1)次迭代结果和第n次检测像素的基础之上进行像素删除操作；即是否删除像素在每次迭代的执行中是固定顺序的，它不仅取决于前次迭代的结果，也取决于本次迭代中已处理过像素点分布情况。
并行算法：在并行算法中，第n次迭代中像素的删除只取决于(n-1)次迭代后留下的结果，因此所有像素能在每次迭代中以并行的方式独立的被检测；即像素点删除与否与像素值图像中的顺序无关，仅取决于前次迭代效果。
2.细化过程 细化算法有ZS算法和查表法。ZS细化算法是一种基于8领域的并行细化算法，通过对目标像素8领域进行分布的算术逻辑运算，来确定该像素是否能删除。八领域如下图所示。
细化判断依据为：内部点不能删除、孤立不能删除、直线端点不能删除。
ZS细化过程如下：
第一次迭代，若P1满足以下四个条件，说明P1为边界点，可以删除，将P1值设为0：
(1)2 小于等于 Pi从i=2到i=9的和 小于等于6
(2)S(P1)=1;
(3)P2×P4×P6=0;
(4)P4×P6×P8=0;
条件(1)中若P2至P9的和在2至6之间，说明P1为边界点。S(P1)表示目标像素P1的8邻域中，顺时针变化一周像素由0变1的次数。在目标点8邻域P2-P9的范围内，像素值由0变1的次数只能为1次。条件(2)保证了图像细化后的连通性。
第二次迭代中，像素点如果满足第一次迭代中的条件(1)和(2)及以下条件，则移除该像素点：
(5)P2×P4×P8=0;
(6)P2×P6×P8=0;
重复以上迭代过程，直至处理完所有像素点，此时细化完成。
查表法中，由于输入的图像是一张二值图，将其归一化为像素值只有0和1的图像，然后对其进行卷积操作。具体卷积操作为：将目标点的八领域和卷积进行点乘，接着将所有值相加即可得表的索引M，下一步用索引值M去找表中对应的值，对应的值为0或1，就把目标点的像素值修改为0或1，其中1为不可删除点，0位可删除点。重复上述步骤，遍历完所有像素点，对目标点进行查表、修改目标像素值，最后得到细化结果。
3.代码实现 #include&lt;iostream&gt; #include &lt;opencv2\opencv.hpp&gt; using namespace std; using namespace cv; //查表法// Mat lookUpTable(Mat&amp; mat, int lut[]) { Mat mat_in; mat.convertTo(mat_in, CV_16UC1);	//8 转 16 int MatX = mat_in.rows; int MatY = mat_in.cols; int num = 512; //表的维数和卷积核中的数据有关,小矩阵初始化按行赋值 Mat kern = (Mat_&lt;int&gt;(3, 3) &lt;&lt; 1, 8, 64, 2, 16, 128, 4, 32, 256);	//卷积核 Mat mat_out = Mat::zeros(MatX, MatY, CV_16UC1); Mat mat_expend = Mat::zeros(MatX + 2, MatY + 2, CV_16UC1); Rect Roi(1, 1, MatY, MatX);	//（列，行，列，行） Mat mat_expend_Roi(mat_expend, Roi);	//确定扩展矩阵的Roi区域 mat_in.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33d9976a4705d23d08e68275d161ba2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1a471615c3b1f5f39c22f48406f5815/" rel="bookmark">
			JDK8安装与环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在网上看了下JDK的安装与环境配置，发现很多视频以及博客的讲的都很复杂，对初学者很不友好。很多小白看到这些配置步骤都一脸懵，即使一步一步看着操作还是配置失败。这主要是因为很多博主配置了不需要的配置环境，让人觉得很复杂。其实只要配置一步就可以了，是的没错，只需要配置一个地方就可以了，那么下面让我们来看看如何配置
目录
一、JDK的安装
二、JDK的环境配置
三、配置环境的作用
一、JDK的安装 JDK的下载可以去官网，也可以在网上找，这里就不在介绍。
JDK的版本：JDK1.1~JDK1.9 对应的就是 JDK1~JDK9；如 JDK8 其实就是 JDK1.8 的另一个名字，这里我们以JDK8为例
1、找到你下载好的JDK8鼠标右键，选择 以管理员身份运行 2、点击 下一步
3、在开发工具中本身就带有JRE所以不需要另外再下载，直接禁用就可以了
选择 公共JRE --&gt;选择 此功能将不可用
4、 更改安装路径：点击 开发工具 ，再点击 更改 ，选择你要安装的路径，记住这个路径，后续会用到，然后再点击 下一步
如果不更改安装位置，则直接点击 下一步 即可安装完成
注意：安装位置不能有中文
5、安装中
6、安装完成，点击 关闭
到此JDK就安装成功了
二、JDK的环境配置 1、在桌面上选择此电脑，然后鼠标右击，选择 属性
2、选择 关于，然后点击 高级系统设置
3、选择 环境变量
4、配置环境变量
这里我们看到有一个 用户变量 和 系统变量，如果你配置 用户变量，只能供本用户使用，登录别的用户账号则无法使用JDK；如果配置 系统变量，那么无论你登录那个用户账号都能使用JDK
系统变量配置：
选择 Path，然后点击 编辑
进来后点击 新建，然后填入JDK安装路径
找到JDK安装路径，进入bin目录下，然后复制该路径
添加JDK安装路径 ，然后点击 确定
然后再点击 确定，配置完成
5、win键 + r ，输入 cmd ，点击 确定，打开DOS命令窗口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1a471615c3b1f5f39c22f48406f5815/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15abdc038943faa75e38d8e82f493538/" rel="bookmark">
			checkbox 设置默认值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		checkbox 设置默认值 1. 错误写法 &lt;input type="text" id="content" name="content"&gt; &lt;input type="checkbox" id="status" name="status" value="1"&gt; 以下是demo，假设我们在默认状态下提交，生成的参数将会是content=
2. 正确写法 &lt;input type="hidden" value="2" id="status" name="status"&gt; &lt;input type="checkbox" onchange="changeVal()"&gt; &lt;script&gt; // 状态改变，修改隐藏域的值 function changeVal() { if ($("#status").val() == '2') { $("#status").val('1'); } else { $("#status").val('2'); } } &lt;/script&gt; 以下是demo，假设我们在默认状态下提交，生成的参数将会是content=&amp;status=2
3. demo.html &lt;!DOCTYPE html&gt; &lt;html lang="zh"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;check box demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form id="form"&gt; &lt;div&gt; 内容： &lt;input type="text" id="content" name="content"&gt; &lt;/div&gt; &lt;div&gt; 状态： &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15abdc038943faa75e38d8e82f493538/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f82abd8abbdfc6a996bfd279e608efb/" rel="bookmark">
			为什么要使用 playwright 做浏览器自动化测试？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有人给现存的web自动化测试框架分类，第1类叫做 Selenium，第2类叫 Selenium less，间接说明了 Selenium 在 web 自动化测试的统治地位。
如果有项目需要引入web自动化测试，首选就是 Selenium ，因为它具备以下学习优势：
API 非常成熟和稳定，几乎不需要为了适配新的版本修改旧代码；
教程和解决方案非常丰富，如果想学，可以看很多教程，代码出现问题，可以直接在网上收集解决方案。
而其他的自动化测试框架就不具备这个优势了。目前比较流行的 Cypress.io 和Playwright 都提供了详细的官方文档，入门会很简单，但是在实际的操作过程中，如果遇到了一些问题无法解决，在网上很难找到现成的解决方案，就算是一些比较基础的 API 调用，也很难找到使用的案例。
Selenium 除了学习优势
还具备的优势有：
selenium 跨语言。主流的编程语言都有完善的 selenium 库支持，就算是新兴的 go 语言和 rust 语言，都有对应的库。
selenium 不仅可以用在web自动化测试里面，而且拓展到移动端的APP自动化测试；
selenium 的 web driver作为W3C的一个标准，可扩展性能力很强。
生态庞大，不容易被轻易取代，有很多扩展工具可以使用。
selenium 有这么多优势？为什么还会有其他优秀的框架层出不穷呢？
微软做了 playwright ，谷歌做了 pupeteer，由一个小团队做出来的 cypress 也大受欢迎。
为了避免盲目追求新技术，使用新工具，我们有必要想清楚一个问题：
问
一个优秀的 web 自动化测试框架，应该具备什么能力？
第一，它最好是跨语言的，至少应该支持主流的编程语言，才会有更多的人去推动社区发展，供更多人使用。这一点，cypress 和 pupeteer 占劣势，cypress 只支持 JavaScript 语言，pupeteer 虽然支持其他语言，但是都不是官方维护的， playwright 具备多语言的官方维护。
第二，它应该是容易使用的。在外部暴露的API使用起来会比较简单，降低初学者的门槛。它的设计和原理要比较容易理解，这样的话，一些高级开发者能够快速的对其进行二次开发。这一点 selenium 做得不错，不过缺乏高层次的 API 使用，而二次开发出来的上层框架使用起来差异较大，很难统一。其他三个框架的用法都很简单，只是要建立更庞大的社区还需要时间。
第三，安装越简单越好，降低使用门槛。selenium 做得不够好，需要独立去管理浏览器、webdriver 驱动、语言包等多个依赖条件，而 playwright 基本能做到一键安装，连浏览器都整合下载，非常方便。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f82abd8abbdfc6a996bfd279e608efb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a62a3dcde2b345a4392a7503fd130b3/" rel="bookmark">
			【ROS学习】-tf学习(tf_monitor、tf_echo、static_transform_publisher、view_frames)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 本文的内容主要来自 ros wiki 上的教程：http://wiki.ros.org/tf
简短总结：
tf_monitor : 将当前的坐标系转换关系打印到终端控制台。
tf_echo &lt;source_frame&gt; &lt;target_frame&gt; ：把特定的坐标系之间的平移旋转关系，打印到终端控制台。
static_transform_publisher: 发布一个父坐标系到子坐标系的静态tf转换，偏移x/y/z (单位是m)，旋转是欧拉角(或者四元数) ,这里的周期period_in_ms，是这个tf的发布周期，设置为100ms（也就是10hz）是一个很好的值。
view_frames : 可以输出当前的tf关系到pdf中。
roswtf: 帮助你找到tf中的错误。
一、tf_monitor tf_monitor ：将当前的坐标系转换关系打印到终端控制台。
rosrun tf tf_monitor 打印结果：
tf_monitor &lt;source_frame&gt; &lt;target_target&gt;:打印特定的坐标系关系
比如：
rosrun tf tf_monitor /map /base_link 打印结果：
二、tf_echo tf_echo &lt;source_frame&gt; &lt;target_frame&gt; ：把特定的坐标系之间的平移旋转关系，打印到终端控制台。
rosrun tf tf_echo /map /base_link 打印结果：
三、static_transform_publisher 这个是最重要的命令，既可以在命令行使用，也可以在launch文件使用，并且经常在launch文件中使用。主要有下面两种形式：
发布一个父坐标系到子坐标系的静态tf转换，偏移x/y/z (单位是m)，旋转是欧拉角 yaw/pitch/roll (单位是弧度 rad)，这里 yaw是关于Z轴的旋转，pitch是关于关于Y轴的旋转，roll是关于X轴的旋转。这里的周期period_in_ms，是这个tf的发布周期，设置为100ms（也就是10hz）是一个很好的值。 static_transform_publisher x y z yaw pitch roll frame_id child_frame_id period_in_ms 在launch文件中使用格式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a62a3dcde2b345a4392a7503fd130b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/584a68ff2a06f90791fc3d57d8e4eae4/" rel="bookmark">
			【相机硬触发】大恒相机硬触发说明文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大恒相机硬触发说明文档 相机硬触发是区别于软触发，利用IO或者光耦等外部控制信号触发相机快门的技术。
大恒相机有IO触发和光耦触发两种硬触发方式，其中光耦触发隔离了光电回路，对于相机更加安全，但是由于存在光电转换过程所以触发时间延迟了30us左右。硬触发方式只有单次触发，也就是说想要连续获得图片必须向相机发射多次发射方波信号。
硬触发只能通过回调函数获得图片，对于大恒相机只能通过已经定义的回调函数获得图片，回调的数据类型已经确定。
利用IO信号控制相机硬触发 在IO控制线中有line0，line1，line2，line3三根线，前两根是光耦触发线，后两根是IO输入/输出线。注意使用IO控制时还应连接IO地线GND。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2pAw5Fxg-1659436674790)(/home/houbosen/Pictures/Screenshot 2022-07-14 14:00:47.png)]
```` #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;thread&gt; #include "time.h" #include "opencv2/opencv.hpp" #include "../libFSM/include/StateMachine.h" #include "stdio.h" #include "GxIAPI.h" //定义全局变量，用来存图和计时 cv::Mat empty(1024, 1280, CV_8UC3, cv::Scalar::all(0)); timeval tv; long time_end; long time_start; //图 像 回 调 处 理 函 数 //传回来的GX_FRAME_CALLBACK_PARAM *pFrame包含了图像所在指针，大小，长度等一系列信息，需要解码之后变成RGB图片 static void GX_STDC OnFrameCallbackFun(GX_FRAME_CALLBACK_PARAM *pFrame) { if (pFrame-&gt;status == 0) { gettimeofday(&amp;tv, NULL); time_end = tv.tv_sec * 1000000 + tv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/584a68ff2a06f90791fc3d57d8e4eae4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40345bf29f6f4ebf09eb2bcdd22b9844/" rel="bookmark">
			【笔记】FOC学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FOC学习笔记 例程学习
SimpleFOC 英文对应 无刷直流电机(BLDC)
云台电机 -低 KV（高内阻~10Ω）云台电机实际上可以在几乎任何无刷电机驱动器上使用，低速和高扭矩运行时非常平稳。它们可以高质量的代替你的步进电机或者直流伺服电机
高性能无刷直流电机 -高KV（低内阻&lt;1Ω ）高性能无刷电机驱动板上通常有电流检测电路
步进电机-2相4线，相对较高的极对数 &gt;50
编码器（Encoder）
磁传感器（Magnetic sensor）
Hall sensor（霍尔传感器
电机的 a 相， b 相和 c 相直接连接到驱动板的电机输出端子 TB_M1
电源线连接到输入端 TB_PWR
L6234芯片：低功率simpleFOC用的芯片
位置传感器的连接，分类和测试程序 编码器连接 通道 A and B 连接到驱动板的编码器端子 P_ENC的 A 和 B上。如果你的编码器上有 index ，你也可以将它连接到编码器端子的 I上。encoder &gt;
- encoder_example
- encoder_software_interrupts_example 磁传感器-SPI通信 magnetic_sensors &gt;
- magnetic_sensor_i2c_example
- magnetic_sensor_spi_example
- magnetic_sensor_analog_example
磁传感器的 SPI 接口 SCK, MISO 和 MOSI 连接到 Arduino 的 SPI 引脚 (Arduino UNO 13,12 and 11)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40345bf29f6f4ebf09eb2bcdd22b9844/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f030c394a4131bb5bf6b39dbd0e4887/" rel="bookmark">
			vue项目解决页面登录时，禁止浏览器提醒是否保存密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要思路 1.通过input输入框，监听输入值，进行替换成*符号，避免使用input的type="password"类型，造成浏览器提醒是否记住密码；
如果是vue、react等项目请自行改造一下代码！
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;script src="./jquery.min.js"&gt;&lt;/script&gt; &lt;body&gt; &lt;form id="forLogin" method='post' onsubmit="return mdFive();"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt; &lt;table&gt; &lt;tr&gt; &lt;td align="left" class="text"&gt; &lt;div class="text_user"&gt;用户名:&lt;/div&gt; &lt;/td&gt; &lt;td&gt;&lt;input id="input_text_user" name="user" type="text" autocomplete="off" /&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align="left" class="text"&gt; &lt;div class="text_user"&gt;密码:&lt;/div&gt; &lt;/td&gt; &lt;td id="textOrPsw"&gt; &lt;input id="inputText" name="pswView" type="text" autocomplete="off" /&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt; &lt;td&gt; &lt;!-- 此处可以隐藏或将值放到变量中 --&gt; &lt;input name="psw" id="psw" type="text" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f030c394a4131bb5bf6b39dbd0e4887/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18d6bb27e7eaafbc91feac00c6255051/" rel="bookmark">
			圣杯布局与双飞翼布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		圣杯布局 圣杯布局是三列布局，中间宽度自适应，两边定宽，这样做的优势是重要的东西放在文档流前面可以优先渲染。也就是在html文档中，中间的部分要写在左右布局之前。
当然，这种布局是面向PC端的，移动端由于屏幕宽度较小，不推荐多列布局。
DOM结构：
&lt;div class="header"&gt;Header&lt;/div&gt; &lt;div class="bd"&gt; &lt;div class="main"&gt;Main&lt;/div&gt; &lt;div class="left"&gt;Left&lt;/div&gt; &lt;div class="right"&gt;Right &lt;/div&gt; &lt;/div&gt; &lt;div class="footer"&gt;Footer&lt;/div&gt; 1、浮动 + margin-left 的负值（最常用）
&lt;style&gt; *{ margin: 0; padding: 0; } html, body { width: 100%; height: 100%; } .header, .footer { width: 100%; height: 80px; line-height: 80px; background-color: antiquewhite; text-align: center; } /* 中间布局的样式 */ .content { height: calc(100% - 160px); /* 根据左边栏和右边栏的宽度设置padding,留出位置放left和right */ padding: 0 150px 0 200px; } /* main优先渲染，宽度设为100% */ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18d6bb27e7eaafbc91feac00c6255051/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff6994a33108cf3badbef1518a0f833e/" rel="bookmark">
			模型压缩与量化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型压缩目的是减少网络参数量；模型加速的目标则是降低计算复杂度。
模型压缩和加速可以通过多种方式来实现。
首先是针对网络结构本身进行优化改进，常见的如使用3x3的小卷积核取代大卷积核；average-pooling取代了full-connection layers；MobileNets中使用depth-wise convolution替代传统的卷积方式等。
除了根据人工经验和数学模型设计的特有算子结构外，还包括模型剪枝、量化、蒸馏方法。剪枝方法去除神经网络结构中不重要的部分；量化方法则是调整网络结构中的权重或激活值的表达精度；蒸馏方法则是把复杂网络结构的知识转移到较小网络结构上。
其次是在推理框架上做优化，成熟的轻量化框架如TensorRT/Tf-lite/NCNN/MNN等，这些框架能够实现编译优化、缓存优化、算子优化、稀疏存储与计算、加速指令集应用等。能显著的提升模型推理速度。
二．剪枝
剪枝流程
深度神经网络结构中，有着大量的冗余参数。在推理过程中，仅有少部分的权值参与有效的计算，并对推理结果产生主要影响。剪枝方法通过把网络结构中冗余的权值、节点或层去掉，减少网络的规模，降低计算复杂度。让模型在推理效果、推理速度上达到平衡。
类似的，模型剪枝的主要流程如下：
（1）训练一个性能较好的原始模型。原模型网络参数量较大，推理速度较慢。
（2）判断原模型中参数的重要程度。
（3）去除重要程度较低的参数。
（4）在训练集上微调，尽量避免由于网络结构变化而出现的性能下降。
（5）判断模型大小、推理速度、效果等是否满足要求，不满足则继续剪枝。剪枝类型 图. 模型剪枝
从剪枝的基本操作单元来看，可以分为“非结构化剪枝（Unstructured pruning）”和“结构化剪枝（Structured pruning）”两大类。
“非结构化剪枝”主要通过对权重矩阵中的单个或整行、整列的权重值进行修剪。修剪后的新权重矩阵会变成稀疏矩阵（被修剪的值会设置为0）。因而除非硬件平台和计算库能够支持高效的稀疏矩阵计算，否则剪枝后的模型是无法获得真正的性能提升的。
“结构化剪枝”的基本修剪单元是滤波器或权重矩阵的一个或多个Channel。由于结构化剪枝没有改变权重矩阵本身的稀疏程度，现有的计算平台和框架都可以实现很好的支持。
2.1 非结构化剪枝
2.1.1 权值剪枝
剪掉神经元节点之间的不重要的连接。相当于把权重矩阵中的单个权重值设置为0。一般的，会对权重矩阵中所有的数值按照大小排序，把排在后面的一定比例的值设为0即可。
图. 权值剪枝的矩阵表现
2.1.2 神经元剪枝
把权重矩阵中某个神经元节点去掉，则和神经元相连接的突触也要全部去除。相当于同时去除权重矩阵中的某一行和列。如何判断神经元节点的重要程度呢？可以通过计算神经元对应的行和列的权重值的平方和的根的大小进行排序，把排序在后面一定比例的神经元节点去掉。
图. 神经元剪枝的矩阵表现
2.2 结构化剪枝
2.2.1 filter-wise
一个卷积核被剪枝，那么其前一个Feature Map和下一个Feature Map 都会发生相应的变化。
图. Filter-wise剪枝
以上图为例，在第i层卷积中，其中第2、5个卷积核被剪掉（卷积核数量变少，每个卷积核的shape不变）；当i-1层的featruemap经过第i层卷积矩阵卷积后得到的第i层feature map，其中的第2、5个channel也相应的被去除。为了匹配第i层featuremap通道维度产生的变化，第i+1层的卷积中的每个卷积核的第2、5个channel的权重被去除（卷积核数量不变，但每个卷积的shape发生改变）。
为方便观察，把上图中每层卷积核排列成卷积核矩阵的形状，如下图kernel matrix。通过这种形式，我们继续探讨两种剪枝形式。
◎ 单层中卷积核剪枝
图. 剪掉一个卷积核，相关的feature层也同时被剪掉
如上图所示，kernel matrix 中的ni表示第i层feature map的通道深度；ni+1表示第i+1层feature map的通道深度。kernelmatrix中每个卷积核的尺寸为k x k。
从第i个卷积层剪掉n个卷积核的算法过程如下：
（1）计算每个卷积核的权重绝对值之和。
（2）根据的值大小排序。
（3）将最小的n个卷积核及对应的feature map剪掉。下一个卷积层中相关的卷积核也要移除。
（4）生成了第i层和第i+1层新的权重矩阵，剩余的权重参数被复制到新模型中。
◎ 跨多层剪枝
在上图中的i+1层的卷积矩阵中，由于i+1层的featuremap减少一个通道，导致该卷积层中相关的卷积核（一行）被剪枝；如果同时要对该层卷积矩阵中某一列进行剪枝该，则这层卷积矩阵既被上一层的feature map影响，又能影响下一层feature map。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff6994a33108cf3badbef1518a0f833e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1ddef9135536724f4061c25287c9a21/" rel="bookmark">
			图像质量指标：PSNR、SSIM、MSE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直方图方法 方法描述：有两幅图像patch(当然也可是整幅图像)，分别计算两幅图像的直方图，并将直方图进行归一化，然后按照某种距离度量的标准进行相似度的测量。
方法的思想：基于简单的向量相似度来对图像相似度进行度量。
优点：直方图能够很好的归一化，比如256个bin条，那么即使是不同分辨率的图像都可以直接通过其直方图来计算相似度，计算量适中。比较适合描述难以自动分割的图像。
缺点：直方图反应的是图像灰度值得概率分布，并没有图像的空间位置信息在里面，因此，常常出现误判；从信息论来讲，通过直方图转换，信息丢失量较大，因此单一的通过直方图进行匹配显得有点力不从心。
图像模板匹配 一般而言，源图像与模板图像patch尺寸一样的话，可以直接使用上面介绍的图像相似度测量的方法；如果源图像与模板图像尺寸不一样，通常需要进行滑动匹配窗口，扫面个整幅图像获得最好的匹配patch。
PSNR PSNR 在图像处理上主要用于量化受有损压缩影响的图像和视频的重建质量。
（Mean Squared Error）均方误差
一种全参考的图像质量评价指标。
处理图像与原始图像越接近，MSE越小，则PSNR越大。一般来说：
P S N R &gt; 40 d 时，说明图像质量极好（非常接近原始图像）30 d B &lt; P S N R &lt; 40 d B 时，说明图像质量好（存在可以接受的失真）20 d B &lt; P S N R &lt; 30 d B 时，说明图像质量差（存在不可接受的失真）P S N R &lt; 20 时，说明图像质量极差 对于彩色图像，以RGB图像为例，有以下3种方式计算PSNR：
计算RGB三通道每个通道的PSNR值，再求平均计算RGB三通道每个通道的MSE值，取平均，再计算PSNR将RGB转换成YUV颜色空间，仅仅计算Y（亮度）分量的PSNR 其中方法2和方法3较常用。
PSNR是最普遍，最广泛使用的评鉴画质的客观量测法，不过许多实验结果都显示，PSNR的分数无法和人眼看到的视觉品质完全一致，有可能PSNR较高者看起来反而比PSNR较低者差。这是因为人眼的视觉对于误差的敏感度并不是绝对的，其感知结果会受到许多因素的影响而产生变化（例如：人眼对空间频率较低的对比差异敏感度较高，人眼对亮度对比差异的敏感度较色度高，人眼对一个区域的感知结果会受到其周围邻近区域的影响）。
如果两个输入图像的相似，PSNR 返回一个浮点数在30和50之间，(数值越高，相符程度越高).
SSIM （Peak Signal-to-Noise Ratio）峰值信噪比
SSIM(Structural Similarity)，结构相似性，是一种衡量两幅图像相似度的指标。SSIM 主要考量图片的三个关键特征：亮度（Luminance）,对比度（Contrast）,结构 (Structure)
SSIM使用的两张图像中，一张为未经压缩的无失真图像x，另一张为失真后的图像y。
也是一种全参考的图像质量评价指标，它分别从亮度、对比度、结构三方面度量图像相似性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1ddef9135536724f4061c25287c9a21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f672b446ee72c9c0ca2858aca2b4e3a6/" rel="bookmark">
			页面通过js获取并加载远程html文件，移除html文件中不需要的内容，修改html文件中img图片的路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当我们需要在页面加载远程的html文件时，首先需要获取这个文件： this.$axios(htmlUrl) 移除html文件里一些无用的元素，然后加载html： this.$axios(htmlUrl) .then(res =&gt; { // 获取远程html文件，移除其中无用的元素后，加载到textWrap里 let tempDiv = $(`&lt;div&gt;${res.data}&lt;/div&gt;`) tempDiv.find('meta').remove() tempDiv.find('title').remove() tempDiv.find('link').remove() tempDiv.find('script').remove() tempDiv.find('style').remove() textWrap.html(tempDiv.html()) }) 如果html文件中有img图片，我们加载html后img图片可能会因为路径错误而不显示，此时需要修改图片路径： if(textWrap.find('img').length) { textWrap.find('img').attr('src', imgSrc) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa9a8e37e57a578960c255055e166bb6/" rel="bookmark">
			Three.JS程序化建模入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这个教程中，我们将学习如何在 three.js 中制作自己的自定义程序几何，以及如何利用程序几何来制作吸引人的低多边形地形。
学习本教程需要你具备以下基本技能：
基本熟悉three.js应用的结构基础编程知识3d几何的基本知识（顶点，uvs，法线等）任何具有 webgl 兼容网络浏览器的机器关于如何运行 javascript 代码的知识（本地或使用类似jsfiddle的东西） 如果你阅读了我之前的教程，会看到three.js 提供了许多不同的内置基本几何类型，再加上你可以轻松地将自己的3D 模型导入到three.js 中以及为什么需要制作你自己的几何？好吧，一个答案当然是为了好玩！如果你问我这就是你需要的唯一答案。
但是，对于更务实的读者来说，如果你想构建每次运行程序时都独一无二的几何图形，那么生成自己的几何图形也是有益的。或者，如果几何图形需要适应你事先不知道的某些约束，并且使其不适合存储。
1、基本几何体 首先，我们从一个基本Geometry实例开始。在上一个教程中，我们查看了许多不同类型的几何图形，例如SphereGeometry和CylinderGeometry，但出于我们的目的，我们需要一个普通的空Geometry对象。
var geometry = new THREE.Geometry(); var material = new THREE.MeshBasicMaterial(); var mesh = new THREE.Mesh(geometry, material); scene.add(mesh); 现在，我们开始制作实际的几何图形。Three.js 至少需要两件东西才能使用Geometry。首先它需要vertices，如你所知，3D 图形是通过光栅化三角形绘制的。所以我们至少需要一个三角形来绘制一些东西（严格来说这不是真的，但就我们的目的而言，这是一个公平的假设）。我们需要 3D 空间中的 3 个点。其次，我们需要告诉 three.js 如何使用 three.js 将这些点连接在一起。Face3需要 3个点并将它们连接在一起以绘制一个三角形。现在让我们来看看。首先，让我们定义一个简单的三角形。
geometry.vertices.push(new THREE.Vector3( 1, -1, 0)); geometry.vertices.push(new THREE.Vector3( 0, 1, 0)); geometry.vertices.push(new THREE.Vector3(-1, -1, 0)); geometry.faces.push(new THREE.Face3(0, 1, 2)); 请注意直接访问顶点数组和面数组是多么容易？这是three.js中Geometry类的好处。如果我们使用 BufferGeometry这将更加复杂。但是BufferGeometry速度稍快，因此你面临权衡取舍。
在我们继续之前还有几点。注意我们的面是如何取三个整数的。这些是我们三个顶点中每个顶点的数组索引。我们在事务中定义它们的顺序。在多个面中引用同一个顶点并没有错。事实上，这允许我们重用一些顶点并节省一些空间。让我们看看它现在是如何工作的。
geometry.vertices.push(new THREE.Vector3( 1, -1, 0)); geometry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa9a8e37e57a578960c255055e166bb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d06328667c79c6030e7af6fffed27fb/" rel="bookmark">
			spring data JPA 学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考学习视频：哔哩哔哩中的图灵课堂中的徐庶老师。
本篇博客是自己学习jpa的笔记记录，笔记主要来源是视频中老师的讲解和加上个人的一些理解，仅供参考。
目录
jpa学习前言
为什么要用spring data
什么是jpa
jpa与jdbc对比
mybatis与hibernate的对比
hibernate搭建与测试(hibernate原始的操作)
spring data jpa基本入门
CrudRepository接口提供的常用方法
基本的分页与排序演示
jpa的自定义操作
使用jpql进行自定义
使用原生sql进行自定义
按照规定的方法名来进行操作
jpa的动态条件查询（重难点）
Query by Example
Specifications
Querydsl
jpa学习前言 为什么要用spring data spring data主要是用来实现数据存储的，那么我们使用mybatis，jdbc不行吗？为什么还要去学一门新技术？因为随着互联网业务的发展，业务的场景越来越复杂，单一的关系型数据库不再是最优的选择，但是随着数据库种类与数据库中间技术的变多，开发人员的学习成本和企业的招聘成本都会加剧上升，但是spring data可以对多种数据库进行操作，这样就大大减少了我们的学习成本。spring data帮我们统一了数据访问层，减低了学习成本，提升了开发效率。
什么是jpa JPA全称Java Persistence API（2019年重新命名为 Jakarta Persistence API ），是Sun官方提出的一种ORM规范。 O:Object R: Relational M:mapping
该规范为我们提供了：
① ORM映射元数据：JPA支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对 象持久化到数据库表中； 如：@Entity 、 @Table 、@Id 与 @Column等注解。
② JPA 的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发者从繁琐的JDBC和 SQL代码中解脱出来。 如：entityManager.merge(T t)；
③ JPQL查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。 如：from Student s where s.name = ? （注意这个查询语句中的Student是类对象，name是该对象的属性）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d06328667c79c6030e7af6fffed27fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a6a99435ca6a5e6ba343b19ce1e16e/" rel="bookmark">
			post请求返回403
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		post 请求返回 403
导入模块：
from django.views.decorators.csrf import csrf_exempt
在函数前面添加修饰器：
@csrf_exempt
2. 原因：
当采用客户端象 django 的服务器提交 post 请求时，会得到403，权限异常。
因为 django 针对提交的请求，有校验。所以会如此。
客户端提交的 post 如果不加这段，会出现 403 error
@csrf_exempt
def runoob(request):
name = request.POST.get(“name”)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f0828abcbba0ea70e174d1c5681c28c/" rel="bookmark">
			Ubuntu20.04成功安装google浏览器，并正常使用Bing等其他搜索引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu20.04安装google浏览器，并正更换其他搜索引擎 一、下载谷歌浏览器源文件二、在linux终端运行如下命令安装三、安装完后，更换搜索引擎 一、下载谷歌浏览器源文件 方式一：下载地址（64位）
谷歌浏览器源文件地址
https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
方式二：命令行下载安装Chrome
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 二、在linux终端运行如下命令安装 sudo dpkg -i google-chrome-stable_current_amd64.deb 报错用：
sudo apt-get -f install
三、安装完后，更换搜索引擎 安装完后，打开google浏览器缺不能打开网页不能查询，换了搜索引擎也不能用
解决办法：打开终端运行 ：
sudo apt install --reinstall libnss3 google-chrome-stable 问题解决了！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a22d840a41cffb33b5b313f496990124/" rel="bookmark">
			禁用防火墙后，aria2的6800端口还是不通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器新安装aria2后，想通过aria2浏览器插件远程管理，但是无论如何都连接不上服务器，禁用了防火墙(ufw和iptables)后依然连接不上。
首先在另一台机器使用telnet命令测试一下端口的连通性，发现并不通。
telnet ip地址 6800 使用nginx代理一个端口803，再次测试连通性。
可以看到803端口是连通的，也就排除了防火墙的问题，问题应该出在aria2本身。
查看aria2的运行状态，可以看到程序监听了6800端口，也是完全正常的。
于是查看一下6800端口的情况：
此时终于发现问题所在，原来aria2c只监听了localhost的6800端口！也就是说只有管理程序安装在本地才能连通端口。查看官方文档，发现--rpc-listen-all可以控制监听的网络。
加上这一参数启动，再测试端口连通性，发现是连通的。
回到aria2的浏览器插件，此时也已经连接上了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db1b3e2983d70d6acd5aaeaf62531d24/" rel="bookmark">
			un7.30:Linux——在docker容器中显示MySQL数据库中文。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇博客中，我们已经在docker中成功安装了MySQL，接下来，我就给大家分享一下，如何在docker中使用MySQL，包括在docker容器中显示MySQL的中文字字符。
一、输入指令进入，注意换一下端口号，或者把之前的端口号停掉，命令：docker run -d -p 3309:3309 --privileged=true -v /usr/share/mysql/log:/var/log/mysql -v /usr/share/mysql/data:/var/lib/mysql -v /usr/share/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=Aa123123. --name m2 mysql
二、查看运行的镜像，命令：docker ps
三、 进入到路径下，命令：cd /usr/share/mysql/conf/
四、新建my.cnf,添加下列内容，
[client]
default_character_set=utf8
[mysqld]
collation_server = utf8_general_ci
character_set_server = utf8
五、输入指令再次查看，我们可以看到和我们刚才添加的内容一模一样，命令：cat my.cnf
六、查看运行容器，命令：docker ps
七、重启查看，命令：docker restart m2
八、登录，命令：mysql -uroot -p
九，输入指令查看字符串类型，命令：SHOW VARIABLES LIKE 'character%';
十、再次建表查看。
1、show databases;
2、create database db01;
3、use db01;
4、create table t1(id int,name varchar(20));
5、insert into t2 values(1,'zs');
6、即可看到虚拟机上可以显示中文字符了，命令：select * from t1;
如此，我们便可实现在docker容器中展示中文这一功能了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a17fcf615f883253cea0938376c863/" rel="bookmark">
			MachineLearning 11.  机器学习之随机森林生存分析（randomForestSRC）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击关注，桓峰基因
桓峰基因公众号推出机器学习应用于临床预测的方法，跟着教程轻松学习，每个文本教程配有视频教程大家都可以自由免费学习，目前已有的机器学习教程整理出来如下：
MachineLearning 1. 主成分分析（PCA）
MachineLearning 2. 因子分析（Factor Analysis）
MachineLearning 3. 聚类分析（Cluster Analysis）
MachineLearning 4. 癌症诊断方法之 K-邻近算法（KNN）
MachineLearning 5. 癌症诊断和分子分型方法之支持向量机（SVM)
MachineLearning 6. 癌症诊断机器学习之分类树（Classification Trees)
MachineLearning 7. 癌症诊断机器学习之回归树（Regression Trees)
MachineLearning 8. 癌症诊断机器学习之随机森林（Random Forest)
MachineLearning 9. 癌症诊断机器学习之梯度提升算法（Gradient Boosting)
MachineLearning 10. 癌症诊断机器学习之神经网络（Neural network)
MachineLearning 11. 机器学习之随机森林生存分析（randomForestSRC）
今天介绍一下生存分析的另一种方法建模，别只用Cox回归了，试试机器学习之随机森林生存分析（randomForestSRC）怎么样？
前言 随机生存森林通过训练大量生存树，以表决的形式，从个体树之中加权选举出最终的预测结果。
构建随机生存森林的一般流程为：
Ⅰ. 模型通过“自助法”（Bootstrap）将原始数据以有放回的形式随机抽取样本，建立样本子集，并将每个样本中37%的数据作为袋外数据（Out-of-Bag Data）排除在外；
Ⅱ. 对每一个样本随机选择特征构建其对应的生存树；
Ⅲ. 利用Nelson-Aalen法估计随机生存森林模型的总累积风险；
Ⅳ. 使用袋外数据计算模型准确度。
生存，竞争风险生存设置需要一个时间和审查变量，应该在公式中使用标准生存公式规范作为结果。一个典型的公式是这样的:Surv()~。状态是用户数据集中事件时间和状态变量的变量名。对于生存森林(Ishwaran et al. 2008)，审查变量必须编码为一个非负整数，0为审查保留，(通常)1=死亡(事件)。对于竞争风险森林(Ishwaran et al.， 2013)，实现类似于生存，但有以下注意事项:审查必须编码为非负整数，其中0表示审查，非零值表示不同的事件类型。而0,1,2,…，J为标准，建议事件可以不连续编码，但必须始终使用0进行审查。将拆分规则设置为logrankscore将导致生存分析，其中所有事件都被视为相同类型。通常，竞争风险需要比生存设置更大的节点大小。
软件安装 RandomForestSRC 是美国迈阿密大学的科学家 Hemant Ishwaran和 Udaya B.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7a17fcf615f883253cea0938376c863/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee958890e8651ef219803e1bc03111cf/" rel="bookmark">
			BERT、ALBERT、RoBerta、ERNIE模型对比和改进点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. BERT总结
MLM (Masked language model)NSP (Next Sentence Prediction) MLM ：
在一句话中随机选择 15% 的词汇用于预测。对于在原句中被抹去的词汇， 80% 情况下采用一个特殊符号 [MASK] 替换， 10% 情况下采用一个任意词替换，剩余 10% 情况下保持原词汇不变。这么做的主要原因是：在后续微调任务中语句中并不会出现 [MASK] 标记，而且这么做的另一个好处是：预测一个词汇时，模型并不知道输入对应位置的词汇是否为正确的词汇（ 10% 概率），这就迫使模型更多地依赖于上下文信息去预测词汇，并且赋予了模型一定的纠错能力。上述提到了这样做的一个缺点，其实这样做还有另外一个缺点，就是每批次数据中只有 15% 的标记被预测，这意味着模型可能需要更多的预训练步骤来收敛。
bert 缺点：
MLM直接对单个token进行随机mask，丢失了短语和实体信息，这一点对中文尤其明显，百度ERNIE对其进行了改进MLM仅预测被mask的token，其他token没有参与到预测中。而GPT等语言模型可以对每个token进行预测。导致MLM训练效率偏低，训练时间过长。这一点BERT论文自己也提到了，ELECTRA围绕这一点进行了改进。NSP任务可以学到sequence level信息，但仅为一个二分类，且负样本构造过于简单，导致模型不能充分训练。之前BERT的消融分析中也看到了，NSP对下游任务的作用比MLM要小。SpanBERT、ALBERT、Roberta均提到了这一点，并进行了相关改进，或者干脆弃用NSP。 2. ALBERT
嵌入层矩阵分解 跨层参数共享SOP(Sentence Order Prediciton) 正例与NSP相同，但负例是通过选择一篇文档中的两个连续的句子并将它们的顺序交换构造的。这样两个句子就会有相同的话题，模型学习到的就更多是句子间的连贯性。用于句子级别的预测（SOP）。SOP 主要聚焦于句间连贯，用于解决原版 BERT 中下一句预测（NSP）损失低效的问题。
3. RoBERT
4. ERNIE
增加 短语 和 实体 级别的 mask 方式， 融合外部知识添加优质中文语料DLM, Dialog 语料 总结：
模型总结改进点BERT中文以字为单位表示的通过两个训练任务采用多层transformer的encoder部分（核心是多头attention）的预训练模型比word2vec更能够动态得到词语在不同语境下的向量表示，能够解决word2vec上下文无关问题ALbert精简版的BERT，参数量减小了，克服扩展模型困难的问题1、因式分解:将词嵌入层先映射到一个低维空间，再映射到隐藏层 2、跨层参数共享 3、SOP：提升性能Roberta更为精细的bert调优版本，采用更大数据，更大batch_size，动态mask（中文采用全词mask），去掉NSP，采用全句子策略训练1、改进优化函数，更大的模型参数量
2、动态mask（全词mask）
3、去掉下一句预测任务
4、采用更大的batchERINIE融合了更多知识，mask的时候采用短语和实体级别的mask，添加了更多优质语料融合了更多知识，mask的时候采用短语和实体级别的mask，添加了更多优质语料 参考：
BERT、ALBERT、RoBerta、ERNIE模型对比和改进点总结 - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bb5cdfc5ede2c857e3ee7b0033f007e/" rel="bookmark">
			这个用PHP开发的全开源商城系统可免费商用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近两年，开源一直是技术圈非常火热的话题，拥抱开源已是大势所趋，互联网精神本就以开放、分享为核心，去开源平台Github及国内的Gitee溜达一圈，可以发现许多优秀的开源项目，废话不多说，今天给大家分享一款真正可免费商用的好开源商城系统，绝对精品！
颜值高 这是个看脸的时代，第一印象很重要，美的东西总能让人赏心悦目，程序也是如此，界面美观，用起来都舒服！
项目结构如图： 项目代码结构 └─view uni-app存放根目录
├─api 接口统一存放目录
│ ├─activity.js 活动接口
│ ├─admin.js 后台订单管理接口
│ ├─api.js 公共接口
│ ├─order.js 订单接口
│ ├─public.js 授权分享接口
│ ├─store.js 产品接口
│ └─user.js 用户接口
├─components 组件目录
│ ├─addressWindow 地址组件
│ ├─countDown 倒计时组件
│ ├─couponListWindow 优惠券列表弹框组件
（商品详情、提交订单）
│ ├─couponWindow 优惠券弹出框组件
（首页）
│ ├─goodList 商品展示组件
│ ├─home 悬浮导航组件
│ ├─jyf-parser 富文本框组件
│ ├─Loading 正在加载组件
│ ├─orderGoods 订单产品展示组件
│ ├─payment 支付弹出框组件
│ ├─PriceChange 后台更改价格组件
│ ├─productConSwiper Swiper产品轮播图组件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bb5cdfc5ede2c857e3ee7b0033f007e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61ddcb1889e041c596eb54e272e61cab/" rel="bookmark">
			AUTOSAR学习笔记2——CANIF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CanIf：
在AUTOSAR中与上层通信层与CAN驱动程序服务接口
1、初始化CANIF
CanIf_InitMemory() 初始化全局配置，将CANIF初始化成原始数据
CanTrcv_xxx_InitMemory() 、CanTrcv_xxx_Init() 初始化CAN收发器，要在CanIf_Init()之前就 要把收发器设置成正常状态
Can_InitMemory() 、 Can_Init() 初始化CAN存储以及初始化CAN（也要在CanIf_Init()之前调用）
CanIf_Init（） 初始化所有的CAN接口控制器，
CanIf_SetControllerMode(0, CANIF_CS_STARTED) 配置CANIF在CAN控制器0的状态为启动状态
CanIf_SetPduMode(0, CANIF_SET_ONLINE) 配置CAN接口在CAN控制器0上的模式为在线模式
在初始化CANIF之前要先调用 EcuM_BswErrorHook()，当产生下面任一错误时初始化操作就会停止
错误1：ECUM_BSWERROR_NULLPTR 指向配置的指针无效
错误2：ECUM_BSWERROR_COMPATIBILITYVERSION 收发器不兼容
错误3：ECUM_BSWERROR_MAGICNUMBER 罕见的数字错误
2、通信
控制器模式：物理状态上控制，有停止（CANIF_CS_STOPPED）、启动（CANIF_CS_STARTED）、睡眠（CANIF_CS_SLEEP）、不初始化（CANIF_CS_UNINIT），每次进行转换都要先停止再切换，比如要想从开始模式切换到睡眠模式，就要先让切换到停止模式再切换到睡眠模式 （这些函数要用这个CanIf_SetControllerMode()来设置）
PDU（数据协议单元）模式：完全由软件进行处理。只有在CANIF_CS_STARTED模式下PDU模式才能运行
CANIF_GET_OFFLINE TX和RX都离线
CANIF_GET_RX_ONLINE TX离线，RX在线
CANIF_GET_TX_ONLINE TX离线，RX在线
CANIF_GET_ONLINE TX和RX都在线
CANIF_GET_OFFLINE_ACTIVE TX和RX都离线，有接口进行模拟操作
CANIF_GET_OFFLINE_ACTIVE_RX_ONLINE TX离线、RX在线，由接口进行模拟操作
如果启用了参数r CanIfPnWakeupTxPduFilterSupport下面也可以使用：
CANIF_GET_TX_ONLINE_WAKF TX在线，RX离线
CANIF_GET_ONLINE_WAKF TX和RX切换在线
只要设置了CANIF_GET_ONLINE 和 CANIF_GET_TX_ONLINE其中一种就会激活PUD模式
PDU模式可以通过函数CanIf SetPduMode()来设置，也可以通过函数CanIf_GetPduMode()来检索。
3、传输：只有在初始化成功之后、CAN设备启动之后、CANIF在于启动状态并且TX/RX在线，才能传输PUD
TX请求必须调用CanIf_Transmit(, )，（底层调用的是CAN_Write()函数）
如果在总线上传输成功，那就会有一个轮询函数确认，然后传输到上层，所有需要配置一个回调函数
1）TX数据截断：通过CanIfTxPduTruncation参数配置截断特性，数据长度超出设置的长度，就会进行截断发送。如果没配属性且长度超出就不会传输且报错 CANIF_E_TXPDU_LENGTH_EXCEEDED
2）动态的传输：通过Dynamic Tx Objects参数激活（与静态不同的是ID属性可以选择）可以使用CanIf_SetDynamicTxId()来配置ID
3）发送缓冲区：同一时间有很多的数据需要发送，这些数据就存在发送缓冲区中，等待按照优先级或者先进先出进行发送
1）FIFO（frist in frist out先进先出：那一条数据先进入缓冲区就哪一条数据先发送
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61ddcb1889e041c596eb54e272e61cab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bf44891f2370e79956d30429595fcc3/" rel="bookmark">
			System类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		System 类 System 类包含一些有用的类字段和方法。它不能被实例化。
在 System 类提供的设施中，有标准输入、标准输出和错误输出流；对外部定义的属性和环境变量的访问；加载文件和库的方法；还有快速复制数组的一部分的实用方法。
成员变量 // 标准输入流，常用于键盘录入 public final static InputStream in = null // 标准输出流，常用于打印信息 public final static PrintStream out = null; // 标准错误输出流，常用于打印错误信息 public final static PrintStream err = null; public class SystemFieldDemo { public static void main(String[] args) { // 通过Scanner测试标准输入 Scanner sc = new Scanner(System.in); String next = sc.next(); // 通过System.out.print测试标准输出流 System.out.println(next); sc.close(); // 通过System.err.print测试标准输出流 System.err.println("打印错误报告"); } } 构造方法 构造方法私有化，无法创建对象
/** Don't let anyone instantiate this class */ private System() { } arraycopy() 这个方法表示复制数组，从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bf44891f2370e79956d30429595fcc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82b2e2b824362a48f1dd87a75a3c3c99/" rel="bookmark">
			Zabbix笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zabbix笔记 监控项 创建监控项 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-DenKI1yb-1655547267051)(C:\Users\zwp\AppData\Roaming\Typora\typora-user-images\image-20211014190625793.png)]
键值
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ph9cTW9e-1655547267052)(C:\Users\zwp\AppData\Roaming\Typora\typora-user-images\image-20211014190702136.png)]
监测—&gt;最新数据
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Cc8sJD8J-1655547267053)(C:\Users\zwp\AppData\Roaming\Typora\typora-user-images\image-20211014190921646.png)]
监控项的值映射 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mkS6rMez-1655547267054)(C:\Users\zwp\AppData\Roaming\Typora\typora-user-images\image-20211014191141037.png)]
创建值映射
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3B9u2quf-1655547267054)(C:\Users\zwp\AppData\Roaming\Typora\typora-user-images\image-20211014191232685.png)]
运用到监控器
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ki7uR9cN-1655547267055)(C:\Users\zwp\AppData\Roaming\Typora\typora-user-images\image-20211014191435888.png)]
自定义监控项 配置
[root@web-01 ~]# cat /etc/zabbix/zabbix_agent2.d/default.conf UserParameter=sda.tps,iostat | grep sda | awk '{print $2}' UserParameter=mem.used,free -m | awk '/^Mem/ {print $3/$2*100}’ UserParameter=mem.ava,free -m | awk '/^Mem/ {print 100-$3/$2*100}‘ systemctl restart zabbix_agent2 测试
[root@web-01 ~]# zabbix_agent2 -t mem.ava mem.ava [s|67.9494] [root@web-01 ~]# zabbix_agent2 -t mem.used mem.used [s|31.8857] [root@web-01 ~]# server获取数据
安装zabbix-get数据包
yum -y install zabbix-get 获取数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82b2e2b824362a48f1dd87a75a3c3c99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92f989edcf955887ae9861415750659d/" rel="bookmark">
			思科RSTP组网实验（快速生成树协议）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1.1 RSTP简介 RSTP协议是在STP协议（生成树协议）的基础上进行了部分改进，实现网络拓扑的快速收敛。简单理解，RSTP比STP快！并且拥有STP协议的所有内容。（个人理解而已，非专业解释！）
1.1.2 组网拓扑图 1.1.3 实验目标 两处的计算机网络通过两台交换机互连组成内部网,为了提高网络的可靠性,作为网络管理员,你要用2条链路将交换机互连,现要求在交换机上做适当配置,使网络避免环路。 1.1.4 全局配置命令 （1）SW0交换机跟网桥的配置
Switch&gt;en Switch#conf t Switch(config)#vlan 10	//创建VLAN Switch(config-vlan)#int f0/1	//进入接口 Switch(config-if)#switchport mode access //把接口设置成access模式 Switch(config-if)#switchport access vlan 10	//把接口划给vlan 10 Switch(config-if)#exit Switch(config)#int range f0/2 - 3	//批量操作f0/1和f0/2 Switch(config-if-range)#switchport mode trunk //接口模式设置为trunk模式 Switch(config-if-range)#switchport trunk allowed vlan all	//允许所有VLAN通过 Switch(config-if-range)#exit Switch(config)#spanning-tree mode rapid-pvst //生成树配置从快速生成树RSTP模式 Switch(config)#spanning-tree vlan 10 priority 4096 //把SWO交换机配置成根网桥 （2）SW1交换机备份网桥的配置（交换机生成树的默认优先级为327268）
Switch&gt;en Switch(config)#vlan 10 Switch(config-vlan)#int f0/1 Switch(config-if)#switchport mode access Switch(config-if)#switchport access vlan 10 Switch(config-if)#exit Switch(config)#int range f0/2 - 3 Switch(config-if-range)#switchport mode trunk Switch(config-if-range)#switchport trunk allowed vlan all Switch(config-if-range)#exit Switch(config)#spanning-tree mode rapid-pvst 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92f989edcf955887ae9861415750659d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec9ad072cbc5cebf5f52a985188c5002/" rel="bookmark">
			yocto（六）——搭建yocto环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yocto环境没了，重新构建一下。说来惭愧，先写了后面的文章，才来补环境搭建~~~
文章参考官方手册：https://docs.yoctoproject.org/brief-yoctoprojectqs/index.html
准备环境 我的系统是ubuntu20.04，执行以下命令安装依赖包。
sudo apt install gawk wget git diffstat unzip texinfo gcc build-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping python3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint3 xterm python3-subunit mesa-common-dev zstd liblz4-tool 其他发行版环境依赖可查看这个网址。
提醒：后续所有操作均不需要root权限！！！后续所有操作均不需要root权限！！！后续所有操作均不需要root权限！！！
选择yocto版本 1.下载需要使用Git，配置方法网上有太多教程了，自行百度一下。
2.找个空闲的目录下载yocto。
mkdir yocto cd yocto git clone git://git.yoctoproject.org/poky 3.选择一个长期支持的版本，点击这个网站查看。
上图可以看到后续稳定支持的版本所有三个，我们选择一个新的，即kirkstone版本。
注意：新版本的yocto语法有些改动，比如操作符分割不再使用下划线_了，而是使用:符号，在编写yocto配方时候需要特别注意！！！
cd poky git branch -a #查看所有分支 git checkout -t origin/kirkstone -b my-kirkstone #选择kirstone分支 后续如果需要更新yocto的话执行：
git pull 构建yocto $ cd poky $ source oe-init-build-env You had no conf/local.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec9ad072cbc5cebf5f52a985188c5002/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cd06a2ff6a9804e01e24358618a8a84/" rel="bookmark">
			CRMEB全开源Java版微信小程序商城，附源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CRMEB-JAVA版简介 CRMEB商城JAVA版，SpringBoot + Maven + Swagger + Mybatis Plus + Redis + Uniapp +Vue 包含移动端、小程序、PC后台、Api接口；有产品、用户、购物车、订单、积分、优惠券、营销、余额、权限、角色、系统设置、组合数据、可拖拉拽的form表单等模块，大量的减少了二开的成本。
CRMEB-JAVA版主要特性 有详细的代码注释，有完整系统手册SpringBoot框架
使用SpringBoot框架框架开发前端采用Vue CLI框架
前端使用Vue CLI框架nodejs打包，页面加载更流畅，用户体验更好标准接口
标准接口、前后端分离，二次开发更方便支持队列
降低流量高峰，解除耦合，高可用无缝事件机制
行为扩展更方便，方便二次开发数据表格导出
Excel数据导出,导出表格更加美观可视；数据统计分析
后台使用ECharts图表统计，实现用户、产品、订单、资金等统计分析强大的后台权限管理
后台多种角色、多重身份权限管理，权限可以控制到每一步操作强大的表单生成控件
可以自由配置开发表单，减少前端工作量，后端接口统一调用 CRMEB-JAVA版项目地址： Gitee: https://gitee.com/ZhongBangKeJi/crmeb_java
如果对您有帮助，您可以点右上角 “Star” 支持一下 谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4702d5ac1a21444e9f035c6572598e0/" rel="bookmark">
			qps tps rps 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qps query per second
每秒查询数
例如一次 sql 查询就是一次 query
tps transaction per second
每秒事务数
例如一次事务 sql 包含 3 个语句, 那么其实是一次事务
rps request per second
每秒请求数
例如请求一次 http 接口, 就是一次 request
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/835d00a11aefaf697cad6b9e331958da/" rel="bookmark">
			yocto（二）——bitbake工作流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考yocto官方手册，如有理解不当之处，欢迎留言指出。
项目概述和概念手册：https://docs.yoctoproject.org/overview-manual/index.html
项目参考手册：https://docs.yoctoproject.org/ref-manual/index.html
yocto项目的厨师——bitbake ​ bitbake是OpenEmbedded构建系统的引擎，通过解析一系列配置文件（主要为recipes，即bb/bbappend文件）来创建任务列表，并根据依赖关系依次执行。通过bitbake -c listtasks xxx（模块名或映像名）命令可以查看编译一个模块或整个映像所需任务名称。编译一个模块/映像的主要执行过程如下（内核除外）：
​ 下面按四个阶段来讲解bitbake的执行过程及涉及的变量，其中第四阶段（上图标黄的两任务）不是编译每个模块都有的。
源码获取及处理 ​ 这个阶段包含三个任务，分别为do_fetch、do_unpack、do_patch。
原文件来源
​ yocto编译一个模块所需的源代码或开源组件从哪里获取？
​ 如上图所示，源码可以从上游开源项目（如busybox-1.28.3.tar.bz2）、本地项目（本地源代码）、软件配置管理（如git）中获取。
do_fetch任务：根据配置文件中SRC_URI变量所指定的方式获取源代码。
do_unpack任务：如果源文件需要解压，则该任务会将源码包解压到指定目录下。
do_patch任务：如果对开源项目进行了修改，则这个任务可以为解压后的源码打补丁，比如对linux开源内核源码进行了修改。
这个大阶段涉及的配置变量有以下：
SRC_URI
​ 源文件列表变量，位于配方（recipe）文件中。每个recipe必须有一个指向源的SRC_URI变量。
SRC_URI = "git://github.com/openbmc/linux;protocol=git;branch=${KBRANCH}" #表示从github上下载linux内核源码 SRC_URI += "file://defconfig" #表示从本地目录获取内核默认配置，目录的路径由FILESPATH变量指定 ​ 以下列举常用的获取方式，更多的获取方式请参阅SRC_URI。
​ file://-从本地机器 获取文件，通常是元数据附带的文件（例如补丁、内核配置、uboot配置文件），路径是相对于FILESPATH变量的。构建系统默认在配方同目录下名为“${BP}”、"${BPN}"、"files"的目录下查找指定文件，如需增加额外路径，便通过FILESPATH和FILESEXTRAPATHS指定。
​ 注意：如果源码是本地文件，确保每个文件都使用file://写出，而不是使用指定文件夹方式下载整个文件夹，因为yocto需要单独检查每个文件是否被修改。
​ bzr://-从 Bazaar 版本控制存储库中获取文件。
​ git://-从 Git 版本控制存储库中获取文件。
​ 如果是从本地仓库下载，则先配置好本地Git仓库。yocto依赖与git的版本控制，简单来说就是yocto每次编译时候，会去检查软件包的源文件是否修改，只有修改过才会让软件包重新编译，那么对于git仓库就是对比上一次与当次版本差异。所以，对于源码在本地的git仓库的软件包，需要在每次编译前进行以下操作：
git add ./* git commit -m "test" ​ 这样就可以确保本地git仓库源码修改后能参与yocto工程编译。
​ svn://-从 Subversion (svn) 版本控制存储库中获取文件。
​ http://-使用http。
​ https://-使用https。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/835d00a11aefaf697cad6b9e331958da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f5debad9ab5002fb4db39c7ba34c357/" rel="bookmark">
			管理基础知识20
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		波特五力模型[掌握]
波特五力模型是迈克尔·波特（Michael Porter）于20世纪80年代初提出。他认为行业中存在着决定竞争规模和程度的五种力量，这五种力量综合起来影响着产业的吸引力以及现有企业的竞争战略决策。五种力量分别为同行业内现有竞争者的竞争能力、潜在竞争者进入的能力、替代品的替代能力、供应商的讨价还价能力、购买者的讨价还价能力。
竞争战略从一定意义上讲是源于企业对决定产业吸引力的竞争规律的深刻理解。任何产业，无论是国内的或国际的，无论生产产品的或提供服务的，竞争规律都将体现在这五种竞争的作用力上。因此，波特五力模型是企业制定竞争战略时经常利用的战略分析工具。
SWOT战略分析法[掌握]
SWOT分析是在外部环境与内部环境分析的基础上，将外部环境中的机会与威胁和内部的优势与劣势结合在一起的一种分析方法。SWOT这几个字母分别代表的含义是：优势（Strengths)、劣势（Weaknesses）、机会（Opportunities）和威胁（Threats）。
SWOT分析的基本步骤
（1）分析组织的内部优势与劣势，既可以相对组织目标而言，也可以相对竞争对手而言。
（2）分析组织面临的外部机会与威胁，可能来自于与竞争无关的外部环境因素的变化，也可能来自于竞争对手力量与因素变化，或二者兼有，但关键性的外部机会与威胁应予以确认。
（3）将外部机会和威胁与组织内部优势和弱点进行匹配，形成可行的组织发展战略。
运用SWOT分析的实例
［案例］小峰的SWOT分析情况
基本情况：小峰，男，石家庄某大学计算机科学与技术专业大二学生，在校期间学习了计算机编程等方面的专业理论知识，具有较强的逻辑推理能力，性格开朗，勤奋好学，踏实稳重。
生涯目标：软件工程师
小峰的SWOT分析情况
SWOT分析法是一种能够较客观而准确地分析自我的方法，利用这种方法可以从中找出对自己有利的、值得发扬的因素，以及对自己不利的、如何去避开，发现存在的问题，找出解决的办法，并明确以后的发展方向。
内部个人因素
优势优点
1. 做事认真踏实，勤奋好学；为人随和，容易交往，值得信赖。
2. 热爱数学和编程，理解、数理、推理能力强，对新知识接收快，尤其是对计算机软件编程方面有浓厚的兴趣
3. 进取心强，尊重强者，崇尚科学，追求技术
4. 英语书面能力强，有一定的口语表达能力
5. 富有极强的责任感和耐心，且喜欢做软件编程方面的工作
弱势缺点
1. 没有工作阅历，专业实际应用能力欠缺
2. 不善言辞，与陌生人交往能力差
3. 职业素质还达不到软件公司的要求
4. 工作学习有些保守，冒险精神不够，并且创新能力有待提高
外部因素
发展机会
1. 计算机专业，属于热门专业，将来就业前景比较好，社会需求量大
2. 石家庄是河北省会，并且建立了动漫基地，IT服务行业发展前景好，毗邻北京、天津，地理位置佳
3. 软件行业是朝阳产业，待遇优厚
阻碍威胁
1. 社会中学习计算机人数多，普通技能人才多，竞争激烈
2. 在学校所学知识偏重理论，而忽视实际应用，知识陈旧
3. 母校实力有限，知名度不高
4. 自己的家庭务农，没有强大的社会关系，只能靠自己
最大优势：对计算机软件编程方面有浓厚兴趣；学习能力强，理解、数理、推理能力强；英语书面水平好，有责任感和耐心。
应对策略：利用自己专业优势，个性优势，能力优势和发展环境优势，继续学习和掌握计算机理论课程，学习软件开发有关知识，积极参加社会实践，到公司中学习和锻炼，参与一些软件开发项目，提高专业实际应用能力，积累开发经验，了解IT行业发展情况，努力提高自己的职业素质和能力，提高与人交往的能力，建立人脉关系，为就业做好准备。
PEST分析法[掌握]
PEST分析是指宏观环境的分析，P是政治(politics)，E是经济(economy)，S是社会(society)，T是技术(technology)。在分析一个企业集团所处的背景的时候，通常是通过这四个因素来进行分析企业集团所面临的状况。
进行PEST分析需要掌握大量的、充分的相关研究资料，并且对所分析的企业有着深刻的认识，否则，此种分析很难进行下去。经济方面主要内容有经济发展水平、规模、增长率、政府收支、通货膨胀率等。政治方面有政治制度、政府政策、国家的产业政策、相关法律及法规等。社会方面有人口、价值观念、道德水平等。技术方面有高新技术、工艺技术和基础研究的突破性进展。 （1）政治环境：政治环境主要包括政治制度与体制，政局，政府的态度等；法律环境主要包括政府制定的法律、法规。
（2）经济环境：构成经济环境的关键战略要素：GDP、利率水平、财政货币政策、通货膨胀、失业率水平、居民可支配收入水平、汇率、能源供给成本、市场机制、市场需求等。
（3）社会环境：影响最大的是人口环境和文化背景。人口环境主要包括人口规模、年龄结构、人口分布、种族结构以及收入分布等因素。
（4）技术环境：技术环境不仅包括发明，而且还包括与企业市场有关的新技术、新工艺、新材料的出现和发展趋势以及应用背景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56b537ba95a616e2903ab9e46f87aa60/" rel="bookmark">
			18、优化网站性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地缓存 将数据缓存在应用服务器上，性能最好。（要考虑缓存大小，缓存的过期时间）常用缓存工具：Ehcache、Guava、Caffeine等。 分布式缓存 将数据缓存在NoSQL数据库上，跨服务器。常用缓存工具：MemCache、Redis等。 多级缓存 一级缓存（本地缓存）&gt; 二级缓存（分布式缓存）&gt; DB
避免缓存雪崩（缓存失效，大量请求直达DB），提高系统的可用性 本地缓存适合与用户无强关联的信息，Redis可以缓存与用户强关联的信息(如 登录凭证)，可以跨服务器，但比本地缓存稍微慢些
两级缓存的过程：
本地缓存 数据变化频率相对较低的数据比较使用于缓存。将热门帖子列表缓存到本地缓存中。使用Caffeine。
1、自定义配置
# caffeine caffeine.posts.max-size=15 // 设置缓存空间里缓存多少对象，缓存的列表的对象是page caffeine.posts.expire-seconds=180 // 3min 缓存数据的更新一般有两种方式：1、数据发生更新 2、缓存到了过期时间
3、优化业务方法，一般是优化Service。
使用Caffeine 缓存 帖子列表和总的行数
Caffeine的核心接口是Cache，其有两个子接口 LoadingCache, AsyncLoadingCache。LoadingCache 是同步缓存，AsyncLoadingCache可以实现异步、并发。
@Value("${caffeine.posts.max-size}") private int maxSize; @Value("${caffeine.posts.expire-seconds}") private int expireSeconds; // Caffeine核心接口: Cache, LoadingCache, AsyncLoadingCache // 帖子列表缓存 private LoadingCache&lt;String, List&lt;DiscussPost&gt;&gt; postListCache; // 帖子总数缓存 private LoadingCache&lt;Integer, Integer&gt; postRowsCache; @PostConstruct public void init() { // 初始化帖子列表缓存 postListCache = Caffeine.newBuilder() .maximumSize(maxSize) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56b537ba95a616e2903ab9e46f87aa60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8543a3fb02be40edfd8504a3fd51476/" rel="bookmark">
			17、生成长图，并上传至服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成长图 1、wkhtmltopdf介绍 wkhtmltopdf url filewkhtmltoimage url file 2、java中使用wkhtmltopdf（异步执行） Runtime.getRuntime().exec(cmd) 服务器把定义的cmd命令交给操作系统后，便继续向下执行了，即异步。
package com.nowcoder.community; import java.io.IOException; public class WkTests { public static void main(String[] args) { String cmd = "d:/work/wkhtmltopdf/bin/wkhtmltoimage --quality 75 https://www.nowcoder.com d:/work/data/wk-images/3.png"; try { Runtime.getRuntime().exec(cmd); System.out.println("ok."); } catch (IOException e) { e.printStackTrace(); } } } 3、服务器端生成长图 检查并创建目录
@Configuration public class WkConfig { private static final Logger logger = LoggerFactory.getLogger(WkConfig.class); @Value("${wk.image.storage}") private String wkImageStorage; @PostConstruct public void init() { // 创建WK图片目录 File file = new File(wkImageStorage); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8543a3fb02be40edfd8504a3fd51476/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49ebc45fcfba5f51f7db00a592cbeeb9/" rel="bookmark">
			3天快速入门python机器学习（黑马xxx）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、 机器学习概述1.1 人工智能概述1.1.1介绍1.1.2 机器学习、深度学习能做些什么1.1.3 人工智能阶段课程安排 1.2 什么是机器学习1.2.3 数据集构成 1.3 机器学习算法分类1.3.1 分类1.3.2 小练习1.3.3 机器学习算法分类 1.4 机器学习开发流程1.5 学习框架和资料介绍1.5.1 机器学习库和框架1.5.2 书籍资料 二、特征工程2.1 数据集2.1.1 可用数据集（针对本次三天学习而言）2.1.2 sklearn数据集2.1.3 数据集的划分 2.2 特征工程介绍2.2.1 为什么需要特征工程(Feature Engineering)2.2.2 什么是特征工程2.2.3 特征工程的位置与数据处理的比较 2.3 特征提取2.3.1 特征提取2.3.2 字典特征提取2.3.3 上述总结2.3.3文本特征提取2.3.5 总结 2.4 特征预处理2.4.1 什么是特征预处理2.4.2 归一化2.4.3 标准化 2.5 特征降维2.5.1 降维 - 降低维度2.5.2 降维的两种方式2.5.3 特征选择2.5.4 低方差特征过滤 2.6 主成分分析2.6.1 什么是主成分分析(PCA)2.6.2 案例：探究用户对物品类别的喜好细分 三、分类算法3.1 sklearn转换器和估计器3.1.1 转换器 - 特征工程的父类3.1.2 估计器(sklearn机器学习算法的实现) 3.2 K-近邻算法（KNN）3.2.1 什么是K-近邻算法3.2.2 k-邻近算法API3.2.3 案例1：鸢尾花种类预测3.2.4 K-近邻总结 3.3 模型选择与调优3.3.1 什么是交叉验证(cross validation)3.3.2 超参数搜索-网格搜索(Grid Search)3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49ebc45fcfba5f51f7db00a592cbeeb9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/218/">«</a>
	<span class="pagination__item pagination__item--current">219/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/220/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>