<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f60be25cac31429ae1e7f5373f1cc4ea/" rel="bookmark">
			VSCode 出现 正在保存“xxxx.vue”: 从 “‘Vetur‘, ‘ESLint‘“(configure)中获取代码操作。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版本降级
自动更新了0.37版本有问题
切到0.36.1，禁用更新
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94f99fe69a41a4f71b461afb81c8333f/" rel="bookmark">
			WebGPU学习（3）---使用IndexBuffer（索引缓冲区）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在让我们将 IndexBuffer 与 VertexBuffer 一起使用。演示示例
1.准备索引数据 我们用 Uint16Array 类型来准备索引数据。我们将矩形的4个点放到 VertexBuffer 中，然后根据三角形绘制顺序，组织成 0–1–2 和 0–2–3 的结构。
const quadIndexArray = new Uint16Array([0, 1, 2, 0, 2, 3]); 2.创建IndexBuffer 接下来，我们使用 WebGPU API 创建一个 IndexBuffer。使用逻辑设备g_device的createBuffer()方法。
const indicesBuffer = g_device.createBuffer({ size: quadIndexArray.byteLength, usage: GPUBufferUsage.INDEX, mappedAtCreation: true, }); 3.将顶点索引数据设置为从GPUBuffer映射的Uint16Array new Uint16Array(indicesBuffer.getMappedRange()).set(quadIndexArray); indicesBuffer.unmap(); 接下来将 Uint16Array 的顶点数据设置为 IndexBuffer 。使用 GPUBuffer 的getMappedRange方法创建一个新的 Uint16Array 类型变量， 并将quadIndexArray数据进行设置填充。设置完成后，使用unmap()方法取消内存映射。（这几步其实跟上一篇文章基本一致）
4.将IndexBuffer设置为RenderPipeline 使用setIndexBuffer()方法将 IndexBuffer 设置为 RenderPipeline。
此外，使用drawIndexed()作为绘图函数来替代之前的draw()。
const commandEncoder = g_device.createCommandEncoder(); const renderPassEncoder = commandEncoder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94f99fe69a41a4f71b461afb81c8333f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acf6b9a48570859228b459ea69cbb62e/" rel="bookmark">
			CMake编译opencv4.6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 openCV系列文章目录 文章目录 openCV系列文章目录前言一、准备工作二、使用步骤1.使用CMake编译openCV 总结 前言 最近在项目中遇到图片处理，一拍脑袋就想到大名鼎鼎的opencv
一、准备工作 1.openCV官网下载
2.CMake官方下载
3.vs2019官方下载
二、使用步骤 1.使用CMake编译openCV 在点击Configure后报错：
CMake Warning at cmake/OpenCVDownload.cmake:248 (message):
IPPICV: Download failed: 28;“Timeout was reached”
For details please refer to the download log file:
E:/openCV/opencv-4.6.0_build/CMakeDownloadLog.txt
Call Stack (most recent call first):
3rdparty/ippicv/ippicv.cmake:37 (ocv_download)
cmake/OpenCVFindIPP.cmake:259 (download_ippicv)
cmake/OpenCVFindLibsPerf.cmake:12 (include)
CMakeLists.txt:733 (include)
这个应该是编译opencv源码的通用问题，主要是网络问题，无法下载ippicv包，这里提供一个手动寻找安装包的方式，步骤如下：
（1）1. 在opencv源代码中获取ippicv的下载地址
首先打开opencv-x.x.x\3rdparty\ippicv\ippicv.cmake文件，分别找到如下语句
ippicv_2019_lnx_intel64_general_20180723.tgz
将
中的
修改成
（2）生成vs工程
（3）编译OpenCV.sln
打开OpenCV.sln,生成对应的lib、dll
编译报错
估计是换行符引起的，所以把：
修改成：
把二维string数组写到一行，编译通过
（4）生成lib、dll路径
总结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/350a4a00cc687527baabe9329d55b443/" rel="bookmark">
			C/C&#43;&#43;项目开发：双色球彩票系统！C语言告诉你中奖并不是偶然！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.bilibili.com/video/BV1uh411D7Wh/?spm_id_from=333.999.0.0&amp;vd_source=ddb210d09ec373c5da8a60f4910c4020
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; // 双色球彩票 //电脑自动生成双色球 void CreateBall(int arr[]); //打印双色球 void PrintBall(int arr[]); //冒泡排序 void ButtleSort(int arr[], int length); //判断是否中奖 void IsWin(int user[],int computer[]); int main() { while (1) { //分别表示用户和电脑的球号 int user[7], computer[7]; printf(" ---------------------------------- \n"); printf("| |\n"); printf("| 双色球彩票系统 |\n"); printf("|游戏规则： |\n"); printf("| 红球：（1-&gt;33）任选6个红球 |\n"); printf("| 蓝球：（1-&gt;16）任选1个蓝球 |\n"); printf("| |\n"); printf(" ---------------------------------- \n"); printf("请您先选择6个红球（1-&gt;33重复）：\n"); for (int i = 0; i &lt; 6; i++) { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/350a4a00cc687527baabe9329d55b443/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5999f7f0889e65590d60b30546c63b79/" rel="bookmark">
			小程序启动页动画实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序刚被加载时是有自己默认动画的，但是这个千篇一律。我们其实可以做个性化的加载，带来一点不一样的感觉。比如下面的例子：
小程序加载动画
这个是怎么做的呢？使用的是wx.createAnimation 这个API，具体如下：
wx.createAnimation 首先有大概是下面的页面结构：
&lt;view class="progress_wrapper"&gt; &lt;image src="../../static/home/slider.png" class="slider" animation="{{animationData}}"&gt;&lt;/image&gt; &lt;u-line-progress :percentage="percent" inactiveColor="rgba(0,0,0,.6)" activeColor="#fff" class="p_bar"&gt;&lt;/u-line-progress&gt; &lt;view class="text-box"&gt; &lt;text&gt;加载中...{{tweened.toFixed(0)}}%&lt;/text&gt;&lt;/br&gt; &lt;text&gt;资源正在疯狂加载中，请耐心等待哦&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; 在小程序首页，onLoad方法中添加代码，页面加载时触发。
Page({ data: { animationData: {}, percent: 0 }, onLoad: function(options) { // 隐藏tabBar wx.hideTabBar() // 获取设备宽度定位slider const info = wx.getSystemInfo() // 创建动画的方法 const animation = wx.createAnimation({ duration: 1000, timingFunction: 'ease', }) // 按步骤执行动画 1. 让滑块移动到大约40%的位置 animation.translate((info.windowWidth-60)*0.4).step() //this.animationData = animation.export() //this.percent = 44 this.setData({ animationData: animation.export(), percent: 44 }) // 延时2秒 执行动画2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5999f7f0889e65590d60b30546c63b79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be87d977fe95897f128c8cead6fbe3ff/" rel="bookmark">
			关于解决VS中LINK : fatal error LNK1168: 无法打开的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法（言简意赅）：
1，打开任务管理器（ctrl+alt+delete)——结束VS应用进程
2.选择与你电脑相匹配的位数
像我电脑是64位的，所以我选择的是x64（x86指的是32位的电脑）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/127f109bb6a9d0e5b27e50b362a9811c/" rel="bookmark">
			超简单的使用mmyolov5  balloon实验的讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLOv5 从入门到部署全流程 — MMYOLO 0.4.0 文档
①打开anaconder的promp
②执行如下命令
activate open-mmlab-YOLOV5 ## 启动自己为了运行yolov5准备的环境 cd D:\桌面替代\pytorch学习资料\python程序\mmyolo-main\ #跳转到从官方下载的mmyolo文件包路径 python tools/train.py configs/yolov5/yolov5_s-v61_syncbn_fast_1xb4-300e_balloon.py ##用官方的tool运行实验程序 注意：
第一行的环境名称是自定义的按照个人的命名开启
第二行的文件路径也是自定义，用户自行修改
运行成功后可以有如下效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33678a0e0524cd4b0d36e591c9503c06/" rel="bookmark">
			vs2022 x64 C/C&#43;&#43;和汇编混编
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vs2022环境x64 C/C++和汇编混编 vs64位程序不支持__asm内嵌汇编，需要单独编写汇编源文件示例如下1、新建空的win32项目，新建main.cpp，示例代码如下2、新建asm64.asm汇编源文件，示例代码如下3、编译器配置，选择x64，debug或者release都可以，4、直接生成即可 vs64位程序不支持__asm内嵌汇编，需要单独编写汇编源文件 示例如下 1、新建空的win32项目，新建main.cpp，示例代码如下 #include &lt;Windows.h&gt; extern "C" void __stdcall asm_func(const char* lpText); extern "C" UINT GetMsgBoxType() { return MB_YESNOCANCEL; } int main() { asm_func("Hello world!"); return 0; } 2、新建asm64.asm汇编源文件，示例代码如下 .data msgCaption db 'Message box text',0 .code align 16 extern GetMsgBoxType : proc extern MessageBoxA : proc extern __imp_MessageBoxA : qword asm_func proc ; RCX = address for the string for the message box sub	rsp, 28h	; shadow stack only [n]8 size lea	rdx, [msgCaption] mov	r8, rcx call	GetMsgBoxType mov	r9, rax xor rcx, rcx ;call	[__imp_MessageBoxA] call MessageBoxA add	rsp, 28h	; restoring shadow stack ret asm_func endp end 3、编译器配置，选择x64，debug或者release都可以， 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33678a0e0524cd4b0d36e591c9503c06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d78ced0346186062fbc7064ae6c9b6b4/" rel="bookmark">
			后台管理项目笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备 建立项目 npm install -g @vue/cli
vue create managesys--创建vue2
配置其他 router npm install vue-router@3.5.0
router/index.js import Vue from 'vue' import Router from 'vue-router' Vue.use(Router) const routers=[] const router=new Router({	routes:routers}) export default router store npm install vuex@3.1.2 --save
store/index.js import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) const store=new Vuex.Store({ state:{}, mutation:{}, }) export default store axios npm install axios@0.18.0 --save api/config.js import axios from "axios"; export function request(config) { const instance = axios.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d78ced0346186062fbc7064ae6c9b6b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f6d4686a82b97834beada0e380581b8/" rel="bookmark">
			Qt之界面（自定义标题栏、无边框、可移动、缩放）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果 注意：由于需要调用 Windows 上的头文件与库，所以不能跨平台，只支持 Windows 系统。如果想要跨平台，可以使用鼠标等事件实现，具体百度搜索参考下。 自定义标题栏 titleBar.h
#ifndef TITLEBAR_H #define TITLEBAR_H #include &lt;QLabel&gt; #include &lt;QPushButton&gt; class titleBar : public QWidget { Q_OBJECT public: explicit titleBar(QWidget *parent = nullptr); ~titleBar(); protected: //双击标题栏进行界面的最大化/还原 virtual void mouseDoubleClickEvent(QMouseEvent *event); //进行界面的拖动 virtual void mousePressEvent(QMouseEvent *event); //设置界面标题与图标 virtual bool eventFilter(QObject *obj, QEvent *event); private slots: //进行最小化、最大化/还原、关闭操作 void onClicked(); private: //最大化/还原 void updateMaximize(); private: QLabel *m_pIconLabel; //标题栏图标 QLabel *m_pTitleLabel; //标题栏标题 QPushButton *m_pMinimizeButton; //最小化按钮 QPushButton *m_pMaximizeButton; //最大化/还原按钮 QPushButton *m_pCloseButton; //关闭按钮 }; #endif // TITLEBAR_H titleBar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f6d4686a82b97834beada0e380581b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6e72d9449c17ae4a1c89da0920f0ae0/" rel="bookmark">
			时间序列数据预测的类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要内容是使用LSTM网络进行不同类型的时间序列预测任务，不涉及代码，仅仅就不同类型的预测任务和数据划分进行说明。
参考文章：https://machinelearningmastery.com/how-to-develop-lstm-models-for-time-series-forecasting/
注：所涉及的概念在数据案例会说明
时间序列数据预测本质就是利用先前的值预测后面的值，在得到一组数据后，需要将数据处理为一个个样本，每个样本中包括先前的数据和要预测的数据，将其作为训练集
1 单变量时间序列数据预测 单变量时间序列数据指的是，除了时间属性数据，只有单一属性的一组数据，比如2010一年间黄金的价格，按天统计，也就是一天一个数据。数据中只有价格这一个属性，共365个数据。
同时单变量也是指数据只有一个序列，一个变量也就是一个特征（feature）。
1.1 单步预测 单步预测中的单步是指一个时间步长（time step），比如上述黄金价格数据中，每一天就是一个时间步长，即在时间序列数据中每获取一次数据就是一个时间步。
单步预测就是仅仅预测一个时间步长的数据。
单变量时间序列数据的单步预测（单变量单步预测，Univariate Step）：利于前边几个时间步长的数据预测下一个时间步长的数据
数据处理：
数据集dateset [10, 20, 30, 40, 50, 60, 70, 80, 90] 上面的少量数据中，只是单一属性的一组数据。在进行预测前要将数据处理为样本（假设使用3个时间步长的数据预测下一个时间步长的数据），样本结构如下：
以下数据共有6个样本，每个样本中都是前三个时间步长的数据为一组作为输入，下一个时间步长的数据为另一组作为输出。
[10 20 30] 40 [20 30 40] 50 [30 40 50] 60 [40 50 60] 70 [50 60 70] 80 [60 70 80] 90 即： 输入	输出 [[10, 20, 30],	[40, [20, 30, 40].	50, ……	]	] 使用这样的数据训练一个模型后，我们就可以使用前连续三个时间步长的数据预测下一个时间步长的数据。
最后我们在看一下样本中输入数据和输出数据的维度：
输入：两个维度，样本总数、用于预测的时间步长，这里分别是6、3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6e72d9449c17ae4a1c89da0920f0ae0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e80222d14cd29f1fe1c38592d9e74e3c/" rel="bookmark">
			NGINX关键特性解析：负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NGINX是一款高性能的Web服务器软件，同时也是一个反向代理服务器。负载均衡是NGINX的一个关键特性之一，可以将客户端请求分摊到多个后端服务器上，从而提高系统的吞吐量和稳定性。在本文中，我们将深入探讨NGINX的负载均衡特性，包括其优势、算法、配置和实践等方面。
一、负载均衡的优势
提高系统的吞吐量：将客户端请求分摊到多个后端服务器上，可以减少每个服务器的负载压力，从而提高系统的吞吐量和处理能力。
提高系统的稳定性：当某个服务器出现故障时，负载均衡可以自动将请求转发到其他健康的服务器上，从而保证系统的稳定性和可用性。
提高系统的可扩展性：通过增加后端服务器的数量，可以实现系统的横向扩展，从而应对高并发和大流量的场景。
二、负载均衡算法
NGINX支持多种负载均衡算法，包括轮询、IP哈希、权重、最少连接等方式。不同的算法可以根据实际场景进行选择，以下是常用的负载均衡算法：
轮询算法（Round Robin）：将客户端请求依次分配给每个后端服务器，循环往复。轮询算法简单易实现，适用于后端服务器性能相近的场景。
IP哈希算法（IP Hash）：根据客户端的IP地址进行哈希计算，将同一个IP地址的请求转发到同一个后端服务器上。IP哈希算法适用于需要长连接或会话保持的场景。
权重算法（Weighted Round Robin）：根据后端服务器的权重，分配不同比例的请求。权重算法可以根据后端服务器的性能和资源进行动态调整。
最少连接算法（Least Connections）：将请求转发到当前连接数最少的后端服务器上。最少连接算法适用于需要长时间连接的场景，例如视频会议、游戏等。
三、负载均衡的配置
在NGINX中配置负载均衡非常简单，只需要使用upstream模块定义后端服务器的列表，并在server模块中使用proxy_pass指令将请求转发到后端服务器上即可。以下是一个简单的负载均衡配置示例：
http { upstream backend { server backend1.example.com; server backend2.example.com; server backend3.example.com; } server { listen 80; location / { proxy_pass http://backend; } } } 在上述示例中，我们定义了一个名为backend的upstream列表，其中包含了三个后端服务器。其中，backend1.example.com的权重为5，表示其可以处理更多的请求；backend2.example.com和backend3.example.com的权重为默认值1。在server模块中，我们使用proxy_pass指令将所有请求转发到backend列表中的服务器上。
此外，NGINX还支持其他的负载均衡配置选项，例如keepalive、health check、upstream hash等。这些选项可以提高系统的性能和可用性，并且可以根据实际需求进行配置和调整。
upstream的语法如下：
Copy code upstream group_name { server server1; server server2; ... } 其中group_name是这组服务器的名称，可以自定义，后面需要用到；server是要负载均衡的服务器列表，可以是IP地址或域名。
例如，我们定义一个名为my_servers的upstream组，其中包含两个服务器：
Copy code upstream my_servers { server 192.168.1.101; server 192.168.1.102; } 此外，NGINX还支持其他的负载均衡配置选项，例如keepalive、health check、upstream hash等。这些选项可以提高系统的性能和可用性，并且可以根据实际需求进行配置和调整。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e80222d14cd29f1fe1c38592d9e74e3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84b6addbded0da075865194aec29155d/" rel="bookmark">
			【Proteus仿真】【51单片机】洗衣机控制系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、功能简介二、软件设计三、实验现象联系作者 一、功能简介 本项目使用Proteus8仿真51单片机控制器，使用LED指示模块、数码管显示模块、DS18B20温度模块、电机驱动模块、水位传感器模块等。
主要功能：
系统运行后，数码管显示初始水位和时间，通过按键K1选择水位，按键K2选择工作模式且对应模式指示灯亮；当按下K3键设定烘干温度，K1和K2调节温度值。当选择好模式和水位，按下K4键开始工作；如果不是甩干和烘干模式下，开始会进水，等待水位到达指定高度后开始洗涤工作，然后按照指定时间洗涤漂洗和脱水。在脱水时，出水指示灯亮。结束后蜂鸣器报警提示。若水位高度超过报警值，则电机停止，蜂鸣器报警。当工作在烘干模式，当前温度低于设定温度值，开启加热，到达阈值后关闭加热。
二、软件设计 /* 作者：嗨小易（QQ：3443792007） */ //系统参数初始化 void sys_parm_init(void) { sys_ctrl.mode=0; sys_ctrl.start=0;	sys_ctrl.lev_set=LEVEL_SW_MIN; sys_ctrl.time=0; sys_ctrl.time_flag=0; sys_ctrl.sec=0; sys_ctrl.run_sta=0; sys_ctrl.lev_flag=0; sys_ctrl.level=0; sys_ctrl.work_time[0]=sys_ctrl.time*2/5;//洗涤时间 sys_ctrl.work_time[1]=sys_ctrl.time*1/5;//漂洗时间 sys_ctrl.work_time[2]=sys_ctrl.time*2/5;//脱水时间 sys_ctrl.set_temp=30; sys_ctrl.temp_flag=0; _led_mode_show(sys_ctrl.mode); WORK_XD_LED=1;WORK_PX_LED=1;WORK_TS_LED=1; JS_LED=1;CS_LED=1; JR_LED=1; motor_stop(); } //暂停阶段参数设置 void _pause_parm_init(void) { JS_LED=1;CS_LED=1; JR_LED=1; motor_stop();	} //系统数据采集 void sys_data_get(void) { static u8 i=0; while(1) { //如果在洗涤和漂洗阶段进行水位检测 if(sys_ctrl.run_sta&lt;2) { //获取水位 sys_ctrl.level=pcf8591_read_adcvalue(0); sys_ctrl.level=cal_map(sys_ctrl.level,0,255,0,99);	} if(sys_ctrl.start==1) { i++; if(i%10==0) { //温度检测 sys_ctrl.temp=ds18b20_read_temperture();	}	} break; }	} //系统数据显示 void sys_data_show(void) { u8 buf[4]; while(1) { //如果系统还未开始时，显示 if(sys_ctrl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84b6addbded0da075865194aec29155d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dbfbd403c89e24a6d1c352b26314b64/" rel="bookmark">
			Vue组件间通信的四种方式（函数回调，自定义事件，事件总线，消息订阅与发布）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概述 props配置项-回调函数实现
自定义事件实现
事件总线实现
消息订阅与发布实现（pubsub-js库）
概述 在组件化编程中，组件间的通信是重要的，我们可以有四种方式实现组件间的通信。
分别是：函数回调，自定义事件，事件总线和消息订阅与发布。
props配置项-回调函数实现 需求：父组件（App.vue）给子组件（Student.vue）传递数据 父组件想要给子组件传递数据，只需要父组件在使用子组件的位置直接声明传递即可，子组件使用props配置项接收父组件传入的数据。
App组件（父组件）
&lt;template&gt; &lt;div id="app"&gt; &lt;!--将data中的数据name传入Student子组件--&gt; &lt;Studnet :name="name"&gt;&lt;/Studnet&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Studnet from './components/Studnet.vue' export default { name: 'App', data(){ return { name:"Tom" } }, components: { Studnet } } &lt;/script&gt; Studnet组件（子组件）
&lt;template&gt; &lt;div&gt; &lt;button @click="printAppData"&gt;点击&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:"Student", // 子组件Student使用props配置项接收父组件传入的数据 // 接收时注意需要加引号 props:["name"], methods:{ printAppData(){ // 当点击事件触发后直接打印传入的数据 console.log(this.name); } } } &lt;/script&gt; 当父组件传递给子组件数据后，像如上案例，传入的数据会存在子组件的data中，是响应式的。 测试 ：当我们点击按钮后，查看控制台
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dbfbd403c89e24a6d1c352b26314b64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76e49bd4fac416caad1c6a15dada35c9/" rel="bookmark">
			JSP九大内置对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		九大内置对象 前言 九大内置对象：request、response、session、application、page、pageContext、out、config、exception。四大作用域：page、request、session、application作用域的有效期限：
page作用域的变量只在当前页面中有效，只要页面跳转了，page域中的变量重新计算。
request里的变量可以跨越forward前后的两页。但是只要刷新页面，它们就重新计算了。
session作用域体现在会话中，当未关闭游览器时，session中的变量是通用的，当关闭重新启动游览器，重新发起新的会话时，session域中的变量重新计算。
application里的变量一直在累加，除非你重启tomcat，否则它会一直变大九大内置对象对应的作用域
request作用域：request对象
session作用域：session对象
application作用域：application对象
page作用域：response、page、pageContext、out、config、exception 对象 1、request对象： request 对象是 javax.servlet.httpServletRequest类型的对象。 该对象代表了客户端的请求信息，主要用于接受通过HTTP协议传送到服务器的数据。（包括头信息、系统信息、请求方式以及请求参数等）。request对象的作用域为一次请求
是客户端对服务器发出的请求。客户端的请求信息被封装在request对象中，通过它发送请求给服务器。它是HttpServletRequest类的实例。作用域为request(用户请求期）。
常用方法： 1. object getAttribute(String name) 返回指定属性的属性值（常用） 2. Enumeration getAttributeNames() 返回所有可用属性名的枚举 3. String getCharacterEncoding() 返回字符编码方式（常用） 4. int getContentLength() 返回请求体的长度（以字节数） 5. String getContentType() 得到请求体的MIME类型 6. ServletInputStream getInputStream() 得到请求体中一行的二进制流 7. String getParameter(String name) 返回name指定参数的参数值（常用） 8. Enumeration getParameterNames() 返回可用参数名的枚举 9. String[] getParameterValues(String name) 返回包含参数name的所有值的数组 10. String getProtocol() 返回请求用的协议类型及版本号 11. String getScheme() 返回请求用的计划名,如:http.https及ftp等 12. String getServerName() 返回接受请求的服务器主机名 13.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76e49bd4fac416caad1c6a15dada35c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dab064d5daf69f9d2f802aec6cfc93df/" rel="bookmark">
			应急响应入门之Linux分析排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 当企业发生黑客入侵、系统崩溃或其它影响业务正常运行的安全事件时，急需第一时间进行处理，使企业的网络信息系统在最短时间内恢复正常工作，进一步查找入侵来源，还原入侵事故过程，同时给出解决方案与防范措施，为企业挽回或减少经济损失。 针对常见的攻击事件，结合工作中应急响应事件分析和解决的方法，总结了一些 Linux 服务器入侵排查的思路。
01文件分析-敏感文件信息 在linux系统下一切都是文件，其中/tmp是一个特别的临时目录文件。每个用户都可以对它进行读写操作。因此一个普通用户可以对/tmp目录执行读写操作。
查看敏感目录文件，如 tmp目录、可执行程序目录/usr/bin ，/usr/sbin等
1.使用la -alt / 查找tmp目录
【一&gt;所有资源获取&lt;一】 1、200份很多已经买不到的绝版电子书 2、30G安全大厂内部的视频资料 3、100份src文档 4、常见安全面试题 5、ctf大赛经典题目解析 6、全套工具包 7、应急响应笔记
2.使用ls —help 查看帮助信息
3.ls的常用用法： ls 用来显示目录列表
-a 显示所有档案及目录
-l 以长格式显示目录下的内容列表
-t 用文件和目录的更改时间排序
4.进入tmp目录，查找最近新添加的可疑文件。
02文件分分析-敏感文件信息 查看开机启动项内容/etc/init.d/，恶意代码很有可能设置在开机启动的位置。
查看指定目录下文件时间顺序的排序：ls -alt | head -n 10
查看文件时间属性: stat 文件名
使用ls -alh /etc/init.d // 查看开机启动项
进入开机启动项目录，对其进行筛选。
针对可以文件可以使用**stat **进行创建修改时间、访问时间的详细查看，若修改时间距离时间日期接近，有线性关联，说明可以被篡改。
如：stat apache2 查看文件详细信息。
03文件分析-敏感文件信息 主要针对新增文件分析：
查找24h内被修改的文件
find ./ -mtime 0 -name “*.php”
查找72h内新增的文件
find ./ -ctime -2 -name “‘*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dab064d5daf69f9d2f802aec6cfc93df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/667a5a252ed5f3d0ce92272ea31742b3/" rel="bookmark">
			图解人工智能知识架构(从系统角度告诉你人工智能到底学些啥)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人都想学习人工智能，但是却不知道该学些啥？从宏观的视角搞清楚人工智能到底需要学习哪些领域的知识是至关重要的。这就好比要去逛一座大的商场，非常需要一份商场的楼层导览图，它能够告诉你各个楼层商户的分布；又好比去一个风景区游玩，非常需要一份景区地图，它能够为你清晰地呈现所有景点的位置。如果能够通过图形可视化的方式呈现出人工智能的知识架构，那么对于想要快速入门人工智能的人来说就能够直观地了人工智能到底应该学些啥。
通过图形可视化的方式对人工智能的知识架构加以呈现可以采用两种方式，即分别从系统和知识的角度加以呈现。本文主要从系统角度呈现人工智能的知识架构。关于从知识角度呈现人工智能的知识架构的内容将在下一篇文章《图解人工智能知识架构(从知识角度告诉你人工智能到底学些啥)》中加以介绍，欢迎阅读。
从系统的角度看，人工智能的知识架构可以分拆为：AI理论、AI算法、AI软件、AI硬件等，具体参见图 2-1。
图 2-1 从系统角度看人工智能的知识架构
1.人工智能理论
AI理论涉及的内容如图 2-2所示，主要包括数学、神经科学、心理学、物理、专业理论、伦理学等[1]。AI中的数学理论主要包括分析学、概率论与统计学、线性代数与矩阵论、运筹学与最优化等，当然一些更高阶的内容，例如向量微积分、测度论等也是必须的。神经科学对AI研究有特别重要的理论意义，例如神经科学中与大脑相关的部分是AI领域中神经网络、深度学习的重要理论基础；此外，计算机视觉作为AI的一个重要领域，其创始人 David Marr就是剑桥大学神经生物学毕业的博士。心理学中与决策相关的部分对于AI的研究有重要指导意义，如何决策也是AI的研究内容之一。物理学对AI的发展也具有显著意义，例如光学成像就是AI中计算机视觉领域的一个重要的研究内容，又比如物理学中熵的概念[2][3]被引入AI中，从而发明了最大熵模型。专业理论则是指AI的具体应用领域的相关理论，例如将AI应用于金融分析中，则必须学习金融学有关的理论。伦理学主要解决人工智能技术的安全性及合法性等方面的问题，例如隐私保护等。
图 2-2 AI理论所涉及的内容
2.人工智能算法
AI算法的研究内容其本质是研究如何将数学模型转换为计算机能够执行的步骤。在AI的研究过程中，首先需要对具体的应用问题进行数学建模，但这些数学模型往往是高度抽象的。要将抽象的数学模型转变为生产力去解决物理世界中的实际问题，就必须借助计算机或者机器，让它们去执行相关的指令。这就必须通过程序去实现。在将数学模型转换为具体代码的过程中必须要有一个连接两者的桥梁，这个桥梁就是算法，见图 2-3。因此，算法研究人员通常是利用数学理论对具体问题进行建模，然后将模型转换为算法。相比于数学模型，算法能够更容易被程序员理解，进而写成代码。程序员可能看不懂数学公式，但是却能够很容易理解算法。
图 2-3 数学理论、算法和代码之间的关系
3.人工智能软件
AI软件的研究内容是为AI系统建立一套程序运行的框架或者架构，它是AI算法的载体，是包含一系列算法的集合。比如无人机软件就是无人机运行的一个软件架构，它里面包含了与无人机操作相关的一系列算法。AI软件的研究非常重要，它需要考虑代码的可扩展性、稳定性、高效性等一系列至关重要的问题。因此，AI软件的研究是AI研究内容的一个重点。虽然市面上有一些开源的AI软件可以解燃眉之急，但为长远计，还是要高度重视AI软件的研究和开发，避免被AI软件卡脖子的问题出现。
4.人工智能硬件
AI硬件的研究内容主要包括构建高性能AI服务器及AI系统决策指令的执行机构等，比如分布式数据存储器、GPU、机器人、无人驾驶汽车等，如图 2-4所示。AI软件和硬件的关系，好比人的大脑和四肢的关系。光有大脑，而没有四肢，就无法发挥人的作用。同样地，光有AI软件而没有AI硬件，就无法发挥AI的巨大威力。因此，对AI硬件的研究也必须高度重视。
图 2-4 常见的AI硬件设备
对于AI学习者而言，理论上可以按照AI理论、AI算法、AI软件、AI硬件这样的路线来学习，不过按照这样的思路来写的教材非常少见，所以按照这样的模式来逐步学习不太现实。但对于构建实际的人工智能系统而言，往往需要用到此知识架构。因此，建议按照下一篇文章，即《图解人工智能知识架构(从知识角度告诉你人工智能到底学些啥)》，来指导自己进行人工智能的学习，等搭建好自己的人工智能知识体系后，再将自己的知识体系转换成此文中的知识架构，进而指导自己构建人工智能系统的实践。
参考文献 郑南宁. 人工智能本科专业知识体系与课程设置[M]. 北京: 清华大学出版社, 2019.
晋宏营. 最大熵原理导出理想气体分子的速度和速率分布[J].科学技术与工程, 2012,12(030):7989-7992.
李素建, 刘群, 杨志峰. 基于最大熵模型的组块分析[J]. 计算机学报, 2003, 26(12):1722-1727.
南京大学人工智能学院. 人工智能导论[M]. 北京: 机械工业出版社, 2019.
焦李成, 李阳阳, 侯彪, 石光明. 人工智能学院本硕博培养体系[M]. 北京: 中国铁道出版社, 2019.
关于人工智能快速入门的更多精彩内容，可以购买《人工智能怎么学》进一步阅读。
图书购买方式
京东：https://item.jd.com/13395339.html
当当：http://product.dangdang.com/29469230.html
天猫：https://detail.tmall.com/item_o.htm?id=687374654836
为了让图书惠及更多的读者，为更多想学习人工智能的人提供帮助，经过向出版社申请，对图书《人工智能怎么学》的部分内容进行连载。图书《人工智能怎么学》的全部内容包含了初级入门、中阶提高以及高级进阶三个级别的内容。连载的内容主要是初级入门级别，适合想对人工智能进行快速和高效入门的读者，对于已有一定的人工智能学习基础，希望进一步进阶或提高的读者，则需要购买图书《人工智能怎么学》，学习中阶提高以及高级进阶的内容。此外，对于学习人工智能感兴趣的读者，也可以加入知识星球《人工智能怎么学》，知识星球是一个构建学习社群的平台，通过加入《人工智能怎么学》的社群，你将获得更多的学习资料和课程信息。
与作者互动和了解更多信息
想跟作者一起学习人工智能和互动，你可以加入如下社群：
知识星球：https://t.zsxq.com/0aLkVg0os
QQ群：600587177
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/667a5a252ed5f3d0ce92272ea31742b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96f157fce2c46038eba810d3a0df59d1/" rel="bookmark">
			react CodeMirror react-codemirror2 改变高度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CodeMirror有个默认的高度300px，尝试在less文件修改，没有修改成功
/deep/ .CodeMirror { height: auto; } 然后用下面这种方法修改成功：
const codemirrorDom = document.getElementsByClassName('CodeMirror')[0] codemirrorDom.setAttribute("style","height: auto") 真实不容易
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86a07d0e86ad808b4a8d646ebd908163/" rel="bookmark">
			使用Python绘制各种方法的词云图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import jieba from PIL import Image from wordcloud import WordCloud import numpy as np import matplotlib.pyplot as plt # 我们导入文本内容，并且去除掉一下换行符和空格，代码如下 text = open(r"《冰与火之歌》第1卷权力的游戏.txt",encoding='gbk').read() text = text.replace('\n',"").replace("\u3000","") # 我们需要将其分成一个个的词，这个时候就需要用到jieba模块了，代码如下 text_cut = jieba.lcut(text) # 将分好的词用某个符号分割开连成字符串 text_cut = ' '.join(text_cut) # 结果当中或许存在着不少我们不需要看的、无关紧要的内容，这个时候就需要用到停用词 stop_words = open(r"baidu_stopwords.txt",encoding='utf-8').read().split("\n") # # 绘制词云图的核心代码 word_cloud = WordCloud(font_path="simsun.ttc", # 设置词云字体 background_color="white",# 词云图的背景颜色 stopwords=stop_words) # 去掉的停词 word_cloud.generate(text_cut) image = word_cloud.to_image() image.show() word_cloud.to_file("1.png") 这样一张极其简单的词云图算是做好了，当然我们可以给它添加一个背景图片，例如下面这张图片，
主要需要添加的代码如下所示
background = Image.open(r"5.png") graph = np.array(background) word_cloud = WordCloud(font_path="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86a07d0e86ad808b4a8d646ebd908163/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13f747a0ea88954da0547f066e908f48/" rel="bookmark">
			真的了解HashMap、HashSet吗？做一道测试题试试！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人博客《HashMap、HashSet底层原理分析》，可以了解hashmap的底层源码实现
测试代码 HashSet底层实际就是一个Hashmap。猜猜下面源码每一个打印结果。
注：user对象重写的hashcode方法，保证name和age一样的情况下hashcode是一样的，
import java.util.*; public class HashmapTest { public static void main(String[] args) { HashMap map = new HashMap(); User u1 = new User("AA"); User u2 = new User("BB"); map.put(u1,1); map.put(u2,2); System.out.println("结果一(put u1 u2 后)="+map); // u1 重新Set name u1.setName("CC"); System.out.println("结果二(u1 set name 后)="+map); // 移除 u1 map.remove(u1); System.out.println("结果三(remove u1 后)="+map); // put user(CC) map.put(new User("CC"),3); System.out.println("结果四(put user(CC) 后)="+map); // put user(AA) map.put(new User("AA"),4); System.out.println("结果五(put user(AA) 后)="+map); } } class User{ private String name; private int age; public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13f747a0ea88954da0547f066e908f48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5b6d3ca32ed32426b25b90f9ecf9e94/" rel="bookmark">
			己用Okhttp工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、请求工具类
import android.os.Handler; import android.os.Looper; import java.io.IOException; import java.util.HashMap; import java.util.Map; import java.util.concurrent.TimeUnit; import okhttp3.Call; import okhttp3.Callback; import okhttp3.FormBody; import okhttp3.MediaType; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.RequestBody; import okhttp3.Response; import okhttp3.logging.HttpLoggingInterceptor; /** * 网络请求工厂类 */ public class OkHttpFactory { private static OkHttpFactory mInstance; private OkHttpClient mOkHttpClient; private Handler mDelivery; private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8"); public OkHttpFactory(OkHttpClient okHttpClient) { if (okHttpClient == null) { mOkHttpClient = new OkHttpClient(); } else { mOkHttpClient = okHttpClient; } if (mDelivery == null) mDelivery = new Handler(Looper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5b6d3ca32ed32426b25b90f9ecf9e94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb642411c042de38ffecceeffe898e3/" rel="bookmark">
			Unity异步跳转场景丨过度空场景丨进度条过度场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity异步跳转 前言制作结构介绍过度场景制作进度条版本观赏版本 使用方法结果 前言 提示：大体介绍今日功能介绍
本文为了场景太大跳转卡顿所增加一个过度场景
制作 结构介绍 本文共有三个场景原本的场景和跳转后的场景增加一个过度时的场景，场景分为有进度条和无进度条版本。 过度场景制作 代码直接制作首先我们定义一个固定的场景名字使用的类备用，稍后直接使用 public class AppDefine { public static string nextSceneName; } 异步的部分 进度条版本 本文选择可以直接选择添加一个可视化的进度条版本本场景名为AsyncLoadScene public Slider loadingSlider; //加载场景进度条，B场景中使用UGUI实现 public Text loadingText; //显示加载进度 % private float loadingSpeed = 1; //加载速度，这里是进度条的读取速度 private float targetValue; //进度条目标的值/异步加载进度的值 private float operation = 3.0f; private AsyncOperation asyncLoad; //定义异步加载的引用 // Use this for initialization void Start() { //loadingSlider.value = 0.0f; //初始化进度条 if (SceneManager.GetActiveScene().name == "AsyncLoadScene") //如果当前活动场景是B { //启动协程 StartCoroutine(AsyncLoading()); //开启协程进行异步加载 } } IEnumerator AsyncLoading() { asyncLoad = SceneManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfb642411c042de38ffecceeffe898e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93b5b9e5423e5ae5e401c2f22c83d2f9/" rel="bookmark">
			Java分割字符串的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法：
可能一下子就会想到使用split0方法，用split0方法实现是最方便的，但是它的效率比较低
第二种方法：
使用效率较高的StringTokenizer类分割字符串，StringTokenizer类是JDK中提供的专门用来处理字符串分割子串的工具类。它
的构造函数如下：
public StringTokenizer(String str, String delim)
str是要分割处理的字符串，delim是分割符号，当
-个StringTokenizer对象生成后，通过它的nexiToken0方法便可以得到下•
个分割的字符串，再通过hasMoreTokens0方法可以知道是否有更多的子字符串需要处理。这种方法的效率比第一种高。
第三种方法：
使用String的两个方法—indexOf0和subString0，subString(;是采用了时间换取空间技术，因此它的执行效率相对会很快，只要处理好内存溢出问题，但可大胆使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1434acea759fb055df8717fcf0a99041/" rel="bookmark">
			SSH 服务支持弱加密算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漏洞扫描有SSH 服务支持弱加密算法，解决方案有两个：
方案一：修改 SSH 配置文件，添加加密算法：
vi /etc/ssh/sshd_config
最后添加一下内容（去掉 arcfour、arcfour128、arcfour256 等弱加密算法）
Ciphers aes128-ctr,aes192-ctr,aes256-ctr,aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,aes192-cbc,aes256-cbc
保存文件后重启 SSH 服务：service sshd restart
方案二：升级 openssh 版本为最新版本
官网有说明，OpenSSH 7.0 以后的版本默认禁用了一些较低版本的密钥算法。
SSH Weak MAC Algorithms Enabled 漏洞修复使用同样的方式，添加以下行：
MACs hmac-sha1,umac-64,hmac-sha2-256,hmac-sha2-512,hmac-ripemd160
参考链接：
https://linux.uits.uconn.edu/2014/06/25/ssh-weak-ciphers-and-mac-algorithms/#
这里使用方案一进行：
操作步骤：
vim /etc/ssh/sshd_config 但是重启ssh报错：
-- Unit sshd.service has begun starting up. Feb 20 15:57:24 VM-24-9-centos sshd[27215]: /etc/ssh/sshd_config line 144: Bad SSH2 cipher spec 'aes128-ctr,aes192-ctr,aes256-ctr,aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,aes192-cbc,aes25-cbc'. Feb 20 15:57:24 VM-24-9-centos systemd[1]: sshd.service: main process exited, code=exited, status=255/n/a Feb 20 15:57:24 VM-24-9-centos systemd[1]: Failed to start OpenSSH server daemon.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1434acea759fb055df8717fcf0a99041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3ed204cc9214250a8b03e73d5bdd41c/" rel="bookmark">
			Junit &#43; Mockito 测试回调(callback) 方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语言：Java
JDK： Java8 及以上。
前言 Java8推出函数式接口后，就经常使用此特性开发。
在使用Junit + Mockito 时遇到有回调（callback）的函数方法时，遇到几种情况，这里进行记录。
Mockito打桩理解 对于Mockito中打桩个人理解：测试的方法在正常环境需要引入其他类中的方法来支撑（实），但是在mock时，所依赖的其他类都是mock的，这个时候就需要用到Mockito中的打桩来支撑（虚）。
对应代码说明就是：
//打桩，跳过调用，虚构调用返回 doReturn(mockObject).when(ServiceNameA).getXXXXX(anyString()); doReturn(Arrays.asList(new A())).when(ServiceNameB).getXXX(anyInt(),anyString()); doNothing().when(ServiceNameC).updateXXXX(anyList()); //调用 aService.methodName(param); 通用函数回调 //第一种写法： //对方法返回进行拦截处理 Answer answer = new Answer() { @Override public Object answer(InvocationOnMock invocation) throws Throwable { Object[] param = invocation.getArguments(); //callback方法的参数列表 Object param1 = param[0]; //第一个入参 Consumer&lt;Object&gt; oConsumer = (Consumer&lt;Object&gt;) param[1]; //Lambda oConsumer.accept(returnObject); return oConsumer; } }; doAnswer(answer).when(serviceName).method(any()); //第二种：（第一种进阶版） doAnswer(new Answer() { public Object answer(InvocationOnMock invocation) { Object[] args = invocation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3ed204cc9214250a8b03e73d5bdd41c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7faaad12576ca05f20dfe13c5bdf49f/" rel="bookmark">
			Android学习（一）--用户登录注册界面（界面跳转&#43;背景音乐）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.功能要求
2.功能实现流程图
3.功能演示
4.界面与功能
4.1登录界面
4.1.1界面展示
4.1.2登录界面功能简介
4.1.3界面代码
4.1.4登录按钮点击事件
4.1.5退出按钮点击事件
4.1.6背景音乐点击事件
4.1.7记住密码
5.Java源码
1.功能要求 （1）三个界面布局，体现文本框、编辑框、单选按钮、复选框按钮、按钮、listview控件，其它控件可自选。
（2）实现从第一个界面分别能跳转到另两个界面，其它两个界面也可返回第一个界面，将一个界面的数据通过Activity的数据传递传送到另一个界面。
（3）获取某个界面的数据，将数据存储到外部文件，数据存储方式可自选。
（4）根据各自项目的需求在某个界面中通过自定义广播、Toast提示实现一条广播的发送。
（5）在第一个界面当点击按钮时利用服务、MediaPlayer实现播放、停止播放背景音乐的功能。
2.功能实现流程图 3.功能演示 功能演示
4.界面与功能 4.1登录界面 4.1.1界面展示 4.1.2登录界面功能简介 在登录界面可以实现5个功能：
（1）登录界面的跳转（2）注册界面的跳转（3）退出功能
（4）记住密码功能（5）背景音乐播放和停止功能
界面跳转功能我使用的是intent实现activity与activity之间的跳转，可以直接按返回键返回到前一页，不需要自己添加按键监听代码实现，但需要在manifest注册activity。
4.1.3界面代码 activity_main.xml:
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/relativeLayout" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@drawable/bj1" tools:context=".MainActivity"&gt; &lt;EditText android:id="@+id/name" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginStart="75dp" android:layout_marginEnd="32dp" android:hint="请输入用户名" app:layout_constraintBottom_toTopOf="@+id/pwd" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintHorizontal_bias="0.0" app:layout_constraintStart_toStartOf="parent" android:maxLines="1" app:layout_constraintTop_toTopOf="parent" app:layout_constraintVertical_bias="0.972" /&gt; &lt;EditText android:id="@+id/pwd" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginStart="75dp" android:layout_marginEnd="32dp" android:hint="请输入密码" android:inputType="textPassword" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7faaad12576ca05f20dfe13c5bdf49f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8910e454f2e5a028785ab4bfd2c83a4b/" rel="bookmark">
			【投屏】Scrcpy源码分析四（最终章 - Server篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scrcpy源码分析系列
【投屏】Scrcpy源码分析一（编译篇）
【投屏】Scrcpy源码分析二（Client篇-连接阶段）
【投屏】Scrcpy源码分析三（Client篇-投屏阶段）
【投屏】Scrcpy源码分析四（最终章 - Server篇）
在前两篇我们探究了Scrcpy Client的连接和投屏逻辑，本篇我们就要继续探究Server端的逻辑了。
1. 入口函数 我们先来回忆下，还记得Server端是怎么运行起来的么？
答：由Client端执行adb push把Server程序上传到设备侧，然后执行app_process将Server端程序运行起来的。完整的命令是adb -s serial shell CLASSPATH=/data/local/tmp/scrcpy-server.jar app_process / com.genymobile.scrcpy.Server 1.25 [PARAMS] 。
app_process的好处一个是方便我们在安卓侧运行一个纯java程序（是dalvik的字节码，不是jvm字节码），二个是提权，使程序拥有root权限或者shell同等权限。
因为Client指定的类是com.genymobile.scrcpy.Server，所以Server的入口方法就是Server.java类的main()方法，其关键代码是：
// Server.java public static void main(String... args) { // 解析参数 Options options = createOptions(args); // scrcpy方法 scrcpy(options); } private static void scrcpy(Options options) { // 调用DesktopConnection的open函数 DesktopConnection connection = DesktopConnection.open(tunnelForward, control, sendDummyByte); // 控制逻辑 Controller controller = new Controller(device, connection,); startController(controller); // 投屏逻辑 ScreenEncoder screenEncoder = new ScreenEncoder(); screenEncoder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8910e454f2e5a028785ab4bfd2c83a4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a471184304204d97de79882bc27a2ca/" rel="bookmark">
			详解可变形注意力模块（Deformable Attention Module）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Deformable Attention（可变形注意力）首先在2020年10月初商汤研究院的《Deformable DETR: Deformable Transformers for End-to-End Object Detection》论文中提出，在2022CVPR中《Vision Transformer with Deformable Attention》提出应用了Deformable Attention（可变形自注意力）机制的通用视觉Transformer骨干网络DAT（Deformable Attention Transformer），并且在多个数据集上效果优于swin transformer。
在BEV感知算法中，比如DETR3d，BEVFormer等，均采用的是前者中提出的Deformable Attention。具体的维度及细节分析参考博客《Deformable DETR 原理分析》及微信公众号文《搞懂 Vision Transformer 原理和代码，看这篇技术综述就够了（二）》。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67206a5b7d88b5c78ff395b961c4b929/" rel="bookmark">
			[yocto]bitbake使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bitbake安装 git clone git://git.openembedded.org/bitbake ./bitbake安装完成 tree -L 1 . ├── AUTHORS ├── bin ├── ChangeLog ├── classes ├── conf ├── contrib ├── doc ├── lib ├── LICENSE ├── LICENSE.GPL-2.0-only ├── LICENSE.MIT ├── MANIFEST.in ├── README ├── toaster-requirements.txt └── TODO 设置环境变量 export PATH=/home/xxx/Poky/test/bitbake/bin:$PATH 简单测试 bitbake --version BitBake Build Tool Core version 2.2.0 bitbake执行环境 conf/bblayer.conf 在开始执行时，bitbake首先在当前工作目录中寻找conf/bblayer.conf文件非必须，但是所有使用层的运行环境中都包括该文件BBLAYERS变量 指向所有层的路径 conf/layer.conf 每个层都有自己层配置文件，bblayer.conf中指定的路径下可以检索出层独有的层配置文件BBPATH bittbake使用该变量检索.class(classes文件夹)和.conf(conf文件夹)文件BBFILES 指定菜谱文件BBFILE_COLLECTIONS 通过+=追加当前层的名字BBFILE_PATTERN_xxx 指定xxx层菜谱文件路径BBFILE_PRIORITY_xxx 指定xxx层的优先级 数值越大优先级越高如果多个层中出现同名菜谱，bitbake选择高优先级的菜谱进行编译优先级也决定了追加菜谱文件的顺序 任务 task bitbake可以在配方文件中定义shell或者python函数作为可执行元数据，而具体实现依靠task完成
bitbake把特殊函数当作任务，任务被定义在菜谱和类文件中针对特殊菜谱直接从bitbake命令行调用定义格式为： do_xxxxxdo_configure () { # Specify any needed configure commands here } addtask configure do_compile () { # You will almost certainly need to add additional arguments here oe_runmake -f makefile } addtask compile before do_install after do_configure do_install () { oe_runmake -f makefile install } addtask install after compile python do_clean(){ ##可以添加匿名python函数task #python function } add clean 执行task： bitbake task.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67206a5b7d88b5c78ff395b961c4b929/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c883d1c07c35c52b5e9c6e8f0de6a78/" rel="bookmark">
			贝叶斯变分推断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Variational Bayesian Inference Abstract 贝叶推断是统计学中的一个重要问题，也是许多机器学习方法中经常遇到的问题。贝叶斯推断已经被应用于各行各业。传统的贝叶斯技术需要通过积分来计算后验分布，而伴随着计算机的发展这一问题得到解决。在面对高维的参数空间时，基于蒙特卡洛抽样的方法难以直接评估或样本。而贝叶斯变分推断技术将后验推断问题巧妙地转化为优化问题进行求解，具有更好的收敛性和可扩展性。本文将对贝叶斯变分推断技术做出介绍。
1. Introduction 贝叶斯推断（Bayesian inference）是推论统计的一种方法，是统计学（特别是数理统计学）中很重要的技巧之一。它使用贝叶斯定理，在有更多证据及信息时，更新特定假设的概率。近些年来，贝叶斯推断在许多的领域中扮演者日益重要的角色，包括科学、工程学、哲学、医学、体育运动、法律等。
贝叶斯推断的关键是要确定统计模型的后验分布，此后模型将被用来对未知样本做出预测。然而由于积分的求解并容易（特别是在较为复杂的参数空间），在很多情形下，我们无法直接获得后验分布的理论解。这一点制约着基于贝叶斯的统计推断方法普遍的应用于各种问题。
近年来，随着计算机技术的发展，后验分布的近似计算问题取得了突破。其中基于马尔可夫的方法通过采样的方法使用随机化方法完成近似。然而，随着后验分布的复杂化，基于蒙特卡洛抽样的方法，特别是，马尔可夫链蒙特卡罗方法，如吉布斯抽样采取完全贝叶斯方法的统计推断复杂分布，难以直接评估或样本。而变分贝叶斯推断则是一个好的替代方法。变分贝叶斯提供了一个局部最优的精确后验的解析解。下面我们主要介绍贝叶斯变分推断的基本思想。
2. Method 变分推断方法的基本思想是通过使用已知简单分布来逼近需推断的复杂分布，并通过限制近似分布的类型，从而得到一种局部最优、但具有确定解的近似后验分布。在这一部分，我们将从问题的角度出发，介绍贝叶斯变分推断的具体流程。
2.1 Problem Formulation 给定一组数据 X = { x 1 , x 2 , , . . . , x n } \textbf{X} = \{x_1, x_2, , ..., x_n\} X={x1​,x2​,,...,xn​}，我们需要计算隐含变量 Z = { z 1 , z 2 , . . . , z m } \textbf{Z}=\{z_1, z_2, ..., z_m\} Z={z1​,z2​,...,zm​} 的后验分布 P ( Z ∣ X ) P(\textbf{Z} | \textbf{X}) P(Z∣X)，其中隐含变量 Z \textbf{Z} Z 可以是给定模型的未知参数，是不能观察到的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c883d1c07c35c52b5e9c6e8f0de6a78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8773ab7ba73525d27a63059408fe87e2/" rel="bookmark">
			使用IDEA完成登录与注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，完成数据库编写 DROP DATABASE if EXISTS mydb; CREATE DATABASE mydb; use mydb; CREATE TABLE ta_user ( uid int primary key auto_increment, username varchar(32), password varchar(32), phone varchar(32), address varchar(32) ); INSERT INTO ta_user(username,password,phone,address)VALUES('张三','123','12323231','北京'); INSERT INTO ta_user(username,password,phone,address)VALUES('李四','456','35343434','上海'); INSERT INTO ta_user(username,password,phone,address)VALUES('王五','789','33234324','河南'); SELECT * from ta_user; 二，网页前端显示部分（HTML部分） 注：注意文件创建地方
分层思想：创建一些包将一大堆代码分散到各个包中，可以使代码简洁，容易后期维护
主页面 &lt;%-- Created by IntelliJ IDEA. User: ThinkPad Date: 2023/2/18 Time: 8:35 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8773ab7ba73525d27a63059408fe87e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69e66844db1bf53dbe63f0176772e1a4/" rel="bookmark">
			tooltip不生效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在写一些表格页面，还有一些提示，我就用了 标签，大概我项目的代码如下
&lt;el-tooltip :disabled="disabled" content="点击开始绘制，鼠标移动到地图上显示为“+”号，点击地图上某一点则留下一个黑色线条空心小圆点，鼠标继续移动时其轨迹会显示出一条蓝色路线,直到鼠标点击形成第2个节点,至此,鼠标两次单击形成2个节点以及一条线。鼠标继续移动则其轨迹会继续显示蓝色线条,直到点击形成下一个节点。在地图上双击完成绘制,形成区域以后可以保存地图,绘制区域至少需要3个节点。" placement="bottom-start" effect="light"&gt; &lt;el-button @click="disabled = !disabled" size="mini"&gt;绘制说明&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;style lang="scss"&gt; .el-tooltip__popper { max-width: 20%!important; //宽度可根据自己需要进行设置 } &lt;/style&gt; 这里特别需要注意一下哦～～ el-tooltip 的样式加上了scope是不生效的，但是页面中不加的scope可能会出现样式污染的情况～那么这样的话咱们就可以用两个style标签啦～
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfb2e1f19cc3394cecd0a2b2a4876350/" rel="bookmark">
			详细介绍chrony服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		chrony服务器 硬件时间：BIOS里面；关机后依然运行，主板电池为它供电；RTC时钟
系统时间：开机后，软件启动读取硬件时钟，之后独立运行
Chrony 的配置文件是/etc/chrony.conf
chronyd服务器端
chronyc客户端
Chrony是一个开源自由的网络时间协议 NTP 的客户端和服务器软软件。它能让计算机保持系统时钟与时钟服务器（NTP）同步，因此让你的计算机保持精确的时间，Chrony也可以作为服务端软件为其他计算机提供时间同步服务。
Chrony由两个程序组成，分别是chronyd和chronyc
chronyd是一个后台运行的守护进程，用于调整内核中运行的系统时钟和时钟服务器同步。它确定计算机增减时间的比率，并对此进行补偿。（平滑的变化）
chronyc提供了一个用户界面，用于监控性能并进行多样化的配置。它可以在chronyd实例控制的计算机上工作，也可以在一台不同的远程计算机上工作。
NTP 是网络时间协议（Network Time Protocol）的简称，通过 udp 123 端口进行网络时钟同步。
RHEL7中默认使用chrony作为时间服务器，也支持NTP，需要额外安装。
NTP与chrony不能同时存在，只能用其中一个
一，一些相关的简单命令 1，使用命令Systecmctl restart chronyd 启动状态
2，使用命令Systemctl status chronyd查看chronyd的状态
3，使用命令Timedatectl 查看时间状态
4，使用命令rpm -qa | grep chrony查看是否安装chrony软件 5，如果没有的可以用Yum install chrony -y命令安装
6，使用命令cat /etc/services在linux查看服务对应的端口
二，chrony服务器配置 1，从阿里云同步时间（第一台机器） （1）使用命令vim /etc/chrony.conf打开配置文件
（2）注释掉pool ntp服务器池，添加一个阿里云的单个ntp服务器
Server ntp.aliyun.comiburst （此台服务器从阿里云来同步时间）
allow：默认情况下不允许任何ntp客户端访问
allow 192.168.0.0/16 （打开允许后面的服务器从此服务器来同步时间）
:wq保存并退出
（3）重启chronyd服务 systemctl restart chronyd
（4）使用timedatectl命令来查看状态是否为yes active
（5）Ping ntp.aliyun.com查看是否能够ping通，以及是否拿到ip
2，从第一台机器同步时间（第二台机器） （1） 克隆第一台机器（第二台机器）后改掉ip 和 主机名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfb2e1f19cc3394cecd0a2b2a4876350/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a46c8f4bbe94ac9f41a290b56fe55b1/" rel="bookmark">
			BGP 实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验需求
按照规划建立BGP对等体关系，R1和R5各发布一条路由，保证两个网段可以互相通信
二、配置思路
划分网段
配置IP
AS 2运行OSPF协议，使得R2,R3,R4之间可以互相通信
建立对等体
发布路由
测试通信
三、配置命令
【1】配置IP地址
[r1]interface g0/0/0
[r1-GigabitEthernet0/0/0]ip address 12.0.0.1 24
[r1]interface loopback 0
[r1-LoopBack0]ip address 1.1.1.1 24
[r2]interface g0/0/0
[r2-GigabitEthernet0/0/0]ip address 12.0.0.2 24
[r2]interface loopback 0
[r2-LoopBack0]ip address 2.2.2.2 24
[r2]interface g0/0/1
[r2-GigabitEthernet0/0/1]ip address 23.0.0.1 24
[r3]interface g0/0/1
[r3-GigabitEthernet0/0/1]ip address 34.0.0.1 24
[r3]interface loopback 0
[r3-LoopBack0]ip address 3.3.3.3 24
[r3]interface g0/0/0
[r3-GigabitEthernet0/0/0]ip address 23.0.0.2 24
[r4]interface g0/00/0
[r4-GigabitEthernet0/0/0]ip address 34.0.0.2 24
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a46c8f4bbe94ac9f41a290b56fe55b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ec65b4e2d41021a4802bd0f31e62066/" rel="bookmark">
			Pytorch 训练模型代码范例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pytorch 训练模型代码范例：
import torch import torch.nn.functional as F from torch.utils.data import Dataset, DataLoader from datautils import MyTrainDataset class Trainer: def __init__( self, model: torch.nn.Module, train_data: DataLoader, optimizer: torch.optim.Optimizer, gpu_id: int, save_every: int, ) -&gt; None: self.gpu_id = gpu_id self.model = model.to(gpu_id) self.train_data = train_data self.optimizer = optimizer self.save_every = save_every def _run_batch(self, source, targets): self.optimizer.zero_grad() output = self.model(source) loss = F.cross_entropy(output, targets) loss.backward() self.optimizer.step() def _run_epoch(self, epoch): b_sz = len(next(iter(self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ec65b4e2d41021a4802bd0f31e62066/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bf03715ecde80fffaa9d3a68b36a9de/" rel="bookmark">
			/bin/sh: 1: bison: not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 question: /bin/sh: 1: bison: not found method: sudo apt install bison flex 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05a532052c6317d635a3b7a495b23867/" rel="bookmark">
			python模块与包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python的程序结构 组成：包（package）、module（模块）、function（方法）
模块导入 导入方式 方式描述调用模块内函数使用模块内的类import 模块名1, 模块名2 或from 包名 import 模块名导入这个模块模块名.方法名(参数)模块名.类名from 模块名 import 方法名1, 方法名2，类名或from 包名.模块名 import 方法名，类名导入模块内指定的方法（不是以模块导入，是将函数或类导入）方法名(参数)类名(参数)from 模块名 import *或 from 包名.模块名 import *导入模块内所有函数和类方法名(参数)类名(参数) 注意： 同一个模块写多次，只被导入一次。import应该放在代码的顶端
maths.py的内容：
def add(num1, num2): return float(num1) + float(num2) def minus(num1, num2): return float(num1) - float(num2) class mats: def multiply(self, num1, num2): return float(num1) * float(num2) def division(self, num1, num2): return float(num1) / float(num2) 在maths.py同一目录下创建新的py文件，简单示例模块的导入方式
1、import 模块名的方式
import maths result = maths.add(34, 56) print(result) m = maths.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05a532052c6317d635a3b7a495b23867/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b2972cf25ccd5fb51b155062e389ae9/" rel="bookmark">
			我在公司里，为什么访问不了家里电脑的 IP 地址？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网站有位读者问了这个问题：
估计这位同学不知道路由器其实还有个 NAT 机制，帮我们把私有 ip 地址转换为公网 ip 地址，所以今天分享这方面的知识。
IPv4地址有限，最大42亿个。为了更好的利用这有限的IP数量，网络分为局域网和广域网，将IP分为了私有IP和公网IP，一个局域网里的N多台机器都可以共用一个公网IP，从而大大增加了"可用IP数量"。
收发数据就像收发快递
当我们需要发送网络包的时候，在IP层，需要填入源IP地址，和目的IP地址，也就是对应快递的发货地址和收货地址。
IP报头里含有发送和接收IP地址
但是我们家里的局域网内，基本上都用192.168.xx.xx这样的私有IP。
如果我们在发送网络包的时候，这么填。对方在回数据包的时候该怎么回？毕竟千家万户人用的都是192.168.0.1，网络怎么知道该发给谁？
所以肯定需要将这个192.168.xx私有IP转换成公有IP。
因此在上篇文章最后，留了这么个问题。局域网内用的是私有IP，公网用的都是公有IP。一个局域网里的私有IP想访问局域网外的公有IP，必然要做个IP转换，这是在哪里做的转换呢？
私有IP和公有IP在哪进行转换
答案是NAT设备，全称Network Address Translation，网络地址转换。基本上家用路由器都支持这功能。
我们来聊下它是怎么工作的。
NAT的工作原理 为了简单，我们假设你很富，你家里分到了一个公网IP地址 20.20.20.20，对应配到了你家自带NAT功能的家用路由器上，你家里需要上网的设备有很多，比如你的手机，电脑都需要上网，他们构成了一个局域网，用的都是私有IP，比如192.168.xx。其中你在电脑上执行ifconfig命令，发现家里的电脑IP是192.168.30.5。你要访问的公网IP地址是30.30.30.30。
于是就有下面这样一张图
内网IP访问公网IP
当你准备发送数据包的时候，你的电脑内核协议栈就会构造一个IP数据包。这个IP数据包报头里的发送端IP地址填的就是192.168.30.5，接收端IP地址就是30.30.30.30。将数据包发到NAT路由器中。
此时NAT路由器会将IP数据包里的源IP地址修改一下，私有IP地址192.168.30.5改写为公网IP地址20.20.20.20，这叫SNAT（Source Network Address Translation，源地址转换）。并且还会在NAT路由器内部留下一条 192.168.30.5 -&gt; 20.20.20.20的映射记录，这个信息会在后面用到。之后IP数据包经过公网里各个路由器的转发，发到了接收端30.30.30.30，到这里发送流程结束。
SNAT
如果接收端处理完数据了，需要发一个响应给你的电脑，那就需要将发送端IP地址填上自己的30.30.30.30，将接收端地址填为你的公网IP地址20.20.20.20，发往NAT路由器。NAT路由器收到公网来的消息之后，会检查下自己之前留下的映射信息，发现之前留下了这么一条 192.168.30.5 -&gt; 20.20.20.20记录，就会将这个数据包的目的IP地址修改一下，变成内网IP地址192.168.30.5, 这也叫DNAT（Destination Network Address Translation，目的地址转换）。之后将其转发给你的电脑上。
DNAT
整个过程下来，NAT悄悄的改了IP数据包的发送和接收端IP地址，但对真正的发送方和接收方来说，他们却对这件事情，一无所知。
这就是NAT的工作原理。
NAPT的原理 到这里，相信大家都有一个很大的疑问。
局域网里并不只有一台机器，局域网内 每台机器都在NAT下留下的映射信息都会是 192.168.xx.xx -&gt; 20.20.20.20，发送消息是没啥事，但接收消息的时候就不知道该回给谁了。
NAT的问题
这问题相当致命，因此实际上大部分时候不会使用普通的NAT。
那怎么办呢？
问题出在我们没办法区分内网里的多个网络连接。
于是乎。
我们可以加入其他信息去区分内网里的各个网络连接，很自然就能想到端口。
但IP数据包（网络层）本身是没有端口信息的。常见的传输层协议TCP和UDP数据报文里才有端口的信息。
TCP报头有端口号
UDP报头也有端口号
于是流程就变成了下面这样子。
当你准备发送数据包的时候，你的电脑内核协议栈就会先构造一个TCP或者UDP数据报头，里面写入端口号，比如发送端口是5000，接收端口是3000，然后在这个基础上，加入IP数据报头，填入发送端和接收端的IP地址。
那数据包长这样。
数据包的构成
假设，发送端IP地址填的就是192.168.30.5，接收端IP地址就是30.30.30.30。
将数据包发到NAT路由器中。
此时NAT路由器会将IP数据包里的源IP地址和端口号修改一下，从192.168.30.5:5000改写成20.20.20.20:6000。并且还会在NAT路由器内部留下一条 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b2972cf25ccd5fb51b155062e389ae9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfa130d17f34e2045780e6fe0fb08f52/" rel="bookmark">
			[shell]shell中if语句的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bash中如何实现条件判断？
条件测试类型：
整数测试
字符测试
文件测试
一、条件测试的表达式：
[ expression ] 括号两端必须要有空格
[[ expression ]] 括号两端必须要有空格
test expression
组合测试条件：
-a: and-o: or!: 非 二、整数比较：
-eq 测试两个整数是否相等-ne 测试两个整数是否不等-gt 测试一个数是否大于另一个数-lt 测试一个数是否小于另一个数-ge 大于或等于-le 小于或等于 命令间的逻辑关系
逻辑与：&amp;&amp; 第一个条件为假 第二个条件不用在判断，最总结果已经有
第一个条件为真，第二个条件必须得判断
逻辑或：|| 三、字符串比较
== 等于 两边要有空格!= 不等&gt; 大于&lt; 小于 四、文件测试
-z string 测试指定字符是否为空，空着真，非空为假-n string 测试指定字符串是否为不空，空为假 非空为真-e FILE 测试文件是否存在-f file 测试文件是否为普通文件-d file 测试指定路径是否为目录-r file 测试文件对当前用户是否可读-w file 测试文件对当前用户是否可写-x file 测试文件对当前用户是都可执行-z 是否为空 为空则为真-a 是否不空 五、if语法
if 判断条件 0为真 其他都为假
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfa130d17f34e2045780e6fe0fb08f52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a44be332224b4f9481b576615abae57b/" rel="bookmark">
			Unity 实现贴花/投影效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【核心思路】 实现投影效果有以下几种思路：
一是对处理渲染到相机的最终画面，将想投影的贴图修改上去。
二是对被投影的物体的Shader加上关键字，开启关键字的时候用想投影的贴图。
三是在一个物体上渲染想投影的贴图，让这个物体最后绘制，且只绘制那些被遮挡的部分，
本文采用第三种实现方式。
【实现效果】 【Build-In Shader】 Shader "Unlit/DecalShader" { Properties{ [HDR] _Color ("Tint", Color) = (0, 0, 0, 1) _MainTex ("Texture", 2D) = "white" {} } SubShader{ Tags{ "RenderType"="Transparent" "Queue"="Transparent-400" "DisableBatching"="True"}//选择透明渲染，要在所有透明物体渲染完成之后再渲染 Blend SrcAlpha OneMinusSrcAlpha ZWrite off //关闭深度写入，投影不需要 Pass{ CGPROGRAM #include "UnityCG.cginc" //定义顶点和片元着色器函数 #pragma vertex vert #pragma fragment frag sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; //相加深度图，要用C#代码开启相机深度图Camera.main.depthTextureMode = DepthTextureMode.Depth sampler2D_float _CameraDepthTexture; struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 screenPos : TEXCOORD0; float3 ray : TEXCOORD1; }; v2f vert(appdata v){ v2f o; float3 worldPos = mul(unity_ObjectToWorld, v.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a44be332224b4f9481b576615abae57b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4018f9b316688eb824421f4bd1182d9/" rel="bookmark">
			SpringBoot毕业设计40个项目分享(源码&#43;论文)（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言 题目1 : 基于SSM的汽车租赁系统 &lt;br /&gt; 题目2 : 基于SSM的在线药品超市购物系统 &lt;br /&gt; 题目3 : 基于SSM的在线药品超市购物系统 &lt;br /&gt; 题目4 : 基于SSM的疫情防控物业管理系统 &lt;br /&gt; 题目5 : 基于SSM的在线音乐网站设计与实现 &lt;br /&gt; 前言 🔥 这两年开始毕业设计和毕业答辩的要求和难度不断提升，传统的java web缺少创新和亮点，往往达不到毕业答辩的要求，这两年不断有学弟学妹告诉学长自己做的java web管理系统达不到老师的要求。
为了大家能够顺利以及最少的精力通过毕设，学长分享5个优质java web毕业设计项目，需要的自取。
题目1 : 基于SSM的汽车租赁系统 🥇 题目综合评分(每项满分5分)
难度系数：3分工作量：5分创新点：3分界面美化：5分 🥇 相关技术和工具 :
开发语言：Java框架：ssmJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 🥇 功能模块
管理员：首页、个人中心、用户管理、汽车类型管理、车辆信息管理、租车信息管理、还车信息管理、评价信息管理、故障上报管理、系统管理用户前台：首页、车辆信息、新闻资讯、我的、跳转到后台、客服用户后台：首页、个人中心、租车信息管理、还车信息管理、评价信息管理、故障上报管理、我的收藏管理 🥇 项目详细描述地址:
https://www.zhihu.com/people/59-14-98-28/zvideos
题目2 : 基于SSM的在线药品超市购物系统 🥇 题目综合评分(每项满分5分)
难度系数：3分工作量：5分创新点：3分界面美化：5分 🥇 相关技术和工具 :
开发语言：Java框架：ssmJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 🥇 功能模块
管理员：首页、个人中心、用户管理、员工管理、药品类别管理、药品信息管理、药品入库管理、药品出库管理、在线咨询管理、留言板管理、系统管理、订单管理用户：首页、个人中心、在线咨询管理、我的收藏管理、订单管理员工：首页、个人中心、药品信息管理、药品入库管理、药品出库管理、在线咨询管理前台首页：首页、药品信息、医药指南、留言反馈、个人中心、后台管理、购物车 🥇 项目详细描述地址:
https://www.zhihu.com/people/59-14-98-28/zvideos
题目3 : 基于SSM的在线药品超市购物系统 🥇 题目综合评分(每项满分5分)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4018f9b316688eb824421f4bd1182d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b003bd8dcf68c16c3c11637d1527f2b8/" rel="bookmark">
			C&#43;&#43;编译时出现错误的未知类型名称‘constexpr‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 在Eclipse中编译C++程序时，报错"unknown type name 'constexpr'"。
原因 编译器的C++版本过老，修改C++版本为11以上即可。
解决方法 1）点击Project的Prooerties
2）点击C++ Build中的settings一栏
3）点击GCC的Dialect，修改Language standard即可
注：其他编译器同理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9486b1882134e0656c1ea073d57723f3/" rel="bookmark">
			Python：parser.add_argument()用法【命令行选项、参数、子命令解析器、sh脚本】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		parser 官方文档
一、argparse使用 argparse 模块是 Python 内置的一个用于命令项选项与参数解析的模块，argparse 模块可以让人轻松编写用户友好的命令行接口。通过在程序中定义好我们需要的参数，然后 argparse 将会从 sys.argv 解析出这些参数。argparse 模块还会自动生成帮助和使用手册，并在用户给程序传入无效参数时报出错误信息。
main.py文件
import argparse parser = argparse.ArgumentParser() parser.add_argument('--seed', type=int, default=72, help='Random seed.') parser.add_argument('--epochs', type=int, default=10000, help='Number of epochs to train.') parser.add_argument('--use_multi_gpu', default=False, action='store_true', help='use multiple gpus') args = parser.parse_args() print(args.seed) print(args.epochs) 打印内容如下：
/home/user/anaconda3/bin/python3.6 /home/user/lly/pyGAT-master/test.py False 72 10000 Process finished with exit code 0 action的作用：训练时加上–use_multi_gpu参数就表示其值为store_true表示的True
二、sh脚本 main.sh文件：
python main.py \ --seed=$1 \ --epochs=$1 其中：
$1：表示控制台输入的第一个参数；$2：表示控制台输入的第二个参数； 三、控制台输入 sh main.sh 20 500 参考资料：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9486b1882134e0656c1ea073d57723f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/802721e220b3737401ab88745845d980/" rel="bookmark">
			编写一个C语言程序，能够实现求斐波那契数列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 好的，这是一个实现求斐波那契数列的C语言程序：
#include &lt;stdio.h&gt; int main() { int n, i; long long int f[100]; // 定义一个 long long int 类型的数组来存储斐波那契数列 printf("请输入斐波那契数列的项数："); scanf("%d", &amp;amp;n); f[0] = 0; // 第一项为 0 f[1] = 1; // 第二项为 1 for (i = 2; i &lt; n; i++) { // 使用循环计算斐波那契数列的每一 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa8e346d62d0fd338329622e28724bcb/" rel="bookmark">
			二叉树的非递归后序遍历算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		答：非递归后序遍历二叉树的算法是：从根结点开始，先将根结点压入栈，然后遍历左子树，每访问一个结点，就将该结点也压入栈，直到空结点；然后从栈中弹出栈顶结点，访问它，再按相同的方法访问它的右子树。重复以上步骤，直到栈空。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feafe532c4bc245f01dfe9e4b74b8e1d/" rel="bookmark">
			写一段java主动发送请求的示例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		String url = "http://example.com/example.php";try { URL obj = new URL(url); HttpURLConnection con = (HttpURLConnection) obj.openConnection();
// optional default is GET con.setRequestMethod("GET");
//add request header con.setRequestProperty("User-Agent", USER_AGENT);
int respon
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7e72dbc533effd7886dfe2d3a1853dd/" rel="bookmark">
			写一个qgriphics程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我可以为你写一个qgraphics程序，它将实现以下功能：使用Qt库绘制图形，使用QPainter类进行图形绘制，使用QGraphicsView类创建图形视图，使用QGraphicsItem类添加和移动图形项目，使用QGraphicsScene类创建图形场景，使用QGraphicsEllipseItem类添加圆形图形项目，使用QGraphicsLineItem类添加线条图形项目，使用QGraphicsTextItem类添加文本图形项目，并使用QGraphicsRectItem类添加矩形图形项目。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efbbea0d28a4fd02c8a59a5d1117c89e/" rel="bookmark">
			pytorch怎么加载city数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyTorch可以使用torchvision库中的torchvision.datasets模块加载Cityscapes数据集，它有一些类似的数据集，如COCO，VOC等。使用torchvision.datasets.Cityscapes(root, split, mode, target_type,transform)即可加载Cityscapes数据集。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27b51dee0cf1286ceaf0a2a66e41be99/" rel="bookmark">
			很好玩的html小游戏代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 HTML(超文本标记语言)是用来描述网页的一种语言。它使用标签来标记文本、图像、链接等元素。要创建一个 HTML 小游戏，你需要使用 HTML、CSS 和 JavaScript 来构建游戏的界面和逻辑。
这里是一个简单的 HTML 小游戏的例子，这是一个猜数字的游戏：
&lt;html&gt; &lt;head&gt; &lt;title&gt;猜数字游戏&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;猜数字游戏&lt;/h1&gt; &lt;p&gt;我想出了一个 1 到 100 之间的数字，你需要猜出来。&lt;/p&gt; &lt;input type="text" id="guess"&gt; &lt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03b669e831b5c4aa4244ab744c2f23ba/" rel="bookmark">
			使用Java写出九九乘法表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以这样写：public class MultiplicationTable{ public static void main(String[] args){ for(int i=1;i&lt;=9;i++){ for(int j=1;j&lt;=i;j++){ System.out.print(i+""+j+"="+(ij)+"\t"); } System.out.println(); } } }
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/165/">«</a>
	<span class="pagination__item pagination__item--current">166/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/167/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>