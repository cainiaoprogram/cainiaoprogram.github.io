<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa7e1228229d45895c8638b50f33dd6d/" rel="bookmark">
			使用EA画ER图并导出为图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 我们在机房重构的时候、机房合作的时候都画过ER图，还记得当时自己是用什么工具画的吗？想必也和小编一样，开始是用word，然后各种工具的使用吧。最后还是觉得EA比较方便。这次的毕业设计，论文中也需要插入一个总体的ER图，所以，小编在这分享一下使用EA怎么画ER图。
步骤 1、我们需要新建一个文件,如下图,选择类型处选择&lt;所有&gt;，选择DesignModel 类型。
2、新增图表。
3、添加更多工具（画ER图使用的）
4、开始画实体和联系。
5、设置联系。
因为我们的联系有对一、一对多和多对多，所以我们要设置出来以便让别人能看明白两个实体之间的联系。
我们的ER图画完了。。。。。。
但是如果我们画了一个很大的系统的ER图，图很大，关系很复杂，如果我们要将图插入到文档中，直接截图的画，有的时候可能会截的不全,给看文档的人带来很大的不方便,而且也不美观。这个时候我们就要想个办法了。
下面小编来说一下，EA是如何将画好的图导出为图片的。
1、 首先,选择project-àDocumentation—&gt;Diagrams Only Report
2、 选择输出路径和要导出的格式等。
3、完成！
总结 第一次使用，我们可以不懂为什么，或者不用知道，只是当时能解决问题就OK了。但是如果我们又有第二次碰上了，那我们应该看看这个东西到底是什么真面目了。第三次的时候有必要想想这个东西的存在肯定有它的意义，那么它还有什么方便的地方呢？我们就需要去挖掘一下了。大家都说EA是个很强大的软件，那么EA的功能，你又知道多少呢？小编有时间会好好的研究EA，然后分享给大家的！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6cefae807ee8a3bd998421d4cb21e22/" rel="bookmark">
			live555 rtsp延时问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 live555 rtsp客户端在刚接入服务器（每次重新接入的时候的时候）延时好几秒钟，播放一会图像延时就正常了，有遇到跟我同样的问题的吗？ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e28cf88d84b2ab4b67b98f1dd49b7ff/" rel="bookmark">
			Ubuntu下安装Chrome浏览器的两个方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、通过直接下载安装Google Chrome浏览器deb包。
打开Ubuntu终端，以下为32位版本，使用下面的命令。
wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb
以下为64位版本，使用下面的命令。
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
下载好后
32 位安装命令:
sudo dpkg -i google-chrome-stable_current_i386.deb
64 位安装命令:
sudo dpkg -i google-chrome-stable_current_amd64.deb 二、添加 Google Chrome 的PPA
安装Google Chrome浏览器官方PPA，打开终端然后运行下面的命令，下载签名密钥：
wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add
sudo sh -c 'echo "deb http://dl.google.com/linux/chrome/deb/ stable main" &gt;&gt; /etc/apt/sources.list.d/google-chrome.list'
sudo apt-get update
sudo apt-get install google-chrome
安装Google Chrome unstable 版本：
sudo apt-get install google-chrome-beta
安装Google Chrome beta 版本：
sudo apt-get install google-chrome-unstable
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e28cf88d84b2ab4b67b98f1dd49b7ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d283606f01feab8b97e1d07224c9356/" rel="bookmark">
			Android开发学习之路--RxAndroid之初体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学了一段时间android，看了部分的项目代码，然后想想老是学基础也够枯燥乏味的，那么就来学习学习新东西吧，相信很多学java的都听说过RxJava，那么android下也有RxAndroid。
RxJava最核心的两个东西是Observables（被观察者，事件源）和Subscribers（订阅者）。Observables发出一系列事件，Subscribers处理这些事件。这里的事件可以是任何你感兴趣的东西，触摸事件，web接口调用返回的数据等等。
关于RxAndroid的github：https://github.com/ReactiveX/RxAndroid。
新建emRxAndroidStudy工程， 然后在build.grade的dependencies里添加：
compile 'io.reactivex:rxandroid:1.1.0' compile 'io.reactivex:rxjava:1.1.0' 接着我们来试下RxAndroid了， 首先这里我们还是使用上次的注解的方式，把4个和Annotation相关的文件拷贝到工程，编写MainActivity代码如下： package com.jared.emrxandroidstudy; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; import android.widget.TextView; import rx.Observable; import rx.Subscriber; @EMLayoutBinder(R.layout.activity_main) public class MainActivity extends BaseActivity { private static final String TAG = "MainActivity"; private Subscriber&lt;String&gt; subscriber; private Observable&lt;String&gt; observable; @EMViewBinder(R.id.hello) private TextView mHello; @EMViewBinder(R.id.test1) private Button mTest1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); createSubscriber(); } private void bindSubscriber() { observable.subscribe(subscriber); } private void createSubscriber() { subscriber = new Subscriber&lt;String&gt;() { @Override public void onCompleted() { Log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d283606f01feab8b97e1d07224c9356/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84d5857d8b50b72be3f96940899f82b4/" rel="bookmark">
			C&#43;&#43;类虚函数表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include &lt;cstdlib&gt; using namespace std; class Base1 { public: virtual void f() { cout &lt;&lt; "Base1 f()" &lt;&lt; endl; } virtual void g() { cout &lt;&lt; "Base1 g()" &lt;&lt; endl; } virtual void h() { cout &lt;&lt; "Base1 h()" &lt;&lt; endl; } }; class Base2 { public: virtual void f() { cout &lt;&lt; "Base2 f()" &lt;&lt; endl; } virtual void g() { cout &lt;&lt; "Base2 g()" &lt;&lt; endl; } virtual void h() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84d5857d8b50b72be3f96940899f82b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f57dad1f7b6df7d3afa850eb1153e7e0/" rel="bookmark">
			单片机的时钟分频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时钟分频名词解释 分频器一般都是跟计数单元一起结合使用。
预分频器（prescaled） 预分频比是在计数单元值发生变化之前起作用（假如不用预分频时，计数器在每个上升沿到来时加1，而现在使用分频比为1：2的预分频器的话，那么必须等到两个上升沿的到来，计数器才会加1） 后分频器 后分频器与预分频器功能一样，只不过是在计数器值发生改变后起作用。像TMR2的后分频器，如果不使用，计数器一但发生溢出，将立即置位标志为TMR2IF，但是如果有1：2的后分频器的话，必须两次溢出后才会置位。 定时器的“预分频”就是把CPU的时钟信号分频以后作为定时器的计时信号。不同的分频比例，当然定时器计时的快慢就不一样了。
PLL(Phase-Locked Loop) 输入信号－&gt; 鉴相器 －&gt; 低通滤波器 －&gt; 压控振荡器－&gt; 输出信号。鉴相器有两个输入，分别是输入信号和压控振荡器的输出信号，在二者相位差和频率差不是很大的情况下，鉴相器的输出与两输入信号之差成正比，鉴相器的输出为模拟信号，其通过低通滤波器虑除高频杂波，后进入压控振荡器，压控振荡器的输出频率随其输入电压的改变而改变。从原理图上看，PLL实际上是一负反馈系统，只要输入信号在正常范围内，输出信号在“一定时间内”都能跟上。输入信号发生变化后，输出信号跟踪输入信号的过程称之为捕获；输出信号跟踪完毕时称之为锁定；输入信号变化过快导致输出信号无法跟踪时称为失锁。通过PLL可以方便实现N倍频，原理如下： 输入信号－&gt; 鉴相器 －&gt; 低通滤波器 －&gt; 压控振荡器－&gt; 输出信号 ^|_N分频器_________| 此外，可以实现小数倍频，原理如下： 输入信号－&gt; 鉴相器 －&gt; 低通滤波器 －&gt; 压控振荡器－&gt; 输出信号 ^|___N分频器/N+1分频____| | | |—— 模式控制 ――———&gt; | 模式控制模块可以选择分频器处于N分频器还是N+1分频，若通过模式控制模块实现 10个clk中有9个clk为N分频，1个clk为N+1分频，则实际输出信号频率为（N+0.1）× 输入频率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6424472ec731160be088709ed91afdc/" rel="bookmark">
			安卓基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是activity: (1):界面显示:setContentView(layout布局文件),然后activity实现了OnClickListener，用户做操作我们就能收到用户操作的内容然后反馈给用户 (2)和用户进行交互:四大组件之一,作为一个界面的容器,一个可以与用户交互的界面,他能与用户交互是因为他是Context的子类,同时实现了window.callback(window.callback(窗口的回调事件)有一个dispatchTouchEvent事件,所以他能分发，既然window.callback他能分发事件,他就可以处理这些事件)和keyevent.callback(按键的回调事件,),可以处理与窗体交互的事件 servie也是Context的子类,但是他没有实现Window.callback(窗口回调事件)和keyevent.callback(按键的回调事件),所以他不能和用户交互 (3):开发举例说明:以前开发常用的有 FragmentActivity,ListActivity,PreferenceActivity,TabActivity等等,如果开发中遇到界面有共同的特点,布局大同小异,功能类似,我们就可以定义一个BaseActivity,这样代码优化比较好 为什么要使用fragment？ 当我们需要动态的多节目切换时,就需要将ui元素和activity融合成一个模块.在2.3中我们一般通过各种activity中进行跳转来实现多界面的跳转和单个界面动态改变.在4.0或以上的系统中可以使用新的特性来方便的达到这个效果-fragment类.Fragment类似一个嵌套activity,可以定义自己的layout和自己的生命周期. 当一个fragment被创建的时候,他会经历以下状态 onAttach,onCreate,onCreateView,onActivityCreate 当这个fragment对用户可见的时候,他会经历以下状态 onStart,onResume 当这个fragment进入后台模式的时候,他会经历以下状态 onPause,onStop 当这个fragment被销毁(或者持有他的activity被销毁),他会经历以下状态 onPause,onStop,onDestroyView,onDestroy,onDetach fragment的大部分状态和activity相似,但fragment都有一些新的状态 onAttached:当fragment被加入到activity的时候调用(这个方法可以获得所在的activity) onCreateView:当activity要得到fragment的layout时,调用此方法 onActivityCreate:当activity的oncreate方法返回后调用此方法 onDestroyView：当fragm中的视图移除的时候调用此方法 onDetach:当fragment和activity分离的时候,调用这个方法 2.activity的生命周期: activity的从出生(new)到死亡(垃圾回收)的过程,activity创建的时候是由frameWork new出来的,我们自己可以去newactivity,但是new了自己没法启动(就像servlet,我们自己虽然可以new,但是启动不了).activity被fragmentWork New出来之后,由他去管理activity的. activity给我们提供了一系列的方法,然后在相应的方法做出相应的操作,这些方法括:onCreate,onDestroy,onstart,onstop,onresume,onpause,onRestart 这些方法都是两两对应的 onCreate():创建 onDestroy():销毁 onStart():可见 onStop():不可见 onresume():可编辑(获取焦点) onPause():不可编辑(失去焦点) 这6个方法都是相对应的,只剩下一个onRestart方法了,该方法在activity被onStop后,但是并没有被fragmentwork回收掉,在再次启动activity时,不再调用onCreate,而是调用onRestart 例子:比如我做一个商品界面,用户在点击某一个商品的时候,商品界面被按走,然后用户点击返回,我就在这个onRestart里面做对商品页面的数据操作,从网络再拿商品,然后做刷新操作,保证用户做了操作,能保证用户看到最新的数据 activity还有一些其他不常用的比如:onPostResume和onPostCreate onPostResume:可见(onStart)完成以后框架也就是系统去回调 onPostResume方法,而不是我们去回调该方法 onPostCreate:创建完成之后框架(系统)回调此方法,自己实现了也不会去覆盖框架的该方法 3.2个activity之间的跳转必然会执行的方法: 一般情况分2种, B完全覆盖住了A：activirt分别为A和B，当在A里面激活B组件的时候,A会调用onPause(不可编辑,失去焦点)方法,然后B调用oncreate(出生)，onstart(可见)，onRresume(可编辑)方法,这个时候B覆盖了窗体,A会调用onStop（不可见）方法, B是透明的或者是个对话框:如果B是透明的,或者是对话框的样式,就不会调用onStop方法 4.横竖屏切换执行的生命周期方法 这个生命周期和清单文件的配置有关系 (1):不设置activity的android：configChanges时,切屏会重新调用各个生命周期方法,默认首先销毁当前的activity,然后重新加载,执行生命周期方法 (2):设置activity的android:configChanges="orientation|keyboardHidden|screenSize"时,切屏不会重新调用各个生命周期,只会执行onConfigurationChanged方法 5.如何将一个activity设置成窗口的样式 1.可以在清单文件中配置activity的样式,设置成 android:theme="@android:style/Theme.DiaLog" 2.可以自己创建一个dialog,如何写一个布局文件,把布局文件当成一个dialog 6.你后台的activity被系统回收怎么办?如果后台的activity由于某种原因被系统回收了,如何在被系统回收之前保存当前状态 当activity处于不在前台界面显示,处于onPause或者onStop这2个状态的时候,activity不在内存栈的顶端，也是有可能被android回收的, 反正就是除了在栈顶的activity,其他activity都有可能在内存不足的时候被系统回收,activity越是在栈底越有可能被回收 当她们被系统回收,会调用onSaveInstanceState方法,你可以吧那些数据存取到outState里面, @Override protected void onSaveInstanceState(Bundle outState) { //在activity被系统回收的时候,存取到outState路面 outState.putInt("1", 100); super.onSaveInstanceState(outState); } 在用户在下一次在即该activity的时候,就会调用onCreate方法 @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6424472ec731160be088709ed91afdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e64e62b8b85f342fc6674d13128884a/" rel="bookmark">
			解决Android 5.0以上版本Button自带阴影效果的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天跟UI对界面，发现一个按钮使用系统自带的button会自动有一个阴影。然而在4.x上却没有这个问题。直觉就是因为MD导致的Android版本差异。 果断Google，在stackoverflow上找到了解决方案。 http://stackoverflow.com/questions/28756035/how-to-remove-button-shadow-android 关键一条代码 style=”?android:attr/borderlessButtonStyle” 属性解释
&lt;Button android:id="@+id/button_send" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/button_send" android:onClick="sendMessage" style="?android:attr/borderlessButtonStyle" /&gt; 设置该属性就可以去掉自带的阴影。 该属性在API 11及以上可用。鉴于现在普遍都是API 14，所以可以放心使用。已在5.1和6.0上试过，没问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4e322d1cc376b16c6619089ccc6feeb/" rel="bookmark">
			【opencv】opencv各版本与VS配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		opencv1.0（支持vc6.0）与vc6.0配置 假设安装到E盘下 1、添加环境变量 path下 E:\opencv1.0\bin 2、打开vc6.0进行配置，选择tools-&gt;options-&gt;Directories，选择include files在下方填入路径 E:\opencv1.0\cxcore\include E:\ opencv1.0\cv\include E:\ opencv1.0\cvaux\include E:\ opencv1.0\ml\include E:\ opencv1.0\otherlibs\highgui E:\ opencv1.0\otherlibs\cvcam\include 选择library files 在下方填入路径 E:\opencv1.0\lib 选择source files 在下方填入路径 E:\ opencv1.0\cxcore\src E:\ opencv1.0\cv\src E:\ opencv1.0\cvaux\src E:\ opencv1.0\otherlibs\highgui E:\ opencv1.0\otherlibs\cvcam\src\windows 3、建立一个工程，手动添加lib 选择 project-&gt;settings-&gt;link 在object/library modules: cxcore.lib cv.lib ml.lib cvaux.lib highgui.lib cvcam.lib 完成配置 ————————————————————————————————————
opencv2.4.9（支持vc10 vc11 vc12）与vs2012配置 假设安装到E盘下 1、添加环境变量 path下 E:\opencv\build\x64\vc11\bin （64位系统选择x64位，32位系统选择x86，vc11为vs2012，vc10为vs2010，vc12为vc2013） 2、项目上右键-&gt;属性-&gt;vc++目录 可执行文件目录（path目录）添加： E:\opencv\build\x64\vc11\bin; 包含目录添加： E:\opencv\build\include\opencv2; E:\opencv\build\include\opencv; E:\opencv\build\include; 库目录添加： E:\opencv\build\x64\vc11\lib; 3、项目上右键-&gt;属性-&gt;链接器-&gt;输入 附加依赖项添加： opencv_calib3d249d.lib opencv_contrib249d.lib opencv_core249d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4e322d1cc376b16c6619089ccc6feeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/973c9d55497dbef5f13f96d467f74bab/" rel="bookmark">
			Spring框架中SecurityContextHolder类的使用详解（未完待续）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring框架借助ThreadLocal来保存和传递用户登录信息。我们通常是使用下面这段代码，来获取保存在ThreadLocal中的用户信息。
SecurityContextHolder.getContext().getAuthentication().getPrincipal();
如果我们想获取用户的ID，可以这样：
String userId = SecurityContextHolder.getContext().getAuthentication().getPrincipal().getUserId();
一，我们来看一下源代码
public class SecurityContextHolder extends Object，这个类直接继承自Object
官方文档说明如下：
Associates a given SecurityContext with the current execution thread.
这句话大概的意思是，SecurityContextHolder的主要功能是将当前正在执行的thread与SecurityContext关联起来。
进一步详细的说明是：
This class provides a series of static methods that delegate to an instance of SecurityContextHolderStrategy. The purpose of the class is to provide a convenient way to specify the strategy that should be used for a given JVM. This is a JVM-wide setting, since everything in this class is static to facilitate ease of use in calling code.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/973c9d55497dbef5f13f96d467f74bab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/282c8ad40bd4d2ccbaddb36d12a3f68c/" rel="bookmark">
			Oracle  Help Center
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 涵盖Oracle所有官方技术以及相关文档！
http://docs.oracle.com/en/
转载于:https://my.oschina.net/1272149624/blog/625682
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3992d4e05ba0010f6e294c9fd6aaab1/" rel="bookmark">
			matplotlib中画图显示中文，但保存为图片后中文乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matplotlib中画图显示中文，但保存为图片后中文乱码 这两天赶毕设论文的测试，使用matplotlib画图，首先解决图片预览的中文显示，很简单：
import numpy as np import matplotlib.pyplot as plt import matplotlib # 设置显示中文 matplotlib.rcParams['font.sans-serif'] = ['SemiHei'] #指定默认字体 matplotlib.rcParams['axes.unicode_minus'] = False #解决保存图像是负号'-'显示为方块的问题 N = 37 match_count = (392, 785, 1178, 1571, 1971, 2371, 2771, 3171, 3571, 3971, 4371, 4780, 5189, 5603, 6017, 6431, 6904, 7382, 7860, 8338, 8816, 9294, 9775, 10256, 10737, 11219, 11701, 12183, 12665, 13176, 13687, 14199, 14711, 15223, 15735, 16247, 16759) match_count_delta = [] start = 0 for x in match_count: match_count_delta.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3992d4e05ba0010f6e294c9fd6aaab1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80154985e0ca0e3aec49f313de488536/" rel="bookmark">
			TI DSP TMS320C66x学习笔记之内联指令（c6x.h中文注释）(六)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*****************************************************************************/ /* C6X.H v7.4.12 */ /*****************************************************************************/ #include "vect.h" typedef double __float2_t;//__float2_t双精度浮点型 #define _lltof2 _lltod #define _f2toll _dtoll //将一个__float2_t解释成一个long long #define _ftof2 _ftod #define _hif2 _hif #define _lof2 _lof #define _f2tol _dtol //将一个__float2_t解释成一个__int40 #define _ltof2 _ltod #define _amem8_f2 _amemd8 //加载和存储8bytes，指针必须8byte对齐，必须包含c6x.h #define _amem8_f2_const _amemd8_const //加载8bytes，指针必须8byte对齐，必须包含c6x.h #define _mem8_f2 _memd8 //从内存里加载一个64位值 #define _mem8_f2_const _memd8_const #define _fdmv_f2 _fdmv #define _hif2_128 _hid128 #define _lof2_128 _lod128 #define _f2to128 _dto128 #define _fdmvd_f2 _fdmvd /*从src2里提取csta和cstb指定的区域且符号扩展到32位。提取出的区域先符号左移再右移。*/ int _ext	(int src2, unsigned csta, unsigned cstb); int _extr	(int src2, int src1);//同上，区别左右移的位数由src1的低10位指定 unsigned _extu	(unsigned src2, unsigned csta, unsigned cstb);//同上上，区别最后是0扩展到32位 unsigned _extur (unsigned src2, int src1);//同上，区别左右移的位数由src1的低10位指定 /*通过cstb和csta指定需要置1的首位和尾位*/ unsigned _set	(unsigned src, unsigned csta, unsigned cstb); unsigned _setr	(unsigned src2, int src1);//将src2中指定位置1，置1的首位和末位有src1的低10位指定 /*通过cstb和csta指定需要清0的首位和尾位*/ unsigned _clr	(unsigned src, unsigned csta, unsigned cstb); unsigned _clrr	(unsigned src2, int src1);//将src2中指定位清0，清0的首位和末位有src1的低10位指定 /*将src1和src2相加，且饱和其结果*/ int _sadd	(int, int); __int40_t _lsadd (int, __int40_t); /*从src1中减去src2并饱和结果*/ int	_ssub	(int src1, int src2); __int40_t _lssub (int, __int40_t); /*将一个40bit的long转换成一个32bit的有符号int，如有需要，对结果进行饱和*/ int _sat	(__int40_t); /*将src2左移src1位，结果饱和在32位*/ int _sshl	(int src2, unsigned src1); /*把src1的高、低16位和src2的高、低16位分别相加，放入结果的高、低16位*/ int	_add2	(int, int); int	_sub2	(int, int);/*把src1的高、低16位减去src2的高、低16位，放入结果的高、低16位*/ /*有条件减和左移（常用于除法）*/ unsigned _subc	(unsigned, unsigned); /*搜索src2里面的1或0,1或0是由src1的LSB决定的，返回比特位变换的位数*/ unsigned _lmbd	(unsigned src1, unsigned src2); /*返回src的绝对值*/ int _abs	(int src); __int40_t _labs	(__int40_t src); /*返回src的冗余的符号比特位的个数，bit31是符号位，例如bit31往低位走，01b返回0,001b返回1,0001b返回2,00001b返回3*/ unsigned _norm	(int); unsigned _lnorm (__int40_t); //16 LSBs * 16 LSBs int	_mpy	(int src1, int src2);/*src1和src2相乘，操作数默认为有符号*/ int	_mpyus (unsigned src1, int src2);/*无符号src1和有符号src2相乘，S是用来确定哪个是有符号数（S）哪个是无符号数（U）*/ int	_mpysu (int, unsigned); unsigned _mpyu	(unsigned, unsigned); //16 MSBs * 16 MSBs int	_mpyh	(int, int); int	_mpyhus (unsigned, int); int	_mpyhsu (int, unsigned); unsigned _mpyhu (unsigned, unsigned); //16 MSBs * 16 LSBs int	_mpyhl (int, int); int	_mpyhuls (unsigned, int); int	_mpyhslu (int, unsigned); //16 LSBs * 16 MSBs int	_mpylh (int, int); int	_mpyluhs (unsigned, int); int	_mpylshu (int, unsigned); unsigned _mpylhu (unsigned, unsigned); //与上面的乘法指令区别在何处 /*把src1的低16位和src2的低16位相乘,之后左移一位*/ int	_smpy	(int src1, int src2); int	_smpyhl (int, int);//高16位 * 低16位 int	_smpylh (int, int);//低16位 * 高16位 int	_smpyh (int, int);//把src1的高16位和src2的高16位相乘 /*将src1和src2中的2对16位有符号数相乘，然后左移1位，再进行饱和*/ long long _smpy2ll (int, int); /*32位有符号数乘以32位有符号数，64位的结果左移1位然后饱和，然后将之后的结果的高32位写入dst*/ int _smpy32 (int, int); /*返回double寄存器的高32位（奇数位寄存器）作为int型*/ unsigned _hi(double); /*返回double寄存器的高32位（奇数位寄存器）作为float型*/ float _hif(double); /*返回long long寄存器的高32位（奇数位寄存器）作为int型*/ unsigned _hill(long long); /*返回double寄存器的低32位（偶数位寄存器）作为int型*/ unsigned _lo(double); /*返回double寄存器的低32位（偶数位寄存器）作为float型*/ float _lof(double); /*返回long long寄存器的低32位（偶数位寄存器）作为int型*/ unsigned _loll(long long); /*创建一个新的double寄存器来保存2个unsigned int的值，其中src2是高（奇数）寄存器，src1是低（偶数）寄存器*/ double _itod(unsigned, unsigned); /*创建一个新的double寄存器来保存2个float的值，其中src2是高（奇数）寄存器，src1是低（偶数）寄存器*/ double _ftod(float, float); /*创建一个新的long long寄存器来保存2个unsigned int的值，其中src2是高（奇数）寄存器，src1是低（偶数）寄存器*/ long long _itoll(unsigned src2, unsigned src1); /*注意不是变换，是直接将寄存器中的值解释成整型或者浮点型*/ float _itof(unsigned); /* 将一个int寄存器重新解释成一个float型 */ unsigned _ftoi(float); /* 将float的比特位解释成unsigned int */ __int40_t _dtol(double); /* 将一个double寄存器重新解释成一个_int40_t型*/ double _ltod(__int40_t); /* 将一个__int40_t寄存器重新解释成一个double型*/ long long _dtoll(double); /* 将一个double寄存器重新解释成一个long long型*/ double _lltod(long long); /* 将一个long long寄存器重新解释成double型 */ /* Define pseudo intrinsics for some pseudo instructions */ #ifndef _cmplt2 #define _cmplt2(src1, src2) _cmpgt2((src2), (src1)) #endif #ifndef _cmpltu4 #define _cmpltu4(src1, src2) _cmpgtu4((src2), (src1)) #endif #ifndef _dotpnrus2 #define _dotpnrus2(src1, src2) _dotpnrsu2((src2), (src1)) #endif #ifndef _dotpus4 #define _dotpus4(src1, src2) _dotpsu4((src2), (src1)) #endif #ifndef _mpyihll #define _mpyihll(src1, src2) _mpyhill((src2), (src1)) #endif #ifndef _mpyihr #define _mpyihr(src1, src2) _mpyhir((src2), (src1)) #endif #ifndef _mpyilll #define _mpyilll(src1, src2) _mpylill((src2), (src1)) #endif #ifndef _mpyilr #define _mpyilr(src1, src2) _mpylir((src2), (src1)) #endif #ifndef _mpyus4ll #define _mpyus4ll(src1, src2) _mpysu4ll((src2), (src1)) #endif #ifndef _saddsu2 #define _saddsu2(src1, src2) _saddus2((src2), (src1)) #endif #ifndef _swap2 #define _swap2(src) _packlh2((src), (src)) #endif /*把src1和src2的4对8bits相加，不会进行饱和，进位不会影响其他的8位数*/ int _add4 (int, int); /*计算2对有符号16位数的平均值*/ int _avg2 (int, int); /*计算4对有符号8位数的平均值*/ unsigned _avgu4 (unsigned, unsigned); /*比较2对16位数的值是否相等，结果放入dst的最低2位，相等返回1*/ int _cmpeq2 (int, int); /*比较4对8位数的值是否相等，结果放入dst的最低4位，相等置1，否则为0*/ int _cmpeq4 (int, int); /*比较2对有符号16位数，src1 &gt; src2，置为1；否则为0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80154985e0ca0e3aec49f313de488536/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbee17abda05aebc3ec24df1a80ddbbe/" rel="bookmark">
			source Insight设置自动缩进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		source Insight设置自动缩进
option-&gt;document options-&gt;auto indenting
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39c186e4fa161c1edebc334138bec584/" rel="bookmark">
			webdynpro for java 表格内复制一行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java webdynpro 中对于表格有时需要复制一行同时粘贴到下一行，官方文档中没有具体说明，但是类似node节点下新增一条element道理相同，只不过用到了一个WDCopyService方法，具体实现代码如下：
IReceiptsNode node = wdContext.nodeReceipts(); IReceiptsElement currEle = wdContext.currentReceiptsElement(); ZReceipts ele = new ZReceipts(); IPrivateCreateView.IReceiptsElement createEle = node.createReceiptsElement(ele); //将当前行字段值copy到新建行中 WDCopyService.copyCorresponding(currEle,createEle); node.addElement(createEle); ZReceipts ele = new ZReceipts(); 是新建element时需要的，根据node节点不同而不同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21bd9f082efa83f88b88fc749ddd809b/" rel="bookmark">
			Xtrabackup实现的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Xtrabackup的wiki上简单的介绍了一下实现的原理：
首先，在logfile中找到并记录最后一个checkpoint（“last checkpoint LSN”），然后开始从LSN的位置开始拷贝InnoDB的logfile到xtrabackup_logfile；接着，开始拷贝全部的数据文件.ibd；在拷贝全部数据文件结束之后，才停止拷贝logfile。
因为logfile里面记录全部的数据修改情况，所以，即时在备份过程中数据文件被修改过了，恢复时仍然能够通过解析xtrabackup_logfile保持数据的一致。
Tip1：Xtrabackup是一个用于备份InnoDB/XtrDB的工具，真正的在线备份（不影响数据的读写），InnoDB Hot Backup的开源替代品。
Tip2：在使用参数stream=tar备份的时候，你的xtrabackup_logfile可能会临时放在/tmp目录下，如果你备份的时候并发写入较大的话xtrabackup_logfile可能会很大（5G+），很可能会撑满你的/tmp目录，可以通过参数--tmpdir指定目录来解 决这个问题。
备份原理
XtraBackup基于InnoDB的crash-recovery功能。它会复制innodb 的data file，由于不锁表，复制出来的数据是不一致的，在恢复的时候使用crash-recovery，使得数据恢复一致。
InnoDB维护了一个redo log，又称为 transaction log，事务日志，它包含了innodb数据的所有改动情况。当InnoDB启动的时候，它会先去检查data file和transaction log，并且会做二步操作：
1.It applies committed transaction log entries to the data files
2.it performs an undo operation on any transactions that modified data but did not commit.
XtraBackup在备份的时候， 一页一页地复制innodb的数据，而且不锁定表，与此同时，XtraBackup还有另外一个线程监视着transactions log，一旦log发生变化，就把变化过的log pages复制走。为什么要急着复制走呢？ 前几章的时候就提过这个问题，因为transactions log文件大小有限，写满之后，就会从头再开始写，所以新数据可能会覆盖到旧的数据。
在prepare过程中，XtraBackup使用复制到的transactions log 对备份出来的innodb data file 进行crash recovery。
实现细节
文件权限
xtrabackup以read-write模式打开innodb的数据文件，然后对其进行复制。其实它不会修改此文件。也就是说，运行xtrabackup的用户，必须对innodb的数据文件具有读写权限。
为什么要用rw模式呢？直接read模式不好么？
因为xtrabackup采用了其内置的innodb库来打开文件，而innodb库打开文件的时候就是rw的。
Tuning the OS Buffers
因为XtraBackup要从文件系统中复制大量的数据，所以它尽可能地使用posix_fadvise()，来告诉OS不要缓存读取到的数据，从而提升性能。因为这些数据不会重用到了，OS却没有这么聪明。如果要缓存一下的话，几个G的数据，会对OS的虚拟内存造成很大的压力，其它进程，比如mysqld很有可能被swap出去，这样系统就会受到很大影响了。
posix_fadvise(file,0,0, POSIX_FADV_DONTNEED)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21bd9f082efa83f88b88fc749ddd809b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b955b33bcef9cc6eb1be9b7a705cede/" rel="bookmark">
			清除QList中的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看一下代码 QWidget *ww=new QWidget; qDebug()&lt;&lt;"ww--"&lt;&lt;ww; QList&lt;QWidget*&gt;list; list.append(ww); list.append(new QWidget); list.append(new QWidget); list.append(new QWidget); foreach(QWidget*w,list) { if(w) { list.removeOne(w); delete w; w=NULL; qDebug()&lt;&lt;"list size--"&lt;&lt;list.size(); } } if(ww) { qDebug()&lt;&lt;"ww is not null--"; // qDebug()&lt;&lt;ww; } 上面程序输出的结果是
这其中有几个问题在这里说明一下，
1如何清除QList中的数据
首先QList中有多个renmove函数来清除QList中的项，但是如果项是指针，则不会释放指针所指向的内存，如需要则应手动释放。
2释放指针所指向的内存
foreach(QWidget*w,list) { if(w) { list.removeOne(w); delete w; w=NULL; qDebug()&lt;&lt;"list size--"&lt;&lt;list.size(); } } if(ww) { qDebug()&lt;&lt;"ww is not null--"; // qDebug()&lt;&lt;ww; } 如果仔细看上面的代码以及代码的输出会发现，虽然循环中已经把QList中的项都清除了，指针也释放掉了， 但是if(ww)仍然判断为真。
其实，在这里是正确的。这个问题是变量作用域的问题，在循环中，w被delete释放掉了内存，w=NULL；也置为了空，但是并没有对指针ww进行任何修改，
ww所指向的内存地址仍然还是哪个内存地址，只是在循环结束后，这个内存地址所指向的内存所存放的东西已经没有了，所以if(ww)判断为真。
但是qDebug()&lt;&lt;ww;则不能正确打印，因为内容已经不存在了，这不是一个指向正确数据的指针了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/661e0ff93d374491aa15f871c1b0dad5/" rel="bookmark">
			Linux下定时自动重启mysql服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在/etc/crontab文件中添加一句：55 17 * * * root service mysql restart
crontab代码：
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
HOME=/
# For details see man 4 crontabs
# Example of job definition:
# .---------------- minute (0 - 59)
# | .------------- hour (0 - 23)
# | | .---------- day of month (1 - 31)
# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...
# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/661e0ff93d374491aa15f871c1b0dad5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9016f317d8105e53cde6f9b14c860dda/" rel="bookmark">
			CentOS7自动以root身份登陆gnome桌面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 7自动以root身份登录gnome桌面 刚刚在虚拟机中成功的安装上了CentOS 7 64位，发现在登录gnome桌面时必须创建一个普通用户，否则不让登录。
重启CentOS发现下方藏有一个使用其他用户登录选项，可以输入用户名使用root登录。
流畅且犀利的操作了一会儿，感觉很爽XD。想以后都用root登录，反正不是用于生产环境的服务器而是VMware虚拟机，有着强大的快照功能，随时可以恢复到上一个快照。好，赶紧进入正文。
1. 配置root自动登录gnome 在配置的时候会遇到GDM：
GDM是什么？ GDM (The GNOME Display Manager)是GNOME显示环境的管理器，并被用来替代原来的X Display Manager。与其竞争者(X3DM,KDM,WDM)不同，GDM是完全重写的，并不包含任何XDM的代码。GDM可以运行并管理本地和远程登录的X服务器(通过XDMCP)。
gdm仅仅是一个脚本，实际上是通过他来运行GDM二进制可执行文件。
gdm-stop是用来迅速终止当前正在运行的gdm守护进程的一个脚本。
gdm-restart脚本将迅速重启当前守护进程。
gdm-safe-restart会当所有人都注销后再重启。
gdmsetup是一种可以很简单的修改多数常用选项的图形化界面工具。
百度上搜到的都是RHEL、CentOS 6的配置方法，并不适用于CentOS 7。我在此贴出供各位看官参考：
在CentOS 6较新版本的Linux发行版中预设不允许以root账号登入gnome图形用户桌面，因此一般使用者登入后，可以在终端机以su root，暂时取得root权限；
如果一定要以root登入图形界面，可以修改/etc/pam.d/gdm以及 /etc/pam.d/gdm-passwd，把这行auth required pam_succeed_if.so user != root quiet加上#注释掉，保存后就可以用root账号了。
对于CentOS 7的用户，可参见RedHat的官方帮助文档： 14.3.6. Configuring Automatic Login
简单来说就是：vi /etc/gdm/custom.conf 然后在[daemon]下面添加：
[daemon] AutomaticLoginEnable=True AutomaticLogin=root #你想自动登录的用户名 保存并重启，重启的时候已经以root用户登录了。
2. 删除用户 删除用户可参见： CentOS 7用户账户配置
例如：
userdel danyl 只删除用户，不删除相关的文件以及目录；
userdel -rf danyl 强制删除danyl用户的所有文件及目录，请谨慎操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8ace84bdd10d9cf6555e14722327e8c/" rel="bookmark">
			Android开发学习之路--UI之简单聊天界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学了很多的ui的知识，这里就来实现个聊天的界面，首先来实现个layout的xml，代码如下：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;ListView android:id="@+id/msg_list_view" android:layout_height="0dp" android:layout_width="match_parent" android:layout_weight="1" android:divider="#0000"/&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;EditText android:id="@+id/input_text" android:layout_height="wrap_content" android:layout_width="0dp" android:layout_weight="1" android:hint="输入你想说的话" android:maxLines="2"/&gt; &lt;Button android:id="@+id/send" android:layout_height="wrap_content" android:layout_width="wrap_content" android:text="发送"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; 这里主要是listview来实现聊天的记录显示，edittext用于输入信息，button用于按钮发送。效果如下： 然后实现个listView的界面，这里用到了两张准备好的图片，是*.9.png，也就是9宫格的图片，主要的作用就是为了防止不该拉伸的地方拉伸，这里的界面用到了气泡，所以只要拉伸中间的背景就好了，两边的就不要拉伸了，新建msg_item.xml，代码如下：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:padding="10dp"&gt; &lt;LinearLayout android:id="@+id/left_layout" android:layout_height="wrap_content" android:layout_width="wrap_content" android:layout_gravity="left" android:background="@drawable/left_messages"&gt; &lt;TextView android:id="@+id/left_msg" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_margin="10dp" android:textColor="#fff"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/right_layout" android:layout_height="wrap_content" android:layout_width="wrap_content" android:layout_gravity="right" android:background="@drawable/right_messages"&gt; &lt;TextView android:id="@+id/right_msg" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_margin="10dp"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; 效果如下图所示： 这里的图片是网上找的png，然后ps改变大小，最后在android studio中，右击选择新建9-patch图片，然后选择拉伸的位置，如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8ace84bdd10d9cf6555e14722327e8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21c383b760ff3382359facdc3349674b/" rel="bookmark">
			Linux中pushd、popd和dirs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://ninayang1987.blog.sohu.com/148256687.html
1、dirs 1）功能 不带参数的dirs命令显示当前目录栈中的记录 2）语法 （1）格式：dirs [-clpv] [+n] [-n] （2）选项 -c 删除目录栈中的所有记录 -l 以完整格式显示 -p 一个目录一行的方式显示 -v 每行一个目录来显示目录栈的内容，每个目录前加上的编号 +N 显示从左到右的第n个目录，数字从0开始 -N 显示从右到左的第n个日录，数字从0开始 注意：dirs始终显示当前目录, 再是堆栈中的内容；即使目录堆栈为空, dirs命令仍然只显示当然目录 2、pushd 1）功能 pushd命令常用于将目录加入到栈中，加入记录到目录栈顶部，并切换到该目录； 若pushd命令不加任何参数，则会将位于记录栈最上面的2个目录对换位置，并切换到第二个目录。 2）语法 （1）格式：pushd [目录 | -N | +N] [-n] （2）选项 目录 将该目录加入到栈顶，并执行"cd 目录"，切换到该目录 +N 将第N个目录移至栈顶（从左边数起，数字从0开始） -N 将第N个目录移至栈顶（从右边数起，数字从0开始） -n 将目录入栈时，不切换目录 3、popd 1）功能 popd用于删除目录栈中的记录；如果popd命令不加任何参数，则会先删除目录栈最上面的记录，然后切换到删除过后的目录栈中的最上面的目录 2）语法 （1）格式：popd [-N | +N] [-n] （2）选项 +N 将第N个目录删除（从左边数起，数字从0开始） -N 将第N个目录删除（从右边数起，数字从0开始） -n 将目录出栈时，不切换目录 示例： root@ubuntu:~# pushd /root/code/
~/code ~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21c383b760ff3382359facdc3349674b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c7c01c40a7f4eabc8e7674515f98647/" rel="bookmark">
			mac OS X下制定ll指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ll作为ls -l的快捷方式，但系统本身没有，需要通过如下方法生成 1、在用户目录下新建.bash_profile文件 # vim .bash_profile 2、添加内容 alias ll = 'ls -l' alias la = 'ls -a' alias l = 'ls -la' 3、执行命令让其生效 # source .bash_profile 转载于:https://www.cnblogs.com/orzlin/p/5183377.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c8aa4313bd45ac7ee3609e80ce7a0cd/" rel="bookmark">
			Ubuntu 默认安装的vi超级难用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在插入状态下，按方向键出来的结果竟然是大写的字母ABCD，这是因为在ubuntu中其实没装vi,只装了vim-tiny，在系统上，vi仅仅是vim的一个别名。
这时候需要自己安装完整版的 vim
sudo apt-get install vim
将全新安装2个包，完成即爽！
http://blog.csdn.net/i46614161/article/details/4953975
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f329d48f78790c56c26f8bfecbac25bf/" rel="bookmark">
			微信JSSDK接口，previewImage
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在微信里看过文章的应该知道，文章里的图片点击后可以放大、分享和保存。
然而自己在微信里开发的网页，里面的图片点击后没办法实现这个效果，然后就去看了下微信JS文档，里面有个previewImage可以调用。
previewImage是微信客户端给内置浏览器增加的一个Javascript Interface，通过调用这个API，可以调起微信客户端提供的大图片查看组件。
官方说明和例子：
wx.previewImage({ current: '', // 当前显示图片的http链接 urls: [] // 需要预览的图片http链接列表}); document.querySelector('#previewImage').onclick = function () { wx.previewImage({ current: 'http://img5.douban.com/view/photo/photo/public/p1353993776.jpg', urls: [ 'http://img3.douban.com/view/photo/photo/public/p2152117150.jpg', 'http://img5.douban.com/view/photo/photo/public/p1353993776.jpg', 'http://img3.douban.com/view/photo/photo/public/p2152134700.jpg' ] });}; 可以看出例子中的数据是写死在里面的，所以要自己写个JS，然后把指定div里面图片加载到wx.previewImage中
&lt;div id="previewImage"&gt;&lt;img src="https://www.hackhp.com/1.jpg"&gt;&lt;img src="https://www.hackhp.com/2.jpg" &gt;&lt;/div&gt; 把图片链接都添加到wx.previewImage里
&lt;script&gt; $(document).on('click', '#previewImage img',function(event) { var imgArray = []; var curImageSrc = $(this).attr('src'); var oParent = $(this).parent(); if (curImageSrc &amp;&amp; !oParent.attr('href')) { $('#previewImage img').each(function(index, el) { var itemSrc = $(this).attr('src'); imgArray.push(itemSrc); }); wx.previewImage({ current: curImageSrc, urls: imgArray }); } });&lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60bd573cd2389fc7aa3185a6bfc492fb/" rel="bookmark">
			mark_as_advanced
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mark cmake cached variables as advanced.
mark_as_advanced([CLEAR|FORCE] VAR [VAR2 ...]) Mark the named cached variables as advanced. An advanced variable will not be displayed in any of the cmake GUIs unless the show advanced option is on. If CLEAR is the first argument advanced variables are changed back to unadvanced. If FORCE is the first argument, then the variable is made advanced. If neither FORCE nor CLEAR is specified, new values will be marked as advanced, but if the variable already has an advanced/non-advanced state, it will not be changed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60bd573cd2389fc7aa3185a6bfc492fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/617945b6da87749384014c692cdbadac/" rel="bookmark">
			一个预防堕落的秘方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1932年，时任北京大学文学院院长兼中国文学系主任的胡适先生，在给当年应届毕业的大学生的寄语中将“堕落”的方式概括成两类：一是容易抛弃学生时代的求知欲望，二是容易抛弃学生时代理想的人生追求。为了保持求知欲望和人生追求，他开出了三种药方（或者说是三句大白话）。而笔者今天特别想结合个人的经历来谈谈其中的第二个药方：总得多发展一点非职业的兴趣（这也是我感受最深的一点）。
胡适十分看重非职业兴趣的发展。他的论断是：“你的闲暇往往定你的终身。闲暇用来打麻将，就可能会成为赌徒；闲暇用来为社会服务，也许会成为社会改革者；闲暇用来研究历史，说不定就成了史学家”。胡适举出两个英国十九世纪的哲人来说事儿。一个是当了一辈子公司秘书的米尔，却在哲学、经济、政治思想史上占有很高位置。另一个是测量工程师斯宾塞，他用闲暇把自己历练成了十九世纪晚期世界思想界颇有影响的大家。胡适还特别指出，尤其是那些所从事的职业不合自己理想的人，有了闲暇的爱好和追求，生活不枯寂、精神不烦闷。就是连做6个小时擦桌子的工作也不烦闷，因为6个小时之后，就可以做自己心仪的事情了，或研究化学，或考证历史，或写小说戏曲，或画大幅山水。
我也想举两个我所熟悉的名人故事来印证胡适的论断，他们都是对人类文明起到过巨大推动作用的数学家。第一位是大名鼎鼎的“业余数学之王”、法国数学家费马。现在我们知道费马是解析几何的发明者之一；对于微积分诞生的贡献仅次于牛顿和莱布尼茨，他还是概率论的主要创始人，以及独撑17世纪数论天地的人。此外，费马对物理学也有重要贡献。然而，费马一生从未受过专门的数学教育，他的职业仅仅是一名律师，数学研究也不过是业余之爱好。很难想象，就是这样非专业的兴趣竟然就成了这位17世纪法国最伟大的数学家。
另外一位是微积分中格林公式的发明者。你一定想不到，英国数学家乔治·格林在生命的绝大部分时间里仅仅是一名磨坊工。直到他以四十岁之龄成为剑桥大学的本科生之前，甚至几乎没受过什么正规的教育。事实上，大学毕业后不久格林就因积劳成疾而病故。但即便如此，格林短促的一生仍然产出了对后世影响极为深远的重要论著。且这些论著基本都是在他入学剑桥之前完成的，也就是说格林的学术成绩差不多都是在其一边做工一边自学的生涯中创造的。现在我们知道，格林的学术成果直接影响了斯托克斯和麦克斯韦，并最终导致了电磁理论的诞生。如若不是凭借着一点非职业的兴趣，格林又何以在那座风车磨坊中度过那段未为人知的艰苦自学岁月呢？
这些例子不仅存在于历史书中，它其实广泛地存在我们周围。我经常给别人讲起过去单位的一个小保安。那时，我刚参加工作不久。小保安从我初到单位实习的时候就遇见了。当时我下班之后经常待在办公室晚走一些，每次下楼都能碰到这个家伙在看C++或者Java的书（而且看书的只有这个家伙）。后来他一直是保安，我则一直在公司继续重复我原本的工作。每每经常在走廊、地铁站、楼梯间里面碰见他背个大包，我们都相视一笑。直到某天我们再次相遇，他告诉我他辞职了，然后应聘到一家用友软件的合作商里面了。恭喜了半天，感觉确实很欣慰。我和他认识的一年半时间里，只是见过短短的几面，偶尔他借借我的U盘，或者让我帮他打印个身份证什么的。相比于别人，跟他认识的时间似乎只有几个小时的样子。一叶知秋，不经意间，我们就觉不到原来身边的树木都已经多了一圈年轮。不经意间，身边一个不让人留意的人已经华丽的转身，飞走了。不过想想这也确实该是他华丽转身的时候了。公司里的保安大多来自欠发达的农村，初到大城市，很多人都会迷茫，选择保安这种其实不太需要什么特殊能力的工作恐怕只能是没有选择的选择。但这个非职业的兴趣最终成为了我所认识的小保安赖以改变自身的一技之长。
我的另外一个大学同学的故事更为更励志。他的名字曾经多次出现在我的编程书前言里，作为我衷心感谢的合作伙伴。他也曾经有过一段程序员生涯。但是他还有高大上的业余爱好——凯尔特音乐。在我认识他的时候，这完全是他的一个业余爱好，业余的不能再业余。但是这个非职业的兴趣最终被他玩到了机制。他做过程序员，也从事英语培训工作，后来他又告诉我他在从事课程研发（尽管我其实并不太理解他的工作）。但他始终在坚持玩他的凯尔特音乐，后来爱尔兰总理访华时接见了他（因为凯尔特音乐相当于爱尔兰的古典民乐），格莱美大奖得主访华时邀他同台，国外的电视台采访过他，他家乡的广播电台邀请过他。最近的某期《中国之星》节目里，他为刘欢组的选手吉克隽逸伴奏，再最近他又出现在《我是歌手》节目里，为张信哲演出的“二十年以前”做伴奏嘉宾……
最后说说我自己。无论在我学习生涯还是实际工作中，到目前为止，几乎都没遇到过跟图像处理有关的内容。我的大学课程里完全没有图像处理或者信号处理的相关课程。我开始这方面的研究和学习，甚至源于一个傲气的赌约。至少到目前为止，我还没有以图像处理作为过谋生的技能。所以直到现在有人问起我，我都一直说：图像处理之于我而言只是业余爱好。就像费马喜欢做数学题，我的那位同学喜欢玩音乐一样。闲暇的爱好和追求，至少使“生活不枯寂、精神不烦闷”。我虽然可能终其一生也不太会提出一个什么“白马算法”，但我仍然自信于对这个领域我算是理解得比较深入的。我曾经出版过四本与图像处理有关的书籍，（尽管图像所涉及的内容非常广泛）对于基础领域的各个方面，我都略有涉及。而在偏微分方程在图像处理中的应用，以及图像降噪、去雾、增强、融合与安全等领域也有较深研究。与这个领域（主要是产业界）的一些同道中人也多有交互。在我看来，研究有趣的图像处理算法，特别是探索他们之间彼此的隐秘联系和脉络实在是一大趣事。好吧，所以我也希望我能够把我这个非职业的兴趣继续下去：）尽管我从来不指望从中获利，求知本身带个我的乐趣就是我最大的获益。
如果你所从事的职业恰恰是你的兴趣所致，那么恭喜你，因为你正享受着它所带给你的喜悦，而乐此不疲。就像那个以一己之力抗衡整个中国乒乓球界几代人的瓦尔德内尔。有没有告诉你，当他的第一个对手蔡振华已经当上中国体委主任的时候，老瓦仍然乐于做一名运动员。当他17岁拿到第一个冠军，并用奖金买了一台跑车后，就从来没碰过那辆车。直到他将那台蒙尘的跑车卖掉时，他都还没有驾照。我想这就是职业与兴趣完美结合的典型。但是我又不得不说，这其实很难得。我想更多人仍然属于胡适笔下“那些所从事的职业不合自己理想的人”，那么为了避免走向堕落，何不发展一点点非职业的兴趣？还记得《钢铁是怎样炼成的》里面保尔·柯察金的那句话吗？“当回首往事的时候，不会因为虚度年华而悔恨，也不会因为碌碌无为而羞愧。”希望这点非职业的兴趣能够让你回首往事时不悔恨，不羞愧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb72ae9ec05b58551821db5f69dbdf5d/" rel="bookmark">
			appium常见问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在appium的使用过程中，经常出现也被问到一些问题，总结一下，方便大家“对号入座”吧~~~
1. “A new session could not be created.(Original error:)”...
原因：通常，出现这种问题的原因是，由于appium server还没有断开时，你又再次执行脚本了，所以报错。
方法：断开appium server，再启动
2.环境变量问题：ANDROID_HOME is set but does not exist on the file system...
原因：ANDROID_HOME配置时，多了一个分号 方法：去掉分号
3.环境问题："java -version" failed...Error: spawn ENOENT
原因：node版本太低
方法：升级了一下node，就好了
4.启动了错误的activity
原因：起始activity不对
方法：在CMD命令行执行如下命令，查看启动的activity名字（由于是真机，无法用HierarchyViewer.bat查看。所以采用命令行方式）
aapt d badging &lt;xxxx.apk&gt; | findstr "name launch-activity"
用这个命令会更好：
aapt d badging &lt;xxxx.apk&gt; | findstr "package launchable-activity"
*** 注意：这里需要根据自己的apk所在路径和名字修改
可能出现如下情况：
方法：从sdk\build-tools目录下把aapt.exe这个文件复制到tools目录下
5.“Failed to start an Appium session.”...
排错步骤：
1) 检查C:\Program Files (x86)\Appium\node_modules\appium\node_modules\appium-adb\jars\sign.jar是否存在
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb72ae9ec05b58551821db5f69dbdf5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51839a48b2ffe43167bf9677b9b54aab/" rel="bookmark">
			SELECT INTO FROM   mysql  Undeclared variable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用SELECT INTO FROM进行数据表和数据的复制时，会提示Error Code: 1327. Undeclared variable: 这是因为mysql 数据库不支持 SELECT INTO FROM，
可用insert into table1 select * from table2 代替
转载于:https://www.cnblogs.com/yangcclg/p/5174950.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c276cef860a893fe1a5ebd0c100323c2/" rel="bookmark">
			视音频数据处理入门：RGB、YUV像素数据处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		=====================================================
视音频数据处理入门系列文章：
视音频数据处理入门：RGB、YUV像素数据处理
视音频数据处理入门：PCM音频采样数据处理
视音频数据处理入门：H.264视频码流解析
视音频数据处理入门：AAC音频码流解析
视音频数据处理入门：FLV封装格式解析
视音频数据处理入门：UDP-RTP协议解析
=====================================================
有段时间没有写博客了，这两天写起博客来竟然感觉有些兴奋，仿佛找回了原来的感觉。前一阵子在梳理以前文章的时候，发现自己虽然总结了各种视音频应用程序，却还缺少一个适合无视音频背景人员学习的“最基础”的程序。因此抽时间将以前写过的代码整理成了一个小项目。这个小项目里面包含了一系列简单的函数，可以对RGB/YUV视频像素数据、PCM音频采样数据、H.264视频码流、AAC音频码流、FLV封装格式数据、UDP/RTP协议数据进行简单处理。这个项目的一大特点就是没有使用任何的第三方类库，完全借助于C语言的基本函数实现了功能。通过对这些代码的学习，可以让初学者迅速掌握视音频数据的基本格式。有关上述几种格式的介绍可以参考文章《[总结]视音频编解码技术零基础学习方法》。
从这篇文章开始打算写6篇文章分别记录上述6种不同类型的视音频数据的处理方法。本文首先记录第一部分即RGB/YUV视频像素数据的处理方法。视频像素数据在视频播放器的解码流程中的位置如下图所示。
本文分别介绍如下几个RGB/YUV视频像素数据处理函数： 分离YUV420P像素数据中的Y、U、V分量 分离YUV444P像素数据中的Y、U、V分量 将YUV420P像素数据去掉颜色（变成灰度图） 将YUV420P像素数据的亮度减半 将YUV420P像素数据的周围加上边框 生成YUV420P格式的灰阶测试图 计算两个YUV420P像素数据的PSNR 分离RGB24像素数据中的R、G、B分量 将RGB24格式像素数据封装为BMP图像 将RGB24格式像素数据转换为YUV420P格式像素数据 生成RGB24格式的彩条测试图 本文中的RGB/YUV文件需要使用RGB/YUV播放器才能查看。YUV播放器种类比较多，例如YUV Player Deluxe，或者开源播放器（参考文章《修改了一个YUV/RGB播放器》）等。
函数列表 (1) 分离YUV420P像素数据中的Y、U、V分量本程序中的函数可以将YUV420P数据中的Y、U、V三个分量分离开来并保存成三个文件。函数的代码如下所示。 /** * Split Y, U, V planes in YUV420P file. * @param url Location of Input YUV file. * @param w Width of Input YUV file. * @param h Height of Input YUV file. * @param num Number of frames to process.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c276cef860a893fe1a5ebd0c100323c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce066a3072efd079fc34c62ff1b40a6e/" rel="bookmark">
			Android开发学习之路--Android Studio项目目录结构简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		既然已经搭建好环境了，那就对Android Studio中项目目录结构做个简单的了解了，这里以最简单的Hello工程为例子，新建好工程后看如下三个工程视图：
1、Android工程
manifests：
AndroidManifest.xml：APP的配置信息
java：主要为源代码和测试代码
res：主要是资源目录，存储所有的项目资源
drawable：存储一些xml文件，-*dpi表示存储分辨率的图片，用于适配不同的屏幕。
-mdpi:320x480
-hdpi:480x800、480x854
-xhdpi:至少960x720
-xxhdpi:1280x720
layout：存储布局文件
mipmap：存储原声图片资源
values：存储app引用的一些值
- colors.xml： 存储了一些color的样式
- dimens.xml：存储了一些公用的dp值 - strings.xml： 存储了引用的string值
- styles.xml： 存储了app需要用到的一些样式
Gradle Scripts:build.gradle为项目的gradle配置文件
2、Project工程
build：系统生成的文件目录，最后生成的apk文件就在这个目录，这里是app-debug.apk
libs：为项目需要添加的*.jar包或*.so包等外接库
src：项目的源代码，其中android test为测试包，main里为主要的项目目录和代码，test为单元测试代码
3、Packages工程
4、AndroidManifest.xml
AndroidManifext描述了package中暴露的组件像activity，serveice等，他们各自的实现类，各种能被处理的数据和启动位置。此外还能声明程序中的contentproviers，intentreceivers，还能指定permissions和instrumentation等等。
xmlns:android：定义android的命名空间。
package：指定本应用内java主程序的包名，这里就是com.example.jared.hello了。
application：声明了每一个应用程序的组件及其属性。
android:allowBackup：将程序加入到系统的备份和恢复架构中。
android:icon：显而易见表示APP的图标了。
android:label：许可列表。
android:supportsRtl：启用各种RTLAPI来用RTL布局显示应用，这个是android4.2的新特性。 android:theme：android的主题。
activity：android:name表示当前的activity的名字，因为工程为MainActivity，所以这个名字就为这个，之后有新的activity的话，也需要添加才可以使用。
intent-filter：包含了action，data和category三种。
action：只有android:name属性，常见的是android.intent.action.MAIN，表示此activity是作为应用程序的入口。 data：指定了希望接受的intent请求的数据URI和数据类型。
category：android:name属性，常见的是android.intent.category.LAUNCHER，决定应用程序是否显示在程序列表里。
关于本应用的manifest基本上没啥问题了，以后遇到了别的google查阅就好。
5、layout的activity_main.xml
RelativeLayout：相对布局。
xmlns:android定义：android命名空间。
xmlns:tools：tools命名空间，用来预览一些布局属性的添加喝删除后的效果。
android:layout_width：指定了控件的宽度，可选择match_parent，fill_parent，wrap_content，其中match_parent和fill_parent的意思相同，官方更加推荐使用match_parent。match_parent表示让当前控件的大小和父布局的大小一样，也就是由父布局来决定当前控件的大小。wrap_content表示让当前控件的大小能够刚好包含住里面的内容，也就是由控件内容决定当前控件的大小。
android:layout_height:同上。
android:paddingLeft，android:paddingRight，android:paddingTop，android:paddingBottom：站在父view的角度描述问题，它规定它里面的内容必须与这个父view边界的距离。此外还有margin，它是站在自己的角度描述问题，规定自己喝其他的view之间的距离，如果同一级只有一个view，那么它的效果基本上就和padding一样了。
TextView：android的控件。
android:text：textview显示的内容，这里就是hello world了。
至此，androd的layout简单介绍了下，至于之后遇到的种种，google等着你。
6、MainActivity.java
package com.example.jared.hello; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce066a3072efd079fc34c62ff1b40a6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbc521ee0efdef32f4e746fc4008f169/" rel="bookmark">
			Android开发学习之路--MAC下Android Studio开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自从毕业开始到现在还没有系统地学习android应用的开发，之前一直都是做些底层的驱动，以及linux上的c开发。虽然写过几个简单的app，也对android4.0.3的源代码做过部分的分析，也算入门了，但是很多的知识点都是零零散散的，也缺少了总结。
相信凭借着对于linux内核层，android framework层的熟悉，加上也写过简单的应用，对于之后的android开发学习之路会事倍功半。
要学android，先要学java，但是光光从学java开始，会让很多人还没动手之前就失去了兴趣，所以个人觉得还是实践为主，不是一直都说实践是检验真理的唯一标准嘛，相信每个人都希望检验真理。既然要动手，那么必须得搭建个开发环境了，由于本人用的是mac pro（之前买来学习了段时间ios，简单的ios的控件和oc也算明白了点，为以后打下基础），win下的开发环境以前一直都是一个eclispe一个sdk。mac下想用用android studio，之前的1.0版本发现太老了一些东西不能用，于是乎就准备装个2.0版本的，遇到种种问题之后，还是记录下搭建过程了。
一些资源可以参考如下网站，个人觉得不错：
资源提供网站: http://www.androiddevtools.cn/ 1、下载android studio
先根据上述的资源提供网站下载最新的android studio（以下简称AS），本文以AS2.0 preview4为例。
下载好之后解压缩后，打开finder，放到应用层的目录下去，如下图：
绿色的那个就是图标了，记得1.0版本是个小机器人的。哎，mac的安装还是相当方便的，不像win下一步，点击啊，各种install啊，心累。
2、安装／更新jdk和sdk
既然更新好了，那么就去下载jdk1.7和sdk tool，然后指定sdk和jdk的路径。File-&gt;Project Structure(快捷键command+;)如下图：
jdk的路径一般是这样子了，sdk需要根据自己的sdk存放的路径来设置。
天朝把google给屏蔽了，要更新sdk还得接着搞代理。
打开Tools-&gt;Android&gt;SDK Manager
点击红框出来如下界面
这里的Android studio有个小bug，首先把Android studio的界面先最小化，然后启动Android SDK Manager在桌面，点击Android SDK Manager-&gt;Preferences 然后设置
具体如下图：
HTTP Proxy Server：mirrors.opencas.cn HTTP Proxy Port:80
其他代理设置可以参考上述的资源提供网站。
当然你也可以直接从上述的网站里面直接获取sdk的相关资源。
好了，设置好之后那就是漫长的等待下载了。
3、新建Hello Project
按着指导下一步下一步先简单地建立个工程测试下，发现各种gradle的问题。什么plugin too old，明明是2.10的。搞不懂，最后stackoverflow找到了方法，设置了下版本，如下图：
把gradle:2.0.0改为了1.5.0，然后不要同步，关掉AS，重新开始，接着就是gradle的一些build了，之后就可以运行了。然后可以运行模拟器来启动android的应用了。
4、mac下的android真机调试 虽然android下的模拟器可以实现应用调试，但是速度实在是太慢了，所以得有真机调试才靠谱，但是mac下怎么来真机调试呢，还是得问问万能的google了，这里做个简单的介绍。
首先usb连上手机，这里测试的是华为手机，接着在mac的终端输入命令如下：
system_profiler SPUSBDataType 接着就可以得到如下信息：
huawei TD Smart Phone: Product ID: 0x1038 Vendor ID: 0x12d1 (Huawei Technologies Co., Ltd.) Version: 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbc521ee0efdef32f4e746fc4008f169/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d3f1a09f57b5c630f1b73140be03c40/" rel="bookmark">
			为什么如果数据库导入data.sql，则zabbix_proxy服务无法启动？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zabbix_proxy的main()函数如下
int	main(int argc, char **argv) { zbx_task_t	task = ZBX_TASK_START; char	ch; #if defined(PS_OVERWRITE_ARGV) || defined(PS_PSTAT_ARGV) argv = setproctitle_save_env(argc, argv); #endif progname = get_program_name(argv[0]); /* parse the command-line */ while ((char)EOF != (ch = (char)zbx_getopt_long(argc, argv, shortopts, longopts, NULL))) { switch (ch) { case 'c': CONFIG_FILE = zbx_strdup(CONFIG_FILE, zbx_optarg); break; case 'R': if (0 == strcmp(zbx_optarg, ZBX_CONFIG_CACHE_RELOAD)) task = ZBX_TASK_CONFIG_CACHE_RELOAD; else { printf("invalid runtime control option: %s\n", zbx_optarg); exit(EXIT_FAILURE); } break; case 'h': help(); exit(-1); break; case 'V': version(); exit(-1); break; default: usage(); exit(-1); break; } } if (NULL == CONFIG_FILE) CONFIG_FILE = zbx_strdup(CONFIG_FILE, SYSCONFDIR "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d3f1a09f57b5c630f1b73140be03c40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/922966f14bd9412ce1f6e0f1bac734fe/" rel="bookmark">
			【转】Notepad&#43;&#43; 中文查找(中文搜索)问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文：http://www.365fy.com/fybbs/viewthread.php?tid=9024
Notepad++ 查找中文字符时有问题，找到的结果根本就不是你要查的内容。以下两种临时解决方法任选一种即可解决：
方法一：查找时，在“查找模式”中，由“普通”改为“正则表达式”。 方法二：在菜单栏的“格式”中，默认是“以ANSI格式编码”，改为使用“GB2312”就好了（格式-&gt;Character sets-&gt;Chinese-&gt;GB2312）。Windows上的中文默认是按GB18030编码的。 &lt;script&gt;window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];&lt;/script&gt; 阅读(900) | 评论(0) | 转发(0) | 0 上一篇：【转】Java基本概念：集合类 List/Set/Map...的区别
下一篇：【转】从JVM内存管理的角度谈谈静态方法和静态属性
相关热门文章 tar、tgz、gz批量解压方法...内网访问香港服务器慢——解决...centos 7 安装 vmware worksta...java.net.MalformedURLExcepti...OpenStack 无法连接到Neutron ... A sample .exrc file for vi e...游标的特征IBM System p5 服务器 HACMP ...busybox的httpd使用CGI脚本(Bu...Solaris PowerTOP 1.0 发布 linux dhcp peizhi roc关于Unix文件的软链接求教这个命令什么意思，我是新...sed -e "/grep/d" 是什么意思...谁能够帮我解决LINUX 2.6 10... 给主人留下些什么吧！~~ 评论热议 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb0dfbfc5edde6eea1f1b63bde2cdf4/" rel="bookmark">
			51单片机汇编编程－－16位拉幕灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		16位拉幕灯。
说明：
由P1、P2组成16位拉幕灯，依次由P1.0逐次点亮到P2.7。
再由P2.7到P1.0逐次熄灭。如此循环。
题目链接：http://zhidao.baidu.com/question/1509966686324214140.html
做而论道编程如下：2014-05-07 09:59
;试试看：
ORG 0000H
MOV 30H, #0
MOV 31H, #0
M_LOOP:
MOV R2, #16
DISP1:
MOV P1, 30H
MOV P2, 31H
CALL RIGHT
CALL DL
DJNZ R2, DISP1
MOV R2, #16
DISP2:
MOV P1, 30H
MOV P2, 31H
CALL LEFT
CALL DL
DJNZ R2, DISP2
SJMP M_LOOP
;-----------------------
LEFT:
CLR C
MOV A, 30H
RLC A
MOV 30H, A
MOV A, 31H
RLC A
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfb0dfbfc5edde6eea1f1b63bde2cdf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/898b7a4aabeb70bf96a94a67844ddca2/" rel="bookmark">
			初识Face&#43;&#43;在android上的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近两天终于可以正式的开始基于Face++下，Android的人脸识别了；感觉看着里面的说明文档就两个字：头疼疼！
首先：注册--&gt;创建自己的 应用--&gt;获取KEY和 SECRET(这个用于自己的项目中)；具体参考：http://www.faceplusplus.com.cn/create-a-new-app/ ；在这里就不浪费墨水了。
用到的sdk下载：:http://www.faceplusplus.com.cn/dev-tools-sdks/ 里面有faceppsdk_min.jar可以根据自己的需要放在自己的项目中 ，然后Bulid一下就OK使用了。
faceppsdk_min.jar 说明：本人查考里面的代码发现在这个架包里面都是一些接口方法，（或者我认为是一些工具方法）具体的图像分析都是调用里面的方法然后 通过网络上传到服务进行分析的；
经过大量的java工程的测试，得到的一些心得如下 以javaFaceDemo 为例说明：
A: 帮助文档的Demo 只是例行公事的调用了 架包中的方法，让我们看起来很牛13的样子；但是细细分析就会发现里面有很多的重复的代码的套用，还有一些功能都是简单的调用了一下，并没有给出太明显的能看出来的使用技巧；所以要想很好的使用架包，大致理解Demo中的每个方法功能是很有必要的；下面我大致说下我个人的理解：
Person：创建”一个“人：（在Demo中一共有两个图片地址，这里姑且认为是url1、url2）通过url1 我们可以识别（HttpRequests.detectionDetect(...)）这张图片中有多少人脸存在;然后就是添加一些“人”的基本信息：如人的名字：PersonName:person_1;然后获取“人”的返回信息；
Faceset：创建一个人脸集合；
Group：创建一个群组；在这个方法中 "group_0"就是我们创建的群组的名称（当然这个名称可以自己定义，这里就用“group_0”来说明了。）；personList.add("person_"+i);：就是我们向这个群组中添加 我们在 Person类中创建的“人”；（训练一次就可以了，下面使用的时候可以注释掉该训练。）；httpRequests.recognitionVerify：给定的人脸和人 进行判断是否是（相同的）给定的人；这里注意了：setPersonName表示给定的人的名称，也就是之前的创建的任务名称；getJSONObject（0）表示图片中的下表为“0”，也就是第一个人脸对应的人（注意：如果图像中只有一个人脸那么就只能比较一次了）。
Recognition：人脸识别：在httpRequests.trainIdentify方法中的“group_0”就是我们选择的训练的群组的名称，和Group中的群组名称一致；httpRequests.trainVerify
方法就是对“人”进行训练，里面的(“person_”+i)就是人名称Name；
Info：执行查询操作：
At_last：最终的删除数据（在测试使用过后一定记得要删除我们创建的“人”或者“集合”，不然下次执行时就会报异常了！ ）；
B:可以通过Person方法多创建几个“人”（可以通过访问多个图像url来创建），通过 Group方法创建多个群组，在Recognition方法中进行训练；这个步骤完成后就可以人脸识别测试了：注释掉创建的Person、Group方法，然后在Recognition方法中可以注释掉训练方法，只需要在Recognition方法中 设置要识别的 群组名称，和 人物 名称就可以进行测试了；可以通过查看日志信息“is_same_person”中的true或者false 观察识别结果了。
至此 我们应该就大致了解了如何进行简单的人脸测试了。
注：以上内容仅是个人观点，如有不当之处可以指出，让我们共同学习共同进步！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c6eff81368ebf1377ccf6f9f55293eb/" rel="bookmark">
			Linux 双物理网卡绑定成一个虚拟网卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux 下, 經常需要將兩塊物理網卡綁定成一個虛擬網卡, 來防止一塊網卡或其對應的網絡出現故障造成服務中斷.
環境: Oracle Linux Server release 6.6
1) 建立 ifcfg-bond0, 配置IP地址為 10.134.145.126
2) 分別修改 ifcfg-eth0 和 ifcfg-1 將 BOOTPROTO 設置為 dhcp, MASTER=bond0, Slave=yes
3) 配置內核模塊配置文件 /etc/modprobe.d/modprobe.conf , 如果已經存在就在后面添加這兩行
miimon=100, 系統每 100ms 檢測一次鏈路連接狀態, 如果一條不通就轉入另一條線路
mode=0,1,2,3, 0:負載均衡, 兩塊同時啟用, 1:故障備援, 1塊 啟用 1塊停用, 當啟用的網卡不通時啟用另一塊
注: bonding 只提供鏈路檢測, 即網卡到交換機是否接通, 交換機到其它網絡的故障與其無關
4) 加入到開機自動啟動
重新啟動電腦后生效, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37dcb389db452a597d5c7b508bea87b2/" rel="bookmark">
			网络测试常用的命令-比较ping,tracert和pathping等命令之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无论你是一个网络维护人员，还是正在学习TCP/IP协议，了解和掌握一些常用的网络测试命令将会有助于您更快地检测到网络故障所在，同时也会有助你您了解网络通信的内幕。
下面我们逐步介绍几个常用的命令：
1、Ping命令。 当您的机器不能访问Internet，首先确认是否是本地局域网的故障。假定局域网的代理服务器IP地址为202.168.0.1，您可以使用ping 202.168.0.1命令查看本机是否和代理服务器联通。此外可以测试本机的网卡是否正常工作，使用 ping 127.0.0.1命令。一般返回ping的信息就表示本地到该主机的网络线路连通。
但是很多服务器为了防止攻击，一般会关闭对ping的响应。所以ping一般作为测试连通性使用。ping命令后，会接收到对方发送的回馈信息，其中记录着对方的IP地址和TTL。TTL是该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。TTL是IPv4包头的一个8 bit字段。例如IP包在服务器中发送前设置的TTL是64，你使用ping命令后，得到服务器反馈的信息，其中的TTL为56，说明途中一共经过了8道路由器的转发，每经过一个路由，TTL减1。
2、Tracert Tracert命令用来显示数据包到达目标主机所经过的路径（路由器），并显示到达每个节点（路由器）的时间。命令功能同Ping类似，但它所获得的信息要比Ping命令详细得多，它把数据包所走的全部路径、节点的IP以及花费的时间都显示出来。该命令比较适用于大型网络。
Tracert 先发送 TTL 为 1 的回应数据包，当数据包上的 TTL在路由器收到后TTL自动减1 ，一旦某个服务器将TTL减1后，等于了0，路由器应该将“ICMP Time Exceeded”的消息发回源计算机，源计算机就根据收到的信息判断达到的路由器和所用时间。下次再次发送数据包时，将TTL递增 1，继续上述测试，直到目标响应或 TTL 达到最大值，从而确定路由。通过检查中间路由器发回的“ICMP 已超时”的消息确定路由。某些路由器不经询问直接丢弃 TTL过期的数据包，这在 Tracert 实用程序中看不到，我们会显示请求超时的请求信息。下图所示，我们测试到新浪的路经过了8道路由，同时根据上图测试ping 新浪时候，TTL=56，说明新浪的TTL初始设置为64，经过8道路由后到达我们客户机，还剩下64-8 = 56。下图中请求超时的反馈信息是因为路由器对ping命令做了处理，关闭了ping的响应，所以我们收不到发给他的反馈信息。
3、pathping pathping 命令是一个路由跟踪工具，它将 ping 和 tracert 命令的功能与这两个工具所不提供的其他信息结合起来，综合了二者的功能。pathping会先显示中间的通过的路由器（类似tracert命令得到的信息），然后对每个中间路由器（节点）发送一定数量的ping包，通过统计他们对ping包响应的数据包来分析通信质量。上面也提到了，有的路由器对ping关闭了响应，所以有的节点的丢包率会达到100%，所以这种一般就是关闭了ping回复。你可以自己ping试一下。还有，对ping包丢弃程度只是节点本身对ping的处理，并不一定影响他的通信，你可以看到，关闭ping命令节点的下一个节点返回到数据是正常的，说明回复的包都成功发送回来。总之，pathping 命令在一段时间内将数据包发送到将到达最终目标的路径上的每个路由器，然后根据从每个跃点返回的数据包计算结果。由于命令显示数据包在任何给定路由器或链接上丢失的程度，因此可以很容易地确定可能导致网络问题的路由器或链接。下图所示，我们看到，达到第二个就终止了，因为第二道节点（路由器），不支持ping，然后，程序就终止不在继续往下探测了。
4、 nslookup Nslookup命令用于解析域名，一般用来检测本机的DNS设置是否配置正确。如： nslookup 网站域名，即可解析出网站的IP地址。如图，可以看出解析www.163.com的时候，可以解析出它所有的IP地址，而如果网路出现异常或者无法收到服务器发送来的信息时候，会出现下面第二张图片的显示。服务器和Address代表是解析这些IP地址和域名的DNS服务器信息。比如我使用的DNS是jtjndc007.home.langchao.com, DNS服务器地址是10.100.1.11.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec2647e040fcc12c1b997d47807eec48/" rel="bookmark">
			-webkit-overflow-scrolling 实现快速滚动和回弹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 HTML5网页内都有快速滚动和回弹的效果，看上去和原生app的效率都有得一拼。
实现方式：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"/&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"&gt; &lt;title&gt;scroll&lt;/title&gt; &lt;style type="text/css"&gt; *{margin: 0;padding: 0;} header{ background: #f00; color: #fff; } nav { width: 85%; height: 30px; line-height: 30px; white-space: nowrap; overflow: hidden; overflow-x: scroll; -webkit-overflow-scrolling: touch; } nav::-webkit-scrollbar { display: none; } nav a { display: inline-block; width: 50px; height: 30px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;nav&gt; &lt;a&gt;菜单1&lt;/a&gt; &lt;a&gt;菜单2&lt;/a&gt; &lt;a&gt;菜单3&lt;/a&gt; &lt;a&gt;菜单4&lt;/a&gt; &lt;a&gt;菜单5&lt;/a&gt; &lt;a&gt;菜单6&lt;/a&gt; &lt;a&gt;菜单7&lt;/a&gt; &lt;a&gt;菜单8&lt;/a&gt; &lt;a&gt;菜单9&lt;/a&gt; &lt;a&gt;菜单10&lt;/a&gt; &lt;/nav&gt; &lt;/header&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf05b90cfabe90a06c03d29d20650b3b/" rel="bookmark">
			Java算法---华为oj矩阵乘法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;span style="font-size:18px;"&gt;import java.util.Scanner; /** * Created by Administrator on 2015/01/18. */ public class Main{ public static void main(String[] args) { Scanner sc=new Scanner(System.in); while (sc.hasNext()){ int Marx1hang=sc.nextInt(); int Marx1lie2hang=sc.nextInt(); int Marx2lie=sc.nextInt(); int[][] Marx1=new int[Marx1hang][Marx1lie2hang]; int[][] Marx2=new int[Marx1lie2hang][Marx2lie]; for(int i=0;i&lt;Marx1hang;i++){ for(int j=0;j&lt;Marx1lie2hang;j++){ Marx1[i][j]=sc.nextInt(); } } for(int i=0;i&lt;Marx1lie2hang;i++){ for(int j=0;j&lt;Marx2lie;j++){ Marx2[i][j]=sc.nextInt(); } } for(int i=0;i&lt;Marx1.length;i++){ StringBuffer sb=new StringBuffer(); for(int j=0;j&lt;Marx2[0].length;j++){ int sum=0; for (int k=0;k&lt;Marx1lie2hang;k++){ sum+=(Marx1[i][k]*Marx2[k][j]); } sb.append(sum+" "); } System.out.println(sb.substring(0,sb.length()-1)); } } } } &lt;/span&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d2e3db001c4ab7c3efa5b731ed9b88e/" rel="bookmark">
			mysql5.7 安装方法 (跟旧的不一样了)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 5.7发布之后很多网友都在说，打开想安装文件夹.但是文件夹中没有DATA目录, 没有mysqly默认库.启动不了数据库，那是因为5.7的数据库的初始化方法和之前的初始化不一样了。 首先这里所描述的过程适用于所有平台的MySQL。5.7.6之前，使用mysql_install_db在UNIX和类UNIX系统。MySQL 5.7.7之前，Windows分布包括了在MySQL数据库建表的数据目录。 MySQL5.7数据库 64位 5.7.10 官方最新版 授权方式：免费软件软件类型：国外软件软件语言：英文软件大小：89.94 MB更新日期：2015-12-08运行环境：WinXP, Win2008, Win7, Win8 下载地址 MySQL5.7 32位 5.7.10 官网最新版 授权方式：免费软件软件类型：国外软件软件语言：英文软件大小：86.2 MB更新日期：2015-12-08运行环境：WinXP, Win2008, Win7, Win8 下载地址 以下说明假定您当前的位置是MySQL的安装目录，这里以BASEDIR为例 1 shell&gt; cd BASEDIR 要初始化数据目录，调用 mysqld的与 --initialize或 --initialize不安全的选项，这取决于你是否希望服务器生成的一个随机初始密码'root'@'本地账号'的账户。 在Windows环境下，使用这些命令： 1 2 C:\&gt; bin\mysqld --initialize C:\&gt; bin\mysqld --initialize-insecure 在Unix和类Unix系统，重要的是要确保数据库的目录和文件都是由拥有 MySQL的登录帐户，以便服务器具有读写访问它们，当你以后运行它。为了确保这一点，如果你运行的mysqld为root，包括 --user选项，如下所示： 1 2 shell&gt; bin/mysqld --initialize --user=mysql shell&gt; bin/mysqld --initialize-insecure --user=mysql 否则，执行程序，而身份登录mysql的，在这种情况下可以省略 --user从命令选项。 无论任何平台，使用 --initialize为“ 默认安全 ”的安装（即包括产生一个随机的初始根密码）。在这种情况下，密码被标记为过期，你需要选择一个新的密码。随着 --initialize-insecure 的选项，没有root口令生成; 假设你把服务器投入使用之前指定一个密码及时查询账户。 如果mysqld的没有标识的安装目录或数据目录的正确位置.它可能需要指定其他选项，如 --basedir或 --datadir.如果mysqld的没有标识的安装目录或数据目录的正确位置。例如（输入在一行上的命令）： 1 2 3 shell&gt; bin/mysqld --initialize --user=mysql --basedir=/opt/mysql/mysql --datadir=/opt/mysql/mysql/data 另外，对于Unix和类Unix系统，假设选择文件名是 /opt/mysql/mysql/etc/my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d2e3db001c4ab7c3efa5b731ed9b88e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a951a8653cd2589fd1a66c0688d3ee4/" rel="bookmark">
			MySQL存储过程的动态行转列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL存储过程中使用动态行转列 最近做项目关于数据报表处理，然而数据库存储格式和报表展现形式不同，需要进行一下行转列的操作，在做上一个项目的时候也看了一下，但是后来换了读取方式，也就没深入研究这个问题了。
而这一次必须要直面这个问题了，奈何我是那么的不想看，可项目不能因为这个问题卡在这，只好好好找资料看如何解决这个问题。
开始也在网上找到一些MySQL行转列的例子，但大部分都是静态的，要么就是不知所云，说的不是很清楚。后来就找到国外的一个资料，参考了之后对照自己项目的数据库，然后便成功的实现了动态行转列。下面我以一个简单的数据库为例子，说明一下。
数据表结构 这里我用一个比较简单的例子来说明，也是行转列的经典例子，就是学生的成绩
三张表：学生表、课程表、成绩表
学生表
就简单一点，学生学号、学生姓名两个字段
CREATE TABLE `student` ( `stuid` VARCHAR(16) NOT NULL COMMENT '学号', `stunm` VARCHAR(20) NOT NULL COMMENT '学生姓名', PRIMARY KEY (`stuid`) ) COLLATE='utf8_general_ci' ENGINE=InnoDB; 课程表
课程编号、课程名
CREATE TABLE `courses` ( `courseno` VARCHAR(20) NOT NULL, `coursenm` VARCHAR(100) NOT NULL, PRIMARY KEY (`courseno`) ) COMMENT='课程表' COLLATE='utf8_general_ci' ENGINE=InnoDB; 成绩表
学生学号、课程号、成绩
CREATE TABLE `score` ( `stuid` VARCHAR(16) NOT NULL, `courseno` VARCHAR(20) NOT NULL, `scores` FLOAT NULL DEFAULT NULL, PRIMARY KEY (`stuid`, `courseno`) ) COLLATE='utf8_general_ci' ENGINE=InnoDB; 以上就是数据库表的结构了，这里没有建立外键，但是根据表的结构，可以清楚的看到成绩表中的学号和课程号是与学生表、课程表分别关联起来的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a951a8653cd2589fd1a66c0688d3ee4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93b0f228d9430d13e3d0d59b55c3beb8/" rel="bookmark">
			Android多用户系列：跨用户启动（绑定）Service、启动Activity、访问ContentProvider
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 启动Service 二. 启动Activity 三. 访问ContentProvider 调用ContentProvider.maybeAddUserId(Uri uri, int userId)方法，为uri添加相应的用户信息即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/614982cfda6d78b345509afb7db68909/" rel="bookmark">
			poi 日期处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@SuppressWarnings({ "static-access" }) private String getValue(Cell hssfCell) { if (hssfCell == null) { return null; } if (hssfCell.getCellType() == Cell.CELL_TYPE_BOOLEAN) { // 返回布尔类型的值 return String.valueOf(hssfCell.getBooleanCellValue()); } else if (hssfCell.getCellType() == Cell.CELL_TYPE_NUMERIC) { if (HSSFDateUtil.isCellDateFormatted(hssfCell)) { SimpleDateFormat sdf = null; if (hssfCell.getCellStyle().getDataFormat() == HSSFDataFormat.getBuiltinFormat("h:mm")) { sdf = new SimpleDateFormat("HH:mm"); } else {// 日期 sdf = new SimpleDateFormat("yyyy-MM-dd"); } Date date = hssfCell.getDateCellValue(); return sdf.format(date); } else if (hssfCell.getCellStyle().getDataFormat() == 58) { // 处理自定义日期格式：m月d日(通过判断单元格的格式id解决，id的值是58) SimpleDateFormat sdf = new SimpleDateFormat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/614982cfda6d78b345509afb7db68909/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6d72bd4c1c1d2d95cf3168ad19733b6/" rel="bookmark">
			如何将一个Android项目使用本地服务器运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这周在忙着课程设计，只忙了一个Android项目在本地运行的一个实践。
在实战开发中，一个项目的测试阶段不能用服务器的数据，因此，在做测试的时候一定要把项目绑定在本地服务器上，并且访问本地数据库。
在我做开发时候是基于eclipse下的Android项目，和myeclipse下的服务器端
环境是springMVC+mybatis+sql
主要在Android中更改IP为电脑动态网络IP
服务器端将数据库连接改为本地数据库，在运行Android项目时，先运行服务器
【在操作中遇到的错误】
1无法连接到服务器，但是，相同访问连接服务器端网络可以访问到数据
解决：关闭电脑防火墙
2手机端报错无法连接到网络
解决：手机不连接电脑WiFi，不用内网IP
3记住更改数据库权限
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8194f1c667b30758dcf1d4c4ed85dec/" rel="bookmark">
			安装Ubuntu时，提示“没有根文件系统 ”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装Ubuntu时，提示“没有定义根文件系统”
原因：分区错误
解决：
将Ubuntu分区，删除重新创建分区，注意挂载点为“/”
此时就可以单击“继续”，进行下一步安装
以上分区方式，是没有交换分区的，下面提供两种带交换分区的分区方式：
第一种，包含4个分区，分别为
/分区（大小：15G+）
交换空间分区 （大小：3G，根据硬盘大小，最大为内存的2倍，最小为512MB），类似于Windows的虚拟内存
/boot分区 （200MB）
/home分区 （剩下全部空间）
第二种，包含3个分区，分别为
/分区 （大小：15GB+）
交换空间分区 （大小：3G，根据硬盘大小，最大为内存的2倍，最小为512MB）
/home分区（剩下全部空间）
以第一种分区方式，分区过程：
1.创建/分区
2.创建交换空间分区
3.创建/boot分区
4.创建/home分区
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29617ee72ffac281f57f915636453d39/" rel="bookmark">
			华为机试——最小k个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入n个整数，输出其中最小的K个,算法复杂度为O(nlogk) #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;algorithm&gt; using namespace std; typedef multiset&lt;int,greater&lt;int&gt; &gt; intSet; typedef multiset&lt;int,greater&lt;int&gt; &gt;::iterator setIterator; void GetLeastKNumbers(const vector&lt;int&gt;&amp; data,intSet&amp; leastNumbers,int k) { leastNumbers.clear(); if(data.size()&lt;k||k&lt;1) return; vector&lt;int&gt;::const_iterator it=data.begin(); for(;it!=data.end();it++) { if(leastNumbers.size()&lt;k) leastNumbers.insert(*it); else { setIterator greatest=leastNumbers.begin(); if(*it&lt;*greatest) { leastNumbers.erase(greatest); leastNumbers.insert(*it); } } } } int main() { int n,k; int number; vector&lt;int&gt; data; intSet leastNumbers; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) { cin&gt;&gt;number; data.push_back(number); } cin&gt;&gt;k; GetLeastKNumbers(data,leastNumbers,k); for(setIterator it=leastNumbers.begin();it!=leastNumbers.end();++it) cout&lt;&lt;*it&lt;&lt;" "; cout&lt;&lt;endl; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63324b8417a8a52ee1f827ac3fbdb533/" rel="bookmark">
			Training Very Deep Networks
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章提出一种训练深层网络的训练结构-highway，主要的来源于LSTM中的阀门开关的思想。highway的提出使得可以使用梯度下降可以直接训练较深的卷积神经网络。
plain网络前向过程为：
其中H为非线性激活函数。对于highway网络来说在上述的基础上又引入了两个非线性变换T和C，则highway为：
其中T为transform gate，C为carry gate，T和C实际上是定义了最终的输出分别是由多少变换和输入构成。为了简单，可以另C=1-T：
使用就卷积进行表达为：
特殊情况为：
需要注意的是highway的定义方式要求H，T，x，y具有相同的维度。
plain网络于highway结构比较如下：
实验结果说明：plain网络要比highway难优化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/539c212a1a1a355a8ba7aa75ed7b0587/" rel="bookmark">
			Deep Residual Learning for Image Recognition
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Deep Residual Learning for Image Recognition中提出的152层网络结构在ILSRC 2015获得第一名，集成后的网络在ImageNet分类错误率3.57%，作者微软研究院的何凯明等。
上图中两条曲线分别为20层和56层的“plain”网络在训练集和测试集上的错误率，这里的“plain”是指一般的无环的“直流”卷积网络。按照以往的经验理论，网络越深应该有更好的分类效果，加大网络的深度是一种很有效的提高准确率的方法。但从上图中的曲线很明显是与这一结论相矛盾的，20层的网络无论是在训练集还是测试集上的错误率都比56层的要低。为了说明出现这一现象并不是因为梯度弥散或是膨胀导致的，所以在每一个卷积之后，ReLU之前 会使用bn层。对于深层的网络，有这样一个现象，算法开始是收敛的，但随着网络加深，准确略逐渐的下降，但并没有出现过拟合。所以说明出现这样的现象是因为优化出现问题。
这篇文章提出一种deep residual learning framework的结构，解决对于很深的网络的优化问题。这种结构主要受启发于LSTM和HighWay
这种结构有两个优点（1）比较容易优化（2）网络层数加深可以有更高的准确率。
这种short connection 实际上是卷积之后的output与input的逐点加和，这句就需要二者具有相同的维度，但是由于采样的原因使得很多时候并不能满足，通常有三种方法可以解决上述问题：
（A）使用zero-padding shortcuts增加维度，并且所有的shortcut是参数自由的（B）维度不同时使用projection shortcuts，相同时使用恒等变换x（C）完全使用projection shortcuts
实验验证三种方法的错误率为：
从结果可以看出B方法相较于A方法有一定的提升，但是C相对于B提升极少，但是计算量却增加很大，所以并不使用C方法。
对于上图中的两种结构identity shortcut有相似的时间复杂度。但是对于右侧的结构来说如果使用projection shortcuts计算量和模型大小相当于identity shortcut的二倍。所以identity shortcut对于这种bottleneck的设计来说是更好地。
这个实验说明resnet确实可以提高深度网络的准确率，使得网络优化的更好。
【注】这里需要注意一点的是，在这个网络结构中pool只出现了一次，使用的2步长的方法进行下采样。二者的最大的不同在于2步长的卷积虽然会使得output size 减小，但是由于卷积核大小为3，实际上每个像素点的信息都是利用到的，相较于pool来说带来的信息损失会比较小。并且在Google的rethink文章中也指出，在网络的前期尽量不要制造bottleneck，但频繁使用pool必然会增加这种信息的减少而出现bottleneck。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bb7e7475ee154c74ecb021c71e2d26a/" rel="bookmark">
			判断两个矩形是否重叠
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		判断两个矩形是否重叠 关于如何判断两个矩形重叠，这是我在实际项目开发当中曾经遇到过的问题：“判断图像中检测到的两个人脸框矩形是否有重叠部分，并计算重叠大小，从而确认是否为同一个人脸”。后来，在浏览博客时，也发现也有人将这个问题当做面试题目，并进行过讨论，但是，列出的代码过于繁杂，不敢恭维。所以，写下这篇博文，并贴出代码，供大家参考。
前提 两个矩形的边均与x轴或y轴平行，即轴对齐的矩形将第一个矩形记做A，第二个矩形记做B判断矩阵A与矩阵B是否重叠（边沿重叠也认为是重叠） 讨论 第一种方案，正向思维 按照一般的思路，先列举出所有的矩形重叠的情况，然后，判断是否是其中一种，如图所示，共有四种重叠情况，我们使用紫色代表矩形A，红色代表矩形B，并分别用p1,p2,p3,p4代表对应的左上角与右下角。如果依次判断，过于复杂，而且容易出错，这里我们不再进行代码实现。 第二种方案，反向思维 反向思考，我们不妨先解决出“不重叠”的情况，如图，我们画出了一个并怎么漂亮的图，看起来十分复杂，但是，实际上，相比第一种方案，更易表示。即B矩阵，可能在A的左侧、右侧、上侧、下侧。如果用公式表示，即 ( p2.y≤p3.y)∨(p1.y≥p4.y)∨(p2.x≤p3.x)∨(p1.x≥p4.x ) 则，两个矩阵重叠时，公式为 ¬[(p2.y≤p3.y)∨(p1.y≥p4.y)∨(p2.x≤p3.x)∨(p1.x≥p4.x)] 根据德·摩根定律可转换为 (p2.y&gt;p3.y)∧(p1.y&lt;p4.y)∧(p2.x&gt;p3.x)∧(p1.x&lt;p4.x) 解决方案 根据上述第二种情况分析，我们可以进行代码的实现，如下
#include &lt;iostream&gt; using namespace std; //矩阵位置坐标 typedef struct Rect { Rect(int x, int y, int width, int height) : x(x), y(y), width(width), height(height) {} int x; //矩形左上角x坐标 int y; //矩形左上角y坐标 int width; //矩形宽度 int height; //矩形高度 } Rect; /** * @brief 判断两个轴对齐的矩形是否重叠 * @param rc1 第一个矩阵的位置 * @param rc2 第二个矩阵的位置 * @return 两个矩阵是否重叠（边沿重叠，也认为是重叠） */ bool isOverlap(const Rect &amp;rc1, const Rect &amp;rc2) { if (rc1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bb7e7475ee154c74ecb021c71e2d26a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/502be49123cfa70e3b2e9e28df38c8ec/" rel="bookmark">
			text/html和text/plain的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		text/html和text/plain的区别 ps：本人亲测，阿里云2核4G5M的服务器性价比很高，新用户一块多一天，老用户三块多一天，最高可以买三年，感兴趣的可以戳一下：阿里云折扣服务器
1、text/html的意思是将文件的content-type设置为text/html的形式，浏览器在获取到这种文件时会自动调用html的解析器对文件进行相应的处理。
2、text/plain的意思是将文件设置为纯文本的形式，浏览器在获取到这种文件时并不会对其进行处理。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/466/">«</a>
	<span class="pagination__item pagination__item--current">467/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/468/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>