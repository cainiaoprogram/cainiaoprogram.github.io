<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3c68a09f71000c2690453ecab0c65c7/" rel="bookmark">
			java run方法完美写法_Java巧用lambda，异步方法优雅写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解lambda的基本原理
加入lambda之后，很多写法都变得简单起来，如创建一个线程对象，可以：
new Thread(new Runnable() {
@Override
public void run() {
System.out.print("Hello");
}
});
lambda写法:
new Thread(() -&gt; System.out.print("Hello"));
单独将lambda拎出来：
Runnable runnable = () -&gt; System.out.print("Hello");
其实lambda代表的就是一个接口的实现而已(匿名内部类)。而这种接口也叫函数式接口，会有@FunctionalInterface注解进行编译时检查。
或者直接把lambda看成一个方法，上述的 () -&gt; System.out.print("Hello") 就是代表一个无入参、无返回值的一个方法(等同于public void run() {System.out.print("Hello")})，而Runnable runnable则是指向这个方法(类似函数指针)，需要调用这个方法时，调用runnable.run()即可.
当有一个参数、无返回值则是Consumer
// 对printStream对象的void print(String s)方法的引用
PrintStream printStream = System.out;
Consumer consumer = printStream::print;
consumer.accept("Hello");
// 输出
Hello
对于有入参(一个或两个)、有返回值等情况，JDK也提供了对应的函数式接口：
接口
函数
说明
Consumer
void accept(T t)
无返回值、一个入参，T为入参类型
BiConsumer
void accept(T t, U u)
无返回值、两个入参，T为第一个入参类型、U为第二个入参类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3c68a09f71000c2690453ecab0c65c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff5024664df107bb9c6070147ee4ffb5/" rel="bookmark">
			java long scala_scala和java哪个运行速度快
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在spark时代，scala流行起来，有人认为scala比java好用，scala简单，简洁。觉得java比较繁琐，确实，在代码量上来说，确实如此，今天看了一些文档，发现其中的奥秘。
从代码量上来说
scala比java简洁
开发效率高于java，这是无可置疑的。
比如：
java的输出：System.out.println(“hello world”);
scala的输出： println(“hello world”)
2.两者都依赖jvm虚拟机
Scala程序必须要基于jvm，Scala是在Java的基础上开发实现的。所以要 将scala进行编译，然后交给jvm进行执行。
而java也是基于jvm,通过字节码编译，执行。
3.那么两者的执行快慢如何得出：
scala的底层是java，按说是java运行的快。
java代码 for
public class Demo1 {
public static void main(String[]args){
long start = System.currentTimeMillis();
int t = 0;
for (int i= 0; i&lt;= 100000;i++) {
t += i;
}
long end = System.currentTimeMillis();
System.out.println(end-start);
System.out.println(t);
}
}
结果为：
3
705082704
Process finished with exit code 0
可以看到java的运行确实很快。
再来看一下scala的两种方式：
一种是while 一种是for
首先看一下for循环
object Demo2 {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff5024664df107bb9c6070147ee4ffb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce193ff9ff52991063d796f68770067f/" rel="bookmark">
			java异常问题_10个关于Java异常的常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章总结了十个经常被问到的JAVA异常问题；
1.检查型异常VS非检查型异常
简单的说，检查型异常是指需要在方法中自己捕获异常处理或者声明抛出异常由调用者去捕获处理；
非检查型异常指那些不能解决的异常，如除0，空指针等；
检查型异常非常重要，因为你希望使用你API接口的人知道如何处理这些异常；
举个例子，IOException是非常常见的检查型异常，RuntimeException是非检查型异常；
Java的异常层级关系图如下：
2.异常管理最佳实践
如果一个异常当前能够被恰当的处理，那么应该捕获处理它，否则应该显示的抛出异常；
3.为什么在try代码块里定义的变量，在catch或finally代码块里不能被访问
如下代码，在try代码块中声明字符串s变量，但是不能在catch代码块中使用，代码不能编译通过；
try{
File file= new File("path");
FileInputStream fis= newFileInputStream(file);
String s= "inside";
}catch(FileNotFoundException e) {
e.printStackTrace();
System.out.println(s);
}
原因是因为你不知道在try代码块中的哪一句会抛出异常，很有可能这个异常在变量声明之前就抛出了；
这正是以上这个例子的情况；
注：强烈怀疑是因为作用域的关系导致s变量不可见；
4.为什么Integer.parseInt(null)和Double.parseDouble(null)会抛出不同的异常
这是JDK的问题，因为这两个方法是不同的开发人员写的，所以没必要深究；
Integer.parseInt(null);//throws java.lang.NumberFormatException: null
Double.parseDouble(null);//throws java.lang.NullPointerException
注：其实我目前的JDK7已经没有该问题了，两个都是抛出NumberFormatException
5.多用运行时异常
几个常见的运行时异常，如IllegalArgumentException、ArrayIndexOutOfBoundsException；
当判断条件不满足时，可以抛出这些异常，如下代码：
if (obj == null) {throw new IllegalArgumentException("obj can not be null");
6.是否可以在一个catch代码块里捕获多个异常
答案是可以的。因为JAVA的异常可以追溯到同一个父类Exception，我们可以使用父类捕获多个异常；
try{
}catch(Exception e) {//TODO: handle exception
}
补充：
在JAVA7中，增加了新语法，可以这样捕获多个异常：
try{
...
}catch( IOException |SQLException ex ) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce193ff9ff52991063d796f68770067f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3887015cbb2add6061ea705a9499e0e8/" rel="bookmark">
			java empty string_java.lang.NumberFormatException: empty String
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The code below keeps giving a java.lang.NumberFormatException: empty String:
private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {
double AText = Double.parseDouble(angleAField.getText());
double BText = Double.parseDouble(angleBField.getText());
double CText = Double.parseDouble(angleCField.getText());
double aText = Double.parseDouble(sideaField.getText());
double bText = Double.parseDouble(sidebField.getText());
double cText = Double.parseDouble(sidecField.getText());
if (getMissing(angleAField.getText()) == false &amp;&amp; getMissing(angleCField.getText()) == false) { //doesnt have angle C ,find Angle A
double angleA = Math.round(Math.asin((Math.sin(BText) / bText) * aText));
angleAField.setText("" + angleA);
}
}
public boolean getMissing(String Field) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3887015cbb2add6061ea705a9499e0e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b1e62b40314560765d7bc6d9fb92d9e/" rel="bookmark">
			js java 中文乱码_编码问题(.java/.jsp/.js等文件的中文乱码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		乱码的出现是因为编码与解码的不一致造成的，假如你对“中文”两个字进行了gbk格式的保存，却用utf-8格式的解读，是肯定会出现乱码的。
如何避免中文乱码：应用上下统一用一种编码格式。 utf-8或者gbk 建议用utf-8. 虽然占空间，但是通用性强，它属于国际编码格式。相反，gbk是国家级的。
下面简单说下以tomcat为容器的程序响应response的编码流程：
.java--.class
.jsp--.java--.class~~.html
.js--.js
.css--.css
编码涉及到的就这几种流程，而在程序响应中出现中文乱码也就中间的两种情况：
.jsp--.java--.class~~.html：
第一步 jsp的保存编码可以通过
第二步 然后通过某种(假设A)编码保存为.java(可以是任何编码，即使是ISO-8859，虽然可能出现中文乱码，但不碍事，因为用户看不到。该编码格式可能先参考tomcat的默认编码，如果没有设置可能参考操作系统的默认编码)，然后tomcat会继续用A编码读取；
第三步 接着走.class编译流程，类似.java。
最终，会生成html。而html的格式至关重要，它的格式是根据谁来的呢？ 有个优先顺序，第一 看response.setCharacterEncoding("UTF-8")是否进行设置 ，没有没则看看jsp中是否设置了
pageEncoding="utf-8"的格式进行保存。 (不同浏览器不一样) 而浏览器非常聪明，它根据响应头信息得到该html的保存编码，然后就用保存编码的编码格式去解码显示。 如图：
而我遇到的乱码情况是这样的：jsp的保存编码为pageEncoding="utf-8",而js的保存编码为gbk(通过eclipse可以看到)；当该html在浏览器中以utf-8的格式显示时，它的js也会以utf-8的解码格式去显示，这样 gbk-utf-8就出现乱码了。
解决方法一： 单独为该js设置 编码格式
解决方法二： 修改js的保存编码格式，可以把js复制到文本中，另存为utf-8。然后修改eclipse对js的默认编码为utf-8.window-general-content types -text-javascript,修改为utf-8，update---ok。最后再把文本中的utf-8格式的js复制到eclipse中。
到此，只是简单的描述了一下响应response的编码转换流程。 真正容易出现乱码的地方是 request请求。
request的中文请求乱码分三种情况：1.url参数请求 2.表单 post 参数请求 3.表单 get参数请求
无论哪种情况，在从客户端(浏览器)发送的时候，都采用浏览器的编码方式先编码，然后在服务端再用某一种编码来解码; 之所以出现乱码，是因为在客户端跟服务端所用的编码和解码格式不一致造成的。那么何为浏览器编码？ 可以通过(ie)页面-编码进行查看(注意如果你所浏览的页面是由frame构成的，那么你所看到编码为最外层页面的编码，并不一定是当前响应页面的编码《如果外层页面编码和当前响应页面的编码不一致》)。而当前浏览器编码，也就是当前响应页面的编码；如果你在A页面上再次发送请求，那么这次请求所用的编码即浏览器编码为上次响应A页面所用的编码，也就是浏览器展示A页面所用的编码(参考上面响应部分)。
那么，我们确定了浏览器端的编码，服务端解码是依据谁来决定解码格式呢？ 首先，表单post方式则通过request.setCharacterEncoding("UTF-8")来决定。ssh2，框架中一般配置有spring、strust2的中文过滤器。org.springframework.web.filter.CharacterEncodingFilter、 org.apache.struts2.dispatcher.FilterDispatcher。 一般情况，都是struts2的过滤器在最后，因为执行完struts2可能就不执行其他过滤器了而直接找对应的action。 CharacterEncodingFilter的格式直接在web.xml中配置，而FilterDispatcher则会取得struts2的默认编码struts.i18n.encoding=UTF-8(在strust2-core.jar下面的default.properties中)，如果你没有在struts.xml中设置struts.i18n.encoding的话。 这两个过滤器的作用都是设置request.setCharacterEncoding()；
其次，就是url和表单get方式了，他们针对不同的容器，做出的判断也是不一样的。下面以tomcat为例：
对于URL提交的数据和表单中GET方式提交的数据，在接收数据的JSP中设置request.setCharacterEncoding参数是不行的，因为在Tomcat5.0中，默认情况下使用ISO- 8859-1对URL提交的数据和表单中GET方式提交的数据进行重新编码(解码)，而不使用该参数对URL提交的数据和表单中GET方式提交的数据进行重新编码(解码)。要解决该问题，应该在Tomcat的配置文件的Connector标签中设置useBodyEncodingForURI或者 URIEncoding属性，其中useBodyEncodingForURI参数表示是否用request.setCharacterEncoding 参数对URL提交的数据和表单中GET方式提交的数据进行重新编码，在默认情况下，该参数为false(Tomcat4.0中该参数默认为 true)；URIEncoding参数指定对所有GET方式请求(包括URL提交的数据和表单中GET方式提交的数据)进行统一的重新编码(解码)的编码(不建议使用，可能影响到其他项目)。URIEncoding和useBodyEncodingForURI区别是，URIEncoding是对所有GET方式的请求的数据进行统一的重新编码(解码)(tomcat下的所有项目)，而useBodyEncodingForURI则是根据响应该请求的页面的request.setCharacterEncoding参数对数据进行的重新编码(解码)，不同的页面可以有不同的重新编码(解码)的编码。所以对于URL提交的数据和表单中GET方式提交的数据，可以修改 URIEncoding参数为浏览器编码或者修改useBodyEncodingForURI为true，并且在获得数据的JSP页面中 request.setCharacterEncoding参数设置成浏览器编码。
而weblogic服务器，网上给出说法需要在weblogic.xml中设置：
此方法可同时用于 GET 和 POST 操作。
input-charset
使用 元素定义用于读取 GET 和 POST 数据的字符集。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b1e62b40314560765d7bc6d9fb92d9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86e59ee7011d14ab55ae0b7558ace7dd/" rel="bookmark">
			java bison_antlr与bison的一些比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Antlr, @init, @after. 这个对于相似的逻辑处理可以避免重复的代码。
2. Bison, $1, @$, 不用定义一个变量，体现了script的方便性。
3. 优先级。Antlr以顺序来确定，bison依靠%left, %right定义，稍占优。不过bison的优先级只支持到token级别，不注意反而增加了疑惑。
4. AST的支持。其实即使没有工具本身的支持，用bison产生一个语法树还是不算困难的，比如通过一个stack维护parent节点。不过antlr毕竟直接支持并增加了redirection.
5. Channel特性。
6. 生成代码的可读性及可调试性。Antlr略好，不过毕竟还是会产生类似于 if ( (LA8_0==39) ) { alt8=1; }等自动临时变量。Bison 通过 #line 106 "../INPUT/src/xxx.yy"实现。想要观察比如$1的值需要额外处理。
7. shift/reduce warnning. 这个门槛比较高，在复杂逻辑中完全去除对于俺相当困难
8. @lexer/parser::members {}. 由于继承的关系，override的处理不够直观。也许工具能够克服这个缺点。
9. 出错处理。Java的异常处理和字符串比C++稍好，个人意见。Antlr还有脚本层面上的catch支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c69aa0e84509b832294611add07265d4/" rel="bookmark">
			java的requestmapping_@RequestMapping与@GetMapping和@PostMapping等新注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@RequestMapping与@GetMapping和@PostMapping等新注释
Spring的复杂性不是来自于它处理的对象，而是来自于自身，不断演进发展的Spring会带来时间维度上复杂性，比如SpringMVC以前版本的@RequestMapping，到了新版本被下面新注释替代，相当于增加的选项：
@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
@PatchMapping
从命名约定我们可以看到每个注释都是为了处理各自的传入请求方法类型，即@GetMapping用于处理请求方法的GET类型，@ PostMapping用于处理请求方法的POST类型等。
如果我们想使用传统的@RequestMapping注释实现URL处理程序，那么它应该是这样的：
@RequestMapping(value = "/get/{id}", method = RequestMethod.GET)
新方法可以简化为：
@GetMapping("/get/{id}")
如何工作？
所有上述注释都已在内部注释了@RequestMapping以及方法元素中的相应值。
例如，如果我们查看@GetMapping注释的源代码，我们可以看到它已经通过以下方式使用RequestMethod.GET进行了注释：
@Target({ java.lang.annotation.ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@RequestMapping(method = { RequestMethod.GET })
public @interface GetMapping {
// abstract codes
}
所有其他注释都以相同的方式创建，即@PostMapping使用RequestMethod.POST进行注释，@ PutMapping使用RequestMethod.PUT进行注释等。
使用方式
下面是结合RestController的简单使用：
@RestController
@RequestMapping("users")
public class UserController {
@Autowired
UserService userService;
@GetMapping("/status/check")
public String status()
{
return "working";
}
@GetMapping("/{id}")
public String getUser(@PathVariable String id)
{
return "HTTP Get was called"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c69aa0e84509b832294611add07265d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3adf2af6fbf87dd17434a8501ef66ca/" rel="bookmark">
			vue element menu侧边导航栏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;!--el-menu里的颜色是通过element定义的属性来设置的,css样式中没有相关样式--&gt; &lt;!--unique-opened 只摊开一个el-submenu,默认是弹开所有.这个属性依赖于submenu的index值,如果index值相同的会同时展开--&gt; &lt;!--router用来开启el-menu-item的路由模型,默认连接是index的值--&gt; &lt;el-menu background-color="#333744" text-color="#fff" active-text-color="#ffd04b" unique-opened router&gt; &lt;el-submenu index="1"&gt; &lt;!--index属性用于区别不同的submenu--&gt; &lt;template slot="title"&gt;&lt;!--slot属性表明该template是submenu的标题--&gt; &lt;i class="el-icon-location"&gt;&lt;/i&gt; &lt;!--添加左侧的小图标--&gt; &lt;span&gt;导航一&lt;/span&gt;&lt;!--添加标题名称--&gt; &lt;/template&gt; &lt;el-menu-item index="1-1"&gt;选项1&lt;/el-menu-item&gt;&lt;!--添加二级选项--&gt; &lt;el-menu-item index="1-2"&gt;选项2&lt;/el-menu-item&gt;&lt;!--添加二级选项--&gt; &lt;/el-submenu&gt; &lt;el-submenu index="2"&gt; &lt;template slot="title"&gt;&lt;!--slot属性表明该template是submenu的标题--&gt; &lt;i class="el-icon-location"&gt;&lt;/i&gt; &lt;!--添加左侧的小图标--&gt; &lt;span&gt;导航一&lt;/span&gt;&lt;!--添加标题名称--&gt; &lt;/template&gt; &lt;el-menu-item index="2-1"&gt;选项1&lt;/el-menu-item&gt;&lt;!--添加二级选项--&gt; &lt;el-menu-item index="2-2"&gt;选项2&lt;/el-menu-item&gt;&lt;!--添加二级选项--&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Home' } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 参考:
https://element.eleme.io/#/zh-CN/component/menu#ce-lan
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05d993ddaf198e7eaa59a3b07cfa545f/" rel="bookmark">
			go java web框架_为什么Go的web框架速度还不如Java？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web框架是IO密集型程序，包含HTTP协议的编解码，你可以理解为动态的字符串的处理，因为HTTP/1.1是文本类型的协议。还有JSON编解码，涉及到语言内的数据结构跟JSON之间的转换。还有跟数据库的交互，也是语言外部的IO操作。编译型语言的密集计算性能体现不出优势。
TechEmpower的Fortunes测试(select查询asort排序foreach输出HTML测试)来看, PHP底层基于Event扩展的workerman-pgsql(352,508)高于Go的fasthttp-quicktemplate(319,764),低于Go的fasthttp-prefork-quicktemplate(363,587). 但都处于一个性能级别.https://www.techempower.com/benchmarks/​www.techempower.com
特殊场景下，比如生成动态增长的不定长数量的大型字典，其中键名包含字符串连接和系统时间戳获取，PHP这类动态解释型语言反而比Go这种编译型语言还要快不少。网友提供的深度优化的Go代码对比PHP测试
网友深度优化的Go代码,依旧比最普通的PHP代码慢,内存占用两者相当,都是90MB左右.
所谓Go的开发效率和性能,在这次与PHP的较量中,有点像个笑话!
截图可见,这是一个一条命令直出同时cat显示源代码的对比测试,避免有人认为我作弊.
cat hash.go &amp;&amp; go build hash.go &amp;&amp; ./hash &amp;&amp; go version &amp;&amp; cat hash.php &amp;&amp; time php hash.php
测试环境是我的新的Linux笔记本,处理器是i7-8750H,所以要比第一张图里的i5-3230M快.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8bfa0a01fc326823661dfc1809dffed/" rel="bookmark">
			Java http请求设置代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.io.IOException; import java.security.KeyManagementException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.cert.CertificateException; import java.util.Map; import javax.net.ssl.SSLContext; import javax.net.ssl.TrustManager; import javax.net.ssl.X509TrustManager; import org.apache.http.HttpEntity; import org.apache.http.HttpHost; import org.apache.http.client.ClientProtocolException; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.config.Registry; import org.apache.http.config.RegistryBuilder; import org.apache.http.conn.socket.ConnectionSocketFactory; import org.apache.http.conn.socket.PlainConnectionSocketFactory; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClientBuilder; import org.apache.http.impl.client.HttpClients; import org.apache.http.impl.conn.DefaultProxyRoutePlanner; import org.apache.http.impl.conn.PoolingHttpClientConnectionManager; import org.apache.http.util.EntityUtils; public class HTTPProxy { public static SSLContext createIgnoreVerifySSL() throws NoSuchAlgorithmException, KeyManagementException { SSLContext sc = SSLContext.getInstance("SSLv3"); // 实现一个X509TrustManager接口，用于绕过验证，不用修改里面的方法 X509TrustManager trustManager = new X509TrustManager() { @Override public void checkClientTrusted( java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8bfa0a01fc326823661dfc1809dffed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07309a37a81f195e32a46e128c7607c1/" rel="bookmark">
			Docker快速搭建Clickhouse集群(3分片3副本)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 前文简单介绍了下Clickhouse的安装和客户端使用，在实际生产环境中，Clickhouse常常是以集群模式部署的，由于很多系统不满足sse4.2指令，这里使用docker来搭建一个Clickhouse的集群。
1. 环境说明 1.1 机器列表 机器名
IP
配置
操作系统
部署的服务
备注
server01
192.168.21.21
8c8g
centos7.3
clickhouserver（cs01-01）和
clickhouserver（cs01-02）
clickhouse01-01: 实例1, 端口: tcp 9000, http 8123, 同步端口9009, 类型: 分片1, 副本1
clickhouse01-02: 实例2, 端口: tcp 9001, http 8124, 同步端口9010, 类型: 分片2, 副本2 (clickhouse2的副本)
server02
192.168.21.69
8c8g
centos7.3
clickhouserver（cs02-01）和
clickhouserver（cs02-02）
clickhouse02-01: 实例1, 端口: tcp 9000, http 8123, 同步端口9009, 类型: 分片2, 副本1
clickhouse02-02: 实例2, 端口: tcp 9001, http 8124, 同步端口9010, 类型: 分片3, 副本2 (clickhouse3的副本)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07309a37a81f195e32a46e128c7607c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9855262295c47f5ba1b1f038fbe3bab6/" rel="bookmark">
			OBS Studio安装教程以及录制等详细配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前录制视频分别用了拍大师，爱剪辑，EV录屏和嗨格式录制大师，这几个要么导出收费，要么各种水印，讲道理，难道没一款免费的软件？有，Obs studio各大主播都在用的串流和录屏软件。
1.下载地址如下
https://obsproject.com/zh-cn/download 但是这个软件下载速度非常慢，还会经常下载失败，我们点击官网下面这个,使用种子下载，然后就能在迅雷很快速的下载了
2.下载完可能会提示环境缺少Microsoft Visual C++ 2019 Redistributable Package，当然点击链接跳转去下载的也是需要梯子的，这里我就直接百度搜了，然后去这里下载
https://patch.soft128.com/down/130697.html 下载安装完会提示重启（我没有重启，也没出问题）。
3.打开Obs studio，点击左上方文件-&gt;设置，简单设置下语言为中文（在通用）和输出的选项即可（我测试发现录像质量选无损好点，大小也不是很大，也很清晰，对比高清就不行很模糊）
4.设置快键，主要是开始录制和停止，暂停录制得快键，不冲突即可
5.选择底部得场景和来源，因为我是录制游戏视频，所以选的显示器，你们可以自取所需
6.然后按你设定得快捷键开启录制吧
画面黑屏得话
可以在下面两个链接找答案：
https://zhuanlan.zhihu.com/p/116884610 https://blog.csdn.net/wy_bk/article/details/90439112 如果Navid控制面板选集成图形还是黑屏，可以选高性能，我的电脑就是高性能才能显示，大家灵活点多尝试下即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/136617f4a92eacdb038faa643f915739/" rel="bookmark">
			Java 常用开发工具配置之Eclipse
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eclipse是常用IDE中的一款，历史悠久对于大多数Java程序员，人生的第一行代码想必就是由他编辑出来的，今天总结一下工作中经常使用到的配置。
一、插件类 本文介绍所有插件自动安装步骤：（以安装spotbugs为例，其他同理）
Spotbugs：顾名思义，定位bugs的一款插件，在我们编写完代码之后可以选择一个文件、一个文件夹或者项目进行筛除bug。
安装方式：
选择工具栏Help–&gt;Eclipse Marketplace 如图
输入spotbugs，回车结果如图 点击install进行安装，下一步如图
选择I accept the terms of the license agreement，点击finished即可。
二、propedit 将国际化文件中的Unicode转换成中文
选择工具栏Help–&gt;Install New Software–&gt;add
http://propedit.sourceforge.jp/eclipse/updates/
以下为手动安装：
1.SVN 这是一款源代码控制插件，它允许你从 SVN 下载代码并从 Eclipse 执行所有与 SVN 相关的操作。
SVN下载地址
安装方式：
解压，解压后目录：将features目录下所有文件复制到，eclipse或myeclipse安装目录下对应的features文件夹下，例如我本地的目录 ：D:\Program Files\eclipse noen\features 注：如提示是否覆盖，选择覆盖将plugins目录下所有文件复制到，eclipse或myeclipse安装目录下对应的plugins文件夹下，例如我本地的目录：D:\Program Files\eclipse noen\plugins 注：如提示是否覆盖，选择覆盖使用方法：（以eclipse为例myeclipse同理）
在eclipse 工具栏Window–&gt;Show View–&gt;Other 选项中输入svn，结果如下图
选择SVN资源库,点击Open；
在弹出SVN资源库窗口右键选择，新建–&gt;资源库位置，输入svn地址即可。 2.OpenExplore OpenExplore是一款实现在eclipse中，将选中的文件在文件资源管理显示的插件。
Open Explore 下载地址
安装方式：
将上面地址中文件下载下来后解压将OpenExplorer_1.5.0.v201108051513.jar 复制到eclipse安装目录dropins文件夹下，例如我本地安装路径：D:\Program Files\eclipse sts\dropins重启eclipse，选中文件右键菜单栏中就会出现Open Explore选项效果如图
后续会持续更新其他常用插件 二、配置 1.编码相关配置 智能提示：工具栏 Window–&gt;Preferences–&gt;Java–&gt;Editor–&gt;Content Assist
输入：26位英文字母即abcdefghijklmnopqrstuvwxyz，点击Apply。
自动格式化代码：即进行保存操作后将代码自动格式化。
工具栏 Window–&gt;Preferences–&gt;Java–&gt;Editor–&gt;Save Actions
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/136617f4a92eacdb038faa643f915739/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ea403823ad38d9e9601ad8e67172572/" rel="bookmark">
			RVEA：参考向量引导多目标优化进化算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RVEA：参考向量引导多目标优化进化算法 参考文献
《A Reference Vector Guided Evolutionary Algorithm for Many-Objective Optimization》
要点
本文提出了一种参考向量引导多目标优化进化算法。参考向量不仅可以用于将原始的多目标优化问题分解为多个单目标子问题，而且可以阐明用户偏好，以针对整个Pareto前沿的首选子集作为目标。在提出的算法中，采用了一种称为角度惩罚距离的标量化方法来平衡高维目标空间中解的收敛性和多样性。提出了一种自适应策略，根据目标函数的尺度动态调整参考向量的分布。 一、介绍
本文的主要贡献如下：
一种标量化方法，称为角度惩罚距离（APD），旨在根据目标数和世代数在多目标优化中动态平衡收敛和多样性。在提出的APD中，收敛标准是通过候选解与理想点之间的距离来衡量的，而多样性准则是通过候选解与参考向量之间的锐角来衡量的。注意，如果参考向量用于表示用户偏好，则该角度还指示用户偏好的满意度。提出了一种自适应策略来调整参考向量，以处理未很好归一化的目标函数。自适应策略根据不同目标函数的范围来调整参考向量的分布，以确保即使目标函数没有很好地归一化或PF的几何结构高度不对称，候选解也可以在目标空间中均匀分布是高度不对称的。该策略主要用于获得均匀分布的帕累托最优子集。结果表明，参考向量还可以提供一种高效的和计算有效的方法来表达偏好。这种偏好表达在多目标优化中特别有价值，因为在这种情况下很难获得整个PF的代表性近似值。通过指定中心向量和半径，我们提出了一种基于参考向量的偏好表达方法，该方法能够在目标空间的偏好区域中生成均匀分布的帕累托最优解。问了提高RVEA在不规则PF问题的性能，提出了一种参考向量再生成策略。基本思想是使用额外的参考向量集在目标空间中进行探索，以便提高由RVEA获得的具有不规则PF问题的解的密度。 二、背景
参考向量
在不失一般性的前提下，本文中使用的所有参考向量均为第一象限内的单位向量，其原点为起始点。从理论上讲，这样的单位向量可以通过将任意向量除以其范数轻松生成。但是，实际上，对于目标空间的均匀分布的覆盖范围，需要均匀分布的单位参考向量。为了产生均匀分布的参考向量，我们采用[A multiobjective evolutionary algorithm using Gaussian process-based inverse modeling]中介绍的方法。首先，使用规范的单纯形格设计方法在单元超平面上生成一组均匀分布的点。
其中i = 1，…，N，其中N为均匀分布点的数量，M为目标数，H为单纯形格设计的正整数。然后，通过变换可以得到相应的单位参考向量vi。
该图将参考点从一个超平面映射到一个超球面，其示例如图所示。根据单纯形晶格设计的性质，给定H和M，总数为N =(H + M-1, M-1)个均匀分布的参考向量。
单纯形格
给定两个向量v1和v2，两个向量之间的锐角θ的余弦值可用于测量它们之间的空间关系，其计算公式为
||·||计算范数，表示向量长度。
三、提议的RVEA
主框架
A、子代生成
采用模拟二项交叉（SBX）和多项式突变来创建子代种群。没有用任何明确的交配选择策略。N个个体中每个个体都有相同的概率参与繁殖过程。参考向量选择策略可以有效地管理目标空间的小子空间内的收敛性和多样性，从而使每个子空间内的个体都可以对总体做出同样的贡献。 B、参考向量引导选择
RVEA使用参考向量将目标空间划分为多个子空间，并且在每个子空间内分别执行选择。
参考向量引导选择包括四个步骤：
目标值转换种群划分APD计算精英选择 a)目标值转换
本文中的参考向量的起始点始终是坐标原点，将种群Pt中的个体的目标值F(t)={f(t1), f(t2), …, f(t|Pt|)}转换为F’(t)，通过以下方法：
其中zmin(t)=(zmin(t, 1), zmin(t, 2), …, zmin(t, m))表示根据F(t)计算的最小目标值。
转换操作的作用是：
确保转换后的目标值都在第一象限内，其中每个目标函数的极点在相应的坐标轴上，从而最大程度地覆盖了参考向量。将理想点设置为坐标系原点。 b)种群划分
目标值转换后，通过将每个个体与其最近的参考向量相关联，将种群Pt划分为N个子种群。
如图，两个向量的空间关系通过两个向量之间的锐角来测量
即目标向量和参考向量之间的余弦值可以计算为：
子种群划分
C、APD距离
一旦将种群Pt划分为N个子种Pt1，Pt2，…，PtN，就可以从每个子种群中选择一位精英，为下一代创建Pt+1。
由于我们的动机是在最接近理想点的每个参考向量上找到解，因此选择标准包括两个子条件，即对于候选解相关联的参考向量而言，收敛标准和多样性标准。
用||f’||衡量收敛性标准，用θ衡量多样性标准，为了平衡两者之间的关系，APD距离定义为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ea403823ad38d9e9601ad8e67172572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ffc9bb72a6ebf3dac01d0199229ab77/" rel="bookmark">
			Ubuntu Server 20.04 设置静态 IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一步：查看网卡设备号 输入命令ip addr或ip a确认要修改静态ip的网卡号：
第二步：修改 yaml 文件 执行命令：vim /etc/netplan/xxx.yaml将里面的内容按如下格式修改：
代码：
network: ethernets: ens33: #配置的网卡的名称 addresses: [172.16.85.130/24] #配置的静态ip地址和掩码 dhcp4: no #关闭DHCP，如果需要打开DHCP则写yes optional: true gateway4: 172.16.85.2 #网关地址 nameservers: addresses: [8.8.8.8,8.8.4.4] #DNS服务器地址，多个DNS服务器地址需要用英文逗号分隔开 version: 2 renderer: networkd #指定后端采用systemd-networkd或者Network Manager，可不填写则默认使用systemd-workd 注意：
ip 地址和 DNS 服务器地址需要用[]括起来，但是网关地址不需要每个冒号后边都要先加一个空格每一层前边的缩进，至少比上一层多两个空格 第三步：让配置生效 sudo netplan apply 验证：使用ip addr查看效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fea7a9eb9704133bc0cf57876d30fc4a/" rel="bookmark">
			React学习笔记6：React Hooks API总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		useState-保存状态（惰性初始化） 作用 函数组件添加状态 注意事项 初始化以及更新state用来声明状态变量 使用步骤（使用useState来创建状态） 引入import React,{useState} from "react"接收一个参数作为初始值返回一个数组，第一个值为状态，第二个为改变状态的函数 useEffect-解决副效应 只要是副效应，都可以使用useEffect()引入。
useEffect，就是执行有副作用的操作，默认情况下，它在第一次渲染之后和每次更新之后都会执行。 可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount这三个函数的组合。
作用/用途
给没有生命周期的组件，添加结束渲染的信号获取数据事件监听或订阅改变DOM输出日志 注意事项
在render之后执行使用useEffect()时，如果有多个副效应，应该调用多个useEffect()，而不应该合并写在一起。 使用步骤
引入import React,{useEffect} from "react"接收一个函数作为参数接收第二个参数（依赖列表），只有依赖更新时，才会执行函数返回一个函数。先执行返回函数，再执行参数函数 示例
import React, { useState, useEffect } from 'react' function EffectFunction() { const [num, setNum] = useState(1) //以下函数先输出1，再输出2 useEffect(() =&gt; { console.log("2") document.body.addEventListener('todo', () =&gt; { }) return () =&gt; { document.body.removeEventListener('todo', () =&gt; { }) console.log("1") } }, [num]) return ( &lt;div onClick={() =&gt; setNum(num =&gt; num + 1)}&gt; 这是一个函数组件-{num} &lt;/div&gt; ) } export default EffectFunction useLayoutEffect-监测DOM 作用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fea7a9eb9704133bc0cf57876d30fc4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de008631c7cb8b4c0783c9c7a5a52cc0/" rel="bookmark">
			Js 获取对象属性个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、方法一 var attributeCount = function(obj) { var count = 0; for(var i in obj) { if(obj.hasOwnProperty(i)) { // 建议加上判断,如果没有扩展对象属性可以不加 count++; } } return count; } var testObj = { name1: "value1", name2: "value2" }; alert(attributeCount(testObj)); // 2 二、方法二 function TestObj(name, age) { this.name = name, this.age = age } TestObj.prototype.proCount = function() { var count = 0 for(pro in this) { if(this.hasOwnProperty(pro)) { // 这里扩展了对象,所以必须判断 count++; } } return count; } var testObj = new TestObj('名称', 12); alert(testObj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de008631c7cb8b4c0783c9c7a5a52cc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c1bddd9ebebd41c65f372594054e68a/" rel="bookmark">
			Java8collection.sort_Collections.sort()源码分析(基于JAVA8)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java.lang.Object java.util.Collections简介
此类仅包含操作或返回集合的静态方法。
它包含多样的对集合进行操作的算法，“包装器”，返回由指定集合支持的新集合，以及其他一些细碎功能。
如果提供给它们的集合或类对象为null，则此类的方法都抛出NullPointerException
该类中包含的多态算法的文档通常包括实现的简要说明 。 这些描述应被视为实现说明 ，而不是说明的一部分 。 只要规范本身得到遵守，实现者就可以随意替代其算法。 (例如，sort使用的算法不一定是一个mergesort，但它必须是稳定的 算法)
如果集合不支持适当的突变原语，例如set方法，则该类中包含的“破坏性”算法，即修改其操作的集合的算法被指定为抛出UnsupportedOperationException。 如果调用对集合没有影响，这些算法可能但不是必须抛出此异常。 例如，在已经排序的不可修改列表上调用sort方法可以抛出UnsupportedOperationException
Collections的sort方法代码：
一
二
&gt; 表示该方法中传递的泛型参数必须实现了Comparable中的compareTo(T o)方法，否则进行不了sort排序
其sort方法实现都委托给了java.util.List接口的默认实现的sort方法
方法细节奏：
(1)将list转换成一个Object数组
(2)将这个Object数组传递给Arrays类的sort方法(也就是说Collections的sort本质是调用了Arrays.sort)
(3)完成排序之后，再一个一个地，把Arrays的元素复制到List中
注意到sort有一个条件判断，当LegacyMergeSort.userRequested==true，采用legacyMergeSort
否则采用ComparableTimSort
LegacyMergeSort.userRequested的字面意思大概就是“用户请求传统归并排序”，这个分支调用的是与jdk5相同的方法来实现功能。
ComparableTimSort是改进后的归并排序，对归并排序在已经反向排好序的输入时表现为O(n^2)的特点做了特别优化。对已经正向排好序的输入减少回溯。对两种情况(一会升序，一会降序)的输入处理比较好(摘自百度百科)。legacyMergeSort代码：
泛型版
mergeSort代码
①：对dest[]排序，传递过来的List list也就排好了序，src[]数组用做中介，即后面的方法需要调用，这里有个判断条件为length &lt; INSERTIONSORT_THRESHOLD
INSERTIONSORT_THRESHOLD为Arrays的一个常量7，它定义了如果数组元素小于7用插入排序
②：当数组元素不小于7，
先将数组拆分成低区间和高区间
再调用两个递归对区间元素排序。在递归时注意还会判断已划分区间元素是否还不少于7，如果不小于7继续划分成两个区间，这样循环递归调用
特别注意src[]和dest[]的参数位置，调用递归时，是将src[]数组作为排序对象进行排序，src[]排序后，在通过③或④方法将dest[]数组依据src进行排序。最终达到List list排序的结果。
③：如果初始元素个数不小于7进过②方法后，只有两种情况：两个排好序的低区间和高区间。这个方法作用是：如果低区间列表中的最高元素小于高区间列表中的最低元素，则表明该次递归循环的区间段已经排好序，然后将这段数据复制到dest[]数组中。
反之则进入方法④
④：进入该方法表明该次递归循环的左区间最大元素大于右区间最小元素，也就是说左区间的数组元素值都大于高区间的数组元素值，因此将src中的高区间元素和低区间元素调换放入dest数组中。这样一次递归循环就调用完毕，如果还有循环就继续排序下去，否则排序就已经完成。
TimSort.sort()/*
* The next method (package private and static) constitutes the
* entire API of this class.
*/
/**
* Sorts the given range, using the given workspace array slice
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c1bddd9ebebd41c65f372594054e68a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8ec6dae8c78cef114fe1a52feb64d4b/" rel="bookmark">
			Java8collection.sort_java8的新特性，Collections.sort(排序的List集合)的使用，对list封装Map里面的某个值进行排序...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		--------------------------对简单list的排序----------------------------------
List list = new ArrayList&lt;&gt;();
list.add(1);
list.add(2);
list.add(3);
list.add(4);
Collections.sort(list)
排序前是：
1
2
3
3
排序后：
4
3
2
1
------------------------------------------------------------------
----------------------------对list封装Map里面的某个值进行排序-------------------------------------
List&gt; mapList = new ArrayList&gt;();
Collections.sort(mapList,new Comparator&gt;() {
//降序排序
public int compare(Map o1, Map o2) {
double s = Double.parseDouble(o1.get("dist").toString());　//由于从map里面取出来的值为Object类型，无法直接转换为Integer类型，需要转换为double
double d = Double.parseDouble(o2.get("dist").toString());
Double D1 = new Double(s); //由于double类型无法直接转换为Integer类型，需要用封装类先封装double
Double D2 = new Double(d);
Integer s1 = D1.intValue();　//使用Double的intValue方法转换为Integer类型
Integer s2 = D2.intValue();
//使用Entry类中的值来比较大小
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8ec6dae8c78cef114fe1a52feb64d4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73d85b53fd3884428d8d140e7ad75283/" rel="bookmark">
			VS Code mac “检测到#include错误。请更新includePath。”的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近vs code里Java和C一起写，但有的时候会出现“检测到#include错误。请更新includePath。”的问题，在csdn上看了很多解决方法好像没卵用…自己的解决方法如下：
前提条件 报错内容为“检测到#include错误。请更新includePath。”
打开Finder -&gt; Macintosh HD -&gt; Library -&gt; Developer -&gt; CommandLineTools -&gt; usr -&gt; lib，看看里面有没有名叫clang文件夹。如果没有，以下解决方案可以使用；如果有，该解决方法不适用。 解决方法 打开terminal输入 xcode-select --install 等待安装安装完后回到Finder -&gt; Macintosh HD -&gt; Library -&gt; Developer -&gt; CommandLineTools -&gt; usr -&gt; lib看是否有clang文件夹。如果有的话，继续下一步。进入clang文件夹，clang -&gt; 版本号 -&gt; include，右键点Get Info -&gt; 复制Where的内容返回vs code，用快捷键command+P查找名为“c_cpp_properties.json”的文件将第五步复制的内容加上“/include”粘贴至"includePath"下 "includePath":[ "${粘贴内容/include}/**" ] command+S返回之前的代码，确认是否能运行。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f53365c126a074ed7dc4a05a4597086/" rel="bookmark">
			java中sort排序函数_java中Collections.sort排序函数用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Comparator是个接口，可重写compare()及equals()这两个方法,用于比价功能；如果是null的话，就是使用元素的默认顺序，如a,b,c,d,e,f,g，就是a,b,c,d,e,f,g这样，当然数字也是这样的。
compare(a,b)方法:根据第一个参数小于、等于或大于第二个参数分别返回负整数、零或正整数。
equals(obj)方法：仅当指定的对象也是一个 Comparator，并且强行实施与此 Comparator 相同的排序时才返回 true。
Collections.sort(list, new PriceComparator());的第二个参数返回一个int型的值，就相当于一个标志，告诉sort方法按什么顺序来对list进行排序。
具体实现代码方法如下：
Book实体类：
package com.tjcyjd.comparator;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.GregorianCalendar;
import java.util.Iterator;
import java.util.TreeMap;
/**
* 书实体类
*
* @author yjd
*
*/
public class Book implements Comparable { // 定义名为Book的类，默认继承自Object类
public int id;// 编号
public String name;// 名称
public double price; // 价格
private String author;// 作者
public GregorianCalendar calendar;// 出版日期
public Book() {
this(0, "X", 0.0, new GregorianCalendar(), "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f53365c126a074ed7dc4a05a4597086/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/932ba2d0a5a9e27ab7d14952efe3430d/" rel="bookmark">
			java heap space怎么解决_java heap space错误的解决方法是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java heap space错误的解决方法是：1、设置环境变量，代码为【set JAVA_OPTS= -Xms32m -Xmx512m】；2、在执行JAVA类文件时加上相关参数，参数为【java -Xms32m -Xmx800m cl】。
java heap space错误的解决方法是：
1、设置环境变量set JAVA_OPTS= -Xms32m -Xmx512m
可以根据自己机器的内存进行更改,但本人测试这种方法并没有解决问题。可能是还有哪里需要设置。
2、java -Xms32m -Xmx800m className
就是在执行JAVA类文件时加上这个参数，其中className是需要执行的确类名。(包括包名)
这个解决问题了。而且执行的速度比没有设置的时候快很多。
如果在测试的时候可能会用Eclispe 这时候就需要在Eclipse -&gt;run -arguments 中的VM arguments 中输入-Xms32m -Xmx800m这个参数就可以了。相关学习推荐：java基础
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ac9bb6b04d392921de574dc3a1149ca/" rel="bookmark">
			java 调用其他线程_java 后台接口另起一个线程执行其他业务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接post代码，然后在详细介绍为什么：
packagecom.xxx.testset.service.impl;import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;/***
* @function xxx接口实现类
*@authorLiangjw
* @date 2019-9-18 下午02:09:33
*@version*@sinceJDK 1.7*/
public class TestSetServiceImpl extends BizServiceImpl implementsTestSetService {ExecutorService executorService= Executors.newSingleThreadExecutor();...
@OverridepublicString startTest(String testId) {final String test_Id =testId;
Connection con=DBConnectUtil.getConnection();
PreparedStatement pstmt= null,pstmt2 = null;
ResultSet resultSet= null;try{
Date nowDate= newDate();final String nowDateStr =DateUtil.dateTransformStr(nowDate, DATE_FORMAT);
Map map = new HashMap();
map.put("TEST_ID", testId);//获取检测装置集---2020年7月10日16:40:44 ljw
final List deviceList = this.getDao().queryForDataSet(STATEMENT_KEY + "selectPdDetectionDevice", map).getResults();
map.put("TEST_STATE", "检测中");
map.put("BEGIN_TIME", nowDateStr);//获取当前机具表中第一条数据，补充到检测任务中---2020/07/02 ljw
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ac9bb6b04d392921de574dc3a1149ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb8dcd4dc793050657cc1c0fe6257931/" rel="bookmark">
			java迭代器删除元素_java迭代器中删除元素的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们知道通过Iterator，可以对集合中的元素进行遍历。那么在其中遇到我们不需要的元素时，可不可以在遍历的时候顺便给删除呢？答案是当然可以。在Iterator下有一个remove函数，专门用于删除的操作。下面我们就remove进行讲解，然后对删除元素方法进行说明，最后带来实例的展示。
1.Iterator中的remove
void remove()：删除迭代器刚越过的元素
从基础集合中移除这个迭代器返回的最后一个元素(可选操作)。两个线程中都删除，保证线程的同步。
2.删除元素说明
(1)迭代器遍历方式， 适用于连续内存存储方式，比如数组、 ArrayList(其实 ArrayList底层实现也是数组形式)。 缺点是只能从头开始遍历， 优点是可以边遍历边删除
(2)arraylist每次遍历的时候会去判断该集合是否被修改过，调用的方法是checkForComodification()。 如果被修改过ConcurrentModificationException异常。
(3)如何判断是否修改呢，主要是通过维护2个变量来实现，modCount记录了修改次数，expectedModCount记录期望修改次数。 通过iterator.remove()进行的删除操作，会同时修改modCount、ConcurrentModificationException; 而通过list.remove(object/index)，则只会修改modCount。 这也是fast-fail机制
3.删除实例Iterator it=list.iterator();
while(it.hasNext()){
Object e=it.next();
if("b".equals(e)){
it.remove();
}
}
System.out.println(list);
以上就是java迭代器中删除元素的操作，当我们在遍历集合时就可以一同完成，不必等待遍历结束再执行。这样的方法可以说是很方便的，小伙伴们赶紧学起来吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/315adc8b7914555a453c0b9249b2f02f/" rel="bookmark">
			java集合类实现原理_Java 集合类实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自:http://blog.csdn.net/qq_25868207/article/details/55259978
ArrayList是List接口的可变数组非同步实现，并允许包括null在内的所有元素。
底层使用数组实现
该集合是可变长度数组，数组扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量增长大约是其容量的1.5倍，这种操作的代价很高。
采用了Fail-Fast机制，面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险
LinkedList实现原理要点概括
LinkedList是List接口的双向链表非同步实现，并允许包括null在内的所有元素。
底层的数据结构是基于双向链表的，该数据结构我们称为节点
双向链表节点对应的类Node的实例，Node中包含成员变量：prev，next，item。其中，prev是该节点的上一个节点，next是该节点的下一个节点，item是该节点所包含的值。
HashMap实现原理要点概括
HashMap是基于哈希表的Map接口的非同步实现，允许使用null值和null键，但不保证映射的顺序。
底层使用数组实现，数组中每一项是个单向链表，即数组和链表的结合体；当链表长度大于一定阈值时，链表转换为红黑树，这样减少链表查询时间。
HashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Node对象。HashMap底层采用一个Node[]数组来保存所有的key-value对，当需要存储一个Node对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Node时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Node。
HashMap进行数组扩容需要重新计算扩容后每个元素在数组中的位置，很耗性能
采用了Fail-Fast机制，通过一个modCount值记录修改次数，对HashMap内容的修改都将增加这个值。迭代器初始化过程中会将这个值赋给迭代器的expectedModCount，在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map，马上抛出异常
Hashtable实现原理要点概括
Hashtable是基于哈希表的Map接口的同步实现，不允许使用null值和null键
底层使用数组实现，数组中每一项是个单链表，即数组和链表的结合体
Hashtable在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。Hashtable底层采用一个Entry[]数组来保存所有的key-value对，当需要存储一个Entry对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。
synchronized是针对整张Hash表的，即每次锁住整张表让线程独占
ConcurrentHashMap实现原理要点概括
ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。
它使用了多个锁来控制对hash表的不同段进行的修改，每个段其实就是一个小的hashtable，它们有自己的锁。只要多个并发发生在不同的段上，它们就可以并发进行。
ConcurrentHashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。Hashtable底层采用一个Entry[]数组来保存所有的key-value对，当需要存储一个Entry对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。
与HashMap不同的是，ConcurrentHashMap使用多个子Hash表，也就是段(Segment)
ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。
HashSet实现原理要点概括
HashSet由哈希表(实际上是一个HashMap实例)支持，不保证set的迭代顺序，并允许使用null元素。
基于HashMap实现，API也是对HashMap的行为进行了封装，可参考HashMap
LinkedHashMap实现原理要点概括
LinkedHashMap继承于HashMap，底层使用哈希表和双向链表来保存所有元素，并且它是非同步，允许使用null值和null键。
基本操作与父类HashMap相似，通过重写HashMap相关方法，重新定义了数组中保存的元素Entry，来实现自己的链接列表特性。该Entry除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而构成了双向链接列表。
LinkedHashSet实现原理要点概括
对于LinkedHashSet而言，它继承与HashSet、又基于LinkedHashMap来实现的。LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承与HashSet，其所有的方法操作上又与HashSet相同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0e72fe4f2cbfdf26673b3c5e3f91d02/" rel="bookmark">
			java接口能被实例化吗_java的接口为什么不能实例化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java的接口为什么不能实例化呢？首先，我们需要明白实例化的含义。实例化实际意义是在jvm的堆中开辟出一块内存空间，比如Student s = new Student();此处声明Student对象s，并且实例化一个Student对象，实则是在堆中开辟出一块空间来存放Student对象，s则是指向这块空间，也就是内存中的一块地址。这块地址中所存放的值就是我们这个Student对象的一些属性。
具体类所占用的内存空间(也就是堆里的一块地址)所存放的值是类的成员变量，这里插入一张图便于我们理解：
图中可以看到，栈中存放的是per，值是堆中具体Person这个对象的地址，也就是per指向这个具体类的引用。而堆中一块地址，存放的值是Person这个类的成员变量(局部变量在执行时存放在栈中)。
那么换做一个接口呢？假设我们可以new出一个接口，那么这个接口就会占用堆中的一块地址，那么我们想想接口的这块地址上能够存放什么值呢。
说到这个首先要清楚接口中允许有什么：静态的属性以及方法声明。这里再说明下，java的内存空间分为四类：栈(stack)、堆(heap)、代码(code)、静态数据(data)。由此可见接口中所有的东西的具体值都是存放在代码去和静态数据区的，所以接口的这块地址上并没有任何实际的值需要存储，那么为什么要给他一块地址来浪费空间呢。其实用底层代码在内存中开辟出一块空间很容易，那么为什么java设定不允许接口实例化呢，以我的理解而言，那就是接口的实例化没有任何实际意义，只会占用一块内存空间，却不会在这块空间中放任何实际的值，所以java主动去规避掉了这个问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1658bd20792fb2480d0c764ae3bccbaa/" rel="bookmark">
			php代码转java代码_PHP代码转成java代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function bter_query($path, array $req = array()) {
// API settings, add your Key and Secret at here
$key = '';
$secret = '';
// generate a nonce to avoid problems with 32bits systems
$mt = explode(' ', microtime());
$req['nonce'] = $mt[1].substr($mt[0], 2, 6);
// generate the POST data string
$post_data = http_build_query($req, '', '&amp;');
$sign = hash_hmac('sha512', $post_data, $secret);
// generate the extra headers
$headers = array(
'KEY: '.$key,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1658bd20792fb2480d0c764ae3bccbaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ead0a6597c6c027a538bf2a3e460ddc5/" rel="bookmark">
			java解析yaml_YAML配置文件解析器：SnakeYAML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇blog主要是讨论：
如何使用SnakeYAML来读取YAML(YML为其简写)配置文件；
读取后，装载成Map，而Map如何存储的配置文件的数据。
SnakeYAML的简介
SnakeYAML是针对java语言的YAML解析器。如果想更多的了解SnakeYAML和YMAL，请看blog：
如何读取YAML配置文件
请看代码：
FileInputStream fileInputStream = null;
try {
Yaml yaml = new Yaml();//实例化解析器
File file = new File("inscriber-s\\src\\main\\resources\\application.yml");//配置文件地址
fileInputStream = new FileInputStream(file);
Map map = yaml.loadAs(fileInputStream, Map.class);//装载的对象，这里使用Map, 当然也可使用自己写的对象
//printMap(map, 0);
}catch(FileNotFoundException e) {
log.error("文件地址错误");
e.printStackTrace();
}finally {
try {
if(fileInputStream!=null) fileInputStream.close();
}catch (IOException e){
e.printStackTrace();
}
}
Map是如何存储的配置文件数据
以下面的.yml配置文件为例：
# mybatis
mybatis:
type-aliases-package: info.ideatower.component.inscriber.entity
mapper-locations: classpath:mapping/*.xml
config-locations: classpath:mybatis-config.xml
# 应用组件通信等配置
component:
misso:
log:
addr: http://localhost:8009
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ead0a6597c6c027a538bf2a3e460ddc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f618d12febf9efc88ba0909c5f55ff46/" rel="bookmark">
			java解析yaml_Java解析Yaml格式数据工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Yaml数据示例：
--- !ruby/hash:ActionController::Parameters
title: "测试这是一句文本文案，看看你的问题是否已经解决了呢？"
options:
- !ruby/hash:ActionController::Parameters
option_name: "已经解决了"
option_select: 'false'
- !ruby/hash:ActionController::Parameters
option_name: "还没解决呢"
option_select: 'true'
Yaml解析工具类：
import org.yaml.snakeyaml.Yaml;
import java.util.Map;
/**
* @author P.H
* @date 2019/12/25 10:25
* @description Yaml解析
*/
public class YamlUtil {
public static MapparseYaml2Map(String str){
Yaml yaml = new Yaml();
return (Map)yaml.load(cleanYaml(str));
}
private static String cleanYaml(String yamlText) {
String tmpText = yamlText.replaceAll("^---.*\n", "---\n");
tmpText = tmpText.replaceAll("!ruby.*\n", "\n");
return tmpText;
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f618d12febf9efc88ba0909c5f55ff46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6b8589636a7f94196b36e289a701728/" rel="bookmark">
			js java 乱码_js和java 中文乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为在jsp中对中文进行了编码的时候用的是UTF-8的编码方式，而在servlet中调用request.getParameter();方法的时候使用服务器指定的编码格式自动解码一次，所以前台编码一次后台解码一次而解码和编码的方式不用所以造成了乱码的出现；
解决方法一：
window.self.location="searchbytext.action?searchtext="+encodeURIComponent(encodeURIComponent(seartext));
searchtext=java.net.URLDecoder.decode(searchtext,"UTF-8");
为什么要两次编码的原因：后台java代码给searchtext赋值的时候，本身已经使用了一次解码，不过解码的结果依然不对。所以我们可以在页面上进行两次编码操作，这样后台自动的那次就可以抵消掉一次，然后在使用searchtext=java.net.URLDecoder.decode(searchtext,"UTF-8");进行一次解码就好了。
(ps:不行就多转几次 多试几次 这个就是一个坑
fileNameTemp= java.net.URLDecoder.decode(fileNameTemp,"UTF-8");
//System.out.println(fileNameTemp);
fileNameTemp= java.net.URLDecoder.decode(fileNameTemp,"UTF-8");
)
解决方法二：
另外还有一种方法是JavaScript进行一次编码，后台java处理时换种想法就好了：
java代码：
String s = new String(request.getParameter("name").getBytes("ISO8859-1"), "UTF-8");
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44f67cac468c53161144d3ba8e95e6cd/" rel="bookmark">
			java kafka 消费_java实现Kafka的消费者示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用java实现Kafka的消费者
表示的是：consumer间隔多长时间在zookeeper上更新一次offset
说明：
为什么使用High Level Consumer？
有些场景下，从Kafka中读取消息的逻辑不处理消息的offset，仅仅是获取消息数据。High Level Consumer就提供了这种功能。
首先要知道的是，High Level Consumer在ZooKeeper上保存最新的offset(从指定的分区中读取)。这个offset基于consumer group名存储。
Consumer group名在Kafka集群上是全局性的，在启动新的consumer group的时候要小心集群上没有关闭的consumer。当一个consumer线程启动了，Kafka会将它加入到相同的topic下的相同consumer group里，并且触发重新分配。在重新分配时，Kafka将partition分配给consumer，有可能会移动一个partition给另一个consumer。如果老的、新的处理逻辑同时存在，有可能一些消息传递到了老的consumer上。
设计High Level Consumer
使用High LevelConsumer首先要知道的是，它应该是多线程的。消费者线程的数量跟tipic的partition数量有关，它们之间有一些特定的规则：如果线程数量大于主题的分区数量，一些线程将得不到任何消息
如果分区数大于线程数，一些线程将得到多个分区的消息
如果一个线程处理多个分区的消息，它接收到消息的顺序是不能保证的。比如，先从分区10获取了5条消息，从分区11获取了6条消息，然后从分区10获取了5条，紧接着又从分区10获取了5条，虽然分区11还有消息。
添加更多了同consumer group的consumer将触发Kafka重新分配，某个分区本来分配给a线程的，从新分配后，有可能分配给了b线程。
关闭消费组和错误处理
Kafka不会再每次读取消息后马上更新zookeeper上的offset，而是等待一段时间。由于这种延迟，有可能消费者读取了一条消息，但没有更新offset。所以，当客户端关闭或崩溃后，从新启动时有些消息重复读取了。另外，broker宕机或其他原因导致更换了partition的leader，也会导致消息重复读取。
为了避免这种问题，你应该提供一个平滑的关闭方式，而不是使用kill -9
上面的java代码中提供一种关闭的方式：
在shutdown之后，等待了5秒钟，给consumer线程时间来处理完kafka stream里保留的消息。
附件列表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76d9c43d7a63ff0419a948823fb6d439/" rel="bookmark">
			java ssh 上传_java ssh 上传文件至服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java ssh 上传文件至服务器
@(JAVA)[上传文件至服务器]
private File upload; // 得到上传的文件
private String uploadContentType; // 得到文件的类型
private String uploadFileName; // 得到文件的名称
//省略get,set方法
private static final String LUN_WEN_ZHUAN_ZHU = "lun_wen_zhuan_zhu";
private static final String FILE_SEPARATOR = File.separator;
private static final String BASE_ATTACH_DIR = "attached";
public void jQueryFileUpload() throws Exception {
String dirName = this.request.getParameter("dir");
final String maxSizeStr = this.request.getParameter("maxSize");
final String customFileName = this.request.getParameter("customFileName");
final int maxSize = StringUtils.isNotEmpty(maxSizeStr) ? Integer.valueOf(maxSizeStr) : 500 * 1024 * 1024;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76d9c43d7a63ff0419a948823fb6d439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26c8b8a60a51ebab7434d5a17638b92a/" rel="bookmark">
			java class.forname_java 中的class.forName()是什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
Class.forName() 是指返回的是一e68a84e8a2ad62616964757a686964616f31333366306437个类。class.forName()，可以通过反射来操作这个类，例如获取属性，获取方法等等。
class.forName是用到了java.lang.Class.forName包的方法，他是通过类的全称来返回一个类，全称是指包名称加类名称，他是通过jvm来加载的，这样就可以获取到这个类了。
Class.forName是用到了java.lang.Class.forName包的方法，全称是指包名称加类名称，是通过jvm来加载的。过jvm就可以获取到这个类，也可以通过反射来操作这个类，例如获取属性，获取方法等等。这种方式在框架中比较常见。
jvm在装载类时会执行类的静态代码段，要记住静态代码是和class绑定的，class装载成功就表示执行了静态代码，而且以后不会再执行这段静态代码。
扩展资料：
用法示例：
class c = Class.forName(“Example”);
factory = (ExampleInterface)c.newInstance();
其中ExampleInterface是Example的接口，可以写成如下形式：
String className = “Example”;
class c = Class.forName(className);
factory = (ExampleInterface)c.newInstance();
进一步可以写成如下形式：
String className = readfromXMlConfig;//从xml 配置文件中获得字符串
class c = Class.forName(className);
factory = (ExampleInterface)c.newInstance();
上面代码已经不存在Example的类名称，它的优点是，无论Example类怎么变化，上述代码不变，甚至可以更换Example的兄弟类Example2 , Example3 , Example4……，只要他们继承ExampleInterface就可以。
Class.forName()用法详解：
Class.forName(xxx.xx.xx)返回的是一个类。Class.forName(xxx.xx.xx)的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段。
当一个class被加载，或当加载器(class loader)的defineClass()被JVM调用，JVM 便自动产生一个Class 对象。
如果想借由“修改Java标准库源码”来观察Class 对象的实际生成时机(例如在Class的constructor内添加一个println())，这样是行不通的！因为Class并没有public constructor。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10645dd9fd2345628f615a6fb4f086c2/" rel="bookmark">
			java string分割_java 字符串分割的三种方法(总结)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在项目中遇到一个小问题，一个字符串分割成一个数组，类似String str=”aaa,bbb,ccc”; 然后以”,”为分割符，将其分割成一个数组，用什么方法去实现呢？
第一种方法：
可能一下子就会想到使用split()方法，用split()方法实现是最方便的，但是它的效率比较低
第二种方法：
使用效率较高的StringTokenizer类分割字符串，StringTokenizer类是JDK中提供的专门用来处理字符串分割子串的工具类。它的构造函数如下：
public StringTokenizer(String str,String delim)
str是要分割处理的字符串，delim是分割符号，当一个StringTokenizer对象生成后，通过它的nextToken()方法便可以得到下一个分割的字符串，再通过hasMoreTokens()方法可以知道是否有更多的子字符串需要处理。这种方法的效率比第一种高。
第三种方法：
使用String的两个方法—indexOf()和subString()，subString()是采用了时间换取空间技术，因此它的执行效率相对会很快，只要处理好内存溢出问题，但可大胆使用。而indexOf()函数是一个执行速度非常快的方法，
原型如下：
public int indexOf(int ch) 它返回指定字符在String对象的位置。如下：
举例：
"ab&amp;&amp;2"以&amp;分割成"ab" "2"
String tmp = "ab&amp;&amp;2";
String splitStr = null;
int j = tmp.indexOf("&amp;"); // 找分隔符的位置
splitStr = tmp.substring(0, j); // 找到分隔符，截取子字符串
tmp = tmp.substring(j + 2); // 剩下需要处理的字符串
System.out.println(splitStr);
System.out.println(tmp);
ab
2
以上这篇java 字符串分割的三种方法(总结)就是小编分享给大家的全部内容了，希望能给大家一个参考，也希望大家多多支持脚本之家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0b966f81225131faf8241b2da6fb987/" rel="bookmark">
			用java语言编写石头剪刀布获胜法,剪刀石头布Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I'm new to programming and I'm trying to write a very simple Rock, Paper, Scissors game in Java. It will compile and run fine, but I am looking to say something like "Invalid move. Try again." or something along those lines for when the user (personPlay) does not enter a correct character (r, p, or s). What would be the best way to do so? For example, if you enter a "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0b966f81225131faf8241b2da6fb987/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bb722d714494d9603cab89a106ccb86/" rel="bookmark">
			启用mysql数据库.bat_常用数据库启动服务bat脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一台机器上同时装有oracle ,sqlserver 2005 , mysql,apache,iis,tomcat
等的服务搞得机器比牛还慢,于是从services.msc
里把这些服务全设成了手动启动,而每次启动其中一个服务都要运行services.msc有些麻烦,切有时候切换还挺频的.于是呼,写了以下脚本.共享如下:
@echo off
:dosmenu
REM 选择菜单
echo
#**********************************************************************#
echo Windows 服务启动脚本 made by
qukunping 20080101 echo
#**********************************************************************#
echo 命令相关参数说明如下 快速切换
echo
#**********************************************************************#
echo.
echo [1]启动mysql [2]关闭mysql
echo [3]启动sqlserver2005 [4]关闭sqlserver2005
echo [5]启动oracle [6]关闭oracle 其它键退出本程序
echo.
echo
#**********************************************************************#
set /P CHS= 请选择: [1],[2],[3],[4],[5],[6]?
if /I "%CHS%"=="1" (
goto aaaa
)
if /I "%CHS%"=="2" (
goto bbbb
)
if /I "%CHS%"=="3" (
goto cccc
)
if /I "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bb722d714494d9603cab89a106ccb86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae89931faca5f16b6d932a276ef621a5/" rel="bookmark">
			zabbix mysql 脚本路径_Zabbix安装图文教程(需要LAMP或者LNMP运行环境)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：
操作系统：CentOS
IP地址：192.168.21.127
Web环境：Nginx+MySQL+PHP
zabbix版本：Zabbix 2.2 LTS
备注：Linux下安装zabbix需要有LAMP或者LNMP运行环境
准备篇：
一、Web环境：Nginx+MySQL+PHP
二、zabbix软件包下载
上传zabbix-2.2.6.tar.gz到服务器/usr/local/src目录下面
安装篇
一、创建、导入zabbix数据库
cd /usr/local/src #进入软件包下载目录
tar zxvf zabbix-2.2.6.tar.gz #解压
cd /usr/local/src/zabbix-2.2.6/database/mysql #进入mysql数据库创建脚本目录
ls #列出文件，可以看到有schema.sql、images.sql、data.sql这三个文件
mysql -u root -p #输入密码，进入MySQL控制台
create database zabbix character set utf8;#创建数据库zabbix，并且数据库编码使用utf8
insert into mysql.user(Host,User,Password) values('localhost','zabbix',password('123456')); #新建账户zabbix，密码123456
flush privileges; #刷新系统授权表
grant all on zabbix.* to 'zabbix'@'127.0.0.1' identified by '123456' with grant option; #允许账户zabbix能从本机连接到数据库zabbix
flush privileges; #再次刷新系统授权表
use zabbix #进入数据库
source /usr/local/src/zabbix-2.2.6/database/mysql/schema.sql #导入脚本文件到zabbix数据库
source /usr/local/src/zabbix-2.2.6/database/mysql/images.sql #导入脚本文件到zabbix数据库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae89931faca5f16b6d932a276ef621a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e67d4cae59f47f779cfc85113494daa1/" rel="bookmark">
			Mac 下 Homebrew 安装的正确方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Mac 下 Homebrew 安装的正确方法 很多小伙伴会遇到mac下安装Homebrew报错的情况，给一个方法你试过就知道
/bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/233c110b1429390f078ba8631ae54767/" rel="bookmark">
			python量化交易通达信_通达信交易策略,通达信量化交易
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容导航：
Q1：通达信交易策略公式 满足gg后出现aa卖出
DIF:=EMA(CLOSE,12)-EMA(CLOSE,26);
DEA:=EMA(DIF,9);
MACD:=(DIF-DEA)*2;
两个条件用and？那是同时满足。 大于号小于号？ 你要的是“满足gg后出现aa”。
满足gg后多少天？ 要有个时间限制。
Q2：怎样编程可以让通达信程序化交易？
问题提得很专业,可是能回答的人不专业.
Q3：有什么好用的股票策略平台？
股票程序化交易策略的话，首推金字塔，最早的股票程序化交易策略平台，其次是文华财经，从期货市场发展到证券市场的。如果不是要求程序化交易的话，可以考虑通达信，界面简洁 速度快；其次是大智慧、东方财富、同花顺等。
可以关注我，有问题可以继续交流。
Q4：想做一个通达信股票全自动程序化交易程序，求帮助。
以前有老美也有这样想的 但是 没有一个成功的 他们用当时最好的 大型计算机组 用程序买卖股票
但是没有成功
除了出现真正的 人工智能 否则 按程序规则 弄出的结果 是注定失败的
别浪费时间了 股票市场最大的变数是人心 退一万步讲 你怎么设定人心的程序？
Q5：请问(通达信)交易系统公式怎么编写啊，谢谢大家啦。
你的条件不够严谨，按你说的做了一个。看过公式后，继续把你的条件补上！
MA5:MA(CLOSE,5);
MA10:MA(CLOSE,10);
MA30:MA(CLOSE,30);
MA60:MA(CLOSE,60);
AA:=CROSS(C,MA30) AND C
BB:=CROSS(C,MA60) AND C&gt;MA30;
CC:=CROSS(MA30,C) AND MA30&gt;MA60;
DD:=CROSS(MA60,C) AND MA30
DRAWTEXT(AA,L*0.98,'B'),COLORRED;
DRAWTEXT(BB,L*0.99,'●'),COLORRED;
DRAWTEXT(CC,H*1.02,'●'),COLORGREEN;
DRAWTEXT(DD,H*1.02,'S'),COLORGREEN;
Q6：通达信交易系统公式使用
功能---选股器----条件选股
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad975b74dad2e1011cf57939d84381fb/" rel="bookmark">
			自定义内置非root用户镜像制作方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(注：本文以rancher环境中部署应用操作为例)
1.在环境中的任意一worker节点上创建一个文件夹，如test
mkdir -p test
2.在文件夹中用vi命令生成一个新的文件，文件名为Dockerfile，内容如下：
FROM docker.io/centos:7.9.2009#基础镜像来源
MAINTAINER tangmeng#镜像制作者
RUN adduser testuser#添加新用户信息
RUN echo “testuser:testuser” | chpasswd#为新用户修改密码
3.利用命令生成新镜像，如生成一个名为testimage:v1.0的镜像,在当前文件夹下执行以下命令（注意命令以英文句点结束）
docker build -t testimage:v1.0 .
4.通过docker image |grep testimage 命令可以查看到生成的新镜像
5.验证应用“以非root用户运行容器”功能是否生效
a.部署一个新的应用，镜像名为:testimage:v1.0
b.进入应用的pod命令行执行命令：id testuser 来查看此用户的id及用户组id，如：1000
c.编辑应用，打开“以非root用户运行容器”选项，在命令-用户id和用户组id处埴写前面查到的id值 ，如1000
d.再次进入应用的pod命令行中执行命令whoami,可以查看到当前登录用户为：testuser
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e002e0c0efe2db18dd41acc1db0bdbd3/" rel="bookmark">
			相互关注互粉mysql实现_用MySQL实现微博关注关系的方案分析(转)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于产品需求的需要，我们做的产品里要实现类似微博里的关注关系。本文是以MySQL为基础，分析用MySQL如何实现微博的关注关系，对理解关注关系有一定的意义。
关注关系产生的四种关系状态
关注
粉丝
双向关注(互粉)
无关系
用词follower表示粉丝 – 追随者
用词following表示关注 – 追随
设计的结构必须能满足以下功能：
查询关注列表
查询粉丝列表
查询双向关注列表
判断两个用户的关系
查询带关系状态的任一列表
第一种方案
用一行纪录表示关注和粉丝，字段u2的值表示粉丝，u1表示被关注者。
Table: user(用户表)
Table: follower(u2表示粉丝， u1表示被关注的人)
查询用户id = 1的关注列表
SELECT * FROM follower WHERE u2 = 1
查询用户id = 1的粉丝列表
SELECT * FROM follower WHERE u1 = 1
查询用户id = 1的双向关注列表
SELECT t1.* FROM (SELECT * FROM follower WHERE u2 = 1) AS t1 INNER JOIN follower t2 ON t1.u1 = t2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e002e0c0efe2db18dd41acc1db0bdbd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/973aefaebeba798c3f947936e86f5ca3/" rel="bookmark">
			IBIS详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IBIS是Input/Output buffer information specification的缩写，从名字中可以看出，模型的主要作用是描述器件输出输出的特性。
简单来说，有IBIS模型比没有模型，仿真结果会更为准确。
在IBIS出现之前，仿真主要依靠SPICE模型，由于SPICE模型规模庞大，通常仿真都非常耗时，且提供SPICE模型存在泄密的风险。而IBIS并不考虑IC内部的电路，只关注输入输出部分，因此不会泄露厂商的知识产权，且可以将仿真时间压缩一到两个数量级，大大提高效率。
IBIS模型最初由EDA软件公司，IC厂商，以及一些大学研究机构发起，目前成员众多：
相比于它的历史以及未来的发展，我们更关心IBIS模型到底包含了哪些内容。
这里我们用一个ISSI的DDR颗粒为例，看看IBIS中有哪些信息：
IBIS模型的后缀为.ibs，可以用专门的IBIS查看软件打开，也可以用记事本打开。
模型中用****号隔开的内容为备注，不包含被仿真软件实际使用的信息。
IBIS模型第一部分是头文件信息，包含了IBIS模型的版本号，文件名，日期，厂商等。
第二部分信息主要描述器件的物理特性，以及模型信息。
其中Package为封装上的RLC寄生参数，这个值分为三个部分，分别是典型值，最小值，最大值，用来模拟不同的仿真情景。
这部分还有各个引脚所对应的模型名称，以及该引脚的RLC信息（部分IBIS模型不会提供具体到某个引脚的RLC）。
比如在上图中，可以得出器件封装上的PIN A2，这个PIN的功能是DQ，使用的模型为I/O。
如果有差分，我们还能看到差分的信息（这部分也并不是标配）：
在这个环节的最后部分是关于模型的描述，比如一个I/O模型，就对应了多种输入输出的状态，这些我们是可以在仿真时选择进行设置的。
第三部分则是对第二部分中模型的详细描述，以上图中的第一个模型FULL_ODT0为例。最前面的部分是描述模型整体的一个电压特性，同时还可以从C_comp中获得该引脚的Die电容信息。
接着是最重要的I/V曲线与V/T曲线，这些曲线在IBIS模型中以坐标点的方式进行表达。
其中I/V曲线有四个，分别是Pulldown、Pullup、GND Clamp、POWER Clamp。这些曲线表示器件的静态特性，其测量方法为施加一定的电压值后，测得的电流值。
V/T曲线则相对更容易理解，表达的是信号在上升、下降沿电压和时间的关系。
这些数据由于是坐标点，很难直观的获得有用的信息。我们可以用IBIS Development Studio这个软件，将文本描述的信息转变为图形。
在这部分中还有一个参数是Ramp，这里对信号的边沿时间做了一个简单的总结，可以直观的看出信号的边沿时间，稍微留意一下，可以看见Ramp是被*****所包裹的，所以这个信息只是给我们看的，仿真并不会用这个信息，而是用上面的曲线。
以上就是IBIS模型的大体内容。IBIS初版协议自1993年发布以来，一直在不停的修订和完善协议，目前最新版本为2019年3月15日发布的7.0版本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/518ce30f7c86968661eb26bc26644f0f/" rel="bookmark">
			python中ix用法_Python:Pandas中的ix用法详细解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		终于弄懂了Pandas中ix()函数的用法了。首先生成一个数据框
import numpy as np
import pandas as pd
df = pd.DataFrame(np.arange(0,60,2).reshape(10,3),columns=list('abc'))
df
输出的数据框是这个样子的
a b c
0 0 2 4
1 6 8 10
2 12 14 16
3 18 20 22
4 24 26 28
5 30 32 34
6 36 38 40
7 42 44 46
8 48 50 52
9 54 56 58
可以看到索引index为0，1，2…9，列标签columns name为a,b,c
df.ix[:,:]
print(df)
#输出结果为数据的所有行和列
a b c
0 0 2 4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/518ce30f7c86968661eb26bc26644f0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a5d42e517ce5126c365c5fe8ed7edad/" rel="bookmark">
			maven依赖传递（直接、间接依赖）、解决依赖冲突（排除依赖、版本锁定dependencyManagement）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、maven依赖传递（直接、间接依赖） 二、解决依赖冲突（排除依赖、版本锁定dependencyManagement） 最常用：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0edf3127893db0246b2d907e02ada8e3/" rel="bookmark">
			deeplabv3&#43;系列之deeplabv3网络搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用paddlepaddle2.0版本实现deeplabv3网络搭建。 基于paddlepaddle2.0版本的搭建。最近飞桨2.0版本出来啦！也挺好用的，所以就参考一些其他版本的代码，用paddlepaddle2.0版本重新写一下deeplabv3+ResNet网络。这篇文章为deeplabv3中ASPP等模块的搭建，以及整合前面的ResNet网络，骨干网络部分可以看上一篇文章deeplabv3+系列之ResNet骨干网络
原论文地址：Rethinking Atrous Convolution for Semantic Image Segmentation
paddlepaddle2.0版本安装教程
一.deeplabv3模块（参考飞桨七日图像分割打卡课程搭建的） 二.可直接运行的代码： ## layers ## 一些子层 import paddle import paddle.nn as nn import paddle.nn.functional as F class ConvBNReLU(nn.Layer): def __init__(self, in_channels, out_channels, kernel_size, padding='same', **kwargs): super().__init__() self._conv = nn.Conv2D( in_channels, out_channels, kernel_size, padding=padding, **kwargs) self._batch_norm = SyncBatchNorm(out_channels) def forward(self, x): x = self._conv(x) x = self._batch_norm(x) x = F.relu(x) return x class ConvBN(nn.Layer): def __init__(self, in_channels, out_channels, kernel_size, padding='same', **kwargs): super().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0edf3127893db0246b2d907e02ada8e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae0b545b15455fda7060b8ff75965da6/" rel="bookmark">
			决策树系列(四)——基于决策树算法实现员工离职率预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基于决策树算法实现员工离职率预测一、引入工具包二、数据加载三、数据预处理3.1 重复值处理3.2 缺失值处理3.3 异常值处理 四、特征选择4.1 删除明显无关特征4.2 查看数值型特征相关性4.3 类别型特征探索性分析 五、特征工程类别型特征转换 六、模型训练6.1 切分特征和标签6.2 样本不均衡问题6.3 切分训练集和测试集6.4 模型训练6.5 模型评估6.6 使用网格搜索寻找最优参数对模型进行优化6.7 使用最优参数建立模型 七、待补充 基于决策树算法实现员工离职率预测 问题描述：
我们有员工的各种统计信息，以及该员工是否已经离职，统计的信息包括了（工资、出差、工作环境满意度、工作投入度、是否加班、是否升职、工资提升比例等）现在需要你来通过训练数据得出 员工离职预测，并给出你在测试集上的预测结果。
数据集地址：https://www.kaggle.com/c/rs6-attrition-predict/data
数据说明：
训练数据和测试数据，保存在train.csv和test.csv文件中。训练集包括1176条记录，36个字段，字段说明如下：
字段说明字段说明user_id用户ID，无意义特征MaritalStatus员工婚姻状况，Single单身，Married已婚，Divorced离婚Age员工年龄MonthlyIncome员工月收入，范围在1009到19999之间Attrition员工是否已经离职，Yes表示离职，No表示未离职MonthlyRate员工月收入BusinessTravel商务差旅预测，Non-Travel不出差，TravelRarely不经常出差，TravelFrequently经常出差NumCompaniesWorked员工曾经工作过的公司数DailyRate平均每日工资Over18年龄是否超过18岁Department员工所在部门，Sales销售部，Research &amp; Development研发部，HumanOverTime是否加班，Yes表示加班，No表示不加班DistanceFromHome公司跟家庭住址的距离，从1到29，1表示最近，29表示最远PercentSalaryHike工资提高的百分比Education员工的教育程度，从1到5，5表示教育程度最高PerformanceRating绩效评估EducationField员工所学习的专业领域RelationshipSatisfaction关系满意度，从1到4，1表示满意度最低，4表示满意度最高EmployeeCount雇员人数StandardHours标准工时EmployeeNumber工号StockOptionLevel股票期权水平EnvironmentSatisfaction员工对于工作环境的满意程度，从1到4，1的满意程度最低，4的满意程度最高TotalWorkingYears总工龄Gender员工性别，Male表示男性，Female表示女性TrainingTimesLastYear上一年的培训时长，从0到6，0表示没有培训，6表示培训时间最长HourlyRate每小时收入WorkLifeBalance工作与生活平衡程度，从1到4，1表示平衡程度最低，4表示平衡程度最高JobInvolvement员工工作投入度，从1到4，1为投入度最低，4为投入度最高YearsAtCompany在目前公司工作年数JobLevel职业级别，从1到5，1为最低级别，5为最高级别YearsInCurrentRole在目前工作职责的工作年数JobRole工作角色YearsSinceLastPromotion距离上次升职时长JobSatisfaction工作满意度，从1到4，1代表满意度最低，4代表最高YearsWithCurrManager跟目前的管理者共事年数 评分标准：AUC
一、引入工具包 import pandas as pd import numpy as np import matplotlib.pyplot as plt import seaborn as sns from sklearn.tree import DecisionTreeClassifier from sklearn.model_selection import train_test_split,cross_val_score from sklearn.metrics import roc_auc_score from imblearn.over_sampling import SMOTE from sklearn.model_selection import GridSearchCV 二、数据加载 data = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae0b545b15455fda7060b8ff75965da6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5753175e414e456f8272009d3098815/" rel="bookmark">
			java方法的自动调用问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java方法的自动调用问题 背景 经常在java里面看到某些方法被自动调用（除了构造函数以外的方法），我们并没有主动的使用
Class.方法()去调用方法，而是直接new一个类的时候方法就被调用了，其实最终原因还是该类的父类或者父类的父类里面的构造函数调用了该方法，而这个方法在子类中是通过重写父类的方法的方式去实现的
实例 如上图：
子类重写了父类的方法父类的构造函数调用了该方法 当new一个子类对象时，它首先会执行父类的构造函数(因为没有重写父类的构造函数)，而父类的构造函数中调用了say()方法，程序就会去执行这个say()方法，子类又重写了say()方法，因为这里是new的一个子类对象，执行的就是子类的say()方法，那么在我们看来(不看父类的情况下),就感觉是在子类中new一个对象时，直接调用了子类的say()方法
总结 Java中当只是new一个对象时，只有静态代码块（静态方法并不会被自动执行）和构造函数以及父类的构造函数会被自动执行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85536447173f538f5f7581adb2600806/" rel="bookmark">
			abaqus与matlab联合仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		abaqus与matlab联合仿真 取材于2020.11的资料，文档整理于2021.2.7
引：启动abaqus license 如果运行abaqus报错如下图：
则点击abaqus licensing，选择第四个【Start/Stop/Reread】，点击第一个按钮【Start Server】，下方显示框中显示【Server Start Successful.】，再次打开abaqus ACE即可，如果还是报错就再开一次。
abaqus licensing界面：
正常打开的abaqus提示框：
联合编程思路 注：本文所用的接口函数runabaqus.m、get_history_output.m、odbHistoyOutput.py与这篇博客相同。
一、abaqus中完成有限元建模，得到模型文件，进行一次仿真，得到自动生成的.inp文件。
​ 具体建模方法在前两篇博客里已有详细描述。
二、matlab调用abaqus引擎进行仿真
根据需要的参数修改.inp文件
选本次模型用abaqus仿真时自动生成的.inp文件作为初始文件进行修改比较省事。一般是根据要求修改载荷力和分析步长，注意matlab代码中的具体修改的是inp文件的哪行要打开inp文件进行确认，改错行结果肯定凉凉。
根据需要读取的结果设置req.txt
%e.g. req='PART-1-1,Node PART-1-1.11,U2'; %指定部件名，节点名和读取的结果 部件名即inp文件中的实例名*Instance, name=Part-1-1, part=Part-1，每个inp文件内容会略有差别，我这个在第51行。节点名一定要大写，不管你在abaqus里命名的大写还是小写这里都必须大写。
matlab调用abaqus引擎的接口runabaqus.m，提交inp文件运行，得到.odb结果文件。
matlab调用python脚本odbHistoyOutput.py，根据req.txt的要求，从.odb文件中读取仿真结果数据并存入结果txt。
matlab读取结果txt中的数据并绘图。
利用matlab调用abaqus引擎获取变载荷的仿真过程变量（例如端点位移量）的原理是，多次调用abaqus进行仿真，每次只仿真分析步长的时间，获取本次仿真中最后一个时刻变量值，再进行下一次仿真。例如仿真时长为 0.4 s 0.4s 0.4s，分析步长为 0.01 s 0.01s 0.01s，则要进行 0.4 / 0.01 = 40 0.4/0.01=40 0.4/0.01=40次仿真。两次仿真之间可以通过修改inp文件修改载荷力，即可实现变载荷力仿真，如正弦载荷。
所以运行一次仿真的时间都比较长，需要根据仿真结果调pid参数的时候可以酌情减少仿真时长阶节约时间，毕竟pid参数好不好前两次超调的一小段就已经能说明很多问题了。
报错：未找到匹配的文件。 我进行软体手指的受力位移仿真时，报错：
&gt;&gt; finger Abaqus License Manager checked out the following license(s): "cae" release 6.12 from DESKTOP-8I4F446 &lt;1022 out of 1024 licenses remain available&gt;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85536447173f538f5f7581adb2600806/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd9699c4533cd2214f3173f3524be8bc/" rel="bookmark">
			用mysql查询图书的信息_PHP&#43;MySQL 利用mysql_fetch_row模糊查询图书信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 代码
td{
font-size:9pt;
}
.style2 {color: #FFFFFF}
应用mysql_fetch_row()函数从数组结果集中获取信息 请输入图书名称 编号图书名称出版时间图书定价作者出版社$link=mysql_connect("localhost","root","root") or die("数据库连接失败".mysql_error());
mysql_select_db("db_database13",$link);
mysql_query("set names gb2312");
$sql=mysql_query("select * from tb_book");
$row=mysql_fetch_row($sql);
if ($_POST[Submit]=="查询"){
$txt_book=$_POST[txt_book];
$sql=mysql_query("select * from tb_book where bookname like '%".trim($txt_book)."%'"); //如果选择的条件为"like",则进行模糊查询
$row=mysql_fetch_row($sql);
}
if($row==false){ //如果检索的信息不存在，则输出相应的提示信息
echo "
对不起，您检索的图书信息不存在! ";}
do{
?&gt;
&lt;?php echo $row[0]; ?&gt; &lt;?php echo $row[1]; ?&gt;&lt;?php echo $row[2]; ?&gt;&lt;?php echo $row[3]; ?&gt; &lt;?php echo $row[4]; ?&gt; &lt;?php echo $row[5]; ?&gt;}while($row=mysql_fetch_row($sql));
?&gt;
二 运行结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bae5ee7a6d1e5567dea53622652893b/" rel="bookmark">
			合并两个数组的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS合并两个数组的方法
我们在项目过程中，有时候会遇到需要将两个数组合并成为一个的情况。比如： var a = [1,2,3]; var b = [4,5,6]; 有两个数组a、b，需求是将两个数组合并成一个。方法如下： 1、concat
js的Array对象提供了一个叫concat()方法，连接两个或更多的数组，并返回结果。 var c = a.concat(b);//c=[1,2,3,4,5,6]; 这里有一个问题，concat方法连接a、b两个数组后，a、b两个数组的数据不变，同时会返回一个新的数组。这样当我们需要进行多次的数组合并时，会造成很大的内存浪费，所以这个方法肯定不是最好的。
2、for循环
大概的思路是：遍历其中一个数组，把该数组中的所有元素依次添加到另外一个数组中。直接上代码：
for(var i in b){ a.push(b[i]); } 这样的写法可以解决第一种方案中对内存的浪费，但是会有另一个问题：丑！这么说不是没有道理，如果能只用一行代码就搞定，岂不快哉~
3、apply
函数的apply方法有一个特性，那就是func.apply(obj,argv)，argv是一个数组。所以我们可以利用这点，直接上代码： a.push.apply(a,b); 调用a.push这个函数实例的apply方法，同时把，b当作参数传入，这样a.push这个方法就会遍历b数组的所有元素，达到合并的效果。
这里可能有点绕，我们可以把b看成[4,5,6]，变成这样：
a.push.apply(a,[4,5,6]); 然后上面的操作就等同于：
a.push(4,5,6); 这样就很清楚了！
另外，还要注意两个小问题：
1）以上3种合并方法并没有考虑过a、b两个数组谁的长度更小。
所以好的做法是预先判断a、b两个数组哪个更大，然后使用大数组合并小数组，这样就减少了数组元素操作的次数！
2）有时候我们不希望原数组（a、b）改变，这时就只能使用concat了。
转自：http://www.cnblogs.com/Being-a-runner-up/p/5627166.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/328/">«</a>
	<span class="pagination__item pagination__item--current">329/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/330/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>