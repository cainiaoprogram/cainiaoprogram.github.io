<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f15a32e2357544f0d4f4e601d347bb3/" rel="bookmark">
			4.1.5 OS之文件管理空闲磁盘块的几种算法(空闲表法、空闲链表法、位示图法、成组链接法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章转自:
4.1.5 OS之文件管理空闲磁盘块的几种算法(空闲表法、空闲链表法、位示图法、成组链接法)_BitHachi的博客-CSDN博客_空闲块成组链接法
目录
0.思维导图
1.存储空间的划分与初始化
2.空闲表法
3.空闲链表法
空闲盘块链
空闲盘区链
4.位示图法
5.成组链接法
0.思维导图 1.存储空间的划分与初始化 2.空闲表法 如何分配？
如何回收？
3.空闲链表法 空闲盘块链 空闲盘区链 4.位示图法 如何分配与回收？
5.成组链接法 超级块的作用
如何分配？
需要1个空闲磁盘块
需要100个空心啊磁盘块
如何回收？
第二种情况，第一组已满
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d07551ae6911f5a09b6f88ccdea1754/" rel="bookmark">
			【python】词云图制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		词云图制作 python 练了一段时间的词云图，就来和大家讲讲词云图制作的详细过程。
效果图 工具准备 1、python32、安装第三方库wordcloud3、安装numpy、pillow库。4、安装jieba库5、安装matplotlib库 from wordcloud import WordCloud import numpy as np from PIL import Image from matplotlib import colors import collections #这些都是需要使用的库 安装方法：我大多是借助pycharm中的setting直接安装。但是也有安装失败的，大家可以自行“c一下”
代码展示 # -*- coding: utf-8 -*- import jieba from wordcloud import WordCloud import numpy as np from PIL import Image from matplotlib import colors import collections def chinese_jieba(): # 读取目标文本 with open(r'文本.txt', encoding='utf-8') as fp: txt = fp.read() fp.close() wordlist_jieba = jieba.lcut(txt) # 将文本分割，返回列表 txt_jieba = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d07551ae6911f5a09b6f88ccdea1754/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd9a38dfd030770a8d5559c99509a838/" rel="bookmark">
			PYQT基础组件QPushButton、QMessageBox、QInputDialog、QFileDialog、QtextEdit、QSlider、QSpinBox、QComboBox详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、写在前面二、QT for Python基础组件2.1 QPushButton组件2.2 QMessageBox组件2.3 QInputDialog组件2.4 QFileDialog组件2.5 QtextEdit组件2.6 QSlider组件2.7 QSpinBox组件2.8 QComboBox组件 三、总结 一、写在前面 ​ ~~~~~~~~~ 最近计划开始系统整理一下python进行QT开发的基础知识和技能，一方面帮助老师整理相关的知识和实例Demo，另外一方面也完善自己QT开发的知识，作为之前QT树形组件的补充和拓展。关于QT树形组件的基本内容，可以参考我之前的博文：https://blog.csdn.net/DALEONE/article/details/123676385?spm=1001.2014.3001.5501
二、QT for Python基础组件 2.1 QPushButton组件 组件简介：
​ ~~~~~~~~~ QPushButton组件，顾名思义是定义QT界面中按钮的类，QT官网对其的界定为Perhaps the most commonly used widget in user’s interface，足见其在QT界面开发设计中的重要性，但是从应用开发的层面讲，相对而言较为简单。
界面展示：
组件使用：
QPushButton的实例化及基础使用：
button1 = QPushButton("OK", self) ## QPushButton实例化 button1.clicked.connect(lambda: self.onClicked(button1)) def onClicked(self, button): print("Button {0} is clicked.".format(button.text())) 小Tips：
QPushButton的构造函数中传入str作为Button的label，显示在创建成功的按钮上Button的text方法用于获取Button的名称(上述实例化时传入的label) 此处的connect函数重点强调：
​ ~~~~~~~~ QT开发过程中，每个组件都不可能单独存在，都必须与一定的作用效果相关联（不是光秃秃摆个图标上去，否则图形化界面就没有意义）。
​ Button.clicked.connect()即说明Button按钮背后关联的作用：print("Button {0} is clicked.".format(button.text())) 输出被按下按钮的名称。
提醒：
​ 此处onClicked函数需要传入参数，因此借助于lambda表达式完成函数传入调用，后续在其他组件中还会有其他传入的方式
关于lambda表达式，也可以参考我的博文：(2条消息) python中lambda表达式，列表生成式，map()函数的基础用法详解_隔壁李学长的博客-CSDN博客_lambda 列表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd9a38dfd030770a8d5559c99509a838/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac46902355879be37f491cfb9f845ed/" rel="bookmark">
			pymavlink使用简单教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 pymavlink主要包含的模块连接样例 设置任务样例 更改飞行参数param样例 飞行模式总结 pymavlink Pymavlink是MAVLink协议的python实现。 自身包括一个源代码生成器（generator / mavgen.py），用于为其他编程语言创建MAVLink协议实现。 还包含用于分析飞行日志的工具。
主要包含的模块 mavutil: 用于设置通信链接，接收和解码消息，运行定期任务等.mavwp: 用于加载/保存航点，地理围栏等.mavparm: 用于加载/保存MAVLink 的参数.mavextra: 用于转换单位和消息的工具。mavexpression (internal): MAVLink表达式评估的一些函数. 连接 首先是进行连接, 因为我用的是模拟器所以用udp进行连接并获取心跳包
master = mavutil.mavlink_connection('udp:0.0.0.0:{}'.format(port))# port 是端口号 master.wait_heartbeat() print("Heartbeat from system (system %u component %u)" % ( master.target_system, master.target_system)) 连接上了以后可以通过recv_match获取消息
msg = master.recv_match(type='ATTITUDE', blocking=True) 其中type是你要获取的消息的类型,可以是单个消息,也可以是一组消息,组消息用[]即可,blocking 是该消息是否阻塞,即在收到type类的消息前一直等待.msg可以使用to_dict()将其变成dict
样例 不停接收UAV的ATTITUDE消息
from pymavlink import mavutil master = mavutil.mavlink_connection('udp:0.0.0.0:{}'.format(port))# port 是端口号 master.wait_heartbeat() print("Heartbeat from system (system %u component %u)" % ( master.target_system, master.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ac46902355879be37f491cfb9f845ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7857625d22940f98783dc9aa29650113/" rel="bookmark">
			抖音取关-autojs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近不少网友私信我，想要抖音取关的自动化脚本，奈何上次写的脚本已经好几个月没有更新了，导致可能部分代码已经失效，而且唐丁没有给大家详细的安装和使用教程，导致不少朋友拿到脚本后也不知道如何使用。今天唐丁就一次性给大家演示一下。
唐丁最近完善了一下后台管理系统，增加了一些对脚本的支持接口，方便后面对脚本的发布、使用、升级等做统一的管理。今天就在这里一次性把脚本的使用流程说清楚，方便后续大家的安装和使用。
1、所有脚本都以安卓应用(apk)的形式发布，大家下载到手机上安装即可（安装过程可能提示病毒之类的异常，直接忽略即可）
2、安装后需要给予软件两个权限: 无障碍(软件正常运行的基础)和悬浮窗(日志查看)
从公众号（程序员唐丁）回复关键词获取脚本链接下载后，里面包括脚本软件和使用说明文档两部分，不清楚的同学可以直接安装说明文档进行操作。
当前脚本的种类还不算丰富，唐丁正在抓紧完善当中，后续所有的功能脚本会集成在一个安卓应用当中，大家可以直接在界面中选择需要的功能，配置相关参数后即可使用。这边再解释一下密钥相关的东西，获取密钥需要登录上述页面中的网站，注册并开通脚本账号后会自动生成一个密钥，一个账号只有一个密钥，密钥对唐丁的所有脚本都是通用的，新注册的用户有10次免费体验的机会。欢迎大家使用～～
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5389c5e0e9ade81de6b284e634eef22/" rel="bookmark">
			AI常见部署方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.AI部署简介2.具体部署 1.AI部署简介 没人告诉你的大规模部署AI高效流程！ 对大部分 TensorFlow 模型来说，部署流程是相同的： 1. 将图像固化为 Protobuf 二进制文件 2. 调整推断代码，使它可以处理固化的图 3. 容器化应用程序 4. 在最上面加上 API 层 本文提出了一个大规模部署 AI 的高效工作流程： 固化图并将推断封装在 API 下 重复使用会话和图，缓存输入和输出 用 Docker 容器化应用程序（包括 API 层） 将大规模应用程序与 Kubernetes 一起部署在你选择的云上 将训练从推断中分离出来 建立任务队列，将较小的任务确立为优先级 使用这些技术，你就可以在成本最小、速度和效率最大的情况下大规模部署 AI。 2.具体部署 使用ONNX部署深度学习和传统机器学习模型自动部署深度神经网络模型TensorFlow（Keras）到生产环境中深度学习Tensorflow生产环境部署（上·环境准备篇） 客户端 ----&gt; web服务(flask或者tornado) --grpc或者rest--&gt; tensorflow serving 深度学习Tensorflow生产环境部署（下·模型部署篇）Tensorflow 2.x模型-部署与实践如何部署tensorflow训练的模型将tensorflow模型部署到服务器上Tensorflow如何进行工业部署？ 确定好输入和输出节点，把模型导出成SavedModel格式， 然后用TF-Serving启动服务， 调用方发http请求或者grpc请求就可以拿到预测结果 使用 Docker 部署 TensorFlow 环境
已经训练好的tensorflow模型如何部署到web上？
可以做成一个http服务,提供一个web接口,模型只在服务器上就可以了. 使用时候客户端通过http请求上传要识别的图片等数据到服务端接口,服务端计算后返回给客户端. 部署PyTorch模型到终端如何将pytorch模型通过docker部署到服务器 在服务端训练出特定的算法模型——再将这个模型部署到服务端或者终端（以后大多数场景下是部署到终端）——需要服务端AI框架到终端AI推理框架的转换工具。 Tensorflowserving:
模型部署 TensorFlowServingtensorflow2.0基础（10）——使用tensorflow-serving部署模型Tensorflow-serving部署模型到服务器tensorflow serving部署keras或tf2.0模型docker部署tensorflowserving以及模型替换Tensorflow-serving+Docker安装+模型部署用Docker容器自带的tensorflowserving部署模型对外服务（成功率100%）TensorFlow Serving + Docker +Tornado机器学习模型生产级快速部署 常用的做法如使用flask、Django、tornado等web框架创建一个服务器app，这个app在启动后就会一直挂在后台，然后等待用户使用客户端POST一个请求上来（例如上传了一张图片的url），app检测到有请求，就会下载这个url的图片，接着调用你的模型，得到推理结果后以json的格式把结果返回给用户。 这个做法对于简单部署来说代码量不多，对于不熟悉web框架的朋友来说随便套用一个模板就能写出来，但是也会有一些明显的缺点： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5389c5e0e9ade81de6b284e634eef22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd8bfe39fbcce9ce2992cefeb4e324af/" rel="bookmark">
			Latex左对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用latex排版时，需要将以上内容改为左对齐，可以这样：
\begin{flushleft} 内容 \end{flushleft} 排版效果如下，虽然左对齐了，但是右边会出现空格，并不美观
只需要先导入\usepackage{ragged2e}，然后在内容前面加上\justifying即可
\begin{flushleft} \justifying 内容 \end{flushleft} 效果如下：
okay! 完成！
参考：https://blog.csdn.net/jzwong/article/details/99964922
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c2c1728f6a8ff6b35de94d447270333/" rel="bookmark">
			[09]Golang的结构体struct
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结构struct Go中的struct 与 C 中 的truct非常相似，并且Go没有class使用type&lt; Name &gt;struct{}定义结构，名称遵循可见性规则支持指向自身的指针类型成员支持匿名结构，可用作成员或定义成员变量匿名结构也可用于map的值可以使用字面值对结构进行初始化允许直接通过指针来读写结构成员相同类型的成员可以直接拷贝赋值支持 == 与 != 比较运算符，但不支持 &gt; 或 &lt;支持匿名字段，本质上是定义了某个类型为名称的字段嵌入结构作为匿名字段看起来像继承，但不是继承可以使用匿名字段指针 结构体的定义和使用 type test struct{} //定义结构体 func main() { a := test{} fmt.Println(a) } 运行结果：
定义一个Person的结构
type Person struct { Name string Age int } //定义结构体 func main() { a := Person{} fmt.Println(a) } 运行结果：
初始化
type Person struct { Name string Age int } //定义结构体 func main() { a := Person{} a.Name = "jack" a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c2c1728f6a8ff6b35de94d447270333/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5701fa5d5826f33b8f9e0709b430a943/" rel="bookmark">
			MySQL掉落榜首？全新开发者调查报告已出炉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stack Overflow 2022 开发者调查报告现已出炉。Stack Overflow 年度开发者调查是面向全球开发者进行的规模最大、最全面的调查，调查涵盖了从开发者喜爱的技术到工作偏好等内容。2022 年是 Stack Overflow 发布年度开发者调查报告的第十二年，有来自 180 个国家 / 地区的 73000 多名开发人员参与了这个调查。其中，依旧是来自美国和印度的受访者数量最多，其次是德国和 UKI（英国和爱尔兰）；仅有 632 份调查反馈来自中国开发者，占比为 0.88%。 此次调查的一些亮点内容如下：&amp;nbsp; 在线学习编程的比例从 60% 上升到了 70%，45 岁以上的受访者喜欢从书本上学习知识，年轻人（18 岁以下）依赖在线学习与资源。
Docker 似乎正在成为专业开发人员的基本工具，从 55% 增加到 69%。
Rust 已连续第七年成为最受喜爱的语言，87% 的开发人员表示他们希望继续使用它。
Phoenix 取代 Svelte 成为最受欢迎的 Web 框架。Angular.js 连续三年成为开发者最讨厌的框架，React.js 连续五年成为开发者最想学习的框架。
Docker 和 Kubernetes 分别位列最受喜爱和想要学习的工具第一和第二位。大家想要使用 Docker 的意愿似乎并未放缓，从去年的 30% 增加到了今年的 37%。
Clojure 仍然是已知最高收入的语言。Chef 开发人员薪水最高，但它也是开发者最不喜欢的工具之一。
69% 的受访者从事全职工作，相较去年上升了 4 个百分点。
85% 的开发人员表示，他们的组织至少部分是支持远程的。
62% 的受访者每天花费超过 30 分钟寻找问题的答案或解决方案，还有&amp;nbsp;25%&amp;nbsp;的人每天花费超过一个小时。对于一个由 50 名开发人员组成的团队来说，整个团队每周花费在搜索答案 / 解决方案上的时间总计 333-651 小时。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5701fa5d5826f33b8f9e0709b430a943/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35c83b84cc9a4d67438b7c5b7775493e/" rel="bookmark">
			Python入门自学进阶-Web框架——17、Django实现评论树形结构、Model操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、获取浏览器信息
对于不同的设备，后端可以通过request获取设备的相关信息，根据信息的不同返回不同的页面，如手机用的Android系统，还是其他等等。
测试工具：user agent switcher for chrome，安装后可以选择模拟的设备进行发送请求
上面选择的是Chrome on Android Mobile，在谷歌浏览器中查看请求头：
User-Agent显示是Android系统。
在后端，请求的所有信息是封装在request的environ中的：在后端打印print（request.environ.keys()）
dict_keys(['ALLUSERSPROFILE', 'APPDATA', 'COMMONPROGRAMFILES', 'COMMONPROGRAMFILES(X86)', 'COMMONPROGRAMW6432', 'COMPUTERNAME', 'COMSPEC', 'CYGWIN', 'DJANGO_SETTINGS_MODULE', 'FP_NO_HOST_CHECK', 'HOMEDRIVE', 'HOMEPATH', 'IDEA_INITIAL_DIRECTORY', 'LOCALAPPDATA', 'LOGONSERVER', 'MOZ_PLUGIN_PATH', 'NUMBER_OF_PROCESSORS', 'OS', 'PATH', 'PATHEXT', 'PROCESSOR_ARCHITECTURE', 'PROCESSOR_IDENTIFIER', 'PROCESSOR_LEVEL', 'PROCESSOR_REVISION', 'PROGRAMDATA', 'PROGRAMFILES', 'PROGRAMFILES(X86)', 'PROGRAMW6432', 'PSMODULEPATH', 'PUBLIC', 'PYCHARM_DISPLAY_PORT', 'PYCHARM_HOSTED', 'PYTHONIOENCODING', 'PYTHONPATH', 'PYTHONUNBUFFERED', 'SESSIONNAME', 'SYSTEMDRIVE', 'SYSTEMROOT', 'TEMP', 'TMP', 'USERDOMAIN', 'USERNAME', 'USERPROFILE', 'VBOX_MSI_INSTALL_PATH', 'WINDIR', 'RUN_MAIN', 'SERVER_NAME', 'GATEWAY_INTERFACE', 'SERVER_PORT', 'REMOTE_HOST', 'CONTENT_LENGTH', 'SCRIPT_NAME', 'SERVER_PROTOCOL', 'SERVER_SOFTWARE', 'REQUEST_METHOD', 'PATH_INFO', 'QUERY_STRING', 'REMOTE_ADDR', 'CONTENT_TYPE', 'HTTP_HOST', 'HTTP_CONNECTION', 'HTTP_CACHE_CONTROL', 'HTTP_SEC_CH_UA', 'HTTP_SEC_CH_UA_MOBILE', 'HTTP_SEC_CH_UA_PLATFORM', 'HTTP_UPGRADE_INSECURE_REQUESTS', 'HTTP_USER_AGENT', 'HTTP_ACCEPT', 'HTTP_SEC_FETCH_SITE', 'HTTP_SEC_FETCH_MODE', 'HTTP_SEC_FETCH_USER', 'HTTP_SEC_FETCH_DEST', 'HTTP_ACCEPT_ENCODING', 'HTTP_ACCEPT_LANGUAGE', 'HTTP_COOKIE', 'wsgi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35c83b84cc9a4d67438b7c5b7775493e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c598d4cd18a8c0e782cd55dfe4c2a196/" rel="bookmark">
			编译内核错误——*** 没有规则可制作目标“debian/canonical-certs.pem”，由“certs/x509_certificate_list” 需求。 停止。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开.config文件
vim .config 删掉双引号中的内容（保留双引号） 删完后：
保存退出
:wq 问题结局！来吧！去挑战下一个困难！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c603450a9f7bd45664105fac59b724f2/" rel="bookmark">
			Sublime text 3手把手使用教程（附带配置完成安装包）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Last-Modified:2022/3/11 来给三年前的这个博客简单加一下win10上sublime编译c++的做法
直接去官网下一个免费的
免费的和花钱的功能上没有区别，购买证书的一般是用作商业用途的团队
打开sublime之后，点击Tools/Build System/New Build System
之后会出来一个新文件，输入下面内容，并保存为 myc++.sublime-build（myc++是自己取的名字）
{ "encoding": "utf-8", "working_dir": "$file_path", "shell_cmd": "g++ -Wall -std=c++11 -fexec-charset=GBK \"$file_name\" -o \"$file_base_name\"", "file_regex": "^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$", "selector": "source.c++", "variants": [ { "name": "Run", "shell_cmd": "g++ -Wall -std=c++11 -fexec-charset=GBK \"$file\" -o \"$file_base_name\" &amp;&amp; start cmd /c \"\"${file_path}/${file_base_name}\" &amp; pause\"" } ] } 环境变量是当然要配置的，去加上自己MinGW等编译系统bin文件的地址即可
完成之后按ctrl+B会弹出一个命令框，选择带run的
之后按ctrl+B就默认会用那个了，加shift会调出一开始的总选项
以下为原文回答： 首先，
如果你还在用 D e v Dev Dev的话
请不要纠结到底看不看这篇文章
那就是要看完！
没有看不起 D e v Dev Dev
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c603450a9f7bd45664105fac59b724f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15632917688321d437b62cb19191b014/" rel="bookmark">
			关于数据表空间问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle经常需要查数据库表空间大小，使用率，加表空间等，这里总结我经常使用的语句。
一、数据表空间相关：
查询所有表空间的使用情况：
SELECT d.tablespace_name "Name", d.status "Status", TO_CHAR (NVL (a.BYTES / 1024 / 1024, 0), '99,999,990.90') "Size (M)", TO_CHAR (NVL (a.BYTES - NVL (f.BYTES, 0), 0) / 1024 / 1024, '99999999.99' ) USE, TO_CHAR (NVL ((a.BYTES - NVL (f.BYTES, 0)) / a.BYTES * 100, 0), '990.00' ) "Used %" FROM SYS.dba_tablespaces d, (SELECT tablespace_name, SUM (BYTES) BYTES FROM dba_data_files GROUP BY tablespace_name) a, (SELECT tablespace_name, SUM (BYTES) BYTES FROM dba_free_space GROUP BY tablespace_name) f WHERE d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15632917688321d437b62cb19191b014/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5961a6a4174a2d0cf08d8c83125fcdd2/" rel="bookmark">
			Shell脚本语言-数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、语法 数组名=(值1 值2 值3…) 2、初始化数组 方式一 name=("404" "Andy" "柚芒子" "全班最菜") #输出 echo $name #默认：打印第一个元素 方式二 name=() name[0]="404" name[1]="Andy" name[2]="柚芒子" name[3]="全班最菜" echo ${name[0]} ${name[1]} 3、读取数组 语法结构：${数组名[下标]} name=("404" "Andy" "柚芒子" "全班最菜") #输出一个元素 echo ${name[0]} #输出所有-&gt;"@"表示输出所有的数据 echo ${name[@]} 4、数组长度 方式一：获取数组元素个数 语法：${#数组名[@]} 代码： name=("404" "Andy" "柚芒子" "全班最菜") echo ${#name[@]} 结果：4 方式二：获取数组元素个数 语法：${#数组名[*]} 代码： name=("404" "Andy" "柚芒子" "全班最菜") echo ${#name[*]} 结果：4 方式三：获取单个元素-&gt;字符长度 语法：${#数组名[下标]} 代码： name=("404" "Andy" "柚芒子" "全班最菜") echo ${#name[2]} 结果：3 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4cbd33d9d8c3f793e858aa92269265e/" rel="bookmark">
			js使用for循环进行矩阵乘法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 矩阵乘法 * @param matrix_a 矩阵行 * @param matrix_c 矩阵列 * @returns 返回矩阵 */ public MatrixMultiply(matrix_a: Float64Array, matrix_c: Float64Array): Float64Array { const matrix: Float64Array = new Float64Array(matrix_a.length); const length_a: number = Math.sqrt(matrix_a.length); let matrix_b: Float64Array = new Float64Array(matrix_a.length);; if (length_a === matrix_c.length) { for (let i: number = 0; i &lt; matrix_a.length; i++) { matrix_b[i] = matrix_c[i % length_a]; } } else { matrix_b = Float64Array.from(matrix_c, value =&gt; value); } const length_b: number = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4cbd33d9d8c3f793e858aa92269265e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e7dbc332f3d5a0570d13cb42f6a1ddf/" rel="bookmark">
			【记一次大量文本相似度去重】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文本相似度去重，在大量的文本中找到相似的文本进行去重。 整体去重流程 采用三层去重处理分别是 url，title，content。url，title 都采用 MD5去重（这个so easy ），content 采用simhash+海明距离 去重（也就是 文本相似度的计算）。 1、对content 计算 simhash 得到64位的字符串 1) 全角转半角 2) 繁体转换简体 3) 去除各类标签和特殊字符 4) 文本分词处理(采用的hanlp分词，其他自行查找) 5) 词频计算 6) 去除停用词 7) 计算词语权重 8) 根据词语和权重值，生成由0和1组成的64位simhash 2、查找计算汉明距离，判断文本是否重复，判断标准两个文本海明距离（海明距离可以理解为两个simhash有多少位不一样）小于等于3就认为是重复文本 1)将64位切成4段，每段16位，作为key，然后在redis查找 。 a) key存在，找到值，遍历所有值，计算海明距离小于等于3就认为是重复的文本。遍历完毕不存在海明距离小于等于3，说明不是重复文本 ， 进行 2）将值存入到redis b) key不存在，说明不是重复文本 ，进行 2）将值存入到redis 如果两个相似文本，海明距离最大为3，最多有3位不一样，最多分布在3个段内，4个段至少有1个段是完全一致的。(可以根据自己的需求设计海明距离，和分段数，目的主要是对大量数据进行过滤) 2)将16位的4段分别作为key 存到redis 中，可以采用 list 类型（16位的段作为key，simhash 作为list中的元素），也可以采用zset（本文中采用zset，16位的段作为key，simhash 作为zset中的value，然后再设计一个score 用于过滤）。 理论说完，开始上货。 maven 引入hanlp &lt;dependency&gt; &lt;groupId&gt;com.hankcs&lt;/groupId&gt; &lt;artifactId&gt;hanlp&lt;/artifactId&gt; &lt;version&gt;portable-1.7.5&lt;/version&gt; &lt;/dependency&gt; 上工具类 可以直接拿走
import com.hankcs.hanlp.HanLP; import com.hankcs.hanlp.seg.common.Term; import org.apache.commons.collections.CollectionUtils; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e7dbc332f3d5a0570d13cb42f6a1ddf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a348ab53065a00633fe0103c85a7c33/" rel="bookmark">
			pytorch最全预训练模型下载与调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pytorch预训练模型下载与调用 torchvision.models 官方预训练模型调用代码：https://github.com/pytorch/vision/tree/master/torchvision/models
官方文档地址 ：https://pytorch.org/docs/master/torchvision/models.html
预训练模型下载: Classification 分类 AlexNet
model_urls = { 'alexnet': 'https://download.pytorch.org/models/alexnet-owt-4df8aa71.pth', } VGG
model_urls = { 'vgg11': 'https://download.pytorch.org/models/vgg11-bbd30ac9.pth', 'vgg13': 'https://download.pytorch.org/models/vgg13-c768596a.pth', 'vgg16': 'https://download.pytorch.org/models/vgg16-397923af.pth', 'vgg19': 'https://download.pytorch.org/models/vgg19-dcbb9e9d.pth', 'vgg11_bn': 'https://download.pytorch.org/models/vgg11_bn-6002323d.pth', 'vgg13_bn': 'https://download.pytorch.org/models/vgg13_bn-abd245e5.pth', 'vgg16_bn': 'https://download.pytorch.org/models/vgg16_bn-6c64b313.pth', 'vgg19_bn': 'https://download.pytorch.org/models/vgg19_bn-c79401a0.pth', } ResNet
model_urls = { 'resnet18': 'https://download.pytorch.org/models/resnet18-5c106cde.pth', 'resnet34': 'https://download.pytorch.org/models/resnet34-333f7ec4.pth', 'resnet50': 'https://download.pytorch.org/models/resnet50-19c8e357.pth', 'resnet101': 'https://download.pytorch.org/models/resnet101-5d3b4d8f.pth', 'resnet152': 'https://download.pytorch.org/models/resnet152-b121ed2d.pth', } ResNeXt
model_urls = { 'resnext50_32x4d': 'https://download.pytorch.org/models/resnext50_32x4d-7cdf4587.pth', 'resnext101_32x8d': 'https://download.pytorch.org/models/resnext101_32x8d-8ba56ff5.pth', 'resnext101_32x16d': 'https://download.pytorch.org/models/ig_resnext101_32x16-c6f796b0.pth' } Wide ResNet
model_urls = { 'wide_resnet50_2': 'https://download.pytorch.org/models/wide_resnet50_2-95faca4d.pth', 'wide_resnet101_2': 'https://download.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a348ab53065a00633fe0103c85a7c33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94674969d6cb83d3951009fd0c6efa81/" rel="bookmark">
			Vue中的nextTick源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）首先nextTick是可以传两个参数: 回调函数 和 环境对象
（2）nextTick做了什么：把传入的函数放入callback数组，并且执行timerFunc函数
（3）timerFunc函数： 去判断当前环境是否支持原生Promise，原生MutationObserver，试图把回调放入微任务队列去执行，如果不支持，则检查是否支持setImmediate，不支持就用setTimeout。就是对环境进行一个降级处理，去执行flushCallbacks函数
（4）flushCallbacks函数：就是for循环执行callback队列
const callbacks = [] let pending = false let timerFunc export function nextTick (cb?: Function, ctx?: Object) { let _resolve callbacks.push(() =&gt; { if (cb) { try { cb.call(ctx) } catch (e) { handleError(e, ctx, 'nextTick') } } else if (_resolve) { _resolve(ctx) } }) if (!pending) { pending = true timerFunc() } // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== 'undefined') { return new Promise(resolve =&gt; { _resolve = resolve }) } } // timerFunc export let isUsingMicroTask = false if (typeof Promise !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94674969d6cb83d3951009fd0c6efa81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c8eee848c7a3c35b239d41cb6e5d920/" rel="bookmark">
			修改ssh服务的默认端口（附坑解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常规方法
首先我们先查看当前开放的口号
netstat -tnlp |grep ssh 如果提示没有netstat命令则通过如下命令下载安装
yum install net-toolls #按照提示输入y即可 ssh配置文件路径/etc/ssh/sshd_config，使用命令编辑
vi /etc/ssh/sshd_config 找到 #Port 22 所在行，将“#”去掉，然后在下一行我们手动在添加一行 Port 1022 （随便你需要的端口号），添加一行是为了防止我们将原来的端口修改无效后我们无法链接，稍后测试通过后删除即可。
保存配置文件后，重启ssh
systemctl restart sshd 或者 service sshd restart 重启后我们在使用第一步的命令，查看我们添加的端口号是否生效，如果新增的端口号出现在了列表中，用我们的远程工具链接即可，剩下的所有步骤跳过即可。如果不生效则继续往下看 ↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓深坑解决↓↓↓↓↓↓↓↓↓↓↓↓↓↓
我们查看下当前ssh服务的运行状态，命令如下：
systemctl status sshd.service 可以看到，我们修改的端口号所在行红色报错了，最后生效运行的还是22端口，这个问题是由于 selinux 引起的，需要修改 selinux 中的 SSH 端口。继续往下看↓↓↓↓↓↓↓↓↓
首先安装工具，没有会自动安装，提示安装过了忽略继续往下即可
yum -y install policycoreutils-python 修改selinux
#修改 /etc/selinux/config 配置，启用 SELinux vi /etc/selinux/config SELINUX=permissive # 重启服务器 init 6 # 重启后查看 SELinux 状态 sestatus 添加开放的端口，开放后重启服务
semanage port -a -t ssh_port_t -p tcp 1024 #添加端口 systemctl restart sshd #重启服务 查看防火墙的状态，关闭则开启
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c8eee848c7a3c35b239d41cb6e5d920/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a6300e0ef314bb671b716e9e94c1282/" rel="bookmark">
			Kafka 开启 SASL/PLAINTEXT 认证及 ACL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 安装 Kafka 并开启 SASL/PLAINTEXT 认证 前言一、环境准备1、组件版本2、下载文件3、上传文件 二、安装 Zookeeper（单节点）三、安装 Kafka（单节点）四、Zookeeper 开启 SASL 认证1、修改 zoo.cfg，添加如下配置2、新增 zk_server_jaas.conf3、将 kafka 认证的包导入 zk 中4、修改 zkEnv.sh 添加环境变量5、重启 zk 五、Kafka 开启 SASL 认证1、新增 kafka_server_jaas.conf 配置文件2、修改 kafka-run-class.sh，添加环境变量3、修改 server.properties 配置文件4、重启 kafka5、查看 Topic6、启动生产者和消费者 六、配置 ACL1、配置 Zookeeper ACL2、配置 Kafka ACL 前言 在之前的开发工作中，需要开发使用用户名密码的方式连接 Kafka 并对 Kafka 数据进行处理，但是客户并没有提供可以测试的环境，于是就自己着手搭建了一套单节点的 Kafka 并开启 SASL 认证。
一、环境准备 1、组件版本 组件版本kafka2.11-2.22zookeeper3.6.2 2、下载文件 KAFKA：下载地址
ZOOKEEPER：下载地址
3、上传文件 # 将下载的 zookeeper 和 kafka 包上传到 /opt/software 目录下 mkdir -p /opt/software # 组件的安装目录 mkdir -p /opt/module # 组件数据存放目录 mkdir -p /opt/data 二、安装 Zookeeper（单节点） # 解压zookeeper文件到/opt/modele/目录下 cd /opt/software tar -zxvf apache-zookeeper-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a6300e0ef314bb671b716e9e94c1282/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ddb3bacaf13f9c2dcf6aa889fd1670b/" rel="bookmark">
			【批处理DOS-CMD命令-汇总和小结】-时间延迟命令、延迟执行命令——ping、for、vbs延迟函数、批处理命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考来源：bat脚本的基本命令语法 - 整合侠 - 博客园
一、什么是时间延迟命令、延迟执行命令？应用有哪些？ 通俗来说，就是指“延迟一段时间再执行下一条命令”。
应用方面，主要是用来“模拟进度条”。
二、利用ping实现延迟命令 为啥ping命令可以实现延时？
因为从我们自己的主机Ping通到目标主机，是需要时间的；所以执行ping命令一般比较久，利用它执行很久的特性，额外加在想要延时的位置，就实现了延时命令。
但是这种延时手段是不精确的，因为每一次ping通的延迟不一样。
下面给出一个ping命令延时的例程。
@echo off echo 延时前：%time% ping /n 3 127.0.0.1 &gt;nul echo 延时后：%time% pause 参数/n表示ping通的次数。
127.0.0.1是本机ip地址，在这里可以简写成127.1。
&gt;nul表示不将结果显示在屏幕上。
在Bat文件中执行，效果如下，可以看到延时了2秒钟。 三、利用循环命令for外加参数/l实现延时 for命令实现延时的原理，也很简单。
直接添加参数/l，然后设置start、step、end分别为1、1、n，通过调整变量n的数值大小，就可以改变延时长短。
这个延时，也是不精确的。
下面给出bat代码。同样地，&gt;nul也是用来屏蔽计次循环的输出内容。
@echo off echo 延时前：%time% for /l %%i in (1,1,100000) do echo %%i&gt;nul echo 延时后：%time% pause 在bat文件中执行，结果如下，10万次对应大概2s的延时。
四、利用vbs延迟函数实现延时 实现原理：
将wscript.sleep延时方法的代码放入临时创建的delay.vbs脚本文件，而后利用cmd命令cscript调用delay.vbs脚本文件，即可实现延时。
延时误差：
精确度毫秒，误差1000毫秒，
代码如下：
@echo off echo %time% call :delay 5000 echo %time% pause exit :delay echo WScript.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ddb3bacaf13f9c2dcf6aa889fd1670b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76e6cc0efeb11e2f40c6c555e375d0ba/" rel="bookmark">
			用python获取oracle数据库数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # -*- coding:utf-8 -*- import sys import cx_Oracle as cx sys.path #这里的顺序是用户名/密码@oracleserver的ip地址/数据库名字 conn = cx.connect('root/root@127.0.0.1:1521/ORCL') #创建cursor对象 cur = conn.cursor() #查表 sql = "SELECT * FROM STUDENT" #执行数据库操作 cur.execute(sql) #取前八条数据 many_data=cur.fetchmany(8) print(many_data) cur.close() conn.commit() conn.close() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f40dcbee5ca64cecca256ab16d87b8a/" rel="bookmark">
			java任务队列__将一段代码放入另一个线程运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、创建任务队列对象： public ConcurrentLinkedQueue&lt;Runnable&gt; queue = new ConcurrentLinkedQueue&lt;&gt;(); 2、在当前线程将任务加入队列： //向队列中添加任务，并没有执行 //add lambda表达式 queue.add(()-&gt;{ log.info("taskQueue..."); }); 3、在另一个线程取出任务运行： Runnable task = queue.poll();//取出任务 if(task!=null){ task.run();//运行 } 总结： 当我们有执行顺序有相关联的代码在两个不同的线程中执行，因为不同线程运行顺序不可控，就可以使用任务队列将他们放入一个线程中运行，在同一个线程中，更容易控制从而达到我们想要的结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6950d27ae30768417ddb36dca515eeb/" rel="bookmark">
			Android ConstraintLayout约束布局的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：回廊一寸相思地，落月成孤，背灯和月花阴，已是十年踪迹十年心。 —— 虞美人
一、概述 AndroidStudio3.0之前默认的根布局是RelativeLayout，但是3.0之后默认的根布局是ConstraintLayout(约束布局)，它作为一款强大的调整View位置和大小的ViewGroup被Google所推荐，ConstraintLayout能够以支持库的形式支持到最小的API 9，同时也在不断丰富API和功能，它能在复杂布局中有效降低布局层级，提高性能，使用更加灵活。
但是约束布局不要乱用，因为它在测量子view的相对位置相对大小的时候，它的onmeasure()方法会被多次调用。
我们来探讨一下ConstraintLayout的相关用法，新版的Android Studio在建立工程时会默认添加约束布局的依赖，如果没有添加则需要手动在build.gralde文件中添加依赖库：
implementation 'androidx.constraintlayout:constraintlayout:1.1.3' 二、相关属性 2.1 相对定位 相对定位，其实这个跟RelativeLayout差不多，一个View相对另一个View的位置，常用属性如下：
layout_constraintLeft_toLeftOf 左边左对齐；layout_constraintLeft_toRightOf 左边右对齐；layout_constraintRight_toLeftOf 右边左对齐；layout_constraintRight_toRightOf 右边右对齐；layout_constraintTop_toTopOf 上边顶部对齐；layout_constraintTop_toBottomOf 上边底部对齐；layout_constraintBottom_toTopOf 下边顶部对齐；layout_constraintBottom_toBottomOf 下边底部对齐；layout_constraintStart_toEndOf 起始边向尾部对齐；layout_constraintStart_toStartOf 起始边向起始边对齐；layout_constraintEnd_toStartOf 尾部向起始边对齐；layout_constraintEnd_toEndOf 尾部向尾部对齐；layout_constraintBaseline_toBaselineOf 文字的底部线对齐，用于含文本的控件对齐基线；layout_constraintDimensionRatio 宽高比"2:1"、"H,2:1"或"W,2:1"。 我们来简单实用ConstraintLayout来实现下面的布局，tv_1位于水平居中位置，tv_2位于tv_1的右侧，tv_3位于tv_1的下方，
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView ...... android:id="@+id/tv_1" android:text="tv_1" app:layout_constraintLeft_toLeftOf="parent" tv_1的左边位于parent(父控件)的左边 app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;TextView ...... android:id="@+id/tv_2" app:layout_constraintLeft_toRightOf="@id/tv_1" tv_2的左边位于tv_1的右边 app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;TextView ...... android:id="@+id/tv_3" android:text="tv_3" app:layout_constraintLeft_toLeftOf="@id/tv_1" app:layout_constraintTop_toBottomOf="@id/tv_1" /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 效果如下：
以tv_3的layout_constraintLeft_toLeftOf="@id/tv_1"来说，layout_constraintLeft表示tv_3的左边，toLeftOf表示tv_1的左边，意思就是说tv_3的左边位于tv_1的左边，如上图tv_3与tv_1左边对齐，那么tv_2的layout_constraintTop_toTopOf="parent"表示tv_2的顶部在parent(父控件)的的顶部。
那么constraintLeft、constraintRight、constraintTop、constraintBottom则分别表示自身控件的左、右、上、下四个位置，toLeftOf、toRightOf、toTopOf、toBottomOf表示位于哪一个控件(后接控件ID)左、右、上、下。大致来说，constrainXXX表示自身的约束边，toXXXOf表示另一个View的边。
那么控件1和控件2文字对齐怎么办，layout_constraintBaseline_toBaselineOf表示文字基线对齐，什么是Baseline，就是文字底部基线
&lt;TextView android:id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6950d27ae30768417ddb36dca515eeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e42ed2333dc708e92bdfeecb0a3670f/" rel="bookmark">
			C&#43;&#43;模型部署：qt&#43;yolov5/6&#43;onnxruntime&#43;opencv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者平时主要是写 c++ 库的，界面方面了解不多，也没有发现“美”的眼镜，界面有点丑，大家多包涵。本次介绍的项目主要是通过 cmake 构建一个 基于 c++ 语言的，以 qt 为框架的，包含 opencv 第三方库在内的，跨平台的，使用 ONNX RUNTIME 进行前向推理的 yolov5/6 演示平台。文章力求简单，不追求过多的细节，让同学们对整个流程有一个全面的认识，废话不多说，下面我们就开始一步步的进行介绍。
推理框架 各种支持 C++ 的前向推理库都有自己的一些优点与缺点。X86架构下常用的框架：OpenCV DNN，OpenVINO，OpenVINO，ONNX RUNTIME与TensorRT 也是。下面对他们进行简要的对比，混合使用方式较复杂，暂不考虑（例如：使用其他模块为 DNN 加速等）。
OpenCV DNN OpenCV 中的深度学习模块（DNN）只提供了推理功能，不涉及模型的训练，即模型训练好了，进行预测，支持多种深度学习框架，比如TensorFlow，Caffe,Torch和Darknet。
优点： 1.代码量及编译运行开销远小于其他深度学习模型框架；
2.DNN 模块提供了内建的 CPU 和 GPU 加速（不常用），OpenCV 内置，无需依赖第三方库；
3.一般不限制平台与 CPU ，通用性强。
缺点： 一般情况下 OpenCV DNN 速度最慢。
OpenVino OpenVINO是英特尔推出的一款全面的工具套件，用于快速部署应用和解决方案，支持计算机视觉的CNN网络结构超过200余种。
优点 1.Linux、Windows、macOS 三大平台全覆盖；
2.对英特尔CPU有相应的优化（毕竟自家出品）；
3.支持部分英特尔的独立显卡，同时支持英特尔核芯显卡的第 6 代至第 12 代智能英特尔 酷睿处理器，详细信息点击。
缺点 原则上只支持英特尔的CPU与显卡推理加速。
ONNX Runtime ONNX Runtime 是一个微软公司的开源项目，旨在加速跨各种框架、操作系统和硬件平台的机器学习。
优点 1.Linux、Windows、macOS 三大平台全覆盖；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e42ed2333dc708e92bdfeecb0a3670f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd76657ed3c3f2947adf3ddfc773398a/" rel="bookmark">
			【MySQL】设置好友关系（关注、粉丝、互关）的数据库设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主键关注者id被关注者id112213321423531634743856978 先建一张好友关系表
CREATE TABLE IF NOT EXISTS `follower` ( `id` int(6) unsigned NOT NULL, `user_id` varchar(200) NOT NULL, `follower_id` varchar(200) NOT NULL, PRIMARY KEY (`id`) ) DEFAULT CHARSET=utf8; INSERT INTO `follower` (`id`, `user_id`, `follower_id`) VALUES ('1', '1', '2'), ('2', '1', '3'), ('3', '2', '1'), ('4', '2', '3'), ('5', '3', '1'), ('6', '3', '4'), ('7', '4', '3'), ('8', '5', '6'), ('9', '7', '8'); 我关注的人
select * from follower where user_id = '1' 关注我的人
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd76657ed3c3f2947adf3ddfc773398a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf08e7164f99f771f29d664abf41f7d/" rel="bookmark">
			WPE 抓包 发包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接:讲解wpe抓包,封包_Shaun-sheng的博客-CSDN博客_wep抓包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f97239b556695e5f029a807fd17019b/" rel="bookmark">
			UnknownHostException 未知的名称或服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在服务器上部署jar包或者war包时遇见类似：“**java.net.UnknownHostException 未知的名称或服务”**这个的错误，百思不得其解，总以为是项目代码里面有哪个配置或者什么写错了，但是百度了一圈终于得知是服务器的主机地址没有绑定ip地址，也是醉了！！！！！！！！
原因是host未建立映射关系，编辑hosts文件，增加映射即可： 解决办法：
获取主机名的命令：
hostname 添加一行：
vi /etc/hosts 你的服务器ip地址 你的主机名
例：
172.20.223.233 mysql 添加完重启网络配置
service network restart 然后在重新部署启动项目
完事
-----------------------------------
©著作权归作者所有：来自51CTO博客作者Mr_madong的原创作品，请联系作者获取转载授权，否则将追究法律责任
java.net.UnknownHostException 未知的名称或服务
https://blog.51cto.com/u_15473875/4905791
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92b71bda01133c710af437c81169d1b8/" rel="bookmark">
			Uniapp中h5跨域解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		H5为啥会存在跨域问题
小程序一切都正常的请求调用
App一切都正常的请求调用
此跨域问题只存在于浏览器端，App和小程序不存在跨域问题
出现如下报错
参考地址：
manifest.json官方配置文档： uni-app官网
Chrome 调试跨域问题解决方案之插件篇： uni-app H5跨域问题解决方案（CORS、Cross-Origin） - DCloud问答
其实uni-app官方有解决跨域的办法，官方推荐使用HBuilderX中内置的浏览器去预览，在内置的浏览器中不会存在跨域问题，但是要是在Chrome 浏览器中预览的话就会出现这个跨域问题，官方推荐使用Allow-Control-Allow-Origin: *插件的方式去解决，但是我试过这个插件，不知道是什么问题，并没有效果，跨域问题依旧还是存在，后面再仔细的看了下文档，看到了下面的提示。
uni-app 中 manifest.json-&gt;h5-&gt;devServer 实际上对应 webpack 的 devServer，鉴于 manifest 为 json 文件，故 webpack.config.js-&gt;devServer 配置项下的简单类型属性均可在manifest.json-&gt;h5-&gt;devServer节点下配置，funciton 等复杂类型暂不支持。
猜想能否使用proxy配置反向代理的方式去实现跨域请求，代码如下：
/* h5特有相关 */ "h5" : { "devServer" : { "port" : 8083, //端口号 "disableHostCheck" : true, "proxy" : { "/api" : { "target" : "http://localhost:8866/", //目标接口域名 "changeOrigin" : true, //是否跨域 "secure" : false // 设置支持https协议的代理 } } } } 此时需要用相对路径，不能使用绝对路径。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92b71bda01133c710af437c81169d1b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6e99f7b6f399ef7ca246ecdd26cae31/" rel="bookmark">
			【注意力】ESE：Effective Squeeze-and-Excitation Block
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：https://arxiv.org/pdf/1911.06667.pdf
ESE(Effective Squeeze and Extraction) layer是模型中的一个block，基于SE（Squeeze and Extraction）而来。与SE的区别在于，ESE block只有一个fc层，《CenterMask : Real-Time Anchor-Free Instance Segmentation》的作者注意到SE模块有一个缺点：由于维度的减少导致的通道信息损失。为了避免这种大模型的计算负担，se的2个fc层需要减少通道维度。特别的，当第一个fc层使用r减少输入特征通道，将通道数从c变为c/r的时候，第二个fc层又需要扩张减少的通道数到原始的通道c.在这个过程中，通道维度的减少导致了通道信息的损失。因而，effective SE(eSE)仅仅使用一个通道数为c的fc层代替了两个fc层，避免了通道信息DE丢失；
代码：
def get_act_fn(act=None, trt=False): assert act is None or isinstance(act, ( str, dict)), 'name of activation should be str, dict or None' if not act: return identity if isinstance(act, dict): name = act['name'] act.pop('name') kwargs = act else: name = act kwargs = dict() if trt and name in TRT_ACT_SPEC: fn = TRT_ACT_SPEC[name] elif name in ACT_SPEC: fn = ACT_SPEC[name] else: fn = getattr(F, name) return lambda x: fn(x, **kwargs) class EffectiveSELayer(nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6e99f7b6f399ef7ca246ecdd26cae31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dc6940625be33b6fb5e1380228a526e/" rel="bookmark">
			利用QT实现主界面APP应用开发之经典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在嵌入式的开发过程中，利用好应用开发也是不错的选择。
今天主要和大家聊一聊，如何利用Qt来开发APP主界面，在Qt中提供了QStackedWdget与QTableView这样的控件方便页面切换，但是这种方法比较生硬，体验感较差。也可以自己实现对应滑动界面的设计。
第一：滑动界面的设计基础
#include "slidepage.h"#include &lt;QDebug&gt;#include &lt;QPropertyAnimation&gt;​SlidePage::SlidePage(QWidget *parent):QWidget(parent),pageIndex(0),pageCount(0),draggingFlag(false){ pageIndicator.clear(); this-&gt;setMinimumSize(400, 300); this-&gt;setAttribute(Qt::WA_TranslucentBackground, true);​ scrollArea = new QScrollArea(this); scrollArea-&gt;setAlignment(Qt::AlignCenter);​ mainWidget = new QWidget(); mainWidget-&gt;setStyleSheet("background: transparent");​ scrollArea-&gt;setWidget(mainWidget); scrollArea-&gt;setStyleSheet("background: transparent");​ bottomWidget = new QWidget(this); bottomWidget-&gt;setStyleSheet("background: transparent");​ bottomHBoxLayout = new QHBoxLayout(); bottomWidget-&gt;setLayout(bottomHBoxLayout); bottomHBoxLayout-&gt;setContentsMargins(0, 0, 0, 0); bottomHBoxLayout-&gt;setAlignment(Qt::AlignCenter);/* 关闭滚动条显示 */ scrollArea-&gt;setVerticalScrollBarPolicy( Qt::ScrollBarAlwaysOff); scrollArea-&gt;setHorizontalScrollBarPolicy( Qt::ScrollBarAlwaysOff);​ /* 滚屏对象 */ scroller = QScroller::scroller(scrollArea); QScroller::ScrollerGestureType gesture = QScroller::LeftMouseButtonGesture; scroller-&gt;grabGesture(scrollArea, gesture);​/* 获取属性 */ QScrollerProperties properties = scroller-&gt;scrollerProperties();​/* 设置滑动的时间，值越大，时间越短 */ properties.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dc6940625be33b6fb5e1380228a526e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/777f8748a29e7638b84f8d6b48acc874/" rel="bookmark">
			Latex 爬过的坑(4)——Latex中插入Emoji
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Latex 中插入 Emoji 可以参考这篇博客：在 LaTeX 中使用 Emoji ✌️，该博客对应的 Github 链接为：https://gist.github.com/rxaviers/7360908。
不过该宏包有一些细小的坑帮大家排一下雷：
该宏包仅能够在 lualatex 环境下使用。如果是用的 TeXstudio，在 Options &gt; Build &gt; Default Compiler 中换成 lualatex 环境，否则会报错。
Github 中的 Emoji 代码如下图所示，但是在实际使用时并不需要两个冒号，以 grin 为例，只需要输入 \emoji{grin} 即可。
在 Github 中的 emoji 代码不全，如果查询不到自己想要的 emoji 的代码的话，可以上 Emojipedia 网站，在输入框可以直接输入 emoji，接着将网址中的后缀复制到代码中即可。比如我有个 emoji 😪，我想要该 emoji 的代码，那么我在 Emojipedia 网站的输入框直接输入该 emoji，链接会变为：https://emojipedia.org/sleepy-face/，我们只需要将 sleepy-face 给复制下来放到代码中 \emoji{sleepy-face} 即可。
在 Github 中带有下划线的 emoji 复制到代码中都会报错，比如 \emoji{kissing_closed_eyes} 会报错，这种只需要将下划线变为横线即可：\emoji{kissing-closed-eyes}。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/678f07d55f73c35a404d933a7b1443b1/" rel="bookmark">
			【js组件】自定义select
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单个HTML页面直接运行。
下面是代码：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; body{ background-color: black; color: white; } .KatyLight-select { position: relative; width: 200px; display: inline-block; text-align: center; user-select: none; color: #3b5b65; font-size: .8rem; } .KatyLight-select &gt; .title { padding: .5rem 1rem; background-color: transparent; display: block; box-shadow: inset 0 0 0 2px #96e4ff; color: #96e4ff; } .KatyLight-select &gt; .title:empty::after{ content: '请选择'; color: #3b5b65; } .KatyLight-select &gt; .KatyLight-select-list { display: none; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/678f07d55f73c35a404d933a7b1443b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b137bdeec1c3499679ae33dba4ce90f0/" rel="bookmark">
			element-plus使用中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		element-plus默认是英文，要显示中文需要安装中文包
一、
Element Plus 提供了全局配置国际化的配置。 import ElementPlus from 'element-plus' import zhCn from 'element-plus/es/locale/lang/zh-cn' app.use(ElementPlus, { locale: zhCn, }) 二、Element Plus 还提供了一个 Vue 组件 ConfigProvider 用于全局配置国际化的设置。
&lt;template&gt; &lt;el-config-provider :locale="locale"&gt; &lt;app /&gt; &lt;/el-config-provider&gt; &lt;/template&gt; &lt;script&gt; import { defineComponent } from 'vue' import { ElConfigProvider } from 'element-plus' import zhCn from 'element-plus/lib/locale/lang/zh-cn' export default defineComponent({ components: { ElConfigProvider, }, setup() { return { locale: zhCn, } }, }) &lt;/script&gt; 三、如果通过 CDN 使用 Element Plus ，那么你需要添加以下代码，以下是一个 unpkg 的示例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b137bdeec1c3499679ae33dba4ce90f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0714dfd68cf1753bd2bfd99f237a63b/" rel="bookmark">
			ubuntu 安装 Eigen 及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu 安装 Eigen 及使用 安装 命令安装
sudo apt-get install libeigen3-dev 默认安装路径在:
/usr/include/eigen3 注: 如果默认安装路径不在此路径下, 也可能在 /usr/local/include/eigen3 或者其他路径下, 下面的操作对应即可.
使用 使用 Eigen 的方法有如下几种:
包含头文件 &lt;eigen3/Eigen/Dense&gt; 因为默认安装路径在 /usr/include/eigen3 下, 编译器去查找路径时只能找到 include 文件下, 故不可直接包含头文件 &lt;Eigen/Dense&gt;, 需包含头文件 &lt;eigen3/Eigen/Dense&gt;
#include &lt;iostream&gt; #include &lt;eigen3/Eigen/Dense&gt; using namespace std; int main() { Eigen::MatrixXi m(2, 2); m &lt;&lt; 1, 2, 3, 4; cout &lt;&lt; m &lt;&lt; endl; return 0; } 包含头文件 &lt;Eigen/Dense&gt; 大多数的程序包含的都是 &lt;Eigen/Dense&gt; 头文件, 如果想这样包含的话需要将 eigen 下的 Eigen 文件提升一级目录, 即将 Eigen 从 /usr/include/eigen3 放到 /usr/include/ 下, 如下命令:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0714dfd68cf1753bd2bfd99f237a63b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/149e281b2ab71dd9ab729b8d2dc2fb81/" rel="bookmark">
			树莓派、jetson nano 安装pycharm arm架构64 aarch64
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pycharm、javajdk
链接：https://pan.baidu.com/s/1o0Y4DU-CnaDx5OdLitA66g 提取码：2d4r pycharm2021最低使用Java11版本
解压：
tar -zxvf Java包
tar -zxvf pycharm包
配置环境变量：
sudo gedit /etc/profile 写入：
export JAVA_HOME=/usr/local/java/jdk-11.0.14/ export JRE_HOME=${JAVA_HOME}/jre export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar JAVA_HOME根据实际情况填写
jre不需要，不用管（Java11之后jre集成在jdk中，若使用的话需要自行编译，百度）
终端：
source /etc/profile 验证：
java -version
出现版本号，成功
然后运行pycharm：
进入解压后的pycharm，
使用：
./pycharm.sh 或者 sh pycharm.sh 此时若提醒没有jre，且java -version成功，则重启即可，
重启后运行pycharm，成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc9a790f4f7ee09dc05961b8ea0252f3/" rel="bookmark">
			Draco - glTF模型压缩利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Draco 是用于网格压缩的 glTF 扩展以及由 Google 开发的开源库，用于压缩和解压缩 3D 网格以显着减小 3D 内容的大小。它压缩顶点位置、法线、颜色、纹理坐标和任何其他通用顶点属性，从而提高在网络上传输 3D 内容的效率和速度。
这意味着 更小的文件大小 和 更快的流式传输，尤其是在 3D Tiles 的情况下，当新的图块出现或需要新的细节级别时，它经常流式传输新的 glTF 模型。
我们一直在与 Khronos 和 Google 合作使 Draco 成为 glTF 扩展，你现在可以在 Cesium 中加载 Draco 压缩模型和 3D 瓦片集！
2、Khronos glTF Draco 压缩扩展 glTF 现在有 KHR_draco_mesh_compression 扩展，它可以加载包含 Draco 压缩几何的缓冲区。从 Cesium 1.44 开始，我们通过利用 Google 的开源 JavaScript 解压缩库支持使用 Draco 压缩数据加载 glTF 资产。
使用压缩网格可以减少 glTF 模型的最终文件大小，这意味着这些资产占用的空间更少，下载的数据更少，流传输更快。为了说明差异，我们使用Draco 编码器压缩了以下文件 ，所有属性的默认压缩级别为 7。
这是 glTF 2.0 Draco 压缩Cesium牛奶卡车示例模型 与 glTF 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc9a790f4f7ee09dc05961b8ea0252f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d7a8e992cde156b1bb0036905491f93/" rel="bookmark">
			LeetCode(C&#43;&#43;)-动态规划(打家劫舍、打家劫舍II、打家劫舍III)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		198. 打家劫舍 代码： class Solution {	//198. 打家劫舍 //动态规划五部曲： //1. 确定dp数组以及下标的含义：下标为i以内的房屋，能够偷窃到的最高金额为dp[i] //2. 确定递推公式：dp[i]=max(dp[i-2]+nums[i],dp[i-1]); //3. dp数组如何初始化：dp[0]=nums[0] dp[1]=max(nums[0],nums[1]) //4. 确定遍历顺序：从前往后 //5. 举例推导dp数组： public: int rob(vector&lt;int&gt;&amp; nums) { if (nums.size() == 1)return nums[0]; vector&lt;int&gt; dp(nums.size()); dp[0] = nums[0]; dp[1] = max(nums[0],nums[1]); for (int i = 2; i &lt; nums.size(); ++i) { dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[nums.size() - 1]; } }; 213. 打家劫舍 II 代码： class Solution {	//213.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d7a8e992cde156b1bb0036905491f93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1796d59ddc80015c32feccb4b7a33f2d/" rel="bookmark">
			考研之操作系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		页面 页表项 页框 最近在复习操作系统的基本分页存储管理的概念时遇到了一个理解上的问题，记录一下。
----------------------------------------------分割线----------------------------------------------
王道书上将页表项的块号和内存页框一一划线连接，乍一看以为是一个页表项对应一个页框，一个页框只能对应一个页表项，而王道的视频在讲这个内容时（操作系统3.1.7）会出现一个页表框放了很多页表项，这是怎么回事呢？
这里我理解失误，想了很长时间，最后想明白，应该这样理解：首先，页表项的块号需要记录页框的编号，页框的标号越多，页表项需要的空间就越大，这是用来求页表项的大小的，这是其一。再次，由于页表在内存中（PCB中），页面需要在内存中利用页表找到对应的块号，而内存又被分块了，所以，其实王道所讲的真正的目的是算一下在给定的页框大小情况下能放多少页表项。总而言之，就是把页表项尽可能全部放在一个内存页框中（页框存放多个页表项的原因），然后页面在内存中访问页表项找到相应的块号（形成了块号和页框一一对应）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd45a1b8f8a05401532487353f7222ba/" rel="bookmark">
			免费安装Visual Studio 2022
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我使用软件的选择顺序是优先选择开源软件，其次是社区免费版本，大部分时间我都是在linux下开发，很少在windows下写代码。但是在这microsoft还是处于统治地位的时代，而且很多新手写代码开始还是倾向于在windows下，因此推荐Visual Studio 2022 社区版，即满足我的个人选择倾向，也是很多人需要的，下面介绍如何使用免费社区版的VS2022。
1、下载 下载地址为：Visual Studio: 面向软件开发人员和 Teams 的 IDE 和代码编辑器
打开网页，找到这个地方
选择community 2022版本，这个是免费使用的，所以你不用去找破解，但是在下载前可能需要欧用邮箱注册 。
或者拉倒网页最后，找这个图片内容
2、安装 下载很快，但是并不是下载了VisualStudioSetup.exe，体积很小，他实际上是一个下载器。运行这个可执行程序，才是真正的下载开始，这个是需要花点时间的，只需要等。
然后根据你的需要去选择组件安装
3、安装完成就可以启动VS2022开始创建工程写代码了 具体怎么创建工程自己摸索吧。
提示：
C++、C、汇编语言开发工具和库都可用作 Windows 中 Visual Studio 的一部分。你可以在 Visual Studio 中使用 C++ 创建任何内容，从简单的控制台到 Windows 桌面应用、从设备驱动程序和操作系统组件到移动设备的跨平台游戏，以及从小型 IoT 设备到 Azure 云中的多服务器计算。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4cbfaa38cfa58540a1d1cd15dbb2279/" rel="bookmark">
			quartus II SignalTap 在线调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、调用SignalTap工具 调用SignalTap工具之前，默认已经打开工程
在tools工具栏下找到signaltap，单击即可添加该工具
然后看到文件添加进工程，重新编译工程，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/266f84972753a8bf6edb69c631c20810/" rel="bookmark">
			Simhash算法及python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 为什么需要Simhash? 传统相似度算法：文本相似度的计算，一般使用向量空间模型(VSM)，先对文本分词，提取特征，根据特征建立文本向量，把文本之间相似度的计算转化为特征向量距离的计算，如欧式距离、余弦夹角等。
缺点：大数据情况下复杂度会很高。
Simhash应用场景：计算大规模文本相似度，实现海量文本信息去重。
Simhash算法原理：通过hash值比较相似度，通过两个字符串计算出的hash值，进行异或操作，然后得到相差的个数，数字越大则差异越大。
2. 文章关键词特征提取算法TD-IDF 词频（TF）：一个词语在整篇文章中出现的次数与词语总个数之比；
逆向词频（IDF)：一个词语，在所有文章中出现的频率都非常高，这个词语不具有代表性，就可以降低其作用，也就是赋予其较小的权值。
分子代表文章总数，分母表示该词语在这些文章出现的篇数。一般会采取分母加一的方法，防止分母为0的情况出现，在这个比值之后取对数，就是IDF了。
最终用tf*idf得到一个词语的权重，进而计算一篇文章的关键词。然后根据每篇文章对比其关键词的方法来对文章进行去重。simhash算法对效率和性能进行平衡，既可以很少的对比（关键词不能取太多），又能有好的代表性（关键词不能过少）。
3. Simhash原理 Simhash是一种局部敏感hash。即假定A、B具有一定的相似性，在hash之后，仍然能保持这种相似性，就称之为局部敏感hash。
得到一篇文章关键词集合，通过hash的方法把关键词集合hash成一串二进制，直接对比二进制数，其相似性就是两篇文档的相似性，在查看相似性时采用海明距离，即在对比二进制的时候，看其有多少位不同，就称海明距离为多少。
将文章simhash得到一串64位的二进制，根据经验一般取海明距离为3作为阈值，即在64位二进制中，只要有三位以内不同，就可以认为两个文档是相似的，这里的阈值也可以根据自己的需求来设置。也就是把一个文档hash之后得到一串二进制数的算法，称这个hash为simhash。
simhash具体实现步骤如下：
1. 将文档分词，取一个文章的TF-IDF权重最高的前20个词（feature）和权重（weight）。即一篇文档得到一个长度为20的（feature：weight）的集合。
2. 对其中的词（feature），进行普通的哈希之后得到一个64为的二进制，得到长度为20的（hash : weight）的集合。
3. 根据（2）中得到一串二进制数（hash）中相应位置是1是0，对相应位置取正值weight和负值weight。例如一个词进过（2）得到（010111：5）进过步骤（3）之后可以得到列表[-5,5,-5,5,5,5]。由此可以得到20个长度为64的列表[weight，-weight...weight]代表一个文档。
4. 对（3）中20个列表进行列向累加得到一个列表。如[-5,5,-5,5,5,5]、[-3,-3,-3,3,-3,3]、[1,-1,-1,1,1,1]进行列向累加得到[-7，1，-9，9，3，9]，这样，我们对一个文档得到，一个长度为64的列表。
5. 对（4）中得到的列表中每个值进行判断，当为负值的时候去0，正值取1。例如，[-7，1，-9，9，3，9]得到010111，这样就得到一个文档的simhash值了。
6. 计算相似性。两个simhash取异或，看其中1的个数是否超过3。超过3则判定为不相似，小于等于3则判定为相似。
Simhash整体流程图如下：
4. Simhash的不足 完全无关的文本正好对应成了相同的simhash，精确度并不是很高，而且simhash更适用于较长的文本，但是在大规模语料进行去重时，simhash的计算速度优势还是很不错的。
5. Simhash算法实现 # !/usr/bin/python # coding=utf-8 class Simhash: def __init__(self, tokens='', hashbits=128): self.hashbits = hashbits self.hash = self.simhash(tokens) def __str__(self): return str(self.hash) # 生成simhash值 def simhash(self, tokens): v = [0] * self.hashbits for t in [self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/266f84972753a8bf6edb69c631c20810/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8bdd340953c196d74327bf21e0b6ab2/" rel="bookmark">
			彩色图像高频与低频成分的分解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 彩色图像高频与低频成分的分解 import torchgeometry import cv2 import torch import numpy as np def calc_Freq(torch_img, kernel=3): if kernel == 3: sigma = 3 elif kernel == 5: sigma = 1.5 else: sigma = 1 lowFreq = torchgeometry.image.gaussian_blur( torch_img, (kernel, kernel), (sigma, sigma) ) highFreq = torch_img - lowFreq return lowFreq, highFreq 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f824492bdd763cb82dcb2fddfd173715/" rel="bookmark">
			js中的WebSocket
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、WebSocket定义：
html5提供的单个TCP连接上进行全双工通信的协议。WebSocket允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。
二、WebSocket特点：
在实现数据推送时，多数都是ajax轮询（在特定的时间间隔，由浏览器主动发起请求，会占用很多带宽和服务器资源）。而WebSocket建立TCP连接后，服务器可以主动给客户端传递数据，能够更好的节省服务器资源和带宽，实现更实时的数据通讯。因为WebSockets只能通过连接发送纯文本数据和二进制数据，所以对于复杂的数据结构，在通过连接发送之前，必须进行JSON.stringify()序列化。协议标识符是ws（加密则为wss），服务器网址就是 URL。如“ws://localhost:8080"。 三、WebSocket用法：
WebSocket的所有操作都是采用事件的方式触发的，这样不会阻塞UI，使得UI有更快的响应时间和更好的用户体验。
浏览器通过Javascript向服务器发出建立WebSocket连接的请求，连接建立后，客户端和服务器就可以通过TCP连接直接交换数据。当获取WebSocket连接后，可以通过send()方法向服务器发送数据，可以通过onmessage事件接收服务器返回的数据。
实例 var ws = new WebSocket(path [,protocols]);
path：要连接的 URL，这应该是 WebSocket 服务器将响应的 URL。
protocols(可选)：一个协议字符串或者一个包含协议字符串的数组。
属性 ws.readyState
ws.bufferedAmount
...
方法 ws.send()
ws.close()
事件 ws.onopen
ws.onmessage
ws.close
ws.onerror
//创建一个webSocket实例，执行后，客户端就会与服务端连接 var ws = new WebSocket("ws://localhost:8080"); //当WebSocket创建成功时，触发onopen事件 ws.onopen = function(){ console.log("open"); // 复杂的数据结构，在通过连接发送之前，必须进行序列化。 const json = JSON.stringify({ type: 'keepalive', id: '' }); ws.send(json); //将消息发送到服务端 } //当客户端收到服务端发来的消息时，触发onmessage事件 ws.onmessage = function(e){ //e.data 的数据格式也是字符串，手动解析这些数据才能得到其他格式的数据。 const _data = JSON.parse(e.data); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f824492bdd763cb82dcb2fddfd173715/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0875a63b374e9e047f0bbb3ae6f0fb9e/" rel="bookmark">
			纯html实现input输入框选择日期时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;Show a Date and Time Control&lt;/h1&gt; &lt;form action="/action_page.php"&gt; &lt;label for="birthdaytime"&gt;Birthday (date and time):&lt;/label&gt; &lt;input type="datetime-local" id="birthdaytime" name="birthdaytime"&gt; &lt;input type="submit"&gt; &lt;/form&gt; &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; type="datetime-local" is not supported in Internet Explorer 11 or prior Safari 14.1.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 参考
https://www.w3schools.com/tags/tryit.asp?filename=tryhtml5_input_type_datetime-local
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f1fd40f77756ef0f0bcf91c175e3086/" rel="bookmark">
			亲测可用fiddler手机抓包配置代理后没有网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次使用fiddler抓包，手机配置我自己的电脑代理后发现没有网络连接，配置别人的代理就有网络连接。经过百度，尝试了各种方法之后成功解决，以下记录整个操作过程：
1.确认手机代理没有配置错误：
电脑查找id地址的方法：开始——运行——cmd——确定——ipconfig——回车；
IPv4地址就是电脑的id地址：
手机HTTP代理里面的配置代理，选择手动，然后在服务器中输入电脑的ip地址，端口输入fiddler中设置的端口（一般是8888）；
2.修改注册表信息；
打开注册表：运行——cmd——确定——regedit——回车，在HKEY_CURRENT_USER\Software\Microsoft\Fiddler2下创建一个DWORD，值置为80（十进制）（右键，选择新建）：
3.编辑fiddlerScript rule；
在fiddler菜单栏中，点击Rules，选择Customize Rules，然后通过ctrl+f查找OnBeforeRequest方法添加一行代码；
if (oSession.host.toLowerCase() == "webserver:8888") { oSession.host = "webserver:80"; }
12345 PS：我的电脑在设置了这些之后，重新打开fiddler发现还是不行，依然没有网络连接，于是我就想到了是不是安装证书的问题，我就把证书重新安装，然后重新打开fiddler，果然就可以了。以下为重新安装证书的操作步骤：
1.在fiddler菜单栏中，点击Tools，选择Options…
2.点击HTTPS，选择Actions，然后选择Reset All Certificates，点击确定；
3.接着就会弹出安装证书的提示信息，选择YES，安装证书；
4.安装好了之后，在Actions中选择Open Windows Certificate Manager，可以查看到安装好的证书。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/946932b8efd68b10cda0508727ff8de7/" rel="bookmark">
			keras对MNIST数据集分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用keras工具对MNIST数据集分类 first step : 环境配置 -keras —— 神经网络搭建 —— *conda install keras* -numpy ——数据集的处理 —— *conda install numpy* second step ：数据集的导入 各种数据集的导入都需要用到keras的dataset包，如果使用这个包，他会默认前往亚马逊下载数据集，如果需要使用本地包只能修改源码。
或者可以利用其他方法载入数据集，只要在训练前，完成格式转换就可以。
from keras.dataset import mnist (trainX,trainY),(testX,testY)= mnist.load_data(path='./dataset/mnist.npz') #&lt;class 'numpy.ndarray'&gt; Y:(60000) 需要注意one_hot # 同时 样本 像素为255 from keras.utils import np_utils trainY = np_utils.to_categorical(trainY, 10) import tflearn.datasets.mnist as mnist X, Y, testX, testY = mnist.load_data(one_hot=True) third 搭建模型，作者也属于初学keras，下面代码所示属于线性网络结构，所以并不复杂，另外可以再加入卷积池化，还可以自定网络的损失函数，这些可以在后面接触。
def model(): model =Sequential() model.add(Flatten()) model.add(Dense(1024)) #三个全连接 + softmax激活 model.add(Dense(512)) model.add(Dense(128)) model.add(Dense(10)) model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/946932b8efd68b10cda0508727ff8de7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d4c20b45ac514e58995ba02c12ca68d/" rel="bookmark">
			ESP32系列--第九篇 ADC的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、目的 本篇主要介绍ESP32的ADC功能，ESP32有两个ADC模块，分别为ADC1/ADC2，每个ESP32系列具有的通道数不一样，详情请看下表。
在WiFi在使用时，ADC2的使用受到一些限制，实际应用场景中一般只使用ADC1即可。
二、介绍 ADC的IO引脚分配 ESP32系列 （下表来自ESP-IDF开发文档）
GPIO
Analog Function
RTC GPIO
Comments
GPIO0
ADC2_CH1
RTC_GPIO11
Strapping pin
GPIO1
TXD
GPIO2
ADC2_CH2
RTC_GPIO12
Strapping pin
GPIO3
RXD
GPIO4
ADC2_CH0
RTC_GPIO10
GPIO5
Strapping pin
GPIO6
SPI0/1
GPIO7
SPI0/1
GPIO8
SPI0/1
GPIO9
SPI0/1
GPIO10
SPI0/1
GPIO11
SPI0/1
GPIO12
ADC2_CH5
RTC_GPIO15
Strapping pin; JTAG
GPIO13
ADC2_CH4
RTC_GPIO14
JTAG
GPIO14
ADC2_CH6
RTC_GPIO16
JTAG
GPIO15
ADC2_CH3
RTC_GPIO13
Strapping pin; JTAG
GPIO16
SPI0/1
GPIO17
SPI0/1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d4c20b45ac514e58995ba02c12ca68d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/257bd00fa3a7436c732d17c70a23a476/" rel="bookmark">
			技术干货 | MindSpore AI科学计算系列（四）：AlphaFold2分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
蛋白质折叠这个被列为“21世纪的生物物理学”的重要课题之一，已经困扰了科学家们近半个世纪，好消息是在两年一届的CASP比赛中，2020年谷歌deepmind团队的Alphafold2凭借其接近90分的成绩取得CASP14比赛中蛋白质3D结构预测的榜首，这一成就被Nature等杂志喻为前所未有的进步。
近期AlphaFold2连续两登Nature着实在又生物和科研圈火了一把，首先是在7月15日宣布开源，
https://github.com/deepmind/alphafold
并将长达六十多页的代码解析及数据集对外公开，我们团队也第一时间对代码进行了复现，并重跑了CASP14的比赛数据集，发现结果确如人所愿，大部分的结果均可达到将近90分（TM-score）的高分，然而一些序列不太长的蛋白质序列的结果反而差强人意，其原因我在后文会进一步介绍。紧随其后一周之后的7月22日，谷歌再度Nature发声，宣布将会把覆盖人类98.5%的蛋白质预测结果对外公开，其中58%达到了可信水平，35.7%达到了高置信度，要知道之前科学家经过几十年的努力靠着实验观测手段才覆盖了人类蛋白质序列中17%的蛋白质。
那么什么是蛋白质折叠问题呢
引用维基百科的描述如下：蛋白质折叠（英语：Protein folding）是蛋白质获得其功能性结构和构象的物理过程。通过这一物理过程，蛋白质从无规则卷曲折叠成特定的功能性三维结构。在从mRNA序列翻译成线性的氨基酸链时，蛋白质都是以去折叠多肽或无规则卷曲的形式存在。
简单来说蛋白质是由氨基酸序列组成的，人体内常见氨基酸种类为20种，这20种氨基酸的排列组合形成特定的氨基酸链时，经过mRNA翻译形成氨基酸的肽链，随后由于氨基酸之间在分子力的作用下扭曲旋转而形成三维空间结构的过程即是蛋白质折叠过程，而最终形成的这个空间结构决定了蛋白质的功能特性。因此如果能快速知道一种蛋白质的空间结构，那么科学家就可以了解其生物功能特性，如何通过蛋白质的一级氨基酸序列获得其生理形态的三维空间结构即是蛋白质折叠问题。
表1：常见20种氨基酸
为什么说蛋白质折叠问题困扰人类近半个世纪呢
想要得到蛋白质的空间结构传统的观测手段为通过冷冻电镜，x射线晶体衍射，二维核磁共振等手段。对于X射线晶体衍射和二维核磁共振，需要经过基因表达，蛋白质提取和纯化，蛋白质结晶等过程，其中仅仅获取纯度较高的蛋白质晶体这一步就非常困难，不仅要考虑温度还要考虑溶剂环境等的影响，实验周期可达数月之久，近年来出现的冷冻电镜虽观测精度高，但价格昂贵（单价数千万人民币），对操作手段，观测一个蛋白质就需几十万及以上的的成本。
另外1958年F.H.C. 克里克提出了生物学中著名的中心法则：DNA-RNA-蛋白质，并指出蛋白质是由DNA转录为RNA,再由RNA翻译成一个个氨基酸组合而成的，因此蛋白质的一级氨基酸序列信息应该包含了蛋白质三维空间结构的必要重要信息。从此越来越多的人开始尝试通过科学计算的方法从蛋白质一维氨基酸序列直接推导出其三维构想，但因蛋白质的每个氨基酸的侧链，甚至氨基酸与氨基酸之间形成的肽键均可以旋转，其每个原子位置均需要确定，因此整个蛋白质的空间构想种类可达10^300之大，这可比宇宙中所有原子的数量还大，由此出现了CASP（Critical Assessment of protein Structure Prediction）比赛，用于激励大家参与解决蛋白质折叠问题，该赛事成立于1994年，每两年举办一次，也是计算生物学领域中最权威和最富盛名的比赛，最新2020年的比赛为CASP14，alphafold2即在该比赛中拿到了结构预测的第一名。
解决蛋白质折叠问题有什么意义
解决蛋白质折叠问题后可从蛋白质的一维序列获取其三维结构，这对新药研发，蛋白质设计有着至关重要的作用。
如人体内的抗体蛋白，就是通过其特殊的“Y”型结构和特定的病毒或细菌结合从而消灭他们，再比如人体内的胶原蛋白，其结构如绳索一般，具有很强的韧性，可以传递张力，广泛存在于软骨，韧带等，了解蛋白质的空间结构后就可以更好的了解其活性中心，配体靶点等，甚至可以改造蛋白质从而让其满足特性的功能需求。
传统的药物设计一般是通过筛选大量的天然化合物，寻找易与目标蛋白质分子紧密结合，容易合成且没有毒副作用来完成的，因此研发周期较长，费用较高，而了解蛋白质的空间结构后可以减少这种寻找药物的盲目性，缩短研发周期和降低成本。
AlphaFold2算法相关
整个算法框架如图所示为end2end结构，可以大体分为三个部分，分别是数据处理，网络和结构预测，总输入为单个蛋白质序列。数据处理部分集成了生成MSA和查找templates（模板，包含了MSA中与源序列相似的已知蛋白质结构信息）的部分，另外还引入了pairing信息（包含每个残基-残基对儿的特征。简单来说每个残基之间都有一个隐性的状态来描述其之间的关系，这个信息即被文章里称为pairwise features）。
MSA, pairing, templates 被输入到Evoformer网络中，其中pair 信息和MSA信息相互迭代更新，并输入到结构预测模块Structure module，最终得到3D结构信息。
Evoformer 模块
Evoformer模块的输入如上图所示，因alphafold2选取的MSA长度为128，但很多蛋白质的MSA包含了最多5000条蛋白质序列，因此这里除了随机选取128条作为输入外，还将剩余的MSA序列对选取的作中心聚类，然后作为extra-msa信息， template信息与MSA和pair进行简单的相加与concat之后再加入extra-msa信息作为整个Evoformer的输入部分。
在网络架构中接收前面提取的MSA和pair表征后，不仅有横向的attention对当前氨基酸序列的所谓位置进行attention计算，还有纵向的attention去获取其他MSA序列相同位置上氨基酸的突变与稳定性信息。MSA经过横纵attention之后再经过一个transition层，然后通过计算外积并取平均来计算pairwise features。对于pairwise features的更新采用的是三角法则原理，原因是pairwise features信息记录了残基之间的两两距离关系，因距离关系不是自由的，应该满足三角不等式，即：相邻的三个边应该满足两边之和大于等于第三边，所以对于每个边，即pairwise features里的每个pair信息都会接收和其相关的可组成三角形的任意两个边来进行更新。
Structure module 部分
接着就来到了结构更新模块，该模块以经过Evoformer 网络层后得到的pair features信息，原始的序列信息（MSA中只保留目标氨基酸序列，丢弃剩余MSA作为single repr）以及将所有残基位置的初始化空间结构信息作为输入，首先经过IPA(invariant point attention)模块更新序列表征信息，更新后的single repr被映射到主链上通过欧几里得变换并更新坐标信息，在通过计算主链以及侧链的旋转角度信息，最终更新得到预测的全原子坐标，感兴趣的可以查看alphafold2的suppl文献。
了解了alphafold2的整体流程之后，可以发现MSA以及template的信息对于最终的预测结果起到非常重要的作用，从预测结果来看，对于同源已知蛋白质数量越多的目标序列，其预测结果准确率越高，而对于同源蛋白质数量很少的那些预测结果则较差，如我们使用AlphaFold2预测了CASP14中的T1043号蛋白，虽然其氨基酸序列长度仅为148（相比CASP14其他蛋白较小），但是预测结果却比较差(如图所示，蓝色为预测值，红色为真实值)，TM-score仅为20多，原因就是该序列的同源模板数量仅为个位数。
总结一下
1. Alphafold2广泛使用了transformer结构，不管是MSA还是残基-残基对的信息更新都使用了attention机制，结构模块的更新使用了三角法则，简化了计算的复杂度，准确率也提高了不少。
2. 整个模型的Evoformer和structure module部分都使用了recycling，即将输出重新加入到输入在重复refinement，进行信息的精炼。
3. 对于训练部分，先进行了预训练，然后把MSA中没有标签的序列预测出三维结构，再将这些训练结果置信度较高的结构保存下来重新进行训练
4. 对msa还做了masked attention自监督训练
然而我们发现在推理的过程中使用到的都是现有的蛋白库，对于那些MSA序列长度还可以，但是模板较少的目标序列而言，其预测精度较低，那是不是可以在推理的过程中也把MSA中没有结构信息的序列进行预测，再把结果保留下来当做template来做预测呢，这个感兴趣的同学也可以一起思考下。
参考资料
1. https://predictioncenter.org/index.cgi
2. https://alphafold.ebi.ac.uk/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/257bd00fa3a7436c732d17c70a23a476/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a695879a5f369f1ee0d4a106c3ddeed/" rel="bookmark">
			应用使用Druid连接池经常性断链问题分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间有应用使用Druid连接池经常的提示断链报错，整个问题排查分析过程很有意思。这里将Druid连接池、数据库层以及负载均衡层的配置分析下，记录整个问题的分析过程，同时梳理下Druid连接池的配置和连接保活及回收机制。
1、问题背景 应用通过数据库连接池申请连接，再通过负载均衡连接到数据库代理然后访问数据库，这是一个典型的架构，如下图所示：
但是系统上线后应用总是出现偶发性的断链报错，经常性的出现以下错误信息：
discard connection com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure The last packet successfully received from the server was 72,557 milliseconds ago. The last packet sent successfully to the server was 0 milliseconds ago. 根据错误日志初步判断肯定是与 DB之间的链接已经断开，尝试使用了一个已经断开的链接才会引起这个错误发生，但是根据Druid的连接检查功能，不应出现这样的问题。接下去了解下Druid连接池的基本配置以及连接保活和回收机制。
2、Druid连接池 2.1 Druid连接概览 Druid是开源的数据库连接池，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况。
在druidDataSource中有一个重入锁和衍生的两个condition：一个监控连接池是否为空，一个监控连接池不为空。在druidDataSource中有两个线程，一个生成连接CreateConnectionThread，一个回收连接DestoryConnectionThread。在创建、获取、回收的时候都会使用这些锁和condition。每次获取Connection都会调用init，内部使用inited标识DataSource是否已经初始化OK。每次获取Connection都会需要进行加锁保证线程安全，所有操作都在加锁后执行。如果连接池内没有连接了，则调用empty.signal()，通知CreateThread创建连接，并且等待指定的时间，被唤醒之后再去查看是否有可用连接。 2.2 Druid参数配置说明 1）基本属性
name：配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。如果没有配置，将会生成一个名字，格式是：“DataSource-” + System.identityHashCode(this).url：连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql://10.20.153.104:3306/druid2、oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnautousername：连接数据库的用户名password：连接数据库的密码driverClassName：这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName 2）连接池大小
initialSize：初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时。缺省值为0maxActive：最大连接池数量。缺省值为8minIdle：最小连接池数量。缺省值为0maxWait：获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。缺省值为-1 3）连接检测
testOnBorrow：申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。缺省值为truetestOnReturn：归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。缺省值为falsetestWhileIdle：建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。缺省值为falsetimeBetweenEvictionRunsMillis：有两个含义：1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。2) testWhileIdle的判断依据。缺省值为60smaxEvictableIdleTimeMillis：连接空闲时间大于该值，不管minidle是多少都关闭这个连接。缺省值为7小时minEvictableIdleTimeMillis：连接空闲时间大于该值并且池中空闲连接数大于minidle则关闭这个连接。缺省值为30分钟maxPoolPreparedStatementPerConnectionSize：要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100。缺省值为-1PhyTimeoutMillis：物理连接打开的时间超过这个超时时间，并且不再使用时会关闭这个物理连接，一般不建议打开validationQuery：用来检测连接是否有效的sql，要求是一个查询语句，常用select ‘x’。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。缺省值为nullvalidationQueryTimeout：单位：秒，检测连接是否有效的超时时间。底层调用jdbc Statement对象的void setQueryTimeout(int seconds)方法。缺省值为-1keepAlive：连接池中的minIdle数量以内的连接，并且连接的空闲时间大于keepAliveBetweenTimeMillis但小于minEvictableIdleTimeMillis，则会执行validationQuery来保持连接的有效性。缺省值为falsekeepAliveBetweenTimeMillis：打开KeepAlive时，当连接的空闲时间超过该值，会使用validationQuery执行一次查询，检查连接是否可用。缺省值为120s 4）缓存语句
poolPreparedStatements：是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。缺省值为falsesharePrepareStatementsmaxPoolPreparedStatementPerConnectionSize：要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100。缺省值为-1 2.3 Druid连接池使用 使用druid连接池，主要是使用DruidDataSourceFactory创建出DataSource数据源对象，然后调用其getConnection方法获取数据库连接对象，拿到连接对象之后，和其它数据库连接不同的是当调用连接的close方法时，底层不再是关闭销毁连接对象，而是将连接对象放入到连接池中，以便后续新的请求到来时，直接拿去使用。
import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a695879a5f369f1ee0d4a106c3ddeed/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/225/">«</a>
	<span class="pagination__item pagination__item--current">226/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/227/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>