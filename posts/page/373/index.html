<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6b4b651ac090d9491e158bc2d212f04/" rel="bookmark">
			Sigmoid/Tanh/ReLu激活函数的优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		激活函数的作用 引入非线性，增强神经网络的表达能力
Sigmoid/Tanh/ReLu激活函数的优缺点 这三个激活函数都没能解决梯度消失 梯度弥散就是梯度消失。
一种很流行的说法是Relu解决了梯度消失的问题，其实并不是这样。
单从激活函数的导数来说，看激活函数的“死区”范围，即导数接近于0的区间。Sigmoid和Tanh仅0附近一小段范围非死区；即使是Relu仍有一半的死区。
此外，梯度不仅包括激活函数的导数，还有输出值。不能指望一个激活函数能解决梯度消失。不同的激活函数对输出有不同的影响。要考虑的东西就更多了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2acb95024a60d01eff51bad479fa2c78/" rel="bookmark">
			CSAPP:BombLab(深入了解计算机系统配套实验)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSAPP:BombLab CSAPP:BombLab实验原理实验过程phase 1phase 2phase 3phase 4phase 5phase 6secret phase CSAPP:BombLab 新手小白，第一次写博客，算是记录一下做的一些有意思的东西，分享给大家。有一些理解不够深刻，甚至出错的地方，还请大家见谅，并帮我指正，谢谢！
这是一个《深入了解计算机系统》教学的配套实验，肝了一个下午加一整个晚上，总结了一下整个过程。这里我使用的是Ubuntu16.04的虚拟机。
实验原理 通过gdb对二进制文件进行反汇编，阅读相应的汇编代码，并使用gdb进行断点调试和内存读取，从而破译共七个炸弹，包括六个常规炸弹和一个隐藏炸弹。
实验过程 在Ubuntu终端打开gdb，输入命令objdump -d bomb&gt;bomb1.asm，将二进制文件反汇编为汇编代码文件，然后输入gdb ./bomb命令，使用gdb打开二进制文件bomb。这样可以在阅读汇编代码的同时对程序进行调试。
在main函数的汇编代码段中，可以看到分别调用了&lt;phase_1&gt;、&lt;phase_2&gt;、&lt;phase_3&gt;、&lt;phase_4&gt;、&lt;phase_5&gt;、&lt;phase_6&gt;代码段，它们分别对应着各个炸弹的函数。我们只要对这些代码段进行分析就可以找到拆解炸弹的方法。
phase 1 phase 1很简短，其汇编代码：
0000000000400ee0 &lt;phase_1&gt;: 400ee0:	48 83 ec 08 sub $0x8,%rsp 400ee4:	be 00 24 40 00 mov $0x402400,%esi //%esi中的地址为0x402400 400ee9:	e8 4a 04 00 00 callq 401338 &lt;strings_not_equal&gt; //调用字符串比较，相同则eax为0 400eee:	85 c0 test %eax,%eax //是否相同 400ef0:	74 05 je 400ef7 &lt;phase_1+0x17&gt; 400ef2:	e8 43 05 00 00 callq 40143a &lt;explode_bomb&gt; 400ef7:	48 83 c4 08 add $0x8,%rsp 400efb:	c3 retq 其中引用了&lt;strings_not _equal&gt;代码段，从字面上看是比较字符串，其汇编代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2acb95024a60d01eff51bad479fa2c78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/face85dafdbd89c5e4bb970e52712dae/" rel="bookmark">
			微信小程序配置顶部导航条标题颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 { "window":{ "navigationBarBackgroundColor": "#ffffff", "navigationBarTextStyle": "black", "navigationBarTitleText": "微信接口功能演示", "backgroundColor": "#eeeeee", "backgroundTextStyle": "light" } } navigationBarBackgroundColor 导航栏背景颜色，如”#000000”
navigationBarTextStyle 导航栏标题颜色，仅支持 black/white
navigationBarTitleText 导航栏标题文字内容
backgroundColor 窗口的背景色
backgroundTextStyle 下拉背景字体、loading 图的样式，仅支持 dark/light
enablePullDownRefresh 是否开启下拉刷新，详见页面相关事件处理函数。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21f4f7a6a2d5bafb70e2b27a545febbb/" rel="bookmark">
			C&#43;&#43;简单的TCP/IP服务端与客户端（附完整代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. TCP服务端 （一）创建一个TCP服务端 可大致分为以下5个步骤：
1.初始化环境 2.创建监听套接字 3.监听套接字与IP地址及端口绑定 4.监听套接字 5.等待客户端连接 1. 初始化环境 WSADATA	wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); WSAStartup()函数的调用指明Windows Sockets API的版本号及获得特定Windows Sockets实现的细节，应用程序或DLL只能在一次成功的WSAStartup()调用之后才能调用进一步的Windows Sockets API函数。
该函数执行成功后返回0。
2. 创建监听套接字 m_listenSocket = socket(AF_INET, SOCK_STREAM, 0)); AF_INET：指定使用IPV4协议簇
SOCK_STREAM：字节流，数据有保障的传输
0：不希望指定协议
该函数执行成功返回一个新的套接字，否则返回：INVALID_SOCKET。
3. 监听套接字与IP地址及端口绑定 sockaddr_in sockadd = { 0, }; sockadd.sin_family = AF_INET;//IPV4协议簇 sockadd.sin_port = htons(m_uPort);//监听端口 sockadd.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//监听本机任意IP bind(m_listenSocket, (struct sockaddr*) &amp; sockadd, sizeof(sockadd)); m_listenSocket：已经创建好的监听套接字
INADDR_ANY：如果机器存在多网卡，客户端连接任意一个IP地址均可建立通信
执行失败时返回： SOCKET_ERROR
4. 监听套接字 listen(m_listenSocket, 1); m_listenSocket：绑定IP地址及端口的监听地址
1：指定最大允许同时连接的客户端数
5. 等待客户端连接 m_clientSocket = accept(m_listenSocket, (struct sockaddr*) &amp; addr, &amp;addrlen); 提取套接字m_listenSocket上挂起连接队列的第一个连接，然后返回新套接字m_clientSocket，如过要与客户端通信就需要通过m_clientSocket来发送或接收数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21f4f7a6a2d5bafb70e2b27a545febbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2a681f48ce179e1f97916fd014de94c/" rel="bookmark">
			zookeeper之Curator使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先起一个工具类配置好客户端 public class CuratorUtil { private final static String zkIp = "192.168.9.100:2181,192.168.9.101:2181,192.168.9.102:2181"; private static CuratorFramework client; // 客户端 /* 重连策略:初始时间,最大重试次数 */ private static RetryPolicy retryPolicy = new ExponentialBackoffRetry(25000, 3); public static CuratorFramework getZkClient(){ /* 创建会话:服务器列表,会话超时时间,链接创建超时时间,重试策略 */ // client = CuratorFrameworkFactory.newClient(zkIp, 5000 , 5000, retryPolicy); /* Fluent风格便于阅读 */ client = CuratorFrameworkFactory.builder() .connectString(zkIp) .sessionTimeoutMs(25000) .connectionTimeoutMs(25000) // 创建连接超时时间过小的话,可能会导致client没连接上,操作报未连接错. .retryPolicy(retryPolicy) .namespace("base") // 独立隔离命名空间,任何操作都是基于该相对目录 .build(); client.start(); return client; } } 再来操作代码 public class TestApplication { public static void main(String[] args) throws Exception { CuratorFramework client = CuratorUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2a681f48ce179e1f97916fd014de94c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89b003bf1531e170cd4bf6eba2f3af29/" rel="bookmark">
			C&#43;&#43;基础知识概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++基础知识概念 自己在复习C++的过程中整理了大约100个常见的问题以及重要知识点，和大家一起分享。
全文几乎都是 概念性解答，主要参考书籍是 清华大学出版社郑莉 老师主编的 《C++语言程序设计（第四版）》。
接下来是索引目录，会分为4篇文章，每篇文章解答25个问题概念，可以通过大标题直接定位到该篇文章；
如果其中问题 概念解答有什么错误或者不当的地方，欢迎大家指出来，让我们一起进步，谢谢大家~
索引目录 C++基础知识概念（一） 1 比较值传递和引用传递的相同点和不同点。
2 什么叫内联函数？它有哪些特点？
3 什么叫拷贝构造函数？拷贝构造函数何时被调用？
4 复制构造函数与赋值运算符（=）有何不同？
5 什么叫作用域？有哪几种类型的作用域？
6 什么叫做可见性？可见性的一般规则是什么？
7 什么叫静态数据成员？他有何特点？
8 什么叫静态函数成员？他有何特点？
9 什么叫友元函数？什么叫友元类？
10 在函数内部定义的普通局部变量和静态局部变量在功能上有何不同？计算机底层对这两类变量做了怎样的不同处理导致了这种差异？
11 引用和指针有何区别？何时只能使用指针而不能使用引用？
12 比较类的 3 种继承方式之间的差别？
13 什么叫虚基类？有何作用？
14 组合与继承有什么共同点和差异？通过组合生成的类与被组合的类之间的逻辑关系是什 么？继承呢？
15 基类与派生类的对象，指针或引用之间，哪些情况下可以隐含转换，哪些情况下可以显 示转换？在涉及多重继承或虚继承的情况下，在转换时会面临哪些新问题？
16 什么叫做多态性？在 C++种是如何实现多态的？
17 什么叫抽象类？抽象类有何作用？抽象类的派生类是否一定要给出纯虚函数的实现？
18 在 C++中，能否声明虚构造函数？为什么？能否声明虚析构函数？有何用途？
19 什么叫做流？流的提取和插入是指什么？I/O 流在 C++中起着怎样的作用？
20 什么叫做异常？什么叫做异常处理？
21 C++的异常处理机制有何优点？
22 比较函数重载和虚函数在概念和使用方式方面有什么区别？
23 比较 class 和 struct 结构体的异同
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89b003bf1531e170cd4bf6eba2f3af29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/419f8b51be8a84fa6f3fdb46b3b01dad/" rel="bookmark">
			Gradle与Maven项目相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、Maven to Gradle Gradle对Maven的支持是比较完善的，在pom.xml文件所在的目录下执行：
gradle init # 根据pom.xml内容生成对应的gradle配置 gradle build # 开启gradle构建 二、Gradle to Maven Gradle项目转Maven项目需要借助一个Gradle插件，在项目的module的build.gradle文件中加入以下配置即可：
apply plugin: 'maven' 通过双击Idea的GUI或者执行命令来完成转换:
gradle install 完成之后，将会在当前Module项目的build目录下的poms文件夹下生成pom-default.xml，将其拷贝到项目的根目录下即可。
完整的文件示例 plugins { id 'java' } group 'com.biturd' version '1.0-SNAPSHOT' sourceCompatibility = 1.8 repositories { mavenLocal() mavenCentral() } dependencies { testCompile group: 'junit', name: 'junit', version: '4.12' } apply plugin: 'maven' task convert2Maven { doLast { file("$buildDir/poms/pom-default.xml").renameTo(file("$rootDir/pom.xml")) } } install.dependsOn(convert2Maven) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cae22f5d09bca62a73538875ef4a30f/" rel="bookmark">
			微信小程序监听全局变量的变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在使用全局的倒计时的时候，单纯的用app.globalData.xxx 无法实现倒计时时间的变化
所以就需要用到监听全局变量xxx的变化 在用this.setData赋值
app.js
watch: function (method) { var obj = this.globalData Object.defineProperty(obj, 'clock', { configurable: true, enumerable: true, set: function (value) { this._name = value; method(value); }, get: function () { return this._name } }) }, globalData: { clock:"" } index.js //需要获取倒计时时间的页面js
onLoad:function(options){ let that = this; getApp().watch(that.watchBack) }, watchBack: function (value){ this.setData({ clock: value }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/256b89647a02485b1a055269ceeef4ad/" rel="bookmark">
			开启OCSP提升HTTPS速度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：根据客服对用户信息的反馈，部分IOS启动app很慢甚至超时，而安卓并无异常。
排查步骤 1.查看nginx的错误日志和服务端的处理日志，并没有发现异常超时的记录；2.通过还原用户使用场景，用户发送请求到服务器接收到请求，产生了6-10s的延迟，这个直接导致ios 触发原定的3s超时；3.了解到用户并非出于网络较差环境，或者使用科学上网，于是将问题定位到https验证；4.因为ios为了促进app审查，使用了https来与服务器通信，而安卓则是跳过验证，这点坐实了https验证的问题。 解决思路 1.检查https证书是否过期，发现各项证书均在有效期内；
2.通过ssllab.com测试域名的各项指标，发现TLS只支持到v1.0-v1.2，v1.3并无支持，而v1.3在验证速度上比历史版本块，其中原因v1.3引入以下特性，速度有很大提升：
相比过去的的版本，引入了新的密钥协商机制 — PSK支持 0-RTT 数据传输，在建立连接时节省了往返时间废弃了 3DES、RC4、AES-CBC 等加密组件，废弃了 SHA1、MD5 等哈希算法ServerHello 之后的所有握手消息采取了加密操作，可见明文大大减少不再允许对加密报文进行压缩、不再允许双方发起重协商DSA 证书不再允许在 TLS 1.3 中使用 3.开启OCSP(Online Certificate Status Protocal), 在nginx的server{}配置中增加以下配置
ssl_stapling on;ssl_stapling_verify on;ssl_trusted_certificate /etc/letsencrypt/live/xxx.xxx.com/fullchain.pem;resolver 8.8.8.8 8.8.4.4 1.1.1.1 valid=60s;resolver_timeout 2s;
然后重启nginx，在ssllab.com验证，OCSP stapling YES。 4.之后验证https速度和http差不多了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1411900a10c325d1275ed9414612b2c0/" rel="bookmark">
			JS如何找数组中的最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、for循环 1.基本用法
let arr = [12, 223, 44, 56, 785, 34, 857]; let max = arr[0]; for (let i = 1; i &lt; arr.length; i++) { if (arr[i] &gt; max) { max = arr[i] } } console.log(max); 2.三元运算符
let arr = [12, 223, 44, 56, 785, 34, 857]; let max = arr[0]; for (let i = 1; i &lt; arr.length; i++) { max = max &gt; arr[i] ? max : arr[i] } console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1411900a10c325d1275ed9414612b2c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a6fbedd26860e57d4e4259e70840806/" rel="bookmark">
			403状态码----详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在访问网站的时候，会时不时的出现403 Forbidden错误，浏览器会给出403 Forbidden错误提示，在打开Access Error中列出的URL之后, 出现以下错误：
403 Forbidden
Access to this resource on the server is denied!
Powered By LiteSpeed Web Server
LiteSpeed Technologies is not responsible for administration and contents of this web site!
403错误是网站访问过程中，常见的错误提示。资源不可用，服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致，比如IIS或者apache设置了访问权限不当。一般会出现以下提示：
一、403 forbidden是什么意思？
403 Forbidden是HTTP协议中的一个状态码(Status Code)。可以简单的理解为没有权限访问此站。该状态表示服务器理解了本次请求但是拒绝执行该任务，该请求不该重发给服务器。在HTTP请求的方法不是“HEAD”，并且服务器想让客户端知道为什么没有权限的情况下，服务器应该在返回的信息中描述拒绝的理由。在服务器不想提供任何反馈信息的情况下，服务器可以用404 Not Found代替403 Forbidden。
二、403错误代码的分类介绍
403.1
403.1错误是由于"执行"访问被禁止而造成的，若试图从目录中执行CGI、ISAPI或其他可执行程序，但该目录不允许执行程序时便会出现此种错误。
403.2
403.2错误是由于"读取"访问被禁止而造成的。导致此错误是由于没有可用的默认网页并且没有对目录启用目录浏览，或者要显示的HTML网页所驻留的目录仅标记为"可执行"或"脚本"权限。
403.3
403.3错误是由于"写入"访问被禁止而造成的，当试图将文件上载到目录或在目录中修改文件，但该目录不允许"写"访问时就会出现此种错误。
403.4
403.4错误是由于要求SSL而造成的，您必须在要查看的网页的地址中使用"https"。
403.5
403.5错误是由于要求使用128位加密算法的Web浏览器而造成的，如果您的浏览器不支持128位加密算法就会出现这个错误，您可以连接微软网站进行浏览器升级。
403.6
403.6错误是由于IP地址被拒绝而造成的。如果服务器中有不能访问该站点的IP地址列表，并且您使用的IP地址在该列表中时您就会返回这条错误信息。
403.7
403.7错误是因为要求客户证书，当需要访问的资源要求浏览器拥有服务器能够识别的安全套接字层(SSL) 客户证书时会返回此种错误。
403.8
403.8错误是由于禁止站点访问而造成的，若服务器中有不能访问该站点的DNS名称列表，而您使用的DNS名称在列表中时就会返回此种信息。请注意区别403.6与403.8错误。
403.9
403.9错误是由于连接的用户过多而造成的，由于Web服务器很忙，因通讯量过多而无法处理请求时便会返回这条错误。
403.10
403.10错误是由于无效配置而导致的错误，当您试图从目录中执行CGI、ISAPI或其他可执行程序，但该目录不允许执行程序时便会返回这条错误。
403.11
403.11错误是由于密码更改而导致无权查看页面。
403.12
403.12错误是由于映射器拒绝访问而造成的。若要查看的网页要求使用有效的客户证书，而您的客户证书映射没有权限访问该Web站点时就会返回映射器拒绝访问的错误。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a6fbedd26860e57d4e4259e70840806/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/312191da4191206f8ef2f9e4aeca6872/" rel="bookmark">
			边沿触发器(T触发器)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用目的：
提高可靠性，增强抗干扰能力，希望触发器的次态仅取决于CLK的下降沿（或上升沿）到来时的输入信号状态，与在此前、后输入的状态没有关系。 【 1. 上升沿触发器 】 用两个电平触发D触发器组成的边沿触发器
电路结构 电路原理 即：
由两个D电平触发器组成（D电平触发器的输出=其输入）CLK=1时，D电平触发器正常工作，CLK=0时，D电平触发器会锁存其变为0前瞬间的输出状态，并保持这个输出状态不变。CLK=0时，CLK1=1，FF1正常工作；CLK2=0，FF2处于“锁存状态”。CLK=1时，CLK1=0，FF1处于“锁存”状态；CLK2=1，FF2正常工作；
此时的FF2的输入为FF1的输出，由于FF1锁存保持输出不变，故FF2的输出也不变且等于FF1的输出。 真值表 时序图 总结 输出Q仅在CLK的上升沿时发生改变并改变为与输入D相同的状态(1/0)，其他状态均保持不变。
【 2. 下降沿触发器 】 电路结构 时序图 总结 输出Q仅在CLK下降沿时发生改变并改变为与输入D相同的状态(1/0)，其他状态均保持不变。
【3. 有异步置位、复位端的边沿触发器 】 【 4. T触发器 】 工作原理 每当时钟信号下降沿且T=1时进行翻转
功能描述 T’ 触发器 当T=1时，Q*=Q´，这时候也可以称为T ´触发器。即时钟信号下降沿来临时会翻转。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847da132ea3b478e6680cf9791f522a4/" rel="bookmark">
			SQL学习（五）查询结果过滤和排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果初学，看看基础语法直接结合例子来看更容易理解。
基础语法 DISTINCT 选取出唯一的结果的语法 SELECT DISTINCT column, another_column, … FROM mytable WHERE condition(s); DISTINCT 语法会直接删除重复的行，即排重。
GROUP BY 结果排序（ordered results） SELECT column, another_column, … FROM mytable WHERE condition(s) ORDER BY column ASC/DESC; ASC表示升序排列 A~Z
DESC表示降序排列 Z~A
LIMIT 和 OFFSET limited查询 SELECT column, another_column, … FROM mytable WHERE condition(s) ORDER BY column ASC/DESC LIMIT num_limit OFFSET num_offset; 对整个结果集排序之后，我们可以 LIMIT来指定只返回多少行结果 ,用 OFFSET来指定从哪一行开始返回。
练习 练习题出自自学SQL。
按导演名排重列出所有电影，并按导演名正序排列 # 按照导演名 排重 列出所有电影 SELECT DISTINCT director FROM movies # 按照导演名正序排列 ORDER BY director ASC 注意 DISTINCT 排重，只取director属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/847da132ea3b478e6680cf9791f522a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5c4a20bc32b9fe10b9ccc3f7601c9fe/" rel="bookmark">
			cports.exe 端口查看器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 cports1. 关闭端口的两种方法2. 使用 cports 步骤 cports 如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败，可以打开 CMD 关闭不用的占用指定端口的程序（需要输入指令），也可以使用 cports 来关闭端口（更方便）。 1. 关闭端口的两种方法 通过 CMD 来关闭：端口号被重复使用了怎么办？通过 cports 来关闭：cports 下载地址（官网访问很慢，已上传至CSDN资源库），官网地址：http://www.nirsoft.net/utils/cports.html 2. 使用 cports 步骤 打开 cports.exe（不需要解压文件夹）；查看端口的占用情况：
右键点击要关闭的进程，关闭进程并释放占用的端口：
原文链接：https://qwert.blog.csdn.net/article/details/105496753
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eefe58706f3eff3d266eba303a3a2cc/" rel="bookmark">
			关于Sourcetree 关联gitee的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前期的配置 新装好Sourcetree后
1. 点击 [工具]&gt;&gt;[创建或导入SSH密钥]
在弹窗口中点击 [Generate]
随后会在图上的红框中生成公钥, 点击2个save保存到本地计算机里,一般存在 C:\用户\用户名\.ssh
2. 登录gitee,点击头像下的[设置] &gt;&gt;左边菜单的[SSH公钥]
将之前红色框中的公钥复制进来,点击确定
3. 公钥填写完成后,双击右下角的图标
在弹框中点击 [Add key], 找到之前存好的私钥,点击Closse
中期:拉取项目 关于项目的关联
1. 在gitee页面上创建项目
填写好相关信息
2. 复制项目的连接
3.Sourcetree点击 [Clone],填写相关的信息
4. 在弹框中输入 gitee的账户密码
5. 点击[Clone],即可下载项目到本地
6. idea 点击open 这个下载到本地后,点击创建子模块,就可以愉快的编码了
后期:提交代码 本地代码有变动后
点击[文件状态]&gt;&gt;未暂存文件
可以看到,本地会生成许多尚未提交的代码文件,但部分文件是不需要提交到远程的,例如.idea结尾和.git结尾的文件
1.配置过滤规则: 点击右上角[设置]&gt;&gt;[高级]&gt;&gt;[编辑]
在弹框的记事本中,编辑需要过滤的文件格式,一种格式写一行,写完后CTRL+S 保存
*.iml */target/ .mvn .git .idea/ .gitignore 点击确定
这样可以看到过滤后的,尚未上传的文件
2. 点击文件后的[+] 或点击[暂存所有]
在页面最下面,填写此次变更的注释后,点击[提交]
此时只是提交到本地厂库
3. 点击左边的[History],可以看到刚刚提交的信息,点击[推送]
在弹框中选择,推送到远程哪个分支下,点击[推送]
点击[显示完整输出] ,可以看到推送的结果
可以在gitee页面上看到,上传的代码了
SourceTree&amp;Git部分词汇的介绍 克隆(clone)：从远程仓库URL加载创建一个与远程仓库一样的本地仓库提交(commit)：将暂存文件上传到本地仓库（我们在Finder中对本地仓库做修改后一般都得先提交一次，再推送）检出(checkout)：切换不同分支添加（add）：添加文件到缓存区移除（remove）：移除文件至缓存区暂存(git stash)：保存工作现场重置(reset)：回到最近添加(add)/提交(commit)状态合并(merge)：将多个同名文件合并为一个文件，该文件包含多个同名文件的所有内容，相同内容抵消抓取(fetch)：从远程仓库获取信息并同步至本地仓库拉取(pull)：从远程仓库获取信息并同步至本地仓库，并且自动执行合并（merge）操作，即 ** pull=fetch+merge **推送(push)：将本地仓库同步至远程仓库，一般推送（push）前先拉取（pull）一次，确保一致分支(branch)：创建/修改/删除分枝标签(tag):给项目增添标签工作流(Git Flow):团队工作时，每个人创建属于自己的分枝（branch），确定无误后提交到master分枝终端(terminal):可以输入git命令行 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31b2e50ed25140ce5b447aef23835076/" rel="bookmark">
			python的pandas异常值处理（Z-score方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、构建包含异常值的矩阵 import pandas as pd import matplotlib.pyplot as plt #构建包含异常值的矩阵 df=pd.DataFrame([[1,12],[120,17],[3,31],[5,53],[2,22],[12,32],[13,43]],columns=['col1','col2']) df 输出：
二、画图 #散点图 plt.scatter(df['col1'],df['col2']) plt.show() 输出：
从表中，我们暂时可以判断120为离群值（异常点）。
三、通过Z-Score法判断异常值 df_zscore=df.copy() #复制一个用来存储Z-score得分的数据框 df_zscores=(df_zscore-df_zscore.mean())/df_zscore.std() #0-1标准化法 df_zscores.abs()&gt;2.2 #标准化的绝对值大于2.2即为异常点 输出：
注意：对于有固定业务规则的可直接套用业务规则，而对于没有业务规则的，可以采用常见的数学模型进行判断，即基于概率分布的模型（例如正态分布的标准差范围）、基于聚类的方法（例如kmeans）、基于密度的方法（例如LOF）、基于分类的方法（例如KNN）、基于统计的方法（例如分位数）等，此时异常值的定义带有较强的主观判断色彩，具体情况具体分析。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e8a224a9c303d3b3360332ce04183be/" rel="bookmark">
			MySQL 日期相关查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 日期相关查询 查询今日数据查询昨日数据查询近7日数据查询近30日数据查询本周数据查询上周数据查询本月数据查询上月数据查询本季度数据查询上季度数据查询本年数据查询上年数据----把bigint类型转换为时间格式将时间转换为时间戳 查询今日数据 SELECT * FROM 表名 WHERE TO_DAYS(时间字段名) = TO_DAYS(NOW());
查询昨日数据 SELECT * FROM 表名 WHERE TO_DAYS(NOW()) - TO_DAYS(时间字段名) &lt;= 1;
查询近7日数据 SELECT * FROM 表名 WHERE DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;= date(时间字段名);
查询近30日数据 SELECT * FROM 表名 WHERE DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;= date(时间字段名);
查询本周数据 SELECT * FROM 表名 WHERE YEARWEEK(DATE_FORMAT(时间字段名,'%Y-%m-%d')) = YEARWEEK(NOW());
查询上周数据 SELECT * FROM 表名 WHERE YEARWEEK(DATE_FORMAT(时间字段名,'%Y-%m-%d')) = YEARWEEK(NOW())-1;
查询本月数据 SELECT * FROM 表名 WHERE DATE_FORMAT(时间字段名, '%Y%m') = DATE_FORMAT( CURDATE() , '%Y%m' );
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e8a224a9c303d3b3360332ce04183be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cd4412a46fc7741b1daa046d4863a3d/" rel="bookmark">
			LeetCode - 787. K 站中转内最便宜的航班
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		787. K 站中转内最便宜的航班 有 n 个城市通过 m 个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。
现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到从 src 到 dst 最多经过 k 站中转的最便宜的价格。 如果没有这样的路线，则输出 -1。
解题思路：本题的场景可以转化为在给定的最大深度下找加权最短路的问题。那么图的遍历有两种方式，这里对应的给出两种解法。
深度优先搜索 class Solution { public: void helper(unordered_map&lt;int, vector&lt;vector&lt;int&gt;&gt;&gt;&amp; m, unordered_set&lt;int&gt;&amp; visited, int cur, int K, int dst, int out, int &amp;res) { if (cur == dst) {res = out; return;} if (K &lt; 0) return; for (auto a : m[cur]) { if (visited.count(a[0]) == 1 || out + a[1] &gt; res) continue; visited.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cd4412a46fc7741b1daa046d4863a3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5624c8eb8839a0f99b834436a1841f4a/" rel="bookmark">
			go源码阅读——malloc.go
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【博文目录&gt;&gt;&gt;】 【项目地址&gt;&gt;&gt;】 内存分配器 golang内存分配最初是基于tcmalloc的，但是有很大的不同。tcmalloc文章：
参见：http://goog-perftools.sourceforge.net/doc/tcmalloc.html
翻译：https://blog.csdn.net/DERRANTCM/article/details/105342996
主分配器在大量页（runs of pages）中工作。将较小的分配大小（最大为32 kB，包括32 kB）舍入为大约70个大小类别之一，每个类别都有其自己的大小完全相同的空闲对象集。任何空闲的内存页都可以拆分为一个大小类别的对象集，然后使用空闲位图（free bitmap）进行管理。
分配器的数据结构为： fixalloc：用于固定大小的堆外对象的空闲列表分配器，用于管理分配器使用的存储。
mheap：malloc堆，以页（8192字节）粒度进行管理。
mspan：由mheap管理的一系列使用中的页面。
mcentral：收集给定大小类的所有跨度。
mcache：具有可用空间的mspans的每P个缓存。
mstats：分配统计信息。
分配一个小对象沿用了高速缓存的层次结构： 1、将大小四舍五入为一个较小的类别，然后在此P的mcache中查看相应的mspan。扫描mspan的空闲位图以找到空闲位置（slot）。如果有空闲位置，分配它。这都可以在不获取锁的情况下完成。2、如果mspan没有可用位置，则从mcentral的具有可用空间的所需size类的mspan列表中获取一个新的mspan。获得整个跨度（span）会摊销锁定mcentral的成本。3、如果mcentral的mspan列表为空，从mheap获取一系列页以用于mspan。4、如果mheap为空或没有足够大的页，则从操作系统中分配一组新的页（至少1MB）。分配大量页面将分摊与操作系统进行对话的成本。 清除mspan并释放对象沿用了类似的层次结构： 1、如果响应分配而清除了mspan，则将mspan返还到mcache以满足分配。2、否则，如果mspan仍有已分配的对象，则将其放在mspan的size类别的mcentral空闲列表上。3、否则，如果mspan中的所有对象都是空闲的，则mspan的页面将返回到mheap，并且mspan现在已失效。 分配和释放大对象直接使用mheap，而绕过mcache和mcentral。如果mspan.needzero为false，则mspan中的可用对象位置已被清零。否则，如果needzero为true，则在分配对象时将其清零。通过这种方式延迟归零有很多好处：
1、堆栈帧分配可以完全避免置零。2、它具有更好的时间局部性，因为该程序可能即将写入内存。3、我们不会将永远不会被重用的页面归零。 虚拟内存布局 堆由一组arena组成，这些arena在64位上为64MB，在32位（heapArenaBytes）上为4MB。每个arena的起始地址也与arena大小对齐。
每个arena都有一个关联的heapArena对象，该对象存储该arena的元数据：arena中所有字（word）的堆位图和arena中所有页的跨度（span）图。它们本身是堆外分配的。
由于arena是对齐的，因此可以将地址空间视为一系列arena帧（frame）。arena映射（mheap_.arenas）从arena帧号映射到*heapArena，对于不由Go堆支持的部分地址空间，映射为nil。arena映射的结构为两层数组，由“L1”arena映射和许多“ L2”arena映射组成；但是，由于arena很大，因此在许多体系结构上，arena映射都由一个大型L2映射组成。
arena地图覆盖了整个可用的地址空间，从而允许Go堆使用地址空间的任何部分。分配器尝试使arena保持连续，以便大跨度（以及大对象）可以跨越arena。
OS内存管理抽象层 在任何给定时间，运行时管理的地址空间区域可能处于四种状态之一：
1）无（None）——未保留和未映射，这是任何区域的默认状态。2）保留（Reserved）——运行时拥有，但是访问它会导致故障。不计入进程的内存占用。3）已准备（Prepared）——保留，意在不由物理内存支持（尽管OS可能会延迟实现）。可以有效过渡到就绪。在这样的区域中访问内存是不确定的（可能会出错，可能会返回意外的零等）。4）就绪（Ready）——可以安全地访问。 这组状态对于支持所有当前受支持的平台而言绝对不是必需的。只需一个“无”，“保留”和“就绪”就可以解决问题。但是，“已准备”状态为我们提供了用于性能目的的灵活性。例如，在POSIX-y操作系统上，“保留”通常是设置了PROT_NONE的私有匿名mmap’d区域，要转换到“就绪”状态，需要设置PROT_READ | PROT_WRITE。但是，Prepared的规格不足使我们仅使用MADV_FREE从Ready过渡到Prepared。因此，在“准备好”状态下，我们可以提早设置一次权限位，我们可以有效地告诉操作系统，当我们严格不需要它们时，可以自由地将页面从我们手中夺走。
对于每个操作系统，都有一组通用的帮助程序，这些帮助程序在这些状态之间转换内存区域。帮助程序如下：
sysAlloc sysAlloc将OS选择的内存区域从“无”转换为“就绪”。更具体地说，它从操作系统中获取大量的零位内存，通常大约为一百千字节或兆字节。该内存始终可以立即使用。
sysFree sysFree将内存区域从任何状态转换为“无（Ready）”。因此，它无条件返回内存。如果在分配过程中检测到内存不足错误，或用于划分出地址空间的对齐部分，则使用此方法。仅当sysReserve始终返回与堆分配器的对齐限制对齐的内存区域时，如果sysFree是无操作的，这是可以的。
sysReserve sysReserve将内存区域从“无（None）”转换为“保留（Reserved）”。它以这样一种方式保留地址空间，即在访问时（通过权限或未提交内存）会导致致命错误。因此，这种保留永远不会受到物理内存的支持。如果传递给它的指针为非nil，则调用者希望在那里保留，但是sysReserve仍然可以选择另一个位置（如果该位置不可用）。
注意：sysReserve返回OS对齐的内存，但是堆分配器可能使用更大的对齐方式，因此调用者必须小心地重新对齐sysReserve获得的内存。
sysMap sysMap将内存区域从“保留（Reserved）”状态转换为“已准备（Prepared）”状态。它确保可以将存储区域有效地转换为“就绪（Ready）”。
sysUsed sysUsed将内存区域从“已准备（Prepared）”过渡到“就绪（Ready）”。它通知操作系统需要内存区域，并确保可以安全地访问该区域。在没有明确的提交步骤和严格的过量提交限制的系统上，这通常是不操作的，例如，在Windows上至关重要。
sysUnused sysUnused将内存区域从“就绪（Ready）”转换为“已准备（Prepared）”。它通知操作系统，不再需要支持该内存区域的物理页，并且可以将其重新用于其他目的。 sysUnused内存区域的内容被认为是没用的，在调用sysUsed之前，不得再次访问该区域。
sysFault sysFault将内存区域从“就绪（Ready）”或“已准备（Prepared）”转换为“保留（Reserved）”。它标记了一个区域，以便在访问时总是会发生故障。仅用于调试运行时。
状态转换图 hint的选择 64位机器 在64位计算机上，我们选择以下hit因为：
1、从地址空间的中间开始，可以轻松扩展到连续范围，而无需运行其他映射。2、这使Go堆地址在调试时更容易识别。3、gccgo中的堆栈扫描仍然很保守，因此将地址与其他数据区分开很重要。 从0x00c0开始意味着有效的内存地址将从0x00c0、0x00c1 … n 小端开始，即c0 00，c1 00，…这些都不是有效的UTF-8序列，否则它们是尽可能远离ff（可能是一个公共字节）。如果失败，我们尝试其他0xXXc0地址。较早的尝试使用0x11f8导致线程分配期间OS X上的内存不足错误。 0x00c0导致与AddressSanitizer发生冲突，后者保留了最多0x0100的所有内存。这些选择减少了保守的垃圾收集器不收集内存的可能性，因为某些非指针内存块具有与内存地址匹配的位模式。
但是，在arm64上，我们忽略了上面的所有建议，并在0x40 &lt;&lt; 32处分配，因为当使用具有3级转换缓冲区的4k页面时，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5624c8eb8839a0f99b834436a1841f4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a66a0e8d8d24178330be3654956b66d1/" rel="bookmark">
			PostGIS实现叠加分析之-Spatial Join (1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：Spatial Join是Arcgis提供的重要的分析工具，归类在Overlap工具箱中。​本文主要介绍基于Postgis实现Spatial Join，即空间连接，空间连接的依据是空间关系。由于空间关系的复杂性，空间连接分析算是比较复杂的一个，本文首先介绍了空间关系的相关概念、分类、模型等，详细介绍Postgis提供的空间拓扑关系函数，包括非常常用的ST_Contains ，ST_Within ，ST_Intersects等函数，这些函数都是判断空间关系的，而不生产新数据，实际应用中都是用来条件判断，结合关系数据库的SQL可以帮助我们做很多分析计算。
第一篇白话一些简单理论，此为理论篇。
http://mp.weixin.qq.com/s?__biz=MzI2NTU5NTk5NA==&amp;mid=100000101&amp;idx=1&amp;sn=598ac174b494f0ac3b9d9a6424953479&amp;chksm=6a9bbc505dec3546edbb4fb24316cab5846fcf1fe140d0fb135d06848dd4bdef3fc3aa56cf44#rd
推荐下公众号，后续主要更新开源GIS相关知识技能，包括PostgreSQL、PostGIS、Geoserver等，欢迎有兴趣同学关注学习交流
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56945d13e81bfc561a58ae2914252a2f/" rel="bookmark">
			每日打卡 2020-04-11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		践行每日打卡，早睡早起早做，轻快前行。
学习：精读一篇文章/看一功能，写一总结；
工作：处理积压事务，计划和总结；
生活：做运动，写下感悟；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4217b5d25856fb6a1ba9eaa580122f6c/" rel="bookmark">
			如何做一个优雅的Pod
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		没有人不想优雅的活着，在这喧闹的生活中过得优雅从容并不容易。但在k8s的世界中，如何做个优雅的Pod还是有套路可循的。
Pod的生命周期 在优雅之前，我们先谈谈Pod的一生，大体分为以下几个阶段
创建，通过kubectl或者api创建pod, apiserver收到请求后存储到etcd调度，scheduler检测到pod创建后，通过预选优选为pod选取合适的人家(node)启动，kubelet检测到有pod调度到当前节点，开始启动pod终止，不同的pod有不同的谢幕方式，有的正常运行结束没有restart就completed，有的被kill就入土为安了，有的被驱逐换种方式重新开始 今天我们主要讨论3-4阶段，前面部分更多是deployment/daemonset这些pod的父母所决定的。
优雅的启动 init container 通常pod有一些初始化操作，创建文件夹，初始化磁盘，检查某些依赖服务是不是正常，这些操作放在代码中会污染代码，写在启动命令中不方便管理，出问题也不方便排查，更优雅的方式是使用k8s的[init container][1]。
理解 Init 容器
Pod 可以包含多个容器，应用运行在这些容器里面，同时 Pod 也可以有一个或多个先于应用容器启动的 Init 容器。
Init 容器与普通的容器非常像，除了如下两点：
它们总是运行到完成。每个都必须在下一个启动之前成功完成。
如果 Pod 的 Init 容器失败，Kubernetes 会不断地重启该 Pod，直到 Init 容器成功为止。然而，如果 Pod 对应的 restartPolicy 值为 Never，它不会重新启动。 如果为一个 Pod 指定了多个 Init 容器，这些容器会按顺序逐个运行。每个 Init 容器必须运行成功，下一个才能够运行。当所有的 Init 容器运行完成时，Kubernetes 才会为 Pod 初始化应用容器并像平常一样运行。
Init 容器能做什么？
因为 Init 容器具有与应用容器分离的单独镜像，其启动相关代码具有如下优势：
Init 容器可以包含一些安装过程中应用容器中不存在的实用工具或个性化代码。例如，没有必要仅为了在安装过程中使用类似 sed、 awk、 python 或 dig 这样的工具而去FROM 一个镜像来生成一个新的镜像。Init 容器可以安全地运行这些工具，避免这些工具导致应用镜像的安全性降低。
应用镜像的创建者和部署者可以各自独立工作，而没有必要联合构建一个单独的应用镜像。
Init 容器能以不同于Pod内应用容器的文件系统视图运行。因此，Init容器可具有访问 Secrets 的权限，而应用容器不能够访问。由于 Init 容器必须在应用容器启动之前运行完成，因此 Init 容器提供了一种机制来阻塞或延迟应用容器的启动，直到满足了一组先决条件。一旦前置条件满足，Pod内的所有的应用容器会并行启动。 示例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4217b5d25856fb6a1ba9eaa580122f6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cbcbb39e2a3f2b7b4b1aa873fd6334d/" rel="bookmark">
			Artifact xxx:war exploded: Error during artifact deployment.See server log for details.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 换了个项目换回来突然就部署不了。抑郁。不过幸好我的问题挺好解决的
解决方法： 首先打开File菜单中的Project Structure
打开Artifacts（第一步），先移除自己要部署的项目（第二步），然后在添加回来（第二步旁边那个 + ）。
关闭这个界面 ，打开Tomcat部署界面。在如下的界面，先移除自己需要部署的项目。（注意出现部署错误就会发现该界面没有红框所示内容）
重新将项目添加进部署中。但注意添加的选项（选择第一个会导致部署还是没有进行，使用第二个从文件夹中选择自己的项目添加）
发现如红框所示的时候，就表明你部署成功啦！
总结：具体的原因不知道 自己太菜了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcd976a5fa62a110311d55d39068061a/" rel="bookmark">
			STM32F103&#43;ESP8266建立室内温度监测，采用MQTT方式连接阿里云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32F103+ESP8266建立室内温度监测，采用MQTT方式连接阿里云
一、开篇概述
闲来无事也想再市场正火的物联网方面做一个小东西，目的有两个。一是学习STM32F103的操作程序、二是做个物联网的小玩意，采用MQTT上传到云。
题外话，自己感觉还是有个项目驱动学习的才快，非常感谢被问到的老师们。相信大菜鸟有可能也能成为小菜鸟的。哈哈
二、所用材料
STM32F103开发板（随便一个都行，无论正点、野火、自己制作）ESP8266小模块DS18B20器件UART&lt;–&gt;USB串口小模块相关下载器KEIL5.25开发程序软件 三、程序移植
在网上找到一个程序，开始移植，主要是ESP8266的驱动编写，程序的框架基本已经写好，只要自己稍微改下GPIO、UART、iic 、timer、NAVC、IT中断函数编写等。
注意点：
由于ESP8266是UART控制，稍微注意下RX、TX的线序 四、测试步骤
DS18B20的测温驱动测试ESP8266连接模式入网测试全局MQTT上云测试
云操作需要建立自己的设备与产品，相关的操作阿里云都有介绍，可以自行查看很简单， 基本上到这里就算完成了，虽然写好写，但是做起来对我这样的新手来说，着实一件难事啊，做了几天才搞定。也算是没少走弯路，写下这篇文章，激励自己吧，慢慢的成长。
相关的代码我上传到网上，有需要的朋友可以做个参考
代码下载
阿里云监测的数据：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/408fda14f6fa5ba8d912dfb57375c48c/" rel="bookmark">
			[JavaScript] 用 jQuery 实现抽奖程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 抽奖功能1. 主要需求2. 素材页面3. 代码实现 抽奖功能 1. 主要需求 实现一个抽奖功能。点击开始按钮后，开始按钮禁用，停止按钮取消禁用，小图片实现快速切换显示。点击停止按钮后，停止按钮禁用，开始按钮取消禁用，小图片停止切换，将小图片在大图片位置显示。小图片实现快速切换显示。点击停止按钮后，淡入淡出选中图。 2. 素材页面 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;抽奖程序&lt;/title&gt; &lt;script type="text/javascript" src="../js/jquery-1.11.1.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; #small { border: 1px solid blueviolet; width: 75px; height: 75px; margin-bottom: 20px; } #smallPhoto { width: 75px; height: 75px; } #big { border: 2px solid orangered; width: 500px; height: 500px; position: absolute; left: 300px; top: 10px } #bigPhoto { width: 500px; height: 500px; } #btnStart { width: 100px; height: 100px; font-size: 22px; } #btnStop { width: 100px; height: 100px; font-size: 22px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/408fda14f6fa5ba8d912dfb57375c48c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84df5bf90ef49050e8675563d27a3acd/" rel="bookmark">
			matlab统计矩阵元素的出现次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法1： 例如统计矩阵flag里面的0次数
length(find(flag==0)) 以此类推 统计其他的元素次数
方法2： 统计flag里面所有的元素次数
a=hist(flag, unique(flag));
方法3： 统计flag里面所有的元素次数
x=flag(:) x=sort(x); % 数据排序 d=diff([x;max(x)+1]); % 通过同一数据为0 找标识 count = diff(find([1;d])) ; % 找到d里面的非0的位置， y =[x(find(d)) count]; % 打印结果 y的第一列是对应的元素，第二列是对应元素的出现次数
PS:🐧号 1762016542 提供答疑咨询等
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb5ed22d17d8c2fe77fa8a37f1c379d/" rel="bookmark">
			IntelliJ IDEA 2020.1发布，你要的都在这！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生命太短暂，不要去做一些根本没有人想要的东西。本文已被 https://www.yourbatman.cn 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的专栏供以免费学习。关注公众号【BAT的乌托邦】逐个击破，深入掌握，拒绝浅尝辄止。
目录 前言正文what’s new（新特性）1、支持Java 142、从IDE直接下载JDK3、更好的Java代码检查4、LightEdit模式5、Javadoc渲染6、改进的导航栏/面包屑栏7、Zen模式（禅模式）8、调试器：数据流分析辅助9、调试器：属性置顶10、初步支持HProf快照分析使用Demo 11、Git交互体验优化12、改进的HttpClient工具13、统一的浅色主题14、小彩蛋：支持中文15、其它更好的框架支持对Docker、Kubernetes更好支持Maven/Gradle自动导入更加智能支持Scala 3拆分Terminal终端会话运行配置可存储到文件彻底过度到JBR11版本 总结 关注A哥 前言 千呼万唤始出来。自从官方在2020-01-20发布了其2020年的Roadmap后，我便持续关注着、期待着JetBrains IntelliJ IDEA在“新10年”的首个版本的发布。这不，就在昨天(2020-04-09)发布了其“新10年”的首个版本：IntelliJ IDEA 2020.1。按照国际惯例，作为大版本号的升级，一般都会“搞点事情”，而事实确实如此（包括了支持中文哦）。
说明：2020是Jetbrain公司成立20周年，小伙子是20岁的大男孩了
正文 老规矩，先来一张最新版的IDEA启动图尝尝鲜：
比2019.3的启动页更好看，还是更美了呢？仁者见仁~
what’s new（新特性） IntelliJ IDEA 2020.1 添加了对 Java 14 的支持、为部分 Web 和测试框架添加新功能，通过数据流分析辅助升级了调试器，新增了LightEdit模式，以及支持从IDE直接下载和配置JDK等！
1、支持Java 14 2020年3月17日，Oracle的JDK/Java 14 正式GA（General Available），这是自Java采用六个月一次的发布周期后的第五次发布。
“咱们”IDEA顺序跟上，提供了支持其新特性。除了针对record提供完整的代码洞察支持，IDE 还允许用户快速创建新record，生成其构造函数与组件，以及对既有错误发出警报。 另外，IDE 现已支持 instanceof 运算符的模式匹配，其中包括新的检查以及快速修复，后者用简洁明了的新模式变量快速简化了冗长的 instanceof-and-cast 惯用代码。
2、从IDE直接下载JDK 当你还在吐槽现在JDK下载起来越来越麻烦的时候，IntelliJ IDEA此举会不会让你感动到哭？
您无需再从网络中搜索不可或缺的 JDK。 从 IntelliJ IDEA 2020.1 开始，在创建并配置项目时，您可以直接从 IDE 下载并配置 JDK 构建。 如果您打开下载的项目，IDE 将检查计算机是否安装了为此项目配置的 JDK。 如果未安装，IDE 将提示您下载 JDK。当然你也可以自己主动下载：
下载JDK的vendor源可以有多种可选（木有官方正统的Oracle哟~）：
3、更好的Java代码检查 在 IntelliJ IDEA 的每个新版本中，都会扩展其静态代码分析功能。 此版本也不例外。 除了上述改进外，还新增了多项代码检查。 它们可以检查 SimpleDateFormat 模式中的大写字母，分析日期格式设置，搜索其他冗余方法调用，以及报告并建议消除字符串文字中多余的转义字符等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfb5ed22d17d8c2fe77fa8a37f1c379d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f8d12d9ea068b0203af4e9403f26047/" rel="bookmark">
			Linux下安装指定版本Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：yum安装docker最简单的方法就是执行yum install docker，这个命令会安装最新版本的docker-ce，然而，生产环境通常都要求安装指定版本的docker,下面的内容主要说明怎样安装指定版本的docker
1、检查系统中是否已经安装了docker
执行：ps -ef |grep docker
如上图所示表示没有安装docker,如果显示已安装docker的需要先使用yum remave docker-*先卸载
2、添加docker-ce仓库
如上图所示发现缺少docker-ce的仓库，因此需要添加docker-ce的仓库，国内，推荐阿里的docker-ce仓库
2.1 安装yum仓库管理工具
执行：yum install -y yum-utils
2.2 下载阿里的docker-ce仓库
执行：yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
2.3 查看是否下载成功docker-ce仓库
3、查看选择docker-ce各版本
执行：yum list docker-ce --showduplicates | sort -r
4、安装指定版本的docker-ce
执行：yum install docker-ce-17.12.1.ce -y
5、关闭防火墙
执行：systemctl status firewalld 查看防火墙状态
确保防火墙关闭，如不是关闭状态可执行：systemctl disable firwalld
6、启动docker
执行：systemctl start docker 7、设置docker开机启动
执行：systemctl enable docker
8、设置docker加速器
异常处理
如遇到启动docker时失败，可以先尝试关闭selinux
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0321f1536b48508f48ecfd710d8bd76/" rel="bookmark">
			vsftpd启动报错code=exited, status=2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vsftpd配置文件如下：
anonymous_enable=NO
write_enable=YES
chroot_local_user=YES
chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chroot_list
allow_writeable_chroot=YES
userlist_enable=YES
ssl_enable=YES
allow_anon_ssl=NO
force_local_data_ssl=YES
force_local_logins_ssl=YES
ssl_tlsv1=YES
listen=YES
listen_ipv6=NO
pam_service_name=vsftpd
userlist_enable=YES
tcp_wrappers=YES
错误信息：
[root@kkocx ~]# systemctl status vsftpd.service
● vsftpd.service - Vsftpd ftp daemon
Loaded: loaded (/usr/lib/systemd/system/vsftpd.service; enabled; vendor preset: disabled)
Active: failed (Result: exit-code) since Fri 2020-04-10 18:21:37 CST; 20min ago
Process: 4506 ExecStart=/usr/sbin/vsftpd /etc/vsftpd/vsftpd.conf (code=exited, status=2)
4月 10 18:21:37 DNS systemd[1]: Starting Vsftpd ftp daemon…
4月 10 18:21:37 DNS vsftpd[4506]: 500 OOPS: SSL: cannot load RSA certificate
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0321f1536b48508f48ecfd710d8bd76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c07f08a72466139dc813c274b34e171/" rel="bookmark">
			2020-04-10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标定重投影误差 加入畸变参数的重投影误差和没有加入畸变参数的重投影误差有区别。
加入畸变参数的重投影误差在0.几个pixel左右。
没有加入畸变参数的重投影误差在1.几个pixel左右。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da15092e37cfa8ccfa241ee77018c183/" rel="bookmark">
			Charles iOS抓https包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、iPhone 连mac IP 代理
2、Charles -&gt; Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate -&gt; 钥匙串里找到Charles证书点击完全信任
3、Charles -&gt; Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate on a Mobile Device orRemote Browser -&gt; 弹框 -&gt; OK
4、iPhone -&gt; Safari -&gt; chls.pro/ssl 下载证书，安装证书
5、Charles -&gt; Proxy-SSL -&gt; Proxying settings -&gt; Add -&gt; port -&gt;443
6、ps iOS新版本系统无法抓到https包，手机通用-关于本机-最下面“证书信任设置”，找到Charles proxy 把开关打开就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43753ea20ff5ead83f3ddeb8a3e54846/" rel="bookmark">
			ESP32CAM与安卓端进行配合控制灯光简述(含有4G网查看方法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ESP32CAM 前言： 最近很忙，很久没更新了，因为之前倒腾了ESP32CAM模块发了一个B站的视频后，很多小伙伴都来找我问一下这个配合是如何进行的，因此写个简述，供大家有所参考。
视频效果： ESP32CAM实战效果！值得用来DIY的摄像头！
ESP32CAM： 我也有一个项目，名字叫做智能控制家居控制，因为控制需要有反馈的效果，如果不在家里又控制了家电，不亲眼看到总觉得不太好，看到控制的效果心里面总归要放心一点，因此我开始去网上选择摄像头模块。无意间看到了这款摄像头，当时就是被价格所吸引了，我是31入手的，拿到手后烧录了安信可官方的固件后，效果还不错。因此就开始了对这个模块的探寻之路。这个模块我倒没有深入去具体查看它的代码那些，我就想使用它的视频功能就行了，也不需要人脸识别(人脸识别太差了)，需要的就是能够流畅的观察到视频就行了。最开始的时候代码用的是arduino的官方ESP32中的camera那个例程，这个例程中功能很多，可以改变视频质量，视频格式，人脸识别等等。不过这个显得有点鸡肋了。因此最后我在社区找到了一个精简版的，就是直接观看摄像头的，很流畅，也很好用，地址为https://randomnerdtutorials.com/esp32-cam-video-streaming-web-server-camera-home-assistant/ ，在这里感谢作者了。关于烧录这些跟着教程走是没有一点问题的。在最后得到视频的播放地址后
就能够在局域网下通过浏览器来进行观看了(后面会说通过4G网来查看)，很遗憾的是这个视频同时只能有一个人观看，在增加客户端去用浏览器观看是看不到的。还有就是浏览器也有要求，最好是用火狐或者谷歌的浏览器。这一步完成了，这个ESP32CAM端就算完成了。接下来说一下安卓端。
安卓端： 大多数同学都对这个比较感兴趣，楼主呢对安卓的编程也不太会，这个成了一个大问题，很多做联动的都没办法实现。学习Java编安卓的时候效率很慢，也没有时间。后来偶然解除了易安卓，发现上手挺快的，很多的项目我都是用易安卓去完成的，因此，我给的方法就是易安卓，Java编应该也是类似的。这里请见谅！我们可以发现ESP32CAM是通过浏览器来进行查看的，因此编程的时候通过加入浏览器类库就能够实现了。需要类库的同学可以将邮箱留下，我发给你。下面看一下界面
思路也很简单 ，首先在ESP32CAM端建立一个UDP的服务器，然后自己规定协议，比如这里我规定1是打开灯光，0是关闭灯光，然后在浏览器的类库上写上转到ESP32CAM的视频地址上，只要安卓端按下按钮后，会发送对应的数据，CAM收到后作出控制就行了。
程序的思路就是这样，也很简单，至于UDP的建立这个就根据arduino上面自带的例程改一下就行了。我也是根据此，写完了自己的一个项目文件
后来又经过了一次修改，配合舵机后完成的效果很棒。我的项目的源码就不公开了，不过万变不离其宗，都是这个原理的。最后说一下4G的查看。
4G远程查看 先上效果
这里用到了内网穿透的效果，首先要确保自己家里面是公网的ip，大多数的同学都不是，最好就打电话给运行商说一下将自己家里面改为公网ip，然后将家里的光猫改为桥接模式，意思就是光猫只负责将光信号转化为电信号，而不做拨号路由的功能，这样路由器端就能够通过拨号获取到公网的ip，后面的工作就好做多了。
首先光猫的LAN口接入路由器的wan口，一旦光猫改为桥接模式后，路由器就需要拨号上网了(注意打电话给客服获取上网的账号和密码),然后路由器wan口模式改为拨号上网 ，然后你的wan口就会获取一个公网的ip地址
然后在路由器高级功能里面找到端口映射或者叫做虚拟服务器
先说一下访问的方式，比如你要访问ip为192.168.3.1，然后在浏览器输入这个ip访问的时候默认你访问的是80端口，而80端口大多数都被运营商给屏蔽了，因此最好选择其他的端口，我这里选择100端口，那么就应该在浏览器输入192.168.3.1:100。好的接下来说这个虚拟服务器的设置，外部端口号意思就是我们访问的端口号，我们选择的用100端口来访问，则外部端口号输入100
而这个内部端口号指的是你需要访问的局域网IP所用到的端口。我们的cam用的浏览器web访问用的就是80端口，因此内部端口号设置为80.而这个ip地址自然填的就是esp32cam的局域网ip。协议选择all，然后保存后就完成了设置。
比如现在我获取到的公网IP是110.189.213.3，那么在4G网下，我访问浏览器输入110.189.213.3:100则这个请求首先会转发到路由器端，然后路由器一看，寻思这个端口是设置转发了的嘛，所以他会将这个请求直接转到局域网cam的IP且访问的端口是80.那么就无形之间在局域网和远程建立了一个连接。就能够实现cam的远程查看，而不局限于局域网了。
结束语： 其实还有很多有意思的东西我都还想写，最近因为忙着考试也没时间去写,比如：ESP8266和天猫精灵的配合控制，基于云端的智能控制，ESP8266做为云端服务器，蓝桥杯的设计模板，还有关于路由器的设置，软路由的使用，笔记本做软路由等等很多有意思的我都想后面有空和大家分享。希望有兴趣的朋友可以关注，点赞，转发，哈哈，毕竟有了人看，才会有更新的动力啊。如果有什么问题不懂可以在评论下面讨论
-------------------------2020/4/10
ESP32CAM电路
附录 esp_camera.h /* * Example Use * static camera_config_t camera_example_config = { .pin_pwdn = PIN_PWDN, .pin_reset = PIN_RESET, .pin_xclk = PIN_XCLK, .pin_sscb_sda = PIN_SIOD, .pin_sscb_scl = PIN_SIOC, .pin_d7 = PIN_D7, .pin_d6 = PIN_D6, .pin_d5 = PIN_D5, .pin_d4 = PIN_D4, .pin_d3 = PIN_D3, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43753ea20ff5ead83f3ddeb8a3e54846/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a062d2a3c361f4fc66a51757c169f0dd/" rel="bookmark">
			Oracle Help
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Oracle Help 执行过的 SQL 语句 SELECT * FROM V$SQLAREA T WHERE ROWNUM &lt;= 50 and t.PARSING_SCHEMA_NAME = 'ZTENET' and t.SQL_TEXT like '%ZTE_FMT_SEAL%' ORDER BY T.LAST_ACTIVE_TIME DESC; 执行中的 SQL 语句 SELECT B.SID ORACLEID, B.USERNAME 登录ORACLE用户名, B.SERIAL#, SPID 操作系统ID, PADDR, SQL_TEXT 正在执行的SQL, B.MACHINE 计算机名 FROM V$PROCESS A, V$SESSION B, V$SQLAREA C WHERE A.ADDR = B.PADDR AND B.SQL_HASH_VALUE = C.HASH_VALUE and b.USERNAME = 'ZTENET'; 修改用户名密码 select username from dba_users where username = 'ZTEFMT'; -- 用户名密码不要加单引号 alter user ZTEFMT identified by ztefmt888888; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5065b1c6874da738a1633f9776dd9855/" rel="bookmark">
			图片密码长度（image password strength）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片密码长度（image password strength） 示例代码HTMLCSSJS 更多有趣示例 尽在 知屋安砖社区 示例 代码 HTML &lt;div class="background" id="background"&gt;&lt;/div&gt; &lt;div class="bg-white rounded p-10 text-center shadow-md"&gt; &lt;h1 class="text-3xl"&gt;Image Password Strength&lt;/h1&gt; &lt;p class="text-sm text-gray-700"&gt;Change the password to see the effect&lt;/p&gt; &lt;div class="my-4 text-left"&gt; &lt;label class="text-gray-800"&gt;Email:&lt;/label&gt; &lt;input type="email" class="border block w-full p-2 mt-2 rounded" placeholder="Enter email..." /&gt; &lt;/div&gt; &lt;div class="my-4 text-left"&gt; &lt;label class="text-gray-800"&gt;Password:&lt;/label&gt; &lt;input id="password" type="password" class="border block w-full p-2 mt-2 rounded" placeholder="Enter password..." /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- SOCIAL PANEL HTML --&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5065b1c6874da738a1633f9776dd9855/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cab89d7951751589dda4e6c7139b950/" rel="bookmark">
			手动设置MinGW编译器在Matlab中的环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 选择要安装的目标文件夹（在我的情况下为“ C：\ mingw-w64 \ x86_64-5.3.0-posix-seh-rt_v4-rev0”），然后转到下一步。
安装后，要告知编译器到Matlab的路径，可以在Matlab命令窗口中编写，也可以直接在m-file中编写以下命令:
setenv('MW_MINGW64_LOC','C:\mingw-w64\x86_64-5.3.0-posix-seh-rt_v4-rev0\mingw64')
要测试是否正确设置了编译器，请在Matlab命令窗口中键入以下命令
mex -setup C++
这应该为您提供以下输出：
MEX configured to use 'MinGW64 Compiler (C++)' for C++ language compilation. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/087a6fc8694939de53421d8943ad41f7/" rel="bookmark">
			SCSS的具体详解和与less的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SCSS的四种输出格式与SCSS与Sass的区别 可以参考这位老哥的
简单来说
SCSS更简单一点，没有什么奇怪的语法与奇怪的缩进，与less相差不大，利于使用与学习（推荐）
Sass有更加严格的语法（反正我看起来怪怪的）
不过SCSS与Sass是同宗同族的，不过Sass是老大哥
二、注释 与less相同
关于/**/
多行注释，会在原生css文件里面保留注释，但在压缩时注释就会消失
/*下面是SCSS文件*/ /* .container div:nth-child(odd){ background-color: #eee; } .container div:nth-child(even){ background-color: #ccc; }*/ /*下面是对应的SCSS文件生成的css文件*/ /* .container div:nth-child(odd){ background-color: #eee; } .container div:nth-child(even){ background-color: #ccc; }*/ 关于//
单行注释，不会在原生css文件里面保留注释，也不会在压缩的文件里面显示
/*下面是SCSS文件*/ //.container div:nth-child(odd){ // background-color: #eee; //} //.container div:nth-child(even){ // background-color: #ccc; //} /*下面是对应的SCSS文件生成的css文件*/ 什么也没有 /*!*/
强制注释，会在原生css文件里面保留注释，也会在压缩的文件里面显示
/*下面是SCSS文件*/ /*! .container div:nth-child(odd){ background-color: #eee; } .container div:nth-child(even){ background-color: #ccc; }*/ /*下面是对应的SCSS文件生成的css文件*/ /* .container div:nth-child(odd){ background-color: #eee; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/087a6fc8694939de53421d8943ad41f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2802b9954449d1255fb26bd310b2aec/" rel="bookmark">
			复现Style Transfer for Headshot Portraits
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1步 最难的一步
Go to libs/ and follow the instructions to install SIFT-flow 先去提示的网站下载项目
Instructions: http://people.csail.mit.edu/celiu/ECCV2008/ 按照SIFT-flow的readme提示操作
在matlab打开SIFT-flow项目使用mex命令
需要安装 MinGW 安装MATLAB Support for MinGW-w64 C/C++ Compiler会失败，
参考：https://mp.csdn.net/console/editor/html/105420841
4.10号 安装完之后，运行还是会报错，SIFT-FLOW这里，mex命令没有用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85bd65de943817e5324be342d8244723/" rel="bookmark">
			安装MATLAB Support for MinGW-w64 C/C&#43;&#43; Compiler失败如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要使用mex命令，需要安装MinGW，matlab上安装失败，打开网页也是失败！
解决方法：
打开 http://khailaie.com/notes/MEX/MEX-MinGW-setup-Windows.html 按照提示操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/220b6340370a5d86b29c7c8175341c13/" rel="bookmark">
			python版本和Matlab版本对应的关系,python调用matlab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		调用的话参考
https://blog.csdn.net/m0_37316917/article/details/90256563
https://zhuanlan.zhihu.com/p/67127872
注意的是python和matlab版本有对应关系，我下载了matlab2010和2014，前者没有engines文件夹，后者只支持python2.7和3.3！
已知matlab2017b支持python3.6 ~下载对应破解版，安装matlab后再参考调用的文章.
环境：Windows10，Matlab R2018，Pycharm
1. 安装
新建python工程，工程目录为 E:\untitled Matlab为Python提供了专门的Matlab引擎，在Pycharm中打开Terminal，定位到Matlab引擎所在的目录：
Pycharm的Terminal位于界面的左下角，与Anaconda Prompt具有相同的功能，可以执行pip命令
本人的目录为 F:\matlab\extern\engines\python，其中extern前是matlab安装目录，后续是固定目录 输入python setup.py install安装Matlab引擎
2. 导入Matlab引擎与使用
输入如下命令导入matlab.engine ：
import matlab import matlab.engine matlab函数在python调用中，首先需要启动一个engine，通过engine去启动matlab函数，也可以启动多个引擎来，启动多个计算，也可以使用非同步启动等方式，这些在官网中都有说明： [https://ww2.mathworks.cn/help/matlab/matlab_external/start-the-matlab-engine-for-python.html]
engine = matlab.engine.start_matlab() #启动matlab （1）调用matlab系统函数
engine.sqrt(matlab.double([1.,2.,3.,4.,5.])) （2）调用m文件
在工程目录（python源程序文件同目录）下新建matlab源程序文件，具体如下：
matlab源程序文件与python源程序文件处于同一目录下即可
文件名为test01.m，写入如下代码：
function a=test01(a,b) a=0.5*(a+b) python中调用：
engine.test01(1.,2.) 注意事项 （1）数据类型差异 engine传入时，需要将python的数据类型转换成matlab可用。 以常用的numpy数组为例： a = np.array([[1,2],[3,4]]) ，传入时需要使用matlab.double(a.tolist)的形式， 同时engine的输出也是matlab对象，需要进行一定的处理。
测试代码如下：
a = np.array([[1,2],[3,4]]) b = np.array([[1,1],[1,1]]) c = np.array(engine.test01(matlab.double(a.tolist()),matlab.double(b.tolist()),nargout=1)) print(c) （2）返回值个数
如上述代码中nargout=1，对应test01函数返回值个数，默认为1个，0个或多个返回值需要对应修改，否则会报错
（3）资源回收
engine.exit() 运行结果附图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/220b6340370a5d86b29c7c8175341c13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/318e6fc0cb632c689c792a3b11af0409/" rel="bookmark">
			达梦数据库 作业计划备份失败（错误-8007，备份文件创建失败）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做好备份数据库作业计划后，发现执行日志有报 -8007，备份文件创建失败，找了下这个可能的原因之一，应该是备份目录的权限不够，因此需要手动设置下文件夹的权限；
设置下权限（根据需要进行设置），
发现不报错了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/517899b8970002e59618788272d17ea1/" rel="bookmark">
			prometheus应用与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		prometheus应用与实践 一、架构 二、指标类型 1、Counter(计数器) ​ 特点： 只增不减，除非监控系统发生了重置。
​ 适用场景：描述服务的请求数、已完成的任务数、错误发生的次数等 。
​ API：
//将counter值加1. increment(1L) // 将指定值加到counter值上，如果指定值&lt;0 会发生异常. increment(val) ​ PromQL ：
//通过rate()函数获取HTTP请求量的增长率 rate(http_requests_total[5m]) //查询当前系统中，访问量前10的HTTP地址 topk(10, http_requests_total) 2、Guage（仪表盘） ​ 特点： 可增可减 ，反映数据的实时性。
​ 适用场景： 内存使用率这种指标数据，也可以表示能随时增加或减少的“总数”，例如：当前并发请求的数量
​ API：
//将指定值赋予gauge值上 set(val) 3、 Histogram（直方图） ​ 特点： 一段时间范围内对数据进行采样（通常是请求持续时间或响应大小等），并将其计入可配置的存储桶（bucket）中，后续可通过指定区间筛选样本，也可以统计样本总数，数据展示为直方图。
​ 适用场景： 监控样本的分布情况。
4、 Summary（摘要） ​ 特点：对数据样本的简要描述（如：80%样本的平均响应时间为5s）
​ 适用场景：性能的总结。
三、案例 案例一：prometheus使用 global: scrape_interval: 30s # 设置监测频率（默认1min）. evaluation_interval: 30s # 设置告警频率（默认1min） # scrape_timeout is set to the global default (10s).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/517899b8970002e59618788272d17ea1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/141e4cf9c6a4f2130c8501e955d9be6b/" rel="bookmark">
			如何将char转换为String？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文翻译自：How to convert a char to a String?
I have a char and I need a String . 我有一个char ，我需要一个String 。 How do I convert from one to the other? 我如何从一个转换为另一个？ #1楼 参考：https://stackoom.com/question/YI1E/如何将char转换为String
#2楼 Nice question. 好问题。 I've got of the following five 6 methods to do it. 我有以下 五种 方法可以做到这一点。 1. String stringValueOf = String.valueOf('c'); // most efficient 2. String stringValueOfCharArray = String.valueOf(new char[]{x}); 3. String characterToString = Character.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/141e4cf9c6a4f2130c8501e955d9be6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca5b475c634477e4a225b9430e600a43/" rel="bookmark">
			实体VO接收前台JSON 日期参数自动转化LocalDateTime全局配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer; import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer; import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer; import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer; import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer; import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer; import org.springframework.boot.autoconfigure.jackson.Jackson2ObjectMapperBuilderCustomizer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import org.springframework.core.convert.converter.Converter; import java.time.LocalDate; import java.time.LocalDateTime; import java.time.LocalTime; import java.time.format.DateTimeFormatter; @Configuration public class DateTimeConfig { /** * Date格式化字符串 */ private static final String DATE_FORMAT = "yyyy-MM-dd"; /** * DateTime格式化字符串 */ private static final String DATETIME_FORMAT = "yyyy-MM-dd HH:mm:ss"; /** * Time格式化字符串 */ private static final String TIME_FORMAT = "HH:mm:ss"; @Bean @Primary public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() { return builder -&gt; builder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca5b475c634477e4a225b9430e600a43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7511a8b428c8a56d0433003eacda3851/" rel="bookmark">
			分别用 VTK 体绘制和面绘制来实现医学图像三维重建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注公众号：【小张Python】，为你准备了 50+ 本Python 精品电子书籍 与 50G + 优质视频学习资料，后台回复关键字：1024 即可获取；如果对博文内容有什么疑问，后台添加作者【个人微信】，可与作者直接进行交流
序言，VTK介绍： VTK 全称为 The Visualization Toolkit (可视化工具)，是一个开源、跨平台、自由获取、支持并行计算的图形应用函数；拥有3D 渲染的最新工具、提供3D交互模式以及2D绘图等。
VTK 包含一个C++类库，目前提供了众多语言接口，例如 Java、Python、TCL；在三维函数库OpenGL 的基础上采用面向对象设计方法发展起来
图形学基本概念和数据结构，是VTK的核心，VTK是通过 Pipline的形式来输送数据，实现预览效果。
三维重建 在 VTK 中，提供了两种重建方式：体绘制和面绘制 (一般来说用VTK做重建，医学图像领域较多，如 Dicom、mha、mhd；当然 VTK 也实现点云重建)
面绘制 利用面绘值用到VTK封装到的 Marching Cube 算法，简称 MC算法，MC 算法的实现主要分为三部分：
1,确定包含等值面的体元 首先介绍一下 体元的概念，体元是三维图像中由相邻的八个体素点组成的正方体方格，英语也叫 Cube，体元中角点函数值分为两种情况，一种是大于等于给定等值面的值 C0 ,则将角点设为 1 称该角点在等值面内部，否则设为0，在等值面之外，
一般来说，会出现一个角点在内，一个角点在外，则角点之间的连线(也就是体元的边)必然与等值面相交，根据这个原理就能判断等值面与哪些体元相交。
体元内每个角点(顶点)有两种情况：0和1，一共8个角点即分为256种( 2 8 = 256 2^8 = 256 28=256 )，根据平面对称性、中心对称性，256种最终降到15种
2，确定等值面与体元边界的交点 找到含有等值面的体元之后，接下来就是确定等值面与体元边界的交点，体元间的数值都是呈线性变化，求交点时一般采用的是线性插值，如 Case0 中等值面的两个端点 一个在外为( 标记0) ，一个在内 ( 标记为1 ) 则交点为0.5；
3，求等值面的法向量 以上步骤 1，2，3 为实现 MC 算法步骤流程，但利用 VTK ，不需要这么繁琐，主要算法步骤都已经封装到 vtkMarchingCube 类中，使用 vtkMarchingCube 时，需要设置三个参数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7511a8b428c8a56d0433003eacda3851/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18aa2dd5b662e93bbc518f6d1dddf3da/" rel="bookmark">
			什么是代码，源文件、编辑和编译？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 前言2 代码3 源文件3.1 关于后缀名3.2 特别注意 4 编辑5 编译6 小结 1 前言 在给本科一二年级的学生教学C语言时，发现有不少同学由于使用计算机少或缺少基本理论的教学，对这程序设计中的很多基本概念并不了解，比如一些基本的文件和后缀名的概念都不清楚，给C语言的实践带来了很多麻烦。所以本文就程序设计的一些相关的基本概念进行简要介绍（注：如无特别指出，所有的示例均指C语言）。
2 代码 我们需要了解的第一概念是代码（也称源代码）。代码是指程序开发人员根据编程语言的语法规则，所编写的用于实现某些功能操作的语句的集合。如以下的示例代码：
#include &lt;stdio.h&gt; int main() { printf("Hello world!\n"); return 0; } 3 源文件 代码的本身就是一串文本形式的数据，需要有一个地方来存储。在计算机中，几乎所有的系统都使用文件来存储数据，所以源文件就是保存代码的文件。比如，我可以用一个记事本文件 hello.txt 来保存代码。
3.1 关于后缀名 为了区分源代码文件和普通文件，一般使用不同的后缀名表示，如C语言就使用 .c，Java 用 .java，python用 .py等。这样的目的是为了更好地区分不同的文件类型，但是本质上都是一样的文本文件，没有本质区别。
3.2 特别注意 在Windows中会自动隐藏后缀名，比如在新建一个文本文件后，只能看到新建文本文件 看不到后缀名 .txt。Windows默认隐藏后缀名的设定给很多初学者带来麻烦。解决的办法只需要简单设置一下即可。在Win10中，只需在文件资源管理器中勾选“查看-&gt;文件扩展名”即可，如下图所示（Win7系统点 这里)。
4 编辑 编辑是对文件内容的修改。由于数据保存在文件中，我们需要一个工具来修改文件，例如对于文本文件 .txt，双击时系统会自动使用系统自带的 notepad 打开、编辑和保存修改内容。对于源文件，同样地我们也需要编辑器来进行编译操作。一般可以对源代码进行操作的编译器有很多，如 Notepad++, Atom, Sublime Text等，推荐初学者使用 Notepad++，不仅免费，而且功能强大。
5 编译 我们所编写的代码是纯文本文件，是为了方便人阅读和查看，所以机器是没有办法执行的。为了让机器能够执行程序，需要进行一个转换操作，将人工编写的代码转换为机器可以执行的程序，就是编译。举例来说，编译就是将 hello.c 转换为 hello.exe 的过程即： hello.c ==编译==&gt; hello.exe。编译后，hello.exe 的内容变成了机器可读而人无法阅读的纯二进制码，如下图所示（上面为 hello.c，下面为 hello.exe）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18aa2dd5b662e93bbc518f6d1dddf3da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aca45e10a1a40bbd754f74dd3d21ca5/" rel="bookmark">
			SecureCRT窗口输出代码关键字高亮设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载高手前辈已经做好的配色方案脚本。
百度网盘连接如下：
链接：https://pan.baidu.com/s/1bKjGey 密码：hzcg 二、查看文件存放路径。
打开CRT：【Options】-【Global Options】-【General】-【Configuration Paths】
上图是以我的电脑为例。
正常情况下应该是如下路径：
C:\Users\Administrator\AppData\Roaming\VanDyke\Config\Keywords
三、把第一步下载的文件脚本，放到上一步找的目录中。
下图是以我自己的电脑为例
正常情况下应该放在如下路径内：
C:\Users\Administrator\AppData\Roaming\VanDyke\Config\Keywords
四、打开当前会话设置窗口，按照下图选择刚才下载的配置文件即可！
【Options】-【Global Options】-【General】-【Default Session】-【Edit Default Settings】
OK完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4179689f95d026b876f174cfff5e989/" rel="bookmark">
			【原创】 ES5高效封装WIN10系统教程2020系列（五）常用软件安装及设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
本教程共有7个系列 **
1. 母盘定制
2. 准备封装环境
3. 母盘安装及系统调整
4. 使用工具优化与清理
5. 常用软件安装及设置
6. ES5封装
7. 测试效果
常规软件安装这章就比较随意了，每个人的工作环境不同，安装软件也不尽相同，不一定照着教程弄，甚至可以直接跳过这章。但是为了保证教程的连贯和完整性，我还是要演示一下。可以看看教程里我是怎么去优化设置软件，比如，如何设置开始菜单仿WIN7,如何设置输入法仿WIN7，还有个别软件的去更新处理。安装常规软件，要保证软件稳定的前提下尽量选用绿色无污染的软件。不要安装那种频繁更新，且如果不更新就不能用的软件，比如微信。本人是搞电脑维修的，预装的常用软件一般都是考虑到大多数人要用的常用软件。今年的软件装安装就直接用我平时经常封装的软件些来演示。
**
本系列共有13个软件和安装设置步骤 **
1.安装搜狗拼音输入法v9.1a及设置输入法仿WIN7优化
2.安装WIN10开始菜单经典优化工具StartIsBack_2.9.0及设置开始菜单仿WIN7优化
3.安装Adobe Flash Player 32.0.0.321
4.安装360zip_noad_4.0.0.1040
5.安装QQ影音播放器QQPlayer_V4.6.0.1078及优化设置
6.安装极速迅雷1.0.35.366
7.安装酷我音乐v8.7.7.0-BCS37
8.安装腾讯视频及设置
9.安装QQ浏览器9.6.5及主页设置
10.安装QQ
11安装腾讯电脑管家及设置
12.安装OFFICE 2019
13.拷贝电脑维护方面的绿色专业工具到开始菜单
**
下面截图演示具体操作过程 抱歉，这篇无法通过审核，想要学习的请到我的博客去看吧，百度我的昵称即可。
常用软件安装及设置就讲到这里，下一章继续讲解最重要的章节ES5封装，敬请期待。。。 **
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f23740f098fdcdbbeb70c0c83a2794a/" rel="bookmark">
			Pytorch 报错：RuntimeError: invalid argument 0: Tensors must have same number of dimensions: got 2 and
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pytorch 报错：RuntimeError: invalid argument 0: Tensors must have same number of dimensions: got 2 and 1 at /pytorch/aten/src/THC/generic/THCTensorMath.cu:62 这种错误有两种可能： 你输入的图像数据的维度不完全是一样的 ，比如是训练的数据有100组，其中99组是256×256，但有一组是384×384，这样会导致Pytorch的检查程序报错；比较隐晦的batchsize的问题 ，Pytorch中检查你训练维度正确是按照每个batchsize的维度来检查的，比如你有1000组数据（假设每组数据为三通道256px256px的图像），batchsize为4，那么每次训练则提取(4,3,256,256)维度的张量来训练，刚好250个epoch解决(2504=1000)。但是如果你有999组数据，你继续使用batchsize为4的话，这样999和4并不能整除，你在训练前249组时的张量维度都为(4,3,256,256)但是最后一个批次的维度为(3,3,256,256)，Pytorch检查到(4,3,256,256) != (3,3,256,256)，维度不匹配，自然就会报错了，这可以称为一个小bug。 解决办法： 对于第一种：整理一下你的数据集保证每个图像的维度和通道数都一致即可。
对于第二种：挑选一个可以被数据集个数整除的batchsize或者直接把batchsize设置为1即可。
转载自：
[1]: https://www.baidu.com/link?url=S5divOmzTDMQtBwoFjH_XJK7EO_9UWweijCAYdeb5wgQh_U9Skt_gQJApCSjGJEHfTddNr745Hc1Cfj8As-ZBK&amp;wd=&amp;eqid=ab8d3eb9000d73b5000000025e8dce87
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ff08ec1539e2c4ba4b085a78a4be18/" rel="bookmark">
			神操作：教你用Python识别恶意软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读：本文将利用静态分析技术揭示这些恶意软件的功能。
作者：约书亚·萨克斯（Joshua Saxe）、希拉里·桑德斯（Hillary Sanders）
来源：大数据DT（ID：hzdashuju）
在本文中，我们将介绍恶意软件静态分析的基础知识。静态分析是对程序文件的反汇编代码、图形图像、可打印字符串和其他磁盘资源进行分析，是一种不需要实际运行程序的逆向工程。虽然静态分析技术有欠缺之处，但是它可以帮助我们理解各种各样的恶意软件。
通过细致的逆向工程，你将能够更好地理解恶意软件二进制文件在攻击目标后为攻击者提供的好处，以及攻击者可以隐藏并继续攻击受感染计算机的方式。正如你将看到的，本文结合了描述和实例，每个部分都介绍了静态分析技术，然后说明其在实际分析中的应用。
本文的代码和数据，可以在公众号后台回复恶意软件获取下载方式。你将在数据目录/ch1中找到本文示例中使用的恶意软件示例。为了演示本文讨论的技术，我们在演示中使用ircbot.exe，这是一个互联网中继聊天（Internet Relay Chat，IRC）机器人，也在日常广泛监测中最常见的恶意软件的示例之一。
严格来说，当连接到IRC服务器时，这个程序被设计常驻在目标计算机上。在ircbot.exe控制目标后，攻击者可以通过IRC控制目标计算机，执行控制指令，例如打开网络摄像头偷偷捕获视频、提取目标的地理位置和桌面的截图，以及从目标机器中提取相关文件等。
01 微软Windows可移植可执行文件格式
要进行恶意软件静态分析，你需要了解Windows PE文件格式，该格式描述了如.exe、.dll和.sys等当今Windows程序文件的结构，并定义了它们存储数据的方式。PE文件包含x86指令、图像和文本等数据，以及程序运行所需的元数据。
PE格式最初的设计是用来进行下面的操作。
1）告诉Windows如何将程序加载到内存中
PE格式描述了文件的哪些块应该加载到内存中，以及在哪里加载。它还告诉你，Windows应该在程序代码里的哪个位置开始执行程序，以及哪些动态链接代码库应该加载到内存中。
2）为运行程序提供在执行过程中可能使用的媒体（或资源）
这些资源可以包括字符串，如GUI对话框或控制台输出的字符串，以及图像或视频。
3）提供安全数据，例如数字代码签名
Windows使用这些安全数据来确保代码出自受信任的来源。
PE格式通过利用图1-1中所示的一系列结构来完成以上工作。
▲图1-1 PE文件格式
如图1-1所示，PE文件格式包括一系列头（header），用来告诉操作系统如何将程序加载到内存中。它还包括一系列节（p）用来包含实际的程序数据。Windows将这些节加载到内存中，使其在内存中的偏移量与它们在磁盘上的显示位置相对应。
让我们从PE头开始，来更详细地探讨这个文件结构。我们将略过对DOS头的讨论，这是20世纪80年代微软DOS操作系统的遗留产物，仅仅出于兼容性原因而存在。
1. PE头
如图1-1底部所示，在DOS头❶的上面是PE头❷，它定义了程序的一般属性，如二进制代码、图像、压缩数据和其他程序属性。它还告诉我们程序是否是针对32位或64位系统而设计的。
PE头为恶意软件分析师提供了基本但有用的情景信息。例如，头里包括了时间戳字段，这个字段可以给出恶意软件作者编译文件的时间。通常恶意软件作者会使用伪造的值替换这个字段，但是有时恶意软件作者会忘记替换，就会发生这种情况。
2. 可选头
可选头❸实际上在今天的PE可执行程序中无处不在，恰恰与其名称的含义相反。它定义了PE文件中程序入口点的位置，该位置指的是程序加载后运行的第一个指令。
它还定义了Windows在加载PE文件、Windows子系统、目标程序（例如Windows GUI或Windows命令行）时加载到内存中的数据大小，以及有关该程序其他的高级详细信息。由于程序的入口点告诉了逆向工程师该从哪里开始进行逆向工程，这个头信息对逆向工程师来说是非常宝贵的。
3. 节头
节（p）头❹描述了PE文件中包含的数据节。PE文件中的一个节是一块数据，它们在操作系统加载程序时将被映射到内存中，或者包含有关如何将程序加载到内存中的指令。
换句话说，一个节是磁盘上的字节序列，它要么成为内存中一串连续字节的字符串，要么告知操作系统关于加载过程的某些方面。
节头还告诉Windows应该授予节哪些权限，比如程序在执行时，是否应该可读、可写或可执行。例如，包含x86代码的.text节通常被标记为可读和可执行的，但是不可写的，以防止程序代码在执行过程中意外修改自身。
图1-1描述了许多节，如.text和.rsrc。执行PE文件时，它们会被映射到内存中。其他如.reloc节的特殊节不会被映射到内存中，我们也将讨论这些节。下面我们来浏览图1-1中显示的节。
1）.text节
每个PE程序在其节头中包含了至少一个标记为可执行的x86代码节；这些节几乎总是命名为.text❺。
2）.idata节
.idata节❻，也被称为导入节，包含导入地址表（IAT），它列出了动态链接库和它们的函数。IAT是最重要的PE结构之一，在对PE二进制文件进行最初的分析时需要查看它，因为它指出了程序所调用的库，然而这些调用反过来又可能会泄露恶意软件的高级功能。
3）数据节
在PE文件结构中的数据节可以包括.rsrc、.data和.rdata等节，它们存储程序使用的鼠标光标图像、按钮图标、音频和其他媒体等。例如，图1-1中的.rsrc节❼包含了程序用于将文本呈现为字符串的可打印字符串。
.rsrc（资源）节中的信息对恶意软件分析师是非常重要的，因为通过检查PE文件中的可打印字符串、图形图像和其他资产，他们可以获得关于文件功能的重要线索。
在03节中，你将了解如何使用icoutils工具包（包括icotool和wrestool）从恶意软件二进制文件的资源节中提取图形图像。然后，在04节中，你将学习如何从恶意软件资源节中提取可打印的字符串。
4）.reloc节
PE二进制文件的代码并非是与位置独立的，这意味着如果将它从预期的内存位置移动到新的内存位置，它将无法正确执行。.reloc❽在不破坏代码的情况下通过允许移动代码来解决这个问题。
如果一个PE文件的代码已被移动，它就告诉Windows操作系统将该文件的代码中进行内存地址转换，这样代码仍可以正确运行。这些转换通常涉及在内存地址中添加或减去偏移量。
02 使用pefile解析PE文件格式
由Ero Carerra编写和维护的Python模块pefile已经成为解析PE文件的一个行业标准的恶意软件分析库。在本节中，我将向你展示如何使用pefile来解析ircbot.exe。代码清单1-1假设ircbot.exe已位于你当前的工作目录中。
输入以下命令安装pefile库，以便我们可以在Python中导入它：
$ pip install pefile 现在，使用代码清单1-1中的命令启动Python，导入pefile模块，然后使用pefile打开并解析PE文件ircbot.exe。
代码清单1-1 加载pefile模块并解析PE文件（ircbot.exe）
$ python &gt;&gt;&gt; import pefile &gt;&gt;&gt; pe = pefile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4ff08ec1539e2c4ba4b085a78a4be18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2594389508fce95dacdbfb0976fdc767/" rel="bookmark">
			OBS-25版本支持srt推流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		３月份OBS开源社区推出OBS25候选版本时，即开放了srt的推流功能测试。目前release版本已经能稳定的支持srt推流。
srt的推流方式为，点开obs右下角的 设置-&gt;推流面板，参数设置如下：
1.服务：请选择自定义方式；
2.服务器：这一栏直接填写接收端的完整url地址。比如我们要推流的服务器IP地址为172.16.133.199，端口为10080，应用名为live，流名称为123，那么推流地址应写成：
srt://172.16.133.19:10080?streamid=#!::h=live/123,m=publish
最后的publish表示本OBS端为传输推流端（如果是拉流端的话，此处应为request）；
3.串流密钥：留空，不填写任何东东（对于rtmp推流，此处应填写流名称）；
4.使用身份验证：对于接收端要求身份验证的，请勾上此复选框，并填写用户名和密码，否则请不勾选。
根据施大神的一篇ppt揭示，原始的srt协议在自适应编码方面的控制不是很好，算法过于简单，如图所示
根据实际测试来看，目前的obs版本对srt的支持上，这点推测应该也没有做优化。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/372/">«</a>
	<span class="pagination__item pagination__item--current">373/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/374/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>