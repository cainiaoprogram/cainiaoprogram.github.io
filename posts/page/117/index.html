<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd53542de8caf2755bb57b28ef524365/" rel="bookmark">
			编程之美：优雅解决复杂问题的思维模式与方法论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优雅地解决复杂问题是每个人都希望具备的能力。在现代社会，我们面临各种复杂的挑战，例如技术革新、组织变革、环境问题等。解决这些复杂问题需要一种系统性、全面性的思维模式和方法论。下面将介绍一些常用的思维模式和方法论，帮助读者更好地应对复杂问题。
首先，系统思维是解决复杂问题的基石。系统思维是一种将问题看作相互关联和相互影响的各个部分组成的整体的思维方式。它能够帮助我们理解问题的复杂性，并找到解决问题的整体策略。通过绘制思维导图、流程图等工具，将问题分解为多个子问题，并分析它们之间的相互关系，从而找到解决问题的最佳路径。
其次，分析与综合是在解决复杂问题时常用的思维模式。分析是将问题分解为更小、更易处理的部分，以便更好地理解问题的本质和结构。综合是将各个部分重新组合，形成一个更完整的解决方案。通过分析与综合的思维模式，我们可以从整体和细节两个角度全面地考虑问题，并找到最优的解决方案。
逆向思维是解决复杂问题的重要方法之一。逆向思维要求我们设想已经解决了问题，然后反推回当前的状态，找出实现目标的路径和策略。逆向思维能够帮助我们发现问题中的关键因素和瓶颈，并采取相应的措施来解决问题。
创新思维是解决复杂问题的必备素质。创新思维是一种跳出传统思维模式的思考方式。在解决复杂问题时，我们需要从不同的角度、跨界思考，挖掘新的解决方案。创新思维可以通过头脑风暴、类比、隐喻等方法来激发创造力，找到原来未曾想到的解决办法。
团队协作是解决复杂问题的关键。在解决复杂问题时，团队成员可以共同分析和讨论问题，各自提供不同的观点和见解，从而提供更多的解决方案。通过有效的沟通和合作，团队可以充分发挥每个人的优势，形成整体的智慧和创造力，更好地解决复杂问题。
除了以上的思维模式外，还有一些常用的方法论可以应用于解决复杂问题，如六西格玛、PDCA循环、敏捷开发等。这些方法论提供了一种结构化的解决问题的框架，帮助我们更加系统和有效地解决问题。
总而言之，解决复杂问题需要思维模式和方法论的支持。系统思维、分析与综合、逆向思维、创新思维和团队协作是一些常用且有效的思维模式，可以帮助我们理清问题，找到解决方案。此外，六西格玛、PDCA循环、敏捷开发等方法论也可以提供一种结构化的解决问题的方式。通过学习和实践这些思维模式和方法论，我们可以不断提升解决复杂问题的能力，迎接各种挑战。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/725836a2dc642b26c0e2a234afb73b3d/" rel="bookmark">
			跨模态视频检索系统的前后端消息队列技术，使负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跨模态视频检索系统的前后端消息队列技术，使负载均衡 消息队列技术讲解 消息队列（Message Queue）是一种应用程序之间通信的方式，它可以将消息存储在一个队列中，让发送者和接收者能够异步地进行消息交换。消息队列有以下几个优点：
解耦：发送者和接收者不需要知道对方的存在，只需要关注消息的内容和格式。缓冲：当发送者发送速度大于接收者处理速度时，消息队列可以缓存消息，避免数据丢失或拥塞。异步：发送者和接收者不需要同时在线，可以在不同的时间点进行消息发送和接收。可靠性：消息队列可以保证消息的持久化和顺序性，以及提供重试和补偿机制，防止消息丢失或重复。扩展性：消息队列可以支持多对多的通信模式，以及动态地增加或减少发送者和接收者的数量，实现系统的水平扩展。 常见的消息队列技术有RabbitMQ、Kafka、ActiveMQ、Redis等。
代码框架 以下是一个使用Python和RabbitMQ实现的简单的前后端消息队列技术的代码框架：
前端 import pika # 连接RabbitMQ服务器 connection = pika.BlockingConnection(pika.ConnectionParameters('localhost')) channel = connection.channel() # 声明一个名为query的队列 channel.queue_declare(queue='query') # 定义一个回调函数，用于处理后端返回的结果 def callback(ch, method, properties, body): print("Received %r" % body) # 订阅名为result的队列，并指定回调函数 channel.basic_consume(queue='result', on_message_callback=callback, auto_ack=True) # 发送一个查询请求到名为query的队列 channel.basic_publish(exchange='', routing_key='query', body='Hello World!') print("Sent 'Hello World!'") # 开始接收后端返回的结果 channel.start_consuming() 后端 import pika # 连接RabbitMQ服务器 connection = pika.BlockingConnection(pika.ConnectionParameters('localhost')) channel = connection.channel() # 声明一个名为query的队列 channel.queue_declare(queue='query') # 声明一个名为result的队列 channel.queue_declare(queue='result') # 定义一个处理函数，用于处理前端发送的查询请求，并返回结果 def process(ch, method, properties, body): print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/725836a2dc642b26c0e2a234afb73b3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eff2f78b12a301cc07255d0eb9a835c5/" rel="bookmark">
			Anaconda超详细教程2023/7/10(windows)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 Anaconda是一个强大的开源数据科学平台,它将很多好的工具整合在一起，极大地简化了使用者的工作流程，并能够帮助使用者解决一系列数据科学难题。在学习机器学习时，一般都会使用Anaconda。
有小伙伴纠结先安装python还是安装anaconda，这边的建议是装anaconda，就不需要单独装python了，因为anaconda自带python，且安装了anaconda之后，默认python版本是anaconda自带的python版本。
Anaconda下载地址 注：在anaconda安装的过程中，比较容易出错的环节就是环境变量的配置，所以大家在配置环境变量的时候，要细心一些
进入Anaconda官网。 直接点击，进去就是这个界面，然后点击Dowload注意必须是windows环境下且对应64位
查看电脑位数可以右键此电脑——》属性
官网下载太慢了，推荐下载地址：** 点击这里到清华镜像站下载
安装详细步骤
1、双击下载好的安装包
2、点击Next
3、点击I Agree
4、选择All Users,再点击next
5、选择安装路径，这里一定一定不要选择C盘
6、只选择第二项，第二项是说要默认使用python版本，后期手动添加环境变量，第一个是创建快捷方式，然后安装install
7. 点击install,等待一会,点击next
8.点击next
9.对于两个’learn‘，都取消打勾，然后finish
10.然后就等待它安装好，手动配置环境变量
配置环境变量 此电脑（右键）——》属性——》高级系统设置——》点击环境变量
在系统变量里面找到并点击Path
选中path再编辑新建环境变量
D:\APPS\Anaconda3
D:\APPS\Anaconda3\Scripts
D:\APPS\Anaconda3\Library\bin
D:\APPS\Anaconda3\Library\mingw-w64\bin
D:\APPS\Anaconda3\Library\usr\bin
简要说明五条路径的用途：这五个环境变量中，1是Python需要，2是conda自带脚本，3是jupyter notebook动态库, 4是使用C with python的时候
然后确认
检查安装是否成功 同时按住win+r ,输入cmd,在弹出的命令行查看conda的版本
conda --version
输入python
若出现版本号，即表示配置成功
在电脑屏幕左下角的Windows徽标键这里，选择点击绿色圈圈Anaconda Navifator将其打开
出现此界面就表示anaconda安装成功
到这里，基本安装和设置都结束了，如果提示你需要更新的你自行更新即可。
更改conda源（后续安装第三方库可以加快速度） conda install 包名
安装需要的Python包非常方便，但是官方服务器在国外，下载龟速，国内清华大学提供了Anaconda的镜像仓库，我们把源改为 清华大学镜像源
国内常用镜像源 清华大学 ：https://pypi.tuna.tsinghua.edu.cn/simple/ 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科学技术大学 ：http://pypi.mirrors.ustc.edu.cn/simple/ 华中科技大学：http://pypi.hustunique.com/ 豆瓣源：http://pypi.douban.com/simple/ 腾讯源：http://mirrors.cloud.tencent.com/pypi/simple 华为镜像源：https://repo.huaweicloud.com/repository/pypi/simple/
1、临时使用
pip install [包名] -i [pip源URL]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eff2f78b12a301cc07255d0eb9a835c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5edf39d9c549c5e79cacf473fa64e132/" rel="bookmark">
			YOLOV8原理和实现全解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 简介
2. YOLOv8 概述
3. 模型结构设计
4. Loss 计算 5. 训练数据增强
6. 训练策略
7. 模型推理过程 8. 总结
1. 简介 YOLOv8 是 Ultralytics 公司在 2023 年 1月 10 号开源的 YOLOv5 的下一个重大更新版本，目前支持图像分类、物体检测和实例分割任务，在还没有开源时就收到了用户的广泛关注。
按照官方描述，YOLOv8 是一个 SOTA 模型，它建立在以前 YOLO 版本的成功基础上，并引入了新的功能和改进，以进一步提升性能和灵活性。具体创新包括一个新的骨干网络、一个新的 Ancher-Free 检测头和一个新的损失函数，可以在从 CPU 到 GPU 的各种硬件平台上运行。 不过 Ultralytics 并没有直接将开源库命名为 YOLOv8，而是直接使用 Ultralytics 这个词，原因是 Ultralytics 将这个库定位为算法框架，而非某一个特定算法，一个主要特点是可扩展性。其希望这个库不仅仅能够用于 YOLO 系列模型，而是能够支持非 YOLO 模型以及分类分割姿态估计等各类任务。 总而言之，Ultralytics 开源库的两个主要优点是：
融合众多当前 SOTA 技术于一体未来将支持其他 YOLO 系列以及 YOLO 之外的更多算法 下表为官方在 COCO Val 2017 数据集上测试的 mAP、参数量和 FLOPs 结果。可以看出 YOLOv8 相比 YOLOv5 精度提升非常多，但是 N/S/M 模型相应的参数量和 FLOPs 都增加了不少，从上图也可以看出相比 YOLOV5 大部分模型推理速度变慢了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5edf39d9c549c5e79cacf473fa64e132/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f43a19ac1cbd8c28d3aafb81ec2cf3c/" rel="bookmark">
			LongLLaMA：LLaMA的升级版，处理超长上下文的利器！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文来源：芝士AI吃鱼
有效整合新知识：大模型面临的挑战
大家使用过大型模型产品的时候可能会遇到一个共同的问题：在进行多轮对话时，模型可能会忘记之前的对话内容，导致回答不连贯。这实际上是由于大型模型在处理大量新内容时有时会力不从心，给人一种分心的感觉。
这个问题实际上也是当前大型模型面临的一个主要挑战，即如何有效地将大量新知识整合到模型中。目前常见的解决方法之一是微调（fine-tune），但这种方法不仅需要大量资源和复杂的流程，而且并不能总是清晰地指导模型如何整合新知识。例如，对《爱丽丝梦游仙境》这样的文本进行微调，不能让模型回答与故事本身相关的问题，只能让模型预测下一个词或者补全句子。这种情况让人感到很沮丧。
整合新知识的替代方法：上下文整合
除了微调外，另一种有效的替代方法是将新知识整合到上下文中，而无需进行模型训练。然而，这种方法受到模型上下文长度的限制。为了处理大型知识数据库，模型需要将上下文长度扩展到数百万个标记，但这在现实中是不可行的。即使是强大的GPT-4模型，其上下文长度也只有32K。
谷歌DeepMind研究团队最近提出了一种名为"Focused Transformer"（FoT）的注意力集中的Transformer架构，旨在解决大型模型的分心问题。他们使用FoT对LLaMA模型进行微调，从而获得了名为LongLLaMA的模型，其架构与LLaMA相同。通过解决大型模型的分心问题，LongLLaMA显著提高了模型的上下文长度，并且在passkey检索任务中甚至可以扩展到256K长度的上下文。更重要的是，LongLLaMA对标准Transformer的改动非常小，可以无缝切换到其他任务的大型语言模型。
Focused Transformer（FoT）是一种注重注意力集中的Transformer架构。它通过优化模型的注意力机制，帮助模型更好地处理大量新知识和上下文信息。这项创新技术的引入使得模型能够有效整合新知识，提高对话的连贯性。
在FoT的基础上，研究团队对LLaMA模型进行了微调，得到了LongLLaMA模型。与LLaMA相比，LongLLaMA在处理上下文长度方面取得了显著的改进。在passkey检索任务中，LongLLaMA能够处理长达256K的上下文信息，这在过去是难以实现的。
LongLLaMA-3B模型在上下文长度为100k时准确率达到94.5％，在上下文长度达到256k的准确率为73％，而标准的LLaMA-3B模型在上下文长度2k时准确率接近于0，已基本不可用了。
FoT的实现方法很简单，它实际和谷歌2022年提出的一个内存加大版的transormer—Memoryrizing Transormer非常相似，后面我们也会详细讨论FoT和它的区别。FoT额外使用了一块较大的内存来存储历史信息的key-value对，然后借鉴了对比学习的思想在训练阶段中使用跨批次训练（cross-btach）将大量历史信息融入到样本中以增强key-value对的空间结构，这样模型就能对更加专注在和当前问题非常相关的历史信息中。
目前LongLLaMA模型的代码和权重已经公布在github和Hugging Face：
论文链接:
https://arxiv.org/pdf/2307.03170.pdf
项目地址：
https://github.com/CStanKonrad/long_llama
Hugging Face：
https://huggingface.co/syzymon/long_llama_3b
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42f62905f92cbb6c73784f268e79cfb6/" rel="bookmark">
			Windows VScode如何配置与使用git？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当我们在VScode中编写代码后，需要提交到git仓库时，但是我们又不想切换到git的命令行窗口，我们可以在VScode中配置git，然后就可以很方便快捷的把代码提交到仓库中。
1. 官网下载安装Git命令行工具 根据自己的电脑系统，选择相应的版本，我这里是下载的 Windows 安装完成后，在桌面上点击右键，出现下图所示的图标，则表示安装成功
2.配置VScode中的git 在输入框中输入 git.path ，再点击第二个地方，打开 settings.json 文件
在 settings.json 文件中，添加 git 的安装路径
然后关闭 VScode ，再次打开，点击左侧的第3个图标，发现第2和第3个地方变成了可点击状态，表示git环境配置成功。
3. 使用 VScode + git，提交到仓库 git clone ‘项目的git远程仓库路径’修改的代码提交到远程仓库
【注意】提交到远程仓库需要输入账号和密码。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d2b0521f6fef55728144260b2c79bfa/" rel="bookmark">
			git reset 命令详解 git revert命令详解。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git reset 命令详解 reset命令介绍参数使用commit还没有pushcommit 已经push 补救 git revert命令revert说明举例命令 reset命令 介绍 git reset 命令格式为:
git reset [ --soft | --mixed | --hard ] [&lt; commitid &gt;]
在git的这些命令中git reset是最长常用的，也是最危险的最容易被误用的。它的主要参数是：soft,mixed,hard它们告诉git，当执行reset是，要对index和working copy做什么。
参数 soft:
–soft参数只将其它的commit重置到你选定的HEAD，index和working copy中的数据不变。
mixed:
–mixed参数是将HEAD和index重置到你选定的HEAD，而working copy不变。
hard:
–hard是将HEAD，index，working copy同时改变到你规定的commit上。
注意：commitid是每次你要回退到的那个commit的id,它可以通过git log获取。
使用 commit还没有push 可以看到我新进行了一次提交，但是还没有push。此时我发现，我提交错了，要撤回这次提交。
执行：
git log 要退回到错误提交的上一次提交。
# 什么都不写 默认 --mixed git reset 0997fab2fa0bfa468cc5c55e56d7df0491869c3a 可以看到，执行了命令之后版本退回去了，但是修改的内容还在。
如果不想要修改的内容了
# --hard 丢弃修改的内容 git reset --hard 0997fab2fa0bfa468cc5c55e56d7df0491869c3a 退回到了指定版本，修改的内容也没了。
commit 已经push 回退的方式同上，执行完上面指定命令后 可以看到，线上代码还在错误提交那里，本地代码再18:28提交的那一次那里。右下方出现小蓝点，说明线上代码比本地代码更新。
此时如果你push，会提示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d2b0521f6fef55728144260b2c79bfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af7cae71d58dd4189588e7444830f256/" rel="bookmark">
			SSRF漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言
作者简介：不知名白帽，网络安全学习者。
博客主页：不知名白帽的博客_CSDN博客-网络安全,CTF,内网渗透领域博主
网络安全交流社区：https://bbs.csdn.net/forums/angluoanquan
目录
SSRF漏洞原理
产生CSRF的函数
SSRF中常见手法
File协议
Dict协议
Sftp协议
http协议
Tftp协议
SSRF绕过
常见的限制
绕过
SSRF防御
SSRF漏洞原理 SSRF漏洞形成的原因是应用程序存在可以从其他服务器获取数据的功能，但是服务器的地址并没有做严格的过滤，导致应用程序可以访问任意的URL链接，攻击者通过精心构造URL链接，进行一下攻击：
可以通过服务器获取内网主机、端口和banner信息对内网的应用程序进行攻击利用file协议读取文件可以攻击内网程序造成溢出 产生CSRF的函数 file_get_contentsfsockopencurl_exec SSRF中常见手法 使用pikachu的SSRF(CURE)练习
File协议 file:///文件路径
可以查看本地文件
查看重要文件/etc/passwd或者windows/win.ini
Dict协议 dict://ip:port
可以查看开放端口
Sftp协议 sftp://攻击机ip:port
SSH文件传输协议或安全文件传输协议
http协议 http://
可以用来访问内网资源
可以判断常见端口
Tftp协议 tftp://
简单文件传输协议，允许客户端从远程主机获取文件或将文件上传至远程主机
SSRF绕过 常见的限制 限制为http://www.xxx.com 域限制请求IP不为内网地址限制请求只为http协 绕过 限制为http://www.xxx.com 域名时（利用@）采用短网址绕过采用进制转换 SSRF防御 ,过滤返回信息，验证远程服务器对请求的响应是比较容易的方法统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态限制请求的端口为http常用的端口黑名单内网ip禁用不需要的协议。仅仅允许http和https请求 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85f52010d29d46f539c3533906229bce/" rel="bookmark">
			oracle12c单机部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、虚拟机图形化界面部署 ps：这个是在虚拟机部署的时候，安装oracle需要图形化界面，部署虚拟机的环境
1.创建虚拟机（典型） 创建虚拟机选择"典型"方式
避免自动安装-选择稍后安装系统.
选择虚拟机中的linux centos7系统
设置虚拟机名字与位置
在电脑中创建出指定文件存储虚拟机，一个文件存储一个。
虚拟机会占用大量内存，选用大内存的硬盘
设置虚拟机最大磁盘空间，搭建架构机器内存最少50g（本次给60g）
最后进入配置,调整内存大小选择系统光盘
本次安装的是oracle，给的内存大点，本次给了4g内存
内存选择好，选择系统光盘镜像
2.部署linux环境 准备部署安装Linux系统 ：CentOS-7-x86_64-DVD-2009.iso
对网卡名进行配置 biosdevname=0 net.ifnames=0 #网卡名字 ensxxx --&gt;eth0 eth1 #用于让网卡名字变成ethx 形式eth0 eth1 ,centos 7中默认是ens33 进入系统后后，选择 Istall cento7 ，按下‘tab键’，进入下方命令行模式，输入上方修改网卡配置。
选择语言，选择为英文模式
对网卡进行配置
检查 net.ifnames=0 biosdevname=0 是否配置成功
点击“配置”，进行网卡配置
选择开机自启动网卡
手动配置eth0网卡,点击save进行保存
配置ip地址等信息 ip: 10.0.0.200 子网掩码:24 网关: 10.0.0.2 dns: 223.5.5.5,223.6.6.6 #配置的时候是逗号 最后检查
关闭Kdump
磁盘分区(自动)
选择软件包（安装oracle要选择带gui的图像化界面）
检查时间
开始安装
设置root密码，本次密码为1
配置普通用户cmx，密码为1
3.进入Linux系统 配置认证
以root用户登录系统
配置语言
命令行管理模式
检查IP地址并检查网络连通性
4.基础优化 关闭防火墙和selinux
#firewalld systemctl stop firewalld #关闭防火墙 systemctl disable firewalld #关闭防火墙开启自启动 systemctl status firewalld #selinux sed -i 's#SELINUX=enforcing#SELINUX=disabled#g' /etc/selinux/config #enforcing更改为disabled setenforce 0 #关闭selinux getenforce #结果只要不是enforcing就表示关闭了.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85f52010d29d46f539c3533906229bce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6201c640f19949490c0d32813fbc0ddc/" rel="bookmark">
			PHY芯片快速深度理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：
什么是phy
为什么要熟悉RJ45网口
网络七层协议
两个模块进行通信
什么是MDIO协议
MDIO的作用 MDIO没那么重要
MDIO读写时序
为什么说读取的phy最多32个
什么是phy
物理层芯片称为PHY、数据链路层芯片称为MAC。
可以看到PHY的数据是RJ45网络接口（网线口）穿过了的差分信号，而PHY作用就是将差分信号转为数字信号，这块内容不用深究，制造商都设计好了。那我们干什么呢？（主要是对phy芯片进行模式选择，比如工作速率，工作模式）
为什么要熟悉RJ45网口
上面说到针对phy芯片我们只要进行模式选择（下文海翎光电的小编会介绍使用mdio接口，通过寄存器控制）那模式选择后，如何查看是否有效呢？最简单直接的就是通过RJ45网口的指示灯查看。
RJ45 座子上一般有两个灯，一个黄色(橙色)，一个绿色，绿色亮的话表示网络连接正常，黄色闪烁的话说明当前正在进行网络通信，黄灯闪动频率快表示网速好，这两个灯由 PHY 芯片控制。
如果不懂物理层和数据链路层可以和海翎光电的小编一起看一下网络七层协议。
网络七层协议
两个模块进行通信
下图是两个主控直接的通信，比如我们的电脑和路由器 ，但是如果没有中间的介质还能连接网络吗？答案是可以的
如果phy芯片没有，那么可以直接通过两个mac连接进行通信，之所以需要mac 、phy、变压器的目的是为了转换数据类型适配所以的网线，但是在一些电路上，没必要加这么多东西
比如搭载 Linux系统的arm芯片想要网络，可以直接通过mac和网卡芯片连接获取，这时候就需要通过RGMII接口或者MII接口 和 MDIO 连接网卡芯片。
（网卡芯片内置也是mac+phy，有的只有mac 层这个要看具体的手册）
什么是MDIO协议
mido协议即SMI协议，SMI协议也是一种通信协议类似与I2C协议但是通信方式不一样。SMI包含两根信号线，一个MDC时钟线，一个MDIO双向传输的数据线，
如图为SMI应用框图。STA设备通过MDIO接口与PHY通信。STA（StaTIon Management）为主控设备，比如MCU、MAC、ONU等。PHY为从设备。一个STA最多管理32个PHY。MDC信号由STA控制，MDIO信号根据通信方式的不同可以由STA或者PHY接管控制。如图通常MDIO会接一个电阻上拉至接口电源。
MDIO的作用 从上面的连接图可以看到MDIO是用来连接主设备和多个PHY设备，并且通过MDIO来传输数据。那么传输的是数据是哪些呢？主要是传输链接状态、传输速度与选择、断电、低功率休眠状态、TX/RX模式选择、自动协商控制、环回模式控制等。
MDIO没那么重要
MDIO在上面说到的两个模块通信，我提到了 arm芯片和网卡芯片直接需要，那么这个真的有必要吗？其实没必要连接！！！
换个话说 不连接也可以使得网络畅通，因为网络的数据传输时靠RGMII不是靠MDIO，MDIO的作用仅仅只是用来查看一些状态和功能，还有简单的控制，而这些简单的控制是完全可以有网卡芯片内置去写死，arm层只要和网卡的写的一直就可以通讯。
但是为什么很多时候需要通过mdio来进行读写控制，这个只是在网络通讯正常后的升级优化，用来方便查看状态，就像写了个前端网页来看后台数据。
如果mido没有读通，或者读取的数据是0xfffff，那么不一定是mdio的问题，很多时候是网卡本身没有启动！
MDIO读写时序
Preamble：32bits的前导码
Start：2bit的开始位。
OP Code：2bits的操作码，10表示读，01表示写。
PHYAD：5bits的PHY地址。
REGAD：5bits的寄存器地址，即要读或写的寄存器。
Turn Around：2bits的TA，在读命令中，MDIO在此时由MAC驱动改为PHY驱动，并等待一个时钟周期准备发送数据。在写命令中，不需要MDIO方向发生变化，则只是等待两个时钟周期准备写入数据。
Data：16bits数据，在读命令中，PHY芯片将读到的对应PHYAD的REGAD寄存器的数据写到Data中，在写命令中，MAC将要写入对应PHYAD的REGAD寄存器的值写入Data中。
Idle：空闲状态，此时MDIO无源驱动，处高阻状态，但一般用上拉电阻使其处在高电平，上拉电阻一般为1.5K。为什么说读取的phy最多32个
因为mdio中读取的phy只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个，但这是从读取的方式判断的，而mdio读取是依照phy芯片本身地址空间就5为。
为什么说reg地址最多32个
同样mdio中读取的reg只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个
PHY 芯片寄存器地址空间为 5 位，地址 0-31 共 32 个寄存器， IEEE 定义了 0-15 这 16 个寄存器的功能， 16~31 这 16 个寄存器由厂商自行实现。也就是说不管你用的哪个厂家的 PHY 芯片，其中 0~15 这 16 个寄存器是一模一样的。仅靠这 16 个寄存器是完全可以驱动起 PHY 芯片的，至少能保证基本的网络数据通信。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6201c640f19949490c0d32813fbc0ddc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c9c28602a15e08a60ff9ddc1fbe72d8/" rel="bookmark">
			如何获取局域网内海康摄像头的IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题解决方法图像分类网络AlexNetVGGNetGooLeNet系列ResNetDenseNetSwin TransformerMAECoAtNetConvNeXtV1、V2MobileNet系列MPViTVITSWAEfficientNet系列MOBILEVITEdgeViTsMixConvRepLKNetTransFGConvMAEMicroNetRepVGGMaxViTMAFormerGhostNet系列DEiT系列MetaFormerRegNetInternImageFasterNet 注意力机制物体检测行人属性识别行人跟踪OCR超分辨采样弱光增强RetinexNet NLP多模态知识蒸馏剪枝智慧城市 问题 在房间里部署了很多海康摄像头，但是却不知道IP地址，如何才能获取到这些摄像头的IP地址呢？
解决方法 海康提供了一个工具，将其下载后安装即可，下载地址：
https://www.hikvision.com/cn/support/tools/hitools/clea8b3e4ea7da90a9/ 通过SADP软件搜索局域网内所在网段的在线设备。同时支持查看设备信息、激活设备、修改设备的网络参数、重置设备密码等功能
还有更多的工具，链接：
https://www.hikvision.com/cn/support/tools/hitools/ 文章目录 问题解决方法图像分类网络AlexNetVGGNetGooLeNet系列ResNetDenseNetSwin TransformerMAECoAtNetConvNeXtV1、V2MobileNet系列MPViTVITSWAEfficientNet系列MOBILEVITEdgeViTsMixConvRepLKNetTransFGConvMAEMicroNetRepVGGMaxViTMAFormerGhostNet系列DEiT系列MetaFormerRegNetInternImageFasterNet 注意力机制物体检测行人属性识别行人跟踪OCR超分辨采样弱光增强RetinexNet NLP多模态知识蒸馏剪枝智慧城市 图像分类网络 AlexNet 【第61篇】AlexNet：CNN开山之作
VGGNet 【第1篇】VGG
GooLeNet系列 【第2篇】GooLeNet
【第3篇】Inception V2
【第4篇】Inception V3
【第62篇】Inception-v4
ResNet 【第5篇】ResNet
DenseNet 【第10篇】DenseNet
Swin Transformer 【第16篇】Swin Transformer
【第49篇】Swin Transformer V2：扩展容量和分辨率
MAE 【第21篇】MAE（屏蔽自编码器是可扩展的视觉学习器）
CoAtNet 【第22篇】CoAtNet：将卷积和注意力结合到所有数据大小上
ConvNeXtV1、V2 【第25篇】力压Tramsformer，ConvNeXt成了CNN的希望
【第64篇】ConvNeXt V2论文翻译：ConvNeXt V2与MAE激情碰撞
MobileNet系列 【第26篇】MobileNets：用于移动视觉应用的高效卷积神经网络
【第27篇】MobileNetV2：倒置残差和线性瓶颈
【第28篇】搜索 MobileNetV3
MPViT 【第29篇】MPViT：用于密集预测的多路径视觉转换器
VIT 【第30篇】Vision Transformer
SWA 【第32篇】SWA：平均权重导致更广泛的最优和更好的泛化
EfficientNet系列 【第34篇】 EfficientNetV2：更快、更小、更强——论文翻译
MOBILEVIT 【第35篇】MOBILEVIT：轻量、通用和适用移动设备的Vision Transformer
EdgeViTs 【第37篇】EdgeViTs： 在移动设备上使用Vision Transformers 的轻量级 CNN
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c9c28602a15e08a60ff9ddc1fbe72d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e53eeb089ad3e178aaa810e721d7925/" rel="bookmark">
			实现：Vue点击按钮，跳转到新的页面。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法：routerLink标签-添加target="_blank" 。即可跳转新的页面 &lt;router-link target="_blank" :to="{path:'/basicLifeChart',query:{valueNum:'1111'}}"&gt;八字排盘&lt;/router-link&gt; 路由配置： { path:'/basicLifeChart', name:'basicLifeChart', component:()=&gt; import('@/views/basicLifeChart.vue'), meta:{ name:'基础命盘' } } 第二种方法：
语法是vue3
&lt;el-button type="primary" @click="onSubmit"&gt;开始排盘&lt;/el-button&gt; &lt;a style="width: 0; height: 0;" ref="target" href="" target="_blank"&gt;&lt;/a&gt; &lt;script setup&gt; import { ref } from 'vue'; //获取ref const target = ref(null); // 点击事件 const onSubmit = () =&gt; { console.log(target.value);//a标签 console.log(window.location);//获得端口协议域名 target.value.setAttribute('href', window.location.origin + '/basicLifeChart') target.value.click() } &lt;/script&gt; document.setAttribute() 方法创建或改变某个新属性。
如果指定属性已经存在,则只设置该值。
...完结！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cc5592f8290c556d6b4a087aed94f6a/" rel="bookmark">
			Android 13媒体文件访问权限适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：# Google技术征文 # Android 13媒体文件访问权限适配-51CTO开发者训练营-51CTO.COM
众所周知，从Android 4.4（Api Level 19）开始，开发者想要开发访问其他应用向外部存储空间提供的媒体文件的功能，譬如自定义用户头像、发送图文评论、播放音乐和剪辑视频等，都需要一个重要的权限——READ_EXTERNAL_STORAGE。而Android 13（Api Level 33）则将READ_EXTERNAL_STORAGE进一步细分成为了读取图片的READ_MEDIA_IMAGE、读取视频的READ_MEDIA_VIDEO和读取音频的READ_MEDIA_AUDIO，本文主要介绍在媒体文件权限方面如何适配Android 13
首先要在AndroidManifest中对声明权限做如下修改：
&lt;!-- 一般来说，允许用户自定义头像的app都需要这个权限 --&gt; &lt;uses-permission android:name="android.permission.READ_MEDIA_IMAGES" android:minSdkVersion = "33"/&gt; &lt;!-- 如果你想开发音乐播放器之类需要获取音频的app，加上这个权限 --&gt; &lt;uses-permission android:name="android.permission.READ_MEDIA_AUDIO" android:minSdkVersion = "33"/&gt; &lt;!-- 如果你想开发视频编辑器之类需要获取视频的app，加上这个权限 --&gt; &lt;uses-permission android:name="android.permission.READ_MEDIA_VIDEO" android:minSdkVersion = "33"/&gt; &lt;!-- 向前兼容 --&gt; &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" android:maxSdkVersion="32" /&gt; 然后在代码中申请权限：
if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) { ActivityCompat.requestPermissions( activity,new String[]{ READ_MEDIA_IMAGES, READ_MEDIA_AUDIO, READ_MEDIA_VIDEO },MEDIA_READ_REQUEST_CODE); }else{ ActivityCompat.requestPermissions( activity,new String[]{ READ_EXTERNAL_STORAGE },MEDIA_READ_REQUEST_CODE); } Android 13除了对媒体文件访问权限进行之外，还为用户提供了一种全新的媒体文件选择器，让其无需向应用授予对整个媒体库的访问权限，也解决了以往的版本不支持多选的问题。 if (Build.VERSION.SDK_INT &gt;= Build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cc5592f8290c556d6b4a087aed94f6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/981c9acffcd0d694a890f2712f471e15/" rel="bookmark">
			客户端证书身份验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
本教学文章将指导您如何通过Nginx配置启用客户端证书身份验证。客户端证书身份验证是一种安全机制，要求客户端提供有效的证书以验证其身份，只有通过验证的客户端才能访问服务器资源。
前提条件
在开始本教程之前，确保您满足以下前提条件：
已经安装并配置好Nginx。
已经生成客户端证书和私钥。
步骤
下面是通过Nginx配置启用客户端证书身份验证的步骤：
步骤1：准备客户端证书和私钥
首先，您需要准备客户端证书和私钥。这些证书和私钥通常由受信任的证书颁发机构（CA）签发。确保您已经生成了客户端证书和私钥文件，并将其放置在安全的位置。
步骤2：配置Nginx
打开Nginx的配置文件，通常是位于/etc/nginx/nginx.conf或/etc/nginx/conf.d/default.conf。
在要应用客户端证书身份验证的服务器块（server块）或特定的location块中，添加以下配置示例：
server { listen 443 ssl; server_name your_domain.com; ssl_certificate /path/to/server.crt; ssl_certificate_key /path/to/server.key; ssl_client_certificate /path/to/client.crt; ssl_verify_client on; # 其他配置... } 在上述配置中，我们使用ssl_certificate指令和ssl_certificate_key指令指定服务器的证书和私钥文件的路径。使用ssl_client_certificate指令指定客户端证书的路径。
通过设置ssl_verify_client on;启用客户端证书身份验证。
确保将your_domain.com替换为您的域名，将文件路径替换为实际的证书和私钥文件路径。
步骤3：重启Nginx服务
在完成配置更改后，保存并关闭Nginx配置文件。然后，执行以下命令重启Nginx服务，以使配置生效：
sudo systemctl restart nginx 请根据您的操作系统和Nginx安装方式选择适当的命令。
验证
完成配置后，Nginx将要求客户端提供有效的证书以验证其身份。客户端需要将证书提供给服务器才能访问受保护的资源。您可以使用具有有效证书的客户端尝试访问服务器资源，验证是否成功通过身份验证。
结论
在本教程中，我们学习了如何通过Nginx配置启用客户端证书身份验证。通过按照上述步骤配置Nginx，并准备和使用有效的客户端证书和私钥，您可以增强服务器的安全性，只允许通过验证的客户端访问服务器资源。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef1e4324046d7205aa31d8492977f1c2/" rel="bookmark">
			如何用Java实现KMP字符串匹配算法？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KMP算法是一种高效的字符串匹配算法，用于在一个主串中查找一个模式串的出现位置。它通过利用已经匹配过的字符信息，避免不必要的回溯操作，提高了匹配的效率。
KMP算法的核心思想是构建一个最大公共前后缀表（也称为部分匹配表），根据该表在匹配过程中确定模式串向后移动的位置。下面将详细介绍KMP算法的实现步骤和Java代码。
一、构建最大公共前后缀表
最大公共前后缀表是一个长度与模式串相等的数组，用于存储每个位置对应的最大公共前后缀长度。具体的构建方法如下：
1、初始化最大公共前后缀表为一个与模式串长度相同的数组，默认值都为0。
2、从第二个位置开始遍历模式串，依次计算每个位置对应的最大公共前后缀长度。
1）、假设当前位置为i，已知前i-1个位置的最大公共前后缀长度为prefixLen[i-1]。
2）、如果模式串的第prefixLen[i-1]个字符与模式串的第i个字符相等，则最大公共前后缀长度为prefixLen[i-1]+1。
3）、否则，继续往前查找长度为prefixLen[i-1]的最大公共前后缀，直到找到相等的字符或长度为0。
4）、更新prefixLen[i]为找到的最大公共前后缀的长度。
以下是使用Java代码实现构建最大公共前后缀表的函数：
private int[] buildPrefixTable(String pattern) { int[] prefixLen = new int[pattern.length()]; prefixLen[0] = 0; int len = 0; int i = 1; while (i &lt; pattern.length()) { if (pattern.charAt(i) == pattern.charAt(len)) { len++; prefixLen[i] = len; i++; } else { if (len != 0) { len = prefixLen[len - 1]; } else { prefixLen[i] = 0; i++; } } } return prefixLen; } 二、KMP算法的匹配过程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef1e4324046d7205aa31d8492977f1c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef40169a173e0a8f29dfbab90db5f5a9/" rel="bookmark">
			linux下查看cpu个数，核数，线程数, GPU，内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 有时我们也许想知道一个服务器上的性能如何。慢慢补充…
cpu 查看cpu个数 cat /proc/cpuinfo | grep "physical id" | sort | uniq | wc -l 查看cpu核数 cat /proc/cpuinfo | grep "core id" | sort | uniq | wc -l 查看cpu线程数 cat /proc/cpuinfo | grep "processor" | sort | uniq | wc -l GPU 会显示出型号，显存，利用率等。如果没有独显，没装驱动可能会显示找不到命令。
nvidia-smi nvidia-smi -L 一秒刷新实时显示
watch -n 1 nvidia-smi 查看cuda版本 nvcc --version python中 -V 经常等价于 --version
查看cudnn版本 cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2 但是如果不安装在该目录该命令就…没有用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef40169a173e0a8f29dfbab90db5f5a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41a2e14c2586842fe6541a4f4e062849/" rel="bookmark">
			基于springboot的学生考勤管理系统的，考勤请假管理系统，附源码&#43;数据库&#43;论文&#43;PPT，适合课程设计、毕业设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、项目介绍
随着信息技术和网络技术的飞速发展，人类已进入全新信息化时代，传统管理技术已无法高效，便捷地管理信息。为了迎合时代需求，优化管理效率，各种各样的管理系统应运而生，各行各业相继进入信息管理时代，学生考勤管理系统就是信息时代变革中的产物之一。
任何系统都要遵循系统设计的基本流程，本系统也不例外，同样需要经过市场进行调研，论文需求进行分析，概要设计，系统详细设计，测试和编码等步骤，设计并实现了学生考勤管理系统。系统选用B/S模式，应用java技术，MySQL为后台数据库。系统主要包括首页，个人中心，学生管理，教师管理，班级信息管理，课程信息管理，签到信息管理，考勤信息管理，请假信息管理，考勤统计管理等功能模块。
本文首先介绍了学生考勤管理的技术发展背景与发展现状，然后遵循软件常规开发流程，首先针对系统选取适用的语言和开发平台，根据需求分析制定模块并设计数据库结构，再根据系统总体功能模块的设计绘制系统的功能模块图，流程图以及E/R图。然后，设计框架并根据设计的框架编写代码以实现系统的各个功能模块。最后，对初步完成的系统进行测试，对功能、单元和性能进行测试。测试结果表明，该系统能够实现所需的功能，运行状况尚可并无明显缺点。
通过市场调研及咨询研究，了解了学生考勤管理系统及管理者的使用需求，于是制定了管理员，教师和学生等模块。功能结构图如下所示：
2、技术框架
运行系统：windows
编程语言：java
系统架构：B/S
后端框框：SpringBoot+Mybatis
前端框架：Vue+html+js+css
前后端分离：否
数据库：MySQL
Maven项目：是
数据库表数量：11
运行环境：JDK8+MySQL5.6+Maven3.6+idea+Node.js 14.16
3、演示视频
基于springboot的学生考勤管理系统的，考勤请假管理系统，附源码+数据库+论文+PPT，适合课程设计、毕业设计
B站演示视频地址：基于springboot的学生考勤管理系统的，考勤请假管理系统，附源码+数据库+论文+PPT，适合课程设计、毕业设计_哔哩哔哩_bilibili
4、项目截图
4.1、登录
4.2、学生-首页
4.3、学生-班级信息
4.4、学生-课程信息管理
4.5、学生-签到信息管理
4.6、学生-考勤信息管理
4.7、学生-请假信息管理
4.8、学生-考勤统计管理
4.9、教师-首页
4.10、教师-学生管理
4.11、教师-课程信息管理
4.12、教师-考勤统计管理
4.13、管理员-首页
4.14、管理员-教师管理
4.15、管理员-班级信息管理
4.16、管理员-考勤信息
5、文档截图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f690c33bef0047967d9db3fbed353b3/" rel="bookmark">
			U-Boot移植 (2)- LCD 驱动修改和网络驱动修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. LCD 驱动修改1.1 修改c文件配置1.2 修改h文件配置1.3 编译测试 2. 网络驱动修改2.1 I.MX6U-ALPHA 开发板网络简介2.2 网络 PHY 地址修改2.3 删除 uboot 中 74LV595 的驱动代码2.4 添加开发板网络复位引脚驱动2.5 更新 PHY 的连接状态和速度2.6 烧写调试2.7 测试一下 ENET12.8 其他需要修改的地方 链接: C/C++Linux服务器开发/后台架构师【零声教育】-学习视频教程-腾讯课堂 1. LCD 驱动修改 一般 uboot 中修改驱动基本都是在 xxx.h 和 xxx.c 这两个文件中进行的， xxx 为板子名称，即board/freescale/mx6ull_myboard/mx6ull_myboard.c和 include/configs/mx6ull_myboard.h这两个文件。
一般修改 LCD 驱动重点注意以下几点：
LCD 所使用的 GPIO，查看 uboot 中 LCD 的 IO 配置是否正确LCD 背光引脚 GPIO 的配置LCD 配置参数是否正确 正点原子的 I.MX6U-ALPHA 开发板 LCD 原理图和 NXP 官方 I.MX6ULL 开发板一致，也就是 LCD 的 IO 和背光 IO 都一样的，所以 IO 部分就不用修改了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f690c33bef0047967d9db3fbed353b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/516db27ecabea654aa022bd408f31213/" rel="bookmark">
			U-Boot移植 (1)- uboot添加自己的开发板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 uboot添加自己的开发板1. uboot源码结构分析2. 编译和烧写 NXP 官方开发板对应的 uboot2.1 编译NXP官方开发板对应的 uboot2.2 烧写验证与驱动测试1. SD 卡和 EMMC 驱动检查2. LCD 驱动检查3. 网络驱动4. u-boot需要修改的地方 3. 添加开发板默认配置文件4. 添加开发板对应的头文件5. 添加开发板对应的板级文件夹5.1 修改Makefile文件5.2 修改imximage.cfg文件5.3 修改Kconfig文件5.4 修改MAINTAINERS文件 6. 修改U-Boot图形界面配置文件7. 创建编译脚本 链接: C/C++Linux服务器开发/后台架构师【零声教育】-学习视频教程-腾讯课堂 uboot添加自己的开发板 NXP原厂的uboot，直接烧录到我的开发板中，LCD的驱动是不正常的，需要进行修改。「使得uboot能匹配我们自己的开发板」。
修改uboot以匹配开发板的方式有两种，一种是在NXP原厂开发板 「i.MX 6ULL EVK」 的文件上进行修改，另一种仿造NXP的开发板文件，添加自己的开发板文件。为了能更多的了解uboot，使用代码改动较大的第二种方式进行uboot的移植。
在修改uboot之前，先来看一下uboot的源码结构。
1. uboot源码结构分析 uboot的源码如下，这里是源码编译后的结果，包含编译后的文件。
这里文件的含义如下：
u-boot：编译出来的 ELF 格式的 uboot 镜像文件。 u-boot.bin：编译出来的二进制格式的 uboot 可执行镜像文件。 u-boot.cfg： uboot 的另外一种配置文件。 u-boot.imx： u-boot.bin 添加头部信息以后的文件， NXP 的 CPU 专用文件。 u-boot.lds：链接脚本。 u-boot.map： uboot 映射文件，通过查看此文件可以知道某个函数被链接到了哪个地址上。 u-boot.srec： S-Record 格式的镜像文件。 u-boot.sym： uboot 符号文件。 u-boot-nodtb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/516db27ecabea654aa022bd408f31213/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e4c425b239859a3c5114126a4b387b2/" rel="bookmark">
			数字图像处理【10】OpenCV-直方图反向投影与模板匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇简单描述直方图在图像处理中典型的应用场景，属于是比较老旧的应用技术，但不妨拿出来再学习，温故而知新，为新知识做一个铺垫。
直方图反向投影（Back Projection） 还记得之前学习过的图像直方图的计算/均衡化的知识吗，反向投影是在这基础上展开，需要回顾的同学可以看看这里的文章。
首先说说直方图反向投影的概念：
反向投影就是利用源图像的直方图模型中的分布情况/概率值，在源目标图像位置进行一个投影，通常用HSV色彩空间的H通道的直方图模型进行投影。 Note：注意这里是用HSV色彩空间，与之前介绍的HSI颜色模型有点区别。这里简单概括一下：其实它两本质是同一套理论。为什么一个叫色彩空间，一个颜色模型，最本质的区别是V和I不同，V指的是value，V=max(R,G,B)，HSV只有下半个圆锥，中轴线是灰度，HSV中纯白的那一点的位置对应在HSI中是中轴中值灰度的位置。如果说HSV的饱和度是对纯白而言的，则HSI的饱和度是对纯中值灰度而言的。由于两种模型中的I和V的不同导致了H和S的不同。在HSV色彩空间里，H的取值范围是[0~180]，S和V是[0~255]【PS：Windows电脑自带的画图软件中的调色板是HSI模型的】
为了加深理解，举个应用例子，给大家说明白什么是直方图反向投影：
(1) 例如一4x4图像的灰度如下 ：
Image= 0 1 2 3
4 5 6 7
8 9 10 11
8 9 14 15
(2) 定义该直方图的灰度区间为[0,3)，[4,7)，[8,11)，[12,16)
则其直方图：Histogram = 4 4 6 2
归一化后为：Histogram = 0.25 0.25 0.375 0.125
(3) 直方图反向投影后，位置(0,0)上的像素值为0，对应的bin为[0,3)，所以反向直方图在该位置上的值这个bin的值4。
Image_BackProjection=
4 4 4 4
4 4 4 4
6 6 6 6
6 6 2 2
我们看到，实际上是原图像的256个灰度值被置为很少的几个值了，具体有几个值，那要看把0~255的灰度等级划分为多少个区间（HSV空间的H，那就是将0~180划分区间）在反向投影的特征矩阵中，具体位置的值就是它对应的原图像中的点所在区间的灰度直方图值。所以我们可以看出，一个区间点越多，在反向投影矩阵中就越亮。
从这个过程也可以看出，我们是先求出原图像的直方图，再由直方图得到反向投影得出特征矩阵，由直方图到投影矩阵实际上就是一个反向的过程，所以叫反向投影。
直方图反向投影-opencv-4.5.5 C工程实现
#include &lt;opencv2/opencv.hpp&gt; #include &lt;iostream&gt; using namespace cv; using namespace std; void Hist_And_BackProjection(int, void*); Mat src, hsv, hue; string titleStr = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e4c425b239859a3c5114126a4b387b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17648462ad0cc7197cdec4e2d9d80db7/" rel="bookmark">
			Zotero使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zotero使用 1、安装2、常见的插件2.1、强烈推荐的插件2.2、可选插件 3、使用OneDrive同步Zetero信息参考资料 随便记录一下。
1、安装 之前使用Zotero来进行文献管理，用知网研学来进行文献阅读、做笔记啥的，发现要同时使用两个软件，觉得有点麻烦，就想着仅仅使用Zotero来进行阅读和管理，减少多软件的麻烦，直接一步到位。
也不是很熟悉，就随便记录一下吧。
在官网下载Zotero安装包，安装即可。
为了方便使用，需要配合浏览器插件Zotero Connector使用，即在浏览器上也装上Zotero插件，用来添加文献、附件之类的。
2、常见的插件 2.1、强烈推荐的插件 Jasminum 中文文献强烈推荐这款插件，它具有下面的强大功能：
拆分或合并 Zotero 中条目作者姓和名根据知网上下载的文献文件来抓取引用信息（就是根据文件名）添加中文PDF/CAJ时，自动拉取知网数据，该功能默认关闭。需要到设置中开启，注意添加的文件名需要含有中文，全英文没有效果（还是根据文件名）为知网的学位论文 PDF 添加书签更新中文 translators拉取文献引用次数，是否核心期刊 DOI manager 它能自动帮助你更新文献的DOI信息。
Zotfile 这个插件也是强烈推荐的，如果主力使用Zetero的话，这个插件一定要安装。
这个插件最强大的功能在于它能实现对文献的自动重命名，移动PDF并将其附加到Zotero项目，该插件还可以帮助你从PDF文件中提取注释。
Zotero-better-notes 这个插件可以直接再Zetero中做笔记，支持Markdown等功能，非常强，非常推荐！！如果想要替换知网研学，这个插件必装！！
Zotero Update IFs Zotero Update IFs能够更新英文期刊的JCR分区、中科院分区、影响因子和5年影响因子，对于中文期刊更新是否CSCD收录、北大核心、科技核心、复合影响因子、综合影响因子等，具有一下特点：
1、使用期刊名称从唯问(http://sci.justscience.cn/)更新期刊英文期刊的JCR分区、中科院分区、影响因子和5年影响因子，对于中文期刊更新是否CSCD收录、北大核心、科技核心、复合影响因子、综合影响因子。插件主体来源于Zotero Scholar Citations(https://github.com/beloglazov/zotero-scholar-citations)，获取核心期刊信息部分代码来源于茉莉花（https://github.com/l0o0/jasminum/），在此表示感谢。插件安装后在分类及条目上右击会出现从唯问更新期刊信息，点击即可从唯问(http://sci.justscience.cn/)获取JCR分区、中科院分区、影响因子和5年影响因子及中文期刊更新是否南南农大核心期刊、南农大高质量期刊（仅含食品科学与工程）、CSCD收录、北大/南大核心、科技核心、复合影响因子、综合影响因子，并分别写入到档案、存档位置、馆藏目录、索书号、版权字段（可进行设置是否显示和存贮位置），如果没有获取到数据，请核实该期刊有无被SCI索引或直接访问唯问(http://sci.justscience.cn/)查看。
2、使用期刊名称从唯问(http://sci.justscience.cn/)更新期刊英文期刊的缩写，写入到刊名缩写 （需要在工具-更新期刊信息设置…中进行相关选项设置）。
3、清除其它字段内容（工具-清除其它内容…）。
4、给作者加粗、加星、清除加粗、清除加星；将文献题目改为首字母大写；更改期刊题目；更改期刊题目大小写；作者姓名改为词首字母大写；交换作者姓和名；显示配置目录，显示数据目录等小工具（工具-工具箱）。
2.2、可选插件 Zotero Scihub 这款插件主要是调用Sci-hub网站，进行文献自动下载。如果你觉得插件配置的原始网址不够给力，我们也是可以点击“编辑-首选项”，将自己常用的Sci-hub网站放进去，实现自动下载。
Markdown Here 该插件帮助你在做笔记的时候，可以轻松运用Markdown语言，同时可以帮助你直接将文献笔记导出到其他环境中。
3、使用OneDrive同步Zetero信息 参考：Zotero使用Onedrive实现云同步
要点：
把原来的账号同步功能关掉设置附件根目录、数据存储目录，这个需要设置到OneDrive的同步文件中，这样多个PC端都能够同步过来 参考资料 1、Zotero常用插件一锅端
2、Zotero使用Onedrive实现云同步
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d275f0f0a93836e648b6703dfea949b/" rel="bookmark">
			Stable Diffusion&#43;ControlNet&#43;Lora 指导AI&#43;艺术设计的WebUI全流程使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. 背景知识1.1 Stable Diffusion背景知识1.1.1 安装stable-diffusion-webui 1.2 ControlNet 背景知识 二. 使用方法2.1 环境配置2.2 运行WebUI 三. 背景知识3.1 Stable Diffusion参数详解3.2 ControlNet 参数详解 四. 定制化技巧4.1 参数技巧 五. 参考来源 设计师们往往对于新出的绘画工具上手比较艰难，本文针对目前比较火热的Stable Diffusion+ControlNet指导AI艺术设计的工具使用进行全面讲解。很多人会有预感，未来要么设计师被图形学程序员取代，要么会使用AI工具的设计师取代传统设计师，2023年开始，AI辅助设计甚至主导设计已经成了司空见惯的现象。 软硬件环境：
OS: Ubuntu 20.04(Stable Diffusion开发需要Linux 环境，纯使用Web工具也可在WIndows下运行)
CPU: AMD5800 8core 16Thread
GPU: NVIDIA RTX 3090 * 2
RAM: 16GB * 4
Pytorch-gpu=1.13
CUDA=11.7
一. 背景知识 1.1 Stable Diffusion背景知识 1.1.1 安装stable-diffusion-webui 由于笔者的系统为Linux ,因此需要按照官网(https://github.com/AUTOMATIC1111/stable-diffusion-webui)的操作进行以下配置：
# Debian-based: sudo apt install wget git python3 python3-venv bash &lt;(wget -qO- https://raw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d275f0f0a93836e648b6703dfea949b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df600193f8a4d04f5800b6768121d40e/" rel="bookmark">
			基于微信小程序的科创微应用平台小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末联系获取源码
开发语言：Java
框架：ssm
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql 5.7/8.0
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.3.9
浏览器：谷歌浏览器
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
一、前言介绍 随着信息技术在管理上越来越深入而广泛的应用，管理信息系统的实施在技术上已逐步成熟。本文介绍了基于微信小程序的科创微应用平台的开发全过程。通过分析基于微信小程序的科创微应用平台管理的不足，创建了一个计算机管理基于微信小程序的科创微应用平台的方案。文章介绍了基于微信小程序的科创微应用平台的系统分析部分，包括可行性分析等，系统设计部分主要介绍了系统功能设计和数据库设计。
本基于微信小程序的科创微应用平台管理员功能有个人中心，用户管理，企业管理，场地信息管理，场地类型管理，预约参观管理，场地预约管理，活动信息管理，报名信息管理，我的收藏管理，试题管理，试卷管理，系统管理，考试管理。用户和企业可以注册登录。企业可以发布信息，用户可以预约信息，可以参加考试等。因而具有一定的实用性。
本基于微信小程序的科创微应用平台，后台采用SSM框架，MYSQL数据库设计开发，微信小程序用微信开发者工具开发，充分保证系统的稳定性。系统具有界面清晰、操作简单，功能齐全的特点，使得基于微信小程序的科创微应用平台管理工作系统化、规范化。本系统的使用使管理人员从繁重的工作中解脱出来，实现无纸化办公，能够有效的提高基于微信小程序的科创微应用平台管理效率。
二、系统结构 本系统是基于B/S架构的网站系统，设计的功能结构图如下图所示：
三、功能截图 小程序模块的实现 首页
活动信息
我的
管理员模块的实现 用户信息管理
企业信息管理
场地信息管理
试题信息管理
四、部分核心代码 小程序端首页主要代码 methods: { jump(url) { if (this.queryIndex == 0) { localStorage.setItem('indexQueryCondition', document.getElementById("dianyingxinxidianyingmingcheng").value); } jump(url) }, queryChange(event) { this.queryIndex = event.target.value; if (this.queryIndex == 0) { this.dianyingxinxidianyingmingcheng = this.queryList[event.target.value].queryName; } } } }); layui.use(['layer', 'form', 'element', 'carousel', 'http', 'jquery'], function() { var layer = layui.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df600193f8a4d04f5800b6768121d40e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a91efa2198db976df4ef87ed9ae53b8/" rel="bookmark">
			存在CSRF漏洞的CMS练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
作者简介：不知名白帽，网络安全学习者。
博客主页：不知名白帽的博客_CSDN博客-网络安全,CTF,内网渗透领域博主
网络安全交流社区：https://bbs.csdn.net/forums/angluoanquan
CMS
链接：https://pan.baidu.com/s/13FWlnJ2o4iQmtPm3EnYOpg 提取码：tiwy 目录
Espcms
安装
使用工具（CSRFTester）进行测试
Metinfo
安装
使用工具进行测试
74cms_v4.1.24
安装
使用BP进行测试
Espcms 安装 安装目录：http://127.0.0.1/espcms/upload/install/index.php
安装成功
使用工具（CSRFTester）进行测试 打开工具
设置代理
开始监听
提交表单
添加一个会员账号
会员添加成功
生成HTML
返回CSRFTester，将用户名test666修改为test777. 然后点击右下角Generate HTML保存到指定目录，会生成一个index.html文件
修改HTML
将form表单里的内容删除
访问修改后的HTML
发现test777被创建成功
返回原网站查看
因此该网站存在CSRF漏洞
Metinfo 安装 安装目录：http://127.0.0.1/Metinfo5.3.1/install/
安装成功
后台登录页面：http://127.0.0.1/Metinfo5.3.1/admin/login/login.php
使用工具进行测试 打开工具CSRFTester并开始代理
先添加一个管理员
生成HTML
将user全部改为test
修改HTML
将form表单中的内容删除
访问修改后的HTML文件
新用户test被创建
查看原网页
登录test用户
此处存在CSRF漏洞
74cms_v4.1.24 安装 安装目录：http://127.0.0.1/74cms_v4.1.24/upload/install.php
安装成功
进入网站后台
使用BP进行测试 添加管理员账户user
使用BP中的CSRF POC构造HTML
生成HTML
修改HTML
将user全部更改为test
访问该HTML
点击submit request
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a91efa2198db976df4ef87ed9ae53b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2983d0c0c6ba17ada058c44af74cd5c9/" rel="bookmark">
			一文说明白各种Excel数据导入导出方式的优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，没有什么是绝对好或绝对不好。
（1/4）导入导出方式
Excel数据导入导出方式，不外乎下面几种：
1、剪贴板
2、OLE
3、DOI
4、ZABAP2XLSX
5、ZXLSX_WORKBENCH
6、STRANS
（2/4）原理
下面介绍一下各种导入导出方式的原理。
1、剪贴板
导入：用户打开Excel -&gt; 自行复制数据 -&gt; 在SAP中读取剪贴板数据
导出：SAP将数据发送到剪贴板 -&gt; 用户打开Excel -&gt; 自行粘贴数据
剪贴板操作的方法为：CL_GUI_FRONTEND_SERVICES类中的CLIPBOARD_EXPORT和CLIPBOARD_IMPORT
2、OLE
导入：创建Excel.Application或ET.Application(WPS)，通过函数ALSM_EXCEL_TO_INTERNAL_TABLE或类似的自己写的OLE代码，导入数据
导出：创建同样的Application，通过OLE代码导出数据
网上有很多OLE相关的代码，这里不再赘述。
要了解更多OLE相关知识，请查看《OLE那些事》。
要了解更多Excel及VBA相关知识，请查看VBA从零学习系列，或点击文章开头的话题标签。
3、DOI
导入：通过TEXT_CONVERT_XLS_TO_SAP或类似的DOI代码，导入数据。
导出：通过DOI代码导出数据。
网上有很多DOI相关的代码，这里也不再赘述。
4、ZABAP2XLSX
Office自2007以后，推出了xlsx、docx、pptx等新的文件格式，这些新的文件格式统称为openxml格式。
我们可以把“工作簿1.xlsx”重命名为“工作簿1.xlsx.zip”，然后尝试解压缩，可以得到若干个xml文件。
作为知名的ABAP与Excel的项目的代表，ZABAP2XLSX就是将数据按照openxml的规则，生成若干xml文件，然后通过CL_ABAP_GZIP进行文件压缩打包，进而得到xlsx文件的。
5、ZXLSX_WORKBENCH
其中提供了包括上述2、3、4三种方式的组合代码的程序，是一个比较强大的工作台。在它的代码中，你可以找到CALL METHOD OF、i_oi_spreadsheet、if_ixml_element等分别代表OLE、DOI、OPENXML代码特征的使用痕迹。
所以，不要迷信ZXLSX_WORKBENCH就一定最好，别的导入导出方式存在的缺点，它一样存在。而且它还存在更多的学习成本、项目交接成本、运维成本等。
6、STRANS
通过Transformation进行XML转换
（3/4）优缺点
说完了各种导入导出方式的原理，下面说一下各种导入导出方式的优缺点。
1、剪贴板
优点：
1) 无视客户端Excel的版本，不管用户装的是Excel 2007还是2019，或是老掉牙的2003，还是奇异的Office 365
缺点：
1）导入数据时，我们可能都遇到过数据串行的问题。这是因为单元格中的内容出现了“回车+换行”的字符。正常情况下，我们在Excel单元格中输入ALT+回车换行输入，Excel中的字符是换行字符。但某些第三方软件，比如某友某蝶等，在导出Excel文件时，可能会在单元格写入“回车+换行”的字符实现单元格内容的换行。这样的文件在通过SAP剪贴板导入系统时，就会导致数据串行。
2）无法满足用户多Sheet页读取、多Sheet页导出的需求。
3）用户体验不好，除非项目团队比较强势，否则用户一般不会买单。
4）导出数据时，如果数据发送到剪贴板时，其中某些字段以双引号开头，会导致导出的数据出现数据错乱的情况，需要在发送剪贴板前对数据做特殊处理。
5）工作表列数较多，总长度超出4096时无法导入、导出。因为SAP的剪贴板支持的最大长度为4096。
缺点4截图如下图：
2、OLE
优点：
1）功能强大，支持几乎所有VBA的命令，进而可以支持几乎Excel所有的功能，比如公式、图表、筛选、条件格式、打印缩放、保护工作表、另存为PDF等等等等
2）可以处理剪贴板导入时无法处理的“回车+换行”的问题。即在文件打开后，执行一下OLE命令，将“回车+换行”字符替换为“换行”字符
3）导出大量数据时，通过粘贴的方式处理，非常快。【不要上来就质疑OLE慢，可以先想象一下我们复制几万行数据从一个Sheet到另外一个Sheet的时候快不快！导出大量数据时，只是SAP将数据发送到剪贴板稍微有点慢。】
4）具备一定VBA基础时，使用非常方便
5）支持按R1C1的形式写单元格公式（具体请百度Excel R1C1），这个很强大
6）相较于ZABAP2XLSX，可以得到公式单元格的计算结果，而不是得到其公式
缺点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2983d0c0c6ba17ada058c44af74cd5c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91318d3a8003522c460e0be9aae69b4e/" rel="bookmark">
			DNS解析过程：从域名到IP地址的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言一、什么是DNS解析？二、DNS解析的过程1.用户输入域名2.查询浏览器缓存3.查询本地Host文件4. 发起DNS查询5.本地DNS服务器迭代查询过程6.根 DNS 服务器查询7.顶级域名服务器查询8.权威域名服务器查询9.本地DNS服务器响应10.操作系统响应 总结 引言 在今天的互联网世界中，我们使用域名来访问各种网站和网络资源，例如"www.example.com"。然而，计算机网络之间的通信实际上是通过IP地址进行的。那么，是什么使我们能够通过域名访问特定的IP地址呢？这就是DNS解析发挥作用的地方。
一、什么是DNS解析？ DNS解析是将域名（例如example.com）转换为对应的IP地址（例如192.0.2.1）的过程。在互联网上，计算机和其他设备使用IP地址来相互通信和定位。然而，IP地址是一串数字，不太容易记忆和使用。为了解决这个问题，DNS（Domain Name System）系统被引入。
此外，DNS解析还具有缓存机制，可以提高访问速度和网络效率。了解DNS解析的过程有助于我们理解互联网的工作原理，并能够解决一些与域名解析相关的常见问题。
二、DNS解析的过程 注：图片来源于小红书@王咔咔
1.用户输入域名 用户在浏览器或其他应用程序中输入域名，例如"example.com"。
2.查询浏览器缓存 首先浏览器会检查之前有没有缓存过此域名对应的IP地址，若有则直接跳过DNS解析过程。
3.查询本地Host文件 若在浏览器中未找到此域名对应的IP地址，操作系统会检查本地计算机的Host文件，若其中保存或者设置了此域名对应的IP地址，解析过程就结束了，操作系统将直接返回缓存中的IP地址。
4. 发起DNS查询 如果在本地Host文件中未找到对应的记录，操作系统会向本地DNS服务器发送查询请求。这些DNS服务器通常由用户的网络服务提供商（ISP）或其他网络设置指定（如中国移动或者电信、联通等）。
5.本地DNS服务器迭代查询过程 本地DNS服务器接收到查询请求后，会检查自己的缓存。如果在缓存中找到了对应的记录，服务器会直接返回IP地址。否则，本地DNS服务器将扮演迭代器的角色，向其他DNS服务器发送查询请求。
6.根 DNS 服务器查询 本地 DNS 服务器向根 DNS 服务器发送查询请求，请求根 DNS 服务器提供负责目标域名顶级域（例如.com、.org、.net 等）的权威 DNS 服务器的地址。
7.顶级域名服务器查询 本地DNS服务器向顶级域名服务器发送查询请求，请求该域名的权威DNS服务器的地址。
8.权威域名服务器查询 顶级域名服务器返回给本地DNS服务器一个或多个权威域名服务器的地址。本地DNS服务器随即向权威域名服务器发送查询请求。
权威域名服务器查询在自己的数据库中查找与该域名相关的记录，例如A记录（将域名映射到IPv4地址）、AAAA记录（将域名映射到IPv6地址）等。如果找到了记录，权威域名服务器将其返回给本地DNS服务器。
9.本地DNS服务器响应 本地DNS服务器收到来自权威域名服务器的响应后，将IP地址存储在自己的缓存中，并将结果返回给操作系统。
10.操作系统响应 操作系统接收到IP地址后，将其传递给发起查询的应用程序，例如浏览器。浏览器利用该IP地址与目标服务器建立连接，并开始相应的网络通信。
总结 本文详细介绍了DNS解析的过程，从用户输入域名到最终获取IP地址的步骤。DNS解析是将域名转换为IP地址的关键过程。通过理解DNS解析的工作原理，我们可以更好地理解互联网的运作方式，并解决与域名解析相关的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abb98812c7e58c55f0126af2ac739d82/" rel="bookmark">
			射频学习（DAY1)时域和频域、数字预失真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信号可以从时域和频域两个方面进行分析。
时域是指信号随时间的变化情况。在时域分析中，我们观察和记录信号随时间的变化，包括信号的振幅、波形、周期性等。时域分析的常见方法包括时域图、波形图和功率谱密度图。时域分析可以提供关于信号的时间特性和动态行为的信息。
频域是指信号在频率上的特性。在频域分析中，我们将信号转换为频率域表示，以便观察信号中包含的不同频率分量和频率特性。频域分析的常见方法包括傅里叶变换、频谱图和频率响应。频域分析可以揭示信号的频率成分、频率分布以及频率间的相互关系。
时域和频域分析是互补的。通过时域分析，我们可以观察到信号的时间变化和振幅特性；而通过频域分析，我们可以了解信号的频率成分和谱特性。综合时域和频域分析可以更全面地理解信号的特性，从而在不同应用领域中进行信号处理、滤波、调制和解调等操作
在时域和频域之间进行转换的傅里叶变换是一个线性变换，它将信号从一个域转换到另一个域，并保持信号的信息不变。
从时域到频域的傅里叶变换可以通过连续傅里叶变换（CTFT）或离散傅里叶变换（DFT）来实现。CTFT适用于连续时间信号，而DFT适用于离散时间信号。通过傅里叶变换，我们可以将时域信号分解为一系列复指数函数或正弦波，每个函数代表一个特定频率的成分。这些复指数函数或正弦波的振幅和相位表示了信号在频域上的特性。
从频域到时域的傅里叶逆变换（Inverse Fourier Transform）可以将频域信号转换回时域信号。逆傅里叶变换是傅里叶变换的逆运算，它将频率成分重新组合成原始的时域信号。逆傅里叶变换的结果是一个连续时间信号（对于CTFT）或离散时间信号（对于DFT），与原始信号在时域上一致。
通过在时域和频域之间进行转换，我们可以更详细地分析信号的特征。时域分析可以揭示信号的波形、振幅和变化的时间关系，而频域分析可以揭示信号的频率分布、频率成分的强度和相位信息。这些分析可以用于不同领域中的信号处理、滤波、噪声去除、信号压缩等应用。
需要注意的是，在进行傅里叶变换时，某些信号的时域和频域表示可能存在一定的限制和假设。例如，对于非周期信号，通常会使用傅里叶变换的变种，如快速傅里叶变换（FFT），以处理离散非周期信号的频域表示。此外，傅里叶变换还有许多扩展和变种，如短时傅里叶变换（STFT）、小波变换等，用于处理更复杂的信号和特定应用场景。
在实际应用中，时域和频域分析各有其优势和用途。
时域分析对于观察和理解信号的时间特性非常有用。它可以揭示信号的波形、振幅、周期性、脉冲宽度等特征。通过时域分析，我们可以观察信号的时序行为，如信号的起始时间、持续时间、间隔等。时域分析通常使用波形图、时序图或时间序列来表示信号，使我们可以直观地观察到信号的变化和动态特性。
频域分析则更关注信号的频率特性和频率分量。它可以揭示信号中的各个频率成分的强度、相位关系以及它们之间的频率间隔。频域分析可以帮助我们分析信号的频率分布、频率响应、频带宽度等特征。通过频域分析，我们可以检测和分析信号中的频率成分，例如主频、谐波、干扰等。频域分析通常使用频谱图、频谱密度图或功率谱图来表示信号的频率特性。
时域和频域分析可以相互补充，提供全面的信号分析和理解。时域分析用于检测和描述信号的动态行为，而频域分析用于揭示信号中的频率特性。通过结合时域和频域分析，我们可以深入了解信号的性质，并选择合适的处理方法和技术来处理信号，如滤波、频率选择、调制和解调等。
当我们处理信号时，时域和频域分析可以帮助我们解决不同类型的问题。
在时域分析中，我们可以观察信号的变化趋势、振幅、周期性、时域特性等。时域分析适用于以下情况：
观察信号的波形特征：通过时域分析，我们可以直接观察信号的波形，了解信号在不同时间点的变化情况。这对于某些特殊波形（如脉冲信号、方波信号）以及峰值和持续时间等信息的获取非常有用。
研究信号的动态行为：时域分析可以帮助我们观察信号随时间的变化，如信号的起始时间、结束时间、变化速率等。这对于动态信号或随时间变化的系统的分析非常重要。
检测信号的时间关系：时域分析可以帮助我们确定信号之间的时间关系，如信号的时间延迟、时间差、相对时间顺序等。这在信号处理、通信系统等领域中非常关键。
而在频域分析中，我们关注信号的频率特性，包括频率分量、频谱分布、频率间的相互关系等。频域分析适用于以下情况：
分解信号的频率成分：频域分析可以将信号分解为不同频率的成分，并以频谱图或频谱密度图的形式呈现。这使得我们可以观察到信号中各个频率的贡献和特征。例如，在音频处理中，频域分析可以将声音分解为不同音调和频率的成分。
检测频率成分的强度和相位：频域分析可以帮助我们了解信号中各个频率成分的强度和相位信息。这对于频率选择、滤波和信号调制非常重要。
研究信号与系统的频率响应：频域分析可以帮助我们了解信号如何与特定系统或滤波器相互作用。通过观察信号在不同频率上的响应，我们可以确定信号的频带宽度、增益、衰减等特性。
数字预失真
数字预失真（Digital Predistortion，DPD）是一种用于抵消非线性系统失真的数字信号处理技术。在许多无线通信系统和射频（RF）传输链中，信号经过功放（Power Amplifier，PA）时会发生非线性失真，导致输出信号的畸变和功率效率的下降。数字预失真通过预先对输入信号进行逆向失真处理，可以在功放输出上实现更线性的响应，从而减少失真并提高传输质量。
数字预失真的基本原理是通过传递使用先前测量到的失真信息的修正信号，对输入信号进行调整。通常，在进行数字预失真前，使用测试信号驱动功放并测量其输出的非线性失真特性。这些测量结果用于建立模型或查找表，以描述功放的非线性特性。然后，输入信号通过该模型或查找表进行预失真调整，以抵消功放引起的非线性失真。最终，修正后的信号用于驱动功放，以实现更准确的线性输出。
数字预失真技术需要高性能的数字信号处理器（DSP）和快速算法来实时计算修正信号。它在无线通信系统中广泛应用，特别是在高功率无线电通信系统（如LTE，5G等）中。数字预失真能够有效改善功放的线性度和功率效率，从而提高系统的性能和容量。
使用数字预失真的优点包括：
减少功放引起的非线性失真：通过预先补偿功放的非线性特性，可以显著减少输出信号中的畸变，提高信号的质量和准确性。
提高功放的功率效率：功放在非线性区域工作时往往效率较低。通过数字预失真，可以使功放在更线性的工作区域内运行，提高功率效率，减少功放的能量消耗。
节省系统成本：通过数字预失真技术，可以使用更小功率、更低成本的功放来实现所需的输出功率要求，从而降低系统成本。
降低对频谱带宽的要求：非线性失真会引入额外的频谱扩展，使信号占用更大的带宽。通过数字预失真，可以减少失真导致的频谱扩展，提高频谱效率。
它基于以下原理：
提前检测：预先测量功放的非线性特性，通常使用测试信号来驱动功放并测量输出的非线性失真。
建立模型：利用测量结果，建立功放的非线性特性模型。这可以使用多项式函数、神经网络等数学模型表示。
修正信号：通过将输入信号与建立的功放模型相反地作用于信号进行修正，产生预失真信号。
功放驱动：修正后的信号用于驱动功放，使功放输出更准确的线性放大，并抵消实际输入信号的非线性失真。
实际应用方面，数字预失真已经被广泛应用于无线通信领域和射频系统中。它可以用于各种无线通信标准，如LTE、5G、Wi-Fi等，以提高信号质量、扩大覆盖范围和提高网络容量。数字预失真还被用于射频前端系统中的功放、混频器和滤波器，以补偿非线性特性，减少系统失真和提高性能。
然而，数字预失真在实施过程中也面临一些挑战和限制：
功放模型的建立：准确建立功放的非线性模型是数字预失真的关键。这需要精确的非线性特性测量，尤其是在动态工作条件下。此外，功放的非线性特性可能随时间、温度和频率变化，需要考虑时变性。
模型复杂性和计算复杂性：高度精确的功放模型往往会带来复杂的数学形式和大量的参数。计算这些模型和修正信号的复杂性可能需要高性能的硬件平台和有效的算法实现。
自适应性与稳定性：功放的非线性特性可能会发生变化，因此数字预失真系统需要具备自适应能力，能够实时地对功放的非线性特性进行估计和调整，以保持失真抵消的有效性和稳定性。
可扩展性和兼容性：数字预失真系统需要能与不同类型的功放和系统架构兼容，并能够适应不同的通信标准和频段。这要求适应性强、可配置性高的设计和实现。
近年来，一些进一步的发展已经取得，以克服数字预失真的挑战并进一步提升性能：
深度学习和机器学习：利用机器学习和神经网络等深度学习技术，可以实现更准确的功放模型，提高预失真性能，并减少对先前测量的依赖。
宽带预失真：传统的数字预失真通常针对单一频点或窄带信号进行优化。然而，宽带预失真技术能够同时考虑更宽的频率范围和多个信号频点，以适应更复杂的通信系统和信号情况。
多输入多输出（MIMO）预失真：MIMO系统中存在多个功放和信号路径，对于这种情况，MIMO预失真技术可以更好地抵消非线性失真并提高系统性能。
低功耗和低成本实现：针对功耗和成本敏感的应用，研究人员正在尝试开发低功耗、高效率的数字预失真实现方案，以提高可行性和经济性。
综上所述，数字预失真是一种用于克服功放引起的非线性失真的有效技术。尽管它具有一些挑战和限制，但随着技术的进步和创新，数字预失真的性能和应用范围正在不断扩展。它在无线通信和射频系统中的应用有助于提高信号质量、增加系统容量以及降低能源消耗，对于实现高性能和可靠的通信系统至关重要
Q&amp;A：
信号在频域里面是怎么表示的？
信号在频域中是通过频谱表示的。频谱表示了信号在不同频率上的能量或振幅分布情况。频谱表示常常使用傅里叶变换（Fourier Transform）来获得。
傅里叶变换是一种将信号在时域中的波形转换为频域中的频谱的数学变换。它将信号分解为一系列不同频率的正弦和余弦函数（也称为正弦和余弦分量），每个分量具有不同的振幅和相位。傅里叶变换以复数形式表示频域信号，其中幅度表示信号在不同频率上的能量或振幅，相位表示不同频率分量之间的相对相位差。
傅里叶变换有两种形式：连续傅里叶变换（Continuous Fourier Transform，CFT）和离散傅里叶变换（Discrete Fourier Transform，DFT）。
连续傅里叶变换（CFT）：用于连续时间信号频谱的表示。它将信号从时域转换为连续频域上的频谱。
离散傅里叶变换（DFT）：用于离散时间信号频谱的表示。它将离散时间信号从时域转换为离散频域上的频谱。
对于实际的离散时间信号，通常使用快速傅里叶变换（Fast Fourier Transform，FFT）算法来高效计算离散傅里叶变换。
频域表示提供了一种观察和分析信号频率成分的有效手段。通过频谱表示，我们可以了解信号在不同频率上的分布情况，识别信号中的频率分量、频率峰值和频带信息等，从而有助于理解信号的特征、调制方式以及与其他信号的交互作用。频域分析在许多领域中都有广泛的应用，包括通信、音频处理、图像处理等。
信号带宽指的是什么？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abb98812c7e58c55f0126af2ac739d82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/942f117e064a9389898a2a6ae2090944/" rel="bookmark">
			【网络】HTTPS协议原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
“加密”相关概念
为什么要加密
常见加密方式
对称加密
非对称加密
HTTPS工作过程探究
方案1-只使用对称加密
方案2-只使用非对称加密
方案3-客户端和服务端双方都使用非对称加密
方案4-非对称加密 + 对称加密
上述方案问题分析 方案5-证书认证 + 非对称加密+对称加密
什么是证书
什么是数据摘要
什么是数字签名
证书认证 + 非对称加密+对称加密
常见问题
中间人修改证书怎么办。
中间人将证书整个换掉。
摘要内容在网络传输时为什么要加密形成签名
数字签名为什么不直接加密，而是要先hash形成摘要呢。
总结
http协议内容是按照文本的方式明文传输的，传输的过程中存在被恶意分子获取，修改的风险。这种传输方式，称为明文传输。
https也是用用层的协议，在http协议的基础上引入了加密层，这种传输方式称为密文传输。
“加密”相关概念 加密的本质就是把 要传输的信息 进行一系列的变换，生成密文。解密的过程就是将密文再次经过变换，恢复成 真正要传输的信息。在加密解密的过程中，需要一个或者多个中间数据，辅助加密解密，这样的中间数据叫做 密钥。
例：如下图所示，张三想要向如花表白，但是在信息传输的过程中，害怕被别人看到或者恶意修改，就用key对要传输的数据进行了加密，并且在消息发送前把key也告诉了如花。信息发送后，即便数据在传输的过程中被别人看见，看到了并不是信息的原貌。只有拥有key的如花通过key对数据进行解密，才能等看到张三传输的原始信息。
为什么要加密 在互联网上，明文传输是比较危险的事情。不法分子可以通过一些技术手段来窃取你的隐私信息，甚至篡改内容。如果你在登录支付软件的过程中被“坏人”获取到了账户余额，甚至获取到用户的支付密码，后果不堪设想。下面举个例子：
案例场景：小明 想要下载一个 A 软件，点击下载按钮后，本质上是在给服务器发送一个http请求，服务器发送响应给客户端后，http响应中就包含了 A软件 的下载链接， 因为 在网络传输的任何数据包都要通过运营商的网络设备，这个时候运营商可以劫持这个响应，对数据内容进行篡改，如将A软件的下载链接 修改成 “B软件的下载链接” 。
http的内容是明文传输的，被中间人劫持后，传输的内容完全暴露。中间人可以修改传输的信息，并且不被客户端和服务端察觉。因此我们需要对信息进行加密。
常见加密方式 对称加密 对称加密采用的是单个密钥的加密方法，使用这一个密钥完成对信息进行加密和解密。
特点：算法公开、计算量小、加密速度快、加密效率高。
非对称加密 非对称加密，需要两个密钥进行加密和解密，公钥（对明文加密），私钥（对明文解密），两个密钥反过来使用也是可以的。
特点：算法强度复杂、加密解密速度慢。
HTTPS工作过程探究 方案1-只使用对称加密 问题：服务器需要维护每个客户端和每个密钥之间的关联关系，比较理想的做法就是在客户端和服务器建立连接的时候，双方协商确定好这次密钥是什么。但是在协商密钥的过程中，如果将密钥明文传输，那么中间人（黑客等）也可以获得密钥，这样一来后序的加密传输就形同虚设，毫无意义！
方案2-只使用非对称加密 分析：服务器端有私钥和公钥，服务器先将公钥以明文的方式传递给客户端（中间人也可以拿），此后客户端向服务器传输数据前都用公钥加密，从客户端到服务器的信道好像是安全的（实际上仍不安全，后面讨论），因为只有服务端有解密的私钥。 但是，从服务端到客户端这条路无法保证安全，如果服务器用私钥加密，中间人手中也有公钥，也可以对信息进行解密。
问题总结：公钥传输后，从客户端到服务端的通信信道似乎保证了安全（实际不安全）。但是，从服务端到客户端仍然是不安全的。
方案3-客户端和服务端双方都使用非对称加密 如下图所示：服务端和客户端各有一对密钥。
以上图为例进行描述，服务端的密钥为公钥S和私钥S',客户端的密钥为公钥C和私钥C'。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/942f117e064a9389898a2a6ae2090944/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc7312b6d130c98e4d864c19f241cecf/" rel="bookmark">
			Vue3 与 React 全方面对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 编程风格 &amp; 视图风格 1.1 编程风格 React 语法少、难度大；Vue 语法多，难度小
例如指令：
Vue
&lt;input v-model="username"/&gt; &lt;ul&gt; &lt;li v-for="(item,index) in list" :key="index"&gt;{{ item }}&lt;/li&gt; &lt;/ul&gt; React
&lt;input value={username} onChange={e =&gt; setUsername(e.target.value)}/&gt; &lt;ul&gt; { list.map((item,index) =&gt; &lt;li key={index}&gt;{item}&lt;/li&gt;) } &lt;/ul&gt; Vue 给我们提供了很多的指令功能，而这些功能在 React 中基本都需要我们使用原生 js 来实现。
所以会有很多人说: "使用 Vue 实际上你就是在操作 Vue，使用 React 实际上你是在操作 js"。
React 魔改少，手动实现；Vue 魔改多，自动完成。
例如事件：
Vue
&lt;button @click="handleClick('hello')"&gt;点击&lt;/button&gt; const handleClick = (msg) =&gt; { console.log('msg') } React
&lt;button onClick="handleClick('hello')"&gt;点击&lt;/button&gt; const handleClick = (msg) =&gt; { return () =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc7312b6d130c98e4d864c19f241cecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1063dfaea0a957c1b35ea66d114392b1/" rel="bookmark">
			Frp&#43;长亭雷池waf&#43;Nginx实现内网穿透
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、说明1. 实现目的2. 参考链接 二、具体实现1. Frp安装配置1.1.frps配置1.2.frpc配置1. 实现直接https访问:https2http2. frpc使用Http接收 2. Waf环境安装配置2.1. 环境搭建2.2. 使用配置2.2.1. 站点添加2.2.2. 黑白名单2.2.3 检测日志&amp;源IP获取方式设置 3. Nginx安装配置1.公网Nginx安装2.内网Nginx安装 4.群晖获取真实来源IP配置 三、实现效果展示1. waf拦截效果2. 群晖登录记录访问IP 一、说明 1. 实现目的 由于没有固定的宽带，拿不到公网IP地址。所以只能使用内网穿透工具通过腾讯云轻量主机进行内网穿透。想在穿透过程中使用waf对于一些恶意请求进行拦截处理。故而产生了本篇文档的使用安装说明
2. 参考链接 Centos7环境下安装Nginx:Centos7安装配置nginx长亭雷池一键安装:长亭雷池官网安装介绍frp配置介绍:frp中文文档CentOS7安装Docker 和 docker-compose：CSDN安装Docker和Docker-Compose 二、具体实现 1. Frp安装配置 之前已经有写过关于frp安装的文档，这里不再说明可以查看Frp内网穿透安装及配置
1.1.frps配置 这里主要调整一个配置，locations_http_to_https
[common] bind_port = 7000 token = your token vhost_http_port = 80 #http服务监听的端口 #以下dashboard相关为管理看板的地址和账号密码 dashboard_port = 8888 dashboard_user = admin dashboard_pwd = admin enable_prometheus = true #日志输出地址，级别，最大保留天数 log_file = /var/log/frps.log log_level = info log_max_days = 3 [web] type = http custom_domains = your domain #主要增加以下这段，强制将http请求跳转到https locations_http_to_https = true ## 通过配置 locations_http_to_https 让我们的http请求强制跳转到https端口上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1063dfaea0a957c1b35ea66d114392b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89a5a3d75381777a58088f6830b8f261/" rel="bookmark">
			【记录】Windows 11｜激活Windows系统的产品密钥的获取、安装、查看以及查询使用次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows 11。
系统的产品密钥的获取、安装、查看以及查询使用次数的具体步骤如下。
文章目录 1 产品密钥的获取2 产品密钥的安装和激活3 产品密钥的查看及使用次数查询 1 产品密钥的获取 如果重装了系统导致系统未激活，但没有提前记录产品密钥，这时可以使用以下三种方法查看自己的硬件里的产品密钥：
命令提示符查看原始密钥（wmic path softwarelicensingservice get OA3xOriginalProductKey）；注册表查看备份产品密钥（HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SoftwareProtectionPlatform右侧的 BackupProductKeyDefault）；使用硬件检测软件AIDA64或者produkey查看密钥。 具体操作步骤，见于：查看 Windows 系统正版产品密钥的 3 种方法，重装必备！。
如果单纯地没有正版密钥，可以让同事看一下本文，让他意识到自己的系统密钥次数完全用不完，然后借他的密钥激活一下。
2 产品密钥的安装和激活 可以采用slmgr。
首先win+x打开Windows终端（管理员权限）。
然后输入：
slmgr 会弹出一堆窗口，它们是使用说明。
很显然，/ipk就是安装，/ato就是激活，/dli就是显示产品密钥，/dlv就是显示详细信息。
安装以及激活：
slmgr /ipk xxxxx-xxxxx-xxxxx-xxxxx slmgr /ato 3 产品密钥的查看及使用次数查询 仅仅是查看密钥，可以输入：
wmic path softwarelicensingservice get OA3xOriginalProductKey 输入后会显示下图所示的内容：
希望同时显示产品密钥，和密钥使用次数，则可以输入：
slmgr /dlv 输入后将会弹窗显示如下：
可以看到重置次数还剩 999次。（次数怪多的）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3c0dd34b140d15d5c2c0954f8b98f53/" rel="bookmark">
			CSS、SCSS、LESS语法的区别详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
CSS、SCSS、LESS语法的区别详解
1. CSS
2. SCSS
变量
嵌套规则
混合
函数
3. LESS
变量
嵌套规则
混合
函数
区别对比
总结
CSS、SCSS、LESS语法的区别详解 1. CSS CSS（Cascading Style Sheets）是一种样式表语言，用于描述HTML或XML（包括如SVG、XUL等等）文档的外观和格式。CSS描述了如何将元素显示在屏幕上，打印出来，或者以其他方式呈现给用户。
css body { background-color: #f0f0f0; } h1 { color: #333; font-size: 2em; } CSS没有变量、嵌套规则、混合、函数等高级功能。
2. SCSS SCSS（Sassy CSS）是CSS预处理器Sass的一种语法格式。它使用全新的语法结构，相比于原生的CSS，SCSS可以使用变量、嵌套规则、混合、函数等高级功能。
变量 在SCSS中，我们可以使用$符号来定义一个变量：
scss $font-stack: Helvetica, sans-serif; $primary-color: #333; body { font: 100% $font-stack; color: $primary-color; } 嵌套规则 SCSS支持嵌套规则，这意味着你可以在一个选择器内部定义另一个选择器：
scss nav { ul { margin: 0; padding: 0; list-style: none; } li { display: inline-block; } a { display: block; padding: 6px 12px; text-decoration: none; } } 混合 混合是一种可以重复使用的代码块，你可以在任何地方引用它：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3c0dd34b140d15d5c2c0954f8b98f53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc193655b2c99b51312260761c0f1995/" rel="bookmark">
			GOM引擎卡在正在加载游戏资源－－解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GOM引擎点开始游戏一直卡在正在加载游戏资源中...下载好版本之后只更新过KEY，其它的没有动，当时我也不知道是什么问题.
这种情况比较常见，有不少人碰到过这种情况，后来经过仔细对比发现，原来是NewopUI.Pak这个必备补丁文件的问题，之所以卡在这里，是因为NewopUI.Pak里面少一些文件，不能正常读取出界面文件，所以跳不过去。
解决方法：先用官方引擎里面的NewopUI.Pak生成登陆器试，或者找版本里面的登陆器\补丁文件夹下，和补丁文件包里面有没有NewopUI.Pak这个文件，如果有，一个个复制过来生成登陆器试，都试了不行的话就是版本问题了，不会修复的话建议更换版本吧。
今天的分享就到这里了，感谢您的阅读，若是想要了解更多传奇技术干货，关注我主页更精彩
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/996f5c4fe9c94dfd69f275b1c5dc255c/" rel="bookmark">
			什么是提示工程？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：芝士AI吃鱼
理解大规模人工智能模型为何如此行事是一门艺术。即使是最有成就的技术专家也会对大型语言模型 (LLM) 的意想不到的能力感到困惑，大型语言模型是ChatGPT等人工智能聊天机器人的基本构建模块。
因此，提示工程成为生成式 AI 领域的热门工作也就不足为奇了，但这份工作究竟是什么？
什么是即时工程？ 专业的提示工程师每天都在研究人工智能的运作原理。他们使用精心设计的提示以及精确的动词和词汇，将聊天机器人和其他类型的生成人工智能发挥到极限，发现错误或新问题。
每个组织的角色细节各不相同，但总的来说，即时工程师致力于以可重复的方式改进机器生成的输出。换句话说，他们试图使人工智能行为与人类意图保持一致。
为什么即时工程并不完全适合技术人员 虽然杰出的提示工程师拥有罕见的纪律和好奇心，但在开发良好的提示时，他们还利用了不限于计算机科学领域的通用技能。
即时工程的兴起正在向具有更多样化技能的创意人员开放生成式人工智能开发的某些方面，其中很大一部分与无代码创新有关。特斯拉前人工智能总监Andrej Karpathy 于 2023 年 1 月发推文表示，“最热门的新编程语言是英语”。
在某种程度上，优秀的提示工程师可以弥补人工智能的局限性：人工智能聊天机器人可以擅长语法和词汇，但没有世界的第一手经验，这使得人工智能开发成为一项多学科的工作。
然而，一些专家质疑该角色的长期价值，因为通过笨拙的提示可以获得更好的输出。但生成技术有无数的用例，人工智能输出的质量标准将不断提高。这表明即时工程作为一项工作（或至少是工作中的一项职能）不会很快消失。
5 项非技术提示工程技能 任何与生成人工智能交互的人都应该对即时工程师的日常活动感兴趣，原因有两个：（1）它阐明了技术的能力和局限性。（2）它让人们更好地理解如何利用他们已经拥有的技能与人工智能进行更好的对话。
以下是通过即时工程的多学科领域促进人工智能技术发展的五种非技术技能。
1. 沟通 就像项目经理、教师或任何定期向其他人介绍如何成功完成任务的人一样，提示工程师需要善于发出指示。大多数人需要大量的例子才能完全理解指令，人工智能也是如此。
Edward Tian开发了 GPTZero，这是一种人工智能检测工具，可以帮助确定高中论文是否由人工智能撰写，并向大型语言模型展示了示例，以便它可以使用不同的声音进行写作。
当然，Tian 是一位拥有深厚技术技能的机器学习工程师，但任何正在开发提示并希望聊天机器人以特定方式编写的人都可以使用这种方法，无论是经验丰富的专业人士还是小学生。
2. 主题专业知识 许多提示工程师负责针对特定用例（例如医疗保健研究）调整聊天机器人。
这就是为什么突然出现要求特定行业专业知识的工程职位招聘信息。例如，英国律师事务所 Mishcon de Reya LLP有一个 GPT 法律提示工程师的职位空缺。他们正在寻找“对法律实践有深入了解”的候选人。
主题专业知识，无论是在医疗保健、法律、营销还是木工方面，对于制作强有力的提示都是有用的。细节决定成败，在与人工智能交谈时，现实世界的经验非常重要。
3. 语言 为了让人工智能取得成功，它需要有意图。这就是为什么善于使用动词、词汇和时态来表达总体目标的人有能力提高人工智能性能。
当 Anna Bernstein 开始在 Copy.ai 工作时，她发现将提示视为一种魔咒很有用：一个错误的单词会产生与预期截然不同的结果。“作为一名诗人，这个角色……通过接近的语言融入了我的痴迷本性。这是我的文学背景和分析思维的一个非常奇怪的交叉点，”她在接受《商业内幕》采访时说道。
AI提示不使用编程语言，而是使用散文，这意味着人们在开发提示时应该释放内心的语言学热情。
4.批判性思维 生成式人工智能擅长合成大量信息，但它可能会产生幻觉（这是一个真正的技术术语）。当聊天机器人的训练或设计质量较差或数据不足时，就会出现人工智能幻觉。当聊天机器人产生幻觉时，它只是吐出虚假信息（以相当权威、令人信服的方式）。
提示工程师找出这个弱点，然后训练机器人变得更好。例如，人工智能初创公司 Scale AI 的即时工程师Riley Goodside在向聊天机器人询问以下问题时得到了错误的答案：“贾斯汀·比伯出生那一年，哪支 NFL 球队赢得了超级碗？” 然后，他要求聊天机器人列出一系列逐步的逻辑推论，以得出答案。最终，它纠正了自己的错误。
这强调了对主题有适当的熟悉程度是关键：对于某人来说，让聊天机器人生成他们无法可靠地进行事实核查的东西可能不是一个好主意。
5. 创造力 尝试新事物是创造力的定义，也是良好的即时工程的本质。Anthropic 的招聘启事称，该公司正在寻找一名具备“创造性黑客精神”等资质的快速工程师。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/996f5c4fe9c94dfd69f275b1c5dc255c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c712a2a18e55aaf4bd7811695de4f307/" rel="bookmark">
			介绍Vue router的history模式以及如何配置history模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 Vue router给我们提供了两种路由模式，分别是hash模式和history模式。其中默认是使用hash模式，即URL中带有一个#符号，但是处于业务或个人喜爱的差别，Vue router也提供了history模式。但是由于Vue是单页SPA应用，所以每个路由并没有对应的html文件。
什么是history模式 history模式特点 history模式使用浏览器的history API来管理路由状态，而不是依赖于URL中的哈希。在history模式下，URL看起来更加整洁，没有#符号。例如，http://example.com/user/profile。history模式可以在不刷新整个页面的情况下，通过改变URL来切换页面，实现更加流畅的用户体验 history模式的优缺点 优点： 更友好的URL：history模式下的URL看起来更加整洁，没有特殊字符（如#），给用户提供了更好的阅读体验。无刷新页面切换：使用history模式时，页面切换不会导致整个页面的刷新，仅仅改变URL，从而实现更加流畅的用户体验。更好的SEO：搜索引擎对于history模式下的页面更容易进行抓取和索引，因为URL更加直观、语义化。路由传参更方便：相比hash模式的URL传参，history模式下的传参更加直观简洁，参数可以直接通过URL的路径进行表示。 缺点： 服务器配置要求：使用history模式需要服务器的支持，因为URL改变时，要确保服务器能正确地展示相应的页面，需要进行一些额外的服务器配置。兼容性问题：history模式在一些旧版本的浏览器（如IE9及以下）中不被支持，如果要兼容这些浏览器，可能需要降级为hash模式。开发环境要求：当使用history模式时，需要在开发环境中配置一个服务器来模拟URL的请求，以确保路由正常运行，相比hash模式需要更多的配置。 如何配置Vue Router使用history模式 - 首先我们需要创建一个Vue项目
- 安装Vue Router
npm i vue-router - 在Vue项目中配置Vue Router使用history模式
import Vue from 'vue';import VueRouter from 'vue-router';Vue.use(VueRouter);const router = new VueRouter({ mode: 'history', routes: [ // 路由配置 ]});export default router; 服务器配置
- 配置服务器，使得所有路由的URL都指向入口页面，我们用nginx配置举例： server { listen 80; server_name your_domain.com; root /path/to/your/vue_app/dist; index index.html; location / { try_files $uri $uri/ /index.html; }}# 在以上配置中，需要进行以下调整：# 1. server_name：将your_domain.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c712a2a18e55aaf4bd7811695de4f307/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/900c6b23a0c511620984a774f8826eeb/" rel="bookmark">
			jar包运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.jar包在windows下运行 1.第一种启动方式
直接启动，日志输出到控制台,这种启动方式，当前命令窗口关闭后则，程序停止
java -jar xxx.jar 2.第二种启动方式
后台启动，以服务的形式启动jar，启动后，关闭需要杀掉进程
javaw -Xms128m -Xmx1024m -jar xxx.jar 3.结束jar包运行
后台启动，以服务的形式启动jar，启动后，关闭需要杀掉进程
@echo off taskkill -f -t -im javaw.exe exit 4.设置jar包开机自运行
利用windows管理工具，任务计划程序。
1.在任务计划程序库上右键，创建任务 2.设置常规信息 填写任务名称，任务描述，设置是否需要登录运行，勾选使用最高权限运行。
2.设置触发器 设置启动时运行，其余按需勾选
3.设置启动程序，运行的jar包的bat脚本或者程序exe
选择要运行的脚本，起始于的位置，添加脚本所在的文件目录
二.jar包在linux下运行 1.运行jar包 在Linux系统下，启动架包和在windows下启动jar包的命令是一样的，但有个前提，你必须先安装jdk或jre；
java -jar xxx.jar 2.把命令放在后台执行 在命令的末尾加上一个&amp;符号，就能让该命令在后台运行，在终端输入中断命令ctrl+c，不会影响该架包的启动；但是终端执行exit退出终端窗口，或终端窗口连接超时，该命令就会被迫kill。
java -jar xxx.jar &amp; 3.把命令放在后台执行 在命令的前面加上nohup，就可以保证启动命令彻底脱离终端窗口。
nuhup java -jar xxx.jar &amp; 4.结束jar包运行 终止之前我们首先需要查看一下java程序的进程id，通过进程id来结束进程。命令如下：
ps -ef|grep java 5.如何找到已经运行的jar包 ps是process status的简称，用于显示当前进程的状态； a：all简称，显示所有程序； u：user简称，以用户为主的格式来显示； x：显示所有程序，不区分终端机； ps aux | grep xxx.jar 6.关闭已经运行的jar包 使用第9种信号(SIGKILL)无条件终止该进程；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/900c6b23a0c511620984a774f8826eeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca0a78794889a5c6b90eceda37ef2c3f/" rel="bookmark">
			首篇综述！Open Vocabulary学习综述：全面调研
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击下方卡片，关注“CVer”公众号
AI/CV重磅干货，第一时间送达
点击进入—&gt;【目标检测和Transformer】交流群
前言：
最近大火的Open Vocabulary 方向第一篇综述！北京大学、南洋理工大学等联合发表最新的Open Vocabulary 综述。综述涵盖多种任务（检测、分割、视频、3D）的百多种不同的Open Vocabulary方法，最新模型截止至今年6月！同时，综述还首次在统一数据集上公平对比了目前的代表性方法，并讨论了几个具有广阔前景的未来研究方向！
在CVer公众号后台回复：开放词汇综述，即可下载本文综述PDF和项目
摘要：
在视觉场景理解领域，深度神经网络在分割、跟踪和检测等各种核心任务中取得了令人印象深刻的进步。然而，大多数方法都基于闭集假设，这意味着模型只能识别训练集中存在的预定义类别。最近，由于视觉语言预训练（VLM）的快速进展，开放词汇（Open Vocabulary）设置被提出。这些新方法寻求识别和定位带注释的标签之外的类别。与弱监督（Weak Supervision）和零样本（Zero-Shot）设置相比，开放词汇方法更通用、更实用、更有效。作者对开放词汇学习进行了全面回顾，总结和分析了该领域的最新发展。作者首先将其与零样本学习、开集识别和分布外检测等相关概念进行比较。然后回顾了分割和检测中几个密切相关的任务，包括长尾问题、少样本和零样本设置。对于方法综述，作者首先介绍检测和分割的基本知识作为初步知识。接下来，作者划定了使用开放词汇学习的各种场景，然后比较常用数据集和基准（Benchmark）中最新的检测和分割方法。最后，作者总结了关于未来研究方向的见解、问题和讨论。
论文题目：Towards Open Vocabulary Learning: A Survey
发表单位：北京大学，南洋理工大学等
论文地址：https://arxiv.org/abs/2306.15880
项目地址：
https://github.com/jianzongwu/Awesome-Open-Vocabulary
提交时间：2023年6月28日
在CVer公众号后台回复：开放词汇综述，即可下载本文综述PDF和项目
1，研究动机：
新热点，大众瞩目的方向：
图 1 Open Vocabulary近期代表性工作
如图所示，从2021年第一篇提出Open Vocabulary Object Detection的工作开始，Open Vocabulary的工作数量逐年增加，逐渐成为计算机视觉+自然语言处理，多模态领域的新热点。在过去的两中，针对不同任务的Open Vocabulary工作提出了总计有一百多种方法。
2，这篇综述的特色，以及和相关领域的综述有什么区别？
图 2 Open Vocabulary和其他setting的区别
本文是聚焦于Open Vocabulary领域的第一篇综述。
1，为了明确定义，作者对Open Vocabulary和其他setting做了详细的区分和定义。具体来说，Open-Set/Open World/OOD 不对novel类别进行分类，Zero-Shot对novel类别进行分类，Open Vocabulary不仅对novel类别进行分类，它还可以使用和图像相关的文本数据进行弱监督训练，而Zero-Shot中，训练数据是严格不能和novel类别重合的。
2，本综述也会系统地回顾下近些年来在闭集的一些分割检测方法的进展，作为预备的知识，方便新人也能很快了解闭集以及open-vocabulary之间的关系。同时综述还回顾了几个相关领域，比如zero-shot segmentation/detection，long-tail segmentation/detection。
3，本综述是从具体的技术细节对现有的分割检测以及3D任务进行细粒度的一个分类，确保读者对整个领域方法有个大致系统性的认知。
4，本综述详细地对比了多个不同open vocabulary setting下的方法性能，确保
3，Open Vocabulary典型算法框架总结：
图 3 Open Vocabulary典型算法框架
本文以一张图总结了Open Vocabulary领域检测/分割的一个典型通用算法框架。图片首先输入一个Image Encoder，再将Encoder得出的特征输入到检测/分割头中，得到bounding box/object mask，以及每个物体的visual embedding。和传统分割算法不同的是，open vocabulary领域将物体的分类器权重换成了由VLM-text生成的base和novel类别的text embedding。通过计算visual embedding和text embedding的相似度，最终可以得出每个物体的类别。目前使用最多的VLM-text模型是CLIP。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca0a78794889a5c6b90eceda37ef2c3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c3bafeb7394e47716ee83a034f4f502/" rel="bookmark">
			Maven高级（四）--私服
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.作用 我们所拆分的模块是可以在同一个公司各个项目组之间的项目组之间进行资源共享的，这就需要Maven的私服来实现。
二.场景 两个项目组之间如何基于私服进行资源的共享的呢？
例如A开发了一个模块tlias-utils,B团队进行项目开发，要想使用tlias-utils中提供的工具类，怎么办呢？在pom.xml文件中引入对应的坐标。
当B团队在maven项目的pom.xml配置文件中引入依赖之后，maven如何查找这个依赖？查找顺序：
（1）本地仓库：只在A团队的本地仓库有这个依赖jar包，B的本地仓库没有。
（2）远程中央仓库：中央仓库全球只有一个，不是什么人都可以往中央仓库中来上传jar包的，我们是没有权限操作的。
所以此时maven的私服就出场了，私服其实就是架设在公司局域网内部的一台服务器，就是一种特殊的远程仓库。
这样各个团队可以连接私服上传jar包，如果我们在项目中需要使用其他第三方提供的依赖，如果本地仓库没有，也会自动连接私服下载，如果私服没有，私服此时会自动连接中央仓库，去中央仓库中下载依赖，然后将下载的依赖存储在私服仓库及本地仓库中。
三.概念 【1】私服：是一种特殊的远程仓库，它是假设在局域网内的仓库服务，用来代理位于外部的中央仓库，用于解决团队内部的资源共享与资源同步的问题。
【2】依赖查找顺序：
本地仓库-&gt;私服仓库-&gt;中央仓库
四.具体步骤 资源的上传与下载，我们需要做三步配置，执行一条指令。
第一步配置：在maven的配置文件中配置访问私服的用户名和密码。--在自己maven安装目录下的conf/setting.xml中的servers中配置。例：
&lt;server&gt; &lt;id&gt;maven-releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;maven-snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin&lt;/password&gt; &lt;/server&gt; 第二步配置：在maven的配置文件中配置连接私服的地址（url地址，依赖下载的仓库组地址）--在自己maven安装目录下的conf/settings.xml中的mirrors,profiles中配置。例：
&lt;mirror&gt; &lt;id&gt;maven-public&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;http://192.168.150.101:8081/repository/maven-public/&lt;/url&gt; &lt;/mirror&gt; &lt;profile&gt; &lt;id&gt;allow-snapshots&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;maven-public&lt;/id&gt; &lt;url&gt;http://192.168.150.101:8081/repository/maven-public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt; 第三步配置：IDEA的maven工程的pom文件中配置上传（发布地址）--直接在tlias-parent中配置发布地址。例：
&lt;distributionManagement&gt; &lt;!-- release版本的发布地址 --&gt; &lt;repository&gt; &lt;id&gt;maven-releases&lt;/id&gt; &lt;url&gt;http://192.168.150.101:8081/repository/maven-releases/&lt;/url&gt; &lt;/repository&gt; &lt;!-- snapshot版本的发布地址 --&gt; &lt;snapshotRepository&gt; &lt;id&gt;maven-snapshots&lt;/id&gt; &lt;url&gt;http://192.168.150.101:8081/repository/maven-snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; 配置好了上述三步之后，要上传资源到私服仓库，就执行maven声明周期：deploy。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c3bafeb7394e47716ee83a034f4f502/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/718dfbb9b750e58c7e9f7f73ccde05eb/" rel="bookmark">
			vue&#43;springboot架构，后端service层介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue+springboot架构，后端service层介绍 前言 本文主要介绍了vue+springboot架构中，后端service层的作用和实现方法，希望能对有兴趣的读者有所帮助。
service层的作用 vue+springboot架构是一种前后端分离的开发模式，后端service层是用来封装业务逻辑和数据操作的功能，供controller层调用和返回结果。后端service层一般需要做以下几件事情：
定义service层的接口和实现类，接口中声明业务方法，实现类中编写业务逻辑。注入dao层或mapper层的对象，调用它们的方法来操作数据库或执行sql语句。处理异常情况，例如捕获sql异常，抛出自定义异常等。添加事务管理注解，保证数据的一致性和完整性。 service层的示例代码 下面是一个简单的后端service层的示例代码：
// service层接口 public interface UserService { // 查询所有用户 List&lt;User&gt; findAllUsers(); // 根据id查询用户 User findUserById(Integer id); // 添加用户 void addUser(User user); // 更新用户 void updateUser(User user); // 删除用户 void deleteUser(Integer id); } // service层实现类 @Service public class UserServiceImpl implements UserService { @Autowired private UserMapper userMapper; @Override public List&lt;User&gt; findAllUsers() { return userMapper.selectAllUsers(); } @Override public User findUserById(Integer id) { return userMapper.selectUserById(id); } @Override @Transactional // 添加事务管理注解 public void addUser(User user) { userMapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/718dfbb9b750e58c7e9f7f73ccde05eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/debf93bd74d20f5250614df724af0be7/" rel="bookmark">
			Python 变量作用域浅谈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍了Python 变量作用域的相关资料，文中讲解非常细致，代码帮助大家更好的理解和学习，感兴趣的朋友可以了解下
特点
python的作用域是静态的，在源代码中变量名被赋值的位置决定了该变量能被访问的范围。即Python变量的作用域由变量所在源代码中的位置决定。Python中并不是所有的语句块中都会产生作用域。只有当变量在Module(模块)、Class(类)、def(函数)中定义的时候，才会有作用域的概念。
1. 函数内部的变量，函数外部不能访问
1
2
3
4
def func():
variable = 100
print(variable) print(variable) # name 'variable' is not defined
2. 函数上层的变量(标量)只能读取，不能再次定义，初始化
1
2
3
4
5
6
7
8
def counter1():
n = 0
def compute():
n = n + 1 # n为标量（数值，字符串，浮点数），Python程序会因为“如果内部函数有引用外部函数的同名变量或者全局变量,并且对这个变量有修改.那么python会认为它是一个局部变量,又因为函数中没有n的定义和赋值，所以报错
# y = n + 1 # 更改为y就没事
# return y
return n
return compute
1
2
3
4
5
6
variable = 300
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/debf93bd74d20f5250614df724af0be7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5398d41f9ab9c1582049894156d9a0ac/" rel="bookmark">
			关于搞视觉识别的数据处理的一些注意事项及诸多代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.一定一定要备份
2.图片拍摄
3.图片处理
4.图片裁剪
5.格式转化
方案一
方案二
6．图片分类
7.打标签
8.重命名
9.随机挑选数据集
其实这部分内容并不多，主要就交代一下需要注意的地方
1.一定一定要备份 在拍摄图像数据集或者打完标签之类的时候，特别是进行大规模批量处理前，一定进行备份，这部分不需要代码，只需要简单的复制粘贴就可以，所以不过多陈述
哪怕搞得复杂一点也总比事后干着急强 ​​​​​​ 2.图片拍摄 数据集收集，不在于数量，而在于质量。这其实是一个比较复杂的，需要进行权衡的工作，我建议交给比较机灵的人去干。
比如，假如拍了1000张水瓶，但是这些水瓶的角度和姿态都大差不差，那这就是废品，这会导致在训练之后对水瓶的识别会变得十分苛刻。
又比如，假如拍了1000张水瓶，但是这些水瓶的角度全都不一样，这其实也是废品，这会导致在训练之后对水瓶的识别变得十分松懈或者更加苛刻。
所以需要在复杂和单一中进行权衡，对更容易出现的角度和姿态进行多拍，对不容易出现的角度少拍但是不能不拍。
这边建议先把垃圾盛放台和摄像头的大小间距之类的先决定好后直接开始搭建拍摄台，1：1复刻垃圾桶正式出炉的拍摄状态，这样会很利于后续的识别，也可以直接随心一点扔，数量多了就能看出哪种姿态更加常见，但是这对拍摄台的特征要求比较高。
哪怕只拍了两张也可以通过旋转或者调色调等增大数量还能提高随机性 3.图片处理 这部分我觉得没啥用，但是其实还是有点用的，比如最基础的旋转。
在旋转目标识别中有着非常大的作用。
或者比如曝光度或者对比度之类的，这使垃圾桶在面对不同光照下时的识别变得容易得多。
其他的比如改噪点啊，或者改色调啊，肯定还是有用，但是我感觉作用并不是那么明显了，我觉得可能会影响整体数据，也就不多阐述了，在本次数据集处理我是肯定不会做这些的，假如后人想试一试，那也可以搞一搞对这进行补充。
这是cv搞出来的实时图像处理，还是蛮酷的，可以用来装逼，代码用的是别人的，想要的话可以私信或者评论找我要 4.图片裁剪 图片裁剪一般都是进行大规模批量裁剪，所以像我最开始所说，一定要记得备份。
具体什么时候裁剪我就不多说了，肯定是会遇到的。
这里就放一下我用的批量裁剪代码吧
from PIL import Image import os import os.path # 定义文件所在文件夹 image_dir = "文件夹路径" for parent, dir_name, file_names in os.walk(image_dir): # 遍历每一张图片 for filename in file_names: pic_name = os.path.join(parent, filename) image = Image.open(pic_name) _width, _height = image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5398d41f9ab9c1582049894156d9a0ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec09cbea291a956fce8c871c2ca1a80e/" rel="bookmark">
			Java中的回调函数是什么?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中，回调函数是一种常见的编程模式，也称为回调机制。它允许将一段代码作为参数传递给另一个方法，并在需要时执行。回调函数通常用于异步编程或事件处理，可以将程序的控制权转移到回调函数上，以便在特定事件发生时执行相关的操作。
在Java中，回调函数通常通过接口来实现。具体步骤如下：
定义一个接口，其中声明回调方法。这个方法的参数和返回类型取决于你的需求。
编写包含回调函数的方法，并将接口作为参数传递进去。这样，该方法就知道在需要时调用哪个回调方法。
创建实现接口的类，并实现回调方法。
在主程序中，实例化回调接口的实现类，并将其作为参数传递给包含回调函数的方法。
当特定事件发生时，包含回调函数的方法会调用传递的回调对象的回调方法，执行特定的操作。
回调函数在Java中的应用非常广泛，例如在事件处理、线程编程、网络编程等方面都有使用。它可以提供更灵活的程序设计方式，使得代码更具可读性和可维护性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40fd8a2224392755dfacaa1b4c969a64/" rel="bookmark">
			MySQL事务管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL事务管理 事务的概念 事务的概念
事务由一条或多条SQL语句组成，这些语句在逻辑上存在相关性，共同完成一个任务，事务主要用于处理操作量大，复杂度高的数据。比如转账就涉及多条SQL语句，包括查询余额（select）、在当前账户上减去指定金额（update）、在指定账户上加上对应金额（update）等，将这多条SQL语句打包便构成了一个事务。MySQL同一时刻可能存在大量事务，如果不对这些事务加以控制，在执行时就可能会出现问题。比如单个事务内部的某些SQL语句执行失败，或是多个事务同时访问同一份数据导致数据不一致的问题。 因此一个完整的事务并不是简单的SQL集合，事务还需要满足如下四个属性：
原子性： 一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中如果发生错误，则会自动回滚到事务开始前的状态，就像这个事务从来没有执行过一样。持久性： 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。隔离性： 数据库允许多个事务同时访问同一份数据，隔离性可以保证多个事务在并发执行时，不会因为由于交叉执行而导致数据的不一致。一致性： 在事务开始之前和事务结束以后，数据库的完整型没有被破坏，这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联型以及后续数据库可以自发性地完成预定的工作。 上面的四个属性简称ACID：
原子性（Atomicity，又称不可分割性）。一致性（Consistency）。隔离性（Isolation，又称独立性）。持久性（Durability）。 为什么会出现事务？
事务被MySQL编写者设计出来，本质是为了当应用程序访问数据库的时候，事务能够简化我们的编程模型，不需要用户自己去考虑各种各样的潜在错误和并发问题。
如果MySQL只是单纯的提供数据存储服务，那么用户在访问数据库时就需要自行考虑各种潜在问题，包括网络异常、服务器宕机等。因此事务本质是为了应用服务的，而不是伴随着数据库系统天生就有的。
事务的版本支持 事务的版本支持
通过show engines命令可以查看数据库引擎。如下：
说明一下：
Engine： 表示存储引擎的名称。Support： 表示服务器对存储引擎的支持级别，YES表示支持，NO表示不支持，DEFAULT表示数据库默认使用的存储引擎，DISABLED表示支持引擎但已将其禁用。Comment： 表示存储引擎的简要说明。Transactions： 表示存储引擎是否支持事务，可以看到InnoDB存储引擎支持事务，而MyISAM存储引擎不支持事务。XA： 表示存储引擎是否支持XA事务。Savepoints： 表示存储引擎是否支持保存点。 事务的提交方式 查看事务的提交方式
事务常见的提交方式有两种，分别是自动提交和手动提交。
通过show命令查看autocommit全局变量，可以查看事务的自动提交是否被打开。如下：
说明一下： autocommit的值为ON表示自动提交被打开，值为OFF表示自动提交被关闭，即事务的提交方式为手动提交。
设置事务的提交方式
通过set命令设置autocommit全局变量的值，可以打开或关闭事务的自动提交。如下：说明一下： 将autocommit的值设置为1表示打开自动提交，设置为0表示关闭自动提交，相当于将事务提交方式设置为手动提交。
事务的相关演示 准备测试表
为了便于演示，我们将MySQL的隔离级别设置成读未提交，也就是把隔离级别设置的比较低，方便看到实验现象。如下：
需要注意的是，设置全局隔离级别后当前会话的隔离级别不会改变，只会影响后续与MySQL新建立的连接，因此需要重启终端才能看到会话的隔离级别被成功设置。如下：
创建一个银行用户表，表中包含用户的id、姓名和账户余额。如下：
演示一：事务的常规操作
启动两个终端，左终端使用begin或start transaction命令启动一个事务，右终端查看银行用户表中的信息。如下：
左终端中的事务向表中插入一条记录，由于我们将隔离级别设置成了读未提交，因此在左终端中的事务使用commit提交之前，在右终端中就能查看到事务向表中插入的记录。如下：
左终端中的事务使用savepoint命令创建一个保存点，然后继续向表中插入一条记录，这时在右终端中也能看到新插入的这条记录。如下：
左终端中的事务使用rollback命令回滚到保存点，这时右终端在查看表中数据时就看不到刚才插入的第二条记录了。如下：
左终端中的事务使用rollback命令回滚到事务最开始，这时右终端在查看表中数据时就看不到任何记录了。如下：
说明一下：
使用begin或start transaction命令，可以启动一个事务。使用savepoint 保存点命令，可以在事务中创建指定名称的保存点。使用rollback to 保存点命令，可以让事务回滚到指定保存点。使用rollback命令，可以直接让事务回滚到最开始。使用commit命令，可以提交事务，提交事务后就不能回滚了。 演示二：原子性
在左终端中启动一个事务，在右终端查看银行用户表中的信息。如下：
左终端中的事务向表中插入一条记录，由于隔离级别是读未提交，因此在右终端中能够查询到插入的这条记录。如下：
如果左终端中的事务在提交之前因为某些原因与MySQL断开连接，那么MySQL会自动让事务回滚到最开始，这时右终端中就看不到之前插入的记录了。如下：
演示三：持久性
在左终端中启动一个事务，在右终端查看银行用户表中的信息。如下：
左终端中的事务向表中插入一条记录，由于隔离级别是读未提交，因此在右终端中能够查询到插入的这条记录。如下：
左终端中的事务在提交后与MySQL断开连接，这时右终端中仍然可以看到之前插入的记录，因为事务提交后数据就被持久化了。如下：
演示四：begin会自动更改提交方式
通过show命令查看autocommit的值为ON，表示事务的提交方式是自动提交，此时银行用户表中有一条记录。如下：
在左终端中启动一个事务并向表中新插入一条记录，由于隔离级别是读未提交，因此在右终端中能够查询到新插入的这条记录。如下：
如果左终端中的事务在提交之前与MySQL断开连接，那么MySQL依旧会自动让事务回滚到最开始，这时右终端中就看不到之前新插入的记录了。如下：
也就是说，使用begin或start transaction命令启动的事务，都必须要使用commit命令手动提交，数据才会被持久化，与是否设置autocommit无关。
演示五：单条SQL与事务的关系
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40fd8a2224392755dfacaa1b4c969a64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cd45e89e7e06c3b4af3760dab165271/" rel="bookmark">
			SpringBoot &#43; Docker 实现一次构建到处运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、容器化部署的好处 Docker 作为一种新兴的虚拟化方式，它可以更高效的利用系统资源，不需要进行硬件虚拟以及运行完整操作系统等额外开销。
传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。
最重要的是一致的运行环境。Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性。从而达到真正意义上的 一次构建，到处执行。
二、构建镜像 2.1、Dockerfile 接着我们开始使用 Dockerfile 来定制我们的镜像，从而达到容器化的目的。Dockerfile 的本质就是将一系列修改、安装、构建、操作的命令整合到一起，去构建一个个性化的镜像，以达到一次构建，到处运行。接下来我们就来构建自定义镜像。
在my-project-server模块下创建docker目录，在docker目录下创建Dockerfile。代码如下：
FROM openjdk:8-jre MAINTAINER Micromaple &lt;micromaple@qq.com&gt; RUN mkdir /app COPY my-project-server-1.0.0-SNAPSHOT.jar /app/app.jar ENTRYPOINT ["java", "-Djava.security.egd=file:/dev/./urandom", "-jar", "/app/app.jar", "--spring.profiles.active=prod,druid-prod"] EXPOSE 8899 FROM：指定基础镜像，项目是使用jdk8开发的项目，所以我们指定的基础镜像为openjdk:8-jre
MAINTAINER：项目维护人员
RUN：执行命令，在根目录下创建app目录
COPY：将宿主机当前目录下的my-project-server-1.0.0-SNAPSHOT.jar文件拷贝到app目录下，并重命名为app.jar
ENTRYPOINT：指定容器启动程序及参数
EXPOSE：指定运行时容器提供服务的端口
2.2、开始构建 在虚拟机创建目录
mkdir -p /usr/local/docker/my-project/docker 将打包后的my-project-server-1.0.0-SNAPSHOT.jar文件和Dockerfile文件上传至该目录。
执行镜像构建命令
docker build -t my-project-server:v1 . 构建成功
$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE my-project-server v1 ed30386b06d2 11 seconds ago 334MB openjdk 8-jre 26ac3f63d29f 9 months ago 273MB 三、搭建私服 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cd45e89e7e06c3b4af3760dab165271/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60fdfeff3089793a0bfec07bd586fd67/" rel="bookmark">
			解决幂等问题，只需要记住这个口诀！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为开发人员，我们每天都要开发大量的接口，其中包括了读接口和写接口，而对于写接口来说，除了要保证他的性能、可用性以外，还需要有一个重要的问题，那就是考虑如何保证接口的幂等性。
幂等性
什么是幂等性？
"幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。 在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。 幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。 这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。"
以上是百度百科中的回答，总结起来就是一句话：一个接口，不管我调多少次，只要参数不变，结果也应该不变。
但是，实际在工作中，谈到幂等性，一般分为两种，即请求幂等和业务幂等
请求幂等：每次请求，如果参数一样，结果也要一样。
业务幂等：同一次业务请求，在拿到最终状态之后的每次请求，结果要保证一样。在没拿到最终状态之前，每一次请求需要正常执行业务逻辑，直到推进到最终状态。
一般来说，我们谈到的幂等性，大部分都是业务幂等。比如，一次支付请求，如果支付返回处理中，或者系统异常等，我们需要重试，继续调用，直到他明确的返回支付成功，或者明确的无法成功的支付失败结果。
如何保证幂等
想要保证幂等性，最简单的做法就是：在做业务操作之前，先查一下，判断下本次操作是否有被执行过，如果执行过，则不再执行，否则继续执行。
但是，这个方案存在一个关键性的问题，那就是在高并发场景中，是可能会有幂等击穿的。
所以，想要解决好这个问题，需要做好并发控制，那么，做并发控制，大家首先想到的就是锁，没错。就是要用锁。
那么，解决幂等问题，请记住这个口诀：”一锁、二判、三更新”
一锁、二判、三更新
“一锁、二判、三更新”，只要严格遵守这个过程，那么就可以解决并发问题。
一锁：第一步，先加锁。可以加分布式锁、或者悲观锁都可以。但是一定要是一个互斥锁！
二判：第二步，进行幂等性判断。可以基于状态机、流水表、唯一性索引等等进行重复操作的判断。
三更新：第三步，进行数据的更新，将数据进行持久化。
三步需要严格控制顺序，确保加锁成功后进行数据查询和判断，幂等性判断通过后再更新，更新结束后释放锁。
以上操作需要有一个前提，那就是第一步加锁、和第二步判断的时候，需要有一个依据，这个就是幂等号了，通常需要和上游约定一个唯一ID作为幂等号。然后通过对幂等号加锁，再通过幂等号进行幂等判断即可。
一锁这个过程，建议使用Redis实现分布式锁，因为他是非阻塞的高效率的互斥锁。非常适合在幂等控制场景中。
二判这个过程，如果有操作流水，建议基于操作流水做幂等，并将幂等号作为唯一性约束，确保唯一性。如果没有流水，那么基于状态机也是可以的。
但是不管怎么样，数据库的唯一性约束都要加好，这是系统的最后一道防线。万一前面的锁失效了，这里也能控制得住不会产生脏数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0e737f5f50c0d40d156e96450d18c09/" rel="bookmark">
			VUE中使用vue-cropper实现图片裁剪，及问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 网上关于vue-cropper的使用有很多篇，但是能详细介绍并且把隐藏的问题总结的却很少（就很烦），正好题主最近用了这个插件，在此做个总结
需求：（这里题主的需求也是经过几次变更，逐步完善了vue-cropper组件的使用，下列序号表示需求的变更 ） 对头像上传功能加入图片裁剪功能（这里只需能裁剪即可，无其他要求）另一个功能点也需要加入图片裁剪功能，且要求裁剪后的图片固定宽高为108像素对头像上传时裁剪后的图片加入限制，宽高不超过300像素 问题： 如果只是需要能裁剪图片，那根据其他大部分vue-cropper篇章即可实现；
这里说一下题主在这些需求下出现的问题及解决方法
需求1：正常引用vue-cropper即可实现裁剪功能；（这里把vue-cropper封装为组件，为方便读写，也预防后续其他地方引用）
需求2：这里加入了裁剪图片固定宽高的限制（截图框固定大小108）
问题1：如果不注意vue-cropper参数的使用，在full: false时，在浏览器页面100%时裁剪图片不出错，当不是100%时，裁剪后的图片宽高会随浏览器页面大小的变化而变化
如：页面缩放比例为90%，截图框显示300，最终截图为270；页面缩放比例为110%，截图框显示300，最终截图为330
解决：设置full: true
问题2：加入了背景图可滚动后，在full: true时，滚动背景图也会影响裁剪图片的大小
解决：这里找了很久但还是找到了解决方法，影响裁剪图片大小的问题解决不了，但是可以解决保存图片大小的问题，即使裁剪的图片大小被影响了，但是在保存图片时可以重置图片大小，保存成需要的图片大小
需求3：这里又加入了新限制，没有遇到新问题，只是对组件做了优化提升
这里题主直接上题主最终版的组件了
1.使用vue-cropper之前，先引入： npm install vue-cropper 2.创建CropperImage组件，main.js中引入 import VueCropper from 'vue-cropper' import CropperImage from '@/components/CropperImage.vue' Vue.component('CropperImage', CropperImage) 3.CropperImage中定义 3.1 template （这里加入了放大、缩小、重置大小三个功能按钮） &lt;template&gt; &lt;el-dialog title="裁切封面" :visible.sync="show" width="1000px" :before-close="handleClose" :close-on-click-modal="false" :close-on-press-escape="false" &gt; &lt;div class="cropper-content"&gt; &lt;div class="cropper-box"&gt; &lt;div class="cropper"&gt; &lt;vue-cropper ref="cropper" :img="option.img" :output-size="option.outputSize" :info="option.info" :can-scale="option.canScale" :auto-crop="option.autoCrop" :auto-crop-width="option.autoCropWidth" :auto-crop-height="option.autoCropHeight" :fixed="option.fixed" :fixed-number="option.fixedNumber" :full="option.full" :fixed-box="option.fixedBox" :can-move="option.canMove" :can-move-box="option.canMoveBox" :original="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0e737f5f50c0d40d156e96450d18c09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/627a3bc983158245d925c382ce9b3035/" rel="bookmark">
			TimestepEmbedSequential&#43; zero_module&#43;make_zero_conv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TimestepEmbedSequential TimestepEmbedSequential@abstractmethodfor layer in self:h = x.type(self.dtype)zero_module+make_zero_conv TimestepEmbedSequential class TimestepBlock(nn.Module): """ Any module where forward() takes timestep embeddings as a second argument. """ @abstractmethod def forward(self, x, emb): """ Apply the module to `x` given `emb` timestep embeddings. """ class TimestepEmbedSequential(nn.Sequential, TimestepBlock): """ A sequential module that passes timestep embeddings to the children that support it as an extra input. """ def forward(self, x, emb, context=None): for layer in self: if isinstance(layer, TimestepBlock): x = layer(x, emb) elif isinstance(layer, SpatialTransformer): x = layer(x, context) else: x = layer(x) return x 这段代码包含两个 PyTorch 类，它们分别是 TimestepBlock 和 TimestepEmbedSequential。这些类继承了 PyTorch 的 nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/627a3bc983158245d925c382ce9b3035/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e9acfa548b45406078e3f4684974bb/" rel="bookmark">
			入职第一天：先用Git管好你的代码！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文并非面向完全的 Git 初学者，也不会详细介绍每一个 Git 命令和它的所有选项。相反，本文的目标读者是那些已经有一些基础，至少知道如何在本地仓库进行基本的版本控制操作，包括 git add，git commit 和 git log，但是还没有在企业环境中真正使用 Git 进行过项目开发的开发者们。
本文的目标是提供一种顺畅的过渡，帮助你更深入地理解如何在实际的项目开发中使用 Git，以及如何利用 Git 进行高效的团队协作。
提交规范 记住，每个提交都应该是有意义的更改，应附带明确的提交信息。这不仅可以帮助你回溯和理解每次更改的目的，而且还能帮助团队其他成员更好地理解你的更改。在提交规范中，你可以添加更多关于提交信息格式的建议，比如推荐的提交信息格式是：&lt;type&gt;: &lt;subject&gt;，这里的type可以是以下几种：
feat：新功能fix：修复bugdocs：文档改变style：代码格式改变（比如删除空格、格式化）refactor：某个已有功能重构perf：性能优化test：增加测试chore：构建过程或辅助工具的变动 subject则是对提交内容的简短描述。
分支管理 分支是 Git 中的核心概念，是实现并行开发和团队合作的重要工具。在这个章节中，本文会详细介绍如何在实际项目开发中高效使用分支。
开发流程 在一个典型的开发流程中，我们通常会有一个主分支（例如 master 或 main），一个开发分支（例如 develop），以及针对特定功能或修复的特性分支（例如 feature/your_feature 或 fix/your_fix）。
主分支通常包含了最新发布的或即将发布的代码，开发分支包含了正在开发的代码，而特性分支则是从开发分支切出来的，用于开发新功能或修复bug。
当新功能或修复完成后，我们会将特性分支合并回开发分支，然后在需要发布新版本时，我们会将开发分支合并到主分支，并打上相应的版本标签。
创建并切换分支 创建并切换到新的分支，我们可以使用 git checkout -b 命令：
git checkout -b new_branch 合并分支 要将一个分支的更改合并到当前分支，我们可以使用 git merge 命令：
git merge other_branch 请注意，合并前通常需要切换到目标分支，例如将开发分支合并到主分支：
git checkout master git merge develop 分支的推送和删除 在你完成了特性分支上的工作后，你可以将其推送到远程仓库，并在确认无误后删除它：
git push origin feature_branch git branch -d feature_branch 示例流程 以下是一种典型的分支管理示例流程：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49e9acfa548b45406078e3f4684974bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7d4079cbefd143b2b158ba8df2ef5b7/" rel="bookmark">
			Zabbix监控系统及安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zabbix监控系统系统及安装部署 一、Zabbix的概念二、zabbix 监控原理三、zabbix的综合对比四、Zabbix 6.0 新特性Ⅰ、Zabbix server高可用防止硬件故障或计划维护期的停机：Ⅱ、Zabbix 6.0 LTS新增Kubernetes监控功能，可以在Kubernetes系统从多个维度采集指标： 五、Zabbix 6.0 功能组件六、Zabbix 6.0 部署Ⅰ、部署 zabbix 服务端Ⅱ、部署 Nginx + PHP 环境并测试Ⅲ、部署数据库（要求 MySQL 5.7 或 Mariadb 10.5 及以上版本）Ⅳ、编译安装 zabbix Server 服务端Ⅴ、部署 Web 前端，进行访问Ⅵ、安装 zabbix 客户端，实现 zabbix 服务端自我监控Ⅶ、解决 zabbix-server Web页面中文乱码问题 七、添加zabbix客户机Ⅰ、在 Web 页面中添加 agent 主机 八 、自定义监控内容在 Web 页面创建自定义监控项模板Ⅰ、创建模板Ⅱ、创建监控项Ⅲ、创建触发器Ⅳ、创建图形Ⅴ、将主机与模板关联起来Ⅶ、设置邮件报警 九、zabbix 自动注册Ⅰ、zabbix 自动发现 作为一个运维，需要会使用监控系统查看服务器系统性能、应用服务状态和网站流量指标等，利用监控系统的数据去了解网站上线发布的结果和健康状态。 利用一个优秀的监控软件，我们可以:
●1、通过一个友好的界面进行浏览整个网站所有的服务器状态
●2、可以在 Web 前端方便的查看监控数据
●3、可以回溯寻找事故发生时系统的问题和报警情况
一、Zabbix的概念 Zabbix是什么？
zabbix 是一个基于 Web 界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。zabbix 能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。zabbix 由 2 部分构成，zabbix server 与可选组件 zabbix agent。通过 C/S 模式采集数据，通过 B/S 模式在 Web 端展示和配置。zabbix server 可以通过 zabbix agent，SNMP协议，端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能，它可以运行在 Linux 等平台上。zabbix agent 需要安装在被监视的目标服务器上，它主要完成对硬件信息或与操作系统有关的内存，CPU 等信息的收集。 二、zabbix 监控原理 zabbix agent 安装在被监控的主机上，zabbix agent 负责定期收集客户端本地各项数据，并发送至 zabbix server 端zabbix server 收到数据后， 将数据存储到数据库中，用户基于 Zabbix Web 可以看到数据在前端展现图像。当 zabbix 监控某个具体的项目， 该项目会设置一个触发器阈值， 当被监控的指标超过该触发器设定的阈值，会进行一些必要的动作，动作包括：发送信息（邮件、微信、短信）、发送命令（shell 命令、reboot、restart、 install 等）。 三、zabbix的综合对比 监控系统发行时间开发语言性能社区支持容器支持企业使用部署难度Prometheus2016go支持万为单位相对不如zabbix，但人数与日俱增不仅支持swarm原生集群，还支持Kubernetes容器集群的监控，是目前容器监控最好的解决方案基本上使用Kubernetes与容器的企业，prometheus是最好的选择只有一个核心server组件，一条命令便可以启动Zabbix2012c+php上限约10000节点应用广泛，支持较成熟，遇到的问题都能搜到zabbix出现的比较早，当时容器还没有诞生，自然对容器的支持也比较差（在6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7d4079cbefd143b2b158ba8df2ef5b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40a843b44caae4525ad6e6819a78a938/" rel="bookmark">
			Fuzz_AFL学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fuzz what：从维基百科上看，模糊处理是对代码库或可执行文件的自动输入测试。在摸索过程中，无效或意外（有时是随机）的数据被提供给可执行文件，希望能找到一些未定义的行为，或漏洞。why： 模糊测试对于以下方面很有价值： 从不受信任的来源接收输入的软件（安全性）;理智性检查两个复杂算法的等价性（正确性）;验证接受复杂输入的大容量 API 的稳定性（稳定性）， 例如解压缩器，即使所有输入都是可信的。 where： 特定于 C/C++ 的错误，需要清理器捕获： 释放后使用，缓冲区溢出未初始化内存的使用内存泄漏 算术错误： 除以零、整数/浮点数溢出、无效的按位移位 普通崩溃： 空取消引用，未捕获异常 并发错误： 数据竞赛， 死锁 资源使用错误： 内存耗尽、挂起或无限循环、无限递归（堆栈溢出） 逻辑错误： 同一协议的两个实现之间的差异往返一致性错误（例如压缩输入、解压缩、与原始内容进行比较）断言失败 AFL深入学习 fuzz运行中的细节 那模糊测试产生的输入样例呢？
libFuzzer将输入样例作为一个字节数组，并将它的指针与长度传入给接口函数。AFL采用了另一种思路，将之视为文件！
像前面的例子，这个文件就是stdin标准输入，afl-fuzzer把标准输入重定向到其产生的测试样例，这样在程序中scanf/cin就相当于在利用测试样例了。
另外如果有其他需要？譬如读取的是二进制格式的输入而非终端字符。
办法之一就是使用C标准库的freopen函数将标准输入以二进制文件的形式打开，然后使用fread等函数对之进行读取。
另一个办法就是在命令行的--后程序参数中加一个@@，这是一个占位符，AFL发现这个占位符就不会把测试样例重定向给stdin，转而将值保存为一个磁盘文件，然后在main函数中，@@占位符对应的argv就是该文件的路径字符串，读取之即可。
在Fuzzing共享库时，可能需要编写一个简单demo，将输入传递给要Fuzzing的库（其实大多数项目中都自带了类似的demo）。这种情况下，可以通过设置LD_LIBRARY_PATH让程序加载经过AFL插桩的.so文件，不过最简单的方法是静态构建
libFuzzer将整个被测对象视为一个函数接口，每次测试视为循环体中对函数的一次调用。但是AFL不然，他将被测对象看作一个可执行程序，每次测试视为对程序的一次调用，自然也会在新的进程环境中。
一次Fuzzing过程通常会持续很长时间，如果这期间运行afl-fuzz实例的终端终端被意外关闭了，那么Fuzzing也会被中断。而通过在screen session中启动每个实例，可以方便的连接和断开。
afl-fuzz并行Fuzzing，一般的做法是通过-M参数指定一个主Fuzzer(Master Fuzzer)、通过-S参数指定多个从Fuzzer(Slave Fuzzer)
多系统并行的基本工作原理类似于单系统并行中描述的机制，你需要一个简单的脚本来完成两件事。在本地系统上，压缩每个fuzzer实例目录中queue下的文件，通过SSH分发到其他机器上解压。
种子库要求与原则 (1) 有效的输入
尽管有时候无效输入会产生bug和崩溃，但有效输入可以更快的找到更多执行路径。
(2) 尽量小的体积
较小的文件会不仅可以减少测试和处理的时间，也能节约更多的内存，AFL给出的建议是最好小于1 KB，但其实可以根据自己测试的程序权衡，这在AFL文档的perf_tips.txt中有具体说明。
种子库修剪
语料库蒸馏（Corpus Distillation）
AFL提供了两个工具来帮助我们完成这部工作——afl-cmin和afl-tmin。
afl-cmin的核心思想是：尝试找到与语料库全集具有相同覆盖范围的最小子集。举个例子：假设有多个文件，都覆盖了相同的代码，那么就丢掉多余的文件。
整体的大小得到了改善，接下来还要对每个文件进行更细化的处理。afl-tmin缩减文件体积的原理这里就不深究了，有机会会在后面文章中解释，这里只给出使用方法（其实也很简单，有兴趣的朋友可以自己搜一搜）。
afl-tmin有两种工作模式，instrumented mode和crash mode。
处理测试结果 确定造成这些crashes的bug是否可以利用，怎么利用
crash exploration mode：这是afl-fuzz的一种运行模式，也称为peruvian rabbit mode，用于确定bug的可利用性
triage_crashes：AFL源码的experimental目录中有一个名为triage_crashes.sh的脚本，可以帮助我们触发收集到的crashes
crashwalk：如果你想得到更细致的crashes分类结果，以及导致crashes的具体原因，那么crashwalk就是不错的选择之一。这个工具基于gdb的exploitable插件，安装也相对简单，在ubuntu上
afl-collec：是afl-utils套件中的一个工具，同样也是基于exploitable来检查crashes的可利用性。它可以自动删除无效的crash样本、删除重复样本以及自动化样本分类。
代码覆盖率 基本块（Basic Block）：缩写为BB，指一组顺序执行的指令，BB中第一条指令被执行后，后续的指令也会被全部执行，每个BB中所有指令的执行次数是相同的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40a843b44caae4525ad6e6819a78a938/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/116/">«</a>
	<span class="pagination__item pagination__item--current">117/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/118/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>