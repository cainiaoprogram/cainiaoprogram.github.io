<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0990daf7786a3579b00a162d08f18f5/" rel="bookmark">
			CVE-2022-31814pfsense远程命令执行漏洞复现与exp利用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、环境搭建
二、漏洞触发点原理分析
三、exp验证
四、攻击流量分析
总结
前言 pfBlockerNG是一个默认未安装的 pfSense 插件，它通常用于阻止来自整个国家或 IP 范围的入站连接。在pfBlockerNG &lt;= 2.1.4_26中发现了一个远程命令执行漏洞（CVE-2022-31814），该漏洞存在于用于记录和查询 DNSBL 数据的文件 /usr/local/www/pfblockerng/www/index.php中，使用 PHP 函数exec()作为查询代码，将不受信任的数据传递到命令中，用户可以构造HTTP请求的HOST字段来触发远程命令执行。
受影响实体
pfSense是一个基于FreeBSD操作系统开发的防火墙和路由器软件；
FreeBSD 是一种类UNIX操作系统；
pfBlockerNG是一个pfSense的插件（默认不安装），提供了广告、恶意内容和地理拦截功能。
受影响版本
pfSense 2.6.0 pfBlockerNG&lt;=2.1.4_26 一、环境搭建 1.从pfSense下载iso 2.6.0版本镜像文件。下载地址：Download pfSense Community Edition
2.新建虚拟机，选择FreeBSDm，添加第二网卡（因为配置防火墙需要两个网卡），导入下载好的镜像文件。
接收协议
之后一路默认，在选择文件系统时，选UFS文件系统格式。
之后一路OK，最后Reboot重启。
3.将WAN口映射到eth0，LAN口映射到eth1,然后根据提示配置IP地址、子网掩码、网关I，IPV6可以不用管。
配置好后LAN口为web访问地址
4.访问web主页，默认登录名密码为：admin/pfsense
5.进入主页，添加pfBlockerNG插件，插件版本只有3.2.0_4,先安装。
漏洞存在的插件版本是2.1.4_26，github上找到相应版本的集合包的zip格式并下载。
下载地址：pfsense/FreeBSD-ports: FreeBSD ports tree with pfSense changes (github.com)
将压缩包中的pfBlockerNG的index.php文件解压，因为漏洞触发点只在该文件中，所以不用全部解压。
6.将index.php上传到防火墙中。上传成功后会返回路径。
7.打开命令行，使新上传的文件覆盖之前的文件
mv /tmp/index.php /usr/local/www/pfblockerng/www/index.php
至此环境部署完毕
二、漏洞触发点原理分析 漏洞触发点：
//index.php // Query DNSBL Alias for Domain List. $query = str_replace('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0990daf7786a3579b00a162d08f18f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dccf7520d84fc258bf6b097076b6f814/" rel="bookmark">
			Linux中.bashrc文件是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The .bashrc file is a script file that’s executed when a user logs in. The file itself contains a series of configurations for the terminal session. This includes setting up or enabling: coloring, completion, shell history, command aliases, and more.
.bashrc文件是用户登录时执行的脚本文件。该文件本身包含终端会话的一系列配置。 这包括设置或启用：着色，完成，shell历史记录，命令别名等。
It is a hidden file and simple ls command won’t show the file.
这是一个隐藏文件 ，简单的ls命令不会显示该文件。
To view hidden files, you can run the below command:
要查看隐藏的文件，可以运行以下命令：
$ ls -a You can see the .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dccf7520d84fc258bf6b097076b6f814/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f86d80d161daea3c135a5ff267a7ec97/" rel="bookmark">
			浅谈MySQL和Oracle的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL和Oracle都是常见的关系型数据库管理系统，它们在功能、性能、适用场景等方面存在一些区别。
mysql和oracle都是关系型数据库，可以应用于各种平台。我们用的oracle的版本是oracle11g ,用的mysql的版本是mysql5.5。mysql最开始是瑞典一个公司开发的，开源的，但是后来被sun公司收购，后来sun又被oracle收购，所以现在可以说mysql属于甲骨文公司了！现在用mysql的公司也有很多，mysql价钱便宜些，处理千万级别的数据不成问题的，并且开源，很友好！
mysql默认端口：3306 默认用户root
oracle默认端口 1521 默认用户system
1. 数据类型：
MySQL和Oracle支持的数据类型不同。MySQL支持的数据类型较少，而Oracle支持更多的数据类型，如LOB、XML、Geospatial等。
2. 性能：
Oracle具有更高的性能和可扩展性，可以支持更大规模、高并发的应用程序。MySQL在小型Web应用和中小型企业中表现良好。
开源与商业许可 MySQL是开源的，可以免费使用和修改，也有商业许可版本提供额外的功能和支持。而Oracle是商业许可的，需要支付费用才能使用。
数据库规模和性能 Oracle是一种高度可扩展的数据库，适用于大型企业级应用程序，可以支持数百个CPU和数百万个事务。MySQL则更适合中小型应用程序，可以支持大约64个CPU和数千个事务。
数据完整性和安全性 Oracle在数据完整性和安全性方面提供了更多的功能和选项，如可自定义的安全策略、数据加密和完整性检查等。MySQL也提供了一些安全功能，但比Oracle较少。
数据库管理工具 Oracle提供了一系列的数据库管理工具，如Oracle Enterprise Manager和SQL Developer等，可以更方便地管理和监控数据库。MySQL则相对较少提供这些工具，需要使用第三方工具或命令行进行管理。
数据库语言和存储引擎 Oracle支持多种数据库语言，如SQL、PL/SQL和Java等，也支持多种存储引擎，如B-tree、Bitmap和哈希等。MySQL则主要使用SQL语言，并支持多种存储引擎，如InnoDB、MyISAM和Memory等。
总的来说，Oracle更适合大型企业级应用程序，提供更多的功能和选项，但需要支付较高的费用。而MySQL则更适合中小型应用程序，提供基本的数据库功能，但可以免费使用或以较低的费用使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/196b853ccd68c514f1ee50e24e48d8b3/" rel="bookmark">
			calHist()-使用OpenCV和C&#43;&#43;计算直方图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		calHist()-使用OpenCV和C++计算直方图 在计算机视觉中，几乎处处都使用直方图。对于阈值计算，我们使用灰度直方图。对于白平衡，我们使用直方图。对于图片中的对象跟踪，比如CamShift技术，我们使用颜色直方图，采用颜色直方图作为特征。
在更抽象的意义上，从梯度直方图形成 HOG 和 SIFT 描述符。
直方图也是一种视觉词袋表示，广泛用于图像搜索引擎和机器学习中。而且，这很可能不是您第一次在研究中看到直方图。
那么，为什么直方图会派上用场呢？
因为直方图描绘了一组数据频率分布。事实证明，查看这些频率分布是开发简单图像处理技术的主要方法…以及真正强大的机器学习算法。
这篇博文将总结图像直方图，以及如何使用 OpenCV 和 C++ 从视频中计算颜色直方图。
1. 什么是直方图 可以将直方图视为显示图像强度分布的图形。X 轴为像素值（通常范围为 0 到 255），Y 轴为图片中的像素数。
这只是查看图像的不同方式。当您查看图像的直方图时，您可能会感觉到图像的对比度、亮度、强度分布等。
今天几乎所有的图像处理软件都包含直方图功能。
2. OpenCV C++实现 2.1 OpenCV 中的 calHist() 函数 cv.calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate]]) 使用calHist函数来实现直方图，参数解析：
1. images:这是`uint8`或`float32`源图像。 1. channels:它是计算直方图的通道索引。如果输入是灰度图像，则值为[0]。要计算彩色图像中蓝色、绿色或红色通道的直方图，请传递[0] 、[1]或[2] 。 1. mask:计算直方图的区域，None表示整幅图像区域 1. histSize:Bin数目，必须用方括号括起来。传递[256]表示全像素范围 1. range:通常是[0,256]; 2.2 代码 #include "opencv2/highgui.hpp" #include "opencv2/imgcodecs.hpp" #include "opencv2/imgproc.hpp" #include &lt;iostream&gt; const int histSize = 256; void drawHistogram(cv::Mat&amp; b_hist,cv::Mat&amp; g_hist,cv::Mat&amp; r_hist) { int hist_w = 512; int hist_h = 400; int bin_w = cvRound((double)hist_w / histSize); cv::Mat histImage(hist_h, hist_w, CV_8UC3, cv::Scalar(0, 0, 0)); cv::normalize(b_hist, b_hist, 0, histImage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/196b853ccd68c514f1ee50e24e48d8b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20178e3988af97a8dd8681a5ac99169f/" rel="bookmark">
			java获取用户ip地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 获取请求IP * 参考：https://www.cnblogs.com/mypath/articles/5239687.html * A同学和B同学在同一局域网内请求接口 https://xxx.com/abc-service/vcode/send 得到的结果（经过了nginx）： * * A同学: * X-Real-IP：1.96.130.81 * X-Forwarded-For： 121.125.171.194, 1.96.130.81 * * B同学: * X-Real-IP：1.96.119.104 * X-Forwarded-For： 121.125.171.194, 1.96.119.104 * * * @param request * @return */ public static String getRequestIpAddress(HttpServletRequest request) { String ipAddress = null; if (org.apache.commons.lang3.StringUtils.isEmpty(ipAddress) || org.apache.commons.lang3.StringUtils.isBlank(ipAddress) || "unknown".equalsIgnoreCase(ipAddress)) ipAddress = request.getHeader("X-Real-IP"); if (org.apache.commons.lang3.StringUtils.isEmpty(ipAddress) || org.apache.commons.lang3.StringUtils.isBlank(ipAddress) || "unknown".equalsIgnoreCase(ipAddress)) ipAddress = request.getHeader("X-Forwarded-For"); // 对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照','分割 if (ipAddress != null &amp;&amp; ipAddress.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20178e3988af97a8dd8681a5ac99169f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24d5f0c501ca4e30f760bbe2fb5363a2/" rel="bookmark">
			springboot集成nacos配置管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档：Nacos Spring Boot 快速开始
个人实践：
Namespace用来区分环境，例如：开发环境、测试环境、生产环境。
Group用来区分不同的应用。
DataId用来区分配置，例如：mysql配置，redis配置，kafka配置。
0、前提：已安装启动nacos。 去控制台创建新的命名空间：
在develop命名空间下，创建新的配置：dataId=mysql，group=yzh-maven
1、引入jar包 &lt;!-- https://mvnrepository.com/artifact/com.alibaba.boot/nacos-config-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;nacos-config-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.2.12&lt;/version&gt; &lt;/dependency&gt; 注意：版本 0.2.x.RELEASE 对应的是 Spring Boot 2.x 版本，版本 0.1.x.RELEASE 对应的是 Spring Boot 1.x 版本。 2、application.properties配置 ## nacos配置 # 开启配置预加载功能 nacos.config.bootstrap.enable=true nacos.config.server-addr=127.0.0.1:8848 nacos.config.namespace=56705fdc-7fb8-45bc-80aa-f79c7d94baa5 nacos.config.group=yzh-maven #nacos.config.data-id=mysql nacos.config.data-ids=mysql,redis # 配置文件类型 nacos.config.type=properties # 开启自动刷新 nacos.config.auto-refresh=true 官方配置说明：spring boot 0.2.2 以及 0.1.2版本新功能使用手册 · nacos-group/nacos-spring-boot-project Wiki · GitHub
3、代码使用 @RestController @RequestMapping("/nacos") @Slf4j public class NacosController { /** * 自动刷新 */ @NacosValue(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24d5f0c501ca4e30f760bbe2fb5363a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22849eb9c593b3f9a5ec13853e140a83/" rel="bookmark">
			Chrome浏览器更新字体看不清的最终解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 阿酷TONY / 2023-5-6 / 长沙 / 原创 / 实测解决 参考图片：
Chrome更新至版本Chrome 109.0.5414.120 字体看不清
浏览器症状与表现 Chrome更新至版本Chrome 109.0.5414.120 字体看不清；会很细，在设置中选择自定义的字体，仍无法解决；重新安装chrome浏览器，也不能解决。
人员症状 轻者表现为焦虑、不安、烦燥，茶不思饭不香；重者表现为愁眉苦脸、一心想砸电脑。
原因猜测 似乎是网页不能识别宋体等某些字体，这些字体被一款很细的字体代替，引起看不清。具体原因不详。
我这边遇到这个问题，搞了几天都没有解决。重装谷歌，修改谷歌设置中的字体、字体大小均无法解决。
找到最终的解决方案是：安装windows的KB2670838系统补丁 （我2023-3-30 实测的，有效）。
Chrome 109.0.5414.120 和 Edge 109.0.1518.78 ，此方法均有效。 微软补丁 KB2670838官方下载：
https://www.catalog.update.microsoft.com/Search.aspx?q=KB2670838 MR虚拟直播 MR直播实例(混合现实直播)高品质企业直播企业年会直播来个虚拟舞台场景如何？MR直播(混合现实直播)做一场高品质企业培训MR场景直播-帮助企业高效开展更有意思的员工培训企业多会场视频直播（主会场、分会场直播）实例效果虚拟直播（虚拟场景直播）要怎么做？ 无延迟直播 无延时直播/超低延时直播画面同步性测试（实测组图）搞定企业视频直播：硬件设备、直播网络环境和设备连接说明无延时/无延迟视频直播实例效果案例OBS无延迟视频直播完整教程（组图）毫秒级超低延时直播产品实测（PRTC直播/webRTC直播） 视频加密与安全 企业培训视频如何防止被下载和盗用？在线教育机构视频加密防下载和防盗用的方法有哪些可以借鉴上新：视频加密功能增加防录屏(随机水印)功能两种实现视频倍速播放的方法（视频播放器倍速1.5x/2x）教育培训机构教学课程内容视频加密是如何做的？ 在线导播台 在线导播台（网页导播台）混流效果OBS Studio导播台多画面使用实测软件导播台多画面切换支持多人连麦实测（实测组图） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff9bc9138881d39dbf0361513e913290/" rel="bookmark">
			selenium 元素定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开头 简单介绍selenium的元素定位，主要集中在 xpath中
xpath XML Path Language用于解析html和xml xpath 的缺点比css慢，是从头到尾的便利
常用的表达式
常用在网页端进行测试，在想匹配的地方， 打开控制台，进行匹配测试, 可以先用clear() 清除控制台无用信息
在控制台中 匹配想要的结果并查看,需要写完xpath定位式之后填写回车
匹配最后一个的 xpath 写法：
$x("//div[@class='s_order']/a[last()]") # 匹配列表元素的最后一个 $x("//div[@class='s_order']/a[last()-1]") # 匹配列表元素的倒数第二个 测试例子 # xpath的使用 from lxml import etree html = ''' &lt;div id="container"&gt; &lt;ul class="list"&gt; &lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ''' doc = etree.HTML(html) # 拿到指定的标签下的原代码，因为etree.tostring是拿到brary所以需要decode转为str ul_list = doc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff9bc9138881d39dbf0361513e913290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4f55cc68f2effd28420f15b0afdac9c/" rel="bookmark">
			计算机网络基础（四）—— 什么是TCP/IP协议？是两种网络协议？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 01 | 🍓 概念 \color{red}{概念} 概念🍓02 | 🍊 T C P / I P 分层模型 \color{orange}{TCP/IP分层模型} TCP/IP分层模型🍊03 | 🍋 数据链路层协议 \color{yellow}{数据链路层协议} 数据链路层协议🍋04 | 🍐 网络层协议—— A R P / R A R P \color{green}{网络层协议 —— ARP/RARP} 网络层协议——ARP/RARP🍐05 | 🍆 网络层协议—— I C M P 协议 \color{blue}{网络层协议 —— ICMP协议} 网络层协议——ICMP协议🍇06 | 🍧 网络层协议—— I P 协议 \color{cyan}{网络层协议 —— IP协议} 网络层协议——IP协议🍧07 | 🍇 应用层协议 \color{purple}{应用层协议} 应用层协议🍇 字面上的意思，很多人看到会以为TCP/IP协议说的就是两种协议TCP和IP。
它指的确实是这两种协议，但很多时候，他还有另一个说法“TCP/IP协议簇”，指的是利用IP进行通信时所必须用到的协议群的统称，诸如IP、HTTP、FTP等都属于其中的一种协议。
01 | 🍓 概念 \color{red}{概念} 概念🍓 TCP/IP是Internet的核心协议，是互联网中最常用的协议之一，它是一组用于在网络中实现通信的网络协议。它包含了许多重要的特性，主要表现在以下五个方面：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4f55cc68f2effd28420f15b0afdac9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ccad8497602e10af01a15505e0d31c/" rel="bookmark">
			SpringCloud(16) 整合Seata&#43;多数据源&#43;sharding-jdbc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、docker-compose一键部署Seata三、项目整合1、引入依赖2、增加配置文件3、数据源配置4、各个微服务下的resources目录下准备`seata.conf` 四、编写业务代码进行测试1、分库分表a:父服务声明（主业务调用方）b:子服务声明 2、多数据源 五、源码案例Demo 一、前言 本文通过以下环境整合Seata + 多数据源 + sharding-jdbc
spring-boot 2.7.0spring-cloud 2021.0.2spring-cloud-alibaba 2021.0.1.0sharding-jdbc 4.1.1seata-server 1.5.2dynamic-datasource 3.3.2 二、docker-compose一键部署Seata 见 https://gitee.com/zhengqingya/docker-compose
三、项目整合 tips: 详情见文末提供的源码demo
1、引入依赖 &lt;dependencies&gt; &lt;!-- sharding-jdbc --&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.shardingsphere/sharding-jdbc-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;4.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 整合seata --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-transaction-base-seata-at&lt;/artifactId&gt; &lt;version&gt;4.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 动态数据源 --&gt; &lt;!-- https://mvnrepository.com/artifact/com.baomidou/dynamic-datasource-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- seata --&gt; &lt;!-- 最外层父pom.xml中统一管理seata版本 （全局修改版本为1.5.2） --&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-starter-alibaba-seata --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4ccad8497602e10af01a15505e0d31c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73f757f52fcf9d7d9300d9402d78fc63/" rel="bookmark">
			win10自带dll修复以及多种dll修复方法分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修复DLL文件是解决Windows系统中发生的许多问题的重要步骤之一。在Windows 10中，自带了一些工具和功能来修复损坏的DLL文件。本文将讨论Windows 10自带的DLL修复工具以及其他常见的DLL修复方法。
一.Windows 10自带的DLL修复工具 Windows 10自带了许多工具和功能来修复损坏的DLL文件。以下是其中一些工具和功能：
1. System File Checker（SFC）
System File Checker（SFC）是Windows 10自带的一个工具，可以扫描系统文件并尝试修复任何受损的文件。要使用SFC，请按照以下步骤操作：
a. 打开命令提示符（管理员权限）。
b. 输入以下命令并按Enter键：sfc /scannow
c. 等待扫描完成。
d. 如果SFC找到任何受损的文件，它将尝试自动修复它们。
2. Deployment Image Servicing and Management（DISM）
Deployment Image Servicing and Management（DISM）是Windows 10自带的另一个工具，可以扫描系统映像并尝试修复任何受损的文件。要使用DISM，请按照以下步骤操作：
a. 打开命令提示符（管理员权限）。
b. 输入以下命令并按Enter键：dism /online /cleanup-image /restorehealth
c. 等待扫描完成。
d. 如果DISM找到任何受损的文件，它将尝试自动修复它们。
二.其他常见的DLL修复方法 除了Windows 10自带的工具和功能外，还有许多其他常见的DLL修复方法。以下是其中一些方法：
1.使用dll修复软件
直接在百度上搜索电脑修复精灵，进入官方站点下载一个dll修复工具，利用这个dll修复工具直接进行一键修复就可以了，它会根据你电脑系统缺失了哪些dll文件，然后进行相关的修复，如你丢失了dll就会帮你修复dll文件，操作比较简单方便。
DLL修复工具_一键修复所有dll缺失msvcp140.dll丢失的解决方法–电脑修复精灵
2.下载并安装DLL文件
如果您知道缺少的DLL文件的名称和版本号，则可以从Internet上下载它。当您下载DLL文件时，请确保从受信任的网站下载，并且文件与您的操作系统和软件程序版本兼容。下载后，将DLL文件放入正确的文件夹中，并注册它。
3.运行病毒扫描程序
某些DLL文件可能会被病毒或恶意软件感染。在这种情况下，您需要运行病毒扫描程序来清除您的计算机上的任何恶意软件。一旦您的计算机干净了，您可以尝试使用Windows 10自带的DLL修复工具来修复任何受损的文件。
win10自带dll修复，DLL文件是Windows 10系统中不可或缺的组成部分。当它们损坏时，可能会导致许多问题。在本文中，我们讨论了Windows 10自带的DLL修复工具以及其他常见的DLL修复方法。如果您遇到任何DLL相关的问题，请尝试使用这些方法来解决它们。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3389c6784ffb3777e9f25f5fae15ceba/" rel="bookmark">
			打造中国的Web3.0基座，张平院士谈“构建元宇宙及支撑技术“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在近期举办的全球元宇宙大会开幕式上，中国工程院院士、北京邮电大学教授张平出席大会并发表了题为《构建元宇宙及支撑技术》的开场演讲。
演讲中，张平院士分析阐述了理想的元宇宙技术运行状态。他表示，元宇宙需要实现大规模用户持续在线、高沉浸感/高仿真、高效内容生产，去中心化信息存储和认证几个层面共同加持。在对元宇宙的理解方面，张平院士从四个层次和角度进行了精彩解读与探讨，对打造中国的Web3.0基座，也给出了切实的方向讨论。
演讲干货满满，平行云整合张平院士发表过的核心观点与重要信息，为读者提炼编辑，请君阅读！
元宇宙概念和支撑技术 虽然元宇宙可以被视为一种应用，但是背后一定需要技术支撑，张平院士首先讲述了元宇宙的概念以及其支撑技术。
元宇宙可以追溯至《西游记》。这本书中提到了四个能力（千里眼、顺风耳、筋斗云和七十二变）代表人类对未来元宇宙的期待。如今，除了七十二变，其他能力已通过电视、电话和飞机等实现。科技的进步使得未来七十二变也有可能实现。互联网和虚拟现实技术的结合创造了巨大的元宇宙世界。
早期互联网提供了社交和娱乐，为元宇宙奠定了基础。移动互联网和数字技术的发展进一步推动了元宇宙的发展。今天的数字化时代，5G相比4G新增了广泛的接入和可靠的低时延连接，再加上物联网、人工智能、区块链、云计算、大数据、边缘计算等数字技术在经济社会各方面广泛拓展，使得元宇宙的诞生成为水到渠成的事。
元宇宙定义为虚实结合，包含真体、孪体和虚体三种角色的切换、扮演和替换。真体是现实世界物体，孪体是数字化的孪生体，虚体是独立创造的物体。以《西游记》为例，孙大圣是真体，他的孪体是由毫毛创造的，虚体是他变化而成的任意人物。元宇宙包括现实和虚拟世界，后者又分为镜像世界和拟像世界。真体、孪体和虚体之间有三种转换：真体与孪体切换、孪体与虚体替换，以及真体与虚体扮演。这些转换形成了虚拟社会经济系统的商业价值。
在实际运行中，理想的元宇宙技术状态需要实现大规模用户持续在线、高度沉浸感、高仿真度以及高效内容生产，此外还需要去中心化的信息存储和认证等技术支持。
元宇宙催生了现实与虚拟世界的融合，成为人类文明进化的关键时刻。这种前所未有的连接方式将彻底改变人类的生存方式，带来深远的影响。元宇宙的出现将重塑世界的发展规律，对普世价值体系带来巨大冲击。因此，元宇宙不仅关系到国家安全和经济繁荣，也对社会进步具有重要意义。它将引领世界发展趋势，产生广泛而深远的影响。
元宇宙将改变国际合作和竞争的范式，催生新型国际政治意识形态，对经济和国家安全有重大影响。我们需确保元宇宙意识形态与国家安全，并掌握话语权和标准制定权。元宇宙带来进步，但也潜藏风险，可能成为人类依赖的虚拟陷阱。在经济方面，元宇宙以网络为基础，整合交互、数字孪生、人工智能、区块链等技术构建新型社会经济系统。
根据图示，分布式经济阶段与以往不同，不再分离实体制造与知识产权，线上支付与线下支付。相反，在这个阶段，数字资本与虚拟共创将融合。因此，元宇宙将促进实体经济与数字经济的深度融合，推动数字经济进入新的阶段。
目前国外已形成元宇宙产业生态，包括数字化基础设施、元宇宙应用的技术基座、可信虚拟支付与金融支持等。元宇宙基础设施经历巨大变化，从传统互联网的一维信息到Web3.0、脑机接口和自主智能体的三维全景空间。元宇宙提供更沉浸、交互的体验。理想的元宇宙应具有大规模在线用户、高沉浸感、高仿真、高效内容生产，以及去中心化信息存储和认证。这些技术共同构成元宇宙的技术基座。
关于Web3.0，以及Web3.0与元宇宙的关系 Web3.0也是当前备受瞩目的话题，沉浸式是未来的互联网的趋势所向。
互联网的发展，历经三个过程：Web1.0时期是把电视、电话等初级手段获取信息变成了通过网络获得任何知识。Web1.0是一个中心化的阅读式互联网，包括了谷歌、雅虎、新浪等公司。到了Web2.0中心化的双向可写可读的互联网，技术发生进步，移动互联网大幅度发展，任何人都能与我们相连。Web2.0的出现使得Web1.0的商业模式不复存在，变为阿里和其它的商务模式。而Web3.0则是一个去中心化可信价值的互联网，在这里，除非Web2.0的受益者发生转变或对自身进行变革，否则Web3.0的技术发展趋势必将催生新的模式。Web3.0或许会是一个去中心化的网络生态，大家都是扁平化，互联网中每个人的价值都会产生巨大的变化。
Web3.0是构建元宇宙的底层网络架构，实现去中心化、可信和安全的互联网。它赋予用户掌握身份数据和实现经济价值的能力。Web3.0打破平台垄断，促进自下而上的创新，创造新业务模式和市场，推动全球数字经济系统的发展。
元宇宙是在Web3.0基础上的终极应用生态系统，可信地承载个人的社交身份、资产和资源，支撑虚拟社会经济体。Web3.0的技术特征与元宇宙的生态需求相匹配。元宇宙将与Web3.0相互融合，实现虚拟和现实的交融，跨越大平台中心生态的鸿沟，开创富有想象力和创造力的元宇宙系统。
Web3.0技术构建了一个三维沉浸式的信息空间，与一维信息和二维图像音视频不同。沉浸式体验将得到支撑，包括交互媒介（如AR、VR、脑机接口、自主智能体）、通信网络（如5G、6G）和算力算法（如云计算、区块链、算力网络、隐私计算、跨链计算）。这些技术将推动元宇宙的发展，重塑人们的体验和互动方式。
我国发展元宇宙面临的问题 元宇宙代表着一种主流的互联网经济体验模式，预计很快能形成产业生态，是一个增量市场。
国内元宇宙目前还处于初级发展阶段，亟须从顶层设计上进行整体性规划，是继续“借船出海”还是自主构建核心技术体系，是我们必须做出回答的战略问题。从基础设施上看，网络的可控性是国家的战略目标。对此，我国需要进行以下几个方面的研究：
构建数据驱动的数字经济技术 数据所有权与访问权的概念受到挑战，重要的是能够控制和使用数据，而不仅仅是拥有数据。
构建分布式扁平化元宇宙经济 通过多个平等的主体协同构建分布式经济，通过激励机制和治理规则进行社会分工和数据分享，实现良性的协同机制。目标是打破网络资源垄断，构建实体与虚拟的深度融合。Web3.0和区块链技术为元宇宙提供支付和结算系统。
构建元宇宙经济数字支付体系 解决数字人民币无法在区块链流通的问题，数字人民币上链可能是解决方案，但需要克服技术难题。
构建我国数字经济双循环格局 强化数据和算力等生产要素，构建中国自主可控的元宇宙技术标准体系，推动数字经济双循环，确保安全共享数据价值。
构建安全可控的Web3.0元宇宙基础设施需要考虑政治、经济、科技和网络安全四个层面。政治上要维护国家意识形态和价值主张；经济上要推动数字经济产业发展；科技上要掌握核心技术和话语权；网络安全上要保障国家和网络空间的安全。中国应引领元宇宙科技发展，打造自主可控的基础设施和生态环境。
打造中国版本的Web3.0基座 我国需要加快建设自主可控的Web3.0技术体系，相比于可信Web3.0技术，我们需要搭建许可Web3.0技术。我国的元宇宙采用同国外一样的体系架构，也包括基础设施、技术基座、许可支付以及典型应用等（见图4）。
在通信网络方面，我国在5G时代取得全球主导地位，并已布局6G网络。在算力算法方面，我国构建的算力网络满足实时计算需求，实现高度协同和系统可控，支持国内外双循环战略。在交互媒介和终端方面，我国在AR/VR和脑机接口技术上处于领先水平，可满足未来元宇宙需求。
钱学森先生对虚拟现实有过展望，提出了“灵境”概念，认为人机深度结合将带来深刻变革。灵境代表智能体和数字孪生的物理世界，构建中国式元宇宙的技术基座是以感、通、算、控一体化的Intelligent-concise为特点。
在可信感知方面，实现全面的泛在环境和人、机、物、灵感知，确保可信、实时的智能感知技术，包括人类五感、脑机接口、机器视觉、自然语言处理等。在可信传输方面，关键是身份认证和传输方案的认证。在算/控方面，研究隐私保护的元宇宙入口设备、联邦学习的空中计算、智能边缘计算、区块链传输、云服务集群和去中心化网络等。6G不仅涵盖了5G的三个核心元素（人类社会、信息空间、物理世界），还包括第四维元素——灵，实现人机物灵的互通，提供实时虚拟业务场景和满足用户需求。
张平，中国工程院院士
张平，中国工程院院士，北京邮电大学教授、博士生导师、网络与交换技术国家重点实验室主任，鹏城实验室宽带通信部主任，中关村泛联移动通信技术创新应用研究院院长，中国电信研究院名誉院长，《通信学报》主编，IEEE Fellow等。长期致力于移动通信理论研究和技术创新，担任IMT- 2020（5G）专家组成员、IMT-2030（6G）推进组咨询委员会委员，先后获国家科学技术进步奖特等奖等多项奖励，为我国自主技术成为国际主流做出了基础性的贡献。目前研究兴趣聚焦在语义通信和语用达意网络。
———————————————————————————
欢迎关注实时云渲染解决方案、Cloud XR技术路线，以及平行云LarkXR解决方案的用户与我们保持紧密沟通和互动，扫码加入平行云社区吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f65a76a2172666cfefef29bbf11efac1/" rel="bookmark">
			【彻底搞懂】vite proxy如何解决跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景描述：本地起了两个服务
前端vue项目跑在http://localhost:5173端口后端接口服务跑在http://localhost:3000端口
前端项目请求后端接口时，浏览器给出了跨域的提示，接口请求失败。下面给出通过配置前端代理解决跨域问题的方法👇🏻 如果你是vite搭建的vue3项目，找到vite.config.ts，添加下面内容：
export default defineConfig({ server: { proxy: { '/api': { target: 'http://localhost:3000', changeOrigin: true, rewrite: (path) =&gt; path.replace(/^\/api/, ''), }, } }, }) 关键的点来了，你的前端发起请求的baseUrl应该是 http://localhost:5173/api
举个例子：前端要请求后端http://localhost:3000/userlist 接口，那么你发起的请求应该是下面的样子：
http://localhost:5173/api/userlist 这样前端就是从相同的host 并且相同的port发起的请求，代理通过前缀"/api"匹配的你要转发的请求，转发到’http://localhost:3000’真正的后端服务，并且把多余的前缀给你替换掉。
关于这个问题，网络上充斥着大量的错误方法，一不小心就会被误导。如果本文帮到了你，就帮忙点个赞吧，有助于让更多的人看到。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f774eedb447e5fd2490f5f59597393d/" rel="bookmark">
			【vue报错】‘vue-cli-service‘ 不是内部或外部命令，也不是可运行的程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从github上面下载了一个项目，在本地执行
但是一直出现这样的错误 vue-cli-service 不是内部命令
&gt; vue-cli-service serve 'vue-cli-service' 不是内部或外部命令，也不是可运行的程序 或批处理文件。 npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! ofd.js@0.2.6 serve: `vue-cli-service serve` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the ofd.js@0.2.6 serve script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm WARN Local package.json exists, but node_modules missing, did you mean to install? npm ERR!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f774eedb447e5fd2490f5f59597393d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eac08ec8166e114b70a5e8d9b38b1f97/" rel="bookmark">
			奶牛竞选 C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在推翻农场主约翰的暴虐统治后，这些奶牛正在进行它们的第一次选举，贝西是N头 (1≤5000）竞选总统的奶牛之一。然而，在大选真正开始之前，贝西想要确定谁最有可能获胜。
选举分为两轮。在第一轮中，获得最多票数的K头奶牛(1≤K≤N)进入第二轮；在第二轮投票中，得票最多的奶牛当选总统。
考虑到奶牛，我希望在第一轮中获得Ai选票(1≤Ai≤1000000000），在第二轮中获得Bi选票 (1≤Bi≤100000000） ( 如果他或她成功了)，确定哪头奶牛有望赢得选举。幸运的是，Ai列表中没 有出现两次计票；同样，Bi列表中也不会出现两次计票。
输入 第1行：两个用空格分隔的整数N和K。
第2~N+1行：第i+1行包含两个用空格分隔的整数Ai和Bi。
输出 预期将赢得选举的奶牛编号。
#include &lt;iostream&gt; using namespace std; #define N 20 //预设最大奶牛数量 //是不是要用malloc分配内存空间 struct cew { int o; //奶牛编号 int a; //第一轮得票数 int b; //第二轮得票数 int level=0; //是否晋级的标志 }; //在定义时就初始化以防内存溢出 {0，0，0，0} int main() { int n=0; //对结构体数组初始化 分配内存防止溢出 cew cews[N]={{0,0,0,0},{0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}}; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eac08ec8166e114b70a5e8d9b38b1f97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/255ba45e1648d3571422ca4cc962e225/" rel="bookmark">
			Ubuntu创建新用户的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组里的服务器是Ubuntu系统，跑实验的话需要远程访问，这样的话需要在服务器上创建一个自己的账户，本文记录一下在Ubuntu系统下创建新用户的过程。（服务器的远程访问一般通过ssh来实现，关于ssh的使用可以参见Ubuntu下的SSH。）
本文主要包含两部分内容：
1. 新建一个用户
2. 允许该用户以管理员身份执行命令（在使用服务器的时候，不建议给予普通用户管理员权限）
注：本文基于Ubuntu系统的主机名为HPZ640-1，用户名为mqk，进行创建与删除的新用户名为tt
1. 创建用户
创建用户有两条命令：adduer和useradd，对应着两条删除用户的命令：deluser和userdel。
这两种命令之间的区别：
adduser：会自动为创建的用户指定主目录、系统shell版本，会在创建时输入用户密码。
useradd：需要使用参数选项指定上述基本设置，如果不使用任何参数，则创建的用户无密码、无主目录、没有指定shell版本。
1.1 adduser
sudo adduser tt [sudo] password for mqk: 正在添加用户"tt"... 正在添加新组"tt" (1006)... 正在添加新用户"tt" (1006) 到组"tt"... 创建主目录"/home/tt"... 正在从"/etc/skel"复制文件... 输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：已成功更新密码 正在改变 tt 的用户信息 请输入新值，或直接敲回车键以使用默认值 全名 []: 房间号码 []: 工作电话 []: 家庭电话 []: 其它 []: 这些信息是否正确？ [Y/n] y 这样在创建用户名时，就创建了用户的主目录以及密码。
默认情况下：
adduser在创建用户时会主动调用 /etc/adduser.conf；
在创建用户主目录时默认在/home下，而且创建为 /home/用户名
如果主目录已经存在，就不再创建，但是此主目录虽然作为新用户的主目录，而且默认登录时会进入这个目录下，但是这个目录并不是属于新用户，当使用userdel删除新用户时，并不会删除这个主目录，因为这个主目录在创建前已经存在且并不属于这个用户。
为用户指定shell版本为：/bin/bash
因此常用参数选项为：
–home： 指定创建主目录的路径，默认是在/home目录下创建用户名同名的目录，这里可以指定；如果主目录同名目录存在，则不再创建，仅在登录时进入主目录。
–quiet： 即只打印警告和错误信息，忽略其他信息。
–debug： 定位错误信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/255ba45e1648d3571422ca4cc962e225/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06045710b42db84684541773f95c8cf4/" rel="bookmark">
			Ubuntu中gnome-terminal的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本使用 gnome-terminal命令用于打开一个新的终端，直接在命令行就可以打开一个新的终端
gnome-terminal 打开后自动最大化
gnome-terminal --maximize 打开后全屏
gnome-terminal --full-screen 设置标题
gnome-terminal --title="new title" 打开多个终端，多个tab
gnome-terminal --window --window #打开两个 gnome-terminal --window --tab --window --tab --tab #打开两个，第一个两个tab，第二个3个tab 设置打开的位置和大小(宽度x高度+左侧偏移量+上方偏移量)
gnome-terminal --geometry=80x25+10+10 指定终端的工作目录
gnome-terminal --working-directory=/home/roo/桌面 终端缩放 –zoom
gnome-terminal --working-directory=/home/roo/桌面 --zoom=2 gnome-terminal --working-directory=/home/roo/桌面 --zoom=1.5 gnome-terminal --working-directory=/home/roo/桌面 --zoom=0.5 启动后自动执行命令 有两个参数可以实现这个功能，-e和-x，这两个区别在于：
-e 可以出现多次，如果在所有--window前面，表示对所有window和tab起作用，如果在--window或者--tab后面，表示只针对这个tab执行，要注意-e后面只能有一个参数，也就是说如果有空格，需要用引号，具体见后例-x 只能出现一次，在-x后面的所有内容，均认为是要执行的命令，所以可以出现空格，这些命令是针对所有tab都执行的 比如：
gnome-terminal -e ls gnome-terminal -x ls 这两个的执行结果都一样，就是新的终端闪一下就没了，有几种办法：
一种是修改terminal的配置，在terminal点右键，选择Profiles-&gt;Profile Preferences，然后找到Title and Command，里面有一项When command exits，后面选择为Hold the terminal open，然后就可以了
第二种是把结果重定向给less，这样less执行完之前，是不会退出的
gnome-terminal -x ls|less 第三种是在bash里面再启用一个bash
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06045710b42db84684541773f95c8cf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ca468433a8f534a604026275d47a659/" rel="bookmark">
			queryWrapper处理一对一，一对多，多对多
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SELECT bu.ID AS id, bu.FULLNAME AS fullName, bu.ID_NUMBER AS idNumber, bu.MOBILE AS Mobile, bu.USER_TYPE AS userType, bc.BANK_CODE AS bankCode, bc.BANK_NAME AS bankName, bc.CARD_NUMBER AS cardNumber, bc.PASSWORD AS password FROM bank_user AS bu LEFT JOIN ( bank_card AS bc ) ON bu.ID = bc.USER_ID WHERE bu.ID = 1 ； 将这段代码换成queryWrapper的写法，结果返回userdetailDTO对象，此对象包含所有查询的字段 是的，定义一个 BankUser 对象时，通常需要在其内部定义一个 BankCard 字段来表示其与 bank_card 表的关联关系。
例如，在 BankUser 类中定义一个 BankCard 对象作为其属性：```java
public class BankUser { private Long id; // 用户 ID private String fullName; // 用户名 // 其他属性.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ca468433a8f534a604026275d47a659/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff70f89af07fc2d1e2ebcc0b45d23170/" rel="bookmark">
			有道云笔记常用快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		F5 同步/刷新
Shift +Alt+D 插入当前时间：
CTRL + B 加粗
CTRL + I 斜体字
CTRL + U 下划线
CTRL + E 删除线
CTRL + D 任务框 CTRL + 1 变成标题1
CTRL + 2 变成标题2
CTRL + 3 变成标题3
CTRL + 4 变成标题4
CTRL + G 高亮块
CTRL + H 加水平线
当前行成无序列表（快捷键：ctrl+L） 当前行成有序列表（快捷键：ctrl+shift+L） CTRL + Q 引用
📖 插入表情
CTRL + AlT + D 插入代码块
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6d91b041ee726409b20aa0b3b4cd31c/" rel="bookmark">
			Docker构建镜像报“invalid diffID for layer xxx”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常信息
在某一台服务器加载过后出现这个问题，应该是某一层的镜像盐值不一致导致的
具体解决
把出现错误的sha256记录一下 sha256:d01a040bd8a04b756bf184076bdeb95ab91a19da3e5803acd2d8f8bd43ce902c 首先先把这个镜像解压出来，找到加载失败的那一层镜像，
重新生成镜像层sha256
将之前错误的加密生成的镜像替换最新加密生成的镜像
sed -i "s/d01a040bd8a04b756bf184076bdeb95ab91a19da3e5803acd2d8f8bd43ce902c/bf49af9d33a667658353b0025d9c3cbfae5f78bd02c834a4f57a8e809fa5a6f8/g" 6c46dffd68d44d6bac77bad58cddb073e56d234535ed00131fffb3ab33a5a69b.json 重新用sha256生成新的镜像id
sha256sum 6c46dffd68d44d6bac77bad58cddb073e56d234535ed00131fffb3ab33a5a69b.json 88ee2ff401d2c6fe395e9cc93b20443550bb028c69df15a4f38a7758884e7244 6c46dffd68d44d6bac77bad58cddb073e56d234535ed00131fffb3ab33a5a69b.json 修改名字
mv 6c46dffd68d44d6bac77bad58cddb073e56d234535ed00131fffb3ab33a5a69b.json 88ee2ff401d2c6fe395e9cc93b20443550bb028c69df15a4f38a7758884e7244.json 替换manifest.json里的重新生成的镜像id
sed -i "s/6c46dffd68d44d6bac77bad58cddb073e56d234535ed00131fffb3ab33a5a69b/88ee2ff401d2c6fe395e9cc93b20443550bb028c69df15a4f38a7758884e7244/g" manifest.json 然后重新打包，构建就可以啦
此时重新打个tag上传harbor可以使用啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c77006a8365b9f9539f36ca50d47b42/" rel="bookmark">
			概率论与数理统计：概率论基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概率论与数理统计是研究随机现象规律性的数学分支。在现实生活中，许多事件的发生都与概率相关，因此掌握概率论和数理统计的知识对于我们正确理解事物具有重要意义。 一、随机试验与样本空间
随机试验是指在相同的条件下，每次试验的结果可能有多种，但每种结果发生的概率是确定的。样本空间是指随机试验中所有可能的结果构成的集合，通常用 Ω 表示。样本点是指样本空间中的每一个元素，它表示试验的一个可能结果。例如，掷一枚硬币是一个随机试验，样本空间是 {正, 反}，两个样本点分别表示硬币出现正面和反面。
二、随机事件及其概率
随机事件是指在样本空间中选取某些样本点的集合，通常用大写字母表示。例如，在掷一枚硬币的随机试验中，事件 A 表示“硬币朝上是正面”，用 A={正} 表示。概率是指随机事件发生的可能性大小，通常用 P(A) 表示。概率的取值范围在 0 到 1 之间，当概率为 0 时表示事件不可能发生，当概率为 1 时表示事件一定会发生。
在概率论中，事件运算满足以下定理：
交换律：对于任意两个事件 A 和 B，A∪B = B∪A 且 A∩B = B∩A。
结合律：对于任意三个事件 A、B 和 C，(A∪B)∪C = A∪(B∪C) 且 (A∩B)∩C = A∩(B∩C)。
分配律：对于任意三个事件 A、B 和 C，A∩(B∪C) = (A∩B)∪(A∩C) 且 A∪(B∩C) = (A∪B)∩(A∪C)。
对偶律：对于任意事件 A，有 A^𝑐（即 A 的补事件）与 S 的差集 S^ 相等，即 A^𝑐 = S^ - A，即“事件 A 不发生”等于“事件 A 的补事件发生”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c77006a8365b9f9539f36ca50d47b42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f3c2d9e946016392d9d993e97a149c4/" rel="bookmark">
			Midjourney进阶教程！7大方向快速生成合心意的AI人物形象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言
由于在工作中，经常会涉及到使用人物素材完成 Banner 设计的工作，于是最近开始探索关于 Midjourney 进行 AI 人物生成的相关测试，同时将这一段时间的经验分享出来。
刚开始接触和使用 Midjourney 的时候，最大的问题在于生成的人物图片无法保证人物位置的大小和视角，想要固定某一种动作，只能通过垫相同动作的图片的这种方式去解决。
后来经过一些了解摄影的朋友，通过他们了解到这些都是可以通过摄影的知识来补充的这方面短板的。
后来我去咨询了 chatgpt，它确实给了我一些很有用的方向。
根据 ChatGPT 的建议，我这里将生成 AI 人物类型图片的方向确定为一下 7 方面：
人物构图的视角选择
人物角度的选择
人物距离的选择
人物表情的选择
人物氛围感的选择
人物服装的选择
人物风格的选择
通过这 7 个方向，我们来进行了实验。
二、人物构图的视角选择
视角可以按照相机相对于被拍摄对象的位置，分为正面、背面和侧面。
当然，拍摄角度不仅限于这三个方向，还可以有更多不同的角度选择，这需要根据被拍摄对象和拍摄需求来选择合适的角度。
测试：不加入关键词的 AI 生成的图片会是什么样子？
生成思路：年轻的女孩
生成咒语：young girl, --ar 16:9
通过随机生成的 8 张来看，由于没有其他关键词的约束，目前随机出来默认的人物形象偏欧美风，人物视角的比例偏差也都保持在了正面和侧面，那么我们现在可以通过增加构图视角的关键词来限定人物呈现的视角。
我们来看看增加不同视角之后的样子吧。
1. 正视角
正视角是指在人像构图时，拍摄对象正对着相机的姿态，使人像呈现出正面的视角。
咒语关键词：Front view
生成思路：正视角的年轻女孩
生成咒语：young girl, front view, --ar 16:9
通过随机生成的图片来看，由于受到正视角关键词的约束，目前随机出来人物都是偏正面的，结果相对来说是较好的，那么我们就继续来看一看其它的视角。
2. 后视角
后视角是指从被摄对象的背后拍摄的视角，也就是以被摄对象的背部为主要构图元素的拍摄方式。
这种视角可以营造出一种神秘或者引人遐想的氛围。
咒语关键词：Back view angle &amp; Back angle
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f3c2d9e946016392d9d993e97a149c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e7bbb480b5d23d27976f4278e386747/" rel="bookmark">
			写PPT的步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写PPT的步骤如下：
确定主题和目标受众：首先需要明确你要展示的主题是什么，以及你的目标受众是谁。这有助于你确定内容和风格。
收集素材：根据主题和目标受众，收集相关的图片、文字、数据等素材。确保素材的质量和准确性。
设计幻灯片布局：选择一个适合主题的幻灯片布局，包括标题页、正文页和结论页等。确保每个页面的设计简洁明了，易于理解。
编写幻灯片内容：根据主题和目标受众，编写幻灯片的内容。注意语言简洁明了，避免使用过于专业的术语或复杂的句子结构。同时，要注重逻辑性和连贯性，确保内容有条理。
添加多媒体元素：在幻灯片中添加图片、视频、音频等多媒体元素，以增强展示效果。但要注意不要过度使用，以免影响幻灯片的整体效果。
调整字体和颜色：选择易读的字体和配色方案，确保幻灯片的整体风格一致。同时，要注意字体大小和行距的设置，以便观众能够轻松阅读。
练习演讲：在制作好幻灯片后，要多次练习演讲，熟悉内容和流程。这样可以提高演讲的效果和自信心。
总之，写PPT需要注意内容的准确性、逻辑性和连贯性，同时也要注重展示效果和视觉效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef7f95cd6d9cb670d42d5a404ddd7a70/" rel="bookmark">
			iOS输入限制表情输入、最大字符、正则过滤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言正文0.工具类1.限制表情包UITextViewUITextField 2.限制最大字符3.过滤特殊字符 前言 平时输入会有输入限制，
1.最大字符数量
2.限制特殊字符：表情包、数字中文、大小写
3.空格换行符等特殊字符
一般的解决办法在输入时或输入完成时（根据业务需要），设置正则过滤就可以。
参考：常用正则表达式(通用字符过滤)
注意，今天说iOS的输入限制，很离谱，以下为一些坑点：
1.明确是需要显示还是直接不允许输入（限制输入打不出来，可以打出来但超过后提示）；
2.边输入边查询还是输入完成后再查询。（这些都是需求定义类的，注意提前划分）；
3.用正则的时候注意连续字符输入；
4.限制表情输入注意九宫格输入时是表情➋➌➍➎➏➐➑➒，所以还得兼容一下九宫格；（很让人费解）
…
正文 0.工具类 MyTextViewAndTextFieldManager
.h
#import &lt;Foundation/Foundation.h&gt; NS_ASSUME_NONNULL_BEGIN @interface MyTextViewAndTextFieldManager : NSObject /** * 判断字符串中是否存在emoji * @param string 字符串 * @return YES(含有表情) */ + (BOOL)stringContainsEmoji:(NSString *)string; //1、首先上判断字符串是否含有表情符号的代码 /** * 判断字符串中是否存在emoji * @param string 字符串 * @return YES(含有表情) */ + (BOOL)hasEmoji:(NSString*)string; //2、然后是去除字符串中的表情 //去除字符串中所带的表情 + (NSString *)disable_emoji:(NSString *)text; //3、由于苹果系统自带的九宫格输入汉字的过程中也会默认是表情符号，因此需要添加判断当前是否是九宫格键盘 /** 判断是不是九宫格 @param string 输入的字符 @return YES(是九宫格拼音键盘) */ +(BOOL)isNineKeyBoard:(NSString *)string; /// textField 最长长度 WithMaxLength:20 + (NSString *)string:(UITextField *)textField WithMaxLength:(CGFloat)maxLength; @end NS_ASSUME_NONNULL_END .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef7f95cd6d9cb670d42d5a404ddd7a70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e440236b889cb1cff46d37b16c49135/" rel="bookmark">
			Qt实现MySQL数据库备份小工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//读取配置类 #ifndef CONFIG_H #define CONFIG_H #include &lt;QObject&gt; #include &lt;QFile&gt; #include &lt;QDebug&gt; #include &lt;QSettings&gt; class Config { public: Config(); ~Config(); public: bool isReady()const {return configHasReady;} QSettings* getSet()const{return sets;} signals: public slots: private: QSettings* sets; //存所有的配置 void init();//初始化 public: volatile bool configHasReady=false;//配置是否就绪 private: }; #endif // CONFIG_H #include "config.h" #include &lt;QDir&gt; Config::Config() { (void)init(); } Config::~Config() { delete sets; sets = nullptr; } void Config::init() { QString iniStr=QDir::currentPath()+"/cfg.ini"; //配置文件初始化 sets = new QSettings(iniStr,QSettings::IniFormat); if(0 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e440236b889cb1cff46d37b16c49135/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1903520d821bb394100e655f4d21d195/" rel="bookmark">
			vue.config.js中的devServer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		真能扯啊。
按照我的经历，我认为学习vue一个障碍和困难，是不容易了解它整个项目结构。*.vue本身的内容较容易掌握，但更大的方面，比如它整个项目的运行机制，路由，配置，就比较讳莫如深了。资料很少，说的人也是不知从哪里抄的，没有说清楚。对于像我这样普通的开发者来说，让我不用啥框架，直接用空白项目捣鼓出一个看得过去的前端，我会感到困难重重，这也不知，那也不懂，无从下手。这其中，就包括这个vue.config.js。
vue.config.js，就是vue项目的配置文件咯。一度传闻vue3创建项目时，默认是不提供这个文件，要用的话只能自己手动创建。但一旦创建，vue又会自动地优先使用其中的配置。这给人一种很扯的感觉。不过，不久前我创建vue3项目，里面是有vue.config.js的。其实，vue也没有什么好神秘的，它就是一个巨大的语法糖，或者解释器。虽然它创建了这样那样的书写结构，但最终是要编译成原始的js。你看vue3的语法，我感觉并不比vue2更高明，反而有种累赘和啰嗦的感觉，估计VUE4还要来个大改，折腾不止，至死方休。
说回vue.config.js。vue.config.js里面，同样有许多神秘的咒语。不过后来逐渐有了一些发现。下面这段代码就摘自我们之前一个vue项目的vue.config.js。
module.exports = { devServer: { port: 8090, // 端口号，如果端口号被占用，会自动加1 host: '0.0.0.0',// 主机名， 127.0.0.1， 真机 0.0.0.0 https: false, //协议 open: false, //启动服务时自动打开浏览器访问 disableHostCheck: true, proxy: { '/api':{ target:PROXY_API_BASE_URL, pathRewrite:{ "^/api":"" } }, '/webapps':{ target:PROXY_BASE_URL, pathRewrite:{ "^/webapps":"/webapps" } }, '/javapubzy':{ target:PROXY_BASE_URL, pathRewrite:{ "^/javapubzy":"/javapubzy" } }, '/arcgis':{ target:PROXY_BASE_URL, pathRewrite:{ "^/arcgis":"/arcgis" } } } }, 。。。 } 代码中，devServer算是系统的保留字，用来配置我们的开发环境，从名字也能看出来。所以，别看它里面写了这么多，又是端口，又是代理，让人一看就头大，其实只是用于我们本机开发和调试。一旦发布和打包，就与它无关了。我们将发布包部署到nginx，端口和转发，就遵循nginx的设置：
http { include mime.types; default_type application/octet-stream;	sendfile on; server { listen 8081; server_name 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1903520d821bb394100e655f4d21d195/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/841281b153dd6db84f1183e887095338/" rel="bookmark">
			GraphHopper调研笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 GraphHopper GraphHopper是一种快速且内存有效的Java导航引擎，默认使用OSM和GTFS数据，也可导入其他的数据源。支持CH（Contraction Hierarchies）、A*、Dijkstra算法。
1、应用介绍 graphhopper有以下几种常见的地图应用：
(1) 把一个GPS点垂直投影到最近的道路上
(2)根据输入的两个GPS点进行路径规划,支持设置起点的离开方向和终点的到达方向
(3)根据一个GPS点和给定的时间范围给出等时圈的点
2、功能介绍 2.1 创建地图 2.1.1 示例代码 ghLoc是OSM格式的地图路径
cachePath是读取OSM地图之后的地图缓存，下次可以直接使用缓存中的地图
static GraphHopper createGraphHopperInstance(String ghLoc,String cachePath) { GraphHopper hopper = new GraphHopper(); // OSM 文件路径 hopper.setOSMFile(ghLoc); // 读取完OSM数据之后会构建路线图，此处配置图的存储路径 hopper.setGraphHopperLocation(cachePath); hopper.setProfiles(new Profile("car").setVehicle("car").setWeighting("fastest").setTurnCosts(false)); hopper.importOrLoad(); return hopper; } 2.2点投影到路上的Node 2.2.1 示例代码 EncodingManager encodingManager = hopper.getEncodingManager(); BooleanEncodedValue accessEnc = encodingManager.getBooleanEncodedValue(VehicleAccess.key("car")); DecimalEncodedValue speedEnc = encodingManager.getDecimalEncodedValue(VehicleSpeed.key("car")); // snap some GPS coordinates to the routing graph and build a query graph FastestWeighting weighting = new FastestWeighting(accessEnc, speedEnc); Snap snap = hopper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/841281b153dd6db84f1183e887095338/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c37c9b206ed613f2b935dc3cd53d836/" rel="bookmark">
			ActivityManagerService和ActivityTaskManagerService详解—Android 12（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上一篇博客ActivityManagerService和ActivityTaskManagerService启动详解—Android 12（一），介绍了SystemServer.starBootstrapServices()中启动AMS和ATMS所做的工作，这一节介绍在SystemServer.startCoreServices()中关于AMS和ATMS设置UsageStateManagerInternal服务来跟踪application使用状态的业务。
目录
1. AMS和ATMS设置UsageStateManagerInternal服务
1.1 AMS.setUsageStatsManager() 1.2 ATMS.setUsageStatsManager() 1.3 UsageStatsManagerInternal 1.4 UsageStatsService
1.4.1 UsageStatsService.onStart()
1.4.2 UsageStatsService的内部类BinderService
1.4.3 UsageStatsService的内部类LocalServicce 2. 创建系统服务的步骤
1. AMS和ATMS设置UsageStateManagerInternal服务 // /frameworks/base/services/java/com/android/server/SystemServer.java public final class SystemServer implements Dumpable { private void startCoreServices(@NonNull TimingsTraceAndSlog t) { // Tracks application usage stats. t.traceBegin("StartUsageService"); mSystemServiceManager.startService(UsageStatsService.class); mActivityManagerService.setUsageStatsManager( LocalServices.getService(UsageStatsManagerInternal.class)); t.traceEnd(); } } 1.1 AMS.setUsageStatsManager() // /frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java public class ActivityManagerService extends IActivityManager.Stub implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback, ActivityManagerGlobalLock { public void setUsageStatsManager(@NonNull UsageStatsManagerInternal usageStatsManager) { mUsageStatsService = usageStatsManager; mActivityTaskManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c37c9b206ed613f2b935dc3cd53d836/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/398dcbbee310ab38b9603953bf080f2d/" rel="bookmark">
			FFmpeg 解码 H264 格式的视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FFmpeg 解码 H264 主要分三个步骤，其一获取解码器，其二向解码器中送入 H264 NALU，其三从解码器中获取解码后的 YUV 等数据。
一、H264 H.264，同时也是 MPEG-4 第十部分，是由 ITU-T 视频编码专家组（VCEG）和 ISO/IEC 动态图像专家组（MPEG）联合组成的联合视频组（JVT，Joint Video Team）提出的高度压缩数字视频编解码器标准。这个标准通常被称之为 H.264/AVC（或者 AVC/H.264 或者 H.264/MPEG-4 AVC 或 MPEG-4/H.264 AVC）而明确的说明它两方面的开发者。
H264 标准各主要部分有 Access Unit delimiter（访问单元分割符），SEI（附加增强信息），primary coded picture（基本图像编码），Redundant Coded Picture（冗余图像编码）。还有 Instantaneous Decoding Refresh（IDR，即时解码刷新）、Hypothetical Reference Decoder（HRD，假想参考解码）、Hypothetical Stream Scheduler（HSS，假想码流调度器）。
特点
1．低码率（Low Bit Rate）：和 MPEG2 和 MPEG4 ASP 等压缩技术相比，在同等图像质量下，采用 H.264 技术压缩后的数据量只有 MPEG2 的 1/8，MPEG4 的 1/3。
2．高质量的图像：H.264 能提供连续、流畅的高质量图像（DVD质量）。
3．容错能力强：H.264 提供了解决在不稳定网络环境下容易发生的丢包等错误的必要工具。
4．网络适应性强：H.264 提供了网络抽象层（Network Abstraction Layer），使得 H.264 的文件能容易地在不同网络上传输（例如互联网、CDMA、GPRS、WCDMA 和 CDMA2000 等）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/398dcbbee310ab38b9603953bf080f2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/408d22a4903a050df92c02de0ce0780b/" rel="bookmark">
			Linux系统调用函数shmget()、shmat()，标准C库函数ftok()（创建共享内存段，创建共享内存段的键，把共享内存段加入当前的进程的地址空间中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 如果，想要深入的学习Linux系统调用中的shmget、shmat函数与标准C库中的ftok函数，还是需要去自己阅读Linux系统中的帮助文档。
具体输入命令：
man 2 shmget/shmat man 3 ftok 即可查阅到完整的资料信息。
shmget 函数 shmget() 是一个Linux系统调用函数，用于创建一个新的共享内存段（segment）或获取一个已存在的共享内存段。这个函数会返回一个整数类型的共享内存标识符（ID），用于在后续的系统调用中引用共享内存段。
函数原型：
//使用此函数，需导入此头文件 #include &lt;sys/ipc.h&gt; #include &lt;sys/shm.h&gt; int shmget(key_t key, size_t size, int shmflg); 参数说明：
key_t key： 一个键值，用于唯一标识一个共享内存段。你可以使用IPC_PRIVATE常量创建一个私有共享内存段，或使用ftok()函数根据文件路径生成一个唯一的键值。size_t size: 共享内存段的大小，以字节为单位。当创建新的共享内存段时，需要指定大小。对于已存在的共享内存段，这个参数可以忽略（设置为0的意思）。int shmflg: 一个标志位集合，用于控制共享内存段的访问权限和创建行为。这个参数通常包括两部分：权限标志（类似文件权限，如0644）和操作标志。操作标志可以是IPC_CREAT（如果共享内存段不存在，则创建一个新的共享内存段，如果共享内存段存在的话，也是使用这个参数，只不过不创建而已）或IPC_EXCL（与IPC_CREAT一起使用，确保共享内存段是新创建的，如果已存在，则返回错误）。 返回值：
成功时，shmget() 返回一个非负整数，表示共享内存段的标识符（ID）。失败时，返回-1，并设置相应的errno。 使用示例：
#include &lt;sys/ipc.h&gt; #include &lt;sys/shm.h&gt; #include &lt;stdio.h&gt; int main() { key_t key = ftok("somefile", 65); // Generate a unique key based on file path int shmid = shmget(key, 1024, 0666 | IPC_CREAT); // Create a new shared memory segment of 1024 bytes if (shmid == -1) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/408d22a4903a050df92c02de0ce0780b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4ca7765b6c98769e4dd6b744b85ea05/" rel="bookmark">
			C#中sort排序相关用法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#中，List.Sort() 不仅为我们提供了默认的排序方法，还为我们提供了4种自定义排序的方法，通过默认排序方法，我们无需重写任何Sort()方法的实现代码，就能对单参数类型的List数据进行单一规则的排序，如果通过对这些方法进行改进我们可以轻松做到对多参数、多规则的复杂排序。
下面通过程序示例介绍四种相关的方法：
1.第一种，sort自带的list排序功能，但是该方法只是适用于单个元素的list。
using System; using System.Text; using System.Linq; using System.Collections; using System.Collections.Generic; class test { static void Main(string[] args) { List&lt;int&gt; list = new List&lt;int&gt;(); list.Add(6); list.Add(4); list.Add(3); list.Add(5); //直接对数字进行排序 list.Sort(); foreach (var item in list) { Console.WriteLine(item); } Console.ReadKey(); } } 对于多元素的list，需要用不同的排序方式对元素进行排序。
未排序：
using System; using System.Text; using System.Linq; using System.Collections; using System.Collections.Generic; class test { static void Main(string[] args) { List&lt;student&gt; stu = new List&lt;student&gt;(); stu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4ca7765b6c98769e4dd6b744b85ea05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0634d87cfb00651948f440ee350b24ad/" rel="bookmark">
			搭建angularjs开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装 nodejs ，下载：https://nodejs.org/zh-cn/download/releases
cmd: node -v npm-v 查看版本检查是否安装成功
在nodejs安装目录下创建2个文件夹node_cache和node_global，并执行一下cmd命令：
npm config set cache "D:\Program Files\nodejs\node_cache"
npm config set prefix "D:\Program Files\nodejs\node_global"
安装express : npm install express -g 设置环境变量：NODE_PATH = D:\Program Files\nodejs\node_global\node_modules
PATH = D:\Program Files\nodejs\node_global
安装cnpm：npm install -g cnpm --registry=https://registry.npm.taobao.org nodejs安装的版本过低，这里可能会报错
2、安装yarn：
cnpm install -g yarn
yarn config set registry https://registry.npm.taobao.org --global #yarn config get registry 查看配置
yarn config set disturl https://npm.taobao.org/dist --global
2、安装 ng： cnpm install -g @angular/cli@15.2.8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0634d87cfb00651948f440ee350b24ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd98ed7f8b1492282bd29a594855d88d/" rel="bookmark">
			万字详细解析Dubbo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Dubbo?
Dubbo是一款高性能的分布式服务框架，它由阿里巴巴开发并开源。Dubbo提供了完整的RPC通信机制，包括服务自动注册与发现、负载均衡、容错等多种功能，它可以帮助我们快速构建分布式服务体系，并满足高可用、高并发的需求。Dubbo广泛应用于各种互联网企业中，如电商、金融、物流等领域。
为什么要使用Dubbo?
使用Dubbo有以下几个优点：
高性能：Dubbo采用了多种技术手段，如网络通讯、序列化、线程模型等优化，保证了高并发场景下的性能表现。多语言支持：Dubbo实现了跨语言的RPC通信机制，支持Java、.NET、Python、Node.js等多种编程语言，便于不同团队之间的协作与整合。高可用性：Dubbo提供了多种容错机制，如重试、熔断、降级等，保证在分布式环境中服务的稳定性。易于扩展：Dubbo支持插件化扩展，可以按需自定义各种功能，例如注册中心、负载均衡、序列化方式等。可视化管理：Dubbo提供了可视化的管理平台Dubbo-Admin，方便监控和管理服务的状态和流量。 综上所述，Dubbo具备高性能、多语言支持、高可用性、易于扩展和可视化管理等特点，是构建分布式服务体系的理想选择。
使用Dubbo背景
使用Dubbo的背景可以从以下几个方面来说明：
分布式系统的兴起：随着互联网技术的快速发展，分布式系统逐渐成为构建大型互联网应用的必然选择。在分布式系统中，服务的数量和复杂度不断增加，如何有效地管理和调用这些服务成为了一个重要问题。高并发场景的需求：互联网应用常常需要应对高并发访问的情况，而传统的单体应用往往无法满足这种需求。因此，采用分布式架构可以将负载均衡和并发处理能力分散到多台服务器上，提高应用的响应能力和可扩展性。服务治理的需求：在分布式系统中，服务的注册、发现、路由、负载均衡、容错等方面都需要进行有效的管理和治理，以保证服务的稳定性和可靠性。而Dubbo正是基于这些需求而设计和开发的，它提供了完整而强大的服务治理功能，帮助用户轻松构建分布式服务体系。 综上所述，使用Dubbo反映了分布式系统和高并发场景下的实际需求，也是为了解决分布式架构中服务治理的问题。
Dubbo提供了哪3个关键功能？
Dubbo提供了以下三个关键功能：
远程调用：Dubbo支持基于Java的远程过程调用（RPC），使得不同进程或者不同机器上的服务可以像调用本地方法一样进行调用。负载均衡：Dubbo提供多种负载均衡策略，例如随机、轮询、最少活跃等。通过负载均衡，Dubbo能够实现请求分发，从而保证服务的高可用和质量。集群容错：Dubbo支持多种集群容错策略，例如失败自动切换、失败快速恢复、失败粘滞等。这些策略可以在服务出现故障时自动切换到备用节点，从而避免因单点故障而导致整个系统崩溃的情况。 Dubbo服务的关键节点有哪些?
Dubbo服务的关键节点包括以下几个：
服务提供者(Provider)：提供具体的服务实现，向注册中心注册服务地址以及提供服务。注册中心(Register)：Dubbo使用注册中心来管理和发现服务提供者。它可以是Zookeeper、Redis等第三方分布式协调框架，也可以是Dubbo自带的简易版注册中心。服务消费者(Consumer)：调用远程服务的客户端，通过注册中心获取可用的服务列表，并选择合适的服务提供者进行调用。监控中心(Monitor)：Dubbo支持将服务调用信息发送到监控中心进行统计和监控。常见的监控中心有Dubbo自带的Monitor、Elasticsearch等。 上述四个节点构成了Dubbo服务的关键组成部分，同时还有负载均衡器、集群容错等辅助组件，共同协作完成服务的调用和治理。
说一下Dubbo服务注册流程?
Dubbo服务注册流程如下：
启动服务提供者(Provider)：Dubbo服务提供者启动时，会将自己提供的服务信息发布到注册中心。注册服务：服务提供者在启动时，会将自己提供的服务信息封装成一个URL对象，并调用注册中心的API将该URL注册到注册中心上。注册中心接收到服务提供者的注册请求后，会将服务提供者的信息保存到自己的本地存储中。发现服务：服务消费者(Consumer)启动时，会向注册中心发起订阅请求，获取当前可用的服务列表。注册中心会返回符合条件的服务提供者列表给服务消费者。选择服务提供者：服务消费者根据负载均衡策略，从服务提供者列表中选择一台服务提供者进行调用。调用服务：服务消费者通过RPC调用选中的服务提供者，完成服务调用。 上述流程是Dubbo服务注册的基本流程，整个过程中涉及到服务提供者、注册中心和服务消费者三个角色的协作。
Dubbo架构的特点？
Dubbo架构的特点主要包括以下几个方面：
面向接口编程：Dubbo采用面向接口编程的方式，服务提供者将自己提供的服务封装成一个接口，服务消费者通过调用该接口来消费服务。分布式服务治理：Dubbo提供了多种分布式服务治理方案，例如负载均衡、集群容错、服务降级、路由等，以保证服务的高度可用。可扩展性：Dubbo支持插件化扩展，可以灵活地定制和扩展各个模块，满足不同应用场景下的需求。高性能：Dubbo底层采用Netty网络通信框架，并使用Hessian、Protobuf等高效序列化协议，以及多种高效的线程池和队列等技术实现高性能的RPC调用。服务治理中心：Dubbo提供了可视化的服务治理中心，可以对服务进行监控、统计和管理，方便运维人员实时掌握服务的运行情况。多语言支持：Dubbo支持Java、Python、Node.js等多种语言，以及多种序列化协议，可以实现跨语言远程调用。 Dubbo的核心配置？用途？
Dubbo的核心配置如下：
dubbo:application：服务应用配置，用于配置当前应用的名称等信息。dubbo:registry：注册中心配置，用于配置注册中心的地址和协议等信息。dubbo:protocol：远程调用协议配置，用于配置服务暴露的协议类型、端口号等信息。dubbo:service：服务提供者配置，用于配置服务接口实现类、超时时间、负载均衡等信息。dubbo:reference：服务消费者配置，用于配置服务消费方的接口类型、超时时间、重试次数等信息。dubbo:monitor：监控中心配置，用于配置监控中心的地址和协议等信息。 以上几个配置项是Dubbo框架的核心配置，也是使用Dubbo进行服务开发的必要配置。它们分别对应了Dubbo的几个关键功能，例如应用管理、服务注册与发现、远程调用协议、服务提供者和消费者等，都是构成Dubbo服务治理体系不可或缺的一部分。
配置优先级规则？
Dubbo的配置优先级规则如下：
方法级别优先：Dubbo的方法级别配置具有最高优先级，如果在dubbo:service或dubbo:reference中同时配置了方法级别和全局级别的属性，以方法级别为准。属性覆盖规则：如果同一个标签内部出现相同的属性，后面的属性会覆盖前面的属性。全局默认值：对于没有配置的属性，Dubbo会使用全局默认值进行填充。可以通过设置系统属性来修改默认值。外部化配置：Dubbo支持将配置外部化到properties、XML等文件中，如果外部化的配置项与内部配置项冲突，则以外部化的配置为准。Java系统属性：Dubbo还支持将配置写入Java系统属性，如果系统属性中存在相应的配置项，则以系统属性中的配置为准。 总体来说，方法级别优先，属性覆盖规则次之，全局默认值再次之，外部化配置和Java系统属性优先级较低。在实际开发中，需要根据具体情况选择合适的配置方式，并注意配置的优先级规则。
如何用代码方式绕过注册中心点对点直连？
在Dubbo中，可以使用点对点直连方式来进行服务调用，绕过注册中心。如果要在代码中实现绕过注册中心点对点直连，需要按照以下步骤进行：
获取服务引用：在代码中获取服务引用时，不再使用Dubbo的注解或XML配置，而是通过代码创建服务引用对象。 ServiceConfig&lt;HelloService&gt; service = new ServiceConfig&lt;HelloService&gt;(); service.setInterface(HelloService.class); service.setRef(new HelloServiceImpl()); 复制代码 设置URL：在创建服务引用对象后，需要设置URL对象，包括协议、IP地址、端口号等信息。 URL url = new URL("dubbo", "localhost", 20880); service.setUrl(url); 复制代码 暴露服务：在设置完URL后，需要将服务暴露出去，使得其他服务消费者能够调用该服务。 service.export(); 复制代码 调用服务：在其他服务消费者中进行服务调用时，也需要通过代码指定直连的服务地址和端口号。 ReferenceConfig&lt;HelloService&gt; reference = new ReferenceConfig&lt;HelloService&gt;(); reference.setInterface(HelloService.class); reference.setUrl("dubbo://localhost:20880"); HelloService helloService = reference.get(); String result = helloService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd98ed7f8b1492282bd29a594855d88d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca65b67932ca75b556300758cb6b339a/" rel="bookmark">
			SpringBoot 如何结合 Liquibase 实现数据库的变更管理?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot 和 Liquibase 结合使用，可以简化数据库变更管理的流程，同时也保证了数据的一致性和可追踪性。本文将深入讲解如何在 Spring Boot 应用中集成 Liquibase，并实现数据库变更管理。
注：本文中使用的示例代码基于 Spring Boot 2.5.0 和 Liquibase 4.3.5 版本。
1. Liquibase 简介 Liquibase 是一个开源的数据库变更管理工具，支持多种数据库（如 MySQL、Oracle、SQL Server 等），可以通过 XML、YAML 或 SQL 格式定义数据库变更脚本。Liquibase 可以自动执行这些脚本，并记录每次变更的信息，以便后续进行回滚或比较数据库状态等操作。
2. 准备工作 2.1 创建 Spring Boot 项目 首先我们需要创建一个新的 Spring Boot 项目，可以使用 Spring Initializr 进行快速初始化，也可以手动创建。这里使用 Spring Initializr。
打开 start.spring.io/ 页面，选择以下选项：
Project：Maven ProjectLanguage：JavaSpring Boot：2.5.0Packaging：JarJava：11 在 Dependencies 选项卡中搜索并添加以下依赖：
Spring WebSpring Data JPAH2 DatabaseLiquibase 完成后点击 Generate 按钮下载项目压缩包并解压到本地。
2.2 配置 Maven 在项目根目录下的 pom.xml 文件中添加 Liquibase 的 Maven 插件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca65b67932ca75b556300758cb6b339a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1556f6b789fe90ba69924481bb07a2a/" rel="bookmark">
			pom非常好用的写法，统一管理springboot有关依赖的版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信大家使用maven的时候，每引用一个依赖都要写一遍版本号，当然这是必要的，现在springboot非常的主流，每个springboot有关的依赖的版本又是一至的
我们大家就不需要重新去再写一遍了，可以引入依赖 spring-boot-dependencies，这样后面所有的有关springboot的依赖都使用的是 spring-boot-depencies的依赖
&lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring-boot-version&gt;2.2.2.RELEASE&lt;/spring-boot-version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot-version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 我们来看看对比，原来的：
使用了spring-boot-dependencies 依赖之后
这样代码看着更加的简洁，后期也更易维护，学到了吗家人们
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1bbaa1e1f49ce1b0fd1c559fa4b7d4f/" rel="bookmark">
			EasyExcel导出大数据文件（100万条）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EasyExcel导出大数据文件（100万条） Java解析、生成Excel比较有名的框架有Apache poi、jxl。但他们都存在一个严重的问题就是非常的耗内存，poi有一套SAX模式的API可以一定程度的解决一些内存溢出的问题，但POI还是有一些缺陷，比如07版Excel解压缩以及解压后存储都是在内存中完成的，内存消耗依然很大。
easyexcel重写了poi对07版Excel的解析，一个3M的excel用POI sax解析依然需要100M左右内存，改用easyexcel可以降低到几M，并且再大的excel也不会出现内存溢出；03版依赖POI的sax模式，在上层做了模型转换的封装，让使用者更加简单方便
根据上图可以看出，easyexcel的读取.xml文件是在磁盘上运行的，这也就意味着对于大数据文件时十分友好的。如果几十万的数据用poi来导出的话，全部的数据先写入内存，然后再写出，内存肯定会写满。作者用Java虚拟机在widows上默认分配的内存大小，用poi导出100万条数据，CPU全程100%，没一会idea就会报Java堆溢出。
所以我们本次使用easyexcel来导出100万条数据，来看一看其效率和时间。
准备 环境：
mybatis-plus
easyexcel
lambok
mysql数据库
首先准备100万条数据，为了方便，我用mybatis-plus循环100万次插入同一条数据数据，（注意：此处要给每一条数据设置唯一不重复的主键，后面优化sql会用到索引）
//插入 @Autowired private ExamItemService examItemService; @Test public void insert() { for (int i = 0; i &lt; 1000000; i++) { ExamItem examItem = new ExamItem(i, 对象其他变量赋值);//可以多设置些属性，方便对比 examItemService.save(examItem); } 这是数据库中的所有100万条数据
一次性导出所有数据 我们先来试一下一次性把100万条数据一次性全部导出到一个excel文件中。
//单次查询，全量导出 @Test public void export() { long beginTime = System.currentTimeMillis(); List&lt;ExamItem&gt; list = examItemService.list(); long overQueryTime = System.currentTimeMillis(); String fileName = "写你自己准备存excel的文件夹路径，要提前创建好，否则会当成文件名放在工程的根目录下" + "一次性全部导出" + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1bbaa1e1f49ce1b0fd1c559fa4b7d4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bf257f2212e6e6ddcfc3b5afb0ed72b/" rel="bookmark">
			前端开发代码规范工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		规范化是前端工程化的一个重要部分。现在，有许多工具能够辅助我们实行代码的规范化,比如你一定知道的 ESLint 和 Prettier。
今天，来聊聊这些工具的工作原理和基本使用，了解它们是如何发挥作用的，以及如何更好地利用这些工具去规范项目的代码。
本文主要聊聊这些工具的作用和基本使用方式，不会有细致的使用步骤和教程，这些内容我希望你能从官方指引中查看。
1. ESlint - 检查你的 JavaScript 代码 让我们先从知名度最高的 ESLint[1] 开始。
1.1. ESLint 及其作用 Lint 是一类专门用于检查代码的工具软件， 也称 linter。ESLint ，即 JavaScript （ECMAScript）代码的检查工具。
正如官网的介绍 —— “Find and fix problems in your JavaScript code”，ESLint 能够辅助查找出你的 JavaScript 代码中的问题，包括：
代码风格问题（styles）。比如，运算符两边的空格、语句末尾的分号。
不好的写法。比如，使用 == 进行比较而不是 ===。
可能存在逻辑问题的代码模式。比如，定义了一个变量，但没有使用到它。
此外，ESLint 还能够帮你自动修复一些简单的问题。
我们将在下一小结学习如何使用 ESLint 检查我们的 JavaScript 代码，并修复其中的一些问题。
1.2. ESLint 快速上手 为了在项目中使用 ESLint，需要先安装它。
# 初始化一个 npm 项目 mkdir eslint-test cd eslint-test npm init -y # 安装 eslint npm init @eslint/config 复制代码 回答一系列问题后，你可以看目录中的配置文件 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bf257f2212e6e6ddcfc3b5afb0ed72b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/662501e29cfb2419275a858030f3a13e/" rel="bookmark">
			ubuntu上安装显卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：下面介绍的方法，都是在组装台式机，系统为ubuntu18.04LTS、ubuntu20.04LTS、ubuntu21.04LTS、ubuntu22.04LTS下亲测可用的！其他版本和平台没有测试！
如果是笔记本电脑，可以参考最下面转载文章。
方法一：使用官方的NVIDIA驱动进行手动安装（稳定、靠谱）
步骤：
1.安装驱动前一定要更新软件列表和安装必要软件、依赖（必须）
sudo apt-get update #更新软件列表 sudo apt-get install g++ sudo apt-get install gcc sudo apt-get install make 2.查看GPU型号（你自己知道显卡型号就不用查了，直接下一步；通用查看显卡型号命令：lspci | grep -i vga）
lspci | grep -i nvidia
3.官网下载对应驱动（必须），下载好之后，注意把nvidia驱动放在英文名文件夹下，比如mkdir driver 新建文件夹“driver”
官方驱动下载地址：官方驱动 | NVIDIAhttps://www.nvidia.cn/Download/index.aspx?lang=cn
4.卸载原有驱动
sudo apt-get remove --purge nvidia* # 或者nvidia-*
5.禁用nouveau(nouveau是通用的驱动程序)（必须）
sudo gedit /etc/modprobe.d/blacklist.conf 或者(blacklist-nouveau.conf)
在打开的blacklist.conf末尾添加如下，保存文本关闭
blacklist nouveau options nouveau modeset=0 在终端输入如下更新，更新结束后重启电脑（必须）
sudo update-initramfs –u
重启后在终端输入如下，没有任何输出表示屏蔽成功
lsmod | grep nouveau
6.安装lightdm，lightdm是显示管理器，主要管理登录界面，ubuntu20.04、21.04、22.04需要自行安装,然后上下键选择lightdm即可
（这一步也可以不安装lightdm，使用ubuntu20.04、21.04、22.04自带的gdm3显示管理器，直观的区别就是gdm3的登陆窗口在显示器正中间，而lightdm登录窗口在偏左边，正常使用没有区别。其他的区别这里不做探究；）
（亲测需要注意的是，如果你有控制多屏显示的需要，gdm3可能更适合你，亲测使用lightdm设置多屏，可能会出现卡屏，死机，无法动弹情况，仅供参考）
sudo apt-get install lightdm
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/662501e29cfb2419275a858030f3a13e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe170f2c30f795a6754c8843cf292f60/" rel="bookmark">
			关于FusionCompute中Ubuntu16.04.5 Server虚拟机安装Nvidia T4 GPU卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境如下：
华为FusionCompute，采用虚拟机GPU直通的方式进行部署4块T4卡，全部资源关联给一台虚拟机；
使用的英伟达驱动版本为：NVIDIA-Linux-x86_64-410.104.run
坑点在于：
虚拟化平台本来是6.3.1版本，得知如需使用T4卡，虚拟化平台需升级到8.0.0；后经过评审流程，最终实施升级到了最新8.0.0；但是
我算法平台测试版本为Ubuntu16.04.1 Desktop，经查，虚拟化版本不支持此操作系统，只支持Windows系统相关操作系统，GPU资源组
关联不了测试虚拟机，此刻心中一万个羊驼奔腾而过；继续联系华为处理，后终于得知，版本Ubuntu16.04.5 Server内部测试过可行，
赶紧和算法厂家进行沟通，得知算法平台也支持之后，又在线对虚拟化平台VRM和CNA平台进行了插件升级，终于Ubuntu16.04.5
Server关联到了GPU资源组；
接下来就是安装驱动了！对了，在安装Ubuntu16.04.5时，记得勾选openssh（自己下openssh安装包，老是安装错误）！
将NVIDIA-Linux-x86_64-410.104.run传入/root下
首先需要禁用nouveau；
1.添加conf 文件：cat /etc/modprobe.d/blacklist-nouveau.conf
blacklist nouveau
options nouveau modeset=0
2. 重新生成 kernel initramfs:
update-initramfs -u
3. 重启：
reboot
接下来安装驱动；
chmod -x NVIDIA-Linux-x86_64-410.104.run
sh NVIDIA-Linux-x86_64-410.104.run
安装错误，提醒缺少GCC，此为离线安装，无法上网；也下载了gcc5.4.0，但是安装时依旧报错，最后干脆将镜像挂载，以下参考大神；
关于ubuntu server装上后没有make gcc等的方法_ubuntu gcc 13_竺蠡的博客-CSDN博客
这里感谢博主解决了一下大问题！
安装gcc、make后！安装nvidia驱动正常！
不容易啊，撒花。。。。结束！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44235bdc07ebb0c70062453d182d5961/" rel="bookmark">
			Pandas DataFrame 列切片的5种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pandas是一个非常有用的数据分析库,如果你掌握了DataFrame的操作,数据处理会事半功倍。本文介绍DataFrame列切片的5种常用方法。
DataFrame就是表格型数据结构,包含行与列。所以列切片就是选择DataFrame中的部分列。我们可以通过方括号`[]`以及`columns`属性完成列切片。
例如,如果你有一个DataFrame:
col1 col2 col3 col4 0 1 4 7 10 1 2 5 8 11 2 3 6 9 12 1.选择单列
df['col1'] col1 0 1 1 2 2 3 2.选择多列
df[['col1', 'col3']] col1 col3 0 1 7 1 2 8 2 3 9 3.按标签选择
df[df.columns[0:2]] col1 col2 0 1 4 1 2 5 2 3 6 4.按位置选择
df[df.columns[1:3]] col2 col3 0 4 7 1 5 8 2 6 9 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44235bdc07ebb0c70062453d182d5961/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cb15da27e539059aafdc3c34ab06fd4/" rel="bookmark">
			运算符详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运算符 运算符1. 算术运算符2. 比较运算符2.1等号运算符2.2 不等于运算符2.3 空运算符2.4 非空运算符2.5 最小值运算符2.6 最大值运算符2.7 BETWEEN AND运算符2.8 IN运算符2.9 NOT IN运算符2.10 LIKE运算符 3. 逻辑运算符3.1逻辑非运算符3.2 逻辑与运算符3.3逻辑或运算符3.4逻辑异或运算符 4.使用正则表达式查询 运算符 1. 算术运算符 算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加（+）、减（-）、乘（*）、除（/）和取模（%）运算。
2. 比较运算符 比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果为假则返回0，其他情况则返回NULL。
比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录。
2.1等号运算符 等号运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回0。在使用等号运算符时，遵循如下规则： 如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。 2.2 不等于运算符 不等于运算符（&lt;&gt;和!=）用于判断两边的数字、字符串或者表达式的值是否不相等，如果不相等则返回1，相等则返回0。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL，或两边都为NULL，则结果为NULL。
此外，还有非符号类型的运算符：
2.3 空运算符 空运算符（IS NULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回1，否则返回0。
#查询commission_pct等于NULL。比较如下的四种写法
SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NULL;
SELECT employee_id,commission_pct FROM employees WHERE commission_pct &lt;=&gt; NULL;
SELECT employee_id,commission_pct FROM employees WHERE ISNULL(commission_pct);
SELECT employee_id,commission_pct FROM employees WHERE commission_pct = NULL;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cb15da27e539059aafdc3c34ab06fd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66b73dec519efc95c2dc4052eceeffde/" rel="bookmark">
			微信小程序使用POST提交数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序 使用POST提交数据，官方API
RequestTask | 微信开放文档
按照API写上去，但是还是无法提交数据，于是断点查看一下：
真机调试出现报错，要将相机调试切换回1.0,有时候可能不同的错误就要切换回2.0至于原理还没去深挖过。今天的目的是快速上架一个小程序，不深入去研究。
神奇的现象就出现了，断点状态下查看数据提交一切正常，也能正常弹出“发送成功”的弹框
但是正常的状态下测试又无法发送成功。
于是在猜问题是否出现在小程序不认这个服务器地址的原因呢？因为小程序对外访问要求非常高，应该是说要求非常多，又要验证域名，又要HTTPS的合法域名等等。
于是设置一下小程序：
把这个不校验XXX前面的勾取消掉
然后登陆小程序后台，设置当时要访问的服务器地址为合法地址：
这个时候，重新运行小程序，就可以发送数据啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb74550c2a28668a77efb7872c80fbaa/" rel="bookmark">
			DDR为什么需要DQS信号？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.原理 DDR(double data rate SDRAM)中的数据是双边沿传输，即在时钟的上升和下降沿都可以采样，它和单边沿传输的SDRAM(即SDR，single data rate SDRAM)的区别如下图，图中的data eye即数据的两次传输之间围成的区域，图(a)为SDR的传输示意图，因为只有一个时钟沿传输数据，所以称为single-edged clocking，图(b)为DDR的传输示意图，因为是两个时钟沿传输数据，所以称为dual-edged clocking。
在SDR中，data eye是由两个同向时钟沿围成的(在图中即为在时钟上升沿，发送端驱动数据)，中间还会有一个反向时钟沿，在该反向时钟沿的时刻(在图中即为下降沿)数据是稳定的，所以该反向时钟沿可以用来在接受端采样数据。简而言之就是每个data eye有两个可用时钟沿，左边的上升沿用于发送端驱动数据，中间的下降沿用于接收端采样数据，而右边的时钟沿就属于下一个data eye了。
而在DDR中，data eye是由紧邻的两个反相时钟沿围成，每个data eye可用的时钟沿个数减半(即只有一个)，这个时钟沿只能用于驱动或采样数据，而无法把两件任务都完成。因此必须引入另一种机制来弥补这一缺陷，这一机制就是DQS(data strobe signal)，它被称为同步时序参考信号( source-synchronous timing reference signal)。
2.DQS的通用方法 下图是读操作的时序图，DQS由DRAM产生并送给controller，DQS和DQ都和clock的边沿对齐(edge aligned)，controller将DQS delay 90°(需要额外的delay电路)，delay后的DQS边沿和DQ的中心对齐(centere-aligned)，可以用来采样稳定的数据。
下图是写操作的时序图，DQS由controller产生并送给DRAM，DQS和clock的边沿对齐(edge aligned)，而DQ和clock是中心对齐的(edge-aligned，也需要额外电路)，DRAM就可以直接用DQS的边沿采样数据。
可以看到，写操作和读操作中的DQS、DQ、clock的关系是不同的，且都需要controller提供额外的电路来保证它们的关系，原因DRAM通常是大规模生产，把额外电路的负担都放到controller一侧，可以降低DRAM的成本。
另外，在高速接口设计中（尤其是DDR这种并行高速接口），要尽量减少信号传输时间的uncertainty（通常由skew和jitter两部分组成），以保证所有数据都能被同时正确采样，这就需要精细的板上布线和复杂的训练(traning)。为了减小时序收敛难度，DDR不是同时将所有DQ线的时序同时进行约束，而是将它们每8个bit为1组，且每一组都有自己的DQS信号。
3.LPDDR5中的DQS LPDDR5中，仿照GDDR引入了高频的数据时钟WCK，和命令时钟CK分开，二者的频率比为1：2或1：4。WCK作为写操作的DQS，额外引入了一个新的端口RDQS作为读操作中的DQS。
RDQS在写操作中用来传输link ECC。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1f97f55650ffea173f9a112147ea089/" rel="bookmark">
			数据挖掘算法基础（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 机器学习算法基础引言分类算法朴素贝叶斯模型决策树模型支持向量机模型逻辑回归模型 聚类算法原型聚类——k-means算法密度聚类——DBSCAN算法层次聚类 模型的评估与选择经验误差与过拟合评估方法留一法交叉验证法自助法 性能度量错误率和精度查准率、查全率和F1ROC和AUC曲线 机器学习算法基础 引言 引入NLP的算法体系，当前的主流算法可以分为两类：
传统的基于统计学的机器学习算法体系。人工神经网络算法体系。
很多机器学习算法经常应用到NLP相关的任务中，例如用朴素贝叶斯、支持向量机、逻辑回归等方法进行文本分类，用k-means方法进行文本聚类等。
近几年，人们对大脑和语言的内在机制了解的越来越多，也能够从更高的层次上观察和认知思维现象，由此形成了一套人工神经网络的算法体系。
本章将介绍机器学习算法和人工神经网络算法的概念、原理和方法。 分类算法 分类算法就是根据对象的特征或属性，将其划分到已有的类别中。比如邮件分类，网页内容分类等。常用的算法如决策树、朴素贝叶斯以及支持向量机SVM等分类算法。
朴素贝叶斯模型 朴素贝叶斯方法是基于贝叶斯定理与特征条件独立假设的分类方法。对于给定的训练集合，首先基于特征条件独立学习输入、输出的联合概率分布；然后基于此模型，对给定的输入x，利用贝叶斯定理求出后验概率最大的输出y。朴素贝叶斯方法简单，学习与预测的效率都很高，是常用的方法。
基本方法如下：
（1）确定特征属性，获取训练样本集合。
（2）计算各类别的先验概率。
（3）计算各类别下各特征属性的条件概率。
（4）计算各类别的后验概率
（5）以后验概率的最大项作为样本所属类别。
决策树模型 决策树算法是一种逼近离散函数值的方法。它是一种典型的分类方法，首先对数据进行处理，利用归纳算法生成可读的规则和决策树，然后使用决策对新数据进行分析。本质上决策树是通过一系列规则对数据进行分类的过程。由于这种决策分支画成图形很像一棵树的枝干，故称为决策树。决策树的生成算法主要有ID3、C4.5和C5.0生成树算法。
决策树是一个树结构，每个非叶节点表示一个特征属性，每个分支边表示这个特征属性在值域上的取值，叶节点存放一个类别。
决策过程：从根节点开始，测试待分类项中相应的特征属性，并按照其值选择输出分支，知道达到叶子节点，将叶子节点存放的类别作为决策结果。
ID3算法生成决策树过程：
（1）从根节点开始，对节点计算所有可能的特征的信息增益，选择信息增益最大的特征作为节点的特征，由该特征的不同值建立子节点；
（2）对子节点递归地调用以上方法，构建决策树；
（3）直到所有特征的信息增益很小或则没有特征可选择为止，最后得到一颗决策树；
信息熵是接收的每条信息中所包含信息的平均量，是不确定性的度量。香农将随机变量X的熵值定义H(X)如下：
信息增益：用来衡量一个属性区分样本的能力。当使用某一个属性作为一颗决策树的根节点时，该属性的信息增益越大，这颗决策树也就越简洁。信息增益是信息熵H的变形，定义如下：
支持向量机模型 支持向量机（SVM）是用来解决分类问题的。作为数据挖掘领域中一项非常重要的任务，分类目前在商业上应用最多。而分类的目的是构造一个分类任务或分类模型，该模型能把数据库中的数据项映射到给定类别中的某一个，从而可以用于预测未知类别。
通俗的说，支持向量机的最终目的是在特征空间中寻找到一个尽可能将两个数据集合分开的超级平面。之所以名字里面加上了前缀“超级”，是因为我们的数据特征空间很有可能是高维度空间，而且我们希望这个超级平面能够尽可能大的将两类数据分开。
支持向量机可以分为线性可分支持向量机（硬间隔支持向量机）和非线性可分支持向量机（软间隔支持向量机）。支持向量机算法已经应用在很多领域，例如文本分类、图像分类、数据挖掘、手写数字识别、行人检测等，且其可应用的领域还远远不止这些。
支持向量机是一种监督学习方法，主要思想是建立一个最优决策超平面，使得该平面的两侧距离该平面最近的两类样本之间的距离最大化，从而对分类问题提供良好的泛化能力。
SVM算法的优点：可用于线性可分，也可用于回归；低泛化误差；推导过程优美，容易理解；计算复杂度低。
SVM算法的缺点：对参数选择比较敏感；原始的SVM只擅长处理二分类问题。
以上的方法只能解决线性可分的问题，遇到线性不可分的问题需要引入核函数，将问题转化的高维空间。
逻辑回归模型 逻辑回归算法常用于数据挖掘、疾病自动诊断、经济预测等领域。逻辑回归算法是一种广义的线性回归方法，其仅在线性回归算法的基础上套用了一个逻辑函数，从而对事件发生的概率进行预测。
逻辑回归算法的步骤如下所示：
加载数据文件。数据预处理，生成多项式特征。由于最简单的二分类问题只有一阶特征，决策边界为一条直线，可以不考虑本步骤。而现实中的样本，往往需要拟合一条曲线来划分数据，即多项式拟合。多边形边界需要将特征转换为多项式，进而更改样本的分布状态，使之能拟合更复杂的边界，例如圆或者其它不规则图形。初始化参数，构建代价函数。
用梯度下降法优化代价函数，确定参数。
构建预测函数，求概率值。根据概率值画决策边界。 聚类算法 聚类算法是无监督学习的典型算法，不需要标签。试图探索和发现一定的模式，用于发现共同的群体，按照内在相似性将数据划分为多个类别使得类内相似性大，类间相似性小。应用场景包括新闻聚类、用户购买模式、图像与基因技术等。
常见的聚类算法包括：
原型聚类：原型聚类亦称为“基于原型的聚类”，此类算法假设聚类结构能通过一组原型刻画，在现实聚类任务中极为常用。密度聚类：密度聚类亦称为“基于密度的聚类”，此类算法假设聚类结构能通过样本分布的紧密程度确定。层次聚类：层次聚类算法试图在不同层次对数据集进行划分，从而形成树形的聚类结构。数据集的划分可采用“自底向上”的聚合策略，也可采用“自顶向下”的分拆策略。 原型聚类——k-means算法 原型聚类亦称为“基于原型的聚类”，此类算法假设聚类结构能通过一组原型刻画，在现实聚类任务中极为常用。通常情形下，算法先对原型进行初始化，然后对原型进行迭代更新求解。采用不同的原型表示、不同的求解方式，将产生不同的算法。下面介绍经典的原型聚类算法k-means也称为k均值法。下面介绍经典的原型聚类算法k-means也称为k均值法。
算法思想就是首先随机确定k个中心点作为聚类中心，然后把各个数据点分配给最邻近的中心点，分配完成后将中心点移动到所表示的聚类的平均中心位置处，然后重复迭代上述步骤，直到分配过程不再产生变化位置。
k-means算法采用距离作为相似性指标，认为簇由靠近的对象组成，因此两个对象的距离越近，则其相似度越高。而不同的距离度量会对聚类的结果产生影响，常见的距离度量如下：
K-means算法流程：
随机选择K个随机的点（称为聚类中心）；对与数据集中的每个数据点，按照距离K个中心点的距离，将其与距离最近的中心点关联起来，与同一中心点关联的所有点聚成一类；计算每一组的均值，将该组所关联的中心点移动到平均值的位置；重复执行2-3步，直至中心点不再变化； 密度聚类——DBSCAN算法 基于密度聚类的方法：
密度聚类假设聚类结构能通过样本的紧密程度确定，同一类别的样本，他们之间是紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。从样本密度出发考虑样本间的可连接性，然后基于可连接样本不断扩展聚类的簇实现聚类的目的。 DBSCAN算法流程：
给定包含 n 个对象的数据集 D ，邻域为 ϵ，密度阈值为 MinPts首先找到所有的核心对象根据 (ϵ,MinPts) 对 n 个对象进行搜索，寻找所有的核心对象，构成核心对象集合。根据上述的核心对象寻找 D 中所有密度相连的样本，构成簇，若上述核心对象已被访问，则剔除出去。重复上述过程，直至核心对象集合为空。 DBSCAN(Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法)：基于一组“邻域”参数 (ϵ,MinPts) 来刻画样本分布的紧密程度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1f97f55650ffea173f9a112147ea089/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f0566dfc72dfc788dcc1e90a43bcaa8/" rel="bookmark">
			iphone死机屏幕没反应？可以用这2种办法解决！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iPhone用的时间长了，难免不会遇到卡屏、死机的情况，如果出现这种状况我们应该怎么办呢，下面小编整理出来了几招解决方法，教大家解决iPhone卡屏、死机的问题。
一、强制重启 如果自己的iPhone一直处于卡屏无法操作，或死机屏幕没反应，可尝试强制重启，但此方法只可解决一部分基础性iOS系统问题。
不同iPhone机型号选择不同的强制重启操作：
全面屏型号（iPhone8及以后）：分别快速按下音量高、低键，再持续按开关键直到iPhone黑屏后看到 Apple 标志，松开所有按键等待iPhone重启即可；
iPhone 7、iPhone 7 Plus等：同时按住顶部（或侧边）按钮和调低音量按钮，直到iPhone黑屏后看到 Apple 标志，松开所有按键等待iPhone重启即可；
设有Home键的型号（iPhone7之前）：同时按住Home键与开关键，直到iPhone黑屏后看到 Apple 标志，松开所有按键等待iPhone重启即可。
二、iOS系统修复 如果是因为升级、降级或其它操作导致iOS系统软件故障，可以借助一些更专业的工具来修复iOS系统问题。
如牛学长苹果手机修复工具，支持一键修复150+iOS设备系统问题，包括黑屏、白苹果、黑屏转圈、不停重启、卡在恢复模式、更新失败、无法开机等系统问题。
操作指引： 第一步：下载打开牛学长苹果手机修复工具，使用USB数据线把你的苹果手机和电脑连接，点击“开始”。
第二步：选择“标准修复”或“深度修复”模式，“标准修复”模式不会清除设备数据，“深度修复”修复成功率更高，但会清除设备数据。
第三步：待软件识别设备后，再点击“下载固件”，下载成功后开始修复。整个修复过程大概10分钟，注意不要断开数据线，等待显示“修复完成”即可。
如果以上的系统修复无法解决iPhone黑屏问题，那么也可能是iPhone出现了硬件故障，包括电池硬件问题，那么是无法修复的。
建议及时送往苹果官方进行检修，可以更好、更全面地解决iPhone出现的硬件故障。
关于iPhone出现的黑屏无法唤醒屏幕，死机无法开机问题，现在你知道怎么解决了吗？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5fbba38a8564ebbe5f229c35de6f299/" rel="bookmark">
			sqli-labs第十五关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*盲注
本关属于时间注入，基于源码分析，闭合字符是单引号。
本关没有错误提示，那么我们只能靠猜测进行注入。这里我直接从源代码中看到了 sql语句
页面无回显，单靠页面无法判断闭合方式，所以得查看源码
根据源码知道是单引号闭合
利用延时注入进行。
uname=admin'and If(ascii(substr(database(),1,1))=115,1,sleep(5))#&amp;passwd=11&amp;submit=Submit
正确的时候可以直接登录，不正确的时候这里会延时 5 秒。
*/
在尝试之后，联合查询和报错注入方式后无果，我们初步判断为盲注
查看根目录下本关的源码：
猜想正确
我们采用延迟盲注（时间注入主要用 if(表达式1，表达式2，表达式3) 函数与sleep() 函数配合使用。if函数原理是当表达式1为True时，返回值为表达式二，否则返回表达式三。）
admin’ and if(length(database()=8),sleep(5),1) #
这句话意思就是 如果条件成立，就停止5秒
输入 admin’ and if(length(database()=8),sleep(5),1) #
看这延迟5秒中，说明猜想数据库8位正确
我们继续猜解库名
admin’ and if(substr(database(),1,1)=‘s’,sleep(5),1#
admin’ and if(substr(database(),2,1)=‘e’,sleep(5),1）#
admin’ and if(substr(database(),3,1)=‘c’,sleep(5),1)#
admin’ and if(substr(database(),4,1)=‘u’,sleep(5),1)#
admin’ and if(substr(database(),5,1)=‘r’,sleep(5),1)#
admin’ and if(substr(database(),6,1)=‘i’,sleep(5),1)#
admin’ and if(substr(database(),7,1)=‘t’,sleep(5),1)#
admin’ and if(substr(database(),8,1)=‘y’,sleep(5),1)#
像这样继续猜解不断尝试
......
如果想进一步得到用户、密码信息，继续不断猜解…
反正盲注很麻烦并且浪费时间！
最后就是猜数据库表和猜数据库了，这里就不在叙述了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4dad02100d14c011fe68b8c885594c8/" rel="bookmark">
			Android 存储目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Context 对象获取目录 1）getExternalFilesDir
说明
方法中的参数为需要在 files 目录下新建的目录名，如果新建的目录不存在，则会创建，反之，不会重复创建。 示例
// args // Environment.DIRECTORY_MUSIC // Environment.DIRECTORY_PODCASTS // Environment.DIRECTORY_RINGTONES // Environment.DIRECTORY_ALARMS // Environment.DIRECTORY_NOTIFICATIONS // Environment.DIRECTORY_PICTURES // Environment.DIRECTORY_MOVIES // Environment.DIRECTORY_DOWNLOADS // Environment.DIRECTORY_DCIM // /storage/emulated/0/Android/data/cn.opensrc.enterpriseopenaccountsdktest/files File filePath1 = getExternalFilesDir(""); // /storage/emulated/0/Android/data/cn.opensrc.enterpriseopenaccountsdktest/files/DCIM File filePath2 = getExternalFilesDir(Environment.DIRECTORY_DCIM); // /storage/sdcard1/Android/data/cn.opensrc.enterpriseopenaccountsdktest/files/self File filePath3 = getExternalFilesDir("self"); 2）getExternalCacheDir 说明
新建 cache 目录。 示例
// /storage/emulated/0/Android/data/cn.opensrc.enterpriseopenaccountsdktest/cacheFile filePath = getExternalCacheDir(); 3）getCacheDir 示例
// /data/data/cn.opensrc.enterpriseopenaccountsdktest/cache File filePath = getCacheDir(); 4）getDir 说明
会新建名为 app_DirName 的目录，其中 app_ 为固定格式。 示例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4dad02100d14c011fe68b8c885594c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abdb380bb2e0bef082745869ef055e5d/" rel="bookmark">
			【标准化方法】(4) Weight Normalization 原理解析、代码复现，附Pytorch代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天和各位分享一下深度学习中常用的归一化方法，权重归一化（Weight Normalization， WN），通过理论解析，用 Pytorch 复现一下代码。
Weight Normalization 的论文地址如下：https://arxiv.org/pdf/1903.10520.pdf
1. 原理解析 权重归一化（Weight Normalization，WN）选择对神经网络的权值向量 W 进行参数重写，参数化权重改善条件最优问题来加速收敛，灵感来自批归一化算法，但是并不像批归一化算法一样依赖于批次大小，不会对梯度增加噪声且计算量很小。权重归一化成功用于 LSTM 和对噪声敏感的模型，如强化学习和生成模型。
对深度学习网络权值 W 进行归一化的操作公式如下：
通过一个 k 维标量 g 和一个向量 V 对权重向量 W 进行解耦合。标量 ，即权重 W 的大小， 表示 v 的欧几里得范数（二范数）。
作者提出对参数 v，g 直接重新参数化然后执行新的随机梯度下降，并且认为通过将权重向量（g）的范数与的方向解耦，加速了随机梯度下降的收敛。
假设代价函数记为 L，此时的深度学习网络权值的梯度计算公式为：
设 ，其中 是投影矩阵。梯度计算可以写成：。
设 ，当梯度噪声大时，c 变大，有 ，则 变小。
当梯度较小时，c 变小趋于0，有 。即：权重归一化 WN 使用这种机制做到梯度稳定。另外，作者也发现 ||v|| 对学习率有很强的鲁棒性。
WN 不像 BN 还具有固定神经网络各层产生的特征尺度的好处，WN 需要小心的参数初始化。给 v 的范数设定一个范围（正态分布均值为零，标准差为 0.05），这样虽然延长了参数更新的时间，但收敛后的测试性能会比较好。
设 ，仅在初始化期间取 可以得到应用 WN 后，
由上式可得，当 WN 进行参数初始化时可以在一开始达到和 BN 相同的作用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abdb380bb2e0bef082745869ef055e5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e089ac71a50681d845f052baf934a3cf/" rel="bookmark">
			CSS-复合选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复合选择器： 交集选择器： 代码： 选中同时符合多个条件的元素，有并且的含义（既…又…）
&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;交集选择器&lt;/title&gt; &lt;style&gt; .rich { color: gold; } .beauty { color: red; } /* p元素且类名为beauty */ p.beauty { color: green; } /* .dream{ color: orange; } */ .rich.beauty { color: orange; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h2 class="rich"&gt;土豪张三&lt;/h2&gt; &lt;h2 class="beauty"&gt;明星李四&lt;/h2&gt; &lt;!-- &lt;h2 class="dream"&gt;土豪明星王五&lt;/h2&gt; --&gt; &lt;h2 class="rich beauty"&gt;土豪明星王五&lt;/h2&gt; &lt;hr&gt; &lt;!-- hr是水平线 --&gt; &lt;p class="beauty"&gt;小狗旺财&lt;/p&gt; &lt;p class="beauty"&gt;小猪佩奇&lt;/p&gt; &lt;/body&gt; 有图有真相： 格式： 选择器1选择器2选择器3…选择器n { }
交集选择器注意点： 有标签名，标签名必须写在前面id选择器，理论上是可以作为交集的条件，但是实际应用几乎不用(#)交集选择器中不可能出现两个元素选择器，不可能即是p元素又是span元素用得最多的交集选择器是：元素选择器配合类名选择器，例如 p.beauty 并集选择器： 代码： &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e089ac71a50681d845f052baf934a3cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a401cc32a8290d6fef3e877be89e216/" rel="bookmark">
			Linux 虚拟化技术 KVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
virt-install 命令创建虚拟机 命令版 半手工
利用 qemu-img命令创建虚拟磁盘
基于已有系统直接创建新的虚拟机启动 复制
​编辑
复制 可以 适用于脚本 可以批量改 内存之类的 克隆没法子改
利用virt-clone克隆实现
半虚拟化设备统一接口virtio
创建 Windows Server 2008 虚拟机
生成Windows Server 2008 镜像模版、
libvirt 架构
快照
#查看虚拟机详细信息
#查看当前启动的虚拟机
#查看所有虚拟机
启动和关闭虚拟机
#列出开机状态虚拟机的UUID和名称
#列出所有虚拟机的UUID和name
查看虚拟机UUID,通过UUID启动关闭虚拟机
暂停和恢复虚拟机
配置虚拟机开机自动启动
磁盘预分配策略
虚拟磁盘类型 qcow2 格式选项
创建raw格式非稀疏文件 创建raw格式稀疏文件
raw文件复制的格式控制 virsh 管理虚拟机快照
使用virsh 命令还原快照 #删除快照 [root@ubuntu2004 isos]#virsh dominfo centos7.0 #查看虚拟机详细信息 Id: - Name: centos7.0 UUID: 266d67e2-8630-4dcf-955d-b0bbb71f9ae6 OS Type: hvm State: shut off CPU(s): 2 Max memory: 1048576 KiB Used memory: 1048576 KiB Persistent: yes Autostart: disable Managed save: no Security model: apparmor Security DOI: 0 apt update
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a401cc32a8290d6fef3e877be89e216/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/137/">«</a>
	<span class="pagination__item pagination__item--current">138/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/139/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>