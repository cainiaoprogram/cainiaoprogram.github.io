<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11ba6a3c0584960cdb0ee89985b4dd0f/" rel="bookmark">
			linux系统中如何验证网络端口通不通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux系统中如何验证网络端口通不通 前言相关命令详解telnet命令具体的用法端口不通的时候：端口开启的时候:telnet 测试端口连通之后,还有惊喜如何退出 telnet命令第一种方法第二种方法 nc命令具体用法端口不通的时候:端口开启的时候:nc命令连通端口之后也是具备可以发送和接收信息的功能如何退出nc命令nc命令很强大 命令很强大但是有可能受环境限制为了适应环境,功能简配深处逆境,总有办法绝处逢生端口不通的时候端口正常的时候 简单介绍一下 netstat 命令netstat 命令参数介绍netstat 状态介绍服务器的监听状态:TCP连接时候的三次握手状态时候的TCP连接成功的状态TCP断开连接四次挥手时候的状态 前言 我们在linux系统网络调试中经常会遇到需要测试验证对应的端口是否正常的场景,接下来讲解一下常用的方法。
相关命令详解 telnet命令 具体的用法 telnet serverIP port
注意事项是 serverIP和port之间需要用空格分开
具体的操作:
端口不通的时候： ggd@ubuntu:~$ telnet 192.168.70.1 20 Trying 192.168.70.1... telnet: Unable to connect to remote host: Connection refused ggd@ubuntu:~$ 端口开启的时候: ggd@ubuntu:~$ telnet 192.168.70.1 8080 Trying 192.168.70.1... Connected to 192.168.70.1. Escape character is '^]'. 需要注意的是**Connected to 192.168.70.1.表示对应的端口是通的**
telnet 测试端口连通之后,还有惊喜 大家通过上图可以了解,当通过telnet命令连通对应的端口之后，可以通过终端给对应的服务器发送消息,另外同时也可以接收服务器发送的消息
如何退出 telnet命令 大家在测试端口的时候如果对应的端口连通之后,此时该命令处于阻塞状态,不知道该怎么退出
第一种方法 先按 ctrl + ] 然后再按 ctrl + D 第二种方法 先按 ctrl + ] 然后再输入quit nc命令 具体用法 nc -v serverIP port
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11ba6a3c0584960cdb0ee89985b4dd0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b400881e5879222eecc3fe084f74b5f/" rel="bookmark">
			MATLAB编程测试传递函数的响应曲线（系统辨识第一篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 S域传递函数
50 Y(S) G(S) = exp(-100*s) * ---------- = ----- 1000 s + 1 X(S) 通过MATLAB编程生成动态响应曲线，这里的采样周期设为1s，便与后期辨识工业现场被控对象。
这里涉及到《自动控制原理》知识点，S变换、Z变换、差分方程等。
将S域传递函数离散化
0.04998 y(z) g(z) = z^(-100) * --------- = ----- z - 0.999 x(z) 方程分子分母同时除以z
0.04998 y(z) g(z) = z^(-101) * --------------- = ----- 1 - 0.999z^(-1) x(z) 将上述方程十字相乘
y(z) - 0.999y(z)z^(-1) = 0.04998x(z) z^(-101) 改写成
y(t) - 0.999y(t-1) = 0.04998x(t-101) y(t) = 0.999y(t-1) + 0.04998x(t-101) clear all;close all;clc; sys=tf([0 50],[1000,1],'inputdelay',100); % ts 为采样时间常数 ts = 1; dsys=c2d(sys,ts,'zoh'); % num 为分子系数，den 为分母系数 [num,den]=tfdata(dsys,'v'); % tdelay 为滞后时间常数 tdelay = 101; for m=1:tdelay y(m)=0; end x=linspace(1, 1, 10000); for n=102:1:10000 y(n)=-den(2)*y(n - 1)+num(2)*x(n-101); end figure(1) plot(y) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c080c232261ccf4cdfeb99b060d58b82/" rel="bookmark">
			linux记事本之redhat9安装jdk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		警告:用于虚拟机下学习，操作前请备份快照！！！
1.打开linux自带浏览器，下载jdk，按照版本我直接下载x64.tar.gz的包，用的是root用户登入的，下载路径/root/下载。（注:下载jdk需要注册oracle用户）
链接:https://www.oracle.com/java/technologies/downloads/#java8
2.打开终端，检测一下系统是否有自带的Java，输入:java -version
3.我的系统自带一个“11.0.16.1”的版本，需要卸载。
4.找出安转包，输入:rpm -qa 丨grep java
5.先用的rpm卸载，失败了，有依赖关系
6.用yum卸载，输入:yum remove 包全名 ，需要交互一下，按y回车，卸载成功。
7.输入:java -version 检查一下，卸载成功。
8.拷贝/root/下载里的包到/opt（opt是optional的缩写，是“可选”的意思，是给主机额外安装软件所摆放的目录，用来安装附加软件包，是用户级的程序目录，例如任何外部或第三方软件。）
9.拷贝完成查看一下
10.直接解压软件包
11.解压完成，查看一下，进入到解压后的目录，pwd显示当前路径，复制路径
12.修改配置文件，cd进入到/etc目录，输入:vim profile
13.进入到profile文件，定位到最后按i，进入编辑模式，输入（路径不同只能参考）:
JAVA_HOME=/opt/jdk1.8.0_351
PATH=$JAVA_HOME/bin:$PATH
CLASSPATH=$JAVA_HOME/lib:.
export JAVA_HOME PATH CLASSPATH
14.按esc 回到命令模式 按 :wq 保存退出（注意:是输入 冒号wq）
15.输入: source profile 重新加载一下配置文件，查看一下是否安装成功
16.创建一个HelloWorld测试一下，去我的家下创建一个HelloWorld.java文件，注意区分大小写
创建编辑HelloWorld.java:
vim HelloWorld.java
public class HelloWorld{
public static void main(String[] args){
System.out.println("Hello,你好");
}
}
编译:
javac HelloWorld.java
运行:
java HolleWorld
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11dcdeb463acd6c12abba2684cf1444b/" rel="bookmark">
			Centos 安装，配置和管理DNS服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 DNS相关知识
1.1 DNS服务器是什么？ Domain Name System，即域名系统，实质上是一个分布式数据库，其中存储了域名和IP地址之间的映射关系
1.2 DNS作用是？
在用TCP/IP协议架设的网络中，每一个节点都有唯一的IP地址，用来作为唯一的标志。然而记住这些毫无记忆规律的IP地址是不可能的。为了方便记忆，产生了域名系统DNS，运行在TCP协议之上。负责将域名转换成实际相对应的IP地址，这个过程称为域名解析
1.3 域名解析的方法
早期的域名解析方法（HOST文件）和 分布式的域名服务器
1.4 DNS的查询方式
1.4.1 递归查询——客户机与本地DNS服务器
1.4.2 迭代查询——DNS服务器之间
1.5 域名结构：
域名系统的一般结构：H1.www.tieba.baidu.com
主机名.三级域名.二级域名.顶级域名
2 DNS安装
2.1 查询是否已经安装
rpm -qa | grep bind
2.2 安装DNS
yum clean all
yum -y install bind
2.3 查询安装结果和DNS状态
rpm -qa | grep bind
systemctl status named.service
2.4. 启动DNS服务 # systemctl start named.service //启动DNS服务
2.5. 停止DNS服务 # systemctl stop named.service //停止DNS 服务
2.6. 重启DNS服务 # systemctl restart named.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11dcdeb463acd6c12abba2684cf1444b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0635d62f75b78c623e0a3fc51530d293/" rel="bookmark">
			Unity UI ScrollView内item内容完整显示 超框自动滑动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关键API 用unity提供的工具计算两个ui的相对坐标 bounds = RectTransformUtility.CalculateRelativeRectTransformBounds(Viewport, curClickItem.transform); bounds的max是item顶部与viewport顶部的距离；
min是item底部与viewport顶部的距离；
插值可以直接计算；
完整代码如下 public void SetRect() { rectHeight = Viewport.rect.height; bounds = RectTransformUtility.CalculateRelativeRectTransformBounds(Viewport, curClickItem.transform); float offsetY = 0; if (bounds.max.y + rectHeight &gt; rectHeight) offsetY = -1 * bounds.max.y; if (bounds.min.y + rectHeight &lt; 0) offsetY = -1 * (bounds.min.y + rectHeight); var anchoredPosition = Content.anchoredPosition; anchoredPosition.y += offsetY; Content.anchoredPosition = anchoredPosition; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/060b956b6f32ed286a2ab32b7b5bd00b/" rel="bookmark">
			基于STM32的矩阵电子密码锁的Proteus仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本设计仅供参考
基于STM32的矩阵电子密码锁的Proteus仿真 (源码+仿真+原理图+PCB)
原理图：Altium Designer
仿真图：protues 8.9
程序编译器：keil 5
编程语言：C语言
编号C0034
【腾讯文档】C0034 网盘链接
资料下载链接
主要功能： 液晶屏幕实时显示矩阵键盘输入的密码；4x4矩阵键盘可输入6位密码并支持循环覆盖；有密码输入正确或错误的声光提示；带重新输入功能。 仿真图（提供源文件）： 原理图（提供源文件）： PCB（仅供参考）： 程序： 主函数
int main(void) { uint8_t Key_Value = 27; uint8_t i = 0; /* Reset of all peripherals, Initializes the Flash interface and the Systick. */ HAL_Init(); /* Configure the system clock */ SystemClock_Config(); TIM3_Init(2400-1, 72-1); // 10ms Beep_Init(); Key_Init(); LCD_Init(); LCD_write_string(0, 0, "Input Password:"); while(1) {	Key_Value = Key_Scan(); if(Key_Value &lt; 10) { disp_num[i] = Key_Value; i++; if(i &gt; 5) i = 0; Key_Value = 27; }	if(Key_Value == 16) {	for(i = 0; i &lt; 6; i++) { if(disp_num[i] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/060b956b6f32ed286a2ab32b7b5bd00b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/459cd017e5f71e9e186532f08d23b0b3/" rel="bookmark">
			HTML里的图片高度固定，宽度自适应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需求：图片的高度固定，宽度需自适应，保证图片在缩小的情况下不失帧
效果图：
1.HTML
&lt;div class="img" :style="{backgroundImage:'url('+item.chainImage+')',backgroundSize:'contain', backgroundRepeat:'no-repeat'}"&gt; &lt;/div&gt; 注：background-size：contain; // 缩小图片来适应元素的尺寸（保持像素的长宽比），是图片宽高最长的那个边覆盖元素一边即可； 2.CSS
.img { height: 22px; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5477bd23813eadcd976a04efbf33fc3e/" rel="bookmark">
			rz命令安装和使用——Linux-CentOS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天需要把Windows系统中的文件上传到VM中Linux里。
1.rz
首先命令行输入rz并回车发现提示未找到命令，那接下来就开始安装。
2.yum install lrzsz -y
输入yum install lrzsz -y回车，等待一小会，就提示已安装完毕。
3.rz
安装完成后输入rz回车，弹出选择文件对话框，双击打开。
上传完毕后，点关闭。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01d2ad1b17235fe18eb84c9510be5250/" rel="bookmark">
			IDEA插件系列（11）：Translation插件——翻译插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 插件介绍 可以翻译词汇、语句，十分方便。
2. 安装方式 第一种安装方式是使用IDEA下载插件进行安装
第二种方式是使用离线插件进行安装
插件下载地址：http://plugins.jetbrains.com/plugin/8579-translation/
3. 使用方法 3.1 翻译单词 选中单词，右键单击，选择Translate(翻译)，然后进行翻译。
也可以使用快捷键：Ctrl+Shift+Y
出现如下翻译面板
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0f6b3377f6487e7f14e0d20c14a10ca/" rel="bookmark">
			IDEA插件系列（10）：Statistic插件——统计代码行数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 插件介绍 显示项目统计信息。此插件显示按扩展名排序的文件，以及大小，行数LOC等。
2. 安装方式 第一种安装方式是使用IDEA下载插件进行安装
第二种方式是使用离线插件进行安装
插件下载地址：http://plugins.jetbrains.com/plugin/4509-statistic/
3. 使用方法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/020f7563888d4d174873e92cd624d513/" rel="bookmark">
			IDEA插件系列（6）：GsonFormatPlus插件——JSON字符串转换Java实体类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 插件介绍 GsonFormatPlus
JSON字符串与Java实体类的相互转换。
2. 安装方式 第一种安装方式是使用IDEA下载插件进行安装
第二种安装方式是使用离线插件进行安装
插件下载地址：https://plugins.jetbrains.com/plugin/7654-gsonformat/
3. 使用方法
先在项目的默认包目录下创建一个空的类
右键-&gt;生成（Alt+insert）
选中GsonFormat，或者使用快捷键打开(Alt+s)
复制json并点击设置
点击转换
结果
如果不想要JsonProperty 可以关闭
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5024b877aaaaa3efa05228b48ff9d62/" rel="bookmark">
			Xcode安装特定版本系统的模拟器（不支持断点下载所以总是下载失败）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xcode里下载太慢就算了，他不支持断点下载，一直一直一直下载失败，根本就装不上嘛！！！
添加模拟器、下载需要的iOS版本 添加模拟器
没有要的iOS版本则点击Download more
然而因为Xcode不支持断点下载，我在这就没成功下载过= =
所以我们找出下载地址，换个下载器（支持断点速度也快多了），用safari下都比Xcode好使！！！
找出对应iOS版本的下载地址 打开系统自带的console（控制台），这里我也没咋用过，一开始google了好久不知道他们到底选的右边的哪一个= =
其实蛮简单的，和charles抓包一样，点「清除」，先清空其他进程信息，然后点「开始」
然后在Xcode里开始下需要的iOS版本，然后在上图输入筛选条件，就能找到一条带有下载地址的进程信息了！Xcode里下载的也可以取消了，虽然不取消他也会很快的失败= =
安装 如15.2的下载地址就是
https://devimages-cdn.apple.com/downloads/xcode/simulators/com.apple.pkg.iPhoneSimulatorSDK15_2-15.2.1.1643410298.dmg
直接粘贴到safari就开始下载了，当然使用其他下载器也是OK的
下载完成后不要修改文件名，直接拖进Xcode安装的地方，路径：~/Library/Caches/com.apple.dt.Xcode
finder里点「前往」「前往文件夹」，输入地址
邮件显示包内容
如果没有Downloads，那就新建一个叫Downloads的文件夹，然后把刚下好的15.2 dmg放到Downloads里
再回到Xcode，就可以直接install了，install也要一会时间，等他装完就变成installed了
参考博客：
https://www.cnblogs.com/ZJT7098/p/Xcode-xia-zai-mo-ni-qi-tai-man.html
https://www.jianshu.com/p/ae77bcdde356
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b82ee56d472da7e07cab1f77be6e630/" rel="bookmark">
			C基础—文件上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.文件 文本文件 : 存储时,是将字符的ascii值存在磁盘中,取的时候将数值(ascii)翻译成对应的字符
二进制文件: 存的是二进制,取的是二进制
2.文件指针 当打开一个文件时，系统会返回一个结构体，这个结构体有此文件操作的所有信息 调用fopen时，系统返回这个结构体地址 FILE *p = fopen（“./a.txt”） 更多编程资料：huzi15209271798 3.打开文件 FILE *fp = fopen( “pathname”, 打开的方式 );
注意: 打开的选项
只有带r的选项,如果文件不存在,则不创建文件
带w选项的,打开时会清空文件
fopen的返回值: 如果成功返回FILE结构体地址,失败返回NULL
返回的文件流指针标识了打开的那个文件
4 fclose fclose(FILE *fp);
功能: 关闭文件
参数: 文件流指针
5 vs中. 当前./相对路径问题 1 如果直接在vs中调试运行: 相对路径相对的是工程文件
2 如果手动运行,.exe文件.相对路径相对的是可执行文件
6 设备文件 stdin
stdout
stderr
7 fputc 功能: 写入一个字符到文件中
int fputc(int ch, FILE * stream); 功能：将ch转换为unsigned char后写入stream指定的文件中 参数： ch：需要写入文件的字符 stream：文件指针 返回值： 成功：成功写入文件的字符 失败：返回-1 FILE *fp = fopen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b82ee56d472da7e07cab1f77be6e630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c089ed9d951e6914d4e6be367c342b6a/" rel="bookmark">
			手把手教你搭建视频去重系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#01 背景 如今，短视频平台对各类搬运视频的检测力度和精确度越来越高了。无论是影视号的剪辑，还是从油管搬运，即使做了各类复杂的视频变换，都很容易被检测出来。作者都会收到提醒，严重的甚至被封号。
乔布斯演讲原始视频
搬运的视频，加了字幕遮盖
常见的视频变换手段包括时间和画面上的改变：
时间: 倒放，循环，混剪，加速，减速等
画面: 裁剪，翻转，缩放，分辨率，马赛克，色度，对比度，模糊，噪点，画面复制，文字或图案叠加，修改背景，二次盗拍，画中画，deepfake等
面对如此多种类的视频变换，平台是如何检测出来的？魔高一尺，道高一丈。针对各类层出不穷的作弊手段，现在平台的检测算法已经相对成熟。很难有搬运作弊视频逃脱检测。
本文将从技术角度分析揭开这背后的技术和算法，并手把手教你搭建一个同款的检测系统。
我们知道，现代 AI 神经网络模型可以对图像、视频等数据提取特征，也叫 embedding，每个图像或视频可以提取出一个独一无二的 embedding。对视频本身的重复检测也就是对提取出的 embedding 进行相似度分析。
首先我们了解两个概念，即不同粒度的视频的重复检测：视频粒度的检测和片段粒度的检测。
视频粒度检测是一种针对整个视频时长内拥有大量重复的情况的方法。 它通过比较两个完整视频的向量之间的相似性来找到重复的视频。 由于每个视频只会被一个向量表示，这种方法通常速度更快、效率得更高。 然而这种方法的局限性也很明显：无法适应部分片段重复的情况，尤其不利于检测长视频中小片段的重复。 例如，视频 A 和视频 B 的前 1/4 时长完全相同，后 3/4 时长完全不同，但它们的视频向量可能并不相似。 在这种情况下，视频粒度检测显然无法识别到侵权内容。
片段粒度检测能够找到重复片段的开始和结束时间，可以处理视频片段的复杂剪辑、插入片段、或视频长度不同等情况。 它的核心技术在于比较视频帧之间的相似性。显然，这种方法能够做到更加精确的查重效果，但要求更多的时间和资源。
在上一篇文章中，我们已经演示了如何构建一个简单的视频粒度视频去重系统。 在下面的例子中，我们将实现片段粒度的视频重复检测。这种细粒度的片段检测会更加精确，并带来更高的召回，比较符合实际业务需求。
我们会使用 Towhee 和 Milvus 搭建片段粒度的视频查重系统：Towhee 是一个能对非结构化数据一键提取 embedding 的工具；Milvus 是业内领先的向量数据库，可用于向量存储和检索。
本文中使用的方法可以将核心功能简化为几行代码，方便大家动手复现和学习。
#02 准备工作 1、安装依赖 在 python3 环境下，安装这些依赖：
! python -m pip install -q pymilvus towhee pillow ipython numpy plyvel 2、准备数据 我们使用的视频均来自 VCSL 数据集。VCSL 包括了大量来自 Youtube 和 Bilibili 的真实视频，主要用于视频重复检测。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c089ed9d951e6914d4e6be367c342b6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42c9b5cdba955d746417bb22ff0e2e72/" rel="bookmark">
			Postman 的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Postman
在程序开发中用于调试网络程序或者跟踪网页请求。可以对网页进行简单的基本信息调试。Postman最早是作用chrome浏览器插件存在的，但是2018年初Chrome停止对Chrome应用程序的支持。所以现在Postman提供了独立的安装包，不再依赖于Chrome浏览器了。Postman在发送网络HTTP请求方面可以说是Chrome插件类产品中的代表产品之一。并且官方号称使用最广泛的REST API测试工具。
适用的操作环境
最初只是Chrome浏览器中的一个插件。现在已经作为一个独立的产品在使用。在Windows X32、Windows X64、、macOS、Linux系统中都有对应的产品。
使用文档
官方文档教程：https://learning.getpostman.com/docs/postman/launching_postman/installation_and_updates/
官方文档翻译文档：http://chromecj.com/web-development/2017-12/870.html
插件网提供的教程：http://www.cnplugins.com/tool/postman-specificate-lession.html
安装
Chrome浏览器插件安装
打开chrome网上应用商店，搜索Postman ，如下图，添加至chrome 即可适用
不能访问的请移至插件网下载：http://www.cnplugins.com/advsearch.php?q=postman
下载后添加到chrome 浏览器中即可。
客户端安装
下载地址：https://www.getpostman.com/downloads/
选择适合自己系统的版本下载，win32、win64、macOS、Linux
下载后直接安装即可
基本功能介绍
登录
登录后可以使所有的配置同步到云上，下次登录后会自动将配置更新，避免受到地区、时间、外部环境的影响。当然不用登录也可以使用。点击最下方Skip signing in and take me straight to the app，跳过登录使用。如果是简单的使用学习可以不使用登录，但是如果是项目中使用还是建议登录使用。
打开后页面如下图
页面介绍如下图
菜单栏：postman的一些操作菜单
常用功能：postman列出来的经常使用的一些功能
历史记录：请求过的一些记录历史
请求集合：也叫接口集，主要是根据不同的分类进行保存接口的集合
主体部分：用来发送请求和接受服务器响应
请求主体部分介绍
请求区域：发送接口请求设置的区域
请求方法：get、post、put、delete等
URL：请求的接口URL
参数设置：包括请求时需要传的参数，header，body等
响应区域：服务器响应返回的结果
响应内容：返回的数据部分，body、cookies、headers等
响应统计：返回的状态码、耗时、文件大小
显示方式：对显示的内容的展示方式，Auto、html等方式呈现
以上页面区域划分为自己理解，可能不是很书面体。
请求流程
简单的环境配置
例如：更换IP测试，本地测试和线上测试
本地地址：http://localhost:8080/
线上环境地址：https://www.baidu.com
可以将IP设置为动态，根据需要调用。
新建环境变量
在环境中设置两个变量，local_url和 online_url 用于存放各自的IP
可以在一个环境中设置多个变量
环境变量的使用
选择使用的环境，在url中或body中使用{{变量名}}，两个大括号中间传入变量名的方式传入值
环境管理中还可以设置全局变量，即在任何环境中都生效的变量
get请求
get请求分两种发送方法：输入url 后直接请求和传入参数请求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42c9b5cdba955d746417bb22ff0e2e72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35dda3ac154e2cfa0c9cd8c5f3dd8257/" rel="bookmark">
			【前端设计】寄存器与主功能电路为异步时钟时的功能影响探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们的目标是┏ (゜ω゜)=☞芯片前端全栈工程师~喵！
前言 今天想探究一个小问题，就是寄存器的时钟如果与主时钟是异步时钟，那么会不会对主功能有影响。当然，这样做肯定不是合理的，我知道的比较多的是寄存器使用降频到同源同相的时钟，或者使用主时钟再对寄存器读取时钟做跨异步。
不过我想了几天总是感觉如果使用异步时钟，是否也可能对功能影响有限？
场景 主要想探究三个场景：RW型配置寄存器、RO型状态记录寄存器和W1C型上报寄存器。
RW型配置寄存器 对于软件配置的RW型寄存器，配置时钟为apb_clk（假定使用apb总线配置，令其为125M），工作时钟为work_clk（令其为800M）。那么在寄存器配置后的几个时钟周期内，内部工作电路看到的值是不定的，最终会在几个周期后获取的正确的配置值，rtl内关联逻辑也会在几个周期后恢复正确：
那么如果rtl对这个值以及这个值的变化非常敏感，或者在电路工作中频繁的配置，则这样会引起电路内部的功能问题。而如果工作的流程是先配置寄存器，稳定后再启动电路工作，并且在工作过程中不会改配，则配置项可以视为准静态信号，此时即使配置寄存器在异步时钟域，也不会影响主电路动作。
举个例子，寄存器配置启动信号，电路中获取配置的沿跳变开始启动，这种场景下即使晚几拍开始工作实际也是没有影响的，而且启动配置一旦稳定为1后也不会随意跳变为0了，因此电路时可以正确工作：
因此我个人认为，如果对于一个系统，配置项在工作之前稳定，在工作过程中可视为准静态信号的话，寄存器处于异步时钟域是可以接受的。
RO型状态记录寄存器 状态寄存器一般用来记录内部的busy、cnt、接口等状态信息，主要用于在出现bug时“甩锅”。比如系统卡死了，我一查自己的模块ostd_cnt都是0，接口和内部的valid都是0，那就可以拍胸脯说：不是卡死在我这的！因此这一类记录寄存器基本为电平上报（即使为脉冲，在高频工作低频寄存器的场景下也会展宽），简单的电路如下图：
对于这种情况，同样的如果软件不需要实时的获取最新最准确的值，且在读取时（比如挂死的场景）这些状态已经稳定在某个值一段时间，那么应该说直接异步采样是不会有问题的，最后总是能够读取到需要的值。如果软件需要实时准确值，那么这样会导致状态读取错误。
W1C型上报寄存器 w1c型寄存器一般用来上报中断、上报完成等软件可以清掉的状态，这类状态一般在电路内部以脉冲的方式上报（总不能中断一直起，清掉了立马又上报吧，致命中断除外）。因此如果电路在高频工作，状态上报时是需要脉冲展宽的，当然如果以电平的方式上报则没有这个问题。那么还是刚刚的思考，脉冲展宽之后虽然有亚稳态的影响会导致寄存器在几拍之后才会采样的正确的值，但是只要正确的值能够被采样到，就可以软件读取到正确的值。
在这里我又多想了一些，w1c型寄存器提供给rtl的接口都是两个（以中断为例）：irq_in和irq_wen。如果irq_wen和irq_in做相同的展宽（我印象中需要展宽到慢时钟两个周期），但是apb_clk在信号下降时采样到了亚稳态，irq_wen恢复到了1而irq_in恢复到了0，那是否会使得最终寄存器中保存的值为错误值？换而言之，是否需要将irq_in做更高的展宽确保一定最终上报正确的值呢？
以上就是这两天我的思考内容，并非来自工作经验因此结论很可能是错误的，请大家不吝勘误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e4c8ea1d2d5f7e081a55741b5ad73ed/" rel="bookmark">
			【Mac M1】安装ffmpeg以及视频字幕整合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装brew
2. git克隆：git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg
3. 进入ffmpeg目录：cd ffmpeg
4. 执行脚本 ./configure --prefix=/opt/local
5. 编译 make
6. 安装 make install
这里注意：需要配置环境变量
vim /etc/profile
#set my ffmpeg environment
export FFMPEG_PATH=/opt/local
export PATH=$PATH:/opt/local/bin
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/local/lib
令修改生效：source /etc/profile
7. 安装成功，查看 ffmpeg版本 /opt/local/bin/ffmpeg -version
8. ffmpeg -i demo.mp4 -i demoTest.ass -c copy out.mkv
demo.mp4 是我的视频文件
demoTest.ass是我的字幕文件
out.mkv是合成后的带字幕的视频文件
这样针对视频通过ffmpeg来添加字幕就完成了，合成速度很快。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e5a09216819963aa4114c81ac17b14/" rel="bookmark">
			VBA PtrSafe无法使用如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以前由于软件版本都是32位的，现在版本升级为64位，则编写的VBA代码报编译错误，如下：
若要在64位系统上使用，则必须更新此项目中的代码。请检查并更新Declare语句,然后用PtrSafe属性标记它们.
解决方法：为了兼容64位系统，需要在Declare 后面加PtrSafe 进行标记，即由原来的Declare更改为Declare PtrSafe
如下：
更改之前
Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long) 更改之后 PtrSafe
Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b59eec7f47f956031491365960036350/" rel="bookmark">
			IoT亿级设备接入层建设实践——实践类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 不同的接入层
互联网的产品基本都需要解决终端的接入问题，每个接入层会因为终端数量、终端能力、网络环境等不同的因素有各自的设计特性，比如：淘宝网需要解决海量短连接问题、微信需要解决海量长连接问题，同时大家都要解决移动网络问题，那么阿里云IoT物联网接入层需要解决的是什么？在回答这个问题之前，先来看看物联网的特性
物的特性
既然要解决"物"的问题，那么首先需要了解"物"，先来看看这些"物"包括哪些，这些物有什么特性？
居家类：电视机、音箱、开关、灯泡，空调、洗衣机等基础设施类：水表、电表、燃气表等工业场景：产品信息、质量信息、设备能耗信息等安防类：摄像头、门磁、烟感等其他：汽车、手表、眼镜、单车、门锁、充电宝、起搏器等 "物"的种类非常多，应用场景、成本各不同，比如水表一般安装在户外，一般采用电池供电，这种设备对能耗的要求非常苛刻，比如基站铁塔的后备电源，一般安装在荒野，这种设备对网络的要求非常苛刻，比如开关，这种设备对存储、内存、cpu的要求非常苛刻，不同的"物"特性催生了不同的IoT接入层，下面来看看IoT接入层需要做什么？
二、IoT接入层需要解决什么问题？ 2.1 接入层关键问题 通用接入层需要解决的问题
安全性：通道安全、身份安全、数据安全连接方式：采用TCP、UDP，使用长连接还是短连接？协议选择：http协议、protobuf协议、mqtt、coap、私有协议等网络问题：就近接入/就快接入、系统及TCP/IP协议内核参数的调优等海量连接问题：当海量连接在线时，怎么保障系统的可用性？ IoT接入层有什么不同
特性：多样性、碎片化
针对这些设备特性，IoT接入层需要怎么来解决？
2.3 相同的问题，不同的解法 安全性：各种设备都联网后，设备将在我们的生活中更加根深蒂固，给安全带来更大的挑战，比如：汽车、门锁、起搏器等收到安全攻击，那么用户的隐私、财产、生命都会带来严重的威胁。IoT场景下很多设备对存储、内存、cpu、网络都有要求，那么在设计安全时，就不能简单的通过加强加密的安全方法来解决这个问题，因为它们执行复杂加密和解密的速度不足以让它们实时安全地传输数据。IoT接入层既要考虑安全性，又要对受限设备做妥协，需要怎么去平衡两者的需求？ 网络问题：IoT场景下的网络更加复杂，通信层面包括有广域网技术：GPRS/4G/5G/Lora/NB-IoT等，有局域网技术：Ble、ZigBee等，不同的通信模组会有不同的网络质量，怎么来保障网络稳定性，网络RT是非常关键的点。IoT场景下很多设备只能采用局域网通信技术，这类设备不能直接上网，需要边缘网关来代理上网，针对边缘网关的场景，接入层需要怎么设计？一个边缘网关下面可能挂了几万个设备，如果一个通道来处理的话，怎么解决单通道的拥塞问题以及单通道的热点问题？如果多通道来处理，这些通道之间怎么建立网络拓扑模型？ 协议选择：一般的接入层只会选择一种协议(比如淘宝的http、钉钉的lwp、微信的私有协议)，但是IoT不同，它需要支持多种协议，支持这么多协议，就是为了解决不同的业务场景，比如业务场景会主动给设备推送消息(共享充电宝、共享自行车等)，那么需要使用tcp长连接来解决，这种情况下采用mqtt+tcp协议会比较合理。比如业务只需要设备上报消息(水表、电表等)，不需要发控制指令给设备，那么采用coap的udp短连接就比较合适，既能省能耗，又能省流量。比如业务需要在浏览器上使用，那么http的tcp短连接就比较合适，天然的适配。比如业务已经有大量存量设备，同时采用了私有协议，连接了自建的平台，但是现在又想要接入阿里云IoT平台，使用平台各种能力(数据分析、监控、生态等)，那么采用泛发接入是比较合理的做法，通过泛发协议把私有协议转成标准协议，设备不需要改动，只要在自建平台做个适配层就可以了。 三、怎么解决IoT的接入问题，阿里云的优势在哪里？ 3.1 安全设计 对于系统设计来说，安全是基础，但又不能因为安全问题影响用户体验，需要在安全性和体验上找到平衡点，同时对于低功耗设备需要有不同的安全考量，那么阿里云IoT接入层是怎么来做的呢？
核心思想：通过三层安全防护机制 + 云端的安全风控模型来保证设备的安全性
三层防护机制
第一层：DDos 防护系统
基于阿里云强大、专业的DDos安全防护体系，防止IoT业务出现重大经济损失、数据泄露等问题，详细参考DDos防护
第二层：通道安全
通过支持TLS、DTLS、X509、ID2 四种方式来解决通道的安全问题，同时针对低功耗设备，做了多个维度的优化
不同传输协议上的TLS：mqtt协议跑在TCP之上，而coap协议跑在UDP之上，针对不同的传输协议，IoT接入层分别实现了TLS、DTLS，用来解决不同协议的通道安全问题流量维度：TLS认证流程中，需要把服务端证书传给设备端，大概消耗4K左右流量，同时要求设备支持非对称加密算法，对于某些低功耗设备来说，能耗、流量、加密能力都是有要求的，IoT接入层通过PSK技术，解决证书传输带来的流量消耗问题，同时解决非对称加密算法对cpu的性能损耗问题RTT减少1次：TLS的握手需要2次RTT，正常公网的RT 50毫秒，两次RTT需要消耗100毫秒时间，为了减少网络交互次数，IoT接入层实现了sessionTicket技术，利用sessionTicket的复用能力来减少通道建立过程中的RTT次数，同时也去掉了证书传输和非对称加密 注：ID2是阿里云安全团队实现的类TLS协议，能力跟X509的双向TLS对等，同时在双向认证的基础上，减少了设备证书的传输，适用于对安全等级要求较高、同时对设备流量有要求的场景。
第三层：设备身份授权及验证
阿里云IoT的设备身份叫三元组，由平台授权颁发的设备身份信息，每个设备全球唯一，在设备建立连接时，设备通过DeviceSecret加签设备信息，然后有平台对加签信息进行验证，用来完成设备登陆IoT平台，保障设备的安全性。
三元组指的是ProductKey、DeviceName、DeviceSecret的组合。
ProductKey：是物联网平台为产品颁发的全局唯一标识。DeviceName：在注册设备时，自定义的或系统生成的设备名称，具备产品维度内的唯一性。DeviceSecret：物联网平台为设备颁发的设备密钥，和DeviceName成对出现。 云端一体的安全风控体系
为了进一步提升设备的安全等级，阿里云IoT建立安全风控模型，针对设备暴力认证、设备恶意连接等行为，采取主动预警，快速阻断等措施，为设备安全保驾护航。比如某个设备不停的来认证，但是每次认证都是因为签名验证而失败，同时设备每次上传的签名又不同，根据这三个条件基本可以判定该设备存在暴力认证的行为。
3.2 网络优化 直连网络
不同的通信模组(GRPS/3G/4G/5G、Ble/ZigBee)，不同的部署环境(电梯、地下车库、荒野)，会导致各种不同的网络差异，给设备的连接稳定性带来风险，阿里云IoT针对这些问题，是怎么来解决的？核心思路：让设备就近接入，同时提供稳定、高速的网络环境。阿里云IoT接入层通过部署多region(如下图)的方式来为用户提供就近接入的能力，通过BGP网络为设备提供稳定、高速的网络环境。
BGP网络有什么优势？
消除南北访问障碍。由于BGP可以将联通、电信、移动等运营商的线路“合并”，使得中国南北无障碍通讯成为可能。对接入层来说，可使“联通、电信”这类区别消失，更能使一个网站资源无限制的在全国范围内无障碍访问，而不需要在异地部署VPN或者异地加速站来实现异地无障碍访问。高速互联互通。原来一条线路访问另一线路往往要经过很多层路由，但实现BGP以后就像进入了高速公路。质量最好的网络：从运营商网络质量来看，BGP带宽是中国内地地域目前最昂贵的、线路质量也是最好的线路。对于延迟要求比较苛刻的业务可以使用BGP线路来解决。 就近接入
先来看看用户怎么就近接入？分两种情况：
设备使用的区域确定：设备厂商在生产设备时，已经知道设备需要卖到哪些地方，对于这类情况，设备直接写死就近的region接入地址就可以了。设备使用的区域未定：设备在生产时，并不清楚设备在哪个区域使用？这种情况肯定不能直接写死一个接入地址了，这种情况下，首先需要解决的是设备的区域归属问题，解决这个问题有两种方式：一种方式是让用户指定设备的归属地，这种方式比较普遍，比如买苹果产品时，不管iphone，ipad都会在设备初始化时要求设定一个归属地，还有一种是根据设备IP地址来判定，可以做到无人工干预，完全自动化，但因为IP库存在一定的误差，这种自动化同时也会带来归属地判定的错误。 那么阿里云IoT针对这两种归属地判定场景做了什么优化？
用户指定归属地：用户可以在配网的时候设置归属地到设备里，也可以在阿里云IoT平台提前预置设备的归属地，设备只需要在接入IoT平台之前去设备引导服务获取就近接入点地址就可以了。 这里有个问题：去哪里获取设备接入点地址？阿里云IoT只部署一个中心，然后通过全球设备引导服务中心+加速通道+智能域名来解决这个问题。自动判定设备归属地：为了减少IP判定带来的误差，阿里云IoT支持产品的多区域指定能力，比如可以指定设备可能会在新加坡，上海、美东等地使用，然后动态的根据IP+设定区域来判定设备归属地，这样的精度就会有明显的提升。 region覆盖不到的区域的网络优化方案
阿里云IoT通过多region部署来满足设备的就近接入，但是region数量有限(部署region的代价较大)，不能解决一些偏远地区的网络问题，IoT接入将通过部署前置节点 + 智能动态路由能力来解决这个问题。比如把IoT前置接入点(不需要部署整个region)部署在离偏远地区最近的机房，然后通过该前置接入点代理设备登陆到指定的region中，然后在前置接入点跟指定region部署加速通道，这样就能解决这些偏远地区设备的网络问题。 边缘网关
针对网关设备，如果子设备较多的情况下，会带来哪些问题？
网关下有10w个子设备，同时每个子设备定时数据上报，需要怎么设计？网关下的10w个子设备，因为网关下线，全部需要断线重连，需要怎么保障子设备快速上线？ 大数据的上报的解决方案
阿里云IoT的网关技术方案核心技术点：
多通道：一个网关有多条物理TCP连接，每个物理连接等价，网关可以往任意一个物理连接发送或者接受数据子设备虚拟连接：网关代理子设备上线，每个子设备对应一个虚拟连接的session子设备&amp;自连设备打平：服务器对子设备跟直连设备等同处理，唯一差别就是直连设备有独立channel，子设备是共享物理channel，这样设计便于设备的各种运维操作 通过多通道解决了网关的海量数据上报问题、通道的热点问题，同时解决了通道容灾问题。
通过虚拟连接解决了子设备通道复用的问题，不需要为每个子设备建立一个TCP连接。
通过子设备和直连设备打平解决了各种运维的复杂性，子设备相当于一个直连设备。
子设备的登陆慢的解决方案
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b59eec7f47f956031491365960036350/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c59dbd88f00362096962e68376758bdb/" rel="bookmark">
			物联网数据分析（上篇）——业务系统架构类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021 年，活跃的物联网设备超过 100 亿台。
预计到 2030 年，活跃的物联网设备数量将超过 254 亿台。
到 2025 年，每分钟将有 152,200 台物联网设备连接到互联网。
到 2025 年，物联网解决方案有可能产生 4-11 万亿美元的经济价值。
83% 的组织通过引入物联网技术提高了效率。
据估计，在 2019 年至 2025 年的六年期间，全球物联网支出将达到 15 万亿美元。
到 2026 年，消费物联网市场预计将达到 1420 亿美元，复合年增长率为 17%。
94% 的零售商同意实施物联网的好处大于风险。
到 2025 年，物联网设备生成的数据量预计将达到 73.1ZB（zettabytes）。
原文作者：Bojan Jovanovic
1 引文 物联网大数据统计数据显示，随着采用率的提高，设备将在接下来的几年中在全球范围内产生成倍增长的数据。到2025年，这些数字将达到73.1ZB，相当于2019年产出的422%，当时产生了17.3ZB的数据。
这样海量的数据，价值挖掘的潜力可以说是无穷的。越来越多的物联网厂商选择设备上云，想挖掘物联网设备数据背后的价值是其中很重要一个因素。本文从阿里云物联网数据分析功能的演进，探讨物联网数据分析的技术解决方案。
2 数据标准化 物联网数据协议多种多样，碎片化严重，所以物联网平台从开始就提出了用物模型来统一设备数据上云的标准，后来也成为了事实上的行业标准做法。但是以MQTT协议为例的物联网数据传输协议，是没有对设备数据传输格式做要求的，实际上物联网厂商可以用完全自定义的二进制数据上云，然后流转到自己的存储。这样就导致物联网平台被通道化，平台不感知用户上报的数据内容，无法为用户创造更多的价值。
因此平台提供了通过脚本的形式解析用户的自定义协议，通过脚本解析后的数据，已经是通用的alink json协议，能够被平台感知。
3 即席查询（Ad Hoc）版本 即席查询（Ad Hoc）是用户根据自己的需求，灵活的选择查询条件，系统能够根据用户的选择生成相应的统计报表。即席查询与普通应用查询最大的不同是普通的应用查询是定制开发的，而即席查询是由用户自定义查询条件的。
百度百科词条：即席查询
阿里云的物联网数据分析，第一个版本是基于即席查询架构的版本，这个版本在一段时间内，解决了用户设备数据上云后的分析问题，在刚开始的业务体量阶段，有其架构的实用性，也为平台积累的一些原始能力和第一批用户。
3.1 数据分析功能的提出 解析后的标准alink设备数据，首选的存储是时序存储，而不是传统IT系统最常见的关系型存储。这是由物联网的设备特征和业务属性决定的。这些时序类的设备数据上云后，大部分的用户选择通过规则引擎流转到自建的平台。如下图左一所示：
为了不让物联网平台被通道化，同时给上云的物联网平台用户提供更多的价值，创造更多的平台附加值，我们上线了物联网数据分析功能（上图右一），上云的设备数据进行存储后，可以被设备分析模块进行使用。在数据分析模块里，用户可以用时序透视，可视化分析，SQL工具等功能对设备数据进行分析。
3.2 数据存储 经过解析后的设备alink协议数据，是存储在时序存储中的。但是时序存储中的数据不能直接使用，不是分析工具无法分析时序存储中的数据，而是有稳定性和成本两方面的考虑：
第一，设备数据上报链路对数据入仓的实时性能有很高的要求，一旦分析类的读请求大量消耗时序存储的系统资源，势必会影响时序存储系统的稳定性。
第二，时序存储和离线存储的成本差距巨大，为了减少存储成本，时序存储底座里只有一个月的数据存储，而要做到长时间的数据持久化存储，需要更低成本的存储底座，这里我们选择的是阿里云的OSS存储。
因此平台会通过实时入仓的任务，将设备上云数据同步到OSS存储底座上，这里采用的是ORC格式，方便大数据分析技术栈的各个生态产品进行分析使用。如下图所示：
3.3 基于即席查询（Ad Hoc）的数据分析架构 转储过的设备数据，只包含了设备上报的事实数据，但是实际在用户的业务过程中，纯粹的设备事实数据是没法给用户带来更大的业务价值的。举个例子，在室内节能解决方案中，我们要通过上报的设备数据找出最耗电的室内电器，针对性的进行管理，以此降低电力费用支出。我们可以通过设备上报的事实数据，找到耗费了最多电量的电器，但是这个设备为什么耗费这么多电量，需要很多额外的维度信息补充。比如电器的型号，电器的运行环境数据，电器的安装位置，电器的运行时长等。抛开这些维度数据，单纯的分析设备的事实数据意义不大。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c59dbd88f00362096962e68376758bdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ccfefc08712e5f0f880d609d05b490b/" rel="bookmark">
			vue3&#43;vite在若依项目中使用scss全局变量、公共颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 做项目一般都需要设置公共的颜色、字体、文字大小等css变量，如果不设置这些css变量的话，项目中颜色来回复制，等需要改变的时候，每个页面都需要进行替换，使用scss的css变量之后，在每个页面使用变量就能达到统一的目的。
第一步 创建scss文件 在src/assets/styles目录下创建self.scss
第二步 创建变量 在self.scss中创建需要的变量，如图，变量需要前面带$符，变量后面最好自己加上注释，这样让别人看的时候也方便理解
$brandColor:#147DE2; // 品牌主色 $contentTxtColor:#888; // 主体内容文字色 $mainH1Fsize:32px; // 大标题字号 $contentFsize:14px; // 主体内容字号 第三步 在vite.config.js或vite.config.ts中引用 { ...... resolve:{ ..... },	...... css:{	preprocessorOptions: { // 全局样式引入 scss:{ additionalData: '@import "./src/assets/styles/self.scss";', javascriptEnabled: true } }, ............ } } 第四步 在任意页面使用scss变量 &lt;style scoped lang="scss"&gt; .contentTitle { padding:20px 0px; border-bottom:1px solid #eee; font-size: $mainH1Fsize; .title{ position: relative; &amp;::after{ content:""; width: 100%; height: 4px; background:$brandColor; display: block; } } } &lt;/style&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e14f18b718ed3aa6be59ee662f74b475/" rel="bookmark">
			C&#43;&#43;OPencv视频文件处理使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.视频读取 cv::VideoCapture capture(const string&amp; filename); // 从视频文件读取
文件（.MPG或.AVI格式）中读取视频，**对象创建以后，OpenCV将会打开文件并做好准备读取它，如果打开成功，
我们将可以开始读取视频的帧，并且cv::VideoCapture的成员函数isOpened()将会返回true
2.视频保存 VideoWriter video_writer; video_writer.open(const string&amp; filename, int fourcc, double fps, Size frameSize, bool isColor=true); 参数意义： filename：保存文件名称及路径； fourcc：表示压缩帧的codec，一般用CV_FOURCC(‘M’,‘J’,‘P’,‘G’) = motion-jpeg codec； fps：表示帧率，可用video_writer.get(CV_CAP_PROP_FPS)； frameSize：保存的视频大小； 示例代码：
void video_demo(Mat &amp;image) { VideoCapture capture(0); //读取摄像头,读取视频文件直接把0改为视频路径 int frame_width = capture.get(CAP_PROP_FRAME_WIDTH); //宽度 int frame_height = capture.get(CAP_PROP_FRAME_HEIGHT); //高度 int count = capture.get(CAP_PROP_FRAME_COUNT); //总的帧数 double fps = capture.get(CAP_PROP_FPS); // 每秒播放多少帧 cout &lt;&lt; "fps:" &lt;&lt; fps &lt;&lt; endl; //capture.get(CAP_PROP_FOURCC); //视频编码方式 //创建写入对象 VideoWriter writer("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e14f18b718ed3aa6be59ee662f74b475/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be5d8e9b57755148d67580ac02cba13f/" rel="bookmark">
			redis7基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是redis官方资料为什么要使用Redis1.redis用途缓存数据分类： 2.redis缓存特性3.redis的io模型3.1 单线程模型3.2 多线程模型3.3 redis模型优缺点单线程模型多线程模型多路复用技术 4.redis安装redis配置文件启动redis配置文件参数redis停止命令redis数据删除命令redis-cli连接server查看linux内核版本查看somaxconn的值查看cpu 数 什么是redis Redis全称为：Remote Dictionary Server（远程数据服务），使用C语言编写。Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。基于内存，可持久化 官方资料 Redis官网:http://redis.io/ Redis官方文档:http://redis.io/documentation Redis下载:http://redis.io/download 为什么要使用Redis 一个产品的使用场景肯定是需要根据产品的特性，先列举一下Redis的特点：
读写性能优异
。Redis能读的速度是110000次/s,写的速度是81000次/s （测试条件见下一节）。数据类型丰富
。string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。原子性
。Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。丰富的特性
。Redis支持 publish/subscribe, 通知, key 过期等特性。持久化
。Redis支持RDB, AOF等持久化方式发布订阅
。edis支持发布/订阅模式分布式
。Redis Cluster 1.redis用途 缓存数据分类： 实时数据同步缓存：数据库数据更新之后，redis中的数据会被清除，下一次查询之后再写入缓存阶段性同步缓存：redis允许数据一段时间内与数据库中的数据保持不一致，，这时增加缓存过期时间，当缓存消失之后，再查询时写入缓存
2.redis缓存特性 性能极高： 读速度 11w/s ， 写 8w/s，
–原因是数据操作是在内存中发生，
– c语言开发简单稳定-源码很少，早起2w行 3.0版本支持集群，5w行持久化 – 支持RDB和AOF高可用集群- 主从集群丰富的数据类型 string, list(链表), set（集合）、zset（有序集合）、哈希客户端语言广泛支持acl权限控制， redis6开始引入支持多线程io模型 ， 从6.0版本开始支持多线程，之前版本单线程 3.redis的io模型 3.1 单线程模型 3.2 多线程模型 内存响应时间：100ns
3.3 redis模型优缺点 单线程模型 优点
-1. 多线程模型 多路复用技术 多路复用的三种模型： select模型、poll模型、epoll模型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be5d8e9b57755148d67580ac02cba13f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a79e009a1b9dfbb0712759572fc7041/" rel="bookmark">
			单片机之晶振频率（单片机的心脏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，要知道频率的概念，频率是值物体每秒振动的次数。或在一定时间或范围内某种事物发生或出现的次数。
在单片机中经常能听到诸如12MHz 72MHz这样的词。
它代表的意思就是晶振每秒钟震动的次数，例如12MHz就是每秒能震动12*10^6次，常见于51单片机的晶振。
而51单片机又有12分频(12T)和1分频(1T)，其中12分频的意思就是单片机的标准运算速度是晶振(12MHz)的12分之1，即12分频下，单片机的运行速度为1秒钟震动10^6次。
12MHz的12分频(频率为1MHz)下单片机震动1次则历经1us(T=1/F=1s/10^6=1us)，震动1000次则历经1ms。12MHz的1分频(频率为12MHz,等于不分频)则是一秒钟震动12*10^6次，此时，单片机震动1次历经1/12us，震动12000次才历经1ms。频率越大，震动次数越快，则震动同样次数花费的周期就越短。
72MHz则常见于STM32单片机，晶振一秒震动72*10^6次，则此频率下单片机1us震动72次。可见其速度之快。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ba95781916bbbedb5cba5a5ed470f9/" rel="bookmark">
			html中表格和表单嵌套以及css基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、html中表格和表单嵌套 注意嵌套过程中先写表单外标签，因为表单没有嵌套规则表格的合并以及相关操作可以在嵌套中正常使用总结：表格和表单的嵌套，代码中展示是表格被嵌套在了表单当中，在展示中看着是表单被嵌套在了表格当中。代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 因为表单没有嵌套规则，表格有嵌套规范，所以表单写在外面 --&gt; &lt;form&gt; &lt;table border="1" cellpadding="30"&gt; &lt;tBody&gt; &lt;tr align="center"&gt; &lt;td rowspan="4"&gt;总体布局&lt;/td&gt; &lt;td colspan="2"&gt;用户注册&lt;/td&gt; &lt;/tr&gt; &lt;tr align="right"&gt; &lt;td&gt;用户名：&lt;/td&gt; &lt;td&gt;&lt;input type="text" placeholder="请输入用户名"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr align="right"&gt; &lt;td&gt;密码：&lt;/td&gt; &lt;td&gt;&lt;input type="text" placeholder="请输入密码"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr align="center"&gt; &lt;td colspan="2"&gt; &lt;input type="submit"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;input type="reset"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tBody&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 结果展示
2、css基础 注意css书写样式有四种方法，其中常用的有三种：内联样式、内部样式、外部样式外部样式需要通过link来把写在外部的css文件引入到html当中，下面的例子中css和html是写在同一文件夹当中的。html代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37ba95781916bbbedb5cba5a5ed470f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45e744a92d5301a892c609e42d0412e8/" rel="bookmark">
			移动端适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
移动端的应用(主要包括三类):
移动端适配的原因
自适应:
响应式:
px、em、rem的理解
Viewport视口 一、视口的划分:
layout viewport 布局视口
visual viewport 视觉视口
ideal viewport 理想视口
二、视口大小的更改​​​​​​​
viewport属性各个参数：
移动端适配方法
一、rem(根倍率) + 动态的根标签的font-size
1、媒体查询设置动态的html标签属性
2、通过JS动态计算html标签中的font-size
3、已经开源的库可以使用
二、vw(视口宽度)---推荐
三、flex(弹性布局)
移动端的应用(主要包括三类): 原生App开发: iOS、Android、RN、uniapp、Flutter等
原理:现在常用的前端框架是HTML、CSS、JS打包,在手机的浏览器中运行;原生app(RN)全是用JS编写,打包成为java或者OC语言,可以直接在手机中运行,不需要依赖浏览器
小程序开发: 微信小程序开发、uniapp等
web页面: Vue开发、React开发、uniapp等
原理:就是上面提到的,移动端的Web页面,可以使用浏览器或者WebView浏览
这里借用一张React-Nactive图片解释:
通过这张图片,我们就可以显而易见的知道两者的区别:
原生App直接与系统进行交互,与WebApp这种中间有浏览器或者WebView的显然要快,缺点也是显而易见的,拿我用过的RN为例,组件库中的组件相对来说比较少,变化和功能相对来说要少,再就是搭建环境和运行环境要比WebApp多,iOS和Android是两套代码,打包为的方式也不同.
移动端适配的原因 最主要的原因:屏幕大小
这里我们可以看见各种手机型号,不同手机型号的屏幕也不经相同,如果使用固定的尺寸,那么不同的App在不同手机上肯定不适配.
再加上现在平板、手表、曲面屏、折叠屏、车机显示屏、大的电视屏幕以及电脑屏幕,不同App想要做好用户体验以及开拓市场,那么App应用的适配性就至关重要.
自适应: 根据不同的设备屏幕大小来自动进行调整
响应式: 当屏幕的宽或者高进行改变时,会自动进行响应,并自动进行根据屏幕进行改变
比如:手机屏幕竖屏调整为横屏; 电脑窗口的宽或者高进行拉伸
px、em、rem的理解 简单的来讲:
px(像素),屏幕的每一个小方块亮的不同颜色的灯组成了屏幕,每一个小方块,就是一个像素em(相对长度单位),电脑的手机当你不给font-size是也会出现字体大小,这个就是设置的默认字体大小,所有未经调整的浏览器都符合: 1em=16px。根据这个计算,就可以算出默认字体大小对应的em,那么不同屏幕的默认不同,就会进行自适应和响应式rem(根元素): root em就可以简单的理解为相对于root &lt;html&gt;元素的单位, 还有一些rpx、fpx等其实都是根据这些出发的,了解了这些再看就会简单
网址:px、em 和 rem 三者区别_cbkting的博客-CSDN博客_rem em px
Viewport视口 一、视口的划分: 这里只针对移动端, pc端没有这种转换和划分
注意:&lt;meta name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45e744a92d5301a892c609e42d0412e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f4cb6336338461b338c1b4295d4bdfb/" rel="bookmark">
			华为云会议实测：经常开远程视频会议，选它就对了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言华为云会议悄然助力各行各业和其他云会议产品相比，华为云会议优势是什么？云端一体线下会议室和云会议互通专业会管与会控能力更安全 华为云会议有哪些 AI 能力？华为云会议入门有多简单？下载步骤如下安装加入会议预约会议快速邀请与会者同一网络，快速投屏会议录制 华为云会议免费版满足你的白嫖愿望 前言 最近有外贸创业的同学和我闲聊中说到：他经常需要坐飞机到南方几家工厂去考察产品，有时候还经常需要和欧美一些企业采购人员视频会议谈合作。然而在使用一些视频软件时，总是容易出现掉帧、视频画质清晰度不太够、不方便观察产品细节、受网络影响出现卡顿等问题，感觉一直在忙活、效率并不是很高，大脑都有些许转不过来了。
回想起我之前的工作经历，当时公司一个大项目经常需要去上海、北京、深圳、硅谷研究院多地联合讨论交流，当时公司使用的是华为云会议。初出茅庐的我还问领导，国内这么多云会议软件，为什么公司会选择华为云会议？
他告诉我说，华为云会议解决了很多视频会议中的痛点：硬终端系列全、适配好，会议室的视频会议体验更好；跨地域沟通灵活又安全、免注册、便捷接入、海外接入也很稳定；视频和共享高清，远程看图细节很清晰；安全性高，电脑上共享有水印，手机上开会不能截屏等，防止截屏泄露信息；还有录制、翻译多国语言、自动生成会议纪要等很多实用的功能，是很多同类产品难以企及的。
作为一名互联网 AI 领域从业者，我深刻感受到了华为云会议把各项AI技术注入到云会议场景所带来的服务水平的巨大提升；因此我毫不犹豫地推荐他使用华为云会议。
IDC最新发布的《2022上半年中国视频会议市场研究报告》显示，华为云会议凭借领先的技术和优异的市场表现目前市场份额位居行业第一，正在引领中国云办公市场。
由于外贸、金融一类市场本身的特点，很多公司各业务条线、各地分支机构，都会形成业务合作关系，这种离散耦合的关系使得视频会议显得尤其重要，可以极大地缩短从概念到实践的时间和人力成本，提升工作效率。我相信华为云会议的使用也能够为我同学在外贸创业中提供助力。最起码在和老外会谈时，他那蹩脚的外语理解能力能够再进一步，并且受益于华为云会议视频多项AI能力加持，不会存在漏掉关键信息的情况，一定能够事半功倍，马到功成。
接下来，博主就已经了解到的华为云会议各项功能和大家展开分享，让我们一起体验“技术就是第一生产力”这一真谛 。
华为云会议悄然助力各行各业 当下时代飞速发展，很多企业办公人员分布在全国各地，视频会议就是各级部门日常沟通最直接的工具。在企业办公会议、企业培训、行政会议/汇报决策会议/全员大会、外部商务交流、招聘、营销活动、跨国交流等众多视频云会议场景中，华为云会议都能让日益频繁的云上会议沟通更加自由、方便。
近几年，很多高校开展了远程教育，学生们可以随时随地进入课程，学习宝贵知识；华为云会议已经为许多高校提供了相应的视频课程、远程教育技术服务，并且华为云会议教育旗舰版对所有非盈利性教育机构和学校提供教育专属折扣。
华为云会议还能让医院合作交流更紧密，远程会诊更高效。
此外，多地行政单位、高校、医院、制造业、多项跨国的高端峰会也选择了华为云会议来协助参会人员异地交流、远程办公，足见用户对其实力的认可。
和其他云会议产品相比，华为云会议优势是什么？ 近些年，市场上涌现多款稳定且功能齐全的云会议产品（例如飞书、腾讯会议、华为云会议），与其他产品相比，华为云会议的优势主要体现在：
云端一体 华为自研会议大屏IdeaHub+原生云会议体验，具有更高清和实时的音视频效果。同时华为原厂提供全系列专业视讯终端，小中大会议室全覆盖。此外，华为云会议也支持第三方大屏安装SmartRooms，获得云端一体的智能会议室体验。丰富的终端选择，从高端旗舰款到极具性价比普及款，轻松覆盖大中小型会议室、经理室、办公区、开放区、前台大厅等各类场景。
线下会议室和云会议互通 华为线下会议系统连续8年位居中国区视频会议行业第一品牌，华为云会议与华为线下会议互通性好，体验一致，支持统一管理和调度，即使 2 套会议系统也能具有一个会议的体验。业界主流的Polycom、思科会议终端除了提供会议室连接器这种转换连接的方式外，还提供直接注册到华为云会议连接方式，音视频互通体验好。华为云会议还提供VDC融合方案，可以与视频监控等融合互通，适合如应急指挥、园区等需要会议、监控视频融合的场景。
专业会管与会控能力 在大型会场，华为云会议接入时支持500方双向高清视频，可提供多达39种丰富的组合多画面布局，满足客户定制化需求，同时支持非手机号和邮箱的独立账号体系，具备更强的会管和会控能力。
更安全 华为云会议安全体系基于华为公司可信文化和安全流程构建，提供云、管、端全方位安全防护；多重业务安全性设计，有效防黑客攻击、防信息泄露，确保会议稳定可靠。具体包括：
17+国际国内权威安全认证：获得17+国际国内权威安全认证，华为云是首批通过可信云SaaS安全认证的云会议厂家，并且是国内唯一通过NIST的云会议厂家。多重业务安全设计：支持用户接入权限控制、外部与会者标记、会议锁定、共享水印、防手机端截屏、等候室、共享权限控制等会议安全功能。多数据中心备份，多网络通道保障：支持多地数据中心灾备，多运营商网络通道保障；重大会议可提供会议系统双平面，接入节点、网络、终端双备份，PSTN语音接入三重备份，云、网络、终端，任何一个节点故障都能快速切到备用节点，保障会议稳定可靠进行。 华为云会议有哪些 AI 能力？ 随着AI技术的应用，人们希望系统可以越来越智能化，帮助人们处理一些重复工作，聚焦在思想的创造上。那么华为云会议都有哪些AI能力，来帮助提升会议效率和体验呢？
智能取景，发言人跟踪：华为IdeaHub支持智能取景，根据会议室中人员坐的位置智能取景，提供一个最佳视角，让与会者在画面正中。同时支持根据发言人声音，特写放大发言人。
实时字幕和智能翻译：华为云会议支持语音转字幕显示，并提供中英文实时翻译，便于跨语言的交流。语音转文字自动生成会议纪要，并可以根据不同接入方标识，会议纪要可以自动导出。
AI语音助手：华为IdeaHub支持AI语音助手，用语音发起会议，并呼叫通讯录中的人加入会议。要开会，动动嘴就可以了。
虚拟背景：华为云会议可以识别人像，并根据设置的虚拟背景进行叠加显示。
通过使用华为云会议产品，我们见证了 CV 分类、检测、跟踪、图像分割、超分重建、语音识别、语音翻译、语音转文字等众多领域 AI 技术的落地应用和对传统云会议产品带来的 AI 加持。
华为云会议入门有多简单？ 近两年，华为云会议一直伴随着我的生活、工作和学习。以我的使用经验来看，华为云会议产品的设计是真的简洁，而且多平台均能够完美运行和高效接入，这里和大家简单介绍一下华为云会议的基础安装和使用。
下载步骤如下 华为云会议产品下载链接 点击红色按钮：立即下载
安装 这里以Mac电脑为例，下载的安装包直接双击打开，点击左侧图标拖拽至右侧即可，非常的easy。 加入会议 如果只是加入会议，那么无需注册账号，也能一键接入会议。华为云会议支持电脑、平板、手机、Web、会议终端等各类终端接入，无需登录也可加入会议，随时随地，便捷参会。如下所示，我们只需打开华为云会议软件，点击加入会议，然后输入正确的会议ID即可。
预约会议 使用电脑、平板、手机、会议大屏上的华为云会议客户端，或Web会议管理平台上，或者在Outlook上通过华为云会议插件，都可以一键创建即时会议，并添加其他与会人直接入会。也可以预约会议，会议通知可以通过短信、邮件、微信、Outlook日历等方式发送给与会者。即便与会人没有及时上线，会议主持人也可以呼叫与会人的云会议帐号或者手机号码，通知他加入会议（其他厂商很多都不支持外呼PSTN电话入会），让会议组织便捷高效。这一功能非常适合企业内部使用。
快速邀请与会者 华为云会议支持通讯录邀请、链接信息邀请、二维码邀请等多种邀请方式。
同一网络，快速投屏 很多同事在用笔记本电脑做分享时，经常忘记带转接线，有了华为云会议，在同一网络下，输入投屏码即可快速完成投屏，为企业用户增添了便利。
屏幕共享，内容选择
会议录制 在会议过程中，主持人可以轻松设置录制权限，保证内容安全不外泄：
结束会议之后、点击设置并打开录制文件所在文件夹，即可看到刚刚录制的会议视频。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f4cb6336338461b338c1b4295d4bdfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be9fcf61b79d222921b199ebe136e496/" rel="bookmark">
			如何在Lambda表达式中对BigDecimal进行累加？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如何在Lambda表达式中对BigDecimal进行累加？ ​ 今天在工作中需要用到foreach对订单金额Bigdecimal进行累加，查了很久都没查出结果；
// 已支付总金额 BigDecimal paidAmount = BigDecimal.ZERO; orderList.stream() .filter(OrderDO::getHasPaid) .forEach(orderDO -&gt; paidAmount.add(orderDO.getPaidAmount())); ​ 上面这种做法paidAmount依然为0；
​ 于是换一种做法，使用变量接收，但会报Variable used in lambda expression should be final or effectively final的编译错误；
解决方法是使用map-reduce进行缩紧；
// 已支付总金额 BigDecimal paidAmount = orderList.stream() .filter(OrderDO::getHasPaid) .map(OrderDO::getPaidAmount) .reduce(BigDecimal.ZERO, BigDecimal::add); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54b17531bf2f84a34e5b240bdc8b8e09/" rel="bookmark">
			Python列表嵌套字典dict中相同key的相加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 实现思路：
1.去重id
2.通过去重id生成count值为0的dict
3.先循环目标数据，再循环去重后的dict 通过if判断，相同则相加，不同则跳过，这样就达到了dict相加的目的 # 怎么把列表中相同key的字典相加，也就是id相同的值，doc_count的值加doc_count的值
代码段如下：
l1 = [{'id': 5, 'count': 129}, {'id': 1, 'count': 3}, {'id': 1, 'count': 64}] #将不同的id放入一个列表中 lid = [] for i in l1: if i['id'] not in lid: lid.append(i['id']) print(lid) lm = [] #根据lid,生成结果列表 for i in lid: lm.append({'id': i, 'count': 0}) # 如果有多个元素，需要再新定义一个空列表 #相同id的count数相加 for p in l1: for o in lm: if p['id'] == o['id']: o['count'] = o['count']+p['count'] print(lm) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/578a0560ac9ce770fd66ac381318c470/" rel="bookmark">
			CSS元素水平垂直居中的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用弹性布局
align-items: center;设置flex子项在垂直方向上居中；justify-content: center;设置flex子项在水平方向上居中。
&lt;div class="box1"&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;/div&gt; .box1 { width: 600px; height: 600px; border: 2px solid yellowgreen; /* 使用弹性布局实现子元素居中 */ display: flex; align-items: center; justify-content: center; } .box2 { width: 500px; height: 500px; border: 2px solid red; } 二、使用绝对定位配合偏移
设置子元素绝对定位：top: 50%;left:50%后，可以看见界面上子元素左上角位于父元素的中心点上；此时需要偏移设置：transform: translate(-50%, -50%)，此处的-50%是以子元素的中心点作为对其点的，实现的效果是元素在X轴方向上左移自身宽度的50%，在Y轴方向上上移自身高度的50%，从而达到真实的水平垂直居中效果。
&lt;div class="box2"&gt; &lt;div class="box3"&gt;&lt;/div&gt; &lt;/div&gt; .box2 { width: 500px; height: 500px; border: 2px solid red; position: relative; } .box3 { width: 400px; height: 400px; border: 2px solid blue; /* 绝对定位配合偏移实现居中 */ position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } 三、使用绝对定位配合外边距
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/578a0560ac9ce770fd66ac381318c470/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d733e7b77927007d63160afe96ac7bd/" rel="bookmark">
			利用MATLAB计算无限级数和泰勒级数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇内容主要对于利用MATLAB来计算无限级数和泰勒级数。
目录
1 无限级数
1.1 无限级数的定义：
1.2 symsum函数
1.3 利用MATLAB对于无限级数的示例进行求解
2 泰勒级数
2.1 泰勒级数的定义：
2.2 taylor函数
2.3 利用MATLAB对于无限级数的示例进行求解
1 无限级数 1.1 无限级数的定义： 无穷级数是研究有次序的可数或者无穷个数函数的和的收敛性及和的数值的方法，理论以数项级数为基础，数项级数有发散性和收敛性的区别。只有无穷级数收敛时有一个和，发散的无穷级数没有和。（本段定义引用自百度百科无限级数）
1.2 symsum函数 在MATLAB中提供了symsum函数用于计算无限级数，其中symsum函数的调用方式为：symsum(y,x,start,end)，其中y是一个符号表达式，表示的是该无限级数的通项，x表示的是进行计算的自变量，而start表示的是开始项，end表示的是结束项。
下面对于symsum函数进行举例，例如利用MATLAB判断下面的级数和为多少：
MATLAB代码如下所示：
syms n s=symsum(1/(n*(n+1)),n,1,Inf) 运行结果如下所示：
s = 1 利用MATLAB对于无限级数的计算可以极大地简化我们计算速度。例如，如果我们对于上述的无限级数进行计算的话，过程如下所示：
计算结果与上面MATLAB计算所得结果相同，利用对于部分求无限级数的问题MATLAB可以一定程度上进行简化操作。
1.3 利用MATLAB对于无限级数的示例进行求解 下面对于一些无限级数的示例进行求解，例如：
MATLAB代码如下所示：
syms n x1=(-1^(n-1))/(n*(n+2)) x2=1/((5*n-4)*(5*n+1)) x3=1/(n^2) x4=((-1)^(n+1))/(n^2) y1=symsum(x1,n,1,Inf) y2=symsum(x2,n,1,Inf) y3=symsum(x3,n,1,Inf) y4=symsum(x4,n,1,Inf) 运行结果如下所示：
y1 = -3/4 y2 = 1/5 y3 = pi^2/6 y4 = pi^2/12 2 泰勒级数 2.1 泰勒级数的定义： 如果f(x)在具有任意接的导数，则幂函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d733e7b77927007d63160afe96ac7bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a888cfa150ade969c1a7709f62f11b1a/" rel="bookmark">
			Vim多窗口操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、命令行命令：vim打开多个窗口2、vim底行命令：当前窗口的基础上再打开新文件3、窗口间游走（切窗口）3.1 鼠标 4、调整窗口尺寸5、关闭窗口 备注：
vim多个窗口打开同一个文件的时候，他们享受同一个文件缓冲区，在其中一个窗口编辑内容，其他窗口内容会跟着实时变化。
1、命令行命令：vim打开多个窗口 # 水平铺满，上下分割 vim -o file1 file2 file3 ... # 垂直铺满，左右分割 vim -O file1 file2 file3 ... 2、vim底行命令：当前窗口的基础上再打开新文件 # 在【左侧】打开文件(备注：不写文件名时，表示【再次打开当前文件】) :vsp new_file :vs&lt;回车&gt; # 在【上方】打开文件(备注：不写文件名时，表示【再次打开当前文件】) :sp new_file :vs&lt;回车&gt; 3、窗口间游走（切窗口） &lt;ctrl+w&gt; h/j/k/l 光标切换到：【左、下、上、右】的窗口（附：如果把hjkl换成大写，则会直接将当前光标窗口进行移动） &lt;ctrl+w&gt; t 切换到：左上角 &lt;ctrl+w&gt; b 切换到：右下角 &lt;ctrl+w&gt; p 切换到：上次一光标所在窗口 &lt;ctrl+w&gt; w 依次轮询切换窗口 num &lt;ctrl+w&gt; w 直接定位到当前screen第num个窗口（左上角是第1个，从左往右，从上往下数） 3.1 鼠标 还有一种可以使用鼠标左键点击直接切换窗口的方法，底行模式输入命令下面命令就可以直接鼠标左键点击切换窗口了：
：set mouse=a 但是这样就没法用鼠标左键选中文本复制了，取消鼠标的方法为底行模式命令：
：set mouse= 4、调整窗口尺寸 &lt;ctrl+w&gt; = 当前屏幕所有窗口【等宽且等高】 &lt;ctrl+w&gt; | 当前窗口【宽度】调到最大（竖线:shift \） &lt;ctrl+w&gt; _ 当前窗口【高度】调到最大（下划线：shift 减号） #不加num默认操作一个长度单位 num &lt;ctrl+w&gt; + 将当前窗口【增高num行】 num &lt;ctrl+w&gt; - 将当前窗口【减少num行】 num &lt;ctrl+w&gt; &gt; 将当前窗口【变宽num行】 num &lt;ctrl+w&gt; &lt; 将当前窗口【变窄num行】 -------------------------------------------------- 按键备注： # 减号 - # 等号 = # 加号 【shift =】 # 下划线：【shift 减号】 5、关闭窗口 底行模式命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a888cfa150ade969c1a7709f62f11b1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64d66434d2ef71738201b584be76f04e/" rel="bookmark">
			Ubuntu搭建dhcpv6服务器(Kea DHCP Server V1.4.0)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按如下配置之后，SLAAC，Stateless DHCP，Statefull DHCP都可以工作，而且所有模式都支持PD。
配置net.ipv6.conf.all.forwarding为1安装并配置RADVD，这个比较简单，就不再赘述了，配置如下： interface eth1 { AdvSendAdvert on; MinRtrAdvInterval 20; MaxRtrAdvInterval 60; AdvManagedFlag on; AdvOtherConfigFlag on; prefix 2001:10:10:10::/64{ AdvOnLink on; AdvAutonomous off; AdvRouterAddr off; }; RDNSS 2001:10:10:10::10 {}; }; DHCPv6服务器的配置文件如下)： 注意：配置"interfaces"之后，还要在subnet6中配置"interface"
// This is a basic configuration for the Kea DHCPv6 server. Subnet declarations // are mostly commented out and no interfaces are listed. Therefore, the servers // will not listen or respond to any queries. // The basic configuration must be extended to specify interfaces on which // the servers should listen.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64d66434d2ef71738201b584be76f04e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8603d7e326326db3b5ab55da1ac2d98a/" rel="bookmark">
			机器人SLAM Windows下基于rosjava Android APP项目源码编译运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译失败 ： Caused by: org.gradle.api.resources.ResourceException: Could not get resource 'https://github.com/rosjava/rosjava_bootstrap/raw/kinetic/buildscript.gradle'.
有没有人，有解决办法，
https://github.com/rosjava/android_appshttps://github.com/rosjava/android_apps
项目在windows上Android studio编译失败：
---------------------------更新--------------------------------- 结果：项目编译成功了 结论： Windows 系统下，VPN，VPN, VPN才能编译成功 编译效果 目前，apk,测试安装在Android 9手机完全没有问题。
环境： 在windows 10下可以编译，在window系统下可以编译，在windows系统下可以编译
***重点是***：VPN
我的环境是：window 10 64bit
Android Studio 4.1.2https://github.com/rosjava/android_apps， 这个项目根目录：buid.gradle ，注释掉这个 //task wrapper(type: Wrapper) {
// gradleVersion = '4.10.2'
//}
//task wrapper(type: Wrapper) { // gradleVersion = '4.10.2' //} buildscript { apply from: "https://github.com/rosjava/android_core/raw/kinetic/buildscript.gradle" } apply plugin: 'catkin' allprojects { group 'com.github.rosjava.android_apps' version = project.catkin.pkg.version } subprojects { apply plugin: 'ros-android' afterEvaluate { project -&gt; android { packagingOptions { /* https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8603d7e326326db3b5ab55da1ac2d98a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e88d6211e0067de5278e14cbb78b349b/" rel="bookmark">
			个人微信号API接口,微信机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义的微信机器人，需求是可以自己批量添加好友、批量打标签等进行好友管理，社群管理需要自动聊天，自动回复，发朋友圈，转发语音，以及定时群发等，还可以提取聊天内容，进行数据汇总，收藏快捷回复各种功能…
主流的路线
Web网页端：2017年后不再支持新号登录，仅支持老号，并且掉线严重，功能缺失严重。
Ipad/MAC协议：不需要实体硬件，功能较强大，行业占有率高，但由于通过grpc,mmtls破解研发，极其容易被检测有，容易出现封号的安全性问题，同时研发人员偏少，更新能力不足
PC Hook：由于是对Windows操作系统的内存进行hook，安全性会远高于上面的几种方式，功能性相比ipad协议少些，行业内具有研发能力更少，安全性、稳定性比较优秀，不会出现追封、批量封的情况
经测试Web网页端确实不能用，Ipad/MAC并没有容易被封号，提示异常的时候你确定，后面就不会再提示了，最好账号是用了很久，新号我就不知道了
目前网络售卖的一般都好几千块钱，PC Hook很多是用易语言编写，按照我自己的需求我最终选择IPAD,因为接口功能丰富，
并没有出现易被封号的问题出现。
支持项目
微信云控微商工具微信CRM清理僵尸粉微信机器人 重点
1、接口参数设置的时候记得修改版本号，不然会提示微信版本太低，无法登录
2、要想程序不死掉，要调用心跳接口
3、添加好友的时候，记得要获取userNameV1、antispamTicket 不知道哪里获取的可以咨询我。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1842b01b5a7c90da9f848541fe12d321/" rel="bookmark">
			ChatGPT可以帮我们做哪些事？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从精确发现代码中的安全漏洞到随心所欲地写一篇文章或整个功能代码块，再到打开通往另一个维度的门户，OpenAI 新推出的 ChatGPT 改变了游戏规则，它的可能性似乎只受限于你的局限性。
— 1 —
你的愿望就是我的命令
上周，OpenAI 研究实验室推出了 ChatGPT，这是一个能在你的浏览器中运行的聊天机器人，类似于你在提供客户支持聊天的网站上看到的机器人。
ChatGPT 由 GPT-3.5 系列模型提供支持，这些模型使用 Azure AI 超级计算基础设施上的文本和代码数据进行训练。人工智能的能力已经得到提升，可以处理奇怪的、技术性的、抽象的或具体的请求。
通过将其高级聊天机器人置于公共预览版中，OpenAI 希望通过了解所有用户对 ChatGPT 的要求以及该技术的性能来获得众包反馈。
需要注意的一个关键点是当前预览未连接到互联网，因此它返回的任何响应都纯粹来自离线训练的模型。ChatGPT 无法告诉你，例如，“Microsoft 当前的电话号码是多少？”或今天的天气。
但这里有 10 件很酷的事情，可以用 ChatGPT 来完成。
1. 调试你的代码，并修复它！
想知道为什么你的代码无法运行？将开发时间之外的调试周期留给 AI 策划者。
它不仅会发现错误，还会修复它们，并用简单的语言向你解释修复方法。
哪还需要程序员？
2. 检测安全漏洞，创建 PoC
如果一段代码包含安全漏洞，你也可以询问 ChatGPT。它将用简单的语言完美地向你解释判断背后的原因。
或许，让 AI 更进一步，要求它提供一个有效的概念验证（PoC）演示，让你可以利用该漏洞！
安全研究人员，你听到了——是时候找另一份工作了！
3. 部署虚拟机
研究科学家 Jonas Degrave 展示了如何将 ChatGPT 变成一个功能齐全的 Linux 终端，并直接从你的 Web 浏览器与“虚拟机”交互。
ChatGPT变成一个功能齐全的准Linux终端
实际上，并没有真正的 Linux 虚拟机在幕后运行——对命令行输入的响应完全基于与 AI 的对话，但由 ChatGPT 启动的伪 VM 似乎令人信以为真。
4. 跨维度旅行（一半时间有效）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1842b01b5a7c90da9f848541fe12d321/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aa7a1eda792effd505969386c266138/" rel="bookmark">
			Atlas配置Hbase Hook
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Atlas配置Hbase Hook 配置hbase-site.xml
在主节点HBase客户端$Hbase_HOME/conf/hbase-site.xml中追加写入：
&lt;property&gt; &lt;name&gt;hbase.coprocessor.master.classes&lt;/name&gt; &lt;value&gt;org.apache.atlas.hbase.hook.HBaseAtlasCoprocessor&lt;/value&gt; &lt;/property&gt; 解压hbase-hook包
解压hook包(这里以hbase-hook为例)，并拷贝内容到atlas安装目录下
tar -zxvf apache-atlas-2.2.0-hbase-hook.tar.gz -C /opt/atlas/atlas 创建 Atlas hook jars在HBase classpath的连接
'ln -s &lt;atlas package&gt;/hook/hbase/* &lt;hbase-home&gt;/lib/' 举例：
ln -s /opt/atlas/atlas/hook/hbase/* /opt/hbase/hbase/lib/ 复制ATLAS_HOME/conf/atlas-application.properties到HBase_HOME/conf目录下
cp /opt/atlas/atlas/conf/atlas-application.properties /opt/hive/hive/conf/ 配置atlas-application.properties，增加以下属性
######### HBase Hook Configs ####### atlas.cluster.name=primary atlas.hook.hbase.synchronous=false atlas.hook.hbase.numRetries=3 atlas.hook.hbase.queueSize=10000 atlas.kafka.zookeeper.connect=172.36.97.151:2181,172.36.97.152:2181,172.36.97.153:2181 atlas.kafka.zookeeper.connection.timeout.ms=30000 atlas.kafka.zookeeper.session.timeout.ms=60000 atlas.kafka.zookeeper.sync.time.ms=20 执行同步HBase元数据脚本
# 这里同步的是HBase中已有数据的元数据，可以通过此脚本同步过来 [root@dc6-80-283 ]# cd /opt/atlas/atlas/hook-bin/ # 执行脚本导入元数据，期间需要输入atlas的用户名和密码：admin/admin [root@dc6-80-283 ]# sh import-hbase.sh 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b196d2a6b271c74a6599f0a646eb9c17/" rel="bookmark">
			使用PageMethod.startPage分页查询 返回总数对不上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用PageMethod.startPage方法进行分页查询操作时，如果对查询结果对象进行了转换，那么就会导致最后的数据总数结果对不上，导致前端显示的总数为当前页面的数量。
示例如下，总数仅仅是当前页的十条，但其实总数不止十条。
问题代码：
​ public PageInfo&lt;ReceivedBO&gt; listOrderPage(ReceivedQueryBO queryBO) { //设置从第几页开始，每页显示多少条 PageMethod.startPage(queryBO.getPageNum(), queryBO.getPageSize()); //构建查询sql和Example Example example = Example.builder(Received.class).where(queryBO.buildSql()).build(); // 默认按照创建时间倒序排序 example.setOrderByClause("create_time desc"); List&lt;Received&gt; receiveds = receivedMapper.selectByExample(example); //将Received结果转换为ReceivedBO（对象发生变化） List&lt;ReceivedBO&gt; receivedBOList = ConverterUtils.convert(receiveds,ReceivedBO.class); return PageInfo.of(receivedBOList); } ​ 解决
public PageInfo&lt;ReceivedBO&gt; listOrderPage(ReceivedQueryBO queryBO) { //设置从第几页开始，每页显示多少条 PageMethod.startPage(queryBO.getPageNum(), queryBO.getPageSize()); //构建查询sql和Example Example example = Example.builder(Received.class).where(queryBO.buildSql()).build(); // 默认按照创建时间倒序排序 example.setOrderByClause("create_time desc"); List&lt;Received&gt; receiveds = receivedMapper.selectByExample(example); //将Received结果转换为ReceivedBO（对象发生变化） List&lt;ReceivedBO&gt; receivedBOList = ConverterUtils.convert(receiveds,ReceivedBO.class); //问题解决关键 PageInfo pageInfo = new PageInfo&lt;&gt;(receiveds); pageInfo.setList(receivedBOList); return pageInfo; } ​ 这样，问题就成功解决啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7edd4a04d5a326f83ade1975708387c6/" rel="bookmark">
			【需求】DBeaver中使用with as，下面使用as出来的表却报错说不存在，ERROR: relation “new_dppp“ does not exist
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bug bug如下：
Navicat中同样的语句可以使用，但是DBeaver中却不能使用，折腾半天，终于把问题解决了，但是不知道为什么，可能是软件本身设置如此吧
解决bug 解决方法：不要有换行，猜测是换行是独立片段，没有联系（这估计是DBeaver的特性，Navicat中不会这样）
拓展 那么的就像换行，空着美观一点怎么办，可以解决，加注释行就可以解决了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f947c60582898eb9566de0b842c8ef4/" rel="bookmark">
			TVM：一种自动端到端优化的深度学习编译器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TVM: An Automated End-to-End Optimizing Compiler for Deep Learning 提出背景 ​ 现有的 DL 框架依赖于计算图 IR 来实现优化，比如自动微分（Auto Differentiation）和动态内存管理。然而计算图层级（Graph-level）的优化对硬件后端特定算子层级（Operator-level）的变换来说，往往视角太高了。这些框架大部分关注的都是服务器级 GPU 设备中的一小撮，而把目标机相关的优化委派给高度工程化的、厂家特化的算子库。这类算子库需要大量的人工调优，也因此过于特殊化（普适性差）和不透明，导致不易于在硬件平台之间移植。即使是框架支持的后端，优化计算图时也需要在以下两个选择中权衡：
避免引入算子库中未定义的新算子（扩展性差）新算子使用未优化的实现代替（性能降级） ​ 为了使得各种硬件后端的计算图层级和算子层级优化成为可能，TVM 作为一种全新意义上的端到端（End-to-end）方法被提出。TVM 编译器从现有框架中取得 DL 程序的高层级表示，并产生多硬件平台后端上低层级的优化代码。TVM 的目标是展示与人工调优的竞争力，关键的挑战是：
平衡特定硬件的特性和抽象。DL 加速器引入了张量计算原语（Tensor Compute Primitives），但 CPU 和 GPU 有各自的数据处理形式（标量、向量），如何将多维度的数据布局通过变换，使之适合处理器和内存层级（Memory Hierarchy），是一个巨大的挑战。此外，加速器设计普遍偏好控制精简性的设计，而将任务调度的复杂性下放到编译栈上。对于某些特定的加速器，编译器甚至需要产生能够显式解决流水线数据依赖的代码，来“隐藏”内存访问的延迟（Memory Access Latency Hiding）。优化存在海量的搜索空间。安排内存访问、线程模式和新硬件原语（Hardware Primitives）等元素是排列组合级别的复杂度，如果实现一个黑箱来自动调优会带来巨大的搜索开销。也许我们可以预定义一个开销模型来指导搜索，但是现代硬件的复杂程度是不断增长的（而且速度很快），精确建模的难度非常大，更不用说还得给每一种硬件类型都独立建模了。 主要工作 ​ TVM 提出了三个重要模块：
张量表达语言（Tensor Expression Language）和变换原语（Transformation Primitives）。这是对 Halide 计算调度解耦理念的扩展，把硬件本质（Hardware Intrinsic）和变换原语也分离了，使得 TVM 可以支持新的加速器和对应的硬件本质。自动程序优化框架（Automated Program Optimization Framework）。使用一个基于 ML 的开销模型来指导如何寻找最优张量算子，当收集到更多硬件后端的数据时，模型的适应性和表现会不断提升。计算图重写（Graph Rewriter）。作用于自动代码生成器上层，统筹计算图级和算子级的联合优化。 工作流程 ​ TVM 的工作流程：
读取现有框架中的模型，产生计算图表示进行高层级数据流重写（High-level Dataflow Rewriting），产生优化后的计算图进行算子层级优化，为计算图中的融合算子（Fused Operator）产生高效代码算子由张量表达语言声明，执行细节不需要指定利用 ML 开销模型从目标机潜在的优化集合中，搜索算子的最优代码将生成的代码包装为可部署的模块 优化计算图（Optimizing Computational Graphs） ​ 计算图是一种高级表示，提供了对于算子的全局视野，而不需要指明实现的细节。就像 LLVM IR，计算图也可以转换成功能等价的子图，以适合各种优化手段。TVM 对计算图的优化包括：算子融合（Operator Fusion）、常量折叠（Constant Folding）、静态内存规划（Static Memory Planning）、数据布局变换（Data Layout Transformation）等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f947c60582898eb9566de0b842c8ef4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/209137f6d87894a517aad1b94a6d1b97/" rel="bookmark">
			qmake source code 解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qmake 主要框架流程 qmake的主要功能执行入口在main.cpp中的runQMake(int argc, char **argv)中。其主要框架流程如下:
runQMake(int argc, char **argv){ QMakeVfs vfs; //初始化qmake的文件系统。virtual file system。vfs会为每个文件赋予一个id,并提供根据id进行操作的函数。 Option::vfs = &amp;vfs; QMakeGlobals globals; Option::globals = &amp;globals; globalst提供配置查询环境参数和操作环境变量相关的一些函数。 ....... Option::init(argc, argv); //初始化参数 ..... QMakeProperty prop; //初始化property。构造函数中调用QMakeProperty 的reload函数。 .... QMakeParser parser(&amp;proFileCache, &amp;vfs, &amp;Option::evalHandler);//创建parser对象，parser的主要作用是将脚本代码转换成ProToken类型的数据，并存放到Profile对象中的m_proitems中。 Option::parser = &amp;parser; ...... QMakeProject project;//创建qmake工程，构造函数参数会使用到option::parser，并赋予成员变量其m_parser，结构中的成员最终用于辅助生成makefile //QMakeProject::QMakeProject(): QMakeEvaluator(Option::globals, Option::parser, Option::vfs, &amp;Option::evalHandler){} ....... project.read(fn) //加载和解析(词法语法语义)配置文件（.prl、pri、.conf、.prf），解析工程pro文件 ...... MetaMakefileGenerator *mkfile = MetaMakefileGenerator::createMetaGenerator(&amp;project, QString(), false, &amp;success); //创建makefile对象向，内部通过生成SubdirsMetaMakefileGenerator或BuildsMetaMakefileGenerator对象，初始化并返回。 ..... mkfile-&gt;write() //生成Makefile.Debug、Makefile.Release、Makefile三个文件。 } QMakeProject是整体的架构，他继承与QMakeEvaluator，用于描述一个qt工程，除了完成处理语法和语义分析的QMakeEvaluator的功能，还会做一些工程相关的处理（比如路径、缓存文件）。一个QMakeProject对象含有一个用于处理词法分析的QMakeParser对象成员。QMakeProject做完解析后，作为参数传入MetaMakefileGenerator对象中，生成makefile文件。
解析从QMakeProject的read函数开始，内部会调用QMakeEvaluator::evaluateFile()。开始进行词法和语法分析。
词法分析 QMakeParser对象进行语法分析。QMakeParser主要作用是将qmake language语法的代码进行标记化（tokenized），将原始代码全部解析成ProToken类型的数据，解析内容放到Profile对象的m_proItems成员中。主要操作在QMakeParser::read中，read的调用堆栈如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/209137f6d87894a517aad1b94a6d1b97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5434ac83f81c62fef6d8ae168bbdbb1/" rel="bookmark">
			C#实现两个线程交替打印1-100
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目说明 题目：两个线程交替打印输出数字1-100，一个线程只打印偶数，另一个只打印奇数，并且要求按顺序输出。
最近看到了这个题目，想到了几种实现的方式，记录一下，如果有写的不对的地方，欢迎指正！！！
代码实现 方法一 可以通过两个外部的变量，去控制是打印奇数还是偶数，下面是实现的代码
class Program { public static int i = 1; public static bool isprintOddNumber = false;//控制基数的变量,判断是否可以进行打印奇数 public static bool isprintEvenNumber = false;//控制偶数的变量，判断是否可以进行打印偶数 static void Main(string[] args) { Thread thOdd = new Thread(printNumOdd);//奇数线程 Thread thComplex = new Thread(printNumComplex);//偶数线程 isprintOddNumber = true;//刚开始的时候可以打印奇数 isprintEvenNumber = false;//偶数控制不能打印 thOdd.Name = "奇数"; thComplex.Name = "偶数"; thOdd.Start(); thComplex.Start(); Console.Read(); } private static void printNumOdd() { while(i&lt;100) { if (i % 2 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5434ac83f81c62fef6d8ae168bbdbb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/605615d7902cda056c81c9bccc6fef2d/" rel="bookmark">
			时间排序(Date)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间排序 处理杂乱的各种汇总数据并将其按照时间顺序返回给前端，需要先对所有日期进行汇总并排序后追加各项时间下的数据，以下记录针对个时间点的排序代码（正序，倒序则将return中的o1和o2交换位置）
入参：xs
格式：String类型的时间
出参：res
格式：String类型的时间
public List&lt;String&gt; getSortDate(List&lt;String&gt; xs) { List&lt;String&gt; res = new ArrayList&lt;&gt;(); Collections.sort(xs, new Comparator&lt;String&gt;() { DateFormat f = new SimpleDateFormat("yyyy-MM"); @Override public int compare(String o1, String o2) { try { return f.parse(o1).compareTo(f.parse(o2)); } catch (ParseException e) { throw new IllegalArgumentException(e); } } }); StringBuffer now = new StringBuffer(); ArrayList&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); //用已经排序好的时间对带时间类型的进行对比,获取排序好并且带时间类型 for (int i = 0; i &lt; xs.size(); i++) { String aa = xs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/605615d7902cda056c81c9bccc6fef2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23167b962ac3ebbfe6ebbf7a89f09bf0/" rel="bookmark">
			【JavaScript】——JS数组的方法（全且详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建数组 1、使用数组字面量方法 var arr1 = []; // 创建一个数组 var arr2 = [10]; // 创建一个数组长度为10的数组 var arr3 = ['a','b','c']; // 创建一个包含3个字符串的数组 2、使用Array构造函数 无参构造
var arr1 = new Array(); // 创建一个空数组 带参构造
如果只传一个数值参数，则表示创建一个初始长度为指定数组的空数组
var arr2 = new Array(10); // 创建一个数组长度为10的数组 如果传入一个非数值的参数或者参数大于1，则表示创建一个包含指定元素的数组
var arr3 = new Array('a','b','c'); // 创建一个包含3个字符串的数组 3、Array.of方法创建数组(es6新增) Array.of()方法会创建一个包含所有传入参数的数组，而不管参数的数量与类型
let arr1 = Array.of(1,2); console.log(arr1.length); // 2 let arr2 = Array.of(3); console.log(arr2.length); // 1 console.log(arr2[0]); // 3 4、Array.from方法创建数组(es6新增) 在js中将非数组对象转换为真正的数组是非常麻烦的。在es6中，将可迭代对象或者类数组对象作为第一个参数传入，Array.from()就能返回一个数组
function arga(...args){ // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23167b962ac3ebbfe6ebbf7a89f09bf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6822d512b99e51907a71cb7ff614d384/" rel="bookmark">
			vs qt 调试 输出 打印 到输出窗口 或控制台窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		printf只能输出 到控制台窗口。
一、qt Qt日志重定向（将qDebug信息输出到界面控件）_wx61a586bb4cf91的技术博客_51CTO博客
Windows版qt中，如果是一个控制台应用程序，文本将被发送到控制台；否则，被发送到调试器。
也就是qt中，对于非Qt console Application工程，默认的qDebug()会输出到qt creator 的应用程序输出窗口
在这种情况下，printf（）、fprintf(stdout...)、fpritnf(stderr...) 标准输出都无法显示。只有开启控制台窗口以及设置输出到控制台窗口才能将标准输出显示出来。下面两个步骤是设置输出到控制台(DOS)窗口以及开启控制台窗口。
1、在.pro 文件中添加 CONFIG += console， qt 日志输出将显示到控制台（DOS）窗口，qDebug（）输出的信息将输出到控制台（DOS）窗口，传统的pring()、fprintf(stdout...)、fprinf(stderr,..)默认显示到控制台（DOS）窗口
等价于 在 项目配置中 ，qmake 额外参数项中加入 "CONFIG+=console"
2、勾选run in terminal ，显示控制台窗口，不勾选的话，将无法显示控制台(DOS)窗口
可能存在设置完之后控制台窗口无法显示的情况，需要选中工程，右键选择 清理、构建。
关于脚本文件的日志输入和输出 脚本文件(*.pro，*.prl，*.pri，*.conf，*.prf)是由qmake进行解释的，可以通过message()/warning()/error()等函数输出到qt creator的概要信息窗口。脚本有提供一个promt的输入函数，但是需要在dos窗口中通过命令行运行qmake才能进行输入。
参考 prompt(question, [decorate])
关于qt 中的qDebug() qDebug()在windows中是调用windows api OutputDebugString()函数。
qDebug就是一个宏定义，最终都指向QMessageLogger的debug函数：
#define qDebug QMessageLogger(QT_MESSAGELOG_FILE, QT_MESSAGELOG_LINE, QT_MESSAGELOG_FUNC).debug debug函数有多种重载，有的会直接运行出结果；有的会构建并返回QDebug对象，QDebug类重载了流操作符，使得qDebug可以使用流操作符 qDebug()&lt;&lt;"This is a debug message."; 。但最终都会调用下面的函数。
static void qt_message_print(QtMsgType, const QMessageLogContext &amp;context, const QString &amp;message); 二、visual studio 1、vs 中有一个OutputDebugString （Windows.h中）函数，在所有窗体程序中都可以输出到vs的输出窗口，在调试窗体程序，无控制台窗口时，想打印参数，那么这个函数就很有用了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6822d512b99e51907a71cb7ff614d384/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74e5ccf3d8254764edc710ad6f8b06f3/" rel="bookmark">
			如何使用AES加解密提高项目安全性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装依赖并引入 yarn add crypto-es jsencrypt
CryptoES.mode： ECB、CBC（需要多加一个偏移量iv）
import CryptoES from 'crypto-es'; import JSEncrypt from 'jsencrypt'; 注： 引入后报错 Can't resolve './JSEncrypt'
解决方法：
原始webpack配置修改 // webpack配置 module.rules添加 { test: /\.m?js/, resolve: { fullySpecified: false } } 使用 config-overrides.js修改webpack配置 const path = require('path'); const { override, addWebpackModuleRule } = require('customize-cra'); module.exports = override( addWebpackModuleRule( { test: /\.m?js/, resolve: { fullySpecified: false } } ), ) 一、非对称加解密 前后端用公钥加密，AES 解密
加密
REACT_APP_SSOPUBLICKEY 公钥存储在环境变量中（.env） // 与后端约定共同使用公钥加密 const encryptor = new JSEncrypt(); encryptor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74e5ccf3d8254764edc710ad6f8b06f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41badc9220e923926130bd9138449fd9/" rel="bookmark">
			结合函数式接口 Supplier 使用熔断器 Hystrix
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 如果你只需要使用 Hystrix 的注解形式就够了，那本篇文章对你没什么意义，但如果是采用继承 HystrixCommand 类进行使用，可以结合函数式接口 Supplier 进行更解耦的实现，对业务的侵入小，并且代码的相互依赖低
代码 我们先来看一段代码
private Boolean equal(String s1, String s2) { return equalStr(s1, s2); } private Boolean equalStr(String s1, String s2) { return s1.equals(s2); } 只采用继承 HystrixCommand 类进行使用 如果你直接把这段代码采用继承 HystrixCommand 类进行使用，并且用s1作为熔断标识
private Boolean equal(String s1, String s2) { return new StrCommand(s1, s2).execute(); } public class StrCommand extends HystrixCommand&lt;Boolean&gt; { private String s1; private String s2; public StrCommand(String s1, String s2) { // 熔断标识 super(Setter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41badc9220e923926130bd9138449fd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2bf6fce081637249441d39e166494cd/" rel="bookmark">
			字符串相似及匹配 Jaro-Winkler
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 String str1 = "明天吃红烧肉"; String str2 = "明天中午吃红烧肉"; String str3 = "明天吃红烧肉？"; String str4 = "吃红烧肉"; 用普通的相等判断，只能得到是或否，但如果你在实际的业务需求中，有需要用到两个字符串的相似程度，做进一步的逻辑判断，那么在 Java 的轮子里，我推荐你使用 java-string-similarity
我只讲有用的部分：怎么拿到两个字符串的相似值，我浏览了一下我自己查找资料时所看的博客，有用的关键部分全都七零八落，所以看完这篇文章，保证你开箱即用，我会直接推荐一个我实际应用的相似度算法，并写一个demo
java-string-similarity 你只需要知道，这是个提供各种字符串相似度算法的三方库就好了，总共有十几种算法供君选用，我推荐在我看来，实际意义最大的一个算法：Jaro-Winkler，其他的算法还不如去搞elasticsearch
Jaro-Winkler 基于两个字符串之间的公共字符的数量和顺序，它考虑了典型的拼写偏差，使用前缀比例，对从头匹配的字符串给予更大的权重
说人话就是，在我看来，这个算法，和普通人判断两个字符串的相似程度的逻辑是一致的，头部越像，权重越高，尾部相像，权重不大
先看下运行结果：
如果关键字在句子的后面部分，相似度会急剧下降，这种情况就需要你另外在java-string-similarity，找寻合适的算法了
demo maven 引入 &lt;dependency&gt; &lt;groupId&gt;info.debatty&lt;/groupId&gt; &lt;artifactId&gt;java-string-similarity&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; 使用 public static void main(String[] args) { JaroWinkler jaroWinkler = new JaroWinkler(); String str1 = "明天吃红烧肉";; String str2 = "明天中午吃红烧肉"; String str3 = "明天吃红烧肉？"; String str4 = "吃红烧肉"; System.out.println(str1 + " 和 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2bf6fce081637249441d39e166494cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5890797c7abdebb02638848ebe77de6b/" rel="bookmark">
			什么是HTTPS证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是HTTPS证书
HTTPS证书（即SSL证书）。HTTPS证书是颁发给标识互联网域名的数字证书，证书作用为建立SSL加密通道。
二、HTTPS证书的作用
HTTPS主要是为敏感数据和交易（如账单明细、信用卡交易和用户登录等）提供不安全HTTP协议之上的增强安全层。HTTPS使用SSL或TLS加密技术加密转换中的每个数据包，以避免中间黑客和攻击者提取数据帐篷；即使连接被破坏。
三、HTTPS概念
​ 超文本传输协议安全（HTTPS）是标准Web传输协议（HTTP）的一个变体，它通过安全套接字层（SSL原理）或传输层安全（TLS）协议连接为传输中的数据添加一层安全性。
四、HTTP与HTTPS的区别
什么是HTTP？HTTP是一种协议，其完整形式是超文本传输协议，允许您将超文本传输到HTTP协议。超文本的问题是什么？超文本是指网络文本、链接以及基于网络的内容，如照片、音频、视频等。ssl证书申请可以找蔚可云
从地址栏中的地址栏复制您的网站地址，在域名的开头有http或https，它指定使用哪个端口和使用协议的基于Web的内容。
HTTPS的主要区别在于超文本传输协议的安全性，而HTTP的主要区别在于，在HTTPS中使用一个站点时，数据是加密的，因此数据是安全的。现在很多网站都使用e-https协议，尤其是那些网站——有支付系统或不同的银行。此外，电子邮件服务提供商或社交媒体网站也使用HTTPS协议。
使用HTTPS协议的网站，将在地址栏中看到他们的地址，然后绿色将被赋予他们的全名，如果鼠标移过地址栏，将显示此网站的验证来源。前面有一个绿色的锁，点击小锁，可以看到数字证书。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c0d143576f205841f1575510fc673c0/" rel="bookmark">
			STM32&#43;雷龙SD NAND(贴片SD卡)完成FATFS文件系统移植与测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 在STM32项目开发中，经常会用到存储芯片存储数据。 比如：关机时保存机器运行过程中的状态数据，上电再从存储芯片里读取数据恢复；在存储芯片里也会存放很多资源文件。比如，开机音乐，界面上的菜单图标，字库文件，方便设备开机加载。
为了让单片机更加方便的读写这些资源文件，通常都会加文件系统，如果没有文件系统，直接读取写扇区的方式，对数据不好管理。 这篇文章就手把手教大家，在STM32上完成FATFS文件系统的移植；主控芯片采用STM32F103ZET6， 存储芯片我这里采用（雷龙） CS创世 SD NAND 。 SD NAND 简单来说就是贴片式SD卡，使用起来与普通的SD卡一样，简单的区别就是：比TF卡稳定，比eMMC便宜。 下面章节里会详细介绍下 CS创世 SD NAND。
下面是CS创世 SD NAND 与STM32开发的板的接线实物图：
这是读写扇区测试的结果：
二、SD NAND 介绍 我当前使用的SD NAND型号是，CSNP32GCR01-AOW，容量是4GB。
下面是通过编写STM32代码读取的存储信息：
Card Type:SDHC V2.0 Card ManufacturerID:102 Card RCA:5000 Card Capacity:3696 MB Card BlockSize:512 芯片的详细参数如下：
【1】不用写驱动程序自带坏块管理 【2】尺寸小巧，简单易用，兼容性强，稳定可靠，固件可定制，LGA-8封装 【3】标准SDIO接口，兼容SPI，兼容拔插式TF卡/SD卡，可替代普通TF卡/SD卡 【4】尺寸6.2x8mm，直接贴片，不占空间 【5】内置平均读写算法，通过1万次随机掉电测试 【6】耐高低温，机贴手贴都非常方便 【7】速度级别Class10（读取速度23.5MB/S写入速度12.3MB/S） 【8】支持标准的SD 2.0协议，用户可以直接移植标准驱动代码，省去了驱动代码编程环节。支持TF卡启动的SOC都可以用SD NAND 【9】比TF卡稳定，比eMMC便宜 **下面是芯片的实物图： ** 这是官网申请的样品，焊接了转接板，可以直接插在SD卡卡槽上测试。 最终选型之后，设计PCB板时，设计接口，直接贴片上去使用，非常稳定，抖动也不会导致，外置卡TF卡这种容易松动的问题。
这是雷龙的官网： http://www.longsto.com/product/35.html
三、编写SD NAND驱动代码 SD NAND 的驱动代码与正常的SD卡协议是一样的，支持标准的SD 2.0协议，下面我就直接贴出写好的驱动代码。
包括了模拟SPI，硬件SPI，SDIO等3种方式，完成对SD NAND 的读写。我当前使用的主控板子是STM32F103ZET6，如果你使用的板子不是这一款，可能还是其他的CPU也没关系；我这里直接贴出了SPI模拟时序的驱动代码，可以直接移植到任何单片机上使用，代码拷贝过去也只需要修改GPIO口即可，非常方便。
3.1 SPI模拟时序驱动方式 （1）整体工程代码 这是当前工程的截图: 代码采用寄存器风格编写，非常简洁。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c0d143576f205841f1575510fc673c0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/183/">«</a>
	<span class="pagination__item pagination__item--current">184/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/185/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>