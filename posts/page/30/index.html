<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aef5bdcb40a1b258d8acb60971448d16/" rel="bookmark">
			Pandas教程（非常详细）（第五部分）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接着Pandas教程（非常详细）（第四部分），继续讲述。
二十五、Pandas sample随机抽样 随机抽样，是统计学中常用的一种方法，它可以帮助我们从大量的数据中快速地构建出一组数据分析模型。在 Pandas 中，如果想要对数据集进行随机抽样，需要使用 sample() 函数。
sample() 函数的语法格式如下：
DataFrame.sample(n=None, frac=None, replace=False, weights=None, random_state=None, axis=None) 参数说明如下表所示：
参数名称参数说明n表示要抽取的行数。frac表示抽取的比例，比如 frac=0.5，代表抽取总体数据的50%。replace布尔值参数，表示是否以有放回抽样的方式进行选择，默认为 False，取出数据后不再放回。weights可选参数，代表每个样本的权重值，参数值是字符串或者数组。random_state可选参数，控制随机状态，默认为 None，表示随机数据不会重复；若为 1 表示会取得重复数据。axis表示在哪个方向上抽取数据(axis=1 表示列/axis=0 表示行)。 该函数返回与数据集类型相同的新对象，相当于 numpy.random.choice()。实例如下：
import pandas as pd dict = {'name':["Jack", "Tom", "Helen", "John"],'age': [28, 39, 34, 36],'score':[98,92,91,89]} info = pd.DataFrame(dict) #默认随机选择两行 info.sample(n=2) #随机选择两列 info.sample(n=2,axis=1) 输出结果：
name age score
3 John 36 89
0 Jack 28 98
score name
0 98 Jack
1 92 Tom
2 91 Helen
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aef5bdcb40a1b258d8acb60971448d16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/221c9efa85a88bdf8133bdb58ebbbca9/" rel="bookmark">
			设计循环队列——oj题622
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.
个人主页：晓风飞 专栏：LeetCode刷题|数据结构|Linux 路漫漫其修远兮，吾将上下而求索 文章目录 题目要求：应该支持如下操作：示例：提示： 结构体定义队列的创建基本操作判断队列是否为空：判断队列是否已满：入队操作：出队操作：获取队首和队尾元素：内存释放 难点解释难点1难点2难点3 要做题目的点击这里–&gt;队列oj题——622.设计循环队列
题目要求： 设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。
循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。
应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。
Front: 从队首获取元素。如果队列为空，返回 -1 。
Rear: 获取队尾元素。如果队列为空，返回 -1 。
enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。
deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。
isEmpty(): 检查循环队列是否为空。
isFull(): 检查循环队列是否已满。
示例： MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
circularQueue.enQueue(1); // 返回 true
circularQueue.enQueue(2); // 返回 true
circularQueue.enQueue(3); // 返回 true
circularQueue.enQueue(4); // 返回 false，队列已满
circularQueue.Rear(); // 返回 3
circularQueue.isFull(); // 返回 true
circularQueue.deQueue(); // 返回 true
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/221c9efa85a88bdf8133bdb58ebbbca9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d520225c106cda5c4d476ac279036e6/" rel="bookmark">
			每日一道算法题day-three(备战蓝桥杯)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽大家好，今天来给大家带来每日一道算法题系列第三天，让我们来看看今天的题目，一起备战蓝桥杯
题目： 小 Y的桌子上放着 n 个苹果从左到右排成一列，编号为从 11 到 n。
小苞是小 Y 的好朋友，每天她都会从中拿走一些苹果。
每天在拿的时候，小苞都是从左侧第 11 个苹果开始、每隔 22 个苹果拿走 11 个苹果。
随后小苞会将剩下的苹果按原先的顺序重新排成一列。
小苞想知道，多少天能拿完所有的苹果，而编号为 n 的苹果是在第几天被拿走的？
输入格式 输入的第一行包含一个正整数 n，表示苹果的总数。
输出格式 输出一行包含两个正整数，两个整数之间由一个空格隔开，分别表示小苞拿走所有苹果所需的天数以及拿走编号为 n 的苹果是在第几天。
数据范围 对于所有测试数据有：1≤n≤10^9
解题思路： 1 2 3 4 5 6 7 8
题里说每隔着两个苹果拿走一个，所以这段数字的变化规律就是：
2 3 5 6 8
3 5 8
5 8
5
8
首先观察这个题的数据范围，10的九次方，所以我们不能一一个一个的枚举每次拿的苹果，但我们可以一天一天的枚举
怎么样的一天一天的枚举呢，比如说我们现在有n个苹果，每天可以进行隔一个拿一个的操作，那么模拟下来我们每天大约拿三分之一的苹果，也就是三分之n（n/3）每隔两个苹果拿一个苹果，就是（n+2）/3的上取整，什么是上取整：
上取整： 关于上取整，我们可以通过一个函数来了解：
ceil函数： 功能：把一个小数向上取整
即就是如果数是2.2 ，那向上取整的结果就为3.000000
原型：double ceil(doube x);
参数解释：
x:是需要计算的数
返回值：
成功：返回一个double类型的数，此数默认有6位小数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d520225c106cda5c4d476ac279036e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddaeae1e5048fba65e32a50f515626bd/" rel="bookmark">
			接口功能测试策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于平台服务器是通过接口来与客户端交互数据提供各种服务，因此服务器测试工作首先需要进行的是接口测试工作。测试人员需要通过服务器接口功能测试来确保接口功能实现正确，那么其他测试人员进行客户端与服务器结合的系统测试过程中，就能够排除由于服务器接口缺陷所导致的客户端问题，便于开发人员定位问题。以下便是个人的平台服务器接口功能测试经验总结:
一、接口测试范围
根据服务器的测试需求，接口测试范围主要分为：1、新增接口的测试；2、新增业务功能接口测试；3、整个服务器的接口测试。所需测试测试接口依次增多，在测试时间足够的条件下，当然需要对所有接口进行测试用例的设计，但如果测试较短的情况下，则应该首先根据用户的典型操作对测试接口进行优先级划分，对调用频繁接口需要优先进行测试。
二、接口测试策略
在进行平台服务器接口测试之前，首先需要整理服务器接口的测试方案，分析接口测试的要点，平台服务器的接口测试内容主要有：
接口设计检查
接口用于服务器与客户端的数据交互，客户端通过网络协议传递的数据为服务器接口的输入数据，因此应该首先通过服务器接口文档及客户端数据约束文档进行交互数据的有效性检查：
n 整数型数据位数
n 浮点型数据精度
n 字符串数据范围值
要求客户端的整数型、浮点型、字符串数据以及其最大值和最小值都能作为服务器接口的有效输入。这些工作在服务器设计评审时就可以进行，以便确保不会出现客户端上传数据被服务器自动进行截断或四舍五入的操作。
接口依赖关系检查
以上策略只谈到单个接口的测试方法，对于用户来说，一个操作可能会造成服务器调用多个接口来进行完成，因此还需要从业务处理的角度，对各种业务操作所涉及的多个接口之间依赖调用进行测试。
接口依赖关系检查主要是通过接口的输出值为另一接口的输入值来实现的，因此在进行接口测试之前，需要分析所测试接口的输入值是通过客户端还是其他接口输出来获取的，在设计测试用例时，加入接口的依赖关系说明以便于测试。
接口输入/输出验证
服务器接口功能测试类似于单元测试，在设计测试用例时，侧重点在于接口模块输入/输出项的正确性验证，根据接服务器接口处理方式，对各种接口进行分类：
第一类：条件判断接口
这类接口在接收到请求数据后，会根据输入参数进行条件判断，然后返回相应结果码，通常涉及条件判断的接口有：用户鉴权接口、升级状态上报、密码修改/重置等接口。因此输入/输出项验证的侧重点主要集中在：
1）判断条件的验证
要对判断条件进行验证，则需要知道接口是根据哪些输入项来进行判断的，以密码重置接口为例：
密码重置接口
『接口功能』：用户登录之后发起找回密码操作，用户输入邮箱信息后，游戏中心将向平台服务器发送请求，平台服务器将随机为用户生成新的密码，发到用户的邮箱中。
『接口方向』：游戏中心—&gt;平台服务器
『遵循协议』：HTTPS，请求消息使用Post方式
参数名称
参数类型
参数长度
说明
userID
Int
10
用户ID号
email
String
60
邮箱地址
key
String
50
接口名称
version
String
8
版本号
响应消息（sendMessageRes）
参数名称
参数类型
参数长度
说明
resultCode
Int
5
结果返回码，返回42000表示处理成功
此接口根据输入的userID、email参数来进行数据正确性的判断（key是接口名称，如果错误服务器将不会处理，version是版本号，其值只是用于记录，不参与判断），设计接口测试用例时，应该首先对接口的判断参数进行验证，这些输入项不能为空，然后利用等价类划分、边界值方法来根据userID、email输入项设计各种合法的数据，验证接口是否可以正常处理。
2）异常数据的响应
只考虑正常情况，而不考虑异常场景是无法保证接口功能运行正常，对于密码重置接口，用户ID不存在、不合法，邮箱输入格式错误、用户邮箱信息不存在或未激活就是测试时需要考虑的异常场景，设计这类输入值，并且检查接口返回的响应码，响应码的正确才能保证客户端根据异常情况来显示相应的提示信息。简而言之，条件判断的接口其测试策略就是根据判断条件来设计各种输入值来检验接口的功能。
第二类：数据查询接口
这类接口接收到请求数据后，首先会验证请求是否合法，然后会根据请求项查询数据库相应表中数据返回给客户端，通常涉及数据查询的接口有：用户基本资料/经验值/赛事信息查询、游戏列表获取、在线人数查询等接口。以用户经验值查询接口为例：
用户经验值查询接口
『接口功能』：用户登录游戏中心后，可以查询自己每个游戏项目的经验值信息，包括此项目的经验值等级、等级称号、今日经验值上限等。
『接口方向』：游戏中心—&gt;平台服务器
『遵循协议』：HTTP+XML，请求消息使用Post方式
响应消息（sendMessageRes）
此接口首先会根据webkey来判断请求是否合法，然后根据请求参数中的userID、isAll、sportItemID来查询数据表中相应数据。除了象条件判断接口一样根据判断项webkey、请求参数userID、isAll、sportItemID设计合法/不合法和正常/异常测试值之外，还需要结合数据库来对查询结果进行验证:
1）是否根据正确的关联数据表进行查询；
2）验证查询结果是否从数据表中正确项中获取，涉及到多表联合查询时，不同表中的相同项设计不同测试数据进行验证；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddaeae1e5048fba65e32a50f515626bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/432f3a14833f8d098a330ad755598515/" rel="bookmark">
			【排序算法总结】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 稳点与非稳定排序2. 冒泡排序3. 简单选择排序4. 直接插入排序5. 快排6. 堆排7. 归并 1. 稳点与非稳定排序 不稳定的：快排、堆排、选择原地排序：快排也是非原地排序：归并 和三个线性时间排序：桶排序 ，计数，基数 2. 冒泡排序 时间复杂度 O(n*n)空间复杂度 O(1)稳定 public class ReviewToo { //1.冒泡排序 时间复杂度 O(n*n) 空间复杂度 O(1) 稳定 public int[] BubbleSort(int[] a) { int temp;//空间复杂度的体现 boolean flag; o: for (int i = 1; i &lt; a.length; i++) { flag = false; for (int j = 0; j &lt; a.length - i; j++) { if (a[j] &gt; a[j + 1]) { temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; flag = true; } } if (flag == false) { break o; } } return a; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/432f3a14833f8d098a330ad755598515/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f430319c8f5b211dec72e76d3846e13/" rel="bookmark">
			嵌入式中的数据初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 数值类 变量初始化 整型、浮点型的变量可以在定义的同时进行初始化，一般初始化为 0.
int num = 0; float fnum = 0.21f; double dnum = 0.32; 2. 字符型 变量初始化 字符型变量也可在定义的同时进行初始化，一般初始化为 '\0'。
char ch = '\0'; 3. 字符串初始化 字符串初始化的方法比较多，这里简单介绍三种方法，因为字符串本质上是由一个个字符组成的字符数组，所以其初始化的最终目的，就是将字符数组里面的一个个字符都初始化为'\0';
方法一：使用空的字符串"";
char str2[10] = ""; 方法二：使用memset。
char str2[10]; memset(str2, 0, sizeof(str2)); 方法三：写一个循环。
char str2[10]; for (int i = 0; i &lt; 10; i++) { str2[i] = '\0'; } 比较推荐使用方法二，也即使用 memset 进行初始化。
注：很多人对memset这个函数一知半解，只知道它可以初始化很多数据类型的变量，却不知道其原理是什么样的，这里做一下简要的说明：memset是按照字节进行填充的。
先看下面的一段代码：
int num; memset(&amp;num, 0, sizeof(int)); printf("step1 = %d\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f430319c8f5b211dec72e76d3846e13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06bd8ff6f83e973255e3e38e166517f1/" rel="bookmark">
			【电路笔记】-电感器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电感器 文章目录 电感器1、概述2、电感器的时间常数3、电感器示例1 电感器是一种由线圈组成的无源电气元件，其设计目的是利用电流通过线圈而产生的磁力和电力之间的关系。 1、概述 在本中，我们将看到电感器是一种电子元件，用于将电感引入到电路中，它阻止电流大小和方向的变化，并且即使是一根直的导线也可能具有一定量的电感 。
在我们有关电磁学的教程中，我们看到当电流流过导线时，会在该导体周围产生磁通量。 这种影响会产生围绕导体循环的磁通量方向与流过同一导体的电流方向之间的关系。 这导致了电流和磁通量方向之间的关系，称为“弗莱明右手定则”。
但是，还存在与缠绕线圈相关的另一个重要特性，即当磁通量反对或抵抗流过它的电流的任何变化时，通过磁通量的运动将次级电压感应到同一线圈中。
就其最基本的形式而言，电感器只不过是缠绕在中心磁芯上的线圈。 对于大多数线圈，流过线圈的电流 ( i i i ) 会在其周围产生与电流成比例的磁通量 ( N ϕ N\phi Nϕ )。
电感器，也称为扼流圈，是另一种无源类型的电气元件，由线圈组成，设计为利用这种关系，通过流经线圈的电流在其本身或其核心内感应出磁场。 将线圈形成电感器会产生比简单线圈产生的磁场强得多的磁场。
电感器由紧紧缠绕在实心中心芯上的电线形成，该中心芯可以是直圆柱形杆，也可以是连续的环或环，以集中磁通量。
电感器的原理图符号是线圈的符号，因此线圈也可以称为电感器。 电感器通常根据其缠绕的内芯类型进行分类，例如空芯（自由空气）、实心铁芯或软铁氧体芯，不同的芯类型通过在芯线旁边添加连续或平行点线来区分。 线圈如下图所示。
流经电感器的电流 i 产生与其成比例的磁通量。 但与阻止极板上电压变化的电容器不同，电感器由于其磁场内自感能量的积累而阻止流过其的电流变化率。
换句话说，电感器抵抗或阻止电流的变化，但很容易通过稳态直流电流。 电感器抵抗电流变化的能力，以及将电流 i 与其磁通链 N ϕ N\phi Nϕ 作为比例常数联系起来的能力称为电感，其符号为 L L L，单位为亨利 ( H H H)，以约瑟夫·亨利 (Joseph Henry) 命名。
由于亨利本身就是一个相对较大的电感单位，因此对于较小的电感器，亨利的子单位用于表示其值。 例如：
电感前缀 因此，为了显示亨利的子单位，我们将使用以下示例：
1mH = 1 毫亨利 – 等于亨利的千分之一 (1/1000)。
100μH = 100 微亨利 – 等于百万分之 100 (1/1,000,000) 亨利。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06bd8ff6f83e973255e3e38e166517f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f77471cb3f049ce814361c5c4e83d027/" rel="bookmark">
			GitHub 删除仓库 (Delete this repository)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub 删除仓库 [Delete this repository] References 在待删除的 repository 界面下，点击 Settings Settings 最下端，Danger Zone Delete this repository References [1] Yongqiang Cheng, https://yongqiang.blog.csdn.net/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f160beb8763cbf37329cc7e99a042d7f/" rel="bookmark">
			给新手的25个建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
最近知乎上，有一位大佬邀请我回答下面这个问题，看到这个问题我百感交集，感触颇多。
在我是新人时，如果有前辈能够指导方向一下，分享一些踩坑经历，或许会让我少走很多弯路，节省更多的学习的成本。
这篇文章根据我多年的工作经验，给新人总结了25条建议，希望对你会有所帮助。
1.写好注释 很多小伙伴不愿意给代码写注释，主要有以下两个原因：
开发时间太短了，没时间写注释。
《重构》那本书说代码即注释。
我在开发的前面几年也不喜欢写注释，觉得这是一件很酷的事情。
但后来发现，有些两年之前的代码，业务逻辑都忘了，有些代码自己都看不懂。特别是有部分非常复杂的逻辑和算法，需要重新花很多时间才能看明白，可以说自己把自己坑了。
没有注释的代码，不便于维护。
因此强烈建议大家给代码写注释。
但注释也不是越多越好，注释多了增加了代码的复杂度，增加了维护成本，给自己增加工作量。
我们要写好注释，但不能太啰嗦，要给关键或者核心的代码增加注释。我们可以写某个方法是做什么的，主要步骤是什么，给算法写个demo示例等。
这样以后过了很长时间，再去看这段代码的时候，也会比较容易上手。
2.多写单元测试 我看过身边很多大佬写代码有个好习惯，比如新写了某个Util工具类，他们会同时在test目录下，给该工具类编写一些单元测试代码。
很多小伙伴觉得写单元测试是浪费时间，没有这个必要。
假如你想重构某个工具类，但由于这个工具类有很多逻辑，要把这些逻辑重新测试一遍，要花费不少时间。
于是，你产生了放弃重构的想法。
但如果你之前给该工具类编写了完整的单元测试，重构完成之后，重新执行一下之前的单元测试，就知道重构的结果是否满足预期，这样能够减少很多的测试时间。
多写单元测试对开发来说，是一个非常好的习惯，有助于提升代码质量。
即使因为当初开发时间比较紧，没时间写单元测试，也建议在后面空闲的时间内，把单元测试补上。
3.主动重构自己的烂代码 好的代码不是一下子就能写成的，需要不断地重构，修复发现的bug。
不知道你有没有这种体会，看自己1年之前写的代码，简直不忍直视。
这说明你对业务或者技术的理解，比之前更深入了，认知水平有一定的提升。
如果有机会，建议你主动重构一下自己的烂代码。把重复的代码，抽取成公共方法。有些参数名称，或者方法名称当时没有取好的，可以及时修改一下。对于逻辑不清晰的代码，重新梳理一下业务逻辑。看看代码中能不能引入一些设计模式，让代码变得更优雅等等。
通过代码重构的过程，以自我为驱动，能够不断提升我们编写代码的水平。
4.代码review很重要 有些公司在系统上线之前，会组织一次代码评审，一起review一下这个迭代要上线的一些代码。
通过相互的代码review，可以发现一些代码的漏洞，不好的写法，发现自己写代码的坏毛病，让自己能够快速提升。
当然如果你们公司没有建立代码的相互review机制，也没关系。
可以后面可以多自己review自己的代码。
5.多用explain查看执行计划 我们在写完查询SQL语句之后，有个好习惯是用explain关键字查看一下该SQL语句有没有走索引。
对于数据量比较大的表，走了索引和没有走索引，SQL语句的执行时间可能会相差上百倍。
我之前亲身经历过这种差距。
因此建议大家多用explain查看SQL语句的执行计划。
关于explain关键字的用法，如果你想进一步了解，可以看看我的另外一篇文章《explain | 索引优化的这把绝世好剑-CSDN博客》，里面有详细的介绍。
6.上线前整理checklist 在系统上线之前，一定要整理上线的清单，即我们说的：checklist。
系统上线有可能是一件很复杂的事情，涉及的东西可能会比较多。
假如服务A依赖服务B，服务B又依赖服务C。这样的话，服务发版的顺序是：CBA，如果顺序不对，可能会出现问题。
有时候新功能上线时，需要提前执行sql脚本初始化数据，否则新功能有问题。
要先配置定时任务。
上线之前，要在apollo中增加一些配置。
上线完成之后，需要增加相应的菜单，给指定用户或者角色分配权限。
等等。
系统上线，整个过程中，可能会涉及多方面的事情，我们需要将这些事情记录到checklist当中，避免踩坑。
7.写好接口文档 接口文档对接口提供者，和接口调用者来说，都非常重要。
如果你没有接口文档，别人咋知道你接口的地址是什么，接口参数是什么，请求方式时什么，接口多个参数分别代码什么含义，返回值有哪些字段等等。
他们不知道，必定会多次问你，无形当中，增加了很多沟通的成本。
如果你的接口文档写的不好，写得别人看不懂，接口文档有很多错误，比如：输入参数的枚举值，跟实际情况不一样。
这样不光把自己坑了，也会把别人坑惨。
因此，写接口文档一定要写好，尽量不要马马虎虎应付差事。
如果对写接口文档比较感兴趣，可以看看我的另一篇文章《API接口，那叫一个优雅-CSDN博客》，里面有详细的介绍。
8.接口要提前评估请求量 我们在设计接口的时候，要跟业务方或者产品经理确认一下请求量。
假如你的接口只能承受100qps，但实际上产生了1000qps。
这样你的接口，很有可能会承受不住这么大的压力，而直接挂掉。
我们需要对接口做压力测试，预估接口的请求量，需要部署多少个服务器节点。
压力测试的话，可以用jmeter、loadRunner等工具。
此外，还需要对接口做限流，防止别人恶意调用你的接口，导致服务器压力过大。
限流的话，可以基于用户id、ip地址、接口地址等多个维度同时做限制。
可以在nginx层，或者网关层做限流。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f160beb8763cbf37329cc7e99a042d7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/550fb7061e9dec709415798c30437cd3/" rel="bookmark">
			Java多线程-14
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
程序线程进程
​编辑​编辑​编辑并发并行​
创建线程的基本方式（1）​
创建线程的基本方式（2） ​
售票超卖
线程终止​
常用方法
程序线程进程 并发并行
创建线程的基本方式（1）
package com.edu.threaduse; public class Demo01 { public static void main(String[] args) throws InterruptedException { //创建Cat对象，可以当线程使用 Cat cat = new Cat(); cat.start();//启动线程 //使用run的话是主线程里面的一个普通方法,只有run执行完毕才结束 //说明:当main线程启动一个子线程Thread-0,主线程不会阻塞，会继续执行 for (int i =0;i&lt;10;i++){ System.out.println("主线程i="+i); Thread.sleep(1000); } } } //通过继承Thread类创建线程 /* 当一个类继承类Thread类，该类就可以当做线程使用 我们会重写run方法，写上自己的业务代码 run Thread类实现Runnable接口的run方法 */ class Cat extends Thread{ @Override public void run() { int time =0; while(time++&lt;80){ //重写run方法，写上自己的业务逻辑 //该线程每隔1秒，在控制台输出"喵喵，我是小猫咪"; System.out.println("喵喵,我是小猫咪"+"线程名称="+Thread.currentThread().getName()); //让线程休眠1s try { Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/550fb7061e9dec709415798c30437cd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ad2160baf691d688fb25eada9318f22/" rel="bookmark">
			RLHF几大常用框架实践对比（trlx、deepspeedchat、colossalaichat）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：RLHF几大常用框架实践对比（trlx、deepspeedchat、colossalaichat） - 知乎
目录
收起
一、RLHF的作用
二、实践效果
三、怎么做
1、框架
2、算法
3、数据
4、调参
一、RLHF的作用 从InstructGPT的论文中看，RLHF目的就是为了让模型输出的结果能和人类对齐。而所谓对齐，体现在三点：
有用：即遵守指令的能力诚实：不容易胡说八道安全：不容易生成不合法的、有害、有毒的信息 RLHF在这篇论文中，我们都知道分为三个步骤，包括SFT（微调模型）、RM（训练回报模型或者叫偏好模型）、RL（强化学习）。那么只靠SFT能做到对齐这件事吗？应该可以做到一部分，现在网上大多数流行的开源模型基本上也止步到SFT这个步骤。其实SFT其实也展现出了很不错的性能，但是从实践上看，例如moss要做到和人类比较好的对齐，光微调的数据就达到100w的级别，这个级别的高质量数据收集起来代价还是比较高的，而后面RL的步骤，从实践结果来看，它能够用少量的数据让模型在对齐上的效果和泛化性达到一个新的高度。
从这个文章Awesome 论文合集 ｜不看这些论文，你都不知道 RLHF 是如此的神奇 （4） - OpenDILab浦策的文章 - 知乎 Awesome 论文合集 ｜不看这些论文，你都不知道 RLHF 是如此的神奇 （4） - 知乎看，RLHF有这三个优点：
建立优化范式：为无法显式定义奖励函数的决策任务，建立新的优化范式。对于需要人类偏好指引的机器学习任务，探索出一条可行且较高效的交互式训练学习方案。省数据（Data-Efficient）：相对其他的训练方法，例如监督学习，Top-K 采样等，RLHF 能够利用更少的人类反馈数据达到相近的训练效果。省参数（Parameter-Efficient）：相对其他的训练方法，例如监督学习，Top-K 采样等，RLHF 可以让参数量较小的神经网络也能发挥出强大的性能。 从符尧大神的文章Notion – The all-in-one workspace for your notes, tasks, wikis, and databases.里可以看出RLHF的效果如下：
翔实的回应： text-davinci-003 的生成通常比 text-davinci-002长。 ChatGPT 的回应则更加冗长，以至于用户必须明确要求“用一句话回答我”，才能得到更加简洁的回答。这是 RLHF 的直接产物。**公正的回应：**ChatGPT 通常对涉及多个实体利益的事件（例如政治事件）给出非常平衡的回答。这也是RLHF的产物。**拒绝不当问题：**这是内容过滤器和由 RLHF 触发的模型自身能力的结合，过滤器过滤掉一部分，然后模型再拒绝一部分。**拒绝其知识范围之外的问题：**例如，拒绝在2021 年 6 月之后发生的新事件（因为它没在这之后的数据上训练过）。这是 RLHF 最神奇的部分，因为它使模型能够隐式地区分哪些问题在其知识范围内，哪些问题不在其知识范围内。 二、实践效果 我们的中文实验大多是基于GLM10B的huggingface版本进行的。SFT和大多网上的策略是一样的，使用开源的指令数据集，和一些ChatgptAPI生成的数据集训练。目前网上没有像英文领域有那么多公开的偏好数据集，早期我们直接用翻译接口翻译了HH-RLHF数据集，然后训练了一个回报模型。之后在一些中文的多轮对话上做强化学习，这样粗糙的RLHF，已经可以得到一个能够生成翔实的回应的PPO模型了。但是，也只是变得翔实而已，遵守指令的能力甚至变弱了，也没有丝毫安全性的提升（因为完全没相关数据）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ad2160baf691d688fb25eada9318f22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2e585601070b9fee74ec0074f3a4c87/" rel="bookmark">
			【书生·浦语大模型实战营01】《书生·浦语大模型全链路开源体系》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 《书生·浦语大模型全链路开源体系》 1. 大模型成为热门关键词 LLM发展时间轴 2. 书生·浦语全链条开源开放体系 微调：XTuner 支持全参数微调支持LoRA等低成本微调 评测：OpenCompass 全方位评测，性能可复现80套评测集， 40万道题目 3. 全链条开源开放体系｜微调 3.1 高效微调框架XTuner 3.1.1 适配多种生态 自动优化加速 开发者无需关注复杂的显存优化与计算加速细节
3.1.1 适配多种硬件 训练方案覆盖 NVIDIA 20系以上所有显卡最低只需8GB显存即可微调7B模型 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a90e56b004590b47a690131311ab73f/" rel="bookmark">
			RTMO~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RTMO 是基于 MMPose 的单阶段实时人体姿态估计模型，它结合了坐标回归与 YOLOX 检测框架，在多人场景下实现了领先的速度与精度。RTMO 在 CrowdPose 数据集上首次达到了 80+ 的 AP，是多人拥挤场景当前效果最好的实时模型。
实时高精度的单阶段人体姿态估计算法 RTMO 正式开源！RTMO 结合了坐标回归策略与 YOLOX 检测框架，克服了现有的单阶段人体姿态估计模型精度与速度难以兼得的难题。RTMO 具有两个突出的优势：
在密集的多人场景中，速度和精度均领先。相比传统的二阶段模型如 RTMPose，RTMO 的速度受画面中的人数的影响可以忽略不计。同时它在多个多人密集场景的数据集上获得了最高精度，如在 CrowdPose 数据集上取得83.8 AP，较以往最佳模型提升 5.3 AP。
模型简单易部署。作为端到端的单阶段模型，RTMO 可以一条命令完成推理和部署，无需额外的人体检测器网络，大大简化了使用流程。
项目主页：https://github.com/open-mmlab/mmpose/tree/main/projects/rtmo
论文链接：https://arxiv.org/abs/2312.07526
效果展示
让我们一起先看看 RTMO 在多人场景中的检测效果（latency 为 NVIDIA 3090 TensorRT-FP16 测试结果）
图1 推理效果图1
图2 推理效果图2
实时姿态估计模型的性能对比
现有的实时姿态估计模型主要包括二阶段 top-down 架构的轻量级模型（例如 RTMPose）以及基于 YOLO 架构的单阶段模型（例如 YOLO-Pose, YOLOv8-Pose）。我们在 CPU 和 GPU 上分别比较了它们的速度和精度。
图3 CPU 上实时姿态估计模型的速度-精度对比图
图4 GPU 上实时姿态估计模型的速度-精度对比图
相较其他实时单阶段模型，RTMO 在性能上全面领先，达到了和二阶段模型 RTMPose 差不多的精度。而相比二阶段模型，RTMO 在画面中人数较多时有速度优势。在相同精度要求下，当画面中人数超过 4(cpu)/2(gpu) 时，RTMO 的推理速度就已经超越了 RTMPose。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a90e56b004590b47a690131311ab73f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45eed431ff7d3908a3849b8c7dfe1da4/" rel="bookmark">
			Python识别图片中的文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python识别图片中的文字 一、前言 不知道大家有没有遇到过这样的问题，就是在某个软件或者某个网页里面有一篇文章，你非常喜欢，但是不能复制。或者像百度文档一样，只能复制一部分，这个时候我们就会选择截图保存。但是当我们想用到里面的文字时，还是要一个字一个字打出来。那么我们能不能直接识别图片中的文字呢？答案是肯定的。
点此免费领取：CSDN大礼包：《python学习路线&amp;全套学习资料》免费分享
二、Tesseract 文字识别是ORC的一部分内容，ORC的意思是光学字符识别，通俗讲就是文字识别。Tesseract是一个用于文字识别的工具，我们结合Python使用可以很快的实现文字识别。但是在此之前我们需要完成一个繁琐的工作。
（1）Tesseract的安装及配置 Tesseract的安装我们可以移步到该网址[ https://digi.bib.uni-mannheim.de/tesseract/]，我们可以看到如下界面：
有很多版本供大家选择，大家可以根据自己的需求选择。其中w32表示32位系统，w64表示64位系统，大家选择合适的版本即可，可能下载速度比较慢，大家可以选择链接：pan.baidu.com/s/1jKZe_ACL… 提取码：ayel下载。安装时我们需要知道我们安装的位置，将安装目录配置到系统path变量当中，我们路径是D:\CodeField\Tesseract-OCR。
我们右击我的电脑/此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;Path-&gt;编辑-&gt;新建然后将我们的路径复制进去即可。添加好系统变量后后我们还需要依次点确定，这样才算配置好了。
（2）下载语言包 Tesseract默认是不支持中文的，如果想要识别中文或者其它语言需要下载相应的语言包，下载地址如下： https://tesseract-ocr.github.io/tessdoc/Data-Files ，进入网站后我们往下翻：
其中有两个中文语言包，一个Chinese-Simplified和Chinese-Traditional，它们分别是简体中文和繁体中文，我们选择需要的下载即可。下载完成后我们需要放到Tesseract的路径下的tessdata目录下，我们路径是D:\CodeField\Tesseract-OCR\tessdata。
（3）其它模块下载 除了上面的步骤，我们还需要下载两个模块：
pip install pytesseract pip install pillow 复制代码 第一个是用于文字识别的，第二个是用于图片读取的。接下来我们就可以进行文字识别了。
三、文字识别 （1）单张图片识别 接下来的操作就要简单的多，下面是我们要识别的图片：
接下来就是我们文字识别的代码：
import pytesseract from PIL import Image # 读取图片 im = Image.open('sentence.jpg') # 识别文字 string = pytesseract.image_to_string(im) print(string) 复制代码 识别结果如下：
Do not go gentle into that good night! 复制代码 因为默认是支持英文的，所以我们可以直接识别，但是当我们要识别中文或其它语言时就需要做些修改：
import pytesseract from PIL import Image # 读取图片 im = Image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45eed431ff7d3908a3849b8c7dfe1da4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c38c0a2ea65d4ea112860c0377e66f3e/" rel="bookmark">
			citeSpace保姆级安装使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		citeSpace保姆级安装使用教程 文章目录 citeSpace保姆级安装使用教程CiteSpace功能与参数区安装使用知网数据导出citespace数据导入结果 设置操作隐藏节点 CiteSpace功能与参数区 安装 citeSpace安装教程
citespace下载 网址：https://citespace.podia.com/
安装之后打开是这样：
点击Agree出现下图：
使用 知网数据导出 citespace数据导入 结果 最后出来的图
设置操作 隐藏节点 在左侧栏取消想隐藏节点的visible属性，或者直接右键该节点，选择“Hide node”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82e7e9bb8efc5c9ab673e2aa2c3a1dd0/" rel="bookmark">
			vmware中ubuntu虚拟机不能够用共享文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候发现装好虚拟机后，然后
虚拟机-设置-选项-共享文件夹
然后使用快捷键ctrl+alt+t 打开命令行，cd /mnt下没有看到hgfs文件夹
解决办法是安装vmware tools工具
此时想通过点击 虚拟机-安装vmwaretools工具 按钮 居然发现该按钮是灰色的，不可点击
解决步骤方法:
1 将虚拟机关机
2 左侧栏选中某虚拟机后右键选择设置，选择使用物理驱动器(自动检测),弹出下面：
备注：经过我的测试，上图一个光驱就行，如果上图还是不行，则再加一个cd光驱和一个软驱，同时光驱类型选择物理驱动器类型，然后再接着下面流程试验
3 这时候再开机，会发现 虚拟机-安装vmwaretools 已经可点，点击后，
然后解压后执行 ./vmware-install.pl 安装vmware tools工具
安装好vmware tools 后重启虚拟机，会发现共享文件夹已经可用，在/mnt下面就可以看到hgfs文件夹，桌面完全充满虚拟机，全屏显示
fr:hunk
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42648f561235372d832284e4240821e8/" rel="bookmark">
			DETR纯代码分享（九）transformer.py
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定义DETR Transformer用于DETR模型 """ DETR Transformer class. Copy-paste from torch.nn.Transformer with modifications: * positional encodings are passed in MHattention * extra LN at the end of encoder is removed * decoder returns a stack of activations from all decoding layers """ import copy from typing import Optional, List import torch import torch.nn.functional as F from torch import nn, Tensor 这段代码是一个用于实现DETR模型中的Transformer类的定义。DETR是一个用于目标检测的神经网络模型，它将目标检测任务转化为一个序列到序列（Sequence-to-Sequence）问题。下面是对这段代码的解释：
DETR Transformer class: 这是一个类的定义，表示DETR模型中的Transformer部分。该类用于实现Transformer的结构和功能。
Copy-paste from torch.nn.Transformer with modifications: 该注释表明该类的定义是从PyTorch的torch.nn.Transformer类进行复制并进行了一些修改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42648f561235372d832284e4240821e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a4c180ee6bb01c7d57aeac5c64b4e3d/" rel="bookmark">
			shell 获取主机IP 脚本中使用IP 打印出来IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 查看ip查看网关只查看ens33过滤ip拿到网卡名字对内容进行切片获取第一网卡IP （head -1 表示第一个网卡）脚本中打印IP 查看ip ip a 查看网关 ip r 只查看ens33 ip a show dev ens33 过滤ip ip a | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' 拿到网卡名字 ip a |awk '/^[0-9]+:/{print $2}'| awk 'BEGIN{FS=":"}{print $1}'| grep -v lo # 只要第一个网卡 ip a |awk '/^[0-9]+:/{print $2}'| awk 'BEGIN{FS=":"}{print $1}'| grep -v lo | head -1 对内容进行切片 ip a show dev $(ip a |awk '/^[0-9]+:/{print $2}'|awk 'BEGIN{FS=":"}{print $1}'| grep -v lo | head -1) ## 获取ens网卡 的ip ip a show dev ens33 | awk 'NR==3{print $2}' | awk -F'/' '{print $1}' 获取第一网卡IP （head -1 表示第一个网卡） ip a show dev $(ip a |awk '/^[0-9]+:/{print $2}'|awk 'BEGIN{FS="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a4c180ee6bb01c7d57aeac5c64b4e3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc4acaf7b9578d2e08121538c8b52c0b/" rel="bookmark">
			filecoin通过filutils 区块浏览器获取历史收益数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		filecoin 历史收益数据 每天每T平均收益 导出历史每日收益为文档 filutils 区块浏览器
导出历史每日收益为文档 #!/bin/bash for i in {1..10} do echo $i result=$(curl --location --request POST 'https://api.filutils.com/api/v2/powerreward' \ --header 'User-Agent: Apifox/1.0.0 (https://apifox.com)' \ --header 'Content-Type: application/json' \ --header 'Accept: */*' \ --header 'Host: api.filutils.com' \ --header 'Connection: keep-alive' \ --header 'Cookie: __cf_bm=yu677yL.CJGBJZ2zWxCtKeykaZe_Hn3Y5FnlurzfSmA-1704454769-1-AYaGa/B0Pz5PO9V3NznKFbjNnbzwGlbdlOW18kikOd4dotfi8Hn+tx+u7PzPU6JWrWBY1aE3veKJBy7EMci4br8=' \ --data-raw '{ "startDate": "2022-01-01", "endDate": "2024-01-04", "pageIndex": '$i', "pageSize": 100 }') echo $result &gt;&gt; /root/shell/FIL_T/2022-01-01.txt cd /root/shell/FIL_T cat 2022-01-01.txt | jq -r '.data[] | "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc4acaf7b9578d2e08121538c8b52c0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/014017389e8bb180f7e4259db9118ad7/" rel="bookmark">
			【MIT 6.S081】2020, 实验记录（1），Lab: Xv6 and Unix utilities
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 实验准备TasksTask 1: Boot xv6Task 2: sleepTask 3: pingpongTask 4: primesTask 5: findTask 6: xargs 实验准备 这个 lab 用来学习尝试如何通过 system call 来实现常见的 shell 命令行程序，比如 ls、sleep、xargs 等。
实验官网 可以使用 docker 搭建实验环境：
docker pull debian:bullseye docker run -it --name mit6.s081 -d debian:bullseye /bin/bash 然后按照实验官网的介绍，在 git 下载源代码并启动。
Tasks Task 1: Boot xv6 这个 task 就是在 git 上下载源代码，并启动 xv6 系统：
$ make qemu 成功后就可以看到 OS 成功启动。
Task 2: sleep 本 task 以及接下来的 task，都是在 /user 目录下实现用户级程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/014017389e8bb180f7e4259db9118ad7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e2ec769f4319f8430459e43bfc410b8/" rel="bookmark">
			Windows CMD命令详细介绍：文本操作篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows CMD命令详细介绍：文本操作篇 在Windows操作系统中，通过命令提示符（cmd）执行文本文件的操作是一项基本的技能。以下是如何在cmd中进行文本文件的创建、删除、复制、查看和打开的详细介绍。
1. 创建文本文件 使用echo命令和&gt;操作符可以直接在cmd中创建新的文本文件。例如，要创建一个名为example.txt的文本文件，执行以下命令：
echo Hello, World! &gt; example.txt 这将在example.txt中写入"Hello, World!"。
2. 删除文本文件 要删除文本文件，可以使用del命令。例如，删除example.txt：
del example.txt 3. 复制文本文件 使用copy命令可以复制文本文件。例如，将file1.txt复制到file2.txt：
copy file1.txt file2.txt 4. 查看文本文件内容 使用type命令可以查看文本文件的内容。例如，查看example.txt：
type example.txt 5. 打开文本文件 通过start命令可以在cmd中打开文本文件。例如，打开example.txt：
start example.txt 这将在关联的默认文本编辑器中打开文件。
这些基本的cmd命令可以提高你在命令行环境下处理文本文件的效率。希望这篇博客对你有帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de78d80e8b6ab39ad5278c6c702f0ed1/" rel="bookmark">
			Source Insight 4.0的超实用的常规设置技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、字体大小设置2、行号显示3、快速跳转到某一行4、在所有文件中的搜索某一函数使用情况5、换行自动对齐6、取消程序名后的文件路径显示 1、字体大小设置 【Options】-&gt;【Preferences】-&gt;【Typing】-&gt;【Per File Type】-&gt;【Screen Font】
2、行号显示 【View】-&gt;【Line Numbers】
3、快速跳转到某一行 Ctrl+G
4、在所有文件中的搜索某一函数使用情况 Ctrl+/
5、换行自动对齐 】Options】-&gt;】File type Options】，选择】Auto Indent…】弹出对话框，将】Smart Indent Options】下的两个复选框的√去掉即可
6、取消程序名后的文件路径显示 点击文件名-&gt;Windows Tab Options，进去取消勾选即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a017c0ebc7132236a7a8a858b875129b/" rel="bookmark">
			[NSSRound#3 Team]This1sMysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[NSSRound#3 Team]This1sMysql 源码
&lt;?php show_source(__FILE__); include("class.php"); $conn = new mysqli(); if(isset($_POST['config']) &amp;&amp; is_array($_POST['config'])){ foreach($_POST['config'] as $key =&gt; $val){ $value = is_numeric($var)?(int)$val:$val; $conn-&gt;set_opt($key, $value); } } if(isset($_POST['mysql']) &amp;&amp; is_array($_POST['mysql'])){ $my = $_POST['mysql']; if($conn-&gt;real_connect($my['host'], $my['user'], $my['pass'], $my['dbname'], $my['port'])){ echo "connect success"; $conn-&gt;query("show databases;"); } else{ echo "connect fail"; } } else{ include("function.php"); } $conn-&gt;close(); ?&gt; 先来看看怎么处理config参数的，首先必须是数组，然后foreach遍历赋值给$val，如果是$var是数字，则$val转换成int型赋值给$value否则按原始值赋值。然后执行set_opt($key, $value)百度了一下，发现是mysqli_options函数的别称
那么我们分析下mysqli_options函数的参数
public mysqli::options(int $option, string|int $value): bool 刚好对应我们源码中的参数
option是可以修改的选项，注意是int型
而value是布尔值，这俩参数暂时还不知道如何利用
我们接着往下看，接收参数mysql包括对应键名进行sql数据库连接，可是我们并不知道具体的信息。结合提示Rogue-MySql-Server，去网上搜到可以利用Mysql服务端反向读取客户端的任意文件
当然此原理利用的option是**MYSQLI_OPT_LOCAL_INFILE**。通过题目提供的mysql参数对我们本地机的Mysql服务端进行连接从而反向读取靶机的文件
我们前面分析过了参数config的作用，那么我们只需要开启该option设置为true即可
（我查的是9，但是参考wp中确实排在8）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a017c0ebc7132236a7a8a858b875129b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26b14fe31f08c7c46fde0ab421a054c7/" rel="bookmark">
			8 款浏览器兼容性测试工具，看你了解几个？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📢专注于分享软件测试干货内容，欢迎点赞 👍 收藏 ⭐留言 📝 如有错误敬请指正！📢软件测试面试题分享： 1000道软件测试面试题及答案📢软件测试实战项目分享： 纯接口项目-完整接口文档📢软件测试实战项目分享：WEB 测试自动化项目实战📢软件测试学习教程推荐：火遍全网的《软件测试》教程 前言 浏览器的兼容性问题，是指不同浏览器使用内核及所支持的 HTML 等网页语言标准不同，用户客户端的环境不同造成的显示效果不能达到理想效果。对于用户而言，无论使用哪款浏览器，期望看到的效果是正常的统一的。
市面上发布的浏览器版本非常之多，碍于测试环境和人力资源的不足，要想做到全面的兼容性测试很难。如何进行高效的浏览器兼容性测试，对于前端开发人员还是测试工程师来说，都算得上一个头疼的问题。
为此，我们可以在多台计算机或者多台虚拟机上部署不同浏览器进行测试，但这种方法会造成一定的资源浪费、或存在卡顿情况。为提高测试效率，可以利用一些浏览器兼容性测试工具来完成测试工作。以下介绍 8 款浏览器兼容性测试工具，可以依据自己需求选择，有需要的欢迎收藏！
1、IETester 下载地址：https://www.my-debugbar.com/wiki/IETester/HomePage
一款专注于 IE 浏览器各个版本兼容性调试的工具，在 PC 下载客户端安装即可使用。支持 Windows 7，Vista and XP，Windows 8 desktop 系统。 有中文，英文等多国语言支持。IETester 可以模拟出不同的 js 引擎来帮助程序员设计效果统一的代码。覆盖 IE5.5/6.0/7.0/8.0/9.0/10/11 版本 ，完全满足大部分 IE 浏览器兼容性的测试。
2、BrowserShots 网址：http://browsershots.org/
BrowserShots 是一款免费的在线跨浏览器测试平台，捕捉网站在不同浏览器中的截图。支持 Linux、Windows、Mac 平台，覆盖浏览器也比较多，IE、Chrome、Firefox、 Opera、Safari 都有覆盖。可以选择不同操作系统不同的浏览器版本，输入被测网址，即可截图查看兼容性
3、spoonBrowser Sandbox 网址：https://turbo.net/browsers
需要注册账号登录后，点击需要测试的浏览器环境，安装插件运行不同浏览器模块来进行测试。Spoon Browser Sandbox 支持主流浏览器 IE、Chrome、Firefox、Safari、Opera 及其不同版本。满足多款主流浏览器兼容性测试的需求，唯一不足是非免费，但可免费体验。
4、Browserstack 网址：https://www.browserstack.com/
Browserstack 是一个非常著名的多系统跨浏览器兼容性测试平台，支持 9 大操作系统上的 3000 种浏览器，覆盖所有旧版本的 Internet Explorer（IE6 - IE11），最新测试版和开发版（Edge，Safari，Chrome，Firefox，Opera 和 Yandex）以及各种真实的 iOS 和 Android 设备。作为浏览器测试市场上最古老的工具之一，仍然被 Microsoft、jQuery、Airbnb、以及 Wikipedia 等知名企业所延用。非免费，用户在 browserstack 网站注册后可享受 30 分钟的免费试用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26b14fe31f08c7c46fde0ab421a054c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d669c91adc22cd6e491cb756fcda2a32/" rel="bookmark">
			Rust 字符串 初步了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rust 的字符串 。字符串不是复合类型，
String 和 &amp;str ：
String 具有所有权，是存储在堆上的。&amp;str 没有所有权，是对 String 的引用。字符串字面量也是 &amp;str 类型，存储在栈上。 切片（slice） 对于字符串而言，切片就是对字符串一部分的引用。
let s = String::from("hello"); let s1 = &amp;s[0..5]; // 不包含终止索引 hello 创建切片的语法：[开始索引..终止索引]。（该语法是一个右半开区间） 。
切片数据结构：保存开始的位置（指针）和切片的长度。
.. range 序列 语法。 包含第一个字节或最后一个字节时，开始索引或最后索引可以省略。
let s = String::from("hello"); let s1 = &amp;s[..2]; // he let s2 = &amp;s[2..]; // llo let s3 = &amp;s[..]; // hello 注意
在使用切片时，需要保证索引落在字符的边界上。
因为切片上的索引指的是字节，而不是字符，而且字符串使用的编码是 UTF-8 。
所以当一个字符占用多个字节时，索引可能不在字符的边界上，导致没有取到完成的字符，出现错误。
字符串切片的类型标识为 &amp;str 。
所以切片（slice）是一个不可变引用。
其他切片 数组也可以进行切片。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d669c91adc22cd6e491cb756fcda2a32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/560ebc11ba1cbc23c96c964d7226c7ac/" rel="bookmark">
			Spring AOP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.为什么要学习AOP？ 案例：有一个接口Service有一个insert方法，在insert被调用时打印调用前的毫秒数与调用后的毫秒数，其实现为
public class UserServiceImpl implements UserService { private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void addUser(){ System.out.println("方法开始时间："+new Date()); userDao.addUser(); System.out.println("方法结束时间："+new Date()); } } 问题：输出日志的逻辑还是无法复用
2.AOP概述 AOP：全称是Aspect Oriented Programming即：面向切面编程。
简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对程序进行增强：权限校验,日志记录,性能监控,事务控制.
3.AOP相关术语 连接点（joinpoint）
被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法。
切入点（pointcut）
切入点是指我们要对哪些连接点进行拦截的定义
通知/增强（advice）
所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类
切面（aspect）
是切入点和通知的结合
引介（introduction）
是一种特殊的通知，在不修改代码的前提下，引介可以在运行期为类动态地添加一些方法或字段
目标对象（Target）
要代理的目标对象（要增强的类）
织入（weave）
将增强应用到目标的过程将advice应用到target的过程
代理（Proxy）
一个类被AOP织入增强之后，就产生一个代理类
4.Spring的AOP配置 4.1创建工程 4.1.1pom.xml &lt;dependencies&gt; &lt;!-- ioc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/560ebc11ba1cbc23c96c964d7226c7ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ae39d5fd30044bc95dad5cfc0794a1c/" rel="bookmark">
			打包Python程序为不依赖本地环境独立的 Windows 可执行程序详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打包 PyQt 程序为独立的 Windows 可执行程序 在开发 Python程序时，有时候我们希望将其打包成一个独立的 Windows 可执行程序，方便分享给其他人，而不需要他们安装 Python 或 有关依赖。为了实现这一目标，我们可以使用 PyInstaller 工具。下面是详细的步骤：
步骤一：安装 PyInstaller 首先，确保你已经安装了 PyInstaller。在命令行中执行以下命令：
pip install pyinstaller 步骤二：进入程序目录 使用命令行进入包含 Python 程序的目录。你可以使用 cd 命令切换到你的项目文件夹。
cd path/to/your/project 步骤三：创建 spec 文件 使用以下命令生成 PyInstaller 的 spec 文件，用于配置打包选项。
pyinstaller --name=YourAppName --onefile YourApp.py 在这个命令中，替换 YourAppName 为你希望的可执行文件名称，YourApp.py 替换为你的 Python 程序的主文件。
步骤四：编辑 spec 文件（可选） 生成的 spec 文件通常是 YourAppName.spec，你可以打开这个文件检查和修改以确保满足你的需求。这一步是可选的，如果你对默认配置满意，可以跳过。
步骤五：执行打包 运行以下命令执行打包：
pyinstaller YourAppName.spec 这将在 dist 目录下生成一个可执行文件，其中包含您的整个 Python 程序及其依赖项。
步骤六：测试可执行文件 在 dist 目录中找到生成的可执行文件（通常是 YourAppName.exe），双击运行，确保它在不同的 Windows 环境中正常工作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ae39d5fd30044bc95dad5cfc0794a1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/639bd64b8233c2fe40ba6138ec640b57/" rel="bookmark">
			年底了，准备跳槽的可以看看...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📢专注于分享软件测试干货内容，欢迎点赞 👍 收藏 ⭐留言 📝 如有错误敬请指正！📢软件测试面试题分享： 1000道软件测试面试题及答案📢软件测试实战项目分享： 纯接口项目-完整接口文档📢软件测试实战项目分享：WEB 测试自动化项目实战📢软件测试学习教程推荐：火遍全网的《软件测试》教程 前两天跟朋友感慨，今年的铜九铁十、裁员、疫情导致好多人都没拿到offer!现在已经1月了，具体明年的金三银四只剩下两个月。
对于想跳槽的职场人来说，绝对要从现在开始做准备了。这时候，很多高薪技术岗、管理岗的缺口和市场需求也出来了。
所以准备3月跳槽、找工作的朋友，就一定要好好准备抓住机会，补一补自己的知识体系，完善自己的能力模型
为此我专门找了一份《软件测试进阶学习+面试宝典》分享给大家，共206页包含测试理论、Linux基础、MySQL基础、Web测试、接口测试、App测试、管理工具、Python基础、Selenium相关、性能测试、LordRunner相关等举例等一起分享出来给大家看看，也是给大家平时查漏补缺。
不多说，直接上干货（展示部分以阿里面试纲要为例）完整版文末领取
通过大数据总结发现，其实软件测试岗的面试都是差不多的。常问的有下面这几块知识点：
全网首发-涵盖16个技术栈 第一部分，测试理论（测试基础+需求分析+测试模型+测试计划+测试策略+测试案例等等）第二部分，Linux（ Linux基础+Linux练习题）第三部分，MySQL（基础知识+查询练习+万年学生表经典面试题汇总+数据库企业真题）第四部分，Web测试第五部分，API测试第六部分，App测试第七部分，管理工具第八部分，Python基础（Python基础+编程题+集合+函数+Python特性等等）第九部分，Selenium相关第十部分，性能测试第十一部分，LordRunner相关第十二部分，计算机网络第十三部分，组成原理第十四部分，数据结构与算法第十五部分，逻辑题第十六部分，人力资源 软件测试基础 软件测试的步骤是什么?如何录制测试脚本?应该考虑进行如何测试的测试方法怎样估计测试工作量?测试设计的问题当测试过程发生错误时，有哪几种解决办法?测试执行的问题测试评估的目标如何提高测试?C/S模式的优点和缺点B/S模式的优点和缺点 Linux grep和find的区别? grep 都有哪些用法?查看IP地址?创建和删除一个多级目录?在当前用户家目录中查找haha.txt文件?如何查询出tomcat的进程并杀掉这个进程，写出linux命令?动态查看日志文件?查看系統硬盘空间的命令?查看当前机器listen 的所有端口? Python 统计python源代码文件中代码行数，去除注释，空行，进行输出?python调用cmd并返回结果?冒泡排序1,2,3,4 这4个数字，能组成多少个互不相同的且无重复的三位数，都是多少?请用 python 打印出 10000 以内的对称数（对称数特点：数字左右对称，如：1,2,11,121,1221 等）给定一个整数 N，和一个 0-9 的数 K，要求返回 0-N 中数字 K 出现的次数判断 101-200 之间有多少个素数，并输出所有的素数一个输入三角形的函数，输入后输出是否能组成三角形，三角形类型，请用等价类- 划分法设计测试用例…
MySQL 你用的Mysql是哪个引擎，各引擎之间有什么区别?如何对查询命令进行优化?数据库的优化?Sql注入是如何产“生的，如何防止?NoSQL和关系数据库的区别?MySQL与MongoDB本质之间最基本的差别是什么Mysql数据库中怎么实现分页?Mysql数据库的操作?优化数据库?提高数据库的性能?什么是数据的完整性? …
Web Web测试和app测试区别？WEB测试环境搭建和测试方法WEB测试教程WEB测试要点及基本方法Web测试页面总结… 接口测试 什么是接口如果模块请求http改为了https,测试方案应该如何制定，修改?常用HTTP 协议调试代理I具有什么?详细说明抓取HTTPS协议的设置过程?描述TCP/IP协议的层次结构，以及每一-层中重要协议jmeter,一个接口的响应结果如下:接口产生的垃圾数据如何清理依赖第三方的接口如何处理测试的数据你放在哪?什么是数据驱动，如何参数化? …
性能测试 你认为性能测试的目的是什么?做好性能测试的工作的关键是什么?服务端性能分析都从哪些角度来进行?如何理解压力测试，负裁测试以及性能测试?如何判断是否有内存泄漏及关注的指标?描述软件产“生内存泄露的原因以及检查方式。(可以结合- 种开发语言进行描述)简述什么是值传递，什么是地址传递，两者区别是什么?什么是系统瓶颈?…、 elenium 如何开展自动化测试框架的构建?如何设计自动化测试用例:webdriver如何开启和退出一个浏览器?什么是自动化测试框架?Selenium是什么，流行的版本有哪些?你如何从命令行启动Selenium RC?在我的机器端口4444不是免费的。我怎样才能使用另一个端口?什么是Selenium Server,它与Selenium Hub有什么不同?你如何从Selenium连接到数据库?你如何验证多个页面上存在的一个对象?XPath中使用单斜杠和双斜杠有什么区别?如何编写SeleniumIDE/ RC的用户扩展?如何在页面加载成功后验证元素的存在?你对Selenium Grid有什么了解?它提供了什么功能?如何从你的Java Class启动Selenium服务器?Selenium中有哪些验证点?什么是XPath?什么时候应该在Selenium中使用XPath? 计算机与网络 一台计算机的IP是192.168.10.71子网掩码255.255.255.64与192.168.10.201 …请简述DNS、活动目录、域的概念。10M兆宽带是什么意思?理论下载速度是多少?什么是IP地址?OSI七层网络模型的划分?TCP和UDP有什么不同?HTTP属于哪一层的协议?HTTP和HTTPS的区别?cookies和session的区别?HTTP的get请求和post请求的区别?HTTP1.0和HTTP1.1有什么区别TCP的连接建立过程，以及断开过程?客户端使用DHCP获取IP的过程?写出某个网段的网络地址和广播地址? 人力资源 你的测试职业发展是什么？你自认为做测试的优势在哪里？你找工作时，最重要的考虑因素为何？为什么我们应该录取你？请谈谈你个人的最大特色。一个测试工程师应具备那些素质和技能？还有问一下你是怎样保证软件质量的，也就是说你觉得怎样才能最大限度地保证软件质量？为什么选择测试这行？如果我雇用你，你能给部门带来什么贡献？ 最后 整份文档一共有将近 400 页，全部为大家展示出来肯定是不太现实的，为了不影响大家的阅读体验就只展示了部分内容，还望大家海涵，希望能帮助到您面试前的复习且找到一个好的工作，也节省大家在网上搜索资料的时间来学习！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94f4649ade3cbe01d333ed9bedbc476b/" rel="bookmark">
			软件测试——自动化测试框架有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📢专注于分享软件测试干货内容，欢迎点赞 👍 收藏 ⭐留言 📝 如有错误敬请指正！📢软件测试面试题分享： 1000道软件测试面试题及答案📢软件测试实战项目分享： 纯接口项目-完整接口文档📢软件测试实战项目分享：WEB 测试自动化项目实战📢软件测试学习教程推荐：火遍全网的《软件测试》教程 前言 自动化测试常用的Python框架有哪些？常用的框架有Robot Framework、Pytest、UnitTest/PyUnit、Behave、Lettuce。Pytest、Robot Framework和UnitTest主要用于功能与单元测试，Lettuce和Behave仅适用于行为驱动测试。
一、Robot Framework Python测试框架之一，Robot Framework被用在测试驱动(test-driven)类型的开发与验收中。虽然是由Python开发而来，但是它也可以在基于.Net的IronPython和基于Java的Jython上运行。作为一个Python框架，Robot还能够兼容诸如Windows、MacOS、以及Linux等平台。
在使用Robot Framework(RF)之前，需要先安装Python 2.7.14及以上的版本。推荐使用Python 3.6.4，以确保适当的注释能够被添加到代码段中，并能够跟踪程序的更改。同时还需要安装Python包管理器--pip。
二、Pytest 适用于多种软件测试的Pytest，是另一个Python类型的自动化测试框架。凭借着其开源和易学的特点，该工具经常被QA(质量分析)团队、开发团队、个人团队、以及各种开源项目所使用。鉴于Pytest具有“断言重写(assert rewriting)”之类的实用功能，许多大型互联网应用，如Dropbox和Mozilla，都已经从下面将要提到的unittest(Pyunit)切换到了Pytest之上。
除了基本的Python知识，用户并不需要更多的技术储备。另外，用户只需要有一台带有命令行界面的测试设备，并且安装好了Python包管理器、以及可用于开发的IDE工具。
三、UnitTest/PyUnit UnitTest/PyUnit一种标准化的针对单元测试的Python类自动化测试框架。基类TestCase提供了各种断言方法、以及所有清理和设置的例程。因此，TestCase子类中的每一种方法都是以“test”作为名词前缀，以标识它们能够被作为测试用例所运行。用户可以使用load方法和TestSuite类来分组、并加载各种测试。
可以通过联合使用，来构建自定义的测试运行器。正如我们使用Junit去测试Selenium那样，UnitTest也会用到UnitTest-sml-reporting、并能生成各种XML类型的报告。由于UnitTest默认使用了Python，因此我们并不需要什么先决条件。除了需要具备Python框架的基本知识，您也可以额外地安装pip、以及用于开发的IDE工具。
四、Behave 行为驱动开发是一种基于敏捷软件开发的方法。它能够鼓励开发人员、业务参与者和QA人员，三者之间的协作。Python测试框架Behave允许团队避开各种复杂的情况，去执行BDD测试。从本质上说该框架与SpecFlow和Cucumber相似，常被用于执行自动化测试。用户可以通过简单易读的语言来编写测试用例，并能够在其执行期间粘贴到代码之中。而且，那些被设定的行为规范与步骤，也可以被重用到其他的测试方案中。
任何具备Python基础知识的人都可以使用Behave。其他先决条件还包括：先安装Python 2.7.14及以上的版本。通过Python包管理器或pip来与Behave协作。大多数开发人员会选择Pycharm作为开发环境，当然您也可以选用其他的IDE工具。
五、Lettuce Lettuce是另一种基于Cucumber和Python的行为驱动类自动化工具。Lettuce主要专注于那些具有行为驱动开发特征的普通任务。它不但简单易用，而且能够使得整个测试过程更流畅、甚至更有趣。安装带有IDE的Python 2.7.14、及以上的版本。当然，您也可以使用Pycharm或任何其他IDE工具。同时，您还需要安装Python包管理器。
最后我邀请你进入我们的【软件测试学习交流群：785128166】， 大家可以一起探讨交流软件测试，共同学习软件测试技术、面试等软件测试方方面面，还会有免费直播课，收获更多测试技巧，我们一起进阶Python自动化测试/测试开发，走向高薪之路
作为一个软件测试的过来人，我想尽自己最大的努力，帮助每一个伙伴都能顺利找到工作。所以我整理了下面这份资源，现在免费分享给大家，有需要的小伙伴可以关注【公众号：程序员二黑】自提！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd125bab78eeb66ab4540fde74a8797e/" rel="bookmark">
			在Fiber中处理请求和响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		掌握GoLang Fiber中请求和响应管理的艺术，以实现高效的Web开发 在Web开发领域，有效地处理请求和响应是构建既用户友好又高效的Web应用的基石。该过程涉及管理传入的HTTP请求、解析数据和参数、构建适当的响应、处理不同的响应类型以及优雅地处理错误。对于GoLang Fiber这样一个强大且灵活的Web框架来说，掌握请求和响应处理的艺术至关重要。在这个全面的指南中，我们将探讨在Fiber中处理HTTP请求的细节，深入了解解析请求参数和数据的过程，揭示创建和发送HTTP响应的过程，探索不同的响应类型，并了解错误处理和为健壮的Web应用程序制定错误响应。
在Fiber中处理HTTP请求 处理HTTP请求是任何Web应用的核心。它涉及从客户端接收传入的请求，处理它们，并提供合适的响应。在Fiber中，由于其简单而强大的路由系统，管理HTTP请求变得简单明了。让我们探索在Fiber中处理请求的细节。
解析请求参数和数据 为了从传入的请求中提取数据和参数，Fiber提供了各种方法和工具。无论您需要访问路由参数、查询参数、表单数据还是JSON负载，Fiber都能满足您的需求。
以下是在Fiber中解析请求参数的基本示例：
package main import ( "github.com/gofiber/fiber/v2" ) func main() { app := fiber.New() // 定义一个捕获用户ID作为参数的路由 app.Get("/users/:id", func(c *fiber.Ctx) error { // 从路由参数中提取用户ID userID := c.Params("id") // 以用户ID作为响应 return c.SendString("用户ID: " + userID) }) app.Listen(":3000") } 在这个例子中，路由捕获用户的ID作为一个参数，我们使用c.Params("id")来访问参数的值。这对于创建响应各种输入的动态路由非常有用。
Fiber还简化了与查询参数、表单数据和JSON负载的工作。例如，您可以使用c.Query("param")访问查询参数，使用c.FormValue("field")访问表单数据，以及使用c.BodyParser(&amp;data)访问JSON负载。
创建和发送HTTP响应 一旦您处理了传入的请求，您需要向客户端发送一个适当的HTTP响应。Fiber提供了创建和发送响应的直观方式，包括各种响应方法，如Send、JSON、Status等。
以下是在Fiber中创建和发送HTTP响应的基本示例：
package main import ( "github.com/gofiber/fiber/v2" ) func main() { app := fiber.New() app.Get("/", func(c *fiber.Ctx) error { // 发送一个简单的文本响应 return c.SendString("你好，Fiber!") }) app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd125bab78eeb66ab4540fde74a8797e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e7b9f12ddffbac27a701d4d7cc75d7d/" rel="bookmark">
			Iceberg: COW模式下的MERGE INTO的执行流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MergeInto命令 MERGE INTO target_table t USING source_table s ON s.id = t.id //这里是JOIN的关联条件 WHEN MATCHED AND s.opType = 'delete' THEN DELETE // WHEN条件是对当前行进行打标的匹配条件 WHEN MATCHED AND s.opType = 'update' THEN UPDATE SET id = s.id, name = s.name WHEN NOT MATCHED AND s.opType = 'insert' THEN INSERT (key, value) VALUES (key, value) 如上是一条MERGE INTO语句，经过Spark Analyzer解析时，会发现它是MERGE INTO命令，因此将解析target_table对应生成的SparkTable实例封装成RowLevelOperationTable的实例，它会绑定一个SparkCopyOnWriteOperation的实例，并且实现了创建ScanBuilder和WriteBuilder的方法。
ScanBuilder和WriteBuilder是Spark中定义的接口，分别用于构建读数据器（Scan）和写数据器（BatchWrite）。
Iceberg基于Spark 3.x提供的外部Catalog及相关的读写接口，实现了对于Iceberg表（存储格式）的数据读写。
下面以SparkCopyOnWriteOperation跟踪分析如何利用Spark写出数据为Iceberg表格式。
Iceberg行级更新的操作，目前支持UPDATE / DELETE / MERGE INTO三个语法。
预备知识 SparkTable定义 public class SparkTable implements org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e7b9f12ddffbac27a701d4d7cc75d7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f64ae52cf73e4ac0b277c43a93233dba/" rel="bookmark">
			Iceberg: 列式读取Parquet数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过Spark读取Parquet文件的基本流程 SQL ==&gt; Spark解析SQL生成逻辑计划树 LogicalPlan ==&gt; Spark创建扫描表/读取数据的逻辑计划结点 DataSourceV2ScanRelation ==&gt; Spark优化逻辑计划树，生成物理计划树 SparkPlan ==&gt; Spark根据不同的属性，将逻辑计划结点DataSourceV2ScanRelation转换成物理计划结点BatchScanExec BatchScanExec ==&gt; BatchScanExec::inputRDD属性的延迟生成DataSourceRDD实例 DataSourceRDD ==&gt; DataSourceRDD::compute方法创建PartitionReader实例 PartitionReader ==&gt; Iceberg中实现了Spark中的BatchDataReader接口 BatchDataReader ==&gt; BatchDataReader::open方法会创建Parquet文件上的迭代器（Spark中遍历数据的过程都是基于迭代器） VectorizedParquetReader ==&gt; VectorizedParquetReader::next方法，读取Parquet文件中的内容，并封装成Spark中的ColumnarBatch对象 ColumnarBatch 两种BaseBatchReader的实现类 BaseBatchReader支持以Batch + Vectorized的特性，读取底层的文件。
ColumnarBatchReader 通过VectorizedSparkParquetReaders::build Reader()静态方法创建的读取器，关键特性如下：
支持读取Delete File以Arrow的格式直接读取Parquet文件最终返回的数据集的类型为Spark.ColumnarBatch，是Spark中的实现类 public static ColumnarBatchReader buildReader( Schema expectedSchema, MessageType fileSchema, Map&lt;Integer, ?&gt; idToConstant, DeleteFilter&lt;InternalRow&gt; deleteFilter) { return (ColumnarBatchReader) TypeWithSchemaVisitor.visit( expectedSchema.asStruct(), fileSchema, new ReaderBuilder( expectedSchema, fileSchema, NullCheckingForGet.NULL_CHECKING_ENABLED, idToConstant, ColumnarBatchReader::new, deleteFilter)); ArrowBatchReader 通过ArrowReader::buildReader()静态方法创建的读取器，关键特性如下：
不支持读取Delete File以Arrow的格式直接读取Parquet文件返回的最终结果为ColumnarBatch类型，是Iceberg内置的实现类 在Iceberg 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f64ae52cf73e4ac0b277c43a93233dba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/392254e984f75ae37c8433c78d6b3f90/" rel="bookmark">
			Trino: 基于时间片的Split数据处理模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两种线程调度模型 其它一些主流的分布式计算引擎，如StarRocks，实现的数据处理模型也是基于时间片。
基于任务 JAVA库的线程池中的调度&amp;执行模型就是典型地、基于任务的。
一般地，通过实现Runnable接口，我们可以定义一个任务的执行逻辑，然后通过ExecutorService::submit(FutureTask)方法提交执行，一旦Runnable::run()方法执行结束，也就意味着与之绑定的线程的结束。
沿用Trino中的Split概念，在此模型下，run()方法负责处理一个完整的Split，才会返回处理结果，然后线程由执行态进入就绪态，等待新的任务。
一个简单的任务调度模型（So easy, but out of control）样例代码如下：
ExecutorService executor = Executors.newFixedThreadPool(1); CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; processing(split)), executor); future.join(); 优点：设计实现简单。
缺点：线程执行时间无法预估，例如执行过程中的某个操作被阻塞，则整个线程阻塞；线程中断逻辑复杂，想要实现中止线程的功能，需要考虑许多情况，并且中断时间延迟无法估计；线程状态的切换开销不可忽略。
基于时间片 类似操作系统中的CPU时间片的调度和执行模型。
沿用Trino中的Split概念，在此模型下，run()方法可以负责处理一个完整的Split，并且为这个线程分配一个时间片，例如1s，则如果1秒后这个Split没有处理完，当前线程就主动挂起这个Split，转而处理另外一个优先级更高的Split，而不会切换自己的状态为就绪态或阻塞态；同样地，如果在处理Split的过程中的某个操作被阻塞，则这个线程可以及时地挂起Split，转而去处理其它的Split。
优点：没有线程状态的切换开销；能够充分利用CPU资源，避免阻塞或等待；能够更好地基于权重处理Split；
缺点：实现复杂，不仅需要考虑如何释放任务，还需要考虑如何恢复任务。
Trino基于时间片的线程执行模型 相关概念 Split 由Coordinator调度分发给Worker执行，是对要读取的数据的描述
Page 是对Split的更细粒度的切分，是数据处理的最小单元，是Operator一次处理的数据集合。
Operator 作用于Split之上的执行单元，可以认为就是一个方法，对Page处理后产生一个新的Page。
Driver 绑定唯一一个Split及一组Operators，负责Split的数据上能够正确地流经Operators。
DriverSplitRunner Worker结点上执行Split的实体，它封装了Driver和Split。
PriorityDriverSplitRunner Worker结点上调度Split时的调度对象，它封装了DriverSplitRunner实例，同时带有权重指标。
Split调度&amp;执行流程图 Coordinator ---分发---&gt; Split ---&gt; Worker Worker ---接收---&gt; Split ---&gt; DiverSplitRunner ---&gt; PriorityDriverSplitRunner ---&gt; WaitingQueue TaskExecutor ---调度---&gt; WaitingQueue ---&gt; PriorityDriverSplitRunner PriorityDriverSplitRunner ---运行---&gt; Driver Driver ---处理---&gt; Operators ---&gt; Page ---&gt; BlockedFuture BlockedFuture ---阻塞---&gt; BlockingQueue BlockedFuture ---不阻---&gt; 时间片结束 ---&gt; WaitingQueue PriorityDriverSplitRunner ---完成---&gt; Driver ---完成---&gt; Operator ---完成---&gt; Worker创建工作线程池 Worker结点启动时，会通过Google Inject库，初始化工作线程池，这个线程池就是处理Split的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/392254e984f75ae37c8433c78d6b3f90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8ed24f7adf0780af99d8b4cc3b1c71a/" rel="bookmark">
			【android开发-07】android中ImageView的用法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，ImageView使用drawable图片的方法
ImageView是Android开发中常用的视图控件，用于显示图片资源。ImageView继承自View类，可以用于展示Bitmap或Drawable类型的图片资源。
ImageView可以通过XML属性设置显示图片，也可以通过Java代码进行设置。
XML属性包括：
android:src：用于设置ImageView所显示的Drawable对象的ID，例如设置显示保存在res/drawable目录下的图片。
android:maxHeight和android:maxWidth：用于设置ImageView组件的最大高度和宽度。需要将android:adjustViewBounds属性设置为true，否则不生效。
android:tint：用于对图片进行着色，其属性可以是#rgb、#argb、#rrggbb或#aarrggbb表示的颜色值。
android:scaleType：用于设置图片的缩放模式，例如matrix、fitXY、fitStart、fitCenter等。
在Java代码中，可以通过ImageView的setImageResource()方法设置图片资源，参数为R.drawable.图片名。也可以通过setImageBitmap()方法设置位图图片。
例如，以下是一个使用ImageView显示图像资源的常见示例：
XML布局代码：
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/my_image" android:contentDescription="@string/my_image_description"/&gt; &lt;/LinearLayout&gt; Java代码示例：
ImageView imageView = findViewById(R.id.imageView); // 从布局文件中获取id为imageView的ImageView imageView.setImageResource(R.drawable.my_image); // 设置ImageView的图片资源为res/drawable目录下的my_image图片 2，ImageView使用bitmap代码例子
在Android中，ImageView可以通过使用Bitmap对象来显示图片。以下是一个例子：
// 创建一个Bitmap对象，可以从资源文件或者文件中获取 Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.my_image); // 获取ImageView对象 ImageView imageView = findViewById(R.id.my_image_view); // 将Bitmap对象设置到ImageView中 imageView.setImageBitmap(bitmap); 这个例子假设你有一个名为my_image的图片资源文件，并且你已经在你的项目中的res/drawable目录下。ImageView的id是my_image_view。这段代码会从资源文件中获取Bitmap，然后将这个Bitmap设置为ImageView的图像。
如果你需要从文件中获取Bitmap，你可以使用BitmapFactory.decodeFile(String path)方法。这个方法需要一个文件路径作为参数，它会返回一个表示该文件的Bitmap对象。
注意：当使用ImageView显示大图像或者大量图像时，你可能会遇到内存问题。这是因为ImageView不会自动管理其Bitmap对象的内存。如果你不再需要显示这个Bitmap，你应该调用imageView.setImageBitmap(null)或者bitmap.recycle()来释放内存。
3,ImageView实现缩放操作
在Android中，可以使用ScaleType属性来改变ImageView的图像大小。以下是如何实现的一些例子：
1，在XML布局文件中定义ImageView，并设置ScaleType属性： &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/my_image" android:scaleType="centerCrop"/&gt; 2，在这个例子中，图像将被缩放以适应ImageView，并保持其原始纵横比。如果图像的纵横比与ImageView的纵横比不同，那么图像将被裁剪。
在Java或Kotlin代码中动态设置ImageView的ScaleType属性： ImageView imageView = new ImageView(this); imageView.setImageResource(R.drawable.my_image); imageView.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8ed24f7adf0780af99d8b4cc3b1c71a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ed4eafe455b1d426bd9801f42682e47/" rel="bookmark">
			springboot、spring-kafka、kafka-client的版本对应关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在使用springboot集成kafka的时候需要注意springboot版本、引用的依赖spring-kafka版本和kafka中间件版本的对应关系，否则可能会因为版本不兼容导致出现错误。
1、含义说明（摘自官网） Spring Boot：是springboot的版本。Spring for Apache Kafka Version ：是springboot集成的spring-kafka的版本，如 &lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt; &lt;version&gt;2.6.8&lt;/version&gt; &lt;/dependency&gt; spring Integration for Apache Kafka Version ：是springboot集成的spring-integration-kafka的版本，如 &lt;dependency&gt; &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt; &lt;artifactId&gt;spring-integration-kafka&lt;/artifactId&gt; &lt;version&gt;3.3.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; kafka-clients : 是springboot集成的spring-kafka，spring-kafka中引入了kafka-client的版本，对应kafka中间件版本，如
2、springboot、spring-kafka、kafka-client的版本对应关系（摘自官网） Spring for Apache Kafka的官网地址如下：
3、注意 在项目中应用时需要根据具体的环境，若项目采用springboot框架，则可以直接引用spring-kafka依赖，选择对应的依赖版本和kafka中间件版本即可。若项目为普通项目，则可以直接引用kafka-clients依赖，如下
&lt;!-- https://mvnrepository.com/artifact/org.apache.kafka/kafka-clients --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb3fdfb79d628812317ea3982132e493/" rel="bookmark">
			推荐 ：手把手教你用Python创建简单的神经网络（附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解神经网络工作方式的最佳途径莫过于亲自创建一个神经网络，本文将演示如何做到这一点。
神经网络(NN)又称人工神经网络(ANN)，是机器学习领域中基于生物神经网络概念的学习算法的一个子集。
拥有五年以上经验的德国机器学习专家Andrey Bulezyuk声称：“神经网络正在彻底改变机器学习，因为它们能够在广泛的学科和行业中为抽象对象高效建模。”
人工神经网络基本上由以下组件组成：
输入层：接收并传递数据隐藏层输出层各层之间的权重每个隐藏层都有一个激活函数。在这个简单的神经网络Python教程中，我们将使用Sigmoid激活函数。 神经网络有多种类型。在本项目中，我们将创建前馈或感知神经网络。这种类型的ANN直接将数据从前向后传递。
前馈神经元的训练往往需要反向传播，它为网络提供了相应的输入和输出集。当输入数据被传送到神经元时，经过处理后，产生一个输出。
下面的图表显示了一个简单的神经网络的结构：
了解神经网络如何工作的最佳方法是学习如何从头开始构建神经网络(而不是采用任何库)。
在本文中，我们将演示如何利用Python编程语言创建一个简单的神经网络。
问题 如下是一个展示问题的表格。
我们将提供一个新的数据集，利用它训练神经网络，从而能够预测正确的输出值。
正如上表所示，输出值总是等于输入部分中的第一个值。因此，我们期望输出的值为1。
让我们看看是否可以使用Python代码来得出相同的结果(你可以在本文末尾仔细阅读这个项目的代码，然后再继续阅读本文)。
创建一个NeuralNetwork类 我们将用Python创建一个NeuralNetwork类来训练神经元，以期给出准确的预测。这个类还会有其他的帮助函数。
即使我们不会在这个简单的神经网络示例中使用神经网络库，我们也将导入numpy库来辅助计算。
numpy库提供了以下四种重要方法：
exp—用于生成自然指数array—用于生成矩阵dot—用于矩阵相乘random—用于生成随机数。请注意，我们将生成随机数，以确保它们的有效分布。 1.应用Sigmoid函数 我们将使用Sigmoid函数，来绘制一个特征“S”型曲线，作为神经网络的激活函数。
此函数可以将任何值映射到0到1之间的值，它将有助于我们对输入的加权和归一化。
此后，我们将创建Sigmoid函数的导数，以帮助计算权重的调整参数。
可以利用Sigmoid函数的输出来生成它的导数。例如，如果输出变量为“x”，则其导数为x*(1-x)。
2. 训练模型 这是我们教神经网络做出准确预测的阶段。每个输入都有一个权重-可为正值或负值。这意味着：有较大的正权重或负权重的输入会对结果的输出产生更大的影响。请记住，我们最初是通过为每个随机数分配一个权重后开始的。
下面是这个神经网络示例的训练过程：
第一步：从训练数据集中提取输入，根据训练数据集的权重进行调整，并通过一种计算神经网络输出的方法对其进行筛选。
第二步：计算反向传播错误率。在这种情况下，它是神经元的预测输出与训练数据集的期望输出之间的差异。
第三步：利用误差加权导数公式，根据所得到的误差范围，进行了一些较小的权值调整。
第四步：对这一过程进行15000次迭代。在每次迭代中，整个训练集被同时处理。
我们使用“.T”函数将矩阵从水平位置转换为垂直位置。因此，数字将以如下方式存储：
最终，神经元的权重将根据所提供的训练数据进行优化。随后，如果让神经元考虑一个新的状态，与先前的状态相同，它便可以作出一个准确的预测。这就是反向传播的方式。
打包运行 最后，NeuralNetwork类初始化成功后，可以运行代码了。
下面是如何在Python项目中创建神经网络的完整代码：
import numpy as np class NeuralNetwork(): def __init__(self): # seeding for random number generation np.random.seed(1) #converting weights to a 3 by 1 matrix with values from -1 to 1 and mean of 0 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb3fdfb79d628812317ea3982132e493/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fd8829b482a5fcbffca8a3647cd8fdd/" rel="bookmark">
			如何使用 Python 实现彩票自由（双色球）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		福彩双色球也是购买次数最多的彩种之一，相比大乐透，双色球更容易中小奖
下面将介绍 Python 实习双色球彩票自由的流程
1. 随机一注 福彩双色球一注同样包含 7 个数字，包含 6 个红球和 1 个篮球
其中
红球是从 1 - 33 中选择 6 个不同的数字蓝球是从 1 - 16 中选择 1 个不同的数字 使用 Python 随机生成一注双色球号码，部分代码如下：
def gene_ssq(number): """ 随机产生几注双色球（6+1） :param number: :return: """ result = [] for item in range(number): reds = [] # 产生6个红球 while len(reds) &lt; 6: # 从1-33中随机取一个数字 temp_red_num = random.randint(1, 33) if temp_red_num not in reds: reds.append(temp_red_num) # 蓝球 blue = random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fd8829b482a5fcbffca8a3647cd8fdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04906733623ed6e88b091197535d04b4/" rel="bookmark">
			简单三步，用 Python 发邮件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 前言 发送电子邮件是个很常见的开发需求。比如你写了个监控天气的脚本，发现第二天要下雨，或者网站上关注的某个商品降价了，就可以发个邮件到邮箱来提醒自己。
使用 Python 脚本发送邮件并不复杂。不过由于各家邮件的发送机制和安全策略不同，常常会因为一些配置问题造成发送失败。今天我们来举例讲讲如何使用 Python 发送邮件。
本文主要内容包括，了解发邮件的思路，发送邮件需要的一些设置，发送一封简单的邮件，发送一封包含附件的邮件，在写代码过程中我们需要注意哪些问题等等。（完整参考代码地址见文末）
1. 思路 使用脚本发送邮件的思路其实和客户端发送邮件一样，过程都是：
登录 —&gt; 写邮件 —&gt; 发送
只不过通过脚本发送时我们需要考虑到整个过程的方方面面。以下为思路导图：
2. Python-email 模块 与发送邮件相关的 Python 模块：
smtplib
是关于 SMTP（简单邮件传输协议）的操作模块，在发送邮件的过程中起到服务器之间互相通信的作用。
email
简单来说，即服务器之间通信的信息，包括信息头、信息主体等等。
举个简单的例子，当你登录邮箱，写好邮件后点击发送，这部分是由 SMTP 接管；而写邮件、添加附件是由 email 模块控制。
3. 开通电子邮箱的SMTP功能 在使用脚本发邮件之前，我们需要打开自己邮箱的 SMTP 功能，各家邮箱的设置方法就不一一讲述了，具体使用时可以百度一下，下面以 163 邮箱设置为例做一个简单的演示：
4. 简单代码 实践出真知，我们结合一个简单的代码来理解这一过程：登录 163 邮箱，向 qq 邮箱发送邮件。
脚本分为三个步骤：
设置好服务器端信息邮件主体信息登录发送 另外在处理文本时，我们需要使用 MIMEText 类。
import smtplib from email.mime.text import MIMEText #设置服务器所需信息 #163邮箱服务器地址 mail_host = 'smtp.163.com' #163用户名 mail_user = '159*****02' #密码(部分邮箱为授权码) mail_pass = '7******x' #邮件发送方邮箱地址 sender = '159*****02@163.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04906733623ed6e88b091197535d04b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/141999d2a95e983c491da08163837388/" rel="bookmark">
			如何访问GitHub快的飞起？两步解决访问超时GitHub，无法访问GitHub的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查找国内访问比较快的IP 站长工具网址： https://tool.chinaz.com
测速链接: https://tool.chinaz.com/speedtest/github.com
输入 github.com 点击查看分析
往下滑动，找一个比较快的IP，然后去修改hosts配置文件 （例如：20.205.243.166）
2.修改hosts配置文件 hosts配置文件地址：C:\Windows\System32\drivers\etc\hosts
打开hosts文件，在其末尾插入 IP 域名
保存退出hosts文件，再次访问，快的飞起 👻
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ca46591083066a8721ae29e7e60c829/" rel="bookmark">
			手把手教你编写Python抢购脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想买苹果手机，但总是抢不到，所以想试着能不能写个脚本代码。
第一步：把想要抢购的商品加进购物车，注意：脚本是对购物车内全部商品进行下单操作，所以不够买的商品最好先从购物车内删除。
第二步：写好Python脚本，在抢购之前运行，并设置好抢购时间。
Python脚本实现 安装Python。我安装的是anaconda安装webdriver扩展。它是Selenium模块的一部分。Selenium是一个用于Web应用程序测试的工具，用于测试你的应用程序看是否能够很好得工作在不同浏览器和操作系统之上。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。所以其实就是安装Selenium：Win+R，输入cmd，在命令行中输入pipshow selenium安装chrome浏览器（因为我用的是谷歌）安装chromedriver。它是chrome的插件，是为了webDriver能通过操作chromedriver来控制chrome浏览器自动操作，如打开网页，点击按钮等操作。 下载地址：
http://chromedriver.storage.googleapis.com/index.html或https://npm.taobao.org/mirrors/chromedriver/
**注意：下载时要根据电脑系统和chrome浏览器版本来选择对应的chromedriver版本。**可以通过浏览器右上角的三点→帮助→关于Google Chrome来查看自己的chrome版本。
下载chromedriver安装包后，进行解压，放在chrome安装的同级目录下，同时在环境变量PATH中添加路径。
然后用以下代码检验是否安装成功：
然鹅，此时我遇到了错误，如下
于是，我把chromedriver.exe放到了我python脚本的文件夹后，就完美解决问题了！
【补充】
我知道自己为什么出现上面那个错误了，因为路径没输入！
在下图所示红框处输入自己的下载的chromedriver安装路径即可成功运行。
完整的Python脚本代码如下：
```python # coding=utf-8 import os from selenium import webdriver import datetime import time from os import path #此处chromedriver改为自己下载解压的chromedriver的路径 driver = webdriver.Chrome("E:/JupyterNotebookSavePath/chromedriver") #driver.maximize_window() def login(): #打开淘宝首页，扫码登陆淘宝 driver.get("https://www.taobao.com") time.sleep(3) if driver.find_element_by_link_text("亲，请登录"): driver.find_element_by_link_text("亲，请登录").click() print("请在15秒内完成扫码") time.sleep(15) #打开购物车列表首页 driver.get("https://cart.taobao.com/cart.htm") time.sleep(3) #全选购物车 if driver.find_element_by_id("J_SelectAll1"): driver.find_element_by_id("J_SelectAll1").click() now = datetime.datetime.now() print("login success:", now.strftime("%Y-%m-%d %H:%M:%S")) def buy(times): while True: #记录当前时间，使用datatime内置模块 now = datetime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ca46591083066a8721ae29e7e60c829/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/319984890dfdbdc3290b6e8e8bafcdbb/" rel="bookmark">
			Pycharm下载安装详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pycharm下载安装详细教程 目录 1、Pycharm 简介2、Pycharm下载3、环境变量的配置4、Pycharm的使用 1、Pycharm 简介 PyCharm是一种Python IDE（Integrated Development Environment，集成开发环境），带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，比如调试、语法高亮、项目管理、代码跳转、智能提示、自动完成、单元测试、版本控制。此外，该IDE提供了一些高级功能，以用于支持Django框架下的专业Web开发。
非常适合刚学习Python的小白，目前最强大的编译器，没有之一。
2、Pycharm下载 这边推荐自己操作一遍去官网下载.pycharm官网
pycharm在官网是分为两个版本，第一个版本是Professional(专业版本)，这个版本功能更加强大，主要是为Python和web开发者而准备，是需要付费的。第二个版本是社区版，比较轻量级，主要是为Python和数据专家而准备的。
专业的人员当然要下载专业版啦~虽然收费文章末尾会给如何实现破解版的小tips！
图示如下：
第一步，打开官网界面，进入到下载界面 第二步，打开安装包，开始安装
第三步，选择安装路径
第四步，一些功能的选择
第五步，直接下一步，点击Install
第七步，完成
3、环境变量的配置 第一步、右击此电脑点击属性，点击高级系统设置，点击环境变量，打开Path新建
第二步、查看Pycharm路径
第三步、拷贝路径，完成环境变量的配置
4、Pycharm的使用 第一步、打开Pycharm初步使用
第二步、勾选我同意，点击继续
第三步、选择Don’t Send
第四步、选择免费试用30天
第五步、创建项目
第六步、关联python解释器
第七步、一步一步来
第八步、选file，然后选中“New Project…老方法写一个Hello world测试一下，查看运行结果 print('Hello world!') 这样就完成pycharm的下载了！快去使用吧！
关于Python技术储备 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
👉[[CSDN大礼包：《python兼职资源&amp;全套学习资料》免费分享]]（安全链接，放心点击）
一、Python所有方向的学习路线 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python必备开发工具 四、Python视频合集 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
六、Python练习题 检查学习结果。
七、面试资料 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e829ee5b511438414a310fb698055b4a/" rel="bookmark">
			《现代C&#43;&#43;语言核心特性解析》笔记（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二十四、三向比较（C++20） 1. “太空飞船”（spaceship）运算符 C++20标准新引入了一个名为“太空飞船”（spaceship）的运算符 &lt;=&gt;，它是一个三向比较运算符。&lt;=&gt; 之所以被称为“太空飞船”运算符是因为 &lt;=&gt; 让著名的Perl语言专家兰德尔·L.施瓦茨想起1971年的一款电子游戏《星际迷航》中的太空飞船。读者应该也看出来了，&lt;=&gt; 并不是 C++20首创的，实际上Perl、PHP、Ruby等语言早已支持了三向比较运算符，C++是后来的学习者。
顾名思义，三向比较就是在形如 lhs &lt;=&gt; rhs 的表达式中，两个比较的操作数 lhs 和 rhs 通过 &lt;=&gt; 比较可能产生3种结果，该结果可以和0比较，小于0、等于0或者大于0分别对应 lhs &lt; rhs、lhs == rhs 和 lhs &gt; rhs。举例来说：
bool b = 7 &lt;=&gt; 11 &lt; 0; // b == true 请注意，运算符&lt;=&gt;的返回值只能与0和自身类型来比较，如果同其他数值比较，编译器会报错：
bool b = 7 &lt;=&gt; 11 &lt; 100; // 编译失败，&lt;=&gt; 的结果不能与除 0 以外的数值比较 2. 三向比较的返回类型 可以看出 &lt;=&gt; 的返回结果并不是一个普通类型，根据标准三向比较会返回3种类型，分别为 std::strong_ordering、std::weak_ordering 以及 std::partial_ordering，而这3种类型又会分为有3～4种最终结果，下面就来一一介绍它们。
1. std::strong_ordering std::strong_ordering 类型有3种比较结果，分别为 std::strong_ordering::less、std::strong_ordering::equal 以及 std::strong_ordering::greater。表达式 lhs &lt;=&gt; rhs 分别表示 lhs &lt; rhs、lhs == rhs 以及 lhs &gt; rhs。std::strong_ordering 类型的结果强调的是 strong 的含义，表达的是一种可替换性，简单来说，若 lhs == rhs，那么在任何情况下 rhs 和 lhs 都可以相互替换，也就是 fx(lhs) == fx(rhs)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e829ee5b511438414a310fb698055b4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f813a0fbb4d79faada3e5e0deb425bcf/" rel="bookmark">
			两步带你解决IDEA 插件下载安装慢、超时、不成功问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两步带你解决IDEA 插件下载安装慢、超时、不成功问题 1. 查找 国内插件的节点IP地址2. 修改本地hosts文件 &gt; 今天在安装idea中的插件时，又双叒叕出现了这个问题，下载一个几MB的插件巨慢，所以写一下它的解决方案
1. 查找 国内插件的节点IP地址 站长工具: https://tool.chinaz.com/dns/
查找链接: https://tool.chinaz.com/speedtest/plugins.jetbrains.com
在检测结果中选择一个相对耗时少的IP地址 ，例如 第一个 ”13.227.74.128“
2. 修改本地hosts文件 Windows 系统 Hosts 文件路径：C:\Windows\System32\drivers\etc\hosts
编辑完毕后保存（需要管理员身份）
再次下载插件，快的起飞了😎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2b5f1756a2b38e514a6eb732f95ddeb/" rel="bookmark">
			P60 生成式对抗网络GAN -生成器效能评估与条件式生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GAN 生成一段文字，很困难
scratch gan 可以训练温习
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a4170012b886bb250e8bea99d27ca78/" rel="bookmark">
			MR实战：词频统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、实战概述二、提出任务三、完成任务（一）准备数据1、在虚拟机上创建文本文件2、上传文件到HDFS指定目录 （二）实现步骤1、创建Maven项目2、添加相关依赖3、创建日志属性文件4、创建词频统计映射器类5、创建词频统计归并器类6、创建词频统计驱动器类7、启动应用，查看结果 四、实战总结 一、实战概述 本实战演练旨在利用Hadoop MapReduce框架在虚拟环境中执行一个简单的词频统计任务。首先，在master节点上创建了一个包含多个单词行的文本文件words.txt，并将该文件上传至HDFS中的指定目录/wordcount/input。
在集成开发环境IntelliJ IDEA中，我们创建了一个名为MRWordCount的Maven项目，并引入了Apache Hadoop 3.3.4版本的客户端依赖和JUnit测试框架。为了便于日志管理，添加了log4j.properties配置文件来定义日志输出格式及位置。
接下来，实现了两个关键类：WordCountMapper和WordCountReducer。WordCountMapper继承自Mapper接口，负责读取输入文本文件中的每一行内容，将每行按空格分割成单词，并为每个单词生成一个键值对（&lt;单词, 1&gt;），以便后续计数处理。而WordCountReducer则继承自Reducer接口，它接收Mapper阶段产生的所有相同单词的键及其对应的次数，进行合并统计并输出格式化的"(单词, 出现次数)"键值对。
最后，通过WordCountDriver驱动类完成整个MapReduce作业的设置与执行。此类初始化Hadoop Configuration对象、设置Job参数（包括Mapper和Reducer类、键值类型等）、指定了HDFS上的输入输出路径，并最终提交作业至集群执行。作业完成后，WordCountDriver还会从HDFS上读取结果并显示到控制台。
经过上述步骤，当运行WordCountDriver主类时，程序将会读取HDFS上的输入文件，运用MapReduce模型进行分布式计算，最终得到期望的词频统计结果，并在控制台展示出来。这个实例展示了如何使用Hadoop MapReduce进行大规模数据处理的实际操作流程。
二、提出任务 单词文件 - words.txt hello hadoop world hello hive world hello hbase world hadoop hive hbase I love hadoop and hive 使用MR框架，进行词频统计，输出如下结果
三、完成任务 （一）准备数据 1、在虚拟机上创建文本文件 在master虚拟机上创建words.txt文件
2、上传文件到HDFS指定目录 创建/wordcount/input目录，执行命令：hdfs dfs -mkdir -p /wordcount/input
将文本文件words.txt，上传到HDFS的/wordcount/input目录
（二）实现步骤 说明：集成开发环境IntelliJ IDEA版本 - 2022.3 1、创建Maven项目 Maven项目 - MRWordCount，设置了JDK版本 - 1.8，组标识 - net.huawei.mr
单击【Create】按钮，得到初始化项目
2、添加相关依赖 在pom.xml文件里添加hadoop-client和junit依赖
&lt;dependencies&gt; &lt;!--hadoop客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a4170012b886bb250e8bea99d27ca78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97d2584fe1327230d59adffe6166855c/" rel="bookmark">
			使用国内镜像源来安装 Golang 包：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用国内镜像源来安装 Golang 包：
阿里云：https://mirrors.aliyun.com/goproxy/
要使用这些镜像源，请将 GOPROXY 环境变量设置为所选镜像源的 URL。例如，要使用阿里云镜像源，请在命令行中运行以下命令：
export GOPROXY=https://mirrors.aliyun.com/goproxy/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ca45ff89eb1bfeec6f14647850c1875/" rel="bookmark">
			零基础：数据分析的完整Python教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.用于数据分析的Python基础（略）
为什么要学习Python进行数据分析？Python 2.7 v /秒3.4如何安装Python？在Python中运行一些简单的程序 2.Python库和数据结构
Python数据结构Python迭代和条件构造Python库 3.使用Pandas在Python中进行探索性分析
系列和数据框简介Analytics Vidhya数据集-贷款预测问题 3.使用Pandas在Python中进行数据整理
系列和数据框简介Analytics Vidhya数据集-贷款预测问题 4.使用Pandas在Python中进行数据整理
5.用Python构建预测模型
逻辑回归决策树随机森林 2.Python库和数据结构 Python数据结构 以下是一些在Python中使用的数据结构。您应该熟悉它们，以便适当地使用它们。
列表 –列表是Python中功能最丰富的数据结构之一。列表可以简单地通过在方括号中写一个用逗号分隔的值列表来定义。列表可能包含不同类型的项目，但是通常所有项目都具有相同的类型。Python列表是可变的，并且列表的各个元素都可以更改。 这是一个定义列表然后访问它的快速示例：
字符串–可以简单地通过使用单（‘），双（“”）或三（“’））反向逗号来定义字符串。用三引号引起来的字符串可以跨越多行，并且经常在文档字符串中使用（Python记录函数的方式）。\用作转义符。请注意，Python字符串是不可变的，因此您不能更改部分字符串。
元组 –元组由用逗号分隔的多个值表示。元组是不可变的，并且输出用括号括起来，以便正确处理嵌套的元组。此外，即使元组是不可变的，但如果需要，它们也可以保存可变数据。 由于元组是不可变的并且不能更改，因此与列表相比，它们的处理速度更快。因此，如果您的列表不太可能更改，则应使用元组而不是列表。
词典- d ictionary是无序集合的 键：值 对，与所述的要求，即，键是唯一的（一个字典内）。一对大括号创建一个空字典： {}。
Python迭代和条件构造 像大多数语言一样，Python也有一个FOR循环，这是最广泛使用的迭代方法。它具有简单的语法：
for i in [Python Iterable]: expression(i) 这里的“ Python Iterable”可以是列表，元组或其他高级数据结构，我们将在后面的部分中进行探讨。让我们看一个简单的示例，确定数字的阶乘。
fact=1 for i in range(1,N+1): fact *= i 谈到条件语句，这些语句用于根据条件执行代码片段。最常用的构造是if-else，其语法如下：
if [condition]: __execution if true__ else: __execution if false__ 例如，如果我们要打印数字N是偶数还是奇数：
if N%2 == 0: print ('Even') else: print ('Odd') 现在您已经熟悉了Python基础知识，让我们再进一步。如果必须执行以下任务怎么办：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ca45ff89eb1bfeec6f14647850c1875/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c508ed17a7a22274448aedd89714422/" rel="bookmark">
			C语言——指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定义 指针也就是内存地址，指针变量是用来存放内存地址的变量。
将内存以一个字节分为一个个内存单元，每个内存单元都进行编号，这个编号就是地址，也就是指针。
int b = 1; int *pb = &amp;b; //这里的pb变量是一个整型指针变量，用来存放整型变量b的地址 我们可以通过&amp;（取地址操作符）得到一个变量的地址，然后将地址存到一个指针变量中，可以用这个指针变量来访问那个变量。
二、指针的大小 对于32位机器，假设CPU与内存之间有32条地址线，每一根寻址线在工作时会产生高电平（代表1）和低电平（代表0），则这个机器可以产生
00000000 00000000 00000000 00000000
到
11111111 11111111 11111111 11111111
这么多的地址，一共是2 ^ 32 个地址，一个地址指向的内存单元是一字节，所以这么多地址可以指向大约4GB的内存。
对于64位机器，假设CPU与内存之间有64条地址线，每一根寻址线在工作时会产生高电平（代表1）和低电平（代表0），则这个机器可以产生
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
到
11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111
这么多的地址，一共是2 ^ 64 个地址，一个地址指向的内存单元是一字节，所以这么多地址可以指向更大的内存。
这里我们发现，地址的大小是取决于地址线的多少的（或者是系统位数），对于32位机器，地址是32位的，也就是32bit的大小，所以是4字节的大小，所以32位机器的地址大小是4字节；相应的64位机器的地址是8字节。
#include &lt;stdio.h&gt; int main() { int b = 1; int *pb = &amp;b; printf("%zu\n", sizeof(pb)); return 0; } 64位平台输出结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c508ed17a7a22274448aedd89714422/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0117b75f06506119603b250a6f403b40/" rel="bookmark">
			【机器学习|Python】sklearn中的数据预处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本篇文章主要讲解Python的sklearn库中常用的数据预处理方法，主要介绍工具中的内容，即该库中的相关方法包含的常用接口和基本使用，并不适合手把手入门学习，此外将涉及更少的原理和使用情况说明。
更多关于本文涉及的数据预处理方法的原理知识：【机器学习】数据预处理方法中的数学原理 (1) - 掘金 (juejin.cn) sklearn中的数据预处理 sklearn.preprocessing：sklearn中的数据预处理模块sklearn.impute：sklearn中的缺失值填充模块 本文主要涉及的方法：
极差归一化：sklearn.preprocessing.MinMaxScaler数据标准化：sklearn.preprocessing.StandardScaler标签编码：sklearn.preprocessing.LabelEncoder特征编码：sklearn.preprocessing.OrdinalEncoder数据二值化：sklearn.preprocessing.Binarizer数据分箱：sklearn.preprocessing.KBinsDiscretizer缺失值处理：sklearn.impute.SimpleImputer ps：拟合的时候可以传入多个特征数据，sklearn中的方法大多都会自动分别对每一列进行处理，但sklearn一般不支持一维数据导入，至少为二维，若想传入一维数组进行处理可以使用reshape(-1, 1)转为二维数组，若想传入单个Series对象则需要先将其转为DataFrame对象。
数据无量纲化 极差归一化：统一量纲，将某特征下所有的值归一化在指定范围内，默认该范围为 [0,1][0, 1][0,1]，也可以手动确定范围。
常用接口如下：
import pandas as pd import numpy as np from sklearn.preprocessing import MinMaxScaler data = pd.DataFrame(np.random.randint(10, 100, (5, 2))) # 准备测试数据 # 常用接口 scaler = MinMaxScaler() # 默认范围为 [0,1] scaler = MinMaxScaler(feature_range=[5, 10]) # 自定义归一化数据范围 scaler.fit(data) # 拟合数据 scaler.partial_fit(data) # 数据量大的时候fit()报错，可以使用partial_fit() result = scaler.transform(data) # 变换数据 result = scaler.fit_transform(data) # 拟合和变换一步达成 data = scaler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0117b75f06506119603b250a6f403b40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b77b2ae93608b673e60117438f73623a/" rel="bookmark">
			贪心算法：活动选择问题以及贪心选择性质证明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么时候使用贪婪算法? – 贪心选择特性: 全局的最优解可以通过局部的最优（贪婪） 选择得到.
• 动态规划需要检查子问题的解。 – 最优子结构: 问题的最优解包含了其子问题的最优解.
• 例如, 如果 A 是S的最优解, 那么 A ' = A - {1} 是 的最优解.
• 贪心算法 (试探) 并不能总是得到最优解.
• 谈论算法和动态规划 (DP)对比 – 相同: 最优子结构
– 差别: 贪婪选择特性
– 如果贪婪算法不是最优的， 可以使用DP 。
活动选择问题 给定一个集合 S = {1, 2, …, n} n个计划的活动,对每个活动 ， 开始时间为 结束时间为 , 选择出相互兼容的活动最大集合.
– 如果被选中,活动 在半开放的区间中进行.
– 活动 和兼容 如果 和 不重叠
问题分析 基本思想 对应伪代码 贪心选择性质证明 设为问题所给的活动集合，且E中的活动是按照活动结束时间增序排列的，明显，活动为最早结束。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b77b2ae93608b673e60117438f73623a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/29/">«</a>
	<span class="pagination__item pagination__item--current">30/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/31/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>