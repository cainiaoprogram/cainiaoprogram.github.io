<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91c78567a73540e59da6761d98436578/" rel="bookmark">
			【程序5】题目：利用条件运算符的嵌套来完成此题：学习成绩&gt;=90分 	的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* 2017年3月2日13:29:42 java基础50道经典练习题 例5 Author:ZJY(&amp;&amp;) Purpose:(a&gt;b)?a:b的应用 【程序5】 题目：利用条件运算符的嵌套来完成此题：学习成绩&gt;=90分 的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。 程序分析：(a&gt;b)?a:b这是条件运算符的基本例子。 */ import java.util.Scanner; public class ProgramNo5_1 { public static void main(String[] args) { System.out.printf("请输入学生的成绩:"); Scanner sc = new Scanner(System.in); int score = sc.nextInt(); grade(score); } private static void grade(int score) { if((0 &gt; score)|| (100 &lt; score)){ System.out.printf("输入学生成绩无效!!"); }else { String str = ((score &gt;= 90)? "分，属于A等级。" :((score &gt;= 60)? "分，属于B等级。" :"分，属于C等级。")); System.out.println("该学生得分:" + score + str); } } } /* 2017年3月2日13:29:42 java基础50道经典练习题 例5 注意点: public static void main(String[] args) 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91c78567a73540e59da6761d98436578/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b5f91bef69c622f6c631ba8af7b7446/" rel="bookmark">
			DDR地址和容量计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DDR3 地址线 DDR3为减少地址线，把地址线分为行地址线和列地址线，在硬件上是同一组地址线；地址线和列地址线是分时复用的，即地址要分两次送出，先送出行地址，再送出列地址。
一般来说列地址线是10位，及A0...A9；行地址线数量根据内存大小，BANK数目，数据线位宽等决定(感觉也应该是行地址决定其他) ;
BANK bank是存储库的意思，也就是说，一块内存内部划分出了多个存储库，访问的时候指定存储库编号，就可以访问指定的存储库，内存中划分了多少个bank，要看地址线中有几位BA地址，如果有两位，说明有4个bank，如果有3位，说明有8个bank
DDR3 容量计算 下面这张图是芯片k4t1g164qf资料中截取的；以1Gb容量的DDR2颗粒为例（其他的类似）；假设数据线位宽为16位，则看64Mb x 16这一列:
bank地址线位宽为3，及bank数目为 2^3=8；
行地址线位宽位13，及A0...A12；
列地址线位宽为10，及A0...A9；
有 2^3 * 2^13 * 2^10 = 2^26 =2^6Mb = 64Mb
再加上数据线，则容量为 64Mb x 16
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d4ac664e1589dc14123bf64ac5e2760/" rel="bookmark">
			JSONObject.fromObject()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在将前台传回的对象JSON集字串在后台转为对象集时老是出错，搜了很久没有解决方法，一查API，搞定。
JSONObject.fromObjec()不能解析list中NULL值。
当然，这个NULL值不是指JSON对象为NULL值，实际写没这么用的。这个NULL值是指 JSON字串中 对象的属性/方法不能为NULL值。JSONObject.fromObjec()会去调用正确的JSONObject工厂方法，而NULL值明显没有。
fromObject
public staticJSONObject fromObject(Object object)
Creates a JSONObject.
Inspects the object type to call the correct JSONObject factorymethod. Accepts JSON formatted strings, Maps, DynaBeans and JavaBeans.
Parameters:
object -
Throws:
JSONException - if the object can not be converted to a properJSONObject.
fromObject
public staticJSONObject fromObject（Object object）
创建JSONObject。
检查对象类型以调用正确的JSONObject工厂方法。 接受JSON格式的字符串，Maps，DynaBeans和JavaBeans。
参数：
object -
抛出异常：
JSONException - 如果对象无法转换为正确的JSONObject。
所以说，要多看API！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6f3a61aa97d7084252731c888ed4d80/" rel="bookmark">
			转载： Fisher精确检验概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fisher 精确检验 检验两个二进制变量是否是独立的。该检验可以分析 2x2 列联表，并产生精确的 p 值， 以检验以下假设： · H0：行变量和列变量是独立的 · H1：行变量和列变量是相关的 Fisher 精确检验中的 p 值对于所有样本数量都是准确的，而当单元格计数较小时， 用于检查相同假设的卡方检验的结果可能不准确。 例如，可以使用 Fisher 精确检验来分析下面的竞选结果列联表， 以确定投票是否独立于投票人的性别。 候选人 A 候选人 B 女 9 26 男 21 35 对于该表，Fisher 精确检验产生的 p 值为 0.263。 由于该 p 值大于常用的 a 水平，因此数据与原假设一致。 因而，没有证据表明在竞选中投票人的性别会影响其选择。 ###下面这段没有看懂，留待后续学习###
您还可以使用 Fisher 精确检验来确定两个总体比率是否相等。
对于此应用，原假设假定两个总体比率是相等的 (H0:p1 = p2)； 备择假设可以是左尾 (p1&lt; p2)、右尾 (p1&gt; p2)，或双尾 (p1 ≠ p2)。 Fisher 精确检验作为两个比率的检验十分有用，因为它对于所有样本数量都是准确的， 而当事件数小于 5 时，以及试验数减去事件数的结果小于 5 时，基于正态近似的 2 个比率的检验可能不准确。 Fisher 精确检验基于超几何分布。因此，p 值在表的边际合计中是有条件的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c046a7dfc8b06cf33beaf23caebc6dff/" rel="bookmark">
			envi5.1安装出现the installation of msvc_2010_sp1_64 has failed 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 envi5.1安装出现the installation of msvc_2010_sp1_64 has failed 解决办法
这两天安装envi，总是装不上，提示the installation of msvc 2010 sp1 64 has failed 网上找解决办法，得到的就是下面的东西：
​​​​​​​
照着步骤修改注册表，还是不能安装，怎么办呢？装vcredistx86吧，可是装完了还是不能装envi，好崩溃。无奈之下只好开始分析问题，解决问题。
问：为什么装完了vcredistx86还是没法安装envi？
答：注意你的问题是the installation of msvc_2010_sp1_64 has failed ，你应该装手动vcredistx64
然后就开始装vcredistx64，但是遇到了一个严重错误，又安装失败。
问：为什么装vcredistx64失败？
答：电脑已经装了vcredistx64，只是安装可能存在问题，不符合envi软件安装环境，所以envi才安装失败，卸载vcredistx64重装吧
问：怎么卸载？
答：使用window install clean up，卸载掉
Microsoft Visual C++ 2010 Redistributable Package (x64) 结果：卸载重装了以后，重新安装envi，一路都很顺利。
最后说明：如果你的机子是32位的系统，一样的道理。
附上相关地址：------------------------------------------------
32位系统的机子：
vcredistx86下载地址：地址
如果要卸载，卸载
Microsoft Visual C++ 2005 Redistributable Package (x86) 64位系统的机子：
vcredistx64下载地址：地址
如果要卸载，卸载
Microsoft Visual C++ 2010 Redistributable Package (x64) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10b4290746c1fff9db20f16b5b8c61fa/" rel="bookmark">
			城市二级联动json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		{
"provinces": [
{
"name": "北京市",
"citys": [
"东城区",
"西城区",
"崇文区",
"宣武区",
"朝阳区",
"海淀区",
"丰台区",
"石景山区",
"房山区",
"通州区",
"顺义区",
"昌平区",
"大兴区",
"怀柔区",
"平谷区",
"门头沟区",
"密云区",
"延庆区",
"其他"
]
},
{
"name": "广东省",
"citys": [
"广州",
"深圳",
"珠海",
"汕头",
"韶关",
"佛山",
"江门",
"湛江",
"茂名",
"肇庆",
"惠州",
"梅州",
"汕尾",
"河源",
"阳江",
"清远",
"东莞",
"中山",
"潮州",
"揭阳",
"云浮",
"其他"
]
},
{
"name": "上海市",
"citys": [
"黄浦区",
"卢湾区",
"徐汇区",
"长宁区",
"静安区",
"普陀区",
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10b4290746c1fff9db20f16b5b8c61fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88c1e035bf7a82111a46759905edb09d/" rel="bookmark">
			重载的特点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义：一个类中含两个以上同名的方法，他们之间就构成重载
特点： 1、必须是两个以上同名的方法 2、方法之间的参数组合必须不同（参数的数目不同或者参数的类型不同） 3、方法的返回值不能作为判断方法之间是否构成重载的依据
好处： 大大简化啦的类调用者的代码，让我们感觉类有一种自动化调用的功能，而没有增加类创建的代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/719a15bf82631af629d769878275d15e/" rel="bookmark">
			爬虫框架Scrapy之Downloader Middlewares
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		反反爬虫相关机制 Some websites implement certain measures to prevent bots from crawling them, with varying degrees of sophistication. Getting around those measures can be difficult and tricky, and may sometimes require special infrastructure. Please consider contacting commercial support if in doubt. (有些些网站使用特定的不同程度的复杂性规则防止爬虫访问，绕过这些规则是困难和复杂的，有时可能需要特殊的基础设施。如果有疑问请联系商业支持。)
来自于Scrapy官方文档描述：http://doc.scrapy.org/en/master/topics/practices.html#avoiding-getting-banned
通常防止爬虫被反主要有以下几个策略：
动态设置User-Agent（随机切换User-Agent，模拟不同用户的浏览器信息）
禁用Cookies（也就是不启用cookies middleware，不向Server发送cookies，有些网站通过cookie的使用发现爬虫行为）
可以通过COOKIES_ENABLED 控制 CookiesMiddleware 开启或关闭 设置延迟下载（防止访问过于频繁，设置为 2秒 或更高）
Google Cache 和 Baidu Cache：如果可能的话，使用谷歌/百度等搜索引擎服务器页面缓存获取页面数据。
使用IP地址池：VPN和代理IP，现在大部分网站都是根据IP来ban的。
使用 Crawlera（专用于爬虫的代理组件），正确配置和设置下载中间件后，项目所有的request都是通过crawlera发出。
DOWNLOADER_MIDDLEWARES = { 'scrapy_crawlera.CrawleraMiddleware': 600 } CRAWLERA_ENABLED = True CRAWLERA_USER = '注册/购买的UserKey' CRAWLERA_PASS = '注册/购买的Password' 如何设置下载中间件（Downloader Middlewares） 下载中间件是处于引擎(crawler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/719a15bf82631af629d769878275d15e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22841460045b69cbf8317a4ef9f09e20/" rel="bookmark">
			JDK(1.6,1.7,1.8,10,11)64位解压版配置使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK(1.6,1.7,1.8,10,11)64位解压版配置使用
安装jdk解压版
下载jdk地址 链接: https://pan.baidu.com/s/1sm8O5dF 密码: 86p4
将下载的javaSE(1.6,1.7,1.8,10,11其中一种)解压到当前文件夹中。例如我的解压路径：
然后复制jdk的路径到path中：
验证其中配置的环境是否可用：
到此，配置压缩版jdk完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05ccfabbbb6fc19e31e6139f80ea5737/" rel="bookmark">
			vs编译libcurl和jsoncpp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先是编译libcurl，我下载的是7.52.1，下载地址是点击打开链接http://down.cnzz.cn/201612/63184eca.shtml
我主要参考的是点击打开链接http://www.cnblogs.com/jkcx/p/6406706.html 和
点击打开链接https://my.oschina.net/u/1420791/blog/198247
首先看第一篇，说是要打开开发人员命令提示，我不知道怎么打开，最后查到是在
开始-&gt;程序-&gt;visual studio 2013-&gt; visual studio tools里面，当然我用的是vs 2013。
然后打开开发人员命令，cd到curl-curl-7_52_1/winbuild/ 目录，
使用命令nmake /f Makefile.vc mode=static VC=12 RTLIBCFG=static编译，
成功之后，生成的库文件在builds/libcurl-vc12-x86-release-static-ipv6-sspi-winssl目录下，我们需要的是该目录下的include和libcurl_a.lib.
然后就要测试啦，新建一个工程，配置工程的时候需要注意一下几点：
①: 如果编译libcurl的时候是静态编译，那么就要设置项目-&gt;属性-&gt;c/c++-&gt;代码生成-&gt;运行库-&gt;多线程（/MT）.
同时
②项目-&gt;属性-&gt;c/c++-&gt;常规-&gt;附加包含目录,把builds/libcurl-vc12-x86-release-static-ipv6-sspi-winssl目录下的include包含进来。
③项目-&gt;属性-&gt;VC++目录-&gt;库目录，把builds/libcurl-vc12-x86-release-static-ipv6-sspi-winssl目录下的lib包含进来。
④项目-&gt;属性-&gt;链接器-&gt;输入-&gt;附加依赖项，里面添加
libcurl_a.lib
ws2_32.lib
winmm.lib
wldap32.lib
这四项。
⑤项目-&gt;属性-&gt;c/c++-&gt;预处理器-&gt;预处理器定义，如果有BUILDING_LIBCURL，就改成CURL_STATICLIB，如果没有就添加CURL_STATICLIB。因为我配置的时候就没有BUILDING_LIBCURL，我参考的资料里面却说有。
然后就可以了，就是这些问题。
2.jsoncpp的编译。jsoncpp最新下载地址点击打开链接https://github.com/open-source-parsers/jsoncpp
然后编译参考的文章主要有：点击打开链接http://blog.sina.com.cn/s/blog_6294abe7010156v5.html 和
点击打开链接http://www.bubuko.com/infodetail-1198176.html
之所以会有第二篇，是因为我编译的是 release版的，debug下就不会有问题。
我把release下生成的lib放到我的工程目录下，然后添加到项目属性的附加依赖项里，测试json，结果出现了这样的问题：
fatal error C1083: 无法打开编译器生成的文件:“../../build/vs71/release/lib_json\json_value.asm”: No such file or directory 然后我就重新打开json的解决方案jsoncpp-master\makefiles\vs71\jsoncpp.sln,项目-&gt;属性-&gt;c/c++-&gt;输出文件-&gt;汇编程序输出,改为无列表，重新编译。
成功之后生成的库文件在jsoncpp-master\build\vs71\release\lib_json\json_vc71_libmt.lib.当然这里我是release编译的。
然后新建一个项目测试，配置需要注意的是：
①我是release编译的，那么项目也要按照libcurl的①那样配置。
②项目-&gt;属性-&gt;VC++目录-&gt;库目录，把jsoncpp-master\build\vs71\release\lib_json添加进来，当然我这个路径并不完整，自己得按照自己的目录来添加。
③项目-&gt;属性-&gt;链接器-&gt;输入-&gt;附加依赖项，添加json_vc71_libmt.lib。
ok！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a69eb63cb291258ecc5d092212cc5666/" rel="bookmark">
			MDK常见错误记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本篇文章记录Keil相关的常见错误，以备后来碰到相同错误可以速查。
1、.\Objects\stm32_test.axf: Error: L6200E: Symbol __Vectors_Size multiply defined (by startup_stm32f10x_ld.o and startup_stm32f10x_md.o). … 接近100个错误。
看一下project中是不是把3种类型CPU的启动代码都引用了： startup_stm32f10x_ld.s startup_stm32f10x_md.s startup_stm32f10x_hd.s 根据你的CPU型号，留下一个就可以了，而且只能留下一个。
STM32F103C8T6是64K的所以保留startup_stm32f10x_md.s一个即可： 2、 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d19c397f8a1d5069478d410ed3d41138/" rel="bookmark">
			【图像处理】windows 10 &#43; vs2015&#43; opencv3.0.0 &#43;附加模块opencv_contrib编译和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.前言 将基于低版本opencv（比如2.3.1）的程序，在vs2015+opencv3.0的环境下编译会报错： “未声明的标识符:SiftFeatureDetector ” “未声明的标识符BruteForceMatcher” 查阅才知，sift、surf等等已经被移到opencv_contrib模块，如果需要在高版本opencv中使用到opencv_contrib模块，则需要自己进行编译。其编译和配置流程，在github.com:opencv/opencv_contrib的README里写了： 那么现在开始自行编译和配置吧。根据本文内容，成功率应该是99.99%，中途可能会遇到很多问题，我也会再总结一篇。 通过不懈努力，最终成果如下： 一.准备：系统环境和工具 1）系统：win 10 64位 2）opencv：3.0.0 3）opencv_contrib：3.0.0 4）visual studio:2015 5）CMake：3.8.0
1.安装CMake3.8.0 根据使用的操作系统选择相应的版本进行下载和安装即可（点击下载）： 2.下载opencv3.0.0 点击到官网下载
3.安装opencv3.0.0 将opencv安装到指定目录，比如：H:\opencv
4.下载opencv_contrib3.0.0 附加模块opencv_contrib最好下载与opencv为同一版本的。 5.解压opencv_contrib 3.0.0 将下载好的附加模块 opencv_contrib-3.0.0.zip 解压到指定位置，比如：C:\Users\september\Desktop\opencv_contrib-3.0.0 解压后，opencv_contrib-3.0.0的结构目录如下：
二.编译 1.打开cmake 2.输入opencv源文件路径 在where is the source code输入opencv地址/sources地址， 比如：H:/opencv/sources
3.输入保存编译结果的路径 在where to build the libraries输入保存编译结果的地址， 比如：H:/opencv/mybuild 比如下图：
4.第一次编译 （1）点击configure，选择本机的编译器，最后四位数字才代表vs的版本，比如图中的2015，代表的是visual studio 2015。 （2）点击finish，开始第一次编译。 如果编译器的版本选错，第一次编译时会出错： no cmake_c_compiler could be found. no cmake_cxx_compiler could be found. 第一次编译完成后会显示编译opencv所需要的参数，如图： 5.第二次编译 （1）在参数列表中，将Name为OPENCV_EXTRA_MODULES_PATH的Value设置为opencv_contrib-3.0.0的路径/modules，例如：C:/Users/september/Desktop/opencv_contrib-3.0.0/modules 可以在search栏中搜索OPENCV_EXTRA_MODULES_PATH变量，如下图。 （2）点击configure，直到configure done。 重点：configure done后，一定要检查一下参数列表，如果参数列表还有红色标记的条目，就再尝试几次configure，直到所有条目都是白色为止。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d19c397f8a1d5069478d410ed3d41138/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a16654379cb97d085f3a00a55ffb579a/" rel="bookmark">
			python WebDriver如何处理右键菜单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebDriver如何处理右键菜单
一、背景
在学习selenium webdriver的过程中，遇到这样一个问题。ActionChains类中提供了context_click的方法，它可以用来在web页面中进行右键点击的操作，但是问题来了。右键弹出的菜单如何去选择呢？
二、尝试
1、在ActionChains类中，我们可以​看到有一个send_keys的方法。该方法可以接受Keys类中键盘上大部分的按键操作，如ActionChains(driver).send_keys(Keys.DOWN)，意图是发送一个向下的箭头操作来选择右键弹出菜单，但是实践后，发现是无效的；
2、既然send_keys​方法不行，那我接着找到了key_down和key_up的方法，按下某个键后再释放，达到相同的目的，实践后仍然失败；
3、我告诉自己不要气馁，一定会找到解决办法的。我又看到move_by_offset​的方法，既然键盘操作不行，那么我还可以用鼠标偏移量的方法，让鼠标移动到目标菜单上，再点击操作。残酷的现实告诉我，此路不通；
4、这时的我基本已经绝望，百度了很多方法也不行。后来，看到有人说用Robot类可以实现这个右键菜单的操作。而且，下面还有成功的代码，不过是用Java写的。对于只会python的我来说，需要找到一个python语言的实现，接下来开始找python下的“robot”​类。百度已经被我烦到死，还是没有找到；
5、最后，我在想那Python语言下是不是有模拟鼠标键盘操作的类库呢？换了一个思路，果然有所收获。win32api/win32con两个很牛的类可以做这个事，尝试成功。
import win32api
import win32con
win32api.keybd_event(40,0,0,0)#下箭头的键码是40
win32api.keybd_event(40,0,win32con.KEYEVENTF_KEYUP,0)#按下后再释放
​附个键位码表：
键位码表
6、还有一种解决右键菜单的方法，也列在下面，待以后有时间再尝试
使用AutoItX实现鼠标模拟：
#将AutoItX3.dll 文件复制到 window目录然后注册一下
regsvr32.exe AutoItX3.dll
from win32com.client import Dispatch
def enter_game():
AutoItX = Dispatch( "AutoItX3.Control" )
# Block All Input
AutoItX.BlockInput( 1 )
AutoItX.Sleep( 20000 )
if AutoItX.WinActivate( GAME_WINDOW_TITLE, '' ):
pass
else:
if AutoItX.WinWaitActive( GAME_WINDOW_TITLE, '', 8 ):
pass
else:
# Unblock input
AutoItX.BlockInput( 0 )
return False
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a16654379cb97d085f3a00a55ffb579a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47ad417a177db55a6b34e4cc7acc3d2f/" rel="bookmark">
			bootstrap下拉菜单无效的解决方法之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题背景：lz在使用bootstrap遇到下拉列表无效问题，lz引用的jQuery文件为jquery-1.8.2.min.js，bootstarp文件为bootstrap.min.css、bootstrap.min.js。
解决过程：在浏览器打开页面，F12 Network检查js、css资源文件是否正确引用,发现没问题，然后Console发现bootstrap.js报错
Uncaught Error: Bootstrap's JavaScript requires jQuery version 1.9.1 or higher
at bootstrap.js:14
at bootstrap.js:16
相信到这里已经一目了然了，bootstrap需要1.9.1及以上版本的jQuery支持，于是lz查看bootstrap源码如下：
+function ($) {
var version = $.fn.jquery.split(' ')[0].split('.')
if ((version[0] &lt; 2 &amp;&amp; version[1] &lt; 9) || (version[0] == 1 &amp;&amp; version[1] == 9 &amp;&amp; version[2] &lt; 1)) {
throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher')
}
}(jQuery);
证实了前面的说法，于是lz把原来的jquery-1.8.2.min.js换成最新版本的jQuery文件（jquery-3.1.1.min.js）一切OK，问题解决！
最后奉上最新版本jQuery官网下载地址http://jquery.com/download/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a2bb6469336c54a221b3c44e430e826/" rel="bookmark">
			Spring循环依赖的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：循环依赖就是N个类中循环嵌套引用，如果在日常开发中我们用new 对象的方式发生这种循环依赖的话程序会在运行时一直循环调用，直至内存溢出报错。下面说一下Spring是如果解决循环依赖的。
第一种：构造器参数循环依赖 Spring容器会将每一个正在创建的Bean 标识符放在一个“当前创建Bean池”中，Bean标识符在创建过程中将一直保持
在这个池中，因此如果在创建Bean过程中发现自己已经在“当前创建Bean池”里时将抛出
BeanCurrentlyInCreationException异常表示循环依赖；而对于创建完毕的Bean将从“当前创建Bean池”中清除掉。
首先我们先初始化三个Bean。
public class StudentA { private StudentB studentB ; public void setStudentB(StudentB studentB) { this.studentB = studentB; } public StudentA() { } public StudentA(StudentB studentB) { this.studentB = studentB; } } public class StudentB { private StudentC studentC ; public void setStudentC(StudentC studentC) { this.studentC = studentC; } public StudentB() { } public StudentB(StudentC studentC) { this.studentC = studentC; } } public class StudentC { private StudentA studentA ; public void setStudentA(StudentA studentA) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a2bb6469336c54a221b3c44e430e826/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b350b0df7c460b72c241c4126fae22c9/" rel="bookmark">
			windows环境下用c&#43;&#43;实现socket编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是Socket
socket即套接字，用于描述地址和端口，是一个通信链的句柄。应用程序通过socket向网络发出请求或者回应。
sockets(套接字)编程有三种，流式套接字（SOCK_STREAM），数据报套接字（SOCK_DGRAM），原始套接字（SOCK_RAW）；前两种较常用。基于TCP的socket编程是采用的流式套接字。
（1）SOCK_STREAM表示面向连接的数据传输方式。数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送，但效率相对较慢。常用的HTTP协议就使用SOCK_STREAM传输数据，因为要确保数据的正确性，否则网页不能正常解析。
（2）SOCK_DGRAM表示无连接的数据传输方式。计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。因为SOCK_DGRAM所做的校验工作少，所以效率比SOCK_STREAM高。
QQ视频聊天和语音聊天就使用SOCK_DGRAM传输数据，因为首先要保证通信的效率，尽量减小延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响。
注意：SOCK_DGRAM没有想象中的糟糕，不会频繁的丢失数据，数据错读只是小概率事件。
有可能多种协议使用同一种数据传输方式，所以在socket编程中，需要同时指明数据传输方式和协议。
二、客户端/服务端模式：
在TCP/IP网络应用中，通信的两个进程相互作用的主要模式是客户/服务器模式，即客户端向服务器发出请求，服务器接收请求后，提供相应的服务。客户/服务器模式的建立基于以下两点：
（1）建立网络的起因是网络中软硬件资源、运算能力和信息不均等，需要共享，从而就让拥有众多资源的主机提供服务，资源较少的客户请求服务这一非对等作用。
（2）网间进程通信完全是异步的，相互通信的进程间既不存在父子关系，又不共享内存缓冲区。
因此需要一种机制为希望通信的进程间建立联系，为二者的数据交换提供同步，这就是基于客户/服务端模式的TCP/IP。
服务端：建立socket，声明自身的端口号和地址并绑定到socket，使用listen打开监听，然后不断用accept去查看是否有连接，如果有，捕获socket，并通过recv获取消息的内容，通信完成后调用closeSocket关闭这个对应accept到的socket，如果不再需要等待任何客户端连接，那么用closeSocket关闭掉自身的socket。
客户端：建立socket，通过端口号和地址确定目标服务器，使用Connect连接到服务器，send发送消息，等待处理，通信完成后调用closeSocket关闭socket。
三、编程步骤
（1）服务端
1、加载套接字库，创建套接字（WSAStartup()/socket()）;
2、绑定套接字到一个IP地址和一个端口上（bind()）;
3、将套接字设置为监听模式等待连接请求（listen()）；
4、请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字（accept()）；
5、用返回的套接字和客户端进行通信（send()/recv()）；
6、返回，等待另一个连接请求；
7、关闭套接字，关闭加载的套接字库（closesocket()/WSACleanup()）；
（2）客户端
1、加载套接字库，创建套接字（WSAStartup()/socket()）；
2、向服务器发出连接请求（connect()）；
3、和服务器进行通信（send()/recv()）；
4、关闭套接字，关闭加载的套接字库（closesocket()/WSACleanup()）；
四、windows下实现socket简单实例
使用软件：devc++
（一）TCP协议
（1）代码
服务端：server.cpp
#include &lt;stdio.h&gt; #include &lt;winsock2.h&gt; #pragma comment(lib,"ws2_32.lib") int main(int argc, char* argv[]) { //初始化WSA WORD sockVersion = MAKEWORD(2,2); WSADATA wsaData; if(WSAStartup(sockVersion, &amp;wsaData)!=0) { return 0; } //创建套接字 SOCKET slisten = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if(slisten == INVALID_SOCKET) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b350b0df7c460b72c241c4126fae22c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/749244b48fa7b55036529a341bf11002/" rel="bookmark">
			MySQL截取和拆分字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		截取字符串函数： SUBSTRING("12214545646455455",2) 从第2个字符开始截取到最后。SUBSTRING的参数有三个，最后一个是截取的长度，默认是到结尾，负数是倒数第几位。 拆分字符串函数： SUBSTRING_INDEX("[0.20,0.20,null]", ',', -1) 以 , 进行拆分字符串，从第一个关键词开始取前面所有的字符串。如果上面的第三个参数修改为 -1，那么就是取倒数第一个。
SELECT
SUBSTRING_INDEX(
SUBSTRING_INDEX("[0.20,0.20,null]", ',', 2),
',' ,- 1
) AS result
0.20
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/509447324c398f9e52a867649250978c/" rel="bookmark">
			学习OpenCV(4) 基于OpenCV的双目测距程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用MFC和OpenCV编写的双目测距程序,编写过程中参考了很多前人的经验,期间很多博主给我提供了源码或者问题解答,所以我想把我的经验写出来分享给大家,也许并没有什么使用价值,但是可以作为类似的项目的参考.(全部免积分下载)~
1.演示视频 http://www.bilibili.com/video/av8862669/
2.源码链接 https://github.com/jiafeng5513/Evision
其中包含MFC版本程序和Qt版本的程序,演示视频是MFC版本的.在github上有详细的build指南.
3.测试数据 github仓库里面自带测试数据
4.其他资源 EmguCV相关:
http://download.csdn.net/detail/angle_cal/9764885
http://download.csdn.net/detail/angle_cal/9764882
http://download.csdn.net/detail/angle_cal/9764889
Aforge.Net
http://download.csdn.net/detail/angle_cal/9764884
5.环境搭建以及使用说明 请看Evision 项目github主页
这是我曾经使用过的设备:
后来新换的设备:
6.联系我 这些链接中,代码是我自己写的但是参考了很多别人的程序,视频是我自己做的,其他的资源都是我在别的渠道找到的,因为时间太久远了已经忘了出处,发在这里完全是为了分享,而且下载是免积分的.如果这些资源侵犯了您的权益,请联系我删除:1535432383@qq.com,可以加QQ好友交流(1535432383)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/436ca0c57e94e7df5a26cf0e555f2f7e/" rel="bookmark">
			最长单调递增子序列的三种解法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从报名蓝桥杯开始我就觉得我走入了一条及其坑的路。
从大一到大三我写过的代码，思考过的算法真是少之又少，一个动态规划我依旧没有吃透，真的是觉得好有挫败感。不过还好，一点点来。
既然知道自己要去做这件事情，就认真去做吧。就算开始的比较晚但是能学到东西就很好。
这是转载自爱天涯技术论坛。http://qiemengdao.iteye.com/blog/1660229
解释部分是人家的，代码是我自己又写了一遍的，加深理解吧算是。觉得自己学习能力真的是有待加强。
问题 给定一个长度为N的数组，找出一个最长的单调自增子序列（不一定连续，但是顺序不能乱）。例如：给定一个长度为6的数组A{5， 6， 7， 1， 2， 8}，则其最长的单调递增子序列为{5，6，7，8}，长度为4.
解法1：最长公共子序列法 这个问题可以转换为最长公共子序列问题。如例子中的数组A{5，6， 7， 1， 2， 8}，则我们排序该数组得到数组A‘{1， 2， 5， 6， 7， 8}，然后找出数组A和A’的最长公共子序列即可。显然这里最长公共子序列为{5, 6, 7, 8}，也就是原数组A最长递增子序列。最长公共子序列算法在算法导论上有详细讲解，这里简略说下思想。
假定两个序列为X={x1, x2, ..., xm}和Y={y1, y2, ..., yn)，并设Z={z1, z2, ..., zk}为X和Y的任意一个LCS。
1）如果xm = yn，则zk = xm=yn，且Zk-1是Xm-1和Yn-1的一个LCS。
2）如果xm != yn, 则zk != xm蕴含Z是Xm-1和Y得一个LCS。
3）如果xm != yn, 则zk != yn蕴含Z是X和Yn-1的一个LCS。
这个方法我记得原来老师讲过，但是都忘记怎么实现了。今天先放在这里，立个flag，后期补充上。
解法2：动态规划法（时间复杂度O(N^2)) 设长度为N的数组为{a0，a1, a2, ...an-1)，则假定以ai结尾的数组序列的最长递增子序列长度为L(i)，则L(i)={ max(L(j))+1, j&lt;i且a[j]&lt;a[i] }。也就是说，我们需要遍历在i之前的所有位置j(从0到i-1)，找出满足条件a[j]&lt;a[i]的L(j)，求出max(L(j))+1即为L(j)的值。最后，我们遍历所有的L(i)（从0到N-1），找出最大值即为最大递增子序列。时间复杂度为O(N^2)。
例如给定的数组为{5，6，7，1，2，8}，则L(0)=1, L(1)=2, L(2)=3, L(3)=1, L(4)=2, L(5)=4。所以该数组最长递增子序列长度为4，序列为{5，6，7，8}。算法代码如下：
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/436ca0c57e94e7df5a26cf0e555f2f7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/358c5019fd80e0332678421a5c9a8acd/" rel="bookmark">
			关于C语言的malloc函数以及内存泄漏的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		malloc函数
malloc函数的原型：
（void *）malloc（int size）
malloc函数的返回值是一个void类型的指针，参数为int类型的数据，即申请分配的内存大小，单位是字节。内存分配成功之后，malloc函数返回这块内存的首地址，你需要一个指针来接受这个地址。但是由于函数的返回值是void *类型，所以必须强制转换成你所接收的类型。也就是说这块内存将来要用来存储什么类型的数据，比如
char *p = (char *)malloc(100);
在堆上分配了100个字节的内存，返回这块内存的首地址，把地址强制转换成char *类型后，赋给char *类型的指针变量p;同时告诉我们这块内存将用来存储char类型的数据。也就是说你只能通过指针变量p来操作这块内存。这块内存本身没有名字，对它的访问是匿名访问
使用malloc函数同样要注意这点：如果所申请的内存块大于目前堆上剩余的内存块（整块），则内存分配就会失败，函数函数NULL。注意这里说的是“堆上剩余内存块”不是所有剩余内存块之和，因为malloc函数申请的是连续的一块内存。既然malloc函数申请内存又不成功的可能，那我们在使用指向这块内存的指针时，必须用if( NULL != p)语句上来验证内存分配确实成功了。
内存泄漏
在C语言程序设计中，内存泄漏几乎是很难避免的，C程序产生泄漏内存，则运行速度会逐渐变慢，并最终停止运行；如果产生覆盖内存，程序会变得非常脆弱，很容易受到恶意用户的攻击。内存泄漏是一种隐性危害，它们很难被发现，通常不能在相应的源代码中找到错误，需要仔细分析与专门的检测工具才能发现。
（1）内存泄漏的定义
通常我们所说的内存泄漏，是指分配出去的内存在使用之后没有释放掉，没有回收，长此以往，会造成没有足够的内存可以分配。一般表现为运行时间越长，占用的内存越多，最终导致系统奔溃。一般的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期决定），使用完后必须显式释放的内存。应用程序一般使用malloc，realloc，new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。
（2）内存泄漏的原因
2.1 C语言内存分配情况 在C语言中，根据数据在内存中存在的时间（生存周期）不同，将内存空间分为三个区：
1）程序区：用于存储程序的代码，即程序的二进制代码。
2）静态存储区：用于存储全局变量和静态变量，这些变量的空间在程序编译时就已经分配好了。
3）动态存储区：用于在程序执行时分配的内存，又分为：堆区（heap）和栈区（stack）。堆区:用于动态内存 分配，程序运行时由内存分配函数在堆上分配内存。在C语言中，只能使用指针才能动态的分配内存。栈区:在 函数执行时，函数内部的局部变量和函数参数的存储单元的内存区域，函数运行结束时，这些内存区域会自动释 放。 2.2 C语言动态内存分配 在C语言中用内存分配函数来实现内存的动态分配，这些函数有：malloc()和realloc()等函数。malloc():使用这个 函数时需要包含头文件。使用该函数需要指定要分配的内存字节数作为参数，例如： int *pNumber=（int *） malloc（100） 这条语句分配了100个字节的内存，并把这个内存块的地址赋给pNumber，这个内存块可以保存最大25个int值， 每个int占4个字节。如果不能分配请求的内存，malloc（）会返回一个null指针。 2.3 释放动态分配的内存 堆上分配的内存会在整个应用程序结束之后，由操作系统负责回收，但最好是在使用完这些内存后立即释放。如 果不释放，会引起内存泄漏，极大占用系统资源，可能会产生各种未知的错误。所以，必须使用free（）函数释 放内存，参数是内存地址（指针），例如：free（pNumber），依上例。 （3）内存泄漏避免的方法 3.1正确使用malloc函数分配内存 malloc是一个函数，专门用来从堆上分配内存。使用malloc函数需要几个要求：内存分配给谁？分配多大内存？ 是否还有足够内存分配？ 内存将用来存储什么格式的数据？分配好的内存在哪里？ 如果这5点都确定，那内存就 能分配。下面看看malloc的原型：（void *）malloc（int size） malloc函数的返回值是一个void类型的指针，参数为int类型的数据，即申请分配的内存大小，单位是字节。内存 分配成功之后，malloc函数返回这块内存的首地址，你需要一个指针来接受这个地址。也就是说这块内存将来要 用来存储什么类型的数据，如： char *p = （char *）malloc（100） 在堆内存分配了100个字节的内存，返回这块内存的首地址，把地址强制转换成char *类型后赋给char *类型的指 针变量p；同时告诉我们这块内存将用来存储char类型的数据。你只能通过指针变量p来操作这块内存，这块内存 本身没有名字，对它的访问是匿名访问。但是，不一定每次malloc函数都能成功分配到内存。既然malloc函数申 请内存存在不成功的可能，那我们在使用指向这块内存的指针时，必须用if（ NULL ！= p）语句上来验证内存分 配确实成功了。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/358c5019fd80e0332678421a5c9a8acd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c784df3157d8ac8ab06a4c0eceacb8b/" rel="bookmark">
			Mycat入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mycat介绍 介绍在官方网站上有比较详细的介绍，在这里复制粘贴没什么意思，大家到官网上看官网链接 前置条件 本教程是在window环境下运行的，实际生产推荐在Linux上运行。 必备条件(自行安装,如果不会装请先打好基础在来学习)：
JDK：建议是1.7及其以上。MySQL：必须是5.5及其以上。 拓扑结构 两张表users和item，三个数据库db01,db02,db03（三个库在一个数据库实例上）users只在db01中存储。item表被分割到db02和db03中存储。 create database db01; CREATE TABLE users ( id INT NOT NULL AUTO_INCREMENT, name varchar(50) NOT NULL default '', indate DATETIME NOT NULL default '0000-00-00 00:00:00', PRIMARY KEY (id) )AUTO_INCREMENT= 1 ENGINE=InnoDB DEFAULT CHARSET=utf8; 在db02和db03中分别创建item表，SQL脚本如下
create database db02; CREATE TABLE item ( id INT NOT NULL AUTO_INCREMENT, value INT NOT NULL default 0, indate DATETIME NOT NULL default '0000-00-00 00:00:00', PRIMARY KEY (id) )AUTO_INCREMENT= 1 ENGINE=InnoDB DEFAULT CHARSET=utf8; create database db03; CREATE TABLE item ( id INT NOT NULL AUTO_INCREMENT, value INT NOT NULL default 0, indate DATETIME NOT NULL default '0000-00-00 00:00:00', PRIMARY KEY (id) )AUTO_INCREMENT= 1 ENGINE=InnoDB DEFAULT CHARSET=utf8; 开始使用 先打mycat官方网站上下载安装包，网址为mycat 下载图如下所示： 然后在conf目录下编辑service.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c784df3157d8ac8ab06a4c0eceacb8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/268860688ae4acd278727bea40709330/" rel="bookmark">
			恢复回收站删除的文件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		早晨手贱，把昨天下午搞得word文档还原了，备份文件也在回收站被删除~~~~~~~
啊，开始找方法还原，，搞了一上午，，无果。。。教训啊
不过还是有收获
-------------------------------------------------------------
转载一篇辟谣：
当文件误删时，应该怎么办？（纠正一篇最近被经常分享转贴的文章） http://jingyan.baidu.com/article/7f41ececfeaa75593d095cb6.html
2010年03月25日 星期四 12:26 最近经常看到有朋友在转贴分享这样的一篇文章： -------------------------------------------------------------------------------- 误删资料恢复 一不小心，删错了，还把回收站清空了，咋办啊？ 只要三步，你就能找回你删掉并清空回收站的东西 步骤： 1、单击“开始——运行，然后输入regedit （打开注册表） 2、依次展开：HEKEY——LOCAL——MACHIME/SOFTWARE/microsoft/WINDOWS/ CURRENTVERSION/EXPLORER/DESKTOP/NAMESPACE 在左边空白外点击“新建" ，选择：“主键"，把它命名为“645FFO40——5081——101B——9F08——00AA002F954E" 再把右边的“默认"的主键的键值设为“回收站"，然后退出注册表。就OK啦。 3、要重启计算机。 只要机器没有运行过磁盘整理。系统完好.任何时候的文件都可以找回 -------------------------------------------------------------------------------- 乍看上去没有什么问题（虽然很多标点符号用错了，0也写成了O，斜杠也不对），可是你能指望它为你做什么事吗？ 其实这篇文章说的不是恢复误删资料的方法，他恢复的其实是桌面上的“回收站”，最后一句话的承诺也是空头支票。 下面解释一下。 1.为什么说恢复的是桌面的回收站？ 桌面上有个回收站，这是每个人都知道的。有剑走偏锋者巨讨厌这个回收站，会在禁止所有驱动器上的回收站功能后想把这个回收站从桌面上彻底干掉。如何彻底干掉呢？这就需要动用注册表。 在注册表中，“HEKEY-LOCAL-MACHIME\SOFTWARE\MicroSoft\Windows\CurrentVersion\Explorer\Desktop\Namespace” 下保存的是可以在桌面上显示的系统图标的记录（包括回收站、我的电脑、IE图标、网上邻居，以及一些手机软件如Nokia手机浏览器等的图标），这些图标可以显示出来但不能删除就是这个原因（最近有些流氓网站会生成假的IE图标，不可删除但是双击肯定会打开他的网站，用的也是这样的手段）。其中，“645FF040-5081-101B-9F08-00AA002F954E”就是桌面上的回收站。把这个项删掉然后在桌面上刷新一下，就会发现回收站不见了。 说到这里，大多数童鞋应该都会知道了，上面的那些操作恢复的正是这个『回收站』的图标，而不是被删除的文件。更可能的情况是，绝大多数人会发现这个项是已经存在的——因为很少有人会特别去删除这个回收站的图标。 2.那引用的文章有适用的场景吗？ 由上面的分析可以知道，引用的文章适合恢复以下文件： * 你并没有关闭回收站功能。回收站哪里能关闭？在回收站属性中： * 删除文件时并没有直接删除（不是按Shift删除的） * 删除后并没有清空回收站。 * 当然，还需要你修改注册表删除了桌面上的『回收站』图标，否则不需要他教你也会去找回收站。 因此，他说的其实就是从回收站中还原（此时最后一句话磁盘整理又是多余的，因为回收站中的文件不会因为磁盘整理而丢失），可惜东拼西凑最终导致一篇千疮百孔的文章出现，撇去开头和结尾，其实本来的文章应该是：『桌面的回收站图标丢了，应该怎么找回来？』 可惜的是，绝大部分时间我们说的恢复文件，往往是在回收站已经被清空、或是直接删除后要恢复的。此时，引用的那篇文章什么也不能为你做。 3.什么样被删除的文件能恢复？ 要解释这个问题，我们得先知道删文件究竟是怎么删的。 大家都知道拷贝文件往往需要一点时间，但是删文件却很快。原因是：删文件并没有真正删除文件数据。操作系统会维护一个文件分配表（FAT或元文件），这个表记录了文件的相关信息（大小，文件名，属性，权限，以及在磁盘的位置等），和文件数据是分离的。删除文件时，操作系统会修改这个文件记录标记为已删除，并将其对应的磁盘空间标记为未被使用（空白的）。 这里有两个细节： 1.文件只是标记为已删除，但是文件数据本身是没有删除的； 2.文件标记为已删除，但是文件记录还是在的，只是常规访问会被跳过； 因此要恢复文件，必须有两个前提： 1.文件索引虽然被删掉了，但是尚未被覆盖，否则只能通过全盘扫描并通过文件特征来识别——大部分情况下不太可能。 2.文件数据区没有被覆盖，因为已经标记为空白了，如果此时写入文件等，操作系统有可能就会写入到这些已标记为空白的位置，一旦发生了，那么就没法再恢复了。 所以如果误删了文件（非删除到回收站），那么建议的措施是： 1.尽早发现误删，越早发现，恢复的概率越高 2.一旦发现，立刻停止在对应盘（误删文件所在盘）上的一切磁盘操作（复制文件、修改文件、保存文件、安装卸载程序，磁盘整理等等）都是应该立刻禁止的，否则会对恢复造成较大威胁（磁盘整理？整理过后基本上都没法恢复的）。 3.立刻使用数据恢复软件进行数据恢复 综上所述，前面所引用文章中，基本上都是错的，尤其是『只要没进行过磁盘整理，任何时间的文件都可以恢复』，这是典型的吹牛不打草稿的做法。 4.用什么软件进行恢复？ 如果是硬盘上的文件丢失，建议用下面的两种工具：Recuva，EasyRecovery。对于神经大条经常误删东西的同学，或有这方面需要的同学，建议家中常备。 *Recuva比较简单，轻量级（http://www.greendown.cn/soft/6456.html），建议首先选用，简要操作说明如下： *EasyRecovery比较复杂（http://www.greendown.cn/soft/3620.html），功能也要强大一点，不止包含恢复误删的功能，还包括其它数据恢复。在此不加详述，有兴趣的同学可以搜索一下它的教程学习 *对于U盘/存储卡等的文件误删，建议使用BadCopy恢复（http://www.greendown.cn/soft/2776.html）。具体操作方法，网上搜索下哈，我真的很懒，你知道的 &gt;.&lt; 提醒一下，如果删除的文件有点时间了，可能会导致恢复后文件名不可识别，或文件虽然恢复了其实已经损坏无法打开的情况，这是正常的。文件名错误可以自己识别，文件损坏的话……自求多福 -.- 5.平时文件操作建议 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/268860688ae4acd278727bea40709330/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ed08d549fd7d80ab655c03f79fd9517/" rel="bookmark">
			python3使用builtwith识别网站使用相关技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 首先通过pip install builtwith安装builtwith
C:\Users\Administrator&gt;pip install builtwith Collecting builtwith Downloading builtwith-1.3.2.tar.gz Installing collected packages: builtwith Running setup.py install for builtwith ... done Successfully installed builtwith-1.3.2 2. 在pycharm中新建工程并输入下面测试代码 import builtwith tech_used = builtwith.parse('http://www.baidu.com') print(tech_used) 运行会得到下面的错误： C:\Users\Administrator\AppData\Local\Programs\Python\Python36\python.exe F:/python/first/FirstPy Traceback (most recent call last): File "F:/python/first/FirstPy", line 1, in &lt;module&gt; import builtwith File "C:\Users\Administrator\AppData\Local\Programs\Python\Python36\lib\site-packages\builtwith\__init__.py", line 43 except Exception, e: ^ SyntaxError: invalid syntax Process finished with exit code 1 原因是builtwith是基于2.x版本的，需要修改几个地方，在pycharm出错信息中双击出错文件，进行修改，主要修改下面三种： 1. Python2中的 “Exception ,e”的写法已经不支持，需要修改为“Exception as e”。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ed08d549fd7d80ab655c03f79fd9517/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8688e3094af2d38f6e10626d34967eb6/" rel="bookmark">
			语法基础——Objective-C语法基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 学习过Swift之后，好久没用已经生疏了，现在有项目来了，不得不停下手下的工作，开始学习OC，当然这篇文章会以Java基础和C基础作为支撑，这样学习起来入门很简单，可能这篇文章有点个人主义，用作个人笔记吧
OC特点 支持C语法支持面向对象特性兼容性好，可以同时在项目中使用OC、C++，也可以引入C、C++库文件OC中没有命名空间机制，也没有包的概念，为了区分不同的类，在类名加前缀OC中关键字表示都以@开头，用于区分C和C++的关键字，字符串也以@开头，如@public、@protected、@private、@”Hello World” 文件名后缀 语言头文件后缀主文件后缀c.h.cc++.h.cppoc.h.moc与c++.h.mm OC基本数据类型 基本数据类型：数值型（整型、浮点型），字符型（char）、布尔型（BOOL）、空类型（Void）、Block类型、指针数据类型（class、id类型）、特殊类型（SEL、nil）
1、instancetype和id类型
instancetype可以作为返回类型，可以返回和方法所在类相同类型的对象，只能作为返回值id可以作为返回类型，返回任意类型的objcetive-c的对象类型，既可以作为返回值也可以作为参数 类与属性 1、 类的声明语法
@interface Person : NSObject{ 属性声明 } 方法声明 @end 特点：
@interface：相当于Java中的class类名后面的冒号：相当于Java中的extends 2、类的实现语法
@implementation XYZPerson 方法实现{ } @end 3、完整例子
4、创建对象
//第一种创建方式：创建一个可用的对象 Person *p=[Person new]; //new方法的内部会分别调用两个方法来完成2件事情 //1、使用alloc方法来分配存储空间（返回分配的对象） //2、使用init方法来对对象进行初始化 //1、调用类方法+alloc分配存储空间，返回未经初始化的对象 Person *p1=[person alloc]; //2、调用对象方法-init进行初始化，返回对象本身 Person *p2=[p1 init]; //第二种创建方式：以上2步简化为 Person *p=[[Person alloc] init]; //默认初始化完毕后，所有成员变量的值都为0 //用完对象要释放内存 [lisi release]; 究竟new方式和alloc/init方式有什么区别？
new和alloc/init在功能上是一致的，分配内存并完成初始化采用new方式只能采用默认的init方法完成初始化采用alloc的方式可以用自定义的构造方法完成初始化 5、访问对象属性
//调用类的属性，语法：对象-&gt;属性名 lisi-&gt;age; lisi-&gt;name; //或者：(*对象名).对象属性 (*lisi).name 6、调用方法
//调用无参方法，语法:[对象名 方法名] [Person eat] [Person run] //调用有参方法，语法:[对象名 方法名:参数] [Person eat:@"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8688e3094af2d38f6e10626d34967eb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90b0a7d74d6ab79e24eee9420bcf1de5/" rel="bookmark">
			【scikit-learn】04：sklearn库下进行文本数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【scikit-learn】01：使用案例对sklearn库进行简单介绍【scikit-learn】02：使用sklearn库进行统计学习【scikit-learn】03：将sklearn库用于非监督性学习 聚类 【scikit-learn】04：sklearn库下进行文本数据分析 【scikit-learn】05：sklearn文本分类及评价指标【scikit-learn】06：make_blobs聚类数据生成器【scikit-learn】07：数据加载，数据归一，特征选择，逻辑回归，贝叶斯，k近邻，决策树，SVM # -*-coding:utf-8-*- # ---------------------- # Author：kevinelstri # Datetime:2017.2.21 # ---------------------- # ----------------------- # Working With Text Data 文本数据处理 # http://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html # ----------------------- import numpy as np """ 这个指南的目的是在一个实际任务上探索scikit-learn的主要工具，在二十个不同的主题上分析一个文本集合。 在这一节中，可以看到： 1、加载文本文件和类别 2、适合机器学习的特征向量提取 3、训练线性模型进行分类 4、使用网格搜索策略，找到一个很好的配置的特征提取组件和分类器 """ """ 1、Loading the 20 newsgroups dataset 加载20个新闻组数据集 为了获得更快的执行时间为第一个例子，我们将工作在部分数据集只有4个类别的数据集中： """ categories = ['alt.atheism', 'soc.religion.christian', 'comp.graphics', 'sci.med'] from sklearn.datasets import fetch_20newsgroups twenty_train = fetch_20newsgroups(subset='train', categories=categories, shuffle=True, random_state=42) print twenty_train.target print twenty_train.target_names # 训练集中类别的名字，这里只有四个类别 print len(twenty_train.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90b0a7d74d6ab79e24eee9420bcf1de5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/090b26bb2f2359124b62e33d475ef724/" rel="bookmark">
			css之背景图片和插入图片的区别以及精灵图的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，背景图片和插入图片 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;40-css背景图片和插入图片的区别.html&lt;/title&gt; &lt;style&gt; div{ width: 200px; height:200px; background-color: red; } .box1{ background-image: url("images/image.png"); background-repeat: no-repeat; background-position: right bottom; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1,背景图片和插入图片的区别? (1),背景图片仅仅是一个装饰,你不会占用位置,插入图片会占用位置 (2),背景图片有定位属性,很方便的控制图片的位置,插入图片没有定位属性 (3),插入图片的语义比背景图片的语义要强,所以在企业开发中你的图片如果从想让搜索引擎收录,那么推荐使用插入图片 --&gt; &lt;div class="box1"&gt;我是一个文字&lt;/div&gt; &lt;div class="box2"&gt; &lt;img src="images/image.png" alt=""&gt; 我是文字 &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 二，精灵图片的使用 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;42-css精灵图.html&lt;/title&gt; &lt;style&gt; .box1{ width: 100px; height: 100px; background-image: url("images/bg.jpg"); background-position: -422px -190px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/090b26bb2f2359124b62e33d475ef724/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f53ef00340903a366c7373f07d10cbc2/" rel="bookmark">
			微信红包算法研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.galaxy.fym.algorithm.maxsublist; import java.math.BigDecimal; import java.util.*; /** * Created by fengyiming on 2017/2/17. * * @author fengyiming * 随机产生红包：金额正太分布 * * 如果非标准正态分布X~N(μ,σ^2)，那么关于X的一个一次函数 (X-μ)/σ ，就一定是服从标准正态分布N(0,1)。 * 举个具体的例子，一个量X，是非标准正态分布，期望是10，方差是5^2（即X~N(10,5^2)）；那么对于X的线性函数Y=(X-10)/5，Y就是服从标准正态分布的Y~N(0,1)。 */ public class RedPacket { private static Random random = new Random(); private static BigDecimal MIN_VALUE = new BigDecimal("0.01"); private static boolean isMin = false; /** * 生成红包 * * @param amountValue 红包总金额 * @param sizeValue 红包大小 * @param maxMutValue 剩余红包限定倍数 * @param sigmaValue 标准差倍数 * @return */ public static List&lt;BigDecimal&gt; getAllHotPacket(double amountValue, double sizeValue, double maxMutValue, double sigmaValue) { //红包总金额 BigDecimal amount = new BigDecimal(String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f53ef00340903a366c7373f07d10cbc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45b23e186c1b136db571d890fe6481ec/" rel="bookmark">
			sql 数据库表如何添加字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数据表testa中id字段之后添加name字段：
ALTER TABLE `test`.`testa` ADD COLUMN `name` VARCHAR(45) NOT NULL DEFAULT '' AFTER `id`; 另外，MySQL workbench是一款非常好用的数据库操作工具，使用中可以查看到操作对应的sql语句。
MySQL workbench下载地址： MySQL workbench下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0dac52a6140159c1767cc11b5e67249/" rel="bookmark">
			ValueError: invalid literal for int() with base 10: &#39;&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python编程中，有时会遇到以下错误，在此记录一下。
错误信息 ValueError: invalid literal for int() with base 10: ”
具体报错信息如下：
[2017-02-13 14:33:44,225] [ERROR] Internal Server Error: /data/notification/ Traceback (most recent call last): File “/data/python-virtualenv/cmdb-api/lib/python2.6/site-packages/django/core/handlers/base.py”, line 112, in get_response response = wrapped_callback(request, *callback_args, **callback_kwargs) …… File “/data/python-virtualenv/cmdb-api/lib/python2.6/site-packages/django/db/models/fields/init.py”, line 613, in get_prep_value return int(value) ValueError: invalid literal for int() with base 10: ”
原因： 不要被一大堆信息吓蒙掉，从报错信息上看这是一个类型转换错误： ‘’无法转为int型。
命令行下做测试
C:\Users\lanyang&gt;python Python 2.7.6 (default, Nov 10 2013, 19:24:24) [MSC v.1500 64 bit (AMD64)] on win 32 Type "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0dac52a6140159c1767cc11b5e67249/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c92f596e4d94b6e6f63b3716b6a53507/" rel="bookmark">
			python模块以及导入出现ImportError: No module named &#39;xxx&#39;问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python中，每个py文件被称之为模块，每个具有__init__.py文件的目录被称为包。只要模 块或者包所在的目录在sys.path中，就可以使用import 模块或import 包来使用 如果你要使用的模块（py文件）和当前模块在同一目录，只要import相应的文件名就好，比 如在a.py中使用b.py： import b 但是如果要import一个不同目录的文件(例如b.py)该怎么做呢？ 首先需要使用sys.path.append方法将b.py所在目录加入到搜素目录中。然后进行import即 可，例如 import sys sys.path.append('c:\xxxx\b.py') # 这个例子针对 windows 用户来说的 大多数情况，上面的代码工作的很好。但是如果你没有发现上面代码有什么问题的话，可要 注意了，上面的代码有时会找不到模块或者包（ImportError: No module named xxxxxx），这是因为： sys模块是使用c语言编写的，因此字符串支持 '\n', '\r', '\t'等来表示特殊字符。所以 上面代码最好写成： sys.path.append('c:\\xxx\\b.py') 或者sys.path.append('c:/xxxx/b.py') 这样可以避免因为错误的组成转义字符，而造成无效的搜索目录（sys.path）设置。 sys.path是python的搜索模块的路径集，是一个list 可以在python 环境下使用sys.path.append(path)添加相关的路径，但在退出python环境后 自己添加的路径就会自动消失了！ 3、搜索路径和路径搜索 模块的导入需要叫做“路径搜索”的过程。 搜索路径：查找一组目录 路径搜索：查找某个文件的操作 ImportError: No module named myModule 这种错误就是说：模块不在搜索路径里，从而导致路径搜索失败！ 导入模块时，不带模块的后缀名，比如.py Python搜索模块的路径： 1)、程序的主目录 2)、PTYHONPATH目录（如果已经进行了设置） 3)、标准连接库目录（一般在/usr/local/lib/python2.X/） 4)、任何的.pth文件的内容（如果存在的话）.新功能，允许用户把有效果的目录添加到模块搜索路径中去 .pth后缀的文本文件中一行一行的地列出目录。 这四个组建组合起来就变成了sys.path了， &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.path 导入时，Python会自动由左到右搜索这个列表中每个目录。 关于 python ImportError: No module named 'xxx'的问题? 解决方法如下： 1. 使用PYTHONPATH环境变量，在这个环境变量中输入相关的路径，不同的路径之间用逗号 （英文的！)分开，如果PYTHONPATH 变量还不存在，可以创建它！ 这里的路径会自动加入到sys.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c92f596e4d94b6e6f63b3716b6a53507/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e27a709f2cb89b1713e5cfdbddccd86a/" rel="bookmark">
			若要使他人能够在远程计算机上查看此特定错误消息的详细信息，请在位于当前 Web 应用程序根目录下的“web.config”配置文件中创建一个 &lt;customErrors&gt; 标记。然后应将此 &lt;cust
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错提示是这样的！
数据库找不到， 同样也会报这个错误！把数据库路径写对就行了！
权限不够， 或许这样说不贴切，不过，只要把权限设置对就行了！
具体步骤 服务器上网站的发布目录权限配置不正确。。 比如我们在服务器上发布了一个网站，网站存放目录为:PublishedVersion 改正方法:①右键PublishedVersion，属性&gt;&gt;共享&gt;&gt;权限; ②这时候看到一个【添加】按钮，点击【添加】； ③这时候左下方有一个【高级】按钮，点击【高级】； ④这时候中间有一个【立即查找】按钮，点击【立即查找】； ⑤这时候在搜索结果里面找到NetWork(快捷键打N就可以看到了)； ⑥选择了NetWork后点击【确定】，再点击【确定】，这时候看到的这个页面就是NetWork的权限了，都打上勾勾，就可以了。。。 备注：服务器系统是Windows Server 2003。
ps:写入权限不用选
其他回答以及解决方案 第一 那么应该是你IIS配置问题了，服务器是2003么？检查下web服务扩展，ASP.NET 有没有被禁用？再看下IIS里的ASP.NET版本是否选对了。 第二 我遇到过你说的这种问题，在服务器上的IE浏览器中看的是正常的，但在客户端访问的时候就会出问题。当时按照出错提示做了更改——完全不行，后来才发现原来是服务器代码中一个获取日期的类型弄错了，改了就没问题了。但在运行中并不会报错。所以我觉得你还是应该仔细检查下服务器端源代码，看是否有哪个地方出错了。 第三 出现这个错误提示的原因，是因为你的这个页面有错误， 比如，你这个页面初始化的时候，需要从数据库中读取数据加载到页面， 比如你有某个Dropdownlist是从数据库中读取数据绑定，但是页面刚加载的时候，你读取到的数据源内容是空的，于是页面就报错了，但是这个错误，在本地是可以查看的，通过外网连接的时候，因为你的配置文件没有配置允许远程查看错误，所以就不能查看，报告的就是你所述的这个错误。 仔细查看你的页面初始化需要绑定的数据，调试一下，是否有某个从数据库读取的数据初始化时候值是null的！ 第四 出现这种错，要么是你的程序出错，要不就是服务器配置不正确。 看看你的服务器是否支持asp.net，如果支持的话，要看一下是否支持你程序用的版本，比如你用的是asp.net 2.0 ,但服务器只支持1.0 第五 我也遇到过此类问题，在IIS里把.net 版本换了一下就好了。。 还有把 读取 写入 目录浏览都给选上 PS:目录不用选 第六 我就检查服务器上的iis 我把 iis中目录 下面的执行权限 改为 纯脚本和 可执行文件。 就可以了。 希望能对大家有帮助。 第七 给你的网站所用文件所在的文件夹添加Everyone用户，其权限设置为“完全可控” 试一试 第八 在web.config中添加： &lt;system.web&gt; &lt;customErrors mode="Off"/&gt; &lt;/system.web&gt; 这样可以看到具体的错误信息 总结： 由此可见，这个错误的发生包含了许多问题！有待大家发现，如果解决了，切记一定要拿出来分享下！ 笔者是看了这个帖子解决的 http://bbs.csdn.net/topics/300137022 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a0e425adddb72448e7dae63c520a234/" rel="bookmark">
			微信小程序，配置服务器地址的步骤及配置过程中遇到的问题和解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.微信公众平台 https://mp.weixin.qq.com/wxopen/devprofile?action=get_profile&amp;token=26722685&amp;lang=zh_CN 配置一下自己服务器域名 request后面的https://域名
2.在项目的配置信息哪里点击刷新,如图 3.开发工具，清缓存，刷新 调试 缓存 4.配置好之后，在js文件里面加上wx.request请求的代码。 5.看回调接口打印的信息来判断接口是否访问成功和失败的原因。 6.遇到 request:fail小程序要求的TLS版本必须大于等于1.2问题 解决方案：参考 http://www.henkuai.com/thread-16648-1-1.html 7.微信小程序遇到 Failed to load resource: net::ERR_NAME_NOT_RESOLVED解决方案 ：关闭代理，或者依次点击工具栏“动作”-“设置”，选择“不使用任何代理，勾选后直连网络”。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a108772cea09e13f34e0a5a823ed24e/" rel="bookmark">
			volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果单看一句话的，基本上是无法理解的。这句话的意思，并不是“对于一个变量a，a=5这样的写操作，在b=a这样的读操作之前执行”的意思，这句话实际上就是体现happens-before原则具备传递性。
想要解理这句话的意思可以看下面的文章： - Java多线程：volatile变量、happens-before关系及内存一致性：这章文章的“什么是 happens-before 关系？”部分以下的一部分，举了一个传递的例子。例子中主要说明的是“和volatile变量相关的变量”的变化。 - 深入理解Java内存模型（四）——volatile：看“volatile写-读建立的happens before关系”以后的内容，在内容的级别讲了是如何实现的。用了volatile变量后，对volatile变量写之前的数据，在读volatile变量之后，都有了“可见性”（必须是在“读volatile变量”之后，才有可见性） - [译] Java Volatile 关键字详解：这个也写的不错，但没有上两篇文章，不太理解。 - 【Java并发编程】之十六：深入Java内存模型——happen-before规则及其对DCL的分析（含代码）：讲了happens-before，还有最下面的volatile和final的变量的“可见性”的说明 - Java并发编程：volatile关键字解析：“这句话实际上就是体现happens-before原则具备传递性”这句话就出自这里
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7912eb0d262580278381794f00eee3be/" rel="bookmark">
			poi获取合并单元格的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		poi获取合并单元格时，如果是遍历获取合并单元格的所有子单元格的值，office的excel都会有值，wps的excel只会第一个子单元格有值，其他子单元格都没值，即cell=null。故意凡是获取合并单元格的值，都获取第一个子单元格的值即可
以下是用到的操作类
package com.csair.tang.carmanager.utils; import com.csair.tang.carmanager.excel.ExcelFormat; import com.csair.tang.carmanager.excel.ExcelInputStreamDto; import com.csair.tang.carmanager.excel.Region; import com.csair.tang.carmanager.exception.ServiceException; import org.apache.poi.hssf.usermodel.HSSFCellStyle; import org.apache.poi.hssf.usermodel.HSSFWorkbook; import org.apache.poi.ss.usermodel.*; import org.apache.poi.ss.util.CellRangeAddress; import org.apache.poi.xssf.usermodel.XSSFWorkbook; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.util.StringUtils; import org.springframework.web.multipart.MultipartFile; import org.springframework.web.multipart.MultipartHttpServletRequest; import org.springframework.web.multipart.commons.CommonsMultipartResolver; import javax.servlet.http.HttpServletRequest; import java.io.IOException; import java.io.InputStream; import java.util.ArrayList; import java.util.List; /** * Created by Up on 2016/8/26. */ public class ExcelUtil { private final static Logger LOG = LoggerFactory.getLogger(ExcelUtil.class); /** * @author wcyong * @date 2013-6-21 */ public static Workbook getWorkbook(InputStream is, ExcelFormat format) throws IOException { Workbook wb = null; if (format == ExcelFormat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7912eb0d262580278381794f00eee3be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67fa8505b5cfcfe92a894e16aa2db0b8/" rel="bookmark">
			集合各实现类的底层实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ArrayList实现原理要点概括 参考文献：
http://zhangshixi.iteye.com/blog/674856l
https://www.cnblogs.com/leesf456/p/5308358.html
ArrayList是List接口的可变数组非同步实现，并允许包括null在内的所有元素。底层使用数组实现该集合是可变长度数组，数组扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量增长大约是其容量的1.5倍，这种操作的代价很高。若是能预估到顶峰容量，可以设置一个足够大的量以避免数组容量以后的扩展。采用了Fail-Fast机制，面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险remove方法会让下标到数组末尾的元素向前移动一个单位，并把最后一位的值置空，方便GCadd、remove操作对于ArrayList其运行时间是O（N），因为在它当中在前端进行添加或移除构造新数组是O（N）操作；get方法的调用为O（1）操作。要是使用一个增强的for循环，对于任意List的运行时间都是O（N），因为迭代器将有效地从一项到下一项推进。 LinkedList实现原理要点概括 参考文献：
1.http://www.cnblogs.com/ITtangtang/p/3948610.htmll
2.https://www.cnblogs.com/leesf456/p/5308843.html
LinkedList是List接口的双向链表非同步实现，并允许包括null在内的所有元素。底层的数据结构是基于双向链表的，该数据结构我们称为节点双向链表节点对应的类Node的实例，Node中包含成员变量：prev，next，item。其中，prev是该节点的上一个节点，next是该节点的下一个节点，item是该节点所包含的值。它的查找是分两半查找，先判断index是在链表的哪一半，然后再去对应区域查找，这样最多只要遍历链表的一半节点即可找到add、remove操作对于LinkedList其运行时间是O（1）；get方法的调用为O（N）操作。要是使用一个增强的for循环，对于任意List的运行时间都是O（N），因为迭代器将有效地从一项到下一项推进。 HashMap实现原理要点概括 参考文献：http://zhangshixi.iteye.com/blog/672697
参考文献：http://blog.csdn.net/lizhongkaide/article/details/50595719
HashMap是基于哈希表的Map接口的非同步实现，允许使用null值和null键，但不保证映射的顺序。底层使用数组实现，数组中每一项是个单向链表，即数组和链表的结合体；当链表长度大于一定阈值时，链表转换为红黑树，这样减少链表查询时间。HashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Node对象。HashMap底层采用一个Node[]数组来保存所有的key-value对，当需要存储一个Node对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Node时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Node。HashMap进行数组扩容需要重新计算扩容后每个元素在数组中的位置，很耗性能采用了Fail-Fast机制，通过一个modCount值记录修改次数，对HashMap内容的修改都将增加这个值。迭代器初始化过程中会将这个值赋给迭代器的expectedModCount，在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map，马上抛出异常 Hashtable实现原理要点概括 参考文献：http://blog.csdn.net/zheng0518/article/details/42199477
Hashtable是基于哈希表的Map接口的同步实现，不允许使用null值和null键底层使用数组实现，数组中每一项是个单链表，即数组和链表的结合体Hashtable在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。Hashtable底层采用一个Entry[]数组来保存所有的key-value对，当需要存储一个Entry对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。synchronized是针对整张Hash表的，即每次锁住整张表让线程独占 ConcurrentHashMap实现原理要点概括 参考文献：http://blog.csdn.net/zheng0518/article/details/42199477
ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同段进行的修改，每个段其实就是一个小的hashtable，它们有自己的锁。只要多个并发发生在不同的段上，它们就可以并发进行。ConcurrentHashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。Hashtable底层采用一个Entry[]数组来保存所有的key-value对，当需要存储一个Entry对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。与HashMap不同的是，ConcurrentHashMap使用多个子Hash表，也就是段(Segment)ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。 HashSet实现原理要点概括 参考文献：http://zhangshixi.iteye.com/blog/673143l
HashSet由哈希表(实际上是一个HashMap实例)支持，不保证set的迭代顺序，并允许使用null元素。基于HashMap实现，API也是对HashMap的行为进行了封装，可参考HashMap LinkedHashMap实现原理要点概括 参考文献：http://zhangshixi.iteye.com/blog/673789l
LinkedHashMap继承于HashMap，底层使用哈希表和双向链表来保存所有元素，并且它是非同步，允许使用null值和null键。基本操作与父类HashMap相似，通过重写HashMap相关方法，重新定义了数组中保存的元素Entry，来实现自己的链接列表特性。该Entry除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而构成了双向链接列表。 LinkedHashSet实现原理要点概括 参考文献：http://zhangshixi.iteye.com/blog/673319l
对于LinkedHashSet而言，它继承与HashSet、又基于LinkedHashMap来实现的。LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承与HashSet，其所有的方法操作上又与HashSet相同。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f60354b37c9ca95c88a85f5d42e40c8d/" rel="bookmark">
			hls 网络上的m3u8视频源地址（可用的）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8
2、http://kbs-dokdo.gscdn.com/dokdo_300/_definst_/dokdo_300.stream/playlist.m3u8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34b12510880283f33e39cddc2fc365d1/" rel="bookmark">
			EDA软件_Cadence_Allegro 16.6添加封装库路径（导入网表时需要）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照《Cadence 高速电路板设计与仿真》（第5版）9.2节的输入网络表操作，无法正确导入网络表，原因是封装库路径没有设置，具体的设置方法如下。 选择Setup-&gt;User Preferences，弹出 User Preferences Editor 对话框，点击 Paths 前面的‘+’号展开，再点击Library，需要设置其中三个参数，将封装库添加到目录下，如下图所示。
参考链接：http://wenku.baidu.com/link?url=4k8-osDTGGnTdNgACP8Rsw3d3uRA3lN7gJ-dIwDxaPRRpch7g9IujdiMUpuoLywS28kihhsnPhHDwAgbtECPr7ja79Czi0SKv0tc_mZkw_7
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4229a095932419fb8dc7234384b98e6d/" rel="bookmark">
			所用ctorrent项目编译遇到的几个问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到问题error: openssl/md5.h: No such file or directory openssl/md5.h找不到，就安装openssl，仍找不到。 出现：error: openssl/md5.h: No such file or directory 原因是openssl-devel没有安装，执行： yum install libssl-dev 就可以了
collect2: ld returned 1 exit status错误解决 g++ -g -O2 -o ctorrent bencode.o bitfield.o btconfig.o btcontent.o btfiles.o btrequest.o btstream.o bufio.o compat.o connect_nonb.o console.o ctcs.o ctorrent.o downloader.o httpencode.o iplist.o peer.o peerlist.o rate.o setnonblock.o sigint.o tracker.o sha1.o -lrt btcontent.o: In function `checkMd5(char*, char*)': /home/fangy/Desktop/ctorrent-dnh3.3.2/btcontent.cpp:86: undefined reference to `MD5_Init' /home/fangy/Desktop/ctorrent-dnh3.3.2/btcontent.cpp:89: undefined reference to `MD5_Update' /home/fangy/Desktop/ctorrent-dnh3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4229a095932419fb8dc7234384b98e6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dfcbda86036898a3a70d1a46f7140b1/" rel="bookmark">
			[C#]Array.Sort()排序的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【前言】
C#视频的看到冒泡排序以后，小杨老师讲了一个更简单的排序方法，这个方法就是Array.Sort()函数，利用这个函数可直接对数组中的数字进行排序，比冒泡排序简单得多了，仅仅只需要一行代码，下面是代码和运行结果。
int[] nums = new int[] { 2, 652, 32, 1, 6, 65 }; Array.Sort(nums); //Array.Reverse(nums);//方法，反转 for (int i = 0; i &lt; nums.Length; i++) { Console.WriteLine(nums[i] + "\t"); } Console.ReadKey(); 结果为：
若想降序排序，当然可以，只需要加一行代码就可以实现，代码如下：
Array.Reverse(nums);//方法，反转 这行代码的作用就是反转输出结果，是不是So easy呢。但是，这些在程序的内部是怎样实现的呢？虽然说它只是一种方法，并不需要我们知道具体的操作，但总有一些强迫症的人，不知道结果心里不爽，若正在读这篇博客的你和我一样好奇是怎样实现的就继续往下看吧。
【正文】
这种方法具体是这样实现的？ 咳咳……
我也不知道，那就百度吧。好心的网友解释是这样的：Arrays.sort()方法根据传出参数的长度的大小来判断用哪种排序方法，如果数组的长度小于7用冒泡排序，如果数组长度大于7，将数组分为两部分，前半部分和后半部分分别进行冒泡排序，最后再执行一次总的排序。
也就是说Arrays.sort()方法就是相当于给我们写好的一个冒泡排序（长度小于7位），就像小杨老师解释的，大部分的方法差不多都是这样。比如说该吃饭了，自己做饭需要买菜、洗菜、切菜、炒菜，一切都完成后才能顺利的吃到饭，但是若不想做饭该怎么办呢？有什么方法呢？点外卖，手机一点，想吃什么直接就给送过来了，这就是一种方法，一种别人做好的，你直接就可以拿过来用的方法。
在看其他同学博客的过程中意外发现了Array.Sort()的一个严重bug，若我代码如下的时候运行的结果是这样的：
int[] nums = new int[] {2,6,21,652,65,6,1,12 }; Array.Sort(nums); 得到的结果为：1，12，2，21，6，65，652
可以看到并没有完全按照升序排列，这是为什么呢？因为Array.Sory()方法的排序默认按照ASCII字符码进行排序，数字式按照他们的字符串形式排序的。
这就是Array.Sort()方法的排序原理，虽然很简单，但是有了以上例子我觉得Array.Sort()方法在一定情况下并不适用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4e74164627542a88f45bdaf4edfae1b/" rel="bookmark">
			js获取img宽高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识点1 如果写了var img = new Image（100 ，100）， img.src = ‘1.png’ ，这样的作用是可以把img缓存到浏览器中，常用来做图片预加载。
知识点2 html代码：
[外链图片转存失败(img-dfDsOQbF-1562240215537)(https://mp.csdn.net/mdeditor/1.png)] js代码：
var imgW = document.getElementsByTagName('img')[0].style.width; 上面这种获取图片宽高方法，必须有style=“width:400px”，才能获取图片宽高。
知识点3 html代码：
&lt;style&gt; img{ padding:20px;border:1px solid red;} &lt;/style&gt; [外链图片转存失败(img-1OTZrTAM-1562240215538)(https://mp.csdn.net/mdeditor/1.png)] js代码：
window.onload = function(){ var img = document.getElementsByTagName('img')[0], imgOffsetWidth = img.offsetWidth, //442px imgClientWidth = img.clientWidth; //440px; } 其实offsetWidth得到的是width值+padding值+border值，clientWidth得到的是width值+padding值。但是值得注意的是，如果把style="width:400px"去掉，那么它们获取的就是真实图片的宽高。
知识点4 html代码：
[外链图片转存失败(img-NkUAK1sD-1562240215538)(https://mp.csdn.net/mdeditor/1.png)] js代码：
//naturalWidth只是用于Firefox/IE9/Safari/Chrome/Opera浏览器 window.onload = function(){ var img = document.getElementsByTagName('img')[0]; nWidth = img.naturalWidth //图片真实宽度 nHeight = img.naturalHeight //图片真实高度 } naturalWidth和naturaHeight都是获取图片真实宽高的值，但是只适用于的IE9以上浏览器，所以对于IE9以下得用其他方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4e74164627542a88f45bdaf4edfae1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cd43bf76aede7b3a6818ba96be9d1a3/" rel="bookmark">
			在 JDK 7 版本以上， Comparator 要满足自反性，传递性，对称性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 JDK 7 版本以上， Comparator 要满足自反性，传递性，对称性，不然 Arrays . sort ，
Collections . sort 会报 IllegalArgumentException 异常。
说明：
1 ） 自反性： x ， y 的比较结果和 y ， x 的比较结果相反。
2 ） 传递性： x &gt; y , y &gt; z ,则 x &gt; z 。
3 ） 对称性： x = y ,则 x , z 比较结果和 y ， z 比较结果相同。
反例：下例中没有处理相等的情况，实际使用中可能会出现异常：
new Comparator&lt;Student&gt;() {
@Override
public int compare(Student o1, Student o2) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cd43bf76aede7b3a6818ba96be9d1a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d444435ebe247ca96dec31ca55429a76/" rel="bookmark">
			Java 8系列之Stream的基本语法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stream系列：
Java 8系列之Stream的基本语法详解Java 8系列之Stream的强大工具CollectorJava 8系列之重构和定制收集器Java 8系列之Stream中万能的reduce 概述 继Java 8系列之Lambda表达式之后，我们来了解Stream。Stream 是用函数式编程方式在集合类上进行复杂操作的工具，其集成了Java 8中的众多新特性之一的聚合操作，开发者可以更容易地使用Lambda表达式，并且更方便地实现对集合的查找、遍历、过滤以及常见计算等。
聚合操作 为了学习聚合的使用，在这里，先定义一个数据类：
public class Student { int no; String name; String sex; float height; public Student(int no, String name, String sex, float height) { this.no = no; this.name = name; this.sex = sex; this.height = height; } **** } Student stuA = new Student(1, "A", "M", 184); Student stuB = new Student(2, "B", "G", 163); Student stuC = new Student(3, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d444435ebe247ca96dec31ca55429a76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b10239dc9db5803446387b9a8cc2ba9/" rel="bookmark">
			Java 8系列之Stream中万能的reduce
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stream系列：
Java 8系列之Stream的基本语法详解Java 8系列之Stream的强大工具CollectorJava 8系列之重构和定制收集器Java 8系列之Stream中万能的reduce reduce 操作可以实现从Stream中生成一个值，其生成的值不是随意的，而是根据指定的计算模型。比如，之前提到count、min和max方 法，因为常用而被纳入标准库中。事实上，这些方法都是reduce操作。
reduce方法有三个override的方法：
Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);&lt;U&gt; U reduce(U identity,BiFunction&lt;U, ? super T, U&gt; accumulator,BinaryOperator&lt;U&gt; combiner); 我们先看第一个变形，其接受一个函数接口BinaryOperator&lt;T&gt;，而这个接口又继承于BiFunction&lt;T, T, T&gt;.在BinaryOperator接口中，又定义了两个静态方法minBy和maxBy。这里我们先不管这两个静态方法，先了解reduce的操作。
@FunctionalInterface public interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; { public static &lt;T&gt; BinaryOperator&lt;T&gt; minBy(Comparator&lt;? super T&gt; comparator) { Objects.requireNonNull(comparator); return (a, b) -&gt; comparator.compare(a, b) &lt;= 0 ? a : b; } public static &lt;T&gt; BinaryOperator&lt;T&gt; maxBy(Comparator&lt;? super T&gt; comparator) { Objects.requireNonNull(comparator); return (a, b) -&gt; comparator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b10239dc9db5803446387b9a8cc2ba9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c213593c46abd67e98d380354c2dabed/" rel="bookmark">
			Java 8系列之Stream的强大工具Collector
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stream系列：
Java 8系列之Stream的基本语法详解Java 8系列之Stream的强大工具CollectorJava 8系列之重构和定制收集器Java 8系列之Stream中万能的reduce 概述 前面我们使用过collect(toList())，在流中生成列表。实际开发过程中，List又是我们经常用到的数据结构，但是有时候我们也希望Stream能够转换生成其他的值，比如Map或者set，甚至希望定制生成想要的数据结构。
collect也就是收集器，是Stream一种通用的、从流生成复杂值的结构。只要将它传给collect方法，也就是所谓的转换方法，其就会生成想要的数据结构。这里不得不提下，Collectors这个工具库，在该库中封装了相应的转换方法。当然，Collectors工具库仅仅封装了常用的一些情景，如果有特殊需求，那就要自定义了。
显然，List是能想到的从流中生成的最自然的数据结构， 但是有时人们还希望从流生成其他值， 比如 Map 或 Set， 或者你希望定制一个类将你想要的东西抽象出来。
前面已经讲过，仅凭流上方法的签名，就能判断出这是否是一个及早求值的操作。 reduce操作就是一个很好的例子， 但有时人们希望能做得更多。 这就是收集器，一种通用的、从流生成复杂值的结构。只要将它传给collect 方法，所有的流就都可以使用它了。
&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);
&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner);
辅助接口 Supplier Supplier&lt;T&gt;接口是一个函数接口，该接口声明了一个get方法，主要用来创建返回一个指定数据类型的对象。
T：指定的数据类型
@FunctionalInterface public interface Supplier { T get(); }
BiConsumer BiConsumer&lt;T, U&gt;接口是一个函数接口，该接口声明了accept方法，并无返回值，该函数接口主要用来声明一些预期操作。
同时，该接口定义了一个默认方法andThen，该方法接受一个BiConsumer，并返回一个组合的BiConsumer，其会按照顺序执行操作。如果执行任一操作抛出异常，则将其传递给组合操作的调用者。 如果执行此操作抛出异常，将不执行后操作(after)。
@FunctionalInterface public interface BiConsumer&lt;T, U&gt; { void accept(T t, U u); default BiConsumer&lt;T, U&gt; andThen(BiConsumer&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c213593c46abd67e98d380354c2dabed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa654ec85d684e77f780df883a061c4f/" rel="bookmark">
			css属性选择器和通配符选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，属性选择器1 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;20-css属性选择器上.html&lt;/title&gt; &lt;!-- 属性选择器,根据指定的属性名称找到对应的标签,设置属性 1,格式: [attribute] 作用:根据指定的属性名称找到对应的标签,设置属性 [attribute=value] 作用:找到指定属性,并且属性的取值是value的标签,设置属性 最常见的场景就是,区分input标签的属性 input[type=password]{} &lt;input type="text" id=""&gt; &lt;input type="password" id=""&gt; &lt;input type="radio" id=""&gt; &lt;input type="checkbox" id=""&gt; --&gt; &lt;style&gt; /*p[id]{ color: red; }*/ p[class=pp]{ color: aqua; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p id="=id1"&gt;我是段落1&lt;/p&gt; &lt;p id="=id2" class="cc"&gt;我是段落2&lt;/p&gt; &lt;p class="cc"&gt;我是段落3&lt;/p&gt; &lt;p id="=id3"&gt;我是段落4&lt;/p&gt; &lt;p class="pp"&gt;我是段落4&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 二，属性选择器2 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;21-css属性选择器下.html&lt;/title&gt; &lt;!-- 1,属性的取值是以什么开头的 [attribute|=value] css2 了解 [attribute^=value] css3 2,属性的取值是以什么结尾的 [attribute$=value] css3 3,属性的取值是否包含某个特定的值的 [attribute~=value] css2 了解 [attribute*=value] css3 --&gt; &lt;style&gt; /*img[alt^=abc]{ color: red; }*/ img[alt|=abc]{ color: red; } img[alt$=abc]{ color: aqua; } img[alt*=abc]{ color: green; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa654ec85d684e77f780df883a061c4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5c665fb28ec42863a57d879de71ec12/" rel="bookmark">
			css序选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，序选择器1 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;18-css序选择器.html&lt;/title&gt; &lt;!-- 序选择器: css3中新增的选择器最具代表性的就是序选择器 1,同级别的第几个 :first-child 选中同级别中的第一个 :last-child 选中同级别中的最后一个 :nth-child(n) 选中同级别中的第n个 :nth-last-child(n) 选中同级别中的倒数第n个 :only-child 选中父元素中只有一个子元素的元素 注意点:不区分类型 2,同类型的第几个 :first-of-type 选中同级别中同类型的第一个 :last-of-type 选中同级别中同类型的最后一个 :nth-of-type(n) 选中同级别中同类型的第n个 :nth-last-of-type(n) 选中同级别中同类型的倒数第n个 :only-of-type 选中父元素中子元素的类型只有一种的元素 --&gt; &lt;style&gt; /*p:first-child{*/ /*color: red;*/ /*}*/ /* p:first-of-type{ color: red; }*/ /*p:last-child{ color: greenyellow; }*/ /*p:last-of-type{ color: green; }*/ /*p:nth-child(3){ color: red; }*/ /*p:nth-of-type(3){ color: burlywood; }*/ /*p:nth-last-child(2){ color: purple; }*/ /*p:nth-last-of-type(2){ color: yellow; }*/ /*p:only-child{ color: purple; }*/ p:only-of-type{ color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5c665fb28ec42863a57d879de71ec12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48d5c16a28a464599485ce7052c226db/" rel="bookmark">
			css交集选择器、并集选择器、兄弟选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，交集选择器 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;15-css交集选择器.html&lt;/title&gt; &lt;!-- 交集选择器,相交的部分就是要设置属性值的标签 1,格式: 选择器1选择器2...{ 属性:值; } 2,注意点: (1),选择器之间没有任何的连接符号 (2),选择器可以是标签名称,也可以是id、class名称 (3),交集选择器仅仅是了解 --&gt; &lt;style&gt; p.para1{ color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;我是段落&lt;/p&gt; &lt;p&gt;我是段落&lt;/p&gt; &lt;p class="para1"&gt;我是段落&lt;/p&gt; &lt;p class="para1"&gt;我是段落&lt;/p&gt; &lt;p&gt;我是段落&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 二，并集选择器 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;16-css并集选择器.html&lt;/title&gt; &lt;!-- 并集选择器 1,格式: 选择器1,选择器2,...{ 属性:值; } 2,注意点: (1),选择器之间利用,连接 (2),选择器可以是标签名称,也可以是id、class名称 --&gt; &lt;style&gt; .ht,.para{ color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class="ht"&gt;我是头&lt;/h1&gt; &lt;p class="para"&gt;我是段落&lt;/p&gt; &lt;p&gt;我是段落&lt;/p&gt; &lt;p&gt;我是段落&lt;/p&gt; &lt;p&gt;我是段落&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 三，兄弟选择器 &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48d5c16a28a464599485ce7052c226db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/530fb7298b60501281d030b1d20580c1/" rel="bookmark">
			css后代选择器，子元素选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，后代选择器 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;12-css后代选择器.html&lt;/title&gt; &lt;!-- 后代选择器,找到指定特定的标签的所有后代,然后设置属性 1,格式: 标签名称1 标签名称2 ...{ 属性:值; } 先找到名称叫做标签名称1的标签,然后在此标签下找到名称是标签名称2的所有标签,最后设置属性值 例如: div p{ } 2,注意点: (1),后代选择器必须用空格隔开 (2),后代不一定是儿子,也可以是孙子 (3),后代选择器不仅仅可以使用标签名称,也可以使用其他的选择器(如id、class选择器) --&gt; &lt;style&gt; /*div p{ color: red; }*/ /*#identtity p{ color: red; }*/ /*.para p{ color: green; }*/ .para .lip{ color: greenyellow; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;我是段落&lt;/p&gt; &lt;div id="identtity" class="para"&gt; &lt;p&gt;我是段落&lt;/p&gt; &lt;p&gt;我是段落&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p class="lip"&gt;我是段落&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;p&gt;我是段落&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 二，子元素选择器 &lt;!DOCTYPE html&gt; &lt;html lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/530fb7298b60501281d030b1d20580c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf90c95303fa015a27f7daa839279eac/" rel="bookmark">
			Bodymovin插件的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 使用css3来实现比较复杂动画的时候往往力不从心。所以网上看到的大多数专题基本上都是使用svg或者canvas来做的， 但是要对这些的api有一定的了解才能做出来，而且还要各种代码，过程相当繁杂。最近在github上面看到的一个神奇的插件：bodymovin，可以实现在 After Effect（可视化操作，不用码代码）上面导出 svg的json数据，然后在html上引入bodymovin.js，简单的初始化就可以在网页上面实现svg动画。amazing!
安装 github上面的使用教程 https://github.com/bodymovin/...
具体的插件安装也可参考文章
http://www.mq2014.com/after-e...
html调用 html
&lt;div id='container'&gt;&lt;/div&gt;
html页面引入 bodymovin.js
&lt;script src="js/bodymovin.js" type="text/javascript"&gt;&lt;/script&gt;
详情语法和选项请参考 github， wrapper为要出现动画的DOM，path为汇出的json档位置。
var svgContainer = document.getElementById(‘container’);
var animItem = bodymovin.loadAnimation({
wrapper: svgContainer,//svg容器
animType: ‘svg’,
loop: true,
path: ‘data.json’ //该json就是 After Effect的 bodymovin插件导出的json文件
});
参考文章
http://www.mq2014.com/after-e...
http://www.jianshu.com/p/d887...
https://github.com/bodymovin/...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f0e644255eb2f7acb948131523b085f/" rel="bookmark">
			文件grep
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 grep “text” file grep “abc” /a.txtgrep “text” dir grep -rn “abc” /data/var/星号/星号.log -rn 代表搜索所有目录和文件夹(r)以及显示行号(n) 第一个星号代表该所有文件夹下的所有文件夹 第二个星号代表所有以log结尾的文件 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/455/">«</a>
	<span class="pagination__item pagination__item--current">456/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/457/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>