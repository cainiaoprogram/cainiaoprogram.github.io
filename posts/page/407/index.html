<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20e9180de1f8489165acd09a96f843b3/" rel="bookmark">
			编译内核错误：Can&#39;t use &#39;defined(@array)&#39; (Maybe you should just omit the defined()?) at kernel/timeconst.p...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在编译一个新的rk sdk的时候，编译内核报错
CHK include/linux/version.h CHK include/generated/utsrelease.h make[1]: 'include/generated/mach-types.h' is up to date. CALL scripts/checksyscalls.sh CHK include/generated/compile.h TIMEC kernel/timeconst.h Can't use 'defined(@array)' (Maybe you should just omit the defined()?) at kernel/timeconst.pl line 373. /home/liuxueneng/workCode/rk3066/kernel/kernel/Makefile:141: recipe for target 'kernel/timeconst.h' failed make[1]: *** [kernel/timeconst.h] Error 255 Makefile:973: recipe for target 'kernel' failed make: *** [kernel] Error 2 显示错误
Can't use 'defined(@array)' (Maybe you should just omit the defined()?) at kernel/timeconst.pl line 373 已经提示纤细的错误信息在哪里了，打开timeconst.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20e9180de1f8489165acd09a96f843b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c18154a4155ca8d793bced347a316730/" rel="bookmark">
			maya中redshift渲染深度景深后nuke后期使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、redshift 渲染pass通道中的 depth层，会输出一个z 通道图片，建议使用tiff float方式，此方式精度很高。 nuke中读取tiff时，鼠标在图片上移动，发现深度信息集中在图片的RGB色彩信息中的R通道， 于是可通过shuffle节点将R通道提取并赋予RGB三个通道，转换成常规图片类型， 之后用grade节点根据鼠标点击不同通篇区域，得到景深的float大概范围值。 并重新映射黑白范围，方便使用zblur制作景深效果。 2、同过shuffleCopy节点，拷贝得到的深度信息为色彩层的depth通道，此处只使用红色通道，
之后使用zblur节点制作景深模糊效果，nuke还提供了zDefocus节点但是效率很低，有卡顿现象，
zblur则效率很高。
======================================= 链接： https://pan.baidu.com/s/1bF-9GwkeVw14kWJKb2bBeA 提取码：83cy ================================== 南无阿弥陀佛 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/114b0ba875bbc4d5c7edbe6e550df89b/" rel="bookmark">
			vue .number修饰符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中遇到这样一个问题, 某个input框用来输入价格之类的数字, 我想对input的取值区间做判断, 但是发现输入后变成了String类型, 所以用了vue中的.number修饰符, 这样就可以获得Number类型了, 很方便
&lt;el-input v-model.number="memberLevelForm.pointRate" type="number" placeholder="请输入消费金额" min="0" max="100" οnkeyup="(event.keyCode==69||event.keyCode==110)?this.value='':this.value" :disabled="isDetailPage"&gt;&lt;/el-input&gt; 扩展: .lazy会转变为在 change 事件中同步 .trim 修饰符会自动过滤掉输入的首尾空格 转载于:https://www.cnblogs.com/Shysun/p/10922816.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa0366d4710e9140a45a8f1ff16a8e30/" rel="bookmark">
			CVPR2019-实例分割Mask Scoring R-CNN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今年的Oral，在coco数据集表现超过了Mask RCNN，来自地平线的华科实习生。
论文：Mask Scoring R-CNN【paper】【github】
1. 提出背景 Mask RCNN 提出以来，一直是作为经典霸屏，但这里面一直存在一个严重的问题，那就是其score机制：
由于沿用了 Faster RCNN 的 class和box，对应class是类别score，并不能代表mask的好坏，看下图：
2. 算法框架 问题提出来，很简单的想法就是，我能否加一个分支预测mask部分的score呢？比如用IoU来度量。
思路很简单，在Mask head的基础上，加了一个分支，将ROI对齐后的特征与得到的Mask做了一个concat，然后通过卷积层+全连接层，得到IoU Score，最后通过score相乘得到最终的得分：
Smask​ = Scls​ ∗ Siou​
训练阶段 来看网络是如何训练的？给几个key point：
1）对于新增的IoU分支，训练样本是RPN的正样本（负样本只参与分类），与Mask分支一致；
定义正样本为RPN的Box与Ground Truth的IoU大于0.5。
2）针对得到的Mask结果，根据阈值（文中是0.5）做二值化，计算二值化结果 和 Ground Truth的mask IoU；
当二值化mask结果与GT一致时，Loss = 1 - Mask IoU = 0
这里的二值化可以考虑修改一下，比如采用soft mask的方案。
3）3个head分支同时训练。
这里作者试验了多个head，根据试验效果最后选择当前head，这里也有改进的空间，大家可以好好分析一下。
推理阶段 1）对于输出的box做soft-NMS处理后，得到score top-k（文中k=100）的box；
这一步和mask RCNN并无区别，根据输出box映射到mask 分支，获取对应的分割图。
2）将得到的分割图送入mask IoU分支，计算对应得分；
3）仅使用Mask IoU的score来矫正class core，能够整体反应分割的够不够好；
3. 测试效果 测试效果很不错，请看大屏幕：
在CoCo数据集上的表现（不同backbone上均有显著提升）：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28d0192e106db5f4edc6e76f3875a99a/" rel="bookmark">
			vbs进阶——条件分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		条件分支，是一个特别基础的东西，对于像我一样热爱C++的人，就是一些if,else,case之类的东西，下面我们要讲的vbs的条件分支也差不多一样.
基础代码： if 条件 then 做的事 注意：一定不能分行，否则就会编译错误！
else if 条件 then 做的事 else 不满足需要做的事 3个及以上的条件 if 条件 then 做的事 else if 条件 then 做的事 else if 条件 then 做的事 就这样两个单词:
if else
却能衍生出无限种可能，这就是条件分支！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca4c50b905dc21ea17a10549a6f5944f/" rel="bookmark">
			bootstrap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感悟：bootstrap就是一个预定义的模板，你用它的模板最主要的是要知道class是什么，class的作用域，作用范围是什么，各种bootstrap的实现是通过各种类名的添加来实现的，最重要的模块是栅格属性（当然，你可以动态改变栅格系统的列数）
如果要超小屏幕，小屏幕和中等屏幕同时拥有排列效果，那么需要把类前缀都加上（3个）
重要的类名
(相当于css.reset)
想知道元素为什么会设置为某个样式，比如为什么list-inline会让文本水平排列，可以打开浏览器审查元素，直接看css设置
表格标题和表格内容的写法
即便是不加table-responsive表格也是响应式的，加上更为保险一些
所有的包裹着form-group类的元素宽度都为100%
当你点击label的时候，input会自动获取焦点，所以label非常重要，注意图中id的对应一致性
每个input都加了一个类名class=“form-control”，这个类名加了之后，会让input样式发生一些改变
在bootstrap下创建按钮的三种方式（共同点是class=“btn
btn-default”，当然也可以通过其他的class来创建比如Success,Danger只是颜色不同而已）
响应式图片也非常简单加个class就可以了
在一些对界面要求不太严格的项目中，可以使用bootstrap
bootstrap组件路径导航
下拉列表的源码里面可以把所有以aria和role开头的删除掉 下面第4&lt;li role="separator" class="divider"&gt;&lt;/li&gt;行代表着下划线，添加可以使结构明晰 dropdown可以变为dropup
dropdown-menu可以变为dropdown-menu-right,下拉菜单元素就会右对齐 也可以添加一行li为下拉列表加个标题
&lt;div class="dropdown"&gt; &lt;button class="btn btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true"&gt; Dropdown &lt;span class="caret"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class="dropdown-menu" aria-labelledby="dropdownMenu1"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 按钮组 加个-vertical按钮就变成垂直排列 可以在按钮组里面加上下拉列表 按钮尺寸调整加上btn-sm
&lt;div class="btn-group"&gt; &lt;button type="button" class="btn btn-default"&gt;Left&lt;/button&gt; &lt;button type="button" class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca4c50b905dc21ea17a10549a6f5944f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6626e0266f4290d791bd40db075e3023/" rel="bookmark">
			HDU 4745 Two Rabbits
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=4745
题目分析 这个题目乍一看觉得很麻烦，不过仔细读题就会发现一个重要的条件：两个兔子不会相互穿过，也就是说，两个兔子始终在一个环里面走；而且在任意时刻，两个兔子所在的位置的权值一样，那么我们设想一下两个兔子都从终点出发，看他们最远可以走多少步，这样等价于两个兔子从任意位置出发最后聚集于同一个位置一样；
那么我们从终点走的时候，两个兔子走过的石子的权值恰好构成一个回文串。
这样一来我们所求的就变成了求给定的环中最长的回文子序列了。
现在讲一下下面代码的思想吧，我们记dp [ i ] [ j ] 为从 i - j 的最长回文子序列的长度，先求出了所有子序列的回文长度，具体做法：
首先说明一下代码： dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
现在我们需要求的是区间 [ i, j ] 的最长回文子序列，如图
那么这个区间的最长回文子串可能是由区间 [ i+1 , j ] 的左边添加一个元素后形成的，为了不打乱 [ i + 1 , j ] 中的最长回文子序列，我们把添加的元素不计入回文串的计算就好。
同理，这个区间的最长回文子串也可能是在区间 [ i , j - 1] 的右边添加一个元素后形成的，为了不打乱 [ i , j - 1 ] 中的最长回文子序列，我们把添加的元素不计入回文串的计算就好。
然后就是代码: if (w[i] == w[j]) dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + 2);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6626e0266f4290d791bd40db075e3023/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8a3d62a9372edd1b301d03692c4af01/" rel="bookmark">
			Comparison method violates its general contract!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目中有许多地方用到了集合排序，不是自然排序，必须的自己实现排序逻辑了。
java提供实现排序接口有两个Comparable与Comparator。
我简单理解：
1.Comparable接口是实现在需要排序的单个对象上的，例如：Student学生类，根据学号或其他属性排序，Student类就要implements实现Comparable接口，并重写int compareTo(T o) 方法。你排序所依赖的所有元素都需要包含在Student类里，换言之就是依赖在Student类里能获取到的资源。然后直接调用Collections.sort(List&lt;T&gt; list) 方法就行了，比较方便。
但是，有一点需要注意，Comparable接口比较局限，就是继承Comparable接口类只能实现Student的一种排序，换一种排序，你就需要重新编写Student基础类了。
2.Comparator接口是可以单独拿来实现的，每个实现Comparator接口都可以有一种排序的逻辑。继承Comparator接口需要实现 int compare(String o1, String o2)方法。然后直接调用Collections.sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)方法。
Comparator接口就比较自由了，每个实现Comparator接口都可以有自己实现逻辑，无需修改需要排序的对象，比较灵活。并且所依赖的元素不局限于需要排序对象本身的属性，可以把需要的资源任意添加实现Comparator接口的类中。
例如：
class SchoolRoomComparator implements Comparator&lt;String&gt;{ Map&lt;String,SchoolRoom&gt; schoolRoomMap; public SchoolRoomComparator(){ this.schoolRoomMap = schoolRoomMap； } @Override public int compare(String o1, String o2) { return schoolRoomMap.get(o1).getXuhao() - schoolRoomMap.get(o2).getXuhao(); } } 用到了出了需要排序的String对象外，还依赖schoolRoomMap属性。
下面我说说我程序报的异常吧。
异常：Comparison method violates its general contract!
我这里就简单阐述一下，我用的是Comparator接口实现的排序。由于业务需要，在比较Double对象大小时，我用了Math.ceil(double a) 方法，错误的把需要比较的Double对象转化成了整数，忽略了小数部分。违反了Comparator 要满足自反性，传递性，对称性。
参考博客：https://blog.csdn.net/wangxueming/article/details/80967341
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fa83e0cbe6e27354b0d65325301c2b9/" rel="bookmark">
			win7系统，ENVI5.2安装中出现the installation of msvc_2005_sp1_x86 has failed 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win7系统，ENVI5.2安装中出现the installation of msvc_2005_sp1_x86 has failed 解决办法
原因：注册表大小被限制
操作步骤：
1、开始——&gt;运行——&gt;regedit，确定
2、找到HKEY_LOCAL_MACHINE——&gt;SYSTEM——&gt;CurrentControlSet——&gt;Control，找到RegistrySizeLimit，（如果没有，在右侧右键，新建，如图）
做如下修改
最后的结果这样的：
重启电脑，完了之后，再安装ENVI，就没有上述问题了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/235e614a1b20b893d5450bef34afce9d/" rel="bookmark">
			Mint-UI的mt-search如何触发事件（确定和取消）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mint-ui的官方文档写得是真的简单，简单到遗漏了许多重点，使用文档里关于mt-search的api只介绍了属性的部分，各个调用方法完全没有介绍，让用户自己去探索？官方文档。
关于开源框架的使用文档，我接触到的还是Element-UI写得最为简洁明了了，相比于Mint-UI都是同一个爸爸（饿了么）出来的，差距为什么就这么大呢？
正文 1、确定事件
mint-ui使用文档开头里有提到，在 Vue 2.0 中，为自定义组件绑定原生事件必须使用 .native 修饰符，mint-ui开发者可能考虑到button按钮使用的概率比较大，他们只对 Button 组件进行了处理，使用mt-button组件可以直接@click绑定事件，而其他的组件都需要使用.native修饰符来触发事件。
mt-search触发确定事件，需使用@keyup.enter.native来绑定确定事件，如下图：
&lt;mt-search ref="mtSearch" @keyup.enter.native="search"&gt;&lt;/mt-search&gt; 解释：很多读者会很纳闷，为什么不是用click点击事件触发呢？是这样子的，手机键盘的上都会自带有一个搜索按钮（右下角），无论是安卓还是ios，当用户输入完点击搜索按钮后就会执行所绑定的确定事件了。如下图问ios的键盘：
2、取消事件
关于mt-search的取消事件就更蛋疼了，这个组件提供了一个取消按钮，却不提供点击触发事件，我也是佛了... 我在网上也搜了很久，没有找到一个很合适的，有的说监听input绑定的value为空时实现取消事件？这位小哥未必太单纯了，要是我输入时输错了或者想清空重新输入呢？这时候也会执行此取消事件。找了一遍，没找到，于是自己动手写一个吧。
请原谅，我用上了最原始的方法，哈哈哈哈哈... mounted(){ this.$nextTick(()=&gt;{ let cancel = this.$refs.mtSearch.$el.querySelectorAll('.mint-searchbar-cancel')[0]; cancel.onclick=()=&gt;{ this.close() // 取消事件 } }) } 给取消按钮添加一个dom事件，来执行取消事件，我也是无可奈何呀。
经过对各个移动端ui框架的对比，从技术团队、社区活跃度和框架实用性等方面考虑，我个人推荐有赞的Vant-ui，虽然Vant-ui初始定位是应用于商城类web，但是随着它的组件逐渐丰富，它可以应用于很多场景，最重要的是它的文档写得简洁明了，开发者用起来舒服；但它有一个缺点，单位用的是px，如果要做移动端适配还有把它转成rem，这一部分它文档有介绍，只不过转换有些麻烦。
（完）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccb34a8e524b53c8243a29d3baf5363e/" rel="bookmark">
			Unity中Scale详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.缩放变换
Scale代表的是缩放。 通常意义下的缩放变换，指的是利用缩放矩阵和物体的齐次坐标相乘而进行变换，缩放矩阵形如：
Scalex代表x轴方向的缩放 Scaley代表y轴方向的缩放 Scalez代表z轴方向的缩放 当它与物体的齐次坐标相乘后，可以得到缩放后的物体坐标 可以发现缩放矩阵将物体原本的坐标依据缩放比例进行了变换。 这是几何上的缩放变换，那么在Unity中，缩放变换又是一种什么样的作用呢。
2.Unity中的缩放变换
在Unity中，对于导入的模型以及unity中自带的那些Object（例如 Cube 、Sphere…）是不能直接改变其本身属性坐标的大小的，只有通过缩放变换来改变其自身坐标系的大小来使其大小发生改变。也就是如果物体正常的长度为2，如果你本体坐标系的缩放为2，那么物体实际看到的长度就变为了4，但是这个物体在它本体坐标系下的长度仍然为2。在Unity中，Scale的变化你可以看做是对物体的本体坐标系进行的缩放变化，在这个缩放过程中，物体在其本体坐标系下的各项属性保持不变。 如图这是一个Cube改变Scale之前的状态，接下来我们在Z轴对它进行缩放 可以发现这个cube在z轴上的长度变为了原来的二倍，而它自身的坐标并未发生改变。
在unity中的物体的transform里，表示缩放的一共有两个量，lossyScale和localScale。
Localscale代表的是当前物体相对于父物体的缩放，既可以作为左值也可以作为右值。
Lossyscale代表的是当前物体在全局中的缩放，为只读变量，不可修改。
Inspector界面显示的scale表示的是localScale。
3.注意
在Unity中关于Scale容易出问题的地方就在于当物体之间包含父子关系时，如果父物体的Scale改变，会导致子物体的世界坐标（即transform.position）发生改变。（注意，inspector中的position为与父物体的相对坐标）
假定在父物体的Scale为（1,1,1）的情况下，父物体的世界坐标为(x1,y1,z1)，子物体的世界坐标为(x2,y2,z2)。当父物体的Scale发生改变变为（1,1,2）时，父物体的世界坐标不发生改变，而子物体的世界坐标将变为(x1,y1,z1+(z2-z1)*2)。子物体的世界坐标发生这种改变的目的，是为了保证其相对于父物体本体坐标系的相对坐标的不变性。
演示一下
令Ojbect1为父物体，object2为obj1的子物体，object3为obj2的子物体 如果在初始情况下object1的坐标为（0,0，-2），object2的坐标为（0,0,1.5），object3的坐标为（0,0,4） 接下来改变三个物体的localScale。 Object1的localScale为（1,1,1.5） object2的localScale为（1,1,2） object3的localScale为（1，1,3） 改变过后，三者的lossyScale变为（1,1,1.5），（1,1,3），（1,1,9）。 Obj1的position为（0,0，-2），obj2的坐标为（0,0,3.25），obj3的坐标为（0,0,10.75）。
改变前后三个物体的localPosition均未发生改变。
接下来解释obj2和obj3的坐标变化是如何得来的。 3.25= -2+（1.5-（-2））*1.5 10.75=[-2+ （1.5-（-2））*1.5]+(4-1.5)*3 即子物体的当前世界坐标等于父物体的世界坐标加上子物体相对于父物体的相对坐标乘以父物体的lossyScale对应的值。
public class ObstacleCollect : MonoBehaviour { void Awake() { BoxCollider[] boxColliders = GetComponentsInChildren&lt;BoxCollider&gt;(); for (int i = 0; i &lt; boxColliders.Length; i++) { float minX = boxColliders[i].transform.position.x - boxColliders[i].size.x*boxColliders[i].transform.lossyScale.x*0.5f; float minZ = boxColliders[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccb34a8e524b53c8243a29d3baf5363e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aa846c8d8305e3260c64b13ae52aef9/" rel="bookmark">
			（七）系统信息图形化显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面我们读取了CPU的信息，并且以QLabel的形式显示了出来，但是只是一些文字的显示，所以这次我想对这些信息做一下美化，让他们看起来好看一些。
首先，我们参考一下Windows是怎么做的。
这是Windows下任务管理器中的信息，以波形图的方式展现了出来，那么我就仿造他做一个吧
我要显示4个信息的波形图，CPU使用率，CPU温度，内存信息，硬盘信息，所以要创建四个Widget窗口，并且画波形图的方法都是一样的，只是传入的值不一样，所以我子类化了一个QWidget，命名为QGraph，在ui设计界面，将控件的类提升为自定义的QGraph类
首先，头文件中的构造函数
#define ROWS 5 //5行 #define COLS 20 //20列 class QGraph : public QWidget { Q_OBJECT public: explicit QGraph(QWidget *parent = 0); ~QGraph(); QColor background_color, line_color; //保存背景色和前景色 int graph_heigh,graph_width; //行间距和列间距 int startX,startY; //起始的坐标 void setColor(QColor bgcolor, QColor lcolor); //设置背景色和前景色，上级调用 void setRate(double rate); //设置数据，上级调用 void dataReset(); //清空数据，上级调用 protected: void paintEvent(QPaintEvent *); //画图事件 private: int cur; //最近一次更新数据的数组索引值 int length = COLS*2+2; //数组长度 double RateData[COLS*2+2]; //用于保存数据，只保存最近的42个数据 }; 观察Windows的界面发现，背景的栅栏使用很浅的颜色画的，线条用深色的颜色，而用于填充的颜色介于背景色与前景色之间。在主窗口实例化了4个窗口，分别为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5aa846c8d8305e3260c64b13ae52aef9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/522ebae63e051e69eb2cd524ded34dbf/" rel="bookmark">
			libevent 的 Android 编译过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址：
https://github.com/ventureresearch/libevent
已经修改好的版本：
https://download.csdn.net/download/phil_gu/11195444
重要过程：
1. Android.mk 去掉 文件： epoll_sub.c bufferevent_openssl.c (不需要SSL)
2. 由于在android上连接的原因
将 Android/event2/event-config.h
/* Define to 1 if you have the `issetugid' function. */ //#define _EVENT_HAVE_ISSETUGID 1 Android 下面没有 issetugid 函数
evutil_rand.c
在 evutil_secure_rng_add_bytes 之前 加上 #ifdef HAVE_ARC4RANDOM_ADDRANDOM
#ifdef HAVE_ARC4RANDOM_ADDRANDOM void evutil_secure_rng_add_bytes(const char *buf, size_t n) { arc4random_addrandom((unsigned char*)buf, n&gt;(size_t)INT_MAX ? INT_MAX : (int)n); } #endif 3. 运行 NDK 进行编译：
ndk-build.cmd NDK_PROJECT_PATH=. APP_BUILD_SCRIPT=Android.mk 会生成 libevent 的 Android 静态库。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d95273abf1dda06fda0f136e422c25e/" rel="bookmark">
			深度学习：TensorFlow简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于TensorFlow TensorFlow是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。是由谷歌的研究员和工程师研究开发，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。
什么是数据流图（Data Flow Graph）? 数据流图中使用“节点”与“线”表示。如果用计算机中的逻辑表示的话，“节点”就是输入输出位，而“线”代表着中间实现的逻辑门，如与、或、非。
Tensorflow的特征 高度的灵活性 TensorFlow 不是一个严格的“神经网络”库。只要你可以将你的计算表示为一个数据流图，你就可以使用Tensorflow。你来构建图，描写驱动计算的内部循环。我们提供了有用的工具来帮助你组装“子图”（常用于神经网络），当然用户也可以自己在Tensorflow基础上写自己的“上层库”。定义顺手好用的新复合操作和写一个python函数一样容易，而且也不用担心性能损耗。当然万一你发现找不到想要的底层数据操作，你也可以自己写一点c++代码来丰富底层的操作。
真正的可移植性（Portability） Tensorflow 在CPU和GPU上运行，比如说可以运行在台式机、服务器、手机移动设备等等。想要在没有特殊硬件的前提下，在你的笔记本上跑一下机器学习的新想法？Tensorflow可以办到这点。准备将你的训练模型在多个CPU上规模化运算，又不想修改代码？Tensorflow可以办到这点。想要将你的训练好的模型作为产品的一部分用到手机app里？Tensorflow可以办到这点。你改变主意了，想要将你的模型作为云端服务运行在自己的服务器上，或者运行在Docker容器里？Tensorfow也能办到
多语言支持 Tensorflow 有一个合理的c++使用界面，也有一个易用的python使用界面来构建和执行你的graphs。你可以直接写python/c++程序，也可以用交互式的ipython界面来用Tensorflow尝试些想法，它可以帮你将笔记、代码、可视化等有条理地归置好。当然这仅仅是个起点——我们希望能鼓励你创造自己最喜欢的语言界面，比如Go，Java，Lua，Javascript，或者是R
性能最优化 比如说你又一个32个CPU内核、4个GPU显卡的工作站，想要将你工作站的计算潜能全发挥出来？由于Tensorflow 给予了线程、队列、异步操作等以最佳的支持，Tensorflow 让你可以将你手边硬件的计算潜能全部发挥出来。你可以自由地将Tensorflow图中的计算元素分配到不同设备上，Tensorflow可以帮你管理好这些不同副本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/767b5e38ef3a079b26a4d5908d9b08b1/" rel="bookmark">
			Spring Boot整合IBM MQ 连接发送和接受
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从网上整理的，有些问题再更改了一下。
1.pom &lt;!--ibm mq--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.jms&lt;/groupId&gt; &lt;artifactId&gt;javax.jms-api&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.ibm.mq&lt;/groupId&gt; &lt;artifactId&gt;com.ibm.mq.allclient&lt;/artifactId&gt; &lt;version&gt;9.1.1.0&lt;/version&gt; &lt;/dependency&gt; 2.application.properties #ibm mq 配置信息 project.mq.host= 192.168.6.11 project.mq.port= 1414 #(队列管理器名称) project.mq.queue-manager= mq #(通道名称) project.mq.channel= fuwu #创建的MQ用户 project.mq.username= root #创建的MQ用户连接密码 project.mq.password= 123456 #连接超时 project.mq.receive-timeout= 20000 3.JmsConfig（注入连接参数） import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import org.springframework.jms.connection.CachingConnectionFactory; import org.springframework.jms.connection.JmsTransactionManager; import org.springframework.jms.connection.UserCredentialsConnectionFactoryAdapter; import org.springframework.jms.core.JmsOperations; import org.springframework.jms.core.JmsTemplate; import org.springframework.transaction.PlatformTransactionManager; import com.ibm.mq.jms.MQQueueConnectionFactory; import com.ibm.msg.client.wmq.WMQConstants; @Configuration public class JmsConfig { /** * 注入连接参数: * 建立JmsConfig类，添加注解@Configuration，并将以上属性注入到此类 */ @Value("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/767b5e38ef3a079b26a4d5908d9b08b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b1e3deeda0d77e271e9dcc7f241b014/" rel="bookmark">
			从损失函数解决关于密集遮挡人群的检测问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于密集遮挡的行人检测
行人检测是计算机视觉领域的一个重要研究课题，在自动驾驶，视频监控和机器人等各种应用，旨在预测一系列行人实例的边界框。实际上，在现实生活中的复杂情景中，遮挡是行人检测的最重要挑战之一，尤其是在拥挤的场景中。例如在CityPersons数据集中48.8 ％行人其它行人互相遮挡。以前的方法只要求每个预测的边界框都接近其指定的GT，而不考虑它们之间的关系。因此，它们使得检测器对拥挤场景中的非最大抑制（NMS）的阈值敏感，这种密集遮挡问题并不能单靠调整NMS阈值来解决，较大的NMS阈值导致很多误检，较小的NMS阈值导致很多漏检。
有些论文专门提出方法来解决密集和遮挡问题，本文将关注Occlusion-aware R-CNN:Detecting Pedestrians in a Crowd（简称为OR-CNN）和Repulsion Loss两个解决方案。
1.OR-CNN
该论文以Faster R-CNN为基础，对损失函数部分和RoIPooling两个部分分别做出了一些改进。本博客将主要关注对损失函数改进的部分，提出聚集损失（AggLoss）来改进密集遮挡问题。
Faster R-CNN是两阶段检测方法，分别在RPN和R-CNN头部网络检测。为了在RPN模块中能有效的生成更加准确的区域候选框，设计了AggLoss使候选框尽量的靠近对应的GT，并且同一个GT对应的所有proposal boxes尽量紧凑。其定义如下：
损失函数包含两个部分，分类损失和AggLoss，其中分类损失是与原始论文一样，使用交叉熵损失。AggLoss定义如下：
AggLoss 包含常规的回归损失用于使proposal boxes尽量靠近GT，同时还有一个compactness loss，Lcom，用于使同一个GT对应的多个proposal boxes之间尽量紧凑，定义如下：
由以上定义可知，Lcom是专门针对一个GT对应了多个anchor的情况，让同一个GT对应的候选框之间尽量的紧凑，通过计算GT与多个候选框的均值之间的smoothL1实现。
AggLoss的思想非常简单，损失设计也很简洁，只是在原来的损失基础上增加了一个Lcom，从而达到了使候选框尽量的靠近对应的GT，并且同一个GT对应的所有proposal boxes尽量紧凑的目的。效果很赞，在多个公开数据集上达到了SOTA，作者对比了使用原始损失和AggLoss的区别，见下图。
这两个图很有意思，能反映一些问题，图a是没有使用NMS的预测结果，可以明显看出AggLoss的预测结果更好，基线的预测结果框比较分散，AggLoss的结果同一个GT的框更加紧凑，这种情况使用NMS可轻松去掉冗余框而不会出现漏检或者误检。图b是NMS阈值对预测结果的影响，对于基线方法0.55是一个分水岭，NMS阈值小于0.55时，错误率一直下降，但是超过0.55之后错误率大幅增加。对于AggLoss情况，错误率曲线更加平滑，首先整体错误率比基线更低，其次NMS阈值对AggLoss的影响没那么大，而且NMS阈值增加到0.55继续增加也不会出现错误率上升的情况，因为AggLoss的预测框更加紧凑，使用NMS很容易过滤冗余框。
2. 互斥损失
Repulsion Loss是旷视提出的，针对密集遮挡行人问题在损失函数做了一些改进。其想法也很简单，对于密集遮挡问题，如何处理同一个GT对应的多个候选框以及不同的GT对应的候选框？类似磁铁原理，同性相斥异性相吸，RepLoss使同一个GT对应的多个候选框尽量的紧凑聚集，不同GT对应的候选框尽量远离，有点类似triplet loss的想法。函数设计如下：
其中LAttr是吸引损失，其实就是常规使用回归损失smoothL1，RepGT和RepBox分为两个排斥损失，第一个使proposals远离具有第二大IoU的GT，第二个使不同GT对应的proposals尽量远离。
注意，第一个loss中作者使用了IoG而不是传统的IoU，原因在于GT无法改变，如果使用IoU则网络可以通过放大proposal的方式来降低loss，这并不是我们所期望的。如果直接使用IoG，分母是GT的面积无法改变，从而规避了这样的问题。
其中这个Smooth_ln是针对0到1的输入变量设计的一个鲁棒函数，具体形状如下所示：
可以看到，正如Smooth_l1不会对特别大的偏差给予过大的惩罚，Smooth_ln对于很小接近于1的输入也不会像原始的ln函数一样给予负无穷那么大的loss，从而可以稳定训练过程，而且对抗一些离群点。
NMS对错误率的影响曲线，相对于基线，RepLoss的曲线会更加平滑，且在各个阈值都要优于基线方法。
参考：
[1] Wang, X., Xiao, T., Jiang, Y., Shao, S., Sun, J., &amp; Shen, C. (2017). Repulsion Loss: Detecting Pedestrians in a Crowd. arXiv preprint arXiv:1711.07752.
[2] Zhang, S., Wen, L., Bian, X., Lei, Z.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b1e3deeda0d77e271e9dcc7f241b014/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dcf827a259020f741438b0aa855e773/" rel="bookmark">
			CRNN代码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CRNN主要分为四步
1.特征提取
2.序列转换
3.执行LSTM获取序列输出
4.进行CTC转换
CRNN使用 以下代码有三个作用
1.特征提取
2.序列转换
3.执行LSTM获取序列输出
def inference(self, inputdata, name, reuse=False): """ Main routine to construct the network :param inputdata: :param name: :param reuse: :return: """ with tf.variable_scope(name_or_scope=name, reuse=reuse): # centerlized data inputdata = tf.divide(inputdata, 255.0) #1.特征提取阶段 # first apply the cnn feature extraction stage cnn_out = self._feature_sequence_extraction( inputdata=inputdata, name='feature_extraction_module' ) #2.第二步， batch*1*25*512 变成 batch * 25 * 512 # second apply the map to sequence stage sequence = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dcf827a259020f741438b0aa855e773/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82a3593e2b10a218e36de5c9716c2aaf/" rel="bookmark">
			AndroidStudio关联源码；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、找到你AndroidStudio SDk的这个目录 ，把标红的地方复制下来； 2、来到你as的配置目录： 开打 jdk.table.xml 文件；
接下来就是重点了：修改
&lt;sourcePath&gt; &lt;root type="composite"&gt; &lt;root url="http://developer.android.com/reference/" type="simple"/&gt; &lt;/root&gt; &lt;/sourcePath&gt; //或 &lt;sourcePath&gt; &lt;root type="composite"&gt; &lt;/root&gt; &lt;/sourcePath&gt; 修改为：
&lt;sourcePath&gt; &lt;root type="composite"&gt; &lt;root url="file://D:/AndroidTool/Android/sdk/sources/android-25" type="simple"/&gt; &lt;/root&gt; &lt;/sourcePath&gt; //url就是你步骤一复制的地址； 注意：
正常情况下，会有多个 &lt;name value="Android API 27 Platform"/&gt; ，用到什么版本就修改这个版本的就行；建议多修改几个；
最后，重启AS！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e55a66cb0c4a775edfcaed55d740b0b/" rel="bookmark">
			Java内存分析工具MAT(Memory Analyzer Tool)安装使用实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/jin_kwok/article/details/80326088
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba85f169d9a56bc09059852ed77ab645/" rel="bookmark">
			UE4 阴影距离修改，解决阴影错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原答案连接：https://answers.unrealengine.com/questions/169875/shadow-draw-distance.html?tdsourcetag=s_pcqq_aiomsg
官方文档：https://docs.unrealengine.com/en-US/Engine/Rendering/LightingAndShadows/RayTracedDistanceFieldShadowing/index.html
场景物体远离时，阴影自动消失，这是UE4的优化方案，而且这个数值可以进行设置。
在project settings - Engine - rendering ，勾选Generate Mesh Distance Fields，重启工程
在世界大纲中，选择产生阴影的灯光。
在Detail - Cascaded Shadow Maps，修改Dynamic Shadow Distance MovebleLight数值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9db3ba23ee7fbddd1738f5f183441b9/" rel="bookmark">
			不同Vlan的PC相互通信（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不同Vlan的PC相互通信（一） 本周计算机网络实验，实验内容是：只使用Vlan的trunk接口和access接口实现两个二层交换机上属于不同Vlan的PC互通
预备知识 交换机端口 以太网端口有三种链路类型：access、hybrid、trunk.
Access端口只能允许一个Vlan通过，一般用于连接终端，也是端口默认的类型。
Trunk端口可以允许多个Vlan通过，一般用于交换机之间的连接:
Port link-type trunk
Hybrid端口和Trunk端口唯一不同之处在于发送数据时：
Hybrid端口既可以允许多个Vlan的报文发送时不打标签，也可以允许多个Vlan的报文发送时打标签；Trunk端口只允许和自己pvid值相同的Vlan报文发送时不打标签。所以Hybrid端口不仅用于连接交换机，还可以连接终端。Port link-type hybrid 端口接收报文 Access端口收报文:
收到一个报文，判断是否有Vlan信息： 如果没有则打上端口的PVID，并进行交换转发如果有则直接丢弃（缺省）。 trunk端口收报文：
收到一个报文，判断是否有Vlan信息： 如果没有则打上端口的PVID，并进行交换转发如果有判断该trunk端口是否允许该Vlan的数据进入：如果允许则报文携带原有Vlan标记进行转发，否则丢弃该报文。 hybrid端口收报文：
收到一个报文，判断是否有Vlan信息： 如果没有则打上端口的PVID，并进行交换转发如果有则判断该hybrid端口是否允许该Vlan的数据进入：如果可以则转发，否则丢弃。 端口发送报文 Acess端口发报文：
将报文的vlan tag剥离，直接发送出去。trunk端口发报文：
比较端口的PVID和将要发送报文的Vlan信息： 如果两者相等则剥离Vlan信息，再发送否则报文将携带原有的Vlan标记转发。 hybrid端口发报文：
1、判断该Vlan在本端口的属性
2、如果是untag则剥离Vlan信息，再发送，如果是tag则比较端口的PVID和将要发送报文的Vlan信息，如果两者相等则剥离Vlan信息，再发送，否则报文将携带原有的Vlan标记进行转发。 实验环境 上课时是在实体交换机上操作，课后使用华为eNSP模拟试验，加深印象。
华为eNSP:
网络拓扑图 设备配置 交换机配置 LSW1
LSW2
PC机配置 PC1：
PC2：
PC3：
PC4：
PC5：
PC6：
实验结果 Vlan 100的PC1可以访问对端 Vlan 200的PC2.
Vlan 100和Vlan 100、Vlan 200 和Vlan 200间均不能通信，为什么？
Vlan50和Vlan50的相互通信不受任何影响，为什么？
结果分析 由交换机端口收发报文的性质可知，实验结果与预期一致。
附配置命令 交换机的基本配置 •显示交换机的各种运行状态
[sw]display current-configuration
[sw]display interface
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9db3ba23ee7fbddd1738f5f183441b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e88df3e1f834242e7d4baac5314f665f/" rel="bookmark">
			C#关于控制线程的停止和继续
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、static EventWaitHandle eHandle = new EventWaitHandle(true, EventResetMode.ManualReset); 当前状态下调用 eHandle.WaitOne(),不会导致阻塞， 需要调用Reset()阻塞，Set()放行。 WaitOne()-&gt;Run-&gt;Reset()-&gt;Stop-&gt;Set()-&gt;Run 2、static EventWaitHandle eHandle = new EventWaitHandle(false, EventResetMode.ManualReset); 当前状态下调用 eHandle.WaitOne(),需要先Set()放行，不然门一直是关闭的 WaitOne()-&gt;Stop-&gt;Set()-&gt;Run 3、static EventWaitHandle eHandle = new EventWaitHandle(true, EventResetMode.AutoReset); 当前状态下第一次调用WaitOne(),并不会阻塞，true表示放行的状态，但是因为是自动模式，走过门之后会自动把门带上，第二次调用WaitOne(),会阻塞住,如果是手动模式，不去ReSet()的话，不管怎么调用WaitOne()都会放行。 WaitOne()-&gt;Run-&gt;WaitOne()-&gt;Stop-&gt;Set-&gt;Run 4、static EventWaitHandle eHandle = new EventWaitHandle(false, EventResetMode.AutoReset); WaitOne()-&gt;Stop-&gt;Set()-&gt;Run 自动模式下，如果在放行状态，调用一次WaitOne()后都会自动关门阻塞。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ee69cf1038e0e41650df677674044f3/" rel="bookmark">
			在Xilinx zynq7020平台使用Marvell6020交换机芯片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初次写博客，不好的地方欢迎提出建议。 目 标 ：在ZYNQ7020处理器的linux平台调通Marvell 88e6020交换机，实现局域网内可以通讯。 硬件平台：zynq7020（ARM CORTEX-A9），Marvell 88E6020交换机芯片 内核版本：linux4.14.0 说到网络，肯定是先想到网络OSI7层协议模型，直接度娘可以找到很多7层模型的详细介绍，以下介绍简单介绍相关的MAC层和PHY层。 •MAC是Media Access Control的缩写，即媒体访问控制子层协议。该协议位于OSI七层协议中数据链路层的下半部分，主要负责控制与连接物理层的物理介质。 在发送数据的时候，MAC协议可以事先判断是否可以发送数据，如果可以发送将给数据加上一些控制信息，最终将数据以及控制信息以规定的格式发送到物理层； 在接收数据的时候，MAC协议首先判断输入的信息并是否发生传输错误，如果没有错误，则去掉控制信息发送至LLC层。以太网MAC由IEEE-802.3以太网标准定义。 •PHY是物理接口收发器，它实现物理层。包括MII/GMII（介质独立接口）子层、PCS（物理编码子层）、PMA（物理介质附加）子层、PMD（物理介质相关）子层、MDI子层。 PHY在发送数据时，收到MAC过来的数据（对PHY来说，没有帧的概念，对它来说，都是数据而不管什么地址，数据还是CRC），每4bit就增加1bit的检错码，然后把并行数据转化为串行流数据，再按照物理层的编码规则把数据编码，再变为模拟信号把数据送出去。 收数据时的流程反之。 PHY与MAC的通迅接口 MAC和PHY是通过MII（Medium Independent Interface（介质独立接口））进行通信。包括如下：
数据接口，有TX/RX两条独立的通道。管理接口（SMI），由时钟信号和数据信号组成，控制监控PHY的工作状态。 以MII的基础，又有了以下多种数据接口： RMII（Reduced Media Independant Interface）,简化的MII，信号线更少了。GMII（Gigabit Media Independent Interface）千兆的MII接口。RGMII (Reduced Gigabit Media Independent Interface)简化的千兆接口。 SMI（MII管理接口）： 串行管理接口（Serial Management Interface）也被称作MII管理接口（MII Management Interface），包括MDC和MDIO两条信号线。MDIO是一个PHY的管理接口，用来读/写PHY的寄存器，以控制PHY的行为或获取PHY的状态，MDC为MDIO提供时钟。 这次的硬件使用的是RGMII接口： RGMII均采用4位数据接口，工作时钟125MHz，并且在上升沿和下降沿同时传输数据，因此传输速率可达1000Mbps。 PHY层之下是RJ45，RJ45就是我们平常使用的网线水晶头插线口。 以下为MAC和PHY通讯的整体框图 以下为研究代码过程 ZYNQ7020 MAC驱动 在源码包的位置 source_root/drivers/net/ethernet/cadence/
drivers/net/ethernet/cadence/macb_main.c 为MAC驱动代码。
macb_main.c 平台注册到probe执行，在probe中执行了macb_mii_init函数。 /*平台注册*/ static struct platform_driver macb_driver = { .probe = macb_probe, .remove = macb_remove, .driver = { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ee69cf1038e0e41650df677674044f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f7274441e5924ca96f3d08ba2da63cd/" rel="bookmark">
			全国行政区划分简单分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从国家统计局网站（2018年统计用区划代码和城乡划分代码(截止2018年10月31日)）获取了一份省、市、区、镇、村的数据。
数据下载地址(MySQL):https://download.csdn.net/download/luojxun/11188693
1、简单总结一下爬取数据需要注意事项（网上有不少爬取国家统计局的这份数据，下载了好多，要么不全，要么是有错。本文提供的数据核对了一下，没有发现错误。）
i)、网站使用gb2312编码，获取数据时要使用gbk编码，否则一些生僻字就会乱码。
ii)、共有282个市辖区没有下级行政区
SELECT COUNT(*) FROM `city` c LEFT JOIN district d ON c.id = d.city_id WHERE d.name = "市辖区" iii)、有3个城市没有划分区、县，而下级直接是镇。（这是数据爬取的异常情况，忽略这条爬取的数据就容易错。如何判断网上下载的数据是否有错误，挑选下面省市的数据进行核对就很容易发现错误）
SELECT p.name provinceName, c.name cityName FROM province p LEFT JOIN `city` c ON c.province_id = p.id LEFT JOIN district d ON c.id = d.city_id WHERE d.code = 0 广东省东莞市广东省中山市海南省儋州市 2、简单的分析一下数据
i)、除台湾省、香港特别行政区、澳门特别行政区外，有31个省、直辖市、自治区
全国共有：
343个城市
3,285个区、县
43,563个街道、乡、镇、办事处、开发区
666,260个居委会、社区、村
ii)、直辖市有4个
SELECT p.name FROM `province` p LEFT JOIN city c ON c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f7274441e5924ca96f3d08ba2da63cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5091428dfb8358756c704c57816dee67/" rel="bookmark">
			Pytorch学习笔记（I）——预训练模型（九）：ResNet50网络结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VGG VGG11VGG13VGG16VGG19 ResNet ResNet18ResNet34ResNet50ResNet101ResNet152 ResNet( (conv1): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False) (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace) (maxpool): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False) (layer1): Sequential( (0): Bottleneck( (conv1): Conv2d(64, 64, kernel_size=(1, 1), stride=(1, 1), bias=False) (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False) (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5091428dfb8358756c704c57816dee67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f20e536ad6d0ea62aca89cd85d9c71d6/" rel="bookmark">
			网络传输中的校验和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.MAC层的fcs
https://blog.csdn.net/a1414345/article/details/72781130
2.TCP/IP校验和
https://blog.csdn.net/star_xiong/article/details/17303003
3.既然链路层提供了crc校验，为什么还要在网络层帧和传输层数据包中再次提供校验？
因为IP层存在分片，MAC层还会存在帧聚合；所以，数据链路层的CRC校验通过，并不能保证一个IP包的完整性、因为中间也可能存在丢帧，导致不能重组。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/064e0b783ff809c1d875dca2c99a0398/" rel="bookmark">
			MAP的底层原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Map数据结构
Map也是容器的一种，那么我们以前看到的每一种容器，都有响应的数据结构，例如数组是一组连续的存储空间，链表是无序的，包含指针域和值域的容器。
Map的每一个元素叫做键值对，所谓键值对其实就是 “键” 和 “值” 组成的一对。
map的主要实现类是hashmap和treemap,在java开发过程中主要用到的是hashmap。下面简单介绍一下hashmap原理
数组
数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；
链表
链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。
哈希表
那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。
哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— 拉链法，我们可以理解为“链表的数组”
hashmap底层原理
HashMap保存数据的过程为：首先判断key是否为null，若为null，则直接调用putForNullKey方法。若不为空则先计算key的hash值，然后根据hash值搜索在table数组中的索引位置，如果table数组在该位置处有元素，则通过比较是否存在相同的key，若存在则覆盖原来key的value，否则将该元素保存在链头（最先保存的元素放在链尾）。若table在该处没有元素，则直接保存。
hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小×loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16×0.75=12的
时候，就把数组的大小扩展为2×16=32，即扩大一倍，然后重新计算每个元素在数组中的位置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55310e3d3d3dee5920e38ebc5f90e256/" rel="bookmark">
			python 列表推导式if或者多个if_else判断多种情况的列表推导式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 只判断一种情况的列表推导式，如判断是否是偶数： a=[i for i in range(20) if i %2==0] print(a) 输出结果如下：
二、 对于多种情况获得多种结果，if else结构： a=['零' if i==0 else '三' if i==3 else '五' if i==5 else i for i in range(20) ] print(a) 将0,3,5换成中文的零，三，五，输出如下所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eae664e5b60f56b1a72b6113b54e90e/" rel="bookmark">
			Go 并发控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 提到Go语言的并发，就不得不提goroutine，其作为Go语言的一大特色，在日常开发中使用很多。
在日常应用场景就会涉及一个goroutine启动或结束，启动一个goroutine很简单只需要在函数前面加关键词go即可，而由于每个goroutine都是独立运行的，其退出有自身决定的，除非main主程序结束或程序崩溃的情况发生。
那么，如何控制goroutine或者说通知goroutine结束运行呢？
解决的方式其实很简单，那就是想办法和goroutine通讯，通知goroutine什么时候结束，goroutine结束也可以通知其他goroutine或main主程序。
并发控制方法主要有： 全局变量
channel
WaitGroup
context
全局变量 这是并发控制最简单的实现方式
1、声明一个全局变量。
2、所有子goroutine共享这个变量，并不断轮询这个变量检查是否有更新；
3、在主进程中变更该全局变量；
4、子goroutine检测到全局变量更新，执行相应的逻辑。
示例
package main import ( "fmt" "time" ) func main() { open := true go func() { for open { println("goroutineA running") time.Sleep(1 * time.Second) } println("goroutineA exit") }() go func() { for open { println("goroutineB running") time.Sleep(1 * time.Second) } println("goroutineB exit") }() time.Sleep(2 * time.Second) open = false time.Sleep(2 * time.Second) fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5eae664e5b60f56b1a72b6113b54e90e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48f46fc09f8aced50ab564a9ebb9d3bb/" rel="bookmark">
			HTML/CSS自制网页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：作为初学者使用HTML/CSS制作的网页、修改了三次页面、终于修改出了自己满意的效果、三次修改前后的页面会分别展示在下方。然后、我使用的工具是HBuilder软件
观看顺序：顺次往下、就是每次修改后的展示效果
第一次页面：使用了表格布局方式（很老旧的布局方式）、并且代码冗余、夹杂着许多未生效的代码
第二次页面：修改为使用DIV标签对表格布局进行了替换、去除了未生效的代码、对可以合并的代码进行了整合
第三次页面：解决了高度塌陷问题、加入了导航条、对整体宽度进行了修改、发现修改宽度后布局起来轻松了一些
CSS文件代码如下：
.Demo001{ text-align: center; font-family: "agency fb"; color: #FFFAF0; width: 800px; background:black; margin: 10px auto 10px auto; } .Demo002{ text-align: center; width: 800px; list-style: none; overflow: hidden; margin: 0px auto 10px auto; background: black; } .Demo003{ color:black ; letter-spacing: 1px; text-align: center; width: 800px; margin: 0px auto 10px auto; background: #FFE4C4; font: 16px/2.5 "agency fb"; } .Demo004{ color: black; width: 800px; background: #FFE4C4 ; letter-spacing: 1px; text-align: center; margin: 0px auto 10px auto; font: 16px/2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48f46fc09f8aced50ab564a9ebb9d3bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50a96e395e515eed2516b2600b55de3f/" rel="bookmark">
			收藏 | 送你浙大陈华钧教授《知识图谱导论》课程系列PPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：专知
本文约1500字，建议阅读10分钟。
本文为你介绍了浙江大学计算机学院陈华钧教授的课程《知识图谱导论》。
知识图谱是人工智能的前沿科技之一，近两年非常火热。无论你是做计算机的哪个方向，相信在日常的学习和生活中，都能耳濡目染。为了更系统的了解知识图谱，小编找到了浙江大学计算机学院的陈华钧教授开设的《知识图谱导论》课程的ppt，希望能帮助到各位对知识图谱感兴趣的同学。
课程名： 《知识图谱导论》
课程老师：陈华钧
个人主页：https://person.zju.edu.cn/huajun
教师简介
陈华钧，教授、博导。浙江大学阿里巴巴知识引擎联合实验室负责人、浙江省大数据智能计算重点实验室副主任、中国人工智能学会知识工程与分布智能专业委会副主任、中国中文信息学会语言与知识计算专业委员会副主任、中文开放知识图谱OpenKG发起人。主要研究方向为知识图谱、自然语言处理、大数据与知识发现、生物医学信息等。在IJCAI, WWW, KR, ISWC, EMNLP, NAACL, AAAI/IAAI, ICDE, IEEE Magazine on Computational Intelligence, IEEE Intelligent System, IEEE Transaction on Knowledge and Data Engineering, Briefings in Bioinforamtics, BMC Bioinformatics 等国际顶级会议或期刊上发表多篇论文，并曾获国际语义网会议ISWC最佳论文奖。作为负责人主持国家自然科学基金重点项目、国家重点研发计划项目、国家重大科技专项项目及企业合作项目等二十余项。曾获得教育部技术发明一等奖、国家科技进步二等奖等奖励。
课程目录
➤ Lecture 1 : 知识图谱概览 ➤ Lecture 2：知识图谱的表⽰与建模
➤ Lecture 3：知识图谱的存储与关联查询 ➤ Lecture 4：知识图谱构建与关系抽取 ➤ Lecture 5：知识图谱表⽰学习与关联推理 ➤ Lecture 6：语义搜索与知识图谱问答
获取《知识图谱导论》课程PPT, 你可以 后台回复《知识图谱导论》首字母“190519”进行下载
也可以访问陈华钧老师主页并下载
课件展示
-END-
编辑：王菁
校对：王欣
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a99d8887180c563c3eec6e9c953928df/" rel="bookmark">
			Bootstrap&#39;s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bug
Uncaught Error: Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4
Bootstrap.js需要jQuery 1.9.1 版本或更高的版本(但是要低于版本4)。
解决：
替换引用到的jquery为匹配的版本。
&lt;script src="https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"&gt;&lt;/script&gt;
附：Bootstrap支持的jQuery版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de3157ce09eba22f923656990545de24/" rel="bookmark">
			多目标跟踪之LightTrack
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文：LightTrack: A Generic Framework for Online Top-Down Human Pose Tracking
Github: https://github.com/Guanghan/lighttrack
京东的一篇cvpr2019
论文提出了轻量级的多目标跟踪框架LightTrack。包含YOLOV3的目标检测，基于CPN_res101，MSRA152，mobile_deconv这3个网络种任意一个的关键点检测，基于SGCN的人体姿势匹配。整体结构是一种自上而下的结构。
主要贡献：
提出了一个通用的基于自上而下的骨架跟踪框架。提出了SGCN作为一个REID模块进行姿势跟踪。根据各种不同的设置进行了大量的实验。 整体流程：
跟踪过程分为主要帧和次要帧。每隔10帧或者目标跟踪丢失的帧算一个主要帧。
在主要帧中，首先使用YOLOv3进行检测，对检测到的目标进行两边20%的放大。再使用关键点检测模型mobile_deconv获得15个或者17个人体关键点。跟踪匹配过程同时考虑了空间相关性（spatial consistency）和姿势相关性（pose consistency）。然后首先使用IOU进行ID的匹配，如果没有匹配上的返回-1，再使用关键点的特征进行匹配。如果还是没有匹配上，就将该目标的ID+1，作为一个新的目标。
在次要帧中，只通过关键点进行下一帧的关键点预测，具体首先通过之前帧的关键点得到框。然后使用该得到的框进行关键点的预测，会得到预测的结果和得分。最后通过关键点的预测的得分是否小于规定阈值（0.6），来判断目标是否跟踪丢失，如果一直跟踪的，就在图像上画出跟踪的信息，如果跟踪丢失了，就不在图像上画框了。
整体来看，框检测过程只有关键帧才有，关键点检测所有帧都有，SGCN识别过程也只有关键帧才有。
HPE(Human Pose Estimation):
姿态关键点检测部分，作者尝试了CPN_res101，MSRA152，mobile_deconv共3种网络结构。
mobile_deconv的结构：
Top-Down Pose Tracking Framework：
需要重新跟新识别ID的情况：
之前视频中的人消失，或者遮挡新的候选人出现，或者之前视频中消失的人重新出现人走路的时候相互遮挡，被当成了1个人摄像头的抖动或者变焦导致跟踪失败 SGCN（Siamese Graph Convolution Network）：
优势：
SGCN提取的特征具有人体姿势的相关性，并且具备可解释性。并且在边界框有很强的关系，对边界框有直接的强制约束。通过使用人体关键点可以更好的进行跟踪，得到ROI区域。保证了候选区域之间的区分度，可以使用姿势特征做基于骨架的姿势匹配。 网络结构代码，
class Model(nn.Module): r"""Siamese graph convolutional networks Args: in_channels (int): Number of channels in the input data num_class (int): Number of classes for the classification task graph_args (dict): The arguments for building the graph edge_importance_weighting (bool): If ``True``, adds a learnable importance weighting to the edges of the graph **kwargs (optional): Other parameters for graph convolution units Shape: - Input: :math:`(N, in_channels, T_{in}, V_{in}, M_{in})` - Output: :math:`(N, num_class)` where :math:`N` is a batch size, :math:`T_{in}` is a length of input sequence, :math:`V_{in}` is the number of graph nodes, :math:`M_{in}` is the number of instance in a frame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de3157ce09eba22f923656990545de24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b437fad329fe4c29e3e041b0590b96e/" rel="bookmark">
			idea设置maven项目的pom文件默认为jdk1.8版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!-- 让idea的maven项目-pom.xml文件变成jdk1.8的配置 --&gt;
&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt;
--------------------- 作者：郑清 来源：CSDN 原文：https://blog.csdn.net/qq_38225558/article/details/84999872 版权声明：本文为博主原创文章，转载请附上博文链接！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9af6f66c50ca479f0e71e089dc8c14c/" rel="bookmark">
			自制：keras数据集制作与读取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能我是个菜鸡吧，官方keras和tf不会用啊，无奈之下投入了手写生成器的邪教之内，io速率？别问，想哭，不过能跑就ok。
数据集制作也心累的一批，8G小内存如何降的住50+G大数据，哭哭，所以转投了H5邪教，直接把数据封装，自此告别原始数据的水深火热。
不废话，上干货。
H5数据生成器
# -*- coding: utf-8 -*- import os import cv2.cv2 as cv2 from SR.pmbloder import ReadBMPFile import numpy as np import h5py def save_h5(h5f,data,target): shape_list=list(data.shape) if not h5f.__contains__(target): shape_list[0]=None dataset = h5f.create_dataset(target, data=data,maxshape=tuple(shape_list), chunks=True) return else: dataset = h5f[target] len_old=dataset.shape[0] len_new=len_old+data.shape[0] shape_list[0]=len_new dataset.resize(tuple(shape_list)) dataset[len_old:len_new] = data train_path = ''#训练集路径 val_path = ''#测试集路径 def load_image(image_path): merged = #数据获取操作，按需更改 return merged def data_generate(path,flag="train"):#sr问题示例，按需更改 hrpath = path+'/HR' lrpath = path+'/LR' hrlist = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9af6f66c50ca479f0e71e089dc8c14c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aae9ad60804669925c2ba6171228f04/" rel="bookmark">
			MapGis前端开发笔记一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.开发环境：MapGIS IGServer10.0、OpenLayers3
二.需求分析：前端界面的道路网通过捕捉周边的点要素个数，以此作为权重来对道路网进行颜色带的渲染。
三.思路：1.由于路网的线要素较长，故首先要将线要素进行划分，合理来说，应该是按照距离划分的。2.对新的道路做缓冲区分析，缓冲区半径自定义。3.通过缓冲区与周围点要素进行空间查询，得到每个缓冲区查询到的点要素个数。4.将所有的点个数进行数据标准化，设置阈值，进行颜色的渲染。
四.实现：
1.获取道路。通过Zondy.Service.QueryDocFeature()的属性查询方法进行查询，得到发布的mapx文件中所有的线要素，回调函数返回值是个数组，这是中地的要素，要使用var format = new Zondy.Format.PolygonJSON(); var linesFeatureArr= format.read(result);得到ol的feature。
2.生成新道路。通过遍历线要素数组，通过getGeometry()得到线要素的geometry，再通过getCoordinates()得到geometry的节点坐标。通过自己写个小方法去对线要素进行截取，最后得到的是很多个点坐标的数组。
var gLine=new Zondy.Object.GLine( new Zondy.Object.AnyLine([new Zondy.Object.Arc(zondy_pointArr2)]) ); var LinGeom=new Zondy.Object.FeatureGeometry({ LinGeom:[gLine] }); 通过上面这个方法去得到中地的FeatureGeometry，用于做缓冲区。再通过下面这个得到ol的feature，用于添加到地图上。现在，我就得到了两个数组，一个是中地的线要素数组zondyRoadFeatureArr，一个是ol的线要素数组olRoadFeatureArr。
var roadSub_feature=new ol.Feature({ type: 'route', geometry:new ol.geom.LineString(ol_pointArr2) }); 3.生成缓冲区。通过Zondy.Service.FeatureBuffBySingleRing()和zondyRoadFeatureArr生成缓冲区，该缓冲区作为面要素存在hdf里面，返回值里面含有这个面要素的url，url=data.results[0].Value，将所有的缓冲区的url放在一个数组里，bufferUrlArr。
4.查询缓冲区。通过Zondy.Service.QueryLayerFeature和bufferUrlArr查询出缓冲区要素，这个返回值是一个中地的FeatureGeometry。因为要用它作为一个浏览器上绘制的多边形进行查询点要素，所以要将其转换为Zondy.Object.Polygon()。如何转换？
//将中地的要素转换为ol的 var format = new Zondy.Format.PolygonJSON(); var bufferFeature = format.read(result); //将ol的要素转换为中地的polygon var bufferPolygon=new Zondy.Object.Polygon(); bufferPolygon.setByOL(bufferFeature[0].values_.geometry); 得到了一个缓冲区的要素，放到一个数组里，就有了一个缓冲区要素的数组bufferFeatureArr。
5.查询点要素。通过Zondy.Service.QueryDocFeature()和bufferFeatureArr进行查询，返回结果result.TotalCount即是点要素的个数，将其放在一个数组里，就会有一个存到点要素个数的数组ptNumberArr。
4、5.修正！这个时候思路错了！
需求是为了得到各个缓冲区内捕捉到的点的个数，原来的方法是通过矢量图层查询到缓冲区，将其作为几何多边形去向IG Server发送请求，去查询点的个数。这样太笨了！
正确的方法：通过查询，能够得到所有的缓冲区和点的个数，全部转换为ol类型的，然后将缓冲区存到ol的ol.source.Vector里，而该类有个方法叫getFeatureInExtent(extent),即在ol里面，也是支持空间查询的。这样就不需要去请求服务器了，就会快得多，并且后面的密度分析里面同样是这个道理，能够大大提高效率！不过学到的Promise和async function(){await Promise}还是很有用的，虽然走了一些弯路，但是却看到了不一样的风景！
至此，共有5个数组。分别是zondyRoadFeatureArr，olRoadFeatureArr，bufferUrlArr，bufferFeatureArr，ptNumberArr。其中关系是这样的：zondyRoadFeatureArr→bufferUrlArr→bufferFeatureArr→ptNumberArr，而olRoadFeatureArr还没有用上，那么就通过ptNumberArr的索引与olRoadFeatureArr索引一一对应的关系，将其渲染出不同的颜色。
五.遇到的坑：
1.缓存区生产失败。原因：缓冲区执行时候的参数写法错误，注意格式是下面这个样子的，点线面生产缓冲区都要使用Zondy.Object.FeatureGeometry这个类，但是Zondy.Object.GLine、Zondy.Object.GPoint、Zondy.Object.Region这些的格式要注意一下，而这些跟Zondy.Object.PolyLine、Zondy.Object.Polygon是不一样的，前者是复杂的，是里面有很多内容，后者是简单的，只是一个多边形。而在生成缓冲区的时候，需要用前者，在作为绘制多边形查询的时候，比如拉框查询的这个“矩形”，要转换为后者。
var gLine=new Zondy.Object.GLine( new Zondy.Object.AnyLine([new Zondy.Object.Arc(zondy_pointArr2)]) ); var LinGeom=new Zondy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1aae9ad60804669925c2ba6171228f04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cff423f76b1ed522e2e331fd48571558/" rel="bookmark">
			oc笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IBAction 使方法具有控件连线关联功能，空间触发相关事件时调用连线方法，本质为void类型。
IBOutlet 与控件连线关联功能，连线获取storyboard的控件
1、@interface 与@implementation OC中的类必须包括两部分，interface部分和implementation部分，这才是oc中的一个类的完整声明；
OC中将成员变量和成员方法的声明部分放置在interface部分中，包括继承关系，protocal实现关系，都在interface里面的头部进行声明；将实现部分放置在implementation部分中
相当于是将类拆分成声明和实现两部分，这两部分缺一不可，所以在OC中，将interface叫做类声明部分，简而言之，oc中interface是类的一个部分，和implementation共同组成一个完整的类。
interface 定义了类的名称，数据成员，方法 implementation 包含公开方法的实现，定义私有变量和方法
也可以定义实体变量 差别在于访问权限 intercace的默认权限为protected，而后者为private
定义一个新方法时 用：冒号代表参数传递，因此参数可以夹杂于名称中间
2、@property与@synthesize
成对出现的，可以自动生成某个类成员变量的存取方法。在Xcode4.5以及以后的版本，@synthesize可以省略
@synthesize的作用：
1、一个作用就是让编译器为你自动生成setter与getter方法。 2、还有一个作用，可以指定与属性对应的实例变量，
例如@synthesize str = xxx；那么self.str其实是操作的实例变量xxx，而不是_str了。
如果.m文件中写了@synthesize str;那么生成的实例变量就是str；如果没写@synthesize str;那么生成的实例变量就是_str。
(注意：_str这个实例变量是不存在的). 在老式的代码中，@property只能写在@interface @end中，@synthesize只能写在@implementation @end中，自从xcode 4.5及以后的版本中，@property就独揽了@property和@synthesize的功能。
@property (nonatomic, copy) NSString *str;这句话完成了3个功能：1）生成_str成员变量的get和set方法的声明；2）生成_str成员变量set和get方法的实现；3）生成一个_str的成员变量。(注意：这种方式生成的成员变量是private的)
3、atomic与nonatomic
atomic：默认是有该属性的，这个属性是为了保证程序在多线程情况，编译器会自动生成一些互斥加锁代码，避免该变量的读写不同步问题。
nonatomic：非原子性 如果该对象无需考虑多线程的情况，请加入这个属性，这样会让编译器少生成一些互斥加锁代码，可以提高效率
4、readwrite 与readonly readwrite 属性默认 自动生成存取 readonly：只生成getter不会有setter方法。
readwrite、readonly这两个属性的真正价值，不是提供成员变量访问接口，而是控制成员变量的访问权限。
5、getter setter
getter：是用来指定get方法的方法名，以set开头的基本形式 没有返回值，有参数 为实例变量赋值 只有一个参数
setter：是用来指定set访问的方法名，没有参数，有返回值，给实例变量获取值
在@property的属性中，如果这个属性是一个BOOL值，通常我们可以用getter来定义一个自己喜欢的名字，例如：
@property (nonatomic, assign, getter=isValue) boolean value;
@property (nonatomic, assign, setter=setIsValue) boolean value;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cff423f76b1ed522e2e331fd48571558/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/903bfe9e240a844ad13785bf5deea68b/" rel="bookmark">
			CTF密码学常见加密解密总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CTF密码学常见加密解密总结 被实验吧一堆大佬出题人折磨的死去活来的我，嘤嘤嘤。在此做个总结，防止自己忘掉：
由下面这张思维导图进行扩展：
参考:
作者：adversity` 来源：CSDN 原文：https://blog.csdn.net/qq_40836553/article/details/79383488
作者：大龙博客 来源：CSDN 原文：https://blog.csdn.net/gelong_bokewang/article/details/88527929
作者：前端弟弟 来源：CSDN 原文：https://blog.csdn.net/qq_41681743/article/details/82700911
目录 CTF密码学常见加密解密总结编码：1.Base64编码2 . jother编码3. unicode编码4.url编码（十六进制的%编码）5.hex编码核心价值观编码解码16进制转字符串 古典密码——单表替换1.凯撒密码2.仿射密码3.埃特巴什码(Atbash Cipher) 古典密码——多表替换1.playfair密码(Playfair cipher 或 Playfair square)2.棋盘密码（Polybius方表）3.Nihilist 加密法4.Hill密码（希尔密码）4.维吉尼亚密码Autokey Cipher(自动密钥密码)ADFGVX密码词频分析 其他（有些不知道归类到哪，就丢这里啦~）1. Escape加密/UnEscape解密2. eval(function(p,a,c,k,e,d)系列解密javascript程序3.VBScript4.猪圈密码5.手机键盘加密6.QWE密码7.曲路密码8.盲文9.当铺密码10.Brainfuck(BF)11.Ook!12.Piet13种荒谬的编程语言摩斯电码 现代密码学——HashMD5（哈希算法） 现代密码学——非对称密码体系1.RSA2.DSA（Digital Signature Algorithm）ECC（Elliptic Curves Cryptography，椭圆曲线密码编码学）serpent(蛇)加密/解密 现代密码学——对称密码体系AES（Advanced Encryption Standard）1.CBC(Cipher Block Chaining)/密文分组链接方式2.CFB（Cipher Feedback）/ 密文反馈模式3.ECB(Electronic Code Book)/电码本模式4.OFB (Output Feedback)/输出反馈模式DESTEA（Tiny Encryption Algorithm）RC4/5 编码： 1.Base64编码 Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，base64就是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应4个base64单元，即3个字节可表示4个可打印字符。它可用来作为电子邮件的传输编码。
特征：(1)在base64中的可打印字符包括字母A-Z、a-z、数字0-9，+ / =。
(2)永远是4的倍数，不足四的用=补齐。
例如：编码‘Man’
在此例中，base64算法将3个字符编码转为4个字符
base64索引表：
如果要编码的字节数不能被3整除，最后会多出1个或2个字节，那么可以使用下面的方法进行处理：先使用0字节值在末尾补足，使其能够被3整除，然后再进行base64的编码。在编码后的base64文本后加上一个或两个“=”号，代表补足的字节数。也就是说，当最后剩余一个八位字节（一个byte）时，最后6位的base64字节块有四位是0值，最后附加上两个等号；如果最后剩余两个八位字节（2byte）时，最后一个6位的base字节块有两位是0值，最后附加一个等号
例如：
当看到号的加密方式时，可以考虑base64。例：cTZ1NQ解码之后为q5u5。
关于base32：
base32中只有大写字母（A-Z）和数字234567
关于base16：
base16中只有数字0-9以及大写字母ABCDEF
base64编码转图片: 在"data:image/gif;base64,"后加上Base64编码 在线转图片即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/903bfe9e240a844ad13785bf5deea68b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84cb27cfc221b3ba3d46399534856722/" rel="bookmark">
			（二）通过网络获取天气信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个项目的最终目的是实现在ARM板上，使用qt+opencv实现人脸识别的考勤系统。上一次完成了打开摄像头代码，这一次我打算在系统中加入通过网络实时获取当地天气情况的功能。
使用心知天气的API接口实现（免费） 在这里我选择使用心知天气提供的API接口来完成这次任务。JSON格式。
心知天气的官网网址
https://www.seniverse.com
注册登录后，进入控制台，点击我的API项目
记录好自己的API私钥，这里被和谐了，因为私钥是重要的访问密码，最好不要透露出去。
因为是免费用户，所以只有3个API接口可以调用，其他的都不能用，访问频率也被限制到400次/小时，或者20次/分钟。（当然如果你是土豪可以考虑花钱购买）超过了访问频率，服务器将会拒绝你的访问，直到一个小时后再恢复。
然后点击产品文档查看API格式
点击天气现象代码说明这里，下载官方提供的图标，程序中会用到。至于使用哪个图标就看你自己喜好了。
接下来看API调用格式，因为是免费用户，可以使用的三个API分别是天气实况，逐日天气和生活指数。
第一个，天气实况
将这个url地址复制下来，将key=后面的打码部分改为自己的私钥，location=后面的beijing改为ip，其他的不用改。ip的意思是自动根据IP地址定位城市，如果想查询指定的城市，可以通过上面的“接口中的通用参数”了解，这一章对API中的参数设置有详细说明。JSON格式我就不细说了，自己去了解吧。
第二个，逐日天气
把url地址复制下来，参数修改如上。
第三个，生活指数
url地址复制下来。
API接口记录完毕，接下里开始写代码。
Qt重点代码解析 访问API接口，并获取返回的JSON数据 访问网址用到了QT的两个类，QNetworkAccessManager和QNetworkReply
记得包含头文件和在.pro文件中加入network
#include &lt;QtNetwork&gt; #include &lt;QtNetwork/QNetworkAccessManager&gt; #include &lt;QtNetwork/QNetworkRequest&gt; #include &lt;QtNetwork/QNetworkReply&gt; 在.h文件中声明变量，因为有三个地址，我想同时访问，所以每一个都要创建对应的QNetworkAccessManager和QNetworkReply
QNetworkAccessManager *m_NetManger_now; QNetworkAccessManager *m_NetManger_daily; QNetworkAccessManager *m_NetManger_life; QNetworkReply *m_Reply_now; QNetworkReply *m_Reply_daily; QNetworkReply *m_Reply_life; 接着声明槽
private slots: void finishedSlot_now(QNetworkReply*); void finishedSlot_daily(QNetworkReply*); void finishedSlot_life(QNetworkReply*); 在.c的构造函数中加入
url_weather_now = "https://api.seniverse.com/v3/weather/now.json?key=你自己的私钥&amp;location=ip&amp;language=zh-Hans&amp;unit=c"; url_weather_daily = "https://api.seniverse.com/v3/weather/daily.json?key=你自己的私钥&amp;location=ip&amp;language=zh-Hans&amp;unit=c&amp;start=0&amp;days=5"; url_weather_life = "https://api.seniverse.com/v3/life/suggestion.json?key=你自己的私钥&amp;location=ip&amp;language=zh-Hans"; m_NetManger_now = new QNetworkAccessManager; m_NetManger_daily = new QNetworkAccessManager; m_NetManger_life = new QNetworkAccessManager; connect(m_NetManger_now,&amp;QNetworkAccessManager::finished,this,&amp;WeatherWidget::finishedSlot_now); connect(m_NetManger_daily,&amp;QNetworkAccessManager::finished,this,&amp;WeatherWidget::finishedSlot_daily); connect(m_NetManger_life,&amp;QNetworkAccessManager::finished,this,&amp;WeatherWidget::finishedSlot_life); m_Reply_now = m_NetManger_now-&gt;get(QNetworkRequest(url_weather_now)); m_Reply_life = m_NetManger_life-&gt;get(QNetworkRequest(url_weather_life)); m_Reply_daily = m_NetManger_daily-&gt;get(QNetworkRequest(url_weather_daily)); 接着完成槽函数的编写，这里列举一个例子，其他的可以举一反三。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84cb27cfc221b3ba3d46399534856722/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a09db73597df77c5d63e0dfdbf1eea5/" rel="bookmark">
			DDR中的ODT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ODT电阻端接 ODT (on-die termination) 裸片终端（ODT）功能允许DRAM通过ODT控制引脚为x4 / x8配置的每个DQ，DQS / DQS，RDQS / RDQS和DM信号打开/关闭终端电阻。对于x16配置，ODT通过ODT控制引脚应用于每个DQ，UDQS / UDQS，LDQS / LDQS，UDM和LDM信号。
ODT功能旨在通过允许DRAM控制器独立地打开/关闭任何或所有DRAM设备的终端电阻来改善存储器通道的信号完整性。
请注意：
ACTIVE和STANDBY模式支持ODT功能。
在SELF REFRESH模式下，ODT关闭且不受支持。
ODT的功能描述：
DDR的直流标准 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbbf91f6752580bb08448880c4eeddef/" rel="bookmark">
			System.getProperty()方法获取系统属性的值（获取springboot项目下resource目录下的文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本来要上传文件到项目的resources文件夹中，如何获取项目的绝对路径？
于是乎查到了这个
String basePath = System.getProperty("user.dir");
图片来源：https://blog.csdn.net/weixin_37139197
获取springboot项目下resource目录下的文件方法：
File file = null; try { file = ResourceUtils.getFile(ResourceUtils.CLASSPATH_URL_PREFIX + "static/1.gif"); } catch (FileNotFoundException e) { e.printStackTrace(); } 但是打jar包后就无法获取，jar在文件系统中不是文件夹，其内部内容不能使用路径访问，改为流访问：
InputStream is = this.getClass().getResourceAsStream("/static/1.gif"); 根据业务要求判断流是否使用，而我在项目中要使用文件，所以要将流转化为文件。
附一个简单的转化方法，逻辑有了，自行优化：
public static void inputStream2File(InputStream is, File file) throws Exception { OutputStream os = new FileOutputStream(file); int bytesRead = 0; byte[] buffer = new byte[2048]; while ((bytesRead = is.read(buffer, 0, 2048)) != -1) { os.write(buffer, 0, bytesRead); } os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbbf91f6752580bb08448880c4eeddef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15db3125f9252353c4e3e32c2394809c/" rel="bookmark">
			WEB3.0白皮书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I //
Part1 新浪潮
//
那么 Web3.0 究竟是什么?
TA 能给当今世界带来什么变化?
TA 由哪 些技术组成?
如何实现 Web3.0?
TA 能带来哪些机会?
我们能从中得到什么?
Web3.0 是一个非常前沿的话题，充满了不确定性，也没有任何人能准确预测她何时到来，会以何种形式到来。但趋势已现，仅以此文抛 砖引玉，希望与志同道合者一起推动。
Web3.0 也是一个很老的话题，自2006 年以来，Web3.0 一词正受到越来越多的关注，也是越来越多争论的焦点，这个现象一直持续到目前为止。
“人们不停地质问 Web 3.0 到底是什么。我认为当可缩放矢量图形在 Web 2.0 的基础上大面积使用——所有东西都起波纹、 被折叠并且看起来没有棱角——以及一整张语义网涵盖著大量的数据，你就可以访问这难以置信的数据资源。”
—Tim Berners Lee(2006-5)
“Web 1.0 是拨号上网，50K 平均带宽，Web 2.0 是 1M 平均宽带，那 Web 3.0 就该是10M 带宽，全视频的网络，这才感觉像 Web3.0。”
—- Netflix 创始人 Reed Hastings(2006-11)
“(Web 3.0)创建应用程序的方法将不同。到目前为止 Web 2.0 一词的出现主要是回应某种叫做“AJAX”的概念……而对 Web 3.0 我的预测将是拼凑在一起的应用程序，带有一些主要特征:应用程序相对较小、数据处于 Cloud 中、应用程序可以在任何设备上运行(PC 或者移动电话)、应用程序的速度非常 快并能进行很多自定义、此外应用程序像病毒一样地扩散(社交网络，电子邮件等)。”
— 谷歌首席执行官EricSchmidt(2007- 8)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15db3125f9252353c4e3e32c2394809c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d2957ea715c049b5d588f393b79f42f/" rel="bookmark">
			Shamir密钥分享算法简析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述 秘密共享技术是密码学和信息安全的一个重要研究内容，ShamirShamir密钥分享算法最早是由ShamirShamir和BlacklyBlackly在1970年基于LagrangeLagrange插值和矢量方法提出的，其基本思想是分发者通过秘密多项式，将秘密ss分解为nn个秘密分发个持有者，其中任意不少于kk个秘密均能恢复密文，而任意少于kk个秘密均无法得到密文的任何信息。
实际应用 比如在门限体系中，为了保证信息安全性，一个秘密通常不能由单个持有者保存。比如一些重要场所的通行，比如遗嘱的生效等，必须将秘密分由多人保管并且只有当多人同时在场时秘密才能得以恢复。在这些场合，就需要这样一套的密钥分享技术。
算法思路 表示 ShamirShamir密钥共享算法由一个二元数(k,n)(k,n)表示，其中nn表示将明文ss加密为nn个ShadowShadow，kk表示必须至少同时拥有kk个ShadowShadow才能解密获得成明文。
加密 对于待加密的明文s∈ Zps∈ Zp(pp为大素数)，在有限群GF(p)GF(p)任取k−1k−1个随机数a1,a2,…,ak−1a1,a2,…,ak−1，并令a0=sa0=s，从而构造如下的多项式：
对于这个多项式，任取nn个数x1,x2,x3,…,xnx1,x2,x3,…,xn分别带入多项式得到nn个密钥对:
分发给nn个持有者。
解密 假设得到了kk个密钥对{x1,y1}{x2,y2}…{xk,yk}{x1,y1}{x2,y2}…{xk,yk}，我们可以得到如下方程(运算均在GF(p)GF(p))：
由矩阵乘法或者LagrangeLagrange插值法均可求的a0a0即为明文ss。
安全性 由伽罗华域以及矩阵运算的性质可知该算法的安全性是显然的。
补充 当k=nk=n的时候，Shamir算法还有一种用异或运算的实现:任取n−1n−1个随机数(r1,r2,r3,…,rn−1)(r1,r2,r3,…,rn−1),对于明文ss计算
rn=r1⊕r2⊕r3…⊕rn−1rn=r1⊕r2⊕r3…⊕rn−1
这样就可以通过将这nn个数全部进行异或来得到明文，同时，任意一个ShadowShadow都不会泄露有关秘密的任何信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4999c4dc7a8b67c06360292be2ed0d4d/" rel="bookmark">
			Apriltag原理简介及源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 AprilTag视觉定位Python实现AprilTag过程AprilTag边缘检测四边形检测编码与解码 实现代码 AprilTag视觉定位Python实现 AprilTag是一个视觉基准库，在AR，机器人，相机校准领域广泛使用。通过特定的标志（与二维码相似，但是降低了复杂度以满足实时性要求），可以快速地检测标志，并计算相对位置。
官网：https://april.eecs.umich.edu/software/apriltag.html
AprilTag过程 AprilTag内容主要包含三个步骤。
第一步是如何根据梯度检测出图像中的各种边缘。第二步即如何在边缘图像中找出需要的四边形图案并进行筛选，AprilTag尽可能的对检测出的边缘检测，首先剔除非直线边缘，在直线边缘进行邻接边缘查找，最终若形成闭环则为检测到一个四边形。最后一个步便是如何进行二维码编码和二维码解码，编码方式分为三种，其黑边色块长度分别为8，7，6三个色块长度，对于解码内容，要在检测到的四边形内生成点阵列用于计算每色块的值，再根据局部二值模式(Local Binary Patterns)构造简单分类器对四边形内的色块进行分类，将正例色块编码为1将负例色块编码为0，就可以得到该二维码的编码。得到编码以后再与已知库内的编码进行匹配，确定解码出的二维码是否为正确。 AprilTag边缘检测 对于第一步来说，最主要的功能就是寻找图像中的边缘，原文章使用的是局部二值模式，但是实际使用中，我建议可以使用Canny算子方法，虽然检测出的边缘会减少，但是相应的也降低了图像中的噪点。
四边形检测 对于得到的二值化边缘图像，需要对其进行多边形分析，首先运用
边缘结构分析(Topological structural analysis of digitized binary images)查找多边形，该方法用于确定二值图像边缘的围绕关系，即确定外边缘，内边缘以及它们之间嵌套关系，确定的边缘都与原图都有相对应的关系，因此完全可以用边缘来表示原图。该算法采用编码的思想，首先赋予不同的边缘以不同的编码值，这样方便确认多边形的层次关系。算法从起点开始，编辑边缘的像素，寻找该起始点同类的边缘点，当扫描至起始点时，该多边形闭环形成，切换至下一个起始点重复该操作，直到所有的二值点都被遍历，排除边数小于4的，将满足条件的进行进一步处理。
利用多边形凸包寻找算法(Finding the convex hull of a simple polygon)，计算每一个多边形本身的凸包，并求凸包及其多边形的面积，将两个面积进行比较，当多边形面积比凸包大时将该多边形排除，这样子可以有效的排除非凸多边形，以及不满足多边形面积与凸包面积之比大于0.8的多边形，保留满足条件的其余多边形。
对于最终满足条件的多边形，使用道格拉斯-普克算法(Douglas-Peucker algorithm)进行四边形逼近。
1 寻找曲线的两个端点A，B，作曲线间的弦即线段AB。 2 求线段AB到曲线上的距离最远的点C，并求其间的距离d。 3 将该距离d与提前设定的阈值进行比较，如果小于阈值，就可直接将该直线近似为曲线，该段曲线处理完毕。 4 如果距离d大于给定的阈值，用点C将曲线分割成为AC与BC，并分别对两段取线进行1至3的处理。 5 当所有曲线都处理完毕时，依次连接各个分割点形成的折线，这样就可将处理前的曲线近似成为直线，排除该情况下顶点数不为4的多边形。 图中表示的就是经过筛选后得到四边形的整个过程。
编码与解码 在上一步检测出的四边形并不一定满足我们的要求，所以需要对上一步得到的四边形进行编码，匹配，检查。对于得到的四边形，首先要确定其内部的点阵，上一步的四边形是以四个顶点的形式进行存储的，根据这四个点可以确定其四边形内的点阵的具体坐标，不同编码方式其点阵的个数不相同(根据选择编码方式不同有 8 ∗ 8 , 7 ∗ 7 , 6 ∗ 6 8*8,7*7,6*6 8∗8,7∗7,6∗6可选)，其编码方式由使用者对物体进行标定时确定，根据编码方式的不同，生成不同的内点坐标。以图\ref{矩形编码}所示举例，该二维码的边长为6个黑边，其中的有效编码区域是除去外部黑边的 4 ∗ 4 4*4 4∗4的部分，该部分区域有黑有白，用于二维码的编码。
具体的编码方式如下：
在确定的四边形中明确点阵坐标，在灰度图像中提取点阵的最外围一圈的像素的平均值Value1，再提取点阵次外外围一圈的像素的平均值Value2，根据AprilTag本身的二维码库的设计，四边形最外一层的虽有点的灰度值都是黑色的，而此外层的灰度值是黑色与白色混合，因此在同一光照环境下，Value1和Value2有明显的阈值分界线，确定阈值为Value1与Value2的均值，重新遍历整个点阵所有点坐标的像素值高于阈值的部分编码为0，低于阈值的部分编码为1，见图\ref{图片点阵}。如此以来，从第一行开始进行编码，直至整个点阵被编码完成，将编码排列起来会得到一串二进制码，该二进制码的长度由具体的编码方式决定（分为36，25，16三种），每个四边形都能得到一串二进制码，该码表示该状态下二维码的编码，错误的四边形往往会生成错误的编码，错误编码无法在阈值范围内匹配到相应的ID，故可以轻松的排除错误编码的四边形，对得到的四边形进行编码并进行匹配校验是重要的一个过程。
进一步确定编码是否可靠，要与已知的编码库进行匹配，由于观察到的编码存在旋转的情况，所以应先将得到的编码进行三次90°旋转共得到四个方向上的编码，再逐一与编码库进行比较，求解编码之间的汉明距离(Hamming Distance，汉明距离是表示两个二进制编码之间的相似程度的一种距离，汉明距离是两个长二进制串之间位数不相同的个数。当观察编码与已知库里的某一编码的汉明距离小于给定的阈值时(一般为2)，就确定该观察编码的ID为与之匹配的编码库里的ID，并记录下该汉明距离，若编码库并没有一个与之匹配就确定该观察编码有误，则舍弃该编码对应的四边形。
经过上述的筛选与验证，至此观察编码的ID以及编码的旋转已经可以确定，便可计算该二维码的其他参数，包括二维码相对于原二维码的旋转方位，观察二维码与匹配二维码的相似程度，其中主要为二维码的单线性变换矩阵(Homography Matrix)}，在计算机领域中的针孔相机模型下，同一个张图形在不同空间内都有相关性，单线性变换就是将这个图片在该空间下映射至另一个与之对应的空间下，单线性变化矩阵就是这种映射矩阵且可分解出寻转矩阵与平移矩阵，根据上一个步骤求出的四个顶点的坐标即可求出相对于原始坐标的单线性变换矩阵，利用单线性变换矩阵结合多相机的信息，可以得到二维码的相关姿势信息。分解该矩阵就可求出旋转变换向量rvec以及平移变换向量tvec，对于得到的旋转向量，可以根据该向量求得二维码的正确姿势。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4999c4dc7a8b67c06360292be2ed0d4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fa49b56fb824fdc73928a01925b7c73/" rel="bookmark">
			用户敏感信息掩码工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际开发中，用户/客户敏感数据（如手机号、姓名、身份证号码等）打印输出的时候，为了保护用户隐私，通常需要将其转换为掩码”*“处理，下面分享一个掩码工具类，希望能给大家提供参考。
工具类 /** * */ package com.aiait.es.util; import org.apache.commons.lang3.StringUtils; /** * @author Zhenyu,Chen * */ public class MaskUtil { /** * 手机号显示首3末4位，中间用*号隐藏代替，如：188****5593 * * @param mobile * @return */ public static String maskMobile(String mobile) { if(StringUtils.isBlank(mobile) || mobile.length() &lt;= 8) { return mobile; } return wordMask(mobile, 3, 4, "*"); } /** * 电话号码显示区号及末4位，中间用*号隐藏代替，如：055****6666 * * @param telephone * @return */ public static String maskTelephone(String telephone) { if(StringUtils.isBlank(telephone)) { return telephone; } String result; if (telephone.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fa49b56fb824fdc73928a01925b7c73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1f0af0354c5da39a83203a1e283957c/" rel="bookmark">
			BLE蓝牙主机和从机的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BLE蓝牙的角色有以下几种：广播者（Advertise）、扫描者（Scanner）、从设备（Slave）、主设备（Master）、发起者（Initiator）,其中主设备是由发起者、扫描者转化而来，从设备则是由广播者转化而来；蓝牙模块通信是指两个蓝牙模块或蓝牙设备之间进行通信，进行数据通信的双方一个是主机，一个是从机。
主设备模式：工作在主设备模式,可以与一个从设备进行连接。在此模式下可以对周围设备进行搜索并选择需要连接的从设备进行连接。理论上，一个蓝牙主端设备，可同时与7个蓝牙从端设备进行通讯。一个具备蓝牙通讯功能的设备， 可以在两个角色间切换，平时工作在从模式，等待其它主设备来连接，需要时，转换为主模式，向其它设备发起呼叫。一个蓝牙设备以主模式发起呼叫时，需要知道对方的蓝牙地址，配对密码等信息，配对完成后，可直接发起呼叫。
从设备模式：工作在从机模式下的蓝牙模块只能被主机搜索，不能主动搜索。从设备跟主机连接以后，也可以和主机设备进行发送和接收数据。
主模式与从模式的区别：主机是指能够搜索别人并主动建立连接的一方，从机则不能主动建立连接，只能等别人连接自己。
（上述文章阐述归伦茨科技公司所有，转载请注明出处，更多相关信息欢迎关注微信公众号：lenze_tech或微信号：lenzetech）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/259ff56090255014235622460e52e009/" rel="bookmark">
			tkinter让用户选择文件并返回可读取文件绝对地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里我们import tkinter.filedialog
import tkinter.filedialog import tkinter as tk 然后我们编写函数用于用户选择文件并获得文件地址
def selectPath(self): #选择文件path_接收文件地址 path_ = tkinter.filedialog.askopenfilename() #通过replace函数替换绝对文件地址中的/来使文件可被程序读取 #注意：\\转义后为\，所以\\\\转义后为\\ path_=path_.replace("/","\\\\") #path设置path_的值 path.set(path_) 编写tkinter界面并把函数绑定上按钮
main_box=tk.TK() #变量path path = tk.StringVar() #输入框，标记，按键 tk.Label(main_box,text = "目标路径:").grid(row = 0, column = 0) #输入框绑定变量path tk.Entry(main_box, textvariable = path).grid(row = 0, column = 1) tk.Button(main_box, text = "路径选择", command = selectPath).grid(row = 0, column = 2) main_box.mainloop() 这样就可以实现让用户选择文件了，并且选择后path接受到的值为程序可识别的
下为运行演示不包括菜单
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35177f11807fbe55a3f06c17bf0869b8/" rel="bookmark">
			配置httpd网站服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置httpd网站服务 问题 默认安装的httpd服务并未指定域名，因此启动服务时会出现“httpd: Could not reliably determine the server’s fully qualified domain name, using 127.0.0.1 for ServerName”的异常信息，本例中要求将Web网站的名称设置为svr5.tedu.cn。
另外，公司将要部署的动态网站采用的是PHP网页程序，需要将访问网页目录时的索引文件设为index.php。由于网站目录希望能通过FTP方式远程维护，还需要将其部署到/var/ftp/目录下。
方案 沿用上篇博客快速搭建web的配置，通过调整httpd服务器的配置，实现以下目标：
将网站名称设置为 svr5.tedu.cn
将 index.php 作为访问网页目录时第一个查找的网页文件（即默认首页）
将默认网站根目录迁移到 /var/ftp/
步骤 实现此案例需要按照如下步骤进行。
步骤一：将网站名设置为 svr5.tedu.cn
1）验证未设置网站名称时的效果
[root@svr5 ~]# service httpd restart //重启httpd服务 停止 httpd： [确定] 正在启动 httpd：httpd: apr_sockaddr_info_get() failed for svr5 httpd: Could not reliably determine the server's fully qualified domain name, using 127.0.0.1 for ServerName [确定] 2）修改httpd.conf配置文件，启用并调整ServerName行
[root@svr5 ~]# vim /etc/httpd/conf/httpd.conf .. .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35177f11807fbe55a3f06c17bf0869b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/497856ab7eb38dc851e115c0bb61e638/" rel="bookmark">
			使用python实现阿里云动态域名解析DDNS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 前置条件 1、域名是在阿里云购买的
2、地址必须是公网地址，不然加了解析也没有用
简介 通过阿里云提供的SDK，然后自己编写程序新增或者修改域名的解析，达到动态解析域名的目的；主要应用于pppoe拨号的环境，比如家里设置了服务器，但是外网地址经常变化的场景；再比如公司的pppoe网关，需要建立vpn的场景。
安装阿里云SDK 需要安装两个SDK库，一个是阿里云核心SDK库，一个是阿里云域名SDK库；
阿里云核心SDK库：pip install aliyun-python-sdk-core
阿里云域名SDK库：pip install aliyun-python-sdk-domain
阿里云SDK帮助
关于调试 阿里云提供一个在线调试，支持在线调试好之后，再复制回来本地即可。使用调试平台需要先登录。在线调试平台
API的模块名称都可以通过帮助文档查询
设计思路 一、获取阿里云的accessKeyId和accessSecret
二、获取外网ip
三、判断外网ip是否与之前一致
四、外网ip不一致时，新增或者更新域名解析记录
详细步骤 获取accessKeyId和accessSecret 可以在阿里云控制台个人中心直接获取，但是一般建议使用RAM角色来进行权限控制，这样这个accessKey和accessSecret就只能操作域名，不能操作其他的资源，相对会比较安全。关于RAM快速入门，请点击链接
获取到accessKeyId和accessSecret之后，填入相对应的函数中即可：
from aliyunsdkcore.client import AcsClient from aliyunsdkcore.acs_exception.exceptions import ClientException from aliyunsdkcore.acs_exception.exceptions import ServerException from hwx_function import * import os import time client = AcsClient('&lt;accessKeyId&gt;', '&lt;accessSecret&gt;', 'cn-hangzhou') 获取外网IP 通过网络上面的外网ip的API获取，可以使用多个，我这里只是列举了一个，具体代码如下：
def get_internet_ip(): with urllib.request.urlopen('http://www.3322.org/dyndns/getip') as response: html = response.read() ip = str(html, encoding='utf-8').replace("\n", "") return ip 判断IP是否一致 因为阿里云不允许修改相同的解析，所以需要比对IP是否一致；因为把上一次解析的IP写入文件，所以只需要读取出来，跟本次得到的外网IP相比较，一致则不修改解析记录，不一致则修改解析记录。关于域名解析操作的代码，下面会有解释。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/497856ab7eb38dc851e115c0bb61e638/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a63f1c77e954678812ea3394e2a91089/" rel="bookmark">
			数据分析统计学基础之数据的趋势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据的趋势 一.数据的集中趋势 集中趋势又称“数据的中心位置”、“集中量数”等。它是一组数据的代表值.数据的集中趋势就是一组数据向数据的中心值靠拢的程度。
集中趋势是统计学中的重要统计分析指标，常用的有平均数，中位数和众数等。
1.1平均数 平均数为集中趋势的最常用测度值，目的是确定一组数据的均衡点。用平均数表示一组数据的情况，有直观、简明的特点，所以在日常生活中经常用到，如平均的速度、平均的身高、平均的产量、平均的成绩等。
不是所有类型的资料都能使用平均数。平均数适合用于数值型数据，不能用于分类数据和顺序数据。
1.1.1 算术平均数 一组样本的和除以该样本的数量，记作
x ˉ = x 1 + x 2 + ⋯ + x n n {\bar {x}}={\frac {x_{1}+x_{2}+\cdots +x_{n}}{n}} xˉ=nx1​+x2​+⋯+xn​​
在实际工作中,很少使用算术平均数,因为并不准确,特别是有异常值存在的时候,受极值的影响较大.
1.1.2 加权算术平均数 是具有不同权重的数据的算术平均数，记作
x ˉ = x 1 f 1 + x 2 f 2 + ⋅ ⋅ ⋅ + x n f n f 1 + f 2 + ⋅ ⋅ ⋅ + f n = ∑ x f ∑ f \bar{x}=\frac{x_1f_1+x_2f_2+···+x_nf_n}{f_1+f_2+···+f_n}=\frac{\sum xf}{\sum f} xˉ=f1​+f2​+⋅⋅⋅+fn​x1​f1​+x2​f2​+⋅⋅⋅+xn​fn​​=∑f∑xf​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a63f1c77e954678812ea3394e2a91089/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/406/">«</a>
	<span class="pagination__item pagination__item--current">407/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/408/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>