<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c207d7ada264f244f5603336fa53fa6d/" rel="bookmark">
			http://caomaoav.top/index.php,hkfeed-dev/2014-11-04-passwords.txt at master · threatbot/hkfeed-dev ·...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		~!@#$%^&amp;
~!@#$%^&amp;*()
_
-
!@#$%^
!@#$%^&amp;
@#$%^&amp;
@#$%&amp;
00
00000
000000
00000000
001xiaoqiang
0061qiqi
0085288
0.123
0.1234
012345
0123456
01234567
0123456789
01280128
0147
0321
0557wuchenli
06102012
0727527122
09iis
0p9o8i7u
!@#!@#1
1~
1000
100380
1008
10086
1020
102030
1029384756
110028
110110
110.142!@#$
1111
11111
111111
111111!
11111111
111111q
111213141516
111888ss
111999111999
111aA,
1.11E+12
1+1=2
112.22!@#$
112233
11223311
11223344
1122334455
112233q
112233ss
1123448049
112.34!@#asd
112.44!@#$
112.50!@#$
1149051160
1179558756xm
119584456
11qq..
120.12!@#$
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c207d7ada264f244f5603336fa53fa6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/348aa0cb48b839d297e667f3ac39d5a7/" rel="bookmark">
			注册表方法删除WINDOWS右键多余扩展项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注册表方法：必须要非常确定某个文件就是你想要删除的文件（比如带有Q Q \bai du yun字眼），建议先去系统盘搜索文件名，确定文件的出处，再做删除；在不确定的情况下删除之前，要先进行注册表备份，以免出系统状况再进行恢复。（已经按照2、3步骤尝试成功了，4、5还没试。）
步骤：
1、按 Win + R 组合键（或在“开始”菜单搜索“运行”），打开“运行”-输入“regedit”-打开注册表编辑器。
2、删除桌面右键菜单中无用的扩展项：
展开[HKEY_CLASSES_ROOT\Directory\Background\shell]，在其中找到你想要删除的菜单，删除即可。
3、清除其他右键菜单中多余项：
1）展开[HKEY_CLASSES_ROOT＼*＼shellex＼ContextMenuHandlers] 分支，找到要删除的无用项，然后根据关键字删除需要清除的右键菜单项即可。
2）对于仅在文件夹右键菜单中才有的选项，可到 [HKEY_CLASSES_ROOT＼Direclory＼shell]和 [HKEY_CLASSES_ROOT＼Directory＼shellex＼ContextMenuHandlers] 分支下查找。
有时 ，
[HKEY_CLASSES_ROOT＼Folder＼shell]和 [HKEY_CLASSES_ROOT＼Folder＼shellex＼ContextMenuHandlers] 分支下也有右键菜单中的选项。
4、折叠右键二级菜单：
有些软件在右键菜单中有多个命令选项，比如安装WinRAR后，就有数个项目会附加到标准文件和文件夹的右键菜单中。以下设置能够将WinRAR右键菜单全部项目压缩到“WinRAR”子菜单中(操作以WinRAR3.30为例)：在WinRAR主窗口，单击“选项”菜单中的“设置”，单击“综合”选项卡，选中“层叠右键关联菜单”复选框，单击“确定”按钮。如果你的电脑右键菜单还有其他软件的多个选项，就由你自己研究将它们组合为右键子菜单的方法吧！
5、清除任何显卡生成的桌面右键菜单方法修改注册表文件：
依次单击展开“HKEY_CLASSES_ROOT\\Directory\\Background\\shellex\\ContextMenuHandlers”键值，删除其中的“igfxcui”键（这个是显卡的），然后重新启动系统或者注销即可删除桌面菜单上的那三个选项。基本是保留个new就好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f59dd8d05ee3c8370bf129f5f2f48e4f/" rel="bookmark">
			Java中方法的重载与重写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法的重载和重写在面试中经常会出现，所以我的学习笔记希望可以帮到你，有错误处烦请指正。 一、二者的定义和代码的一些细节 1.1方法的重载Overload 同一个类中可以存在同名的方法。那么如何区分他们呢，如我们所知方法的括号中是方法的参数（空括号时为空参方法）。由于形参列表的不同，当调用方法时括号内的参数列表不同，调用相对应的方法。这些不同形参列表的方法，就构成了方法的重载。
1.1.1重载的好处 方便方法有不同参数需求时的使用
1.1.2代码例子 public class test { public static void main(String[] args) { testOverride test = new testOverload(); //测试空参方法 test.testFuction(); //测试含参方法 test.testFuction(12); } } class testOverload{ //类的属性 private int id; //类的getter and setter public int getId() { return id; } public void setId(int id) { this.id = id; } //空参方法 public void testFuction() { System.out.println("这是空参方法"); } //单参数方法 public void testFuction(int id) { setId(id); System.out.println("这是含参数的方法，传入参数为id: " + getId()); } } 运行结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f59dd8d05ee3c8370bf129f5f2f48e4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88edeff4d2f6f67811f32d7456169445/" rel="bookmark">
			Qualcomm Snapdragon Profiler使用教程(4)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qualcomm Snapdragon Profiler使用教程（4） 1快照捕捉1.1其他要求1.2启动应用程序1.3快照捕获基础1.4 Vulkan快照捕获 1快照捕捉 如下图所示，快照捕获模式允许捕获图形应用程序的单个帧。 快照捕获详细显示了如何在CPU上渲染场景。
在“快照捕获”中，选择一个过程以查看可用的指标。 然后选择指标以查看快照。 捕获帧后，查看捕获的数据并逐步进行帧渲染逐个绘制调用。
1.1其他要求 OpenGL ES和Vulkan应用程序都必须在该应用程序的AndroidManifest.xml中包含android.permission.INTERNET和android.permission.WRITE_EXTERNAL_STORAGE。
如果要在Vulkan应用的“着色器分析器”面板中查看SPIR-V组件，请在主机上安装Android NDK版本13b或更高版本，并在File &gt; Settings &gt; Android &gt; Android NDK Location中设置其位置。
1.2启动应用程序 “快照捕获”面板中的“启动应用程序”按钮可用于启动目标设备上安装的任何应用程序。 使用此按钮的含义取决于正在启动的应用程序的类型。
必须使用按钮启动Vulkan应用程序以启用Vulkan快照的捕获。使用OpenGL ES应用程序的按钮将使Snapdragon
Profiler加载其OpenGL API拦截器库的最新版本，这将启用最佳捕获功能。 在不使用按钮的情况下在设备上启动OpenGL
ES应用程序时，将使用设备上预安装的API拦截器库。 根据该库的使用期限，它可能会缺少功能或包含当前版本中已修复的错误。所有其他应用程序的行为均相同，无论它们是从设备启动还是通过按钮启动。 使用“启动应用程序”按钮启动应用程序将利用Java调试线协议。 因此，建议在使用此功能时禁用其他使用JDWP的调试和性能分析工具。
1.3快照捕获基础 检查Android设备是否已连接到安装了Snapdragon Profiler的计算机，然后启动Profiler。 注意：Snapdragon Capture模式当前仅在具有Qualcomm Snapdragon 805（或更高版本）处理器和Android 6.0（或更高版本）的移动设备上起作用。 选择File &gt; Connect，或从“Start Page”中单击“ Connect to a Device”以连接到设备以启动会话。在“Start Page”上，单击“ New Snapshot Capture”，或选择Capture &gt; New Snapshot。将显示一个新的“快照”选项卡：
从“Snapshot”选项卡中，滚动浏览“Data Sources”列表，然后选择一个过程。该流程可用的度量标准显示在左下方的“Processes”列表中。
注意：尚不支持针对计算缓冲区和辅助命令缓冲区的Vulkan Snapshot指标。 单击度量以查看快照，然后单击“ Take Snapshot”以捕获框架。橙色栏表示Profiler正在检索快照。捕获后，查看捕获的数据并逐步进行帧绘制drawcall-by drawcall。
注意：可以在一个会话中拍摄多个快照。 但是Pixel History, Drawcall Replay, Frame Statistics仅适用于最新的快照捕获。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88edeff4d2f6f67811f32d7456169445/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcaddfe12fb7cce527147f4cecb7192a/" rel="bookmark">
			随笔：ubuntu启动慢，检查启动项，缩短启动时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随笔：ubuntu启动慢，检查启动项，缩短启动时间
ubuntu开机慢，检查开机启动项，以及各项所占用的时间，命令：
systemd-analyze blame 一般是networking.service耗时长。详细情况还是查看上面命令输出结果。
以下是解决networking.service耗时长的方法，输入命令：
/lib/systemd/system/networking.service
sudo vim /lib/systemd/system/networking.service 在文件中，找到TimeoutStartSec（最后一行），将其值修改为=10s（原为5min）即可
TimeoutStartSec=10s
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/219b25dbc24d2e6597be102217ceafdf/" rel="bookmark">
			Python图像处理（七）——图像阈值化处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、阈值化 图像的二值化，就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的只有黑和白的视觉效果。
一幅图像包括目标物体、背景还有噪声，要想从多值的数字图像中直接提取出目标物体，常用的方法就是设定一个阈值T，用T将图像的数据分成两部分：大于T的像素群和小于T的像素群。这是研究灰度变换的最特殊的方法，称为图像的二值化（Binarization）。
当灰度Gray小于阈值T时，其像素设置为0，表示黑色；当灰度Gray大于或等于阈值T时，其Y值为255，表示白色。
Python OpenCV中提供了阈值函数threshold()实现二值化处理,其公式余参数如下所示：
retval, dst = cv2.threshold(src, thresh, maxval, type)
参数：
retval：阈值 dst： 处理结果 src：原图像 thresh：阈值 maxval：最大值 type：类
method阈值类型一般分为五种：
cv2.THRESH_BINARY——大于阈值的部分像素值变为最大值，其他变为0 cv2.THRESH_BINARY_INV——大于阈值的部分变为0，其他部分变为最大值 cv2.THRESH_TRUNC——大于阈值的部分变为阈值，其余部分不变 cv2.THRESH_TOZERO——大于阈值的部分不变，其余部分变为0 cv2.THRESH_TOZERO_INV——大于阈值的部分变为0，其余部分不变 二、二进制阈值化 首先设置一个阈值，例如80，则大于等于80的像素点的灰度值设定为最大值，灰度值小于80的像素点的灰度值设定为0
关键字为 cv2.THRESH_BINARY
代码如下：
import cv2 #读取图片 image = cv2.imread("E:/pythonProject/xin.jpeg") image1 = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) #阈值处理 retval, dst = cv2.threshold(image1, 80, 255, cv2.THRESH_BINARY) #图像显示 cv2.imshow("image", image) cv2.imshow("dst", dst) #等待窗口 cv2.waitKey(0) cv2.destroyAllWindows() 输出结果如下所示：
三、反二进制阈值化 该方法与二进制阈值化方法相似，先要选定一个特定的灰度值作为阈值，比如80。大于80的像素点的灰度值设定为0，小于该阈值的灰度值设定为255。
关键字为 cv2.THRESH_BINARY_INV
代码如下所示：
import cv2 #读取图片 image = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/219b25dbc24d2e6597be102217ceafdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a29c25edc9d23704d6c168a990fbeadc/" rel="bookmark">
			vscode写python时的错误提示和自动格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）在VScode中打开设置，搜索python.linting.flake8enabled
（2）在Settings界面中勾选Whether to lint Python files using flake8
（3）打开终端，下载flake8（错误提示）和autopep8（自动格式化）
pip install flake8, autopep8 安装完成后，重启vscode，右键选择自动格式化，ctrl+s保存，那些因为没有遵循pep8格式而报错的红线就会消失。
（4）更改flake8对于line too long的限制，在settings中修改下面内容
"python.linting.flake8Args": ["--max-line-length=248"] （5）最近又出现了flake8不起作用的问题，就是无法检测出代码中的错误，一怒之下pip install pylint把错误提示器改成pylint又好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a58b75fbfc1e09f1932a46a8c34fa4d/" rel="bookmark">
			滚动加载数据 php,无刷新动态加载数据 滚动条加载适合评论等页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		滚屏加载更多数据,适合评论等页面
本例的数据库很简单，一看就明了
$query=mysql_query("select * from content order by id desc limit 0,10");
while ($row=mysql_fetch_array($query)) {
?&gt;
js文件
$(function(){
var winH = $(window).height(); //页面可视区域高度
var i = 1;
$(window).scroll(function () {
var pageH = $(document.body).height();
var scrollT = $(window).scrollTop(); //滚动条top
var aa = (pageH-winH-scrollT)/winH;
if(aa&lt;0.02){
$.getJSON("result.php",{page:i},function(json){
if(json){
var str = "";
$.each(json,function(index,array){
var str = "
"; var str = str + "
"+array['date']+" "; var str = str + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a58b75fbfc1e09f1932a46a8c34fa4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5016444aee5d455423c327a64faca04c/" rel="bookmark">
			后台LocalDateTime参数的接收问题（Failed to convert value of type ‘java.lang.String‘ to required type ‘java.tim
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后台LocalDateTime参数的接收问题（Failed to convert value of type ‘java.lang.String’ to required type ‘java.time.LocalDateTime’） 使用postman测试接口时，发现传递的时间不能够被后端获取，其中postman请求的截图如下：
controller层接口的方法为：
报错如下：
解决方法： 通过@DateTimeFormat注解，去解析前端传入的时间格式字符串然后转化成LocaDateTime的时间类型。注意：格式化的时候，格式需要和前台传入值得格式一致，并且看清楚参数类型到底是LocalDateTime还是LocalTime 顺便说一下，@JsonFormat：他和@DateTimeFormat正好对应关系，如果我们从DB中取得时间类型数据，想传回前端，并且规定格式，那么就可以使用@JsonFormat(pattern=“yyyy-MM-dd”,timezone = “GMT+8”)
pattern:是你需要转换的时间日期的格式
timezone：是时间设置为东八区，避免时间在转换中有误差
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fca906a763aef1aacdd32915c95d2c29/" rel="bookmark">
			【转】IDEA类和方法注释模板设置（非常详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA自带的注释模板不是太好用，我本人到网上搜集了很多资料系统的整理了一下制作了一份比较完整的模板来分享给大家，我不是专业玩博客的，写这篇文章只是为了让大家省事。
这里设置的注释模板采用Eclipse的格式，下面先贴出Eclipse的注释模板，我们就按照这种格式来设置：
类注释模板： 方法注释模板：
一、首先我们来设置IDEA中类的模板：（IDEA中在创建类时会自动给添加注释）
1、File--&gt;settings--&gt;Editor--&gt;File and Code Templates--&gt;Files
我们选择Class文件（当然你要设置接口的还也可以选择Interface文件）
（1）${NAME}：设置类名，与下面的${NAME}一样才能获取到创建的类名
（2）TODO：代办事项的标记，一般生成类或方法都需要添加描述
（3）${USER}、${DATE}、${TIME}：设置创建类的用户、创建的日期和时间，这些事IDEA内置的方法，还有一些其他的方法在绿色框标注的位置，比如你想添加项目名则可以使用${PROJECT_NAME}
（4）1.0：设置版本号，一般新创建的类都是1.0版本，这里写死就可以了
2、效果图展示
二、设置方法注释模板
IDEA还没有智能到自动为我们创建方法注释，这就是要我们手动为方法添加注释，使用Eclipse时我们生成注释的习惯是
/**+Enter，这里我们也按照这种习惯来设置IDEA的方法注释
1、File--&gt;Settings--&gt;Editor--&gt;Live Templates
（1）新建组：命名为userDefine
（2）新建模板：命名为*
因为IDEA生成注释的默认方式是：/*+模板名+快捷键（比如若设置模板名为add快捷键用Tab，则生成方式为
/*add+Tab），如果不采用这样的生成方式IDEA中没有内容的方法将不可用，例如获取方法参数的methodParameters(）、
获取方法返回值的methodReturnType(）
（3）设置生成注释的快捷键
（4）设置模板：模板内容如下
注意第一行，只有一个*而不是/*
在设置参数名时必须用${参数名}$的方式，否则第五步中读取不到你设置的参数名
* * @Author $NAME$ * @Description //TODO $end$ * @Date $time$ $date$ * @Param $param$ * @return $return$ **/ 如果使用/*生成的模板注释将会是如下效果：所以我们要去掉最前面的/*
（5）设置模板的应用场景
点击模板页面最下方的警告，来设置将模板应用于那些场景，一般选择EveryWhere--&gt;Java即可
（如果曾经修改过，则显示为change而不是define）\
（6）设置参数的获取方式
选择右侧的Edit variables按钮
PS:第五步和第六步顺序不可颠倒，否则第六步将获取不到方法
选择每个参数对应的获取方法（在下拉选择框中选择即可），网上有很多教程说获取param时使用脚本的方式，我试过使用脚本
的方式不仅麻烦而且只能在方法内部使用注释时才能获取到参数
（7）效果图
创建方法，在方法上面写：/*+模板名+Enter--&gt;/**+Enter
————————————————
版权声明：本文为CSDN博主「吃货刘小念」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/xiaoliulang0324/article/details/79030752
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6430e0d745348648f659088b71b691ac/" rel="bookmark">
			php中数字可以加字符吗,字母数字在PHP中增加一个字符串(到一定长度)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标签：php
我需要使用字母数字增量器生成一个序列(或函数来获取“下一个id”).
字符串的长度必须是可定义的,字符必须是0-9,A-Z.
例如,长度为3：
000
001
002
~
009
00A
00B
~
00Z
010
011
etc..
所以我想这个函数可能会像这样使用：
$code = '009'
$code = getNextAlphaNumeric($code);
ehco $code; // '00A'
我自己正在努力解决这个问题,但很奇怪,如果有人之前已经解决了这个问题,并想出一个比我自己更聪明/更强大的解决方案.
有没有人有一个很好的解决这个问题的方法？
解决方法:
像base_convert这样的东西会起作用吗？也许沿着这些方向(未经测试)
function getNextAlphaNumeric($code) {
$base_ten = base_convert($code,36,10);
return base_convert($base_ten+1,10,36);
}
我们的想法是你的代码实际上只是一个基数为36的数字,所以你将那个基数为36的数字转换为基数为10,向它加1,然后将其转换回基数36并返回它.
编辑：刚刚意识到代码中可能存在任意字符串长度,但这种方法可能仍然可行 – 如果先捕获所有前导零,然后将其剥离,则执行基础36 – &gt;基础10转换,添加一个,并添加任何所需的前导零…
标签：php
来源： https://codeday.me/bug/20190716/1480386.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0eb0d6c00e1a83bd5e4feaf091b9c75/" rel="bookmark">
			银联 php hex2bin,php 实现银联商务H5支付
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		银联商务H5支付接口文档：文档地址
一：H5支付的接口地址:
1：支付宝支付
测试地址：http://58.247.0.18:29015/v1/netpay/trade/h5-pay
2：银联支付
测试地址：http://58.247.0.18:29015/v1/netpay/uac/order
二：接口需要的基本参数
接口使用的是get传参，直接将接口参数放到接口地址后,此接口是由浏览器直接跳转到接口
(1)authorization
认证方式，直接填入：OPEN-FORM-PARAM
(2)appId
银联商务用户H5支付产品的AppID
(3)timestamp
时间戳，格式为yyyyMMddHHmmss，如20191001121212
(4)nonce
随机数
(5)content
业务内容，为json格式，并且需要进行url编码，内部的具体信息下面介绍
(6)signature
签名,需要进行url编码,具体生成方式如：Base64_Encode(HmacSHA256(appId + timestamp + nonce + SHA256_HEX(content), AppKey))
业务内容content参数内部具体参数说明：
1：requestTimestamp
报文请求时间，格式为yyyy-MM-dd HH:mm:ss，如2019-10-01 12:12:12
2：merOrderId
商户自己生成的订单号，这里注意：我们需要在我们自己生成的订单号前面加上1017前缀
3：mid
银联商务用户H5支付产品的商户号
4：tid
银联商务用户H5支付产品的终端号
5：instMid
业务类型，直接填入：H5DEFAULT
6：totalAmount
支付总金额，单位为分
7：expireTime
订单过期时间，格式为yyyy-MM-dd HH:mm:ss，如2019-10-02 12:12:12
8：notifyUrl
支付结果通知地址
9：returnUrl
网页跳转地址
三：H5支付的支付宝支付实例
$appId = '10037e6f6a4e6da4016a670fd4530012';
$appKey = 'f7a74b6c02ae4e1e94aaba311c04acf2';
$mid = '898310148160568';
$tid = '88880001';
//业务内容
$time = time();
$content = [
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0eb0d6c00e1a83bd5e4feaf091b9c75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cadcfa86c383dda2225a0682db8866cd/" rel="bookmark">
			java高并发代码示例,Java使用代码模拟高并发操作的示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在java中，使用了synchronized关http://www.cppcns.com键字和Lock锁实现了资源的并发访问控制，在同一时间只允许唯一了线程进入临界区访问资源(读锁除外)，这样子控制的主要目的是为了解决多个线程并发同一资源造成的数据不一致的问题。在另外一种场景下，一个资源有多个副本可供同时使用，比如打印机房有多个打印机、厕所有多个坑可供同时使用，这种情况下，Java提供了另外的并发访问控制--资源的多副本的并发访问控制，今天使用的Semaphore即是其中的一种。
Java通过代码模拟高并发可以以最快的方式发现我们系统中潜在的线程安全性问题，此处使用Semaphore(信号量)和 Count
1、Semaphore
JDK 1.5之后会提供这个类
Semaphore是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。
2、CountDownLatch
JDK 1.5之后会提供这个类，
CountDownLhttp://www.cppcns.comatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。
CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。
如下图：
以上两个类可以搭配使用，达到模拟高并发的效果，以下使用代码的形式进行举例：
package modules;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaph
如上方法模拟5000次请求，同时最大200个并发操作，观察最后的结果，发现每次的结果都有差别，和预期不符，得出结果部分如下：
22:18:26.449 [main] INFO modules.CountExample - count:4997
22:18:26.449 [main] INFO modules.CountExample - count:5000
22:18:26.449 [main] INFO modules.CountExample - count:4995
22:18:26.449 [main] INFO modules.CountExample - count:4998
最后结论：add 方法 非线程安全
那如何保证add方法 线程安全，将add方法进行如下修改即可：
private static void add() {
count.incrementAndGet();
}
执行结果如下：
22:18:26.449 [main] INFO modules.CountExample - count:5000
22:18:26.449 [main] INFO modules.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cadcfa86c383dda2225a0682db8866cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f612e6bd9e809aee8533e32bb166db2/" rel="bookmark">
			关系型数据库，索引、B-tree、B&#43;树、Hash索引、存储索引InnoDB和MySql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库之 关系型数据库:
关系型数据库涉及知识点:
架构、索引、锁、语法、理论范式
如何设计一个关系型数据库:
1.需要有存储的文件系统（SSD固态硬盘、机械硬盘）
2.要有程序实例用逻辑结构映射出物理结构(存储管理、缓存机制、SQL解析、日志管理、权限划分、容灾机制、索引管理、锁管理)
索引模块:
1.为什么要使用索引
灵感来源于 字典
*快速查询数据
2.什么样的信息成为索引
主键、唯一键、普通键
3.索引的数据结构
*生成索引,建立二叉查找树进行二分查找
*生成索引，建立B-Tree结构进行查找
*生成索引，建立B±Tree结构进行查找（MySQL）
*生成索引,建立Hash结构进行查找
B-Tree特点:
根节点至少包括两个孩子
树中每个节点最多含有m个孩子(m&gt;=2)
除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子
所有叶子点都位于同一层
*关键字按顺序升序
*关键字的个数比孩子要少一个
*关键字对应的左边的孩子的值都小于关键字，右边的孩子都比关键字大
B±树
B+Tree更适合用来做存储索引原因：
*B+树的磁盘读写代价更低（内部存放索引信息，存入关键词多，一次性读入内存的数据就越多，效率高IO次数就少）
*B+树的查询效率更加稳定(根到叶子节点，所有数据查询长度相同，稳定)
*B+树更有利于对数据库的扫描(遍历叶子节点范围查询)
Hash索引:
Hash索引查询效率较高
缺点:
*仅仅能满足“=”，“IN”,不能使用查询范围
*无法被用来避免数据的排序操作
*不能利用部分索引键查询
*不能避免表扫描
*遇到大量Hash值相同的情况后性能并不一定就会比B-Tree索引高
密集索引和稀疏索引的区别:
*密集索引文件中的每个搜索码值都对应一个索引值
*稀疏索引文件只为索引码的某些值建立索引项
MYSQL有两种存储引擎:
MYISAM:大都索引是稀疏索引
InnoDB：有且仅有一个密集索引；
若一个主键被定义，则该主键则作为密集索引
若没有主键被定义，该表的第一个唯一非空索引则作为密集索引
若不满足以上条件，innodb内部会生成一个隐藏主键作为密集索引
非主键索引相关键位和其对应的主键值，包含两次查找
InnoDB的索引和数据是分开的
MYISAM的索引和数据是在一起的
如何定位并且优化慢查询Sql:
根据慢日志定位慢查询SQL
使用explain等工具分析sql
修改sql或者尽量让sql走索引
索引建的越多越好吗？
*数据量小的表不需要建立索引，建立会增加额外的索引开销
*数据变更需要维护索引，因此更多的索引意味着更多的维护成本
*也意味着需要更多的空间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52dd8803f12845f448dbdfa7b248134e/" rel="bookmark">
			字节跳动AI lab计算机视觉实习生面试教训
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为学术没有人带，自己一个人看论文 做实验太难受了，所以就打算找个大厂的AI lab进行实习。
2021年3月9日 15：00开始的面试，牛客网开的房间，刚开始一直语音不知道什么问题，对方面试官听不到我说话，急了大概十来分钟，最终决定加了面试官微信，微信语音，然后网络不是太好，就直接打电话了衰。
面板还是用的牛客网的房间，首先自我介绍，然后讲了下之前的工作，前一段时间一直在做的小样本学习(few-shot learning)的东西，就大概讲了一下novelty、contributions，到这里还好，然后开始问及我简历上写的自监督训练模型用于下游的目标检测。面试官就问：目标检测你应该了解一些吧，我说是，但是了解的不多 特别细的地方不是很清楚。然后接着问那IOU你知道吧，然后就直接编辑框里写一个IOU吧，本科的时候算矩阵的交集并集分分钟用java写出来，然后我好久没做过这种题了，我知道边界问题不太好控制，所以就问面试官能换道题吗 这道题边界不太好控制，然后面试官说这道题考的就是边界问题，那行，换一道，目标检测里面的nms知道吧，我说知道，非最大值抑制，面试官：那你写一个nms。真没造过这种轮子，我说能再换一道题吗，然后面试官说那就来一道数据结构吧，出了一道leetcode medium的题leetcode 394.字符串编码，本科时都刷过的题，本能反应就是用栈做，但硬是没跑出结果，最近刷的题还是太少了我，还是太菜了，然后就凉了。
之前是有看面经准备的，深度学习 机器学习一些基本的算法什么的都准备了一下，还有经常容易考的题。但是，真的都没问到，问的题可能就真的看面试官了。
教训：编程能力还是有待提高，自己太菜了，以后得好好努力了 对得起自己的时间，字节跳动对代码能力确实要求不低。
思考：直博读的真的划算吗？（希望几年后再看能不后悔当初自己的选择）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b055646ec374dcfa9db7df3c679f7880/" rel="bookmark">
			php 插入字段_php 在字符串指定位置插入新字符的简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		php 在字符串指定位置插入新字符的简单实现
因为项目用到DataTable表格加载后台数据，要连表查询虚拟机选中的策略状态，所以想到先把策略表内容取出来，组成一个'[n个option]'字符串，在遍历虚拟机列表时把他的策略值拼成 'value="1"' 这样的字符串，再利用explode()和implode() 函数，组成新的字符串返回给前台，就实现了选中状态。
$option = '';
// 取出所有策略
$sla_query = $this-&gt;db-&gt;select('sla_id, name')-&gt;get('sla');
$sla_res = $sla_query-&gt;result_array();
if (!empty($sla_res)) {
$option .= '未保护';
foreach ($sla_res as $k1 =&gt; $v1) {
$option .= '' . $v1['name'] . '';
}
$option .= '';
} else {
$option .= '未保护';
}
// 选中默认的保护策略
$vm_query = $this-&gt;db-&gt;select('sla_id')-&gt;where('vm_id', $vm_id)-&gt;get('task_vm', 1);
$vm_res = $vm_query-&gt;row_array();
if (is_null($vm_res['sla_id'])) $res['sla_id'] = 0;
$selected = 'value="' . $vm_res['sla_id'] .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b055646ec374dcfa9db7df3c679f7880/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a16ee249030d7b113c91202ad684775/" rel="bookmark">
			CLion使用：异常-This file does not belong to any project target, code insight features...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述： 使用CLion创建新项目，以及源文件（.c），出现提示：This file does not belong to any project target, code insight features might not work properly.
且代码编译运行出现错误
collect2.exe: error: ld returned 1 exit status mingw32-make.exe[3]: *** [项目名.exe] Error 1 mingw32-make.exe[2]: *** [CMakeFiles/项目名.dir/all] Error 2 mingw32-make.exe[1]: *** [CMakeFiles/项目名.dir/rule] Error 2 mingw32-make.exe: *** [test_030902] Error 2
解决： 经与其他项目对比发现，问题出现在CMakeLists.txt文件的add_executable上
解决方案： 手动追加源文件名至该位置
add_executable(test_030902 main.c test001.c)
并reload changes
或者创建源文件时勾选Add to targets
勾选后效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11a3daed3707e013413db69e38cad5ec/" rel="bookmark">
			try catch 底层原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有这样一段程序
public class Main { public static void main(String[] args) { new Main().call(); } public int call() { try { int a = 1 / 0; } catch (Exception e) { System.err.println("exception"); return 0; } finally { return 4; } } } 程序运行结果
java.lang.ArithmeticException: / by zero 4 我们来看下这段代码编译出来的部分字节码：
public int call(); descriptor: ()I flags: ACC_PUBLIC Code: stack=2, locals=4, args_size=1 0: iconst_1 1: iconst_0 2: idiv 3: istore_1 4: iconst_4 5: ireturn 6: astore_1 7: getstatic #2 // Field java/lang/System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11a3daed3707e013413db69e38cad5ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb9e1ae3ff32e4ba039440f83883df1/" rel="bookmark">
			Linux抓包工具tcpdump使用小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux抓包工具tcpdump使用小结 简介及安装tcpdump命令详解tcpdump参数tcpdump表达式tcpdump 命令演示常用抓包命令组合 tcpdump抓包实测理解抓取的报文 简介及安装 tcpdump 是一款用于截取网络分组，并过滤输出分组内容的工具。tcpdump 凭借强大的功能和灵活的截取策略，使其成为类 UNIX 系统下用于网络分析和问题排查的首选工具。 tcpdump 提供了源代码，公开了接口，因此具备很强的可扩展性，对于网络维护和入侵者都是非常有用的工具。tcpdump 存在于基本的 Linux 系统中，由于它需要将网络界面设置为混杂模式，普通用户不能正常执行，但具备 root 权限的用户可以直接执行它来获取网络上的信息。因此系统中存在网络分析工具主要不是对本机安全的威胁，而是对网络上的其他计算机的安全存在威胁。tcpdump 可以将网络中传送的数据包的 “头” 完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供 and、or、not 等逻辑语句来帮助我们去掉无用的信息。
tcpdump 默认在几乎所有的 Linux 发行版中都可用，但若你的 Linux 上没有的话，使用下面方法进行安装。
CentOS/RHEL使用下面命令在 CentOS 和 RHEL 上安装 tcpdump
sudo yum install tcpdump* tcpdump命令详解 tcpdump [ 选项 ] [ -c 数量 ] [ -i 网络接口 ] [ -w 文件名 ] [ 表达式 ] tcpdump 选项翻译如下： -l：使标准输出变为缓冲行形式； -c：抓包次数； -n: 禁用域名解析，让 tcpdump 直接输出 IP 地址； -nn：直接以 IP 及 Port Number 显示，而非主机名与服务名称； -s ：&lt; 数据包大小 &amp; gt; 设置每个数据包的大小； -i：指定监听的网络接口； -r：从指定的文件中读取包； -w：输出信息保存到指定文件； -A: 以 ASCII 值显示抓到的包, 比如和 MySQL 的交互时，可以通过 - A 查看包的文本内容； -a：将网络地址和广播地址转变成名字； -d：将匹配信息包的代码以人们能够理解的汇编格式给出； -e：在输出行打印出数据链路层的头部信息； -f：将外部的 Internet 地址以数字的形式打印出来； -t：在输出的每一行不打印时间戳； -v ：输出稍微详细的报文信息； -vvv 会尝试解析应用层协议，输出详细信息。二者组合就能完整的详细信息； -vvvv 该参数其实是 -v 与 -vvv 的组合； -vv 则输出更详细信息。 tcpdump参数 tcpdump tcp -i bond0 -tttt -s 0 -c 100 and dst port !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdb9e1ae3ff32e4ba039440f83883df1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd13d9c57d02135790c1df8140f8e732/" rel="bookmark">
			规则引擎 Drools
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		规则引擎 Drools 文章目录 规则引擎 Drools1. 问题引出2. 规则引擎概述2.1 什么是规则引擎2.2 使用规则引擎的优势2.3 规则引擎应用场景2.4 Drools介绍 3.Drools入门案例3.1 业务场景说明3.2 开发实现3.3 小结3.3.1 规则引擎构成3.3.2 相关概念说明3.3.3 规则引擎执行过程3.3.4 KIE介绍 4. Drools基础语法4.1 规则文件构成4.2 规则体语法结构4.3 注释4.4 Pattern模式匹配4.5 比较操作符4.5.1 语法4.5.2 操作步骤 4.6 执行指定规则4.7 关键字4.8 Drools内置方法4.8.1 update方法4.8.2 insert方法4.8.3 retract方法 5. 规则属性5.1 enabled属性5.2 dialect属性5.3 salience属性5.5 activation-group属性5.6 agenda-group属性5.7 auto-focus属性5.8 timer属性5.9 date-effective属性5.10 date-expires属性 6. Drools高级语法6.1 global全局变量6.2 query查询6.3 function函数6.4 LHS加强6.4.1 复合值限制in/not in6.4.2 条件元素eval6.4.3 条件元素not6.4.4 条件元素exists6.4.5 规则继承 6.5 RHS加强6.5.1 halt6.5.2 getWorkingMemory6.5.3 getRule 6.6 规则文件编码规范 7. Spring整合Drools7.1 Spring简单整合Drools7.2 Spring整合Drools+web7.3 Spring Boot整合Drools 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd13d9c57d02135790c1df8140f8e732/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c24dfa5156cc79239580c584cf677d36/" rel="bookmark">
			Android APP开发入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了Android APP开发入门教程，从SDK下载、开发环境搭建、代码编写、APP打包等步骤一一讲解，非常简明的一个Android APP开发入门教程，需要的朋友可以参考下。
工作中有做过手机App项目，前端和android或ios程序员配合完成整个项目的开发，开发过程中与ios程序配合基本没什么问题，而android各种机子和rom的问题很多，这也让我产生了学习android和ios程序开发的兴趣。于是凌晨一点睡不着写了第一个android程序HelloAndroid，po出来分享给其他也想学习android开发的朋友，这么傻瓜的Android开发入门文章，有一点开发基础的应该都能看懂。
一、准备工作 主要以我自己的开发环境为例，下载安装JDK和Android SDK，假如你没有现成的IDE，你可以直接下载SDK完整包，里面包含了Eclipse，如果有IDE那么你可以滚动到下面选择USE AN EXISTING IDE，然后安装SDK，如果你的SDK在安装时找不到JDK目录，你可以在系统环境变量里添加JAVA_HOME变量，路径为你的JDK目录，我的IDE是IntelliJ IDEA，都装好以后开始配置IDE增加SDK支持。
首先，打开Android SDK Manager把Android 4.0以上版本的未安装的都打勾装上，根据你个人实际情况，如果你只打算用自己的手机测试，那就把你机子系统一样版本的SDK包装上，下载时间有点长。
然后打开IDE创建新项目，IDEA比较智能，如果你装好了SDK，新建项目里就会出现Android的Application Module，选择后右边Project SDK为空，点击New按钮，找到SDK目录确定，下拉列表就会列出已经安装的各个版本的SDK，选择自己需要的版本，如果是第一次设置，IDE会提醒你先设置JDK，根据提示找到JDK目录即可。
填好项目名称后下一步选择USB Device，然后完成项目构建，IDE会自动生成基本的项目所需的文件及目录。
二、代码编写 做好准备工作后，终于可以开始写我们的hello android了，在开始编写代码之前，我们先了解几个文件：
res/layout/main.xml App主窗体布局文件，你的应用长什么样都在这边定义，有Design和Text两种模式
res/values/strings.xml 可以理解为i18n文件，这个文件用来存放程序调用的各种字符串
src/com/example/helloandroid/MyActivity.java 这个就是我们的主程序类，等下要实现的功能都在这个文件里添加
首先为应用添加一个id为hellotextView的textview和一个id为hellobutton的button，mail.xml 代码如下：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent" &gt; &lt;TextView android:layout_width="fill_parent" android:layout_height="180dp" android:text="@string/default_message" android:id="@+id/hellotextView" android:textColor="#00ff00" android:gravity="center"/&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/button_send" android:id="@+id/hellobutton" android:layout_gravity="center"/&gt; &lt;/LinearLayout&gt; 代码和控件用到的字符串定义如下：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;resources&gt; &lt;string name="app_name"&gt;helloandroid by hiwanz&lt;/string&gt; &lt;string name="button_send"&gt;Say something&lt;/string&gt; &lt;string name="default_message"&gt;Click button below!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c24dfa5156cc79239580c584cf677d36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a2920380508b0c07ddd4ff9b72a9e12/" rel="bookmark">
			STM32CubeMX学习笔记（16）——电源管理(PWR)低功耗停止模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、低功耗模式简介 系统提供了多个低功耗模式，可在 CPU 不需要运行时（例如等待外部事件时）节省功耗。由用户根据应用选择具体的低功耗模式，以在低功耗、短启动时间和可用唤醒源之间寻求最佳平衡。
睡眠模式、停止模式及待机模式中，若备份域电源正常供电，备份域内的 RTC 都可以正常运行，备份域内的寄存器的数据会被保存，不受功耗模式影响。
从表中可以看到，这三种低功耗模式层层递进，运行的时钟或芯片功能越来越少，因而功耗越来越低。
模式名称说明进入方式唤醒方式对1.8V区域时钟的影响对VDD区域时钟的影响调压器睡眠模式内核停止，所有外设包括M3核心的外设，如NVIC、系统时钟(SysTick)等仍在运行调用WFI命令任意中断内核时钟关，对其他时钟和ADC时钟无影响无开睡眠模式内核停止，所有外设包括M3核心的外设，如NVIC、系统时钟(SysTick)等仍在运行调用WFE命令唤醒事件内核时钟关，对其他时钟和ADC时钟无影响无开停止模式所有的时钟都已停止配置PWR_CR寄存器的PDDS+LPDS位+SLEEPDEEP位+WFI或WFE命令任意外部中断EXTI(在外部中断寄存器中设置)关闭所有1.8V区域的时钟HSI和HSE的振荡器关闭开启或处于低功耗模式(依据电源控制寄存器的设定)待机模式1.8V电源关闭配置PWR_CR寄存器的PDDS+SLEEPDEEP位+WFI或WFE命令WKUP上升沿、引脚的RTC闹钟事件、NRST引脚上的外部复位、IWDG复位关闭所有1.8V区域的时钟HSI和HSE的振荡器关闭关 1.1 睡眠模式 在睡眠模式中，仅关闭了内核时钟，内核停止运行，但其片上外设，CM3 核心的外设全都还照常运行。有两种方式进入睡眠模式，它的进入方式决定了从睡眠唤醒的方式，分别是 WFI(wait for interrupt) 和 WFE(wait for event)，即由等待“中断”唤醒和由“事件”唤醒。
特性和说明：
立即睡眠： 在执行 WFI 或 WFE 指令时立即进入睡眠模式。退出时睡眠： 在退出优先级最低的中断服务程序后才进入睡眠模式。进入方式： 内核寄存器的 SLEEPDEEP=0 ，然后调用 WFI 或 WFE 指令即可进入睡眠模式；SLEEPONEXIT=1 时，进入“退出时睡眠”模式。唤醒方式： 如果是使用 WFI 指令睡眠的，则可使用任意中断唤醒；如果是使用 WFE 指令睡眠的，则由事件唤醒。睡眠时： 关闭内核时钟，内核停止，而外设正常运行，在软件上表现为不再执行新的代码。这个状态会保留睡眠前的内核寄存器、内存的数据。唤醒延迟： 无延迟。唤醒后： 若由中断唤醒，先进入中断，退出中断服务程序后，接着执行 WFI 指令后的程序；若由事件唤醒，直接接着执行 WFE 后的程序。 1.2 停止模式 在停止模式中，进一步关闭了其它所有的时钟，于是所有的外设都停止了工作，但由于其 1.8V 区域的部分电源没有关闭，还保留了内核的寄存器、内存的信息，所以从停止模式唤醒，并重新开启时钟后，还可以从上次停止处继续执行代码。停止模式可以由任意一个外部中断(EXTI)唤醒，在停止模式中可以选择电压调节器为开模式或低功耗模式。
特性和说明：
调压器低功耗模式： 在停止模式下调压器可工作在正常模式或低功耗模式，可进一步降低功耗。进入方式： 内核寄存器的 SLEEPDEEP=1，PWR_CR 寄存器中的 PDDS=0，然后调用 WFI 或 WFE 指令即可进入停止模式；PWR_CR 寄存器的 LPDS=0 时，调压器工作在正常模式，LPDS=1 时工作在低功耗模式。唤醒方式： 如果是使用 WFI 指令睡眠的，可使用任意 EXTI 线的中断唤醒；如果是使用 WFE 指令睡眠的，可使用任意配置为事件模式的 EXTI 线事件唤醒。停止时： 内核停止，片上外设也停止。这个状态会保留停止前的内核寄存器、内存的数据。唤醒延迟： 基础延迟为 HSI 振荡器的启动时间，若调压器工作在低功耗模式，还需要加上调压器从低功耗切换至正常模式下的时间。唤醒后： 若由中断唤醒，先进入中断，退出中断服务程序后，接着执行 WFI 指令后的程序；若由事件唤醒，直接接着执行 WFE 后的程序。唤醒后，STM32 会使用 HSI 作为系统时钟。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a2920380508b0c07ddd4ff9b72a9e12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dc183462b2e1a8e88262cc4a3aa81fd/" rel="bookmark">
			Linux之Netem模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章：概念篇 Netem 是 Linux 2.6 及以上内核版本提供的一个网络模拟功能模块。该功能模块可以用来在性能良好的局域网中，模拟出复杂的互联网传输性能，诸如低带宽、传输延迟、丢包等等情况。使用 Linux 2.6 (或以上) 版本内核的很多发行版 Linux 都开启了该内核功能，比如Fedora、Ubuntu、Redhat、OpenSuse、CentOS、Debian等等。tc 是 Linux 系统中的一个工具，全名为traffic control（流量控制）。tc 可以用来控制 netem 的工作模式，也就是说，如果想使用 netem ，需要至少两个条件，一个是内核中的 netem 功能被包含，另一个是要有 tc 。
第二章：原理 TC用于Linux内核的流量控制，主要是通过在输出端口处建立一个队列来实现流量控制。接收包从输入接口（Input Interface）进来后，经过流量限制（Ingress Policing）丢弃不符合规定的数据包，由输入多路分配器（Input De-Multiplexing）进行判断选择：如果接收包的目的是本主机，那么将该包送给上层处理；否则需要进行转发，将接收包交到转发块（Forwarding Block）处理。转发块同时也接收本主机上层（TCP、UDP等）产生的包。转发块通过查看路由表，决定所处理包的下一跳。然后，对包进行排列以便将它们传送到输出接口（Output Interface）。一般我们只能限制网卡发送的数据包，不能限制网卡接收的数据包，所以我们可以通过改变发送次序来控制传输速率。Linux流量控制主要是在输出接口排列时进行处理和实现的。
第三章：应用 首先在使用此模块之前需要进入root模式，进入方法：
图形界面bai启动一个虚拟终端du程序，在里面切换到 root 身份zhi，比如 su - 或者 sudo -i 。图形界dao面有些zhuan系统允许 root 登陆，那么启动的虚拟终端程序也是默认 root 权限。切换到本地字符终端，直接用 root 登陆，或者用一般用户登陆，再进行切换到 root 权限。用其他方式，比如远程登录的方式同样处理。 其次需要查看本机使用的网卡：
在linux终端输入: ifconfig ，即可获取本机所有网卡，如我的网卡是ens33。
root@ubuntu:~# ifconfig -a ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.100.29 netmask 255.255.255.0 broadcast 192.168.100.255 inet6 fe80::e701:b1f8:2dac:7272 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:69:4a:41 txqueuelen 1000 (以太网) RX packets 13064 bytes 6071316 (6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dc183462b2e1a8e88262cc4a3aa81fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d432baf5bf2478beeda22c4eafa3e3c/" rel="bookmark">
			python字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串是 Python 中最常用的数据类型。我们可以使用引号( ’ 或 " )来创建字符串。
创建字符串很简单，只要为变量分配一个值即可。例如：
var1 = 'Hello World!' var2 = "Runoob" Python 访问字符串中的值 Python 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。
Python 访问子字符串，可以使用方括号 [] 来截取字符串，字符串的截取的语法格式如下
#!/usr/bin/python3 var1 = 'Hello World!' var2 = 'Runnoob' print("var1[0]：", var1[0]) print("var2[1:5]：", var2[1:5]) var1[0]: H var2[1:5]: unoo Python 字符串更新 你可以截取字符串的一部分并与其他字段拼接，如下实例：
实例(Python 3.0+)
#!/usr/bin/python3 var1 = 'Hello World!' print ("已更新字符串 : ", var1[:6] + 'Runoob!') 以上实例执行结果
已更新字符串 : Hello Runoob! Python字符串运算符 下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d432baf5bf2478beeda22c4eafa3e3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2214e88c53e1d03de8aaa0aa8594615c/" rel="bookmark">
			【CheatSheets】AI速查表集合 一图胜千言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【CheatSheets】AI速查表集合 一图胜千言 公众号： ChallengeHub 引言
机器学习很复杂，知识众多，对于新手来说，如果他们没有合适的学习资源，则开始学习机器学习会很痛苦。大多数机器学习库很难理解，学习曲线可能会令人沮丧。机器学习和深度学习工程师必备-速查表可以帮助我们快速查找相应功能以及使用方法，大家收藏一波吧
最近在Github发现一个仓库，名字为cheatsheets-ai ，https://github.com/kailashahirwar/cheatsheets-ai，
其中包含来自不同来源的不同机器学习框架的备忘单。
备忘单列表：
Keras
Numpy
Pandas
Scipy
Matplotlib
Scikit-Learn
Neural Networks Zoo
ggplot2
PySpark
R Studio
Jupyter Notebook
Dask
1、Keras
来源— https://www.datacamp.com/community/blog/keras-cheat-sheet#gs.DRKeNMs
2、Numpy
来源 — https://www.datacamp.com/community/blog/python-numpy-cheat-sheet#gs.AK5ZBgE
3、Pandas
来源-https://www.datacamp.com/community/blog/pandas-cheat-sheet-python#gs.HPFoRIc
4、Scipy
来源 — https://www.datacamp.com/community/blog/python-scipy-cheat-sheet#gs.JDSg3OI
5、Matplotlib
来源 — https://www.datacamp.com/community/blog/python-matplotlib-cheat-sheet#gs.uEKySpY
6、Scikit-learn
来源 — https://www.datacamp.com/community/blog/scikit-learn-cheat-sheet
9、 Neural Networks Zoo
来源— http://www.asimovinstitute.org/neural-network-zoo/
8、ggplot2
来源— https://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf
9、PySpark
来源 — https://www.datacamp.com/community/blog/pyspark-sql-cheat-sheet
10、R Studio (dplyr and tidyr)
来源 — https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf
11、Jupyter Notebook
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2214e88c53e1d03de8aaa0aa8594615c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49c57585180508d5749bf8bd183b7f36/" rel="bookmark">
			k8s中将flannel网络切换calico网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意事项： 1、kubelet 配置必须增加 --network-plugin=cni 选项
2、kubec-proxy 组件不能采用 --masquerade-all 启动，因为会与 Calico policy 冲突，并且需要加上–proxy-mode=ipvs（ipvs模式），–masquerade-all=true（表示ipvs proxier将伪装访问服务群集IP的所有流量,）
1、停止flanneld服务 yaml形式安装的flanneld切换calico 1、利用之前部署的flanneld文件删除掉flanneld网络
kubectl delete -f kube-flanneld.yaml 2、删除路由
我们删除网卡会自动删除这两个网卡的路由
ip link delete cnio ip link delete flannel.1 删掉其他路由
ip route delete 10.244.0.0/24 via 192.168.25.61 dev eth0 ip route delete 10.244.1.0/24 via 192.168.25.61 dev eth0 ip route 172.17.92.0/24 dev docker0 proto kernel scope link src 172.17.92.1 3、清除网络规则
iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X 二进制安装的flanneld切换calico 1、关闭flanneld服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49c57585180508d5749bf8bd183b7f36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9ce097be4b394a66a6bb9de640811e3/" rel="bookmark">
			Cobalt Strike从入门到精通之Web Drive-By web钓鱼攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.bilibili.com/video/BV1P64y1f7e1?p=6
Cobalt Strike Web Drive-By web钓鱼攻击 在这里补充一个上节课的新的知识点，如何使用python语言的payload 加载器去攻击
# length: 894 bytes from ctypes import * import ctypes buf = "" #这里填写payload PROT_READ = 1 PROT_WRITE = 2 PROT_EXEC = 4 def executable_code(buffer): buf = c_char_p(buffer) size = len(buffer) addr = libc.valloc(size) addr = c_void_p(addr) if 0 == addr: raise Exception("Failed to allocate memory") memmove(addr, buf, size) if 0 != libc.mprotect(addr, len(buffer), PROT_READ | PROT_WRITE | PROT_EXEC): raise Exception("Failed to set protection on buffer"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9ce097be4b394a66a6bb9de640811e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d1327fd06736a22178b361a9cdc0402/" rel="bookmark">
			设计算法求数组中相差最小的两个元素（称为最接近数）的差。要求分别给出伪代码和C&#43;&#43;描述。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.题目 设计算法求数组中相差最小的两个元素（称为最接近数）的差。要求分别给出伪代码和C++描述。
2.算法分析思路： 1.对数组先进行快速排序，使数组有序
2.依次比较相邻两数的差,更新最小值
3.快速排序模板: void quick_sort(int q[], int l, int r) { //递归的终止情况 if(l &gt;= r) return; //第一步：分成子问题 int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while(i &lt; j) { do i++; while(q[i] &lt; x); do j--; while(q[j] &gt; x); if(i &lt; j) swap(q[i], q[j]); } //第二步：递归处理子问题 quick_sort(q, l, j), quick_sort(q, j + 1, r); } 4.时间复杂度分析 快速排序O(nlog2n) 更新最小值 for循环 O(n)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d1327fd06736a22178b361a9cdc0402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a857bf194cfaf87591cccaf68aef882/" rel="bookmark">
			1.Anaconda Navigator更新_Anaconda详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Anaconda介绍、安装及使用教程 前言 Python是一种面向对象的解释型计算机程序设计语言，具有跨平台的特点，可以在Linux、macOS以及Windows系统中搭建环境并使用，其编写的代码在不同平台上运行时，几乎不需要做较大的改动就能运行。
Python的应用遍及人工智能、科学计算、Web开发、系统运维、大数据及云计算、金融、游戏开发等，具有数量庞大且功能相对完善的标准库和第三方库。
一、Anaconda 1、简介 Anaconda是大型的科学计算平台，是Python集成开发环境，包含了大量的科学包，能够方便快捷的对程序包进行管理和部署。
2、特点 安装简单包含了数百个科学模块，高效运用于各种项目免费社区支持Anaconda 是跨平台的，有 Windows、macOS、Linux 版本支持多种语言：Python、R、Java等 3、包管理工具——conda 3.1 升级 升级Anaconda需要先升级conda
conda update conda conda update anaconda conda update anaconda-navigator # 最新版本的anaconda-navigator 3.2 卸载 Linux、Mac 删除安装路径
rm -rf anaconda 3.3 基本命令 conda --version # 查看 conda 版本 conda update -n base conda # update最新版本的conda conda create -n xxxx # 创建名为 xxxx 的虚拟环境 conda create -n xxxx python=3.5 # 创建包含 python3.5 的名为 xxxx 的虚拟环境 conda remove -n xxxx --all # 删除名为 xxxx 的虚拟环境 conda activate xxxx # 进入 xxxx 环境 conda deactivate # 退出环境 conda env list # 显示所有的虚拟环境 conda clean -p # 删除没有用的包 conda clean -t # tar打包 conda clean -y -all # 删除所有的安装包及cache 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a857bf194cfaf87591cccaf68aef882/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb6a38d719e78afd669b8ca8cec7ceda/" rel="bookmark">
			ArcGIS处理LAS数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArcGIS处理LAS数据集 文章目录 ArcGIS处理LAS数据集加载显示LAS数据集LAS数据集二维显示LAS数据集三维显示 投影变换数据格式转换LAS数据集转栅格LAS数据集转TIN LAS数据集地形分析点云数据分类与信息提取分类LAS地面点分类建筑物点数据分类LAS噪点 3D视图及导航窗口生成3D视图测距 3D视图及导航窗口生成3D视图测距 加载显示LAS数据集 LAS数据集二维显示 打开arcmap，加载所给的LAS数据集，可以看到LAS数据以二维形式显示，其中，房屋建筑等点数据被高亮显示为红色或近红色，结果如所示。
图 1-1 LAS数据集二维显示
LAS数据集三维显示 打开arcscene，加载所给的LAS数据集，可以看到LAS数据集以三维形式进行显示，房屋建筑等地物等高度与地面不同，且以红色或近红色高亮显示，结果如所示。
图 1-2 LAS数据集三维显示（全局）
图 1-3 LAS点云数据三维显示局部
投影变换 由于所给的数据没有定义坐标系，所以这里需要手动定义地理坐标系和投影坐标系。
图 1-4 缺少空间参考
Arcgis无法直接为LAS数据集创建投影文件，所以这里需要使用【创建LAS数据集】来为LAS数据集指定空间参考，设置输入LAS数据集为“DataSample.las”，输出数据集为“DataSample_prj.las”，设置坐标系为“WGS_1984_UTM_Zone_33N”，如所示。
图 1-5 创建LAS数据集及投影
打开新创建的LAS数据集，双击打开【图层属性】，可以看到已定义空间参考，如所示。
图 1-6 图层属性
当然，也可以使用提取 LAS工具重写 LAS 文件以包括正确的空间参考信息。
数据格式转换 LAS数据集转栅格 点击【3D Analyst】→【数据管理】→【转换】→【由LAS数据集转出】→【LAS数据集转栅格】，设置输入LAS数据集为“DataSample”，输出数据集为“city_dem.tif”，值字段为“ELEVATION”，其余属性保持默认，如所示。
图 2-7 LAS数据集转栅格
LAS数据集转栅格结果如所示。
图 2-8 LAS数据集转栅格结果
双击打开“city_dem.tif”的属性，点击【显示】→【基本高度】，设置栅格在表面上浮动，点击确定。
点击【符号系统】→【拉伸】，进行拉伸渲染，结果如所示。
图 2-9 栅格拉伸渲染（全局）
拉伸渲染的局部结果如所示。
图 2-10 栅格拉伸渲染（局部）
LAS数据集转TIN 点击【3D Analyst】→【转换】→【由LAS数据集转出】，设置输入LAS数据集为“DataSample.las”，输出TIN为“TIN”，设置最大节点数为5000000，其余属性保持默认，点击确定，如所示。
图 2-11 LAS数据集转TIN
LAS数据集转TIN的最终结果如所示。
图 2-12 LAS数据集转TIN结果
点击【3D Analyst】→【功能性表面】→【表面体积】，设置输入表面为TIN，输出文本文件为“表面体积.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb6a38d719e78afd669b8ca8cec7ceda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fb4b9016fb277d355352bbb7e6d1c78/" rel="bookmark">
			java createobject_CreateObject（“Excel.Application”）实例的行为与“普通”（点击）实例不同...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果我通过双击Excel文件打开Excel然后使用VBA打开MyExcelFile并运行MyMacro，事情就好了 . 但是，如果我使用VBA使用CreateObject创建一个新的Excel实例，并使用VBA打开MyExcelFile并运行MyMacro，则第三方加载项我无法控制行为方式(错误) .
我'm wondering if there are settings for Excel instances I can control and should set explicitly? I got really excited when I saw this, but it didn'解决了我的问题："New" Excel.Application vs Excel.Application
通过点击打开Excel是否从CreateObject(“Excel.Application”)启动不同的设置？也许不同的工作目录或什么？
总之，对于我的第三方AddIn：
作品：
Workbooks.Open("MyExcelFile")
Application.Run "MyExcelFile!MyMacro"
不起作用：
Dim ObjXL
Set objXL = CreateObject("Excel.Application")
objXL.Workbooks.Open("MyExcelFile")
objXL.Application.Run "MyExcelFile!MyMacro"
在MyMacro中，我加载了AddIn：
Dim success as Boolean
...
success = False
success = Application.RegisterXLL("PathToAddIn_x64.xll")
If Not (success) Then
Exit Sub
End If
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fb4b9016fb277d355352bbb7e6d1c78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10dc27a4877f862aa730bb6b4671c871/" rel="bookmark">
			Sparse-Interest Network for Sequential Recommendation WSDM2021
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 顺序推荐中的最新方法着重于从用户的行为序列中学习下一个推荐的整体嵌入向量。但是，通过经验分析，我们发现用户的行为序列通常包含多个概念上不同的项目，而统一的嵌入向量主要受一个人最近的频繁动作的影响。因此，如果概念上相似的项目在最近的交互中不占主导地位，则可能无法推断出下一个首选项目。为此，另一种解决方案是用编码该用户意图的不同方面的多个嵌入矢量来表示每个用户。尽管如此，最近有关多兴趣嵌入的工作通常考虑了通过聚类发现的少量概念，这可能无法与真实系统中的大量项目类别相提并论。有效地建模大量不同的概念原型是一项艰巨的任务，因为项目在概念上通常不能很好地按精细的粒度进行聚类。此外，一个人通常只与一组稀疏的概念进行交互。有鉴于此，我们提出了一种新颖的稀疏兴趣网络（SINE），以进行顺序推荐。我们的稀疏兴趣模块可以从大型概念库中为每个用户自适应地推断出一组稀疏概念，并相应地输出多个嵌入。给定多个兴趣嵌入，我们将开发一个兴趣汇总模块，以主动预测用户的当前意图，然后使用该模块显式地对多个兴趣进行建模，以进行下一项预测。在几个公共基准数据集和一个大型工业数据集上的经验结果表明，SINE可以比最先进的方法取得实质性的进步。
我就没懂这个图的含义
问题 但是，要从行业水平数据中的用户行为序列中有效地提取多个嵌入矢量，仍然存在一些挑战。首先，项目在概念上通常不能很好地聚集在实际系统中。尽管可以将项目的类别信息用作概念，但是在许多情况下，实际上这种类型的辅助信息由于注释噪声而可能不可用或不可靠。第二个挑战是从大型概念库中为用户自适应地推断出一组稀疏的感兴趣概念。推理过程包括选择操作，这是一个离散的优化问题，难于端到端训练。第三，给定多个兴趣嵌入向量，我们需要确定哪个兴趣可能会被激活以用于下一个项目的预测。在训练期间，下一个预测项目可以用作激活首选意图的标签，但是推断阶段没有这样的标签。该模型必须自适应地预测用户的下一个意图。
在本文中，我们提出了一种新的稀疏兴趣网络(SINE)用于顺序推荐来解决这些问题。SINE可以学习大量的兴趣组，并以端到端的方式捕获用户的多种意图。图4显示了SINE的整体结构。我们的稀疏兴趣提取模块自适应地从大量兴趣组中推断出用户交互的兴趣，并输出多个兴趣嵌入。聚合模块能够动态预测用户的下一个意图，有助于显式地捕获前N个项目推荐的多个兴趣。我们在几个公共基准和一个工业数据集上进行了实验。实验结果表明，我们的框架比最先进的模型性能更好，并产生了合理的项目聚类。
模型 先捕获用户意图，然后利用K临近算法来生成候选项目
用于捕获用户的多个意图的最先进的序列编码器可以概括为两类。第一类方法求助于强大的顺序编码器来隐含地提取用户的多重意图，例如基于多头自我注意的模型(又名变形金刚[43])。另一种类型的方法依赖于潜在的原型来显式地捕捉用户的多重意图。通常，由于意图检测和嵌入在实践中的混合性质，前一种方法可能会限制其捕获多个意图的能力。例如，实证结果表明，在推荐方面，Transformer学习的多个矢量表示似乎并不比单头实现[21]具有明显的优势。相反，后者通过聚类识别的概念可以有效地提取用户的不同兴趣，如文献[27，29]中经验证明的那样。然而，这些方法的可伸缩性很差，因为它们要求每个用户都有一个嵌入在每个概念下的意图，这在工业应用中很容易扩展到数千个。例如，在中国天猫的电商平台上，数百万甚至数十亿的商品属于1万多个专家标注的树叶类别[24个]。随着实际系统中存在大量的兴趣概念，需要一个可扩展的多兴趣提取模块。
第一个模块 正弦的架构(彩色效果更佳)。稀疏兴趣模块以用户的行为序列为输入，从庞大的兴趣组池中自适应地激活用户的兴趣，并输出多兴趣嵌入。然后，兴趣聚合模块通过主动预测用户的下一意图，帮助用户选择最喜欢的兴趣进行下一项推荐。SINE提供了以端到端的方式对项目进行聚类并推断用户稀疏兴趣集的能力。
a是用户行为的注意力权重向量。
2式首先是合并C和Z，然后top-k打分，最后得到用户的潜在矩阵
公式2是一个TOP-K选择技巧，它使得离散选择操作是可微的，前人的工作[8]发现它在逼近TOP-K选择问题时非常有效。
在推断出当前的概念原型Cu之后，我们可以根据用户与原型的距离来估计他/她的行为序列中的每一项与其相关的用户意图。
度量位置t的主要意图与𝑘潜在概念相关的可能性。
t和k换了位置的具体影响，以及p代表的含义
p是一个概率矩阵
生成多个兴趣嵌入向量
到目前为止，我们已经介绍了稀疏兴趣网络的整个过程。给定用户的行为序列，我们首先从概念池中激活他/她喜欢的概念原型。然后执行意图分配以估计与输入序列中的每个项目相关的用户意图。然后，应用自关注层计算所有项目的关注度权重，用于下一项目预测。最后，根据公式5，通过加权和生成用户的多个兴趣嵌入。
第二个模块 在稀疏兴趣提取模块之后，我们得到每个用户的多个兴趣嵌入。一个自然的后续问题是如何利用各种兴趣进行实际推理。一种直观的解决方案是使用下一个预测项作为目标标签，以选择不同的兴趣嵌入进行训练[24]。尽管它很简单，但它的主要缺点是在推理过程中没有目标标签，这导致训练和测试之间的差距，并可能导致性能退化。
针对这一问题，我们提出了一种基于主动预测的自适应兴趣聚合模型。这里的动机是，更容易预测用户基于时间偏好的下一步意图，而不是找到理想的标签。具体地说，基于在公式3中计算的意图分配分数ptk,我们可以得到行为序列中所有项目的意图分布矩阵，表示为pu，
xu拔 是用户意图序列
不同兴趣的聚合权重计算如下
e是是不同兴趣的注意力载体。
The final user representation
整体思路 1.通过输入的序列中找到pool中最相关的K个concept得到Cu
2.Cu所选中的K跟每一个item发生的关系来生成pkt,ptk(捕捉item与attention的关系)，然后用公式5得到特定用户意图的embedding
3 得到K个意图嵌入后，利用pool得到下一个意图后，与之前的K个意图做一个attention，最后加权求和得到Vu
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ab20967d555fc54571401fe391b5fb5/" rel="bookmark">
			《软件工程导论》第一章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、软件工程学概述 1.1软件危机 1、为了更有效地开发与维护软件，软件工作者在20世纪60年代后期开始认真研究消除软件危机的途径，从而逐渐形成了一门新兴的工程学科——计算机软件工程学（通常简称为“软件工程”）
2、1968年北大西洋公约组织的计算机科学家在西德召开国际会议，讨论软件危机问题，在这次会议正式提出并使用了“软件工程”这个名词，一门新兴的工程学科就此诞生了。
3、软件危机的定义： 软件危机是指在计算机的开发和维护过程中所遇到的一系列严重问题。
4、概括地说，软件危机包含下述两方面问题：
如何开发软件，以满足社会对软件日益增长的需求。如何更有效地维护数量不断膨胀的已有软件。 5、 软件危机的典型表现：
对软件开发成本和进度的估计常常很不准确；用户对“已完成的”软件系统不满意的现象经常发生；软件产品的质量往往靠不住；软件常常是不可维护的；软件通常没有适当的文档资料；软件成本在计算机系统总成本中所占比例逐年上升；软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势。 6、 产生软件危机的原因：
客观原因
1.软件不同于硬件，它是计算机系统中的逻辑部分而非物理部分；
2.软件较难维护；
3.软件不同于一般程序，它的一个显著特点是规模庞大，而且程序复杂性将随着程序规模增加而呈指数上升。主观原因
1.忽视软件需求分析的重要性；
2.错误的认为软件开发就是写程序；
3.轻视软件维护； 7、详细设计是决定编码质量的关键；做好软件定义时期的工作，是降低软件成本提高软件质量的关键；编写程序所需的工作量只占软件开发全部工作量的10%-20%；测试占40%-50%；实际上用于软件维护的费用占软件总费用的55%-70%；软件工程学的一个重要目标就是提高软件的可维护性，减少软件维护的代价。
8、 消除软件危机的途径：
首先应该对计算机软件有一个正确的认识，软件是程序、数据及相关文档的完整集合；必须充分吸取和借鉴前人行之有效的原理、概念、技术和方法；推广使用在实践中成功的技术和方法；开发和使用更好的软件工具；既要有技术措施（方法和工具），又要有必要的组织管理措施。软件工程正是从管理和技术两方面研究如何更好地开发和维护计算机软件的一门新兴学科。 1.2软件工程 1、软件工程是指导计算机软件开发和维护的一门工程学科，该学科的目的是生产出能按期交付的、在预算范围内的、满足用户需求的、质量合格的软件产品。
2、软件工程的本质特性：
软件工程关注于大型程序的构造；软件工程的中心课题是控制复杂性；软件经常变化；开发软件的效率非常重要；和谐地合作是开发软件的关键；软件必须有效地支持它的用户；在软件工程领域中通常由具有一种文化背景的人替具有另一种文化背景的人创造产品。 3、 软件工程的基本原理：
用分阶段的生命周期计划严格管理；坚持进行阶段评审；实行严格的产品控制；采用现代程序设计技术；结果应能清楚地审查；开发小组的人员应该少而精；承认不断改进软件工程实践的必要性。 8、通常把在软件生命周期全过程中使用的一整套技术方法的集合称为方法学，也称为泛型。
9、软件工程方法学包含3个要素：方法、工具 和 过程。
10、传统方法学也称为生命周期方法学或结构化范型，其特点是：
采用结构化技术完成软件开发的各项任务。把软件生命周期划分成若干个阶段，如何顺序地完成每个阶段的任务。每一个阶段的开始和结束都有严格的标准，对于任何两个相邻的阶段而言，前一阶段的结束标准就是后一个阶段的开始标准。在每一个阶段结束之前都必须正式严格的技术审查和管理复审。 11、传统方法学的优点：
把软件生命周期划分成若干个阶段，每个阶段的任务相对独立，而且比较简单，便于不同人员协作。使软件开发工程的全过程以一种有条不紊的方式进行，保证了软件的质量。特别是提高了软件的可维护性。采用生命周期方法学可以大大提高软件开发的成功率，软件开发的生产率也能明显提高。 12、传统方法学的缺点：
当软件规模庞大，或者对软件的需求是模糊的或会随时间变化而变化的时候，使用传统方法学开发软件往往不成功。 13、面向对象方法学
面向对象方法把数据和行为看成是同等重要的，它是一种以数据为主线，把数据和对数据的操作紧密地结合起来的方法。
把对象作为融合了数据及在数据上的操作行为的统一的软件构件。把所有对象都划分成类。按照父类与子类的关系，把若干给相关类组成一个层次结构的系统。对象彼此间仅能通过发送消息互相联系。 优点： 降低了软件产品的复杂性，提高了软件的可理解性，简化了软件的开发和维护工作，促进了软件重用。
1.3软件生命周期 1、软件生命周期由软件定义、软件开发和运行维护（也称软件维护）3个时期组成，每个时期又进一步划分成若干个阶段。
2、一个软件从定义、开发、使用和维护，直到最终被废弃，要经历一个漫长的时期，通常把软件经历的这个漫长的时期称为生命周期。
3、软件定义时期的任务是：确定软件开发工程必须完成的总目标（问题定义）；确定工程的可行性（可行性分析）；导出实现工程目标应该采用的策略及系统必须完成的功能（需求分析）；估计完成该项工程需要的资源和成本，并且制定工程进度表。软件定义时期通常进一步划分成3个阶段，即问题定义、可行性分析和需求分析。
4、开发时期具体设计和实现在前一个时期定义的软件，它通常由下述4个阶段组成：总体设计、详细设计、编码和单元测试，综合测试。其中前两个阶段又称为系统设计，后两个阶段又称为系统实现。
5、维护时期的主要任务是使软件持久地满足用户的需求，每一次维护活动本质都是一次压缩和简化了的定义和开发过程。
6、下面简要介绍软件生命周期每个阶段的基本任务。
问题定义：“要解决的问题是什么？”可行性研究：“对于上一阶段所确定的问题有行得通的解决办法吗？”进行一次大大压缩和简化了的系统分析和设计过程，也就是在较抽象的高层次上进行的分析和设计过程。可行性研究应该比较简短，这个阶段的任务不是具体解决问题，而是研究问题的范围，探索这个问题是否值得去解，是否有可行的解决方案。（可行性研究报告）需求分析：“为了解决这个问题，目标系统必须做什么”，主要是确定目标系统必须具备哪些功能。通常用数据流图、数据字典和简要的算法表示系统的逻辑模型。（需求规格说明书）总体设计：“概括地说，应该怎样实现目标系统？”总体设计又称概要设计。软件设计的一条基本原理就是，程序应该模块化，也就是说，一个程序应该由若干个规模适中的模块按合理的层次结构组织而成。因此，总体设计的另一项主要任务就是设计程序的体系结构，也就是确定程序由哪些模块组成以及模块间的关系。（总体设计说明书）详细设计：“应该怎样具体地实现这个系统呢？”也称为模块设计，详细的设计每个模块，确定实现模块功能所需要的算法和数据结构。（详细设计说明书）编码和单元测试：这个阶段的关键任务是写出正确的容易理解、容易维护的程序模块。（程序清单和单元测试报告）综合测试：关键任务是通过各种类型的测试（及相应的调试）使软件达到预定的要求。最基本的测试是集成测试和验收测试。把测试计划则是按照规格说明书的规定（通常在需求分析阶段确定），由用户（或在用户积极参加下）对目标系统进行验收。软件维护：关键任务是通过各种必要的维护活动使系统持久地满足用户的需要。4类维护活动：改正性维护、适应性维护、完善性维护、预防性维护。 1.4软件过程 1、定义：软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。
2、系统是相互关联或相互作用的一组要素。
3、过程定义了运用方法的顺序、应该交付的文档资源，为保证软件质量和协调变化所需求采取的管理措施以及标志软件开发各个阶段任务完成的里程碑。
4、生命周期模型规定了把生命周期划分成哪些阶段及各个阶段的执行顺序，因此，也成为过程模型。瀑布模型与快速原型模型的主要区别是获取用户需求的方法不同。
5、各大模型的特点、优点及缺点、应用范围：
瀑布模型： 传统软件工程方法学的软件过程，基本上可以用瀑布模型来描述。
特点：
阶段间具有顺序性和依赖性。推迟实现的观点。质量保证的观点。 优点：
强迫开发人员采用规范的技术方法。严格地规定了每个阶段必须提交的文档。每个阶段前必须正式进行严格的技术审查和管理复查。受文档约束，使软件维护容易一些，瀑布模型的成功在很大程度上是由于它基本上是一种文档驱动的模型。 缺点：
在可运行的软件产品交付给用户之前，用户只能通过文档来了解未来的产品是什么样的。开发人员和用户之间缺乏有效的沟通，很可能导致最终开发出的软件产品不能真正满足用户的需求。 应用范围：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ab20967d555fc54571401fe391b5fb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae46cf584dee5373bf8c6d7f899b7ba4/" rel="bookmark">
			CMMI五个成熟度级别和对应22个过程域（PA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CMMI五个成熟度级别和对应22个过程域（PA） 1.初始级-inital 特点：软件开发过程是无序的，成功全靠个人。被动
过程域：无
2.已管理级-managed 特点：项目得到了计划，执行，度量和控制。主动
过程域：7个过程域（如下表所示1.1）3个项目管理，3个支持，1个工程
过程域中文名称过程域英文名称过程类型需求管理（RM）Requirements Management工程项目规划（PP）Project Planning项目管理项目监控（PMC）Project Monitoring and Control项目管理供应商协议管理（SAM）Supplier Agreement Management项目管理度量分析（MA）Measurement and Analysis支持过程和产品质量保证（PPQA）Process and Product Quality Assurance支持配置管理（CM）Configuration Management支持 表1.1
3.已定义级-defined 特点：所有项目均使用经批准裁剪的标准软件过程来开发和维护软件产品的生产。被动
过程域：11个过程域（如下表1.2所示）5个工程，3个过程管理，2个项目管理，1个支持
过程域中文名称过程域英文名称过程类型需求开发（RD）Requirements Development工程技术方案（TS）Technical Solution工程产品集成（PI）Product Integration工程验证（VER）Verification工程确认（VAL）Validation工程组织过程焦点（OPF）Organizational Process Focus过程管理组织过程定义（OPD）Organizational Process Definition过程管理组织培训（OT）Organizational Training过程管理集成化项目管理（IPM）Integrated Project Management项目管理风险管理（RSKM）Risk Management项目管理决策分析与解决方案（DAR）Decision Analysis and Resolution支持 表1.2
4.量化管理级-quantitatively managed 特点：这时候所有的改进目标是可以预测的，过程得到了度量并受控
过程域：2个过程域（如下表1.3所示）1个过程管理，1个项目管理
过程域中文名称过程域英文名称过程类型组织过程性能（OPP）Organizational Process Performance过程管理定量项目管理（QPM）Quantitative Project Management项目管理 表1.3
5.持续优化级-optimizing 特点：这时候组织关注的点是在于如何改进，围绕机会与变化进行响应，过程稳定且灵活
过程域：2个过程域（如下表1.4所示）1个过程管理，1个支持
过程域中文名称过程域英文名称过程类型组织革新与推广（OID）Organizational Innovation and Deployment过程管理原因分析与解决方案（CAR）Causal Analysis and Resolution支持 表1.4
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afdbb4e55def9ffef17a3e6cd4f763c3/" rel="bookmark">
			对标企业采购的三大变化，你落伍了吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		采购正在成为一个全新的游戏，新的规则需要前几代所不具备的新技能集。事实是，行业以外的人对采购角色和价值的定义发生了巨大的变化。采购已从职能性工作演变为战略性工作。
采购曾经是一项职能性工作，团队成员发出冗长的请求建议书（RFP），并在做出采购决定之前审查所有的答复。这个过程通常需要数周或数月的评估，然后才会将结果和建议提交给执行团队或其他内部利害关系人。
但今天，采购的角色发生了巨大的变化，尤其是在过去十年，主要是因为引进了SaaS和其他基于云的交付模型，这些模型完全改变了企业选择和部署现代技术的方式。
随着软件电子采购和SaaS交付模式在十多年前的引入，采购团队转移了重点和优先事项。采购部门别无选择，只能采用电子采购或SaaS处理方式，这意味着对新技术的内部评估采用更便捷的流程。
如今，采购超越了原有的职能性工作根源，成为企业组织及其IT部门的重要战略工作。
3种方式-采购角色将继续演变
采购角色在寻源过程中持续演变，采购团队需要接受几个重大变化。在这里，我们总结了3个我们认为正在发生的变化。
1.采购将获得更大的影响力和可见性
寻源以前由IT部门负责，然而，采购在这个过程中变得更像是一种战略资产。因此，它的影响力越来越大，IT企业开支预算正在重新评估，确定成本节约和潜在的合并领域。
在某些情况下，IT 采购属于较大采购机构以外的采购类别，拥有指定的主管和团队。整合成本的最有效方法之一是使用SaaS 支出管理平台，查找和处理企业内的冗余应用程序。
2.采购团队需要增加专业知识
在当今的SaaS和基于云的世界，评估新技术时需要考虑许多方面，每个部门的要求通常是不同的，甚至部门内部的功能也有所不同。
如果采购涉及新的技术采购流程，那么对于采购团队来说，与IT部门建立牢固的关系以及积累做出明智决策所需的知识应该是头等大事。
如果各部门自行支付新的订阅费，那么利用SaaS管理平台跟踪部门和个人支出非常重要。
3.采购需要量化节约和创造价值
为了让采购团队发展壮大，并保持其对企业组织和IT部门的战略资产地位，关键是让他们少参与实际的软件采购和精确的决策制定，多参与整个企业的价值创造。
在当今的技术环境中，采购团队将自己与量化节约联系在一起，例如减少未使用的许可证、整合平台和确保所有系统相互连接，从而为IT和整个企业创造巨大的价值。
现代化采购技术
在如今的信息化时代，企业需要紧跟时代的发展步伐，利用现代化SaaS技术，更好地进行资源整合，提升企业采购效益，才能在日益激烈的市场竞争下，生存和保持市场竞争力。
8MSaaS SRM电子采购平台集电子招投标、采购及供应商管理为一体，为企业打造从供应、采购到交付的一站式采购管理平台，帮助企业完成从职能采购到战略采购的转变，实现电子化、信息化采购流程，提升企业竞争优势。
8MSaaS SRM支持电子招投标、询比价、竞价、协议价等不同类型的采购，提供采购全过程管理，包括采购申请与审批流程、采购定价、采购订单，发货、收货、验收入库、发票与付款管理以及采购产品基准价等管理，帮助企业实时掌控采购进度和情况。
与福特式供应链模式不同，8MSaaS SRM使用供应商绩效模式，使结果最优化。其业务直通能力能够最小化潜在欺诈，尽早地提供及发送分析。
系统能让用户、采购商和供应商直接在线协作，完成电子寻源、电子招投标和电子合同签订，实现了从需求申请到采购过程再到合同/订单付款的全流程、全电子化管理。并自动打通各部门之间的信息共享与流通，加强采购各环节的监控，实现公开透明、科学高效采购。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13e0fcbf4b9fcab7803ec3f1553f27c6/" rel="bookmark">
			Kbengine介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kbengine游戏引擎 前景游戏引擎的底层介绍github地址：Kbengine框架的优缺点：结构介绍：组件介绍： 前景 这里介绍呢，我是在kbengine原代码上有做修改，原基础上只支持webscoket通信，现在添加了http通信和Async实现异步分布式web框架 游戏引擎的底层介绍 kbengine底层架构很庞大功能很完善。底层采用c++，而写逻辑只需要使用python，大家都知道python是一种开发效率非常高的语言，所以你只要写python代码就不用考虑底层如何实现。kbengine底层架构被设计为多进程分布式动态负载均衡方案， 理论上只需要不断扩展硬件就能够不断增加承载上限，单台机器的承载上限取决于游戏逻辑本身的复杂度。网络层被底层封装的很好，在写逻辑的时候几乎可以忘记rpg等细节过程，远程访问非常方便，但是目前官网和论坛已经无法访问，具体原因不是很清楚。
github地址： https://github.com/kbengine/kbengine
Kbengine框架的优缺点： 框架结构非常专业，但是同时非常厚重。 编译时间很长，服务器启动时间也很长（10~20秒），部署也非常麻烦（在linux上面要安装openssl，编译python，设置环境变量）部署方面只是环境编辑时间上有点蛋疼，操作步骤没有几下分布式并不仅仅体现在多个逻辑服务器上面，而体现在多个逻辑服务器（场景服务器）数据可互通。 这个也是KBEngine非常强大的地方。python作为脚本语言，我如果仅仅是实现简单的逻辑还没什么问题。但是一旦我所有的服务器逻辑都是python来实现了，那么性能就会成为问题，甚至可能还不如Node.js性能高。 脚本语言比c++、java这样的静态编译的语言开发效率要高，但是实际操作起来却发现很多不顺手的地方，很多静态语言编译期就能检查出来的低级错误，现在必须运行时才发现某个变量名写错了。 在我看来服务器其实对热更新并没有那么高的需求，而且要做成安全可靠的热更新是非常困难的，客户端影响比较小还可以考虑，服务器一旦出错就成百上千倍的放大。能把配置做成热加载的，能不关服务器的情况下开启和关闭某个系统就足够了。 脚本语言除了开发效率高就是热更新方便，然而现在看来热更新需求不大，开发效率也不如使用c#+vs高效。RPC的通信方式很棒，可以让客户端和服务器以函数调用的方式来调用远程函数，而不需要考虑通信细节。 然而我非常不习惯这种方式，当需要传的数据复杂了，维护起来反而麻烦。而且传输效率上来讲肯定不如protobuf高。 如果是protobuf来维护的话，只要proto定好了，客户端和服务器共同使用，有类型修改的时候只要关注proto就可以了。 然而KBEngine中的rpc定义参数修改了需要改三处地方，并且还不是静态检查，只有运行时才能发现哪个参数定义的不一致。 另外，如果客户端和服务器都是使用python的话，应该还是比较方便的，但是客户端是c#而服务器是python，rpc反而造成了维护的不方便。数据库管理没有使用之前的原理，自己封装一套，包含有防sql注入等问题 结构介绍： 目录结构：
|- kbengine (KBE_ROOT 根目录)
|- assets (默认的游戏项目资产库，你可以添加新的资产库通过环境变量绑定)
|- res (所有资源文件)
|- spaces (通常存放游戏场景相关的资源，例如Navmesh)
|- server (通常放置服务端相关的配置文件)
|- scripts (所有的游戏逻辑，Python文件)
|- base (Base的Python逻辑)
|- cell (Cell的Python逻辑)
|- client (Client的Python逻辑)
|- bots (机器人的Python逻辑，压力测试)
|- common (逻辑公共文件夹)
|- data (游戏逻辑用到的数据资源)
|- db (dbmgr扩展脚本)
|- entity_defs (实体定义与声明)
|- interfaces (实体的接口声明)
|- server_common (服务端逻辑公共)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13e0fcbf4b9fcab7803ec3f1553f27c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d8ab7196406cb7fc9a94d65bbeacb22/" rel="bookmark">
			linear-gradient()图像渐变属性详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于linear-gradient()我学习的时候，查了很多资料，但是发现不管是网上还是一些书籍，都没有将这个属性的运用讲得明白，清楚，对此，我写了这篇博客，虽然不能保证每一位读者都能够看懂，但是也希望这篇博客能为你提供一些帮助，如有问题，请在博客中提出，谢谢。
首先给大家讲的就是兼容性，在IE浏览器中这个属性的设置是不兼容的，当然在IE浏览器中也可以实现类似的效果，那边是滤镜(fliter)的作用了.其他的不同的浏览器也是有不同的，比如chrome一般要加-webkit-前缀，如：-webkit-linear-gradient，比如opera就是-o-linear-gradient。
linear-gradient是属于CSS3中Gradient中的两个属性一个，这两个属性分别为linear-gradient（线性渐变）和radial-gradient（径性渐变）,其中linear-gradient线性渐变呈现线性变化，大家一看名称就可以知道这相当于是直线变化，比如充左上角到右下角的变化，或者从上到下，而radial-gradient径性渐变呈现径性变化，这便是大家经常见到的圆圈渐变效果，从图像的中间向四周进行变化，像是大家仍块石头到河里荡起的涟漪一样。而本片博客则是讲解linear-gradient,当然，linear-gradient和radial-gradient是相通的，他的使用方法一样，则是呈现的效果不同而已。
如下是简单的linear-gradient的使用
代码：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;linear-gradient&lt;/title&gt; &lt;style type="text/css"&gt; *{margin:0;padding:0;} .posDir{margin:100px auto;} .linearBar{width:100px;height:100px;border:1px solid #ccc; background-image:linear-gradient(45deg, #000,#fff); /*********************************偏向角度,起始点颜色,终止点颜色***************/ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="linearBar posDir"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 这里提到了background-image:对这个属性进行linear-gradient,简单的说这个linear-gradient设置是针对图片的，所以必须是放图片的属性才能运用这个linear-gradient进行设置.
除了以上的角度使用(40deg),除此之外，还有提供的一些类似于C语言中的常量的东西,如下:
linear-gradient(left bottom, #000, #fff); 将代码中的 background-image改为如上代码，会呈现如下效果:
如此，这效果，是#99CC33, #FF6666,#336699,#FF0033均匀分布产生的结果，自然默认是均匀的，那么自然也存在不均匀的，这就需要我们自己设置了，这也是网上资料坑爹的地方，他们没有对这一属性的使用进行简单明了的讲解，所以我来插一脚，写一个:
background-image: linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent); 大家看着这个代码可能会有点迷糊，这是什么，写得也太长了，但是我想说的是，这个东西基本就是不均匀自主控制渐变的一个典型例子，首先，大家要明确一个概念，就是第一个 rgba(255,255,255,.15) 25%,说的是从左下角开始起到 25%为 rgba(255,255,255,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d8ab7196406cb7fc9a94d65bbeacb22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ee9b4af706c9b0af89c72fe3b93d341/" rel="bookmark">
			java 把JSON字符串转成List集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 List&lt;String&gt; thermocline = new ArrayList&lt;&gt;(); thermocline = JSONArray.parseArray(jSONObject.get("allTemperature").toString()).toJavaList(String.class) 集合转数组
List&lt;Long&gt; oneOrderIds = new ArrayList&lt;Long&gt;() Long[] long = oneOrderIds.toArray(new Long[oneOrderIds.size()]) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f442d65880a2cb35701a245222c24b9/" rel="bookmark">
			java object 转换date类型_java中，Date数据类型和JSONObject数据类型之间的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.text.SimpleDateFormat;
import java.util.Date;
import net.sf.json.JSONObject;
public class DateTest {
public static void main(String[] args) {
Date d = new Date();
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
String str= dateFormat.format(d);//将date类型转换为string类型：2015-10-15 05:00:53
System.out.println(str);
//{"date":15,"day":4,"hours":17,"minutes":3,"month":9,"seconds":12,"time":1444899792796,"timezoneOffset":-480,"year":115}
JSONObject a = JSONObject.fromObject(d);//将date类型转换为jsonObject数据类型
System.out.println(a);
Date b = new Date();
b=(Date) JSONObject.toBean(a, Date.class);//将jsonObject类型转换为date数据类型
System.out.println(b);
}
}
原文：http://www.cnblogs.com/sayy/p/4882961.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad0b3447521dfcdfb7764f34dfbb4b55/" rel="bookmark">
			三天搞定射频识别技术（二）2.3寻卡防冲突选卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		寻卡防冲突 /******************************************************************************* //功 能：寻卡 //参数说明: req_code[IN]:寻卡方式 // 0x52 = 寻感应区内所有符合14443A标准的卡 // 0x26 = 寻未进入休眠状态的卡 // pTagType[OUT]：卡片类型代码 // 0x4400 = Mifare_UltraLight // 0x0400 = Mifare_One(S50) // 0x0200 = Mifare_One(S70) // 0x0800 = Mifare_Pro(X) // 0x4403 = Mifare_DESFire //返 回: 成功返回MI_OK *******************************************************************************/ char PcdRequest(unsigned char req_code,unsigned char *pTagType) { char status; unsigned int unLen; unsigned char ucComMF522Buf[MAXRLEN]; ClearBitMask(Status2Reg,0x08); //清零Status2Reg的MFAuthent Command执行成功标志位 WriteRawRC(BitFramingReg,0x07); //清零Transceive命令开始位 SetBitMask(TxControlReg,0x03); //开启天线 ucComMF522Buf[0] = req_code; //取522要执行的命令 //printf("%x\n",ucComMF522Buf[0]); //printf("%x\n",ucComMF522Buf[1]); status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&amp;unLen);//向PICC发送寻天线区内全部卡命令，并接收PICC返回的数据 if ((status == MI_OK)) if ((status == MI_OK) &amp;&amp; (unLen == 0x10))//没有错误并接接收为2个字节 { *pTagType = ucComMF522Buf[0];//取接收缓冲区的第一个字节 *(pTagType+1) = ucComMF522Buf[1];//取接收缓冲区的第二个字节 } else { status = MI_ERR; //错误 } #if PRINT printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad0b3447521dfcdfb7764f34dfbb4b55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2ddba1caa5ef8b07dbfc802ca0ada76/" rel="bookmark">
			MySQL报错[ERR] 1093 - You can‘t specify target table ‘student_info‘ for update in FROM clause 的解决办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MySQL在执行更新或者删除操作时，当条件还是该表查询出来的时候，会报
[ERR] 1093 - You can’t specify target table ‘student_info’ for update in FROM clause
这可能更新的表与查询的表为同一表会存在嵌套递归，MySQL会报上述错误。
如：
update student_info set state = 0 where id in (select id from student_info where name like '%李林%' and class_id in ('class_2','class_4','class_5','class_7','class_8')); 这时就会报 [ERR] 1093 - You can’t specify target table ‘student_info’ for update in FROM clause
解决办法是：
在同表的条件处做一层等价表的嵌套查询，这样可以避免条件也是要变更的表，具体如下：
update student_info set state = 0 where id in (select t.id from ( (select id from student_info where name like '%李林%' and class_id in ('class_2','class_4','class_5','class_7','class_8'))t ); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffc0b4ce391463070429dc4467cab9aa/" rel="bookmark">
			4. 寻找两个正序数组的中位数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。
示例 1：
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
示例 2：
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
示例 3：
输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
示例 4：
输入：nums1 = [], nums2 = [1]
输出：1.00000
示例 5：
输入：nums1 = [2], nums2 = []
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffc0b4ce391463070429dc4467cab9aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d6aa6daaffe1b734a185022e1b43967/" rel="bookmark">
			python flask框架详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flask是一个Python编写的Web 微框架，让我们可以使用Python语言快速实现一个网站或Web服务。本文参考自Flask官方文档，
英文不好的同学也可以参考中文文档
1.安装flask pip install flask 2.简单上手 一个最小的 Flask 应用如下:
from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello World' if __name__ == '__main__': app.run() 代码解析：
1、首先我们导入了 Flask 类。 该类的实例将会成为我们的 WSGI 应用。
2、接着我们创建一个该类的实例。第一个参数是应用模块或者包的名称。如果你使用 一个单一模块（就像本例），那么应当使用 name ，因为名称会根据这个 模块是按应用方式使用还是作为一个模块导入而发生变化（可能是 ‘main’ ， 也可能是实际导入的名称）。这个参数是必需的，这样 Flask 才能知道在哪里可以 找到模板和静态文件等东西
3、然后我们使用 route() 装饰器来告诉 Flask 触发函数的 URL 。
4、函数名称被用于生成相关联的 URL 。函数最后返回需要在用户浏览器中显示的信息。
运行结果：
* Serving Flask app "flask_demo" (lazy loading) * Environment: production WARNING: This is a development server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d6aa6daaffe1b734a185022e1b43967/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79143d6457ca77bf527d28b9169b0ddc/" rel="bookmark">
			SpringMVC运行流程图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 流程图 学习SpringMVC有一些日子了 ，到最后看到这张图（感谢尚硅谷），详细介绍了SpringMVC的运行流程。下面我想结合HelloWorld介绍一下在Idea中的运行流程。会附上详细的debug全过程。 项目结构图如下： 1.用户向服务器发送请求，请求被SpringMVC前端控制器DispatcherServlet捕获。 2.DispatcherServlet对请求URL进行解析,判断请求URL对应的映射： ①.映射不存在： a.在判断是否配置了&lt;mvc:default-servlet-handler&gt;(连同&lt;mvc:annotation-driven&gt;一起配置，否则出错) b.如果没配置,则控制台报映射查找不到,客户端展示404错误 c.如果有配置，则执行目标资源(一般为静态资源，如:JS,CSS,HTML) (上图中的断点的标记会在下面的图中给出) 配置了&lt;mvc:default-servlet-handler&gt; 没有配置&lt;mvc:default-servlet-handler&gt; 配置了&lt;mvc:default-servlet-handler&gt;之后DispatcherServlet的handlerMappings中多了一个SimpleUrlHandlerMapping，这个SimpleUrlHandlerMapping回去查找对应的目标资源(该项目中abc.html为静态资源，为验证所用)。 ②.映射存在： 执行下面流程 3.根据该URI,调用HandlerMapping获得该Handler配置的所有相关的对象(包括Handler对象以及Handler对象对应的拦截器),最后以HandlerExecutionChain对象的形式返回。 4.DispatcherServlet根据获得的Handler,选择一个合适的HandlerAdapter。 下面的这段debug用于解释 3，4. { 使用debug模式启动整个项目： 1.首先在@Controller标记的类的目标方法中标记断点： 2.点击index页面的helloworld，执行到断点，如下图所示 3.在debugger Frames窗口中，找到如下一行代码：doDispatch(方法):DispatcherServlet(类) (在debug调试中Frames中的代码执行顺序是从下往上的) 4.在doDispatch方法中找到这一行，并打上断点。该方法中的mappedHandler是HandlerExecution的实例。 5.点开getHandler方法(Ctrl+鼠标左键)，在下面的两处打上断点。 第一处断点 可以查看HanlderMappings有多少个HandlerMapping。 第二处断点 可以查看根据哪一个HandlerMapping生成的HandlerExecutionChain实例 6.在getHandler()的下一行打上断点 返回的HandlerExecutionChain实例如下图所示 7.根据HandlerExecutionChain实例，得到HandlerAdapter } 5.如果成功获得HandlerAdapter后，此时将开始执行preHandler()方法(前提是定义了拦截器) 6.提取request中的模型数据，填充目标方法的入参，开始执行目标方法，处理请求。(可能会用到HttpMessageConveter@RequestBody@ResponseBody，数据类型转换，数据类型格式化(配置FormattingConversionService)，数据验证JSR303用hibernate validator实现) 7.Handler执行完成后，向DispatcherServlet返回一个ModelAndView对象 8.执行拦截器的postHandle()方法 { 5，6，7，8的断点图如下图所示 } 9.执行processDispatchResult()方法 10.进入processDispatchResult()方法，先判断是否有异常(如果有异常就用handlerExceptionResolver解决)，在进行渲染 11.进入render()方法内部通过视图解析器(一般都是InternalResourceViewResolver)解析ModelAndView，从而确定跳转的view。 12.往下走，调用view.render()方法。 13.在view.render()方法中会通过调用AbstractView类中的exposeModelAsRequestAttribute()方法，将ModelAndView中的model放入到request域中 14.最后调用afterCompletion()方法 (该方法在processDispatchResult中) 到此结束。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0a32e07d1e964c86ac0436a6626cd81/" rel="bookmark">
			懒汉模式和饿汉模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		饿汉式PK懒汉式
1.饿汉式线程安全
2.懒汉式存在线程风险
懒汉式存在线程风险解决方法：
1.同步锁
2.双重校验锁
3.静态内部类
4.枚举
.单例模式的优点:
1.在内存中只有一个对象，节省内存空间
2.避免频繁的创建销毁对象，提高性能
3.避免对共享资源的多重占用
单例模式缺点:
1.扩展比较困难
2.如果实例化后的对象长期不利用，系统将默认为垃圾进行回收，造成对象状态丢失。
单例模式使用场景:
1.创建对象时占用资源过多，但同时又需要用到该类对象
2.对系统内资源要求统一读写，如读写配置信息
3.当多个实例存在可能引起程序逻辑错误，如号码生成器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4a2da02082053b06d251f1bd3209baa/" rel="bookmark">
			电容104是多大？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电容104是0.1uF大小的电容，也就是100000pF大小的电容。计算方法是10乘以10的4次方的100000，单位是pF。这种方法为数学计数法。
电容容值单位转换：1法拉(F)=1000毫法(mF)；1毫法(mF)=1000微法(μF)；1微法(μF)=1000纳法（nF）；1纳法（nF）=1000皮法(pF)；即：1F=1000000μF；1μF=1000000pF。
扩展资料
电容容量标示的方法：
直标法是用数字和单位符号直接标出。如1uF表示1微法，有些电容用“R”表示小数点，如R56表示0.56微法。数学计数法是用三位数字标示，第一位和第二位数字为有效数字，第三位数字为倍数。
文字符号法是用数字和文字符号有规律的组合来表示容量。如p10表示0.1pF、1p0表示1pF、6P8表示6.8pF、2u2表示2.2uF。色标法是用色环或色点表示电容器的主要参数，电容器的色标法与电阻相同。
电容的作用
1、旁路
旁路电容是为本地器件提供能量的储能器件，它能使稳压器的输出均匀化，降低负载需求。 就像小型可充电电池一样，旁路电容能够被充电，并向器件进行放电。
为尽量减少阻抗，旁路电容要尽量靠近负载器件的供电电源管脚和地管脚。 这能够很好地防止输入值过大而导致的地电位抬高和噪声。地电位是地连接处在通过大电流毛刺时的电压降。
2、去耦
去耦，又称解耦。 从电路来说， 总是可以区分为驱动的源和被驱动的负载。如果负载电容比较大， 驱动电路要把电容充电、放电， 才能完成信号的跳变。
在上升沿比较陡峭的时候，电流比较大， 这样驱动的电流就会吸收很大的电源电流，由于电路中的电感，电阻（特别是芯片管脚上的电感，会产生反弹），这种电流相对于正常情况来说实际上就是一种噪声，会影响前级的正常工作，这就是所谓的“耦合”。
去耦电容就是起到一个“电池”的作用，满足驱动电路电流的变化，避免相互间的耦合干扰。
将旁路电容和去耦电容结合起来将更容易理解。旁路电容实际也是去耦合的，只是旁路电容一般是指高频旁路，也就是给高频的开关噪声提高一条低阻抗泄防途径。
高频旁路电容一般比较小，根据谐振频率一般取0.1μF、0.01μF 等；而去耦合电容的容量一般较大，可能是10μF 或者更大，依据电路中分布参数、以及驱动电流的变化大小来确定。
旁路是把输入信号中的干扰作为滤除对象，而去耦是把输出信号的干扰作为滤除对象，防止干扰信号返回电源。这应该是他们的本质区别
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bb260d1964fa349840e31cc69d97692/" rel="bookmark">
			Ubuntu创建文件夹快捷方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WIN老用户习惯了，建个快捷方式在桌面有点小方便，下面是操作。
English Version
Tell you how to create Ubuntu file shortcuts
方法 按住
Ctrl + Shift
然后使用鼠标 左键
拖动文件夹到指定位置
成功后，该文件夹左下角会出现 一个黑色箭头 。
对于双系统用户来说，如果文件夹不在Ubuntu的默认硬盘里，你需要打开文件夹所在硬盘，该快捷方式才能生效，否则会出现以下错误：
参考 How to create desktop shortcut launcher on Ubuntu 18.04 Bionic Beaver Linux
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a41f559d5c87f151311208fbe17aa584/" rel="bookmark">
			GPIO的两种引脚规则：BCM与BOARD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树莓派(raspberry)针脚在python中BCM与BOARD模式的区别：
在python程序中定义的GPI针脚有两种模式：① BCM模式；② BOARD模式。
① BCM模式：
例如：GPIO.setmode(GPIO.BCM)测试结果如下：物理针脚11脚对应GPIO17脚；物理针脚12脚对应GPIO18脚。
测试命令如下：
#sudo ipython
#import RPi.GPIO as GPIO
#GPIO.setmode(GPIO.BCM)
#GPIO.setup(17,GPIO.OUT)
#GPIO.output(17,GPIO.HIGH) #GPIO.output(17,GPIO.LOW)
测试结果：物理针脚11脚，输出高电平
下面[SyntaxError: invalid syntax]是因为我没有安装模块(第三方模块)在GPIO17号引脚上。
In[5]所报的错误也是由于在上面一步中未安装模块(第三方模块)所以报错了。注：只要安装上第三方模块这一问题就可得到解决。
② BOARD模式：
例如：GPIO.setmode(GPIO.BOARD)测试结果如下：物理针脚13脚对应GPIO13脚；物理针脚12脚对应GPIO12脚。
#sudo ipython
#import RPi.GPIO as GPIO
#GPIO.setmode(GPIO.BOARD )
#GPIO.setup(11,GPIO.OUT)
#GPIO.output(11,GPIO.HIGH)#GPIO.output(11,GPIO.LOW)
测试结果：物理针脚11脚，输出高电平
因此，树莓派中的GPIO物理针脚对应python中两种模式的逻辑针脚。
[在占位符中有两种方法进行引用GPIO的信号，所以我们需要使用setmode()方法来进行设置使用哪一种方法：]
GPIO接口的引脚号：GPIO.setmode(GPIO.BOARD) #物理引脚
Broadcom芯片的GPIO信号数：GPIO.setmode(GPIO.BCM) #GPIO信号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ef60652e60644e9fbd4b9e45b8d48d1/" rel="bookmark">
			SQL笔试经典50题及答案解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[转]SQL笔试经典50题及答案解析 建表语句
create table Student(sid varchar(10),sname varchar(10),sage datetime,ssex nvarchar(10));
insert into Student values('01' , '赵雷' , '1990-01-01' , '男');
insert into Student values('02' , '钱电' , '1990-12-21' , '男');
insert into Student values('03' , '孙风' , '1990-05-20' , '男');
insert into Student values('04' , '李云' , '1990-08-06' , '男');
insert into Student values('05' , '周梅' , '1991-12-01' , '女');
insert into Student values('06' , '吴兰' , '1992-03-01' , '女');
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ef60652e60644e9fbd4b9e45b8d48d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43be3ba79ec51636d062c81b80d47d19/" rel="bookmark">
			解决zabbix5.0监控项 ICMP 报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决zabbix5.0监控项 ICMP 报错问题
zabbix是通过fping命令去ping主机IP的存活状态
alive 返回1
[root@Zabbix ~]# fping 114.114.114.114
114.114.114.114 is alive
如出现
fping failed:file no output
fping failed:Fping6 Address family for hostname not supported
可以更新fping版本
查看当前安装的fping
[root@Zabbix ~]# rpm -qa|grep fping
fping-2.4-1.b2.3.el6.rf.x86_64
#卸载
[root@Zabbix ~]# rpm -e fping
[root@Zabbix ~]# rpm -qa|grep fping
然后下载安装新版本
wget http://fping.org/dist/fping-5.0.tar.gz
tar -zxvf fping-5.0.tar.gz
./configure
make &amp;&amp; make install
#因为zabbix_server.conf是配置了fping的路径的，所以需要做链接，这样不用重启zabbix
ln -s /usr/local/sbin/fping /usr/sbin/fping
查看安装的版本
fping -v
fping: Version 5.0
然后重新点击现在检查 ICMP就正常了。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/324/">«</a>
	<span class="pagination__item pagination__item--current">325/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/326/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>