<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0a83e0d6f1d4df9d5536ca1cf124699/" rel="bookmark">
			相差为2的两个素数称为孪生素数。例如，3与5，41与43等都是孪生素数。设计程序求出指定区间上的所有孪生素数对。区间上限和下限由键盘获取。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
int Prime(int n);
int main()
{ long begin, end, i, j;
printf("Please input c and d(c&gt;2):");
scanf("%ld,%ld", &amp;begin, &amp;end);
for (i = begin; i &lt;= end-2; i++)
{ if (Prime(i)&amp;&amp;Prime(i+2))
{ printf("(%ld,%ld)", i, i+2);
}
}
return 0;
} int Prime(int n)
{ int i;
for ( i = 2; i &lt;= sqrt(n); i++)
{ if (n % i == 0)
{ return 0; }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0a83e0d6f1d4df9d5536ca1cf124699/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab23562e82994e8b9e7ed584d6d8c9bd/" rel="bookmark">
			JMeter&#43;InfluxDB&#43;Grafana 搭建可视化性能实时监控平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、用jmeter做并发测试，执行出来的报告太过粗糙，视图简陋，针对长时间的疲劳测试很难及时察看执行过程中的情况，搭建可视化页面，监控实时数据，能够储存和对比测试结果 二、简述 1、Influxdb是一种时序数据库，用来存放监控数据；我们需要搭建这个时序数据库服务，用来存放监控jmeter执行结果 1.1、Influxdb安装和部署 (windows10 64位操作系统)
下载地址：Get InfluxDB | #1 Ranked Time Series Database | InfluxData
1.2、修改influxdb.conf配置文件
修改时，注意文件内容原来的格式，别改错了，保存修改后的配置文件
1.3、启动Influxdb服务
看到这个页面，就说明Influxdb服务启动成功了，这个页面不要关，重新打开一个cmd窗口，敲Influx命令
1.4、 Influxdb自带一个客户端程序influx，可用来连接Influxdb数据库，进行增删改查等操作数据库，语法和sql语法相同 创建一个“jmeter”库(用于储存jmeter测试结果)
&gt; show databases # 查看所有数据库
&gt; create database "jmeter" # 创建数据库
&gt; use jmeter # 切换数据库
&gt; create uesr "admin" with password 'admin' with all PRIVILEGES # 创建管理员权限的用户
2、搭建好influxdb后，在Jmeter中连接Influxdb，将Jmeter执行结果数据储存到Influxdb；Jmeter连接Influxdb是通过后端监听器建立连接 配置说明
2.1、Influxdb默认端口是8086，db=jmeter 是刚才创建的数据库名称jmeter
2.2、application：可根据需要自由定义，只是注意后面在 Grafana 中选对即可
2.3、measurement：表名，默认是 jmeter ，也可以自定义
2.4、summaryOnly：选择true的话就只有总体的数据，false会将每个transaction都分别记录Backend Listener的默认百分位设置为“90;95;99”，即百分位数为90％，95％、99％
3、influx连接数据库后，需要切换到我们创建的jmeter库中；使用查询命令：select * from jmeter JMeter和Infludb连接正常的话，执行查询语句会显示查询到数据，显示空的说明连接又有问题，需要检查前面的步骤
三、Grafana安装和部署 1、Grafana是一个跨平台的开源的度量分析和可视化工具，通过将采集的数据查询然后可视化的展示。利用Grafana连接Influxdb数据库，将Jmeter执行结果生成美观的视图 下载地址：Download Grafana | Grafana Labs
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab23562e82994e8b9e7ed584d6d8c9bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4fcb01a7e8442ee6fad8f451c9ed011/" rel="bookmark">
			扫雷游戏（保姆式教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：说到扫雷游戏，小时候玩着可头疼了，玩的时候就乱点，也不知道啥意思，完全凭感觉，至今回想还挺有意思，今天带着大家小小实现一波简易版扫雷游戏。代码分为三个部分，game.h是存放声明的部分，game.c是游戏具体实现的部分，test.c是我们大概逻辑部分。
目录
❤️总体思路：
🤞1.打印菜单栏
🤞2.数组的定义
🤞3.数组的初始化
🤞4.打印数组
🤞5.布置雷
🤞6.排查雷
🤞7.game.h代码部分
🤞8.game.c代码部分
🤞9.test.c代码部分
总体思路： 扫雷游戏是在一堆格子里去排查，格子的话我们可以定义成二维数组的形式，其中这些格子包括雷，和含有多少雷的信息。如下图第一张所示,左上角就是我含有雷的个数，第二张图片上数字部分是它的周围含有几个雷。
既然有存放雷，和显示雷的信息，不如我们就定义两个数组，一个是存放雷，一个存放含雷的信息，并且这两个数组的大小是一样，为了保证位置一一对应关系，这样一来方便了改坐标的代码。我们知道当我们选择棋盘周围的坐标时，去统计周围雷信息的时候就会造成数组访问越界，所以不如我们定义的数组的时候，就多定义两行两列（左右都要所以定义两列，行是一样的道理，上下部分），但是显示的时候不能出现多出来的两行和两列。两个数组定义完就是初始化，和打印，打印完了，我们在布置雷，布置好雷就开始排雷。总体思路是这样接下来我们在去细化。
1.打印菜单栏 玩游戏都有个菜单栏，菜单栏里有选项，玩游戏或者不玩游戏，我们就来定义玩游戏选输入 1， 不玩游戏，我们输入0。接下来就写一个简易的菜单栏
// test.c 代码部分 void menu() { printf("************************\n"); printf("******** 1.play ********\n"); //玩游戏 printf("******** 0.exit ********\n"); //退出游戏 printf("************************\n"); } 菜单栏有了，接下来就是调用这个菜单栏，我们都知道玩游戏我们可以多次玩，并不是只玩以此，所以菜单栏打印的话也要放在循环里，并且一上来就有一个菜单栏，所以用到do....while循环。
补充：do......while循环就是先做一次事，再循环。
调用菜单栏如下：
// test.c 代码部分 int main() { do { menu(); //调用菜单栏 } while (); } 调用完菜单栏，接下来就是我们去选择，选择你给输入一个数吧，所以定义一个变量，来作为输入部分，代码如下：
// test.c 代码部分 int main() { int input = 0; do { menu(); printf("请选择:&gt;"); scanf("%d", &amp;input); } while (input); } 输入完之后，你肯定要接收进来，接受的结果来判断我们是否玩游戏，所以我们选择switch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4fcb01a7e8442ee6fad8f451c9ed011/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa14f13e51d60fbbd8e533f87ee379f/" rel="bookmark">
			matlab .txt转.mat，.csv转.mat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		处理数据信息需要使用不同的软件，python与matlab共同处理数据，以下是使用matlab将.txt和.csv文件转为.mat文件的代码：
clc; close all; clear all; cancerPA=importdata('cancerPA.txt') #.csv就直接输入 X.csv就行 save cancerPA.mat cancerPA; 至此，python的文件转换，matlab的文件转换都差不多经历了，期待与大家的交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57ad8267debd21c8283afc6bdfd384a6/" rel="bookmark">
			ElementUI-tooltip在表格中使用时内容不显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#ElementUI-tooltip在表格中使用时内容不显示
错误代码
&lt;el-table-column prop="teachingMon" label="星期一"&gt; &lt;template slot-scope="scope"&gt; &lt;el-tooltip class="item" effect="dark" placement="top-start"&gt; &lt;div slot="content"&gt; &lt;span&gt;{{ dateFormat(scope.row.dateMon)}}&lt;/span&gt; &lt;/div&gt; {{ dateFormat(scope.row.dateMon) | slashMonth() }} &lt;/el-tooltip&gt; &lt;/template&gt; &lt;/el-table-column&gt; 更正：
&lt;el-table-column prop="teachingMon" label="星期一"&gt; &lt;template slot-scope="scope"&gt; &lt;el-tooltip class="item" effect="dark" placement="top-start"&gt; &lt;div slot="content"&gt; &lt;span&gt;{{ dateFormat(scope.row.dateMon)}}&lt;/span&gt; &lt;/div&gt; &lt;span&gt; {{ dateFormat(scope.row.dateMon) | slashMonth() }}&lt;/span&gt; &lt;/el-tooltip&gt; &lt;/template&gt; &lt;/el-table-column&gt; ####总结： 表格内使用文字提示组件的时候{{}}中的内容需要用标签包裹，否则不显示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1bbf7cd85d5238b8db8af5cf2fc385d/" rel="bookmark">
			winform开源ui控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cxymm.net/article/ssdnif/83473045
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05e3294efed0b38f2af02abf5f549ea6/" rel="bookmark">
			分布式一致性协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAP CAP是指在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）这三个要素最多只能同时实现两点，不可能三者兼顾。
常见注册中心对比：
单主协议（不允许数据分歧）： 整个分布式系统就像一个单体系统，所有写操作都由主节点处理并且同步给其他副本。例如主备同步、2PC、Paxos 都属于这类协议。
1：zab 协议 ZooKeeper 使用该协议实现
ZAB也是对Multi Paxos算法的改进，大部分和raft相同。
2：Raft协议 etcd 使用该协议实现
raft 是目前工业界广泛使用的分布式一致性协议, 被广泛应用在分布式系统中, 例如 ETCD、TiKV、Consul 等著名开源软件都使用了 raft 协议来实现分布式系统中的强一致性, paxos 算法作为分布式一致性算法的鼻祖, 其以难以理解和很难工程化著称, raft 的作者希望设计一种更简洁的算法来替代 paxos, 使其在保证正确性和可靠性的前提下能够容易理解和实现。
Raft算法是对Paxos算法的简化和改进。
3：Paxos 协议 Paxos有个很特别的就是协调者(proposer)只需等到超过1/2(多数派)的节点同意而不是全部节点，这样只有当1/2的节点同时出现故障整个系统才会有问题，加上同时这个限定条件后，这个系统的故障概率是极低极低的。
多主协议（允许数据分歧，去中心化）： 所有写操作可以由不同节点发起，并且同步给其他副本。例如 Gossip、POW。
它们的核心区别在于是否允许多个节点发起写操作，单主协议只允许由主节点发起写操作，因此它可以保证操作有序性，一致性更强。
而多主协议允许多个节点发起写操作，因此它不能保证操作的有序性，只能做到弱一致性。
1：Gossip协议 Redis Cluster、Consul 使用了该协议
Gossip又被称为流行病算法，它与流行病毒在人群中传播的性质类似，由初始的几个节点向周围互相传播，到后期的大规模互相传播，最终达到一致性。Gossip协议被广泛应用于P2P网络，同时一些分布式的数据库，如Redis集群的消息同步使用的也是Gossip协议，另一个重大应用是被用于比特币的交易信息和区块信息的传播，Gossip算法每个节点都是对等的，即没有角色之分，Gossip算法中的每个节点都会将数据改动告诉其他节点。
2：Pow协议 比特币使用了该协议
Proof-of-work算法又被称为Pow算法，其实从这个算法的名称中我们能对它实现的功能窥见一二，工作量证明算法，那是否意味着工作量较大的某一个节点能够获得主动权呢？事实也是类似这个原理，大量的节点参与竞争，通过自身的工作量大小来证明自己的能力，最终能力最大的节点获得优胜，其他节点的信息需要与该节点统一。Pow最为人所熟知的应用是比特币，
分布式一致性协议主要分为两大类，分别是单主协议和多主协议，这里不介绍具体协议，主要是对比各协议之间的异同点，各协议与cap理论的关系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf49e5ba9a4e4544bb6619071d865b68/" rel="bookmark">
			Java关于Http请求的各种参数或行为的获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HttpServletRequest的作用及用法 http请求头以及ip、参数等信息都包含其中。
方法声明功能描述String getMethod()该方法用于获取 HTTP 请求消息中的请求方式（如 GET、POST 等）String getRequestURI()该方法用于获取请求行中的资源名称部分即位于 URL 的主机和端门之后、参数部分之前的部分String getQueryString()该方法用于获取请求行中的参数部分，也就是资源路径后问号（？）以后的所有内容String getContextPath()该方法用于获取请求 URL 中属于 Web 应用程序的路径，这个路径以 / 开头，表示相对于整个 Web 站点的根目录，路径结尾不含 /。如果请求 URL 属于 Web 站点的根目录，那么返回结果为空字符串（""）String getServletPath()该方法用于获取 Servlet 的名称或 Servlet 所映射的路径String getRemoteAddr()该方法用于获取请求客户端的 IP 地址，其格式类似于 192.168.0.3String getRemoteHost()该方法用于获取请求客户端的完整主机名，其格式类似于 pcl.mengma.com。需要注意的是，如果无法解析出客户机的完整主机名，那么该方法将会返回客户端的 IP 地址int getRemotePort()该方法用于获取请求客户端网络连接的端口号String getLocaIAddr()该方法用于获取 Web 服务器上接收当前请求网络连接的 IP 地址String getLocalName()该方法用于获取 Web 服务器上接收当前网络连接 IP 所对应的主机名int getLocalPort()该方法用于获取 Web 服务器上接收当前网络连接的端口号String getServerName()该方法用于获取当前请求所指向的主机名，即 HTTP 请求消息中 Host 头字段所对应的主机名部分int gctServcrPort()该方法用于获取当前请求所连接的服务器端口号，即 HTTP 请求消息中 Host 头字段所对应的端口号部分StringBuffcr getRequestURL() 该方法用于获取客户端发出请求时的完整 URL，包括协议、服务器名、端口号、 资源路径等信息，但不包括后面的査询参数部分。注意，getRequcstURL() 方法返冋的结果是 StringBuffer 类型，而不是 String 类型，这样更便于对结果进行修改
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf49e5ba9a4e4544bb6619071d865b68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c849743d3620fea6abacf4a2434cca96/" rel="bookmark">
			Java语法：finally中修改返回结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java的try语句在返回前将其他所有的操作执行完，保留好要返回的值，而后转入执行finally中的语句，而后分为以下三种情况：
如果finally中有return语句，则会将try中的return语句”覆盖“掉，直接执行finally中的return语句。如果finally中没有return语句，也没有改变要返回值，则执行完finally中的语句后接着执行try中的return语句。如果finally中没有return语句，但是改变了要返回的值，分以下两种情况： 如果return的是基本数据类型或引用类型，则在finally中对值或引用的改变不起作用，try中的return语句依然会返回之前保留的值。如果return的是引用类型，而在finally中修改该引用类型的属性值，try中return语句返回的对象，属性值是finally中改变后的属性值。 public class FinallyReturnTest { public static void main(String[] args) { try { System.out.println(finallyReturnBasic()); // 2 System.out.println(finallyReturnString()); // Change me! System.out.println(finallyReturnReference()); // innerB System.out.println(finallyChangeBasic()); // 1 System.out.println(finallyChangeString()); // Hello World! System.out.println(finallyChangeReference()); // innerA System.out.println(finallyChangeAttribute()); // innerB } catch (Exception e) { System.out.println(e); } } public static int finallyReturnBasic() throws Exception { int input = 1; try { return input; } catch (Exception e) { throw new Exception("test exception"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c849743d3620fea6abacf4a2434cca96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1407b5d1040337a194ba33406c13414f/" rel="bookmark">
			Web前端开发1&#43;x（中级） Bootstrap知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Bootstrap中关于弹性布局的属性错误的是（ D ）。 A、flex B、flex-wrap C、justify-content D、flex-container Flex样式： 使用.d-flex和.d-inline-flex 实现开启 flex 布局样式。 弹性容器中包裹弹性子元素可以使用以下三个类： .flex-nowrap (默认不包裹), .flex-wrap（包裹） .flex-wrap-reverse（进行项目排序顺序的倒序）。 内容排列可以设置弹性盒子内子元素的位置， justify-content-* 类用于修改弹性子元素的排列方式，* 号 允许的值有：start (默认), end, center, between 和 around。 D选项flex-container属性错误。 在Bootstrap中，（ C ）不是媒体特性的属性。 A、device-width B、width C、background D、orientation device-width属性输出设备的屏幕可见宽度。 width定义输出设备中的页面可见区域宽度。 orientation调整屏幕方向的操作。 background 设置控件的背景色，不是媒体特性的属性。 系统会自动分最多12列 Bootstrap 中显示标签的 class 的是（ B ）。 A、row B、label C、form D、level row 行内容显示，使用行在水平方向创建一组列。 label 标签主要用来显示提示信息等内容，它的基本样式通过.label类实现。 form和level不属于class类。 A.&lt;576px 像素的为超小屏幕，用 .col-xs* B.≥576px 像素的为小屏幕，用 .col-sm-* C.≥768px 像素的为中等屏幕，用 .col-md-* D.≥992px 像素的则为大屏幕，用 .col-lg-* E.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1407b5d1040337a194ba33406c13414f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cacf0799bfa47c3372035f8ec4cd6c82/" rel="bookmark">
			主流浏览器的内核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IE（Internet Explorer）浏览器：Trident内核，俗称IE内核；Chrome浏览器：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核；Firefox浏览器：Gecko内核，俗称Firefox内核；Safari浏览器：Webkit内核；Opera浏览器：最初是Presto内核，后来跟随Chrome变成Webkit内核，现在是Blink内核。 其他浏览器：
百度浏览器、世界之窗内核：IE内核；360浏览器、猎豹浏览器内核：IE+Chrome双内核；搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）；2345浏览器内核：好像以前是IE内核，现在也是IE+Chrome双内核了；UC浏览器内核：这个众口不一，UC说是他们自己研发的U3内核，但好像还是基于Webkit和Trident，还有说是基于火狐内核。。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81f7b06bf305aaba43cd69ac2a69023b/" rel="bookmark">
			模型选择&amp;&amp;模型评估
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、为什么要进行模型选择？二、模型选择1.正则化2.交叉验证 三、模型评估 一、为什么要进行模型选择？ 机器学习的三要素是模型、策略、算法。模型的训练也是尤为重要的一环。应用某种策略、使用某种算法对假设空间里的模型进行优化后，如果我们得到了不止一个模型，应该选择哪一个模型作为最终使用的模型？选择了最终模型后，其效果究竟如何？这就是模型选择和模型评估的内容。
二、模型选择 模型选择(model selection)有两层含义：一是在假设空间上训练得到的模型可能不止一个，需要从中进行选择；二是对于一个具体问题，我们可能希望尝试不同方法，于是就有了不同的模型，在这些模型训练结束后，我们需要决定使用哪一个，但这种模型选择往往需要结合模型评估方法，因为对于某种归纳偏好，不同方法下的不同模型的实现各不相同，只能根据在测试集上的最终表现效果来选择。
机器学习方法的三要素与第一层模型选择的关系：
多种机器学习方法的模型选择示意图：
也就是说，对于每一种方法，都要经历三要素及内部的模型选择，再进行模型评估和最终选择。
下面介绍监督学习中两大类模型选择的方法：正则化和交叉验证。
1.正则化 正则化(regularization)它与结构风险最小化等价，用于规避模型过拟合的问题，在模型选择中，正则化方法也同样被用来对模型复杂度进行惩罚，避免模型由于过度追求训练集上的效果而过度偏向复杂模型，导致过拟合，降低泛化能力。下图说明了模型复杂度和泛化能力之间的关系：
2.交叉验证 在样本量足够大的理想情况下，应当把数据集分割为三部分：训练集(training set)、验证集(validation set)和测试集(testing set)，分别用于模型训练、模型选择和模型评估，用于评估模型泛化能力的测试集只出现在最后的模型评估环节。但很多时候数据不够充足，这种时候可以取消验证集，采用交叉验证方法，通过反复划分训练集和测试集来避免用同一批数据训练和评估一个模型，相当于将验证集和测试集合二为一了。
交叉验证(cross validation)指的是对有限的数据集进行随机划分，利用分割后的部分组成训练集和测试集，进而重复进行模型的训练、选择和评估。常用的交叉验证法有三种：
简单交叉验证/留出法(hold-out)：将数据集按一定比例随机分为两部分：训练集和测试集，分别在其上训练和测试所有备选模型，选出测试结果最好的，这相当于用模型评估代替了模型选择，直接砍掉验证集来增加其余两个集合的样本量，简单粗暴；
K折交叉验证(k-fold cross validation)：将数据集随机划分为K个大小相同或基本相同的子集，分别把每一个子集作为测试集，其余 K-1个子集作为训练集，就得到了K 组不同的训练、测试集，在这K组训练、测试集上训练并测试每一种模型，选择平均测试误差最小的模型；有时为了避免单次随机划分的特殊性，还会进行多次随机划分，将多个交叉验证的结果再进行一次平均；
留一交叉验证(leave-one-out cross
validation)：K折交叉验证的特例，将K取为样本量N，也即把每个样本单独作为测试集，其余样本作为训练集。这种方法的计算量较大，一般仅用于数据稀少的情况。
当样本量实在过小时，可以考虑采用有放回抽样，抽取次数和原数据集样本量相等，形成一个新的样本作为训练集，而将未被抽到过的样本全体作为测试集，这种在样本量较小的情况下构造样本的想法来源于统计学中的自助法(bootstrapping)。
三、模型评估 模型评估(model assessment)是指对于一种具体方法输出的最终模型，使用一些指标和方法来评价它的泛化能力。这一步骤通常在模型训练和模型选择之后，正式部署模型之前。模型评估方法不针对模型本身，只针对问题和数据，因此可以用来评价来自不同方法的模型的泛化能力，进行用于部署的最终模型的选择。
我们评估一个模型，最关心的是它的泛化能力，对于监督学习问题，泛化能力可以用泛化误差(generalization error)来衡量，泛化误差指的是模型在训练集以外的数据上的风险函数，用数学语言表示为：
，其中 f^表示一个具体的模型，x*y表示整个样本空间或者排除训练集的整个样本空间。泛化误差越小意味着模型在样本空间上的期望损失越小，模型的泛化能力越强。
需要注意的一点是，模型评估使用的损失函数不一定是训练时的策略中使用的损失函数，但对于许多模型，两者是相同的。 但很显然，我们没法获得样本空间的总体概率分布，所以泛化误差不可实际获得，实际应用中是通过如下定义的测试误差来衡量模型的泛化能力的：
测试误差(testing error)：训练好的模型在测试集上的经验损失；训练误差(training error)：模型在训练集上的经验损失； 如果采用0-1损失函数，即 [公式]，则测试误差就变为了常用的错误率(error rate)，即 [公式]，这是分类问题常用的评估指标之一，表示模型错分的测试样本的比例，一个相应的指标是准确率/精度(accuracy)，表示模型正确分类的测试样本的比例，即 [公式]，很显然，错误率 + 准确率 = 1.
如果采用平方损失函数，即 [公式]，则测试误差就变为了样本的均方误差(mean squared error)，这是回归问题常用的评估指标之一。
理论上，对于一种机器学习方法，可以估计其能得到的模型的泛化误差上界，从而对其泛化能力有一个整体的认识，但这个界的估计非常复杂，机器学习的理论研究还在探索阶段。 下面介绍机器学习中一个重要的关系：偏差—方差权衡。
偏差—方差权衡
在统计学中，估计的均方误差可以分解为方差和偏差平方的和，对于形如 [公式] 的监督学习问题，也可以进行类似的分解，假设我们得到了 [公式] 的一个估计 [公式]，注意到 [公式]，以及随机误差与解释变量独立、与训练集的选择独立，则预测的均方误差[公式] 可以进行如下分解：
[公式]
进一步地，考虑到 [公式] 是在一个特定的训练集上训练得到的，记训练集为 [公式]，则 [公式] 还应是 [公式] 的函数，因此应记作 [公式]，因此有 [公式]，对于固定的 [公式]，可以证明有分解式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81f7b06bf305aaba43cd69ac2a69023b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56c1f37dca1fe8eb931eca6214aa24cf/" rel="bookmark">
			[c&#43;&#43;11] using用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 为什么要引入using using和typedef的作用都是为了，定义类型别名。既然有typedef了，为什么还要引入using呢？
答案：为了弥补typedef的不足。using 的别名语法也覆盖了 typedef 的全部功能，C+11标准鼓励用using，因为using比较直观。
using比typedef直观 // 重定义unsigned char
typedef unsigned char ty_uchar; using ty_uchar = unsigned char; // 重定义函数指针
typedef void (*ty_func)(int,double); using ty_func = void (*)(int, double); 从上面的对比中可以发现，C++11 的 using 别名语法比 typedef 更加清晰。using的写法把别名的名字放到了左边，而把别名指向的放在了右边，中间用 = 号等起来，非常清晰。
using可用于模板别名，而typedef不行 template &lt;typename T&gt; using ty_map_str = std::map&lt;std::string, T&gt;; ty_map_str m_map;
如果使用typedef，编译报错
template &lt;typename T&gt; typedef std::map&lt;std::string, T&gt; ty_map_str; 在 C++11之前不得不这样写：
template &lt;typename _T&gt; struct ty_str_map { typedef std::map&lt;std::string, _T&gt; map_type; }; ty_str_map&lt;int&gt;::map_type m_map; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5018c385fde6795c5197e5d1df91582c/" rel="bookmark">
			DC-1靶场渗透实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境准备
Kali虚拟机
DC-1靶场http://www.five86.com/downloads/DC-1.zip
首先将kali虚拟机和靶机DC1都设置为net模式
ifconfig查看kali的IP为192.168.152.128
使用nmap扫描此网段下的主机
启动DC-1靶机
再次扫描得到DC-1靶机的IP地址为192.168.152.138
二、实验过程
使用nmap针对该IP进行详细扫描
发现打开了22、80和111的端口，还开启了ssh服务
访问发现80端口可以访问，如图
是一个登录界面
这里很明显的可以看到
Powered by Drupal由 Drupal 提供支持，后面会用到
在使用burpsuit尝试进行爆破登录时被锁定了
使用御剑扫描也没有找到其他页面
尝试使用awvs进行扫描
发现存在远程代码执行(SA-CORE-2018-002)漏洞
使用msfconsole工具搜索该漏洞
直接在kali下调用该工具
search SA-CORE-2018-002
搜索该漏洞及利用方式
use 使用该模块
show options查看此模块中我们还需要设置的选项，为YES且空的就是还需要我们设置的
如图RHOST(目标IP地址)为YES但是还没有设置
使用set设置目标IP
Exploit进行攻击
如图攻击成功发现第一个flag，并提示我们
翻译如下
提示我们去找该CMS的配置文件
我们按渗透的常理来说一般都会尝试去看一下像账户、密码这样重要的文件，于是我们在/etc/passwd配置文件下找到一个flag4用户，在flag4用户的家目录/home/flag4下找到了flag4
根据flag1的提示我们去找此网站CMS的配置文件
前面我们发现网页有Powered by Drupal的指纹，说明此网站采用Drupal的开源内容管理框架（CMF）
搜一下drupal的配置文件
在sites/default/下
我们去到此目录
发现三个文件
逐个打开发现flag2在setting.php文件中
翻译过来就是
爆破攻击和字典攻击不是 获得访问权限的唯一方法(您将需要访问权限)。你能用这些证书做什么?
提示我们暴力破解不行，只能获取权限
同时也发现数据库的大量信息username、password等
所以接下来我们进行提权
利用python的内置模块pty中的spawn()方法
构造命令
python -c 'import pty;pty.spawn("/bin/bash")'
实现交互式shell
尝试登录MySQL数据库
登录成功
由前面发现的信息可以知道密码存放在drupaldb数据库users表中
我们可以看见用户名为admin的账户，并且看到其密码，但是被加密了
我们使用hash-identifie工具查询一下它的加密方式
新建一个终端
直接输入hash-identifie打开 粘贴admin的密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5018c385fde6795c5197e5d1df91582c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63605641d4b8070e5d5d163f77fccabf/" rel="bookmark">
			python复制文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import shutil shutil.copyfile("1.txt","2.txt") #第一个参数为被复制的文件路径 #第二个为复制后另存为的文件路径 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e33a09ea2d4bc4ae782fe189d34d03a/" rel="bookmark">
			小区选择、重选和轻松测量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.小区选择 1.1、小区选择的目的 如果UE想要获取网络服务，就需要选择一个plmn下的小区驻留。在小区搜索过程中会搜到很多的小区，需要根据小区系统消息及终端属性确认当前小区是否适合驻留，小区电平和信号质量即是评价标准之一。
NR系统有多波束的概念，所以需要测量多个波束的测量值，只有超过门限的波束测量值才会进行最后的测量量计算。
对于多波束小区重选，包括从E-UTRA重选到NR，小区信道测量从SSB波束推导出来：
如果SIB2/SIB4没有配置nrofSS-BlocksToAverage参数，或者SIB2/SIB4没有配置absThreshSS-BlocksConsolidation参数，或者最高波束测量值小于等于absThreshSS-BlocksConsolidation。则认为小区测量值为最高波束测量值，每一个波束测量量在38.215定义。
否则，小区测量量为nrofSS-BlocksToAverage个高于门限absThreshSS-BlocksConsolidation的最高波束测量量功率的线性平均值。
1.2、小区选择的S准则 如果UE想在该小区驻留，需要满足如下条件：
Srxlev &gt; 0 AND Squal &gt; 0
Srxlev = Qrxlevmeas – (Qrxlevmin + Qrxlevminoffset )– Pcompensation - Qoffsettemp
Squal = Qqualmeas – (Qqualmin + Qqualminoffset) - Qoffsettemp
其中的参数分别解析
Srxlev
Cell selection RX level value (dB)
Squal
Cell selection quality value (dB)
Qoffsettemp
Offset temporarily applied to a cell as specified in TS 38.331 [3] (dB)
临时附加偏移，根据TS 38.331定义，connEstFailOffset在SIB1中定义，如果SIB1中没有该信元，则认为Qoffsettemp为无穷大。
如果SIB1配置了connEstFailureControl信元，且T300在一个小区连续超时connEstFailCount次，则对于connEstFailOffsetValidity指示的周期内，使用connEstFailOffset作为Qoffsettemp。T300定义为从UE发送RRCSetupRequest到收到RRCSetup或RRCReject时间。
connEstFailOffset
Parameter "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e33a09ea2d4bc4ae782fe189d34d03a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d30517e39c5d1af076a93f11d994136c/" rel="bookmark">
			java获取GET和POST请求参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		URL和参数列表 一 获取请求方式
request.getMethod(); get和post都可用，
二 获取请求类型
request.getContentType(); get和post都可用，示例值：application/json ，multipart/form-data， application/xml等
三 获取所有参数key
request.getParameterNames(); get和post都可用，注：不适用contentType为multipart/form-data
四 获取参数值value
request.getParameter("test"); get和post都可用，注：不适用contentType为multipart/form-data
五 获取取参数请求集合
request.getParameterMap(); get和post都可用，注： 不适用contentType为multipart/form-data
六 获取文本流
request.getInputStream() 适用于如：application/json，xml,multipart/form-data文本流或者大文件形式提交的请求或者xml等形式的报文
七 获取URL
getRequestURL()
八 获取参数列表:
1.getQueryString()
只适用于GET,比如客户端发送http://localhost/testServlet?a=b&amp;c=d&amp;e=f,通过request.getQueryString()得到的是a=b&amp;c=d&amp;e=f.
2.getParameter()
GET和POST都可以使用
但如果是POST请求要根据&lt;form&gt;表单提交数据的编码方式来确定能否使用.
当编码方式是(application/x- www-form-urlencoded)时才能使用.
这种编码方式(application/x-www-form-urlencoded)虽然简单，但对于传输大块的二进制数据显得力不从心.
对于传输大块的二进制数这类数据，浏览器采用了另一种编码方式("multipart/form-data"),这时就需要使用下面的两种方法.
3.getInputStream()
4.getReader()
上面两种方法获取的是Http请求包的包体,因为GET方式请求一般不包含包体.所以上面两种方法一般用于POST请求获取参数.
需要注意的是：
request.getParameter()、 request.getInputStream()、request.getReader()这三种方法是有冲突的，因为流只能被读一次。
比如：
当form表单内容采用 enctype=application/x-www-form-urlencoded编码时，先通过调用request.getParameter()方法得到参数后,
再调用request.getInputStream()或request.getReader()已经得不到流中的内容，
因为在调用 request.getParameter()时系统可能对表单中提交的数据以流的形式读了一次,反之亦然。
当form表单内容采用 enctype=multipart/form-data编码时，即使先调用request.getParameter()也得不到数据，
所以这时调用request.getParameter()方法对 request.getInputStream()或request.getReader()没有冲突，
即使已经调用了 request.getParameter()方法也可以通过调用request.getInputStream()或request.getReader()得到表单中的数据,
而request.getInputStream()和request.getReader()在同一个响应中是不能混合使用的,如果混合使用就会抛异常。
九：下面附上解析multipart/form-data格式的报文方法，
示例报文如下：
解析：（利用upload方式解析的可以忽略）
/** * 解析multipart/form-data * @param res 这是通过request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d30517e39c5d1af076a93f11d994136c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be80260705af43c5032598cbdf13699/" rel="bookmark">
			docker搭建emqx服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 1. 什么是 MQTT？
MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的"轻量级"通讯协议
关键词：通讯协议
2.什么是EMQ(emqx的简称)?
EMQ X Broker 是基于高并发的 Erlang/OTP 语言平台开发，支持百万级连接和分布式集群架构，发布订阅模式的开源 MQTT 消息服务器。
关键词：消息服务器
正文 一、拉取 emqx/emqx镜像 1.1 搜索镜像 任何有关键字相关的镜像，都建议先 docker search xxx 一下，我觉得是个好习惯
docker search emqx 1.2 拉取镜像 docker pull emqx/emqx 1.3 查看镜像 docker images 二、构建 emqService 容器 2.1 docker run 命令构建 这里开放了若干个端口，端口对应协议如下,最后一个没开，但是作为了解放在下表了。
端口描述18083web端后台管理页端口1883MQTT TCP 端口8883MQTT TCP TLS/SSL 端口8083HTTP and WebSocket 端口8084HTTPS and WSS 端口8080MGMT API 端口 · MGMT 端口 ：MGMT是网络管理端口，可以直接用网线连接，登陆进防火墙以网页模式管理。
docker run -itd --name emqService -p 18083:18083 -p 1883:1883 -p 8084:8084 -p 8883:8883 -p 8083:8083 emqx/emqx 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2be80260705af43c5032598cbdf13699/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8576ca7fbc8f9eaff3d11157fd905b55/" rel="bookmark">
			opencv 图像直方图详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 理论基础一、opencv 函数支持calcHist()代码示例 理论基础 直方图
直方图是数值数据分布的精确图形表示。为了构建直方图，第一步是将值的范围分段，即将整个值的范围分成一系列间隔，然后计算每个间隔中有多少值。 这些值通常被指定为连续的，不重叠的变量间隔。 间隔必须相邻，并且通常是（但不是必须的）相等的大小。
图像直方图
图像直方图统计的可以是对描述图像有用的任何特征，如灰度值，梯度等。
直方图是图像的一个统计特征，它具有旋转、缩放、平移不变性，被应用于灰度图像的阈值分割，对比度调整，颜色匹配等等。下面以灰度图像灰度直方图说明统计的原理：
考虑以上灰度值图像，我们如何统计这些数据呢？我们知道灰度值在0 - 255范围之间总共 256 个值，可以将我们的范围划分为子部分（称为bins），例如：
计算每个bini范围内像素的数量。得到下图(x轴表示bin，y轴表示每个箱子中的像素数)。
直方图重要概念：
dim:希望收集数据的参数数量。在上面例子中，dims = 1是因为我们只计算每个像素(在灰度图像中)的强度值。
bin:在上面例子的示例中，bins = 16
range:要测量的值的限制。在本例中:range = [0,255]
一、opencv 函数支持calcHist() 计算一组数组的直方图。函数原型，三个重载函数：
CV_EXPORTS void calcHist( const Mat* images, int nimages, const int* channels, InputArray mask, OutputArray hist, int dims, const int* histSize, const float** ranges, bool uniform = true, bool accumulate = false ); /** @overload this variant uses %SparseMat for output */ CV_EXPORTS void calcHist( const Mat* images, int nimages, const int* channels, InputArray mask, SparseMat&amp; hist, int dims, const int* histSize, const float** ranges, bool uniform = true, bool accumulate = false ); /** @overload */ CV_EXPORTS_W void calcHist( InputArrayOfArrays images, const std::vector&lt;int&gt;&amp; channels, InputArray mask, OutputArray hist, const std::vector&lt;int&gt;&amp; histSize, const std::vector&lt;float&gt;&amp; ranges, bool accumulate = false ); 参数说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8576ca7fbc8f9eaff3d11157fd905b55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24832eb408d217979f6d91533b397a48/" rel="bookmark">
			OCR识别——百度飞桨PaddleOCR测试及环境搭建详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 PaddleOCR 概述一、Python 环境设置三、代码测试 PaddleOCR 概述 PaddleOCR 包含富文本检测、文本识别和端到端算法。结合现实场景和行业经验，PaddleOCR 选择 DB 和 CRNN 作为基本检测识别模型，经过一系列优化策略，提出了一系列模型，命名为 PP-OCR，用于工业应用。PP-OCR模型针对一般场景，形成不同语言的模型库。基于 PP-OCR 的能力，PaddleOCR 发布了文档场景任务的 PP-Structure 工具包，包括布局分析和表格识别两大任务。为打通产业落地全流程，PaddleOCR提供大规模数据生产工具和多种预测部署工具，帮助开发者快速将想法变为现实。
一、Python 环境设置 1.安装 conda
注意：使用PaddlePaddle需要先安装python环境，这里我们选择python集成环境conda工具包
conda 是一个常用的 python 包管理器
安装 conda 后，可以安装 python 环境，以及 numpy 等所需的工具包环境。
下载路径https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda
下载完后安装。安装之后在cmd命令行查看conda命令是否可以正常使用
2.打开终端并创建Conda环境
打开 Anaconda Prompt 终端：左下方 Windows 开始菜单 -&gt; Anaconda3 -&gt; Anaconda Prompt 启动控制台
创建一个新的 Conda 环境
#在命令行输入以下命令，创建一个名为 paddle_env 的环境 #这里为了加快下载速度，使用清华源码 conda create --name paddle_env python=3.8 --channel https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ #这是一行命令 此命令将创建一个名为 paddle_env 且 Python 版本为 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24832eb408d217979f6d91533b397a48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d933ec4ee64debbff80baff726d87d8/" rel="bookmark">
			缺陷检测——Halcon表面划痕检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.项目场景： 提取表面划痕缺陷
二.解决方案： 1.先对原始图像做中值滤波处理：
2.局部阈值处理
3.blob分析提取特征
三.halcon代码 read_image (Image, 'scratchSrc') mean_image (Image, ImageMean, 7, 7) dyn_threshold (Image, ImageMean, DarkPixels, 5, 'dark') connection (DarkPixels, ConnectedRegions) select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 10, 1000) union1 (SelectedRegions, RegionUnion) dilation_circle (RegionUnion, RegionDilation, 3.5) skeleton (RegionDilation, Skeleton) connection (Skeleton, Errors) select_shape (Errors, Scratches, 'area', 'and', 50, 10000) select_shape (Errors, Dots, 'area', 'and', 1, 50) 四.核心算法解析 dyn_threshold (OrigImage, ThresholdImage, RegionDynThresh, Offset, LightDark）
算法功能：使用局部阈值分割图像。
OrigImage：原始输入图像
ThresholdImage：平滑处理之后的输入图像
RegionDynThresh：结果输出图像
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d933ec4ee64debbff80baff726d87d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f03062f3b6f780924a0dd0963427db37/" rel="bookmark">
			opencv 矩形cv::Rect数据结构详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、源码二、cv::Rect的成员和属性1.成员2.属性 三、代码示例四、运行效果 一、源码 template&lt;typename _Tp&gt; class Rect_ { public: typedef _Tp value_type; //! default constructor Rect_(); Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height); Rect_(const Rect_&amp; r); Rect_(Rect_&amp;&amp; r) CV_NOEXCEPT; Rect_(const Point_&lt;_Tp&gt;&amp; org, const Size_&lt;_Tp&gt;&amp; sz); Rect_(const Point_&lt;_Tp&gt;&amp; pt1, const Point_&lt;_Tp&gt;&amp; pt2); Rect_&amp; operator = ( const Rect_&amp; r ); Rect_&amp; operator = ( Rect_&amp;&amp; r ) CV_NOEXCEPT; //! the top-left corner Point_&lt;_Tp&gt; tl() const; //! the bottom-right corner Point_&lt;_Tp&gt; br() const; //!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f03062f3b6f780924a0dd0963427db37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b2de00221c49a951a5f91b1e444c5e4/" rel="bookmark">
			opencv 自适应二值化cv::adaptiveThreshold()函数详解（复杂背景下提取划痕）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、opencv cv::adaptiveThreshold()函数1.函数原型：2.参数说明：3.函数原理： 代码示例 前言 从以下复杂背景图片下提取划痕
假设采用全局阈值二值化， cv::threshold(src, globalBinayImage, 150, 255, cv::THRESH_BINARY_INV)，很难得到最优的二值化效果,划痕没有完整提取出来，反而把背景也提取出来了:
这个时候就需要一种能够自适应的二值化算法上场了。
一、opencv cv::adaptiveThreshold()函数 1.函数原型： CV_EXPORTS_W void adaptiveThreshold( InputArray src, OutputArray dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C ); 2.参数说明： src：输入8位单通道图像。
dst：输出图像，大小和类型与src相同。
maxValue：满足条件的像素所分配的非零值。
adaptiveMethod：要使用的自适应阈值算法，ADAPTIVE_THRESH_MEAN_C或者ADAPTIVE_THRESH_GAUSSIAN_C
thresholdType：阈值类型，必须是THRESH_BINARY或者HRESH_BINARY_INV，指示要提取亮区域还是暗区域
blockSize：用于计算像素阈值的像素邻域的大小:3,5,7，以此类推。
C：偏移值调整量，从每个邻域计算出的平均值或高斯加权平均值中减去的常量，就是最终阈值，它可以是正的，也可以是零或负的。
3.函数原理： 算法通过计算每个像素周围blockSize x blockSize大小像素块的加权均值并减去常量C得到该像素值的最终阈值，每个像素都会有一个自适应的动态阈值。
代码示例 cv::Mat src; src = cv::imread("D:\\QtProject\\Opencv_Example\\adaptiveThreshold\\adaptiveThreshold.png", cv::IMREAD_GRAYSCALE); if (src.empty()) { cout &lt;&lt; "Cannot load image" &lt;&lt; endl; return; } //全局二值化 cv::Mat globalBinayImage; cv::threshold(src, globalBinayImage, 150, 255, cv::THRESH_BINARY_INV); //自适应二值化 cv::Mat binaryImage; cv::adaptiveThreshold(src, binaryImage, 255,cv::THRESH_BINARY_INV, cv::ADAPTIVE_THRESH_GAUSSIAN_C, 7,8); 程序运行效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b4cc64e37ea4fb513895311fc34cb20/" rel="bookmark">
			opencv dft离散傅立叶变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概念一、算法步骤1.将图像扩展到最佳大小2.为复数和实值开辟空间3.进行离散傅里叶变换4.将实部和复部转换为振幅5.转换到对数尺度6.裁剪和重新排列7.归一化 运行效果完整代码 概念 傅里叶变换将图像分解成它的正和余弦分量。换句话说，它将图像从它的空间域变换到它的频域。其思想是，任何函数都可以精确地逼近无穷个正函数和余弦函数的和。傅里叶变换是一种方法。二维图像的傅里叶变换在数学上为:
这里f是空间域的图像值，F是频域的图像值。变换的结果是复数。可以通过实像和复像显示，也可以通过幅值和相位图像显示。然而，在整个图像处理算法中，只有幅值图像是有意义的，因为它包含了我们需要的关于图像几何结构的所有信息。然而，如果你打算在这些形式中对图像做一些修改，然后你需要重新转换它，你需要保留这两个。
一、算法步骤 1.将图像扩展到最佳大小 DFT的性能取决于图像的大小。当图像大小是数字2、3和5的倍数时，它往往是最快的。因此，为了获得最大的性能，通常一个好主意是填充边界值的图像，以获得具有这些特征的大小。getOptimalDFTSize()返回这个最佳大小，我们可以使用copyMakeBorder()函数来扩展图像的边框(拓展的像素被初始化为0):
cv::Mat src; src = cv::imread("D:\\QtProject\\Opencv_Example\\dft\\dft.png", cv::IMREAD_GRAYSCALE); if (src.empty()) { cout &lt;&lt; "Cannot load image" &lt;&lt; endl; return; } show(src); cv::Mat padded; int m = cv::getOptimalDFTSize( src.rows ); int n = cv::getOptimalDFTSize( src.cols ); cv::copyMakeBorder(src, padded, 0, m - src.rows, 0, n - src.cols, cv::BORDER_CONSTANT, cv::Scalar::all(0)); 2.为复数和实值开辟空间 傅里叶变换的结果是复数。这意味着对于每个图像值，结果是两个图像值。此外，频域范围比其对应空间域大得多。因此，我们通常至少以浮点格式存储这些数据。因此，我们将我们的输入图像转换为这种类型，并扩展它与另一个通道来保存复数值:
cv::Mat planes[] = {cv::Mat_&lt;float&gt;(padded), cv::Mat::zeros(padded.size(), CV_32F)}; cv::Mat complexI; cv::merge(planes, 2, complexI); 3.进行离散傅里叶变换 可以就地计算(输入与输出相同):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b4cc64e37ea4fb513895311fc34cb20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84c8e7ed07082111f98d38e4e619028d/" rel="bookmark">
			【python】Pandas中DataFrame基本函数整理（全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		构造函数
DataFrame([data, index, columns, dtype, copy]) #构造数据框 属性和数据
DataFrame.axes #index: 行标签；columns: 列标签 DataFrame.as_matrix([columns]) #转换为矩阵 DataFrame.dtypes #返回数据的类型 DataFrame.ftypes #返回每一列的 数据类型float64:dense DataFrame.get_dtype_counts() #返回数据框数据类型的个数 DataFrame.get_ftype_counts() #返回数据框数据类型float64:dense的个数 DataFrame.select_dtypes([include, include]) #根据数据类型选取子数据框 DataFrame.values #Numpy的展示方式 DataFrame.axes #返回横纵坐标的标签名 DataFrame.ndim #返回数据框的纬度 DataFrame.size #返回数据框元素的个数 DataFrame.shape #返回数据框的形状 DataFrame.memory_usage() #每一列的存储 类型转换
DataFrame.astype(dtype[, copy, errors]) #转换数据类型 DataFrame.copy([deep]) #deep深度复制数据 DataFrame.isnull() #以布尔的方式返回空值 DataFrame.notnull() #以布尔的方式返回非空值 索引和迭代
DataFrame.head([n]) #返回前n行数据 DataFrame.at #快速标签常量访问器 DataFrame.iat #快速整型常量访问器 DataFrame.loc #标签定位，使用名称 DataFrame.iloc #整型定位，使用数字 DataFrame.insert(loc, column, value) #在特殊地点loc[数字]插入column[列名]某列数据 DataFrame.iter() #Iterate over infor axis DataFrame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84c8e7ed07082111f98d38e4e619028d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d314ece473b6d4f6b446b3fa5bfbe52/" rel="bookmark">
			linux kernel配置调试方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤 安装新内核，记住 grub 的序号，修改 grub.conf
将默认内核改成一个正常可用内核，而不是新安装的内核。
新内核启动时加入panic=5，使新内核启动失败后自动重启。
grub下次重启后进入新内核，使新内核仅在下次重启作为默认内核。一旦发生再次重启，就会按照进入 grub.conf 指定的默认内核。
root 权限运行 grub 命令，进入 grub 命令行。在 grub 命令行中运行（假设新内核的序号为 0)，savedefault --default=0 --once，输入 quit 以离开 grub 命令行，通过 crontab 设置机器自动重启。
运行 crontab -e，进入 crontab 配置文件，加入一行*/15 * * * * reboot。
重启系统，如果能正常进入新内核，则运行 crontab -e，删除 reboot 的一行。
系统性能分析工具perf 内置于Linux内核源码树中的性能剖析工具。基于事件采样原理以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。常用于性能瓶颈的查找与热点代码的定位。举例：
perf top
# perf top // 默认配置
# perf top -G // 得到调用关系图
# perf top -e cycles // 指定性能事件
# perf top -p 23015,32476 // 查看这两个进程的cpu cycles使用情况
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d314ece473b6d4f6b446b3fa5bfbe52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa8562fcfe662c0ef93802e51060bf6c/" rel="bookmark">
			【游戏开发小技】Unity中实现Dota里的角色技能地面贴花效果（URP | ShaderGraph | Decal）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文最终效果
文章目录 一、前言二、环境准备1、URP环境准备2、技能范围图案 二、方案一：写Shader实现1、Shader脚本：UrpDecal.shader2、材质球3、创建Cube4、地面场景5、添加Renderer Feature: Decal6、移动DecalCube，与地面交叉7、运行效果 三、方案二：使用URP Decal Projector1、添加Renderer Feature: Decal2、创建Decal Shader Graph3、材质球4、空物体挂 URPDecalProjector组件4、设置组件参数5、运行效果 四、工程源码五、完毕 一、前言 嗨，大家好，我是新发。
我平时偶尔会打打Dota2，在Dota里面，技能释放前会有一个地面贴花效果来作为范围的显示，比如深渊领主的这个技能，如下
我们可以看到技能范围特效是可以投射到场景地面和物体上（比如树木），这个在Unity中如何去实现呢？本文我以URP渲染管线为例，讲一下这个技能地面贴花效果的制作过程吧~
注：本文我使用的Unity版本为2021.3.1f1c1，Universal RP版本为12.1.6
二、环境准备 1、URP环境准备 首先通过PackageManager安装Universal RP，在Project窗口中右键鼠标，点击菜单Create / Rendering / URP Asset (with Universal Renderer)，
此时会创建出两个文件，如下
打开Project Settings窗口，点击Graphics，把Uinversal Render Pipeline Asset文件拖给Scriptable Render Pipeline Settings，如下
2、技能范围图案 接着我们去找一张技能范围的图案，我找了一张这样的，
接下来就是具体的实现过程了。有两个方案，下面我分别给大家讲解一下。
二、方案一：写Shader实现 1、Shader脚本：UrpDecal.shader 我在GitHub上看到有个外国小哥写了个URP渲染管线的贴花Shader，
GitHub地址：https://github.com/ColinLeung-NiloCat/UnityURPUnlitScreenSpaceDecalShader
我给他的Shader添加了中文注释，方便大家阅读，如下
// see README here: // github.com/ColinLeung-NiloCat/UnityURPUnlitScreenSpaceDecalShader Shader "Universal Render Pipeline/NiloCat Extension/Screen Space Decal/Unlit" { Properties { [Header(Basic)] _MainTex("Texture", 2D) = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa8562fcfe662c0ef93802e51060bf6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0d2d9a37dde613f4b52dd9226e13623/" rel="bookmark">
			零基础vue.js学习笔记 进阶篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记整理来源 B站up主黑马程序员
B站黑马程序员 快速入门vue前端
适合初学者入门vue.js， 该文是进阶篇
基础篇包括课程中的Vue基础和本地应用环节
该文是进阶篇，包括网络应用和综合应用
基础篇链接
文章目录 Vue.js网络应用介绍axios基本使用axios导入get请求随机笑话接口实战演示功能 post请求用户注册接口实战演示功能 总结 axios+vue一条随机笑话接口 天知道-介绍天知道--回车查询天气接口 天知道--点击查询综合应用-悦听-介绍天知道-音乐查询歌曲搜索接口 音乐播放歌曲url获取地址 歌曲封面歌曲详情获取 歌曲评论热门评论获取 播放动画播放MVmv地址获取 Vue.js 网络应用 介绍 Vue结合网络数据开发应用
axios :网络请求库
axios+vue 结合vue一起
通过天气预报巩固
axios基本使用 axios导入 &lt;script src="http://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; get请求 axios.get(地址?key=value&amp;key2=value2).then(function(response){},function(err){}) response函数会在请求成功后调用 err会在请求失败后调用 随机笑话接口 接口1随机笑话请求地址http://autumnfish.cn/api/joke/list请求方法get请求参数num(笑话个数)相应内容随机笑话 实战演示 &lt;body&gt; &lt;input type="button" value="get请求" class="get"&gt; &lt;script src="http://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; &lt;script&gt; document.querySelector(".get").onclick=function(){ axios.get("http://autumnfish.cn/api/joke/list?num=5") //axios.get("http://autumnfish.cn/api/joke/list123?num=5") .then(function(response){ console.log(response); } ,function(err){ conselo.log(err); }) } &lt;/script&gt; &lt;/body&gt; 功能 正常执行，在控制台输出五条笑话
如果用注释的语句会执行err语句，在控制台输出错误代码。
post请求 axios.post(地址,{key:value,key2:value2}).then(function(response){},function(err){}) response函数会在请求成功后调用 err会在请求失败后调用 用户注册接口 接口2用户注册请求地址http://autumnfish.cn/api/user/reg请求方法post请求参数username(用户名) --字符串类型响应内容注册成功或失败 实战演示 &lt;body&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0d2d9a37dde613f4b52dd9226e13623/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cc158099247bf86bf58aee2751b83ee/" rel="bookmark">
			安卓5.1 配置对应的frida环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.为什么是安卓5.1
因为这个安卓版本网络抓包不用处理信任证书
2.使用的frida版本
使用12.1.0以下版本才能让 frida-server在5.1安卓机上运行
3.使用python版本
python 3.7.9 (对应frida版本)
4.使用的frida-tool版本
frida-tool 1.1.0 (对应frida版本)
安装环境:
前往↓网址找到frida版本下载,pip下载毛病有点多,经历过会懂
https://pypi.org/project/frida/12.1.0/
我是 windows 下载frida-12.1.0-py3.7-win-amd64.egg 和 frida-12.1.0.tar.gz 解压出来后,在setup.py目录用python setup.py install 安装
前往↓网址找frida-tools版本下载
https://pypi.org/project/frida-tools/1.1.0/
解压出来后,在setup.py目录用python setup.py install 安装
python运行 import frida没报错即安装成功
对应的frida-server文件
Release Frida 12.1.0 · frida/frida · GitHub
模拟器用这个文件:
frida-server-12.1.0-android-x86.xz
手机则用:
frida-server-12.1.0-android-arm64.xz
将frida-server文件解压
打开命令行
adb push [frida-server文件名] /data/local/tmp adb shell su cd /data/local/tmp chmod 777 [frida-server文件名] #运行 ./[frida-server文件名] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a165fb73cc8e13ff656dbac6a54a400b/" rel="bookmark">
			excel常用快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【Ctrl】+【1】 设置单元格格式 【Alt】+【回车】 单元格内换行 【Alt】+【=】 一键求和 【Alt】+【↓】 生成下拉菜单 【Alt】+【F1】 生成表格 【Ctrl】+【Shift】+【1】 去除小数点，小数变整数 【Ctrl】+【L】/【Ctrl】+【T】 美化表格 【Ctrl】+【\】 两列数据找不同 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93235003af0153356b7662a394c574b7/" rel="bookmark">
			[剑指 Offer 52. 两个链表的第一个公共节点]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		剑指 Offer 52. 两个链表的第一个公共节点 题解：
输入两个链表，找出它们的第一个公共节点。
示例 1：
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 虽然给了很多条件，但实际上我们能接收的只有listA和listB。
解法：
方法一：（自写，消耗太大，拉跨）
基本思想就是双循环遍历对每一个节点都做比较
/** 执行用时：712 ms, 在所有 Java 提交中击败了5.04%的用户 内存消耗：44.1 MB, 在所有 Java 提交中击败了5.02%的用户 * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode tmpA = headA; while(tmpA !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93235003af0153356b7662a394c574b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aca674bdbe1738e1c6dfa766d6bb403/" rel="bookmark">
			Java实现斗地主
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：通过程序实现斗地主过程中的洗牌，发牌和看牌
思路：
1:创建一个牌盒， 也就是定义一个集合对象，用Arraylist集合实现 2:往牌盒里面装牌 3:洗牌，也就是把牌打撒，用Collections的shuffle()方法实现 4:发牌，也就是遍历集合，给三个玩家发牌 5:看牌，也就是三个玩家分别遍历自己的牌 实现代码：
public class PokerDemo { public static void main(String[] args) { //创建牌盒 ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); //♦ ♥ ♠ ♣ String[] colors = {"♦","♥","♠","♣"}; String[] numbers = {"2","3","4","5","6","7","8","9","10","J","Q","K","A"}; for(String color:colors){ for(String number:numbers){ array.add(color+number); } } array.add("大王"); array.add("小王"); Collections.shuffle(array); System.out.println(array); ArrayList&lt;String&gt; wss1 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; wss2 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; wss3 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; dp = new ArrayList&lt;String&gt;(); for(int i=0;i&lt;array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aca674bdbe1738e1c6dfa766d6bb403/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de8ea91e6584ed3c0c45c46d83cae08f/" rel="bookmark">
			哈密顿圈问题相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.文章缘由
毕业论文与这个相关，于是搜索了一些资料，看到有位前辈做过研究，感觉挺有意思。
2.哈密顿圈问题简介
参考自百度百科：哈密顿圈问题(Hamilton circuit problem)是图论中著名的难题之一。巡回售货员问题有一个基于图的天然类似问题，它是图论中的一个基本问题，给定一个有向图G(V，E)，如果G中的圈C恰好经过每一个顶点一次，则称圈C是一个哈密顿圈。换句话说，它构成一条经过所有顶点的、没有重复的“路线”。哈密顿圈问题如下：给定一个有向图G，问它有一条哈密顿圈吗?
3.研究的问题图
4.解决问题代码
public class HamiltonCircuit { /* * 参数adjMatrix：给定图的邻接矩阵，其中值为1表示两个顶点可以相通，值为-1表示两个顶点不能相通 */ public void getHamiltonCircuit(int[][] adjMatrix) { boolean[] used = new boolean[adjMatrix.length]; //用于标记图中顶点是否被访问 int[] path = new int[adjMatrix.length]; //记录哈密顿回路路径 for(int i = 0;i &lt; adjMatrix.length;i++) { used[i] = false; //初始化，所有顶点均未被遍历 path[i] = -1; //初始化，未选中起点及到达任何顶点 } used[0] = true; //表示从第1个顶点开始遍历 path[0] = 0; //表示哈密顿回路起点为第0个顶点 dfs(adjMatrix, path, used, 1); //从第0个顶点开始进行深度优先遍历,如果存在哈密顿回路，输出一条回路，否则无输出 } /* * 参数step:当前行走的步数，即已经遍历顶点的个数 */ public boolean dfs(int[][] adjMatrix, int[] path, boolean[] used, int step) { if(step == adjMatrix.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de8ea91e6584ed3c0c45c46d83cae08f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ccbb00d7bf6999249e0afecfc2584b9/" rel="bookmark">
			vue的计算属性（和一点lable标签的使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算属性可以减少模板中的计算逻辑，进行数据缓存，提高性能。
更强大的属性声明方式，可以对定义的属性进行逻辑处理和数据监视 。逻辑处理就是在计算属性内可以执行一些自己写的逻辑，数据监视就是计算属性内的返回值是依赖其他属性的变化而变化。
计算属性和方法的区别：在每一次调用方法时都要重新计算，而计算属性不用，在使用计算属性时不需要加（），而调用方法时需要加（），具体可以看代码中的例子，计算属性时依赖其他属性的，当其他属性变化时才会触发，然后 以函数的方式return结果；
效果图：
&lt;template&gt; &lt;div class=""&gt; &lt;label for="tex1" &gt;初始的str1为:&lt;/label&gt; &lt;!-- 注意lable标签是不换行的，for元素相当于是为了绑定服务对象 --&gt; &lt;input id="tex1" type="text" v-model="str1"&gt;&lt;br&gt; &lt;br&gt; &lt;div style="color:red"&gt; 大写后的str1为:{{str2}}&lt;br&gt; &lt;/div&gt; &lt;br&gt; &lt;label for="text2"&gt;初始化的msg为:&lt;/label&gt; &lt;input id="text2" type="text" v-model="msg"&gt;&lt;br&gt; &lt;br&gt; &lt;div style="color:red"&gt; 反转后的msg为：{{msg1}}&lt;br&gt; &lt;/div&gt;&lt;br&gt; &lt;label for="nom"&gt;初始化之前的num1：&lt;/label&gt; &lt;input type="text" v-model="num1"&gt;&lt;br&gt; &lt;div style="color:#F56C6C"&gt; 计算属性后：{{num2}} &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: '', data () { return { str1: '', msg: '', num1: 0 } }, computed: { str2: function () { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ccbb00d7bf6999249e0afecfc2584b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74d2119c5fb94e2da223bd39d0e9479a/" rel="bookmark">
			vscode 远程ssh连接省去输入密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先打开powershell
输入ssh-keygen -t rsa -b 2048
然后在c盘，用户目录文件夹下面有.ssh文件夹，里面生成了ssh的公钥和私钥
然后用记事本打开公钥，将其内容复制到linux系统家目录中的.ssh目录中的authorized_keys文件中没有就创建文件写入
或者
使用命令
ssh-copy-id username@ip自动将公钥复制过去
然后在vscode中键入ctrl+shift+p
搜索sshconfig
然后回车，配置文件
保存即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72342e3a7fae03fe735bbe90cb55a263/" rel="bookmark">
			SpingMVC的工作流程(详细版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：整体工作流程图 2：SpringMVC流程 1：浏览器发送请求送至前端控制器DispatcherServlet。
2：DispatcherServlet收到请求后调用HandlerMapping处理器映射器。
3：处理器映射器找到具体的Handler处理器返回给DispatcherServlet。
4：DispatcherServlet调用HandlerAdaptor处理器适配器。
5：HandlerAdaptor去调用具体的处理器(Controller)。
6：Controller返回一个ModelAndView对象给HandlerAdaptor。
7：HandlerAdaptor将接收到的ModelAndView对象返回给DispatcherServlet。
8：DispatcherServlet将ModelAndView对象传给ViewResolver视图解析器进行解析。
9：ViewResolver视图解析器将解析的结果View返回给DispatcherServlet。
10：DispatcherServlet根据View进行渲染视图。
11：DispatcherServlet响应浏览器的请求。
3：组件说明 1:DispatcherServlet：前端控制器(由框架提供)，作为流程控制的中心，控制其他组件执行，统一调度，能够接受请求、响应结果。
2：HandlerMapping：处理器映射器(由框架提供)，根据用户请求的url路径找到负责处理的Handler处理器。
3：HandlerAdaptor：处理器适配器(由框架提供)，根据特定规则去执行Handler。
4：Handler：处理器(需要自己开发)，作为后端控制器，对具体用户的业务请求进行请求，并将处理的结果封装在ModelAndView对象中，并返回给调用者。
5：ViewResolver：视图解析器(由框架提供)，主要进行视图解析，根据逻辑视图名解析出真正的视图。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67bcfc4f0887341b14a36a64ff454ceb/" rel="bookmark">
			Python模块selenium实例：电影分类排名数据生成json，sqlite和excel（openpyxl）文件（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面一篇文章已经生成了每个类别的电影评分前100位的json文件共21个。如下图：
现在我想把所有的电影按照评分做成一个总表。为此需要逐个打开每个文件，这里要用到os模块的listdir方法，如下建立一个遍历文件的获取文件名的函数：
from os import listdir def movie_files(folder): """gather list of image files""" movie_files = [] for f in listdir(folder): if f.endswith("json"): movie_files.append(f) return movie_files 函数中folder参数为文件所在目录，通过for循环遍历文件夹，如果文件以json结尾的则把文件名添加到列表，最后返回列表。
我们有了文件的名字列表后，现在需要逐个打开然后把数据添加到新的列表，函数如下：
def grand_data(folder,movieFiles): """Granded the data from the genre movies""" movieDataScore = [] movieDatas = [] for file in movieFiles: with open(folder+file, 'r',encoding='utf-8') as f: movies = json.load(f) for m in movies: movieDataScore.append(m['IMDb Score']) movieDatas.append(m) # Sorted the IMDb score list and remove duplicates new_movieDataScore = sorted(list(set(movieDataScore)),reverse=True) return movieDatas,new_movieDataScore 需要注意的是，我们建立了两个列表，一个把所有类别的电影数据放进去，另外一个要把电影评分放进去，同时通过set去重后再转为列表进行排序，函数最后返回两个列表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67bcfc4f0887341b14a36a64ff454ceb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d063ff971ca49bacd5e76ce2e659b639/" rel="bookmark">
			linux初探——linux怎么将一个文件移动到另一个目录下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录处理在日常工作中是比较常见的，今天就向大家介绍几个常用的跟目录处理有关的命令。
一、创建目录：mkdir mkdir 是 make directories 的缩写，该命令最简单的用法就是，直接在 mkdir 后面跟一个你想要创建的目录所在路径加目录名。
mkdir /tmp/movie #在tmp目录下创建一个名为movie的目录，其中 /tmp/ 是路径，movie 是你自己起的目录名 递归创建目录
假设我想在 tmp 目录下创建一个名为 book 的目录，然后再在 book 目录下创建一个名为 programming 的目录，怎么办呢？如果直接输入 mkdir /tmp/book/programming 是会报错的，因为此时 tmp 目录下不存在名为 book 的命令，而我还想在 book 目录下创建 programming 这个目录，显然是不行的。
有的读者可能会说，那我们可以这样：
mkdir /tmp/book #先在tmp目录下创建一个book目录 mkdir /tmp/book/programming #然后再在book目录下创建一个programming目录 这样是可以的，但是这只是创建一个二级目录，如果我想创建一个十级的目录，那要写 10 行命令才能创建完，未免有点太麻烦了。
不过我们不用担心， mkdir 命令为我们提供了一个选项 -p，通过这个选项，就可以一次创建多级目录。使用方式如下：
mkdir -p /tmp/book/programming #即使book目录原本不存在，也可以创建成功 一次创建多个目录
在mkdir 命令后面跟多个目录可以一次创建多个目录，比如：
mkdir /tmp/image /tmp/music #在tmp目录下同时创建image和music两个子目录 通过这种方式，就算我们想一次创建二十个、三十个目录也是可以的，这也是命令行的魅力所在。试想一下，如果在图形用户界面下创建三十个目录，是不是能把人给逼疯了？😂
二、切换目录：cd cd 命令是 change directory 的缩写，cd 命令最简单的用法就是，在该命令后面加上你想切换到的目录的路径。比如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d063ff971ca49bacd5e76ce2e659b639/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a944d2190a926a5ff7038ed8661a699/" rel="bookmark">
			【游戏开发教程】Unity Cinemachine快速上手，详细案例讲解（虚拟相机系统 | 新发出品 | 良心教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、插件下载三、案例1：第三人称自由视角，Free Look character场景1、场景演示2、组件参数2.1、CinemachineBrain：核心2.2、CinemachineFreeLook：第三人称自由视角相机2.2.1、设置Follow：跟随2.2.2、设置LookAt：朝向2.2.3、三个圆环轨道：环绕约束2.2.4、圆环轨道之间的连接曲线：Spline Curvature2.2.5、相机移动策略，移动阻尼：Body Y/Z Damping2.2.6、相机旋转策略，瞄准：Aim2.2.7、瞄准偏移：Tracked Object Offset2.2.8、预测：Lookahead2.2.8、瞄准阻尼：Horizontal/Vertical Damping2.2.9、画面构图（重要） 2.3、小结 3、用代码控制相机移动（绕圆环旋转） 四、案例2：相机避障不穿墙，Free Look collider场景1、场景演示2、组件参数2.1、CinemachineCollider：相机碰撞2.1.1、Add Extension拓展2.1.2、Collide Against：被认定为障碍物的Layer2.1.3、Ignore Tag：忽略碰撞检测的Tag2.1.4、Transparent Layers：透明层2.1.5、Minimum Distance From Target：与目标的最小距离2.1.6、Avoid Obstacles：是否避开障碍物2.1.7、Distance Limit：碰撞检测的射线长度2.1.8、Camera Radius：相机半径2.1.9、Strategy：避障策略2.1.10、Maximum Effort：一次可处理的最多的障碍物数量2.1.11、Smoothing Time：相机移动的平滑时间2.1.12、Damping：避障后相机恢复位置的阻尼2.1.12、Damping When Occluded：避障时的相机阻尼 五、案例3：简单追踪，FollowCam Simple Follow场景1、场景演示2、组件参数2.1、CinemachineVirtualCamera：虚拟相机2.1.1、Follow与LookAt：追踪目标2.1.2、Binding Mode：Body绑定模式1、Lock To Target On Assign 模式（常用）2、Lock To Target With World Up 模式3、Lock To Target No Roll 模式4、Lock To Target 模式5、World Space 模式6、Simple Follow With World Up 模式 六、案例4：动画状态驱动自由视角，StateDrivenCamera场景1、场景演示2、组件参数2.1、CinemachineStateDrivenCamera：状态驱动虚拟相机2.1.1、父节点：CinemachineStateDrivenCamera2.1.2、子节点：多个虚拟相机2.1.3、设置Animated Target2.1.4、设置State 七、案例5：分镜/切镜，ClearShot场景1、场景演示1.1、ClearShot场景1.2、ClearShot closest场景1.2、ClearShot character场景 2、组件参数2.1、CinemachineClearShot：自动选择/切换最适合的摄像头2.2、CinemachineBlendListCamera：虚拟相机过渡/混合器2.3、CinemachineTriggerAction：虚拟相机触发器2.3.1、碰撞体勾选Is Trigger2.3.2、设置过滤2.3.3、设置Skip First2.3.4、设置On Object Enter响应 八、案例6：多目标追踪，Dolly Group场景1、场景演示2、组件参数 九、其他案例1、打BOSS视角：BossCam场景2、双重目标：DualTarget场景3、近物透明，FadeOutNearbyObjects场景4、第三人称瞄准，3rdPersonWithAimMode场景5、镜头震动，Impulse场景 十、完毕 一、前言 嗨，大家好，我是新发。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a944d2190a926a5ff7038ed8661a699/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5dceb1f932345cf02517dbb9661c786/" rel="bookmark">
			mysql知识合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.基础：2.数据库设计1.三大范式2.日志崩溃处理Redo log（重做日志）undo log（回滚日志）bin log（归档日志）bin log 和 redo log区别日志相关问题崩溃后如何恢复MySQL 怎么知道 binlog 是完整的?redo log 和 binlog 是怎么关联起来的?处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计?如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？不引入两个日志，也就没有两阶段提交的必要了。只用 binlog 来支持崩溃恢复，又能支持归档，不就可以了？那能不能反过来，只用 redo log，不要 binlog？redo log 一般设置多大？正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？ 3.备份4.mysql主从复制**概述：****能解决的问题：****复制原理：**具体步骤 3.视图和临时表1.视图2.临时表外部临时表内部临时表**临时表说明** 3.视图和临时表的区别 4.变量，存储过程，函数1.变量2.存储过程语法：流程控制游标 3.函数4.存储过程和函数的区别 5.事务和隔离级别1.事务ACID事务操作回滚点 2.隔离级别并发访问下事务产生的问题**四种隔离级别：**幻读解决幻读在可重复读隔离界别下解决幻读 总结 3.进阶1.mysql架构连接层服务层SQL语句的执行流程查询缓存分析器（解析器）优化器执行器 存储引擎层系统文件层 2.MySQL缓存机制缓存命中条件缓存工作流程缓存说明开启查询缓存缓存参数全局缓存状态缓存命中测试**缓存清空测试**使用SQL Hint选择缓存大数据量缓存性能测试 缓存的利用率缓存失败情况减少缓存碎片缓存这么好，为什么很少用他？ 3.存储引擎1.什么是MySQL存储引擎存储引擎概述查看存储引擎修改默认存储引擎常见存储引擎 2.存储引擎的特点InnoDB 存储引擎**InnoDB架构****InnoDB关键特性** MyISAM 存储引擎MyISAM与InnoDB对比文件结构不同锁粒度不同事务支持插入性能对比查询性能对比索引上的区别其他区别 Memory存储引擎Merge 存储引擎 4.锁1.什么是MySQL锁，作用是什么2.mysql锁的类别和作用全局锁表级锁行锁页锁间隙锁临键锁（Next-Key lock)乐观锁和悲观锁共享/排它锁意向锁记录锁插入意向锁自增锁 3.总结 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5dceb1f932345cf02517dbb9661c786/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65693c1fd9a5e0754f43e0ce42620554/" rel="bookmark">
			Computer Graphics Games101 学习笔记03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Assignment 0 比较简单的环境配置，网上资料挺多的，这里推荐一个
链接
Transformation 03-Transformation 这一部分主要讲 2 D 2D 2D变换，通过引入矩阵来表示
剪切(shear)
缩放(scale)
旋转(Rotation,默认以原点为中心，逆时针旋转多少度)
平移(translate)
线性变换
用矩阵乘上输入坐标得到输出坐标的过程就叫做变换（矩阵是从右往左结合的缘故）
其实可以类比初中数学中的一次函数
而且可以发现一个性质: x ′ x' x′和 x x x的行数一样，推广一下其实代表着变换后得到的东西和之前的东西是一个性质的（比如直线变换后就会得到直线）。
齐次坐标
之前所有的变换都可以用上图的公式来实现，但是不难发现这不是一个线性变换，因为平移本身就不是线性变换而是仿射变换(Affine)，而我们为了省事想要把所有变换都变成线性变换，这样处理起来也方便，不用把平移作为单独的case考虑。但是顺序上还是要先处理线性变换，再进行平移操作的处理(我理解是历史缘故)。
为了实现这个想法，就需要引入齐次坐标了。
齐次坐标其实就是引入了一个新变量，为0的话表示向量，为1表示点。
而且这也符合常规逻辑
V e c t o r ( 0 ) + V e c t o r ( 0 ) = V e c t o r ( 0 ) Vector(0) + Vector(0) = Vector(0) Vector(0)+Vector(0)=Vector(0)
P o i n t ( 1 ) + V e c t o r ( 0 ) = P o i n t ( 1 ) Point(1) + Vector(0) = Point(1) Point(1)+Vector(0)=Point(1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65693c1fd9a5e0754f43e0ce42620554/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43453889cfa86de05c3aa553054f6d24/" rel="bookmark">
			如何保障系统稳定性并实现减排？蚂蚁集团有这些关键技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4 月 27 日，首届“全球信息系统稳定性峰会”在北京召开。会上，中国信息通信研究院（以下简称“中国信通院”） 公布了首批信息系统稳定性保障能力评估结果、分布式系统稳定性实验室成员单位、信息系统平稳运行优秀案例。蚂蚁集团当选为实验室成员单位，其支付平台凭借在系统稳定和安全等方面的技术与实践，获得“系统平稳运行优秀案例”颁证。
作为实验室成员单位，蚂蚁集团积极参与编写了系统稳定性相关的标准及研究报告，此次峰会上，蚂蚁集团数字科技事业群技术副总经理石世群也做了《支付宝系统双十一稳定性保障经验分享》的主题演讲，分享蚂蚁集团金融级分布式架构 SOFAStack 在系统稳定性保障领域的探索和实践经验。
以下为演讲整理全文：
大家好，我是蚂蚁集团数字科技的石世群。今天我将在线介绍支付宝双 11 稳定性保障的相关内容。
系统的稳定性保障，是一个复杂的系统工程。从 2004 年到 2021 年，支付宝经历了一系列的技术架构升级和迭代，从单元化架构走向弹性上云，进而演化到云原生、绿色计算，这个过程既要考虑容量稳定性，也要考虑成本和效率。
我们做了简单的总结，大概经历三个阶段：
第一阶段，主要解决容量的问题。通过 LDC、弹性能力和 OceanBase，解决了容量理论上无限伸缩的能力。同时，通过全链路压测技术很好的对全链路容量进行验证；
第二阶段，当支付的容量能力达标后，进一步考虑的就是如何通过技术创新去提升整体架构的稳定和效率。典型的场景有 2 个，一个是云原生，云原生架构的核心理念是将基础设施和业务进行剥离，从而释放基础设施的红利，大幅提升创新速度和效率，比较典型的案例就是 ServiceMesh 在蚂蚁的落地。另一个就是我们对于智能监控运维体系，通过数据智能的方式，提升系统应急响应恢复的反应速度。
第三阶段，绿色减排。连续几年，我们在保持峰值稳步增长的情况下，提出了大促 0 成本新增。2021 年双 11，我们的主要方向就聚焦在绿色减排上，通过离在线混部、分时调度、智能 AI 容量等创新技术，实现节约 64 万度电和 394 吨碳减排。
接下来，我给大家介绍一下支付宝双 11 大促的关键技术。
一、单元化部署
异地多活逻辑单元架构，蚂蚁内部也叫 LDC，全称是 Logical Data Center（逻辑数据中心），是对 IDC（Internet Data Center，互联网数据中心）的一种逻辑划分，也是支付宝系统实践“单元化部署”所采用的方案。
保障信息系统的稳定性，核心要解决两方面问题：
第一个，单点瓶颈。任何一个互联网系统发展到一定规模时，都会不可避免地触及到单点瓶颈。从单服务器、单应用，到单数据库、单机房，进而到多机房部署、多地部署（异地多活），这个过程就是在不断突破单点瓶颈；
第二个，保障异地容灾能力，这样才能满足金融级稳定性要求。多地多机房部署，是互联网系统发展的必然方向， 这里面要解决很多关键问题，包括流量调配、数据拆分、延时等，当然这些问题都可以通过技术和方案来解决，而承载这些方案的是一个部署架构。尽管可采用的部署方案不止一个，但无论是纯理论研究，还是一些先行系统的架构实践，都把“单元化部署”列为最佳方案。
所谓单元，是指一个能完成所有业务操作的自包含集合，在这个集合中包含了所有业务所需的所有服务，以及分配给这个单元的数据。一个单元，是一个五脏俱全的缩小版整站，它是全能的，因为部署了所有应用；但它不是全量的，因为只能操作一部分数据。
支付宝内部通过将单元分成 RZone、GZone、CZone 三类，来解决流量调配、数据拆分、延时的问题： RZone（Region Zone）：最符合理论上单元定义的 zone，每个 RZone都是自包含的，拥有自己的数据，能完成所有业务。
GZone（Global Zone）：全局单元，部署了不可拆分的数据和服务，这些数据或服务可能会被 RZone 依赖。GZone 在全局只有一组，数据仅有一份。
CZone（City Zone）：以城市为单位部署的单元，同样部署了不可拆分的数据和服务，也会被 RZone 依赖。但跟 GZone 不同的是，CZone 中的数据或服务会被 RZone 频繁访问，每一笔业务至少会访问一次；而 GZone 被 RZone 访问的频率则低的多。CZone 是为了解决异地延迟问题而特别设计的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43453889cfa86de05c3aa553054f6d24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78a06fc7e4ac53155fcf7c5c7b6e9135/" rel="bookmark">
			RuntimeError: Error(s) in loading state_dict for ResNet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤵 Author ：Horizon Max
✨ 编程技巧篇：各种操作小结
🎇 机器视觉篇：会变魔术 OpenCV
💥 深度学习篇：简单入门 PyTorch
🏆 神经网络篇：经典网络模型
💻 算法篇：再忙也别忘了 LeetCode
错误提示 RuntimeError: Error(s) in loading state_dict for ResNet: Missing key(s) in state_dict: "conv1.weight", "bn1.weight", "bn1.bias", "bn1.running_mean", "bn1.running_var", "layer1.0.conv1.weight", "layer1.0.bn1.weight", "layer1.0.bn1.bias", "layer1.0.bn1.running_mean", "layer1.0.bn1.running_var", "layer1.0.conv2.weight", "layer1.0.bn2.weight", "layer1.0.bn2.bias", "layer1.0.bn2.running_mean", "layer1.0.bn2.running_var", "layer1.0.conv3.weight", "layer1.0.bn3.weight", "layer1.0.bn3.bias", "layer1.0.bn3.running_mean", "layer1.0.bn3.running_var" 后面接着一大堆网络结构相关的东西
错误原因 load_state_dict 中 strict 参数默认是 True ：
表示预训练模型的层和自己定义的网络结构层严格对应相等（如层名和维度）
所以当我们修改了网络结构后，如果strict为True的时候就会报错
def load_state_dict(self, state_dict, strict=True): r"""Copies parameters and buffers from :attr:`state_dict` into this module and its descendants.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78a06fc7e4ac53155fcf7c5c7b6e9135/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da1a992c024e1be22b041bf781e371e8/" rel="bookmark">
			torch模型的保存和加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里介绍只保存加载模型的参数的方法，因为速度快，占内存小。
保存语法：
torch.save(model.state_dict(),'model.pth')
加载模型的语法：
因为只保存了模型的参数，所以需要先定义一个网络对象，然后再加载模型的参数。
例如：
model = ClassNet()
将模型参数加载到新模型中，torch.load返回的时一个OrderedDict,model.state_dict()把模型的所有参数都以OrderdeDict的形式保存了下来。
{'epoch': 1, 'model_name': 'resnet', 'state_dict': OrderedDict([('backbone.conv1.weight', tensor([[[[-9.6635e-03, -5.8054e-03, -1.7499e-03, ..., 5.6849e-02, 1.7084e-02, -1.2774e-02], [ 1.1954e-02, 1.0023e-02, -1.0967e-01, ..., -2.7083e-01, -1.2892e-01, 3.8908e-03], [-6.0705e-03, 5.9568e-02, 2.9577e-01, ..., 5.2005e-01, 2.5649e-01, 6.3826e-02], state_dict = torch.load('model.pth')
model.load_state_dict(state_dict)
这里附上一份自己的torch分类代码中的模型的保存和加载
#自定义模型保存 state = { "epoch": epoch + 1, "model_name": config.model_name, "state_dict": model.state_dict(), "F_Score": F_Score, "optimizer": optimizer.state_dict(), } filename = config.weights + config.model_name + ".pth" # resnet.pth torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da1a992c024e1be22b041bf781e371e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22e354907673b351841e4b8c1af6427a/" rel="bookmark">
			深入torch框架内部
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		torch框架下的函数都进行了封装，使初学者很难清楚内部的数据形式到底是什么，所以，经过了torch框架的练习，这篇文章来解析一下torch框架下的封装函数。
我们打印
print(torch.nn)
print(torch.optim)
print(torch.cuda)
输出结果：
&lt;module 'torch.nn' from 'D:\\Anaconda\\envs\\pytorch\\lib\\site-packages\\torch\\nn\\__init__.py'
&lt;module'torch.optim'from'D:\\Anaconda\\envs\\pytorch\\lib\\sitepackages\\torch\\optim\\__init__.py
&lt;module'torch.cuda'from'D:\\Anaconda\\envs\\pytorch\\lib\\sitepackages\\torch\\cuda\\__init__.py'
nn,optim,cuda均在torch框架下的目录中，函数或类就在目录下的文件中。
1，学习率衰减函数：
#学习率衰减 scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=20, gamma=0.5,last_epoch=-1) 参数含义：
step_size:每经过多少个epoch对学习率进行调整，此时的scheduler.step()放在epoch循环下。
gamma:经过step_size个epoch后，学习率变成:lr * gamma。
last_epoch:last_epoch之后恢复lr为initial_lr(如果是训练了很多个epoch后中断了 继续训练 这个值就等于加载的模型的epoch 默认为-1表示从头开始训练，即从epoch=1开始。
scheduler 对象常用的几个属性：
scheduler.step():对学习率进行更新，放在epoch下，优化器的更新之后。
scheduler.dict():状态信息 ，字典格式
print(scheduler.state_dict()) # {'step_size': 20, 'gamma': 0.5, 'base_lrs': [0.01], 'last_epoch': 0, '_step_count': 1, 'verbose': False, # '_get_lr_called_within_step': False, '_last_lr': [0.01]} 查看打印每个epoch的学习率：
可用优化器的属性state_dict():optimizer.state_dict()['param_groups'][0]['lr']
state_dict()下的内容：
for k,v in state_dict.items(): print(k) #state #param_groups 'param_groups': [{'lr': 0.01, 'momentum': 0.9, 'dampening': 0, 'weight_decay': 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22e354907673b351841e4b8c1af6427a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e1ff6051671e274f7d30a9c8abac4e6/" rel="bookmark">
			docker高级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DockerFile DockerFile是什么？ Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。 镜像构建三大步： ​ 编写DockerFile文件执行docker build 命令构建镜像docker run 运行容器。 DockerFile构建过程解析 Dockerfile内容基础知识 每条保留字指令都必须为大写字母且后面要跟随至少一个参数指令按照从上到下，顺序执行#表示注释每条指令都会创建一个新的镜像层并对镜像进行提交 Docker执行Dockerfile的大致流程 ​ Docker基于最开始的镜像，创建运行一个容器，根据一条命令对容器进行修改，然后Docker commit提交一层镜像层，然后有基于这个镜像层，创建新的容器，然后有根据下一条命令修改容器，然后又提交，直至最后一条命令执行完。
DockerFile常用保留字指令 From : 基础镜像，当前镜像是基于哪个镜像的，必须指定基础镜像，DockerFile第一条命令必须是From MAINTAINER : 镜像维护者姓名邮箱 RUN : 镜像构建时需要运行的Linux命令,Run是在docker build的时候执行的 --shell格式： RUN yum install xxx（运行一条yum命令） --exec格式： RUN [可执行文件，参数1，参数2] # 例：RUN [./redis-server,/etc/redis/redis.conf] 等同于 RUN ./redis-server /etc/redis/redis.conf EXPOSE : 镜像构建完成，运行当前镜像，生成的容器对外暴露的端口 WORKDIR : 指的是在运行容器时，进入交互终端所在的文件目录 USER : 指定镜像 需要什么用户才能执行 默认Root ENV : 构建过程中设置环境变量 ADD : 将宿主机中的文件添加到容器中，会自动的解压tar压缩包和自动处理URL COPY : 将宿主机中的文件拷贝到容器中 （类似于ADD 但是不会自动解压，）# COPY ["src", "dest"] VOLUME ： 容器卷 CMD ： 指定容器启动后要干的事情（和前面RUN的区别：Run在Build时运行，CMD在容器运行后运行） --shell格式：CMD yum install xxx（运行一条yum命令） --exec格式： CMD [可执行文件，参数1，参数2], --Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换 ENTRYPOINT : 类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖， ---而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序 ---如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。 编写一个Dockerfile文件（centos7+java8） FROM centos:7 #基础镜像centos 7 MAINTAINER zzyy&lt;zzyybs@126.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e1ff6051671e274f7d30a9c8abac4e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/512d3c953d419c2a0757b56f65685725/" rel="bookmark">
			【LeetCode】ACM完整代码写数据结构（以树、链表为例）c&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主现在从PTA过渡到了力扣进行刷题，近期在实习面试过程中也发现需要现场写完整代码（也就是ACM代码），从力扣注重函数实现的格式中还有点难切换出来，但是在搜索过程中这种完整代码的博客内容好少啊。于是也动手写了完整的代码和大家一起分享，平时也可以稍微练习一下，不然连头文件怎么写可能都会忘。重点在于树和链表，此篇以力扣上的题为例进行展示。由于这里仅是对完整代码进行展示，因而不对解题内容作解析。
反转链表 / 剑指 Offer 24. 反转链表 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; struct ListNode{ int val; ListNode* next; ListNode(int x):val(x),next(NULL){} }; ListNode* create(vector&lt;int&gt; arr){ int i; ListNode *p,*head,*pre; head = new ListNode(0); //给一个初始值0 pre = head; for(i = 0;i&lt; arr.size();i++){ p = new ListNode(arr[i]); pre-&gt;next = p; pre = p; } return head; } int main() { int arr[] = {5,4,3,2,1,0}; vector&lt;int&gt; v(arr,arr+sizeof(arr)/sizeof(int)); //把int型数组转化为vector，注意这里的转化方式 ListNode* L = create(v); L = L-&gt;next; //要有这步,否则要在create函数中返回head-&gt;next即L指向头结点 while(L!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/512d3c953d419c2a0757b56f65685725/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d2fe9f9ef4503df8bb6af98a952a2d7/" rel="bookmark">
			docker 快速启动 Confluent Kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 参考资料来自 ConfluentKafka 与 Confluent 创建 docker-compose.yml启动服务创建 Topic向 quickstart 中写入数据消费 quickstart 中的数据关闭 Kafka总结 参考资料来自 Confluent https://developer.confluent.io/quickstart/kafka-docker/
Kafka 与 Confluent 随着 Kafka 代码被贡献给 Apache 软件基金会，成功孵化成 Apache 顶级项目并顺利毕业，
世界上有越来越多的公司和个人开始接触到 Kafka，并不断地向 LinkedIn 的 Kafka 创始团队寻
求技术上的支持与帮助，这让 3 位 Kafka 创始人感到这是一个巨大的商业机会。
于是，在 2014 年 Jay Kreps、Jun Rao 和 Neha Narkhede 离开 LinkedIn 公司创办了 Confluent.io。
这家公司从事商业化 Kafka 工具开发以及提供实时流式处理方面的产品。
该公司基于 Apache Kafka 提供了 Confluent Platform。如果我们把 Apache Kafka 比作 Linux 的内核，那么 Confluent 就类似于 Linux 的某个发行版（比如 CentOS 或 Ubuntu）。Confluent 提供了一些 Apache Kafka 没有的组件和功能，比如完善的跨数据中心数据备份以及集群监控解决方案等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d2fe9f9ef4503df8bb6af98a952a2d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b15e5de39522d9ee8f1f0c502582b78d/" rel="bookmark">
			SSL证书以及其验证过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文整理了SSL证书的一些知识，主要是对与整个证书链验证原理的介绍，不涉及具体的报文细节
SSL证书内容 SSL证书是通信过程中一方的身份证明，用来发送给通信的另一方来证实自己的身份。其内容主要包括一些与自身相关的信息和与证书相关的信息以及自己的公钥。
一些明文信息自己的公钥CA的数字签名 CA机构签名过程 CA机构对服务端进行验证后（CA有自己的验证方式，线上或者线下都有），对服务器的明文信息先进行hash，得到摘要，然后用自己的私钥对摘要进行加密，得到数字签名。将签名和证书一起发放给服务器。
证书链 现实中不可能所有的证书都是由少数几个CA签发的，那样CA就太忙了。因此产生了证书链，根CA发布证书给中间CA，中间CA再发布证书给各个服务器。验证的时候，从下往上，最终验证到根CA。
验证过程 假设有两个中间CA，CA1和CA2，整个证书链如下所示
根CA -》CA1 -》CA2 -》 服务器
那么此时，服务器发给客户端的证书链中不仅包含自己的证书，还要包含各个中间CA的证书，本例子中也即CA1和CA2以及服务器自己的证书。
客户端首先验证 CA2 -&gt;服务器这一环，分为以下步骤：
从CA2的证书中，拿出CA2的公钥，对服务器证书中的CA2的签名进行解密。对服务器证书中的明文信息进行hash，使用的hash算法与CA2所使用的hash算法一致。对比前两步的结果，看其是否相等，若相等则验证通过。 验证通过后，客户端继续验证证书链的下一个环节，即 CA1 -&gt; CA2，与上一个环节大同小异，分为以下步骤：
从CA1的证书中，拿出CA1的公钥，对CA2证书中的CA1的签名进行解密。对CA2证书中的明文信息进行hash，使用的hash算法与CA1所使用的hash算法一致。对比前两步的结果，看其是否相等，若相等则验证通过。 验证通过后，客户端继续验证证书链的最后一个环节，即 根CA -&gt; CA1，注意第一步的不同之处：
从自己本地的缓存中，拿出根CA的公钥，对CA1证书中的根CA的签名进行解密。对CA1证书中的明文信息进行hash，使用的hash算法与根CA所使用的hash算法一致。对比前两步的结果，看其是否相等，若相等则验证通过。 至此证书验证过程结束。客户端本地会缓存一些少量的，全球都认可的根CA的证书，根CA的证书是自签名的，其中也会包含根CA的公钥。
无论有多少中间CA（零个或者多个），只要沿着证书链进行验证，每一个环节都验证通过的话，服务器就是可信的。其中有一个环节验证不通过，服务器就是不可信的。
关于SSL协议以及SSL证书还有很多内容，以后随着学习慢慢补充。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ebe63ff5788315656e747407f11687d/" rel="bookmark">
			深度学习：卷积核的训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卷积核的训练：
1.选择一幅原始图片X，选择一个卷积核K（3×3）。
2.做卷积Y= X*K。
3.转换问题：有原始图片X,有目标图片Y，求卷积核K。
4.解：
a.初始化一个3×3的随机数据的额卷积核W
b.Z = X*W卷积运算
c.损失值Loss = (Z-Y)^2均方差
d.用Loss 对Z求导，得到误差delta = Z-Y
e.dW = X*delta卷积运算，得到卷积核的误差
f.梯度更新W = W-0.5×dW/size(X)
g.重复b-f
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/240/">«</a>
	<span class="pagination__item pagination__item--current">241/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/242/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>