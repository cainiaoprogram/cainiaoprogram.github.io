<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9df61ef97f1a70c089b42354a27c0119/" rel="bookmark">
			SpringBoot热部署（修改代码无须重启）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 Java作为编译型语言，每次修改代码都要重新编译运行才能生效，大大影响了我们的开发效率。如何像解释型语言那样，修改代码无须重启即可看到效果，这种方法称为“热部署”，本文介绍实现热部署的步骤。
采用框架：SpringBoot 2.0.1.RELEASE
开发工具：IntelliJ IDEA 2018.1.4
二、步骤 ①在pom.xml中增加热部署的相关依赖spring-boot-devtools：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; ②IntelliJ IDEA设置自动编译：
快捷键Ctrl + Alt + S，打开 Settings，搜索 Compiler，勾选 Build project automatically，点击 OK
③IntelliJ IDEA设置 Registry：
快捷键 Shift + Ctrl + Alt + /，打开 Maintenance，选择 1. Registry...
在弹出页面查找 Compiler autoMake allow when app running 项并勾选，直接点击 Close
（小提示：在该页面直接输入字母可触发搜索功能，输入compiler.auto即可出结果）
三、测试 配置完成后重启服务器生效，此时修改任何Java代码都会自动重启服务，无须手动重启。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8b5ead5da68e59e216ec286ee77320b/" rel="bookmark">
			大学自习室简易抢座小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户端使用微信小程序，从某个模板扒皮下来。
服务端使用GO gin框架。
大致结构
小程序提交抢座任务，服务器每天定时抢座。
1.遇到过座位服务器响应过慢，解决办法就是简化步骤，将耗时的步骤尽量提前进行。
2.单个服务器性能有限，解决办法多台服务器同时抢座，并使用消息队列用来分配任务。
3.座位服务器有速率限制，超过请求次数则会封号，解决办法：找到临界值调整请求次数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1927e2b2b6ab8f1aa54e884c5c264e91/" rel="bookmark">
			c&#43;&#43; 回溯算法-八皇后
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //VC6.0-------------------das白 2019.12.28 #include"stdafx.h" #include &lt;cmath&gt; #include &lt;iostream&gt; using namespace std; //----------全局变量------------ #define n 8 //n皇后 int a[n]={0}; //棋盘 a[0]=5 则表示皇后在第一行 第六列 int sum=0; //解的个数 //-----------------n皇后-----回溯算法-------------------- //检测皇后位置是否正确 bool Check_queen(int row,int col){ //遍历前面所有皇后 判断是否与新皇后冲突 for(int i=0;i&lt;row;i++){ //之前已经row+1(且是一维数组存储行列坐标) 无需判断是否同一行 //判断其是否为同一列 或 是否斜率为1 if( (a[i]==col) || (abs(row-i)==abs(col-a[i])) ) return false; } //符合要求 return true; } //输出已求解的个数以及棋盘 void output(){ sum+=1; cout&lt;&lt;"------ "&lt;&lt;sum&lt;&lt;" ------"&lt;&lt;endl; for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;n;j++){ if(a[i]==j) cout&lt;&lt;"* "; else cout&lt;&lt;"0 "; } cout&lt;&lt;endl; } } //确定row+1个皇后 void Queen(int row,int col){ //如果已铺满棋盘 则输出棋盘 if(row&gt;=n){ output(); return ; } if(col&gt;=n) return; //超出棋盘范围 放弃此解 //确定第row+1个皇后位置 if(Check_queen(row,col)){ a[row]=col; Queen(row+1,0); // for(int i=row;i&lt;n;i++) a[i]=0; //下面几行皇后位置清零 寻找下一个可能的答案 } //皇后位置右移 Queen(row,col+1); } //------------------------------------------------------ void main() { Queen(0,0); } 八皇后输出： 四皇后输出： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6913f0209abfe5f1c31596710ccdecfc/" rel="bookmark">
			geoserver根据某字段值的不同给点图形设置不同图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在数据库中存储点图形数据的时候，会根据该坐标点对应的东西不同，会通过字段将点类型进行区分。比如饭店的坐标和理发店的坐标，我们在数据库存储的时候会通过某个字段进行区分。
那么我们如果将不同的点在同一个图层上发布成不同的图标呢？
1，首先，我们需要将自定义的图片放到geoserver的data\styles目录下
将会用到的图标上传到geoserver项目的data\styles目录下，图片不要太大，压缩到合适的尺寸再放
2，新建如下样式
&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt; &lt;StyledLayerDescriptor version="1.0.0" xsi:schemaLocation="http://www.opengis.net/sld http://schemas.opengis.net/sld/1.0.0/StyledLayerDescriptor.xsd" xmlns="http://www.opengis.net/sld" xmlns:ogc="http://www.opengis.net/ogc" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt; &lt;NamedLayer&gt; &lt;Name&gt;door&lt;/Name&gt; &lt;UserStyle&gt; &lt;Title&gt;A red line style&lt;/Title&gt; &lt;FeatureTypeStyle&gt; &lt;Rule&gt; &lt;ogc:Filter&gt; &lt;ogc:PropertyIsEqualTo&gt; &lt;ogc:PropertyName&gt;node_type&lt;/ogc:PropertyName&gt; &lt;ogc:Literal&gt;2&lt;/ogc:Literal&gt; &lt;/ogc:PropertyIsEqualTo&gt; &lt;/ogc:Filter&gt; &lt;PointSymbolizer&gt; &lt;Graphic&gt; &lt;ExternalGraphic&gt; &lt;OnlineResource xlink:type="simple" xlink:href="menjia_new.png" /&gt; &lt;Format&gt;image/png&lt;/Format&gt; &lt;/ExternalGraphic&gt; &lt;Size&gt;&lt;ogc:Literal&gt;16&lt;/ogc:Literal&gt;&lt;/Size&gt; &lt;/Graphic&gt; &lt;/PointSymbolizer&gt; &lt;/Rule&gt; &lt;Rule&gt; &lt;ogc:Filter&gt; &lt;ogc:PropertyIsEqualTo&gt; &lt;ogc:PropertyName&gt;node_type&lt;/ogc:PropertyName&gt; &lt;ogc:Literal&gt;3&lt;/ogc:Literal&gt; &lt;/ogc:PropertyIsEqualTo&gt; &lt;/ogc:Filter&gt; &lt;PointSymbolizer&gt; &lt;Graphic&gt; &lt;ExternalGraphic&gt; &lt;OnlineResource xlink:type="simple" xlink:href="menjia.png" /&gt; &lt;Format&gt;image/png&lt;/Format&gt; &lt;/ExternalGraphic&gt; &lt;Size&gt;&lt;ogc:Literal&gt;16&lt;/ogc:Literal&gt;&lt;/Size&gt; &lt;/Graphic&gt; &lt;/PointSymbolizer&gt; &lt;/Rule&gt; &lt;/FeatureTypeStyle&gt; &lt;/UserStyle&gt; &lt;/NamedLayer&gt; &lt;/StyledLayerDescriptor&gt; 每个rule对应一个过滤条件，每个过滤条件的*ogc:PropertyName代表用以区分图标的字段，下面的ogc:Literal表示该过滤条件试用的过滤字段的值，即该值为多少时适用该过滤条件Format填写image/png，因为我这里用的时png图片。ogc:Literal*代表图层中图标的大小；OnlineResourcessss标签填写自定义图片的名字。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6913f0209abfe5f1c31596710ccdecfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d18a3d15d10a039c5601a76e678eea26/" rel="bookmark">
			geoserver样式（SLD方式）—— 箭头样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		geoserver中在配置图层线条样式的时候，有时候会碰到需要给线条加箭头的情况，那么这个箭头要如何实现呢，先看看效果：
上面样式完整代码：
&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt; &lt;StyledLayerDescriptor version="1.0.0" xsi:schemaLocation="http://www.opengis.net/sld http://schemas.opengis.net/sld/1.0.0/StyledLayerDescriptor.xsd" xmlns="http://www.opengis.net/sld" xmlns:ogc="http://www.opengis.net/ogc" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt; &lt;NamedLayer&gt; &lt;Name&gt;vectorline&lt;/Name&gt; &lt;UserStyle&gt; &lt;Title&gt;A cyan line style&lt;/Title&gt; &lt;FeatureTypeStyle&gt; &lt;Rule&gt; &lt;LineSymbolizer&gt; &lt;Stroke&gt; &lt;CssParameter name="stroke"&gt;#fffc00&lt;/CssParameter&gt; &lt;CssParameter name="width"&gt;2&lt;/CssParameter&gt; &lt;/Stroke&gt; &lt;/LineSymbolizer&gt; &lt;LineSymbolizer&gt; &lt;Stroke&gt; &lt;GraphicStroke&gt; &lt;Graphic&gt; &lt;Mark&gt; &lt;WellKnownName&gt;shape://oarrow&lt;/WellKnownName&gt; &lt;Stroke&gt; &lt;CssParameter name="stroke"&gt;#e06666&lt;/CssParameter&gt; &lt;CssParameter name="width"&gt;2&lt;/CssParameter&gt; &lt;/Stroke&gt; &lt;/Mark&gt; &lt;Size&gt;20&lt;/Size&gt; &lt;/Graphic&gt; &lt;/GraphicStroke&gt; &lt;CssParameter name="stroke-dashoffset"&gt;10&lt;/CssParameter&gt; &lt;CssParameter name="stroke-dasharray"&gt;20 100&lt;/CssParameter&gt; &lt;/Stroke&gt; &lt;/LineSymbolizer&gt; &lt;/Rule&gt; &lt;/FeatureTypeStyle&gt; &lt;/UserStyle&gt; &lt;/NamedLayer&gt; &lt;/StyledLayerDescriptor&gt; 关键样式代码解读：
&lt;LineSymbolizer&gt; &lt;Stroke&gt; &lt;GraphicStroke&gt; &lt;Graphic&gt; &lt;Mark&gt; &lt;WellKnownName&gt;shape://oarrow&lt;/WellKnownName&gt; &lt;Stroke&gt; &lt;CssParameter name="stroke"&gt;#e06666&lt;/CssParameter&gt;&lt;!-- 箭头线条的颜色 --&gt; &lt;CssParameter name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d18a3d15d10a039c5601a76e678eea26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/044c50cdf30b7e8b88ac54e5e33f5084/" rel="bookmark">
			SVG学习之stroke-dasharray 和 stroke-dashoffset 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一：概念解释
stroke意思是：画短线于，在…上划线
stroke-dasharray:用于创建虚线，之所以后面跟的是array的，是因为值其实是数组。请看下面解释
stroke-dasharray = '10' stroke-dasharray = '10, 5' stroke-dasharray = '20, 10, 5' stroke-dasharray为一个参数时： 其实是表示虚线长度和每段虚线之间的间距
如：stroke-dasharray = ‘10’ 表示：虚线长10，间距10，然后重复 虚线长10，间距10
两个参数或者多个参数时：一个表示长度，一个表示间距
如：stroke-dasharray = ‘10, 5’ 表示：虚线长10，间距5，然后重复 虚线长10，间距5
如：stroke-dasharray = ‘20, 10, 5’ 表示：虚线长20，间距10，虚线长5，接着是间距20，虚线10，间距5，之后开始如此循环
stroke-dashoffset： offset：偏移的意思。
这个属性是相对于起始点的偏移，正数偏移x值的时候，相当于往左移动了x个长度单位，负数偏移x的时候，相当于往右移动了x个长度单位。
需要注意的是，不管偏移的方向是哪边，要记得dasharray 是循环的，也就是 虚线-间隔-虚线-间隔。
这个属性要搭配stroke-dashoffset才能看得出来效果，非虚线的话，是无法看出偏移的。 概念有点抽象，来看一个MDN的例子，图中红线段是偏移的距离
上图效果分别是：
1.没有虚线
2.stroke-dasharray=“3 1” ，虚线没有设置偏移，也就是stroke-dashoffset值为0
3.stroke-dashoffset=“3”，偏移正数，虚线整体左移了3个单位，图中3后面的红线段，就是起始线段，线段之后是1个单位的间隔，我们可见区域从这个间隔开始，然后循环 3-1,3-1的虚线-间隔-虚线-间隔
4.stroke-dashoffset="-3"，偏移负数，虚线整体右移动了3个单位，由于dasharray 是循环的，前面偏移的位置会有dasharray 填充上
5.stroke-dashoffset=“1”，偏移正数，虚线整体左移了1个单位，最终呈现出来的效果跟 线段4 一样
2.示例
利用这两个属性，我们可以做出好看的动画效果
线段从无到有，由短变长
实现思路就是：
第一步：设置stroke-dasharray虚线长度等于当前svg的宽度，间隔大于或者等于svg宽度
&lt;svg &gt; &lt;line id="line" x1="30" y1="30" x2="300" y2="30" stroke-width="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/044c50cdf30b7e8b88ac54e5e33f5084/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45c2e3e6c478a660897628f595d6dd25/" rel="bookmark">
			数据库中有哪几种数据类型？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据库中有哪几种数据类型？ 整型： tiny int，small int，medium int，int，big int，大小分别为 8，16，24，32，64位。（1字节 = 8 位）浮点型： float、double字符串类型： 定长的 char，变长的 varchar。在进行存储时，char 会删除末尾的空格，varchar 会保留末尾的空格。日期时间类型： 与时区无关的 data time，与时区有关的 time stamp。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39dacaf9b3725ad3122593d337d9f695/" rel="bookmark">
			nodeJs—解决node-xlsx读取csv文件乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做一个将mysql数据库导出的csv数据文件处理后再导入到mysql的脚本。发现在用node-xlsx插件读取csv文件的时候，读取文件中文为乱码：
var xlsx = require('node-xlsx'); var channel = xlsx.parse("data/t_gd_gantry1.csv"); var channelData = channel[0] var channelDataStr = channelData.data console.log(channelDataStr) 在网上找了下解决方法，其实很简单，将csv文件用记事本打开，选择另存，编码格式选为 UTF-8 重新保存即可
重新读取另存的编码格式为utf-8格式的csv文件，中文已经可以正常读取了：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03397cf4169bd58d38fff6a8227324e2/" rel="bookmark">
			jvm参数之GC日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.verbose:gc 表示，启动jvm的时候，输出jvm里面的gc信息。格式如下： [Full GC 200K-&gt;100K(1984K)， 0.0653877 secs] 解读 ：Full GC 就表示执行了一次Full GC操作，200K 和100K 表示执行GC前内存容量和执行GC后的内存容量。1984K就表示内存总容量。0.0653877是本次GC所耗时间，单位秒。 2.-XX:+printGC 这个打印的GC信息跟上个相同。 3.-XX:+PrintGCDetails 打印GC的详细信息。格式如下： –Heap – def new generation total 13824K, used 11223K [0x27e80000, 0x28d80000, 0x28d80000) 解读：new generation 就是堆内存里面的新生代。total指的是该区域内存容量。used也就是已使用的。0x开头的那三个分别代表的是 初始值，当前所使用的值，最大值。 – eden space 12288K, 91% used [0x27e80000, 0x28975f20, 0x28a80000) 解读：eden space 指的是eden区，是在新生代里面的，一些创建的对象都会先被放进这里。后面那个12288K就表示eden区容量，91% used，表示已经使用了百分之多少。后面同上 – from space 1536K, 0% used [0x28a80000, 0x28a80000, 0x28c00000) – to space 1536K, 0% used [0x28c00000, 0x28c00000, 0x28d80000) 解读：from space 和to space 是survivor的两个区。也属于新生代。他两个区的大小一样的。因为新生代的GC采用的是复制算法，每次只会用到一个幸存区，所以总会有一个是空的 – tenured generation total 5120K, used 0K [0x28d80000, 0x29280000, 0x34680000) – the space 5120K, 0% used [0x28d80000, 0x28d80000, 0x28d80200, 0x29280000) – compacting perm gen total 12288K, used 142K [0x34680000, 0x35280000, 0x38680000) – the space 12288K, 1% used [0x34680000, 0x346a3a90, 0x346a3c00, 0x35280000) – ro space 10240K, 44% used [0x38680000, 0x38af73f0, 0x38af7400, 0x39080000) – rw space 12288K, 52% used [0x39080000, 0x396cdd28, 0x396cde00, 0x39c80000) 解读：老年代 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03397cf4169bd58d38fff6a8227324e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5a63c0f61f17c88d3f4d6c1f455fbf5/" rel="bookmark">
			AS中NDK环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第一步 设置AS第二步第三步第四步 写测试类：第五步第六步第七步第八步第九步 添加调用测试第十步 运行结果 第一步 设置AS 在安装好的as，打开：
配置ndk路径，如果没有下载在下面提示框中有选择自动下载。
第二步 在项目的gradle.properties文件中加上 android.useDeprecatedNdk = true （此项不同as版本好像可以不用添加） 第三步 为了方便生成头文件和so文件，我们可以在Android Studio → External Tools中设置两个命令，分别来生成头文件和生成.so文件。
program:$JDKPath$/bin/javah Arguments:-encoding UTF-8 -d ../jni -jni $FileClass$ Working directory:$SourcepathEntry$\..\java​ program:E:\Android\ndk-bundle\build\ndk-build.cmd (ndk-build.cmd所在文件夹的路径) Arguments：可以不用填 Working directory：$ModuleFileDir$\src\main （这给路径一定要填对，不然找不到需要编译的C++源文件） 第四步 写测试类： package com.example.williamwang.myapplication; public class NdkTest { static { System.loadLibrary("JniTest"); } public static native String getString(); } 第五步 右击这个类选择刚才写的javah命令，就会生成头文件。
第六步 根据头文件写一个测试的.cpp文件
Android.mk文件
LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := JniTest LOCAL_SRC_FILES := com_example_williamwang_myapplication_NdkTest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5a63c0f61f17c88d3f4d6c1f455fbf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bc09d67fec199520eb7b37a6b1eb992/" rel="bookmark">
			PostGIS实现叠加分析之-Clip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Clip操作，顾名思义，裁剪。 设想一下，拿 Clip feature 对Input feature进行裁剪，就是按着Clip的要素范围对Input要素进行保留，Clip的作用就是画个边界，你Input feature保留我Clip范围内(边界内)的空间要素，属性并不做改变。注意裁剪的要素可以是面，线，点等。
2.以下是Arcgis 帮助里给的示范和解释，已经很权威了，可以参考，而且英文帮助更有助理解，来自10.2的帮助 3. 另外官网还给了应用，比如AOI提取，给出点、线、面的裁剪示例 4. Postgis的求解 Postgis提供了ST_Clip()的函数，但是是对影像raster的裁剪，
那么模仿arcgis的clip操作其实直接用st_intersection(A,B) ，属性值保留原来的Input feature就可以。
5.实际操作 略
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6548d3420495fb909d1c8c22c6a08874/" rel="bookmark">
			lotus 存储时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 千兆内网 扇区大小1GB存储命令 lotus-storage-miner pledge-sector Empty ---&gt; Packing耗时2mPacking ---&gt; Unsealed 耗时0s performing sector replication 执行扇区复制 node remote 拷贝staging 1GB 耗时9s computation 耗时 10m node remote 拷贝 sealed 1GB 耗时9s node remote 拷贝 cache 10.25GB 耗时 1m38s Unsealed ---&gt; PreCommitting 耗时 11mPreCommitting ---&gt; PreCommitted 耗时 0sPreCommitted ---&gt; Committing 耗时 11m scheduling seal proof computation 调度密封证明计算 node remote 拷贝 sealed 1GB 耗时9s node remote 拷贝 cache 10.25GB 耗时 1m33s starting computation 耗时 17m node remote 拷贝 cache 2GB 耗时 20s Committing ---&gt; CommitWait 耗时 19mCommitWait ---&gt; Proving 耗时 0s 节点耗时 node remote 总耗时 45mnode miner 存储到Proving sector 总耗时 49m 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6ab4c9125bf37eb2b125f8fb68dfd12/" rel="bookmark">
			python 将PDF 转成 图片的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、说明二、PDF转图片方法1：PyMuPDF（成功）①、安装PyMuPDF：②、转换图片代码： 方法2：pdf2image(未成功)①、安装pdf2image②、安装Poppler： 方法3、wind（已经成功）①、安装wind②、安装imagemagick③、安装ghostscript我下载好的ghostscript ④、代码： 方法4、imagemagick+ghostscript（已经成功）①、安装imagemagick②、安装ghostscript③、cmd命令转换：④、一般只是转换一俩个上一步就行了，如果数量过多，可以用python写个脚本。 参考： 一、说明 昨天突然想着把PDF转成图片，昨天尝试了许久，没有成功，然后就很纳闷，图片合成PDF就可以，应该转成图片也可以吧，然后网上各种找解决这个问题的方法。
如果需要图片合成PDF的，可以参考一下我之前的一个博客：
使用img2pdf 模块将目录下图片合并成pdf
二、PDF转图片 方法1：PyMuPDF（成功） ①、安装PyMuPDF： 模块地址：
pip install PyMuPDF ②、转换图片代码： import datetime import os import fitz # fitz就是pip install PyMuPDF def pyMuPDF_fitz(pdfPath, imagePath): startTime_pdf2img = datetime.datetime.now() # 开始时间 print("imagePath=" + imagePath) pdfDoc = fitz.open(pdfPath) for pg in range(pdfDoc.pageCount): page = pdfDoc[pg] rotate = int(0) # 每个尺寸的缩放系数为1.3，这将为我们生成分辨率提高2.6的图像。 # 此处若是不做设置，默认图片大小为：792X612, dpi=96 zoom_x = 1.33333333 # (1.33333333--&gt;1056x816) (2--&gt;1584x1224) zoom_y = 1.33333333 mat = fitz.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6ab4c9125bf37eb2b125f8fb68dfd12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31ce5a9e417ddaf2c6c1f1fae7c0719e/" rel="bookmark">
			进程管理实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.实验目的及实验环境 实验目的：
通过观察、分析实验现象，深入理解进程及进程在调度执行和内存空间等方面的特点，掌握在POSIX 规范中fork和kill系统调用的功能和使用。
实验环境：
硬件
(1) 主机：win7；
(2) 内存：8G ；
(3) 硬盘空间：500G。软件
Linux 操作系统，ubuntu16，安装在虚拟机下，预装有X-Window 、vi、gcc、gdb 和火狐浏览器。 二. 实验内容 通读下列代码：
/* * POSIX 下进程控制的实验程序残缺版 */ #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;signal.h&gt; #include &lt;ctype.h&gt; /* 允许建立的子进程个数最大值 */ #define MAX_CHILD_NUMBER 10 /* 子进程睡眠时间 */ #define SLEEP_INTERVAL 2 int proc_number=0; /* 子进程的自编号，从0开始 */ void do_something(); main(int argc, char* argv[]) { int child_proc_number = MAX_CHILD_NUMBER; /* 子进程个数 */ int i, ch; pid_t child_pid; pid_t pid[10]={0}; /* 存放每个子进程的id */ if (argc &gt; 1) { /* 命令行参数中的第一个参数表示建立几个子进程，最多10个 */ child_proc_number = atoi(argv[1]); child_proc_number = (child_proc_number &gt; 10) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31ce5a9e417ddaf2c6c1f1fae7c0719e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d514e17ac2c4002826d0d1b45f9e43d1/" rel="bookmark">
			安装rabbitmq时踩的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 rpm -i rabbitmq-server-3.6.0-1.noarch.rpm 报错
这里显示依赖问题，查询了网上，简单的解决方法就是直接忽略
rpm -i --nodeps rabbitmq-server-3.6.0-1.noarch.rpm 但是试过没有用
然后找到了下列方法
yum install -y socat 但是会遇到问题，下载下面依赖就可以
yum -y install epel-release 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47ab7f3cf9f40befc1c4babe174661d3/" rel="bookmark">
			maven之packaging标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用Java web开发的后端工程师们大多会使用Maven作为项目构建以及编译的工具，微服务和大中台当道的今天，更加关注maven的细节是必要的。今天我们来讲一讲&lt;packaging&gt;标签的作用。
首先maven作为一种XML标记语言，标签通常成对存在，目前packaging标签有3种配置：
&lt;packaging&gt;pom&lt;/packaging&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;packaging&gt;war&lt;/packaging&gt; 1. &lt;packaging&gt;pom&lt;/packaging&gt; 在父级项目中的pom.xml文件使用的packaging配置一定为pom。父级的pom文件只作项目的子模块的整合，在maven install时不会生成jar/war压缩包。
一定有童鞋会问：为什么需要一个父级pom文件呢？
好处如下：
可以通过&lt;modules&gt;标签来整合子模块的编译顺序（Maven引入依赖使用最短路径原则，例如a&lt;–b&lt;–c1.0 ，d&lt;–e&lt;–f&lt;–c1.1，由于路径最短，最终引入的为c1.0；但路径长度相同时，则会引入先申明的依赖）。因此尽量将更加底层的service放在更先的位置优先加载依赖较为合适。可以将一些子项目中共用的依赖或将其版本统一写到父级配置中，以便统一管理。groupId, artifactId, version能直接从父级继承，减少子项目的pom配置。 如下我给出了我写的项目的父级pom的样式：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;groupId&gt;cn.homie&lt;/groupId&gt; &lt;artifactId&gt;ancient-culture&lt;/artifactId&gt; &lt;name&gt;ancient-culture&lt;/name&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;description&gt;Carry forward the Chinese classical culture backend system. Author: Mr.Zyx &lt;/description&gt; &lt;modules&gt; &lt;!-- basic support service --&gt; &lt;module&gt;homie_shared_service&lt;/module&gt; &lt;module&gt;homie_auth_service&lt;/module&gt; &lt;module&gt;homie_calendar_service&lt;/module&gt; &lt;!-- functional service --&gt; &lt;module&gt;homie_user_service&lt;/module&gt; &lt;module&gt;homie_forum_service&lt;/module&gt; &lt;module&gt;homie_blog_service&lt;/module&gt; &lt;module&gt;homie_divination_service&lt;/module&gt; &lt;!-- integration service --&gt; &lt;module&gt;ancient-culture-api&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;springframework.version&gt;5.2.1.RELEASE&lt;/springframework.version&gt; &lt;spring-data-jpa.version&gt;2.2.2.RELEASE&lt;/spring-data-jpa.version&gt; &lt;springboot.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47ab7f3cf9f40befc1c4babe174661d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6412f671f810df0dcdfb415a931f753d/" rel="bookmark">
			Unity | 打开文件对话框批量选择文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在新浪博客写了一篇关于打开文件对话框批量选择文件的文章，可惜新浪博客不能写代码，奈何当时太年轻，并不觉得不方便，直到遇到CSDN...emmm，不想将就了，所以在这里更新一波，并补充其他的方法：
原文的方法一 1. 源码如下：
System.Windows.Forms.OpenFileDialog dlg = new System.Windows.Forms.OpenFileDialog(); dlg.Multiselect = true; dlg.RestoreDirectory = false; dlg.ValidateNames = true; dlg.FilterIndex = 1; dlg.Filter = "图片文件(*.jpg;*.png;*.jpeg)|*.jpg;*.png;*.jpeg|pdf文件|*.pdf|所有文件|*."; //"文本文件|*.*|C#文件|*.cs|所有文件|*.*";// "图片文件或PDF文件(*.jpg;*.png;*.jpeg;*.pdf)|*.jpg;*.png;*.jpeg;*.pdf"; dlg.InitialDirectory = "C:\\"; dlg.Title = "请选择要识别的图片或pdf"; if (dlg.ShowDialog() == System.Windows.Forms.DialogResult.OK) { for (int i = 0; i &lt; dlg.FileNames.Length; i++) { Debug.Log(dlg.FileNames.GetValue(i).ToString()); } } 2. 缺点：窗口风格旧、打包后运行有问题（看不到文件夹）：
原文的方法二 1. 源码如下：
[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)] public class OpenFileName { public int structSize; public IntPtr dlgOwner; public IntPtr instance; public string filter; public string customFilter; public int maxCustFilter; public int filterIndex; public string file; public int maxFile; public string fileTitle; public int maxFileTitle; public string initialDir; //打开路径 null public string title; public int flags; public short fileOffset; public short fileExtension; public string defExt; public IntPtr custData; public IntPtr hook; public string templateName; public IntPtr reservedPtr; public int reservedInt; public int flagsEx; } void OpenOfnInit() { Openofn = new OpenFileName(); Openofn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6412f671f810df0dcdfb415a931f753d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22a9889144f8316db1bfeb865191dbb6/" rel="bookmark">
			关于运行scrapy项目时提示 ModuleNotFoundError: No module named &#39;pymongo‘的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1问题描述 今天使用scrapy框架写爬虫并且使用mongodb存储结果时，在powershell中运行scrapy crawl demo发现报错，报错内容是No module named 'pymongo‘，即，没有找到pymongo模块，但是笔者确确实实的下载过这个模块，那么到底是怎么回事呢？
2问题分析 首先，需要指出的是，一定是环境问题。是否是多python版本共存？笔者的电脑里同时存在着Python2.7和python3.6，当初是安装anaconda时，默认安装了前者，后者是工作学习需要，同时Python2将被淘汰，安装了Python3，导致当前笔者的电脑里同时存有两个环境，而，笔者先前将pymongo安装在了python36中，并没有安装在Python27中，导致在powershell中运行scrapy时默认使用了python2.7，所以导致了上述报错，那么到底是不是呢？
3验证假设 验证假设最好的方法就是去尝试，这里笔者先贴出powershell中的错误：
这里先尝试在默认的Python27环境中同样也下载这个pymongo模块，再运行一遍，看看是否报错，结果如下：
发现能够正确运行了，看来是这个问题，即直接在终端运行scrapy程序会默认使用conda的Python默认路径，即我这里是Python2.7。
4其他 这里使用cmd终端方法来试试，因为powershell算是cmd升级版本，笔者经过测试（先卸载Python2.7的pymongo再安装）分别测试发现，确实是这个conda的默认环境导致的问题，但是在笔者测试的过程中，还发现了一个powershell问题，即不能够像cmd切换环境：如下分别是在cmd和powershell中的切换Python环境的调试
conda activate python版本号 我这里是36，因为当初安装conda时默认的27 conda activate Python36 发现成功的切换环境，但是在powershell中就不可以
因此，这里需要注意，但是既然在cmd中可以切换环境，那么因为我最开始的scrapy是在python36中写的，出错原因是powershell只认识默认的Python27版本，而我在Python27中没有安装pymongo，在Python36中安装了这个模块，那么我在cmd中切换成Python36后再运行scrapy文件不就可以吗？
实践出真知：
确实可行
5总结 很多人因为工作学习需要，会在电脑中同时存在多个Python版本，
（1）在powershell运行scrapy文件程序时，会默认使用conda默认的环境，如果该默认环境中没有装有对应的第三方模块时，就会出现类似的找不到模块的错误，因此可以在默认的环境下也安装一样的模块，同时继续使用powershell启动；
（2）由于笔者在上面分析中发现，powershell无法切换环境，如果不非要使用powershell，可以在终端cmd中，切换Python解释器后，因为pymongo安装在Python36中了，切换后就可以直接运行。
总之，如果没有多版本共存问题，就不会出现本文问题；同时如果powershell可以切换版本也会节省很多debug时间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b90da5073dafc32301ee2349bad35f0/" rel="bookmark">
			从 MySQL 迁移数据到 Oracle 中的全过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 这里记录一次将MySQL数据库中的表数据迁移到Oracle数据库中的全过程 ，使用工具 Navicat，版本 12.0.11
操作环境及所用工具： mysql5.7oracle18cwindowsNavicat12.0.11idea 二、开始移植 点击 工具 -&gt; 数据传输
左边 源 标识mysql数据库 ， 右边 目标 标识要移植到的oracle数据库
高级选项中勾选大写
温馨小提示：
如果字段名和表名都为小写，oracle操作数据的时候将会出现找不到表或视图的错误，解决方法是必须加上双引号才能查询到， 这样的话我们通过程序操作数据的时候必须加上双引号，即大大加重了迁移数据库后的工作量，因此这里需勾选转换对象名为大写 ，同时在转换过程中如果字段名出现oracle关键字的话，它会自动给我们加上双引号解决关键字的困扰！！！
【 ex: user -&gt; "USER" number -&gt; "NUMBER" desc -&gt; "DESC" level -&gt; "LEVEL" 】
选择需要移植的表，这里我一把梭全选了~
然后等待数据传输完成
如果最后遇到如下情况，可暂不管，直接关闭即可~
然后查看oracle，如下，数据导入成功
温馨小提示：传输过程中可能会存在有部分几张表不成功，手动导一下就好了~~
三、问题 1、解决oracle自增主键 oracle设置自增主键的几种方式： 序列 + 触发器序列 + Hibernate配置 (注：此方式仅适用于通过Hibernate连接数据库的方式)oracle12c版本之后新增 自增列语法 GENERATED BY DEFAULT AS IDENTITY 解决思路： 在ddl 创建表sql中添加自增主键的命令，重新创建一次表结构，然后再将oracle中的数据单独导入
这里由于小编oracle版本为18c 因此在创建表的时候加上自增主键语法即可完成！
① 备份数据 -&gt; 数据泵方式 数据泵 -&gt; 数据泵导出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b90da5073dafc32301ee2349bad35f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0c0c50a93ffe6ad80664dfa067c1d74/" rel="bookmark">
			cookie存取信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //设置cookie function setCookie(name,value){ document.cookie = name + "="+ escape (value) + ";" } //获取cookie function getCookie(name){ var arr,reg=new RegExp("(^| )"+name+"=([^;]*)(;|$)"); if(arr=document.cookie.match(reg)) return unescape(arr[2]).split(","); else return null; } 具体用法：
var hotLine = $.trim($("#hotLine").val()); setCookie("hotLine",hotLine); var hotLine = getCookie("hotLine")[0]; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cfc53123c0f65499c60c3861ffa7f95/" rel="bookmark">
			lotus storage 存储过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lotus storage 存储过程 1，lotus storage 存储过程 1，lotus storage 存储过程 * Empty | | | v *&lt;- Packing（打包） &lt;- incoming（载入） | | | v *&lt;- Unsealed（解封） &lt;--&gt; SealFailed（封装失败） | | | v * PreCommitting（预提交中） &lt;--&gt; PreCommitFailed（预提交失败） | | ^ | v | *&lt;- PreCommitted （预提交）------/ | ||| | vvv v--&gt; SealCommitFailed（密封提交失败） *&lt;- Committing（提交中） | | ^--&gt; CommitFailed（提交失败） | v ^ *&lt;- CommitWait（提交等待） ---/ | | | v *&lt;- Proving（证明中） | v FailedUnrecoverable（不可恢复的失败） UndefinedSectorState （未定义的扇区状态）&lt;- ¯\_(ツ)_/¯ | ^ *---------------------/ 参考：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cfc53123c0f65499c60c3861ffa7f95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f170ff839e38f4423f86ddf35f3ec3b7/" rel="bookmark">
			Java解析Yaml格式数据工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Yaml数据示例： --- !ruby/hash:ActionController::Parameters title: "测试这是一句文本文案，看看你的问题是否已经解决了呢？" options: - !ruby/hash:ActionController::Parameters option_name: "已经解决了" option_select: 'false' - !ruby/hash:ActionController::Parameters option_name: "还没解决呢" option_select: 'true' Yaml解析工具类： import org.yaml.snakeyaml.Yaml; import java.util.Map; /** * @author P.H * @date 2019/12/25 10:25 * @description Yaml解析 */ public class YamlUtil { public static Map&lt;String,Object&gt; parseYaml2Map(String str){ Yaml yaml = new Yaml(); return (Map&lt;String, Object&gt;)yaml.load(cleanYaml(str)); } private static String cleanYaml(String yamlText) { String tmpText = yamlText.replaceAll("^---.*\n", "---\n"); tmpText = tmpText.replaceAll("!ruby.*\n", "\n"); return tmpText; } /** * ignore */ private static boolean ignore(String yamlText) { if (yamlText == null) { return false; } return yamlText.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f170ff839e38f4423f86ddf35f3ec3b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58369b6b57c2777d7a2fe9b22f0dd9c9/" rel="bookmark">
			GLUT键盘控制（glutKeyboardFunc和glutSpecialFunc）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GLUT 教程 键盘输入 GLUT允许我们编写程序，在里面加入键盘输入控制，包括了普通键，和其他特殊键（如 F1,UP）。在这一章里我们将学习如何去检测哪个键被按下，可以从GLUT里得到些什么信息，和如何处理键盘输入。 到现在，你应该注意到了，只要你想控制一个事件的处理，你就必须提前告诉 GLUT，哪个函数将完成这个任务。到现在为止，我们已经使用GLUT告诉窗口系统，当窗口重绘时我们想调用哪个渲染函数，但系统空闲时，哪个函数被调用。和当窗口大小改变时，哪个函数又将被调用。 相似的，我们必须做同样的事来处理按键消息。我们必须使用 GLUT通知窗口系统，当某个键被按下时，哪个函数将完成所要求的操作。我们同样是调用一个函数注册相关的回调函数。 当你按下一个键后， GLUT提供了两个函数为这个键盘消息注册回调。第一个是glutKeyboardFunc。这个函数是告诉窗口系统，哪一个函数将会被调用来处理普通按键消息。 普通键是指字母，数字，和其他可以用 ASCII代码表示的键。函数原型如下： void glutKeyboardFunc(void(*func)(unsigned char key,int x,int y)); 参数： func: 处理普通按键消息的函数的名称。如果传递 NULL，则表示GLUT忽略普通按键消息。 这个作为 glutKeyboardFunc函数参数的函数需要有三个形参。第一个表示按下的键的ASCII码，其余两个提供了，当键按下时当前的鼠标位置。鼠标位置是相对于当前客户窗口的左上角而言的。 一个经常的用法是当按下 ESCAPE键时退出应用程序。注意，我们提到过，glutMainLoop函数产生的是一个永无止境的循环。唯一的跳出循环的方法就是调用系统exit函数。这就是我们函数要做的，当按下ESCAPE键调用exit函数终止应用程序（同时要记住在源代码包含头文件stdlib.h）。下面就是这个函数的代码： void processNormalKeys(unsigned char key,int x,int y) { if(key==27) Exit(0); } 下面让我们控制特殊键的按键消息。 GLUT提供函数glutSpecialFunc以便当有特殊键按下的消息时，你能注册你的函数。函数原型如下： void glutSpecialFunc(void (*func)(int key,int x,int y)); 参数： func: 处理特殊键按下消息的函数的名称。传递 NULL则表示GLUT忽略特殊键消息。 下面我们写一个函数，当一些特殊键按下的时候，改变我们的三角形的颜色。这个函数使在按下 F1键时三角形为红色，按下F2键时为绿色，按下F3键时为蓝色。 void processSpecialKeys(int key, int x, int y) { switch(key) { case GLUT_KEY_F1 : red = 1.0; green = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58369b6b57c2777d7a2fe9b22f0dd9c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/224b7b19cb557b9d2a653a9d8c57df9b/" rel="bookmark">
			最长单调子序列问题（LIS，dp入门）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dp的一种很简单的题型。
小编便以两道题来介绍一下。
问题一：防卫导弹
题目描述
一种新型的防卫导弹可截击多个攻击导弹。它可以向前或向下飞行，但不可以向后或向上飞行。它有一个缺点，尽管它发射时可以达到任意高度，但它只能截击比它上次截击导弹时所处高度低或者高度相同的导弹。现对这种新型防卫导弹进行测试，在每一次测试中，发射一系列的测试导弹，该防卫导弹所能获得的信息包括各进攻导弹的高度，以及它们的发射次序。求在每次测试中，该防卫导弹最多能截击的进攻导弹数量。
输入
第1行有若干个整数hi(0≤hi≤32767)，表示进攻导弹的高度，其中导弹数不超过4000个。
输出
一个整数，表示最多能截击的进攻导弹数。
样例输入
36 25 45 17 22 28
样例输出 3
分析：
选择一个导弹，之后只能选比它高度低的导弹。中间比开始的导弹高的就会跳过或去除（不计入）。这种 在一段序列中去除一些、而得出最长的一段单调序列的问题，即是dp经典题型：最长单调子序列问题。
最长非降子序列的长度。 (讲DP基本都会讲到的一个问题LIS：longest increasing subsequence)
代码
#include &lt;bits/stdc++.h&gt; #pragma GCC optimize(2) using namespace std; typedef long long ll; int n,a[4001],f[4001]; int main(){ while(scanf("%d",&amp;a[++n])!=EOF) ; n--; // 检验输入 // for(int i=1;i&lt;=n;i++)	cout&lt;&lt;a[i]&lt;&lt;' '; //核心代码 for(int i=1;i&lt;=n;i++){ f[i]=1; for(int j=1;j&lt;i;j++) if(a[j]&gt;=a[i])	f[i]=max(f[i],f[j]+1); } int res=0; for(int i=1;i&lt;=n;i++)	res=max(res,f[i]); cout&lt;&lt;res&lt;&lt;endl; } 1、不定输入之前讲过了，略。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/224b7b19cb557b9d2a653a9d8c57df9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4760caa343647167ddb6048820163f1f/" rel="bookmark">
			ffmpeg所有的解码器（decoders）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FFMPEG解码器 Decoders: V..... = Video(视频流） A..... = Audio（音频流） S..... = Subtitle（字幕流） .F.... = Frame-level multithreading ..S... = Slice-level multithreading ...X.. = Codec is experimental ....B. = Supports draw_horiz_band .....D = Supports direct rendering method 1 ------ V....D 012v Uncompressed 4:2:2 10-bit V....D 4xm 4X Movie V....D 8bps QuickTime 8BPS video V....D aasc Autodesk RLE VF...D aic Apple Intermediate Codec V....D alias_pix Alias/Wavefront PIX image V....D amv AMV Video V....D anm Deluxe Paint Animation V.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4760caa343647167ddb6048820163f1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a9293584091483ab7984ea4d3d83e9c/" rel="bookmark">
			Android  java.lang.NoSuchFieldError: 完美解决办法,以及原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FATAL EXCEPTION: main Process: cn.com.jusoft.epumping.staff, PID: 27129 java.lang.NoSuchFieldError: No static field ib_select of type I in class Lcom/ufo/imageselector/R$id; or its superclasses (declaration of 'com.ufo.imageselector.R$id' appears in /data/app/cn.com.jusoft.epumping.staff-Jqv742Hw1WhlfWk2DplCGA==/base.apk) at com.ufo.imageselector.adapter.BasicAdapter$ViewHolder.&lt;init&gt;(BasicAdapter.java:60) at com.ufo.imageselector.adapter.AlbumAdapter.onCreateViewHolder(AlbumAdapter.java:32) at com.ufo.imageselector.adapter.AlbumAdapter.onCreateViewHolder(AlbumAdapter.java:22) at android.support.v7.widget.RecyclerView$Adapter.createViewHolder(RecyclerView.java:6411) at android.support.v7.widget.RecyclerView$Recycler.tryGetViewHolderForPositionByDeadline(RecyclerView.java:5597) at android.support.v7.widget.RecyclerView$Recycler.getViewForPosition(RecyclerView.java:5482) at android.support.v7.widget.RecyclerView$Recycler.getViewForPosition(RecyclerView.java:5478) at android.support.v7.widget.LinearLayoutManager$LayoutState.next(LinearLayoutManager.java:2215) at android.support.v7.widget.GridLayoutManager.layoutChunk(GridLayoutManager.java:556) at android.support.v7.widget.LinearLayoutManager.fill(LinearLayoutManager.java:1502) at android.support.v7.widget.LinearLayoutManager.onLayoutChildren(LinearL 重点内容 解决办法:找到报错的ID——No static field ib_select of type I in class 这里是ib_select
然后查找到 该Layout所在布局,—-&gt;然后搜索布局名称,会找到相同名称的.更改自己的布局名称;重新运行即可
原因:!!! 文件名相同,依赖的文件名与自身写的相同,导致数据重复引用错误
主模块和library模块里新建相同名字的layout文件，但两者不同
最后在打包生成的apk文件中，这个名字的layout文件只有一个，并且是主模块的layout文件:
另外，apk文件中的resources.arsc文件中的id确实没有library中定义的id
结论 Android的打包机制决定了不能有同名的layout文件，故只能避免模块之间文件的重名
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbed505dd4a037fd0dbcce2ff6081f69/" rel="bookmark">
			scrapy设置和查看Cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 设置Cookie settings文件中给Cookies_enabled=False解注释
settings的headers配置的cookie就可以用了
def start_requests(self): yield scrapy.Request(url,dont_filter=True,cookies={your cookie}) 获取Cookie #请求Cookie Cookie = response.request.headers.getlist('Cookie') #响应Cookie Cookie = response.headers.getlist('Set-Cookie') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a125785a318fcc29748177175f50d3e/" rel="bookmark">
			Python爬虫进阶必备 | 某电竞加密参数分析( 什么花里胡哨，三行代码完成加密)...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“咸鱼学Python”，选择“加为星标”
第一时间关注Python技术干货！
建议收藏 | 最全的 JS 逆向入门教程合集
目标网站：
aHR0cHM6Ly93d3cuamRqMDA3LmNvbS8=
抓包分析与加密定位 首先打开开发者模式，抓包请求【图1-1】
图1-1 可以看到这里的加密参数名为sign
拿到加密参数名，我们现在用两种方法定位加密位置
•xhr 断点•直接搜索参数
使用 xhr 断点只要分析堆栈肯定可以找到这个参数生成的地方，不过很麻烦，建议当你没办法通过检索参数名找到加密位置的线索的时候再使用 xhr 断点。【图1-2】
图1-2 在这个例子当中，直接搜索 sign 就可以找到这个加密的参数位置了。【图1-3】
图1-3 结果不多只有 5 个，逐个检索也可以找到，上图红框中标记的就是 sign 这个参数加密所在文件，我们打开在文件中再次检索。【图1-4】
图1-4 可以看到，这个参数 sign 等于 a ，如果你没办法确认这个位置是不是，你可以打上断点重新加载看看是否会断在这个位置就知道了。
加密分析 找到加密位置之后，我们就来看看这个 a 他的加密到底是个啥。
经过断点可以看到a是在这里生成的。【图2-1】
图2-1 那么a 等于什么呢？就是下面这一串了。
var e, n, r = (new Date).getTime(), o = "timestamp=".concat(r,"&amp;secret=").concat("aHVheWluZ19zZWNyZXRfYXBp"), a = (e = o,n = i()(e),encodeURIComponent(s.a.stringify(n))); 这段代码怎么理解？
其实非常简单，我给大家拆分一下。
a 的值是等于 encodeURIComponent(s.a.stringify(n))
但是生成a中用到了变量n，这个 n又等于i()(e)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a125785a318fcc29748177175f50d3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9d9ac1b9d5ef1ba718bd35aacacebd8/" rel="bookmark">
			机器人学习笔记(3) 正运动学和逆运动学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019/10/24
正运动学：给定机器人关节变量的取值来确定末端执行器的位置和姿态。
逆运动学：根据给定的末端执行器的位置和姿态来确定机器人关节变量的取值。
3.1 运动链
转动关节对应转角（一个自由度）平动关节对应线性位移（一个自由度）球窝关节（两个自由度）、球形腕关节（三个自由度）。 现假设每个关节仅有一个自由度的假设下，关节的运动可以通过单个实数来描述；关节按照1到n的顺序进行编号，杆按照从0到n的顺序进行编号。按照这种约定，关节i把连杆i连接到 i-1杆上。关节i的位置相对于连杆i-1固定，即单关节i被驱动时，连杆i发生运动，因此，连杆0是固定的（基座）。
第i个关节关联一个相应的关节变量，用qi来表示：
2019/10/25
假设Ai是齐次变换矩阵，它给出了坐标系0ixiyizi相对于参考系oi-1xi-1yi-1zi-1的位置和姿态角度。矩阵Ai并非是恒定不变的，它随着机器人位形的改变而改变。基于前面假设一个关节一个自由度的前提下，Ai只是单个变量（qi）的函数。
用来表达坐标系ojxjyjzj相对于参考系oixiyizi的位置和姿态的齐次变换矩阵称为变换矩阵，表示如下：
对于末端执行器而言，末端执行器上的任意一点，它在坐标系n中的位置和姿态，我们分别使用一个三维向量和一个3x3的旋转矩阵来表示，并定义齐次变换矩阵如下：
2019/10/29
3.2 Denavit-Hartenberg
约定在机器人应用中，用来选择参考坐标系的一种常用的约定规则称为Denavit-Hartenberg约定，简称DH约定。一个任意的齐次变换矩阵可以通过6个数字来表示，例如第四列的三个元素以及左上角的3x3旋转矩阵的三个欧拉角。然而在DH表述中只有四个参数甚至更少。原因是坐标系的原点和可以任意的选取。
3.2.1 存在和唯一性问题
探讨哪些齐次变换可以通过（3-10）的表达式来表述两个附加特性：
（DH1）坐标轴x1垂直于坐标轴z0.。
（DH2）坐标轴x1与坐标轴z0相交。
https://download.csdn.net/download/weixin_38291293/11387880
https://download.csdn.net/download/weixin_38291293/11387874
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cb9530ae52722baa35a800247e29eb2/" rel="bookmark">
			2019-12-23
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue面试题
1.vue优点？框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；
简单易学，双向数据绑定，组件化，
视图，数据，结构分离，虚拟DOM，运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。
2.vue父组件向子组件传递数据？
答：通过props
3.子组件像父组件传递事件？
答： e m i t 方 法 4. v − s h o w 和 v − i f 指 令 的 共 同 点 和 不 同 点 ？ 答 : 共 同 点 ： 都 能 控 制 元 素 的 显 示 和 隐 藏 ； 不 同 点 ： 实 现 本 质 方 法 不 同 ， v − s h o w 本 质 就 是 通 过 控 制 c s s 中 的 d i s p l a y 设 置 为 n o n e ， 控 制 隐 藏 ， 只 会 编 译 一 次 ； v − i f 是 动 态 的 向 D O M 树 内 添 加 或 者 删 除 D O M 元 素 ， 若 初 始 值 为 f a l s e ， 就 不 会 编 译 了 。 而 且 v − i f 不 停 的 销 毁 和 创 建 比 较 消 耗 性 能 。 总 结 ： 如 果 要 频 繁 切 换 某 节 点 ， 使 用 v − s h o w ( 切 换 开 销 比 较 小 ， 初 始 开 销 较 大 ) 。 如 果 不 需 要 频 繁 切 换 某 节 点 使 用 v − i f （ 初 始 渲 染 开 销 较 小 ， 切 换 开 销 比 较 大 ） 。 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cb9530ae52722baa35a800247e29eb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b16f929d2bd72d11a8cd88399f97469/" rel="bookmark">
			PredRNN&#43;&#43;: Towards A Resolution of the Deep-in-Time Dilemma in Spatiotemporal Predictive Learning 翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PredRNN++: Towards A Resolution of the Deep-in-Time Dilemma in Spatiotemporal Predictive Learning 目录 PredRNN++: Towards A Resolution of the Deep-in-Time Dilemma in Spatiotemporal Predictive LearningAbstract1.Introduction1.1. Deep-in-Time Structures and Vanishing Gradients Dilemma in Spatiotemporal Modeling 2. Related Work3. Revisiting Deep-in-Time Architectures4. PredRNN++4.1. Causal LSTM4.2. Gradient Highway 5. Experiments5.1. Moving MNIST Dataset5.2. KTH Action Dataset 6. Conclusions7.AcknowledgementsReferences Abstract 提出了一种用于时空预测学习的循环网络PredRNN++。为了追求短期视频动态的强大建模能力，我们利用一种新的循环结构，称为Causal LSTM和级联双记忆，使我们的网络在时间上更深入。为了缓解深度预测模型中梯度传播的困难，我们提出了一种梯度捷径单元，该单元为梯度流从输出流返回到远程先前输入流提供了可选的快速路径。梯度捷径单元与Causal LSTMs无缝协作，使我们的模型能够自适应地捕获短期和长期的视频依赖关系。我们的模型在人造和真实的视频数据集上都获得了最先进的预测结果，显示了它在模拟缠结运动方面的能力。
1.Introduction 时空预测学习是指以一种自监督(有时称为无监督)的方式从无标签的视频数据中学习特征，并使用它们来执行特定的任务。这种学习范式已经或可能有益于实际应用，例如降水预报(Shi et al.， 2015;(Wang et al.， 2017)，交通流预测(Zhang et al.， 2017;(Xu et al.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b16f929d2bd72d11a8cd88399f97469/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88550f3eec9af6df46c76d9a0824c3bc/" rel="bookmark">
			VS Code 插件（vsc-netease-music）推荐及注意
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 网易云就算现在版权问题很严重，却不得不承认它的资源有时候挺好的，那么你有没有想过把它集成到Vs Code中呢？还真有人做到了。
vsc-netease-music 插件的名字就叫这个，安装，使用，一气呵成。
然而报了个问题：
NotSupportedError: Failed to load because no supported source was found. 问题的原因很简单，我们都知道Vscode是基于electron做的，而VS Code 使用的 Electron 版本不包含 ffmpeg，需替换自带的 ffmpeg 动态链接库才能正常播放，所以要做到这点我们需要手动下载对应版本的Electron，然后手动替换ffmpeg这个文件。
首先我们要查看当前VS Code的版本：
code -v 接着看对应使用的是哪个版本的electron，下面例子使用1.41.1。
https://raw.githubusercontent.com/Microsoft/vscode/1.41.1/.yarnrc 看到使用的electron版本是：
disturl "https://atom.io/download/electron" target "6.1.5" runtime "electron" 接着找到对应的镜像：
https://npm.taobao.org/mirrors/electron/6.1.5/ 在列表中找到：
electron-v6.1.5-win32-x64.zip 或者直接输入：
https://npm.taobao.org/mirrors/electron/6.1.5/electron-v6.1.5-win32-x64.zip 接着压缩其中的ffmpeg.dll到：
C:\Users\%your name%\AppData\Local\Programs\Microsoft VS Code 脚本 作者用了python写了个自动添加的脚本，我的是没啥作用，你们可以试试
https://github.com/nondanee/vsc-netease-music 使用 也很简单，F1打开控制台，输入类似下图的指令，当然首先我们要启动，只要输入nete…就差不多会出来了：
包括登陆等它功能还是都有的，简单的图形界面：
只能说能想到这个，真的很厉害了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5920b6418c618981ae76a4d599c023d3/" rel="bookmark">
			OpenCV-Python 图像梯度 | 十八
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标 在本章中，我们将学习：
查找图像梯度，边缘等我们将看到以下函数：cv.Sobel()，cv.Scharr()，cv.Laplacian()等 理论 OpenCV提供三种类型的梯度滤波器或高通滤波器，即Sobel，Scharr和Laplacian。我们将看到他们每一种。
1. Sobel 和 Scharr 算子 Sobel算子是高斯平滑加微分运算的联合运算，因此它更抗噪声。逆可以指定要采用的导数方向，垂直或水平（分别通过参数yorder和xorder）。逆还可以通过参数ksize指定内核的大小。如果ksize = -1，则使用3x3 Scharr滤波器，比3x3 Sobel滤波器具有更好的结果。请参阅文档以了解所使用的内核。
2. Laplacian 算子 它计算了由关系 Δ s r c = ∂ 2 s r c ∂ x 2 ∂ 2 s r c ∂ y 2 \Delta src = \frac{\partial ^2{src}}{\partial x^2} \frac{\partial ^2{src}}{\partial y^2} Δsrc=∂x2∂2src​∂y2∂2src​给出的图像的拉普拉斯图,它是每一阶导数通过Sobel算子计算。如果ksize = 1,然后使用以下内核用于过滤:
k e r n e l = [ 0 1 0 1 − 4 1 0 1 0 ] kernel = \begin{bmatrix} 0 &amp; 1 &amp; 0 \\ 1 &amp; -4 &amp; 1 \\ 0 &amp; 1 &amp; 0 \end{bmatrix} kernel=⎣⎡​010​1−41​010​⎦⎤​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5920b6418c618981ae76a4d599c023d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc04a6cd4dd445b39baa854ab1e03fce/" rel="bookmark">
			ORACLE 11g 数据库 java jdk版本匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle版本是11G
这个要取决于你的jdk，如果你的jdk是 JDK 1.4 、1.5用ojdbc5.jar，如果jdk是1.6、1.7、1.8用ojdbc6.jar 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/123665711ce3a0543c0225bc17be8630/" rel="bookmark">
			Oracle11g与Oracle11gxe有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XE版的是免费版，有限制的，如数据库大小限制在11G以内，不能多CUP等等。但个人学习用没问题的。 目标文件夹: C:
Oracle 主目录: C:\app\oracle\product\11.2.0\server
Oracle 基目录:C:
‘Oracle 数据库监听程序’ 的端口: 1521
‘Oracle Services for Microsoft Transaction Server’ 的端口: 2030
‘Oracle HTTP 监听程序’ 的端口: 8080
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e191f93f10fe3b7b3e60af140a97e555/" rel="bookmark">
			CS224N_2019_Assignment3: Dependency Parsing (Solution)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 A3作業讓你學會建立neural dependency parser的同時也能熟悉Pytorch的用法。
Written part是關於Adam和Dropout的解答與思考，這部分教授在課上解釋的比較少，但屬於neural network的重點之一，建議閱讀相關文獻加深這部分的理解。
Coding part是關於運用wrriten part的optimizer trick建立一個完整的simple neural net，並進行模型訓練。
題目詳情 – Written Part – #1. Machine Learning &amp; Neural Networks (8 points) Answer：
( a )
i. Using m updates the gradient by multiplying it by α(1-β) times, reducing the gradient even further than SGD.
ii. v will get larger updates since its calculation contains the power of the gradients. If v is larger than 1, the updated v will be larger; if v is smaller than 1, the updated v will become smaller.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e191f93f10fe3b7b3e60af140a97e555/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15e6d2a06e4a827cf9d29d232fbaf4df/" rel="bookmark">
			python 简单全自动WORD合并（加程序链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境： python 3.x
python 的 pywin32包
pyinstaller包（把python打包成exe）pyinstaller -F app.py
自己百度安装即可
源码： #导入pywin32包 import win32com.client as win32 import os print('-'*30) print('使用方式：') print('1、把放在桌面') print('2、第一次点击，桌面会出现一个file文件夹') print('3、把一些docx后缀的文件放进去') print('4、再次点击运行程序') print('合并排序方式为：由大到小') print('-'*30) input('回车下一步....') #创建文件夹，判断是否有文件夹，没有则创建 if not os.path.isdir('file'): os.mkdir("file") #获取file文件目录 file_list = os.listdir("./file/"); #是否存在文件 if len(file_list): word = win32.gencache.EnsureDispatch('Word.Application') #可视化运行 word.Visible = 1 output = word.Documents.Add()#新建合并后空白文档 lists = [] #循环列表 for file in file_list: #判断是不是word docx 后缀的文件 if '.docx' in file: path = os.getcwd() + '\\file\\'+ file lists += [path] for file in lists: output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15e6d2a06e4a827cf9d29d232fbaf4df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/175896c4e8573aa6797de69f4e445097/" rel="bookmark">
			自己公司项目中引用jacoco，及多报告合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个内容是继续之前的视频内容的后续章节。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/804c707e1ec20aaef94c26aa6ed55eb9/" rel="bookmark">
			HashMap实现原理分析(源码分析，ReHash，)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、HashMap的数据结构
解决hash冲突的办法
二、源码分析
1. 位桶数组
2. 数组元素Node实现了Entry接口,v&gt;
3. HashMap如何put(key，value）
4. HashMap如何getValue值
5. HasMap的扩容机制resize();
6. JDK1.8使用红黑树的改进
三、再谈ReHash
单线程下的ReHash
并发下的Rehash
一、HashMap的数据结构 数据结构中有 数组 和 链表 来实现对数据的存储，但这两者基本上是两个极端。 （堆砌了别人的文章！呵呵呵）
数组
数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；
链表
链表存储区间离散(不连续)，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，O（N）。链表的特点是：寻址困难，插入和删除容易。
哈希表
那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。
当链表数组的容量超过初始容量的0.75时，再散列将链表数组扩大2倍，把原链表数组的搬移到新的数组中
加载因子（默认0.75）：为什么需要使用加载因子，为什么需要扩容呢？因为如果填充比很大，说明利用的空间很多，如果一直不进行扩容的话，链表就会越来越长，这样查找的效率很低，因为链表的长度很大（当然最新版本使用了红黑树后会改进很多），扩容之后，将原来链表数组的每一个链表分成奇偶两个子链表分别挂在新链表数组的散列位置，这样就减少了每个链表的长度，增加查找效率
HashMap本来是以空间换时间，所以填充比没必要太大。但是填充比太小又会导致空间浪费。如果关注内存，填充比可以稍大，如果主要关注查找性能，填充比可以稍小。
即HashMap的原理图是：
解决hash冲突的办法 开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）再哈希法链地址法建立一个公共溢出区 Java中hashmap的解决办法就是采用的链地址法（也称为拉链法）。
二、源码分析 1. 位桶数组 transient Node&lt;K,V&gt;[] table; 2. 数组元素Node&lt;K,V&gt;实现了Entry接口 public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable { private static final long serialVersionUID = 362498820763181265L; /** * 初始大小 - MUST be a power of two.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/804c707e1ec20aaef94c26aa6ed55eb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69068f953e86b13f75fec63c4f8cb665/" rel="bookmark">
			JAVA程序设计：连续数组（LeetCode：525）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。
示例 1:
输入: [0,1]
输出: 2
说明: [0, 1] 是具有相同数量0和1的最长连续子数组。
示例 2:
输入: [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。
思路：将0变成-1,1还是1，然后从前到后累加过去，记录每种和第一次出现的位置，直到下次出现，则距离即为和为0的长度。
class Solution { public int findMaxLength(int[] nums) { int n=nums.length; if(n==0) return 0; int sum=0,ans=0; Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;(); map.put(0, 0); for(int i=0;i&lt;n;i++) { sum+=nums[i]==0?-1:1; if(map.containsKey(sum)) ans=Math.max(ans, i+1-map.get(sum)); else map.put(sum, i+1); } return ans; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3064739a0058fb462b9f50dbc31c729b/" rel="bookmark">
			intent-filter的action、category、data匹配规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们知道有两种方式来启动Activity，显示调用和隐式调用。当使用隐式调用时，又会涉及到IntentFilter的匹配规则。我确信大多数开发者很少关注隐式调用，因为平时开发中用到大多数是显示调用。例如：用Intent直接打开一个Activity，或者用Intent通过包名等其他信息打开另外一个应用等。而隐式调用则使用的比较少，当然也不是完全不使用。例如：当我们需要打开浏览器访问某个链接时，手机上可能存在多个浏览器，我们也无法拿到某一个浏览器的包名，那么一般情况下我们会写如下代码：
Intent intent = new Intent(); intent.setAction("android.intent.action.View"); intent.setDate(Uri.parser("https://www.baidu.com/")); startActivity(intent); 执行完这段代码后，系统将会弹框提示选择哪个浏览器打开。只要这个Intent中的action(通过setAction()方法配置)能和Activity配置的过滤规则中的任何一个action相同即可匹配成功(这里后面会详细分析)。这里就说明Intent中action匹配到了多个Activity，所以系统会将所有能打开这个链接的应用展示出来供用户选择。这种通过action匹配activity的方式就是一种典型的隐式调用。
首先我们先分析显示调用和隐式调用的原理：
1、Activity的调用模式 a、显示调用
显示调用需要明确的指出被启动的对象的组件信息、包括包名和类名
示例1：通过包名打开一个应用
这里需要注意：启动第三方Apk的Activity，需要第三方Activity的android:exported属性为true。
android:exported 是Android中的四大组件 Activity，Service，Provider，Receiver 四大组件中都会有的一个属性。
总体来说它的主要作用是：是否支持其它应用调用当前组件。 默认值：如果包含有intent-filter 默认值为true; 没有intent-filter默认值为false。如果有intent-filter，你把android:exported设置为false，那么第三方app也是无法调用该组件的(会报permission拒绝)
Intent intent = new Intent(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_LAUNCHER); ComponentName cn = new ComponentName("com.mg.axe.testappa","com.mg.axe.testappa.MainActivity"); intent.setComponent(cn); startActivity(intent); 示例2： 打开一个Activity
Intent intent = new Intent(ActivityA.this,ActivityB.class); startActivity(intent); b、隐式调用
需要Intent能匹配目标组件的IntentFilter中所设置的过滤信息.如果不匹配将无法启动目标Activity
示例1：通过action方式匹配对应的Activity
Intent intent = new Intent(); intent.setAction("android.intent.action.View"); startActivity(intent); 为什么会匹配到这么多应用的Activity？ 因为在这些Activity的IntentFilter匹配规则中有如下规则：
（由于我们这里没有匹配其他的条件，所以会匹配到很多应用的Activity，我们可以添加其他的匹配条件，比如入“category”，“data”的匹配来更加精确的匹配到所需要的Activity）
通过上面的实例，大概了解了显示调用和隐式调用的方式。接下来我们将重点放在隐式调用的IntentFilter的匹配中
2.Action的匹配规则 Intent中的Action必须能够和Activity过滤规则中的Action匹配. 如果一个Intent-filter过滤规则中有多个action,那么只要Intent中的action能够和Intent-filter过滤规则中的任何一个action相同即可匹配成功。
在AndroidManifest中添加AActivity的action的匹配规则&lt;action android:name="com.axe.mg.what" /&gt;
&lt;activity android:name=".AActivity" android:label="@string/app_name" android:theme="@style/AppTheme.NoActionBar"&gt; &lt;intent-filter&gt; &lt;category android:name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3064739a0058fb462b9f50dbc31c729b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21d1fe2eafd3648c43147e4bde4fa7c0/" rel="bookmark">
			每日论文学习：Deep High-Resolution Representation Learning for Human Pose Estimation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Deep High-Resolution Representation Learning for Human Pose Estimation(目前SOTA,已经开源)
作者：Ke Sun, Bin Xiao, Dong Liu, Jingdong Wang
论文链接：https://arxiv.org/abs/1902.09212
代码链接：https://github.com/leoxiaobin/deep-high-resolution-net.pytorch
论文解读：https://mp.weixin.qq.com/s/ZRCzBTBmlEzQCVo1HLWtbQ
这个工作是目前姿态估计领域sota的方法，对网络结构下手。
主要思想感觉是为了解决之前姿态估计由于pooling操作带来的分辨率丢失，因此作者考虑用多尺度特征融合的方式来保证在分辨率不丢失的情况下同时模型能够学习到更好的特征。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c01596ecbdaf8a4d52ea0d204f79423/" rel="bookmark">
			git 报错did not match any file(s） known to git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言： 在使用gitLab中时遇到一个问题，就是我在gitLab新建分支后，在本地切换分支不成功，遇到了这个问题，在大佬的博客的指点下，顺利解决这个问题，记录下我一步一步解决问题的过程，最后面是我参考大佬的地址，有兴趣的朋友可以去看一下。 问题展示：（目前情况是我已经建立好分支51test了，回到本地） 解决步骤： 1.首先我们看一下分支情况: git branch -a 2.在这里没有看到我们想要的分支,先获取所有分支: git fetch 3.可以看到有个 new branch 后面是我们新建的分支，切换到远程 51test (换成你自己)分支: git checkout origin/51test 4.执行 git branch git branch 5.现在我们可以从当前的 master 分支切换并新建分支 51test ,可以理解为即将新创建的分支是由当前 master 分支出来的(为了为后续做准备,此处新分支就叫做 51test ): git checkout -b 51test ***注意我们新建立的 51test 分支还不能和远程的 51test 分支建立追踪关系(虽然表面我们看似已经建立了 51test 分支,但git不认为它和远程的 51test 有任何关系), 可以用 git pull 来测试下，会报错 6.建立本地分支和远程分支的追踪关系,完了再用 git pull 测试下 git branch -u origin/51test 51test 到此就结束了，有想沟通的朋友欢迎留言，私聊哈，大佬入口 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2db6d88ac51039884e6e4c30a4c8f178/" rel="bookmark">
			【目标检测】RFBNet:Receptive Field Block Net for Accurate and Fast Object Detection（CVPR2017）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文：《Receptive Field Block Net for Accurate and Fast Object Detection》
论文链接：https://arxiv.org/abs/1711.07767
参考原文：https://blog.csdn.net/u014380165/article/details/81556769
http://www.sohu.com/a/300330661_787107
代码链接：https://github.com/ruinmessi/RFBNet
1、绪论部分： 当前顶级目标检测器依赖于非常深的CNN主干网络，例如ResNet-101和Inception，优点是它们具有强大的特征表现能力，但是耗时严重。相反地，一些基于轻量级模型的检测器满足实时处理，但是精度是诟病。
在RFBNet这篇论文中，主要想利用一些技巧使用轻量级模型达到速度和精度并举的检测器。灵感来自人类视觉的感受野结构Receptive Fields (RFs) ，提出了新奇的RF block（RFB）模块，来验证感受野尺寸和方向性的对提高有鉴别鲁棒特征的关系。RFBNet是以主干网络(backbone)为VGG16的SSD来构建的。下面是讨论其有效性，两项基准测试实验和结果显示。RFBNet具备同非常深的主干网络检测器的精度，但是保持了实时性。
2、RFB结构 RFB是一个类似Inception模块的多分支卷积模块，它的内部结构可分为两个组件：多分支卷积层以及随后的膨胀卷积层，如下图（Figure2）所示：
RFB结构主要有两个特点：
1、不同尺寸卷积核的卷积层构成的多分枝结构，这部分可以参考Inception结构。在Figure2的RFB结构中也用不同大小的圆形表示不同尺寸卷积核的卷积层。
2、引入了dilated卷积层，dilated卷积层之前应用在分割算法Deeplab中，主要作用也是增加感受野，和deformable卷积有异曲同工之处。
在Figure2的RFB结构中用不同rate表示dilated卷积层的参数。
在RFB结构中最后会将不同尺寸和rate的卷积层输出进行concat，达到融合不同特征的目的。在Figure2的RFB结构中用3种不同大小和颜色的输出叠加来展示。在Figure2的最后一列中将融合后的特征与人类视觉感受野做对比，从图可以看出是非常接近的，这也是这篇文章的出发点，换句话说就是模拟人类视觉的感受野进行RFB结构的设计。
RFB结构示意图如下所示：
（a）是RFB，整体结构上借鉴了Inception的思想，主要不同点在于引入3个dilated卷积层（比如3*3conv, rate=1），这也是这篇文章增大感受野的主要方式之一。
（b）是RFB-s，RFB-s和RFB相比主要有两个改进，一方面用3*3卷积层代替5*5卷积层，另一方面用1*3和3*1卷积层代替3*3卷积层，主要目的应该是为了减少计算量，类似Inception后期版本对Inception结构的改进。
3、RFBNet检测结构 Figure5是RFB-Net300的整体结构示意图，基本上和SSD类似，和SSD不同的是：
1、主干网上用两个RFB结构替换原来新增的两层。
2、conv4_3和conv7_fc在接预测层之前分别接RFB-s和RFB结构，这两个结构的示意图如前面Figure4所示。
4、实验结果 Table1是在PASCAL VOC2007 test-set数据集上的测试结果，训练集基于2007和2012的trainval。RFB Net300在mAP和FPS方面效果都不错。
Table4是在COCO test-dev 2015数据集上的测试结果。最后一个RFB Net512-E主要做了2点改变：1、对conv7_fc的输出特征做了上up-sample，然后和conv4_3的输出特征做融合，基于融合后的特征做预测。这种做法其实是借鉴了FPN算法的思想。2、在RFB结构中增加了7*7大小的卷积分支。这两点改进对效果的提升有一定帮助，而且带来的计算量也少。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1704e225f5d212f2a86336179f33c48/" rel="bookmark">
			ValueError: invalid literal for int() with base 10: &#39;123a&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出错语句 ValueError: invalid literal for int() with base 10: ‘123a’
问题解决思路：
（1）问题分析 首先对于语句的错误大概意思为 值错误，对于int（）类型进行无效的迭代。‘：’后面的为输入’xxx’导致值迭代出现错误的原因 ；
（2）解决办法 寻找可进行int（）类型转换，了解到int（）只能转化由纯数字组成的字符串。（如下图1）
图1 错误示例
（3）解决方案
1：分析对值进行int()类型的强制转换是否是必须的，若无关，则可以将int()类型删去
2：当输入的字符型中有小数点时（如图2），如下图‘12.3’，或者另一种‘[1，2，3，4]’数组形式。可以通过eval()函数，可以将字符串str当成有效的表达式来求值并返回计算结果。
对于包含小数点的字符，另外一种解决方案 ，首先利用float将其变成浮点型，然后进行强制int()变换
图2 当字符传含有小数点时
改正结果：
a=‘12.3’ #输入的为带小数点的数 类型str
type(a)
&lt;class ‘str’&gt;
b=eval(a) #通过eval()进行将str内容进行有效的内容进行返回
type(b)
&lt;class ‘float’&gt;
print(b) #得到浮点型数据 12.3
12.3
print(int(b)) #进行强制int型转换
12
c=float(a)
print( c)
12.3
type( c)
&lt;class ‘float’&gt;
print(int( c))
12
eval()函数的使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75e41bbba285770010ccdc941e3b11e9/" rel="bookmark">
			LTE中测量过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LTE当中的测量过程
一、测量控制下发的时机：在UE建立无线承载后，基站通过rrcConnectionReconfiguration下发测量配置信息，以下是常见的几个下发场景：
1、RRC建立完成后，下发同频，异频两个测量控制
2、切换后，目标基站收到ＵＥ发送的rrcConnectionReconfigurationComplete后，下发以上三条测量控制。
异频切换可以设置使用A2+A4事件方式或者A2+A3、A2+A5事件方式。
同频切换测量控制、测量、触发
异频切换测量控制、测量、触发
A1事件判决不等式
在基于覆盖的异频切换中，事件A1用于停止异频测量，表示服务小区的质量已经高于一定门限值。当事件A1满足上报条件并上报eNodeB后，将触发异频测量的停止。
1）进入该事件的条件：（Ms：服务小区测量值，RSRP单位dBm，RSRQ单位dB，Thresh：绝对门限值，单位同Ms，Hys：磁滞值，单位dB）
2）离开该事件的条件：（同上）
Ms是服务小区的测量结果；
Hys是事件A1迟滞参数，由参数InterFreqHoA1A2Hyst决定；
Thresh 事件A1的门限参数，根据事件A1A2测量触发类型InterFreqHoA1A2TrigQuan，可采用测量量RSRP和RSRQ作为事件A1的测量触发类型；
A2事件判决不等式
在基于覆盖的异频切换中，事件A2用于异频测量的触发，表示服务小区的质量已经低于一定门限值。当事件A2满足上报条件并上报eNodeB后，将触发异频测量配置的下发。事件A2的判决公式如下：
触发条件：Ms+Hys&lt;Thresh
取消条件：Ms-Hys&gt;Thresh
Ms是服务小区的测量结果；
Hys是事件A2迟滞参数，由参数InterFreqHoA1A2Hyst决定；
Thresh 事件A2的门限参数，根据事件A1A2测量触发类型InterFreqHoA1A2TrigQuan的选择，可分别采用测量量RSRP和RSRQ作为事件A2的评估判决
A3事件判决不等式
同频切换通过事件A3触发，且事件上报方式采用事件转周期的上报方式，事件A3的触发，即邻区质量高于服务小区一定偏置值。所以A3事件是一个邻区与服务小区的比较结果；
进入该事件的条件：Mn+Ofn+Ocn-Hys &gt; Ms+Ofs+Ocs+Off
离开该事件的条件：Mn+Ofn+Ocn+Hys &lt; Ms+Ofs+Ocs+Off
Mn为该邻区的测量结果，不考虑计算任何偏置。
Ofn为该邻区频率特定的偏置（即offsetFreq在measObjectEUTRA中被定义为对应于邻区的频率）；
Ocn为该邻区的小区特定偏置（即cellIndividualOffset在measObjectEUTRA中被定义为对应于邻区的频率），同时如果没有为邻区配置，则设置为零；
Ms 为没有计算任何偏置下的服务小区的测量结果；
Ofs为服务频率上频率特定的偏置（即offsetFreq在measObjectEUTRA中被定义为对应于服务频率）；
Ocs 为服务小区的小区特定偏置（即cellIndividualOffset在measObjectEUTRA中被定义为对应于服务频率），并设置为0，如果没有为服务小区配置的话；
Hys 为该事件的滞后参数（即hysteresis为reportConfigEUTRA内为该事件定义的参数）；
Off 为该事件的偏移参数（即a3-Offset为reportConfigEUTRA内为该事件定义的参数，也称A3门限）；
A3事件的触发条件可以简化为：Mn -Hys-Off&gt;Ms，Hys、Off默认配置，只要Mn大于Ms值3个dB即触发A3事件。
表示UE在上报A3事件测量报告后，如果满足上报A3事件条件，会每隔IntraFreqHoRprtInterval毫秒后上报A3事件测量报告（默认240ms），直到收到切换命令或不满足A3事件条件。
事件A3触发机制原理如下图所示，当事件A3在延迟触发时间TimeToTrig内都满足触发条件，则UE对事件A3进行事件转周期的上报，如下图：
A4事件判决不等式
异频切换通过事件A4触发，采取事件转周期的上报方式。事件A4的触发，即邻区质量高于一定门限值。所以，A4事件触发机制，是邻区质量高于绝对门限值的结果；
触发条件：Mn+Ofn+Ocn-Hys&gt;Thresh
取消条件：Mn+Ofn+Ocn+Hys&lt;Thresh
Mn是邻区测量结果；
Ofn是邻区频率的特定频率偏置，由参数QoffsetFreq决定，此参数在测量控制消息的测量对象中下发；
Ocn同A3事件中Ocn；
Hys是事件A4迟滞参数，由参数InterFreqHoA4Hyst决定，在测量控制消息中下发;
Thresh事件A4的门限参数；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a4c7f8d5e0dc8b73c140bad45957814/" rel="bookmark">
			Python find_element_by_xpath 通过 文本内容 定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查找具体的元素，必须在前面输入标准开头 “ // ”，表示从当前节点寻找所有的后代元素 1、通过文本内容定位
# HTML &lt;div&gt; &lt;span&gt;11111&lt;/span&gt; &lt;span&gt;22222&lt;/span&gt; &lt;span&gt;33333&lt;/span&gt; &lt;/div&gt; # 通过文本内容定位 22222 的 span 标签 find_element_by_xpath("//span[contains(text(),'22222')]") 2、选择第 几个 节点
# 先通过文本定位22222所在span标签 # 再通过 position 定位 33333的 span标签 find_element_by_xpath("//span[contains(text(),'22222')]/../span[position()=3]") find_element_by_xpath("//span[contains(text(),'22222')]/../span[3]") 3、定位上一层节点或上二层节点
# 通过 /.. 定位到 上一点节 find_element_by_xpath('//div[contains(text(),"红宝石")]/..') # 通过 /../.. 定位到 上上一点节 find_element_by_xpath('//div[contains(text(),"红宝石")]/../..') 3、根据 属性 定位
find_element_by_xpath("//div[@id='goods']") find_element_by_xpath("//div[@class='goods']") 4、可以通过赋值变量多次定位，实现目标
#把节点保存到变量 content content=driver.find_element_by_xpath('//div[contains(text(),"红宝石")]/../..') #通过 content 变量继续定位，此处注意要在 "/" 前台加 "." 指明当前节点位子开始定位 text=content.find_element_by_xpath("./td[7]/div/button") 5、选择同级节点
&lt;div class="el-form-item&gt; &lt;label for="transDate"&gt;...&lt;/label&gt; &lt;div&gt;...&lt;/div&gt; &lt;div&gt;...&lt;/div&gt; &lt;div&gt;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a4c7f8d5e0dc8b73c140bad45957814/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcebdf2e533faa20b95a4d9b93fa1df7/" rel="bookmark">
			使用div利用布局实现表格的效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用div利用布局实现表格的效果加粗样式 html代码
&lt;div class="table"&gt; &lt;div class="thead"&gt; &lt;div class="tr"&gt; &lt;div class="th"&gt; 用户名 &lt;/div&gt; &lt;div class="th"&gt; 角色名 &lt;/div&gt; &lt;div class="th edit"&gt; 操作 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="tbody"&gt; &lt;div class="tr"&gt; &lt;div class="td"&gt; 陈兰秀 &lt;/div&gt; &lt;div class="td"&gt; 财务 &lt;/div&gt; &lt;div class="td edit"&gt; &lt;span onclick="editRole()"&gt;编辑&lt;/span&gt; | &lt;span onclick="delRole()"&gt;删除&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="tr"&gt; &lt;div class="td"&gt; 吕洋 &lt;/div&gt; &lt;div class="td"&gt; 技术经理 &lt;/div&gt; &lt;div class="td edit"&gt; &lt;span&gt;编辑&lt;/span&gt; | &lt;span&gt;删除&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="tr"&gt; &lt;div class="td"&gt; 吕洋 &lt;/div&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcebdf2e533faa20b95a4d9b93fa1df7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc4cc48c224c46a36b1647c569530e04/" rel="bookmark">
			背景图片虚化的效果的css样式的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有写页面的时候，有一个需求，就是给页面一个背景，但是有一个要求，就是这个背景要有一个背景虚化的效果。
实现方式：css样式
核心的思路就是在有背景的div的下面再加一层和它等大的div,给这个div一个白背景，然后这个div透明
对应的代码如下
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * { padding: 0; margin: 0; } html, body { height: 100%; } .wrapper { height: 100%; width: 100%; position: relative; background-image: url('../../image/login-img/bgimg.jpg'); background-repeat: no-repeat; background-size: 100% 100%; } .bg-blur { position: absolute; left: 0; right: 0; top: 0; bottom: 0; background: rgba(255, 255, 255, .5); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc4cc48c224c46a36b1647c569530e04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21074c41514f061b5d99154b2ba721c0/" rel="bookmark">
			自定义select的样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在项目上用原生的html css js(jquery)进行页面的开发
有的需求要用到选择框
但是在项目上用原生的select 那肯定是不行的，样式太难看
下面我给出我对select样式自定义的实现
html 代码
&lt;div class="getRole"&gt; &lt;select name="role" id=""&gt; &lt;option value=""&gt;请选择角色&lt;/option&gt; &lt;option value="请选择"&gt;选择&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; 对应的css 代码
select:focus { outline: 0px; } select { border: none; height: 20px; /*很关键：将默认的select选择框样式清除*/ appearance: none; -moz-appearance: none; -webkit-appearance: none; width: 95%; padding-left: 10px; /*在选择框的最右侧中间显示小箭头图片*/ background: url("../../image/setting-img/down.png") no-repeat scroll right center transparent; /*为下拉小箭头留出一点位置，避免被文字覆盖*/ padding-right: 14px; } select::-ms-expand { display: none; } .getRole { margin: 20px 0; /* margin-left: -39px; */ width: 260px; height: 24px; border-radius: 3px; border: 1px solid #ccc; border-color: rgba(153, 129, 129, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21074c41514f061b5d99154b2ba721c0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/384/">«</a>
	<span class="pagination__item pagination__item--current">385/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/386/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>