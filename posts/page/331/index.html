<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59c651d58d7964c790e92f784d4d02b9/" rel="bookmark">
			undefined reference to `std::cout&#39;等错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		undefined reference to `std::cout'等错误 (1)gcc和g++都是GNU(组织)的一个编译器。
(2)后缀名为.c的程序和.cpp的程序g++都会当成是c++的源程序来处理。而gcc不然，gcc会把.c的程序处理成c程序。
(3)对于.cpp的程序，编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcbe865ff6fff66ba53531434a6200ce/" rel="bookmark">
			7. HBase实战之谷粒微博
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 HBase实战之谷粒微博1. 需求分析2. 代码实现2.1 代码设计总览2.2 创建命名空间以及表名的定义2.3 发布微博2.4 删除微博2.5 关注用户2.6 取关用户2.7 获取用户的的初始化页面2.8 获取用户的微博详情 3. 测试 ☆ HBase实战之谷粒微博 1. 需求分析 微博内容的浏览，数据库表设计。用户社交体现：关注用户，取关用户。拉取关注的人的微博内容。 2. 代码实现 2.1 代码设计总览 创建命名空间以及表名的定义创建微博内容表创建用户关系表创建用户微博内容接收邮件表发布微博内容添加关注用户移除（取关）用户获取关注的人的微博内容测试 创建guli-weibo的maven工程，引入以下依赖：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase-client&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase-server&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 然后在resources文件夹添加hbase-site.xml文件
&lt;?xml version="1.0"?&gt; &lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt; &lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://hadoop:9000/HBase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;!-- 0.98后的新变动，之前版本没有.port,默认端口为60000 --&gt; &lt;property&gt; &lt;name&gt;hbase.master.port&lt;/name&gt; &lt;value&gt;16000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;hadoop,hadoop101,hadoop102&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; &lt;value&gt;/opt/module/zookeeper-3.4.6/zkData&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 工程文件结构如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcbe865ff6fff66ba53531434a6200ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a01dc5172ba854ad6d327c8dffe12f8b/" rel="bookmark">
			路由技术——OSPF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基础理论部分：邻居关系建立
1.OSPF 报文类型以及每一种报文的作用？（提示：hello 作用有4个）
2. 描述一下OSPF 工作流程？
3.Router ID 选举原则
4.OSPF建立邻接的条件:【提示：报头、hello、DBD 中的参数， 共11点】
5.OSPF 邻居建立过程
6 .隐式确认交互过程
7. OSPF 网络类型
8.每一种网络类型下的报文发送是使用单播还是组播，如果是组播， 地址是多少？hello 发送时间是多少
9. 点到点与点到多点的网络类型能否建立邻居，能否传递路由？如果想建立邻居， 如何修改参数？
10.DR 和 BDR 的作用和竞选规则？
11. 为什么DR不可以抢占？
12.IS-IS也有一个广播的网络类型，和OSPF中的DR一样有一个DIS，这个DIS是可以被抢占的，叫指定中间系统，为什么DIS支持被抢占？
13.OSPF开销的计算方式：
14. 5类LSA有哪几种计算外部路由metric值的方式，有什么区别？
15.两种外部路由metric计算方式怎么进行优选比较？
16.OSPF 是如何进行防环的？[提示：区域内的防环：区域间防环：外部路由防环：]
17. 真ABR 与伪ABR 的概念和ABR的防环规则
18.LSA 能不能汇总，在哪里汇总，为什么？
19 .OSPF路由选路的原则，及在什么情况下会负载，
20.如果有多台ABR存在，是每台ABR都会进行7转5操作吗？转换者选举原则是什么？
进阶理论：OSPF LSA
21.，1类LSA 是谁产生的？1类LSA都包含哪些信息？有几种链路类型？描述一下每一种链路类型， Link ID，adv router 是什么？cost 如何计算？
22.2类LSA 是谁产生的？2类LSA 包含的内容是什么， Link ID，adv router 是什么？
23. 3类LSA 是谁产生的?3类LSA 包含的内容是什么， Link ID 是什么， ADV Router 是什么， 跨区域传递ADV Router 如何改变？cost 是多少？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a01dc5172ba854ad6d327c8dffe12f8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6afcad83f55830392a4e6789fffa2594/" rel="bookmark">
			【Python报错解决方案】TypeError: ‘float‘ object is not callable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近又开始写代码了，今天学习神经网络的BP时候发现了一个报错并且在网站上看了，大部分的解释都很简单但是有很难懂，但是人家的方法也是可以用的。其实这个错误非常简单，但如果你不注意就或报错并且由于太简单了就很难发现。
解决方法：
在数与数之间的加减乘除符号不能省略
例子
报错代码
w[1] = w[1]-0.5( t1 * w[7] + t2 * w[8] )*h1*(1.0-h1)*l[1] 这段代码会报错！！！！
错误：TypeError: ‘float’ object is not callable
解决代码
w[1] = w[1]-0.5*( t1 * w[7] + t2 * w[8] )*h1*(1.0-h1)*l[1] 区别：
出错代码省略了一个乘号
----------------分享完毕，解决请【点赞】哈 ------------------------
Address：北京
Date：20210131
喜欢可以关注【小猪课堂】公众号了解更多内容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b430383781872526f2a226815c2f8b79/" rel="bookmark">
			decimal类型怎么算字节数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相比于float，double类型，decimal类型属于精确类型，不会丢失精度，所以只要涉及到金钱，财务相关的数据，对应的类型一定要选择decimal。
那么decimal类型怎么算字节数，怎么看支持的数字可以到几位小数和几位整数呢？
举个例子，数据库的商品售价字段类型被定义为Decimal(18,9)，18这个数代表着商品售价最长可以到18位，而9这个数字表示小数点后面有9位数字，那么18-9=9，也就得出了整数位可以有9位。
对于decimal类型来说，每4个字节存9个数字，那么以上数据一共有18位，所以会有18/9x4=8,再加上小数点会占一个字节，所以8+1=9，因此decimal(18,9)占用9个字节。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07e69d1dd36f208b5eb93b2ccfc6be00/" rel="bookmark">
			了解下自然主键和代理主键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自然主键：指的是事务属性中的自然唯一标示，比如员工的身份证号，除了可以充当主键之外，同时也是员工信息的重要组成部分。
代理主键：指的是与业务无关，无意义的数字序列值，仅仅具有主键的作用，比如自动增长的ID。
个人建议，开发中使用代理主键，与业务解耦，避免数据操作和迁移出现问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44fde9ef9df24cdf60d5bdf01bf10c64/" rel="bookmark">
			VB Option Compare语句 在模块级别中使用，用于声明字符串比较时所用的缺省比较方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作用
在模块级别中使用，用于声明字符串比较时所用的缺省比较方法。
语法
Option Compare {Binary | Text | Database} 说明
1，如果使用，则 Option Compare 语句必须写在模块的所有过程之前。
2，Option Compare 语句为模块指定字符串比较的方法（Binary、Text 或 Database）。如果模块中没有 Option Compare 语句，则缺省的文本比较方法是 Binary。
3，Option Compare Binary 是根据字符的内部二进制表示而导出的一种排序顺序来进行字符串比较。在 Microsoft Windows 中，排序顺序由代码页确定。典型的二进制排序顺序如下例所示：
A &lt; B &lt; E &lt; Z &lt; a &lt; b &lt; e &lt; z &lt; _ &lt; _ &lt; _ &lt; _ &lt; _ &lt; �
4，Option Compare Text 根据由系统国别确定的一种不区分大小写的文本排序级别来进行字符串比较。当使用 Option Compare Text 对相同字符排序时，会产生下述文本排序级别：
(A=a) &lt; ( =) &lt; (B=b) &lt; (E=e) &lt; (=) &lt; (Z=z) &lt; (=)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44fde9ef9df24cdf60d5bdf01bf10c64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85086351725b092ff21daf8beaa347cd/" rel="bookmark">
			IEEE文献免费下载方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法：SCI-Hub SCI-Hub网址
随便选择上图红色框框内的一个链接即可，然后会进入下面界面：
然后把需要下载的文献的DOI输入到上图红框里面，然后再点击open就可以加载出PDF格式的文献，然后就可以点击save进行下载
DOI的获取办法：
如果是下载IEEE文献的话，那么就进入IEEE官网：IEEE官网网址
把文献名字输入进去点击搜索即可
如果在SCI-Hub中出现加载PDF失败的话，那么就使用第二种方法进行下载 第二种方法：飞鸟科研助手 飞鸟科研助手官网
同样是输入DOI即可下载，DOI获取办法同上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35ccee38c2e3f8a88d2ce6a39668ea1d/" rel="bookmark">
			mysql安装完成后怎么打开_Python与Mysql怎么完成大量的数据交互？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你不了解python，可以先了解python的简单用法。不过人邮君相信，在座的各位都是大佬，我们直接介绍操作。
第一部分，我们先来介绍python与mysql如何完成数据交互： python 与 mysql 实现交互的过程，通常分为：建立连接、把sql语句定义为字符串，提交指令、关闭连接。
核心的技能在于 sql语句；除了定义sql语句，其余3个处理都是固定的写法。接下来，人邮君结合《MySQL是怎样运行的》这本书，以Linux环境为主，为大家进行说明。
MySQL是怎样运行的 从根儿上理解MySQL
首先来看第一步，安装 MySQL 数据库：
如果你想要使用python操作MySQL数据库，就必须先要安装pymysql库，这个库的安装很简单；
第二步，pymysql 模块安装与使用：
MySQL-python驱动，是python 操作mysql必不可少的模块。
下载MySQL-python-1.2.5.zip 文件之后直接解压。进入MySQL-python-1.2.5目录:
&gt;&gt;python setup.py install
下载地址：https://pypi.python.org/pypi/MySQL-python/
第三步，python与mysql的交互实现：
1)连接
pymysql .connect () 函数：连接数据库
使用 pymysql 的 connect() 方法连接数据库，涉及到几个参数，具体代表意义如下：
host：MySQL服务的地址，若数据库在本地上，使用 localhost 或者127.0.0.1。如果在其它服务器上，则写对应的 IP地址
port：服务的端口号，默认为3306，不写则为默认值。
user：登录数据库的用户名
passwd：登录 MySQL 的密码
db：数据库名
charset：设置为 utf8 编码，解决存汉字乱码问题
eg：
# 导入模块import pymysql# 打开数据库连接conn = pymysql.connect( host="127.0.0.1", user="root", password="123456", database="test_db", charset="utf8")print(conn)print(type(conn)) 输出结果显示如下：表面数据库连接成功
详细可以参考
https://www.cnblogs.com/qjj19931230/p/12550384.html?utm_source=tuicool
这里要强调的是，除了上面的连接方式，还有其他的连接。在《MySQL是怎样运行的》这本书中，介绍到，mysql连接分为内连接和外连接。内外连接的根本区别是在驱动表中记录不符合ON子句中的连接条件时，内连接不会把该记录加入到最后的结果集中，而外连接会。外连接分为左(外)连接和右(外)连接。
三种链接方式如下图所示：
2)获取游标
conn.cursor():获取游标
对数据库进行操作，只连接数据库是不够的，还需要获取操作数据库的游标，才能进行后续的操作。游标的主要作用是用来接收数据库操作后的返回结果，比如数据查询、插入和删除等。通过获取到的数据库连接实例 conn 下的 cursor() 方法来创建游标，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35ccee38c2e3f8a88d2ce6a39668ea1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/979126a06c4b4ce6e8b8c4258ff38ec5/" rel="bookmark">
			深度学习的视觉跟踪：一个全面的调查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章翻译自一篇外文文献，仅供学习之用。
Deep Learning for Visual Tracking: A Comprehensive Survey Seyed Mojtaba Marvasti-Zadeh, Student Member, IEEE, Li Cheng, Senior Member, IEEE,
Hossein Ghanei-Yakhdan, and Shohreh Kasaei, Senior Member, IEEE
摘要—视觉目标跟踪是计算机视觉中最抢手但最具挑战性的研究主题之一。鉴于病态问题的性质及其在各种实际场景中的流行程度，许多大型基准数据集已经建立，并已开发出许多方法并证明了这些方法在近年来取得了重大进展-主要是基于最近的深度学习（DL）的方法。这项调查旨在系统地调查当前基于DL的视觉跟踪方法，基准数据集和评估指标。它还广泛评估和领先的视觉跟踪方法。首先，从六个方面总结了基于DL的方法的基本特征，主要动机和贡献关键方面：网络体系结构，网络开发，视觉跟踪的网络培训练，网络目标，网络输出以及利用相关滤波器的优势。其次，比较了流行的视觉跟踪基准及其各自的属性，并总结了它们的评估指标。第三，在集合上检查基于DL的最新方法成熟的OTB2013，OTB2015，VOT2018和LaSOT基准测试。最后，通过对这些状态进行关键分析，在数量和质量上都采用了最先进的方法，研究了它们在各种常见情况下的优缺点。可以作为从业人员的使用指南，帮助他们权衡何时，在何种条件下选择哪种方法。它还有助于讨论正在进行中的问题，并阐明有前途的研究方向。
目录
Deep Learning for Visual Tracking: A Comprehensive Survey
1. 介绍
2.深层视觉跟踪方法的分类法
2.1 网络架构
2.1.1卷积神经网络（CNN）
2.1.2暹罗神经网络（SNN）
2.1.3递归神经网络（RNN）
2.1.4生成对抗网络（GAN）
2.1.5自定义网络
2.2 网络利用
2.2.1模型重用或深度可用的功能
2.2.2用于视觉跟踪的深度功能
2.3网络训练
2.3.1 仅离线培训
2.3.2仅在线培训
2.3.3离线和在线培训
2.4网络目标
2.4.1基于分类的目标函数
2.4.2基于回归的目标函数
2.4.3基于分类和回归的目标函数
2.5网络输出
3. 视觉跟踪基准数据集
3.1视觉跟踪数据集
3.2 评估指标
3.2.1 绩效考核
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/979126a06c4b4ce6e8b8c4258ff38ec5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f86e4fdf0979d0436025afdf61821de7/" rel="bookmark">
			安装mxnet失败的第31天！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习框架mxnet的安装： 放在前面，我终于成功了 C:\ProgramData\Anaconda3&gt;python.exe -c "import mxnet as mx; print(mx.nd.zeros((1,2), ctx=mx.gpu()) + 1)" [[1. 1.]] &lt;NDArray 1x2 @gpu(0)&gt; 根据各方提示，我先是去NVIDIA的控制面板查看自己需要安装的CUDA 的版本，显示我可以安的是cuda10.2，去官网，失败了N天以后，学会了百度下有没有好心人的国内资源。。。。
成功安好CUDA10.2，本身已经有了Anacoda,所以就剩下安装Mxnet了，然后按照教程进行了下面的操作：
D://PortableProgram/Anaconda3/python.exe -m pip install --pre mxnet-cu102 -f https://dist.mxnet.io/python/cu102 果不其然的，失败了好多天，每天尝试一次，每天失败一次，网络上各种说法都有，每天试一试，心情特别好。。。。。
解决方案： 最终在今天，我决定放弃所谓的最适合的版本，卸载了CUDA10.2，重新安装了cuda10.1 再回到教程，进行安装：
D://PortableProgram/Anaconda3/python.exe -m pip install mxnet_cu101 -i https://pypi.tuna.tsinghua.edu.cn/simple 如果失败，可以根据提示，一般都是加上 --user
C:\ProgramData\Anaconda3&gt;python.exe -m pip install mxnet_cu101 --user -i https://pypi.tuna.tsinghua.edu.cn/simple 一次成功，测试结果如最开始！！！
思考 不要追求什么都是最新版本，老姜才是稳定的！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44b6ba5053a7dd4ef12e0314301b4e8d/" rel="bookmark">
			vue导入音乐_vue中添加mp3音频文件的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有的时候我们需要在vue中添加音频文件，但是直接将音频文件放置了assets目录下的时候，会发现并不能正常播放，下面是两种常用的配置方法：
方法一、将音频文件放置在static目录中，然后进行调用，如下所示
dio class="success"
src="/static/audios/do_wrong.mp3"&gt;
以上这种方式就能够解决这个问题了。
方法二、给项目配置mp3格式的解析器
1、在webpack.base.conf.js中添加加载器，如下
2、在vue-loader.conf.js文件为audio的src属性添加转换属性选项，让 vue-loader 知道需要将 audio 的 src 属性的内容转换为模块。
module.exports = {
loaders: utils.cssLoaders({
sourceMap: isProduction
? config.build.productionSourceMap
: config.dev.cssSourceMap,extract: isProduction
}),transformToRequire: {
"audio": "src"
}
}
3、添加audio标签，引入资源文件
dio autoplay="autoplay"
controls="controls"
preload="auto"
src="../assets/allright.mp3"&gt;
此时的资源文件放置在assets目录下即可。
4、重新启动项目或者打包发布，即可听到声音。
以上就是本文的全部内容，希望对大家的学习有所帮助，也希望大家多多支持编程之家。
总结
以上是编程之家为你收集整理的vue中添加mp3音频文件的方法全部内容，希望文章能够帮你解决vue中添加mp3音频文件的方法所遇到的程序开发问题。
如果觉得编程之家网站内容还不错，欢迎将编程之家网站推荐给程序员好友。
本图文内容来源于网友网络收集整理提供，作为学习参考使用，版权属于原作者。
如您喜欢交流学习经验，点击链接加入交流1群：1065694478(已满)交流2群：163560250
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4c4cf5c059632d93f9dfbd356626802/" rel="bookmark">
			重启redis集群_redis集群原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis集群原理 一、主从架构 1、架构图 （图略）
2、主从复制概述： 主从复制的作用： ​数据副本（对数据在别的服务器上面进行备份，且从服务器中的数据将会清空并备份主服务器中的数据） 拓展读的性能（客户端访问服务器的时候访问从节点，从而减少对主服务器的访问压力） 存在的问题：
主节点出现故障的时候，需要手动故障转移，使得在从节点slave中产生一个父节点master【所以需要引入哨兵模式】写能力和存储能力受限(只能对主节点master进行写和存储的操作) 主从复制的实现方式： ​ 1、命令：（优点：无需重启，缺点：不便于管理）
​ slaveof ip port：设置ip地址为当前服务器中的从服务器，从而实现主从关系。
​ slaveof no one：取消当前服务器的所有主从关系，不允许有成为任何服务器的从属服务器，但是之前备份的数据不会被删除，只是说之后产生的数据从服务器不会进行备份。
​ 2、配置：(在redis启动之前进行配置，优点：统一配置，缺点：需要重启)
​ slaveof ip port：设置从节点的ip和端口
​ slave-read-only yes：设置节点为只读模式，这样会产生节点直接的数据不同步，即从服务器设置为只读模式，主服务器修改了数据，从服务器能同步备份数据，但是如果从服务器修该了数据，主服务不会产生备份效果。
3、主从复制原理 ​ 一些概念：
​ （1）run_id：每次启动redis都会分配一个id，重启之后run_id会变化。
​ （2）offset：请求master数据得偏移量，部分复制
​ （3）repl_backlog_size：复制缓冲区大小，默认为1M，部分复制的时候，如果offset在这个范围内，则开始部分复制，否者要进行全量复制。可以修改这个大小以达到更好地复制机制。
​ redis复制形式分为全量复制和增量复制两种
​ 全量复制的情况：
​ (1) redis slave首次启动或重启时发生
​ (2) redis slave进程没有重启，但是掉线了，重新连接后不满足部分复制的条件
​ 增量复制的情况：
​ (1) 主从的redis版本&gt;=2.8
​ (2) redis slave进程没有重启，但是掉线了，重连了master(因为slave进程重启的话，run id就没有了)
​ (3) redis slave保存的run id与master当前run id一致 (注：run id并不是pid，slave把它保存在内存中，重启就消失)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4c4cf5c059632d93f9dfbd356626802/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12a76fcc8930b71eba9e7e026d7d87cb/" rel="bookmark">
			uml边界类例子_UML 边界类、控制类、实体类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标签：
来源：http://bbs.csdn.net/topics/300192417
UML中类有三种主要的版型：边界类、控制类和实体类。引入边界类、控制类及实体类的概念有助于分析和设计人员确定系统中的类。
边界类位于系统与外界的交界处，窗体、报表、以及表示通讯协议的类、直接与外部设备交互的类、直接与外部系统交互的类等都是边界类。通过用例图可以确定需要的边界类，每个Actor/Use Case对至少要一个边界类，但并非每个Actor/Use Case对要唯一的边界类。
实体类保存要放进持久存储体的信息。持久存储体就是数据库、文件等可以永久存储数据的介质。实体类可以通过事件流和交互图发现。通常每个实体类在数据库中有相应的表，实体类中的属性对应数据库表中的字段。
控制类是控制其他类工作的类。每个用例通常有一个控制类，控制用例中的事件顺序，控制类也可以在多个用例间共用。其他类并不向控制类发送很多消息，而是由控制类发出很多消息。
例如在考试系统中 当学生在考试时 ,学生与试卷交互 那么 学生和试卷都是实体类,而考试时间 ,规则,分数都是边界类; 当考试完了将试卷提交给试卷保管者 ,则 试卷则成了边界类.
标签：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d9a41ae722811a3a2ce7bad7e44a378/" rel="bookmark">
			解决Some index files failed to download.They have been ignored, or old ones used instead报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用sudo apt-get update后报错：
Err:1 http://ppa.launchpad.net/wireshark-dev/stable/ubuntu bionic InRelease Temporary failure resolving 'ppa.launchpad.net' Err:2 http://security.ubuntu.com/ubuntu bionic-security InRelease Temporary failure resolving 'security.ubuntu.com' Err:3 http://archive.ubuntu.com/ubuntu bionic InRelease Temporary failure resolving 'archive.ubuntu.com' Err:4 http://archive.ubuntu.com/ubuntu bionic-updates InRelease Temporary failure resolving 'archive.ubuntu.com' Err:5 http://archive.ubuntu.com/ubuntu bionic-backports InRelease Temporary failure resolving 'archive.ubuntu.com' Reading package lists... Done W: Failed to fetch http://archive.ubuntu.com/ubuntu/dists/bionic/InRelease Temporary failure resolving 'archive.ubuntu.com' W: Failed to fetch http://archive.ubuntu.com/ubuntu/dists/bionic-updates/InRelease Temporary failure resolving 'archive.ubuntu.com' W: Failed to fetch http://archive.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d9a41ae722811a3a2ce7bad7e44a378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9a4ec61769bf86af2dff816d3895291/" rel="bookmark">
			mysql复制表格的语句_MySQL复制表结构 表数据sql语句总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复制整个表
代码如下
create table new_table select * from old_table;
复制表,不复制数据
代码如下
create table new_table select * from old_table where 0;
主键，索引，自增等其他额外特征不会被带到新表中。这点和其他的数据库产品类似。
上面为核心两句了
1、MySQL复制表结构及数据到新表
代码如下
CREATE TABLE `新表` SELECT * FROM `旧表`
2、只复制表结构到新表
代码如下
CREATE TABLE `新表` SELECT * FROM `旧表` WHERE 1=2
或
CREATE TABLE `新表` LIKE `旧表`
3、复制旧表的数据到新表(假设两个表结构一样)
代码如下
INSERT INTO `新表` SELECT * FROM `旧表`
4、复制旧表的数据到新表(假设两个表结构不一样)
代码如下
INSERT INTO `新表`(字段1,字段2,…….) SELECT 字段1,字段2,…… FROM `旧表`
5、show create table 旧表;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9a4ec61769bf86af2dff816d3895291/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81205335e21e3252f49d51649181e86b/" rel="bookmark">
			五种基本单例模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录标题 模式简介饿汉式懒汉式懒汉式(双重检验锁)静态内部类枚举类型 模式简介 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。
注意：
1、单例类只能在一个jvm实例中有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 接下来我们介绍一下我们常见到的几种单例模式:
饿汉式 正如其名"饿汉" ，类加载的时候就实例化，并且创建单例对象。优点: 先天性线程安全 当类初始化的时候 该对象就会被创建
缺点 : 如果项目中使用过多的饿汉式就会发生问题,项目启动会很慢,存放在方法区中占用内存较大
public class demo1 { /* 饿汉式 : 优点 先天性线程安全 当类初始化的时候 该对象就会被创建 缺点 : 如果项目中使用过多的饿汉式就会发生问题,项目启动会很慢,存放在方法区中占用内存较大 */ private static demo1 singleTon = new demo1(); private demo1(){ } public static demo1 getInstance(){ return singleTon; } } 懒汉式 只有在需要的时候才会加载 但是在多线程的情况下 会出现线程安全的问题. 实例对象可能被初始化多次
public class demo2 { private static demo2 singleTon; //懒汉式的单例模式 private demo2(){ } public static demo2 getInstance(){ if(singleTon==null){ singleTon = new demo2(); } return singleTon; } } 对于饿汉式它会存在,在多线程的情况下,线程不安全的问题,实例化的对象(单例对象)可能被实例化多次,这里我们做一个测试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81205335e21e3252f49d51649181e86b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1db3eea752460203efe6f18bb91f3767/" rel="bookmark">
			主流边缘端部署嵌入式平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主流边缘端部署嵌入式平台 文章目录 引言RK1808RK1808人工智能计算棒RK1808芯片架构优势极致低功耗强大AI运算能力面向AIoT应用的丰富接口易于开发 RK1808具体的规格信息RK1808测评 NVIDA Jetson Nano、 tx1/2、Xavier测评规格参数优势 树莓派3/4测评规格参数总结 引言 AIoT开启了继物联网、人工智能后又一大想象无限的领域，同时也给智慧物联、人工智能在应用层面拓展更多可能性开启新的篇章。边缘计算对势头正盛的物联网的发展至关重要。近日，机器学习和数据科学咨询公司 Tryolabs 发布了一篇基准评测报告，测试比较了英伟达 Jetson Nano、谷歌 Coral 开发板（内置 Edge TPU）、英特尔神经计算棒这三款针对机器学习设计的边缘计算设备以及与不同的机器学习模型的组合。结果表明，无论是在推理时间还是准确度方面，英伟达的 Jetson Nano 都是当之无愧的赢家。另外他们也给出了在树莓派 3B 与英伟达 2080ti GPU 上的结果以供参考。
RK1808 RK1808人工智能计算棒 便携的边缘计算设备，有基于Movidius Myriad 2的神经计算棒一代，而后有基于Google Edge TPU的Coral神经计算棒、INTEL Myriad X的神经计算棒二代，“若派Ropal”神经计算棒，Intel加速棒等，虽然说各有特色，但还是有一个共同点，那就是不便宜，对于国内一些想开拓边缘计算领域的中小企业或者走量的企业来说，成本不是太好控制，因此推荐国产瑞芯微RK1808人工智能计算棒——一款物美价廉的深度学习开发工具。
基于RK1808 NPU芯片，主要面向基于人工智能平台以及边缘计算产品的深度学习开发者。
RK1808人工智能计算棒算是众多边缘计算设备中的佼佼者，外观时尚精致，尺寸只有60mm*19mm（差不多传统U盘大小），并且有多种颜色可选。接口采用USb3.0 Type A接口，无风扇设计，利用USB接口供电，使用时无需连接云端，即可为开发主机设备以及众多第三方的单板计算机提供基于深度学习网络模型的推理加速。
瑞芯微RK1808人工智能计算棒的内置芯片RK1808，这是在瑞芯微在CES2019消费电子展发布的一款内置高能效NPU的AIoT芯片解决方案，在硬件规格上，瑞芯微RK1808 AIoT芯片采用双核Cortex-A35架构，NPU峰值算力高达3.0TOPs，VPU支持1080P视频编解码，支持麦克风阵列并具有硬件VAD功能，支持摄像头视频信号输入并具有内置ISP。
RK1808芯片架构 优势 极致低功耗 芯片采用22nm FD-SOI工艺，相同性能下功耗相比主流28nm工艺可降低30%左右；内置2MB系统级SRam，可实现always-on设备无DDR运行；具有硬件VAD功能，支持低功耗侦听远场唤醒。 强大AI运算能力 内置的NPU算力最高可达3TOPs；支持INT8/INT16/FP16混合运算，最大程度兼顾性能、功耗及运算精度；支持tensorflow/MXNet/PyTorch/Caffe等一系列框架的网络模型转换，兼容性强。 面向AIoT应用的丰富接口 RK1808具有丰富的外设接口，便于应用扩展，视频支持MIPI/CIF/BT1120输入，支持MIPI/RGB显示输出；具有PWM/i2C/SPI/uart等一系列传感器输入输出接口；具有USB3.0/USB2.0/PCIE等高速设备接口，支持千兆以太网及外置WiFi/BT模块；音频支持麦克风阵列输入，同时支持音频输出。 易于开发 支持LINUX系统，AI应用开发SDK支持C/c++及Python，方便客户浮点到定点网络的转换以及调试，开发便捷度极强。 总所周知，AI算力是制约AI产业发展和开发者创新的痛点之一，瑞芯微RK1808 AIoT芯片平台具备的可无限量叠加、级联特性，将激活更丰富的AI应用场景与创新产品，满足产业链合作伙伴对AI高性能计算的产品需求。
RK1808具体的规格信息 在封装上，RK1808采用FCCSP 420封装，0.3mm balls，球间距为0.5/0.35mm，说穿了这款芯片绝不适合业余爱好者去折腾，还是适合有实力的企业去开发，个人用户使用这些企业现成的产品即可，或者使用瑞芯微刚刚推出的RK1808人工智能计算棒。
双核Cortex-A35，内部集成2MB SRAMDDR 32位 数据宽度，最大支持2GB DDR3/DDR3L/LPDDR3/LPDDR3L-1600集成512KB内部缓冲区的神经处理单元，支持：每个周期支持最多1920 Int8，最多192 Int16以及最多64 FP16 MAC操eMMC 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1db3eea752460203efe6f18bb91f3767/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22a5e6a361ce5d9601bc4126f6b37a87/" rel="bookmark">
			Java注解@Mock和@InjectMocks及@Mock和@Spy之间的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java注解@Mock和@InjectMocks及@Mock和@Spy之间的区别
1.@Mock和@InjectMocks的区别
@Mock为您需要的类创建一个模拟实现。
@InjectMocks创建类的一个实例，并将用@Mock或@Spy注释创建的模拟注入到这个实例中。
注意，必须使用@RunWith(MockitoJUnitRunner.class)或Mockito.initMocks(this)初始化这些模拟并注入它们。
下面给出一个使用示例：
假设我们有Game和Player两个Class。
class Game { private Player player; public Game(Player player) { this.player = player; } public String attack() { return"Player attack with:" + player.getWeapon(); } } class Player { private String weapon; public Player(String weapon) { this.weapon = weapon; } String getWeapon() { return weapon; } } 如您所见，Game类需要Player类来执行attack方法。
@RunWith(MockitoJUnitRunner.class) class GameTest { @Mock Player player; @InjectMocks Game game; @Test public void attackWithSwordTest() throws Exception { Mockito.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22a5e6a361ce5d9601bc4126f6b37a87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d9b3cf698f00ab81c0213a7f815f282/" rel="bookmark">
			【Rcode】生存分析： KM &amp; COX回归&amp; 随机森林&amp; nomogram
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文使用了R——survival包下的lung数据进行方法测试：
1）KM 2) Cox回归：多因素 3）随机森林因子（根据cox回归结果） 4）nomogram （ 根据cox回归结果，建立了中位生存时间，1年5年生存率的概率计算）
-----🧚🏽‍♀️本文只有干货，非常干！🤣-----
一、数据加载 #生存分析
library("survival") library("survminer") data("lung") head(lung) 结果： &lt;head(lung) inst time status age sex ph.ecog ph.karno pat.karno meal.cal wt.loss 1 3 306 2 74 1 1 90 100 1175 NA 2 3 455 2 68 1 0 90 90 1225 15 3 3 1010 1 56 1 0 90 90 NA 15 4 5 210 2 57 1 1 90 60 1150 11 5 1 883 2 60 1 0 100 90 NA 0 6 12 1022 1 74 1 1 50 80 513 0 二、KM方法和非参数检验 #---------------KM方法-------------------------
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d9b3cf698f00ab81c0213a7f815f282/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bcab6bcfe4a254aefba532720792a6e/" rel="bookmark">
			RTSP协议视频智能分析/智能识别系统EasyNVR运行一段时间后自动掉线如何排查？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TSINGSEE青犀视频云边端架构视频智能分析平台EasyNVR、EasyCVR等具备视频流拉取、转码、分发的功能，并且我们提供丰富的API接口进行二次开发。EasyNVR等平台同时配备了演示平台以及测试账号，如果大家有需求，可以直接下载部署测试。
这段时间我们碰到一个关于EasyNVR掉线的问题，某台服务器上的EasyNVR服务总是会自动断掉，目前我们只发现一例此类问题。
在发现该问题的时候，EasyNVR会维持一段时间的正常运行，但是过了一段时间或者过了几天后，服务就断掉了，摄像头也全部无法播放。我们通过检查日志发现nginx文件里面的data.conf文件有问题。
这个文件是一分钟刷新一次的，刷新一次就会更新一次数据，但是在该服务器上，我们发现每次刷新的数据都是一样的，EasyNVR服务就是因为数据有误导致无法运行。
通过研发分析，此处可能是nginx的刷新机制出现了问题，解决方案只能是把data.conf文件删掉，然后重新启动，系统就会自动生成一个新的data.conf文件，此时就可以正常使用EasyNVR服务了。
EasyNVR作为视频安防云服务平台，支持从海康、大华、宇视等网络硬盘录像机NVR按设备、通道、日期获取对应视频文件进行直播或者录像的检索与回放，无需安装各个安防厂商的视频播放插件。如果大家还想了解EasyNVR更多操作说明，欢迎联系我们了解咨询。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0320a88e2d3ba8bf8173a3946af0aa8/" rel="bookmark">
			centos使用storcli工具查看服务器硬盘和raid组信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装storcli：
# yum install storcli 安装后在/opt/Mega/stocli目录下
2.参数定义：
/cx = Controller ID
/vx = Virtual Drive Number
/ex = Enclosure ID
/sx = Slot ID
3.为了方便使用，可建立软链接
# ln -s /opt/MegaRAID/storcli/storcli64 /bin/storcli # ln -s /opt/MegaRAID/storcli/storcli64 /sbin/storcli 若不想建立软链接，可在/opt/MegaRAID/stocli目录下执行./storcli64指令
4.查看当前设备raid控制器相关信息
# ./stocli64 show all CLI Version = 007.1316.0000.0000 Mar 12, 2020
Operating system = Linux 4.19.90
Status Code = 0
Status = Success
Description = None
Number of Controllers = 1
Host Name = localhost.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0320a88e2d3ba8bf8173a3946af0aa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fa8f3ea70170849ef43b6bd585f633f/" rel="bookmark">
			python代码转java工具_Python代码转为java代码？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是一段Python的加密代码 ：
import md5
def encrypted_id(id):
byte1 = bytearray('3go8&amp;$8*3*3h0k(2)2')
byte2 = bytearray(id)
byte1_len = len(byte1)
for i in xrange(len(byte2)):
byte2[i] = byte2[i]^byte1[i%byte1_len]
m = md5.new()
m.update(byte2)
result = m.digest().encode('base64')[:-1]
result = result.replace('/', '_')
result = result.replace('+', '-')
return result
请问如何改写为java代码？
下面是我改写的java代码，但是返回的结果始终为空：
public static String md5(String musicID) throws NoSuchAlgorithmException {
System.out.print(musicID);
String result;
byte[] byte1, byte2;
String word = "3go8&amp;$8*3*3h0k(2)2";
byte1 = word.getBytes();
byte2 = musicID.getBytes();
int byte2_len = byte2.length;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fa8f3ea70170849ef43b6bd585f633f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70be37f58d92ebf5dc9045d7e588c8c2/" rel="bookmark">
			python中的方法和函数的区别_Python中函数和方法的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中函数和方法是有区别的。
区别一所处的位置：函数是直接写文件中而不是class中，方法是只能写在class中。
区别二定义的方式：
1.函数定义的方式 def关键字 然后接函数名 再是括号 括号里面写形参也可以省略不写形参
def functionName():
"""这里是函数的注释"""
print("这一块写函数的内容")
2.方法定义的方式， 首先方法是定义在类中的，其他大体和函数定义差不多，这里需要注意的一点就是方法必须带一个默认参数(相当于this)，静态方法除外
class className(super):
def methodName(self):
"""这里是方法的注释
self相当于this；
"""
print("这里是方法的内容")
区别三调用的方式：
1.函数的调用：函数的调用是直接写 函数名(函数参数1,函数参数2,......)
def functionName():
print("这是一个函数")
#调用
functionName()
2.方法的调用：方法是通过对象点方法调用的(这里是指对象方法)
class className:
def method(self):
print("这是一个方法")
#调用---------------------
#实例化对象
c=className()
c.method()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dff6e492b459442a0deddc7ea53f3e29/" rel="bookmark">
			python 映射表_python映射列表实例分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文实例讲述了python映射列表。分享给大家供大家参考。具体分析如下：
列表映射是个非常有用的方法，通过对列表的每个元素应用一个函数来转换数据，可以使用一种策略或者方法来遍历计算每个元素。
例如：
复制代码 代码如下:
params = {"server":"mpilgrim", \
"database":"master", \
"uid":"sa", \
"pwd":"secret" \
}
print ["%s=%s" % (k, params[k]) for k in params.keys()]
print ';'.join(["%s=%s" % (k, params[k]) for k in params.keys()])
返回结果为：
复制代码 代码如下:
['uid=sa', 'pwd=secret', 'database=master', 'server=mpilgrim']
还可以改进下，把元组转化成字符串，使用join函数方法。
复制代码 代码如下:
'uid=sa;pwd=secret;database=master;server=mpilgrim'
(join函数不仅使用于元组还使用于列表，功能是字符串化)
split跟join相反，把字符串转换成元组
看如下应用
复制代码 代码如下:
str = 'server=mpilgrim;uid=sa;database=master;pwd=secret'&gt;&gt;&gt; str.split(';')
['server=mpilgrim', 'uid=sa', 'database=master', 'pwd=secret']
&gt;&gt;&gt; str.split(';', 1)
['server=mpilgrim', 'uid=sa;database=master;pwd=secret']
&gt;&gt;&gt; str.split(';', 2)
['server=mpilgrim', 'uid=sa', 'database=master;pwd=secret']
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dff6e492b459442a0deddc7ea53f3e29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f7d2c75e095a5b2c02f1288ec1a73db/" rel="bookmark">
			Openssl中chacha20-poly1305的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理简述 chacha20-poly1305 是带有关联数据的认证加密（AEAD）AEAD是一种能够同时保证数据的保密性、 完整性和真实性的一种加密模式。
通常使用除了明文以外，会把包头的地址和端口等信息放进去一起做完整性校验。
chacha20 是流加密算法。
poly1305 是完整性校验是算法，即根据输入（加密数据和关联数据）输出16字节的认证标签。
使用方法 加密 输入项：
输入项长度(Bytes)说明key32共享秘钥iv12干扰项，每次不同AADN关联数据plaintextN待加密数据明文 输出项：
输出项长度(Bytes)说明ciphertextN加密后的密文，长度与原始明文一致TAG16认证标签 通常将TAG接在ciphertext密文之后。
解密 输入项：
输入项长度(Bytes)说明key32共享秘钥iv12干扰项，每次不同AADN关联数据ciphertextN待加密数据明文TAG16认证标签 输出项：
输出项长度(Bytes)说明plaintextN原始明文result1完整性检查结果（1成功，0失败） 参数关联 key + iv + plaintext ===&gt; ciphertext
ciphertext + AAD ===&gt; TAG
AAD只参与完整性验证，不参与加密。
代码实例 代码刚验证完，没整理，凑合看，嘻嘻。
int chachapoly_test(void) { /* Key 共享秘钥 */ unsigned char skey2[32] = { 0x2e,0xff,0xe4,0x85,0x1e,0x23,0x72,0xef, 0x5c,0x44,0x14,0x75,0x61,0xd8,0xf0,0xa3, 0xde,0x91,0x09,0x00,0x24,0x03,0x51,0x3c, 0xf2,0xf6,0x6d,0x16,0xbd,0x78,0xd2,0x63}; int ret = 0; EVP_CIPHER_CTX* ctx = NULL; EVP_CIPHER_CTX* dctx = NULL; /* 干扰项 iv */ unsigned char iv[12] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b }; /* 外部关联数据 AAD */ unsigned char aad[128] = {0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15, 0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1f,0x20,0x21,0x22,0x23,0x24,0x25,0x26, 0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15, 0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1f,0x20,0x21,0x22,0x23,0x24,0x25,0x26, 0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15, 0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1f,0x20,0x21,0x22,0x23,0x24,0x25,0x26, 0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15, 0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1f,0x20,0x21,0x22,0x23,0x24,0x25,0x26}; unsigned char ciphertext[1024] = {0}; unsigned char res[1024] = {0}; /* 原始明文 plaintext */ unsigned char msg[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f7d2c75e095a5b2c02f1288ec1a73db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd3b1681d66a6cfaf6055929e8a9ea6f/" rel="bookmark">
			IntelliJ IDEA 20周岁啦，为期2天的周年庆活动对开发者免费开放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 你好，我是方同学(YourBatman)
A哥 -&gt; 方同学。是的，中文昵称改了。自知道行不深无以用“哥”字称呼，虽已毕业多年，同学二字寄寓心态一直积极、热情、年轻
题记：笔者2015年入行，2017年9月首次使用IntelliJ IDEA，从最初的排斥抵触，到现在爱不释手。一晃IntelliJ IDEA 20岁了，祝福它越来越好。近一年我分享了好几篇关于IDEA的深度剖析文章，在文首就提前分享给你：
IntelliJ IDEA 2020.3正式发布，年度最后一个版本很讲武德IntelliJ IDEA 2020.2正式发布，诸多亮点总有几款能助你提效IntelliJ IDEA 2020.1正式发布，你要的Almost都在这！IntelliJ IDEA 2019.3正式发布，给我们带来哪些新特性？IDEA命令行缩短器助你解决此问题：Command line is too long. Shorten command line 2001年，IntelliJ IDEA诞生，使得开发更富有成效和愉快的体验；2021年，IntelliJ IDEA已受到全球400多万开发者的喜爱和使用！
IntelliJ IDEA是JetBrains公司最为重要的产品，没有之一。回顾20周年，在其创立之初，JetBrains只是布拉格（捷克的首都）一家普通得不能再普通的小公司。起初只有3名员工，做着一款产品为800个客户提供服务。经过20年的持续发展，该公司已然成为一个跨国公司，办事处遍布全球9个国家之多，员工人数也超过1200名，开发者工具达到25款之多，用户规模更是突破800万。
说明：JetBrains产品面向的是开发者/程序员，并非普通C端用户，因此这个数字是非常惊人的
今年(2021年)是IntelliJ IDEA的20周年，为此JetBrains公司计划搞一个盛大的周年庆活动，管它叫IntelliJ IDEA Conf，所有开发者均可免费报名参与，公司创始人Maxim Shafirov会“亲临现场”哦。会议时间、具体日程下待会再做成列。
本文提纲 版本约定 IntelliJ IDEA：2020.3.1 正文 IntelliJ IDEA风风雨雨走过20年，取得了众多骄人成绩。站在这个时间节点上，我们先一同来领略下其风采。透过冰冷的数字，我们能体会到IntelliJ IDEA工程师们的骄傲和自豪。
IntelliJ IDEA成绩单 在刚刚过去的2020年整年，全球共400万+开发者在使用IntelliJ IDEA，共被下载了超过1千200万次。
IntelliJ IDEA是全球性的国际化的，它的使用者坐落在世界的各个角落。从官方统计出的这张图能看到各州分部：
从地图上也能看到，亚洲使用IntelliJ IDEA的人是最多的。毕竟，你懂的中国在亚洲嘛（还有印度），人数总量这一块从来都是拿捏得死死的。
截止2021年1月，亚洲总人口45亿，全球77亿，占比60%左右
使用人数国家Top 5 第一有悬念吗？答，没有。毕竟对人数这块中国还没怕过谁~
第一名：中国
第二名：美国
第三名：印度
第四名：德国
第五名：俄罗斯
说明：统计数据来自2020整年
特性使用次数Top 5 在过去20年里，IntelliJ IDEA共发布了40+个主要版本，效率惊人。发布N多特性，其中最被开发者常用的五大特性为：
第一名：代码补全第二名：显示意图操作第三名：运行第四名：跳转到声明地方第五名：切换行断点 说明：统计数据来自2020整年
IntelliJ平台产品汇总 IntelliJ是个平台，而IntelliJ IDEA是其基础。还有很多的商业/非商业产品，众多成熟的IDE和插件，放一张让人骄傲的产品图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd3b1681d66a6cfaf6055929e8a9ea6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2555b391b2c87fe104ffc93335375171/" rel="bookmark">
			51单片机的复位引脚_51单片机复位电路工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		51单片机要复位只需要在第9引脚接个高电平持续2us就可以实现，那这个过程是如何实现的呢?在单片机系统中，系统上电启动的时候复位一次，当按键按下的时候系统再次复位，如果释放后再按下，系统还会复位。所以可以通过按键的断开和闭合在运行的系统中控制其复位。
开机的时候为什么为复位在电路图中，电容的的大小是10uf，电阻的大小是10k。所以根据公式，可以算出电容充电到电源电压的0.7倍(单片机的电源是5V，所以充电到0.7倍即为3.5V)，需要的时间是10K*10UF=0.1S。也就是说在电脑启动的0.1S内，电容两端的电压时在0~3.5V增加。这个时候10K电阻两端的电压为从5~1.5V减少(串联电路各处电压之和为总电压)。所以在0.1S内，RST引脚所接收到的电压是5V~1.5V。在5V正常工作的51单片机中小于1.5V的电压信号为低电平信号，而大于1.5V的电压信号为高电平信号。所以在开机0.1S内，单片机系统自动复位(RST引脚接收到的高电平信号时间为0.1S左右)。
按键按下的时候为什么会复位在单片机启动0.1S后，电容C两端的电压持续充电为5V，这是时候10K电阻两端的电压接近于0V，RST处于低电平所以系统正常工作。当按键按下的时候，开关导通，这个时候电容两端形成了一个回路，电容被短路，所以在按键按下的这个过程中，电容开始释放之前充的电量。随着时间的推移，电容的电压在0.1S内，从5V释放到变为了1.5V，甚至更小。根据串联电路电压为各处之和，这个时候10K电阻两端的电压为3.5V，甚至更大，所以RST引脚又接收到高电平。单片机系统自动复位。.
总结：1、复位电路的原理是单片机RST引脚接收到2US以上的电平信号，只要保证电容的充放电时间大于2US，即可实现复位，所以电路中的电容值是可以改变的。2、按键按下系统复位，是电容处于一个短路电路中，释放了所有的电能，电阻两端的电压增加引起的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2a1b952bddf90f3709fe1a4c0a79c48/" rel="bookmark">
			pta编程题python答案提交显示非零返回_Python在Oj上提交程序的一些套路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. FAQ
0.1 提交后提示“答案错误”或者“格式错误”
PTA检查答案正确与否是通过字符串匹配实现的。所以可能有以下几种原因：
格式错误:程序的输出要与题目中的样例输出格式一样(输出内容根据运行结果不同而变化)，程序输出的结果多一个空格、少一个空格，都不行。
比如输出样例为1 + 2 = 3，你的输出却是1+2=3，错误原因分析：在+与=两边少了相应的空格，在3后面却多了空格。
在input()中填写了提示信息
不要在input中填写提示信息！需要获取输入的地方只要input()就可以了。以下代码是错误的,x = input("请输入")，请改为'x = input()'
你的答案真的错了(请仔细对比，包括大小写、空格等)或者题目错了(小概率)。
0.2 提交后提示"非零返回"
代码有语法错误
针对这种问题，请先在IDLE中把程序调试好以后再提交。
代码中多出不必要的input()
多写了input()，但却没有相应的输入，就会产生错误。比如样例输入只要求输入1行，但代码中却有2个input()。
0.3 其他要注意的
PTA中的Python3无法正确处理中文字符，所以任何时候，提交的代码中都不要出现中文。
新建题时不要在输入、输出文件包含中文。
1.处理输出
1.1 直接使用print函数
print('你要输出的内容')
1.2 使用Python中字符串的format函数，比如：
a = 1.111
b = 2.222
print('{} + {} = {:.2f}'.format(a,b,a+b))
输出:1.111 + 2.222 = 3.33
注1：这里的{:.2f}为保留两位小数。
注2：这里面的输出+与=两旁均有空格。
1.3 换行或者不换行
print函数直接换行，如果想不换行要加上end=""
print("1", end="")
print("2", end="")
print("3")
print("4")
输出:
123
4
另一种处理方式：
line = "a"
line = line + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2a1b952bddf90f3709fe1a4c0a79c48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d8b43fd78f213604f9305fa452b639b/" rel="bookmark">
			IDL编程：利用shp文件批量裁剪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDL编程：利用shp文件批量裁剪 源码简介：源码下载源码参考文献链接及运行效果展示 源码简介： 主要是在“https://www.cnblogs.com/gisoracle/p/3663707.html”源码的基础上增加了“ ENVI_FILE_MNG, id =fid,/remove” 释放内存的部分。
源码下载 源码下载: CSDN下载搜：bach_subset_viashp.pro.
源码 ;;;;image_dir为影像路径 ;;;;vector_dir矢量路径 ;;;;outfile_dir裁剪后结果路径 pro Bach_subset_viashp,Image_dir,vector_dir,outfile_dir COMPILE_OPT IDL2 ;compole_opt是对idl编译规则的修改，关键字有defint32,strictarr, ;idl2等 ;defint32把默认的ＩＤＬ整型数据１６位改为３２位 ;strictarr强迫数组元素用中括号，不用小括号 ;idl2则为上述二者的并。 e=ENVI(/Headless) ;启动ENVI image_dir='F:\E\data\grass_yield\2000_2018GOSIF\8day' ;根据文件存放的目录进行相应修改 image_files=file_search(image_dir,'*.tif',count=numfiles) ;根据相应的文件格式修改过滤条件 for i=0,numfiles-1 do begin image_file=image_files[i] print,image_file if strlen(image_file) eq 0 then return ENVI_OPEN_FILE, image_file, r_fid=fid, $ /no_interactive_query, /no_realize ENVI_FILE_QUERY, fid, file_type=file_type, BNAMES=BNAMES,nl=nl, ns=ns,dims=dims,nb=nb ;打开shape文件 vector_dir='F:\E\data\grass_yield\shp\WGS84\minqin' ;根据文件存放的目录进行相应修改 shapefile=file_search(vector_dir,'*.shp',count=numshps) if strlen(shapefile) eq 0 then return oshp = OBJ_NEW('IDLffshape',shapefile) oshp-&gt;Getproperty,n_entities=n_ent,Attribute_info=attr_info,$ n_attributes=n_attr,Entity_type=ent_type roi_shp = LONARR(n_ent) FOR ishp = 0,n_ent-1 DO BEGIN entitie = oshp-&gt;Getentity(ishp) IF entitie.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d8b43fd78f213604f9305fa452b639b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2257f94d6193fd4303d7ed419f51f479/" rel="bookmark">
			shmget函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shmget int shmget(key_t key, size_t size, int flag);
key: 标识符的规则
size:共享存储段的字节数
flag:读写的权限
返回值：成功返回共享存储的id，失败返回-1
key_t key
-----------------------------------------------
key标识共享内存的键值: 0/IPC_PRIVATE。 当key的取值为IPC_PRIVATE，则函数shmget()将创建一块新的共享内存；如果key的取值为0，而参数shmflg中设置了IPC_PRIVATE这个标志，则同样将创建一块新的共享内存。
在IPC的通信模式下，不管是使用消息队列还是共享内存，甚至是信号量，每个IPC的对象(object)都有唯一的名字，称为“键”(key)。通过“键”，进程能够识别所用的对象。“键”与IPC对象的关系就如同文件名称之于文件，通过文件名，进程能够读写文件内的数据，甚至多个进程能够共用一个文件。而在IPC的通讯模式下，通过“键”的使用也使得一个IPC对象能为多个进程所共用。
Linux系统中的所有表示System V中IPC对象的数据结构都包括一个ipc_perm结构，其中包含有IPC对象的键值，该键用于查找System V中IPC对象的引用标识符。如果不使用“键”，进程将无法存取IPC对象，因为IPC对象并不存在于进程本身使用的内存中。
通常，都希望自己的程序能和其他的程序预先约定一个唯一的键值，但实际上并不是总可能的成行的，因为自己的程序无法为一块共享内存选择一个键值。因此，在此把key设为IPC_PRIVATE，这样，操作系统将忽略键，建立一个新的共享内存，指定一个键值，然后返回这块共享内存IPC标识符ID。而将这个新的共享内存的标识符ID告诉其他进程可以在建立共享内存后通过派生子进程，或写入文件或管道来实现。
int size(单位字节Byte)
-----------------------------------------------
size是要建立共享内存的长度。所有的内存分配操作都是以页为单位的。所以如果一段进程只申请一块只有一个字节的内存，内存也会分配整整一页(在i386机器中一页的缺省大小PACE_SIZE=4096字节)这样，新创建的共享内存的大小实际上是从size这个参数调整而来的页面大小。即如果size为1至4096，则实际申请到的共享内存大小为4K(一页)；4097到8192，则实际申请到的共享内存大小为8K(两页)，依此类推。
int shmflg
-----------------------------------------------
shmflg主要和一些标志有关。其中有效的包括IPC_CREAT和IPC_EXCL，它们的功能与open()的O_CREAT和O_EXCL相当。
IPC_CREAT 如果共享内存不存在，则创建一个共享内存，否则打开操作。
IPC_EXCL 只有在共享内存不存在的时候，新的共享内存才建立，否则就产生错误。
如果单独使用IPC_CREAT，shmget()函数要么返回一个已经存在的共享内存的操作符，要么返回一个新建的共享内存的标识符。如果将IPC_CREAT和IPC_EXCL标志一起使用，shmget()将返回一个新建的共享内存的标识符；如果该共享内存已存在，或者返回-1。IPC_EXEL标志本身并没有太大的意义，但是和IPC_CREAT标志一起使用可以用来保证所得的对象是新建的，而不是打开已有的对象。对于用户的读取和写入许可指定SHM_R和SHM_W,(SHM_R&gt;3)和(SHM_W&gt;3)是一组读取和写入许可，而(SHM_R&gt;6)和(SHM_W&gt;6)是全局读取和写入许可。
返回值
-----------------------------------------------
成功返回共享内存的标识符；不成功返回-1，errno储存错误原因。
EINVAL 参数size小于SHMMIN或大于SHMMAX。
EEXIST 预建立key所致的共享内存，但已经存在。
EIDRM 参数key所致的共享内存已经删除。
ENOSPC 超过了系统允许建立的共享内存的最大值(SHMALL )。
ENOENT 参数key所指的共享内存不存在，参数shmflg也未设IPC_CREAT位。
EACCES 没有权限。
ENOMEM 核心内存不足。
struct shmid_ds
-----------------------------------------------
shmid_ds数据结构表示每个新建的共享内存。当shmget()创建了一块新的共享内存后，返回一个可以用于引用该共享内存的shmid_ds数据结构的标识符。
include/linux/shm.h
struct shmid_ds { struct ipc_perm shm_perm; /* operation perms */ int shm_segsz; /* size of segment (bytes) */ __kernel_time_t shm_atime; /* last attach time */ __kernel_time_t shm_dtime; /* last detach time */ __kernel_time_t shm_ctime; /* last change time */ __kernel_ipc_pid_t shm_cpid; /* pid of creator */ __kernel_ipc_pid_t shm_lpid; /* pid of last operator */ unsigned short shm_nattch; /* no.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2257f94d6193fd4303d7ed419f51f479/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0827a954a771b97ba8caa5e1ee3d61be/" rel="bookmark">
			登陆服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 登录服务器 ssh 命令行法
如果你的端口是默认的22 端口：ssh 用户名 IP 地址
如果你的端口是特殊端口 以 2333 为例
MacOS ssh 用户名 IP 地址 -p2333
Windows ssh用户名 IP 地址 2333 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce0f3d101d4f1064a4e6c933c09bbe1f/" rel="bookmark">
			mysql的isnull函数_MySQL isnull()函数基本指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本教程将向您介绍MySQL ISNULL函数以及如何使用它来处理NULL值。
MySQL ISNULL函数简介
ISNULL函数接受一个参数，并测试该参数是否为。如果参数为NULL，则ISNULL函数返回1，否则返回0。
下面说明了ISNULL函数的语法：
ISNULL(expr)
请考虑以下示例：
SELECT ISNULL(NULL); -- 1 SELECT ISNULL(1); -- 0 SELECT ISNULL(1 + NULL); -- 1; SELECT ISNULL(1 / 0 ); -- 1;
请注意，如果您尝试找到Microsoft SQL Server的ISNULL函数的MySQL替代方法，则应该使用MySQL的函数。 因为ISNULL函数在MySQL中与Microsoft SQL Server的ISNULL函数是不同的。
MySQL ISNULL函数和IS NULL运算符
ISNULL函数与IS NULL运算符共享一些行为。 例如，如果您将DATE类型的列声明为，则可以使用以下语句查找特殊日期“0000-00-00”：
SELECT * FROM table_name WHERE ISNULL(date);
请注意，MySQL故意实现此函数来支持ODBC应用程序，因为ODBC不支持特殊日期值'0000-00-00'。或者修改以下值为： sql_mode=NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION，官方手册参考：
我们来看下面的一个例子。
首先，创建一个名为special_isnull的新表，如下所示：
USE testdb; drop table if exists special_isnull; CREATE TABLE special_isnull ( start_date DATE default NULL );
其次，将一些数据插入到special_isnull表中：
INSERT INTO special_isnull(start_date) VALUES('2000-01-01'),('0000-00-00'),(NULL);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce0f3d101d4f1064a4e6c933c09bbe1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f030df4128978e44712b8dae0f82ad6e/" rel="bookmark">
			mysql数据库统计人数_统计人数 数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		{"moduleinfo":{"card_count":[{"count_phone":1,"count":1}],"search_count":[{"count_phone":4,"count":4}]},"card":[{"des":"阿里云数据库专家保驾护航，为用户的数据库应用系统进行性能和风险评估，参与配合进行数据压测演练，提供数据库优化方面专业建议，在业务高峰期与用户共同保障数据库系统平稳运行。","link1":"https://www.aliyun.com/service/optimization/database","link":"https://www.aliyun.com/service/chiefexpert/database","icon":"https://img.alicdn.com/tfs/TB1a5ZfonnI8KJjy0FfXXcdoVXa-100-100.png","btn2":"数据库紧急救援服务","tip":"还有更多专家帮助您解决云上业务问题：立即查看","btn1":"云上数据库优化服务","link2":"https://www.aliyun.com/service/databaserescue","title":"数据库专家服务"}],"search":[{"txt":"安全首席专家","link":"https://www.aliyun.com/service/chiefexpert/security"},{"txt":"中间件首席专家","link":"https://www.aliyun.com/service/chiefexpert/middleware"},{"txt":"系统与平台首席专家","link":"https://www.aliyun.com/service/chiefexpert/platform"},{"txt":"存储首席专家","link":"https://www.aliyun.com/service/chiefexpert/storage"}],"countinfo":{"search":{"length_pc":0,"length":0},"card":{"length_pc":0,"length":0}},"simplifiedDisplay":"newEdition","newCard":[{"link":"https://www.aliyun.com/product/rds/mysql","icon":"rds_mysql1","contentLink":"https://www.aliyun.com/product/rds/mysql","title":"云数据库RDS MySQL版","des":"云数据库RDS MySQL版 MySQL 是全球最受欢迎的开源数据库，阿里云MySQL版 通过深度的内核优化和独享实例提供稳定极致的数据库性能，同时灵活的部署架构及产品形态，可满足不同场景下的数据库需求。","btn1":"了解详情","link1":"https://www.aliyun.com/product/rds/mysql","btn2":"管理控制台","link2":"https://rdsnext.console.aliyun.com/#/rdsList/cn-hangzhou/basic/","btn3":"在线咨询","link3":"https://www.aliyun.com/core/online-consult?spm=5176.8789780.7y9jhqsfz.115.47ea55caeL2Mfu&amp;from=OVtXEBmlH8","infoGroup":[{"infoName":"最新活动","infoContent":{"firstContentName":"MySQL 1年仅19.9元","firstContentLink":"https://www.aliyun.com/database/dbfirstbuy#J_9036464270","lastContentName":"ECS+MySQL 0.7元/日","lastContentLink":"https://www.aliyun.com/1111/enterprise"}},{"infoName":"快速入门","infoContent":{"firstContentName":"选型指南","firstContentLink":"https://help.aliyun.com/document_detail/164594.html?spm=a2c4g.11186623.6.551.56b67384ispvvk","lastContentName":"上手指南","lastContentLink":"https://help.aliyun.com/document_detail/26124.html?spm=a2c4g.11174283.2.16.51795b83pbkzav"}},{"infoName":"最佳实践","infoContent":{"firstContentName":"X-Engine的应用场景","firstContentLink":"https://help.aliyun.com/document_detail/148402.html?spm=a2c4g.11186623.2.14.3f592685zjuUxu#concept-2364901","lastContentName":"读写分离功能","lastContentLink":"https://help.aliyun.com/document_detail/96073.html?spm=a2c4g.11174283.2.53.42db5b83VvZvMJ"}},{"infoName":"产品推荐","infoContent":{"firstContentName":"云数据库PolarDB","lastContentName":"云原生数据仓库MySQL","firstContentLink":"https://www.aliyun.com/product/polardb","lastContentLink":"https://www.aliyun.com/product/ads"}}]}],"visual":{"textColor":"dark","topbg":""}}
{"$env":{"JSON":{}},"$page":{"env":"production"},"$context":{"moduleinfo":{"card_count":[{"count_phone":1,"count":1}],"search_count":[{"count_phone":4,"count":4}]},"card":[{"des":"阿里云数据库专家保驾护航，为用户的数据库应用系统进行性能和风险评估，参与配合进行数据压测演练，提供数据库优化方面专业建议，在业务高峰期与用户共同保障数据库系统平稳运行。","link1":"https://www.aliyun.com/service/optimization/database","link":"https://www.aliyun.com/service/chiefexpert/database","icon":"https://img.alicdn.com/tfs/TB1a5ZfonnI8KJjy0FfXXcdoVXa-100-100.png","btn2":"数据库紧急救援服务","tip":"还有更多专家帮助您解决云上业务问题：立即查看","btn1":"云上数据库优化服务","link2":"https://www.aliyun.com/service/databaserescue","title":"数据库专家服务"}],"search":[{"txt":"安全首席专家","link":"https://www.aliyun.com/service/chiefexpert/security"},{"txt":"中间件首席专家","link":"https://www.aliyun.com/service/chiefexpert/middleware"},{"txt":"系统与平台首席专家","link":"https://www.aliyun.com/service/chiefexpert/platform"},{"txt":"存储首席专家","link":"https://www.aliyun.com/service/chiefexpert/storage"}],"countinfo":{"search":{"length_pc":0,"length":0},"card":{"length_pc":0,"length":0}},"simplifiedDisplay":"newEdition","newCard":[{"link":"https://www.aliyun.com/product/rds/mysql","icon":"rds_mysql1","contentLink":"https://www.aliyun.com/product/rds/mysql","title":"云数据库RDS MySQL版","des":"云数据库RDS MySQL版 MySQL 是全球最受欢迎的开源数据库，阿里云MySQL版 通过深度的内核优化和独享实例提供稳定极致的数据库性能，同时灵活的部署架构及产品形态，可满足不同场景下的数据库需求。","btn1":"了解详情","link1":"https://www.aliyun.com/product/rds/mysql","btn2":"管理控制台","link2":"https://rdsnext.console.aliyun.com/#/rdsList/cn-hangzhou/basic/","btn3":"在线咨询","link3":"https://www.aliyun.com/core/online-consult?spm=5176.8789780.7y9jhqsfz.115.47ea55caeL2Mfu&amp;from=OVtXEBmlH8","infoGroup":[{"infoName":"最新活动","infoContent":{"firstContentName":"MySQL 1年仅19.9元","firstContentLink":"https://www.aliyun.com/database/dbfirstbuy#J_9036464270","lastContentName":"ECS+MySQL 0.7元/日","lastContentLink":"https://www.aliyun.com/1111/enterprise"}},{"infoName":"快速入门","infoContent":{"firstContentName":"选型指南","firstContentLink":"https://help.aliyun.com/document_detail/164594.html?spm=a2c4g.11186623.6.551.56b67384ispvvk","lastContentName":"上手指南","lastContentLink":"https://help.aliyun.com/document_detail/26124.html?spm=a2c4g.11174283.2.16.51795b83pbkzav"}},{"infoName":"最佳实践","infoContent":{"firstContentName":"X-Engine的应用场景","firstContentLink":"https://help.aliyun.com/document_detail/148402.html?spm=a2c4g.11186623.2.14.3f592685zjuUxu#concept-2364901","lastContentName":"读写分离功能","lastContentLink":"https://help.aliyun.com/document_detail/96073.html?spm=a2c4g.11174283.2.53.42db5b83VvZvMJ"}},{"infoName":"产品推荐","infoContent":{"firstContentName":"云数据库PolarDB","lastContentName":"云原生数据仓库MySQL","firstContentLink":"https://www.aliyun.com/product/polardb","lastContentLink":"https://www.aliyun.com/product/ads"}}]}],"visual":{"textColor":"dark","topbg":""}}}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46a9335c6a35cd8b55791118299494b0/" rel="bookmark">
			老码农公开！我是这样不花钱开CSDN会员的......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		‍
‍HAPPY“牛”YEAR~
牛年到，好运来~
不论你今年新年回不回家
CSDN 福利你都可以领到！
助你牛气冲天，“码”力十足
上周的活动已经有不少同学参与周五福利日活动
都领到了CSDN会员！
这周活动继续！加码万份好礼！！！
只要体验CSDN插件就有机会领
CSDN会员和瓜分5W现金！
别怪CSDN没提醒你，
1月29日11点，#嗨翻星期五#限时登场，
奖品数量有限，先到先得！
↓复制到电脑端，参与活动↓
https://t.csdnimg.cn/NSnM
教你如何免费获得CSDN会员
免费获得CSDN会员只需要两个简单的步骤
步骤一：电脑登录插件官网（https://t.csdnimg.cn/NSnM）下载最新版本插件（下载步骤在官网有噢）
（下载后的浏览器就变成这个样子啦，是不是很好看~）
步骤二：打开新标签页，点击活动图标，进入活动，新用户可免费得一次领取机会，完成任务可获得更多奖池领取机会！
免费送会员图标在这里！点开就是活动界面啦！
点击一键邀请，新用户可免费得一次领取机会，完成分享任务即可解锁其他奖池瓜分机会！听说邀请的人越多，抽中的概率就越大哦！快把邀请链接发给小伙伴参与进来吧！~
愣着干嘛！还不快去先把插件下载了，
定好闹钟准备周五抢会员呀！
下载链接都给大家准备好了！
↓复制到电脑端，参与活动↓
https://t.csdnimg.cn/NSnM
CSDN插件是什么？
程序员都在用的浏览器插件！你不会还不知道吧！
随便在【知乎】【CSDN】站内搜一下，太多人夸这款插件了！
程序员都在用的浏览器插件--CSDN chrome浏览器插件！让小编再详细给大家介绍一下这款插件的具体用途！
1、 『万能工具』 ： 任意页面一键呼出实用工具
支持json格式化、单词查询等近10种常用工具，随时随地一键调用，不必再为一个需求浪费时间来回切换，真的超级节省时间，大大提高程序猿效率的神器
2、『一键搜索』：快速搜索历史记录、书签和网页内容
任意网页点按C，即可一键调用搜索框（全网+本地），查找资料再也不必打开一堆网页，自从有了这个插件，麻麻再也不怕我找不到网页了！
3、『新标签页美化』：让浏览器赏心悦目
标签页每天更新全网最新的个性化壁纸，支持DIY，打造专属极客的浏览器！我的浏览器也太好看了吧！
4、官方永久免费『去广告』
从底层永久去站内广告，加载速度更快，体验更爽，没有广告看起来就是爽！
5、 『扩展功能』：随时体验有趣好玩的新功能，免费体验
通过搜索框进入后台功能商店，可免费添加或开发个性化功能，比如网页极简模式、黑暗模式、表达式测试、自定义天气插件、抢票等若干资源，自由定制，跟CSDN一起打造更好玩的浏览器工具！你心动了没！
！羊毛预警！
谁还没下CSDN插件！请立即上车
↓把链接复制到电脑端↓
https://t.csdnimg.cn/NSnM
现在加入CSDN插件互助群还有好礼相送！
一起和小伙伴们玩起来吧~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2af3e1e535397528874cacb19632aab7/" rel="bookmark">
			正则匹配中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如何使用正则匹配中文字符，w匹配的仅仅是中文，数字，字母，对于国人来讲，仅匹配中文时 匹配中文字符的正则表达式： [u4e00-u9fa5] 2、需要匹配双字节字符，中文也是双字节的字符
匹配双字节字符(包括汉字在内)：[^x00-xff] 3、可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） 更多常用正则表达式匹配规则：
英文字母:[a-zA-Z] 数字:[0-9] 4、匹配中文，英文字母和数字及_:
^[u4e00-u9fa5_a-zA-Z0-9]+$ 5、同时判断输入长度：
[u4e00-u9fa5_a-zA-Z0-9_]{4,10} ^[wu4E00-u9FA5uF900-uFA2D]*$ 6、一个正则表达式，只含有汉字、数字、字母、下划线不能以下划线开头和结尾：
^(?!_)(?!.*?_$)[a-zA-Z0-9_u4e00-u9fa5]+$ 7、 ^ 与字符串开始的地方匹配
(?!_)　不能以_开头 (?!.*?_$)　不能以_结尾 [a-zA-Z0-9_u4e00-u9fa5]+　至少一个汉字、数字、字母、下划线 8、$　与字符串结束的地方匹配
放在程序里前面加@，否则需要\进行转义 @"^(?!_)(?!.*?_$)[a-zA-Z0-9_u4e00-u9fa5]+$" （或者：@"^(?!_)w*(?&lt;!_)$" 或者 @" ^[u4E00-u9FA50-9a-zA-Z_]+$ " ) 9、只含有汉字、数字、字母、下划线，下划线位置不限：
^[a-zA-Z0-9_u4e00-u9fa5]+$ 9、由数字、26个英文字母或者下划线组成的字符串
^w+$ 10、2~4个汉字
@"^[u4E00-u9FA5]{2,4}$"; 11、
^[w-]+(.[w-]+)*@[w-]+(.[w-]+)+$ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4adabca2ad42ea249e535ad4fcde8fa/" rel="bookmark">
			使用python时，ModuleNotFoundError: No module named ‘win32api‘处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一（亲测有效） 直接 pip install pywin32 就行了
方法二 转载自https://blog.csdn.net/qq_41676500/article/details/89282872 1、环境：win10+python3.7
2、 处理方法
安装pywin32库，先打开命令行cmd，输入 pip install pypiwin32 进行自动安装。
安装完毕后重新运行代码不再出现No module named 'win32api’问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e00bd648758182965202bf5e63f8d40/" rel="bookmark">
			pytest失败重跑插件: pytest-rerunfailures使用与坑（全网独家精华）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在编写接口case的时候，我们常遇到一个这样的问题：
测试环境不稳定偶发接口超时（和服务无关，纯粹是环境问题），然后执行接口case也因此偶发失败。比如同一个接口case跑五次，其中有两次失败，另外三次都是成功的，这种偶发性的环境问题就需要我们手动重跑（还不一定能够通过）。有没有一个比较好的机制，保证case能够尽最大努力通过测试呢？
这里我们介绍pytest的一个失败重跑插件：pytest-rerunfailures
介绍 pytest-rerunfailures是一个通过重跑机制来消除不稳定失败的pytest插件。
项目地址：https://github.com/pytest-dev/pytest-rerunfailures
安装 安装&amp;运行要求：
Python 3.6~3.9, or PyPy3pytest 5.0+ 安装插件
sudo pip(pip3) install pytest-rerunfailures 使用pytest-rerunfailures 使用方式有两种：
命令行参数装饰器方式 命令行参数模式 示例case：test_demo.py
#!/usr/bin/env python3 #!coding:utf-8 import pytest import random def test_simple_assume(): #每次case运行的值为1或者2，具有随机性 r = random.randint(1,2) assert r == 1 如果我们直接运行pytest test_demo.py，那么每次运行的结果会具有一定随机性（可能成功也可能失败）
如果使用pytest-rerunfailures指定执行多次，只要执行次数足够多，那么遇到结果成功的机会就会更多。
例子1
指定失败重跑最大次数为10：pytest --reruns 10
如下图，我们看到一共跑了两次，第一次结果失败，所以重跑了第二次，最终结果用R标注。（如果跑一次就成功，结果应该是'.')
例子2
指定失败重跑最大次数为10，重跑间隔为1秒：pytest --reruns 10 --reruns-delay 1
如下图，一共重跑了两次，重跑两次的执行时间为2.1秒，上图中一次只需要0.07秒，这里多出的两秒就是因为--reruns-delay指定的重跑间隔为1秒。
例子3：通过表达式指定失败重跑
test_demo.py解释：
test_assert_error随机抛出AssertionError
test_value_error随机抛出ValueError
#!/usr/bin/env python3 #!coding:utf-8 import pytest import random def test_assert_error(): r = random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e00bd648758182965202bf5e63f8d40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4bdf67aeeedfa7ee7c297930b8460f6/" rel="bookmark">
			相机标定（1）——四个坐标系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 二维图像能提供丰富的环境信息或空间信息，这些信息涵盖（1）图像上每一点的亮度与物体某个表面点的反射光的强度的关系（2）图像点在图像平面上的位置与 a . a. a.相机与空间物体的相对方位的关系； b . b. b.相机的内部结构关系1。利用这些信息，可实现诸如测距，测量，识别，地图构建，定位，相机运动和姿态估计等方面的工作。
为了描述相机的几何成像关系，需要进行数学建模，这些几何模型参数就是相机参数，包括内参和外参，而求解参数的过程就称为相机标定。本文所介绍的相机模型是计算机视觉中广泛使用的针孔模型（The basic pinhole model）。这种模型在数学上是三维空间到二维平面（image plane or focal plane）的中心投影，由一个 3 × 4 3\times4 3×4投影矩阵 P = K [ R ∣ t ] P=K[R|t] P=K[R∣t]2来描述， K K K为相机内参（internal camera parameters）， [ R ∣ t ] [R|t] [R∣t]为外参（external parameters）。
我们通过描述四个坐标系的相互转换关系，可以拆分和剖析投影矩阵 P P P。
四个坐标系 下图表示四个坐标系的相互关系3。
图像像素坐标系：表示三维空间物体在图像平面上的投影，像素是离散化的，其坐标原点在CCD图像平面的左上角， u u u轴平行于CCD平面水平向右， v v v轴垂直于 u u u轴向下，坐标使用 ( u , v ) (u,v) (u,v)来表示。图像宽度 W W W，高度 H H H图像物理坐标系：坐标原点在CCD图像平面的中心， x , y x,y x,y轴分别平行于图像像素坐标系的 ( u , v ) (u,v) (u,v)轴，坐标用 ( x , y ) (x,y) (x,y)表示。相机坐标系：以相机的光心为坐标系原点， X c , Y c X_c,Y_c Xc​,Yc​轴平行于图像坐标系的 x , y x,y x,y轴，相机的光轴为 Z c Z_c Zc​轴，坐标系满足右手法则。相机的光心可理解为相机透镜的几何中心，如下图所示3。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4bdf67aeeedfa7ee7c297930b8460f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25c0a650e9d521e131b8b2022d966e5f/" rel="bookmark">
			vue 阴影_从 mCast 聊聊声明式 UI（Vue.js 与 SwiftUI）和原型构建效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文发表于 rebornix.com 作为玩票性质的 Vue.js 用户和 iOS/macOS 开发，这个标题对于我来说，写起来本来是没有多少底气的。不过半年前我花了点业余时间和朋友写了个 macOS 的播客客户端 ‎mCast ，获得了一些第一手的感悟，故此写篇文章聊聊我的想法。
先说结论，声明式 UI 及配套的现代工具链（Hot Reload，Live Editing）能够大幅提高原型构建的效率，而且对经验不丰富的开发者尤为明显。
我们先不妨看看 mCast 的设计、原型和最终实现的过程。
设计 ‎mCast 并不是要做一个全尺寸的桌面端播客客户端，它只是来自我几个简单的想法
一个 macOS menubar 应用，永远可以快速通过鼠标访问类似于 iOS 的应用设计核心功能就是：搜索、浏览热门，然后收听 第一点对于一个开了十几个应用窗口的人来说是刚需，第二点意味着这个应用就是个 Single Page App，第三点代表着这个应用不会去做播客下载等功能，因为在桌面平台上，我们假设网络是永远可达的。
有了这几个点子，这个应用该长什么样在脑海里就有个基本的概念了。接下来只需花个两分钟，把一个 iOS 播客应用的截图，放到 macOS menubar 上就行了
对于首页而言，这个可以说就是设计稿了。我们觉得它看起来还不错，像那么一回事。接下来就是写个原型，看看如果这个应用跑起来的话，是不是能够解决我们前面提到的那些痛点。
原型 既然是要写原型的话，一定是尽可能的使用廉价的方式。这里就不得不提我的情况，我并没有太多的设计经验，不具备专业的设计能力。
也就是说，这个页面里面，字体是多大，部件的大小、间距、阴影该是多少，我还没有一套科学的方案。这种情况下，要想知道怎么进行布局才最“悦目”，唯一的办法就是不断的试错。所以，在构建原型时，代码/UI 修改一定要尽可能的轻松和快速。
此外，原型设计工具如果能够尽可能接近我的 mental model，那就再好过了。
基于以上两点，我决定在 codesandbox 上，使用 Vue.js 来书写第一个原型。完成以下的效果，花了一小时不到。
核心模板代码也很简单
&lt;template&gt; &lt;div id="home"&gt; &lt;input v-model="query" type="search" placeholder="Search or enter url" v-on:change="updateQuery" spellcheck="false" /&gt; &lt;div class="filters"&gt; &lt;div class="filter"&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25c0a650e9d521e131b8b2022d966e5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49cfdc5e05164d547fa28807faa433cf/" rel="bookmark">
			决策树系列(一)——从ID3，C4.5到CART树算法原理推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 决策树一、什么是决策树二、特征选择2.1 信息增益信息增益计算练习： 2.2 信息增益比信息增益比： 2.3 基尼系数 三、决策树的生成3.1 ID3算法ID3算法的缺点 3.2 C4.5算法3.2.1 C4.5进行的改进手段1. 连续变量处理手段2. 缺失值处理3. 引入悲观剪枝策略进行后剪枝4. 使用信息增益比(率)作为划分标准 3.2.2 C4.5算法的缺点 3.3 CART算法 四、决策树的剪枝五、决策树优缺点六、算法引申1. 多变量决策树2. 随机森林 七、参考资料 决策树 一、什么是决策树 决策树是一种基于树结构的分类与回归方法，他能够从一系列有特征和标签的数据中总结出决策规则，并用树状图的结构来呈现这些规则,以解决分类和回归问题。
例如，我们看到一个人穿着剪裁得体的西装，修身干练的衬衫，那么我们最起码认为这个人仪表大方，干干净净，然后这个人谈吐得体，态度温和，那么我们说这个人很有气质。最终我们得出一个简单的决策：这个人值得交朋友。上述中，“西装衬衫”可以视为一种特征，那么“干净”就可以视为标签。
决策树学习通常包括3个步骤：
1. 特征选择
2. 决策树生成
3. 决策树剪枝
二、特征选择 特征选择在于选取对训练数据具有分类能力的特征。这样可以提高决策树学习的效率。决策树的目的就是让模型的不确定性降低的越快越好。如果利用一个特征进行分类的结果与随机分类的结果没有很大差别，则称这个特征是没有分类能力的。那如何衡量一个特征是否具有分类能力？通常特征选择的准则是信息增益或信息增益比。
2.1 信息增益 划分数据的原则是：将无序的数据变得更加有序。在划分数据集前后，信息发生的变化称为信息增益。那么，如何定义信息呢？这里我们引入熵的概念。
在信息论与概率统计中，熵是表示随机变量不确定性的度量(物理学中定义为混乱度)。假设集合中的变量X = { x 1 , x 2 , x 3 , . . . , x n x_1,x_2,x_3,...,x_n x1​,x2​,x3​,...,xn​ }，它对应在集合中的概率是P = { P 1 , P 2 , P 3 , .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49cfdc5e05164d547fa28807faa433cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5bfe9aefcefa225b8cd347b41ed8776/" rel="bookmark">
			au人声处理_人声效果的精细处理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该楼层疑似违规已被系统折叠 隐藏此楼查看此楼
对人声效果的处理，大多数人都是使用反复试探性调节的方法，以寻找音感效果最好的处理效果。此种调音方式的不足十分明显：
(1)寻找一个理想的调音效果，需经多次猜测，所以需要教长的时间。
(2)较好的调音效果常常是偶然遇到的，这对于调音规律的归纳总结没什么帮助，并且以后也不易再现。
(3)不同设备的各项固定参数和可调参数都不尽相同，因而使用某一设备的经验，通常都无法用于另一设备。
发展到目前的效果处理设备，用于改变音源音色的技术手段并不太多，其中比较常用的只有频率均衡、延时反馈、限幅失真等3种基本方法，然而这些效果处理设备的不同参数组合所产生的音色则大相径庭。
效果处理器的参数设置可以有很多项，尤其是延时反馈，这种模拟混响效果参数的设置理论上可达几十项之多。当然这些专业性极强的参数，大多数人都难以理解，也不知道如何理解。因此，大部分效果处理设备都只设置一、二个可调参数，并且其可调范围也比较狭窄。这种调整简单的效果处理设备容许人们在上面进行尝试性调整，而不会出现太大的问题。但对于效果处理要求更为精细的调音场合，例如在多轨录音系统当中，则必须使用更为专业的效果处理设备，用以做出更为精细的效果处理。
频率均衡
很明显，频率均衡的分段越多，效果处理的精细程度也就越高。除了图示均衡，一般调音的均衡单元通常只有三四个频段，这显然满足不了精确处理音源的要求。为了能足够灵活的对人声进行任意的均衡处理，我们建议使用增益、频点和宽度都可调整的段频率均衡。
多数频率均衡的可调参数只有增益一项，然而这并不意味着其他两项参数不存在，而且这两项参数为不可调的固定参数。当然这两项参数设置为可调也并非难事，但这些会增加设备的成本，并使其调整变得复杂化。所以增益、频点和宽度都可调整的参量均衡电路，通常只有在高档设备上才能见到。
实际上，增益、频点和宽度都是可调整的频率均衡，几乎不可能使用胡猜乱试的方法找出一个理想的音色。在这里我们必须研究音频信号的物理特性、技术参数以及他在人耳听感上的对应关系。
人声音源的频谱分布比较特殊，就其发音方式而言，他有三个部分：一个是由声带震动所产生的乐音，此部分的发音最为灵活，不同音高、不同发音方式所产生的频谱变化也很大；二是鼻腔的形状较为稳定，因而其共鸣所产生的谐音频谱分布变化不大；三是口腔气流在齿缝间的摩擦声，这种齿音与声带震动所产生的乐音基本无关。
频率均衡可以大致的将这三部分频谱分离出来。用语调节鼻音的频率段在500Hz，以下均衡的中点频率一般在80~150Hz，均衡带宽为4个倍频程。例如，可以将100Hz定为频率均衡的中点，均衡曲线应从100~400Hz平缓的过渡，均衡增益的调节范围可以为+10Db~-6dB。这里应提醒大家的是：进行此项调整的监听音箱不得使用低频发音很弱的小箱子，以避免鼻音被无意过分加重。
人声乐音的频谱随音调的变化也很大，所以调节乐音的均衡曲线应非常平缓，均衡的中点频率可在1000~3400Hz，均衡带宽为六个倍频程。此一频段控制着歌唱发音的明亮感，向上调节可温和地提升人声的亮度。然而如需降低人声的明亮度，情况就会更复杂一些。一般音感过分明亮的人声大多都是2500Hz附近的频谱较强，这里我们可用均衡带宽为1/2倍频程，均衡增益为-4dB左右的均衡处理，在2500Hz附近寻找一个效果最好的频点即可。
人声齿音的频谱分布在4kHz以上。由于此频段亦包含部分乐音频谱，所以建议调节齿音的频段应为6~16KHz，均衡带宽为3个倍频程，均衡中点频率一般在10~12KHz，均衡增益最大向上可调至+10Db；如需向下降低人声齿音的响度，则应使用均衡带宽为1/2倍频程，均衡中点频率为6800Hz的均衡处理，其均衡增益最低可向下降至-10Db。
由以上分析可以看出，对人声进行频率均衡处理时，为突出某一音感而进行的频段提升，都尽量使用曲线平缓的宽频带均衡。这是为了使人声鼻音、乐音、齿音三部分的频谱分布均匀连贯，以使其发音自然、顺畅。从理论上讲，应使人声在发任何音时，其响度都保持恒定。
为了在不破坏人生自然感的基础上对其进行特定效果的处理可以使用1/5倍频程的均衡处理，具体有以下几种情形：
(1)音感狭窄，缺乏厚度，可在800Hz处使用1/5倍频程的衰减处理，衰减的最大值可以在-3dB。
(2)卷舌齿音的音感尖啸，"嘘"音缺乏清澈感，可在2500Hz处使用1/5倍频程的衰减处理，衰减的最大值可以在-6Db。
对音源的均衡处理，最好是使用能显示均衡曲线的均衡器。一般数字调音台均衡器上的均衡增益调节钮用"G"来标识，均衡频率调节钮用"F"来标识，均衡带宽调节钮用"F"或"Q"来标识。
延时反馈
延时反馈是效果处理当中应用最为广泛，但也是最为复杂的方式。其中，混响、合唱、镶边、回声等效果，其基本处理方式都是延时反馈。
1、混响
混响效果主要是用于增加音源的融合感。自然音源的延时声阵列非常密集、复杂，所以模拟混响效果的程序也复杂多变。常见参数有以下几种：
混响时间：能逼真的模拟自然混响的数码混响器上都有一套复杂的程序，其上虽然有很多技术参数可调，然而对这些技术参数的调整都不会比原有的效果更为自然，尤其是混响时间。
高频滚降：此项参数用于模拟自然混响当中，空气对高频的吸收效应，以产生较为自然的混响效果。一般高频混降的可调范围为0.1~1.0。此值较高时，混响效果也较接近自然混响；此值较低时，混响效果则较清澈。
扩散度：此项参数可调整混响声阵密度的增长速度，其可调范围为0~10，其值较高时，混响效果比较丰厚、温暖；其值较低时，混响效果则较空旷、冷僻。
预延时：自然混响声阵的建立都会延迟一段时间，预延时即为模拟次效应而设置。
声阵密度：此项参数可调整声阵的密度，其值较高时，混响效果较为温暖，但有明显的声染色；其值较低时，混响效果较深邃，切声染色也较弱。
频率调制：这是一项技术性的参数，因为电子混响的声阵密度比自然混响稀疏，为了使混响的声音比较平滑、连贯，需要对混响声阵列的延时时间进行调制。此项技术可以有效的消除延时声阵列的段裂声，可以增加混响声的柔和感。
调治深度：指上述调频电路的调治深度。
混响类型：不同房间的自然混响声阵列差别也较大，而这种差别也不是一两项参数就能表现的。在数码混响器当中，不同的自然混响需要不同的程序。其可选项一般有小厅(S-Hall)、大厅(L-Hall)、房间(Room)、随机(Random)、反混响(Reverse)、钢板(Plate)、弹簧(Sprirg)等。其中小厅、大厅房间混响属自然混响效果；钢板、弹簧混响则可以模拟早期机械式混响的处理效果。
房间尺寸：这是为了配合自然混响效果而设置的，很容易理解。
房间活跃度：活跃度，就是一个房间的混响强度，他与房间墙面吸声特性有关，此项参数即用于调节此特性。
早期反射声与混响声的平衡：混响的早期反射声与其处理效果特性关系密切，而混响声阵的音感则不那么变化多端，所以数码混响器的这两部分的生成是分开的，本参数就是用于调整早期反射声与混响声阵之间响度平衡。
早期反射声与混响声的延时时间：即早期反射声与混响声阵之间的延时时间控制。此时间较长，混响效果的前段就较清澈；此时间较短，早期反射声与混响声就会重叠在一起，混响效果的前段就较浑浊。
除以上可调参数之外，混响效果还有一些其他附属参数，例如低通滤波、高通滤波、直达/混响声的响度平衡控制等。
2、延时
延时就是将音源延迟一段时间后，再欲播放的效果处理。依其延迟时间的不同，可分别产生合唱、镶边、回音等效果。
当延迟时间在3~35ms之间时人耳感觉不到滞后音的存在，并且他与原音源叠加后，会因其相位干涉而产生"梳状滤波"效应，这就是镶边效果。如果延迟时间在50ms以上时，其延迟音就清晰可辨，此时的处理效果才是回音。回音处理一般都是用于产生简单的混响效果。
延时、合唱、镶边、回音等效果的可调参数都差不多，具体有以下几项：
*延时时间(Dly)，即主延时电路的延时时间调整。
*反馈增益(FBGain)，即延时反馈的增益控制。
*反馈高频比(HiRatio)，即反馈回路上的高频衰减控制。
*调制频率(Freq)，指主延时的调频周期。
*调制深度(Depth)，指上述调频电路的调制深度。
*高频增益(HF)，指高频均衡控制。
*预延时(IniDly)，指主延时电路预延时时间调整。
*均衡频率(EQF)，这里的频率均衡用于音色调整，此为均衡的中点频率选择。
由于延时产生的效果都比较复杂多变，如果不是效果处理专家，建议使用设备提供的预置参数，因为这些预置参数给出的处理效果一般都比较好。
声激励
对音源信号进行浅度的限幅处理，音响便会产生一种类似"饱和"的音感效果从而使其发音在不提高其实际响度的基础上有响度增大的效果。
一些数码效果器上也配有非线性饱和效果，他就是对信号的振幅处理，模拟大电瓶信号在三极管上的饱和所引起的非线性，从而产生出"发硬"的音感效果。
由于限幅失真所引起的主要是产生额外的高次谐波成分，因而新设计的激励器，为了使其处理效果柔和一些，都是通过在音源中家置高次载波成分来模拟限幅失真，营造不那么"嘶哑"的声激励效果。
另外，通过一个用于加强高次谐波的高通滤波器对原信号进行处理，然后再叠加在经延时的原信号上，可以营造出音头清澈的声效果。显然、这种处理方式可以产生出不那么嘈杂的激励处理。
激励处理类似于音响设备的过载失真，因而对音源的过量激励，会产生令人不悦的嘈杂感。由于早期音响设备的保真度都不高，人们已经习惯了那种稍显嘈杂的音响，而对于音感清洁的高保真度音响，反而不太习惯，感觉其发音过分柔弱。在人声音源当中，除了一少部分经过专门训练的人之外，大部分的发言都缺乏劲度，因而这里的激励处理是十分必要的。
对人声的激励处理有下面几种情形：
(1)对人声乐音的激励处理，其频谱分布以2500Hz为中点。此种激励的效果比较自然舒适、对增加音源突出感的作用也比较明显。
(2)对人声鼻音的激励处理，其频谱分布以500Hz为中点。此种激励可以有效地增大人声的劲度感。
(3)对人声800Hz附近进行激励，可以增加音源的喧嚣感，当然此处理方式的使用应十分谨慎，最好是只用于摇滚乐的演唱。
(4)对人声3500-6800Hz范围内的频谱，不宜使用激励处理，因为它容易使音源产生令人不悦的嘈杂声响。
(5)对人声的齿音一般应避免使用激励处理，因为此频段的失真很容易被人察觉。当然如果是使用激励效果比较柔和的数字式激励器，也可以对齿音做轻微的激励处理，以用于加重齿音的清析感。其处理的频谱应在7200Hz以上。
歌唱发音的激励处理通常要保守一些。在实际的调音当中，激励处理的音感效果有可能随长时间的听音而逐渐弱化，所以在调节激励效果时，时间不要超过10分钟。
对人声音源的激励处理，最好是使用数码效果处理器。它通常有以下几项调整参量：
1.输入增益(Gmn)，用于调节输入电平，注意此处切勿使设备产生过载。
2.调谐频率(Tuning)，根据需要处理的频段，选择一个合适的频率。
3.驱动电平(Drive)，用于调整激励的深度。驱动电平较大时，效果比较嘈杂；驱动电平较小时，效果则比较温和。
4.混合比率(Mix)，即原信号与效果信号的响度比。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5bfe9aefcefa225b8cd347b41ed8776/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/964dcf0b6e76e4692e05e60c00881594/" rel="bookmark">
			vs2015编译ffmpeg 配置开发环境 (坑多)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		心得 在刚开始学ffmpeg的时候，遇到的最大麻烦就是配置开发环境，ffmpeg我在使用的时候明显感觉linux下面配置比windows下面配置简单多了。但是在win环境下工作也有很多方便的地方。在配置这个环境的过程中，并没有像网上找到的那些配置资料那样，很顺利，我遇到的麻烦主要有几点：
①网上搜索的资料提供的老ffmpeg build版本网址，已经关闭了。想要得到旧版本ffmpeg，可能要自己编译。
②编译环境的问题，到底是选MINGW还是MSVC
③vs编译环境导致一系列问题下面就是配置环境的过程，希望能帮助被配置环境卡住的人。 一、开发环境 用的是vs2015 ffmpeg版本 3.4.2 二、编译 先去github上面下载源码，然后再编译成库文件和程序，才能使用。
编译过程会因为系统环境和vs方面的配置，出现各种各样的问题。可以直接去下build好的。
以下为理想中的vs ffmpeg编译过程：
先安装mys2库，官网为https://www.msys2.org/。下载后安装，我选择安装在D盘，感觉安装包比较大。到msys2窗口执行，安装编译程序： pacman -S make gcc diffutils重命名D:\Program Files\msys2\usr\bin\link.exe 为link.bak, 避免和MSVC 的link.exe冲突起来。安装YASM,官网为http://yasm.tortall.net/Download.html，下载后，将下载回来的yasm-1.3.0-win64.exe 改名为yaml.exe，并放置于 MSYS2 安装目录中。就是放置到D:\Program Files\msys2\usr\bin 中。把ffmpeg放msys2目录下面，然后
./configure --toolchain=msvc --arch=x86 --enable-yasm --enable-asm --enable-shared --disable-static
这一步我失败了。make后 make install 总结：我编译失败了，提示是cl问题，估计是环境变量的问题。下面给出解决办法。 错误解决过程 提示找不到cl，尝试找到vs的cl路径，并添加到环境变量，但是依然报错，并且vs创建不了新的项目，去系统的卸载程序面板，修复vs，修复之后再去configue ffmpeg依然找不到cl。重新安装了vs2015，没有提示cl问题了
但是编译报错，是nasm的问题
nasm/yasm not found or too old. Use --disable-x86asm for a crippled build.
在msys2里面执行
pacman -Su nasm安装编译环境。
之后再configure
编译过程很慢，等了很长时间make 之后，msys2界面中大量报错，命令行 error D8000 :cl:。可能是vs用的是中文版。
(1)那么需要切换到其他语言包，去vs的选项-&gt;工具-&gt;区域里面，获取其他语言。跳到微软的网站，下载了一个英语语言包安装程序，运行结果vs2015提示安装不起来，提示已经安装语言（并没有安装）。那么就需要卸载该语言包，然后再重新安装语言包。
(2)卸载方法为，给语言包安装程序添加快捷方式，打开属性，在最后添加-Uninstall，卸载过程非常慢。卸载完再重新安装英文语言包，之后就可以make和makeinstall了。 编译输出的位置 在我的mysy2安装路径 D:\Program Files\msys2\usr\local下面，出现了几个文件夹，其中include和lib文件夹包含了我所需要的库和头文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/964dcf0b6e76e4692e05e60c00881594/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bc7933c963a59ea4e919aa74b0f4cb0/" rel="bookmark">
			eggjs session传递不成功
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近自己写node后台的时候遇见一个问题，在egg框架中，跨域参数设置成
config.cors = { origin: 'http://localhost:3000', allowMethods: 'GET,HEAD,PUT,POST,DELETE,PATCH,OPTIONS' }; 无法进行session传递，登录接口获取session后并没存储起来
于是乎发现需要允许cookie跨域
config.cors = { origin: 'http://localhost:3000', credentials: true, // 支持cookie跨域 allowMethods: 'GET,HEAD,PUT,POST,DELETE,PATCH,OPTIONS' }; 在前端请求中新增
axios({ method:'post', url: checkLogin, data:dataProps, withCredentials: true // 增加cookie跨域 }).then( res=&gt;{ setIsLoading(false) if(res.data.data=='登录成功'){ localStorage.setItem('openId',res.data.openId) props.history.push('/index') }else{ message.error('用户名密码错误') } } ) 经过这一系列操作后，发现，cookie还是没有正常存储，以为是配置有问题，开始从各个配置中开始寻找错误项，经过多种尝试无果，最后突然想到线上环境的页面经过ngnix反向代理后，接口才能正常存储cookie，于是我把我的本地路径改成了 http://127.0.0.1:3000/login
config.cors = { origin: 'http://127.0.0.1:3000', credentials: true, // 支持cookie跨域 allowMethods: 'GET,HEAD,PUT,POST,DELETE,PATCH,OPTIONS' }; 意外的发现cookie可以正常的存储了，没想到最后的问题出在这里，如果大家在本地开发同意遇见了这样一个问题，大家可以尝试下这个方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41400e3908deb90d0a9ad117971e2661/" rel="bookmark">
			android dts配置_Android 4.0系统支持DTS音效_华为手机_手机Android频道-中关村在线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在系统方面，华为T8950荣耀+采用的是当前新机比较主流的Android 4.0系统。虽然使用的是原生Android 4.0系统，但是华为在此基础上还是做了一定的优化。从主界面来看，并没有太多的特色。不过用户可以通过功能键来切换2D与3D桌面。切换后的显示效果还是比较明显的。可以很清楚的看出图标的阴影效果以及窗口切换时富有立体的旋转动画。有了这样的一个小小改变也可以为用户带来不同的体验效果。
Android 4.0系统界面
可切换2D/3D桌面
我们在主屏幕的第二屏可以看到有一个比较简洁的音乐播放器插件。进入到音乐播放器后，整体的一个播放界面还是非常简单的。不过功能却不少。如果手机中有多首歌曲时，用户可以直接滑动音乐封面来切换歌曲，不用点击下方的按键来操作，而且滑动音乐封面非常的流畅。
音乐播放界面 加入DTS音效
在音质方面，由于加入了DTS音效，因此当我们从设置中开启DTS音效时，播放出的音乐效果完全与未开启是两种感觉。未开启DTS音效时，播放出的音乐，感觉声音比较低而且没有立体环绕感。该机设有双扬声器，因此在开启DTS音效后，双扬声器能够充分展现出应有的良好音效。声音饱满，空间感非常突出，使用耳机后的感觉更明显。这点非常值得赞赏。
720p视频播放非常流畅
在视频播放方面，这款手机使用的双核1GHz处理器为MT6577处理器，可支持720p视频播放。那么在实际的测试中，我们选取的720p分辨率，码率为2705Kbps，编码为H264视频，播放非常流畅，丝毫没有卡顿的现象。同时DTS音效也同样支持视频播放，开启DTS音效播放出的视频音效的确与未开启有很大的区别。
//mobile.zol.com.cn/324/3243878.html
mobile.zol.com.cn
true
中关村在线
//mobile.zol.com.cn/324/3242040.html
report
1380
在系统方面，华为T8950荣耀+采用的是当前新机比较主流的Android 4.0系统。虽然使用的是原生Android 4.0系统，但是华为在此基础上还是做了一定的优化。从主界面来看，并没有太多的特色。不过用户可以通过功能键来切换2D与3D桌面。切换后的显示效果还是...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad6b9e255b7bc7d8f2e34c81dc1ac08a/" rel="bookmark">
			[css]  用css画出一个圆圈，里面有个对号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[css] 用css画出一个圆圈，里面有个对号 #right { width: 150px; height: 150px; margin: 100px auto; border-radius: 50%; border: 5px solid #000000; display: flex; justify-content: center; align-items: center; } #right::before { content: ""; display: block; width: 88px; height: 50px; border: 20px solid #000000; border-right: none; border-top: none; transform: rotate(-45deg) translate(7px, -10px); } 个人简介 我是歌谣，欢迎和大家一起交流前后端知识。放弃很容易，
但坚持一定很酷。欢迎大家一起讨论
主目录 与歌谣一起通关前端面试题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d443a81a353125ffd545f4d332c3d3e/" rel="bookmark">
			[css]  你们团队中css的class命名采用的是什么方式呢？下划线还是横线还是驼峰？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[css] 你们团队中css的class命名采用的是什么方式呢？下划线还是横线还是驼峰？ 形式 .a .a-b 不用驼峰和_，因为这两样都需要 shift 辅助输入, 驼峰越多，按下shift 键的次数就越多。 个人简介 我是歌谣，欢迎和大家一起交流前后端知识。放弃很容易，
但坚持一定很酷。欢迎大家一起讨论
主目录 与歌谣一起通关前端面试题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23487955c4e86fcbb794a2f0e59da8fc/" rel="bookmark">
			mysql cluster 故障切换_Orchestrator MySQL主库故障切换的几种类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Orchestrator 对MySQL主库的故障切换分为自动切换和手动切换。
手动切换又分为recover、force-master-failover、force-master-takeover以及graceful-master-takeover.
1.自动切换
自动切换是主库出现故障后，自动提升新主库，进行故的障切换。
自动切换受到以下条件限制和约束：
主库是downtime的集群不进行故障切换。如果希望忽略集群故障，可以设置downtime。
处于故障活跃期的集群不进行故障切换(即in_active_period=1)
只对配置项RecoverMasterClusterFilters匹配的集群进行故障切换
会周期检测主库状态。
自动切换，会周期进行故障扫描，如果发现故障，条件满足就会进行故障切换。
故障检测和切换具体由CheckAndRecover()实现，具体调用：
GetReplicationAnalysis()，进行故障扫描
executeCheckAndRecoverFunction()，进行故障恢复
2.手动切换
手动切换包括: recover、force-master-failover, force-master-takeover以及graceful-master-takeover。
手动切换不受自动切换中提到的条件限制和约束。
2.1 recover
recover 以故障主库以及候选实例candiateKey为参数，调用CheckAndRecover()，进行故障切换。
指定的故障主库必须是故障的，也就是已确认发生故障，如果不是故障的，不进行切换。
2.2 force-master-failover
不论集群主库是否故障，都会进行后续切换操作，需要用户确认已发生故障。
具体步骤：
(1) 故障扫描 forceAnalysisEntry()--&gt;GetReplicationAnalysis()
(2) 故障恢复ForceExecuteRecovery(analysisEntry, nil,false)--&gt;executeCheckAndRecoverFunction()，不指定候选主库
最后，老主库成为单独的DB 实例。
2.3 force-master-takeover
同上，需要用户自己判定故障。
force-master-takeover，唯一不同于force-master-failover的点是，force-master-takeover带候选主库(即candidate)，并且候选主库必须是集群主库的直连从库。
其他同force-master-failover。
2.3 graceful-master-takeover
这种切换方式针对的是：老主库是正常的，需要提升新主库，老主库可作为从库。
具体操作步骤包括：
(1)检查候选主库
候选主库必须是集群的主库的直连从库
候选主库，没有被禁止提升为主库(即promotion rule 不是must not)
候选主库，没有延迟过大(超过20s)
(2) 故障扫描，forceAnalysisEntry()--&gt;GetReplicationAnalysis()
(3) 调用hooks：PreGracefulTakeoverProcesses
(4) 如果集群中不只一个副本，将老主库的从库移动到候选主库之下
(5) 停止候选主库的复制，在候选主库上执行stop slave
(6) 设置老主库只读
(7) 使候选主库追上老主库(start slave until)
(8) 进行故障恢复，新主库形成ForceExecuteRecovery(analysisEntry, &amp;destination.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23487955c4e86fcbb794a2f0e59da8fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fcfa162d2592d813889ad54fc72cd49/" rel="bookmark">
			iOS键盘弹出遮挡输入框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：输入框被键盘遮挡
期望效果：输入框位于键盘上方
解决思路：
监听键盘出现和消失的状态，当键盘出现时，当前视图上移，当输入完成收起键盘时，视图回到初始状态。
难点：视图向上平移的距离
原理都差不多，oc版参考代码：
self.phoneInput = [UITextField new]; self.phoneInput.placeholder = @"请输入..."; [self.view addSubview:self.phoneInput]; ///键盘弹出 处理遮挡问题 - (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil]; } - (void)keyboardWillShow:(NSNotification *)notification { //获取处于焦点中的view NSArray *textFields = @[self.phoneInput]; UIView *focusView = nil; for (UITextField *view in textFields) { if ([view isFirstResponder]) { focusView = view; break; } } if (focusView) { //获取键盘弹出的时间 double duration = [notification.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fcfa162d2592d813889ad54fc72cd49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff6ea51084946a9f525dbb5d78ad9dc8/" rel="bookmark">
			时钟分频器的工作原理_STM32定时器（TIM）之预分频器（PSC）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在STM32的定时器中，预分频器(Prescaler-PSC)用来将定时器时钟源进行分频输出。
预分频器的值由寄存器TIMx_PSC设定，是一个16位正整数值。
STM32CubeMX中的TIM预分频设置 在STM32系统中，定时器的时钟源为内部时钟时，其频率一般都比较高，以STM32F103的TIM1为例，其总线时钟最大为72MHz，体现在16位的定时器上的效果就是从0计数到65535上溢只需要0.9毫秒。如果我们需要更长时间的定时间隔，那么就需要预分频器对时钟进行分频处理，以降低定时器时钟（CK_CNT）的频率。
除此之外，也可以通过配置预分频器，来获取想要的定时器时钟频率。依然以上边的TIM1为例，如果我们想获取一个精确的1ms中断，如果不分频，72MHz的时钟对应每周期1/72us，十分不利于计算。这时候使用预分频器将其72分频后为1MHz，每周期1us，1000个计时周期即为1ms，这样既便于计算，定时也更加精确。
预分频器的工作的工作原理是，定时器时钟源每tick一次，预分频器计数器值+1，直到达到预分频器的设定值，然后再tick一次后计数器归零，同时，CNT计数器值+1。
由此可以看出，因为达到最大值后还要再tick一次才归零，所以定时器时钟频率应该为Fosc/(PSC+ 1)。其中Fosc是定时器的时钟源。比如想对时钟源进行72分频，那么预分频器的值就应该设置为71。
预分频器值寄存器TIMx_PSC存在影子寄存器（官方翻译为缓冲功能），所以在定时器启动后更改TIMx_PSC的值并不会立即影响当前定时器的时钟频率。要等到下一个更新事件（UEV）发生时才会生效。比如下边这张图就体现了将分频系数由1修改为2（即TIMx_PSC由0更改为1）时整个定时器的时序图。
预分频器值更改时的定时器时序图 更新事件（UEV）则由TIMx_CR1寄存器中的UDIS位控制，在启用时，会通过以下两种方式触发 ：
计数器上溢 手动将 TIMx_EGR 寄存器中的UG 位置 1 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/330/">«</a>
	<span class="pagination__item pagination__item--current">331/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/332/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>