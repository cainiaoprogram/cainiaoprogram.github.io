<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/142cb5a0876b0abe2e801d7e679cf1ad/" rel="bookmark">
			使用afl-cov出现lcov: ERROR: no valid records found in tracefile解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 lcov: ERROR: no valid records found in tracefile解决办法 出现这个问题有两种可能 一个是gcc问题，gcc 8出现了问题，使用gcc 7没有出现问题一个是lcov问题，ubuntu装的版本是1-13，建议换一个新版本 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41f582aa6e1cacb260899bd27d4b9d9f/" rel="bookmark">
			选择排序算法详解之C语言版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、算法原理 选择排序属于不稳定排序法，是一种常用的排序算法，其时间复杂度为O(n^2)。
所谓的不稳定排序算法是指在一组数据中存在多个相同的数据，但是在排序之后，相同数据的前后位置会发生改变。例如有数据{5, 5., 2}，使用选择排序法，排序结果为{2, 5., 5}，即两个相同数据5的前后位置发生了改变。
选择排序算法原理就是首先固定一个位置i，用该位置上的元素data与后面的元素data_j依次比较大小。以从小到大排序为例，如果data &gt; data_j，则交换这两个数据，直到位置i之后的所有元素都小于该位置上的元素结束。之后执行i++即可完成该数组的排序。
Demo：假设有数据如下表所示：数组名记为data
Step 1：固定下标i为1，取出其位置上的元素data[1]，与之后的每一个位置上的元素进行比较，当比较到位置3的时候，该位置上的元素data[3]&lt;data[1]，此时交换data[1]和data[3]，得到如下数组。
然后从data[4]开始继续和data[1]比较，重复前述工作，最终完成与data[1]的比较，并得到如下的数组：
Step 2：固定下标为2，从data[3]开始比较与data[2]的大小，遇到反序的元素则交换。最终得到如下数组：
Step 3：固定下标为3，从data[4]开始比较与data[3]的大小，遇到反序的元素则交换。最终得到如下数组：
Step 4：固定下标为4，从data[5]开始比较与data[4]的大小，遇到反序的元素则交换。最终得到如下数组：
Step 5：固定下标为5，从data[6]开始比较与data[5]的大小，遇到反序的元素则交换。最终得到如下数组：
二、算法 1. 固定某个位置i的排序算法：
Step 1: 取出元素data[i]；
Step 2：j = i+1，比较data[i]和data[j]，如果反序则交换data[i]和data[j]的值，转Step 3；
Step 3：j = j+1，如果j等于数组的长度n，则结束，否则转Step 2.
2.选择排序算法：
固定的位置i从1开始直到i=n-1，依次执行上述固定位置的排序算法即可。
从算法流程可以看出，选择排序算法的时间复杂度是O(n^2)。
3.选择排序算法流程图：
三、算法之C程序 1.选择排序算法之C语言版
/* 功能：使用选择排序法对数组data进行排序 输入参数： data，已知数据散乱的数组 n，元素的个数 输出参数： Data，排好序的数组 返回值：无 */ void SelectionSort( int data[], int n ) { int i, j, t, k; for( i = 1; i &lt;= n-1; i++ ) { //输出每一轮排序前的状态 for( k = 1; k &lt;= n; k++ ) { printf( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41f582aa6e1cacb260899bd27d4b9d9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a401673001ee30d71943bfb2a3732504/" rel="bookmark">
			关于 solidworks启动问题：无法获得下列许可 solidworks standard 无法连接到服务器(-15,10,10016)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SolidWorks软件功能强大，组件众多、易学易用的特点，使其成为3D CAD解决方案的领先和主流。在实体、表面、钣金设计、运动运动仿真、有限元分析等模块中具有不可替代的功能。不知道有没有小伙伴遇到和我一样的问题 ，就是电脑重启后软件就打不开啦，出现下图所示内容。
今天我们就来解决这个问题，直接上干货：
第一步：
在硬盘的SolidWorks_Flexnet_Server文件夹下找到lmtools 应用并双击运行 ，然后进行如下操作：
点击” start/stop/Reread “选项——&gt;点击“Start Server”按键——&gt;点击“Config Services”选项——&gt;勾选 “Start Server at Power Up” 选项——&gt;点击“Save Service”按键 。
第二步：
经过如上设置就可以打开软件了，但电脑重启之后还会出现打不开的情况，折腾了很久，推测应该是系统防火墙自动屏蔽了相关服务（“SolidWorks Flexnet Server” ），所以需要进行如下操作：
①右键左下角开始菜单，打开任务管理器，
②点击“服务”选项，找到”SolidWorks Flexnet Server “条目，右键弹出上下文菜单中点击“打开服务”。
③接下来同样在“服务”的列表中找到“SolidWorks Flexnet Server”，右键选择属性，
④在“常规”选项卡中的“启动类型(E)”下拉菜单中选择“自动”，
⑤在“恢复”选项卡中进行计算机自动服务失败的操作设置，“第一次失败”选择“重新启动服务”，“第二次失 败”及“后续失败”选择运行一个程序（sw_d.exe） 一般是在“SolidWorks_Flexnet_Server"文件夹下。具体设置如下图:
ok! 到这里这个问题就解决啦! 为了印证这个思路是否可行，我们把电脑重启，并打开solidworks进行验证!，电脑重启后稍等1~2分钟再运行程序，因为window系统是在开机后才开始加载各种服务程序的，开机后等1~2分钟是为了提高本方法的兼容性，因为有的小伙伴刚开机就运行SW发现还是打不开就怀疑本方法的可行性，实际上是因为上述设置在刚开机后还没生效。 最后，如果你想知道为什么这样设置下面给出我的关于本方法的解释：
至于第⑤步 ，为什么运行的是这个程序“sw_d.exe”，是因为如果 在“SolidWorks Flexnet Server”服务处于“正在运行”的状态，是可以在“任务管理器”的该条目下右键点击“转 到详细信息”，发现窗口转到“详细信息”选项卡并高亮了“sw_d.exe”，我们右键点击“打开文件所在的位置”(合理猜想打开许可证服务又是通过打开这个程序来进行的），所以我们把该路径复制下来，粘贴到上面对应的程序路径里头，相当于告诉计算机，如果你自动启动失败了，先重启服务，如果还不行，就一直尝试打开这个路径下的sw_d.exe。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13b8663676182210b8f3e646f22092c5/" rel="bookmark">
			关于WPF的Image控件图片显示问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新入手WPF，记录下image控件的图片显示几种方式。
准备：新建文件夹(我命名Asserts或者imgs),然后导入图片
1、直接在控件中绑定
2、在代码中相对路径
3、在代码中绝对路径(路径改为图片的绝对地址)
4、授权方式
使用第二种授权方式要注意设置图片的属性设置 以下为第一次用wpf不出图时的测试项(太久忘记了，反正不出图的时候前面需要加两个..)：
1、在xaml显示图片，添加以下代码直接显示 2、在cs中显示。就是在这一步，我卡了很久。查了很多资料，就是无法搞定，最后磨出来了。
我错误的原因在于没加上../这个，导致路径找不到，很奇怪，我看资料里面基本没人加这个就能显示图片。
另外，在测试的时候，我也按照有些资料修改了图片的属性，不知道这个有没有用，懒得测试了。如果还是不显示，可以试着修改
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb68a082d647ac8a3ed37676fc323c2e/" rel="bookmark">
			scp 命令使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		scp 命令使用 本文记录 scp 命令相关知识
Scp(Secure Copy) 是一个在各个主机之间进行复制或者文件传输的一个命令行工具。它在后台使用 ssh 连接来进行文件的传输。scp 既指一种定义安全复制应该如何工作的协议，也指一种可以被安装的作为 OpenSSH 工具套的一部分的软件或是指令。
命令格式 scp [参数] [原路径] [目标路径] 命令参数 -1 强制 scp 命令使用协议 ssh1 -2 强制 scp 命令使用协议 ssh2 -4 强制 scp 命令只使用 IPv4 寻址 -6 强制 scp 命令只使用 IPv6 寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C （大写）启用压缩功能，文件在传输过程中被压缩，节省时间和带宽； -p （小写）保留原文件的修改时间，访问时间和访问权限； -q 不显示传输进度条、诊断和警告信息； -r 递归复制整个目录 -v 详细显示复制过程的信息，会显示出整个过程有关连接如何建立，正在使用什么配置和认证文件等等的详细信息，当程序失败或无法完成请求时非常有用； -c cipher 以 cipher 将数据传输进行加密，此参数直接传递给 ssh，默认采用 AES 算法，其它的有：blowfish 等； -F ssh_config 指定一个替代的 ssh 配置文件，此参数直接传递给 ssh； -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给 ssh； -l limit 限定 scp 使用的带宽，以 Kbit/s 为单位； -o ssh_option 如果习惯于使用 ssh_config 中的参数传递方式； -P port 注意 P 是大写, port 是指定数据传输用到的端口号； -S program 指定加密传输时所使用的程序，此程序必须能够理解 ssh 的选项； 使用说明 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb68a082d647ac8a3ed37676fc323c2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/496fa792c095102655cb94c1d8b4794b/" rel="bookmark">
			软件测试最全面试题及答案整理（2022最新版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、你的测试职业发展是什么?
2、你认为测试人员需要具备哪些素质
3、你为什么能够做测试这一行
4、测试的目的是什么?
5、测试分为哪几个阶段?
6、单元测试的测试对象、目的、测试依据、测试方法?
7、怎样看待加班问题
8、结合你以前的学习和工作经验，你认为如何做好测试。
9、你为什么选择软件测试行业
10、根据你以前的工作或学习经验描述一下软件开发、测试过程，由哪些角色负责，你做什么
11、根据你的经验说说你对软件测试/质量保证的理解
12、软件测试的流程是什么?
13、你对SQA的职责和工作活动(如软件度量)的理解?
14、说说你对软件配置管理的理解
15、怎样写测试计划和测试用例
16、说说主流的软件工程思想(如CMM、CMMI、RUP,XP,PSP,TSP等)的大致情况及对他们的理解
17、你是怎样保证软件质量的，也就是说你觉得怎样才能最大限度的保证软件的质量?
18、基于目前中国的国情，大多数公司的项目进度紧张、人员较少、需求文档根本没有或者很不规范，你认为在这种情况下怎样保证软件的质量?(大多数公司最想知道的就是在这种困难面前你该怎么保证软件的质量，因为这些公司一般就是这种情况--既不想投入过多又想保证质量)
19、一个测试工程师应该具备哪些素质和技能?
20、做好软件测试的一些关键点
21、软件测试员自身素质培养
22、为什要在一个团队中开展测试工作?
23、你所熟悉的软件测试类型有哪些?
24、你认为做好测试用例设计工作的关键是什么
25、请详细介绍一下各种测试类型的含义
26、测试计划工作的目的是什么?测试计划工作的内容都包括什么?其中哪些是最重要的?
27、您认为做好测试计划工作的关键是什么?
28、当开发人员说不是BUG时，你如何应付?
29、你自认为测试的优势在哪里?
30、什么是系统瓶颈?
31、文档测试主要包含什么内容?
32、功能测试用例需要详细到什么程度才是合格的?
33、配置和兼容性测试的区别是什么?
34、软件文档测试主要包含什么?
35、没有产品说明书和需求文档地情况下能够进行黑盒测试吗?
36、测试中的“杀虫剂怪事”是指什么?
37、在配置测试中，如何判断发现的缺陷是普通问题还是特定的配置问题?
38、为什么尽量不要让时间有富裕的员工去做一些测试?
39、完全测试程序是可能的吗?
40、软件测试的风险主要体现在哪里?
41、发现的缺陷越多，说明软件缺陷越多吗?
42、所有的软件缺陷都能修复吗?所有的软件缺陷都要修复吗?
43、软件测试人员就是QA吗?
44、如何减少测试人员跳槽带来的损失?
45、测试产品与测试项目的区别是什么?
46、和用户共同测试(UAT测试)的注意点有哪些?
47、如何编写提交给用户的测试报告?
48、测试工具在测试工作中是什么地位?
49、常见的测试用例设计方法都有哪些?请分别以具体的例子来说明这些方法在测试用例设计工作中的应用。
50、您认为做好测试用例设计工作的关键是什么?
51、详细的描述一个测试活动完整的过程。
52、以往是否曾经从事过性能测试工作?请尽可能的详细描述您以往的性能测试工作的完整过程。
53、在您以往的工作中，一条软件缺陷(或者叫bug)记录都包含了哪些内容?如何提交高质量的软件缺陷(bug)记录?
54、您在从事性能测试工作时，是否使用过一些测试工具?如果有，请试述该工具的工作原理，并以一个具体的工作中的例子描述该工具是如何在实际工作中应用的。
55、您认为性能测试工作的目的是什么?做好性能测试工作的关键是什么?
1、你的测试职业发展是什么? 测试经验越多，测试能力越高。所以我的职业发展是需要时间积累的，一步步向着高级测试工程师奔去。而且我也有初步的职业规划，前3年积累测试经验，按如何做好测试工程师的要点去要求自己，不断更新自己改正自己，做好测试任务。
2、你认为测试人员需要具备哪些素质 做测试应该要有一定的协调能力，因为测试人员经常要与开发接触处理一些问题，如果处理不好的话会引起一些冲突，这样的话工作上就会不好做。还有测试人员要有一定的耐心，有的时候做测试很枯燥乏味。除了耐心，测试人员不能放过每一个可能的错误。
3、你为什么能够做测试这一行 虽然我的测试技术还不是很成熟，但是我觉得我还是可以胜任软件测试这个工作的，因为做软件测试不仅是要求技术好，还有有一定的沟通能力，耐心、细心等外在因素。综合起来看我认为我是胜任这个工作的。
4、测试的目的是什么? 测试的目的是找出软件产品中的错误，是软件尽可能的符合用户的要求。当然软件测试是不可能找出全部错误的。
5、测试分为哪几个阶段? 一般来说分为5个阶段：单元测试、集成测试、确认测试、系统测试、验收测试
6、单元测试的测试对象、目的、测试依据、测试方法? 测试对象是模块内部的程序错误，目的是消除局部模块逻辑和功能上的错误和缺陷。测试依据是模块的详细设计，测试方法是采用白盒测试。
7、怎样看待加班问题 加班的话我没有太多意见，但是我还是觉得如果能够合理安排时间的话，不会有太多时候加班的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/496fa792c095102655cb94c1d8b4794b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc6898071e57cada3ab7aa3b5643417/" rel="bookmark">
			《动手深度学习》从零实现softmax之——图像分类数据集的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从零实现softmax 图像分类数据集的处理(后续常用)Fashion-MNIST 读取数据集小批量数据可视化(不需要d2l库)读取小批量数据data.DataLoader整合为完整的读取数据的方法 python基础语法plt.subplots()的使用 图像分类数据集的处理(后续常用) Fashion-MNIST MNIST数据集 [LeCun et al., 1998] 是图像分类中广泛使用的数据集之一，但作为基准数据集过于简单。 我们将使用类似但更复杂的Fashion-MNIST数据集 [Xiao et al., 2017]。
读取数据集 %matplotlib inline import torch import torchvision from torch.utils import data from torchvision import transforms from d2l import torch as d2l d2l.use_svg_display() #d2l自定义函数：以矢量图svg形式输出 # 通过ToTensor实例将图像数据从PIL类型变换成32位浮点数格式， # 并除以255使得所有像素的数值均在0到1之间 mnist_train = torchvision.datasets.FashionMNIST( root = "E:/Coding/Jupyter/data", train = True, transform = transforms.ToTensor(), download=True) mnist_test = torchvision.datasets.FashionMNIST( root = "E:/Coding/Jupyter/data", train = False, transform = transforms.ToTensor(), download=True) Fashion-MNIST由10个类别的图像组成， 每个类别由训练数据集（train dataset）中的60000张图像 和测试数据集（test dataset）中的10000张图像组成。因此，训练集和测试集分别包含60000和10000张图像。 测试数据集不会用于训练，只用于评估模型性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcc6898071e57cada3ab7aa3b5643417/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c40694c6b73f761ff51ecc97200d63/" rel="bookmark">
			修改 CMD 命令行中 C:\Users\用户名 与系统用户名不一致
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产生背景： 当在 AD 域环境中，当域用户首次登陆系统后，会自动在 " C:\Users\用户 " 路径下建立一个用户名的文件夹，如果这个用户离职后，直接修改 AD 账号的名称，再以新的 AD 账号登陆，就会出现 CMD 命令行中 C:\Users\用户名 与系统用户名不一致
鉴于有朋友按此方法操作后，没法登陆，这里在补充下：
首先要有另一个管理员账号：
如 windows 自带的 Administrator，如果 window10，这个用户默认在装 windows 是禁用的状态，可以将他启用，方法如下：
打开运行：输入 lusrmgr.msc，将 Administrator 启用并设置密码
你也可以新建一个用户，把这个用户加入到管理员 Administrators 组里，这里不再演示
1、Win+R 打开运行输入 regedit 回车，打开注册表编辑器
计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\ 2、定位到下面这个文件夹下：然后找到 S-1-5-21 开头的项，点击进去，找到右侧名为 ProfileImagePath 的文件，双击打开，修改自己喜欢的用户名，点击确定
3、 用 Administrator 管理员登录，如果是域环境下，就用域管理员登陆，然后 修改 C:\Users 下面的用户文件夹名称
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/984c54b869b63971b20124e4acf8a6ce/" rel="bookmark">
			MATLAB系统辨识工具箱-System Identification Toolbox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 该工具箱提供 MATLAB® 函数、Simulink® 模块和一个应用程序，用于根据测量的输入输出数据构建动态系统的数学模型。它使用户可以创建和使用不容易从第一原理或规范建模的动态系统模型。用户可以使用时域和频域输入输出数据来识别连续时间和离散时间传递函数、过程模型和状态空间模型。该工具箱还提供嵌入式在线参数估计算法。
该工具箱提供了最大似然、预测误差最小化 (PEM) 和子空间系统识别等识别技术。为了表示非线性系统动力学，用户可以估计 Hammerstein-Weiner 模型和具有小波网络、树分区和 sigmoid 网络非线性的非线性 ARX 模型。该工具箱执行灰盒系统识别以估计用户定义模型的参数。用户可以在 Simulink 中使用识别的模型进行系统响应预测和工厂建模。该工具箱还支持时间序列数据建模和时间序列预测。
二、开始 了解系统识别工具箱的基础知识
2.1 教程 2.1.1 使用系统识别应用程序识别线性模型 使用系统识别应用程序从单输入/单输出 (SISO) 数据中识别线性黑盒模型。
2.1.2 使用命令行识别线性模型 使用系统识别工具箱命令从多输入/单输出 (MISO) 数据中识别线性模型。
2.1.3 使用系统识别应用程序识别低阶传递函数（过程模型） 使用该应用程序从单输入/单输出 (SISO) 数据中识别连续时间传递函数。
2.1.4 估计热扩散的连续时间灰盒模型 此示例说明如何估计热棒系统的连续时间灰盒模型的热导率和传热系数。
2.1.5 使用系统识别应用程序识别非线性黑盒模型 使用系统识别应用程序从单输入/单输出 (SISO) 数据中识别非线性黑盒模型。
MATLAB-使用系统识别应用程序识别非线性黑盒模型_白日梦想家_胖七七的博客-CSDN博客
2.2 关于系统识别 2.2.1 系统识别概述 系统识别是一种使用系统输入和输出信号的测量来建立动态系统数学模型的方法。
2.2.2 系统识别工作流程 系统识别工作流程中的典型任务总结。
2.2.3支持的数据 System Identification Toolbox 软件支持从时域和频域数据估计线性模型。
2.2.4 支持的连续和离散时间模型 您可以从时域和频域数据中估计的连续时间和离散时间模型的类型。
2.2.5 使用频域数据估计模型 工具箱中的频域识别概述。
2.2.6 何时使用应用程序与命令行 何时使用应用程序与系统识别工具箱命令。
2.2.7 使用系统识别应用程序 使用系统识别应用程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/984c54b869b63971b20124e4acf8a6ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/239de80921baa81173a595ff6c516e5a/" rel="bookmark">
			关于如何创建maven私有仓库（docker中），maven中的setting文件内容设置，pom文件中如何设置连接私有仓库与发布到私有仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.本机安装
本机安装很简单，安装好后，直接运行即可
进入nexus-3.30.0-01\bin目录下，输入cmd
nexus /run
2.如果在docker里面安装nexus
搜索docker镜像
Docker search nexus 拉取镜像
docker pull docker.io/sonatype/nexus3 创建挂载目录
mkdir -p /usr/local/nexus3/nexus-data chown -R 200 /usr/local/nexus3/nexus-data 启动容器 docker run -tid -p 8081:8081 --name nexus -e NEXUS_CONTEXT=nexus -v /usr/local/nexus3/nexus-data:/nexus-data docker.io/sonatype/nexus3 3. 登录Nexus进行配置 登陆Nexus
访问：http://ip:8081/nexus 使用默认管理员身份登录，帐号：admin，密码：在容器中/nexus-data/admin.password中查看
管理仓库
Browse可以查看当前有多少仓库，搭建好的Nexus，默认会带有一些maven仓库，一般使用这些仓库就足够了。
默认仓库说明
maven-central：maven中央库，默认从https://repo1.maven.org/maven2/拉取jar
maven-releases：私库发行版jar，初次安装请将Deployment policy设置为Allow redeploy
maven-snapshots：私库快照（调试版本）jar
maven-public：仓库分组，把上面三个仓库组合在一起对外提供服务，在本地maven基础配置settings.xml或项目pom.xml中使用
增加新的代理源
添加maven2的代理 添加代理（Cache统一设置为200天 288000） 十个常用代理
aliyun http://maven.aliyun.com/nexus/content/groups/public
apache_snapshot https://repository.apache.org/content/repositories/snapshots/
apache_release https://repository.apache.org/content/repositories/releases/
atlassian https://maven.atlassian.com/content/repositories/atlassian-public/
central.maven.org http://central.maven.org/maven2/
datanucleus http://www.datanucleus.org/downloads/maven2
maven-central （安装后自带，仅需设置Cache有效期即可） https://repo1.maven.org/maven2/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/239de80921baa81173a595ff6c516e5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c3bae7f5a1e0b6c48751d7f571667f3/" rel="bookmark">
			Ansible 概述与模块基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Ansible 概述1.Ansible 的特点2.Ansible 工作机制 二、Ansible 环境安装及部署三、Ansible 命令行模块1.command 模块2.shell 模块3.cron 模块4.user 模块5.group 模块6.copy 模块7.file 模块8.hostname 模块9.ping 模块10.yum 模块11.service/systemctl 模块12.script 模块13.setup 模块 四、inventory 主机清单1.inventory 中的变量2.主机变量3.组变量4.组嵌套 一、Ansible 概述 Ansible是一款为类Unix系统开发的自由开源的配置和自动化工具
它用Python写成，类似于saltstack、Puppet、CHef，但是有一个不同和优点是我们不需要在节点中安装任何客户端
它使用SSH来和节点进行通信。Ansible基于 Pthon paramiko 开发，分布式，无需客户端，轻量级，配置语法使用 YMAL 及 Jinja2模板语言，更强的远程命令执行操作
Ansible官方网站：https://www.ansible.com/，红帽公司于2015年10月收购了ansible，而ansible成立于2013年
Ansible能批量配置、部署、管理上千台主机。比如以前需要切换到每个主机上执行的一或多个操作，使用Ansible 只需在固定的一台Ansible控制节点上去完成所有主机的操作
使用者在使用时，在服务器终端输入命令或者playbooks，会通过预定好的规则将playbook拆解为play，再组织成ansible可以识别的任务，调用模块和插件，根据主机清单通过SSH将临时文件发给远程的客户端执行并返回结果，执行结束后自动删除
1.Ansible 的特点 1.部署简单，没有客户端，只需在主控端部署Ansible环境，被控端无需做任何操作
2.模块化：调用特定的模块，完成特定任务
3.默认使用SSH协议对设备进行管理
4.主从集中化管理
5.配置简单、功能强大、扩展性强
6.支持API及自定义模块，可通过Python轻松扩展
7.通过Playbooks来定制强大的配置、状态管理
8.对云计算平台、大数据都有很好的支持
9.具有幂等性：一个操作在一个主机上执行一遍和执行N遍的结果是一样的
2.Ansible 工作机制 Ansible 在管理节点将 Ansible 模块通过 SSH 协议推送到被管理端执行，执行完之后自动删除，可以使用 SVN 等来管理自定义模块及编排
ansible是基于模块工作的，本身没有批量部署的能力，真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。主要包括：
(1)连接插件connection plugins：负责和被监控端实现通信
(2)host inventory：指定操作的主机，是一个配置文件里面定义监控的主机
(3)各种模块核心模块、command模块、自定义模块
(4)借助于插件完成记录日志邮件等功能
(5)playbook：剧本执行多个任务时，非必需可以让节点一次性运行多个任务
由图可以看出Ansible的组成由以下模块组成：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c3bae7f5a1e0b6c48751d7f571667f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54b0966bf1cf803f57ac5e4f66a779f3/" rel="bookmark">
			数据结构笔记（考研）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、算法概述算法的定义：基本特性：算法的基本要求存储结构与逻辑结构 二、数据的逻辑结构集合结构线性结构线性表广义表顺序表数组：查找算法 栈队列单链表循环链表双链表递归斐波那契数列汉诺塔问题 串 排序算法计算交换排序冒泡排序快速排序 插入排序直接插入排序希尔排序 选择排序简单选择排序堆排序 归并排序基数排序 树形结构链式存储的二叉树创建二叉树：前序、中序、后序遍历查找节点删除节点 顺序存储的二叉树线索二叉树赫夫曼树赫夫曼编码二叉排序树（二叉搜索树、BST）平衡二叉树（AVL树）多路查找树 哈希表（散列表）图形结构 一、算法概述 抽象数据类型（ADT）描述了数据的逻辑结构和抽象运算，通常用数据对象、数据关系、基本操作集这样的三元组来表示，从而构成一个完整的数据结构定义
算法的定义： 算法是解决特定问题求解决步骤的描述，再计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。
基本特性： 输入、输出、又穷性、确定性、可行性
输入：算法具有零个或多个输入
输出：算法至少有一个或多个输出
有穷性：指算法再执行有限的步骤之后，自动结束而不会出现无心循环，并且每一个步骤再可接受的时间内完成
确定性：算法的每一个步骤都具有确定的意义，不会出现二义性
可行性：算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限次数完成
好的算法应考虑：正确性、可读性、健壮性、效率与低存储量需求
算法的基本要求 正确性、可读性、健壮性、时间复杂度、空间复杂度
存储结构与逻辑结构 存储结构有顺序存储、链式存储、索引存储和散列存储
有序表既可以链式存储又可顺序存储，属于逻辑结构
二、数据的逻辑结构 集合结构 线性结构 线性表 表中元素具有抽象性，仅讨论元素间的逻辑关系，不考虑元素究竟表示什么内容
广义表 表头可能是原子、列表，表尾必为列表
取表头：列表第一个原子
取表尾：列表删去第一个元素后的剩余列表
顺序表 顺序存储的存储结构是随机存储的存储结构
优点：
随机访问，可通过首地址和元素序号在时间O（1）内找到指定的元素
存储密度高，每个结点只存储数据元素
缺点：
相邻的元素物理上也相邻，插入和删除操作需要移动大量元素，时间复杂度为O（n）
数组： 中间元素删除：创建长度-1的新数组，将原数组头尾复制到新数组中（for循环分为删除之前之后的元素），新数组替换原数组
public class TestArray2 { public static void main(String[] args) { //目标数组 int[] arr = new int[] {9,8,7,6,5,4}; //要删除的元素下标 int dst = 3; //创建新数组，长度是原数组-1 int[] newArr = new int[arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54b0966bf1cf803f57ac5e4f66a779f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99e73b2af47ba0bbe1910b396e807d3d/" rel="bookmark">
			Markdown详细教程&#43;技巧总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Markdown详细教程+技巧总结 前言Markdown工具工具介绍Typora介绍安装设置技巧 VS Code (Visual Studio Code)安装设置中文安装扩展编辑Markdown文档配合Markdown使用的扩展 Markdown Pad 2介绍安装设置中文Key个性化设置 Markdown与HTML的联系编辑技巧快捷键列表标记失效页面内跳转 CSDN博客技巧CSDN目录CSDN快捷键自定义列表注脚注释LaTeX公式Mermaid制图甘特图UML图FLowchart流程图 导出与导入 字符实体前言空格其他 转义字符首行缩进空行字体目录导出分页链接列表有序列表无序列表待办列表多级列表自定义列表 图片Markdown图片CSDN图片HTML图片图片居中标题 表格分割线代码块单行代码块多行代码块技巧 LaTeX数学公式介绍注意事项 前言 若想直接学习LaTeX数学公式，请参见我的另一篇博客：LaTeX数学公式-详细教程 。
本篇文章从基础开始介绍Markdown语言，并有自己的经验和总结。适合新手和有基础的用户。其他途径的基础学习可以参照 Markdown中文文档 。
本篇文章内容包含Markdown工具，Markdown与HTML的联系，页面内跳转，编辑技巧，CSDN博客技巧，字符实体，空格，转义字符，首行缩进，空行，字体，目录，导出分页，链接，列表，图片，表格，代码块，LaTeX数学公式，等等。
Markdown工具 工具介绍 很多小伙伴想要学习Markdown但却不知道使用什么编辑器来编写，这里我来列举一些可以编辑Markdown文件（即.md文件）的软件：Typora（推荐，目前已收费），Vsual Studio Code（推荐），Markdown Pad 2，有道云笔记，印象笔记等等。
个人优先推荐Typora（目前已收费），优点是跨平台，轻量；真缩减即所得，没有预览窗口，写出即可预览；可以自动根据标题显示大纲，即目录。而且集成了LaTeX数学公式的包（需要在设置中开启，后文会详细说明），不需要安装插件。
个人第二推荐Vsual Studio Code，即VS Code，VS Code原生支持Markdown语言，可以安装其他插件使其功能更加强大，下文有VS Code中编辑Markdown的说明，并介绍一些配合Markdown使用的插件。
至于Markdown Pad 2，优点是便捷，速度快，无广告，而且还可以进行个性化设置。但可能需要安装插件，并授权激活，下方有该软件的安装与配置说明。
如果不想安装软件，在CSDN等博客网站上也可以编辑Markdown文件，然后可以选择导出。
Typora 介绍 （目前已收费）
跨平台，轻量；真缩减即所得，没有预览窗口，写出即可预览；可以自动根据标题显示大纲（即目录），也可以手动输入Markdown语法生成目录；集成了LaTeX数学公式的包（需要在设置中开启，后文会详细说明），不需要安装插件。 安装 Typora官网：链接
下载对应系统的软件安装包正常安装即可。
设置 点击文件-偏好设置即可进行设置：
通用-启动选项：可根据自己偏好选择，推荐打开新文件
通用-保存：勾选自动保存
通用-更新：取消自动更新
通用-高级设置：取消勾选发生匿名数据
外观-字体大小：根据自己的偏好设置，如无特殊要求推荐选择自动
外观-状态栏：显示状态栏
外观-侧边栏：大纲视图允许折叠和打开
外观-主题：GitHub
编辑器-使用成对符号：匹配括号和引号，匹配Markdown字符
编辑器-即时渲染：显示Markdown源码
编辑器-复制：复制Markdown源码
图像-插入图片：复制到指定路径，对本地图片使用规则，对网络图片使用规则，优先使用相对路径，推荐填写./image/${filename}
Markdown-Markdown扩展语法：全部勾选
Markdown-代码块：全部勾选，代码缩进为4
导出-通用-默认导出文件夹：和原文件同目录
导出-PDF-主题：自动使用当前主题
导出-PDF-分页：可根据自己偏好选择，也可使用 导出分页 章节的方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99e73b2af47ba0bbe1910b396e807d3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/144267cab6ca28adf5bde8d93c3b7f7e/" rel="bookmark">
			Redis 大 key 要如何处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是 Redis 大 key大 key 会造成什么问题如何找到大 key如何删除大 key 文章目录 1.什么是 Redis 大 key2.大 key 会造成什么问题3.如何找到大 key3.1 redis-cli --bigkeys 查找大key3.2 使用 SCAN 命令查找大 key3.3 使用 RdbTools 工具查找大 key 4.如何删除大 key4.1 分批次删除4.2 异步删除 1.什么是 Redis 大 key 大 key 并不是指 key 的值很大，而是 key 对应的 value 很大。
一般而言，下面这两种情况被称为大 key：
String 类型的值大于 10 KB；Hash、List、Set、ZSet 类型的元素的个数超过 5000个； 2.大 key 会造成什么问题 客户端超时阻塞。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。引发网络阻塞。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。阻塞工作线程。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。内存分布不均。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/144267cab6ca28adf5bde8d93c3b7f7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd94e787e19f3ca171a5ce3434581e80/" rel="bookmark">
			vue 动态路由实现 后端控制权限时的前端处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端思路： 上图中 获取路由信息 ，可以是后端控制的，可以是前端根据用户信息从路由表中筛选的。
此处只讲解后端存储路由信息的情况
组织路由信息 请求后台，获取返回结果，结果有两种可能，一种是组合好的树状结构，一种是路由平铺
树状结构：
不需要重组路由结构，但是需要替换组件信息
import components from '@/router/components' /* 遍历后台传来的路由字符串，转换为组件对象 * @params asyncRouterMap MyRoute[] 异步路由数组 * @params type boolean 是否需要重写子路由路径 */ function filterAsyncRouter(asyncRouterMap: MyRoute[], type = false) { return asyncRouterMap.filter(route =&gt; { if (type &amp;&amp; route.children) { route.children = rewriteChildrenPath(route.children, route) } if (route.component) { // 如果路径组件在路由表中查询不到，默认渲染NotFound组件，其他情况可自定义处理 if (!Object.keys(components).includes(route.component as string)) { route.component = components.NotFound } else { route.component = components[route.component as keyof typeof components] } } if (route.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd94e787e19f3ca171a5ce3434581e80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c05d4bb2845d962fabe7e2c062bb4f6/" rel="bookmark">
			WPF 设计一个最简单登录页面功能的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		布局入门，简单基础四个控件的使用，设计一个最简单登录页面功能的实现；
&lt;Window x:Class="WpfNewGongWei.Demo1.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:local="clr-namespace:WpfNewGongWei.Demo1" mc:Ignorable="d" Title="MainWindow" Height="450" Width="800" ShowInTaskbar="True" WindowStartupLocation="CenterScreen" WindowState="Maximized" Topmost="True" Loaded="Window_Loaded" &gt; &lt;Grid Margin="0,0,248,118"&gt; &lt;Button HorizontalAlignment="Left" Margin="86,305,0,0" VerticalAlignment="Top" Width="75" /&gt; &lt;!--&lt;Button&gt; &lt;Label Content="账号"&gt;&lt;/Label&gt; &lt;/Button&gt;--&gt; &lt;Label Content="账号" Margin="35,50,0,-26" /&gt; &lt;Label Content="密码" Margin="35,80,0,-26" /&gt; &lt;TextBox Name="txtUName" HorizontalAlignment="Left" Margin="86,50,0,0" TextWrapping="NoWrap" Text="admin" VerticalAlignment="Top" Width="120"/&gt; &lt;PasswordBox Name="txtPwd" HorizontalAlignment="Left" Height="23" Margin="86,83,0,0" Password="123456" PasswordChar="*" VerticalAlignment="Top" Width="120" Loaded="txtPwd_Loaded"/&gt; &lt;Button Name="btnLogin" Content="登录" HorizontalAlignment="Left" Margin="76,151,0,0" VerticalAlignment="Top" RenderTransformOrigin="0.464,-0.064" Click="btnLogin_Click" /&gt; &lt;Button Name="btnCancel" Content="取消" HorizontalAlignment="Left" Margin="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c05d4bb2845d962fabe7e2c062bb4f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c4e04fe54e35a7024b29a5f12ae09a7/" rel="bookmark">
			Vue3--vue双向绑定v-module
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue双向绑定v-module v-model 原理 v-bind绑定value属性的值；
v-on绑定input事件监听到函数中，函数会获取最新的值赋值到绑定的属性中
手动实现双向绑定 &lt;input type="text" :value="message" @input="inputChange" /&gt; ... data() { return { message: "Hello Vue", }; }, methods: { inputChange(event) { this.message = event.target.value; }, }, v-model 绑定textarea &lt;textarea cols="30" rows="10" v-model="content"&gt;&lt;/textarea&gt; v-model 绑定checkbox checkbox单选框 绑定到属性中的值是一个Boolean此时input的value属性并不影响v-model的值
&lt;label for="agree"&gt; &lt;input id="agree" type="checkbox" v-model="isAgree" /&gt; 同意协议 &lt;/label&gt; &lt;h2&gt;单选框:{{isAgree}}&lt;/h2&gt; checkbox多选框 绑定到属性中 值是array 注意 多选框中 必须明确的绑定一个value值
&lt;div class="hobbies"&gt; &lt;h2&gt;请选择你的爱好&lt;/h2&gt; &lt;label for="sing"&gt; &lt;input id="sing" type="checkbox" v-model="hobbies" value="sing" /&gt;唱 &lt;/label&gt; &lt;label for="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c4e04fe54e35a7024b29a5f12ae09a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c6b3545518dea37ef1d11ce842b0223/" rel="bookmark">
			Python语法之列表生成式的13个练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 列表生成式是Python内置的非常简单却强大的可以用来创建list的生成式。
Python 列表推导式是什么
列表推导式是 Python 语言特有的一种语法结构，也可以看成是 Python 中一种独特的数据处理方式，
它在 Python 中用于 转换 和 过滤 数据。
其语法格式如下所示，其中 [if 条件表达式] 可省略。
变量 = [表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]] variable = [out_exp for var in iterable if condition] 下面通过例题来对列表生成式进行深入的理解。
例题1：生成一个由1-10的平方组成的列表 列表元素分别为[1×1,2×2,3×3,…n×n]，假设n=10
常规方法
alist = [] for i in range(1, 11): alist.append(i * i) print(alist) # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 列表生成式
alist = [i * i for i in range(1, 11)] print(alist) # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 例题2：接着上一个需求，要求返回的序列中不存在偶数项 常规方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c6b3545518dea37ef1d11ce842b0223/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07898babb1ee5243127548ea80215a50/" rel="bookmark">
			软件设计师（3）--＞数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
数据库
一、三级模式两级映像
二、数据库的设计过程
三、ER模型
四、关系代数
五、规范化理论
六、并发控制
七、数据库完整性约束
八、数据库安全
九、数据备份
十、数据库故障与恢复
十一、数据仓库
3、数据仓库与数据库的对比​编辑十二、数据挖掘
十三、反规范化技术
十四、大数据技术
数据库 一、三级模式两级映像 &gt;三级模式结构：数据库系统的三级模式结构是指数据库系统是由外模式、模式和内模式三级构成。
①模式（schema）：
模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。它是数据库系统模式结构的中间层，既不涉及数据的物理存储细节，右与具体的应用程序、所使用的应用开发工具及高级程序设计语言无关。
模式实际上是数据库数据在逻辑上的视图。一个数据库只有一个模式。数据库模式以某一种数据模型为基础，同意综合地考虑了所有用户的需求，并将这些需求有机地结合成一个逻辑整体。定义模式时不仅要定义数据的逻辑结构，例如数据记录由哪些数据项构成，数据项的名字、类型、取值范围等；而且要定义数据之间的联系，定义与数据有关的安全性、完整性要求。
数据库管理系统提供模式数据定义语言（模式DDL）来严格地定义模式。
②外模式（external schema）：
外模式也称子模式（subschema）或用户模式，它是数据库用固话（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。
外模式通常是模式的子集。一个数据库可以有多个外模式。由于它是各个用户的数据视图，如果不同的用户在应用需求、看待数据的方式、对数据保密的要求等方面存在差异，则其外模式描述就是不同的。即使对模式中同一数据，在外模式的结构、类型、长度、保密等级等都可以不同。另一方面，同一外模式也可以为某一用户的多个应用系统所使用，但一个应用程序只能使用一个外模式。
外模式是保证数据库安全性的一个有力措施。每个用户只能看见和访问所对应的外模式中的数据，数据库中的其余数据是不可见的。
③内模式（internal schema）：
内模式也称存储模式（storage schema），一个数据库只有一个内模式。它是数据物理存储和存储方式的描述，是数据在数据库内部的组织方式。例如，记录的存储方式是堆存储还是按照某个（些）属性值的升（降）序存储，或按照属性值聚簇（cluster）存储；索引按照什么方式组织，是B+树索引还是hash索引；数据是否压缩存储，是否加密；数据的存储记录结构有何规定，如定长结构还是变长结构，一个记录不能跨物理页存储；等等。
&gt;数据库中的二级映像功能与数据独立性：
数据库系统的三级模式是数据的三个抽象级别，它把数据的具体祖冲之留给数据库管理系统管理，使用户能逻辑地、抽象地处理数据，而不必关心数据在计算机中的具体表示方式和存储方式。为了能够在系统内部实现这三个抽象层次的联系和转换，数据库管理系统在这三级模式之间提供了两层映像：外模式/模式映像和模式/内模式映像。
正式这两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。
①外模式/模式映像：
模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。对应于同一个模式可以有任意多个外模式。对于每一个外模式，数据库系统都会有一个外模式/模式映像，它定义了该外模式和模式之间的对应关系。这些映像定义通常包含在各自外模式的描述中。
当模式改变时（例如增加新的关系、新的属性、改变属性的数据类型等），由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变。应用程序是根据数据的外模式编写的，从而应用程序不用修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。
②模式/内模式映像：
数据库只有一个模式，也只有一个内模式，所以模式/内模式映像是唯一的，它定义了数据全局逻辑结构与存储结构之间的对应关系。例如，说明逻辑记录和字段在内部是如何表示的。该映像定义通常包含在模式描述中。当数据库的存储结构改变时（例如选用了另一种存储结构），由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变。保证了数据与程序之间的物理独立性，简称数据的物理独立性。
二、数据库的设计过程 数据库设计通常分为6个阶段：
①需求分析：分析用户的需求，包括数据、功能和性能需求；
②概念结构设计：主要采用E-R模型进行设计，包括画E-R图；
③逻辑结构设计：通过将E-R图转换成表，实现从E-R模型到关系模型的转换；
④数据库物理设计：主要是为所设计的数据库选择合适的存储结构和存取路径；
⑤数据库的实施：包括编程、测试和试运行；
⑥数据库运行与维护：系统的运行与数据库的日常维护。
三、ER模型 ER图分为实体、属性、关系三个核心部分。实体是长方形体现，而属性则是椭圆形，关系为菱形。
ER图的实体（entity）即数据模型中的数据对象，例如人、学生、音乐都可以作为一个数据对象，用长方体来表示，每个实体都有自己的实体成员（entity member）或者说实体对象（entity instance），例如学生实体里包括张三、李四等，实体成员（entity member）/实体实例（entity instance） 不需要出现在ER图中。
ER图的属性（attribute）即数据对象所具有的属性，例如学生具有姓名、学号、年级等属性，用椭圆形表示，属性分为唯一属性（ unique attribute）和非唯一属性，唯一属性指的是唯一可用来标识该实体实例或者成员的属性，用下划线表示，一般来讲实体都至少有一个唯一属性。
ER图的关系（relationship）用来表现数据对象与数据对象之间的联系，例如学生的实体和成绩表的实体之间有一定的联系，每个学生都有自己的成绩表，这就是一种关系，关系用菱形来表示。
ER图中关联关系有三种：
1对1（1:1） ：1对1关系是指对于实体集A与实体集B，A中的每一个实体至多与B中一个实体有关系；反之，在实体集B中的每个实体至多与实体集A中一个实体有关系。
1对多（1:N） ：1对多关系是指实体集A与实体集B中至少有N(N&gt;0)个实体有关系；并且实体集B中每一个实体至多与实体集A中一个实体有关系。
多对多（M:N） ：多对多关系是指实体集A中的每一个实体与实体集B中至少有M(M&gt;0)个实体有关系，并且实体集B中的每一个实体与实体集A中的至少N（N&gt;0）个实体有关系。
&gt;ER模型转换关系模式
①一对一关系的转换
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07898babb1ee5243127548ea80215a50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c7316cbcc66335ab8590139f6422333/" rel="bookmark">
			python 小例题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Python 其实我平时几乎不用 ，前几天一个高中同学让我帮他做 他们的实验报告，我重新捡起两年前的 Python 题目一 PS :题目一太简单了 ，仅做展示
题目二 传送门： Python：整数四则运算及格式化输出
题目三 传送门：Python：猜数字
题目四 传送门：Python：货币转换
题目五 传送门：Python：使用 turtle 库，绘制一个八角图形。
总目录 传送门： 题目二： Python：整数四则运算及格式化输出
题目三： Python：猜数字
题目四： Python：货币转换 题目五： Python：使用 turtle 库，绘制一个八角图形。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6a0635792bfb4f7d2fa528c75d32d3f/" rel="bookmark">
			pycharm中cv2无法自动补全（简单解决方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 问题cv配置问题解决 问题 初次接触pycharm用其学习python，发现配置opencv后没法自动补全，网上搜了很多博客，要么没效果，要么没搞清楚写的什么，记录一下
cv配置 1. file-&gt;settings-&gt;project: pythontest-&gt;python interpreter
2. 点上面的加号，输入opencv-python进行安装
问题解决 在当前项目中寻找cv2.pyd文件
D:\package\python\pythontest\venv\Lib\site-packages\cv2\cv2.pyd
4.将该文件复到你的.py文件所在目录下即可
5.现在就能补全了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9311e377b175cfc0d8d0e9d0ebcac629/" rel="bookmark">
			pip安装及matplotlib安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、pip安装
首先，找到安装python的文件夹，接着打开文件夹里的Scripts文件夹，打开Scripts文件夹并复制该路径。如下图：
右键单机此电脑图标，点击属性，找到高级系统设置。如下图：
点击其中的环境变量。如下图：
找到系统变量下的Path，并点击编辑。如下图：
将之前复制的路径粘贴（新建）上去。如下图：
再一路点确定以关闭所有框。
之后win+R，输入cmd打开命令行窗口，再输入pip或pip3看会不会报错。（不报错就是pip安装成功了。）
如果按照这个方法还报错的话，可以把Scripts文件夹下的pip文件双击打开一次，应该就不会报错了。
2、matplotlib安装
pip安装成功后就可以安装matplotlib了。我在网上找到一种较为简单的方法，我也是通过这个方法安装成功的。
首先，在命令行窗口输入如下代码：
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple matplotlib
如果回车后看到出现几个动态进度条就是成功了，等到命令行窗口不动了就可以关掉它了。
之后可以在python的编译器里输入如下代码：
import matplotlib
print(matplotlib.version)
如果返回的是matplotlib的版本号就是成功了。如下图：
参考资料：https://www.bilibili.com/video/BV14h411R7bZ?spm_id_from=333.337.search-card.all.click&amp;vd_source=42f6dab2a5ec090782e25abde2b846d6
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a2464e305e4b1599e3eea055d0baa2f/" rel="bookmark">
			Python：猜数字 （输入一个数字，打印比较的结果：“猜错了”、“猜对了”、“答对了”）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目三 代码 answer = 88 while True: your_answer = int(input("请输入你的答案：")) if your_answer &gt; answer: print("太大了") elif your_answer &lt; answer: print("太小了") else: print("答对了") break 运行结果 传送门 ：题目总目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56b3604fe083cd747cc72aede4092f61/" rel="bookmark">
			Python：使用 turtle 库，绘制一个八角图形。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目五 代码 import turtle as t t.setup(500,500) t.pensize(5) t.pencolor('black') t.pu() t.goto(-150,-100) t.pd() t.fd(300) for i in range(7): t.left(135) t.fd(300) t.done() 运行结果 传送门 ： 题目总目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad7aa7b18e6612dc236182e7c44dc01/" rel="bookmark">
			Python：货币转换（写一个程序进行人民币和美元货币之间的币值转换）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目四 代码 n = input('请输入带有标志(RMB,USD)的钱数:') if n[:3] in ['RMB']: u = eval(n[3:]) / 6.78 print("USD{:.2f}".format(u)) elif n[:3] in ['USD']: r = 6.78 * eval(n[3:]) print("RMB{:.2f}".format(r)) 运行结果 传送门: 题目总目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60345df5a926d4f6b41e4928c9a7a742/" rel="bookmark">
			Python：整数四则运算及格式化输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目二 代码 a = int(input('输入第一个数：')) b = int(input('输入第二个数：')) num1 = a + b num2 = a - b num3 = a * b num4 = a / b print('{} + {} = {}'.format(a, b, num1)) print('{} - {} = {}'.format(a, b, num2)) print('{} * {} = {}'.format(a, b, num3)) print('{} / {} = {}'.format(a, b, num4)) 运行结果 传送门 ：题目总目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36e98daf38d8873e668aea15afb6b1a0/" rel="bookmark">
			OpenGL-光照
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 光照模型建立 OPenGL处理光照采用的是一种近似： 把光照系统分为三部分： 光源、材质和光照环境。 光源： 光的来源 材质：指接受光照的各种物体的表面，由于物体如何反射光线只有物体表面决定 材质特点就决定了物体反射光线的特点。 光照环境：是指一些额外的参数，它们将影响最终的光照画面。 比如一些光线经过多次反射后，已经无法分清它究竟是由哪个光源发出，这 时指定一个环境亮度参数，可以使最后形成的画面更接近真实情况。 2. 法线向量 OpenGL中，法线方向是用一个向量表示。 为了实现光照效果，则需要在代码中为每个顶点指定其法线向量。 在指定法线向量时，只需要指定每一个顶点的法线向量，OpenGL会自行计算顶点 之间的其他点的法线向量，并且，法相向量一旦被指定，除非再指定新的法线向量 ，否则以后指定的所有点都将以这一向量作为自己的法线向量。 glColor* 函数用于指定颜色 glNormal* 函数则可以指定法线向量 注意：使用glTranslate* 函数 或者glRotate* 函数可以改变物体的外观，但是法线向 量并不会随之改变。 使用glScale* 函数，对每一坐标进行不同程度缩放，很有可能导致法线向量不 正确，所以应该尽量避免使用glScale* 函数，即使使用，最好保证各坐标等比例 缩放。 3. 控制光源 OpenGL中，支持有限数量光源。 至少会支持8个光源 GL_LIGHT0 0号光源 GL_LIGHT1 1号光源 ... GL_LIGHT7 7号光源 glEnable 函数用于开启它们。 例如： glEnable(GL_LIGHT0); 表示开启0号光源 glDisable 函数用于关闭光源。 每一个光源都可以设置其属性 这一动作是通过glLight* 函数完成的 该函数j具有三个参数 1. 指明是哪一个光源的属性 2. 指明设置该光源的哪一个属性 3. 指明该属性的值设置为多少 （1）GL_AMBIENT、GL_DIFFUSE、GL_SPECULAR 属性表示了光源所发出的 光的反射特性，每个属性由四个值表示，分别代表了颜色的RGBA值。 GL_AMBIENT 表示该光源所发出的光，经过非常多次的反射后，最终 遗留在整个光照环境中的强度。 GL_DIFFUSE 表示该光源所发出的光，照射到粗糙表面时经过漫反射，所 得到的光照强度。 GL_SPECULAR 表示该光源所发出的光，照射到光滑表面时经过镜面反射， 所得到的光的强度。 （2）GL_POSITION 属性。表示光源所在的位置。由四个值（X, Y, Z, W）表示。 如果第四个值W为零，则表示光源位于无限远处，前三个值表示了它所在的 方向。这种光源成为方向性光源。 如果第四个值W不为零，则X/W, Y/W, Z/W 表示了光源的位置。这种光源称为 位置性光源。对于位置性光源，设置其位置与设置多边形顶点的方式相似， 可以使用各种矩阵变换函数：glTranslate*,glRotate* 注意：方向性光源在计算时比位置性光源快了不少，因此在视觉效果允许的 情况下，应该尽可能的使用方向性光源。 （3）GL_SPOT_DIRECTION、GL_SPOT_EXPONENT、GL_SPOT_CUTOFF 属 性。表示将光源作为聚光灯使用。只针对位置性光源有效。 GL_SPOT_DIRECTION 属性有三个值，表示一个向量，即光源发射的方向。 GL_SPOT_EXPONENT 属性只有一个值，表示聚光的程度。 为零表示光照范围内各个方向发射的光线强度相同。 为正数表示向中央集中，正对发射方向位置受更多光照，其他位置 受到较少光照，数值越大，聚光效果就越明显。 GL_SPOT_CUTOFF 属性也只有一个值，表示一个角度，它是光源发射光线 所覆盖角度的一半（如图），其取值范围在0 - 90之间	，也可以取 180 这个 特殊值。取值为 180 时表示光源发射光线覆盖 360 度，即不使用聚光灯，向 全周围发射。 （4）GL_CONSTANT_ATTENUATION、GL_LINEAR_ATTENUATION、 GL_QUADRATIC_ATTENUATION 属性。这三 个属性表示了光源所发出的光线的直线传播特性。 现实生活中 ，光线的强度随着距离的增加而减弱。 OpenGL 把这个减弱的趋势抽象成函数： 衰减因子 = 1 / (k1 + k2 * d + k3 * k3 * d) 其中 d 表示距离，光线的初始强度乘以衰减因子，就得到对应距离的光线 强度。 k1, k2, k3 分别就是 GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, GL_QUADRATIC_ATTENUATION。 通过设置这三个常 数，就可以控制光线在传播过程中的减弱趋势。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36e98daf38d8873e668aea15afb6b1a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c84a5646f8b80087b450cebec052ae42/" rel="bookmark">
			sv- typedef
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一个文件中多个类引用，一般是先定义被调用的类，
class class_0; endclass class class_1; class_0 cl_0; endclass 如果不想先定义被调用的类，sv 又没有类似c 的.h 文件存储类声明，编译时从上到下解析，就会遇到类未定义，sv 就使用tydef 来做声明，先通过编译。
typedef class class_0; class class_1; class_0 cl_0; endclass class class_0; endclass 同样可以解决互相调用的情况。
typedef class class_0; class class_1; class_0 cl_0; endclass class class_0; class_1 cl_1; endclass 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5ad0eab8330d6e562105a2fce023f80/" rel="bookmark">
			docker-harbor私有仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Docker Harbor概述1.Harbor 简介2.Harbor 的特性3.Harbor 的构成 二、Harbor部署1.部署Docker-Compose服务2.部署Hardor 服务3.启动Harbor4.使用Docker 命令在本地通过127.0.0.1来登陆和推送镜像，默认情况下，Registry服务器在80端口上侦听5.在其他客户端上传镜像6.重载Docker后重新登录Harbor，再登陆7.下载Harbor仓库中的tomcat镜像8.从公网下载nginx镜像，上传到我们的Harbor仓库中9.图形界面查看，在浏览器中的Harbor仓库中查看我们上传的Nginx镜像 一、Docker Harbor概述 1.Harbor 简介 Harbor 是 VMware 公司开源的企业级 Docker Registry 项目，其目标是帮助用户迅速搭建一个企业级的 Docker Registry 服务Harbor以 Docker 公司开源的 Registry 为基础，提供了图形管理 UI 、基于角色的访问控制(Role Based AccessControl) 、AD/LDAP 集成、以及审计日志(Auditlogging) 等企业用户需求的功能，同时还原生支持中文Harbor 的每个组件都是以 Docker 容器的形式构建的，使用 docker-compose 来对它进行部署。用于部署 Harbor 的 docker-compose 模板位于 harbor/docker-compose.yml 2.Harbor 的特性 1.基于角色控制：用户和仓库都是基于项目进行组织的，而用户在项目中可以拥有不同的权限2.基于镜像的复制策略：镜像可以在多个 Harbor 实例之间进行复制（同步）3.支持 LDAP/AD：Harbor 可以集成企业内部已有的 AD/LDAP（类似数据库的一张表），用于对已经存在的用户认证和管理4.镜像删除和垃圾回收：镜像可以被删除，也可以回收镜像占用的空间5.图形化用户界面：用户可以通过浏览器来浏览，搜索镜像仓库以及对项目进行管理6.审计管理：所有针对镜像仓库的操作都可以被记录追溯，用于审计管理7.支持 RESTful API：RESTful API 提供给管理员对于 Harbor 更多的操控, 使得与其它管理软件集成变得更容易8.Harbor和docker registry的关系：Harbor实质上是对docker registry做了封装，扩展了自己的业务模板 3.Harbor 的构成 Harbor 在架构上主要有 Proxy、Registry、Core services、Database（Harbor-db）、Logcollector（Harbor-log）、Job services 六个组件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5ad0eab8330d6e562105a2fce023f80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4054cf7c6d3b5e895b0f21d011777bb0/" rel="bookmark">
			React 学习笔记总结(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. React 简介2. React的核心工具库3. 实现一个React的实例4. React 两种创建虚拟DOM的方式5. 虚拟DOM 与 真实DOM的对比6. jsx语法规则7. jsx 实战练习8. React开发者工具 安装9. React 函数式组件10. js的类 相关知识11. React 类式组件12. 组件实例对象的三大核心属性 之 state 状态13. React中的 事件绑定14. js和React类方法的 this指向问题(重点！！)15. 解决类中this的指向问题15. setState的使用16. React类式组件的 构造器 、render以及方法调用次数17. React的 state简写方式 1. React 简介 React用于构建用户界面的JavaScript库。
React由FaceBook开发的，并且已经开源。
react的原理：
2. React的核心工具库 babel的作用：
将ES6语法转成ES5。jsx格式转成js格式。 react.development.js 和 react-dom.development.js文件的作用：
3. 实现一个React的实例 1.引入react的三个核心文件
注意：下面的顺序问题！ 2.创建虚拟DOM，将虚拟DOM渲染到页面。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;hello_react&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 准备好一个容器 --&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4054cf7c6d3b5e895b0f21d011777bb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aae4e56698ce0ab055192d966131370/" rel="bookmark">
			常见的优化算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的优化算法
文章目录 1. 梯度下降法（batch gradient densent BGD)2. 随机梯度下降法 (Stochastic gradient descent SGD)3. 小批量梯度下降 (Mini-batch gradient descent MBGD)4. 动量法5. AdaGrad6. RMSProp7. Adam 1. 梯度下降法（batch gradient densent BGD) 全局最优
每次迭代都需要把所有的样本都送入，这样的好处是每次迭代都顾及了全部的样本，做的是全局最优化。
2. 随机梯度下降法 (Stochastic gradient descent SGD) 随机的从样本中抽出一个样本进行梯度的更新
针对梯度下降法训练速度慢的缺点，提出了随机梯度下降算法，随机梯度下降算法是从样本中随机抽出一组，训练后按梯度更新一次，然后再抽取一组，再更新一次，在样本量极其大的情况下，可能不用训练完所有的样本就可以获得一个损失值在可接受范围之内的模型了。
3. 小批量梯度下降 (Mini-batch gradient descent MBGD) 找一波数据计算梯度，使用均值更新参数
SGD相对来说要快得多，但是也有存在问题，由于单个样本的训练可能带来很多噪声使得SGD并不是每次迭代都向着整体优化方向，因此在刚开始训练时可能收敛的很快，但是训练一段时间后就会变得很慢。在此基础上又提出了小批量梯度下降法，它是每次从样本中随机抽取一小批进行训练，而不是一组，这样既保证了效果又保证了速度。
4. 动量法 对梯度进行平滑处理，防止振幅过大
mini-batch SGD算法虽然这种算法能够带来很好的训练速度，但是在到达最优点的时候并不能够总是真正到达最优点，而是在最优点附近徘徊。
另一个缺点就是mini-batch SGD需要我们挑选一个合适的学习率，当我们采用小的学习率的时候，会导致网络在训练的时候收敛太慢；当我们采用大的学习率的时候，会导致在训练过程中优化的幅度跳过函数的范围，也就是跳过最优点。我们所希望的仅仅是网络在优化的时候网络的损失函数有一个很好的收敛速度同时又不至于摆动幅度太大。
所以Momentum优化器刚好可以解决我们所面临的问题，它主要是基于梯度的移动指数加权平均，对网络的参数进行平滑处理的，让梯度的摆动幅度变得更小。
v = 0.8 v − 0.2 Δ w , Δ w 表示前一次的梯度 v=0.8v-0.2\Delta w,\Delta w表示前一次的梯度 v=0.8v−0.2Δw,Δw表示前一次的梯度
w = w − α v , α 表示学习率 w=w-\alpha v,\alpha 表示学习率 w=w−αv,α表示学习率
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1aae4e56698ce0ab055192d966131370/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23edadba528a4bef16aa4fb2c72ba6c9/" rel="bookmark">
			Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出错显示 Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateInputException: Error resolving template [index], template might not exist or might not be accessible by any of the configured Template Resolvers] with root cause
ERROR 8176 --- [nio-9090-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateInputException: Error resolving template [index], template might not exist or might not be accessible by any of the configured Template Resolvers] with root cause org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23edadba528a4bef16aa4fb2c72ba6c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba473c93e96def34d1ae6541e9fcb61c/" rel="bookmark">
			Ubuntu18.04安装nvidia显卡驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu18.04安装nvidia显卡驱动 1.更新内核到最新2.firmware更新3.禁用nouveau4.查看适合自己的驱动5.安装对应的驱动6.检查驱动是否安装完成 1.更新内核到最新 点此下载
1）进入网站下载不带lowlatency的四个文件
2）在下载的文件夹位置打开终端，输入命令
sudo dpkg -i *.deb 安装成功显示“成功”或者“done”
2.firmware更新 1）点此下载最新的.tar.gz 版本（一般在最后）
2）解压缩下载的文件后进入解压缩后的文件目录，打开终端运行以下命令：
sudo make install 3）安装成功后显示如下
3.禁用nouveau 1）在终端输入命令
sudo gedit /etc/modprobe.d/blacklist.conf 2）在打开的文件最末输入命令
blacklist nouveau options nouveau modeset=0 3）重启
4.查看适合自己的驱动 打开终端输入以下命令可以查看
nvidia-detector 5.安装对应的驱动 在软件与更新里面附加驱动，选择上图查看的对应版本驱动
6.检查驱动是否安装完成 如下图显示对应显卡型号即安装成功
小新Air 14 plus 装 ubuntu18.04 屏幕亮度解决方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c094b6a68a0ed5f62b66cf4bece7af83/" rel="bookmark">
			51单片机的智能灯光控制系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.硬件设计 本设计主要由51单片机最小系统、红外热释电模块、光强度检测模块、继电器灯光控制模块和电源模块组成。
硬件框图如下：
二.设计功能 光敏电阻检测环境光的光线强度，然后通过比较器电路做比较，输出信号给单片机。通过红外热释电传感器检测周围人体信号。当检测到晚上光线暗又检测到人体信号时，单片机通过灯光控制电路控制220V白炽灯发光，如果2分钟没有人体信号或者光线强的时候，灯光控制电路关闭白炽灯，从而达到一个节能的效果。红外热释电传感器的检测范围5~7M。 三.设计原理图 智能灯光控制系统原理图由单片机最小系统、人体感应模块、关照强度模块、灯光控制模块、电源模块和灯泡组成。本系统采用了光敏电阻检测白天黑夜，红外热释电传感器感应人体信号，经过单片机分析处理后判断是否控制灯光亮灭情况，实现了室内无人或者关照充足时灯光自动光灯，有人到来且光照不足时自动开启灯光，如果光照度和人体感应都不满足时，单片机延时1分钟，关掉灯光。实现了一个节能的效果。原理图如图：
四.设计程序 void main(void) { int i,j; while(1) { if(Rsd == 1)Led = 0; //热释电指示灯 else Led = 1; if(Rsd == 1 &amp;&amp; Light == 0) { Ji_D_Qi = 0; // Led = 0; for(i=0;i&lt;TIMEMIN;i++) { for(j=0;j&lt;10;j++) //执行完一次一分钟 { DelayMs(1000); if(Rsd == 1)Led = 0; else Led = 1; } } // Led = 1; } else Ji_D_Qi = 1; //关闭继电器 } } 原理图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c094b6a68a0ed5f62b66cf4bece7af83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fecfd2aa58df1c8b0fabea5035dd6fc/" rel="bookmark">
			vue项目发布采用gzip压缩文件部署到nginx无法运行问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gzip压缩分为服务器压缩和前端文件压缩。应该二者结合，综合使用。
一、问题描述 有一个VUE项目，开发环境下，使用npm运行，一切正常，发布部署到nginx上一片空白。用谷歌浏览器进入开发者工具，提示什么“Uncaught SyntaxError: Unexpected token ‘&lt;’ ”
为什么会报这个错误呢？这与nginx的设置有关。
location / { root E:/订餐谁拿饭抓阄评估规划执行监控审计管理系统/code/web/dist;	index index.html index.htm; try_files $uri $uri/ /index.html; } 最后这一句，当出错的时候会强制跳转到 index.html 页面，而js文件不能识别html，因此报Uncaught SyntaxError: Unexpected token &lt; 错误。
更确切地说，是浏览器向服务器请求js文件，服务器报错了，依照nginx的设定，转跳到了index.html，即nginx向客户端返回了index.html的内容。而浏览器接收到这部分"javascript"内容后，无法解释，于是就报了“Uncaught SyntaxError: Unexpected token &lt;”的错。
为什么向服务器请求js文件会报错呢？原因是，在我们的发布包里，没有这些js文件，只有js文件的压缩包：
nginx应该是可以识别这些压缩包，能处理gzip，所以没有报404错误（如果将发布包部署到IIS，会报404错误），但不知道什么原因，nginx没有正确返回js内容，而是触发了异常。
二、vue的文件压缩处理 之所以我这个vue项目的发布文件，有*.gz文件，是因为配置文件vue.config.js中指定使用了压缩插件：
switch (process.env.NODE_ENV) { case "development": ... break; case "production"://vue3默认情况下，npm run build时，process.env.NODE_ENV==="production" ... WEBPACK_PLUGINS.push( new CompressionWebpackPlugin({ filename: "[path].gz[query]", algorithm: "gzip", test: new RegExp("\\.(" + productionGzipExtensions.join("|") + ")$"), threshold: 10240, minRatio: 0.8, deleteOriginalAssets: true,//删除压缩后的原文件 }) ); break; } 三、nginx的gzip设置 事实上，对于服务器来说，有2种应用gzip的途径。一是我们发布文件的时候，不做任何处理，由nginx在处理客户端请求时，将内容压缩返回；二就是我们发布压缩文件，nginx直接读取并返回给客户端。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fecfd2aa58df1c8b0fabea5035dd6fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca6eec99df474166aca78bae54ef14f3/" rel="bookmark">
			Django 多方式实现跨域访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是跨域 1.1 跨越介绍 跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。 这里说明一下，无法跨域是浏览器对于用户安全的考虑，如果自己写个没有同源策略的浏览器，完全不用考虑跨域问题了。
域可以理解为：协议 + 域名 + 端口号
在前后端不分离的项目中，前端使用ajax发起请求时，前端发起请求的域与后端定义API的域一致，故不会存在跨域问题在前后端分离的项目中，前端使用ajax或者axios发起请求，前后端各自运行在自己的域下，所以在发起请求的时候就会造成跨域，比如前端使用脚手架创建，运行在http://127.0.0.1:8080 后端运行在http://127.0.0.1:8000 端口，当前端发起请求时，因为域（端口不一致）不同，就会造成跨域，浏览器便会阻止该请求。 1.2 跨域分类 跨域请求分为2种，一种是简单请求，一种是复杂请求。
简单请求 只要同时满足以下两大条件，就属于简单请求 HTTP 方法是下列之一 - HEAD - GET - POST HTTP 头信息不超出以下几种字段 - Accept - Accept-Language - Content-Language - Last-Event-ID - Content-Type 只能是下列中的一个类型 application/x-www-from-urlencoded multipart/form-data text/plain 任何一个不满足上述要求的请求，即会被认为是复杂请求
复杂请求会先发出一个预请求，我们也叫预检，OPTIONS请求
二、同源策略 浏览器只阻止表单以及ajax请求，并不会阻止src请求，所以我们的cdn，图片等src请求都可以发~~
2.1 Ajax测试 当我们向后端发起GET请求时，后端没有做跨域访问。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"&gt;&lt;/script&gt; &lt;title&gt;跨域请求测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;button @click="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca6eec99df474166aca78bae54ef14f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/331612b24fcf44b587bd354fb1de8f4d/" rel="bookmark">
			JWT 快速入门，并实现登录认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、JWT 简介 jwt（JSON Web Tokens），是一种开发的行业标准 RFC 7519 ，用于安全的表示双方之间的声明。目前，jwt广泛应用在系统的用户认证方面，特别是现在前后端分离项目。
1.1 Jwt认证流程 前端用户填写好用户名和密码，点击登录后端对提交的用户名和密码进行校验，校验通过则发送token给前端前端将token保存在cookie中，并在每一次请求时都将cookie一并发送给后端后端对用户发送过来的token进行校验，并通过token识别是哪个用户。 1.2 session &amp; Token 区别 session
在django中，如果使用session进行认证，会在django_session表中存储用户登录记录，随着用户增加，数据库中的记录也会越来越多，增加了服务器压力
token
传统token
​ 用户登录成功后，服务端生成一个随机token给用户，并且在服务端(数据库或缓存)中保存一份token，以后用户再来访问时需携带token，服务端接收到token之后，去数据库或缓存中进行校验token的是否超时、是否合法。
jwt 形式
​ 用户登录成功后，服务端通过jwt生成一个随机token给用户（服务端无需保留token），以后用户再来访问时需携带token，服务端 接收到token之后，通过jwt对token进行校验是否超时、是否合法。
1.3 JWT 格式 jwt是一段由.（点）组成的三段式密文
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c 第一段称为头部（header）
头部存储了两部分信息，分别是类别和加密算法。加密算法通常使用sha256（这里指整体加密时采用的算法），将头部进行base64url编码得到一段内容
# 密文 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 # 解密 { "alg": "HS256", "typ": "JWT" } 第二段称为payload（载荷）
payload 里面包含用户有部分数据，比如用户id和用户名等。第二段内容也是通过base64url进行加密，所以内容中不能包含敏感数据
# 密文 eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ # 解密 { "sub": "1234567890", "name": "John Doe", "iat": 1516239022 } 第三段为签名（signature）
把前两段的base64url密文通过.拼接起来，并加入秘钥，然后对其（两段密文和盐）进行HS256加密（header中定义的类别），再然后对整体密文进行base64url加密，最终得到token的第三段。
base64url( HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), your-256-bit-secret (秘钥加盐) ) ) 二、PyJWT 使用 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/331612b24fcf44b587bd354fb1de8f4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f063d07855d074b0473b89168046784d/" rel="bookmark">
			Celery 基础入门，并实现异步发送邮件（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Celery 介绍 Celery 是一款非常简单、灵活、可靠的分布式系统，可用于处理大量消息，并且提供了一整套操作此系统的一系列工具。
Celery 是一款消息队列工具，可用于处理实时数据以及任务调度。
1.1 什么是任务队列 任务队列一般用于线程或计算机之间分配工作的一种机制。
任务队列的输入是一个称为任务的工作单元，有专门的职程（Worker）进行不断的监视任务队列，进行执行新的任务工作。
Celery 通过消息机制进行通信，通常使用中间人（Broker）作为客户端和职程（Worker）调节。启动一个任务，客户端向消息队列发送一条消息，然后中间人（Broker）将消息传递给一个职程（Worker），最后由职程（Worker）进行执行中间人（Broker）分配的任务。
Celery 可以有多个职程（Worker）和中间人（Broker），用来提高Celery的高可用性以及横向扩展能力。
1.2 中间人Broker是什么 Celery 需要一个中间件来进行接收和发送消息，通常以独立的服务形式出现，成为 消息中间人（Broker）
常见的中间人有：
RabbitMQRedis 1.3 Celery 特点 高可用
如果出现丢失连接或连接失败，职程（Worker）和客户端会自动重试，并且中间人通过 主/主 主/从 的方式来进行提高可用性。快速
单个 Celery 进行每分钟可以处理数以百万的任务，而且延迟仅为亚毫秒（使用 RabbitMQ、 librabbitmq 在优化过后）。灵活
Celery 的每个部分几乎都可以自定义扩展和单独使用，例如自定义连接池、序列化方式、压缩方式、日志记录方式、任务调度、生产者、消费者、中间人（Broker）等。 二、Celery 使用 2.1 安装 Celery 安装Celery pip install celery pip install eventlet # Windows平台下需要配合协程来执行任务 我们使用redis来作为中间人
pip install redis delay(arg, kwarg=value) 调用任务
需要调用我们创建的实例任务，可以通过 delay() 进行调用。
delay() 是 apply_async() 的快捷方法，可以更好的控制任务的执行（详情：调用任务：Calling Tasks）：&gt;&gt;&gt; from tasks import add &gt;&gt;&gt; add.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f063d07855d074b0473b89168046784d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/248491821eaaf5bd4819e391df5ef93d/" rel="bookmark">
			Quartus安装器件库方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Quartus安装器件库方法 Step1：下载器件库Step2：安装器件库Step3：完成 Step1：下载器件库 第一步需要下载好我们所安装的Quartus版本所对应支持的器件系列，比如我使用的是Quartus Prime 16.1 Standard版本，那么，需要到Intel官网下载Quartus Prime 16.1 Standard版本所支持的器件库。
由于Quartus Prime 16.1 Standard是个比较老的版本了，在Intel官网中相关的器件库已经下架了，那么可以网上搜索一下Quartus Prime 16.1 Standard的器件库，进行下载，下载完是.qdz格式的文件，我们可以将其放到一个固定路径下，一般放在Quartus的安装路径下，且路径中不能含中文路径。
Step2：安装器件库 第二步需要安装我们所下载的器件库，首先，以管理员身份运行Quartus（必须以管理员身份运行），然后依次点击：Tools -&gt; Install Devices…，如下图所示。
然后next
选择器件库的存放位置，点击next
然后可以看到在该文件夹中我们存储的哪些器件库，以我们这里为例，文件夹里面包含了Cyclone IV系列与Stratix IV两个系列的器件库，其中Cyclone IV系列器件库未安装，Stratix IV系列器件库已经安装，勾选yclone IV系列器件库，一路next进行安装。
安装完成
Step3：完成 然后关闭Quartus，重新启动Quartus建立工程就可以看见我们可以选择我们安装的器件系列了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9467d4bd5a37d978768b01171385cc44/" rel="bookmark">
			Android studio Dolphin海豚 properties乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天尝鲜，把Android Studio升级到了海豚版，突然发现local.properties和gradle.properties里的汉字出现乱码，百度了一圈也没有我想要的答案，后来受一篇博客的启发终于解决了properties乱码的问题。
直接上图！
底部的下拉菜单点开后，选中UTF-8，然后保存，问题解决了
如果本文对您有所帮助，麻烦点个赞，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5de8d6cd97a6ad3f8129bedfaeea550/" rel="bookmark">
			SD卡的驱动(linux操作系统下)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		emmc读写速度慢：是1线，还是4，8线，emmc和控制器本身支持的最高速率，还有dts的配置，cache（sync）是否有影响；回写，调度。
s3cmci_probe-&gt;mmc_alloc_host(mmc_rescan)-&gt;mmc_add_host-&gt;mmc_start_host-&gt;queue_delayed_work(system_freezable_wq, work, delay)-&gt;mmc_rescan-&gt;mmc_rescan_try_freq-&gt;mmc_attach_mmc-&gt;mmc_init_card，mmc_add_card-&gt;mmc_alloc_card-&gt;drv-&gt;probe(mmc_blk_probe)-&gt;mmc_blk_alloc-&gt;alloc_disk(perdev_minors),mmc_init_queue,add_disk-&gt;
block层：实现mmc为块设备，和块设备那套对接，实现并注册卡的驱动，加入到bus上。
core:抽象host,bus ,card实体，向底层提供便利的host要用的api。提供检测卡的插入，向bus注册sd卡。
host:提供并注册host驱动，实现host ops，用platform bus去match。
sd卡插入后的流程：中断检测总线上是否有卡，init card(standy_by),在bus上add card，找到driver match上，probe函数。
nandflash芯片
mmc 卡化
sd卡，比mmc在写保护，速率，容量
inand/emmc 电子产品越来越小，芯片比sd卡卡槽小巧，卡槽插拔次数多了接触不良。
inand/emmc sd卡芯片化，速率和接口，现在是8线io,支持1，4，8线传输模式，sd卡IO线，支持1，4线传输。自己完成ECC校验，不用代码来实现。sd卡内存有个卡的接口控制器，就相当于一个单片机。
形式上，这个部分和i2c非常相似
系统也是分成core层，host层（对应i2c的adapter），设备层
core层：主要功能应该是提供host注册，总线注册，设备注册的几个方法以及所谓sdio总线接口的算法了。
host层：已经是注册一个platform设备，其中应该提供主要sdio接口算法的实现。
设备层：应该是提供几个功能 1）注册块设备，映射到/dev下面的设备节点 2）应该还有设备其他信息。
Host层驱动，主要是填充mmc_host结构体相关内容和实现mmc_host_ops结构体中的函数。最后调用mmc_add_host向MMC core注册host驱动。可以参考S3C24XX的HOST驱动程序(drivers/mmc/host/s3cmci.c,s3cmci.h),上层MMC Core主要调用mmc_host_ops中的函数来实现与硬件交互。
MMC Core层。
该层主要实现了几个结构体函数指针，用来构建整个MMC设备驱动模型。它们是：
struct bus_type mmc_bus_type /*mmc总线，用来管理sd/mmc卡设备和驱动*/
struct mmc_bus_ops mmc_ops /*MMC卡总线操作函数，主要是在电源管理方面*/
struct mmc_bus_ops mmc_sd_op /*SD卡总线操作函数，主要是在电源管理方面*/
struct mmc_bus_ops mmc_sdio_ops /*SDIO总线操作函数，主要是在电源管理方面*/
struct bus_type sdio_bus_type /*SDIO另外定义了一条总线*/
core.c文件中实现了几个关键的函数，用来提供给上层MMC Card调用和对SD/MMC卡的侦测函数以及初始化。
供给上层MMC Card调用主要有：
void mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq);
int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5de8d6cd97a6ad3f8129bedfaeea550/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1907c9c6dd57ff492c226c3c74112ba6/" rel="bookmark">
			Vue/Nuxt框架开发的PC端网站兼容平板设备的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家做项目的时候有没有遇到过一些不符合常理的开发需求，例如：开发的时候PC端和H5是两套站点，一般H5站点会适配平板设备，但是如果需要改成PC端适配平板呢；前期开发PC端没有考虑到PC端会有需要兼容平板的一天，完犊子了，这可怎么办？PC端的站点的长宽单位都是px，写的固定长度；而且会有固定的版型（就是页面一般会有一个最小宽度，比如1200px，1280px，1380px这些不等），如果要重写自适应，恐怕劳力费时还不讨好，当我拿到这个需求时，内心是崩溃的，后来思考了下，也有办法处理，但是会引发另外一些问题，下面我们慢慢展开。
这个项目PC的版型1380px，也就是小于这个宽度将以横向滚动条展示内容；首先看下面的viewport配置： // nuxt.config.js meta: [ { name: "viewport", content: "width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" } ] 上面这个配置会在HTML页面生成一个meta标签，等同于原生下面配置：
&lt;meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt; 上面配置完了之后会禁止用户缩放页面，很奈斯。凡事有意外IOS系统高版本上不接受meta标签限制，那么就需要通过其他方式来禁用用户缩放，看下面一段脚本代码：
// methods: {} // 阻止IOS手动缩放 stopIOSScale() { // 阻止双击放大 let lastTouchEnd = 0; document.addEventListener('touchstart', function(event) { if (event.touches.length &gt; 1) { event.preventDefault(); } }); document.addEventListener('touchend', function(event) { let now = (new Date()).getTime(); if (now - lastTouchEnd &lt;= 300) { event.preventDefault(); } lastTouchEnd = now; }, false); // 阻止双指放大 document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1907c9c6dd57ff492c226c3c74112ba6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75f2a72a063268e54908a9b11c7d3ff9/" rel="bookmark">
			python数据分析预处理z-score标准化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、z-score标准化的python代码 import pandas from pandas import read_excel from sklearn import preprocessing dataset = read_excel('processing2.xlsx', header=0, index_col=0) values = dataset.values #dataframe转换为array数组类型 values = values.astype('float32') #定义数据类型 data = preprocessing.scale(values) df=pandas.DataFrame(data) #将array还原为dataframe df.columns=dataset.columns #命名标题行 df.to_excel ('processing3.xlsx',index=None) #另存为excel，删除索引 使用机器学习sklearn的scaler方法进行z- score标准化只需一行：
from sklearn import preprocessing
data = preprocessing.scale(values) #注意，这里的values是array
然后再加两步：将dataframe转化为array，以及将array还原为dataframe即可！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8807887f01af217218ee6d4c0c76b2be/" rel="bookmark">
			TensorRT 系列 （0）C&#43;&#43; API 构建编译网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TensorRT的核心在于对模型算子的优化（合并算子、利用GPU特性选择特定核函数等多种策略），通过tensorRT，能够在Nvidia系列GPU上获得最好的性能，因此tensorRT的模型需要在目标GPU上实际运行的方式选择最优算法和配置，也因此tensorRT生成的模型只能在特定条件下运行（依赖于编译的trt版本、cuda版本、编译时的GPU型号）。TensorRT提供的C++、Python接口用于直接构建网络结构，本次主要介绍C++接口实现网络的构建与模型的编译，当然TensorRT也可以实现由其它框架的模型直接进行转换，如下是TensorRT工作流：
如下是通过C++ API要实现的网络结构：
示例代码如下：
// tensorRT include #include &lt;NvInfer.h&gt; #include &lt;NvInferRuntime.h&gt; // cuda include #include &lt;cuda_runtime.h&gt; // system include #include &lt;stdio.h&gt; class TRTLogger : public nvinfer1::ILogger{ public: virtual void log(Severity severity, nvinfer1::AsciiChar const* msg) noexcept override{ if(severity &lt;= Severity::kVERBOSE){ printf("%d: %s\n", severity, msg); } } }; nvinfer1::Weights make_weights(float* ptr, int n){ nvinfer1::Weights w; w.count = n; w.type = nvinfer1::DataType::kFLOAT; w.values = ptr; return w; } int main(){ // 本代码主要实现一个最简单的神经网络 TRTLogger logger; // logger是必要的，用来捕捉warning和info等 // ----------------------------- 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8807887f01af217218ee6d4c0c76b2be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/465c453000395e3c8360dd6d6940044c/" rel="bookmark">
			IPC和RPC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IPC：（Inter Process Communication ）跨进程通信 这个概念泛指进程之间任何形式的通信行为，是个可以拿来到处套的术语。它不仅包括各种形式的消息传递，还可以指共享资源，以及同步对象[mutex 或者其他类似的东西，即确保安全的并发访问共享资源（也就是防止两个或两个以上的对象同事对同一个数据成员进行修改，从而导致数据被破坏，或者竞争条件下同事读/写数据而导致错误的情况发生）]的东西。
RPC:(Reomote Procedure Call) 远程过程调用 特指一种隐藏了过程调用时实际通信细节的IPC方法。客户端将调用一个本地方法，而这个本地方法则是负责透明的与远程服务端进行过程间通信。这个本地方法会讲相关参数顺序打包到一个消息中，然后把这个消息发送给服务端提供的方法，服务端的方法会从消息中解出序列化发出来的参数，然后执行，最后仍以同样的方式将方法的返回值发送给客户端。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6449026cbb2bf77025d5962aba229c48/" rel="bookmark">
			鸿蒙开发入门 | 开发第一个鸿蒙应用&#43;页面跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN话题挑战赛第2期
参赛话题：学习笔记
准备好鸿蒙开发环境后，接下来就需要创建鸿蒙项目，掌握项目的创建过程以及配置。项目创建好后，需要把项目运行在模拟器上，鸿蒙的模拟和安卓模拟器有些不同，鸿蒙提供远程模拟器和本地模拟器，通过登录华为账号登录在线模拟器，使用DevEco Studio可将项目部署到远程模拟器中。
分析 使用DevEco Studio集成工具开发第一个鸿蒙应用，完成鸿蒙应用创建、鸿蒙模拟器创建、部署应用到模拟器。
1、开发第一个鸿蒙应用 1●创建鸿蒙应用 打开DevEco Studio，在欢迎页单击Create HarmonyOS Project，创建一个新工程，如图1所示。
■ 图1 Create HarmonyOS Project
根据工程创建向导，选择需要的Ability工程模板，然后单击Next按钮。关于工程模板的介绍和支持的设备类型，请参考支持的设备模板和编程语言，如图2所示。
■ 图2工程创建向导
填写工程相关信息，Device Type选择Phone，其他保持默认值即可，单击Finish按钮，如图3所示。关于各个参数的详细介绍，请参考创建一个新的工程。
■ 图3 填写工程相关信息
工程创建完成后，DevEco Studio会自动进行工程的同步，同步成功如图4所示。
■图4 工程自动同步
2●部署鸿蒙应用到模拟器 DevEco Studio提供远程模拟器和本地模拟器，我们以远程模拟器为例进行说明。在DevEco Studio菜单栏，单击Tools→Device Manager，如图5所示。
■ 图5 打开设备管理器
在Remote Emulator页中单击Login按钮，在浏览器中弹出华为开发者联盟账号登录界面，请输入已实名认证的华为开发者联盟账号的用户名和密码进行登录(查看远程模拟器登录常见问题)，如图6所示。
■ 图6 登录华为开发者联盟账号
说明: 推荐使用Chrome浏览器，如果使用Safari、360等其他浏览器，要取消阻止跨站跟踪和阻止所有Cookie功能。
登录后，请单击界面上的“允许”按钮进行授权，如图7所示。
■ 图7 华为账号授权
在设备列表中，选择设备P40，并单击按钮
，运行模拟器，如图8所示。
■ 图8 运行模拟器
单击DevEco Studio工具栏中的按钮
运行工程，或使用默认快捷键Shift+F10运行工程，如图9所示。
■ 图9 运行工程到模拟器
DevEco Studio会启动应用的编译构建，完成后应用即可运行在模拟器上，如图10所示。
■ 图10 工程运行成功页面
2、实战演练——页面跳转 鸿蒙操作系统提供了两种FA(Feature Ability)的UI开发框架: Java UI框架和JS UI框架，如表1所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6449026cbb2bf77025d5962aba229c48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/048975eed07eddc53779e406f4c7efcd/" rel="bookmark">
			C语言 字母小写转换大写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt;
int main()
{
char ch;
scanf("%c", &amp;ch);
if (ch&gt;='a' &amp;&amp; ch&lt;='z')
{
ch=ch-32;
printf ("%c\n",ch);
}
else
printf ("%c\n",ch);
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c289418246d46b67c19607cfc0fa6be4/" rel="bookmark">
			Cloudreved云盘搭建及配置Aria2离线下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备 Ubuntu云服务器(已安装宝塔)，解析一个域名主机记录下载cloudreve_x.x.x_linux_amd64.tar.gz阅读Cloudreve文档 关于Cloudreved部署官方文档很清晰，文档和网上没什么资料，所以着重记录一下Aria2部署
安装Cloudreved 1.在防火墙中放行5212端口
2.将cloudreve_x.x.x_linux_amd64.tar.gz上传服务器/www/wwwroot/Cloudreve路径下(宝塔可以直接远程下载)
3.打开Shell工具
cd /www/wwwroot/Cloudreve	# 切换路径 tar -zxvf cloudreve_x.x.x_linux_amd64.tar.gz	# 解压缩 chmod +x ./cloudreve	# 赋权 ./cloudreve	# 启动 4.首次启动会显示账号密码，通过http://服务器IP:5212访问并登录，确认可以登录即可，Ctrl+C停止运行
绑定域名 1.在宝塔面板中绑定域名，新建一个数据库（数据库可以不创建，默认使用Cloudreve内置的 SQLite 数据库，并在同级目录创建数据库文件cloudreve.db）
2.设置反向代理，代理名称：cloudreve，目标URL：http://127.0.0.1:5212
3.添加数据库信息/www/wwwroot/Cloudreve/conf.ini，具体信息在宝塔面板导航-&gt;数据库
[Database] Type = mysql; 数据库类型，目前支持 sqlite | mysql User = xxxx; &lt;-用户名 Password = xxxx; &lt;-密码 Host = 127.0.0.1; 数据库地址 Name = xxxx; &lt;-数据库名称 TablePrefix = cd; 数据表前缀 4.再次启动，生成新的账号密码，通过域名访问
cd /www/wwwroot/Cloudreve	# 切换路径 ./cloudreve	# 启动 5.做一些基本的设置，如果是个人使用，关掉注册功能。之后增删改用户账号密码通过导航的用户设置。之后Ctrl+C停止运行
进程守护 什么是进程守护？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c289418246d46b67c19607cfc0fa6be4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36a2762fc81c22be080379a66baa4306/" rel="bookmark">
			实训九：三层交换机VLAN划分及VLAN间通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的
1、了解vlan的原理。
2、学会使用各种多层交换设备进行vlan的划分。
3、理解vlan之间通信的原理和实现方法。
二、应用环境
1、软件实验室的IP地址段是192.168.10.0/24，多媒体实验室的IP地址段是192.168.20.0/24.为了保证他们之间的数据互不干扰，也不影响各自通信的效率，我们划分了vlan，使两个实验室属于不同的vlan。
2、两个实验室有时候也需要相互通信，此时就要利用三层交换机划分vlan。
三、实验设备
1、神州数码DCN-CS6200 交换机 1 台
2、PC机 2 台
3、console线 1 根
4、直通网线 2 根
四、实验拓扑
提示：使用一台交换机和两台PC机，还将其中PC1作为控制台终端，使用console口配置方式，使用两根网线分别将PC1和PC2连接到交换机的RJ-45接口上。
五、实验要求
1、在交换机上划分两个基于端口的vlan100；vlan200
要求：vlan100的成员能够互相访问，vlan200的成员能够互相访问，vlan100和vlan200的成员之间不能互相访问。
2、PC1和PC2的网络设置为：
六、实验步骤
第一步：交换机恢复出厂设置。
CS6200-28X-EI#set default ！！清空当前配置 Are you sure? [Y/N] = y CS6200-28X-EI#write ！！保存当前配置 Sep 15 20:57:51:000 2022 CS6200-28X-EI MODULE_CONFIG_SHELL/3/:Switch configuration has been set default! NULL(factory config) will be used as the startup-config file at the next time! CS6200-28X-EI#reload ！！重启交换机 Process with reboot? [Y/N] y 第二步：给交换机设置IP地址即管理IP。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36a2762fc81c22be080379a66baa4306/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9925df89d78f68a8a96b39dbda69e4f6/" rel="bookmark">
			Clickhouse&amp;Mysql执行文件格式&amp;在线修改表结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 执行语句 clickhouse-client --user 用户名 --password 密码 -d 对应的数据库 --multiquery &lt; sql文件名.sql mysql -hip地址 -u用户 -p密码 --database 哪个数据库 &lt; sql文件名.sql 在线修改表结构 pt-online-schema-change工具使用 - --dry-run 就是预执行，主要的作用就是看会不会报错。
- --execute 实际执行，主要作用就是预执行以后没有报错的话实际操作。
- --no-drop-old-table 就是修改表的时候保留原始表数据情况。
例子
pt-online-schema-change --charset=utf8mb4 --recursion-method=none --no-drop-old-table --no-version-check --user=用户 --password=密码 --host=地址 P=3306,D='数据库',t=表结构 --alter "ADD COLUMN ceshi varchar(255) NULL" --dry-run 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/206/">«</a>
	<span class="pagination__item pagination__item--current">207/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/208/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>