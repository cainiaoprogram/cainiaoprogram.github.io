<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09abab63c81bf9351539026cf48474d7/" rel="bookmark">
			Docker实现Mysql读写分离（主从同步）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 Mysql读写分离主要是通过主从数据库复制来实现，Mysql自带的二进制复制技术；Mysql5.7与Mysql8操作稍有差别，Mysql8的授权模式有改动，需要先创建用户；实现主从同步后，使用MyCat等软件实现读写分离；使用Docker来模拟两台服务器，原理和使用2台不同IP的服务器一样； 安装Docker 下载Docker Desktop https://www.docker.com/get-started，这个是有图形界面的Docker，可以省去很多命令操作，对系统有一定要求；直接安装即可； 拉取mysql docker pull mysql:5.7 在Docker Hub查看版本，本文使用5.7版本 https://hub.docker.com/_/mysql?tab=tags
制作主从Mysql镜像 1. 任意位置创建2个文件夹，并分别创建Dockerfile和My.cnf Dockerfile – 打包配置文件My.cnf – Mysql配置文件，这里修改好以后替换Mysql原有文件，也可以打包以后进入容器修改，但是Docker原生没有Vim编辑，需要更新源安装，但是速度很慢； 2. 编写Dockerfile FROM mysql:5.7 COPY my.cnf /etc/mysql/ EXPOSE 3306 CMD ["mysqld"] master和slave相同mysql:5.7 – 不写版本号5.7会拉取最新版Mysql，最新版的授权有变化，需修改授权方式 3. 编写My.cnf master： [mysqld] pid-file = /var/run/mysqld/mysqld.pid socket = /var/run/mysqld/mysqld.sock datadir = /var/lib/mysql secure-file-priv= NULL # 新添加的在下面 #启用二进制，必须 log-bin=mysql-bin #填写整数，每个数据库不同 server-id=1 slave: [mysqld] pid-file = /var/run/mysqld/mysqld.pid socket = /var/run/mysqld/mysqld.sock datadir = /var/lib/mysql secure-file-priv= NULL # 新添加的在下面 #启用二进制，必须 log-bin=mysql-bin #填写整数，每个数据库不同 server-id=2 更多配置参考 server-id=1 #任意自然数n，只要保证两台MySQL主机不重复就可以了。 log-bin=mysql-bin #开启二进制日志 auto_increment_increment=2 #步进值auto_imcrement。一般有n台主MySQL就填n auto_increment_offset=1 #起始值。一般填第n台主MySQL。此时为第一台主MySQL binlog-ignore=mysql #忽略mysql库【我一般都不写】 binlog-ignore=information_schema #忽略information_schema库【我一般都不写】 replicate-do-db=aa #要同步的数据库，不填默认所有库 # 配置好后重启MySQL # https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09abab63c81bf9351539026cf48474d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9908c39cbae2c7176e131fafca524ea9/" rel="bookmark">
			Matlab（R2014a版本）一阶、二阶系统响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PART1：一阶系统响应
1.1阶跃响应
num=1 den=[1 1] g=tf(num,den) 直接输入系统传递函数（时域函数经拉普拉斯变换后在s域的函数）的系数。num为分子系数，den为分母系数，从左至右依次为最高次项至最低次项的系数。
上述代码生成的传递函数（输入连续时间信号）显示在命令行窗口：
使用函数step()求阶跃响应（Step Respond）
step(g) 直接显示图象
响应性质待补充。一阶响应几乎没有震荡，很快到达稳态，与直流响应重合。
改变分母系数
右上角的图例中，英文代表着传递函数一次项的系数，从上到下依次是1、2、4、6、8，随着一次项系数增加，到达稳态所需时间变长
1.2脉冲响应
方法一：
首先生成脉冲信号
imp = [1; zeros(49,1)]; 信号在t=1处产生脉冲，其余时间为0，图像如下
使用滤波器函数filter产生传递函数后输入脉冲信号
num=1 den=[1 1] h=filter(num, den, imp); stem(0:49,h) 图像是离散的，如下
方法二：
无需生成信号，直接用滤波器模拟函数fvtool()
num=1 den=[1 -0.9] one=tf(num,den) fvtool(num,den) 在上方的工具栏选项中有脉冲响应的选项
以上两个图象都是离散信号（discrete signal）的图象（暂未明白x-axis的意义），用impulse()函数可以求频率响应的时域图象。
以后所有系统都只讨论连续信号的响应。
impulse(one) 单极点系统（一阶系统）的极点在左半平面时，脉冲响应随时间衰减。都是稳定的。
改变分母一次项的大小（1、2、4、6、8）
一次项系数变大，衰减变慢，响应变慢。
1.3当分母的常数项变成负数（其余不变）
极点变成右半平面，位于实轴。
阶跃响应（Step Respond）图象
指数增长，不稳定
冲激响应（Impulse response）图象
指数增长，不稳定，极点距离虚轴越远（分母一次项系数越大），响应越慢。
1.4极点位于原点
此处考虑系统传递函数为1/s的情况
num=1 den=[1 0] one=tf(num,den) 阶跃响应
时间函数就是正比例函数，unbounded，输入有界的情况下输出无界，系统不稳定
冲激响应
这是阶跃函数的图象
PART2：二阶系统响应
2.1系统的两个极点分别在正实轴和负实轴，均为一阶
num=[2 5] den=[1 1 -1] 系统传递函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9908c39cbae2c7176e131fafca524ea9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8250b2cd8e08a0deee2c65436e4698f/" rel="bookmark">
			认识计算机-JavaEE初阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、计算机的发展史二、冯诺依曼体系（Von Neumann Architecture）三、CPU基本工作流程3.1 算术逻辑单元（ALU）3.2 寄存器（Register)和内存（RAM）3.3 控制单元（CU）3.4 CPU基本工作流程 四、编程语言（Program Language）4.1 程序（Program）4.2 编程语言的发展 五、操作系统（Operating System）5.1 操作系统的概念5.2 什么是进程 / 任务（Process / Task）5.3 CPU分配----进程调度（Process Scheduling）5.4 内存分配-----内存管理（Memory Manage）5.5 进程间的通信 前言： 随着时代发展，互联网的兴起，计算机已经普及到了家家户户，可以说每个人都对计算机并不陌生，但我们是否真正了解计算机呢？接下来简单介绍一下有关计算机的知识。 一、计算机的发展史 计算的需求在⼈类的历史中是⼴泛存在的，发展⼤体经历了从⼀般计算⼯具到机械计算机到⽬前的电⼦计算机的发展历程。
计算机的发展史可以追溯到古代使用计算工具时期。然而，现代计算机的起源可以追溯到20世纪初的一系列重要发明和创新。以下是一些关键的里程碑事件：
1837年，英国数学家查尔斯·巴贝奇设计了一台名为分析引擎（Analytical Engine）的机械计算器，被视为世界上第一台计算机的雏形。
1936年，数学家阿兰·图灵提出了通用图灵机的概念，奠定了计算机理论的基础，并对计算机科学做出了重大贡献。
1940年代中期，康奈尔大学的维尔纳·冯·布劳恩（Von Neumann）教授提出了存储程序原理，即将指令和数据存储在同一内存中，这成为现代计算机架构的基础。
1946年，世界上第一台电子管计算机ENIAC诞生于美国宾夕法尼亚大学，它是一个巨大的机器，主要用于军事计算。
1951年，第一台商业计算机UNIVAC I问世，成为世界上第一台投入商业应用的计算机。
1960年代，计算机开始出现集成电路技术的应用，这使得计算机变得更小、更快、更强大，并且成本更低。
1970年代，个人计算机（PC）开始出现，苹果公司和微软成为该领域的主要开拓者。
1980年代和1990年代，计算机网络和因特网的发展使得计算机得以连接并共享资源，促进了信息时代的到来。
在过去几十年里，计算机技术迅速发展，从大型机、小型机、个人计算机到移动设备和云计算等新兴领域的不断创新。
⼈类对计算的需求，驱动我们不断的发明、改善计算机。⽬前这个时代是“电⼦计算机”的时代，发展的潮流是：更快速、更稳定、更微型。
二、冯诺依曼体系（Von Neumann Architecture） 现代的计算机，⼤多遵守冯诺依曼体系结构：
CPU 中央处理器：进行算术运算和逻辑判断存储器：分为外存和内存，用于存储数据（用二进制方式存储）输入设备：用户给计算机发号施令的设备输出设备：计算机向用户汇报结果的设备 对于存储空间大小：硬盘 &gt; 内存 &gt;&gt; CPU
对于数据访问速度：CPU &gt; 内存 &gt; 硬盘
认识计算机之父–冯诺依曼
冯·诺依曼（John von Neumann，1903年12⽉28⽇-1957年2⽉8⽇），美籍匈⽛利数学家、计算机科学家、物理学家，是20世纪最重要的数学家之⼀。冯·诺依曼是布达佩斯⼤学数学博⼠，在现代计算机、博弈论、核武器和⽣化武器等领域内的科学全才之⼀，被后⼈称为“现代计算机之⽗”、“博弈论之⽗”。
三、CPU基本工作流程 CPU（中央处理器Center Process Unit）由运算器（ALU）、控制器（CU）、寄存器、时钟组成。
3.1 算术逻辑单元（ALU） ALU 算术逻辑单元（Arithmetic&amp;logical Unit）：是中央处理器(CPU)的执行单元，是所有中央处理器的核心组成部分,是计算机的数学大脑，由"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8250b2cd8e08a0deee2c65436e4698f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5bbbc310e168380b75b78387e8c578c/" rel="bookmark">
			ReadTimeoutError问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用pip install 安装库时遇到ReadTimeoutError
当使用pip安装时，经常速度很慢，而且保持很慢速度下载到最后突然这种情况实在很让人崩溃：
解决方法：
将
pip install 所要安装的库 换成
pip --default-timeout=1000 install -U 所要安装的库 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/093658d2301711c9366d327f4feb2849/" rel="bookmark">
			【阿里规约】阿里开发手册解读——代码格式篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导航：
【Java笔记+踩坑汇总】Java基础+JavaWeb+SSM+SpringBoot+SpringCloud+瑞吉外卖/黑马旅游/谷粒商城/学成在线+设计模式+面试题汇总+性能调优/架构设计+源码
阿里规约PDF：
阿里巴巴开发手册.pdf
目录
一、编码和换行符
二、空格规范
2.1 保留字
2.2 二目、三目运算符 2.3 缩进
2.4 注释
2.5 强制转换
2.6 方法参数
三、行数、字符数
3.1 单行字符数
3.2 方法行数
四、括号
4.1 大括号换行规则
3.2 小括号规则
一、编码和换行符 规范：代码的编码统一使用UTF-8，换行符使用 Unix 格式，不要使用 Windows 格式。
换行符：
Unix格式：在Unix、Linux以及类Unix操作系统中，使用换行符\n来表示新行，这是常用的行结束符。
Windows格式：在Windows操作系统中，通常使用回车符和换行符\r\n（CR-LF，Carriage Return-Line Feed）来表示新行。
IDEA设置编码为UTF-8：
二、空格规范 2.1 保留字 规范：if/for/while/switch/do 等保留字与括号之间都必须加空格。 正例（添加空格）：
if (condition) { // 代码逻辑 } for (int i = 0; i &lt; 10; i++) { // 循环体 } while (condition) { // 循环体 } switch (value) { case 1: // 情况1的代码 break; default: // 默认情况的代码 } 反例（不添加空格）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/093658d2301711c9366d327f4feb2849/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0682655df39bac7bc79bbc10cb5f7fc4/" rel="bookmark">
			Python语音合成探究（五、男声和女声选择的终极解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在《Python语音合成探究（一、男声和女声的选择）》文章中介绍了声音的选择，但有些朋友还是不能成功。我想，Win10中，在“调整时间”--“设置”--“语音”中，能预听各类语音的实际效果（但并一定保证你在python中正常使用，具体原因及解决方法参看《Python语音合成探究（一、男声和女声的选择）》文章），我何不写一段代码，也实现这样的功能呢？
import re import sys, os import pyttsx3 import win32com.client as wincl import chardet from pathlib import Path def audition(): # 创建对象 engine = pyttsx3.init() # 获取当前语音速率 rate = engine.getProperty('rate') # print(f'语音速率：{rate}') # 设置新的语音速率 engine.setProperty('rate', 150) # 获取当前语音音量 volume = engine.getProperty('volume') # print(f'语音音量：{volume}') # 设置新的语音音量，音量最小为 0，最大为 1 engine.setProperty('volume', 1.0) # 获取当前语音声音的详细信息，并试听语音 voices = engine.getProperty('voices') # 從語音信息是提取機器人姓名並試音 v = 0 # 语音索引号 for voice in voices: # print(f'语音声音详细信息：{voice}') # print(type(voice)) # str1 = str(voice)[82:100] str1 = str(voice)[100:140].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0682655df39bac7bc79bbc10cb5f7fc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34043079d11676360d7a321be32c2191/" rel="bookmark">
			electron学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Electron概述 1、Electron概念 Electron是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入 Chromium 和 Node.js 到 二进制的 Electron 允许您保持一个 JavaScript 代码代码库并创建 在Windows上运行的跨平台应用 macOS和Linux——不需要本地开发 经验。
2、Electron的优势和特点 2.1低门槛的学习曲线 Electron使用JavaScript和Web技术进行开发，这使得它的学习曲线相对较低。对于已经熟悉JavaScript的开发者来说，掌握Electron的开发技术和工具并不难，可以更快地上手并进行应用程序的开发。
2.2跨平台特性 Electron能够实现跨平台的应用程序开发，无论是在Windows、macOS还是Linux平台上，都可以构建出相同的应用程序。这大大简化了开发工作，减少了开发团队的工作量，并且具备更广泛的应用和推广范围。
2.3丰富的生态系统 Electron拥有庞大的社区和丰富的生态系统，开发者可以轻松地找到各种插件、工具和资源来辅助开发工作。
2.4灵活的界面设计 Electron中使用HTML和CSS来进行界面的设计和布局，这使得开发者可以利用Web前端技术的优势创建美观而且高度可定制的用户界面。
二、Electron 项目开发实践 1、环境准备 1.1 Node.js 环境 nodejs 版本选择最新的LTS版本，也就是 v18.18.2
1.2 安装 Electron 安装 Electron 是入门前比较麻烦的一步，主要是因为国内的网络问题，解决方案有两种
使用国内代理使用科学上网网上下载node包，修改源代码 使用代理 npm install -g cnpm --registry=https://registry.npmmirror.com cnpm i electron 科学上网 开启科学上网直接运行命令
npm i electron 修改源码 官方给了下载地址和具体步骤
[https://github.com/electron/electron/releases]
亲测这个方法在electron 11.2.0之前可以用，后续版本虽然显示的是安装成功，但程序运行时报错。 在开启了科学上网的情况下，仍然不能安装成功，这就要区分公司网络和家庭网络，大部分公司内部网络本身就有代理，所以导致即使按照上面的操作也无法安装成功，这时候把切换到手机热点再去安装就可以了。 3、初始化项目 3.1 初始化项目结构 使用npm init 命令初始化 package.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34043079d11676360d7a321be32c2191/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64b4e216c61b20640ac8501281a62402/" rel="bookmark">
			Matter学习笔记（1）——基本概念和架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 Matter（以前称为 Project Connected Home over IP 或 Project CHIP）是一个 开源应用层协议，向下屏蔽了设备制造商的生态和系统，旨在创建跨智能家居设备、移动应用程序和云服务的统一通信标准。它支持多种现有技术，包括 以太网、Wi-Fi、Thread 和低功耗蓝牙 (BLE)，并使用 TCP 和 UDP 等基于 IPv6 的传输协议来确保不同类型网络之间的连接。
Matter 由 开源 SDK（https://github.com/project-chip）实现，该 SDK 不仅包含规范的实现，还包含一套丰富的示例和互操作代码。核心 Matter 协议适用于 OSI 环境的前三层，这意味着它支持任何类型的 IPv6 传输和网络运行。虽然通过 IPv6 进行控制和其他操作通信，但可能会采用 Bluetooth 低功耗 (BLE) 来调试新设备1。
Matter 既灵活，又可以互操作。它基于低功耗 802.15.4 网络以及 Wi-Fi 智能家居设备的多年挑战和成功经验。与 Thread 类似，Matter 基于 IPv6 构建。它提供强大的加密功能、明确定义的设备类型及其数据建模，以及对多个生态系统管理员的支持。
Matter还支持其他智能家居技术的桥接，（例如 Zigbee、Bluetooth Mesh 和 Z-Wave）。这意味着基于这些协议的设备可以通过桥接器操作，桥接器是 Matter 网络和其他桥接的物联网技术的成员设备。桥接器有双重优势。使用其他协议的设备可以访问面向本机 Matter 设备的技术和生态系统。与此同时，Matter 将利用具有大规模已安装用户群体的成熟技术，创建一个真正连接的事物网络。
二、Matter协议架构 Matter 应用层可以分为几个主要组件。
在最底层，Matter 协议栈与传输层交互。有效数据包在发送设备上沿着协议栈向下流动，在接收设备上沿着协议栈向上流动。
2.1 应用程序 应用程序层定义给定最终产品的业务逻辑。例如，对于照明的应用程序可能包含处理打开/关闭灯泡及其颜色特征的逻辑。对于门锁应用程序，业务逻辑可以根据来自特定虚拟助理技术的语音命令来打开和关闭特定模型的门栓。它还可以定义来自特定 PIN 键盘 UI 的输入、门栓模型上特定 LED 的反应等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64b4e216c61b20640ac8501281a62402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cea8a6bfaf33734fd79e9cf92c2c7cab/" rel="bookmark">
			【Ruoyi管理后台】用户登录强制修改密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期有个需求，就是需要调整Ruoyi管理后台：用户如果三个月(长时间)未修改过密码，需要在登录时强制修改密码，否则不能登录系统。
一、后端项目调整 从需求来看，我们需要在用户表增加一个字段，用于标记用户最近一次修改密码的时间。
1.调整表结构 1）用户表 sys_user 加入 pwd_time 字段
每次更新密码时，都需要更新为当前系统时间。
2）调整对应的xml映射文件 SysUserMapper.xml
3）调整对应的实体对象 SysUser
同时加入对应的 get/set 方法。
2.调整登录接口 为什么要在登录接口这个地方调整，是因为后面的重置密码接口是需要登录后的 token 才能够调用成功，否则会提示登录已过期。
1）SysLoginService
加入判断用户是否已超过三个月没修改过密码
public boolean isPwdExpire(String username) { SysUser sysUser = userService.selectUserByUserName(username); Date pwdTime = sysUser.getPwdTime(); LocalDate pwdDate = pwdTime.toInstant().atZone(ZoneId.systemDefault()).toLocalDate(); // 获取当前日期 LocalDate currentDate = LocalDate.now(); // 计算日期差异 Period period = Period.between(pwdDate, currentDate); // 检查月份差异是否大于等于三个月 if (period.toTotalMonths() &gt;= 3) { return true; } return false; } 2）SysLoginController
在 login 方法内，加入上面的方法判断
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cea8a6bfaf33734fd79e9cf92c2c7cab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91bdc892cad704b7f0005c3d0ba0ed80/" rel="bookmark">
			如何安装ubuntu虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 更多软件安装 详见&gt;&gt;
常用开发软件安装 目录导航帖
1 所需材料 我们前往清华大学开源镜像网站，搜索找到ubuntu
点击ubuntu-releases选项：
点击黄色标记的iso镜像并下载，这样我们就有了ubuntu的镜像文件！
2 安装步骤 接下来开始正式安装Ubuntu系统，首先打开安装好的MVware Workstations Pro 16，如果还未安装此软件，请点击如何安装MVware Workstations Pro 16，按照教程的步骤完成安装
点击创建新的虚拟机（黄色标记）：
选择“自定义”（这里的目的是可自由分配虚拟机的核数、内存和硬盘空间），点击下一步：
点击下一步：
点击“浏览”，将所需材料中下载好的镜像文件加载进来，点击下一步：
设置虚拟机的用户信息：
虚拟机的名称自己定义，会显示在MVWare的左侧虚拟机名称栏目里
用户名和密码是虚拟机内ubuntu操作系统的用户名和密码，需要记住！（以后sudo权限就靠它了）
点击下一步
点击下一步
设置处理器以及内核数量（根据自己的电脑配置来设置，双核双线程可满足大部分实验需求），设置完点击下一步
设置内存大小，一般为主机内存的1/4-1/2最佳（比如64GB内存，虚拟机设置16GB），设置完点击下一步：
NAT或者桥接都是可以的，这里直接用NAT网络，点击下一步
默认选项即可，点击下一步
默认选项即可，点击下一步
点击下一步
磁盘空间根据电脑硬盘剩余大小设置，一般设置20-100GB都是可以的，点击下一步
默认选项即可，点击下一步
点击完成
此时，ubuntu虚拟机正在自动安装中，等待安装结束即可
安装结束，输入用户名密码即可登录系统了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f02412a26d5d26cd56ad08ed196f26e/" rel="bookmark">
			元宇宙是否为噱头？若不是，什么是元宇宙？他的概念、技术、应用和影响是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章来源：元宇宙的概念、技术、应用与影响——一项系统性文献综述 - 中国知网 (cnki.net)
摘要 [目的/意义]系统综述与分析当前国内外的元宇宙研究现状，有利于准确把握元宇宙发展方向，强化元宇宙基础研究，争取元宇宙建构权。[方法/过程]运用PRISMA方法，以Web of Science、ScienceDirect、SpringerLink、GoogleScholar、中国知网、万方和百度学术数据库中收集的262篇元宇宙主题论文为研究对象，梳理并回答元宇宙的概念与主要特征、核心技术与架构、应用行业与实例以及潜在影响与实证证据4个研究问题。[结果/结论]结果表明：①不同于传统认知，元宇宙概念并非模糊不清，而是紧紧围绕虚拟、沉浸、交融、社交和交互5个核心特征，由个体层次向人类层次持续演变和发展；②不同层次元宇宙共享一套技术架构，核心技术高度一致且相互协同，但整体技术成熟度不高；③元宇宙的行业应用范围有限，以第三产业行业为主，第二和第一产业行业对元宇宙的认知与需求有待深化与扩展；④元宇宙有政治、社会、经济、技术和文化价值观5种潜在影响类型，积极影响明显多于消极影响，但部分观点存在分歧，尚缺少实证研究证明。此外，讨论当前元宇宙研究的不足和未来可能的研究方向可以对进一步探索元宇宙及相关主题研究提供有益的参考与借鉴。
1.引言 后疫情时代，全球数字化转型加快，人类生产和生活方式发生重大变化[1]。自新冠疫情爆发，传统接触式线下活动受限，云课堂、在线文旅和数字孪生图书馆等无接触、沉浸式线上场景应用需求涌现，网络化、智能化成为经济发展的新动能。加之，全民数字素养与技能稳步提升，数字化意识和习惯正在养成，社会元素逐渐由实向虚，人类正加速向虚拟世界迁移。
现实世界信息技术的发展推动着虚拟世界不断发展，人类迈向元宇宙时代[2]。1990年至1996年，钱学森先生就曾预见元宇宙这一历史变革，并强调了“灵境（Virtual Reality）”技术对创造力提升、形象与灵感思维发展的巨大助力[3]。1992年，美国作家N.Stephenson在其科幻小说Snow Crash中首次提出“元宇宙（Metaverse）”，并构想了一个与现实平行且紧密联系的虚拟空间[4]。随着扩展现实和人工智能等新技术的发展与应用，人们对元宇宙的想象在技术层面上逐渐得以实现，世界各国企业和政府开始注意到其在数字产业升级、实体经济赋能和社会问题解决等方面的作用，并积极采取行动以在时代浪潮中受益[5-10]。
鉴于近年来元宇宙的迅猛发展，有必要探讨和评估其研究现状及未来应用价值，以准确把握元宇宙发展方向，强化元宇宙基础研究，争取元宇宙建构权。尽管已有综述文章基于不同研究兴趣，如技术分类[11]、概念传播[12]和可持续发展与责任建设[13]等，对元宇宙研究进展进行过梳理，但仍然可以发现一些不足：①多数论文专注于研究单一领域的特定主题，如医疗保健[14]、急诊医学[15]、伦理责任[16]等，缺乏针对元宇宙的整体性评估；②多数论文采用叙事性和评论性综述方法，虽同样可对大量文献进行归纳与总结，得出研究结论，但通常较为主观，定量分析不足且数据再现困难。为应对上述问题，并为未来元宇宙及相关主题研究提供参考，本研究对收录于Web of Science（WoS）、ScienceDirect（SD）、SpringerLink（SL）、GoogleScholar（GS）、中国知网（CNKI）、万方（WF）和百度学术（BS）数据库的262篇元宇宙主题论文进行系统综述，回顾与梳理了国内外元宇宙的最新研究进展，以回答4个研究问题：①元宇宙的概念及主要特征？②元宇宙的核心技术及技术架构？③元宇宙的应用行业及应用实例？④元宇宙的潜在影响与实证证据？
2.综述原则与方法 2.1. 综述原则 为使所有论文都能得到客观且一致的收集与分析，本研究定义了3个指导系统性综述实施的基本原则，以确保收集的论文符合研究目的：①明确的排除和纳入标准。本研究制定了非中英文、基本信息缺失、无全文、完全不相关和不相关五类论文排除标准与相关和紧密相关两类论文纳入标准。②客观的评估策略。每篇论文的选择与数据的收集编码均由两名熟悉元宇宙基本知识的评估人员进行评估。若评估人员意见不一，将通过讨论做出最终判断。③有证据的数据收集。对于主观判断数据（如元宇宙概念），论文原始文本作为
2.2. 系统性综述方法 系统性综述是一种利用预先设计的明确过程对文献进行全面评述的方法。其通常指向具体研究问题，遵循文献纳入与排除、论文质量评估、证据分析与综合以及结果报告与总结等过程。与叙事性和评论性等传统综述方法相比，该方法的文献识别、筛选、纳入和分析等过程明确且可重复，不仅有利于控制和降低研究人员文献选择的偏倚，综合观察结果，为研究问题提供更可靠且准确的回答，而且还能最大限度地保障知识创新的科学性与严谨性[17]。目前，该方法已得到不同领域研究人员的广泛认可，应用于医疗急诊[15]和国家安全[18]等多个新兴课题。
为客观、全面和准确地分析元宇宙研究进展，本研究遵循PRISMA（Preferred Reporting Items for Systematic reviews and Meta-Analyses）[19]指导思想，将元宇宙综述过程分为论文识别、论文筛选与评估、论文纳入和数据处理与编码4个阶段。论文识别阶段负责检索选定数据库中可能与元宇宙主题相关的所有论文；论文筛选与评估阶段负责过滤并保留信息完整且与元宇宙主题明确相关的论文；论文纳入阶段负责按相关程度将符合筛选与评估条件的论文分不同标准纳入；数据处理与编码阶段负责对纳入的论文数据进行预处理与编码。如图1所示：
图1 PRISMA不同阶段过程
Figure 1 Different stages of the PRISMA process
具体而言，检索于2023年2月底进行，共收集到5 464篇中文论文（CNKI 2 577篇，WF 1 628篇，BS 1 250篇，前向搜索4篇，后向搜索5篇）和2 039篇英文论文（WoS 940篇，SD 758篇，SL 139篇，GS 141篇，前向搜索57篇，后向搜索4篇）。前向搜索指收集引用综述论文的其他论文，后向搜索指收集综述论文引用的论文[20]。进一步，分别以CNKI和WoS检索论文集为基准，通过阅读标题、摘要、关键词和全文内容等，按1.1节原则对7 503篇论文进行去重、筛选与评估，最终收集到262篇有效论文（中文152篇，英文110篇），论文总量符合系统性综述建议范围[21]。其中，紧密相关论文131篇，部分相关论文65篇，背景支持论文66篇。
针对所获论文，重点抽取、处理和编码基础数据（如标题、作者、基金、期刊）、元宇宙概念、元宇宙技术、技术成熟度、应用行业、产业类别、研究形式、行业应用实例以及行业影响等信息，用于后续研究问题的探讨与分析。262篇收集论文的检索、筛选和纳入标准、数据抽取、数据处理、数据编码流程与结果详见开源GitHub仓库[22]。
3. 当前元宇宙研究进展 3.1. 描述性统计 本研究共收集到262篇期刊论文，涵盖152种期刊（中文92种，英文60种），核心期刊108种。其中，《电子政务》（7篇）、《中国图书馆学报》（6篇）和《图书馆论坛》（6篇）是发文最多的中文期刊，Sustainability（9篇）和IEEE Access（8篇）是发文最多的英文期刊。就研究形式而言，有24篇综述或调查类论文，93篇讨论类论文，91篇理论解决方案类论文，54篇实际解决方案类论文。
3.1.1. 研究主体 262篇收集论文中共发现710位作者（中文292人，英文418人），其中38人发表过2篇及以上元宇宙主题的论文，其余超74.6%的作者仅发表过1篇论文。369个不同机构（中文120个，英文249个）参与了这些论文的撰写，其中高校是元宇宙研究的主导机构（315个），其次是公司（25个）、研究中心（21个）和政府（8个）。
3.1.2. 地理分布 中国（包括港澳台，44篇）、韩国（31篇）、美国（12篇）、英国（8篇）和澳大利亚（6篇）是发表英文论文最多的国家。尽管中国和韩国并非元宇宙热潮的发源地，但对元宇宙表现出了极大兴趣。此外，“一带一路”沿线国家或地区也对元宇宙表现出了较大兴趣。北京（58篇）、上海（27篇）、江苏（12篇）、广东（11篇）和湖北（8篇）是发表中文论文最多的地区。东部及部分中部地区较为关注元宇宙，而大部分中西部地区刚开始关注元宇宙。
3.1.3. 资助情况 262篇收集论文中，有167篇获得过至少一项资助，中文论文资助率（109篇，72.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f02412a26d5d26cd56ad08ed196f26e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2d0d7cb13c9273e9e9853482cf61e90/" rel="bookmark">
			1.1 微信Native支付 - 接入指引与支付安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信支付接入指引与支付安全 文章目录 微信支付接入指引与支付安全一、微信产品介绍1.1 付款码支付1.2 JSAPI支付1.3 小程序支付1.4 Native支付1.5 APP支付1.6 刷脸支付 二、接入指引2.1 获取商户号2.2 获取AppID2.3 绑定商户号与AppId2.4 获取秘钥和证书2.4.1 申请API秘钥2.4.2 申请API证书 三、支付安全3.1 对称加密与非对称加密3.1.1 优缺点 3.2 身份认证3.3 数字签名3.3.1 摘要算法介绍 3.4 数字证书3.4.1 Https中的数字证书 一、微信产品介绍 官方网站：微信支付 - 中国领先的第三方支付平台 ｜ 微信支付提供安全快捷的支付方式 (qq.com)
我们可以看一下“产品中心”中的”支付产品“
1.1 付款码支付 产品中心 - 微信支付商户平台 (qq.com)
1.2 JSAPI支付 产品中心 - 微信支付商户平台 (qq.com)
”线下场所“是商户展示自己的商户二维码，用户进行扫描并输入金额
“公众号场景”是指用户在微信内进入商家的公众号内进行支付
“PC网站场景”是用户在网站中展示一个二维码，用户进行扫描
1.3 小程序支付 产品中心 - 微信支付商户平台 (qq.com)
在小程序中下单并且进行支付
1.4 Native支付 商户展示支付二维码，用户扫一扫完成支付的模式，这种方式适用于pc网站
之前提到的JSAPI支付也适用于pc网站的情景
Native支付是用户扫描二维码后直接展示由商家指定的的支付金额
JSAPI支付是用户扫描二维码后需要由用户自己去输入一个支付金额
1.5 APP支付 是指商户通过在移动端独立的APP应用程序中集成微信支付模块从而完成支付流程的一种方式。
这种支付方式我们需要有一个APP，例如向美团
1.6 刷脸支付 用户在刷脸设备前通过摄像头刷脸，然后识别身份后进行的一种支付方式，适用于线下实体场所的一个收银场景
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2d0d7cb13c9273e9e9853482cf61e90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67a180c259d9c64f2d47b96e76d9ecbd/" rel="bookmark">
			Markdown常用语法及常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.标题 # 一级标题 一级标题 ## 二级标题 二级标题 ### 三级标题 三级标题 #### 四级标题 四级标题 ##### 五级标题 五级标题 ###### 六级标题 六级标题 二. 常用快捷键 代码块：Ctrl+Shift+K代码句：Ctrl+Shift+`后退一步（撤销）：Ctrl+z前进一步：Ctrl+Y引用：Ctrl+Shift+Q几级标题：Ctrl+数字提高标题级别：Ctrl+=减低标题级别：Ctrl±结束缩进：Ctrl+[选中当前行：Ctrl+L跳转到有内容的末尾：Ctrl+End 三. 杂项 1.引用 &gt; 这是一段引用 这是一段引用
2.顺序列表 1. 顺序列表 aaabbbccc 3.无序列表 - 无序列表 aaabbbccc ​ 多级无序列表：换行后使用Tab键
4.任务列表 - [ ]任务列表 aaa bbb ccc 5.代码块 ```c代码块 代码块 6.表格 表格 |aaa|bbb|ccc| 姓名年龄成绩 7.强调 *强调* 强调
8.加粗 **加粗** 加粗
9.行内代码 `行内代码` 行内代码
四.常见问题 1. 多级列表两次回车无法返回上一级列表？ 使用Ctrl+End跳转到有内容的末尾，将空白全部删除即可恢复正常 2. 只读或没有权限编辑文件？ 右击文件或文件夹或磁盘，寻找标记只读的地方，取消只读选项 3.二级标题已经设置好，但在大纲中未显示？ 使用Ctrl+/进入源代码模式，查看标题缩进是否不一致，大概率是因为缩进不一致导致未显示 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67a180c259d9c64f2d47b96e76d9ecbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c44db0d87166a07cb1b0971300121b8f/" rel="bookmark">
			数据结构知识点整理（类C语言实现）（在更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：类C语言使用引用传参(&amp;)，是借用C++语法中的内容，C语言实现时使用指针(*）传参，与类C代码有很大不同 2.线性表 案例：稀疏多项式的运算 创建一个新数组c分别从头遍历比较a和b的每一项 指数相同：对应系数相加，若其和不为零，则在c中增加一个新项指数不相同：则将较小项复制到c中 当其中一个多项式遍历完毕，将另一个剩余项复制到c中即可 线性表的基本操作： InitList(&amp;L)
线性表的初始化操作结果：构建一个空的线性表L DestroyList(&amp;L)
初始条件：线性表L已经存在操作结果：销毁线性表L（表本身消失） ClearList(&amp;L)
初始条件：线性表L已经存在操作结果：将线性表L重置为空表（表仍存在） ListEmpty(L)
初始条件：线性表L已经存在操作结果：若线性表为空，则返回TURE；否则返回FALSE ListLength(L)
初始条件：线性表L已经存在操作结果：返回线性表中元素个数 GetElem(L,i,&amp;e)
初始条件：线性表L已经存在，1&lt;=i&lt;=ListLength(L)操作结果：用e返回线性表L中第i个元素的值 LocateElem(L,e,compare())
初始条件：线性表L已经存在，compare()是数据元素判定函数操作结果：返回L中第一个与e满足compare()的数据元素的位序，若不存在，则返回0 PriorElem(L,cur_e,&amp;pre_e)
初始条件：线性表L已经存在操作结果：若cur_e，是L的数据元素，且不是第一个，则用pre_e返回他的前驱，否则操作失败，pre_e无意义 NextElem(L,cur_e,&amp;next_e)
初始条件：线性表L已经存在
操作结果：若cur_e，是L的数据元素，且不是最后一个，则用next_e返回他的前驱，否则操作失败，next_e无意义
ListInsert(&amp;L,i,e)
初始条件：线性表L已经存在，i&lt;=i&lt;=ListLength(L)+1操作结果：在L的第i个位置前插入新的元素e，L的长度加一 ListDelete(&amp;L,i,&amp;e)
初始条件：线性表L已经存在，i&lt;=i&lt;=ListLength(L)操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一 ListTraverse(&amp;L,visited())
初始条件：线性表L已经存在操作结果：依次对线性表L中每个元素调用visited() 算法中用到的预定义常量和类型 //函数结果状态代码 #define TURE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2 //Status 是函数的类型，其值是函数结果状态代码 typedef int Status; typedef char ElemType; 顺序表 1.顺序表中元素存储位置的计算 假设线性表的每个元素需占用i个存储单元，则第i+j个元素的存储位置和第i个元素的存储位置之间满足关系： LOC(a(n+1))=LOC(a(n))+i 2.顺序表的特点 以物理位置相邻表示逻辑关系，任一元素均可随机存取 3.顺序表 地址连续依次存放随机存取类型相同 4.顺序表的类C语言代码实现 #define LIST_INIT_SIZE 100//线性表存储空间的初始分配量 typedef struct { ElemType elem[LIST_INIT_SIZE];//方案1：静态数组方式 ElemType *elem;//方案2：动态内存分配方式 int length;//当前长度 }SqList; SqList L;//定义变量L，L是SqList这种类型的变量，L是个顺序表 L.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c44db0d87166a07cb1b0971300121b8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f52b0d6cccd427c7496acd40f5606be/" rel="bookmark">
			用css画勾和叉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 css实现勾 √css实现叉 x通过unicode 来实现扩展阅读 css实现勾 √ .right { width: 28px; height: 28px; line-height: 26px; border: 1px solid #025299; background-color: #025299; position: relative; cursor: pointer; } .right::before { position: absolute; content: " "; width: 7px; height: 13px; transform: rotate(45deg); border-right: 2px solid #fff; border-bottom: 2px solid #fff; top: 4px; left: 9px; } css实现叉 x .error { width: 28px; height: 28px; line-height: 26px; border: 1px solid #025299; background-color: #025299; position: relative; cursor: pointer; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f52b0d6cccd427c7496acd40f5606be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b89dc080cc00a753fb62990e444959b6/" rel="bookmark">
			Hyperledger Fabric搭建测试网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文使用的Fabric版本：V2.5.4
Ubuntu系统：16.04LTS
前序文章已经详细介绍了如何安装部署Hyperledger Fabric系统，这里不再赘述。本篇文章主要介绍如何使用Fabric的测试网络。在正式开始之前，有一点需要说明：
Hyperledger Fabric的完整安装路径如下： $HOME/go/src/github.com/hyperledger/fabric 为了方便，下文cd命令中的路径从fabric开始书写，fabric之前的省略。
1 启动/关闭测试网络 为了方便开发人员学习及测试智能合约和DApp，fabric-samples文件中提供了一个测试网络test-network。
1.1 启动测试网络 进入fabric/scripts/fabric-samples/test-network，可以执行如下命令启动测试网络：
cd fabric/scripts/fabric-samples/test-network ./network.sh up 如果命令在执行过程中遇到“permission denied"提示，则使用sudo权限执行第二条命令：
sudo ./network.sh up 执行成功将看到以下提示信息：
从图中可以看到，这个测试网络包括一个Orderer节点、两个Peer节点和一个CLI客户端(这些都部署在docker容器中)，其中这两个Peer节点分属两个组织：Org1和Org2。
1.2 关闭测试网络 可以使用以下命令关闭测试网络：
sudo ./network.sh down Tips:测试网络关闭之后，创建的通道、部署的链码以及配置的环境变量都会失效，都要重新设置。
1.3 重启测试网络 可以使用如下命令重启测试网络：
sudo ./network.sh restart 2 创建通道 通道提供一种通信机制，将指定的Peer和Orderer连接在一起，形成一个具有保密性的通信链路，进行数据隔离(区块数据只能存储在已加入到通道中的成员节点内)。
测试网络成功启动之后，就可以创建通道了。创建命令如下：
sudo ./network.sh createChannel 命令会默认创建一个名为"mychannel"的通道，并且将两个Peer节点加入该通道中。
Anchor peer set for org ‘Org1MSP’ on channel ‘mychannel’
Anchor peer set for org ‘Org2MSP’ on channel ‘mychannel’
Channel ‘mychannel’ joined
创建通道时，还可以指定通道的名字。命令如下：
//创建一个名为first_channel的通道 sudo .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b89dc080cc00a753fb62990e444959b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9010305f6a115888713cd2e2c1c93c53/" rel="bookmark">
			scrcpy常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.说明 scrcpy是一个基于adb调试实现的屏幕共享软件，可以将安卓手机共享到电脑，并且可以在电脑控制手机
特点
对手机无侵入、可以不联网（数据线）、低延迟、免费开源。
功能
屏幕共享、屏幕录制、声音转发、复制粘贴、画质控制、OTG
系统
最低Android 5.0（API 21），开启USB调试
GitHub
https://github.com/Genymobile/scrcpy
2.安装 scrcpy支持Windows、macOS、Linux
其中Windows直接在GitHub下载
https://github.com/Genymobile/scrcpy/releases
macOS和Linux可以通过包管理器快速安装
# macOS brew install scrcpy # Linux apt install scrcpy 3.运行 首先确保手机已经开启USB调试，并且用数据线连接电脑（无线调试不用）
如果已经把scrcpy添加到环境变量，可以直接在终端执行scrcpy 命令启动scrcpy就能使用了，如果想要自定义，后面可以加上各种参数
4.常用参数 4.1 传输优化 参数说明举例--max-size设置最大分辨率scrcpy --max-size=1024--bit-rate设置最大码率，默认是8Mbpsscrcpy --bit-rate=2M--max-fps设置采集帧率scrcpy --max-fps=15--print-fps打印当前帧率scrcpy --print-fps--display-buffer缓冲（毫秒），增加延时但减少抖动scrcpy --display-buffer=50 4.2 窗口设置 参数说明举例--window-title设置窗口标题--window-title="小米手机1"--window-borderless无边框启动（不好拖动窗口哦）scrcpy --window-borderless--always-on-top置顶窗口scrcpy --always-on-top--fullscreen或-f全屏窗口scrcpy --fullscreen--rotation旋转窗口，取值0123，依次增加旋转90度scrcpy --rotation=1--stay-awake屏幕保持常亮(不息屏)scrcpy --stay-awake--turn-screen-off息屏状态下也能控制scrcpy --turn-screen-off--disable-screensaver关闭屏幕保护scrcpy --disable-screensaver--window-x --window-y窗口的位置x、y位置scrcpy --window-x=100 --window-y=100--window-width --window-height窗口的宽、高scrcpy --window-width=1080 --window-height=1920--display指定显示屏（多显示屏时）scrcpy --display=1 4.3 屏幕录制 参数说明举例--record录制视频scrcpy --record=test.mp4--no-display仅录制，不显示镜像scrcpy --no-display --record=test.mp4 4.4 音频控制 安卓版本要求大于等于11，如果是11要确保屏幕已解锁
参数说明举例--no-audio禁止音频scrcpy --no-audio--no-video禁止视频（只要音频）scrcpy --no-video--audio-bit-rate音频比特率，默认128Kscrcpy --audio-bit-rate=64000--audio-buffer音频缓冲，默认50毫秒，建议与--display-buffer一致scrcpy --audio-buffer=40 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9010305f6a115888713cd2e2c1c93c53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7002bce38c1f9f887ed1a0cb5e1e923/" rel="bookmark">
			Python实用技巧：将 Excel转为PDF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将Excel文件转换为PDF可以方便储存表格数据，此外在打印或共享文档时也能确保表格样式布局等在不同设备和操作系统上保持一致。今天给大家分享一个使用第三方Python库Spire.XLS for Python 实现Excel转PDF的简单方法。
实现步骤 首先，通过pip命令来安装依赖库； pip install Spire.XLS 安装完成后，导入所需库； from spire.xls import * from spire.common import * 加载Excel文档，然后可以通过 Spire.XLS for Python 提供的 Workbook.SaveToFile() 或Worksheet.SaveToPdf() 来将Excel工作簿或某个指定的工作表转换为PDF格式。在转换时还可以通过 PageSetup 类来进行页面设置。 代码示例 1 .使用Python将Excel文件转为PDF格式（每个工作表显示为单独的一页）：
from spire.xls import * from spire.common import * # 创建Workbook对象 workbook = Workbook() # 加载Excel文档 workbook.LoadFromFile("数据.xlsx") # 设置工作表适应页面 workbook.ConverterSetting.SheetFitToPage = True # 将Excel转换为PDF workbook.SaveToFile("ToPDF.pdf", FileFormat.PDF) workbook.Dispose() 2. 使用Python将Excel中每个工作表转换为单独的PDF文件：
from spire.xls import * from spire.common import * # 创建 Workbook 对象 workbook = Workbook() # 加载Excel文件 workbook.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7002bce38c1f9f887ed1a0cb5e1e923/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6ff458c05c178e0923c35c6c905dab5/" rel="bookmark">
			mybatis ORDER BY FIND_IN_SET 失效的一次问题排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看代码，我想根据传递的questionIndex进行排序
&lt;select id="selectListByConditionsOrder" resultMap="BaseResultMap"&gt; SELECT * FROM survey_xx ${ew.customSqlSegment} AND deleted_at IS NULL &lt;if test="questionIndex != null"&gt; ORDER BY FIND_IN_SET(question_index, #{questionIndex}) &lt;/if&gt; &lt;/select&gt; 结果运行起来怎么也不对，最终发现是因为传递过来的字符串有问题
之前是
pageArray.toString() 改成
pageArray.join(",") 就好了，真是诡异，我还纳闷为啥navicat里测试没问题用mybatis就有问题呢。
JSONArray pageArray
hutool的一个json
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eae4eb1217be4b271c00cfa386fd3cbc/" rel="bookmark">
			ubuntu 源码编译安装make过程很慢问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一般下载的时候有两种方式 使用wget 下载后使用tar命令解压直接git clone 源代码 下载完成之后，进入目录，新建一个文件夹build，防止影响码源结构第三步，进入到build目录，使用cmake编译 cmake ..第四步直接make编译 这一步有时候会很慢，我们使用make -jn这里n表示线程数，我一般使用八个线程 make -j8或者这里编译需要的软件即可 make clang -j8 最后安装 sudo make install 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a93d172b29edb8f4fb570ca334152b9/" rel="bookmark">
			QTcpSocket中readyRead信号不实时触发问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题描述
在Qt中使用Tcp通讯时的惯常做法是在服务端将QtcpSocket的readyRead信号与处理业务的槽函数关联，这样每当有新的通讯数据时触发readyRead信号，进而通过槽函数处理业务流程。然而，readyRead信号与客户端的write函数并没有必然的一一对应关系。因此，对一些特别依赖数据实时性的应用场景就会出现通讯中断的情况。
关联readyRead信号的一般形式如下：
QObject::connect(mpSocket,&amp;QTcpSocket::readyRead,this,&amp;TcpServer::slotReadData); 例如，在一次业务流程中，当服务端根据客户端的回复指令下发指令时，由于readyRead信号没有实时触发，导致服务端没有及时收到回令而业务中断（用Wireshark抓包显示数据的确发送成功了）。当下一次重新开始时，才把上一次滞留的回令连带新的回令以粘包的形式发给服务端。此时，本意是完全从头再来，却收到上一次的滞留回令，此时业务逻辑就很有可能出错。在这种情形中，Qt的信号与槽机制参与TCP通讯就存在局限性。我们迫切需要换一种思路去实时获取TCP传输过来的数据。
2.原因分析
首先，必须明确发送端write一次，接收方就会有新数据到达，readyRead()信号就会触发一次，这种理解不对！
发送和接收没有必然一一对应关系。发送端write()函数调用一次，若这一次write了较大数据(2M)，那么接收方readyRead()信号往往会触发两次以上，反过来，如果发送方write()函数被调用了两次或是以上，接收方的readyRead信号也可能只调用一次。
所谓的有新数据来，readyRead信号就会触发一次，实际上不是指从发送端有新数据来到接收端计算机，而是数据从接收计算机的Tcp/ip协议栈到达Qt应用程序，即系统io缓冲区到达Qt应用程序，数据从系统到达Qt应用程序readyRead信号就会触发一次。
综上，究其根本是QT的TCP通讯并没有丢数据，只是数据滞留在了io缓冲区！
3.解决方法
本人尝试了起一个线程不断轮询调用QtcpSocket的readAll()或者read()函数，只是偶尔能够全部及时取到TCP通讯数据，很多时候也拿不到io缓冲区的滞留数据。甚至，起两个线程，一个用于收发数据（对应readAll()和write()函数），另外一个用队列里的指令驱动业务流程，这样也不行，连最基本的通讯连接都出了问题。
既然QT的接口有局限性，就尝试调用windows自带的socket接口。最终，根据这个思路，调用WinSock的的recv()接口，完美解决问题！
4.关键代码
这里省略了业务流程以及其它不相干的代码，只突出解决问题的关键代码。
先看头文件：
#include &lt;WinSock.h&gt; class TcpServer : public QThread { Q_OBJECT public: explicit TcpServer(QObject* parent = 0); ~TcpServer(); void run(); bool StartListen(const QHostAddress&amp; address = QHostAddress::Any, quint16 port = 0); private: void ProcData(char revData[], int len); private: SOCKET m_listenSocket; SOCKET m_revSocket; //对应所建立连接的套接字的句柄 }; 再看构造函数：
TcpServer::TcpServer(QObject* parent) : QThread(parent) { /*此处省略其它构造内容*/ WORD sockVersion = MAKEWORD(2, 2); WSADATA wsaData; if (WSAStartup(sockVersion, &amp;wsaData) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a93d172b29edb8f4fb570ca334152b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/316ec48bfbd6696937560b5d9b9ad608/" rel="bookmark">
			MyBatis-PLUSS学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MyBatis-plus快速入门 1.1简介 MyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis (opens new window) 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。
特性：
无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 支持数据库：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/316ec48bfbd6696937560b5d9b9ad608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08c69f0213237535c1112504241fff89/" rel="bookmark">
			【曲阜师范大学毕业论文】基于JavaWeb的滑雪场系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：展示部分文档内容和系统截图，需要完整的视频、代码、文章和安装调试环境请私信up主。 3.3 数据库设计
3.3.1 数据库设计原则 学习程序设计，如果想要了解数据库管理系统或者是按照系统接口的要求制作的，就必须创建一个数据库管理系统模型，用来存储数据，这样在进行应用程序编程的过程中，就不需要加载操作系统页面的信息，从而提高整个系统的工作效率。在数据库管理系统中承载着众多的数据，应该说，一个管理信息系统的建设中心和基地，也为建设管理信息系统和信息管理系统提出了新的查询、删除、修改和操作功能，使管理信息系统建设可以快速查询需要的数据，而不是直接从代码中查找。信息库管理系统由各个组成部分的信息表按照具体的方法进行准确的归并、排序和组成信息库管理系统[7]。
3.3.2 数据库E-R图设计 E-R图即实体-联系图，提供了解显示数据类型存在联系的途径，主要特点是实体、属性、联系。本系统主要的实体属性图如图3-4所示。
3.3.3数据库表结构设计 系统使用MySQL数据库，根据系统数据存储的特点来对其关系表进行设计。系统中在线购票详细信息如表3-1所示。
表3-1 在线购票
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
主键
addtime
timestamp
创建时间
CURRENT_TIMESTAMP
changdimingcheng
varchar
200
场地名称
menpiaofeiyong
float
门票费用
riqi
date
日期
yonghuzhanghao
varchar
200
用户账号
yonghuxingming
varchar
200
用户姓名
shoujihao
varchar
200
手机号
系统中滑雪论坛详细信息如表3-2所示。
表3-2 滑雪论坛
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
主键
addtime
timestamp
创建时间
CURRENT_TIMESTAMP
title
varchar
200
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08c69f0213237535c1112504241fff89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8375d9bd1f922f74e3471b467047583e/" rel="bookmark">
			基于JavaWeb的公用品管理系统的设计与开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：展示部分文档内容和系统截图，需要完整的视频、代码、文章和安装调试环境请私信up主。 2.1 Java介绍 Java语言作为一种基于对象的语言，其具备了安全、通用等优势，被广泛地用于网络、数据中心等领域，其实现的动态 Web和跨平台功能，首先是通过 Hot Java浏览器来实现的。从那以后， Java在 Web页面上得到了越来越多的使用，而且还在继续改进。相比于 C/C++, Java语言要比 C/C++要简单得多。 Java和 C++的程序设计有很多类似的地方， Java程序设计人员去掉了 C++中少用到的属性，使其变得更加精细。面向对象最大的特点就是将相似的函数放入相同的函数，然后编程人员就可以使用这些函数来实现相应的函数。Java的代码不象 C++那样，必须手工地进行存储和存储。对于一个通过 Java语言来写的软件，只要经过一次编辑，它就可以用于各种平台。
2.2 MySQL数据库 MySQL是 Oracle系列中的一类，是目前最主要的一类关系数据库。MySQL的意思是一个用于储存与管理的数据仓储，在实际生活中，它就像一个档案与资料橱窗。雇员可以利用这个资料库在资料库中储存资料。MySQL所采用的一种被用作建立表格的方法。
因为 MySQL的安装费用低廉，而且运行快速，所以许多中小企业都选择了 MySQL作为自己的基础。MySQL的性能非常出色，而且因为它的源码是自由开放的，所以可以为公司节省大量的开发费用。
MySQL数据库可以储存海量的数据，在使用时既简单又快速，为了提高检索的效率，还可以在数据库表上添加一个索引， MySQL可以利用 SQL语句对系统的信息进行进行当系统有必要增加数据时，就可以使用插入命令来对数据库进行修改，这样就可以利用少数几个 SQL命令来对整个系统进行管理。MySQL属于一个开放且可以免费使用的数据库，它可以利用一条标准的 SQL句子来实现对 OS的信息的设置，而且对 MySQL的设置和配置也比较容易，还可以利用一个数据库管理工具 Navicat for MySQL来实现对数据库的信息进行可视化的管理。
2.3 SpringBoot框架 SpringBoot框架在经过几年的不断发展，现在它的发展非常成熟。与 Spring框架相比，它减少了许多的配置。 SpringBoot框架中嵌入了 Tomcat，它不需要对 Tomcat服务器进行另外的设置。在编写代码的过程中，它也可以使用 R对象来进行。由 SpringBoot编制而成的程序可以与前端页面进行良好的互动，并且可以很好地对这些异常进行处理，可以捕捉到许多的异常。 SpringBoot框架是通过界面进行实现互动的，所以在后期的修改中，它可以迅速且容易地进行更改。
2.4 IDEA开发环境 IDEA是 IBM公司自己开发出来的，不过 IBM公司也将它奉献到了开放源码上。IDEA编译器用 Java编写了基本的程序，并且使用了大量自身的开发插件。IDEA编译机的核心程序是开源的，可以作为二次研发的良好环境。IDEA编译程序的研发必须以高可用性、安全性等为中心。当 IDEA编译机被发明之初，它只能用 Java进行编码，而后来由于技术的进步，它可以用其他的程序语言进行编码。IDEA尽管只是一种编译工具，但随着大量的插件涌现， IDEA能够将其整合起来，使其具有更多的功能性。IDEA可以很好地适应各种常见的开发情况，其中各种功能可以涵盖系统的各个发展时期，它的应用也比较便捷，其中既有前台接口，也有后端的商业逻辑。
2.5 B/S架构 B/S架构是当前主流的网络架构，它可以将所有的主要功能都集中在服务器上，方便了开发者的操作，方便了系统的维护和使用。只要员工安装了目前的主流浏览器，比如360、谷歌、 QQ、以及其他的浏览器，就可以安装 sqlserver、 mysql等数据库。已安装的浏览器与服务器端的资料库进行数据资料交互。许多专业的软件都可以完成，但是在 B/S模式下，却可以将 Web浏览器、 ActiveX和各种脚本语言相融合。为编程人员节省大量的开发费用。现在 B/S架构已经成为了主流的编程架构，最大的好处就是没有位置的限制，也不需要安装任何的软件。如果是 B/S开发，那么后期的系统维护就会变得非常的方便，不需要所有的事情都在服务器上，只需要一个简单的客户端，就能解决一些问题，开发出来的软件和员工的交互能力也会得到提升，而且还能随时更新网页中的数据。
3.3 系统各部分功能需求分析 3.3.1 系统总体需求分析 办公用品管理系统的设计与实现，最主要的是满足使用者的使用需求，并且可以向使用者提供一些与系统配套的服务。本篇论文主要从实际出发，采用以对象为设计重点的设计方法，因此在进行系统总体的需求分时借助用例图可以更好的阐述各个功能模块之间的关系，以及明确系统使用者之间的联系。本系统的设计包含管理员和员工两个角色。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8375d9bd1f922f74e3471b467047583e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bc654d879f3ac6b179ccd61e0537241/" rel="bookmark">
			知识点-numpy，pandas和matplotlib
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考笔记：
注意：from numpy import show_config as show_numpy_config
ImportError: cannot import name ‘show_config’ from ‘numpy’ (unknown location)
numpy与scipy版本不一致： 参考：https://docs.scipy.org/doc/scipy/dev/toolchain.html 一、numpy
1、创建ndarray(可以是多维的但是数据类型必须一致)：np.array()
#举例
np.array(range(100))
*T 转置
*dtype 类型
*size 大小
*ndim 维数
*shape 维度大小（返回元组）
#reshape 改变排列
#arange 相当于列表的range，并可以支持步长且可以是小数步长
#zeros 创建多维需要传入一个元组（3,5）
*多维数组切片，比如[1:3][1:3],联系两个切片不是先横切再后切，这是相当于两个横切，所以建议多写在一起[1:3，1:3]
#判断和、或、非，这里是用&amp; | ~
#花式索引切片里面再加个[]包起来表示
#abs绝对值，sqrt开根号，ceil向上取整，floor向下取整，round四舍五入，trunc向0取整，modf小数返回两个值一个小数点前整数，一个是小数点后的数的两个数组，nan表示缺失不是个数(另外0/0值也是nan)，inf表示无穷大的数（除以0）
#maximum 取两个数组对应位置的最大数形成数组
举例：不是nan的取出,结合布尔型索引 a[~np.isnan(a)]
#cumsum返回的还是一个数组，各位置值对应前面位置的累积和
另例子：import random
random.randint(1,10) 表示随机整数, random.choice([1,5,7,10]) 随机取值, random.uniform(1.0,10.0) 随机小数, random.random() 返回0-1间随意数, random.shuffle([1,5,7,10]) 随机打乱列表,
#numpy结合random一样，np.random.randint(1,10,3)表示随机产生3个各1-10的数组， np.random.randint(1,10,(3,5))表示随机产生3行5列各1-10的二维数组，rand==random
还有randn这是返回一个随机浮点数，大概-1.96~+1.96之间
二、pandas
1、Series
#创建可以列表，字典和数组进行创建 pd.Series(np.arange(10))
#pd.Series([3,5,6,2],index=list(“abcd”)) 注意Series 大写第一位，另外index索引是个列表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bc654d879f3ac6b179ccd61e0537241/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0af6c037a365e13018fe2f66e71fb3d/" rel="bookmark">
			Linux抓包框架对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux网络报文捕获/抓包技术对比：napi、libpcap、afpacket、PF_RING、PACKET_MMAP、DPDK、XDP(eXpress Data Path) ackapiexpexpressliblibpcaplinuxmapmmappacpackpacketpathpcapcapprering
1.传统linux网络协议栈流程和性能分析
协议栈的主要问题
针对单个数据包级别的资源分配和释放
流量的串行访问
从驱动到用户态的数据拷贝
内核到用户空间的上下文切换
跨内存访问
2. 提高捕获效率的技术
预分配和重用内存资源
数据包采用并行直接通道传递.
内存映射.
数据包的批处理.
亲和性与预取.
3. 典型收包引擎
3.1 libpcap
3.2 libpcap-mmap
3.3 PF_RING
3.4 PACKET_MMAP
PACKET_MMAP的实现原理
PACKET_MMAP源码分析
3.5 DPDK
UIO+mmap 实现零拷贝（zero copy）
UIO+PMD 减少中断和CPU上下文切换
HugePages 减少TLB miss
其它优化
3.6 XDP(eXpress Data Path)
PS：使用XDP(eXpress Data Path)防御DDoS攻击
新的分层方法
绕过更低层的门
XDP
关于DDoS防御
怎么做？
4. 无锁队列技术
CAS原子指令操作
内存屏障
5. 基于pfring/dpdk的应用
参考
相关阅读
1.传统linux网络协议栈流程和性能分析
Linux网络协议栈是处理网络数据包的典型系统，它包含了从物理层直到应用层的全过程。
数据包到达网卡设备。网卡设备依据配置进行DMA操作。（第1次拷贝：网卡寄存器-&gt;内核为网卡分配的缓冲区ring buffer）网卡发送中断，唤醒处理器。驱动软件从ring buffer中读取，填充内核skbuff结构（第2次拷贝：内核网卡缓冲区ring buffer-&gt;内核专用数据结构skbuff）数据报文达到内核协议栈，进行高层处理。socket系统调用将数据从内核搬移到用户态。(第3次拷贝：内核空间-&gt;用户空间) 研究者们发现，Linux内核协议栈在数据包的收发过程中，内存拷贝操作的时间开销占了整个处理过程时间开销的65%，此外层间传递的系统调用时间也占据了8%～10%。
协议栈的主要问题 针对单个数据包级别的资源分配和释放 每当一个数据包到达网卡，系统就会分配一个分组描述符用于存储数据包的信息和头部，直到分组传送到用户态空间，其描述符才被释放。此外，sk_buff庞大的数据结构中的大部分信息对于大多数网络任务而言都是无用的.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0af6c037a365e13018fe2f66e71fb3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a277399650d6ee1654bd021ef83f9d1/" rel="bookmark">
			Stable Diffusion：最先进的文本生成图像模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		稳定扩散 生成式 AI 技术正在迅速发展，现在可以简单地根据文本输入生成文本和图像。Stable Diffusion 是一种文本到图像模型，使您能够创建逼真的应用程序。
扩散模型通过学习去除添加到真实图像中的噪声进行训练。这种降噪过程会产生逼真的图像。这些模型还可以通过调节文本的生成过程，仅从文本生成图像。例如，稳定扩散是一种潜在扩散，模型学习识别纯噪声图像中的形状，如果形状与输入文本中的单词匹配，则逐渐使这些形状成为焦点。必须首先使用语言模型将文本嵌入到潜在空间中。然后，采用U-Net架构在潜在空间中进行一系列的噪声添加和消除操作。最后，将去噪后的输出解码到像素空间中。
以下是 Stable Diffusion 生成的输入文本和相应输出图像的一些示例。
以下图片是对输入的回应：“宇航员在火星上骑马的照片”、“印象派风格的纽约市绘画”和“穿西装的狗”。
以下图像是对输入的响应：（i） 玩扑克的狗，（ii） 森林中树木丛生的城堡的彩色照片，以及 （iii） 森林中树木丛生的城堡的彩色照片。负面提示：黄色
基于稳定扩散AI 模型开发的工具包 DreamTexture.js自动纹理化开发包 是基于 Stable Diffusion AI模型的3D 模型纹理自动生成与设置开发包，可以为 webGL 应用增加 3D 模型的快速自动纹理化能力。
图一为原始模型, 图二图三为贴图后的模型。提示词：city, Realistic , cinematic , Front view ,Game scene graph
1、DreamTexture.js 开发包内容 DreamTexture.js 基于 Three.js 和稳定扩散(stable diffusion) AI 模型开发，用于实现 3D 模型的自动纹理化,当然版本 V1.0,主要文件及目录组织结构如下：
开发包文件说明dream-texture.cjscjs 格式库文件dream-texture.esmesm 格式库文件dream-texture.umdumd 格式库文件stable-diffusion-guide.md用于 DreamTexture.js 的稳定扩散服务安装指南LICENSE.md开发包许可协议文件example/DreamTexture.js 使用示例目录 2、DreamTexture.js 开发包快速上手 以 ESM 库为例介绍如何使用 DreamTexture.js 开发包为 Three.js 应用增加 3D 模型的自动化纹理能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a277399650d6ee1654bd021ef83f9d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac5af53d7cf7bbc1ab69f8981c240bb/" rel="bookmark">
			最全的语言和时区对照表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最全的android各国语言对照表
https://blog.csdn.net/u010586698/article/details/56673379
https://blog.csdn.net/zhaoyufei133/article/details/89283506
Android默认时区大全
https://blog.csdn.net/kulolun/article/details/104649552/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afd7f57d126529b79505c0efc5fba321/" rel="bookmark">
			anker创新-2023年秋季校园招聘-音频算法方向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		职位描述 负责音频处理算法的研发和优化，包括但不限于噪声抑制、回声消除、声反馈抑制、音效、声纹、唤醒、指令词识别等。持续跟进国际前沿技术方向，预研端侧可落地的音频技术，打造技术影响力。对音频处理系统进行模拟和实验，验证算法的性能，参与音频算法的性能评估和调试，解决实际应用中的问题。配合工程同学将算法落地至会议硬件、耳机、音箱、智能cāmera以及各种IOT和智能家居产品。 职位要求 面向2024年毕业，信号处理、计算机、电子信息、自动化等相关专业硕士及博士研究生。在音频信号处理、唤醒、关键词、声纹、声学事件检测一个或多个方向有较深入研究。熟练掌握C、Python、Shel等编程语言，熟悉常用的深度学习框架。高水平学术论文、竞赛经验加分。好的团队协作精神，较强的沟通能力以及英文读写能力，对技术研发有热情。具有良好的团队合作精神和沟通能力。 安克简介： 安克创新科技股份有限公司成立于2011年，是国内营收规模最大的全球化消费电子品牌企业之一。企业业务从线上起步，在亚马逊等境外大型电商平台上占据领先的行业市场份额，拥有很高的知名度和美誉度：
安克创新致力于在全球市场塑造中国消费电子品牌，通过不断创新，将富有科技魅力的领先产品带向全球消费者，弘扬中国智造之美。成功打造了智能充电品牌Anker,并相继推出Soundcore、eufy、Nebulas等自主品牌，进步拓宽业务领域，在AI0T、智能家居、智能声学、智能安防等领域均有出色表现，拥有全球10多个国家与地区超1亿用户。
自成立以来，安克创新以远超行业平均的增速发展：其中2019年营收66.55亿人民币；2020年营收93.53亿人民币；2021年营收125.74亿人民币。2022年，安克创新持续保持了稳健的增长，全年销售额达142.51亿人民币。
安克音频技术研究院简介 办公地点主要是北京和深圳两地，目前负责公司大部份音频、语音算法的研发和工程落地工作，业务面向会议系统、耳机、音箱、助听辅听、各种智能家居等产品。安克音频技术研究院不仅有丰富的产品落地场景，还非常重视创新技术的研发，曾在多项国际音频竞赛中取得第一名的好成绩。欢迎各位音频方向的小伙伴加入我们，将富有科技魅力的领先音频产品带向全球消费者，弘扬中国智造之美！
需要了解更多信息，请发送简历到：alex.wei@anker-in.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eec3aaffa0f945bf55b84ac6b81cbb8/" rel="bookmark">
			java jdk 版本切换工具 jEnv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jEnv - Manage your Java environment
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/385416c6c423d7b3f5f313671e615b62/" rel="bookmark">
			简单的京东爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		京东爬虫 更新**爬虫代码****数据分析代码** 参考: Python爬虫：爬取京东商品简介. #!/usr/bin/env python # -*- coding:utf-8 -*- # @Time : 2021/8/6 import requests from bs4 import BeautifulSoup import xlwt import time class Config(): ''' PARAMETER_LABEL：需要根据爬取的商品详情界面的信息key进行修改，其中'评论数'是另一种方式获取的 TITLE_LABEL：PARAMETER_LABEL修改后excel的表头也做相应的修改 GOOD_LABEL：无需修改，默认该四个信息都爬取 need_list：能直接从html解析后的标签文件中获取的 ''' # excel表头 TITLE_LABEL = ['商品名称', '价格', '商家', '商品详情地址', '工艺', '图案', '风格', '材质', '形状', '直径', '评论数'] # html中对应TITLE_LABEL的key GOOD_LABEL = ['name', 'price', 'shop', 'detail_addr'] # TITLE_LABEL中商品详情页（即点进单个商品界面）想爬取的数据在html中key，'评论数'一定要放在最后 PARAMETER_LABEL = ['工艺', '图案', '风格', '材质', '形状', '直径', '评论数'] # 将PARAMETER_LABEL去掉'评论数'即为need_list need_list = PARAMETER_LABEL[:-1] # 将搜索页的key和单个商品详情页的key组合起来 TOTAL_LABEL = GOOD_LABEL + PARAMETER_LABEL # excel文件的保存路径 SAVE_PATH = '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/385416c6c423d7b3f5f313671e615b62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5e1280f1552b80f215262a25e79f27b/" rel="bookmark">
			安克创新音频算法工程师(应届生)招聘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		职位描述：
负责音频处理算法的研发和优化，包括但不限于噪声抑制、回声消除、声反馈抑制、音效、声纹、唤醒、指令词识别等。
持续跟进国际前沿技术方向，预研端侧可落地的音频技术，打造技术影响力。
对音频处理系统进行模拟和实验，验证算法的性能， 参与音频算法的性能评估和调试，解决实际应用中的问题。
配合工程同学将算法落地至会议硬件、耳机、智能camera以及各种IOT和智能家居产品。
职位要求：
信号处理、计算机、电子信息、自动化等相关专业硕士及以上学历。
在音频信号处理、唤醒、关键词、声纹、声学事件检测一个或多个方向有较深入研究。
熟练掌握C、Python、Shell等编程语言，熟悉常用的深度学习框架。
高水平学术论文、竞赛经验加分。
好的团队协作精神，较强的沟通能力以及英文读写能力，对技术研发有热情。
具有良好的团队合作精神和沟通能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59d5b5f299121ee58f6ff1365b1e6a54/" rel="bookmark">
			Docker指定容器使用内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker指定容器使用内存 作者：铁乐与猫
如果是还没有生成的容器，你可以从指定镜像生成容器时特意加上 run -m 256m 或 --memory-swap=512m来限制。
-m操作指定的是物理内存，还有虚拟交换分区默认也会生成同样的大小，而–memory-swap的值则等于两者的总和大小。
如果是已在运行中的容器，可以通过docker update命令来实现：
docker update --help可查看到用法，如上图所见。
-m --memory 为设置内存最大值；默认单位为byte，可以使用K、G、M等带单位的字符串。
–memory-reservation 是弹性控制内存大小，防止损失性能，建议要开。当宿主机资源充足时，允许容器尽量多地使用内存，当检测到内存竞争或者低内存时，强制将容器的内存降低到memory-reservation所指定的内存大小。按照官方说法，不设置此选项时，有可能出现某些容器长时间占用大量内存，导致性能上的损失。
–-memory-swap：等于内存和swap分区大小的总和，设置为-1时，表示swap分区的大小是无限的。默认单位为byte，可以使用K、G、M等带单位的字符串。如果–memory-swap的设置值小于–-memory的值，则使用默认值，为–-memory-swap值的两倍。
默认情况下，容器可以使用主机上的所有空闲内存。
docker会自动为容器在目录/sys/fs/cgroup/memory/docker/&lt;容器的完整长ID&gt;中创建相应cgroup配置文件，所以在宿主机内查看容器使用的内存配额可以通过查看相应的配置文件得知：
好比如上图
在cgroups的配置文件中，查看到容器的内存大小为256MB (256×1024×1024=268435456B)，内存和swap加起来大小为512MB(512x1024x1024=536870912)。
注：我实际查看线上的容器时没有限制内存和swap的大小，后来自行敲了docker update --memory-swap=512 容器ID 的命令重新再看才变成512MB了。
例：
core@tielemao /data/mysql_wp_db/mysql $ docker update -m 256m d17d6 d17d6 core@tielemao /data/mysql_wp_db/mysql $ docker update --memory-swap 512m d17d6 d17d6 core@tielemao /data/mysql_wp_db/mysql $ docker stats d17d6 CONTAINER CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS d17d6 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59d5b5f299121ee58f6ff1365b1e6a54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f622e69f73eb504d9fc472b8a7c0052/" rel="bookmark">
			tensorrt推理 onxx转engine代码（python），cyclegan网络推理（python、C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将onnx文件导出为engine，FP16格式
​ ​ import tensorrt as trt import pycuda.driver as cuda import pycuda.autoinit # 加载ONNX文件 onnx_file_path = 'model.onnx' engine_file_path = 'model_tesfp16.trt' TRT_LOGGER = trt.Logger(trt.Logger.WARNING) builder = trt.Builder(TRT_LOGGER) network = builder.create_network(1) parser = trt.OnnxParser(network, TRT_LOGGER) # 解析ONNX文件 with open(onnx_file_path, 'rb') as f: data = f.read() parser.parse(data) # 构建TensorRT引擎 builder_config = builder.create_builder_config() builder_config.max_workspace_size = 4*(1 &lt;&lt; 30) builder_config.set_flag(trt.BuilderFlag.FP16) engine = builder.build_engine(network, builder_config) # 构建TensorRT引擎 # builder_config = builder.create_builder_config() # builder_config.max_workspace_size = 1 &lt;&lt; 30 # # builder_config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f622e69f73eb504d9fc472b8a7c0052/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3efac4246fb2c600357c90fe6046642/" rel="bookmark">
			Ansible 安装与使用/ssh免密互信-以及解决免密不生效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器
HostName IP CPU MEM DES
k8s-master 172.26.48.4 2 Core 2G k8s master 节点
k8s-node1 172.26.48.5 1 Core 2G 应用节点
k8s-node2 172.26.135.94 1 Core 2G 应用节点
| HostName | IP | CPU | MEM | DES
|–|–|–|–|–|–|
| k8s-master |172.26.48.4 |2Core | 2G | k8s master 节点 |
| k8s-node1 |172.26.48.5 |1 | 2G | 应用节点 |
| k8s-node2 | 172.26.135.94 | 1| 2G | 应用节点|
不要忘记修改本地/etc/hosts文件
# 将以下内容追加(&gt;&gt;)到 /etc/hosts文件 [root@k8s-master ~]# cat &lt;&lt;EOF &gt;&gt; /etc/hosts 172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3efac4246fb2c600357c90fe6046642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eda56d499b41c6d03143ef63b81d46ba/" rel="bookmark">
			使用Go构建一个Postgres流平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 Go 通道从拉推模型转向更高效的流方法。这通过重叠拉取和推送阶段来提高性能，减少总体处理时间和延迟。
Go通道提供数据同步、资源管理和并发处理。它们允许 goroutine 安全地通信和交换数据。这些源实现了每秒 10-12k 事务的吞吐量，最小延迟为 1-5 秒，比之前使用拉推的 30 秒有了显着改进。
在PeerDB，我们的使命是创建一个 Postgres 优先的数据移动平台，使数据从 Postgres 流式传输到数据仓库、队列和存储变得快速、简单。我们的工程重点围绕数据移动速度提高 10 倍、成本效益和硬件优化。
在这篇博文中，我们将深入探讨最近从拉推模型到使用Go goroutine 的更高效流媒体方法的转变。让我们探讨为什么流式传输至关重要，以及这种变化如何显着提高性能。
Pull-and-Push推拉模型
拉推模式：将行提取到内存中的一个数组，然后将它们移动到目标位置。
虽然这种方法在批量较小的情况下效果不错，但在批量较大的情况下就出现了问题。
具体来说，我们无法在拉取的同时并行推送，导致管道效率不高。在我们的典型设置中，拉取和推送时间的比例为 60-40。
_// sync all the records normally, then apply the schema delta after NormalizeFlow._type RecordsWithTableSchemaDelta struct {
RecordBatch *RecordBatch // wrapper for "Records []Record" TableSchemaDeltas []*protos.TableSchemaDelta
RelationMessageMapping RelationMessageMapping
}
转向流式处理
我们的新方法是在从 PostgreSQL 提取数据的同时，分批缓冲并并发地将数据推送到目标（如 Snowflake）。这种流水线式数据传输具有显著优势：
提高效率：管道化允许我们重叠拉取和推送阶段，从而减少整体处理时间。减少延迟：使用流水线技术，数据可以更快地到达目的地，从而提高整个系统的响应速度。 这是更改后的共享结构：
type CDCRecordStream struct {
// Records are a list of json objects.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eda56d499b41c6d03143ef63b81d46ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a5a815489cf91e1b885040a7989b64f/" rel="bookmark">
			Java的JDBC编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、数据库编程的必备条件二、Java的数据库编程：JDBC三、JDBC的工作原理四、JDBC的使用4.1 JDBC 开发案例4.2 JDBC 使用步骤总结 五、JDBC常用的接口和类5.1 JDBC API5.2 数据库连接 Connection5.3 Statement 对象5.4 ResultSet 对象 七、内容总结 一、数据库编程的必备条件 编程语言：Java、C、C++、Python等数据库：Oracle、MySQL、SQL Server等数据库驱动包：不同的数据库，对应不同的编程语言提供了不同的数据库驱动包，如：MySQL提供了Java的驱动包mysql-connector-java，就可以使用Java这门编程语言在程序中操作MySQL，同样，要使用Java操作Oracle数据库，需要Oracle的数据库驱动包ojdbc。 二、Java的数据库编程：JDBC JDBC，即 Java Database Connectivity，Java数据库连接，是一种用于执行SQL语句的Java API（Application Programming Interface，即应用程序编程接口），它是Java中的数据库连接规范，这个API 由 java.sql.* ，javax.sql.* 包中的一些类和接口组成，为Java开发人员操作数据库提供了一个标准的API，可以为多种关系数据库提供统一访问。
三、JDBC的工作原理 JDBC 为多种关系数据库提供统一访问方式，作为特定厂商数据库访问API的一种高级抽象，主要包含一些通用的接口类。
JDBC访问数据库的层次结构：
JDBC的优势：
Java语言访问数据库操作完全面向抽象接口编程开发数据库应用不用限定在特定数据库厂商的API程序的可移植性大大增强 四、JDBC的使用 4.1 JDBC 开发案例 准备数据库驱动包，并将其添加到项目的依赖中：
在项目中创建文件夹 lib ，并将依赖包 mysql-connector-java-5.1.47.jar 复制到 lib中，再配置该 jar包到本项目的依赖中：
第一种方法：右键点击项目Open Module Settings，在Modules中，点击项目，配置Dependencies，点击+，JARS or Directories，将该lib文件夹配置进依赖中，表示该文件夹下的jar包都引入作为依赖（步骤太多，本人不建议使用）
第二种方法：右键点击 lib 文件夹，在点开的窗口中 点击 Add as Library 就可以了，是将这个目录标记成“库”
案例1： /** * 数据库的修改操作 * @throws SQLException */ public static void main(String[] args) throws SQLException { Scanner scanner = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a5a815489cf91e1b885040a7989b64f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/351297ac4684267567be144943f0db3d/" rel="bookmark">
			使用 Gorm 进行事务和错误处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 GORM 中管理事务和错误的全面指南，以确保可靠的数据库操作 在数据库管理的世界中，确保数据完整性至关重要。GORM，强大的 Go 对象关系映射库，为开发人员提供了维护数据一致性和优雅处理错误的必要工具。本文将作为您全面的指南，帮助您掌握在 GORM 中进行事务和错误处理。我们将深入探讨使用事务来确保原子性，并探索有效处理错误和回滚的策略，以保持您的数据库操作在您的 Go 项目中可靠和健壮。
在 GORM 中使用事务 事务在确保数据一致性和完整性方面起着至关重要的作用。GORM 的事务支持使您能够将多个数据库操作视为一个工作单元。
步骤 1：开始事务
使用 GORM 的 Begin 方法来启动一个事务：
tx := db.Begin() 步骤 2：执行操作
在事务中执行您的数据库操作：
if err := tx.Create(&amp;User{Name: "Alice"}).Error; err != nil { tx.Rollback() return err } 步骤 3：提交或回滚
在执行操作后，可以选择提交或回滚事务：
if err := tx.Commit().Error; err != nil { tx.Rollback() return err } 在 GORM 中处理错误和回滚 在发生故障的情况下，优雅的错误处理和回滚对于维护数据一致性和完整性至关重要。
步骤 1：处理错误
检查错误并适当地处理它们：
if err := tx.Create(&amp;User{Name: "Bob"}).Error; err !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/351297ac4684267567be144943f0db3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/012ae875482b0ecc205c7bf3c47aa201/" rel="bookmark">
			ubuntu连接蓝牙耳机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人也是经历了重重困难，特写此篇希望对读者能够带来帮助
1. 编辑 /etc/bluetooth/main.conf 文件，设定ControllerMode = bredr 这一步使用vim编写完成后，保存退出的时候，会显示说没有修改权限，执行以下命令
sudo chmod 777 /etc/bluetooth/main.conf 然后再保存退出即可，vim的使用教程我这里不再赘述
2. 重启蓝牙服务 在终端输入一下命令重启蓝牙服务：
sudo /etc/init.d/bluetooth restart 然后如果出现以下错误说：
Restarting bluetooth (via systemctl): bluetooth.serviceJob for bluetooth.service failed because the control process exited with error code.
See “systemctl status bluetooth.service” and “journalctl -xe” for details.
failed!
输入以下命令解决这个问题：
systemctl reload dbus 然后再输入一遍上面那个命令重新重启蓝牙服务即可
3. 在 Ubuntu 设置中找到蓝牙，搜索你的耳机进行配对 因为我的耳机是airpods，所以我的配对方式是 长按充电盒上的按钮，直到指示灯变成白色的呼吸状态，进入蓝牙配对模式。
然后在 Ubuntu 设置中找到蓝牙，搜索你的耳机进行配对
如果连接上了，但是没有声音。就按如下的操作。
在 Ubuntu 设置中找到声音，设定声音输出设备为 AirPods。
4. 连接成功之后 连接成功之后可以再把那个设置加上#注释掉。就是第一步修改那个文件里面的你写的那一行。
这一步可做可不做。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8903e2d6ebbe8af30d28233c665bc325/" rel="bookmark">
			nginx的全局配置和HTTP相关配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
资源类型：
网站访问量
网站访问量统计的重要指标
HTTP1.0和1.1的问题
HTTP2协议 HTTP 请求访问的完整过程
HTTP 请求报文 http协议状态码分类
http协议常用的!!状态码!! I/O 的具体实现方式 通过官方 yum 源安装nginx
Nginx 核心模块 Nginx的配置文件的组成部分：
systemctl start nginx: （组装启动，退出 ）systemctl stop nginx.
默认的nginx.conf 配置文件格式说明 绿色自己加的
location 的详细使用 #语法规则： Location @重定向 Nginx 四层访问控制
Nginx 账户认证功能
自定义错误页面（跳转）
检测文件是否存在 （可自行创建）
长连接配置 作为下载服务器配置
范例: 实现下载站点 限流限速 规则必须写入http语句块里
限制并发连接数 规则必须写入http语句块里
实现百度云盘非会员限度限流功能: Nginx 状态页 echo 模块实现信息显示 自定义变量
常用内置变量 server { 都在里面
自定义默认格式日志 自定义json格式日志 支持多个
json 格式的日志访问统计 关于 favicon.ico
Nginx 压缩功能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8903e2d6ebbe8af30d28233c665bc325/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67d7c702fdd5a844492d8d40442adada/" rel="bookmark">
			华为交换机镜像端口配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、进入交换机（进入web页面）
1.配置vlan
二、配置镜像流量
1.配置观察口
2.配置镜像端口
3.结果展示
4.关闭接口后的效果
三、镜像流量的删除
1.删除镜像流量接口
2.删除镜像监听口
一、进入交换机（进入web页面） 1.配置vlan Vlan 12
Ip address 192.168.12.1 24
Interface g0/0/15
Port default vlan 12
二、配置镜像流量 1.配置观察口 Observer-port 1 interface g0/0/15
2.配置镜像端口 Interface g0/0/1
Port-mirroring to observer-port 1 both
3.结果展示 4.关闭接口后的效果 interface g0/0/15
shut down
三、镜像流量的删除 1.删除镜像流量接口 Interface g0/0/21
Undo port-mirroring to observe-port 4
2.删除镜像监听口 Undo observe-port 4 g0/0/15
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0561fd281b9ed7f92d8e4672ea1be64/" rel="bookmark">
			python的 time &amp; datetime模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础知识 对时间的处理可以归类为三种 时间的显示
时间的转换
时间的运算
python中常用的几种时间表示方式 时间戳：从1970年1月1日0时0分开始往后计算总共秒数
根据自定义格式化时间字符串：例如 "2023-11-7 11:41"
元组
UTC:世界协调时间，世界标准时间无时区，中国背景为东八区，也就是UTC+8小时 time模块：一般用来打印时间戳和时间格式的转换 time.localtime([secs]) #将时间戳转换为元组，默认为当前时间戳。参数可以修改成其他时间戳
time.gmtime([secs]) #与time.localtime()类似，但是显示的是UTC时间在中国需要时间减8小时
time.time() #时间戳
time.mktime() #把元组转换为时间戳
time.sleep() #睡眠多少秒
time.sleep() #把元组转换为"Tue Nov 7 12:07:52 2023"这种格式，默认为当前时间戳
time.ctime() #把时间戳转换为"Tue Nov 7 12:07:52 2023"这种格式，默认为当前时间戳
time.strftime(format[,t]) #把元组格式化为字符串，默认为当前时间
示例：
time.strftime("%Y-%m-%d %X")
time.strftime("%Y-%m-%d %H:%M")
print(time.strptime(str[,format)]) #把字符串转换为元组
示例：
time.strptime("2023-11-07 12:16","%Y-%m-%d %H:%M")
datetime模块：一般用来显示日期和日期的运算 datetime.date 表示日期的类
datetime.date.today() #日期
datetime.datetime #表示日期时间类
datetime.datetime.now() #当前时间
datetime.timedelta #时间间隔运算类
示例：
t = datetime.datetime.now()
t - datetime.timedelta(days=3) #当前时间减去3天
t + datetime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0561fd281b9ed7f92d8e4672ea1be64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e3cbe3234882006d2a7a17431566da2/" rel="bookmark">
			2023软件设计师备考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件设计师备考 5月考试自我总结知识点汇总目录第一章 计算机组成与体系结构1. 数据的表示2. 运算器与控制器（高频）3. Flynn分类法4. CISC与RISC （高频）5. 流水线技术（一般必考）6. 存储系统（高频）7. 总线系统8. 可靠性9. 校验码10.计算机性能指标 操作系统操作系统相关概念1.进程状态2.前驱图3.信号量与PV操作4.死锁与银行家算法5.段页式存储6.页面置换算法7.磁盘管理8.绝对路径与相对路径9.索引文件10.位示图11.I/O设备管理 数据库系统计算机网络与信息安全系统开发基础面向对象 5月考试自我总结 第一次开始备考软件设计师考试，本人专业是计算机科学与技术，备考大概两个月，前天（5月27日）才结束，上午题表现良好，下午题遭遇了历史滑铁卢，试题四和试题五代码填的一塌糊涂，一般不怎么考的邻接图也上场表演了，唉！不管结果如何，咱就先总结一波，下次还有机会继续考（虽然很失落，但前路一直得走…）不过总结一次性写不完呀，每天都攒点！
知识点汇总目录 第一章 计算机组成与体系结构 1. 数据的表示 进制的转换
本考点主要是考的内存地址的计算、结合IP地址来考虑
【要点】
（1）十进制转R进制（短除法）
（2）R进制转十进制（按权展开法）
（3）二进制转八进制、转十六进制（分组快速转换）
主要是需要熟练掌握二进制与十六进制的互转，来熟练运算IP地址的转换和内存地址的转换。原码/反码/补码/移码的特性与表示
本考点主要是考原码、反码、补码与移码之间的关系，结合题目描述判断正误，或者是计算某种码值的表示范围或数值个数。
【要点】
（1）原码、反码、补码、移码的转换规则
原码：符号位+数值绝对值
反码：负数的反码是符号位不变，数值位按位取反。正数的反码是原码本身。
补码：负数的补码是符号位不变，数值位在反码的基础上加一。正数的补码是原码本身。
移码：正数和负数的移码都是在补码的基础上符号位取反。
注意：0的原码和反码不唯一，补码和移码唯一。因为0分为+0和-0，因此原码和反码不唯一。
（2）原码、反码、补码、移码的取值范围浮点数的表示
本考点是给定一些描述（关于浮点数构成和运算规则），浮点数的运算过程中对齐方式和理解尾数、阶码等含义。
【要点】
（1）浮点数各部分表示意义：N=尾数*基数^指数
一般尾数用补码，阶码用移码
阶码的位数决定浮点数表示的范围，尾数的位数决定浮点数的有效精度。阶码位数越大范围越大，尾数的位数越大精度越高。
（2）浮点数的运算规则：对阶——&gt;尾数计算——&gt;结果格式化
对阶时，尾数小的向大的看齐，对阶是通过尾数位数较小的右移实现。逻辑运算
本考点主要考察给定运算表达式计算结果或等价表达式，判断短路运算。
【要点】
（1）关系运算符优先级：&lt;、&gt;=、&lt;=、&gt;
逻辑运算符：||（或）、&amp;&amp;（与）、⊕（异或）、！（非）
（2）短路原则：在逻辑表达式的求解中，并不是所有逻辑运算符都要被执行。例如：a&amp;&amp;b&amp;&amp;c 只有a为真时，才需要判断后面b和c的状态，若a为假，不必判断b和c，整个都为假。 2. 运算器与控制器（高频） 考点：本章考点主要是针对计算机中存在的部件判断是属于运算器还是控制器，或者给定部件功能判断具体描述的部件。
【要点】
运算器
（1）算术逻辑单元ALU：数据的算数运算和逻辑运算；
（2）累加寄存器AC：通用寄存器，为ALU提供一个工作区，用来暂存数据；
（3）数据缓冲寄存器DR：写内存时，暂存指令或数据；
（4）状态条件寄存器PSW：存状态标志与控制标志。（有争议性，也有将其归为控制器的）控制器
（1）程序计数器PC：存储下一条要执行指令的地址；
（2）指令寄存器：存储即将执行的指令；
（3）指令译码器ID：对指令中的操作码字段进行分析解释；
（4）时序部件：提供时序控制信号。 3. Flynn分类法 考点：分类法主要是考分类与指令匹配，或者是各种体系结构类型的属性和特点。常考的典型类型系统：阵列处理机、超级向量处理机，常考类型：SIMD、MISD。
【要点】
Flynn分类法将计算机分为：单指令单数据流（SISD）、单指令多数据流（SIMD）、多指令单数据流（MISD）、多指令多数据流（MIMD）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e3cbe3234882006d2a7a17431566da2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8cca89383ad20cd05d5f87caa65b44a/" rel="bookmark">
			小发猫论文同义句转换器—一键降重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小发猫论文同义句转换器是一种人工智能工具，旨在帮助用户将论文中的句子转换成同义句。该工具可以帮助用户在撰写论文时，更加轻松地表达相同的意思，从而提高论文的质量和可读性。
小发猫官网 ---&gt;&gt;&gt; http://www.xiaofamao.com/
1、论文降重修改句子软件
小发猫论文同义句转换器的原理是基于自然语言处理技术和机器学习算法。它通过分析大量的语料库，学习不同语言的表达方式，并根据这些数据来生成新的同义句。该工具不仅可以对英文进行转换，还可以对其他语言进行转换。
2、论文降重同义句转换网站
小发猫论文同义句转换器的优点是显而易见的。首先，它可以大大缩短写作时间，避免重复性劳动。其次，它可以提高论文的多样性和可读性，避免同一意思的句子多次出现。最后，它可以提高论文的质量和水平，使论文更加专业和规范。
3、转换句子意思不变的软件
使用小发猫论文同义句转换器非常简单。用户只需要将需要转换的句子输入到该工具中，点击“转换”按钮即可。该工具会根据用户输入的句子自动生成新的同义句，并且还可以提供多个选项供用户选择。用户可以根据自己的需要选择最合适的同义句，并将其插入到论文中。
4、小发猫近义词词典
除了简单的转换功能外，小发猫论文同义句转换器还提供了其他一些有用的功能。例如，该工具可以帮助用户检查句子的语法和拼写错误。另外，该工具还可以帮助用户将论文中的长句缩短或将短句扩展成更丰富的句子。这些功能都可以帮助用户更加高效地撰写论文。
总的来说，小发猫论文同义句转换器是一种非常有用的写作工具。它可以帮助用户更加轻松地表达相同的意思，从而提高论文的质量和可读性。如果您正在撰写论文或需要帮助改写一些句子，不妨试试小发猫论文同义句转换器，相信它会给您带来很多帮助。
参考资料：
毕业论文怎么写能降低重复率实用
论文降重一天能够搞定吗
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/771d9aef7fd3b8c87f778cfb3ce96465/" rel="bookmark">
			iOS 让界面元素的文字随着语言的更改而变化——本地化文字跟随
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在我的 App 内置的设置中，修改了语言，这时需要让当前界面的文本跟着改变语言。
解决方法是：添加一个观察者，观察 localize 本地语言的通知，然后一有变化就调用自定义的方法执行操作。（而设置中其实是改变了 localize 的语言）
override func viewDidLoad() { tableForChoose = tableChoose super.viewDidLoad() NotificationCenter.default.addObserver(self, selector: #selector(setText), name: NSNotification.Name(LCLLanguageChangeNotification), object: nil) } @objc func setText() { btn_complete?.setTitle("done".localized(), for: .normal) tableForChoose?.reloadData() tableForChoose?.selectRow(at: defaultChoose ?? IndexPath(row: 0, section: 0), animated: true, scrollPosition: .middle) if let cell = tableForChoose?.cellForRow(at: defaultChoose ?? IndexPath(row: 0, section: 0)) { cell.accessoryType = .checkmark } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4415f0ada33e10c0e4f48b852aeefbf/" rel="bookmark">
			01. VBA从入门到精通——录制宏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在功能区显示开发工具选项： excel表功能区右击→常用→选择显示开发工具选项→确定
开发工具选项中按钮作用： Visual Basic:打开VBA窗口
宏：查看要录制的宏
录制宏：准备录制宏
使用相对引用：录制宏的时候对单元格的引用做一个设置
宏安全性：对宏的使用做安全设置，一般设置为禁用所有宏，并发出通知，此时打开带有宏代码的工作薄时会出现警告标记，如果宏可信就选择启动
录制宏： 点击录制宏按钮/左下角开始录制新宏打开对话框
定义名字
选择保存位置：一般选择保存当前工作簿
点击确定按钮就开始录制了：此时大部分操作excel表的动作都会被录制下来并自动生成对应的代码
点击左下角/开发工具中的停止宏录制
查看录制完的宏代码： 点击开发工具中 Visual Basic打开VBA窗口→双击模块中的模块1
宏代码的作用： 把录制的宏代码进行编辑加工用在其他的程序中
运行录制的宏完成另一个工作表的制作：
打开VBA窗口运行F5/者点击运行宏/设置的快捷键运行
手动写代宏代码： 打开VBA窗口→插入→模块 保存有宏代码的工作簿： 需要Excel启动宏的工作簿类型，其扩展名为.xlsm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae20271c3cf36c9f3d677f907c58b758/" rel="bookmark">
			ACL2023长论文：对话系统相关论文汇总【1】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ACL 2023长论文 对话系统相关汇总摘要 2023.1.7 整理ACL长论文收录的对话系统相关论文
这系列论文在对话系统领域涉及多个关键主题。其中，Prompter以动态前缀适应零样本对话状态跟踪，显著优于先前方法。另外，采用双语模型的DAMP在全球市场上展现出强大的多语言性能。视频对话理解方面，VSTAR数据集推动了对话与场景、主题的深度理解。最后，结合对比潜变量的个性化对话生成模型CLV，有效整合了稀疏与密集人物描述，提升了个性化生成的质量。这些研究推动了对话系统在各个方面的创新和性能提升。
Yajiao Liu, Xin Jiang, Yichun Yin, Yasheng Wang, Fei Mi, Qun Liu, Xiang Wan, Benyou Wang: One Cannot Stand for Everyone! Leveraging Multiple User Simulators to train Task-oriented Dialogue Systems. 1-21 摘要：用户模拟器是设计成模仿人类用户的代理；最近的研究进展发现，针对用户模拟器进行优化的面向任务的对话（ToD）系统能够更好地满足人类用户的需求。然而，如果ToD系统仅定制给一个特定的即时用户模拟器，可能导致ToD系统不够优化，因为人类用户的行为可能各不相同。在本文中，我们提出了一个名为MUST的框架，通过充分利用多个用户模拟器来优化ToD系统。实施MUST的主要挑战包括：1）在每个优化步骤中如何自适应确定与ToD系统交互的用户模拟器，因为ToD系统可能对某些特定用户模拟器进行了过度拟合，同时对其他模拟器进行了欠拟合；2）如何避免对于连续多个优化步骤未被选择的模拟器的适应性遗忘。为了解决这些挑战，我们将MUST制定为多臂老虎机（MAB）问题，并提供了一种方法。
Björn Bebensee, Haejun Lee: Span-Selective Linear Attention Transformers for Effective and Robust Schema-Guided Dialogue State Tracking. 78-91 摘要：在模式引导的对话状态跟踪模型中，通过使用服务模式的自然语言描述来估计对话的当前状态，以便泛化到未见的服务。先前的生成方法按顺序解码槽值，对模式变化的泛化效果不佳，而判别方法分别编码历史和模式，未考虑槽间和意图-槽依赖关系。我们引入了SPLAT，这是一种新颖的架构，通过将输出限制在有限的预测空间内，实现了比先前方法更好的泛化和效率。与此同时，我们的模型允许在描述和历史之间进行丰富的注意力，同时通过整合线性时间注意力来保持计算成本受限。我们在Schema-Guided Dialogue（SGD）和MultiWOZ数据集上展示了我们模型的有效性。我们的方法显著改进了现有模型，在SGD数据集上实现了85.3的JGA。此外，我们在SGD-X基准上展示了增强的鲁棒性：我们的模型胜过了体积超过30倍的D3ST-XXL模型5.0个点。
Yiyang Li, Hai Zhao: EM Pre-training for Multi-party Dialogue Response Generation. 92-103 摘要：对话响应生成要求代理根据当前对话历史生成响应，在已经深入研究了两方对话的情况下，对于多方对话留下了巨大的空白。与两方对话不同，其中每个响应都是对其前一次话语的直接回复，在多方场景中，在生成响应话语之前应指定响应话语的收件人。由于大量的两方会话数据，已经提出了各种预先训练的两方对话响应生成语言模型。然而，由于多方对话数据集中缺少带有注释的收件人标签，因此难以将它们用于预训练多方对话响应生成模型。为了克服这一障碍，我们提出了一种期望最大化（EM）方法，通过迭代执行期望步骤生成收件人标签，并执行最大化步骤来优化响应生成模型。理论分析和广泛实验证明了我们提出的方法的可行性和有效性。本文的官方实现可在 https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae20271c3cf36c9f3d677f907c58b758/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8f1c83045392fdfa3164ee12be586f3/" rel="bookmark">
			索引和事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、索引1.1 概念1.2 作用1.3 使用场景1.4 使用 二、事务2.1 为什么要使用事务2.2 事务的概念2.3 事务的使用 三、内容重点总结 一、索引 1.1 概念 索引是一种特殊的文件，包含对数据表所有记录的引用指针。在MySQL中，索引是基于一个或多个列的数据结构，是一种数据库对象，它们存储有序的键值对，其中键是列的值，而值是指向表中数据行的物理位置。可以对表中的一列或多列创建索引，并指定索引类型，各类索引有各自的数据结构实现。
1.2 作用 数据库中的表、数据、索引之间的关系类似于书架上的图书、书籍内容、书籍目录的关系。索引可用于快速定位，检索数据，加快查询的速度，避免对表进行遍历，是对查询操作的优化手段
索引能提高查询的速度，但也会有一定的代价 占用更多的空间，生成索引，需要一系列的数据结构和额外的数据，来存储到硬盘空间中可能会降低插入、更新和删除操作的速度 1.3 使用场景 考虑对数据库中表的某列或某几列创建索引，需要考虑以下几点：
数据量较大，经常对列进行条件查询该表的插入和对这些列的修改操作频率较低索引会占用额外的磁盘空间
满足上述条件，考虑对表中这些字段创建索引，来提高查询效率，但如果不是条件查询列，或者经常使用插入、修改操作，或者磁盘空间不足时，不考虑创建索引 1.4 使用 创建主键约束（PRIMARY KEY）、唯一约束（UNIQUE）、外键约束（FOREIGN KEY）时，会自动创建对应列的索引
查看索引 show index from 表名;
-- 查看学生表已有的索引 show index from student; 创建索引
要创建索引的列是非主键、非唯一约束、非外键的字段 create index 索引名 on 表名(列名)
-- 创建课程表中name 字段的索引 create index idx_course_name on classes(name); 删除索引
自动创建的索引不能删除 drop index 索引名 on 表名;
-- 删除课程表中name字段的索引 drop index idx_course_name on course; 拓展：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8f1c83045392fdfa3164ee12be586f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37f91186002a820f071f8ebf63562427/" rel="bookmark">
			MyCat入门配置详解和常见九种数据分片算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyCat入门配置详解和常见九种数据分片算法 第一节 分库分表概述 1、为什么要拆分？ ①MySQL 实例内部结构 [1]单一架构 [2]复制架构 尽管搭建了复制架构，但是实际上从逻辑上来说仍然只有一个 db_hr 数据库。
②性能瓶颈 MySQL 工作过程中的性能瓶颈主要来自于下面三个方面（同等硬件条件下）：
数据存储量：单表 1000 万条数据达到极限；500 万条开始性能明显下降；300 万条开始就应该考虑拆分。I/O 瓶颈：关系型数据库以硬盘作为主要存储介质，所以必然存在 I/O 瓶颈。访问量瓶颈：通常 MySQL 的最大连接数默认是100，最大可以达到 16384。 由此我们可以看出，对数据库进行拆分主要是出于数据量不断增加的挑战。
2、拆分方式 ①垂直拆分 垂直拆分是最容易想到的拆分方式。它按照项目的业务功能模块，把从属于不同模块的数据库表分散到对应的不同数据库中。
这种拆分方式的优缺点是：
优点 拆分规则明确，按照不同的功能模块或服务分配不同数据库数据维护与定位简单 缺点 并没有解决单表数据量太大的问题会出现跨库 join需要对上层应用系统的代码进行重构，修改原有的事务操作 ②水平拆分 针对一张数据量很大的表，把它拆分为多张表，数据分流保存到各个拆分后的数据库表中。
如果数据量继续增加，超过一个单库能够容纳的极限则需要继续分库：
这种拆分方式的优缺点评价：
只分表不分库： 同库无分布式事务问题，事务处理相对简单同库无跨库 join 问题表拆分后不存在超大型表的性能问题只要拆分规则定义好，很难出现扩展性的限制，但拆分规则设定并不简单，规则一定会和业务挂钩，如根据 id、根据时间等。 既分表又分库： 异库存在分布式事务问题异库存在跨库 join 问题多数据源管理难度加大，代码复杂度增加 3、MyCat 简介 尽管拆分后必然要面对很多问题，但是随着数据量的增加又不得不拆分。所以我们开发的上层应用系统必须有能力对接拆分后的多个数据库。MyCat 就是帮助我们实现这一功能的数据库中间件。
MyCat 是一款数据库中间件。
对于应用程序来说完全透明：不管底层的数据如何拆分，应用只需要连接 MyCat 即可完成对数据的操作。
支持 MySQL、SQL Server、Oracle、DB2、PostgreSQL 等主流数据库。
MyCat 不存储数据，它只是数据的路由。
底层拦截用户发送过来的 SQL 语句并进行分析：如分片分析、路由分析、读写分离分析、缓存分析等，然后将此 SQL 发往后端的真实数据库，并将返回的结果做适当的处理，最终再返回给用户。
Mycat的特性如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37f91186002a820f071f8ebf63562427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fd001a671004adb6aca21eff8bbe09c/" rel="bookmark">
			前端常用网址汇总（不断更新哦）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端常用网址汇总 好看的插件echarts获取地图echarts常用比较炫酷的样式vant动效 codepen轮播插件tab分页表格类页面的框架layuiFlutter可以代替图标的100+个Unicode符号html2canvas合成海报长按保存vscode必备插件 转化工具pug html互相转化模拟测试数据图片压缩提示 工作中使用到的接口文档测试提交bug的网站工作提交用的禅道上传设计图查看设计图的蓝湖抠图网站Windows的cmd中如何关闭端口uniapp小程序写echartsdownLoad 纯前端下载图片、文件localStorage设置过期时间 web资源responsivelyfigletreadme.sosmalldevsmartmockupspfpmakerstorytaletype-scaleremove-bgmetatags 好看的插件 echarts https://echarts.apache.org/examples/zh/index.html#chart-type-map
百度echarts
获取地图 获取地图json
echarts常用比较炫酷的样式 https://gallery.echartsjs.com/explore.html#sort=ranktimeframe=allauthor=all
vant 链接: https://vant-contrib.gitee.io/vant/#/zh-CN/.
动效 codepen https://codepen.io/
轮播插件 https://www.swiper.com.cn/
tab分页 http://www.mescroll.com
表格类页面的框架layui https://www.layui.com/
Flutter Flutter中文网
可以代替图标的100+个Unicode符号 https://www.asni.cn/1899
html2canvas合成海报长按保存 海报合成
vscode必备插件 VScode必备插件
转化工具 pug html互相转化 https://pughtml.com/
模拟测试数据 http://jsonplaceholder.typicode.com/
图片压缩 https://tinypng.com/
http://www.zuohaotu.com/image-compress.aspx
提示 https://blog.csdn.net/qq_33368846/article/details/84317120
工作中使用到的 接口文档 http://192.168.1.202/group/26
测试提交bug的网站 http://www.hibug.cn/invite_join.html?project_id=GmBC3wZ7Ir4=
工作提交用的禅道 http://exk.bjzhhs.cn:81/zentao/user-login-L3plbnRhby9teS10YXNrLmh0bWw=.html
上传设计图查看设计图的蓝湖 https://lanhuapp.com/web/#/item
抠图网站 https://www.remove.bg/zh
Windows的cmd中如何关闭端口 https://blog.csdn.net/wang20010104/article/details/124346599
uniapp小程序写echarts https://ext.dcloud.net.cn/plugin?id=271
downLoad 纯前端下载图片、文件 http://danml.com/download.html
localStorage设置过期时间 https://www.cnblogs.com/ricolee/p/localstorage-expiretime.html
web资源 responsively 你可以在上面输入你的 web 网站，一次性查看它在各个设备下的响应式布局表现~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fd001a671004adb6aca21eff8bbe09c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/73/">«</a>
	<span class="pagination__item pagination__item--current">74/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/75/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>