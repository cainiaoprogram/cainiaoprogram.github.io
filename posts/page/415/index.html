<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c9cd8e6f9bb2f65506e73696f2e1fd6/" rel="bookmark">
			常用的深度学习模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/jackkang01/article/details/81064114
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c074ef080c4eacfb4a548db30eb971db/" rel="bookmark">
			网易云音乐评论爬取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我是个很喜欢听歌的人，手机里面下了几百首歌，而且还会每个月还会增加几首，因为我觉得听歌能让我活得更有趣。平常的我，喜欢听一些流行歌曲或者被翻唱突然又火起来的老歌、无聊时会听些欢快的歌、运动时会听写激昂的歌、伤心时也会听些伤感的歌。
我特别喜欢一句话： 初闻不识曲中意，再闻已是曲中人。 也许是因为我也是曲中人把。。。
所以我想把那些触动我的歌曲的评论利用我所学的知识爬取下来，将他们的故事收集起来细细品读。
话不多说，开始我们的爬虫之旅吧！！！
环境 Anaconda3(Python3)：Windows10下安装Anaconda3(64位)详细过程Python的第三方库：Crypto、base64、requests：conda install 库名Windows10Chrome浏览器（谷歌浏览器） 总体思路 通过跟踪点击评论翻页时发出的请求，得到具体变化参数，然后通过查看js文件破解采用了加密算法生成的params和encSecKey，但是通过对js脚本的分析，encSecKey参数是不需要破解的，只需要在浏览器获取到encSecKey的值然后复制到代码里，然后模拟POST请求程序就可以啦！！！
详细步骤 打开网易云音乐官网，随便打开一首歌，这里是我以前追的一部剧的主题曲忽而今夏。打开开发者模式，依次点击Network、XHR，然后到页面里点击下一页。通过查看返回结果追踪到翻页发出的请求。
通过查看请求的Headers知道了这条请求是POST请求，传输的参数是params和encSecKey
那么很明显这两个长长的参数是加密过的，因为通过翻页发现每次这两个参数的值都不一样，而且不是明文。我们就只能通过查看JS文件来模拟加密过程，因为找到对应的加密方法的操作步骤过于复杂，所以我录制了一个操作视频，你们可以慢慢观看。
查找对应加密方法
将上面找到的两个JS脚本复制出来脚本一：(function() { var c0x = NEJ.P, eq2x = c0x("nej.g"), v0x = c0x("nej.j"), k0x = c0x("nej.u"), QI7B = c0x("nm.x.ek"), l0x = c0x("nm.x"); if (v0x.bl1x.redefine) return; window.GEnc = true; var bqv4z = function(cHv1x) { var m0x = []; k0x.be0x(cHv1x, function(cHu1x) { m0x.push(QI7B.emj[cHu1x]) }); return m0x.join("") }; var cHs1x = v0x.bl1x; v0x.bl1x = function(Y0x, e0x) { var i0x = {}, e0x = NEJ.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c074ef080c4eacfb4a548db30eb971db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8b60249c470cdf971886966eed16c55/" rel="bookmark">
			高性能缓存类库Caffeine介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 Caffeine 是一个高性能、出色的缓存类库，基于Java 8。它的性能非常的出色，API也比较友好，本篇，我们就来介绍一下Caffeine 使用。
特性 Caffeine使用的是一个内存缓存，是基于Google 的 Guava与ConcurrentLinkedHashMap进行实现的。
Maven地址：
&lt;dependency&gt; &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt; &lt;artifactId&gt;caffeine&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; 我们首先来看一个其使用的demo：
LoadingCache&lt;Key, Graph&gt; graphs = Caffeine.newBuilder() .maximumSize(10_000) .expireAfterWrite(5, TimeUnit.MINUTES) .refreshAfterWrite(1, TimeUnit.MINUTES) .build(key -&gt; createExpensiveGraph(key)); 就这样，我们即可创建一个缓存结构，其中createExpensiveGraph()方法是我们自行定义的，用于生成缓存的逻辑，其他的方法我们将会在后面进行依次介绍。
Caffeine 提供了多种构建方式创建一个缓存，我们来看一下它的主要特性：
自动加载数据放入缓存，支持异步方式基于缓存容量的淘汰策略，当存储的元素超过最大值的时候，根据使用元素最近的使用频率策略进行淘汰基于过期时间的淘汰策略异步刷新策略key值自动包装成弱引用元素值自动包装成弱引用或软引用通知淘汰元素策略向外部存储资源写入元素统计缓存访问信息 以上就是Caffeine 的主要特性，接下来，我们就对上面的特性中比较常用的几个，进行展开详细介绍一下。
缓存加载 缓存加载是Caffeine 的最基础特性，其支持四中模式的加载策略：手工加载、同步加载、异步加载、异步手动加载。
手动加载 首先，我们来看一下手动加载：
//Build a manual cache Cache&lt;Key, Graph&gt; cache = Caffeine.newBuilder() .expireAfterWrite(10, TimeUnit.MINUTES) .maximumSize(1000) .build(); // Lookup an entry, or null if not found Graph graph = cache.getIfPresent(key); // Lookup and compute an entry if absent, or null if not computable graph = cache.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8b60249c470cdf971886966eed16c55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddecf80ee46bb7822644aa1bc0af5cf4/" rel="bookmark">
			MySQL-参数(max_allowed_packet)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参数 max_allowed_packet 指服务器端和客户端在一次传送数据包的过程中数据包的大小(最大限制)如果超出这个值，将抛出异常 参数查看 // 查看MySQL最大支持数据包大小 select @@max_allowed_packet; // 查看MySQL最大支持连接数 select @@max_collections; // 服务器响应的最大连接数 show global status like 'Max_used_connections'; 注：MySQL版本不同这个默认值可能会不一样 参数修改 通过配置文件修改，修改后要重启服务 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ab1ff32f7bfc9058fb38d32620426eb/" rel="bookmark">
			vs下把opencv程序封装成dll，然后在未配置opencv的环境中调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、把opencv程序封装成dll
首先新建一个DLL项目。
选择DLL
完成。
建好的项目中总共包含以下文件：
我们需要修改的只是跟我们项目名相同的文件test1.cpp，其它不用管。
test1.cpp中已有一些内容，我们只需在后面添加即可。
示例程序：
然后配置opencv的环境，以release为例。配置好opencv环境之后，编译生成。会在项目目录的release文件中生成test1.dll和test1.lib。生成DLL完成。
2、在未配置opencv的环境中调用生成的dll
新建一个win32控制台应用程序，调用dll的示例程序如下：
先选择release，编译生成一次。当然会报错，这一步只是为了在项目目录下生成一个release文件夹。
然后（1）把之前生成的test1.dll和test1.lib，以及所有用到的opencv的release版的dll，放到release文件夹下。
我用的是opencv2.4.10，这里用到的opencv的dll有opencv_core2410.dll，opencv_highgui.dll 和 opencv_imgproc.dll。
（2）项目-&gt;属性-&gt;VC++目录-&gt;库目录，把release文件夹添加进来，
（3）项目-&gt;属性-&gt;链接器-&gt;输入-&gt;附加依赖项，添加“test1.lib”。
然后再运行就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aef32cd0216ba11f908914602cb5479d/" rel="bookmark">
			TypeError: unsupported operand type(s) for &#43;: &#39;float&#39; and &#39;decimal.Decimal&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TypeError: unsupported operand type(s) for +: 'float' and 'decimal.Decimal'
浮点型和双精度类型 相加报错
from decimal import Decimal
Decimal( float )+Decimal( float ) 转载于:https://www.cnblogs.com/yanxiatingyu/p/10452625.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b2bba5357da768944470d757ec3d53c/" rel="bookmark">
			上海诺西Java面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.外连接和子查询区别
外连接和子查询最大的区别就在于外连接使用的join不需要在内存中创建临时表，效率比子查询高。
2.String的equals方法
https://blog.csdn.net/qq_25827845/article/details/53868815
3.Mybatis的两种实现方式
1）注解
2）.xml文件配置
4.Http和RPC区别
RPC 跟 http 不是一个层次的概念。RPC 是 远程过程调用，RPC 包含传输协议和编码协议。http是超文本传输协议，RPC 也可以用http作为传输协议，但一般是用 tcp作为传输协议。用json作为编码协议。RPC的主要用在内部服务间的通信。我们常说的微服务架构就要用到RPC.
原文：https://blog.csdn.net/wangpengzhi19891223/article/details/81012443 5.Dubbo与springcloud区别
https://blog.csdn.net/anningzhu/article/details/76599875
1)dubbo由于是二进制的传输，占用带宽会更少
2)springCloud是http协议传输，带宽会比较多，同时使用http协议一般会使用JSON报文，消耗会更大
3)dubbo的开发难度较大，原因是dubbo的jar包依赖问题很多大型工程无法解决
4)springcloud的接口协议约定比较自由且松散，需要有强有力的行政措施来限制接口无序升级
5）dubbo的注册中心可以选择zk,redis等多种，springcloud的注册中心只能用eureka或者自研(具体怎样我也不太清楚，看了 很多资料上有的说springcloud注册中心也可以用zookeeper，但是有的说需要自研，有懂得大神可以解答下)
6.hashmap底层原理
1）底层结构是数组+链表+红黑树，根据元素key的hash值对数组长度取模。得到存储位置。数组是Entry[]，
2）hash碰撞就是两个对象的key的hashCode值一样，将数据采用链表的形式存储在相同的Entry[]节点，获取时通过equals遍历节点上的每个key，获取value。
7.String与StringBuffer,StringBuilder的区别？
1）String是不可类，不适用于经常修改；
2）StringBuffer和StringBuilder是字符串缓冲区，使用于经常修改的对象，但是StringBuffer是线程安全的，StringBuilder是线程不安全的，StringBuilder效率相对于StringBuffer较高，但是安全性不高，当不需要再进行修改的时候，可以直接用tostring方法将结果转成String类。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b5b2e8f31780c63da56864e728a7b3b/" rel="bookmark">
			算法：汉明距离 vs 编辑距离 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 汉明距离
在信息论中，两个等长字符串之间的汉明距离是两个字符串对应位置的不同字符的个数。例如，1011101 与 1001001 之间的汉明距离是 2。
汉明距离是以理查德·卫斯里·汉明的名字命名的，汉明在误差检测与校正码的基础性论文中首次引入这个概念。在通信中累计定长二进制字中发生翻转的错误数据位，所以它也被称为信号距离。汉明重量分析在包括信息论、编码理论、密码学等领域都有应用。它是用来衡量2个二进制码字之间的相似程度的。
2 编辑距离
编辑距离，又称Levenshtein距离，是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。例如，kitten与sitting之间的编辑距离为3。
应用: DNA分析、拼字检查、语音辨识、抄袭侦测。
3 个人理解
汉明距离更多的是强调向量，即每一位的值都有相应的实际意义。而编辑距离强调更多的是一个字符串转化为另外一个的最快速度，没有考虑不同位的含义。
比如说，有两个对象A=”909”，B=”090”。A与B的汉明距离H(A, B) = 3，编辑距离ED(A, B) =2。
若附加对象A，B的描述为其空间位置信息，H(A, B) = 3表示在三个维度上均不相同；ED(A,B) = 2表示操作两个维度便可完全相同。显然在这种情况下用汉明距离比编辑距离更具有合理性。而在误差检测和校正码时，多数情况向量维度是相同的，并且每一位都对应着特定的描述信息，也即这些时候多数是用汉明距离。
若附加对象的A，B的描述文字信息（即拼字检查），显然用编辑距离表示更能反映A，B之间的相似程度。总之，在一些与序列相关但每一位又没有特定的含义的应用适合用编辑距离。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11bd8945530d3b608ad7c22c44761ec7/" rel="bookmark">
			关于SpringBoot&#43;SpringMVC&#43;Mybatis&#43;Oracle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于SpringBoot+SpringMVC+Mybatis+Oracle（不支持JSP需依赖） 关于各类文件的位置 applocation.properties配置文件 #编码格式 spring.http.encoding.force=true spring.http.encoding.charset=UTF-8 spring.http.encoding.enabled=true server.tomcat.uri-encoding=UTF-8 #热部署生效 spring.devtools.restart.enabled: true #设置重启的目录 spring.devtools.restart.additional-paths: src/main/java #classpath目录下的WEB-INF文件夹内容修改不重启 spring.devtools.restart.exclude: WEB-INF/** #JSP自定义访问路径的默认配置 spring.mvc.view.prefix: /WEB-INF/jsp/ spring.mvc.view.suffix: .jsp #映射文件路径 mybatis.mapperLocations=classpath:mapper/*.xml #mysql/Oracle数据库连接 #spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver #spring.datasource.driver-class-name=oracle.jdbc.OracleDriver #spring.datasource.url=jdbc:oracle:thin:@localhost:1521:orcl #spring.datasource.username=scgcxx #spring.datasource.password=scgcxx #Druid配置 数据库连接 spring.datasource.druid.driver-class-name=oracle.jdbc.OracleDriver spring.datasource.druid.url=jdbc:oracle:thin:@localhost:1521:orcl spring.datasource.druid.username=scgcxx spring.datasource.druid.password=scgcxx # 下面为Druid连接池的补充设置，应用到上面所有数据源中 spring.datasource.druid.type=com.alibaba.druid.pool.DruidDataSource spring.datasource.druid.initialSize=5 spring.datasource.druid.minIdle=5 spring.datasource.druid.maxActive=20 # 配置获取连接等待超时的时间 spring.datasource.druid.maxWait=60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 spring.datasource.druid.timeBetweenEvictionRunsMillis=60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 spring.datasource.druid.minEvictableIdleTimeMillis=300000 spring.datasource.druid.validationQuery=SELECT 1 FROM DUAL spring.datasource.druid.testWhileIdle=true spring.datasource.druid.testOnBorrow=false spring.datasource.druid.testOnReturn=false spring.datasource.druid.poolPreparedStatements=true spring.datasource.druid.maxPoolPreparedStatementPerConnectionSize=20 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 spring.datasource.filters=stat,wall,log4j2 spring.datasource.logSlowSql=true spring.datasource.useGlobalDataSourceStat=true # pagehelper分页配置 pagehelper.helper-dialect=oracle pagehelper.reasonable=true logging.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11bd8945530d3b608ad7c22c44761ec7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f648a4f87bccd350d2c54593f3d6d1a/" rel="bookmark">
			目标检测算法——SSD详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、 背景（基本介绍）
二、 网络结构
三、 具体过程
1. default box 匹配
2. 损失函数
3. 数据增广
4. Atrous Algothrim
5. NMS（非极大值抑制）
五、 性能评估
优点：
缺点：
SSD 算法的改进：DSSD
1. DSSD 网络结构
图19 VGG网络与ResNet网络的对比
2. 实现细节
3. 训练与预测
4. 总结
DSSD 检测结果展示
一、 背景（基本介绍） 基于“Proposal + Classification”的目标检测方法中，R-CNN 系列（R-CNN、 SPPnet、
Fast R-CNN以及 Faster R-CNN等）取得了非常好的结果，但是在速度方面离实时效果还比较远。在提高 mAP (Mean Average Precision) 的同时兼顾速度，逐渐成为神经网络目标检测领域未来的趋势。YOLO检测算法不仅能够达到实时的效果，而且mAP与前面面提到的 RCNN系列相比有很大的提升。 但是YOLO 有一些缺陷：每个网格只能预测一个物体，容易造成漏检；且对于物体的尺度相对比较敏感，面对尺度变化较大的物体时泛化能力较差。针对 YOLO 中的这些不足，SSD(Single Shot MultiBox Detector)网络在这两方面都有所改进，同时兼顾了 mAP 和实时性的要求。 two-stage 方法与 one-stage 方法 主流的算法主要分为两个类型： two-stage方法：如R-CNN系列算法，其主要思路是先通过启发式方法（selective search）或者 CNN 网络（RPN)产生一系列稀疏的候选框，然后对这些候选框进行分类(classification)与回归(bounding box regression)，two-stage方法的优势是准确度高； one-stage方法：如YOLO和SSD，其主要思路是均匀地在图片多个层数的特征图上进行密集抽样，抽样时可以采用不同尺度和长宽比，然后利用CNN提取特征后直接进行分类与回归，整个过程只需要一步，所以其优势是速度快。但是均匀的密集采样的一个重要缺点 是训练比较困难，这主要是因为正样本与负样本（背景）极其不均衡，导致模型准确度稍低。 不同算法的性能如图1所示，可以看到两类方法在准确度和速度上的差异。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f648a4f87bccd350d2c54593f3d6d1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db3d0fbafeae5f1f833015ff0dace483/" rel="bookmark">
			python 生成随机数/随机字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#随机生成浮点数
print(random.random())
print(random.uniform(10,20))
print(random.uniform(20,10))
#随机生成整数
print(random.randint(10,20))#生成n:10&lt;=n&lt;=20
随机选取0到100间的偶数：
&gt;&gt;&gt; import random
&gt;&gt;&gt; random.randrange(0, 101, 2)
42
随机字符：
&gt;&gt;&gt; import random
&gt;&gt;&gt; random.choice('abcdefg&amp;#%^*f')
'd'
多个字符中选取特定数量的字符：
&gt;&gt;&gt; import random
random.sample('abcdefghij',3) ['a', 'd', 'b']
多个字符中选取特定数量的字符组成新字符串：
&gt;&gt;&gt; import random
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.join(random.sample(['a','b','c','d','e','f','g','h','i','j'], 3)).r
eplace(" ","")
'fih'
随机选取字符串：
&gt;&gt;&gt; import random
&gt;&gt;&gt; random.choice ( ['apple', 'pear', 'peach', 'orange', 'lemon'] )
'lemon'
洗牌：
&gt;&gt;&gt; import random
&gt;&gt;&gt; items = [1, 2, 3, 4, 5, 6]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db3d0fbafeae5f1f833015ff0dace483/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/776b193bf2d90b0703033d7306de5bc0/" rel="bookmark">
			Tensorflow object detection API源码分析之如何构建模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型的具体参数被定义在config文件中，如samples/configs/ssd_mobilenet_v2_coco.config
model { ssd { num_classes: 90 box_coder { faster_rcnn_box_coder { y_scale: 10.0 x_scale: 10.0 height_scale: 5.0 width_scale: 5.0 } } matcher { argmax_matcher { matched_threshold: 0.5 unmatched_threshold: 0.5 ignore_thresholds: false negatives_lower_than_unmatched: true force_match_for_each_row: true } } similarity_calculator { iou_similarity { } } anchor_generator { ssd_anchor_generator { num_layers: 6 min_scale: 0.2 max_scale: 0.95 aspect_ratios: 1.0 aspect_ratios: 2.0 aspect_ratios: 0.5 aspect_ratios: 3.0 aspect_ratios: 0.3333 } } image_resizer { fixed_shape_resizer { height: 300 width: 300 } } box_predictor { convolutional_box_predictor { min_depth: 0 max_depth: 0 num_layers_before_predictor: 0 use_dropout: false dropout_keep_probability: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/776b193bf2d90b0703033d7306de5bc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4327ffbd14ac8846e1c0db3dad5a73e3/" rel="bookmark">
			关于stm32f407   IO口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.0 stm32f407 7组*16个 +2 IO口 每个IO口有四种输入，四种输出功能 1、输入浮空 5、开漏输出
2、输入上拉 6、推挽输出
3、输入下拉 7、推挽复用
4、模拟输入 8、开漏复用
每个IO口有十个寄存器
1 端口模式寄存器 GPIOX_MODER 32位
00 ：输入 （复位状态）
01 ：通用输出模式
10 :复用功能模式
11 ：模拟模式
2 端口输出类型寄存器 GPIO_OTYPER 16位
0 ：输出推挽 （复位状态）
1 ：输出开漏 3 端口输出速度寄存器 GPIO_OSPEEDR
00 ： 2MHZ
01 ：25MHZ
10 ：50MHZ
11 ：30PF时为100MHZ（高速）15PF时为80MHZ
4 端口上拉、下拉寄存器 GPID_PUPDR
00 ：无上拉或下拉
01 ：上拉
10 ：下拉
11 ：保留
5 端口输入数据寄存器 GPIO_IDR
这些位只读形式，只能在字模式下访问 6 端口输出数据寄存器GPIO_ODR
对于原子置位 复位，通过GPIO_BSRR寄存器
所谓原子，就是要么成功，要么失败，是不可分割的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4327ffbd14ac8846e1c0db3dad5a73e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/270d7123eeb6f868ddf993ae4c620174/" rel="bookmark">
			restful api 设计规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 同一种数据的操作，只设置一个url路由，也就是根据请求方法的不同来区分处理逻辑。
可以基于FBV来通过请求方法的不同，处理不同的逻辑，也可以基于CBV来实现。
两种方式CBV更加简洁，不需要判断
2. 域名
为了对用户使用的url和网页中使用的接口api进行区别，
(1)子域名的方式区分，例如：api.baidu.com/v1/login.json
用户一看域名是以api开头的，就知道就接口，返回的是json数据
(2)url的方式进行区分
例如：www.baidu.com/api/v1/login.json
第一种方式需要解决跨域请求的问题，也就是当域名不同或者端口不同的时候，都会出现跨域请求。
第二种，保证了域名和端口的一致性，只是url不一样而已
跨域：因为浏览器的同源策略，当你通过浏览器向www.baidu.com前端页面发送请求的时候，网页需要向后台请求接口，但是如果接口的域名和当前的域名不一致，就会出现跨源请求的错误，无法访问到页面。而跨源是网页向api发送请求之后，服务器响应了这个请求，但是是浏览器端把这一次请求的响应给阻止了，并不是在请求不同域名的接口时，服务端不会响应这个请求。跨源是浏览器端的阻止行为，而不是服务器端的。
3. 版本规则
两个版本共存的时候，应该将api的版本号放入url中。
例如：api.example.com/api/v1/
另一种做法是将版本号放在http头信息中，但不如放入url中方便直观。
4.面向资源编程
将网络中的任何东西都看作是资源，对资源可以进行增删改查的操作，但是资源表示的是一个名称，如果一个url后面跟的是一个名词(单复数都可以)，所用的名词往往与数据库的表格名对应，就表示要对这个资源进行增删改查的操作了。而get/post/delete/put是动词，所以url中不建议出现动词。
例如：www.baidu.com/api/v1/order/ (遵循规范)
www.baidu.com/api/v1/orders/ (遵循规范)
www.baidu.com/api/v1/get_order/ (没有遵循规范)
5. http方法规范
GET：从服务器上获取一个或者多个资源
POST：在服务器上新建一个资源
PUT：在服务器跟新全部资源
PATCH：在服务器更新部分资源
6. 过滤规范
www.baidu.com/api/v1/orders/?status=1&amp;page=2&amp;offset
7. 状态码规范(状态码+code码)
后台提供的状态码，供前端使用。
200系列，300系列表示重定向，400系列表示客户端错误，500系列表示服务端错误(后台代码错误)。
但是只有状态码还是不够的，请求的状态太多，所以除了使用状态码表示状态以外，还应该有code码来表示更加详细的请求情况。
比如：支付宝的code码，20000,20001等
def get(self,request,*args,**kwargs): ret = { 'code':1000, 'msg':'没有携带cookie' } return HttpResponse(json.dumps(ret),status=201) 8. api 超链接规范
在列表页的json中，restful希望详情页的url也包含在json数据中，就不用单独的进行拼接了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3469105ac115d7611d19da66087e2aac/" rel="bookmark">
			老卫带你学---leetcode刷题(2.Add Two Numbles)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 您将获得两个非空链表，表示两个非负整数。数字以相反的顺序存储，每个节点包含一个数字。添加两个数字并将其作为链接列表返回。
您可以假设这两个数字不包含任何前导零，除了数字0本身
示例： 输入：（2 - &gt; 4 - &gt; 3）+（5 - &gt; 6 - &gt; 4） 输出： 7 - &gt; 0 - &gt; 8 说明： 342 + 465 = 807。 解决： 思想： 使用变量跟踪进位并从列表头部开始模拟逐位数字，其中包含最低有效数字。
就像你在一张纸上总结两个数字一样，我们首先将最低有效数字相加，即 L1与L2。但每个节点里的数是0-9，那么相加起来以后，我们就需要考虑其进位情况。例如5+7=12这样。
伪代码： 初始化返回节点L初始化进位carry=1初始化L1与L2的头节点p与q循环如下步骤，直到L1与L2到达尽头： 设置L1的头节点p的值为x。如果p为终点，则设为0设置L2的头节点q的值为y。如果q为终点，则设为0设置sum=x+y+carry更新carry=sum/10让L的next节点为sum%10判断是否L1与L2到达终点回到第1步 代码 c++代码: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { return addBybit(l1,l2,0); } ListNode* addBybit(ListNode* l1,ListNode* l2,int carry){ if(l1==NULL) l1=new ListNode(0); if(l2==NULL) l2=new ListNode(0); ListNode* l=new ListNode((l1-&gt;val+l2-&gt;val+carry)%10); carry=(l1-&gt;val+l2-&gt;val+carry)/10; if(l1-&gt;next !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3469105ac115d7611d19da66087e2aac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73d406a98a28dcaa24d899fae032b3e4/" rel="bookmark">
			LeetCode 重复的DNA序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。
编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。
示例:
输入: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT" 输出: ["AAAAACCCCC", "CCCCCAAAAA"] 思路分析：利用map标记各个长度为10的子串出现的次数，出现多次的就是结果。
class Solution { public: vector&lt;string&gt; findRepeatedDnaSequences(string s) { vector&lt;string&gt; result; unordered_map&lt;string, int&gt; myMap;//用于关联各个长度为10的子串出现的次数 int strSize = s.size(); for (int beginIndex = 0; beginIndex &lt;= strSize - 10; ++beginIndex) { string tempRes = s.substr(beginIndex, 10); if (++myMap[tempRes] == 2) {//第一次出现两次，避免重复 result.push_back(tempRes); } } return result; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d73da7c98622b5fdd3dfa5cdcceafa0e/" rel="bookmark">
			删除delphi组件TStringlist中的重复项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		procedure RemoveDuplicates(const stringList : TStringList) ;
var
buffer: TStringList;
cnt: Integer;
begin
stringList.Sort;
buffer := TStringList.Create;
try
buffer.Sorted := True;
buffer.Duplicates := dupIgnore;
buffer.BeginUpdate;
for cnt := 0 to stringList.Count - 1 do
buffer.Add(stringList[cnt]) ;
buffer.EndUpdate;
stringList.Assign(buffer) ;
finally
FreeandNil(buffer) ;
end;
end;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b17a5dc38e99af91e8c2460a95269b4/" rel="bookmark">
			C&#43;&#43;-P5-结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;windows.h&gt; // 为了使用Sleep()函数 struct FishOil { std::string name; std::string uid; char sex; }; bool InitFishC(); bool ReadFishC(); void RecordFishC(); bool WriteFishC(FishOil *OilData); int main() { int i; InitFishC(); // 初始化数据。 while( 1 ) { std::cout &lt;&lt; "请选择需要进行的操作: \n"; std::cout &lt;&lt; "1. 打印数据到屏幕\n"; std::cout &lt;&lt; "2. 录入数据\n"; std::cout &lt;&lt; "3. 退出程序\n"; std::cin &gt;&gt; i; switch( i ) { case 1: if( ReadFishC() ) std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b17a5dc38e99af91e8c2460a95269b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66f10eb2ed246e1893ecd734627b8ad4/" rel="bookmark">
			C&#43;&#43;-P4-从另一个小程序接着说
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.c
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main( int argc, char* argv[] ) { FILE *in, *out; int ch; if( argc != 3 ) { fprintf( stderr, "输入形式: copyFile 源文件名 目标文件名 \n" ); exit( EXIT_FAILURE ); } if( ( in = fopen( argv[1], "rb") ) == NULL ) { fprintf( stderr, "打不开文件: %s \n", argv[1] ); exit( EXIT_FAILURE ); } if( ( out = fopen( argv[2], "wb") ) == NULL ) { fprintf( stderr, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66f10eb2ed246e1893ecd734627b8ad4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ce7cef0f8103db3cf4f8b512c03320f/" rel="bookmark">
			离线大数据调度框架 -- 1、需求分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、启动flume将指定文件【文件内容每一分钟增加若干行，模拟nginx日志】自动同步到HDFS。
要求：
将文件归档时间设置为1小时；归档文件存储格式设置为LZO；HDFS文件按天分文件夹进行存储，不能全部同步到一个文件夹中； 2、配置MR任务并依赖flume任务
要求：
将日志文件解析到hive表每天对应的分区中查看每天分区日志里面是否有其它天的日志【Event Time和处理时间可能不一致】假设当天分区存在其它天的日志，请设计一个方案保证当天的分区只能有当天的数据，并且保证所有的数据不会丢失（不能每次都扫描所有的日志）选做：将日志解析文件存储为parquet文件类型 3、通过sqoop命令行显示mysql里面有多少数据表；通过azkaban配置sqoop任务，将product、member、order三表同步到hive表
要求：
每天设置全量同步相关数据每天设置一个新的分区同步进一步思考 【只要指定数据源数据库、源表和输出hive库、hive表，可以实现所有表在一个任务中就可以实现同步，并且每个map的数据是相对均匀的】 ？？？ 4、hive相关调度
计算每天有多少pv、uv、订单量、收入、注册用户数 （使用1个sql）计算访问product页面的用户中，有多少比例在30分钟内下单并且支付成功对应的商品更改前一个sql，需要做到支持变更不同的页面类型（正则）和目标时间，支持指定时间间隔的转化率分析（写明设计思路）通过sql计算每个商品的每天的pv、uv并存入新建的hive表，格式自己定义计算每个商品每天的pv、uv的环比情况（今天-昨天/昨天），并且筛选出环比增长最大的和最小的（负数&lt;正数）计算每天的登录用户数中新老用户占比，并且统计新老用户分别的pv、uv （新老用户的判断标准？？？）设计一个udaf，将用户当前行为之前30分钟内的actionid行为存为一个list，其中list中的序号代表由远到近的时间序（参考collect_set的udaf）基于udaf重写第二个作业的sql，对比有何不同 5、配置sqoop任务将hive任务结果导入mysql数据库
计算每个商品的每天的pv、uv并存入新建的hive表每天同步到mysql的表中 6、基于你现有知识，设计自己的框架
框架适用方需求如下：【前2个需求通过写shell脚本暴露通用参数】
业务方不想知道你怎么同步，只想在使用的时候指定源数据库、源表和输出hive库、hive表，第二天自动同步全量信息。对日志解析而言，业务方不想知道你是通过什么引擎实现的，只希望写个输入路径，输出hive表，分区和解析逻辑，其它过程系统自动完成业务放不想写add jar这样的方式创建临时函数，如何设计一个规范保证业务方可以直接使用你生成的udf，可以注册为常用函数，也可以用其它方式 【把udf函数加入hive启动服务，在hive-site.xml的hive.aux.jars.path中添加jar包路径】sqoop导入数据库太慢了，如何设计一种方案：在任务中，直接将结果写入数据库，业务方不想知道中间细节，只希望hive查询结果可以直接插入数据库（不做转化） 【此处数据库应该指mySQL数据库】 hive-contrib模块的GenericUDFDBOutput 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e415e6b6ab8d21a43386482df1e71140/" rel="bookmark">
			BottomNavigationView&#43;Fragment实现主页面布局，并解决fragment重叠和数据保存的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现底部导航，有很多种方式，我比较喜欢用android的design提供的BottomNavigationView，实现起来非常方便
先看效果
主页布局如下
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;FrameLayout android:id="@+id/fl_container" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1"/&gt; &lt;!--labelVisibilityMode用来设置item大于3个的时候同时显示icon和title--&gt; &lt;!--itemIconTint和itemTextColor用来设置icon和title在选中和未选中的颜色--&gt; &lt;!--itemBackground用来设置底部导航栏的整体背景效果--&gt; &lt;!--app:menu用来设置底部菜单 --&gt; &lt;android.support.design.widget.BottomNavigationView android:id="@+id/nav_bottom" android:layout_width="match_parent" android:layout_height="wrap_content" app:labelVisibilityMode="labeled" app:itemBackground="@android:color/background_light" app:itemIconTint="@color/selector_bootom_item_checked" app:itemTextColor="@color/selector_bootom_item_checked" app:menu="@menu/bottom_navigation_view"/&gt; &lt;/LinearLayout&gt; 下面提几个关键地方
根据传入的Bundle对象判断acticity是否重建 if (savedInstanceState == null){ //根据传入的Bundle对象判断是正常启动还是重建 true表示正常启动，false表示重建 setSelectedFragment(0); } 添加fragment之前先通过fragmentManager找fragment，为空则添加，不为空则使用已有的实例 currentFragment = fragmentManager.findFragmentByTag("fragment"+position);//要显示的fragment(解决了activity重建时新建实例的问题) hideFragment = fragmentManager.findFragmentByTag("fragment" + lastPosition);//要隐藏的fragment(解决了activity重建时新建实例的问题) if (position != lastPosition){//如果位置不同 if (hideFragment != null){//如果要隐藏的fragment存在，则隐藏 transaction.hide(hideFragment); } if (currentFragment == null){//如果要显示的fragment不存在，则新加并提交事务 currentFragment = mFragments.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e415e6b6ab8d21a43386482df1e71140/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e7d51cbc7851e8e7e672ff91d05f906/" rel="bookmark">
			五大常用算法学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一。分治算法：快速排序、归并排序、大整数乘法、二分查找、递归（汉诺塔）
基本概念：把一个复杂的问题分成若干个相同或相似的子问题，再把子问题分成更小的子问题… ， 知道最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 看上去有点类似Fork/Join框架，或map-reduce。
排序算法中的快速排序、归并排序都是使用的分治算法。
分治算法的适用场景：
1）当问题规模缩小到一定的程度就可以很容易解决
2）该问题可以分解为若干个规模较小的相同问题
3）该问题分解出的若干子问题的解可以合并为该问题的解
4）每个子问题都是独立的，相互之间没有交集。
使用分治法的经典场景：
1）二分搜索
2）大整数乘法
3）合并排序
4）快速排序
5）汉诺塔
分治算法经典例题：
输入一组整数，求出这组数字子序列和中最大值。也就是求出最大子序列的和，不必求出最大的那个序列。例如：序列：-2, 11, -1, 13, -5, -2 , 则最大子序列的和为20。
public static void main(String[] args) { int[] a = { -2, 11, -4, 13, -5, -2 };// 最大子序列和为20 int[] b = { -6, 2, 4, -7, 5, 3, 2, -1, 6, -9, 10, -2 };// 最大子序列和为16 System.out.println(maxSubSum1(a)); System.out.println(maxSubSum4(b)); } // 最大子序列求和算法一 public static int maxSubSum1(int[] a) { int maxSum = 0; // 从第i个开始找最大子序列和 for (int i = 0; i &lt; a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e7d51cbc7851e8e7e672ff91d05f906/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d98511e7c38f56e8082b2b5ca48ab2e/" rel="bookmark">
			Hystrix的线程池隔离和信号量隔离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信号量的隔离：
it executes on the calling thread and concurrent requests are limited by the semaphore count.
每次调用线程，当前请求通过计数信号量进行限制，当信号大于了最大请求数（maxConcurrentRequests）时，进行限制，调用fallback接口快速返回。
最重要的是，信号量的调用是同步的，也就是说，每次调用都得阻塞调用方的线程，直到结果返回。这样就导致了无法对访问做超时（只能依靠调用协议超时，无法主动释放）
官网对信号量隔离的描述建议
Generally the only time you should use semaphore isolation for HystrixCommands is when the call is so high volume (hundreds per second, per instance) that the overhead of separate threads is too high; this typically only applies to non-network calls.
隔离的细粒度太高，数百个实例需要隔离，此时用线程池做隔离开销过大通常这种都是非网络调用的情况下线程池隔离:
it executes on a separate thread and concurrent requests are limited by the number of threads in the thread-pool
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d98511e7c38f56e8082b2b5ca48ab2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ee7bb6513737b0c3496bdbdbfe378c9/" rel="bookmark">
			Hystrix原理流程图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4464a9b5f336ddcf5ec834495b9d4b22/" rel="bookmark">
			Solr-7.2.1命令行创建Core导入数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基于Solr-7.2.1版本
不用拷贝默认配置，快速创建core
如果有权限限制，需要先设置全局的Solr验证 export SOLR_AUTHENTICATION_OPTS='-Dbasicauth=user:password' export SOLR_AUTH_TYPE='basic 创建core bin/solr create -c [core_name] 修改core.properties文件，指定路径 #Written by CorePropertiesLocator #Tue Feb 26 07:33:32 UTC 2019 name=core_name config=/home/finbtc/soft/solr-7.2.1/server/solr/core_name/conf/solrconfig.xml schema=/home/finbtc/soft/solr-7.2.1/server/solr/core_name/conf/managed-schema dataDir=/home/finbtc/soft/solr-7.2.1/server/solr/core_name/data/ 修改managed-schema文件，创建对应的字段信息
进入solr的控制台，通过documents中的update操作，导入数据
重启服务
bin/solr stop -p 19531 bin/solr start -p 19531 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/846f6816e0ffff24d18507fd99ca8b75/" rel="bookmark">
			改变程序黑窗口的背景和字体颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用system(“color a”),增加头文件#include &lt;stdlib.h&gt;，其中a表示颜色属性，颜色属性由两个十六进制数字指定 – 第一个为背景，第二个则为前景。每个数字可以为以下任何值之一:如system(“color 1f”);表示蓝底白字。
0 = 黑色 8 = 灰色
1 = 蓝色 9 = 淡蓝色
2 = 绿色 A = 淡绿色
3 = 湖蓝色 B = 淡浅绿色
4 = 红色 C = 淡红色
5 = 紫色 D = 淡紫色
6 = 黄色 E = 淡黄色
7 = 白色 F = 亮白色
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2324eadcfbabfecfae158f8140f91b0c/" rel="bookmark">
			【统计学】第三章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Evernote Export 数据的预处理包括哪些内容？ 1.数据审核
2.数据筛选
3.数据排序
4.数据透视表
分类数据和顺序数据的整理和图示方法各有哪些？ 1.分类数据整理：对于定性数据，使用频数分布进行描述，还可以进行比例、百分比、比率等级统计量描述。
分类数据的图示条形图帕累托图饼图环形图 2.顺序数据整理： 对于顺序数据，除了可以使用以上整理和显示技术，还可以计算累积频数和累积频率(百分比)
顺序数据的图示折线图 数值型数据的分组方法有哪些？简述组距分组的步骤。 数据分组的主要目的是观察数据的分布特征。数据经分组后再计算出各组中数据出现的频数，就形成了一张频数分布表。
数据分组的方法有单变量值分组和组距分组两种。
确定组数确定各组的组距根据分组整理成频数分布表 直方图与条形图有何区别？ 首先，条形图是用条形的长度表示各类别频数的多少，其宽度(表示类别)则是固定的；直方图是用面积表示各组频数的多少。矩形的高度表示每一组的频数或频率，宽度则表示各组的组距，因此其高度与宽度均有意义。
其次，由于分组数据具有连续性，直方图的各矩形通常是连续排列，而条形图则是分开排列。
条形图用于展示分类数据，而直方图用于展示数值型数据
绘制线图应注意哪些问题？ 绘制线图时，时间一般绘在横轴，观测值在纵轴。一般应该绘成横轴略大于纵轴的长方形，其长宽比例大致为10:7.
图形过扁或过于瘦高，不仅不美观，而且会给人造成视觉上的错觉，不便于对数据变化的理解。一般情况下，纵轴数据下端应从"0"开始，以便于对数据变化的理解。一般情况下，纵轴数据下端应从"0"时开始，便于比较。如果数据"0"之间的间距过大，可以采取折断的符号将纵轴折断。
饼图和环形图有什么不同？ 饼图与环形图类似，但是又有区别。环形图中间有一个"空洞"，每个样本用一个环来表示，样本中的每一部分数据用环中的一段表示。因此环形图可显示多个样本各部分所占的响应比例，从而有利于对构成的比较研究。
茎叶图和环形图相比有什么优点？它们的应用场合是什么？ 茎叶图是反映原始数据分布的图形。它由茎和叶两部分构成，其图形是由数字组成的。通过茎叶图，可以看出数据的分布形状及数据的离散程度，比如是否对称，数据是否集中，是否有离群点，等等。
茎叶图类似于横置的直方图，与直方图对比，茎叶图既能给出数据的分布状况，又能给出每一个原始数值，即保留了原始数据的信息。而直方图虽然能很好的显示数据的分布，但是不能保留原始的数值。在应用方面，直方图通常适用于大批量数据，茎叶图通常适用于小批量数据。
环形图可显示多个样本各部分所占的相应比例，从而有利于对构成的比较研究。
鉴别图表优劣的准则有哪些？ 1.一张好图应当静心设计，有助于洞察问题的实质。2.一张好图应当使复杂的观点得到简明、确切、高效的阐述。3.一张好图应当能在最短的时间内以最少的笔墨给读者提供大量的信息。4.一张好图应当是多维的。5.一张好图应当表述数据的真实情况。
在绘制图形时，应避免一切不必要的修饰。过于花哨的修饰往往会使人注重图形本身，而掩盖了图形所要表达的信息。图形产生的视觉效果应与数据所体现的事物特征相一致，否则有可能歪曲数据，给人留下错误的印象。 制作统计表应注意哪些问题？ 首先，要合理安排统计表的结构，比如行标题、列标题、数据资料的位置应安排合理。当然，由于强调的问题不同，行标题和列标题可以互换，但是应使统计表的横竖长度比例适当，避免出现过高或过宽的表格形式。其次，表头一般应包括表号、总标题和表中的数据的单位等内容。总标题应简明确切地概括出统计表的内容，一般需要说明统计数据的时间，地点以及何种数据，即标题内容应满足3W要求。如果表中的全部数据都是同一个计量单位，可在表的右上角标明。若各变量的计量单位不同，则应放在每个变量后或单列出一列标明。再次，表中的上下两条横线一般用粗线，中间的其他线要用细线，这样使人看起来清除、醒目。通常情况下，统计表的左右两边不封口，列标题之间在必要时可用竖线分开，而行标题之间通常不必用横线隔开。总之表中尽量少用横竖线。表中的数据一般是右对齐，有小数点时应以小数点对齐，而且小数点的位数应统一。对于没有数据的表格单元，一般用"-"表示，一张填好的统计表不应出现空白单元格。 错题集 1.样本或总体中各不同类别数值之间的比值称为比率2.将比例乘以100得到的数值称为百分数3.饼图最适合描述结构性问题4.环形图适合于比较研究两个或多个样本或总体的结构性问题5.最适合描述一组数据分布的图形是直方图6.对于大批量的数据，最适合描述分布的图形是直方图7.对于小批量的数据，最适合描述分布的图形是茎叶图8.对于时间序列数据，用于描述其变化趋势的图形通常是箱线图9.气泡图主要用于描述三个变量之间的相关关系10.与直方图相比茎叶图保留了原始数据的信息11.茎叶图不适合描述分类数据12.直方图与条形图的区别之一是直方图的各矩形通常是连续排列的，而条形图则是分开排列的 %23%23%23%20%E6%95%B0%E6%8D%AE%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9%EF%BC%9F%0A%3E**1.%E6%95%B0%E6%8D%AE%E5%AE%A1%E6%A0%B8**%0A%3E**2.%E6%95%B0%E6%8D%AE%E7%AD%9B%E9%80%89**%0A%3E**3.%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F**%0A%3E**4.%E6%95%B0%E6%8D%AE%E9%80%8F%E8%A7%86%E8%A1%A8**%0A%0A%23%23%23%20%E5%88%86%E7%B1%BB%E6%95%B0%E6%8D%AE%E5%92%8C%E9%A1%BA%E5%BA%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E6%95%B4%E7%90%86%E5%92%8C%E5%9B%BE%E7%A4%BA%E6%96%B9%E6%B3%95%E5%90%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%0A%3E1.%E5%88%86%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86%EF%BC%9A%E5%AF%B9%E4%BA%8E%E5%AE%9A%E6%80%A7%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%BF%E7%94%A8%E9%A2%91%E6%95%B0%E5%88%86%E5%B8%83%E8%BF%9B%E8%A1%8C%E6%8F%8F%E8%BF%B0%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E6%AF%94%E4%BE%8B%E3%80%81%E7%99%BE%E5%88%86%E6%AF%94%E3%80%81%E6%AF%94%E7%8E%87%E7%AD%89%E7%BA%A7%E7%BB%9F%E8%AE%A1%E9%87%8F%E6%8F%8F%E8%BF%B0%E3%80%82%0A%3E*%20%E5%88%86%E7%B1%BB%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9B%BE%E7%A4%BA%0A%20%20%20%20%3E*%20%E6%9D%A1%E5%BD%A2%E5%9B%BE%0A%20%20%20%20%3E*%20%E5%B8%95%E7%B4%AF%E6%89%98%E5%9B%BE%0A%20%20%20%20%3E*%20%E9%A5%BC%E5%9B%BE%0A%20%20%20%20%3E*%20%E7%8E%AF%E5%BD%A2%E5%9B%BE%0A%0A%3E2.%E9%A1%BA%E5%BA%8F%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86%EF%BC%9A%20%E5%AF%B9%E4%BA%8E%E9%A1%BA%E5%BA%8F%E6%95%B0%E6%8D%AE%EF%BC%8C%E9%99%A4%E4%BA%86%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E4%BB%A5%E4%B8%8A%E6%95%B4%E7%90%86%E5%92%8C%E6%98%BE%E7%A4%BA%E6%8A%80%E6%9C%AF%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%AE%A1%E7%AE%97%E7%B4%AF%E7%A7%AF%E9%A2%91%E6%95%B0%E5%92%8C%E7%B4%AF%E7%A7%AF%E9%A2%91%E7%8E%87(%E7%99%BE%E5%88%86%E6%AF%94)%0A%3E*%20%E9%A1%BA%E5%BA%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9B%BE%E7%A4%BA%0A%20%20%20%20%3E*%20%E6%8A%98%E7%BA%BF%E5%9B%BE%0A%0A%23%23%23%20%E6%95%B0%E5%80%BC%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E7%BB%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E7%AE%80%E8%BF%B0%E7%BB%84%E8%B7%9D%E5%88%86%E7%BB%84%E7%9A%84%E6%AD%A5%E9%AA%A4%E3%80%82%0A%3E%E6%95%B0%E6%8D%AE%E5%88%86%E7%BB%84%E7%9A%84%E4%B8%BB%E8%A6%81%E7%9B%AE%E7%9A%84%E6%98%AF%E8%A7%82%E5%AF%9F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E5%B8%83%E7%89%B9%E5%BE%81%E3%80%82%E6%95%B0%E6%8D%AE%E7%BB%8F%E5%88%86%E7%BB%84%E5%90%8E%E5%86%8D%E8%AE%A1%E7%AE%97%E5%87%BA%E5%90%84%E7%BB%84%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E9%A2%91%E6%95%B0%EF%BC%8C%E5%B0%B1%E5%BD%A2%E6%88%90%E4%BA%86%E4%B8%80%E5%BC%A0%E9%A2%91%E6%95%B0%E5%88%86%E5%B8%83%E8%A1%A8%E3%80%82%0A%3E%E6%95%B0%E6%8D%AE%E5%88%86%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%8D%95%E5%8F%98%E9%87%8F%E5%80%BC%E5%88%86%E7%BB%84%E5%92%8C%E7%BB%84%E8%B7%9D%E5%88%86%E7%BB%84%E4%B8%A4%E7%A7%8D%E3%80%82%0A%3E*%20%E7%A1%AE%E5%AE%9A%E7%BB%84%E6%95%B0%0A%3E*%20%E7%A1%AE%E5%AE%9A%E5%90%84%E7%BB%84%E7%9A%84%E7%BB%84%E8%B7%9D%0A%3E*%20%E6%A0%B9%E6%8D%AE%E5%88%86%E7%BB%84%E6%95%B4%E7%90%86%E6%88%90%E9%A2%91%E6%95%B0%E5%88%86%E5%B8%83%E8%A1%A8%0A%0A%0A%23%23%23%20%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%B8%8E%E6%9D%A1%E5%BD%A2%E5%9B%BE%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F%0A%3E%E9%A6%96%E5%85%88%EF%BC%8C%E6%9D%A1%E5%BD%A2%E5%9B%BE%E6%98%AF%E7%94%A8%E6%9D%A1%E5%BD%A2%E7%9A%84%E9%95%BF%E5%BA%A6%E8%A1%A8%E7%A4%BA%E5%90%84%E7%B1%BB%E5%88%AB%E9%A2%91%E6%95%B0%E7%9A%84%E5%A4%9A%E5%B0%91%EF%BC%8C%E5%85%B6%E5%AE%BD%E5%BA%A6(%E8%A1%A8%E7%A4%BA%E7%B1%BB%E5%88%AB)%E5%88%99%E6%98%AF%E5%9B%BA%E5%AE%9A%E7%9A%84%EF%BC%9B%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%98%AF%E7%94%A8%E9%9D%A2%E7%A7%AF%E8%A1%A8%E7%A4%BA%E5%90%84%E7%BB%84%E9%A2%91%E6%95%B0%E7%9A%84%E5%A4%9A%E5%B0%91%E3%80%82%E7%9F%A9%E5%BD%A2%E7%9A%84%E9%AB%98%E5%BA%A6%E8%A1%A8%E7%A4%BA%E6%AF%8F%E4%B8%80%E7%BB%84%E7%9A%84%E9%A2%91%E6%95%B0%E6%88%96%E9%A2%91%E7%8E%87%EF%BC%8C%E5%AE%BD%E5%BA%A6%E5%88%99%E8%A1%A8%E7%A4%BA%E5%90%84%E7%BB%84%E7%9A%84%E7%BB%84%E8%B7%9D%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%85%B6%E9%AB%98%E5%BA%A6%E4%B8%8E%E5%AE%BD%E5%BA%A6%E5%9D%87%E6%9C%89%E6%84%8F%E4%B9%89%E3%80%82%0A%3E%E5%85%B6%E6%AC%A1%EF%BC%8C%E7%94%B1%E4%BA%8E%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE%E5%85%B7%E6%9C%89%E8%BF%9E%E7%BB%AD%E6%80%A7%EF%BC%8C%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E5%90%84%E7%9F%A9%E5%BD%A2%E9%80%9A%E5%B8%B8%E6%98%AF%E8%BF%9E%E7%BB%AD%E6%8E%92%E5%88%97%EF%BC%8C%E8%80%8C%E6%9D%A1%E5%BD%A2%E5%9B%BE%E5%88%99%E6%98%AF%E5%88%86%E5%BC%80%E6%8E%92%E5%88%97%E3%80%82%0A%3E**%E6%9D%A1%E5%BD%A2%E5%9B%BE%E7%94%A8%E4%BA%8E%E5%B1%95%E7%A4%BA%E5%88%86%E7%B1%BB%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%80%8C%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%94%A8%E4%BA%8E%E5%B1%95%E7%A4%BA%E6%95%B0%E5%80%BC%E5%9E%8B%E6%95%B0%E6%8D%AE**%0A%0A%23%23%23%20%E7%BB%98%E5%88%B6%E7%BA%BF%E5%9B%BE%E5%BA%94%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F%0A%3E%E7%BB%98%E5%88%B6%E7%BA%BF%E5%9B%BE%E6%97%B6%EF%BC%8C%E6%97%B6%E9%97%B4%E4%B8%80%E8%88%AC%E7%BB%98%E5%9C%A8%E6%A8%AA%E8%BD%B4%EF%BC%8C%E8%A7%82%E6%B5%8B%E5%80%BC%E5%9C%A8%E7%BA%B5%E8%BD%B4%E3%80%82%E4%B8%80%E8%88%AC%E5%BA%94%E8%AF%A5%E7%BB%98%E6%88%90%E6%A8%AA%E8%BD%B4%E7%95%A5%E5%A4%A7%E4%BA%8E%E7%BA%B5%E8%BD%B4%E7%9A%84%E9%95%BF%E6%96%B9%E5%BD%A2%EF%BC%8C%E5%85%B6%E9%95%BF%E5%AE%BD%E6%AF%94%E4%BE%8B%E5%A4%A7%E8%87%B4%E4%B8%BA10%3A7.%0A%3E%E5%9B%BE%E5%BD%A2%E8%BF%87%E6%89%81%E6%88%96%E8%BF%87%E4%BA%8E%E7%98%A6%E9%AB%98%EF%BC%8C%E4%B8%8D%E4%BB%85%E4%B8%8D%E7%BE%8E%E8%A7%82%EF%BC%8C%E8%80%8C%E4%B8%94%E4%BC%9A%E7%BB%99%E4%BA%BA%E9%80%A0%E6%88%90%E8%A7%86%E8%A7%89%E4%B8%8A%E7%9A%84%E9%94%99%E8%A7%89%EF%BC%8C%E4%B8%8D%E4%BE%BF%E4%BA%8E%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E7%BA%B5%E8%BD%B4%E6%95%B0%E6%8D%AE%E4%B8%8B%E7%AB%AF%E5%BA%94%E4%BB%8E%220%22%E5%BC%80%E5%A7%8B%EF%BC%8C%E4%BB%A5%E4%BE%BF%E4%BA%8E%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E7%BA%B5%E8%BD%B4%E6%95%B0%E6%8D%AE%E4%B8%8B%E7%AB%AF%E5%BA%94%E4%BB%8E%220%22%E6%97%B6%E5%BC%80%E5%A7%8B%EF%BC%8C%E4%BE%BF%E4%BA%8E%E6%AF%94%E8%BE%83%E3%80%82%E5%A6%82%E6%9E%9C%E6%95%B0%E6%8D%AE%220%22%E4%B9%8B%E9%97%B4%E7%9A%84%E9%97%B4%E8%B7%9D%E8%BF%87%E5%A4%A7%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%87%87%E5%8F%96%E6%8A%98%E6%96%AD%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%B0%86%E7%BA%B5%E8%BD%B4%E6%8A%98%E6%96%AD%E3%80%82%0A%0A%23%23%23%20%E9%A5%BC%E5%9B%BE%E5%92%8C%E7%8E%AF%E5%BD%A2%E5%9B%BE%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F%0A%3E%E9%A5%BC%E5%9B%BE%E4%B8%8E%E7%8E%AF%E5%BD%A2%E5%9B%BE%E7%B1%BB%E4%BC%BC%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8F%88%E6%9C%89%E5%8C%BA%E5%88%AB%E3%80%82%E7%8E%AF%E5%BD%A2%E5%9B%BE%E4%B8%AD%E9%97%B4%E6%9C%89%E4%B8%80%E4%B8%AA%22%E7%A9%BA%E6%B4%9E%22%EF%BC%8C%E6%AF%8F%E4%B8%AA%E6%A0%B7%E6%9C%AC%E7%94%A8%E4%B8%80%E4%B8%AA%E7%8E%AF%E6%9D%A5%E8%A1%A8%E7%A4%BA%EF%BC%8C%E6%A0%B7%E6%9C%AC%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%94%A8%E7%8E%AF%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AE%B5%E8%A1%A8%E7%A4%BA%E3%80%82%E5%9B%A0%E6%AD%A4%E7%8E%AF%E5%BD%A2%E5%9B%BE%E5%8F%AF%E6%98%BE%E7%A4%BA%E5%A4%9A%E4%B8%AA%E6%A0%B7%E6%9C%AC%E5%90%84%E9%83%A8%E5%88%86%E6%89%80%E5%8D%A0%E7%9A%84%E5%93%8D%E5%BA%94%E6%AF%94%E4%BE%8B%EF%BC%8C%E4%BB%8E%E8%80%8C%E6%9C%89%E5%88%A9%E4%BA%8E%E5%AF%B9%E6%9E%84%E6%88%90%E7%9A%84%E6%AF%94%E8%BE%83%E7%A0%94%E7%A9%B6%E3%80%82%0A%0A%23%23%23%20%E8%8C%8E%E5%8F%B6%E5%9B%BE%E5%92%8C%E7%8E%AF%E5%BD%A2%E5%9B%BE%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F%E5%AE%83%E4%BB%AC%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E5%90%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%0A%3E%E8%8C%8E%E5%8F%B6%E5%9B%BE%E6%98%AF%E5%8F%8D%E6%98%A0%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E7%9A%84%E5%9B%BE%E5%BD%A2%E3%80%82%E5%AE%83%E7%94%B1%E8%8C%8E%E5%92%8C%E5%8F%B6%E4%B8%A4%E9%83%A8%E5%88%86%E6%9E%84%E6%88%90%EF%BC%8C%E5%85%B6%E5%9B%BE%E5%BD%A2%E6%98%AF%E7%94%B1%E6%95%B0%E5%AD%97%E7%BB%84%E6%88%90%E7%9A%84%E3%80%82%E9%80%9A%E8%BF%87%E8%8C%8E%E5%8F%B6%E5%9B%BE%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%87%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E5%B8%83%E5%BD%A2%E7%8A%B6%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%9A%84%E7%A6%BB%E6%95%A3%E7%A8%8B%E5%BA%A6%EF%BC%8C%E6%AF%94%E5%A6%82%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E9%9B%86%E4%B8%AD%EF%BC%8C%E6%98%AF%E5%90%A6%E6%9C%89%E7%A6%BB%E7%BE%A4%E7%82%B9%EF%BC%8C%E7%AD%89%E7%AD%89%E3%80%82%0A%3E%E8%8C%8E%E5%8F%B6%E5%9B%BE%E7%B1%BB%E4%BC%BC%E4%BA%8E%E6%A8%AA%E7%BD%AE%E7%9A%84%E7%9B%B4%E6%96%B9%E5%9B%BE%EF%BC%8C%E4%B8%8E%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%AF%B9%E6%AF%94%EF%BC%8C%E8%8C%8E%E5%8F%B6%E5%9B%BE%E6%97%A2%E8%83%BD%E7%BB%99%E5%87%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E5%B8%83%E7%8A%B6%E5%86%B5%EF%BC%8C%E5%8F%88%E8%83%BD%E7%BB%99%E5%87%BA%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%A7%8B%E6%95%B0%E5%80%BC%EF%BC%8C%E5%8D%B3%E4%BF%9D%E7%95%99%E4%BA%86%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BF%A1%E6%81%AF%E3%80%82%E8%80%8C%E7%9B%B4%E6%96%B9%E5%9B%BE%E8%99%BD%E7%84%B6%E8%83%BD%E5%BE%88%E5%A5%BD%E7%9A%84%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E5%B8%83%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B8%8D%E8%83%BD%E4%BF%9D%E7%95%99%E5%8E%9F%E5%A7%8B%E7%9A%84%E6%95%B0%E5%80%BC%E3%80%82%E5%9C%A8%E5%BA%94%E7%94%A8%E6%96%B9%E9%9D%A2%EF%BC%8C%E7%9B%B4%E6%96%B9%E5%9B%BE%E9%80%9A%E5%B8%B8%E9%80%82%E7%94%A8%E4%BA%8E%E5%A4%A7%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%8C%8E%E5%8F%B6%E5%9B%BE%E9%80%9A%E5%B8%B8%E9%80%82%E7%94%A8%E4%BA%8E%E5%B0%8F%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E3%80%82%0A%3E**%E7%8E%AF%E5%BD%A2%E5%9B%BE**%E5%8F%AF%E6%98%BE%E7%A4%BA%E5%A4%9A%E4%B8%AA%E6%A0%B7%E6%9C%AC%E5%90%84%E9%83%A8%E5%88%86%E6%89%80%E5%8D%A0%E7%9A%84%E7%9B%B8%E5%BA%94%E6%AF%94%E4%BE%8B%EF%BC%8C%E4%BB%8E%E8%80%8C%E6%9C%89%E5%88%A9%E4%BA%8E%E5%AF%B9%E6%9E%84%E6%88%90%E7%9A%84%E6%AF%94%E8%BE%83%E7%A0%94%E7%A9%B6%E3%80%82%0A%0A%23%23%23%20%E9%89%B4%E5%88%AB%E5%9B%BE%E8%A1%A8%E4%BC%98%E5%8A%A3%E7%9A%84%E5%87%86%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%0A%3E*%201.%E4%B8%80%E5%BC%A0%E5%A5%BD%E5%9B%BE%E5%BA%94%E5%BD%93%E9%9D%99%E5%BF%83%E8%AE%BE%E8%AE%A1%EF%BC%8C%E6%9C%89%E5%8A%A9%E4%BA%8E%E6%B4%9E%E5%AF%9F%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E8%B4%A8%E3%80%82%0A%3E*%202.%E4%B8%80%E5%BC%A0%E5%A5%BD%E5%9B%BE%E5%BA%94%E5%BD%93%E4%BD%BF%E5%A4%8D%E6%9D%82%E7%9A%84%E8%A7%82%E7%82%B9%E5%BE%97%E5%88%B0%E7%AE%80%E6%98%8E%E3%80%81%E7%A1%AE%E5%88%87%E3%80%81%E9%AB%98%E6%95%88%E7%9A%84%E9%98%90%E8%BF%B0%E3%80%82%0A%3E*%203.%E4%B8%80%E5%BC%A0%E5%A5%BD%E5%9B%BE%E5%BA%94%E5%BD%93%E8%83%BD%E5%9C%A8%E6%9C%80%E7%9F%AD%E7%9A%84%E6%97%B6%E9%97%B4%E5%86%85%E4%BB%A5%E6%9C%80%E5%B0%91%E7%9A%84%E7%AC%94%E5%A2%A8%E7%BB%99%E8%AF%BB%E8%80%85%E6%8F%90%E4%BE%9B%E5%A4%A7%E9%87%8F%E7%9A%84%E4%BF%A1%E6%81%AF%E3%80%82%0A%3E*%204.%E4%B8%80%E5%BC%A0%E5%A5%BD%E5%9B%BE%E5%BA%94%E5%BD%93%E6%98%AF%E5%A4%9A%E7%BB%B4%E7%9A%84%E3%80%82%0A%3E*%205.%E4%B8%80%E5%BC%A0%E5%A5%BD%E5%9B%BE%E5%BA%94%E5%BD%93%E8%A1%A8%E8%BF%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%83%85%E5%86%B5%E3%80%82%0A%3E%20**%E5%9C%A8%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2%E6%97%B6%EF%BC%8C%E5%BA%94%E9%81%BF%E5%85%8D%E4%B8%80%E5%88%87%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E4%BF%AE%E9%A5%B0%E3%80%82%E8%BF%87%E4%BA%8E%E8%8A%B1%E5%93%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E5%BE%80%E5%BE%80%E4%BC%9A%E4%BD%BF%E4%BA%BA%E6%B3%A8%E9%87%8D%E5%9B%BE%E5%BD%A2%E6%9C%AC%E8%BA%AB%EF%BC%8C%E8%80%8C%E6%8E%A9%E7%9B%96%E4%BA%86%E5%9B%BE%E5%BD%A2%E6%89%80%E8%A6%81%E8%A1%A8%E8%BE%BE%E7%9A%84%E4%BF%A1%E6%81%AF%E3%80%82%E5%9B%BE%E5%BD%A2%E4%BA%A7%E7%94%9F%E7%9A%84%E8%A7%86%E8%A7%89%E6%95%88%E6%9E%9C%E5%BA%94%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%89%80%E4%BD%93%E7%8E%B0%E7%9A%84%E4%BA%8B%E7%89%A9%E7%89%B9%E5%BE%81%E7%9B%B8%E4%B8%80%E8%87%B4%EF%BC%8C%E5%90%A6%E5%88%99%E6%9C%89%E5%8F%AF%E8%83%BD%E6%AD%AA%E6%9B%B2%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%BB%99%E4%BA%BA%E7%95%99%E4%B8%8B%E9%94%99%E8%AF%AF%E7%9A%84%E5%8D%B0%E8%B1%A1%E3%80%82**%0A%0A%23%23%23%20%E5%88%B6%E4%BD%9C%E7%BB%9F%E8%AE%A1%E8%A1%A8%E5%BA%94%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F%0A%3E*%20%E9%A6%96%E5%85%88%EF%BC%8C%E8%A6%81%E5%90%88%E7%90%86%E5%AE%89%E6%8E%92%E7%BB%9F%E8%AE%A1%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%8C%E6%AF%94%E5%A6%82%E8%A1%8C%E6%A0%87%E9%A2%98%E3%80%81%E5%88%97%E6%A0%87%E9%A2%98%E3%80%81%E6%95%B0%E6%8D%AE%E8%B5%84%E6%96%99%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%BA%94%E5%AE%89%E6%8E%92%E5%90%88%E7%90%86%E3%80%82%E5%BD%93%E7%84%B6%EF%BC%8C%E7%94%B1%E4%BA%8E%E5%BC%BA%E8%B0%83%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8D%E5%90%8C%EF%BC%8C%E8%A1%8C%E6%A0%87%E9%A2%98%E5%92%8C%E5%88%97%E6%A0%87%E9%A2%98%E5%8F%AF%E4%BB%A5%E4%BA%92%E6%8D%A2%EF%BC%8C%E4%BD%86%E6%98%AF%E5%BA%94%E4%BD%BF%E7%BB%9F%E8%AE%A1%E8%A1%A8%E7%9A%84%E6%A8%AA%E7%AB%96%E9%95%BF%E5%BA%A6%E6%AF%94%E4%BE%8B%E9%80%82%E5%BD%93%EF%BC%8C%E9%81%BF%E5%85%8D%E5%87%BA%E7%8E%B0%E8%BF%87%E9%AB%98%E6%88%96%E8%BF%87%E5%AE%BD%E7%9A%84%E8%A1%A8%E6%A0%BC%E5%BD%A2%E5%BC%8F%E3%80%82%0A%3E*%20%E5%85%B6%E6%AC%A1%EF%BC%8C%E8%A1%A8%E5%A4%B4%E4%B8%80%E8%88%AC%E5%BA%94%E5%8C%85%E6%8B%AC%E8%A1%A8%E5%8F%B7%E3%80%81%E6%80%BB%E6%A0%87%E9%A2%98%E5%92%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8D%95%E4%BD%8D%E7%AD%89%E5%86%85%E5%AE%B9%E3%80%82%E6%80%BB%E6%A0%87%E9%A2%98%E5%BA%94%E7%AE%80%E6%98%8E%E7%A1%AE%E5%88%87%E5%9C%B0%E6%A6%82%E6%8B%AC%E5%87%BA%E7%BB%9F%E8%AE%A1%E8%A1%A8%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E4%B8%80%E8%88%AC%E9%9C%80%E8%A6%81%E8%AF%B4%E6%98%8E%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C%E5%9C%B0%E7%82%B9%E4%BB%A5%E5%8F%8A%E4%BD%95%E7%A7%8D%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%8D%B3%E6%A0%87%E9%A2%98%E5%86%85%E5%AE%B9%E5%BA%94%E6%BB%A1%E8%B6%B33W%E8%A6%81%E6%B1%82%E3%80%82%E5%A6%82%E6%9E%9C%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%85%A8%E9%83%A8%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E8%AE%A1%E9%87%8F%E5%8D%95%E4%BD%8D%EF%BC%8C%E5%8F%AF%E5%9C%A8%E8%A1%A8%E7%9A%84%E5%8F%B3%E4%B8%8A%E8%A7%92%E6%A0%87%E6%98%8E%E3%80%82%E8%8B%A5%E5%90%84%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%A1%E9%87%8F%E5%8D%95%E4%BD%8D%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%88%99%E5%BA%94%E6%94%BE%E5%9C%A8%E6%AF%8F%E4%B8%AA%E5%8F%98%E9%87%8F%E5%90%8E%E6%88%96%E5%8D%95%E5%88%97%E5%87%BA%E4%B8%80%E5%88%97%E6%A0%87%E6%98%8E%E3%80%82%0A%3E*%20%E5%86%8D%E6%AC%A1%EF%BC%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E4%B8%A4%E6%9D%A1%E6%A8%AA%E7%BA%BF%E4%B8%80%E8%88%AC%E7%94%A8%E7%B2%97%E7%BA%BF%EF%BC%8C%E4%B8%AD%E9%97%B4%E7%9A%84%E5%85%B6%E4%BB%96%E7%BA%BF%E8%A6%81%E7%94%A8%E7%BB%86%E7%BA%BF%EF%BC%8C%E8%BF%99%E6%A0%B7%E4%BD%BF%E4%BA%BA%E7%9C%8B%E8%B5%B7%E6%9D%A5%E6%B8%85%E9%99%A4%E3%80%81%E9%86%92%E7%9B%AE%E3%80%82%E9%80%9A%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E7%BB%9F%E8%AE%A1%E8%A1%A8%E7%9A%84%E5%B7%A6%E5%8F%B3%E4%B8%A4%E8%BE%B9%E4%B8%8D%E5%B0%81%E5%8F%A3%EF%BC%8C%E5%88%97%E6%A0%87%E9%A2%98%E4%B9%8B%E9%97%B4%E5%9C%A8%E5%BF%85%E8%A6%81%E6%97%B6%E5%8F%AF%E7%94%A8%E7%AB%96%E7%BA%BF%E5%88%86%E5%BC%80%EF%BC%8C%E8%80%8C%E8%A1%8C%E6%A0%87%E9%A2%98%E4%B9%8B%E9%97%B4%E9%80%9A%E5%B8%B8%E4%B8%8D%E5%BF%85%E7%94%A8%E6%A8%AA%E7%BA%BF%E9%9A%94%E5%BC%80%E3%80%82%E6%80%BB%E4%B9%8B%E8%A1%A8%E4%B8%AD%E5%B0%BD%E9%87%8F%E5%B0%91%E7%94%A8%E6%A8%AA%E7%AB%96%E7%BA%BF%E3%80%82%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%88%AC%E6%98%AF%E5%8F%B3%E5%AF%B9%E9%BD%90%EF%BC%8C%E6%9C%89%E5%B0%8F%E6%95%B0%E7%82%B9%E6%97%B6%E5%BA%94%E4%BB%A5%E5%B0%8F%E6%95%B0%E7%82%B9%E5%AF%B9%E9%BD%90%EF%BC%8C%E8%80%8C%E4%B8%94%E5%B0%8F%E6%95%B0%E7%82%B9%E7%9A%84%E4%BD%8D%E6%95%B0%E5%BA%94%E7%BB%9F%E4%B8%80%E3%80%82%E5%AF%B9%E4%BA%8E%E6%B2%A1%E6%9C%89%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E6%A0%BC%E5%8D%95%E5%85%83%EF%BC%8C%E4%B8%80%E8%88%AC%E7%94%A8%22-%22%E8%A1%A8%E7%A4%BA%EF%BC%8C%E4%B8%80%E5%BC%A0%E5%A1%AB%E5%A5%BD%E7%9A%84%E7%BB%9F%E8%AE%A1%E8%A1%A8%E4%B8%8D%E5%BA%94%E5%87%BA%E7%8E%B0%E7%A9%BA%E7%99%BD%E5%8D%95%E5%85%83%E6%A0%BC%E3%80%82%0A%0A%0A%23%23%23%20**%E9%94%99%E9%A2%98%E9%9B%86**%0A*%201.%E6%A0%B7%E6%9C%AC%E6%88%96%E6%80%BB%E4%BD%93%E4%B8%AD%E5%90%84%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%88%AB%E6%95%B0%E5%80%BC%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E5%80%BC%E7%A7%B0%E4%B8%BA**%E6%AF%94%E7%8E%87**%0A*%202.%E5%B0%86%E6%AF%94%E4%BE%8B%E4%B9%98%E4%BB%A5100%E5%BE%97%E5%88%B0%E7%9A%84%E6%95%B0%E5%80%BC%E7%A7%B0%E4%B8%BA**%E7%99%BE%E5%88%86%E6%95%B0**%0A*%203.**%E9%A5%BC%E5%9B%BE**%E6%9C%80%E9%80%82%E5%90%88%E6%8F%8F%E8%BF%B0%E7%BB%93%E6%9E%84%E6%80%A7%E9%97%AE%E9%A2%98%0A*%204.**%E7%8E%AF%E5%BD%A2%E5%9B%BE**%E9%80%82%E5%90%88%E4%BA%8E%E6%AF%94%E8%BE%83%E7%A0%94%E7%A9%B6%E4%B8%A4%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E6%A0%B7%E6%9C%AC%E6%88%96%E6%80%BB%E4%BD%93%E7%9A%84%E7%BB%93%E6%9E%84%E6%80%A7%E9%97%AE%E9%A2%98%0A*%205.%E6%9C%80%E9%80%82%E5%90%88%E6%8F%8F%E8%BF%B0%E4%B8%80%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%98%AF**%E7%9B%B4%E6%96%B9%E5%9B%BE**%0A*%206.%E5%AF%B9%E4%BA%8E%E5%A4%A7%E6%89%B9%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%9C%80%E9%80%82%E5%90%88%E6%8F%8F%E8%BF%B0%E5%88%86%E5%B8%83%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%98%AF**%E7%9B%B4%E6%96%B9%E5%9B%BE**%0A*%207.%E5%AF%B9%E4%BA%8E%E5%B0%8F%E6%89%B9%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%9C%80%E9%80%82%E5%90%88%E6%8F%8F%E8%BF%B0%E5%88%86%E5%B8%83%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%98%AF**%E8%8C%8E%E5%8F%B6%E5%9B%BE**%0A*%208.%E5%AF%B9%E4%BA%8E%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%94%A8%E4%BA%8E%E6%8F%8F%E8%BF%B0%E5%85%B6%E5%8F%98%E5%8C%96%E8%B6%8B%E5%8A%BF%E7%9A%84%E5%9B%BE%E5%BD%A2%E9%80%9A%E5%B8%B8%E6%98%AF**%E7%AE%B1%E7%BA%BF%E5%9B%BE**%0A*%209.%E6%B0%94%E6%B3%A1%E5%9B%BE%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E%E6%8F%8F%E8%BF%B0**%E4%B8%89%E4%B8%AA%E5%8F%98%E9%87%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E5%85%B3%E5%85%B3%E7%B3%BB**%0A*%2010.%E4%B8%8E%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9B%B8%E6%AF%94%E8%8C%8E%E5%8F%B6%E5%9B%BE**%E4%BF%9D%E7%95%99%E4%BA%86%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BF%A1%E6%81%AF**%0A*%2011.**%E8%8C%8E%E5%8F%B6%E5%9B%BE**%E4%B8%8D%E9%80%82%E5%90%88%E6%8F%8F%E8%BF%B0%E5%88%86%E7%B1%BB%E6%95%B0%E6%8D%AE%0A*%2012.%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%B8%8E%E6%9D%A1%E5%BD%A2%E5%9B%BE%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B9%8B%E4%B8%80%E6%98%AF**%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E5%90%84%E7%9F%A9%E5%BD%A2%E9%80%9A%E5%B8%B8%E6%98%AF%E8%BF%9E%E7%BB%AD%E6%8E%92%E5%88%97%E7%9A%84%EF%BC%8C%E8%80%8C%E6%9D%A1%E5%BD%A2%E5%9B%BE%E5%88%99%E6%98%AF%E5%88%86%E5%BC%80%E6%8E%92%E5%88%97%E7%9A%84** 转载于:https://www.cnblogs.com/pandaboy1123/p/10437449.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85f4e0d40d9ff1c0c118e3c4b2694802/" rel="bookmark">
			C/C&#43;&#43; — Socket通讯错误码解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#define	EPERM	1	/* Operation not permitted */ 操作不允许 #define	ENOENT	2	/* No such file or directory */ 文件或路径不存在 #define	ESRCH	3	/* No such process */ 进程不存在 #define	EINTR	4	/* Interrupted system call */ 中断的系统调用 #define	EIO	5	/* I/O error */ I/O错误 #define	ENXIO	6	/* No such device or address */ 设备或地址不存在 #define	E2BIG	7	/* Argument list too long */ 参数列表过长 #define	ENOEXEC	8	/* Exec format error */ 执行格式错误 #define	EBADF	9	/* Bad file number */ 错误的文件编码 #define	ECHILD	10	/* No child processes */ 子进程不存在 #define	EAGAIN	11	/* Try again */ 重试，非阻塞socket一般在缓冲区无数据时返回，阻塞socket标识超时 #define	ENOMEM	12	/* Out of memory */ 内存不足 #define	EACCES	13	/* Permission denied */ 没有权限 #define	EFAULT	14	/* Bad address */ 地址错误 #define	ENOTBLK	15	/* Block device required */ 需要块设备 #define	EBUSY	16	/* Device or resource busy */ 设备或资源忙 #define	EEXIST	17	/* File exists */ 文件已经存在 #define	EXDEV	18	/* Cross-device link */ 跨设备链路 #define	ENODEV	19	/* No such device */ 设备不存在 #define	ENOTDIR	20	/* Not a directory */ 文件夹路径不存在 #define	EISDIR	21	/* Is a directory */ 是文件夹路径 #define	EINVAL	22	/* Invalid argument */ 无效参数 #define	ENFILE	23	/* File table overflow */ 文件表溢出 #define	EMFILE	24	/* Too many open files */ 打开的文件描过多 #define	ENOTTY	25	/* Not a typewriter */ 非打字机 #define	ETXTBSY	26	/* Text file busy */ 文本文件忙，缓冲区被占用 #define	EFBIG	27	/* File too large */ 文件过大 #define	ENOSPC	28	/* No space left on device */ 设备没有剩余空间 #define	ESPIPE	29	/* Illegal seek */ 非法查询 #define	EROFS	30	/* Read-only file system */ 文件系统只读 #define	EMLINK	31	/* Too many links */ 连接过多，超过系统限制 #define	EPIPE	32	/* Broken pipe */ 管道破裂 #define	EDOM	33	/* Math argument out of domain of func */ 参数超出函数域 #define	ERANGE	34	/* Math result not representable */ 结果无法表示 #define	EDEADLK	35	/* Resource deadlock would occur */ 资源将发生死锁 #define	ENAMETOOLONG	36	/* File name too long */ 文件名过长 #define	ENOLCK	37	/* No record locks available */ 没有可用的记录锁 #define	ENOSYS	38	/* Function not implemented */ 函数未实现 #define	ENOTEMPTY	39	/* Directory not empty */ 文件夹非空 #define	ELOOP	40	/* Too many symbolic links encountered */ 遇到太多的符号连接 #define	EWOULDBLOCK	EAGAIN	/* Operation would block */ 操作将阻塞 #define	ENOMSG	42	/* No message of desired type */ 没有符合需求类型的消息 #define	EIDRM	43	/* Identifier removed */ 标识符已移除 #define	ECHRNG	44	/* Channel number out of range */ 通道编号超出范围 #define	EL2NSYNC	45	/* Level 2 not synchronized */ Level 2 未同步 #define	EL3HLT	46	/* Level 3 halted */ Level 3 停止 #define	EL3RST	47	/* Level 3 reset */ Level 3 重置 #define	ELNRNG	48	/* Link number out of range */ 连接数量超出范围 #define	EUNATCH	49	/* Protocol driver not attached */ 协议驱动程序未附加 #define	ENOCSI	50	/* No CSI structure available */ 无CSI结构可用 #define	EL2HLT	51	/* Level 2 halted */ Level 2 停止 #define	EBADE	52	/* Invalid exchange */ 无效的交换 #define	EBADR	53	/* Invalid request descriptor */ 无效的请求描述 #define	EXFULL	54	/* Exchange full */ 交换完全 #define	ENOANO	55	/* No anode */ 无阳极 #define	EBADRQC	56	/* Invalid request code */ 无效的请求码 #define	EBADSLT	57	/* Invalid slot */ 无效的插槽 #define	EDEADLOCK	EDEADLK #define	EBFONT	59	/* Bad font file format */ 错误的字体文件格式 #define	ENOSTR	60	/* Device not a stream */ 设备非流 #define	ENODATA	61	/* No data available */ 无有效数据 #define	ETIME	62	/* Timer expired */ 计时器到期 #define	ENOSR	63	/* Out of streams resources */ 超出流资源 #define	ENONET	64	/* Machine is not on the network */ 机器不在网络 #define	ENOPKG	65	/* Package not installed */ 未安装包 #define	EREMOTE	66	/* Object is remote */ 对象是远程 #define	ENOLINK	67	/* Link has been severed */ 链接正在服务中 #define	EADV	68	/* Advertise error */ 广告错误 #define	ESRMNT	69	/* Srmount error */ 这个错误是RFS特定的。 当远程计算机仍在装载资源时尝试停止RFS，或者当资源使用不包含具有当前装入的资源的远程计算机的客户机列表重新进行读取时发生。 #define	ECOMM	70	/* Communication error on send */ 发送过程中通讯错误 #define	EPROTO	71	/* Protocol error */ 协议错误 #define	EMULTIHOP	72	/* Multihop attempted */ 多跳尝试 #define	EDOTDOT	73	/* RFS specific error */ RFS特殊错误 #define	EBADMSG	74	/* Not a data message */ 不是数据类型的消息 #define	EOVERFLOW	75	/* Value too large for defined data type */ 对指定的数据类型来说值太大 #define	ENOTUNIQ	76	/* Name not unique on network */ 网络上名字不唯一 #define	EBADFD	77	/* File descriptor in bad state */ 文件描述符状态错误 #define	EREMCHG	78	/* Remote address changed */ 远程地址改变 #define	ELIBACC	79	/* Can not access a needed shared library */ 无法访问需要的共享库 #define	ELIBBAD	80	/* Accessing a corrupted shared library */ 访问损坏的共享库 #define	ELIBSCN	81	/* .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85f4e0d40d9ff1c0c118e3c4b2694802/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4839927b5bbdf0e8dfdb17aea88797c/" rel="bookmark">
			Spring REST Docs 介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring REST Docs 是一个为 Spring 项目生成 API 文档的框架，它通过在单元测试中额外添加 API 信息描述，从而自动生成对应的文档片段。
本文会以一个最简单的示例介绍如何在一个 Spring Boot 应用中使用 Spring REST Docs，并在最后与目前最常见的 SpringFox 进行一些对比，分别介绍其特点和优劣。
基础准备 首先需要一个 Spring Boot 项目，并通过 MockMvc 编写一些简单的测试。
@RestController public class HelloController { @GetMapping("hello") public Result hello(@RequestParam("name") String name) { return new Result(200, String.format("Hello %s!", name)); } } 在上面代码中提供了一个最简单的 Controller，其接收请求参数中的 name 属性，并返回一个包含 code 和 msg 的 Result 对象。
接下来需要为其编写一个测试：
@WebMvcTest @ExtendWith(SpringExtension.class) public class HelloControllerTests { @Autowired private MockMvc mockMvc; @Test public void testHello() throws Exception { mockMvc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4839927b5bbdf0e8dfdb17aea88797c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f49c21a979eca7d9a24fac08cdd2691e/" rel="bookmark">
			can&#39;t open! &#34;[Microsoft][ODBC 驱动程序管理器] 未发现数据源名称并且未指定默认驱动程序 QODBC3: Unable to connect&#34;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows平台，使用Qt +ODBC连接数据库报错：
can't open! "[Microsoft][ODBC 驱动程序管理器] 未发现数据源名称并且未指定默认驱动程序 QODBC3: Unable to connect"
问题原因：
原来这个databasename指的是图1中的1，
我原来以为是2.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7176c7dcd8489d4b0c3468823941ee6/" rel="bookmark">
			python下判断文件夹是否存在并创建文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python代码：
import os if not os.path.exists('filename/'): #判断所在目录下是否有该文件名的文件夹 os.mkdirs('filename/test.txt') #创建多级目录用mkdirs，单击目录mkdir else: if os.path.exists('file'): print('the file exists') else: os.chdir('filename/') os.mknod("test.txt") #创建空文件 python中对文件、文件夹（文件操作函数）的操作需要涉及到os模块和shutil模块。
得到当前工作目录，即当前Python脚本工作的目录路径: os.getcwd()
返回指定目录下的所有文件和目录名:os.listdir()
函数用来删除一个文件:os.remove()
删除多个目录：os.removedirs（r“c：\python”）
检验给出的路径是否是一个文件：os.path.isfile()
检验给出的路径是否是一个目录：os.path.isdir()
判断是否是绝对路径：os.path.isabs()
检验给出的路径是否真地存:os.path.exists()
返回一个路径的目录名和文件名:os.path.split() eg os.path.split('/home/swaroop/byte/code/poem.txt') 结果：('/home/swaroop/byte/code', 'poem.txt') 分离扩展名：os.path.splitext()
获取路径名：os.path.dirname()
获取文件名：os.path.basename()
运行shell命令: os.system()
读取和设置环境变量:os.getenv() 与os.putenv()
给出当前平台使用的行终止符:os.linesep Windows使用'\r\n'，Linux使用'\n'而Mac使用'\r'
指示你正在使用的平台：os.name 对于Windows，它是'nt'，而对于Linux/Unix用户，它是'posix'
重命名：os.rename（old， new）
创建多级目录：os.makedirs（r“c：\python\test”）
创建单个目录：os.mkdir（“test”）
获取文件属性：os.stat（file）
修改文件权限与时间戳：os.chmod（file）
终止当前进程：os.exit（）
获取文件大小：os.path.getsize（filename）
文件操作：
os.mknod("test.txt") 创建空文件
fp = open("test.txt",w) 直接打开一个文件，如果文件不存在则创建文件
关于open 模式：
w 以写方式打开，
a 以追加模式打开 (从 EOF 开始, 必要时创建新文件)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7176c7dcd8489d4b0c3468823941ee6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4b7d3925e5dc75b9c51bcb26fb04234/" rel="bookmark">
			SQL 消息 7391，因为链接服务器‘’的OLE DB访问接口 ‘SQLNCLI’无法启动分布式事务问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统：Windows Server 2008 +MS SQL 2008 2R
场景：在将SQL 2005数据库迁移到SQL 2008上时对链接服务器的数据表做增删改是正常的，在触发器中对链接服务器的数据表做增删改就有问题了，上图
来自微软官方的决解方案：
https://support.microsoft.com/zh-cn/help/329332/you-receive-error-7391-when-you-run-a-distributed-transaction-against
来自网络对该问题处理方式（测试无效做个记录方便以后排查问题）
--1、是否启动MSDTC服务（需确认双方服务器都开启）
--2、双方135端口是否开启、是否被占用（可用 telnet IP 135 指令检测端口是否打开）
--3、保证没有在发起事物的服务器里执行链接服务器上的查询、视图、存储过程中包含有访问发起事物服务器的操作，
-- 这样的操作叫环回（loopback），举个“栗子”：A服务器中执行链接服务器B的存储过程sp_b,在sp_b中存在访问A的操作
--4、查看MSDTC设置
-- 打开“管理工具-》组件服务-》计算机-》我的电脑-》MSDTC选项-》安全配置
-- 在安全配置里选中：
-- （1）网络DTC访问
-- （2）允许远程客户端、允许远程管理
-- （3）允许入站、允许出站、不要求进行验证
-- （4）DTC登录用户必须保证为：NT Authority/NetWork Service
-- 配置完以上所有重启服务器使配置生效（有些电脑可能要先启动DTC服务然后在启动SQL SERVER服务）
--5、链接服务器名称解析问题
-- 找到服务器中的hots文件添加IP + 服务器名称解析
以上所有步骤执行完发现问题依旧存在（这时候基本可以排除MSDTC服务的问题了）
继续排查MSDTC依赖组件是否有问题
可以看出DTC依赖的几个系统组件
这时候祭出微软的dtcping.exe 下载地址：https://www.microsoft.com/en-us/download/details.aspx?id=2868
（dtcping 可能无法直接ping IP 所以需要在系统的host文件中添加IP映射）
.
从这里看的出是RPC服务有问题
CMKERP2 IP=xxx.24.78.30
ERP-GHN0 IP=xxx.24.78.65
但是在CMKERP2中 用DTCPING工具ping ERP-GHN0 IP=xxx.24.78.100
到现在为止问题很明显了就是存在两台服务器名称一致但是IP不同并且两台电脑存在同一个域中
导致了两台服务器通过服务器名称相互访问时一直导致RPC有问题
最后将.100这台服务器名称改了，并且在域中的映射也改了，最后ERP-GHN0指向了.65
问题决解
最后可通过cmd指令 nbtstat -a IP来取得主机名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4b7d3925e5dc75b9c51bcb26fb04234/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6f0d55e6cc91ecbd502f2369bfc4c08/" rel="bookmark">
			Mockito框架@Mock, @InjectMocks注解使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近写项目Junit，使用Junit4框架，测试的数据都要依赖数据库，而好多接口需要调其他的系统，junit4框架完全无法实现测试功能，大佬推荐用Mockito框架，这篇博客用来记录学习Mockito的使用方法，不足欢迎指点。
@Mock, @InjectMocks使用方法：
1、导入依赖
&lt;dependency&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-all&lt;/artifactId&gt; &lt;version&gt;1.8.5&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 2、mockito一个简单案例
@Test public void argumentMatchersTest(){ List&lt;String&gt; mock = mock(List.class); when(mock.get(anyInt())).thenReturn("Hello").thenReturn("World"); String result=mock.get(100)+" "+mock.get(200); verify(mock,times(2)).get(anyInt()); assertEquals("Hello World",result); } List mock = mock(List.class); 的作用就是创建一个mock模拟对象。
when(…).thenReturn（…）; 返回预期值，当代用when里面方法时返回指定的值。
when(mock.get(anyInt())).thenReturn(“Hello”).thenReturn(“World”);
第一次当调用mock.get(anyInt())方法就会返回字符串Hello，再次调用返回字符串World。
3、打桩支持迭代风格的返回值设定：
// 第一种方式 when(i.next()).thenReturn("Hello").thenReturn("World"); // 第二种方式 when(i.next()).thenReturn("Hello", "World"); // 第三种方式，都是等价的 when(i.next()).thenReturn("Hello"); when(i.next()).thenReturn("World"); 4、mockito需要添加@RunWith(MockitoJUnitRunner.class)
如果使用的Junit + mockito测试，那肯定使用的是@RunWith(SpringJUnit4ClassRunner.class)，这时候需要在添加mockito的初始化。
@RunWith(MockitoJUnitRunner.class) public class ArticleManagerTest { @Mock ArticleCalculator calculator; @Mock ArticleDatabase database; @Mock User user; @InjectMocks private ArticleManager manager; //① @Test public void shouldDoSomething() { //使用了一个ArticleListener实例调用了addListener manager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6f0d55e6cc91ecbd502f2369bfc4c08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ad9f3b6996c7218dc511124664b4186/" rel="bookmark">
			文件服务器存储解决方案探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 定义 文件服务器(file servers)是一种器件，它的功能就是向服务器提供文件。
它加强了存储器的功能，简化了网络数据的管理。
它一则改善了系统的性能，提高了数据的可用性，二则减少了管理的复杂程度，降低了运营费用。
2 简介 在C/S模式下，文件服务器（file server）是一台对中央存储和数据文件管理负责的计算机，这样在同一网络中的其他计算机就可以访问这些文件.
文件服务器允许用户在网络上共享信息，而不用通过软盘或一些其它外部存储设备来物理地移动文件;
任何计算机都能被设置为主机，并作为文件服务器（file server）运行
最简单的形式是，文件服务器可以是一台普通的个人计算机，它处理文件要求并在网络中发送它们;
在更复杂的网络中，文件服务器也可以是一台专门的网络附加存储（NAS）设备，它也可以作为其他计算机的远程硬盘驱动器来运行，并允许网络中的人像在他们自己的硬盘中一样在服务器中存储文件.
文件服务器具有分时系统文件管理的全部功能，提供网络用户访问文件、目录的并发控制和安全保密措施的局域网（LAN）服务器.
3 常见开源服务器 3.1 EasyFS 支持缩略图，支持单选、多选，下载支持中文名，不依赖其它容器，可独立部署，使用Java语言、SpringBoot框架开发.
3.2 FastDFS 是一个开源的分布式文件系统，对文件进行管理
功能 文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题.
特别适合以文件为载体的在线服务，如相册网站、视频网站等等.
主要是针对互联网中的小文件系统，没有文件索引数据库，整体性能很高 原理 3.3 HDFS 简介 优点 高可靠性。Hadoop按位存储和处理数据的能力值得人们信赖。
高扩展性。Hadoop是在可用的计算机集簇间分配数据并完成计算任务的，这些集簇可以方便地扩展到数以千计的节点中。
高效性。Hadoop能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。
高容错性。Hadoop能够自动保存数据的多个副本，并且能够自动将失败的任务重新分配。
低成本。与一体机、商用数据仓库以及QlikView、Yonghong Z-Suite等数据集市相比，hadoop是开源的，项目的软件成本因此会大大降低。
Hadoop带有用Java语言编写的框架，因此运行在 Linux生产平台上是非常理想的。Hadoop上的应用程序也可以使用其他语言编写，比如 C++。
Hadoop是目前最流行的的分布式文件系统之一，能找到的资料相当丰富。
从使用的角度说，Hadoop的使用和使用FTP有点类似
3.4 TFS 淘宝使用的文件系统，用于图片存储，在小文件存储上比较有优势，但随着写的增加，读文件的效率会降低.
TFS（Taobao FileSystem）是一个高可扩展、高可用、高性能、面向互联网服务的分布式文件系统，主要针对海量的非结构化数据，它构筑在普通的Linux机器集群上，可为外部提供高可靠和高并发的存储访问.
TFS为淘宝提供海量小文件存储，通常文件大小不超过1M，满足了淘宝对小文件存储的需求，被广泛地应用在淘宝各项应用中。它采用了HA架构和平滑扩容，保证了整个文件系统的可用性和扩展性。同时扁平化的数据组织结构，可将文件名映射到文件的物理地址，简化了文件的访问流程，一定程度上为TFS提供了良好的读写性能。
总体结构 一个TFS集群由两个NameServer节点（一主一备）和多个DataServer节点组成。这些服务程序都是作为一个用户级的程序运行在普通Linux机器上的。
在TFS中，将大量的小文件(实际数据文件)合并成为一个大文件，这个大文件称为块(Block), 每个Block拥有在集群内唯一的编号(Block Id), Block Id在NameServer在创建Block的时候分配, NameServer维护block与DataServer的关系。Block中的实际数据都存储在DataServer上。而一台DataServer服务器一般会有多个独立DataServer进程存在，每个进程负责管理一个挂载点，这个挂载点一般是一个独立磁盘上的文件目录，以降低单个磁盘损坏带来的影响。
NameServer主要功能是: 管理维护Block和DataServer相关信息,包括DataServer加入，退出, 心跳信息, block和DataServer的对应关系建立，解除。正常情况下，一个块会在DataServer上存在， 主NameServer负责Block的创建，删除，复制，均衡，整理，NameServer不负责实际数据的读写，实际数据的读写由DataServer完成。
DataServer主要功能是: 负责实际数据的存储和读写。
同时为了考虑容灾，NameServer采用了HA结构，即两台机器互为热备，同时运行，一台为主，一台为备，主机绑定到对外vip，提供服务；当主机器宕机后，迅速将vip绑定至备份NameServer，将其切换为主机，对外提供服务。图中的HeartAgent就完成了此功能
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69d8cafc453686259028e0903cef95a2/" rel="bookmark">
			struts2文件上传大小限制问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一下我老师大神的人工智能教程。零基础！通俗易懂！风趣幽默！还带黄段子！希望你也加入到我们人工智能的队伍中来！https://blog.csdn.net/jiangjunshow
struts2默认文件上传大小为2M,如需修改默认大小,解决方法如下：
&lt;struts&gt; &lt;constant name="struts.multipart.maxSize" value="20971520" /&gt; &lt;!-- 设置允许最大值 20MB(1024*1024*20) --&gt; &lt;package name="build" extends="struts-default"&gt; &lt;action name="fileUpload" class="com.home.UploadAction" method="upload"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;result name="input"&gt;/error.jsp&lt;/result&gt; &lt;!-- &lt;param name="allowedTypes"&gt;&lt;/param&gt; 允许文件类型 --&gt; &lt;interceptor-ref name="fileUpload"&gt; &lt;param name="maximumSize"&gt;5242880&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="defaultStack" /&gt; &lt;!-- 默认拦截器 --&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; struts.multipart.maxSize和fileUpload拦截器的maximumSize属性分工不同
1、struts.multipart.maxSize控制整个项目所上传文件的最大size。超过这个值,后台报错
the request was rejected because its size (51224434) exceeds the configured maximum (20971520)
2、fileUpload拦截器的maximumSize属性必须小于struts.multipart.maxSize的值。
struts.multipart.maxSize默认2M,当maximumSize大于2M时,必须设置struts.multipart.maxSize的值大于maximumSize。
3、当上传的文件在maxSize和maximumSize之间时,系统提示
The file is to large to be uploaded: file "apache-tomcat-7.0.47.zip""upload_94d9d06c_a45f_b91e4c915c02_00000002.tmp" 8782342
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69d8cafc453686259028e0903cef95a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ed6941c260cf67731cfe32322cc467d/" rel="bookmark">
			深度学习：语义分割 FCN与Unet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://blog.csdn.net/wyzjack47/article/details/81107980
图像分割： 什么是图像分割问题呢？ 简单的来讲就是给一张图像，检测是用框出框出物体，而图像分割分出一个物体的准确轮廓。也这样考虑，给出一张图像 Ｉ，这个问题就是求一个函数，从I映射到Mask。至于怎么求这个函数有多种方法。我们可以看到这个图，左边是给出图像，可以看到人和摩托车，右边是分割结果. 像素级分类。mask=function(I)
图像分割：两个框架 一个基于 cnn 一个基础 FCN 一、FCN(fully convolutional network) 论文：Fully Convolutional Networks for Semantic Segmentation. Jonathan Long ,Evan Shelhamer ,Trevor Darrell
第一次将深度学习结合起来的是这篇文章全卷积网络(FCN)，利用深度学习求这个函数。在此之前深度学习一般用在分类和检测问题上。由于用到CNN，所以最后提取的特征的尺度是变小的。和我们要求的函数不一样，我们要求的函数是输入多大，输出有多大。为了让CNN提取出来的尺度能到原图大小，FCN网络利用上采样和反卷积到原图像大小。然后做像素级的分类。输入原图，经过VGG16网络，得到特征map,然后将特征map上采样回去。再将预测结果和ground truth每个像素一一对应分类，做像素级别分类。也就是说将分割问题变成分类问题，而分类问题正好是深度学习的强项。如果只将特征map直接上采样或者反卷积，明显会丢失很多信息。
FCN毫无疑问是语义分割领域的经典之作，在FCN出现之前，传统的CNN分割是将像素周围一个小区域作为CNN输入，做训练和预测，这样低效且不准确（忽略整体信息）。CNN主要有三点创新：
• 卷积化：即将传统CNN结构（文中提到的Alexnet、VGG）最后的全连接层改成卷积层，以便进行直接分割，这是十分有创造性的。
• 上采样：由于网络过程中进行了一系列下采样，使得特征层大小减小，了最后得到的预测层和原图一致，需要采用上采样，作用类似于反卷积。
• 并联跳跃结构：想法类似于resnet和inception，在进行分类预测时利用多层信息，具体如下图：
FCN采取解决方法是将pool4、pool3、和特征map融合起来，由于pool3、pool4、特征map大小尺寸是不一样的，所以融合应该前上采样到同一尺寸。这里的融合是拼接在一起(concact)，不是对应元素相加。
FCN是深度学习在图像分割的开山之作，FCN优点是实现端到端分割等，缺点是分割结果细节不够好，可以看到图四，FCN8s是上面讲的pool4、pool3和特征map融合，FCN16s是pool4和特征map融合，FCN32s是只有特征map，得出结果都是细节不够好，具体可以看自行车。由于网络中只有卷积没有全连接，所以这个网络又叫全卷积网络
二、Unet:医学影像分割的基石 论文：U-Net: Convolutional Networks for Biomedical Image Segmentation. Olaf Ronneberger, Philipp Fischer, and Thomas Brox
医学影像分割的论文，大部分都以Unet为基础进行改良，可见其重要性。而Unet是在FCN的基础上进行改良的，其网络结构如下：
可见，Unet 包括左边的收缩路径和右边的扩张路径。收缩路径就是经结构，包括几个 3 × 3 的卷积加 RELU 激活层再加 2 × 2maxpooling 的结构(stride :2) ，下采样的每一步特征通道数都增加一倍。扩张路径的每一步包括上采样、 2 × 2 卷积（减少一半通道数），和相应收缩路径中的剪裁过的特征层的串联以及两个 3 × 3 卷积加 RELU 。最后一层用了 1 × 1 卷积把64个通道
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ed6941c260cf67731cfe32322cc467d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb7a1371206c83fa18b16edd7f12291e/" rel="bookmark">
			Scrapy - Request 和 Response（请求和响应）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Requests and Responses：http://doc.scrapy.org/en/latest/topics/request-response.html
Requests and Responses（中文版）：https://scrapy-chs.readthedocs.io/zh_CN/latest/topics/request-response.html
请求 和 响应 通常，Request对象 在 爬虫程序中生成并传递到系统，直到它们到达下载程序，后者执行请求并返回一个 Response对象，该对象 返回到发出请求的爬虫程序。
上面一段话比较拗口，有 web 经验的同学，应该都了解的，不明白看下面的图大概理解下。
爬虫 -&gt; Request:创建Request -&gt; Response:获取下载数据Response -&gt; 爬虫:数据 Request 和 Response 类 都有一些子类，它们添加基类中不需要的功能。这些在下面 的 请求子类 和 响应子类中描述。
Request objects class scrapy.http.Request (url [, callback, method='GET', headers, body, cookies, meta, encoding='utf-8', priority=0, dont_filter=False, errback, flags] )
一个 Request 对象 表示一个 HTTP请求，它通常是在爬虫生成，并由下载执行，从而生成 Response 对象。
参数：
url (string) – the URL of this requestcallback (callable) – the function that will be called with the response of this request (once its downloaded) as its first parameter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb7a1371206c83fa18b16edd7f12291e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bc4cfb1e978466deb2b555f2e0c7313/" rel="bookmark">
			关于SpringMVC&#43;Spring&#43;Mybatis&#43;JQuery&#43;BootStrap_Table的Maven项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于SpringMVC与Spring结合Mybatis的Maven项目 各类文件位置 简单的POM.xml配置 &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.johe.scgcxx&lt;/groupId&gt; &lt;artifactId&gt;com.scgcxx&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- Servlet依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring 上下文依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- SpringMVC 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springmvc依赖的json支持包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring JDBC 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aop依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bc4cfb1e978466deb2b555f2e0c7313/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c141bb1070ad220eecf4781f56625509/" rel="bookmark">
			重拾golang - go目录结构说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go 目录结构说明 golang集多编程范式之大成者，使开发者能够快速的开发、测试、部署程序，支持全平台静态编译。go具有优秀的依赖管理，高效的运行效率，庞大的第三方库支持以及在国内持续的增长势头。
作为开发者的我们也将不得不重视这门语言的兴起。首先向大家讲解一下go语言开发环境的目录结构，让我们更清楚的认识它。
一、goroot开发包目录 当我们安装好后，会在安装目录出现一个go/文件夹，如果是windows目录应在再C:/go下（默认），如果是unix/linux一般会在/usr/local/go下，这个目录是unix software resource的含义。 # liunx上目录位置 chao@chao-PC:/usr/local/go$ pwd /usr/local/go # 主要目录包含如下图，分别进行说明： 1、api文件夹 存放Go API检查器的辅助文件。其中，go1.1.txt、go1.2.txt、go1.3.txt和go1.txt文件分别罗列了不同版本的Go语言的全部API特征；except.txt文件中罗列了一些（在不破坏兼容性的前提下）可能会消失的API特性；next.txt文件则列出了可能在下一个版本中添加的新API特性。 2、bin文件夹 存放所有由官方提供的Go语言相关工具的可执行文件。默认情况下，该目录会包含go和gofmt这两个工具。 3、doc文件夹 存放Go语言几乎全部的HTML格式的官方文档和说明，方便开发者在离线时查看。 4、misc文件夹 存放各类编辑器或IDE（集成开发环境）软件的插件，辅助它们查看和编写Go代码。有经验的软件开发者定会在该文件夹中看到很多熟悉的工具。 查看： chao@chao-PC:/usr/local/go/misc$ ls android benchcmp chrome git linkcheck sortac tour arm cgo editors ios nacl swig trace 5、pkg文件夹 用于在构建安装后，保存Go语言标准库的所有归档文件。pkg文件夹包含一个与Go安装平台相关的子目录，我们称之为“平台相关目录”。例如，在针对Linux 32bit操作系统的二进制安装包中，平台相关目录的名字就是linux_386；而在针对Windows 64bit操作系统的安装包中，平台相关目录的名字则为windows_amd64。
Go源码文件对应于以“.a”为结尾的归档文件，它们就存储在pkg文件夹下的平台相关目录中。 值得一提的是，pkg文件夹下有一个名叫tool的子文件夹，该子文件夹下也有一个平台相关目录，其中存放了很多可执行文件。关于这些可执行文件的用途，读者可参见附属于本书的Go命令教程。
查看： chao@chao-PC:/usr/local/go/pkg$ ls include linux_amd64_dynlink linux_amd64_shared tool linux_amd64 linux_amd64_race linux_amd64_testcshared_shared 6、src文件夹 存放所有标准库、Go语言工具，以及相关底层库（C语言实现）的源码。通过查看这个文件夹，可以了解到Go语言的方方面面。 查看： chao@chao-PC:/usr/local/go/src$ ls all.bash clean.bat errors iostest.bash os sort all.bat clean.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c141bb1070ad220eecf4781f56625509/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fd36592ee7c66caff12093df6b650c1/" rel="bookmark">
			二叉树的前（先）序中序和后序遍历 以及如何通过两个序列确定唯一二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 三种遍历前（先）序遍历。中序遍历。后序遍历。 举几个例子两个序列确定一个二叉树 最近做了一套卷子，考了二叉树的遍历。有点生疏，回顾一下，如何通过两种遍历序列确定一颗二叉树。
三种遍历 先中后表示对根节点访问的先后顺序，对子树都是先左后右。
前（先）序遍历。 遍历顺序是 根节点 -&gt;左子树（节点）-&gt;右子树（节点）
可以理解成
1 存在根节点，访问根节点2 存在左子树或节点的话，访问该节点，若存在左子树，继续执行2，直到左路走到底3 左子树访问到底，该节点只剩下右子树（节点），访问该节点。（此时可以理解成该节点左子树和右子树为空）当一个左子树遍历完。回溯到上一节点。遍历右子树。直到全部遍历完。 中序遍历。 遍历顺序是 左子树（节点） -&gt;根节点-&gt;右子树（节点）
可以理解成当一个节点的左子树遍历完，才遍历这个节点，故需要找到最左的叶子节点开始遍历。若不存在则先遍历根节点，然后在右子树中寻找最左的叶子节点
1 寻找最左边最下的叶子节点，访问该节点2 遍历完左边子树（节点），访问该节点对应的父节点。3 访问父节点后，遍历右子树（也可以当做一个新的树处理） 后序遍历。 遍历顺序是 左子树（节点） -&gt;右子树（节点）-&gt;根节点
可以理解成当一个节点的左子树和右子树都遍历完，才遍历这个节点，同样需要找到最左的叶子节点开始遍历。
1 寻找最左下的叶子节点，访问该节点2 遍历完左边子树（节点），访问该节点对应的兄弟节点。3 访问根节点4 回溯到上一层（3中的根节点作为向上一层的左或右节点）继续执行123，直到遍历到根节点 举几个例子 前序序列：ABCDEF
中序序列：CBDAEF
后续序列：CDBFEA
前序序列：ABDEFGCHI
中序序列：DBFEGACIH
后续序列：DFGEBIHCA
前序序列：ABCDEGF
中序序列：CBEGDFA
后续遍历：CGEFDBA
两个序列确定一个二叉树 给出一个中序序列，再给一个前序或后续序列，则可以确定一个个唯一的二叉树。
这里需要注意的是，两个序列中必须有一个中序序列才可以。 前序和后续组合无法确定唯一二叉树
根据三种遍历方式的特性，可以知道。前序遍历第一个出现的则是它的根节点。后续最后一个是根节点。而将这个节点放在中序序列中，左边则是根节点的左子树，右边是右子树。
我们用最后一个例子的前序和中序来试着确定一个唯一的二叉树。
首先A是根节点，由于A在中序中位于最后，则这个二叉树没有右子树。则B是A的左节点B在中序中，左边只有C，故B的左子树只有C由前序知道，D是B的右节点，同时可以把它当做是一个新的子树来分析。把ABC从中序序列中拿掉，同时D的右边只有F，则D的右子树只有F这时，只剩下E和G没有位置了。无疑，这两个位于D的左子树。这时他俩的前序序列是EG，则E是D的左节点，中序序列是EG，则G是E的右节点。完成 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ef1e9b621209e53b1bcfcb3b252348f/" rel="bookmark">
			有道云笔记快捷键用法（加自己的补充）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有道云笔记快捷键设置介绍：
1.切换界面模块隐藏(快捷键：ctrl+←)显示(快捷键：ctrl+→);
2.新建笔记(快捷键：ctrl+n);
3.激活窗口(热键：ctrl+shfit+y);
4.隐藏窗口的截屏方式(热键：ctrl+shfit+PrintScreen);
5.同步(快捷键：F5);
6.插入待办事项(快捷键ctrl+d)
7.插入当前时间(快捷键shift+alt+d)
您可以点击菜单-设置-快捷键来查看或修改。
补充：
插入分割线（快捷键：ctrl+h）关闭当前页面（快捷键：ctrl+w）当前行成无序列表（快捷键：ctrl+L）当前行成有序列表（快捷键：ctrl+shift+L）保存（快捷键：ctrl+s）全部选择页面中的内容（ctrl+a）撤销当前操作（ctrl+z）返回撤销操作（ctrl+y）查询页面中的内容（ctrl+f） 目前就发现这么多。以后发现了再补充。有知道别的快捷键的欢迎补充。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1745b438933b30699b64cc531b85315/" rel="bookmark">
			操作系统（二）内存管理——页式与段式存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统（二）内存管理——页式与段式存储 内存管理的意义段式存储页式存储段页式管理 今天没有代码，因为我还没想明白怎么写！ 因为不知道今天的代码应该怎么写，所以决定先写一写内存分配的原理。
先忽略掉教材里面众多有关于内存管理的知识点，只简单介绍一下页式和段式存储两种内存管理方式。为之后引入保护模式和长模式进行一下铺垫。
内存管理的意义 在我个人的观念里，引入内存管理主要有一下两个原因：
随着CPU从开始的20位增加到32位再到现在的64位CPU，可以直接访问的内存从最初的只有1M增加到4G再到16EG（理论值，目前支持到128G）。为了管理如此大量的存储空间，要设计一些管理模式（算法）去管理这样基数的内存，使得内存的分配有程序可寻。现代程序对内存的需求逐渐加大，加之分时系统的内存中可能会有大量程序正在运行，如何合理给每个程序分配内存才能将计算机各部件的利用率提高成为了一个需要深入研究的问题。 孙子曰：凡治众如治寡，分数是也。
总而言之，内存管理就是通过设计一种合理的数据结构，来进行内存的管理，以降低系统的复杂度，并提高系统的效率。
今天暂且只介绍页式存储和段式存储。
段式存储 段式存储是为了解决以上两种问题所提出的一种算法。段式存储将内存分割为若干长度不同或相同的数据段；要求每个段内的内存连续，段间地址不必连续。
在学习的过程中发现，有两种分段机制，一种是在操作系统进行加载时的对内存进行的分段，另一种是用户进程中按自然段进行分段。具体还需要在以后学习中查阅资料理解。
每个段的描述信息，包括段基址、段长等信息将以下图的形式进行组成，形成一个段表项，由多个段表项组成组成一张段表，存储在内存中。
在对内存进行分段之后，需要通过以下的方式来访问内存地址。
31 … 1615 … 0段号S段内偏移量W 程序在访问内存地址时，分别给出段号S和段内偏移量W，再根据段号S查找段表获得段基址，然后计算得到要访问的实际地址。
页式存储 在这里仅提及基础页式存储的原理，并不涉及有关虚拟内存的内容。
和段式存储不同，页式存储的每个页面的大小是固定的。因此当给进程分配内存时，若有进程内存不足一页时，将分配一整页。分页存储的逻辑地址结构如下：
31 … 1615 … 0页号P段内偏移量W 和段式存储的逻辑地址结构基本相同。因此，也同样需要引入一张页表进行地址的映射。由于每一页的长度L固定，所以可以根据逻辑地址A计算得到页号P和段内偏移量W。
P = A / L P = A / L P=A/L
W = A m o d &amp;ThinSpace;&amp;ThinSpace; L W = A \mod L W=AmodL
再根据P查找页表，获得页的起始地址F，即可以求得实际地址。
随着页表项的增加，为了提高查找速度，以及降低内存占用，可以引入多级页表，在此不再深入，有兴趣可以自行查阅教材。
需要注意的是，在页式存储中，每个进程都有自己的页表。
尽管页式存储和段式存储原理上相近，但是这两种存储方式有一些差异：
一般来说页式存储的每个基本单元（页）的大小要小于段式存储中的段。页式存储在分配内存时可能会产生内部碎片，而段式不会。还有好多。。。 段页式管理 在页式和段式存储方式出现以后，又有牛人将其进行了结合，形成了段页式管理方式。目前还用不到，所以懒得写了，可以自行查阅教材。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/999f17a72fdf4ca3aa0fc887c2a42595/" rel="bookmark">
			分布式消息中间件Kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以下为网易云课堂微专业Java高级开发的笔记以及自己的体会。
消息中间件的本质：一种具备接受请求、保存数据、发送数据等功能的网络应用。
5大核心组成：协议、持久化机制、消息分发机制、高可用设计、高可靠设计。 举例：RocketMQ 支持的Openmessaging协议：解析快，有事务设计、持久化设计
Kafka协议：结构简单、解析快、无事务设计、有持久化设计
Kafka 顺序读取数据到磁盘，效率比较好。可以动态扩容。
Kafka集群依赖于zookeeper来保证系统可用性，为集群保存一些meta信息。
Kafka核心API
对于每个topic，kafka集群都会维护一个分区日志。
consumer的读取partition的offset在1.x之前的版本存放在zookeeper，但是zookeeper的写操作性能很差，2.X版本之后offset的信息存放在consumer中，谁用谁存储。zookeeper仅仅存放该consumer最后一次的offset，减轻了zookeeper的压力。
Kafka核心概念 partition topic-partition-message三层结构来表示消息。每个分区有一个leader，0或多个follower。
leader处理此分区的所有读写请求，follower被动的复制数据【虽然被动复制数据，但是consumer可以主动从副本上pull到数据，减轻了从leader的读取压力 98:00】。
producer 生产者往某个topic上发布消息，也负责选择发不到topic上哪个partition【1. 从分区列表轮流选择分区； 2. 按照权重选择分区】。由开发者负责如何选择分区的算法。
consumer 消费者使用消费组名称来进行标识，topic中的每条记录仅仅只能被同一个消费组中的一个消费者实例消费，但可以同时被不同消费组中的实例消费。
新版本中只有producer不依赖于zookeeper，而topic和consumer都是依赖于zookeeper。
zookeeper实用场景（通过临时顺序节点可以实现分布式锁）
KafkaAPI 需要说明的是，旧版的Consumer分为高阶和低阶，高阶的入口类是ConsumerConnector，这种方式屏蔽了底层具体获取数据、设置、更新offset的过程，无法按照自己的业务场景选择处理方式。低阶的入口类是SimpleConsumer，可以自行给定分区、偏移量等属性。
高阶ConsumerAPI具体参考：https://www.cnblogs.com/liuming1992/p/6432626.html
低阶ConsumerAPI具体参考：http://www.cnblogs.com/liuming1992/p/6432506.html
新版本的API 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/417e8bd1a93454e4ca3e2c8ed65591f9/" rel="bookmark">
			[转]扎克伯格做了26张PPT，员工效率提10倍，已被疯狂传阅！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、时间常有，时间在于优先。
2、时间总会有的：每天只计划 4～5 小时真正的工作。
3、当你在状态时，就多干点；不然就好好休息：有时候会连着几天不是工作状态，有时在工作状态时却又能天天忙活 12 小时，这都很正常的。
4、重视你的时间，并使其值得重视：你的时间值 1000 美元/小时，你得动起来。
5、不要多任务，这只会消耗注意力；保持专注，一心一用。
6、养成工作习惯，并持之以恒，你的身体会适应的。
7、在有限的时间内，我们总是非常专注并且有效率。
8、进入工作状态的最佳方式就是工作，从小任务开始做起，让工作运转起来。
9、迭代工作，期待完美收工会令人窒息：“做完事情，要胜于完美收工” Facebook 办公室墙壁上贴的箴言。动手做，胜过任何完美的想象。
10、工作时间越长，并不等于效率越高。
11、按重要性工作，提高效率。
12、有会议就尽早安排，用于准备会议的时间往往都浪费掉了。
13、把会议和沟通 (邮件或电话) 结合，创造不间断工作时间：一个小会，也会毁了一个下午，因为它会把下午撕成两个较小的时间段，以至于啥也干不成。
PS：当看到一个程序员冥思苦想时，不要过去打扰，甚至一句问候都是多余的。
14、一整天保持相同的工作环境。在项目/客户之间切换，会效率低。
15、工作—放松—工作=高效(番茄工作法)
番茄工作法是弗朗西斯科·西里洛于1992年创立的一种相对于GTD更微观的时间管理方法。
使用番茄工作法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后在纸上画一个X短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。
16、把不切实际的任务分割成合理的小任务，只要每天都完成小任务，你就会越来越接近那个大目标了。
17、从来没有两个任务会有相同的优先级，总会有个更重要，仔细考虑待办事情列表。
18、必须清楚白天必须完成的那件事，是什么。“Only ever work on the thing that will have the biggest impact” 只去做那件有着最大影响的事情。—— Jason Cohen
19、把任务按时间分段，就能感觉它快被搞定了。
20、授权并擅用他人的力量。——君子善假于物(人)也，如果某件事其他人也可以做到八成，那就给他做！
21、把昨天翻过去，只考虑今天和明天。昨天的全垒打赢不了今天的比赛。——好汉不提当年勇。
22、给所有事情都设定一个期限。不要让工作无期限地进行下去。
23、针对时间紧或有压力的任务，设置结束时间，万事皆可终结
24、多记，多做笔记
25、进入高效状态后，记下任何分散你注意力的东西比如Google搜索词、灵光乍现的想法、新点子等等。如果你把它们记下来，它就不会再蹦来蹦去了。
26、休息，休息一下～
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e21b9b17d0ce662249d9ac29e7e72ca2/" rel="bookmark">
			Aria-ng中Aria2出现的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：
1.树莓派
2.aria2 1.15.1（使用sudo apt install -y aria2 直接安装）
3.aria-ng 0.4.0
http请求方式需要根据aria2的版本来选择，如果版本低于1.15.2使用post模式将会导致未连接
不知道什么原因树莓派开机自动启动的服务无法连接到aria2
必须重新启动服务
sudo systemctl restart aria
无法下载的情况有可能是存储的文件路径不正确
需要在配置文件里修改dir
dir=正确的路径
安装时参考文章
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b0038c95935df488f651e1e671a7082/" rel="bookmark">
			微信指纹支付原理浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 微信指纹支付从设备出厂到完成支付大致可以分成4个步骤、3对公私钥：
1.设备出厂公私钥及tee适配 手机厂商在手机tee的RPMB区域内置私钥A_priv及微信支付的特定ta和SoterKeyStore，然后厂商统一将该设备信息和设备公钥A_pub存储在腾讯服务器（校验设备签名时需要向腾讯服务器发起请求）。
2.生成应用公私钥 某app想在mobile上使用微信支付，则使用soter API向tee发出请求，tee中生成应用公私钥，私钥B_priv存储在tee中，公钥通过A_priv签名后发送给应用服务器，应用服务器向腾讯服务器发出请求校验签名，通过则存储B_pub。
3.生成业务公私钥 对于同一个设备的同一个应用可能存在多个用户（不同账号在同一设备登入），这时需要对每个用户生成独立的业务公私钥C，和第二个阶段类似，在tee中生成业务公私钥，C_priv仍然存在设备中，C_pub通过B_priv签名之后传给应用服务器。
4.使用微信指纹支付 客户端向服务器请求挑战因子challenge（实际为随机数，用于防止重放攻击），客户端在指纹识别通过后调用回调函数onAuthenticationSucceeded，然后在回调函数中将 challenge发送给tee中特定的ta进行签名（微信使用自定义的SoterKeyStore），签名之后从ta（SoterKeyStore）中返回challenge+fid+tee信息+使用C_priv签名后的签名值，发送回服务器进行校验，服务器使用C_pub验签，同时校验challenge值，都通过则表示请求合法。
这里要注意几点：
1）challenge值是用于防止重放攻击。 2）签名是在tee中执行（ta），用户态通过KeyStore向ta发出签名申请。 3）fid相当于每个指纹的hash，理论上每个指纹都不同。 4）tee中指纹认证通过与否都只会回调相关函数并在回调函数中发出签名请求，比如验证通过回调onAuthenticationSucceeded，验证不通过则回调onAuthenticationError，而回调函数在用户态，可能被任意篡改，攻击者可以将onAuthenticationError函数体篡改成onAuthenticationSucceeded函数体，然而由于只有指纹验证通过之后ta才会接受签名请求，所以即使直接篡改也无法欺骗ta签名。 5）指纹验证通过后发送challenge给tee，然后从ta中返回的数据格式如下： 5.微信指纹支付和支付宝指纹支付（ifaa）主要差别 1）手机tee中内置密钥数不同。腾讯soter框架在tee的RPMB中只内置了一个设备私钥；IFAA则需要在设备中内置设备私钥+IFAA根公钥。 2）微信的应用密钥相当于ifaa的服务端密钥，但是微信应用密钥是在设备中生成，而ifaa是直接通过ifaa认证中心给服务端颁发证书。 3）微信由于没有在手机中内置根公钥，所以每次生成应用密钥的时候需要向腾讯服务器发出请求校验签名，而ifaa通过内置根证书＋ifaa认证中心颁发服务端证书的方式完成校验。 4）腾讯soter开源，对小商户而言接入方便（无需申请服务端证书）；ifaa目前暂时没有开源。 6.总结 总而言之，不论是指纹、人脸、眼纹还是其他特征，生物授权的本质是密钥签名，只有认证通过才签名是生物授权能保证安全的根本原因。 无论使用那种指纹支付方式，都需要和设备厂商做适配（tee和应用层），微信指纹支付原理和支付宝ifaa本质上差别不大，但是对小商户而言接入成本更低；安全性上， 由于微信soter生成应用密钥时需要向微信服务端发出申请，所以存在被记录应用用户状况的风险。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8507828019859f09f21ead9c95386905/" rel="bookmark">
			这是一个博客脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		111111
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07a91a9d2898cde18614c40ca3b55bae/" rel="bookmark">
			Anaconda3安装使用教程（自己以后也方便查阅）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Anaconda是什么？ 我也不知道，自己百度吧。
2.Anaconda安装及配置 下载 ：https://www.anaconda.com/distribution/
直接去官网下载下来就好了，然后安装。安装的时候如果不改路径的话直接下一步下一步就好了。下载比较慢，我用了某雷还可以接受。
直接点击运行，然后就可以了。
在cmd命令下输入conda info看到如下图表示你已安装成功！
如果提示conda不是内容命令，说明您在安装时未勾选配置环境变量的选项。接下来手动配置系统环境变量 3.环境变量配置
将以下路径添加到系统环境变量中
D:\ProgramData\Anaconda3;
D:\ProgramData\Anaconda3\Scripts;
D:\ProgramData\Anaconda3\Library\mingw-w64\bin;
D:\ProgramData\Anaconda3\Library\usr\bin;
D:\ProgramData\Anaconda3\Library\bin;
安装装成功了，先说一下一些简单的命令吧。
3. 包管理 安装Anaconda之后，我们就可以很方便的管理安装包（安装，卸载，更新）。
1. 安装包
conda 的包管理功能和pip 是一样的，当然你选择pip 来安装包也是没问题的。
1. #安装 matplotlib 2. conda install matplotlib 2. 更新包
1. # 包更新 2. conda update matplotlib 3. 卸载包
1. # 删除包 2. conda remove matplotlib 4. 查询已经安装的包
# 查看已安装的包 conda list 4.环境管理 conda 可以为你不同的项目建立不同的运行环境。
# 基于 python3.6 创建一个名为test_py3 的环境 conda create --n test_py3 python=3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07a91a9d2898cde18614c40ca3b55bae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1af11dc6aa957f38d616aec2690a6842/" rel="bookmark">
			python接口请求post raw格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口文档中写明接口请求方式为 post raw，python代码中的请求头中Content-Type应为application/raw，请求参数data是字典格式，故在post请求中用json.dumps()将参数转换成字符串
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a604dbe7cb8f1b77911cdcb7a536127/" rel="bookmark">
			charles在mac上抓取本地python请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先打开charles,在Proxy中打开macOS Proxy，这样才能抓取本地请求
2.python代码中，post/get请求中添加verify = False忽略ssl认证，否则会报Caused by SSLError(SSLError(1, '[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:646)')错，如下
res = requests.post(url = self.url,headers = headers,data = json.dumps(data),verify = False)
参数： verify：Ture/False，默认是Ture，用于验证SSL证书开关
3.添加verify = False后仍会报如下警告
InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: 在请求语句前添加如下代码即可解决
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/414/">«</a>
	<span class="pagination__item pagination__item--current">415/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/416/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>