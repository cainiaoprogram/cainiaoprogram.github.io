<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88653ac239a2cecb8b2e1f0657c6230a/" rel="bookmark">
			SAP /usr/sap/&lt;SID&gt;目录日志文件清理 -- 转载的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SAP /usr/sap/目录下日志文件涨的很快，以下是清理方法：
stat.DAT：性能统计文件。 这个统计文件增长很快，不小心就涨到900MB以上。 对应的OS路径: D:\usr\sap\DEV\DVEBMGS00\data
处理方法: ST03N -&gt; Expert mode -&gt; Collector and Perfromance DB -&gt;Statistics
Records &amp; File -&gt; Delete File删除Delete File下的文件例如文件名是sap_DEV_00
dev_rd：gateway trace file. 对应的OS路径: D:\usr\sap\DEV\DVEBMGS00\work
处理方法: SMGW -&gt; Goto -&gt; Trace -&gt; Gateway -&gt; Reset file
dev_rfc：RFC trace file 对应的OS路径:D:\usr\sap\DEV\DVEBMGS00\work
处理方法: SM59 -&gt; RFC -&gt; Delete Trace
dev_w(n)：Work Proccess 对应的文件(处理这种情况慎重) 对应的OS路径:D:\usr\sap\DEV\DVEBMGS00\work
处理方法: SM50 -&gt; Process -&gt; Trace -&gt; Reset files
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f56d57cdbf01ee9c4f252265b1d7a63/" rel="bookmark">
			Android源码解析--DiskStatsService(存储管理)服务详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DiskStatsService和DeviceStorageMonitorService两个服务都和系统内部存储管理、监控有关。
这里先讲DiskStatsService
DiskStatsService DiskStatsService很简单，代码只有100行左右，它直接继承自Binder，却没有实现Binder的任何接口：
/** * This service exists only as a "dumpsys" target which reports * statistics about the status of the disk. */ public class DiskStatsService extends Binder { 根据源码注释，这个Service只是在执行 dumpsys命令时输出存储设备的使用情况。
说到dumpsys命令，这是系统中一个很重要的命令，主要用于打印系统中指定服务， 它是用C++写的，在dumpsys.cpp文件中，我们看一下它的main方法：
int main(int argc, char* const argv[]) { //先得到与ServiceManager通信的 BpServiceManager sp&lt;IServiceManager&gt; sm = defaultServiceManager(); ... Vector&lt;String16&gt; services; Vector&lt;String16&gt; args; bool showListOnly = false; if ((argc == 2) &amp;&amp; (strcmp(argv[1], "-l") == 0)) { showListOnly = true; } if ((argc == 1) || showListOnly) { //如果参数只有一个，或者参数里写了 -l, 就查询在ServiceManager中注册的所有Service services = sm-&gt;listServices(); services.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f56d57cdbf01ee9c4f252265b1d7a63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27b0ac03523f2b7131885c49b36b6f8a/" rel="bookmark">
			sed往指定位置插入变量的小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sed中的常用往后插入的语法，比如往匹配到的行后面添加内容，可以使用-i参数和a参数来往后插入
[root@linux ~#] sed -i '/Pattern/ a\String' FileName 如果要插入的是个变量，则需要将注意两点:
使用双引号来替代单引号使用反斜杠对\进行转译 下面就是个示例。示例文件: 1.txt，要往第四行后面添加字符串var="New Line Here."
This is line 1. This is line 2. This is line 3. This is line 4. This is line 5. This is line 6. 就可以这样做:
[root@linux ~#] var="New Line Here." [root@linux ~#] sed -i "/This is line 4/ a\\$var" 1.txt This is line 1. This is line 2. This is line 3. This is line 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27b0ac03523f2b7131885c49b36b6f8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd896c3c97c641e42b65095df0b4443e/" rel="bookmark">
			岛屿的个数-Java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题干 给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。
示例 1:
输入: 11110 11010 11000 00000 输出: 1 示例 2:
输入: 11000 11000 00100 00011 输出: 3 //BFS,使用队列的非递归广度优先搜索 private int m, n; private int stepArr[][] = {{0,1},{1,0},{0,-1},{-1,0}}; public int numIslands(char[][] grid) { if(null == grid || grid.length == 0 || grid[0].length == 0) return 0; m = grid.length;//行 n = grid[0].length;//列 int count = 0; for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j] == '1') //遍历、后BFS，BFS一次计数+1 { bfs(grid, i, j); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd896c3c97c641e42b65095df0b4443e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9036ae4b2192b24b484d173845559f3d/" rel="bookmark">
			STM8  bootloader（boot和app皆可使用中断）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM8 In Application Programming IAP编写的三个要点：
分析STM8启动过程和C运行时环境建立规划bootloader和application以及各自向量表在内存中的分布如何重定位STM8中断向量表 思路： 要编写IAP程序首先需要解决的问题是程序在运行过程中，当发生异常时，如何保证程序正常的跳转到相应的异常服务函数（不论程序是运行在bootloader还是application）。
但STM8没有类似NVIC之类的中断控制器管理中断向量的地址，STM8的向量表固定在0x008000，因此在IAP中需要重定位向量表来实现（为了bootLoader和application都可以使用中断，因此，选择将向量表重定位到RAM中）
规划内存分布 针对于STM8L052C6（2K RAM/32K FLASH）
FLASH分布
0x8000bootloader_startbootloader0xBFFFbootloader_end0xC000app_startapp0xFFFFapp_end 在0x8000开始的前128个字节，放置着bootloader重定位过的向量表（bootloader的真正的向量表放置在另外的地方）
在0xC000开始的前128个字节，放置着application的向量表
RAM分布
0x0000reload_vector0x0080.data/.bss/.textrw0x07FF 在0x000000开始的128个字节，放置着真正的向量表。（因此，不论在bootloader还是application都要在编译阶段告知链接器保留0x00~0x80这段内存空间）
利用RAM的特性(rwx)，当bootloader运行时，放置bootloader的向量表，当application运行时，放置application的向量表。
详细的分布规则，请参考config目录下的lnkstm8l052c6.icf文件
链接脚本语法请参考IARforSTM8/stm8/doc目录下的EWSTM8_DevelopmentGuide.pdf文件
重定位STM8中断向量表 由于STM8的向量表固定在0x008000~0x008080的位置，想要实现重定位向量表，则必须在固定的向量表中填入真正的向量表地址，方法如下：（参考src目录下的stm8l15x_interrupt.s文件）
/* * The interrupt vector table. */ SECTION `.intvec`:CONST define_vector MACRO DC8 0x82 DC24 _interrupt_\1 ENDM PUBLIC __intvec EXTERN __iar_program_start __intvec: DC8 0x82 DC24 __iar_program_start ;; RESET 0x8000 DC8 0x82 DC24 0x0004 DC8 0x82 DC24 0x0008 DC8 0x82 DC24 0x000C DC8 0x82 DC24 0x0010 DC8 0x82 DC24 0x0014 DC8 0x82 DC24 0x0018 DC8 0x82 DC24 0x001C DC8 0x82 DC24 0x0020 DC8 0x82 DC24 0x0024 DC8 0x82 DC24 0x0028 DC8 0x82 DC24 0x002C DC8 0x82 DC24 0x0030 DC8 0x82 DC24 0x0034 DC8 0x82 DC24 0x0038 DC8 0x82 DC24 0x003C DC8 0x82 DC24 0x0040 DC8 0x82 DC24 0x0044 DC8 0x82 DC24 0x0048 DC8 0x82 DC24 0x004C DC8 0x82 DC24 0x0050 DC8 0x82 DC24 0x0054 DC8 0x82 DC24 0x0058 DC8 0x82 DC24 0x005C DC8 0x82 DC24 0x0060 DC8 0x82 DC24 0x0064 DC8 0x82 DC24 0x0068 DC8 0x82 DC24 0x006C DC8 0x82 DC24 0x0070 DC8 0x82 DC24 0x0074 DC8 0x82 DC24 0x0078 DC8 0x82 DC24 0x007C 汇编语法请参考IARforSTM8/stm8/doc目录下的EWSTM8_AssemblerReference.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9036ae4b2192b24b484d173845559f3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af3ca36da0859be90fdf6a1b6c1d314f/" rel="bookmark">
			外部访问docker容器(docker run -p/-P 指令)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P（大写） 或 -p （小写） 参数来指定端口映射。
（1）当使用 -P 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。
使用 docker ps 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。
$ sudo docker run -d -P training/webapp python app.py $ sudo docker ps -l CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bc533791f3f5 training/webapp:latest python app.py 5 seconds ago Up 2 seconds 0.0.0.0:49155-&gt;5000/tcp nostalgic_morse 同样的，可以通过 docker logs 命令来查看应用的信息。
$ sudo docker logs -f nostalgic_morse * Running on http://0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af3ca36da0859be90fdf6a1b6c1d314f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/275de550f6eb3b8752afd130b894757c/" rel="bookmark">
			查找SAP表空间占用空间最大的几张表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查SAP系统表空间里最大几张表，我们一般用DB02–&gt; Space --&gt;Segments --&gt; Overview，点击Top Size菜单查看，但是并没有看到这个表空间里真实的最大几张表。只好用查SQL的方法去看。
SQL&gt; select * from (select segment_name, bytes/1024/1024 from dba_segments where tablespace_name=‘PSAPSR3’ order by bytes desc) where rownum &lt;= 5;
查看lob对应的表：
select table_name,column_name,segment_name,index_name from user_lobs where segment_name = ‘lob的名字’;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1504859ceff429c6f31d0234265bea2/" rel="bookmark">
			嵌入式行业公司及所属产业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手机供应链
1、手机主控芯片厂家：
高通，MTK，展讯，华为海思，苹果，三星，Intel，Marvell等等
2、OEM/ODM方案公司：
A：阿龙
B：波导(MTK)，比亚迪，邦华，邦旭，贝龙，博瑞世纪，倍易通(MTK)，宝捷讯(MTK)
C：创翔
D：东方拓宇(高通)，鼎智(MTK)，鼎维尔(MTK)，鼎为(MTK)，鼎勤，德晨，德戎，德晟，多美达
F：沸石
G：国速科技，国乾，国通世纪(MTK/展讯)，高创捷
H：辉烨(高通)，豪成(高通/MTK)，海派(宇龙)(MTK)，华勤(MTK)，鸿宇(MTK)，华录，华立德(MTK)，海信移动(高通)，海莱威，华粤世通(MTK)
J：金科龙(MTK)，金淼，金百锐，经纬，极简时代，甲金，巨盛
K：酷赛，康永(展讯)，匡盛
L：龙旗(高通/MTK)，朗易通(MTK)
M：摩天时代，明唐
N：宁波万豪
O：欧博信，欧孚
Q：祈锦通信
R：锐嘉科(MTK)
S：赛博宇华(高通)，世誉信达，三木通讯(MTK/展讯)
T：同洲(高通)，天珑(高通)，天奕达(MTK/展讯)，TCL-机甲(MTK)，泰达讯
W：沃特沃德(高通)，闻泰(高通)，闻尚(MTK)，无线开锋，纬创，伟创力
X：希姆通，兴格(MTK)，新翔通讯，信云无线，讯锐
Y：宇龙，优思，友利通，易希拓克，亚创达，易丰展业，易景，与德
Z：中芯优电，中科创达，致远控股，中信泰合
3、手机代工厂：
英华达（小米开始工厂）、卓翼（联想手机、平板）、比亚迪、伟创力、和硕、鸿海（富士康）、纬创、仁宝、华宝、广达、正崴、普诚华、致伸、华勤、闻泰、维沃、欧珀、酷派、金立、因塔斯、裕元华阳、凯赫威、劲胜、捷荣、格林、奥尔、赛龙、旺鑫精密平湖分公司、和立信、德赛、中诺、益光、海派等等。
平板供应链
1、平板主控芯片厂家：
瑞芯微，全志，晶晨，MTK，炬力，Via威盛，中星微，盈方微，君正，苹果，三星，Intel，Telechips，Marvell，TI，飞思卡尔，NVIDIA英伟达等等。
2、OEM/ODM方案公司：
A：阿龙，艾诺，爱健，安科讯，奥谷奇，爱培科，艾普，爱可欧，微步
B：比亚迪，宝龙达，百能达，秉祥
C：创盈芯，创智成，辰星通，彩虹(佛山)
D：鼎智，鼎汉创新，德与方，德凯胜，德天
F：发掘，富士莱
G：广和通，国荣，国威，国邦兴业
H：华瑞安，汉普，华旭昌，海克莱特，慧为，海纳天亨，华勤，海棠通信，恒必达，恒晨，惠科
J：机甲，嘉利信息，佳音时代，京华，江门三连，金锐显，景翰光电，今视通，金研微，金百盛，吉兆，金泰一，极泰德
K：酷比魔方
L：蓝岸通讯，力瑞，蓝晨，蓝魔
M：美好未来，美迪飞
N：南巨
P：品网，普方达，普耐尔
Q：七彩虹
R：瑞谷电子，瑞联
S：三木通信，索智，赛维天创，实义德，硕颖，深创(昱科)
T：天智伟业，天和致远，天启，同创辉，拓步
W：未来华文(君越)，文晟(誉丞，炬力旗下)，微步，炜疆，五元素，五洋洲
X：星王，芯威创展，芯派德，芯舞，芯图，芯毕耐，信太科技
Y：易连汇通，易方，益光，友坚恒天，亿道，亿东，英众科技，英卡，英特圣，永思高科，亚忆，亿博达，英杰
Z：智联，泽迪(瑞芯微旗下)，众芯智汇，中科创达，中科长城，组创微
机顶盒供应链
1、数字机顶盒产业链
①主控芯片厂家：
ST、博通、NXP、NEC、海思、富士通、晶晨、Sigma Designs、芯晟(CSM)、晨星(Mstar)、国芯、LSI、赛普拉斯、ALi等。
②数字机顶盒厂商及其运营商：
华为，创维，深圳九洲，长虹，银河，同洲，兆驰，帕诺迪电器，华曦达，神州电子，高斯贝尔，金亚太，九联，天诚，迈科，新大陆，爱迪欧，大旗，汇星，奥视通，博尚，天地星，凯利华，卓异，杰科，视维，高视佳，海信，康佳，大连大显，速浪，浪潮，泰信，金网通，极众电子，四达时代，金亚，长江电讯，数电，胜天工，东方广视，中大电器，英集电子，艾尔数字，耀锦，广茂，纽格力(NEW GLEE)，佳彩，赛科世纪，红线，富兰电子，SINKNA，佩斯，同辉，泰辉，博远伟业等等。
2、OTT机顶盒(网络播放器)产业链：
①主控芯片厂家：
晶晨、瑞芯微、全志、海思、炬力、晨星、瑞昱、MTK、Intel、美满等，现在主流的就是晶晨、瑞芯微、全志、海思等这几家了。
②OTT机顶盒(网络播放器)厂商及其运营商：
海美迪，泰捷，创维，阿里巴巴，乐视，小米，百度电视云，开博尔，创盈芯，赛威尔电子，英菲克，天敏，视壮，中网鑫，中维畅想，桔豆，碧维视，迈乐，优酷，金亚太，杰科，泰信，海信，忆典，迪优美特，亿格瑞，特纳，华曦达，华广，第五元素，蓝晨，高清视通，莱檬，腾上，武汉精伦，迈科，金亚，深圳九洲，浪潮，康佳，高斯贝尔，汇星数字，凯利华，卓异，视维，艾尔，纽格力（NEW GLEE），赛科世纪，中大电器，银河，视源，昕创(高创)，飞越数字(兆驰)，力合高，航天数字，欣广视，艾尚科，新科，同洲，纬信，泰霖，鑫华恒，仙苗，聚力传媒，煜丰达，嘉音美尔，卓丰太，创思奇，优莱客，晶凌达，同方多媒体，玥芯通，微星视道，烽视威，国宏邦，小技，赛梅斯凯，天猫智业，橙
视，维嘉企业，和天创科技，中兴九城，美纳途，七威，酷派（神盒），声物科技，乐橙，晶凌，狮威，UT斯达康，智我（ZIVOO），晨芯，盈卓等等。
安防
零部件芯片：海思、TI、中星微、视频算法提供商Object Video等；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1504859ceff429c6f31d0234265bea2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25e6764e1c6f64dbbfd3c90e13874d86/" rel="bookmark">
			python环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python环境搭建 准备工具如下： 下载 python【python 开发环境】
http://python.org/getit/
下载 setuptools 【python 的基础包工具】
http://pypi.python.org/pypi/setuptools
下载 pip 【python 的安装包管理工具】
https://pypi.python.org/pypi/pip
想使用 python 语言开发，首先需要 python 开发环境，需要说明的是 python 目前最新版本分：2.7.x和3.3.x（简称 python 2 和 python 3）；python 3 并非完全的向下兼容 python 2 ，语法上也有较大的差异。python 3在性能上更加优秀，但由于 python 2多年的发展，大量的类库、框架是基于 python 2，所以，目前两个版本都在维护更新。个人推荐新手从 python 2开始学习 python，因为有丰富的资料、类库和框架给我们学习和使用。当然，随着时间的推移，python 3 才是 python 发展的未来。setuptools 是 python 的基础包工具，可以帮助我们轻松的下载，构建，安装，升级，卸载 python
的软件包。pip 是python软件包的安装和管理工具，有了这个工具，我们只需要一个命令就可以轻松的python 的任意类库。 windows 环境安装： 第一步、安装 python 的开发环境包，选择需要安装路径进行安装，笔者下载的是目前最新的
python2.7.5版本，安装目录为：C:\Python27。第二步、 安装 setuptools 通过前 面提供的 setuptools 的连接，拖动页面到底部找到，
setuptools-1.3.2.tar.gz 文件（版本随着时间版本会有更新），对文件进行解压，找到 ez_install.py
文件，进入 windows 命令提示（开始–运行–cmd 命令，回车）下执行 ez_install.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25e6764e1c6f64dbbfd3c90e13874d86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0598f0f208ba8c8e08b6d1b7bd099551/" rel="bookmark">
			iframe 跨域高度自适应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个iframe的问题，在工作中简直就是突然的一到坎，打的戳不及防。通常很久遇到一次，每次遇到就忘记了上一次是如何解决的，emmmm…今天本仙女去总结一下。
在实际应用中，很多时候通iframe引入页面，如果同域情况，可以使用以下代码。
script:
window.function(){
var ifm= document.getElementById(“iframepage”);
var subWeb = document.frames ? document.frames[“iframepage”].document:ifm.contentDocument;
if(ifm != null &amp;&amp; subWeb != null){
ifm.height = subWeb.body.scrollHeight;
}
}
body:
&lt;iframe src=“iframe.html” id=“iframepage” name=“iframepage” width=“100%”&gt;
但是引进来的页面，往往是跨域的，上述代码就会报错，因为跨域的安全性问题。
所以，我们就要找个“中介”来帮助我们。
比如在域A中有一个页面a.html，我们要引入域C中的页面c.html，这样我们可以在域A中再建立一个“中介”页面b.html,作为c.html的子页面，然后获取一些相关信息，最后通过b.html来实现设置a.html中iframe高度的效果，因为b和a是在同域下的，所以不存在安全障碍。
c.html中的代码如下:（不知道为啥标签一写就出不来代码，请手动补全标签哦）
&lt;iframe id=“b_id” width=“100%” src=“http://域A/b.html” style=“display:none”&gt; &lt;script type=“text/javascript”&gt;
var c_height=Math.max(document.body.scrollHeight,document.body.clientHeight);
var b_iframe = document.getElementById(“b_id”);
b_iframe.src = b_frame.src+"#"+b_height;
通过url，为"中介"页面b.html传递了c.html的高度信息，这个高度就是a.html中iframe的自适应高度。
b.html中的代码如下:
JavaScript：
//得到a.html中的a_iframe
var a_iframe=parent.parent.document.getElementById(“a_iframe”);
var hash_url = window.location.hash;
//得到传递过来的height属性
var hash_height = hash_url.split("#")[1]+“px”;
//调整a_iframe的height，达到自适应
a_iframe.height = hash_height;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0598f0f208ba8c8e08b6d1b7bd099551/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e77e3930ba3006a0f758fad9ea3c881/" rel="bookmark">
			nginx反向代理到Https后，请求Http资源报错blocked mixed-content
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法： &lt;link rel="stylesheet" href="http://cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"&gt;
比如这里我用了bootcss的cdn,但是正常情况下这样写是会报blocked mixed-content错误的。
解决方法：
&lt;link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"&gt;
这样的话浏览器就会根据你域名的请求来识别，比如https下他会自动请求https的资源，而http时，请求http的资源。
但是有可能他并不存在https的资源，但是我又想在Https下用这个cdn怎么办呢?
第二种方法： 加&lt;meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"&gt;
这样他会在请求Http资源的时候先将他转成Https再请求。
第三种方法： 可以在nginx里面解决 在nginx可通过在server添加
#解决https请求http资源不可用的情况
add_header Content-Security-Policy upgrade-insecure-requests;
解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a7b19757f79d88bdc0688dfe7cc3973/" rel="bookmark">
			Spring boot 2项目部署到Windows系统tomcat中遇到中文乱码问题（都是问号？）解决记录...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发环境： macOS Mojave 10.14.4; java 1.8; IDEA 2019.1； tomcat 8.5; mysql 5.7. 复制代码 开发框架 spring boot2 mybatis 复制代码 统一编码 UTF-8 复制代码 场景描述 开发一个接收数据的接口，用于接收数据并插入到数据库。 请求方式POST请求，Content-Type：application/json 复制代码 接口示例 @PostMapping(value = "/**/**") public Result saveData(@RequestBody String body){ return null; } 复制代码 问题描述 在开发环境（macOS）下，使用postman调试接口，一切正常； 发布到测试环境（Windows）下到tomcat，使用postman发送数据，发现接收到的数据（body）中文乱码，中文字符有些正常有些乱码变为问号“？”。 复制代码 无效解决方案 1、修改tomcat server.xml，在&lt;connector&gt;标签中添加```URIEncoding="UTF-8"```，无效; 2、在postman请求头参数中添加Accept-Charset：UTF-8，无效； 复制代码 解决方案： 在tomcat的catalina.bat文件中set JAVA_OPTS=%JAVA_OPTS% %LOGGING_CONFIG%的后面加上 -Dfile.encoding="UTF-8" 复制代码 [www.seaxiang.com/blog/java_p…](参考连接设置-Dfile.encoding 解决 java项目乱码问题)
转载于:https://juejin.im/post/5c9c910b5188251d7d02660e
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b7d82109c3b16e351ff11cfa085f7aa/" rel="bookmark">
			Tensorflow下使用SSD训练自己的数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tensorflow下使用SSD训练自己的数据集 1、数据集格式转换。
① 将自己的数据集做成VOC2007格式，直接将VOC2007文件夹粘贴到SSD-Tensorflow-master目录下。
② 修改datasets文件夹中pascalvoc_common.py文件中的训练类。
#原始的 # VOC_LABELS = { # 'none': (0, 'Background'), # 'aeroplane': (1, 'Vehicle'), # 'bicycle': (2, 'Vehicle'), # 'bird': (3, 'Animal'), # 'boat': (4, 'Vehicle'), # 'bottle': (5, 'Indoor'), # 'bus': (6, 'Vehicle'), # 'car': (7, 'Vehicle'), # 'cat': (8, 'Animal'), # 'chair': (9, 'Indoor'), # 'cow': (10, 'Animal'), # 'diningtable': (11, 'Indoor'), # 'dog': (12, 'Animal'), # 'horse': (13, 'Animal'), # 'motorbike': (14, 'Vehicle'), # 'person': (15, 'Person'), # 'pottedplant': (16, 'Indoor'), # 'sheep': (17, 'Animal'), # 'sofa': (18, 'Indoor'), # 'train': (19, 'Vehicle'), # 'tvmonitor': (20, 'Indoor'), # } #修改后的 VOC_LABELS = { 'none': (0, 'Background'), 'gun': (1, 'gun'), 'knife': (2, 'knife'), } ③ 修改datasets文件夹中的pascalvoc_to_tfrecords.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b7d82109c3b16e351ff11cfa085f7aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/573e20c8f260171281b7a42df10725f3/" rel="bookmark">
			一文看懂YOLO v2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 新的YOLO版本论文全名叫“YOLO9000: Better, Faster, Stronger”，相较于YOLO主要有两个大方面的改进：
第一，作者使用了一系列的方法对原来的YOLO多目标检测框架进行了改进，在保持原有速度的优势之下，精度上得以提升。
第二，作者提出了一种目标分类与检测的联合训练方法，通过这种方法，YOLO9000可以同时在COCO和ImageNet数据集中进行训练，训练后的模型可以实现多达9000种物体的实时检测。
我们根据论文中Better，Faster，Stronger三个方面来阐述YOLOv2的算法细节，其中会提到YOLO一些算法YOLO讲解。
Better Batch Normalization
神经网络学习过程本质就是为了学习数据分布,一旦训练数据与测试数据的分布不同,那么网络的泛化能力也大大降低;另外一方面，一旦每批训练数据的分布各不相同(batch 梯度下降),那么网络就要在每次迭代都去学习适应不同的分布,这样将会大大降低网络的训练速度。
解决办法之一是对数据都要做一个归一化预处理。YOLOv2网络通过在每一个卷积层后添加batch normalization，极大的改善了收敛速度同时减少了对其它regularization方法的依赖（舍弃了dropout优化后依然没有过拟合），使得mAP获得了2%的提升。
先建立这样一个观点： 对数据进行预处理（统一格式、均衡化、去噪等）能够大大提高训练速度，提升训练效果。批量规范化 正是基于这个假设的实践，对每一层输入的数据进行加工。示意图：
BN 的做法是 在卷积池化之后，激活函数之前，对每个数据输出进行规范化（均值为 0，方差为 1）。
公式很简单，第一部分是 Batch内数据归一化（其中 E为Batch均值，Var为方差），Batch数据近似代表了整体训练数据。
第二部分是亮点，即引入 附加参数 γ 和 β（Scale &amp; Shift），Why？ 因为简单的归一化 相当于只使用了激活函数中近似线性的部分（如下图红色虚线），破坏了原始数据的特征分布，这会降低模型表达能力。
High Resolution Classifier
预训练分类模型采用了更高分辨率的图片
YOLOv1先在ImageNet（224x224）分类数据集上预训练模型的主体部分（大部分目标检测算法），获得较好的分类效果，然后再训练网络的时候将网络的输入从224x224增加为448x448。但是直接切换分辨率，检测模型可能难以快速适应高分辨率。所以YOLOv2增加了在ImageNet数据集上使用448x448的输入来finetune分类网络这一中间过程（10 epochs），这可以使得模型在检测数据集上finetune之前已经适用高分辨率输入。使用高分辨率分类器后，YOLOv2的mAP提升了约4%。
Convolutional With Anchor Boxes
YOLOv1是利用全连接层直接预测bounding box的坐标。
YOLOv2则借鉴了Faster R-CNN的思想，引入anchor。
YOLOv2移除了YOLOv1中的全连接层而采用了卷积和anchor boxes来预测边界框。为了使检测所用的特征图分辨率更高，移除其中的一个pool层。在检测模型中，YOLOv2不是采418×418图片作为输入，而是采用416×416大小。因为YOLOv2模型下采样的总步长为32,对于416×416大小的图片，最终得到的特征图大小为13×13，维度是奇数，这样特征图恰好只有一个中心位置。对于一些大物体，它们中心点往往落入图片中心位置，此时使用特征图的一个中心点去预测这些物体的边界框相对容易些。所以在YOLOv2设计中要保证最终的特征图有奇数个位置。
YOLOv2中引入anchor boxes，输出feature map大小为13×13，每个cell有5个anchor box预测得到5个bounding box，一共有13×13×5=845个box。增加box数量是为了提高目标的定位准确率。
Dimension Clusters（维度聚类）
为了方便理解我们先讲解一下k-means。
K-Means算法的思想很简单，对于给定的样本集，按照样本之间的距离大小，将样本集划分为K个簇。让簇内的点尽量紧密的连在一起，而让簇间的距离尽量的大。如果用数据表达式表示，假设簇划分为(C1,C2,…Ck)，则我们的目标是最小化平方误差E：
其中μi是簇Ci的均值向量，有时也称为质心，表达式为：
K-Means采用的启发式方式很简单，用下面一组图就可以形象的描述。
了解了K-means，我们再来看看YOLOv2中的Dimension Clusters。
k-means需要有数据，中心点个数是需要人为指定的，位置可以随机初始化，但是还需要度量到聚类中心的距离。这里怎么度量这个距离是很关键的。
距离度量如果使用标准的欧氏距离，大盒子会比小盒子产生更多的错误。例(100-95)^2=25, (5-2.5)^2=6.25。因此这里使用其他的距离度量公式。聚类的目的是anchor boxes和临近的ground truth有更大的IOU值，这和anchor box的尺寸没有直接关系。自定义的距离度量公式：d(box,centroid)=1-IOU(box,centroid)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/573e20c8f260171281b7a42df10725f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d795af4ebb6f3a2a04004784f6e74d97/" rel="bookmark">
			闭包的快速了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想着重新跳槽，偶尔想起用过太多的闭包，却一下子组织不起来语句去描述它。
今天在这好好谈谈闭包。
先上代码：
function A(){ //定义普通函数 A
function B(){ // 在 A 中定义普通函数 B
console.log(‘Hello 小仙女!’);
}
return B; //在 A 中返回 B
}
var C = A(); //执行 A，并把 A 的返回结果赋值给变量 C
C();// Hello 小仙女! //执行 C
这是最简单的闭包。
总结一句话：
当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。（面试官问的话这么答也可以的）
这是对闭包最简单的理解，当然闭包还有其更深层次的理解，这个就涉及的多了，你需要了解JS的执行环境(execution context)、活动对象(activation object)以及作用域(scope)和作用域链(scope chain)的运行机制。
但通常在工作中，怎么会有这么简单的例子。。。。。。
网上搜到一个例子，直接粘贴复制：
(function (document) {
var viewport;
var obj = {
init: function(id) {
viewport = document.querySelector(’#’ + id);
},
addChild: function(child) {
viewport.appendChild(child);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d795af4ebb6f3a2a04004784f6e74d97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5bee5aafcdbf1120aca02e023f06365/" rel="bookmark">
			安卓Appium采坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Error: Unable to find an active device or emulator with OS 7.0.0. The following are available: emulator-5554 (7.0) 用adb devices 命令查看安卓真机或者模拟器的设备名称，见下图的
2. 输入汉字乱码显示 原因一：代码上的修改如图，在汉字前面加个u
原因二：安装Appium Android Input Manager for Unicode、
安卓手机系统语音默认设置为Appium Android Input Manager for Unicode；注意：华为手机系统设置了这个输入法之后，手动操作手机键盘无法调出
3. Appium 每次执行用例提示Appium Android Input Manager for Unicode 问题 按照下面的链接更改appium的android-helpers.js文件
https://www.jianshu.com/p/1878cd713106
4. 无法定位元素，安卓7.0版本会出现元素定位不到问题 原因一：在desired_caps中配置’automationName’: ‘uiautomator2’,
原因二：运行出现错误如下错误
selenium.common.exceptions.WebDriverException: Message: An unknown server-side error occurred while processing the command. Original error: Could not sign with default certificate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5bee5aafcdbf1120aca02e023f06365/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93e882e1a5d0ee7cda9c12de11d084a5/" rel="bookmark">
			Gitlab-CI  备忘录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.编译环境
将安装包拷贝到/opt目录下 ,在~/.bashrc配置环境变量
#set java environment
export JAVA_HOME=/opt/jdk1.8.0_202 export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:$PATH
#set android environment
export ANDROID_HOME=/opt/android-sdk-linux
export PATH=$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH
#set android environment
export GRADLE_HOME=/opt/gradle-4.10.1
export PATH=$GRADLE_HOME/bin:$PATH
#set NDK environment
export NDK_HOME=/opt/android-ndk-r18b
export PATH=$NDK_HOME:$PATH
#set 360jiagu environment
export JIAGU_DIR=/opt/360jiagubao_linux_64/jiagu
安装SDK 所需要32位包 sudo apt-get install -y libc6-i386 lib32stdc++6 lib32gcc1 lib32ncurses5 lib32z1
测试环境变量： java -v，ndk-build -v , gradle, adb shell .
安装Git并配置GIt SSH 公钥：
cd ~/.ssh ssh-keygen -t rsa生成ssh的公钥和私钥 ,将公钥拷贝到gitlab配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93e882e1a5d0ee7cda9c12de11d084a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8189a49981b505dadb3dc3be41d2e3b/" rel="bookmark">
			Qt Creator转VS2017(VS2019)遇到‘常量中有换行符‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案A 进入项目 -&gt; 属性-&gt;常规,将字符集设置为多字节字符集
在C/C++ =&gt; 命令行中添加
/utf-8 方案B(推荐) 发现一个现象, 在Qt Creator中怎么使用中文字符串都是没有任何问题的, 但是只要迁移到VS2019, 就会有各种中文问题, 常见的问题有两个:
常量中有换行符 (编译不通过) 参考方案A常量中文显示乱码 (不管是输出到stdout, 还是显示到界面上) 如何解决乱码 为什么会出现乱码, 大概原理就是源代码文件的编码格式必须是UTF8 no BOM, 我们需要安装一个VS扩展FixFileEncoding, 下载安装就好了, 没啥子好说的. 相关文档官方网站都有详细说明
除了这个扩展, 还是有ForceUTF8, 安装很简单就不上图了, 菜单栏-&gt;扩展-&gt;管理扩展, 在右上角搜索"Force UTF-8" 就可以找到该插件, 安装就完事了
测试发现 ForceUTF8 好像不起作用, 也没找到配置的入口.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19bfd72b67ceaa114055d0e708a9bad3/" rel="bookmark">
			javascript 算法题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组转换成树形结构
数据结构，上下级是有关联关系的
var data = [ { "node_id": "1", "parent_id": "0", "name": "1" }, { "node_id": "5", "parent_id": "1", "name": "2" }, { "node_id": "6", "parent_id": "5", "name": "3" }, { "node_id": "7", "parent_id": "5", "name": "3333" } ] 解法1:(多个循环)
data.forEach(ele =&gt; { let parentId = ele.parent_id; if (parentId === 0) { } else { data.forEach(d =&gt; { if (d.node_id === parentId) { let childArray = d.child; if (!childArray) { childArray = [] } childArray.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19bfd72b67ceaa114055d0e708a9bad3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea235f0115e31c4978f7c98a841731d3/" rel="bookmark">
			QT中connect的两种简单用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种：使用宏
这种方法较为常见：
connect(sender, SIGNAL(valueChanged(QString, QString)), receiver, SLOT(updateValue(QString))); 即使用SIGNAL() 和 SLOT()将信号与槽进行声明；
例子：
QLabel *label = new QLabel; QScrollBar *scrollBar = new QScrollBar; QObject::connect(scrollBar, SIGNAL(valueChanged(int)), label, SLOT(setNum(int))); 此示例确保标签始终显示当前滚动条值。注意，信号和插槽参数不能包含任何变量名，只能包含类型。
第二种：使用函数指针
这种方法比前一种更新，而且带语法检查，书写也更为方便。
connect(sender, PointerToMemberFunction signal, receiver, PointerToMemberFunction method)； 该信号必须是在头文件中声明为信号的函数。槽函数可以是任何可以连接到信号的成员函数。
例子：
QLabel *label = new QLabel; QLineEdit *lineEdit = new QLineEdit; QObject::connect(lineEdit, &amp;QLineEdit::textChanged, label, &amp;QLabel::setText); 本例确保标签始终显示当前行编辑文本。
一个信号可以连接到许多槽和信号。许多信号可以连接到一个插槽。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d9505e6937187ae85a7fbb5bf43c364/" rel="bookmark">
			BugFree系统部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语： 最近公司需求，需要部署一个测试case录入系统、bug记录系统，而同事推荐之前使用过的BugFree系统，这个由淘宝开发的开源系统，但已经在2013年就停止更新了，那么我们介绍下如何部署。
1.准备环境 ①、CentOS-7-x86_64-Minimal-1708系统：http://59.80.44.100/isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1810.iso
②、BugFree系统源码：https://github.com/chencjfeng/bugfree
③、yum源更新，并停止防火墙
yum install epel-release //扩展包更新包 yum update //更新yum源 systemctl stop firewalld.service //停止防火墙服务 systemctl disable firewalld.service //禁用防火墙开机启动服务 ④、下载更新mysql-server源
yum -y install wget wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm rpm -ivh mysql-community-release-el7-5.noarch.rpm 2.配置Apache环境 ①、安装Apache
yum install httpd ②、启动进程
service httpd start ③、设置httpd开机启动
chkconfig httpd on 访问服务器ip，能出现以下页面则表示安装成功，不能出现以下页面则排查下防火墙是否关闭和httpd服务是否起来
Apache
3.配置mysql环境 ①、安装mysql
yum install mysql mysql-server ②、启动进程
service mysqld start ③、配置mysql root初始密码
mysql use mysql update user set password=password('密码') where user='root' ; //此句结尾需加上分号，分号不能漏掉 ④、重启mysql服务生效
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d9505e6937187ae85a7fbb5bf43c364/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f08cf25ed60cf8b12bc06f6ca90688f/" rel="bookmark">
			用scanf函数输入数据，举例并分析错误原因  用下面的scanf函数输入数据，使a=3，b=7,x=8.5,y=71.82,c1=’A’,c2=’a’。问在键盘上如何输入。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天遇到一个小学弟开始学c语言，问了一道题。
用scanf函数输入数据，举例并分析错误原因
用下面的scanf函数输入数据，使a=3，b=7,x=8.5,y=71.82,c1=’A’,c2=’a’。问在键盘上如何输入。
#include&lt;stdio.h&gt;
int main()
{
int a, b;
float x, y;
char c1, c2;
scanf("a=%d b=%d",&amp;a,&amp;b);
scanf("%f %e",&amp;x,&amp;y);
scanf("%c%c", &amp;c1, &amp;c2);
return 0;
}
我上机运行了下：
在控制台输入了 3 7 8.5 71.82Aa
为什莫出错？？？？？？
最后看了看莫非scanf("a=%d b=%d",&amp;a,&amp;b);??????????????
百度下，
scanf("输入控制符非输入控制符", 输入参数);
这种用法几乎是不用的，也建议你们永远都不要用。但是经常有人问，为什么 printf 中可以有“非输出控制符”，而 scanf 中就不可以有“非输入控制符”。事实上不是不可以有，而是没有必要！下面来看一个程序：
# include &lt;stdio.h&gt; int main(void) { int i; scanf("i = %d", &amp;i); printf("i = %d\n", i); return 0; } 在 printf 中，所有的“非输出控制符”都要原样输出。同样，在 scanf 中，所有的“非输入控制符”都要原样输入。所以在输入的时候i=必须要原样输入。比如要从键盘给变量 i 赋值 123，那么必须要输入i=123才正确，少一个都不行，否则就是错误。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f08cf25ed60cf8b12bc06f6ca90688f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c1054e0c74cbb73676702f8a7918f15/" rel="bookmark">
			服务器安全狗 Linux 安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器安全狗 Linux 安装教程 1：使用SSH连接Linux服务器 这里我用的是SecureCRT 连接，如果Linux服务器22端口没有开放，或者连接失败，很有可能是服务器防火墙的问题或者SSH服务的问题，解决方法请自行百度。
2：安装安全狗 2.1：下载安全狗 下载时需要先查看Linux服务器的版本信息，是32位还是64位的，选择对应的版本，我这里安装的64位的，下载链接为：http://download.safedog.cn/safedog_linux64.tar.gz
●查看系统版本信息的方法：uname -a 从使用的镜像文件或x86-64（64位）/i686（32位）都可分辨
●下载命令：wget http://download.safedog.cn/safedog_linux64.tar.gz
（如果你是32位，请自行替换链接）
2.2：安装过程 2.2.1：压缩包安装
●解压刚下载的压缩包：tar -zxvf safedog_linux64.tar.gz
请先ls查看一下自己的压缩包名字，不一定一样，如果不同，上面的指令请自行替换
●ls 查看解压后的目录，cd 进入该目录，执行命令 ./install.py
●安装完成后如图，如果出现其他错误，请自行百度之
2.2.2：安全狗账号绑定
●需要先去安全狗注册自己的一个账号，用于绑定
●注册完后，执行sdcloud -u 你的安全狗服云帐号 命令进行绑定，按照提示输入密码
●绑定成功后，使用sdui命令便可调出图形化界面对安全狗进行详细的配置了
注：如果执行命令sdui，出现以下报错信息，是因为终端类型不匹配引起的。
解决方法：
●打开SecureCRT的选项
●点击会话选项
●点击仿真
●终端选择Xterm，并且勾选ANSI颜色和使用颜色方案
●断开SecureCRT的连接后，重新连接，执行sdui命令即可进行配置
如果遇到如下报错，请在终端执行下面的三条指令，并重新连接
●mkdir -p /usr/share/terminfo/x
●cd /usr/share/terminfo/x
●ln -s /lib/terminfo/x/xterm xterm
如果还有其他报错，请参照：
https://blog.csdn.net/dotphoenix/article/details/53714340
注：
你要是不爱看上面的英文界面也可以选择进入服云管理网址去操作图形界面，登陆服务器安全狗之后，这里你就可以时刻看到自己的 VPS 主机的安全情况了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/092546a905e30ddc46d9f671c26603d5/" rel="bookmark">
			python框架-Flask第三方组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. flask-sqlalchemy a. 下载安装 pip3 install flask-sqlalchemy b. init__.py 导入并实例化SQLAlchemy from flask_sqlalchemy import SQLAlchemy db = SQLAlchemy() 注意事项： - 必须在导入蓝图之前 - 必须导入models.py c. 初始化 db.init_app(app)
d. 在配置文件中写入配置 # ##### SQLALchemy配置文件 ##### SQLALCHEMY_DATABASE_URI = "mysql+pymysql://root:123456@127.0.0.1:3306/db?charset=utf8" SQLALCHEMY_POOL_SIZE = 10 SQLALCHEMY_MAX_OVERFLOW = 5 e. 创建models.py中的类（对应数据库表） models.py
from sqlalchemy.ext.declarative import declarative_base from sqlalchemy import Column from sqlalchemy import Integer,String,Text,Date,DateTime from sqlalchemy import create_engine from twiss import db class Users(db.Model): __tablename__ = 'users' id = Column(Integer, primary_key=True) name = Column(String(32), index=True, nullable=False) depart_id = Column(Integer) f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/092546a905e30ddc46d9f671c26603d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3301ed5e0876c47d5a391c8236ea74e/" rel="bookmark">
			zeroc ice : c#客户端 &#43; c&#43;&#43;服务端通信操作记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ice介绍 Ice（Internet Communications Engine）是ZeroC公司的杰作，继承了CORBA的血统，是新一代的面向对象的分布式系统中间件。Ice是RPC通讯领域里最稳定、强大、高性能、跨平台、多语言支持的老牌开源中间件，特别适合于当前互联网领域中一个平台存在多种开发语言编程，以及网站和app应用并存的复杂大型项目。
RPC（Remote Procedure Call Protocol 远程过程调用协议），是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC假定某些传输协议的存在，如TCP或UDP，为通讯程序之间携带信息数据；在OSI网络通讯模型中，RPC跨越了传输层和应用层。
Ice通过与编程语言无关的中立语言Slice（Specification Language fro Ice）来描述服务的接口，从而达到对象接口与其实现想分离的目的。
目前Ice平台支持客户端API的语言有C++、.NET、Java、Python、Object-C、Ruby、PHP、JavaScript等。在服务器可以使用C、.NET、Java、Python等来开发。
关键特性
1. 支持多语言之间的RPC互通。
2. 高性能的RPC调用。
3. 支持传统的RPC调用、异步调用、One-Way调用、批量发起请求，支持TCP通信、UDP通信等。
4. 多平台支持。
5. 不断更新，与时俱进。
通讯原理 1. 开发者通过slice定义接口规范Printer.ice。
2. 客户端和服务端分别通过对应的转换工具生成各自语言的接口。
3. 客户端和服务器分别用各自的语言根据统一的接口实现具体逻辑代码。
至于调用等底层实现由ICE帮我们完成，大大简化、节省了开发的时间。
我的安装环境: win7 ,visual studio 2015,zeroc 3.7
服务端语言：C++ 客户端语言：C#
接口（计算两整数值，服务端计算，客户端调用接口）
module AddT
{
interface Adder
{
int add(int i,int j);
}
}
ice配置 1、ICE安装（去官网下载最新版本，此次版本只有20M,之前版本将近400M，主要是把C++库文件放在其它地方了) 1、进入程序包管理器(工具-&gt;NuGet包管理器-&gt;程序包管理器控制台) 2、安装ice、ice builder、ice插件 2.1、安装ice，选择项目，输入install-package zeroc.ice.v140 -version 3.7.1 Tips：V140代表VS的版本，(V140&lt;-&gt;VS2015，V120&lt;-&gt;VS2013)，3.7.1代表ice的版本
2.2、安装ice.builder.msbuild，输入install-package zeroc.icebuilder.msbuild 2.3、 安装ice build插件 服务端 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3301ed5e0876c47d5a391c8236ea74e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6426b0fe50df644b67d1db08978a08d9/" rel="bookmark">
			树类算法之--XGBoost算法原理&amp;代码实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.算法原理介绍 1.1Xgboost简介 xgboost是Boosting算法的其中一种，Boosting算法的思想是许多弱分类器集成在一起，形成一个强分类器。以为xgboost是一种提升树模型，所以他是将许多树模型集成在一起，形成一个很强的分类器。而所用到的树模型则是cart回归树模型。
xgboost是在GBDT的基础上进行改进，使得更加强大，使用范围更大xgboost一般和sklearn一起使用，但是由于sklearn中没有集成Xgboost，所以需要单独安装在安装的时候要注意安装多线程版本 1.2.xgboost的优点 xgboost算法可以给预测模型带来能力的提升。当我们对其表现有很多了解的时候，我们会发现他们有如下优势：
1.2.1正则化 实际上，xgboost是以“正则化提升技术”而闻名。xgboost在代价函数里加入了正则化项，用于控制模型的复杂度。
正则化项里包含了：
树的叶子节点个数每个叶子节点上输出的score的L2模的平方和。从Bias-variance tradeoff角度来看，正则化项降低了模型的variance，使得学习出来的模型更加的简单，防止过拟合，这也是xgboost优于传统GBDT的一个特征 1.2.2并行处理 xgboost工具支持并行。众所周知，Boosting算法是串行结构的处理方式，也就是说按照这种顺序的处理是没有办法实现并行处理的。这里要格外的注意xgboost的并行处理，并不是并行的建树。xgboost也是一次迭代完才能进行下一次迭代的（第t次迭代的代价函数里包含）。xgboost的并行是在特征粒度，也就是说每一棵树的构造依然是依赖于前一棵树
决策树的整个建树过程，最耗时耗资源的一个步骤就是对特征值得排序（因为要确定最佳分割点），xgboost的并行处理过程如下：
1.预先对数据（特征值）进行排序。2.将排好序的结构保存为block块，在后面的迭代建树过程重复的使用这个结构，可以大大减少计算，这个block结构也使得并行成为了可能。3.进行节点分裂时，并行的计算每个特征的增益，最终选择增益最大的特征去分裂 1.2.3灵活性 xgboost支持用户自定义目标函数和评估函数，只要目标函数二阶可导就行了。它对模型增加了一个全新的维度，所以我们的处理不会受到任何限制。
1.2.4泰勒二阶展开 在工程实际问题的优化设计中，所列的目标函数往往很复杂，为了使问题简化，常常将目标函数在某点邻域展开成泰勒多项式来逼近原函数。
实际上，xgboost使用泰勒二阶展开的目的是，为了自定义Loss,如果按照最小二乘法的损失函数直接推导，同样能够得到陈大佬最终的推导式子：
二阶泰勒展开实际上不是最小二乘法，平方损失函数的二阶泰勒展开 = 最小二乘，但是陈大佬之所以使用泰勒展开，就是为了xgboost库的可扩展性，因为任何Loss函数只要二阶可导，就可以重复使用，关于最小二乘法的任何推导，而且泰勒展开的本质就是尽量去模仿一个函数，而二阶泰勒展开已经足够去近似大量的Loss函数了，最经典还有基于分类的对数似然Loss函数，这样的话，同样的一套代码就可以完成分类或回归了，而不至于每次都要重新推导一遍。
1.2.5Xgboost寻找特征 xgboost在训练过程中，给出各个特征的评分，从而表明每个特征对模型的重要性xgboost是利用梯度优化算法，样本是不放回的，如果一个样本被连续重复抽出，梯度来回踏步，不利于收敛。xgboost支持自采样，也就是说每轮计算可以不使用全部的样本。 1.2.6缺失值处理 对于特征值有缺失的样本，xgboost可以自动学习出他的分裂方向。xgboost内置处理缺失值的规则。用户需要提供一个和其他样本不同的值，然后把它作为一个参数传入，以此来作为缺失值的取值。xgboost在不同节点遇到缺失值时采用不同的处理方式，并且会学习未来遇到缺失值时的处理方法。
1.2.7剪枝技术 xgboost先从顶到底建立所有可以建立的子树，再从底到顶的反向机芯剪枝，比起lightGBM，这样不容易陷入局部最优解。【后剪枝技术：去掉某个子树或用叶子节点代替某个子树时，对模型整体的能力影响很小】
1.2.8内置交叉验证 xgboost允许在每一轮Boosting迭代中使用交叉验证，因此可以方便的获得最优Boosting迭代次数，而GBDT使用网格搜索，只能检测有限个值。
2.xgboost模型详解 2.1安装 安装有两种方式：
离线安装：可以去选择适合自己的版本在线安装：可以直接在终端使用pip命令进行安装 pip install xgboost-0.81-cp37-cp37m-win_amd64.whl 注意：多线程版本安装比较复杂，可以参考一些专业教程进行安装
2.2xgboost加载的数据格式解析 xgboost可以加载多种数据格式的训练数据
名称说明libsvm格式的文本数据Numpy二维数组xgboost算法自带的二进制的缓存文件。剪枝的数据存储在对象DMatrix中。 2.2.1下面会对各种格式进行演示 加载libsvm格式的数据 dtrain1 = xgb.DMatrix('train.svm.txt') 加载二进制的缓存文件 dtrain2 = xgb.DMatrix('train.svm.buffer') 加载numpy的数组 data = np.random.rand(5,10) # 5行10列数据集 label = np.random.randint(2,size=5) # 二分类目标值 dtrain = xgb.DMatrix(data,label=label) # 组成训练集 将scipy.sparse格式的数据转化为Dmatrix格式 csr = scipy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6426b0fe50df644b67d1db08978a08d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afd960e62c8b6a4dbc29101cca8148ed/" rel="bookmark">
			JDBC结果集ResultSet映射为实体类(对象)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.方法抽取
public static List&lt;Object&gt; handler(ResultSet rs, Class&lt;?&gt; clazz) { List&lt;Object&gt; list = new ArrayList&lt;&gt;(); Object obj = null; try { while (rs.next()) { // 创建一个clazz对象实例并将其赋给要返回的那个返回值。 obj = clazz.newInstance(); // 获取结果集的数据源 ResultSetMetaData rsmeta = rs.getMetaData(); // 获取结果集中的字段数 int count = rsmeta.getColumnCount(); // 循环取出个字段的名字以及他们的值并将其作为值赋给对应的实体对象的属性 for (int i = 0; i &lt; count; i++) { // 获取字段名 String name = rsmeta.getColumnName(i + 1); // 利用反射将结果集中的字段名与实体对象中的属性名相对应，由于 // 对象的属性都是私有的所以要想访问必须加上getDeclaredField(name)和 Field f = obj.getClass().getDeclaredField(name); f.setAccessible(true); // 将结果集中的值赋给相应的对象实体的属性 f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afd960e62c8b6a4dbc29101cca8148ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/681f1af27e6bb35c44ab5f5100ec5d77/" rel="bookmark">
			ASCII、Unicode、UTF-8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 一直对ASCII、Unicode、UTF-8编码不是很清楚，无意间看到了一篇文章对此解释的比较详细，就记录一下。
1.ASCII 我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。
上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。
ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。
2.非ASCII编码 英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。
但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128–255的这一段。
至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号
中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。
3.Unicode 正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。
可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。
Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。
4.Unicode的问题 需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。
比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。
这里就有两个严重的问题：
第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？
第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的
它们造成的结果是：
1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。
2）Unicode 在很长一段时间内无法推广，直到互联网的出现。
5.UTF-8 互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。
UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。
UTF-8 的编码规则很简单，只有二条：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/681f1af27e6bb35c44ab5f5100ec5d77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a53a036a05e7c53bd3236dc1606f92af/" rel="bookmark">
			iOS webview中video标签播放视频相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.iOS webview中video标签播放视频导致状态栏异常:
h5用video标签播放视频，系统会弹起一个window用AVPlayerViewController播放视频，导致异常，可以在控制器中监控window退出，在回调方法中解决问题。
1.通知：receiveWindowDidBecomeHiddenNotification
2.收到通知处理
- (void)receiveNotification:(NSNotification *)noti{
UIWindow *window = (UIWindow *)noti.object;
if(window){
UIViewController *root = window.rootViewController;
NSArray *arr = root.childViewControllers;
if(arr.count&gt;0&amp;&amp;[arr.firstObject isKindOfClass:NSClassFromString(@"AVPlayerViewController")]){
/* 代码 */
}
}
}
二：webview属性：
1.allowsInlineMediaPlayback
是否能播放内联视频，iPhone的默认值为false，iPad的默认值为true。
将此属性设置为true可以内嵌播放视频否则使用本机全屏控制器播放。 2.mediaTypesRequiringUserActionForPlayback
设置为NO，可以h5决定自动播放，否则，无论h5如何设置，都需要用户点击才能播放。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e3053f32bedd1fca4f7c30e13be7f9/" rel="bookmark">
			navicat连接Oracle异常需指定oci.dll文件解决办法以及工具下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 制定oci.dll和sqlplus.exe文件就可以了
oci.dll 百度网盘 链接：https://pan.baidu.com/s/1oXctYagEP68HL_3tCUiQiw 提取码：43wn sqlplus.exe 百度网盘 链接：https://pan.baidu.com/s/1REKukxykZJfUwFxVoyhZBQ 提取码：xwwi 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6acbe0f4d781bb10dcb837b7f4cd262/" rel="bookmark">
			机器学习--朴素贝叶斯分类器（python手动实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习-朴素贝叶斯分类器 简介名词介绍公式概率分布数据集及代码实现代码实现定义容器对象循环提取十个桶文件中的数据，分门别类存储计算先验概率，条件概率预测分类测试集验证预测测试十折交叉验证 代码汇总 总结 简介 朴素贝叶斯（Naive Bayes）是基于贝叶斯定理和概率论预测样本类别的概率算法，而朴素一词的来源就是假设各特征之间相互独立。朴素贝叶斯属于监督学习的生成模型，实现简单，没有迭代，并有坚实的数学理论（即贝叶斯定理）作为支撑。在大量样本下会有较好的表现，不适用于输入向量的特征条件有关联的场景。
关于贝叶斯定理的详细介绍
名词介绍 拿西瓜是否成熟举例，假设判断西瓜成熟的特征有：瓜蒂是否脱落，敲打的声音-浊响|清脆
先验概率：
先验概率是根据以往经验和分析得到的概率，先验概率无需样本数据，不受任何条件的影响。比如有1000个西瓜，其中熟瓜600，涩瓜400，则先验概率p（熟瓜）=0.6，p（涩瓜）=0.4，并不受瓜蒂和敲打声音的影响。再比如硬币正反面概率各为0.5也是先验概率。后验（条件）概率：
已知结果或者某一条件（结果也是一种条件），求知条件或者结果的概率。比如已知某西瓜瓜蒂脱落，判断瓜成熟的概率，即p(成熟|瓜蒂脱落)。拉普拉斯平滑（Laplace smoothing）：
它的思想非常简单，就是对先验概率的分子（划分的计数）加1，分母加上类别数；对条件概率分子加1，分母加上对应特征的可能取值数量。这样在解决零概率问题的同时，也保证了概率和依然为1。
直接的作用就是防止模型“过拟合”，提高了模型的泛化性能。
也是解决样本为0的时概率为0的问题，因为若p(B)为0，则P(B|A)也为0，而实际并非如此。概率密度函数：
用于描述连续型随机变量所服从的概率分布，由此判断不可列的连续型随机变量的概率。 公式 贝叶斯公式：
朴素贝叶斯基本公式：
即P(B|A) = P(A|B)P(B)
概率密度函数：
正态分布：
概率分布 高斯分布型：
正态曲线呈钟型，两头低，中间高，左右对称因其曲线呈钟形，因此人们又经常称之为钟形曲线多项式型：
用于离散值模型里。比如文本分类问题里面我们提到过，我们不光看词语是否在文本中出现，也得看出现次数。如果总词数为n，出现词数为m的话，有点像掷骰子n次出现m次这个词的场景。伯努利型：
亦称“零一分布”、“两点分布”：一个事情有两种可能的结果，其中结果为1的发生概率为a,结果2发生的概率为1-a 数据集及代码实现 数据集是使用了分层抽样的十折交叉验证的，所以分为了十个名字相似的各类样本相近的数据集桶文件，如下：
该数据集为国会投票的样本：
分析数据集：
democrat为民主党，republican为共和党，即标签，表示类别
此后y和n表示特征，共16个特征，每个特征两个类别
代码实现 定义容器对象 存储从数据集中提取的数据，存储对数据统计分析的结果
数据分为三类：标签类别（democrat/republican），字符型特征（y/n），数值型（即连续型，该数据集没有此类型）
''' params: bucketPrefix： 桶文件名的前缀 testBucketNumber：测试数据所在的桶的编号 dataFormat: 数据文件格式列表 ''' total=0 #记录总数据量 classes={} #存类别出现的次数 counts={} #每个类别对应的属性值出现的次数 self.format = dataFormat.strip().split('\t') # 切分每一列的数据类型 ''' 存储数值型数据信息 ''' totals={} # 每种类别对应的值的总和 numericValues={} #存每种类别对应的列的取值 ''' 存储计算出的概率 ''' self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6acbe0f4d781bb10dcb837b7f4cd262/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8816d95c53f8980ad27e2b3d757acea7/" rel="bookmark">
			一个Java死锁示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		没什么说的，都在注释里了：
public class DeadLock { public static void main(String[] args) { //o1 o2 代表资源 Object o1 = new Object(); Object o2 = new Object(); System.out.println("go go go!"); Thread t1 = new Thread(new Runnable() { public void run() { synchronized (o1) { //线程t1获取o1的锁才能继续执行 try { Thread.sleep(3000); //睡3秒，确保线程t2把o2锁拿走 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println("t1获得了哦O1"); synchronized (o2) { //线程t1获取o2的锁才能继续执行 System.out.println("t1获得了哦O2"); } } } }); Thread t2 = new Thread(new Runnable() { public void run() { synchronized (o2) { //线程t2获取o2的锁才能继续执行 try { Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8816d95c53f8980ad27e2b3d757acea7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4e4826c72ad6e688bab6f4f9138054c/" rel="bookmark">
			Java适配器模式生活中的实例，帮助理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以手机充电的场景为例，写了个适配器的代码。
接口： 220V电源 Interface Charge220{}
手机的充电方法：void Charge(Charge220 c){
}
日常生活，我们可以直接获取220V电源，但是手机又不能用220V点压充电，所以我们需要一个充电器（适配器）
代码如下：
//我们只有220V的可以直接使用的电压 interface Charge220{ void charge(); } //代表3V的电源，但我们直接获取不到 class V3 { public void charge() { System.out.println("charging with 3V"); } } //适配器，实现（接入）220v，持有3v对象，在充电方法中调用3v的充电 class VAdapter implements Charge220{ V3 v3 ; public VAdapter(V3 v3) { super(); this.v3 = v3; } @Override public void charge() { v3.charge(); } } public class Phone { public Phone() { super(); } //手机的充电方法，能直接获取的只有220v的电，但我们肯定不能把手机直接接到220V电压的电线上 public void getE(Charge220 c) { c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4e4826c72ad6e688bab6f4f9138054c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0e622a135192d7d7d84158f678170f3/" rel="bookmark">
			（国内）计算机核心期刊排名及投稿经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机核心期刊新排名：2004部分核心期刊名单（自动化、计算机部分与无线电、电信部分)
自动化、计算机部分
1 计算机学报 北京 中国计算机学会等
2 软件学报 北京 中国科学院软件研究所
3 计算机研究与发展 北京 中国科学院计算技术研究所等
4 自动化学报 北京 中国科学院等
5 计算机科学 重庆 国家科技部西南信息中心
6 控制理论与应用 广州 中国科学院系统科学研究所等
7 计算机辅助设计与图形学学报 北京 中国计算机学会等
8 计算机工程与应用 北京 华北计算技术研究所
9 模式识别与人工智能 北京 中国自动化学会等
10 控制与决策 沈阳 东北大学
11 小型微型计算机系统 沈阳 中国科学院沈阳计算机技术研究所
12 计算机工程 上海 上海市计算机协会
13 计算机应用 北京 中国科学院计算机应用研究所等
14 信息与控制 沈阳 中国科学院沈阳自动化研究所
15 机器人 沈阳 中国科学院沈阳自动化研究所
16 中国图象图形学报 A版 北京 中国图象图形学会
17 计算机应用研究 成都 四川省计算机应用研究中心
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0e622a135192d7d7d84158f678170f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/935cd1106c5c87dcc5be3b254e19c612/" rel="bookmark">
			rabbitMQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
RabbitMQ实战教程
1.什么是MQ
2.RabbitMQ
2.1.RabbitMQ的简介
2.2.官网
2.3.MQ的其他产品
2.4.学习5种队列
2.5.安装文档
3.搭建RabbitMQ环境
3.1.下载
3.2.windows下安装
3.3.Linux下安装
3.4.安装的注意事项
3.5.安装完成后操作
4.添加用户
4.1.添加admin用户
4.2.用户角色
4.3.创建Virtual Hosts
4.4.管理界面中的功能
5.学习五种队列
5.1.导入my-rabbitmq项目
5.2.简单队列
5.3.Work模式
5.4.Work模式的“能者多劳”
5.5.消息的确认模式
5.6.订阅模式
5.7.路由模式
5.8.主题模式（通配符模式）
6.Spring-Rabbit
6.1.Spring项目
6.2.简介
6.3.使用
6.4.持久化交换机和队列
7.Spring集成RabbitMQ一个完整案例
7.1.在A系统中发送消息到交换机
7.2.在B系统接收消息
7.3.在C系统中接收消息
8.Springboot集成RabbitMQ
8.1.简单队列
8.2.多对多使用（Work模式）
8.3.Topic Exchange（主题模式）
8.4.Fanout Exchange（订阅模式）
9.总结
RabbitMQ实战教程
1.什么是MQ
消息队列（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已。
其主要用途：不同进程Process/线程Thread之间通信。
为什么会产生消息队列？有几个原因：
不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个；
不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列；
关于消息队列的详细介绍请参阅：
《Java帝国之消息队列》
《一个故事告诉你什么是消息队列》
《到底什么时候该使用MQ》
MQ框架非常之多，比较流行的有RabbitMq、ActiveMq、ZeroMq、kafka，以及阿里开源的RocketMQ。本文主要介绍RabbitMq。
本教程pdf及代码下载地址：
代码：https://download.csdn.net/download/zpcandzhj/10585077
教程：https://download.csdn.net/download/zpcandzhj/10585092
2.RabbitMQ
2.1.RabbitMQ的简介
这里写图片描述
开发语言：Erlang – 面向并发的编程语言。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/935cd1106c5c87dcc5be3b254e19c612/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13fffb8f3bd64b38d53d0ea608203668/" rel="bookmark">
			hbase和hive的区别是什么？怎么区分两者之间的关系？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HIVE： hive，是一款开源的数据仓库 1、hive不是数据库，而是数据仓库，主要依赖于hadoop来实现
2、底层文件系统是hadoop的hdfs，实现对hdfs上结构化数据的SQL操作HQL，速度较慢
3、计算引擎是hadoop的mapreduce
4、依靠存储在其他关系型数据库metastore来对hdfs结构化数据进行管理，实现类似数据库的功能
5、不具备数据库的一些主键、索引、update操作等特性，但是提供了分区、块索引、SQL等特性
6、比较适合存储海量的全量（历史+更新）轨迹数据，比对数据进行批量的挖掘、分析等操作
总结一下，hive是基于hadoop实现的数据仓库，适合存储海量全量数据，支持类SQL操作，性能相对较差，数据存储
有一定的限制，不支持更新、索引等事务。适合海量数据的挖掘和分析，通俗一点来说，hive其实就是借助mysql等数据库在
hadoop上层套了一个壳，来实现对hdfs上结构化数据的映射，为上层提供sql服务。
HBASE：
即Hadoop databse，顾名思义就是一个hadoop的数据库
1、nosql数据库之一，基于列式存储（列族），适合海量半结构化数据的存储和检索
2、不支持SQL、适合海量、带时间序列的数据的存储和检索、性能较好
3、原生支持基于rowkey的一级索引，rowkey按照字典序进行排序
4、运算执行引擎是hbase自身提供、底层存储基于hdfs
总结一下，hbase是NOSQL数据库的一种，基于分布式列式存储，适合海量半结构化带时间序列的数据的存储和检索，性能较优秀，hbase底层存储依赖于hdfs，与rdbms的区别与其他nosql类似，比如不支持SQL、事务性相对较差等等。
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
综上，hbase是数据库、hive是数据仓库，而这有很大的区别、也有很多类似的地方比如都属于hadoop生态圈、存储都基于hdfs等。一般来说用hive作为海量结构化全量数据的存储、运算、挖掘、分析；hbase用来作为海量半结构化数据的存储、检索；这二者可以很好协同工作，hive上计算完的结果放在hbase中供检索，也可以将hbase里面的结构化数据和hive相结合，实现对hbase的sql操作等等。
--------------------- 作者：zx8167107 来源：CSDN 原文：https://blog.csdn.net/zx8167107/article/details/79265537?utm_source=copy 版权声明：本文为博主原创文章，转载请附上博文链接！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c07b43870b952e5febda0cad30ead3e/" rel="bookmark">
			深入理解HBase的系统架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HBase的构成RegionsHBase的HMasterZooKeeperHBase各组成部分之间的合作HBase的第一次读写HBase的META tableRegion Server的组成HBase的写操作步骤 步骤一步骤二HBase的MemStoreHBase Region FlushHFileHFile的结构 HFile的索引HBase的读合并（Read Merge）以及读放大（Read amplification）HBase的Compaction Minor CompactionMajor CompactionRegion的分割（Region split）读操作的负载均衡（Read Load Balancing）HDFS的数据备份（Data Replication）HBase的异常恢复（Crash Recovery）数据恢复（Data Recovery）Apache HBase的优缺点 优点缺点 初次接触HBase的读者，建议先阅读浅析HBase：为高效的可扩展大规模分布式系统而生
HBase的构成 物理上来说，HBase是由三种类型的服务器以主从模式构成的。这三种服务器分别是：Region server，HBase HMaster，ZooKeeper。
其中Region server负责数据的读写服务。用户通过沟通Region server来实现对数据的访问。
HBase HMaster负责Region的分配及数据库的创建和删除等操作。
ZooKeeper作为HDFS的一部分，负责维护集群的状态（某台服务器是否在线，服务器之间数据的同步操作及master的选举等）。
另外，Hadoop DataNode负责存储所有Region Server所管理的数据。HBase中的所有数据都是以HDFS文件的形式存储的。出于使Region server所管理的数据更加本地化的考虑，Region server是根据DataNode分布的。HBase的数据在写入的时候都存储在本地。但当某一个region被移除或被重新分配的时候，就可能产生数据不在本地的情况。这种情况只有在所谓的compaction之后才能解决。
NameNode负责维护构成文件的所有物理数据块的元信息（metadata）。
HBase结构如下图所示：
Regions HBase中的表是根据row key的值水平分割成所谓的region的。一个region包含表中所有row key位于region的起始键值和结束键值之间的行。集群中负责管理Region的结点叫做Region server。Region server负责数据的读写。每一个Region server大约可以管理1000个region。Region的结构如下图所示：
HBase的HMaster HMaster负责region的分配，数据库的创建和删除操作。
具体来说，HMaster的职责包括：
调控Region server的工作 在集群启动的时候分配region，根据恢复服务或者负载均衡的需要重新分配region。监控集群中的Region server的工作状态。（通过监听zookeeper对于ephemeral node状态的通知）。管理数据库 提供创建，删除或者更新表格的接口。 HMaster的工作如下图所示：
ZooKeeper HBase利用ZooKeeper维护集群中服务器的状态并协调分布式系统的工作。ZooKeeper维护服务器是否存活，是否可访问的状态并提供服务器故障/宕机的通知。ZooKeeper同时还使用一致性算法来保证服务器之间的同步。同时也负责Master选举的工作。需要注意的是要保证良好的一致性及顺利的Master选举，集群中的服务器数目必须是奇数。例如三台或五台。
ZooKeeper的工作如下图所示：
HBase各组成部分之间的合作 ZooKeeper用来协调分布式系统的成员之间共享的状态信息。Region Server及HMaster也与ZooKeeper连接。ZooKeeper通过心跳信息为活跃的连接维持相应的ephemeral node。如下图所示：
每一个Region server都在ZooKeeper中创建相应的ephemeral node。HMaster通过监控这些ephemeral node的状态来发现正常工作的或发生故障下线的Region server。HMaster之间通过互相竞争创建ephemeral node进行Master选举。ZooKeeper会选出区中第一个创建成功的作为唯一一个活跃的HMaster。活跃的HMaster向ZooKeeper发送心跳信息来表明自己在线的状态。不活跃的HMaster则监听活跃HMaster的状态，并在活跃HMaster发生故障下线之后重新选举，从而实现了HBase的高可用性。
如果Region server或者HMaster不能成功向ZooKeeper发送心跳信息，则其与ZooKeeper的连接超时之后与之相应的ephemeral node就会被删除。监听ZooKeeper状态的其他节点就会得到相应node不存在的信息，从而进行相应的处理。活跃的HMaster监听Region Server的信息，并在其下线后重新分配Region server来恢复相应的服务。不活跃的HMaster监听活跃HMaster的信息，并在起下线后重新选出活跃的HMaster进行服务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c07b43870b952e5febda0cad30ead3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a696507aca50848b7f5611c55c3de9d0/" rel="bookmark">
			HashMap源码研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自博客园：http://www.cnblogs.com/jzb-blog/p/6637823.html
每个java程序员都知道，HashMap是java中最重要的集合类之一，也是找工作面试中非常常见的考点，因为HashMap的实现本身确实蕴含了很多精妙的代码设计。
对于普通的程序员，可能仅仅能说出HashMap线程不安全，允许key、value为null，以及不要求线程安全时，效率上比HashTable要快一些。稍微好一些的，会对具体实现有过大概了解，能说出HashMap由数组+链表+RBT实现，并了解HashMap的扩容机制。但如果你真的有一个刨根问题的热情，那么你肯定会想知道具体是如何一步步实现的。HashMap的源码一共2000多行，很难在这里每一句都说明，但这篇文章会让你透彻的理解到我们平时常用的几个操作下，HashMap是如何工作的。
要先提一下的是，我看过很多讲解HashMap原理的文章，有一些讲的非常好，但这些文章习惯于把源代码和逻辑分析分开，导致出现了大段的文字讲解代码，阅读起来有些吃力和枯燥。所以我想尝试另一种风格，将更多的内容写进注释里，可能看起来有些啰嗦，但对于一些新手的理解，应该会有好的效果。
HashMap结构 首先是了解HashMap的几个核心成员变量（以下均为jdk源码）：
1 transient Node&lt;K,V&gt;[] table;　//HashMap的哈希桶数组，非常重要的存储结构，用于存放表示键值对数据的Node元素。 2 3 transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; //HashMap将数据转换成set的另一种存储形式，这个变量主要用于迭代功能。 4 5 transient int size;　//HashMap中实际存在的Node数量，注意这个数量不等于table的长度，甚至可能大于它，因为在table的每个节点上是一个链表（或RBT）结构，可能不止有一个Node元素存在。 6 7 transient int modCount;　//HashMap的数据被修改的次数，这个变量用于迭代过程中的Fail-Fast机制，其存在的意义在于保证发生了线程安全问题时，能及时的发现（操作前备份的count和当前modCount不相等）并抛出异常终止操作。 8 9 int threshold;　//HashMap的扩容阈值，在HashMap中存储的Node键值对超过这个数量时，自动扩容容量为原来的二倍。 10 11 final float loadFactor;　//HashMap的负载因子，可计算出当前table长度下的扩容阈值：threshold = loadFactor * table.length。 显然，HashMap的底层实现是基于一个Node的数组，那么Node是什么呢？在HashMap的内部可以看见定义了这样一个内部类：
1 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { 2 final int hash; 3 final K key; 4 V value; 5 Node&lt;K,V&gt; next; 6 7 Node(int hash, K key, V value, Node&lt;K,V&gt; next) { 8 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a696507aca50848b7f5611c55c3de9d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afb5003fcd785815e3d15753b4e791ab/" rel="bookmark">
			两种方法解决Undefined symbol SystemInit问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法一：
1.在startup_stm32l1xx_md.s中注释：
2.在工程中增加：
解决方法二：
增加一个系统C文件，可以官方固件包里找到。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b2d005dc5f5156fae428fc5bdb4a181/" rel="bookmark">
			通过Lombok学习如何写好hashCode和equals方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平时开发过程中，有时需要重写javaBean的hashCode和equals方法，但是一时间却不知道如何编写，百度上一搜索各种写法，总感觉没一个是标准写法。还好，Lombok的@Data会自动给JavaBean填充hashCode和equals方法，可以通过反编译出来，学习下Lombok如何重写hashCode和equals方法的。
import lombok.Data; import java.util.List; /** * @author sunchangtan * @date 2019/2/15 13:18 */ @Data public class Person { private String name; private int age; private List&lt;Friend&gt; friendList; private Person[] parents; private Nation nation; } 使用jd-gui.exe反编译出class字节码，代码如下：
package com.sample.mybatis.test; import java.util.Arrays; import java.util.List; public class Person { private String name; private int age; private List&lt;Friend&gt; friendList; private Person[] parents; private Nation nation; public void setAge(int age) { this.age = age; } public int hashCode() { int PRIME = 59;int result = 1;Object $name = getName();result = result * 59 + ($name == null ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b2d005dc5f5156fae428fc5bdb4a181/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dcc55d534f5617b62f807a7756ca3bf/" rel="bookmark">
			模式之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35a3db8981bb3493da0a91526e056513/" rel="bookmark">
			非root权限scp免密传输文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境说明 有两台服务器，client端没有root权限，接收端server有root权限。现在需要从client端免密scp文件到server端。
因为client端没有.ssh文件夹的访问权限，所以不能直接使用client端的密钥，需要从server端生成密钥文件。
整个流程操作步骤如下：
1、server端生成密钥，并且把公钥添加到authorized_keys
2、把私钥上传到client端
3、使用scp -i指定密钥传输
server端配置 生成密钥对 执行ssh-keygen -t rsa，完成之后在/root/.ssh文件夹可以查看到密钥对id_rsa为密钥文件，id_rsa.pub为公钥文件；
执行cp -rf /root/.ssh/id_rsa.pub /root/.ssh/authorized_keys即可
client端配置 上传私钥 把server端的id_rsa上传至client端即可
使用scp传输 了解scp命令的可以直接跳过，看后面-i参数的使用方法
1．命令格式：
scp [参数] [原路径] [目标路径]
2．命令功能：
scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在linux服务器之间复制文件和目录。
3．命令参数：
-1 强制scp命令使用协议ssh1
-2 强制scp命令使用协议ssh2
-4 强制scp命令只使用IPv4寻址
-6 强制scp命令只使用IPv6寻址
-B 使用批处理模式（传输过程中不询问传输口令或短语）
-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）
-p 保留原文件的修改时间，访问时间和访问权限。
-q 不显示传输进度条。
-r 递归复制整个目录。
-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。
-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。
-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。
-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。
-l limit 限定用户所能使用的带宽，以Kbit/s为单位。
-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，
-P port 注意是大写的P, port是指定数据传输用到的端口号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35a3db8981bb3493da0a91526e056513/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/094c766f392d26bdb82b8acc6dad0b5f/" rel="bookmark">
			Object Detection(目标检测神文)(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 [CVPR2019] Generalized Intersection over Union: A Metric and A Loss for Bounding Box Regression anchor-free[CVPR2019] Region Proposal by Guided Anchoring[CVPR2019] Feature Selective Anchor-Free Module for Single-Shot Object Detection[CVPR2019]CenterNet: Keypoint Triplets for Object Detection[CVPR2019]Objects as Points[CVPR2019]CornerNet-Lite: Efficient Keypoint Based Object Detection[CVPR2019]FoveaBox: Beyond Anchor-based Object Detector[2019]DuBox: No-Prior Box Objection Detection via Residual Dual Scale Detectors YOLO[2019]Spiking-YOLO: Spiking Neural Network for Real-time Object Detection[CVPR2019]Gaussian YOLOv3: An Accurate and Fast Object Detector Using Localization Uncertainty for Autonomous Driving [AAAI2019]Gradient Harmonized Single-stage Detector[2019]Augmentation for small object detection[2019]SimpleDet: A Simple and Versatile Distributed Framework for Object Detection and Instance Recognition[2019]BayesOD: A Bayesian Approach for Uncertainty Estimation in Deep Object Detectors[2019]DetNAS: Neural Architecture Search on Object Detection[2019]ThunderNet: Towards Real-time Generic Object Detection[2019]Feature Intertwiner for Object Detection[CVPR2019]Few-shot Adaptive Faster R-CNN[2019]Improving Object Detection with Inverted Attention[2019]FCOS: Fully Convolutional One-Stage Object Detection[CVPR2019]Libra R-CNN: Towards Balanced Learning for Object Detection[2019]Complexer-YOLO: Real-Time 3D Object Detection and Tracking on Semantic Point Clouds[CVPR2019]What Object Should I Use?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/094c766f392d26bdb82b8acc6dad0b5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27bc44cb91555dc0752206f5b4a0ade7/" rel="bookmark">
			计算机视觉算法岗面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自https://blog.csdn.net/qq_28214097/article/details/80007627
https://blog.csdn.net/qq_28214097/article/details/80007627
SVM:
线性回归：
逻辑回归：
tensorflow原理、细节：
SIFT原理：
拉普拉斯图像融合算法：
PCA原理：
反向传播原理：
梯度消失的原因和解决办法：
决策树：
随机森林：
K-means的基本流程：与KNN的区别：
梯度下降法与牛顿法的区别与优劣：
区别：梯度下降法是一阶，牛顿法是二阶
牛顿法相对于梯度下降法：优点：二阶比一阶收敛速度快；缺点：对目标函数严格，要求目标函数二阶可微，Hessian矩阵正定；需要计算Hessian矩阵以及它的逆，计算量大。
描述Canny算法的流程：
以下是简述：
1.先用高斯滤波器进行图像模糊（一般边缘检测算法都需要先滤波降低对噪声的敏感）
2.计算图像的梯度幅值图像和角度图像（计算梯度即提取边缘，参考其它边缘检测算法；计算角度是为步骤3要用）
3.对梯度幅值图像进行非最大值抑制（目的是为了细化边缘）
4.用双阈值对边缘进行选择和连接（主要思想是把弱边缘连接到强边缘上）
CNN最成功的应用是在CV，那么为什么NLP和Speech的很多问题也可以用CNN解出来？为什么AIphaGo里也用了CNN？这几个不相关的问题的相似性在哪里？CNN通过什么手段抓住了这个共性？
CNN是用于挖掘数据之间的空间相关性（相对于RNN用于挖掘时序相关性），所以不管是NLP，Speech还是AlphaGo，只要数据之间存在空间相关性，就可以使用CNN。而CNN最成功的应用在CV是因为在图像数据中的空间相关性最明显，像素之间存在两个维度上的空间相关性。回答CNN通过什么手段抓住此共性这个问题，实质上是回答卷积和池化的特点。主要手段有局部连接(local connectivity)、权值共享(parameter sharing)和池化(pooling)局部连接和权值共享有效地减少了网络的权值参数，抑制过拟合，同时保持了原始数据之间的空间联系。池化是下采样的一种方式，只取数值最大的特征，减少参数并且在空间上对原图物体保持平移不变性。
什么样的资料集不适合用深度学习?
数据集太小。数据集太小时，用深度学习提取出来的特征非常容易过拟合，没有泛化能力，因而不及传统的机器学习方法。其本质是样本空间太稀疏，不能反映总体空间的分布，因而用深度学习得到的模型会过拟合。
数据之间没有局部相关性。深度学习对于结构化的数据提取特征有非常好的效果，但对于没有结构化的数据，即数据之间不存在局部相关性，如可能存在统计关系等，此时用深度学习就不是很合适。
激活函数选用什么，有什么好处，为什么？
sigmoid：
表达式：
求导：
特点：增强0附近的梯度，放大信号，梯度计算方便，但对非敏感区域会饱和，造成梯度消失
tanh:
求导：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75be7e3893c2bb2fb7d6ec9eee670763/" rel="bookmark">
			Android Native层异常分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Native报错定位 今天调试Android stagefright模块，修改MediaCodec.cpp文件时，一不小心在代码里写了个空指针进去。
于是得到了下面这个报错日志：
--------- beginning of crash libc : Fatal signal 11 (SIGSEGV), code 1, fault addr 0x0 in tid 5104 (MediaCodec_loop) DEBUG : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** DEBUG : Build fingerprint: '*******************************************' DEBUG : Revision: '0' DEBUG : ABI: 'arm' DEBUG : pid: 5050, tid: 5104, name: MediaCodec_loop &gt;&gt;&gt; com.google.android.exoplayer2.demo &lt;&lt;&lt; DEBUG : signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x0 DEBUG : Cause: null pointer dereference DEBUG : r0 ******** r1 ******** r2 ******** r3 ******** DEBUG : r4 ******** r5 ******** r6 ******** r7 ******** DEBUG : r8 ******** r9 ******** sl ******** fp ******** DEBUG : DEBUG : backtrace: DEBUG : #00 pc 00018e90 /system/lib/libc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75be7e3893c2bb2fb7d6ec9eee670763/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c532b51d0e982c16026404b826a28a/" rel="bookmark">
			javascript (js)通过button按钮实现盒子的显示和隐藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前奏：无论是实现div或其他内容的显示和隐藏，原理都差不多 效果图： 点击隐藏后隐藏盒子，同时隐藏按钮的值修改为显示。点击显示后盒子又将显示，显示按钮的值修改为隐藏，如图：
完整代码如下（代码详解）：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; /*div盒子css样式——区分*/ div { height: 150px; //高度150px width: 150px; //宽度150px background-color: yellow; //盒子颜色yellow } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="button" value="隐藏" id="btn"&gt; &lt;div id="dv"&gt;&lt;/div&gt; &lt;script&gt; //通过button按钮的id获取点击事件 document.getElementById("btn").onclick = function () { //使用if判断，判断button按钮的value属性 if (this.value === "隐藏") { // 如果是隐藏，那么点击后通过div盒子的id修改css样式，将display属性值改为none document.getElementById("dv").style.display = "none"; //this关键字获取的是当前对象 通过this关键字来修改button的value值 this.value = "显示"; } else if (this.value === "显示") { // 如果是显示，那么点击后通过div盒子的id修改css样式，将display属性值改为block document.getElementById("dv").style.display = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2c532b51d0e982c16026404b826a28a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7add45fc137c296101f45e85a6f74f57/" rel="bookmark">
			第十三章 Swing程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Swing 程序设计 Swing概述 Swing为“轻量级组件“完全由Jav语言编写，可以在任何平台上运行；依赖于本地平台的组件被称为“重量级组件”，如AWTSwing组件的类的层次和继承关系 Created with Raphaël 2.2.0 Java.lang.Object类 Java.awt.Component类 Java.awt.Container类 Javax.swing.JComponent类 常用Swing组件概述 组件名称定义JButton代表Swingt按钮，按钮可以带一些图片或文字JCheckBoxSwing中的复选框组件JComBox下拉列表框，可以在下拉显示区域显示多个选项JFrameSwing的框架类JDialogSwing版本的对话框JLabelSwing中的标签组件JRadioButtonSwing的单选按钮JList能够在用户界面中显示一系列条目的组件JTextField文本框JPasswordField密码框JTextAreaSwing中的文本区域JOptionPaneSwing中的一些对话框体 常用窗体 JFrame窗体 可以将JFrame看作是承载这些Swing组件的容器。 创建JFrame窗体前需要继承java.swing.JFrame类 JFrame在程序中的语法格式如下 JFrame jf = new JFrame(title); Container container = jf.getContentPane(); jf:JFrame类的对象 container:Container类的对象，可以使用JFrame对象调用getContentPane()方法获取。 Swing组件的窗体通常与组件和容器相关，所以在JFrame对象创建完成后，需要调用getContentPane()方法将窗体转换为容器，然后在容器中添加组件或设置布局管理器。
如需将组件添加至容器，可以使用来自Container类的add()方法进行设置，如： container.add(new JButton("按钮")); remove()方法将这些组件从容器中删除 container.remove(new JButton("按钮")); 实例：
import java.awt.*; import javax.swing.*; public class Example1 extends JFrame { private static final long serialVersionUID = 1L; // 定义一个类继承JFrame类 public void CreateJFrame(String title) { // 定义一个CreateJFrame()方法 JFrame jf = new JFrame(title); // 实例化一个JFrame对象 Container container = jf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7add45fc137c296101f45e85a6f74f57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d940c2b9f2b887740ae0ef600b79fe0/" rel="bookmark">
			理解HTTP协议中的 Expect: 100-continue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理解 HTTP/1.1 协议里设计 100 (Continue) HTTP 状态码的的目的是，在客户端发送 Request Message 之前，HTTP/1.1 协议允许客户端先判定服务器是否愿意接受客户端发来的消息主体（基于 Request Headers）。
即， 客户端 在 Post（较大）数据到服务端之前，允许双方“握手”，如果匹配上了，Client 才开始发送（较大）数据。
这么做的原因是，如果客户端直接发送请求数据，但是服务器又将该请求拒绝的话，这种行为将带来很大的资源开销。
协议对 HTTP客户端的要求是：
如果 client 预期等待“100-continue”的应答，那么它发的请求必须包含一个 " Expect: 100-continue" 的头域！
相关策略 客户端策略 如果客户端有 post 数据要上传，可以考虑使用 100-continue 协议。在请求头中加入 {“Expect”:”100-continue”}如果没有 post 数据，不能使用 100-continue 协议，因为这会让服务端造成误解。并不是所有的 Server 都会正确实现 100-continue 协议，如果 Client 发送 Expect:100-continue 消息后，在 timeout 时间内无响应，Client 需要立马上传 post 数据。有些 Server 会错误实现 100-continue 协议，在不需要此协议时返回 100，此时客户端应该忽略。服务端策略 正确情况下，收到请求后，返回 100 或错误码。如果在发送 100-continue 前收到了 post 数据（客户端提前发送 post 数据），则不发送 100 响应码(略去)。 以上信息整理自：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d940c2b9f2b887740ae0ef600b79fe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53de19464afa7af698918aa6f528feb9/" rel="bookmark">
			HTTP 状态码(Status Code)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP状态码 HTTP状态码(HTTP Status Code)是用于标识网页服务器超文本传输协议的响应状态的3位数字代码。
状态码分类：
1xx 消息响应(表示接收到请求并且继续处理)。
2xx 成功(请求被成功接收，处理)。
3xx 重定向(为了完成指定的动作，必须接收进一步处理)。
4xx 请求错误(客户端请求的语法错误，或不能正确执行请求)。
5xx 服务器错误(请求正确，但服务器不能正确执行)。
常见状态码 200 服务器响应正常。
304 该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。
400 无法找到请求的资源。
401 访问资源的权限不够。
403 没有权限访问资源。
404 需要访问的资源不存在。
405 需要访问的资源被禁止。
407 访问的资源需要代理身份验证。
414 请求的URL太长。
500 服务器内部错误。
status code &amp; link 100 Continue
101 Switching Protocol
200 OK
201 Created
202 Accepted
203 Non-Authoritative Information
204 No Content
205 Reset Content
206 Partial Content
300 Multiple Choices
301 Moved Permanently
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53de19464afa7af698918aa6f528feb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58f1bca438b4c317037c94e4d8259e1a/" rel="bookmark">
			二分法与排序算法(二分法排序,插入法排序,冒泡排序,直接排序,直接选择排序)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二分法 二分法排序:查询一个元素在其他经过排序的数字数组中的索引 package com.test.two; import java.util.Arrays; public class 二分法 { public static void main(String[] args) { int[] arr = { 11, 22, 9, 33, 4, 25, 27, 15 }; Arrays.sort(arr); int[] arr1 = arr; int num = 22; System.out.println(Arrays.toString(arr1)); System.out.println(meth(arr1, num)); } private static int meth(int[] arr, int num) { int start = 0; int end = arr.length - 1; while (start &lt;= end) { int mid = (start + end) / 2; if (arr[mid] &gt; num) { end = mid - 1; } else if (arr[mid] &lt; num) { start = mid + 1; } else { return mid; } } return -1; } } 排序算法(插叙排序,冒泡排序,直接排序,直接选择排序) 插入法排序:外循环从0 开始到 数组长度,内循环从外循环元素 到0 package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58f1bca438b4c317037c94e4d8259e1a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/411/">«</a>
	<span class="pagination__item pagination__item--current">412/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/413/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>