<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66f61a25c158161261ebd32d9d6ac8b4/" rel="bookmark">
			Saas整合ELK Stack
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ELK Stack（Elasticsearch、Logstash、Kibana）是一个流行的日志管理和分析工具。将SaaS与ELK Stack整合，可以实现对日志的实时收集、分析和可视化。
以下是将SaaS整合ELK Stack的操作流程：
1. 准备工作
- 注册并登录ELK Stack所在的服务提供商，获取ELK Stack的访问权限。
- 确保SaaS服务已部署，并能够正常运行。
2. 部署ELK Stack
- 根据服务提供商的文档，在SaaS平台上部署ELK Stack。一般情况下，可以通过以下命令安装Elasticsearch、Logstash和Kibana：
# 安装Elasticsearch sudo apt-get install elasticsearch # 安装Logstash sudo apt-get install logstash # 安装Kibana sudo apt-get install kibana - 配置ELK Stack，包括以下内容：
1. 配置Elasticsearch集群名称和节点名称。
2. 配置Logstash的输入、过滤器和输出。
3. 配置Kibana的索引和可视化。
3. 配置SaaS服务日志收集
- 在SaaS服务中，配置将日志输出到ELK Stack所在的日志收集器（如Logstash）。
- 修改日志输出格式，使其符合ELK Stack的解析规则。例如，使用以下模板配置日志格式：
{ "@timestamp": "2021-08-01T00:00:00.000Z", "@version": "1", "log_name": "saas_service", "level": "INFO", "message": "This is a sample log.", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66f61a25c158161261ebd32d9d6ac8b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91dc7877cad0476d8a15c3a4521d5b6c/" rel="bookmark">
			CSDN怎么在文章中生成目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 手动添加自动添加实现效果 手动添加 想要在CSDN文章中生成目录，需要两步：
在博文中（一般是文章顶部）加上：@[TOC](这里写目录标题)然后使用#对标题编号。 自动添加 在使用Markdown写CSDN文章时，先点击【工具栏】右上角【目录】，选择【添加】目录。然后文章标题使用#编号。 实现效果 实现效果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/263bb4c45ca51c288261814a0c9635cd/" rel="bookmark">
			网线插好了但是电脑连不上网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天，我用电脑联网时，突然发现不能连接网络了。但是前几天，还是能正常连接网络。我检查了网线确实连接了电脑，但是不知道是不是接触不良，或者网线坏了。我反复插了几次网线，但是电脑还是连不上网络。后来我打开【设置】-【网络和Internet】-【更改适配器选项】，结果发现我电脑的以太网竟然被禁用了，重新启动以太网后，我就成功连上了网络。
所以，我们在电脑已经插好网线的前提下，发现连不上网路，可以查看电脑的以太网是否禁用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/407ec17f532af16da5f6cd46d9d6576a/" rel="bookmark">
			怎么在电脑上找到自己安装的软件的安装包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以Visual Studio Code为例，先找到桌面的快捷方式的图标，然后单击鼠标右键，选择【属性】
选择【快捷方式】中【打开文件所在的位置】
找到文件所在位置的上一级
该文件夹即是我们要找的安装包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb3ce552723ef8bcd0d2e5c1d24b9d79/" rel="bookmark">
			PositiveSSL和Sectigo的多域名证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，我们要知道PositiveSSL是Sectigo旗下的子品牌，提供多种类型的SSL数字证书，包括DV基础型的多域名SSL证书。Sectigo的SSL证书产品同样比较丰富，不仅有DV基础型多域名SSL证书，还有OV企业型以及EV增强型的多域名SSL证书。今天就随SSL盾小编了解PositiveSSL和Sectigo旗下的多域名SSL证书，
1.多域名SSL证书是比较灵活的一款SSL证书，它可以同时保护多个独立的域名，不论是多个主域名还是多个子域名。PositiveSSL和Sectigo旗下的多域名SSL证书默认包含3-5个域名记录，如果不够用还可以付费添加。对于域名比较多的个人或者企事业单位，多域名SSL证书可以节省管理SSL证书的成本以及时间。
2.PositiveSSL旗下的DV基础型多域名SSL证书价格较低，只有一百九十八元，默认包含3个域名记录，可以付费增添之250个域名记录。这款多域名SSL证书属于入门级，因此申请流程比较简单，只需要提交CSR之后验证域名所有权就可以在5分钟内签发证书。这款多域名SSL证书申请速度快、性价比高，比较适合个人或者中小型企业开发者。
3.Sectigo旗下的OV企业型多域名SSL证书和EV增强型所域名SSL证书审核流程比较严格，只支持企事业单位申请。申请时不仅需要验证域名所有权，还需要验证申请主体的真实性，审核时间较长，但是Sectigo的OV多域名SSL证书和EV多域名SSL证书加密强度较高，特点也比较明显。OV多域名SSL证书可以携带申请主体的部分信息，EV多域名SSL证书可以在它保护的所有域名网站的地址栏显示企业名称，这些特点可以帮助用户识别真机网站，提高信任度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56c6bf58de727f6debbb856d0e79eb65/" rel="bookmark">
			麒麟系统安装docker、mysql、clickhouse
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查看麒麟系统版本信息
cat /etc/os-release
麒麟系统版本V10
64位操作系统
# uname -p
x86_64
# uname -p
aarch64
内核版本
# uname -r
4.19.90-24.4.v2101.ky10.x86_64
本操作为麒麟系统版本V10，x86_64操作系统
一，安装docker
文件：
docker-compose-linux-x86_64
docker-19.03.0.tgz
arm下载地址：
Index of linux/static/stable/aarch64/
deb下载地址（我们下载这个）：
https://download.csdn.net/download/weixin_60748184/88717628?spm=1001.2014.3001.5503
https://download.csdn.net/download/CSDNCDN/87704041
Index of /NS/V10/V10SP1/os/adv/lic/base/x86_64/Packages/
1、将docker-compose-linux-x86_64拷贝到/usr/local/bin并重命名为docker-compose cp docker-compose-linux-x86_64 /usr/local/bin/docker-compose chmod 777 /usr/local/bin/docker-compose 2、解压压缩包docker-19.03.0.tgz并移动到/usr/bin下 tar -zxvf docker-19.03.0.tgz cp -p docker/* /usr/bin/ cp docker.service /usr/lib/systemd/system/ cp containerd.service /usr/lib/systemd/system/ cp docker.socket /usr/lib/systemd/system/ chmod +x /usr/lib/systemd/system/docker.service 5.文件生效 systemctl daemon-reload 6.设置开机启动 systemctl enable docker 7.启动docker systemctl start docker 8、查看docker版本 docker -v 9、查看docker-compose版本 docker-compose -v 删除docker
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56c6bf58de727f6debbb856d0e79eb65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d9e0db2a8406b4bec8a6988d45d5744/" rel="bookmark">
			H3C配置远程登录（console、telnet、ssh）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 介绍
2. 用console口登录交换机并配置
3. 创建本地用户
4. 本地用户能够通过telnet、SSH登录
1. 介绍 新交换机，通过Console口进入交换机，配置Console登录密码，并创建用户，退出Console登录后，用户通过远程（Telnet、SSH）登录交换机。
交换机为H3C S5130 V7
[test]dis version H3C Comware Software, Version 7.1.070, Release 6126P20 Copyright (c) 2004-2018 New H3C Technologies Co., Ltd. All rights reserved. H3C S5130S-28P-EI uptime is 0 weeks, 2 days, 3 hours, 23 minutes Last reboot reason : User reboot Boot image: flash:/s5130s_ei-cmw710-boot-r6126p20.bin Boot image version: 7.1.070, Release 6126P20 Compiled Apr 03 2018 11:00:00 System image: flash:/s5130s_ei-cmw710-system-r6126p20.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d9e0db2a8406b4bec8a6988d45d5744/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/711d2d697874c195baad53fbb8d68aa6/" rel="bookmark">
			给Flutter &#43; FireBase 增加 badge 徽章，App启动器 通知红点。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在此之前需要配置好 firebase 在flutter 在项目中。（已经配置好的可以忽略此提示）
Firebase 配置教程：flutter + firebase 云消息通知教程 (android-安卓、ios-苹果)_flutter firebase_messaging ios环境配置-CSDN博客
由于firebase 提供的消息通知测试只能做简单设置。所以这里需要自己搭建一个服务。
一、测试服务器搭建： 1. 来到 fireBase 控制台，进入需要搭建的项目。（生成私钥）
2.服务器环境-&gt; 向特定设备发送消息
官方文档给了六种服务器配置信息。以下例子采用 NestJs 进行快速搭建一个服务器。（搭建过程忽略）IDE使用的 Vscode。
在搭建好的项目中 安装 firebase-admin 依赖 (Linux, MacOs 命令前需要加 sudo 提高权限)
npm i firebase-admin 把上面在firebase 生成私钥 json 文件 复制到src文件夹下 并在service中引用。
Service 代码 ：(NestJs)
FireBase 官方例子比较老旧 许多Api 已经更改，需要注意。
可以直接在 NestJs 代码中，Ctrl + 点击的方法进到 TypeScript 的类型声明文件中，查看相关Api 或者去官网查看相关已经废弃和新版Api。
官网Api参考连接：https://firebase.google.com/docs/reference/admin/node/firebase-admin.messaging.messaging.md?hl=zh-cn#messagingsend
import { Injectable } from '@nestjs/common'; import * as admin from 'firebase-admin'; import * as serviceAccount from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/711d2d697874c195baad53fbb8d68aa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/985da95c4b549cf51202759c728539c7/" rel="bookmark">
			用bat 命令 修改sql文件中的数据库名字 新的名字通过读取配置文件中的字段获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在批处理脚本中，如果新数据库名存储在配置文件（比如config.ini）中的某个字段内，可以按照以下步骤进行：
假设你的配置文件内容如下：
Ini [Database] newName=myNewDB 要读取这个值并用于替换.sql文件中的旧数据库名，请使用以下批处理脚本：
Batch @echo off setlocal enabledelayedexpansion :: 读取配置文件中的新数据库名 for /f "tokens=2 delims==" %%a in ('findstr /b "newName=" config.ini') do ( set "NEW_DB_NAME=%%a" ) :: 遍历所有.sql文件并替换数据库名 for /r %%i in (*.sql) do ( echo Processing file: %%i type "%%i" &gt; "temp.tmp" for /f "delims=" %%j in ('type "temp.tmp"') do ( set "line=%%j" set "line=!line:oldDBName=%NEW_DB_NAME%!" echo.!line! &gt;&gt; "new_%%i" ) del "%%i" ren "new_%%i" "%%i" ) del "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/985da95c4b549cf51202759c728539c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7c47584b0906a122f64cba12a908e35/" rel="bookmark">
			MathType7.6安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.软件介绍 MathType是一款可以帮助用户快速完成数学公式编辑的应用软件，这款软件适合在进行教育教学、科研机构、论文写作的时候使用。我们可以直接通过这款软件来获取到大量数学上使用到的函数、数学符号等内容，然后使用这些内容来完成公式编辑。
不管是学生、老师还是理科专业工作者，都可以通过使用MathType来编辑数学试卷、书籍、报刊、论文等多种不同的内容。另外这款软件还能够对公式的字体颜色、字体大小进行调整，从而让你编辑的数学公式在格式上能够更加的规范。
2.软件下载 评论区留邮箱即可
3.安装步骤 1.下载并解压缩
2.双击MathType-win-zh-7.6.0.156.exe安装MathType；
3.打开Crack文件夹，复制MathType.exe到安装文件夹（默认为C:\Program Files (x86)\MathType)
4.复制到下方文件夹即可破解
安装完成后Mathtype会自动嵌入到word中，如果在word上方加载项未发现Mathtype，使用下面的方法嵌入即可：
1、首先查看word是32位还是64位（电脑系统是64位office不一定是哦），查看方法：打开word-文件-账户-关于word中就会显示；
2、接下来分别复制
MathType的安装路径 \MathPage\32\MathPage.dll
MathType的安装路径 \Office Support\32\MathType Commands 2016.dotm
将这两个文件复制到office的安装路径，默认路径为C:\Program Files (x86)\Microsoft Office\root\Office16\STARTUP\文件夹下；
3、最后打开word，就会在上方加载项看到MathType的加载项，选择内联便可进行公式编写啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9500ab2d8e7c30d535ef46d438a2d332/" rel="bookmark">
			7 集中式日志和分布式跟踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 日志聚合模式日志集中化的简单解决方案使用日志并输出分布式跟踪Spring Cloud Sleuth实现分布式跟踪 小结 前面的文章： 1、 1 一个测试驱动的Spring Boot应用程序开发 2、 2 使用React构造前端应用 3、 3 试驱动的Spring Boot应用程序开发数据层示例 4、 4 向微服务架构转变 5、 5 转向事件驱动的架构 6、 6 网关和配置服务器 代码：下载
前面的系统中已经涉及几个组件生成的日志（Multiplication、Gamification、Gateway、Consul、RabbitMQ），其中某些组件可能有多个实例，很多日志输出是独立运行的，很难获得系统活动的整体视图。如果用户报告错误，很难找出哪个组件或实例出现故障。在一个屏幕上安排多个日志窗口会有用，但当微服务实例数量增加时，这就不是那么容易解决的了。
要很好地维护像微服务架构这样的分布式系统，需要一个中心位置，在那里可以访问所有聚合日志并进行搜索。
日志聚合模式 通常是将所有的日志输出从应用程序发送到另一个组件，该组件将它们聚合在一起，另外，希望日志能保留一段时间，因此，需要数据存储功能。理想情况下，应该能够浏览这些日志，搜索并过滤每个微服务、实例、类等信息，为此，许多工具提供了一个用户界面，用于连接到聚合日志存储。如图所示：
Gamification Multiplication Gateway 分析/查询/过滤 发送日志 发送日志 发送日志 集中式日志 日志聚合 过滤和搜索 日志记录代理 日志记录代理 日志记录代理 用户 实现集中式日志记录时，最好的做法是应用程序逻辑不逻辑此模式，服务应该只使用公共接口来输出消息，将这些日志传送到中央聚合器的日志记录代理独立工作，捕获应用程序产生的输出。
现在有这种模式的多种实现，包括免费和付费的解决方案，其中最受欢迎的是ELK堆栈：Elasticsearch、Logstash和Kibana。
随着时间的推移，建立ELK堆栈已经越来越容易，但仍然不是一项容易的任务，这里不使用ELK实现，就不做介绍了。
日志集中化的简单解决方案 要实现集中式日志处理，需要建立一个新的微服务，来汇总来自Spring Boot应用程序的日志，为了简单起见，不用数据层来保存日志，只接收来自其他服务的日志，并输出到标准输出中。这种方案有助于实现分布式跟踪。
要实现日志输出，需要使用已有的工具RabbitMQ，要捕获应用程序中的每个日志记录行并以RabbitMQ消息的形式发送，因为Spring Boot一直使用Logback，不需要修改应用程序中的代码，就可以由外部配置文件驱动。
在Logback中，将日志行写入特定目标的逻辑部分称为附加程序，此日志记录库包含一些内置的附加程序，用于将消息输出到控制台（ConsoleAppender）或文件（FileAppender和RollingFileAppender）。不需要配置，因为Spring Boot在其依赖项中包含了一些默认的Logback配置，还设置了输出的消息格式。
Spring AMQP提供了一个Logback AMQP日志记录附加程序，可以满足其需要，该附加程序接收每一行日志并为RabbitMQ中的给定交换生成一条消息，其中包含格式和其他一些自定义的选项。
首先准备要添加的Logback配置。Spring Boot可以在应用程序资源文件夹（src/main/resources）中创建一个logback-spring.xml文件来扩展默认值，该文件将在应用程序初始化时自动获取。AMQP附加程序文档列出了所有参数及其含义：
applicationId：Application ID — 应用ID - 如果 pattern 包括 %X{applicationId}，则添加到 routing key 中。将其设置为应用程序名称，便于在汇总日志时区分源。host：连接到的RabbitMQ主机。由于环境的不同，将该值连接到spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9500ab2d8e7c30d535ef46d438a2d332/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dc57779b31718989bd4fa1b64ccb296/" rel="bookmark">
			从假数据到动态表格：一个简单的JavaScript和HTML示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景介绍 在Web开发中，我们经常需要处理和展示数据。有时，这些数据是真实的，但有时它们可能是假的（例如，为了演示或测试目的）。本文将向您展示如何使用假数据创建一个动态的HTML表格，并使用JavaScript为其添加交互功能。
二、创建假数据 首先，我们需要一些假数据。在JSON格式中，我们可以创建一个简单的对象，其中包含多个项目，每个项目都有一个ID、名称和类型。以下是一个示例：
{ "items": [ { "id": 1, "name": "Item 1", "type": "Type A" }, { "id": 2, "name": "Item 2", "type": "Type B" }, // ... 更多数据 ] } 三、创建HTML表格 接下来，我们需要创建一个HTML表格来显示这些数据。在表格中，我们为每个项目添加一个行（&lt;tr&gt;），其中包含三个单元格（&lt;td&gt;）：一个用于显示ID，一个用于显示名称，另一个用于显示类型。
由于我们希望每页显示10条数据，我们将在JavaScript中实现分页逻辑。同时，我们还将添加一个搜索框、一个重置按钮和两个筛选按钮，以允许用户根据名称和类型筛选数据。
首先，我们需要一个HTML文件来布局表格和按钮。这里是一个简单的HTML模板：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;假数据表格&lt;/title&gt; &lt;link rel="stylesheet" href="styles.css"&gt; &lt;!-- 引入CSS样式表 --&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="text" id="search-input" onkeyup="filterTable()" placeholder="搜索名称"&gt; &lt;!-- 搜索框 --&gt; &lt;button onclick="resetFilter()"&gt;重置&lt;/button&gt; &lt;!-- 重置按钮 --&gt; &lt;button onclick="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dc57779b31718989bd4fa1b64ccb296/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/160f3f30727d0a1f10e7045c0bf57247/" rel="bookmark">
			36-javascript输出方式，弹框：普通，confirm弹框，prompt弹框，控制台输出：普通，warm，error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.页面打印
&lt;body&gt; &lt;p&gt;你真是一个小机灵鬼&lt;/p&gt; &lt;script&gt; // 页面打印 document.write("打印内容"); &lt;/script&gt; &lt;/body&gt; 2.覆盖文档 &lt;body&gt; &lt;p&gt;你真是一个小机灵鬼&lt;/p&gt; &lt;script&gt; // 覆盖文档 window.onload = function(){ document.write("aaa"); } &lt;/script&gt; &lt;/body&gt; 3.普通弹框
&lt;body&gt; &lt;script&gt; // 普通弹框 alert ("输出的内容"); // var num = 0; // alert("输出的内容"); //输出的内容 // alert("num"); //num // alert(num); //0 &lt;/script&gt; &lt;/body&gt; 4.确认弹框
&lt;body&gt; &lt;script&gt; // 确认弹框 var a = confirm("确定吗？你要删除"); alert(a); &lt;/script&gt; &lt;/body&gt; 5.可输入内容的弹窗
&lt;body&gt; &lt;script&gt; //可输入内容的谈框 var a = prompt("请输入你的年纪"); &lt;/script&gt; &lt;/body&gt; 6. 控制台输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/160f3f30727d0a1f10e7045c0bf57247/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd79d5d9665d75b08a184d2d9d569e11/" rel="bookmark">
			Python查询MySQL字段有单引号报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Python中，当我们使用pymysql库与MySQL数据库交互时，可能会遇到查询含有单引号的字段时出现错误的情况。下面我们将详细讨论这个问题以及如何解决它。
问题描述 假设你有一个MySQL数据库表，其中有一个字段名为'single's quote，如果你直接使用这个字段名进行查询，很可能会遇到问题。
首先，确保你已经安装了pymysql库。如果还没有安装，可以通过pip进行安装：
pip install pymysql 接下来，我们将使用pymysql连接到MySQL数据库并进行查询。
示例代码 import pymysql # 连接到MySQL数据库 db = pymysql.connect(host='localhost', user='yourusername', password='yourpassword', database='yourdatabase') cursor = db.cursor() # 错误的查询方式，会导致报错 # query = "SELECT * FROM yourtable WHERE 'single's quote = 'some value'" # cursor.execute(query) # result = cursor.fetchall() # print(result) # 正确的查询方式，使用反引号(`)转义字段名 query = "SELECT * FROM yourtable WHERE `single's quote` = 'some value'" cursor.execute(query) result = cursor.fetchall() print(result) 解决方案：使用反引号(`)转义字段名 在MySQL中，你可以使用反引号(`)来转义字段名或表名。修改上面的代码，使用反引号转义字段名：
在字段名两侧加上反引号(`)。确保你的查询语句中的其他部分正确处理了单引号。执行查询并获取结果。 总结与注意事项 当你在Python中使用pymysql与MySQL交互时，遇到含有特殊字符的字段名时，需要特别注意SQL语句的构造和转义规则。使用反引号(`)来转义字段名或表名是一个有效的解决方法。为了代码的简洁和可维护性，尽量避免在字段名中使用特殊字符。如果可能的话，考虑使用下划线(_)代替单引号(‘)命名字段。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/951e91daf2a52bd5c0bbf8f7340e95d1/" rel="bookmark">
			「微服务」企业微服务架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，来自Darren的消息是，微服务架构并不是构建大规模企业应用程序的新方式。Netflix和亚马逊等公司已经实施了微服务架构，在过去几年中提供了成功的产品。
但是微服务架构适合您的组织吗？答案不是简单的是或否，但我会尝试用Darren的讲话作为指导来引导你找到答案。
微服务架构是一个将在多个方面影响您的组织的旅程 - 在文化，技术和运营方面。让我们考虑一个跨国企业的单体应用程序，该应用程序已经成熟多年并占据了市场主导地位。从软件工程师或架构师的角度来看，简化代码库的复杂区域以使其更易于维护是一种很好的做法。
那么当你遇到一个疯狂的大型Java类时，你会怎么做，这些Java类包含许多代码行和一个不幸的方法，占40％的类？一个自然（和明智）的事情是与团队进行某种形式的讨论，并提出一种策略，将类分解为多个较小的类和/或方法。现在问问自己为什么清理整体Java类很重要？
如果您的答案是更简单的单元测试，更容易进行代码审查，更改影响，那么我建议您将相同的思维过程应用于构成产品的整体服务和模块。
将monolith应用程序拆分为更小，可管理的服务有几个原因。如果您是组织中的业务负责人，以下可能是您的一些担忧：
进入新市场
支持创新
在业务功能和系统之间创建更好的一致性
改变治理结构以更好地支持快速决策
快速响应新的市场条件
抵御市场颠覆者
作为首席技术官或首席架构师，您有责任评估最能解决上述问题的不同解决方案，并设计符合组织愿景的系统。以下是在考虑微服务架构时需要关注的一些关键领域：
多种服务之间的依赖关系管理
端到端功能测试的大小
快速检测故障，正常故障并快速恢复
容器作为构建工件
跨组织边界重用组件/模块
公共使用服务的API合同
监控部署生命周期的各个阶段
集中式架构团队与分散式架构团队
构键自动化
架构师的角色随着微服务的采用而发展，并委托他或她承担挑战性的责任，从而形成架构治理。架构治理是组织尝试开始微服务之旅的关键因素之一，因为如果没有正确的顺序，该过程将很快导致微管理而不是微服务。
将monolith分成多个可管理服务的最大优势之一是使一个小团队能够全面管理其服务的生命周期 - 开发，测试和推向生产。这意味着企业架构师不再需要承担单个服务的内部工作负担，而是高度关注整个系统中服务之间的交互。此外，架构师应密切关注系统的整体运行状况，以确保每项服务以一致的方式生成与监控相关的指标。
为开发团队提供完全的权限，以便在构建服务时选择他们选择的技术堆栈并不意味着架构师不再对其实现有任何发言权。事实上，架构师受到高度鼓励，可以教育和影响开发团队。例如，考虑到服务必须处理的数据的高度非结构化特性，架构师可以建议使用NoSQL数据库而不是关系数据库。例如，Netflix将JVM的使用标准化为一个平台，以便他们可以跨服务使用标准库。
虽然架构师之一忙于与开发团队合作，但另一个人正在与“业务”团队合作，以使技术愿景与业务愿景保持一致。这对于建筑师来说是一个重要特征，因为系统需要能够适应产品愿景或用户反馈的变化。因此，架构师需要始终掌握行业中的最新趋势，工具和框架，并准备好为给定的工作应用正确的工具。
Darren谈到了“部署耦合”的概念，强调了许多单片系统和传统企业架构需要在单个版本中将所有系统的更改同步到生产中这一事实。这反过来导致长时间运行的测试周期从未捕获任何东西，并且感觉没有人可以失败，因为一个系统未达到其截止日期意味着其他所有人都被推出。
通过使用远程调用作为集成服务的机制，可以避免部署耦合。微服务社区建议使用REST over HTTP而不是其他远程通信协议（如RPC或SOAP），因为基于非HTTP的协议往往会将您绑定到特定平台或对互操作性施加限制。通过基于用户级合同使用HTTP集成服务，开发团队可以避免永无止境的端到端测试阶段的陷阱并保持合适的速度。
然而，管理数百个服务会使组织的操作复杂化。作为一个组织，您必须确保拥有可靠的DevOps基础架构，以便处理应用程序监视和警报。正如我上面提到的，架构师必须至少标准化服务发出日志的方式，以便运营团队可以监控整体系统运行状况，并且如果需要进一步调查，则能够深入到服务级别监控。
最后，每个组织都必须努力招募，培训和留住高素质的技术人员，因为“微观团队”之间的沟通和协作需要有效，技术上的刺激以及最重要的乐趣是至关重要的！
我希望这可以解决你对大型企业中微服务架构的一些担忧。我鼓励你观看这个非常有见地的视频录制，其中Darren更详细地讨论了这些非常关注的问题。
本文 :https://architect.pub/micro-service-architecture-enterprise-microservice-architecture讨论：知识星球【首席架构师圈】或者加微信小号【ca_cto】或者加QQ群【792862318】公众号
【jiagoushipro】
【架构师酒馆】
精彩图文详解架构方法论，架构实践，技术原理，技术趋势。
我们在等你，赶快扫描关注吧。微信小号
【ca_cea】
50000人社区，讨论：企业架构，云计算，大数据，数据科学，物联网，人工智能，安全，全栈开发，DevOps，数字化.
QQ群
【285069459】深度交流企业架构，业务架构，应用架构，数据架构，技术架构，集成架构，安全架构。以及大数据，云计算，物联网，人工智能等各种新兴技术。
加QQ群，有珍贵的报告和干货资料分享。
视频号【架构师酒馆】
1分钟快速了解架构相关的基本概念，模型，方法，经验。
每天1分钟，架构心中熟。
知识星球【首席架构师圈】向大咖提问，近距离接触，或者获得私密资料分享。
喜马拉雅【超级架构师】路上或者车上了解最新黑科技资讯，架构心得。【智能时刻，架构君和你聊黑科技】知识星球认识更多朋友，职场和技术闲聊。知识星球【职场和技术】微博【架构师酒馆】智能时刻哔哩哔哩【架构师酒馆】
抖音【cea_cio】架构师酒馆
快手【cea_cio_cto】架构师酒馆
小红书【cea_csa_cto】架构师酒馆
网站CIO(首席信息官)https://cio.ceo网站CIO,CTO和CDOhttps://cioctocdo.com网站架构师实战分享https://architect.pub 网站程序员云开发分享https://pgmr.cloud官网行天智能科技咨询公司https://xingtian.ai网站开发者闲谈https://blog.developer.chat网站首席隐私官内参https://cpo.work网站首席安全官内参https://cso.pub 网站CIO内参https://cio.cool网站CDO内参https://cdo.fyi网站CXO内参https://cxo.pub网站首席架构师社区https://jiagoushi.pro 谢谢大家关注，转发，点赞和点在看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18a87fe2a104d1ecbe3203adc77754fc/" rel="bookmark">
			Tsmaster使用笔记整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择厂商 根据你所选择的CAN分析仪的厂商，确定你的厂商设备设置。
我一般会选择PEAK，和 ZLG多一点，其他的没有用过。除了上图中的，市面上的CAN分析仪还有CANanlyst、广成科技、创芯科技等，但它们都不能在Tsmaster上使用。在汽车报文采集仪器上，金钱是个蛮重要的因素，Tsmaster是相对功能很全面的报文分析软件，但是它的硬件价格相对较高。
PEAK的价格在2100元左右（2023年），ZLG大概在3900元左右。
配置通道数量和硬件通道选择 读报文 在上图的步骤2选择CAN/CAN FD报文信息。
总线记录也是个很好的功能，当你没有办法长期在车上边采集边观察报文时，可以点击总线记录，然后以txt格式保存，再复制到excel里进行分析。
发报文 上图的步骤2中，是从数据库添加报文，此处会打开CAN数据库，链接到我们事先做好的dbc文件上。一个数据库可能有多个虚拟模块，比如说，热管理BMS，整车控制IP等。我们会先在左侧的逻辑通道中选择虚拟模块，再在右侧选择相应的报文添加进发送页面。
然后来看下图，Tsmaster最好用的功能之一，就是，可以选择每个发送行的发送周期（也可以只发送一次，模拟冲激信号）。然后，可以以比特为单位设置每比特的值，假设一帧报文是8个字节，那么8个字节可能被分为多个信号，每个信号占不等长的字节长度，Tsmaster就会根据你dbc数据库的定义，将各个信号在发送行的详细页面给逐个分好，你可以根据注释非常直观地看到每个字节或者每两个字节代表什么含义。
同时，最方便的是，那种选项式的信号，Tsmaster可以直接识别选项有哪些，通过下拉框去选择中文选项，譬如红绿灯，那就是“红黄绿”，而不是“0x0, 0x1, 0x2”，再需要你看dbc数据库里人为的定义。
发送报文还有一种情况，就是发的报文，dbc数据库没有怎么办，此时可以选择
添加新的原始报文，然后手动输入报文名称，报文标识符，和各个字节的值。
更多花里胡哨的功能以后用到再更新……
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bf32552dbaf5ccd5900bde6f12091b0/" rel="bookmark">
			计算机Java项目｜基于SSM的计算机考试系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者主页：编程指南针
作者简介：Java领域优质创作者、CSDN博客专家 、CSDN内容合伙人、掘金特邀作者、阿里云博客专家、51CTO特邀作者、多年架构师设计经验、腾讯课堂常驻讲师
主要内容：Java项目、Python项目、前端项目、人工智能与大数据、简历模板、学习资料、面试题库、技术互助
收藏点赞不迷路 关注作者有好处
文末获取源码 项目编号：L-BS-ZXBS-14 一，环境介绍 语言环境：Java: jdk1.8
数据库：Mysql: mysql5.7
应用服务器：Tomcat: tomcat8.5.31
开发工具：IDEA或eclipse
二，项目简介 随着网络不断的普及发展，计算机考试系统设计依靠网络技术的支持得到了快速的发展，首先要从学生的实际需求出发，通过了解学生的需求开发出具有针对性的管理系统，利用目前网络给学生带来的方便快捷这一特点对系统进行调整，设计的系统让学生使用起来更加方便，本系统的主要目的就是给学生带来方便与快捷，学生只要在家中就可以进行在线考试[1]。同时随着电子商务的发展网上计算机考试系统设计已经受到广大学生的关注。
互联网发展至今，已经解决了很多我们解决不了的难题，使得我们工作更加便捷，提高了我们的工作效率。目前各行各业都在运用网络信息管理程序，不同的学生也都接触到信息管理，特别是在各大电商行业广泛的应运起来。通过对当前网络环境发展的分析与总结，开发计算机考试系统设计可以改变以往的手工统计方式，改变传统线下计算机考试系统设计的状态，由于学生的不断增多，使用传统的线下手工统计模式已经远远不能满足于学生需求了，而且越来越多的学校也在开通线上进行考试，所以开发一个计算机考试系统设计可以解决不利于线下考试的问题，同时管理员可以利用网络对计算机考试系统设计信息进行管理，设计的网站保证信息的完整安全，这样才能提高工作效率，保证系统安全正常的运行[2]。
本计算机考试系统设计主要包括二大功能模块，即管理员功能模块和学生功能模块。
（1）管理员模块：系统中的核心用户是管理员，管理员登录后，通过管理员功能来管理后台系统。主要功能有：个人中心、学生管理、考试科目管理、考试成绩统计管理、试题管理、管理员管理、试卷管理、考试管理等功能。管理员用例图如图3-1所示。
图3-1　管理员用例图
（2）学生：个人中心、考试科目管理、考试管理等功能，学生如图3-2所示。
图3-2 学生用例图
登录流程
登录模块主要满足管理员以及学生的权限登录，学生登录流程图如图3-3所示。
图3-3登录流程图
注册流程
未有账号的学生可进入注册界面进行注册操作，学生注册流程图如图3-4所示。
图3-4 注册流程图
添加信息流程
学生在添加信息时，信息编号自动生成，系统会对添加的信息进行验证，验证通过则添加至数据库，添加信息成功，反之添加失败。添加信息流程如图3-5所示。
图3-5 添加信息流程图
删除信息流程
学生可选择要删除的信息进行信息删除操作，在删除信息时系统提示是否确定删除信息，是则删除信息成功，系统数据库将信息进行删除。删除信息流程图如图3-6所示。
图3-6删除信息流程图
三，系统展示 管理员功能模块
管理员登录，通过填写注册时输入的用户名、密码、角色进行登录，如图5-1所示。
图5-1管理员登录界面图
管理员登录进入计算机考试系统设计可以查看个人中心、学生管理、考试科目管理、考试成绩统计管理、试题管理、管理员管理、试卷管理、考试管理等信息。
学生管理，在学生管理页面中可以通过填写考生编号、密码、考生姓名、性别、出生日期、联系电话、身份证、邮箱等内容进行修改、删除，如图5-2所示。还可以根据需要对考试科目管理进行详情，修改或删除等详细操作，如图5-3所示。
图5-2学生管理界面图
图5-3考试科目管理界面图
试题管理，在试题管理页面中可以填写试卷、试题、类型、答案、分数等信息，并可根据需要对已有试题管理进行修改或删除等操作，如图5-4所示。
图5-4试题管理界面图
管理员管理，在管理员管理页面中可以填写用户名、密码、角色等信息，并可根据需要对已有管理员管理进行修改或删除等详细操作，如图5-5所示。
图5-5管理员管理界面图
试卷管理，在试卷管理页面中可以查看试卷名称、考试时长、试卷状态等内容，并且根据需要对已有试卷管理进行详情，修改或删除等详细操作，如图5-6所示。
图5-6试卷管理界面图
考试成绩统计管理，在考试成绩统计管理页面中可以查看科目编号、考试名称、最高分、最低分、平均分等内容，并且根据需要对已有考试成绩统计管理进行详情，修改或删除等详细操作，如图5-7所示。
图5-7考试成绩统计管理界面图
错题本，在错题本页面中可以查看用户ID、试卷、试题、分值、正确答案、考生答案、试题分析、考试时间等内容，并且根据需要对已有错题本进行详情，修改或删除等详细操作，如图5-8所示。
图5-8错题本界面图
5.2学生功能模块
学生登录进入计算机考试系统设计可以查看个人中心、考试科目管理、考试管理等内容。
注册，在注册页面中通过填写考生编号、考生姓名、联系电话、身份证、邮箱等信息进行修改、删除如图5-9所示。
图5-9注册界面图
考试科目管理，在考试科目管理页面中可以查看科目编号、考试名称、考试时间等信息内容，并且根据需要对已有考试科目管理进行修改或删除等其他详细操作，如图5-10所示。
图5-10考试科目管理界面图
试卷列表管理，在试卷列表管理页面中通过填写试卷、考试时间等内容进行修改、删除，如图5-11所示。
图5-11试卷列表管理界面图
考试记录管理，在考试记录管理页面中通过填写用户、试卷、试题名称、分值、正确答案、考生答案、考生分值、考试时间等内容进行修改、删除，如图5-12所示。
图5-12考试记录管理界面图
四，核心代码展示 五，相关作品展示 基于Java开发、Python开发、PHP开发、C#开发等相关语言开发的实战项目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bf32552dbaf5ccd5900bde6f12091b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e83799607ae491250237d07c2782a2b7/" rel="bookmark">
			【Electron】 Vite项目 初始配置 scss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 pnpm add -D sass
src下面创建 styles/main.scss 文件
mian.ts 内引入 ./styles.scss 文件
import './styles/main.scss' 测试scss是否生效：
styles/mian.scss
:root{ --mian:red; } App.vue
&lt;template&gt; &lt;div&gt;你好&lt;/div&gt; &lt;/template&gt; &lt;style lang="scss" scoped&gt; div { color: var(--mian); } &lt;/style&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/399def33d0efcdd80b718a2f8997b741/" rel="bookmark">
			使用Trie数据结构实现搜索自动完成功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文旨在讨论使用 Java 的搜索自动完成的低级实现，将Trie在用例中使用数据结构。
这是一个示例TrieNode类：
class TrieNode{
Map&lt;Character,TrieNode&gt; children;
boolean isEndOfWord;
TrieNode(){
children = new HashMap&lt;&gt;();
isEndOfWord = false;
}
}
请注意，我们在这里使用 Map 来存储 Trie 中特定层级的所有字符。
如果问题是按字母顺序返回结果，那么我们别无选择，只能使用 TreeMap，能确保顺序，但会在插入和搜索时耗费时间，因为 TreeMap 查找/插入将耗费 log(n) 时间。
在本文中，我们假设可以按任意顺序返回结果，以使事情变得简单。
另外，假设我们有来自后台的缓存响应。我们可以将其作为自动完成任务的单词来源。让这个输入是单词，假设我们正在搜索一个单词 searchWord 。因此，方法定义可归结为以下内容：
public List suggestedWords(String[] words, String searchWord) { for (String word: words) { insert(word); // insert to Trie } return search(searchWord); // search in Trie and return results } 方法 insert(String word) 可以在 Trie 中插入单词。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/399def33d0efcdd80b718a2f8997b741/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b950fbe844d186e8fdbfc2e148b0eb6b/" rel="bookmark">
			rockscache：保证与DB最终或强一致性的Redis缓
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着缓存的引入，分布式系统中的一致性问题出现了，因为数据同时存储在两个地方：数据库和Redis。
到目前为止，我们看到的所有缓存解决方案，如果没有在应用程序级别引入版本控制，都无法解决数据不一致场景。目前还没有成熟的解决方案来保证最终一致性
即使您使用锁来进行更新，仍然存在可能导致不一致的特殊情况。
解决方案
现有的解决方案都没有完全解决该问题，但有多种选择。
设置稍短的过期时间：在这个过期时间内，会不一致。缺点是过期时间越短意味着数据库负载越高
双重删除：删除一次缓存，延迟几百毫秒再删除一次。这种做法只是进一步降低了不一致的概率，但并不是禁止的
在应用层引入类似版本的机制：应用层必须维护版本，因此这种方案限制了通用性并且不易重用
该项目为您带来了一种全新的解决方案，无需引入版本，即可保证缓存与数据库之间的数据一致性。该解决方案是同类解决方案中的首创，已获得专利，现已开源供所有人使用。
我们实现了名为“标记为已删除”的缓存策略，彻底解决了这个问题，确保缓存和数据库之间的数据保持一致。
解决原理如下：
缓存中的数据是具有以下字段的哈希。
值：数据本身
lockUtil：数据锁过期时间，当一个进程查询缓存没有数据时，则锁定缓存一小段时间，然后查询DB，然后更新缓存
所有者：数据锁uuid
查询缓存时。
如果数据为空并被锁定，则休眠100ms并再次查询
如果数据为空且未锁定，则同步执行“取数据”并返回结果
如果数据不为空，则立即返回结果，异步执行“取数据”
“获取数据”操作定义为
判断是否需要更新缓存，如果满足以下两个条件之一，则需要更新缓存 数据为空且未锁定数据锁定已过期 如果需要更新缓存，则锁定缓存，查询DB，如果验证锁持有者未更改，则更新并解锁缓存。
当DB数据更新时，通过dtm成功更新数据后，保证缓存被标记为已删除
TagAsDeleted 设置数据过期时间为10s，并设置锁过期，下次查询到缓存时会触发“取数据” 通过上述策略：
如果最后写入数据库的版本是Vi，最后写入缓存的版本是V，写入V的uuid是uuidv，那么一定有如下的事件序列：
数据库写入Vi -&gt; 缓存数据标记为已删除 -&gt; 某些查询锁定数据并写入uuidv -&gt; 查询数据库结果V -&gt; 缓存中的locker是uuidv，写入结果V在这个序列中，V的读取发生在Vi的写入之后，所以V等于Vi，保证了缓存数据的最终一致性。 dtm-labs/rockscache已经实现了上述方法，并且能够保证缓存数据的最终一致性。
Fetch函数实现了之前的查询缓存
TagAsDeleted函数实现“标记已删除”逻辑
当开发者Fetch在读取数据时调用，并确保TagAsDeleted在更新数据库后调用，那么缓存就可以保证最终的一致性。
dtm-labs致力于解决数据一致性问题，在分析业界现有实践后，提出了新的解决方案dtm-labs/dtm + dtm-labs/rockscache，彻底解决了上述问题。另外，该方案作为成熟的方案，还具有防渗透、防击穿、防雪崩的能力，也可以应用于需要强数据一致性的场景。
有关完整的可运行示例，请参阅dtm-cases/cache
背景
DB 和缓存操作的原子性
对于缓存管理，业界一般采用写入数据库后删除/更新缓存数据的策略。由于保存到缓存和保存到数据库操作不是原子的，必然存在时间差，因此两个数据之间会存在一个不一致的窗口，该窗口通常很小，影响也较小。然而，由于两项操作之间可能会出现停机和各种网络错误，因此有可能其中一项完成而另一项无法完成，从而导致长时间的不一致。
为了说明上面的不一致场景，数据用户修改了数据A到B。应用程序修改数据库后，然后删除/更新缓存，如果没有异常发生，那么数据库和缓存中的数据是一致的。
然而在分布式系统中，可能会出现进程崩溃和宕机事件，所以如果一个进程在更新数据库之后、删除/更新缓存之前崩溃，那么数据库和缓存中的数据可能会长时间不一致。
要彻底解决这里长时间的不一致并不是一件容易的事，因此我们在下面介绍各种解决方案。
解决方案一：设置较短的过期时间
这种方案是最简单的方案，适合低并发的应用。开发者只需将缓存的过期时间设置为一个较短的值，例如一分钟。这种策略非常容易理解和实现，并且缓存系统提供的语义使得大多数情况下缓存和数据库之间不一致的时间窗口很短。当进程崩溃时，不一致的时间窗口可能会持续一分钟。
对于这种解决方案，数据库应该能够在每分钟生成所有访问的缓存数据，这对于许多高并发的应用程序来说可能过于昂贵。
方案二：消息队列
这是由
更新数据库时，同时向本地表写入一条消息。这两个操作都在一个事务中。
编写一个轮询任务，不断轮询消息表中的数据，并将它们发送到消息队列。
消费消息队列中的消息并更新/删除缓存
这种方法可确保缓存始终在数据库更新后更新。但是这个架构非常繁重，这些部分的开发和维护成本都不低：消息队列的维护；开发和维护高效的轮询任务。
方案三：订阅Binlog
这个方案和场景2很相似，原理和数据库的主从同步类似，数据库的主从同步是通过订阅binlog并从master向slave应用更新来完成的，而这个解决方案是通过订阅 binlog 并将更新从数据库应用到缓存来完成。这是由
部署并配置debezium以订阅数据库的binlog
监听数据更新并同步更新/删除到缓存
这个方案也保证了数据库更新后缓存也会更新，但是和之前的消息队列方案一样，这个架构也很重。一方面，Debezium 的学习和维护成本较高，另一方面，开发人员可能只需要少量数据来更新缓存，订阅所有 binlog 来执行此操作是对资源的浪费。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b950fbe844d186e8fdbfc2e148b0eb6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b5cd57705c63f553e464ef6613a2df4/" rel="bookmark">
			【EAI 007】Mobile ALOHA：一个低成本的收集人类示教数据的双臂移动操作硬件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文标题：Mobile ALOHA: Learning Bimanual Mobile Manipulation with Low-Cost Whole-Body Teleoperation
论文作者：Zipeng Fu, Tony Z. Zhao, Chelsea Finn
作者单位：Stanford University, UC Berkeley, Meta
论文原文：https://arxiv.org/abs/2401.02117
论文出处：–
论文被引：–（01/05/2024）
项目主页：https://mobile-aloha.github.io/
论文代码：
硬件代码：https://github.com/MarkFzp/mobile-aloha软件代码：https://github.com/MarkFzp/act-plus-plus硬件拆解：link先前工作：https://tonyzhaozh.github.io/aloha/ Abstract 在机器人技术领域，从人类演示（human demonstrations）中进行的模仿学习（Imitation Learning，IL）已经取得了令人瞩目的成绩。然而，大多数成果都集中在桌面操作（table-top manipulation）上，缺乏一般有用任务所需的移动性和灵巧性。在这项工作中，我们开发了一套系统，用于模仿需要全身控制（whole-body control）的双臂移动操作任务。我们首先介绍了用于数据收集的低成本全身远程操作系统——Mobile ALOHA。它通过一个移动底座和一个全身远程操作界面增强了 ALOHA 系统[104]。利用Mobile ALOHA 收集的数据，我们进行了有监督的行为克隆，并发现与现有静态 ALOHA 数据集进行联合训练可提高移动操作任务的性能。通过对每个任务进行 50 次演示（demonstrations），联合训练可将成功率提高 90%，从而使 Mobile ALOHA 能够自主完成复杂的移动操作任务，例如炒虾并送到餐桌上，打开双门壁柜以存放沉重的烹饪锅，按电梯按键并进入电梯，以及使用厨房水龙头冲洗用过的平底锅。
1. Introduction 从人类提供的演示中进行模仿学习，是开发通用机器人的一个很有前途的工具，因为它允许人类向机器人传授任意技能。事实上，直接行为克隆可以让机器人学习各种原始的机器人技能，从移动机器人的车道跟随[67]，到简单的拾放操作技能[12, 20]，再到更精细的操作技能，如涂抹披萨酱或插入电池[18, 104]。然而，在现实的日常环境中，许多任务都需要移动和灵巧操作的全身协调，而不仅仅是单独的移动或操作行为。例如，考虑图 1 中将沉重的锅放入橱柜这一相对基本的任务。
机器人首先需要导航到橱柜，这就需要机器人底座的移动性。要打开橱柜，机器人需要后退，同时牢牢抓住两个门把手，这就需要全身控制。随后，双臂需要抓住锅的把手，一起将锅移入橱柜，这就强调了双臂协调的重要性。 与此类似，烹饪，清洁，家务管理，甚至是使用电梯在办公室中穿梭，都需要移动操作，而双臂的灵活性往往会让这些操作变得更加容易。在本文中，我们研究了将模仿学习扩展到需要双臂移动机器人全身控制的任务的可行性。
有两个主要因素阻碍了模仿学习在双臂移动操作中的广泛应用。
1）缺乏方便使用，即插即用的全身远程操控硬件。如果购买现成的双臂移动机械手，成本可能会很高。像 PR2 和 TIAGo 这样的机器人价格超过 20 万美元，一般的研究实验室难以承受。要在这些平台上实现远程操作，还需要额外的硬件和校准。例如，PR1 使用两个触觉设备进行双臂远程操作，并使用脚踏板控制底座[93]。之前的工作[5]使用动作捕捉系统将人类动作重定向到 TIAGo 机器人上，而 TIAGo 机器人只能控制单臂，需要仔细校准。游戏控制器和键盘也可用于远程操作 Hello Robot Stretch [2] 和 Fetch Robot[1]，但不支持双臂或全身远程操作。2）之前的机器人学习相关工作并未展示复杂任务的高性能双臂移动操作。虽然最近的许多研究表明，扩散模型和Transformer等表现力很强的策略类可以在细粒度，多模态操作任务中表现出色，但目前还不清楚同样的方法是否适用于移动操作：随着自由度的增加，手臂和基座动作之间的交互可能会变得复杂，基座姿势的微小偏差可能会导致手臂末端执行器姿势的大幅偏移。总之，无论是从硬件还是从学习的角度来看，之前的研究都没有为双臂移动操作提供实用且令人信服的解决方案。 在本文中，我们试图解决将模仿学习应用于双臂移动操作的难题。在硬件方面，我们提出了Mobile ALOHA，一种用于收集双体移动操作数据的低成本全身远程操作系统。Mobile ALOHA 通过将其安装在轮式底座上，扩展了原始 ALOHA 的功能，即低成本，灵巧的双臂 puppeteering 操作装置 [104]。然后，用户将身体拴在系统上，反向驱动车轮，使底座移动。这样，当用户双手控制ALOHA 时，底座可以独立移动。我们同时记录底座速度数据和手臂操作数据，形成一个全身远程操作系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b5cd57705c63f553e464ef6613a2df4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0f37d28ab8b3ebc0db33c92431f87c6/" rel="bookmark">
			数据结构 : 单向链表实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 经典的单向链表 , 需要考虑各种场景 , 实现较为复杂 , 在代码中有很多自己的注解不删除了 见谅
我由三个文件实现 , 分别是
头文件和声明 List.h实现功能的源码List.c测试链表功能的测试文件 Test.c List.h #pragma once #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; typedef int SLTDataType; typedef struct SListNode { SLTDataType data; struct SListNode* next; }SLTNode; void SLTPrint(SLTNode* phead); SLTNode* SLFind(SLTNode* phead, SLTDataType x); void SLPushFront(SLTNode** pphead, SLTDataType x); void SLPushBack(SLTNode** pphead, SLTDataType x); void SLpopFront(SLTNode** pphead); void SLpopBack(SLTNode** pphead); void SLInsert(SLTNode** pphead, SLTNode* pos, SLTDataType x); void SLInsertAfter(SLTNode* phead, SLTDataType x); void SLErase(SLTNode** pphead, SLTNode* pos); void SLEraseAfter(SLTNode* pos); void SLdestroy(SLTNode** pphead); List.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0f37d28ab8b3ebc0db33c92431f87c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c097d159808bf32b0e12d0c972b96ac5/" rel="bookmark">
			【代码复现系列】paper：CycleGAN and pix2pix in PyTorch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		或许有冗余步骤、之后再优化。
1.桌面右键-git bash-输入命令如下【git clone https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix】
2.打开anaconda的prompt，cd到pytorch-CycleGAN-and-pix2pix路径
3.在prompt里输入【conda env create -f environment.yml】配置虚拟环境及相应的包
4.在prompt里输入【conda activate pytorch-CycleGAN-and-pix2pix】激活虚拟环境
5.下载数据集。在github中说：
bash是linux命令，在win中，直接打开刚才下载的pytorch-CycleGAN-and-pix2pix文件夹找到datasets然后找到download_pix2pix_dataset.sh文件，记事本打开，找到url
打开http://efrosgans.eecs.berkeley.edu/pix2pix/datasets/
找到facades数据集下载
解压到pytorch-CycleGAN-and-pix2pix文件夹的datasets文件夹下
6.回到刚才的prompt，输入【pip install visdom】然后输入【python -m visdom.server】以便后续可视化运行结果
To view training results and loss plots, run python -m visdom.server and click the URL http://localhost:8097. 7.打开pycharm，左上角open，找到下载的pytorch-CycleGAN-and-pix2pix，然后open
8.右下角interpreter设置，调成虚拟环境：
9.点开pycharm左下角terminal，输入【python test.py --dataroot ./datasets/facades --name facades_pix2pix --model pix2pix --direction BtoA】
即可跑代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/773049d94694d5ca28f6b969aac36045/" rel="bookmark">
			903. 昂贵的聘礼（最短路，超级原点，Dijkstra）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		903. 昂贵的聘礼 - AcWing题库
年轻的探险家来到了一个印第安部落里。
在那里他和酋长的女儿相爱了，于是便向酋长去求亲。
酋长要他用 10000 个金币作为聘礼才答应把女儿嫁给他。
探险家拿不出这么多金币，便请求酋长降低要求。
酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要 8000 金币。如果你能够弄来他的水晶球，那么只要 5000 金币就行了。”
探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。
探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。
不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。
探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。
另外他要告诉你的是，在这个部落里，等级观念十分森严。
地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。
他是一个外来人，所以可以不受这些限制。
但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。
因此你需要在考虑所有的情况以后给他提供一个最好的方案。
为了方便起见，我们把所有的物品从 11 开始进行编号，酋长的允诺也看作一个物品，并且编号总是 11。
每个物品都有对应的价格 P，主人的地位等级 L，以及一系列的替代品 Ti 和该替代品所对应的”优惠” Vi。
如果两人地位等级差距超过了 M，就不能”间接交易”。
你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。
输入格式 输入第一行是两个整数 M，N，依次表示地位等级差距限制和物品的总数。
接下来按照编号从小到大依次给出了 N 个物品的描述。
每个物品的描述开头是三个非负整数 P、L、X，依次表示该物品的价格、主人的地位等级和替代品总数。
接下来 X 行每行包括两个整数 T 和 V，分别表示替代品的编号和”优惠价格”。
输出格式 输出最少需要的金币数。
数据范围 1≤N≤100,
1≤P≤10000
1≤L,M≤N
0≤X&lt;N
输入样例： 1 4 10000 3 2 2 8000 3 5000 1000 2 1 4 200 3000 2 1 4 200 50 2 0 输出样例： 5250 解析 ： 这道题目需要使用超级原点，这种做法在图论中经常使用，在本道题目中的用法为：设一个超级原点，是的超级原点到每个点的距离为购买本个物品的原始价格，图中其他边为优惠的价格，这样就可以使用Dijkstra算法得出最优解了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/773049d94694d5ca28f6b969aac36045/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e6007aef6eca302e46f32540a0c559b/" rel="bookmark">
			Redis基本原理和基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、基本原理
（一）非关系型数据库
（二）关系型数据库与非关系型数据库的区别
（三）Redis简介
1.什么是Redis
2.数据存储结构
3.默认端口号
4.数据类型
（1）五大基础类型
（2）三种特殊类型
（四）Redis优点
1.极高的数据读写速度
2.支持丰富的数据类型
3.支持数据的持久化
4.原子性
5.支持数据备份
（五）redis快的原因
二、部署Redis
（一）环境准备
（二）修改内核参数
（三）安装Redis
（四）修改配置文件
（五）定义systemd服务管理脚本
（六）启动服务
三、实操
（一）Redis 命令工具
（二）redis-cli 命令行工具
（三）redis-benchmark 测试工具
（四）Redis数据库常用命令
1.String（字符串）
2.List（列表）
3.Hash（哈希/散列）
4.Set（无序集合）
5.Zset/Sorted Set（有序集合）
6.通用
一、基本原理 （一）非关系型数据库 不需要预先建库建表定义数据存储表结构，每条记录可以有不同的数据类型和字段个数（比如微信群聊里的文字、图片、视频、音乐等）。
主流的 NoSQL 数据库有 Redis、MongBD、Hbase、Memcached、ElasticSearch、TSDB 等。
（二）关系型数据库与非关系型数据库的区别 关系型数据库（SQL）非关系型数据库（NOSQL）存储结构二维表格结构可以是文档、键值对、索引、时间序列等，不同类型数据库使用不同的存储结构扩展方式纵向扩展（提升硬件性能）横向扩展（增加服务器节点数量）事务支持基于ACID原则基于BASE原则典型代表MySQL、Oracle、SQL-server等Redis、MongBD、Hbase、Memcached、ElasticSearch、TSDB等 （三）Redis简介 1.什么是Redis Redis（远程字典服务器） 是一个开源的、使用 C 语言编写的、基于内存运行的 NoSQL 数据库
2.数据存储结构 键值对（Key/Value KV）
3.默认端口号 TCP的6379
4.数据类型 （1）五大基础类型 String（字符串） List（列表） Hash（哈希/散列）Set（无序集合）Zset/Sorted Set（有序集合） （2）三种特殊类型 HyperLogLogs（基数统计）Bitmaps (位图)geospatial （地理位置) （四）Redis优点 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e6007aef6eca302e46f32540a0c559b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02cf3a11de652f6f03818fc13c31a557/" rel="bookmark">
			c&#43;&#43;学习：容器list实战（获取目录返回容器list）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建一个dir.h,声明dir类 #ifndef DIR_H #define DIR_H #include &lt;sys/types.h&gt; #include &lt;dirent.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;iostream&gt; #include &lt;list&gt; class Dir { public: Dir(); static std::list&lt;std::string&gt; entryList(const char *dirPath, const char *filter); }; #endif // DIR_H 新建一个dir.cpp，定义dir类 #include "dir.h" Dir::Dir() { } std::list&lt;std::string&gt; Dir::entryList(const char *dirPath, const char *filter) { std::list&lt;std::string&gt; list; DIR * fp = opendir(dirPath); if(fp == NULL) { perror("opendir error"); return list; } while(1) { struct dirent * info = readdir(fp); if(info == NULL) { break; } if(info-&gt;d_type == DT_REG &amp;&amp; info-&gt;d_name[0] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02cf3a11de652f6f03818fc13c31a557/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/401649e03514ff0f7ece345299fbf3b8/" rel="bookmark">
			如何将Redis、Zookeeper、Nacos配置为Windows系统的一个服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：当我们在Windows上开发时，不可避免的会用到一些中间件，如Redis、Zookeeper、Nacos等等，当在项目中使用到本地的这些服务器时，我们需要把本地的服务器启动，会开启下面这样的一个窗口。
Redis服务器；
这样有几点不好的地方：1）服务器是窗口化，不好管理；2）重启电脑或关闭窗口后，服务器就关闭了，需要重启；
本文介绍如何将这些服务器配置为Windows的一个服务；
如下：
Redis 首先，配置Redis环境变量，将bin路径添加到环境变量中。然后，打开CMD命令，输入下面的命令；
redis-server --service-install redis.windows.conf 其中，redis.windows.conf为Redis目录下面的配置文件；
敲回车，如果出现下面的错误：
加上redis.windows.conf文件的全路径，如下，再敲回车；
redis-server --service-install D:\Program Files (x86)\Redis-x64-3.2.100\redis.windows.conf 路径不能有空格，将Redis目录换个没有空格的路径（当然环境变量也需要重新配置），再试；
redis-server --service-install D:\dev\Redis-x64-3.2.100\redis.windows.conf 敲完回车。打开CMD，输入services.msc，可查看到Redis服务，可选择启动/停止服务，可以设置为自动启动，这样开机就启动了；
打开CMD，输入redis-cli启动Redis客户端，能进入下面的界面，说明配置完成；
Zookeeper Zookeeper设置起来有一点麻烦，首先去下载一个插件，插件网站，选择最下面这个最新版本的。
解压后，将这两个启动程序拷贝到Zookeeper目录的bin文件夹下；
然后，配置两个环境变量；
ZOOKEEPER_HOME=zookeeper目录 ZOOKEEPER_SERVICE=zookeeper服务名，自定义 在zookeeper目录下的bin文件夹里，编写一个bat脚本，用来配置zookeeper服务器到windows里，如下：
prunsrv.exe "//IS//%ZOOKEEPER_SERVICE%" ^ --DisplayName="Zookeeper (%ZOOKEEPER_SERVICE%)" ^ --Description="Zookeeper (%ZOOKEEPER_SERVICE%)" ^ --Startup=auto --StartMode=exe ^ --StartPath=%ZOOKEEPER_HOME% ^ --StartImage=%ZOOKEEPER_HOME%\bin\zkServer.cmd ^ --StopPath=%ZOOKEEPER_HOME%\ ^ --StopImage=%ZOOKEEPER_HOME%\bin\zkServerStop.cmd ^ --StopMode=exe --StopTimeout=5 ^ --LogPath=%ZOOKEEPER_HOME% --LogPrefix=zookeeper-wrapper ^ --PidFile=zookeeper.pid --LogLevel=Info --StdOutput=auto --StdError=auto 在该目录下打开CMD，执行此文件，执行过程中会弹出是否启动程序的窗口，选择是。然后打开服务管理器，可以看到新增了一个Zookeeper服务；
启动服务后，同样打开Zookeeper的客户端，启动成功说明配置成功了；
Nacos 首先，去GitHub上下载一个工具，winsw工具，根据自己的操作系统下载。
下载完成后，拷贝到nacos下面的bin文件夹里，并且重命名为nacos.exe；
然后，在当前目录下创建一个xml文件，文件内容如下：
&lt;service&gt; &lt;id&gt;nacos&lt;/id&gt; &lt;name&gt;nacos&lt;/name&gt; &lt;description&gt;nacos_service&lt;/description&gt; &lt;executable&gt;startup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/401649e03514ff0f7ece345299fbf3b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88527ac621de3e905be3797a837a9d66/" rel="bookmark">
			Kafka与RabbitMQ的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		消息队列介绍 消息队列（Message Queue）是一种在分布式系统中进行异步通信的机制。它允许一个或多个生产者在发送消息时暂时将消息存储在队列中，然后由一个或多个消费者按顺序读取并处理这些消息。
消息队列具有以下特点：
异步通信：消息队列允许生产者和消费者在时间上解耦，即生产者发送消息后不必等待消费者立即处理，消费者可以在适当的时候从队列中获取并处理消息。可靠性：消息队列提供了持久化机制，确保即使在系统崩溃或重启的情况下，消息也不会丢失。顺序性：消息队列保证了消息按照发送的顺序逐个被消费者读取和处理，这有助于维护数据的完整性和一致性。可扩展性：通过将处理逻辑分离到不同的消费者，消息队列允许系统轻松地扩展到多个节点，以提高吞吐量和应对高并发场景。解耦：消息队列允许生产者和消费者之间无需直接交互，它们之间的耦合性降低，可以独立地进行开发、部署和运维。 常见的消息队列工具有 RabbitMQ 、Kafka 、ActiveMQ 、RocketMQ 等。这些工具提供了不同的特性和适用场景，可以根据实际需求选择适合的消息队列系统。
Kafka的介绍 Apache Kafka是一个开源流处理平台，由Scala和Java编写，由Apache软件基金会开发。它是一个高吞吐量的分布式发布订阅消息系统，可以处理消费者在网站中的所有动作流数据。这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。对于像Hadoop一样的日志数据和离线分析系统，但又要求实时处理的限制，Kafka是一个可行的解决方案。Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消息。
Kafka可以存储和持续处理大型的数据流，它有点像消息中间件，但是和传统的消息中间件有着很大得差异。消息系统只会传递数据，而Kafka的流处理能力可以让我们高效的处理数据。它可以发布和订阅数据流，并将它们保存起来进行处理。
Kafka里的消息用主题进行分类，主题下有若干个分区，有新消息，消息会追加的形式写入分区。由于主题会有多个分区，所以在整个主题范围内，是无法保证消息顺序的。分区可以分布在不同的服务器上，实现数据冗余和伸缩。此外，消费者可以订阅一个或多个主题，通过检查偏移量来区分读取哪个消息。
Kafka的特点 高吞吐量：Kafka每秒可以处理数万条消息，适用于各种规模的流数据处理场景。持久化：Kafka将消息持久化到磁盘，因此可以用于批量消费和实时应用程序。分布式系统：Kafka是一个分布式系统，易于向外扩展，支持多个生产者和消费者同时读写。可靠性：Kafka通过分布式结构和数据备份机制来保证数据的可靠性和容错性。可扩展性：Kafka集群支持热扩展，可以方便地增加或减少节点。耐用性：Kafka中的数据分区存储在每台机器的磁盘上，不易丢失。支持在线和离线场景：Kafka既可以在线处理实时数据流，也可以离线处理历史数据。 此外，Kafka还具有低延迟、高并发、灵活的分区和消费者组管理等特点，使其适用于各种流处理场景，如消息队列、行为跟踪、运维数据监控、日志收集、流处理、事件溯源和持久化日志等。
RabbitMQ的介绍 RabbitMQ是一个开源的消息队列系统，使用Erlang语言编写，实现了高级消息队列协议（AMQP）。它是一个可靠的、可扩展的、易用的消息队列系统，广泛应用于各种分布式系统中。
RabbitMQ的特点 RabbitMQ的主要特点包括：
可靠性：RabbitMQ通过持久化、传输确认和发布确认等机制来确保消息的可靠传递。灵活的路由：消息在进入队列之前会通过交换器进行路由，使得消息能够按照特定的规则进行分发。可扩展性：RabbitMQ支持构建集群，多个节点可以组成一个集群，并可以根据实际业务需求动态地扩展集群中的节点。高可用性：队列可以在集群的多台机器上进行镜像设置，即使其中的某些节点出现故障，队列仍然可用。多种协议：RabbitMQ不仅原生支持AMQP协议，还支持其他多种消息中间件协议，如STOMP、MQTT等。多语言客户端：RabbitMQ提供了广泛的语言客户端支持，几乎涵盖了所有常用编程语言，包括Java、Python、Ruby、PHP、C#、JavaScript等。 RabbitMQ是一个可靠、灵活、可扩展的消息队列系统，适用于各种分布式系统的消息传递需求。
Kafka与RabbitMQ的相同点 消息传递：两者都支持异步消息传递，可以在分布式系统中传递消息。可靠性：两者都提供了持久化机制，保证消息的可靠性传递。高吞吐量：Kafka和RabbitMQ都具有高吞吐量的特性，能够处理大量的消息。可扩展性：两者都支持水平扩展，可以根据需求增加节点来处理更多的消息。 综上所述，Kafka和RabbitMQ的相同点主要表现在消息传递、可靠性、高吞吐量以及可扩展性等方面。
Kafka与RabbitMQ的不同点 语言：RabbitMQ是由Erlang语言开发的，而Kafka则是用Scala语言开发的。结构：RabbitMQ使用AMQP（高级消息队列协议），其broker由Exchange、Binding和Queue组成。而Kafka则采用不同的结构，其中broker有part（分区）的概念。交互方式：RabbitMQ采用push的方式，而Kafka则采用pull的方式。集群负载均衡：RabbitMQ的负载均衡需要单独的load balancer进行支持，而Kafka则通过zookeeper对集群中的broker和consumer进行管理。数据处理方式：RabbitMQ是一个传统的AMQP消息队列，使用队列来存储和传递消息，并通过消息持久化和队列持久化机制将消息和队列持久化到磁盘中，以提供高可靠性和持久性。而Kafka则是一个分布式流处理平台，使用分布式日志来存储和传递消息，支持高吞吐量和低延迟的实时数据流处理，适合处理大量的数据流。数据存储：Kafka内部采用消息的批量处理，数据的存储和获取是本地磁盘顺序批量操作，消息处理的效率高，吞吐量高。 Kafka和RabbitMQ在语言、结构、交互方式、集群负载均衡、数据处理方式和数据存储等方面存在差异。选择使用哪种消息队列系统取决于具体的应用场景和需求。
Kafka和RabbitMQ的使用场景的区别 Kafka和RabbitMQ的使用场景存在一些明显的区别，主要表现在以下几个方面：
消息大小和格式 ：RabbitMQ更适合处理中小型消息，而Kafka则更适合处理大型消息和流式数据。实时性要求 ：RabbitMQ支持更精确的消息传递延迟和定时功能，更适合实时消息处理。吞吐量 ：Kafka在吞吐量方面表现优于RabbitMQ，尤其在处理大量数据和高并发场景时。数据一致性和可靠性 ：RabbitMQ提供了更强的消息持久化和确认机制，确保消息可靠传输。分布式系统支持 ：Kafka通过其分布式特性和高吞吐量能力，更适用于构建大规模分布式系统。插件支持和生态系统 ：RabbitMQ有更丰富的插件支持和生态系统，更容易与各种技术和工具集成。 Kafka和RabbitMQ的使用场景区别主要表现在消息大小和格式、实时性要求、吞吐量、数据一致性和可靠性、分布式系统支持以及插件支持和生态系统等方面。选择使用哪种消息队列系统取决于具体的应用场景和需求。
RabbitMQ使用指南
Kafka使用指南
ActiveMQ使用指南
RocketMQ使用指南
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a05824624bfff6cfc76357d5f952c3fc/" rel="bookmark">
			操作系统期末重点复习 （南昌大学）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人一名大三学生，最近要期末考试了自己整理一下操作系统需要复习的重点希望对大家的期末复习有帮助-
带！！的是老师着重强调的
第一章–计算机系统概述 1.现代操作系统的特点和主要功能 并发：指两个或多个事件在同一时间间隔内发生
共享：指系统中的资源可供多个并发执行的进程使用
虚拟：虚拟是指把物理上的实体变为若干逻辑上的对应物
异步：多道程序环境下由于资源有限，进程的执行并不是贯彻到底的，而是走走停停，以不可预知的速度向前执行
功能：
a.操作系统作为计算机资源的管理者：处理机管理、存储器管理、文件管理、设备管理
b.操作系统作为用户和计算机硬件系统之间的接口：命令接口（联机命令和脱机命令）、程序接口
c.操作系统实现了对计算机资源的扩充
2.不同的操作系统的特点： a.批处理：
单批道：每次内存中仅放一道作业，每当它在运行期间发出IO请求时就会让CPU陷入低速的IO中导致CPU空闲等待时间过长
多批道：允许多个程序同时进入内存并允许它们在CPU上交替的运行，资源利用率高但不提供人机交互能力，无法调试
b.分时操作系统
分时技术：将处理机的运行时间分为很短的时间片，按照时间片轮流把出库胡分配给各个联机作业使用
分时操作系统是指多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时和主机进行交互操作而不受干扰。
主要有同时性、交互性、独立性、及时性的特点
c.实时操作系统
硬实时系统：某个动作必须在规定时间发生
软实时系统：接受偶尔违反时间规定且不会引起永久性伤害
d**.网络操作系统**
网络操作系统将计算机网络中的各台计算机有机的结合在一起，提供一种统一、经济而有效的使用各台计算机的方法，最主要的特点就是网络中各种资源的共享及各台计算机之间的通信
第二章–进程与线程 1.程序顺序执行和并发的特点 顺序执行时
1.顺序性：程序严格按照顺序执行
2.封闭性：程序运行时独占全机资源
3.可再现性：程序按顺序一定的速度执行，可再现
并发执行时
1.间断性：由于资源有限，并发进程之间会相互制约
2.失去封闭性：并发的程序共享计算机资源，这些资源的状态由这些程序一起改变
3.不可再现性：执行速度不确定，不可再现
2.！！进程的基本概念以及进程状态的切换 PCB：为了使参与并发的每个程序都能独立的运行，必须为之配备一个专门的数据结构，称为进程控制块PCB，系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程
进程实体：由程序段、相关数据段和PCB三部分构成进程实体（进程映像）
进程：1）进程是程序的一次执行。2）进程是一个程序及数据在处理机上顺序执行发生的活动。3）进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的基本单位
PCB是进程存在的唯一标识
进程的状态有：就绪态、运行态、阻塞态
就绪态-运行态：操作系统从就绪链表中调度一个进程PCB进CPU
运行态-就绪态：一个进程时间片用完CPU必须去调度下一个进程时
运行态-阻塞态：进程在运行时需要等待一个事件的完成
阻塞态-就绪态：进程等待的事件完成
3.进程同步与互斥 同步：直接制约关系，为了完成某种任务的两个或者多个进程之间相互协调等待传递信息所产生的制约关系
互斥：间接制约关系，临界资源只能被一个进程访问到，其余访问的进程需dengdai
4.！！经典同步问题 1.生产者消费者问题
//简单 semaphore mutex=1; semaphore empty=n; semaphore full=0; producer(){ while(1){ produce an item in nextp; p(empty); p(mutex); add nextp to buffer; v(nutex); v(full); } } consumer(){ while(1){ p(full); p(mutex); remove an item from buffer; v(mutex); v(empty); consume the item; } } //复杂 //桌上只有一个盘子，每次只能放入一个水果，爸爸专门放苹果，妈妈专门放橘子，儿子专门等橘子，女儿专门等苹果 //只有盘子为空的时候才可以放入苹果，只有盘子里有各自需要的水果时儿子女儿才可以取出 semaphore plate=1,apple=0,orange=0; dad(){ while(1){ prepare an apple; p(plate); put the apple on the plate; v(apple); } } mom(){ while(1){ prepare orange; p(plate); put the orange on the plate; v(orange); } } son(){ while(1){ p(orange); take an orange from the plate; v(plate); eat; } } daughter(){ while(1){ p(apple); take an apple on the plate; v(plate); eat; } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a05824624bfff6cfc76357d5f952c3fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b33bd86aeba141c5a54cb8ea2670929/" rel="bookmark">
			即将消失的五种编程语言？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Ruby
Ruby 在 1999 年发布后立即受到程序员们的热捧，它能够快速构建应用程序的特性给程序员留下了非常深刻的印象。紧随其后，备受欢迎的 Ruby on Rails 框架于 2004 年发布，由于 Ruby 和 Rails 这两个名称在当时几乎成为了同义词，因此 Ruby 很快地被推到了程序员最喜欢的编程语言排行榜首位。但由它构建的应用程序运行速度往往比其他流行的编程语言，比如 JavaScript、Go 和 Python 构建的应用（在某些框架下）运行速度慢。同时期下，后三者已经发展到可以满足当时的需求，而 Ruby 在很多方面一直在原地踏步，没有什么进步。
2. Visual Basic
它于1991年由微软发布，作为构建 Windows 的主要工具，确实实现了此目的。这种语言在许多方面与Java相似，一段时间后，C#成为了微软的新语言标准。与c#诞生同时，微软程序员发明了VisualBasic . net，它的语法与BASIC相同，但代码模仿了C#。这两种语言都广为人知，但c#似乎赢得了流行度的竞赛。因此，Visual Basic似乎注定要消亡。
3. Delphi
Delphi也就是Pascal + Objects，最有可能被淘汰，即便Embarcadero已经尝试支持它，新版本仍在发布中。这主要归结于Borland的一系列战略失误。
4. Perl
Perl 于 1987 年开始流行时，它被誉为是适合任何一个人的编程语言，曾经有一段时间，每个人都用Perl编程，但是后来发生了一些事情，开发者开始在不知道原因的情况下添加越来越大的功能，也许这增加了了问题的复杂性。甚至它的作者似乎已经含蓄地解释了Perl的一些问题，并选择停止从2000年开始的Perl 6开发，关键是，似乎现在也没人想要在用Perl。
5. Haskell
Haskell 是另一个古董级别的编程语言，它于几十年前创建，在世纪之交前一直被使用。不幸的是，对于 Haskell 来说，属于它的时代很快就要结束了。研究人员和学者大多将 Haskell 用于构建程序，以对其工作进行复杂的排列和外推计算，普遍认为它很难学习。学习路径困难必然导致非常有限的活跃用户，而 Haskell 的上一个最新的稳定版本是在 2010 年发布，这对于促进它本身的发展无济于事。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cb2071fe6cbe46fd6ea98158cd39ace/" rel="bookmark">
			2024三掌柜赠书活动第三期：Rust系统编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言
Rust语言概念
关于《Rust系统编程》
Rust系统编程的核心点
Rust系统编程的关键技术和工具
编辑推荐
内容简介
作者简介
图书目录
书中前言/序言
《Rust系统编程》全书速览
结束语
前言 在技术圈，最近的编程语言新秀当属Rust莫属，Rust是一种现代化的系统编程语言，具有强大的性能、内存安全和并发性，它旨在提供高效的低级控制和抽象，使开发人员能够编写高性能、可靠且安全的系统级应用程序。据悉在 Stack Overflow 的年度开发者调查报告中，Rust 连续多年被评为“最受喜爱的编程语言”，越来越多的大公司如谷歌、微软、腾讯等都开始将Rust运用于各类项目中。本文就来简单聊聊Rust系统编程的基本概念和特点，并聊聊如何使用Rust构建可靠的系统级软件。
Rust语言概念 作为开发者想必都知道，Rust是一门系统编程语言，专注于安全，尤其是并发安全，支持函数式和命令式以及泛型等编程范式的多范式语言。Rust在语法上和C++类似，设计者想要在保证性能的同时提供更好的内存安全。据悉 Rust最初是由Mozilla研究院的Graydon Hoare设计创造，然后在Dave Herman, Brendan Eich以及很多其他人的贡献下逐步完善的，Rust的设计者们通过在研发Servo网站浏览器布局引擎过程中积累的经验优化了Rust语言和Rust编译器。
还有就是Rust编译器是在MIT License 和 Apache License 2.0双重协议声明下的免费开源软件，另外，Rust已经连续七年（2016，2017，2018，2019，2020, 2021, 2022）在Stack Overflow开发者调查的“最受喜爱编程语言”评选项目中折取桂冠。
关于《Rust系统编程》 接下来给大家推荐一本关于Rust系统编程学习必备的书籍，这是一本关于Rust系统编程实战类的干货图书，一经上市就登上了京东“计算机与互联网”图书排行榜前列。另外，关注本文博主，点赞+收藏本文，且在本文评论区评论“我要入门Rust编程”，将选取三名幸运读者送出纸质版《Rust系统编程》一本，截止时间：2024.01.14。入手《Rust系统编程》传送门：https://item.jd.com/13434725.html 或者 《Rust系统编程》([印]普拉布·艾什沃拉 著 刘君 译)【简介_书评_在线阅读】 - 当当图书，个人觉得这本书非常的不错，尤其是想构建可靠的系统级软件的开发者来讲，是一本不可多得的好书，值得拥有去学习。
Rust系统编程的核心点 内存安全：Rust的所有权系统和借用检查器能够在编译时防止常见的内存错误，如空指针引用、数据竞争等。零成本抽象：Rust提供了高级抽象和模块化的编程机制，同时保证在运行时不引入额外的开销。高性能：Rust的运行时性能接近于C/C++，并且具备对内存分配和线程管理的精细控制。并发性：Rust的并发模型允许开发人员编写安全的并发代码，包括线程安全、跨线程通信等。 Rust系统编程的关键技术和工具 unsafe关键字：Rust提供了unsafe关键字，用于处理需要绕过编译时检查的底层操作，如访问原始指针和调用不安全的函数。FFI（Foreign Function Interface）：Rust支持与其他语言进行无缝集成，可以直接调用C语言函数和使用C语言的数据结构。Cargo构建系统：Cargo是Rust的默认构建系统，提供了便捷的项目管理、依赖管理和构建工具等功能。 编辑推荐 Rust是一种现代开源系统编程语言，它承诺并做到了3个领域的：Java的类型安全；C 的速度、表现力和效率；无须垃圾收集器的内存安全。通读完本书，你会对如何使用Rust管理和控制操作系统资源（如内存、文件、进程、线程、系统环境、外围设备、网络接口、终端和外壳程序）有清晰的了解，并掌握如何通过FFI构建跨语言绑定。在此过程中，你会对Rust为构建安全、高性能、可靠和高效的系统级软件带来的价值有深刻的认识。
内容简介 《Rust系统编程》详细阐述了与Rust系统编程相关的基本解决方案，主要包括Rust工具链和项目结构，Rust编程语言之旅，Rust标准库介绍，管理环境、命令行和时间，Rust中的内存管理，在Rust中使用文件和目录，在Rust中实现终端I/O，处理进程和信号，管理并发，处理设备I/O，学习网络编程，编写不安全Rust和FFI等内容。此外，本书还提供了相应的示例、代码，以帮助读者进一步理解相关方案的实现过程。 本书适合作为高等院校计算机及相关专业的教材和教学参考书，也可作为相关开发人员的自学用书和参考手册。
图书目录 目 录
第1篇 Rust系统编程入门
第1章 Rust工具链和项目结构 3
1.1 技术要求 3
1.2 为项目选择正确的Rust配置 4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cb2071fe6cbe46fd6ea98158cd39ace/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25e221be76ce205e8ace02e856af0af4/" rel="bookmark">
			1146. 新的开始（prim算法，超级原点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1146. 新的开始 - AcWing题库
发展采矿业当然首先得有矿井，小 FF 花了上次探险获得的千分之一的财富请人在岛上挖了 n 口矿井，但他似乎忘记了考虑矿井供电问题。
为了保证电力的供应，小 FF 想到了两种办法：
在矿井 i 上建立一个发电站，费用为 vi（发电站的输出功率可以供给任意多个矿井）。将这口矿井 i 与另外的已经有电力供应的矿井 j 之间建立电网，费用为 pi,j 小 FF 希望你帮他想出一个保证所有矿井电力供应的最小花费方案。
输入格式 第一行包含一个整数 n，表示矿井总数。
接下来 n 行，每行一个整数，第 i 个数 vi 表示在第 i 口矿井上建立发电站的费用。
接下来为一个 n×n 的矩阵 P，其中 pi,j 表示在第 i 口矿井和第 j 口矿井之间建立电网的费用。
数据保证 pi,j=pj,i，且 pi,i=0
输出格式 输出一个整数，表示让所有矿井获得充足电能的最小花费。
数据范围 1≤n≤300
0≤vi,pi,j≤105
输入样例： 4 5 4 4 3 0 2 2 2 2 0 3 3 2 3 0 4 2 3 4 0 输出样例： 9 解析： 超级原点：这里我们可以假设存在一个超级原点，将在某点上建发电站视作将该点与超级原点连接。（这种转换的做法在图论中很常见）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25e221be76ce205e8ace02e856af0af4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c8970776d0db9b0ba323a3ca4b5a58d/" rel="bookmark">
			Openharmony 对应Android基本系统信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新需要做Openharmony的一些适配，但是看了hdc，相比adb阉割了不少东西，很多都没展示出来，所以就想方设法跟adb的一些方法对照一下，分享一下希望帮到更多的人。
什么是getprop 在Android系统中，getprop是一个命令行工具，允许用户查询设备上配置文件中的属性值。这些属性值通常用于配置设备的行为和特性，例如网络设置、系统偏好设置等。getprop命令可以列出所有的配置信息，也可以根据特定的关键字查询特定的属性值。
举个例子
adb shell getprop ro.product.model 这个可以获取当前手机的牌子
Openharmony的对应方法 在普通的android设备中，getprop是从/system/build.prop里面读取数据，所以我先尝试着从openharmony系统中的这个文件读取，但是很可惜，这个文件里面什么都没有。
随后找到了一个命令，param，这个相当于和getprop对应的指令吗，那么具体有什么呢？
获取全部列表
hdc shell param get 这边可以获取全部的列表，但是数量太大，我们对const变量过滤，得到如下结果：
const.product.odm.name = Phoenix const.product.os.dist.apiversion = 40100 const.product.os.dist.releasetype = Release const.product.brand = HUAWEI const.product.model = NOH-AN00 const.product.name = HUAWEI Mate 40 Pro const.product.cpu.abilist = arm64-v8a const.product.hide = true const.product.hide.matchers = 4.1.0;OpenHarmony-4 const.product.hide.replacements = 2.0.0;2 const.product.build.type = default const.product.build.user = default const.product.build.host = default const.product.build.date = default const.product.devicetype = phone const.product.software.version = NOH-AN00 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c8970776d0db9b0ba323a3ca4b5a58d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ace020a3a66f9978218fa6ef2010852/" rel="bookmark">
			zookeeper源码(05)数据存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文详细分析一下zookeeper的数据存储。
ZKDatabase 维护zookeeper服务器内存数据库，包括session、dataTree和committedlog数据，从磁盘读取日志和快照后启动。
关键字段 // 数据节点树 protected DataTree dataTree; protected ConcurrentHashMap&lt;Long, Integer&gt; sessionsWithTimeouts; protected FileTxnSnapLog snapLog; // 用于操作底层数据文件 // committedLog中第一条和最后一条数据的zxid protected long minCommittedLog, maxCommittedLog; // committedLog最大容量，默认500 public int commitLogCount; // 维护最后提交的请求集，可用于快速follower同步 protected Queue&lt;Proposal&gt; committedLog = new ArrayDeque&lt;&gt;(); protected ReentrantReadWriteLock logLock = new ReentrantReadWriteLock(); private volatile boolean initialized = false; // txnlog计数 private AtomicInteger txnCount = new AtomicInteger(0); 构造方法 public ZKDatabase(FileTxnSnapLog snapLog) { dataTree = createDataTree(); sessionsWithTimeouts = new ConcurrentHashMap&lt;&gt;(); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ace020a3a66f9978218fa6ef2010852/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13fbfb9b8688a53de713f48fce920d43/" rel="bookmark">
			简单程序 C语言xdoj98
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述
按输入 n 的不同情况，输出不同的特定文字。当 n 为 2 的倍数，且不是 3、5 的倍数时， 输出"Nice"；当 n 为 3 的倍数，且不是 2、5 的倍数时，输出"Good"；当 n 为 5 的倍数，且 不是 2、3 的倍数时，输出"Best"；其他情况，输出"Bad"。
输入格式
输入一个正整数 n（n 为自然数，且 n≤10,000）。
输出格式
输出特定文字。
样例输入 1： 9
样例输入 2： 16
样例输入 3： 130
样例输出 1： Good
样例输出 2： Nice
样例输出 3： Bad
样例说明
n 为自然数，且不大于 10,000。
评测用例规模与约定
n 可以是 2、3、5 的整数倍，也可以不是
#include &lt;stdio.h&gt; //简单程序 int main() { int n; scanf("%d", &amp;n); int a = 0, b = 0, c = 0; if (n % 2 == 0) { a = 1; } if (n % 3 == 0) { b = 1; } if (n % 5 == 0) { c = 1; } if (a == 1 &amp;&amp; b == 0 &amp;&amp; c == 0) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13fbfb9b8688a53de713f48fce920d43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b31aad83e2ad614c3546648fb7b0afd2/" rel="bookmark">
			127基于matlab的卡尔曼滤波在目标跟踪中应用仿真研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于matlab的卡尔曼滤波在目标跟踪中应用仿真研究，模拟目标真实轨迹 z，形成观测数据（真实轨迹位置数据迭加上观测数据） ， 递推估计 ，计算估计误差画出目标轨迹、测量数据、滤波数据曲线；滤波误差的均值曲线；滤波误差的标准差曲线。程序已调通，可直接运行。
127matlab卡尔曼滤波跟踪应用仿真 (xiaohongshu.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6720d5ad2db5a50dbfa1f4d28726a45e/" rel="bookmark">
			【项目经验】：elementui 表单问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.项目问题 1.在登录页面输入密码后浏览器保存密码，在下一次别的页面打开输入框会自动输入浏览器保存的密码。原因是浏览器会默认认为当前input的属性是password。
2.当form表单只有一个表单时回车提交表单问题
二.最终解决方案 浏览器自动填充密码问题 先设置input输入框的type属性为text; 然后获取焦点时改变type为password。
// html &lt;input type="password" onfocus="type='password'"&gt; &lt;el-input type = 'text' @focus = "focusFn"&gt;&lt;/el-input&gt; // js focusFn(e){ e.srcElement.type = 'password' } form表单只有一个表单时回车提交表单问题 表单加@submit.native.prevent
&lt;el-form @submit.native.prevent&gt; &lt;el-form-item&gt; &lt;el-input v-model="form.password" @keyup.enter.native="enterInput" /&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76503ba8c44d3da1ed727f684797eb25/" rel="bookmark">
			升级 Vite 5 出现警告 The CJS build of Vite‘s Node API is deprecated.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀 作者主页： 有来技术
🔥 开源项目： youlai-mall 🍃 vue3-element-admin 🍃 youlai-boot
🌺 仓库主页： Gitee 💫 Github 💫 GitCode
💖 欢迎点赞 👍 收藏 ⭐留言 📝 如有错误敬请纠正！
目录 错误描述问题原因解决方案解决方案一解决方案二 问题扩展什么是 CJS？什么是 ESM?CJS 和 ESM 的区别Vite 为什么弃用 CJS？ 开源项目 错误描述 vue3-element-admin 升级 Vite4 至 Vite5 后启动项目出现如下警告：
The CJS build of Vite's Node API is deprecated. See https://vitejs.dev/guide/troubleshooting.html#vite-cjs-node-api-deprecated for more details. 问题原因 Vite 官方弃用 CJS 说明： deprecate-cjs-node-api
解决方案 Vite 官方 Github 仓库下的 ISSUE：“The CJS build of Vite’s Node API is deprecated” when using a TS vite.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76503ba8c44d3da1ed727f684797eb25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/912dcd2b3b5086d73c9205342026ef75/" rel="bookmark">
			Django(六)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		员工管理系统(用户管理） {% extends 'layout.html' %} {% block content %} &lt;div class="container"&gt; &lt;div style="margin-bottom: 10px"&gt; &lt;a class="btn btn-success" href="#"&gt; &lt;span class="glyphicon glyphicon-plus-sign" aria-hidden="true"&gt;&lt;/span&gt; 新建用户 &lt;/a&gt; &lt;/div&gt; &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;span class="glyphicon glyphicon-th-list" aria-hidden="true"&gt;&lt;/span&gt; 用户列表 &lt;/div&gt; &lt;table class="table table-bordered"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;密码&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;余额&lt;/th&gt; &lt;th&gt;入职时间&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;所属部门&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;td&gt;xxx&lt;/td&gt; &lt;td&gt;xxx&lt;/td&gt; &lt;td&gt;xxx&lt;/td&gt; &lt;td&gt;xxx&lt;/td&gt; &lt;td&gt;xxx&lt;/td&gt; &lt;td&gt;xxx&lt;/td&gt; &lt;td&gt;xxx&lt;/td&gt; &lt;td&gt; &lt;a class="btn btn-primary btn-xs" href="#"&gt;编辑&lt;/a&gt; &lt;a class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/912dcd2b3b5086d73c9205342026ef75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a179a82ea05ff509b7527ecc2d0fe00/" rel="bookmark">
			【Flutter 开发实战】Dart 基础篇：最基本的语法内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在深入了解 Dart 这门编程语言之前，我们需要了解一些关于 Dart 的最基本的知识，像是常量、变量、函数等等，这样才能够让我们的开发效率更上一层楼。在本节，我们将探讨一些基础语法，包括入口方法 main、变量、常量以及命名规则。让我们一起揭开 Dart 的神秘面纱，为你带来更深层次的了解。
探寻 Dart 的大门：main 方法 在 Dart 中，所有程序的执行都始于 main 方法。这是程序的入口点，是代码开始执行的地方。不少初学者学习代码都会从 main 方法开始阅读，从而整理出整个工程项目的整体脉络。让我们看一个简单的 main 方法：
void main() { print("Hello, Dart!"); } 这是不少小伙伴初学编程时都会编写简单案例，在这个例子中，main 方法是程序的起点，print 函数用于在控制台输出文本，当你按下运行，就会在控制台内看到 Hello, Dart! 这段话。Dart 的语法简洁，让你能够迅速理解和编写代码。
变量：存储世界的记忆 在 Dart 中，变量用于存储数据。使用 var 关键字可以声明一个变量，而 Dart 会自动推断其类型。例如：
void main() { var message = "Hello, Dart!"; print(message); } 在这里，我们创建了一个名为 message 的变量，用于存储字符串；当我们点击运行后，就会把 message 中的存储的内容输出出来。Dart 的类型推断让我们无需明确指定变量类型，使得代码更加简洁。
常量：不变的世界 与变量不同，常量在 Dart 中是不可变的。通常使用 final 或 const 关键字可以声明常量。const 表示编译时常量，其值在一开始就必须被赋值，而 final 在声明时可以不赋初始值，但只能在运行时被赋值一次。与 const 不同的是，final 是运行时常量，而且它具有惰性初始化的特性，即在运行时首次使用前才进行初始化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a179a82ea05ff509b7527ecc2d0fe00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80396119e25987e390ddeaafccbd4fc2/" rel="bookmark">
			python中字符串替换方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一种--replace()函数接收两个参数，第一个参数为要被替换的子字符串，第二个参数为替换后的新字符串
string = "张三180" new_string1 = string.replace(string, "李四") # &gt;&gt;&gt; 李四 new_string2 = string.replace('张三', "李四") # &gt;&gt;&gt; 李四180 print(new_string1) print(new_string2) 第二种--Template
string = "${name} is a ${age}" t = Template(string) print(t.substitute(name="张三", age="18")) # &gt;&gt;&gt; 张三 is a 18 # 变量没与字典匹配的话，解释器会抛出KeyError print(t.substitute(name="张三")) # &gt;&gt;&gt; KeyError: 'age' print(t.safe_substitute({"name": "张三", "age": "18"})) # &gt;&gt;&gt; 张三 is a 18 # 没有匹配则不会被替代 print(t.safe_substitute({"name": "张三"})) # &gt;&gt;&gt; 张三 is a ${age} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25d06aac1a33cadc9992ab4cae56b341/" rel="bookmark">
			AnnexB封装格式介绍（主要用于H.264和H.265视频编码标准，是一种常见的视频流NALU封装格式，常用于RTSP、RTP传输）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：解码中的AnnexB和avcC两种分割数据方式
文章目录 AnnexB 格式介绍1. NALU单元与开始代码1.1 NALU单元1.2 开始代码 2. AnnexB格式详述2.1 基本结构2.2 长度前缀 3. 从AnnexB格式到AVCC格式4. AnnexB格式的优缺点4.1 优点4.2 缺点 5. 疑难问题解析如何确定开始代码的长度？如何处理存在于NALU单元原始数据中的开始代码？ 6. AnnexB 格式的应用场景1. 视频流传输2. 视频文件存储3. 编解码器 AnnexB 格式介绍 AnnexB是一种常见的视频流NALU封装格式，主要用于H.264和H.265视频编码标准。其特性包括插入开始代码以标识NALU单元的开始，以及使用字节流方式传输数据。
1. NALU单元与开始代码 在理解AnnexB格式之前，首先需要了解NALU（Network Abstraction Layer Units）单元的概念。在H.264/H.265编码中，每个视频帧被编码为一个或多个NALU单元。
1.1 NALU单元 每个NALU单元都可以看作是视频数据的一个独立包，它包含一定数量的原始字节数据。这些数据可以是图像切片、序列参数集（SPS）、图像参数集（PPS）等类型。
1.2 开始代码 为了在字节流中识别出每个NALU单元的开始位置，AnnexB格式引入了所谓的"开始代码"。开始代码可以是两种形式：0x000001或0x00000001。当解析器在字节流中遇到这样的模式时，它知道一个新的NALU单元开始了。
2. AnnexB格式详述 接下来深入探讨一下AnnexB格式的具体内容和结构。
2.1 基本结构 AnnexB格式基本上就是一连串的NALU单元，每个单元由一个开始代码和随后的原始字节数据组成。
[开始代码] [NALU单元] [开始代码] [NALU单元] ... 2.2 长度前缀 在某些情况下，例如当数据被封装到其他容器（如MPEG-TS、MP4等）时，可能需要使用"长度前缀"而不是"开始代码"。长度前缀是一个固定长度的字段，通常为4个字节，表示接下来的NALU单元的长度。然而，这并不是AnnexB格式的一部分，而是属于AVCC格式。
3. 从AnnexB格式到AVCC格式 正如上文所述，有时需要将AnnexB格式转换为AVCC格式。这主要涉及两步：去掉开始代码，并添加长度前缀。
以下是一个简单的Python示例，演示如何进行此转换：
def annexb_to_avcc(annexb): avcc = b'' nal_units = annexb.split(b'\x00\x00\x01') for nal_unit in nal_units: if len(nal_unit) == 0: continue length_prefix = len(nal_unit).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25d06aac1a33cadc9992ab4cae56b341/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feed96f2e3de4cb0404cbf9363bdfc2f/" rel="bookmark">
			【动态代理详解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 关于代理1.1 代理的概述1.1.1 什么是动态代理1.1.2 动态代理能做什么 1.2 什么是代理1.2.1 生活中的代理1.2.2 为什么要找中介？ 1.3 开发中的代理模式（代理）1.3.1 使用代理模式的作用 1.4 实现代理的方式 2. 静态代理2.1 什么是静态代理2.2 静态代理的实现步骤2.3 静态代理的优缺点 3. 动态代理（重点）3.1 什么是动态代理3.2 动态代理的优点3.3 动态代理的两种实现方式3.3.1 jdk动态代理的实现3.3.2 InvocationHandler 接口（调用处理器）3.3.3 如何理解InvocationHandler接口3.3.4 Method类3.3.5 Proxy类 3.4 动态代理的实现步骤 4.动态代理开发中实例 1. 关于代理 知道什么是动态代理以及动态代理能干什么就可以
1.1 代理的概述 1.1.1 什么是动态代理 ​ 使用jdk的反射机制，创建对象的能力， 创建的是代理类的对象。
动态：在程序执行时，调用jdk提供的方法才能创建代理类的对象。jdk动态代理，必须有接口，目标类必须实现接口， 没有接口时，需要使用cglib动态代理 1.1.2 动态代理能做什么 ​ 可以在不改变原来目标方法功能的前提下， 可以在代理中增强自己的功能代码。
​ 例如实际开发中，你所在的项目中，有一个功能是其他人（公司的其它部门，其它小组的人）写好的，你可以使用。你发现这个功能，现在还缺点，不能完全满足我项目的需要。 我需要在gn.print()执行后，需要自己在增加代码。用代理实现 gn.print（）调用时， 增加自己代码， 而不用去改原来的 GoNong文件。
// GoNong.class GoNong gn = new GoNong(); gn.print(); ​ 注意，不知道源代码，不能使用重写，而且你要用写好的功能想要去扩展功能，就只能先把写好的方法执行一边，然后再代理中扩展，重写的话，原来写好的方法也没了
1.2 什么是代理 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/feed96f2e3de4cb0404cbf9363bdfc2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55bbfd3272ee46321451748ac22a111d/" rel="bookmark">
			K8S的集群调度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scheduler：负责调度资源，把pod调度到node节点，有两种策略，
1：预选策略
2：优先策略
list-watch概念
k8s集群当中，通过list-watch的机制进行每个组件的协作，保持数据同步，每个组件之间的解耦
Kubectl配置文件，想APIserver发送命令---apiserver把命令发送到各个组件
如kubectl runnginx --image=nginx：1.22-----apiserver---controller manager---scheduler---kubelet(管理生命周期)
List-watch(监听)---会在每一步把监听的消息（先监听apiserver：6443）----每个组件（controller manager，scheduler，kubelet，etcd）都会监听apiserver：6443端口，都会获取消息 1、 kubectl run nginx --image=nginx:1.22 &gt; 2、 由apiserver调度到各个组件 &gt; 3、 controller-manger负责创建pod控制器 &gt; 4、 scheduler调度资源 &gt; 5、 kubelet来管理节点 &gt; 创建成功后，通过kubectl get pod/kubectl describe pod nginx 这些信息都保存在etcd数据库当中。 如何来把pod分配到node 工作流程：
1.kubectl创建pod和副本数传递给apiserver
2.创建replicas指定pod的策略保存通过apiserver在etcd数据库中存储配置信息。
3.etcd会将创建replicas的事件发送给apiserver
4.apiserver发送创建指令开始调用controller-manger
5.controller-manger收到指令开始创建pod再将信息发送给apiserver
6.apiserver收到创建pod的信息并将信息保存在etcd中
7.etcd把发送创建pod的信息再发送给apiserver
8.apiserver把创建pod的指令发送给scheduler
9.scheduler开始选择往哪个node节点上创建pod并更新pod的node节点信息。发送给apiserver
10.apiserver把pod的更新信息保存到etcd中
11.etcd告诉apiserver 已经确定节点信息。需要调用节点上的kubelet
12.apiserver传递消息开始调用kubelet创建pod和容器
13.kubelet将确定完毕的信息和节点信息，发送给apiserver。
14.apiserver将最终保存容器、副本、节点信息保存到etcd数据库中。
调度的过程和策略
Scheduler是k8s集群的调度器，他的意义就是把破分配到集群的节点
以下几个问题是它要考虑的
1 公平：每个节点都能够分配资源
2 资源高效利用：集群当中的资源可以被最大化使用
3 效率：调度的性能要好，能够尽快的完成大批量的pod的调度工作
4 灵活：运行用户根据自己的需求，控制和改变调度的逻辑
Scheduler是一个单独运行的程序，启动之后就会一直监听APIserver，它会获取报文中的字段:spec.nodeName
创建pod时候，为每个pod创建一个binding，表示该往哪个节点上部署
创建pod搭配节点时，由两个策略，先执行预选策略，再执行优选策略，这两步的操作都必须成功，否则立刻返回报错，也就是说，部署的node，必须满足这两个策略
预算策略
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55bbfd3272ee46321451748ac22a111d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f55883c2c0ae6c7bc6d55f550538818/" rel="bookmark">
			1. 两数之和（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述： 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
输入： nums = [2,7,11,15], target = 9
输出： [0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
代码实现: public class Main{ public static void main(String[] args) { //测试函数 int[] nums = new int[]{2, 7, 11, 15}; System.out.println(Arrays.toString(twoSum(nums, 9)));//[0, 1] } public static int[] twoSum(int[] nums, int target) { //最终结果数组 int[] res = new int[2]; //标记变量：未得到结果为0，得到结果为1 int flag = 0; //暴力枚举：每一个数和后面的所有数组合相加 for (int i = 0; i &lt; nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f55883c2c0ae6c7bc6d55f550538818/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afeec5385a98c6cbc4bdbb452dece21a/" rel="bookmark">
			【Flet教程】使用Flet以Python创建TODO应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flet是基于Python实现的Flutter图形界面GUI。除了使用Python，具备美观、简洁、易用，还有Flutter本身的跨平台（安卓、iOS、Win、Mac、Web）、高性能、有后盾的特点。下面是0.18版官方TODO APP教程，为了准确，保持了中英双语，请对照食用。
Create To-Do app in Python with Flet
使用Flet在Python中创建待办事项应用程序 In this tutorial we will show you, step-by-step, how to create a ToDo web app in Python using Flet framework and then share it on the internet. The app is a single-file console program of just 180 lines (formatted!) of Python code, yet it is a multi-session, modern single-page application with rich, responsive UI:
在本教程中，我们将逐步向您展示如何使用Flet框架在Python中创建ToDo web应用程序，然后在互联网上共享。该应用程序是一个只有180行（格式化！）Python代码的单文件控制台程序，但它是一个多会话、现代的单页应用程序，具有丰富、响应迅速的UI：
You can see the live demo here.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afeec5385a98c6cbc4bdbb452dece21a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c67ac0220ba7e85605d33136e0af2b23/" rel="bookmark">
			腾讯云com域名注册1元一年，非常可以！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云com域名注册优惠价格1元首年，条件是企业新用户，个人新用户注册com域名是33元首年，第二年续费价格85元一年。活动 txybk.com/go/domain-sales 活动打开如下图：
腾讯云com域名注册优惠价格
腾讯云com域名注册原价是85元一年，优惠价是75元一年。如果是腾讯云新用户可以享受特价，企业新用户注册com域名首年1元，个人新用户注册com域名首年33元。第二年续费价格是85元一年。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec02ef1efa86628900785cff9c7e591c/" rel="bookmark">
			【车载以太网测试从入门到精通】系列文章目录汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【车载以太网测试从入门到精通】——物理层测试
【车载以太网测试从入门到精通】——数据链路层测试
【车载以太网测试从入门到精通】——网络层测试
【车载以太网测试从入门到精通】——传输层测试
【车载以太网测试从入门到精通】——以太网TCP/IP协议自动化测试（含CAPL源码）
【车载以太网测试从入门到精通】——以太网网络管理测试
【车载以太网测试从入门到精通】——以太网网络管理自动化测试（含CAPL源码）
【车载以太网测试从入门到精通】——鲁棒性测试（待续）
【车载以太网测试从入门到精通】——SOME/IP协议测试（待续）
【车载以太网测试从入门到精通】——SOMEI/IP服务接口自动化测试（含CAPL源码）
【车载以太网测试从入门到精通】——DoIP协议测试
【车载以太网测试从入门到精通】——DoIP诊断自动化测试（待续）
【车载以太网测试从入门到精通】——DoIP BootLoader刷写（含CAPL源码）
【车载以太网测试从入门到精通】——以太网网关路由测试（待续）
【车载以太网测试从入门到精通】——以太网网关路由自动化测试（待续）
【车载以太网测试从入门到精通】——以太网交换机测试（待续）
【车载以太网测试从入门到精通】——以太网交换机自动化测试（待续）
【车载以太网测试从入门到精通】——AVB测试（待续）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37249cb410a5ac814201f5263f56e17a/" rel="bookmark">
			H3C-Telnet配置实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拓扑图：
要求：
按照图示连接到真机，并配置IP地址（真机IP地址配置到VirtualBox Host-Only Ethernet Adapter网卡）在R1上开启Telnet服务，创建用户hy，密码1234567890c用于身份验证(此处的用户名和密码可以任意设置）在真机上使用S-CRT通过Telnet登录R1 步骤：（注意：选择的host真机接口要按照图示所标注的）
1.虚拟机里连接好后，给路由器配置ip
&lt;r1&gt;system-view 从用户视图进入系统视图
System View: return to User View with Ctrl+Z.
[r1]sysname R1 给路由器重新命名为R1
[R1]int g0/0 进入接口g0/0
[R1-GigabitEthernet0/0]ip add 1.1.1.1 24 配置ip 1.1.1.1 24为掩码
2.给真机配置IP
电脑左下角开始（windows图标）
选择设置
选择如上页面的网络和Internet 选择更改适配器选项
找到如图所示名称网卡（对应了拓扑图中host的接口）
鼠标右键选择属性
选择Internet协议版本4
输入IP 1.1.1.2 --确定（注意要选择使用下面的ip地址，而不是自动获取）
在R1上ping 1.1.1.2，发现是通的
3.在R1上进行配置
可以使用键盘tab键自动补全命令
[R1]telnet server enable 开启telnet服务
[R1]local-user hy class manage 添加用户名 hy
New local user added.
[R1-luser-manage-hy]password sim 1234567890c 给用户名hy设置密码1234567890c
[R1-luser-manage-hy]service-type telnet 指定用户的作用是用户telnet的验证
[R1-luser-manage-hy]authorization-attribute user-role level-15 配置身份权限级别（0-15共16个级别） 15是最高可以做所有命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37249cb410a5ac814201f5263f56e17a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95fce8c69b56e0c5f98dd21fba30857f/" rel="bookmark">
			win11 如何切换用户？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1步：打开其他用户 第2步：添加账户 第3步： 使用新用户登录
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/15/">«</a>
	<span class="pagination__item pagination__item--current">16/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/17/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>