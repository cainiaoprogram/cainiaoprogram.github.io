<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71a3943bc3c65a335df82d9653882033/" rel="bookmark">
			Android 应用使用数据统计服务——UsageStatsManager
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 应用使用数据统计服务——UsageStatsManager 先了解下相关知识
UsageStats UsageStats是在指定时间区间内某个应用使用统计数据的封装类。包含的公开方法及对应的作用如下：
方法用途getFirstTimeStamp()获取指定时间区间内应用第一次使用时间戳getLastTimeStamp()获取指定时间区间内应用最后一次使用时间戳getLastTimeUsed()获取应用最后一次使用时间戳getPackageName()获取应用包名getTotalTimeInForeground()获取应用在前台的时间 EventStats EventStats是在指定时间区间内某个类型事件统计数据的封装类。包含的公开方法及对应的作用如下：
方法用途getCount()获取在指定时间区间内事件发生的次数getEventType()获取事件类型getFirstTimeStamp()获取指定时间区间内这个事件第一次发生的时间戳getLastEventTime()获取这个事件最后一次发生的时间戳getLastTimeStamp()获取指定时间区间内这个事件最后一次发生的时间戳getTotalTime获取这个事件总共发生的次数 UsageEvents UsageEvents是用来返回指定时间区间内组件状态变化事件数据的封装类，其返回的组件状态变化事件类型如下：
UsageEvents.Event: public static final int NONE = 0; public static final int MOVE_TO_FOREGROUND = 1; public static final int MOVE_TO_BACKGROUND = 2; public static final int END_OF_DAY = 3; public static final int CONTINUE_PREVIOUS_DAY = 4; public static final int CONFIGURATION_CHANGE = 5; public static final int SYSTEM_INTERACTION = 6; public static final int USER_INTERACTION = 7; public static final int SHORTCUT_INVOCATION = 8; public static final int CHOOSER_ACTION = 9; public static final int NOTIFICATION_SEEN = 10; public static final int STANDBY_BUCKET_CHANGED = 11; public static final int NOTIFICATION_INTERRUPTION = 12; public static final int SLICE_PINNED_PRIV = 13; public static final int SLICE_PINNED = 14; public static final int SCREEN_INTERACTIVE = 15; public static final int SCREEN_NON_INTERACTIVE = 16; public static final int KEYGUARD_SHOWN = 17; public static final int KEYGUARD_HIDDEN = 18; UsageStatsManager **UsageStatsManager 是Android提供统计应用使用情况的服务。通过这个服务可以获取指定时间区间内应用使用统计数据、组件状态变化事件统计数据以及硬件配置信息统计数据。**提供的主要查询方法如下表：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71a3943bc3c65a335df82d9653882033/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/767249ddc9300ab4604218b185701a67/" rel="bookmark">
			R语言——R函数、选项参数、数学统计函数（六）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、R函数
二、选项参数
三、数学统计函数
四、参考
一、R函数 1.lm()
lm()是R语言中经常用到的函数，用来拟合回归模型。它是拟合线性模型最基本的函数
lm()格式如下：
fit&lt;-lm(formula,data) 其中，formula指要拟合的模型形式，data是一个数据框，包含了用于拟合模型的数据。结果对象（本例中是fit）存储在一个列表中，包含了所拟合模型的大量信息。表达式（formula）形式如下：
Y~X1+X2..Xn 举例，输入：
a&lt;-c(1,2,3,4,5) b&lt;-c(2,4,6,8,10) mydata&lt;-data.frame(a,b) fit&lt;-lm(a~b,mydata) summary(fit) 结果会显示：
所以a,b的关系可表示为：
a=0.000000000000001192+0.5*b 2.函数返回值及输入数据格式
使用函数时要注意函数的返回值类型，比如有些函数返回值是列表，那就不能将其运用到使用向量的环境中。
有些函数只能处理矩阵，有些函数既能处理矩阵也能处理数据框，使用函数时，需要知道每个函数的输入数据格式，否则就会出错。
输入数据类型
向量：sum，mean，sd，range，median，sort，order
矩阵或数据框：cbind，rbind
数字矩阵：heatmap
3.使用help(函数名)可以查看函数的帮助文档。
二、选项参数 一般的选项函数可以分为三部分：输入控制部分、输出控制部分以及调节部分。
- 输入控制选项
常用选项：
file：接一个文件
data：一般指要输入一个数据框
x：表示单独的一个对象，一般都是向量，也可以是矩阵或者列表
x和y：函数需要两个输入变量
x，y，z：函数需要三个输入变量
formula：公式
na.rm：删除缺失值
- 输出控制选项：在R中，函数一般都是屏幕输出结果，每个函数的返回值也比较固定，所以输出控制选项并不多。
- 调节参数
调节参数
1.根据名字判断选项的作用
color：选项明显用来控制颜色
select：与选择有关
font：与字体有关
font.axis：就是坐标轴的字体
lty：是 line type
lwd：是 line width
method：软件算法
2.选项接受哪些参数
main：字符串，不能是向量
na.rm：TRUE 或者 FALSE
axis：side参数只能是1到4
fig：包含四个元素的向量
三、数学统计函数 1.概率统计函数
R概率分布：
d 概率密度函数 p 分布函数 q 分布函数的反函数 r 产生相同分布的随机数 正态分布函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/767249ddc9300ab4604218b185701a67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d2e23d14cae7d3d26f73957cae06587/" rel="bookmark">
			Android NumberPicker使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android NumberPicker使用 NumberPicker是一个滑动的控件，和spinner差不多。
数字选择器NumberPicker是Android3.0之后出的一个控件，所以如果要兼容3.0之前的版本就需要用到GitHub上的开源项目，下载地址是https://github.com/SimonVT/android-numberpicker
使用 1.首先在xml文件中引入NumberPicker控件
&lt;NumberPicker android:id="@+id/np" android:layout_width="wrap_content" android:layout_height="wrap_content" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toBottomOf="@+id/number_picker_use" /&gt; 2.在activity中找到NumberPicker，设置方法
NumberPicker numberPicker = findViewById(R.id.np); String[] datas = new String[]{"北京", "上海", "广州", "深圳"}; numberPicker.setDisplayedValues(datas); //设置文字 numberPicker.setMaxValue(datas.length - 1); //设置最大值，最大值是datas[3] numberPicker.setMinValue(0); numberPicker.setDescendantFocusability(DatePicker.FOCUS_BEFORE_DESCENDANTS); numberPicker.setValue(1); 常用方法 设置最大值 mNumberPicker.setMaxValue(10); //设置最大值，只能传入int 设置最小值 mNumberPicker.setMinValue(0); //设置最小值 设置当前值 mNumberPicker.setValue(5); //设置当前值 获取当前值 int value = mNumberPicker.getValue(); //获取当前值 getMaxValue()获取最大值 getMinValue()获取最小值 有一点需要注意的数值不能用负数。
获取设置的数据 String[] data = numberPicker.getDisplayedValues();//返回一组数据 获取/设置文本颜色、文本大小、固定颜色 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) { numberPicker.setTextColor(Color.RED);//设置所有的文本都是红色 numberPicker.setTextSize(20);//文字大小，这里最好使用px转dp numberPicker.setSelectionDividerHeight(40);//两道分割线的高度 } getTextColor getTextSize getSelectionDividerHeight 设置监听 NumberPicker有三个监听分别是OnValueChangeListener、OnScrollListener、Formatter
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d2e23d14cae7d3d26f73957cae06587/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fff6a0e1c5ca2009c3bb3960fef329c/" rel="bookmark">
			Spring Boot日志：从Logger到@Slf4j的探秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Spring Boot
二、日志
三、Logger
四、@Slf4j
一、Spring Boot Spring Boot是一个开源的Java框架，它简化了Spring应用程序的开发过程。它采用简洁的编码方式和约定优于配置的原则，使得开发者可以快速构建独立的、可部署的Spring应用程序。
Spring Boot提供了自动配置的特性，通过分析项目的依赖关系，它可以根据项目的需要自动配置Spring应用程序。这样开发者可以专注于业务逻辑的开发，而无需手动配置复杂的Spring框架。
Spring Boot还提供了一个用于构建独立的、可执行的Spring应用程序的内嵌式容器，比如Tomcat、Jetty等。这样开发者可以将应用程序打包成一个独立的可执行文件，方便部署和分发。
Spring Boot还提供了丰富的开发工具和插件，简化了项目的构建和部署过程。它集成了常用的开发框架和技术，比如Spring MVC、Spring Data JPA、Thymeleaf等，使得开发者可以快速搭建起一个功能完善的应用程序。
总的来说，Spring Boot是一个使得Spring应用程序开发更加简单、快速和高效的框架，它极大地提高了开发效率，减少了开发人员的工作量，是Java开发的一种优秀选择。
二、日志 SpringBoot日志是指在SpringBoot应用程序中记录和管理日志的机制。日志是应用程序开发和运维中非常重要的一部分，它可以帮助开发者和运维人员追踪应用程序的运行状态、排查错误和分析性能问题。
SpringBoot提供了对多种日志框架的集成支持，包括常用的Logback、Log4j2和Java Util Logging等。开发者可以根据自己的需求选择和配置适合的日志框架。
SpringBoot的日志配置非常灵活，通过简单的配置文件或注解即可实现日志的输出和管理。常见的日志配置包括日志级别、输出格式、输出位置、日志文件切割等。
SpringBoot还提供了一些特殊的日志注解，如@Slf4j注解，可以简化日志对象的创建和使用。
通过合理配置和使用SpringBoot日志，开发者可以方便地记录应用程序的运行日志，包括调试信息、错误信息、性能信息等。同时，通过日志记录的信息，开发者还可以更好地进行应用程序的调优和问题排查。
总结来说，SpringBoot日志是在SpringBoot应用程序中记录和管理日志的机制，它是应用程序开发和运维中非常重要的一部分，可以帮助开发者和运维人员追踪应用程序的运行状态、排查错误和分析性能问题。
三、Logger Logger是一个日志记录器，用于在应用程序中记录日志信息。它是日志框架的核心组件之一。Logger提供了一组方法，开发者可以使用这些方法来记录不同级别的日志信息，如调试信息、警告信息、错误信息等。
Logger通常与日志级别(Level)相关联，每个日志级别对应着一种不同的信息重要性。常见的日志级别包括TRACE、DEBUG、INFO、WARN和ERROR等。开发者可以根据需求选择适当的日志级别，从而控制日志输出的详细程度。
Logger还允许开发者为日志信息指定不同的输出目的地，比如控制台、文件、数据库等。开发者可以通过配置文件或代码的方式指定日志输出的位置和格式。
Logger的使用非常简单，开发者只需获取到Logger对象，然后调用相应的方法记录日志信息即可。典型的记录日志的方法包括log.debug()、log.info()、log.warn()和log.error()等。
使用Logger记录日志的好处包括：
可以追踪应用程序的运行状态，包括调试信息、异常信息等。可以帮助开发者排查错误和分析性能问题。可以提供应用程序的运行日志，便于日后回溯和审查。 总结来说，Logger是一个用于在应用程序中记录日志信息的组件，它允许开发者根据需要记录不同级别的日志信息，并将其输出到指定的位置。使用Logger可以提供有价值的运行日志，方便开发者排查错误和分析应用程序的性能。
四、@Slf4j @Slf4j是一个注解,用于简化在Java类中创建Logger对象的过程。它是Lombok库提供的一个注解,通过在类上加上@Slf4j注解,开发者可以自动在类中生成一个名为log的Logger对象。使用@Slf4j注解后,开发者可以直接通过log对象来记录日志信息,而无需手动创建Logger对象。
@Slf4j注解与常见的日志框架,如Logback、Log4j等配合使用,可以方便地在应用程序中记录和管理日志。它提供了一组与Logger对象相对应的方法,如log.debug()、log.info()、log.warn()和log.error()等。开发者可以根据需要选择适当的方法来记录不同级别的日志信息。@Slf4j注解还可以自动帮助开发者生成私有的、静态的Logger对象,并为其设置相应的名称。这样,开发者就可以在类中任何地方使用log对象来记录日志,而无需每次都手动创建Logger对象。
@Slf4j注解的使用非常简单,只需要在类上加上@Slf4j注解即可。开发者还需要在项目的构建工具中引入Lombok库的依赖,以使得注解生效。同时,也可以根据需要配置Logger的级别、输出位置、格式等。
总结来说,@Slf4j是一个注解,用于简化在Java类中创建Logger对象的过程。它通过自动生成Logger对象,使得开发者可以方便地在类中记录和管理日志信息。使用@Slf4j注解可以减少重复的代码,提高开发效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c53655d2e5bcfa499729119db17c59f0/" rel="bookmark">
			浅谈Linux文件系统逻辑结构图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件系统概念分两种：
1.静态的文件系统，就是躺在储存设备中文件和目录的集合
2.就是动态的文件系统，指的是被进程挂载后的文件系统，这时文件系统存储分为两部分，躺在磁盘中的文件和目录的集合，已经在内存高速缓冲区中的一个镜像。我们在操作文件系统时基本上就是在高速缓冲区中操作文件系统。
因此，要理解文件系统就需要将文件系统同进程结合起来理解。
进程控制块的task_struct中有两个结构体指针同文件系统相关联，分别是fs和file。fs指向fs_struct，而file指向files_struct 结构体。下面分别解释这两个结构体。
fs_struct结构体中root指向本进程的“根目录”，即root所指向的dentry结构体代表着本进程的“根目录”，也就是当用户登录进入系统时所“看到”的根目录。pwd则指向进程当前所在的目录，即在shell中使用命令“pwd"所看到的目录。
而files_struct结构体中保存着该进程已经打开的文件数组fd_arrays[fid],我们在程序中使用open命令打开的文件就会保存在这个数组中。毫无疑问数组成员files用来描述打开的文件信息。她包括该文件的目录信息dentry和操作该文件的函数结构体files_operations.通过dentry可以找到文件的inode节点进而找到保存文件数据的逻辑块。而对该文件操作的函数方法着保存在files_operations中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e31d2656d8897e7015aef8a2b5b31f9/" rel="bookmark">
			关于我花费六千多组了台window&#43;Linux主机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一边学习，一边总结，一边分享！
写在前面 我在2023年12月组了一台“洋垃圾”的主机，一边当做台式机使用，一边当做服务器使用。这个方案算是相对比较划算的方案。我开始是打算直接单做服务器使用的，以及内存配的很高，但是后面和同事一起商量后，还是接受了后面的方案。大家，若有类似的需求可以自己也组一台类似的主机。
后面我们会把我组的这台机子的详细配置和金额罗列出来，供大家参考。
**注意：**若是你身边没有电脑大神，尽量不要组“洋垃圾”，或是你直接让商家给你弄好后发过来。自己拿到手后直接使用…，自己组电脑真的很磨人。
若我们的分享对你有用，希望您可以点赞+收藏+转发，这是对小杜最大的支持。
原文链接：关于我花费六千多组了台window+Linux主机 配置： CUP：E5 2690 v4 *2，共18核，56线程主板：浪潮x99主板内存：DRR4 16G * 8，共128G显卡：微星3070 8G系统盘：致钛 1T，储存盘：银河 X18 12T *2机箱：坦克先马3机箱电源：800W电源 价格 CPU、主板、内存、电源和机箱（还有2张PCIE转M.2的卡）是在一家购买：共2600元左右显卡（微星3070 8G）:2094元致钛 1T：379元左右吧银河 X18 12T * 2：804元 * 2 实际机子的价格不贵，但是在中途发生的事情很老火，来回退、换配件弄了3次[泪目]。不知道，我这次是运气问题还是怎么回事，我同事也是在这家店购买的，他的没有问题。唉，算上运费，也是不小的开销。若是你运气好，基本就是一次成功。
CUP 志强CUP主要适用于服务器的，我们现在淘来的，主打一个性价比。2690 v4的CUP主要缺点就是单核性能太弱，线程数少一点等。这里，若是价格以及商家有货的话，我推荐使用E5 2697A V4的CUP，16核，睿频：2.6G。我开始是想要这个CUP的，但商家这里缺货。
主板 我这个这个主板最大的优点是，内存卡槽共有20个，最大可以插64G * 20，PCIE槽共6个，3个PCIE×8，SATA接口共10个，从主板这些上看算是很有性价比的。但是，这是我的噩梦开始，不是很建议购买，大家若是资金允许的话，还是建议购买超微的主板,是此浪潮主板的2倍价。但是，像我这样主机来回折腾还算是少数吧。我们后面的猜测，主要由于我们个人不知道浪潮主板的特性，以及商家客服的不专业。这也只是后面我们这边最终无奈的总结。
显卡 显卡，商家也不知道是矿卡还是网吧淘汰下来的。说是，来源不知道，但是质保1年，7天无理由退换。也算是二手商家中比较靠谱的吧（PS：自己咨询和退换中直觉）。对于显卡的话，大家若是考虑性价比，那么可以直接购买涡轮卡2080 Ti，我们同事使用的这张卡，跑分可以差不多是50W+,但是对于涡轮卡，主要的缺点就是：噪声大。尤其是发热后，风扇转的飞快。我这张卡，跑分在45W左右，对于非游戏人来说，绰绰有余。这张卡，不使用的时候，温度在30-35℃左右，风扇是不转的。显卡的选择因人而异，若是你对其要求不高，完全可以选择一个1000以内的卡即可。显卡的性能如下图所示，仅供参考：
系统盘及储存 1. 系统盘
我选择致钛作为系统盘，还是选择相对比较靠谱的，对于我们配的主机，不需要选择那些很贵的M.2盘，主打一个性价比，主要主板的规格就限定了速度。
2. 储存盘
储存盘的话，可以使用m.2硬盘，可以购买PCIE拆分卡，一拖二或四之类的即可，注意：要购买PCIE卡，请先看你的主板是否支持PCIE拆分，若不支持，PCIE拆分卡是不能使用的。
对于大容量储存，我这边依旧是推荐使用机械硬盘。但是对于机械硬盘的选择就看你个人，自己这里购买是从PDD上购买的，商家是说非国产，零通电，店保3年（PS：但是，我们也不知道3年时间，购买的商家是否还存活着呢？）以及国产，质保5年（官方2年+店保3年），这里面的水很深，请自己看好后再下单。
对于咸鱼购买，这个水就更深了，我自己也在咸鱼购买和出售物品，对应硬盘，不建议在其购买，购买了2次，都是不能使用的。其中一次卖家号不久前被封了，硬盘也坏了。若是，在咸鱼购买物品，要么购买那些专做咸鱼的卖家，要么去购买那些个人卖家。这个靠不靠谱就需要自己来分辨，总之一句话：不要贪图小便宜，购买那些价格合理的物品。
3. 磁盘阵列
我开始组服务器时，硬盘是打算组整列的。预期是组raid5，也购买的阵列卡，以及购买了3个12T的机械硬盘。但是，我购买的卡应该是太低端了，组的raid5速度实在是太慢了，仅有单个盘的1/2的速度，没错，只是这个速度。若是以raid5阵列速度应该在盘速度×2，我12T的盘速度在200-250M/s左右，正常的话应该在400-450M/s。so，最终阵列卡不要了，服务器只给单个硬盘。
4. 我的硬盘分配
1T系统盘，12T window储存盘，12T Linux挂载盘。
我的Linux盘是直接挂载上去的，因此，12T也应该够个人使用了。
window储存盘，就只是储存我的个人数据。我的数据会分别储存在3个设备中。2台主机和1台NAS，以及都进行同步。分别放在办公室和宿舍中。这样也进一步保证，我数据丢失的发生。NAS中，自己组了raid5阵列，应该也不会同时发生2块盘损坏的情况吧。
避坑小能手 若大家购买浪潮主板x99主板，请切记，浪潮主板若是按了显卡，信号输出只会从显卡中输出，集显是不会输出信号的，以及集显输出的信号会一直显示自检不过的位置。
我们第一次，就是由于按了显卡后无法进入BIOS，一直卡在这个位置，以为是主板有问题…
这些直到，第三次拿到后，也还不知道，一直到马上崩溃了，以及要退货了，在退货前一晚才知道。
我们的客服真的很无语，我猜，这个主板这样的问题，不只我一个人遇到，应该是很多人都遇到。
在我们购买类似的“洋垃圾”时，最好身边有对计算机相对较好的人，不然自己弄真的很困难。其次，对于商家客服的专业性需要进行质疑，请及时与客服进行沟通，以及咨询如何解决。
电脑配置信息 往期文章： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e31d2656d8897e7015aef8a2b5b31f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8294b0dffcb9cd9805e0db2a5cd008c7/" rel="bookmark">
			利用ArcGIS探究环境与生态因子对水体、土壤、大气污染物等影响的实践技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如何利用ArcGIS实现电子地图可视化表达？如何利用ArcGIS分析空间数据？如何利用ArcGIS提升SCI论文的层次？制图是地理数据展现的直观形式，也是地理数据应用的必要基础。本次课程从ArcGIS的基本操作、ArcGIS 的空间数据分析及ArcGIS 的高级制图技术，带领大家从掌握ArcGIS的基本操作到熟练应用ArcGIS的各种功能，为电子地图绘制、数据分析和SCI写作提供帮助。
为了能够熟练应用ArcGIS，往往需要经过大量系统的学习，入门过程漫长，甚至会走很多弯路。本次课程将通过3天的学习，由浅入深，一步一步讲解ArcGIS的各种应用模块和工具操作，并通过多个典型实例来指导学员高效地完成数据处理和高级制图。是为地理信息系统和 ArcGIS 初学者+中阶操作课程准备，不需要学员具备系统的 ArcGIS 知识基础。
1、理解GIS的基本概念；
2、掌握ArcGIS的基本操作；
3、掌握ArcGIS高级制图技术；
4、掌握ArcGIS的模型构建；
5、掌握ArcGIS空间统计和数据分析方法；
6、熟练应用ArcGIS进行数据评价。
第一部分
1.1 ArcGIS软件界面及操作逻辑
1.2 ArcGIS数据制备+数据集/属性表操作
1.3 案例练习+问题交流讨论
1.4 ArcGIS坐标系详解+矢量数据编辑及分析
1.5 矢量坐标空间校正+栅格数据地理配准
1.6 采样示意图的制作练习及答疑
第二部分
2.1 基于DEM的表面分析和水文分析
2.2 地统计、空间插值功能详解：全国降雨分布图的制作
2.3 案例练习+问题交流讨论
2.4 基于ArcGIS的空间统计：热点/冷点分析+空间自相关分析
2.5 基于ArcGIS的回归分析：地理加权回归
2.6 污染物空间格局预测制图/练习及答疑
第三部分
3.1 土地利用数据的获取及分析+土地利用转移矩阵的构建
3.2 基于土地利用量化人类活动的模型分析
3.3 案例练习+问题交流讨论
3.4 栅格数据的有效提取、渔网构建、缓冲区分析、欧氏距离及重分类
3.5 用地适宜性评价体系及权重的构建
3.6 土地利用+人类活动模型练习及答疑
【案例展示】
1.基于DEM的表面分析和水文分析案例展示
2.人类活动对污染物分布格局的影响案例展示
3.空间可视化分析案例展示
4.地统计和空间统计分析案例展示
5.基于土地利用的人类活动模型案例展示
关注科研技术平台获取更多详情 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc3304c074c35e7140b26eb001a8ab73/" rel="bookmark">
			计算机等级考试在线答题小程序 毕业设计-附源码 68573
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
计算机等级考试在线答题小程序主要功能模块包括用户管理、考试动态、考试须知、在线考试、用户反馈等，采取面对对象的开发模式进行软件的开发和硬体的架设，能很好的满足实际使用的需求，完善了对应的软体架设以及程序编码的工作，采取Mysql作为后台数据的主要存储单元，采用Spring boot框架、JSP技术、Ajax技术进行业务系统的编码及其开发，实现了本系统的全部功能。本次报告，首先分析了研究的背景、作用、意义，为研究工作的合理性打下了基础。针对计算机等级考试在线答题小程序的各项需求以及技术问题进行分析，证明了系统开发的必要性和技术可行性，然后对设计系统需要使用的技术软件以及设计思想做了基本的介绍，最后来实现计算机等级考试在线答题小程序的部署运行使用它。
关键词：在线答题；Springboot框架；MySQL数据库
Springboot Computer Rank Examination Online Answering Applet
Abstract
The main functional modules of the online answering applet for computer grade examination include user management, examination dynamics, examination instructions, online examination, user feedback, etc. The object-oriented development mode is adopted for software development and hardware erection, which can well meet the needs of actual use, improve the corresponding software erection and program coding, take MySQL as the main storage unit of background data, and adopt Spring boot framework JSP technology, Ajax technology for business system coding and development, to achieve all the functions of the system.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc3304c074c35e7140b26eb001a8ab73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40f3ecf6a449835ac69eda7066ae2dbe/" rel="bookmark">
			Hive08_分区表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 分区表 1 概念： 分区表实际上就是对应一个 HDFS 文件系统上的独立的文件夹，该文件夹下是该分区所
有的数据文件。Hive 中的分区就是分目录，把一个大的数据集根据业务需要分割成小的数据
集。在查询时通过 WHERE 子句中的表达式选择查询所需要的指定的分区，这样的查询效率
会提高很多。
2 案例演示 1 创建分区表语法 hive (default)&gt; create table dept_par( deptno int, dname string, loc string ) partitioned by (day string) row format delimited fields terminated by '\t'; 注意：分区字段不能是表中已经存在的数据，可以将分区字段看作表的伪列。
2 加载数据到分区表中 （1） 数据准备
dept_20220401.log
10	ACCOUNTING	1700 20	RESEARCH	1800 dept_20220402.log
30	SALES	1900 40	OPERATIONS	1700 dept_20220403.log
50	TEST	2000 60	DEV	1900 （2） 加载数据
hive (default)&gt; load data local inpath '/usr/soft/datas/dept_20220401.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40f3ecf6a449835ac69eda7066ae2dbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d14a3d3b98ab2d41f2b75fbb7b18d108/" rel="bookmark">
			Ubuntu 22.04 安装cmake3.28
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cmake 3.28
Kitware APT Repository
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f994b771e1776f8f9b02139d3c2b5da5/" rel="bookmark">
			CentOS：安装gitlab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装依赖 yum install -y curl policycoreutils-python openssh-server #centos8没有policycoreutils-python yum源，不用管 2、启动ssh并设置为开机自启动 systemctl enable sshd systemctl start sshd 3、安装Postfix来发送通知邮件。 yum install postfix 4、设置Postfix开机自启动。 systemctl enable postfix 5、启动Postfix服务。 vim /etc/postfix/main.cf # 添加 inet_interfaces = all 保存退出运行：
sudo systemctl start postfix 6、下载gitlab wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el8/gitlab-ce-12.10.1-ce.0.el8.x86_64.rpm 7、安装 rpm -i gitlab-ce-10.0.0-ce.0.el7.x86_64.rpm 8、编辑ip和端口 vim /etc/gitlab/gitlab.rb #找到 external_url # 重新配置并启动 gitlab-ctl reconfigure gitlab-ctl restart # 开启 gitlab-ctl start # 关闭 gitlab-ctl stop 注意：警惕！双平台挖矿僵尸网络 Sysrv-hello 盯上用户 GitLab 服务器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb01da3ac18bcf77dcf732a57844377e/" rel="bookmark">
			Linux基础-vim操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		普通模式 使用vim的命令创建文件并进入时，默认为普通模式
此时不能进行·文件内容的书写
（使用vim命令进行文件的编辑时，如果没有该文件，则会自己进行创建）
插入模式 进入普通模式后，点击i，然后进入插入模式，可以进行文件内容的写入
然后按下按键”ESC“，可以返回普通模式
除了按键”i“，还可以使用”o“,"a","A"。从普通模式进入插入模式
可视化模式 在普通模式按下”v“，可进入可视化模式进行数据选取，然后继续操作之后就自动退出回普通模式
该模式的好处是可以对文件进行批量处理
末行模式 在普通模式下按下”ESC“可以从普通模式转为末行模式
在此模式下，可以进行文件的保存与文件的退出
：set nu 可以进行行数的显示
：w
对文件进行保存
：q
对文件进行退出
然后在后续添加”！“，可以进行强制操作
快捷方式 yy p 对文件进行单行复制粘贴
可以使用视图模式选取多行进行复制粘贴
dd 对单行进行删除
n+dd 一次删除n行
u 撤销操作，相当于windows中的ctrl+z
x 删除光标单个字
gg 光标位置提到文章前
G 光标位置转移到文章末尾
o 行首
ctrl+4 行尾
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/051b12164da90ad398a57dfe98a17a27/" rel="bookmark">
			【心得】PHP文件包含高级利用攻击面个人笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、nginx日志文件包含
二、临时文件包含
三、php的session文件包含
四、pear文件包含
五 、远程文件包含
文件包含 include "/var/www/html/flag.php";
一 文件名可控
$file=$_GET['file'];
include $file.".php"; //用php伪协议 ，可以使用data协议
二 文件后缀可控
$file=$_GET['file'];
include "/var/www/html/".$file; //不能使用伪协议了
/var/www/html/../../../../../flag
高级文件包含
一、nginx日志文件包含 nginx 可以认为它是http的一个服务器软件，提供了http服务 ，默认监听80端口
http://localhost/123.php?a=b
123.php 后缀是否是.php .就进行一次转发，转发到本地的127.0.0.1的9000端口
9000端口，是被另一个服务端软件监听，它提供解析php文件的服务，我们把这个软件，叫做php-fpm
专门解析php后缀的文件，执行里面代码，将执行结果交给nginx,再由nginx返回给http的客户端，这个客户端就是浏览器
http://localhost/123.jpg
123.jpg 非php后缀，那么由自己处理，nginx会找到web目录，读取123.jpg的内容，并返回给浏览器，同时告诉浏览器，我返回的
文件内容是一个jpg图片，你按照图片模式进行渲染，于是，浏览器页面上就能显示出一张图片出来
日志包含的前提条件
1 有文件名可控的文件包含点
2 有可以访问到的日志路径 默认nginx的日志路径为 /var/log/nginx/access.log
(linux默认日志路径：var/log)
例题1：web37
UA头里的php代码必须要一次性写对，如果出错，文件包含执行的时候会报fatal error不再向下解析后续再写入的php代码（环境被污染）
payload:
?file=../../../../../../var/log/nginx/access.log
UA:&lt;?php eval($_POST[1]);?&gt;
post:1=system('tac /f*');
二、临时文件包含 /tmp/php??????
文件包含，能否包含一个 /???/????????[@-[]]
答案是：不行 文件包含，是不支持通配符
我们明确的，得到这个临时目录下php开头的随机文件名字全称，然后我们就可以正常包含进去
默认情况，生命周期与php脚本一致，也就是说，脚本运行过程中，存在，脚本运行结束了，这个临时文件会被自动删除
突破点：
1 在php脚本运行过程中，包含临时文件
2 在脚本运行过程中，得到完整的临时文件名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/051b12164da90ad398a57dfe98a17a27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/222ef04f094755a324a206536b046367/" rel="bookmark">
			Springcloud 微服务实战笔记 Eureka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务治理 服务注册 在服务治理框架中，通常都会构建一个注册中心，每个服务单元向注册中心登记自己提供的服务，将主机与端口号、版本号、通信协议等一些附加信息告知注册中心，注册中心按服务名分类组织服务清单。当服务启动后，会向注册中心注册自己的服务，那么注册中心就会有一个服务清单。另外，服务注册中心还需要以心跳的方式去监测清单中的服务是否可用，若不可用需要从服务清单中剔除，达到排除故障服务的效果。
服务发现 由于在服务治理框架下运作，服务间的调用不再通过指定具体的实例地址来实现，而是通过向服务名发起请求调用实现。所以，服务调用方在调用服务提供方接口时候，并不知道具体的服务实例位置。因此，调用方需要向服务注册中心咨询服务，并获取所有服务的实例清单，以实现对具体服务实例的访问。框架为了性能等因素，不会采用每次都向服务注册中心获取服务方式，并且不同的应用场景在缓存和服务剔除等机制上也会有一些不同的实现策略。
服务治理机制 服务治理是如何运作的？
●“服务注册中心-1”和“服务注册中心-2”，它们互相注册组成了高可用集群。 ●“服务提供者”启动了两个实例，一个注册到“服务注册中心-1”上，另外一个注册到“服务注册中心-2”上。 ●还有两个“服务消费者”，它们也都分别只指向了一个注册中心。
服务提供者 服务注册 “服务提供者”在启动的时候会通过发送REST请求的方式将自己注册到Eureka Server上，同时带上了自身服务的一些元数据信息。Eureka Server接收到这个REST请求之后，将元数据信息存储在一个双层结构Map中，其中第一层的key是服务名，第二层的key是具体服务的实例名。
服务同步 如架构图中所示，这里的两个服务提供者分别注册到了两个不同的服务注册中心上，也就是说，它们的信息分别被两个服务注册中心所维护。此时，由于服务注册中心之间因互相注册为服务，当服务提供者发送注册请求到一个服务注册中心时，它会将该请求转发给集群中相连的其他注册中心，从而实现注册中心之间的服务同步。通过服务同步，两个服务提供者的服务信息就可以通过这两台服务注册中心中的任意一台获取到。
服务续约 在注册完服务之后，服务提供者会维护一个心跳用来持续告诉Eureka Server:“我还活着”，以防止 Eureka Server 的“剔除任务”将该服务实例从服务列表中排除出去，我们称该操作为服务续约（Renew）。
关于服务续约有两个重要属性，我们可以关注并根据需要来进行调整：
eureka.instance.lease-renewal-interval-in-seconds=30 // 定义服务续 约 任 务 的 调 用 间 隔 时 间 ， 默 认 为 30 秒 eureka.instance.lease-expiration-duration-in-seconds=90 // 定义服务失效的时间，默认为90秒
服务消费者 获取服务 到这里，在服务注册中心已经注册了一个服务，并且该服务有两个实例。当我们启动服务消费者的时候，它会发送一个 REST 请求给服务注册中心，来获取上面注册的服务清单。为了性能考虑，EurekaServer会维护一份只读的服务清单来返回给客户端，同时该缓存清单会每隔30秒更新一次。
获取服务是服务消费者的基础，所以必须确保eureka.client.fetchregistry=true参数没有被修改成false，该值默认为true。
若希望修改缓存清 单 的 更 新 时 间 ， 可 以 通 过 eureka.client.registry-fetch-intervalseconds=30参数进行修改，该参数默认值为30，单位为秒。
服务调用 服务消费者在获取服务清单后，通过服务名可以获得具体提供服务的实例名和该实例的元数据信息。因为有这些服务实例的详细信息，所以客户端可以根据自己的需要决定具体调用哪个实例，在Ribbon中会默认采用轮询的方式进行调用，从而实现客户端的负载均衡。
服务下线 在系统运行过程中必然会面临关闭或重启服务的某个实例的情况，在服务关闭期间，我们自然不希望客户端会继续调用关闭了的实例。所以在客户端程序中，当服务实例进行正常的关闭操作时，它会触发一个服务下线的REST请求给Eureka Server，告诉服务注册中心：“我要下线了”。服务端在接收到请求之后，将该服务状态置为下线（DOWN），并把该下线事件传播出去。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/222ef04f094755a324a206536b046367/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b18401547541c5793ca43c23c6f767f/" rel="bookmark">
			usb qmi wwan拨号方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、驱动编译及安装 代码位置：drivers/net/usb/qmi_wwan.c
需要在static const struct usb_device_id products[] = {}中添加usb device的pid、vid.
modprobe usbnet
modprobe cdc-wdm
insmod ./qmi_wwan.ko 编译：在makefile中修改，编译为ko，及obj-m += qmi_wwan.o
此时，通过ifconfig查看会多出来一张网卡：
wwan0 Link encap:Ethernet HWaddr da:1c:f5:1a:2d:ac BROADCAST NOARP MULTICAST MTU:1500 Metric:1
RX packets:0 errors:0 dropped:0 overruns:0 frame:0
TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B)
同时dev下有cdc-wdm0节点生成。
2、配置APN echo APN=3gnet &gt;&gt; /etc/qmi-network.conf
3、开始拨号 qmi-network /dev/cdc-wdm0 start
udhcpc -i wwan0 //获取ip
4、断开拨号 qmi-network /dev/cdc-wdm0 stop
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b18401547541c5793ca43c23c6f767f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eb63327937520dbad384e717895d30b/" rel="bookmark">
			解决 svn: Can‘t read stdin:End of file found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jenkins 使用svn 的hook 去触发自动构建的过程中发现报错
svn:E070014 Can’t read stdin:End of file found
报错是通过svn checkout 工程过程中带账号密码的行为出现的
svn co http://svn.xxx.com:xxx/reps/xxx --user xxx --password xxx
发现是cache 问题，修改命令解决
svn co http://svn.xxx.com:xxx/reps/xxx --user xxx --password xxx --no-auth-cache
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f50ee3d38531c2c185be7f537e9ab447/" rel="bookmark">
			【Web】CTFSHOW元旦水友赛部分wp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
①easy_include
②easy_web
③easy_login
web一共5题，我出了3题，巧的是好像师傅们也只出了3题，跨年拿旗还是很快乐的，下面直接贴出自己的wp.
①easy_include pearcmd不解释
这里主要是 ，file://协议支持以file://localhost/etc/hosts的方式访问服务器文件,来绕过开头必须是字母的限制
②easy_web 代码审计，大致思路是通过构造pop链实现class Chu0_write类中的eval函数RCE
首先传参是show_show.show，php变量名只能是数字字母下划线，传进去的变量名会将 , +,.,[等符号转换成_，若变量中有. 号，可以用[替换_后，之后的字符不会再被替换成_
构造的参数是show[show.show
有两个waf
第一个waf1是用urlencode绕过，即不会出现字母字符，注意是对$_REQUEST进行waf判断的，request的顺序：GET&lt;POST，因此绕过的思路只需要同时POST一个相同参数对应数字即可绕过%73%68%6f%77[%73%68%6f%77.%73%68%6f%77=1&amp;chu0=1&amp;name=1&amp;cmd=1
第二个waf2不能出现show，那么用base64-encode --&gt; utf-8 -&gt; utf-16 --&gt; convert.quoted-printable-decode绕过，我们编写个脚本
$content='ctfshowshowshowwww'.$_GET['chu0'];
chu0参数需要传system，按照下面的脚本
&lt;?php $b ='system'; $payload = iconv('utf-8', 'utf-16', base64_encode($b)); file_put_contents('payload.txt', quoted_printable_encode($payload)); $s = file_get_contents('payload.txt'); $s = preg_replace('/=\r\n/', '', $s); echo $s; 运行后得到c=003=00l=00z=00d=00G=00V=00t=00
现在来构造序列化链
首先__wakeup()方法中有一个throw new Exception("fastfast");，回强制GC回收导致__destruct魔术方法不起作用从而触发不了其他魔术方法，
使用数组绕过。详解见ctfshow 第三届愚人杯 easy_php_愚人杯3rd [easy_php]-CSDN博客的ctfshow 第三届愚人杯 easy_php
&lt;?php highlight_file(__file__); class ctf{ public $h1; public $h2; public function __wakeup(){ throw new Exception("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f50ee3d38531c2c185be7f537e9ab447/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c63179f5277ea93b6cedca97b619fa6a/" rel="bookmark">
			从信号处理角度彻底理解FFT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只想速览公式可以转到简明FFT公式
一、FFT起初用于解决的问题 分解复合信号
将复合信号视为若干正弦波与余弦波的叠加，如何得知某个正弦波/余弦波在该信号中的强度？
二、即答 用特定频率的正弦波/余弦波（设其为a）乘上复合信号即可
由三角函数系的正交性，对于复合信号中频率不同于a的波，与a相乘的结果在一个周期内积分为0；而对于频率与a相同的波，乘积在一个周期上的积分结果不为0，由此可以得到a在复合信号中的强度。（类似于码分多路复用，不知道不碍事，和FFT没关系）（不用担心相位问题，相位不为0的波可以分解成余弦波和正弦波）
图中左上（记为图1），蓝的是原始信号，红的是给定频率的正弦波/余弦波a，是信号强度关于时间的函数（AKA时域）。图中左下（记为图2）是原始信号与a的乘积。图中右侧（记为图3）是不同频率的信号在原始信号中的强度，是信号强度关于频率的函数（AKA频域）。
如果某频率不存在于原始信号中，那么乘积的积分结果为0，对应于图3函数值接近于0的部分；如果某频率存在于原始信号中，那么乘积的积分结果不为0.对应于图3的峰值。
由图1中的蓝色曲线变成图3，这样的变换称为傅里叶变换（FT, Fourier Transform），也称由时域转换为频域；反之，为逆傅里叶变换（IFT, Inverse Fourier Transform），由频域转为时域。
那么把所有频率的正弦波和余弦波都和复合信号相乘再积分就好了，但这显然不现实
三、数学建模 1. 涉及到正弦波与余弦波 想到用欧拉公式，那么只用将信号乘上对应不同频率信号的指数就好
欧拉公式： e i x = c o s x + i s i n x e^{ix}=cosx+isinx eix=cosx+isinx
由于信号是关于时间的函数，并且和频率有关，因此写作 e i ω t e^{i\omega t} eiωt，其中 ω \omega ω与频率f有关
问题变成： F ( f ) = ∫ − ∞ ∞ f ( t ) e − i ω t d t F(f)=\int_{-\infty}^{\infty} f(t) e^{-i \omega t} d t F(f)=∫−∞∞​f(t)e−iωtdt， f ( t ) f(t) f(t)指原始信号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c63179f5277ea93b6cedca97b619fa6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2920e0b3ec04af3795fcc7b6fd1cafe9/" rel="bookmark">
			Kubernetes 100个常用命令！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章是关于使用 Kubectl 进行 Kubernetes 诊断的指南。
列出了 100 个 Kubectl 命令，这些命令对于诊断 Kubernetes 集群中的问题非常有用。这些问题包括但不限于：
• 集群信息
• Pod 诊断
• 服务诊断
• 部署诊断
• 网络诊断
• 持久卷和持久卷声明诊断
• 资源使用情况
• 安全和授权
• 节点故障排除
• 其他诊断命令：文章还提到了许多其他命令，如资源扩展和自动扩展、作业和定时作业诊断、Pod 亲和性和反亲和性规则、RBAC 和安全、服务账号诊断、节点排空和取消排空、资源清理等。
图片
集群信息：
显示 Kubernetes 版本：kubectl version
显示集群信息：kubectl cluster-info
列出集群中的所有节点：kubectl get nodes
查看一个具体的节点详情：kubectl describe node 列出所有命名空间：kubectl get namespaces
列出所有命名空间中的所有 pod：kubectl get pods --all-namespaces
Pod 诊断：
列出特定命名空间中的 pod：kubectl get pods -n 查看一个 Pod 详情：kubectl describe pod -n 查看 Pod 日志：kubectl logs -n 尾部 Pod 日志：kubectl logs -f -n 在 pod 中执行命令：kubectl exec -it -n – Pod 健康检查：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2920e0b3ec04af3795fcc7b6fd1cafe9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e595242b6aadc324cde227bcdb79060c/" rel="bookmark">
			【谷歌云】注册谷歌云 &amp; 创建Compute Engine
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Google Cloud注册1.1 账号信息1.2 付款信息验证1.3 验证成功 二、Compute Engine创建2.1 启动Compute Engine API2.2 创建实例2.3 新建虚拟机实例2.4 等待实例创建完成2.5 查看虚拟机配置信息2.6 创建防火墙规则2.7 SSH远程连接虚拟机 三、参考链接 一、Google Cloud注册 1.1 账号信息 选择所在的国家/地区 1.2 付款信息验证 创建付款资料
账号类型：个人付款方式：添加外币卡或符合条件的银行卡填写所在地区的居住地址信息 完成验证。
1.3 验证成功 二、Compute Engine创建 2.1 启动Compute Engine API 2.2 创建实例 2.3 新建虚拟机实例 2.4 等待实例创建完成 2.5 查看虚拟机配置信息 2.6 创建防火墙规则 导航至防火墙。
允许被指定入站的端口的通行。
防火墙规则详细信息。
2.7 SSH远程连接虚拟机 三、参考链接 🔴🟡🟢https://cloud.google.com/compute?hl=zh-cn&amp;_ga=2.11152948.-1601988297.1704092521
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6884f2b84474cb49a036bde91b0fff0a/" rel="bookmark">
			两个眼前一亮的工作！已开源，可在线体验！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是阿潘，2024 年，新年首个工作日，公司引来组织架构调整，两个工程师和一个产品并入业务线，直面业务大佬的压榨！
第一天就搞大事情，希望新的一年，我们都能迎来爆发的一年！顺便聊下最近爆火的一些开源项目。
1、HandRefiner 上图：Stable Diffusion（前两行）和 SDXL（最后一行）生成畸形的手（每对左侧），例如手指数量不正确或形状不规则的问题，可以通过 HandRefiner 有效纠正（每对右侧） 。
作者引入了一种名为 HandRefiner 的轻量级后处理解决方案，用于纠正生成图像中畸形的手。HandRefiner 采用有条件修复方法来纠正畸形的手，同时保持图像的其他部分不变。利用手部网格重建模型，该模型始终遵循正确的手指数量和手部形状，同时还能够在生成的图像中拟合所需的手部姿势。鉴于由于手部畸形而生成的失败图像，我们利用 ControlNet 模块重新注入此类正确的手部信息。此外，当我们改变控制强度时，我们发现了 ControlNet 中的相变现象。它使我们能够利用更容易获得的合成数据，而不会受到现实和合成手之间的领域差距的影响。
更多可视化效果：
项目地址：
https://github.com/wenquanlu/HandRefiner
https://huggingface.co/hr16/ControlNet-HandRefiner-pruned
2、AnyText 阿里最新开源工作，主要解决AI绘画文字生成不够真实的问题。AnyText，一种基于扩散的多语言视觉文本生成和编辑模型，专注于在图像中渲染准确且连贯的文本。
关于功能，我们与其他竞争对手的区别有五个因素，如表 1 所示：
a) 多行：AnyText 可以在用户指定的位置生成多行文本。 b) 变形区域：可以在水平、垂直、甚至弯曲或不规则区域进行书写。 c) 多语言：我们的方法可以生成多种语言的文本，如中文、英语、日语、韩语等。
d) 文本编辑：提供以一致的字体样式修改所提供图像内的文本内容的能力。 e) 即插即用：AnyText 可以与稳定的扩散模型无缝集成，并赋予其生成文本的能力。
除此之外，作者还贡献了第一个大规模多语言文本图像数据集 AnyWord-3M，其中包含 300 万个带有多种语言 OCR 注释的图像文本对。
和其他模型效果对比：
测试，这里展示使用文字生成的方案：
根据官方的使用说明，需要输入两个东西：
1）一个prompt 提示词，并将包含的文字用双引号包裹
2）指定文字放置的区域，支持（手动绘制、矩形框或随机生成）
点击运行:
项目地址：
https://github.com/tyxsspa/anytext
在线体验：
https://modelscope.cn/studios/damo/studio_anytext
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75433f01b62e8157f326202c78a57789/" rel="bookmark">
			javaString类三点注意--学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		String是不可变字符串对象，改变String的值只会创建一个新对象，不会改变原来指向的对象，若原来指向的对象没有其它变量引用，则会被系统回收只要是以"字符串"创建的字符串对象，会存储到字符串常量池中，且相同内容的字符串只会存储一份
例如 String a = "abc"; String b = "abc"; 以上代码中，a和b实际上都是指向同一个字符串，又因字符串不可变，所以这种存储方式可以节省很多内存
但以new方式创建的字符串对象，每new一次都会产生一个新对象存放在堆内存中
例如
char[] chs = {'a','b'.'c'}; String a = new String(chs); String b = new String(chs); 上面代码中，a与b指向的是不同的字符串对象
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a67b5f8629949c1cbc1e47e11e95b5e/" rel="bookmark">
			tyxsspa/AnyText 阿里生成文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dockerfile ################
# 使用 NVIDIA CUDA 11.8 开发环境作为基础镜像
FROM nvcr.io/nvidia/cuda:12.1.1-cudnn8-runtime-ubuntu22.04
# 设置非交互式安装模式以避免某些命令在构建过程中暂停
ENV DEBIAN_FRONTEND=noninteractive
# 更新软件包列表并安装基本工具
RUN apt-get update &amp;&amp; apt-get install -y wget git curl vim bzip2 &amp;&amp; apt-get install ffmpeg libsm6 libxext6 -y &amp;&amp; apt-get install libgl1 -y
# 下载 Anaconda 安装脚本
RUN wget https://repo.anaconda.com/archive/Anaconda3-2023.03-Linux-x86_64.sh
# 运行 Anaconda 安装脚本
RUN /bin/bash Anaconda3-2023.03-Linux-x86_64.sh -b -p /opt/conda
RUN rm Anaconda3-2023.03-Linux-x86_64.sh
# 将 conda 添加到 PATH，这样我们就可以直接使用它
ENV PATH /opt/conda/bin:$PATH
# 设置工作目录（可根据需要更改）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a67b5f8629949c1cbc1e47e11e95b5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d821b04dc055e08c800212c1b7037ff/" rel="bookmark">
			虚幻UE 材质-进阶边界混合之WAT世界对齐纹理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		边界混合前篇：虚幻UE 材质-边界混合之PDO像素深度偏移量
上一篇主要讲材质相似或者不同的两个物体之间的边界混合
这一篇主要讲自建材质且相同的两个物体之间的边界混合
文章目录 一、世界对齐纹理二、世界对齐纹理实验1、制作材质 三、进一步优化 一、世界对齐纹理 世界对齐纹理（WAT,World Aligned Texture）是一种特殊的纹理处理方式，用于将纹理贴图与实际物体表面对齐，使得纹理在渲染时能够正确地贴在物体表面上，实现更加真实和逼真的虚拟场景。
不依赖于物体UV坐标，直接使用世界坐标
方便做“背景”混合
其实现原理为：将贴图生成在一个统一的世界立方体之中，然后映射或者投影在物体表面。
举一个例子：
雪地里的井盖，按常理来说井盖被雪覆盖了薄薄的一层，且应该在指定位置有脚印。
通过这样描述，我们可以对井盖和地面使用同一样的材质，然后设置世界对齐纹理，这样井盖和地面的贴图生成在统一的世界立方体中，最后整体朝某个方向映射到物体表面。
最终效果简版效果：
移动井盖后：（井盖的材质没有固定，而是跟随环境的变化而变化）
二、世界对齐纹理实验 1、制作材质 首先我们指定我们需要做一个与背景地面相关的材质，所以我们创建一个材质：
材质文件创建好了，我们得对井盖进行分析，需要设置为背景雪地一样的材质，所以基础颜色需要设置为雪地纹理，且进行世界对其。
并把它赋给雪地和井盖，赋给雪地的原因是程序需要知道是哪些物体进行世界对其
但是发现贴图大小不对，调整贴图大小
这里有几个参数可以讲解一下：
输入1： Texture Object：这里之所以使用这个节点是因为把贴图转化成一个对象传入， 相当于一个容器，输入的是一个贴图对象， 而不仅仅是Texture Sample里面的颜色， 并且世界对其贴图的节点也是希望你传一个贴图对象。 输入2： Texture Size：这里是用一个矢量RGB来作为对应X、Y、Z轴， 默认矢量RGB为1、1、1，单位向量，这样控制起来很方便。 输出： XY / Z / XYZ Texture:这里是说明世界对齐的轴向选择， 如果为XY Texture： 下图展示，从z轴投影就是错误的贴图。 纹理大小调整后效果：
三、进一步优化 做到这里我们还可以对其进行优化，我们现在只是对基础颜色进行了世界对齐
我们还可以对粗糙度、法线进行世界对其，这样效果更加好了
注意：法线对应的是世界对齐法线节点
由于雪地贴图没有粗糙度纹理，所以这里可以不用连接，
这里只是举例如果有粗糙度纹理的情况下的做法
最后效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce9974035b40e9ea0d4848a04c9441b8/" rel="bookmark">
			VMware 虚拟机 ubuntu 20.04 硬盘扩容方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近由于需要编译 【RK3568】的 Linux SDK，发现 虚拟机默认的 200G 空间不足了，因此想增加这个 200G 空间的限制，通过网络上查找了一些方法，加上自己亲自验证，确认 硬盘扩容 正常，方法也比较的容易，所以做个笔记记录下来。 操作步骤如下 首先 VMware 虚拟机 ubuntu 20.04 需要 【关机】，而不是【挂起】，这里强烈建议进入 虚拟机 ubuntu 后，点击关机的 按钮进行关机，而不是通过 VMware 【电源】进行关机，VMware【电源关机】会产生一些影响，比如 【虚拟网卡】无法工作，导致虚拟机 ubuntu 20.04 无法联网，这个后面再写一个笔记。 VMware 点击 【编辑虚拟机设置】，进入 【虚拟机设置】，点击 【磁盘 SCSI】，右边有个 【扩展磁盘容量】，点击 【扩展】，我之前 200G，成功扩展为 400G了，当然可以继续扩展一下，比如扩展为 500G 进入 ubuntu 进行配置 需要开启 VMWare 中的虚拟机 ubuntu 20.04，然后进行 分区大小的调整（扩展容量），也就是 VMWare 扩展容量后，ubuntu 20.04 默认开机后，新扩展的容量需要调整分区后才能使用 这里建议使用 图形方式的分区调整工具进行扩展分区空间，这里使用 sudo apt-get install gparted 安装 gparted，然后 sudo gparted 运行 gparted 注意这里没有新建分区，因为新建的分区，还需要修改 系统的分区挂载表，否则每次开机无法挂载到系统，这里是【扩容】，也就是把 新增加的空间，追加到 现有的分区中，这里是 扩展分区 extended 类型的 /dev/sda5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce9974035b40e9ea0d4848a04c9441b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb800725f0e5b6d13b9d3b7101874093/" rel="bookmark">
			Github排名前10的Java Decompiler
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. jadx Jadx ：查看带有语法高亮的反编译代码、跳转到声明处、查找用法、全文搜索、Smali调试器等功能
Star：37.7k⭐️
项目地址：https://github.com/skylot/jadx
下载：https://github.com/skylot/jadx/releases/tag/v1.4.7
操作页面：
2. bytecode-viewer bytecode-viewer 是一款功能强大的Java反编译工具，支持简便的拖放式操作，适用于Java Jars和Android APKs，提供广泛的文件格式支持，内置6个Java反编译器和3个字节码反汇编器，包括Krakatau和Smali/BakSmali汇编器，支持APK/DEX文件，具备内置Java编译器、高级静态搜索功能、可定制的用户界面、插件和脚本引擎设计，以及恶意代码扫描API等特色功能，同时支持30多种语言翻译，提供导出为Runnable Jar、Zip、APK等多种功能
Star：14.1k⭐️
项目地址：https://github.com/Konloch/bytecode-viewer
下载：https://github.com/Konloch/bytecode-viewer/releases/tag/v2.12
操作页面：
3. jd-gui JD-GUI 是一个独立的图形实用工具，用于显示“.class”文件的Java源代码，可以使用JD-GUI浏览重构后的源代码，以便立即访问方法和字段。
Star：13.2k⭐️
项目地址：https://github.com/java-decompiler/jd-gui
下载：https://github.com/java-decompiler/jd-gui/releases/tag/v1.6.6
操作页面：
4. Recaf Recaf 是一款现代Java字节码编辑器，简化了Java程序的复杂性，包括常量池、栈帧、宽指令等
Star：5.4k⭐️
项目地址：https://github.com/Col-E/Recaf
下载：https://github.com/Col-E/Recaf/releases/tag/2.21.13
操作页面：
5. Luyten Luyten 是一个基于Procyon的开源Java反编译GUI
Star：4.9k⭐️
项目地址：https://github.com/deathmarine/Luyten
下载：https://github.com/deathmarine/Luyten/releases/tag/v0.5.4_Rebuilt_with_Latest_depenencies
6. GDA-android-reversing-Tool GDA-android-reversing-Tool 是最快且最强大的Android反编译工具（原生工具，无需Java虚拟机），支持APK、DEX、ODEX、OAT、JAR、AAR和CLASS文件。它具备恶意行为检测、隐私泄漏检测、漏洞检测、路径解决、打包器识别、变量跟踪、反混淆、Python和Java脚本、设备内存扩展等功能。
Star：3.7k⭐️
项目地址：https://github.com/charles2gan/GDA-android-reversing-Tool
下载：https://github.com/charles2gan/GDA-android-reversing-Tool/releases/tag/GDA4.10
备注：仅支持windows系统
7. fernflower Fernflower 是第一个真正可行的Java解析反编译器，可能也是针对高级编程语言的解析反编译器。
Star：3.1k⭐️
项目地址：https://github.com/fesh0r/fernflower
下载：无
命令：
java -jar fernflower.jar [-&lt;option&gt;=&lt;value&gt;]* [&lt;source&gt;]+ &lt;destination&gt; 8. Krakatau Krakatau 是一款强大的Java字节码汇编器和反汇编器，支持将二进制class文件转换为易读的文本格式，处理混淆代码，同时提供反编译器用于将Java二进制文件转换为可读源代码，专为处理混淆代码设计。
Star：1.9k⭐️
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb800725f0e5b6d13b9d3b7101874093/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c25d32f3f49411b47b963c90d26ab9e/" rel="bookmark">
			Python压缩图片大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天遇到一个问题，制作的网站因为图片尺寸比较大导致加载很慢，所以想通过压缩图片的方式来加快页面的加载速度（当然也可以选择cdn和oss的方式来加快页面加载速度）
话不多说，Python肯定是首选项嘛，那么PIL（Python Imaging Library）库肯定是要用到的，下面一起看下怎么操作吧
一、安装PIL库
pip install Pillow Pillow对python的版本有一定要求，详见下图：
二、检验是否安装成功
from PIL import Image print(Image.__version__) 三、打开图片
img = Image.open("test.jpg") # 如果文件不存在或格式不支持，会抛出异常。所以我们可以用try-except语句来捕获异常，并打印错误信息 try: img = Image.open("test.jpg") except IOError as e: print(e) 四、保存图片
img.save("new.jpg") # 如果要指定保存的格式，可以传入format参数，例如： img.save("new.png", format="PNG") # 如果要指定保存的质量，可以传入quality参数，取值范围是1-95，默认是75。质量越高，文件越大，压缩效果越差；质量越低，文件越小，压缩效果越好。例如： img.save("new.jpg", quality=50) 五、获取图片信息
在对图像进行压缩之前，我们可能需要获取一些图像的基本信息，例如大小、格式、模式等。这些信息可以通过Image对象的属性来获取
# size属性：返回一个元组，表示图像的宽度和高度（单位是像素），例如(800, 600) print(img.size) # (800, 600) # format属性：返回一个字符串，表示图像的格式，例如"JPEG" print(img.format) # JPEG # mode属性：返回一个字符串，表示图像的模式，例如"RGB" print(img.mode) # RGB 六、修改图片
如果要修改图像的大小、格式或模式，可以使用Image对象的方法
# resize方法：接受一个元组作为参数，表示新的宽度和高度（单位是像素），返回一个新的Image对象 new_img = img.resize((400, 300)) # convert方法：接受一个字符串作为参数，表示新的模式，返回一个新的Image对象 new_img = img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c25d32f3f49411b47b963c90d26ab9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f73059b7e581d2796b0e7b2d74023eb9/" rel="bookmark">
			UE5 VR版增强输入初体验 官方模板学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 我们传统的输入方式，是通过编辑器设置输入操作映射，然后BindAction和BindAxis绑定
这边插播一条增强输入知识点，参考知乎大佬文章
和增强输入的VR模板教学：如何使用VR模板在UE5中使用增强输入系统_哔哩哔哩_bilibili
实践操作 我们进入VR模板，通过一个jump案例，了解使用规则，首先新建一个Input Action，命名IA_JUMP。
然后我们在IMC_Default新建映射Jump，设置输入按键时Oculus的Touch A按键
我们在VR_Pawn蓝图里发现设置Mapping Context的方法，Add Mapping Context包含了Priority设置了输入的优先级别，可以在适当时候屏蔽某些输入，例如打开背包是按键E，但是同时Pawn可以和门有互动动作，也是按键E，这时候设置优先级（0是最高优先级），进行输入屏蔽，确保我们打开背包时，开不了门。
InputAction方法包含了下面这些状态，具体可以参考虚幻文档虚幻引擎中的增强输入 | 虚幻引擎5.1文档 (unrealengine.com)
触发状态 触发状态（Trigger State） 表示动作的当前状态，例如 已开始（Started） 、 进行中（Ongoing） 、 已触发（Triggered） 、 已完成（Completed） 和 已取消（Canceled） 。通常，你将使用"已触发"状态。你可以绑定到C++和蓝图中的特定状态。
已触发（Triggered）： 动作已触发。这意味着它完成了所有触发器要求的求值。例如，"按下并松开"触发器会在用户松开按键时发送。
已开始（Started）： 发生了开始触发器求值的某个事件。例如，"双击"触发器的第一次按下将调用"已开始"状态一次。
进行中（Ongoing）： 触发器仍在进行处理。例如，当用户按下按钮时，在达到指定持续时间之前，"按住"动作处于进行中状态。根据触发器，此事件将在收到输入值之后对动作求值时触发每次更新。
已完成（Completed）： 触发器求值过程已完成。
已取消（Canceled）： 触发已取消。例如，"按住"动作还没触发之前，用户就松开了按钮。
在VrPawn蓝图中中进行蓝图连连看，输出一个jump started的bebug文本
我们需要确保IMC_Default在PMI_VRTemplate被设置，下图所示，右侧一排数字表示默认的优先级顺序。
倒数第二步，我们需要确保项目设置中，这些参数正确设置。
最后成功输出文本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b611657d08bbb34af22f6555a52c397/" rel="bookmark">
			maven、springboot项目编译打包本地jar、第三方jar包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 引言 一般我们在maven项目中都是通过引入pom坐标的形式来引入第三方jar包，但某些场景下，第三方是直接提供的jar包文件，这就需要我们从本地引入第三方包并进行打包。所以我们今天来看下如何进行本地引入第三方包操作
1. 步骤 1、在项目下创建lib文件夹，或者其他文件夹，将第三方包放入该文件夹下
2、IDEA中执行快捷键F4，或手动进入Project Settings，在Libraries中点击添加jar包，选择我们刚刚引入的jar包
3、修改pom文件，指定第三方jar包文件，
这里注意要添加&lt;includeSystemScope&gt; true &lt;/includeSystemScope&gt;配置，这样才会在打包时加载本地的jar，否则会出现本地运行没问题，但编译打包出来就会报错找不到类
同时注意把&lt;mainClass&gt;中的&lt;skip&gt;调整成false, 否则引入的包不会一起打包出来
&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;!--配置本地jar包在项目的存放路径jar包--&gt; &lt;compilerArguments&gt; &lt;extdirs&gt;${project.basedir}/src/main/webapp/WEB-INF/lib&lt;/extdirs&gt; &lt;/compilerArguments&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;webResources&gt; &lt;resource&gt; &lt;!--配置本地jar包在项目中的存放路径-war包--&gt; &lt;directory&gt;src/main/webapp/WEB-INF/lib/&lt;/directory&gt; &lt;!--配置打包时jar包的存放路径--&gt; &lt;targetPath&gt;WEB-INF/lib&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/*.jar&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${spring-boot.version}&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;com.example.security_demo.SecurityDemoApplication&lt;/mainClass&gt; &lt;skip&gt;false&lt;/skip&gt; &lt;!-- 加入此配置，才会把本地的jar包也引进去 --&gt; &lt;includeSystemScope&gt; true &lt;/includeSystemScope&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 4、pom里添加刚刚引入的jar包，这里的systemPath路径就选择jar包所在的路径
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b611657d08bbb34af22f6555a52c397/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c66091ef1618a5834f041bf0bd56a8d/" rel="bookmark">
			Android13 热点默认5G频道配置修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android13 热点默认5G频道配置修改 文章目录 Android13 热点默认5G频道配置修改一、前言二、修改默认配置1、代码中修改默认配置2、保存默认配置文件设置默认5G频段配置热点配置文件完整信息示例： 3、代码中强制设置配置信息（1）在关键流程设置热点开启和关闭代码：热点启动流程热点启动关键流程： （2）在获取配置信息方法强制设置并返回，是否ok？ 三、其他1、Android13 热点默认5G频道配置修改总结2、之前写的热点相关知识汇总3、Android 设置默认热点名称和热点密码、密码长度4、Android11 热点开启流程5、Android11 热点配置信息保存分析6、Android 实现热点开机后自动开启 一、前言 Android开发中经常要设置默认热点，名称，热点密码，是否是5G频段。
之前也有对默认名称和密码进行分析的文章，但是热点频道没怎么看，热点频段对传输性能还是比较重要的，有的平台默认就要5G，查看代码发现默认是2.4G热点。
本文对 Android 默认热点5G频段配置 进行分析。
配置热点信息后，会生成热点配置文件：
wifi信息保存位置： /data/misc/apexdata/com.android.wifi/WifiConfigStore.xml 热点信息保存位置： /data/misc/apexdata/com.android.wifi/WifiConfigStoreSoftAp.xml 热点的信息文件包含了：热点名称，热点密码，热点频段和信道值等基本信息；
wifi 的信息文件包含了：连接过的wifi名称，密码，MAC地址等信息。
二、修改默认配置 1、代码中修改默认配置 系统中热点默认配置信息对象 WifiApConfigStore.java
实现思路：
在默认配置方法getDefaultApConfiguration() 中设置默认信息即可。
packages\modules\Wifi\service\java\com\android\server\wifi\WifiApConfigStore.java
import android.os.SystemProperties; //添加prop属性 public class WifiApConfigStore { private static final String TAG = "WifiApConfigStore"; //（1）获取默认配置信息方法，该方法在系统无法检测到默认配置文件时会生成 //系统第一次运行时会执行到,还有就是把系统热点配置文件删除后再重启也是会执行到 private SoftApConfiguration getDefaultApConfiguration() { SoftApConfiguration.Builder configBuilder = new SoftApConfiguration.Builder(); //configBuilder.setBand(generateDefaultBand(mContext)); //（2）原来的逻辑。2.4G热点 //（3）加个打印，查看默认的频段值 Log.d(TAG, "getDefaultApConfiguration generateDefaultBand = " + generateDefaultBand(mContext)); //（4）设置默认5G的一段逻辑，添加prop属性进行判断 boolean isDefault5G = SystemProperties.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c66091ef1618a5834f041bf0bd56a8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/429549e4e42759a037fdbfb029bd79d7/" rel="bookmark">
			neovim调试linux内核过程中索引不到对应头文件问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我叫徐锦桐，个人博客地址为www.xujintong.com，github地址为https://github.com/jintongxu。平时记录一下学习计算机过程中获取的知识，还有日常折腾的经验，欢迎大家访问。
一、环境 neovim–0.9.4
mason的clangd LSP
二、问题 当用nvim打开linux源码文件时候会出现下列的情况，找不到对应的结构定义，也索引不到对应的头文件，在对应结构按ctrl + ]也进入不了对应的结构。
三、解决 最后在Reddit上发了篇求助帖子，有个外国友人解决了这个问题。他给推荐了一篇文章Linux Kernel – How to setup your editor
注意： 默认已经安装好了Linux的编译环境。
首先编译内核 在linux源码根目录下运行下面命令，编译内核。
make menuconfig make CC=clang 注意： 如果是在ubuntu下编译内核，需要下载下面的依赖。
sudo apt install libncurses-dev flex bison openssl libssl-dev dkms libelf-dev libudev-dev libpci-dev libiberty-dev autoconf 生成compile_commands.json文件 也是在根目录运行。
python3 ./scripts/clang-tools/gen_compile_commands.py 然后打开nvim更新完成索引就行了。
我的neovim环境配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dde078b72cbc9608b2e9f640339bf377/" rel="bookmark">
			neovim调试xv6-riscv过程中索引不到对应头文件问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我叫徐锦桐，个人博客地址为www.xujintong.com，github地址为https://github.com/jintongxu。平时记录一下学习计算机过程中获取的知识，还有日常折腾的经验，欢迎大家访问。
和这篇文章neovim调试linux内核过程中索引不到对应头文件问题
出现的问题一样。
也是通过生成一个compile_commands.json文件来解决。
注意： 默认你已经安装完了xv6-riscv的编译环境。
生成compile_commands.json 安装bear sudo apt install bear 开始生成 在项目根目录下运行。
make clean &amp;&amp; bear make qemu 如果运行上面代码报错，那就运行下面这个代码。
make clean &amp;&amp; bear -- make qemu 然后就会在根目录生成一个compile_commands.json文件，之后打开nvim等待索引更新就ok了。
我的neovim配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54b8f2c7d0745d5bf6daea883ebab1ea/" rel="bookmark">
			Android ZXing二维码包含中文时乱码解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android ZXing二维码包含中文时乱码解决 文章目录 Android ZXing二维码包含中文时乱码解决一、前言二、ZXing 把中文字符串生成二维码扫描后显示问号解决1、Zxing 的简单使用2、源码上的编译的项目二维码乱码修改 二、其他1、查看字符串编码：2、字符串设置编码：3、是否utf-8字符串4、网上其他的处理方式 一、前言 ZXing就不过多介绍了，就是可以可以扫描二维码获取里面字符串和把字符串生成二维码的小框架。
本文记录一下源码编译中，ZXing 在源码编译后，包含中文字符串的二维码出现问号乱码解决。
Android Studio中运行该app是没有这个问题的，那么有可能就是编译环境不同导致的。
二、ZXing 把中文字符串生成二维码扫描后显示问号解决 1、Zxing 的简单使用 ImageView imageView; //要显示二维码的控件 String string = "XXX"; // 二维码的字符串 //Zxing 工具类 MultiFormatWriter formatWriter = new MultiFormatWriter() BitMatrix matrix = formatWriter.encode(string, BarcodeFormat.QR_CODE, viewWidth, viewHeight); Bitmap bitmap = bitMatrix2Bitmap(string, matrix); imageView.setImageBitmap(bitmap); //设置二维码图片显示 //像素点确认的方法 public static Bitmap bitMatrix2Bitmap(BitMatrix matrix) { int w = matrix.getWidth(); int h = matrix.getHeight(); int[] rawData = new int[w * h]; for (int i = 0; i &lt; w; i++) { for (int j = 0; j &lt; h; j++) { int color = Color.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54b8f2c7d0745d5bf6daea883ebab1ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/580fedb552642b7f8c7ee353140de6e0/" rel="bookmark">
			虚幻UE 材质-边界混合之PDO像素深度偏移量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年的第一天！！！大家新年快乐！！！
可能是长大了才知道
当你过得一般
你的亲朋好友对你真正态度只可能是没有表露出来的冷嘲热讽了
希望大家新的一年平安、幸福、
永远活力满满地追求自己所想做的、爱做的！！！
今天就来篇简单的PDO像素深度偏移量
文章目录 一、PDO像素深度偏移量二、像素深度偏移实验三、Dither抖动 一、PDO像素深度偏移量 PDO像素深度偏移量（Pixel Depth Offset），用于处理模型与模型或模型与地形之间穿插衔接生硬时的过渡效果。 它的原理是将该材质所指定的模型的像素点剔除，但保留模型之后的像素点，从而可以制作出融合透明的效果。PDO在UE中主要用于处理一些细节的过渡和遮挡关系，以提高模型的视觉真实感和场景的逼真度。
像素深度：像素上的物体到摄影机的距离
如何观察虚幻内的像素/场景深度？
他就会以灰通道颜色的方式去展示像素深度，越深代表离屏幕越近。
二、像素深度偏移实验 场景中红色板子和蓝色板子都是1cm的厚度，中间间隔也是1cm的厚度。
如果我们把红色板子通过像素偏移2cm会是一个怎样的情况呢？
像素偏移值：2cm
像素偏移值：1.9cm
从这里可以看出，像素偏移就是在像素的层面上位移了多远距离达到的一个视差结果。
三、Dither抖动 抖动：让不同深度的像素产生混合效果——融合边缘
如下面的红色和蓝色的板子
如果在抖动的情况下进行像素偏移那么会有什么效果？
我们先分析一下， 统一的像素偏移使我们观察的颜色发生变化后不在变化， 抖动让我们的像素深度再次发生变化。 那么我们每一帧得到的颜色可能就不同，那么可能产生颜色叠加，Lerp的感觉。 可以看出抖动给像素偏移带来了颜色混合的感觉，使红色过渡蓝色有了过渡效果
从而达到边缘的过渡（值得一提的是如果两物体的材质相近的话过渡效果会非常好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5573f2d677b6bb837556e9ddec9f60b2/" rel="bookmark">
			Shell脚本学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 写在前面 工作中，需要用到写一些shell脚本去完成一些简单的重复性工作， 于是就想系统的学习下shell脚本的相关知识， 本篇文章是学习shell脚本整理的学习笔记，内容参考主要来自C语言中文网， 学习过程中， 加入了一些在学习过程中的实践经验和思考， 并抽取出一些常用的知识内容整理成这篇文章，方便以后回看回练， 如果想更系统的学习， 可以去前面这个网站进行学习。
大纲如下：
Shell基础Shell编程Shell高级Shell的一些快捷操作 Ok, let’s go!
2. Shell基础 2.1 what? shell: 用户和内核之间的”代理”
Shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，这就是 Shell 的本质。 shell主要用来开发一些实用的、自动化的小工具，例如检测计算机的硬件参数、搭建 Web 运行环境、日志分析等，不适合开发具有复杂逻辑的中大型软件。
shell是一种脚本语言。
编译性语言：程序运行之前，把所有的代码翻译成二进制形式(可执行文件), 用户拿到的是可执行文件，看不到源码。这个过程叫做编译，这样的编程语言叫编译性语言，完成编译过程的软件叫编译器。 C/C++， GO等 优点是执行速度快、对硬件要求低、保密性好，适合开发操作系统、大型应用程序、数据库等 解释性语言：一边执行，一边翻译，无须生成任何二进制文件， 用户拿到源码即可运行。程序运行后即时翻译，翻译一部分执行一部分，不会等所有代码都翻译完，这个过程叫做解释， 这样的编程语言叫解释性语言，完成解释过程的软件叫解释器。 python, javascript, php，shell等 脚本语言的优点是使用灵活、部署容易、跨平台性好，非常适合 Web 开发以及小工具的制作 2.2 why? Shell是运维人员必须掌握的技能, Shell 脚本是实现 Linux 系统自动管理以及自动化运维所必备的工具
Linux 运维工程师(OPS): 主要工作就是搭建起运行环境，让程序员写的代码能够高效、稳定、安全地在服务器上运行，他们属于后勤部门。OPS 的要求并不比程序员低，优秀的 OPS 拥有架设服务器集群的能力，还会编程开发常用的工具。工作细节如下： 安装操作系统，例如 CentOS、Ubuntu 等。部署代码运行环境，例如网站后台语言采用 PHP，就需要安装 Nginx、Apache、MySQL、PHP 运行时等。及时修复漏洞，防止服务器被攻击，这包括 Linux 本身漏洞以及各个软件的漏洞。根据项目需求升级软件，例如 PHP 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5573f2d677b6bb837556e9ddec9f60b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0e83c12ba2f07a307faf4902e27827d/" rel="bookmark">
			词嵌入位置编码的实现（基于pytorch）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景介绍 在transformers架构当中，对于词向量的输入需要加上原本词对应的位置信息，作为输入到模型中训练的input，那具体的位置编码如何实现呢？本篇博客就跟大家一起分享一下对应的步骤
位置编码的公式 对于词向量的位置编码的方式有多种，这里就介绍用三角函数进行位置编码的公式
PE是position embeding位置编码的意思，pos表示词的位置，表示词向量的维度,i表示词向量的第i维度
那接下来我们就根据公式进行位置编码的代码实现
代码实现 环境依赖的库
import torch import math import numpy as np import matplotlib.pyplot as plt 定义一个函数获取位置编码的信息
def generate_word_embeding(max_len,d_model): # 初始化位置信息 pos = torch.arange(max_len).unsqueeze(1) # 初始化位置编码矩阵 result = torch.zeros(max_len,d_model) # 获得公式对应的值 coding = torch.exp(torch.arange(0,d_model,2)*(-math.log(10000.0))/d_model) result[:,0::2] = torch.sin(pos*coding) result[:,1::2] = torch.cos(pos*coding) # 为了与原编码直接相加，格式为[B,seq_len,d_model]，需要再增加一个维度 return result.unsqueeze(0) 假设我们的max_len是100，d_model为20，那么pos的维度为[100,1]，result的维度为[100,20]，coding的维度为[1,d_model/2]，result[:,0::2]是指对result的每列从第0列开始每隔一列赋值，对应公式中的PE(pos,2i)；同理，result[:,1::2]对应公式中的PE(pos,2i+1)
位置编码信息可视化 我们把得位置编码信息进行可视化从而得到更直观的感受
d = 6 pos_code = generate_word_embeding(100,d) print(pos_code.shape) plt.plot(np.arange(100),pos_code[0,:,0:d]) plt.legend(['dim=%d'%p for p in range(d)]) plt.show() 把词的时序长度设置为6，显示对应时序上每一个维度的位置编码信息
可以看到每一个时序位置上对应每一个维度都对应一个三角函数的变换规律，在放进model中训练的后就能够通过学习获得位置对应的知识
欢迎大家讨论交流~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f20f05a624ca6cc7de6250cff0f0f16/" rel="bookmark">
			从C到C&#43;&#43;2——C&#43;&#43;引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一..h头文件书写 如果你长时间只是写一个.c或.cpp文件作为一个项目，那么很少会写.h头文件，但是它是我们必须要会的，曾在某公司的笔试题目中考过，所以第一部分就介绍.h头文件的书写模板。
在写头文件时需要注意，在开头和结尾处必须按照如下样式加上预编译语句（如下）：
#ifndef 你的文件名 #define 你的文件名 //两个文件名保持一致 // 你的代码写在这里 #endif 这样做是为了防止重复编译，不这样做就有可能出错。
​ 我们在理解的基础上记忆，比如ifndef其实是if not define，如果没有定义该文件，那么就define xxx.h定义该文件，具体的定义在下面实现，而endif用来表示结束。曾经笔试的一道题目就是.h头文件的格式和作用，那么上面就是答案啦！
二.C++引用 今天的主要部分就是C++引用了，顺带一些其他很少讲解但实用的知识点。
1.基本用法 作用：给变量起一个别名
语法：数据类型 &amp;别名 = 原名
int a=10; int &amp;b=a; ​ 从内存的角度来理解这段简单代码，int a=10表示在内存中分配了一个4B的空间，其存放的值是10，我们可以通过变量a来对这块内存空间进行操作，同时第二句代码给a起一个别名叫b，那么以后我们也可以通过b来操作这块内存空间。那么如果你通过b来改变了这块内存的空间的值，那么a代表的内存空间的值也发生变换。
引用可以看做是数据的一个别名，通过这个别名和原来的名字都能够找到这份数据。
2.引用注意事项 引用创建时就必须初始化（也就是说一定要通过=告诉计算机这个引用是哪个变量的别名）引用一旦初始化后就不能更改 3.引用作为函数参数 在定义或声明函数时，我们可以将函数的形参指定为引用的形式，这样在调用函数时就会将实参和形参绑定在一起，让它们都指代同一份数据。如此一来，如果在函数体中修改了形参的数据，那么实参的数据也会被修改，从而拥有“在函数内部影响函数外部数据”的效果。 ​ 对于函数的参数传递，一般有三种传递方法：值传递、指针传递、引用传递。对于值传递我们知道，形参并不改变实参，最简单等的例如交换函数swap：
void swap(int a,int b){ int temp=a; a=b; b=temp; //可以在这里使用cout输出a和b } int main(){ int a=10,b=20; swap(a,b); //也可以在这里使用cout输出a和b } ​ 也就是说，如果使用的值传递，在main函数里的cout输出你会发现并没有交换a和b两个变量的值，只有在swap函数里的cout才会交换两个变量的值，针对这个问题我们采取了引用传递的办法，这些形参就会带动实参的改变。（如果你对指针传递很熟悉，也可以使用指针传递）
4.引用作函数返回值 引用作为函数的返回值时，需要注意以下两点：
不要返回局部变量的引用如果返回值是引用类型，那么函数调用可以作为左值 第一点好理解，局部变量即在函数内部定义的变量，我们不能返回它的引用；主要是第二点怎么理解，直接看代码：
#include &lt;iostream&gt; //声明命名空间std using namespace std; int &amp;func() { static int a = 10; return a; } int main() { int &amp;result = func(); cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f20f05a624ca6cc7de6250cff0f0f16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e9b6a2ce80cae17e1f5cf738fff768/" rel="bookmark">
			ABC201(A-C)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if((2*a-b-c)*(2*b-a-c)*(2*c-a-b)==0)cout&lt;&lt;"Yes"&lt;&lt;endl; else cout&lt;&lt;"No"&lt;&lt;endl; return 0; } B #include&lt;bits/stdc++.h&gt; using namespace std; struct high{ string name; int id; }; bool cmp(high a,high b){ return a.id&gt;b.id; } int main() { int n; cin&gt;&gt;n; high h[n]; for(int i=0;i&lt;n;i++){ cin&gt;&gt;h[i].name; cin&gt;&gt;h[i].id; } sort(h,h+n,cmp); cout&lt;&lt;h[1].name&lt;&lt;endl; return 0; } C #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int num[3]={0}; char c; for(int i=0;i&lt;10;i++){ cin&gt;&gt;c; if(c=='o')num[0]++; else if(c=='?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8e9b6a2ce80cae17e1f5cf738fff768/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b11bf1336581613c5bcc74171c6a66a1/" rel="bookmark">
			系统（嘀嗒）定时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.简介 SysTick---系统（嘀嗒）定时器，内核外设，是一个24位的向下递减的计数器，计数器每计数一次的时间为 1/SYSCLK。
当重装载数值寄存器的值递减到 0 的时候，系统定时器就产生一次中断，以此循环往复。
系统定时器一般用于操作系统，用于产生时基，维持操作系统的心跳。
二.寄存器 校准寄存器一般不用。 三.实验（闪光灯） 编程步骤：
设置重装载寄存器的值；清除当前数值寄存器的值；配置控制与状态寄存器。 延时思路： systick 的 counter 从 reload 值往下递减到 0 的时候，CTRL 寄存器的位 16:countflag 会置 1 ，且读取该位的值可清 0 ，所有我们可以使用软件查询的方法来实现延时。 systick.c
#include "systick.h" #if 0 static __INLINE uint32_t SysTick_Config(uint32_t ticks) { // 判断 tick 的值是否大于 2^24，如果大于，则不符合规则 if (ticks &gt; SysTick_LOAD_RELOAD_Msk) return (1); // 初始化reload寄存器的值	SysTick-&gt;LOAD = (ticks &amp; SysTick_LOAD_RELOAD_Msk) - 1; // 配置中断优先级，配置为15，默认为最低的优先级 NVIC_SetPriority (SysTick_IRQn, (1&lt;&lt;__NVIC_PRIO_BITS) - 1); // 初始化counter的值为0	SysTick-&gt;VAL = 0; // 配置 systick 的时钟为 72M // 使能中断 // 使能systick SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk; return (0); } #endif void SysTick_Delay_us(uint32_t us) { uint32_t i; SysTick_Config(72); for(i=0; i&lt;us; i++) { // 当计数器的值减小到 0 的时候，CRTL 寄存器的位 16 会置 1 while( !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b11bf1336581613c5bcc74171c6a66a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d1638df2dee540f106ce263e014c955/" rel="bookmark">
			react&#43;umi&#43;antd项目搭建配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档链接：
UmiJS官方文档
React官方文档
Ant Design官方文档
一、项目搭建 对于react umi项目搭建，umi官方文档已经写的很清晰了，具体请查看上面的umi官方文档链接。这里我不再详细说明，着重说明一些需要注意的地方。
1. 首先，确认是否已安装node和umi，本文umi版本使用3.0版本。
$ node -v $ umi -v 2. 可通过以下两种命令创建项目，但创建出来的项目umi版本不同
$ yarn create umi 说明： 使用此命令创建的项目，umi版本为2.x版本，如需使用3.x版本还需要手动升级，关于手动升级的操作umi官网也有详细步骤 除此之外，此命令可选择创建哪种项目，如需使用ant-design-pro框架可使用此法创建（如下图） $ yarn create @umijs/umi-app 说明： 此命令为umi官网提供的项目创建工具，创建完成umi项目即为3.x版本推荐使用 注意：以上两种创建方式都需要手动安装 antd 依赖，项目工程默认自带的是 @ant-design/pro-layout ，但pro-layout相关文档阅读体验不够好，个人比较推荐直接使用 antd （使用ant-design-pro框架除外）
二、ESLint相关配置 umi项目的lint相关配置使用 @umijs/fabric 就已经足够了，运行过程中如果有什么依赖找不到直接yarn安装就行。
1. 新增 .eslintrc.js、.eslintignore、.stylelintrc.js、.stylelintignore 配置文件
eslintrc.js
module.exports = { extends: [require.resolve('@umijs/fabric/dist/eslint')], rules: { 'no-unused-vars': 'warn', '@typescript-eslint/no-unused-vars': 'warn' }, } .stylelintrc.js
module.exports = { extends: [require.resolve('@umijs/fabric/dist/stylint')] }; prettierrc相关配置使用项目创建时默认的就行，不用修改。
2. 配置lint相关命令（仅供参考，可根据需求灵活配置）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d1638df2dee540f106ce263e014c955/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/469dabd76ab6beda9d2fab37e3c735e3/" rel="bookmark">
			【API调用gpt-4 (vision-preview)】基于微软的Azure OpenAI API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 微软的Azure页面 ： https://learn.microsoft.com/zh-cn/azure/ai-services/openai/concepts/models
调用代码：https://learn.microsoft.com/zh-cn/azure/ai-services/openai/how-to/switching-endpoints
openai说明: https://platform.openai.com/docs/guides/vision
服务器区域选择与购买 (略) 不同区域的服务器开通不同模型 美国西部
参考代码，GPT4识别图片，并中文回复 prompt=“What’s in this image? 并使用中文回答”
需要解析的远程图片
完整代码 from openai import AzureOpenAI api_key="your_key" azure_endpoint="your_model_url" client = AzureOpenAI( api_key=api_key, api_version="2023-12-01-preview", azure_endpoint=azure_endpoint ) response = client.chat.completions.create( model="gpt-4-vision-preview", messages=[ { "role": "user", "content": [ {"type": "text", "text": "What’s in this image? 并使用中文回答"}, { "type": "image_url", "image_url": { "url": "https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/Gfp-wisconsin-madison-the-nature-boardwalk.jpg/2560px-Gfp-wisconsin-madison-the-nature-boardwalk.jpg", }, }, ], } ], max_tokens=300, ) print(response.choices[0]) 回应 这张图片是一个木制的步道穿过一片绿色的草地，远处有一些树木，天空是蓝色的，有一些白云。
Choice(finish_reason=None, index=0, logprobs=None, message=ChatCompletionMessage( content='这张图片是一个木制的步道穿过一片绿色的草地，远处有一些树木，天空是蓝色的，有一些白云。', role='assistant', function_call=None, tool_calls=None), finish_details={'type': 'stop', 'stop': '&lt;|fim_suffix|&gt;'}, content_filter_results={'hate': {'filtered': False, 'severity': 'safe'}, 'self_harm': {'filtered': False, 'severity': 'safe'}, 'sexual': {'filtered': False, 'severity': 'safe'}, 'violence': {'filtered': False, 'severity': 'safe'}}) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bde0e32f9595224c36d6d9086282ddfb/" rel="bookmark">
			【BCC动态跟踪PostgreSQL】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BPF Compiler Collection (BCC)是基于eBPF的Linux内核分析、跟踪、网络监控工具。其源码存放于GitCode - 开发者的代码家园
想要监控PostgreSQL数据库的相关SQL需要在编译PostgreSQL的时候开启dtrace。下文主要介绍几个和PostgreSQL相关的工具,其他工具可根据需求自行了解。
1.dbslower：跟踪慢查询，然后打印超出延时的，默认延时是1ms //终端 1： [root@localhost tools]# ./dbslower postgres -p 58474 //终端 2： postgres=# select pg_backend_pid(); pg_backend_pid ---------------- 58474 (1 row) postgres=# select pg_sleep(3); pg_sleep ---------- (1 row) postgres=# select pg_sleep(2); pg_sleep ---------- (1 row) postgres=# select pg_sleep(1); pg_sleep ---------- (1 row) postgres=# select pg_sleep(2); pg_sleep ---------- (1 row) /终端1： [root@localhost tools]# ./dbslower postgres -p 58474 Tracing database queries for pids 58474 slower than 1 ms.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bde0e32f9595224c36d6d9086282ddfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8293f8ac2ed5ba22ce70b234a6712d4/" rel="bookmark">
			第三十四周：文献阅读&#43;LSTM学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘要
Abstract
文献阅读：综合EMD-LSTM模型在城市排水管网水质预测中的应用
现有问题
提出方法
EMD-LSTM综合模型
研究框架
结论
Long Short-term Memory(长短期记忆)
1. LSTM的结构
2. Multiple-layer LSTM
3.3 LSTM Example
3. GRU
LSTM实现PM2.5预测
总结
摘要 在本周阅读的文献中，提出了以EMD为中心的数据预处理模块和LSTM预测模块相结合的城市排水管网水质HCI综合预测模型。在EMD-LSTM模型中，EMD允许保留异常值并利用非对齐时刻的数据，这有助于捕获数据模式，而LSTM神经网络强大的非线性映射和学习能力可以对水质进行时间序列预测，综合预测模型实现对城市排水网络水质的准确预测。LSTM是一种特殊的RNN，比普通的RNN多了三个“门”，可以让信息有选择性的通过。LSTM能够在更长的序列中有更好的表现，解决了RNN训练时的梯度无效问题。
Abstract The literature read this week proposes a comprehensive prediction model for urban drainage network water quality HCI, which combines an EMD centered data preprocessing module and an LSTM prediction module. In the EMD-LSTM model, EMD allows for retaining outliers and utilizing data from non aligned moments, which helps capture data patterns.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8293f8ac2ed5ba22ce70b234a6712d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3aacb4525c10122c7884f5b0d5f1ba2/" rel="bookmark">
			第三十五周：文献阅读&#43;Self-attention
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘要
Abstract
文献阅读：基于LSTM和注意机制的水质预测
现有问题
提出方法
前提点
1. LSTM
2. 注意力机制
研究模型（AT-LSTM）结构
模型验证
总结AT-LSTM优于LSTM的方面
Self-attention（自注意力机制）
1. 运作
2. Muti-Head Self-attention
3. Self-attention v.s. CNN
4. Self-attention v.s. RNN
实现Self-attention
摘要 本周阅读的文献提出了AT-LSTM模型即注意力机制结合LSTM模型，用于提高水质检测的精确度。AT-LSTM模型与传统LSTM模型相比的不同之处在于增加了注意力层，通过对神经网络隐含层元素进行自适应加权，减少无关因素对结果的影响，突出相关因素的影响，从而提高预测精度。研究通过与单一模型的对比实验，验证了借助注意力机制的AT-LSTM模型在多元时间序列的预测性的优势。self-attention是一种可以考虑全局信息以及不同输入向量之间关系的机制，在训练时可以充分发挥这些关系，优化训练的结果。通过计算输入之间的关联性，过滤掉无效的信息，减少计算量。
Abstract The literature read this week proposes the AT-LSTM model, which combines attention mechanism with LSTM model, to improve the accuracy of water quality detection. The difference between the AT-LSTM model and the traditional LSTM model lies in the addition of an attention layer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3aacb4525c10122c7884f5b0d5f1ba2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3ef10e9ffb2e6ff50c4790f42e0d95a/" rel="bookmark">
			HarmonyOS系统架构及项目结构浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本概念 UI框架 HarmonyOS提供了一套UI开发框架，即方舟开发框架（ArkUI框架）。方舟开发框架可为开发者提供应用UI开发所必需的能力，比如多种组件、布局计算、动画能力、UI交互、绘制等。
方舟开发框架针对不同目的和技术背景的开发者提供了两种开发范式，分别是基于ArkTS的声明式开发范式（简称“声明式开发范式”）和兼容JS的类Web开发范式（简称“类Web开发范式”）。以下是两种开发范式的简单对比。
开发范式名称语言生态UI更新方式适用场景适用人群声明式开发范式ArkTS语言数据驱动更新复杂度较大、团队合作度较高的程序移动系统应用开发人员、系统应用开发人员类Web开发范式JS语言数据驱动更新界面较为简单的程序应用和卡片Web前端开发人员 应用模型 应用模型是HarmonyOS为开发者提供的应用程序所需能力的抽象提炼，它提供了应用程序必备的组件和运行机制。有了应用模型，开发者可以基于一套统一的模型进行应用开发，使应用开发更简单、高效。
随着系统的演进发展，HarmonyOS先后提供了两种应用模型：
FA（Feature Ability）模型： HarmonyOS API 7开始支持的模型，已经不再主推。FA模型开发可见。Stage模型(推荐)： HarmonyOS API 9开始新增的模型，是目前主推且会长期演进的模型。在该模型中，由于提供了AbilityStage、WindowStage等类作为应用组件和Window窗口的“舞台”，因此称这种应用模型为Stage模型。Stage模型开发可见。 FA模型和Stage模型的整体架构和设计思想等更多区别，请见应用模型解读。
Stage 模型 基于Stage模型开发的应用，经编译打包后，其应用程序包结构如下图所示
在开发态，一个应用包含一个或者多个Module，可以在DevEco Studio工程中创建一个或者多个Module。
Module是HarmonyOS应用 / 服务的基本功能单元，包含了源代码、资源文件、第三方库及应用/服务配置文件，每一个Module都可以独立进行编译和运行。
Module分为“Ability”和“Library”两种类型
“Ability”类型的Module对应于编译后的HAP（Harmony Ability Package）； “Library”类型的Module对应于HAR（Harmony Archive），或者HSP（Harmony Shared Package）。
如下图所示。 这里介绍到的Module默认指的是“Ability”类型的Module。
我们通过DevEco Studio把应用程序编译为一个或者多个.hap后缀的文件，即HAP。HAP是HarmonyOS应用安装的基本单位，包含了编译后的代码、资源、三方库及配置文件。HAP可分为Entry和Feature两种类型。
Entry类型的HAP：是应用的主模块，在module.json5配置文件中的type标签配置为“entry”类型。在同一个应用中，同一设备类型只支持一个Entry类型的HAP，通常用于实现应用的入口界面、入口图标、主特性功能等。Feature类型的HAP：是应用的动态特性模块，在module.json5配置文件中的type标签配置为“feature”类型。一个应用程序包可以包含一个或多个Feature类型的HAP，也可以不包含；Feature类型的HAP通常用于实现应用的特性功能，可以配置成按需下载安装，也可以配置成随Entry类型的HAP一起下载安装 每个HarmonyOS应用可以包含多个 .hap文件，一个应用中的.hap文件合在一起称为一个Bundle，而bundleName就是应用的唯一标识。需要注意的是：在应用上架到应用市场时，需要把应用包含的所有.hap文件（即Bundle）打包为一个 .app后缀的文件用于上架，这个.app文件称为App Pack（Application Package），其中同时包含了描述App Pack属性的pack.info文件；在云端（服务器）分发和终端设备安装时，都是以HAP为单位进行分发和安装的。
打包后的HAP包结构包括ets、libs、resources等文件夹和resources.index、module.json、pack.info等文件。
ets目录用于存放应用代码编译后的字节码文件。libs目录用于存放库文件。库文件是HarmonyOS应用依赖的第三方代码（.so二进制文件）。resources目录用于存放应用的资源文件（字符串、图片等），便于开发者使用和维护。resources.index是资源索引表，由IDE编译工程时生成。module.json是HAP的配置文件，内容由工程配置中的module.json5和app.json5组成，该文件是HAP中必不可少的文件。IDE会自动生成一部分默认配置，开发者按需修改其中的配置。pack.info是Bundle中用于描述每个HAP属性的文件，例如app中的bundleName和versionCode信息、module中的name、type和abilities等信息，由IDE工具生成Bundle包时自动生成。 FA 模型 基于FA模型开发的应用，其应用程序包结构如下图所示。
FA模型与Stage模型不同之处在于HAP内部文件存放位置不同，FA模型将所有的资源文件、库文件和代码文件都放在assets文件夹中，在文件夹内部进一步区分。
config.json是应用配置文件，IDE会自动生成一部分模块代码，开发者按需修改其中的配置。详细字段请参见应用配置文件。assets是HAP所有的资源文件、库文件和代码文件的集合，内部可以分为entry和js文件夹。entry文件夹中存放的是resources目录和resources.index文件。resources目录用于存放应用的资源文件（字符串、图片等），便于开发者使用和维护。resources.index是资源索引表，由IDE调用SDK工具生成。js文件夹中存放的是编译后的代码文件。pack.info是Bundle中用于描述每个HAP属性的文件，例如app中的bundleName和versionCode信息、module中的name、type和abilities等信息，由IDE工具生成Bundle包时自动生成。 项目结构 一个 HarmonyOS 项目的目录结构如下
其中详细如下：
AppScope中存放应用全局所需要的资源文件。entry是应用的主模块，存放HarmonyOS应用的代码、资源等。oh_modules是工程的依赖包，存放工程依赖的源文件。build-profile.json5是工程级配置信息，包括签名、产品配置等。hvigorfile.ts是工程级编译构建任务脚本，hvigor是基于任务管理机制实现的一款全新的自动化构建工具，主要提供任务注册编排，工程模型管理、配置管理等核心能力。oh-package.json5是工程级依赖配置文件，用于记录引入包的配置信息。 在AppScope，其中有resources文件夹和配置文件app.json5。AppScope&gt;resources&gt;base中包含element和media两个文件夹，
其中element文件夹主要存放公共的字符串、布局文件等资源。media存放全局公共的多媒体资源文件。 模块级目录 entry&gt;src目录中主要包含总的main文件夹，单元测试目录ohosTest，以及模块级的配置文件。
main文件夹中，ets文件夹用于存放ets代码，resources文件存放模块内的多媒体及布局文件等，module.json5文件为模块的配置文件。ohosTest是单元测试目录。build-profile.json5是模块级配置信息，包括编译构建配置项。hvigorfile.ts文件是模块级构建脚本。oh-package.json5是模块级依赖配置信息文件。 进入src&gt;main&gt;ets目录中，其分为 entryability、pages 两个文件夹。
entryability存放ability文件，用于当前ability应用逻辑和生命周期管理。pages存放UI界面相关代码文件，初始会生成一个Index页面。 resources目录下存放模块公共的多媒体、字符串及布局文件等资源，分别存放在element、media文件夹中。
app.json5 AppScope&gt;app.json5是应用的全局的配置文件，用于存放应用公共的配置信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3ef10e9ffb2e6ff50c4790f42e0d95a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3458741a7b6447c45c4e9636a94b3b24/" rel="bookmark">
			Word2Vec（词向量）---机器学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Word2Vec是一种用于将词语映射到向量空间的词嵌入技术，它通过学习大量文本语料库中的词语上下文关系，将每个词语表示为高维向量。这一表示形式使得具有相似语境的词语在向量空间中更加接近。
Word2Vec有两个主要的实现算法：Skip-gram和CBOW（Continuous Bag of Words）。以下是对Word2Vec的一些重点介绍：
Skip-gram和CBOW：
Skip-gram： 通过给定中心词来预测其周围的上下文词，可以用于生成更准确的词向量，特别适用于较大的数据集。
CBOW： 通过给定周围的上下文词来预测中心词，相对于Skip-gram，CBOW更快，尤其在小型数据集上效果良好。 如下图：左为CBOW，右为Skip-gram
训练过程：
1、 Word2Vec的训练过程基于神经网络，通常是一个浅2、层的神经网络。
3、 输入层为词汇表中的每个词，输出层为对应的词向量。
4、隐藏层的权重矩阵即为最终学到的词嵌入矩阵。
相似性和关系：
1、在Word2Vec生成的向量空间中，词语的相似性可以通过计算它们之间的余弦相似度来衡量。
、向量之间的运算，如king - man + woman，可以用来找到具有类似语义关系的词语，例如queen。
面试考点：
原理和算法： 理解Word2Vec的基本原理，了解Skip-gram和CBOW的区别，以及它们是如何通过神经网络进行训练的。
应用和优势： 知道Word2Vec在自然语言处理中的应用，以及它相对于传统的词袋模型等方法的优势。
调参和性能： 熟悉Word2Vec的一些重要参数，如窗口大小、向量维度等，以及它们如何影响模型的性能。
训练时间和数据规模： 考虑Word2Vec在大规模数据上的训练时间和在小规模数据上的表现。
关于Word2Vec若干问题的思考
（1）Word2Vec两个算法模型的原理是什么，网络结构怎么画？
Word2Vec有两个主要的算法模型：Skip-gram和CBOW。下面分别介绍它们的原理和网络结构。
Skip-gram模型原理： 原理： Skip-gram模型的目标是从一个词中预测其周围的上下文词。
网络结构：
输入层： 词汇表的大小，每个词被表示为一个独热编码向量。
隐藏层： 单层的权重矩阵，用于将输入向量映射到隐含层的向量。这个向量即为词向量。
输出层： 词汇表的大小，每个输出单元对应一个词，输出的概率表示给定中心词的情况下，周围的词是其他词的概率。
训练过程：
1、 输入为中心词，目标是预测周围的上下文词。
2、使用softmax函数将输出层的原始分数转换为概率分布。
3、最小化损失函数，例如交叉熵，以更新权重矩阵，使预测的上下文词概率最大化。
优点：
对于大规模数据集，Skip-gram通常能够学到更准确的词向量。
CBOW模型原理： 原理： CBOW模型的目标是从上下文词的平均来预测中心词。
网络结构：
输入层： 词汇表的大小，每个词被表示为一个独热编码向量。
隐藏层： 单层的权重矩阵，用于将输入向量映射到隐含层的向量，再取平均。
输出层： 词汇表的大小，每个输出单元对应一个词，输出的概率表示给定上下文词的情况下，中心词是其他词的概率。
训练过程：
输入为周围的上下文词的平均，目标是预测中心词。
使用softmax函数将输出层的原始分数转换为概率分布。
最小化损失函数，例如交叉熵，以更新权重矩阵，使预测的中心词概率最大化。
优点：
相对于Skip-gram，CBOW在小规模数据集上通常训练速度更快。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3458741a7b6447c45c4e9636a94b3b24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce56abdbbdcd2867e86536b06085abcf/" rel="bookmark">
			C&#43;&#43;职工管理系统实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言：需求一、创建一个管理者的类，面向管理者进行编程1.建立.h文件2.建立.c文件3.编写一个显示系统菜单的成员函数 二、实现功能0：退出管理程序三、设计抽象类worker和三个职工的子类1.思路：创建一个职工的抽象类，将员工、经理、老板用多态来构造2.思路：多态的派生类中，成员变量是编号、姓名和等级。成员函数是岗位信息描述和获取岗位名称。3.h文件声明抽象worker类成员变量和函数4.单独实现一个员工employee的子类，重写父类的纯虚函数。5.单独实现经理mannerr的子类并重写6.实现老板boss的子类并重写 四.实现功能1：添加职工信息的功能①思路分析：我们添加职工时，可能会创建各种各样不同的职工，需要将不同种类的职工放入一个不定长的数组保存。②解决方法：父类的指针可以统一的访问不同子类对象，所以利用堆区建立一个指针数组来统一的管理不同的子类对象,使其类似数组似的有序排布。③一个一个的添加不同职员的信息的函数④成批的批量的添加职员信息的函数这里我遇到一个大坑：ofs &lt;&lt; "ID\t姓名\t等级\t岗位" &lt;&lt; endl;原因：文件流 ofs 是作为参数传递给函数的，每次调用函数时都会重新创建一个新的文件流对象。因此，每次调用 manyaddinformation 函数时，文件流 ofs 都是新创建的，并且文件是空的。这就导致了每次都会写入表头信息。解决思路：void WorkerManger::manyaddinformation(abstractWorker* worker[], ofstream&amp; ofs)，将文件流 ofs 定义为 WorkerManger 类的成员变量。这样，文件流对象将在类的生命周期内保持打开状态，而不会在每次函数调用时重新创建。 ⑤将添加的职工信息保存到文件中这里不建议用saveinfo这个函数，因为我尝试过，这样做，会导致每次重启程序时刷新文件，导致之前的信息丢失。最好还是在批量添加职员信息的函数里就直接完成文件的写入。 ⑥读取文件内容并打印出来,还可以统计员工、经理、老板各自人数 五、实现功能2：显示职工信息六、实现功能3：删除离职职工七、实现功能4：修改职工信息（目前仅姓名）八、实现功能5：查找职工信息,根据ID号或姓名来查找职工信息的功能九、实现功能6：将员工、经理、老板三类分别打印其信息十：实现功能7：清空文件十一：出现BUG：删除、修改操作中的文件重新写入会导致文件内容重复一次。解决思路：只知道肯定是deleteWorker和modifyWorker这两个函数有问题，但是不知道怎么修改写文件那一块的代码。 前言：需求 管理系统中需要实现的功能如下:
退出管理程序：退出当前管理系统 增加职工信息：实现批量添加职工功能，将信息录入到文件中，职工信息为：职工编号、姓名、部门编号 显示职工信息：显示公司内部所有职工的信息 删除离职职工：按照编号删除指定的职工 修改职工信息：按照编号修改职工个人信息 查找职工信息：按照职工的编号或者职工的姓名进行查找相关的人员信息 按照编号排序：按照职工编号，进行排序，排序规则由用户指定 清空所有文档：清空文件中记录的所有职工信息（清空前需要再次确认，防止误删) 一、创建一个管理者的类，面向管理者进行编程 1.建立.h文件 #pragma once//防止头文件重复包含，与下面C语言的ifndef差不多 #ifndef WORKERMANGER__H #define WORKERMANGER__H #include &lt;iostream&gt; using namespace std; class WorkerManger { public: //构造函数 WorkerManger(); //析构函数 ~WorkerManger(); }; #endif // !1 2.建立.c文件 #include &lt;iostream&gt; #include "workerManager.h" WorkerManger::WorkerManger() { } WorkerManger::~WorkerManger() { } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce56abdbbdcd2867e86536b06085abcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daa02ff1dae5df9c3c295970fba6a3cb/" rel="bookmark">
			ros2基础学习13 DDS 通信得学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ROS2中最为重大的变化——DDS，我们在前边课程中学习的话题、服务、动作，他们底层通信的具体实现过程，都是靠DDS来完成的，它相当于是ROS机器人系统中的神经网络。
通信模型 DDS的核心是通信，能够实现通信的模型和软件框架非常多，这里我们列出常用的四种模型。
第一种，点对点模型，许多客户端连接到一个服务端，每次通信时，通信双方必须建立一条连接。当通信节点增多时，连接数也会增多。 而且每个客户端都需要知道服务器的具体地址和所提供的服务，一旦服务器地址发生变化，所有客户端都会受到影响。
第二种，Broker模型，针对点对点模型进行了优化，由Broker集中处理所有人的请求，并进一步找到真正能响应该服务的角色。 这样客户端就不用关心服务器的具体地址了。不过问题也很明显，Broker作为核心，它的处理速度会影响所有节点的效率，当系统规模增长到一定程度，Broker就会成为整个系统的性能瓶颈。
更麻烦是，如果Broker发生异常，可能导致整个系统都无法正常运转。之前的ROS1系统，使用的就是类似这样的架构。
第三种，广播模型，所有节点都可以在通道上广播消息，并且节点都可以收到消息。这个模型解决了服务器地址的问题，而且通信双方也不用单独建立连接，但是广播通道上的消息太多了，所有节点都必须关心每条消息，其实很多是和自己没有关系的。
第四种，就是以数据为中心的DDS模型了，这种模型与广播模型有些类似，所有节点都可以在DataBus上发布和订阅消息。
但它的先进之处在于，通信中包含了很多并行的通路，每个节点可以只关心自己感兴趣的消息，忽略不感兴趣的消息，有点像是一个旋转火锅，各种好吃的都在这个DataBus传送，我们只需要拿自己想吃的就行，其他的和我们没有关系。
可见，在这几种通信模型中，DDS的优势更加明显。
DDS DDS并不是一个新的通信方式，在ROS2之前，DDS已经广泛应用在很多领域，比如航空，国防，交通，医疗，能源等。
比如在自动驾驶领域，通常会存在感知，预测，决策和定位等模块，这些模块都需要非常高速和频繁地交换数据。借助DDS，可以很好地满足它们的通信需求。
什么是DDS？ 好啦，说了半天DDS，到底啥意思呢？我们来做一个完整的介绍
DDS的全称是Data Distribution Service，也就是数据分发服务，2004年由对象管理组织OMG发布和维护，是一套专门为实时系统设计的数据分发/订阅标准，最早应用于美国海军， 解决舰船复杂网络环境中大量软件升级的兼容性问题，现在已经成为强制标准。
DDS强调以数据为中心，可以提供丰富的服务质量策略，以保障数据进行实时、高效、灵活地分发，可满足各种分布式实时通信应用需求。
这里也提一下对象管理组织OMG，成立于1989年，它的使命是开发技术标准，为数以千计的垂直行业提供真实的价值，比如大家课可能听说过的统一建模语言SYSML和UML，还有中间件标准CORBA等，当然还有DDS。
DDS在ROS2中的应用 DDS在ROS2系统中的位置至关重要，所有上层建设都建立在DDS之上。在这个ROS2的架构图中，蓝色和红色部分就是DDS。
刚才我们也提到，DDS是一种通信的标准，就像4G、5G一样，既然是标准，那大家都可以按照这个标准来实现对应的功能，所以华为、高通都有很多5G的技术专利，DDS也是一样，能够按照DDS标准实现的通信系统很多，这里每一个红色模块，就是某一企业或组织实现的一种DDS系统。
既然可选用的DDS这么多，那我们该用哪一个呢？具体而言，他们肯定都符合基本标准，但还是会有性能上的差别，ROS2的原则就是尽量兼容，让用户根据使用场景选择，比如个人开发，我们选择一个开源版本的DDS就行，如果是工业应用，那可能得选择一个商业授权的版本了。
为了实现对多个DDS的兼容，ROS设计了一个Middleware中间件，也就是一个统一的标准，不管我们用那个DDS，保证上层编程使用的函数接口都是一样的。此时兼容性的问题就转移给了DDS厂商，如果他们想让自己的DDS系统进入ROS生态，就得按照ROS的接口标准，开发一个驱动，也就是这个部分。
无论如何，ROS的宗旨不变，要提高软件代码的复用性，下边DDS任你边，上边的软件没影响。
在ROS的四大组成部分中，由于DDS的加入，大大提高了分布式通信系统的综合能力，这样我们在开发机器人的过程中，就不需要纠结通信的问题，可以把更多时间放在其他部分的应用开发上。
质量服务策略QoS DDS为ROS的通信系统提供提供了哪些特性呢？我们通过这个通信模型图来看下。
DDS中的基本结构是Domain，Domain将各个应用程序绑定在一起进行通信，回忆下之前我们配置树莓派和电脑通信的时候，配置的那个DOMAIN ID，就是对全局数据空间的分组定义，只有处于同一个DOMAIN小组中的节点才能互相通信。这样可以避免无用数据占用的资源。
DDS中另外一个重要特性就是质量服务策略，QoS。 QoS是一种网络传输策略，应用程序指定所需要的网络传输质量行为，QoS服务实现这种行为要求，尽可能地满足客户对通信质量的需求，可以理解为数据提供者和接收者之间的合约。
具体会有哪些策略？比如：
DEADLINE策略： 表示通信数据必须要在每次截止时间内完成一次通信；
HISTORY策略： 表示针对历史数据的一个缓存大小；
RELIABILITY策略： 表示数据通信的模式，配置成BEST_EFFORT，就是尽力传输模式，网络情况不好的时候，也要保证数据流畅，此时可能会导致数据丢失，配置成RELIABLE，就是可信赖模式，可以在通信中尽量保证图像的完整性，我们可以根据应用功能场景选择合适的通信模式；
DURABILITY策略，可以配置针对晚加入的节点，也保证有一定的历史数据发送过去，可以让新节点快速适应系统。
所有这些策略在ROS系统中都可以通过类似这样的结构体配置，如果不配置的话，系统也会使用默认的参数。
举一个机器人的例子便于大家理解。
比如我们遥控一个无人机航拍，如果网络情况不好的话，遥控器向无人机发送运动指令的过程，可以用reliable通信模式，保证每一个命令都可以顺利发送给无人机，但是可能会有一些延时，无人机传输图像的过程可以用best effort模式，保证视频的流畅性，但是可能会有掉帧。
如果此时出现一个黑客黑入我们的网络，也没有关系，我们可以给ROS2的通信数据进行加密，黑客也没有办法直接控制无人机。
DDS的加入，让ROS2的通信系统焕然一新，多众多样的通信配置，可以更好的满足不同场景下的机器人应用。
好啦，DDS这么好，那该如何配置和使用呢？我们先带大家入个门。
案例一：在命令行中配置DDS 我们先来试一试在命令行中配置DDS的参数。
启动第一个终端，我们使用best_effort创建一个发布者节点，循环发布任意数据，在另外一个终端中，如果我们使用reliable模型订阅同一话题，无法实现数据通信，如果修改为同样的best_effort，才能实现数据传输。
ros2 topic pub /chatter std_msgs/msg/Int32 "data: 42" --qos-reliability best_effort $ ros2 topic echo /chatter --qos-reliability reliable$ ros2 topic echo /chatter --qos-reliability best_effort 如何去查看ROS2系统中每一个发布者或者订阅者的QoS策略呢，在topic命令后边跟一个"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daa02ff1dae5df9c3c295970fba6a3cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1e5f8ac8bc4b01750a114411bd28afe/" rel="bookmark">
			二叉搜索树介绍以及实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树无论是在实际运用还是面试题中，都是一种十分热门的数据结构，而二叉搜索树则是进阶版的二叉树，在map和set中也有应用。
什么是二叉搜索树 二叉搜索树又叫二叉排序树，它可以是一颗空树，又或者是有以下三个特点的树。
若它的左子树不为空，则左子树的所有节点的值都小于根节点的值。若它的右子树不为空，则右子树的所有节点的值都大于根节点的值。它的左右子树也都是二叉搜索树。 因为二叉搜索树具有以上三个特性，因此二叉搜索树的最优搜索次数为 O(log^2) ，最差搜索次数为 O(N)。
此外，中序遍历一个二叉搜索树所得到的结果应该是一个有序的数组。
二叉搜索树的实现 二叉搜索树的查找 从根节点开始查找，若查找的 val 大于根节点的值，则向右子树查找，否则向左子树查找最多查找高度次，走到空还没有找到，就返回nullptr,否则就返回这个节点。 pNode find(const T&amp; val) { pNode cur = Root; if (cur-&gt;_data == val) { return cur; } while (cur != nullptr) { if (val &gt; cur-&gt;_data) { cur = cur-&gt;_right; } else if (val &lt; cur-&gt;_data) { cur = cur-&gt;_left; } else { return cur; } } return nullptr; } 二叉搜索树的插入 二叉树的插入需要找到正确的位置。
val大于当前节点的值就向右子树走val小于当前节点的值就向左子树走直到找到一个空节点就插入 bool insert(T val) { pNode cur = new Node(val); pNode root = Root; if (Root!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1e5f8ac8bc4b01750a114411bd28afe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8edcf9cd1239ae58bb19a032c7eafbd4/" rel="bookmark">
			Django(三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.快速上手 确保app已注册 【settings.py】
编写URL和视图函数对应关系 【urls.py】
编写视图函数 【views.py】
启动django项目
命令行启动python manage.py runserver Pycharm启动
1.1 再写一个页面 2. templates模板 2.1 静态文件 2.1.1 static目录 在app目录下创建static文件夹
2.1.2 引用静态文件 3. 模板语法 本质上：在HTML中写一些占位符，由数据对这些占位符进行替换和处理。
案例：伪联通新闻中心 4.请求和响应 关于重定向：
案例：用户登录 报上面错误的话要在.html里面加上{% csrf_token %}就可以了
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/41/">«</a>
	<span class="pagination__item pagination__item--current">42/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/43/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>