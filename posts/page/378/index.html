<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/221c3b18fd17d8bd529c0db92f806d86/" rel="bookmark">
			vue中使用svg类型图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、第一步：安装解析svg类型图标的依赖库
npm install svg-sprite-loader --save-dev 2、配置vue.config.js文件，代码如下
chainWebpack(config) { // set svg-sprite-loader config.module .rule('svg') .exclude.add(resolve('src/icons')) .end() config.module .rule('icons') .test(/\.svg$/) .include.add(resolve('src/icons')) .end() .use('svg-sprite-loader') .loader('svg-sprite-loader') .options({ symbolId: 'icon-[name]' }) .end() } 3、在src/components下新建文件夹及文件SvgIcon/index.vue，代码如下
&lt;template&gt; &lt;!--&lt;svg class="svgClass" aria-hidden="true"&gt; &lt;use :xlink:href="iconName"&gt;&lt;/use&gt; &lt;/svg&gt;--&gt; &lt;div v-if="isExternal" :style="styleExternalIcon" class="svg-external-icon svg-icon" v-on="$listeners" /&gt; &lt;svg v-else :class="svgClass" aria-hidden="true" v-on="$listeners"&gt; &lt;use :xlink:href="iconName" /&gt; &lt;/svg&gt; &lt;/template&gt; &lt;script&gt; // doc: https://panjiachen.github.io/vue-element-admin-site/feature/component/svg-icon.html#usage import { isExternal } from '@/utils/validate' export default { name: 'SvgIcon', props: { iconClass: { type: String, required: true }, className: { type: String, default: '' } }, computed: { isExternal() { // return false return isExternal(this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/221c3b18fd17d8bd529c0db92f806d86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f003117b57a91e64167db4ae3a82f90/" rel="bookmark">
			Linux驱动加载问题“.ko模块无法加载modprobe: module &#39;xxx.ko&#39; not found”解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 可能是缺少相关路径、文件或是文件名不需要带扩展 使用modprobe XX.ko命令后，会到文件系统/lib/modules/xxxxx目录下查找相应的XX.ko文件;
这里的xxxxx是指系统内核版本，可以通过uname -r命令获得。
解决方案：
没有这个目录的话，自己创建一个~创建后将.ko文件放入这个目录中执行depmod命令重新执行modprobe XX.ko命令若还不行：重新执行modprobe XX命令（去掉扩展名） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8843a7447e1e22af288184a54cb7d0e1/" rel="bookmark">
			vue中自定义element-ui组件库的主题颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言：在项目中直接修改element的样式变量，前提是需要使用scss编写，这就需要首先在项目中安装可以解析scss文件格式的插件
1、第一步：安装解析scss文件格式的插件sass-loader,node-sass
npm install sass-loader node-sass -dev 2、第二步：在src下新建theme文件，并在文件下新建element-variables.scss文件，element-variables.scss文件配置代码如下
/* 改变主题色变量 */ $--color-primary: teal; /* 改变 icon 字体路径变量，必需 */ $--font-path: '../node_modules/element-ui/lib/theme-chalk/fonts'; @import "../node_modules/element-ui/packages/theme-chalk/src/index"; 3、在main.js中引入配置好的自定义主题文件
import './theme/element-variables.scss' 4、正常使用组件就可以了，如下type=“”primary“的按钮颜色便成了上面设置好的颜色，同样如果也需要修改success等类型的颜色，按照上面的方式修改即可
&lt;el-button type="primary"&gt;主要按钮&lt;/el-button&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dbb3d436b2a0504d25f3198c13b323e/" rel="bookmark">
			岛屿数量-Java方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 岛屿数量
给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。
示例 1:
输入:
11110
11010
11000
00000
输出: 1
示例 2:
输入:
11000
11000
00100
00011
输出: 3
思路：grid[i][j]==‘1’
结果加一
变0
上下左右继续找
变0
上下左右继续找
…
class Solution { public int numIslands(char[][] grid) { if(grid==null||grid.length==0){ return 0; } int count = 0; int width = grid[0].length; int height = grid.length; for(int i=0;i&lt;height;i++) { for(int j=0;j&lt;width;j++) { if(grid[i][j]=='1') { count++; delete(i,j,width,height,grid); } } } return count; } public void delete(int i,int j,int width,int height,char[][] grid) { if(i&lt;0||i&gt;=height||j&lt;0||j&gt;=width||grid[i][j]=='0') { return; } grid[i][j]='0';//变0上下左右继续找 delete(i+1,j,width,height,grid); delete(i,j+1,width,height,grid); delete(i-1,j,width,height,grid); delete(i,j-1,width,height,grid); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e8e366fcf41a79a40882a1f39f0a964/" rel="bookmark">
			强化学习（二）：贪心策略（ε-greedy &amp; UCB）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		强化学习（二）：贪心策略（ε-greedy &amp; UCB） 夏栀的博客——王嘉宁的个人网站 正式上线，欢迎访问和关注：http://www.wjn1996.cn
强化学习是当前人工智能比较火爆的研究内容，作为机器学习的一大分支，强化学习主要目标是让智能体学习如何在给定的一个环境状态下做出合适的决策。强化学习相关概念请点击：强化学习（一）：概述
强化学习任务中有两个非常重要的概念——开发（exploit）和探索（explore），有时也分别叫做利用和试探。简单理解一下两者的概念：
开发：在强化学习中，开发指智能体在已知的所有（状态-动作）二元组分布中，本着“最大化动作价值”的原则选择最优的动作。换句话说，当智能体从已知的动作中进行选择时，我们称此为开发（或利用）；探索：指智能体在已知的（状态-动作）二元组分布之外，选择其他未知的动作。 开发与探索是强化学习中非常突出的一个问题，也是决定这个强化学习系统能否获得最优解的重点。我们试想一下，当在执行多臂赌博机任务时，你会事先选择其中几个拉杆来进行试探，当试探一定程度时，你会发现有一拉杆所获得的收益或比较多，因此在一定时间内，你会每次都选择这个拉杆。但是事实上，这个拉杆只是在你所选动作范围内是最优的（也就是局部最优），并不一定是全局最优，因此你还需要在开发的过程中，逐步去探索其他的拉杆。
开发对于最大化当前时刻期望收益是正确的做法，而探索则是从长远角度讲可能带来最大化总收益。然而不幸的是，在某一个状态下，智能体只能执行一个动作，要么开发，要么探索，二者无法同时进行，因此这就是强化学习重点突出的矛盾——权衡开发与探索。
下面介绍两个用于权衡开发与探索的策略—— ϵ − \epsilon- ϵ−贪心和UCB（最大置信度上界）
1、 ϵ − \epsilon- ϵ−贪心 在权衡开发与探索二者之间， ϵ − \epsilon- ϵ−贪心是一种常用的策略。其表示在智能体做决策时，有一很小的正数 ϵ ( &lt; 1 ) \epsilon(&lt;1) ϵ(&lt;1)的概率随机选择未知的一个动作，剩下 1 − ϵ 1-\epsilon 1−ϵ的概率选择已有动过中动作价值最大的动作。
假设当前智能体所处的状态为 s t ∈ S s_t\in S st​∈S，其可以选择的动作集合为 A A A。在多臂赌博机中，每一个拉杆可以代表一个动作，智能体在执行某一个动作 a t ∈ A a_t\in A at​∈A之后，将会达到下一个状态 s t + 1 s_{t+1} st+1​，此时也会得到对应的收益 r t r_t rt​。在决策过程中，有 ϵ \epsilon ϵ概率选择非贪心的动作，即，每个动作被选择的概率为 ϵ / ∣ A ∣ \epsilon/|A| ϵ/∣A∣，其中 ∣ A ∣ |A| ∣A∣表示动作数量；也就是说，每个动作都有同样 ϵ / ∣ A ∣ \epsilon/|A| ϵ/∣A∣ 概率的被非贪心的选择。另外还有 1 − ϵ 1-\epsilon 1−ϵ的概率选择一个贪心策略，因此这个贪心策略被选择的概率则为 1 − ϵ + ϵ / ∣ A ∣ 1-\epsilon + \epsilon/|A| 1−ϵ+ϵ/∣A∣。有人会问为什么是两项的和，其实很简单，在所有的动作集合 A A A中，在某一个时刻，总会有一个动作是智能体认为的最优动作，即 a ∗ = a r g m a x ( Q ( a , s ) ) a^*=argmax(Q(a,s)) a∗=argmax(Q(a,s))，因此这个动作本身有 ϵ / ∣ A ∣ \epsilon/|A| ϵ/∣A∣的概率在探索阶段被选择，还有 1 − ϵ 1-\epsilon 1−ϵ概率在开发阶段被选择。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e8e366fcf41a79a40882a1f39f0a964/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb47148e0ae0679de84146b78f396c58/" rel="bookmark">
			JAVA 获取时间戳并转换为日期格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技术小白一枚，欢迎大佬指教。 JAVA 获取时间戳并转换为日期格式
long time = new Long(System.currentTimeMillis());//获取当前时间戳 Date date = new Date(time); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String formatTime = simpleDateFormat.format(date); System.out.print(formatTime); 运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17f570ca6d62b9c9cabd1e360c236040/" rel="bookmark">
			汇编语言常见错误与部分语法--题目练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是我们老师的作业：
请指出下列指令的错误。
1）MOV AX,[CX]
2）MOV AL,1200H
3）MOV AL,BX
4）MOV [SI][DI],AX
5）MOV ES:[DX],CX
6）MOV [AX], VALUE
7）MOV COUNT,[SI]根据题目要求，写出相应的汇编指令。
1）把BX寄存器的值传给AX。
2）将立即数15送入CL寄存器。
3）用BX寄存器间接寻址方式将存储单元的字与AX寄存器的值相加，结果在AX中。
4）把AL中的字节写入用基址变址寻址的存储单元中。
5）用SI寄存器和位移量VALUE的寄存器相对寻址方式，从存储单元中读出一个字送入寄存器AX。
6）将AX中的数与偏移地址为2000H存储单元的数相减，结果在AX中。 那么答案是什么呢？（这可能会是你比较关注的吧）
二话不说，上图片（图片链接；https://img-blog.csdnimg.cn/20200309211126405.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rpc2Z5,size_16,color_FFFFFF,t_70）
仅用于学习交流，切勿用于其他用途！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bd31a0a701dc152d7c0a8e926c93b8f/" rel="bookmark">
			Python中get、post请求详解(HTTP请求头、状态码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 GET1）导入模块2）发送请求3）响应请求 POSTHTTP请求头HTTP响应状态码 会话保持 我们知道通常浏览器支持get与post两种常见的请求方式，那么在python当中如何具体实现呢？ GET 首先是get，我们知道get指令比较简单，通常便是在浏览器窗口地址栏中使用?xx=xxxxx
那么在python当中如何实现这个过程呢？
首先我们需要了解requests模块
1）导入模块 import requests 2）发送请求 import requests r = requests.get('https://www.baidu.com') # 最基本的不带参数的get请求 re = requests.get(url='https://www.baidu.com/s', params={'wd':'python'}) # 带参数的get请求 这便实现了一个？get请求
3）响应请求 r.encoding #获取当前的编码 r.encoding = 'utf-8' #设置编码 r.text #以encoding解析返回内容。字符串方式的响应体，会自动根据响应头部的字符编码进行解码。 r.content #以字节形式（二进制）返回。字节方式的响应体，会自动为你解码 gzip 和 deflate 压缩。 r.headers #以字典对象存储服务器响应头，但是这个字典比较特殊，字典键不区分大小写，若键不存在则返回None r.request.headers	# 前提是你要在参数里面写入了headers r.status_code #响应状态码 r.raw #返回原始响应体，也就是 urllib 的 response 对象，使用 r.raw.read() r.ok # 查看r.ok的布尔值便可以知道是否登陆成功 #*特殊方法*# r.json() #Requests中内置的JSON解码器，以json形式返回,前提返回的内容确保是json格式的，不然解析出错会抛异常 r.raise_for_status() #失败请求(非200响应)抛出异常 POST 与get类似这里多说一点就是可以发送json请求
import requests import json r = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bd31a0a701dc152d7c0a8e926c93b8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c880fb4dcbe4196683197560d1ce3aff/" rel="bookmark">
			【CNN】卷积神经网络中param和FLOPs介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卷积神经网络中param和FLOPs介绍 CNN论文中在比较网络性能时经常会提到这两个参数，下面简单介绍这两个参数的含义。
Parameters：是指这个网络中参数的数量(训练网络时学习的参数)。这里的参数一般指的时参数W和b，也就是权重和附加值。
FLOPs：全称是floating point operations，即表示浮点运算次数(在CNN中也可简单成为网络的计算量)，小s后缀是复数的缩写。
------上面说道FLOPs，顺便提一下与他有些易混淆的FLOPS。
FLOPS：全称是floating point operations per second，意指每秒浮点运算次数，即用来衡量硬件的计算性能。比如NVIDIA在介绍不同型号显卡的计算力时，就是用的这个参数。
总结：Parameters和FLOPs都是用来计算网络复杂度的，Parameters可以简单理解为网络的参数数量，FLOPs可以简单理解为网络前向运算时的计算量，它们的数值越大，网络越”复杂”。
PS：说到这里又想到了一个参数(ˇˍˇ) ---&gt; FPS，它在CNN中指的是网络每秒钟能够处理图片的数量，例如FPS=20是指网络一秒钟可以处理20张图片。反推过来就是处理一张图片需要50ms.
好了，好了，不能再啰嗦这些小儿科了，万一被哪个大佬刷到要吵我吐口水了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6779082e5ba21e9b546bec1be96260b/" rel="bookmark">
			Eclipse隐藏和显示项目操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技术小白一枚，欢迎各位大佬指导。 项目隐藏 1、右键项目，点击"Close Project"，将项目关闭。
2、点击三角标志（View Memu），选择"Filters"
3、勾选"Closes Projects"选项，点击OK即可。
4、项目已成功隐藏。
显示隐藏项目 1、将"Closes Projects"取消选中，点击OK即可。
2、已成功显示项目。
3、右键项目，点击"Open Project"，将项目打开。至此显示隐藏项目操作已完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23d7ab09f3d137a007ecacde4a8459d3/" rel="bookmark">
			Python利用国内镜像安装包 HTTPSConnectionPool(host=&#39;files.pythonhosted.org&#39;, port=443): Read timed out
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 我们在使用Python的过程中，经常需要使用Python的非标准库。
但下载这些包的时候，要从国外网站上获取资源，这样的下载速度非常缓慢，而且经常会出现超时的问题，导致安装失败。
国内镜像： 我们可以从国内的网址获取这些包：
教育机构：
清华：https://pypi.tuna.tsinghua.edu.cn/simple
华中理工大学：https://pypi.hustunique.com/
山东理工大学：https://pypi.sdutlinux.org/
中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/
企业：
阿里云：https://mirrors.aliyun.com/pypi/simple/
豆瓣：https://pypi.douban.com/simple/
使用方法： pip install -i 网址 包名
举例：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple numpy
这样，Pycharm就会去清华的网站获取numpy包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/781420b29e60daa87c91c69f65f2fc2f/" rel="bookmark">
			IJCAI2018|分层时空LSTM在位置预测中的应用(HST-LSTM)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HST-LSTM: A Hierarchical Spatial-Temporal Long-Short Term Memory Network for Location Prediction
Dejiang Kong and Fei Wu
Zhejiang University
https://www.ijcai.org/Proceedings/2018/0324.pdf
定位技术有助于挖掘人物运动情况，目前已经积累的大量额轨迹数据。
如何高效利用这些数据来预测位置逐渐成为比较流行的研究课题，位置预测是位置服务（LBS）的基础。现有方法通常要么关注长期到访位置预测，比如几天或者几个月这种时间窗，这可以看作是poi推荐问题，要么关注实时位置预测，此即轨迹预测。
这篇文章集中在弱实时条件下的位置预测，旨在预测用户在接下来的几分钟或者几小时的运动情况。作者们提出时空长短期记忆模型（ST-LSTM），该模型将时空影响因素加入lstm，进而可以缓解数据稀疏的问题。
另外，作者们利用一种分层ST-LSTM，以编码解码的形式，对上下文历史到访信息进行建模，进而提升预测效果。
这篇文章提出的HSTLSTM在真实轨迹数据集上进行了测试，结果表明了其有效性。
用户轨迹及抽象和模型的图示如下
不同时间窗之后的目的地分布图示如下
先前的lstm没有考虑时空因素，作者们将时空因素加入了lstm
这篇文章的主要贡献在于
几个基本概念及解释如下
lstm的组成部分主要有以下几个
这篇文章的特色在于将时空因子加入lstm中
时空因子的具体表达式如下，该因子是基于加法算子的，这种算子既精确又高效
其中q和s的表达式如下
到访session的编码过程如下
全局上下文编码方式如下
解码及预测过程如下
整体目标函数形式如下
数据集信息及参数设置如下
参与对比的方法有以下几个
衡量指标有以下两个
效果对比图表如下（指标为ACC@k）
效果对比图表如下（指标为MRR）
不同时间窗和空间窗口下效果对比如下（以ACC@1为指标）
指标随迭代次数的变化趋势图示如下
时空因素作用于不同的门限单元效果对比如下
我是分割线
您可能感兴趣
IJCAI2019|基于会话和注意力机制的CTR预估模型DSIN(已开源)
AISTATS2018|密歇根大学提出新型在线boosting算法用于多标签排序(已开源)
KDD2019|基于注意力的深度学习如何实时预测购买还是浏览
AAAI2020|一种新型高效兼容多行为的推荐系统模型EHCF(已开源)
ICML2007|深度学习用于协同过滤的开篇作之一(出自深度学习鼻祖之一Hinton)
SIGIR2019|基于BERT的深度学习模型在信息检索中的应用(已开源)
SIGIR2019|基于注意力机制的新型深度学习模型(采莓树模型BIRD,已开源)
SIGIR2019|深度学习如何更好地用于学习排序(LTR)(已开源)
SIGIR2019|利用DeepSHAP来解释神经检索模型(已开源)
KDD2018|基于GBM的动态定价回归模型
KDD2018|超越deepfm的CTR预估模型深层兴趣网络DIN(已开源)
RecSys2019|优于DeepFM和XDeepFM的CTR模型FiBiNET
SIGIR2018|选择性GBDT(SelGB)用于排序学习(已开源)
IJCAI2019|基于对抗变分自编码的协同过滤框架VAEGAN
聊聊CatBoost
聊聊XGBoost CatBoost LightGBM RF GBDT
顶会中深度学习用于CTR预估的论文及代码集锦 (3)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/781420b29e60daa87c91c69f65f2fc2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc12db9dd3deafd140f91e17435fbf3f/" rel="bookmark">
			qt 工具栏下加文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我擦后面看了一下Qt自带这种样式的感觉自己SB了：
接口为：
ui.toolBar-&gt;setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
后面的都是废话，不用再看了。
在进行软件界面设计时，用户反应Qt默认的工具栏不是太美观，希望能在工具栏下面加上文字这样比较直观，效果图如下：
思路 去看看qt默认的Action不支持这样的样式，之后想自己定制一下。经过研究得到大概的思路：将Action替换为QToolButton；需要考虑的是有些Action不在本模块new出来，即在复用其他已经有的模块功能时，其他模块将Action封装到模块中了，需要通过GetxxxAction来获取Action，然后将Action加在工具栏上，之后发现QToolButton有一个setDefaultAction接口可以将Action和ToolButton关联起来，这样好像这个就不是问题了。还有一个问题就是qt一般加Action都在QtDesigner进行添加这样比较方便，而且菜单栏里面用的Action和工具栏里面用的是同一个，现在菜单栏里面用Action，工具栏中用ToolButton，那很多代码都要写两遍，如信号槽，代码会变得很冗余。
实现 确定了思路就去实现，具体的方法为：Action的添加跟平时一样在QtDesigner中新建并添加到菜单栏中，之后工具栏中不要添加。在代码中添加InitToolbar函数里面的实现为
QToolButton* open_tool_bar = new QToolButton();
open_tool_bar-&gt;setDefaultAction(ui.actionOpenFile);
open_tool_bar-&gt;setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
ui.toolBar-&gt;addWidget(open_tool_bar);
QToolButton* save_tool_bar = new QToolButton();
save_tool_bar-&gt;setDefaultAction(ui.actionSaveFile);
save_tool_bar-&gt;setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
ui.toolBar-&gt;addWidget(save_tool_bar);
ui.toolBar-&gt;addSeparator();
...
这样做的好处是屏蔽工具栏和菜单栏使用不同的对象带来的差异性，其他地方只用管Action就好，不用管ToolButton。这是我发现代码量最小，最好实现，而且还达到需求的方式。最后实现效果为：
效果还是不错的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/755af004a666910ff4c8852535e64972/" rel="bookmark">
			nginx代理不生效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：
操作系统：windows10
nginx版本：1.16.1
问题：
更改了nginx.conf后，在任务管理器里结束了nginx的进程，然后重新打开nginx.exe。可是访问代理到了错误的网站。
确定了下，nginx.conf里的配置没问题。神奇的事发生了：在任务管理器里结束了所有nginx的进程后，竟然还能访问到代理！！！证明代理没有真正的结束掉！
解决：
重启机器！
后续遇到nginx配置不生效的问题，先检查配置文件有没有错，然后重启nginx。还是有问题的话，停止nginx，然后访问代理看是否成功的停止了nginx。如果真的成功停止了再重启nginx；如果不是的话，尝试nginx.exe -s reload，不行就重启系统吧！
ps：查看应用是否运行着，及其进程号：找到之后就可以杀死进程等
tasklist /fi "imagename eq nginx.exe"
通过命令结束进程
taskkill /f /pid 17888 /pid 3372
如果有多个：taskkill /f /pid 2720 /pid 19012
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda90d1767d31317c5051482b5164433/" rel="bookmark">
			H3C Cloud lab连接CRT并保存会话
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先看清楚设备名最后的数字标识
在Oracle VM VirtualBox管理器中找到与上面编号一致的设备，选中设备，在打开设置 在设置中，找到串口–&gt;端口2–&gt;路径/地址，将地址复制
打开CRT，新建会话
选择Serial，然后将地址粘贴到Name of pipe
保存一个名字，然后就可以在会话列表中看到会话了
需要连接H3C中的其他设备只需要更改最后的编号就可以了
以上内容均属原创，如有不详或错误，敬请指出。 本文作者： 坏坏 本文链接： https://blog.csdn.net/qq_45668124/article/details/104726494 版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明出处！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8c5bcf99c8e3a9ebee99aa315f59670/" rel="bookmark">
			设计模式之工厂方法模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 工厂方法模式（Factory Method Pattern）示例 设计模式是经验总结，是学习软件设计的有效方法，因此，了解和理解现有的设计模式，是提高软件设计的有效途径之一，这里将介绍相关的设计模式，并通过示例了理解其用法。 工厂方法模式（Factory Method Pattern） 工厂方法模式定义了一个创建对象的接口，但是由子类来决定要实例化的类是哪一个。它让类把实例化推迟到了子类。
工厂方法模式是 Java 中最常用的设计模式之一，提供了一种创建对象的最佳方式，属于创建型模式。
**意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
主要解决： 主要解决接口选择的问题。
何时使用： 我们明确地计划不同条件下创建不同实例时。
如何解决： 让其子类实现工厂接口，返回的也是一个抽象的产品。
关键代码： 创建过程在其子类执行。
应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。
优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。
缺点： 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。
使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，“POP3”、“IMAP”、“HTTP”，可以把这三个作为产品类，共同实现一个接口。
注意事项： 作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。
示例 这里以产品创建为例，来说明如何使用工厂方法模式。
首先定义创建者和产品接口，有具体的创建者生产具体的产品，这是基本的设计思路，下面来看看具体实现。
先来看看创建者类，代码如下：
package cn.lut.curiezhang.designpattern.factorymethod; public abstract class Creator { public abstract Product makeProduct(); } 接着是产品类，代码如下：
package cn.lut.curiezhang.designpattern.factorymethod; public abstract class Product { abstract void print(); } 抽象层，两者之间是并行的关系，具体的创建者类来负责具体的产品类的对象的创建，从而，形成二者之间的关系。
具体的创建者A，代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8c5bcf99c8e3a9ebee99aa315f59670/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e56efc835d007f39dad69bb387f78975/" rel="bookmark">
			6个高效学习编程的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程确实不是一件容易的事情，除了要有较强的逻辑思维，还需要花大量的时间和集中力来提升或者维持一定的高度。
与其他的领域不一样的是，技术每日都在变，所以对于编程初学者是很难一直与时并进的。就算是技术大神和老司机们也是追赶的比较吃力的。在技术领域打滚的这些年里，通过经历和经验总结出一些高效的学习方式和方法，在这篇文章里与大家分享。让我们现在就在技术领域的学习之路上奔跑吧！
文章目录 锁定目标，风雨兼程选择目标目标寻找法不要蜻蜓点水先专注于会用而不是能用 采用学习策略经历建立策略 时间管理，提高效率多思考，多教学记录，总结改掉以下习惯总结推荐阅读 锁定目标，风雨兼程 在刚刚接触技术的时候，很多人都会比较迷茫。技术领域有前端后端并且各自有多种编程语言。选定前端后端后又发现越过一山还有一山高，面临更多的选择。甚至在技术领域打滚了多年后的技术人员也会迷茫，会开始质疑自己的前景，是否要换一门语言或者多学几门语言。所以锁定目标是高效学习的第一门课。
选择目标 如果你的目标是前端开发，前期的学习道路是比较明确的，HTML5+CSS3起步。但是如果你的目标是后端开发，还没有开始就已经有多扇门在你前面，让你瞬间选择困难了。所以这里我们就用后端语言选择作为一个例子讲解学习目标选择方法。
陷入学习目标选择困难症是因为技术每日每夜都在变，方向和未来都在摇摆。但是我们首先要有一个对技术有很好的判定能力。
大家应该很多时候都听过"JAVA才是世界上做好的语言"，"PHP才是世界上最好的语言"等等，这些在自己领域崇拜着自己所爱的语言技术爱好者。TA们并没有错，因为每个开发语言都在特定领域或者项目条件里是最好的语言。不过并没有世界上最好的语言，只有在某一个场景和条件下最适合使用的语言。每一种开发语言都有他擅长最合适的使用场景。
PHP - 更适合小型到中型网页端应用（大型应用就需要其他语言配合使)JAVA - 更适合大型应用，企业级应用（中小型应用用JAVA就是大材小用，浪费资源）PYTHON - 更适合用于爬虫，人工智能，脚本类应用 目标寻找法 所以在选择学习目标的时候，我们要有对技术的判定能力，不要轻易听取一些偏面的评价和定论而下决定。
选择学习目标时重要的决定因素:
在目前最实用的 - 学能用到的更容易上手，也更有价值难度跨度不要太高 - 难度跨越太大时间成本会越高感兴趣的 - 感兴趣才更能坚持，更有动力社区更大的 - 社区越大遇到问题时找答案的途径越多开源项目优先 - 开源的项目的技术更有未来 🎯 一旦锁定一个目标就要能懂，能用，能变，再扩张你的学习领域到其他的技术。
能懂 - 能懂的技术或者知识的理论和原理；能用 - 能把技术或者知识投入使用，投入实战项目；能变 - 能举一反三学到的技术或者知识，能变通，延伸拓展。 不要蜻蜓点水 这一点是很多初学者都会犯的错误。
不要浅入浅出，得不到技能还失去了时间。
学习要一步一个脚印，很多一开始学习编程往往会同时学习多个技术，其实这种学习方式不但没有效果反而还浪费时间浪费生命。锁定一个学习目标就要专注一个点上学习，重点学习。
举个例子，如果你想成为一个Java开发工程师，你是不需要从C学起，然后C++，最后才开始学习Java。我看到很多开发者刚开始都是这样学习，其实根本不需要从底层技术开始学习。既然你的学习目标是Java，那就直奔重点不浪费时间。稳固了基础开发语言后，选择一个框架开始深入专业实战知识。当你稳固了更专业的实战知识后，就可以开始学习这个技术的周边工具（比如IDE）让开发更加高效便捷。
📖 专研秘诀：
学习每一个知识或者技术，一定要深入浅出，深入学习和挖掘，吸取重要知识和技术。专心，专注，专研是一个技术人才的基本素养！ 先专注于会用而不是能用 很多开发者习惯性会过于专注于工具使用，写法，性能，可扩展性等等。初学者一般都会掉入工具使用和写法的坑，而资深的开发者会过于专注于性能和可扩展性。这时候往往会过度消耗学习时间，甚至忘记最初的学习目标。
用一个简单易懂的例子，“一个机械工程师不会浪费时间想怎么更好的使用TA的扳手，而是怎么可以组装好一个机器的部件” - 很多人会想，学会用更好的工具不是可以更快地安装好吗？但是现实是，你都还没有弄懂怎么安装，再好再有效的工具对你来说都是无用武之地。所以还没有学会前行，就不要先想着怎么跑。
再举例，如果你是正在学习使用Vue框架，不要太过于执着怎么使用Vue的周边工具，高级写法，性能隐患问题等等。你的目标应该是创建你的第一个首页然后直接投入开发一个小项目小应用。这样你的产出才是最高的，因为这样做更加专注于学会怎么使用Vue来实现功能，而不是更好的使用Vue框架。
在学习的时候要专注于会使用新的技术，而不是怎么用各种花式技巧来提高使用能力。
还有很多童鞋开始学一门技术时，会先开始看一大堆的知识和书籍，或者去看一些大型的项目用这个技术是怎么实现的。其实更有效的学习方式是小步快跑，学习的过程中开发一个小项目会让你更加有动力也更有趣。
约定自己在限定时间内完成小目标，如能完成就给自己一点小奖励。例如，你对你自己说"如果我下周五完成这个功能，我就让自己去看个电影"。记住奖励不需要很大，小步快跑，小奖小利，这样才能维持发自内心的动力和驱动力。不过就算没有达成小目标也不用气馁，失败时成功之母，所有成功的人都是通过在失败中总结成长壮大。
采用学习策略 每一个人都会有一种最合适自己的学习方式方法，适合我的不一定对你就有效 - 所以找到一种对你有效的学习方法很重要。
经历 学习方式方法是通过你日复一日，年复一年不停地尝试和总结得来的一种技巧。我也尝试过很多种方式来学习技术，自从我开始进入技术行业到现在，我换了无数种学习方式才找到最适合自己的一种技巧。
在一开始刚刚入门的时候，我尝试看很多"从入门到精通"，“XXX语言101"等等，最终的结果都是"从入门到放弃”。后面开始走视频学习之路，发现视频里面的老师说话好像是机器人一样，本来有点失眠症的，没想到一看视频秒睡着，被治好了！我以为我的技术生涯就要结束在这里了～ ¯_(⊙︿⊙)_/¯
建立策略 前方无绝路 · 希望在转角 ～ 我迅速改变了策略，学习技术和其他领域不一样除了看书，撸视频还需要动手去敲代码。学习任何一门技术，可以遵循以下学习策略，可以让学习的技术和知识更加稳固。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e56efc835d007f39dad69bb387f78975/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/300f6a7d0ffa3d33e07cc637c8938879/" rel="bookmark">
			Linux内存管理第八章 -- Slab Allocator （一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Linux内存管理第八章 -- Slab AllocatorCachesCache Descriptor Cache Static FlagsCache Dynamic FlagsCache Allocation FlagsCache ColouringCache CreationCache ReapingCache ShrinkingCache Destroying Linux内存管理第八章 – Slab Allocator 在本章中，来介绍内核中更加通用的分配器。Linux使用的slab allocator与用在Solaris中使用的通用分配器有许多相似之处。Linux的实现基本上是在Bonwick的the first allocator论文的基础上进行了一些改进而这些改进与他后续的论文中的描述十分相似。在深入探讨slab allocator的每个部分之前先来通过一段描述快速浏览下slab allocator所使用的数据结构。
slab allocator背后的思想是缓存经常使用的object并保持在初始状态供kernel使用。如果被基于object的allocator，内核将耗费很多时间在分配，初始化和释放相同的object。slab allocator的目的就是缓存一些被释放的object因此这些基础的structures在多次调用期间被预留起来。
slab allocator由一组cache组成，这些cache由一个叫做cache chain的双向循环链表连接在一起。在slab allocator的上下文件，一个cache就是一个管理许多像mm_struct或者fs_cache这种特殊类型的object的管理者。这些cache通过cache struct的next字段连接在一起。
每一cache维护了有多个连续物理page组成的block，这些block称之为slab。slab被切分成很多小块来存放slab自身的数据结构和其管理的object。他们之前的关系如下图：
slab allocator有三个基本目标：
更小块的内存分配可以帮忙消除buddy allocator原本会造成的内部碎片问题。缓存常用的object因此系统不会在分配，初始化和销毁object上浪费时间。在Solaris上的Benchmarks显示使用slab allocator之后对于分配速度有很大的提升。通过将object地址与L1或者L2 cache对齐后可以更好的利用硬件缓存。 为了帮助消除buddy allocator造成的内部碎片问题，系统有维护两个cache集合，这些cache由细小的内存块组成，其大小从25字节到217
其中一个cache集合供DMA设备使用。这些cache叫做size-N和size-N(DMA)m其中N是指要分配的内存大小。可以调用kmallock()来分配这些cache中的memory。这样就解决了buddy allocator带来的low level page中的内部碎片问题。也就是如果只分配几个字节，如果没有slab allocator的话，也需要分配一个page。
slab allocator的第二个任务是维护一些cache来分配常用的object。在内核中使用的许多结构体，初始化的时间甚至超过了分配时间。因此当一个新的slab被创建的时候，多个object被构造函数初始化后打包放入到slab中。如果一个object被释放了，它仍然以初始状态存放在slab中以以便object的分配能够加快。
slab allocator最后一个任务是利用硬件缓存。如果object打包放入slab后还有剩余空间，这些剩余空间将被用来将slab着色。slab着色是一种尝试让在不同slab中的object在硬件cache中使用不同的行的方案。在不同的slab中将object以不同的起始偏移来进行摆放，这就好像这些object在使用CPU硬件缓存的不同行一样来帮助保证从同一个slab分配出来的object不会相互从CPU硬件缓存中被刷掉。使用这种方案后，原本要浪费的空间被添加上了一种新的功能。下图显示了从buddy allocator中分配出来的一个page如何被用来存储与L1 CPU缓存对齐的object。
如果在编译阶段CONFIG_SLAB_DEBUG被打开，slab allocator提供了附加的slab debug功能。有两个debug功能：red zoning和object poisoning。使用red zoning后，object的两端会被放置水位标记。如果该水位不正常，分配器就知道当前object在分配的时候发生了buffer溢出的问题并立即上报。poisoning一个object是指在slab创建时和object释放时将object填充预定义好的bit pattern。在分配的时候，该pattern会被检查如果该pattern被修改了，allocator就知道该object在分配之前已经使用过了并标记它。
slab allocator提供了短小精悍的API，如下表：
kmem_cache_t * kmem_cache_create(const char *name, size_t size, size_t offset, unsigned long flags, void (ctor)(void, kmem_cache_t *, unsigned long),void (dtor)(void, kmem_cache_t *, unsigned long))创建一个新的cache并将它加入到cache chain中 int kmem_cache_reap(int gfp_mask)最多扫描REAP_SCAN个cache并选择其中一个来回收所有的per-cpu objects然后将该cache中的slab释放。该函数在memory很紧张时被调用 int kmem_cache_shrink(kmem_cache_t *cachep)该函数将删除一个cache中所有的per-cpu objects，并删除slabs_free list中的所有slabs，然后返回释放的page数目 void * kmem_cache_alloc(kmem_cache_t *cachep, int flags)从cache中分配单个object并将object返回给调用者 void kmem_cache_free(kmem_cache_t *cachep, void *objp)释放一个object并将它返还到cache中 void * kmalloc(size_t size, int flags)从匿名cache中分配一块memory void kfree(const void *objp)将kmalloc分配的内存块释放 int kmem_cache_destroy(kmem_cache_t * cachep)销毁cache中的所有slab中的所有object并释放与之相关的memory然后再将该cache从cache chain中剔除 Caches 每个cache只能缓存一种类型的object，也就是cache中有多个slab，每个slab中有多个object，但每个object的类型都相同。在一个正在运行的Linux系统中，可以通过cat /proc/slabinfo 来查看当前所有可用的caches列表。/proc/slabinfo文件中给出了cache的一些基本信息。下面来看一下该文件内容的摘要：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/300f6a7d0ffa3d33e07cc637c8938879/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/090b5a174f2aeda3545e965443273a3d/" rel="bookmark">
			方舟编译器课程笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		词法、语法分析实现方法之分 使用lex、yacc或类似的生成器构建手写语法分析器、语法生成器 初始化项目 创建项目文件夹
mkdir bace03 cd bace03 初始化git仓库。
git init 创建测试用例
mkdir test git add test/ vi test/square.pl0 添加文件：
VAR x, squ; PROCEDURE square; BEGIN squ:= x * x END; BEGIN x := 1; WHILE x &lt;= 10 DO BEGIN CALL square; ! squ; x := x + 1 END END. 提交任务
git commit -am 'add a new test case' 配置git快捷操作
git config --global alias.st status git config --global alias.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/090b5a174f2aeda3545e965443273a3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b6c622b266280a0754223d04292e4f0/" rel="bookmark">
			Java实现部标JTT1078实时音视频传输指令——视频流负载包（RTP）传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 说一说实现的思路 1.接收平台方下发的0x9101命令（实时音视频传输请求）2.解析下发的0x9101命令，拿到音视频上传数据的服务器IP和端口号3.开始获取设备摄像头的每一帧视频数据，这里需要注意的是：视频数据支持的格式有：H.264，H.265，AVS，SVAC；详细的可以查看JTT1078协议的（表12）4.将每一帧的数据封装成（表19）音视频流及透传数据传输协议负载包格式 二、解析平台下发的0x9101命令这里就不说了，拿到下发的数据在上传视频流的时候需要 解析到数据后就连接上服务器即可。 三、获取视频流数据并编码成H.264视频格式 我这里是在Android平台实现的可以看下我这篇文章Android采集摄像头的视频流数据并使用MediaCodec编码为H264格式 四、将获取到的H.264视频流的每一帧数据进行RTP包封装，来看下协议 5.5.3 ： 五、提取出一些重要的信息 表中定义的bit位按照大端模式填写：也就是将bit按字符串从左到右排列然后在转成byte字段PT（负载类型，见表19）:这处是文档写错了，应该是见（表12）字段数据类型：I/P/B帧的判断，这个就大家可以参考下这位博主的H264码流的I/P/B帧NALU判断
简单说下：一帧H264的视频流数据一般为0x00 0x00 0x00 0x01 或 0x00 0x00 0x01开头，所以0x01后面的这个字节就是NALU类型数据体长度不超过950个byte：如果一帧数据大于了950byte就需要分包了 下面就来看代码的具体实现了
//实时视频数据包序号 private static int RTP_VIDEO_COUNT = 0; //计算这一I帧距离上一I帧的间隔 private static long LAST_I_FRAME_TIME; //计算这一帧与上一帧的间隔 private static long LAST_FRAME_TIME; /** * 打包实时视频RTP包 * * @param data H.264一帧的视频数据 * @param phone SIM卡号 * @param liveClient 与服务器的连接 */ public static synchronized void videoLive(byte[] data, int channelNum, String phone, LiveClient liveClient) { List&lt;byte[]&gt; dataList = new ArrayList&lt;&gt;(); //每个包的大小 double everyPkgSize = 950.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b6c622b266280a0754223d04292e4f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/626af8987f7133a82cb0da54d4657b2f/" rel="bookmark">
			数据竞赛修炼笔记之快手用户活跃度的预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这段时间，会有系列真实的竞赛项目陪伴，我会通过修炼笔记的方式记录我这段时间学习数据竞赛的经历，希望每个竞赛都能给我们带来收获和成长！ 这个故事会很长，但我会坚持往下走，你看，天上太阳正晴，如果可以，我们一起吧…
1. 写在前面 终于下定决心涉足这个纠结很久的话题了，作为一个懵懂无知的竞赛小白，其实是非常渴望参加一场数据比赛的，因为数据比赛对于AIer来说真的很重要，不知道你是否遇到过这样的一些疑惑，就是涉足一个新领域的时候，比如数据挖掘，先非常努力的花时间学习python，numpy，pandas，scipy，sklearn这些基础知识，但是当后面真的遇到实际问题的时候，却不知道如何下手去分析，再回头想掏之前学会的工具时，发现这些工具依然在，但已记不清它们的使用说明。难不成之前学习过的这些都白学了？ 其实不是的，这些工具都在，只不过我们之前没有真正的去用过它， 所以，比赛就是一个让我们大展身手的舞台，通过解决实际问题，我们才能真正掌握之前的工具，也是学习知识的一个融合，毕竟解决实际问题，需要各个领域的知识交融和碰撞。在这个过程中，我们还可以认识一些志同道合的伙伴，一起进步和交流，进行思维的碰撞并得到成长。
所以这个数据竞赛修炼系列我会把我的所思所学都记录下来并分享，一是因为解决问题的思路可以迁移和变换，这样或许会帮助更多的人，二是通过整理和总结，可以使得知识和技能在自己脑海中逗留的时间长一些吧。
首先声明这个系列的每一篇都会很长，并且会有一大波代码来袭，毕竟每一篇都是一个完整的数据竞赛，每一篇都需要很长的时间消化整理，因为我想用最朴素，最详细的语言把每个比赛的思路和代码说给你听。
今天是数据竞赛修炼笔记的第一篇，带来的比赛是2018年科赛网上的一个比赛快手用户活跃度的预测，我们拿到了一份快手平台记录的关于快手用户的30天一个行为数据集(记录用户注册，登录，视频观看与发布，互动的记录），我们的目标就是根据这个行为数据集预测在未来七天的活跃用户。
首先我们会对任务的目标和数据进行分析，然后会概览模型的架构，从模型的角度提取特征和标签构建数据集，然后基于tensorflow建立模型并训练得到结果。最后会再结合一些好的解决方案，对解决这个问题的思路和知识点进行总结。
大纲如下：
任务目标与数据分析整理模型架构构建用户特征，生成汇总表制作标签建立模型并训练，得到最后的结果知识点和思路的总结（两个知识点温习：pandas的iterrows()和groupby()） Ok, let’s go!
开始之前，需要导入包：
import numpy as np import pandas as pd import tensorflow as tf from deep_tools import f from deep_tools import DataGenerator 2. 任务目标和数据分析 在这一部分，我们先看看拿到的是一份什么样的数据，然后分析一下我们这个任务到底怎么应该去做。
我们会拿到四个表格，分别是：
用户注册日志表，记录的是用户什么时候使用什么方式（微信，qq）什么设备（手机，pad）进行注册的快手账号，会有四个字段的信息，注意，day这一列，由于我们搜集的是30天的数据，所以这里的取值是1-30， 表示的是用户第几天的行为，后面那几份数据也是一样。
APP启动日志表，记录的是用户在第几天登录过快手app， 两个字段的信息
视频创建日志表， 记录的是用户在第几天创作过视频
用户行为日志表，这个比较关键，也是我们后面制作特征的主要渠道来源，由用户的行为才能看出用户是不是活跃
下面，我们就导入数据，详细的看一下这些数据吧 """读取数据集""" register = pd.read_csv('user_register_log.txt', sep='\t', names=['user_id', 'register_day', 'register_type', 'device_type']) launch = pd.read_csv('app_launch_log.txt', seq='\t', names=['user_id', 'launch_day']) create = pd.read_csv('video_create_log.txt', seq='\t', names=['user_id', 'create_day']) activity = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/626af8987f7133a82cb0da54d4657b2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/971bc86b9171cc442f7619a29d96d7ce/" rel="bookmark">
			keras.utils.Sequence使用注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）在实现自己的DataLoader过程中一般都是继承自keras.utils.Sequence，继承该类必须要实现__len__与__getitem__两个函数。
2）在调用fit_generator进行训练时，如果设置了step_per_epoch参数，则每个epoch训练step_per_epoch个step，每个step有batch_size数据，因此每个epoch共训练step_per_epoch*batch_size的数据。如果没有设置step_per_epoch参数，则每个epoch训练的step个数由__len__决定。
3）在训练过程中step_per_epoch的个数可以大于 ceil(float(数据集图片数量)/batch_size) ，这个数字可以认为是遍历一遍数据集需要的实际step数量，__len__一般也实现为这个数字。在每遍历过一次数据集后（确切的说是调用__len__次），会调用一次on_epoch_end()。
4）__getitem__在调用时会有一个index参数，这个参数的取值范围就是range(__len__)的结果，index参数的值是在这个范围内随机给定的。因为__len__实现的时候使用的是ceil向上取整，因此很有可能最后一个index就无法取到一组满batch数据，因为数据集图片数量能够正好整除batch_size的情况很少。如果没有取到一组满batch数据，此时可以返回None，或者干脆什么都不返回。fit_generator在检查到是None的时候会再调用__getitem__一次。
5）所以这个地方要特别注意一点，图片无论是训练集还是验证集的数量一定不能小于batch_size，因为如果图片数量小于batch_size，则永远不能取到一组满batch，程序就会进入无限循环。另一方面在计算__len__的时候，使用了ceil，那么__len__至少大于等于1，也不存在不进入__getitem__的情况。除非数据集图片数量是0。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c6af2a63ce3551eae0bcd2155da5d7e/" rel="bookmark">
			Redis_数据备份与恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Redis 数据备份与恢复 文章目录 Redis 数据备份与恢复1.SAVE 命令2.恢复数据3.Bgsave 1.SAVE 命令 Redis SAVE 命令用于创建当前数据库的备份。
实例
redis 127.0.0.1:6379&gt; SAVE OK 2.恢复数据 如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 CONFIG 命令，如下所示：
redis 127.0.0.1:6379&gt; CONFIG GET dir 1) "dir" 2) "/usr/local/redis/bin" 以上命令 CONFIG GET dir 输出的 redis 安装目录为 /usr/local/redis/bin。
3.Bgsave 创建 redis 备份文件也可以使用命令 BGSAVE，该命令在后台执行。
实例
127.0.0.1:6379&gt; BGSAVE Background saving started 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/867c01a6d8b0b3c00d128e160b208538/" rel="bookmark">
			Jenkins instance appears to be offline 完美解决方案总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人安装的配置如下
Jenkins版本：2.204.4
Ubuntu：16.04.3 LTS (GNU/Linux 4.4.0-105-generic x86_64)
在安装Jenkins时候遇到的Jenkins在安装的时候一直显示“Jenkins instance appears to be offline”
找了很多五花八门的解决办法。但是无一能解决我的问题。经历了各种折腾后我找到了我的解决办法。同时也在这里记录一下所有我收集到的解决办法。希望可以帮到其他折腾中的童鞋们。
文章目录 解决办法1 - 安全证书问题HTTS/SSL修改`hudson.model.UpdateCenter.xml` 解决办法2 - 连接失败因为无法访问google 解决办法1 - 安全证书问题HTTS/SSL 如果你安装在本机比如MacOS, Windows, 本地虚拟机等，你会发现你的本地无法请求Jenkins的HTTPS链接。 这个问题可以通过修改hudson.model.UpdateCenter.xml里面的url地址，从https改为http。
修改hudson.model.UpdateCenter.xml 找到hudson.model.UpdateCenter.xml的所在文件路径
find / -name "hudson.model.UpdateCenter.xml" # 输入以上命令会返回所有这个文件的所在路径 /var/lib/jenkins/hudson.model.UpdateCenter.xml macOS的同学文件路径在：
/Users/Shared/Jenkins/Home/hudson.model.UpdateCenter.xml
编辑hudson.model.UpdateCenter.xml
sudo vim /var/lib/jenkins/hudson.model.UpdateCenter.xml 找到文件里面的以下内容
... &lt;url&gt;https://updates.jenkins.io/update-center.json&lt;/url&gt; ... 改为
... &lt;url&gt;http://updates.jenkins.io/update-center.json&lt;/url&gt; ... 或者可以改为使用中国镜像
... &lt;url&gt;https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json&lt;/url&gt; ... 修改好之后重启Jenkins，
http:localhost:8080/restart或者sudo service jenkins restart用brew安装的可以使用brew services restart jenkins-lts 然后重新访问Jenkins网址，就会发现Jenkins可以正常安装了。
如果这个方法无效,可以看看第二种方式
解决办法2 - 连接失败因为无法访问google 如果第一种方式无效，那很有可能就是我遇到的这种，这种估计也只有在国内才会出现，所以基本上网上找不到这种同样的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/867c01a6d8b0b3c00d128e160b208538/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/178d2be9eb10c936f91d9f8b5fc9ca66/" rel="bookmark">
			Python基础30道练习题（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python小白一枚，欢迎各位大佬指教。 1、通过输入函数input和raw_input()输入学号和姓名，显示出 “学号+姓名”
stunum = input("请输入学号：") name = input("请输入姓名：") print("姓名：" + stunum + "，学号：" + name) 运行结果：
2、接收一个复数的实数和虚数部分，输出其复数表示形式及它的模。
a = int(input("实数a：")) b = int(input("实数b：")) z = (a**2 + b**2)**0.5 com = complex(a, b) print("复数：" + str(com) + " 模：" + str(z)) 运行结果：
3、输入三个整数x,y,z，请把这三个数由小到大输出。
num =[] print("请输入x,y,z数字：") for i in range(0,3): num.append(int(input())) num.sort() print(num) 运行结果：
4、将一个数组逆序输出。
num = ['1', '12', '31', '24', '52'] num.reverse() print(num) 运行结果：
5、利用条件运算符的嵌套来完成此题：学习成绩&gt;=90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。
score = float(input("请输入分数：")) if score &gt;= 90: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/178d2be9eb10c936f91d9f8b5fc9ca66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69e65bcb02c61ca195cbb5fd55484705/" rel="bookmark">
			Redis_连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 连接 文章目录 Redis 连接1.Auth 命令2.Echo 命令3.Ping 命令4.Quit 命令5.Select 命令 Redis 连接命令主要是用于连接 redis 服务。 1.Auth 命令 Redis Auth 命令用于检测给定的密码和配置文件中的密码是否相符。
密码匹配时返回 OK ，否则返回一个错误。
redis 127.0.0.1:6379&gt; AUTH PASSWORD (error) ERR Client sent AUTH, but no password is set redis 127.0.0.1:6379&gt; CONFIG SET requirepass "mypass" OK redis 127.0.0.1:6379&gt; AUTH mypass Ok 2.Echo 命令 Redis Echo 命令用于打印给定的字符串。
redis 127.0.0.1:6379&gt; ECHO "Hello World" "Hello World" 3.Ping 命令 Redis Ping 命令使用客户端向 Redis 服务器发送一个 PING ，如果服务器运作正常的话，会返回一个 PONG 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69e65bcb02c61ca195cbb5fd55484705/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26112d9b95d34f27db60a4d47084e169/" rel="bookmark">
			花了半个月，终于把Python库全部整理出来了，非常全面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载
原文出处：https://www.jianshu.com/p/d25a9169fe86
库名称简介
Chardet，字符编码探测器，可以自动检测文本、网页、xml的编码。
colorama，主要用来给文本添加各种颜色，并且非常简单易用。
Prettytable，主要用于在终端或浏览器端构建格式化的输出。
difflib，[Python]标准库，计算文本差异Levenshtein，快速计算字符串相似度。
fuzzywuzzy，字符串模糊匹配。
esmre，正则表达式的加速器。
shortuuid，一组简洁URL/UUID函数库。
ftfy，Unicode文本工具7
unidecode，ascii和Unicode文本转换函数。
xpinyin，将汉字转换为拼音的函数库
pangu.py，调整对中日韩文字当中的字母、数字间距。
pyfiglet，Python写的figlet程序，使用字符组成ASCII艺术图片
uniout，提取字符串中可读写的字符
awesome slugify，一个Python slugify库，用于处理Unicode。
python-slugify，转换Unicode为ASCII内码的slugify函数库。
unicode-slugify，生成unicode内码，Django的依赖包。
ply，Python版的lex和yacc的解析工具phonenumbers，解析电话号码，格式，存储和验证的国际电话号码。
python-user-agents，浏览器的用户代理（user-agents）的解析器。
sqlparse，SQL解析器。
pygments，一个通用的语法高亮工具。
python-nameparser，解析人名，分解为单独的成分。
pyparsing，通用解析器生成框架。
tablib，表格数据格式，包括，XLS、CSV，JSON，YAML。
python-docx，docx文档读取，查询和修改，微软Word 2007 / 2008的docx文件。
xlwt/xlrd，读写Excel格式的数据文件。
xlsxwriter，创建Excel格式的xlsx文件。
xlwings，利用Python调用Excelcsvkit，CSV文件工具包。
marmir，把Python[数据结构]，转化为电子表格。
pdfminer，从PDF文件中提取信息。
pypdf2， 合并和转换PDF页面的函数库。
Python-Markdown，轻量级标记语言Markdown的Python实现。
Mistune，,快速、全功能的纯Python编写的Markdown解释器。
dateutil，标准的Python官方datetime模块的扩展包，字符串日期工具，其中parser是根据字符串解析成
datetime，而rrule是则是根据定义的规则来生成datetime。
arrow,更好的日期和时间处理Python库
chronyk，一个Python 3版函数库，用于解析人写的时间和日期。
delorean，清理期时间的函数库。
when.py，为见的日期和时间，提供人性化的功能。
moment，类似Moment.js的日期/时间Python库
pytz，世界时区，使用tz database时区信息[数据库]
BeautifulSoup，基于Python的HTML/XML解析器，简单易用, 功能很强大,即使是有bug，有问题的html代码，也可以解析。
lxml，快速，易用、灵活的HTML和XML处理库，功能超强，在遇到有缺陷、不规范的xml时，Python自带的xml处理器可能无法解析。报错时，程序会尝试再用lxml的修复模式解析。
htmlparser，官方版解析HTML DOM树，偶尔搞搞命令行自动表单提交用得上。
pyyaml，Python版本的YAML解释器。
html5lib，-标准库，解析和序列化HTML文档和片段。
pyquery，类似[jQuery]的的HTML解释器函数库。
cssutils，Python CSS库。
MarkupSafe，XML或HTML / XHTML安全字符串标记工具。
cssutils - ACSS library for Python.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26112d9b95d34f27db60a4d47084e169/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c28ffb2a1d36ae397eefddc6c7591ca7/" rel="bookmark">
			Java技术总结（基础篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仅对部分java基础内容做了简单整理，若有笔误或错误出现，欢迎大家指教。
一、JavaSE 1.Java分为三个体系： JavaSE→java平台标准版JavaEE→java平台企业版JavaME→java平台微型版 2.Java编程语言主要特性： 面向对象分布式简单化多线程安全跨平台移植性 3.JVM、JRE、JDK JVM：Java虚拟机(主要用于与操作系统进行交互)JRE:Java运行时环境(包含了JVM，Java提供的核心类库)JDK:Java开发工具包(包含了JRE，Java开发工具集) 4.JDK包结构 ①为了便于使用和维护，JDK类库按照包结构划分，不同功能的类划分在不同的包中。②java.lang→Java程序的基础类，如字符串、多线程等该包中的类使用的比较频繁，不需要导包，可以直接使用。③java.util→常用的工具类，如集合、随机产生器、日历等。④java.io→文件操作，输入/输出操作。⑤java.math→数学运算相关的操作。⑥java.sql→数据库访问。 5.标识符命名规范： ①由26个英文字母大小写，0~9，_或$组成。②数字不能开头。③不能包含空格。④java严格区分大小写。⑤不能使用关键字，可以包含关键字。⑥尽量"见名知意"。 6.变量名命名规范： ①长度不能超过255个字符②※变量名在有效范围内必须是唯一的(声明变量)③多单词组成时，第一单词首字母小写，从第二个单词开始，每个单词首字母大写 7.运算符： ①算数运算符：+, -, *, /, %, ++, –②关系运算符：&gt;, &lt;, ==, &lt;=, &gt;=, !=③逻辑运算符：&amp;, |, &amp;&amp;, ||, !, ^④赋值运算符：=, *=, /=, +=, -=, %=⑤三元运算符：(条件表达式)?表达式1(true):表达式2(false);⑥位运算符 8.基本数据类型（4类/8种） ①整数类型：byte(8位), short(16位), int(位32/默认), long(64位)②浮点型：float(32位), double(64位/默认)③布尔型：boolean(true/false)④字符型：char(char c = ‘a’😉 9.类型转换（自动类型转换/强制类型转换） 1.自动类型转换：
byte/short/char→int→long→float→double
备注：其中byte、short、char三者之间不能直接相互转换
2.强制类型转换（是自动类型转换的逆过程）：
布尔型不能进行类型转换精度损失内存溢出 10.循环结构 ①while循环
while(条件表达式){
循环体；
}
②do_while循环
do{
循环体;
}while(条件表达式)；
③for循环
for(初始化;条件表达式;更新){
循环体
}
④嵌套循环
外层循环控制行数，内层循环控制每行的个数内层循环是外层循环的循环体 ⑤关键字break/continue
break:跳出，结束continue:跳过，越过 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c28ffb2a1d36ae397eefddc6c7591ca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cbb92b5dacf5057c8d3723b586c3b61/" rel="bookmark">
			&#39;you-get&#39; 不是内部或外部命令，也不是可运行的程序 或批处理文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能原因：未正确设置环境变量导致
解决办法：找到pip you-get的安装位置，手动添加设置环境变量
（1）如何找到 you-get的安装位置
win+R 输入 cmd 键入
pip show you-get 找到Location
复制地址 c:\users…\python38\site-packagesc:\users…\python38\site-packages
(2)添加环境变量
打开 电脑右键属性-高级系统设置-高级-环境变量-变量-Path
新建 把刚刚复制出来的路径粘贴进去（#地址中的最后一处\site-packages 替换成Scripts
点击 确定
重新加载 cmd 输入 you-get
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88524fd0c9471f67f6431aa46e3745af/" rel="bookmark">
			明明安装了某个库，但还是显示ModuleNotFoundError: No module named &#39;flask&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因：1：python 、pip 存在多个版本，或者升级过
2：权限问题，有的是root，有的是非 root权限
解决方法：1：搜索路径：
import sys print(sys.path) 2:指定环境变量PYTHONPATH
set PYTHONPATH=D:\anaconda\Lib\site-packages 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26bfd0ebc483ab94afcd2c63070a680f/" rel="bookmark">
			@Value注入List、Map失败，Could not resolve placeholder
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平时经常会使用@Value注入yml文件中的变量，但是今天使用@Value注入一个List时却报错了，程序启动失败，报Could not resolve placeholder 'blackList' in value "${blackList}”，有点懵逼。
Yml中尝试过行内和行外两种写法，都不行
行内:
blackList: 127.0.0.1,192.0.0.1 行外：
blackList: - 127.0.0.1 - 192.0.0.1 代码注入：
@Value("${blackList}") private String[] blackList; 网上搜了很多如何通过yml注入List，大多都是@ConfigurationProperties的方式将变量注入类的属性中。这时候上面的写法是可以注入成功的。但是我不想因为注入一个参数就编写一个类。
后来看到有文章说@Value和@ConfigurationProperties在注入数组时行为是不同的。
@Value and @ConfigurationProperties behave differently when binding to arrays
后来看到大牛的方案试了下，果然可以，太厉害了，记录膜拜下
@Value("#{'${blackList}'.split(',')}") private List&lt;String&gt; blackList; 除了List不能@Value直接注入，Map也是，这里也贴出Map的转换方法：
@Value("#{${paramMaps}}") private Map&lt;String,String&gt; paramMaps; Yml：
blackList: 127.0.0.1,192.0.0.1 paramMaps: "{userId: 'u123', seckillId: 'g00001'}" 至此，问题解决！
可以看到上面我们使用了spring的表达式#{}，功能还是很强大的，有兴趣可以深入了解下。@Value至此springEL,但是@ConfigurationProperties是不支持的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4feb96172ad6e10fef3072428633d418/" rel="bookmark">
			Hive-SQL获取表中复杂结构数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据格式基本如下：
col1 "{""couponSetting"":[{""amount"":""xxxxx"",""type"":""优惠券"",""boxxsrsarow"":""50万"",""_batchssId"":""4718"}"],""totalCount"":6,""couponExplain"":""优惠xxxxxxx选、U（服xxxxxxxx月），每xxxxxxx次。""}" 方法一：当字段col1是String类型时，我们可以直接使用中括号来获取，
select col1['key的名字'] from ods.ods_xxxx limit 1000 方法二：当字段col1不是String类型是，我们用方法一去获取的时候会报错如下：
Error while compiling statement: FAILED: SemanticException [Error 10033]: line 1:7 [] not valid on non-collection types ''col1'': string
含义就是字段并非是String字符串类型，我们需要使用特殊处理的方式，这里我们可以使用：get_json_object（key,"$.xxx"）
的方式来获取。
例如：
select get_json_object(col1,'$.要获取的key') from ods.ods_xxxx where activityid='14' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4747cfa814bc0cb4593da0126dd7fde/" rel="bookmark">
			x-oss-process=image/resize,请求图片附加参数不一样，显示大小和分辨率跟着改变，详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片请求路径：
https://i.vzan.cc/zt/image/HomeImage/jpeg/2017/12/20/19530418efddd9eba34b789d4942c7d8a98b8d.jpeg?x-oss-process=image/resize,limit_0,m_fill,w_200,h_200/quality,q_100
图片原路径：
https://i.vzan.cc/zt/image/HomeImage/jpeg/2017/12/20/19530418efddd9eba34b789d4942c7d8a98b8d.jpeg
通过这2个分析可以看出，图片请求路径都是一样的，只是后面附加了一些参数：
一、参数：?x-oss-process=image/resize,limit_0,m_fill,w_200,h_200/quality,q_100
二、大小
三、分辨率
感觉这个东西好强大！
……………分割线…………………
阿里云OSS 图片处理api（custom）
lhttps://blog.csdn.net/extendworld/article/details/81989955
首先放个阿里云OSS图片处理接口文档 阿里云官方地址 OSS 图片处理接口文档
我们有时会抱怨用户上传的图文中图片文件大了（假如说3M的图片）。导致生成的网页打开速度慢，怎么办呢？
问题分析：网页打开慢是因为网页资源下载的那张图片下载慢。只要能够改变用户上传的大小就能解决这个问题。
方案一： 限制用户上传文件的大小？ 1、使用的用户并不懂程序，限制了大小用户是否会觉得体验感不好？
方案二：图片上传后我们是否能对图片进行处理使之改变该图片的大小（压缩）？ 1、我们写的程序处理图片的接口就一定很好吗？ 2、我们有那么多精力去做这个吗？ 3、我们能否在网上查询相应的资源下载对应的图片处理接口包来使用？安装使用的流程复杂吗？ 4、能否在现有的资源下找个免费的第三方平台免费帮助我们？
然后我根据自己的情况我选择了上述的方案二 - 4 这个方法 采用OSS自带的图片处理机制来帮助我们。 我只说一下我的使用心得。 我的需求只是压缩用户上传上来的图片文件大小 假设我的OSS域名是 http://demo.oss-cn-xxxxx.aliyuncs.com 在该demo bucket下我上传了一张图片 test.jpg 文件大小是3M 假设http能访问到的地址 http://demo.oss-cn-xxxxx.aliyuncs.com/test.jpg
现在我想更改这个图片文件的大小。怎么办？ 1、更改图片清晰度 2、缩小图片尺寸 我能想起的就是这两个方法 但是根据我的需求不能更改缩小图片的尺寸，那么只能是更改图片的清晰度了。 http://demo.oss-cn-xxxxx.aliyuncs.com/test.jpg?x-oss-process=image/quality,q_60 原图清晰度的60% http://demo.oss-cn-xxxxx.aliyuncs.com/test.jpg?x-oss-process=image/quality,q_80 原图清晰度的80%
看到了吧？ queryString ： x-oss-process=image/quality,q_{int} 这个就是更改图片清晰度的结尾参数 {int}取值0~100
当然我们还可以对图片进行多次处理
裁剪 http://demo.oss-cn-xxxxx.aliyuncs.com/test.jpg?x-oss-process=image/circle,r_100
先压缩再裁剪 http://demo.oss-cn-xxxxx.aliyuncs.com/test.jpg?x-oss-process=image/quality,q_80/circle,r_100
是不是很方便，不需要我们自己去写代码，只要我们自己在参数后面加入对应的参数就行了。
当然如果你有自己的阿里云域名（通过域名映射指向的阿里云域名的，如demo.xxxxx.com 指向阿里云的demo.oss-cn-xxxxx.aliyuncs.com） 怎么去实现上述的功能呢？ 一样的，什么都不需要变化。直接点： http://demo.xxxxx.com/test.jpg?x-oss-process=image/circle,r_100 http://demo.xxxxx.com/test.jpg?x-oss-process=image/quality,q_80/circle,r_100
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4747cfa814bc0cb4593da0126dd7fde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0133d072743f8300353c4b83e38f20f/" rel="bookmark">
			数据增强方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数据增强方法一、单样本数据增强方法1.1 几何变换类1.2 颜色变换类 二、多样本融合数据增强2.1 SMOTE2.2 SamplePairing2.3 mixup2.4 cutout2.5 cutmix2.6 Fmix2.7 roimix 三、无监督数据增强方法3.1 GAN3.2 Autoaugmentation 数据增强方法 一、单样本数据增强方法 1.1 几何变换类 包括翻转，旋转，裁剪，变形，缩放等方式
1.2 颜色变换类 包括噪声、模糊、颜色变换、擦除、填充等方式
二、多样本融合数据增强 2.1 SMOTE SMOTE即Synthetic Minority Over-sampling Technique方法，它是通过人工合成新样本来处理样本不平衡问题，从而提升分类器性能。
类不平衡现象是很常见的，它指的是数据集中各类别数量不近似相等。如果样本类别之间相差很大，会影响分类器的分类效果。假设小样本数据数量极少，如仅占总体的1%，则即使小样本被错误地全部识别为大样本，在经验风险最小化策略下的分类器识别准确率仍能达到99%，但由于没有学习到小样本的特征，实际分类效果就会很差。SMOTE方法是基于插值的方法，它可以为小样本类合成新的样本。
主要流程为：
第一步，定义好特征空间，将每个样本对应到特征空间中的某一点，根据样本不平衡比例确定好一个采样倍率N；
第二步，对每一个小样本类样本(x,y)，按欧氏距离找出K个最近邻样本，从中随机选取一个样本点，假设选择的近邻点为(xn,yn)。在特征空间中样本点与最近邻样本点的连线段上随机选取一点作为新样本点，满足以下公式：
第三步，重复以上的步骤，直到大、小样本数量平衡。
2.2 SamplePairing SamplePairing方法的原理非常简单，从训练集中随机抽取两张图片分别经过基础数据增强操作(如随机翻转等)处理后经像素以取平均值的形式叠加合成一个新的样本，标签为原样本标签中的一种。这两张图片甚至不限制为同一类别，这种方法对于医学图像比较有效。
2.3 mixup λ∼Beta(α,α)，α∈(0,∞)。
(xi,yi)和(xj,yj)是从训练数据中随机抽取的两个样本，且λ∈[0,1]。因此，mixup通过结合先验知识，即特征向量的线性插值应导致相关标签的线性插值，来扩展训练分布。
作用为：将两个类别之间用线性过度，提高介于两个类别之间的泛化力，如图所示。
2.4 cutout 随机的将样本中的部分区域cut掉，并且填充0像素值，分类的结果不变；
2.5 cutmix 就是将一部分区域cut掉但不填充0像素而是随机填充训练集中的其他数据的区域像素值，分类结果按一定的比例分配。
2.6 Fmix 根据图像的高频和低频区域对图像进行二值化，然后利用该掩模对像素进行加权。
2.7 roimix 用于水下检测，模拟重叠，遮挡，和模糊的目标。
三、无监督数据增强方法 无监督的数据增强方法包括两类：
(1) 通过模型学习数据的分布，随机生成与训练数据集分布一致的图片，代表方法GAN[4]。
(2) 通过模型，学习出适合当前任务的数据增强方法，代表方法AutoAugment[5]。
3.1 GAN (1) G是一个生成图片的网络，它接收随机的噪声z，通过噪声生成图片，记做G(z) 。
(2) D是一个判别网络，判别一张图片是不是“真实的”，即是真实的图片，还是由G生成的图片。
3.2 Autoaugmentation AutoAugment是Google提出的自动选择最优数据增强方案的研究，这是无监督数据增强的重要研究方向。它的基本思路是使用增强学习从数据本身寻找最佳图像变换策略，对于不同的任务学习不同的增强方法，流程如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0133d072743f8300353c4b83e38f20f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8952ae050ed05d28f0ea65556a584be4/" rel="bookmark">
			关于极光鉴权认证一键登录请求接口的3个相关问题的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天开始准备调用极光推送的REST API发现报了很多错。postman和idea都试过了
报错1: post请求接口，返回{"code":9010,"content":"missing auth"} 出这个错，请仔细查看官方文档https://docs.jiguang.cn/jverification/server/rest_api/rest_api_summary/
鉴权方式
极光 REST API采用 HTTP 基本认证的验证方式。基本做法为，HTTP Header 中加 Authorization：
Authorization: Basic ${base64_auth_string} Header 名称是 "Authorization", 值是 base64转换过的 "appKey:masterSecret"（中间有个冒号）。这两者可以在极光开发者服务的Web控制台[应用设置]-[应用信息]中查看。
报错2: {
"code": 9011, "content": "auth failed" }
出现这个错误，十有八九是你通过postMan请求，把Authorization放到header里面了。。。具体的做法如图
而不是直接在headers里面加个Content-Type：application/json
Authorization Basic MDQzNDdkNDU5Y2QwODZhOTFjNWRlNjU1OjY5YThmODM4ZGV-----------------------
官方给出的解释是：文档里面提供的方式是restapi的方式，postmen是封装好了的
post此时应该可以请求了。
那么java代码怎么写呢？
/** * @Description 极光推送专用post * @Author PrinceCharmingDong * @Date 2020/3/4 */ public static String doPostForJpush (String url, String JSONBody,String appKey,String masterKey) { CloseableHttpResponse response = null; CloseableHttpClient httpClient = null; String responseContent = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8952ae050ed05d28f0ea65556a584be4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5af0dc5e4f5af05dd786f0e9cd121917/" rel="bookmark">
			概率统计22——假设检验理论（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们可以根据经验或统计量对一些事情做出断言，问题是，如何判断这个断言的合理性？假设检验为我们提供了一种利用样本检验断言是否可靠的方法，能够让我们通过已有的证据验证断言是经过缜密的运算，还是毫无根据的瞎猜。
假设检验的背景 某个机器元件的质量标准是功率，功率越大越好，这个元件影响到公司的核心竞争力。技术组在攻克了重重难题后宣称有了重大突破。总经理非常高兴，宣布批量试制。然而改进后的数据却并不那么漂亮，功率均值从原来的600mW提升到603mW，仅仅提升了0.5%，这让总经理大为光火，立即召集技术组开会。
0.5%看起来确实没什么太明显的提升。面对面色铁青的总经理，技术部拿出了改进前的功率分布：
这是个很陡峭的分布曲线，暗示着这个元件的功率控制得十分精细，或者说功率的波动很小，3mW的波动已经相当于“基因突变”了。这样看来，0.5%的提升确实算得上是重大改进。
某个软件公司用每千行的bug数量衡量软件的质量（这里不讨论这种方法是否合理），多年来也做过了很多项目，平均bug率是5.5‰，即每千行代码5.5个bug，勉强达到CMM2的标准。
最近公司全面实施了新的开发方法，发现新项目的bug率降低到4.5‰，这可是降低了18%！于是QA部门的老大在年会上对着分布图激动地宣布，公司软件质量从此迈上了新台阶。
程序员们瞟了一眼分布图，露出了谜之微笑。
上面两个故事告诉我们，在质量改善的过程中，质量提升的百分比并不能作为有效性的唯一依据，0.5%可能是重大提升，18%也可能根本说明不了问题。检验的依据是，改善后是否在改善前总体正常波动的范围内。如果在正常波动范围内，则可以认为并没有什么改善，否则认为有显著改善。这个显著性具体如何判断呢？
显著性水平与置信水平 假设下图是哈尔滨市民年收入的概率分布：
大多数人都在20万附近徘徊。
恰好李冰冰出生于哈尔滨市，不小心把她也统计进去了。大明星的收入肯定比普通市民多得多。
李冰冰明显和普通市民不是一伙的，她的年收入显著高于绝大多数市民，早已跨过了高收入的门坎。某个人的收入落在高收入群体的概率就是显著性水平（Significant Level）。
小明的年收入是25万，和大多数人差不多，我们相信小明是一名普通市民的概率还是比较高的，这个概率就是置信水平（Confidenct Level）。
高收入群体占了总体的多大比例呢？也就是显著性水平应该如何取值？
第一个回答这个问题的人是罗纳德・艾尔默・费舍尔（RonaldAylmerFisher）。
费舍尔（1890 - 1962）是英国统计学家、生物进化学家、数学家、遗传学家和优生学家。是现代统计科学的奠基人之一。著名的F分布就是费舍尔提出的，并以其姓氏的第一个字母命名。
费舍尔提出0.05显著性水平，至于为何要选择0.05，老头在《研究工作者的统计方法》（Statistical Methods for Research Workers）中做过长篇大论，网上有一篇文章叫“Why P=0.05?”（http://www.jerrydallal.com/lhsp/p05.htm），很值得看一下。
现在我们用显著性水平和置信水平去看待哈尔滨市民年收入的问题：
单侧大于显著性
高收入群体在曲线右侧，是“单侧大于”显著性，表示一个人属于高收入群体的概率是0.05，李冰冰明显属于这一侧。相对的，一个人不属于高收入群体的概率是0.95。
现在要判断一个人是否属于低收入群体，此时应当使用“单侧小于”显著性。小明隔壁正好住着一个叫王二的游手好闲的邻居，每个月都等着领政府的救济金混日子，年收入自然很低，绝大多数人都不愿意和他为伍。这类人游手好闲群体在曲线左侧的0.05部分：
单侧小于显著性
除此之外，还有双侧显著性。按照费舍尔的0.05显著性水平理论，双侧检验时要在总体分布的两端各设定一个临界点，临界点以外，两端阴影部分的面积比率各为0.025，表示超低收入群体和高收入群体一样稀少：
有人说我显著性水平不用0.05行不行？当然没问题，具体怎么设定完全取决于实际问题，0.05只是一个常用的取值。如果想检验得严一点，显著性水平要相应放低，比如0.01；如果宽松一点，显著性水平可以稍高一点，比如0.1，此时你也要同时承担置信水平下降的后果。
有了显著性水平后和置信水平后，就可以从直观上回应总经理的愤怒并理解程序员们的谜之微笑，但我们仍然缺少一些理论知识。检验理论究竟蕴含着怎样的逻辑呢？
假设检验的逻辑 我一直很喜欢打乒乓球，一个好友和我从小学一直打到大学毕业，基本上旗鼓相当。工作之后，我天天苦练球技，自认为如果再次交手一定比他更强。年假回家，我俩又一次站在球台边，并以15局为限，看看时隔多日之后谁更胜一筹。
结果是我5胜10败。
由于几乎每一局都是苦战，所以我并不服气，认为这纯属偶然，如果再打一次，结果完全不可预估。我的理由是：抛15次硬币，10次正面朝上完全有可能。对方则是持否定态度，认为这绝对是实力的差距。
我们二人的争论包含了两种截然相反的假设：
我的假设，H­0：双方势均力敌，获胜的概率都是0.5。
朋友的假设，H­1：这个结果表明实力的差距，他的获胜的概率大于0.5。
从朋友的立场来看，他想要证明自己是对的，因此把我的H0假设看成原假设（或者叫待验假设、虚无假设），也是他想要驳斥的假设。H1是H0的备择假设（或者叫对立假设、备选假设），是他试图肯定的假设。他的证明逻辑是：如果H0成立，那么出现H1这样的数据的概率将小于α，这个概率用p表示，称为p值（p-value），作为阈值的α是上一节的显著性水平，取α=0.05。用p值是否大于α作为判断依据：
这有点类似于反证法，如果无法直接证明H0是错的，就转换策略，暂且相信H0是对的， 这种情况下出现H1的概率将小于0.05。这种小概率事件应该不容易在抽样中出现，但现在偏偏出现了，是个强有力的反驳证据，所有应当转而相信H1。
现在来计算一下p值。按照原假设H0，我们二人实力相当，每一场比赛的胜率都相等。假设每场比赛都是独立的，用随机变量X表示朋友获胜的总数，那么X符合总数是15，胜率是0.5的二项分布X~B(15, 0.5)，p值是：
可以用计算机直接计算：
from scipy import stats c = stats.binom.cdf(10 - 1, n=15, p=0.5) # X~B(n, p)的累积分布 p = 1 - c 结果p ≈ 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5af0dc5e4f5af05dd786f0e9cd121917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff3b8c60366f7db85b3610dc232641f1/" rel="bookmark">
			Qwidget  无法加载背景图片，或设计师显示背景图片，运行时不显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文链接：https://blog.csdn.net/luokehua789789/article/details/55511676
一、设置方法有两种，如下：
1、利用style sheet给窗体设置背景
使用stylesheet设置背景图片还是有一些要注意的，如果是在mainwindow和dialog中，直接右键change style sheet在add resource中选择background-image或者border-image，选择资源文件中的图片就行了（前者是按像素显示图片，后者可根据窗体大小来自动缩放图片，通常使用后者，前者如果界面与图片大小不一样，则背景的显示可能就不是整张图片了），如下图：
注意：
a、但在widget中就不行，你会发现，用同样的方法，背景并没有发生改变，而仅仅是它的子窗体背景图片发生了改变。 那么在widget中要如何做呢，我们在widget中放置一个frame，然后对frame通过stylesheet设置背景，后面窗体里所有的部件都放在这个frame里。 b、 我们知道，子窗体会继承父窗体的属性，也就是说，父窗体的背景，在子窗体中也会有，那如何让子窗体不继承父窗体的背景呢，同样的，还是在Edit Style Sheet里，需要输入如下代码：（这样就可以解决窗体中的按键、QLable等控件与主窗体的一样。） #desktop {
border-image: url(:/images/desktop.jpg);
}
#desktop * {
border-image:url();
}
desktop是你的窗体名。
例如 QWidget widGet;则样式表需要写成
#widGet {
border-image: url(:/images/desktop.jpg);
}
#widGet * {
border-image:url();
}
针对QWidget设计师含有背景图片，而运行时没有，则需要用以下方法
2、不过也可以通过如下代码来实现：
QWidget *widget = new QWidget(); widget-&gt;setAutoFillBackground(true); QPalette palette; QPixmap pixmap(":/Resources/Penguins.jpg"); palette.setBrush(QPalette::Window, QBrush(pixmap)); widget-&gt;setPalette(palette); widget-&gt;show(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4a8a2f4bf42a5584186b43bbdafb08d/" rel="bookmark">
			com.alibaba.fastjson 把JSONObject转换为Map(String, Integer)对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.TypeReference;
JSONObject obj = new JSONObject();
{
obj.put("key1", "value1");
obj.put("key2", "value2");
obj.put("key3", "value3");
}
Map&lt;String, Integer&gt; params = JSONObject.parseObject(obj.toJSONString(), new TypeReference&lt;Map&lt;String, Integer&gt;&gt;(){});
System.out.println(params);
//输出：{key3=value3, key2=value2, key1=value1}
List&lt;FlowoutHotel&gt; flowoutList = JSONObject.parseObject(v, new TypeReference&lt;List&lt;FlowoutHotel&gt;&gt;() { });
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.61&lt;/version&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46a1a11f981557a7705a3a6aa9e0a65d/" rel="bookmark">
			Pyqt5，QListWidget中添加QCheckBox并实现多选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pyqt5，QListWidget中添加QCheckBox并实现多选 实现效果图
引入
插入
得到值
返回结果
免责声明
实现效果图
引入
from PyQt5.QtWidgets import QMainWindow,QListWidget, QListWidgetItem, QCheckBox 插入
def insert(self, data_list): """ :param list: 要插入的选项文字数据列表 list[str] eg：['城市'，'小区','小区ID'] """ for i in data_list: box = QCheckBox(i)	# 实例化一个QCheckBox，吧文字传进去 item = QListWidgetItem() # 实例化一个Item，QListWidget，不能直接加入QCheckBox self.listWidget.addItem(item)	# 把QListWidgetItem加入QListWidget self.listWidget.setItemWidget(item, box) # 再把QCheckBox加入QListWidgetItem 得到值
def getChoose(self) -&gt; [str]: """ 得到备选统计项的字段 :return: list[str] """ count = self.listWidget.count() # 得到QListWidget的总个数 cb_list = [self.listWidget.itemWidget(self.listWidget.item(i)) for i in range(count)] # 得到QListWidget里面所有QListWidgetItem中的QCheckBox # print(cb_list) chooses = [] # 存放被选择的数据 for cb in cb_list: # type:QCheckBox if cb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46a1a11f981557a7705a3a6aa9e0a65d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3994858a565c69c6cd9d6c87178b7c9/" rel="bookmark">
			理解Linux解压tar -xzf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 tar tar本质上不是解压缩命令，而是备份文件的命令。
是 -xzf 这几个参数实现了解压缩的功能。
语法 tar(选项)(参数) 常用命令 -x或--extract或--get：从备份文件中还原文件； -z或--gzip或--ungzip：通过gzip指令处理备份文件； -f&lt;备份文件&gt;或--file=&lt;备份文件&gt;：指定备份文件； gzip命令 gzip命令用来压缩文件。
References 菜鸟教程：Linux tar命令Linux命令大全 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c982b813035eedfcc71a4cc62ef235a/" rel="bookmark">
			第二课：fasterRCNN之ROI Pooling层解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ROI Pooling的意义 ROIs Pooling顾名思义，是Pooling层的一种，而且是针对RoIs的Pooling，他的特点是输入特征图尺寸不固定，但是输出特征图尺寸固定；
借助于RoI pooling，Fast R-CNN可以复用卷积特征。考虑到所有候选区域均位于一张图片上，Fast R-CNN对图像整体进行卷积。RoI pooling为每个候选区域提取固定大小的特征图。R-CNN在原始图像上进行裁剪，而Fast R-CNN在特征图上进行裁剪。
什么是ROI呢？
ROI是Region of Interest的简写，指的是在“特征图上的框”；
1）在Fast RCNN中， RoI是指Selective Search完成后得到的“候选框”在特征图上的映射，如下图所示；
2）在Faster RCNN中，候选框是经过RPN产生的，然后再把各个“候选框”映射到特征图上，得到RoIs。
参考文章
Faster RCNN-2 (ROI Pooling和ROI Align)Faster R-CNN源码中ROI Pooling的解析 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/929444e1b662aaa579ff5ea0551f4b5f/" rel="bookmark">
			有符号数和无符号数区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在计算机中，数值类型分为整数型或实数型，其中整型又分为无符类型或有符类型，而实型则只有符类型。 字符类型也分为有符和无符类型。在程序中，用户可以自己定义是否需要一个非负整数；
用char来举例吧，char占一个字节，一个字节=8个二进制位，所以它可以表示2^8个数，也就是256个数。若想要表示正负号，一般需要一个位来标记，如取最高代表正负号，则有符号和无符号的数值最大值对比如下：
1 有符号：0111 1111 = 2^6+2^5+2^4+2^3+2^2+2^1+2^0 = 127; ==&gt; 范围是 -128 ~ 127 2 3 无符号：1111 1111 = 2^7+2^6+2^5+2^4+2^3+2^2+2^1+2^0 = 255；==&gt; 范围是 0 ~ 255 可以看出无符号数只有正数,没有负数,所以比如一个8位元可以储存的最大正数的个数是2的8次方也就是256.而有符号数,因为要兼容负数的可能性,就要牺牲一个位元来做符号表明.所以一个有符号数的最大正数的个数就是2的（8-1次方）再减掉1…是127.
我们可以在程序中直观的看一下他们之间的区别：
int main() { char c = 127; unsigned char u = 127; return 0; } 结果如下：
当取值大于127时，再看程序：
int main() { char c = 128; unsigned char u = 128; return 0; } 结果发生了变化，因为定义的c是有符号数，又因为c的表示范围是-128~127，所以当赋值c为128超过他的表示范围是，显示的值变为-128，有个小技巧，即128-256=-128，，若赋值-129，超过了其负数表示范围，就变成了-129+256=127，程序验证：
int main() { char c = -129; unsigned char u = -129; return 0; } 还有一个问题就是溢出的问题，char是个8位的二进制数，若超过了八位，就只算其16进制的末尾的两位的大小。比如unsigned char的表示范围是0x00~0xFF，若表示0x8FF，则溢出，指标是后两位，即FF，8忽略掉，程序验证：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/929444e1b662aaa579ff5ea0551f4b5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44534fdf1f626f86ce7699ca2be7d882/" rel="bookmark">
			定积分（黎曼和）的编程实现(java和python实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Talk is cheap. Show me the code. a是积分下限，b是积分上限 f是被积函数 代码如下(Java版本):
public class RiemannSum { public static void main(String[] args) { final int times = 100000000; double a, b; double sum = 0; a = 1; b = 3; double delta = (b - a) / times; for (int i = 1; i &lt;= times; i++) { sum += delta * fSin(a + i * delta); } System.out.println(sum); } public static double f(double a) { return Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44534fdf1f626f86ce7699ca2be7d882/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/930f1aee860f0bac67d69cd8d602dd88/" rel="bookmark">
			【目标检测】用自己的数据集训练Faster RCNN的详细全过程（步骤很详细很直观，小白可入）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、写在前面 最近和小伙伴一起参加了服务外包比赛，选择的题目是对于图像中的安全帽的检测。对YOLOv3，Faster RCNN这些常见的目标检测算法都进行了实验。本文就介绍Faster RNN的整个实验过程。
二、电脑相关配置 win10，python3.6
三、训练过程 实验选用的源码是较为常用的Faster RCNN源码。对于该源码的使用网上也有很多的博客文章，但是正是因为文章很多，所以也容易造成一些误导，所以也踩过一些坑。以下是我测试过的可以正确训练的步骤：
1 安装支持包 首先要安装源码运行需要的支持包。下载的Faster RCNN源码中有一个requirement.txt文件，其中记录了需要安装的包的名字。可以在cmd中输入pip install -r requirements.txt安装需要的所有依赖包。也可以自己手动一个个安装，需要的python依赖包有，cython，opencv-python，easydict，Pillow，matplotlib，scipy。
2 修改config.py文件 在lib/config下的config.py文件，是专门的配置文件，其中定义了模型的诸多参数，大家可以根据自己的需要修改相关参数，下面介绍较为重要的需要修改的参数。
（1）network参数
定义预训练使用的模型，我见到的最多的是使用vgg16模型（源码默认也是使用vgg16），也可以使用resnet模型。我采用的是vgg16模型。
（2） learning_rate参数
这个就是我们熟知的学习率，学习率定义的太小收敛速度会很慢，学习率定义的太大可能会导致不收敛。这个参数可以多次调整，分别训练，取一个最优的学习率。
（3） batch_size参数
这个也是很熟知的一个参数，定义的是每一个梯度的大小。一般用的比较多的是32，64，128，256这些batch_size。batch_size太大，内存容量可能撑不住，但是下降方向更准确，震荡更小，而且训练相同量的数据集速度更快；batch_size太小，内存利用率就变小了，但是容易陷入局部最优。个人理解是，如果内存够大，硬件允许的话，batch_size设置的大一些会更容易收敛，效果也会更好。
（4）max_iters参数
这个参数定义的是最大的迭代次数。
（5） snap_iterations参数
这个参数定义的是迭代多少次保存一次模型。个人觉得snap_iterations和max_iters要比较匹配，修改的话需要一起修改。因为如果max_iters参数定义的较小，但是snap_iterations很大的话，就看不到自己生成的模型了。模型保存的路径是default/voc_2007_trainval/default。每次保存模型都是保存4个文件。
（6） roi_bg_threshold_low
这个参数定义的是background（背景）认定的ROI的最小阈值。这里我没有深入研究，但是在运行train.py文件进行训练的时候如果产生Exception：image invalid，skipping。此时修改此处的值为0.0，会解决问题。
3 添加预训练模型 由于我们训练的时候是基于一个预训练模型进行训练的，所以需要下载vgg16模型，并且保存在data/imagenet_weights中。下载的模型命名一般是vgg_16.ckpt，但是我们要修改为vgg16.ckpt。原因是要和源码中调用部分代码一致，源码中调用的名称就是vgg16.ckpt。如果此处不修改，在源码中全部采用vgg_16.ckpt应该也是可以的，但是何必要这么麻烦呢。附上vgg16的百度网盘链接，提取码为45ef。vgg16模型的百度链接
4 制作数据集 为了可以清楚的显示数据集的制作过程，我将项目中的文件目录截下来。VOCDevkit2007中存放的就是数据集。JPEGImages中放的是图片，Annotations中放的是图片对应的xml文件。test.txt，train.txt，trainval.txt，val.txt中存放的是测试集，训练集，训练验证集，验证集对应的图片名称。至于划分数据集是按照我们自己的意愿进行划分就好，源码并未提供划分代码。划分源码如下，修改name_path（图片所在路径），四个txt文档的的路径，就可以在自己电脑上运行并生成对应txt的内容。
from sklearn.model_selection import train_test_split import os name_path = r'.\data\VOCdevkit2007\VOC2007\JPEGImages' name_list = os.listdir(name_path) names = [] for i in name_list: # 获取图像名 names.append(i.split('.')[0]) trainval,test = train_test_split(names,test_size=0.5,shuffle=10) val,train = train_test_split(trainval,test_size=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/930f1aee860f0bac67d69cd8d602dd88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c94f574c95978531d081930127a20674/" rel="bookmark">
			Vue路由懒加载（resolve）,嵌套路由 3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		懒加载：又叫延时加载，即在需要的时候进行加载，随用即载
使用懒加载的原因：
像vue这种（spy）单页面应用，如果没有使用到懒加载，webpack打包的文件过大，造成进入首页时，加载的资源过多，时间过长，即使做了loading也不利于用户体验，而运用懒加载可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载事件，简单来说就是进入首页不用一次加载过多资源造成时间过长
https://blog.csdn.net/weixin_42331327/article/details/108463527 Vue3.0 路由的配置
Vue3路由(跟vue2差别不大) 1.安装vue-router 最新 支持vue3 router的版本eg: “vue-router”: “^4.0.0-beta.13”
由于 vue-cli 没有直接支持创建 Vue3.0 项目，所以需要通过插件升级，我们输入指令：
vue add vue-next import { createRouter,createWebHashHistory } from 'vue-router' const HelloWorld = () =&gt; import("@/components/HelloWorld") const routes = [ { path: '/', name: 'HelloWorld', component:HelloWorld }, ] const router = createRouter({ //负责管理历史的属性，有三种历史可选 //hash,history,memory history: createWebHashHistory(), routes }); export default router //代码中编程式导航也是通过createRouter获取router的,route也一样 main.js引入 import router from './router/index' //引入 app.use(router) app.mount('#app')或者 createApp(App).use(router).mount('#app') 或者 懒加载的使用方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c94f574c95978531d081930127a20674/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d10915634526a2f6fb91097c2fc64e71/" rel="bookmark">
			javaEE_SSM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 内容概述1.工具技术简述mybatisSpringSpringMVCMaven 2. 项目功能项目流程 3. 搭建环境 内容概述 mybatis Spring SpringMVC Maven项目功能搭建环境 1.工具技术简述 mybatis 持久层的框架技术
hibernate是mybatis的前身, 有一些老项目使用hibernate进行维护
持久层技术: 和数据库交互的技术
参考官方文档 link
JDBC: java database connection
xml和注解 代替jdbc代码和手动设置参数
xml配置sql映射 接口
调用方法的对象是接口的真是对象吗? 代理对象
事务管理器: 代理对象操作数据库的时候, 提供事务的控制
&lt;transactionManager type="JDBC"/&gt; MybatisPlus, 通用mapper 增强工具
Spring 官网
Spring全家桶
一站式服务, 无缝连接, 非侵入式设计
EJB编程: 面向组件编程
IOC: 控制反转
Spring提出容器的概念, 容器内存放了多个对象, 控制对象生命周期的所有环节(创建 使用 维护 销毁)
AOP: 面向切面
代码中有大量方法, 每个方法都需要进行日志的记录–&gt;代码冗余
降低耦合性 提高复用性 扩展性 可维护性
SpringMVC mvc设计模式: 理论定义
Maven 开发的时候将jar包手动添加到web工程中的lib里
软件项目的管理工具
git SVN 版本控制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d10915634526a2f6fb91097c2fc64e71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb5bd1481b1d6cdc1db76c9ec5f684c1/" rel="bookmark">
			统计学习方法（二）：感知机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标：
1.掌握感知机的模型形式、损失函数及对应的优化问题。 损失函数推导过程：
最终优化函数：
min L(w,b) 2.掌握随机梯度下降算法原理。 推导过程：
3.理解感知机模型中随机梯度算法的收敛性。 习题： 1.思考感知机模型假设空间是什么？模型复杂度体现在哪？ 假设空间 {f|f=wx+b}，即特征空间中的所有线性分类器。模型的复杂度主要体现在实例特征向量的维度d上或者特征数量上。
2.已知训练数据集D，其正实例点是x1=(3,3)T,x2=(4,3)T，负实例点是x3=(1,1)T: (1) 用python 自编程实现感知机模型，对训练数据集进行分类，并对比误分类点选择次序不同对最终结果的影响。可采用函数式编程或面向对象的编程。 import numpy as np class Perceptron: def __init__(self, x, y, n, eta): self.x = x # 实例点 self.y = y # 实例点的分类 self.n = n # 实例点个数 self.eta = eta # 学习率 # 随机梯度下降法 def SGD(self): # 对w,b取初值 w = np.array([0, 0]) b = 0 # 记录一次迭代是否有误分类点 flag = 1 while flag == 1: flag = 0 for i in range(n): # 如果有误分类点 if self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb5bd1481b1d6cdc1db76c9ec5f684c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20a66d5bf8c6aa5597681d4cde613b40/" rel="bookmark">
			【DP】将一个数组分为两个数组，使两个数组和的差最小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* 将一个数组分为两个数组，使两个数组和的差最小 */ public class SplitArray{ public int diff(int[] array){ int sum = 0; for(int i=0; i&lt;array.length; i++){ sum += array[i]; } int[][] dp = new int[array.length+1][sum/2+1]; for(int i=1; i&lt;=array.length; i++){ for(int j=1; j&lt;=sum/2; j++){ if(j-array[i-1]&gt;=0){ dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-array[i-1]] + array[i-1]); }else{ dp[i][j] = dp[i-1][j]; } } } return sum - 2*dp[array.length][sum/2]; } public static void main(String[] args) { int[] arr = {1,0,1,7,2,4}; SplitArray solution = new SplitArray(); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20a66d5bf8c6aa5597681d4cde613b40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce6b639804b512ae81132e34980f39e0/" rel="bookmark">
			npm run build报错（npm ERR! code ELIFECYCLE）的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体报错如下图：
node_modules安装问题，我们需要重新安装
rm -rf node_modules rm package-lock.json npm cache clear --force npm install 最后再npm run build，即可成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3b86226211d5396fe42ac79ac2368c0/" rel="bookmark">
			[Python]利用python&#43;ffmpeg合并B站视频及格式转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用python+ffmpeg合并B站视频及格式转换 B站客户端下载的视频一般有两种格式：早期的多为blv格式（由flv格式转换而来，音视频轨道在同一文件下）。如今的多为m4s格式，音频轨视频轨分开 以下为利用ffmpeg简单对文件处理，使其转换为大多数播放器能正常播放的mp4格式 前提：已正常安装ffmpeg import tkinter as tk from tkinter import filedialog import os import tkinter.messagebox from tkinter import ttk mainGUI=tk.Tk() width = 400 height = 400 screenwidth = mainGUI.winfo_screenwidth() screenheight = mainGUI.winfo_screenheight() alignstr = '%dx%d+%d+%d' % (width, height, (screenwidth-width)/2, (screenheight-height)/2) mainGUI.geometry(alignstr) mainGUI.title("转码系统") def browseDialog(): root = tk.Tk() root.withdraw() return filedialog.askopenfilename() def browseDialogTo(): path=browseDialog() var.set(path) def browseDialogTo2(): path=browseDialog() var2.set(path) def browseDialogTof2(): path=browseDialog() varf2.set(path) def browseDialogTof3(): path=browseDialog() varf3.set(path) def browseDialogTof4(): path=browseDialog() varf4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3b86226211d5396fe42ac79ac2368c0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/377/">«</a>
	<span class="pagination__item pagination__item--current">378/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/379/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>