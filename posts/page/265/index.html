<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9c0b57cdebe64e7b89cdaec0abc5ac7/" rel="bookmark">
			（尚硅谷）Vue笔记------22
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 路由基本使用 我们先写个大框，样式是用的bootstrap,大家可以用别的或者不写。
main.js:
App.vue:
我们去写两个组件about和home:
既然要用到路由，我们就按照老的套路肯定先要用npm去下载：
然后当然就要在main.js中去引用:
但是这部分引用之前我们要去创建一个路由文件：
这个写完就可以引入到main.js中了：
我们的路由器已经就位了，我们就要想办法去使用我们的路由器：
页面效果：
我们最基本的路由案例就写完了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38b75ed2b429ebb2a62422c7ce1352f8/" rel="bookmark">
			解析C&#43;&#43;中std::ref
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 关于c++中的std::ref，std::ref在c++11引入。本文通过讲解std::ref的常用方式，及剖析下std::ref内部实现，进而再来讲解下std::reference_wrapper，然后我们再进一步分析为什么使用std::ref。
2. std::ref 用法 简单举例来说：
int n1 = 0; auto n2 = std::ref(n1); n2++; n1++; std::cout &lt;&lt; n1 &lt;&lt; std::endl; // 2 std::cout &lt;&lt; n2 &lt;&lt; std::endl; // 2 可以看到 是把n1的引用传递给了n2，分别进行加法，可以看到n2是n1的引用，最终得到的值都是2
那么大家可能会想，我都已经有了’int&amp; a = b’的这种引用赋值的语法了，为什么c++11又出现了一个std::ref，我们继续来看例子：
#include &lt;iostream&gt; #include &lt;thread&gt; void thread_func(int&amp; n2) { // error, &gt;&gt; int n2 n2++; } int main() { int n1 = 0; std::thread t1(thread_func, n1); t1.join(); std::cout &lt;&lt; n1 &lt;&lt; std::endl; } 我们如果写成这样是编译不过的，除非是去掉引用符号，那么我如果非要传引用怎么办呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38b75ed2b429ebb2a62422c7ce1352f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22510bd3afc6bd8162c888f52d70ef29/" rel="bookmark">
			七天玩转Redis | Day6、SpringBoot集成Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、搭建环境2、测试Redis3、StringRedisTemplate3.1、介绍3.2、StringRedisTemplate常用操作3.3、StringRedisTemplate的使用 4、RedisTemplate4.1、介绍4.2、RedisTemplate常用操作4.3、RedisTemplate的使用 Spring Boot Data(数据) Redis 中提供了RedisTemplate和StringRedisTemplate，其中StringRedisTemplate是RedisTemplate的子类，两个方法基本一致，不同之处主要体现在操作的数据类型不同，RedisTemplate中的两个泛型都是Object，意味着存储的key和value都可以是一个对象，而StringRedisTemplate的两个泛型都是String，意味着StringRedisTemplate的key和value都只能是字符串。
注意: 使用RedisTemplate默认是将对象序列化到Redis中,所以放入的对象必须实现对象序列化接口。
1、搭建环境 搭建环境: 采用IDEA+JDK8 + SpringBoot2.3.5集成Redis。
第一步： 使用IDEA构建项目，同时引入对应依赖
依赖选择
引入依赖
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.imooc&lt;/groupId&gt; &lt;artifactId&gt;springboot-redis-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-redis-demo&lt;/name&gt; &lt;description&gt;Demo Redis project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22510bd3afc6bd8162c888f52d70ef29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf72c8b3016064db1400f6886261a91/" rel="bookmark">
			mysql表查询修改删除等操作出现卡死，问题：Waiting for table metadata lock
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		show full processlist; // 列出进程，找出处于Waiting for table metadata lock的process，要杀死这些process
kill ID;　// ID号就是指的列出的第一列“Id”
如果kill后还是出现卡死的问题，建议将数据库相关的process列表都杀死(即db列为自己数据库名称的数据)，我是这样解决这个问题的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5ed4da63b93ea897f007d297baf3718/" rel="bookmark">
			java实现重复的DNA序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 题目描述： 所有 DNA 都由一系列缩写为 'A'，'C'，'G' 和 'T' 的核苷酸组成，例如："ACGAATTCCG"。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。
编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。
leetcode链接：重复的DNA序列
二 算法思路 因为题目的特殊性，我们可以采用空间换时间复杂度的思想，把10个长度单位的字符串存在集合中，如果出现了重复元素，直接放到结果集里即可。
三 算法实现 public List&lt;String&gt; findRepeatedDnaSequences(String s) { List&lt;String&gt; result = new ArrayList&lt;&gt;(); Set&lt;String&gt; existString = new HashSet&lt;&gt;(); if (s.length() &lt;= 10) { return result; } for (int i = 0; i &lt;= s.length() - 10; i++) { String temp = s.substring(i, i + 10); if (existString.contains(temp) &amp;&amp; !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5ed4da63b93ea897f007d297baf3718/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/235d03da97510e2c9e931c4cf8eeeaae/" rel="bookmark">
			Linux入门——环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见Linux发行版本
RHEL （Red Hat Enterprise Linux）
CentOS（社区企业操作系统）
Ubuntu（乌班图）
Debian
vmware 虚拟机 部署系统
1.安装并打开VMWARE
2.在VMware中新建虚拟机
3.典型/自定义，选择自定义安装
4.虚拟机兼容性，默认下一步
5.安装来源，选择稍后安装操作系统
6.操作系统类型，选择linux centos7 64
7.自定义虚拟机名称，文件夹位置。
8.虚拟机CPU,下一步
9.内存选择，1024MB
10.网络连接，选择NAT
11.IO类型，默认下一步
12.虚拟磁盘类型，默认下一步
13.创建新磁盘，默认下一步
14.磁盘大小，默认下一步，20G
15.磁盘文件名，默认下一步
16.完成
17.在新的虚拟机，选择DVD,选择使用ISO镜像，选择CENTOS7 安装镜像
18.开启此虚拟机
可能出现（此主机支持Intel VT-x,但处于禁用状态）
19.install centos 7安装操作系统
（ctr+alt）控制真机
20.中文，简体中文
21.软件选择
{
带GUI的服务器
兼容
开发
}
22.安装位置 分区
{
/boot 1024MB
/
swap 2048MB
}
23.点击开始安装
24.设置root密码
25.同意许可，完成配置
虚拟机安装多了，如何删除
1.打开虚拟机（关机状态） 打开vmx文件
2.右键虚拟机名的标签，选择管理，从磁盘中删除
VMware正版：
FinalShell远程连接管理Centos系统
SSH连接
虚拟机快照
目的：快速还原全新虚拟机
1.选择一台安装完毕的虚拟机
2.选择顶部《虚拟机》菜单
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/235d03da97510e2c9e931c4cf8eeeaae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/681a45da56fdc50da200c91528332a4e/" rel="bookmark">
			【Java-数组】Java数组的创建的3种方法6种写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java数组的创建的3种方法6种写法 一维数组动态创建（4种写法）静态创建（2种写法） 二维数组动态创建（4种写法）静态创建（2种写法） 一维数组 动态创建（4种写法） 第1种：
int a[] = new int[5];//创建长度为5的一维数组等待赋值，初始值为0 第2种：
int[] a1 = new int[5];//创建长度为5的一维数组等待赋值，初始值为0 第3种：
int b[] = new int[] {1,2,3};//声明并创建内存空间且赋值 第4种：
int[] b1 = new int[] {1,2,3};//声明并创建内存空间且赋值 静态创建（2种写法） 第1种：
int c[] = {1,2,3};//声明并创建内存空间，直接赋值 第2种：
int[] c1 = {1,2,3};//声明并创建内存空间，直接赋值 二维数组 动态创建（4种写法） 第1种：
int[][] arr1 = new int[3][3];//声明并创建内存空间，等待赋值，初始值为0 第2种：
int arr2[][] = new int[3][3];//声明并创建内存空间，等待赋值，初始值为0 第3种：
int[][] arr1 = new int[][] {{1,2,3},{4,5,6},{7,8,9}};//声明并创建内存空间且赋值 第4种：
int arr2[][] = new int[][] {{1,2,3},{4,5,6},{7,8,9}};//声明并创建内 静态创建（2种写法） 第1种：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/681a45da56fdc50da200c91528332a4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20d5b4cbe2541457e58a698bedc06776/" rel="bookmark">
			【MyBatis-Bug】Error while downloading ‘http://mybatis.org/dtd/mybatis-3-mapper.dtd‘.sql映射文件mapper报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.错误图示2.解决方案 1.错误图示 2.解决方案 第一步：下载约束文件（http://mybatis.org/dtd/mybatis-3-mapper.dtd）
第二步：在项目路径下创建一个文件夹，把下载好的dtd约束文件放进去
第三步：在Eclipse中点击 Window—&gt;Preferences—&gt;XML—&gt;XML Catalog—&gt;Add
第四步：
第五步：应用并关闭
第六步：关闭sql映射文件再打开，如果发现mapper还是报错则
把
http://mybatis.org/dtd/mybatis-3-mapper.dtd 改成
http://www.mybatis.org/dtd/mybatis-3-mapper.dtd 或者
http://www..mybatis.org/dtd/mybatis-3-mapper.dtd 即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2252ab913ff39c047613992d45d4c03/" rel="bookmark">
			【MyBatis-Bug】mybatis-config.xml中configuration报错解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.解决方案：在第四行URL前加www即可 http://www.mybatis.org/dtd/mybatis-3-config.dtd 2.如果还是报错，可能是Eclipse未引入XML的dtd约束文件。 Eclipse引入XML的dtd约束文件操作如下： 1.Window–&gt;Preferences–&gt;
2.找到XMl操作如下
3.点击add后操作如下
4.点击ok就成功啦！不过要等eclipse反应一会儿错误才会消失
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0ec82c76d9583f5f3bccd6a7150d100/" rel="bookmark">
			【概率论】事件的独立与事件的互斥（或互不相容）、以及它们之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、事件的独立2、事件的互斥（或事件的互不相容）3、独立与互斥（或互不相容之间的关系） 1、事件的独立 通俗的讲，两个事件的独立就是这两个事件发生与否互相不影响，比如：投掷骰子两次，第一次的结果与第二次的结果互不影响，把这两次投骰子看作两次事件，那么也就是说这两次事件独立。
事件 A 与事件 B 独立用概率来定义：P(AB) = P(A) P(B) 。因为事件 A 与事件 B 独立表示两个事件互不影响，所有又有：P(A|B) = P(A),P(B|A) = P(B)。
2、事件的互斥（或事件的互不相容） 事件的互斥（互不相容）是指两个事件不能同时发生，比如：投掷一枚硬币，A事件表示结果为正面，B事件表示结果为反面，这里事件A与事件B是互斥（互不相容）事件，【注意：这里事件A与事件B也可以叫做对立事件，还可以说它们组成完备事件组。】
事件互斥的定义：A∩B = ∅。
3、独立与互斥（或互不相容之间的关系） 一般事件的独立与互斥是没有什么关系的，独立用概率定义，互斥用事件定义。比如：投掷一枚硬币两次，事件A表示第一次为正面，事件B表示第二次为正面，事件C表示第一次为反面；这里事件A与事件B独立，因为P(AB)= P(A)P(B)【P(AB) = 1/4,P(A)P(B)=1/4】【或很明显A事件与B事件互相不影响】，事件A与事件C互斥（互不相容），因为A∩C=∅【或很明显A与C不可能同时发生】。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aa8f5e36d618351492471dc687fe9f3/" rel="bookmark">
			Shell中if判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注： 部分概念介绍来源于网络
Shell 语言中的if条件
一、if的基本语法:
if [ command ];then
符合该条件执行的语句
elif [ command ];then
符合该条件执行的语句
else
符合该条件执行的语句
fi
二、文件/文件夹(目录)判断
[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。
[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。
[ -d DIR ] 如果 FILE 存在且是一个目录则为真。
[ -e FILE ] 如果 FILE 存在则为真。
[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。
[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。
[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。
[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aa8f5e36d618351492471dc687fe9f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86dd31750b3f72e7cf0c8df77849d950/" rel="bookmark">
			ArcGIS实验教程——实验一：ArcGIS软件的认识与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArcGIS实验视频教程合集：《ArcGIS实验教程从入门到精通》（附配套实验数据）
实验目录
第一节 Esri简介
1.1 ESRI简介
1.2 Esri产品发展历程
第二节 ArcGIS简介
2.1 ArcGIS简介
2.2 ArcGIS产品体系
第三节 Desktop简介
3.1 Desktop简介
3.2 Desktop产品等级分类
3.3 Desktop产品组成
3.4 Desktop产品功能
第四节 ArcMap快速入门
4.1 ArcMap基础
4.2 ArcCatalog基础
4.3 ArcToolBox基础
4.4 ArcScene与ArcGlobe概述
第一节 Esri简介 1.1 ESRI简介 美国环境系统研究所公司（Environmental Systems Research Institute, Inc. 简称ESRI公司）成立于1969年，总部设在美国加利福利亚州雷德兰兹市，是世界最大的地理信息系统技术提供商。
在全美各地都设有办事处，世界各主要国家均设有分公司或者代理，全球员工总数超过4000名。其商业合作伙伴计划，在全球有超过2000个领域开发商、咨询服务商、增值代理以及数据提供商，与分布在80个国家的国际代理一起，构成了ESRI公司强大的技术支持与服务网络。
1.2 Esri产品发展历程 1982年，Esri开发出了Arc/info V1.0，是世界上第一个现代意义上的GIS商品化软件；1986年，Esri专门为基于PC的GIS工作站设计了PC Arc/info，它标志着ESRI成功向GIS软件开发公司转型；1992年，Esri发布了ArcView，提供了简易的制图功能；1999年，Esri发布了ArcInfo8，这也是中国早期用户最先接触的ArcGIS软件，常见版本有ArcGIS8.1,8.3；2004年，Esri推出了ArcGIS9系列产品，为构建完善的GIS系统，提供了一套完整的软件产品，经历了9.0、9.1、9.2、9.3、9.3.1五个版本；2010年，Esri推出了ArcGIS10版本，是一个具有里程碑意义的版本。经历的版本有10.0、10.1、10.2、10.3、10.3.1、10.4、10.5、10.6、10.7、10.8、Pro。 第二节 ArcGIS简介 2.1 ArcGIS简介 ArcGIS是Esri公司集40余年地理信息系统（GIS）咨询和研发经验，奉献给用户的一套完整的GIS平台产品，具有强大的地图制作、空间数据管理、空间分析、空间信息整合、发布与共享的能力。
ArcGIS整合了数据库、软件工程、人工智能、网络技术、移动技术、云计算等主流的IT技术，旨在为用户提供一套完整的、开放的企业级GIS解决方案。
2.2 ArcGIS产品体系 ArcGIS10作为一个可伸缩的GIS平台，它的产品家族涉及桌面、服务器、移动和web应用等多个方面，具体的产品构成体系如下图所示：
第三节 Desktop简介 3.1 Desktop简介 ArcGIS for Desktop是GIS专业人士进行地理信息编辑、使用和管理的主要产品，主要包括ArcMap、ArcCatalog、ArcScene和ArcGlobe四大组件。
3.2 Desktop产品等级分类 3.3 Desktop产品组成 主要包括ArcMap、ArcCatalog、ArcScene和ArcGlobe四大组件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86dd31750b3f72e7cf0c8df77849d950/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5913e3e022f1c89b1f434fa8621306c5/" rel="bookmark">
			mysql-修改表名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ALTER TABLE stockPankou RENAME stockPankou1009 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af16edca10f629c27a7bf49b2bf3c2e6/" rel="bookmark">
			.NET实用框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐一些.Net C#较为实用的框架： Json.NET
http://json.codeplex.com/
Json.Net 是一个读写Json效率比较高的.Net框架.Json.Net 使得在.Net环境下使用Json更加简单。通过Linq To JSON可以快速的读写Json，通过JsonSerializer可以序列化你的.Net对象。让你轻松实现.Net中所有类型(对象,基本数据类型 等)和Json的转换。
Math.NET
http://www.mathdotnet.com/
Math.NET的目标是为提供一款自身包含清晰框架的符号运算和数学运算/科学运算，它是C#开发的开源类库。Math.NET含了一个支持线性代数的解析器，分析复杂微分，解方程等等功能。
Faker.Net
https://github.com/jonwingfield/Faker.Net
开发的时候是不是为测试数据烦恼？Faker.Net可以非常方便帮你生成大批量测试数据。例如人员表里面的姓名、性别什么的。
Html Agility Pack
http://htmlagilitypack.codeplex.com/
Html Agility Pack 是CodePlex 上的一个开源项目。它提供了标准的DOM API 和XPath 导航–即使 HTML 不是适当的格式！HTML Agility Pack 搭配 ScrapySharp，彻底解除Html解析的痛苦。
NCrawler
http://ncrawler.codeplex.com/
NCrawler是一款国外的开源网络爬虫软件,遵循LGPL许可协议。其HTML处理使用的是htmlagilitypack开源库,采用xpath的方式处理定位网页元素,十分方便。
SuperWebSocket
http://superwebsocket.codeplex.com/
SuperWebSocket是基于.NET开源Socket框架SuperSocket开发的, SuperSocket所支持的大部分功能在SuperWebSocket中得到了继承。用户可通过SuperWebSocket来快速的构建可靠的，高性能的websocket服务器端应用程序。
SuperSocket
http://supersocket.codeplex.com/
SuperSocket 是 一个轻量级的可扩展的 Socket 开发框架，可用来构建一个服务器端 Socket 程序，而无需了解如何使用 Socket，如何维护Socket连接，Socket是如何工作的。该项目使用纯 C# 开发，易于扩展和集成到已有的项目。只要你的已有系统是使用.NET开发的，你都能够使用 SuperSocket来轻易的开发出你需要的Socket应用程序来集成到你的现有系统之中。
Quartz.NET
http://www.quartz-scheduler.net/
Quartz.NET 是一个开源的作业调度框架，是 OpenSymphony 的 Quartz API的.NET移植，它用C#写成，可用于winform和asp.net应用中。它提供了巨大的灵活性而不牺牲简单性。你能够用它来为执行一个作业而 创建简单的或复杂的调度。它有很多特征，如：数据库支持，集群，插件，支持cron-like表达式等等。
Lucene.Net
http://lucenenet.apache.org/
Lucene.net是Lucene的.net移植版本，是一个开源的全文检索引擎开发包，即它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎。开发人员可以基于Lucene.net实现全文检索的功能。
HttpLib
http://httplib.codeplex.com/
一个基于C#语言的http协议的类库，Httplib让异步交互处理数据更容易了。类库的方法包括：上传文件到服务器，获取页面数据等等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af16edca10f629c27a7bf49b2bf3c2e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9abd6dcff8b719d31a314f6c58d5d7ff/" rel="bookmark">
			vscode快捷键-选中括号匹配内容-支持所有括号(必备效率快捷键)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		啥效果 怎么弄 给这个命令配置一个快捷键就好了,或者找找他的快捷键是啥
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4223eb6d4d659f9d0621c1bd76f2064/" rel="bookmark">
			python的matplotlibbin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在python的matplotlib画图函数中，饼状图的函数为pie pie函数参数解读 plt.pie(x, explode=None, labels=None, colors=None, autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=None, radius=None, counterclock=True, wedgeprops=None, textprops=None, center=(0, 0), frame=False)
x：指定绘图的数据；explode：指定饼图某些部分的突出显示，即呈现爆炸式；labels：为饼图添加标签说明，类似于图例说明；colors：指定饼图的填充色；autopct：自动添加百分比显示，可以采用格式化的方法显示； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a10b4dc04ff4abdde52f9cdbd8952be/" rel="bookmark">
			基于vue-element-admin &#43; django 快速搭建web平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前端：在vue-admind-template的基础上写我们的前端代码，对于想要实现的简单的前端组件（表格，弹框，表单等等）先去element组件库里copy，对于想要实现的复杂的前端组件（图表，编辑器）就去vue-element-admin这个项目中copy
2. 后端：使用django来搭建我们的后端，配合django-rest-framework来写接口，5行代码就能完成了一张数据库表格的增删改查。
3. 部署上线：使用django的官方镜像把服务部署到docker上，连配置环境的时间都节省了。
Element
Element - The world's most popular Vue UI framework
Vue-Admin-Template
源代码：https://github.com/PanJiaChen/vue-admin-template
体验地址：Vue Admin Template
Vue-Element-Admin
源代码：https://github.com/PanJiaChen/vue-element-admin
体验地址：Vue Element Admin
文档地址：介绍 | vue-element-admin
Django:
官网：The web framework for perfectionists with deadlines | Django
英文教程：https://docs.djangoproject.com/en/
中文教程：Django 简介 - Django 教程 - 自强学堂
docker镜像：Docker Hub
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bc69eb25f122a79d2d6547794f81ab1/" rel="bookmark">
			14、openFeign整合sentinel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：创建项目 从 2、Spring Cloud Alibaba快速整合OpenFeign复制order-openfeign，修改为order-openfeign-sentinel order-openfeign-sentinel模块 第一步：修改application.yml server: port: 8086 #应用名称（nacos会将该名称当做服务名称） spring: application: name: order-service cloud: nacos: server-addr: 127.0.0.1:8848 discovery: username: nacos password: nacos namespace: public 第二步：添加依赖 &lt;!--sentinel依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;/dependency&gt; 第三步：创建StockFeignServiceFallback package com.example.order.feign; import org.springframework.stereotype.Component; @Component public class StockFeignServiceFallback implements StockFeignService { public String reduck2() { return "降级啦！！！"; } } 第四步：修改application.yml server: port: 8089 #应用名称（nacos会将该名称当做服务名称） spring: application: name: order-service cloud: nacos: server-addr: 127.0.0.1:8848 discovery: username: nacos password: nacos namespace: public feign: sentinel: # openFeign整合sentinel enabled: true 第五步：修改StockFeignService package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bc69eb25f122a79d2d6547794f81ab1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af13762d2f333547cb87d9e37a2354ea/" rel="bookmark">
			HashMap底层源码与数据结构分析(JDK1.8)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介
JDK1.8中HashMap采用的是数组+链表结构+红黑树保存所有数据
HashMap主要用于存放键值对，它基于哈希表的Map接口实现，是常用的 Java 集合之一，是非线程安全的。
HashMap可以存储null的key和value，但是null作为键只能有一个，null作为值可以有很多个。
JDK1.8之前HashMap由数组 + 链表构成，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（"拉链法"解决冲突）。JDK1.8以后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表转换为红黑树前会判断，如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。
HashMap默认的初始化大小为16，之后每次扩充，容量变为原来的2倍。并且，HashMap总是使用2的幂作为哈希表的大小。
二、底层数据结构分析
JDK1.8之后
相比于之前的版本，JDK1.8 以后在解决哈希冲突时有了较大的变化。
当链表长度大于阈值（默认为 8）时，会首先调用 treeifyBin()方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 resize() 方法对数组扩容。相关源码这里就不贴了，重点关注 treeifyBin()方法即可！
类的属性：
/** * 默认初始化容量为16 */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 ​ /** * 默认最大的容量, 2^30 */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; ​ /** * 负载因子，默认为0.75 */ static final float DEFAULT_LOAD_FACTOR = 0.75f; ​ /** * 当桶(bucket)上的结点数大于这个值时会转成红黑树 */ static final int TREEIFY_THRESHOLD = 8; ​ /** * 当桶(bucket)上的结点数小于这个值时树转链表 */ static final int UNTREEIFY_THRESHOLD = 6; ​ /** * 桶中结构转化为红黑树对应的table的最小大小 */ static final int MIN_TREEIFY_CAPACITY = 64; /** * 存储元素的数组，总是2的幂次倍 */ transient java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af13762d2f333547cb87d9e37a2354ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df1345c7de91001510acf8c91bb1ebb9/" rel="bookmark">
			Jetson Nano 入坑之路 ---- （10）C/C&#43;&#43;语言读写UART或USB串口数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇“Jetson Nano 入坑之路 ”系列博客中笔者讲到笔者封装的一个串口函数，本篇博客，笔者会简单易懂的讲解C语言读写串口的方法。
优化：其他博主的博客在这个串口部分大部分都有个问题，就是十六进制读取的时候，会发现，0x7F以上后，第八位被吃了。你发0xFF，但是程序始终读出来的是0x7F。因为最高位“被吃”了。本博客的程序是博主亲测实用程序。
环境准备 Jetson自带了ch34x的驱动，所以可以直接使用CH34x系列的USB-TTL作为USB串口与Jetson进行交互。在SYN6288语言播报模块笔者也用USB-TTL尝试过。
为了测试，可以安装个mincom，然后把TX和RX短接一下。
代码实现 就不吊胃口了，直接上正菜。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;errno.h&gt; #include &lt;unistd.h&gt; #include &lt;termios.h&gt; #include &lt;fcntl.h&gt; #include &lt;iconv.h&gt; #include &lt;string&gt; #include &lt;iostream&gt; // 函数声明部分 int open_port(int com_port); int set_uart_config(int fd, int baud_rate, int data_bits, char parity, int stop_bits); // 使用实例 int main() { // begin::第一步，串口初始化 int UART_fd = open_port(0); if (set_uart_config(UART_fd, 115200, 8, 'N', 1) &lt; 0) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df1345c7de91001510acf8c91bb1ebb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1d15f7d32e3c67d483096e6301d3cd1/" rel="bookmark">
			MOV格式视频转MP4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题，MOV格式视频转MP4格式。
代码貌似是从哪里copy来的，如果侵权请联系删除。
需要在路径下建一个train文件夹保存转完格式的视频。
import os # 获取目录下的所有文件列表 import fnmatch # 文件格式筛选模块，筛选指定格式文件 # 遍历 def dirlist(path, allfile): filelist = os.listdir(path) for filename in filelist: filepath = os.path.join(path, filename) if os.path.isdir(filepath): dirlist(filepath, allfile) elif fnmatch.fnmatch(filepath, '*.mov'): # 判断文件格式 allfile.append(filepath) return allfile # 格式转换 def RunScript(fileList): count = 0 code = "ffmpeg -i " for filename in fileList: input = filename output = "D:/L1/train/" + str(count) + ".mp4" count += 1 finishcode = code + input + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1d15f7d32e3c67d483096e6301d3cd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45b1f79c9db15e7bd3b2e4a54b5dcd39/" rel="bookmark">
			【java高性能编程基础】- 实现原子操作的多种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述1、加锁1.1、Lock接口1.2、synchronized关键字 2、CAS机制3、原子类（Atomic） 概述 所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。
下面就以i++自增操作为例来实现i++的原子性。
i++并不是一步完成的，它包含了三个步骤：
加载i;计算i+1;给i赋值。 例如，
public class IaddTest { public int i = 0; public void add(){ i++; } public static void main(String[] args) throws Exception { IaddTest iaddTest = new IaddTest(); for(int i=0;i&lt;2;i++){ //创建两个线程 new Thread(new Runnable() { @Override public void run() { for(int i=0;i&lt;10000;i++){ iaddTest.add(); } } }).start(); } Thread.sleep(2000L);//sleep两秒，等待两个线程任务全部执行完成 System.out.println(iaddTest.i); } } 这段代码中，创建了两个线程分别调用10000次add方法（即两万次i++），理论上最后的输出结果应该为20000，但是实际的运行结果却达不到20000，如下：
这是由于两个线程是并发执行的，当线程1读取i值时，线程2还没有将i+1的值赋给i（例如当i = 1时，线程1读取i=1，同时线程2也读取i=1，然后执行+1操作，结果两个线程都将i赋值为2）。
为了避免这种线程不安全情况的发生，保证程序的正确性，我们就需要将i++进行原子操作。
下面，就通过几种不同的方式来实现原子操作。
1、加锁 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45b1f79c9db15e7bd3b2e4a54b5dcd39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ea02187ba257dc88a39bae21f65af1a/" rel="bookmark">
			shell同时把标准错误重定向到标准输出和文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 命令或者脚本 2&gt; &gt;(tee ./error.txt) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6582781899cac60630a2ac961a56694e/" rel="bookmark">
			在image2lcd图片取模软件使用中遇到的小问题，和解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		image2lcd可以把用户导入的图片编辑后转换为C语言数组、二进制文件或BMP等图片格式，编辑中可以修改图片的像素长宽大小，色彩位数等，在学习单片机过程中，需要在TFT彩屏或OLED彩屏中显示图片，那就需要二进制格式的图片数据。这时有image2lcd就会很方便。
但是在我第一次用这个软件在导入图片进去时，会提示无效的输入图片，无论你用什么格式JPG、BMP都不行，解决办法就是先把该图片导图到图画、或者ps等作图软件，再导出，软件就能识别了。
由于该软件发布时间早，而且使用的人比较少，我搜了很久都没有找到解决办法，所以只能摸索，在尝试过程中我想可能是我的电脑有问题，就下载了个云电脑，在免费体验的十分钟内找到了原因，我从网上直接找图片就能导入，但是我用微信截取的图片却用不了无论怎么转换格式都不行，于是我就把图片放到windows电脑自带的图画里，再导出就能使用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/790f9b0327ef2945e9a6e2f4f14539d8/" rel="bookmark">
			K8s&#43;ingress-tcp(mysql)解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一部分ingress设置的部分
部署ingress-controller 部署ingress-controller pod及相关资源
先给要部署nginx-ingress的node打上特定标签
[root@k8s-master ]# kubectl label nodes k8s-node1 custom/ingress-controller-ready=true [root@k8s-master ]# kubectl label nodes k8s-node1 custom/ingress-controller-ready=true 官方文档中，部署只要简单的执行一个yaml
[root@k8s-master ingress-nginx]# wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.17.0/deploy/mandatory.yaml 修改后的文件如下
#TCP的部分加上mysql的3306的端口，NS是default，mysql的Service是dz-mysql data: 3306: "default/dz-mysql:3306" [root@k8s-master ingress-nginx]# cat mandatory.yaml --- apiVersion: v1 kind: Namespace metadata: name: ingress-nginx --- apiVersion: extensions/v1beta1 kind: DaemonSet metadata: name: nginx-ingress-controller namespace: ingress-nginx labels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx spec: # 删除Replicas # replicas: 1 selector: matchLabels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx template: metadata: labels: app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/790f9b0327ef2945e9a6e2f4f14539d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/206664c2bed35c214acec92216a8d39a/" rel="bookmark">
			数组扁平化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、使用堆栈的方式二、使用递归的方式三、使用生成器函数generator的方式1.生成器函数generator 四、考虑数组空位1.将[,1,2,[3,,4,[5,,6,7,,8]]]格式化成[1,2,3,4,5,6,7,8]2.将[,1,2,[3,,4,[5,,6,7,,8]]]格式化成[,1,2,3, ,4,5, ,6,7, ,8] 五、使用reduce来实现数组扁平 参考原文:
1.数组concat_面试官连环追问
2.MDN Array.prototype.flat()
一、使用堆栈的方式 代码如下（示例）：
let arr = [[1,2,3],[3,4,5,5],[6,7,8,9,[11,12,[12,13,[14]]]],10] function cusFlat(array) { const stack = [...array] //将原数组先用扩展运算符解构到新的数组中 const res = []	while (stack.length) { //使用while循环,当栈(stack数组)中还有值接着循环 const pop = stack.pop() //每次从栈中吐出一个值,这样数组(栈)的长度就会改变 if (Array.isArray(pop)) { //如果吐出的是数组,则将该数组解构,堆到这个栈的末尾 stack.push(...pop) }else { //如果吐出的不是数组,则push到一个新的数组中 res.push(pop) } } return res.reverse() //由于push是放到末尾,所以数组顺序需要翻转一下 } console.log('cusFlat',cusFlat(arr)); //[1,2,3,3,4,5,5,6,7,8,9,11,12,12,13,14,10] 二、使用递归的方式 在使用递归的时候只要记住两点:
1.递归函数第一层或者说最初的目的是要去干什么;
2.递归函数一定要有出口,避免死递归.
代码如下（示例）：
function cusFlat(array) { const res = [] function flatCus(params) { params.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/206664c2bed35c214acec92216a8d39a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e055f35b1d0e4098dcbe0673cae872b4/" rel="bookmark">
			nacos 服务注册 管理列表中没有注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在参考官方文档 进行各项配置后发现, 注册没生效
原因:
由于使用的idea 没有开启 maven的自动导入
所以依赖的添加没有自动导入
在刷新项目后, 就正常了
这一点容易被忽略
========================================================
项目启动后, 如果服务注册成功, 控制台输出
c.a.c.n.registry.NacosServiceRegistry : nacos registry, DEFAULT_GROUP 项目名 本机ip地址:8080 register finished
另外如果特意配错nacos的ip, 本地项目是无法启动的, 会出现如
Caused by: com.alibaba.nacos.api.exception.NacosException: failed to req API:/nacos/v1/ns/instance after all servers([localhost:8848]) tried: java.net.ConnectException: Connection refused: connect
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48a988187cfd49d80649c9ead67f6a7f/" rel="bookmark">
			变分自编码器（VAE）（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
说来惭愧，VAE接触很久了，一直想把VAE好好的总结一下，一直拖到现在。
闲话少说，关于VAE的文章网上也有不少，解释的最好最清楚的还是苏剑林老师的这篇文章文章链接，还有B站白板推导系列中关于变分推断跟变分自编码器链接。大家可以多看看这两个资料，或者直接看我这次的总结肯定也不错的。
一、理解VAE前需要了解的知识点
1.极大似然估计 关于极大似然估计可以看我这篇文章，理解极大似然估计的原理，因为VAE中也用到了极大似然估计的原理。https://blog.csdn.net/zeronose/article/details/122437636?spm=1001.2014.3001.5501https://blog.csdn.net/zeronose/article/details/122437636?spm=1001.2014.3001.5501
2.高斯混合模型（GMM） 理解高斯混合模型主要是想让GMM跟VAE进行对比，更容易理解，因为GMM和VAE都属于是隐变量模型，其中都有隐变量这个概念。
这篇之前的文章是介绍EM算法的，里面的例子就是用EM算法去解决高斯混合模型的参数估计问题。可以通过这篇文章来理解高斯混合模型。https://blog.csdn.net/zeronose/article/details/122465732?spm=1001.2014.3001.5501https://blog.csdn.net/zeronose/article/details/122465732?spm=1001.2014.3001.5501
3.变分推断 变分推断是想办法找到一个分布去逼近无法计算得出解析解的后验分布。这也是VAE中用来求解后验分布的方法。可以看B站白板推导关于变分推断部分https://www.bilibili.com/video/BV1aE411o7qd?spm_id_from=333.999.0.0https://www.bilibili.com/video/BV1aE411o7qd?spm_id_from=333.999.0.0
二、AE的基本认识 这里的图全部来源于网络，侵权必删，其中下面关于月亮的一部分，来源于这篇文章，侵权必删。
这篇文章也非常的不错http://www.gwylab.com/note-vae.htmlhttp://www.gwylab.com/note-vae.html
AE就是自动编码器，VAE是在AE的基础上来的，所以这里先介绍一下AE。 先看一下下面两个图：
如上面两个图所示，AE主要有encoder和decoder两个部分组成，其中encoder和decoder都是神经网络。其中encoder负责将高维输入转换为低维的code，decoder负责将低维的code转换为高维的输入，其中输出要跟输入尽可能的相似，最好是能完全一样。
看第二个图的中间部分，就代表了code，我们经过训练，最终得到了一个6维的code，且每个维度有一个具体的值代表。因为AE就是想生成跟输入相同的图像，所以AE是不会产生新的图像的，就像上面第二个图，最后生成的这个大叔，不会是一个闭嘴不笑，红头发的大叔。
再举一个例子，如下图：
如上图，经过训练我们的AE已经能还原这两张图片。接下来，我们在code空间上，两张图片的编码点中间处取一点，然后将这一点交给解码器，我们希望新的生成图片是一张清晰的图片（类似3/4全月的样子）。但是，实际的结果是，生成图片是模糊且无法辨认的乱码图。
为什么我们在code的中间取一点，无法生成3/4月亮的图呢？？？？
还是因为，AE就是要生成跟输入尽可能相同的图，类似与压缩与解压缩的过程，你想让AE生成一个相似但全新的图，它是做不到的。
那如果我就是想生成3/4月亮的图怎么办？有一种方法，我们可以引入噪声，使得图片的编码区域得到扩大，从而掩盖掉失真的空白编码点。如下图所示：
如上图所示，现在在给两张图片编码的时候加上一点噪音，使得每张图片的编码点出现在绿色箭头所示范围内，于是在训练模型的时候，绿色箭头范围内的点都有可能被采样到，这样解码器在训练时会把绿色范围内的点都尽可能还原成和原图相似的图片。然后我们可以关注之前那个失真点，现在它处于全月图和半月图编码的交界上，于是解码器希望它既要尽量相似于全月图，又要尽量相似于半月图，于是它的还原结果就是两种图的折中（3/4全月图）。
由此我们发现，给编码器增添一些噪音，可以有效覆盖失真区域。不过这还并不充分，因为在上图的距离训练区域很远的黄色点处，它依然不会被覆盖到，仍是个失真点。为了解决这个问题，我们可以试图把噪音无限拉长，使得对于每一个样本，它的编码会覆盖整个编码空间，不过我们得保证，在原编码附近编码的概率最高，离原编码点越远，编码概率越低。在这种情况下，图像的编码就由原先离散的编码点变成了一条连续的编码分布曲线，如下图所示。
那么上述的这种将图像编码由离散变为连续的方法，就是变分自编码的核心思想。VAE中间的code不是具体的值，而是一种分布。如下图所示：
三、VAE的基本认识 上面介绍完了AE，接着就来介绍一下VAE。VAE是从AE的基础上来的，其中我们知道，AE类似于一种压缩解压缩的过程，只能生成与输入图像尽可能一样的图像，而不会生成与输入图像相似但不同的图像，这是AE本身所限制的。在这个基础上，VAE中间的code是一个分布，从分布中采样然后输入到decoder中，VAE可以生成与输入图像相似但不同的图像。
如下图所示，为VAE的基本结构图：
如下图所示，为VAE原文中给出的VAE的图模型，从VAE的图模型我们可以看到，z是服从标准正太分布的。
如下图所示，为VAE原文中给出的VAE的结构图。其中分为左右两个部分，右边才是最终的VAE结构。右边比左边就多了一个从标准正太分布中采样的过程，称为重参数化技巧，后面会说到为什么要有这个重参数化技巧。
感觉东西有点多，一篇文章写下来比较臃肿，大家看到后面会没有兴趣，所以将VAE分为（一）、（二）两个部分去介绍，（二）会介绍如下内容：
三、VAE公式推导 四、补充说明 （二）部分是重中之重，理解了公式的推导，基本上就算彻底理解了VAE。https://blog.csdn.net/zeronose/article/details/122660359
​​​​​​​
​​​​​​​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7116226f9b6daa1cf7f71010dafb690/" rel="bookmark">
			5个 VueUse 库函数，让你工作效率翻倍(收藏！)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大厂技术 高级前端 Node进阶
点击上方 程序员成长指北，关注公众号
回复1，加入高级Node交流群
英文 | https://learnvue.co/2021/07/5-vueuse-library-functions-that-can-speed-up-development/
翻译 | 小爱
VueUse 是 Anthony Fu 的一个开源项目，它为 Vue 开发人员提供了大量适用于 Vue 2 和 Vue 3 的基本 Composition API 实用程序函数。 它为常见的开发人员用例提供了数十种解决方案，例如，跟踪引用更改、检测元素可见性、简化常见的 Vue 模式、键盘/鼠标输入等。这是真正节省开发时间的好方法，因为你不必自己添加所有这些标准功能。 我喜欢 VueUse 库，因为在决定提供哪些实用程序时，它确实将开发人员放在首位，而且它是一个维护良好的库，因为它与当前版本的 Vue 保持同步。 VueUse 有哪些实用程序？ 如果你想查看每个实用程序的完整列表，我绝对建议你查看官方文档。但总结一下，VueUse 中有 9 种函数。 动画（Animation）—包含易于使用的过渡、超时和计时函数
浏览器（Browser）—可用于不同的屏幕控制、剪贴板、首选项等
组件（Component）— 为不同的组件方法提供简写
Formatters – 提供反应时间格式化功能
传感器（Sensors ）—用于监听不同的 DOM 事件、输入事件和网络事件
状态（State ）—管理用户状态（全局、本地存储、会话存储）
实用程序（Utility）—不同的实用程序函数，如 getter、条件、引用同步等
Watch —更高级的观察者类型，如可暂停观察者、去抖动观察者和条件观察者
杂项（Misc）— 事件、WebSockets 和 Web Worker 的不同类型的功能 这些类别中的大多数都包含几个不同的功能，因此 VueUse 可以灵活地用于你的用例，并且可以作为快速开始构建 Vue 应用程序的绝佳场所。 在本文中，我们将研究 5 个不同的 VueUse 函数，以便你了解在这个库中工作是多么容易。 但首先，让我们将它添加到我们的 Vue 项目中！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7116226f9b6daa1cf7f71010dafb690/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/250797f6b323553595a2013350c164a3/" rel="bookmark">
			RS485/RS232串口通信实现源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前贴出了代码，但是本地源码已经找不到了；本篇补充了一些使用说明 一、参考代码 1.不方便下载的同学可以参考贴出来的源代码链接：RS485
2.工程链接：RS485
二、基本知识 1.RS485通信讲解：
RS485数据基本格式如下，开发代码时，根据不同厂家产品说明发送指令，并解析返回数据就可以得到对应含义的值
1.1：读50001、50002两个寄存器，假设从机地址为1
上位机（主机）发送下行报文：01 03 00 05 00 02 D4 0A
从机地址功能码寄存器起始地址读取寄存器个数CRC校验010300 0500 02D4 0A 下位机（从机）返回上行报文：01 03 04 00 00 00 00 FA 33
从机地址功能码返回字节个数寄存器30001数据寄存器30002数据CRC校验010300 0400 0000 00FA 33 1.2：向50001寄存器中写入0x36，0x24，假设从机地址为1
上位机（主机）发送下行报文：01 06 00 05 00 01 36 24 6D BC
从机地址功能码寄存器起始地址读取寄存器个数要写入的数据CRC校验010600 0500 0136 246D BC 下位机（从机）上行报文：01 06 00 04 00 01 12 34 4a b0
从机地址功能码寄存器起始地址读取寄存器个数要写入的数据CRC校验010600 0500 0136 246D BC 三、使用 1.RS232：与野火的串口调试工具测试普通串口通信
2.代码只实现了字符串作为发送数据的格式（如果需要支持十六进制格式请自行调整）；这里仅用代码调试，接收区展示了接受到的十六进制字符串格式数据
检验方法采用CRC-16/MODBUS方式，这里提供一个在线校验工具地址：CRC校验
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/250797f6b323553595a2013350c164a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61e777e418cde278768ef4c50175ee52/" rel="bookmark">
			win10系统由传统启动模式（Legacy mbr）转为 UEFI GPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先查看我们系统现有引导项是什么模式：
按Win+R组合键，输入：msinfo32 并回车
结果如下（传统模式显示为传统）：
转换前一定要确认，自己的主板支持UEFI方式，否则转换完无法开机！！！
转换前一定要确认，自己的主板支持UEFI方式，否则转换完无法开机！！！
转换前一定要确认，自己的主板支持UEFI方式，否则转换完无法开机！！！
可以直接下载傲梅分区助手，也可以用老毛桃PE系统带的；教程中用的是老毛桃PE系统：
启动傲梅分区助手，找到要进行转换的磁盘，根据具体提示，右键（注意右键磁盘不是分区），选择转换为GPT格式：
提交之后等待完成，系统盘就变成UEFI格式的启动盘了，这时候如果系统引导项不是UEFI的，还需生成UEFI格式的引导项
在PE系统中，如果存在
注意：UEFI盘符需在之前转换完的GPT上，至此系统启动方式就由传统方式转换为UEFI了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cc52d4da9be7eb28947bacbd8a4eced/" rel="bookmark">
			spring aop pointcut 如何添加多个execution
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 spring aop添加多个包，用||或者or隔开 &lt;!-- 只对业务逻辑层实施事务 --&gt; &lt;aop:config expose-proxy="true"&gt; &lt;aop:pointcut expression="execution(* demo.ssh.daoImpl.*.*(..)) || execution(* demo.mes.daoImpl.*.*(..))" id="txPointcut" /&gt; &lt;!-- Advisor定义，切入点和通知分别为txPointcut、txAdvice --&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPointcut" /&gt; &lt;/aop:config&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ed81e10cacad682c1fb5a9af19f758b/" rel="bookmark">
			SQL Server 2008 R2安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.双击启动安装
2.安装，全新安装
3.输入产品密钥，下一步
4.接受，下一步
5.安装
6.一直下一步，如图操作：
7.对所有用户使用相同账户，下一步
8.混合验证模式，设置密码，添加当前用户
9.再次添加当前用户，下一步
10.下一步。。。。。an’za’hun’g
11.安装完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f44ccf7d114328bac1d656f7ee13e4e8/" rel="bookmark">
			GBase8s 索引入门之原理分析（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GBase8s 索引入门之原理分析（一） 1.数据页的存储结构2.页分裂3.主键索引4.B+ 树实现索引的页存储物理结构5.聚簇索引 1.数据页的存储结构 一般在研究索引之前，需要先知道数据在磁盘上的存储结构，存储方式简单的总结为：
在磁盘文件中，数据页（存储数据的数据结构）之间是组成双向链表的，数据页内部的数据行（每一行数据）是组成单向链表的，而且数据行是根据主键从大到小排序的。如下图：
在引出索引之前，如果表中没有创建索引，是如何根据SQL查询语句查出数据的？
查询方式有两种：根据主键字段查询和根据非主键字段查询。
先看第一种根据主键字段查询，这种查询方式比较简单，直接到数据页的页目录中根据主键进行二分法（ps：比较基础的算法）查找。快速找到主键对应的数据在哪个数据页中，然后到对应的数据页中，遍历数据页中的每一行数据，找到主键对应的数据，然后读取数据行。
第二种根据非主键字段查询，这种方式就不能根据主键的页目录进行二分查找了，只能进入每一个数据页中，一行一行的对比，依次遍历查找，也就是全表扫描。（这种方式在遍历所有的数据页时还需要把数据页加载到内存中，再依次对比查找）
众所周知，全表扫描在数据较多的情况下，效率极低，所以就需要通过创建索引来查询。
2.页分裂 在引入索引概念之前，还需要知道一个前提知识，页分裂。
一个数据页写满了，就要换下一页去写，下一个数据页要求主键值是比上一页大的。
主键值是自增id是很容易做到这一点的。但是有些情况下，主键值不是自增id，比如uuid，那么在往下一个数据页写数据的时候，就很可能产生页分裂，把值小的数据行移动到前面的页去，把前面页较大的数据行，移动到后面页去。这就是页分裂的现象。
页分裂核心是要保证下一页的数据主键值要比上一页的要大。
3.主键索引 针对主键的索引实际上就是主键目录。主键目录就是把每个数据页的页号，还有数据页中最小的主键值放在一起，组成一个索引目录。如下图：
如果要查询id = 3 的数据，就会跟每个数据页的最小主键比较，首先id=3大于数据页1的最小主键值1，小于数据页2的最小主键值4，这样可以定位到id=3的数据一定在数据页1中，然后根据页号找到数据页。当数据页很多时，是通过二分法查找的方式来查找主键所在的数据页的。然后在数据页中二分查找定位数据，进行读取。
这样的效率是非常高的，主键目录就可以认为是主键索引。
4.B+ 树实现索引的页存储物理结构 如果表中的数据过多，就会有大量的数据页存在，对应主键目录中就要存储大量的数据页的页号和最小主键值，这种方式自然不行。
所以采用一种把索引数据存储在数据页中的方法来实现。
即表的数据存放在数据页中，表的索引也存放在页中，这个时候叫索引页。如下图：
现在有很多索引页，但是需要知道应该往哪一个索引页中去找主键数据，是索引页1还是索引页10。于是又把索引页加一个层级出来，在更高的索引层级中，保存了每个索引页和索引页中的最小主键值。如下图：
现在假设要查询id=9的数据，步骤如下：
1.会先从最顶层的索引页20开始查询，通过二分法定位到下一步应该到索引页1中去查询；
2.然后进入索引页1，通过二分法查找定位到数据应该在数据页3中；
3.进入数据页3中，就可以二分法查到id=9的数据了。
如果最顶层的索引页里存放的下层索引页的页号过多，会再一次分裂，增加高一层的索引页。如下图：
上图中多层级的索引页就是一颗B+树，属于一种树形数据结构。这就是常说的MySQL的索引是B+树组成的。
这就是索引的物理存储结构，采用跟数据页一样的页结构来存储，一个索引就是很多页组成的一个B+树。
5.聚簇索引 索引页与数据页之间是有指针连接的。索引页内部，对于同一层级内的索引页，互相之间都是基于指针组成双向链表的，如下图：
在这颗B+树中，最底层的一层就是数据页，数据页就是B+树里的叶子节点。
如果一颗B+树索引数据结构中，叶子节点就是数据页自己本身，就可以称这个B+树索引为聚簇索引。
即上图中的所有索引页+数据页组成的B+树就是聚簇索引。
聚簇索引默认是按照主键组成的，在增删改数据的时候，一方面会更新数据页，一方面会自动维护B+ 树结构的聚簇索引，更新或新增索引页。聚簇索引是默认就建立的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b18f96db258689b5fc9ce09ae18b972/" rel="bookmark">
			数据挖掘案例（1）：泰坦尼克号-数据挖掘流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据挖掘案例（1）：泰坦尼克号-数据挖掘流程_ZhuNian的学习乐园-CSDN博客
内容分为四个部分：
第一部分：数据读取与展示
第二部分：特征理解分析
第三部分：数据清洗与预处理
第四部分：建立模型
数据和源码 移步到Github ： https://github.com/Stormzudi/Data-Mining-Case
邮箱：442395572@qq.com
目录
前言：
1. 泰坦尼克号-数据挖掘案例解读
2. 数据挖掘流程
3. 挑选兵器
第一部分：数据读取与展示
1. 原始数据展示
第二部分：特征理解分析
1. 数据特征分为：连续值和离散值
1.1 Sex --&gt; 讨论：性别跟获救情况的关系
1.2 Pclass --&gt; 讨论：船舱等级跟获救情况的关系
1.3 Age --&gt; 讨论：连续值特征对结果的影响
第三部分：数据清洗与预处理
1. 缺失值填充
1.1 Embarked --&gt; 分析：登船地点跟获救情况的关系
1.2 sibsip --&gt;分析：兄弟姐妹的数量
1.3 Parch --&gt; 分析： 父母和孩子的数量
1.4 Fare --&gt; 分析： 船票的价格
2. 特征工程和数据清洗
2.1 特征相关性的热度图
2.2 特征工程和数据清洗
Age：年龄特征
Family_size：家庭总人数
Fare：船票价格
第四部分：建立模型
1. 交叉验证
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b18f96db258689b5fc9ce09ae18b972/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efef43b76faddcddc820ccc0b37c6b47/" rel="bookmark">
			SQL注入之MySQL注入姿势及绕过
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SQL注入之MySQL注入姿势及绕过 参考链接： https://xz.aliyun.com/t/10594
感受 1. 写的详细，并且绕过姿势也很多，大佬级人物 2. 在网上发现类似的文章，感觉这就是为啥知识需要付费的原因。 3. 学到的东西很多 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16aa8acc5145870d28ffcab9bf3e9655/" rel="bookmark">
			模型评估常见名词（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型的特异性与敏感性，以及二分类模型的评价指标。
下图参考知乎某回答，链接如下，我在学习之后，经过自己总结，给出如下类比解释。
https://www.zhihu.com/question/30750849/answer/346299267https://www.zhihu.com/question/30750849/answer/346299267
模型的特异性与敏感性，这里与医学领域的查全率和查准率相联系，下面以患病给出对比。
下图成为混淆矩阵。
TP:真阳性，即被诊断患病的人中确实患病的人，即诊断患病判断正确的人数。
FP:假阴性，即被诊断为不患病的人中，却患病的人，患病而被漏诊的人。
TN:真阴性，确实不患病，诊断不患病正确的人。
FN:假阳性，即诊断为患病缺并没有患病，被误判为患病的人。
敏感性Sensitivity = TP / （TP + FN），第一行
特异性Specificity = TN / （FP + TN），第二行
敏感性：检测患病的比率越大，表明对该病的识别是否患病诊断比较敏感，称之为敏感性。
特异性：
泛化能力：机器学习模型预测误差情况通常是评估的重点，它不仅仅是学习过程中对训练数据有良好的学习预测能力，根本上在于要对新数据能有很好的预测能力
二分类问题：对于二分类问题，常用的评价指标，
F1-score：
precision：精确率P
recall:召回率R
average error:
本文参考了知乎上一下几篇出色的文章，建议读者阅读。
https://www.zhihu.com/question/30750849/answer/346299267https://www.zhihu.com/question/30750849/answer/346299267https://zhuanlan.zhihu.com/p/436810215https://zhuanlan.zhihu.com/p/436810215https://zhuanlan.zhihu.com/p/434368207https://zhuanlan.zhihu.com/p/434368207
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1387b9cc5d9fbf3c1a8ee249e7448c3/" rel="bookmark">
			19-Figma-旋转造型绘制技法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 19-Figma-旋转造型绘制技法 效果 步骤 1.绘制基础造型 平滑锚点切换为转折锚点 锚点处调整圆角 2.定义自定义旋转点 这个点画小一点 然后找到小圆点的坐标 3. 利用插件Rotate Copies完成 4.完成 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b354734d797ab82fe30811dcc745b8a/" rel="bookmark">
			Android R(11)创建自定义HIDL接口--ICustomHardware(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.定义包名 package flagstaff.hardware.custom_hardware@1.0; HIDL的定义风格总体和cpp是相似的，此处的package也就对应cpp的命名空间，如果是使用cpp来实现后端，那么接口对应的命名空间如下
using flagstaff::hardware::custom_hardware::V1_0::ICustomHardware; 在HIDL接口中，包名的定义规则如下
&lt;package_name&gt;@&lt;number.number&gt; 2.定义接口名 package flagstaff.hardware.custom_hardware@1.0; interface ICustomHardware { ... }; ICustomHardware 对应cpp的话则类 ICustomHardware。
interface可以和cpp的class/struct等关键字挂钩理解。
3.定义方法 package flagstaff.hardware.custom_hardware@1.0; interface ICustomHardware { enableHardware(bool data) generates (bool ret); }; 此处在接口ICustomHardware内定义了方法enableHardware,其入参为boolean类型，返回值也是boolean。
4.文件存放 HIDL的文件命名必须与其内部的接口名称对应，故对于此处定义了ICustomHardware则需保存为ICustomHardware.hal。在HIDL中，一个接口则对应一个文件。下面则是ICustomHardware.hal的存放目录
test/flagstaffTest/hardware/interfaces/custom_hardware/1.0/ICustomHardware.hal 5.Android.bp 5.1 使用hidl-gen自动生成 hidl-gen根据是AOSP自带的根据，专门用于根据用户自定义的HIDL接口自动生成各种以来文件的。下面则是用于生成Android.bp的命令
hidl-gen -L androidbp -r flagstaff.hardware:test/flagstaffTest/hardware/interfaces flagstaff.hardware.custom_hardware@1.0 5.2 hidl-gen hidl-gen功能还是比较强大的，最好提前熟悉。后续自动生成cpp的头文件、接口实现框架代码都会用到,下面是其基本格式。
flagstaff@flagstaff-pc:~/aosp_r.lns$ hidl-gen Usage: hidl-gen -o &lt;output path&gt; -L &lt;language&gt; [-O &lt;owner&gt;] [-p &lt;root path&gt;] (-r &lt;interface root&gt;)+ [-R] [-v] [-d &lt;depfile&gt;] FQNAME.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b354734d797ab82fe30811dcc745b8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9df74317fb687651c99712d197f1cc08/" rel="bookmark">
			Flask学习与项目实战3：简单入手模板及高阶使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：本学习系列笔记是来源B站 知了传课 up主的教学视频的个人学习笔记，原up主教学视频地址：https://www.bilibili.com/video/BV17r4y1y7jJ?p=10。
模板简介 模板是开发web的必备模块，渲染网页的时候，并不是渲染一个纯文本，而是渲染一个富有文本标签的页面。
这个时候就需要使用上模板了。在flask中，配套的模板是jinja2。跟flask一样简单高效。使用起来容易上手。
简单入手 注意模板会在templates里面去寻找这些模板的。所以html需要放在templates下进行操作。
也可以通过更改 Flask（name,template_folder）来修改模板的地址，但是一般不会这么做。
通过render_template来渲染模板。
如果想要传递变量到模板之中，可以把变量定义成字典，然后再render_template中通过关键字参数的方式传递过去。
模板过滤器 Jinja2 过滤器是通过管道符号（|）进行使用的，例如：{{ name|length }}，将返回name的长度。过滤器相当于是一个函数，把当前的变量传入到过滤器中，然后过滤器根据自己的功能，再返回相应的值，之后再将结果渲染到页面中。Jinja2中内置了许多过滤器，在这里可以看到所有的过滤器，现对一些常用的过滤器进行讲解：
html中不能使用python中的一些函数等等。过滤器就是可以使用一些来进行类似内置函数的操作。
join过滤器：将一个序列变成字符串。
使用了join过滤器的情况如下：
控制语句 {% %}就可以使用控制语句了。{{}}两个花括号是使用变量的值。
if 然后通过**context把变量传进去。
这样访问about的时候，就会看道 您刚成年这四个字，因为传进来的变量值是18。
遍历 books里面的每个元素。
遍历person：
模板继承 关键字：block extends
有些网页中是有很多样式一样的。
所以可以使用模板继承。
首先定义父模板。
首先title中，使用block进行预留title给子模板使用。
接下来其他的模板就可以进行继承了。
使用 extends 进行继承就可以了。
具体的形式如下图所示：
静态文件的配置 静态文件放在static下的。
Web应用中会出现大量的静态文件来使得网页更加生动美观。类似于CSS样式文件、JavaScript脚本文件、图片文件、字体文件等静态资源。在Jinja中加载静态文件非常简单，只需要通过url_for全局函数就可以实现，看以下代码：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82f79daa341facac92b985e4df8f6af7/" rel="bookmark">
			解决公司无法访问自建的网站问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		兼职网管记录 解决公司无法访问自建的网站问题相关配置Q1:建站后IP直接访问Q2:更换IP不久，问题重现 解决公司无法访问自建的网站问题 相关配置 TPlink TL-WAR1208L 路由电信服务商 问题记录如下
Q1:建站后IP直接访问 公司主导的两个项目，使用了两个.com，由第三方委托建站后，公司IP不能访问。
尝试光猫重启，重新获取IP后正常未解决前：不在内网内，使用不同的设备及网络服务商均可访问未解决前：在内网内，挂载小猫咪可以正常访问 Q2:更换IP不久，问题重现 进入公司内部路由，分配DNS解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bfc68ef04a74a77af891239e3d83a16/" rel="bookmark">
			SSM整合配置文件总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、jdbc.properties jdbc.driverClassName=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql:///javalearn jdbc.username=root jdbc.password=123456 initialSize=5 maxActive=10 maxWait=3000 1、sqlMapConfig.xml &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;!--起别名--&gt; &lt;typeAliases&gt; &lt;typeAlias type="cn.ecust.domain.User" alias="user"&gt;&lt;/typeAlias&gt; &lt;/typeAliases&gt; &lt;!--注册类型处理器--&gt; &lt;!-- &lt;typeHandlers&gt;--&gt; &lt;!-- &lt;typeHandler handler="cn.ecust.handler.DateTypeHandler"&gt;&lt;/typeHandler&gt;--&gt; &lt;!-- &lt;/typeHandlers&gt;--&gt; &lt;plugins&gt; &lt;plugin interceptor="com.github.pagehelper.PageHelper"&gt; &lt;!--根据数据库不同指定方言--&gt; &lt;property name="dialect" value="mysql"&gt;&lt;/property&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/configuration&gt; 2、applicationContext.xml 开启注解的扫描，希望处理service和dao，controller不需要Spring框架去处理
加载数据库配置文件jdbc.properties
配置数据源
配置sessionFactory
扫描dao所在的包，为dao创建实现类
平台事务管理器
事务增强
事务的AOP织入
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--1、开启注解的扫描--&gt; &lt;context:component-scan base-package="cn.ecust" &gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bfc68ef04a74a77af891239e3d83a16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e820569c59a0779d93477dd32f9d194f/" rel="bookmark">
			BI技巧丨权限管控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BI可视化在实施过程中，用户最关注的点有哪些？
这个问题相信很多小伙伴都遇到过，或者被其他人问过，白茶总结了一下用户比较在意的几个点：安全性、自助性、权限管控、易用性、兼容性、扩展性、便捷性、反应速度等。
本期呢，我们来聊一聊关于权限管控那些事。
PowerBI截至目前为止，可以实现的权限管控包含三方面：页面权限、行权限、列权限。
那么这三者在PowerBI中是如何实现的呢？别急，跟着白茶的思路走。
先来看看本期的案例数据：
案例数据并不是很复杂，共计三张表，分别是权限表、国家表以及案例数据。
将其导入到PowerBI中，我们对权限表进行一下简单的处理。
这是在PowerQuery中关于权限表的截图，大家可以看到页面权限和国家权限采用逗号分割的方式进行存储。
我们需要对这两列进行一下拆分处理。
选择“页面权限”，选择“拆分列”，选择按“分隔符拆分”。
选择“自定义分隔符”，输入文本间的间隔，选择高级选项，选择拆分为“行”。
结果如下：
同理，根据上面的操作，我们将“行权限”进行拆分。
这样做的好处在于，报表正式投入使用后，用户只需要维护Excel文件中的权限配置，PowerBI就会在后台自动执行拆分，进行报表权限控制。
选择关闭并应用，模型如下图。
这里注意一下，权限表不需要与其他表建立模型关系。
白茶根据案例数据，简单的做了如下几个报表。
首页：作为页面权限管控使用，使用字段为权限表中的页面权限字段。
可视化页面：用来展示列权限。
明细页面与地图页面：展示页面权限与行权限使用。
到这里，我们的准备工作基本完成，我们来看一下，三者在PowerBI中的实现方式。
页面权限：
1.报表页面命名与隐藏。
这里大家需要注意，报表页面的名称，一定要与Excel中的文本相对应，不然会导航失败。
当我们配置完成后，除了首页之外的页面，均要设置为隐藏；发布时页面要停留在首页。
2.页面权限配置：选择“管理角色”，选择创建一个角色“页面权限”，在“权限表”输入以下代码。
[邮箱]=USERNAME() 3.页面设置：切片器字段选择权限表中的“页面权限”字段。
添加如下度量值：
页面选择 = SELECTEDVALUE ( '权限表'[页面权限] ) 添加按钮，在“操作”设置中选择类型为“页导航”，点击“fx” 按钮，选择字段值为“页面选择”。
到这里，页面权限配置完成，我们点击面板上的“通过以下身份查看”。
其他用户这里面我们可以输入用户的邮箱进行测试。
我们输入BB测试一下：
可以看到，当我们输入BB邮箱时，切片器会自动的根据用户的权限进行页面筛选。
行权限（RLS）：
行权限这个往往代表用户所能看到的数据范围。
1.添加如下度量值：
国家权限 = VAR CountryAccess = CALCULATETABLE ( VALUES ( '权限表'[行权限] ), '权限表'[邮箱] = USERNAME () ) RETURN SELECTEDVALUE ( '国家表'[CountryZH] ) IN CountryAccess 2.在管理角色页面添加新角色如下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e820569c59a0779d93477dd32f9d194f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e69f45a8f338aefb9ebe374409a6904/" rel="bookmark">
			Python投骰子小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们用Python来实现一个投骰子小游戏，这个小游戏比之前写的要复杂一点点，不过大家不用担心，只要大家掌握了基本的语句就可以写出来了
游戏具体内容如下：
#投骰子 #玩两个骰子 ： 1-6 #1.玩游戏要有金币 #2.玩游戏赠送金币一枚，充值获取金币 #3.只能按10元的倍数充值，10元20个金币 #4.玩一局游戏消耗金币5个 #5.猜大小：猜对 奖励金币2枚 猜错没有奖励 超出6点以上认为是大，否则是小 #6。游戏结束：1.主动退出 2.没有金币退出游戏 #7.退出打印剩余金币数，共玩了几局 代码如下：
import random coins = 0 #金币数 count = 0 #计数器 if coins &lt; 5: #提示充值 print('金币不足，请充值再进入游戏') while True: money = int(input('请输入充值金额')) # 充值金额应为10元的倍数，10元20个金币 if money % 10 == 0: coins = money // 10 * 20 # 计算充值后的金币个数 print('充值成功，当前金币数为%d个' % coins) #进入游戏 print('*******进入游戏*******') answer = input('是否开启游戏(yes or no)') while coins &gt;=5 and answer: # 玩一局扣5个金币 coins -= 5 # 玩一局赠送金币 coins += 1 # 产生两枚随机数 ran1 = random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e69f45a8f338aefb9ebe374409a6904/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4df66fbec288b495627c84740c5e9b32/" rel="bookmark">
			安装echo模块调试Nginx变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题来源 (1)看到nginx.conf里面的变量头都大了，因为我完全不知道那个变量表示的到底是什么，一脸懵逼。。。
(2)有的时候我们需要根据不同的 if 条件自定义变量，并对这些自定义的变量进行调试
解决方法 令人感动到哭的解决方法就是 echo-nginx-module 模块来调试变量。然而这个模块默认情况下并不存在于nginx的正式发行包中，因此我们需要在编译安装nginx的时候手动添加
echo-nginx-module模块的github地址是：
https://github.com/openresty/echo-nginx-module
安装方法如下：
$ wget 'http://nginx.org/download/nginx-1.11.2.tar.gz' $ tar -xzvf nginx-1.11.2.tar.gz $ cd nginx-1.11.2/ # Here we assume you would install you nginx under /opt/nginx/. $ ./configure --prefix=/opt/nginx \ --add-module=/path/to/echo-nginx-module $ make -j2 $ make install 调试案例 为了输出nginx中的各种变量，我通过在/etc/hosts文件中添加了如下记录：
server{ listen 80; server_name www.test.com; location / { echo 'query_string: $query_string'; echo 'request_method: $request_method'; echo 'content_type: $content_type'; echo 'content_length: $content_length'; echo 'fastcgi_script_name: $fastcgi_script_name'; echo 'request_uri: $request_uri'; echo 'document_uri: $document_uri'; echo 'document_root: $document_root'; echo 'server_protocol: $server_protocol'; echo 'https: $https'; echo 'nginx_version: $nginx_version'; echo 'remote_addr: $remote_addr'; echo 'remote_port: $remote_port'; echo 'server_addr: $server_addr'; echo 'server_port: $server_port'; echo 'server_name: $server_name'; echo 'uri: $uri'; } } 然后使用curl命令向www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4df66fbec288b495627c84740c5e9b32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/489523b3bf0a8f71a0e5e133c3d8f4e2/" rel="bookmark">
			【蓝桥杯基础练习】第二天： ① 闰年判断 ② 01字串 ③ 字母图像 ④ 数列特征 ⑤ 查找整数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BASIC-1到BASIC-5 闰年判断01字串==【知识点】== 字母图像==【知识点】== 数列特征==【知识点】== 查找整数==【知识点】== 闰年判断 ''' 给定一个年份，判断这一年是不是闰年。 当以下情况之一满足时，这一年是闰年： 1. 年份是4的倍数而不是100的倍数； 2. 年份是400的倍数。 其他的年份都不是闰年。 样例输入 2013 样例输出 no 样例输入 2016 样例输出 yes ''' a = int(input()) if (a%4==0 and a%100!=0) or a%400==0 : print('yes') else : print('no') 01字串 ''' 问题描述 对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。它们的前几个是： 00000 00001 00010 00011 00100 请按从小到大的顺序输出这32种01串。 输出格式 输出32行，按从小到大的顺序每行一个长度为5的01串。 样例输出 00000 00001 00010 00011 &lt;以下部分省略&gt; ''' 俩种代码的输出结果不同，第一种输出的有空格，第二种是连续输出（无空格）
for a in range(0,2): for b in range(0,2): for c in range(0, 2): for d in range(0, 2): for e in range(0, 2): print(a,b,c,d,e) # 输出有空格，卧槽就离谱 for a in range(0,2): for b in range(0,2): for c in range(0,2): for d in range(0,2): for e in range(0,2): print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/489523b3bf0a8f71a0e5e133c3d8f4e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68f465370874a0c32430d453b8fbea80/" rel="bookmark">
			[夜寂]Spring中Resource接口有关的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*
Resource resource = new FileSystemResource("Beans.xml");
try {
resource.getInputStream();
} catch (IOException e) {
// TODO 自动生成的 catch 块
e.printStackTrace();
}*/
Resource resource1 = new ClassPathResource("Beans.xml");
Resource resource2 = new UrlResource("Beans.xml");
Resource resource3 = new InputStreamResource(new FileInputStream(new File("Beans.xml")));
Resource resource4 = new ByteArrayResource("helloworld".getBytes());
分别对应文件,classpathResource,UrlResource,inputstream资源,byte数组
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/265259c8ce22e1b4a0fb940d6ad6f8b9/" rel="bookmark">
			解决C&#43;&#43;调用DLL，传入DLL后参数变为空值问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
场景
问题原因
解决方案
场景 在C++项目中，C++ DLL调用另一C++ DLL时，非空参数传入DLL后变空。
问题原因 排查调用方DLL和调用的DLL运行库是否一致，如图所示，本文所遇到的问题为，调用方为Release模式，设置的 运行库 为 多线程 DLL (/MD)，调用的DLL为 Debug 模式，设置的 运行库 为 多线程调试DLL (/MDd)。
解决方案 将调用方DLL与调用的DLL库的运行模式及运行库修改一致，比如模式均为Release模式，运行库均为多线程DLL(/MD)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b289a5a291305dbb7a4a159506a65d37/" rel="bookmark">
			C&#43;&#43; string乱码可能解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题场景
问题原因
解决方案
问题场景 C++ string对象赋值后，变为乱码。
问题原因 经过排查后，发现是因为string为结构体中的一个成员，在达到某个条件后，会调用SecureZeroMemory函数对结构体进行初始化为0的操作，由于SecureZeroMemory不能作用于类（应该使用构造函数），从而导致string对象出现乱码。
解决方案 采用对结构体中成员进行分别赋默认值的方式替代SecureZeroMemory。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83fcc6e56e05fb50922225496c6d18ad/" rel="bookmark">
			Linux中以rpm方式安装JDK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装方式 yum、压缩包、rpm三种方式，这里用的是rpm安装
1.准备 官网下好rpm安装包，链接：https://pan.baidu.com/s/1r2mBOFuOl4Ma-PKyT_uBkQ
提取码：jjkk ，这是我自己的，版本为jdk-8u301-linux-x64.rpm
2.上传到自己服务器 可用xftp，也可用宝塔传，就不展开细说，直接拖的问题
3.开始配置 先检查有没有java版本
若有安装OpenJDK可强制卸载，可先用该命令检查版本
rpm -qa|grep jdk 后强制卸载，注意之前配置环境变量不会被删除
rpm -e --nodeps jdk1.8-1.8.0_301-fcs.x86_64 再检查是否还有java版本
然后检查自己上传的jdk
无问题就直接安装
rpm -ivh jdk-8u301-linux-x64.rpm 然后去配置环境变量
#Java环境变量 JAVA_HOME=/usr/java/jdk1.8.0_301-amd64 CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin export PATH CLASSPATH JAVA_HOME 不同在于java路径和名字不同，其他通用，注意一旦环境变量配置错误，出去后就会产生一个严重的问题就是执行任何普通命令都会失败，提示bash: ls: command not found，输入export PATH=/bin:/usr/bin:$PATH，然后回车就能解决问题，但不能根治，只有把profile文件问题改正才会彻底根治
出去后再执行命令使改动生效
source /etc/profile 然后再检查java
没问题即安装完成
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/264/">«</a>
	<span class="pagination__item pagination__item--current">265/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/266/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>