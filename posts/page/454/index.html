<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d2b18485928e0391cc3ea89022ad137/" rel="bookmark">
			python：使用scipy求解常微分方程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到一个物理问题，要求解如下微分方程组： d2xdt2=wdydt d2ydt2=−wdxdt 经参考相关资料后得知，需要用到scipy包中的odeint函数。 odeint函数使用方法如下：
def sol(y,t,v0,w0): return (w0*y[1]+v0,-w0*y[0]) y = odeint(sol,(0,0),t,args = (10,10)) 其中t是自变量，需要给出其取值范围；sol用来描述微分方程；得到的y是一个numpy矩阵，每一行对应一个因变量在自变量范围的值。 odeint所求解的方程必须是如下形式： dydx=f(x,y) 因此，在求解上面的方程组中，实际上是求出了导数，还需要进行积分得到真实的值。
参考资料： Scipy科学计算： http://blog.chinaunix.net/uid-21633169-id-4437868.html scipy下载（win32 python2.7） http://download.csdn.net/download/u010156024/9302697
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb4e62e7357070b7ede8d976b52b385d/" rel="bookmark">
			使用iServer JAVA API访问iServer空间分析服务进行叠加分析示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：MR
之前一篇博客（SuperMap iServer JAVA API介绍）介绍了SuperMap iServer Java API（以下简称Java API）用处、用法，本篇介绍JAVA API访问iServer空间分析服务进行叠加分析的具体应用，并提供工程源码下载。作为示例，这里使用eclipse创建一个控制台应用。
###一、创建JAVA工程&amp;主类
创建一个Java工程，工程下新建lib文件夹，复制%iServerROOT%\WEB-INF\lib\iserver-all-8.1.1-14511.jar到lib文件夹里，并将lib文件夹下的iserver-all-8.1.1-14511.jar右键添加到Build Path里。
本文新建一个包，命名spatialAnalystSample，其下创建一个类，命名SpatialAnalystSample，添加main方法。工程结构如图（JDK1.8）：
###二、获取空间服务提供者
本文访问的空间分析服务REST资源根目录如下：
http://support.supermap.com.cn:8090/iserver/services/spatialanalyst-changchun/restjsr 创建/释放RestSpatialAnalystProvider方法如下：
/** * @param RootURL * 空间分许服务REST资源根目录 * @return RestSpatialAnalystProvider */ private static RestSpatialAnalystProvider getAnalystProvider( String rootURL ) { // 服务提供者设置 RestSpatialAnalystProviderSetting setting = new RestSpatialAnalystProviderSetting( ); setting.restServiceRootURL = rootURL; // 创建服务提供者 return new RestSpatialAnalystProvider( setting ); } /** * @param provider * 待释放资源的服务提供者对象 */ private static void dispose( RestSpatialAnalystProvider provider ) { if ( provider !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb4e62e7357070b7ede8d976b52b385d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2f4e5847b02de4f12f1caf7d3f26d3d/" rel="bookmark">
			opencv 图像傅里叶变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 傅里叶变换 目标 • 使用 OpenCV 对图像进行傅里叶变换 • 使用 Numpy 中 FFT（快速傅里叶变换）函数 • 傅里叶变换的一些用处 • 学习的函数有： cv2.dft()， cv2.idft() 等 原理 傅里叶变换经常被用来分析不同滤波器的频率特性。我们可以使用 2D 离散傅里叶变换 (DFT) 分析图像的频域特性。实现 DFT 的一个快速算法被称为快速傅里叶变换（FFT）。关于傅里叶变换的细节知识可以在任意一本图像处理或信号处理的书中找到。 对于一个正弦信号： x(t) = A sin(2πft), 它的频率为 f，如果把这个信号转到它的频域表示，我们会在频率 f 中看到一个峰值。如果我们的信号是由采样产生的离散信号好组成，会得到类似的频谱图，只不过前面是连续的，现在是离散,把图像想象成沿着两个方向采集的信号,所以对图像同时进行 X 方向和 Y 方向的傅里叶变换，我们就会得到这幅图像的频域表示（频谱图）。更直观一点，对于一个正弦信号，如果它的幅度变化非常快，我们称之为高频信号，如果变化非常慢，我们称之为低频信号。你可以把这种想法应 用到图像中，图像那里的幅度变化非常大呢？边界点或者噪声。所以我们说边界和噪声是图像中的高频分量（注意这里的高频是指变化非常快，而非出现的次数多）。如果没有如此大的幅度变化我们称之为低频分量。现在我们看看怎样进行傅里叶变换。
2、Numpy 中的傅里叶变换 首先我们看看如何使用 Numpy 进行傅里叶变换。 Numpy 中的 FFT 包可以帮助我们实现快速傅里叶变换。函数 np.fft.fft2() 可以对信号进行频率转换，输出结果是一个复杂的数组。本函数的第一个参数是输入图像，要求是灰度格式，第二个参数是可选的, 决定输出数组的大小。输出数组的大小和输入图 像大小一样。如果输出结果比输入图像大，输入图像就需要在进行 FFT 前补0；如果输出结果比输入图像小的话，输入图像就会被切割。 现在我们得到了结果， 频率为 0 的部分（直流分量）在输出图像的左上角。如果想让它（直流分量）在输出图像的中心，我们还需要将结果沿两个方向平移 N/2 。 函数 np.fft.fftshift() 可以帮助我们实现这一步。（这样更容易分析）, 进行完频率变换之后，我们就可以构建振幅谱了。
import cv2 import numpy as np from matplotlib import pyplot as plt img = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2f4e5847b02de4f12f1caf7d3f26d3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6562a633753cf59fb4510565bf6be9d0/" rel="bookmark">
			关于UEFI启动&#43;GPT分区 的一些经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.sina.com.cn/s/blog_4dc988240102xuyq.html
前言： 随着时代和科技的发展，电脑越来越普及，似乎人人都可以张嘴就说“我懂电脑”，但是总有一些看起来完全不懂但实际上非常基础的东西让“懂”与“不懂”清晰地划清界限。比如UEFI+GPT就是其中之一。那些之前认为自己已经精通电脑的人，遇到这个东西，忽然发现自己连以前自以为驾轻就熟的分区、装系统都不会了。 尽管UEFI以及GPT从诞生迄今已经十余年了，但是对于绝大多数人来讲它们是完全陌生的，甚至根本就不知道还有这种东西。 但是由于Windows8操作系统的面世，预装Windows8的电脑开始统一采用UEFI+GPT，很多人被迫接触到，感觉就像突然从天上掉下来的东西一样，无所适从，一筹莫展——“这到底是个什么东西呢？” 一旦出现系统问题，唯一能做的解决办法除了品牌机自带的系统还原，最大能力不过就是把UEFI关闭，把硬盘从GPT再转成MBR，从而彻底毁掉UEFI+GPT的优势，重新回到陈旧落后的BIOS+MBR的系统安装和运行方式上来。而每台电脑的具体情况又不尽相同，有时候即使想用BIOS+MBR也不是肯定能成功的——“我该怎么办啊？” 正文： 之前很长一段时间对UEFI+GPT没有头绪，有种无处下手的感觉，虽然UEFI+GPT安装系统一直没遇到什么障碍，但是即使查阅了相当数量的资料，在认识上对于UEFI+GPT也没有一个完整的概念，总觉得这是一个很难理解的东西，不得要领。不像最初接触BIOS+MBR的时候那么容易入门直至熟练操作。 先说关于什么是UEFI和GPT，在此就不做详解了，感兴趣的都了解，不感兴趣的说了也没什么用处。只说一点最基本的，MBR分区结构只能支持到2.2T的硬盘，超过2.2T就必须采用GPT分区，而就Windows而言，采用了GPT的硬盘，要想安装并启动Windows操作系统，只能选择高于XP的64位操作系统，并且采用UEFI方式安装、引导，否则无法启动，而包括XP在内及其之前的32位操作系统完全不支持GPT，别说安装、引导系统，直接无法识别。3T硬盘时代并不遥远，要想正常使用你的电脑，这就是采用UEFI+GPT的必要性。 而最关键之处在于，照目前的形势来看，由于预装Windows8电脑的推动，UEFI+GPT已经是大势所趋，与是否2.2T以上硬盘也已经没什么直接关系，也许就在不久之后的某一天开始所有的电脑全部使用UEFI单一启动，不会再兼容传统BIOS。 再说一下关于BIOS+MBR，从接触电脑十几年来，一直都是用的这种组合，直至今日，不敢说对此有多么了解，最起码在日常操作中基本无障碍了。比如：Windows各个版本甚至再+Linux+Mac的混合安装、引导驾轻就熟，任意顺序安装，任意创建、修复引导，多硬盘混合引导，分区表损坏、主引导记录损坏的修复、重建等等，都不存在任何问题。 而从一接触UEFI+GPT，总是感觉这个东西无法理解。甚至一筹莫展，哪怕是引导损坏这样之前在BIOS+MBR里不叫事的事情，面对UEFI+GPT都束手无策，查了很多资料，除了重装系统，在国内网络范围内，全网竟然找不到任何一篇具体解决问题的文章。现在回想，很长一段时间内都无法理解这些问题，很多莫名其妙的所谓专业文章的误导在其中作了重要贡献。 后来索性抛开所有的那些乱七八糟的观点、定义，按照自己的想法去摸索，经过近十天，几十遍重装系统，反复的假设、实验，总算是对UEFI+GPT有了一个总体的概念和较为清晰的认识，最关键的在于能够随意进行UEFI+GPT的安装和引导修复了，这是最重要的，个人观点一直都是，必须从实际出发，即使了解的再多，什么问题也解决不了，纸上谈兵，一切等于零。可以毫不夸张的说，至少目前为止，本文是全网络唯一一篇对UEFI+GPT进行实用性介绍和以及解决实际问题的文章。 个人体会，实际上只要对BIOS+MBR有一定的了解和操作能力，完全可以继续用BIOS+MBR的思路去考虑UEFI+GPT的问题，这样的话很多事情都会迎刃而解，因为两者之间在实际应用和操作上没有本质区别，而不是像某些专业文章所渲染那么高深莫测，并且尽其能事的竭力描述两者之间的重大区别，使UEFI+GPT理解起来更加困难，在一定程度上来讲，这就是一种因循误导。（当然也不排除某些写此类文章的人其实自己对这个东西也一知半解或者根本就不明白，除了千篇一律的抄袭、转载，最多也只能翻来覆去的照搬官方术语，堆砌定义和理论，完全谈不上有自己的观点或者看法，更没有什么具体的解决方案。） 关于UEFI的优越特性，比如可操作性、安全性、兼容性、可扩展性之类的问题，在此不再多说，这是开发人员的事情，和我没有关系。仅仅总结几点两者在系统安装及引导方式方面一些异同，帮助同样有此困惑的人理解这个东西： 【重要提示： 本文旨在“授之以渔”，力求融会贯通，知其然更知其所以然。因此本文既不包含网络上“技术文章八股文”式的定义、理论的堆砌和释义，更不是“小白必备”的傻瓜式手把手操作教程，如果对以上两种千篇一律的所谓“技术文章”有偏执的爱好，请务必及时停止浏览，另寻其好。】 不同点： 1.BIOS+MBR安装系统要求硬盘只要存在非隐藏、活动的主分区就可以了；而UEFI+GPT要求硬盘上除了存在ESP分区，还必须存在至少一个主分区 2.BIOS+MBR一旦系统安装好之后，如果系统引导文件在单独的分区，此分区可以在操作系统中可见，也可以设置此分区为隐藏，系统都可以正常启动；而UEFI+GPT系统引导文件所在的ESP分区在操作系统中为不可见 3.BIOS+MBR启动要求的活动的主分区不是唯一固定的，可以任意设定某一分区为活动的主分区，然后MBR就可以通过分区表指引操作系统从此分区启动，也就是说，可以在任意分区（主分区无论是否活动或者扩展分区）安装操作系统，只要存在任意的活动主分区，就可以从此分区启动操作系统；而UEFI+GPT只能把系统引导文件放置在ESP分区 4.BIOS+MBR的系统引导文件可以和系统文件在同一分区的根目录，也可以不与系统文件同一分区，只要系统引导文件所在分区为活动的主分区即可启动操作系统；而UEFI+GPT只能把系统引导文件放置在ESP分区，且操作系统必须在另外的主分区，也就是说，UEFI+GPT强制要求系统启动文件与系统文件必须分离，不在同一分区。 相同点： 1.BIOS+MBR和UEFI+GPT的系统引导文件都可以放置在单独的分区，这一点在上面的第4点里已经说的很清楚 2.BIOS+MBR的系统引导文件所在的活动主分区位置不是固定的，可以随意设置任意分区满足此条件，UEFI+GPT的ESP的位置也是可以随意设置的，在硬盘起始位置、中间位置、末尾，都可以，只要分区属性和其中的引导文件正确，就可以引导启动操作系统（参考文中附图） 3.BIOS+MBR的系统引导文件所在的分区和UEFI+GPT的ESP分区都可以分配任意大小，而不是ESP必须100M 4.BIOS+MBR安装系统所需的非隐藏、活动主分区和UEFI+GPT的系统的ESP分区，都可以同时设置多个，但是即使有多个相同属性的分区，系统安装时安装程序都是自动写入第一个，启动时也都是从第一个启动（参考文中附图） 补充： 1.使用BIOS+MBR和UEFI+GPT安装的系统文件是一模一样的，唯一的区别只是引导方式的不同，因此使用GHOST手动备份的系统，MBR和GPT可以任意交叉还原，只要做好引导修复就没有任何问题 2.GHOST始终是系统备份还原神器，只要熟练掌握GHOST手动操作，至少目前为止Windows系统的范围之内，无论什么版本，无论MBR还是GPT，都可以随意备份还原。 3.MBR与GPT分区互转的话，与“删除所有分区”以及“全盘格式化”没有任何必然联系，你格式化一万遍硬盘也还是原来的分区结构，只有通过转换操作才可以到另一种，而这个转换操作与“删除所有分区”以及“全盘格式化”没什么关系。 着重强调一点： 以上所有经验均基于UEFI+GPT的组合，而实际上，UEFI启动（Windows操作系统）的话，并不强制要求硬盘必须为GPT分区，而是只要硬盘上存在EFI启动文件且位于FAT（16/32）分区就可以了（UEFI无法从NTFS分区启动）。因此如果是小于2.2T的硬盘，不必非得转换成GPT也可以引导系统启动。也就是说，UEFI+MBR也是可行的，而GPT硬盘的话，则必须使用UEFI引导，BIOS无法原生引导GPT硬盘上的操作系统（Windows）。 关于这一点，如果感觉不能理解的话，可以通过以下具体应用来参考。 注： 综观网上那些关于UEFI的所谓技术类文章，除了毫无实用价值和实际意义，而且都不同程度的存在各种各样的因循误导，继而被以讹传讹，最终成为一些人坚信不疑的“定律”。这样的误导主要表现为两点： 1.就是刚刚说的，“UEFI启动系统必须是GPT分区”，这个已经说得很明白了，并且有实例解析，无需再讨论 2.另外一个就是不知道从什么时候什么人开始谣传的“UEFI的优势就是启动速度快”或者“UEFI启动比传统BIOS启动速度快”。无论UEFI还是GPT，与电脑启动速度没有任何必然联系。或者说，只要硬件环境相同、系统一样，无论UEFI+GPT安装还是BIOS+MBR安装系统，启动速度没有区别 附：部分Windows桌面操作系统对GPT的支持 数据读写系统启动 WindowsXP32位不支持GPT不支持GPT WindowsXP64位支持GPT不支持GPT WindowsVista32位支持GPT不支持GPT WindowsVista64位支持GPT支持GPT（需UEFI） Windows732位支持GPT不支持GPT Windows764位支持GPT支持GPT（需UEFI） Windows832位支持GPT不支持GPT Windows864位支持GPT支持GPT（需UEFI） 有了以上的经验总结，就可以轻松解决以下问题了： 1.UEFI+GPT环境下以任意方式安装操作系统（单系统或者多系统）。这个不必详解了 2.最主要的问题：UEFI+GPT引导修复操作（EFI引导文件损坏、ESP分区损坏或者丢失之后手动重建EFI引导等等）。这个在此也不做详解，这是这段时间反复研究、实践的最重要成果，因此姑且算是有所保留卖个关子吧，如果是结合以上几点经验总结，对UEFI+GPT有一定的了解之后，应该不难揣摩出办法 3.如果主板不支持UEFI，使用折中的办法来解决大硬盘使用问题，这个问题以前我也已经多次提过。 第一种办法就是使用多块硬盘，MBR+GPT组合，MBR硬盘作为启动引导盘。 小于2.2T的硬盘采用MBR，大于2.2T的硬盘采用GPT，这样的话，解决方案就很灵活了，可以根据以上所列相同点的第1条和补充里面第2条，使用MBR硬盘建一个非隐藏活动主分区，放置系统引导文件，然后将系统安装在MBR硬盘或者GPT硬盘都可以，无论单系统还是多系统都无所谓，两块硬盘交叉安装操作系统也没有任何问题 强调两点： 1.这样安装的话不限于64位操作系统及XP以上版本，理论上只要是能对GPT硬盘进行读写的系统版本就可以安装。实际测试，32位XP和2003sp1以及之前的版本，电脑事先安装GPT硬盘的情况下，即使系统安装在MBR硬盘，原版系统安装，没有问题，如果是Ghost系统，有可能出现卡死或者蓝屏等问题导致无法顺利安装；先在MBR硬盘安装好系统，然后再装GPT硬盘，无论原版还是Ghost系统都没有问题，只是GPT分区无法识别（解决方法很简单，就是使用2003sp2的disk.sys文件替换到以上系统，就可以完美识别GPT分区，此法简单易操作，且不涉及系统稳定问题，感兴趣的话可以自行搜索）。64位XP安装在MBR硬盘，引导、启动都没有问题，安装在GPT硬盘无法引导。其他系统无论32位还是64位，无论安装在MBR还是GPT，都可以正常引导启动； 2.BIOS安装系统到GPT硬盘仅限于Ghost方式，Ghost解压完毕后手动修复引导即可。 第二种办法是单块大于2.2T的硬盘+U盘或者光盘组合 使用GPT分区结构对硬盘进行分区，是否创建ESP分区都无所谓，因为主板不支持UEFI，创建此分区也没什么用，全凭个人爱好了。然后只能使用Ghost方式解压安装操作系统到硬盘，无论单系统还是多系统，全部安装完毕后，准备一个U盘，大小无所谓，只要不小于十几M就行，使用分区软件设为活动主分区，插在电脑上。进PE（2003sp1以上版本），手动或者使用工具软件修复单系统或者多系统引导，将引导文件写入U盘。然后就可以使用此U盘启动所安装的单系统或者多系统了。此方法实际上就是用U盘代替了第一种方法中的小硬盘而已，没什么本质区别。（这个方法大概10年前我就在电脑论坛发过帖子，当时考虑的是用U盘做一个系统启动钥匙，因为系统引导文件在U盘上，电脑如果不插这个U盘是无法启动的。MBR硬盘系统：Windows864位+Windows732位+WindowsXP32位，GPT硬盘系统：Windows832位+Windows764位+WindowsVista32位，测试环境：杂牌945主板、32M老U盘，测试通过。） 另外还可以再使用光盘来代替U盘，具体方法说起来更简单，用软件创建一个可启动光盘（创建方法自行查询，会做的不用讲，压根没接触过的，另开帖子专门讲也不一定看得懂），然后将上面U盘里的系统启动文件加进去刻录就可以了。然后使用此光盘启动电脑，效果和U盘是一样的。此方法仅仅作为一种可行性的介绍，不推荐使用，U盘比这个方便的多，没必要多此一举。 备注：使用此方法，理论上来讲凡是可以对GPT进行读写的系统都适用，但实际上XP以上系统无论32位还是64位操作系统全部测试可行，但是2003sp1及XP64位这些可以读写GPT的系统也不行，这个不知道是由于NT5.X的ntldr引导机制还是其他的什么原因，有知道原因的朋友不吝赐教！ 注： 1.除专门标明“Ghost系统”，本文所提及的系统安装均为微软原版Windows系统，不包含任何修改版本 2.非UEFI主板安装原版系统到GPT磁盘，只能采取wim直接解压到分区或者先将系统Ghost化，然后解压安装的办法。 3.本文所有结论全部为反复多次实际测试结果，不是设想、假设，更不是想象或者幻想以及想当然的以为 4.本文内容已经多次修订和修改，这是个人的一点经验总结，难免有纰漏以及表达不准确之处，望有相关经验的朋友给予更多帮助 附注： 鉴于许多的网友浏览本文之后提出如下问题，因此酷站网软特集中在此做如下补充说明，不再过多赘述及一一答复： 原本很早之前就写了一篇关于预装win8的电脑改其他系统以及安装多系统的文章，虽然经过多次修改，最后还是放在电脑里没有在任何地方发表出来。 虽然那是亲自实践过多个品牌和型号的预装机器之后总结出来的经验，但是仍然发现在其他品牌和型号的电脑上根本无法通用。而我不可能也没条件遍试所有的机器，因此此篇文章就此搁浅。 因此我在我的这篇文章里面没有涉及任何预装win8系统的电脑改系统的问题。 这是我的一贯态度，我所写的都是我亲身实践、确实可行、不需讨论的，在我这里不可能出现“我觉得”“我认为”“应该是”这类想象或者幻想的东西。 （在此还是要特别强调几点： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6562a633753cf59fb4510565bf6be9d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a8ef8fb1b96acf730391ef6430726f/" rel="bookmark">
			Spring Bean的生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文出处： Giraffe Spring Bean是Spring应用中最最重要的部分了。所以来看看Spring容器在初始化一个bean的时候会做那些事情，顺序是怎样的，在容器关闭的时候，又会做哪些事情。
示例代码 git地址：
giraffe0813 giraffeInSpring giraffeInSpring , up-to-date spring版本：4.2.3.RELEASE
鉴于Spring源码是用gradle构建的，我也决定舍弃我大maven，尝试下洪菊推荐过的gradle。运行beanLifeCycle模块下的junit test即可在控制台看到如下输出，可以清楚了解Spring容器在创建，初始化和销毁Bean的时候依次做了那些事情。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Spring容器初始化 ===================================== 调用GiraffeService无参构造函数 GiraffeService中利用set方法设置属性值 调用setBeanName:: Bean Name defined in context=giraffeService 调用setBeanClassLoader,ClassLoader Name = sun.misc.Launcher$AppClassLoader 调用setBeanFactory,setBeanFactory:: giraffe bean singleton= true 调用setEnvironment 调用setResourceLoader:: Resource File Name=spring-beans.xml 调用setApplicationEventPublisher 调用setApplicationContext:: Bean Definition Names=[giraffeService, org.springframework.context.annotation.CommonAnnotationBeanPostProcessor# 0 , com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5a8ef8fb1b96acf730391ef6430726f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4edd503caff3d00c596d344b5ffb9abb/" rel="bookmark">
			No signing certificate &#34;ios Development&#34; found : No &#34;ios Development&#34; signing certificate matching
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现这个错误的原因是（没有下载到电脑本地运行到keychain当中造成的）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fe03101452c0d0ef7b1b7aedfa27187/" rel="bookmark">
			java将数据库数据导出为Excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开发环境 ssm框架；MySQL；JDK1.7；Tomcat7.0 Apache POI组件操作（自导jar包），官网下载地址：点击打开链接 二、具体内容 2.1、数据库数据 2.2、UserVOMapper.xml 核心代码 &lt;select id="queryExportUser" resultMap="BaseResultMap"&gt; select * from user u &lt;/select&gt; 2.3、UserVOMapper.java 核心代码 List&lt;UserVO&gt; queryExportUser(); 2.4、service层代码（最重要） package com.gusy.muban.service; import java.util.List; import org.apache.poi.ss.usermodel.Cell; import org.apache.poi.ss.usermodel.CellStyle; import org.apache.poi.ss.usermodel.HorizontalAlignment; import org.apache.poi.ss.usermodel.Row; import org.apache.poi.ss.usermodel.Sheet; import org.apache.poi.ss.usermodel.Workbook; import org.apache.poi.xssf.streaming.SXSSFWorkbook; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import com.gusy.muban.dao.UserVOMapper; import com.gusy.muban.model.UserVO; /** * @author gusy */ @Service public class UserService { @Autowired private UserVOMapper mapper; /** * 导出excel * @throws Exception */ public Workbook queryExportUser() throws Exception{ List&lt;UserVO&gt; list=mapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fe03101452c0d0ef7b1b7aedfa27187/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db12810d8c70e366dc88227279b89c4b/" rel="bookmark">
			设置html网页只能在微信中打开，并禁用分享功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法：用js判断 (function () { /* begin禁用微信分享功能 */ function onBridgeReady() { WeixinJSBridge.call('hideOptionMenu'); } if (typeof WeixinJSBridge == "undefined") { if (document.addEventListener) { document.addEventListener('WeixinJSBridgeReady', onBridgeReady, false); } else if (document.attachEvent) { document.attachEvent('WeixinJSBridgeReady', onBridgeReady); document.attachEvent('onWeixinJSBridgeReady', onBridgeReady); } } else { onBridgeReady(); } /* end禁用微信分享功能 */ // 对浏览器的UserAgent进行正则匹配，不含有微信独有标识的则为其他浏览器 var useragent = navigator.userAgent; if (useragent.match(/MicroMessenger/i) != 'MicroMessenger') { // 这里警告框会阻塞当前页面继续加载 // 以下代码是用javascript强行关闭当前页面 var opened = window.open('about:blank', '_self'); /*opened.opener = null; opened.close();*/ } else{ window.alert = function(name){ var iframe = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db12810d8c70e366dc88227279b89c4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c0d2c682f1db699db2735bb63781a15/" rel="bookmark">
			Python之Numpy库常用函数大全（含注释）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 @[toc]-数组的维度变换-数组的类型变换-数组的运算-多维数据的存取 trick: 我将函数分好类别并设置好了目录，点击上方目录，可快速查找
前言：最近学习Python，才发现原来python里的各种库才是大头！ 于是乎找了学习资料对Numpy库常用的函数进行总结，并带了注释。在这里分享给大家，对于库的学习，还是用到时候再查，没必要死记硬背。
PS：本博文摘抄自中国慕课大学上的课程《Python数据分析与展示》，推荐刚入门的同学去学习，这是非常好的入门视频。
Numpy是科学计算库,是一个强大的N维数组对象ndarray，是广播功能函数。其整合C/C++.fortran代码的工具 ，更是Scipy、Pandas等的基础
.ndim ：维度
.shape ：各维度的尺度 （2，5）
.size ：元素的个数 10
.dtype ：元素的类型 dtype(‘int32’)
.itemsize ：每个元素的大小，以字节为单位 ，每个元素占4个字节
ndarray数组的创建
np.arange(n) ; 元素从0到n-1的ndarray类型
np.ones(shape): 生成全1
np.zeros((shape)， ddtype = np.int32) ： 生成int32型的全0
np.full(shape, val): 生成全为val
np.eye(n) : 生成单位矩阵
np.ones_like(a) : 按数组a的形状生成全1的数组
np.zeros_like(a): 同理
np.full_like (a, val) : 同理
np.linspace（1,10,4）： 根据起止数据等间距地生成数组
np.linspace（1,10,4, endpoint = False）：endpoint 表示10是否作为生成的元素
np.concatenate():
-数组的维度变换 .reshape(shape) : 不改变当前数组，依shape生成
.resize(shape) : 改变当前数组，依shape生成
.swapaxes(ax1, ax2) : 将两个维度调换
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c0d2c682f1db699db2735bb63781a15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58c1a1cba08975497156e29227091802/" rel="bookmark">
			教你如何搜索公众号中的文章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家早上好，假期结束又要回来上班了，不知道大家的五一假期都过得怎么样呢？今天是回来上班的第一天，就不推送什么复杂的技术文章了，而是给大家带来一篇实用的工具文章，相信可以给不少朋友带来帮助。
一直以来，都不断有朋友向我建议，为什么不在公众号里提供一个搜索功能呢？好多人都反馈，有时候想找一篇很早之前发过的文章非常痛苦，要从历史文章里面一页页去翻，翻了很久可能都还找不着。
对于这个情况我也深有感触，但问题在于，搜索这个功能并不是我想加就能加的，主要是微信公众号并不支持号内搜索这个功能。为了解决这个问题，我还特意在公众号主页菜单里面加入了一个分类浏览的功能，也是希望能在一定程度上方便大家查看历史文章。
不过一次偶然的机会，我了解到原来微信是支持公众号内文章搜索的，只不过需要一点特殊技巧才行。有了这个功能，就可以极大程度上解决查找历史文章困难的问题，我也是迫不及待地分享给大家。
首先在你的微信主页点击工具栏上的搜索按钮，会看到如下界面：
然后点击文章，界面如下所示：
在这里你要先输入你想搜索哪个公众号下的文章，比如说输入郭霖：
这样会在下方显示出你已关注的公众号，点击这个公众号，界面如下所示：
这里默认会按时间排序显示该公众号的历史文章，然后我们就可以在这里搜索任意内容了，比如说我想查找和RxJava相关的文章，只需要输入rxjava，结果如下所示：
就是这么简单，你学会了吗？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cacb2be5cddbc9ba78d11402a5b0999/" rel="bookmark">
			数据库中存储的是什么?数据库存取的是地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库到底存储的什么呢? 是具体的文件,音频,文档,表格,字段吗?
其实都不是.
数据库中存储的是地址,
比如用户想看视频，用户通过浏览器访问视频网站的网址，视频网站服务器解析用户浏览器的请求(url)，然后服务器访问视频网站的数据库服务器，从数据库服务器中得到该视频存放的地址（路径），然后返回给用户浏览器，用户浏览器再利用此地址访问该视频，即完成了一次查看视频的网络服务。
觉得简短易懂就关注我吧! m_wise
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f033ee5d3d93bee2ee21a961cd7d92ef/" rel="bookmark">
			[idea] 编译报错 javacTask:源发行版1.8 需要目标发行版1.8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误 在Idea2017.1中编译时发生如下的错误
Information:java: javacTask: 源发行版 1.8 需要目标发行版 1.8 Information:java: Errors occurred while compiling module 'suanfa' Information:javac 1.8.0_111 was used to compile java sources Information:Module "suanfa" was fully rebuilt due to project configuration/dependencies changes Information:2017/4/30 下午9:27 - Compilation completed with 1 error and 0 warnings in 1s 547ms Error:java: Compilation failed: internal java compiler error 解决 perferences -&gt; Build,Execution, Deployment -&gt; Compiler -&gt; Java Compiler 设置相应Module的 bytecode version即可 参考 Idea 编译报错 javacTask: 源发行版 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f033ee5d3d93bee2ee21a961cd7d92ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bb1d027346788cd4c9de0b3d1c1353e/" rel="bookmark">
			陈纪修老师《数学分析》 第01章：集合与映射 笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章介绍了集合和映射相关的基本概念，这是高中里已经学过的东西。集合与映射是现代数学的基本ABC术语，喜欢数学的朋友，可以从这一章开始高等数学的学习。
知识点如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf21723666602bf19789666c8af2142d/" rel="bookmark">
			CentOS7 使用 yum 安装 chrome
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS7 使用 yum 安装 chrome 1、下载 rpm 包 搜索 “Google Chrome for Linux 下载” 得到:
例如：http://down.tech.sina.com.cn/page/43719.html
2、用 yum 安装 yum localinstall google-chrome-stable_current_x86_64.rpm yum会自动分析依赖，完成安装
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/628d4089365aad36f88f37c5884ee833/" rel="bookmark">
			浅谈曲面参数化---顾险峰（老顾谈几何）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浅谈曲面参数化 - 算法和理论 （I） 浅谈曲面参数化 - 算法和理论 （II） 浅谈曲面参数化 - 算法和理论 （III） 浅谈曲面参数化 - 算法和理论 （IV） 浅议形状空间的几何方法
调和映照函数 调和映照漫谈 I 调和映照漫谈 II 调和映照漫谈 III
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/550a0cc2558b95178662b014c5f0ab3b/" rel="bookmark">
			eclipse中svn同步失败，cleanup无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		org.apache.subversion.javahl.ClientException:Previous operation has not finished。 org.apache.subversion.javahl.ClientException: ϵͳÕҲ 遇到一个简单的问题，在eclipse中同步代码时，报错org.apache.subversion.javahl.ClientException，无法同步。根据百度得到的方法，去cleanup，没用。还报了一些乱码，本来以为是eclipse的工程编码设置有问题，改了还是不行。最终只好一行行的看报错，最终解决了，记录一下。 现在找不到之前的报错了，当时确实是Refresh/Cleanup都没作用，报错确实和网上的大多数描述的一致，解决方式也都建议Refresh/Cleanup一下，不过没用，还报了乱码错误，提示找不到文件“D:\workspace\jupiter-server\.svn……”，当时没记录，现在只有这些了。
当时还发现，有的工程是可以team-同步的，有的工程却不可以，只好去D盘我的workspace打开各个工程的.svn文件对比，结果发现，少了一个“temp”的空文件夹，新建了一个放进去，再去eclipse同步就没问题了。
坑爹的是，今天晚上又试了一次，发现删掉这个文件也无所谓，搞不明白这个文件夹的作用，一直都是空文件夹。暂时标记。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6fcc013f6ac51e5d93f27c08da6f338/" rel="bookmark">
			ResNet-TensorFlow Model Zoo代码理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ResNet自从15年问世以来迅速影响了CNN的发展，主要得益于ResNet的shortcut结构能够避免网络的退化（即传统的CNN随着网络深度的 增加会出现训练误差和测试误差增大的情况）和梯度消失/爆炸现象，使得ResNet能够从网络层数的加深中受益，这也是为什么ResNet 能够做到34层，50层，甚至152层，甚至是1202层的缘故。原文中提供了几个通用的网络结构：
本文分析GitHub上面的TensorFlow提供的官方ResNet的TensorFlow实现程序，讲解网络在TensorFlow中的代码构成。
首先这是对ResNet在Cifar10和Cifar100数据库的一个复现，也就是说TensorFlow官方提供的这一版ResNet程序是用来进行Cifar的分类任务的。代码地址：https://github.com/tensorflow/models
cifar_input.py（https://github.com/tensorflow/models/blob/master/resnet/cifar_input.py） 用来读取Cifar数据库中的图片数据和标注信息的，这里不做过多讲解，如果想要把ResNet改为回归任务或者是训练自己的数据库，则需要对数据输入进行重写（如果是回归任务，那么网络的结构也需要修改（去掉Softmax层）
resnet_model.py（https://github.com/tensorflow/models/blob/master/resnet/resnet_model.py） 构造了ResNet这个类（Class),定义了ResNet的网络结构、loss等。
首先_build_model()函数定义了网络的核心结构，代码如下：
def _build_model(self): """Build the core model within the graph.""" with tf.variable_scope('init'): #init层将图片的3通道变为16通道feature map输出 x = self._images x = self._conv('init_conv', x, 3, 3, 16, self._stride_arr(1)) #3*3的卷积层，16通道输出 strides = [1, 2, 2] #后面两个2的stride用来降采样 activate_before_residual = [True, False, False] if self.hps.use_bottleneck: res_func = self._bottleneck_residual #bottleneck结构，包含三个卷积子层 filters = [16, 64, 128, 256] else: res_func = self._residual #非bottleneck结构（包含两个3*3的卷积子层） filters = [16, 16, 32, 64] # Uncomment the following codes to use w28-10 wide residual network.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6fcc013f6ac51e5d93f27c08da6f338/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23294d5ba17bae75016f4a04ed5bb1fe/" rel="bookmark">
			理解密码学中的双线性映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回顾 - 什么是群 一、定义 定义1 设G是定义了一个二元运算+的集合，如果这个运算满足下列性质： （1）封闭性——如果a和b都属于G，则a+b也属于G。
（2）结合律——对于G中的任意元素a、b和c，都有（a+b）+c=a+（b+c）成立。
（3）单位元——G中存在元素e，对于G中任意元素a，都有a+e=e+a=a成立。
（4）逆元——对于G中任意元素a，G中都存在元素a'，使得a+a'=a'+a=e成立。G就叫作一个群，记为（G，+）。
如果这里的运算+是加法运算，则称G为加法群；如果这里的运算+是乘法运算，则称G为乘法群。如果一个群中的元素是有限的，则称这个群是一个有限群；否则称这个群是一个无限群。有限群中元素的个数称为群的阶。
例：集合｛0，1｝关于xor运算是群，阶为2 封闭性：0 xor 1 = 1属于该群 结合律：（0 xor 1）xor 0 = 1 = 0 xor （1 xor 0） 单位元为0：0 xor 0 = 0，0 xor 1 = 1 逆元为1：1 xor 0 = 1，1 xor 1 = 0 又如：自然数集合N=｛1，2，3…｝对于通常的加法封闭且满足结合律，但不存在左单位元和左逆元，因此对于加法不是群。
如果群（G，+）中的运算+还满足交换律，即对G中的任意元素a和b，都有a+b=b+a成立，则称G为一个交换群或Abel群，例如整数关于加法的运算（Z，+）就为交换群。
在群中定义求幂运算为重复使用群中的运算，如a4=a+a+a+a。规定a0=e为单位元。如果一个群的所有元素都是a的幂ak，则称这个群是一个循环群，这里的k是整数。a也被称为这个群的生成元。
例：整数加法群是一个循环群，1是生成元，每一个元素都是1的幂，如： 4=14=1+1+1+1 -3=1 -3=（-1）+（-1）+（-1） 而且规定0=1 0，即0为0个1相加。
（注：定义中的“+”并不代表具体的加法，而是抽象的加法——代表一种代数运算）
定义2 给定群G中元素a，称满足ai=e的最小正整数i为元素a的阶。
二、群的基本性质 （1）左逆元同时也是右逆元，即对于a，b∈G，b+a=e，则a+b=e。 （2）左单位元同时也是右单位元，即如果对于所有的a∈G有ea=e，则对于所有的a∈G也有ae=e。
（3）单位元是唯一的。
（4）逆元是唯一的。
双线性映射 抽象意义的双线性映射描述如下：
设G1、G2都是阶为p的循环群，p是素数。如果映射e: G1 × G1 → G2 满足以下性质： （1）双线性性。 对于任意a，b∈Zp和R，S∈G1，有e(Ra, Sb) = e(R, S)ab；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23294d5ba17bae75016f4a04ed5bb1fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bea3e3f425a8eb63c24be02af8ca4d1e/" rel="bookmark">
			WBMP图片格式和转换JPEG方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 Wireless Bitmap（WBMP）是一种移动设备使用的图像格式。这种格式被用于Wireless Application Protocol（WAP）网页中。 WBMP只支持1位颜色，即WBMP图像只包含黑色和白色像素。 WBMP格式 WBMP文件开头是"Header" 头部。Header的第一个字节表示图片类型，目前只有0，即非压缩的黑白位图。第二个字节固定为0。 第三个字节开始，分别是图像的宽度和高度。宽度和高度都使用多字节整数格式存储，见下文。 紧接着是图像数据，每一个bit表示一个象素：1白，0黑。 一个Wbmp文件结构如图： 多字节整数：一个多字节整数由一个或多个字节构成，每个字节的左边第一位表示后边的字节是否为当前整数的一部分。 如果当前字节的左边第一位为0，表示后面没有更多的字节了，该多字节整数结束； 如果当前字节的左边第一位为1，表示后边的字节也用来构成该多字节整数。 WBMP图片处理和转换 获取Wbmp图片的宽高，转换为jpeg图片： public void test() throws Exception {
String fileName = "/tmp/WBMP.wbmp";
getWbmpWH(fileName);
convertWbmp2Jpeg(fileName, "/tmp/wbmp.jpg");
}
// 获取Wbmp图片的宽高 public void getWbmpWH(String wbmpName) throws Exception {
File wbmp = new File(wbmpName);
byte[] datas = FileUtils.readFileToByteArray(wbmp);
byte tmp;
int width = 0, height = 0, offset = 2;
do {
tmp = datas[offset++];
width = (width &lt;&lt; 7) | (tmp &amp; 0x7f);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bea3e3f425a8eb63c24be02af8ca4d1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28a8e23da4f9f4b84c2765e669d64969/" rel="bookmark">
			消息中间件-activemq入门(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一节我们了解了JMS规范并且知道了JMS规范的良好实现者-activemq。今天我们就去了解一下activemq的使用。另外我们应该抱着目的去学习，别忘了我们为什么要使用消息中间件：解耦系统之间的联系，同步或异步的消息传输，尤其是异步的消息传输，分布式环境下，可靠、高效的消息传输，可以保证消息的重发性和顺序性。即解决业务系统比较多或者是分布式环境下的系统之间安全有效通信的问题，带着这样的目的我们来学习消息中间件就有了方向。
1. 为什么用activemq 在设计分布式应用程序时，应用程序间的耦合（或称集成）方式很重要。耦合意味着两个或者多个应用程序或系统的相互依赖关系。一种简单的方式是在所有的应用程序中从架构上设计他们与其他应用程序间的交叉实现。这样必然导致，一个应用程序的改变，直接导致另一个应用程序的改变。
ActiveMQ采用松耦合方式，应用程序将消息发送给ActiveMQ而并不关心什么时间以何种方式消息投递给接收者。同样的，消息接收者也不会关心消息来源于哪里和消息是怎样投递给ActiveMQ的。对于多语言编写的复杂应用环境中，允许客户端使用不同的编程语言甚至不同的消息包装协议。ActiveMQ作为消息的中间件，允许复杂的多语言应用程序以一种一步的方式集成和交互。所以说，ActiveMQ是一种好的，提供松散耦合的，能够为多语言交叉应用提供集成的中间件。
2. 什么时候用activemq ActiveMQ的设计目标是提供标准的，面向消息的，能够跨越多语言和多系统的应用集成消息通信中间件。大多数情况下ActiveMQ被用于做系统之间的数据交换。
只要是两个应用程序间需要通信的情况，都可以考虑使用JMS，不论这种通信是在本地的（就是通信的两个应用程序在同一台主机上），还是分布在不同机器上。尽管是在同一个主机上的两个应用程序需要通信也可以使用ActiveMQ。ActiveMQ可以确保消息投递成功并采用异步方式通信。
3. activemq特性 支持JMS规范：ActiveMQ完全实现了JMS1.1规范。
连接方式的多样化：ActiveMQ提供了广泛的连接模式，包括HTTP/S、JGroups、JXTA、muticast、SSL、TCP、UDP、XMPP等。提供了如此多的连接模式表明了ActiveMQ具有较高的灵活性。
与其他的Java容器紧密集成：ActiveMQ提供了和其它流行的Java容器的结合，包括Apache Geronimo、Apache Tomcat、JBoss、Jetty等。
客户端API：ActiveMQ提供了多种客户端可访问的API，包括Java、C/C++，.NET，Perl、PHP、Python、Ruby等。当然，ActiveMQ中介必须运行在Java虚拟机中，但是使用它的客户端可以使用其他的语言来实现。
中介集群：多个ActiveMQ中介可以一起协同工作，来完成某项复杂的工作，这被称为网络型中介（network of brokers），这种类型的中介将会支持多种拓扑类型。
4. 使用activemq 首先我们去apache上下载activemq，点此下载。
接下来我是使用maven来管理jar的，如果你不用maven的话就去刚下载的activemq包中找到jar包导入即可。maven引入jar：
&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-all&lt;/artifactId&gt; &lt;version&gt;5.14.5&lt;/version&gt; &lt;/dependency&gt; 然后我们进入刚下载的activemq，我进入的路径如下：apache-activemq-5.14.5-bin\apache-activemq-5.14.5\bin\win64\activemq.bat ,我用的是64位的系统，如果你是32位的同理进入相应文件夹下点击activemq.bat启动activemq客户端，启动完成之后，直接访问ActiveMQ管理页面http://localhost:8161/admin/ 默认用户名密码admin/admin。
客户端界面如下：
接下来该我们写代码的时候了，首先我们还是先写一个P2P(点对点)模式的客户端。代码如下：
Sender.java
import javax.jms.Connection; import javax.jms.ConnectionFactory; import javax.jms.DeliveryMode; import javax.jms.Destination; import javax.jms.MessageProducer; import javax.jms.Session; import javax.jms.TextMessage; import org.apache.activemq.ActiveMQConnection; import org.apache.activemq.ActiveMQConnectionFactory; import java.io.BufferedReader; import java.io.InputStreamReader; public class Sender { public static void main(String[] args) { //ConnectionFactory是连接工厂，JMS用它创建连接 ConnectionFactory connectionFactory; //Connection JMS客户端到JMS provider的连接 Connection connection = null; //Session 一个发送或者接收消息的线程 Session session; //Destination 消息发送目的地，消息发送给谁接收 Destination destination; //MessageProducer 消息发送者 MessageProducer messageProducer; //构造ConnectionFactory 实例对象，此处采用ActiveMQ的实现jar connectionFactory = new ActiveMQConnectionFactory( ActiveMQConnection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28a8e23da4f9f4b84c2765e669d64969/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f6181e63ba8ba0cc61ef365623b4ee4/" rel="bookmark">
			vue2 前后端分离项目ajax跨域session问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近学习使用vuejs前后端分离，重构一个已有的后台管理系统，遇到了下面这个问题：
实现跨域请求时，每次ajax请求都是新的session，导致无法获取登录信息，所有的请求都被判定为未登陆。
1、 vuejs ajax跨域请求 最开始使用的是vue-resource，结果发现vue2推荐的是axios，于是改成axios；
安装axios
npm install axios -S 安装完成后在main.js中增加一下配置：
import axios from 'axios'; axios.defaults.withCredentials=true; main.js全部配置如下：
import Vue from 'vue' import App from './App.vue' import ElementUI from 'element-ui' import 'element-ui/lib/theme-default/index.css' import router from './router'; import axios from 'axios'; import './assets/css/main.css' import './assets/css/color-dark.css' //开启debug模式 Vue.config.debug = true; axios.defaults.withCredentials=true; Vue.prototype.$axios = axios; Vue.use(ElementUI); new Vue( { router, el: '#app', render: h =&gt; h(App) } ).$mount('#app') 在XXX.vue文件中具体使用如下：
&lt;template&gt; &lt;el-col :span="4" style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f6181e63ba8ba0cc61ef365623b4ee4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/956faa3c5f4492ebb71b13eac9f6ef54/" rel="bookmark">
			《Towards Viewpoint Invariant 3D Human Pose Estimation》--深度图领域人体姿态估计的CNN算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Towards Viewpoint Invariant 3D Human Pose Estimation》–深度图领域人体姿态估计的CNN算法
这篇文章是ECCV 2016的一篇3D人体姿态估计的文章，一作Albert Haque是Li FeiFei的学生，出自Stanford University。 本文从视角变化作为切入点，研究了深度图领域的3D人体姿态估计任务，自从2011年Shotton, J等人在[Real-time human pose recognition in parts from single depth images. In: CVPR (2011)]中提出随机森林算法以来，该算法以及随后衍生的包括random tree walk系列算法基本上将深度图领域的人体姿态估计任务做到了非常高的水准，微软的Kinect深度相机自带SDK的骨骼提取算法用的就是随机森林算法，该算法的最大优点就是快，实时性要求完全能够得到满足，商业化的应用毫无疑问的证明了该算法的成功。然而CNN的崛起几年之内迅速攻占CV、NLP等领域各个任务，取得了巨大的成功，CNN的优势是大数据的训练支持（当然还有NVIDIA的GPU）以及其本身所具有的强大的非线性拟合能力。本文采用了一个CNN+RNN的逐步refine的网络结构，通过不同视角（Side和Top）的数据进行训练，试图利用CNN的深层次特征来解决视角变化条件下的自遮挡等问题。本文中一个大的贡献是提供了一个大约100K带有标注的深度图数据库（https://www.albert.cm/projects/viewpoint_3d_pose/），这对于一些需要用到深度图做姿态估计等任务的人还是很有帮助的。
一：简介 文中先分析了目前人体姿态估计领域的研究现状：大都以正面视角或者侧面视角的图片进行分析，这虽然提高了精度，但却没能够做到抗视角变化（viewpoint variances）。事实上很多场合下，比如机场、医院、零售店，大都不能获得一个正面或者侧面的理想视角，因而如果考虑实用性的话，viewpoint variances就是一个必须要解决的问题。 解决视角变化的问题主要有两个障碍： 1、模型必须能够同时理解局部和全局信息，也就是说模型必须要具有bottom-up的判别方法所能提供的细节信息和top-down的生成方法所能提供的全局信息。 2、目前存在的depth数据库都比较小，包括数据库尺寸和数据类别。这就使得包括表征学习（representation learning）和viewpoint transfer techniques的技术的使用受到了很大限制。 本文提出了通过投射局部姿态信息到一个预训练的具有视角不变特性的特征空间的方法，并且采用了误差迭代反馈的思想，分stage逐步refine的网络结构。最后，本文提出了一个100K的depth数据库，并且在这个数据库和之前的一个公共数据库EVAL上面取得了state-of-art的效果。
二：模型 输入一张单深度图，分stage迭代refine，每一个stage包含两个输入，即原图处理生成的一个patch（称为Glimpses）和之前生成的估计姿态。模型预测输出的实际上是一个位置的偏移量和一个可见性蒙版。 模型细节： 输入表达：模型的输入图片并不直接输送到网络中去，而是通过提取图片中的不同的patches，并且将其转化成为Glimpses，Glimpse是一种对原始输入的特殊编码形式，它的中心分辨率高，周围分辨率逐渐降低，这就使得中心的特征得到重点的学习，同时又保留了部分空间信息。 Embedding：对于上面所说的通过投射局部姿态信息到一个预训练的具有视角不变特性的特征空间，本文实际上是利用了一个STN（spatial transformer networks）的结构，具体见下图：
对于一个输入的Glimpse，通过一个3D的STN网络（具体细节参见文章Spatial transformer networks. In: NIPS (2015)）得到一个3D的特征表达V并映射回到二维空间得到一个新的Embedding作为卷积网络的输入（U）。 CNN+RNN网络结构：将前面得到的特征表达U组成一个H×W×J（J代表Joints，即关节点的数量）的tensor输入到卷积网络中去，由于直接从全连接层回归出关节点的实际位置非常困难（这是一个高度非线性映射的过程），本文借鉴了这篇文章的思路：Human pose estimation with iterative error feedback. In: CVPR (2016)，提出了一个分Stage逐步refine的结构，并且不同于借鉴的这篇文章，本文将两次迭代的结果用RNN的LSTM结构连接起来以增强时序信息的关联性。
三：loss和训练 由于视角变化所带来的遮挡问题对于人体姿态估计是个很大的困扰，本文将这个任务视为一个多任务学习问题，具体地，本文将整个模型优化问题分为两个步骤来做： 1、关节检测： 这一部分的任务是判断哪些关节是可见的，哪些关节受到了遮挡。这部分任务可以表示为模型中的可见性蒙版 α ，这是一个1×J的向量，如果预测得出的关节点是可见的，则 α 为1，否则为0。 α 是由LSTM生成的一个未归一化的概率经过Softmax得到的。这部分的检测损失是一个交叉熵的形式： 2、关节回归 这一部分的任务是输出关节点的偏移量信息，也就是实际的关节点位置信息。训练的时候只希望训练可见的关节点，因此，损失函数的表达形式为： 其中仅当 α =1时，才计算损失以更新权重。 全局损失可以表示为上面两项之和： 训练的时候是一个端到端的优化过程，CNN+RNN的结构从头开始训练，优化器采用的是Adam optimizer，学习率设为1+e-5， β(1) =0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/956faa3c5f4492ebb71b13eac9f6ef54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6c080efbebf449f02270728b39b6ce6/" rel="bookmark">
			解决 MUI QQ登陆功能报错“该应用非官方正版应用，请到......100044”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现这个问题的原因是我第一次打包的时候使用的是自有证书，然后去qq互联申请移动应用时填写的签名也是自有证书的。
问题来了，我在后面打包的时候用的都是DCloud公用证书。然后去登陆的时候就报100044这个错误了。
然后我又用自用证书打包，去登陆， OK登陆成功。。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ada91ff2cc95c901de1b7d8e202155c/" rel="bookmark">
			C#的补充数据类型System.Numerics.dll
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、System.Numerics.dll简介 创建一个C#项目，然后手动添加这个引用，并且添加usingSystem.Numerics；命名空间，这个命名空间中包含了一些结构体，用来表示一些比较复杂的数据类型，如下所示
注意：上面所说的“单精度浮点数” 指的就是Single结构，它实际上是 float的包装，double的包装为Double,但是float的包装不是Float 而是Single 。
下面我以几个简单的例子进行说明，没有对每一个结构体都说明，详细信息可以自己查看定义
1、Plane结构体
Plane plane = new Plane(3, 3, 3, 5);
Console.WriteLine($"{plane.D} {plane.Normal}");
结果为：5 &lt;3,3,3&gt;
2、Vector3结构体
Vector3 vector = new Vector3((float)100.1, (float)200.2, (float)300.3);
Console.WriteLine($"{vector.X} {vector.Y} {vector.Z} ");
Console.WriteLine($"{Vector3.One}");
Console.WriteLine($"{Vector3.Zero}");
Console.WriteLine($"{Vector3.UnitX}");
Console.WriteLine($"{Vector3.UnitY}");
Console.WriteLine($"{Vector3.UnitZ}");
得到的结果如下：
100.1 200.2 300.3
&lt;1, 1, 1&gt;
&lt;0, 0, 0&gt;
&lt;1, 0, 0&gt;
&lt;0, 1, 0&gt;
&lt;0, 0, 1&gt;
详细信息呢可以参见文档，因为内容较多，这里就不一一列举出来了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37f29cc01d535d151287a1b793bcf4cb/" rel="bookmark">
			学习PLC编程的2个简单方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有的初学者在理论上花了很多功夫，结果半年下来还是没有把 PLC搞懂，其实他们只是缺少了一些 PLC的实践经验，只要再进行一些实际的梯形图编写、程序下载、调试等操作，增加对 PLC的感性认识，很快就可以掌握 PLC这项技术了。开始阶段可以先学习一种品牌的PLC，因为所有的PLC原理都是差不多的，掌握了一种PLC其它的只要翻阅一下手册也就能上手使用了。 初学时可以编一些简单的梯形图，如触点的与、或、输出等，在PLC的机器里运行一下。成功了就会增加你学习的兴趣、和信心。然后再把PLC的主要功能逐个运用一次，比如高速计数器，你可以用PLC本身的脉冲输出端接到高速计数器的输入端，下载编好的梯形图，打开变量观察窗口，运行程序，观察计数的值是否正确。经过了这样的实践，你基本上知道PLC到底能做哪些事情了，在实际的工控应用中就能做到胸有成竹了。 1．学习PLC的理由 PLC控制是当今自动化控制的主流，目前自动化机台控制大多采用PLC控制，只要是从事自动化的人员，就必须要会使用PLC，否则入不了自动化控制的门，被自动化行业淘汰。为此不得不学习PLC。 2．方法 a．有条件的最好去买台PLC用来实践； b．PLC技术是一门实践性非常强的技术，如果你想学好，那么你就必须去实践它。编程就像是一位习武之人，如果只是整天坐在家中看拳谱，不出门练武的话，那么就是一本再厉害的武林密集，再长的时间他的功力也不会提高。学习PLC也是同样的道理，光看书是没有用的，一本PLC书您就是看了十遍以后您还是不会用，学过编程(不管什么语言)的都知道。 c．在学习PLC书本知识的过程中，肯定会对许多指令不是很了解，如果您没有一一解决的话，那么这将是您学习PLC的最大障碍。因此进行实际应用，逐一攻破，这样，你的PLC知识不但会学得牢固，而且在学习的过程中你掌握了实际使用。 d．在学习 PLC有了一定的基础之后，可以自己独立编写一段自己设计的程式，然后传送到 PLC中去运行程式。再经过不断的修改，调试，最后运行成功，这样你的兴趣会大增，达到满意的效果。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7fef4ae4776143ebdfdbf89e21b1eb0/" rel="bookmark">
			JSP页面，脚本标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/
&lt;%@ page language="java" contentType="text/html; charset=GB18030"
pageEncoding="GB18030"%&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=GB18030"&gt;
&lt;title&gt;使用文件包含include指令&lt;/title&gt;
&lt;/head&gt;
&lt;body style="margin:0px;"&gt;
&lt;%@ include file="top.jsp"%&gt;
&lt;table width="781" height="279" border="0" cellpadding="0" cellspacing="0" background="images/center.JPG"&gt;
&lt;tr&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;%@ include file="copyright.jsp"%&gt;
&lt;/body&gt;
&lt;/html&gt;
//
通过代码片段和JSP表达式在JSP页面中输出九九乘法表
&lt;%@ page language="java" contentType="text/html; charset=utf-8"
pageEncoding="utf-8"%&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;%
String str = ""; //声明保存九九乘法表的字符串变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7fef4ae4776143ebdfdbf89e21b1eb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/971b8b77fee6fefbe5057538304b4f4e/" rel="bookmark">
			C&#43;&#43; 移动构造与移动赋值运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，左值与右值
1，左值与左值引用
左值是一个表示数据的表达式，程序可以获取其地址。左值可以出现在赋值语句的左边，也可以出现在赋值语句的右边。左值引用就是对左值的引用。下面的变量都是左值
int a = 20; const int b = 10; int c = b; 2，右值与右值引用
右值即可出现在赋值表达式右边，但不能获取其地址。右值包括字面常量（C风格字符串除外，它表示的是地址），诸如x + y表达式以及返回值的函数（条件是该函数返回的不是引用）。C++11新增了右值引用，这是使用&amp;&amp;表示的，右值引用就是对右值的引用。下面的是右值的例子
int getValue(){ return 50; } int main(){ int x = 10; int y = 20; int &amp;&amp;r1 = 30; //字面常量是右值 int &amp;&amp;r2 = x + y; //表达式是右值 int &amp;&amp;r3 = getValue(); //函数返回的是int类型的值 return 0; } 二，为何需要移动语义？
我们定义了下面这个Useless类
class Useless{ private: string name; char *p; public: Useless(); Useless(string name); Useless(const Useless &amp;f); Useless operator+(const Useless &amp;f) const; void showData(); ~Useless(); }; 定义一个函数这个函数的返回值是Useless类对象
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/971b8b77fee6fefbe5057538304b4f4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09833c2383e778d6e407f0adfaf21ecb/" rel="bookmark">
			input输入框清除插件，极好用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不BB别的了，直接上干货，很容易看懂，自己上手测试吧 clearInput.js插件代码： (function () { document.addEventListener('DOMContentLoaded', function () { var autoClearFiled = document.querySelectorAll('.am-input-autoclear'); //重点,与“HTML中重点1”对应，获取所有class为.am-input-autoclear的元素 if(autoClearFiled){ Array.prototype.forEach.call(autoClearFiled, function (elem) { var clearTrigger = elem.querySelector('.am-icon-clear'); //重点，与“HTML中重点2”对应，获取当前的class元素,监听事件 clearTrigger.style.visibility = 'hidden'; //隐藏 删除图标 var clearInput = elem.querySelector('input[type="text"],input[type="password"],input[type="number"],input[type="tel"],input[type="email"],input[type="url"],input[type="search"]'); if (clearTrigger &amp;&amp; clearInput) { clearTrigger.addEventListener('touchstart', function () { clearInput.value = ''; clearInput.focus(); clearTrigger.style.visibility = 'hidden'; }, false); clearTrigger.addEventListener('click', function () { clearInput.value = ''; clearInput.focus(); clearTrigger.style.visibility = 'hidden'; }, false); clearInput.addEventListener('focus', function () { clearTrigger.style.visibility = (clearInput.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09833c2383e778d6e407f0adfaf21ecb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ababe290cce003e019aec9fd58e1ed75/" rel="bookmark">
			C&#43;&#43;:xutility文件中发生错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在写程序中途测试时，突然多出一堆语法错误，且来源于xutility文件。 打开xutility文件，其中定义了许多结构体以及函数模板。在其中找错误源是找不到的，因为全是类似于缺少;之类的错误。于是回退之前写的代码，终于发现问题所在：在全局定义了一个distance函数，然后这个distance函数与一个函数模板重名，加之调用的时候传入参数类型不符全局定义函数的类型，进行了模板展开，但是又没有定义该类型的模板函数，于是导致错误。 修正方法： 1 . 换掉函数名，参数类型出错会报错正确位置 2 . 使用作用域，防止参数类型不当引起的歧义
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8f324271fd35f4cb11c0b13a66b183c/" rel="bookmark">
			go json解析Marshal和Unmarshal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go语言提供一个json解析的包。见 http://golang.org/pkg/encoding/json/
官方同时提供了一篇文章 JSON and Go 讲述json包的用法， 该文章同时存在中文翻译： JSON与Go 。
看过上述两篇文章后，基本使用应该就没问题了。
同时，贴几个官方的例子，方便理解。 Decoder package main import ( "encoding/json" "fmt" "io" "log" "strings" ) func main ( ) { const jsonStream = ` { "Name" : "Ed" , "Text" : "Knock knock." } { "Name" : "Sam" , "Text" : "Who's there?" } { "Name" : "Ed" , "Text" : "Go fmt." } { "Name" : "Sam" , "Text" : "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8f324271fd35f4cb11c0b13a66b183c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72fa580e5112bbf25bc2d43107a3f2d8/" rel="bookmark">
			VS&#43;QT出现错误：LNK1120与LNK2019
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在VS配置了QT的环境中运行QT程序时，可能会出现如下错误：
error LNK1120：1个无法解析的外部命令 error LNK2019：无法解析的外部符号
如下图所示：
分析：此种错误可能是关联的信号与槽不一致造成的，一种情况可能是有的槽为空，其找不到对应的信号，所以报错。
解决方法：注释掉空的槽，然后重新运行OK！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64baaf5e621ed3569d1dd9d2c9f767db/" rel="bookmark">
			mysql开启GTID跳过错误的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、数据库版本
mysql&gt; select version()
-&gt; ;
+-------------------------------------------+
| version() |
+-------------------------------------------+
| 5.7.17 |
+-------------------------------------------+
1 row in set (0.00 sec)
--主从同步
10.10.6.87 主
10.10.90 从
2、产生问题过程
（1）主从库开启了GTID模式
（2）在从库某表添加了唯一索引，然后去主库给某表添加索引，导致问题 （此处为了测试，故意为之，制造问题）
'Duplicate key name 'i_index'' on query. Default database: 'test'. Query: 'create unique index i_index on t(id)' （3） 查看从库状态，发现Slave_SQL_Running: No mysql&gt; show slave status \G; *************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 10.10.6.87 Master_User: rep Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64baaf5e621ed3569d1dd9d2c9f767db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72abc9e0df1edb3affe7b8362145dfcf/" rel="bookmark">
			Java 1.8 HashMap 源码中 put()方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在jdk1.7的时候，hashmap底层结构就是数组+链表的结构，如果发生冲突，即hashcode相同key也相同，但是value不同的话，那么就会放在底层数组的同一个下标处，官方话叫同一个桶内，以链表的形式保存。
但是在jdk1.8后就修改这么个存储方式，变成了数组+链表+红黑树的结构。我就暂时不讨论他红黑树部分是怎么实现的。我就先看看这个put（）方法具体是怎么执行的。
因为源码中写if的时候，如果括号内就一句话，他就把大括号给省略了，我表示我这么看源码，是相当的不习惯。虽然，他是源码，这么做是考虑到效率问题。
我为了代码看起来舒服点，我就把代码复制出来，大括号该加的加，该格式化的格式化。
然后，再加上详细的注释，方便理解他jdk1.8的源码。
能来看1.8源码的，那估计对1.7以及以前的可能有点了解。
public V put(K key, V value) { return putVal(hash(key), key, value, false, true); }然后是详细的put（）方法的代码 /** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value(put 传 false) * @param evict if false, the table is in creation mode.(put 传 true) * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; //缓存底层数组用,都是指向一个地址的引用 Node&lt;K,V&gt; p; //插入数组的桶i处的键值对节点 int n; //底层数组的长度 int i; //插入数组的桶的下标 //刚开始table是null或空的时候，初始化个默认的table；为tab和n赋值，tab指向底层数组，n为底层数组的长度 if ((tab = table) == null || (n = tab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72abc9e0df1edb3affe7b8362145dfcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e133c6532b7ee81f3e76362e46a2a06e/" rel="bookmark">
			tf.cast
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 cast(x, dtype, name=None)
将x的数据格式转化成dtype.例如，原来x的数据格式是bool，
那么将其转化成float以后，就能够将其转化成0和1的序列。反之也可以
a = tf.Variable([1,0,0,1,1]) b = tf.cast(a,dtype=tf.bool) sess = tf.Session() sess.run(tf.initialize_all_variables()) print(sess.run(b)) #[ True False False True True] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f82ea8793ef28c23ff79a05d2a52e2e/" rel="bookmark">
			Android进阶UI之ImageView设置长度高度为wrap_content时高度根据图片比例自适应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 示例 &lt;ImageView android:id="@+id/img_1" android:layout_width="fill_parent" android:layout_height="wrap_content" android:adjustViewBounds="true" android:scaleType="centerInside" android:src="@drawable/img_bg" /&gt; 网络上下载下来的图片自适应：android:adjustViewBounds=“true”（其详细解释在下面）
&lt;ImageView android:id="@+id/dynamic_item_image" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="top" android:layout_marginTop="5dip" android:adjustViewBounds="true" android:background="@drawable/imageview_background" /&gt; 另外，android:background="@drawable/imageview_background"是给图片加了一个边框，其中imageview_background.xml:
&lt;?xmlversion="1.0" encoding="utf-8"?&gt; &lt;shape xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;solid android:color="@color/white"/&gt; &lt;padding android:left="5.0dip" android:top="5.0dip" android:bottom="5.0dip" /&gt; &lt;/shape&gt; 2 ImageView属性说明 2.1 类概述 显示任意图像，例如图标。ImageView类可以加载各种来源的图片（如资源或图片库），需要计算图像的尺寸，比便它可以在其他布局中使用，并提供例如缩放和着色（渲染）各种显示选项。
2.2 XML属性 2.3 scaleType独立解析 2.3.1 代码示例 // scaleType属性既可以在 XML 中设置，也可以在代码中设置 android:scaleType="centerInside" //XML中 imageView.setScaleType(ImageView.ScaleType.CENTER_INSIDE); //代码中 2.3.2 八个ScaleType，其实可以分为三个类型： （1）以FIT_开头的4种，它们的共同点是都会对图片进行缩放；
（2）以CENTER_开头的3种，它们的共同点是居中显示，图片的中心点会与ImageView的中心点重叠；
（3）ScaleType.MATRIX，用矩阵来绘图。
2.3.3 ScaleType类型 （1）ScaleType.FIT_CENTER——默认：图片会被等比缩放到能够填充ImageView的宽高，并居中展示。（因为图片宽大于高，被缩放到ImageView的宽高并居中展示，上下会留白；如果图片的高大于宽，居中显示就会在左右留白。）
（2）ScaleType.FIT_START：图片等比缩放到ImageView大小，并放置在ImageView的上边或左边展示。（因为图片宽大于高，下半部分留白；如果图片高大于宽，右半部份留白。）
（3）ScaleType.FIT_END：图片等比缩放到ImageView宽高，并放置在控件的下边或右边展示。（因为图片宽大于高，上半部分留白；如果图片高大于宽，左半部分留白。）
（4）ScaleType.FIT_XY：不按比例拉伸图片完全填充ImageView的宽高。
（5）ScaleType.CENTER：不使用缩放，按原图展示图片；如果图片宽高小于ImageView的宽高，那么图片会被居中显示。
（6）ScaleType.CENTER_CROP——常用模式：按比例放大原图直至某边ImageView的宽高展示。
（7）ScaleType.CENTER_INSIDE：当原图的宽或高等于ImageView的宽或高时，按原图大小居中展示；反之将原图缩放至ImageView的居中展示。（当图片大于ImageView的宽或高的，效果与ScaleType.FIT_CENTER的效果相同；如果图片是小于ImageView大小，会出来这两个模式下的差别，如两种模式下的第二个图。）
（8）ScaleType.MATRIX：需要与ImageView.setImageMatrix(Matrix matrix) 配合使用，因为该模式需要用于指定一个变换矩阵用于指定图片如何展示。其实前面的7种模式都是通过ImageView在内部生成了相应的变换矩阵，等于是提供了该模式的一种特定值，使用这个模式只要传入相应矩阵，也就能实现上述七种显示效果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f82ea8793ef28c23ff79a05d2a52e2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e80db4aa0d82991d6b8346d039c7f94/" rel="bookmark">
			VirtualBox 虚拟机下搭建SDN实验平台（安装mininet网络仿真器 &#43; OpenDayLight控制器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装VirtualBox 虚拟机，并安装ubuntu
1）安装虚拟机
sudo apt-get install virtualbox-5.1 2）虚拟机安装ubuntu操作系统
参考how to install ubuntu on virtualBox?
二、ubuntu系统下搭建SDN实验平台
1）首先根据步骤一，在虚拟机上安装两个ubuntu操作系统，一个命名mininet用于安装mininet网络仿真器，一个命名OpenDayLight用于安装OpenDayLight控制器;
2）配置虚拟机配置网络链接，实现主机与虚拟机、虚拟机间的通信。
启动虚拟机选择File –&gt; preferences –&gt; Network –&gt; Host-only Networks–&gt;点击添加按钮(会出现vboxnet0) 关闭虚拟机，为虚拟机添加虚拟网卡，Setting –&gt; Network –&gt; Adapter 2 –&gt; Enable Network Adapter - Attached to: (选择Host-onlyAdapter) - Name（选择1中新建的vboxnet0).然后启动虚拟机，打开命令行，输入ifconfig，多出enp0s8 网卡配置(如图所示) 主机会虚拟出一块vboxnet0网卡，虚拟出192.168.56.*/24 网段
至此，虚拟机与主机互相通信已经实现，互相之间可以 ping 通
为虚拟机安装openssh-server，允许远程登陆 (ssh命令： ssh username@remote-host ip)
sudo apt-get install openssh-server 三、在mininet虚拟机上本地安装mininet源码，步骤如下
1、安装需要软件
sudo apt-get install git 2、获取需要Mininet源代码
git clone git://github.com/mininet/mininet 3、获取mininet源代码之后即可安装mininet
以下命令将安装Mininet VM 中的所有安装工具，包括Open vSwitch 、Wireshark抓包工具和POX，默认情况下这些将安装在用户的主目录下 mininet/util/install.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e80db4aa0d82991d6b8346d039c7f94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f795498eb7d7a55cbf33a45080b7017/" rel="bookmark">
			图像不变性特征—hu矩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像的hu矩是一种具有平移、旋转和尺度不变性的图像特征。
普通矩的计算：
f(x,y)的p+q阶原点矩可以表示为：
而数字图像是一个二维的离散信号，对上述公式进行离散化之后：
其中C与R分别表示图像的列与行。
各阶矩的物理意义：
0阶矩（m00）:目标区域的质量
1阶矩（m01,m10）：目标区域的质心
2阶矩（m02,m11,m20）：目标区域的旋转半径
3阶矩（m03,m12,m21,m30）：目标区域的方位和斜度，反应目标的扭曲
但是目标区域往往伴随着空间变换（平移，尺度，旋转），所以需要在普通矩的基础上构造出具备不变性的矩组—hu矩。
中心矩：构造平移不变性
由零阶原点矩和一阶原点矩，我们可以求得目标区域的质心坐标：
由求得的质心坐标，我们可以构造出中心矩：
由于我们选择了以目标区域的质心为中心构建中心矩，那么矩的计算时永远是目标区域中的点相对于目标区域的质心，而与目标区域的位置无关，及具备了平移不变性。
归一化中心矩：构造尺度不变性
为抵消尺度变化对中心矩的影响，利用零阶中心矩u00对各阶中心距进行归一化处理，得到归一化中心矩：
由上文可知，零阶矩表示目标区域的质量（面积），那么如果目标区域的尺度发生变化（缩小2倍），显然其零阶中心矩也会相应变小，使得矩具备尺度不变性。
hu矩：构造旋转不变性
利用二阶和三阶规格中心矩可以导出下面7个不变矩组(Φ1 Φ7)，它们在图像平移、旋转和比例变化时保持不变。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e5eb1a555bfa4c1c25938ff8256546c/" rel="bookmark">
			中间件技术ActiveMQ消息中间件的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. ActiveMQ介绍 通过ActiveMQ消息服务交换消息。消息生产者将消息发送至消息服务，消息消费者则从消息服务接收这些消息。这些消息传送操作是使用一组实现 ActiveMQ应用编程接口 (API) 的对象来执行的。
二. 软件开发目的 2.1 软件目的 利用消息中间件接口JMS、消息服务器ActiveMQ 和Java Swing实现一个简单的聊天工具，掌握消息中间件的应用。
2. 2程序要求 实现界面化的聊天工具，支持二人之间互发消息。发送消息过程中，发送这首先把消息发送到消息服务器ActiveMQ，接收者从消息服务器上取消息；消息发送者和接收者不需要同时运行（在线），实现即使对方处在离线状态下也可以进行消息的发送和接收。 三. 软件实现 3.1 功能实现 使用MessageSender进行消息发送，使用MessageReceiver进行消息接收。在Swing中，当用户点击开始聊天按钮后MessageReceiver会建立一个线程进行监听消息，如果有新的消息则向对话框中添加信息。 关键线程函数：
MessageSender messageSender = new MessageSender(targe,url,user,password,str); new Thread(messageSender).start(); new Thread(new MessageReceiver(user,url,null,null,textArea)).start(); MessageReceiver中的线程操作，如果接收到信息就更改信息。
SwingUtilities.invokeLater(new Runnable() { @Override public void run() { try { textArea.append("receive : "+ receiveMessage.getText()+"\n");; } catch (JMSException e) { e.printStackTrace(); }}}); 四.运行结果 当对方不在线时，依旧可以发送消息，当对方上线后可以正常接收。
代码链接：https://github.com/BlackJocker1995/MiddlewareWork03
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e6af348aede336dbaa81f5fe21e386f/" rel="bookmark">
			c语言实现字符串的逆序输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; #include&lt;string.h&gt; main() { int i,j,t,n; char a[10]; printf("请输入字符串:"); gets(a); n=strlen(a); for(i=0;i&lt;=n/2;i++) { t=a[i]; a[i]=a[n-1-i]; a[n-1-i]=t; }	for(j=0;j&lt;n;j++) printf("%c",a[j]); printf("\n"); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6d02f2681a668f279f2f70af8dc2522/" rel="bookmark">
			AlarmManager详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AlarmManager的特点 1.AlarmManager是一种系统级别的定时提示服务，这允许app在一个给定的时间段上执行某一段代码。这可以运行在app的生命周期之外。
2.一旦设置AlarmManager，它将一直调用，即使你的应用程序是不运行，甚至当你的设备是在睡眠。
3.定时任务可以唤醒你的设备，但这会消耗更多的电池。因此，你必须小心那些执行频繁的定时任务。定时任务应该尽可能地设置低的频率。
4.一旦设置了AlarmManager，这将执行直到明确的调用停止方法或直到设备重启。
5.例如，一个AlarmManager用于启动长时间运行的操作，如从服务器每天一次同步数据。
6.AlarmManager允许你在给定的时间处理Intent
7.AlarmManager可以与broadcast receiver一起使用，以启动一个service来执行网络操作。
8.AlarmManager 与Timer，TimerTask不同，后者都执行在应用程序生命周期。
设置定时任务 type:闹钟类型，有四个可选值
1.ELAPSED_REALTIME：以手机开机的时间为基准
2.ELAPSED_REALTIME_WAKEUP：以手机开机的时间为基准，并且可以在休眠时发出广播
3.RTC：以UTC标准时间为基准
4.RTC_WAKEUP：以UTC标准时间为基准，并且可以在休眠时发出广播。这种方式是最常见的形式。
下面写一个例子，使用RTC类型。该应用程序使用一个activity，包含三个按钮。一个按钮是为启动定时服务，另一个是取消预定服务。 第三个按钮是在指定的日历时间开始闹钟。例如，如果你设置为你的生日提醒。它将调用在10:30，并将在每30分钟后重复。
下面看一下布局文件：
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context=".MyActivity"&gt; &lt;TextView android:id="@+id/textView" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginBottom="20dp" android:text="@string/hint" android:textAppearance="?android:attr/textAppearanceLarge" /&gt; &lt;Button android:id="@+id/startAlarm" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_alignParentLeft="true" android:layout_alignParentStart="true" android:layout_below="@+id/textView" android:layout_marginBottom="20dp" android:text="Start Alarm Service" /&gt; &lt;Button android:id="@+id/stopAlarm" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@+id/startAlarm" android:layout_marginBottom="20dp" android:text="Stop Alarm" /&gt; &lt;Button android:id="@+id/stopAlarmAt10" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@+id/stopAlarm" android:text="Stop Alarm at 10:30" /&gt; &lt;/RelativeLayout&gt; 定义定时BroadcastReceiver 在这个例子中，我们将与broadcast receiver关联。定时服务将在预定时间调用这个接收器。为了简单起见，每一次的任务我们只是向用户 展示了一个toast。您可以编写您的逻辑来启动服务或下载任务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6d02f2681a668f279f2f70af8dc2522/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/546df1233d1060924ee17d3a47922473/" rel="bookmark">
			蓝桥杯省赛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次参加蓝桥杯，听人说很水于是就参加了，一路折腾总算来到宾馆，10几个人，发现多了个人，只能开个家庭房，随机分配了下，和学霸一间房间，期间背了下快速IO，血长，补了几部番，传来学霸说美赛出成绩，拿了h奖，睡觉。
第二天来到学校，喝了瓶红牛，开始写题，第一题水题，看了几遍题目怕题意出错，暴力算了下，第二题是个全排列+判重，第三题是个杨辉三角类似的题目，没写出来，第4题是个魔方，有点难（赛后听说没什么人出）估计是个放ak的题目吧，第5题简单的递归，第6题很水的最长公共子序列，第7题我的做法是暴力枚举开始年份和结束年份，对于平年进行判断，打了两个月份表，排序的话，本来想写sort，发现java的重载运算符不会写，于是讨论了一下直接就排好序了，但是没有考虑判重，第8题正解应该是个多重背包，如果gcd不为输出INF，我骗分了，第8题是个二分答案，没写出来，第9题我也没想出正解，直接写了个n*n的暴力。
省 一滚粗，决赛前要好好刷题，虽然还有前端还没学完。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e441213cb97da5c79dab2dd91f6b1d35/" rel="bookmark">
			SQLserver统计某个字段不重复的个数以及怎么以时间为单位取出一段时间的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、SQLserver统计某个字段不重复的个数
在查询的命令行处输入：SELECT COUNT(DISTINCT 字段名)FROM 表名
2、怎么以时间为单位取出一段时间的数据
在查询的命令行处输入：SELECT * FROM 表名 where 字段 (这里*号代表所有字段数据，如果你只想得到一部分你想看的字段，可以再加筛选条件)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/597dcf6f7d51c391335a01648e0c5c27/" rel="bookmark">
			git设置mergetool可视化工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 git设置mergetool可视化工具
可以设置BeyondCompare,DiffMerge等作为git的比较和合并的可视化工具,方便操作. 设置如下: 先下载并安装BeyondCompare,DiffMerge等.设置git配置,设置BeyondCompare的git命令如下:#difftool 配置 git config --global diff.tool bc4 git config --global difftool.bc4.cmd "\"c:/program files (x86)/beyond compare 4/bcomp.exe\" \"$LOCAL\" \"$REMOTE\"" #mergeftool 配置 git config --global merge.tool bc4 git config --global mergetool.bc4.cmd "\"c:/program files (x86)/beyond compare 4/bcomp.exe\" \"$LOCAL\" \"$REMOTE\" \"$BASE\" \"$MERGED\"" git config --global mergetool.bc4.trustExitCode true #让git mergetool不再生成备份文件（*.orig） git config --global mergetool.keepBackup false
使用方法如下: diff使用方法: git difftool HEAD // 比较当前修改情况
merge使用方法 git mergetool sourceTree设置方法如下: 1.在菜单(工具-&gt;选项)中设置如图 2.使用菜单(操作-&gt;解决冲突-&gt;打开外部合并工具),则可使用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d917d9bda096dfa0ae08cb5b9caea56/" rel="bookmark">
			ADG732: 32通道、串行控制、3.5 Ω、1.8 V至5.5 V/±2.5 V、模拟多路复用器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址::http://www.bdtic.com/ADI/ADG732.html
相关文章
1、目前市场上的多路模拟开关最多能达到几路，是什么芯片？有没有具体资料----https://zhidao.baidu.com/question/279475452.html
2、DG406中文资料----https://wenku.baidu.com/view/555435cf6137ee06eff91861.html
3、ISL59532_0708中文资料----https://wenku.baidu.com/view/548bd545e518964bcf847c74.html
4、ADG732中文资料----https://wenku.baidu.com/view/f35e35765acfa1c7aa00cc1f.html
ADG732: 32通道、串行控制、3.5 Ω、1.8 V至5.5 V/±2.5 V、模拟多路复用器 ADG726/ADG732分别为单芯片CMOS、32通道/双路16通道模拟多路复用器。ADG732根据5位二进制地址线A0、A1、A2、A3和A4所确定的地址，将32路输入(S1-S32)之一切换至公共输出D。ADG726根据4位二进制地址线A0、A1、A2和A3所确定的地址，将16路输入之一切换至公共输出。
特点 单电源：1.8 V至5.5 V双电源：± 2.5 V导通电阻：4 Ω导通电阻平坦度：0.5 Ω48引脚TQFP或48引脚、 7 mm × 7 mm CSP 封装轨到轨工作开关时间：30 ns单路32:1通道多路复用器双路/差分16:1通道多路复用器TTL/CMOS兼容型输入功能相当、采用串行接口的器件，
请参考ADG725/ADG731 技术指标 Sw/Mx Function x #: (32:1) x 1Ron (Ohms): 4OhmsRon Match (Ohms): 0.3OhmsMax Analog Signal Range: Vss to VddInput Latch: YesMux Operation (MBB/BBM): Break-Before-MakeInterface Type: ParallelMux Type (SE/Diff): Single-Ended 功能框图 订购指南 产品型号 封装 引脚 温度范围 包装和数量 报价*(100-499) 报价*1000 pcs RoHSADG732BCPZ 产品状态: 量产48 ld LFCSP 7x7mm (5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d917d9bda096dfa0ae08cb5b9caea56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82ceeacf0b5ab73e86db944fc72a6644/" rel="bookmark">
			datagrid系列之-加入快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function onBeginEdit(index,row){ var flag = false; var subj = $("#subjCode").val(); var subjCode = new Array(); subjCode.push(subj.split(",")); var subjRow= row.pkAccsubj.subjcode; for(var j=0;j&lt;subjCode[0].length;j++){ if(subjRow==subjCode[0][j]){ flag = true; break; } } // 摘要 ed = $(this).datagrid('getEditor', { index: index, field: 'explanation' }); if(flag){ if(ed == null){ $(this).datagrid('endEdit',index); //结束编辑 return false; } } if(ed != null){ document.onkeydown=function(event){ var e = event || window.event || arguments.callee.caller.arguments[0]; if(e &amp;&amp; e.keyCode==13){ $('#contentTable').datagrid('endEdit', index); $('#contentTable').datagrid('selectRow', index).datagrid('editCell', { index: index, field: 'pkAccsubj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82ceeacf0b5ab73e86db944fc72a6644/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/086206d017400692b15b373cf3bb9889/" rel="bookmark">
			EXCEL 汉字转拼音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EXCEL－VBA-插入-模块 Function pinyin(p As String) As String i = Asc(p) Select Case i Case -20319 To -20318: pinyin = "a " Case -20317 To -20305: pinyin = "ai " Case -20304 To -20296: pinyin = "an " Case -20295 To -20293: pinyin = "ang " Case -20292 To -20284: pinyin = "ao " Case -20283 To -20266: pinyin = "ba " Case -20265 To -20258: pinyin = "bai " Case -20257 To -20243: pinyin = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/086206d017400692b15b373cf3bb9889/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dae2ae8c3b14b8da6ce83c5c8ef41fe/" rel="bookmark">
			怎么设置IP不会冲突，本地电脑为服务器时IP冲突解决方案！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍IP冲突 IP地址在一个网络当中必须是唯一的，也就是说，IP地址具有唯一性。比如在一个局域网中，192.168.1.3这个IP只有被用在一台计算机上，如果存在两台计算机或者多台计算机用这个IP，就会出现冲突。出现IP冲突的原因我们已经有了基本的了解了，那么我们再来看在什么情况下会出现呢？ IP的获取情况有两种 1，自动获取，当网络的中服务器或者是路由器开启了DHCP（动态主机配置协议，这个协议里会定义自动分配IP的地址池，比如192.168.100-192.168.1.199），那么，网络中的客户机就可以通过在本地连接里面，设置为自动获得IP地址来让服务器为客户机配置一个IP，这个IP是随机的(由服务器或者是路由器从定义好的地址池里选一个没有被分配的来给你用)，从而可以保证与其他使用自动获得IP的电脑中的IP地址不相同。2，手动指定，当网络中的服务器或者是路由器没有开启DHCP功能的时候，我们要自己给客户机配置IP，当然，如果服务器开了DHCP功能，我们也一样可以手动指定的。 好了，接一来，我们看看会有什么情况发生什么。 如果你的电脑是使用自动获得IP的，比如你已经得到一个192.168.1.120吧，然后，和你同一个局域网中的另一个用户，他不是自动的，他自己手动设置IP，而他又不知道你已经用了192.168.1.120这个IP，他就把自己的电脑也配置成了192.168.1.120，这样，网络中就出现了两个相同的IP了，这就打破了IP唯一性，于是，冲突就产生了。又或者，你的也是手动的，然后他也手动配置了一个和你一样的IP，那也是一样的结果，IP冲突。最后，我们来说说解决的办法。1,如果你是用自动的，出现了冲突，你就点一下修复，让服务器重新为你配置一个新的IP。2，如果你是手动的，服务器又开有DHCP，你可以改成自动的。3，如果你是手动的，服务器没开DHCP，你就手动改成另一个比较怪的IP，比如192.168.1.253
总结： 从上面我们至少获取2个以上的知识点， 最重要的2个分别是：【 DHCP】和【 地址池 】（这2个理解起来比较简单） 只要让【地址池的开始】 和【结束】不包含你的电脑绑定的IP就行，这样就不会引起IP冲突！ 延伸阅读： DHCP服务器静态地址分配与静态ARP绑定到底有什么不同 链接地址： http://wuxiong8665.blog.163.com/blog/static/935122012629102455464/ 以下仅为个人愚见，有些观点未测试，仅为推测，如有不妥欢迎指正。 以下省略具体操作步聚，仅陈述相关问题。 首先说一下静态地址，使用路由器上网时，开启DHCP，电脑也是可以指定使用静态ip地址的，而关闭DHCP时则必须使用静态ip地址。 在开启DHCP时， 如果你给电脑指定一静态ip会发生几种情况： 一、此指定ip与先上网自动通过DHCP获取动态ip的另一台电脑获得的ip相同，此时会造成ip地址冲突，结果你懂的（要修改自己的静态ip） 二、没有发生第一种情况，但能登QQ却不能浏览网页，why？原因是你没有在自己电脑上指定DNS服务器ip地址，有人会说，我不设置静态ip时也没指定DNS啊，（猜想）那是指定静态ip，ip和DNS都是自动获取的，而当你指定静态ip时，DNS也设置为手动指定了，如果不指定DNS服务器的ip，你访问网页时就不能访将网址解析成对应ip（其实此时部分网站可以用其该域名绑定的ip访问），解决办法：只要手动填入DNS（如上图）就行了。使用此 http://code.google.com/p/namebench/downloads/list工具可以帮你找到最快的dns。 那么，对于第一种情况，就引出了今天要讲的话题：DHCP服务器静态地址分配与静态ARP绑定到底有什么不同？ 简单的说就是： DHCP服务器“静态地址分配”是保留此ip给你的网卡，不会自动分配给别人（（猜想）别人手动指定此ip应该也是可以上网的，这与下面讲到的静态ARP绑定就不一样），此时如果你指定自己电脑的静态ip为该ip，就不用担心你的ip会和别人的冲突了，但并不表示你非得使用此ip上网，如果你指定或者使用自动获取而得到其它ip，也是可以上网的。 而看上去好像和DHCP服务器静态地址分配很类似的静态ARP绑定又是怎么回事？ 这个就更“狠”了，绑定后，你电脑上必须指定为该静态ip才能上网，指定或自动获取为其它ip就断网了（连路由器192.168.1.1也打开不了了），而且别人如果指定为此ip也上不了网。 综上，如果你使用DHCP服务器静态地址分配，你的电脑可以指定静态ip或者自动获取ip，如果使用静态ARP绑定，则你必须在你电脑上指定此静态ip，并且此时必须在DHCP服务器静态地址分配里相应配置，以免路由器将此ip分配给别的电脑而造成ip冲突。 所以一般情况下（没有“恶人”特意指定为你的ip上网时），最简单的方式是使用DHCP服务器静态地址分配并指定电脑静态ip（包括DNS）。 说了这么多，这样做有什么特殊意义？ 可以用来方便“ip带宽控制”，给自己的这个ip分配一个最小占用带宽，或者给别人的电脑分配一个最大占用带宽，免得有人看电影、下载时，其它人的网速就悲剧了。 转载注明出处：http://wuxiong8665.blog.163.com/blog/static/935122012629102455464/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/546f6855a6b81459d1f325e80a22b29b/" rel="bookmark">
			PLC控制系统的软件设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件设计就是编写满足生产控制要求的plc用户程序，即绘制梯形图或编写语句表。 PLC的软件设计包括系统初始化程序、主程序、子程序、中断程序、故障应急措施和辅助程序的设计。首先应根据总体要求和控制系统的具体情况，确定程序的基本结构，画出控制流程图或功能流程图，简单的可以用经验法设计，复杂的系统一般用顺序控制设计法设计。 控制对象和对象之间关系的多样性，体现在PLC程序的编写上。这样采用一般面向过程的方法进行plc编程会变得十分困难，且程序的调试和修改也同样十分困难。因此，必须采用面向对象的编程方法。主体思路有两条：
原文：http://www.gkwo.net/dxt/show-10325.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9689384958044c7590be28e224323ec/" rel="bookmark">
			.NET的前景如何？你的问题答案都在这里-2017
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你感觉.NET的前景如何？ 我怎么感觉 现在都是PHP和 JAVA的天下了
如题：我找了些文章发些很好就分享下！ 链接地址：https://www.zhihu.com/question/36993859?q=你感觉.NET的前景如何？ 回答一： 题主所说C#边沿化的问题，是因为前十年出现一股反 Microsoft 的潮流，主要不是技术之争，而是一种政治运动。说实话我挺反感这股潮流的，完全过火了。
本质还是关于开源和闭源的争论，商业模式的竞争。虽然这些潮流，从时间轴拉长了看非常可笑，但它确实也鞭笞了 Microsoft，客观上促成了情况的转变。
现在 C# 开源后，问题就解决了。
在这种情况下，要看语言本身的技术性，而排除以前的成见。我觉得现在正是投资和押宝 C# 的好时机。如果以前有积累，现在放弃是最可惜的。 作者：匿名用户 链接：https://www.zhihu.com/question/36993859/answer/70173338 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 回答二： 作者：find goo 链接：https://www.zhihu.com/question/36993859/answer/137384805 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 行不行，看虚拟机。
java应用广是因为虚拟机，应用限制也是因为虚拟机。
python应用广是因为虚拟机，应用限制也是因为虚拟机。
Unity3D基于mono，能在ios平台把c#上编译成二进制运行，一下子解决了性能问题，所以Unity3D火了，加上vr应用的兴起，c#应用前景在大家最不被看好时，柳暗花明又一村。很多时候开发语言只是一种语法，在未来可能发展出的新的虚拟机引擎平台，又有了新的发展空间。
和c/c++不同，java,python,c#的发展关键看虚拟机这个翻译器。
看未来不能以当前的状态看未来，c#的mono已经开源, 随着消费习惯的改变，移动终端市场比电脑终端市场大得多，未来70亿人，有60亿人用移动终端不是夸张，对用户沾性更强，估计再过几十年未来终端应该是平板（大的，包括tv）+手机+手表+vr，这种新型终端，得终端者得天下，而传统pc可能只是生产者工具。
现在在移动终端3d市场，各个语言有短板，所以造成了c#的兴起。
主流的开发语言拿到移动终端特别是3d市场会有各种问题，如平台专用的java,obj-c，只能运行在自身平台，而跨平台受到竞争对手限制，如java虚拟机无法进入app store市场，被条款卡死了，obj-c/swift在ios上运行良好，但到了android受编译工个限制及java的平台限制不好用。如果两个平台同时开发，复杂度超过了1+1=2，而3d,VR会进一步增加复杂度。
c++本应该是理想选择，如cocos2d-x就是这种选择，但c++受限于指针内存管理的细节，开发速度特别慢，在商业竞争中用c++开发会导致成本高昂，对于需要快速迭代的移动市场成本太高，这一点在开发3d游戏时表现更明显，因为3d游戏的复杂度高于2d,而VR的复杂度又高于3d，所以需要一种能快速开发的性能高的能工程化的语言。
python,lua受语言静态检查限制，只适合小型化编程，而且性能在3d/VR这种要实时要求高时跟不上，而且python,lua开发工具对软件工程化支持度不好，n多人开发时不容易使用软件工程方法和软件进行管理，语言语法和c，java一样不兼容会导致人难招用工成本高，语言黑箱也比较多不适合在ios下编译成二进制。
c#，本来没有移动市场什么事，特别在基于java的安卓的出现后，微软的wp失败后，c#被认为不会进入移动市场，但mono的开源c#改变了这一切，Unity3D的出现，让人看到跨平台的c#，调用3d,VR平台这种以前是c++与lua天下的api很流畅，代码也好写，c#进步是mono开源虚拟机技术的进一步发展，适用了app store这种要求苛刻的环境，xamarin的开源让人们看到c#在开发移动平台程序时，是一种快速迭代，实现一种代码，n个平台运行。如果你用java幸苦开发出来只能运行于安卓，而c#开发出的游戏或软件可以运行mac,windows,ios,osx,tv，你怎么想?虽然对BAT这样的公司没什么问题（但成本上去了），但对需要快速占领市场，需要快速迭代产品运营赚钱的公司来吸引力非常大。大小老板不是傻子，老板开公司不是谷歌的研究院有钱玩技术不用管市场，而是需要有生产力，好招人，市场反映良好的开发语言，快速迭代移动终端的兴起市场。现代软件产品运行速度的瓶颈是IO，未来也会IO，因为一个死循环一直运行，1秒可以运行n亿次，每次产生一个数据，IO存储是无法跟上这个速度的。程序永远比IO跑得快。你用c++编程最后数据总要落地读写，但一旦调用IO部分，速度和java,c#同样慢。对数据分析，建议使用python，支持的工具库非常多。
另外随着游戏的终端领域的发展，有些团队为了开发方便，在服务器端也使用c#做为app服务器，使用mono可以运行于linux服务器，也可以运行windows，可以使用mysql,mongodb,redis，可以使用云平台基础产品,使用json做为传输协议，根据程序不同可以走http通道，也可以自定义tcp，只要框架设计注意，并发不是问题，这样整个产品的前后台迭代速度更快了。语言虚拟机技术只会越来越进步，硬件性能只会越来越高，用虚拟机语言是降低开发成本提高开发速度的趋势。硬件只会越来越便宜，没有必要像google,腾讯那样堆c++（90年代只有c++可选，后来的淘宝选java），一般的应用根本达不到，就算能达到，那时你整个产品就非常成功了，只要有钱，这些问题都不是问题，如facebook用php开发一样很成功，php性能不够时可请专家优化，开发php虚拟机，所关键不是语言，而是市场。 回答三： 回答四： 微博链接：
http://weibo.com/1678298567/DoR3Wtn9f?type=comment#_rnd1492056014543 如果你们看后还是疑问多，那么可以再看看下面的文章！ .NET技术在中国为什么老被人嫌弃 这个话题有点自黑的意思，我从.NET 1.1开始玩.NET，到现在已经11年了，我是看着.NET成长起来，在中国壮大的，也见证了近几年.NET被各种嫌弃，其实说到底还是中国的架构师太少，我是说真正懂行的架构师，一个资深的架构师是不会直接攻击一门语言或者嫌弃一门语言的，而是会从操作系统、服务器应用容器层面是分析性能、实现成本以及有多少坑。
我其实和很多客户、IT经理、高级软件工程师、架构师聊过，所以对事实有一定的了解。首先呢在中国技术圈氛围就是很浮躁的，浮躁到什么程度，还是中国人的老毛病，喜欢跟风、喜欢一窝蜂，人家用node.js，我们就用node.js；人家用docker，我们也用docker；人家用CloudFoundry，我们也用CloudFoundry，总之人家的东西比我们家先进，所以我们一定要跟上。拿docker来说，其实很多传统企业根本没有用，也就是几家互联网大厂对它情有独钟；Node.js我承认它性能好，但毕竟是弱语言编程，其实代码的维护成本并不低，而且你需要雇佣很资深的Javascript开发人员，薪水自然是水涨船高。其实很多所谓的架构师、IT经理考虑的不是迁移成本、运维成本，而是怎么找点事做，这样才能体现出自己的价值，我总结为四个字“无中生有”。
.NET中的C#语言（我的最爱）其实从1.0发展到6.0，目前已经非常成熟了，特别是语言层面的异步编程支持，已经部分超越了Java，那为什么还是没有公司愿意选它呢？从我的角度看，有几方面的原因。
首先微软的IDE实在是太好用了，好用到基本上找个应届生，就算不懂编程，1-2天内也能写个控制台程序，当然是简单的；但如果是Eclipse，配环境也要好一会儿，但这意味着什么知道吗？门槛！人的门槛！越好用的东西聚集的人相对越Low，当然并不是说用.NET的人烂，而是说平均而言，真正懂.NET的开发人员相对于懂Java的开发人员要少，因为人家的IDE用起来各种不舒服，还不如用Notepad++和Java.exe做编译。这就导致了Java的工程师很多时候必须知其然知其所以然，否则它没法干活，比如jar打包。但很多.NET的程序员估计连怎么用命令行编译程序都不会，这就是问题。
其次一些号称懂.NET的架构师觉得.NET简单，所以他们不愿意给.NET开发高工资，这也间接导致了很多.NET开发人员开始转向其他语言，其实这种模式就是个恶性循环。到最后的结果就是，大量潜在的优秀开发人员放弃.NET，毕竟现在是向钱看的年代。.NET从我的角度看是非常适合做后端，这么多年技术的积淀使得.NET得到了社区广泛认可，其实在国外懂.NET还是很吃香的，根本不愁找不到工作，所以国内一些公司的逻辑我觉得很奇怪，甚至觉得神奇，反正我就是不招.NET工程师，我公司比较高大上，所以只有高达上的Java、Node.js 才能配得上我司，我只能说，不作不死。
再者，.NET可以抄的现成架构并不多，而真正懂.NET的资深架构师在中国基本属于稀有物种，因为这些公司的所谓架构师水平有限，他们自己用.NET写不出好的架构代码（我通常喜欢叫他们集成师，即不会写代码或者写不好代码的架构师），最终还是选Java，因为Java有一大堆架构可以抄，而且很多是开源的，就算不会也至少能抄个4-5成吧。当然咯，从项目风险可控角度这是可以接受的，但其实资深架构师是可以解决这些问题的，在国外很多架构牛人基本都是自己写框架的，这也就能解释为什么优秀且流行的框架基本上都是洋人写的，比如Java的Structs、Spring framework, .NET的Orchard、DNN、ASP.NET Biolerplate等。
最后，微软作为.NET亲爹自然难辞其咎，自从纳总上台后，更是拼命推行拥抱开源政策，拥抱了一堆非.NET系语言，尽管推出了跨平台.NET即.NET Core，但在.NET市场布局和推广方面与过去并没有什么明显不同，说白了就是表现对.NET份额出无所谓的态度。不过微软一直是行业中比较傲娇的公司，它觉得只要自己想推什么肯定能成功，所以对市场份额从来表现的不太看重，他觉得根本不需要在意，迟早是微软的。然并卵，微软手机的失败让微软感受到了自己能力的有限，最近貌似在调整策略，其实回过头来看代价非常高，单收购诺基亚就花了85亿，我只能赞叹微软真土豪，有钱任性，呵呵。
我必须承认近2年.NET的中国市场份额在不断下降，很大程度上与.NET的市场推广策略有关，给行业内一种中低端编程语言的假象，在语言推广初期，这种策略没有什么错误，便于用户上手和接受，但是如今都10年了，重新树立.NET高大上技术的形象非常必要。
有人可能要说我属于老王卖瓜自卖自夸了，我举几个真实的.NET案例你就懂了，沪牌拍牌系统后台是.NET写的，并发至少几千每秒，这个大家懂的；Stackoverflow核心是.NET写的，网站并发 3000每秒，数据库并发 8000每秒；摩根斯坦利交易客户端以及协议是.NET写的；NASDAQ的交易系统是.NET写的，后台跑的SQL Server；腾讯有大量后台系统用.NET写，腾讯甚至已经使用跨平台.NET（Mono）很多年，部署于它的TLinux系统集群中；携程有大量系统用.NET写成，日均动态PV是3千万。
事实胜于雄辩，我就不多说了，你们懂的。
文章地址：http://www.cnblogs.com/neuzilla/p/dotnet_china_market_share.html 为什么那么多公司不用 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9689384958044c7590be28e224323ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/872fa17f275f48443c580487b5600842/" rel="bookmark">
			IP路由和路由表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IP路由过程 路由器关键功能 检查数据包目的地确定信息源发现可能的路由选择最佳路由验证和维护路由信息 建立路由表 静态和动态路由 静态 由网络管理员手工指定的路由。网络拓扑发生变化时，管理员需要手工更新静态路由。 静态路由因其配置简单而开销小得到广泛应用（适合于网络拓扑简单的网络）。 配置 在路由器B上配置到达路由器A的10.1.1.1网段的静态路由。 负载分担 在路由器B上配置到达路由器A的10.1.1.1网段的三条负载路由。 路由备份 在路由器B上配置到达路由器A的10.1.1.1网段的备份路由。 缺省路由 一种特殊的路由，可以通过静态路由配置，某些动态路由协议也可以生成缺省路由，如OSPF和IS-IS.路由表中，缺省路由以到网络0.0.0.0(掩码为0.0.0.0）的路由形式出现。当路由器收到一个目的地在路由表中查不到的数据包时，会将数据包转发给缺省路由指向下一跳。 在路由器B上配置缺省路由 缺省路由也支持路由的负载分担与路由备份
动态 路由器使用路由协议从其他路由器那里获悉的路由。网络拓扑发生变化时，路由器会更新路由信息。 路由协议 路由器之间交互信息的一种语言，路由器之间通过路由协议共享网络状态和网络可达性的一些信息。相互通信的双方必须使用同一种语言才能交互路由信息。路由协议定义了一套路由器之间通信时使用的规则。路由协议维护路由表、提供最佳转发路径。 协议算法 距离矢量路由选择协议（Distance-Vector） 包括RIP和BGP，BGP也被称为路径矢量协议（Path-Vector）。链路状态路由选择协议（Link-State） 又称为最短路径优先路由选择协议，包括OSPF和IS-IS. 原理图 邻居和邻接关系建立 链路状态信息泛洪 最短路径优先算法计算路由 根据业务应用，协议可分成：单播路由协议（Unicast Routing Protocal）：包括RIP、OSPF、BGP和IS-IS等。组播路由协议（Multicast Routing Protocol）：包括DVMRP、PIM-SM、PIM-DM等。 按作用范围，协议可分成：IGP（内部网关协议）：RIP,OSPF,IS-IS。EGP（外部网关协议）：BGP。 路由表 pref：路由优先级。当存在多个路由来源时，优先级高的（数值越小优先级越高）路由来源提供的路由将被激活，用于指导报文的转发。 VRP缺省的路由优先级如下： 等价路由：ECMP Equal Cost Multi-Path到同一个目的地有几条相同花费的路由，当路由优先级相同时，这些路由都会被加入路由表，IP包也会在这几个链路上负载分担。 最长匹配原则 最长匹配举例 路由环路 Routing Loop：报文在两个或几个路由器间循环路由，直到TTL减为0而丢弃。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/453/">«</a>
	<span class="pagination__item pagination__item--current">454/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/455/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>