<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c09ef2ce0d1143e762ca60a12671833c/" rel="bookmark">
			终于有阿里大牛把Spring Cloud的精髓全总结出来了！不服不行啊
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里大牛把Spring Cloud的精髓总结成了一份手册。话不多说。一起来看看：
总览： 因为内容太多，下面就只以截图展示了。需要获取完整Spring Cloud手册的小伙伴：一键三连（点赞+收藏+关注） 后，添加微信：mxm9843 即可免费获取到
详细内容展示： 篇幅限制，就不一一截图展示了。需要获取完整Spring Cloud手册的小伙伴：关注我+转发文章后，私信我【手册】即可免费获取到了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a11ed6e64cf91f6d2d5f15bb0f82cd38/" rel="bookmark">
			Centos7安装Hive2.0.1集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、准备工作
1.1、安装jdk1.8和mysql5.7.21,略
1.2、安装Hadoop2.6.0，略
1.3、机器介绍
192.168.1.89 node1 192.168.1.149 node2 192.168.1.180 node3 node1、node2、node3上都已经安装了Hadoop2.6.0
2、下载并上传(三个节点都操作)
http://archive.apache.org/dist/hive/hive-2.0.1/apache-hive-2.0.1-bin.tar.gz
上传至三台机器的/data/server目录下，并解压：
tar -zxvf apache-hive-2.0.1-bin.tar.gz
3、修改配置文件(三个节点都操作)
cd apache-hive-2.0.1-bin/conf cp hive-default.xml.template hive-site.xml vi hive-site.xml，新增： &lt;configuration&gt; &lt;property&gt; &lt;name&gt;datanucleus.schema.autoCreateAll&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:mysql://192.168.1.166:3306/hive_db?createDatabaseIfNotExist=true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;root&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;123456&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.support.concurrency&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.enforce.bucketing&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.exec.dynamic.partition.mode&lt;/name&gt; &lt;value&gt;nonstrict&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.txn.manager&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hive.ql.lockmgr.DbTxnManager&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.compactor.initiator.on&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.compactor.worker.threads&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a11ed6e64cf91f6d2d5f15bb0f82cd38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbcaa2b8d0225994dbbc00914cc63a93/" rel="bookmark">
			android 携程日历控件,仿携程酒店日历组件for小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仿携程酒店日历
接受日历组件开发之前，本来是拒绝的，日历组件，表单组件绝逼是前端开发的一个噩梦，尤其要做好一个旅游项目的日历，产品的收货标准只有一条，你看携程都实现了哦, MMP的。要在小程序中实现携程app的日历，即要兼顾性能问题，还要实现很多产品非常非常合理的需求。
完整源码
github地址
或者 github搜索 aotoo-xquery
微信搜索小程序: xquery
携程的酒店系统需要日历组件确定入住时间，离店时间。需要日历组件满足以下条件
一年有效期
日历纵向滚动，方便用户快速翻页
入住，离店时间间隔不大于28天，其余日期置灰
超出区间的月份隐藏，避免性能损耗
指定节假日
入住、离店高亮，并标注说明，区间日期低亮
选定离店日期后，跳转前页
再次进入，如果有值，应该高亮表示
难点
懒加载保证渲染性能
通过配置实现纵向日历和横向日历
阳历节日与农历节日与节气
交互，尤其是区域选择的交互
日历组件配置
第一步
第二步
wxml模板
第三步
配置日历组件
Pager({
data: {
source: {
$$id: 'calendar',
mode: 1, // 纵向日历
type: 'range', // 区域选择
tap: 'onTap', // page响应事件
total: 365, // 定义从今天开始一年事件
rangeCount: 28, // 区选区间28天
festival: true, // 开启节假日显示
value: ['2019-12-24', '2020-01-05'], // 默认值
methods: {
// 响应 tap事件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbcaa2b8d0225994dbbc00914cc63a93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7429e48532e96f4d526da1e8bf851791/" rel="bookmark">
			《人工智能及其应用（第6版)》蔡自兴1-6章课后习题.【部分无答案】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 绪论： 1-1什么是人工智能？试从学科和能力两方面加以说明。
人工智能（学科）：人工智能（学科）是计算机科学中涉及研究、设计和应用智能机器的一个分支。其近期的主要目标在于研究用机器来模仿和执行人脑的某些智力功能，并开发相关理论和技术。
人工智能（能力）：人工智能（能力）是智能机器所执行的通常与人类智能有关的智能行为，如判断、推理、证明、识别、感知、理解、通信、设计、思考、规划、学习和问题求解等思维活动。
1-5为什么能够用机器（计算机）模仿人的智能？
物理符号系统假设：任何一个系统，如果它能够表现出智能，那么它就必定能够执行上述6种功能。反之，任何系统如果具有这６种功能，那么它就能够表现出智能；这种智能指的是人类所具有的那种智能。
推论：既然人是一个物理符号系统，计算机也是一个物理符号系统，那么就能够用计算机来模拟人的活动。因此，计算机可以模拟人类的智能活动过程。
1-7你认为应从哪些层次对认知行为进行研究？
答：应从下面４个层次对谁知行为进行研究：
（１）认知生理学：研究认知行为的生理过程，主要研究人的神经系统（神经元、中枢神经系统和大脑）的活动。
（２）认知心理学：研究认知行为的心理活动，主要研究人的思维策略。
（３）认知信息学：研究人的认知行为在人体内的初级信息处理，主要研究人的认知行为如何通过初级信息自然处理，由生理活动变为心理活动及其逆过程
（４）认知工程学：研究认知行为的信息加工处理，主要研究如何通过以计算机为中心的人工信息处理系统，对人的各种认知行为（如知觉、思维、记忆、语言、学习、理解、推理、识别等）进行信息处理。
1-8人工智能的主要研究和应用领域是什么？
问题求解，逻辑推理与定理证明，自然语言理解，自动程序设计，专家系统，机器学习，神经网络，机器人学，模式识别，机器视觉，智能控制，智能检索，智能调度与指挥，分布式人工智能与Agent，计算智能与进化计算，数据挖掘与知识发现，人工生命。
1-9人工智能研究包括哪些内容？这些内容的重要性如何？
知识表示、知识推理和知识应用是传统人工智能的三大核心研究内容。其中，知识表示是基础，知识推理实现问题求解，而知识应用是目的。
1-10人工智能的基本研究方法有哪几类？它们与人工智能学派的关系如何？
功能模拟法：符号主义学派结构模拟法：连接主义学派行为模拟法：行为主义学派
集成模拟法：各学派密切合作，取长补短
第二章 知识表示方法： 2.1状态空间法、问题归约法、谓词逻辑法和语义网络法的要点是什么?它们有何本质上的联系及异同点？
状态空间法是一种基于解答空间的问题表示和求解方法,它是以状态和操作符为基础的.在利用状态空间图表示时,从某个初始状态开始,每次加一个操作符,递增地建立起操作符的试验序列,直到达到目标状态为止.由于状态空间法需要扩展过多的节点,容易出现“组合爆炸”,因而只适用于表示比较简单的问题.
问题归约法从目标（要解决的问题）出发,逆向推理,通过一系列变换把初始问题变换为子问题集合和子子问题集合,直至最后归约为一个平凡的本原问题集合.这些本原问题的解可以直接得到,从而解决了初始问题,用与或图来有效地说明问题归约法的求解途径.
谓词逻辑法采用谓词合适公式和一阶谓词演算把要解决的问题变为一个有待证明的问题,然后采用消解定理和消解反演来证明一个新语句是从已知的正确语句导出的,从而证明这个新语句也是正确的.
本质上都是将人工智能问题求解效率提高的知识表示方法，处理不同问题时应视情况采取不同的方法，在表达和求解复杂问题时需要综合使用这些方法。语义网络是知识的一种图解表示,它由节点和弧线或链线组成.节点用于表示实体、概念和情况等,弧线用于表示节点间的关系.语义网络的解答是一个经过推理和匹配而得到的具有明确结果的新的语义网络.语义网络可用于表示多元关系,扩展后可以表示更复杂问题.
2.5 试用四元数列结构表示四圆盘梵塔问题
2-6用谓词逻辑演算公式表示：A computer system is intelligent if it can perform a task which,if performed by a human, requires intelligence.
P(x,y): x performs y task (x 完成有任务) Q(y): y requires intelligence (y 需要智能)
C(x): x is a computer system (x 是计算机系统)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7429e48532e96f4d526da1e8bf851791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26b0bf6fe073b982a5fae7a50dab9cf0/" rel="bookmark">
			medusa 使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		密码爆破：medusa（美杜莎）使用方法 1.工具介绍 Medusa工具是通过并行登陆暴力破解的方法，尝试获取远程验证服务访问权限，它支持AFP, CVS, FTP, HTTP, IMAP, MS-SQL, MySQL, NCP (NetWare),NNTP, PcAnywhere, POP3, PostgreSQL, rexec, rlogin, rsh, SMB, SMTP(AUTH/VRFY), SNMP, SSHv2, SVN, Telnet, VmAuthd, VNC，是一个不择不扣的密码破解工具 2.参数介绍 medusha [-h host|-H file] [-u username | -U file] [-p password | -P file] [-C file] -M modudle [OPT] 参数名参数含义-h目标主机名称或是IP地址-H包含目标主机名称或是IP地址的文件绝对路径-u测试用户名-U包含测试用户名的文件绝对路径-p测试用户名密码-P包含测试用户名密码的文件绝对路径-C组合条目文件的绝对路径-O日志信息文件的绝对路径-e[n/s/ns]n代表空密码，s代表为密码与用户名相同-M模块执行mingc-m传递参数到模块-d显示所有模块名称-n使用非默认TCP端口-s启用ssl-r重试时间，默认3秒-t设定线程数量-T同时测试的主机总数-L并行化，每个用户使用一个线程-f在任何主机上找到第一个账号/密码后，停止破解-F在任何主机上找到第一个有效的用户名/密码后停止审计-q显示模块的使用信息-v详细级别（0-6）-w错误调试级别（0-10）-V显示版本-Z恢复之前终端的扫描 3.使用实例 破解SSH密码，以DC-1靶机为例，破解flag4用户密码
medusa -M ssh -h 192.168.75.141 -u flag4 -P /usr/share/john/password.lst -f -V 参数解释：
参数名参数含义-h要爆破的目标主机IP地址 192.168.75.141-l要爆破的用户名 flag4-P要爆破的密码字典 /usr/share/john/password.lst-M调用模块ssh执行-V显示版本-f一旦爆破成功一个就立即停止爆破 后记:最近一直在学习，但是学习的东西很多很杂，于是便把自己的学习成果记录下来，便利自己，帮助他人。希望本篇文章能对你有所帮助，有错误的地方，欢迎指出！！！喜欢的话，不要忘记点赞哦！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b02aa575bbc2b1fa8dd8fdbc6ea0b1f3/" rel="bookmark">
			Oracle查询被锁表和解锁方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、权限问题： 查询被锁表必须具有管理员权限的账号才能查询。system/manager或者其他已经被赋权的用户。
二、查询锁表语句： select object_name, l.oracle_username, machine, s.sid, s.serial# from v$locked_object l, dba_objects o, v$session s where l.object_id = 0.object_id and l.session_id = s.sid 三、解锁语句： alter system kill session '247,641'; --247为SID值，641为SERIAL#值。字符串中的逗号之间没有空格。 MySQL的查询被锁表和解锁方法：（简单暴力） -- 1.查看当前数据库锁表的情况 SELECT * FROM information_schema.INNODB_TRX; -- 2.杀掉查询结果中锁表的trx_mysql_thread_id kill 22 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c95a0e46e1c5e8ea5bc909bccc65116/" rel="bookmark">
			‘grep‘ 不是内部或外部命令，也不是可运行的程序 或批处理文件。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10，cmd环境下运行：adb shell top |grep com.*****s.j*
报错！！！
解决办法2种：
方法一：grep 更改为 findstr adb shell top | findstr com.******.**
方法二：先cmd输入adb shell，然后在输入top | grep com.*****.**
原理：
方法一是因为在cmd环境下，所以要用findstr
方法二是因为在shell环境下
终于解决了！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d3d23b02f01c9fdcdbc2367bf346ff3/" rel="bookmark">
			KVM虚拟化技术（二）之创建虚拟机（命令行方式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是邵奈一，一个不务正业的程序猿、正儿八经的斜杠青年。
1、世人称我为：被代码耽误的诗人、没天赋的书法家、五音不全的歌手、专业跑龙套演员、不合格的运动员…
2、这几年，我整理了很多IT技术相关的教程给大家，爱生活、爱分享。
3、如果您觉得文章有用，请收藏，转发，评论，并关注我，谢谢！
博客导航跳转（请收藏）：邵奈一的技术博客导航
| 公众号 | 微信 | 微博 | CSDN | 简书 |
教程目录 0x00 教程内容0x01 创建虚拟机1. 上传ISO镜像到服务器2. 创建虚拟机 0x02 配置虚拟机网络0x03 修改虚拟机的主机名0xFF 总结 0x00 教程内容 创建虚拟机配置虚拟机网络修改虚拟机的主机名 上一教程已经安装好了KVM，并且配置好了网桥，那么接下来就可以创建虚拟机了。其实过程非常简单，跟我们在VMware里创建虚拟机非常相似，只不过我们这里使用命令行方式创建而已。
0x01 创建虚拟机 1. 上传ISO镜像到服务器 2. 创建虚拟机 创建一个存放虚拟机系统的卷 qemu-img create -f qcow2 /var/lib/libvirt/images/base.qcow2 20G 参数说明-f指定卷的格式为qcow2/var/lib/libvirt/images虚拟机卷存放的默认路径base.qcow2完整卷名20G卷的大小 创建虚拟机 执行的命令如下：
virt-install \ -n base \ -r 4096 \ --vcpus 2 \ --disk /var/lib/libvirt/images/base.qcow2 \ --location /opt/iso/CentOS-7-x86_64-DVD-1908.iso \ --nographics \ --network bridge=br0 \ --network bridge=br0 \ --os-type linux \ --os-variant rhel7 \ --console pty,target_type=serial \ --extra-args 'console=ttyS0,115200n8 serial' 命令含义说明如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d3d23b02f01c9fdcdbc2367bf346ff3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f19a8ed118d801a99717f63efc0d4a5e/" rel="bookmark">
			《给java开发者的实操避坑指南》学习笔记——空指针和异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA空指针和异常 什么是空指针？
我们都知道java是没有指针的，这里说的java指针指的就是java的引用,我们不在这里讨论叫指针究竟合不合适，而只是针对这个异常本身进行分析。java中的空指针就是空引用，java空指针异常就是引用本身为空，却调用了方法，这个时候就会出现空指针异常。可以理解，成员变量和方法是属于对象的（除去静态），在对象中才存在相对应的成员变量和方法，然后需要通过对象去调用这些成员变量和方法。对于空指针来说，它不指向任何对象，也就没有所谓的成员变量和方法，这个时候用它去调用某些属性和方法，当然会出现空指针异常。
1、如何从根源避免空指针 首先我们来看一个代码实例，看看空指针会出现在哪些情况中
先构建一个静态的对象类User，对象属性包括name和address，对象方法有print()和readBook两个 public static class User{ private String name; private String[] address; public void print(){ System.out.println("这是User类"); } public String readBook(){ System.out.println("User在读书！"); return null; } } 再构建一个main方法，此处演示的是第一种空指针情况，即：调用了空对象的实例方法(未进行实例化) public static void main(String[] args) { User user = null; user.print(); } 来看看上面方法的运行结果如何
Exception in thread "main" java.lang.NullPointerException at com.wyf.escape.WhatIsNpe.main(WhatIsNpe.java:24) Process finished with exit code 1 可以看出，抛出了NullPointerException也就是我们通常所说的NPE空指针异常，且定位在java的24行也就是我们代码中的user.print();代码，因为user对象的引用都不存在，是为null 的，所以此处的null当然无法去调用print()方法。
第二种空指针情况：访问了空对象的属性 public static void main(String[] args) { User user = null; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f19a8ed118d801a99717f63efc0d4a5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4d5dda53ccc030df54cca8ab8eb71d0/" rel="bookmark">
			[C&#43;&#43;&amp;Rust]LeetCode No.525 连续数组(每日一题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原贴地址：http://blog.leanote.com/post/dawnmagnet/lc525
题目 给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。
示例 1:
输入: nums = [0,1] 输出: 2 说明: [0, 1] 是具有相同数量0和1的最长连续子数组。 示例 2:
输入: nums = [0,1,0] 输出: 2 说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。 提示：
1 &lt;= nums.length &lt;= 105nums[i] 不是 0 就是 1 思路分析 这道题画张图大家就明白了
每一条线上的任意两点之间，都是一个含有相同数量0和1的连续子数组。
想找到最长的子数组，就是找到每条线最右边的点到最左边的点的最大差值
所以我们就用哈希表来存最左边的点。
C++代码 class Solution { public: int findMaxLength(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, int&gt; m; int res = 0; m[0] = 0; vector&lt;int&gt; prefix(nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4d5dda53ccc030df54cca8ab8eb71d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e53cfc85a8f1ffda4ecb32f2e62585dc/" rel="bookmark">
			Tomcat应用部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat应用部署 一、初识Tomcat；1、概述：2、Apache与Tomcat的比较 二、Tomcat与jdk的关系；1、 图解2、解析3、Tomcat和JDK版本对应图 三、Tomcat内部工作原理；1、组件关联2、Container组件详解 四、Tomcat配置文件详解；五、案例：搭建Tomcat案例；（1）实验环境（2）实验目的（3）详细步骤 一、初识Tomcat； 1、概述： Tomcat是由Apache软件基金会下属的Jakarta项目开发的一个Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。由于Tomcat本身也内含了一个HTTP服务器，它也可以被视作一个单独的Web服务器。
2、Apache与Tomcat的比较 相同点：
1.两者都是Apache组织开发的
2.两者都有HTTP服务的功能
3.两者都是开源的
不同点：
1.Apache是专门用了提供HTTP服务的，以及相关配置的（例如虚拟主机、URL转发等等），而Tomcat是Apache组织在符合Java EE的JSP、Servlet标准下开发的一个JSP服务器.
2.Apache是一个Web服务器环境程序，启用他可以作为Web服务器使用，不过只支持静态网页。如果要在Apache环境下运行JSP的话就需要一个解释器来执行JSP网页，而这个JSP解释器就是Tomcat。
3.Apache侧重于HTTPServer ，Tomcat侧重于Servlet引擎，如果以Standalone方式运行，功能上与Apache等效，支持JSP，但对静态网页不太理想；
4.Apache是Web服务器，Tomcat是应用（Java）服务器，它只是一个Servlet（JSP也翻译成Servlet）容器，可以认为是Apache的扩展，但是可以独立于Apache运行。
中间件： JSP网页的解释器
Httpd: 能够解析html的页面，也就是所谓的静态页面
Tomcat： 既能解析html的页面，解析静态页面的能力远远不如httpd，又能解析jsp页面（为主）
Tomcat同类产品：
1.Resin 服务器 2.Jetty 服务器 3.JBoss服务器
4.WebSphere 服务器 5.WebLogic 服务器
二、Tomcat与jdk的关系； 1、 图解 2、解析 JDK是开发人员开发使用，JRE是用来运行java程序，就是java程序的运行环境，jvm是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行；
JDK中包含JRE，在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。jdk是java语言编写的，用来给java程序调用的，jvm因为与平台进行交互，是用c/c++和汇编语言编写的；
jdk是java运行和编译的，tomcat是web项目的运行容器，java没有jdk没办法编译运行，java运行必须依赖jdk的环境，所以安装tomcat前必须要安装jdk环境；
注解：
Java SE（Java Platform，Standard Edition）：Java SE 是做电脑上运行的软件；Java EE（Java Platform，Enterprise Edition）：Java EE 是用来做网站的（我们常见的JSP技术）；Java ME（Java Platform，Micro Edition）：Java ME 是做手机软件的； 3、Tomcat和JDK版本对应图 三、Tomcat内部工作原理； 1、组件关联 1、Tomcat 的心脏是两个组件：Connector 和 Container，Connector 组件是可以被替换，这样显得更加灵活，一个 Container 可以选择对应多个 Connector。多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了。所以整个 Tomcat 的生命周期由 Server 控制。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e53cfc85a8f1ffda4ecb32f2e62585dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ddc535477893b06a5883d55606c3b4a/" rel="bookmark">
			Unable to start embedded Tomcat（已解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决启动Springboot报错“Unable to start embedded Tomcat”
早晨还好好的 然后莫名其妙的卡死重新启动了一次以后就报错，用idea自带的启动工具启动没问题，但是用热部署插件jrebel启动的时候就报错。
解决办法（亲测有效）：
进入idea选择项目的Edit
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed01b02b4f96636feba5186a34cba251/" rel="bookmark">
			MYSOL基本用法（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 新增---------------insert into 表1名 select 列名 from 表2名 查询-----------------①select count(列名）from 表名； 获得列的数量
查询-----------------②select sum(列名）from 表名； 求数据总和
查询----------------③select avg(列名） From 表名； 求当前列平均值
查询----------------④select max(列名） from 表名； 获得该列最大值
查询-------------⑤select min(列名） from 表名； 获得该列最小值
分组查询-----------select 列名 from 表名 group by 列名； having 用法：select 列名 from 表名 group by 列名 having 条件； 先进行分组查询，再执行条件
//而select 列名 from 表名 where 条件 group by 列名；先执行where条件，再执行group by 分组；
联合查询-----select 列1，列2 from 表1，表2 where； 内连接------where 用法和 [inner] join on 都属于内连接 外连接-----①左外连接–select 列名 from 表1 left join 表2 on 连接条件； -------②右外连接------select 列名 from 表1 right join 表2 on 连接条件 ； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8ce3783bc2587d1c885008ec89277b0/" rel="bookmark">
			Android缓存一个int值,Android SharedPreferences工具类，可设置缓存时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		释放双眼，带上耳机，听听看~！
使用ACache也可以设置缓存时间，但ACache在清缓存的时候会被清空。
SharedPreferences存储默认都是无时间限制的。
大概思路是，存储的时候记录当前时间，要存多久。取数据的时候判断这个数据已经存储了多久，如果超过设置的存储时间，就获取默认值。
首先，我们需要一个存储的model——SpSaveModel
public class SpSaveModel implements Serializable{
private int saveTime;
private T value;
private long currentTime;
public SpSaveModel() {
}
public SpSaveModel(int saveTime, T value,long currentTime) {
this.saveTime = saveTime;
this.value = value;
this.currentTime=currentTime;
}
public long getCurrentTime() {
return currentTime;
}
public void setCurrentTime(long currentTime) {
this.currentTime = currentTime;
}
public int getSaveTime() {
return saveTime;
}
public void setSaveTime(int saveTime) {
this.saveTime = saveTime;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8ce3783bc2587d1c885008ec89277b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80fe7ac81dda4a1031df0ad7ee633235/" rel="bookmark">
			【Java实习生】每日面试题打卡——计算机网络篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		临近秋招，备战暑期实习，祝大家每天进步亿点点！Day14本篇总结的是 计算机网络 相关的面试题，后续会每日更新~文章参考自：硬核！30 张图解 HTTP 常见的面试题、JAVA开发面试题_网络_操作系统、计算机网络面试题、JavaGuide 1、OSI 七层结构、TCP/IP 四层结构、五层协议结构 OSI 七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。TCP/IP 四层：网络接口层、网际层、运输层、应用层。五层协议：物理层、数据链路层、网络层、运输层、应用层。 注：按照由下至上的顺序。
OSI 七层参考模型，每一层的作用：
对应的层作用对应的网络协议/硬件物理层提供数据传输的硬件保证，网卡接口，传输介质。中继器、集线器、网关.数据链路层进行数据交换，将要传输的数据转换为二进制形式。网卡、网桥、交换机网络层进行路由选择，网络互联。IP、ICMP、…传输层用于端到端的可靠数据传输。TCP 、UDP、…会话层用于建立用户级的连接，选择适当的传输服务。SQL、RPC、…表示层用于对数据的压缩、加密。JPEG、MPEG、ASII、…应用层提供用户服务，具体功能由应用程序实现。SMTP、HTTP、DNS、… 2、TCP 和 UDP 的区别？基于 TCP、UDP 的协议有哪些？ TCP 和 UDP 的区别？
TCP 提供面向连接的、可靠的数据流传输，而 UDP 提供的是无连接的、不可靠的数据流传输。TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。TCP 传输单位称为 TCP 报文段，UDP 传输单位称为用户数据报。TCP 注重数据安全性，UDP 数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。 面向连接与非面向连接区别？
面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。非面向连接地服务，不需要预先建立一个联络两个通信节点地连接，需要通信地时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输地过程中不再加以监控。 基于 TCP、UDP 的协议有哪些？
基于 TCP 的协议：
HTTP：Web服务器传输超文本到本地浏览器的传送协议。SMTP：邮件传送协议，用于发送邮件。服务器开放的是 25 号端口。FTP：定义了文件传输协议，使用21 端口。… 基于 UDP 的协议：
DNS：用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是53号端口。… TCP 与 UDP 的适用场景：
TCP：当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，HTTP、HTTPS、FTP等传输文件的协议会使用到。
UDP：当强调传输性能而不是传输的完整性时，要求网络通讯速度能尽量的快：如 QQ语音，QQ视频等。
3、TCP 协议如何保证可靠传输？ TCP 通过以下几种措施来保证数据的可靠传输：
① 对应用数据进行分割：将应用数据被分割成 TCP 认为最适合发送的数据块。② 对数据包进行编号：TCP 给要发送的每一个数据包进行编号，接收方按照编号对数据包进行排序，把有序数据传送给应用层。③ 校验和：这是一个端到端的校验，目的是检测数据在传输过程中的任何变化。如果接受端的校验有差错，说明数据在传输过程中出问题了，接收端将丢弃不再接受该数据。④ 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）⑤ 拥塞控制：当网络拥塞时，减少数据的发送。防止过多的数据注入到网络中，避免传输链路过载。⑥ ARQ协议：该协议也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。⑦ 超时重传：当 TCP 发出一个报文段后，它启动一个定时器，等待接收端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 滑动窗口和流量控制：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80fe7ac81dda4a1031df0ad7ee633235/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b886c6d2fe284a2e6c4cffc669a4336/" rel="bookmark">
			鸿蒙系统的特点,鸿蒙系统有什么特别之处
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鸿蒙系统已经正式发布了，在此发布会上华为官方对鸿蒙系统做了详细的介绍，小编这里就对此次发布会的问题进行了一个整理，错过直播的小伙伴们快来看看下面的华为鸿蒙OS系统优点介绍吧！
鸿蒙系统有什么特别之处
鸿蒙系统的特色分别体现在简单地控制、多设备终端连接、拉一拉无线传输、全新桌面、原子化卡片服务、极致性能及隐私安全等方面，下面是小编的详细介绍。
超级终端多设备终端连接
鸿蒙系统的最大特色便是超级终端控制，手机能够通过拉一拉、碰一碰轻松与电脑、平板、智能手表、智能家电、无线耳机、无人摄像头等终端设备 进行连接。图片、文件等内容传输都更快速便捷，不论是日常用还是办公都是非常不错的。
与智能家电碰一碰就能实现手机操控，更加方便，并且目前已经支持方太、美的、苏泊尔、九阳等几十种家电的支持。
全新桌面
此次鸿蒙系统在桌面上采用了全新的原子化卡片服务，在进行应用分类时会自动帮助用户进行相似应用归类，分类管理更高效，分类组件支持放大，通过分类组件可直接进入软件，实现一屏一场景。采用卡片式操作，用户们可以以卡片方式分享文章、页面等内容、无需下载，好友直接就能打开观看。
极致性能
性能方面实现了渲染和逻辑分离、对固定模式空间管理进行了调整，告别了传统的硬件组合方式，让手机帧率逻辑更饱满、操作更流畅、续航时间更长，性能更流畅。
隐私安全
采用了更高级别的隐私保护功能，全面保护用户们的使用隐私安全，支持开启多设备协同认证，提升安全性。
好了，以上就是小编今天带来的分享了。想要了解更多鸿蒙系统消息就来iefans鸿蒙最新消息专区，快快收藏吧，更多精彩不容错过！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f3fc7f05698d8b62a708383fc915042/" rel="bookmark">
			Linux虚拟机安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux虚拟机安装教程 第一步 第一步 点击创建新的虚拟机
第二步：选择自定义
第三步：选择与自己兼容的虚拟机版本，点击下一步
第四步：选择骚猴安装操作系统，点击下一步。
第五步：选择linux操作系统，版本选择自己要安装的版本，点击下一步
第六步：给虚拟机命名，以及选择虚拟机安装路径。
第七步：处理器内核总数不能超过电脑的总核数
第八步：配置内存
双击
点击开启虚拟机
选择中文
设置日期时间
点击软件选择
选择最小安装
选择安装位置
设置密码
点击重启
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f14888a62678ec6e1825dcdfe9ecea70/" rel="bookmark">
			delete from 和 truncate table区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里truncate table 等于delete from 的全量删除，可以从下面几个方面比较：
1、全量删除速度（truncate &gt; delete ）：
如下图所示：
2、事务
truncate table 是 DDL语句，可以手动控制事务的开启、提交和回滚的.
delete 是 DML语句，是隐性提交的，不能rollback.
3、是否支持条件删除
delete支持条件删除，如delete from where .......
truncate table只能全量删除，不能条件删除
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/588ee9d3a719ca6a68448791b1556608/" rel="bookmark">
			【CUDA编程】二：实现图像滤波和K均值聚类算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面介绍了几个简单的CUDA程序，这里再举两个更具体的应用。为简单记，用python写。
图像滤波 图像滤波是用一个带参数滤波器(也可以称为核，也可以称为模板)对图像逐像素点处理，通常是对像素邻域进行加权和。
这里以能够提取边缘的索贝尔算子作为例子。
import pycuda.autoinit import pycuda.driver as drv from pycuda.compiler import SourceModule import cv2 import math import numpy as np """ 通用的图像滤波核函数 """ mod = SourceModule(""" __global__ void applyFilter(const unsigned char *input, unsigned char *output, const unsigned int width, const unsigned int height, const float *kernel, const unsigned int kernelWidth) { const unsigned int col = threadIdx.x + blockIdx.x * blockDim.x; const unsigned int row = threadIdx.y + blockIdx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/588ee9d3a719ca6a68448791b1556608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2beb03ba970a5e43b1c9225008573cce/" rel="bookmark">
			轻量级神经网络设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 深度神经网络模型被广泛应用在图像分类、物体检测等机器视觉任务中，并取得了巨大成功。然而，由于存储空间和功耗的限制，神经网络模型在嵌入式设备上的存储与计算仍然是一个巨大的挑战。
目前工业级和学术界设计轻量化神经网络模型主要有4个方向：
人工设计轻量化神经网络模型基于神经网络架构搜索(Neural Architecture Search,NAS)的自动化设计神经网络CNN模型压缩基于AutoML的自动模型压缩 本文首先介绍基本卷积计算单元，并基于这些单元介绍MobileNet V1&amp;V2，ShuffleNet V1&amp;V2的设计思路。其次，最后介绍自动化设计神经网络的主流方法和基本思路。最后概述CNN模型压缩的主要方法，详细说明基于AutoML的自动模型压缩的相关算法：AMC、PockFlow以及TensorFlow lite的代码实现。
基本卷积运算 标准卷积 卷积层的 输入为$(N,C_{in},H_{in},W_{in})$。输出为 $(N,C_{out},H_{out},W_{out})$，其中$H_{\text{out}}$和$W_{\text{out}}$ 分别为特征图的高度和宽度。卷积核(Kernel)的高和宽：$K[0]$和$K[1]$ $$FLOPS=(C_{in}*K[0]·K[1])*H_{\text{out}}·W_{\text{out}}*C_{out}\quad(考虑bias)$$
输出特征图中有$H_{\text{out}}*W_{\text{out}}*C_{out}$个像素；每个像素对应一个立体卷积核$k[0]*k[1]*C_{in}$在输入特征图上做立体卷积卷积出来的；而这个立体卷积操作，卷积核上每个点都对应一次MACC操作
图3标准卷积：空间维度和通道维度示意图
吃个例子
输入shape为(7*7*3)，卷积核大小为(filter size)(3*3*3)，卷积核个数(filter num \ channel_out)为2，输出shape为(3*3*2)。
Grouped Convolution 分组卷积是标准卷积的变体，其中输入特征通道被为G组(图4)，并且对于每个分组的信道独立地执行卷积，则分组卷积计算量为标准卷积计算量的1/G：
$$FLOPS=\frac{(C_{in}*K[0]*K[1])*H_{\text{out}}*W_{\text{out}}*C_{out}}{G}$$
分组卷积：空间维度和通道维度示意图
Depthwise convolution 引用：Chollet F. Xception: Deep learning with depthwise separable convolutions[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2017: 1251-1258.
Depthwise convolution 是指将输入特征图$(batch\_size, H\_{in}, W\_{in}, C\_{in})$分为group组，Group=$C\_{in}$(既Depthwise 是Grouped Convlution的特殊简化形式)，然后每一组做k*k卷积，Depthwise convolution的计算量为普通卷积的$1/C_{in}$，通过忽略通道维度的卷积显著降低计算量
$$FLOPS=K[0]*K[1]*H_{\text{out}}*W_{\text{out}}*C_{in}$$
Depthwise相当于单独收集每个Channel的空间特征。
Depthwise卷积：空间维度和通道维度示意图
pointwise convolution Pointwise是指对输入$(batch\_size, H\_{in}, W\_{in}, C\_{in})$做$k$个普通的 1x1卷积，主要用于改变输出通道特征维度，相当于在通道之间“混合”信息。Pointwise计算量为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2beb03ba970a5e43b1c9225008573cce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a2f4245ed63f27fcb9d95964c33134b/" rel="bookmark">
			华为mate 10升级鸿蒙,华为10款机型升级EMUI11，为鸿蒙做准备，荣耀脱离这是要大变革？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为Mate 40就要来了，这也是几年来唯一能和iPhone 12叫板的国产旗舰机型，很多花粉甚为期待。同时我们也知道，华为Mate 40将成为华为系中最后的麒麟芯片绝版机型，让人格外珍惜。华为手机这几年的快速发展，给我们带来了太多“黑科技”，最为自豪的就是自研芯片与鸿蒙系统，那么华为下一步将往哪个方向发展，鸿蒙系统将是重点。
在上个月的华为2020开发者大会上，华为不仅发布了鸿蒙2.0，而且明确表示年底该系统就会面向开发者推送Beta测试版，最早明年年初就会对部分机型开放，需要注意的这个“部分机型”会优先考虑EMUI11手机。而EMUI11就是这次华为Mate 40新机要首发应用的，不仅如此，在它正式到来前夕，华为又有了新动作，宣布10款机型升级EMUI11公测，这是为鸿蒙在做准备了。
这10款机型有华为P40系列三款机型、华为Mate 30系列五款产品、还有两款华为MatePad Pro产品。可以看出，这些产品都是华为当前的高端旗舰产品，拥有不少华为的尖端技术，是华为的代表作。
如无意外，再加上华为Mate 40系列新品，它们既是EMUI11的首批应用机型，也可能是鸿蒙2.0的首批尝鲜者。这也就意味着，如果大家手中有这些产品，或现在要及时升级EMUI11，才能在第一时间体验鸿蒙2.0。
那么，EMUI11是否值得升级呢？答案当然是肯定的。且不说EMUI系统发展升级这么多年，已经非常成熟稳定，与此同时它实际上已然有了不少鸿蒙的影子。比如分布式技术应用明显，支持多设备互连、多屏协同，可以实现文件快速传输等高效操作，这与鸿蒙的万物互联核心理念都是相同的。
除此之外，EMUI11还有诸多人因UX设计、全场景体验等亮点。所以，EMUI11不仅值得升级体验，而且过渡鸿蒙2.0也将十分自然顺利。
话说回来，大家看这10款升级EMUI11的产品中，没有一款荣耀产品，就连今年的荣耀数字系列新机荣耀30都没有涵盖其中。这一点颇为耐人寻味，更加印证了荣耀即将脱离华为这个事实。华为出售旗下的荣耀子品牌后，将腾出更多的精力、物力、财力来解决芯片断供困境，以及鸿蒙系统的全面打磨。而芯片问题，除了外购显然不是一时半刻能实现自主生产的，所以鸿蒙系统就成了这两年华为的重中之重。
接下来，荣耀脱离、鸿蒙全面上线这些华为的大变革或将都会一一到来，大家觉得华为可以凭借鸿蒙系统翻盘缺芯少芯的手机业务吗？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3ce2df44ffd97b8e0404ee3d5bb155f/" rel="bookmark">
			{dataSource-1} closing ... {dataSource-1} closed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看看是不是启动错类了。
要启动SpringBoot的主程序类
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a65a652dd8c4602f7cee4882ad67a30f/" rel="bookmark">
			LTE中RB和RE、REG、CCE的定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RB(Resource Block)：频率上连续12个子载波，时域上一个slot，称为1个RB。如下图左侧橙色框内就是一个RB。根据一个子载波带宽是15k可以得出1个RB的带宽为180kHz。
RE(Resource Element)：频率上一个子载波及时域上一个symbol，称为一个RE，如下图右下角橙色小方框所示。
二、RB与占用带宽计算：
占用带宽=子载波宽度*每RB的子载波数*RB数目
其中每个子载波宽度=15K，每RB的子载波数=12；
20M带宽对应100个RB(1200个子载波)，算出实地带宽=18M，加上2M的保护带，合计为20M。
LTE中REG和CCE概念
REG是Resource Element Group的缩写，一个REG包括4个连续未被占用的RE。REG主要针对PCFICH和PHICH速率很小的控制信道资源分配，提高资源的利用效率和分配灵活性。如下图左边两列所示，除了RS信号外，不同颜色表示的就是REG。
CCE是Control Channel Element的缩写，每个CCE由9个REG组成，之所以定义相对于REG较大的CCE，是为了用于数据量相对较大的PDCCH的资源分配。每个用户的PDCCH只能占用1，2，4，8个CCE，称为聚合级别。如下图所示：
举例说明：
LTE支持的子载波宽度为15KHZ和7.5KHZ，也就是指的是子载波的间隔
每个PRB带宽为180KHZ
每RB子载波数目：180/15=12
5G支持的子载波宽度为30KHZ，也就是指的是子载波的间隔。
每个PRB带宽为360KHZ
每RB子载波数目：360/30=12
比如100M频谱带宽（也叫系统带宽）
子载波数：3264
子载波宽度：30KHZ
传输带宽（也叫测量带宽）：3264*30=97920KHZ=97.92MHZ
占用带宽=子载波宽度*每RB子载波数目*RB数目
剩下的100MHZ-97.92MHZ=2.08MHZ带宽就分布在两边，起保护作用的，这个就是保护带宽。
其他：
频点的定义是固定频率带宽的一个编号，只是一个编号而已，例如TD-LTE D频段频率范围为2575～2635MHz，而LTE规定的频率带宽为20MHz（即频率间隔为20MHz），那么d频段共60MHz带宽就可以分为1，2，3共3个频点。
TD-LTE每个小区的带宽最大只能配置20MHZ，每个小区只有一个中心频点（也称 载波频点）；
同频小区：中心频点相同的小区
异频小区：中心频点不同的小区
子载波：LTE采用的是OFDM技术，不同于WCDMA采用的扩频技术，每个symbol占用的带宽都是3.84M，通过扩频增益来对抗干扰。OFDM则是每个Symbol都对应一个正交的子载波，通过载波间的正交性来对抗干扰。协议规定，通常情况下子载波间隔15khz，Normal CP(Cyclic Prefix)情况下，每个子载波一个slot有7个symbol；Extend CP情况下，每个子载波一个slot有6个symbol。下图给出的是常规CP情况下的时频结构，从竖的的来看，每一个方格对应就是频率上一个子载波。
LTE中
10ms是一帧；
5ms一个半帧；
1ms是一个子帧，1ms作为LTE的一个调度时间单位，称为一个TTI（transmission time-interval）；
1ms分成2个时隙slot，每个是0.5ms，每个slot在普通CP模式下分成7个符号，扩展CP模式下分成6个符号；
CP是循环前缀的意思；
符号（即symbol）是时域上最小范围，一个symbol是0.5/7ms（大约70us）；
一个symbol传输多少比特，就需要看是多少QAM（256QAM就是8bit，64QAM就是6bit），即星座图。
补充：
10ms一帧345G都一样这个没变；
5G低频子载波宽度是30KHZ，高频子载波宽度有120KHZ和240KHZ的选择，所以TTI变化了，低频的TTI是0.5ms，高频的TTI是0.125ms（对应的是120KHZ子载波宽度）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8402a3cf638c949bfa3e75a94708b664/" rel="bookmark">
			gRPC-09 传递header信息/元数据 [golang版]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码地址 https://github.com/wanmei002/grpc-learn/tree/master/ch08
逻辑都在拦截器里实现了，可以直接看 拦截器 的代码
介绍 像一些 token 等数据 我们可能希望通过 header头传递，gRPC的数据先传递到 context 里，然后再写到 header 头里，然后
传递给另一端。
直接上代码 客户端 header 数据的写入 需要导入 google.golang.org/grpc/metadata 这个包
headerData := metadata.Pairs("timestamp", strconv.Itoa(int(time.Now().Unix())), "token", "123") ctxH := metadata.NewOutgoingContext(ctx, headerData) // 后续也可以往后面添加数据 ctxH = metadata.AppendToOutgoingContext(ctxH, "kay1", "val1", "key2", "val2") ctxH就是一个上下文，请求服务端时，传的 context.Context 替换成 ctxH 就行
读取 header 信息 header 头信息也可能通过 trailer 传递
一元模式读取 header 信息 var header, trailer metadata.MD // 调用服务端方法的时候可以在后面传参数 serverRetMsg, err := client.RPCMethod(ctx, &amp;Struct, grpc.Header(&amp;header), grpc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8402a3cf638c949bfa3e75a94708b664/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bebdc938240ce18e48f1d18465ca808/" rel="bookmark">
			ClassCastException:ArrayList cannot be cast to class.Account
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 bug分析 java.lang.ClassCastException: class java.util.ArrayList cannot be cast to class com.lwh.pojo.Account 报错翻译
java.lang.ClassCastException: class java.util.ArrayList不能被转换为class com.lwh.pojo.Account
其实就是list类型的数据不能转化成实例型的
错误情况 解决方案 @Override public Account findByid(int id) { List &lt; Account&gt; accounts = getJdbcTemplate().query("select * from account1 where id=?", new BeanPropertyRowMapper&lt;Account&gt;(Account.class) ,id); return accounts.get(0)；//加个get(0)返回第一个实例就行了 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7efe0d865bb6de8d42e392fcbf9e798d/" rel="bookmark">
			Z 字形变换（java版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。
比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：
P A H N
A P L S I I G
Y I R
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：“PAHNAPLSIIGYIR”。
请你实现这个将字符串进行指定行数变换的函数：
string convert(string s, int numRows);
示例 1：
输入：s = “PAYPALISHIRING”, numRows = 3
输出：“PAHNAPLSIIGYIR”
示例 2：
输入：s = “PAYPALISHIRING”, numRows = 4
输出：“PINALSIGYAHRPI”
示例 3：
输入：s = “A”, numRows = 1
输出：“A”
解法：
class Solution { public String convert(String s, int numRows) { if(numRows == 1){ return s; } StringBuilder ret = new StringBuilder(); int len = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7efe0d865bb6de8d42e392fcbf9e798d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/142a2675ed1bab933cb114113f914376/" rel="bookmark">
			KVM教程（1）安装KVM与虚拟机的基本管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KVM是一个基于内核的虚拟机（kernel virtual machine），从Linux内核版本号2.6.20开始已经集成在系统之中。这样要部署虚拟机就不需要额外的软件来支持，效率更高。但是KVM只能虚拟化CPU和内存，对于磁盘、网卡等外设无法模拟，所以需要结合QEMU来模拟其他设备（QEMU虽然也可以模拟CPU和内存，但是效率没有KVM高），也因此KVM其实是QEMU-KVM。
PS：如果虚拟机有安装VirtIO半虚拟化驱动的话能提高虚拟机性能，好在主流Linux系统已经内置了相关驱动，而Windows虚拟机就需要去KVM下载相关驱动了，查询方法：
lsmod | grep virtio 一、宿主机安装KVM
1、用VMware做实验的话第一步就是开启CPU虚拟化功能
2、检查宿主机CPU虚拟化是否开启、KVM内核是否加载 egrep "svm|vmx" /proc/cpuinfo #查看CPU是否开启虚拟化（Inter是vmx，AMD是svm），如果过滤出的flags有内容就是已开启了 lsmod | grep kvm #查看KVM内核是否加载 3、使用yum安装KVM相关软件包 yum install qemu-kvm libvirt virt-install virt-manager bridge-utils #qemu-kvm：核心软件包，实现虚拟化 #libvirt：核心软件包，管理KVM的工具，类似VMware也是管理虚拟机的工具 #virt-install：KVM虚拟机命令行管理工具 #virt-manager：KVM虚拟机图形化管理工具，可不装 #bridge-utils：实现网卡桥接的工具 4、启动libvirtd服务（如果该服务没启动的话virt-install等工具也无法使用）。该服务启动后系统会新增一块virbr0的网卡，该网卡的地址就是虚拟机使用NAT模式时使用的地址。 systemctl enable libvirtd.service systemctl start libvirtd.service 5、为KVM创建桥接网络
KVM默认使用NAT模式来分配网络给虚拟机，在使用NAT模式时虚拟机可以访问外网，但外网无法直接访问虚拟机。所以生产环境更多是配置网桥实现桥接模式上网，让虚拟机与宿主机处于一个网段中，各自有一个自己的IP，可以把他们看成是一个局域网中的不同电脑。配置桥接模式有2种方式：
通过命令行配置桥接模式，该命令会修改配置文件实现永久生效
virsh iface-bridge eth0 br0 #把eth0网卡绑定到br0中 手动编辑配置文件实现桥接模式： vim /etc/sysconfig/network-scripts/ifcfg-br0 #为br0新建配置文件 DEVICE=br0 TYPE=Bridge #类型为桥接 BOOTPROTO=static IPADDR=192.168.1.100 #配置能上网的IP地址，通常就是之前主机的IP NETMASK=255.255.255.0 GATEWAY=192.168.1.1 NBOOT=yes vim /etc/sysconfig/network-scripts/ifcfg-eth0 #将eth0绑定到桥接网络中 DEVICE=eth0 BRIDGE=br0 #这句就是把eth0桥接到br0 ONBOOT=yes 也可以通过命令行模式配置网卡，但是一定要把这些命令写到脚本中一起执行，否则网络就断了 #!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/142a2675ed1bab933cb114113f914376/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af4f43cf0773036474eb76c648d443cb/" rel="bookmark">
			python数据结构——单调栈和单调队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单调栈 数据结构栈遵循先进后出的原则，在python中，利用list就可以实现栈的功能
stack = [] stack.append(1) stack.append(2) print(stack.pop()) #2 单调栈遵循单调增或者单调减的原则，用于处理某些特别的任务，也就是常说的next greater element的问题。
class MStack: def __init__(self): self.stack = [] def push(self, value): while self.stack and stack[-1] &lt;= value: self.pop() self.stack.append(value) def pop(self): return self.stack.pop(-1) 例如，给定一个数组，求出每个数后面更大的数，这就是一个 基础next greater element的问题。比如数组是[3, 1, 2, 8, 3, 5]，返回的结果为[8, 8, 8, -1, 5, -1]，3的下一个最大的数为8，后面同理，8后面最大的数不存在，所以是-1。
这类题目的解法都基于如上的单调栈框架:
def nextGreatNumber(nums): n = len(nums) ans = [-1 for _ in range(n)] stack = [] for i in range(n-1, -1, -1): while stack and stack[-1] &lt;= nums[i]: stack.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af4f43cf0773036474eb76c648d443cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07b785d811ce3b40cc47eea6765ed4f9/" rel="bookmark">
			两个线程交替打印数字和字母，输出1A2B3C4D...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、问题描述二、3种解决方法2.1、synchronized与wait/notify2.2、LockSupport与park/unpark2.3、ReentrantLock与await/singal 一、问题描述 实现一个程序，两个线程交替打印数字和字母，输出1A2B3C4D…，必须先打印数字。
正确输出结果：1A2B3C4D5E6F7G8H 二、3种解决方法 2.1、synchronized与wait/notify import java.util.concurrent.atomic.AtomicBoolean; /** * 交替打印字母与数字 * 1A2B3C... * 保证先打印数字 * @author IT00ZYQ * @date 2021/5/31 21:13 **/ public class Q03_Synchronized_wait_notify { public static void main(String[] args) throws InterruptedException { Object lock = new Object(); char[] cc = "ABCDEFGH".toCharArray(); char[] nn = "12345678".toCharArray(); // tag变量是为了保证数字线程先打印，防止出现A1B2... AtomicBoolean tag = new AtomicBoolean(false); new Thread(() -&gt; { synchronized (lock) { for (int i = 0; i &lt; nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07b785d811ce3b40cc47eea6765ed4f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a590b17f3947d201bde7fbe131750da/" rel="bookmark">
			使用Scrapy爬取豆瓣图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Scrapy爬取豆瓣某影星的所有个人图片
以莫妮卡·贝鲁奇为例
一：首先我们在命令行进入到我们要创建的目录，输入 scrapy startproject banciyuan 创建scrapy项目
创建的项目结构如下
二：为了方便使用pycharm执行scrapy项目，新建main.py
from scrapy import cmdline cmdline.execute("scrapy crawl banciyuan".split()) 再edit configuration
然后进行如下设置，设置后之后就能通过运行main.py运行scrapy项目了
三：分析该HTML页面，创建对应spider
from scrapy import Spider import scrapy from banciyuan.items import BanciyuanItem class BanciyuanSpider(Spider): name = 'banciyuan' allowed_domains = ['movie.douban.com'] start_urls = ["https://movie.douban.com/celebrity/1025156/photos/"] url = "https://movie.douban.com/celebrity/1025156/photos/" def parse(self, response): num = response.xpath('//div[@class="paginator"]/a[last()]/text()').extract_first('') print(num) for i in range(int(num)): suffix = '?type=C&amp;start=' + str(i * 30) + '&amp;sortby=like&amp;size=a&amp;subtype=a' yield scrapy.Request(url=self.url + suffix, callback=self.get_page) def get_page(self, response): href_list = response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a590b17f3947d201bde7fbe131750da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc7dba3b773d27666cbd58a742cfa52d/" rel="bookmark">
			相机模型-鱼眼模型/鱼眼镜头标定基本原理及实现(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题:
1 广角/超广角与鱼眼摄像机,角度界限
2 畸变模型中radtan畸变模型与鱼眼畸变模型在小于150范围是否都时能适用. (同数据,拟合模型不同,,参数结果不同,不欠拟合和过拟合就可)
3 FOV畸变模型与鱼眼畸变模型中体视投影的关系.
鱼眼相机模型 （fisheye camera model）
模型介绍
等距投影
等立体角投影
正交投影
体视投影
线性投影
Kannala-Brandt 模型
去畸变过程
投影过程
反投影过程
雅可比计算
之前总结了一下针孔相机的模型，然后得到了比较积极的回复（其实是我到处求人关注的，虽然截至到目前才三个人），所以就再接再励，乘胜追击（也没得办法，夸下的海口，跪着也要做完），继续总结其他相机模型。
模型介绍 鱼眼相机相较于针孔相机来说，视野更广，但畸变也更加严重，因此普通的针孔模型已不适用。鱼眼镜头的基本构造如图所示，经过多个镜头的折射，最终到达成像单元上。文章中所有图片均来自于网络，非本人所绘。
一般情况下，可以通过控制光线的路径来设计各种各样的镜头类型，根据投影方式的不同，可以将这些镜头分为等距投影、等立体角投影、正交投影、体视投影以及线性投影。
等距投影
r = f θ r=f*θ
等立体角投影
r = 2 f s i n ( θ /2 ) r=2*f*sin(θ/2​)
正交投影
r = f s i n ( θ ) r=f*sin(θ)
体视投影
r = 2 f t a n ( θ/ 2 ) r=2*f*tan(θ/2​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc7dba3b773d27666cbd58a742cfa52d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25339801066c67956b89d235999a8a74/" rel="bookmark">
			html中左浮动怎么写,div css float浮动用法(left right)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		div+css中float认识及css float用法，DIV CSS float浮动知识用法与float浮动教程篇
Css样式的float浮动属性，用于设置标签对象(如：
标签盒子、 标签、标签、标签等html标签)的浮动布局，浮动也就是我们所说标签对象浮动居左靠左(float:left)和浮动居右靠右(float:right)。 float是什么意思？
float是浮动，翻译成中文也是浮动意思。进入对应css手册中float手册了解float基本信息。
float的作用
通过css定义float(浮动)让div样式层块，向左或向右(靠)浮动。
一、float语法 - TOP
Float常跟属性值left、right、none
Float:none 不使用浮动
Float:left 靠左浮动
Float:right 靠右浮动
float语法：
float : none | left |right
参数值：
none : 对象不浮动
left : 对象浮在左边
right : 对象浮在右边
Float浮动结构分析图
接下来我们来通过一个div+css实例讲解float使用技巧。
二、float应用与用法 - TOP
Float浮动用于设置对象靠左与靠右浮动样式，可以实现我们所需要的让DIV、SPAN等标签居左居右浮动。
简单使用语法
div{float:left} /* css注释：设置div对象浮动靠左(left) */
div{float:right} /* css注释：设置div对象浮动靠右(right) */
三、css float浮动案例 - TOP
我们设置一个盒子里，一个靠右、一个靠左浮动2个盒子，为了直观看到css浮动布局效果，我们对两个盒子设置一定宽度、高度和边框。
1、主要的html代码片段：
布局靠左浮动
布局靠右浮动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b63ddaf49fc83ded6e0c6d156f68af51/" rel="bookmark">
			【CUDA编程】一：从简单的实例入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提 拥有NVIDIA的显卡-配置好cuda有C/C++基础Linux系统 基础知识 看看这篇吧CUDA基础知识
以后有空再自己写。
了解以下几个概念：
线程 thread
线程块 thread block
线程格 thread grid
代码1：简单加法 了解 如何创建GPU调用的函数
了解 一些基础函数
/* * 文件名 helloworld.cu * 编译： nvcc -o helloworld helloworld.cu */ #include &lt;iostream&gt; #include &lt;stdio.h&gt; /* * __global__ 用于修饰在gpu上运行且由cpu调用的函数 * 类似的，__device__ 用于修饰在gpu上运行且由gpu调用的函数,本例不涉及 */ __global__ void k_add (int a, int b, int* c ){ *c = a+b; } /* * __host__用于修饰在cpu上运行的函数，一般缺省 */ int main(void){ int h_c;//h前缀表示host,指cpu的变量 int *d_c;//d前缀表示device,指gpu的变量 /* * cudaMalloc功能类似malloc * 第一个参数是指向地址的地址变量(&amp;d_c)，第二个参数是分配显存的大小 * 函数会修改&amp;d_c指向的变量，完成对d_c的赋值 * (void**)是为了让函数无需关心d_c的类型 */ cudaMalloc((void**)&amp;d_c, sizeof(int)); /* * gpu函数调用时有&lt;&lt;&lt; &gt;&gt;&gt; * 其中第一个变量表示使用几个线程块，第二个变量表示一个线程块使用几个线程 */ k_add&lt;&lt;&lt;1,1&gt;&gt;&gt;(2,7,d_c); /* * cudaMemcpy功能类似memcpy * 在cpu中不能解引用gpu变量，必须先将变量从显存复制到内存上才能访问 * 最后一个参数指定复制的方向 */ cudaMemcpy(&amp;h_c, d_c,sizeof(int),cudaMemcpyDeviceToHost); /* * cudaFree功能类似free */ cudaFree(d_c) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b63ddaf49fc83ded6e0c6d156f68af51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/384add1e9682febf1eee6d65d8eeb960/" rel="bookmark">
			Echarts K线图中dataZoom,滚动条左右两边文字更改颜色样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dataZoom: [{ textStyle: { color: this.father //滚动条两边字体样式 }, dataBackground: { areaStyle: { opacity: 0.9, color: '#ff3131', width: 0.5 }, lineStyle: { opacity: 0.9, color: '#ff3131', width: 0.5 } }, type: 'slider', show: true, height: '3.5%', bottom: '12ph', //这里设置滚动条样式,和滚动条手柄样式 borderColor: '#8FDFFE', backgroundColor: 'rgba(183,233,252,0.6)', handleIcon: 'M512 512m-208 0a6.5 6.5 0 1 0 416 0 6.5 6.5 0 1 0-416 0Z M512 192C335.264 192 192 335.264 192 512c0 176.736 143.264 320 320 320s320-143.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/384add1e9682febf1eee6d65d8eeb960/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4f2592a8a7c360fe95fcc120fbad5b6/" rel="bookmark">
			AD20整板铺GND过孔错误：unable to locate any suitable location netgnd
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 AD将PCB整板铺GND过孔时，出现错误：unable to locate any suitable locations on net gnd
这个好解决。
错误提示为：无法在 net gnd 上找到任何合适的位置。
然后回头一想？是不是还没有在 Top Layer 和 Botton Layer 上对GND进行铺铜？
…啊，就这…啊不是，这就…
AD20 整板铺铜 先将板框全部选中，快捷键 T V G。
生成后的铺铜区域有些不如人意，需要人为进行一些修改。
将参数改为如下。（调整网络连接为GND、铺实心铜、相同GND网络的连接用铺铜覆盖）
之后重新铺铜。选中铺铜区域，右键 - 铺铜操作 - 重铺选中的铺铜。
铺铜后的效果。
Bottom Layer同理。
AD20整板铺GND过孔 将整版放置GND过孔，减少回流路径，详见：
Altium AD20整板放置GND过孔、批量放置GND过孔/缝合孔 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd47935eb039de7fd2aefd3613c8ad18/" rel="bookmark">
			[Vue warn]: Error in v-on handler: “ReferenceError: Vue is not defined“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
这块输出就是这个错误
求解决方式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/621335d3f19efdebcacea56a3f4ad276/" rel="bookmark">
			python与数据结构——LRU缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LRU缓存机制 LRU缓存机制有几个特点：
缓存cache是带有容量的缓存必须有顺序之分，以区分最近使用和久未使用的数据（读数据也算使用）读和写数据都比如快，时间复杂度为O(1) 为达到上述目的，LRU缓存算法的核心数据结构就是哈希链表，即双向链表和哈希表的结合。双向链表维护的是使用数据的顺序关系，哈希表方便读写操作。
# 双向链表 class ListNode: def __init__(self, key=None, value=None): self.key = key self.value = value self.prev = None self.next = None # LRU缓存 class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.hashmap = {} self.head = ListNode() self.tail = ListNode() self.head.next = self.tail self.tail.prev = self.head	def get(self, key): pass def put(self, key, value): pass 这样，基础的框架就有了，现在来实现lru的两个api，get和put，在定义这两个方法之前，需要弄清楚，首先，无论是get还是put，都需要更新一次双向链表，主要就是把操作的元素移到链表头，其次，再put方法之后，如果链表的长度超过了容量，就需要删除链表尾的元素。因此，整个代码结构可以写为：
class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/621335d3f19efdebcacea56a3f4ad276/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2076a530854203a3619f0436f54ef8f3/" rel="bookmark">
			JavaScript模块化 （CommonJS、AMD、CMD和ES6&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CommonJS 说明： 每一个模块都可以当做一个模块
在服务端：模块的加载是运行时同步加载的
在浏览器端：模块需要提前编译打包处理（浏览器不认识require）
基本语法 暴露模块 module.exports = value
exports.xxx = value
问题： 暴露的模块到底是什么
引入模块 require(xxx)
第三方模块：xxx为模块名
自定义模块：xxx为模块文件路径
服务器样例 //module1.js //给暴露对象赋值一个对象 module.exports = { uname : "module1" foo () { console.log(this.uname); } } //module2.js //暴露对象赋值一个方法 module.exports = function (){ console.log('module2'); } //module3.js //给暴露对象添加属性 exports.foo = function() { console.log('module3'); } exports.bar = function() { console.log('module3'); } //app.js let module1 = require('./modules/module1'); let module2 = require('./modules/module2'); let module3 = require('./modules/module3'); module1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2076a530854203a3619f0436f54ef8f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/770498257acbce43b51200c836910c59/" rel="bookmark">
			Android应用间共享目录,FileProvider（应用间共享文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可参考《第一行代码》第八章8.3内容。
简介
Android 7.0强制启用了被称作 StrictMode的策略，带来的影响就是你的App对外无法暴露file://类型的URI了。
如果你使用Intent携带这样的URI去打开外部App(比如：打开系统相机拍照)，那么会抛出FileUriExposedException异常。
官方给出解决这个问题的方案，就是使用FileProvider
FileProvider使用步骤
manifest中申明FileProvider
res/xml中定义对外暴露的文件夹路径
生成content://类型的Uri
给Uri授予临时权限
使用Intent传递Uri
1.manifest中申明FileProvider：
...
...
android:name="android.support.v4.content.FileProvider"
android:authorities="com.mydomain.fileprovider"
android:exported="false"
android:grantUriPermissions="true"&gt;
...
...
android:name：provider你可以使用v4包提供的FileProvider，或者自定义您自己的，只需要在name申明就好了，一般使用系统的就足够了。
android:authorities：类似schema，命名空间之类，后面会用到。
android:exported：false表示我们的provider不需要对外开放。
android:grantUriPermissions：申明为true，你才能获取临时共享权限。
2. res/xml中定义对外暴露的文件夹路径：
新建file_paths.xml，文件名随便起，后面会引用到。
name：一个引用字符串。
path：文件夹“相对路径”，完整路径取决于当前的标签类型。path可以为空，表示指定目录下的所有文件、文件夹都可以被共享。
这个元素内可以包含以下一个或多个，具体如下：
注意：external-cache-path在support-v4:24.0.0这个版本并未支持，直到support-v4:25.0.0才支持，最近适配才发现这个坑!
以上是官方提供的几种path类型，不过如果你想使用外置SD卡，可以用这个
物理路径相当于/path/
编写好file_paths.xml，我们在manifest中的provider这样使用：
android:name="android.support.v4.content.FileProvider"
android:authorities="com.mydomain.fileprovider"
android:exported="false"
android:grantUriPermissions="true"&gt;
android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/file_paths" /&gt;
3.生成content://类型的Uri
我们通常通过File生成Uri的代码是这样：
File picFile = xxx;
Uri picUri = Uri.fromFile(picFile);
这样生成的Uri，路径格式为file://xxx。前面我们也说了这种Uri是无法在App之间共享的，我们需要生成content://xxx类型的Uri，方法就是通过Context.getUriForFile来实现：
File imagePath = new File(Context.getFilesDir(), "images");
File newFile = new File(imagePath, "default_image.jpg");
Uri contentUri = FileProvider.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/770498257acbce43b51200c836910c59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1b1e65e20e8e3e406776e4c6d443a03/" rel="bookmark">
			html从json格式取某字段,从服务器端获取JSON格式字符串并解决到前端页面中显示；使用JSON改写表单验证案例（使用JSON.parse()来把JSON格式转变为js对象的运用）2019年5月1...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从服务器端获取JSON格式字符串并解决到前端页面中显示:
实例
html&gt;
Json小案例 点击我获取信息
// 获取按钮
var btn = document.getElementsByTagName('button').item(0);
// 创建ajax对象
var request = new XMLHttpRequest;
// 监听按钮点击
btn.addEventListener('click', getData, false);
// 创建点击事件函数
function getData() {
// ajax步骤
request.addEventListener('readystatechange', show, false);
request.open('get' ,'demo1.php', true);
request.send(null);
}
// 创建show函数
function show() {
// if语句判断是否获取到PHP中的对象
if (request.readyState === 4) {
// console.log(request.responseText);//检查是否获取到JSON格式的对象
// 创建变量obj存储JSON的对象
var obj = JSON.parse(request.responseText);// JSON格式转为对象
// 更新DOM操作
//获取h3标签
var h3 = document.getElementsByTagName('h3').item(0);
// console.log(obj.name);//检查obj变量是否正确
// 将JSON格式里所需的数据打印在页面中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1b1e65e20e8e3e406776e4c6d443a03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e411c0df268c34e0cea9ffb76ffac435/" rel="bookmark">
			html字符串转换成json对象,json对象格式化成html字符串显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function jsonStrFormat(jsonData, tableSpaceNum) {
//缩进字符
var spaceStr = " ";
var startStr = "";
var endStr = "";
var subArr = [];
var subStr = "";
var dataType = checkDataType(jsonData);
if(dataType === 'obj'){
//对象
startStr = "{
";
for(var i in jsonData){
subStr = numberStr(tableSpaceNum+1,spaceStr)+'"'+i+'":'+jsonStrFormat(jsonData[i],tableSpaceNum+1);
subArr.push(subStr);
}
endStr = "
"+numberStr(tableSpaceNum,spaceStr)+"}";
return startStr + subArr.join(',
') + endStr;
}
if(dataType === 'arr'){
//对象
startStr = "[
";
for(var i in jsonData){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e411c0df268c34e0cea9ffb76ffac435/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47ee9ff0c38b0dcd0bcb888ce162d571/" rel="bookmark">
			react：hooks相关面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、为什么会有React Hooks，它解决了哪些问题？ 完善函数组件的能力，函数组件更适合 react 组件组件逻辑复用，hooks表现更好class复杂组件变的难以理解，逻辑混乱，不易拆解和测试 例如：同样的逻辑，散落在 DidMount 和 DidUpdate 中，DidMount 和 WillUnMount 中，使用 hooks，同样的逻辑可以分割到一个一个的 useEffect 中
2、React Hooks 如何模拟组件的生命周期？ 模拟 componentDidMount 和 componentDidUpdate，useEffect 依赖不写模拟 componentDidMount，useEffect 依赖 []模拟 componentDidUpdate，useEffect 无依赖，或者依赖 [a, b]模拟 componentWillUnMount，useEffect 返回一个函数 3、如何自定义 Hook？ 4、React Hooks 性能优化？ useMomo 缓存数据，useCallback 缓存函数相当于 class 组件的 SCU 和 PureComponent 5、使用 React Hooks 遇到过哪些坑？ useState 初始化只初始化一次useEffect 内部不能修改 stateuseEffect 依赖引用类型会出现死循环 6、Hooks 相比 HOC 和 Render Props 有哪些优点？ 没有额外需要理解的规则变量作用域明确不会产生组件嵌套 参考 可以对着这个文章来看 https://blog.csdn.net/weixin_43972437/article/details/105326274
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f73a44843a1f873a5dda90397f2d5ad/" rel="bookmark">
			核范数求导(derivative of the nuclear norm)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在网上找到了关于核范数求导的两种方式，一种是论文里常用的Singular Value Thresholding（SVT）方法，另外一种是网上流传的通过SVD的方式直接求导的方式。
1. Singular Value Thresholding 这种方法最早是针对矩阵补全的问题提出的，在论文《A Singular Value Thresholding Algorithm for Matrix Completion》中，作者提出了关于以下形式问题的求解方法
即对于（2.3）公式中的优化问题而言，其最优解X等于 D τ ( Y ) D_{\tau}(Y) Dτ​(Y)，而 D τ ( Y ) D_{\tau}(Y) Dτ​(Y)的定义如下：
也就是说对于公式（2.3），为了获得X的最优解，我们需要将Y进行SVD（skinny SVD）分解，U和V保持不变，但是对于所有的特征值要减去 τ \tau τ（注意：这个 τ \tau τ是公式中核范数前面的系数），并进行max(0,t)操作，那么对于 σ i &lt; τ \sigma_i&lt;\tau σi​&lt;τ的那些特征值就会被置0，这是SVT的主要思想，而论文中通常会先将带有核范数的目标函数转化成如（2.3）形式的问题，再利用上述SVT的解法求得最优解。
举个具体的实例：
有目标函数一：
min ⁡ Z f ( Z ) + λ ∥ Z ∥ ∗ \min_{Z}f(Z)+\lambda\|Z\|_* Zmin​f(Z)+λ∥Z∥∗​
首先引入中间变量 X X X，得到如下目标函数二：
min ⁡ Z , X f ( Z ) + λ ∥ X ∥ ∗ s .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f73a44843a1f873a5dda90397f2d5ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14eb8356c22a2b6e5c6bcb912198eb36/" rel="bookmark">
			重写和重载的特征与区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）重载 ①在同一个类里
②函数名称相同
③参数不同（参数类型和参数个数）
④返回值不做要求
（2）重写 ①分别位于父类和子类
②函数名称相同
③参数相同（参数类型和参数个数）
④返回值相同
注： ①重写的类型不能是私有的；
②静态方法不能重写为非静态方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/776f529d69337991500335aac8a0b9ea/" rel="bookmark">
			SSM整合配置文件超详细步骤总结 :
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 : 码不多 1. 创建Maven工程，配置pom.xml添加所需依赖
&lt;!-- 集中定义依赖版本号 --&gt; &lt;properties&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;spring.version&gt;5.1.2.RELEASE&lt;/spring.version&gt; &lt;mybatis.version&gt;3.2.8&lt;/mybatis.version&gt; &lt;mybatis.spring.version&gt;1.2.2&lt;/mybatis.spring.version&gt; &lt;mybatis.paginator.version&gt;1.2.15&lt;/mybatis.paginator.version&gt; &lt;mysql.version&gt;5.1.32&lt;/mysql.version&gt; &lt;slf4j.version&gt;1.6.4&lt;/slf4j.version&gt; &lt;druid.version&gt;1.0.9&lt;/druid.version&gt; &lt;pagehelper.version&gt;5.1.2&lt;/pagehelper.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;servlet-api.version&gt;3.0.1&lt;/servlet-api.version&gt; &lt;jsp-api.version&gt;2.0&lt;/jsp-api.version&gt; &lt;jackson.version&gt;2.9.6&lt;/jackson.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;20140107&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/776f529d69337991500335aac8a0b9ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23867a179882efa8736a11131292179f/" rel="bookmark">
			ConcurrentHashMap源码夺命15问，你能坚持到第几问？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		临近秋招，备战暑期实习，祝大家每天进步亿点点！Day11本篇总结的是 ConcurrentHashMap 相关的面试题，后续会每日更新~对 ConcurrentHashMap 源码不熟悉的可以参考我的往期博客：ConcurrentHashMap源码解析文章总目录卷吗？卷就对了，Java 就是这么卷卷单单！ 1、请你描述一下ConcurrentHashMap存储数据结构是什么样子呢？ ConcurrentHashMap 内部的 map 结构和 HashMap 是一致的，都是由：数组 + 链表 + 红黑树 构成。
ConcurrentHashMap 存储数据的单元和 HashMap 也是一致的，即，Node 结构：
static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { // hash值 final int hash; // key final K key; // value volatile V val; // 后驱节点 volatile Node&lt;K,V&gt; next; .... } ConcurrentHashMap 和 HashMap 区别就在于前者支持并发扩容，其内部通过加锁（自旋锁 + CAS + synchronized + 分段锁）来保证线程安全。
2、请问ConcurrentHashMap的负载因子可以新指定吗？ 普通的 HashMap 的负载因子可以修改，但是 ConcurrentHashMap 不可以，因为它的负载因子使用 final关键字修饰，值是固定的 0.75 ： // 负载因子：表示散列表的填满程度~ 在ConcurrentHashMap中，该属性是固定值0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23867a179882efa8736a11131292179f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2926c325241175155f0761756751e50/" rel="bookmark">
			android string.contains,The given artifact contains a string literal with a package reference &#39;andro...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题
I upgraded my android studio to 3.4 canary and now I cannot successfully build anymore due to the following error:
The given artifact contains a string literal with a package reference 'android.support.v4.content' that cannot be safely rewritten. Libraries using reflection such as annotation processors need to be updated manually to add support for androidx.
More details:
Caused by: java.lang.RuntimeException: Failed to transform '.gradle/caches/modules-2/files-2.1/com.jakewharton/butterknife-compiler/9.0.0-SNAPSHOT/732f93940c74cf32a7c5ddcc5ef66e53be052352/butterknife-compiler-9.0.0-SNAPSHOT.jar' using Jetifier. Reason: The given artifact contains a string literal with a package reference 'android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2926c325241175155f0761756751e50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2fd7ff1925fd7616462725ac077cd58/" rel="bookmark">
			python安装thop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在复现代码的时候老会遇到包不存在的问题，一直要pip安装某些包，但是有一些包pip安装不了的，在安装pretrainedmodels的时候发现了这个很好用的安装方法，记录一下以防忘记。
首先，找到该包的GitHub链接，例如我要安装的是thop包，所以我找到了这个包的GitHub链接添加链接描述
第二步，将压缩包下载解压放到需要的路径里面
第三步，打开annaconda prompt或者cmd，激活到tensorflow或者pytorch的环境下面，然后cd到刚刚下载解压的thop路径
第四步，运行 python setup.py install 语句，等环境更新就OK啦！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71bd60ebdea8e5b72c1cf4ff4e051248/" rel="bookmark">
			【新星计划】MATLAB系统辨识工具箱使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、进入System Identification主界面
打开APP栏的系统辨识工具箱，
弹出如下界面
然后点击import data，选择加载类型为时域类型
2、加载数据
导入采集的实验数据，从工作区直接拖拽相应的变量到Input和Output
点击Import按钮，成功加入需要辨识的一组数据，加载成功之后的数据如图：
3、参数辨识
点击Estimate，选择需要辨识的系统模型的结构，这里选择Transfer Function Models传递函数模型
在弹出的传递函数选项中，设置零点和极点个数，取消勾选Time delay中的Fixed，这样就可以自动辨识时间延迟。设置完毕之后，点击Estimate按钮，开始分析
分析过程报告为
此时，右侧的模型窗口出现了辨识的tf1，拖拽到MATLAB中的工作区workspace
4、查看结果
4.1 系统辨识窗口查看
双击tf1，查看辨识结果
4.2 在命令行中查看
将辨识出的结果拖拽到MATLAB工作区之后，在命令行窗口输入tf1
&gt;&gt; tf1 tf1 = From input "u1" to output "y1": 0.0004659 -------------------------- s^2 + 0.01101 s + 0.000881 Name: tf1Continuous-time identified transfer function. Parameterization: Number of poles: 2 Number of zeros: 0 Number of free coefficients: 3 Use "tfdata", "getpvec", "getcov" for parameters and their uncertainties.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71bd60ebdea8e5b72c1cf4ff4e051248/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58d1c7a39dece3d284fcb1747fe4ac1b/" rel="bookmark">
			SSH命令行传输和下载文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSH命令行传输和下载文件
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/309/">«</a>
	<span class="pagination__item pagination__item--current">310/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/311/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>