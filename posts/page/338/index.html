<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337c1bcc8043b6ca28e80ca2922826d1/" rel="bookmark">
			node项目自动打zip压缩包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node项目自动打zip压缩包 普通node项目 参考文章：
https://www.cnblogs.com/xieqian/p/10973324.htmlhttps://blog.csdn.net/weixin_43968658/article/details/102949470
安装依赖 yarn add compressing -D yarn add dayjs -D 脚本 node执行以下脚本，就可以实现将dist目录打包到./zip目录下，自定义zip文件名
const path = require("path"); const fs = require("fs"); const chalk = require("chalk"); // 这个是主角 const compressing = require("compressing"); const dayjs = require("dayjs"); const resolve = dir =&gt; path.join(__dirname, "..", dir); const publishPath = resolve("publish"); const zipName = (() =&gt; `.zip/dist_sit_${dayjs().format("YYYYMMDDHHmm")}.zip`)(); // 判断是否存在当前publish路径，没有就新增 if (!fs.existsSync(publishPath)) { fs.mkdirSync(publishPath); } compressing.zip .compressDir(resolve("dist/"), resolve(zipName)) .then(() =&gt; { console.log(chalk.yellow(`Tip: 文件压缩成功，已压缩至【${resolve(zipName)}】`)); }) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/337c1bcc8043b6ca28e80ca2922826d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dc36211b392e298aa730845fa963cf0/" rel="bookmark">
			List转array（数组）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们常用的的转换方法是 ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;(); list.toArray(); list.toArray(new String[0]); list.toArray(new String[list.size()]); 调用toArray无参方法时底层进行了： 1、里面会去调用Array.copyOff方法用，arrayList中维护的数组以及arrayList的size作为参数
public Object[] toArray() { return Arrays.copyOf(elementData, size); } 2、Array.copyOf调用重载方法，将以上参数以及，list中的数组的数据类型（Object）作为参数调用copyof方法
public static &lt;T&gt; T[] copyOf(T[] original, int newLength) { return (T[]) copyOf(original, newLength, original.getClass()); } 3、再次调用Array.copyOf的重载方法，判断数据类型是否时Object，传入的肯定是个Object所以这里会穿件一个Object类型的数组进行返回
并低啊用System.arraycopy将list中维护的数组中的数据复制到新的数组中去
public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) { @SuppressWarnings("unchecked") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dc36211b392e298aa730845fa963cf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d3bfdea6322462b3b808b8b92a7867f/" rel="bookmark">
			[python]豆瓣网爬取图书图片信息教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[python]豆瓣网爬取图书图片信息教程 1.准备工作：已经爬取了图片的URL，图书的相关信息，以便后期进行标记。
画圈处为图片链接和图书ID（用于匹配图片）
2.定义url数组和id数组
作用同上，且长度相同，url用于爬图片，id用于命名图片存储本地。
3.操作代码
引用了python的requests库
PS:在获取网页操作r = requests.request(‘get’,urls[i], headers=headers) #获取网页
时，若不加headers
和
headers配置文件headers = {‘User-Agent’:‘Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36’}
会报错403，也就是说你的IP被豆瓣封了。
import os import requests os.chdir('C:/Users/测试/Desktop/Python/pics')//操作的环境目录，即图片存取目录 urls=image_list for i in range(len(image_list)): try: headers = {'User-Agent':'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36'} r = requests.request('get',urls[i], headers=headers) #获取网页 with open(str(id_list[i])+'.jpg','wb') as f: #打开写入到path路径里-二进制文件，返回的句柄名为f f.write(r.content) #往f里写入r对象的二进制文件 f.close() except exception as e://可能报错时要抛出异常，打印当前的已保存索引，便于之后操作 print(i) print(e) print(r.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d3bfdea6322462b3b808b8b92a7867f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74ad2c14866f1f2135b62ab2e4e116e1/" rel="bookmark">
			QT日志库 QsLog
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt中提供 Qt::qDebug()、Qt::qWarning()、Qt::qCritical()、Qt::qFatal()进行log输出。如果要输出log.txt文件，需要配合调用Qt::qInstallMessageHandler()函数。但功能并不强大。这里推荐一个第三方Qt日志库：QsLog 。
github: https://github.com/victronenergy/QsLog
下面讲解如何使用：
在github上下载源码，可以制作成lib库形式，也可以以源文件方式加入到项目中，这里直接复制源码加入到项目中。
编写测试代码:
test.cpp
#include "../QsLog/QsLog.h" #include "../QsLog/QsLogDest.h" void init() { // 初始化日志机制 Logger&amp; logger = Logger::instance(); // 设置日志等级 logger.setLoggingLevel(QsLogging::TraceLevel); // 添加文件为目的地 const QString sLogPath(QDir(QApplication::applicationDirPath()).filePath("log.txt")); DestinationPtr fileDestination(DestinationFactory::MakeFileDestination( sLogPath, EnableLogRotation, MaxSizeBytes(1024 * 1024), MaxOldLogCount(2))); // //MaxSizeBytes 代表log文件最大大小，MaxOldLogCount表示旧log文件个数 logger.addDestination(fileDestination); // 打印日志 QLOG_TRACE() &lt;&lt; "1-trace msg"; QLOG_DEBUG() &lt;&lt; "2-debug msg"; QLOG_INFO() &lt;&lt; "3-info msg"; QLOG_WARN() &lt;&lt; "4-warn msg"; QLOG_ERROR() &lt;&lt; "5-error msg"; QLOG_FATAL() &lt;&lt; "6-fatal msg"; for(int i = 0; i &lt; 1000000; ++i) { QLOG_ERROR() &lt;&lt; QString::number(i) + QString::fromUtf8("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74ad2c14866f1f2135b62ab2e4e116e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/591d0bf9c3cb60994005ccd42d1d8b5e/" rel="bookmark">
			spring validation校验 List＜String＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式一：spring + validation + hibernate-validator
maven 依赖：
&lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;javax.el&lt;/artifactId&gt; &lt;version&gt;2.2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;2.0.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.1.7.Final&lt;/version&gt; &lt;/dependency&gt; demo示例：
@ApiModelProperty(value = "类型标识列表（0-原始、1-续签、2-补充）", example = "0") private List&lt; @NotBlank(message = "类型标识不能为空") @Pattern(regexp = "^(0|1|2|){1}$", message = "类型标识不正确（0-原始、1-续签、2-补充）") String&gt; contractFileTypeTempTypeList; 方式二：springboot + validation
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;!--&lt;version&gt;2.1.9.RELEASE&lt;/version&gt;--&gt; &lt;version&gt;2.3.5.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!-- validation --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; demo示例：
@ApiModelProperty(value = "类型标识列表（0-原始、1-续签、2-补充）", example = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/591d0bf9c3cb60994005ccd42d1d8b5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/021fae0b10bbc75365cf4ad8ecf288e3/" rel="bookmark">
			Pycharm不能调试怎么办？如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为测试python的有效工具，很多代码的最终环节都是在pycharm中展现的。最近很多人在测试的环节出现了报错，问题为运行是正常的，但是无法进行调试，也就是debug调试。下面我们列举出原因，并提出对应的解决办法，小伙伴们都来看看吧。
1.文件名和python自带的模块名重复了，这种情况的下建议将文件重命名即可，我以前就是这种情况。
2.在环境变量run/debug configure里加上下面的参数，这是以前遇到翻墙google到的：
3.Pycharm里的setting pyqt compatable与pyqt5不兼容，需要修改，比如auto取消。
4.换个地方打个断点看看，是不是断点位置错误，导致断点没进来。
5.如果这个文件的内容不多的话就删除文件吧，将该文件夹下的文件全部删除掉，可以换个地方备份下，试试看，是在没办法的情况下。
拓展：
注释
ctrl+/:单行注释
光标操作
ctrl+alt+enter:向上插入
shift+enter:向下插入
end: 光标
以上就是Pycharm不能调试的原因以及解决办法，也可以对应着上面所说的情况逐个尝试，结尾的快捷键拓展需要我们同样掌握哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9422fd7dbccbc56c2fc3090e6e15dc19/" rel="bookmark">
			工字型钢弹性截面模量计算公式_弹性截面模量与塑性截面模量的例析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与《弹性截面模量与塑性截面模量的例析》相关的范文
09-06
一.单项选择题1 B 2 D 3 C 4 C 5 A 6 D 7 C 8 D 9D 10D 11D 12 A 13 D 1. 图1为一端固定的橡胶板条,若在加力前在板表面划条斜直线AB ,那么加轴向拉力后AB 线所在位置是? ( b)(其中ab ∥AB ∥ce ) (A ).ab (B).ae (C).ce (D).de 2. 低碳钢加载→卸载→ 再加载路径有以下四种,如右图2,请判断哪一个是正确 ...
经典损伤定义中的"弹性模量法"探讨 谢和平 鞠 杨 董毓利 (中国矿业大学北京研究生部,北京 100083) (中国科学技术大学,合肥 230026) 1) 摘要 本文从应变等效性假说的基本原理出发,研究了基于该假说的损伤定义方法"弹性模量法"中的受损材料弹性模量的物理概念,指出了"弹性模量法"的局限性和适用条件,以及用其描述弹塑性材料损 ...
第三章拉压杆件的承载能力 一.判断题 1. 线应变是构件中单位长度的变形量.( √ ) 2. 用圆截面低碳钢试件做拉伸试验,试件在颈缩处被拉断,断口呈杯锥形.( √ ) 3. 胡克定律只适用于弹性变形范围内.( √) 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9422fd7dbccbc56c2fc3090e6e15dc19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd78cad9cec00f9bf77b8c300be8735f/" rel="bookmark">
			通信端口感叹号_PCI简易通讯控制器有黄色感叹号怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日有网友新安装了Win7系统，安装完成后感觉电脑都顺畅了很多，不过在打开设备管理器的时候发现，在其他设备下的PCI简易通讯控制器有个黄色感叹号，出现这个感叹号也意味着这个控制器的驱动未安装，对此我们该如何解决呢？
解决方法
1、打开设备管理器，右键点击“PCI简易通讯控制器”，在下拉菜单中点击属性；
2、在打开的“PCI简易通讯控制器 属性”窗口显示：该设备的驱动程序未被安装，我们点击更新驱动程序；
3、在新窗口中，我们鼠标左键点击：浏览计算机以查找驱动程序软件；
4、我们在下一个更新驱动程序软件-PCI简易通讯控制器窗口点击：从计算机的设备驱动程序列表中选择，再点击：下一步；
5、在接下来的更新驱动程序软件-PCI简易通讯控制器窗口点击：系统设备，再点击：下一步(N)；
6、接下来，我们左键点击框中厂商栏中的(标准系统设备)(注意：一定要是红线划定的标准系统设备，另一个不行！)，再点击：下一步(N)；
7、这时会弹出一个：更新驱动程序警告窗口，我们别管它，点击是就行了；
8、这时会出现：Windows已经成功地更新驱动程序文件，我们点击关闭；
这时我们回到设备管理器的窗口中，再次查看其他设备下的PCI简易通讯控制器，会发现黄色感叹号已经没了，对此我们也就解决了PCI简易通讯控制器有黄色感叹号的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccd1854657c68eca781feee8fb84b3a0/" rel="bookmark">
			内存都是由半导体器件构成的_计算机硬件的组成有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、微处理器、微型计算机和微型计算机系统的概念
(1)微处理器微型
计算机的核心部分是指由一片或几片大规模集成电路组成的，具有运算器和控制器功能的中央处理器(CPU)。
(2)微型计算机
以微处理器为核心，配上由大规模集成电路制成的存储器、输入输出接口电路及系统总线所组成的计算机，简称微型计算机。
(3)微型计算机系统
以微型计算机为中心，配以相应的外围设备、电源和辅助电路，以及指挥微型计算机工作的系统软件，就构成了微型计算机系统。
2.CPU、内存、接口和总线的概念
微型计算机包含了多种系列、档次、型号的计算机。如IBM PC等。这些计算机的共同特点是体积小，适合放在办公桌上使用，而且每个时刻只能一人使用，因此又称为个人计算机。
(1)主板
主板是固定在主机箱箱l体上的一块电路板，主板上装有大量的有源电子元件。其中主要组件有：CMOS、基本输入输出系统(basic input and output system，BIOS)、高速缓冲存储器(cache)、内存插槽、CPU插槽、键盘接口、软盘驱动器接口、硬盘驱动器接口、总线扩展插槽(提供.ISA、PCI等扩展槽)、串行接口(COM1、(COM2)、并行接口(打印机接口LPT1。因此，主板是计算机各种部件相互连接的纽带和桥梁。
(2)中央处理器
中央处理器(CPU)是计算机的核心，计算机的运转是在它的指挥控制下实现的，所有的算术和逻辑运算都是由它完成的，因此，CPU是决定计算机速度、处理能力、档次的关键部件。
(3)内存储器
存储器分为内存储器和外存储器，通常简称为内存和外存。内存是计算机的主要工作存储器，一般计算机在工作时，所执行的指令及处理的数据，均从内存取出。内存的速度快，但容量有限，主要用来存放计算机正在使用的程序和数据。外存具有存储容量大、存取速度比内存低的特点，所以它用于存放备用的程序和数据等。外存中存放的程序或数据必须调入内存后，才能被计算机执行和处理。常用的外存有磁盘机、磁带机、光盘机等。
计算机中的信息用二进制表示。计算机的存储器由千千万万个小单元组成，每个单元存放一位二进制数(0或1)。存储单位使用下列术语：
· 位(bit)是二进制数的最小单位，通常用“b”表示。
· 字节(byte)以8位二进制数组成1个字节，通常用“B”表示。
· 字(word)由若干个字节组成。它也是表示有储容量的一个单位，通常我们把计算机一次所能处理的数据的最大位数称为该机器的字长，显然字长越长，一次所处理的信息越多，计算精度越高。因此，“字长”是计算机功能的一个重要标志。
· 存储容量计算机内外存储器的容量是用字节(B)来计算和表示的，除B外，还常用KB、MB、GB作为存储容量的单位。其换算关系如下：
B(字节) lB=8b
KB(干字节) 1KB=1024KB
MB(兆字节) lMB=1024KB
GB(吉字节) 1GB=1024MB
①内存
内存是计算机用于直接存取程序和数据的地方，因此计算机在执行程序前必须将这些程序装入内存中。从存储器取出信息称为读出;将信息存入存储器称为写入。存储器读出信息后，原内容保持不变;向存储器写入信息，则原内容被新内容所代替。由于内存是由半导体器件构成的，没有机械装置，所以内存的速度远远高于外存。内存又分如下两种：
· 只读存储器ROM(read only memory)
只能读而不能写入信息，它一般用来存储固定的系统软件和字库等内容，只能被调用，而不能被重写或修改，也不会因断电而消失。
· 随机存取存储器RAM(random access memory)
可以进行任意的读或写操作，它主要用来存放操作系统、各种应用软件、输入数据、输出数据、中间计算结果以及与外存交换的信息等。由于RAM用半导体器件组成，一旦断电，信息就会丢失，所以不能永久保留。
内存容量是反映计算机性能的一个很重要的指标，目前常用64MB、128MB、256MlB等，可高达4GB。
②外存
外部存储器包括软盘、硬盘、光盘和磁带等。外存的信息存储量大，但由于存在机械运动问题，所以存取速度要比内存慢得多。由于外存具有很大的存储容量，因此它可以存放大量信息。它不但存有机器开机后立即要调入的操作系统，而且还存有用户的应用软件、数据等。
由于外存大都由非电子线路来实现(例磁介质、光介质)所以外存上的信息从原理上讲可以长期保留。外存中存放的程序或数据必须调入内存后，才能被执行和处理。
· 软盘
转载请注明来自有趣新闻网：
计算机硬件的组成有哪些
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfc3c728ff21b2d74931b8ed71a65a2d/" rel="bookmark">
			oracle 使用to_number转换字符型时报错：无效的数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：oracle 使用to_number转换字符型时报错：无效的数字 问题代码：to_number(p.num)
问题分析：这个函数只能转换字符串格式是正确数字的情况，也就是一旦字符串为空，或者有特殊字符，或者有空格等等，都会抛错
解决方法：使用regexp_replace函数将特殊字符替换为空
修改后结果：nvl(to_number(regexp_replace(p.num,’[^0-9.]’,’’)),0)
注：regexp_replace函数
语法
VARCHAR REGEXP_REPLACE(VARCHAR str, VARCHAR pattern, VARCHAR replacement)
入参
参数 数据类型 说明
str VARCHAR 指定的字符串。
pattern VARCHAR 被替换的字符串。
replacement VARCHAR 用于替换的字符串。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fdd4cdcf1ebd2970c1a2cdc18f66a53/" rel="bookmark">
			python 中任务 6.3 构建并评分分类模型(SVM模型)   学习笔记3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 任务6.3 构建并评价分类模型6.3.1 使用sklearn 估计器构建分类模型代码6-17 使用sklearn估计器构建SVM模型sklearn 库常用分类算法函数代码 6-18 分类结果的混淆矩阵与准确率 6.3.2 评价分类模型代码6-19 分类模型常用评价方法代码6-20 分类模型评价报告代码6-21 绘制ROC曲线ROC曲线 6.3.3 任务实现使用sklearn构建鲍鱼年龄预测的步骤如下 1 构建SVM分类模型代码 6-22 鲍鱼年龄预测2. 评价构建的SVM分类模型代码 6-23 评价构建的SVM分类模型 任务6.3 构建并评价分类模型 6.3.1 使用sklearn 估计器构建分类模型 代码6-17 使用sklearn估计器构建SVM模型 在数据分析领域，分类算法有很多，其原理千差万别，有基于样本距离的最近邻算法，有基于特征信息熵的决策树，有基于bagging的随机森林 ，有基于boosting的梯度提升分类树 ，但其实现的过程相差不大。过程如图所示。
%%html &lt;img style="float: left;" src="./image/6-17.png" width=300 height=400&gt; sklearn 库常用分类算法函数 sklearn中提供的分类算法非常多，分别存在于不同的模块中。常用的分类算法如下表所示。
%%html &lt;img style="float: left;" src="./image/6-17-2.png" width=400 height=400&gt; import numpy as np from sklearn.datasets import load_breast_cancer from sklearn.svm import SVC from sklearn.model_selection import train_test_split#划分数据 from sklearn.preprocessing import StandardScaler #标准差 cancer = load_breast_cancer() cancer_data = cancer['data'] cancer_target = cancer['target'] cancer_names = cancer['feature_names'] ## 将数据划分为训练集测试集 cancer_data_train,cancer_data_test, \ cancer_target_train,cancer_target_test = \ train_test_split(cancer_data,cancer_target, test_size = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fdd4cdcf1ebd2970c1a2cdc18f66a53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9715ddade41f1b944e0e902b54297227/" rel="bookmark">
			vue elementui前端异步方法转同步记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		elementui的表单验证功能
表单验证方法如果传入回调函数时是异步的
// 子组件的方法 validateForm(){ this.$refs.jsonEditor.getRef("form").validate((valid, hints) =&gt; { return {valid: valid, hints: hints} }) } // 父组件调用,会发现校验结果,hints为undefine submitAll(){ this.$refs.resourceEditorRef.forEach((item, index) =&gt; { console.log(item.validateForm()) }) } 修改成同步的
// 子组件方法 validateForm(){ // this.$refs.jsonEditor.getRef("form").validate((valid, hints) =&gt; { // return {valid: valid, hints: hints} // }) // return new Promise((resolve, reject) =&gt; { // this.$refs.jsonEditor.getRef("form").validate((valid, hints) =&gt; { // resolve({valid, hints}) // }) // }) //或者根据官网文档说明可以不传入回调函数,直接validate return this.$refs.jsonEditor.getRef("form").validate }, // 父组件调用 submitAll(){ // this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9715ddade41f1b944e0e902b54297227/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1094966911dfce5cbe5eddb50b9b7070/" rel="bookmark">
			devtool使用介绍(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		devtool使用介绍1 SDK中devtool的工作流程2.4.1 使用 devtool add添加应用程序 SDK中devtool的工作流程 可扩展SDK的核心要件是一个命令行工具，称为devtool。该工具提供了许多功能，可以帮助你在可扩展的SDK中构建，测试和打包软件，以及通过OpenEmbedded构建系统定制化构建该工具到镜像中。
注意 devtool的用途不限于可扩展的SDK。可以使用devtool帮助你轻松开发必须输出构建的任何项目 使用构建系统构建的图像的一部分。 该devtool命令行也同样被组织到Git中并包含了很多更小功能的子命令。你可以通过执行devtool --help查看所有命令。
注意 在Yocto项目参考手册中查看“ devtool快速阅览”能帮助你快速了解devtool。 存在如下三个devtool子命令，它们提供了开发的切入点：
devtool add ：协助添加要构建的新软件。
devtool Modify ：设置环境以便于开发者能够进行修改现有组件的来源。
devtool upgrade ：更新现有recipe，以便于开发者可以将其构建为一组更新的源文件。
与构建系统一样，“recipes”代表devtool中的软件包。当你使用devtool add时，recipe会被自动创建。 使用devtool modify时，指定的现有recipe用于确定从何处获取源代码以及如何修补它。在这两种情况下都将建立了一个环境，以便于构建一个由你控制的，改变如你预期的recipe源码树。默认情况下，新的recipe和源代码都在SDK下的“workspace”目录。
本节的剩余部分介绍了 devtool add， devtool modify，以及 devtool upgrade工作流程。
2.4.1 使用 devtool add添加应用程序 devtool add命令根据现有源代码生成新recipe。该命令利用了许多devtool命令使用的The Workspace Layer Structure。 该命令足够灵活 允许你将源代码提取到工作区或单独的本地Git存储库，并使用不需要提取的现有代码。
根据你的特定情况，与devtool一起使用的参数和选项会形成不同的组合。下图显示了将与devtool add命令一起使用的常见开发流程：
生成新的recipe：流程的顶部显示了三种方案，你可以使用它们使用devtool add来基于现有源代码生成recipe。在共享开发环境中，其他开发人员通常要负责源代码的各个领域。作为开发人员，你可能有兴趣在Yocto Project中将源代码用作开发的一部分。你所需要做的就是访问代码，recipe以及在其中进行工作的受控区域。在该图中，将三种可能的情况提供给devtool add工作流程： LEFT：图中的左侧场景代表一种常见情况，其中源代码在本地不存在，需要提取。 在这种情况下，源代码将提取到默认工作空间中-你不希望文件位于工作空间之外的某些特定位置。因此，你需要的所有内容都将位于工作空间中： $ devtool add recipe fetchuri 使用此命令，devtool将上游源文件提取到sources文件夹内的本地Git存储库中。 然后，该命令在工作空间中创建一个名为recipe的recipe和一个相应的附加文件。 如果不提供recipe，该命令将尝试确定recipe名称。
Middle：图中的中间场景表示源代码在本地不存在的情况。在这种情况下，代码再次位于上游，并且需要提取到某个局部区域-这次是在默认工作空间之外。 注意 如果需要，devtool在提取过程中，总是在本地创建一个Git存储库。 此外，在这种情况下，第一个位置参数srctree标识devtool add命令将提取的代码定位在工作空间之外的位置。你需要指定一个空目录：
$ devtool add recipe srctree fetchuri 总而言之，源代码是从fetchuri中提取的，并被提取到srctree定义为本地Git存储库的位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1094966911dfce5cbe5eddb50b9b7070/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d232fdc7f1659bca5e2dc1147359c7a8/" rel="bookmark">
			Java JDK 1.8 下载及其版本说明 8u202(最后一个免费版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们可以从Oracle官网下载我们想要的JDK版本
打开官网下载地址： https://www.oracle.com/technetwork/java/javase/downloads/index.html
默认看到的都是各个版本的最新一个版本，如果想要下载自己指定的版本，需要找到归档，归档版本在哪里呢，往下滑划到最下面哦，如下图？
点击 DownLoad! 按钮，即可打开链接，结果见下图
点击JavaSE8（8u202 and earlier）,见下图
选择这个版本，或者后面的版本，然后下载即可,（注意，如果你没有Oracle账号，建议免费注册一个，只有登录的用户才可下载）
win10系统修改JDK版本后配置环境变量不生效处理方法 一、问题 以前安装过安装版的jdk后，配置过环境变量，然后现在更换jdk版本且修改环境变量并不能生效，如原本安装了1.8，现更换为1.7，且配置了环境变量，但是java -version仍显示1.8。
二、原因 当使用安装版本的JDK程序时（一般是1.7版本以上），在安装结束后安装程序会自动将java.exe、javaw.exe、javaws.exe三个可执行文件复制到C:Windows/System32目录，这个目录在WINDOWS环境变量中的优先级高于JAVA_HOME设置的环境变量优先级，故此直接更改JAVA_HOME会无效。
另外，JDK1.8安装版本，还会在C:ProgramDataOracleJava目录中生成一些配置文件，并同时将此目录写到环境变量中的Path中。
三、解决 删除C:WindowsSystem32目录下的java.exe、javaw.exe、javaws.exe三个文件
删除环境变量Path中C:ProgramDataOracleJavajavapath的配置
Oracle收费部分说明是摘自: https://juejin.im/post/5ccce2006fb9a032143770e4
Oracle如何对JDK收费 2019年4月16日，Oracle发布了新的JDK 8的更新，版本号为8u211和8u212。与以往不同的是，新版本的许可协议从BCL换成了OTN，这就意味着，你不能在生产环境使用这个版本了。
如果你想继续使用8u211/8u212，或者之后发布的新版本，就需要给Oracle交钱了。
当然，并不是你用了新版本的JDK就要交钱，这个时候要区分私用和商用：
私用，是我总结的一个词，它包括”Personal Use”和”Development Use”，前者表示一些个人用途，比方说在自己的电脑上写一些小工具，做一些数据分析等等；后者表示开发用途，比如日常开发、做测试、做演示等等。商用不太好界定。我的理解就是拿来赚钱就是商用，比方说把网站部署到生产环境，在公司内部系统使用等。
我用的JDK使用什么协议？
BCL协议，即Oracle Binary Code License Agreement，协议规定你可以使用JDK，但是不能进行修改。私用和商用都可以，但是JDK中的某些商业特性，是需要付费才可以使用的。OTN协议，即Oracle Technology Network License Agreement，目前新发布的JDK用的都是这个协议，可以私用，商用需要付费。从下图可以看出各个版本对应的协议:
我不想掏钱怎么办？
商用的话使用上面BCL协议的版本，私用怎么着都行。很多时候，开发者会对什么版本用了什么协议比较迷惑，懒得搞清楚，那么可以直接使用OpenJDK。
OpenJDK是一个基于GPLv2+CE协议的开源JDK实现，他由OpenJDK社区来运作，作为OpenJDK社区的主导者，Oracle也在尽量减少OpenJDK和Oracle JDK的差别(source)，将一些商业特性移植到了OpenJDK上，比如Java Flight Recorder,Java Mission Control和ZGC等等。对于普通开发者，两者差异可忽略不计。OpenJDK同样会每6个月发布一个新版本，不过每次新的版本发布后，旧的就不维护了，比如OpenJDK 12发布之后，11版本便停止更新，停留在11.0.2版本，没有LTS一说了。
除了Oracle的OpenJDK，还有很多免费OpenJDK实现可以用，比如 Zulu，AdoptOpenJDK，Amazon的Corretto和阿里巴巴的dragonwell等等。具体他们有什么区别，我们以后再说。
我们大厂愿意掏钱怎么办？
可以通过订阅Java SE Subscription来付费，桌面用途每人每月2.5刀，服务器用途每个处理器每月25刀，量多还有优惠。Oracle以前还提供Java SE Advanced, Java SE Advanced Desktop和 Java SE Suite等一次性授权，不过现在都建议新老付费用户换成订阅制了。
Oracle为什么这么做
当然是赚钱，OTN协议的Oracle JDK现在允许私用也只是想让开发者养成习惯，将来开发者搞公司项目的时候，非常有可能会习惯性去Oracle官网下载JDK，这样就导导致了商用项目未经许可违规使用。Oracle法务部的刀肯定老早就磨好了。
谢谢!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc7db3cac013b51617e2df70a561964a/" rel="bookmark">
			调整jmeter5内存_jmeter本机内存溢出如何修改？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		websocket连接过程中内存溢出，本机配置的内存最大和最小设置的512；
一、后台返回
二、结果树返回：
Thread Name: 线程组 1-9
Sample Start: 2017-09-11 13:59:49 CST
Load time: 9006
Connect Time: 0
Latency: 0
Size in bytes: 0
Sent bytes:0
Headers size in bytes: 0
Body size in bytes: 0
Sample Count: 1
Error Count: 1
Data type ("text"|"bin"|""):
Response code:
Response message:
[Execution Flow]
- Opening new connection
- Using response message pattern ""
- Using disconnect pattern ""
- Waiting for the server connection for 9000 MILLISECONDS
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc7db3cac013b51617e2df70a561964a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/630bf884f98ed322179dd59c176c17b8/" rel="bookmark">
			判断拐点的条件_拐点的定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Q:题目：请问芬君，在如上的解答中拐点是哪两个呢？
芬君在线
A:
关于题主的问题，熟悉芬君的应该知道，这就是暑期二轮复习中说的基础知识的补丁：
1.拐点的定义
本质上是函数曲线的凹凸分界点。若该曲线图形的函数在拐点有二阶导数，则二阶导数在拐点处异号(由正变负或由负变正)；还有一种可能性就是函数在该点二阶导数不存在，也有可能该点是拐点。
2.必要条件
设函数f(x)在点X的某邻域内具有二阶连续导数，则该点的二阶导数为0，反之则不成立。
3.充分条件第一充分条件
函数在某点处二阶导数为0，在该点处左右两次二阶导数异号，则可以判定为拐点。两侧同号则不为拐点。
第二充分条件
函数在某点处二阶导数为0，三阶导数不为0，则可以判定为拐点。
4.拐点的求法
1)求出函数二阶导数表达式
2)令二阶导数为0，求解出导数为0的对应x取值，并求解出二阶导数不存在的对应x的取值
3)检查2)中每个x的两侧二阶导数的符号，是否异号。
5.拐点是一个点，是有衡纵坐标组成，不要忘记！！
6.答案，选择C，拐点为(0,0)和(1,0)
推荐阅读：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55a2b4d68c6234c358b6bd69d8aeeccc/" rel="bookmark">
			电脑cpu风扇转一下就停无法开机_电脑cpu风扇转一下停一下,小编告诉你电脑cpu风扇转一下停一下怎么办...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑产品的散热是十分重要的一个内容，良好的散热功能往往能够保证电脑产品的正常运行，因此对于用户而言是十分必须的。CPU风扇和电源风扇都只转一下就停了，很明显是系统给CPU供电出现问题，导致CPU异常，下面逐步进行故障排除。下面，小编给大家介绍电脑cpu风扇转一下停一下的解决步骤。
用户有使用电脑时，会经常遇到启动电脑发现电脑开不了机，显示器没有反应，而且不到10秒钟，电脑就停止运行了，cpu风扇转一下就停，然后反复这样，显示屏无反应，开不了机，这时大家不用太担心。下面，小编给大伙带来了电脑cpu风扇转一下停一下的处理图文。
电脑cpu风扇转一下停一下怎么办
首先要检查内存条是否有问题，检测的方式 拔掉内存条，一根根进行测试开机情况，如果开机风扇不会转一下就停的话就是内存的问题，这种情况更换新内存条就可以了
电脑系统软件图解1
然后在检测主机电源是否有问题，检测方式是替换法，用新电源进行测试，用新电源没问题的话就是电源问题了
电脑系统软件图解2
如果还是不能解决的话，很有可能是主板的问题了，有可能是主板启保护作用
风扇系统软件图解3
如果能开机了，但是会自动重启就很有可能是系统的问题了，不过一般这个问题比较少见，一般出现在老电脑上，可以试一下重装系统是否能解决。
风扇系统软件图解4
以上就是电脑风扇一转一停的解决方法的所有内容了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd202fa3502e315bd1b125e2f9150825/" rel="bookmark">
			word转pdf后表格线不见了_pdf的表格怎么转换成word？教你掌握重要一步！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PDF的表格怎么转换成word？
习惯使用PDF文件的小伙伴们都知道，PDF文件是不能被轻易修改的。不知道大家伙有没有那种感觉，就是PDF文件看起来有种莫名的高级感。不管是图标，还是文件内容（可能是小编我有点想多了叭）。但刚刚接触PDF文件的小伙伴可能会觉得PDF文件看起来有点神秘，不能编辑，那如果文件内容出现错误了，或者说是需要整改文件的内容，那怎么办呢？
也确实是有这种状况，因为突发状况随时都有可能发生。对于这种状况的出现，也有对应的解决方案。如果我们需要修改的文件内容比较少，并且是简单的处理就可以了，那么我们可以使用编辑器来处理。但真的遇到大整改啊，PDF的表格需要重新调整等，需要使用到办公软件的工具，那就需要我们将其转换为office文件格式来处理了。我们的PDF文件里经常有一些表格数据，如果需要修改起来就很麻烦。我们可以将
在线PDF转Word免费的文件转换器工具 - PDF快转在线免费版，这样便可以直接进行大面积修改和处理了。那么，我们如何将PDF的表格转换为word呢？
操作步骤：
打开浏览器，搜索PDF快转。 2.因为我们需要将PDF的表格转word，所以我们需要点击选择转换功能“PDF转word“。
3.点击添加文件来转换，这样我们就可以实现PDF的表格如何转换成word了。然后在转换成功后我们只需点击下载文件即可。
4.点击“收藏“，即可收藏PDF转word页面，在下次需要转换的时候直接打开即可。
这样我们就可以直接在网页上实现如何将PDF的表格转换为word文件，可以满足不想浪费桌面位置，又想解决办公问题的情况啦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f0a84eb26b85e7bb064222c46ddc38b/" rel="bookmark">
			&amp;times被转义成x的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &amp;times被转义成x的解决方法
参考文章：
（1）&amp;times被转义成x的解决方法
（2）https://www.cnblogs.com/Fourteen-Y/p/11428291.html
备忘一下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09a4f77f9567e059f4d5b191d8bb86e2/" rel="bookmark">
			Vm虚拟机安装ubuntu 安装ssh 安装vim以及连接ssm密码一致连不上问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vm虚拟机安装ubuntu 1.准备工作： 这里虚拟机版本我用的是VMware-workstation-full-15.5.2-15785246.exe
ubuntu镜像ubuntu-16.04.3-desktop-amd64.iso 自己根据需要安装
2.安装完成Vm后
新建虚拟机 选择经典， 然后选择ios镜像那个 选中到前面准备的镜像文件，然后全名随便起
用户名随便起（Ubantu的一个用户，不能写root） 密码要能记住的 然后虚拟机名称起的让你知道这个虚拟机主要干什么的 ，位置尽量别放到C盘 自己定义非C盘路径 ，然后磁盘大小选择40GB就够了 然后拆分单多个文件（他会用多少占单个文件的话 会一次性干掉40GB） 下一步后点开自定义硬件 主要改内存跟处理器 内存2G至少（不然卡死 根据自己电脑 处理器 2 2）确保网络适配器为NAT 关闭后 点击完成不用管了 然后等个半个多小时
3安装后有两种登录 记得千万选择你刚才定义的用户名 并且输入密码登录进来的（不然修改密码啥的 他说你没有sudo）
登录进来后第一步不多说设置网络
打开虚拟机 选择上面的编辑 选择 虚拟网络编辑器 进来后点击Vmnet8
DHCP设置前3位不能变
NAT设置 前三位不能变 最后写成2
然后
现在需要重启网络 点击下面
测试这阶段成果 3步
在重新打开上面 然后再打开终端 1、 输入ifconfig
2、打开虚拟机的火狐 输入www.baidu.com 看是否成功
3、在win+r输入cmd ping 192.168.230.129 看是否成功 到此以上都成功后 下面开始其他操作
第一件事修改root密码 sudo passwd root 回车输入当前用户密码 然后再输入两次新密码 此时修改成功 如果修改密码出现卡死情况 建议注销当前用户并且重新登录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09a4f77f9567e059f4d5b191d8bb86e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa0d9840c78296f581bc7e37e8f97998/" rel="bookmark">
			炒菜机器人的弊端_炒菜机缺点有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
菜式单一、需要定期清洗、在炒菜过程中如果断电的话32313133353236313431303231363533e59b9ee7ad9431333365643661，自动程序又会重新开始等等。
一.炒菜机简介
炒菜机，是现在科技产品，是新一代微电脑操控智能烹饪设备，设备主要是方便，简单的操作，无油烟。炒菜机不仅能自动炒、煎、烹、炸、爆、焖、蒸、煮、烙、炖、煲等一锅多用的功能，轻松实现了做饭过程的自动化和趣味化。
二.缺点
1. 炒菜机样式比较单一，材料配给需要固定配额
2. 炒菜机这种程序化的菜品始终没有大厨的那么正宗口感
3. 炒菜的过程当中还是会产生少量的油烟
4. 在炒菜过程中如果断电的话，自动程序又会重新开始
5. 炒菜机要定期清洗，否则就会影响功能的实现
二.历程
1. 第一代炒菜机诞生于2005年，其原型是面包机。这一代产品设计缺陷较多，所以在销售千余台后就停产了。
2. 第二代炒菜机于2006年面世，从外观看已经突破了电饭煲的桎梏，从设计上来说增加了强制鼓风系统，并且最高炒菜温度也由第一代的200度提升到近300度，使得炒出来的菜品更香。
3. 第三代炒菜机则是2010年底研制成功的，该炒菜机最大特点是采用了立体加热，完全解决了传统的铝盘加热器不能沾水、工作温度低、炒菜不香的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd44e4e8ce9fb1fd9f8ee82d0cedcf03/" rel="bookmark">
			python提取中文地址中乡镇名_python处理中文地址描述中的省市区信息（经纬度）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
正文：
目标：
方法：
第一步：
第二步：
第三步：
前言：
本文借助中国省区县信息库进行经纬度获取和图形绘制，适用于个人手中数据为比较整齐的省区县数据。如果想实现任意地址的经纬度获取，可以采用适用面较广的高德地图API获取方法，可以参考Python调用高德地图API获取中文地址对应的经纬度。
正文：
新冠疫情在家，学校安排每天在钉钉上打卡签到，导员说把每天的信息留存好，方便日后核对。
班里三十几个人，来自五湖四海，所有同学的地址在钉钉的地图上显示得并不十分完整。不开心，那就自己动手，丰衣足食。
PS：钉钉的信息里其实有经纬度坐标，但是为了用python实现一下根据中文文本获取经纬度的工作，就假装不知道&gt;_&lt;
目标：
根据中文地址描述获取经纬度
方法：
第一步：
安装cpca, chinese_province_city_area_mapper两个库(安装有问题可参考 安装)。
第二步：
上代码
import os
import cpca
import pandas as pd
from chinese_province_city_area_mapper import drawers
# 获取绝对路径
cur_dir = '\\'.join(os.path.abspath(__file__).split('\\')[:-1])
file_path = os.path.join(cur_dir, '钉钉签到报表20200315-20200315.xls')
# 两种读取Excel非首行作为dataframe列名的方法
readbook = pd.read_excel(file_path, skiprows=2)
# readbook = pd.read_excel(file_path, header=2)
location = readbook['详细地址']
loca = location.to_list()
# print(loca)
df = cpca.transform(loca)
drawers.draw_locations(df, "df.html")
PS：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd44e4e8ce9fb1fd9f8ee82d0cedcf03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cc8c5c4ddebe21048970e1f9eaf653e/" rel="bookmark">
			6 RRC Measurement -- 测量执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Performing Measurement 1、UE 测量可分为IDLE态、INACTIVE态、CONNECTED态下的测量
IDLE：用于小区重选
INACTIVE：用于小区重选
CONNECTED：用于小区切换
2、3种类型的测量：
同频测量：在服务小区的下行载频上进行测量，包括：RSRP、RSRQ、Pthloss等
异频测量：在不同服务小区的下行载频上进行测量，包括：RSRP、RSRQ、Pthloss等
Inter-RAT测量：PCCPCH RSRP、CPICH RSRP、BSIC Identification、BSIC Reconfirmation等
3、按测量 的量不同可分为RSRP、RSRQ
RSRP：(Reference Signal Receiving Power，参考信号接收功率)
定义：是LTE网络中可以代表无线信号强度的关键参数以及物理层测量需求之一，是在某个符号内承载参考信号的所有RE(资源粒子)上接收到的信号功率的平均值。
取值：取值范围 0-91，实际值=取值 - 140dBm.
RSRQ：RSRQ（Reference Signal Receiving Quality）
定义：表示LTE参考信号接收质量，这种度量主要是根据信号质量来对不同LTE候选小区进行排序。这种测量用作切换和小区重选决定的输入。
取值：-3~-19.5 ，绝对值越小越好。
4、测量执行分3类：
reportCGI:
用于检测Cell ID ；唯一标识小区CGI，是一个全局的标识。
(1) 对于普通的测报，UE仅需将其调节器切换到目标小区并测量信号的强度，不需要解码目标小区的mib、sib，测量信号强度需要在很短的时间。
(2) 对于reportCGI，由PLMN、Cell ID等组成，即UE必须要解码目标小区的mib、sib， 因为这个测量是在connected下进行，GAP不会给UE足够的时间解码目标小区的mib、sib，因此通过reportType来设置
(3) reportType中包含：periodical、eventTriggered、reportCGI
reportCGI中主要看：cellForWhichToReportCGI
(4) 如果关联measObject的reportCGI字段指示的小区是NR小区，并且该小区正在广播SIB1，则尝试获取SIB1;如果reportCGI字段指示的单元是EUTRA单元，尝试在相关单元中获取SystemInformationBlockType1
SNR:
用于检测目标小区信号强度；
如果MeasConfig内的measIdList中至少有一个measId包含SINR，则作为触发量和/或报告量
RSRP、RSRQ:
用于检测目标小区信号强度；
每当UE有measConfig时，对servingCellMO配置下的每个服务小区执行RSRP和RSRQ测量
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ab32d133789ace9ab23120e0c5636d6/" rel="bookmark">
			dts音效大师安卓版_dts音效大师
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dts音效大师官方版是一款非常优异和专业的音效处理软件。dts音效大师官方版能够提升汽车音乐效果，并具备八倍音效、2.0转5.1环绕声、U盘音乐、制作碟片、音乐转换等功能，dts音效大师致力于让每一辆车发挥最佳音响效果，让每一位车主享受最美音乐旅程，所以相当靠谱。
相似软件
版本说明
软件地址10.0 最新版
查看
1.0 官方版
查看
3.01 最新版
查看
dts音效大师功能介绍
八倍音效
任何设备、不改音响、不动设备、提升8倍效果(音质);5种音乐风格、16种格式、效果1-8倍可调。
2.0转5.1环绕声
任何普通2.0音乐转5.1环绕声;19种格式(含dts);极大提升音乐包围感、临场感、带入感、效果完美。
U盘音乐
批量制作U盘、SD卡音乐;支持无损、有损、2.0、5.1环绕声;支持14种格式;
制作碟片
一键制作cd、dvd(含dts碟片)音乐碟片;支持16种碟片类型;支持无损、有损、2.0、5.1环绕声。
音乐转换
批量音乐转换(含dts、mlp格式);高级参数设置;支持2.0、5.1、有损、无损互转;支持29种格式。
MTV音乐
一键制作15种MTV视频音乐、3种MTV DVD光盘;支持有损、无损、2.0、5.1;支持设计画面。
无损检测
批量检测无损音乐真假，让假无损音乐(QQ、酷狗、酷我、网易、网络均有不少假无损音乐)原形毕露。
音乐切割
独家绝技，智能分析和切割整轨音乐文件;自动计算每一首曲目开始和结束时间;支持所有音频格式。
音乐合成
音频数据合成音乐文件;多个音乐文件合并为一个音乐文件;支持2.0、5.1、有损、无损音乐格式。
抓取光盘
一键批量抓取CD光盘、SACD光盘镜像内母带音乐文件。
EQ均衡器
简易高、中、低音调节器;15段EQ均衡调节器;音量大小调节器;可以边调边听，批量保存。
统一音量
统一音乐文件的音量大小为90dB;支持所有音乐格式。
修复音乐
修复损坏的、不能播放的、声音不正常的、编码错误的音乐文件;支持所有音乐格式。
更改标签
更改音乐文件内置的专辑、歌手、歌名标签信息;支持WAV、FLAC、APE、MP3格式。
音乐图形
批量输出音乐文件的波形图、频谱图;支持所有音乐格式。
提取人声
提取音乐文件的伴奏音;支持所有音乐格式。
整理名称
智能整理音乐文件名称;删除无用字符、曲目自动编号;支持所有音乐格式。
提取伴奏
提取音乐文件的人声部分;支持所有音乐格式。
制作播放列表
一键制作U盘、SD卡、TFF卡、本地硬盘音乐文件M3U播放列表。
分离音轨
批量分离音乐文件的音轨数据。
音乐检测
批量检测音乐文件编码格式、码率、采样率、位数、声道数量等;检测结果100%正确无误。
dts音效大师安装教程
1、在PC下载网下载这款软件，解压压缩包文件，点击exe安装原版程序，进入安装向导，点击下一步
2、阅读并同意软件安装协议
3、设置软件安装路径，点击下一步
4、选择附加任务，建议创建桌面快捷方式，点击下一步
5、核对安装信息，确认无误后即可点击【安装】按钮继续
6、等待软件安装成功即可
dts音效大师使用方法
如何设置内置音效?
1、选择内置音效;
2、选择效果风格;
3、进行效果调节;
4、确认效果到曲目。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ab32d133789ace9ab23120e0c5636d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52c3fe07447d3c9d2064d06c90c69072/" rel="bookmark">
			dts音效大师安卓版_dts音效大师手机app下载-dts音效大师安卓手机app下载-电玩之家...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dts音效大师app是一款非常专业的音效处理软件，这里有最权威的音频处理器，让用户掌握多个音效效果，低、中、高音都有最明显和最简单的操作，喜欢的朋友不防下载研究一下!
dts音效大师app软件功能：
八倍音效
任何设备、不改音响、不动设备、提升8倍效果(音质);5种音乐风格、16种格式、效果1-8倍可调。
2.0转5.1环绕声
任何普通2.0音乐转5.1环绕声;19种格式(含dts);极大提升音乐包围感、临场感、带入感、效果完美。
制作碟片
一键制作cd、dvd(含dts碟片)音乐碟片;支持16种碟片类型;支持无损、有损、2.0、5.1环绕声。
音乐转换
批量音乐转换(含dts、mlp格式);高级参数设置;支持2.0、5.1、有损、无损互转;支持29种格式。
MTV音乐
一键制作15种MTV视频音乐、3种MTV DVD光盘;支持有损、无损、2.0、5.1;支持设计画面。
无损检测
批量检测无损音乐真假，让假无损音乐(QQ、酷狗、酷我、网易、网络均有不少假无损音乐)原形毕露。
dts音效大师app特色：
音乐合成
音频数据合成音乐文件;多个音乐文件合并为一个音乐文件;支持2.0、5.1、有损、无损音乐格式。
抓取光盘
一键批量抓取CD光盘、SACD光盘镜像内母带音乐文件。
EQ均衡器
简易高、中、低音调节器;15段EQ均衡调节器;音量大小调节器;可以边调边听，批量保存。
统一音量
统一音乐文件的音量大小为90dB;支持所有音乐格式。
修复音乐
修复损坏的、不能播放的、声音不正常的、编码错误的音乐文件;支持所有音乐格式。
音乐图形
批量输出音乐文件的波形图、频谱图;支持所有音乐格式。
dts音效大师app亮点：
提取人声
提取音乐文件的伴奏音;支持所有音乐格式。
提取伴奏
提取音乐文件的人声部分;支持所有音乐格式。
制作播放列表
一键制作U盘、SD卡、TFF卡、本地硬盘音乐文件M3U播放列表。
分离音轨
批量分离音乐文件的音轨数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9d896165d595dffd46f23d1f5339115/" rel="bookmark">
			lenovo启动热键_联想笔记本进bios按什么键|联想笔记本开机进入bios热键是哪个
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		联想笔记本电脑怎么进入BIOS？bios是电脑很重要的程序，通常会储存密码、启动设置等信息，在使用电脑过程中经常需要进bios设置。不少用户还不清楚联想笔记本电脑开机按什么键进bios界面，即便知道，也有可能进不去bios，因为联想笔记本不同型号机型进bios的按键不一样，有的是F2，有的是F1，有的甚至都不是，这边系统城小编就跟大家整理分享联想笔记本进bios热键是哪个的问题。
一、通过F2或Fn+F2进入
1、大部分的联想笔记本电脑，都是在开机后，不停按F2进入BIOS，有的则是需要先按住Fn，再按F2；
2、这样就进入到bios界面，不同型号的联想笔记本电脑bios界面不一样。
二、通过F1或Fn+F1进入
部分联想笔记本机型以及Thinkpad机型，是在开机过程中按F1进bios，有的需先按住Fn，再按F1进入BIOS。
三、通过启动菜单选择
1、一些机型不能通过F1或F2进入BIOS，那么这个时候尝试在启动时按F12或F11打开启动菜单，有的需要先按住Fn，再按F11或F12打开启动菜单；
2、在打开的Boot menu或Startup Device Menu中，通过↓方向键移动选择Enter Setup，按回车键，即可进入BIOS界面。
四、通过novo一键恢复菜单进入
1、很多自带win8/win10的机型，不能通过F1或F2热键进入，这时候可以尝试关闭快速启动，查看windows8系统关闭快速启动的详细步骤；
2、在关机状态下，找到电源键旁边的Novo键，一般是带有箭头按键，有的位于电脑左侧，有的位于电源键旁边，在关机状态下按下Novo键，如果是左侧的小孔，需要用牙签；
3、启动之后调出Novo Button Menu，选择BIOS Setup，按回车键，即可进入BIOS。
联想笔记本电脑怎么进入bios设置的方法就是这样子，由于联想笔记本电脑型号众多，建议大家先查看说明书，如果没有说明书，再根据本文介绍的四种方法来操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cadeeb3a92a007d8bb8de3b6d234d31c/" rel="bookmark">
			cpu过剩是什么意思_CPU过高什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
按字面理解
要么是指CPU温度过高，散热不好
要么就是指CPU性能过剩，买的太好62616964757a686964616fe59b9ee7ad9431333332636339，浪费钱
要么就是CPU占用率过高，这种情况，要么是CPU太弱，要么就是中毒了
最有可能的是进程占有高，是吧！解决办法如下：
【问题描述】：
system进程占用cpu100%，或是开很多程序导致cpu占用100%，一直降不下来
【原因分析】：
1. 虚拟内存
2. 病毒
【简易步骤】：
【我的电脑】—【属性】—【高级】—【设置】—【更改】
【操作步骤】:
方案一：查看虚拟内存，进行调试
1. 【我的电脑】—【属性】—【高级】—【设置】(如图1)
图1
2. 点击【高级】—【更改】(如图2)
图2
3. 需要把虚拟内存更改到哪个分区直接点击对应的分区，然后选择【自定义大小】进行调节。一般虚拟内存设置为物理内存的1.5——3倍即可。比如1GB电脑内存，设置虚拟内存最小值1024，最大2048；2GB电脑内存，最小值2048，最大4092即可。
但虚拟内存不是设置越大越好，针对于WIN7和VISTA系统通常不用设置，系统托管即可
方案二：电脑急救箱
1. 如果CPU占用率仍然很高，也不排除其他原因导致，可以尝试使用【360电脑急救箱】，进行扫描【C盘】。(如图3 如图4)
图3
图4
【问题描述】：
system进程占用cpu100%，或是开很多程序导致cpu占用100%，一直降不下来
【原因分析】：
1. 虚拟内存
2. 病毒
【简易步骤】：
【计算机】—【属性】—【高级】—【设置】—【更改】
【操作步骤】:
查看虚拟内存，进行调试
1. 【计算机】—【属性】—【高级】(如图1)
图1
2. 点击【高级】—【设置】
图2
3. 点击【高级】选项卡—【更改】。(如图3)
图3
4. 需要把虚拟内存更改到哪个分区直接点击对应的分区，然后选择“自定义大小”进行调节。一般虚拟内存设置为物理内存的1.5——3倍即可。比如1GB电脑内存，设置虚拟内存最小值1024，最大2048；2GB电脑内存，最小值2048，最大4092即可。
但虚拟内存不是设置越大越好，针对于WIN7和VISTA系统通常不用设置，系统托管即可
如下图：C盘设置虚拟内存 (如图4)
图4
5. 如果CPU占用率仍然很高，也不排除其他原因导致，可以尝试使用360电脑急救箱，进行扫描C盘
选择自定义扫描，扫描C盘(图5 图6 图7)
图5
图6
图7
6. 扫描完成后重启电脑尝试 。(如图8)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cadeeb3a92a007d8bb8de3b6d234d31c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61fa714af5c43a06af1f52183d551e9e/" rel="bookmark">
			cpu过剩是什么意思_CPU性能真的过剩了？那是你没用好
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常上网，大家会看到一些很有趣但也很矛盾的说法，比如说CPU性能，一方面很多人埋怨CPU进步不够大，一方面也有人整天宣扬CPU性能过剩。
CPU性能过剩论最早发源于什么时代已经不可考了，单核时代应该很少这么说，4核处理器时代一度很流行，现在是6核、8核处理器时代了，持有这种看法的人就更多了。
那么CPU性能到底是不是过剩呢？虽然有部分使用场景，如上网、看视频、听歌对硬件平台的性能要求不高，但是CPU的发展及应用都不是静止不变的。
我们要以发展的眼光看问题，目前CPU性能远没有到过剩的地步，CPU单核、多核性能在提升，玩家们的使用需求也在变化，对CPU性能提出了更高的挑战。
我们现在使用电脑的方式虽然看起来没多大变化，但是跟三年前、五年前甚至十年前相比，很多技术都是不一样的了，144Hz刷新率、4K分辨率、HDR、光线追踪甚至还有多屏，这些玩法对硬件平台的要求提升的不是一点半点。
从目前CPU的发展来看，特别是酷睿处理器近十年来的升级换代，可以看出人们对CPU性能的追求还是在不断提升的。
以目前最新的九代酷睿处理器为例，酷睿i3系列也全面升级到了4核架构了，酷睿i5系列则是6核为主，酷睿i7及酷睿i9系列都是8核8线程或者8核16线程，比两年前的酷睿系列核心数几乎翻倍，为的就是满足玩家们日益增长的CPU性能需求。
从游戏性能实测结果来看，搭配越高端的平台，与之匹配的CPU越高级，那么游戏性能也是不断增长的，就像上图中Gamenexus网站测试的的那样，玩家使用18核的酷睿i9-7980XE超频到4.6Ghz，这也能让游戏性能受益良多。
当然，主流市场的话，九代酷睿中的酷睿i9-9900K及酷睿i7-9700K两款处理器依然很强势，游戏性能依然为具有潜力，同时整套平台的成本也实惠多了，如果再小幅超频到5GHz以上，那么就可以充分发挥出CPU的游戏性能了，并不存在过剩的问题。
在游戏之外，PC用户的需求还在横向扩展，比如说现在的游戏主播，一边玩游戏，还要一边直播或者录像、语音交流，所以主播们配置的主机除了炫酷之外，性能强大也是必须的。
网上针对主播出售的主机，售价基本上都在8000以上，超过万元甚至更高的也比比皆是，他们可从来不担心性能过剩。
总的来说，CPU过剩论尽管有一定的市场，但是对那些稍微有点追求的玩家来说，性能过剩是不存在的，如果你觉得过剩了，只能说明你的需求很低，没有利用好高性能CPU的机会。
综合目前市面上的热门机型，尤其是面向大型游戏应用的，酷睿i5 6核处理器已经是基础了，高端点的会用上8核的酷睿i7-9700K，最顶级的当然是8核16线程的酷睿i9-9900K处理器，不仅单核性能优秀，日常任务毫无压力，而且多核性能也是拔尖的，玩游戏之余还可以有充足的性能承担直播、录像、语音聊天等任务。
相信在下一代酷睿平台上，Intel仍会继续全面提升规格，满足游戏、主播、设计等各种用户群体不断增长的高需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df8df881a1a55ffb75cef379c10b716d/" rel="bookmark">
			python从键盘读取6个整数、存入列表_使用整数Python从列表写入文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我试图从一个列表中写一个文本文件，它与一个字符串列表完美地结合在一起，每个元素都在一个新的行上。但是当我试图用整数从列表中写入时，它就不起作用了。
问题是我需要在代码中的另一个位置将该列表作为整数列表(在比较if语句中的值时)，并且我尝试将整数列表转换为字符串列表，但随后数字被放置在单独的行上，例如
我要用一行字写2016年：2016
但是，它变得像这样2
0
1
6
以下是写入文本文件的代码：
打印(“写入年份：”)
year.append(int(input())
…一些需要将列表年份作为整数的代码。。。
year_string=str(年)with open('movietitle.txt', 'w') as file:
file.write('\n'.join(movietitle))
with open('year_string.txt', 'w') as file:
file.write('\n'.join(year_string))
with open('genre.txt', 'w') as file:
file.write('\n'.join(genre))
with open('review.txt', 'w') as file:
file.write('\n'.join(review))
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e1a4bbf89a17cac7c052c53a585517b/" rel="bookmark">
			blob大小限制 oracle_优化InnoDB表BLOB,TEXT列的存储效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，介绍下关于MySQL InnoDB引擎存储格式的几个要点：
1、InnoDB可以选择使用共享表空间或者是独立表空间方式，建议使用独立表空间，便于管理、维护。启用 innodb_file_per_table 选项，5.5以后可以在线动态修改生效，并且执行 ALTER TABLE xx ENGINE = InnoDB 将现有表转成独立表空间，早于5.5的版本，修改完这个选项后，需要重启才能生效。
2、InnoDB的data page默认16KB，5.6版本以后，新增选项 innodb_page_size 可以修改，在5.6以前的版本，只能修改源码重新编译，但并不推荐修改这个配置，除非你非常清楚它有什么优缺点。
3、InnoDB的data page在有新数据写入时，会预留1/16的空间，预留出来的空间可用于后续的新纪录写入，减少频繁的新增data page的开销。
4、每个data page，至少需要存储2行记录。因此理论上行记录最大长度为8KB，但事实上应该更小，因为还有一些InnoDB内部数据结构要存储。
5、受限于InnoDB存储方式，如果数据是顺序写入的话，最理想的情况下，data page的填充率是15/16，但一般没办法保证完全的顺序写入，因此，data page的填充率一般是1/2到15/16。因此每个InnoDB表都最好要有一个自增列作为主键，使得新纪录写入尽可能是顺序的。
6、当data page填充率不足1/2时，InnoDB会进行收缩，释放空闲空间。
7、MySQL 5.6版本的InnoDB引擎当前支持COMPACT、REDUNDANT、DYNAMIC、COMPRESSED四种格式，默认是COMPACT格式，COMPRESSED用的很少且不推荐(见下一条)，如果需要用到压缩特性的话，可以直接考虑TokuDB引擎。
8、COMPACT行格式相比REDUNDANT，大概能节省20%的存储空间，COMPRESSED相比COMPACT大概能节省50%的存储空间，但会导致TPS下降了90%。因此强烈不推荐使用COMPRESSED行格式。
9、当行格式为DYNAMIC或COMPRESSED时，TEXT/BLOB之类的长列(long column，也有可能是其他较长的列，不一定只有TEXT/BLOB类型，看具体情况)会完全存储在一个独立的data page里，聚集索引页中只使用20字节的指针指向新的page，这就是所谓的off-page，类似ORACLE的行迁移，磁盘空间浪费较严重，且I/O性能也较差。因此，强烈不建议使用BLOB、TEXT、超过255长度的VARCHAR列类型。
10、当InnoDB的文件格式(innodb_file_format)设置为Antelope，并且行格式为COMPACT 或 REDUNDANT 时，BLOB、TEXT或者长VARCHAR列只会将其前768字节存储在聚集索页中(最大768字节的作用是便于创建前缀索引/prefix index)，其余更多的内容存储在额外的page里，哪怕只是多了一个字节。因此，所有列长度越短越好。
11、在off-page中存储的BLOB、TEXT或者长VARCHAR列的page是独享的，不能共享。因此强烈不建议在一个表中使用多个长列。
综上，如果在实际业务中，确实需要在InnoDB表中存储BLOB、TEXT、长VARCHAR列时，有下面几点建议：
1、尽可能将所有数据序列化、压缩之后，存储在同一个列里，避免发生多次off-page。
2、实际最大存储长度低于255的列，转成VARCHAR或者CHAR类型(如果是变长数据二者没区别，如果是定长数据，则使用CHAR类型)。
3、如果无法将所有列整合到一个列，可以退而求其次，根据每个列最大长度进行排列组合后拆分成多个子表，尽量是的每个子表的总行长度小于8KB，减少发生off-page的频率。
4、上述建议是在data page为默认的16KB前提下，如果修改成8KB或者其他大小，请自行根据上述理论进行测试，找到最合适的值。
5、字符型列长度小于255时，无论采用CHAR还是VARCHAR来存储，或者把VARCHAR列长度定义为255，都不会导致实际表空间增大。
后面小编会分享更多运维干货，感兴趣的朋友可以关注一下~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdd748080e3a04c10868c30f2f0e7c12/" rel="bookmark">
			prometheus命令_Prometheus配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置
Prometheus可以通过命令行参数和配置文件来配置它的服务参数。命令行主要用于配置系统参数(例如：存储的位置，保留在磁盘和内存中的数据量的大小等)，配置文件主要用于配置与抓取任务和任务下的实例相关的所有内容, 并且加载指定的抓取规则file。
可以通过运行prometheus -h命令, 查看Prometheus所有可用的命令行参数，
Prometheus服务可以reload它的配置。如果这个配置错误，则更改后的配置不生效。配置reolad是通过给Prometheus服务发送信号量SIGHUP或者通过http发送一个post请求到/-/reload。这也会重载所有配置的规则文件(rule files)。
配置文件(Configuration file)
使用-config.file命令行参数来指定Prometheus启动所需要的配置文件。
这个配置文件是YAML格式， 通过下面描述的范式定义, 括号表示参数是可选的。对于非列表参数，这个值被设置了默认值。
通用占位符由下面定义：
: 一个布尔值，包括true或者false.
: 持续时间，与正则表达式[0-9]+(ms|smhdwy)匹配
: 一个与正则表达式[a-zA-Z_][a-zA-Z0-9_]*匹配的字符串
: 一个为unicode字符串
: 当前工作目录下的有效路径
: 一个包含主机名或者IP地址，并且可以带上一个非必需的端口号的有效字符串
: 一个有效的URL路径
: 一个可以是http或者https的字符串
: 一个正则表达式字符串
其他的占位符被分开指定：
一个有效的配置文件示例。
全局配置指定的参数，在其他上下文配置中是生效的。这也默认这些全局参数在其他配置区域有效。
global:
# 抓取目标实例的频率时间值，默认1分钟
[ scrape_interval: | default = 1m ]
# 一次抓取请求超时时间值，默认10s
[ scrape_timeout: | default = 10s ]
# 执行配置文件规则的频率时间值, 默认1m
[ evaluation_interval: | default = 1m ]
# 当和外部系统通信时(federation, remote storage, Alertmanager), 这些标签会增加到度量指标数据中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdd748080e3a04c10868c30f2f0e7c12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67bb575160e29962dec1897335cf608c/" rel="bookmark">
			大小写 数据库 达梦_达梦常用语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 查询表空间
SQL&gt; select * from V$TABLESPACE;
2. 模式查询
SQL&gt; SELECT * FROM dba_segments;
通过系统视图查找，速度会慢很多 (7.1.4.6之前的版本不支持)
SQL&gt; SELECT object_name from all_objects where object_type = 'SCH';
3. 查询表
SQL&gt; select * from dba_tables where tablespace_name='%s'; //根据表空间名，大小写敏感
SQL&gt; SELECT * FROM SYSOBJECTS WHERE schid = (SELECT object_id from all_objects where object_name = '%s'
and object_type = 'SCH') and (SUBTYPE$ = 'UTAB' or SUBTYPE$ = 'STAB');
//根据模式名字，借助公共属性模式ID。UTAB用户表，STAB系统表
4. 关闭数据库
SQL&gt; shutdown normal;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67bb575160e29962dec1897335cf608c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a57effc47752b29148ca2df040b7e09/" rel="bookmark">
			siamfc代码解读_SiamFC用于目标跟踪的全卷积孪生网络 fully-convolutional siame
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SiamFC用于目标跟踪的全卷积孪生网络 fully-convolutional siame
SiamFC：用于目标跟踪的全卷积孪生网络 fully-convolutional siamese networks for object tracking
SiamFC网络
图中z代表的是模板图像，算法中使用的是第一帧的ground truth；x代表的是search region，代表在后面的待跟踪帧中的候选框搜索区域；?代表的是一种特征映射操作，将原始图像映射到特定的特征空间，文中采用的是CNN中的卷积层和pooling层；6×6×128代表z经过?后得到的特征，是一个128通道6×6大小feature，同理，22×22×128是x经过?后的特征；后面的×代表卷积操作，让22×22×128的feature被6×6×128的卷积核卷积，得到一个17×17的score map，代表着搜索区域中各个位置与模板相似度值。
算法本身是比较搜索区域与目标模板的相似度，最后得到搜索去区域的score map。其实从原理上来说，这种方法和相关性滤波的方法很相似。其在搜索区域中逐点的目标模板进行匹配，将这种逐点平移匹配计算相似度的方法看成是一种卷积，然后在卷积结果中找到相似度值最大的点，作为新的目标的中心。
上图所画的?其实是CNN中的一部分，并且两个?的网络结构是一样的，这是一种典型的孪生神经网络，并且在整个模型中只有conv层和pooling层，因此这也是一种典型的全卷积(fully-convolutional)神经网络。
在训练模型的时肯定需要损失函数，并通过最小化损失函数来获取最优模型。本文算法为了构造有效的损失函数，对搜索区域的位置点进行了正负样本的区分，即目标一定范围内的点作为正样本，这个范围外的点作为负样本，例如图1中最右侧生成的score map中，红色点即正样本，蓝色点为负样本，他们都对应于search region中的红色矩形区域和蓝色矩形区域。文章采用的是logistic loss，具体的损失函数形式如下：
对于score map中了每个点的损失：
其中v是score map中每个点真实值，y∈{+1,?1}是这个点所对应的标签。
上面的是score map中每个点的loss值，而对于score map整体的loss，则采用的是全部点的loss的均值。即：
这里的u∈D代表score map中的位置。
整个网络结构类似与AlexNet，但是没有最后的全连接层，只有前面的卷积层和pooling层。
整个网络结构入上表，其中pooling层采用的是max-pooling，每个卷积层后面都有一个ReLU非线性激活层，但是第五层没有。另外，在训练的时候，每个ReLU层前都使用了batch normalization(批规范化是深度学习中经常见到的一种训练方法，指在采用梯度下降法训练DNN时，对网络层中每个mini-batch的数据进行归一化，使其均值变为0，方差变为1，其主要作用是缓解DNN训练中的梯度消失/爆炸现象，加快模型的训练速度)，用于降低过拟合的风险。
AlexNet:
AlexNet为8层结构，其中前5层为卷积层，后面3层为全连接层；学习参数有6千万个，神经元有650,000个。AlexNet在两个GPU上运行；AlexNet在第2,4,5层均是前一层自己GPU内连接，第3层是与前面两层全连接，全连接是2个GPU全连接；
RPN层第1,2个卷积层后；Max pooling层在RPN层以及第5个卷积层后。ReLU在每个卷积层以及全连接层后。
卷积核大小数量：
conv1:96 11×11×3(个数/长/宽/深度)
conv2:256 5×5×48
conv3:384 3×3×256
conv4: 384 3×3×192
conv5: 256 3×3×192
ReLU、双GPU运算：提高训练速度。(应用于所有卷积层和全连接层)
重叠pool池化层：提高精度，不容易产生过度拟合。(应用在第一层，第二层，第五层后面)
局部响应归一化层(LRN)：提高精度。(应用在第一层和第二层后面)
Dropout：减少过度拟合。(应用在前两个全连接层)
微调(fine-tune)
看到别人一个很好的模型，虽然针对的具体问题不一样，但是也想试试看，看能不能得到很好的效果，而且自己的数据也不多，怎么办？没关系，把别人现成的训练好了的模型拿过来，换成自己的数据，调整一下参数，在训练一遍，这就是微调(fine-tune)。
冻结预训练模型的部分卷积层(通常是靠近输入的多数卷积层)，训练剩下的卷积层(通常是靠近输出的部分卷积层)和全连接层。从某意义上来说，微调应该是迁移学习中的一部分。
感知机：PLA
多层感知机是由感知机推广而来，感知机学习算法(PLA: Perceptron Learning Algorithm)用神经元的结构进行描述的话就是一个单独的。
感知机的神经网络表示如下：
多层感知机：MLP
多层感知机的一个重要特点就是多层，我们将第一层称之为输入层，最后一层称之有输出层，中间的层称之为隐层。MLP并没有规定隐层的数量，因此可以根据各自的需求选择合适的隐层层数。且对于输出层神经元的个数也没有限制。
MLP神经网络结构模型如下,本文中只涉及了一个隐层，输入只有三个变量[x1,x2,x3]和一个偏置量b，输出层有三个神经元。相比于感知机算法中的神经元模型对其进行了集成。
ReLU函数：
sigmod函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a57effc47752b29148ca2df040b7e09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55fcb47ed351ab40c45edbe917d27917/" rel="bookmark">
			Clipper库中文文档详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Clipper库中文文档详解 简介
Clipper Library(以下简称为Clipper库或ClipperLib或Clipper)提供了对线段和多边形的裁剪(Clipping)以及偏置(offseting)的功能
和其他的裁剪库相比，Clipper具有以下特征：
1. 它能够接受各类多边形输入，包含自交的多边形
2. 它支持多种填充规则(奇偶填充、非零填充、正填充、负填充)
3. 它相较于其他库效率极高
4. 它数值稳定(鲁棒性强)，鲁棒性：鲁棒性百科简介
5. 它支持多边形和线段的偏置
6. 它对于商用以及免费软件来说都是免费的
术语：
裁剪(Clipping)：通常是指在二维平面把一个图形在指定的矩形框以外的部分去除掉。在更广义的角度，指定的裁剪范围不一定是一个矩形，可以是各种各样的多边形，甚至是多个多边形；同样的，我们一般裁剪指的是形态学上的“求交”，在Clipper库中裁剪可以实现4中布尔运算(求交、求和、求异、求异或)；
路径(Path)：是指一系列的有序的点的集合，用来定义一个轮廓(Contour)，这个轮廓既可以是代指一条线/开放路径(line/open path)，也可以代指一个多边形/闭合轮廓(polygon/ closed path)
线(Line)：与Polyline同义，代指一个具有两个点或以上点的开放路径
轮廓(Contour)：与路径同义
孔洞/内轮廓(Hole)：代指一个多边形内部表示该部分不属于该多边形的闭合区域：一个“内轮廓(Hole Polygon)”就是一个代指孔的外围点集的封闭路径
多边形填充规则(Polygon Filling Rule)：即在一系列的闭合路径中，来定义哪些属于“内部”，哪些属于“外部”
预定义宏(Defines)
编译器预定义以下类型的宏：
use_int32：当启用32位精度，效率提升，但是使用范围缩小
use_xyz：添加一个Z位数据，对性能影响很小
use_lines：启用开放路径的裁剪；如果该功能关闭(默认开启)，大约有一个小于5%的性能的提升
use_deprecated：确保代码与6.0版本以前的内容相兼容；该功能未来可能会删除
取整(Rounding)
通过使用一个整形数据，Clipper库已经能够避免因为数值稳定性造成的重大错误，关于数值取整问题和可能的解决方法如下：
首先要强调的是，取整导致点会对他们本来的理论坐标形成一定程序的偏移，但是结果的不精确性是可以通过正确的缩放来进行避免的；
Clipper库自身支持可以缩放到一个相对较高精度，它所支持的整形坐标值范围在±0x3FFFFFFFFFFFFFFF (± 4.6e+18)之间
另一个使用离散数据(相较于使用浮动类型数据)的隐患在于可能在极少数的情况下会造成小的自交情况在没有缩放的左侧图片中(这里单位为1像素)，两个多边形的相交部分被用亮绿色标出；
一个30倍放大的交点部分。下图显示该图其实有很小程度的自交情况，三个黑点表明了实际的交点情况(通过展示它们小数点部分)；红色显示在取整之后交点的情况，会很容易观察到取整让方向变反并且引起了一定程度的小的自交；
尽管这些小的自交是不常见的，如果这些被认为是有必要被考虑的，最好使用CleanPolygon的属性来对这种情况进行清除；（将Clipper对象的StrictlySimple属性设定为true同样会对这类自交产生影响但是小的多余的人为引起的错误方向的多边形仍然是不可避免的)
数据类型
cInt
cInt是Clipper库用来表示点坐标数据使用的，目前Clipper库使用整形数据代替浮点数据来保证数据的鲁棒性。
默认的cInt代表了一个有符号64位整形数据并且整个多边形的坐标范围可以达到±9.2e+18的范围内。这容纳了整个浮点数坐标可以使其精度得到最完整的保留。但是，如果坐标范围可以被控制在 ± 3.0e+9之内，那么通过避免了大数的运算，可以得到大约百分之十的效率提升。如果预编译器定义了use_int32，则效率可以更高。
IntPoint
整形点数据结构用来代表Clipper库中相关的所有点；Clipper库刻意选择了整形存储类型类保证数值稳定。
一系列的IntPoint被保存在Path结构中，构成了一个轮廓。
在版本6.0以上，IntPoint现在可以拥有第三个成员“Z”，这可以通过预编译器中定义“use_xyz”来实现，当Z轴数据也被加入时，它的值也会被考虑进裁剪的行为中去，但是，在那些没有对应的Z值交点处，该值会被设定为0，除非用户提供了回调函数。
用户如果希望使用浮点数进行Clip，那么必须手动的进行正确的对浮点数进行缩放为IntPoint，在使用Clipper进行处理。
Path
这个结构包含一系列的整形数据点来定义一个单独的轮廓；路径由两个及以上的点数据组成，并且可以是开放的，当它闭合的时候也可以代表多边形(Polygon)；路径的开放与否是由其内容决定的，封闭的路径可能是“外轮廓”或“内轮廓(内孔)”，这主要由其方向(顺时针或者逆时针)决定的
多个路径可以添加进Paths结构体组成一组路径。
Paths
由多个Path组成的基本类型；
可以包含开轮廓或者闭合轮廓；
InitOptions
IntRect
用于接受Clipper库的GetBounds()函数的结果(包围盒)；
ClipType
总共有四种裁剪运算类型：AND、OR、NOT和XOR
他们的类型主要取决于他们的点集信息和填充规则，规则如下：
AND(Intersection求交)：获取两者相交的部分；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55fcb47ed351ab40c45edbe917d27917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09ae0036ad9bbb93093bfa559bd71d21/" rel="bookmark">
			[转载] for循环中let和var区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先看一段代码：
for(var i=0;i&lt;5;i++){ setTimeout(()=&gt;{ console.log(i);// 5个5 },100) } console.log(i);// 5 for(let j=0;j&lt;5;j++){ setTimeout(()=&gt;{ console.log(j);// 0,1,2,3,4 },100) } console.log(j);// 报错 j is not defined 区别：
var是全局作用域，有变量提升的作用，所以在for中定义一个变量，全局可以使用，循环中的每一次给变量i赋值都是给全局变量i赋值
let是块级作用域,只能在代码块中起作用，在js中一个{}中的语句我们也称为叫一个代码块，每次循环会产生一个代码块，每个代码块中的都是一个新的变量
结论：
在for循环中，定义自变量不要用var，使用let
原文地址：
https://www.cnblogs.com/fanfanZhao/p/12179508.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b473a3f584ffc074ecce994bd587c07b/" rel="bookmark">
			c# DataGridView的列设置combobox和设置RichTextBox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的DataGridView单元格输入中文乱码，RichTextBox可以正常输入中文，我的思路就是RichTextBox覆盖单元格，然后把RichTextBox的值传给单元格
1.新建两个控件
// 定义下拉列表框 private ComboBox cmb_Temp = new ComboBox(); // private RichTextBox text_Temp = new RichTextBox(); 绑定性别下拉列表框
/// &lt;summary&gt; /// 绑定性别下拉列表框 /// &lt;/summary&gt; private void BindSex() { DataTable dtSex = new DataTable(); dtSex.Columns.Add("Value"); dtSex.Columns.Add("Name"); DataRow drSex; drSex = dtSex.NewRow(); drSex[0] = "0"; drSex[1] = "男"; dtSex.Rows.Add(drSex); drSex = dtSex.NewRow(); drSex[0] = "1"; drSex[1] = "女"; dtSex.Rows.Add(drSex); cmb_Temp.ValueMember = "Value"; cmb_Temp.DisplayMember = "Name"; cmb_Temp.DataSource = dtSex; cmb_Temp.DropDownStyle = ComboBoxStyle.DropDownList; } 绑定数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b473a3f584ffc074ecce994bd587c07b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe0dc2c545ec3ea75b516f609fecbada/" rel="bookmark">
			LTE 测量过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述
LTE中的测量主要指连接状态下的移动性测量。RRC_CONNECTED状态下，E-UTRAN通过专属信令向UE下发测量配置（measurement configuration）。如RRCconnectionConfiguration中可以携带。
RRC_IDLE状态下，UE的测量参数通过E-UTRAN的广播获得。（小区重选是空闲模式下最重要的一项任务），在小区重选中，测量只需要进行参考信号接收功率(RSRP)的计。通过小区重选，UE端驻留到优质的小区中。UE端通过RSRP测量，获取当前服务小区和邻近小区的质量）
UE可执行的测量类型
同频测量：测量与当前服务小区下行频点相同的邻小区下行频点
异频测量：测量与当前服务小区下行频点不同的下行频点（同小区和邻小区）
连接状态测量过程主要包括以下三个步骤：
测量配置：由eNodeB通过RRCConnectionReconfiguration消息携带的measConfig信元将测量配置消息通知给UE，即下发测量控制
执行测量：UE会对当前服务小区进行测量，并根据RRCConnectionReconfiguration消息的s-Measure信元来判断是否需要执行对相邻小区的测量
测量报告：测量报告触发类型为周期型和事件型。当满足测量报告条件时，UE将测量结果填入MeasurementReport消息，发送给eNodeB.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb4063805cd6e153d610ff5f0c6318c3/" rel="bookmark">
			sqlite3_bind
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sqlite3_bind_text 中绑定的指针，在sqlite3_step 时必须存在，不能释放，否则会是乱码
sqlite3_bind_blob中绑定的指针，在sqlite3_step 时必须存在，不能释放，否则会是乱码
sqlite3_bind_int 、sqlite3_bind_double 绑定临时变量是可以的，因为传的是值
void test_parameter_binding() {
//1. 不带参数绑定的情况下插入多条数据。
char strSQL[128]; for (int i = 0; i &lt; MAX_ROWS; ++i) { sprintf(strSQL,”insert into testtable values(%d)”,i); sqlite3_prepare_v2(…, strSQL); sqlite3_step(prepared_stmt); sqlite3_finalize(prepared_stmt); } //2. 参数绑定的情况下插入多条数据。
string strSQLWithParameter = “insert into testtable values(?)”; sqlite3_prepare_v2(…, strSQL); for (int i = 0; i &lt; MAX_ROWS; ++i) { sqlite3_bind(…,i); sqlite3_step(prepared_stmt); sqlite3_reset(prepared_stmt); } sqlite3_finalize(prepared_stmt); } 这里首先需要说明的是，SQL语句”insert into testtable values(?)”中的问号(?)表示参数变量的
占位符，该规则在很多关系型数据库中都是一致的，因此这对于数据库移植操作还是比较方便
的。
通过上面的示例代码可以显而易见的看出，参数绑定写法的执行效率要高于每次生成不同的
SQL语句的写法，即2)在效率上要明显优于1)，下面是针对这两种写法的具体比较：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb4063805cd6e153d610ff5f0c6318c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c737bd43ef8e09c76778684f8cfef560/" rel="bookmark">
			心电图心电轴怎么计算_心电轴度数计算表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I
III
—
10
—
9
—
8
—
7
—
6
—
5
—
4
—
3
—
2
—
1
0
+1
+2
+3
+4
+5
+6
+7
+8
+9
+10
—
10
+240
+242
+244
+246
+248
+251
+254
+257
+261
+265
—
90
—
84
—
78
—
72
—
66
—
60
—
53
—
47
—
41
—
35
—
30
—
9
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c737bd43ef8e09c76778684f8cfef560/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/489bec4d34b2753bb07616eba3907baa/" rel="bookmark">
			在某点邻域有定义_【单选题】如果 在点 的某个邻域内有定义，且 ，则有
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【单选题】如果 在点 的某个邻域内有定义，且 ，则有
更多相关问题
已知i为虚数单位，若复数(a2－1)＋(a＋1)i为实数，则实数a的值为[ ]A.－1B.0C.1D.－1或1
若复数，则||等于[ ]A.B.C.1D.
若复数z1=a－i，z2=1＋i(i为虚数单位)，且z1·z2为纯虚数，则实数a的值为()。
复数在复平面上对应的点位于[ ]A.第一象限B.第二象限 C.第三象限D.第四象限
如果复数(m2－3m)＋(m2－5m＋6)i是纯虚数，则实数m的值为[ ]A.0B.2C.0或3D.2或3
复数z=i(l－3i)的虚部是[ ]A．－l B．l C．i D．3
复数z=(i为虚数单位)在复平面内对应的点所在象限为 [ ]A、第一象限B、第二象限C、第三象限D、第四象限
复数的实部是 [ ]A.－2B.2 C.3 D.4
已知a∈R，则复数z=(a2－2a＋4)－(a2－2a＋2)i所对应的点在第()象限，复数z对应点的轨迹是()。
若复数(m2－3m)＋(m2－5m＋6)i(m∈R)是纯虚数，则m的值为[ ]A.0B.2C.0或3D.2或3
复数的共轭复数=()。
已知复数(a∈R，i为虚数单位)，若z是纯虚数，则实数a等于 [ ]A．B．－C．1D．－1
已知复数，则|z|= [ ]A、B、C、 D、2
若复数(x∈R)为纯虚数，则x等于 [ ]A、0 B、1 C、－1D、0或1
设复数z1=1＋i，z2=2＋bi，若为纯虚数，则实数b=[ ]A.－2B.－lC.l D.2
已知复数zl=m＋2i，z2=3－4i，若为实数，则实数m的值为 [ ]A、B、C、D、
若，则复数(cosθ＋sinθ)＋(sinθ－cosθ)i在复平面内所对应的点在[ ]A.第一象限B.第二象限C.第三象限D.第四象限
已知i为虚数单位，则复数对应的点位于[ ]A．第一象限B．第二象限 C．第三象限 D．第四象限
已知复数z1=sin2x＋λi，z2=m＋(m－cos2x)i(λ，m，x∈R)，且z1=z2。(1)若λ=0且0＜x＜π，求x的值；(2)设λ=f(x)，求f(x)的最
复数(1－3i)3的虚部为[ ]A.3B.－3C.2D.－2
已知复数z与(z－2)2－8i都是纯虚数，则z=()。
已知复数zl=m＋2i，z2=3－4i，若为实数，则实数m的值为 [ ]A、B、C、D、
已知复数z与(z ＋2)2－8i 均是纯虚数，则z=()。
已知复数z满足(z－2)i=1＋i(i是虚数单位)，则复数z的模是()。
复数的虚部为[ ]A．0B． C．1 D．－1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/489bec4d34b2753bb07616eba3907baa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dc2d20f9a52444425541309f18b1175/" rel="bookmark">
			在电脑上显示未知发布者怎么办_Win7无法验证发行者、未知发布者的解决方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win7加强了安全性，所有软件必须向微软申请数字签名并且通过审核，运行时才不会弹出诸如无法验证发行者、未知发布者这样的提示。但申请数字签名是要交钱的，有些软件为了节约成本，尤其是个人开发的免费软件，就没有申请数字签名，所以每次打开总是提示“无法验证发布者。您确定要运行此软件吗？”，挺烦人的，不过也有解决办法让系统不再提示，一起有三种方法，下面分别介绍。
方法一：不勾选“打开此文件前总是询问”
当打开未申请数字签名的软件时，会弹出一个提示窗口，如图1所示：
图1
把“打开此文件前总是询问”前面的勾去掉，单击“运行”，成功打开软件后，下次再打开该软件就不会提示了。
方法二：解除锁定
1、右键待解除锁定的软件，选择“属性”，打开窗口如图2所示：
图2
2、单击“解除锁定”，再单击“确定”，下次打开此软件就不会再提示无法验证发行者了，可以打开测试一下。
3、再次打开属性窗口，已经没有“解除锁定”字样，跟普通文件夹和文件的属性窗口一样了(图3)。
图3
方法三：关闭用户帐户控制(UAC)
1、依次选择“开始” → 控制面板 → 系统和安全 → 更改用户帐户控制设置，打开窗口如图4所示：
图4
2、把滑块拖到最下面(从不通知)处，单击“确定”即可；以后，当软件对计算机进行更改就不会弹出提示。
另一种关闭用户帐户控制(UAC)的方法：
依次选择“开始” → 所有程序 → 附件 → 入门 → 选择何时通知您有关计算机更改的消息，打开窗口如图4，同样把滑块拖到最下面即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ba2cdaff4c23f72465e682eb1f40d72/" rel="bookmark">
			python request delete_python request 模块详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		request
Requests 是使用 Apache2 Licensed 许可证的 基于Python开发的HTTP 库，其在Python内置模块的基础上进行了高度的封装，从而使得Pythoner进行网络请求时，变得美好了许多，使用Requests可以轻而易举的完成浏览器可有的任何操作。
GET 请求
# 1、无参数实例
import requests
ret = requests.get('https://github.com/timeline.json')
print ret.url
print ret.text
# 2、有参数实例
import requests
payload = {'key1': 'value1', 'key2': 'value2'}
ret = requests.get("http://httpbin.org/get", params=payload)
print ret.url
print ret.text
POST 请求
# 1、基本POST实例
import requests
payload = {'key1': 'value1', 'key2': 'value2'}
ret = requests.post("http://httpbin.org/post", data=payload)
print ret.text
# 2、发送请求头和数据实例
import requests
import json
url = 'https://api.github.com/some/endpoint'
payload = {'some': 'data'}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ba2cdaff4c23f72465e682eb1f40d72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8741e1771ad96893ca2266d8b3c1fb7/" rel="bookmark">
			机器人周志_世界第一个机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上个月，"机器人之父"恩格尔伯格去世。
《财新周刊》的编辑让我写他的介绍。我查了网上资料，发现那些早期机器人的照片非常有意思。
下面就是我写的人物生平，配上这些有趣的照片。
1.
12月1日，被誉为"机器人之父"的约瑟夫·恩格尔伯格(Joseph Engelberger)，在美国因病去世，享年90岁。他发明制造了人类第一台机器人。
恩格尔伯格1925年生于纽约，先后获得哥伦比亚大学物理学士和电子工程硕士学位。
2.
1950年，恩格尔伯格读到了阿西莫夫的小说集《我，机器人》(I， Robot)，爱不释手，产生了制造机器人的念头。
3.
1956年的一场酒会，他偶遇发明家德沃尔(George C. Devol)。后者提到，他刚刚申请了一个专利，叫做"可编程的用于移动物体的设备"(Programmed Article Transfer)。恩格尔伯格脱口而出，"这不是阿西莫夫笔下的机器人吗！"两人一拍即合，决定合作创立一家生产机器人的公司。
4.
新公司取名Unimation，意为"自动化单位"，1958年正式运作。当年就拿出了第一个产品：一个可以自动完成搬运的机械手臂。虽然，这个产品庞大而笨重，只能完成很简单的任务，但它是人类历史上第一个机器人。
5.
恩格尔伯格和德沃尔从一开始就很清楚，机器人的研发成本很高，只有大公司才买得起。他们把研发方向定在为重型制造业服务，让机器人承担对人类有危险的工作。美国最大的通用汽车公司，是他们首先想到的目标客户。
6.
恩格尔伯格游说通用汽车，希望他们买一台机器人。由于以前从来没有这种东西，很多人对这个产品将信将疑。1961年，通用汽车好不容易答应，在离纽约最近的新泽西工厂，装一台试试看。第一台Unimation机器人的成本是6万美元，售价却只有2万5千美元，因为不这样就卖不出去。
7.
工业机器人在生产线上的作用非常明显，动作精准、永不疲倦、不怕高温和污染。比如，焊接工作处于高温环境，会产生有害气体，工人一不小心就会中毒，机器人就没有这个问题。
通用汽车开始订购更多的机器人，安装在全美各地的工厂，承担的工作扩展到焊接、油漆、粘合和装配。这帮助它取得了自动化生产的革命性突破，巩固和扩大了行业领先地位。其他汽车公司纷纷跟进，将机器人用于自家的流水线。美国机器人协会后来评价，恩格尔伯格的这个发明"彻底改变了现代工业和汽车制造的流程"。
8.
上个世纪60年代，现代工业革命达到了顶峰，阿波罗计划把人类送上了月球，整个美国都对新技术、新设备充满了兴趣。1966年，最热门的晚间谈话节目把Unimation机器人请上了电视，让它对着300万全国观众，发高尔夫球、倒啤酒、挥舞指挥棒，甚至拉手风琴。从此，恩格尔伯格一举成名。
9.
1969年，日本人将恩格尔伯格请到东京演讲，指导日本汽车厂商研发机器人。
10.
川崎重工引进了Unimation机器手臂。这件事对日本汽车工业有深远影响，日本后来超过美国成了"机器人王国"。恩格尔伯格在这个过程中扮演了重要角色，他在日本的知名度甚至比在美国还要大。
11.
随着年龄和荣誉的增长，恩格尔伯格在技术上变得保守。他不赞成在机器人内部，使用电机替代液压，也不认为制造有腿的机器人是必要的，使用轮子更符合实际。这导致他在1983年将Unimation公司以1.07亿美元的价格，卖给了西屋公司，退出了工业机器人行业。
那时，恩格尔伯格可谓功成名就。第一个Unimation机器人，在运作了10万个小时之后，已经光荣退役，送进了博物馆。全世界制作业使用的机器人，超过了300万个。他本人也当选了美国工程院院士。
12.
他并没有就此止步，1984年又创建了TRC公司，研发服务机器人。1988年，他又推出了世界第一个服务业机器人HelpMate。
13.
这个机器人用来在医院走廊穿行，为病人送饭、送药、送邮件，并记录病人的情况。
14.
恩格尔伯格的目标是为机器人装上各种传感器，使其能够直接为人类服务，首先是帮助老年人和残疾人。
15.
他觉得，很多老人进入养老院时，心智还十分健康，只是行动不便，不能很好地照顾自己。
16.
机器人能够承担重复性家务，比如取物、清洁、做饭等等，用来护理老年人，最合适不过了。
17.
接受彭博商业周刊采访时，恩格尔伯格说道，"家用机器人比工业机器人有更广阔的市场前景"。
18.
他认为，机器人未来一定无处不在。他更想作为"家用机器人之父"被人们铭记。
(完)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7b73a8962417fd794f59e9d25521779/" rel="bookmark">
			uml边界类例子_课内资源 - uml边界类、控制类、实体类介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.
一、 识别分析类(只列出类的名称就可以)
.
1、 识别边界类的列表
边界类 说明
BrowseBook 读者、游客和管理员浏览图书
RetrievalBook 读者、游客和管理员检索图书
AdministrationBook 管理员管理图书
BorrowBook 读者借阅、续借、归还图书
LateFee 读者交滞纳金
RevisedInformation 读者和管理员修改资料
2、 边界类建模
3、 识别控制类的列表
控制类 说明
RegisterControl 负责执行读者的注册
BrowseControl 负责执行读者、游客和管理员浏览图书
RetrievalControl 负责执行读者、游客和管理员检索图书
AdministrationControl 负责执行管理员管理图书
BorrowControl 负责执行读者借阅、续借和归还图书
LateFeeControl 负责执行读者交滞纳金
ReviseControl 负责执行读者和管理员修改资料
4、 控制类建模
5、 识别实体类的列表
实体类 说明
BookInfo 图书基本信息
DataInfo 读者和管理员信息
OrderInfo 借书订单信息
6、 实体类建模
.
二、 建立动态模型—顺序图
.
1、 建立查询图书用例顺序图
2、 建立删除图书用例顺序图
3、 建立滞纳金用例顺序图
.
三、 建立动态模型—活动图
1、 建立借阅图书用例的活动图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7b73a8962417fd794f59e9d25521779/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1db61d58bc8e4fa43ad0a9a95745ab7b/" rel="bookmark">
			kirin710f是什么处理器_麒麟710与710f的区别，麒麟710和710f哪个强
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
麒麟710F是不是阉割版？很多消费者们对此感到纠结，甚至有网友在论坛称麒麟710F不是标准的麒麟710，是专门为荣耀8X低配版提供专用的芯片，其它版本则不采用麒麟710F。麒麟710与710F的区别，麒麟710和710F哪个强？下面小编来跟大家一起分享。
麒麟710F是不是阉割版？很多消费者们对此感到纠结，甚至有网友在论坛称麒麟710F不是标准的麒麟710，是专门为荣耀8X低配版提供专用的芯片，其它版本则不采用麒麟710F。麒麟710与710F的区别，麒麟710和710F哪个强？下面小编来跟大家一起分享。aMW高通骁龙
aMW高通骁龙
麒麟710与710F的区别aMW高通骁龙
aMW高通骁龙
根据官网介绍，麒麟710F和麒麟710参数一样，并不存在低主频，其它规格方面都是相同的。而唯一不同的是，麒麟710F和麒麟710封装工艺不同，不过对性能上不会有什么影响，所以消费者们也完全没必要太过于纠结。尽管只是为荣耀8X低配版使用，但不代表麒麟710F处理器存在缩水。aMW高通骁龙
aMW高通骁龙
麒麟710相当于骁龙多少aMW高通骁龙
aMW高通骁龙
麒麟710安兔兔跑分大约在13万分左右，性能水平也就一般般，还不如前两年的骁龙660，唯一优势也只有工艺方面稍微领先。麒麟710采用12nm工艺制程，骁龙660采用14nm工艺，不过要知道骁龙660早两年推出上市，所以跟一个老古董对比，麒麟710性能也就一般了。aMW高通骁龙
aMW高通骁龙
图为麒麟710安兔兔跑分成绩▲aMW高通骁龙
aMW高通骁龙
aMW高通骁龙
图为骁龙660安兔兔跑分成绩▲aMW高通骁龙
aMW高通骁龙
CPU核心价格两者都是一样的，当然CPU主频肯定不同，麒麟710采用4个A73大核(2.2GHz)+ 4个A53(1.7GHz)共八核设计，骁龙600采用4xA73大核(2.2GHz)+ 4x A53(1.8GHz)小核 共八核设计。理论上CPU性能是不存在多少差别的，但是骁龙660/Adreno 512 GPU性能更强一些，所以安兔兔跑分麒麟710就稍微比骁龙660落后一丢丢。aMW高通骁龙
aMW高通骁龙
以上就是关于麒麟710与710F的区别，麒麟710和710F哪个强的内容介绍，想了解更多相关精彩资讯请小伙伴们多关注本站哦！aMW高通骁龙
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f89c510609bea90e041d5a43feca72c/" rel="bookmark">
			扫地机器人噪音响_硬件老兵拆机分析：扫地机器人噪音大小到底与何相关？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬件老兵拆机分析：扫地机器人噪音大小到底与何相关？
2019-12-14 13:30:40
497点赞
490收藏
23评论
一、前言
大家好我是abrams2415，扫地机自从2012年开始玩。已经被我拆了很多台扫地机做研究了。
最近看了很多扫地机器人的评测对比文章。发现各个品牌的扫地机器人噪音大小各不相同，而且目前国内扫地机器人风机大部分都是采用Nidec的，为何一样的风机品牌噪音大小却不一样呢？正好手边有机器，可以为大家一探究竟。
文章中所涉及到的三款扫地机品牌分别如下：科沃斯扫地机器人T5Max智能家用全自动吸尘器洗擦地拖地扫一体机黑色4108元京东去购买石头(roborock)扫地机器人2019新款T6扫拖一体机激光导航规划全自动智能家用吸尘器T65(礼盒版)2899元京东去购买
360扫地机器人X90扫拖一体激光导航电控大水箱5200mAh电池可吸小米粒石头吸尘器超薄拖地机器人地宝2499元京东去购买
二、测试环节
具体的噪音数据我就不测了，主要从硬件设计的角度来解释为啥有的扫地机器人噪音大有的却小一点。
噪声参数对比：引用作者@SeanlXz的横评文章科沃斯T5 max、石头T6、360 X90三款旗舰扫地机器人横评科沃斯T5max、石头T6、360X90三款旗舰扫地机器人横评前言最近很多朋友咨询我扫地机的选购问题，或者在犹豫需不需要一台扫地机，所以我专门花了几天时间，把几台旗舰机器做了一个对比测试，供大家参考。以前光看大家的评测，从来没动笔写过，要是有什么纰漏也请大家海涵。我最早用的是米1扫地机，用了将近两年SeanIXz|赞724评论220收藏952查看详情
中有关噪声测试的结果图片，文中所述测试条件为标准档，原图如下：
▲三款不同型号扫地机器人噪音对比
一般来说扫地机器人的风机吸力越大，转速越快的同时产生的噪声会越大。所以我分别测了这三个品牌的吸力，测试条件也同为标准档，测试部位为中扫吸口位，测试方法为用油泥封堵，管道连通风压计，如下图：
测试位置和方法和测试设备：
本次测试结果如下：
归纳如表：
从结果来看，吸力大的，反而噪音却变小，吸力最大的X90噪音值为58.1dB，小于另外两款机型。到底是什么导致的这种情况呢，带着疑问我们拆机一看究竟。
这里我选择进行进一步拆机，以拆机的先后顺序分别从风机风道结构布局、风机品牌型号、风机装配方式、风道设计长度、风道和出风口降噪消音处理方法等方面细分对比。
2.1 风机风道结构布局，附空气流动示意图：
石头T6
360 X90
上述3款扫地机从结构布局来看，进风道、风机、出风道在连接和完整风路通道的达成上都没有问题。
2.2 风机品牌
科沃斯T5
石头T6
360 X90
风机品牌供应商均为Nidec，说明电机是静音的。发出噪音的一般是涡扇搅动空气时发出的，但是这种噪音在单体上是无法避免，这就需要在风道上下功夫，尽最大可能去降低这些噪音，或减小这些噪音传出机体外。接下来我们继续探究各家在降噪方面做的哪些努力以及产生差别的原因。
2.3 风机的装配，密封和减振
科沃斯T5
石头T6
360 X90
从风机装配看，总结一下主要是通道密封和减振两个重点：
首先从密封来看，T5风机不是整体模组，即只有电机涡轮组件，外壳是另外配合设计。在密封上不如原厂整体性好。其次是T6，风机虽是整体模组，但与进风道配合的密封处采用泡棉不如硅胶来的严实。X90风机上下都是硅胶件，在密封上更可靠一些。
第二是减振，T5减振是依靠两处螺钉橡胶垫，T6除了密封泡棉再没有其它减振设计，风机整体也是用一个硬胶压片用螺钉硬性固定在主壳上的。X90风机上下都是硅胶，由进和出两处风道上下夹着，风机和壳体没有硬接触的地方。
2.4 风道设计的长度
科沃斯T5
石头T6
360 X90
一般来说，进风道越短越有利于空气流动补偿，太长的话，风机载荷越大，转起来越费劲，打个比方如果拿半米长的吸管吸水，水还没到嘴里，人已经累的半死。另外，对于出风道，虽然并不是越长越好，但太短也有两个不利因素，一是风机涡轮处噪音直接释放到机外，二是做降噪处理空间有限，有劲也没地方使。
综合以上对比，进风道最优的是T5，X90其次，出风道最优的是X90。
2.5 风道和出风口在降噪上的处理(这里只针对出风道做说明)
科沃斯T5
石头T6
360 X90
科沃斯T5 MAX ABS壳体(无独立风道)
石头T6 软橡胶+出风口双层消音海棉
360 X90 ABS+全通道腔体吸音棉+出风口单层消音海棉
特别说明的是X90设计了一个风道腔体，在不影响风路通顺的情况下差不多被消音棉填满，所以好的风道设计总结出来有三点：风道通顺，风阻低；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f89c510609bea90e041d5a43feca72c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b992d4f6a9a3d714746377c7a577afb/" rel="bookmark">
			扫地机器人噪音响_用扫地机器人楼下吵吗？会不会有噪音扰民？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着科技日新月异的同时，越来越多的懒人智能工具被开发出来，推向市场，且被火热应用。其中，扫地机器人就是这么一种深受最捧的懒人神器！
据统计，使用扫地机器人的往往是那些居住于城镇公寓房单元套间的人群，像这样的单元房，楼上楼下，左邻右居都离得很近，若使用扫地机器人楼下吵吗？会不会有噪音且被认为扰民呢？
1、扫地机器人的三档设置：
通常，各品牌的扫地机器人都会在功能上设置三档：静音档、标准档、强力档。
如果你开启的是静音或标准档，那么扫地机器人本身在使用过程中所产生的所谓噪音是可以忽略不计的，就算你跟着它走，也只能听到一些细微的轮子走动声。
而如果开启强力档，虽然声音响些，但相比较于吸尘器或是电吹风产生的声响，那简直就是静音的感觉。
因此，从扫地机器人设置上来说，无论哪一档，都不会影响楼下，更别提是扰民了。
2、扫地机器人的声音来源解析：
虽说扫地机器人在工作时产生的声响不足以影响楼上、楼下、左邻右舍，但毕竟声音总归还是有一些的，那让我们追根溯源，看看扫地机器人的声音来源：
(1)扫地机器人驱动电机发出的声音，由设备功能设置来控制声音大小。
(2)扫地机器人走动地面过程中，滚轮与地面接触时的声音，因为滚轮是特别配置的，其产生的声音也是极为轻的。
现在，你该知道用扫地机器人楼下不会感觉到吵了吧！而且也将其中的原因也作了一一分析，这下你该彻底了解了吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bba1366392d8f4d6b9d993b1d1b80b3/" rel="bookmark">
			扫地机器人噪音响_如何减少扫地机器人在工作中的噪音问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何减少扫地机器人在工作中的噪音问题
为了让日常生活家居环境更好，干净卫生，就出现了许多品牌的智能扫地机器人。但是，现在有许多品牌的扫地机器人由于高转速、大功率的电机，和吹风机其它家用电器一样，清扫时总是会产生很大的噪音，让人非常困恼。有些什么技巧可以让智能扫地机的声音能小一些呢？来看看如何减少噪音的技巧吧。减少噪音：
1.目前的家用扫地机市场普遍使用的真空(即使用负压除尘，垃圾入集尘盒)，滚动刷，清洁刷。由真空清扫机是由电机产生的转动，电机功率越大，吸力大，但同时，声音更大。李玲建议，在购买家用清洁机，不需要太高，在1200W ~ 2000W的范围能满足家居生活的需要。
2.我们都应该明白这样一个道理：在回波的密闭的空间也就越大，所以，在一个封闭的房间清扫机的使用产生的噪声越大。小编建议，在扫地机器人工作的时候，将窗户和门打开，可以有效的减小噪音。
当然除了噪音问题，扫地机器人的定期清洗和维护也是非常重要的。比如说当我们购买科沃斯扫地机器人，使用一段时间后，该怎样清洁和维护呢？
拆下前盖。当我们打开上盖，可以看到集成箱。拆下组合框，当我们卸下集成箱，可以清楚的看见机内裂纹间的尘埃。因为集成箱科沃斯地宝相对较小，而不使用像吸尘器旋风吸粉尘，对两种污染处理能力，科沃斯智能扫地机器人还有待加强，它仍然是学习阶段。
为了防止灰尘进入地面，集成盒在浇注完毕后，如果你发现集的灰尘较多，在抗菌底部封闭的过滤棉被阻时，建议把你拉开尘盒，盒子打开底盖清洁集成。抗菌。过滤棉可用水冲洗，但再次使用时必须干燥。主要是刷下到扫地。科沃斯地宝在日常工作中容易伤头发。当缠绕主刷毛发太多，将严重影响科沃斯扫地机器人的工作。小编提醒你，你只要主刷旁边的两个小螺丝，可以很容易地卸下主刷，然后用购买产品时配带的滚刷清扫工具，可以很容易地解决缠绕的头发。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7451ab619f046a4d437e169d5d6d103a/" rel="bookmark">
			扫地机器人噪音响_扫地机器人工作噪音大怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：扫地机器人工作噪音大怎么办
很多消费者在使用扫地机器人，尤其是一些杂牌扫地机器人的时候，总是会发现扫地机器人在工作的时候噪音特别大，不管是工作还是休息，都会受到影响。这可如何是好？购买一款扫地机器人，可不是为了让他们扰乱自己的生活的。今天，小编就来和大家说说，如何才能顺利解决扫地机器人噪音问题。
要想彻底解决，就必须从源头上找到问题的根源，我们必须对扫地机器人的噪音产生原因进行仔细分析。一般来说，扫地机器人噪音主要来自于两个地方，一个是它的零部件不灵活，比如说边刷或者滚刷周围有异物，因此高速转动的时候就会发出噪音，另一个则是因为它的主机质量差，内部设计的不够完善，因此在工作中就容易发出噪音。要想降低扫地机器人噪音，必须要从这两个方面着手。
对于扫地机器人的配件上的问题，处理起来相对容易一些，大家可以将这些配件拆卸下来，把其中的一些杂物清理干净，试试噪音是否变小了。当然，在日常的生活中，大家也不能每次都等出现问题了再进行清理，而应该在平时就注重扫地机器人的保养工作，定期清洁机器人的配件和机体，这样才能保证机器人的工作效果，延长扫地机器人使用寿命。
而如果是主机质量差的问题，相对来说就比较棘手了。因为大家很难自行对主机进行拆卸，所以要进行清理就只能将扫地机器人寄回给原厂家，当然，这还只是异物进入到扫地机器人主机内部的情况。如果扫地机器人噪音问题是因为机器人本身设计上的缺陷，那么想要降低噪音就只能重新换一台了。
所以说，要降低扫地机器人噪音，最好的方法还是在购买的时候就仔细挑选。比如说像科沃斯地宝这样的扫地机器人，在设计的时候就应该着重考虑工作时候的噪音问题。它的电机采用了纯铝材料，并且在电机舱内增加了隔音棉，有效降低了电机运转时候的噪音，这就是科沃斯地宝工作时候“悄无声息”的理由了。
以上就是扫地机器人噪音产生的一些原因和解决方法，要想彻底解决噪音问题，最好的办法还是选择一款科沃斯这样的优质品牌的扫地机器人，这样才能有效地保证大家的工作休息不受干扰。返回搜狐，查看更多
责任编辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2f4b193b7b4ea161f85a3bb6077362d/" rel="bookmark">
			idea怎么进行c语言编程_IDEA加密算法的C语言实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
1、数据加密的基本过程就是对原来为明文的文件或数62616964757a686964616fe78988e69d8331333337616633据按某种算法进行处理，使其成为不可读的一段代码，通常称为“密文”，使其只能在输入相应的密钥之后才能显示出本来内容，通过这样的途径来达到保护数据不被非法人窃取、阅读的目的。
2、常见加密算法
DES(Data Encryption Standard)：数据加密标准，速度较快，适用于加密大量数据的场合；
3DES(Triple DES)：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高；
RC2和 RC4：用变长密钥对大量数据进行加密，比 DES 快；
IDEA(International Data Encryption Algorithm)国际数据加密算法：使用 128 位密钥提供非常强的安全性；
RSA：由 RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的；
DSA(Digital Signature Algorithm)：数字签名算法，是一种标准的 DSS(数字签名标准)；
AES(Advanced Encryption Standard)：高级加密标准，是下一代的加密算法标准，速度快，安全级别高，目前 AES 标准的一个实现是 Rijndael 算法；
BLOWFISH，它使用变长的密钥，长度可达448位，运行速度很快；
其它算法，如ElGamal、Deffie-Hellman、新型椭圆曲线算法ECC等。
比如说，MD5，你在一些比较正式而严格的网站下的东西一般都会有MD5值给出，如安全焦点的软件工具，每个都有MD5。
3、例程：#include
#include
#include
#include
#define maxim 65537
#define fuyi 65536
#define one 65536
#define round 8
unsigned int inv(unsigned int xin);
unsigned int mul(unsigned int a,unsigned int b);
void cip(unsigned int IN[4],unsigned int OUT[4],unsigned int Z[7][10]);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2f4b193b7b4ea161f85a3bb6077362d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/337/">«</a>
	<span class="pagination__item pagination__item--current">338/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/339/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>