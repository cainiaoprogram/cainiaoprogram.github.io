<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7522798c5a449ef40e01c8c0c98bab07/" rel="bookmark">
			BFC详解,从官方定义到上机实操
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方定义 块级格式化上下文（Block Formatting Context，BFC是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程法神高度区域，也是浮动元素与其他元素交互的区域。
下列方式之一都可以创建BFC：
根元素（&lt;html&gt;)浮动元素（元素的float不是none）绝对定位元素（元素的position为absolute或fixed）行内块元素（元素的 display 为 inline-block）表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table）overflow 值不为 visible 的块元素display 值为 flow-root 的元素contain 值为 layout、content或 paint 的元素弹性元素（display为 flex 或 inline-flex元素的直接子元素）网格元素（display为 grid 或 inline-grid 元素的直接子元素）多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。 块格式化上下文包含创建它的元素内部的所有内容。
块格式化上下文对浮动定位（参见 float）与清除浮动（参见 clear）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。
以上就是MDN官方文档的部分解说了，但是还是有点懵，现在我们看看正经的。。。。
创建BFC的条件（上面官方的说法有点啰嗦，我们再简单地总结一遍） 只要元素满足下面任一条件即可触发 BFC 特性：
body 根元素浮动元素：float 除 none 以外的值绝对定位元素：position (absolute、fixed)display 为 inline-block、table-cells、flexoverflow 除了 visible 以外的值 (hidden、auto、scroll) BFC的布局规则(这个可以细品，看完下面的例子再回来看看） 内部的Box会在垂直方向，一个接一个地放置。Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠每个元素的左外边缘（margin-left)， 与包含块的左边（contain box left）相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。除非这个元素自己形成了一个新的BFC。BFC的区域不会与float box重叠。BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。计算BFC的高度时，浮动元素也参与计算 BFC可以解决什么问题？ 利用BFC避免margin重叠使BFC内部浮动元素不会到处乱跑自适应两栏布局 一、利用BFC避免margin重叠 首先会发生margin重叠的肯定使同一个BFC内的块级元素，例如div，p，不是块级元素不会发生重叠。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7522798c5a449ef40e01c8c0c98bab07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72ee3613bd9cce21741a364c05d2cfdb/" rel="bookmark">
			IDEA 快速接口生成实现类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 IDEA 快速生成接口实现类1. 定位到要实现的接口名2. 确认实现类名与路径3. 选择实现方法4. 获得实现类 IDEA 快速生成接口实现类 1. 定位到要实现的接口名 Alt + 回车，选择 Implement interface：
2. 确认实现类名与路径 也可以在 Destination package 中指定未创建的包名，IDEA 会自动生成新包名，如 com.regino.dao.impl（推荐） 3. 选择实现方法 4. 获得实现类 原文链接：https://qwert.blog.csdn.net/article/details/106039691
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75837a2af6e5123b0d540975acfccedc/" rel="bookmark">
			超级厉害的几个网站，一般人我都不告诉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家分享 一些超级实用方便的网站，一把人我都不告诉他们（小声逼逼），每个网站都很有用，下面上菜喽
1.http://www.uugai.com/
一款logo免费制作的网站，在做一些临时的项目，很紧急要用一下的时候可以拿来用一下，非常的方便便捷。
2.https://www.iconfont.cn/ 阿里巴巴矢量图标库
这个不用多说了吧，太厉害了
3.http://www.aigei.com/ 爱给网
音效配乐，3D模型，视频素材，游戏素材都可以免费下载 制作视频啥的很方便
4.https://www.addpdf.cn/
PDF转Word，非常方便
5.https://flatuicolors.com/
一个颜色网站，俺也不知道怎么描述哈哈哈，各种好看的颜色，简直不要太好看。
直接点击你想要的颜色就可以复制了。
6.http://zhongguose.com/
一款中国色的网站，都是一些有中国特色的颜色。非常好看。点击想要的颜色右侧会出现数值即可复制，
7.https://www.dalipan.com/
这个就牛逼了，我认为最厉害的网站了，只有你想不到，没有它搜不到的，各种软件安装包，各种资源，都是以百度网盘链接的形式，搜资源太好用了。
8.http://defubjt.cn/
一款搜索各种影视资源的网站，非常适合我这样的贫农，也是以百度网盘连接的方式，可以保存到自己的网盘在观看
9. https://www.liaoxuefeng.com/
廖雪峰的官方网站，学习的好地方啊，你值得收藏
10.https://www.w3school.com.cn/
w3school这个网站不用我多说了吧，知名度很高的，对前端感兴趣的可以去学习一下。
11.再给大家说两个技巧
百度文库免费下载，打开文章的网页，在baidu后面加上 vvv 即可下载
万能命令方式，在任何网址的前面加上 wn.run/ 即可展示可用于该网页的在线工具，视频，音乐，各种非常厉害
后续更新
12.https://www.91sotu.com/
搜图导航，汇集了各大图片网站，可以找到自己喜欢的图片。
13.https://www.remove.bg/zh
这个网站可以消除图片中的背景，用来抠图很方便
14.http://www.hiwenku.com/
嗨文库，下载某度文档的，哈哈
15.https://tool.lu/
这个厉害，自己打开看吧。
就暂时这么多了，后续有了再来更新，就让这篇博客在你的收藏夹落灰吧，奥利给
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/148419d17874c41eeff79c8faa0c8228/" rel="bookmark">
			Win7连接蓝牙4.0鼠标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了便携，买了个小米无线鼠标。有两种模式，一种是插无线收发器，一种是蓝牙。插收发器倒是没任何问题，但是占一个USB口总是不爽。蓝牙模式很奇怪，在家里的Win10电脑可以连，但是办公用的Win7电脑就是搜不到鼠标。
查了很多资料，主要有几种说法：
1、说电脑没有蓝牙的、蓝牙模块不是4.0的、硬件不支持什么的：纯是自说自话。
2、还有说Win7就是不支持，Win8以上才支持蓝牙4.0：接近真相了，但原因还是不准确。
3、蓝牙4.0采用BLE技术（Bluetooth Low Energy 蓝牙低能耗技术），但是其驱动程序没有包括在Win7系统内，而是从Win8开始带有BLE驱动：真相在此。
关键是Intel官网的Win7最新驱动，包括系统默认安装的、驱动精灵、驱动大师等工具自动安装的，都是不带BLE驱动的。
当你在官网搜索Win7蓝牙驱动时，找到的最新版本是这个：https://downloadcenter.intel.com/zh-cn/download/29330/-Windows-7-?product=59485
然而，BT_21.40.5_64_Win7.exe里面没有BLE驱动，不能支持蓝牙4.0设备。
解决办法： Intel蓝牙设备
刚才说了，通过工具和官网更新蓝牙驱动都不能解决这个问题。更不需要更换什么蓝牙模块的硬件。
1、在设备管理器中卸载原来的蓝牙驱动。
2、在官网找到带有BLE的蓝牙驱动：https://downloadcenter.intel.com/zh-cn/download/28622/-7260-AC-3160-
3、下载安装对应版本的驱动程序（BT_21.10.1_64_Win7.exe）就可以了。
看来Intel的版本管理有问题啊。
成功节省一个USB接口，哈哈。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd5b0735a763b9da83a2ac02621a52c0/" rel="bookmark">
			golang源码阅读-context.WithTimeout
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		context.WithTimeout 可用于一定时间关闭函数或调用，如调用超时，主动关闭调用
1.context.WithTimeout简单使用
func main() { ctx, _ := context.WithTimeout(context.Background(), 4*time.Second) printNum2(ctx) } func printNum2(ctx context.Context) { //要打印的数字 n := 0 for { select { case &lt;-ctx.Done(): fmt.Println("结束") return default: fmt.Println("数字: ", n) n++ } time.Sleep(time.Second) } } 2. WithTimeout实现
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) { //调用WithDeadline， 当前时间+timeout，时间到了 done管道收到信息，函数自行关闭 return WithDeadline(parent, time.Now().Add(timeout)) } 3.WithDeadline实现
func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) { if cur, ok := parent.Deadline(); ok &amp;&amp; cur.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd5b0735a763b9da83a2ac02621a52c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8829e4e54a3a3ba68371a4ad8d50bf5/" rel="bookmark">
			CentOS中设置的网络类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CentOS中设置的网络类型 桥接模式 CentOS会延用母机的IP段(ip地址前3段),补充最后的地址.CentOS系统可以直接访问外网 优势:因为使用母机的IP段,可以直接和该IP段的其他机器进行通信. 缺陷:每一台机器或者每一个虚拟机都会占用该IP段的一个地址,数量多的时候该IP段地址就会不够用.引发IP冲突* NAT模式 CentOS使用一个新的ip段地址,同时为了跟母机通信会给它也配置这个新的ip段的地址.CentOS系统可以通过母机的原IP访问外网 优势:每次都使用的是新的IP段地址,不会有IP冲突. 缺陷:每一台机器或者每一个虚拟机都会产生一个新的IP段,他们之间不能直接通信 主机模式 CentOS产生独立的IP段且跟母机IP不在有联系,所以CentOS不能直接访问外网. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99de1f4329da2e439cbb5e39afb2c55a/" rel="bookmark">
			使用sklearn构建神经网络进行成绩预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# coding=gbk import pandas as pd import numpy as np import matplotlib.pyplot as plt from sklearn.neural_network import MLPRegressor def get_class(T_class, info, num): # 从总的课程（info）里取出指定班级（T_class），将总评的列名改成num info = pd.DataFrame(info)[['StuName', 'StuClass', '总评']] info = info.rename(columns={'总评': num}) data_group = info.groupby(info["StuClass"]) for key, value in data_group: if (key == T_class): info = value info.reindex() return info data1_import = pd.read_csv('output/高等数学(一)-1_output.csv', encoding='GBK') # 读取课程 data2_import = pd.read_csv('output/高等数学(一)-2_output.csv', encoding='GBK') data3_import = pd.read_csv('output/线性代数_output.csv', encoding='GBK') info1 = get_class('18大数据1', data1_import, '高1') info1 = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99de1f4329da2e439cbb5e39afb2c55a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92b2e3eaf6f7d0d00871ec81655700ea/" rel="bookmark">
			【FCC前端教程】28关学会HTML与HTML5基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「经历」 我自学前端已经有6年多了，自问当时学前端是没有系统化学习的。一开始边看文档，连滚带爬学HTML和CSS排版，然后深入研究JavaScript，因为当时最火的就是JQuery，所以用了很长一段时间的JQ。
到了后面遇到有一个项目需要我做APP开发，但是不可能去学IOS开发和安卓开发，因为项目时间也不可能给我们这么充裕的学习时间。所以当时的我深入分析了几个混合APP开发的框架。分析对象包括当时基于AngularJs的Ionic框架和React Native。综合考虑最后选择了Ionic，然后自学了Angular2。（过程也是踩过成千上万的坑学会的）
APP开发的这个过程让我深入感觉到那时候前端的革命性变化。庞大的前端知识扑面而来，也没有想到前端已经发展到这样一个地步。这段时间让我深刻领会到前端的博大精深，并且被前端这个技术领域深深的吸引住了。
到了后面Vue突然开始火了，各大技术公司都开始使用Vue+Cli脚手架搭建前端应用。越来越多的企业要求使用Vue开发前端应用和WebAPP。热爱前端的我从来不畏惧需要学更多的知识，既然Vue来势汹汹，我也开始深入研究和学习Vue开发前端。经过一番折腾Vue也上手了。
至今我依然在不停的学习前端无边无际的知识和技术。
最近我发现，现在学习技术容易了很多。有各种技术文章、手摸手教学、线上培训课程和视频，甚至还有全免费的线上学习课程和练习。相比以前从看文档，连滚带爬的在项目中试错式的学习真的是容易多了。
「前言」 我们都深刻知道，如果想在前端走的更远更久，基础知识必须是要牢固的。最近发现一个免费学习编程的网站 freeCodeCamp(🔥) - 官方版（英文） ｜ 中文社区版 。我好学的性格牵动着我的灵魂，忍不住就去研究了一下。我发现里面的课程确实很全面，而且还有实时和实战编程练习。就算是对于零基础的童鞋，也是可以开始学习编程的。
在一个夜深人静的夜晚，我看着电脑思考人生的时候，我灵机一动，要不我开始写一个系列的文章和大家一起闯关进攻前端全方位知识点。没有闯过这些关卡的童鞋，无论前端能力如何，这个可以锻炼我们自己，也可以深入知道我们自己的前端水平和差距。想学习前端的童鞋可以从零开始学习，一起排除困难共同打开前端大门！
使用这个免费网站学习编程，每一个知识学习完成后会给大家发放一个证书，然后每一个关键学习点之后，还有项目实战。自从2014年，有超过4万个freeCodeCamp毕业的童鞋获得了大企业工作机会。（里面有提到谷歌，苹果，微软，亚马逊，Spotify等公司）
还有看到一些学员的评价：
“我在实习的时候，导师就叮嘱我在 freeCodeCamp 上做题闯关。技术的精进不仅给了我强大的自信，也让我得以进入大厂 ThoughtWorks。” — 姜玉珍“对于还没有形成编程思维的新人，即使是 leetcode 上面 easy 级别的算法题目都感到非常有难度，而 freeCodeCamp 的算法题恰好是一个良好的过渡。” — 魏朝欣 无论这些证书是否对我们在中国的企业有一定的价值。但是能获得多一个证书，没有什么不好的呀。废话不多说了，我们这里就开始勇闯第一课《基础HTML与HTML5入门》！
「规则」如何一起闯关 在开始这个闯关的系列之前，讲一下我们具体怎么一起闯关。
首先，如果我是单纯在这里给大家发布答案，我觉得这些文章就没有太大意义了。所以我希望在闯关的过程中一起学习到更多的知识，弄懂更深层的技术和用我的相关经验讲说这些知识在工作中的使用场景和小技巧。
个人觉得英文版本的操作和体验都更好，加上英文版本的课题会更新。所以我会在英文版中与大家一起闯关。但是喜欢用中文社区版本也是可以的哦。酸甜苦辣各有所爱，但是效果和课题基本都是一样的哈。
每一篇文章的大概内容：
首先我们每一篇文章会尽量包含一个大知识点中的N个关卡。每一个知识点的关卡数量不一，所以有时候可能会拆分成几篇文章来讲说。每一个关卡当中的知识点在freeCodeCamp中有一定的知识材料。但是在一起闯关的文章当中也会做一些详细的知识补充和一些有趣的理解方式。每一个较难的关卡，都会在文章当中做详细的思路，多种实现方式等等的讲说，让我们在每一个关卡中能带走更多深层的知识点。 freeCodeCamp使用教程 课程内容 FCC一共有6大课程，一共大约1800个小时的内容和练习。如果是新人，推荐从第一个开始一个一个闯关学习。如果是老司机，是来这里学习你需要的知识，那可以随意选择你需要的课程开始学习。
响应式Web设计（300个小时）算法和数据结构（300个小时）前端库和框架（300个小时）数据可视化（300个小时）API和微服务（300个小时）信息安全和质量保证（300个小时） 最后还有一个是数千个小时的面试题可以提供给我们使劲的刷哦！
进入关卡 首先我们展开第一课看一下：
第1点这里是基础知识的文章，可以点击查看。看完基础知识之后可以点击下方的回到第一小节开始闯关！第2点这里下面所有的都是练习题，一个一个顺着闯关即可。 关卡教程 ⚠️注意：
大家闯关之前，推荐大家都先使用GitHub登陆，到时候颁发的证书和闯关进度才能得到保存和跟踪哦！！！
我们先从左边 👈 部分的内容开始说明：
简单讲说了这个关卡涉及的知识点描述关卡的挑战内容本关卡的所有目标，点击测试代码的时候，完成的会出现 ✅，没有全部 ✅那就是还有部分我们没有实现哦。所有 ✅才能通关。 接下来就是说明中间的代码区：
代码区，用于编写我们这个关卡的代码。错误输出区域，当我们点击测试代码后，如果有错误就会显示在这里。 最后，最右边的部分是代码被编译后的效果，也就是我们在代码去编写的代码最终会在浏览器呈现出来的效果哦。（这里的效果会在我们编写代码的同时触发变化哦！）
提交代码/测试成功后：
「知识」闯关基础知识点 HTML是什么？
HTML 的全称是 HyperText Markup Language（超文本标签语言），它是一种用来描述网页结构的标签语言。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92b2e3eaf6f7d0d00871ec81655700ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6ce09bb6cf93d362abadd8bf023e893/" rel="bookmark">
			让qt应用程序支持触摸
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址::https://blog.csdn.net/orz415678659/article/details/9136575
一.设备驱动
我的触摸屏是usb接口的
可以参考下这2篇文件
http://blog.csdn.net/paomadi/article/details/8754783 usb触摸屏
http://blog.csdn.net/paomadi/article/details/8309861 输入子系统
不是usb接口的或者自己想写多一个也可以(需要我的源码的请留邮箱说下,我贴一部分)
usb子系统部分关键在于urb的数据传递
input子系统部分关键在于事件的设置及上报
#define M //多点触摸点数
在初始化init或者probe方法中
input_dev=input_allocate_device()；//分配初始化输入设备
//(最好构建一个对象结构体,包含input设备和usb设备,或其他设备,将各个子系统的设备捆绑到一个对象中去)
set_bit(EV_KEY, input_dev-&gt;evbit); //设置事件类型标志位
set_bit(EV_ABS, input_dev-&gt;evbit);
set_bit(BTN_TOUCH, input_dev-&gt;keybit); //设置按键类型标志
#if M
//多点的这么设置参数(我的屏只支持单点,so没亲测)
input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,1920, 0, 0);
input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,1080, 0, 0);
input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
#else
//单点的参数设置
input_set_abs_params(input_dev, ABS_X, 0, 0x7FFF, 0, 0); //设置参数
input_set_abs_params(input_dev, ABS_Y, 0, 0x7FFF, 0, 0);
input_set_abs_params(input_dev, ABS_PRESSURE, 0, 1, 0, 0);
#endif
在接收到数据之后上报事件给input子系统
#if M
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6ce09bb6cf93d362abadd8bf023e893/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd326446a404dd506cb86b8b09d927e5/" rel="bookmark">
			计算机网络课程笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习MOOC华南理工计算机网络课程笔记
第1章 概述
1.1 为什么要学习计算机网络
1.2 互联网发展史
1.3 常用的基本概念
1.4 参考模型
1.5 参考模型相关概念
1.6 本课程的组织
第2章 物理层
2.1 物理层概述
2.2 有导向的传输介质
2.3 复用技术
2.4 调制技术
2.5 公共交换电话网络 PSTN
2.6 物理层设备
第3章 数据链路层
3.1 数据链路层概述
3.2 差错处理概述
3.3 纠1位错的海明码
3.4 检错码
3.5 基本数据链路协议1~3
3.6 滑动窗口协议
3.7 回退n帧
3.8 选择性重传
第4章 介质访问控制子层
4.1 MAC子层概述
4.2 ALOHA协议
4.3 CSMA协议
4.4 以太网概述
4.5 以太网帧格式
4.6 二层交换的基本原理
4.7 生成树协议
4.8 虚拟局域网
4.9 二层设备
第5章 网络层
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd326446a404dd506cb86b8b09d927e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14c2df433750c74399f76b42bf9d7291/" rel="bookmark">
			rocketmq详解(全)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学前小故事
搭建环境
管理工具
rocketmq基础
rocketmq之Java Class
学前小故事
有一天，产品跑来说：“我们要做一个用户注册功能，需要在用户注册成功后给用户发一封成功邮件。”
小明（攻城狮）：“好，需求很明确了。” 不就提供一个注册接口，保存用户信息，同时发起邮件调用，待邮件发送成功后，返回用户操作成功。没一会功夫，代码就写完了。验证功能没问题后，就发布上线了。
线上正常运行了一段时间，产品匆匆地跑来说：“你做的功能不行啊，运营反馈注册操作响应太慢，已经有好多用户流失了。”
小明听得一身冷汗，赶紧回去改。他发现，原先的以单线程同步阻塞的方式进行邮件发送，确实存在问题。这次，他利用了 JAVA 多线程的特性，另起线程进行邮件发送，主线程直接返回保存结果。测试通过后，赶紧发布上线。小明心想，这下总没问题了吧。
没过多久，产品又跑来了，他说：“现在，注册操作响应是快多了。但是又有新的问题了，有用户反应，邮件收不到。能否在发送邮件时，保存一下发送的结果，对于发送失败的，进行补发。”
小明一听，哎，又得熬夜加班了。产品看他一脸苦逼的样子，忙说：“邮件服务这块，别的团队都已经做好了，你不用再自己搞了，直接用他们的服务。”
小明赶紧去和邮件团队沟通，谁知他们的服务根本就不对外开放。这下小明可开始犯愁了，明知道有这么一个服务，可是偏偏又调用不了。
邮件团队的人说，“看你愁的，我给你提供了一个类似邮局信箱的东西，你往这信箱里写上你要发送的消息，以及我们约定的地址。之后你就不用再操心了，我们自然能从约定的地址中取得消息，进行邮件的相应操作。”
后来，小明才知道，这就是外界广为流传的消息队列。你不用知道具体的服务在哪，如何调用。你要做的只是将该发送的消息，向你们约定好的地址进行发送，你的任务就完成了。对应的服务自然能监听到你发送的消息，进行后续的操作。这就是消息队列最大的特点，将同步操作转为异步处理，将多服务共同操作转为职责单一的单服务操作，做到了服务间的解耦。
哈哈，这下能高枕无忧了。太年轻，哪有万无一失的技术啊~
不久的一天，你会发现所有业务都替换了邮件发送的方式，统一使用了消息队列来进行发送。这下仅仅一个邮件服务模块，难以承受业务方源源不断的消息，大量的消息堆积在了队列中。这就需要更多的消费者（邮件服务）来共同处理队列中的消息，即所谓的分布式消息处理。
rocketmq入门
消息队列
含义 消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。实现高性能， 高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。 目前在生产环境，使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。 应用场景 (同下方rocketmq应用场景) 示例图 a. 电商系统 （1）应用将主干逻辑处理完成后，写入消息队列。消息发送是否成功可以开启消息的确认模式。（消息队列返回消息接收成功状态后，应用再返回，这样保障消息的完整性） （2）扩展流程（发短信，配送处理）订阅队列消息。采用推或拉的方式获取消息并处理。 （3）消息将应用解耦的同时，带来了数据一致性问题，可以采用最终一致性方式解决。比如主数据写入数据库，扩展应用根据消息队列，并结合数据库方式实现基于消息队列的后续处理。 b. 日志收集系统 (消息将应用解耦的同时，带来了数据一致性问题，可以采用最终一致性方式解决。比如主数据写入数据库，扩展应用根据消息队列，并结合数据库方式实现基于消息队列的后续处理。) 1.Zookeeper注册中心，提出负载均衡和地址查找服务； 2.日志收集客户端，用于采集应用系统的日志，并将数据推送到kafka队列； 3.Kafka集群：接收，路由，存储，转发等消息处理； rocketmq示例图
分析 a.消息队列是一种"先进先出"的数据结构 b.不使用队列的情况下,生产者与消费者之间是通过RPC交互的 rocketmq应用场景
应用解耦
问题描述 系统的耦合性越高，容错性就越低，以电商应用为例，用户创建订单后， 如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障 或者因为升级等原因暂时不可用，都会造成下单操作异常 解耦含义 使用消息队列解耦，系统的耦合性就会下降了，比如物流系统发生故障， 需要几分钟才能修复，在这段时间内，物流系统要处理的数据被缓存到消 息队列中，用户的下单操作正常完成。当物流系统恢复后，补充处理存在 消息队列中的订单消息即可，终端系统感知不到物流系统发生过几分钟故 障 场景 用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口 那么会存在以下缺点 1.假如库存系统无法访问，则订单减库存将失败，从而导致订单失败 2.订单系统与库存系统耦合 解决方案 订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户下单成功 库存系统：订单下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行 库存操作 假如：在下单时库存系统不能正常使用，也不影响正常下单，因为下单后，订单系统写入消息 队列就不再关心其他的后续操作了。实现了订单系统与库存系统的应用解耦 流量削峰
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14c2df433750c74399f76b42bf9d7291/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0315d53880de9f44b6866622d7a9c5db/" rel="bookmark">
			前端开发之浏览器F12代码调试教程（谷歌浏览器为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 调出开发者工具 按键盘F12空白地方鼠标右键选择检查快捷键Ctrl+Shift+i 开发者工具中常用内容介绍（前4） Element：主要用来调试HTML和CSS代码 查看元素的代码：点击左上角的箭头图标（或按快捷键Ctrl+Shift+C）进入选择元素模式，然后从页面中选择需要查看的元素，然后可以在开发者工具元素（Elements）一栏中定位到该元素源代码的具体位置 查看元素的属性：定位到元素的源代码之后，可以从源代码中读出改元素的属性。如下图中的class、src、width等属性的值。
当然从源代码中读到的只是一部分显式声明的属性，要查看该元素的所有属性，可以在右边的侧栏中查看： 修改元素的代码与属性：点击元素，然查看右键菜单，可以看到chrome提供的可对元素进行的操作：包括编辑元素代码（Edit as HTML）、修改属性（Add attribute、Edit attribute）等。选择Edit as HTML选项时，元素进入编辑模式，可以对元素的代码进行任意的修改。当然，这个修改也仅对当前的页面渲染生效，不会修改服务器的源代码，故而这个功能也是作为调试页面效果而使用。 查看元素的CSS属性：在元素的右边栏中的styles页面可以查看该元素的CSS属性，这个页面展示该元素原始定义的CSS属性以及从父级元素继承的CSS属性。从这个页面还可以查到该元素的某个CSS特性来自于那个CSS文件，使编码调试时修改代码变得非常方便。 在Styles页旁边，有一个Computed页面，这个页面展示该元素经过计算之后的所有CSS属性，即最后浏览器渲染页面时使用的属性。属性的计算由浏览器自动进行，是浏览器渲染页面的一个必不可少的过程。 修改元素的CSS属性：在元素的Styles页面，可以对元素的CSS属性进行修改，甚至删除原有、添加新属性。不过，这些修改，仅对当前浏览器的页面展示生效，不会修改CSS源代码。所以在这里进行CSS属性的修改一般用来调整和完善元素的渲染效果。 给元素添加断点：在元素的右键菜单中选择断点选项（Break on…），选中之后，当元素被修改（通常是被JS代码修改）时，页面加载会暂停，然后可以查看该元素的属性。 元素断点添加之后，可以在右侧栏的DOM Breakpoints页面中看到，这个页面可以看到当前网页的所有元素断点。 查看元素的监听事件：元素的右边栏的Event Listener页面，可以查看到该元素的所有监听事件。在开发中，尤其是维护其他人的代码时，会出现不了解元素对应的监听事件，这个时候，可以在这个页面中找到。这个页面不仅能看到对应的事件函数，还可以定位该函数所在的JS文件以及在该文件中的具体位置（行数），大大提高开发维护的效率。Console：查看代码错误信息，打印代码，调试代码以及查看js中的API 查看JS对象的及其属性： 执行JS语句： 查看控制台日志：当网页的JS代码中使用了console.log()函数时，该函数输出的日志信息会在控制台中显示。日志信息一般在开发调试时启用，而当正式上线后，一般会将该函数去掉
sources：查看资源等文件，调试代码 查看文件：在源代码（Source）页面可以查看到当前网页的所有源文件。在左侧栏中可以看到源文件以树结构进行展示。 添加断点：在源代码左边有行号，点击对应行的行号，就好给改行添加上一个断点（再次点击可删除断点）。右键点击断点，在弹出的菜单中选择Edit breakpoint可以给该断的添加中断条件。 中断调试：添加断点后，当JS代码运行到断点时会中断（对于添加了中断条件的断点在符合条件时中断），此时可以将光标放在变量上查看变量的 也可以在右边的侧栏上查看： 在右侧变量上方，有继续运行、单步跳过等按钮，可以在当前断点后，逐行运行代码，或者直接让其继续运行。network：查看网页的HTTP通信，资源是否加载成功等 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a302f8a1e99032b36efa7f1d7e66dd3/" rel="bookmark">
			Ubuntu16.04 出现“GLIBC_2.27”not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		试过安装GLIBC_2.27,解决了一些安装失败问题，最后../configure --profix=/opt/glibc-2.27 sudo make
sudo make install成功了。
但是执行strings /lib/x86_64-linux-gnu/libc.so.6 | grep GLIBC_
还是没有显示GLIBC_2.27
承认确实Ubuntu16.04不支持GLIBC_2.27版本
决定重装系统了，在TX2上装Ubuntu18.04.。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c921bf3926fcd2f33a28f2076f3d3d81/" rel="bookmark">
			C&#43;&#43;运算符重载（一元运算符，二元运算符，流运算符）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们一直在使用重载的运算符，这些运算符重载在c++语言本身中。例如，c++重载了加运算符（+）和减运算符（-）。这些运算符在整型运算、浮点型运算、指针运算等上下文中，执行的操作是不同的。
大多数c++运算符都可被重载，因此我们只需记住四个不能重载的运算符：“ . ” ， “ .* ” ，“ :: ”， “ ?: ”。
当创建自己的运算符时，应该遵守一定的规则和限制：
一：不能通过重载改变运算符的优先级。如果运算符是左结合，则在重载时也应如此。
二：重载不能改变运算符的结合性。即运算符是按照从右至左还是从左 至右的顺序计算。
三：重载不能改变运算符的元数。即运算符操作个数。
四：不能通过运算符重载改变运算符应用于基本类型对象时的含义。即“-”只能用于两个同类型的数相减或作为负号。
五：相关运算符，例如+和+=，必须分别重载。
六：当重载（），[ ]，-&gt;或赋值运算符，运算符重载函数必须重载为类的成员。
下面以Clac类演示运算符重载（成员函数和友元函数分别实现），该类有两个private数据成员x和y。
一：一元运算符重载。
以++为例，分为++前置和后置，以参数列表是否有int区分。
（1）作为成员函数。
class Clac { public: Clac(); Clac(int, int); Clac operator ++(int);//++后置 Clac operator ++();//++前置 private: int x, y; }; Clac Clac::operator++(int) { Clac temp(*this); x++; y++; return temp; } Clac Clac::operator++() { x++; y++; return *this; } （2）作为友元函数
class Clac { public: Clac(); Clac(int, int); friend Clac operator ++(Clac&amp;, int);//++后置 friend Clac operator ++(Clac&amp;);//++前置 private: int x, y; }; Clac operator ++(Clac&amp; c, int) { c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c921bf3926fcd2f33a28f2076f3d3d81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae25265620ba78a9a5767b676fc4dd81/" rel="bookmark">
			Gradle Core Plugins (plugin is not in &#39;org.gradle&#39; namespace)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一个由 gradle 构建项目遇到的问题：
起因：项目原先运行正常，不过个人 移除掉默认仓库 .gradle 仓库后，重新拉取报错如下：
FAILURE: Build failed with an exception. * Where: Build file 'F:\ideaSpace\insuranceService\build.gradle' line: 13 * What went wrong: Plugin [id: 'org.springframework.boot', version: '2.2.4.RELEASE'] was not found in any of the following sources: - Gradle Core Plugins (plugin is not in 'org.gradle' namespace) - Plugin Repositories (could not resolve plugin artifact 'org.springframework.boot:org.springframework.boot.gradle.plugin:2.2.4.RELEASE') Searched in the following repositories: Gradle Central Plugin Repository * Try: Run with --stacktrace option to get the stack trace.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae25265620ba78a9a5767b676fc4dd81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1b3daba5e4f244bc91d774a61320d70/" rel="bookmark">
			Java IO教程 OutputStream InputStream 读写字节流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先了解IO流的4个顶级的父类 学到了最顶层的父类它的子类的方法通用。非常的方便。 1. 表格总结. 输入流输出流字节流InputStreamOutputStream字符流ReaderWriter 二、先学习OutputStream类 写流（数据：内存–&gt;硬盘） 写入数据的原理：Java程序IO流 – JVM – OS(Operate System) – OS调方法–写入成功.
拓展：字符，字节，01进制的关系?（一切文件皆为字节） 字节是一个单位： 1 字节 Byte = 8个01进制字符是字母或者符号: 比如： a,b c …1、2、3、A、B、C、~！·#￥% 1.学习一个类，先学习它的构造方法。看文档。 1.总结构造方法
带boolean , 为true 就是写入文件的开头，false反之
参数是String就是，路径，参数是File就是File对象，回顾我之前总结的File类的用法 2.再看Attribute参数，无 3.再看常用方法 4. 步骤 一、步骤1.创建FileOutputStream对象，抽象类，(可以用多态）2.写入数据 fileOutputStream.write(): 3 种方法。 1.abstract void write(int b) 将指定的字节写入此输出流 2.void write(byte[] b) 将 b.length字节从指定的字节数组写入此输出流。 3.void write(byte[] b, int off, int len) 从指定的字节数组写入 len个字节，从偏移 off开始输出到此输出流。 3.刷新缓存：fileOutputStream.flush();4.关闭流，节省内存： fileOutputStream.close() ;finally{}中使用更棒 5.代码 package Java学习.Java高级.IO.IO.OutputStream字节输出流; import java.io.FileNotFoundException; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1b3daba5e4f244bc91d774a61320d70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fc5cb1c1130ce77fbe622f14db716ae/" rel="bookmark">
			Redis的跳跃表底层原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。
在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。
Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。
二、跳跃表的实现 Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。
如图展示了一个跳跃表示例，位于图片最左边的是zskiplist结构，该结构包含以下属性：
header：指向跳跃表的表头节点。tail：指向跳跃表的表尾节点。level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。 位于zskiplist结构右方的是四个zskiplistNode结构，该结构包含以下属性：
层（level）：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。后退（backward）指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。分值（score）：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。成员对象（obj）：各个节点中的o1、o2和o3是节点所保存的成员对象。 注意表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性都不会被用到，所以图中省略了这些部分，只显示了表头节点的各个层。
三、跳跃表节点 跳跃表节点的实现由redis.h/zskiplistNode结构定义：
typedef struct zskiplistNode { // 层 struct zskiplistLevel { // 前进指针 struct zskiplistNode *forward; // 跨度 unsigned int span; } level[]; // 后退指针 struct zskiplistNode *backward; // 分值 double score; // 成员对象 robj *obj; } zskiplistNode; 1.层 跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。
每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law，越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。
下图分别展示了三个高度为1层、3层和5层的节点，因为C语言的数组索引总是从0开始的，所以节点的第一层是level[0]，而第二层是level[1]，以此类推。
2.前进指针 每个层都有一个指向表尾方向的前进指针（level[i].forward属性），用于从表头向表尾方向访问节点。下图用虚线表示出了程序从表头向表尾方向，遍历跳跃表中所有节点的路径：
迭代程序首先访问跳跃表的第一个节点（表头），然后从第四层的前进指针移动到表中的第二个节点。在第二个节点时，程序沿着第二层的前进指针移动到表中的第三个节点。在第三个节点时，程序同样沿着第二层的前进指针移动到表中的第四个节点。当程序再次沿着第四个节点的前进指针移动时，它碰到一个NULL，程序知道这时已经到达了跳跃表的表尾，于是结束这次遍历。 3.跨度 层的跨度（level[i].span属性）用于记录两个节点之间的距离：
两个节点之间的跨度越大，它们相距得就越远。指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。 初看上去，很容易以为跨度和遍历操作有关，但实际上并不是这样，遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。
举个例子，如下图用虚线标记了在跳跃表中查找分值为2.0、成员对象为o2的节点时，沿途经历的层：在查找节点的过程中，程序经过了两个跨度为1的节点，因此可以计算出，目标节点在跳跃表中的排位为2。
4.后退指针 节点的后退指针（backward属性）用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节
点。
如下图用虚线展示了如果从表尾向表头遍历跳跃表中的所有节点：程序首先通过跳跃表的tail指针访问表尾节点，然后通过后退指针访问倒数第二个节点，之后再沿着后退指针访问倒数第三个节点，再之后遇到指向NULL的后退指针，于是访问结束。
5.分值和成员 节点的分值（score属性）是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。
节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fc5cb1c1130ce77fbe622f14db716ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9979ea320ba4cad13f0d4f7d51f7c73/" rel="bookmark">
			简单并全面地了解目标检测之fast RCNN(ROI Pooling、ROI Align和Precise ROI Pooling)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标检测之fast RCNN[2015 Ross]
ROI： region of interest(类似region proposal)
B0.Region Proposal:和RCNN一样
2k每张图ROI，为每个ROI记录下坐标 B1 &amp; 2.卷积Convolution &amp; 投影Projection
对一张图只做一次卷积，每个ROI记录下的坐标投射到特征图上比如使用backbone网络结构为VGG，4 max pooling, 即坐标 /16得到2k个feature map zone特征图区域块 B3.ROI pooling layer
参考了SSP(Spatial pyramid pooling) Net 空间金字塔池化，把不同尺寸的图片resize到相同尺寸，并且保留他的空间位置信息处理方式类似于resize，把不同大小特征图变成同样大小特征图原理 每个特征图中大小不一样的ROI做一个网格划分，网格划分(grid)固定大小,并且在每个grid上面做一个max pooling所以不同大小的特征图(feature map)可以转换到相同大小的特征图RoI为7×5，输出为2×2尺寸的ROI Pooling举例
训练细节 batchsize = 2;64RoIs/image -&gt; 128 proposals(从2k个region proposal中按一定方式选出来(比如按大于指定阈值…));1/4 pos(正样本) &amp; 3/4 neg(负样本)IOU&gt;0.5 pos, [0.1, 0.5] neg, [0,0.1]hard neg训练时正负样本按1:3比例，测试用负难样本，如果有错误情况，用负难样本重新训练 问题 cnn中和ROI pooling中加起来pooling(取整)较多，损失像素点较多，当ROI较小时，相对损失的特征就更多了，fast rcnn对小目标检测不太友好 B4 FC layers
FC层中参数较多，可考虑SVD加速(一般不会,矩阵乘法加速效果更好)
B5 Multi-task Loss多任务损失函数
分类：n+1(需考虑背景), softmax + cross entropy, L(cls)定位：offset(用偏置项做预测), smoothL1, L(loc) 注意: Smoooth L2会使得小的更小，大的更大 损失函数为分类损失函数与定位损失函数总和
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9979ea320ba4cad13f0d4f7d51f7c73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5db849380df71fb85a905592855e24b5/" rel="bookmark">
			Github 上传和删除文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Github 上传和删除文件夹1. 上传文件夹2. 删除文件夹3. 附录a. git push -u origin masterb. Git Cheat Sheet Github 上传和删除文件夹 1. 上传文件夹 右键本地空的文件夹 &gt;&gt; 选择 Git Bash Here 打开命令窗口（$ git --help 帮助命令）$ git clone + 仓库地址（Clone with HTTPS）复制要上传的项目到 Repository 文件夹下$ cd + Repository 的名字，或右键 Repository 的文件夹 &gt;&gt; 选择 Git Bash Here 打开命令窗口 $ git --help 帮助命令 $ git init$ git add .$ git commit -m [massage] massage：XX提交的信息（on branch master）$ git push，首次需要登录，登录成功后即上传成功$ cd .. 返回 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5db849380df71fb85a905592855e24b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16f42315464deb8d0fc2cd65fd10aac1/" rel="bookmark">
			一文看懂目标检测之RCNN（NMS和Soft-NMS算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标检测之RCNN 1. RCNN:Regions with CNN features[2014 Ross] 图片输入区域建议(region proposal)特征提取(feature extraction)分类+2次定位(classification(SVM) + detection(线性模型Linear 正则化项)) 2. 区域建议 算法：selective search前景分割，将纹理、形状、颜色相似的合在一起，目前比较少人用，数学公式复杂，难用，效果还不太好，不建议看大概2K多个候选框，包括很多感兴趣尽可能囊括到候选框，粗筛2k个候选框的图片，每个做resize到固定大小，固定大小里有无物体，进入分类网络判断 3. 特征提取 a.在数据集ILSVRC2012 dataset上预训练好的分类网络(AlexNet)直接拿来用，将大约2k个图片一个个送到分类网络（backbone），只拿了特征提取层，扔掉了最后的1*1000的分类层。b.在真实数据集上finetune微调，主要更新后两层全连接dense层c.训练样本正样本和负样本比例为1:3c.IOU小于0.5,给定比较宽松的限制条件，对应较为复杂的网络，样本才不会显得过于少提取CNN特征前必须resize到统一大小,因为后面有FC层，参数是固定的问题：resize后改变了图片本身信息——长方形的旗杆resize压缩成成正方形后，他还是旗杆吗？这个仍然需要改善 4. SVM分类器分类 + NMS算法筛选 + 边界框回归(BBox Regression) 4.1. SVM分类(少样本模型) 给每个样本做分类正样本：Groud True负样本：IOU &lt; 0.3[others ignored]Q：和AlexNet网络训练相比，svm分类时IOU的阈值threshould为什么不一样？A：训练CNN需要更多数据样本，更多数据样本不一定质量高，svm分类时需要质量高数据样本Q：为什么用SVM,为什么不直接用AlexNet最后的softmax？A：AlexNet专注于分类, 不好用少数样本来做定位。数据多，质量差；数据少，质量高，数据少时用SVM相对好一些 4.2. NMS(Non-Maximum Suppression)非极大值抑制算法(很重要) NMS广泛应用于目标检测算法中。其目的是为了消除多余的候选框，找到最佳的物体检测位置。
每个类别置信程度score越高，越能说明物体在框里面取score值最高的一个框，将其他的框和他的iou越大，越可能是同一个物体，所以去掉其他和该框iou高于某一阀值候选框代码实现 import numpy as np def NMS(lists, thre): if len(lists) == 0: return {} lists = np.array(lists) res = [] #取得第i列，第0列为x1,第1列为y1... x1, y1, x2, y2, score = [lists[:, i] for i in range(5)] area = (x2 - x1 + 1) * (y2 - y1 + 1) # get sorted index in ascending order idxs = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16f42315464deb8d0fc2cd65fd10aac1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c37597e40df53e400ad5c2fe8f74b29/" rel="bookmark">
			unigui百度地图交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be78c2d896f48867f1e0d8624a1931b6/" rel="bookmark">
			验证集精度高于训练集精度的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 训练集的数据做了一系列的增广，如旋转，仿射，模糊，添加噪点等操作；过多的增广使得训练集分布产生了变化。模型正则化过多，比如训练时dropout过多，和验证时的模型相差较大，验证时是不会有dropout的。训练的精度是每个batch产生的，而验证的精度一般是一个epoch后产生的，验证时的模型是训练一个个batch之后的，有一个的滞后性；可以说训练得差不多的模型用来验证，当然精度要高一点。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc7ff059364b404575486c9b01abc5b0/" rel="bookmark">
			如何提高分类的区分性能——细粒度图像分类(Fine-Grained Classification)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 如何让网络关注细小细节
举个栗子 通过树叶判断植物类别，花朵判断花的品种，以及人脸识别等任务
1. CenterLoss 1.1 传统分类学习存在的问题： 类内距离可能超过类间距离，对一些模棱两可的样本不好区分
1.2 Center Loss方案 让特征向量有更好的区分性能，有点像做一个内部聚类，把特征向量约束到一起，让不同类别距离(类间距离)尽量大，相同类别(类内距离)尽量小, CenterLoss作用后的区分特征再做分类，能够更好的鉴别出模棱两可的图片 1.3 实现原理/公式解析 计算类与该类别中心的Loss，再做一个L2正则，即向量的平方，如下图所示。中心点坐标为该类别所有相加的和处于类别个数，即均值。 算法
{xi}为训练集. θC为卷积层里的参数.权重参数W和{cj|j=1,2, …, n}为损失层里的参数。
超参数λ为聚类程度的参数指标,α指的是控制每次中心点更新的波动情况(α=1:完全不考虑波动;α&lt;1:进行圆滑处理)，μt为学习率.
对于第6步，注意的是，中心点的向量不是一直固定不变的，每个batchsize训练后，中心点是会改变的。Δcj更新方式如下
δ(condition) = 1; condition为True δ(condition) = 0; condition为False 结果
λ越大，越靠近中心点，聚类能力越强，特征越可区分性；λ越小，越远离中心点，分类能力越强
在MNIST数据集上表现良好，但在CIFAR数据集上表现不佳 2. 其他Loss Triplet Loss/ Contrastive Loss 3. 注意力机制(Attention Mechanism) 最后 原文链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c899e32da8b04bad6d17f7d306987f5/" rel="bookmark">
			配置可通过HTTP访问的fastDFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是 FastDFS 四个方面的功能： 文件存储文件同步文件上传文件下载 系统架构图 从上面这张图中我们可以看到，FastDFS 架构包括 Tracker 和 Storage 两部分，看名字大概就能知道，Tracker用来追踪文件，相当于是文件的一个索引，而 Storage 则用来保存文件。
我们上传文件的文件最终保存在 Storage 上，文件的元数据信息保存在 Tracker 上，通过 Tracker 可以实现对 Storage 的负载均衡。
Storage 一般会搭建成集群，一个 Storage Cluster 可以由多个组构成，不同的组之间不进行通信，一个组又相当于一个小的集群，组由多个 Storage Server 组成，组内的 Storage Server 会通过连接进行文件同步来保证高可用。
2.FastDFS 安装 Tracker 安装Storage 安装Nginx 安装 2.1Tracker 安装 一个环境
先来看一个环境，由于 FastDFS 采用 C语言开发，所以在安装之前，如果没有 gcc 环境，需要先安装，安装命令如下：
yum install gcc-c++ 两个库
再来看两个库，由于 FastDFS 依赖 libevent 库，安装命令如下：
yum -y install libevent 另一个库是 libfastcommon，这是 FastDFS 官方提供的，它包含了 FastDFS 运行所需要的一些基础库。
libfastcommon 下载地址：https://github.com/happyfish100/libfastcommon/archive/V1.0.43.tar.gz下载成功后，将下载文件拷贝到 /usr/local 目录下，然后依次执行如下命令安装： cd /usr/local tar -zxvf V6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c899e32da8b04bad6d17f7d306987f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1f44c05f891d2dbd32081627d83686f/" rel="bookmark">
			【详解】JUC之Condition
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引出初步使用问题解答第一个问题第二个问题第三个问题 wait和await的区别等待队列总结 利用Condition实现生产者和消费者与 ReentrantLock的关系总结 引出 在使用Lock之前，我们使用的最多的同步方式应该是synchronized关键字来实现同步方式了。配合Object的wait()、notify()系列方法可以实现等待/通知模式。
Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式，但是这两者在使用方式以及功能特性上还是有差别的。
初步使用 利用Condition实现一个简单的生产者和消费者
public class ConditionTest { private final static Lock lock = new ReentrantLock(true); private final static Condition condition = lock.newCondition(); private static int data = 0; private static volatile boolean noUse = true; public static void main(String[] args) throws InterruptedException { new Thread(()-&gt;{ while (true){ buildData(); } }).start(); new Thread(()-&gt;{ while (true){ useData(); } }).start(); } /** * 生产数据 */ private static void buildData(){ try { lock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1f44c05f891d2dbd32081627d83686f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b84159891ff241bc5f6c3273d286a16/" rel="bookmark">
			小程序之 input框设置placeholder的style
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;input placeholder='{{capitaltext}}' placeholder-style='color:rgb(207,207,207);font-size:26rpx;' type='number' maxlength='4'&gt;&lt;/input&gt;
第二种办法（已测试）
wxml:
&lt;view class="section"&gt; &lt;input type='number' placeholder="电话" bindblur="phone" style='background-image: url({{background2}});' /&gt; &lt;/view&gt; wxss:
.input-placeholder{ font-size: 16px; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9381583ac2a5b352688597d7d83b78eb/" rel="bookmark">
			FTP工具FileZilla Client出现中文乱码问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一场疫情，搞得好久没有使用公司电脑，今天连接使用新的FTP服务器连接下载文件，FTP成功连接服务器后，出现了乱码问题，一时有点抓瞎，如下图：
使用FileZilla client FTP客户端登录某些FTP站点出现中文乱码，原因是FTP服务端编码与FileZilla client端编码不一致造成的，解决办法如下：
1、打开FileZilla软件进入到主窗口，连接FTP服务器；
2、FTP连接后，点击“文件”，选择“添加当前连接到站点管理器”；
3、在弹出的“站点管理器”窗口中，在左侧选择“新站点”，右侧切换到“字符集”选项卡后，勾选“使用自定义的字符集”并将编码设置为“gb2312”即可。
如果使用了gb2312还是显示乱码，就在字符集中选择“强制UTF-8”：
这样就可以解决乱码问题了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/140bbc6db64b1ea9f514d0897ef57d60/" rel="bookmark">
			QT5 中使用全局快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 全局快捷键： 就是窗口没有处于最前端时，也响应快捷键。
QT5中处理全局快捷键的库： MyGlobalShortCut 。
下载地址： https://download.csdn.net/download/u012278016/12396381
使用方法： 库中包含4个文件，拷贝到项目目录中，即可使用。
代码： onSaveColor() onCancelPickColor() 为自己创建的函数，当用户按下 Ctrl+c 将响应 onSaveColor函数，按下 Esc 将响应 onCancelPickColor函数
//引入头文件 #include &lt;MyGlobalShortCut/MyGlobalShortCut.h&gt; .... //全局快捷键 //取色 MyGlobalShortCut *shortcut = new MyGlobalShortCut("Ctrl+c", this); connect(shortcut, SIGNAL(activated()), this, SLOT(onSaveColor())); //取消取色 MyGlobalShortCut *shortcut1 = new MyGlobalShortCut("Esc", this); connect(shortcut1, SIGNAL(activated()), this, SLOT(onCancelPickColor())); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/934f533a1805a6e2df7941e4105bba77/" rel="bookmark">
			【GDAL】解决获取S57图层数异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 环境 系统：win10 x64
GDAL版本 ：2.2.4
问题 使用GDAL读写S57文件，GDAL初始化时需要初始化环境变量。 如果未初始化，获取S57图层数异常。
解决方法 方法一
初始化GDAL时，需要设置环境变量。
CPLSetConfigOption("GDAL_DATA", "C:\\warmerda\\bld\\data"); GDAL正常初始化代码如下。
GDALDataset	*pGdalDataset; GDALAllRegister(); CPLSetConfigOption("GDAL_DATA", "C:\\warmerda\\bld\\data"); //环境变量设置，必须调用 pGdalDataset = (GDALDataset *)GDALOpenEx(strFileName.c_str(), GDAL_OF_READONLY, NULL, NULL, NULL); if (pGdalDataset == NULL) { cout &lt;&lt; "Open failed!" &lt;&lt; endl; exit(1); } else { cout &lt;&lt; "Open successfully!" &lt;&lt; endl; } 方法二
点击 我的电脑右键属性 弹出对话框中选择 高级系统设置\高级\环境变量\系统变量 增加 GDAL_DATA，值为 C:\\warmerda\\bld\\data 。
跟踪调试，S57图层正常为28，异常为5。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96b189375b1916e399e5cbb4cda7f294/" rel="bookmark">
			展讯平台lcd频率计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展讯平台点屏时要配置两个时钟(phy_freq和pixel_clk),那这两个参数要怎么配置呢，我们可以找到展讯的这份文档，输入屏的参数,即可计算出相应的时钟。如
然后将相应的参数填到屏的配置文件中，如
Android9.0以前,
uboot配置
.phy_freq = 1105000 .pixel_clk = 153600000 kernel配置
pixel_clk:由uboot传参到cmdline(在uboot) clock-frequency = &lt;1105000&gt;;对应uboot的phy_freq Android10.0
uboot配置
.phy_freq = 1105000 .pixel_clk = 153600000 kernel配置
sprd,phy-bit-clock = &lt;1105000&gt;;//phy-freq clock-frequency = &lt;153600000&gt;;//pixel_clk 当然，这不是重点，之前一直不了解其中的运算规则，excel隐藏了其中的运算规则，今天看代码有了一些了解，分享下
pixel_clk计算
从下面的程序中可以窥见一二，如果配置是时钟源是dpi_clk_src中一个，直接使用，然后根据ROUND(a, b)计算分配分配系数
static const u32 dpi_clk_src[] = { 96000000, 128000000, 153600000, 192000000 }; static u32 calc_dpi_clk_src(u32 pclk) { int i; for (i = 0; i &lt; ARRAY_SIZE(dpi_clk_src); i++) { if ((dpi_clk_src[i] % pclk) == 0) return dpi_clk_src[i]; } pr_err("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96b189375b1916e399e5cbb4cda7f294/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7fb13afad93b65d1994ebce62b6adf9/" rel="bookmark">
			【控制理论】【Matlab】利用System identification App辨识对象模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要了解更深入，去Matlab官网
System Identifacation App介绍
https://ww2.mathworks.cn/help/ident/gs/identify-linear-models-using-the-gui.html
另一个辨识的案例：
https://ww2.mathworks.cn/help/ident/examples/estimating-transfer-function-models-for-a-heat-exchanger.html
做控制的时候有一个对象的数学模型非常重要，有时候对机理搞不太清楚或者很难得建立一个模型的时候可以借助实验数据直接做黑箱建模。MATLAB中提供了System identification工具可以很方便地做模型辨识，下面具体讲一下怎么操作的。
数据导入 打开matlab-&gt;App中的System identifacation：
导入的数据可以包括时域的，也可以包括频域的。填入相应的输入变量名，输出变量名，采样时间。import导入后在主界面的data views中会生成对应的图形。
按下主界面中的time plot可以显示数据，检查数据是否正确很方便。
有时候可能需要把数据拉到零附近，preprocess中提供了remove means。
要对数据进行操作时，都要把数据拖到working data中才能生效
preprocess中提供了select range可以把数据分成两个部分，一个用来辨识模型，一个用来验证模型。
我的数据一共有1000个采样点，分成两个部分，选择第一个用来辨识的数据为1-500，第二个用来验证的部分为501-1000，修改名字后insert。
重新调整一下组件，把data_est拖动到working Data区域
数据建模 1、使用Quick start估算线性模型
它将自动生成包括imp的阶跃响应、spad的频率响应、以及arxqs的四阶ARX模型。mathworks的官方解释如下：
imp — Step response over a period of time using the impulseest algorithm.
spad — Frequency response over a range of frequencies using the spa algorithm. The frequency response is the Fourier transform of the impulse response of a linear system.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7fb13afad93b65d1994ebce62b6adf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eea8e1792efb8d47d530d54ebd684aa4/" rel="bookmark">
			CSS animation多个动效叠加的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个简单的动效叠加问题：
@keyframes motion01 { 0% { transform: translate3d(0, -50%, 0) scale(.3) rotate(0deg); } 100% { transform: translate3d(0, 0, 0) scale(1) rotate(360deg); } } @keyframes motion01 { 0% { transform: rotate(0deg) scale(0.3) translate3d(0,-50%,0); } 100% { transform: rotate(360deg) scale(1) translate3d(0,0,0); } } 请问，motion01和motion02的区别是什么？
这两个css动效，如果应用在一张图片上，虽然只是平移和旋转的书写次序进行了对调，但效果却截然不同（如果图片宽和高不等的话）。
原因很简单，先旋转的情况下，图片在水平方向上占据的的宽度会发生变化，图片的中心会向右侧移动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04bcfe6929ad91c4d3a466dfa2ceeb79/" rel="bookmark">
			Redis-- key最大是多少 ，单个实例最多支持多少个key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis:
一个key或是value大小最大是512M
redis单个实例最多能存多少个key键，每个值能存储多少个元素？
解决方法：
What is the maximum number of keys a single Redis instance can hold? and what is the max number of elements in a Hash, List, Set, Sorted Set?
Redis can handle up to 2^32 keys, and was tested in practice to handle at least 250 million keys per instance.
Every hash, list, set, and sorted set, can hold 2^32 elements.
In other words your limit is likely the available memory in your system.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04bcfe6929ad91c4d3a466dfa2ceeb79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d73c49a901380528d4c305b5dc154457/" rel="bookmark">
			图像分割之Unet原理简介与代码简析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unet论文地址：
A Nested U-Net Architecture for Medical Image Segmentation
Unet是比较早的基于深度学习的分割算法了，优点是速度真的快（P100上基于VGG的backbone能跑到50帧），同时不是太开放的场景下可以做到令人满意的分割效果，在对实时性要求较高的场合下是比较适用的（不是所有的场合都能上MaskRCNN的，Backbone大一点，如果显卡差点就容易爆显存了。。），同时相比大分割网络的模型动辄几百Mb，Unet用小backbone模型就可以做到10Mb内，Conv层通道减少一点再把网络模型参数分开，模型大小可以做到很小，用CPU跑速度都挺快的，关键是分割精度在较为简单场景下还可以，load速度快太多了，简单，效果好，速度快，这也就是Unet为什么这么受欢迎的原因，下面是Unet原理介绍：
下图就是Unet网络结构：
Unet结构可以说是相对比较简单的图像分割算法了，通过四个下采样提取目标特征，再通过四个上采样，最后逐个对其像素点进行分类，那么这实际上是一个基于编码器（encode）-解码器（decode）思想，选用四个block做下采样的原因论文作者好像并没有说明，个人理解是因为是更适合测试数据集？
既然说到编码器-解码器，我的个人理解是编码器实际上相当于backbone对输入图片进行特征提取，提取出合适的feature-map，再通过解码器恢复至原尺寸，进行逐个像素点分类。
例如输入1281283的图片，输入网络后的输出为1281281的mask，
以下是一个最简单的下采样block:
x = Conv2D(64, (3, 3), padding='same', name='block1_conv1')(input) x = BatchNormalization()(x) x = Activation('relu')(x) x = Conv2D(64, (3, 3), padding='same', name='block1_conv2')(x) x = BatchNormalization()(x) b1 = Activation('relu')(x) x = MaxPooling2D()(b1) 下采样过程其实没有什么特别值得说明的，就是简单的卷积层特征提取。
上采样：
输入图像经过前面下采样进行特征提取之后，需要把图像恢复至原来的尺寸以便进一步对像素进行分类（所谓的语义分割），那么这个过程也就是上采样。
一般来说上采样方法常见的有：双线性差值（bilinear）,反卷积（Transposed Convolution），还有就是反池化（Unpooling），Unet的上采样就是通过反卷积实现的。
反卷积实质上来说是转置卷积，早在2011年被Zeiler提出，这里简单介绍一下反卷积，详细介绍请看这里
卷积的前向计算可以看做是参数矩阵和输入矩阵相乘，Y是输出，C是参数矩阵，X是输入矩阵
那么反卷积其实类似该前向的逆运算写成：
这里注意的是，反卷积只是为了恢复图像shape，而不是为了恢复图像像素，所以并不是完全的逆运算，反卷积实质还是一种卷积。
Unet中一个标准的上采样block，注意这里运用了一个跳连接把前面的特征图和上采样后的特征图concat到一起（类似resnet的思想），目的是使得上采样后的特征图具有更多的浅层语义信息，增强分割精度，这里注意，最后一层直接一个sigmoid二分类把mask分为前景和背景。
x = Conv2DTranspose(256, (2, 2), strides=(2, 2), padding='same')(x) x = BatchNormalization()(x) x = Activation('relu')(x) x = concatenate([x, b3]) x = Conv2D(256, (3, 3), padding='same')(x) x = BatchNormalization()(x) x = Activation('relu')(x) x = Conv2D(256, (3, 3), padding='same')(x) x = BatchNormalization()(x) x = Activation('relu')(x) 分类：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d73c49a901380528d4c305b5dc154457/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6456dbbf83a2bd6a3c05df1668b15729/" rel="bookmark">
			SpringBoot项目启动自动执行sql脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot项目启动自动执行sql脚本 1. 创建SpringBoot项目（Maven）2. 添加依赖3. 配置文件4. 编写sql脚本文件5. 启动执行sql脚本文件（两种方式）方式1：在配置文件中配置相关属性方式2： 自定义DataSourceInitializer 6. 运行SpringBoot项目，查看数据库7. 不同运行环境执行不同脚本 1. 创建SpringBoot项目（Maven） 略
2. 添加依赖 添加数据库驱动依赖，此处使用的是mysql数据库
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3. 配置文件 编辑application.properties
spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/test?nullNamePatternMatchesAll=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT spring.datasource.username=root spring.datasource.password=123456 yaml格式
spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/test?nullNamePatternMatchesAll=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT username: root password: 123456 4. 编写sql脚本文件 在resource目录下创建一个目录，创建sql文件 schema.sql 和 data.sql（可以创建多个）
schema.sql —— DDL脚本文件
SET NAMES utf8mb4; $$$ SET FOREIGN_KEY_CHECKS = 0;$$$ DROP TABLE IF EXISTS `tb_user_copy`; CREATE TABLE `tb_user_copy` ( `username` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '用户名', `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键id', `password` varchar(16) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, PRIMARY KEY (`id`) USING BTREE, UNIQUE INDEX `username-unique`(`username`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '用户表' ROW_FORMAT = Dynamic;$$$ SET FOREIGN_KEY_CHECKS = 1;$$$ data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6456dbbf83a2bd6a3c05df1668b15729/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeb98645734e26f8ac96d3a130493c1d/" rel="bookmark">
			WordPress博客添加看板娘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果如下:
WordPress博客添加看板娘(送37套服饰)
1. 从我的github下载压缩包
该压缩包已经自带37套服饰、支持换装功能、支持经典动漫台词展示、未来还会支持钉宫日语50音发声喔~
2. 将下载的压缩包 上传到网站的根目录,并解压
scp live2d_v1.0.zip root@xx.xx.xx.xx:/usr/local/nginx/html/vwhm_net_wwwroot/
3. 在header.php文件中添加以下代码
cd wp-content/themes/twentyseventeen/
&lt;link rel="stylesheet" href="/live2d/css/live2d.css" /&gt; &lt;script type="text/javascript" src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.js"&gt;&lt;/script&gt; 4. 在footer.php文件中body结束标签之前,添加以下代码
&lt;div id="landlord"&gt; &lt;div class="message" style="opacity:0"&gt;&lt;/div&gt; &lt;canvas id="live2d" width="280" height="250" class="live2d"&gt;&lt;/canvas&gt; &lt;div class="hide-button"&gt;隐藏&lt;/div&gt; &lt;div class="switch-button"&gt;换装&lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var message_Path = '/live2d/' var home_Path = 'http://vwhm.net' //此处修改为你的域名，必须带斜杠 &lt;/script&gt; &lt;script type="text/javascript" src="/live2d/js/live2d.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/live2d/js/message.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var index = Math.ceil(Math.random()*37) console.log('未闻花名vwhm.net + ' + index) loadlive2d("live2d", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeb98645734e26f8ac96d3a130493c1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a40aa3acc95313cc7cc16a1c78306a41/" rel="bookmark">
			2020必火的图神经网络（GNN）是什么？有什么用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读：近年来，作为一项新兴的图数据学习技术，图神经网络（GNN）受到了非常广泛的关注。2018年年末，发生了一件十分有趣的事情，该领域同时发表了三篇综述类型论文，这种“不约而同”体现了学术界对该项技术的认可。
事实上，在2019年的各大顶级学术会议上，与图神经网络有关的论文也占据了相当可观的份额。相信在未来几年，这种流行的趋势会只增不减。
本文就从“图”说起，带你了解图神经网络的概念及应用。
作者：刘忠雨、李彦霖、周洋
来源：大数据DT（ID：hzdashuju）
01 图的基本定义
图（Graph）是一个具有广泛含义的对象。在数学中，图是图论的主要研究对象；在计算机工程领域，图是一种常见的数据结构；在数据科学中，图被用来广泛描述各类关系型数据。许多图学习的理论都专注于图数据相关的任务上。
通常，图被用来表示物体与物体之间的关系。这在生活中有着非常多的现实系统与之对应，比如化学分子、通信网络、社交网络等。事实上，任何一个包含二元关系的系统都可以用图来描述。因此，研究并应用图相关的理论，具有重大的现实意义。
本文，我们主要对图相关的概念做一些基础介绍，包括图的基本定义、图在计算机中的存储表示方法与遍历方法、图数据及其常见的应用场景、图数据深度学习的浅述。
在数学中，图由顶点（Vertex）以及连接顶点的边（Edge）构成。顶点表示研究的对象，边表示两个对象之间特定的关系。
图可以表示为顶点和边的集合，记为G = (V, E)，其中V是顶点集合，E是边集合。同时，我们设图G的顶点数为N，边数为M（如无特殊说明，本文中的图均如此表示）。一条连接顶点vi, vj∈V的边记为（vi, vj）或者eij。如图1-1所示，V = {v1, v2, v3, v4, v5}，E = {(v1, v2), (v1, v3), (v2, v4), (v2, v3), (v3, v4), (v4, v5)}。
▲图1-1 图G的定义
02 图的基本类型
1. 有向图和无向图
如果图中的边存在方向性，则称这样的边为有向边eij = &lt;vi, vj&gt;，其中vi是这条有向边的起点，vj是这条有向边的终点，包含有向边的图称为有向图，如图1-2所示。与有向图相对应的是无向图，无向图中的边都是无向边，我们可以认为无向边是对称的，同时包含两个方向：eij = &lt;vi, vj&gt; = &lt;vj, vi&gt; = eji。
▲图1-2 有向图
2. 非加权图与加权图
如果图里的每条边都有一个实数与之对应，我们称这样的图为加权图，如图1-3所示，该实数称为对应边上的权重。在实际场景中，权重可以代表两地之间的路程或运输成本。一般情况下，我们习惯把权重抽象成两个顶点之间的连接强度。与之相反的是非加权图，我们可以认为非加权图各边上的权重是一样的。
▲图1-3 加权图
3. 连通图与非连通图
如果图中存在孤立的顶点，没有任何边与之相连，这样的图被称为非连通图，如图1-4所示。相反，不存在孤立顶点的图称为连通图。
▲图1-4 非连通图
4. 二部图
二部图是一类特殊的图。我们将G中的顶点集合V拆分成两个子集A和B，如果对于图中的任意一条边eij均有vi∈A，vj∈B或者vi∈B，vj∈A，则称图G为二部图，如图1-5所示。二部图是一种十分常见的图数据对象，描述了两类对象之间的交互关系，比如：用户与商品、作者与论文。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a40aa3acc95313cc7cc16a1c78306a41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e52968cbb93ee0d9314655d08d3ccd9e/" rel="bookmark">
			前端后台管理系统梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		再梳理一遍
一、商品后台管理系统 1. 功能 1.1 服务端情况 开启了CORS跨域支持需要授权的 API ，必须在请求头中使用 Authorization 字段提供token 令牌（axios拦截器）baseUrl，接口地址：http://localhost:8888/api/private/v1/ token令牌在服务端生成，当登录成功时，post请求返回的用户信息里包含了这一元素：
1.1.1 axios发ajax请求 Axios：通过promise实现对ajax技术的一种封装，ajax只能访问同源的请求。axios并没有install 方法，所以是不能使用vue.use()方法的。为了不在每个文件都引用一次axios，将它改造成vue插件。
npm安装axios发请求 1）使用
axios.get('/user?ID=12345') .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); 2） 改造为vue插件
plugins/http.js
import axios from 'axios' ​ const httpHelper = {} // 配置Vue插件 httpHelper.install = function fn (Vue) { axios.defaults.baseURL = 'http://127.0.0.1:8888/api/private/v1' Vue.prototype.$http = axios } ​ export default httpHelper main.js里安装插件
import http from '@/plugins/http.js' Vue.use(http) 1.1.2 拦截器 – 向服务端发请求需要token httpAxios.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e52968cbb93ee0d9314655d08d3ccd9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5d3171cb1c7f66d7f0116cc9a23ade6/" rel="bookmark">
			Java学习记录｜基于Maven的Druid数据库连接池配置以及空指针异常问题的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本使用 导入jar包，在pom.xml中添加相关的依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.48&lt;/version&gt; &lt;/dependency&gt; 定义配置文件，properties形式，放在resource文件夹里 druid.properties
driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/schema1 username=root password=2010abc123kl #初始化连接数 initialSize=5 #最大连接数 maxActive=10 #最长等待时间 maxWait=3000 获取数据库连接池对象，通过工厂类DuridDataSourceFactory来获取 public class DruidDemo { public static void main(String[] args) throws Exception { //1 定义配置文件 //2 加载配置文件 Properties properties=new Properties(); InputStream inputStream=DruidDemo.class.getClassLoader().getResourceAsStream("druid.properties"); properties.load(inputStream); //3 获取连接池对象 DataSource ds=DruidDataSourceFactory.createDataSource(properties); //4 获取连接 Connection conn=ds.getConnection(); System.out.println(conn); } } 遇到空指针异常（NullPointerException）的情况，可能是因为放在了src根目录下，maven项目要把配置文件放在resources文件夹 5.可正确返回结果
二、druid工具类的创建 public class JDBCUtils { //1 定义成员变量 private static DataSource ds; //2对datasource初始化赋值 static { //3 加载配置文件 Properties pro=new Properties(); try { pro.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5d3171cb1c7f66d7f0116cc9a23ade6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc9dd35262476b279916e933548a7243/" rel="bookmark">
			解决报错：struct.error: unpack_from requires a buffer of at least 4 bytes
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久没更了（大概是因为在国外抗疫hhh），言归正传。
最近实验到后期，跑今年的SOTA提取语义mask的时候，批量处理图片时出现报错。
Traceback (most recent call last): File "/home/xiaoman/.local/lib/python3.6/site-packages/PIL/ImageFile.py", line 235, in load s = read(self.decodermaxblock) File "/home/xiaoman/.local/lib/python3.6/site-packages/PIL/PngImagePlugin.py", line 659, in load_read cid, pos, length = self.png.read() File "/home/xiaoman/.local/lib/python3.6/site-packages/PIL/PngImagePlugin.py", line 122, in read length = i32(s) File "/home/xiaoman/.local/lib/python3.6/site-packages/PIL/_binary.py", line 82, in i32be return unpack_from("&gt;I", c, o)[0] struct.error: unpack_from requires a buffer of at least 4 bytes 搜了一下，出现该报错在不同应用下解决答案不同，但是根本原因是函数unpack_from在使用的时候，输入的参数不对，解决问题的关键就是查看数据源和参数设定。该函数有三个参量：fmt,buffer,offfset，一般buffer不会出问题。然后我就去check了一下测试的图片集，结果发现了问题：
该图片大小不对，删掉，bug解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6846fc0839808bf14fa5fdb7a381906/" rel="bookmark">
			怎么判断map不为空
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例代码：
public static void main(String[] args) { Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); System.out.println("map为空：" + map.isEmpty()); //加入元素 map.put("1", "1"); System.out.println("map为空：" + map.isEmpty()); } 输出结果：
这里是用isEmpty()方法来做判断，其实和map.size()也没差，可以看下isEmpty()方法的源码：
public boolean isEmpty() { return size == 0; } 其实就是把map的size和0做个判断，返回false和true结果。
总结
如果不是要根据具体的size来做相应的业务操作，只是做判空的话，完全可以用isEmpty()方法，看起来也舒服。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a3571f1a303a2b7599dc8e47ee8137c/" rel="bookmark">
			VMWare克隆虚拟机并修改为固定ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.选择我们要克隆的虚拟机，右键点击----管理----克隆，点后点击下一步
2.选择克隆类型，创建链接克隆虽然节约磁盘空间，但是原始虚拟机被删除后，无法使用，建议选择创建完整克隆，然后一直下一步等待完成。
3.重新生成MAC地址
4.修改为静态ip,查询当前ip信息
修改ip信息
cd /etc/sysconfig/network-scripts vi ifcfg-ens33 5.重启网卡，查看当前ip
重启网卡
service network restart 查看ip
ifconfig 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d17df76a1458cd4703b8abd238c64da0/" rel="bookmark">
			多目标优化 MOP （六）：遗传算法 Two_Arch2  2015
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 论文：Two_Arch2： An Improved Two-Archive Algorithm for Many-Objective Optimization
进化算法在解决MaOP问题的时候经常遇到2个问题dominance resistance (DR) 和 the active diversity promotion (ADP)，为了解决以上问题，可以采用4中方法：non-Pareto-based approaches, objective reduction, preference-based approaches, 和 dominance relation.non-Pareto-based approaches包括基于aggregation functions的MOEA/D，基于indicatior的IBEA等；objective reduction包括Pareto corner search evolutionary algorithm (PCSEA)；preference-based approaches可以帮助决策制定者找到PF，可以分为交互的和非交互的方法。
这篇文章提出了两个存档的方法，两个档案分别是indicator-based和Pareto-based，Pareto-based用于保存收敛性好的solution(CA)，indicator-based保存多样性好的solution（DA）。采用了一种心的Lp-norm-based ( p &lt; 1) 多样性维护机制。
Two_Arch2特点：兼顾了收敛性、多样性和复杂度，不需要参考点和其他人为设置。
A.Two_Arch算法流程：
Two_Arch的重组和迭代过程与MOEA相似，重组中的交叉和变异阶段，CA和DA的合集可以看作父代，选择操作也没有特别之处，CA和DA根据不同的不表有不同的更新规则。
当种群通过交叉变异后获得offsrping子代后，对于子代中的非支配解，如果该解支配CA或DA中任何一个解则被放入CA，同时删除CA和DA中被支配的解， 如果该解没有支配其他解则放入DA，CA和DA中都是非支配解。如果CA和DA中解的和大于N，则删除DA中距离CA最小的解。在Two_Arch中，CA和DA没有固定的大小，只有他们的和的大小为N的限制，删除的解都来自于DA.
Two_Arch仍然是一个Pareto-based的算法，在MaOP问题中仍然会失效，另外，在CA中没有多样性维护机制，虽然CA的作用是保持收敛性，如果CF在true PF上而CA中非支配解满足总的个数N，此时没有DA的空间可以存放非支配解了，这时整个DA被删除了也就没有多样性的机制优势了。
TWO_ARCH2算法：
为了保持很好的收敛性和多样性和可接受的复杂度，只使用pareto dominance relation是不够的。作者发现IBEA算法中 可以保持良好的收敛性和多样性，因此作者在外部存档中引入了这个方法，但是CA和DA根据不同的dominance relations更新。在TWO_ARCH2中，CA和DA的角色更加清晰，CA引导种群收敛到true PF,DA在高维目标空间增加种群的多样性。这是为什么交叉操作发生在CA和DA中，但是只有CA发生变异，同时，CA和DA的存档个数都是固定的。在选择操作中，CA和DA的子代选择都是独立的，采用不同的方法，因为CA的多样性差，DA作为最后的输出结果。
B. Convergence Archive(CA)
表示一个solution在目标空间中要支配另一个solution所需要的最小距离，公式如下
Two_Arch2在CA更新中，offspring首先被添加到CA中，然后删除适应度值小的多余的solution，然后更新CA中的个体适应度值
C. Diversity Archive 多样性可以理解为：solution应该分布在目标空间中接近PF的位置，同时，当solution投影到低维目标空间时，差异应该最大化 1）DA中的选择操作：DA中的更新基于pareto dominance，只有非支配解才能加入到DA中，在 Two_Arch2中，采用加入到DA中而不是删除DA中的个体。如果DA中的solutions数量溢出，首先将最大或最小solution添加到DA中，然后将最步相似的solution添加到DA中，计算相似度采用L p -norm-based distance。 2）Similarity in High-Dimensional Space fractional distances ( L p -norm, p &lt; 1) 被证明在高维空间表现很好，当p取小于1的值时，可以表示不同solution之间的较大差异。 Computational Complexity Analysis N个solution的m个目标问题，IBEA的复杂度是 ， T WO_ARCH 将N个solution分配到DA和CA复杂度是 ，删除步骤是 ，总体复杂度是 ， MOEA/D复杂度是 ， AGE-II是 ， NSGA-III是 ， Two_Arch2是 测试问题：DTLZ1-4和WFG1-9 测试指标：IGD 对比算法： T WO _A RCH , IBEA, NSGA-III, MOEA/D, AGE-II 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/265a8662f42fbbee742d50f104264b67/" rel="bookmark">
			[深度学习]-基于tensorflow的CNN和RNN-LSTM文本情感分析对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于tensorflow的CNN和LSTM文本情感分析对比 1. 背景介绍2. 数据集介绍2.0 wordsList.npy2.1 wordVectors.npy2.2 idsMatrix.npy2.2.0 文本预处理2.2.0 为什么把词转化为词向量 2.3 Helper Functions 3. RNN网络训练4. CNN网络训练5. CNN与RNN训练结果对比6. 循环神经网络系列参考文献 1. 背景介绍 如今科技日益发展、网络技术不断深入到大众生活中，贴吧、网站、电子邮件，用户评论等使得人们有更多的便捷方式在网络中发表自己的意见和看法。这些数量庞大的文本中的情感信息有着极大的研究价值和实用价值。而如何能够从众多文本信息和数据中准确而高效地分析出文本中所蕴含的情感，并判断情感极性，对情感做出分类，是目前自然语言处理中的一个热门研究课题。关于文本情感分析，在此之前国内外专家和学者们都已经做了大量的研究，其中运用深度学习来对文本进行情感分析是常用的文本情感分析方法。神经网络模型通过学习和训练后，能有效地模拟人脑的学习方式，对大量的输入文本信息进行高效的分析，并对文本中的情感进行判断，非常适合用于文本情感分析的研究中。
2. 数据集介绍 Google 已经帮助我们在大规模数据集上训练出来了 Word2Vec 模型，它包括 1000 亿个不同的词，在这个模型中，谷歌能创建300万个词向量，每个向量维度为 300。在理想情况下，我们将使用这些向量来构建模型，但是因为这个单词向量矩阵太大了**（3.6G**），因此在此次研究中我们将使用一个更加易于管理的矩阵，该矩阵由 GloVe 进行训练得到。矩阵将包含 400000 个词向量，每个向量的维数为 50。
我们将导入两个不同的数据结构，一个是包含 400000 个单词的 Python 列表（wordsList.npy），一个是包含所有单词向量值的 400000*50 维的嵌入矩阵 （wordVectors.npy）。
数据和代码可以从下面连接中下载
https://github.com/adeshpande3/LSTM-Sentiment-Analysis
如果上面数据集无法下载，可以通过下面我的百度网盘下载
链接：https://pan.baidu.com/s/1O-tGXFt4z9-CbzzJ0CTRkA
提取码：lj20
2.0 wordsList.npy 一个是包含 400000 个单词的 Python 列表，它里面每个单词对应的位置就是 wordVectors里相应词向量的位置
例子：如果我们要查找baseball这个词的相应词向量
import numpy as np import tensorflow as tf import os as os import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/265a8662f42fbbee742d50f104264b67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34c1460d6456f5fdc29d7bc7b4c3a120/" rel="bookmark">
			CNN&#43;SVM模型实现图形多分类任务（SVM替换softmax分类器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘要
模型构建
读取数据集：
CNN模型构建：
模型结构：
训练模型：
结果对比分析：
结束：
摘要 为解决采用 softmax 作为卷积神经网络分类器导致图形分类识别模型泛化能力的不足，不能较好适用图像分类等问题，本次博客使用SVM代替CNN网络的softmax分类层，即CNN提取特征后利用SVM进行分类。为了验证模型更改后的效果，本次在随机构建的垃圾分类数据集上做了一个简单的验证性实验。以验证SVM替换softmax分类器正确进行图像分类的效果。
模型构建 垃圾图像数据为随机选择的一部分数据，总共2143张图片，6个类别。采用train_test_split函数进行随机分割数据，75%作为训练集，其他的作为测试集。为了加快训练速度，采用resize函数实现图像的缩小。这也是导致整体准确率不高的一个原因。
读取数据集： for imagePath in imagePaths: # load the image, pre-process it, and store it in the data list image = cv2.imread(imagePath) image = cv2.resize(image, (norm_size, norm_size)) image = img_to_array(image) data.append(image) # extract the class label from the image path and update the # labels list label = int(imagePath.split(os.path.sep)[-2]) labels.append(label) data = np.array(data, dtype="float") / 255.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34c1460d6456f5fdc29d7bc7b4c3a120/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ba533dcf6fbd8b049a005fd5ee5e86e/" rel="bookmark">
			Vue 中路由导航守卫的介绍及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 路由导航守卫是为了路由跳转之前做的检查及操作
比如：用户没有登录 而是直接通过修改浏览器 url 来访问网页，这种操作无疑是不安全的。路由导航守卫可以让我们对用户要跳转的路由做一次检查，符合条件后放行，不符合条件则强制用户跳转登录页面。
代码如下：
//在路由对象上 挂载路由导航守卫 router.beforeEach((to,from,next) =&gt; { //to 将要访问的路径 //from 代表从哪个路径跳转过来 //next 是一个函数，表示放行 // 1.next() 放行 2.next('/login') 强制跳转到login if(to.path === '/login') return next();//如果用户访问登录页，直接放行 const tokenStr = window.sessionStorage.getItem('token')//获取token if(!tokenStr) return next('/login')//如果没有token 则强制登录 next()//如果用户携带了 token 则放行 }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c00333e52613f3e2a018c3d0df40b82/" rel="bookmark">
			解决pyinstaller打包exe文件过大（菜鸟一刀切傻办法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pyinstaller打包exe文件过大 作为认真学习了Python两个多月的小白，觉得python还是有很多玄学，一直搞不懂明明一毛一样的步骤，为什么我用pyinstaller打包出来的exe有300M，别人只有30M！为了弄清楚介个问题，老姐姐真的是搞了几天几夜，参考了多个前辈的文档，通过自己的各种猜测终于搞好了，抑制不住自己澎湃的心情，想跟大家分享一下一些可能不是很成熟的想法。
part1不成熟的猜测 在很多文档里面都有写到过exe过大，可能是打包很多无用的模块和库，打包完后会有两个文件夹，build和dist，对比两次在build里PKG文件，在没打包成功前就是290多M，打包成功后就是29M，根据缩写和文件，我猜测PKG说明了打包模块和库有多大，所以打包了多余的包这个我认为是正确的。
我使用了各种包括建立虚拟环境的方法都没办法避免打包多余的包，当然太复杂看不懂的就没试了。但是在试的过程中，自己也进行了思考，和基友使用同一种打包方法，步骤一毛一样，为什么我不行呢？有什么不同的地方，那只能是安装的环境了。在各种不同的打包的过程中，我都明显看到会引用anaconda库，再加上很多文章说打包是会一起打包anaconda很多的已有包，所以暂时认为anaconda有影响。然后，根据建立虚拟环境的思路，是为了创造一个没有多余包的环境，我之前很多次安装需要的包时直接运行cmd后pip，可能也会导致pyinstaller打包整个环境安装过的包，因为我比较懒，懒得一条条实验，所以决定按着自己的思路，重新安装环境。
Part2重新安装环境 首先，先把自己的环境卸载干净，有意要试一试的需要百度如何干净卸载python+anaconda+pycharm。
完成卸载后，我决定不再安装anaconda，大家可以查一下不安装anaconda有什么影响，我暂时判断影响不大，因为pycharm用setting安装包也很方便，然后大家就可以正常安装python和pycharm了。
python安装这里有个坑，坑了我两天，就是python现在已经是3.8版了，但是pyinstaller貌似不支持3.8版本，没卸载anconda前，在pycharm 虚拟环境Teminal下打包完，打开exe程序会出Fail to execute script pyi_rth_pkgres。当时也是找了很多方法，但是没办法解决，后来没安装anaconda后，直接用pycharm安装，居然直接按不上！头都大了！无意间看到github下面的pycharm包的描述，支持的python是 3.5到3.7版本，之前又隐约看到什么降级解决，当时没搞懂什么意思，降什么级？到这里，大概猜测是不支持3.8版本，所以果断改安装了3.7版本，果然一切都顺利了，太爱自己了！
Part3规范自己的工程建立、包安装 作为菜鸟的我，真的是很菜很菜，自己真的是很大胆，随便点点能够运行得起来就不去探究具体的方式，沾沾自喜，觉得so easy，封装exe真的是教会了我做人。
重新安装好后我就决定要好好维护这个干净的环境。
step1：
pycharm建立工程使用虚拟环境，这个之前看到入门材料有写，最好使用virtualenv，建立虚拟环境然后这个环境就是独立的，包括安装各种库，都不会影响其他工程，
安装各种依赖库不要用cmd-pip，直接在pycharm工程里setting安装或者Teminal-pip，虽然我不确定有米有影响。
最后就是在pycharm Teminal运行：
pyinstaller -Fw XXX.py
然后还有一个菜鸟会遇到的问题，就是pycharm安装依赖库的时候经常因为镜像问题导致安装不上，推荐一个文pycharm创建虚拟环境venv和添加依赖库package - 一字千金 - 博客园 https://www.cnblogs.com/bclshuai/p/12488341.html
超有用!!!
好勒，以上就是一个菜鸟不成熟的日志，今晚终于可以睡个好觉了。
补充若干打包exe问题 打包过程中经常存在打包完后打不开程序，这个是时候打包exe的时候可以先不屏蔽dos窗口，这样可以用来排查问题。
即使用：pyinstaller -F XX.py就行了
1.Fail to execute script pyi_rth_pkgres
这里可以看到原因是Pyinstaller No module named pkg_resources.py2_warn
查资料说是pyinstaller跟不上setuptools升级，把setuptools降级到44.0.0及以下
pip install setuptools==44.0.0
实验后解决
2.No module named ‘win32com’
打包好exe后，win10使用没问题，win7使用会出现
看着是pandas的库有问题，跟据setuptools经验对pandas降了级，还是有问题，因为是在pycharm terminal打包的，看了一下记录，会有No module named ‘win32com’ pycharm中没有导入pywin32，setting导入，打包成功。
后来试着不降级pandas，还是会有问题，具体要降到多少还没试，直接降到0.25版本了，现在最新是1.03。。。
然后就是待更新了。。。。。
python使人头秃，一直python一直秃。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a949d45a79b6973f4144352485c6ae4/" rel="bookmark">
			5G学习笔记之NG-RAN系统架构（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料：38.401 NG-RAN架构的一般性原则如下： 1. 信令和数据传输网络逻辑分离； 2. NG-RAN和5GC与传输相互独立。NG-RAN和5GC的寻址方案与传输的寻址方案没有相关性，即同一个设备中，传输功能不是NG-RAN或者5GC的一部分。 3. RRC连接的移动性完全由NG-RAN控制。 NG-RAN接口的一般性原则如下： 1. The functional division across the interfaces have as few options as possible. 2. Interfaces are based on a logical model of the entity controlled through this interface. 3. One physical network element can implement multiple logical nodes. NG-RAN系统架构文章链接：
5G学习笔记之NG-RAN系统架构（1）
5G学习笔记之NG-RAN系统架构（2）
5G学习笔记之NG-RAN系统架构（3）
目录 1. NG-RAN架构 2. gNB-CU-CP和gNB-CU-UP分离架构 3. NR-RAN标识 4. UE associations in NG-RAN Node 1. NG-RAN架构 NG-RAN由多个与5GC连接的gNB组成。gNB之间由Xn连接，gNB与5GC之间由NG连接。一个gNB可包含一个gNB-CU和一个或多个gNB-DU。
① gNB-CU与gNB-DU之间通过F1接口连接；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a949d45a79b6973f4144352485c6ae4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1526ed61e0597a82496395e8c7d2ddc/" rel="bookmark">
			XtraBackup工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XtraBackup是innobackupex和xtrabackup协同工作完成备份任务的，innobackupex启动后创建xtrabackup进程并且启动xtrabackup进程，xtrabackup进程首先启动redo log复制线程，然后启动ibd复制线程，在复制ibd的过程中，redo复制线程一直工作，xtrabackup复制ibd完成后，通知innobackupex进程，innobackupex收到通知后，会执行备份锁lock tables forbackup ，开始执行复制非InnoDB文件，当非InnoDB文件复制完成后，innobackupex开始执行lock binlog for backup 开始获取binlog位置信息，将binlog信息写到文件中，完成之后通知xtrabackup进程，并且自己会处于等待状态，xtrabackup收到通知后，会停止redo log的复制线程，告知innobackupex redo复制完成了，innobackupex 收到通知后开始释放锁资源，接下来innobackupex和xtrabackup进行后期工作，例如资源释放，备份元数据信息，最后innobackupex等待xtrabackup进程结束后退出
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40a3eb9f5a1cd8f266a77103ca4a19c4/" rel="bookmark">
			electron 窗口BrowserWindow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const mainWindow = new BrowserWindow({ width: 800, height: 600, frame:false, 弹出的窗口有无边框,默认为有 show:false, 是否显示窗口,否后,通过对象.show()打开 backgroundColor:"#ADD6FF" 设置背景色,16进制rgba格式 webPreferences: { 网页功能设置 preload: path.join(__dirname, 'preload.js'), 脚本路径 nodeIntegration:true, 配置 webviewTag:true 配置 }, }) 让窗口加载内容 窗口对象.loadFile('路径'); 窗口对象.loadURL('url'); 等到窗口内容加载完后再显示 1、设置show:false 2、设置监听 窗口对象.once("ready-to-show",()=&gt;{窗口对象.show();}) 子窗口 不指定坐标和大小,默认和父窗口一样大且覆盖在上面 父窗口关闭,子窗口也关闭 var 子窗口对象=new BrowserWindow({ x:弹出窗口x坐标 y:弹出窗口y坐标 parent:父窗口对象 }) 子窗口对象.show() 模态子窗口 弹出改窗口后,不能点击父窗口 在子窗口的基础上,在创建时添加属性modal:true 文档
渲染进程加载页面
代码示例:
// Modules to control application life and create native browser window const {app, BrowserWindow} = require('electron') const path = require('path') function createWindow () { // Create the browser window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40a3eb9f5a1cd8f266a77103ca4a19c4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/369/">«</a>
	<span class="pagination__item pagination__item--current">370/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/371/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>