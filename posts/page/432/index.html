<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/684618f5f960fdbab65019b4b6e4ab94/" rel="bookmark">
			vbs实现恶搞无限弹窗，复制粘贴就能用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vbs简单实现弹窗 直接新建txt文档，复制粘贴下面代码：
do
a =msgbox("你怕是个ZZ吧？",vbYesNoCancel,"一份认真的问卷调查")
if a =vbYes then
msgbox "emmmm，还算有点自知之明",,"恭喜你，真正的认识了自己！"
exit do
elseif a =vbNo then
b =msgbox("心里没点AC数吗？",vbYesNo,"不要想太多，你就是！")
if b =vbYes then
msgbox "没点数，自己照照镜子啊！",,"这就是你学习好的原因啊"
else
msgbox "能认识错误还是好的",,"MDZZ"
end if
else
d =msgbox("取消你吗呢",vbYesNo,"还想点取消？")
if d =vbYes then
msgbox "取消也没用",,"这是一个轮回"
else
msgbox "不取消就赶紧承认吧",,"ZZ"
end if
end if
loop
保存，修改文件格式为vbs，确认，打开。
“”双引号里面可以随意修改内容，看别人很多都是写表白的，作为一名钢铁直男，我觉得还是现在这样比较好玩，试试发给妹子会不会被打死，如果没更新博客应该就是当场去世了~
注意：第五行的 exit do 表示退出 就是说第一次点击yes之后可以点确定退出弹窗，否则无限循环。（把exit do这句去掉就是死循环了，但是可以通过结束进程来关闭，这个就不多说了，有问题多百度！） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b30a969a8d3c1f6fa0c17ba49fa1768d/" rel="bookmark">
			MT6580 Android8.1调试移植费恩格尔指纹驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先用万用表确定好vcc 2.8v和1.8v的供电正常，有的平台2.8v是软件控制打开，有的平台是直接硬件长供的。
2、根据原理图确定好gpio的配置主要包括spi_cs,spi_sck，spi_miso，spi_mosi，还有复位脚rst和中断脚int:，使用的是哪一组SPI通讯等。
3、dts添加cdfinger 的节点，gpio的配置等，注意查看所使用的gpio是否有其他地方有复用:
vim kernel-3.18/arch/arm/boot/dts/alongk80_bsp.dts
&amp;cdfinger {
compatible = "cdfinger,fps1098";
reg = &lt;0&gt;;
interrupt-parent = &lt;&amp;eintc&gt;;
interrupts = &lt;83 IRQ_TYPE_EDGE_RISING&gt;;
debounce = &lt;83 0&gt;;
vdd_ldo_enable = &lt;0&gt;;
vio_ldo_enable = &lt;0&gt;;
config_spi_pin = &lt;1&gt;;
spi-max-frequency = &lt;8000000&gt;;
pinctrl-names = "fingerprint_reset_high",
"fingerprint_reset_low",
"fingerprint_spi_miso",
"fingerprint_spi_mosi",
"fingerprint_spi_sck",
"fingerprint_spi_cs",
"fingerprint_irq";
pinctrl-0 = &lt;&amp;fps_reset_high&gt;;
pinctrl-1 = &lt;&amp;fps_reset_low&gt;;
pinctrl-2 = &lt;&amp;fps_spi_miso&gt;;
pinctrl-3 = &lt;&amp;fps_spi_mosi&gt;;
pinctrl-4 = &lt;&amp;fps_spi_sck&gt;;
pinctrl-5 = &lt;&amp;fps_spi_cs&gt;;
pinctrl-6 = &lt;&amp;fps_irq&gt;;
status = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b30a969a8d3c1f6fa0c17ba49fa1768d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc5bc706181c96aadd20d4edfbbae8cf/" rel="bookmark">
			error while loading shared libraries: libnet.so.1:cannot open shared object file :No such file or di
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux共享库路径配置详解：
Linux下找不到共享库文件的典型现象为明明已经安装某个软包（如libnet，mysql），编译连接可以正常进行，但是在运行时出现如“error while loading shared libraries: libnet.so.1:cannot open shared object file :No such file or directory”的错误提示。
原因是Linux下的共享库路径配置不正确。默认的linux共享库搜索路径为/lib和/usr/lib两个目录（不包含子目录），若共享库不在这两个路径，不能自动连接到（最典型的就是/usr/local/lib），解决方法有四种：
1，连接时使用静态库（.a文件）。在g++命令上写入改.a文件的完整路径。
2，修改LD_LIBRARY_PATH环境变量。（临时有效，且有时候没有效果）
3，将库文件复制到可以搜索到的路径里面，这样比较狠，但是可能导致一些后即问题。
4，添加搜索路径，使用ldconfig命令（下面详细介绍）。
添加搜索路径方法步骤：
1，先到官网下载对应的源码版本编译安装软件包（make install）。
2，使用locate命令找到该库的被默认安装的路径，使用方法是先用updatedb更新一下locate命令的索引库，然后“locate libnet.so”查找就可以了，在这里我发现，自动编译安装的库文件被放在了/usr/local/lib目录。
3，修改/etc/ld.so.conf，添加路径。在CentOS 6.3下我看到这个文件实际上是包含了/etc/ld.so.conf.d/这个目录下的所有.conf文件，因此我们可以在这个路径下面创建一个新的文件，其中写上诸如“/usr/local/lib”、“/usr/local/mysql/lib”的路径，保存退出。
4，切记一定要主动执行命令：ldconfig，它会更新记录了系统中有哪些so文件的缓存文件（/etc /ld.so.cache）
另外我发现： http://www.linuxidc.com/Linux/2012-12/76632.htm 对于ldconfig的讲解很好，大家可以参考。下面是摘自那里的一段话：
ldconfig几个需要注意的地方
1. 往/lib和/usr/lib里面加东西，是不用修改/etc/ld.so.conf的，但是完了之后要调一下ldconfig，不然这个library会找不到
2. 想往上面两个目录以外加东西的时候，一定要修改/etc/ld.so.conf，然后再调用ldconfig，不然也会找不到
比如安装了一个mysql到/usr/local/mysql，mysql有一大堆library在 /usr/local/mysql/lib下面，这时就需要在/etc/ld.so.conf下面加一行/usr/local/mysql/lib，保存 过后ldconfig一下，新的library才能在程序运行时被找到。
3. 如果想在这两个目录以外放lib，但是又不想在/etc/ld.so.conf中加东西（或者是没有权限加东西）。那也可以，就是export一个全局变 量LD_LIBRARY_PATH，然后运行程序的时候就会去这个目录中找library。一般来讲这只是一种临时的解决方案，在没有权限或临时需要的时 候使用。
4. ldconfig做的这些东西都与运行程序时有关，跟编译时一点关系都没有。编译的时候还是该加-L就得加，不要混淆了。
5. 总之，就是不管做了什么关于library的变动后，最好都ldconfig一下，不然会出现一些意想不到的结果。不会花太多的时间，但是会省很多的事。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67152bdd40c6b2987d0f784857fa5878/" rel="bookmark">
			Python中字符串的合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一: 使用join的方法 &gt;&gt;&gt; " ".join(["A","B","C","D"]) 'A B C D' 方法二: 使用字符串格式化拼接 &gt;&gt;&gt; "%s's age is %d" % ("Jerry", 18) "Jerry's age is 18" &gt;&gt;&gt; 方法三: 使用+来拼接 &gt;&gt;&gt; "&lt;&lt;" + Name1 + " &amp; " + Name2 + "&gt;&gt;" '&lt;&lt;Jerry &amp; Tom&gt;&gt;' &gt;&gt;&gt; 方法四: 使用for循环来处理 &gt;&gt;&gt; long_string = "" &gt;&gt;&gt; for s in ["A", "B", "C", "D"]: ... long_string += s ... &gt;&gt;&gt; print(long_string) ABCD &gt;&gt;&gt; 方法五: 使用operator中的add函数结合reduce来处理 &gt;&gt;&gt; import operator &gt;&gt;&gt; reduce(operator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67152bdd40c6b2987d0f784857fa5878/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c489adc26211fe98451ec814c5aad936/" rel="bookmark">
			根据随机生成的月份，打印该月份的天数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：根据随机生成的月份，打印该月份的天数 思路：1、了解每年共有12个月，有29天的月份是2月，30天的月份是？31天的月份月份是？ 2、利用Scanner输入月份，然后用Switch选择语句输出打印。 public class Ddy { public static void main(String[] args) { Scanner input=new Scanner(System.in); System.out.println(“请输入正确的月份”); int month=input.nextInt(); switch (month) { case 2: System.out.println(“该月份29天”); break; case 1: case 3: case 5: case 7: case 8: case 10: case 12: System.out.println(“该月份31天”); break; case 4: case 6: case 9: case 11: System.out.println(“该月份30天”); break; default: System.out.println(“输出月份有误”); break; } }
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b204330dadf0f90e037aa194891ff317/" rel="bookmark">
			set -o  vi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		set -o vi
再用esc+K键就可以使用上一条指令了
esc+k
esc+j
上下翻
ksh默认是emacs风格的。set -o emacs
在AIX下使用自己已经使用过的命令
在AIX下使用，默认的shell是KSH，和linux下的bash不一样的是，他不能采用我们大家已经熟悉的DOS下的键或者其他我们已经熟悉的快捷键来使用我们上次已经使用过的命令，比如在DOS命令状态下（我把我自己经常用的快捷键列出来，可能还其他的，慢慢补充），大家可以通过F7来取得你已经在当前DOS窗口中输入过的不重复的命令（Windows对你自己在当前窗口顺序输入的非重复命令进行排序，以0，1，2...来编号），F1重复上次同一个位置上的字符，F3重复上次所有的命令,F5和F8向上翻我已经输入过的命令,F9是可以输入你要显示的上次输入的非重复的命令ID（比如，进入某DOS窗口之后，我依次输入了两条命令：dir和cd test，那么本窗口的第0条命令就是dir，类推，当我按下F9的时候，系统提示我“输入命令号码”，这个时候我按照上次输入的顺序号进行输入即可，比如选择0那么这个时候就是dir命令，这个功能和F7的功能是一致的，只是F7可以选择，F9可以直接输入，这两个功能当你输入的命令比较长的时候是比较有用的）。
要想在AIX下使用上次你已经使用过的命令，可以使用以下的方法：
1、在ksh下，运行set -o vi，这个时候整个命令状态就是是VI编辑器了，操作的方法和VI编辑器一摸一样，要重复上次的命令，就在当前状态栏下按ESC，然后输入k，就可以看到下一条命令，按下k就可以查询上一条命令，h可以在当前行向前移动一个字符的位置，l可以在当前行向后移动一个字符的为止，当然这个时候相当于处于vi的状态，所有在vi状态下的对单行操作的命令都可以使用。编辑好之后直接按回车即可。
2、如果不不是在ksh下，那么你可以在命令窗口下运行ksh -o vi，其他的命令和第一种方法一样
3、在ksh的环境变量中设置EDITOR=vi即可，修改的方法即在.profile中直接加入EDITOR=vi;export EDITOR即可。
4、删除历史命令，可以在当前用户的主目录下，查询到一个.sh_history的文件，里面记载了你所有在当前用户输入过的命令。可以将这个文件编辑一下，然后将其中的命令删除掉就可以了。当然你可以将自己喜欢的命令或者比较长的命令放在里面，以后你就直接调用就可以了。当然从这个文件可以看出上面几点讲的采用vi的命令来取得上次的命令，其实ksh是取得这个文件中的信息。
5、以下小技巧：
a、重复上一条命令可以直接在ksh状态下输入r
b、你可以在ksh状态下执行r a=b，意思是先将上一条命令中的a字符用b字符替换，然后运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/567234316f1e4c9139f85b496d4d4c15/" rel="bookmark">
			python计算机二级复习重点总结（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		九月份python计算机二级考试马上就要来了，笔者在这里为各位整理了元组，列表，字典，集合的所有用法，以及考试重点分析。接下来笔者每周将会更新复习总结，感谢大家的支持。
一、python语言基本语法元素 1、程序的基本语法：程序框架，缩进，注释，变量，命名，保留字，语句，引用。 2、基本的输入输出函数：input（） 、eval（）、print（）。 3、源程序的书写风格。 4、Python语言的特点：计算生态。
二、基本的数据类型 1、数字类型：整数类型、浮点类型和复数类型。 （int，float） 2、数字类型的运算：数值运算操作符，数值运算函数。（+-/ %% （取整） %（取余） **(幂)） 3、字符串类型及格式化：索 引 str[i] 切片 str[a:b:c] 基本的format（）格式化方法。 4、字符串类型的操作：字符串操作符、处理函数和处理方法。 5、类型判断和类型转换。
三、程序的控制结构 1、分支结构：单分支结构（if），二分支结构（if-else），多分支结构（if-elif-else） 2、程序的循环结构：遍历循环、无限循环、break和continue循环控制。 3、程序的异常处理：try-except（-else（更高级一点））
四、列表、元组、字典、集合等方法的总结 1、元组的创建 （元组是不可修改的，因此不能添加，不能删除，不能查找元素）
tupl=（） #创建一个空元组 &gt;&gt;&gt;tupl=（1，2，3） &gt;&gt;&gt;2 in tupl #判断一个元素是否存在于元组中 True 2、列表的创建
list_a=[] #创建一个空列表 列表的切片操作
&gt;&gt;&gt;list_a=[1,2,3,4,5,6,7,8,9] &gt;&gt;&gt;list_a[1:8:3] [2,5,8] 列表与字符串的重要区别是，列表中的元素可被更改，因此可以使用赋值语句改变列表中任意的值。
&gt;&gt;&gt;lst=[1,2,3,4] &gt;&gt;&gt;lst[2]=7 &gt;&gt;&gt;lst [1,2,7,4] 列表的求和
s=[1,2,3,4,5,6,7,8,9] sum=0 for i in s: sum+=i print("sum is ",sum) &gt;&gt;&gt;sum is 45 list.append(x):在列表末尾添加元素xlist.extend(L):在列表末尾加入指定列表L的所有元素，等价于a+L.list.insert(i,x):在位置i插入x，其余元素依次向后退。list.remove(x):删除列表第一个值为x的元素，若该元素不存在则报错。list.pop([i]):删除列表第i个位置的元素，并返回该元素；若不指定索引i则移除并返回列表最后一个元素。list.clear():删除列表的所有元素，等价于 ：del a[ : ]。list.reverse():将列表元素顺序反转。list.copy():返回列表的浅复制，等价a[ : ]list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/567234316f1e4c9139f85b496d4d4c15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8ac94152634f0103b7c7a08056c2372/" rel="bookmark">
			十进制分数转换二进制数（思路与伪码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行十进制数转换为二进制数时，可有如下变换：
为求等价的二进制数，将{Xn}设为转化后的每个数位上的数字、A、B分别作为分子分母，且A/B为非假分数，若为假分数，相关处理看伪码部分。
设A/B（十进制分数）=0.x1,x2,x3,...xn （转化而成的n位二进制）
若 2A&gt;=B，则得一位二进制数 ”1“，且A=2A-B；
若2A&lt;B，则得一位二进制数”0“，且A=2A；
重复如上操作，直至A-B=0。
如11/16 = 0.1011
2*11=22(&gt;16)①；进位“1”， 此时二进制数=0.1
(22-16)*2=12（&lt;16)②；进位“0”，此时二进制数=0.10
12*2=24（&gt;16)③；进位“1”， 此时二进制数 =0.101
（24-16）*2=16（&gt;=16)④；进位“1”， 此时二进制数 = 0.1011
16-16=0 ，done
output=0.1011
连贯起来便2*11→（22-16）*2→12*2→（24-16）*2→16-16→0
伪码：
①对十进制分数A/B，进行判断，若A&gt;B，则A = A% B，且记录假分数的整数部分F = A / B。
②判断A == B？若False 则跳转至③，若True 则跳转至④。
③判断 A * 2 &gt;= B?若True：
数组{Xn}（用于存储二进制中每一位数），Xi = 1；
A = A * 2 - B；
返回②。
若False：
Xi = 0；
i = i + 1 （i用于控制数组下标移动，且初始值为0）；
返回②。
④输出F与小数点"."，若i == 0 ，则不输出{Xn}；否则一次性输出{Xn}，输出范围从下标0 ~ i-1。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33b56f8005baa13f37d365215cb48d83/" rel="bookmark">
			网关、路由、DNS详细解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网关(Gateway)又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。针对普通客户来说，网关就是运营商的交换机端口地址，也就是家庭网络将外联的数据包发送的目的地。
DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。 什么是网关，路由，dns？计算机主机网关的作用是什么？(引用比喻) 假设你的名字叫小不点，你住在一个大院子里，你的邻居有很多小伙伴，在门口传达室还有个看大门的李大爷，李大爷就是你的网关。当你想跟院子里的某个小伙伴玩，只要你在院子里大喊一声他的名字，他听到了就会回应你，并且跑出来跟你玩。但是你不被允许走出大门，你想与外界发生的一切联系，都必须由门口的李大爷（网关）用电话帮助你联系。假如你想找你的同学小明聊天，小明家住在很远的另外一个院子里，他家的院子里也有一个看门的王大爷（小明的网关）。但是你不知道小明家的电话号码，不过你的班主任老师有一份你们班全体同学的名单和电话号码对照表，你的老师就是你的DNS服务器。于是你在家里拨通了门口李大爷的电话，有了下面的对话： 小不点：李大爷，我想找班主任查一下小明的电话号码行吗？ 李大爷：好，你等着。（接着李大爷给你的班主任挂了一个电话，问清楚了小明的电话）问到了，他家的号码是211.99.99.99 小不点：太好了！李大爷，我想找小明，你再帮我联系一下小明吧。 李大爷：没问题。（接着李大爷向电话局发出了请求接通小明家电话的请求，最后一关当然是被转接到了小明家那个院子的王大爷那里，然后王大爷把电话给转到小明家）就这样你和小明取得了联系。
至于DHCP服务器嘛，可以这样比喻：
你家院子里的居民越来越多了，传达室李大爷那里的电话交换机已经不能满足这么多居民的需求了，所以只好采用了一种新技术叫做DHCP，居民们开机的时候随机得到一个电话号码，每一次得到的号码都可能会不同。
你家门口的李大爷：就是你的网关
你的班主任：就是你的DNS服务器
传达室的电话交换机：就是你的DHCP服务器
同上，李大爷和王大爷之间的对话就叫做路由。
另：如果还有个小朋友叫做小暗，他住的院子看门的是孙大爷，因为小暗的院子刚盖好，孙大爷刚来不久，他没有李大爷和王大爷办公室的电话（李大爷和王大爷当然也没有他的电话），这时会有两种情况：
1、居委会的赵大妈告诉了孙大爷关于李、王两位大爷的电话（同时赵大妈也告诉了李、王关于孙的电话），这就叫静态设定路由
2、赵大妈病了，孙大爷自己到处打电话，见人就说：“我是小暗他们院子管电话的”，结果被李、王二位听到了，就记在了他们的通讯录上，然后李、王就给孙大爷回了个电话说：“我是小明（小不点）他们院子管电话的”，这就叫动态设定路由
然后有一天小不点要找小暗，结果自然是小不点给李大爷打电话说：“大爷，我找小暗”（这里省略了李大爷去查小暗电话的过程，假设他知道小暗的电话），李大爷一找通讯录：“哦，小暗的院子的电话是孙大爷管着的，要找小暗自然先要通知孙大爷，我可以通知王大爷让他去找孙大爷，也可以自己直接找孙，那当然是自己直接找孙方便了”，于是李大爷给孙大爷打了电话，然后孙大爷又把电话转到了小暗家。
这里李大爷的通讯录叫做路由表。
李大爷选择是自己直接找孙大爷还是让王大爷帮忙转接叫做路由选择。
李大爷之所以选择直接找孙大爷是有依据的，因为他直接找孙大爷就能一步到位，如果要王大爷转接就需要两步才能完成，这里的“步”叫做“跳数”，李大爷的选择遵循的是最少步骤（跳数）原则（如果他不遵守这个原则，小不点可能就会多等些时间才能找到小暗，最终结果可能导致李大爷因工作不力被炒鱿鱼，这叫做“延时太长，选路原则不合理，换了一个路由器”）
当然，事情总是变化的，小不点和小明吵架了，这些天小不点老是给小暗打电话，小明心里想：“操，他是不是在说我坏话啊？”于是小明决定偷听小不点和小暗的通话，但是他又不能出院子，怎么办呢？小明做了这样一个决定：
首先他告诉自己院里管电话的王大爷说：“你给李大爷打个电话说小暗搬到咱们院子了，以后凡是打给他的电话我来接”，王大爷没反映过来（毕竟年纪大了啊！）就给李大爷打了电话，说：“现在我来管理小暗的电话了，孙已经不管了”，结果李大爷就把他的通讯录改了，这叫做路由欺骗。
以后小不点再找小暗，李大爷就转给王大爷了（其实应该转给孙大爷的），王大爷收到了这个电话就转给了小明（因为他之前已经和小明说好了），小明收到这个电话就假装小暗和小不点通信。因为小明作贼心虚，害怕明天小不点和小暗见面后当面问他，于是通信断了之后，又自己以小不点的名义给小暗通了个电话复述了一遍刚才的话，有这就叫数据窃听。
再后来，小不点还是不断的和小暗联系，而零落了小明，小明心里嘀咕啊：“我不能总是这样以小暗的身份和小不点通话啊，外一有一天露馅了怎么办！”于是他想了一个更阴险的招数：“干脆我也不偷听你们的电话了，你小不点不是不给我打电话吗！那我让你也给小暗打不了，哼哼！”，他怎么做的呢？我们来看：
他联系了一批狐朋狗友，和他们串通好，每天固定一个时间大家一起给小暗院子传达室打电话，内容什么都有，只要传达室的孙爷爷接电话，就会听到“打雷啦，下雨收衣服啊！”、“人是人他妈生的，妖是妖他妈生的”、“你妈贵姓”等等，听的脑袋都大了，不听又不行，电话不停的响啊！终于有一天，孙爷爷忍不住了，大喊一声：“我受不了拉！！！！”，于是上吊自杀了！
这就是最简单的DDOS攻击，孙爷爷心理承受能力弱的现象叫做“数据报处理模块有BUG”，孙爷爷的自杀叫做“路由器瘫痪”。如果是我，就会微笑着和他们拉家常，例如告诉他们“我早就听了天气预报，衣服10分钟前已经收好了”或者“那你妈是人还是妖”或者“和你奶奶一个姓”等等，我这种健全的心理叫做“健壮的数据报处理，能够抵御任何攻击”
孙爷爷瘫了之后，小不点终于不再给小暗打电话了，因为无论他怎么打对方都是忙音，这种现象叫做“拒绝服务”，所以小明的做法还有一个名字叫做“拒绝服务攻击”。
小明终于安静了几天，…
几天后，小明的院子来了一个美丽的女孩，名字叫做小丽，小明很喜欢她（小小年纪玩什么早恋！）可是小丽有个很帅的男朋友，小明干瞪眼没办法。当然这里还是要遵循上面的原则：小丽是不能出院子的。那个男的想泡小丽自然只能打电话，于是小明又蠢蠢欲动了：
还记得王爷爷是院子的电话总管吗？他之所以能管理电话是因为他有一个通讯录，因为同一个院子可能有2个孩子都叫小明，靠名字无法区分，所以通讯录上每一行只有两项：
门牌 电话
一号门 1234567 （这个是小明的）
二号门 7654321 （这个是小丽的）
……
王爷爷记性不好，但这总不会错了吧（同一个院子不会有2个“二号门”吧）？每次打电话人家都要说出要找的电话号码，然后通过通讯录去院子里面敲门，比如人家说我找“1234567”，于是王爷爷一比较，哦，是一号门的，他就去敲一号门“听电话”，如果是找“7654321”，那他就找二号门“听电话”。
这里的电话号码就是传说中的“IP地址”
这里的门牌号就是传说中的网卡的’MAC‘地址（每一块网卡的MAC地址都是不一样的，这是网卡的制造商写死在网卡的芯片中的）
小明心里想“奶奶的，老子泡不到你也别想泡”，于是他打起了王爷爷通讯录的主意，经过细心的观察，周密的准备，他终于发现王爷爷有尿频的毛病（毕竟是老人啊…），终于在一个月黑风高的白天，王爷爷去上厕所了，小明偷偷的摸进传达室，小心翼翼的改了王爷爷的通讯录……
过了几天，小丽的男朋友又给小丽打来了电话，对方报的电话是“7654321”，王爷爷一看通讯录，靠：
门牌 电话
一号门 1234567 （这个是小明的）
一号门 7654321 （注意：这个原来是小丽的，但是被小明改了）
……
王爷爷不知道改了啊，于是就去找一号门的小明了，小明心里这个美啊，他以小丽父亲的口吻严厉的教训了那个男的和小丽之间不正当的男女关系，结果那个男的恭恭敬敬的挂了电话。当然小丽并不知道整个事情的发生…
这里小明的行为叫做“ARP欺骗”（因为在实际的网络上是通过发送ARP数据包来实现的，所以叫做“ARP欺骗”），王爷爷的通讯录叫做“ARP表”
这里要注意：王爷爷现在有两个通讯录了，一个是记录每个院子传达室电话的本本，叫做“路由表”，一个是现在说的记录院子里面详细信息的本本，叫做“ARP表”。
有句命言是“人们总是在追求完美的，尽管永远也做不到”（请记住这句话，因为这是一个大名人–也就是我，说的）
王爷爷的制度中有一条是这么写的“每个月要重新检查一下门牌号和电话的对应本（也就是ARP表）”，这个动作叫做“刷新ARP表”，每个月的时间限制叫做 “刷新ARP表的周期”。这样小明为了让那个男的永远不能找到小丽，之后每个月都要偷偷改一次那个通讯录，不过这样也是不得不做的事啊！
补充一点，小明是很聪明的，如果通讯录（ARP表）被改成了这样：
门牌（MAC） 电话（IP）
一号门 1234567 （这个是小明的）
二号门 1234567 （注意：这个被小明改了，但是他一时头晕改错了）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33b56f8005baa13f37d365215cb48d83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d909bc013c39271fb55ce696cf02f453/" rel="bookmark">
			JDK1.8 The Java® Virtual Machine Specification《2.The Structure of the Java Virtual Mach》（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.3.1 （积分）指数表达类型值
整型类型在虚拟机中的值表现为
byte-128到127-2^7 to 2^7 - 1short-32768到32767-2^15 to 2^15 - 1int-2147483648到2147483647-2^31 to 2^31 - 1long从-9223372036854775808到9223372036854775807-2^63 to 2^63 - 1char0到65535-- 2.3.2 浮点类型，值集 与 值
浮点数就是指32位的单精度浮点数float和双精度64位的double，他们的格式与IEEE754定义的float
和double是近乎相通的，而且对数值的操作与IEEE规定的标准二进制浮点数计算方式相关。IEEE 754 标准不仅包含正负符号幅度数，而且包含正负零，正负无穷数以及NaN（一个非数字值 Not a Number的简称），NaN这个值被用来表示表示无效操作的结果，例如零除以零....
每一个java虚拟机的实现中都需要用到两种标准的浮点集，他们是浮点值集和倍精度数値集合。除此之外一个java虚拟机的实现也许会根据自身设置，提供扩展指数浮点数集和扩展指数双浮点数集中的任意一个或全部（也不知道翻译的正不正确 called the float-extended-exponent value setand the double-extended-exponent value set.）。在某些情况下，这些扩展指数值集会替代标准值集去表示float和double类型的值。
任何浮点类型的有限非零值可以表达成如下公式s ⋅ m ⋅ 2^(e − N + 1) 其中s表示+1或者-1， m是一个小于2N的正整数，e是一个介于之间的整数，并且N 和 K 是取决于值集的参数。有些数值可能有多种展现方式。
（说实话下面的话真不太懂）
例如，假设值集中的值 V 可能使用 s，m 和 e 的某些值（不明白），如果 m为偶数并且 e小于2^(K -1)，则可以减半 m并将 e增加1以产生相同值 v（one could halve m and increase e by 1 to produce a second representation for the same value v.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d909bc013c39271fb55ce696cf02f453/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6db807cd7fd82cba3f68cc52c5b68aa4/" rel="bookmark">
			1.TwoSum(两数之和)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。
你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。
示例
给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 解题思路 1.暴力枚举 从头到尾枚举相加，如果值相等，记录下标，最后返回，很自然想到。时间复杂度为O(n^2)。
var twoSum = function (nums, target) { //空数组，用于存放将来符合条件的下标 var arr = []; for (var i=0; i &lt; nums.length; i++) { for (var j=i + 1; j &lt; nums.length; j++) { if (target == nums[i] + nums[j]) { arr.push(i, j); return arr; } } } }; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6db807cd7fd82cba3f68cc52c5b68aa4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a9f864f136e9da7efa2666e53defa32/" rel="bookmark">
			A simple yet effective baseline for 3d human pose estimation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A simple yet effective baseline for 3d human pose estimation 主要工作 在以往的人体3D关键点检测的方法中，主要有两种，一种是构造end-to-end的网络，直接实现输入普通图像，输出人体3D关键点；另一种是首先使用2D关键点检测的方法，检测出2D的关键点，然后使用匹配对对齐的方式构造出3D关键点。
这篇文章的工作非常简单，但是也非常的有用。其主要工作就是构造一个网络，实现2D人体关键点到3D关键点的映射。实际上，2D关键点到3D关键点的映射，就是一个回归过程，而现在使用神经网络构造回归器是非常容易的，因此很容易想到使用训练一个神经网络，实现回归过程。因为作者的方法比较简单，所以作者自己也说这是一个baseline。具体的：
构造了一个高效的2D转关键点转3D关键点的 神经网络 实现细节 网络结构 作者借鉴了如上图所示的Resnet residual结构，作者称之为block，每个block中有两个全连接层（Linear），每个全连接层后面都跟着batch normalization、ReLU、Dropout层。
除此之外，作者还在block前，加了一个全连接层，用来将输入的16*2的关节点升维到1024维，同样的，在网络最后也加了一个全连接层，用来将1024维的数据降维到16*3
在网络中，block的数量可多可少，这里作者一共使用了两个block。
网络输入和输出 输入： 2D关节点的坐标，16*2表示的是16个关节点，每个关节点的坐标是二维的
输出：3D关节点的坐标， 16*3
训练细节 训练数据： Human3.6M： http://vision.imar.ro/human3.6m/description.php
训练参数： Epoch=200， Adam，batch_size=64，weight init=Kaiming initialization， lr=0.001
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89d97a44e8e92a15fbc5d8ec05d5f512/" rel="bookmark">
			using namespace std
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整体认识 —— 解决命名冲突 一个简单的C++程序：
#include&lt;iostream&gt; using namespace std; int main(int argc,char **argv) { cout&lt;&lt;"hello world !"&lt;&lt;endl; system("pause"); // 让程序暂停,按任意键继续 注意，这行不是标准的C++代码, 仅限于调试使用 cout&lt;&lt;"出来了"&lt;&lt;endl; return 0; } 其中：
using namespace std; 是什么意思，又有什么作用呢？
“using namespace std;”，顾名思义 —— 使用（using）名空间（namespace）std，std是名空间的名字，这是C++为了解决不同工程的变量，函数等命名冲突的问题，引入的名空间（namespace）的概念，相当于文件夹的目录和子文件的关系——不同的目录（namespce）下即使有相同子文件名（变量，函数等）也不会产生冲突（如果接触过Java，这里类似于Java中不同的包的作用）。下面是个小例子：
// 声明名空间Jack namespace Jack { double height; void fetch(); } // 声明名空间Jill namespace Jill { double height; void fetch(); } // 使用名空间 cout&lt;&lt;Jack::height&lt;&lt;endl; cout&lt;&lt;Jill::height&lt;&lt;endl; Jack::fetch(); 可以看到，可以指定特定名空间下的同名变量(height)和函数(fetch())。
有时名空间内的内容太多，使用限定符::就太过繁琐，可以使用"using namespace XXX;"直接引入整个名空间：
namespace Jack { double height; void fetch(); .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89d97a44e8e92a15fbc5d8ec05d5f512/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fafc5d2dde4a85b40c49afc75ac90b08/" rel="bookmark">
			Centos 6.8安装Python3.7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：阿里云ECS+Centos 6.8 64bit
Python版本：Python 3.7.0b5
安装前准备：
1、下载源代码：直接用wget在官网下载，命令如下
wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0b5.tgz 因为Centos 6.8安装Python3.7会缺少两个库，会报如下错误：
zipimport.ZipImportError: can't decompress data; zlib not available
ModuleNotFoundError: No module named '_ctypes'
所以需要先安装， 命令如下：
yum install -y zlib* yum install -y libffi-devel 2、解压源代码，命令如下：
tar -zxvf Python-3.7.0b5.tgz 3、配置环境，命令如下：
cd Python-3.7.0b5 ./configure 4、编译源码，并且安装，命令如下：
make &amp;&amp; make install 安装完成之后，如图：
至此，Python3.7已经安装完成。
如果已经安装了Python2.x的同学，需要重新做一下软链，具体操作如下：
cd /usr/bin/ mv python python.2.bak ln -s /usr/local/bin/python3 python 这时候python -V就可以看到是变成3.7的版本了
附：阿里云100+产品1000元代金券：点我领取
12.12活动2折：点我点我
突发性实例特价，1核1G，1年仅需293：点我查看
个人博客：www.huangwx.cn
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31d007d33151d3462471480ae3b1a12f/" rel="bookmark">
			pytorch各个版本的下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. pytorch0.4.0, python3.5, Linux, cu80, 86_64 http://download.pytorch.org/whl/cu80/torch-0.4.0-cp35-cp35m-linux_x86_64.whl
2. pytorch0.4.0, python3.5, Linux, cu90, 86_64 http://download.pytorch.org/whl/cu90/torch-0.4.0-cp35-cp35m-linux_x86_64.whl
3. pytorch0.4.0, python3.6, windows, cpu, 64 http://download.pytorch.org/whl/cpu/torch-0.4.0-cp36-cp36m-win_amd64.whl
4. pytorch0.4.0, python2.7, Linux, cu90, 86_64 http://download.pytorch.org/whl/cu90/torch-0.4.0-cp27-cp27m-linux_x86_64.whl
5. pytorch0.3.1, python3.5, Linux, cu80, 86_64 http://download.pytorch.org/whl/cu80/torch-0.3.1-cp35-cp35m-linux_x86_64.whl
6. pytorch0.3.1, python3.6, Linux, cu80, 86_64 http://download.pytorch.org/whl/cu80/torch-0.3.1-cp36-cp36m-linux_x86_64.whl
http://download.pytorch.org/whl/cu90/torch-0.4.0-cp36-cp36m-linux_x86_64.whl
http://download.pytorch.org/whl/cu90/torch-0.3.1-cp36-cp36m-linux_x86_64.whl
其他照推.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2905be25b219a20b9b9b59b544e76bd/" rel="bookmark">
			Android Studio快捷键Ctrl&#43;Shift&#43;F不能用，全局搜索不能用；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AS全局搜索Ctrl+Shift+F突然就不能用了，在AS找半天没有找到问题，原因竟然是和搜狗输入法的简繁切换快捷键冲突了；下面有图把简繁切换关闭或更换快捷键后，as的全局搜索就能用了；
附： Ctrl+Shift+R 全局替换功能也可以当作全局搜索使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36568ebc695d1c4aae3405a2b2621548/" rel="bookmark">
			Opencv处理图像--细化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Opencv处理图像--细化 细化的算法有很多种，但比较常用的算法是查表法
细化是从原来的图中去掉一些点，但仍要保持原来的形状。
实际上是保持原图的骨架。
代码如上：
#include&lt;iostream&gt; #include&lt;opencv2/core/core.hpp&gt; #include&lt;opencv2/highgui/highgui.hpp&gt; IplImage* ColorSrc ,*ColorSrcCopy; //#define SHOW //#define LONG int //#define BYTE unsigned char / //基于索引表的细化细化算法 //功能：对图象进行细化 //参数：lpDIBBits：代表图象的一维数组 // lWidth：图象高度 // lHeight：图象宽度 // 无返回值 bool ThiningDIBSkeleton (unsigned char* lpDIBBits, int lWidth, int lHeight) {	//循环变量 long i; long j; long lLength; unsigned char deletemark[256] = { 0,0,0,0,0,0,0,1,	0,0,1,1,0,0,1,1, 0,0,0,0,0,0,0,0,	0,0,1,1,1,0,1,1, 0,0,0,0,0,0,0,0,	1,0,0,0,1,0,1,1, 0,0,0,0,0,0,0,0,	1,0,1,1,1,0,1,1, 0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,	1,0,0,0,1,0,1,1, 1,0,0,0,0,0,0,0,	1,0,1,1,1,0,1,1, 0,0,1,1,0,0,1,1,	0,0,0,1,0,0,1,1, 0,0,0,0,0,0,0,0,	0,0,0,1,0,0,1,1, 1,1,0,1,0,0,0,1,	0,0,0,0,0,0,0,0, 1,1,0,1,0,0,0,1,	1,1,0,0,1,0,0,0, 0,1,1,1,0,0,1,1,	0,0,0,1,0,0,1,1, 0,0,0,0,0,0,0,0,	0,0,0,0,0,1,1,1, 1,1,1,1,0,0,1,1,	1,1,0,0,1,1,0,0, 1,1,1,1,0,0,1,1,	1,1,0,0,1,1,0,0 };//索引表 unsigned char p0, p1, p2, p3, p4, p5, p6, p7; unsigned char *pmid, *pmidtemp; unsigned char sum; int changed; bool bStart = true; lLength = lWidth * lHeight; unsigned char *pTemp = (unsigned char *)malloc(sizeof(unsigned char) * lWidth * lHeight); // P0 P1 P2 // P7 P3 // P6 P5 P4 while(bStart) { bStart = false; changed = 0; //首先求边缘点(并行) pmid = (unsigned char *)lpDIBBits + lWidth + 1; memset(pTemp, 0, lLength); pmidtemp = (unsigned char *)pTemp + lWidth + 1; for(i = 1; i &lt; lHeight -1; i++) { for(j = 1; j &lt; lWidth - 1; j++) { if( *pmid == 0) { pmid++; pmidtemp++; continue; } p3 = *(pmid + 1); p2 = *(pmid + 1 - lWidth); p1 = *(pmid - lWidth); p0 = *(pmid - lWidth -1); p7 = *(pmid - 1); p6 = *(pmid + lWidth - 1); p5 = *(pmid + lWidth); p4 = *(pmid + lWidth + 1); sum = p0 &amp; p1 &amp; p2 &amp; p3 &amp; p4 &amp; p5 &amp; p6 &amp; p7; if(sum == 0) { *pmidtemp = 1; #ifdef SHOW cvSet2D(ColorSrc,i,j,cvScalar(0,0,255)); #endif } pmid++; pmidtemp++; } pmid++; pmid++; pmidtemp++; pmidtemp++; } #ifdef SHOW cvNamedWindow("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36568ebc695d1c4aae3405a2b2621548/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8eaed9f70c016ba091f598d98c1e5a2/" rel="bookmark">
			题解报告：poj 1321 棋盘问题（dfs）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Description 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 Input 输入含有多组测试数据。 每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n ，当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 Output 对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。 Sample Input 2 1 #. .# 4 4 ...# ..#. .#.. #... -1 -1 Sample Output 2 1
解题思路：摆放k个棋子，行列上至多只有1个棋子并且其只能放在'#'位置上，求可行的方案数。借用N皇后思想，用一个一维数组col_pl来标记每列上是否已经摆放了一个棋子，然后递归到每一行时查看该行的每一列是否还有没摆放棋子，并且该位置是'#'，如果没有，返回到上一个状态去深搜下一列，否则k--，同时到下一行进行深搜，如果k减到0时，说明此时有一种合理方案，计数器就加1，然后返回到上一个状态位置，继续深搜下一列，边界条件是如果row==n，则直接返回到上一个状态。
AC代码：
1 #include&lt;iostream&gt; 2 #include&lt;cstdio&gt; 3 #include&lt;string.h&gt; 4 using namespace std; 5 int n,k,cnt,num;char mp[9][9],col_pl[9];//col_pl标记每一列是否已放置了一个棋子 6 void dfs(int row,int num){ 7 if(row==n||num==0){//边界条件row（行）递增到n 8 if(num==0)cnt++;//如果num值减为0，则计数器加1 9 return;//都返回到上一层 10 } 11 for(int col=0;col&lt;n;++col){//枚举每一列 12 if(mp[row][col]=='#'&amp;&amp;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8eaed9f70c016ba091f598d98c1e5a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10b2b57ff2aedadb0d5523aa70d7df46/" rel="bookmark">
			Text Classification -- Convolutional Networks、sentence level Attentional RNN、Hierarchical attention
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from：https://richliao.github.io/
Text Classification, Part I - Convolutional Networks Text classification is a very classical problem. The goal is to classify documents into a fixed number of predefined categories, given a variable length of text bodies. It is widely use in sentimental analysis (IMDB, YELP reviews classification), stock market sentimental analysis, to GOOGLE’s smart email reply. This is a very active research area both in academia and industry. In the following series of posts, I will try to present a few different approaches and compare their performances.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10b2b57ff2aedadb0d5523aa70d7df46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b66e70bd5426cfc4d502497d9af74840/" rel="bookmark">
			Centos7下安装ORACLE 11g，弹窗不显示或者显示太小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CentOS7上安装Oracle的时候经常碰到oracle安装客户端的弹窗很小，有的时候还会只有一个竖条，很是烦人。
####解决办法：
./runInstaller -jreLoc /etc/alternatives/jre_1.8.0 这样执行就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92c0cc16ca00d4beac8c1a6cdb7fe0c1/" rel="bookmark">
			什么是闭包（closure），为什么要用它？在开发项目时什么地方用闭包？以及优点和缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 闭包概念：即通过函数嵌套函数，内部函数引用局部变量实现变量不释放。广泛来讲，所有函数访问另一个函数内部变量的过程都可以称之为闭包
2. 优点：局部变量不释放
缺点：内存泄漏、内存占用
3. 闭包的实现基于以下三点：
函数可以创建独立作用域（因此闭包的实现依赖于函数）；
自由变量跨作用域取值，要去创建该函数的作用域中取值；
变量被函数引用时不会被释放；
4. 为什么要用它？
就是为了防止变量污染，但是用多了会内存泄漏
5. 在开发项目时什么地方用闭包？
闭包就是父函数给子函数传值，解决作用域问题。
在es6出现之后一般使用let
比如做一个随机抽题功能、选项卡、幻灯片等。一般用setInterval的地方用的比较多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d8807bf937d0889eec7d8607728b067/" rel="bookmark">
			H5页面播放视频—试看3分钟(使用video.js)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 var myPlayer = videojs('#small-video'); videojs('#small-video', {}, function() { $('#small-video source').attr('src', reloadUrl); myPlayer.src(reloadUrl); myPlayer.load(reloadUrl); if (autoPlay === true) { myPlayer.play(); if (autoPlay === true) { myPlayer.play(); myPlayer.on('timeupdate', function () { console.log(myPlayer.currentTime()); }); } myPlayer.on('play', function () { console.log('开始/恢复播放'); }); } }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e90bb172bd6af0f6c18c3f6aaa22546b/" rel="bookmark">
			Linux用命令启动程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请标明出处：http://blog.csdn.net/wu_wxc/article/details/48931037
本文出自【吴孝城的CSDN博客】
安装了一个程序，想在终端里启动它，需要给它配置个环境
这里用Google浏览器作例子
安装好Chrome
在终端输入
chrome 提示：chrome：未找到命令
输入
sudo gedit ~/.bashrc 打开bashrc
加入chrome的路径
export PATH=$PATH:/opt/google/chrome 因为chrome默认装在这个目录下
这个目录下有个chrome文件，就是用来启动chrome的
保存，打开一个新的终端
输入
chrome 就可以打开谷哥浏览器了
export是输出PATH，使环境变量生效
PATH=$PATH:/opt/google/chrome意思是把/opt/google/chrome加入到环境变量中
export PATH是使环境变量生效
":"相当于Windows的";"
Linux和Unix的sh中
以$开头的字符串表示的是sh中定义的变量
这些变量有系统自动增加的
也可以是用户自己定义的
$PATH表示的是系统的命令搜索路径，相当于windows的%path%
$HOME则表示是用户的主目录，也就是用户登录后工作目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95551751f3030e70426dd32f8eaedb16/" rel="bookmark">
			4.2图像分割之区域分裂与合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区域分裂与合并 区域生长是从一组生长点开始的，另一种方法是在开始时将图像分割成一系列任意不相关的区域，然后将它们合并或者拆分以满足限制条件，这就是区域分裂与合并。通过分裂，可以将不同特征的区域分离开，而通过合并，可以将相同特征的区域合并起来。
（1） 分裂 令R表示整个图像，P代表某种相似性准则。一种区域分裂方法是首先将图像等分为4个区域，然后反复将分割得到的子图像再次分为4个区域，直到对任意Ri，P(Ri)= TRUE，表示区域Ri已经满足相似性准则（比如该区域内灰度值相等或相似），此时不再进行分裂操作。这个过程可以用四叉树形式表示，如下图所示。
其中图(a)中未标出的四个区域分别为R411、R412、R413和R414。
（2） 合并 分裂操作完成之后，结果中一般会包含具有满足相似性的相邻区域，这就需要将满足相似性条件的相邻区域进行合并。可在分裂完成之后，也可以在分裂的同时，对具有相似特征的相邻区域进行合并。一种方法是将图像中任意具有相似特征的相邻区域Rj和Rk合并，即如果P（RjURk）=TRUE，则合并Rj和Rk。合并的两个区域可以大小不同，即不在同一层。当无法再进行聚合或拆分时操作停止。
整个过程如下图所示。
示例演示 分割出OpenCV Logo 最上面的C。具体看代码，算法代码的速度还需要提高。运行结果如下：
[代码下载]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b9f2d54a50271620dfd4acd063349eb/" rel="bookmark">
			升级内存条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，聊一聊如何升级自己的电脑。（先讲升级内存条，下一篇讲升级硬盘）
许多朋友的电脑买的早，现在硬件更新换代太快，机子满足不了日常工作了。或者是买的时候不太懂电脑，就在电脑城稀里糊涂的买了，时间一长，发现也不太好用了。
机子好不好用取决于 日常软件系统维护 和 硬件性能。 相对来说，硬件起到更大的作用。工欲善其事，必先利其器。
一切都没关系，咱们自己小整一下就可以让机子焕然一新啦！
升级内存条！ 1.内存条是干嘛的，为什么要升级它？
通俗的说内存决定机子可以同时运行多少个程序。打个比方，一间50人的教室，进入100人就会挤得要命吧！如果此时咱们让100人进入200人的教室，那大家空间都很合适，可以自己干自己的工作了。
所以咱们要扩大内存条容量来满足更多程序的运行工作（现在程序越做越大，需要的空间也越多）。
2.查看自己电脑的内存大小。 打开计算机，在硬盘的空白处右击选择属性。下图小编的机子是8GB的。目前来看，8GB可以满足日常工作了。（大型游戏和特殊工作软件除外）
如果你的机子小于8GB,那就需要升级了。
3.查看自己机子最大支持多少内存。开始----运行----cmd-----wmic memphysical get maxcapacity-----得到最大支持内存
如下图 得到 33554432 33554432/1024/1024=32 除以两遍1024 得到电脑支持的最大内存，我的机子可支持到32GB。
4.接下来就要看看自己的电脑 有几个内存条卡槽，可以百度自己机子型号找到拆机教程 拆开看看。早晚都要拆，不要害怕，买完内存条按的时候也要拆开，就是拆个盖子，自己跟 着教程小心一点就可以了。下图我的笔记本是两个卡槽，我自己配的是两个4GB内存条。
5.看完卡槽，就要考虑买什么样的内存条了。如果电脑现在是2GB,咱们直接换一条8GB。 如果是4GB 的咱们就再买一条4GB。这就要考虑自己的财力了，换成两条8GB 16GB的都是可以的。
这里有一个原则。配两条就尽量 大小一样，参数一样。要不就配一条。
大小指 都是4GB 都是8GB 这样的（组成双通道，加快运行速度）。参数指 版本电压一样 频率一样 ，现在新机子的内存条都是 ddr4低电压版，老机子好多还是ddr3高电压版。ddr3 里面又分1066HZ 1333HZ 1600HZ 等。
无论你是安装一条内存条还是两条都要和原配内存条参数一致，这样才可以使主板兼容内存条。方便一点就安装 鲁大师 或者 驱动精灵（可参考如何安装软件https://blog.csdn.net/weixin_42715688/article/details/81219185），安装之后打开软件 硬件检测，就可以查看自己机子的内存条型号了。
6.如何购买？品牌，价位？ 我自己都是在 某东 上购买。 具体哪里买，大家自己决定。 对于品牌，几点建议。金士顿的兼容性最好，价格偏高。 国产品牌的价格稍低一些，用起来也是可以的，我自己家里就用的协德的，我感觉没问题。这东西就是看自己手头资金了，一分钱一分货。
挑选时一定看好 型号，型号，型号。你的电脑 原配内存条是ddr3高电压版 你就买 ddr3高电压版 原配是低电压版你就买低电压版。
区分笔记本和台式机，这两种内存条的尺寸不同。
7.买完之后，根据百度的拆机教程，打开后盖。内存条安装时，对准插入即可。如果没插好开机就是黑屏，断电重新再插一遍。
好了，升级内存条就这些内容。朋友们如果哪里不懂，欢迎留言或者扫描下方二维码向我提问。下一篇讲述如何升级硬盘。 小编最近申请了一个微信公众号，准备写一些电脑知识和其他提升自身的小技能，感兴趣的小伙伴搜索 拾光日子 。 咱们下篇再见！ 下一篇：升级硬盘 https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b9f2d54a50271620dfd4acd063349eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8820dd92999a10dc1f8dddb642df0e7/" rel="bookmark">
			CSS  响应式控制字体大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#footer{ font-size: 0.8rem; } @media only screen and (min-width:768px){ #footer{font-size: 1rem;} } @media only screen and (min-width:992px){ #footer{font-size:1.2rem;} } @media only screen and (min-width:2000px){ #footer{font-size:1.6rem;} } 如果您有什么不明白的地方或其它想问的可以关注我的公众号,给我留言,我会尽可能的帮您解决遇到的问题
ps:如果您对摄影感兴趣,也可以关注我的公众号,不定时会分享自己的摄影经验和调色设定,欢迎交流,哈哈哈哈哈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d58695c45d7de96c55172c04ad7f84a/" rel="bookmark">
			sql语句记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.联查到的数据（存于临时表A中）与B表比较，查找到A表存在的数据，B表不存在 SELECT * FROM (SELECT a.userid FROM a,b where a.userid=b.userid and groupid=5) as a WHERE a.userid NOT IN (SaaELECT a.userid FROM b); 2.查询openid重复的所有数据 select *, username,openid,phone,FROM_UNIXTIME(registertime, '%Y-%m-%d %h:%m:%s') from a, b where a.userid=b.userid and openid in (select openid from a group by openid having count(1) &gt; 1) and openid != '' and phone!='' ORDER BY registertime desc; 3.拼接设置字符值 concat update a set phone = concat('hqs_' + username) where userid in ('42496', '42645') 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d58695c45d7de96c55172c04ad7f84a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a36c63dfddfd85e7f274ee5b860227a/" rel="bookmark">
			mybatis测试中出现ERROR StatusLogger No log4j2 configuration file found.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先附上官网的说明文档：
mybatis Logging 概述 在mybatis框架搭建完成用log4j2进行测试时，总是出现ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console错误。
经过各种方法后，终于找到一种有效管用的方法。首先介绍我的环境版本号：
log4j2的jar包版本号是mybatis3.4.5框架自带的log4j，如下所示：
环境spring4.3.0+springmvc4.3.0+mybatis3.4.5
按官方文档的说明
1 SLF4J 2 Apache Commons Logging 3 Log4j 2 4 Log4j 5 JDK logging ，mybatis会使用最先找到的（按上文列举的顺序查找），不少应用服务器的classpath中已经包含Commons Logging，如Tomcat和WebShpere， 所以MyBatis会把它作为具体的日志实现。所以我们首先得指定要使用哪个日志框架，因为是在ssm环境中配置，所以没有mybatis-config.xml文件，就不能在里面配置下面几行
&lt;configuration&gt; &lt;settings&gt; ... &lt;setting name="logImpl" value="LOG4J"/&gt; ... &lt;/settings&gt; &lt;/configuration&gt; 那我们就得在web.xml文件中指定使用log4j作为我们的日志框架的实现。
独立运行的报错解决方案： 错误解决办法：右击工程名新建一个source folder， 命名为resources，下面建一个log4j.properties文件， 你可以对包、映射类的全限定名、命名空间或全限定语句名开启日志功能来查看 MyBatis 的日志语句。
再次说明下，具体怎么做，由使用的日志工具决定，这里以 Log4J 为例。配置日志功能非常简单：添加一个或多个配置文件（如 log4j.properties），有时需要添加 jar 包（如 log4j.jar）。下面的例子将使用 Log4J 来配置完整的日志服务，共两个步骤：
步骤 1：添加 Log4J 的 jar 包 因为我们使用的是 Log4J，就要确保它的 jar 包在应用中是可用的。要启用 Log4J，只要将 jar 包添加到应用的类路径中即可。Log4J 的 jar 包可以在上面的链接中下载。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a36c63dfddfd85e7f274ee5b860227a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc36272dda83a92a4310b154880cf028/" rel="bookmark">
			vue 实现input表单元素的disabled
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 场景分析解决 场景 今天产品经理提了一个需求:
一个API的账号体系增加一个checkbox控制API输出字段,但是有三个是伪控制，事实上是接口里面写死的， 所以是必须选中的
分析 重点是怎么在Vue组件中实现 checkbox的disabled, 哈 这个肯定是需要使用元素绑定的Vue做这个操作可以实现disabled input元素的传递, 这个就很秒了 解决 &lt;input type="checkbox" :disabled="" &gt;具体解决方案如下 &lt;div class="checkbox"&gt; &lt;label class="checkbox-inline" v-for="show_field in form_params.export_fields"&gt; &lt;input type="checkbox" :disabled="isDefault(show_field.value)" v-model="form_params.field" :value="show_field.value"&gt;{{ show_field.name }} &lt;/label&gt; &lt;/div&gt; // 是否是默认展示的字段 isDefault : function(field){ return jQuery.inArray(field, ['x', 'y', 'z']) !== -1; }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d91384a808e5b7ee7515aebee2f7e76/" rel="bookmark">
			3rd-party Gradle plug-ins may be the cause
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kotlin的build.gradle中添加 apply plugin: ‘kotlin-kapt时报错
Folder D:\AndroidProjects\app\build\generated\source\kaptKotlin\debug Folder D:\AndroidProjects\app\build\generated\source\kaptKotlin\release 3rd-party Gradle plug-ins may be the cause 经过多次试验总结出解决办法 首先对照版本号，本文写作日期2018-8-5,可用的版本号为
1. Android studio version 3.1.2 2. gradle plugin version 3.1.2 3. Kotlin version 1.2.30 3. gradle wrapper version 4.4 4. compileSdkVersion 27 5. support:appcompat-v7:27.1.1 其中android studio版本可以在Help-&gt;about中查看，官网下载相应版本 gradle version ，Kotlin version 可以在build.gradle中更改 gradle wrapper在gradle-wrapper.properties中更改，改为 distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-all.zip 记得在build.gradle（app）文件末尾添加 kapt { generateStubs = true }
这步走完依旧报错，呢就再走一步 在Run-&gt;Edit Cofigurations中删除instant Appprovision
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/936d4d2aaa969854b3842d0f1182cd72/" rel="bookmark">
			oracle 数据库 查询获得去重后的所有数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 去重字段，并获得所有数据？
解决： 思路： 对存在重复的数据进行 分组 ，那么对该分组后的数据 按照某一规则排序，取排序的某一数据。
用到 ROW_NUMBER() OVER(PARTITION BY 分组字段 ORDER BY 排序字段 DESC) rownumber(别名) ；
看段代码：
SELECT * FROM (SELECT P.*, ROW_NUMBER() OVER(PARTITION BY P.PRD_ID ORDER BY P.create_tmie DESC) ROWNUMBER FROM PDA_ORDER P ) WHERE ROWNUMBER = 1 row_number() 返回的列 为排序数字 1...n ; 如此 即可查询得到 去重之后的数据 ，去重方法这是其中之一。
作记录总结，错误之处大牛指正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2397523a4144bcdc83b3583904032963/" rel="bookmark">
			Spring REST Docs 构建java项目文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://blog.csdn.net/seanxwq/article/details/78064599
最近因为项目中需要编写接口文档，原来用的swagger结合现有项目问题比较多，且没有直观的目录（不知道swagger是否有左边栏目录这样的形式，没去细查），配合前端和测试使用时，他们抱怨比较多，所以摒弃了swagger之后，找到了spring rest docs， 结合官方文档和网上查到的资料，成功生成了接口文档。样例如下：
spring rest docs的使用其实就是在你现有的spring mvc或spring boot的项目上，配置生成文档的依赖包，然后编写接口单元测试，编写adoc配置文件，最后打包自动生成html接口文档的过程。根据这个步骤一步步操作：
1、配置依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.restdocs &lt;/groupId&gt; &lt;artifactId&gt;spring-restdocs-mockmvc &lt;/artifactId&gt; &lt;scope&gt;test &lt;/scope&gt; &lt;/dependency&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot &lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin &lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.asciidoctor &lt;/groupId&gt; &lt;artifactId&gt;asciidoctor-maven-plugin &lt;/artifactId&gt; &lt;version&gt;1.5.3 &lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;generate-docs &lt;/id&gt; &lt;phase&gt;prepare-package &lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;process-asciidoc &lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;backend&gt;html &lt;/backend&gt; &lt;doctype&gt;book &lt;/doctype&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.restdocs &lt;/groupId&gt; &lt;artifactId&gt;spring-restdocs-asciidoctor &lt;/artifactId&gt; &lt;version&gt;1.2.1.RELEASE &lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin &lt;/artifactId&gt; &lt;version&gt;2.7 &lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-resources &lt;/id&gt; &lt;phase&gt;prepare-package &lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-resources &lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt; ${project.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2397523a4144bcdc83b3583904032963/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fc6124c79538e27e71ba3ec88ba2ddb/" rel="bookmark">
			springMVC拦截器从Request中获取Json格式并解决request的请求流只能读取一次的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在使用SSM（你问我什么叫SSM，我一拳锤爆你的狗头）做开发的时候，经常会使用@RequestBody注解，这个注解是非常的好用。但是如果你想在请求参数传到后台的时候做一个参数检验，当然可以！使用SpringMVC的拦截器，在拦截器里把request的数据读取出来不就行了！！，但是在使用了拦截器的时候会出现一个问题！！！！你在拦截器读取了request的数据，在Controller里面@RequestBody注解获取Json就会失败就读取不到数据！！！！那就是RequestBody是流的形式读取的，流读取一次就没有了！！
为什么使用RequestBody只能读取一遍请求数据流？ 那是因为流对应的是数据，数据放在内存中，有的是部分放在内存中。read 一次标记一次当前位置（mark position），第二次read就从标记位置继续读（从内存中copy）数据。 所以这就是为什么读了一次第二次是空了。 怎么让它不为空呢？只要inputstream 中的pos 变成0就可以重写读取当前内存中的数据。javaAPI中有一个方法public void reset() 这个方法就是可以重置pos为起始位置，但是不是所有的IO读取流都可以调用该方法！ServletInputStream是不能调用reset方法，这就导致了只能调用一次getInputStream()。
解决办法：重写HttpServletRequestWrapper方法 这种方法就是通过重写HttpServletRequestWrapper把request的保存下来，然后通过过滤器保存下来的request在填充进去，这样就可以多次读取request了
1.重写HttpServletRequestWrapper方法
public class RequestWrapper extends HttpServletRequestWrapper { private final String body; public RequestWrapper(HttpServletRequest request) throws IOException { super(request); StringBuilder stringBuilder = new StringBuilder(); BufferedReader bufferedReader = null; try { InputStream inputStream = request.getInputStream(); if (inputStream != null) { bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); char[] charBuffer = new char[128]; int bytesRead = -1; while ((bytesRead = bufferedReader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fc6124c79538e27e71ba3ec88ba2ddb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0122cf2c970b45000195a2a50efcf2c/" rel="bookmark">
			阿里在线测评解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题干： 今天我们看到的阿里巴巴提供的任何一项服务后边都有着无数子系统和组件的支撑，子系统之间也互相依赖关联，
其中任意一个环节出现问题都可能对上游链路产生影响。小明做为新人接收到的第一个任务就是去梳理所有的依赖关系，
小明和每个系统的负责人确认了依赖关系，记录下调用对应系统的耗时，用这些数据分析端到端链路的数目和链路上最长的耗时。
输入： 小明搜集到的系统耗时和依赖列表
5 4 // 表示有5个系统和 4个依赖关系
3 // 调用1号系统耗时 3 ms
2 // 调用2号系统耗时 2 ms
10 // 调用3号系统耗时 10 ms
5 // 调用4号系统耗时 5 ms
7 // 调用5号系统耗时 7 ms
1 2 // 2号系统依赖1号系统
1 3 // 3号系统依赖1号系统
2 5 // 2号系统依赖5号系统
4 5 // 4号系统依赖5号系统
输出: 调用链路的数目 和最大的耗时， 这里有三条链路1-&gt;2-&gt;5，1-&gt;3， 4-&gt;5，最大的耗时是1到3的链路 3+10 = 13，无需考虑环形依赖的存在。
3 13
思路： 一个很不错的题目，不过能在半个小时内做出来还是有点小难度的，主要是用到了一个深搜的思路，将所有依赖关系存在一个map中，从头节点开始向下搜索，有点链表的意思。
每搜到一个尾节点就将结果加1；
代码： #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;stdlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0122cf2c970b45000195a2a50efcf2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8059a0aa538fb6143f041eb98235750c/" rel="bookmark">
			《快学Scala》- 练习题 第十章 特质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题一：定义特质，与类java.awt.geom.Ellipse2D混入问题二：定义特质scala.math.Ordered[Point]问题三：查看BitSet类的线性化规格说明问题四：定义特质scala.math.Ordered[Point]问题五： Java Beans 规范属性变更监听器(property change listener)问题六：Java AWT类库中，Container类问题七：设计Scala特质问题八：设计特质完成java.io.BufferedInputStream修饰器的作用问题九：使用本章的日志生成器特质，给前一个练习中的方案添加日志功能，要求体现出缓冲的效果。问题十：实现一个IterableInputStream类，扩展java.io.InputStream并混入Iterable[Byte]特质 问题一：定义特质，与类java.awt.geom.Ellipse2D混入 // 问题一： // java.awt.Rectangle类有2个很有用的方法translate和grow, // 但可惜的是像java.awt.geom.Ellipse2D这样的类中没有, // 在scala中, 你可以解决掉这个问题, 定义一个RectangleLike的特质, 假如具体的translate和grow方法, // 提供任何你需要用来实现的抽象方法, 以便你可以像如下代码这样混入该特质 val egg = new java.awt.geom.Ellipse2D.Double(5, 10, 20, 30 ) with RectangleLike egg.translate(10, -10) egg.grow(10, 20) trait RectangleLike{ //自身类型，表明该特质只能混入java.awt.geom.Ellipse2D.Double的子类 this : java.awt.geom.Ellipse2D.Double =&gt; translate(x: Double, y: Double){ ... // } grow(x: Double, y: Double){ ... } } 问题二：定义特质scala.math.Ordered[Point] import java.awt.Point /* * 问题二： * 通过把scala.math.Ordered[Point]混入java.awt.Point的方式, 定义OrderedPoint类, * 按辞典方式排序, 也就是说, 如果x &lt; x' 或者x = x'且 y &lt; y' 则 (x,y) &lt; (x', y')则(x,y) &lt; (x',y')。 */ class OrderedPoint extends java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8059a0aa538fb6143f041eb98235750c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/674b46fbbfe692e5846dd90a0d426ab8/" rel="bookmark">
			IPv6，到底是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家都知道5月份的时候工信部印发了 关于贯彻落实《推进IPv6规模部署行动计划》的通知。 通知的具体内容我就不贴出来了，主要意思就是：国家要大力推动IPv6的规模化部署，因此，我们提出了一些具体举措，敦促手机终端、承载网络、数据中心等全面支持IPv6，我们要在这方面领先全世界。。。
那么，问题来了——
什么是IPv6？它有什么特别之处？
为什么国家突然会发文要求推进它？
它对我们的工作生活会造成什么影响？
……
今天，小枣君用这篇文章，给大家做一个“IPv6大揭秘”。 IPv6到底是什么意思？
其实，IPv6并不是一个新鲜事物。早在上个世纪90年代，它就已经诞生了。我相信，从事IT或通信相关工作的人，或多或少听说过它。
IPv6的全称是Internet Protocol version 6。其中，Internet Protocol译为“互联网协议”。所以，IPv6就是互联网协议第6版。 任何网络工作都是基于协议的。协议是网络进行运作的规则和标准。
我们现在所说的上网，就是上“国际互联网（Internet）”。互联网是基于TCP/IP协议族的，而IP是这个协议族中的核心组成部分。 TCP/IP模型对应的协议
IP是网络层协议。它的主要任务，就是根据源主机和目的主机的地址，进行数据的传送。 大家一定经常听说IP地址。是的，IP地址就是IP协议里面的概念。你要联网，就要有IP地址，就像你要寄信，就要有门牌地址一样。 小枣君的IP地址（不要攻击我啊）
既然IPv6是第6版（Version 6），说明在它之前有更老的版本。我们现在广泛使用的，就是IPv4，也就是第4版（Version 4）。 为什么要用IPv6取代IPv4呢？
最主要的原因，就是地址数量不够用了。
IPv4迄今为止已经使用了30多年。最早期的时候，互联网只是设计给美国军方用的，根本没有考虑到它会变得如此庞大，成为全球网络。
尤其是进入21世纪后，随着计算机和智能手机的迅速普及，互联网开始爆发性发展，越来越多的上网设备出现，越来越多的人开始连接互联网。这就意味着，需要越来越多的IP地址。 根据互联网数据研究机构的统计，全世界 76 亿人口，网民总数已经超过了 40 亿（2018年1月）。
IPv4到底一共有多少个IP地址呢？答案是2的32次方，也就是约42.9亿个。 所以说，IPv4地址池接近枯竭，根本无法满足互联网发展的需要。人们迫切需要更高版本的IP协议，更大数量的IP地址池。（有点像固定电话号码升位。）
其实地址不够的问题，并不是这几年才发现的。
早在1990年，IETF（互联网工程任务小组，成立于1985年底，是全球互联网最具权威的技术标准化组织）就开始规划IPv4的下一代协议。他们还建立了IPng（下一代IP），拉了一帮人，专门推进相关工作。 1994年，各IPng的代表们于多伦多举办的IETF会议中，正式提议IPv6发展计划。 该提议直到同年的11月17日才被认可，并于1996年8月10日成为IETF的草案标准。
1998年12月，IPv6被IETF正式推出，也就是互联网标准规范RFC2460。
2003年1月22日，IETF发布了IPv6测试性网络，即6bone网络。
随着十多年的发展，IPv6已经被很多通信网络和终端设备厂商支持，取得了长足的进步。
以我们用的最多的windows电脑操作系统来说，从Windows 2000开始，就已经支持IPv6了。到Windows XP时，进入了产品完备阶段。而Windows Vista及以后的版本，如Win7、Win8、Win10等，都已经完全支持IPv6。 Win10中的IPv6选项
2012年6月6日，国际互联网协会专门举行了“世界IPv6启动纪念日”。这一天，多家知名网站（如Google、Facebook和Yahoo等）正式开始永久性支持IPv6访问。 IPv6会带给我们什么？
首先，最重要的一点，就是前面所说的地址池扩容。
IPv4的地址池是约42.9亿，IPv6能达到多少呢？
数量如下——
340282366920938463463374607431768211456个…
不用数了，数到后面脑子就会秀逗了…
简单说，是2的128次方。 这个数量，即使是给地球上每一颗沙子都分配一个IP，也是妥妥够用的。（沙子表示一脸懵逼~ ）
这个数量值是怎么得来的呢？还是它的地址位长决定的。
如果以二进制来写，IPv6的地址是128位。不过，这样写显然不太方便（一行都写不下）。所以，通常用十六进制来写，也就缩短成32位。 32位会分为8组，每组4位。
所以，下面这样的，就是一个标准的、合法的IPv6地址示例：
2001:0db8:85a3:08d3:1319:8a2e:0370:7344
注意啦！IPv6的地址是可以简写的！每项数字前导的0可以省略。
例如，下面这个地址：
2001:0DB8:02de:0000:0000:0000:0000:0e13
加粗的“0”，就可以省略，变成：
2001:DB8:2de:0:0:0:0:e13
更进一步的，如果有一组或连续几组都是0，那么可以简写成“::”，也就是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/674b46fbbfe692e5846dd90a0d426ab8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8f511f128b2f99665e8634a05c335e7/" rel="bookmark">
			Android问题集锦（十四）- The option &#39;android.enableAapt2&#39; is deprecated and should not be used anymore.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天在升级到Android studio3.1后，编译运行程序报以下异常：
在Java compiler已经有很明显的警告提示了： The option 'android.enableAapt2' is deprecated and should not be used anymore. Use 'android.enableAapt2=true' to remove this warning. It will be removed at the end of 2018..
意思就说android.enableAapt2已经被弃用了，不能被使用了。可以使用android.enableAapt2=true去除该警告，再clear build重新运行程序即可。
参考：
https://stackoverflow.com/questions/49534951/aapt2-working-abnormally-in-android-studio-3-1-both-for-true-and-false-flag 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/625f884107e5c2589045d32a5ff3e07f/" rel="bookmark">
			Fullnat的环境搭建和负载均衡配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FullNAT: 除了DR/NAT/TUNNEL之外IPVS下的新的包转发模式，解决了DR/NAT/TUNNEL中的一些缺点（如不能跨vlan或者跨vlan成本太高，服务搭建较复杂，不易运维等）。
Fullnat主要实现的功能：
1.数据包从外部进来的时候，目标ip更换为realserver ip，源ip更换为内网local ip；
2.数据包发送出去的时候，目标ip更换为client ip，源ip更换为vip；
Fullnat的转发模式：
Fullnat实现原理：
Fullnat虚拟服务的实现：
一 服务安装(为了解释说明，本文所有安装包和压缩包都放在了/mnt目录下）：
1. 首先将作为VS的server1端的ram改成2048或者更大，否则内存不够会报错。
2. 准备安装包：
3. 安装rpm-build服务用来编译内核的源码包，安装kernel包：
这两步完成之后，会在/root目录下生成一个rpmbuild的目录，进入这个目录中的子目录SPECS，里面有一个kernel.spec文件：
4. 执行指令rpmbuild -bp kernel.spec编译这个内核文件，执行时会有许多依赖性的包，将这些包全部安装：
对于asciidoc和newt-devel两个安装包需要另外自行下载，yum源里没有：
5 安装asciidoc,alang-devel,newt-devel ：
6. 安装之后重新编译内核文件：
这时会卡住，需要安装rng-tools来加快进度：yum install rng-tools -y,之后执行rngd -r /dev/urandom指令。
7. 打补丁：
准备Lvs-fullnat-synproxy.tar.gz包并解压将里面的lvs-2.6文件复制到指定目录，进入该指定目录执行56行指令打补丁。
8. 补丁完成之后直接make进行编译，编译过程比较久。
9. 编译完成之后，执行命令 make modules_install，然后make install
10.进入/boot/grub目录，编辑grub.conf文件，将文件中的default 1改为default 0，之后reboot重启。
11. yum remove ipvsadm删除原有的ipvsadm ，进入到/mnt/lvs-fullnat-synproxy/目录，将zxf lvs-tools.tar.gz安装包解压。
12. 进入/mnt/lvs-fullnat-synproxy/tools/keepalived目录，执行指令 ./configure --with-kernel-dir="/lib/modules/`uname -r`/build" 进行编译。如果出现popt的依赖性问题，yum install popt-devel 解决依赖性问题之后，重新执行编译指令./configure --with-kernel-dir="/lib/modules/`uname -r`/build"。没有报错的话，执行make之后make install
13. 进入/usr/local/sbin/lvs-fullnat-synproxy/tools/ipvsadm目录下，进行make和make install编译，这个过程中会安装ipvsadm。这样fullnat的环境就搭好了。ipvsadm -l会看到size=41944304即2的22次方：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/625f884107e5c2589045d32a5ff3e07f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4d0a6aa5178d1ffac86b58c5def4c32/" rel="bookmark">
			Deep Learning Object Detection
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 图像分类和目标识别的区别
分类（左）和目标检测（右）之间的差异是直观和直接的。对于图像分类，将整个图像分类为单个标签。在对象检测的情况下，我们的神经网络定位图像中的（潜在多个）对象。
因此，我们可以认为图像分类为：
一个图像 一类标签（整幅图像）
对象检测：不管是否通过深度学习或其他计算机视觉技术来执行，都建立在图像分类上，并试图精确地定位图像中每个对象出现的位置。
当执行对象检测时，给定输入图像，我们希望获得：
1.一个包围盒的列表，或图像中每个对象的（x，y）坐标
2.与每个边界框关联的类标签
3.与每个边界框和类标签相关联的概率/置信分数
方法一：传统的目标检测流程
该方法不完全是端对端的深度学习目标检测
1.固定大小的滑动窗口，从左到右，从上到下滑动以定位不同位置的对象。
2.在不同尺度下检测物体的图像金字塔
3.基于预训练（分类）卷积神经网络的分类
在每一步的滑动窗口+图像金字塔，都需要提取ROI，将它输入到CNN，输出为ROI的分类。
如果标签L的分类概率高于某个阈值T，则将ROI的包围盒标记为标签（L）。每一个滑动窗口和图像金字塔都重复这个过程，我们得到输出对象检测器。最后，我们将非极大值抑制应用于产生最终输出检测的边界框：
一般这样的方法慢且容易出错。然而，值得学习的是如何应用这种方法，因为它可以将任意的图像分类网络转换成对象检测器，避免了需要明确地训练端到端的深度学习对象检测器。
方法2：
对象检测框架的基本网络
深度学习对象检测的第二种方法在深度学习对象检测框架（faster-RCNN、SSD或YOLO）中处理预先训练的分类网络作为基础网络。
好处是可以创建一个完整的端到端的基于深度学习的对象检测器。
缺点是它需要对学习对象探测器的工作有多深的了解——我们将在下一节中对此进行更多的讨论。
深度学习对象检测器的组件
未完待续...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fa70a81db42cfe52dce06507d262be6/" rel="bookmark">
			傻瓜都能看懂的高并发量服务器架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/daogla/article/details/72877153
服务器架构，说简单不简单，说复杂不复杂，前段时间我们请到了国内服务器顶级攻城狮，他把服务器那点事讲得如此通透简单。
对于一个刚起步的创业公司，不需要考虑太多复杂的服务器架构，能把业务跑起来就行了。但是在早期业务逻辑设计时，懂一些稍微复杂的服务器架构的逻辑，后面可以少走很多弯路。
下面这个图估计大家都明白，这就是最基础的服务器架构。傻瓜式的方法是把应用服务器、文件服务器、数据库服务器全部混合在一起，呵呵呵！但这并不是最科学的。
当业务量持续增加到一定量以后，执行应用程序、读写文件、访问数据库应该有所区分，保证各自的需求都能得到满足，这时候你需要考虑把应用服务器、文件服务器、数据库服务器分离，这个时候的服务器架构应该是下面这样的，它是由三个独立的服务器组成，各司其职。
随着业务量持续增加，应用程序访问缓存数据会成为瓶颈，这个时候需要增加本地缓存，有的也需要分布式缓存。分布式缓存是指缓存部署在多个服务器组成的服务器集群中，以集群的方式提供缓存服务，其架构方式主要有两种，一种是以JBoss Cache为代表的需要同步更新的分布式缓存，一种是以Memchached为代表的互不通信的分布式缓存。如下图：
接下来，应用服务器需要更多台以应对复杂的业务逻辑，那么就需要负载均衡调度服务器来调度和分配应用服务器的工作任务。
再往后，需要考虑数据库服务器的承压能力，通常可以采用主从式数据库服务器架构，把读、写两部分分开，既可以提高数据访问的安全性，也能提高数据读写的效率。
随着业务量暴增，单一区域的服务器带宽将不能承载全国的业务需求，这时候需要增加反向代理和CDN服务器。CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。
同样，服务器架构师应该分析文件服务器和数据库服务器的网络读写速度，进一步部署分布式的架构。
对于有搜索和大量查询的网络业务，还需要增加独立的搜索引擎和NoSQL服务器。
对于更复杂的系统，还需要进一步拆分应用服务器，增加消息队列服务器。增加消息队列服务器有以下几点好处：
1，由于消息队列服务器的速度远远高于数据库服务器，所以能够快递处理并返回数据；
2，消息队列服务器具有更好的扩展性；
3，在高并发的情况下，延迟写入数据库，可以有效降低数据库的压力。
对于一些超大型综合互联网业务，应用服务器也需要分布式的架构，这个时候在不同业务的应用服务器之间做好消息协同会有较大的挑战。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8469a17cb1ede5cda6d7bd11898f576/" rel="bookmark">
			台阶问题（动态规划）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 台阶问题 题目描述 有N 级的台阶，你一开始在底部，每次可以向上迈最多K 级台阶（最少1 级），问到达第N 级 台阶有多少种不同方式。
输入 多组输入,两个正整数N(N ≤ 1000)，K(K ≤ 100)。
输出 一个正整数，为不同方式数，由于答案可能很大，你需要输出ans mod 100003 后的结果。
输入样例 5 2
输出样例 8 12
思路：N阶台阶每次可以上0-k阶，那么第k阶台阶有1-k种到达的方法，所以到达N阶的种数等于到达第N-1阶的种数加上到第N-2阶的种数······加上到达第N-k阶的种数。
#include&lt;cstdio&gt; #include&lt;cstring&gt; int a[1000+10]; int main() { int n,k; while(~scanf("%d%d",&amp;n,&amp;k)){ memset(a,0,sizeof(a)); a[0]=1; for(int i=1;i&lt;=1000;i++){ for(int j=1;j&lt;=k&amp;&amp;(i-j)&gt;=0;j++){ a[i]+=a[i-j]; a[i]%=100003; } } printf("%d\n",a[n]); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/720f0705b56f596a0d9564ed93f779f4/" rel="bookmark">
			高性能后台服务器架构设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：http://blog.sina.com.cn/s/blog_3fba24680102vpvx.html
如何设计高性能的大型网站系统？在移动互联网时代，客户端应用开发本身，并不是体验的决胜之处，真正对团队挑战的地方，还在于后端，无论是承压能力，还是安全性等方面，如果这些地方过不了关，整个应用的基础是不扎实的。
提高服务器性能最简单粗暴的方式，就是增加机器和升级硬件配置。虽然现在的硬件越来越便宜，但是一味地通过增加机器来解决并发量的增长，成本是非常高昂的。结合技术优化方案，才是更有效的解决方法。
一、web端性能
这几年，用户数量并没有出现指数增长，而并发连接数呈指数增长的主要原因是：1、Web页面元素越来越多，更为丰富；2、主流的本浏览器的预加载功能。
（1）、建立长连接。减少反复的创建和销毁连接行为。但是，连接的保持是会占用Web系统服务端资源的，如果不充分使用这个连接，会导致资源浪费。
（2）、通过缓存减少Web请求。通过Http协议头中的expire或max-age来控制，将静态内容放入浏览器的本地缓存。但是，这种方案，对首次访问的用户无效，同时，也影响部分Web资源的实时性。
（3）、通过版本号减轻Web请求。协商方式是通过Http协议的Last-Modified或Etag来控制，这个时候请求服务器，如果是内容没有发生变更的情况，服务器会返回304 Not Modified。但是，，但是连接仍然被建立，请求也发生了。
（4）、合并页面请求。1、合并HTML展示内容。将CSS和JS直接嵌入到HTML页面内，不通过连接的方式引入。2、Ajax动态内容合并请求。对于动态内容，将10次Ajax请求合并为1次的批量信息查询。3、小图片合并，通过CSS的偏移量技术Sprites，将很多小图片合并为一张。4、压缩css，js，图片的大小。
（5）、页面静态化。页面上的大部分内容在很长一段时间内，可能都是没有变化的。例如一篇新闻报道，一旦发布几乎是不会修改内容的。这样的话，通过CGI生成的静态html页面缓存到web服务器的磁盘本地。
二、app端性能。
（1）图片三步加载。从内存、磁盘、网络三个方面上进行三级缓存的实现。1、在加载一张图片的时候，先查看内存是否有该图片的缓存，若无，再查看磁盘时候有该图片的缓存，若无，才从网络中加载；2、在网络加载完成之后，需要把图片加进到内存和磁盘缓存中；3、根据LRU调度方式对缓存进行管理。
（2）预加载技术。基于历史浏览记录和对该网页的安全性判断，在你没点击请求之前，预先加载这个数据。
（3）路由计划表。对用户每天登陆的上网行为和不同行为连接哪个机房，做了一个路由计划表，推送到客户终端上。当用户的网络发生切换，我们就知道这个网络情况下他应该连到哪里最快。
（4）上传加速。在全国部署了超过70个上传加速节点，让每个用户都会选择他最近的上传节点上传他的图片。同时有启用多端口、多连接的上传加速能力，可以尽可能的用尽网络资源，而不是说在一个连接上不停的等待数据包的重传等各方面的东西。
三、带宽
计算带宽要涉及到两个指标(页面平均大小、全天pv), 可以从access日志统计到详细数据。平均流量 = (全天pv/(24*60*60)) * 页面平均大小。峰值流量 = 平均流量 * 5。需购买的带宽等于峰值流量。
但是活动日的峰值流量远不止这个数。2015年微信红包除夕摇一摇总次数110亿次，峰值1400万次/秒。应对活动日，需提前在活动当天CDN将准备数百G带宽应对。
四、后台性能。
大型网站不是设计出来的，而是逐步演化出来的。因为互联网发展运行有其自己的规律，互联网历史已经一再证明“一开始就把网站设计成大型的”这种企图行不通。另外，演化过程中，需要分清当前哪个点是瓶颈，需要知道哪个点优化的优先级最高。所以，技术架构的演进不一定就是按文章从头到尾这样列下来的，要视具体情况来下决定。
从一个小网站说起，一台服务器也就足够了。演进包括如下：
（1） 数据服务器和应用服务器分离。给应用服务器配置更好的 CPU，内存。而给数据服务器配置更好更大的硬盘。
（2）使用缓存。因为 80% 的业务访问都集中在 20% 的数据上，如果我们能将这部分数据缓存下来，性能一下子就上来了。空数据也要入缓存，否则会增加数据库的压力。
（3）nosql。NoSql数据库大量应用于微博系统等事务性不强的系统。如：BigTable、MongoDB （4）服务器集群。需要考虑：负载均衡问题? 负载均衡调度服务器，如nginx。Session 的管理问题。如何让上传文件这些类似的功能继续正常？采用文件服务器统一管理。
（5）数据库读写分离。订阅和发布。实现一个数据访问模块使上层写代码的人不知道读写分离的存在。需要考虑：时延问题。MySQL数据同步是通过binlog日志。延迟问题通过水平拆分服务来提高性能、多线程同步解决。
（6）数据库拆分。垂直拆分数据库时，会遇到的问题：跨业务的事务，应用的配置项多了。数据水平拆分会遇到的问题：SQL 的路由问题，需要知道某个 User 在哪个数据库上。主键的策略会有不同。查询时的性能问题，如分页问题。
（7）CDN。分布式文件系统使用 CDN 。将网站的内容发布到最接近用户的网络”边缘”，使用户可以就近取得所需的内容，解决Internet网络拥塞状况，提高用户访问网站的响应速度。据统计，采用CDN技术，能处理整个网站页面的 70%～95％的内容访问量，减轻服务器的压力，提升了网站的性能和可扩展性。异地部署一般遵循：核心集中，节点分散。如：网宿、睿江、蓝讯，将网站内容同步到全国CDN节点，客户就近访问CDN服务器。
（8）分布式拆分。网站的业务日益复杂，建立一个独立的大型应用来完成这所有的业务变得不实际。从管理角度来，也不方便管理。将系统根据职责进行拆分，同时也能采用大量的廉价机器来支撑着巨大的访问量和数据量。微服务架构的优势很明显：耦合度低、技术选型灵活、发布更加高效、故障隔离。拆分会碰到很多的挑战：1、拆成分布式后需要提供一个高性能、稳定的通信框架，并且需要支持多种不同的通信和远程调用方式；2、将一个庞大的应用拆分需要耗费很长的时间，需要进行业务的整理和系统依赖关系的控制等；3、如何运维（依赖管理、运行状况管理、错误追踪、调优、监控和报警等）好这个庞大的分布式应用。
（9）大系统小做。将功能复杂较大的系统，化大为小，减少模块耦合，降低关联性。分成一个个高度自制的小系统，形成高内聚低耦合的格局，每个模块之间不会过分依赖对方，这样的好处是不会因为任何一个模块而影响全部服务，避免牵一发动全身的风险，实现真正的灰度服务。 （10） 硬件负载均衡。一台Nginx服务器的软负载已经无法承担巨大的web访问量了，可以用硬件负载解决F5或应用从逻辑上做一定的分类，然后分散到不同的软负载集群中。
五、业务方式
有些问题用技术手段并不比用业务手段更有效。12306 的分时卖票就是一个典型例子。
（1）前端缓冲请求。比方说在接入层置入摇红包逻辑，将每秒千万级请求转化为每秒万级的红包请求，再传到红包服务的后端逻辑，降低雪崩的可能性。
（2）后端采用异步分拆。耗时最长的入账操作，直接跳过，异步处理。如：“当前人数较多，收到的红包将稍后入账零钱”
（3）快速拒绝。在客户端的版本更新中，将相关的指令和策略埋入，当接受数据获取异常时，在客户端自动就降低请求频率，比如一次请求失败，用户肯定想二次再刷，但是可能实际上没有向后端请求，而是直接返回，请客户稍安勿躁，如果不提前埋入，到有问题时才处理是来不及的。
（4）流量预加载。从客户端入手，将语音图片等极消耗流量的资源提前让客户端自动下载预置好，提前将流量洪峰疏导。
（5）资源隔离。避免任意一个支路出问题影响整个服务链条，这样即使部分服务出现问题也不会影响到整个服务的崩塌。
（6）根据业务场景降低图片质量。1、针对不同终端，下载不同质量图片。2、研究新的编码格式，使得图片在基本同等质量情况下再下降30%。3、应用一些渐进式的传输技术，你会首先看到模糊的图，一会儿清晰的图就会出现。
（7）回滚机制会造成业务逻辑复杂，容易出错，可能会出现漏洞。我们应该提高服务的简单性、高可用性，减少出错率。对于极少的错误，后续对日志进行单独处理即可。
六、最大连接数限制
（1）全程压测流程，对整个业务链接进行自动提前评估，防止过载。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/720f0705b56f596a0d9564ed93f779f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c37aea86ec7ca6ec1323cdf28bd72a3e/" rel="bookmark">
			设计模式（一）--单例模式和原型模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设计模式的分类 总体来说设计模式分为三大类
创建型（5种）：主要用于处理对象的创建，实例化对象： 单例，建造者，原型，工厂方法，抽象工厂
结构型（7种）：处理类或对象间的组合 适配器，装饰者，结合，桥接，外观，享元，代理
行为型（11种）：描述类或对象怎样进行交互和职责分配 策略，观察者，迭代器，命令，备忘录，中介者，解释器，访问者，责任链，状态，模板方法
二、设计模式的介绍 1、 单例模式 单例模式作用，保证类在内存中的对象唯一性。 适用场景： 资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置控制资源的情况下，方便资源之间的互相通信。如线程池等。 饿汉与懒汉的区别 前者在类装载时就实例化，后者只有在第一次被使用时才实例化。 (饿汉的优点是避免线程同步问题，缺点是即使没用到这个实例还是会加载) (懒汉的优点是实现了懒加载，但需要解决线程安全问题！)
1&gt; 饿汉式，没有实现懒加载~
public class Singleton() { private static Singleton instance = new Singleton(); private Singleton(){ } public static Singleton getInstance() { return instance; } } //获取单例对象 Singleton mSingleton = Singleton.getInstance(); 2&gt; 懒汉，不加锁 线程非安全的
public class Singleton { private static Singleton instance = null; private Singleton() { } private static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } 3&gt; 懒汉，加锁
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c37aea86ec7ca6ec1323cdf28bd72a3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0788868f7b292d9dac9e9e12abc776da/" rel="bookmark">
			Vim查找命令及快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**Vim查找命令及快捷键
**
一、通过指令查找
1、左斜杠/ 从光标所在位置向文件尾搜索
例：／hello
2、问号？　从光标所在位置向文件头搜索
例：？hello
注：／和？均可加参数做指定查找（两者搜索方向不同，此处以／举例进行说明）
１）　&lt;匹配单词的开头　\&gt;匹配单词的结尾
例:　&lt; hel 可以找到所有以hel开头的单词 （此处为了编辑方便我在&lt;和hel中加了空格，实际不应有此空格）
\&gt;llo 可以找到所有以llo结尾的单词
&lt; for&gt;可以找到所有的for单词，forever中的for不会被找到 （此处为了编辑方便我在&lt;和for中加了空格，实际
不应有此空格）
２）　＾代表行首　＄代表行尾
例:　＾hello 只会匹配行首的hello
$hello 只会匹配行尾的hello
另：按"n"或者“N”可对找到的词进行后一个或者前一个的跳转
二、通过快捷键查找
1、#　开始向文件头的方向搜索光标所在位置的单词的下一个出现位置
2、*　开始向文件尾的方向搜索光标所在位置的单词的下一个出现位置
另：被查找到的单词会高亮显示，如想要去除该高亮显示，可使用命令 ：nohl （即no high light的意思）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14bc9b396e4e06c5cbc1e3c25fcb1e78/" rel="bookmark">
			Flash芯片总述及SLC、MLC、TLC和QLC的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NOR Flash 和 NAND Flash是现在市场上两种主要的非易失闪存技术。Intel于1988年首先开发出NOR Flash 技术，彻底改变了原先由EPROM(Electrically Programmable Read-Only-Memory电可编程序只读存储器)和EEPROM(电可擦只读存储器Electrically Erasable Programmable Read – Only Memory)一统天下的局面。紧接着，1989年，东芝公司发表了NAND Flash 结构，强调降低每比特的成本，有更高的性能，并且像磁盘一样可以通过接口轻松升级。NOR Flash 的特点是芯片内执行（XIP ，eXecute In Place），这样应用程序可以直接在Flash闪存内运行，不必再把代码读到系统RAM中。NOR 的传输效率很高，在1~4MB的小容量时具有很高的成本效益，但是很低的写入和擦除速度大大影响到它的性能。NAND的结构能提供极高的单元密度，可以达到高存储密度，并且写入和擦除的速度也很快。应用NAND的困难在于Flash的管理和需要特殊的系统接口。通常读取NOR的速度比NAND稍快一些，而NAND的写入速度比NOR快很多，在设计中应该考虑这些情况。
NAND Flash根据存储原理分为三种，SLC、MLC、TLC。
什么是SLC？SLC英文全称(Single Level Cell——SLC)即单层式储存 。主要由三星、海力士、美光、东芝等使用。
SLC技术特点是在浮置闸极与源极之中的氧化薄膜更薄，在写入数据时通过对浮置闸极的电荷加电压，然后透过源极，即可将所储存的电荷消除，通过这样的方式，便可储存1个信息单元，这种技术能提供快速的程序编程与读取，不过此技术受限于Silicon efficiency的问题，必须要由较先进的流程强化技术(Process enhancements)，才能向上提升SLC制程技术。
什么是MLC？MLC英文全称（Multi Level Cell——MLC)即多层式储存。主要由东芝、Renesas、三星使用。
MLC是英特尔（Intel）在1997年9月最先研发成功的，其原理是将两个位的信息存入一个浮动栅（Floating Gate，闪存存储单元中存放电荷的部分），然后利用不同电位（Level）的电荷，透过内存储存格的电压控制精准读写。MLC通过使用大量的电压等级，每个单元储存两位数据，数据密度比较大。SLC架构是0和1两个值，而MLC架构可以一次储存4个以上的值，因此，MLC架构可以有比较好的储存密度。讲白话点就是一个Cell存放多个bit，现在常见的MLC架构闪存每Cell可存放2bit，容量是同等SLC架构芯片的2倍，目前三星、东芝、海力士（Hynix）、IMFT(英特尔与美光合资公司)、瑞萨（Renesas）都是此技术的使用者，而且这个队伍还在不断壮大，其发展速度远快于曾经的SLC架构。
与SLC比较MLC的优势：鉴于目前市场主要以SLC和MLC储存为主，我们多了解下SLC和MLC储存。SLC架构是0和1两个值，而MLC架构可以一次储存4个以上的值，因此MLC架构的储存密度较高，并且可以利用老旧的生产程备来提高产品的容量，无须额外投资生产设备，拥有成本与良率的优势。与SLC相比较，MLC生产成本较低，容量大。如果经过改进，MLC的读写性能应该还可以进一步提升。与SLC比较MLC的缺点：MLC架构有许多缺点，首先是使用寿命较短，SLC架构可以写入10万次，而MLC架构只能承受约1万次的写入。其次就是存取速度慢，在目前技术条件下，MLC芯片理论速度只能达到6MB左右。SLC架构比MLC架构要快速三倍以上。再者，MLC能耗比SLC高，在相同使用条件下比SLC要多15%左右的电流消耗。虽然与SLC相比，MLC缺点很多，但在单颗芯片容量方面，目前MLC还是占了绝对的优势。由于MLC架构和成本都具有绝对优势，能满足2GB、4GB、8GB甚至更大容量的市场需求。
什么是TLC？ TLC = Triple-Level Cell，即3 bit per cell架构。TLC芯片技术是SLC和MLC技术的延伸，最早期NAND Flash技术架构是SLC(Single-Level Cell)，原理是在1个存储器储存单元(cell)中存放1位元(bit)的资料，直到MLC(Multi-Level Cell)技术接棒后，架构演进为1个存储器储存单元存放2位元。 2009年TLC架构正式问世，代表1个存储器储存单元可存放3位元，成本进一步大幅降低。如同上一波SLC技术转MLC技术趋势般，这次也是由NAND Flash大厂东芝(Toshiba)引发战火，之后三星电子(Samsung Electronics)也赶紧加入战局，使得整个TLC技术大量被量产且应用在终端产品上。TLC芯片虽然储存容量变大，成本低廉许多，但因为效能也大打折扣，因此仅能用在低阶的NAND Flash相关产品上，象是低速快闪记忆卡、小型记忆卡microSD或随身碟等。智能型手机(Smartphone)、固态硬碟(SSD)等技术门槛高，对于NAND Flash效能讲求高速且不出错等应用产品，则一定要使用SLC或MLC芯片。
根据NAND的物理结构，NAND是通过绝缘层存储数据的。当你要写入数据，需要施加电压并形成一个电场，这样电子就可以通过绝缘体进入到存储单元，此时完成写入数据。如果要删除存储单元（数据），则要再次施加电压让电子穿过绝缘层，从而离开存储单元。所以，NAND闪存在重新写入新数据之前必须要删除原来数据。
由于数据写入到TLC中需要八种不同电压状态， 而施加不同的电压状态、尤其是相对较高的电压，需要更长的时间才能得以实现（电压不断增高的过程，直到合适的电压值被发现才算完成）。
所以，在TLC中数据所需访问时间更长，因此传输速度更慢。经过实测，同等技术条件下，TLC的SSD性能是比不上MLC SSD的。
什么是QLC？ QLC = Quad-Level Cell架构，即4bit/cell，支持16充电值，速度最慢寿命最短，目前中技术上在研发阶段，但是intel、三星电子等厂商都已经取得了不错的进展。但在SSD应用中目前仍不现实 。
需要说明的闪存的寿命指的是写入(擦写)的次数，不是读出的次数，因为读取对芯片的寿命影响不大。下面是SLC、MLC、TLC、QLC闪存芯片的区别：
SLC = Single-Level Cell，即1bit/cell，利用正、负两种电荷，一个浮动栅存储1个bit的信息，约10万次擦写寿命。速度快，寿命长，价格贵（约MLC 3倍以上的价格）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14bc9b396e4e06c5cbc1e3c25fcb1e78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68174faf7be760746e0d94ab6797c1b8/" rel="bookmark">
			Ubuntu下创建新用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组里的服务器是Ubuntu系统，跑实验的话需要远程访问，这样的话需要在服务器上创建一个自己的账户，本文记录一下在Ubuntu系统下创建新用户的过程。（服务器的远程访问一般通过ssh来实现，关于ssh的使用可以参见Ubuntu下的SSH。）
本文主要包含两部分内容： 1. 新建一个用户 2. 允许该用户以管理员身份执行命令（在使用服务器的时候，不建议给予普通用户管理员权限） 注：本文基于Ubuntu系统的主机名为HPZ640-1，用户名为mqk，进行创建与删除的新用户名为tt
1. 创建用户 创建用户有两条命令：adduer和useradd，对应着两条删除用户的命令：deluser和userdel。 这两种命令之间的区别： adduser：会自动为创建的用户指定主目录、系统shell版本，会在创建时输入用户密码。 useradd：需要使用参数选项指定上述基本设置，如果不使用任何参数，则创建的用户无密码、无主目录、没有指定shell版本。
1.1 adduser 输入命令：mqk@HPZ640-1:~$ sudo adduser tt 输出显示：
[sudo] password for mqk: 正在添加用户"tt"... 正在添加新组"tt" (1006)... 正在添加新用户"tt" (1006) 到组"tt"... 创建主目录"/home/tt"... 正在从"/etc/skel"复制文件... 输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：已成功更新密码 正在改变 tt 的用户信息 请输入新值，或直接敲回车键以使用默认值 全名 []: 房间号码 []: 工作电话 []: 家庭电话 []: 其它 []: 这些信息是否正确？ [Y/n] y 这样在创建用户名时，就创建了用户的主目录以及密码。
默认情况下： adduser在创建用户时会主动调用 /etc/adduser.conf； 在创建用户主目录时默认在/home下，而且创建为 /home/用户名 如果主目录已经存在，就不再创建，但是此主目录虽然作为新用户的主目录，而且默认登录时会进入这个目录下，但是这个目录并不是属于新用户，当使用userdel删除新用户时，并不会删除这个主目录，因为这个主目录在创建前已经存在且并不属于这个用户。
为用户指定shell版本为：/bin/bash 因此常用参数选项为：
–home： 指定创建主目录的路径，默认是在/home目录下创建用户名同名的目录，这里可以指定；如果主目录同名目录存在，则不再创建，仅在登录时进入主目录。–quiet： 即只打印警告和错误信息，忽略其他信息。–debug： 定位错误信息。–conf： 在创建用户时使用指定的configuration文件。–force-badname： 默认在创建用户时会进行/etc/adduser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68174faf7be760746e0d94ab6797c1b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b9ed1e424d490c8043979db02a95a00/" rel="bookmark">
			3DMAX 解决3DMax中处理模型attach操作卡顿问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3DMax做高精度模型，做CAD等导出模型，减面合并操作时，经常性的出现3Dmax attach操作卡顿现象
1.打开任务管理器，查看实时的cpu 、 内存占用，把与开发无关一些高占用程序关闭
2.设置显卡，右键Nivida控制面板，3D设置，配置surround /Physx中的PhysX改为计算的显卡。
管理3D设置中，程序设置，选择3Dmax，分别如图设置
通过预览调整图像设置 ，使用我的优先选择，侧重于 ：性能，或者平衡
3.3dMax中设置，自定义 - 首选项 - 视口 - 显示驱动程序 - 选择驱动程序为本电脑显卡驱动程序（DX11最好）
如图，英文版位置相同
4.以上，如果还是卡，3Dmax中选择Maxscript，MaxScript 侦听器/Listener
打开的面板中，输入
gc() 回车
freescenebitmaps() 回车
clearundobuffer() 回车
一般只需要输入前两行代码，即可
来自官网翻译解释：
3ds Max变慢 在扩展会话中，特别是在您创建渲染或使用位图材质进行广泛处理的会话中，3ds Max可能因内存分配而变得迟缓。在关闭并重新启动3ds Max会话之前，您可以尝试一些释放内存的MAXScript函数：
gc() 运行垃圾收集例程。
freescenebitmaps() 释放分配给位图的内存。
clearundobuffer() 清除撤消/重做缓冲区。在调用此功能之前，请确保场景符合您的要求！
只需在3ds Max窗口左下角的MAXScript Mini Listener中输入MAXScript函数调用即可。
链接：http://help.autodesk.com/view/3DSMAX/2018/ENU/?guid=GUID-5704C695-6270-4273-B178-88DA8E26689D
建议大家，多看看文档，英文看不懂，有google翻译，网页插件一键翻译，
官方论坛也需要经常查看搜索，这里既包括程序，而且美术人员也应该多了解下
以上总结几种处理3Dmax变慢方法，最主要还是开发硬件高配置，以后会总结更多优化等方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab573b4d353a4540d29281a1de29ca0a/" rel="bookmark">
			《区块链100问》第31-40节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请注明出处：https://blog.csdn.net/sinat_14849739/article/details/81276824 本文出自Shawpoo的专栏 我的简书：简书
1、竞争记账是什么？ 竞争记账是比特币系统的记账方式，它解决了如何在去中心化的记账系统中，保证比特币账本一致性的问题。比特币系统中没有中心化的记账机构，每一个节点都有记账权，如何保证账本一致性是一个重要的问题。在比特币网络中，全网矿工共同参与算力竞争，算力高的矿工计算能力更强，更容易获得记账权。成功抢到记账权的矿工负责记账，并将账本信息同步给整个网络。作为回报，矿工将获得系统新生成的比特币奖励。随着比特币价格上涨，为了获得比特币，越来越多人参与竞争比特币记账权，全网算力难度呈指数级上升。
2、如何投资区块链资产？ 从 2008 年中本聪发布比特币白皮书至今，区块链资产的种类日益增加，投资方式也更加丰富。2009 年比特币刚诞生那会儿，投资者以极客为主，但是，随着更多专业投资者的加入，区块链资产的投资方式更加丰富。目前，投资者参与区块链资产投资的渠道很多：场内交易、场外交易、中心化交易平台、去中心化交易平台都可以进行投资，不仅投资渠道变多了，投资方式也更丰富了，投资者可以通过趋势交易、对冲、跨平台搬砖等交易方式投资获利。
3、如何在交易平台投资区块链资产？ 相较于点对点交易、挖矿等，在交易平台购买是目前获得区块链资产最主流的方式，即场内交易。区块链资产的场内交易和股票类似，由平台帮你撮合，你不知道也不需要知道跟你成交的对手是谁，你的成交对手有可能是一个人，也有可能是很多人。无论是买入还是卖出，交易平台会记录所有人的挂单价格，买卖双方通过实时买卖盘可以获取最新成交价格。同时，交易平台会将历史成交价格及成交量汇总成K线图，方便投资者用于分析行情走势。
4、量化交易是什么？ 量化交易，有时候也称自动化交易，是指以先进的数学模型替代人为的主观判断，极大地减少了投资者情绪波动的影响，避免在市场极度狂热或悲观的情况下做出非理性的投资决策。量化交易有很多种，包括跨平台搬砖、趋势交易、对冲等。跨平台搬砖是指，当不同目标平台价差达到一定金额，在价高的平台卖出，在价低的平台买入。趋势交易会更加复杂一些，它根据趋势的指标来发出卖出和买入的信号。对冲是指同时进行两笔与行情相关、买卖方向相反、数量相当、盈亏相抵的交易，以达到对冲风险的效果。量化交易是成熟交易市场的标志。
5、区块链资产如何在场外交易？ 场外交易也叫 OTC 交易。用户需要自己寻找交易对手，不通过撮合成交，成交价格由交易双方协商确定，交易双方可以借助当面协商或者电话通讯等方式充分沟通。场外交易是最原始的交易方式。比特币刚诞生的时候，并没有交易平台，投资者只能通过场外交易交易比特币，且大多采用一手交钱一手交货的交易方式。现在，已经有很多规范化的场外交易平台，投资者可以直接在交易平台上选择交易对手方，和场内交易一样便捷。通过交易平台，可以有效避免在场外交易中因信息不对称导致人货两空的情况。
6、去中心化交易平台是什么？ 2013 年至今，诞生了很多去中心化交易平台。与中心化交易平台不同，去中心化交易平台不需要注册账户，使用个人数字资产账户即可参与交易。其次，去中心化交易平台每笔交易都通过区块链进行，需要等待区块链的确认才算交易成功。同时，去中心化交易平台不负责保管用户的资产和私钥等信息，一方面避免了交易平台的道德风险，另一方面要求你千万保管好自己的私钥。由于去中心化交易平台普遍存在流动性低、交易处理速度慢等特点，目前交易总量仅占全球数字资产交易总量的 0.03%。目前，去中心化交易平台项目 Airswap、Kyber、0x、OmiseGo 的代币都可以在火币上进行交易。
7、币币交易是什么？ 随着区块链资产种类的增加，传统的法定货币对区块链资产的交易，已经不能满足全球投资者的投资需求，更多专业投资者开始尝试币币交易。币币交易是指，用一种区块链资产定价另一种区块链资产。比如说用比特币定价以太坊会产生 ETH/BTC 交易对，改交易对的价格表示你需要用多少比特币可以买到一个以太坊。通过币币交易，你可以直接用一种区块链资换取另一种区块链资产，中间不涉及法定货币的中转或者结算。现在全球比特币的交易量将近一半来自币币交易，法定货币与比特币交易的比例逐渐缩小。
8、比特币钱包是干嘛的？ 比特币是一种点对点的电子现金系统，没有实物形态，可以存储在比特币钱包里。比特币钱包里存储着你的比特币信息，包括比特币地址（类似于你的银行卡账号）、私钥（类似于你银行卡的密码）。就像实物钱包里可以存放多张银行卡，比特币钱包里也可以存储多个比特币地址，以及每个比特币地址所对应的独立的私钥。比特币钱包的核心功能就是保护你的私钥，如果钱包丢失，你将永远失去这笔比特币。比特币钱包有很多种形态，如 PC 或手机钱包客户端、在线网页钱包、甚至是记录了比特币私钥的小本本（纸钱包）或者大脑（脑钱包）。你可以根据需求来选择适合自己的钱包。俗话说“鸡蛋不要放在一个篮子里”，采用多种方式分散存储也是降低风险的有效方式。
9、冷钱包与热钱包 比特币钱包按照私钥的存储方式，可以分为冷钱包、热钱包两种。冷钱包是指网络不能访问到你私钥的钱包。冷钱包往往依靠“冷”设备确保比特币私钥的安全，比如不联网的电脑、手机、写着私钥地址的小本本等。冷钱包避免了被黑客盗取私钥的风险，但是可能面临物理安全风险，比如电脑丢失损坏等。热钱包是指互联网能购访问你私钥的钱包。热钱包往往是在线钱包的形式。使用热钱包时，最好在不同平台设置不同密码，且开启二次认证，以确保自己的资产安全。无论是使用冷钱包还是热钱包，只要其他人知道了你的比特币私钥，就能转走你的比特币。记住，谁手握私钥，谁才是比特币真正的主人。
10、全节点钱包、轻钱包 前面我们知道了钱包的多种形态，也知道了钱包其实就是“私钥、地址和区块链数据的管理工具”。根据区块链数据的维护方式和钱包的去中心化程度，我们可以把钱包分为：全节点钱包、轻钱包、中心化钱包。全节点的代表是 bitcoin-core 核心钱包，需要同步所有区块链数据，占用很大的内存，但是可以完全实现去中心化。轻钱包依赖比特币网络上其他全节点，仅同步与自己相关的数据，基本可以实现去中心化。中心化钱包不依赖比特币网络，所有的数据均从自己的中心化服务器中获得，但是交易效率很高，可以实时到账，你在交易平台注册的账号就是中心化钱包。
参考资料： 新浪视频区块链100问专区
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/249c2a1d7195e3e2633656fa42196ddc/" rel="bookmark">
			python3_实现BP神经网络 &#43; BP神经网络应用实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.目录 1.BP神经网络简介
2.前期理论准备
2.算法数学原理
（一）符号说明
（二）公式推导
3.python实现（python3编程实现）
（一）sigmoid函数
（二）BP主函数实现
4.数据格式
1.BP神经网络简介 BP神经网络是1986年由Rumelhart和McClelland为首的科学家提出的概念，是一种按照逆向传播算法训练的多层前馈神经网络，是目前应用最广泛的神经网络。
目录
0.目录
1.BP神经网络简介
2.前期理论准备
2.算法数学原理
（一）符号说明
（二）公式推导
3.python实现（python3编程实现）
（一）sigmoid函数
（二）BP主函数实现
4.数据格式
优点：
1.具有任意复杂的模式分类能力和优良的多维函数映射能力，解决了简单感知器不能解决的异或问题的问题（参考博客：https://www.jianshu.com/p/a25788130897 或 https://www.cnblogs.com/xym4869/p/11282469.html）2.从结构上讲，BP神经网络具有输入层、隐含层和输出层3.从本质上讲，BP算法就是以网络误差平方目标函数、采用梯度下降法来计算目标函数的最小值。基本BP算法包括信号的前向传播和误差的反向传播两个过程。 缺点：
1.学习速度慢，即使是一个简单的过程，也需要几百次甚至上千次的学习才能收敛。2.容易陷入局部极小值3.网络层数、神经元个数的选择没有相应的理论指导4.网络推广能力有限。 应用：
1.函数逼近2.模式识别3.分类4.数据压缩 2.前期理论准备 网络训练的目标：找到合适的权值和阈值，使得误差E最小。
sigmoid函数：在信息科学当中，由于其单增以及其反函数单增等性质，sigmoid函数常被用作神经网络的阈值函数，将变量映射当0和1之间。（该函数的对x的求导也应该理解）
2.算法数学原理 （一）符号说明 Xi: 输入信号。
Xd: 隐层的阈值（是从求和函数中-θ中分离出的-1）。
Vih: 第h个隐层神经元所对应输入信号Xi的权值。
αh: 第h个隐层神经元的输入。
-γh=--1*γh：隐层神经元的阈值。
bh: 第h个隐层神经元的输入。
ωhj: 第j个输出层神经元所对应的隐层神经元输出bh的权值。
-θj=-1*θj: 输出层神经元的阈值（bq）
：第j个输出层神经元的输出（预测输出值，yj为真实值）
（二）公式推导 通过公式变换可得输出层权值与阈值的变化量：
同理可得隐层权值和阈值的变化量：
3.python实现（python3编程实现） （一）sigmoid函数 def sigmoid(x): """ 隐含层和输出层对应的函数法则 """ return 1/(1+np.exp(-x)) （二）BP主函数实现 def BP(data_tr, data_te, maxiter=600): # --pandas是基于numpy设计的，效率略低 # 为提高处理效率，转换为数组 data_tr, data_te = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/249c2a1d7195e3e2633656fa42196ddc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8505c321b51705a8f3474efe61b03de/" rel="bookmark">
			Android进程间通信 - 几种方式的对比总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 什么是RPC什么是IPC参考 什么是RPC RPC（Remote Procedure Call）即远程过程调用，它是一种通过网络从远程计算机程序上请求服务，在不需要了解底层网络技术的协议下，即可获取计算机进程中的数据。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。
RPC在OSI网络通信7层模型中，位于传输层与应用层之间，即位于会话层：
RPC实现模式，就是我们常说的C/S结构，引用百度百科的定义：
RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。
简而言之：客户端能向服务端发送若干个进程请求，服务端根据发送的进程参数依次返回对应的计算结果。RPC可以说客户端调用服务端的接口的过程，是面向接口的编程。
RPC在Android中咋样体现的，我们看看官方的解释RPC与IPC的关系
Android 利用远程过程调用 (RPC) 提供了一种进程间通信 (IPC) 机制，通过这种机制，由 Activity 或其他应用组件调用的方法将（在其他进程中）远程执行，而所有结果将返回给调用方。 这就要求把方法调用及其数据分解至操作系统可以识别的程度，并将其从本地进程和地址空间传输至远程进程和地址空间，然后在远程进程中重新组装并执行该调用。 然后，返回值将沿相反方向传输回来。 Android 提供了执行这些 IPC 事务所需的全部代码，因此您只需集中精力定义和实现 RPC 编程接口即可。
要执行 IPC，必须使用 bindService() 将应用绑定到服务上。
也就是说，RPC在的Android具体体现，是依赖 bindService()的方式，在onBind方法将服务端的计算结果返回给客户端（Activity等组件）的过程。
什么是IPC IPC 即 Inter-Process Communication (进程间通信)，是指进程间数据交互的过程。
Android底层是基于Linux，而Linux基于安全考虑，是不允许两个进程间直接操作对方的数据，这就是进程隔离
在Linux系统中，虚拟内存机制为每个进程分配了线性连续的内存空间，操作系统将这种虚拟内存空间映射到物理内存空间，每个进程有自己的虚拟内存空间，进而不能操作其他进程的内存空间，每个进程只能操作自己的虚拟内存空间，只有操作系统才有权限操作物理内存空间.进程隔离保证了每个进程的内存安全，但是在大多数情形下，不同进程间的数据通讯是不可避免的，因此操作系统必须提供跨进程通信机制。
虽然Android是基于Linux，但并不能继承Linux中的进程通信的方式，Android有着自己进程间通信方式。常用有如下几种：
Bundle （四大组件间）文件共享 可参考Android进程通信 - 序列化Serialzable与Parcelable中的示例 AIDL （基于Binder） 能自动生成Binder文件的工具，相当于工具。Android进程通信 - AIDL的使用方法 Messenger（基于Binder） 类似于Hnadler发消息用法Android进程间通信 - Messenger的使用和理解 ContentProvider（基于Binder） Android进程间通信 - ContentProvider内容提供者 Socket（网络） Android进程间通信 - Socket使用（TCP、UDP） 下面引用Android开发艺术探索的总结，已经很全面了
参考 Android开发艺术探索https://blog.csdn.net/u010132993/article/details/72582655https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E5%8D%8F%E8%AE%AE/6893245?fromtitle=RPC&amp;fromid=609861https://developer.android.com/guide/components/processes-and-threadshttps://blog.csdn.net/u011240877/article/details/72863432 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/431/">«</a>
	<span class="pagination__item pagination__item--current">432/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/433/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>