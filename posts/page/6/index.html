<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8d37991161ccd7e6a786344ecc5ce2f/" rel="bookmark">
			基于java的企业快信系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于java的企业快信系统设计与实现
I. 引言 A.研究背景和动机 企业快信系统是企业内部沟通和协作的重要工具，但是现有的企业快信系统存在着一些问题，比如用户体验不佳、信息泄漏等。因此，设计一个基于Java的企业快信系统，可以解决这些问题，提高企业内部沟通和协作的效率。
首先，企业快信系统需要具备高可用性和稳定性，保证系统的可靠性和安全性。其次，企业快信系统需要具备易用性和可扩展性，方便用户使用和管理。此外，企业快信系统需要具备信息加密和隐私保护等功能，保护用户信息和隐私安全。
为了实现这些功能，需要选择合适的技术和工具。比如，可以使用Java语言开发企业快信系统，使用Spring Framework和Hibernate框架进行系统设计和开发。此外，可以使用Apache OpenOffice、微软Office等软件进行文档和表格处理，使用Gmail、Outlook等邮件客户端进行邮件发送和接收。
最后，为了实现企业快信系统的可扩展性和可维护性，需要采用MVC模式进行系统设计和开发。MVC模式将系统分为模型、视图和控制器三个部分，分别对应数据、界面和逻辑控制。通过这种方式，可以实现系统的快速开发和维护。
综上所述，基于Java的企业快信系统设计与实现的研究背景和动机非常明确。设计一个高可用、易用、信息安全、可扩展的企业快信系统，可以提高企业内部沟通和协作的效率，并且保障用户信息和隐私安全。
B.目标和意义 基于Java的企业快信系统设计与实现的目标是建立一个功能强大、安全可靠的快信系统，帮助企业实现高效、安全的消息传递和沟通。具体而言，该系统应该具备以下特点：
快速、安全：该系统应该能够实现快速、安全的信息传递，避免信息泄漏和丢失。可靠性：该系统应该能够保证信息的可靠传输，避免因网络中断等原因导致的信息丢失。可扩展性：该系统应该能够支持企业快速扩展，适应企业不断增长的业务需求。可定制性：该系统应该能够根据企业的具体需求进行定制，满足企业个性化需求。
在实现过程中，该系统应该采用以下技术：安全性：该系统应该采用安全性较高的传输协议，如SSL/TLS等，确保信息传输的安全性。快速性：该系统应该采用高效的传输协议，如HTTP/2等，确保信息的快速传输。可扩展性：该系统应该采用分布式架构，支持负载均衡和集群部署，实现系统的可扩展性。可定制性：该系统应该支持自定义接口和服务，实现系统的可定制性。
该系统实现的意义在于，企业快信系统可以实现企业内部消息的快速传递和沟通，提高企业内部的信息传递效率，降低沟通成本，提高企业内部协作效率。此外，该系统还能够为企业提供个性化服务，满足企业个性化需求，提高企业内部沟通质量，增强企业内部凝聚力。 II. 相关技术和工具 A.Java语言 Java语言是一种面向对象的高级编程语言，由Sun Microsystems（现在是Oracle公司）于1995年发布。Java语言被设计成可移植、可靠、安全和简单易学的语言，以及具有优秀的性能和高效的垃圾回收机制。Java语言可以用于各种应用领域，包括Web应用、移动应用和企业应用等。Java语言的特点包括：
简单易学：Java语言采用清晰、简洁的语法，易于学习和理解。Java程序员不需要了解其他编程语言，就可以快速上手。跨平台性：Java程序可以在不同的操作系统和硬件平台上运行，包括Windows、Mac和Linux等。Java虚拟机（JVM）是Java程序的运行环境，它可以在不同的操作系统上运行相同的Java程序。面向对象：Java语言是一种真正的面向对象编程语言，它支持封装、继承和多态等面向对象的概念和特征。这些特性使得Java程序具有更好的结构化、可读性和可维护性。内存管理：Java语言具有自动垃圾回收机制，程序员不需要手动管理内存。垃圾回收器会定期扫描内存，回收不再使用的对象，避免了内存泄漏和野指针等问题。多线程支持：Java语言支持多线程编程，程序员可以使用线程来并行处理任务。多线程可以提高程序的性能和响应能力。丰富的类库和API：Java语言拥有大量的类库和API，程序员可以使用这些类库和API来完成各种任务，包括图形界面、网络编程、数据库连接等。安全性：Java语言对安全性有着很高的重视，它采用各种机制来保证程序的可靠性和安全性，如字节码验证、安全管理器等。分布式计算：Java语言支持分布式计算，它可以在多个计算机之间进行并行处理。Java语言提供了各种网络协议和接口，使得程序员可以方便地实现分布式计算。
总之，Java语言是一种功能强大、易于学习和使用的编程语言，适用于各种应用领域。它具有跨平台性、面向对象、内存管理、多线程支持、丰富的类库和API、安全性和分布式计算等特点，使得程序员可以快速上手，开发出高质量的程序。 B.数据库技术 数据库技术是一种用于管理和操作数据的技术。它可以帮助企业和组织高效地存储、管理和检索数据。数据库技术包括数据模型、数据库设计、数据库管理系统和数据存储技术等。数据模型是指数据的结构和关系，数据库设计是指如何设计和实现数据模型，数据库管理系统是指如何管理和维护数据库，数据存储技术是指如何存储和管理数据。数据库技术可以帮助企业和组织高效地存储、管理和检索数据，提高工作效率和数据安全性。
C.GUI技术 GUI技术，全称为图形用户界面，是一种用于人机交互的界面设计技术。它通过图形、图标、按钮、菜单等元素，使计算机界面更加直观、简洁、美观。GUI技术在计算机软件、移动设备、电视、智能家居等领域得到广泛应用。在软件开发中，GUI技术可以大大提高软件的易用性和用户体验，让用户更容易上手并使用。
GUI技术最早应用于20世纪70年代的Macintosh计算机，此后，它得到了广泛的发展和应用。在Windows操作系统中，GUI技术更是被广泛应用，成为Windows操作系统的主导设计理念。在移动设备上，iOS和Android操作系统也采用了GUI技术，为用户提供了更加友好的界面设计。
GUI技术的优点在于，它可以大大提高软件的易用性和用户体验。用户可以通过鼠标或触摸屏轻松地与计算机进行交互，并实现各种功能。同时，GUI技术还具有可定制性，用户可以根据自己的喜好和需求，对界面进行个性化设置。此外，GUI技术还可以通过添加插件、组件等方式，扩展计算机的功能，满足不同用户的需求。
总之，GUI技术是计算机界的重要设计理念之一，它的应用范围广泛，可以大大提高计算机的易用性和用户体验。随着技术的不断发展，GUI技术将会有更加广泛的应用，为用户带来更加便捷和高效的计算机体验。
III. 系统需求分析与设计 A.系统功能需求 企业快信系统是企业内部沟通的平台，它为员工提供了一种快速、高效的沟通方式，并且可以有效地降低沟通成本。以下是企业快信系统设计与实现的系统功能需求：
用户管理：企业快信系统需要管理用户，包括用户信息、权限、角色等，以保证系统安全。消息管理：企业快信系统需要管理消息，包括消息的发送、接收、删除、回复等，以保证消息传递的可靠性。文件管理：企业快信系统需要管理文件，包括文件的上传、下载、删除等，以保证文件的共享和安全性。通知管理：企业快信系统需要管理通知，包括通知的发送、接收、删除等，以保证通知传递的及时性和准确性。数据备份：企业快信系统需要定期备份数据，以保证数据的安全性和可靠性。安全性：企业快信系统需要保证系统的安全性，包括数据加密、权限控制、防火墙等，以保证系统数据的完整性和保密性。用户界面：企业快信系统需要提供友好的用户界面，方便用户操作和使用。数据库管理：企业快信系统需要管理数据库，包括数据库的设计、备份、维护等，以保证数据库的正常运行。 B.业务流程分析 1.需求分析
在开发之前，我们需要对企业快信系统进行详细的需求分析，包括系统功能、用户需求、技术架构等方面，确保系统的设计和开发能够满足企业的需求。
2.系统设计
在需求分析的基础上，我们需要进行系统设计，包括系统架构、模块划分、接口设计等方面，确保系统的设计和开发能够满足企业的需求。
3.编码实现
在系统设计的基础上，我们需要进行编码实现，包括程序编写、数据库设计等方面，确保系统的开发和测试能够顺利进行。
4.测试和上线
在编码实现之后，我们需要进行测试和上线，包括单元测试、集成测试、系统测试等方面，确保系统的稳定性和安全性。
5.维护和升级
在系统上线之后，我们需要进行维护和升级，包括系统维护、安全升级等方面，确保系统的长期稳定运行。
C.数据库设计 首先，我们需要一个用户管理系统，用来管理用户的账号、密码、邮箱等信息。用户信息包括用户名、密码、邮箱、手机号码、注册时间等字段。
接下来，我们需要一个系统管理员管理系统，用来管理系统的设置、数据备份、安全管理等信息。管理员信息包括管理员账号、密码、邮箱、手机号码、管理权限等字段。
然后，我们需要一个消息管理系统，用来管理用户之间的私信、群聊、公告等信息。消息信息包括发送者、接收者、消息内容、发送时间等字段。
最后，我们需要一个数据备份管理系统，用来备份系统的数据，防止数据丢失。数据备份信息包括备份时间、备份路径、备份内容等字段。
D.用户界面设计 企业快信系统是现代企业信息化的重要组成部分。企业快信系统具有实时性、安全性、高效性等特点，可以有效地提高企业的工作效率，为企业带来更多的商业价值。在设计企业快信系统时，需要考虑以下几个方面：
用户界面设计
企业快信系统的用户界面设计需要简单易用，操作流程清晰明了。在设计界面时，需要考虑用户的操作习惯和心理需求，尽可能让用户操作更加方便快捷。同时，企业快信系统应该具有良好的可扩展性，可以支持多种用户操作方式，如鼠标、键盘、手写等。消息传递
企业快信系统需要实现消息传递的功能，以便企业内部员工之间进行信息交流。在设计消息传递时，需要考虑消息的实时性、安全性和可靠性，确保消息传递的正确性和完整性。邮件发送
企业快信系统需要支持邮件发送的功能，以便企业内部员工之间进行信息交流。在设计邮件发送时，需要考虑邮件的实时性、安全性和可靠性，确保邮件的发送和接收的正确性和完整性。数据备份
企业快信系统需要支持数据备份的功能，以便企业内部员工之间进行信息交流。在设计数据备份时，需要考虑数据的安全性和可靠性，确保数据备份的正确性和完整性。权限管理
企业快信系统需要支持权限管理的功能，以便企业内部员工之间进行信息交流。在设计权限管理时，需要考虑权限的分配和权限的管理，确保权限的正确性和完整性。
以上是关于企业快信系统设计与实现的用户界面设计的介绍。企业快信系统是现代企业信息化的重要组成部分，在设计企业快信系统时，需要考虑用户体验、数据安全性和可靠性等因素，确保企业内部信息交流的正确性和完整性。 IV. 系统实现与开发 A.开发环境与工具 Java开发环境：常用的Java开发环境有Eclipse、IntelliJ IDEA、NetBeans等。这些开发环境提供了丰富的开发工具，包括代码编辑器、调试工具、版本控制工具等，可以帮助开发人员高效地完成开发任务。开发工具：开发工具包括开发框架、开发库、开发插件等。常用的开发框架包括Spring、Hibernate、Struts等，开发库包括jQuery、Hibernate、Struts等，开发插件包括Eclipse插件、IntelliJ IDEA插件等。这些工具可以帮助开发人员快速地搭建开发环境，提高开发效率。版本控制工具：版本控制工具可以帮助开发人员管理和跟踪项目的代码变化。常用的版本控制工具包括Git、SVN等，这些工具可以帮助开发人员协同开发，提高开发效率。邮件客户端：邮件客户端可以帮助开发人员发送和接收邮件。常用的邮件客户端包括Gmail、Outlook等，这些工具可以帮助开发人员快速地发送和接收邮件，提高沟通效率。 B.系统核心模块的实现 首先，快信系统是企业与客户之间沟通的重要方式，快速、准确地传递信息是快信系统最重要的功能之一。为了实现快速传递信息，快信系统需要具备高效的通信协议和可靠的数据传输机制。基于Java的快信系统应具备以下核心模块：
消息管理模块：负责管理快信系统中的消息，包括消息的接收、发送、删除、保存等操作。通信协议模块：负责快信系统中的通信协议，包括消息的传输方式、传输速度、传输格式等。数据传输模块：负责快信系统中的数据传输，包括数据的传输、接收、保存等操作。消息存储模块：负责快信系统中的消息存储，包括消息的备份、恢复等操作。消息验证模块：负责快信系统中的消息验证，包括消息的真实性、完整性等验证。消息调度模块：负责快信系统中的消息调度，包括消息的发送、接收、发送等操作。消息分析模块：负责快信系统中的消息分析，包括消息的发送者、接收者、发送时间等分析。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8d37991161ccd7e6a786344ecc5ce2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dab53fc7762a224be88d3f33a10734fc/" rel="bookmark">
			C#进行Web API开发时，遇到的常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当使用C#进行Web API开发时，可能会遇到以下一些常见问题：
跨域请求 由于浏览器的同源策略限制，跨域请求可能会引发问题。解决方法可以使用CORS（跨域资源共享）来允许从特定的域名或端口访问你的API。
// 添加CORS中间件 public void Configure(IApplicationBuilder app) { app.UseCors(builder =&gt; builder.WithOrigins("http://example.com") .AllowAnyHeader() .AllowAnyMethod() ); } 异常处理 在Web API开发过程中，必须注意处理各种异常情况，避免暴露敏感信息给客户端。可以使用全局异常过滤器来捕获并处理异常。
// 添加全局异常过滤器 public void ConfigureServices(IServiceCollection services) { services.AddControllers(options =&gt; { options.Filters.Add(new ApiExceptionFilter()); }); } 身份验证和权限控制 在一些需要认证和授权的API中，需要实现用户身份验证和权限控制。可以使用ASP.NET Core提供的身份验证和授权中间件来实现。
// 添加身份验证和授权中间件 public void ConfigureServices(IServiceCollection services) { services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =&gt; { options.TokenValidationParameters = new TokenValidationParameters { ValidateIssuer = true, ValidateAudience = true, ValidateLifetime = true, ValidateIssuerSigningKey = true, ValidIssuer = Configuration["Jwt:Issuer"], ValidAudience = Configuration["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dab53fc7762a224be88d3f33a10734fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d087f1e69c7357534da8c9347f9978/" rel="bookmark">
			正则表达式速攻1/2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是什么 正则表达式的目标是为了匹配字符串，可以理解为Ctrl+F的威力加强版
常用的情形是匹配大小写拉丁字母，数字和部分特殊符号
除此以外的情形，比如汉字，假名，彦文，西里尔字母，阿拉伯字母等需要使用unicode专用代码进行判断
使用的匹配方式是从左到右顺序匹配
修饰符 正则表达式的一般格式为：
/表达式/修饰符
一个正则表达式中只会出现**一次**修饰符，修饰符一共有4个，分别是gims
g 查找所有的匹配项，缺省时表示查找第一次匹配
i 表示不区分大小写
m和s都是根据换行符而言
m 表示多行匹配，也就是说原本用来匹配字符串开头和结尾的^和$现在以换行符为基准，匹配每一行的开头和结尾
s 表示.可以匹配换行符，而原本的.是不包括换行符的
表达式 /表达式/修饰符 表达式就是要匹配的对象
表达式的内容有两种，子表达式和限制符，子表达式就是用来匹配的文本，可以是abc，ABC，123，甚至特殊符号和使用unicode表达的字符等。但是有时候单单有匹配文本是不足以筛选出所有自己想要的内容，比如我要选中所有表示苹果（apple）的词条，但是文中时而写apple时而写apples，分两次选中就很麻烦，如果情况更多更复杂的话光有匹配文本就不够了，这时候就需要修饰符。修饰符紧跟在前一个匹配文本后面，形容这个文本出现的次数。
所以就可以写成apples?表示从a开始到e为止，我要匹配到完整的apple这个文本，而s因为跟了一个修饰符，？的意思是要么出现一次要么不出现，那么就会匹配到apple和apples两种文本了。
子表达式 子表达式也有两种，一种是字符，一种是组合
字符的情况就如上文所说，只要是能够打出来的东西都可以用来作为匹配的文本，但是要注意修饰符是不能够直接作为匹配文本，而要加\进行转义
如果\加上了特殊符号，就会把特殊符号转义成匹配的文本，如果\加上了可以被匹配的文本，反而会被识别为特殊的含义，比如\s表示空格，常用的有:
\s 空格
\w 文字，a-z，A-Z，0-9都属于
\d 数字
\r 回车
\n 换行
组合 如上述所说的例子，如果我要匹配的不只是apple，还想匹配app的话，就要把le看做一个整体，要么不出现，要么出现一次
app(le)?
如果还想要匹配appe,appl,app的话，原本应该写成
appl?e?
实际上也可以把l和e用或符号|分割开，也就是app(l|e)?
常用 .
匹配除了换行符之外的所有字符
[abc]
匹配a，b和c，中括号中的字符都是并列关系
[^abc]
匹配除了a,b,c以外的值
[a-z] 或者 [A-Z] 或者 [0-9] 或者 [a-zA-Z0-9] 等等
[^a-z]
匹配除了a-z以外的值
\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2d087f1e69c7357534da8c9347f9978/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b157a8e3a6ac239abc1bcf06ce015a6a/" rel="bookmark">
			2023-12-29 贪心算法 分发饼干和摆动序列以及最大子数组和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		贪心算法 什么是贪心算法？ 就是每一阶段的最优解，从局部的最优解达到全局的最优解！ 最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧。 贪心算法一般分为如下四步：
将问题分解为若干个子问题找出适合的贪心策略求解每一个子问题的最优解将局部最优解堆叠成全局最优解 455. 分发饼干 思路：这类涉及列表的数据！可以先考虑对列表进行排序先！然后优先满足最小胃口的或者排序优先满足最大胃口的都可以！ 局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。
class Solution: def findContentChildren(self, g: List[int], s: List[int]) -&gt; int: s.sort() g.sort() count = 0 sum = 0 for _g in g: while sum &lt; len(s): if _g &lt;= s[sum]: count += 1 s[sum] = -1 break sum += 1 return count class Solution: def findContentChildren(self, g, s): g.sort() # 将孩子的贪心因子排序 s.sort() # 将饼干的尺寸排序 index = 0 for i in range(len(s)): # 遍历饼干 if index &lt; len(g) and g[index] &lt;= s[i]: # 如果当前孩子的贪心因子小于等于当前饼干尺寸 index += 1 # 满足一个孩子，指向下一个孩子 return index # 返回满足的孩子数目 376.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b157a8e3a6ac239abc1bcf06ce015a6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/121c8772cc131cc6f7d1c16f1a7e9019/" rel="bookmark">
			查看nginx日志慢请求的tips
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在运维工作当中，会需要用到捞日志的命令
获取某一段时间内延时超过的请一秒的请求
cat nginx.log | grep '2021:12' | awk -F '^' '{if ($NF&gt;1) print $0}' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9d73b7e82e1a0c81a4dca78d894f091/" rel="bookmark">
			Qt 6之六：Qt Designer介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt 6之六：Qt Designer介绍 Qt Designer是一个可视化的用户界面设计工具，用于创建Qt应用程序的用户界面，允许开发人员通过拖放和布局来设计和创建GUI界面。
Qt 6之一：简介、安装与简单使用 https://blog.csdn.net/cnds123/article/details/130730203
Qt 6之二：项目的结构、资源文件的使用https://blog.csdn.net/cnds123/article/details/130741807
Qt 6之三： 项目的发布 https://blog.csdn.net/cnds123/article/details/130827966
Qt 6之四：基础概念讲解https://blog.csdn.net/cnds123/article/details/135401606
Qt 6之五：创建菜单https://blog.csdn.net/cnds123/article/details/135440934
关于Qt Designer简单使用在“Qt 6之二：项目的结构、资源文件的使用”中有简单介绍，现在进行综述和在Qt Creator集成的Qt Designer中设置信号和槽的具体操作步骤。
综述 Qt Creator集成的Qt Designer，启动后如下图：
QtPySide6（或PyQt6）使用的Qt Designer和Qt Creator集成的Qt Designer是同一款工具。
【附注：QtPySide6（或PyQt6）使用的Qt Designer，启动后如下图：
细心的读者或用户会发现，显示的界面有所不同，原因是由于不同的集成环境或版本所导致的。】
QtPySide6（或PyQt6）使用的Qt Designer是一个独立的可视化界面设计工具，它可以在单独的窗口中使用。它可以与QtPySide6（或PyQt6）一起使用，用来创建和编辑用户界面，并生成.ui文件。
Qt Creator是一个集成开发环境（IDE），它包含了Qt Designer和其他开发工具。Qt Designer作为Qt Creator中的一个插件，可以直接在Qt Creator中进行创建和编辑用户界面，并生成.ui文件。
它们是同一款工具，所以产生的.ui文件的格式和结构是相同的，无论你是使用独立的 Qt Designer 还是 Qt Creator 集成的 Qt Designer，产生的 .ui 文件都是标准的 XML 格式，描述了用户界面的结构。这些 .ui 文件是通用的：可以在不同的 Qt 应用程序之间移植，也就是说，你可以在一个环境中创建 .ui 文件，在另一个环境中加载和使用它们，不管是在 C++ 的 Qt 应用程序中，还是在 Python 的 PySide6 （或PyQt6）应用程序中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9d73b7e82e1a0c81a4dca78d894f091/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1ea7904f58db2fb53563f17de24eb6d/" rel="bookmark">
			Maximum upload size exceeded
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 默认上传文件有大小限制，在配置文件中设置下项目合适的文件上传大小即可，参考如下：
spring: servlet: multipart: max-file-size: 10MB 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa85d3fe2aa411b8bb0bdcb7bdfc6c2b/" rel="bookmark">
			C/C&#43;&#43;集成开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.csdn.net/pipisorry/article/details/20291219
Clion集成开发环境 jetbrains家的
Clion: A cross-platform IDE for C and C++ [https://www.jetbrains.com/clion/]
下载安装 注意：没有java环境的要先安装java；同样也要安装cmake。
下载[Download CLion: A Smart Cross-Platform IDE for C and C++]
Linux 安装 1.下载安装包后解压 clion目录,运行clion.sh文件进行安装 ~/opt/clion-2017.1.1$ cd bin
~/opt/clion-2017.1.1/bin$ ./clion.sh &amp;
2.1 进入IDE时如果提示导入配置文件，之前版本可能已有文件，按照提示自动导入就好。 2.2 将IDE固定在启动栏；如果没法固定或者总是启动之前版本，则可以在terminal中先打开，然后点击tools &gt; create desktop entry，在dash中就可以搜索打开相应的clion程序了，再固定在启动栏。 在license选项中选择　license server输入http://bash.pub:1017后点击active进行激活。或者通过pycharm同样的激活码激活。 Clion的使用 新建一个project 然后选择项目名字和路径即可创建一个项目，项目默认是一个helloworld,如下图
Note:
1 Clion是通过CMake来管理工程的。
2 工程类型：Clion工程是输出可执行程序、静态库或者动态库，我们可以自己修改CMakeLists.txt即可。
Build工程 我们在build之后发现生产的可执行程序并没有在工程目录下面而是在其他目录，如下
我们通过File–&gt;Settings–&gt;Build、Execution、Deployment–&gt;CMake
在Build output path:中加入bin，就是程序的输出路径
[Clion的安装和使用]
多个子project的project 创建一个project
如果你已经有c的代码了，想直接导入到clion中，则先创建一个project， 如cpp_workspace，其中就有一个cmake-build-debug文件夹，c代码执行文件就在这里面。
将c代码子目录（如JustForTest）copy到这个project中，如果之前是使用vs编辑的，可能需要删除不需要的文件或文件夹：
find . -name Debug | xargs rm -rf
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa85d3fe2aa411b8bb0bdcb7bdfc6c2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca0a3295d819ac3e78ad377787abb8b8/" rel="bookmark">
			微信小程序基本使用2：wxs，组件的使用以及弹窗、滚动条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WXS WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。
可以在模版中内联少量处理脚本，丰富模板的数据预处理能力。
wsx 在IOS设备上性能是JavaScript的2-20倍
内嵌式 &lt;view&gt; &lt;view&gt;{{m1.toUpper(message)}}&lt;/view&gt; &lt;/view&gt; &lt;wxs module="m1"&gt; module.exports.toUpper = function(str){ return str.toUpperCase(); } &lt;/wxs&gt; module=“属性值”
关联式 &lt;view&gt; &lt;view&gt;{{m2.toLower(message)}}&lt;/view&gt; &lt;/view&gt; &lt;wxs src="/utils/tools.wxs" module="m2"/&gt; 在utils下创建文件tools.wxs
// wxs function toLower(str){ return str.toLowerCase(); } module.exports = { toLower : toLower // 起别名 : 方法名 } 在wxs文件中直接写方法，最后通过module.exports暴露出来
组件Components 组件相当于是自定义标签
组件创建：创建文件夹 – &gt; 右键文件夹创建component
局部 局部配置只能在配置的页面上使用，单独在页面的JS文件中配置
在需要引用组件的页面的JSON文件中配置
{ "usingComponents": { "my-com" : "/components/test1/test1" } } wxml文件中引用
&lt;view&gt; &lt;my-com&gt;&lt;/my-com&gt; &lt;/view&gt; 引用组件的页面会显示组件的wxml文件中的内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca0a3295d819ac3e78ad377787abb8b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/683c34b100341bb9f16a4ca426abc3c4/" rel="bookmark">
			Zookeeper 和 naocs的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nacos 和 ZooKeeper 都是服务发现和配置管理的工具，它们的主要区别如下： 功能特性：Nacos 比 ZooKeeper 更加强大，Nacos 支持服务发现、动态配置、流量管理、服务治理、分布式事务等功能，而 ZooKeeper 主要用于分布式协调和服务发现。（服务器注册到配置中心：服务发现，客户端调用某个服务器：分布式协调）
数据一致性：Nacos 支持 AP 和 CP 模式，而 ZooKeeper 只支持 CP 模式。AP 模式强调可用性，允许出现数据不一致的情况，而 CP 模式强调数据一致性，在网络分区的情况下可能会出现部分不可用的情况。 （无论client连哪个服务器，显示的数据都是一样的）
存储方式：Nacos 使用 MySQL 或者 TiDB 存储数据，而 ZooKeeper 使用内存数据库存储数据。 生态系统：ZooKeeper 是 Apache 的顶级项目，生态系统比较完善，而 Nacos 是阿里巴巴开源的项目，生态系统相对较小。
综上所述，Nacos 更加适合用于微服务架构，而 ZooKeeper 更加适合用于分布式系统。
Zookeeper 全局数据一致性CP： 配置文件都一致
顺序性 每个配置的添加都是一样的顺序，一条条按顺序条件
更细原子性 100台机子，只要51台成功，数据更新就成功
宕机的机子重启后数据会同步吗 服务器宕机启动成功后，zookeeper会把配置同步给重启成功的服务器，同步完全后，才允许分布式协调。
集群 必须有个老大leader
有个选举机制
leader处理写操作，如果写操作给到follow（不能直接写），follow会给到leader；
leader写操作会广播给follow去写。
leader处理事务（写）
follow处理非事务操作（读）
observer 除了不能投票，干的事和follewer一样
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e8fd4f6157afed821794a6276a61e55/" rel="bookmark">
			TortoiseSVN·文件锁定与清理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装 TortoiseSVN 的时候，选择 svn 命令可用, 选择 will be intalled on local hard drive 。
在锁定的文件夹内 cmd 进入终端，输入 find . -type f -name ".svn/lock" -exec rm -f {} \; 删除所有锁定文件。进行清理操作：svn cleanup。在 TortoiseSVN 界面内重新提交。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e04c7e227d68c217e4d674c6d5477897/" rel="bookmark">
			Windows下安装mariadb10.5数据库及配置详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、简介 MariaDB数据库管理系统是一款MySQL的替代数据库。MariaDB由MySQL的创始人麦克尔·维德纽斯主导开发，是可扩展的，可靠的SQL服务器的合乎逻辑的选择，MariaDB 10.5 是 MariaDB 当前的稳定系列。
2、下载 下载地址：Download MariaDB Server - MariaDB.org
镜像选择阿里云镜像
3、安装 3.1、双击开始安装 3.2、选择安装路径 3.3、设置密码 3.4、设置服务名和端口号和内存大小 3.5、开始安装 3.6、完成 4、配置 4.1、安装位置 4.2、环境变量配置 4.3、任务管理器 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51f9833633efc1ba9ecd5c3fafa7c939/" rel="bookmark">
			Dell 机架式服务器 - 高级定制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dell 机架式服务器 - 高级定制 1. Dell Technologies2.1. Servers &amp; Storage (服务器及存储) -&gt; Servers2.2. Rack Servers (机架式服务器)2.3. Shop2.4. PowerEdge Rack Servers (PowerEdge 机架式服务器)2.5. PowerEdge R760 Rack Server (PowerEdge R760 机架式服务器) - 高级定制 References 1. Dell Technologies China Mainland
https://www.dell.com/zh-cn
United States
https://www.dell.com/en-us
2.1. Servers &amp; Storage (服务器及存储) -&gt; Servers https://www.dell.com/en-us
2.2. Rack Servers (机架式服务器) https://www.dell.com/en-us/shop/dell-poweredge-servers/sc/servers
Deliver secure, scalable infrastructure with high density one, two or four-socket rack servers that are optimized to power your systems to work together and independently.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51f9833633efc1ba9ecd5c3fafa7c939/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39442fc7314bf6d03c7aaa8564376876/" rel="bookmark">
			UniRepLKNet实战：使用UniRepLKNet实现图像分类任务（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 摘要安装包安装timm 数据增强Cutout和MixupEMA项目结构计算mean和std生成数据集一些问题 摘要 大核卷积神经网络（ConvNets）近年来受到广泛关注，但仍存在两个关键问题需要进一步研究。首先，目前的大型卷积神经网络架构大多遵循传统卷积神经网络或Transformer的设计原则，而大核ConvNets的架构设计仍未得到充分解决。其次，尽管Transformer已在多种模态中占据主导地位，但仍需研究卷积神经网络是否也具备超越视觉领域的强大通用感知能力。
本文从两个方面进行了贡献。首先，提出了设计大型卷积神经网络的四项架构准则。核心思想是利用大型内核与小型内核的本质区别：大型内核可以广角观察而无需深入。遵循这些准则，我们提出的大型卷积神经网络在图像识别方面表现出色。例如，UniRepLKNet在ImageNet上达到了88.0%的准确率，ADE20K mIoU为55.6%，COCO box AP为56.4%，性能优于最近提出的许多强大竞争对手，同时速度更快。
其次，大型内核是解锁ConvNets在非擅长领域中出色表现的关键。通过某些模态相关的预处理方法，UniRepLKNet在时间序列预测和音频识别任务上实现了领先性能，甚至在未经模态特定定制的情况下也取得了这一成就。
论文还提出了以下关于大核卷积神经网络的架构准则：
利用大核的本质特性：大核能够宽视野观察，而不需要深入挖掘。这一特性使得大核卷积神经网络能够在保持较高性能的同时，降低计算的复杂度和时间成本。设计更高效的架构：针对大核卷积神经网络，需要设计更高效的架构，以充分利用大核的优势。例如，可以采用更少的层数和更小的特征图大小，同时保持较高的性能。考虑数据预处理：对于大核卷积神经网络，数据预处理是一个重要的方面。通过对输入数据进行适当的归一化，可以改善网络的性能。优化训练策略：训练大核卷积神经网络需要采用适当的优化策略。例如，可以采用分阶段训练的方法，以及适当的正则化技术来防止过拟合。考虑硬件实现：大核卷积神经网络在硬件实现上需要考虑效率问题。因此，需要设计易于并行化和优化的架构，以便在具有有限资源的情况下实现高效的计算。 本文使用UniRepLKNet模型实现图像分类任务，模型选择最小的unireplknet_t，在植物幼苗分类任务ACC达到了96%+。
通过这篇文章能让你学到：
如何使用数据增强，包括transforms的增强、CutOut、MixUp、CutMix等增强手段？如何实现UniRepLKNet模型实现训练？如何使用pytorch自带混合精度？如何使用梯度裁剪防止梯度爆炸？如何使用DP多显卡训练？如何绘制loss和acc曲线？如何生成val的测评报告？如何编写测试脚本测试测试集？如何使用余弦退火策略调整学习率？如何使用AverageMeter类统计ACC和loss等自定义变量？如何理解和统计ACC1和ACC5？如何使用EMA？ 如果基础薄弱，对上面的这些功能难以理解可以看我的专栏：经典主干网络精讲与实战
这个专栏，从零开始时，一步一步的讲解这些，让大家更容易接受。
安装包 安装timm 使用pip就行，命令：
pip install timm mixup增强和EMA用到了timm
数据增强Cutout和Mixup 为了提高成绩我在代码中加入Cutout和Mixup这两种增强方式。实现这两种增强需要安装torchtoolbox。安装命令：
pip install torchtoolbox Cutout实现，在transforms中。
from torchtoolbox.transform import Cutout # 数据预处理 transform = transforms.Compose([ transforms.Resize((224, 224)), Cutout(), transforms.ToTensor(), transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5]) ]) 需要导入包：from timm.data.mixup import Mixup，
定义Mixup，和SoftTargetCrossEntropy
mixup_fn = Mixup( mixup_alpha=0.8, cutmix_alpha=1.0, cutmix_minmax=None, prob=0.1, switch_prob=0.5, mode='batch', label_smoothing=0.1, num_classes=12) criterion_train = SoftTargetCrossEntropy() Mixup 是一种在图像分类任务中常用的数据增强技术，它通过将两张图像以及其对应的标签进行线性组合来生成新的数据和标签。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39442fc7314bf6d03c7aaa8564376876/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38b458b2fa1555ab580760e37511b55d/" rel="bookmark">
			docker微服务案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 建立简单的springboot项目(boot3)boot2建立通过dockerfile发布微服务部署到docker容器编写Dockerfile打包成镜像运行镜像微服务 建立简单的springboot项目(boot3) 1.建立module
2. 改pom
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;docker_boot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;docker_boot&lt;/name&gt; &lt;description&gt;docker_boot&lt;/description&gt; &lt;properties&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt; &lt;druid.version&gt;1.1.16&lt;/druid.version&gt; &lt;mapper.version&gt;4.1.5&lt;/mapper.version&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--SpringBoot通用依赖模块--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--test--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 写yaml server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38b458b2fa1555ab580760e37511b55d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f41239e074ccbf3367162341bc240518/" rel="bookmark">
			Concurrency in CSharp Cookbook中文翻译：5.6创建自定义块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem 问题 You have reusable logic that you want to place into a custom dataflow block.Doing so enables you to create larger blocks that contain complex logic. 您希望将可重用的逻辑放入自定义数据流块中。这样做可以创建包含复杂逻辑的更大的块。 Solution 解决方案 You can cut out any part of a dataflow mesh that has a single input and output block by using the Encapsulate method. Encapsulate will create a single block out of the two endpoints. Propagating data and completion between those endpoints is your responsibility.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f41239e074ccbf3367162341bc240518/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/077e3defffea1ec4f9c977b4afe57f11/" rel="bookmark">
			【Linux】 vi/vim 教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 【 1. vi/vim 的三种模式 】1.1 命令模式1.2 输入模式1.3 底线命令模式 【 2. 实例 】【 3. vim 的其他命令 】 所有的 Unix Like 系统都会内建 vi 文本编辑器，其他的文本编辑器则不一定会存在。目前我们使用比较多的是 vim 编辑器。vim 从 vi 发展出来，vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。 【 1. vi/vim 的三种模式 】 基本上 vi/vim 共分为三种模式，命令模式（Command Mode）、输入模式（Insert Mode）和命令行模式（Command-Line Mode）。
1.1 命令模式 用户刚刚启动 vi/vim， 默认进入命令模式（也称普通模式）。此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符，比如我们此时按下 i，并不会输入一个字符，i 被当作了一个命令。 命令模式只有一些最基本的命令，因此仍要依靠底线命令行模式输入更多命令。以下是命令模式常用的几个命令： 命令作用i切换到输入模式，在光标当前位置开始输入文本。: （英文冒号）切换到底线命令模式，以在最底一行输入命令。x删除当前光标所在处的字符。a进入插入模式，在光标下一个位置开始输入文本。o在当前行的下方插入一个新行，并进入插入模式。O在当前行的上方插入一个新行，并进入插入模式。dd删除当前行。yy复制当前行。p（小写）粘贴剪贴板内容到光标下方。P（大写）粘贴剪贴板内容到光标上方。u撤销上一次操作。Ctrl + r重做上一次撤销的操作。:w保存文件。:q退出 Vim 编辑器。:q!强制退出Vim 编辑器，不保存修改。 1.2 输入模式 输入模式中，常用操作： 操作作用Esc退出输入模式，切换到命令模式字符按键以及Shift组合输入字符Enter回车键，换行Backspace退格键，删除光标前一个字符Delete删除键，删除光标后一个字符方向键在文本中移动光标HOME/END移动光标到行首/行尾Page Up/Page Down上/下翻页Insert切换光标为输入/替换模式，光标将变成竖线/下划线 1.3 底线命令模式 底线命令模式可用的命令非常多。按 ESC 键可随时退出底线命令模式。在底线命令模式中，常用的命令有（已经省略了冒号）： 命令作用:w保存文件。:q退出 Vim 编辑器。:wq保存文件并退出 Vim 编辑器。:q!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/077e3defffea1ec4f9c977b4afe57f11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44e91c2a7b38b287bf7b9682d0e7d0a9/" rel="bookmark">
			5个Linux归档命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		归档命令允许你将多个文件和目录捆绑到压缩归档文件中，以方便移植和存储。Linux 中常见的压缩包格式包括 .tar、.gz 和 .zip。
1. tar – 从归档文件中存储和提取文件 tar 命令可帮助你处理磁带归档文件（.tar）。它可以帮助你将多个文件和目录捆绑到一个压缩的 .tar 文件中。
语法：
tar [options] filename 有用的 tar 选项：
c – 创建一个新的 .tar 压缩文件。x – 从 .tar 压缩文件中提取文件。f – 指定存档文件名，而不是 stdin/stdout。v – 显示归档文件的详细输出。z – 使用 gzip 压缩或解压缩压缩包。 例子：
tar -cvzf images.tar.gz /home/user/images # tar -xvzf images.tar.gz 这会创建一个名为 images.tar.gz 的 gzip 压缩文件，其中包含 /home/user/images 文件夹。
2. gzip – 压缩或扩展文件 gzip 命令使用 LZ77 编码压缩文件，以减小存储或传输文件的大小。使用 gzip，你可以处理 .gz 文件。
默认只能压缩文件，压缩文件夹用-r file/，默认压缩后的文件名比压缩的文件名多了一个。gz，想指定压缩文件名用-c flienname &gt; output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44e91c2a7b38b287bf7b9682d0e7d0a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f223fae79f5be8cbc8c556ebe2367d96/" rel="bookmark">
			5个Linux重定向命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重定向命令用于控制 Linux 中的输入和输出源，让你可以向文件发送和追加输出流、从文件获取输入、连接多个命令以及将输出分割到多个目的地。
1. &gt; – 重定向标准输出 重定向操作符 &gt; 将命令的标准输出流重定向到文件，而不是打印到终端。文件中的任何现有内容都将被覆盖。
例子：
ls -l /home &gt; homelist.txt 这将执行 ls -l ，列出 /home 目录的内容。
然后，” &gt; “符号将捕获标准输出并写入 homelist.txt，覆盖现有文件内容，而不是将输出打印到终端。
重定向标准输出有助于将命令结果保存到文件中，以便存储、调试或将命令串联起来。
2. &gt;&gt; – 追加标准输出 &gt;&gt; 操作符将命令的标准输出追加到文件中，而不覆盖现有内容。
例子：
tail /var/log/syslog &gt;&gt; logfile.txt 这将把 syslog 日志文件的最后 10 行追加到 logfile.txt 的末尾。与 &gt; 不同， &gt;&gt; 添加输出时不会擦除当前 logfile.txt 的内容。
追加有助于将命令输出收集到一处，而不会丢失现有数据。
3. &lt; – 重定向标准输入 &lt; 重定向操作符将文件内容作为标准输入送入命令，而不是从键盘输入。
例子：
wc -l &lt; myfile.txt 该命令将 myfile.txt 的内容作为输入发送给 wc 命令，wc 命令将计算该文件的行数，而不是等待键盘输入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f223fae79f5be8cbc8c556ebe2367d96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2036576405ef51e8b2effa5d6d2bc85a/" rel="bookmark">
			TDL: 十分钟讲完 60 个你需要的 Linux 命令，60 Linux Commands you NEED to know GPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		small_Medium syposis on 60 Linux commands I) webpage address/route/pathII) text content &amp; exception2.1) command 1 : ssh2.2）ls I) webpage address/route/path URL Resource
II) text content &amp; exception Here are the top 60 Linux commands you need to know, and we’re gonna do this in minutes. Our first command can be used anywhere.
2.1) command 1 : ssh It is SSH because you can’t use Linux unless you can get to it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2036576405ef51e8b2effa5d6d2bc85a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4da08c9419f1372bc8578aeab73413f6/" rel="bookmark">
			数据结构之单调栈、单调队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天学习了单调栈还有单调队列的概念和使用，接下来我将对其定义并配合几道习题进行讲解：
首先先来复习一下栈与队列：
然后我们来看一下单调栈的定义：
单调栈中的元素从栈底到栈顶的元素的大小是按照单调递增或者单调递减的关系进行排列的，由于它的这个性质可以方便我们解决很多问题，接下来看一道可以用这个单调栈来解决的例题：
接下来我会提供两个不同的代码 但其实本质一样的解答，我们可以用样例模拟一下过程，这里我们考虑用一个单调递减的栈进行解答：
首先2进栈，然后接下来是6进栈，首先我们判断出6比2大，那么2对应的答案就是6的下标2并将2出栈，接下来3 1依次进栈，他们两个都满足递减，接下来5进栈之后，5对应的下标就是3 1两个的答案，并将这两个出栈，这样一直模拟下去就会得到每一个的答案，接下来上代码（从左往右看）：
#include&lt;bits/stdc++.h&gt; using namespace std; const int N=2e5+100; int a[N],top,ans[N],n,s[N]; int main(){ //先完成所有的输入 cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; //这里就是本题的模拟过程 for(int i=1;i&lt;=n;i++){ //我们这个时候栈即将进来一个元素，这时候我们将这个元素与单调递减栈中元素从上往下进行比较 while(top &amp;&amp; a[i]&gt;a[s[top]]){ //如果满足while循环条件，也就是即将进站元素大于栈顶元素，那么栈顶元素对应的答案下标就是即将进栈元素的下标 ans[s[top]]=i; //将栈顶元素出栈 --top; } //将这个元素进栈 s[++top]=i; } //最后由于会有后面不存在比他更大的元素，这时候把他们都设置为0 for(int i=1;i&lt;=top;i++) ans[s[i]]=0; //逐个输出 for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;' '; return 0; } 上面的代码我附着了详细的讲解 这里其实也可以从右往左进行枚举并同样使用单调栈进行解答，代码如下：
#include&lt;bits/stdc++.h&gt; using namespace std; const int N=2e5+100; int n,top,a[N],s[N],ans[N]; int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; //从右往左进行模拟 for(int i=n;i;i--){ //当栈非空并且栈顶元素是小于即将进栈的元素时将栈顶元素去除 while(top &amp;&amp; a[s[top]]&lt;=a[i]) --top; //如果栈非空，则说明这时候栈顶元素就是大于此时即将进栈元素的第一个元素 if(top) ans[i]=s[top]; else ans[i]=0;//否则就没有比他更大的数 s[++top]=i;//入栈 } //逐个输出 for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;' '; return 0; } 接下来看第二道题目：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4da08c9419f1372bc8578aeab73413f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c304608bf93540973f625467f936fd7c/" rel="bookmark">
			Android——从系统相册读取照片并展示——2个方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		布局：
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;Button android:id="@+id/btn_choose_common" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:text="普通选择图片" android:textColor="@color/black" android:textSize="17sp" /&gt; &lt;Button android:id="@+id/btn_choose_register" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:text="注册相册结果" android:textColor="@color/black" android:textSize="17sp" /&gt; &lt;/LinearLayout&gt; &lt;ImageView android:id="@+id/iv_photo" android:layout_width="match_parent" android:layout_height="360dp" /&gt; &lt;/LinearLayout&gt; activity：
package com.example.myapplication; import androidx.activity.result.ActivityResultLauncher; import androidx.activity.result.contract.ActivityResultContracts; import androidx.appcompat.app.AppCompatActivity; import android.content.Intent; import android.graphics.Bitmap; import android.net.Uri; import android.os.Bundle; import android.provider.MediaStore; import android.widget.ImageView; public class ChoosePhotoActivity extends AppCompatActivity { private final static String TAG = "ChoosePhotoActivity"; private int CHOOSE_CODE = 3; // 只在相册挑选图片的请求码 private ImageView iv_photo; // 声明一个图像视图对象 @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c304608bf93540973f625467f936fd7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fab9d43a827a65cafc67803084a250b3/" rel="bookmark">
			c&#43;&#43;全排列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
next_permutation()函数
例
perv_permutation()函数
例
next_permutation()函数 next_pernutation()函数用于生成当前序列的下一个排序。它按照字典序对序列进行重新排序，如果存在下一个排列，则将当前序列更改为下一个排列，并返回true；如果当前序列已经是最后一个排列，则将序列更改为第一个排列，并返回false。
例 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; int main() { vector&lt;int&gt;nums = { 1,2,3 }; cout &lt;&lt; "初始排序："; for (int num : nums) { cout &lt;&lt; num &lt;&lt; " "; } cout &lt;&lt; endl; //生成下一个排序 while (next_permutation(nums.begin(), nums.end())) { cout &lt;&lt; "下一个排序为："; for (int num : nums) { cout &lt;&lt; num &lt;&lt; " "; } cout &lt;&lt; endl; } system("pause"); return 0; } 结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fab9d43a827a65cafc67803084a250b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98f160cbd147177165b49e556c0dd2ba/" rel="bookmark">
			2_单例设计模式_反序列化破坏单例模式_注册式单例_线程单例实现 ThreadLocal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三 .反序列化破坏单例模式 个单例对象创建好后，有时候需要将对象序列化然后写入磁盘，下次使用时再从磁盘中读取对象并进行反序列化，将其转化为内存对象。
反序列化后的对象会重新分配内存，即重新创建。
public class SeriableSingleton implements Serializable { /* 序列化 把内存中对象的状态转换为字节码的形式 把字节码通过IO输出流，写到磁盘上 永久保存下来，持久化 ----------------- 反序列化 将持久化的字节码内容，通过IO输入流读到内存中来 转化成一个Java对象 */ public final static SeriableSingleton INSTANCE = new SeriableSingleton(); private SeriableSingleton(){} public static SeriableSingleton getInstance(){ return INSTANCE; } //添加这个固定格式的方法(桥接模式) private Object readResolve(){ return INSTANCE;} } public class SeriableSingletonTest { public static void main(String[] args) { SeriableSingleton s1 = null; SeriableSingleton s2 = SeriableSingleton.getInstance(); FileOutputStream fos = null; try { //序列化 fos = new FileOutputStream("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98f160cbd147177165b49e556c0dd2ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/139d9b21b0756180c42aec12cc328582/" rel="bookmark">
			Vue组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：组件化开发基础 1.组件是什么？有什么用？ 组件就是：扩展 HTML 元素，封装可重用的代码，目的是复用
例如：有一个轮播图，可以在很多页面中使用，一个轮播有js，css，html
组件把js，css，html放到一起，有逻辑，有样式，有html
组件的分类： 全局组件：可以放在根中局部组件： 工程化开发之后： 1个组件 就是1个xx.vue
二：组件的注册方式 1. 定义全局组件，绑定事件，编写样式 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;全局组件&lt;/title&gt; &lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="box"&gt; &lt;div @click="handleClick"&gt;我是根部组件&lt;/div&gt; &lt;global&gt;&lt;/global&gt; &lt;ul&gt; &lt;li v-for="i in 4"&gt; &lt;global&gt;&lt;/global&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; // 创建1个组件对象（全局组件） Vue.component('global', { template: ` &lt;div&gt; &lt;div style="background: rgba(255,104,104,0.7); padding: 5px;" @click="handleClick"&gt;我是头部组件&lt;/div&gt; &lt;div v-if="isShow"&gt;显示消失&lt;/div&gt; &lt;/div&gt; `, methods: { handleClick() { console.log('我被点击了') this.isShow = !this.isShow } }, data() { return { isShow: true } } }) let vm = new Vue({ el: '#box', data: { isShow: true }, methods: { handleClick() { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/139d9b21b0756180c42aec12cc328582/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82f0a2c8ea90aec0a9373e67dec428a2/" rel="bookmark">
			Hadoop之mapreduce参数大全-6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		126.指定 Map 任务运行的节点标签表达式 mapreduce.map.node-label-expression 是 Hadoop MapReduce 框架中的一个配置属性，用于指定 Map 任务运行的节点标签表达式。节点标签是在 Hadoop 集群中为节点分配的用户定义的标签，可用于将 Map 任务限制在特定类型的节点上运行。
在 Hadoop MapReduce 配置文件中，可以通过以下方式设置 mapreduce.map.node-label.expression：
&lt;property&gt; &lt;name&gt;mapreduce.map.node-label.expression&lt;/name&gt; &lt;value&gt;high-memory&lt;/value&gt; &lt;!-- 设置 Map 任务运行的节点标签表达式为 "high-memory" --&gt; &lt;/property&gt; 上述配置中，mapreduce.map.node-label.expression 的值为 high-memory，表示该作业的 Map 任务将只在具有 “high-memory” 标签的节点上运行。
通过设置这个配置属性，可以在 Hadoop 集群中利用节点标签功能，将 Map 任务限制在特定类型的节点上运行，以满足 Map 任务对硬件或软件环境的特定需求。这对于需要更多内存资源的 Map 任务很有用。
请注意，要使用节点标签功能，Hadoop 集群需要启用节点标签，并且相应的节点需要被分配标签。确保配置的节点标签表达式与集群中实际的节点标签匹配，以确保 Map 任务在正确的节点上运行。
127.指定 Reduce 任务运行的节点标签表达式 mapreduce.reduce.node-label-expression 是 Hadoop MapReduce 框架中的一个配置属性，用于指定 Reduce 任务运行的节点标签表达式。节点标签是在 Hadoop 集群中为节点分配的用户定义的标签，可用于将 Reduce 任务限制在特定类型的节点上运行。
在 Hadoop MapReduce 配置文件中，可以通过以下方式设置 mapreduce.reduce.node-label.expression：
&lt;property&gt; &lt;name&gt;mapreduce.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82f0a2c8ea90aec0a9373e67dec428a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ce9f8b5c4d27691b69b924ec8afdffe/" rel="bookmark">
			Pycharm远程连接服务器并运行代码（详细！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久没更新啦！这又是一篇查了很多blog，最终成功捣鼓出结果的一篇教程。这样就可以通过Pycharm同步代码到实验室的服务器中，还可以使用服务器的编程环境~下文在一些步骤处给出了一些解释，具体图片上也进行了步骤标注，希望可以帮助大家快速完成这个小任务~话不多说，开始远程连接服务器的教程。
注意点1：应该是只有Pycharm专业版可以进行远程连接服务器，而且功能更强大！这是我遇到的第一个坑（先是下了社区版）。专业版下载之后，学生可以用学校电子邮箱注册申请免费版，或者查查如何破解Pycharm,此处不再赘述。
直接进入正题吧。
1. 设置Connection
Tools-&gt;Deployment-&gt;Configuration
选择左上角的+添加配置信息（Create New Server处可以随便取一下服务器名字）类型选择SFTP，下方填写Host:服务器的IP地址；User name:账号(用户名)；Password：密码；port端口默认22。填好之后Test Connection测试连接情况，连接成功后选择下面的Apply。
【如果出现 The autenticity of host”…” can’t be established. ssh-rsa key fingureprint…提示，选择Yes继续连接即可】
小Tip: ssh 远程登陆指定端口时输入命令 ssh -p xx user@ip xx-端口号 user-用户 ip-ip地址
2. 建立Mapping
3. 实现代码自动上传
4. 设置Python Interpreter
File-&gt;Settings。
左侧Project：project下拉选择Python Interpreter
点击+ 添加interpreter（之前没有配过的话）
然后会出现这个提示，点Move
Next进入编译器路径配置，Sync folders可以理解是服务器同步文件所在位置
可以利用ssh登录云服务器之后执行which python来获取Python路径
ssh -p 22 username@xxx.xxx.xxx.xxx
-p:选择端口号，这里选择端口号22
@之前为用户名，之后为服务器IP地址
最后Finish结束！
那么如何在服务器上运行程序呢？这里简单说一下。
先把代码上传到服务器上（或者第三步配置了的话，直接Ctrl+S上传代码）
Run(Run 'main' )运行即可，你可以在下方看到运行结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9b786c5b91c6601e50d9b1f39935f32/" rel="bookmark">
			[渗透测试学习] Clicker - HackTheBox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 信息搜集代码审计反弹shell提权 信息搜集 nmap扫描一下端口
nmap -sV -sC -v -p- --min-rate 1000 10.10.11.232 扫描结果
22/tcp open ssh 80/tcp open http Apache httpd 2.4.52 ((Ubuntu)) //重定向 111/tcp open rpcbind 2-4 (RPC #100000) 我们往下看发现启用了nfs协议
去网上查询下相关资料 参考文章
NFS最大的功能就是可以透过网络，让不同的机器、不同的操作系统、可以彼此分享个别的档案(share files)。所以，你也可以简单地将它看做是一个文件服务器(file server)。这个NFS服务器可以让你的PC来将网络远程的NFS服务器分享的目录，挂载到本地端的机器当中，在本地端的机器看起来，那个远程主机的目录就好像是自己的一个磁盘分区槽一样(partition)，使用上相当的便利。
既然可以远程读取文件，那么我们使用mount命令将远程NFS文件系统挂载到本地目录
在本地创建目录mnt/nfs_file，然后读取根目录文件
sudo mount -o nolock 10.10.11.232:/ ~/test/mnt/nfs_file 注：-o：指定挂载选项，比如读写权限、访问权限等
​ nolock 是在挂载 NFS 文件系统时的一种选项，用于禁用文件锁定机制，使得同时进行读写操作不受文件锁定限制
我们ls一下，发现zip文件
解压发现不行，用cp命令复制到本地即可
由于80端口出现重定向，那么我们添加域名到/etc/hosts
开始进行下一步
代码审计 我们在admin.php注意到有对session进行身份验证，如果验证失败则重定向到index.php
那么我们尝试得到admin的session，接着在save_game.php找到可利用的地方
&lt;?php session_start(); include_once("db_utils.php"); if (isset($_SESSION['PLAYER']) &amp;&amp; $_SESSION['PLAYER'] != "") { $args = []; foreach($_GET as $key=&gt;$value) { if (strtolower($key) === 'role') { // prevent malicious users to modify role header('Location: /index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9b786c5b91c6601e50d9b1f39935f32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70601026b4aea5ceda68382759c0f9fe/" rel="bookmark">
			软件测试|好用的pycharm插件推荐（二）—— JSON Parser
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简介 PyCharm是一款强大的Python集成开发环境（IDE），它提供了许多插件来增强开发体验。其中一个非常有用的插件是"JSON Parser"，它允许你在PyCharm中轻松解析和处理JSON数据。在本文中，我们将详细介绍如何安装和使用PyCharm JSON Parser插件。
安装JSON Parser插件 打开PyCharm IDE，并点击顶部菜单栏中的"File"（文件）选项。选择"Settings"（设置）选项，在弹出的菜单中选择"Plugins"（插件）。 在插件窗口的搜索栏中输入"JSON Parser"，然后点击右侧的"Install"（安装）按钮。 安装完成后，重启PyCharm使插件生效。 使用JSON Parser插件 json形式的数据是层级结构（从上至下，一层一层的）的。但是如果我们拿到的是平铺的json字符串，那么看起来效果就会比较困难，尤其是层级较多时，特别难分清层级结构，JSON Parser插件就可以很好的帮我们分层展示JSON，而不需要我们去网站上进行解析。
使用步骤
点击顶部菜单栏中的"View"（视图）选项，在"ToolWindows"中选择"JSON Parser"，如下图： 选择之后，将会出现工作窗口，如下图： 其他功能 除了格式化和验证JSON，JSON Parser插件还提供了其他一些有用的功能，例如：
Minify JSON：将JSON数据压缩为一行，减少空格和换行符。Pretty Print：类似于格式化JSON，但可以选择缩进和换行的方式。Encode/Decode：将JSON数据进行编码和解码。 总结 JSON Parser是一个非常实用的PyCharm插件，它提供了格式化和验证JSON数据的功能，以及其他一些有用的功能。通过安装和使用该插件，你可以在PyCharm中更加轻松地处理JSON数据，从而提高开发效率和准确性。
最后感谢每一个认真阅读我文章的人，礼尚往来总是要有的，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走：
这些资料，对于【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴上万个测试工程师们走过最艰难的路程，希望也能帮助到你！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eae2f2c11016775c5e7852ce573266c8/" rel="bookmark">
			软件测试|好用的pycharm插件推荐（五）——Translation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在我们的日常工作中，经常会遇到需要查看各个第三方库源码的问题，在很多情况下，我们的英语能力不能够满足我们完全读懂源码，所以我们就需要借助翻译工具来帮助我们理解第三方库的源码，如果我们将源码复制再使用其他工具翻译，会显得比较繁琐，如果有一个直接翻译的插件能够使用的话，就会方便许多，pycharm的translation插件就可以满足我们的需求。
简介 PyCharm Translation 是一款方便的插件，可以帮助开发者在 PyCharm 中轻松进行代码注释、文本翻译和国际化字符串管理。本指南将详细介绍如何安装、配置和使用 PyCharm Translation 插件。
安装PyCharm Translation 插件 打开 PyCharm，点击菜单栏的 "File" &gt; "Settings"（或 "PyCharm" &gt; "Preferences"）。在弹出的窗口中，选择 "Plugins"。 在 "Marketplace" 标签中，搜索 "Translation"。
点击 "Install" 安装插件。
配置插件 在插件安装完成后，重启 PyCharm。打开 "File" &gt; "Settings"（或 "PyCharm" &gt; "Preferences"）。在 "Tools" 下找到 "Translation" 部分。在 "Translation" 设置中，选择你想要的默认翻译引擎，例如 "Google Translate"。 使用翻译功能 代码注释翻译：
将光标放在要翻译的代码注释上。右键点击，选择 "Translate" &gt; "Translate Comment"。插件将使用默认引擎将注释翻译为你选择的目标语言。 文本翻译：
选中要翻译的文本。右键点击，选择 "Translate" &gt; "Translate Text"。同样，插件会使用默认引擎将选定的文本翻译为目标语言。 国际化字符串管理：
打开你的项目。在项目中选择要进行国际化处理的字符串。右键点击，选择 "Translate" &gt; "Add to Translation"。在弹出的窗口中，为字符串选择一个翻译键和默认语言。在需要翻译的语言列中输入相应的翻译。 高级功能 自定义翻译引擎： 在设置中，你可以选择不同的翻译引擎，甚至配置自己的翻译服务。批量翻译： 在项目中，你可以选中多个文件或文本，右键点击选择 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eae2f2c11016775c5e7852ce573266c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/577966e121695d26948b72e1d75dbb76/" rel="bookmark">
			16_LearnOpenGL 光照贴图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		光照贴图 前面的教程，我们讨论了让不同的物体拥有各自不同的材质并对光照做出不同的反应的方法。在一个光照场景中，让每个物体拥有和其他物体不同的外观很棒，但是这仍然不能对一个物体的图像输出提供足够多的灵活性。
前面的教程中我们将一个物体自身作为一个整体为其定义了一个材质，但是现实世界的物体通常不会只有这么一种材质，而是由多种材质组成。想象一辆车：它的外表质地光亮，车窗会部分反射环境，它的轮胎没有specular高光，轮彀却非常闪亮（在洗过之后）。汽车同样有diffuse和ambient颜色，它们在整个车上都不相同；一辆车显示了多种不同的ambient/diffuse颜色。总之，这样一个物体每个部分都有多种材质属性。
所以，前面的材质系统对于除了最简单的模型以外都是不够的，所以我们需要扩展前面的系统，我们要介绍diffuse和specular贴图。它们允许你对一个物体的diffuse（而对于简洁的ambient成分来说，它们几乎总是是一样的）和specular成分能够有更精确的影响。
漫反射贴图 我们希望通过某种方式对每个原始像素独立设置diffuse颜色。有可以让我们基于物体原始像素的位置来获取颜色值的系统吗？
这可能听起来极其相似，坦白来讲我们使用这样的系统已经有一段时间了。听起来很像在一个[之前的教程](https://learnopengl-cn.readthedocs.io/zh/latest/01 Getting started/06 Textures/)中谈论的纹理，它基本就是一个纹理。我们其实是使用同一个潜在原则下的不同名称：使用一张图片覆盖住物体，以便我们为每个原始像素索引独立颜色值。在光照场景中，通过纹理来呈现一个物体的diffuse颜色，这个做法被称做漫反射贴图(Diffuse texture)(因为3D建模师就是这么称呼这个做法的)。
为了演示漫反射贴图，我们将会使用下面的图片，它是一个有一圈钢边的木箱：
在着色器中使用漫反射贴图和纹理教程介绍的一样。这次我们把纹理以sampler2D类型储存在Material结构体中。我们使用diffuse贴图替代早期定义的vec3类型的diffuse颜色。
要记住的是sampler2D也叫做模糊类型，这意味着我们不能以某种类型对它实例化，只能用uniform定义它们。如果我们用结构体而不是uniform实例化（就像函数的参数那样），GLSL会抛出奇怪的错误；这同样也适用于其他模糊类型。
我们也要移除amibient材质颜色向量，因为ambient颜色绝大多数情况等于diffuse颜色，所以不需要分别去储存它：
struct Material { sampler2D diffuse; vec3 specular; float shininess; }; ... in vec2 TexCoords; 如果你非把ambient颜色设置为不同的值不可（不同于diffuse值），你可以继续保留ambient的vec3，但是整个物体的ambient颜色会继续保持不变。为了使每个原始像素得到不同ambient值，你需要对ambient值单独使用另一个纹理。
注意，在片段着色器中我们将会再次需要纹理坐标，所以我们声明一个额外输入变量。然后我们简单地从纹理采样，来获得原始像素的diffuse颜色值：
vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords)); 同样，不要忘记把ambient材质的颜色设置为diffuse材质的颜色：
vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords)); 这就是diffuse贴图的全部内容了。就像你看到的，这不是什么新的东西，但是它却极大提升了视觉品质。为了让它工作，我们需要用到纹理坐标更新顶点数据，把它们作为顶点属性传递到片段着色器，把纹理加载并绑定到合适的纹理单元。
更新的顶点数据可以从这里找到。顶点数据现在包括了顶点位置，法线向量和纹理坐标，每个立方体的顶点都有这些属性。让我们更新顶点着色器来接受纹理坐标作为顶点属性，然后发送到片段着色器：
#version 330 core layout (location = 0) in vec3 position; //从顶点集中拿到本帧顶点的 点位置属性 layout (location = 1) in vec3 normal; //从顶点集中拿到本帧顶点的 法向量属性 layout (location = 2) in vec2 texCoords; //从顶点集中拿到本帧顶点的 纹理属性 uniform mat4 model; uniform mat4 view; uniform mat4 projection; out vec2 TexCoords; out vec3 Normal; out vec3 FragPos; void main() { gl_Position = projection * view * model * vec4(position, 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/577966e121695d26948b72e1d75dbb76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8752b0d34209e761c446bc22fd7150e/" rel="bookmark">
			SpringIOC之support模块FileSystemXmlApplicationContext
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝5W+，全栈开发工程师，从事多年软件开发，在大厂呆过。持有软件中级、六级等证书。可提供微服务项目搭建与毕业项目实战，博主也曾写过优秀论文，查重率极低，在这方面有丰富的经验✌
博主作品：《Java项目案例》主要基于SpringBoot+MyBatis/MyBatis-plus+MySQL+Vue等前后端分离项目，可以在左边的分类专栏找到更多项目。《Uniapp项目案例》有几个有uniapp教程，企业实战开发。《微服务实战》专栏是本人的实战经验总结，《Spring家族及微服务系列》专注Spring、SpringMVC、SpringBoot、SpringCloud系列、Nacos等源码解读、热门面试题、架构设计等。除此之外还有不少文章等你来细细品味，更多惊喜等着你哦
🍅uniapp微信小程序🍅面试题软考题免费使用，还可以使用微信支付，扫码加群。由于维护成本问题得不到解决，可能将停止线上维护。
点击这里预览
🍅文末获取联系🍅精彩专栏推荐订阅👇🏻👇🏻 不然下次找不到哟
Java项目案例《100套》
https://blog.csdn.net/qq_57756904/category_12173599.html
uniapp小程序《100套》
https://blog.csdn.net/qq_57756904/category_12199600.html
有需求代码永远写不完，而方法才是破解之道，抖音有实战视频课程，某马某千等培训都是2万左右，甚至广东有本科院校单单一年就得3万4年就12万学费，而且还没有包括吃饭的钱。所以很划算了。另外博客左侧有源码阅读专栏，对于求职有很大帮助，当然对于工作也是有指导意义等。在大城市求职，你面试来回一趟多多少少都在12块左右，而且一般不会一次性就通过，还得面试几家。而如果你对源码以及微服务等有深度认识，这无疑给你的面试添砖加瓦更上一层楼。
最后再送一句：最好是学会了，而不是学废了！！！
FileSystemXmlApplicationContext 是 Spring Framework 中的一个类，它是 ApplicationContext 接口的实现，用于从文件系统加载 XML 配置文件并创建应用程序上下文。与 ClassPathXmlApplicationContext 不同，FileSystemXmlApplicationContext 允许您从文件系统的特定路径加载配置文件。
主要特点和用途包括：
加载文件系统中的 XML 配置文件： FileSystemXmlApplicationContext 允许您指定文件系统上配置文件的路径，然后从该路径加载配置。创建和初始化 bean： 它与其他应用程序上下文一样，可以创建和初始化所有配置文件中定义的 bean，并处理它们之间的依赖关系。提供 bean 获取功能： 一旦配置文件中的 bean 被创建，您可以使用应用程序上下文获取它们，以便在应用程序中使用。 以下是一个示例，演示如何使用 FileSystemXmlApplicationContext：
import org.springframework.context.ApplicationContext; import org.springframework.context.support.FileSystemXmlApplicationContext; public class MyApp { public static void main(String[] args) { // 创建 FileSystemXmlApplicationContext，指定 XML 配置文件的路径 ApplicationContext context = new FileSystemXmlApplicationContext("file:/path/to/applicationContext.xml"); // 从应用程序上下文中获取 bean MyBean myBean = context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8752b0d34209e761c446bc22fd7150e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a5c5c61c75c284c2e7e121c7dff0e26/" rel="bookmark">
			PLECS如何下载第三方库并导入MOSFET 的xml文件，xml库路径添加方法及相关问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 首先xml库的下载，PLECS提供了一个跳转的链接。 https://www.plexim.com/download/thermal_models
2. 下载一个库（以最后一个Wolfspeed为例，属于CREE的SiC MOSFET） 下载这个就行，都包含了。不信自己可以试试再下载其他两个PLECS的库
里面有三个压缩文件，解压后会看到一堆的xml文件
3. PLECS中xml库的导入 首先将现在的库放在你想存放的位置
比如我的是C:\Plexim
然后在plecs中添加搜索路径
添加完之后，扫描一下，如下图步骤1.，然后apply，最后ok
在这里能看到说明就添加成功了
4. xml库与MOSFET的链接 五种MOSFET，只有前两种可以导入xml模型
能导入xml模型的此处显示为黑色，可选
不能导入xml的显示为灰色，
那就换能导入的模型导入
好的，结束。感谢各位观看， 备注：可能存在xml文件版本过高导致无法导入PLECS，解决办法就是使用新版本PLECS **
点个收藏，点个赞吧 **
补充了一点，在自己的知乎里面
https://zhuanlan.zhihu.com/p/677034273
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b78f91d47c661738631fb2ce4c253e48/" rel="bookmark">
			软件测试|Python Selenium 库安装使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 Selenium 是一个用于自动化浏览器操作的强大工具，它可以模拟用户在浏览器中的行为，例如点击、填写表单、导航等。在本指南中，我们将详细介绍如何安装和使用 Python 的 Selenium 库。
安装 Selenium 库 使用以下命令可以通过 pip 安装 Selenium 库：
pip install selenium 安装 WebDriver 安装selenium之后，我们暂时还不能直接使用脚本去操作浏览器，还需要我们下载浏览器对应的驱动，Chrome，edge，Firefox等不同浏览器需要下载不一样的驱动，同时，驱动也需要对应浏览器的版本，如114版本的Chrome浏览器，驱动也只能是114版本的Chromedriver。
Chrome： 下载 Chrome WebDriverFirefox： 下载 Gecko WebDriverEdge： 下载 Edge WebDriver其他浏览器： 根据浏览器类型下载对应的 WebDriver 注：115版本之后的Chromedriver下载地址为：Chromedriver下载地址
下载 WebDriver 后，将其可执行文件所在的路径添加到系统的环境变量中，以便 Selenium 可以找到它。
使用示例 第一个示例：打开网页 from selenium import webdriver # 创建一个 Chrome 浏览器实例 driver = webdriver.Chrome() # 打开网页 driver.get("https://www.baidu.com") # 关闭浏览器 driver.quit() 定位元素 使用 Selenium 可以通过多种方式定位页面中的元素，例如 ID、类名、XPath 等。
from selenium.webdriver.common.by import By element = driver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b78f91d47c661738631fb2ce4c253e48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a1649350a4e4173da9960cf4781954/" rel="bookmark">
			Rust学习笔记-常见的编程概念-函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rust学习笔记 常见的编程概念 函数 Rust 代码中的函数和变量名使用 snake case 规范风格。在 snake case 中，所有字母都是小写并使用下划线分隔单词。这是一个包含函数定义示例的程序：
fn main() { println!("Main function!"); another_function(); } fn another_function() { println!("Another function!"); } 在 Rust 中通过输入 fn 后面跟着函数名和一对圆括号来定义函数。大括号告诉编译器哪里是函数体的开始和结尾。
可以使用函数名后跟圆括号来调用我们定义过的任意函数。因为程序中已定义 another_function 函数，所以可以在 main 函数中调用它。注意，源码中 another_function 定义在 main 函数 之后；也可以定义在之前。Rust 不关心函数定义所在的位置，只要函数被调用时出现在调用之处可见的作用域内就行。
让我们新建一个叫做 functions 的二进制项目来进一步探索函数。将上面的 another_function 例子写入 src/main.rs 中并运行。你应该会看到如下输出：
参数 我们可以定义为拥有 参数（parameters）的函数，参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。技术上讲，这些具体值被称为参数（arguments），但是在日常交流中，人们倾向于不区分使用 parameter 和 argument 来表示函数定义中的变量或调用函数时传入的具体值。
fn main() { another_function(5); } fn another_function(x: u32) { println!("The value of x is {x}"); } 运行结果:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01a1649350a4e4173da9960cf4781954/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26818321ddbb13dfc3900867e6b30717/" rel="bookmark">
			Rust学习笔记-常见的编程概念-变量和数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rust学习笔记 常见的编程概念 变量和可变性 变量默认是不可改变的（immutable），当变量不可变时，一旦值被绑定一个名称上，你就不能改变这个值。
在尝试改变预设为不可变的值时，产生编译时错误是很重要的，因为这种情况可能导致 bug。如果一部分代码假设一个值永远也不会改变，而另一部分代码改变了这个值，第一部分代码就有可能以不可预料的方式运行。不得不承认这种 bug 的起因难以跟踪，尤其是第二部分代码只是 有时 会改变值。
Rust 编译器保证，如果声明一个值不会变，它就真的不会变，所以你不必自己跟踪它。这意味着你的代码更易于推导。
例如，下面代码会检查到不可变错误（immutability error）：
fn main() { let x = 5; println!("The value of x is: {x}"); x = 6; // 不能对不可变变量 x 二次赋值（cannot assign twice to immutable variable `x` ） println!("The value of x is: {x}"); } 尽管变量默认是不可变的，你仍然可以在变量名前添加 mut 来使其可变
例如：
fn main() { let mut x = 5; println!("The value of x is: {x}"); x = 6; println!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26818321ddbb13dfc3900867e6b30717/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dbdc88ecca3a2df0e0fd49eb2d51dc6/" rel="bookmark">
			借助GPT理解 “ Android中 点击弹框外部 取消弹框”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在平常的开发工作中 或 阅读技术博客/书籍 时，难免会遇到我们不懂的知识点，网络上搜索的资料 需要有准确性，系统性，可实操性。
这样的资料查询很费时间且还不一定能找到，但是如果借助训练过的的gpt，就会省下大量的时间且学到的知识也是体系化的。
最近借助gpt工具 处理了 我 不少的问题，接下来就以一个“ Android中 点击弹框外部 取消弹框” 这么一个话题 借助 gpt去了解实现原理
首先从这个场景里面一个关键的值定义出发：
接下来在源码中找到该值引用的地方：
源码里添加了这个flag，当用户触摸屏幕，但触摸位置在窗口的边界之外时，系统将发送ACTION_OUTSIDE 事件到处理事件的窗口。
然后dialog里面会判断是不是ACTION_OUTSIDE 事件
如果你设置了点击外部取消并且检测到了这个事件就会 自动cancel掉
推荐工具：
https://www.gnomic.cn/agentChat/index（上图中用到的工具），这个的回答还是比较不错的
https://devv.ai/zh （AI浏览器），我一般是这两个结合起来用，我发现不对劲 理解不了的时候就用这个ai搜索引擎，他里面会给出一些搜索用到的资料链接
优先用的是stackoverflow的资源，所以会比较准确一些
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de795dfa7d98dbf13a49afe5a08587d/" rel="bookmark">
			代码随想录算法训练营——数组篇总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 理解数组的逻辑结构与物理结构，数组是存放在连续内存空间上的相同类型数据的集合。数组的删除只能用覆盖经典题目1：二分法，要深刻理解循环不变量法则，这也是写代码的重要法则经典题目2:双指针法，暴力破解两层循环都可以想办法用双指针处理，可以是快慢指针或者相向指针经典题目3:滑动窗口，双指针变种，主要在于前后指针都在移动，像一个滑动窗口，滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。经典题目4:同样是深刻理解循环不变量法则，理解偏移量与循环次数，真正解决题目的代码都是简洁的，或者有原则性还需要做一些变种题目，相关题目来巩固，要学会自己分析推导，因为永远也记不住代码，只能记得解决问题思路与自己熟练的编程经验 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74aedff32715794e3c5d3e59fd339eff/" rel="bookmark">
			iOS 按钮添加点击震动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 方法说明： iOS10后系统提供了一套API来简单实现震动：
init时传入一个style定义好的枚举就可以实现不同的震动
typedef NS_ENUM(NSInteger, UIImpactFeedbackStyle) { UIImpactFeedbackStyleLight, UIImpactFeedbackStyleMedium, UIImpactFeedbackStyleHeavy, UIImpactFeedbackStyleSoft API_AVAILABLE(ios(13.0)), UIImpactFeedbackStyleRigid API_AVAILABLE(ios(13.0)) }; // UIImpactFeedbackGenerator is used to give user feedback when an impact between UI elements occurs UIKIT_EXTERN API_AVAILABLE(ios(10.0)) API_UNAVAILABLE(visionos) API_UNAVAILABLE(tvos, watchos) NS_SWIFT_UI_ACTOR @interface UIImpactFeedbackGenerator : UIFeedbackGenerator - (instancetype)initWithStyle:(UIImpactFeedbackStyle)style; /// call when your UI element impacts something else - (void)impactOccurred; /// call when your UI element impacts something else with a specific intensity [0.0, 1.0] - (void)impactOccurredWithIntensity:(CGFloat)intensity API_AVAILABLE(ios(13.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74aedff32715794e3c5d3e59fd339eff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7c170a1d424b7c09e0ecd2696587eed/" rel="bookmark">
			iOS 取整函数（四舍五入取整，向上向下取整，取最近整数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		取整用的函数主要在usr/include &gt; math.h内
一、 四舍五入取整 函数方法如下：
extern float roundf(float); extern double round(double); extern long double roundl(long double); extern long int lroundf(float); extern long int lround(double); extern long int lroundl(long double); 举例：
double rpValue = round(1.1); // 1 double rpValue = round(1.5); // 2 double rpValue = round(-1.4); // -1 double rpValue = round(-1.5); // -2 二、向上取值整（向x轴右侧取整） 函数方法如下：
extern float ceilf(float x); extern double ceil(double x); extern long double ceill(long double x); 举例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7c170a1d424b7c09e0ecd2696587eed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f45a53c993b090e81c848449b36dc97/" rel="bookmark">
			深度学习算法应用实战 | 利用 CLIP 模型进行“零样本图像分类”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 零样本图像分类简介1.1 什么是零样本图像分类?1.2 通俗一点的解释 2. 模型原理图3. 环境配置4. 代码实战5. Gradio前端页面5.1 什么是 Gradio ? 6 进阶操作7. 总结 1. 零样本图像分类简介 1.1 什么是零样本图像分类? “零样本图像分类”（Zero-shot image classification）指的是使用一个模型对图像进行分类，而这个模型并没有在包含那些特定类别的标记样本的数据上进行过显式训练。
传统的图像分类方法需要在一组特定的带标签的图像上训练模型。这个模型通过学习，将图像的某些特征与标签相对应。当需要使用这种模型来处理引入了新标签集的分类任务时，通常需要进行模型的微调，以适应新的标签。
与此相反，零样本或开放词汇的图像分类模型通常是多模态模型，这些模型在包含大量图像及其相关描述的数据集上进行训练。这些模型学习了视觉和语言之间对齐的表示方法，可以应用于包括零样本图像分类在内的许多下游任务。
这是一种更为灵活的图像分类方法，它允许模型在不需要额外训练数据的情况下，泛化到新的和未见过的类别。同时，它也使用户能够用自由形式的文本描述来查询他们目标对象的图像。
1.2 通俗一点的解释 上面的内容如果看不懂没关系，下面我来用通俗的语言解释这段话：
比如我们想让一个熊孩子能认识不同的图片（比如区分猫和狗），我们需要给这个熊孩子看很多标有“这是猫”、“这是狗”的图片来训练它。这就像是在教熊孩子“这些特征意味着猫，那些特征意味着狗”。但如果突然出现一个新的动物种类，比如浣熊，而熊孩子之前没有学习过浣熊的图片，它就不知道怎么识别了。这时，我们通常需要给熊孩子更多的浣熊图片来训练它识别浣熊。这就是我们上面提到的传统的图像分类。
然而，“零样本图像分类”就像是给熊孩子一种超能力，让它能在没有直接学习过某个类别（比如浣熊）的情况下也能识别出来。这种方式是通过训练熊孩子理解图片和文字之间的关系来实现的。比如，熊孩子在学习的时候不仅看图片，还学习这些图片的描述。这样，当它遇到一个新的图片（比如浣熊），即使它之前没有直接学习过，它也可以通过理解图片的特征和之间学到的文字描述来猜测这可能是“浣熊”。
总的来说，这就是一种更聪明的方式，让熊孩子能够在没有被直接训练识别某些东西的情况下，也能识别出这些东西来。
那这篇博客， 我就教大家使用 CLIP 搭建一个零样本的分类模型！不需要任何的训练就可以实现你的分类需求！
教程使用 huggingface 的 transformers 库来完成，这样方便我对整个专栏的代码教程进行维护，也方便我为大家分发模型（这种多模态的模型一般都很大，自己下载一次很麻烦，我会在博客中提供模型网盘地址）。
2. 模型原理图 论文地址：[paper] Learning Transferable Visual Models From Natural Language Supervision (arxiv.org)
论文摘要：最近，在大量数据上进行模型预训练的自然语言处理领域取得的突破为计算机视觉领域的类似基础模型铺平了道路。这些模型可以通过生成通用视觉特征（即，适用于不同图像分布和任务且无需微调的特征）来大大简化任何系统中图像的使用。本研究表明，如果在来自不同来源的足够多的策划数据上训练，现有的预训练方法，特别是自监督方法，可以产生这样的特征。我们重新审视现有方法，并结合不同技术来扩展我们的预训练，包括数据和模型规模方面。大部分技术贡献旨在加速和稳定大规模训练。在数据方面，我们提出了一个自动化管道，用于构建专用的、多样化的、策划的图像数据集，而不是像自监督文献中通常做的那样使用未策划的数据。在模型方面，我们训练了一个拥有10亿参数的ViT模型，并将其蒸馏成一系列较小的模型，这些模型在大多数图像和像素级基准测试中超过了现有最佳的通用特征，即OpenCLIP。
3. 环境配置 后续所有教程都使用conda环境，请大家自行配置好~
conda create --name huggingface-env python==3.8 -y conda activate huggingface-env pip install transformers 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f45a53c993b090e81c848449b36dc97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd5776eeda39a85a3667de4b5b1e4e3b/" rel="bookmark">
			11 个 Python全栈开发工具集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 以下是专注于全栈开发不同方面的 Python 库;有些专注于 Web 应用程序开发，有些专注于后端，而另一些则两者兼而有之。
1. Taipy Taipy 是一个开源的 Python 库，用于构建生产就绪的应用程序前端和后端。
它旨在加快应用程序开发，从初始原型到生产就绪应用程序。
🔑 主要功能：
广泛的交互性布局、样式等有更多的自定义功能（无需 CSS）多页面和多用户应用程序图形流水线编辑器与 Taipy 前端功能集成，实现端到端部署调度兼容笔记本电脑 2.Prefect Prefect 是一个提供数据管道开发的框架。
它通过专注于简单性和用户友好性，将自己与 Airflow 等竞争对手区分开来。
如果您想要一个具有各种功能但比 Airflow 更容易学习曲线的成熟产品，那么 Prefect 是一个很好的介于两者之间。
🔑 主要功能：
直观且用户友好的控制面板缓存等智能功能基于流程的结构，便于工作流程组织动态参数化和依赖关系管理混合执行（本地/云） 3. Streamlit Streamlit 是快速简单地构建 Web 应用程序的游戏规则改变者。
该数据应用程序框架专注于从更完整和更复杂的解决方案到快速且用户友好的解决方案的差异化。
🔑 主要功能：
Pythonic 框架交互式小部件用户友好性 4.Airflow Apache Airflow 是一个开源平台，专为调度和监控工作流而设计。
它是编排复杂数据管道和 ETL 流程的绝佳选择，因为它在过去十年中一直是管道领域的佼佼者。
该库的完整性与陡峭的学习曲线有关。
🔑 主要功能：
基于 DAG 的工作流定义完整的界面包括 DAG 的可视化效果、跟踪故障和管理重试。各种集成动态任务执行和调度以 Python 为中心的设计社区支持 5. Brython Brython 将 Python 带到了前端，因为名称重新组合了“浏览器”和“Python”。
它引入了直接在 Web 应用程序中运行 Python 代码的独特概念。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd5776eeda39a85a3667de4b5b1e4e3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67a7f41ccfa2cf93876118e1eceada3f/" rel="bookmark">
			软通测试岗面试内部资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础性问题 1.你对加班怎么看
2你的优势有哪些
3.你的缺点是什么
4.最有成就感的事情是什么
5.你的职业规划是什么
6离职原因是什么
7.还有什么想问我们的吗
8.你有其他的 offer 吗
专业性问题 9.HTTPS 和 HTTP 的区别
10.HTTPS 的工作原理
11.客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤
12.HTTPS的优点
13.HTTPS的缺点
14.htp 切换到 HTTPS
15.提到 UI 级别测试和 API 测试之间的关键区别?
16.接口测试用例的编写要点有哪些?
17.接口自动化测试的流程?
18.POST 和 GET 有什么区别?
19.常见的 HTTP Header 及其作用
20.Session 与 Cookie 有什么区别?
21.HTTP 通讯过程中， 是客户端还是服务端主动断开连接?
22.HTTP 有哪些请求方法?
23.Cookie 保存在哪里?
24简述 TCP/IP的三次握手和四次挥手
25.TCP 和 UDP 有什么区别
26.什么是 TCP/IP?
27.ison 和字典 dict 的区别?
28.测试的数据你放在哪?
29.什么是数据驱动，如何参数化?
30.ui 自动化中定位不到元素的原因有哪些
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67a7f41ccfa2cf93876118e1eceada3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e01a6e19741a152f09f6962a8d8e23f/" rel="bookmark">
			云卷云舒：数据库的serverless演进趋势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着阿里云、华为云的PolarDB、guessDB都在大力演进serverless版本的发布，部分特性已经发布公测，国内的另外两家云服务商移动云、天翼云也相继推出serverless版本，并计划近期公测，可以看出数据库的serverless趋势依然非常明显。
数据库产品可以说是跟随者计算机发展起来的，尤其是关系型数据库，已经有了接近20多年的发展历史（引文：数据库还能发展多少年），且经久不衰。数据库的系统架构相对稳定，内核层面尤其是在资源调度部分相对成熟，自成体系，面对这serverless的演进，挑战不言而喻。这里面要实现serverless的支持要分开来看：
1、云原生数据库：对于云原生数据库来说，天生就是基于存算分离的架构，对于数据库的弹性扩缩容，只要针对存储层做出分布式应对，上层计算引擎和节点做出一些扩容即可实现，总体来说成本较低；
2、传统数据库：由于历史的缘由，自成体系相对成熟的底层资源管理和调度组件，代码量大，要想开展serverless的调整，近似于重构，工作量巨大，成本较高；
3、云数据库：主要指“托管型”的数据库，如云MySQL，虽然不是完全基于存算分离的架构，但是底层使用的也基本是云盘了，所以进行serverless的改造成本，相比传统数据库来说，小多了，是可以实现的，但是这个改造的深度就要看各大云服务商的投入了，我还是那句话，谁能够真正的吃投了数据库的内核，合理深度的改造将进一步提升产品的成本竞争力，甚至是生存竞争力。
退一步来讲，云服务商也要积极推动serverless技术的落地，已明显降低成本，实现闲置资源的自动利用，比如夜间闲置资源可以动态腾挪出来，供其他产品跑批量测试、灰度发布使用。
可以大胆预测，serverless一定是未来云计算计算型产品的发展趋势，可以极大的激发云计算的成本效益，也将成本各大主流的云服务商市场竞争的主战场。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0ee50e23bf92956c70b4fa248f97a1b/" rel="bookmark">
			SVN迁移至GitLab，并附带历史提交记录（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与《SVN迁移至GitLab，并附带历史提交记录》用的 git svn clone不同，本文使用svn2git来迁移项目代码。
一、准备工作 安装Git环境，配置本地git账户信息： git config --global user.name "XXX" git config --global user.email "XXX@mail.com" 可通过命令git config -l 查看结果
Create a new repository git clone http://xxx/testproject.git cd testproject touch README.md git add README.md git commit -m "add README" git push -u origin master Push an existing folder cd existing_folder git init git remote add origin http://xxx/testproject.git git add . git commit -m "Initial commit" git push -u origin master Push an existing Git repository cd existing_repo git remote rename origin old-origin git remote add origin http://xxx/testproject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0ee50e23bf92956c70b4fa248f97a1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ee119fca2595032359df8bad5c763a9/" rel="bookmark">
			【UE Niagara学习笔记】06 - 制作火焰喷射过程中飞舞的火星
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇博客（【UE Niagara学习笔记】05 - 喷射火焰顶部的蓝色火焰）的基础上继续实现喷射火焰的火星的效果。
目录
效果
步骤
一、创建材质实例 二、添加新的发射器
2.1 设置粒子材质
2.2 设置发射器持续生成粒子
2.3 设置粒子生成数量
2.4 设置粒子初始生命时长、初始颜色和初始大小 2.5 设置粒子生成位置
2.6 让粒子移动
2.7 修改 缩小粒子生成范围 粒子初始位置偏移 延长粒子生命周期
2.8 设置粒子越来越小
2.9 其它细节
效果 步骤 一、创建材质实例 1. 对材质“M_SingleText_Master_Additive”创建一个材质实例
这里命名为“M_FlameThrower_Inst”
打开材质实例“M_FlameThrower_Inst”，设置参数“MainTexture”的值为纹理“T_Spark_B”
二、添加新的发射器 2. 打开粒子系统“NS_Flame_Thrower”
添加发射器
模板选择“Simple Sprite Burst”
命名新添加的发射器为“Spark”
孤立显示该发射器的效果
2.1 设置粒子材质 选中“Sprite渲染器”模块，设置材质为刚才创建的材质实例“M_FlameThrower_Inst”
此时就可以在视口中看到火星粒子
2.2 设置发射器持续生成粒子 选中“Emitter State”模块，设置“Loop Behavior”为“Infinite” 2.3 设置粒子生成数量 删除“Spawn Burst Instantaneous”模块
添加“Spawn Rate”模块
设置粒子生成率为20~30范围内的随机值
2.4 设置粒子初始生命时长、初始颜色和初始大小 2.5 设置粒子生成位置 添加一个“Shpae Location”模块，设置“Shape Primitive”为“Box/Plane”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ee119fca2595032359df8bad5c763a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecdb7bbf74cd7ac97e82cdfc72f4f1d4/" rel="bookmark">
			CSS-设置背景图片的大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要设置背景图片的大小，您可以使用CSS的background-size属性。这个属性允许您指定背景图片的尺寸。
background-size属性可以接受不同的值，包括：
auto：保持原始图片的尺寸。cover：将图片缩放到完全覆盖背景区域，可能会裁剪部分图片。contain：将图片缩放到完全适应背景区域，可能会留有空白区域。具体的尺寸值，例如 100px、50% 等。 以下是几个示例：
/* 将背景图片缩放到完全覆盖背景区域，可能会裁剪部分图片 */ .background { background-image: url('your-image.jpg'); background-size: cover; } /* 将背景图片缩放到完全适应背景区域，可能会留有空白区域 */ .background { background-image: url('your-image.jpg'); background-size: contain; } /* 指定背景图片的具体尺寸 */ .background { background-image: url('your-image.jpg'); background-size: 200px 150px; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ada399e6c200fd9e4cd7e100bcaba17/" rel="bookmark">
			【专栏目录】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本专栏是讲解如何改进Yolo系列小目标的的专栏。改进方法采用了最新的论文提到的方法。改进的方法包括：增加注意力机制、更换卷积、更换block、更换backbone、更换head、更换优化器等；每篇文章提供了一种到N种改进方法。本专栏的改进方法是面向小目标以及密集小目标场景。
评测用的数据集是我自己标注的数据集，里面包含32种飞机。每种改进方法我都做了测评，并与官方的模型做对比。
代码和PDF版本的文章，我在验证无误后会上传到百度网盘中，方便大家下载使用。
这个专栏，求质不求量，争取尽心尽力打造精品专栏！！！
欢迎订阅，谢谢大家支持！！！为了更好的帮助大家，我建了QQ群，用来答疑，QQ群：601684057，输出订阅的订单号即可入群！
已经更18篇内容，还在持续更新中。。。。
MwdpNet:致力于提高高分辨率遥感图像微小目标的识别精度 MwdpNet:致力于提高高分辨率遥感图像微小目标的识别精度
YoloV8改进策略：Shape-IoU，考虑边框形状与尺度的度量 YoloV8改进策略：Shape-IoU，考虑边框形状与尺度的度量
YoloV8改进策略：ASF-YOLO，结合了空间和尺度特征在小目标和密集目标场景有效涨点 YoloV8改进策略：ASF-YOLO，结合了空间和尺度特征在小目标和密集目标场景有效涨点
YoloV8改进策略：动态蛇形卷积，解决管状结构问题 YoloV8改进策略：动态蛇形卷积，解决管状结构问题
YoloV8改进策略：WaveletPool解决小目标的混叠问题，提高小目标的检测精度 YoloV8改进策略：WaveletPool解决小目标的混叠问题，提高小目标的检测精度
YoloV7改进策略：独家原创，全网首发，复现Drone-Yolo，以及改进方法 YoloV7改进策略：独家原创，全网首发，复现Drone-Yolo，以及改进方法
YoloV8改进策略：Gold-YOLO高效目标检测器与YoloV8激情碰撞 YoloV8改进策略：Gold-YOLO高效目标检测器与YoloV8激情碰撞
YoloV5改进策略：独家原创，全网首发，复现Drone-Yolo，以及改进方法 YoloV5改进策略：独家原创，全网首发，复现Drone-Yolo，以及改进方法
YoloV8改进策略：独家原创，全网首发，复现Drone-Yolo，以及改进方法 YoloV8改进策略：独家原创，全网首发，复现Drone-Yolo，以及改进方法
YoloV7改进策略：复现HIC-YOLOv5，打造HIC-YOLOv7，用于小物体检测 YoloV7改进策略：复现HIC-YOLOv5，打造HIC-YOLOv7，用于小物体检测
YoloV5改进策略：复现HIC-YOLOv5，用于小物体检测 YoloV5改进策略：复现HIC-YOLOv5，用于小物体检测
HIC-YOLOv5：改进的YOLOv5，用于小物体检测 HIC-YOLOv5：改进的YOLOv5，用于小物体检测
YoloV5改进策略：LSKNet加入到YoloV5中，打造更适合小目标的YoloV5 YoloV5改进策略：LSKNet加入到YoloV5中，打造更适合小目标的YoloV5
YoloV8改进策略：LSKNet加入到YoloV8中，打造更适合小目标的YoloV8 YoloV8改进策略：LSKNet加入到YoloV8中，打造更适合小目标的YoloV8
YoloV8改进策略：SPD-Conv加入到YoloV8中，让小目标无处遁形 YoloV8改进策略：SPD-Conv加入到YoloV8中，让小目标无处遁形
YoloV8改进策略：NWD小目标检测新范式，助力YoloV5、V8在小目标上暴力涨点 YoloV8改进策略：NWD小目标检测新范式，助力YoloV5、V8在小目标上暴力涨点
小型目标检测中的Transformer：一个基准和最先进技术的综述 小型目标检测中的Transformer：一个基准和最先进技术的综述
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e76cf612eccfce44e0f81a5dd8c65333/" rel="bookmark">
			微服务下多模块拆分，公用类调用与模块隔离性怎么兼得呢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在一个微服务项目中，为了追求低耦合，会根据业务板块对主系统进行切分为一个个子模块，模块间相互隔离，但是这样子就会导致一个问题：对于一些在多个子模块中都适用的配置类、工具类、封装类等都需要拷贝冗余到各个模块中，这样子显然是不太合理的，那么想要鱼和熊掌兼得，我们可以独立创建一个共用子模块，将这一类共用的数据类都给放到这里来，然后将该模块打包为jar包在各个子模块pom文件中引入，这样子就可以实现一份共用配置在多个子模块中使用，并保证了子模块间的隔离性。下面让我们来看一下相关的具体配置操作。
抽离共用资源成模块 我们在这一块可以将一些那些在多个子模块都需要的资源（eg：响应实体、常用工具类、常量类、全局异常处理等）抽离出来写到一个专门的公共资源模块中
业务模块引用 然后我们就可以将这个共用子模块进行打包为Jar给其他业务模块引用，这里科普一下 Maven 命令知识点，一般我们打包使用比较多的命令就是 package、install、deploy。
声明一点就是这三个命令都能打包，有什么区别呢？
package： 该命令完成了项目编译、单元测试、打包功能三个过程。install： 在 package 命令的前提下新增一个步骤，将新打好的包部署到本地 Maven 仓库。deploy： 在 install 命令的前提下新增一个步骤，将新打的包部署到远端仓库（相当于本地和远端仓库同时部署一份）。 而我们只是本地仓库引用，只需要 install 命令执行即可，两种方式分别是 Maven 插件或者终端执行命令 mvn clean install。
可以去对应的仓库坐标下查看 Jar 是否部署成功。如果不知道怎么操作可以参考我的另一篇文章【依赖dependency / 插件Plugin】 not found？可以看看这思路-CSDN博客
然后再其他业务模块的pom文件中就能直接进行引用啦
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.xxx&lt;/groupId&gt; &lt;artifactId&gt;xxxx-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 注意点 这里要注意一下就是说，如果你公共模块中定义了SpringBean的话，想要进行自动装配就必须在公共模块的项目 Resources 目录下新建 META-INF 文件夹，然后创建 spring.factories 文件。在文件中填写好自动装配类的全限定类名
为什么要指定 resources/META-INF 下写 spring.factories？不这么写不行啊。
SpringFactoriesLoader#loadFactories 负责完成自动装配类的加载，扫描的就是这个变量文件。
你不按照规定写可以，扫不到你的自动配置类可咋整，消停的吧。
总结 总结起来，需要按照一定的规范将共用的配置类、工具类、封装类等放在共用子模块中，并将该子模块打包为jar包引入到各个子模块中。如果希望在共用子模块中的代码能够进行自动装配，需要在公共模块的 Resources 目录下创建 META-INF/spring.factories 文件，并在其中填写自动装配类的全限定类名。遵循这些配置操作可以实现共享配置并保持子模块间的隔离性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dafe8c96edaecadf9d06926e563124ed/" rel="bookmark">
			LeetCode 2696.删除子串后的字符串最小长度：栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【LetMeFly】2696.删除子串后的字符串最小长度：栈 力扣题目链接：https://leetcode.cn/problems/minimum-string-length-after-removing-substrings/
给你一个仅由 大写 英文字符组成的字符串 s 。
你可以对此字符串执行一些操作，在每一步操作中，你可以从 s 中删除 任一个 "AB" 或 "CD" 子字符串。
通过执行操作，删除所有 "AB" 和 "CD" 子串，返回可获得的最终字符串的 最小 可能长度。
注意，删除子串后，重新连接出的字符串可能会产生新的 "AB" 或 "CD" 子串。
示例 1：
输入：s = "ABFCACDB" 输出：2 解释：你可以执行下述操作： - 从 "ABFCACDB" 中删除子串 "AB"，得到 s = "FCACDB" 。 - 从 "FCACDB" 中删除子串 "CD"，得到 s = "FCAB" 。 - 从 "FCAB" 中删除子串 "AB"，得到 s = "FC" 。 最终字符串的长度为 2 。 可以证明 2 是可获得的最小长度。 示例 2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dafe8c96edaecadf9d06926e563124ed/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/5/">«</a>
	<span class="pagination__item pagination__item--current">6/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/7/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>