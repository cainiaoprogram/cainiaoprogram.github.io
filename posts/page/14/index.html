<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fa30028ea2dfe230e1347f33076231d/" rel="bookmark">
			苹果电脑RAW图像处理软件Capture One Pro 22 mac软件介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Capture One Pro 22 for mac是一款专业的RAW文件转换器和图像编辑软件，拥有更新的处理引擎、市场领先的性能和强大的新功能，可为 500 多台高端相机提供具有美丽色彩和令人难以置信的细节的终极图像质量。
Capture One Pro 22 for Mac版软件介绍
Capture One是专业的RAW转换器，可为500多个高端相机提供极致的图像质量，美丽的色彩和令人难以置信的细节。它通过可自定义的工作区提供最先进的绑定捕获，强大的数字资产管理，广泛的调整工具和灵活的工作流程。
凭借更新的处理引擎，市场领先的性能和强大的新功能，Capture One是成像软件的专业选择。您可以获得所需的高响应精度工具，可以在节省时间的工作流中从相机的RAW文件创建出色的图像，该工作流可以根据需要进行自定义。
苹果：Capture One Pro 22 for Mac(RAW图像处理软件) v15.4.2.12中文版
Win：Capture One 22 (图片编辑软件)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d5c450c8a242f5dea598f0af7c59a40/" rel="bookmark">
			LeetCode-棒球比赛（682）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述： 你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。
比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：
整数 x - 表示本回合新获得分数 x
“+” - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。
“D” - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。
“C” - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。
请你返回记录中所有得分的总和。
思路： 遍历输入的字符串数组，这里说是字符串数组其实每一个元素不是数字就是字母，那么我们可以通过使用charAt（）方法只访问0位置字符，来判断每个字符串是数字还是别的字符。如果这么想就错了，我第一遍就犯了这个错误，因为有的数字可能是负数所以charAt（0）访问到的是’-‘号导致’-‘这个符号被单独处理了，这显然是错误的，因此换个思路我们可以只访问字符串的最后一个字符这样就能判断该字符串是字母还是数字了。经过上述操作我们能够判断字符串是字母还是数字，如果是不是数字就按照C\D+的规则进行处理即可，如果是数字则直接将其添加到建立的ArrayList中去，当然这些添加和删减整数的操作都要有一个索引来记录位置变化，具体可以看代码。最后使用一个变量来累加最终保存在ArrayList中的每一个元素。
代码：
class Solution { public int calPoints(String[] operations) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int index = 0; for (int i = 0; i &lt; operations.length; i++) { char ch = operations[i].charAt(operations[i].length()-1); if (!Character.isDigit(ch)) { switch (ch) { case '+': list.add(list.get(index - 1) + list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d5c450c8a242f5dea598f0af7c59a40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f067de235c5f4138e4e399ad9d840174/" rel="bookmark">
			u-input 输入框失去焦点时 只保留2位小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;u-input placeholder="请输入金额（必填）" border="none" inputAlign='right' v-model="money" type='digit' @blur='onBlur' &gt; &lt;template slot="suffix"&gt; &lt;view&gt;元&lt;/view&gt; &lt;/template&gt; &lt;/u-input&gt; // 输入框失去焦点时触发 互助费只能保留2位小数 onBlur(){ this.money=this.money.replace(/^\D*(\d*(?:\.\d{0,2})?).*$/g, '$1'); if (this.money!= ''){ this.money= parseFloat(this.money).toFixed(2); }else { this.money= parseFloat(0).toFixed(2); } }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82b1fba5851d5e8479639741ed0fb81c/" rel="bookmark">
			Linux Kdump和Crash工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Kdump 和 Crash 工具介绍1.1 Kdump1.2 Crash 二、配置kdump和Crash工具2.1 安装kexec-tools2.2 设置crashkernel预留内存大小2.3 修改kdump默认配置/etc/kdump.conf2.4 开启kdump服务2.5 测试kdump功能 检查kdump是否开启成功2.6 手动触发crash2.7 查看生成的crash文件 三、Crash命令3.1 bt 命令3.2 dis命令3.3 mod 命令3.4 sym 命令3.5 rd 命令3.6 struct 命令3.7 其他参考文章： 一、Kdump 和 Crash 工具介绍 1.1 Kdump Kdump是一种基于kexec的Linux内核崩溃捕获机制，kexec的全称是Kernel execution，即立即执行，它可以跳过BIOS或者bootloader等引导程序，快速启动一个新的内核。这样第一个内核的内存就得以保留。在第二个内核中可以对第一个内核产生的崩溃数据进行分析。
1.2 Crash Crash是由Red Hat Enterprise Linux 项目师开发的，和Kdump配套使用的一个用于分析内核转储文件的工具。
Kdump+Crash分析宕机问题的流程并不复杂，首先Kdump会在内存中保留一块区域，这个区域用来存放捕获内核。当生产内核在运行过程中遇到崩溃等情况。Kdump会通过kexec机制自动启动捕获内核，跳过BIOS，以免破坏了生产内核的内存，然后把生产内核的完整信息（包括CPU寄存器，栈数据等）转储到指定文件中。接着使用Crash工具来分析这个转储文件，以快速定位宕机问题。
二、配置kdump和Crash工具 目前大部分服务器基于RHEL或者其开源版本Centos部署，本节介绍如何在Centos中配置和安装Kdump和Crash工具。
2.1 安装kexec-tools yum install kexec-tools 2.2 设置crashkernel预留内存大小 GRUB_CMDLINE_LINUX="rd.lvm.lv=centos/root rd.lvm.lv=centos/swap crashkernel=256M" 修改crashkernel的大小，我的系统内存是3G，保留了256M，注意预留内存大小，过小会导致生成coredump文件失败（不知道设置多少时，可以尝试每次增加128M）
修改后还需重新生成grub配置文件，重启系统才能生效
[vagrant@localhost ~]$ grub2-mkconfig -o /boot/grub2/grub.cfg [vagrant@localhost ~]$ reboot [root@localhost ~]$ cat /etc/default/grub GRUB_TIMEOUT=5 GRUB_DISTRIBUTOR="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82b1fba5851d5e8479639741ed0fb81c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8958cb365f4aa13b6fc68ba2bd06f82/" rel="bookmark">
			【前端】前后端的网络通信基础操作（原生ajax, axios, fetch）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 前后端网络请求工具 原生ajaxfetch apiaxios GET和POST请求 get只能发纯文本
post可以发不同类型的数据，要设置请求头，需要告诉服务器一些额外信息
测试服务器地址 有一些公共的测试 API 可供学习和测试用途。这些 API 允许你发送 HTTP 请求（GET、POST 等），并从服务器获取响应。以下是一些常用的公共测试 API：
JSONPlaceholder: Base URL: https://jsonplaceholder.typicode.comExample Endpoints: Posts: /postsComments: /commentsUsers: /users Usage Example (GET): https://jsonplaceholder.typicode.com/posts/1 ReqRes: Base URL: https://reqres.inExample Endpoints: Users: /api/usersSingle User: /api/users/2Create User: /api/users Usage Example (POST): https://reqres.in/api/users 原生ajax 前端页面代码
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="ajax_get.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; GET //原生ajax const xhr = new XMLHttpRequest(); //xhr.open('GET', 'http://wuyou.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8958cb365f4aa13b6fc68ba2bd06f82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96e11ecc321f96c73b275c4f868c87fd/" rel="bookmark">
			redis详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见三类存储系统 RDBMS：关系型数据库系统 Oracle、DB2、PostgreSQL、MySQL、SQL Server...
NoSQL：非关系型数据库，又包含四种流派 键值存储
Memcache、Redis
列式存储
Hbase、Cassandra
文档存储
MongoDB
图式存储
Neo4j
NewSQL：本身在设计上就支持分布式的关系行数据库系统 Aerospike、FoundationDB、RethinkDB...
redis特性 既是一个缓存又是一个存储
in-memory：所有工作都在内存中实现，在磁盘上存储的主要目的是为了冗余
支持持久化存储 基于快照方式：数据异步传输，从内存中传输到磁盘上并保存起来
AOF：把每一次的写操作都直接附加在一个文件后面实现数据存储 支持主从的高可用：借助sentinel实现一定意义上的HA
支持分布式集群：读写操作可以在多借点进行
数据结构服务器：支持存储：字符串、列表、哈希（映射）、集合、有序集合等等
单线程：核心模块是单线程，这样的设计可以避免同步代码阻塞主线程，从而提高性能
支持消息队列，支持发布订阅特性
评估数据： 100W个较小键值需要消耗100M内存
在常见的linux之上支持大约50W的并发
Redis与memcached比较 redis组成： redis-server
redis-cli：客户端一般不用，通常调用API来实现请求
redis-benchmark：压测工具
redis-check-dump &amp; redis-check-aof：检查redis的两种持久化后的文件是否存在错误
安装配置redis 安装：yum -y install redis
启动redis
service redis start
或 redis-server --help 查看命令帮助
配置文件： vim /etc/redis.conf
daemonize no #是否为守护进程默认为no，即便为no但是基于脚本启动时依然运行为守护进程
port 6379 #默认端口
tcp-backlog 511 #定义 tcp等待队列的长度为511。redis的并发性很高，但是前端的并发访问量非常大并且接收缓冲都满掉了就会额外在找一个地方把新进来的请求暂存下来这个位置就叫backlog，tcp协议通常都会有backlog
bind 127.0.0.1 #监听地址 # unixsocket /tmp/redis.sock #定义socket文件位置，如果客户端和redis在同一台主机上建议像mysql一样打开socket。基于socket的客户端和服务端通信，在内存中直接交换数据，不再经过tcp/ip协议栈进行封装再重新拆封
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96e11ecc321f96c73b275c4f868c87fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbfb18e44c70f940140409af48479b2c/" rel="bookmark">
			【分布式微服务专题】SpringSecurity OAuth2快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言阅读对象阅读导航前置知识笔记正文一、OAuth2 介绍1.1 使用场景*1.2 基本概念（角色）1.3 优缺点 二、OAuth2的设计思路2.1 客户端授权模式2.1.0 基本参数说明2.1.1 授权码模式2.1.2 简化（隐式）模式2.1.3 密码模式2.1.4 客户端模式 2.2 令牌的使用2.3 令牌更新 三、Spring Security OAuth2快速开始3.1 授权服务器的几个节点3.2 整体架构（授权码模式）3.3 代码整合（授权码模式）3.4 更新令牌3.5 基于redis存储Token 四、Spring Security Oauth2整合JWT4.1 整合JWT4.2 扩展JWT中的存储内容4.3 解析JWT 学习总结感谢 前言 这里面的笔记都是我这里抄抄那里抄抄得来的，然后也经过了一些简单的测试，主要是用来拓宽知识面用的，毕竟到了项目开发中，不会裸用这些技术框架，通常都是采用第三方集成框架。
另外需要说明的是，这里要介绍的Spring Security OAuth2框架应该有点过时了，在Spring官网已经没有了项目介绍，现在项目似乎已经升级，并且迁移为Spring Authorization Server项目。所以我打算学习完现在的OAuth2之后，继续学习Spring Authorization Server。
阅读对象 了解、熟悉Spring Security有过OAuth2使用经验 阅读导航 系列上一篇文章：《【分布式微服务专题】SpringSecurity快速入门》
前置知识 笔记正文 一、OAuth2 介绍 权威文档地址：OAuth2.0协议介绍
OAuth（Open Authorization，开放授权）是一个关于授权（authorization）的开放网络标准协议，允许用户授权第三方应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容。OAuth在全世界得到广泛应用，目前的版本是2.0版。
注意：OAuth2只是一种标准协议，或者叫作：规范！ 其实在我们计算机学习中，你会发现很多各种各样的规范，这些规范往往指的是一种约定，并不特指某一具体的项目，SpringSecurityOAuth2才是一个具体的项目。可别被带偏了呀
标准协议特点：
简单：不管是OAuth服务提供者还是应用开发者，都很易于理解与使用安全：没有涉及到用户密钥等信息，更安全更灵活开放：任何服务提供商都可以实现OAuth，任何软件开发商都可以使用OAuth 1.1 使用场景 原生app授权：app登录请求后台接口，为了安全认证，所有请求都带token信息，如果登录验证、请求后台数据。前后端分离单页面应用：前后端分离框架，前端请求后台数据，需要进行oauth2安全认证，比如使用vue、react或者h5开发的app第三方应用授权登录，比如QQ，微博，微信的授权登录 案例1：云快印
有一个【云快印】的网站，可以将用户存储在的百度网盘上的照片打印出来。用户为了使用该服务，必须让【云快印】读取自己储存在百度网盘上的照片。只有得到用户的授权，百度网盘才会同意【云快印】取这些照片。那么，【云快印】怎样获得用户的授权呢？
传统方法是，用户将自己百度网盘的用户名和密码，告诉【云快印】，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点：
【云快印】为了后续的服务，会保存用户的密码，这样很不安全百度网盘不得不部署密码登录，而我们知道，单纯的密码登录并不安全【云快印】拥有了获取用户储存在百度网盘服务所有资料的权力，用户没法限制【云快印】获得授权的范围和有效期用户只有修改密码，才能收回赋予【云快印】的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。 综上缺陷，这显然不是我们期待的方案。
案例2：CSDN登录
附上一张常见的OAuth2场景：CSDN接入微信QQ开放平台，用户可以通过微信QQ登录CSDN
*1.2 基本概念（角色） 角色：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbfb18e44c70f940140409af48479b2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea1f22e39cba410e66ef0627f0bc67a6/" rel="bookmark">
			团结引擎 | 发布微信小游戏的那些坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题1 问题：Failed to download file Build/安装包.framework.js.unityweb. Loading web pages via a file:// URL without a web server is not supported by this browser. Please use a local development web server to host content, or use the Build and Run option.
解决办法：
1.启用InternetInformationServices，重启电脑。
2.建立网站
3.在运行文件夹下添加配置文件web.config。
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!-- 有关如何配置 ASP.NET 应用程序的详细信息，请访问 https://go.microsoft.com/fwlink/?LinkId=169433 --&gt; &lt;configuration&gt; &lt;system.webServer&gt; &lt;httpProtocol&gt; &lt;!-- 允许跨域配置 --&gt; &lt;customHeaders&gt; &lt;add name="Access-Control-Allow-Origin" value="*" /&gt; &lt;add name="Access-Control-Allow-Headers" value="X-Requested-With,Content-Type,Authorization" /&gt; &lt;add name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea1f22e39cba410e66ef0627f0bc67a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b592453016726c13738af0ea0d749954/" rel="bookmark">
			压测clickhouse性能相关参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：压测ck性能一直上不去，但是ck负载不大。尝试调整参数，验证是否有性能提升
1、background_common_pool_size
Sets the number of threads performing background non-specialized operations like cleaning the filesystem etc. for tables with MergeTree engines. Could be increased at runtime and could be applied at server startup from the default profile for backward compatibility.
2 、 max_threads 验证有效
The maximum number of threads to execute the request. By default, it is determined automatically.
3、background_pool_size
Sets the number of threads performing background merges and mutations for tables with MergeTree engines.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b592453016726c13738af0ea0d749954/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d0c19d61c2c20bff08eb528ec04ef62/" rel="bookmark">
			PDF 文件操作指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PDF 文件操作指南 PDF 文件介绍 PDF 是一种便携式文档格式（Portable Document Format）的缩写，是由 Adobe 公司创建的一种用于文档交换的文件格式。PDF 格式的文件可以跨平台、跨操作系统和跨设备进行共享和查看，其最大特点是在不同设备上保持内容不变的能力。
以下是关于 PDF 文件格式的介绍：
历史和起源 创建者：由 Adobe 公司的联合创始人 John Warnock 提出概念，并由 Adobe 的团队开发。起源：PDF 最早于 1990 年推出，是一种可靠的电子文档格式，最初用于打印和交换电子文档，后来发展成为广泛使用的标准。 特点和优势 跨平台性：可以在各种操作系统和设备上进行浏览和共享，保持内容的一致性。内容不变性：无论在哪种设备上查看，其排版、格式和布局都保持不变。相对较小的文件大小：能够压缩文档，使其适合于网络传输和存储。高度安全性：可以添加密码、加密和数字签名以确保文档的安全性。支持多媒体：可以包含图像、表格、超链接、音频和视频等多种多媒体元素。 PDF 文件结构 PDF 文件由多个部分组成，其中包括：
Header（文件头）：包含文件的版本和起始信息。Body（主体部分）：包含文档的内容，如文本、图像、链接等。Cross-reference table（交叉引用表）：记录了文件中各个对象的位置。Trailer（尾部）：包含文件的结束信息和指向交叉引用表的链接。 PDF 文件的创建方式 使用专业软件：Adobe Acrobat 是创建和编辑 PDF 的主要工具，可以通过它编辑、组织和创建 PDF 文件。虚拟打印机：用户可以通过虚拟打印机（如Adobe PDF Printer或其他第三方虚拟打印机）将任何可打印的文档转换为 PDF 格式。在线转换工具：有许多在线服务或工具可以将不同格式的文档转换为 PDF。 PDF 的使用场景 电子书籍：许多电子书籍和文档以 PDF 格式发布，用户可以方便地在不同设备上阅读。官方文档：政府机构、公司和组织通常使用 PDF 格式发布文件，以确保格式在不同系统上的一致性。表格和表单：PDF 可以用于创建填写表格和表单，保留其格式不变，便于数据收集和共享。技术文档：软件文档、技术规范和学术论文等经常以 PDF 格式发布和共享。 总体来说，PDF 文件格式以其跨平台性、内容稳定性和安全性成为一种流行的文档交换格式，被广泛应用于各种场景和行业中。
当涉及读取 PDF 文件时，Python 中有几个流行的库可以使用，其中最常用的是 PyPDF2 和 pdfplumber，在本文章中仅介绍PyPDF2。
PyPDF2 PyPDF2 是一个 Python 库，用于处理 PDF 文件，它提供了一些功能，可以用来读取、操作和处理 PDF 文档。下面是关于 PyPDF2 库的特点和功能：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d0c19d61c2c20bff08eb528ec04ef62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f28baa74dd814fffe40e06049eb21a8/" rel="bookmark">
			盘点一个AI都无法解决的Python基础题目（下篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“Python爬虫与数据挖掘”，进行关注
回复“书籍”即可获赠Python从入门到进阶共10本电子书
今
日
鸡
汤
蜀之鄙有二僧：其一贫，其一富。
大家好，我是皮皮。
一、前言 前几天在Python白银交流群【大侠】问了一个Pandas实战的问题，一起来看看吧。上一篇文章说到，看上去AI给的答案，似乎让【大侠】不满意，遂来白银交流群问问大佬们。这一篇文章，我们一起来看看其他大佬给的代码。
二、实现过程 前面的文章中，我们看到了【瑜亮老师】和【东哥】给的代码，这里【甯同学】也给了一份具体的代码，如下图所示：
后来【瑜亮老师】针对上述代码，给了一个小建议，如下所示：
后来【论草莓如何成为冻干莓】也给了一份代码，如下所示：
这代码太秀了，顺利地解决了粉丝的问题。事实证明，能让AI都无法解决的代码问题，大都是自己并没有问清楚，论准确表达的重要性。
三、总结 大家好，我是皮皮。这篇文章主要盘点了一个Pandas实战的问题，文中针对该问题，给出了具体的解析和代码实现，帮助粉丝顺利解决了问题。
最后感谢粉丝【大侠】提出的问题，感谢【巭孬🕷】、【瑜亮老师】、【论草莓如何成为冻干莓】、【甯同学】给出的思路，感谢【莫生气】、【曾是惊鸿照影来】等人参与学习交流。
【提问补充】温馨提示，大家在群里提问的时候。可以注意下面几点：如果涉及到大文件数据，可以数据脱敏后，发点demo数据来（小文件的意思），然后贴点代码（可以复制的那种），记得发报错截图（截全）。代码不多的话，直接发代码文字即可，代码超过50行这样的话，发个.py文件就行。
大家在学习过程中如果有遇到问题，欢迎随时联系我解决（我的微信：pdcfighting1），应粉丝要求，我创建了一些ChatGPT机器人交流群和高质量的Python付费学习交流群和付费接单群，欢迎大家加入我的Python学习交流群和接单群！
小伙伴们，快快用实践一下吧！如果在学习过程中，有遇到任何问题，欢迎加我好友，我拉你进Python学习交流群共同探讨学习。
------------------- End -------------------
往期精彩文章推荐：
盘点一个Python自动化办公实战实现数据汇总填充（方法五）
盘点一个Python自动化办公Excel数据填充实战案例（中篇）
盘点一个使用Python自动化处理GPS、北斗经纬度数据实战（下篇）
Typora导出的PDF目录标题自动加编号
欢迎大家点赞，留言，转发，转载，感谢大家的相伴与支持
想加入Python学习群请在后台回复【入群】
万水千山总是情，点个【在看】行不行
/今日留言主题/
随便说一两句吧~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2560043ab8f3b90d6e2a5ee9ebb1bb73/" rel="bookmark">
			美团实习二面原题，网友直呼太难。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天这题是LeetCode的第82题：删除排序链表中的重复元素 II，一网友在美团面试的时候遇到这道题，不过很遗憾的是该网友没有做出来，其实这是一道中等难度的题，还不算太难。除了美团以外，字节，腾讯也都考过，我们来看下。
问题描述
来源：LeetCode第82题
难度：中等
给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回已排序的链表 。
示例1：
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
示例2：
输入：head = [1,1,1,2,3]
输出：[2,3]
链表中节点数目在范围 [0, 300] 内
-100 &lt;= Node.val &lt;= 100
题目数据保证链表已经按升序 排列
问题分析
这题让把链表中重复的节点全部给删除，因为题中说了链表是排序的，所以重复的节点肯定是挨着的。对于每一个节点都要与他后面的节点比较，如果相同就要把它后面的给删除，接着继续比较。
这里要注意如果有相同的，不要把相同节点的第一个节点给忘了，我们可以使用递归的方式来解决，代码如下。
JAVA：
public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) return head; if (head.val != head.next.val) { // 如果当前节点和下一个节点的值不相同，不需要删除 head.next = deleteDuplicates(head.next); return head; } else { // 如果当前节点和下一个节点的值相同，说明出现了重复的， // 把重复的全部给删除。 while (head.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2560043ab8f3b90d6e2a5ee9ebb1bb73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d4f912e57b359d335b1d4039082b199/" rel="bookmark">
			java编程中，保证接口幂等性的实现方案讨论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是幂等性 数学中的幂等是指f(x) = f(f(x))，编程领域的术语是指同一个操作，在重复提交的情况下，最终产生的影响是不变的。举例说：
提交订单时，用户在购物车界面，重复点击“下单”，服务端有且只会创建一个订单。（客户端在做交互设计的时候，用户点击了“下单”就不能再次点击，立马把按钮置灰。但是，这里会有网络的重试或者弱网等异常，导致服务端可能接收到两次http请求。如果服务端没有对http接口做幂等，那么可能会生成两个重复的订单）用户支付完成后，第三方支付会回调服务端的支付回调接口，服务端然后更新支付订单的状态，最后回调通知其他系统，比如订单系统和积分系统。这里的幂等性是指无论被回调多少次，不会重复更新支付订单的状态和回调通知其他系统。 总结： 对于重要的接口，在实现接口时，一定要考虑是否具备幂等性。
既然不是所有的接口，那都有哪些场景的接口，会需要考虑幂等性呢？
二、哪些场景需要实现幂等 1、异步回调 比如上文说的支付回调接口，也包括在其他的异步操作下的对外接口。
你都必须考虑是否支持幂等。
举个例子，课程服务调用课堂服务的批量创建课堂接口，由于后者是异步的操作，所以待创建完成，课堂服务将要回调通知课程服务。
于是，课程服务需要开放一个接口出来，此接口就必须支持幂等。
2、消息队列 有些业务，需要削峰填谷，会先把异步操作的消息给到Mq，然后在监听方法中消费该mq消息。这里举一个异步复制某文件夹及其下的所有文件为例。
3、网络重试 当出现网络超时，需要重试的时候，你的接口是否支持幂等呢？
比如openfeign就很好地支持retry机制。
三、哪些是天然幂等的 在进一步阐述如何实现幂等前，我们有必要搞清楚，哪些是天然幂等的。
都说自己每天写的代码都是CRUD，我们现在就来分析下它们是否幂等。
查询方法，都说查询的实现往往是最复杂的代码，幸好，它就是幂等的。虽然你前后的查询返回结果可能不一样，然而并不会影响服务端的分毫。
基于版本号或者状态机的更新操作，具体到sql语句，有两种写法，见下：
# 不建议的写法 update PayTrade t set t.status = :newStatus, t.outTradeNo = :outTradeNo, t.payOkDate = :payOkDate where t.channelTradeNo = :channelTradeNo # 建议你这么写 update PayTrade t set t.status = :newStatus, t.outTradeNo = :outTradeNo, t.payOkDate = :payOkDate where t.channelTradeNo = :channelTradeNo and t.status = :oldStatus 他们的区别就是是否要求前一个状态，后面的sql多了一个“ t.status = :oldStatus ”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d4f912e57b359d335b1d4039082b199/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d308f138ac38cb054c9a3918835f0a7/" rel="bookmark">
			CentOS Stream 9配置yum源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Red Hat 9 &amp;&amp; CentOS Stream 9 配置阿里云yum 源CentOS Stream 9 配置阿里云 yum 源Red Hat 9 配置阿里云 yum 源 Red Hat 9 &amp;&amp; CentOS Stream 9 配置阿里云yum 源 CentOS Stream 9 配置阿里云 yum 源 备份原有的 yum文件
[root@localhost ~]# cd /etc/yum.repos.d/ [root@localhost yum.repos.d]# ls centos-addons.repo centos.repo [root@localhost yum.repos.d]# mkdir bak [root@localhost yum.repos.d]# cp -r *.repo bak/ 配置阿里 yum 源
[root@localhost yum.repos.d]# pwd /etc/yum.repos.d [root@localhost yum.repos.d]# vim centos.repo [baseos] name=CentOS Stream $releasever - BaseOS baseurl=https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d308f138ac38cb054c9a3918835f0a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3621fb5b4468024da95636a8afe4b897/" rel="bookmark">
			C&#43;&#43; 开发 &#43; VSCode 调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 开发 + VSCode 调试 MSYS2 安装 gcc、make下载安装MSMYS2pacman 添加镜像源 GCC1. 安装2. 查看结果3. 环境变量 GDB VSCode 调试所需插件创建项目调试代码1. tasks.json 配置任务2. launch.json 配置调试3. 运行 更进一步的 C/C++ 设置 参考资料 MSYS2 安装 gcc、make 下载 官方下载
清华大学开源软件镜像站：MSYS2 软件仓库
安装 MSYS2： 主要功能是提供一个在Windows操作系统上模拟类Unix环境的开发和构建工具集。它提供了一个模拟POSIX系统的命令行接口和包管理器（Pacman）。MSYS2基于Cygwin技术，但它更专注于构建原生Windows应用程序。它的目标是创建一个易于使用的开发平台，使得开发者能够在Windows上编译和运行那些原本在Unix/Linux环境下开发的开源软件。 MinGW-w64： 是一个项目，其目的是为Windows提供GCC（GNU Compiler Collection）和其他工具链的移植版本，以便能够直接生成64位或32位Windows原生可执行文件，无需依赖Cygwin或其他兼容层。MinGW-w64支持现代Windows特性，并解决了早期MinGW在64位系统支持上的局限性。 两者的关系： MSYS2 集成了 MinGW-w64 工具链，使得用户可以通过简单的命令行操作安装和使用 GCC 编译器来编译 Windows 原生程序。使用 MSYS2 的开发者可以利用其提供的包管理系统快速获取并更新 MinGW-w64 等工具链及相关库文件，简化了Windows下的跨平台开发流程。 MSMYS2 下载后直接运行安装即可，我装在： D:\msys64
安装好后，出现多个快捷方式，下表简单是介绍
快捷方式描述MSYS2 CLANG64使用Clang编译器的64位版本环境，提供基于LLVM的C、C++和Objective-C编译器工具链，用于生成Windows 64位原生可执行文件。MSYS2 CLANGARM64同样基于Clang，但针对ARM64架构（如Windows on ARM），为ARM64平台提供编译环境。MSYS2 MINGW32运行32位MinGW-w64工具链的命令行环境，适用于编译面向32位Windows系统的原生应用。MSYS2 MINGW64提供64位MinGW-w64工具链的命令行环境，主要用于编译运行在64位Windows系统上的原生应用，是常用的开发选项。我用的这个MSYS2 MSYS基于POSIX兼容层的Shell环境，提供较为完整的Unix/Linux-like环境，支持那些需要较高程度POSIX兼容性的软件编译或脚本执行。MSYS2 UCRT64使用Universal CRT (UCRT) 的64位工具链环境，该环境下的工具链依赖较新的Windows SDK，可能包含对最新Windows特性和API的支持。 接下来的操作需要用到 pacman 命令，此表是简单的介绍，先了解一下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3621fb5b4468024da95636a8afe4b897/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd058061d9706adb0325a76a62452240/" rel="bookmark">
			谭浩强C语言课后习题-入门与顺序结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一题：第一个HelloWorld程序 题目描述 学习了输出语句，请参照例题，编写一个程序，输出以下信息：
**************************
Hello World!
**************************
注意：Hello与World之间有一个空格以及大小写问题
*也是输出的一部分，别光打印Hello World！
输入格式 无需输入
输出格式 **************************
Hello World!
**************************
样例输入 无 样例输出 ************************** Hello World! ************************** #include&lt;stdio.h&gt; int main() { printf("**************************\n"); printf("Hello World!\n"); printf("**************************\n"); return 0; } 第二题：三个数最大值 题目描述 编写一个程序，输入a、b、c三个值，输出其中最大值。
输入格式 一行数组，分别为a b c
输出格式 a b c其中最大的数
样例输入 10 20 30 样例输出 30 #include&lt;stdio.h&gt; int main() { int a, b, c, m; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); if (a &gt; b) m = a; else m = b; if (c &gt; m) m = c; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd058061d9706adb0325a76a62452240/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f71e240c44e52c0cf35ce2bff2271053/" rel="bookmark">
			【Proteus仿真】【Arduino单片机】蔬菜大棚保温层卷放智能控制系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、功能简介二、软件设计三、实验现象联系作者 一、功能简介 本项目使用Proteus8仿真Arduino单片机控制器，使用LCD1602显示模块、按键模块、28BYJ48步进电机模块、DS18B20温度传感器等。
主要功能：
系统运行后，LCD1602显示温度值、温度阈值、保温层开关状态。
如果温度高于上限，伸开保温层;
如果温度低于下限、合上保温层;
二、软件设计 /* 作者：嗨小易（技术QQ群：570487280） */ //系统数据显示 void sys_data_show(void) { while(1) { //温度值显示 lcd1602_show_nums(5,0,sys_ctrl.temp,2,0); //温度阈值显示 lcd1602_show_nums(4,1,sys_ctrl.templ,2,0); lcd1602_show_nums(13,1,sys_ctrl.temph,2,0); //保温层状态显示 if(sys_ctrl.runflag==1) lcd1602_show_string(11,0,"Open "); else lcd1602_show_string(11,0,"Close"); //阈值设置位置闪烁 switch(sys_ctrl.mode) { case 1://温度下限 lcd1602_show_string(4,1," "); delay_ms(100); lcd1602_show_nums(4,1,sys_ctrl.templ,2,0); break; case 2://温度上限 lcd1602_show_string(13,1," "); delay_ms(100); lcd1602_show_nums(13,1,sys_ctrl.temph,2,0); break; } break;	} } //系统参数设定 void sys_data_set(void) { u8 key=0; key=key_scan(0); //模式设置 if(key==KEY3_PRESS) { sys_ctrl.mode++; if(sys_ctrl.mode&gt;2)sys_ctrl.mode=1; } //在设置模式下，加 else if(key==KEY1_PRESS) { switch(sys_ctrl.mode) { case 1://温度下限 sys_ctrl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f71e240c44e52c0cf35ce2bff2271053/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/526309df340e9dcd1b5a927a4ab13d18/" rel="bookmark">
			机器学习指南：如何学习机器学习？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习
一、介绍 你有没有想过计算机是如何从数据中学习和变得更聪明的？这就是机器学习 （ML） 的魔力！这就像计算机科学和统计学的酷炫组合，计算机从大量信息中学习以解决问题并做出预测，就像人类一样。
可以这样想：想象一下，你想教你的电脑讲有趣的笑话。你给它喂笑话、愚蠢的双关语和敲门声。随着时间的流逝，计算机开始理解是什么让笑话变得有趣，很快，它就破解了自己的搞笑单行本！
这就是机器学习的强大功能，它无处不在，从推荐您可能喜欢在电视上观看的内容到帮助医生诊断疾病。很酷，对吧？
现在，如果你对自己学习这项了不起的技能感到好奇，本指南就像你个人的ML土地地图。我们将分解基本想法，向您展示如何将它们付诸行动，甚至在您准备好时帮助您探索高级主题。
因此，无论您是刚入门的新手还是想要升级的专业人士，本指南都是您进入机器学习世界的激动人心的旅程的伴侣！准备好解开智能计算机的秘密，看看你们可以一起创造哪些令人惊奇的东西。
掌握机器学习基础知识
二、机器学习初学者指南 准备好解开机器学习的秘密了吗？无需魔术解码环;只是一点点好奇心和这个友好的指南！
I. 什么是机器学习？ 想象一下，一台计算机像你一样学习，吸收信息并用它来做出明智的决策。这就是机器学习的魔力！这些算法可以分析数据、发现模式，甚至进行预测，而不是遵循严格的指令。把它想象成为为你的电脑训练一个超能力的大脑。
II. 知识的基石： 在深入研究花哨的算法之前，让我们先打下基础。
特征：将这些视为数据的构建块，就像食谱中的成分一样。它们可以是数字、文本，甚至是描述某事的图像。标签：这些标签告诉计算机每条数据代表什么。想象一下给猫和狗的照片贴上标签——“猫”标签有助于计算机在未来学会识别猫科动物。训练数据：这是计算机的学习材料，是用于学习和改进的大量标记数据的集合。测试数据：这就像电脑的流行测验！它是看不见的数据，用于测试经过训练的模型对新信息的性能。 三、机器学习的类型 机器学习不是一种放之四海而皆准的方法。有不同的学习方式，每种都有自己的优势：
监督学习：想象一下，让老师解释事情并指出正确的答案。这就是监督学习！计算机从标记的数据中学习，例如根据过去的例子识别垃圾邮件。无监督学习：这就像你自己探索一个新地方，发现模式，在没有地图的情况下理解事物。计算机分析未标记的数据以查找隐藏的结构，例如将具有相似购物习惯的客户分组。强化学习：想想玩游戏，从错误和成功中吸取教训。强化学习奖励计算机做出正确的决策，帮助它驾驭复杂的情况，如下棋或控制机器人。 四、 学习语言：算法和模型 现在您已经了解了学习风格，让我们来认识一些明星玩家：
线性回归：想象一下，根据学习时间预测考试成绩。线性回归就像在数据点中绘制一条最佳拟合线以进行连续预测。分类算法：这些就像对数据进行分类，将事物分为不同的类别。逻辑回归、决策树和支持向量机是一些流行的选择。聚类算法：考虑按颜色或图案整理袜子。聚类算法将相似的数据点组合在一起，例如查找客户行为或基因表达的模式。 请记住，这只是机器学习之旅的开始！有了工具箱中的这些基础知识，您就可以探索更高级的概念并构建自己的智能机器了。因此，请继续学习，不断提出问题，并继续解锁机器学习的魔力！
掌握机器学习技能
五、机器学习的基本技能 在我们释放机器学习的超级脑力之前，让我们先来构建一些坚固的构建块！将这些技能视为工具箱中的工具，随时准备帮助您驾驭激动人心的 AI 世界。
A. 需要数学背景 线性代数：将数据想象成构建块，线性代数向我们展示了如何将它们整齐地排列在行和列中。这有助于我们理解计算机如何学习不同信息之间的关系。微积分：你有没有想过计算机是如何找到最佳答案的？微积分赋予他们探索不同可能性并选出赢家的超能力！统计学：这是模式和预测的语言。把它想象成学习如何根据你以前看到的东西做出有根据的猜测。 B. 编程技能： 蟒：就像英语帮助我们相互交谈一样，Python 帮助我们与计算机交谈。它是最流行的机器学习语言，所以学习一些基本的 Python 就像解锁密码一样！数据操作和分析：想象一下，有一个充满信息的凌乱房间。像 NumPy 和 pandas 这样的库帮助我们组织和清理数据，使计算机更容易理解。 C. 数据操作和分析工具： NumPy的：这个库就像 Python 的超级计算器，可以更快、更轻松地在机器学习中处理数字。熊猫：把它想象成一个强大的类固醇电子表格！Pandas 帮助我们以清晰有序的方式处理和分析数据。 请记住，你的基础越牢固，就越容易用机器学习构建令人惊叹的东西。因此，请慢慢来，练习这些技能，并准备好解锁人工智能的魔力！
ML材料
六、机器学习资源 准备好进入机器学习的世界了吗？系好安全带，因为互联网上充斥着惊人的资源来帮助您入门！无论您是好奇的初学者还是经验丰富的学习者，每个人都能找到适合自己的东西。让我们来探索一下您的选择：
A. 在线课程和平台： Coursera的：把它想象成你的人工智能学院！参加顶尖大学和专家的课程，例如吴恩达著名的“机器学习”课程。edX：加入世界各地的知名机构，通过机器学习课程甚至认证来提升您的技能。大胆的：通过实用的“纳米学位”课程掌握工艺。这些提供动手项目和专家指导，将您变成编码英雄。 B. 适合初学者和高级学习者的书籍： Aurélien Géron 的“Hands-On Machine Learning with Scikit-Learn， Keras， and TensorFlow”：这本书是你的实用伙伴，非常适合想要直接进入并开始构建东西的初学者。Christopher M.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/526309df340e9dcd1b5a927a4ab13d18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/619794cb7cca1f746cfadf26ffa92729/" rel="bookmark">
			HarmonyOS鸿蒙应用开发——原生与H5通信框架DSBrigde-HarmonyOS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 介绍安装使用原生JavaScript进度回调 参考 介绍 HarmonyOS版的DSBridge，通过本库可以在鸿蒙原生与JavaScript完成交互，相互调用彼此的功能。
目前兼容Android、iOS第三方DSBridge库的核心功能，基本保持原来的使用方式，可以放心接入到项目中，后续会持续迭代保持与Android库相同的功能，减少前端和客户端的适配工作。
支持的功能：
支持以类的方式集中统一管理API；支持同步和异步调用；支持进度回调/回传：一次调用，多次返回；支持API是否存在的测试 (当前仅支持检测原生API，在调用call()方法时会自检测) 暂不支持的功能：
不支持API命名空间不支持JavaScript的事件侦听器关闭页面 源码：
DSBridge-HarmonyOSDSBridge-AndroidDSBridge-IOS 由于DSBridge库作者已经停止维护了，Android端建议使用 https://github.com/751496032/DSBridge-Android ，目前本人在维护。
安装 ohpm install @hzw/ohos-dsbridge 使用 原生 1、在原生新建一个类继承BaseBridge，实现业务API
, 通过类来集中统一管理API，方法用@JavaScriptInterface()标注，是不是很眼熟呢，加一个@JavaScriptInterface()标注主要为了使用规范，是自定义的装饰器，与Android保持一致性。
export class JsBridge extends BaseBridge { private cHandler: CompleteHandler = null /** * 同步 * @param p * @returns */ @JavaScriptInterface(false) testSync(p: string): string { LogUtils.d("testSync: " + JSON.stringify(p)) return "hello native" } /** * 异步 * @param p * @param handler */ @JavaScriptInterface() testAsync(p: string, handler: CompleteHandler) { LogUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/619794cb7cca1f746cfadf26ffa92729/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d92f7e1a03107414644083010ffe76/" rel="bookmark">
			PMP考试流程，第一步都做错了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报名的流程看下面7个步骤吧，很完整（可以后台联系我，内推机构）
1.在PMI英文网站注册 PMI（英文）网站注册帐号提交项目经验
提交5个工作日后PMI审核通过一年有效期
2.在外专局PMP网站进行注册 到 中国国际人才交流基金会 （中文）网站注册帐号
考前2月左右报考通道开放报考
3.缴纳费用 登录基金会网站--选择 项目管理 报名--点击【报名参加考试】
填写基本信息-填写PMl帐号密码及一年有效期
审核3-5个工作日---通过/未通过（未通过需要继续修改）
审核通过--状态为付费--点击付费在线缴考试费3900元
（不支持微信支付宝，可支持储蓄卡，个别信用卡）
4.获得考试信息 1.交完考试费--基金会考试状态为等待预约
2.考点预约考位--10-15个工作日
3.预约完成，收到PMI预约考试信息邮件
5.参加考试 大陆考试时间一般：3月，6月 9月，12月
1.考前3天登录基金会下载打印准考证（A4黑白打印）
2.带上身份证，提前进入考点
每次考试注意事项/需要带资料不完全一样，可以联系培训老师了解
6.查询考试成绩：通过/未通过 考完1-2个月左右，收到PMI邮件告知是否通过：congratulations/Thank you（fail）
收到邮件后登录PMI官网查询成绩
7.领取书证书 注：PMP考试有商业环境、人、环境三个领域，每个领域的成绩分为四个等级
A：Above Target（高于目标）
T：Target（目标水平）
B：Below Target（低于目标）
N：Needs Improvement（需要提高的）
所以PMP最好的成绩为3A。
请注意，本次考试新增了三个板块：流程、人员和商业环境，每个板块的题目数量和权重都不相同。因此，即使两人的等级相同，也有可能一个合格而另一个不合格。具体的情况取决于成绩饼状图，可以清楚地看出哪个板块的内容未通过。
备考资料分享如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70d5a129d29563d97ff61768ece8e835/" rel="bookmark">
			【owt-server】一些构建项目梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【owt-server】清理日志：owt、srs、ffmpeg
【owt】p2p client mfc 工程梳理【m98】webrtc vs2017构建带符号的debug库【OWT】梳理构建的webrtc和owt mfc工程 m79的mfc客户端及owt-client m98的vs2017 构建的owt-p2p-client 联想笔记本： D:\XTRANS\m98_rtc\xrtc-webrtc\owt-client\P2PMFC-E2E-m98 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c4251c8badd3e3a60ad2ab0f8522b3c/" rel="bookmark">
			软考中级，哪个通过率高且简单？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在软考中级科目中，广受关注的包括软件设计师、网络工程师、系统集成项目管理工程师和数据库系统工程师等。其中，软件设计师是一个备受瞩目的职位，负责软件系统的设计、开发和维护。网络工程师则专注于网络设备的配置和管理，确保网络的正常运行和安全性。系统集成项目管理工程师主要负责系统集成项目的规划、组织和管理。数据库系统工程师则负责数据库的设计、优化和管理。不过，对于备考信息安全工程师，个人建议要谨慎，因为这是近几年新出的科目，网上的相关资料相对较少。
根据很多备考者的反馈，系统集成项目管理师考试相对较易通过。与其他中级软考科目相比，系统集成项目管理师考试的难度较低，报考者无论是否有基础都可参加，并且无需特定的报名条件。这门考试的难度适中，主要涉及理论知识，只有少部分内容涉及技术知识。对于想要考取中级证书的人来说，选择相对简单的科目进行考试是明智之举，不考白不考。总的来说，中级证书的含金量差别不大。哈哈！
因为考过，所以告诉你如何 一次过（经验分享）高效备考，不走弯路！ 本考试设置的科目包括 ：
（1）系统集成项目管理基础知识，考试时间为150分钟，笔试，选择题；
（2） 系统集成项目管理应用技术 （案例分析），考试时间为150分钟，笔试，问答题。
备考锦囊，仅供参考 1、教材
教材对于学习项目管理非常重要，尤其是《系统集成项目管理工程师教程（第2版）》这样由清华大学出版的教材，它包含了考试的大部分内容。建议按照教材的顺序来学习，通过字面意思和个人理解，对项目管理有一个初步的理解。在开始学习时，可以先阅读自己比较熟悉的内容。
虽然有些同学觉得教材太厚，不愿意去仔细阅读，但是考试中85%的题目都来源于教材原文的改编，所以充分利用教材和真题对于通过考试来说是必不可少的。
此外，不建议大家在没有完整通读教材的情况下，直接阅读网上那些列出一条条知识点的材料。这种材料会让你感到挫败，因为你可能根本记不住这些孤立的知识点，而且你不知道这些知识点是从哪里来的，也不知道它们是怎么衍生出来的，所以在没有基础的情况下可能根本无法理解。
而通过阅读教材，你可以从上下文中的定义来理解这些知识点的含义和背后的原理，帮助你将前后的知识联系起来，形成知识的脉络和思维的图谱，从而加深对知识的印象，快速记住知识点。因此，要认真阅读教材，理解每一部分的意思，弄清楚它们讲的是定义、分类还是作用，真正将内容吸收并理解。
2、做真题
认真做真题非常重要。它可以帮助我们了解考试中可能出现的题型和题目的权重分布，从而让我们有针对性地复习和重点关注某些章节。在刷题时，不要只注重数量，而要注重质量和针对性。做真题不仅可以检查复习情况，还可以通过做题的过程联想到相关的知识点，从而巩固所学内容。在做题的过程中，多思考，这样才能使做真题的效果更加显著！
3、上午题的特点是题量多而杂，但都是客观题，遇到不会的可以试着猜一下。建议大家做题时多做笔记，多思考就好。我在某赛的题库中共做了13套上午题和10套下午题，这样在考试时就能避免紧张的情况。
4、下午题的关键是要记住一些知识点，以免在答题时不知道如何回答。通过多做真题，就能渐渐掌握问题的关键点。下午题中必定会涉及到进度管理或挣值管理等计算题，而且这些计算题很容易得分。做题过程中会形成一个完整的知识框架，包括五大过程组、九大知识领域和四十四个管理过程。
拿分技巧 选择题
了解题目要点。在做选择题时，要仔细阅读题目，逐字逐句地理解题目的要求。不要草率地读题，防止错过关键信息。在确认题目所问内容后再开始解答，避免误解导致错误答案。
从易到难。无论事先如何努力复习，考试时总会遇到一些没有见过的题目。这时要保持冷静，不要固执地纠结于无法解答的题目上。可以先跳过那些题目，不要浪费时间纠结，而是专注解答其他相对简单的题目。
有所取舍。如果遇到确实无法解答的题目，即使是考完所有题目后重新检查时也无法解答的题目，要学会“果断舍弃”。当然，并非叫你不选任何选项，可以选择一个你觉得稍微有一点儿把握的选项，至少还有25%的可能性。
案例分析题
列出提纲。非常重要的一步是列出提纲！即使时间很紧，也应该列出一个简单的提纲，哪怕只是几个字，只要自己能看懂即可。不列提纲的话，写作时容易变得混乱无章，所以列提纲非常关键，能让你的答案更有逻辑性。
分点作答。可以使用1、2、3…的方式进行分点作答，方便评分者检查和给分。这样做会使评卷教师更清楚地看到你的得分点，避免遗漏。大家都知道，条理清晰对于这门学科来说非常重要。
书写整洁。不需要过分华丽，但要求书写整洁，避免出现难以辨认的字迹。主要是让评卷人能够清楚地看到你的答案，不要让他们错过你的得分点。
备考资料分享如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/328bae4b78c3fb2259d3f40ab59a2d0d/" rel="bookmark">
			K8S Nginx Ingress Controller client_max_body_size 上传文件大小限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 现象 k8s集群中，上传图片时，大于1M就会报错 413 Request Entity Too Large
Nginx Ingress Controller 的版本是 0.29.0
解决方案 1. 修改configmap kubectl edit configmap nginx-configuration -n ingress-nginx 在 ConfigMap 的 data 字段中设置参数：
data: proxy-body-size: "30m" 示例：
apiVersion: v1 kind: ConfigMap metadata: name: nginx-configuration namespace: ingress-nginx labels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx data: proxy-body-size: "30m" 2. 手动重新载入 Nginx kubectl delete pod -n ingress-nginx [nginx-ingress-controller-pod-name] 3. 验证 查看nginx配置中client_max_body_size的值
kubectl exec -n ingress-nginx [nginx-ingress-controller-pod-name] -- cat /etc/nginx/nginx.conf 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c01f1fd154e517c675b3fcbaa2bb525/" rel="bookmark">
			Docker AOSP `GLIBC_2.33‘ not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： /src/out/target/product/applea/obj/BOOTLOADER_OBJ/build-applea/mkheader: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.33' not found (required by /src/out/target/product/applea/obj/BOOTLOADER_OBJ/build-applea/mkheader) /src/out/target/product/applea/obj/BOOTLOADER_OBJ/build-applea/mkheader: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.34' not found (required by /src/out/target/product/applea/obj/BOOTLOADER_OBJ/build-applea/mkheader) 解决方法： 删除OUT/target下的目录，重新编译就可以
虽然可能会耗时一点，但是确实管用
问题的原因是，我最开始使用的Ubuntu 22.0.4编译的，后来又用docker 18.0.4编译，
OUT/target目录下的东西没有删除，导致有的so是Glibc_2.33编译，但是18.0.4是没有这个库的。
这个问题苦恼了2天。啊真是难似西天取经
第二种，给docker安装GLIBC_2.33
caoxinyu@caoxinyu-HP-Pro-Tower-480-G9:~/rom$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bc01a62af9a4 apple "/bin/sh -c 'chroot …" 2 hours ago Up 2 hours nice_ellis 81f4977552fc android-build-bionic "/bin/sh -c 'chroot …" 16 hours ago Up 16 hours nostalgic_ellis docker exec -ti -u root bc01a62af9a4 bash 就可以以root身份进入镜像，从而安装你需要的库 您可以使用以下列表中的任何一个源镜像只要往您的 /etc/apt/sources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c01f1fd154e517c675b3fcbaa2bb525/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27cb7a764d9a3e35b93e0ba51701a05f/" rel="bookmark">
			1045 - Access denied for user ‘root @223.98.184.126‘ (using password: YES)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql 1045错误 1 知识小课堂1.1 Mysql 1045错误1.2 mysql 常见的错误代码 2 问题呈现3 问题解决3.1 开始前的准备3.1.1 防火墙开端口3.1.2 宝塔管理控制 3.2 问题解决步骤 Navicat 连接数据库的时候报错，本文就是解决此问题。
1 知识小课堂 1.1 Mysql 1045错误 MySQL的1045错误是一个常见的错误，表示用户无法连接到数据库，因为提供的用户名和密码无效。
这个错误的完整消息通常是：“Access denied for user ‘username’@‘hostname’ (using password: YES)”。
这里是一些可能的解决步骤：
检查用户名和密码：确保您使用的用户名和密码是正确的。检查主机名：确保您尝试连接的主机名是正确的。如果您的应用程序尝试从不同的主机或IP地址连接，您可能需要编辑MySQL用户的主机设置。检查MySQL配置：有时候，MySQL配置可能会阻止某些用户从特定主机连接。您可以检查my.cnf或my.ini文件中的bind-address设置，确保它允许您尝试连接的主机。重置密码：如果您忘记了密码，您可能需要重置它。这通常涉及到以安全模式重新启动MySQL服务器，并使用一个有足够权限的账户重置密码。检查用户权限：使用以下命令检查用户的权限： SHOW GRANTS FOR 'username'@'hostname'; 如果用户没有足够的权限，您可能需要添加或修改权限。
查看日志文件：查看MySQL的错误日志文件，它通常位于/var/log/mysql/error.log（取决于您的安装和配置）。日志文件可能包含有关为什么连接被拒绝的更多信息。防火墙或安全组：确保没有任何防火墙或安全组规则阻止您的应用程序主机连接到MySQL服务器。重新安装或修复MySQL：在极端情况下，如果上述所有方法都不起作用，您可能需要考虑重新安装或修复MySQL服务器。 1.2 mysql 常见的错误代码 MySQL常见的错误代码有很多，以下是其中一些常见的错误代码：
1045 - 访问被拒绝，因为提供的用户名和密码无效。
1040 - 连接过多。
1042 - 无法获得该地址给出的主机名。
1045 - 访问被拒绝，因为用户 ‘%s’@‘%s’ 的密码不正确（使用密码：%s）。
1046 - 未选择数据库。
1047 - 未知命令。
1039 - 读取文件 ‘%s’ 时出现意外EOF。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27cb7a764d9a3e35b93e0ba51701a05f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7479af016b028a7ba1fd53743b1363fd/" rel="bookmark">
			Python - 深夜数据结构与算法之 Two-Ended BFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.引言
二.双向 BFS 简介
1.双向遍历示例
2.搜索模版回顾
三.经典算法实战
1.Word-Ladder [127]
2.Min-Gen-Mutation [433]
四.总结
一.引言 DFS、BFS 是常见的初级搜索方式，为了提高搜索效率，衍生了剪枝、双向 BFS 以及 A* 即启发式搜索等高级搜索方式。剪枝通过避免不必要或者次优解来减少搜索的次数，提高搜索效率；双向 BFS 通过层序遍历从首尾逼近答案，提高搜索效率；启发式搜索则是从优先级的角度出发，基于优先级高低搜索，提高搜索效率。本文主要介绍双向 BFS 的使用。
二.双向 BFS 简介 1.双向遍历示例 ◆ 双向连通图
求 A -&gt; L 所需最短路径。
◆ 遍历层级关系
不同颜色代表不同层级的 BFS，绿色为 root，蓝色为第二层，从左向右递推。
◆ 双向遍历
从 A/L 同时层序遍历，当二者扩散的点重合时，左右路径长度相加即为最短路径。
2.搜索模版回顾 ◆ DFS - 递归
◆ DFS - 非递归 ◆ BFS - 栈 三.经典算法实战 1.Word-Ladder [127] 单词接龙: https://leetcode.cn/problems/word-ladder/description/
◆ 单向 BFS
class Solution: def ladderLength(self, beginWord, endWord, wordList): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7479af016b028a7ba1fd53743b1363fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be74ef95a8c9f549670519d0d39dc156/" rel="bookmark">
			ORACLE之rman备份恢复及故障处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、参数文件恢复
1.1 首先查看归档模式是否打开
SQL&gt; archive log list Database log mode No Archive Mode Automatic archival Disabled Archive destination /u01/app/oracle/product/11204/db/dbs/arch Oldest online log sequence 4 Current log sequence 6 1.2 关闭数据库
SQL&gt; shutdown immediate Database closed Database dismounted. ORACLE instance shut down. 1.3 将数据库启动到mount状态
SQL&gt; startup mount ORACLE instance started. Total System Global Area 776646656 bytes Fixed Size 2257272 bytes Variable Size 507514504 bytes Database Buffers 264241152 bytes Redo Buffers 2633728 bytes Database mounted.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be74ef95a8c9f549670519d0d39dc156/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b5e32a636c0083050fdb683fe6d26a5/" rel="bookmark">
			centos7升级gcc9之代码笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：centos7自带的gcc版本是4.8.5的版本，很多python项目需要gcc5+，因此需要升级gcc，升级gcc是个大坑，一般人劝退哈，搞不好整个环境就挂了。本文亦是带坑的更新升级，饮鸩止渴哈，依赖性极强。
要在CentOS 7上升级GCC版本，可以按照以下步骤进行操作：
首先确保系统已经安装了必要的软件包管理工具yum。如果没有安装，可以使用以下命令来安装：
sudo yum install -y epel-release
接下来更新所有已安装的软件包到最新版本：
sudo yum update -y
然后通过添加SCL（Software Collections）存储库来获取并安装最新的GCC版本。运行以下命令将SCL存储库添加到系统中：
sudo yum install -y centos-release-scl
现在我们可以安装特定版本的GCC。比如，要安装GCC 9，可以运行以下命令：
sudo yum install -y devtoolset-9
安装完成后，需要设置默认的编译器为新安装的GCC版本。运行以下命令：
source /opt/rh/devtoolset-9/enable
此时，系统会自动切换到新安装的GCC版本。可以通过运行gcc --version命令来验证当前正在使用的GCC版本。
注意事项：
SCL存储库提供了多个不同版本的开发工具集合，因此可以根据需求选择其他版本进行安装。
每次重新登录或打开新的终端窗口之后，都需要再次运行source /opt/rh/devtoolset-9/enable命令才能生效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6372c282107557e7ff8992fc16e41a98/" rel="bookmark">
			鼠标随动指定区域高亮显示（Excel聚光灯）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实例需求：工作表中数据表实现跟随鼠标选中高亮效果，需要注意如下几个细节需求
数据表为连续区域，但是不一定从A1单元格开始数据表的前两行（标题行）不使用高亮效果数据表中已经应用了条件格式，高亮显示取消后，不应破坏已经设置的条件格式如果选中整列，则不启用高亮显示 演示效果如下图所示。
示例代码如下。
Private Sub Worksheet_SelectionChange(ByVal Target As Range) Dim rowsRng As Range, useRng As Range, oFC As FormatCondition Set useRng = Me.UsedRange.Resize(Me.UsedRange.Rows.Count - 2).Offset(2) For Each oFC In useRng.FormatConditions If oFC.Formula1 = "=TRUE" Then oFC.Delete Next If Target.Rows.Count &lt; Me.Rows.Count Then Set rowsRng = Application.Intersect(Target.EntireRow, useRng) If Not rowsRng Is Nothing Then Set oFC = rowsRng.FormatConditions.Add(Type:=xlExpression, Formula1:="True") With oFC .SetFirstPriority .Interior.Color = RGB(255, 235, 156) .StopIfTrue = True End With End If End If End Sub 【代码解析】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6372c282107557e7ff8992fc16e41a98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35b35b437b0487e8c7c34d0d6b603998/" rel="bookmark">
			基于代理IP的多线程爬虫实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1. 爬虫的基本原理
2. 多线程爬虫的优势
3. 代理IP的应用
4. 基于代理IP的多线程爬虫实现
步骤1：导入必要的模块
步骤2：定义爬虫函数
步骤3：创建线程并启动爬虫
总结
前言 本文将介绍如何使用Python编写一个基于代理IP的多线程爬虫，通过多线程的方式提高爬取效率，并使用代理IP来防止被目标网站封禁。文章将包括爬虫的基本原理、多线程的使用方法和代理IP的应用，以及完整的实现代码。
1. 爬虫的基本原理 爬虫是一种自动化程序，用于从互联网上获取数据。其基本原理是通过HTTP请求从目标网站获取网页内容，然后对网页内容进行解析，提取出所需的数据。爬虫可以按照一定的规则遍历整个网站，或者根据用户指定的关键词进行搜索。
2. 多线程爬虫的优势 多线程爬虫是一种并行爬取数据的方式，相对于单线程爬虫，它能够大幅提高爬取效率。多线程爬虫的原理是通过创建多个线程同时进行爬取操作，每个线程负责爬取一部分数据。由于网络请求通常是IO密集型操作，多线程可以使得CPU在等待网络响应时可以处理其他线程的任务，提高整体的处理效率。
3. 代理IP的应用 在进行爬虫时，有些网站会限制对同一IP地址的频繁请求，甚至会封禁该IP地址。为了规避这种限制，可以使用代理IP来隐藏真实IP地址。代理IP是一种中间服务器，它会将请求转发到目标网站，并将响应结果返回给爬虫程序。通过使用不同的代理IP，可以实现在不同的IP地址上进行爬取，提高爬虫的稳定性和成功率。
4. 基于代理IP的多线程爬虫实现 步骤1：导入必要的模块 import requests from bs4 import BeautifulSoup import threading import time 首先，我们需要导入requests模块来发送HTTP请求，使用BeautifulSoup模块来解析网页内容，使用threading模块来创建和管理多个线程。
步骤2：定义爬虫函数 def crawler(url): proxies = { "http": "http://your_proxy_ip:port", "https": "http://your_proxy_ip:port" } try: response = requests.get(url, proxies=proxies) soup = BeautifulSoup(response.text, "html.parser") # 在这里添加解析网页的代码 except Exception as e: print("Error:", str(e)) 在爬虫函数中，我们首先定义了代理IP的字典，将代理IP的具体信息填写在其中。然后使用requests库发送带有代理IP的HTTP请求，获取网页内容。接下来使用BeautifulSoup对网页内容进行解析和提取所需的数据。如果请求过程中发生异常，我们将打印错误信息。
步骤3：创建线程并启动爬虫 def main(): urls = ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35b35b437b0487e8c7c34d0d6b603998/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40fbbf19c750891344c9ac127fe0d9bc/" rel="bookmark">
			计算机网络-各层协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家在搞嵌入式开发的时候基本都了解过七层网络协议、五层网络协议、四层网络协议，那么今天让我们更加的深入了解一下：
历史发展介绍 OSI七层模型由ISO国际标准化组织提出的通信标准。TCP/IP四层模型是OSI七层模型的简化版，OSI在它被官方完善之前，民间TCP/IP早已实际使用，所以只存在于理论五层协议的体系结构是专门为介绍网络原理而设计的，与TCP/IP四层模型唯一不同的就是将网络接口层分为了数据链路层和物理层，在实际的应用中还是使用TCP/IP四层模型的。 这里我们着重讲解网络协议，因此在这里我们对照七层协议进行讲解。
应用层 HTTP协议（HyperText Transfer Protocol，超文本传输协议）：是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。HTTP是一个基于TCP/IP通信协议来传递数据（HTML文件、图片文件、查询结果等）。它是一个简单的请求-响应协议，用于从服务器请求和发送网页内容。在HTTP协议中，客户端（通常是浏览器）向服务器发送请求，请求内容包括要获取的资源、请求方法（GET、POST等）以及请求头信息；服务器接收请求后，根据请求方法和路径找到相应的资源，并返回响应，包括状态码、响应头信息和响应体信息。HTTP协议的特点包括：
1. 无状态：HTTP协议是无状态的，这意味着服务器不会为每个请求保持状态。因此，同一个客户端的连续请求之间没有关联。
2. 请求-响应模型：HTTP协议采用请求-响应模型，客户端向服务器发送请求，服务器返回响应。
3.面向对象：HTTP协议是面向对象的，客户端和服务器之间传输的对象是消息头和消息体。
4.简单快速：HTTP协议简单、快速，客户端和服务器可以在任何时刻关闭连接，释放系统资源。
5.无须长时间连接：HTTP协议不需要长时间连接，可以快速完成数据传输后断开连接，节省网络资源。
6. 灵活：HTTP协议灵活，可以传输任意类型的数据对象，正在传输的类型由Content-Type加以标记。
HTTPS（全称：Hypertext Transfer Protocol Secure），是以安全为目标的HTTP通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。简单讲，HTTPS是HTTP的安全版。
HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。其主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。
HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。
FTP（File Transfer Protocol，文件传输协议）是一种用于在网络上进行文件传输的标准协议，FTP协议使用TCP传输而不是UDP，客户在和服务器建立连接前要经过一个“三次握手”的过程，保证客户与服务器之间的连接是可靠的，而且是面向连接，为数据传输提供可靠保证。
FTP协议包括两个组成部分，一是FTP服务器，用于存储文件；二是FTP客户端，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。在开发网站的时候，通常利用FTP协议把网页或程序传到Web服务器上。此外，由于FTP传输效率非常高，在网络上传输大的文件时，一般也采用该协议。
FTP协议的特点包括：
1. 基于客户-服务器（C/S）模型而设计。在客户端与FTP服务器之间建立两个连接，一个控制连接和一个数据连接。控制连接用于传输FTP控制命令和命令执行信息；数据连接用于传输数据，包括数据上传、下载、文件列表发送等。
2. 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。
3. FTP提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。
4. FTP只提供文件传送的一些基本的服务，它使用TCP可靠的运输服务。
5. FTP的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。
6. FTP使用客户服务器方式，一个FTP服务器进程可同时为多个客户进程提供服务。
7. FTP协议默认采用TCP端口中的20和21两个端口。其中20用于传输数据，21用于传输控制信息。
8. FTP协议的默认传输模式是ASCII模式，主要用于传输文本文件和程序文件。
9. FTP协议可以建立主动模式和被动模式的数据连接。主动模式下，由服务器主动发起连接；被动模式下，由客户端主动与服务器的临时端口号建立数据传输通道。
SSH（Secure Shell）协议是一种在网络上实现安全远程登录和其他安全网络服务的协议。它建立在应用层和传输层基础之上，利用非对称加密方法实现通信过程中的安全性，可以防止信息泄露、网络攻击和数据篡改等问题。SSH协议最初是在UNIX系统上实现的，但现在已经广泛应用于各种操作系统。 SSH协议的工作原理如下： 1. 客户端和服务器建立连接，服务器会生成一对公钥和私钥。
2. 客户端请求连接，发送请求到服务器。服务器将公钥传给客户端使用。
3. 客户端收到服务器的公钥后，会生成一对公钥和私钥，并将公钥发送给服务器。
4. 服务器验证客户端的公钥是否有效，如果有效，则建立连接。
5. 在连接过程中，客户端和服务器会使用非对称加密算法对数据进行加密和解密，保证数据传输的安全性。
SSH协议的优势包括： 1. 安全性高：SSH协议基于非对称加密方法，采用加密算法对数据进行加密和解密，保证了数据的机密性和完整性。同时，SSH协议还支持数字签名和身份验证等功能，防止网络攻击和非法访问。
2. 兼容性强：SSH协议可以在多种操作系统上运行，如UNIX、Linux、Windows等。这使得在不同系统之间进行安全远程登录和数据传输变得非常方便。
3. 易于使用：SSH协议的安装和配置相对简单，可以通过命令行或图形界面进行操作。同时，SSH协议还支持隧道技术等扩展功能，可以满足各种复杂网络环境的需求。
4. 高度灵活：SSH协议支持多种服务，如远程登录、文件传输、端口转发等。这使得SSH协议在远程管理、软件开发、网络安全等领域具有广泛的应用价值。
Telnet协议是TCP/IP协议族中的一员，是Internet远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，可以连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。Telnet协议的基本内容包括： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40fbbf19c750891344c9ac127fe0d9bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b062f990043c69819388e96870e7928/" rel="bookmark">
			分布式I/O应用于智慧停车场的方案介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		客户案例背景
目前车位检测技术有磁电技术、超声波技术、红外线技术、图像识别车位技术。考虑到例如电磁干扰、信号干扰等的环境因素影响，通常会采用组合使用的方式进行，如采用不同的传感器、应用不同的协议等，以便提高车位检测的准确性和实时性。
对于这些传感器采集到的数据，需要进行数据分析和上传。而通常停车场需要百米以上传输距离，因此传统有线传输将面临传输距离挑战，以及地面安装的成本问题，这可能导致出现通信中断或故障的维修困难。各大智慧停车集成解决方案商在行业发展中迫切关注！
分布式I/O系统概述
分布式I/O系统，由耦合器和I/O模块组成，负责采集传输各种信号数据，最多支持挂载32个I/O模块，512个信号采集，是实现采集控制的带边缘计算的I/O控制器。相较于传统的有线传输方式，分布式I/O系统减少了数据在设备之间传输时间，提高了数据采集的效率。具有可扩展性强、灵活性好、可靠性高且易于管理等特点。
分布式I/O系统方案
1、硬件设备的选型
为了确保数据采集的准确性和实时性，需要选用高品质的IO模块。客户对比之后，选择了钡铼技术研发的I/O模块。
2、数据采集与处理
I/O 板支持多种类型的输入/输出信号采集，如开关量输入、开关量输出、模拟量输入、模拟量输出、PT100、PT1000、热电偶、脉冲输入、脉冲输出、RS485等I/O信号。用户可根据需要配置节点的各个接口。
数据处理方面，在采集到的各类信号中，分布式I/O控制器内置边缘计算功能，可在不依赖云端和上位机的情况下实现数据处理和逻辑联动，实现云边协同。
数据汇总方面，分布式 I/O 模块能够无缝整合来自多个数据采集点的信息，将这些信息汇总并传输至耦合器，以进行更进一步的分析和处理。
即时响应，分布式 I/O 模块能够快速地数据采集和处理，从信号输入到输出有很短的延迟时间，使得现场运维和系统实时控制更为便捷。
远程监测，分布式 I/O 模块的信号采集和数据处理功能远程实时监测和控制。通过物联网平台或内部系统平台，管理员可以随时了解各个节点的数据情况、设备故障报警，避免出现危险或损坏发生。
3、存储与传输
数据采集传输后，需要进行存储和分析。对于智慧停车场的数据存储，需要考虑以下几个因素：可靠性、存储和处理速度、机密性和隐私性、成本，综合考虑以上因素，可以选择一些知名的云平台，如阿里云、华为云、AWS云以及ThingsBoard等。
“
分布式I/O系统应用拓扑图
分布式 I/O 模块是一种用于分散、分布式数据采集和控制的硬件设备，具有以下功能特点：
支持大规模扩展：分布式 I/O 模块可以支持海量的输入/输出，无论是数字型还是模拟型信号都能够适配，从而在扩充节点时灵活性更强。
网络通讯接口：通过不同的网络通讯接口连接到远端的主设备或感知节点，支持信号的双向传输，以便于实现开放性的互联互通。
技术标准化：分布式 I/O 模块常常采用标准化的技术方案，例如Modbus TCP/MQTT/OPC UA等工业网络协议等，使得与其他工业自动化设备的互联变得更为简单。
统一管理：基于 I/O 模块的采集和控制系统也可以被统一管理，在云管理平台上实现对各个节点设备的监管和配置。
数据处理能力：分布式 I/O 模块与其他智能设备相比，在数据处理方面更有优势，因为它内置边缘功能，不需要上位机和云平台或者PLC就能实现本地的I/O信号的联动控制，大大提升了现场的响应速度的，缓解云端上位机数据处理的压力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24214b26c078a7f3009bea1adb6090ed/" rel="bookmark">
			特征工程：图像数据不足时的处理办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在机器学习中，绝大部分模型都需要大量的数据进行训练和学习（包括有监督学习和无监督学习），然而在实际应用中经常会遇到训练数据不足的问题。比如图像分类，作为计算机视觉最基本的任务之一，其目标是将每幅图像划分到指定类别集合中的一个或多个类别中。当训练一个图像分类模型时，如果训练样本比较少，该如何处理呢？
在图像分类任务中，训练数据不足会带来什么问题？如何缓解数据量不足带来的问题？ 一个模型所能提供的信息一般来源于两个方面，一是训练数据中蕴含的信息；二是在模型的形成过程中（包括构造、学习、推理等），人们提供的先验信息。当训练数据不足时，说明模型从原始数据中获取的信息比较少，这种情况下想要保证模型的效果，就需要更多先验信息。先验信息可以作用在模型上，例如让模型采用特定的内在结构、条件假设或添加其他一些约束条件；先验信息也可以直接添加在数据集上，即根据特定的先验假设去调整、变换或扩展训练数据，让其展现出更多的、更有用的信息，以利于后续模型的训练和学习。
具体到图像分类任务上，训练数据不足带来的问题主要表现在过拟合方面，即模型在训练样本上的效果可能不错，但在测试集上的泛化效果不佳。根据上述讨论，对应的处理方法大致也可以分两类，一是基于模型的方法，主要是采用降低过拟合风险的措施，包括简化模型（如将非线性模型简化为线性模型）、添加约束项以缩小假设空间（如L1/L2正则项）、集成学习、Dropout超参数等；二是基于数据的方法，主要通过数据扩充（Data Augmentation），即根据一些先验知识，在保持特定信息的前提下，对原始数据进行适当变换以达到扩充数据集的效果。具体到图像分类任务中，在保持图像类别不变的前提下，可以对训练集中的每幅图像进行一下变换。
一定程度内的随机旋转、平移、缩放、裁剪、填充、左右翻转等，这些变换对应着同一个目标在不同角度的观察结果。对图像中的像素添加噪声扰动，比如椒盐噪声、高斯白噪声等。颜色变换。例如，在图像的RGB颜色空间上进行主成分分析，得到3个主成分的特征向量p1，p2，p3以及对应的特征值λ1，λ2，λ3，然后在每个像素的RGB值上添加增量[p1，p2，p3]·[α1λ1，α2λ2，α3λ3]T，其中α1，α2，α3是均值为0、方差较小的高斯分布随机数。改变图像的亮度、清晰度、对比度、锐度等。 图1.4展示了一些图像扩充的具体样例。
除了直接在图像空间进行变换，还可以先对图像进行特征提取，然后在图像的特征空间内进行变换，利用一些通用的数据扩充或上采样技术，例如SMOTE（Synthetic Minority Over-sampling Technique）算法。抛开上述这些启发式的变换方法，使用生成模型也可以合成一些新样本，例如当今非常流行的生成式对抗网络模型。此外，借助已有的其他模型或数据来进行迁移学习在深度学习中也十分常见。例如，对于大部分图像分类任务，并不需要从头开始训练模型，而是借用一个在大规模数据集上预训练好的通用模型，并在针对目标任务的小数据集上进行微调（fine-tune），这种微调操作就可以看成是一种简单的迁移学习。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76b57d8e648c629a791e205c70cf1c05/" rel="bookmark">
			锂电池制造设备中分布式IO模块优势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在“碳达峰、碳中和”目标推动下，新能源汽车当下发展势头正盛，而纯电动车的核心部件则是：锂电池。动力型锂电池作为新能源汽车核心零部件，其发展与新能源汽车行业息息相关，迎来广阔的市场空间。
为何采用I/O模块？
锂电池制造过程各环节的标准要求，将直接影响电池的成本、质量、安全以及一致性。锂电池的生产工艺分为前、中、后三个阶段，前段工序的目的是将原材料加工成为极片，核心工序为涂布；中段目的是将极片加工成为未激活电芯；后段工序是检测封装，核心工序是化成、分容。整个锂电池生产工序复杂、体系庞大。I/O点数多，要求调试方便，标准化程度高，重复的模块较多，继而数据采集的位置多而分散，所以采用分布式I/O模块最为合适。
1
钡铼分布式I/O模块优势
为锂电池设备制造商及系统集成商提供的分布式I/O模块，凭借操作和功能两方面的优势大幅提升了设备品质，为其快速采集和反馈调节提供了强大助力，缩短了交付时间，降低了总体成本。
2
分布式I/O应用方案
方案拓扑图
独特优势
高速系统总线：支持Modbus、MQTT、OPC UA、Profinet、EtherCAT、Ethernet/IP、BACnet/IP等多种协议以实现地区及全球使用。
丰富I/O信号接入：一个耦合器最多可以挂载32个I/O模块512个信号点，强大的扩展能力。
数据上云：对上支持西门子、欧姆龙、三菱、台达、施耐德等品牌的PLC，也支持Modbus TCP、OPC UA、MQTT三种通信协议对接云平台。
双网口级联：2个RJ45口，可以实现级联，采集信号数量不受限制。
钡铼技术BL200分布式I/O模块
3
应用案例
涂布机
涂布的主要目的是将浆料均匀地涂覆在正负极表面上。本案例实现数字化，放卷、涂布、烘干、收卷均自动完成。
独特优势
张力控制：张力控制会采用不同的传感器，如超声波探头，浮辊等，I/O模块可以实现这些传感器与PLC的稳定接线和即插即用，在任何时间更换模块都无需更改布线。
传输稳定：精确的涂布速度使得浆料利用率高、能够保持生产高品质极片。其高速的系统总线提供了毫秒级的快速响应时间。
耐受恶劣的工业条件：面对现场温度变化，BL200模块的宽温设计可以始终保持稳定工作，功能使用流畅自如。
3
省心细节为锂电池生产助力
I/O模块在设计细节中带来灵活便利，同样是钡铼技术研发优化产品的重要思路。在结构上，BL200 I/O模块采用插拔式设计，设备商可以根据需要自由组合I/O模块，相比传统的连线方式节约时间高达50％。且耦合器体积小，不占空间。在安装上，采用导轨式安装，简单便捷。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fbccb03981e2eccdbb2d377e54cfe46/" rel="bookmark">
			如何快速查找并解决Linux死机的原因？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux死机指操作系统在运行过程中突然停止响应的现象，对于使用Linux的用户来说，这无疑是一个令人头疼的问题。那么，我们应该如何快速查找并解决Linux死机的原因呢?
一般来说，Linux死机的原因可以归结为硬件故障、软件冲突、系统漏洞等。
那么，常见的解决方法都有哪些呢?
检查硬件问题：
1、检查电源供应：确保电源供应正常，电源线没有松动或损坏。
2、检查硬件连接：检查内存条、显卡、硬盘等硬件设备是否均已正确连接，并且没有松动。
3、温度过高：如果CPU温度过高，可能会导致系统死机。可以通过监控软件来检查并降低CPU温度。
检查软件冲突：
1、更新软件和驱动：及时更新系统内核、驱动程序和软件补丁，以确保系统的稳定性。
2、卸载冲突软件：如果某个软件与系统或其他软件存在冲突，可以尝试卸载该软件并重新安装或寻找其他替代品。
3、检查日志文件：查看系统的日志文件，找出是否有软件冲突的记录，并根据记录进行相应的处理。
还可以使用系统工具，Linux提供了一些实用的系统工具，可以帮助我们查找和解决系统死机的问题，例如：
1、top命令：查看系统的进程和资源占用情况，找出可能导致系统死机的进程。
2、dmesg命令：查看内核日志，以了解系统是否存在异常。
3、memtest命令：用于测试内存是否存在问题。
通过以上措施，您应该能够快速定位并解决Linux死机的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82e0494bae4c63e88f52b81eb0f78da7/" rel="bookmark">
			【JAVA线程实现】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java线程池 1. 前言2. 实现线程的七种方法2.1. 继承Thread类2.2. 匿名内部类继承Thread类2.3. 实现Runnable接口2.4. 匿名内部类实现Runnable接口2.5. 使用Lambda表达式2.6. 实现Callable接口和FutureTask包装器2.7. 使用ThreadPoolExecutor实现线程池 1. 前言 线程是程序执行流的最小单元，它是程序的执行路径。在多线程编程中，一个进程内可以有多个线程同时执行，共享进程的资源，从而提高程序的执行效率。进程是操作系统进行资源分配的基本单位，线程是独立调度和分派的基本单位。
2. 实现线程的七种方法 2.1. 继承Thread类 Java中的Thread类是所有线程的超类，它实现了Runnable接口，并重写了run()方法，通过继承Thread类，并重写run()方法，可以实现自定义线程
public class MyThread extends Thread { public void run() { // 线程执行的代码 System.out.println("继承Thread类"); } public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.start(); // 启动线程 } } 2.2. 匿名内部类继承Thread类 public class Main { public static void main(String[] args) { Thread thread = new Thread() { @Override public void run() { // 线程执行的代码 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82e0494bae4c63e88f52b81eb0f78da7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cda2ceee0c441b12750231650c9ca8e/" rel="bookmark">
			什么是DDoS攻击？网站如何防御？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为网站所有者，经常面临着来自各种各样的网络威胁，其中，DDoS攻击无疑是这些威胁中最常见和具有破坏性的一种。
DDoS攻击通过利用大量恶意流量来淹没你的网站，导致你的网站无法正常运行。如果不加以应对，DDoS攻击可能会导致你的业务流失、声誉受损以及金钱损失。
那么DDoS防御策略都有哪些呢?
一、升级服务器以承受攻击
在面对大规模DDoS攻击时，服务器的性能变得尤为重要。强大的服务器能够处理更多的请求，减轻攻击对网站的影响。因此，了解你所使用的服务器，包括其带宽、处理器性能和内存大小等方面，选择能够承受高负载的服务器是至关重要的。
二、使用流量分析工具来检测异常流量
流量分析工具可以帮助你监控并检测DDoS攻击。这些工具可以分析网站的流量模式，并识别出异常的流量行为，如大量的请求源自单一IP地址、重复访问同一页面等。当流量分析工具检测到异常流量时，你可以及时采取措施来阻止攻击，保护你的网站。
三、实施负载均衡
负载均衡是一种将流量分散到多个服务器上的方法。通过实施负载均衡，即使其中一个服务器受到攻击，其他服务器仍然可以继续处理流量。这将大大提高你的网站的稳定性和可用性，使其能够更好地抵抗DDoS攻击。
四、使用高防CDN来减轻压力
CDN是一种分布式架构系统，能将你的网站内容缓存到全球各地的服务器上。当你的网站受到DDoS攻击时，CDN可以分发请求到多个服务器上，减轻单一服务器的压力，同时保持网站的正常运行。通过使用高防CDN，访问者可以从距离最近的服务器获取网站内容，加快网站的加载速度。同时防御能力也是十分强大!
通过实施有效的防御策略，你可以保护自己的网站免受DDoS攻击的破坏。升级服务器、使用高防CDN、流量分析工具、负载均衡，这些都是保护你的网站的关键步骤，特别是高防CDN是现在比较流行的一个防御工具，建议可以用来对付ddos攻击。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c000158f204ff966d5bb57725704802e/" rel="bookmark">
			Linux中虚拟网卡是什么？其类型有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网卡是一块用来允许计算机在计算机网络上进行通讯的计算机硬件，它使得用户可以通过电缆或无线相互连接。而在Linux操作系统中，网卡驱动中又内含了很多虚拟网卡，那么Linux中虚拟网卡是什么?有何作用?我们来看看具体内容介绍。
在Linux中，虚拟网卡是一种虚拟网络设备，它允许将多个逻辑网络接口映射到单个物理网络接口上。虚拟网卡是网络虚拟化的一部分，用于创建、管理和连接虚拟网络。
以下是常见的虚拟网卡类型及作用：
1、虚拟以太网设备：最常见的虚拟网卡类型之一。它们使用虚拟以太网技术模拟物理以太网适配器，并提供虚拟机或容器与物理网络之间的通信。例如，eth0、eth1等都是虚拟以太网设备的命名。
2、Tap设备：用于提供用户空间程序和内核之间的虚拟网络接口。Tap设备可以用于实现虚拟私有网络功能，实现虚拟机或容器之间的通信。
3、桥接设备：用于连接两个或多个网络接口，使其工作在同一个网络段内。桥接设备充当一个交换机，将连接到不同物理接口上的数据包进行转发。
4、虚拟回环设备：是一个虚拟网卡，用于在本地主机上进行通信回环。IP地址127.0.0.1和localhost均绑定到该虚拟回环设备。
虚拟网卡的使用场景广泛。它们可以用于虚拟化平台、容器技术、网络测试、网络监控等领域。通过创建和配置虚拟网卡，可以实现更灵活、安全和高效的网络架构和应用部署方式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8bbae9e51bd6bd7a931e3a8341e3d60/" rel="bookmark">
			基于微信小程序的音乐平台 开源项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块三、系统展示 四、核心代码4.1 查询单首音乐4.2 新增音乐4.3 新增音乐订单4.4 查询音乐订单4.5 新增音乐收藏 五、免责说明 一、摘要 1.1 项目介绍 基于微信小程序+JAVA+Vue+SpringBoot+MySQL的音乐平台，包含了音乐档案模块、音乐收藏模块、音乐订单模块，支持PC后台和微信小程序用户端使用，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，基于微信小程序的音乐平台基于角色的访问控制，给音乐管理员、音乐用户角色使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
1.2 项目录屏 二、功能模块 随着当今世界网络和计算机的飞速发展以及智能手机的普及，人们的生活从过去的必须使用计算机进行工作、娱乐、信息获取转变为通过使用更加便利的移动设备去代替。小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。在微信作为不可或缺的工具当下，微信小程序作为内置于微信内的功能平台，能够给绝大多数人带来对于他们自己而言更简易方便的使用感受及体验。
同时，在如今的时代背景下，音乐对于大多数人来说亦是不可或缺的元素。从商场、超市、餐厅等等舒缓的背景音乐包括现在可以说是如日中天的抖音也是结合了音乐与短视频，由此可见音乐的覆盖面，将音乐与微信小程序相结合，相信是一种有可能性的研究内容。
前台功能可含包用户登录注册、搜索、播放按钮、收藏列表等。后台功能用户管理、音乐上传、付费管理等。网站前台要求导航清晰、图文并茂、风格统一，后台要求功能完善、操作便捷。系统代码规范、运行稳定、安全性高，无明显BUG。 三、系统展示 四、核心代码 4.1 查询单首音乐 @RequestMapping(value = "/getOne", method = RequestMethod.GET) @ApiOperation(value = "查询单首音乐") public Result&lt;Music&gt; get(@RequestParam String id){ User currUser = securityUtil.getCurrUser(); Music music = iMusicService.getById(id); if(music == null) { return ResultUtil.error("音乐不存在"); } // 收藏 QueryWrapper&lt;MusicCollect&gt; mc = new QueryWrapper&lt;&gt;(); mc.eq("music_id",music.getId()); mc.eq("user_id",currUser.getId()); music.setCollectFlag(iMusicCollectService.count(mc)); // 下单 QueryWrapper&lt;MusicOrder&gt; mo = new QueryWrapper&lt;&gt;(); mo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8bbae9e51bd6bd7a931e3a8341e3d60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f574c194801b36b41a694aba20335690/" rel="bookmark">
			51单片机控制键盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.键盘 1.键盘 键盘是电子系统中人机对话的重要组成部分，是人向机器发出指令、输入信息的必须设备
键盘在单片机应用系统中是使用最广泛的一种数据输入设备。键盘是由多个按键组成的。
2.按键 按键通常是一种常开型开关，常态下按键的两个触点处于断开状态，按下按键时它们才闭合。
通常键盘有编码键盘和非编码键盘两种。编码键盘通过硬件电路产生被按按键的键值码，这种键盘使用方便，所需程序简单，但硬件电路复杂，
如计算机的键盘，单片机则通常不采用编码键盘。而软件编程来识别的称为非编码键盘，非编码键盘硬件电路简单。在单片机组成的各种系统中，最常用的是非编码键盘。
3.独立键盘与矩阵键盘 非编码键盘分为独立键盘和矩阵键盘。
独立键盘：每个按键占用一个IO口，当按键数量较多时，lO口利用效率不高，但程序简单，适用于所需按键较少的场合。矩阵键盘：电路连按复杂，但提高了IO口利用率，软件编程较复杂。适用于使用大量按键的场合。
二.独立键盘 1.抖动 了解了独立键盘的原理图之后，我们知道如果键盘按下，那么线路导通IO口会接触到GND从而电压为0，所以我们可以通过IO口电压的变换来判断独立按键是否被按下。
结合上一篇控制单片机数码管的显示，我们很自然的想到如果按键按下实现数字加1显示的实验，为了好实验这里选择数码管的静态显示实验。
那么，有初始的源代码：
#include &lt;reg52.h&gt; //51头文件 #define uchar unsigned char	//宏定义 #define uint unsigned int	//宏定义 sbit we = P2^7;	//位定义数码管位选锁存器接口 sbit du = P2^6;	//位定义数码管段选锁存器接口 sbit key_s2 = P3^0; //定义独立键盘S2的IO口 uchar num = 0; //数码管段选表 uchar code leddata[]={ 0x3F, //"0" 0x06, //"1" 0x5B, //"2" 0x4F, //"3" 0x66, //"4" 0x6D, //"5" 0x7D, //"6" 0x07, //"7" 0x7F, //"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f574c194801b36b41a694aba20335690/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fd653bb56c349db89c5cdc205c4dd53/" rel="bookmark">
			云卷云舒：算力网络&#43;云原生（上）：打造云网边端协同架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云卷云舒：算力网络+云原生（下）：云数据库发展的新篇章-CSDN博客https://blog.csdn.net/bishenghua/article/details/135050556
大家可能经常遇到上述几个疑问？
什么是云原生？云原生后面还能怎么发展？
什么是算力网络？为什么通信运营商都在提算力网络？阿里云怎么不去强调这么多的概念？
云原生和算力网络是什么关系？有什么区别？二者是否矛盾？需要如何配合？
上述几个问题的提示出，相信引起了很多同事的共鸣，现在的云计算领域新概念层出不穷，而算力网络和云原生这两个是当今的“头牌”词汇，正如云计算领域发展到今天，随着技术的演进，算力网络的概念被以中国移动为主的各大云服务商先后提出，成为了通信运营商在云计算领域巨大的技术优势，比如移动云将算力网络作为未来发展的重要战略，同时，也就在近几年云服务商也相继将云原生技术作为未来技术演进的毕竟路径，那么“算力网络”和“云原生”到底是什么关系呢？本文是我的个人意见，仅供参考，欢迎评论区交流留言。
一、算力：后疫情时代新型生产力
1、后疫情时代与数字经济
疫情时代，最宝贵的是算力，包括提供核酸检测、基因检测都需要算力，每天检测量达到几百万。算力时代看似刚刚开始，实则拉力战早已开启。从城市到家庭，从政府到企业，算力已成为未来企业乃至国家发展的主要动能，而且必将成为一种高需求的热门资源。 数字经济时代，新技术、新业态、新场景带来了激增的数据量，对于计算需求、网络需求都提出了新的要求，产业又将再一次催生变革。
2、算力：云服务商的必争之地
疫情时代，使得数字经济成为了必选项。算力作为数字产业最核心的组成部分，成为人们生活的必需品，可见算力对于日常生活的影响是越来越高，但是全球资源有限，如何去合理的定义、整合、利用算力是需要深入研究的。云服务商面临着巨大的机遇，那就是要针对算力开展寸土必争的革新。 二、算力网络和云原生
1、算力的供给
云计算得以长久发展的前提与经济社会的发展一致，同样需要从“供给侧”实现革新，即算力供给，算力供给的渠道，需要通过定义、整合、连接与开放来构建。
算力网络：是一种在5G、AI时代的新型资源整合起来，他讲属于不同所有方的计算、存储等资源通过网络整合起来，按照用户业务的不同需求提供最有的资源服务与网络连接。
2、算力网络：背景
算力网络的出现是必然，分布式算力才是未来的真需求，边缘计算的发展使能算力的多样化，基于网络实现算力的连接和对用户的可达。
3、算力网络：应用场景示例-视频转码
4、云原生：云计算的再升级
云原生定义了云服务商对外的服务形式，在云业务发展的过程中，有三个因素是至关重要的，那就是云服务商如何讲好“云原生的故事”，对于用户来说那就是：
（1）面向内容：云能提供什么？云计算的内容是结构化的，决定着上云的方式是多样化，实现“上得去”。
（2）面向服务：用户该如何用好云？资源驱动无法保证云上业务“站得稳”，云原生需要分阶段稳步发展。
（3）面向场景：云服务的未来在哪里？云原生需要“行的远”就要适应变化，对于场景的探索是云业务持久发展的保障。
5、结构化的云：内容决定上云形式
云原生侧重一个分层的定义，将云分解为IaaS、PaaS、SaaS多个结构化的层次，使得用户上云的形式多样化。
上得去：
上得去
6、面向服务的思维：云原生分阶段演进
云原生从另一个角度阐述了云计算所带来的思维变化，那就是从“面向资源”向“面向服务”的转变，所有的资源都要“封装”为服务对外提供，基于云计算构建应用系统需要实现应用架构和云计算平台的完美契合。
站得稳：
7、云原生新趋势：常态化的变化与场景演进
云原生发展到今天，我们不再谈容器化、微服务和devops等概念，因为云原生的发展趋势就是“适应变化”，在未来，多云、混合、分布式等场景的云环境将成为常态，必定需要打造一片属于变化中的“云原生应用天地”。
行的远：
思考：云服务 广度&amp;深度 ？
基于前面的介绍，我们探讨了三个方面的问题：
云能提供什么？云计算是结构化的，用户上云的方式也是多样化的，实现“上得去”。用户该如何用好云？云原生分阶段的演进，确保上云业务“站得稳”。云服务的形式？云服务是场景驱动的，助力“形得远”。 但是这就足够了吗，这就是云服务的最佳姿态了吗？
上云的模式仍然是集中式的，所以上云的范围依然是狭隘的（资源定义的扩展）。架构是静态的，但是如何实现“全局型架构”，还缺少路径上的延伸（融合通道的扩展）。云的更多价值一定是在运营上，无奈可运营的内容依然是单一的（价值空间的扩展）。 所以算力网络和云原生天生必然走向“协同”。
三、基于算力网络+云原生 打造“全栈协同”的云、网、边、端架构
1、场景协同：云原生扁平化演进到算力网络
云原生不仅仅是一系列技术框架、技术组件的简单组合，数字经济时代，云原生需要赋予更深层次的概念：面向场景的业务驱动。
在纵向上：由公有云、私有云向混合云演进；在横向上：由公有云、边缘云向分布式云演进。云原生不断演进的大场景下，云服务的扁平化发展和分布式演进是算力网络形成的基础。 so：云原生在深度发展的同时，未来的演进也必定是面向横向发展的，云原生在场景驱动下，必将扁平化的演进到算力网络。
2、技术协同：云原生助力算力标准化开放
算力网络需要基于云原生进行调度，云原生在容器技术、云原生操作系统、精细化调度技术等方面不断地演进，提升跨平台能力、调度的敏捷性，在动态发展中的云中实现算力泛在。算力网络为云原生提供了广阔的发展舞台，云原生的跨平台演进趋势与算力网络完美契合，云原生是“算力开放的标准化API”。 3、最高级形态：云、网、边、端的“全栈协同”
“协同架构”：算力网络的到来，将云服务以更加广阔的方式送达给客户，是对于中心云服务的延伸，是云在服务广度的拓展，使能“算力无处不在”；而云原生，是最高级别的云服务形式，是在基础设施、平台、应用，甚至应用产生的全过程都来体现云的服务能力的，是云在服务深度的升华。算力网络延伸了云原生的边界，云原生定义了算力的开放形式，二者的结合，让云、网、边、端架构得以实现横纵的全栈协同。在这一方面，通信运营商有着明显的优势。
备注：请尊重原创，如需转载请在文内备注转载。本文形成部分参考了互联网资源，以上观点完全个人意见，仅供参考。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9fc65566e2afda56074f1d405a3da26/" rel="bookmark">
			argc和argv参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、int main(void)和int main(int argc, char *argv[])的区别 当需要在程序启动时就携带参数给它，而不是运行过程中输入数据，这时就需要让main函数携带参数。
二、int main(int argc, char *argv[])的语法 argc（argument count）表示传入main函数中的参数个数；argv（argument vector）表示传入main函数中的参数列表，其中argv[0]表示此程序的名称。
如下例这段代码test.cpp，在终端中输入`test hello 123"，那么其argc值为3，argv为[“test”, “hello”, “123”]
int main(int argc, char const *argv[]) { return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c9ddbe1b2a0b421c708ecf5fff136eb/" rel="bookmark">
			云卷云舒：算力网络&#43;云原生（下）：云数据库发展的新篇章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云卷云舒：算力网络+云原生（中）：探索构建算力网络数据库_云卷云舒 csdn-CSDN博客 云原生数据库发展的的未来方向：“四化” 一、整体趋势 四化，即“云原生化、平台化、一体化和智能化”。必须基于云的能力和生态，去构建数据库的平台化能力，促进软硬协同体系，同时，chatGPT也向大家证实了AIGC的能力，那么智能化和数据库的结合充满无限可能。
另外基于云原生构建多模数据库可是一个趋势，再次本文简单预测云数据库发展的新篇章，必然是“算力网络+云原生”的高层及结合。
二、四化 1、基于平台化思想，结合云的基础设施实现软硬协同。这里的基础设施包括提供新型云计算能力，如高压缩比存储组件、高加密级数据加密机、高隔离级别计算调度机制，总支可以实现精细化基础设施编排能力、场景赋能型平台能力，帮助客户实现更加高级别的云原生，以降低成本、提升效率等。
2、成本赋能的需求下，三、四层解耦的云原生数据库，都在开展存储计算分离的基础上，至内存池化，以及可以实现无感弹性、精细化弹性、智能弹性，规模化的内存池化一定会带来成本下降，内存成本至少可以降低一半以上，部分场景下的查询以及性能也会大幅提升。
3、一体化能力，云原生数据库、云原生数据仓库将探索实现融合，形成“云原生一体化”的HTAP解架构，赋能数据同步、数据翻译、数据开放、统一入口，对于客户来说将是“一体化”的极致体验。
4、越来越多的数据库将增加对于AIGC场景的支持持，包括多模接入，数据库将会成为AIGC时代的数据支撑平台，以至于成为AIGC应用发展的关键部件。AI4SQL和SQL4AI这两块的应用场景也不会变。
三、云原生数据库优势设计（点击查看详情） 云数据库在云原生的路上，如果需要实现更高级别形式落地，需要更加精细化的场景以及调度能力，首先看一下云原生数据库的主要竞争点，通过和传统数据库的对比分析：
1. 在支撑扩展性方面：云原生数据库则完全依赖的云计算的底层复制和可用性技术，具有数据强一致性、以及极高可扩展性的特点，而普通数据库则采用的是普通的分布式数据库技术，或者说是数据库本身通过中间件技术、生态工具等组合构成的一致性和高可用方案。
2. 在基础设施要求方面：云原生数据库，顾名思义必须运行在云平台上，包括必要的容器云平台或多云管理平台等，而普通的数据库则可以直接运行在本地硬件、虚拟机上，也可以基于简单的对云的应用构建基础的云数据库，但是仅限于基础调度能力上了云，内核和设计理念仍然为传统的架构。
3. 在版本迭代演进方面：云原生数据库一般都是完全基于云平台构建，包括云基础设置、云调度平台、云应用DevOps流程等，他的版本更新和发布与传统的差距较大，完全依赖于通过PaaS的方式进行部署，十分敏捷，响应可以做到完全无中断；而普通数据库则需要通过传统的数据库软件客户端进行重新安装部署、插件增量部署，部署一次的代价相对较大，无法做到完全不停服，所以没法支持业务敏捷迭代。
4. 在数据可靠性方面：云原生数据库通常采用高层次的分布式云原生技术，通过云自身100%的能力确保数据的可靠性和安全，而普通数据库在二者之间的权衡则需要付出巨大的代价，额外插件的引入也会使得架构变得相对复杂，一般来说高并发业务下，数据一致性往往被适当的舍弃，对于业务的影响大多无法避免。
四、下一代数据库的设计畅享 1、形态多样，内核丰富，覆盖HTAP、多模向量等多种形态演进；
2、构建基于算网原生的标准，已保障发展初期的技术路线稳定；
3、技术上将提出智能资源调度、容量上限、软硬融合、国产化兼容性、深度分布式、平台布局等要求；
4、技术壁垒降低，国内广大的国产化厂商将崛起；
5、数据库卸载，数据库与存储的边界发展中将进一步模糊;
6、端到端的技术自主可控必须坚持下去，长期坚持下去。
在这里，我们姑且将未来数据库定义为“算力网络数据库”。
注：仅个人观点，欢迎交流留言 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/748933c902fde311ce0af3465768f0a2/" rel="bookmark">
			基于STM32的水质在线监测系统(论文&#43;源码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.系统设计
本次水质在线监测系统选用STM32单片机作为整个系统的主控制器，整个系统集成了温度传感器、浊度传感器、PH传感器，用于对环境内部的水温、水质、水资源的PH值来进行实际数据的检测工作， 2.实物效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd831c90c5dcbc75a39d758ed257d698/" rel="bookmark">
			go 的内存布局和分配原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go 之所以在高并发环境下表现优异，除了咱们都知道的 GMP 模型，其实 go 的内存布局和分配机制也起到了不少作用。
1. 分配内存三大组件 go 分配内存的过程，主要由三大组件所管理，级别从上到下分别是：
mheap go 在程序启动时，首先会向操作系统申请一大块内存，并交由mheap结构全局管理。
具体怎么管理呢？mheap 会将这一大块内存，切分成不同规格的小内存块，我们称之为 mspan，根据规格大小不同，mspan 大概有 70类左右，划分得可谓是非常的精细，足以满足各种对象内存的分配。
那么这些 mspan 大大小小的规格，杂乱在一起，肯定很难管理对吧？
因此就有了 mcentral 这下一级组件
mcentral 启动一个 go 程序，会初始化很多的 mcentral ，每个 mcentral 只负责管理一种特定规格的 mspan。
相当于 mcentral 实现了在 mheap 的基础上对 mspan 的精细化管理。
但是 mcentral 在 go 程序中是全局可见的，因此如果每次协程来 mcentral 申请内存的时候，都需要加锁。
可以预想，如果每个协程都来 mcentral 申请内存，那频繁的加锁释放锁开销是非常大的。
因此需要有一个 mcentral 的二级代理来缓冲这种压力
mcache 在一个 go 程序里，每个线程M会绑定给一个处理器P，在单一粒度的时间里只能做多处理运行一个goroutine，每个P都会绑定一个叫 mcache 的本地缓存。
当需要进行内存分配时，当前运行的goroutine会从mcache中查找可用的mspan。从本地mcache里分配内存时不需要加锁，这种分配策略效率更高。
mspan 供应链 mcache 的 mspan 数量并不总是充足的，当供不应求的时候，mcache 会从 mcentral 再次申请更多的 mspan，同样的，如果 mcentral 的 mspan 数量也不够的话，mcentral 也会向它的上级 mheap 申请 mspan。再极端一点，如果 mheap 里的 mspan 也无法满足程序的内存申请，那该怎么办？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd831c90c5dcbc75a39d758ed257d698/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0905f6cf9c21ad572c111c7dccf9a6a9/" rel="bookmark">
			go 中的 fmt 占位符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通用占位符 %v 值的默认格式表示
fmt.Printf("%v\n", 100)}//100 %+v 类似%v，但输出结构体时会添加字段名
o := struct{ name string }{"tim"} fmt.Printf("%+v\n", o)}} //{name:tim} %#v 值的 Go 语法表示
o := struct{ name string }{"tim"} fmt.Printf("%#v\n", o) } //struct { name string }{name:"tim"} %T 打印值的类型
o := struct{ name string }{"tim"} fmt.Printf("%T\n", o) } //struct { name string } %% 百分号
fmt.Printf("100%%\n") }//100% 布尔型 true 或 false
t := true fmt.Printf("value: %t", t) 整形 %b 表示为二进制
fmt.Printf("%b\n", 65)//1000001 %c 该值对应的unicode码值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0905f6cf9c21ad572c111c7dccf9a6a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/890f565b53a9fb1ca2cc46e616dd3e8c/" rel="bookmark">
			Vue/ Vue 路由配置 (重温 ) 一级 二级 路由配置 及 路由各种方法重定向 (浏览器渲染)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue路由配置流程: 配置完路由后 , 需要写入到实列内,在App.vue写入 &lt;router-view&gt; 标签进行一级路由配置 ，在components/user.vue写入 &lt;router-view&gt; 进行二级路由配置 路由配置 一. 一级路由配置与路由内方法 语法: const router = new VueRouter({
routes: [ // 一级路由
{path: '/路径名',component: 组件名 }, // 重定向 {path: ' / ', redirect: '/路径名 ' }, // 404 {path: ' * ',component: 组件名 },
],
}) // 一级路由出口 --&gt; App.vue &lt;router-view&gt; &lt;/router-view&gt; 说明: Vue路由是指根据url 分配对应的处理程序 作用就是url 调用对应的控制器 重定向属性说明: 1. 监测默认路径 path:'/' 2. redirct配置项 值是要强制切换的路由路径 重定向说明: 匹配path后 ,强制跳转path路径 ，网页打开url默认值是 / 路径 ，redirct是设置要重定向到那个路径\ 重定向应用场景: 第一次打开网页 配置默认页面 404 : 当找不到路径匹配时 给个提示页面 ,path匹配 * (任意路径) &lt;/router-view&gt;作用: 展示这个页面路由下面的子路由 二.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/890f565b53a9fb1ca2cc46e616dd3e8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01624e62099e0ffc2db098847255192e/" rel="bookmark">
			从0开始python学习-46.pytest框架之通过yaml处理接口关联问题-针对变量处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 提取变量
1.1 提取方法
1.2 提取地方：响应的body，响应的cookie，响应头
1.3 提取方式：
1.4 示例：在能获取到对应token的yaml用例中写入
2.使用变量：封装一个通用extract_util.py
3. 调用测试用例，使用变量
1. 提取变量 1.1 提取方法 extract: 保存值的变量名: [提取地方,提取方式,提取之后的下标取值] 1.2 提取地方：响应的body，响应的cookie，响应头 print(res.text) # 返回字符串类型的数据 print(res.content) # 返回二进制类型的数据 res.json() # 把json字符串转化为字典格式返回 print(res.status_code) # 状态码 print(res.reason) # 状态信息 print(res.cookies) # cookie信息 print(res.encoding) # 编码格式 print(res.headers) # 响应头 print(res.elapsed) # 耗时 print(res.request.method) # 请求方式 print(res.request.url) # 请求路径 print(res.request.headers) # 请求头 print(res.request.body) # 请求数据 1.3 提取方式： 正则表达式：re.findall(pattern, string)
jsonpath：jsonpath.jsonpath(obj, expr)
1.4 示例：在能获取到对应token的yaml用例中写入 extract: access_token: [json,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01624e62099e0ffc2db098847255192e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcd0e7fe95745c7fb307bf4d4565e733/" rel="bookmark">
			【送书福利-第三十二期】《FFmpeg 音视频开发基础与实战》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 适读人群 ：本书适合从事音视频编解码、多媒体应用开发和流媒体技术的初、中级开发者，以及各大院校学生阅 读，也适合有一定经验的开发人员参考使用。
FFmpeg 是⾳视频领域中重量级的开源项⽬，本书以FFmpeg官⽅提供的代码实例为基础，对FFmpeg相关知识进行了全⾯、深⼊地讲解，可有效帮助读者获得基于FFmpeg的⾳视频开发基础知识和技能。本书特色如下：
1.系统地讲解音视频领域的基础知识，如音视频编解码标准、媒体容器的封装格式和网络流媒体协议。
2.由浅入深地介绍FFmpeg 的基本使用方法，包括命令行工具ffmpeg、ffprobe 和ffplay 的主要
使用方法。
3.用6章实战讲解如何使用libavcodec、libavformat 等FFmpegSDK 进行音视频基本功能的开发，可有效提升项目实战能力。
内容简介 全书内容分为三部分，共15 章。第1~6 章为第一部分，主要讲解音视频开发的基础知识，简要介绍音视频技术的发展背景，以及主流的音视频压缩编码算法、音视频容器格式和网络流媒体协议等。第7~9章为第二部分，主要讲解命令行工具ffmpeg、ffprobe 和ffplay 的使用方法，包括如何使用这些工具进行视频播放、格式检测、编转码、格式转换和流媒体推拉流等操作；第10~15 章为第三部分，主要讲解基于FFmpeg SDK 的开发实战，主要介绍如何在工程中调用libavcodec 和libavformat 等库提供的接口实现音视频处理的相关功能。
本书适合从事音视频编解码、多媒体应用开发和流媒体技术的初、中级开发者，以及各大院校学生阅读，也适合有一定经验的开发人员参考使用。
作者简介 殷汶杰，2013年毕业于上海大学信息与通信工程学院，主要研究方向为视频压缩编码、流媒体技术，其间发表了多篇高水平学术论文。具有多家一线互联网上市公司、世界五百强企业与行业独角兽公司的核心开发工作经验，成功申请了多项专利（其中一项国际专利）。发表了数百篇技术博客，并发布了多个线上教学课程，在行业内具有较强的技术影响力。
抽奖方式 点赞+收藏 文章
评论区留言：“人生苦短，拒绝内卷”或者其它皆可（留言才能进入奖池，每人最多留言三条）
本周5晚八点随机抽奖5人
交流 对软考有兴趣的朋友可以进博主的交流群，目前有软件设计师、高项、系统架构师、系统分析师四个群。
群内有历年真题、电子书等资料可以自取；
无营销、纯交流群；
每周会有两次送书活动一次三本，包邮到家。
进群入口
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b9ab251d3f62031670e73394560b806/" rel="bookmark">
			Wargames与bash知识12
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Wargames与bash知识12 Bandit20 关卡提示：
主目录中有一个setuid二进制文件，它执行以下操作：它在您指定为命令行参数的端口上连接到localhost。然后，它从连接中读取一行文本，并将其与前一级别的密码（bandit20）进行比较。如果密码正确，它将传输下一级别（bandit21）的密码。
注意：试着连接到您自己的网络守护程序，看看它是否如您所想的那样工作
推荐命令：
ssh, nc, cat, bash, screen, tmux, Unix ‘job control’ (bg, fg, jobs, &amp;, CTRL-Z, …)
有没有觉得的这个关卡有点眼熟：某个关卡我们使用nc给一个端口（好像是30000）发送一个字符串，然后服务器给回复一个密码。这个关卡是展现服务器端是如何实现的吧，不过细究的还有有很大的区别：那个关卡回复是自动的，但在这个关卡我们需要手动运行一个程序才能实现。
Nc的命令前面已经谈过了，就不再复述。
解决这个问题需要使用两个终端，咱们继续使用windows的wls2子系统unbuntu来做演示。
使用ssh登录服务器
g
yj@guyanjun:~$ ssh -l bandit20 -p 2220 bandit.labs.overthewire.org The authenticity of host '[bandit.labs.overthewire.org]:2220 ([51.20.13.48]:2220)' can't be established. ECDSA key fingerprint is SHA256:IJ7FrX0mKSSHTJ63ezxjqtnOE0Hg116Aq+v5mN0+HdE. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added '[bandit.labs.overthewire.org]:2220,[51.20.13.48]:2220' (ECDSA) to the list of known hosts. _ _ _ _ | |__ __ _ _ __ __| (_) |_ | '_ \ / _` | '_ \ / _` | | __| | |_) | (_| | | | | (_| | | |_ |_.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b9ab251d3f62031670e73394560b806/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/13/">«</a>
	<span class="pagination__item pagination__item--current">14/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/15/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>