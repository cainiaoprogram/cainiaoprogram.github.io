<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36ed42d41ce9f02de4ee120dfa7306d7/" rel="bookmark">
			html常用类名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 HTML中的class类名可以用于标识和样式化HTML元素，它们通常与CSS样式表一起使用，以应用特定的样式和布局。 "container"：通常用于包裹整个页面或页面的主要部分，具有宽度和内外边距的样式设置，以控制容器的布局和外观。 "header"：用于标识页面头部区域，通常包含标题、logo、导航菜单等元素。 "main"：用于标识主要内容区域，通常包含页面的主要内容，如文章、产品列表等。 "footer"：用于标识页面底部区域，通常包含版权信息、联系方式等元素。 "nav"：用于标识导航菜单，可以通过CSS样式设置菜单的布局、颜色、字体等属性。 "nav-item"：用于标识导航菜单中的每个项目，可以通过CSS样式设置每个项目的样式，如字体、颜色、大小、下划线等。 "section"：用于标识页面中的不同区域或部分，可以通过CSS样式设置每个区域的背景色、边框、内边距等属性。 "article"：用于标识文章内容，可以通过CSS样式设置文章标题、正文、作者等元素的样式。 "aside"：用于标识侧边栏或附加内容，可以通过CSS样式设置侧边栏的布局、背景色、字体等属性。 "figure"和"figcaption"：用于图片、图表等内容的容器和标题，可以通过CSS样式设置容器和标题的样式。 "link"：用于链接元素，可以通过CSS样式设置链接的颜色、下划线等属性。 "list-group"和"list-group-item"：用于列表组和列表组中的每个项目，可以通过CSS样式设置列表组的布局、背景色、字体等属性。 "modal"：用于模态对话框元素，可以通过CSS样式设置对话框的布局、背景色、字体等属性。 "table"、"table-row"和"table-cell"：用于表格元素，可以通过CSS样式设置表格的布局、边框、内边距等属性。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/192759d6492b94fde295e2069aec1970/" rel="bookmark">
			npm 本地部署及发布包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择对应部署方式
npm install -g verdaccio 执行查看相关配置 verdaccio 创建项目
cnpm create vite，单元测试，eslint可以根据需要调整
新建packages文件夹，新建所需组件
新建组件导出文件index.ts
import type { App, Plugin } from 'vue' import FormDesign from "./formdesign.vue" export const formDesignPlugin: Plugin = { install(app: App) { app.component('formDesign', FormDesign) }, } export { FormDesign, } 设置组件名称
导出需要用到的组件 及方法
import type { App, Plugin } from 'vue' import { formDesignPlugin } from './form/formdesign'; import { formBuildPlugin } from './form/formbuild' import { flowDesignPlugin } from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/192759d6492b94fde295e2069aec1970/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afae4d9838c015e7a3aa3c4476f43beb/" rel="bookmark">
			c JPEG 中MCU 的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 jpeg编码中，因为对MCU的理解不正确，造成YUV 三分量的排列错误 ，排错了好几天。
对于yuv420p：
如： y00 3 y02 3 y4 ......
y10 y11 y12 y13 ......
则第一个MCU为： y00 y01 y10 y11 u00 v00 共6个字节
我理解MCU 就是比特流中最小的重复单位
下面的程序为Y亮度排序程序，也就2*2的块分割。uv分量不用再排序。
//---------Y 排序---------------------------------- //第一个MCU y01 y02 y10 y11 u01 v01 int yw[pic_heigth*pic_width/64]={}; int wn=0; for(int y=0;y&lt;pic_heigth/8;y=y+2){ for(int x=0;x&lt;pic_width/8;x=x+2){ for(int b=0;b&lt;2;b++){ for(int a=0;a&lt;2;a++){ yw[wn]=(y+b)*pic_width/8+x+a; wn++; } } } } //---------MCU--------------------------------- 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31012760a2f53ba623132daeabc2cf5e/" rel="bookmark">
			VSCode 正则表达式 匹配多行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VS Code 正则表达式匹配多行 (.|\n)*?
//test.js const test = { str: 'VS Code 正则表达式匹配多行VS Code 正则表达式匹配多行VS Code 正则表达式匹配多行VS Code 正则表达式匹配多行VS Code 正则表达式匹配多行VS Code 正则表达式匹配多行VS Code 正则表达式匹配多行VS Code 正则表达式匹配多行VS Code 正则表达式匹配多行VS Code 正则表达式匹配多行', fn: function test() { alert(1) }, } 案例1：const(.|\n)*?\}$
案例2：str(.|\n)*?,
案例3：fn(.|\n)*?\},
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b03783d1328f6e0f537c409990f38ac/" rel="bookmark">
			C&#43;&#43;力扣题目111--二叉树的最小深度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		力扣题目链接(opens new window)
给定一个二叉树，找出其最小深度。
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
说明: 叶子节点是指没有子节点的节点。
示例:
给定二叉树 [3,9,20,null,null,15,7],
返回它的最小深度 2
思路 看完了这篇104.二叉树的最大深度 (opens new window)，再来看看如何求最小深度。
直觉上好像和求最大深度差不多，其实还是差不少的。
本题依然是前序遍历和后序遍历都可以，前序求的是深度，后序求的是高度。
二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数后者节点数（取决于高度从0开始还是从1开始） 那么使用后序遍历，其实求的是根节点到叶子节点的最小距离，就是求高度的过程，不过这个最小距离 也同样是最小深度。
以下讲解中遍历顺序上依然采用后序遍历（因为要比较递归返回之后的结果，本文我也给出前序遍历的写法）。
本题还有一个误区，在处理节点的过程中，最大深度很容易理解，最小深度就不那么好理解，如图：
这就重新审题了，题目中说的是：最小深度是从根节点到最近叶子节点的最短路径上的节点数量。，注意是叶子节点。
什么是叶子节点，左右孩子都为空的节点才是叶子节点！
#递归法 来来来，一起递归三部曲：
确定递归函数的参数和返回值 参数为要传入的二叉树根节点，返回的是int类型的深度。
代码如下：
int getDepth(TreeNode* node) 确定终止条件 终止条件也是遇到空节点返回0，表示当前节点的高度为0。
代码如下：
if (node == NULL) return 0; 确定单层递归的逻辑 这块和求最大深度可就不一样了，一些同学可能会写如下代码：
int leftDepth = getDepth(node-&gt;left); int rightDepth = getDepth(node-&gt;right); int result = 1 + min(leftDepth, rightDepth); return result; 这个代码就犯了此图中的误区：
如果这么求的话，没有左孩子的分支会算为最短深度。
所以，如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。
反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。 最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b03783d1328f6e0f537c409990f38ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/195def75a818d5df22ddf6ee9d3c1bcb/" rel="bookmark">
			软件设计师真题，设计模式专项练习（七）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组合模式 设计模式中的 （45） 模式将对象组合成树形结构以表示“部分-整体”的层次结构，使得客户对单个对象和组合对象的使用具有一致性。下图为该模式的类图，其中， （46） 定义有子部件的那些部件的行为；组合部件的对象由 （47） 通过Component提供的接口操作。（2012年上半年）
（45） A. 代理（Proxy） B. 桥接器（Bridge）
C. 组合（Composite） D. 装饰器（Decorator）
（46） A. Client B. Component C. Leaf D. Composite
（47） A. Client B. Component C. Leaf D. Composite
下图所示为 （46） 设计模式，适用于： （47） 。（2013年下半年）
（46） A. 组件（Component） B. 适配器（Adapter）
C. 组合（Composite） D. 装饰器（Decorator）
（47） A. 表示对象的部分—整体层次结构
B. 不希望在抽象和它的实现部分之间有一个固定的绑定关系
C. 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责
D. 使所有接口不兼容类可以一起工作
下图所示为 （44） 设计模式，属于 （45） 设计模式，适用于 （46） 。（2015年上半年）
（44） A. 代理（Proxy） B. 生成器（Builder）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/195def75a818d5df22ddf6ee9d3c1bcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82fe8cd546f9279a76c61a3cc459ab7d/" rel="bookmark">
			软件设计师真题，设计模式专项练习（六）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		桥接模式 设计模式 （44） 将抽象部分与其实现部分相分离，使它们都可以独立地变化。下图为该设计模式的类图，其中， （45） 用于定义实现部分的接口。（2011年上半年）
（44） A. Bridge（桥接） B. Composite（组合）
C. Facade（外观） D. Singleton（单例）
（45） A. Abstraction B. ConcretelmplementorA
C. ConcretelmplementorB D. Implementor
假设现在要创建一个Web应用框架，基于此框架能创建不同的具体Web应用，比如博客，新闻网站和网上商店等；并可以为每个Web应用创建不同的主题样式，比如浅色或深色等。这一业务需求的类图设计适合采用 （44） 模式（如下图所示）。其中 （45） 是客户程序使用的主要接口，维护对主题类型的应用。此模式为 （46） ，提现的最主要的意图是 （47） 。（2018年上半年）
（44） A. 观察者（Observer） B. 访问者（Visitor）
C. 策略（Strategy） D. 桥接（Bridge）
（45）A. WebApplication B. Blog C. Theme D. Light
（46） A. 创建型对象模式 B. 结构型对象模式 C. 行为型类模式 D. 行为型对象模式
（47） A. 将抽象部分与其实现部分分离，使它们都可以独立地变化
B. 动态地给一个对象添加一些额外的职责
C. 为其他对象提供一种代理以控制对这个对象的访问
D. 将一个类的接口转换成客户希望的另一个接口
欲开发一个绘图软件，要求使用不同的绘图程序绘制不同的图形，该绘图软件的扩展性要求将不断扩充新的图形和新的绘图程序，以绘制直线和图形为例，得到如下图所示的类图，该设计采用 （44） 模式将抽象部分与其实现部分分离，使它们都可以独立地变化。其中 （45） 定义了实现类地接口，该模式适用于 （46） 的情况，该模式属于 （47） 模式。（2019年下半年）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82fe8cd546f9279a76c61a3cc459ab7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f270b8ba1df68fec83356d772707355a/" rel="bookmark">
			uniapp生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用生命周期 uni-app支持如下应用生命周期函数
函数名说明onLaunch当uni-app初始化完成时触发（全局只触发一次）onShow当uni-app启动，或从后台进入前台显示onHide当uni-app从前台进入后台onError当uni-app报错时触发onUniNViewMessage对nvue页面发送的数据进行监听onUnhandledRejection对未处理的 Promise 拒绝事件监听函数onPageNotFound页面不存在监听函数onThemeChange监听系统主题变化 注意
应用生命周期仅可在App.vue中监听，在其它页面监听无效。
页面生命周期 uni-app支持如下页面生命周期函数
函数名说明onInit监听页面初始化onLoad监听页面加载onShow监听页面显示onReady监听页面初次渲染完成onHide监听页面隐藏onUnload监听页面卸载onResize监听窗口尺寸变化onPullDownRefresh监听用户下拉动作，一般用于下拉刷新onReachBottom页面上拉触底事件的处理函数onTabItemTap点击 tab 时触发onShareAppMessage用户点击右上角分享onPageScroll监听页面滚动onNavigationBarButtonTap监听原生标题栏按钮点击事件onBackPress监听页面返回onNavigationBarSearchInputChanged监听原生标题栏搜索输入框输入内容变化事件onNavigationBarSearchInputConfirmed监听原生标题栏搜索输入框搜索事件，用户点击软键盘上的“搜索”按钮时触发onNavigationBarSearchInputClicked监听原生标题栏搜索输入框点击事件onShareTimeline监听用户点击右上角转发到朋友圈onAddToFavorites监听用户点击右上角收藏 onInit使用注意
仅百度小程序基础库 3.260 以上支持 onInit 生命周期其他版本或平台可以同时使用 onLoad 生命周期进行兼容，注意避免重复执行相同逻辑不依赖页面传参的逻辑可以直接使用 created 生命周期替代 onReachBottom使用注意，可在pages.json里定义具体页面底部的触发距离onReachBottomDistance，比如设为50，那么滚动页面到距离底部50px时，就会触发onReachBottom事件。
如使用scroll-view导致页面没有滚动，则触底事件不会被触发。scroll-view滚动到底部的事件请参考scroll-view的文档
onPageScroll（监听滚动、滚动监听、滚动事件）参数说明：
属性类型说明scrollTopNumber页面在垂直方向已滚动的距离（单位px） onPageScroll里不要写交互复杂的js，比如频繁修改页面。因为这个生命周期是在渲染层触发的，在非h5端，js是在逻辑层执行的，两层之间通信是有损耗的。如果在滚动过程中，频发触发两层之间的数据交换，可能会造成卡顿。 onPageScroll : function(e) { //nvue暂不支持滚动监听，可用bindingx代替 console.log("滚动距离为：" + e.scrollTop); }, onTabItemTap返回的json对象说明：
属性类型说明indexString被点击tabItem的序号，从0开始pagePathString被点击tabItem的页面路径textString被点击tabItem的按钮文字 onTabItemTap常用于点击当前tabitem，滚动或刷新当前页面。如果是点击不同的tabitem，一定会触发页面切换。如果想在App端实现点击某个tabitem不跳转页面，不能使用onTabItemTap，可以使用plus.nativeObj放一个区块盖住原先的tabitem，并拦截点击事件。支付宝小程序平台onTabItemTap表现为点击非当前tabitem后触发，因此不能用于实现点击返回顶部这种操作 onTabItemTap : function(e) { console.log(e); // e的返回格式为json对象： {"index":0,"text":"首页","pagePath":"pages/index/index"} }, onNavigationBarButtonTap参数说明：
属性类型说明indexNumber原生标题栏按钮数组的下标 onNavigationBarButtonTap : function (e) { console.log(e); // e的返回格式为json对象：{"text":"测试","index":0} } onBackPress回调参数对象说明：
属性类型说明fromString触发返回行为的来源：‘backbutton’——左上角导航栏按钮及安卓返回键；‘navigateBack’——uni.navigateBack() 方法。支付宝小程序端不支持返回此字段 export default { data() { return {}; }, onBackPress(options) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f270b8ba1df68fec83356d772707355a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38002fe5274feef694f54d64af87b0b0/" rel="bookmark">
			【uview2.0】Keyboard 键盘 与 CodeInput 验证码输入 结合使用 uview
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.uviewui.com/components/codeInput.html （CodeInput 验证码输入）
https://www.uviewui.com/components/keyboard.html （Keyboard 键盘）
&lt;u-keyboard	mode="number" :dotDisabled="true" :show="show" tips='密码为6位数字' confirmText='完成' closeOnClickOverlay @change="changeFun" @close="closeFun" @cancel="closeFun" @confirm='confirmFun' @backspace="backspaceFun" &gt; &lt;view class="flex_center u-bg-white u-p-t-40"&gt; &lt;u-code-input v-model="value" dot&gt;&lt;/u-code-input&gt; &lt;/view&gt; &lt;/u-keyboard&gt; // 按键被点击(不包含退格键被点击) changeFun(e){ // 最多输入6为数字 if(this.value.length &gt;= 6){ return; } this.value += e; }, // 键盘退格键被点击 backspaceFun(){ this.value = this.value.slice(0, -1); }, // 确定 密码键盘 confirmFun(){ console.log('密码为：', this.value) this.show = false; this.value = ''; }, // 关闭 密码键盘 closeFun(){ this.show = false; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38002fe5274feef694f54d64af87b0b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7786d34985aa7d74fd4bff737f7eec18/" rel="bookmark">
			软件设计师真题，设计模式专项练习（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		适配器模式 （47） 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。（2011年上半年）
（47） A. Adapter（适配器）模式 B. Command（命令）模式
C. Singleton（单例）模式 D. Strategy（策略）模式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0633d58e6459678085908f7516fb92d/" rel="bookmark">
			服务端性能测试——性能测试工具JMeter-L1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一遍没学懂，后续文章会更新~ 目录：
1.JMeter介绍与安装Meter简介JMeter安装2.JMeter的运行JMeter运行、界面功能简介3.使用代理服务器录制请求录制压测脚本（一）Web端脚本录制方法4.测试计划5.线程组6.控制器7.JMeter采样器/取样器8.JMeter场景逻辑控制技术9.JMeter监听器10.JMeter定时器11.JMeter断言元件的使用12.JMeter常用配置元件剖析13.JMeter前置处理器前置处理器SampleTimeout前置处理器Beanshell前置处理器14.JMeter后置处理器15.JMeter执行顺序16.JMeter虚拟用户管理17.HTTP请求属性设置18.HTTPcookie设置Cookiemanager19.HTTP信息头管理器Headermanager20.HTTP请求设置21.监听器与测试结果Listener&amp;测试结果 1.JMeter 介绍与安装 Meter简介 Apache组织开发的开源免费压测工具纯Java程序，跨平台性强源程序可以从网上下载高可扩展性可对服务器、网络或对象模拟巨大的负载，进行压力测试可以用于接口测试支持分布式、多节点部署 JMeter 安装 下载位置：
官网 https://jmeter.apache.org/binary 可运行文件包官网下载规律 首页 -&gt; Download -&gt; binariesJMeter 安装方法： 直接解压Demo： JMeter 官网寻找安装包，下载，解压 2.JMeter 的运行 JMeter 运行、界面功能简介 运行环境要求：java运行时环境运行方法：命令行直接启动 $jmeter_home/bin/jmeter.sh常规的菜单功能：新建、保存、查询、配置、帮助 等压测运行相关：开始运行、停止运行、远程运行、停止远程运行 等设定外观长相更改配置语言，不过建议用英语（个人体会中文翻译的有点晕）Demo – JMeter 界面操作、外观、语言 3.使用代理服务器录制请求 录制压测脚本（一）Web 端 压测对象 - http://news.baidu.com压测页面 – 百度首页，百度新闻步骤： 访问百度首页单击进入“百度新闻”操作手段： 录制回放，上手容易，入门学习的好手段 脚本录制方法 打开 JMeter新建压测脚本添加 “HTTP(S) Test Script Recorder” 添加“Thread Group” 在 Thread Group中添加“Recording Controller” 打开 HTTP(S) Test Script Recorder设定 Port = 8088设定 Target Controller = Test Plan &gt; Tread Group &gt; Recording Controller 在 Requests Filtering 添加“include”与 “Exclude”URL 正则匹配表达式目的：避免录制过多没必要的请求Include： .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0633d58e6459678085908f7516fb92d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88f5fc699c2d2e09ab6f336071d4ae92/" rel="bookmark">
			软件设计师真题，设计模式专项练习（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单例模式 以下关于Singleton（单例）模式的描述中，正确的是 （46） 。（2011年上半年）
（46） A. 它描述了只有一个方法的类的集合
B. 它描述了只有一个属性的类的集合
C. 它能够保证一个类的方法只能被一个唯一的类调用
D. 它能够保证一个类只产生唯一的一个实例
欲使类A的所有使用者都使用A的同一个实例，应 （47） 。（2012年下半年）
（47） A. 将A标识为final
B. 将A标识为abstract
C. 将单例（Singleton）模式应用于A
D. 将备忘（Memento）模式应用于A
以下关于Singleton（单例）设计模式的叙述中，不正确的是 （44） 。（2015年下半年）
（44） A. 单例模式是创建型模式
B. 单例模式保证一个类仅有一个实例
C. 单例类提供一个访问唯一实例的全局访问点
D. 单例类提供一个创建一系列相关或相互依赖对象的接口
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87fd4a8dd9399f005b113293d376a521/" rel="bookmark">
			js判断是否是一个数包括0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在JavaScript中，可以使用isNaN()函数来判断一个值是否为数字。如果该值不是数字或者是特定的非数字类型（比如Infinity、-Infinity等），则返回true；反之，返回false。
下面是示例代码：
function isNumber(value) { return !isNaN(parseFloat(value)) &amp;&amp; isFinite(value); } console.log(isNumber("123")); // true console.log(isNumber("abc")); // false console.log(isNumber(0)); // true console.log(isNumber(-5)); // true console.log(isNumber(null)); // false console.log(isNumber([])); // false 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7819700711d338c2bf1204a9c154bd24/" rel="bookmark">
			前端 JS篇快问快答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：常见的特殊字符（不包括空格\s） 正则表达式为：
回答：/[!@#$%^&amp;*()\-_=+{};:'",.&lt;&gt;/?[\]~`|]/ （加粗的紫色字符都是特殊字符）
问题：常见的特殊字符（包括空格\s） 正则表达式为：
回答：/[\s!@#\$%\^&amp;\*\(\)\-_=+\{\};:'",.&lt;&gt;\/\?\\[\]~`|]（加粗的紫色字符都是特殊字符）
问题：不能输入常见的特殊字符（包括空格） 正则表达式为：（加粗的紫色字符都是特殊字符）
回答：/[^!@#\$%\^&amp;*()\-\_=+{};:'",.&lt;&gt;\/?[\]~`| ]/
问题：不能输入空格 正则表达式为：
回答：/^\S+$/
问题：只允许数字 正则表达式为：
回答：/\D/g
问题：只允许数字和中文 正则表达式为：
回答：/[\d]/g
问题：只允许英文字母和数字 正则表达式为：
回答：/[^\w\.\/]/ig
问题：不能输入字母 正则表达式为：
回答：/[^\d|chun]/g
问题：数组中的push()和unshift()方法返回的什么？
回答：返回的是新数组的长度
问题：数组中的pop()和shift() 方法返回的什么？
回答：返回的是被移除的元素
问题：数组中的forEach()返回的什么？
回答：返回的是undefined
问题：数组为空，调用数组中常见的方法会报错吗？
回答：不会，如果数组为空，调用 pop()、shift()、splice() 方法不会报错，它们会返回 undefined。调用 push()、unshift() 方法也不会报错，它们会返回新数组的长度。concat()、map()、filter()、forEach()、slice() 方法也不会报错，它们会返回一个新数组或 undefined。
问题：数组中的concat()返回的是新数组，但是为什么有个时候原数组也会受到影响？
回答：浅克隆，虽然 concat() 方法不会改变原数组，但如果原数组中包含对象或数组，那么新数组中的对象或数组仍然会被引用，因此修改新数组中的对象或数组也会影响原数组。
问题：字符串中的replace()和replaceAll()方法有什么特点
回答：都是传两个参数，当第一个参数是字符串的时候，replace 只替换匹配到的第一个位置，replaceAll 会替换每一个匹配到的地方；第一个参数是正则表达式时，没有区别；除此之外，两个函数的第二个参数都可以传入一个函数，用来自定义替换规则。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d924c00c19e859105373f0337bebd06/" rel="bookmark">
			LINUX常用工具之kdump分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： Linux操作系统的内核一般来说比较稳定，有些机器跑了十多年没有重启过，但是海量机器面前仍不可避免会遇到各种崩溃的情况，本文介绍使用kdump获取内核崩溃时的内存镜像，有助于分析系统在崩溃前发生了什么，分析原因并修复错误，进而进一步提升系统的稳定性。
一、kdump简介 kdump 是目前最有效的linux内存镜像收集机制，广泛应用于各大linux厂商的各种产品中，在 debug 内核方面起着不可替换的重要作用。
Kdump 是一种基于 kexec 的 Linux 内核崩溃捕获机制，将 kernel 崩溃前的内存镜像保存，程序员通过分析该文件找出 kernel 崩溃的原因，从而进行系统改进。
Kdump用于对内存镜像的转储，它不但可以转储内存镜像到本地硬盘，还可以将内存镜像通过NFS，SSH等协议转储到不同机器的设备上。
Kdump分为两个组件：Kexec和Kdump。
Kexec是一种内核的快速启动工具，可以使新的内核在正在运行的内核（生产内核）的上下文中启动，而不需要通过耗时的BIOS检测，方便内核开发人员对内核进行调试。Kdump是一种有效的内存转储工具，启用Kdump后，生产内核将会保留一部分内存空间，用于在内核崩溃时通过Kexec快速启动到新的内核，这个过程不需要重启系统，因此可以转储崩溃的生产内核的内存镜像。
二、kdump安装 2.1 安装包
调试 kdump 生成的 vmcore 文件，需要手动安装 kernel-debuginfo 包。检查安装包操作，注意kernel-debuginfo和kernel-debuginfo的版本要和内核版本一致：
以 RHEL 为例，安装 crash 及内核调试信息包的步骤如下：
rpm -ivh crash-5.1.8-1.el6.ppc64.rpm rpm -ivh kernel-debuginfo-common-ppc64-2.6.32-220.el6.ppc64.rpm rpm -ivh kernel-debuginfo-2.6.32-220.el6.ppc64.rpm
安装可从这里下载：
http://debuginfo.centos.org/7/x86_64/kernel-debuginfo-3.10.0-1127.el7.x86_64.rpm
http://debuginfo.centos.org/7/x86_64/kernel-debuginfo-common-x86_64-3.10.0-1127.el7.x86_64.rpm
2.2 配置kdump配置文件
在/boot/grub/grub.conf文件中添加内核参数"crashkernel=Y@X"，这里，Y 是为 kdump 捕捉内核保留的内存，X 是保留部分内存的开始位置。对于 i386 和 x86_64, 编辑 /etc/grub.conf, 在内核行的最后添加"crashkernel=128M" 。另外建议不要设置为crashkernel=auto，因为rhel6引入的”auto”已经要被抛弃了。
2.3 配置kdump的一些参数。
kdump默认将文件存放在本地硬盘的/var/crash/目录下，该位置可以是本地文件系统的某个目录，或者某个块设备，或者通过网络存储在其他机器上，可以修改文件：
cat /etc/kdump.conf
注: --message-devel 1表示提示信息的级别，1表示只显示进度信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d924c00c19e859105373f0337bebd06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89a3cfb38bc8a5c8211e61490b8a7a68/" rel="bookmark">
			Mac截屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 环境截取全屏截取选定内容截图包含鼠标延迟截屏其它 环境 MacOS 14.2.1 (23C71) 截取全屏 快捷键：Command + Shift + 3
生成的图片为png格式，默认位置在桌面。
注：如果有多个显示屏，则每个显示屏都会截取一张图片。
截取选定内容 快捷键：Command + Shift + 4
然后再拖动鼠标，选取屏幕内容。
生成的图片为png格式，默认位置在桌面。
截图包含鼠标 默认情况下，截图时不包含鼠标。这在有tooltip时可能会对用户造成困扰。
比如：
图片里没有显示鼠标箭头，但是能看到鼠标的效果：下划线和tooltip。
如果想在截图里包含鼠标，按 “Command + Shift + 5” ，在弹出窗口，展开“Options”选项，然后勾选“Show Mouse Pointer”：
然后再按Command + Shift + 3截图，就包含鼠标了：
延迟截屏 前面的截图里包含了tooltip。但是有些tooltip，在按下任意键的瞬间，就消失了。此时就无法采用实时截图的方法，解决办法是延迟截图。
本例中，假设按下任意键，tooltip就会消失。
按 “Command + Shift + 5” ，在弹出窗口，展开“Options”选项，可以看到Timer里有“5 seconds”、“10 seconds”。比如选择5秒延迟，然后点击“Capture”按钮，移动鼠标，显示tooltip，静等倒计时结束，截图里就包含tooltip了。
注意：在选项窗口里，可以选择“截取全屏”或“截取选定内容”，前者会包含鼠标，后者不包含鼠标（前提是选择了包含鼠标）。
注：“包含鼠标”是全局设置（对“Command + Shift + 3”和“Command + Shift + 4”也有效）。但在测试里，我发现延迟截屏的设置，对“Command + Shift + 3”和“Command + Shift + 4”无效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89a3cfb38bc8a5c8211e61490b8a7a68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d62105d559641503938871e5afb106b/" rel="bookmark">
			vue中下载图片跨域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在vue.config.js中配置跨域
'/upload': { //代理图片下载的接口 target: "http://zyy.com", changeOrigin: true, secure: false, // 设置支持https协议的代理 pathRewrite: { '^/upload': '' } } 由于项目中的请求是走的其他地址， 图片是前端上传到obs上的，所以需要配两个跨域。
写请求图片方法
/** * * @param url 图片地址 */ export async function getImage(url: string) { const { data } = await Axios({ method: "GET", url: "/upload" + url, responseType: "blob" }) return data; } 下载图片方法
down: (file: IfFileList) =&gt; { getImage(file.url).then(res =&gt; { const fileName = file.fileName; const myBlob = new Blob([res], { type: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d62105d559641503938871e5afb106b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9d3203a2e8aa562aac49239f8c6e898/" rel="bookmark">
			uniapp 图片懒加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html &lt;view class="u-f wrap itembox"&gt; &lt;view class="imgitem" v-for="(item,i) in list" :key="i" @click.stop="chooseFun(item)"&gt; &lt;view class="u-rela" @click.stop="previewFun(item)"&gt; &lt;image :src="(item.show ? item.img+'?x-oss-process=video/snapshot,t_0,f_jpg' : '')" mode="aspectFill" class="img"&gt;&lt;/image&gt; &lt;image src="@/static/img/stop.png" mode="" class="stopimg"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class="text u-flex"&gt; &lt;image src="@/static/img/c1.png" mode="" class="u-w-40 u-h-40 u-m-r-4" v-if="item.choose"&gt;&lt;/image&gt; &lt;image src="@/static/img/c.png" mode="" class="u-w-40 u-h-40 u-m-r-4" v-else&gt;&lt;/image&gt; &lt;text :class="item.choose ? 'u-color-163' :'u-color-777'"&gt;{{item.choose ? '已选' :'未选'}} &lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; js onPageScroll() { // 滚动事件 this.showImg() ，延迟时间，立即执行 uni.$u.throttle(this.showImg, 0,true) }, onReady() { let that = this uni.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9d3203a2e8aa562aac49239f8c6e898/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eb95b4c0d843945c3b1e40c881915b0/" rel="bookmark">
			使用 rosdep 管理依赖关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是rosdep？ rosdep是 ROS 的依赖管理实用程序，可以与 ROS 包和外部库一起使用。 是一个命令行实用工具，用于标识和安装依赖项以生成或安装包。 在以下情况下，可以调用或调用它：rosdep
构建工作区并需要适当的依赖项来构建其中的包
安装软件包（例如）以检查其执行所需的依赖项sudo apt install ros-galactic-demo-nodes-cpp
还有更多！
它能够处理单个包或包目录（例如工作区）。
关于包.xml文件的一些信息 包的文件包含一组依赖项。 此文件中的依赖项通常称为“rosdep 键”。 这些在标记 、 、 和 中表示。 它们指定在什么情况下需要每个依赖项。package.xml&lt;depend&gt;&lt;test_depend&gt;&lt;exec_depend&gt;&lt;build_depend&gt;&lt;build_export_depend&gt;
对于仅用于测试代码的依赖项（例如），请使用 .gtesttest_depend
对于仅在构建代码时使用的依赖项，请使用 .build_depend
对于代码导出的标头所需的依赖项，请使用 .build_export_depend
对于仅在运行代码时使用的依赖项，请使用 .exec_depend
对于混合用途，请使用 ，它涵盖了生成、导出和执行时间依赖项。depend
这些依赖项由包的创建者手动填充到文件中，并且应该是它所需的任何非内置库和包的详尽列表。package.xml
rosdep是如何工作的？ rosdep将检查其路径中的文件或特定包，并查找存储在其中的 rosdep 密钥。 然后，将这些键与中心索引进行交叉引用，以在各种包管理器中找到合适的 ROS 包或软件库。 最后，一旦找到软件包，它们就被安装并准备好了！package.xml
我如何知道在我的包 .xml 中放入哪些密钥？ 对于 ROS 包（例如），您可以简单地放置包的名称。 您可以在 at 中找到给定 ROS 发行版的所有已发布 ROS 包的列表。nav2_bt_navigatorrosdistro&lt;distro&gt;/distribution.yaml
对于非 ROS 包系统依赖，我们需要找到特定库的密钥。 通常，有两个感兴趣的文件：和 . 通常包含系统依赖项。 通常包含 Python 依赖项。rosdep/base.yamlrosdep/python.yamlbase.yamlaptpython.yamlpip
若要查找键，请在此文件中搜索您的库（最好是 ctrl+F，它的长），并在其中找到包含它的名称。 这是放入文件的密钥。yamlpackage.xml
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7eb95b4c0d843945c3b1e40c881915b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/043d816a89337b7f3c05fec015d68813/" rel="bookmark">
			node.js笔记（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 node,js是一个基于chrome v8引擎的javascript运行环境。
浏览器是javascript的前端运行环境。
node.js是javascript的后端运行环境。
node.js中无法调用浏览器中内置的DOM和BOM等API。
node.js作为一个javascript的运行环境，仅仅提供了基础的功能和API。
浏览器中JavaScript的学习路径
JavaScript的基础语法+浏览器内置API（DOM+BOM等）+第三方库（jQuery等）
node.js的学习路径
JavaScript的基础语法+node.js内置API模块（fs，http，path等）+第三方API模块（express，mysql等）
node.js中LTS版本为稳定版。
node.js中current为新特性尝鲜版。
打开终端，在终端中输入node -v可以查看node.js的版本号，以此确定是否安装成功。
在node.js中环境中执行JavaScript代码分为两步
一，打开终端
二，输入node要执行的JS文件路径
首先创建一个1.js的文件，里边输入如下的代码
console.log('hello node.js') 在终端中输入node以及JS文件的路径，回车，运行代码。
node E:\node.js\1.js 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4efd59d3b6b71706a35cb8adae03f770/" rel="bookmark">
			在C&#43;&#43;中使用嵌套命名空间是一种组织代码的方式，特别是在大型项目或库中。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 组织性和模块化2. 防止命名冲突3. 更清晰的依赖关系4. 灵活的使用和避免污染全局命名空间实际项目中的指导意义代码实战补充内容 在C++中使用嵌套命名空间是一种组织代码的方式，特别是在大型项目或库中。这种做法有几个潜在的优势： 1. 组织性和模块化 嵌套命名空间有助于更好地组织代码。在大型项目中，您可能会有很多类、函数和变量。将这些组织到逻辑上相关的命名空间中，可以提高代码的可读性和可维护性。例如，一个大型的机器人软件项目可能包含多个模块，如控制器、感知、规划等，每个模块可以有自己的命名空间。
2. 防止命名冲突 在不同的命名空间中，可以有相同的类名、函数名或变量名，而不会发生冲突。例如，robot::control::Controller 和 robot::planning::Controller 可以共存，尽管它们共享相同的类名 Controller，但由于位于不同的命名空间中，因此不会发生冲突。
3. 更清晰的依赖关系 通过使用嵌套命名空间，可以更清楚地表达代码间的层次和依赖关系。这对于理解和维护大型代码库非常重要。例如，robot::ros 命名空间可能专门用于与 ros 相关的功能，使得项目结构更加清晰。
4. 灵活的使用和避免污染全局命名空间 使用嵌套命名空间可以避免在全局命名空间中定义太多的名称，从而减少了全局命名空间的污染。此外，用户可以选择使用整个命名空间，或者只是其中的一部分，这提供了更大的灵活性。
实际项目中的指导意义 在实际项目中，嵌套命名空间的使用应遵循以下指导原则：
保持一致性：整个项目中应该以一致的方式使用命名空间。避免过度嵌套：过多的嵌套层次可能会导致代码复杂和难以理解。通常，两到三级嵌套就足够了。明确目的：每个命名空间应该有一个明确的目的和定义的职责。易于理解：命名空间的命名应该直观和描述性，以便于理解其内容。 在设计代码结构时，应根据项目的具体需求和上下文来决定是否使用嵌套命名空间，以及如何使用它们。
代码实战 当然，我们可以修改之前的例子，使用不同的命名空间，并补充完整代码。假设我们改用命名空间 robotics_system，并在里面定义 navigation、diagnostics 和 communication 三个嵌套命名空间。每个嵌套的命名空间将包含一个与其相关功能的类。
首先是头文件，定义了命名空间和类：
// 文件名：RoboticsModules.h #ifndef ROBOTICS_MODULES_H #define ROBOTICS_MODULES_H namespace robotics_system { namespace navigation { class Navigator { public: void navigate() { // 导航相关的功能 } }; } // namespace navigation namespace diagnostics { class DiagnosticTool { public: void diagnose() { // 诊断相关的功能 } }; } // namespace diagnostics namespace communication { class Communicator { public: void communicate() { // 通信相关的功能 } }; } // namespace communication } // namespace robotics_system #endif // ROBOTICS_MODULES_H 然后是一个示例主函数，展示如何使用这些类：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4efd59d3b6b71706a35cb8adae03f770/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0be0e3bfbb15808c9c2df8aa44dcc7df/" rel="bookmark">
			SpringSecurity入门demo(一)集成与默认认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、集成与默认认证：
1、说明：在引入 Spring Security 项目之后，没有进行任何相关的配置或编码的情况下，Spring Security 有一个默认的运行状态，要求在经过 HTTP 基本认证后才能访问对应的 URL 资源，其默认使用的用户名为 user， 密码则是动态生成并打印到控制台的一串随机码。
2、demo验证：
（1）pom：只需要pom添加相关依赖，即完成默认集成功能
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.demo.security&lt;/groupId&gt; &lt;artifactId&gt;security-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.14.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0be0e3bfbb15808c9c2df8aa44dcc7df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a9e29a4641ce580c54d65ce19afec8/" rel="bookmark">
			推荐熊猫电竞赏金电竞系统源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		熊猫电竞赏金电竞系统源码，包含APP、H5和搭建视频教程，支持运营级搭建，这套源码是基于ThinkPHP+Uniaapp框架开发的。
系统是一套完整的电竞平台开发源码，包括赛事管理、用户系统、竞猜系统、支付系统等模块。源码结构清晰，代码规范，易于定制和扩展，可快速搭建个性化的电竞赛事平台。 演示 地 址：runruncode.com/php/19674.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f27ef263396332347a0207f4b8469460/" rel="bookmark">
			猫头虎揭秘：互联网传统行业内成为顶尖高级工程师的12大关键素质与能力‍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主猫头虎的技术世界
🌟 欢迎来到猫头虎的博客 — 探索技术的无限可能！
专栏链接：
🔗 精选专栏：
《面试题大全》 — 面试准备的宝典！《IDEA开发秘籍》 — 提升你的IDEA技能！《100天精通Golang》 — Go语言学习之旅！ 领域矩阵：
🌐 猫头虎技术领域矩阵：
深入探索各技术领域，发现知识的交汇点。了解更多，请访问：
猫头虎技术矩阵新矩阵备用链接 文章目录 猫头虎分享：成为高级工程师的必备素质与能力👩‍💻🚀摘要引言正文1. 基础扎实：编程基础的重要性小结 2. 精通至少一门编程语言小结 3. 开源项目的学习与分析示例小结 4. 高并发处理经验小结 5. 沟通能力小结 6. 问题解决能力如何系统地解决复杂问题小结 7. 团队合作与领导力成为团队中不可或缺的一员小结 8. 持续学习和适应新技术跟上技术发展的步伐小结 9. 项目管理和时间管理能力高效地管理多个项目小结 10. 安全意识和最佳实践保护代码免受安全威胁小结 11. 性能优化提高系统效率和可靠性小结 12. 用户体验和需求理解从用户的角度思考小结 参考资料表格总结本文总结 猫头虎分享：成为高级工程师的必备素质与能力👩‍💻🚀 摘要 与 猫头虎博主一起踏上变革之旅，我们将揭开晋升高级工程师角色的关键素质和技能。这本综合指南超越了单纯的技术细节，涵盖了从基础编程到对编程语言的掌握、对开源项目的深入分析、对高并发的熟练处理，以及经常被忽视但至关重要的沟通艺术。本文对于崭露头角的程序员和经验丰富的开发人员来说都是重要的资源，为您铺平道路成为一名杰出的高级工程师。重点主题包括：高级工程师素质、编程基础、语言能力、开源分析、高并发管理、沟通技巧。
引言 欢迎来到猫头虎博客，今天的焦点转移到我经常思考的一个问题——高级工程师有何不同？虽然许多人可能会列出一系列技术技能，但真正的高级工程师的本质远远不止于此。品质和能力错综复杂，每一条线索都同样重要。让我们开始这一富有洞察力的探索，揭开构成高级工程师核心的技能和特质的结构。从编程基础的基石到细致入微的沟通艺术，和我一起深入了解先进工程专业知识的世界。🔍💡
正文 1. 基础扎实：编程基础的重要性 高级工程师的首要条件是拥有扎实的编程基础。这不仅意味着理解基本的编程概念，如变量、循环、数据结构等，还包括算法和设计模式的知识。深入的理解并掌握这些基础知识，是建立复杂系统和解决高难度编程问题的前提。
一个高级工程师不仅应该了解如何编写代码，更重要的是理解其背后的原理。比如，了解不同的排序算法（冒泡排序、快速排序等）以及它们的时间复杂度和空间复杂度，有助于在需要时选择最优的解决方案。
让我们看一个基础但十分重要的算法示例 - 冒泡排序：
# 示例代码：一个简单的冒泡排序算法 def bubbleSort(arr): n = len(arr) for i in range(n-1): for j in range(0, n-i-1): if arr[j] &gt; arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr # 测试代码 test_array = [64, 34, 25, 12, 22, 11, 90] sorted_array = bubbleSort(test_array) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f27ef263396332347a0207f4b8469460/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51512d502261b401857ce52ea7ae9cf5/" rel="bookmark">
			JVM-Arthas高效的监控工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、arthas介绍
3.选择监控哪个进程
4.进入具体进程
二、arthas的基础命令与基本操作
1.查询包含Java的系统属性：
命令：sysprop |grep java
1.查询不含Java的系统属性：
命令：sysprop | grep -v java
3.打印历史命令
命令：history
4.查看当前工作目录
命令：pwd
三、如何使用arthas监控线上服务的内存状态
1.dashboard - 当前系统的实时数据面板
命令：dashboard -i 100 100毫秒刷新一次
命令：dashboard -n 2 刷新两次
命令：dashboard -n 2 -i 1000 每1秒刷新一次共刷新两次
2.thread - 查看当前线程信息，查看线程的堆栈
支持一键展示当前最忙的前N个线程并打印堆栈：
命令：thread -n 3
当没有参数时，显示第一页线程的信息
命令：thread
显示指定线程的运行堆栈
命令：thread id
查看阻塞的线程
命令：thread -b
3.heapdump - dump java heap, 类似 jmap 命令的 heap dump 功能.
dump 到指定文件 命令：heapdump arthas-output/dump.hprof
4.jvm - 查看当前JVM信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51512d502261b401857ce52ea7ae9cf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/351b0f4fc76f8de09167460a7d414b20/" rel="bookmark">
			Atom feeds是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人github Atom feeds 是一种常用的 web feed 格式，用于发布经常更新的网页内容，如博客文章、新闻头条或者论坛帖子。用户可以订阅这些 feed，然后使用 feed 阅读器（如 Google Reader 或 Feedly）来阅读这些内容，而无需直接访问网站。
Atom 是一种基于 XML 的数据格式，它被设计为 RSS 的替代品，提供了一些 RSS 不具备的特性。例如，Atom 支持内容的更新和删除，支持内容的分页，支持更丰富的元数据，等等。
一个 Atom feed 通常包含一系列的条目（entry），每个条目对应一篇文章或一条新闻。每个条目通常包含以下信息：
id：条目的唯一标识符。title：条目的标题。link：指向条目完整内容的链接。updated：条目最后更新的时间。author：条目的作者。content 或 summary：条目的内容或摘要。 此外，Atom feed 还可以包含一些其他信息，如 feed 的标题、链接、更新时间、作者等。
总的来说，Atom feeds 是一种方便的方式，让用户可以订阅和阅读他们感兴趣的网站的更新，而无需频繁地访问这些网站。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a8c80b64f6218b84bf45ef6ebd0a314/" rel="bookmark">
			google cloud storage: Bucket is a requester pays bucket but no user project provided
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rescent I have read the paper, Effective gene expression prediction from sequence by integrating long-range interactions, Nature mathods, From Deepmind.
And the Basenji2 training, validation, and test data can not obtain.
After learn,
So we need pay it, and how to get these datassets?
step1: Create an Account
Step2: Get the gift amount
This step need visa or other bank card.
Step 3: creat project and get projectID,Yes this picture ID.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a8c80b64f6218b84bf45ef6ebd0a314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8a743feefdf3ec49380fb5294711a44/" rel="bookmark">
			Dockerfile的ADD指令对中括号转义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 环境背景分析参考 环境 RHEL 9.3Docker Community 24.0.7 背景 在Docker官方文档 https://docs.docker.com/engine/reference/builder/#add 里有这么一段话：
When adding files or directories that contain special characters (such as [ and ]), you need to escape those paths following the Golang rules to prevent them from being treated as a matching pattern. For example, to add a file named arr[0].txt, use the following;
ADD arr[[]0].txt /mydir/ 翻译成中文就是：如果添加的文件或目录包含特殊字符（比如 [ 和 ] ），需要按照Golang的规则进行转义，以避免被当成匹配模式。
例如，想要添加文件 arr[0].txt ，需要转义为 arr[[]0].txt 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8a743feefdf3ec49380fb5294711a44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/504d136d32241f5494fbc2d41279f62a/" rel="bookmark">
			模型评估：ROC曲线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二值分类器（Binary Classifier）是机器学习领域中最常见也是应用最广泛的分类器。评价二值分类器的指标很多，比如precision、recall、F1 score、P-R曲线等。相比而言，ROC曲线有很多优点，经常作为评估而知分类器最重要的指标之一。下面我们来详细了解一下ROC曲线的绘制方法和特点。
1. 什么是ROC曲线？ ROC曲线是Receiver Operating Characteristic Curve 的简称，中文名为“受试者工作特征曲线”。ROC曲线源于军事领域，而后在医学领域应用甚广，“受试者工作特征曲线”这一名称也正是来自于医学领域。
ROC曲线的横坐标为假阳性率（False Positive Rate, FPR）；纵坐标为真阳性率（True Positive Rate, TPR）。FPR和TPR的计算方法分别为
上式中，P是真正的正样本的数量，N是真实的负样本数量，TP是P个正样本中被分类器预测为正样本的个数，FP是N个负样本中被分类器预测为正样本的个数。
为了更直观地说明这个问题，我们举一个医院诊断病人的例子。假设有10为意思癌症患者，其中有3位很不幸确实患了癌症（P=3），另外7位不是癌症患者（N=7）。医院对这10位疑似患者做了诊断，判断出3位癌症患者，其中有2位确实是真正的患者（TP=2）。那么真阳性率TPR=TP/P=2/3. 对于7为非癌症的患者来说，有一位很不幸被误诊为癌症患者（FP=1），那么假阳性率FPR=FP/N=1/7. 对于“该医院”这个分类器来说，这组分类结果就对应ROC曲线上的一个点（1/7,2/3）。
2.如何绘制ROC曲线？ 事实上，ROC曲线是通过不断移动分类器的“截断点”来生成曲线上的一组关键点的，通过下面的例子进一步来解释“截断点”的概念。
在二值分类问题中，模型的输出一般都是预测样本为正例的概率。假设测试集中有20个样本，表2.1是模型的输出结果。样本按照预测概率从高到低排序。在输出最终的正例、负例之前，我们需要指定一个阈值，预测概率大于该阈值的样本会被判为正例，其他的全部都是负例。上面所说的“截断点”指的就是区分正负预测结果的阈值。
通过动态地调整截断点，从最高的得分开始（实际上是从正无穷开始，对应着ROC曲线的零点），逐渐调整到最低得分，每一个截断点都会对应一个FPR和TPR，在ROC图上绘制出每个截断点对应的位置，再连接所有点就得到最终的ROC曲线。
就此例来说，当截断点选择为正无穷时，模型把全部样本预测为负例，那么FP和TP必然都为0，FPR和TPR也都为0，因此曲线的第一个点的坐标就是（0,0）。当把截断点调整为0.9时，模型预测1号样本为正样本，并且该样本确实是正样本，因此，TP=1, 20个样本中，所有正例数量为P=10，故TPR=TP/P=1/10, 负样本总数N=10，故FPR=FP/N=0/10=0，对应ROC曲线上的点（0,0.1）。依次调整截断点，直到画出全部的关键点，再连接关键点即得到最终的ROC曲线，如图2.2所示。
其实，还有一种更直观地绘制ROC曲线的方法。首先，根据样本标签统计出正负样本的数量，假设正样本数量为P，负样本数量为N；接下来，把横轴的刻度间隔设置为1/N，纵轴的刻度间隔设置为1/P；再根据模型输出的预测概率对样本进行排序（从高到低）；依次遍历样本，同时从零点开始绘制ROC曲线，每遇到一个正样本就沿纵轴方向绘制一个刻度间隔的曲线，每遇到一个负样本就沿横轴方向绘制一个刻度间隔的曲线，直到遍历完所有样本，曲线最终停在（1,1）这个点，整个ROC曲线绘制完成。
3.如何计算AUC? AUC指的是ROC曲线下的面积大小，该值能够量化地反映基于ROC曲线衡量出的模型性能。计算AUC值只需要沿着ROC横轴做dx积分就可以了。由于ROC曲线一般都处于y=x这条直线的上方（如果不是的话，只要把模型预测的概率反转成1-p就可以得到一个更好的分类器），所以AUC的取值一般在0.5-1之间。AUC越大，说明分类器越可能把真正的正样本排在前面，分类性能越好。
4.ROC曲线相比P-R曲线有什么特点？ 当正负样本的分布发生变化时，ROC曲线的形状能够基本保持不变，而P-R曲线的形状一般会发生较剧烈的变化。
举例来说，图2.3是ROC曲线和P-R曲线的对比图，其中图2.3（a）和图2.3（c）是ROC曲线，图2.3（b）和图2.3（d）是P-R曲线，图2.3（c）和图2.3（d）则是将测试集中的负样本数量增加10倍之后的曲线图。
可以看出，P-R曲线发生了明显的变化，而ROC曲线形状基本不变。这个特点让ROC曲线能够尽量降低不同测试集带来的干扰，更加客观地衡量模型本身的性能。这有什么实际意义呢？在很多实际问题中，正负样本数量往往很不均衡。比如，计算广告领域经常涉及转化率模型，正样本的数量往往是负样本数量的1/1000甚至是1/10000. 若选择不同的测试集，P-R曲线的变化就会非常大，而ROC曲线则能够更加稳定地反映模型本身的好坏。所以，ROC曲线的适用场景更多，被广泛用于排序、推荐、广告等领域。但需要注意的是，选择P-R曲线还是ROC曲线是因实际问题而异的，如果研究者希望更多地看到模型在特定数据集上的表现，P-R曲线则能够更直观地反映其性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9072a921ee2e81bd535fb7ad44b0dc62/" rel="bookmark">
			专业140&#43;总410&#43;哈尔滨工业大学803信号与系统和数字逻辑电路考研经验哈工大电子信息（信息与通信工程-信通）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一年的努力付出终于有了收获，今年专业课140+，总分410+顺利上岸哈工大803电子信息（信息与通信-信通），回顾总结了自己这一年的复习，有得有失，希望对大家复习有所帮助。
数学
时间安排：3月-7月：看基础课程+《660题》
7-9月：强化课程+《880题》一刷和二刷
9-10月：往年真题和总结
10-12月：大量模拟卷和全真模拟
1）高数——高数建议跟武忠祥的基础和强化，讲的特别好，数学一的那部分线面积分可能要自己好好学学。
2）线代——可以无脑选择李永乐老师（永乐大帝）的线代课，课程知识点足够用。
3）概率论——基础看的课程是余炳森老师，强化看的是的是王式安老师。
现在考研的题目越来越灵活了，所以概率论要多做题，多想想为什么这样做，不要死背做题的步骤。
在最后的阶段一定要全真模拟！定时、闭卷，营造考场的氛围，做完对答案，查缺补漏，不需要算分数。
英语
我从4月份开始背单词，一直背到初试考试前。也是从4月份开始做真题、听课，穿插着读一读外刊，大概10月份，完成真题的n刷，开始重点准备作文。
英语重点是阅读，我建议大家听阅读课。
在阅读讲得比较好的老师中，我只听过唐迟和颉斌斌的课。结合我个人的感受，不太建议看颉的，有点玄学，当然，这个就见仁见智了。我更推荐唐迟的课程，一定整篇读完再做题哦，要不听不懂。
完形填空推荐易熙人老师的课。
新题型没看课，全靠自己做总结。
翻译建议看唐静老师的课。
黄皮书的例文很好，可以看看。至于作文课程，我感觉没有哪一个老师讲的特别好，后期都是背模板，分数大概在平均水平。
政治
时间安排：
7-8月看徐涛课程
9-10月 腿姐的课程
10-12月背诵选择题知识点+肖四肖八
23考研的政治选择题比22选择题难一些，网上部分老师说要重视政治，尽早开始复习政治，但我觉得政治不宜过早开始，暑假开始就来得及。
后期政治就是大量的做套卷，但是一定要总结，不要贪多！一定要做一套会一套！肖八重点看选择题，肖四才需要背大题。如果觉得背诵有压力，可以在肖四出来之前看看腿姐冲刺班，背诵的内容都差不多，但是会比肖四提前一周出，不过最后还是要回归到肖四的背诵上。
专业课-803信号与系统和数字逻辑电路
专业课140+也是今年感觉考研科目中比较满意的，这里先感谢一下博睿泽信息通信Jenny老师（非硕士，博士研究生，确实是老师，b站有很多她分享的专业课视频，大家可以先看看）的专业课110+课时辅导和老师全程答疑指导，让我专业课复习没有死角，哈工大803是专业课两门，复习内容较多，信号偏理论，数电偏应用，两门复习侧重不同，复习策略也很大不同，大家切记不要眉毛胡子一把抓，只做题，而忽视工科的基本思想。
Jenny老师课程是整合起来，从知识点引入，到推导证明，到物理意义的深入挖掘，在结合经典题目和考研真题，总结方法，实战做题，非常实用，属于边学边做，现学现用，要知道这本书内容很多，自己看非常费劲，结合jenny老师课程已经整理打包好了，从数学模型证明，到物理含义挖掘，到考研应用，整合在一起，非常方便复习和考研。课后习题，也可以直接先做老师每次课后的布置的题目，都是经典好题，结合题目，发现不足，再返回课程打磨。
总结一下哈工大两门专业课侧重：
信号与系统偏重于计算，在复习过程中，一定要多多练习计算。Jenny老师课程里面里面，每次课布置的测评精选题目和辅导课里面经典例题必须完全掌握，其次是历年真题上的所有题目来龙去脉分析计算必须有理有据，思路清晰，逻辑严密，计算不能出错，这些都搞定了还有余地，可以把老师突破课程里面的习题专项名校真题精选（基本都比哈工大历年难度要高不少）可以很好拓展视野和思路，应对变化，比如如果今年专业课突然难于往年，也不至于焦虑。
数字电路更偏重设计一点，数电更灵活，没有信号那么多的理论，公式推导计算等，更注重应用，所以自己复习起来没有什么头绪，直接跟Jenny老师数电课程就行了，除了最后时序电路设计题比较难以外，其他的组合逻辑分析设计、时序电路分析等难度不算很大，但是比较灵活。所以在复习中建议，及时跟着Jenny老师课程，也要多练习前面基础的部分，即使简单也不要掉以轻心，比如卡诺图、译码器、编码器、触发器、数据选择器、移位寄存器、计数器，这些的基本运用一定要会，至于时序设计这是拉开差距的好机会，Jenny老师课程里面的设计题都很好，给定器件设计，最优，最小设计等等，这些一般教材和其他辅导资料很少有，还有阻塞法等等，大开眼界。也为数电复习节省了很多时间。
总结这一年复习，有过焦虑，有过犹豫，但是最终都坚持下来了，考研也是长跑，大家注意自己的时间安排，持之以恒，但是一定要保持效率，争取每天有一点进步，自然可以化解焦虑情绪。希望我的经验对大家复习有些许帮助，每个人情况不同，别人的经验也不能完全照搬。最后预祝大家顺利被哈工大录取。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/685e3bc41065f07fabb1240c00aef429/" rel="bookmark">
			算法与数据结构--二叉搜索树与自平衡二叉搜索树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.字典（即c++的map） 注：字典的 "member运算" 指的是检查字典中是否存在某个特定的键的操作，即查询操作。
如果我们使用数组来实现字典/map，虽然使用二分法查询也可以达到logn，但是的话插入和删除太慢了。使用链表实现的话虽然插入和删除是O(1)，但是查询的话达到了O(n)，也不可取。
因此人们发明了自平衡二叉查找树，在保证查找效率的同时，又保证了插入和删除的效率，从而更好的实现字典。
c++的map和set就是用红黑树来实现的（一种特殊的自平衡二叉搜索树）。而unorder_map使用哈希表实现的。
1.二叉查找树--BST 在讲自平衡二叉搜索树之前，我们要先明白什么是二叉搜索树。
二叉查找树（Binary Search Tree），是具有如下性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。
二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。
复杂度：使用二叉搜索树进行添加，删除，搜索的平均时间复杂度都为O(logn)
特点：
2.自平衡二叉查找树--AVL树 1.为什么要有AVL树 二叉查找树虽然平均添加，删除，查找效率为O(logn)，但是却不稳定，比如像上面这张图，在最坏的情况下，也就是该二叉树不平衡的时候，效率又降到了O(n)。
所以我们要想办法让这颗二叉查找树平衡，让结点平均地分布在树的两侧，从而提高算法的稳定性，于是就发明了自平衡二叉搜索树，即AVL树。
2.AVL树的定义 3.如何构建AVL树 具体流程： 元素插入二叉搜索树中-&gt;判断结点是否平衡，具体是那种情况的不平衡-&gt;根据所处的不平衡情况进行不同的调整策略
当遇到结点不平衡时：
根据插入元素的落点，调整策略分为四种情况，插入元素落入以下4个子树的情况分别对应着四种状态。
【1】右旋--LL型状态 这时候对A结点，也就是根结点使用右旋操作进行调整。A连接左子树的右子树，A称为B的右子树。
【2】左旋--RR型状态 这时候对根结点使用左旋操作。
【3】先左旋后右旋--LR型状态 采用LR双旋。
这个操作等效与先对B结点作左旋操作，再对A结点作右旋操作。 【4】先右旋后左旋--RL型状态 采用RL双旋。
RL双旋等效于先对C右旋，再对A左旋。
具体代码 gpt生成，以后有时间再自己写一遍
#include &lt;iostream&gt; #include &lt;algorithm&gt; // AVL节点的定义 struct AVLNode { int data; AVLNode* left; AVLNode* right; int height; AVLNode(int value) : data(value), left(nullptr), right(nullptr), height(1) {} }; // 获取节点的高度 int getHeight(AVLNode* node) { if (node == nullptr) return 0; return node-&gt;height; } // 计算平衡因子 int getBalanceFactor(AVLNode* node) { if (node == nullptr) return 0; return getHeight(node-&gt;left) - getHeight(node-&gt;right); } // 更新节点的高度 void updateHeight(AVLNode* node) { if (node !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/685e3bc41065f07fabb1240c00aef429/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2533085c93c68595c22dc00b1e9e9ac/" rel="bookmark">
			flink升级1.18后 flink-table-planner中 org.apache.calcite.sql.SqlBasicCall 的 operands 方法不存在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SqlBasicCall.operands ​​​​​​​更新为: SqlBasicCall.getOperandList() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/316507ebde25f7fbe7987d3d42cec55e/" rel="bookmark">
			SD卡无法格式化怎么解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何修复无法格式化的SD卡？ 提供了4种SD卡无法格式化的解决方法，你可根据具体情况和需要选择合适的方法。
方法1. 更改驱动器号 有时，SD卡无法格式化是因为SD卡无法访问 。为了确保你的Windows操作系统能够识别并显示你的SD卡，检查一下你的SD卡是否有盘符。
1. 将硬盘连接到电脑后，按“Win + R”并在“运行”框中键入“diskmgmt.msc”。你可以按“确定”或按“Enter”打开磁盘管理实用程序。
2. 右键单击已连接的移动硬盘，然后选择“更改驱动器号和路径”选项。
3. 选择“添加”为该驱动器分配一个新的驱动器号。
4. 选择“分配以下驱动器号”选项。请确保你选择的新驱动器号与所有当前驱动器号不同。
方法2. 运行Diskpart格式化SD卡 如果你无法使用文件资源管理器格式化外部硬盘，diskpart是另一个可行的解决方案，因为它可以管理电脑的驱动器（磁盘、分区或卷）。无法格式化SD卡的用户也可以参考此解决方案。
1. 按“Win + R”并在“运行”框中键入“diskpart”，然后点击“回车”打开它。
2. 在窗口中逐条键入以下命令提示符，并在每行后按“回车”。
list diskselect x (x指的是你连接磁盘的磁盘编号。)clean(clean命令可以清除磁盘上的所有数据。)create partition primaryformat fs=ntfs quick (或者format fs=fat32 quick)exit 方法3. 通过磁盘管理格式化SD卡 如果你无法使用diskpart格式化SD卡，你可以向另一个方便的实用程序“磁盘管理”寻求帮助。
1. 在电脑上的搜索栏中输入“磁盘管理”并将其打开。
2. 右键单击无法识别的硬盘，然后选择“格式化”选项。
3. 选择适用于你当前 Windows 操作系统的文件系统。然后单击“确定”保存这些更改。
此外，这款功能完善的分区恢复软件- 傲梅分区助手还可以帮助你免费格式化和转换文件系统。
1. 在你的Windows电脑上运行傲梅分区助手，右键单击你的RAW磁盘并选择“格式化”选项。
2. 选择合适的文件系统，点击“确定”按钮。
3. 点击“提交”确认操作，无误后点击“执行”开始格式化磁盘。
方法4. 删除无法格式化SD卡写保护 如上所述，写保护是SD卡无法格式化的可能因素之一。写保护表示你的SD卡已设置为只读模式。
如需写入新数据或修改SD卡，需要参考以下步骤：解锁SD卡并取消写保护。
1. 将SD卡连接到电脑并确保它可以被识别。
2. 按键盘上的Windows + X ，然后从弹出菜单中选择“Windows PowerShell（管理员）”。
3. 然后，依次输入以下命令行。并在键入每个命令行后按“回车”以执行命令。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/316507ebde25f7fbe7987d3d42cec55e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5856d25a1ec650e5923d324f7a7329a4/" rel="bookmark">
			随机森林回归（Random Forest Regression）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是机器学习 随机森林回归（Random Forest Regression）是一种基于集成学习的回归算法，它通过整合多个决策树的预测结果来提高模型的性能和鲁棒性。随机森林是一种Bagging（Bootstrap Aggregating）方法，它通过对训练数据进行有放回的随机抽样（bootstrap抽样）构建多个决策树，并且在每个决策树的节点上使用随机特征子集来进行分裂。
以下是随机森林回归的主要特点和步骤：
数据准备： 与决策树回归类似，随机森林回归也需要准备包含特征和目标变量的训练数据集。随机抽样： 对训练数据进行有放回的随机抽样（bootstrap抽样）来创建多个训练数据的子集，用于每个决策树的训练。随机特征选择： 对于每个决策树的每个节点，随机选择一个特征子集，然后基于选定的特征进行分裂。这有助于降低各个决策树之间的相关性。树的构建： 对于每个子集，使用随机特征子集构建一个决策树。这可以是通过对数据递归划分来完成，直到达到停止条件，例如树的深度达到最大深度或节点包含的样本数小于某个阈值。预测： 对于新的输入数据，将其传递给每个决策树，得到多个预测结果。最终的预测结果是所有决策树预测结果的平均值。模型评估： 使用测试数据集对整个随机森林模型进行评估，可以使用回归性能指标，如均方误差（Mean Squared Error）等。 随机森林回归具有以下优点：
鲁棒性： 由于随机森林是通过多个决策树的集成，它对于噪声和过拟合的鲁棒性较强。高性能： 随机森林通常能够在不需要过多调整参数的情况下表现出色。特征重要性： 随机森林可以提供每个特征的重要性度量，这对于特征选择和解释模型非常有帮助。 在实践中，可以使用Scikit-Learn库中的RandomForestRegressor类来实现随机森林回归。以下是一个简单的代码示例：
from sklearn.ensemble import RandomForestRegressor from sklearn.model_selection import train_test_split from sklearn.metrics import mean_squared_error import numpy as np import matplotlib.pyplot as plt # 创建示例数据集 np.random.seed(42) X = np.sort(5 * np.random.rand(80, 1), axis=0) y = np.sin(X).ravel() + np.random.normal(0, 0.1, X.shape[0]) # 划分训练集和测试集 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # 创建随机森林回归模型 rf_regressor = RandomForestRegressor(n_estimators=100, random_state=42) # 在训练集上训练模型 rf_regressor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5856d25a1ec650e5923d324f7a7329a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b6a42538050ceded95a39b7bfb1a7c7/" rel="bookmark">
			JVM基础（6）——JVM垃圾回收器简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介：大家好，我是smart哥，前中兴通讯、美团架构师，现某互联网公司CTO
联系qq：184480602，加我进群，大家一起学习，一起进步，一起对抗互联网寒冬
学习必须往深处挖，挖的越深，基础越扎实！
阶段1、深入多线程
阶段2、深入多线程设计模式
阶段3、深入juc源码解析
阶段4、深入jdk其余源码解析
阶段5、深入jvm源码解析
一、简介 在新生代和老年代进行垃圾回收的时候，都需要使用回收器进行回收，不同的JVM 垃圾回收器会有所不同，不同区域一般也采用不同的垃圾回收器。JVM常见的垃圾回收器有以下几种，我们先来简要看下，后续会针对每一种GC专门详细讲解：
Serial/Serial Old Serial/Serial Old收集器是最基本也是最古老的垃圾收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程，也就是发生“Stop the World”。一般JVM都不再使用该收集器。
ParNew ParNew收集器是Serial收集器的多线程版本。新生代并行回收，采用复制算法，老年代串行回收，采用标记整理算法。所以，该收集器一般只用于新生代。
CMS CMS（Current Mark Sweep）收集器，目标是使回收停顿时间最短，也是多线程机制，采用标记整理算法，该回收器一般用于老年代，生产环境上也经常会使用该垃圾回收器与其它GC搭配使用。
G1 G1最大的特点是没有物理上的新生代和老年代，它们是逻辑的，G1将整个Java堆划分为多个大小相等的独立区域（Region），对新生代和老年代进行统一收集，并且采用了更加优秀的算法和设计机制。
二、Stop the World 2.1 何谓Stop the World 上一节，我们提到过JVM在进行垃圾回收时，会挂起除GC线程以外的所有其它线程，这就会导致系统出现卡顿，这就是JVM所谓的 Stop the World 机制。
假设当前JVM新生代的状态如下，Eden区已被填满，Survivor1区存放着上一次Minor GC后的存活对象，这时候即将触发Minor GC，由垃圾回收线程使用垃圾回收器（新生代一般使用ParNew，采用复制算法），使用特定的垃圾回收算法进行回收，如下图：
回收时，Eden区和Survivor1区的存活对象会被转移到Survivor2区，接着Eden和Survivor1中的垃圾对象都会被回收掉：
JVM在进行垃圾回收时，会让我们的系统暂停，不再创建新的对象，同时让GC线程尽快完成垃圾回收的工作——即标记和转移存活对象：
一旦本轮GC结束，就可以恢复我们的系统程序，继续在Eden区创建新的对象了，如下图：
三、总结 上面就是 Stop the World 的整体流程，Stop the World会导致客户端的请求出现卡顿，短则几百毫秒，长则几秒甚至几分钟。所以，无论是Minor GC还是Full GC，都要避免频率过高，这也是使用JVM过程中最需要关注和优化的地方。
从下一章开始，我们将详细讲解常见的三种垃圾回收器的工作原理，不同回收器 Stop the World 的流程也有所区别，GC的核心目标其实就是降低 Stop the World 的总体时间，这也是JVM不断演化的终极思路。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/919333e26b4dff29c2dc384f68897ce0/" rel="bookmark">
			单因素方差分析--R
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务说明 三个剂量水平的药物处理受试者，每个剂量水平十个受试者，现在收集到数据后，问：
药物剂量水平显著影响受试者的response？
或者不同剂量药物处理受试者有显著效果的差异吗？
数据 library(tidyverse) library(reshape2) # install.packages("gplots") library(gplots) df &lt;- read.table("AUClast1.csv",header = T,sep=",") head(df) dose &lt;- c(0.2,0.6,1.8) fqr &lt;- as.data.frame(t(df[1:3,2:11])) rownames(fqr) &lt;- 1:nrow(fqr) colnames(fqr) &lt;- dose fqr &lt;- melt(fqr) fqr$variable &lt;- as.factor(fqr$variable) head(fqr) # variable value #1 0.2 24.9 #2 0.2 19.7 #3 0.2 27.3 #4 0.2 26.8 #5 0.2 30.8 #6 0.2 30.2 table(fqr$variable) # 0.2 0.6 1.8 # 10 10 10 代码 # anove单因素方差分析 fit &lt;- aov(value ~ variable,fqr) summary(fit) # Df Sum Sq Mean Sq F value Pr(&gt;F) # variable 2 593525 296762 45.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/919333e26b4dff29c2dc384f68897ce0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ff7e46f5948f0d3627ab02f69a05027/" rel="bookmark">
			网络安全等级保护测评方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网络安全等级保护测评主要涉及以下几个方面：
物理安全：包括物理位置的选择、物理访问控制和防盗、防火、防水、防雷、温湿度控制、电力供应、防静电和电磁防护等。网络安全：包括结构安全、安全审计、访问控制、边界完整性检查、恶意代码防范、入侵防范和网络设备防护等。主机安全：包括身份鉴别、访问控制、安全审计、入侵防范、恶意代码防范和资源控制等。应用安全：包括身份鉴别、访问控制、安全审计、通信完整性、通信保密性、抗抵赖、软件容错和资源控制等。数据安全：包括数据完整性和保密性、数据的备份和恢复。管理制度：包括安全管理制度、安全管理机构、人员安全管理、系统建设管理、系统运维管理等。
软件全文档文件获取：软件项目开发全套文档下载_软件项目技术实现文档-CSDN博客 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cd89a429850b4f984286f1f83a9716e/" rel="bookmark">
			基于分词的朴素贝叶斯分类器的构造和应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
1 绪 论 1
1.1研究背景与意义 1
1.2中文分词现状 1
1.3 论文主要内容 2
2相关技术分析 3
2.1常见的分词算法 3
2.1.1基于词库的分词算法 3
2.1.2基于理解的分词算法 4
2.1.3基于统计的分词算法 5
2.2中文分词的技术难点 6
2.2.1歧义处理 6
2.2.2新词识别 6
3分词词库 8
3.1词库组成 8
3.2 词库的构建 8
3.3 词库的更新 9
4 改进的贝叶斯定理分词算法 12
4.1 算法概述 12
4.2 歧义处理 13
4.3 算法步骤 14
5 算法实现 18
5.1 开发环境 18
5.2 实验数据 18
5.3 实验方法过程 18
5.4 实验结果展示 19
5.5结果分析 22
结 论 23
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cd89a429850b4f984286f1f83a9716e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b39ae048af8bb26d2ba6bfce9c50e7/" rel="bookmark">
			决策树回归（Decision Tree Regression）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是机器学习 **决策树回归（Decision Tree Regression）**是一种机器学习算法，用于解决回归问题。与分类问题不同，回归问题的目标是预测连续型变量的值，而不是离散的类别。决策树回归通过构建一棵决策树来进行预测。
以下是决策树回归的基本步骤：
数据准备： 收集并准备回归问题的数据集。数据集应包含特征（自变量）和目标变量（因变量），其中目标变量是连续型的。特征选择： 选择用于构建决策树的特征。决策树的每个节点都基于一个特征来进行分裂。树的构建： 使用训练数据集构建决策树。在每个节点上，选择一个特征，并根据该特征的某个阈值将数据集划分为两个子集。这个过程递归地进行，直到达到停止条件，例如树的深度达到预定的最大深度或节点包含的样本数小于某个阈值。节点的值： 在每个叶子节点上，用目标变量的平均值（或其他适当的统计量）作为节点的值。这个值将用于对新数据进行预测。预测： 对于新的输入数据，通过决策树进行遍历，最终到达一个叶子节点，并将该节点的值作为预测结果。模型评估： 使用测试数据集对模型进行评估，可以使用各种回归性能指标，如均方误差（Mean Squared Error）等。 决策树回归具有一些优点，如易于理解和解释，对于数据中的非线性关系具有很好的拟合能力。然而，它也容易过拟合训练数据，特别是在树的深度较大时。为了缓解过拟合，可以使用剪枝技术或者集成学习方法，如随机森林。
在实际应用中，可以使用机器学习库中的决策树回归实现，例如Scikit-Learn（Python中的一个常用机器学习库）提供了DecisionTreeRegressor类来实现决策树回归。
以下是使用Python中Scikit-Learn库进行决策树回归的简单代码示例：
# 导入必要的库 from sklearn.tree import DecisionTreeRegressor from sklearn.model_selection import train_test_split from sklearn.metrics import mean_squared_error import numpy as np import matplotlib.pyplot as plt # 创建一个示例数据集 np.random.seed(42) X = np.sort(5 * np.random.rand(80, 1), axis=0) y = np.sin(X).ravel() + np.random.normal(0, 0.1, X.shape[0]) # 将数据集划分为训练集和测试集 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # 创建决策树回归模型 tree_regressor = DecisionTreeRegressor(max_depth=5) # 在训练集上训练模型 tree_regressor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1b39ae048af8bb26d2ba6bfce9c50e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da5666e801e4ade34c8abe30ee6a8e91/" rel="bookmark">
			基于维基百科的语义朴素贝叶斯学习实现文本的完美分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
译文及原稿 34
基于维基百科的语义朴素贝叶斯学习实现文本的完美分类 1
1.介绍 1
2.相关工作 2
2.1语义朴素贝叶斯分类 2
2.2文本分类的文档表示 3
3. 朴素贝叶斯学习框架 3
4.改进朴素贝叶斯分类 4
4.1文档表示的语义张量空间模型 4
4.2文本分类的语义朴素贝叶斯学习 4
5. 绩效评估 5
5.1经验设置 5
5.2文本分类评价 6
6.总结 6
5. 绩效评估
在这一节中，我们经验地讨论了该方法的有效性。提出了文本分类的语义朴素贝叶斯学习方法。
5.1经验设置
为了评估我们提出的方法，我们使用了20个新闻组、Reuters-21578和OHSUMED文档语料库的受控子集，它们已经被接受为干净的语料库，因此通常用于评估用于文本分类的各种机器学习算法。20Newsgroups语料库有大约20000个文档，这些文档被划分为20个不同的新闻组。在本实验中，我们选取了10000个排名最高的文献。其次，我们生成了Reuters-21578语料库的一个子集，其中文档不偏离类（或主题）。我们首先选择文档属于具有单个主题的最大文档，以避免具有多个主题的文档的模糊性。最后，OHSUMED语料库来自名为MEDLINE的在线医学信息数据库。其中包含270种医学的标题和摘要期刊。
由于该语料库的分类效果不佳，因此在许多研究中，如何对语料库进行合理的分类是非常具有挑战性的。对于这个语料库，我们选择了最频繁的9个班的3600个文件。
在分类度量方面，针对宏(微)平均F1-分数讨论了分类结果，F1-分数是分类结果的精确度和召回度的调和平均。宏平均的F1-分数计算为每个类的相同权重，并且微平均的FI-分数计算为与每个类中的文档数量成比例。这些度量值从0到1不等，并且与分类有效性成比例。对于所有准备的文档语料库，使用10倍的交叉验证计算最终的Fl分数。
语义张量的实现有三个问题：术语空间、概念空间和张量存储。
术语“空间”是通过特征（即，术语）选择方法产生的，为此，我们使用基于文档频率（DF）的方法。在删除很少或没有信息值的停用词之后，我们选择了30%个排名最靠前的术语来支持具有较高DF值的单词。
概念空间通过一个合适的搜索引擎（如Lucene（http://Lucene，ApaCeOrg/））自动地依赖于给定的文档语料库，特别是所有有超过100个传入链接的信息性的维基百科页面首先由搜索引擎索引。接着，我们计算语料库中每个文档中出现的单词的TF IDF值，并将一组高度加权的单词视为查询相关维基百科页面的查询。对于每个文档，其相应的查询被提交给搜索引擎，并且搜索结果成为构建概念空间的候选者。最后，为了构造最优的概念空间，只选择给定语料库最常检索的维基百科页面。在下一节中，我们将描述根据概念空间的大小（最多75个）的性能变化。
我们的张量空间模型可能非常稀疏，因为只有一个小的文档的术语和语义的分数。在存储稀疏第二（或第三）张量，相当大的内存需求是通过仅存储具有坐标列表格式的非零条目，极大地减轻了负担。
在本实验中，我们将所提出的方法与传统的Naeve Bayes[1]。jing’s Naive Bayes[8]、SVM[4]以及三种基于深度学习的分类方法（如全连通深层神经网络（DNN））进行了比较。美国有线电视新闻网和RNN）。在实现这三种深度学习方法中，put层中的节点数等于每个语料库中生成的术语数，out层中的节点数等于要分类的类别数。此外，我们使用ReLU作为激活函数，使用SoftMax函数返回测试文档属于每个类别的概率。具体地说，DNN为我们的实验实现包含7个隐藏层。CNN使用16个滤波器，大小为2×2，并连接到具有256个输入的全连接网络。最后，根据文献[22]提出的模型I实现了RNN。
5.2文本分类评价
表1显示我们使用等式(15)的语义朴素贝叶斯学习为所有文档语料库提供了优越的分类结果。注意，如果对20Newsgroups和Reuters-21578语料库中的文档进行分类，我们的方法会产生几乎完美的分类结果。此外，在测试OHSUMED数据时，我们的方法在F1分数方面显示大于90％，而现有的方法显示出较差的结果。总的来说，京氏朴素贝叶斯、RNN和SVM与提出的方法性能接近，京氏朴素贝叶斯略优于RNN。实证结果表明，语义维基百科信息的有效使用有助于提高分类性能。
对于拉普拉斯平滑，方程（15）和方程（15）的表现形式几乎没有差别。（16）和（17）。此外，如表1所示，概念窗口Cw的大小对分类性能没有显著影响。相比之下，发现概念空间的大小会影响分类性能。图2显示了作为概念空间大小的函数的宏F1-score的图。性能随着概念空间的稍大一点而增加，尤其是在ohSuMed数据的情况下。在概念空间包含测试集中的固有概念(例如，大小大于25)之后，F1-分数保持几乎恒定，并且优于其他方法的性能。
6.总结
本文提出了一种利用语义张量空间模型进行文档表示的语义朴素贝叶斯分类方法。为了克服词袋模型中的语义缺失问题，我们的语义朴素贝叶斯学习方法引入了额外的语义特征，这些语义特征对应于文档中每个术语的含义；语义特征由外部的维基百科页面组成，这些页面知道给定的文件等。因此，在我们的分类学习框架中，将传统的特征统计分解为术语和概念的统计，并适当地估计它们之间的相关性。通过大量的实验，我们证明了本文提出的方法对20NewsGroup和Reuters-21578语料库中的文档进行分类时，能够进行几乎完美的分类。UGH稀疏张量以坐标列表格式存储。另一个未来的工作是将语义张量模型引入到基于深度学习的分类方法中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b94ca87f4ba675e02bdc18c49e9f0f2b/" rel="bookmark">
			liosam 速腾激光雷达数据适配，timestamp位数不够
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先是时间，点云的时间是绝对时间，所以不能用加法
修改过后，scan start和end差距过大，六十多秒。
这里的timestamp要double转float，这里有个古老知识要复习，float是32位，有23位是数字，为什么只有8位一样？
首先，float 是 32位, 其中有23位用于存放尾数, 带有一个固定隐含位… 所以float的有24个二进制有效位位数.
其次，2^24共有8个十进制位. 所以有些编译器 float的有效数字位是 8位 , 有些有效数字位是 7位.(注意不是小数的位数, 是有效数字位)
而double有15～16位有效数字。
所以，timestamp用float是装不下的，所以需要把lio-sam的数据结构改double，从需求看，整数秒有10位，多出5位比毫秒还低，足够用了。
然后直接改VelodynePointXYZIRT的time数据类型为double就好了
不一定要修改这个，只是因为using PointXYZIRT = VelodynePointXYZIRT;
自己定义一个
最后就是回到问题原点，这里不要再加float转换了，不然白改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88cdfc7246dc637456a5907c976e960a/" rel="bookmark">
			JVM基础（4）——JVM存活判定算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介：大家好，我是smart哥，前中兴通讯、美团架构师，现某互联网公司CTO
联系qq：184480602，加我进群，大家一起学习，一起进步，一起对抗互联网寒冬
学习必须往深处挖，挖的越深，基础越扎实！
阶段1、深入多线程
阶段2、深入多线程设计模式
阶段3、深入juc源码解析
阶段4、深入jdk其余源码解析
阶段5、深入jvm源码解析
一、简介 我们在 JVM垃圾回收机制一章中，简单介绍了JVM的垃圾回收机制，先来回顾下，系统运行时创建的对象优先在Java堆内存区域分配：
然后新生代里的对象越来越多，当快满了的时候就会触发“Minor GC”，把新生代中的一些对象回收掉：
那么这里就涉及一个问题： JVM如何知道要去回收哪些对象？ 这其实就是JVM的对象存活判定机制，主要涉及两种算： 可行性分析算法 和 引用计数算法 。
引用计数算法，是给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器值就减1，任何时刻计数器为0的对象就是可以被回收的。
由于Java语言没有选用引用计数法来管理JVM内存，所以本文不赘述，而且引用计数法不能很好的解决循环引用的问题（Python采用的是引用计数法）。
二、可达性分析算法 可达性分析算法（GC Root Tracing ），其基本思路就是通过一系列的名为" GC Roots "的对象作为起始点，从这些起始点开始搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时（即从 GC Roots 到这个对象不可达），则证明此对象是不可用的，就可以被回收。
GC Roots包括：
Java虚拟机栈中的局部变量（指向着GC堆里的对象）；VM的一些静态数据结构里指向GC堆里的对象的引用，例如HotSpot VM里的Universe里有很多这样的引用；所有当前被加载的Java类（看情况）；Java类的运行时常量池里的引用类型常量；String常量池（StringTable）里的引用。 可达性分析算法最难理解的就是该选取哪些对象作为GC Roots，我们通过两个示例来看下。
2.1 示例一 下面是最常见的一种情况：
public class Kafka { public static void main(String[] args) { loadReplicasFromDisk(); } public static void loadReplicasFromDisk(){ ReplicaManager replicaManager = new ReplicaManager(); } } 当执行到loadReplicasFromDisk()时，对应的JVM内存数据结构如下图：
假如此时新生代的内存已经快满了，发生了“Minor GC”，那么JVM会分析ReplicaManager对象的可达性，发现它被“replicaManager”这个局部变量引用着，在JVM规范中， 局部变量是可以作为GC Roots的 ，所以就不会被回收。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88cdfc7246dc637456a5907c976e960a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ede43329a4d6d78a6469b6e3ce315ae/" rel="bookmark">
			基于ARIMA模型的我国山西省能源消费结构趋势的分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
1 绪 论 1
1.1 研究的背景和意义 1
1.2 国内外研究现状 2
1.3 研究的主要内容及方法 3
1.3.1 基本框架 3
1.3.2 研究的重点和难点 4
1.3.3 研究的方法及措施 4
1.4 预期成果 4
2 ARIMA模型方法介绍 5
2.1 ARIMA模型的基本介绍 5
2.1.1 AR模型 5
2.1.2 MA模型 5
2.2 ARIMA模型预测的基本程序 6
2.3关于ARIMA模型 6
2.3.1 模型概念简介 6
2.3.2 ARIMA模型的优缺点 8
3 ARIMA模型的建立 9
3.1 ARIMA模型原理 9
3.2 数据来源 9
3.3 数据分析 10
3.3.1 历年山西省能源消费情况 10
3.3.2 平稳性检验 10
4 模型实验 12
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ede43329a4d6d78a6469b6e3ce315ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3c98fcbd3a6766e25f65abe4c3fea90/" rel="bookmark">
			Spring Security介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Spring Security：
1、简介：Spring Security 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。
（1）用户认证：指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。
Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。
（2）用户授权：指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。
Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。
2、结构：通过继承
org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter 实现权限配置，登录验证成功后初始化org.springframework.security.core.userdetails.UserDetails，存储当前登录用户。默认（可缺省）登录接口：/login
二、 spring security 依赖：
1、pom依赖：
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.14.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3c98fcbd3a6766e25f65abe4c3fea90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd84f2f5ee3e3805044915bd5bf5990a/" rel="bookmark">
			【C&#43;&#43;】STL 算法 ⑩ ( 函数适配器 | 函数适配器概念 | 函数适配器分类 | 函数适配器辅助函数 | std::bind2nd 函数原型及示例 | std::bind 函数原型及示例 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、函数适配器简介1、函数适配器概念2、函数适配器分类3、函数适配器辅助函数 二、函数适配器使用示例 - std::bind2nd 函数1、std::bind2nd 函数原型2、代码示例 - std::bind2nd 函数 三、函数适配器使用示例 - std::bind 函数1、std::bind 函数原型2、代码示例 - std::bind 函数 一、函数适配器简介 1、函数适配器概念 在 STL 中 预定义了很多 函数对象 , 如果要 对 函数对象 的 参数 / 返回值 进行 计算 或 设置 , 可以 使用 " 函数适配器 " 实现上述需求 ;
" 函数适配器 " 可以 将 已存在的 函数对象 转化为 另一种符合要求的 函数对象 ;
" 函数适配器 " 定义在 &lt;functional&gt; 头文件 中 ;
2、函数适配器分类 " 函数适配器 " 常用类型的两类 :
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd84f2f5ee3e3805044915bd5bf5990a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d101e466cfef19df34b6ae538e59452/" rel="bookmark">
			大数据时空分析的新方法:在首尔地铁交通数据中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
译文及原稿 34
大数据时空分析的新方法:在首尔地铁交通数据中的应用 1
1首尔国立大学地球与环境科学学院 1
关键词：CSEOF分析；时空分析；大数据分析 1
引言 1
数据 2
方法 3
讨论 3
地铁一周2号线。图3从上到下显示了登机的CSLVS 3
结论 9
参考文献 10
方法
在本研究中，我们特别感兴趣的是识别地铁乘客数据的时空特征函数，即地铁乘客随地铁站和一周时间变化的不同模式。由于地铁乘客数据的统计特性(均值和协方差)几乎是周期性的，具有明显的周周期，我们假设这些数据属于循环平稳随机变量的范畴。因此，一种称为循环平稳经验正交函数( CSEOF )分析的时空分析技术被用来识别地铁乘客数据的特征函数。
讨论
首尔是一个拥有1000万人口和1.7万人口密度的大都市。此外，许多人从首尔郊区通勤到首尔。地铁线路2，也称为绿线，是9大城市中最繁忙的线路之一。
首尔地铁线路和4条特殊地铁线路（见图2）。每日总次数2号线旅客超过200万人次，占地铁旅客总数的31%。在汉城，图2显示了地铁2号线及其50个车站和所有连接地铁。Tere是乘客数据中一个重要的每周周期。在工作日，大首尔使用地铁上下班的人数。在周末，乘客人数明显减少。基于公共模式，我们设置嵌套本研究周为1周（168小时）。图3显示了50个车站每小时乘客的frst cseof模式
地铁一周2号线。图3从上到下显示了登机的CSLVS
乘客（图_3a）、下车乘客（图_3b）、所有车站增加的乘客（图3c）和相应的PC时间序列（图3d）。TIS模式解释了总的变异性。上下客总量分别呈现出两个明显的高峰与工作日的通勤时间相对应（图3c）；上午高峰在上午7-8点左右，晚高峰6-7点左右，早高峰更大对于下车的乘客，而对于登机的乘客，晚高峰更大。早上7点到点车站附近有大量乘客上地铁。230（Shilim）。下午6点左右，附近也有大量的登机乘客
222号站（Kangnam）。早上（早上7点到8点），222号站附近有大量下车的乘客。然而，在晚上，降落模式没有显示任何明显拥挤的车站。大批量生产并不奇怪因为其他地铁线路，早上在230站附近登机的乘客，除2外，不方便进入，因为有一个很大的社区这个地区人口密度很高。219–222号站位于业务范围内。市中心有许多公司。注意邦当线（如图2所示为B）新的邦当线（图_2中的NB）在220号站与地铁2号线相连。分别是222号站和222号站。从外滩线下车的乘客经常使用出口站220和222。图四，在这些车站在早上。周末，乘客人数减少，早晚高峰不见。期间每日乘客总数为300-320万。工作日，周六减少至240万（78%）和170万（54%），以及
分别是星期日（表1）。图4显示了下车和登机乘客之间的数量差异。很明显，这种差异在早晨比在傍晚。当平均24小时以上时，在221-223站上下客人数的不平衡最为明显；下客人数超过平日旅客登机人数（另见表1）。原因分析这种不平衡不明显。一个合理的解释是，当通勤时间分布更广时，不同的交通方式在晚上很容易得到比早
上好。
相应的PC时间序列表明，地铁2号线的乘客数量没有明显的趋势（图3d）。周周期的te振幅约为~ 1.0的平均值，标准差为0.094。TE直方图高度倾斜，长尾巴朝向低端（图5）。特瑞有几次每年乘客数量的显著减少。减少日期见表2。农历新年，在农历的早期，和楚seok或9月或10月的中秋节是韩国的两个主要节日。泰伊每次持续3-4天，大都会地区的人，尤其是在首尔探访他们住在农村的家庭。特雷是一个普遍的数字下降新年前后的乘客数量。图6显示了每周PC时间序列的月平均振幅。在记录期间内循环。月平均振幅一般变化较小。10%以上，2010年9月除外。月平均乘客数3月达到高峰，11月达到较小程度。平均而言，九月份乘客人数下降最为显著，八月份和二月份的下降幅度较小。9月份的乘客减少明显与Chuseok有关。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b3f911f430a5eb6a5680553c88c3d0e/" rel="bookmark">
			STM32使用1.69寸液晶显示模块使用缓冲区实现快速刷新全屏显示字符串功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个1.69寸SPI接口的液晶显示模块，有320*240=76800个点，每个点有2个字节表示RGB的颜色，所以需要153.6K个字节的数据来刷新全屏，如果SPI口输出数据不是高速并且不紧密排列的话，刷新就会比较慢，有从下到下的肉眼可见的刷新过程，现就是希望使用数据缓冲区（我理解这就是显存的概念吧）来快速刷新显示区域。
原始的单个字符的显示程序：
/****************************************************************************** 函数说明：显示单个字符 入口数据：x,y显示坐标 num 要显示的字符 fc 字的颜色 bc 字的背景色 sizey 字号 mode: 0非叠加模式 1叠加模式 返回值： 无 ******************************************************************************/ void LCD_ShowChar(uint16_t x,uint16_t y,uint8_t num,uint16_t fc,uint16_t bc,uint8_t sizey,uint8_t mode) { uint8_t temp,sizex,t,m=0; uint16_t i,TypefaceNum;//一个字符所占字节大小 uint16_t x0=x; sizex=sizey/2; TypefaceNum=(sizex/8+((sizex%8)?1:0))*sizey; num=num-' '; //得到偏移后的值 LCD_Address_Set(x,y,x+sizex-1,y+sizey-1); //设置光标位置 for(i=0;i&lt;TypefaceNum;i++) { if(sizey==12)temp=ascii_1206[num][i];	//调用6x12字体 else if(sizey==16)temp=ascii_1608[num][i];	//调用8x16字体 else if(sizey==24)temp=ascii_2412[num][i];	//调用12x24字体 else if(sizey==32)temp=ascii_3216[num][i];	//调用16x32字体 else return; for(t=0;t&lt;8;t++) { if(!mode)//非叠加模式 { if(temp&amp;(0x01&lt;&lt;t))LCD_WR_DATA(fc);	//每一个点发送2个字节数据 else LCD_WR_DATA(bc); m++; if(m%sizex==0) { m=0; break; } } else//叠加模式 { if(temp&amp;(0x01&lt;&lt;t))LCD_DrawPoint(x,y,fc);//画一个点 x++; if((x-x0)==sizex) { x=x0; y++; break; } } } } } 由if(temp&amp;(0x01&lt;&lt;t))LCD_WR_DATA(fc); //每一个点发送2个字节数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b3f911f430a5eb6a5680553c88c3d0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b5e3da2e730d50a7114b547245be152/" rel="bookmark">
			Spring Security组件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1728f5f837252d071f02fdd220c4795d/" rel="bookmark">
			Android Studio 禁用插件（Plugin）后无法启动（Mac电脑）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 昨天为了解决某个问题，禁用了Kotlin（Plugins），结果android无法启动了
启动界面如图所示：
Internal error. Please refer to https://code.google.com/p/android/issues com.intellij.ide.plugins.PluginManagerCore$EssentialPluginMissingException: Missing essential plugins: com.android.tools.design, org.jetbrains.android at com.intellij.ide.plugins.PluginManagerCore.checkEssentialPluginsAreAvailable(PluginManagerCore.java:750) at com.intellij.ide.plugins.PluginManagerCore.initializePlugins(PluginManagerCore.java:843) at com.intellij.ide.plugins.PluginManagerCore.initializeAndSetPlugins(PluginManagerCore.java:1047) at com.intellij.ide.plugins.PluginDescriptorLoader$scheduleLoading$pluginSetDeferred$1.invokeSuspend(PluginDescriptorLoader.kt:397) at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33) at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:106) at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:570) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:750) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:677) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:664) 解决办法： 以Mac为例，我们需要去他的配置文件夹下，删除掉我们刚刚禁用的插件；
1.打开FInder（访达）
2.点击左上角【前往】，然后按住option键，点击【资源库】进入：/Application Support/Google/AndroidStudio2022.3/disabled_plugins.txt
3.双击打开后删除刚刚禁用的插件，保存后退出即可。
其实该文件的全部路径是：/Users/用户名/Library/Application Support/Google/AndroidStudio2022.3/disabled_plugins.txt
但是Library文件夹默认是隐藏的，需要在前往中按住option键才能看到
android studio顺利打开！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeac83d94b7f044c01687398c0ea04dd/" rel="bookmark">
			css-文本垂直居中， 左侧border与文字作为导航标题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.文本垂直居中 1.1 Flexbox 布局 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;style&gt; .container { display: flex; align-items: center; /* 使用 align-items 属性垂直居中 */ height: 200px; /* 设置容器高度 */ border: 1px solid #ccc; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;p&gt;垂直居中文本&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 1.2Grid 布局： &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;style&gt; .container { display: grid; place-items: center; /* 使用 place-items 属性垂直水平居中 */ height: 200px; /* 设置容器高度 */ border: 1px solid #ccc; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeac83d94b7f044c01687398c0ea04dd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/3/">«</a>
	<span class="pagination__item pagination__item--current">4/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/5/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>