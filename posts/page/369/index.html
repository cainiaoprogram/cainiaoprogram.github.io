<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fe49fb0c58db706c0182457f4cdcf3f/" rel="bookmark">
			vs code中项目的基本配置--include路径、运行参数、debug配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装C/C++ for Visual Studio Code 点击左边扩展栏图标—&gt;搜索C/C++ -&gt; 安装-&gt;Reload：
安装完成之后，打开你的包含c++的文件夹，将会生成一个.vscode文件夹，所有的配置将在这个文件夹中进行配置。
2.配置IntelliSense 扩展程序会根据当前系统环境配置基本信息，因此有可能配置不完整，这时需要通过生成c_cpp_properties.json文件来配置缺少的信息：
ctrl+shift+P打开Command Palette,运行C/Cpp: Edit configurations...生成c_cpp_properties.json：
{ "configurations": [ { "name": "Linux", "includePath": [ "${workspaceFolder}/**" ], "defines": [], "compilerPath": "/usr/bin/gcc", //编译器路径 "cStandard": "c11", "cppStandard": "c++17", "intelliSenseMode": "clang-x64" } ], "version": 4 } 这是Ubuntu平台上默认生成的c_cpp_properties.json文件，可在这个文件中添加配置。
对于Windows环境下，需要自己下载编译器安装并配置，比如我下载了MinGW64，然后需要配置环境变量：
变量名：MINGW 变量值：D:\worksoftware\mingw-w64\i686-8.1.0-posix-dwarf-rt_v6-rev0\mingw32\bin 引入到Path环境变量中： %MINGW% 然后重启VS code，并在c_cpp_properties.json文件中添加:
"compilerPath": "D:\\worksoftware\\mingw-w64\\i686-8.1.0-posix-dwarf-rt_v6-rev0\\mingw32\\bin\\g++.exe" 1 3.构建应用程序 如果要构建应用程序，则需要生成tasks.json文件：
Ctrl+Shift+P -&gt; Tasks: Configure Tasks… -&gt; Create tasks.json file from templates -&gt; Others.
{ // See https://go.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fe49fb0c58db706c0182457f4cdcf3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a68310ecf4d68c3b7b4000f8f0d1aa1/" rel="bookmark">
			模型验证方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习模型的验证方法笔记概要
模型本身及其背后学习方法的泛化性能（generalization performance），也就是模型对未知数据的预测能力，是机器学习的核心问题。可在一个问题的学习中，往往会出现不同的模型在训练集上具有类似的性能，这时就需要利用模型验证来从这些备选中做出选择。简单来说模型验证的任务就是确定模型的复杂度以避免过拟合的发生。原则上说，模型验证应该使用专门的验证数据集。可是当数据集的容量较小，不足以划分成三个部分时，验证集和测试集就可以合二为一，共同来完成对模型的选择和评价。
估计泛化性能时，最重要的依据就是模型在训练数据集上的精度（accuracy）。定性而论，模型在训练集上的精度不能太低。如果在训练集上都达不到较高的精度的话，模型本身的假设就很可能存在问题（比如用线性模型来建模平方关系的数据），从而导致较大的偏差，这样的模型很难指望它在真实数据上具有良好的表现。
因此我们分析的出发点是误差的分解理论：误差包括噪声、偏差和方差三部分。当模型的训练过程结束后，在训练集上就可以计算出模型 f^ 的训练误差，在测试集上则可以计算出模型的泛化误差。由于训练数据是已知的，验证数据是未知的，两者之间并不存在交集，所以泛化误差也被称为样本外误差（extra-sample error）。训练集的数据中既包含由潜在的概率分布所决定的确定部分，也包含受噪声干扰产生的随机部分。在训练过程中，模型 f^ 将不可避免地把噪声的一部分随机特性也纳入建模的范畴。如果考虑噪声的影响，那么即使当训练数据的自变量不变，它的因变量也会受发生变化。从这个角度来理解，训练数据集就是一个样本，它对应的总体是自变量固定时因变量所有可能的取值。利用样本训练出的模型 f^ 在样本上的表现和在总体上的表现之间的差值，就是所谓的样本内误差。
模型在验证集上的性能是模型选择和评估的依据。无论使用什么样的重采样策略，验证集都需要满足一个基本要求，就是不能和训练集有交集。模型本身就是在训练集上拟合出来的，如果再用相同的数据去验证的话，这种既当运动员又当裁判员的做法就缺乏说服力了。所以在划分时，最基本的原则就是确保训练集、验证集和测试集三者两两互不相交。除了互不相交之外，另一个需要注意的问题是训练 / 验证 / 测试中样例分布的一致性，也就是三个集合中正例和负例的比例应该大致一致，避免在数据集之间出现不平衡。如果训练集和验证集中的样例分布相差较大，这种分布差异将不可避免地给性能的估计带来偏差，从而模型选择造成影响。
模型验证的几个基本方法 想要充分利用有限的数据，必须在训练集和验证集的划分方式，或者说验证数据的抽取方式上做些门道。最简单直接的方法就是随机采样出一部分数据作为训练集，再采样出另一部分作为验证集，这种方法就是留出法（hold-out）。
k 折交叉验证法将原始数据集随机划分为 k 个相同大小的子集，并进行 k 轮验证。每一轮验证都选择一个子集作为验证集，而将剩余的 k−1 个子样本用作训练集。由于每一轮中选择的验证集都互不相同，每一轮验证得到的结果也是不同的，k 个结果的均值就是对泛化性能的最终估计值。
k 折交叉验证一个特例是 k 等于原始数据集的容量 N，此时每一轮中只有一个样本被用做测试，不同轮次中的训练集则几乎完全一致。这个特例被称为留一法（leave-one-out）。
除了 k 折交叉验证之外，另一种模型验证的方法是自助采样（bootstrap）。在学习概率论时你肯定计算过这样的问题：一个袋子里有红球若干白球若干，从中抽出一个球查看颜色后放回或不放回，再次抽出一个红球 / 白球的概率是多少。前面提到的 k 折交叉验证执行的就是典型的不放回的重采样，在同一轮验证中某个样本要么出现在训练集，要么出现在验证集，两者必居其一。
相比之下，自助采样执行的则是有放回的重采样。如果使用自助采样生成训练集的话，需要每次随机从原始数据集中随机抽取一个样本并拷贝到训练集中，将这个样本放回到原始数据集，再重复以上的步骤。这种放回重采样的方式会导致某些数据可能在同一轮验证中多次出现在训练集内，而另一些数据可能从头到尾都没有参与到模型的训练当中。在每一轮次的自助采样中，没有被采到的样本会作为测试数据使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47b8a1fa84d7888f3a9a65ad14750c38/" rel="bookmark">
			广义积分中值定理的证明（柯西中值定理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 积分中值定理的证明：戳这里 看下下面这道题：
这个其实是，广义积分中值定理，我们在做选择题的时候，可以直接使用
下面看一下如何证明： 证明过程中用到的定理： 拓展一下 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed01d8745df723c2ec8fa10356702ea9/" rel="bookmark">
			PowerMock 静态方法模拟问题排查，结果是函数参数问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题：静态方法User.convert(）的模拟，未匹配到预期值。1. 检查静态方法的模拟过程2. 直接拦截静态方法3. 初步定义为参数问题：函数式参数4. 只匹配类型，算解决问题吗(ಥ_ಥ) 问题：静态方法User.convert(）的模拟，未匹配到预期值。 1. 检查静态方法的模拟过程 Mocking Static Method： // 1.类注解：@PrepareForTest(Static.class) //Static.class 是包含 static methods的类 方法内： // 2.模拟静态类（使用PowerMockito.spy（class）模拟特定方法） PowerMockito.mockStatic(Static.class); // 3.拦截：设置期望值 Mockito.when(Static.firstStaticMethod(param)).thenReturn(value); 检查过程没问题。 直接拦截静态方法试试
2. 直接拦截静态方法 验证通过，模拟静态方法没问题。
3. 初步定义为参数问题：函数式参数 // 拦截的方法 &lt;E, R&gt; List&lt;R&gt; queryForList(Object var1, Class&lt;E&gt; var2, Function&lt;E, R&gt; var3); Function类型的参数精确配置不应该 User::convert 这样传。那该怎么传呢？我在官网和百度扒资料，然而不知道是没有，还是没找对。反正，没找到该怎么解决。
没办法，只好先模糊匹配下了
4. 只匹配类型，算解决问题吗(ಥ_ಥ) 花了时间不一定有收获，不花时间也许也有收获呢。
知道函数式参数怎么传的大神，留个言呗
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/110442efe98a33f7c4873994bc4ad53b/" rel="bookmark">
			linux下如何测试端口通不通(四种方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般情况下使用"telnet ip port"判断端口通不通.接下来通过本文给大家分享四种方法测试端口通不通，感兴趣的朋友一起学习吧
一般情况下使用"telnet ip port"判断端口通不通，其实测试方法不止这一种，还有很多种方法，下面小编给大家分享了几种方法，具体内容请往下看：
准备环境
启动一个web服务器，提供端口.
[wyq@localhost ~]$ python -m SimpleHTTPServer 8080 Serving HTTP on 0.0.0.0 port 8080 ... 用其它web服务器提供端口也一样，由于python比较方便，这里就用它
1、使用telnet判断
telnet是windows标准服务，可以直接用；如果是linux机器，需要安装telnet.
用法: telnet ip port
1）先用telnet连接不存在的端口
[root@localhost ~]# telnet 10.0.250.3 80 Trying 10.0.250.3... telnet: connect to address 10.0.250.3: Connection refused #直接提示连接被拒绝 2）再连接存在的端口
[root@localhost ~]# telnet localhost 22 Trying ::1... Connected to localhost. #看到Connected就连接成功了 Escape character is '^]'. SSH-2.0-OpenSSH_5.3 a Protocol mismatch. Connection closed by foreign host. 2、使用ssh判断
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/110442efe98a33f7c4873994bc4ad53b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66317ad08ac836c3372958ddcbb0318d/" rel="bookmark">
			【ROS学习】- tf学习 - tf中重要函数解析 (陆续更新....)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、函数waitForTransform()、lookupTransform()具体解释 二、函数 tf::StampedTransform()、sendTransform()具体解释 三、函数 Transformer::canTransform()具体解释 四、函数 Transformer::transformPose ()、Transformer::transformQuaternion（）具体解释 五、函数 pcl_ros::transformPointCloud()具体解释 这里记录一些 ROS中的 tf 用到的一些重要函数解析，陆续更新…
一、函数waitForTransform()、lookupTransform() // tf监听器 tf::TransformListener listener; // 查找turtle2与turtle1的坐标变换 listener.waitForTransform("/turtle2", "/turtle1", ros::Time(0), ros::Duration(3.0)); listener.lookupTransform("/turtle2", "/turtle1", ros::Time(0), transform); 这里 waitForTransform() ， /turtle2 是target_frame，这里理解为 数据应转换到的frame, 也就是 tf 的 frame_id ； /turtle1 是source_frame ，这里理解为 数据来源的frame, 也就是 tf 的 child_frame_id 。 等待的是 /turtle2 到 /turtle1 的坐标转换，ros::Time(0) 代表最近时刻的有效数据，ros::time::now() 是现在这个时刻的有效数据，不可以把 ros::Time(0) 改成 ros::time::now() ，因为监听做不到实时，会有几毫秒的延迟；最长等待 3.0 s 的时间。
这里 lookupTransform() , /turtle2 是target_frame，这里理解为 数据应转换到的frame, 也就是 tf 的 frame_id ； /turtle1 是source_frame ，这里理解为 数据来源的frame, 也就是 tf 的 child_frame_id 。 等待的是 /turtle2 到 /turtle1 的坐标转换，ros::Time(0) 代表最近时刻的有效数据，ros::time::now() 是现在这个时刻的有效数据，不可以把 ros::Time(0) 改成 ros::time::now() ，因为监听做不到实时，会有几毫秒的延迟；将得到的转换结果存放到 transform 中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66317ad08ac836c3372958ddcbb0318d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54a2fc107159b90c99c598087e4fb9ac/" rel="bookmark">
			js 24小时制  给定多个时间段 计算剩下的时间段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js
js 24小时制 给定多个时间段 计算剩下的时间段 //已经存在的时间的段 时间段不能有交集 let arr=[['5:00','6:00'],['9:00','11:00'],['13:00','14:00'],['1:00','2:00'],['22:00','00:10']] //时间 排序 timeSort=(arr)=&gt;{ return arr.sort(function (a,b){ return Date.parse(`2000/01/01 ${a[0]}:00`) -Date.parse(`2000/01/01 ${b[0]}:00`) }) } // 如果存在 ['22:00','00:10'] 这样格式的 转化为['22:00','23:59'] 和['00:00','00:10'] formatTime(){ let newArr=[...arr] arr.forEach((item,index)=&gt;{ if(Date.parse(`2000/01/01 ${item[0]}:00`)&gt;Date.parse(`2000/01/01 ${item[1]}:00`)){ newArr.splice(index,1) newArr.push([item[0],'23:59']) newArr.push(['00:00',item[1]]) } }) console.log(newArr); return newArr } //计算方法 time = () =&gt; { let newArr = this.formatTime(arr) newArr= this.timeSort(newArr) // 时间段进行排序 let aaa= Date.parse(`2000/01/01 00:00:00`) //00:00 let bbb = Date.parse(`2000/01/01 23:59:00`) // 24:00 let leftTime=[] if(aaa&lt;Date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54a2fc107159b90c99c598087e4fb9ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1907424db0e9474a515525e4ecc08ec2/" rel="bookmark">
			python爬虫基础requests库的使用以及参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、简单介绍requests的使用方法2、爬虫中六种常用的异常处理。3、requests库的七个主要方法。3.1 七个主要方法3.2 HTTP协议对资源的操作 4、requests库方法的参数详解4.1 request()参数（requests.request(method, url, **kwargs)）4.1.1 method4.1.2 url4.1.3 **kwargs对应的13个参数4.1.4 具体使用方法 4.2 其他六个方法的参数 1、简单介绍requests的使用方法 以百度网站为例：
import requests r = requests.get('http://www.baidu.com') print(r.status_code) 调用status_code后，会返回一个值，如果返回值为200，则代表访问成功。
接着使用text查看内容：
print(r.text) 我们会发现有许多乱码，因此就需要改变编码方式。
print(r.encoding) print(r.apparent_encoding) r.encoding = r.apparent_encoding # 也可以这样写 # r.encoding = 'utf-8' encoding方法是从HTTPheader中猜测响应内容的编码，但如果header中不存在charset字段，就默认编码为ISO-8859-1，而apparent_encoding则是从内容中分析编码，只需将它赋给encoding 即可。
下面是爬虫通用代码框架：
import requests try: url = 'http://www.baidu.com' r = requests.get(url) r.raise_for_status() r.encoding = r.apparent_encoding print(r.text) except: print("爬取失败") r.raise_for_status()用来判断status_code的返回值，如果不是200，则返回一个HTTPError异常。
2、爬虫中六种常用的异常处理。 异常说明requests.ConnectionError网络连接错误异常， 如DNS查询失败，拒接连接等requests.HTTPErrorHTTP错误异常requests.URLRequiredURL缺失异常requests.TooManyRedirects超过最大重定向次数，产生重定向异常requests.ConnectTimeout连接远程服务时，超时异常requests.Timeout请求URL超时， 产生超时异常 3、requests库的七个主要方法。 3.1 七个主要方法 方法说明requests.request()构造一个请求，支撑以下各种方法的基础方法requests.get()获取HTML网页的主要方法，对应于HTTP的GETrequests.head()获取HTML网页头信息的方法， 对应HTTP的HEADrequests.post()向HTML网页提交POST请求的方法， 对应于HTTP的POSTrequests.put()向HTML网页提交PUT请求的方法，对应于HTTP的PUTrequests.patch()向HTML网页提交局部修改请求，对应于HTTP的PATCHrequests.delete()向HTML页面提交删除请求，对应于HTTP的DELETE 3.2 HTTP协议对资源的操作 方法说明GET请求获取URL位置资源HEAD请求获取URL位置资源的响应报告，即获得该资源的头部信息POST请求向URL位置的资源后添加新的数据PUT请求向URL位置储存一个资源，覆盖原URL位置的资源PATCH请求局部更新URL位置的资源，即改变该处资源的部分内容DELETE请求删除URL位置储存的资源 4、requests库方法的参数详解 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1907424db0e9474a515525e4ecc08ec2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7962a124d95905fb06ef0c46981f1434/" rel="bookmark">
			Https解决的问题及其连接过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Https介绍Http存在的问题对上述问题，Https的解决办法（使用SSL/TSL）加密算法（解决窃听风险）不可逆签名(数字签名)，Timestamp和Nonce随机数，（解决篡改问题）数字证书（解决冒充风险） SSL/TSL协议原理： Https建立连接的过程Https的握手大致流程：Https的数据传输 Http协议和Https协议的对比Http和Https的区别如下： 参考链接 Https介绍 HTTPS 是综合了对称加密和非对称加密算法的 HTTP 协议。既保证传输安全，也保证传输效率
Http存在的问题 1.窃听风险：Http采用明文传输数据，第三方可以获知通信内容
2.篡改风险：第三方可以修改通信内容
3.冒充风险：第三方可以冒充他人身份进行通信
对上述问题，Https的解决办法（使用SSL/TSL） 1.所有信息加密传输，避免三方窃听通信内容
2.校验机制，内容一旦被篡改，通信双发立刻会发现
3.配备身份证书(CA证书)，防止身份被冒充
加密算法（解决窃听风险） Https使用两种加密算法来保证安全和效率
对称加密：双方使用同一种加密规则对规则进行加解密，如AES,DES等
非对称加密：乙方生成两把秘钥（公钥和私钥）。公钥是公开的，任何人都可以获取，私钥是保密的，只存在于乙方手中。甲方获取公钥，然后用公钥加密信息，乙方得到密文后，用私钥解密。 如RSA，DH等
不可逆签名(数字签名)，Timestamp和Nonce随机数，（解决篡改问题） 数字签名：信息发送者生成的无法伪造的字符串
1.发送者生成的基于内容的消息摘要（可以理解为摘取部份内容hash后的字符串）
2.发送者使用私钥进行加密，得到数字签名。接受者收到后使用发送者的公钥解密，再和自己生成的消息摘要对比，就能知道是否被篡改了。
Timestamp和Nonce：时间戳和一个只能用一次的随机数
防止黑客截取了连接时的包，进行重放和篡改。
对于Timestamp和Nonce随机数，具体实现思路可以见参考链接，目前只需要知道能保证内容不被篡改。
数字证书（解决冒充风险） 服务端会返回数字整书给客户端，客户端会去一层层上上验证CA证书的真实性，直到全球知名的大CA（root CA）。这种层层授信背书的方式，保证了证书的可信性。
SSL/TSL协议 作用域传输层和应用层之间，为应用提供数据的加密传输（TSL可以认为是SSL3.0的升级版，TSL1.0标记位SSL3.1）
原理： 1.SSL/TLS协议基本思路是采用公钥加密法（最有名的是RSA加密算法），客户端向服务器索要公钥，然后用公钥加密信息，服务器收到密文，用自己的私钥解密。
2.为了防止公钥被篡改，把公钥放在数字证书中，证书可信则公钥可信。公钥加密计算量很大，为了提高效率，只在建立连接过程中使用。
3.在连接完成后，服务端和客户端都生成对话秘钥，用它加密信息，而对话秘钥是对称加密，速度非常快。
Https建立连接的过程 Https的握手 大致流程： 1.客户端向服务器发送请求，包括支持的协议等，附带一个随机数字A
2.服务器收到请求后，选择某种非对称加密算法，把数字证书签名公钥（用于客户端验证证书的有效性），身份信息发送给客户端，同时附带一个随机数B
3.客户端验证证书的有效性，并且生成一个随机数C(pre-master-secret)，用服务器的公钥加密随机数C以后发给服务器。确定以后的加密套件。
并且用服务器的公钥加密一段Finish的数据，用于验证连接的正确性。
4.服务器使用私钥解密数据后，并确认以后的加密套件。
并且用服务器的公钥加密一段Finish的数据，用于验证连接的正确性。
5.建立连接，使用约定的加密方法，使用三个随机数A.B,C,生成对话密钥（对称密钥），以后的通信使用该对话密钥。
6.连接建立后，使用对话密钥，同时还使用数字签名，Timestamp和Nonce随机数来加强安全性
Https的数据传输 使用Http发送请求，使用对话密钥加密数据，还会使用数字签名，Timestamp和Nonce随机数来加强安全性。
Http协议和Https协议的对比 Http和Https的区别如下： 1.Https协议需要到CA申请证书，大多数情况下需要一定费用
2.Http是超文本传输协议，信息采用明文传输，Https则是具有安全性SSL加密传输协议
3.Http和Https端口号不一样，Http是80端口，Https是443端口
4.Http连接是无状态的，而Https采用Http+SSL构建可进行加密传输、身份认证的网络协议，更安全。
5.Http协议建立连接的过程比Https协议快。因为Https除了Tcp三次握手，还要经过SSL握手。连接建立之后数据传输速度，二者无明显区别
参考链接 https://www.jianshu.com/p/27862635c077（https介绍）
https://www.jianshu.com/p/4764825fb916（《图解Http》笔记）
https://mp.weixin.qq.com/s/cSkTmAwoJmp78EFJQ05r4w（使用例子讲解Https）
https://blog.csdn.net/koastal/article/details/53456696（timestamp和nonece介绍）
《码处高效java开发手册》 1.6.5 https
极客时间 趣谈网络协议 14讲 https
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f22aafbc9775cdabfa3b45bbc287cae5/" rel="bookmark">
			sed: could not open temporary file /etc/sedbkUwRn: Permission denied
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海思交叉编译器安装出现错误
sed: couldn't open temporary file /etc/sedbkUwRn: Permission denied 解决方法：
sudo su 再source 安装脚本
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处！
更多精彩内容，欢迎访问一只海星的主页
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a40ac6e60b5b5b66ee767dfda4755879/" rel="bookmark">
			IDEA 解决web项目下的web.xml中 context-param的自动提示中没有contextConfigLocation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
如下图所示
web项目下的web.xml中 context-param的自动提示中没有contextConfigLocation
解决方式：
Settings-Plugins中，勾选Spring MVC，然后重启idea即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed5916b8d76329bdd4e8879648134a5c/" rel="bookmark">
			flask路由与视图函数中参数传递
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		客户端(例如 Web 浏览器)把请求发送给 Web 服务器，Web 服务器再把请求发送给 Flask 程序实例。程序实例需要知道对每个 URL 请求运行哪些代码，所以保存了一个 URL 到 Python 函数的映射关系。处理 URL 和函数之间关系的程序称为路由。
在 Flask 程序中定义路由的最简便方式，是使用程序实例提供的 app.route 修饰器，把修 饰的函数注册为路由。
@app.route('/') def index(): return '&lt;h1&gt;Hello World!&lt;/h1&gt;' 像 index() 这样的函数称为视图函数(view function)。
传递参数 传递参数的语法是:"/&lt;参数名&gt;/",然后在视图函数中，也要定义同名的参数
converter:variable_name,其中converter就是类型名称
类型说明string默认的数据类型，接受没有任何斜杠"/"的文本int接受整型float接受浮点类型path和string的类似，但是接受斜杠uuid只接受uuid字符串(唯一,长度过长)any可以指定多种路径。 'any’数据类型可以在一个"url"中的指定多个路径
eg：
from flask import Flask, config app = Flask(__name__) @app.route('/&lt;any(blog,user):url_path&gt;/&lt;id&gt;') def detail(url_path,id): if url_path == "blog": return "博客详情:%s" % id else: return "用户详情:%s" % id if __name__ == '__main__': app.run(host="0.0.0.0", port="8899", debug=True) URL 与视图函数中两种方式传参方式 第一种:使用 path 的形式(将参数嵌入到路径中) @app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed5916b8d76329bdd4e8879648134a5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e9d454d206a04c865bb81d64c747604/" rel="bookmark">
			Dijkstra算法及代码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迪杰斯特拉算法解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为非负值，其在运行过程中维持的关键信息是一组节点集合S。算法重复从结点集V-S中选择最短路径估计最小的结点u，将u加入到集合S，然后对所有从u发生的边进行松弛，运行结束后，从源节点到集合S中每个结点之间的最短路径已经被找到。
下面，通过一个实例讲解该过程！
一、示例详解 如图，是一个有向无环图，假定出发点为V1，迪杰斯特拉算法将算出V1到其他所有点的最短路径，则所求V1到终点的最短路径也可得到，该算法主要完成以下几步：
找到V1 得到以V1出发的邻接点的最短距离，将V1加到S集合中（代码中通过vis数组标记） 从S集合之外的点中找到距离最短者，对以其为出发点的邻接点进行松弛操作，若距离被更新，则记录前驱 重复3，直到所有点被S集合收录 完成后，将得到V1到所有点的最短距离，同时，通过每一个点记录的前驱得到最短路径。
1.问题 1.1 松弛操作是啥？ 松弛操作意味着比起原来的路径，找到了一条距离更短的路，则将原来点的距离更新为新的距离。注意本文中某个点的距离全部指的是从出发点即V1到该点的距离。代码如下：
if(dis[j]&gt;dis[k]+map[k][j]) { dis[j]=dis[k]+map[k][j]; path[j]=k; } 1.2 为啥每个点记录前驱能用于V1到所有终点？ 我的理解是最短路是由最短路+某一条固定路组成，所以前驱适用全部点，比如该图中V1到V7的最短路径为V1-&gt;V2-&gt;V3-&gt;V5-&gt;V6-&gt;V7，因为V6-&gt;V7的距离固定为50，所以V7的最短路径中V1-&gt;V6的一段必然是V1-&gt;V6的最短路径，因此每个结点只需记录一个前驱。要想打印出路径，从终点开始一次次找前驱即可，可通过递归实现。代码如下：
void print(int x)//x为终点 { if(x == -1) return; //递归 print(path[x]); printf("%d-&gt;",x); } 2. 算法过程 程序运行过程中，数据的更新情况如图所示：
红色数据代表每次迭代中被更新的数据，下标代表了结点前驱。由上图可得，当所有结点加入S后，就得到了V1到所有结点的最短距离和最短路径，例如V1到V7的最短距离为130，V7的前驱为V6，V6的前驱为V5，V5的前驱为V3，V3的前驱为V2，V2的前驱为V1，则V1到V7的最短路径为V1-&gt;V2-&gt;V3-&gt;V5-&gt;V6-&gt;V7。
3. 算法复杂度分析 二、代码实现 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; /*问题描述： * 输入n和m，代表n个节点，m条边，然后是m行输入，每行有x,y,z，代表x到y的路距离为z。 * 问题：从1出发到各点的最短路径。 * 测试样例： 7 12 1 2 20 1 3 50 1 4 30 2 3 25 2 6 70 3 4 40 3 6 50 3 5 25 4 5 55 5 6 10 5 7 70 6 7 50 */ using namespace std; const int maxn = 100; int map[maxn][maxn]; int dis[maxn]; int path[maxn]; int vis[maxn];//记录更新过的点 int n; void dijk(int s) { //初始化 memset(path,-1,sizeof(path)); /*INF使用0x3f3f3f3f的好处： * 1：满足无穷大加一个有穷的数依然是无穷大（在DijKstra算法松弛操作中避免了溢出而出现负数） * 2：满足无穷大加无穷大依然是无穷大（两个0x3f3f3f3f相加并未溢出） * 3：初始化时，由于每一个字节为0x3f，所以只需要memset（buf，0x3f,sizeof(buf)）即可 */ memset(dis,0x3f,sizeof(dis)); //初始化为无穷大 memset(vis,0,sizeof(vis)); dis[s] = 0; //自身到自身的距离为0 while(1) { int k = 0; for(int j = 1; j &lt;= n; j++) { if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e9d454d206a04c865bb81d64c747604/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a842c4102cfdf7173c0381687508c17a/" rel="bookmark">
			C&#43;&#43;操作Windows防火墙添加例外程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++操作Windows防火墙添加例外程序 以下代码示例练习Windows防火墙配置文件。 显示当前配置文件，关闭防火墙，打开防火墙并添加应用程序。
/* Copyright (c) Microsoft Corporation SYNOPSIS Sample code for the Windows Firewall COM interface. */ #include &lt;windows.h&gt; #include &lt;crtdbg.h&gt; #include &lt;netfw.h&gt; #include &lt;objbase.h&gt; #include &lt;oleauto.h&gt; #include &lt;stdio.h&gt; #pragma comment( lib, "ole32.lib" ) #pragma comment( lib, "oleaut32.lib" ) HRESULT WindowsFirewallInitialize(OUT INetFwProfile** fwProfile) { HRESULT hr = S_OK; INetFwMgr* fwMgr = NULL; INetFwPolicy* fwPolicy = NULL; _ASSERT(fwProfile != NULL); *fwProfile = NULL; // Create an instance of the firewall settings manager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a842c4102cfdf7173c0381687508c17a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc94a44af7485f614b8a1badb11382bb/" rel="bookmark">
			疫情得到控制之后的广州
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020年三月，我回到了广州，这个还在一直增加疑似病例和确诊病例的城市，是我一直工作的城市。不一样的是，疫情的拐点已经过去，每天的新增病例和出院人数都在变化，情况再向好的方向发展。所以再次回到广州没有那么的恐慌，出门戴好口罩可能也是必备的一项工作，非常值得高兴的是公司还是不要求我们到公司上班，而是在广州的家远程办公，用着那时好时坏免费版team viewer。我搬了新家，去到遥远的番禺大石站。这里的房租确实便宜人也多，特别是晚上的时候，你都不知道窗外是谁家的声音，就算是周末也会有人早起，不隔音就是打扰你最大的麻烦。
刚开始一个人住进新家很不习惯，感觉它不像一个家，像一个笼子，最糟糕的是这边没有什么公园学校和运动场，我的饭后一些娱乐项目骤降，只得和朋友在线上打游戏，可是网络更垃圾，看视频的时候还可以，游戏中卡得掉出去，气得我嗷嗷叫。白天房子的采光只有厕所里面的一扇小窗，也就是说最亮堂的就是小小的厕所。刚开始，工作不是很繁忙我就一个人背上书包查看大众点评上一些附近的景点公园，坐上地铁我就出发了，自然所到之处都是很少的人，毕竟像我这样上班摸鱼还出去玩的人还是寥寥无几的吧，有一说一确实猖狂。到后来实在没地方想去了，我就买了几本书在家看，什么理财、职业生涯规划、王小波和动物性行为，特地上豆瓣和当当商城选了很久，看了一段时间用处很大，睡眠质量稳步提升，实验证明看手机真的会让人精神百倍。
我住的地方是一个村，然后有一些房屋的中介管理，能买的东西还是应有尽有，但是我看到一些店铺开始转让，可能它倒闭了放弃了，也有可能在积极应对疫情冲击等待再一次回归，但是从大局来看，确实很多中小企业甚至大企业都受到了08年金融风暴之后的再一次生存危机，网上不断充斥着大企业大公司裁员减薪的传闻，“失业” 可能是最近听到过频率最多的词语，还好我的饭碗是保住了，但是我的朋友和我说他们年后的工资一直都没发，一个好兄弟的差旅费也是没发，还是自己垫付的，工资也只发了50%。现在还在奔波于各个公司面试的人只看到他们每个人都带着口罩，其实心底里早已经奔溃了好几次，这一年太艰难了，希望下半年能有好的转机，让那么失业破产的人重拾希望。
广州还是那个广州，工作日路上的行人上班的人都急匆匆，早上八点的地铁还是照常的拥挤，地铁口的早餐依旧售卖，年轻人们还在继续趾高气昂，用尽全力过着平凡的一生。继续加油，等待疫苗的出现，等待国家宣布可以摘掉口罩的那天。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6584571fb4720a8d9f81bc99c7ce69f5/" rel="bookmark">
			Oracle_VM_VirtualBox_Extension安装失败解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接安装报错：
解决方法：
方法一：将virtualbox 使用管理员权限启动，重新安装。
方法二：前往官网下载高级扩展包，安装高级扩展包（报错如果不是上述错误不用管）。
然后如图前往查看扩展包，如果再扩展包里有前面带有感叹号的扩展程序（如果没有该方法不适用）在旁边点击添加按钮，选择合适版本的扩展，会提示扩展包降版本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3d4b3243736f7efb89746eb030d1f06/" rel="bookmark">
			微信小程序：WeUI一个专为微信小程序设计的UI框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WeUI是什么 WeUI 是一套同微信原生视觉体验一致的基础样式库。由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。它最初是为了给在微信端页面提供一致的视觉体验而开发开源的一个样式库，后续随着小程序、企业微信等等的开放能力出现，WeUI也提供了小程序、企业微信等等的版本。我们将要介绍的，就是WeUI的小程序版本。
WeUI提供非常多的基础组件。列举如下：
表单组件
Button 按钮 Input 输入框 List 列表 Slider 滑块 Uploader 上传组件 基础组件 Article 文章 Badge 徽章（小红点） Flex 布局 Footer 脚注 Gallery 画廊 …等等 操作反馈 ActionSheet 弹出式菜单 Dialog 对话框 Msg 提示页 Picker 选择器 Toast 弹出式显示 导航相关 Navbar 导航栏 Tabbar 选项栏 搜索相关 官网地址：https://weui.io/。
Github地址为：https://github.com/Tencent/weui。
小程序版本的地址为：https://github.com/Tencent/weui-wxss/。
使用weui进行开发可以简单分为两个步骤。 第一步：导入weui.wxss文件 因为weui.wxss是样式文件，所以导入需要在工程的样式文件进行导入，在这里因为我们是在项目全局使用weui的，所以在项目根目录的app.wxss文件进行导入。
weui.wxss文件位于项目的dist/style目录下，我们在工程下创建thirdparty目录，把weui.wxss文件拷贝进去。接着，在app.wxss导入weui.wxss文件。在app.wxss增加import这一行的代码。
/**app.wxss**/ @import 'thirdparty/weui.wxss'; .container { height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 200rpx 0; box-sizing: border-box; } 第二步：参照weui提供的例子使用weui组件 我们可以在example目录找到对应组件的视图层代码和逻辑层代码，比如我们要使用的九宫格，就位于example目录下的grid。我们可以直接拷贝使用里面的代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3d4b3243736f7efb89746eb030d1f06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8d34d2667215eb5e4722c12434b231a/" rel="bookmark">
			Mockito与 PowerMock 版本对应关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题：java.lang.ClassNotFoundException: org.mockito.exceptions.Reporter1. 我的jar版本 与 问题解决2. 问题排查过程：2.1 检查版本对应关系2.2 检查是否缺少jar依赖2.3 在Mockito的Maven设置里有所发现 3. 参考资料 问题：java.lang.ClassNotFoundException: org.mockito.exceptions.Reporter 1. 我的jar版本 与 问题解决 我的jar版本：
mockito-core： 2.8.9 powermock-api-mockito：1.7.4 powermock-module-junit4：1.7.4 问题解决：
解决方案：powermock-api-mockito 改为 powermock-api-mockito2 powermock-api-mockito 支持 mockito 1.x powermock-api-mockito2 支持 mockito 2.x 2. 问题排查过程： 2.1 检查版本对应关系 怀疑是版本问题，所以在官网找到了下图：版本对应关系
对照图片上，并木有什么问题。
2.2 检查是否缺少jar依赖 PowerMock 支持 EasyMock 和 Mockito 框架，使用需要依赖 api 和 测试框架。 这点上也没问题，三个依赖都在。
2.3 在Mockito的Maven设置里有所发现 powermock-api-mockito 支持 mockito 1.x，并且PowerMock 2版本会被drop掉。 我mockito用的2.8.9，api却用的powermock-api-mockito，明显就对应不上。
powermock-api-mockito2 支持 mockito 2.x。换个jar，问题解决。
mockito-core： 2.8.9 powermock-api-mockito2：1.7.4 powermock-module-junit4：1.7.4 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8d34d2667215eb5e4722c12434b231a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7059921438a144ab9993fe18bc06c5d/" rel="bookmark">
			docker搭建jenkins
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、运行jenkins 这里我们选择Jenkins中国定制版的镜像是因为下载jenkins的插件快不会失败，因为插件源换成了国内的
docker run -itd \ -p 8080:8080 -p 50000:50000 \ --name jenkins \ --privileged=true -u root \ --restart=always \ -v /data/jenkins:/var/jenkins_home \ jenkinszh/jenkins-zh:lts 备注：8080是web端口；50000是jenkins的slave节点连接jenkins的master节点需用到的
容器运行后我们打开页面，我的宿主机ip是192.168.15.9，容器的80端口映射到了宿主机8888端口，所以我们通过http://192.168.15.9:8888/访问web服务，第一次访问需要解锁jenkins输入管理员密码
因为我们把容器的/var/jenkins_home映射到了宿主机的/data/jenkins目录，所以通过以下方式获取初始密码，copy到web
$ cat /data/jenkins/secrets/initialAdminPassword 19d2df6c2cc64cd4828bac4506107071 安装推荐的插件
等待插件安装完成后，创建一个管理员账号
实例配置默认即可
二、添加节点 jenkins可以分布式构建代码，比如有两个项目需要打包 ，我们可以让第一个项目在A节点打包，另一个项目在B节点打包，这样可以互不干扰并发打包两个项目了。
新增节点
节点名称唯一，不能重复
以下是两种不同的方式添加slave节点
1、ssh方式添加节点（节点可以是物理机也可以是容器，此处物理机） # step1: 在jenkins容器所在的宿主机先生成ssh key $ ssh-keygen # 一直 enter 确认即可 # step2: 把整个".ssh"目录copy到/var/jenkins_home $ cp -r ~/.ssh /data/jenkins # step3: 把 ~/.ssh/id_rsa.pub 内容append到slave节点机的 ~/.ssh/authorized_keys文件 # step4: 把 ~/.ssh/id_rsa 内容copy到新增节点的 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7059921438a144ab9993fe18bc06c5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d188731b7e270584d4842cbcb24aaa8/" rel="bookmark">
			filecoin lotus benchmarks v26 GeForce GTX 2080 Ti GeForce GTX 1080 Ti
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		filecoin lotus benchmarks v26 GeForce GTX 2080 Ti 1，编译bench2，基准测试3，GeForce GTX 2080 Ti 测试 1，编译bench 版本 # git show commit d11e375f828526eab2a59fd6fd3db88e3c5cb9d3 (HEAD -&gt; interopnet, tag: interop.5.13, origin/interopnet) Merge: 7b8ee402 1d8c8b9a Author: Travis Person &lt;travisperson@users.noreply.github.com&gt; Date: Wed May 13 05:44:28 2020 +0000 Merge remote-tracking branch 'origin/fix/check-gas-limits' into interopnet 设置环境变量 # export ALL_PROXY=socks5://127.0.0.1:1080 # git config --global http.proxy 'socks5://127.0.0.1:1080' # export GO111MODULE=on # export GOPROXY=https://goproxy.cn env RUSTFLAGS="-C target-cpu=native -g" FFI_BUILD_FROM_SOURCE=1 make clean deps bench 最后显示，编译成功，当前目录可以看到bench go build -o bench .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d188731b7e270584d4842cbcb24aaa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13e7f1c8066298ba28105a5ce3cbae75/" rel="bookmark">
			el-table的多选框（默认全选，条件性渲染，动态勾选等功能）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
最近一直在跟表格里的多选框做斗争，一开始觉得el-table本身的多选框不满足我的需求，想要自定义el-checkbox来实现，结果发现很多坑，还没解决（主要是数据绑定不同步更新的问题），感觉蛮花时间的，又回头看看el-table有没有方法能完善一下，结果成功了，虽然具体实现过程还是很。。。低级，希望可以借鉴这个寻找更好的解决方案，故此记录
页面元素：单选框、输入框、带多选框的表格
需求
针对页面元素说明功能需求如下
表格 带多选框多选框带条件性渲染，满足某条件，多选框不显示多选框默认全选中单选框 根据单选框的切换控制表格多选框是否禁用输入框 显示多选框选中的数量手动输入的数字不能超过表格可选数据的总数量手动输入数字，动态按顺序勾选多选框指定数量的数据 实现
el-table 本身就有多选框的功能
故只要加上&lt;el-table-column type="selection"/&gt;就可以为表格加上多选框
以下为我的表格代码
&lt;el-table ref="dataTable" :data="goodsList" highlight-current-row stripe :fit="true" type="index" :cell-class-name="isRender" @selection-change="handleGoodsChange"&gt; &lt;el-table-column type="selection" width="50" :selectable="checkSelectable" /&gt; &lt;el-table-column prop="name" label="商品名称" sortable /&gt; &lt;el-table-column prop="code" label="商品编码" sortable /&gt; &lt;el-table-column prop="unitprice" sortable label="单价" /&gt; &lt;el-table-column prop="num" label="数量" sortable /&gt; &lt;el-table-column prop="unit" label="单位" sortable /&gt; &lt;el-table-column prop="price" sortable label="金额" /&gt; &lt;/el-table&gt; 由此带多选框表格有了
控制多选框是否渲染
使用动态class为满足条件的行添加display:none样式隐藏多选框
:cell-class-name="isRender" //为表格的每一行添加class /** * 条件判断，添加样式 * @param row * @returns classname */ isRender (row) { if (row.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13e7f1c8066298ba28105a5ce3cbae75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b29af1169a282264b52f9b19f19c58c0/" rel="bookmark">
			VueTouchKeyboard——一个模拟键盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能需求：封装一个带有设计好的样式的输入组件，输入方式为模拟的数字键盘。
键盘组件为VueTouchKeyboard,下载方式如下
npm install "vue-touch-keyboard" --save image.png 封装的输入组件
模板
&lt;template&gt; &lt;div v-clickoutside="hide"&gt; &lt;input v-bind="$attrs" @focus="show" @blur="submit" /&gt; &lt;div class="keyboard__warn-mess keyboard__warn"&gt; &lt;div v-if=warnMessage class=""&gt; {{warnMessage}} &lt;/div&gt; &lt;/div&gt; &lt;vue-touch-keyboard class="keyboard-nav" :options="options" v-if="visible" :cancel="hide" :layout="layout" :accept="hide" :input="input" /&gt; &lt;/div&gt; &lt;/template&gt; 很简单，就包含了一个VueTouchKeyboard模拟键盘和input输入框，以及一个div里放动态的warnMessage
js内容：
&lt;script&gt; import VueTouchKeyboard from 'vue-touch-keyboard'; import 'vue-touch-keyboard/dist/vue-touch-keyboard.css'; import $ from 'jquery'; const clickoutside = {//自定义命令，功能：点击键盘以外的区域隐藏键盘 // 初始化指令 bind (el, binding, vnode) { function documentHandler (e) { // 这里判断点击的元素是否是本身，是本身，则返回 if (el.contains(e.target)) { return false; } // 判断指令中是否绑定了函数 if (binding.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b29af1169a282264b52f9b19f19c58c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/387318d351ee0965500f4b17204e7a98/" rel="bookmark">
			Matlab-python-ABAQUS数据交互及联合使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Matlab可以方便地实现各种优化算法，ABAQUS可以方便地进行有限元建模及求解，有时候两者结合可以更方便做一些自己想做的事，例如通过遗传算法，神经网络等算法进行参数反演，确定本构模型的参数。ABAQUS/CAE的内核语言是Python，通过Python可以方便地读取ABAQUS的结果数据库odb的数据。这里介绍一些关于如何进行三者的交互，编写交互的方法与经验。关于ABAQUS中odb的数据结构这里就不多说，参考相关书籍。通过matlab提交inp文件给ABAQUS计算
可以在matlab里面直接通过系统调用向ABAQUS提交计算文件及相关计算参数，包括用户子程序，cpu数量等。下面是一个函数接口。
接口函数例子：runabaqus(Path,UserFile,InpFile,cpus):
这是一个Matlab接口函数，同时也是实现程序。功能是根据指定参数向ABAQUS提交计算文件，并监测ABAQUS计算过程。参数列表(Path,userFile,InpFile,cpus)含义分别为：
1）Path：inp计算文件所在的绝对路径。
2）UserFile：用户Fortran子程序，如果有子程序就给子程序的文件名，没有的话就不要这个参数，把runabaqus的一行代码inputFile=[‘abaqus job=’,InpFile,’ user=’,userFile,’ cpus=’,cpus]，改为inputFile=[‘abaqus job=’,InpFile,’ cpus=’,cpus]。
3）InpFile：inp计算文件的文件名。
4）cpus：指定ABAQUS求解器使用的cup数量。
其实只需一条命令，system(abaqus job=Inpfile )就可以完成提交计算文件，其他都是辅助，使接口函数适用性更好，把实现方法封装起来。有了接口函数，在matlab定义好相关参数，调用接口就行。
应用例子：
—matlab利用python脚本读取odb数据
思路是：matlab把读取数据的要求写入个txt文件（这里是req.txt），调用python脚本，python脚本读取odb的结果数据，并写入另一个txt文件(这里是RF3.txt)，matlab再从txt文件读取数据。首先编写python接口函数，实现从odb提取特定的结果数据。
例子：读取一个参考点的反力RF3
这是一个python程序，是get_history_output接口的功能实现程序，被get_history_output接口函数调用。其功能是读取req.txt里的参数，按照设定的参数读取odb数据库，并把结果写入”结果关键字.txt”文件，例如读取的是反力RF3时，其结果会被写入”RF3.txt”文件，以供其他程序使用。
有了python脚本就可以在matlab里调用它来读取ABAQUS的结果数据。当然在matlab里要指定odb文件名，部件名，节点名称等信息，为了把实现封装起来，也把调用python脚本的matlab程序写成一个函数get_history_output。
调用python脚本的matlab函数：
get_history_output(Path,OdbFile,step,req)说明：
这是一个matlab接口函数，实现程序是python程序odbHistoryOutput.py。get_history_output的功能是将用户指定的参数写入req.txt文件，调用odbHistoryOutput.py程序读取ABAQUS结果数据库odb的结果数据。(Path,OdbFile,step,req)参数列表含义分别为：
1）Path：odb文件所在的绝对路径。
2）OdbFile：odb数据库的文件名。
3）step：指定读取的分析步。
4）req：读取数据的要求，包括部件名、节点名、结果关键字，例如，req定义如下：
req=’PLATEN-1, Node PLATEN-1.5322,RF3’；
则指明了程序去读取部件名为PLATEN-1，节点名Node PLATEN-1.5322的反力RF3。注意，与历史变量相关的节点名是系统命名的，但是这些节点名有一定的规律，总是这样的形式“Node+空格+instance name.节点号”。
这里的参数(Path,OdbFile,step,req)是读取odb结果需要的，先把它们写入到req.txt文件，供上面的python脚本odbHistoyOutput.py读取。其中showlogfile函数显示python运行时输出的信息，这些信息保存在pylog.txt文件中。该函数的实现在另一篇博客Matlab目录操作及fgetl函数已经介绍。
那么在matlab里就可以指定odb相关信息，调用上面的函数来get_history_output获得odb数据。
应用例子：特别说明
这里与历史变量输出的节点或节点集的名称与你在step里设置历史结果输出指定的节点名是不一样的，与历史变量相关的节点名是系统命名的，这里只有用系统命名的节点名作为参数，才能正确读取所要的历史结果输出。但是这些节点名有一定的规律，总是这样的形式“Node+空格+instance name.节点号”，例如我的模型里有一个部件叫PLATEN-1，定义了一个参考点，并把它设置为一个set，在step里设置了输出它的反力RF3，并且我知道了它的的节点号是5322，那么我设置历史结果相关的节点名称是就是“Node PLATEN-1.5322”。
运行程序后，首先matlab把参数写入req.文件。req.txt记录了指定的相关参数，以逗号隔开，每个参数，如下：然后matlab调用python脚本odbHistoyOutput.py，读取odb数据。odb首先读取req.txt的参数，然后再根据参数去读取odb数据，把结果写入ReqData（即RF3.txt），结果包含时间和反力RF3，如下(部分省略)：
这里matlab与python脚本之间可能有比较的参数和数据需要传递，因此，我这里先把要传递的参数和数据写入特定的txt文件，然后再由另一程序去读取。其次是这里尽量把每个简单的功能写成函数，这样有助于更容易调试程序，不断添加新功能和集成。这就是增量式开发的思想。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95adb5a1363a0f3a584258d0c0a5a06d/" rel="bookmark">
			Win10默认输入法切换中英文标点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Win10中写代码注释时想要在默认的五笔输入法下使用英文标点，如果使用Shift键切换，在标点比较多的情况下实在是太过麻烦。
win10默认输入法自带切换中英文标点的功能，开启方法是ctrl+.
但是需要注意的是该快捷键只能在亲版的输入法中使用，也就是需要在输入法界面中关闭兼容性开关。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ff08d7d202a14ecb33749a60ecf6c80/" rel="bookmark">
			rancher添加集群失败：Etcd Cluster is not healthy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 有一台虚拟机，曾经用来做过rancher集群的agent（角色：etcd、control、worker），后来我删除了这个集群，现在又想用这台虚拟机做rancher集群，结果添加失败，报[etcd] Failed to bring up Etcd Plane: [etcd] Etcd Cluster is not healthy错误
二、解决 谷歌后找到了原因：删除集群的时候没有清除完相关的资源
# 在虚拟机上执行以下操作 # step1：删除rancher相关容器（注：以下命令会删除所有容器，如果你的虚拟机还有rancher集群之外的其他容器，也会被删掉） $ docker rm -f $(docker ps -qa) $ docker rmi -f $(docker images -q) # step2：删除mount挂载点 $ for mount in $(mount | grep tmpfs | grep '/var/lib/kubelet' | awk '{ print $3 }') /var/lib/kubelet /var/lib/rancher; do umount $mount; done # step3：删除映射的目录 $ rm -rf /etc/ceph \ /etc/cni \ /etc/kubernetes \ /opt/cni \ /opt/rke \ /run/secrets/kubernetes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ff08d7d202a14ecb33749a60ecf6c80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0da73678bcc880379bf62471645c02d/" rel="bookmark">
			Java获取当前时间String类型和Date类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java获取当前时间精确到年/月/日 时:分:秒（HH为24小时制hh为12小时制）
根据数据库建表创建的不同类型设置时间：String类型和Date类型
public static void main(String[] args) { // TODO Auto-generated method stub Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); //获取当前时间String类型 String time_string = sdf.format(date); System.out.println("获取当前时间String类型："+time_string); //获取当前时间Date类型 Date time_date = null; try { time_date = sdf.parse(sdf.format(date)); } catch (ParseException e) { e.printStackTrace(); } System.out.println("获取当前时间Date类型："+time_date);	} 输出结果：
获取当前时间String类型：2020-05-13 16:23:11
获取当前时间Date类型：Wed May 13 16:23:11 CST 2020
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87643d71a172436700d1b93a4a6a864d/" rel="bookmark">
			Pytorch 之 TSM（Time Shift Module）测试部分源码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文致力于将文中的一些细节给大家解释清楚，如果有照顾不到的细节，还请见谅，欢迎留言讨论
1.参数部分：
parser = argparse.ArgumentParser(description="TSM testing on the full validation set") parser.add_argument('dataset', type=str) # may contain splits parser.add_argument('--weights', type=str, default=None) parser.add_argument('--test_segments', type=str, default=25) parser.add_argument('--dense_sample', default=False, action="store_true", help='use dense sample as I3D') parser.add_argument('--twice_sample', default=False, action="store_true", help='use twice sample for ensemble') parser.add_argument('--full_res', default=False, action="store_true", help='use full resolution 256x256 for test as in Non-local I3D') parser.add_argument('--test_crops', type=int, default=1) parser.add_argument('--coeff', type=str, default=None) parser.add_argument('--batch_size', type=int, default=1) parser.add_argument('-j', '--workers', default=8, type=int, metavar='N', help='number of data loading workers (default: 8)') # for true test parser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87643d71a172436700d1b93a4a6a864d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f83a58ab650eadd233e81a797cf7cd88/" rel="bookmark">
			shell基础知识（进阶一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是shell
重定向符
管道符（任意门）|
通配符
转义符
环境变量
什么是shell shell是系统和计算机硬件交互时使用的中间介质。
重定向符 输入重定向 &lt;
作用：用于把文件数据流输入给命令
使用格式：
wc -l &lt; /etc/passwd #把/etc/passwd文件的数据流导入给wc -l命令# 输出重定向 &gt; 作用：用于把命令的处理结果输出给后面的文件（会覆盖之前的内容）
使用格式：
ls -l /etc/passwd &gt; test #把ls -l /etc/passwd命令执行的结果输入到test文件中# 追加重定向 &gt;&gt; 作用：用于把命令的处理结果输出给后面的文件（不会覆盖之前的内容）
使用格式：
ls -l /etc/passwd &gt;&gt; test #把ls -l /etc/passwd命令执行的结果输入到test文件中# 错误重定向 2&gt; 作用：用于把命令的错误处理结果输出给后面的文件（会覆盖之前的内容）
使用格式：
sl /etc/passwd 2&gt; test #因为sl命令不存在，所以语句执行失败，会把错误返回输入到test文件中# 错误追加重定向 2&gt;&gt; 作用：用于把命令的错误处理结果输出给后面的文件（不会覆盖之前的内容）
使用格式：
sl /etc/passwd 2&gt;&gt; test #因为sl命令不存在，所以语句执行失败，会把错误返回输入到test文件中# 统合输出重定向 &amp;&gt; 作用：用于把命令的执行结果（无论成功或错误）全部输入给后面的文件
使用格式：
bash test.sh &gt; test1 #执行test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f83a58ab650eadd233e81a797cf7cd88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/285954a60083e40abe8ee355f9372f16/" rel="bookmark">
			【Python】【难度：简单】Leetcode 1370. 上升下降字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你一个字符串 s ，请你根据下面的算法重新构造字符串：
从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。
从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。
重复步骤 2 ，直到你没法从 s 中选择字符。
从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。
从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。
重复步骤 5 ，直到你没法从 s 中选择字符。
重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。
在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。
请你返回将 s 中字符重新排序后的 结果字符串 。
示例 1：
输入：s = "aaaabbbbcccc"
输出："abccbaabccba"
解释：第一轮的步骤 1，2，3 后，结果字符串为 result = "abc"
第一轮的步骤 4，5，6 后，结果字符串为 result = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/285954a60083e40abe8ee355f9372f16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0421558a0db59e2d398f79393789544e/" rel="bookmark">
			基于卷积神经网络的垃圾分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卷积神经网络 - 垃圾分类 代码和数据集可以在 我的AI学习笔记 - github 中获取
实验内容 自今年7月1日起，上海市将正式实施 《上海市生活垃圾管理条例》。垃圾分类，看似是微不足道的“小事”，实则关系到13亿多人生活环境的改善，理应大力提倡。
垃圾识别分类数据集中包括 glass、cardboard、metal、paper、plastic、trash，共6个类别。
生活垃圾由于种类繁多，具体分类缺乏统一标准，大多人在实际操作时会“选择困难”，基于深度学习技术建立准确的分类模型，利用技术手段改善人居环境。
数据集 该数据集包含了 2307 个生活垃圾图片。数据集的创建者将垃圾分为了 6 个类别，分别是：
序号中文名英文名数据集大小1玻璃glass4572纸paper5403硬纸板cardboard3704塑料plastic4455金属metal3806一般垃圾trash115 物品都是放在白板上在日光/室内光源下拍摄的，压缩后的尺寸为 512 * 384.
实验要求 建立深度学习模型，并尽可能将其调到最佳状态
绘制深度学习模型图、绘制并分析学习曲线等
分析模型并试着调试不同学习率等超参数对模型的结果影响
本地环境： GPU:
NVIDIA Quadro P600驱动程序版本：442.92CUDA：10.1（已添加到系统环境变量） torch 1.5.0+cu101
torchvision 0.6.0+cu101
安装使用均没有报错，并可以使用GPU进行训练。
记录 DNN；开始给的示例代码模型, 一个简单的全连接神经网络 inputs = Input(shape=input_shape) # 将输入展平 dnn = Flatten()(inputs) # Dense 全连接层 dnn = Dense(6)(dnn) dnn = BatchNormalization(axis=-1)(dnn) dnn = Activation('sigmoid')(dnn) dnn = Dropout(0.25)(dnn) dnn = Dense(12)(dnn) dnn = BatchNormalization(axis=-1)(dnn) dnn = Activation('relu')(dnn) dnn = Dropout(0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0421558a0db59e2d398f79393789544e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf6b61e8b7714e04d7317f580a612b31/" rel="bookmark">
			docker搭建gitlab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、运行gitlab $ docker run --detach \ --publish 8443:443 --publish 8080:80 --publish 2222:22 \ --name=gitlab \ --restart=always \ --volume /data/gitlab/config:/etc/gitlab \ --volume /data/gitlab/logs:/var/log/gitlab \ --volume /data/gitlab/data:/var/opt/gitlab \ --privileged=true \ gitlab/gitlab-ce-zh:11.1.4 二、修改配置文件 配置web和ssh访问
$ vim /data/gitlab/config/gitlab.rb external_url 'http://192.168.15.9' # 宿主机ip，设置web访问(http://192.168.15.9:8080) gitlab_rails['gitlab_ssh_host'] = '192.168.15.9' # 宿主机ip，设置仓库的访问 gitlab_rails['gitlab_shell_ssh_port'] = 2222 # 容器ssh 22端口映射到宿主机的端口2222 配置邮箱（可选），配置了邮箱：
1、新增gitlab用户的时候，会用该邮箱发送重置用户密码到用户邮箱
2、忘记管理员root密码的时候，也可以通过该邮箱找回密码
$ vim /etc/gitlab/gitlab.rb # 以下配置aliyun邮箱为例 #配置下面，需要配置smtp_tls #注意gitlab_rails['smtp_tls'] 这个是设定为true gitlab_rails['smtp_enable'] = true gitlab_rails['smtp_address'] = "smtp.aliyun.com" gitlab_rails['smtp_port'] = 465 gitlab_rails['smtp_user_name'] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf6b61e8b7714e04d7317f580a612b31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e573d3937dbd1092c2bff9a78fe504c/" rel="bookmark">
			实验4 循环结构程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验内容： 1、运行结果：
2、运行结果：
3、程序的功能：输出100~200之间的全部素数，每行输出10个。
4、补充程序：从键盘输入 5 组数，每组有 6 个数，求出每组中的元素绝对值之和的最大者和最小者，请补充程序。
（1）
（2）
6、有数列2/1,3/2,5/3,8/5,13/8……,求数列前 20 项之和。
7、求满足如下条件的3位数，它除以9的商等于它各位数字的平方和。例如224，它除以9的商为24，而= 24。
8. 如果一个整数等于它的因子（不包括该数本身）之和，则称该数为完数。例如，6 的因子是1,2,3，因为 6=1+2+3，因此 6 是完数。找出1000 以内的所有完数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d4bfce788cd4a4af56f7176e419765/" rel="bookmark">
			MOOC数据结构与算法Python版-第九周编程作业第一题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1二叉树复原（10分）
题目内容：
给定一种序列化二叉树的方式：从根节点起始按层次遍历二叉树所有“可能”存在节点的位置：若该位置存在节点，则输出节点值，并在下一层相应增加两个可用位置；否则输出None，且不增加下一层的可用位置。
例如"[5, 4, 7, 3, None, 2, None, -1, None, 9]"是下图所示的二叉树序列化的结果：
其中红色箭头对所有的None进行了标记。
现给出一个二叉树以这种形式序列化的结果，请复原该二叉树并给出它的中序遍历。
输入格式:
一行合法的Python表达式，可解析为包含整数与None的列表
输出格式：
二叉树中序遍历的整数序列，以空格分隔
输入样例：
[5, 4, 7, 3, None, 2, None, -1, None, 9]
输出样例：
-1 3 4 5 9 2 7
输入样例2：
[5,1,4,None,None,3,6]
输出样例2：
1 5 3 4 6
注：树结构如图（红色箭头对None的对应位置进行了标记）：
思路：找了好多得代码，他们的思路基本是将列表反序列化为树，在进行中序遍历，代码好长注释也少看起来好复杂，感觉自己写不出来。。。偶然发现另一个思路，将二叉树尽量补全为完全二叉树，再进行遍历。提出改思路文章地址：添加链接描述
# 将二叉树补全二叉树,最后一个可以作为父节点得节点为None，想补全但是没想出来 # 最后就没补，跑代码发现结果没影响。。 def complitTree(tree): tree = ['0']+tree i = 1 while 2*i+1 &lt;= len(tree): if tree[i] == 'None': tree.insert(2*i, 'None') tree.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68d4bfce788cd4a4af56f7176e419765/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2e75f9fc380ee18f04e5b0e77a57be3/" rel="bookmark">
			后台项目环境的安装和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：安装phpStudy,安装完成后停掉apache保持mySql运行即可，然后导入数据库，方法：点击mySql管理器 -》 mySql导入导出 -》 输入mySql密码，默认密码为root =&gt; 选择要还原的文件（.sql结尾的文件）=》 还原到数据库名要与还原前的名称保持一直，然后点击运行，当黑框关闭之后就导入完成了。 验证方法：在phpStudy中点击其他选择菜单 =》 mySql工具 =》 打开数据库目录 =》打开mydb（与导入前数据库名字一样）文件夹里面有很多文件则数据库还原完成。
第二步：在后台api项目中安装依赖包，方法：在api项目中按住shift+鼠标右键打开powerShell窗口，运行npm install命令；然后可以用cls命令清屏，再执行node .\app.js启动api接口项目。
第三步：在谷歌浏览器安装插件apizza用来测试接口，测试接口的get和post方法见下面两张图片
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c445e73d66b12b77121697552d02d5a/" rel="bookmark">
			css实现点击元素，改变背景色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 可通过使用css伪类实现点击元素变色的效果，两个伪类是:active, :focus
譬如实现一个div鼠标点击时改变背景色，
&lt;div class="my-demo"&gt;可以摸我&lt;/div&gt; 添加样式：
.my-demo：active { background-color: red; } :focus选择器用于选取获得焦点的元素。仅接收键盘事件或其他用户输入的元素允许 focus的 选择器。
注意：
:active，元素被点击时变色，但颜色在点击后消失；
:focus， 元素被点击后变色，且颜色在点击后不消失；
对于div等元素无法接受键盘或其他用户事件，不支持:focus伪类，则可通过增加tabIndex属性使其支持:focus
&lt;div tabindex="1"&gt; 上面 &lt;/div&gt; &lt;div tabindex="2"&gt; 中间 &lt;/div&gt; &lt;div tabindex="3"&gt; 下面 &lt;/div&gt; div:focus { background-color:red; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/930e62cc418ef68c991e0e9c940075d0/" rel="bookmark">
			ZooKeeper 原理及其在 Hadoop 和 HBase 中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ZooKeeper是一个开源的分布式协调服务，由雅虎创建，是Google Chubby的开源实现。分布式应用程序可以基于ZooKeeper实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。
简介 ZooKeeper是一个开源的分布式协调服务，由雅虎创建，是Google Chubby的开源实现。分布式应用程序可以基于ZooKeeper实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。
基本概念 本节将介绍ZooKeeper的几个核心概念。这些概念贯穿于之后对ZooKeeper更深入的讲解，因此有必要预先了解这些概念。
集群角色 在ZooKeeper中，有三种角色：
LeaderFollowerObserver 一个ZooKeeper集群同一时刻只会有一个Leader，其他都是Follower或Observer。
ZooKeeper配置很简单，每个节点的配置文件(zoo.cfg)都是一样的，只有myid文件不一样。myid的值必须是zoo.cfg中server.{数值}的{数值}部分。
zoo.cfg文件内容示例：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
maxClientCnxns=0
# The number of milliseconds of each tick
tickTime=2000
# The number of ticks that the initial
# synchronization phase can take
initLimit=10
# The number of ticks that can pass between
# sending a request and getting an acknowledgement
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/930e62cc418ef68c991e0e9c940075d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d84062020cc07d9a298786ef670c944a/" rel="bookmark">
			java周查询和mysql的yearWeek同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求要实现按周统计某个数量，本来以为调用mysql的week和java里calendar.get(Calendar.WEEK_OF_YEAR)就行了，结果发现对应不上，而且还有蛋疼的跨年问题，上一年的年末几日和这一年的开头几日可能属于同一周，而且根据天数分布这周可能归属于上一年也可能归属于下一年。mysql还好，有yearWeek方法，而java根本没有类似的方法calendar.get(Calendar.WEEK_OF_YEAR)根本没有包含年份信息，这一点也是比较奇怪，因为单独使用calendar.get(Calendar.WEEK_OF_YEAR)没什么意义。
我绝对参考百度上的日历，以星期一作为一周的开始
mysql使用yearweek(date,1)就行了
java则麻烦一点需要写个方法
public static Integer getYearWeek(Date date) { Calendar calendar = Calendar.getInstance(); calendar.setTime(date); return getYearWeek(calendar); } public static Integer getYearWeek(Calendar calendar) { calendar.setFirstDayOfWeek(Calendar.MONDAY); calendar.setMinimalDaysInFirstWeek(4); int week = calendar.get(Calendar.WEEK_OF_YEAR); int year = calendar.get(Calendar.YEAR); calendar.add(Calendar.DATE, -7);//获得上一周的周数 int lastWeek = calendar.get(Calendar.WEEK_OF_YEAR); int lastYear = calendar.get(Calendar.YEAR); if(week &lt; lastWeek &amp;&amp; year == lastYear) {//周数小于上一周，年数不变说明时间在年末，但是周数已经算到明年，年数需要+1 year += 1; } if(week &gt; lastWeek &amp;&amp; year &gt; lastYear &amp;&amp; lastWeek != 1) {//周数大于上周，年数也大于上周，并且上周不等于1，说明时间在新年的一月，但是周数还是去年的，年数需要-1 year -= 1; } return year * 100 + week; } 经过测试得出的值是一致的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b41fe22ab61531c60889f6d4628cfb34/" rel="bookmark">
			ERROR 1327 (42000): Undeclared variable:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select into from 和 insert into select都是用来复制表的
两者的主要区别为： 1）select into from 要求目标表不存在，因为在插入时会自动创建。
2） insert into select from 要求目标表存在
一、INSERT INTO SELECT语句
1、语句形式为：
Insert into Table2(field1,field2,...) select value1,value2,... from Table1
2、注意地方：
（1）要求目标表Table2必须存在，并且字段field,field2...也必须存在
（2）注意Table2的主键约束，如果Table2有主键而且不为空，则 field1， field2...中必须包括主键
（3）注意语法，不要加values，和插入一条数据的sql混了，不要写成:
Insert into Table2(field1,field2,...) values (select value1,value2,... from Table1)
（4）由于目标表Table2已经存在，所以我们除了插入源表Table1的字段外，还可以插入常量。
二、SELECT INTO FROM语句
语句形式为：
SELECT vale1, value2 into Table2 from Table1
要求目标表Table2不存在，因为在插入时会自动创建表Table2，并将Table1中指定字段数据复制到Table2中 。
总结复制表的基本语句(从旧表复制到新表)：
1、create table newTable as select * from oldTabel; 既复制表结构，也复制表内容；
2、create table newTable as select * from oldTable where 1=2; 只复制表结构，不复制表内容；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b41fe22ab61531c60889f6d4628cfb34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f475816e0700f5abc3655d904a4233bb/" rel="bookmark">
			【Python记事本】之tkinter模块及文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		核心代码来源：https://www.cnblogs.com/ybjourney/p/4995678.html
参考教程来源：https://www.cnblogs.com/shwee/p/9427975.html
记事本功能：文件，编辑和关于。
文件包括新建、打开、保存和另存四个命令。
编辑指的是对文本编辑中要使用的模块，下设功能：撤销，重做，复制，剪切，粘贴，查找和全选。
关于是下设作者和版权两栏。
本代码对源代码进行修改并添加了新的功能！
“文本经修改未保存时打开其他文件或新建文件，弹出提示未保存”，高度还原了windows记事本。
核心原理，定义两个全局变量，一个记录文本初次打开时的内容，一个记录是否保存，当点击新建或打开时，判断此时文本内容和初次打开时的文本内容是否经过改动，未改动则可以打开。
效果如下：
代码：不做伸手党，请不要吝啬您的赞！
from tkinter import * from tkinter import filedialog import tkinter.messagebox import os # 记录未作改动的文本 origintext = '' # 标记是否保存过 flag = True def new(): global filename global flag global origintext if origintext == textpad.get(1.0, END) or flag is True: flag = False root.title('未命名文件') filename = None textpad.delete(1.0, END) origintext = textpad.get(1.0, END) else: tkinter.messagebox.showinfo(title='警告', message='文件未保存！') def openfile(): global filename global origintext global flag if origintext == textpad.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f475816e0700f5abc3655d904a4233bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be87af555b1ada57586e6b818cc94cf2/" rel="bookmark">
			小白开始学习Python第一天（Geany输出中文报错）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一天学习小记 一直对编程有兴趣，最近开始付出行动了，今天是学习Python的第一天。
学习编程，当然打的第一条语句就是“Hello World”了，我也不例外。
今天发现了一个问题，使用Geany打印中文的时候会报错，百度了一下发现了解决办法，就是在开头打上注释#coding = gbk 就好，亲测有效。所以和你们分享一下。
学习代码的第一天，很不错！加油，希望自己以后可以从事这方面的工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3ceac742f12c740b32501cfaaa30caf/" rel="bookmark">
			Docker修改容器内部文件的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Docker修改容器内部文件的方法一共有三种，下面进行一一介绍。
1、进入容器内部修改 使用下面的命令以命令行的形式可以进入容器的内部对文件进行修改。
docker exec -it 容器ID /bin/bash 不过里面没有vim，需要自行安装，安装代码如下所示。不过不推荐这种形式，因为里边的文件是临时的，容器被删除之后，配置就失效了，需要从新配置。
apt-get update apt-get install vim 2、通过docker cp拷贝进行修改 可以通过下面的代码将需要修改的文件拷贝出来，修改完成之后再拷贝回去。这种方式其实和第一种差不多，只是不用安装vim，但是容器被删除之后，修改过的内容也会失效。而且需要重启容器才能生效（好像）
#将容器中的文件拷贝出来 sudo docker cp 容器ID:/etc/mysql/my.cnf /home/tom/ #将容器中的文件拷贝回去 sudo docker cp /home/tom/my.cnf 容器ID:/etc/mysql/ 3、使用-v挂载文件夹(推荐) 最后一种方法是在启动的时候使用-v将容器内部的文件夹挂载（映射）到本地的某个路径下，以后以后可以直接在本地修改，不需要进入容器内部.
#冒号前是本地路径（需要绝对路径），冒号后是容器中的路径 $ docker run --name mytomcat -v /home/www/webapps:/usr/local/tomcat/webapps -d tomcat 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4279f798bfe5a7dafc4686b01bcab218/" rel="bookmark">
			dlp2000 树莓派驱动方式，，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dlp2000 开发入门
树莓派驱动 DLP® LightCrafter Display 2000 评估板
树莓派主要有驱动dpi 和i2c 两个
dpi 主要用在显示器上面的接口
mipi 的dpi
i2c 是主要控制dlpc2607芯片
dlp 的开发板p2 —&gt; 19 20是i2c 接口
i2c 的控制方式有查看 it 的dlpc2607手册
手册地址：http://www.ti.com.cn/cn/lit/ds/symlink/dlpc2607.pdf?&amp;ts=1589200138628
树莓派 接线图
树莓派 可以供电给dlp2000开发板，也可以外接电源， dlp2000 这个板子供有电流有大些，最好是5V 3A的电源，
树莓派供电给 dlp2000
树莓派引脚 的p2_6 :5v 引脚 接在dlp2000板上面的j3
蓝色的引脚 接的是地，另一个引脚 是+5V
电源这部有注意一下，不有接错，容易 烧板子
蓝色线接的是ged 也就是负，外接电源不能同时树莓派供电和外接5V电源，只有一个电源，
树莓派驱动dpi 的方式是在文件修的
文件在/boot/config.txt
Add support for software i2c on gpio pins dtoverlay=i2c-gpio,i2c_gpio_sda=23,i2c_gpio_scl=24,i2c_gpio_delay_us=2
DPI Video Setup dtoverlay=dpi18
overscan_left=0
overscan_right=0
overscan_top=0
overscan_bottom=0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4279f798bfe5a7dafc4686b01bcab218/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd0bdd4d48309ef00e77b4a343a4c101/" rel="bookmark">
			Hadoop完全分布式安装的心酸历程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载VMware安装包 官网下载地址：https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html。
下载后点击.exe文件进行安装，安装成功后首次登录需要输入注册码，根据自己安装的版本百度搜索对应的注册码即可，输入注册码后即完成该软件的破解。破解后进入VMware的主界面如图1所示。
图1 VMware主界面 2.设置VMware的网络连接模式： 点击“编辑”下的“虚拟网络编辑器”，进入VMware的网络设置界面（如图2所示），点击“””进入管理员权限下的网络设置界面（如图3所示）：（1）选择NAT模式，各个虚拟机通过NAT使用宿主机的IP来访问外网。（2）我们的要求是集群中的各个虚拟机有固定的IP、可以访问外网，所以勾掉“”；（3）点击“”，进入NAT设置界面（如图4所示），这里需要记一下网关IP（192.168.211.2）后面的配置会用到，点击“”进行DNS配置（如图5所示）。至此VMware的网络配置完毕。
图2 WMware网络设置界面 图3 管理员权限下的VMware网络设置界面 图4 NAT设置界面 图5 DNS配置界面标题 3.安装虚拟机 （1）在VMware主页点击“新建虚拟机”；
（2）选择“典型”安装，点击“下一步”，如图6所示；
图6 选择典型安装 （3）选择“稍后暗转操作系统”，点击“下一步”，如图7所示；
图7 选择稍后安装操作系统 （4）选择要安装的系统类型，这里我选择的是Linux操作系统，系统版本为Centos7 64位，如图8所示；
图8 选择要装的系统与版本 （5）设置虚拟机的名称与安装位置，如图9所示；
图9 设置虚拟机的名称与路径 （6）设置虚拟机的空间大小，默认的设置即可，如图10所示；
图10 设置虚拟机的空间大小 （7）点击“完成”实现虚拟机的安装，如图11所示；
图11 完成虚拟机的安装 （8）下载Centos7的iso镜像文件，选择下载“CentOS-7-x86_64-DVD-2003.iso”（下载地址：http://mirrors.aliyun.com/centos/7/isos/x86_64/），如图12所示；
图12 下载Centos7的iso镜像文件 （9）点击“编辑虚拟机设置”来进行虚拟机相关信息的设置，如图13所示：
图13 编辑虚拟机设置 （10）点击DVD，指定操作系统ISO文件所在位置，如图14所示。
图14 指定操作系统ISO文件位置 （11）开启虚拟机，进行系统安装，如图15所示；
图15 开启虚拟机进行系统安装 （12）敲击回车，进行系统的安装，如图16所示；
图16 进行系统安装 （13）选择安装系统的版本（英文版、中文版），默认安装英文版，根据自身需求选择（建议选择英文版，路径不容易出错），如图17所示；
图17 选择安装系统的语言 （14）进行安装前的必要配置，配置完成后才能进行安装（如图18所示），使用默认的配置即可，直接点击“Done”按钮（如图19所示），点击“Begin Installation”开始进行安装（如图20所示）。
图18 进行安装所需的配置 图19 选择默认配置 图20 开始进行安装 （15）点击“ROOT PASSWORD”进行root账户密码的设置（如图21所示），为root账户设置完密码后点击“Done”（如图22所示），点击“Finish configuration”按钮完成配置继续进行安装（如图23所示）。点击Reboot启动操作系统（如图24所示）。
图21 为root账户设置密码 图22 为root账户设置密码 图23 完成配置 图24 安装成功重启系统 按上述方法，功安装3个虚拟机，分别是hadoop_01、hadoop_02、hadoop_03。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd0bdd4d48309ef00e77b4a343a4c101/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e45ec4bfb1de0e29c19802f2717a694/" rel="bookmark">
			网络爬虫 | 京东全站数据采集（类目、店铺、商品、评论）——基于Python中Scrapy框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.定义采集数据的存储结构
2.定义管道文件
3.定义中间件文件
4.scrapy爬虫设置文件修改
5.商品类目抓取
6.商品信息抓取
7.店铺信息抓取
8.评论信息抓取
9.抓取过程
10.基本数据展示
1.定义采集数据的存储结构 【存储结构说明】class CategoriesItem(Item)：存储京东类目信息class ProductsItem(Item)：存储京东商品信息class ShopItem(Item)：存储京东店铺信息class CommentSummaryItem(Item)：存储京东每个商品的评论概况信息class CommentItem(Item)：存储京东每个商品的评论基本信息class CommentImageItem(Item)：存储京东每个商品中每条评论的图像信息说明：类中所定义字段可依据具体采集要求或response内容进行调整 【items.py程序】
# -*- coding: utf-8 -*- # Define here the models for your scraped items # # See documentation in: # http://doc.scrapy.org/en/latest/topics/items.html from scrapy import Item, Field class CategoriesItem(Item): """ 存储京东类目信息 """ name = Field() # 商品三级类目名称 url = Field() # 商品三级类目对应url _id = Field() # 商品类目对应id[一级id,二级id,三级id] class ProductsItem(Item): """ 存储京东商品信息 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e45ec4bfb1de0e29c19802f2717a694/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31e72ebf5832ea458cc9b474ba063d58/" rel="bookmark">
			Element-ui 遇到的坑之返回顶部Backtop组件的target如何设置正确的值的问题。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： element-ui 的Backtop属性中有target的值是需要设置的。设置错了，不仅没有效果，反而还可以导致报错。
官方文档说明的是，target触发滚动的对象，String类型。
查看示例，是传一个css选择符。
查看官方源码，我们会发现，
init() { this.container = document; this.el = document.documentElement; if (this.target) { this.el = document.querySelector(this.target); if (!this.el) { throw new Error(`target is not existed: ${this.target}`); } this.container = this.el; } }, target是有默认值的，默认值是document.documentElement对象。我们传入一个css选择器进去后，就会替换为document.querySelector(this.target)选择的dom节点。
废话不多说，重点说一下解决方法。
解决方案一：什么都不传，用默认值。 &lt;template&gt; &lt;div class="appmain-wrap"&gt; &lt;!-- 返回顶部 --&gt; &lt;el-backtop&gt;&lt;/el-backtop&gt; &lt;!-- 其他代码--&gt; &lt;/template&gt; 这个时候，backtop拿到的是document.documentElement对象，它上面有滚动条就会触发返回顶部。
解决方案二：传入正确的target的值。 譬如我是在一个tabs页面使用的示例。
&lt;template&gt; &lt;div class="appmain-wrap"&gt; &lt;el-tabs v-model="activeName" @tab-click="handleClick"&gt; &lt;el-tab-pane label="用户管理" name="first"&gt;用户管理 &lt;el-backtop target=".appmain-wrap"&gt;&lt;/el-backtop&gt; &lt;!-- 其他代码--&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane label="配置管理" name="second"&gt;配置管理&lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;/div&gt; &lt;/template&gt; 这个时候，还是不行，需要给.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31e72ebf5832ea458cc9b474ba063d58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b84cce8b965b7e7a8b87b4da86b9008a/" rel="bookmark">
			gradle升级到高版本找不到AndroidManifest路径问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错如下
property(interface org.gradle.api.file.Directory, fixed(class org.gradle.api.internal.file.DefaultFilePropertyFactory$FixedDirectory, /Users/wk/Documents/AndroidStudio/project/app/build/intermediates/merged_manifests/baiduDebug))/AndroidManifest.xml (No such file or directory)
原路径写法： def manifestPath = "${manifestOutputDirectory}/AndroidManifest.xml"//高版本gradle找不到路径 新路径写法： String manifestPath = variant.outputs[0].getProcessResourcesProvider().get().manifestFile 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61e3c7bc9afd39d4385d39e17b1ba0b4/" rel="bookmark">
			三、数据库的数据类型详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据类型对于数据库的性能是有一定的影响的，如果一个数值采用的不恰当的数据类型，那么将会导致数据库性能下降。这里先提到一点，我也是刚学，后面具体在分解其中缘由。
Mysql支持SQL的所有类型，分为数值类型，字符串类型，还有日期类型及其他类型。我们先来看看数值类型。数值类型和我们写代码中常用的int，long，float，double差不多。int分了多种类型，其中数值正是根据有无符号来决定的。
比如TINYINT的无符号取值范围就是，2的七次方减1，无符号就是2的8次方减1。
在计算机上有符号类型的，存在正0和负0的表示，如8位的int 第一位为符号位，负零=10000000，正零为00000000，为了约定，在超过01111111，溢出时就会变成负零，所以为了不浪费这种表示，特地约定负0表示一个2的七次方的一个负数。其他16位，24位和32位的道理是一样的。
类型
解释大小范围（有符号）无符号用途TINYINT最小的int类型1字节，8位（-128,127）（0,255）小整数类型SMALLINT比较小的int类型2字节，16位（-32768,32767）（0,65535）略小的int类型数值MEDIUMINT较小的int类型3字节，24位(-8 388 608，8 388 607)（0，16 777 215)较小的int类型INT或INTEGER一般的int类型4字节，32位（-2 147 483 648，2 147 483 647）(0，4 294 967 295)一般的int类型BIGINT长整数型8字节，64位(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)(0，18 446 744 073 709 551 615)长整数FLOAT浮点数4字节，32位纠结浮点数的大小意义不大纠结浮点数的大小意义不大单精度DOUBLE双精度浮点8字节，64位纠结浮点数的大小意义不大纠结浮点数的大小意义不大双精度DECIMAL小数值对DECIMAL(M,D) M&gt;D，为M+2一般的D是不允许大于M的，不同的mysql版本会有所不同，但总之依赖于M和D的大小依赖于M和D的值小数值 这里除了几个int类型我们不太常见以外，还有就是DECIMAL。这是一个专门用来表示小数的特定类型。
一般定义时需要指定M和D。此类型是在MySql5.1的版本中开始引入。M表示这个小数一共可以存储多少个位，包含小数部分。D表示小数部分的位数，是十进制的位数。
如DECIMAL(2,1) 代表就是一个最大值是10，小数部分只有一位的小数，那这个数的最大值就是9.9。NUMERIC与DECIMAL同以，一般会默认转成decimal。通常用来表示货币，此类型要比float和double更为精准。超过存储范围会报错！
M是最大位数（精度），范围是1到65。可不指定，默认值是10。D是小数点右边的位数（小数位）。范围是0到30，并且不能大于M，可不指定，默认值是0。 字符类型：
类型解释大小用途CHAR一般短的字符0-255 bytes定长字符串VARCHAR一般的较长的字符0-65535 bytes变长字符串TINYBLOB较小的BOLB字符0-255 bytes不超过 255 个字符的二进制字符串TINYTEXT较小的文本类型0-255 bytes短文本字符串BLOB一般的BLOB0-65 535 bytes二进制形式的长文本数据TEXT文本类型0-65 535 bytes长文本数据MEDIUMBLOB中等的BLOB0-16 777 215 bytes二进制形式的中等长度文本数据MEDIUMTEXT中等长度的TEXT0-16 777 215 bytes中等长度文本数据LONGBLOB超长B,LOB0-4 294 967 295 bytes二进制形式的极大文本数据LONGTEXT超长TEXT0-4 294 967 295 bytes极大文本数据 文本类型可以分为三类，char，text，BOLB。char和varchar在有些数据库引擎上区别比较大，在mysql的InnoDB中我们一般都采用varchar。两者的区别是，char是固定长度，会造成空间浪费，但是检索速度会比较快，对尾部空格的处理会丢失。现在varchar的优化效率也不错，在InnoDB的数据库引擎中，一般都采用varchar代替char。
TEXT主要用来存储长文本数据，如一大段的商品描述，比较长的公告等等。其最大长度是65535BIT，也就是接近0.06M的存储空间了。
1KB=1024B；1MB=1024KB=1024×1024B。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61e3c7bc9afd39d4385d39e17b1ba0b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/693e302b4d5a14326ff6d941ecd076e8/" rel="bookmark">
			MySQL LEFT 字符截取需要注意的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天在数据导出给业务方的时候，业务方一直提示我导出的某一个字段长度超过他们规定的长度
执行SQL语句如下：
update middle_data_content set `description` = LEFT(`description`,1000) 然后会发现：（具体字段LENGTH长度还是会有大于1000的情况）
SELECT LENGTH(`description`) FROM middle_data_content WHERE LENGTH(`description`)&gt;1000 后面百思不得其解，最后用验证的方法来排查问题：
先恢复之前修改过的数据，恢复之前最好先对你要修改的表或库做备份UPDATE current.middle_data_content A, bak.middle_data_content_bak B SET A.description = B.description WHERE A.contentId = B.contentId 此处 current 和 bak 都表示具体数据库名称，可选
然后对其字段做小规模截取UPDATE middle_data_content set `description` = LEFT(`description`,100) 再查看最大的其字段长度SELECT max(LENGTH(`description`)) FROM middle_data_content 结果显示max(LENGTH(`description`)) 300 猜想：
LEFT(description,100) 是截取100个汉字或其他字符串数据
LENGTH(description) 是表示varchar 长度，1个汉字占数据库中3个varchar 字节
论证：
SELECT LEFT("一二三四五六七八九十", 5); 结果：一二三四五 SELECT LENGTH("一二三四五"); 结果：15 官方说明： https://dev.mysql.com/doc/refman/8.0/en/string-functions.html
函数名称描述LEFT()返回指定的最左边的字符数LENGTH()返回字符串的长度（以字节为单位） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43379e08673bffb69805f9c485d1bd4b/" rel="bookmark">
			高通QPST备份QCN及恢复流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：首先打开qpst software download 界面，选择backup选项连接手机进行备份，进度条走完后点击Exit完成备份
二：qcn还原流程，选择restore 连接手机进行还原，待进度条走完后点击Exit后手机会自动重启，此为完整流程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17f57f01a5ba5e3eaa1cc75cadac96f0/" rel="bookmark">
			Golang中的struct比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 可排序、可比较和不可比较 可排序的数据类型有三种 整型Integer浮点型Floating-point字符串String可比较的数据类型除了上述三种外，还有Boolean，Complex，Pointer，Channel，Interface和Array不可比较的数据类型包括，Slice, Map, 和Function 2. 同一个struct的2个实例比较 包含不可比较的成员变量（map，slice，func等） ==操作符可以比较指针，不能直接比较实例；不包含不可比较的成员变量 ==操作符可以比较指针和实例；reflect.DeepEqual函数，指针和实例均可以比较（无论有没有包含不可比较的成员变量） package main import ( "fmt" "reflect" ) type T1 struct { Name string Age int Arr [2]bool ptr *int slice []int map1 map[string]string } func main() { t1 := T1{ Name: "yxc", Age: 1, Arr: [2]bool{true, false}, ptr: new(int), slice: []int{1, 2, 3}, map1: make(map[string]string, 0), } t2 := T1{ Name: "yxc", Age: 1, Arr: [2]bool{true, false}, ptr: new(int), slice: []int{1, 2, 3}, map1: make(map[string]string, 0), } // 报错 实例不能比较 Invalid operation: t1 == t2 (operator == not defined on T1) // fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17f57f01a5ba5e3eaa1cc75cadac96f0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/368/">«</a>
	<span class="pagination__item pagination__item--current">369/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/370/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>