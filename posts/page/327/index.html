<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f73389c85b895b4e0e0245e4688fce16/" rel="bookmark">
			oauth2.0与单点登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是 OAuth2.0 OAuth （Open Authority的缩写）是一个开放标准，该标准允许用户让第三方应用访问该用户在某一网站上存储的私密资源（如头像、照片、视频等），而在这个过程中无需将用户名和密码提供给第三方应用。实现这一功能是通过提供一个令牌（token），而不是用户名和密码来访问他们存放在特定服务提供者的数据。采用令牌（token）的方式可以让用户灵活的对第三方应用授权或者收回权限。
OAuth2.0 是 OAuth 协议的下一版本，但不向下兼容 OAuth 1.0。传统的 Web 开发登录认证一般都是基于 session 的，但是在前后端分离的架构中继续使用 session 就会有许多不便，因为移动端（Android、iOS、微信小程序等）要么不支持 cookie（微信小程序），要么使用非常不便，对于这些问题，使用 OAuth2 认证都能解决。
对于大家而言，我们在互联网应用中最常见的 OAuth2 应该就是各种第三方登录了，例如 QQ 授权登录、微信授权登录、微博授权登录、GitHub 授权登录等等。
1.1、Auth2协议中，共有四个参与方(角色)： 1.resource owner：资源拥有者，即用户。2.resource server：资源服务器。即存储用户数据的服务器，一般对外都以RESTFul API的形式暴露用户数据，client使用access token访问resource server申请被保护起来的用户数据。3.client：客户端。即第三方应用。4.authorization server：授权服务器。用来鉴权第三方应用合法性，并对用户登录、是否授权第三方应用获取数据进行响应，并根据用户操作，向第三应用颁发code 或 用户token或者告知授权失败。 2、什么是单点登录？ 单点登录的英文名是 Single Sign On，因此一般简称为SSO。它的用途在于，不管多么复杂的应用群，只要在用户权限范围内，那么就可以做到，用户只需要登录一次就可以访问权限范围内的所有应用子系统。对于用户而言，访问多个应用子系统只需要登录一次，同样在需要注销的时候也只需要注销一次。举个简单的例子，你在百度首页登录成功之后，你再访问百度百科、百度知道、百度贴吧等网站也会处于登录状态了，这就是一个单点登录的真实案例。
重要的是理解：
SSO服务端和SSO客户端直接是通过授权以后发放Token的形式来访问受保护的资源；相对于浏览器来说，业务系统是服务端，相对于SSO服务端来说，业务系统是客户端；浏览器和业务系统之间通过会话正常访问；不是每次浏览器请求都要去SSO服务端去验证，只要浏览器和它所访问的服务端的会话有效它就可以正常访问。 2.2. OAuth2
3、OAuth2.0授权与单点登录的区别 根据OAuth2.0授权与单点登录的概念，我们可以得知二者至少存在以下几点区别：
从信任角度来看。OAuth2.0授权服务端和第三方客户端不属于一个互相信任的应用群（通常都不是同一个公司提供的服务），第三方客户端的用户不属于OAuth2.0授权服务端的官方用户；而单点登录的服务端和接入的客户端都在一个互相信任的应用群（通常是同一个公司提供的服务），各个子系统的用户属于单点登录服务端的官方用户。从资源角度来看。OAuth2.0授权主要是让用户自行决定——“我”在OAuth2.0服务提供方的个人资源是否允许第三方应用访问；而单点登录的资源都在客户端这边，单点登录的服务端主要用于登录，以及管理用户在各个子系统的权限信息。从流程角度来看。OAuth2.0授权的时候，第三方客户端需要拿预先“商量”好的密码去获取Access Token；而单点登录则不需要。 4、OAuth2 协议一共支持 4 种不同的授权模式： 授权码模式：常见的第三方平台登录功能基本都是使用这种模式。
简化模式：简化模式是不需要客户端服务器参与，直接在浏览器中向授权服务器申请令牌（token），一般如果网站是纯静态页面则可以采用这种方式。
密码模式：密码模式是用户把用户名密码直接告诉客户端，客户端使用说这些信息向授权服务器申请令牌（token）。这需要用户对客户端高度信任，例如客户端应用和服务提供商就是同一家公司，我们自己做前后端分离登录就可以采用这种模式。
客户端模式：客户端模式是指客户端使用自己的名义而不是用户的名义向服务提供者申请授权，严格来说，客户端模式并不能算作 OAuth 协议要解决的问题的一种解决方案，但是，对于开发者而言，在一些前后端分离应用或者为移动端提供的认证授权服务器上使用这种模式还是非常方便的。
4.1、授权码模式 授权码模式是最安全并且使用最广泛的一种模式。以www.javaboy.org 为例，假如我要引入微信登录功能，那么我的流程可能是这样：
在授权码模式中，我们分授权服务器和资源服务器，授权服务器用来派发 Token，拿着 Token 则可以去资源服务器获取资源，这两个服务器可以分开，也可以合并。
上面这张流程图的含义，具体是这样：
首先，我会在我的 www.javaboy.org 这个网页上放一个超链接（我的网站相当于是第三方应用），用户 A （服务方的用户，例如微信用户）点击这个超链接就会去请求授权服务器（微信的授权服务器），用户点击的过程其实也就是我跟用户要授权的过程，这就是上图中的 1、2 步。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f73389c85b895b4e0e0245e4688fce16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdf48e78d7d691f5c14ee44f1007cd8b/" rel="bookmark">
			mysql alter decimal_MySQL数据类型DECIMAL用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL DECIMAL数据类型用于在数据库中存储精确的数值。我们经常将DECIMAL数据类型用于保留准确精确度的列，例如会计系统中的货币数据。
要定义数据类型为DECIMAL的列，请使用以下语法：
column_name DECIMAL(P,D);
在上面的语法中：
P是表示有效数字数的精度。 P范围为1〜65。
D是表示小数点后的位数。 D的范围是0~30。MySQL要求D小于或等于(&lt;=)P。
DECIMAL(P，D)表示列可以存储D位小数的P位数。十进制列的实际范围取决于精度和刻度。
与INT数据类型一样，DECIMAL类型也具有UNSIGNED和ZEROFILL属性。 如果使用UNSIGNED属性，则DECIMAL UNSIGNED的列将不接受负值。
如果使用ZEROFILL，MySQL将把显示值填充到0以显示由列定义指定的宽度。 另外，如果我们对DECIMAL列使用ZERO FILL，MySQL将自动将UNSIGNED属性添加到列。
以下示例使用DECIMAL数据类型定义的一个叫作amount的列。
amount DECIMAL(6,2);
在此示例中，amount列最多可以存储6位数字，小数位数为2位; 因此，amount列的范围是从-9999.99到9999.99。
MySQL允许使用以下语法：
column_name DECIMAL(P);
这相当于：
column_name DECIMAL(P,0);
在这种情况下，列不包含小数部分或小数点。
此外，我们甚至可以使用以下语法。
column_name DECIMAL;
在这种情况下，P的默认值为10。
MySQL DECIMAL存储
MySQL分别为整数和小数部分分配存储空间。 MySQL使用二进制格式存储DECIMAL值。它将9位数字包装成4个字节。
对于每个部分，需要4个字节来存储9位数的每个倍数。剩余数字所需的存储如下表所示：
剩余数字
位
0
0
1–2
1
3–4
2
5–6
3
7-9
4
例如，DECIMAL(19,9)对于小数部分具有9位数字，对于整数部分具有(19位-9位) = 10位数字，小数部分需要4个字节。 整数部分对于前9位数字需要4个字节，1个剩余字节需要1个字节。DECIMAL(19,9)列总共需要9个字节。
MySQL DECIMAL数据类型和货币数据
经常使用DECIMAL数据类型的货币数据，如价格，工资，账户余额等。如果要设计一个处理货币数据的数据库，则可参考以下语法：
amount DECIMAL(19,2);
但是，如果您要遵守公认会计原则(GAAP)规则，则货币栏必须至少包含4位小数，以确保舍入值不超过$0.01。 在这种情况下，应该定义具有4位小数的列，如下所示：
amount DECIMAL(19,4);
MySQL DECIMAL数据类型示例
首先，创建一个名为test_order的新表，其中包含三列：id，description和cost。
CREATE TABLE test_order (
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdf48e78d7d691f5c14ee44f1007cd8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3727f2a7f1fd8df06edca18aecd7d3e4/" rel="bookmark">
			java beetl 视频_04.Beetl常用内置函数以及安全输出---《Beetl视频课程》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期视频实现了三个功能，模糊搜索、标签分类、登录/注销功能；
内容简介：使用了常用内置函数，以及安全输出，实现了上面提到的三个业务
作者：GK
常用内置方法
date 返回一个java.util.Date类型的变量，如 date() 返回一个当前时间(对应java的java.util.Date); ${date( "2011-1-1" , "yyyy-MM-dd" )} 返回指定日期
print 打印一个对象 print(user.name);
println 打印一个对象以及回车换行符号，回车换号符号使用的是模板本身的，而不是本地系统的.如果仅仅打印一个换行符，则直接调用println() 即可
printFile 直接答应文件，文件路径以模板根目录为相对目录，printFile(‘‘/common/header.html’’);
nvl 函数nvl，如果对象为null，则返回第二个参数，否则，返回自己 nvl(user,"不存在")
isEmpty 判断变量或者表达式是否为空，变量不存在，变量为null，变量是空字符串，变量是空集合，变量是空数组，此函数都将返回true
isNotEmpty 同上，判断对象是否不为空
has 变量名为参数，判断是否存在此全局变量，如 has(userList),类似于1.x版本的exist("userList"),但不需要输入引号了
assert 如果表达式为false，则抛出异常
trim 截取数字或者日期，返回字符,如trim(12.456,2)返回"12.45",trim(date,'yyyy')返回"2017"
trunc 截取数字，保留指定的小数位，如trunc(12.456,2) 输出是12.45.不推荐使用，因为处理float有问题，兼容原因保留了
decode 一个简化的if else 结构，如 ${decode(a,1,"a=1",2,"a=2","不知道了")},如果a是1，这decode输出"a=1",如果a是2，则输出"a==2", 如果是其他值，则输出"不知道了"
debug 在控制台输出debug指定的对象以及所在模板文件以及模板中的行数，如debug(1),则输出1 [在3行@/org/beetl/core/lab/hello.txt],也可以输出多个，如debug("hi",a),则输出hi,a=123,[在3行@/org/beetl/core/lab/hello.txt]
parseInt 将数字或者字符解析为整形 如 parseInt("123");
parseLong 将数字或者字符解析为长整形，parseInt(123.12);
parseDouble 将数字或者字符解析为浮点类型 如parseDouble("1.23")
range 接收三个参数，初始值，结束值，还有步增(可以不需要，则默认为1)，返回一个Iterator，常用于循环中，如for(var i in range(1,5)) {print(i)},将依次打印1234.
flush 强制io输出。
json，将对象转成json字符串，如 var data = json(userList) 可以跟一个序列化规则 如,var data = json(userList,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3727f2a7f1fd8df06edca18aecd7d3e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb8efbf9d14f47cdb4f2d6e57b56424c/" rel="bookmark">
			谷歌浏览器查看token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在页面完成登录之后，按F12调出开发者工具。可以取到token！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd56319de1aac91845a53378c46d3ff6/" rel="bookmark">
			linux 应用层gpio中断_linux 应用层使用gpio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/**
* @author emlsyx
* @email yangx_1118@163.com
* @create date 2020-02-19 19:11:53
* @modify date 2020-02-19 19:11:53
* @desc [description]*/#include#include#include#include#include#include
#define err_out(fmt, ...) \
do\
{ \
printf(fmt, ##__VA_ARGS__); \
printf(" \"%s()\" %d error\n", __FILE__, __FUNCTION__, __LINE__); \
}while (0)#define open_gpio_file(path, flag, fd) \
do\
{ \
fd=open(path, flag); \if (fd &lt; 0) \
{ \
err_out("\"%s\" open failed \n", path); \return (-1); \
} \
}while (0);/**
* @brief : gpio 导出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd56319de1aac91845a53378c46d3ff6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edbb58c367767b12508b9f2094193b4b/" rel="bookmark">
			Quartz定时任务管理（动态添加、停止、恢复、删除定时任务）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Quartz定时任务框架经常用于系统后台业务异步处理。平常我们使用时，主要是通过手工编写配置代码文件方式添加修改定时任务，然后重启系统。有时候我们需要根据业务运营需要，动态添加修改定时任务，比如添加新的定时任务、修改任务执行时间、暂停定时任务、删除定时任务等，并且监控定时任务状态，而又不想重启系统，这时就需要系统具备动态管理定时任务的功能。
Quartz提供了一系列组件，支持动态管理定时任务的功能。
Quartz定时任务主要由Scheduler、JobDetail、CronTrigger、Cron组成，实现动态管理定时任务，主要就是通过管理上述对象来实现的。
1、数据库设计
主要将我们平时配置的任务计划放入数据库中保存。在启动任务是，从数据库中查找任务计划信息，并动态配置进去即可。
DROP TABLE IF EXISTS `cc_task_info`; CREATE TABLE `cc_task_info` ( `TID` int(11) NOT NULL AUTO_INCREMENT, `TASK_ANME` varchar(50) NOT NULL, `TASK_CODE` varchar(50) NOT NULL, `JOB_CLASS` varchar(200) NOT NULL, `JOB_GROUP` varchar(50) NOT NULL, `CRON` varchar(50) NOT NULL, `DEL_STATUS` varchar(2) DEFAULT '1' NULL, `CRT_TIME` datetime DEFAULT NULL, PRIMARY KEY (`TID`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='定时任务管理表'; DROP TABLE IF EXISTS `cc_task_record`; CREATE TABLE `cc_task_record` ( `RID` int(11) NOT NULL AUTO_INCREMENT, `TASK_CODE` varchar(50) NOT NULL, `RUN_TIME` datetime NOT NULL, `RUN_CODE` char(1) NOT NULL, `RUN_MSG` varchar(100) NULL, PRIMARY KEY (`RID`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='定时任务运行记录表'; DROP TABLE IF EXISTS `cc_task_status`; CREATE TABLE `cc_task_status` ( `TASK_CODE` varchar(50) NOT NULL, `TASK_STATUS` varchar(10) NOT NULL, `LST_SUCC_TIME` datetime NOT NULL, `LST_TIME` datetime NOT NULL, PRIMARY KEY (`TASK_CODE`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='定时任务运行状态表'; 2、定时任务管理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edbb58c367767b12508b9f2094193b4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eebe11ac761d451e12d6b4a3dbb02c49/" rel="bookmark">
			精心整理了40个Python办公自动化真实案例，一口一个，高效办公！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01
导读
大家好，我是早起。
自从去年4月发布第一篇Python办公自动化系列文章以来，目前已经马不停蹄的更新了近四十个真实办公场景案例，全网累计阅读超20W+，内容涵盖Python操作Word、Excel、PPT、PDF、邮箱及一些常用办公操作。
下面我将全部案例再次进行整理分类汇总，方便大家更好的阅读与学习！
02
自动化基础知识
首先，想要玩好Python办公自动化，基础知识要扎实，下面几篇文章分别从原理讲起，到代码示例，辅以大量图表，对自动化办公中的常用操作进行介绍，点击下方图片可以直达对应文章！
03
Word/Excel单独案例
在了解上面的常用操作后，就可以基于这些操作实现办公自动化，Word和Excel作为工作中最常用的软件，实现自动化可以节省很多时间。
下面给出了一些Python操作Excel或Word的真实案例，点击图片可以直达对应文章学习！
04
Word+Excel综合案例
上面给的是Python单独操作Excel或者Word的案例，而Word与Excel联合使用的场景更多，下面就是一些综合案例，点击图片可以直达文章，希望能对大家有所启发！
05
PPT/PDF案例
除了Word与Excel，PPT和PDF也是日常办公中经常接触的文件格式，下面给出了一些基于PPT与PDF的自动化案例，点击对应图片可以直达学习！
06
邮件自动化案例
操作邮件也是办公场景中常见的需求，下面是一些Python管理邮箱的部分案例，从基础讲解到实战都有，点击图片可以查看对应文章！
07
其他自动化案例
最后，除了Office三件套和PDF、邮箱之外，还有一些办公中常用的操作可以通过使用os和glob等模块实现，以下是一些有趣实用的案例，点击图片可以直达对应文章！
04
写在最后
以上就是这大半年来，早起写过的全部Python办公自动化案例，希望能对感兴趣的读者有所启发，你可以在后台回复「自动化」获取部分源码与数据自己操作一遍。
最后早起想说的是，上面的案例很难拿走就用到你的办公场景中，所以需要你在「阅读的同时去思考哪部分是你可以使用的，哪些方法是你可以参考的，将多个案例中的核心思路去抽象出来，并结合自己的问题方能实现属于你的Python办公自动化」
当然如果你有亟待解决的重复工作需求，或者遇到无法处理的Python办公自动化问题，或希望得到一对一的指导，都可以留言或后台回复「自动化」获得微信添加交流。
求点赞、在看、转发????！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56ae3fc062dddcff3ef1d4232f784064/" rel="bookmark">
			kettle查询mysql获取uuid_Kettle 使用JS脚本 增加UUID输出列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		####JavaScript 脚本如下####################################################
//Script here
//Script here
function UUID(){
this.id = this.createUUID();
}
UUID.prototype.valueOf = function(){ return this.id; }
UUID.prototype.toString = function(){ return this.id; }
UUID.prototype.createUUID = function(){
var dg = new Date(1582, 10, 15, 0, 0, 0, 0);
var dc = new Date();
var t = dc.getTime() - dg.getTime();
var h = '';
var tl = UUID.getIntegerBits(t,0,31);
var tm = UUID.getIntegerBits(t,32,47);
var thv = UUID.getIntegerBits(t,48,59) + '1';
var csar = UUID.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56ae3fc062dddcff3ef1d4232f784064/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ea1281c5cb68b90f3fb6cdef3ef159d/" rel="bookmark">
			java jsp filename filepath 图片上传_java读取图片处理实现缩放裁剪,用于个人信息中上传图片自定义头像大小...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.jspsmart.upload;
import java.io.ByteArrayInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.sql.ResultSet;
import java.sql.SQLException;
import javax.servlet.ServletException;
public class File
{
private SmartUpload m_parent;
private int m_startData;
private int m_endData;
private int m_size;
private String m_fieldname;
private String m_filename;
private String m_fileExt;
private String m_filePathName;
private String m_contentType;
private String m_contentDisp;
private String m_typeMime;
private String m_subTypeMime;
private String m_contentString;
private boolean m_isMissing;
public static final int SAVEAS_AUTO = 0;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ea1281c5cb68b90f3fb6cdef3ef159d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ab8873802387b7efc865c4011441783/" rel="bookmark">
			51单片机学习——9--温度传感器DS18B20
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		温度传感器 DS18B20简介特点实物图原理图内部结构(1) 64位(激)光刻只读存储器(2) DS18B20温度转换规则(3) DS18B20温度传感器的存储器(4) 配置寄存器 ROM指令RAM指令 编程原理DS18B20初始化DS18B20读时序DS18B20写时序大致过程 代码实现 DS18B20 简介 DS18B20数字温度传感器接线方便，封装后可应用于多种场合，如管道式，螺纹式，磁铁吸附式，不锈钢封装式。主要根据应用场合的不同而改变其外观。封装后的DS18B20可用于电缆沟测温，高炉水循环测温，锅炉测温，机房测温，农业大棚测温，洁净室测温，弹药库测温等各种非极限温度场合。耐磨耐碰，体积小，使用方便，封装形式多样，适用于各种狭小空间设备数字测温和控制领域。
特点 1、适应电压范围更宽，电压范围：3.0～5.5V，在寄生电源方式下可由数据线供电
2、独特的单线接口方式，DS18B20在与微处理器连接时仅需要一条口线即可实现微
处理器与DS18B20的双向通讯。
3、DS18B20支持多点组网功能，多个DS18B20可以并联在唯一的三线上，实现组网
多点测温。
4、DS18B20在使用中不需要任何外围元件，全部传感元件及转换电路集成在形如一
只三极管的集成电路内。
5、温范围－55℃～+125℃，在-10～+85℃时精度为±0.5℃
6、可编程的分辨率为9～12位，对应的可分辨温度分别为0.5℃、0.25℃、0.125℃
和0.0625℃，可实现高精度测温。
7、在9位分辨率时最多在93.75ms内把温度转换为数字，12位分辨率时最多在750ms
内把温度值转换为数字，速度更快。
8、测量结果直接输出数字温度信号，以"一根总线"串行传送给CPU，同时可传送
CRC校验码，具有极强的抗干扰纠错能力。
9、负压特性：电源极性接反时，芯片不会因发热而烧毁， 但不能正常工作。
实物图 原理图 内部结构 (1) 64位(激)光刻只读存储器 光刻ROM中的64位序列号是出厂前被光刻好的，它可以看作是该DS18B20的地址序列号。64位光刻ROM的排列是：开始8位（28H）是产品类型标号，接着的48位是该DS18B20自身的序列号，最后8位是前面56位的循环冗余校验码。光刻ROM的作用是使每一个DS18B20都各不相同，这样就可以实现一根总线上挂接多个DS18B20的目的。 (2) DS18B20温度转换规则 DS18B20的核心功能是它可以直接读出数字的温度数值。温度传感器的精度为用户可编程的9，10，11或12位，分别以0.5℃，0.25℃，0.125℃和0.0625℃增量递增。在上电状态下默认的精度为12位。 DS18B20启动后保持低功耗等待状态,当需要执行温度测量和AD转换时，总线控制器必须发出[44h]命令。转换完以后，产生的温度数据以两个字节的形式被存储到高速暂存器的温度寄存器中，DS18B20继续保持等待状态。
这是12位转化后得到的12位数据，存储在DS18B20的两个8位的RAM中，高字节的前5位是符号位，如果测得的温度大于0，这5位为‘0’，只要将测到的数值乘以0.0625即可得到实际温度；如果温度小于0，这5位为‘1’，测到的数值需要先减1再取反再乘以0.0625即可得到实际温度。
(3) DS18B20温度传感器的存储器 DS18B20温度传感器的内部存储器包括一个高度的暂存器RAM和一个非易失性的可电擦除的EEPROM,后者存放高温度和低温度触发器TH、TL和结构寄存器。
(4) 配置寄存器 存储器的第4位为配置寄存器，其组织见图8，用户可按表3所示设置R0和R1位来设定DS18B20的精度。上电默认设置：R0=1、R1=1(12位精度)。注意：精度和转换时间之间有直接的关系。暂存器的位7和位0-4被器件保留，禁止写入。
ROM指令 RAM指令 编程原理 DS18B20初始化 (1).数据线拉到低电平“0”。
(2).延时480微妙（该时间的时间范围可以从480到960微妙）。
(3).数据线拉到高电平“1”。
(4).延时等待80微妙。如果初始化成功则在15到60微妙时间内产生一个由DS18B20所返回的低电平“0”.根据该状态可以来确定它的存在，但是应注意不能无限的进行等待，不然会使程序进入死循环，所以要进行超时判断。
(5).若CPU读到了数据线上的低电平“0”后，还要做延时，其延时的时间从发出的高电平算起（第（3）步的时间算起）最少要480微妙。
DS18B20读时序 (1).将数据线拉低“0”。
(2).延时1微妙。
(3).将数据线拉高“1”,释放总线准备读数据。
(4).延时10微妙。
(5).读数据线的状态得到1个状态位，并进行数据处理。
(6).延时45微妙。
(7).重复1～7步骤，直到读完一个字节。
DS18B20写时序 (1).数据线先置低电平“0”
(2).延时15微妙。
(3).按从低位到高位的顺序发送数据(一次只发送一位)。
(4).延时60微妙。
(5).将数据线拉到高电平。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ab8873802387b7efc865c4011441783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c155ce2131026e3daae0ff8c5204d129/" rel="bookmark">
			java中如何数组转set_如何将数组转换为Set
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本节中，我们将向展示如何将字符串数组转换为Set。可以通过以下方法使用实现：
For-each循环
Arrays.asList()方法(array⇒list⇒set)
Collections.addAll()方法
文件：ArrayToSetExample.java -
package com.yiibai.tutorial;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
/**
* @author yiibai
*
*/
public class ArrayToSetExample {
public static void main(String[] args) {
/* Array to be converted */
String[] numbers=new String[]{"One""Two""Three""One""Six"};
/* Method - 1 */
Set numberList1=new HashSet&lt;&gt;();
for (String integer : numbers) {
numberList1.add(integer);
}
System.out.println("Number List1="+numberList1);
/* Method - 2 */
Set numberList2=new HashSet&lt;&gt;(Arrays.asList(numbers));
System.out.println("Number List2="+numberList2);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c155ce2131026e3daae0ff8c5204d129/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a20f06aa1742bfc608098477b241b63/" rel="bookmark">
			java设计模式--01类图UML图箭头含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		泛化：
表示一个更泛化的元素和一个更具体的元素的关系表现方式主要是继承表示方式：用实线空心箭头表示 实现
类和接口之间的关系表示方式：用虚线空心三角形箭头表示，实现类指向接口。
依赖是一种使用的关系，即一个类的实现需要另一个类的协助。方法参数需要传入另一个类的对象，就表示依赖这个类。表示方式：虚线箭头。
聚合整体个部分的关系，整体和部分可以分开例如：电脑和鼠标表示方式：尾部为空心菱形的实线箭头（也可以没箭头）。 组合
整体个部分的关系，整体和部分不可以分开.
人和头的关系，少一个就不行
尾部为实心菱形的实现箭头（也可以没箭头）
依赖
类中用到了对方就是依赖
表示方式 ：虚线箭头
关联：
依赖关系的一种特例，双向关系和单向关系表示方式一条直线 小结
. 类（Class）：使用三层矩形框表示。 第一层显示类的名称，如果是抽象类，则就用斜体显示。 第二层是字段和属性。 第三层是类的方法。 注意前面的符号，‘+’表示public，‘-’表示private，‘#’表示protected。
接口：使用两层矩形框表示，与类图的区别主要是顶端有&lt;&gt;显示 。 第一行是接口名称。 第二行是接口方法。
继承类（extends） ：用空心三角形+实线来表示。
实现接口（implements） ：用空心三角形+虚线来表示
关联（Association） ：用实线箭头来表示，例如：燕子与气候
聚合（Aggregation） ：用空心的菱形+实线箭头来表示 聚合：表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分，例如： 公司和员工
组合（Composition）：用实心的菱形+实线箭头来表示 组合：部分和整体的关系，并且生命周期是相同的。例如：人与头
依赖（Dependency） ：用虚线箭头来表示，例如：动物与氧气
类之间的关系 UML把类之间的关系分为以下5种.
- 关联：类A与类B的实例之间存在特定的对应关系
- 依赖：类A访问类B提供的服务
- 聚集：类A为整体类，类B为局部类，类A的对象由类B的对象组合而成
- 泛化：类A继承类B
- 实现：类A实现了B接口 关联（Association）
关联指的是类之间的特定对应关系，在UML中用带实线的箭头表示。按照类之间的数量对比，关联 可以分为以下三种：
一对一关联一对多关联多对多关联注意：关联还要以分为单向关联和双向关联 泛化（Generalization）泛化指的是类之间的继承关系，在UML中用带实线的三角形箭头表示。
实现（Realization） 实现指的是类与接口之间的关系，在UML中用带虚线的三角形箭头表示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a56bc34a96b01e7534f5b63eb5f2470e/" rel="bookmark">
			selenium翻页获取京东图书名称和价格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		selenium翻页获取京东图书名称和价格 案例目的： 通过selenium翻页爬取京东图书名称和价格，介绍如何通过selenium模拟鼠标滑轮，点击，翻页等操作。
案例功能： 输入要爬取的页数，批量下载每一页数图书的名称和价格，并保存到本地。
案例分析： 1.找到目标页面的url（我们以中国当代小说为例） 2.通过模拟滚轮实现异步加载： 注：每一页共有60本书，但是：如果没有手动通过滑轮获取剩下的30个数据，通过xpath页只能获取30个，这就是我们为什么要模拟鼠标滑轮的原因。
当我们把滑轮滑倒最底部，就会得到加载剩余的30个数据： 当然，价格也是同理。
名称和价格的xpath，以及鼠标滑轮已经介绍完毕。
3.接下来就是通过selenuim进行翻页。 selenium翻页原理：通过定位下一页的标签，然后模拟点击操作，实现翻页。如下图：
这里说一下注意事项： 1.selenuim模拟浏览器时可能会因为网络的问题，加载时间延长。因此，爬取每一页数据都要设置延时操作，延时时间根据自己的网速设置。
2.在实现滑轮滑动时，scrollTop后面对应的参数是滑轮所在的位置，如果scrollTop=0就代表在最上方，我是通过调试，得到5000比较合适。
3.在selenium中使用find_element_by_xpath进行定位时，只是定义节点，而不是文本和属性。
4.关于数据保存的细节我就不多说了，我的前几篇文章介绍的都有，大家可以做参考。
分析完毕，开始上代码： from selenium.webdriver import Chrome import time from lxml import etree import json if __name__ == '__main__': # 输入要去的页数 pages = int(input('请输入要爬取的页数：')) # 创建浏览器 chrome = Chrome() # 在网址栏输入url chrome.get('https://list.jd.com/list.html?cat=1713,3258,3297') # 创建循环 for i in range(pages): # 页面等待 time.sleep(10) # 通过滑轮进行异步加载 js_ = 'document.documentElement.scrollTop=5000' chrome.execute_script(js_) time.sleep(2) # 获取页面数据 html_data = chrome.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a56bc34a96b01e7534f5b63eb5f2470e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6823caa32b2f19a4cb26cea60315fa20/" rel="bookmark">
			java.lang.NoSuchFieldError报错解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java.lang.NoSuchFieldError报错解决方案
参考文章：
（1）java.lang.NoSuchFieldError报错解决方案
（2）https://www.cnblogs.com/wwwcf1982603555/p/9138247.html
备忘一下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d626b9cc2820568c4b8505db3bcab44/" rel="bookmark">
			浅谈数据加密策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、数据加密传输策略的设计二、密码的加密存储策略三、示例代码 浅谈之前，我们不妨先了解几个知识点：加密技术、哈希摘要。 加密技术 分为 对称加密 与 非对称加密 两类。
对称加密即加密密钥与解密密钥相同，形象的描述为，你有你家房门的钥匙，你既可以用它锁住房门，也可以用它打开房门。常见的算法有DES、AES。
而非对称加密则采用两把钥匙，公钥和私钥。使用公钥加密的信息只能通过私钥解密，反之，使用私钥加密的信息也只能通过公钥解密。这分别对应两个过程：数据加密传输与数字签名。本文仅谈论数据的加密传输。常见的算法有RSA。
哈希摘要 即指通过散列函数为一段数据生成固定长度的摘要，而不论数据的大小。生成的摘要一般难以推导出原数据。常见的散列函数有MD5、SHA-1、SHA-2、SHA-3(Keccak)。
一、数据加密传输策略的设计 从加密技术中，我们可以得到两种简单的加密传输的方式：使用对称加密或使用非对称加密。其各有优劣。
对称加密非对称加密加密效率计算量小，加密效率高计算复杂，加密效率低密钥传输不宜明文传输，以免泄漏密钥造成数据泄漏可传输公钥，使用私钥解密以获得数据 因此，结合使用对称加密与非对称加密，接收方先用发送方的非对称加密的公钥加密自己的对称加密的密钥，发送方再用其私钥解密出对称加密的密钥，双方通过对称加密的密钥传输数据，才是更好的选择。这里我们以客户端（数据接收方）和服务端（数据发送方）为例：
服务端使用非对称加密生成公钥(publicKey)和私钥(privateKey)，客户端使用对称加密生成密钥(key)客户端获取publicKey，使用其加密key，得到key的密文(keyCiphertext)服务端使用privateKey解密keyCiphertext得到key服务端使用key加密数据(data)得到数据的密文(dataCiphertext)客户端获取dataCiphertext，使用key解密得到data 至此，就完成了数据发送方（服务端）向数据接收方（客户端）的加密数据传输
二、密码的加密存储策略 不论是应用程序亦或是网页，都可能涉及到用户的登录，其背后也必然牵扯到数据库对用户密码的存储与验证。直接存储密码确实简单易行，但若发生数据泄漏则将可能产生严重后果，因此用户密码的存储也应当加密。
结合哈希摘要，我们不难想到一种方法：
将用户密码通过哈希函数加密生成摘要，并存储用户登录时，对输入的密码使用相同的哈希函数加密生成摘要对比两次摘要，即可验证密码 但实际上，若用户密码设计的简单（如个人生日等），很容易通过反查询（即先对多个数据一 一对应的生成摘要，再依次对比摘要以确定原数据）的方式破解用户密码。因此，加盐值（salt值）的概念应运而生。所谓加盐值，指的是一串随机生成的数据，将其以任意方式添加到原来的数据中，以提升数据复杂度的一种方法，就像是往一杯干净的水加粗盐而变得浑浊一样。因此，新的密码加密存储方式我们可以这样设计：
随机生成一串字符串（即盐值），将其以任意方式添加到用户密码中，生成摘要，同时存储摘要和盐值用户登录时，取出盐值，将其以相同的方式添加到输入的密码中，生成摘要对比两次摘要，即可验证密码 三、示例代码 代码中所采用的对称加密算法为AES，采用的非对称加密算法为RSA。数据的发送方为服务器端Java程序，数据的接收方为Android应用，所采用的字节数据编码方式为Base64。
数据发送方
//-----------------AES------------------ private byte[] aesKeyBytes = null;// AES密钥字节数组形式 private Key aesKey = null;// AES密钥 /** * 获得使用Base64编码的未加密AES密钥字符串. * * @return AES密钥字符串形式 */ public String getAESKeyNoEncrypt() { return new String(Base64.getEncoder().encode(aesKeyBytes), StandardCharsets.UTF_8); } /** * 使用AES密钥加密数据. * * @param data 待加密的数据 * @return 加密后的密文，使用Base64编码 */ public String aesEncryptData(String data) { try { if (aesKey == null) { throw new NullPointerException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d626b9cc2820568c4b8505db3bcab44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81af3d279419e6775693949fd0fc8a34/" rel="bookmark">
			C#使用Microsoft Edge WebView2记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、C#和JS互相调用
1、js调用C#
C#代码如下：
webView.CoreWebView2.AddHostObjectToScript(“webBrowserObj”, new ScriptCallbackObject());
await webView.CoreWebView2.AddScriptToExecuteOnDocumentCreatedAsync(“var webBrowserObj= window.chrome.webview.hostObjects.webBrowserObj;”);
像网页里面注入变量，这样网页调用时候不用每次写window.chrome.webview.hostObjects.webBrowserObj调用，最主python基础教程要的是为了兼容之前cef里面Js的写法。
[ClassInterface(ClassInterfaceType.AutoDual)]
[ComVisible(true)]
/// /// 网页调用C#方法
/// public class ScriptCallbackObject
{
public string UserName { get; set; } = “我是C#属性”;
public void ShowMessage() { MessageBox.Show("网页调用C#"); } public void ShowMessageArg(string arg) { MessageBox.Show("【网页调用C#】:" + arg); } public string GetData(string arg) { return "【网页调用C#获取数据】;" + arg; } [System.Runtime.CompilerServices.IndexerName("Items")] public string this[int index] { get { return m_dictionary[index]; } set { m_dictionary[index] = value; } } private Dictionary&lt;int, string&gt; m_dictionary = new Dictionary&lt;int, string&gt;(); }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81af3d279419e6775693949fd0fc8a34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c501065103407de7e454f9ce2e36899/" rel="bookmark">
			java定积分_高等数学——简单直观地了解定积分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文始发于个人公众号：TechFlow，原创不易，求个关注
今天是高等数学第11篇文章，我们来看看定积分的相关内容。
对于很多人来说定积分的内容其实早在高中就已经接触过了，比如在高中物理当中，我们经常使用一种叫做”微元法“的方法来解决一些物理问题。但实际上所谓的”微元法“本质上来说其实就是一种微积分计算方法。我们来看两个简单的例子。
微分与积分的例子
第一个例子是扇形的面积计算，先别急着笑，我知道这个是初中的内容。扇形的面积谁不会算，扇形的面积等于圆的面积乘上圆心角嘛。
圆的面积我们都知道\(S=\pi r^2\)，如果是扇形的话，再加上圆心角，我们用弧度制来表示圆心角，可以直接进行计算：\(S=\pi r^2 \theta\)。
除此之外还有别的办法吗？
当然是有的，我们来看下面这张图：
在下面这张图当中，我们从扇形上切了一小块出来，做了一个直角三角形。我们令这个直角三角形无限窄，那么它的面积就可以近似于这一块小扇形的面积。
直角三角形的面积很简单，我们都会算，我们令短的直角边长度是l。那么这个小三角形的面积就等于\(\frac{1}{2}lr\)。
我们如此操作，可以把这一块扇形分割成无数个这样的小三角形，最后我们把这些小三角形的面积全部加起来，就可以得到扇形的面积。由于l趋向于0，每一个小三角形和小扇形的面积差的极限都是0，所以可以近似看成它们相等。
这样一番操作之后，我们可以用无数个小三角形的面积来代替扇形的面积。对于这些小三角形而言，它们的面积都是\(\frac{1}{2}lr\)。把它们进行累加，本质上也就是把这些所有的短边进行累加。那么显然，这些所有的短边累加之后的结果就是扇形的弧长。
我们假设这块扇形的弧长是L，那么整个扇形的面积还可以表示成\(\frac{1}{2}rL\)。
我们可以简单验证一下，一个完整的圆也可以看成是一个扇形。一个完整的圆，它的弧长，也就是周长是\(2\pi r\)。我们代入刚才的公式，得到的结果和圆的面积公式吻合，所以我们的计算是正确的。
在这个例子当中扇形分割成的每个小三角形是一样的，所以我们可以直接进行累加。如果我们微分之后的结果不再是固定的，是变化的，那么应该怎么办？
我们再来看另外一个例子：
比如我们要求a和b两点围成的曲线矩形的面积，我们也可以将矩形进行拆分。我们可以无限拆分成多个小的矩形的面积去替代。我们可以很容易证明，当\(\Delta x\)趋向于0的时候，那一块小的矩形面积和曲线矩形的面积相等。所以我们可以把它拆分成无数个这样的矩形，然后将所有的面积求和，就得到了曲线围成的面积。
对于每一块矩形而言，它们的宽都是\(\Delta x\)，但是它们的高都不相同。但是很容易看出来，它们的高都是区间里某一个坐标的函数值。其实我们可以写出来这些序列的值，它们分别是: a, a+\(\Delta x\), a + 2\(\Delta x\), ..., b。
为了方便书写，我们令这个序列等于\(\{\xi_1, \xi_2, \cdots, \xi_n\}\)
所以曲线围成的面积可以写成：
\[S_{c}=\lim_{\Delta x \to 0}\sum_{i=1}^n f(\xi_i) \Delta x
\]
定积分的定义
我们观察一下上面这个问题，其实我们知道了很多信息，比如我们知道了函数f(x)，我们还知道了a和b的值，看起来已经离结果很近了。的确如此，但是在我们继续往下之前，我们必须要明确一点，我们这样的推算是有前提的。
最大的也是隐藏的前提就是我们做的划分，我们必须要保证两点，首先我们要保证当\(\Delta x\)趋向于0的时候，矩形高度的极限是确定的。并且这些小矩形的面积和的极限趋近于它真实的面积。
我们用数学的语言来表达，也就是说，我们无论如何选取每一个\(\xi_i\)，我们都要保证\(\lim_{\Delta x \to 0}\sum_{i=1}^n f(\xi_i) \Delta x\)是一个定值，这样我们就可以把这个式子写成定积分的形式：
\[\int_a^bf(x)dx = \lim_{\Delta x \to 0}\sum_{i=1}^n f(\xi_i) \Delta x_i
\]
这里的f(x)称作被积函数，\(f(x)dx\)称为被积表达式，x叫做积分变量，a和b分别称为积分的上限和下限。
如果f(x)在[a, b]上的定积分存在，那么就称为f(x)在区间[a, b]上可积。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c501065103407de7e454f9ce2e36899/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2451f3d45025a7b532c79d396d55fd7/" rel="bookmark">
			PHP随机插入字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 随机插入字符串 if(!function_exists('randInsertStr')){ /** * 随机插入字符串 * @param string $string 原字符串 * @param string $insertStr 需要插入的字符串 * @return bool|string * @author Lj * @date 2020-11-12 */ function randInsertStr($string){ if(empty($string)){ return false; } preg_match_all("/./u", $string, $arr); $arrNew = array(1,2); $str = ''; foreach ($arr[0] as $k=&gt;$v){ if($k == 0) { $str.= $v.' '; }else{ $key = array_rand($arrNew,1); $rand = $arrNew[$key]; $str.= ($rand % 2) == 0 ? $v.' ': $v; } } return $str; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2eaade35ec6822744fb972fda92409f/" rel="bookmark">
			Linux中C&#43;&#43;可执行程序执行时出现Permission denied.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因为 该可执行文件未赋予可执行的权限；
解决方法：chmod 777 filename[可执行文件名] （每个人都有读和写以及执行的权限，具体权限可根据实际情况更改），赋予文件可执行权限即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ee3e300f7345a955999fb61148e02eb/" rel="bookmark">
			Extra }, or forgotten endgroup. [  maketitlepage]问题的解决(uline命令)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 最近的一套TeX模板突然不能正常编译了,提示一堆错误信息(如下),但是在TeX live2020版(未更新宏包)上可以正常编译,找了好久才解决这个问题.
Extra }, or forgotten \endgroup. [ \maketitlepage] Missing } inserted. [ \maketitlepage] …… 源文件(报错部分就定位到了这行命令)
\maketitlepage % 封面 对应的文档类主题文件为:
\begin{minipage}[t]{4.5cm} 学号\ ：\uline{\hfill\hspace{3mm}\@stunum\hspace{3mm}\hfill} \\[2mm] % 密级\ ：\uline{\hfill \hfill} \end{minipage} 乍一看发现不了什么问题,但是既然错误提示了大括号缺失什么的,我就尝试着看看\uline这个命令是不是有什么问题.
分析与解决 首先,当我注释掉学号一行时候,不会报错,然后,我把密级一行取消注释之后,发现也不会报错,那么问题肯定就出现在\hspace{3mm}这里了.
我感觉应该是\uline命令在更新之后不支持大括号的参数命令（猜的），因为\hfill不会报错，但是其等价命令\hspace{\fill}却会报错，那看来就是不能在\uline中添加带大括号参数的命令了。
下面是可以在最新版TeX引擎中编译通过的代码段：
\begin{minipage}[t]{4.5cm} 学号\ ：\uline{\hfill\@stunum\hfill} \\[2mm] % 密级\ ：\uline{\hfill \hfill} \end{minipage} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9daf0969fa15d34206482bf33ce7b4b5/" rel="bookmark">
			ResNet-50模型图像分类示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ResNet-50模型图像分类示例
概述
计算机视觉是当前深度学习研究最广泛、落地最成熟的技术领域，在手机拍照、智能安防、自动驾驶等场景有广泛应用。从2012年AlexNet在ImageNet比赛夺冠以来，深度学习深刻推动了计算机视觉领域的发展，当前最先进的计算机视觉算法几乎都是深度学习相关的。深度神经网络可以逐层提取图像特征，并保持局部不变性，被广泛应用于分类、检测、分割、检索、识别、提升、重建等视觉任务中。
本文结合图像分类任务，介绍MindSpore如何应用于计算机视觉场景。
图像分类
图像分类是最基础的计算机视觉应用，属于有监督学习类别。给定一张数字图像，判断图像所属的类别，如猫、狗、飞机、汽车等等。用函数来表示这个过程如下：
def classify(image):
label = model(image)
return label
选择合适的model是关键。这里的model一般指的是深度卷积神经网络，如AlexNet、VGG、GoogLeNet、ResNet等等。
MindSpore实现了典型的卷积神经网络，开发者可以参考model_zoo。
MindSpore当前支持的图像分类网络包括：典型网络LeNet、AlexNet、ResNet。
任务描述及准备
图1：CIFAR-10数据集[1]
如图1所示，CIFAR-10数据集共包含10类、共60000张图片。其中，每类图片6000张，50000张是训练集，10000张是测试集。每张图片大小为32*32。
图像分类的训练指标通常是精度（Accuracy），即正确预测的样本数占总预测样本数的比值。
接下来介绍利用MindSpore解决图片分类任务，整体流程如下：
下载CIFAR-10数据集数据加载和预处理定义卷积神经网络，本例采用ResNet-50网络定义损失函数和优化器调用Model高阶API进行训练和保存模型文件加载保存的模型进行推理
本例面向Ascend 910 AI处理器硬件平台，你可以在这里下载完整的样例代码：https://gitee.com/mindspore/docs/tree/r1.1/tutorials/tutorial_code/resnet
下面对任务流程中各个环节及代码关键片段进行解释说明。
下载CIFAR-10数据集
先从CIFAR-10数据集官网上下载CIFAR-10数据集。本例中采用binary格式的数据，Linux环境可以通过下面的命令下载：
wget https://www.cs.toronto.edu/~kriz/cifar-10-binary.tar.gz
接下来需要解压数据集，解压命令如下：
tar -zvxf cifar-10-binary.tar.gz
数据预加载和预处理加载数据集
数据加载可以通过内置数据集格式Cifar10Dataset接口完成。
Cifar10Dataset，读取类型为随机读取，内置CIFAR-10数据集，包含图像和标签，图像格式默认为uint8，标签数据格式默认为uint32。更多说明请查看API中Cifar10Dataset接口说明。
数据加载代码如下，其中data_home为数据存储位置：
cifar_ds = ds.Cifar10Dataset(data_home)数据增强
数据增强主要是对数据进行归一化和丰富数据样本数量。常见的数据增强方式包括裁剪、翻转、色彩变化等等。MindSpore通过调用map方法在图片上执行增强操作：
resize_height = 224
resize_width = 224
rescale = 1.0 / 255.0
shift = 0.0 define map operations random_crop_op = C.RandomCrop((32, 32), (4, 4, 4, 4)) # padding_mode default CONSTANT
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9daf0969fa15d34206482bf33ce7b4b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcd6ae58cb7e7c69f94f1395a3a73e3a/" rel="bookmark">
			java.lang.string源码_JDK1.8源码——java.lang.String 类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		String 类也是java.lang 包下的一个类，算是日常编码中最常用的一个类了，那么本篇博客就来详细的介绍 String 类。
1、String 类的定义
public final class String
implements java.io.Serializable, Comparable, CharSequence {}
和上一篇博客所讲的 Integer 类一样，这也是一个用 final 声明的常量类，不能被任何类所继承,而且一旦一个String对象被创建, 包含在这个对象中的字符序列是不可改变的, 包括该类后续的所有方法都是不能修改该对象的，直至该对象被销毁，这是我们需要特别注意的(该类的一些方法看似改变了字符串，其实内部都是创建一个新的字符串，下面讲解方法时会介绍)。接着实现了 Serializable接口，这是一个序列化标志接口，还实现了 Comparable 接口，用于比较两个字符串的大小(按顺序比较单个字符的ASCII码)，后面会有具体方法实现；最后实现了 CharSequence 接口，表示是一个有序字符的集合，相应的方法后面也会介绍。
2、字段属性
/**The value is used for character storage.*/
private final charvalue[];/**Cache the hash code for the string*/
private int hash; //Default to 0
/**use serialVersionUID from JDK 1.0.2 for interoperability*/
private static final long serialVersionUID = -6849794470754667710L;
一个 String 字符串实际上是一个 char 数组。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcd6ae58cb7e7c69f94f1395a3a73e3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a87c073a3e22b5a37362d2437d94a281/" rel="bookmark">
			Mac中使用LaTeX的中文字体出现Package fontspec Error: The font “宋体“ cannot be found.解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题分析与解决小结参考 问题 最近写论文需要用到LaTeX,之前我已经介绍过Mac上安装Mac TeX的方法,用起来跟在Windows中没有区别,但是在使用中文字体的时候,还是会发生诸如以下的错误:
! Package fontspec Error: The font "宋体" cannot be found. ! Package fontspec Error: The font "黑体" cannot be found. 在调用的地方我采用了Windows下编译通过的模板,即(字体设置部分):
\setCJKmainfont{宋体}%衬线字体 \setCJKsansfont{黑体}%serif是有衬线字体sans serif无衬线字体。 \setCJKmonofont{仿宋}%中文等宽字体 但是这些字体在Mac中竟然找不到…
分析与解决 一开始我以为需要安装字体才能解决问题(网上很多教程中也是这样说的…),之后发现并不是这样,只是Mac中的字体表示与Windows中不同,所以在Windows下可以编译的中文字体设置,到了Mac中反而会显示字体缺失.
遇到这种情况,我的做法是不用加这些字体的设置,直接command+space调出spotlight,输入font进入字体册,找到LaTeX编译提示缺失的字体,例如我上面提到的宋体,在字体册中显示为:STSong(需要点预览模式为显示字体信息即可看到字体文件名称)
并将上面的字体配置依次修改为对应的字体文件名称(图中的PostScript 名称):
\setCJKmainfont{STSong}%衬线字体 \setCJKsansfont{STHeitiSC-Light}%serif是有衬线字体sans serif无衬线字体。 \setCJKmonofont{STFangsong}%中文等宽字体 就可以完美编译啦!
如果需要在文中设置字体,无需导入其他宏集(文档类为ctex前缀的话自动进行中文字体支持),只需要采用ctex的内置字体修改命令(具体可参考ctex文档):
{\songti 你好世界!} {\lishu 你好世界!} {\heiti 你好世界!} 即可完成字体的修改,另外再附上字号的调整命令:
\newcommand{\chuhao}{\fontsize{42pt}{1.25\baselineskip}\selectfont} %初号 \newcommand{\xiaochuhao}{\fontsize{36pt}{1.25\baselineskip}\selectfont} %小初号 \newcommand{\yihao}{\fontsize{28pt}{1.25\baselineskip}\selectfont} %一号 \newcommand{\erhao}{\fontsize{21pt}{1.25\baselineskip}\selectfont} %二号 \newcommand{\xiaoerhao}{\fontsize{18pt}{1.25\baselineskip}\selectfont} %小二号 \newcommand{\sanhao}{\fontsize{15.75pt}{1.25\baselineskip}\selectfont} %三号 \newcommand{\sihao}{\fontsize{14pt}{1.25\baselineskip}\selectfont}% 四号 \newcommand{\xiaosihao}{\fontsize{12pt}{1.25\baselineskip}\selectfont} %小四号 \newcommand{\wuhao}{\fontsize{10.5pt}{1.25\baselineskip}\selectfont} %五号 \newcommand{\xiaowuhao}{\fontsize{9pt}{1.25\baselineskip}\selectfont} %小五号 \newcommand{\liuhao}{\fontsize{7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a87c073a3e22b5a37362d2437d94a281/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c181433a453169656f1225f0c92c46bb/" rel="bookmark">
			java java.lang.string_字符串(Java.lang.String类)的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java字符串就是Unicode字符序列，例如"Java"就是四个Unicode字符
java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义的类String。每个用双引号括起来的字符串都是String类的一个实例。
Java允许使用符号"+"把两个字符串链接起来。
String s1="Hello";String s2="World"; String s=s1+s2;"HelloWorld"
符号“+”把两个字符串an给定的顺序连接在一起，并且完全按照给定的形式。
当"+"运算符两侧的操作数中只要有一个是字符串(String)类型，系统会自动将另一个操作数转换为字符串在进行连接。
int age=18;　String s="age"+age;// age18
字符串的常用类型：
char charAt(int index)：返回字符串中第index个字符。
boolean equals(String other):如果字符串和other相等，就返回true
boolean equalsIgnoreCase(String other):如果字符串与other相等(忽略大小写)，则返回true
int indexOf(String str)
int indexOf(String str,int fronIndx):返回与str匹配的第一个字符串开始的位置，该位置从0或fronIndx计算，如果原始串中不存在str，返回-1。
int length()：返回字符串的长度
String replace(char oldChar,char newChar):返回一个新串，它是通过newChar替换此字符串中出现的所有oldChar而生成的
boolean rtartsWith(String prefis):如果字符串以prefis结尾，就返回true
String substring(int beginIndex)
String substring(int beginIndex,int endIndex):返回一个新的字符串，该串包含从原始字符串beginIndex到串尾endIndex-1的所有字符串
String toLowerCase():返回一个新的字符串中所有大写字母改写成小写字母
String toUpperCase():返回一个新的字符串，该串原始字符串中的所有小写改成大写
String trim():返回一个新的字符串，该串删除了原始字符串头部和尾部的空格
字符串相等的判断
equals方法用来检测两个字符串内容是否相等，相等返回true，否则false
内容可以是字符串变量，也可以是字符串常数。例如"Hello".equals(t)
要测试两个字符串除了大小写是否相等的，需要使用equalsIgnoreCase方法："Hello".equalsIgnoreCase("hello")
判断字符串是否相等使用“==”
String g1="Hello World!";
String g2="Hello World!";
boolean b1=g1.equals(g2);
System.out.println("\tg1.equals(g2) 是否相等：" + (b1 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c181433a453169656f1225f0c92c46bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4df2949226119b4cc8f7012bfd794881/" rel="bookmark">
			外部js怎么调用vue中methods的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 所谓的 外部js，可以是 .js文件，也可以是 .html文件; vue 中的 methods方法 也就是 .vue文件里的 methods属性下的方法.
当 原生js 和 vue中methods的方法不在同一个文件下，js要调用vue中methods的方法，操作如下：
//.vue文件里的代码 export default { name: 'home', mixins: [mainMixin], data: function () { return {...}}, computed: {...}, mounted(){...}, methods: { TestAA(){ // 要调用的方法 console.log('测试js调用vue中的methods方法 TestAA！！！') }, created () { // 在created ()里定义是为了确保vue组件加载完成后，再执行window 全局方法 window.TestAA= this.TestAA // 将vue中要被调用的方法定义成 window 全局方法 }, // .js 或 .html 文件的 &lt;script&gt;代码中 function Hello(){ // 这里的方法是随便写的，其实可以在任意&lt;script&gt;代码中调用 TestAA 方法 TestAA() // 上面设置好后，这里就可以直接调用了 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e578ddd53f5ca766ef2915069b76bf2/" rel="bookmark">
			java汉诺塔图_java 汉诺塔详解及实现代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java 汉诺塔详解及实现代码
实现效果图
打印的方法在 moveTheTopOne() 方法中被调用，调用该方法前打印出移动的方向--从X号塔往Y号塔
汉诺塔要求：将第一座塔上的所有盘子，借助第二座塔，全部搬运到第三座塔上。
规则：一次只能搬运一个盘子，不准将大盘子落在小盘子上。
汉诺塔实现代码：
public class NewHanoi {
public static int tiers = 4; // tiers 层数
private static List pagoda1 = new ArrayList(); // 静态指针
private static List pagoda2 = new ArrayList();
private static List pagoda3 = new ArrayList();
// 映射,用来确定并打印塔的序号(使用角标),也可以使用 Map
private static List[] mapping = {pagoda1, pagoda2, pagoda3};
public static void main(String[] args) {
preparePagoda(pagoda1, tiers);
System.out.println("初始状态：");
printPagodas();
hanoi(tiers, pagoda1, pagoda2, pagoda3);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e578ddd53f5ca766ef2915069b76bf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcfee9309ea4c1cc3a1f1b2ab480d971/" rel="bookmark">
			java 以管理员执行cmd_java  – 以管理员身份运行命令提示符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我正在开发一个小型关机调度程序项目,我必须将计算机置于“待机”模式.我正在使用的命令是
Runtime.getRuntime().exec("cmd /c Powrprof.dll,SetSuspendState ");
此命令需要管理员权限,我不知道如何获取.此外,在搜索以前的答案时,我发现我可以使用elevate.exe作为
Runtime.getRuntime().exec("c:/elevate Rundll32.exe Powrprof.dll,SetSuspendState ");
Elevate.exe正在执行任务,但耗费了太多时间,即使软件变慢.有没有其他快速的方式？我正在使用Netbeans IDE.
解决方法:
你有几个选择
A.使用admin priv创建快捷方式.
该快捷方式将运行cmd / c Rundll32.exe Powrprof.dll,SetSuspendState
您的Java代码将运行快捷方式：
Runtime rt = Runtime.getRuntime();
rt.exec("cmd /c start \"\" \"myshortcut.lnk\"")
右键单击快捷图标&gt;属性&gt;高级&gt;以管理员身份运行
B.以管理员身份运行java进程
再次,创建一个快捷方式并设置为以管理员身份运行.生成的任何进程也将具有管理员权限.你的java代码将运行：
rt.exec("cmd /c Powrprof.dll,SetSuspendState")
C.使用JNA直接调用SetSuspendState例程. Java进程将需要admin priv(如B),但您不必生成进程.如果你喜欢这个,我可以提供源代码.
D.使用wizmo实用程序：wizmo安静待机
标签：java,command-prompt,command-line
来源： https://codeday.me/bug/20190916/1808218.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fed46245beb3c5d547c8bf842c76cd3/" rel="bookmark">
			Java一定要tomcat吗_Java程序员一定要学Tomcat架构吗?为什么?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先就业后付款
Java程序员一定要学Tomcat架构吗?为什么?
IT培训网面向所有课程学员提供先就业后付款学习方案，保证学员稳定就业，可谓0学费！免除学习压力。
正文：
Java程序员一定要学Tomcat架构吗?为什么?对于Java程序员来说，Tomcat架构是每一个初学Java者在入门之后都必需要学的基础知识之一，为什么Java程序员为什么一定要学Tomcat架构呢?理由其实很简单，Tomcat架构是目前JavaEE开发中最主流的服务器之一 。下面这篇文章我们就来看看学习Tomcat架构的具体原因。
要学Tomcat架构为什么?
Tomcat架构是全世界最著名的Java Web轻量级应用服务器，同时它也是开发和调试JSP/Servelet的必备技能，而且它还是Apache软件基金会提供的免费、开源服务器。目前，Tomcat架构广泛应用于企业应用系统以及云服务平台。因此，Tomcat架构凭借着技术先进、性能稳定、应用广泛以及开源免费等诸多优势，成为Java程序员不得不掌握的基础技能。
如何学Tomcat架构?
IT培训网为广大Java学习者开设了Tomcat高级课程, 从Tomcat基础、架构、Jasper、服务器配置、web应用配置、Tomcat管理配置、JVM、Tomcat集群、Tomcat安全、性能调优等各方面进行了详细地讲解，并通过案例，深度讲解Tomcat对Websocket的支持。通过视频课程的在线学习，大家能深入地理解Tomcat底层原理，对Tomcat的设计架构有深刻地认识，从而对Tomcat进行更加深入地使用和优化，对系统的整体性能进行提升。
Tomcat架构要学哪些内容?
以IT培训网的课程大纲为例，为大家规划了一条详细的学习路径：
第一章 Tomcat基础
第二章 Tomcat架构
第三章 Jasper 引擎
第四章 服务器配置
第五章 Web 应用配置
第六章 Tomcat管理配置和内存参数
第七章 Tomat集群
第八章 Tomat安全
第九章 Tomat性能调优
第十章 WebSocket
总之，如果你想深入地理解Tomcat底层原理和架构设计，并且在工作中对Tomcat进行深层使用和性能优化，就来IT培训网在线学习Tomcat架构的相关课程吧~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/125ef9927f47c770fe337a43a0b08233/" rel="bookmark">
			POM文件的packing错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题 Multiple annotations found at this line:
- Plugin execution not covered by lifecycle configuration: org.apache.maven.plugins:maven-compiler-plugin:3.1:testCompile (execution: default-testCompile, phase: test-compile)
- Plugin execution not covered by lifecycle configuration: org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (execution: default-compile, phase: compile)
- CoreException: Could not get the value for parameter compilerId for plugin execution default-compile: PluginResolutionException: Plugin org.apache.maven.plugins:maven-compiler-plugin:3.1 or one of its dependencies could not be
resolved: The repository system is offline but the artifact com.google.collections:google-collections:jar:1.0 is not available in the local repository.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/125ef9927f47c770fe337a43a0b08233/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60b115dd8c35750e0914b2526577db49/" rel="bookmark">
			wampserver3.1.7_x64启动后橙色不变绿解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装wampserver启动后一直橙色，wampserver橙色。这就说明他的wampserver本地环境并没有启动成功。
出现这种问题的主要原因是由于自己的电脑里的80端口被占用了，导致wampservier本地环境无法再使用80端口了。
网上说停止sql server reporting service服务，可是我电脑根本没有这个服务，我就找是哪个服务占用了窗口，用wampserver自带的工具可以检测80端口。
很明显，是Server: Apache/2.4.37 (Win64) PHP/7.2.14占用了
于是去找这个文件是哪
找到conf配置文件夹，点击进入后找到httpd.conf. 你选择用记事本的方式打开后ctrl+f查找listen直到找到 listen 80 ,然后把80改成你想要更改的端口，注意千万不要改你电脑上已用过的端口就OK了，更改后保存。
之后你浏览apache服务器中的网页就要在你的IP下加入http://127.0.0.1:81(比如你把80改成了81).
如果你不想更改apache服务器的端口，那就修改其它程序的端口就行啦。
不过很奇怪，改完8011还是没用，然后我又改回来80，退出wampserver，再打开就变绿了，玄学
后来才知道，原来左键点击一下图标，选择重启所有服务就能变绿。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd76ee89eceedd2b7ea25e5d05eefab0/" rel="bookmark">
			一条命令解决win7开机重启一直卡在Windows Update 35%
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一台Win7电脑，用系统自带的工具清理垃圾后开机重启一直卡在Windows Update 35%转圈圈数小时，无法进入系统。
强制按关机键，F8进入安全模式依然同样现象。
百度后，有人提到用DISM撤销上次的系统操作可解决问题。
用WinRE恢复模式或WinPE启动，运行如下的命令，其中X:为Win7系统所在盘符。
DISM /Image:X:\ /Cleanup-Image /RevertPendingActions 重启后，问题已解决，直接进入了Win7登录界面。
资料扩充：DISM（Deployment Image Servicing and Management）就是部署映像服务和管理工具 (DISM.exe) 用于安装、卸载、配置和更新脱机 Windows® 映像和脱机 Windows 预安装环境 (Windows PE) 映像中的功能和程序包。Windows 8 ADK工具中的DISM取代了多个Windows 7时的AIK工具，包括PEImg、Intlcfg、程序包管理器和 ImageX。以下这些跟映像处理关系最多的命令，原先有一大部分是imagex来处理的，统一由DISM来完成，而原先的版本服务、语言处理、驱动和程序添加等工作还是由DISM来完成。但这并不意味着IMAGEX都不能用了，在ADK安装目录中，我们仍然可以看到新版本的IMAGEX.EXE，如果你觉得有些处理使用DISM不是很顺畅的话，你可以尝试使用IMAGEX工具。输入"IMAGEX.EXE /?"（双引号内）就可以获得IMAGEX的使用帮助。需要注意的是，处理32位系统的最好在32位系统环境运行，处理64位系统的最好在64位系统环境执行，这方面DISM命令比较挑剔，IMAGEX相对自由些。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25770e44dc02caac595c0c800ac8e8d4/" rel="bookmark">
			java ocr引擎_java 实现 OCR 图片文字识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OCR图像识别技术的JAVA实现
最近有个需求需要用图像识别，学习记录一下。
目前网络上的开源的图像识别技术有很多，例如 OCRE(OCR Easy)、Clara OCR、OCRAD、TESSERACT-OCR 等。
今天本blog将记录下tesseract-ocr的JAVA实现，便于以后查阅使用。
开源 ocr 引擎
我们本次直接以排名第一的 TESSERACT-OCR 作为例子。
TESSERACT-OCR 安装
本次测试的环境为 windows10，所以下载 windows 相关的安装包。
windows 下载地址
安装
安装完毕后，目录下：
直接双击 exe，然后安装。
指定安装特定语言包
这里我们安装一下中文的语言训练包。
【chinese】相关的四个，简体，繁体(分别对应的默认和垂直。)
比较悲催的是全部下载失败。
安装路径
使用默认路径：
C:\Program Files (x86)\Tesseract-OCR
结果
λ ls
ambiguous_words.exe* libcairo-2.dll* libgomp-1.dll* libpangocairo-1.0-0.dll* libwebp-7.dll* tesseract.exe*
classifier_tester.exe* libexpat-1.dll* libharfbuzz-0.dll* libpangoft2-1.0-0.dll* libwinpthread-1.dll* tesseract-uninstall.exe*
cntraining.exe* libffi-6.dll* libintl-8.dll* libpangowin32-1.0-0.dll* lstmeval.exe* text2image.exe*
combine_lang_model.exe* libfontconfig-1.dll* libjbig-2.dll* libpcre-1.dll* lstmtraining.exe* unicharset_extractor.exe*
combine_tessdata.exe* libfreetype-6.dll* libjpeg-8.dll* libpixman-1-0.dll* merge_unicharsets.exe* wordlist2dawg.exe*
dawg2wordlist.exe* libgcc_s_seh-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25770e44dc02caac595c0c800ac8e8d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec02a80251d75f94469dd76df246df19/" rel="bookmark">
			女生适合学习java什么_女生不适合学习java吗？其实不是这样的，女生往往更有优势！...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		女生适合学java吗？女生做IT怎么样
首先要表明我的观点，编程是不分男女，什么女生不适合学编程的说法，从客观上来说，我觉得这是一种偏见。
不少人潜意识里认为女生不适合从事IT开发岗位的工作，因为他们觉得这些岗位对逻辑性的要求很好，而且要具备一定的操作水平，而女生在这方面比较薄弱。实际上，女生从Java的工作，很多时候能做得比男生更好。
为什么说女生比男生更能学好java呢？
1、女生往往比男生更细心，我认为女生可能在这个行业可以做得更好。首先因为女生比较踏实认真，代码的学习是一个长期，需要坚持的过程。而很多男生在学习过程中很容易失去耐心最终放弃。其次女生天生的做事认真、细致，而敲代码正是需要这样耐心细致的品质才会保证更少的错误的出现。
2、有一种说法是，男生往往比较理性，在逻辑方面比女生强。但是不要忘了，java是一门编程语言，抛去其中的数学逻辑不谈，java的本质是一门语言，而且java都是英语。在这方面，女生是会比男生强的，毕竟在我周围，我还没遇过英语比女生好的男生。
女生学Java好找工作吗？
1、关于学完Java能不能找到工作，更多的是在于所学的技能水平如何，是否真正具备开发项目的能力。而不在于性别。现在很多女生敢于做自我，只要她们对Java感兴趣，或者想从事Java的岗位的工作，在工作方面是不会输于男生的。
2、说实话，女生在从事编程方面工作时，是非常好找工作的。女生做IT的是比较少的，这也导致了在面试时，女生往往有更多的通过率。因为IT行业的从业者男性远远多于女性，男女比例不平衡，如果在这样的环境中有女程序员的加入，不仅可以给企业带来活力，也会带动气氛。很多时候，企业在招聘时也更倾向于招聘女性从业者。
最后再从现实问题和未来发展来说一下：
女生做IT方面的工作，其实相较于其他工作是很不错的选择，不需要应酬，不需要出差奔波，也不用担心潜规则，相对稳定。而且女生在未来是可以转型做讲师的，如今有很多java培训班，女生去做讲师，也是一个不错的选择。
对于IT行业的从业者，求职就业完全取决于个人的能力，而不是性别。所以女生完全可以放心大胆的选择IT行业，选择进行Java的学习，去赢得自己想要的人生。所以，妹子，加油！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31f225c0112df235bd01dca149958303/" rel="bookmark">
			java 不验证证书,不带身份验证信任证书的JavaMail SSL，无论如何
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I have a local mail server (hMailServer) with SSL (port 465) and a self-signed certificate.
Domain is "foobar.com"
I have setup my Properties to enable ssl, disable auth, and trust any host
props.put("mail.smtp.auth", "false");
props.put("mail.smtp.ssl.enable", "true");
props.put("mail.smtp.ssl.trust", "*");
If I send the message through the static call to Transport.send()
The email gets delivered.
If I try to get a transport instance from the session then I get
javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31f225c0112df235bd01dca149958303/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c0cca51464e6843305a47ac92b14ab3/" rel="bookmark">
			Java 堆 栈面试题_Java工程师面试题：Java的堆，栈，方法区你都搞清楚了吗?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行学员回访的时候，碰巧提到一些Java工程师面试题：Java的堆，栈，方法区你都楚吗?这里上海Java培训班学员在面试时都这样做了回答。
问题分析：Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。回答套路熟悉时，几个方面都会说到。
程序计数器
上海Java培训班：程序计数器(Program Counter
Register)是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。字节码指令、分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。每条线程都有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址;如果正在执行的是Native方法，这个计数器值则为空(Undefined)。此内存区域是唯一一个在Java虚拟机中没有规范任何OutOfMemoryError情况的区域。
Java虚拟机栈
1. Java虚拟机栈也是线程私有的，它的生命周期与线程相同(随线程而生，随线程而灭)。2.
如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常;如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常;(当前大部分JVM都可以动态扩展，只不过JVM规范也允许固定长度的虚拟机栈)。3.
Java虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时会创建一个 栈帧。 对于我们来说，主要关注的stack栈内存，就是虚拟机栈中
局部变量表部分。
栈帧
上海Java培训班：栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧用于存储
局部变量表、操作数栈、动态链接、方法返回等信息。
每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。在活动线程中，只有位于栈顶的栈帧才是有效的，称为
当前栈帧，与这个栈帧相关联的方法称为 当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。
本地方法栈
本地方法栈(Native Method
Stack)与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务(也就是字节码)服务，而本地方法栈为虚拟机使用到的Native方法服务。Java虚拟机规范对本地方法栈使用的语言、使用方法与数据结构并没有强制规定，因此可以由虚拟机自由实现。例如：HotSpot虚拟机直接将本地方法栈和虚拟机栈合二为一。同虚拟机栈相同，Java虚拟机规范对这个区域也规定了两种异常情况StackOverflowError
和 OutOfMemoryError异常。
堆
上海Java培训班：1. Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，是虚拟机所管理的内存中最大的一块。此内存区域的唯一目的就是
“存放对象实例和数组”，几乎所有的对象实例和数组都在这里分配内存。2. Java堆是垃圾收集器管理的主要区域，也称为GC
垃圾堆。后面会专门分析GC算法。从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆可以细分为：新生代、老生代;从内存分配的角度看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区(TLAB);不论如何划分，都与存放的内容无关，无论哪个区域，存储的仍然是对象实例和数组。3. 如果在堆中没有内存完成实例分配，并且堆上也无法再扩展时，将会抛出OutOfMemoryError异常。4. 内存泄露和内存溢出。
内存泄露 ： 指程序中动态分配内存给一些临时对象，但是对象不会被GC所回收，它始终占用内存。即 被分配的对象可达但已无用，可用内存越来越少。
内存溢出 ：
指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于老年代或永久代垃圾回收后，仍然无内存空间容纳新的Java对象的情况。但这只能是内存溢出的一种诱因，不是唯一因素。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70ba636128511e07cc6c6eff9d6524ef/" rel="bookmark">
			java编程贴纸问题_程序员如何装逼？最后一条绝了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：程序员如何装逼？最后一条绝了！
关注我们 做新生代程序员！
感觉程序员还是可以很好的装逼，比如邻居说输入法切换怎么没用啊，怎么换个壁纸啊，电脑怎么总出现蓝屏啊，等等一系列的问题，然而其实这些问题都so easy，但你帮他解决了，邻居就会觉得你好牛逼。尤其是装个系统，全是看都看不懂。下面来说下程序员该如何装逼。
穿着：套头衫＋牛仔裤+双肩背包，最后再来个夹角拖鞋就齐活了。再随便让头发有点油油的感觉这就完美了。
行为作风：少说话，跟别人聊天也要没事环顾一下四周，感觉漫不经心。千万不要让别人觉得你很认真的在听他说话。
椅子：有钱买Embody，没钱也无所谓。
键盘：一定要HHKB，没印字的，另外最好搞清楚青轴茶轴之类的区别。
屏幕：至少两个屏幕，其中至少要有一个是竖着的，专门看代码。
电脑：电脑最好是Mac的，没有Mac也不怕，随便什么牌子的都好，但一定要帖满贴纸，微软的什么就不要了，Github、Hadoop之类的都好，总之越多越牛，最好再找几个美国的，不出名的超级英雄帖上去，反正也没人会问这个是什么。
网站：Stackoverflow、HackerNews、Reddit、Github一个都不能缺，千万别说上百度和CSDN。
编辑器： 千万不能提IDE，也别骂用IDE的，就要感觉压根不知道有这个东西才好。UltraEdit和Editplus也就20分，Sublime和 Textmate算及格，Vim能给到70，Emacs稍微高个一两分。但这里一定要提到，无论只要和对面说话的人发现在Vim和Emacs上站队不统 一，就要表明自己的立场，然后适当争论，只要不露馅就好，如果发现明显处于下风就微微说一句：不过是哲学思想和价值观的不同罢了，没必要非要比个高下。
系统：用Windows的就面壁去吧，Ubuntu和Debian都是及格，Mac 70分，Arch、Gentoo、LFS　80分，你要是用个BSD就直接拿A。想拿一百分？那就在交谈中，有一搭没一搭不经意的来一句：“哦，我偶尔用用Lisp Machine。”
书：《算法导论》、《编译原理》这种书虽然很经典，但估计大家都看过，TAOCP大家也都听说过，适当装逼可以提到，略微加分。
数据库：MS SQL是什么？MySQL是什么？要说就从MongoDB起，类似的还有Cassandra、Membase、CouchDB。
语言： 千万不要说自己是做Java或者.Net的。PHP也不行，Python稍微有点烂大街。剩下的可以说自己是做 Ruby的，但不要做Rails，说Sinatra。Go、Erlang、Clojure、Scala能给80分，你要是说会个Lisp就是85 分，Haskell直接捅到90分，但是千万注意，一定要说只是精通Haskell，没事喜欢研究Haskell，千万不要说干这个的。最后再拽出来一个 Prolog就成仙了。如果怕被继续追问就说自己做C++的，就是放了个大烟雾弹，让对面也猜不透究竟有几斤几两。C是什么？不知道。
和朋友聊天：和朋友聊天就聊些专业术语，比如java里面的方法，类，数组啊，多讲些英文的词，android里面的沉浸式状态栏，rxjava+MVP+retrofit+glide框架啊，这些都可以讲。
思维：比如你女朋友叫你去买个包子，结果没有包子了，你就炒个粉，这就是程序员思维，if else嘛。
问电话号码：
内容来源：程序师
原文链接：https://www.techug.com/post/how-programmer-show-cool.html
版权归原作者所有。
嵌入式、JavaEE、HTML5......多种课程免费试听！
立即加入，
免费试听！
2、点击文末“阅读原文”
华清远见成都中心
高端IT就业培训专家
责任编辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef8791b70473f77515d46cb6bfd89d91/" rel="bookmark">
			数据库中的范式和多值依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是Markdown来的，有些地方内容展现并不友好，建议直接看原文，点击查看
数据库中的函数依赖，主码，候选码等的区别：点击打开链接
数据库中的范式：分为，1NF,2NF,3NF,BCNF,4NF。一般我们，我们设计数据库到第三范式就算完整的了。它们的关系如下：
第一范式：定义很多，其实说的就是列不可分。
如：
出厂日期
总额
数量
单价
在关系数据库中不能出现这种情况。
第二范式定义：若R∈1NF，且每一个非主属性完全函数依赖于码，则R∈2NF。意思是非主属性完全依赖于码（候选码，主码），这里需要注意一下，是非主属性（候选码之外的属性），在前一篇文章已经说过。
如：
(学号, 系名, 课程号, 成绩) ∈1NF (学号, 系名, 课程号, 成绩)不属于 2NF 在该关系模式中，学号+课程号是码，其他属性都是非主属性，但是只有成绩完全依赖于码，系名是部分依赖，因为学号就可以推出学生所在的系了。
第三范式定义：它的定义。。不打了，太烦了。其实说的就是消除 传递依
赖。每一个非主属性都要直接依赖于码，不能传递依赖于码。如：在一个
学生表中，我们规定一个系的学生是住在同一个宿舍区域的，于是，该关
系模型为：
学生表(学号, 系名, 宿舍区)
在这关系中，学号为码，学号——&gt;系名，学号——&gt;宿舍区，但是，系名也能推出宿舍区，变成 学号——&gt;系名——&gt;宿舍区，即宿舍区传递依赖于学好了。
解决方法：拆分成两个表：
1（学号，系名），2（系名，宿舍区）
从上面我们可以看到，在两个表中我们可以看到，当两个表通过外键（1表的系名，2中系名为主健）关联后，另一个表的的信息（如2表中的宿舍区）不能再写到包含外键关系的表中（1表）。
BC范式：前面的三个范式是针对非主属性的，BC范式则是针对于码（什么是码，前篇文章说过），它要求每个函数的依赖关系中其决定因素都要包含码。
如：
在关系模式STJ（S，T，J）中，S表示学生，T表示教师，J表示课程。
函数依赖：(S，J)→T，(S，T)→J， T→J 其中，(S，J)和(S，T)都是候选 码。
可以看出STJ中，它是属于第三范式的，因为没有哪一组依赖关系中，非主属性传递或者部分 依赖于码，（记住是非主属性，是候选码以外的属性，T在候选码中），但是，它不属于BC范式，因为T是决定因素，T不包含码（候选码的任何一个真子集都不能叫候选码）。
多值依赖定义：第四范式需要掌握的一个内容。它说的就是设R(U)是一个属性集U上的一个关系模式， X、 Y和Z是U的子集，并且Z＝U－X－Y。关系模式R(U)中多值依赖 X→→Y成立，当且仅当对R(U)的任一关系r，给定的一对（x，z）值，有一组Y的值，这组值仅仅决定于x值而与z值无关（想不到好的方法把它概括起来，哎！）
判定方法：对于任意关系中，如果存在两个元组（就是行），记为A,B，如果他们的某一属性X的值相等，那么我们交换它们另外的属性Y的值后，得到的新的两个元组，在表中是可以在原来的表中找到与它们相匹配的元组的。
如：
该表中的码为（C,T,B）我们可以找到第一和第四行，它们的属性X=物理是相同的，当我们交换Y=教员属性后得到（物理，王军，普通物理学）和（物理，李勇，普通 物理学），与原来的表相比，是一毛一样的。我们也可以交换第三行和第四行，得到（物理，王军，物理习题集）和（物理，李勇，普通物理学），与原来表相比，我们还是能找到与它们相匹配的元组的。
平凡多值依赖和非平凡的多值依赖：
若X→→Y，而Z＝φ，则称X→→Y为平凡的多值依赖否则称X→→Y为非平凡的多值依赖。
多值依赖与函数依赖的区别：
1）若函数依赖X→Y在R（U）上成立，则对于任何Y' 属于Y均有X→Y' 成立
2）多值依赖X→→Y若在R(U)上成立，不能断言对于任何Y' 属于Y有X→→Y' 成立，因为多值依赖中，其实就是一对一组，一个老师可能交多门课，所以不同老师可能有教相同的课，所以不能推出X→→Y' 成立。我们可以看出，如果把一组改为一个，实际上就是函数依赖，所以所函数依赖是多值依赖的特例，多值依赖不一定是函数依赖，但函数依赖一定是多值依赖。
多值依赖性质：
（1）多值依赖具有对称性
若X→→Y，则X→→Z，其中Z＝U－X－Y
（2）多值依赖具有传递性
若X→→Y，Y→→Z， 则X→→Z –Y
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef8791b70473f77515d46cb6bfd89d91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76a834383fa5d6d403622ec973a69eed/" rel="bookmark">
			pycharm怎样编写java_Pycharm改进和编写代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyCharm包含用于编写代码的各种标准，其中包含适用于Python的适当缩进。 这有助于提高代码标准并在PyCharm编辑器中编写完整的代码。
改进代码完成
PyCharm中的代码完成非常独特。 您可以使用许多其他功能进一步增强它。 请注意，编辑器提供了代码块的开始和结束。 以下代码编写一个名为demo.py的文件中 -
message = 'GIEWIVrGMTLIVrHIQS' #encrypted message
LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
for key in range(len(LETTERS)):
translated = ''
for symbol in message:
if symbol in LETTERS:
num = LETTERS.find(symbol)
num = num - key
if num &lt; 0:
num = num + len(LETTERS)
translated = translated + LETTERS[num]
else:
translated = translated + symbol
print('Hacking key #%s: %s' % (key, translated))
代码使用以下构造完成 -
如果在屏幕上显示此弹出窗口时按下Ctrl + 空格键，则可以看到更多代码完成选项 -
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76a834383fa5d6d403622ec973a69eed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cdb331c6695a23044c09c99b91ba0cc/" rel="bookmark">
			简易文件系统-用Go语言从零开始设计(四) 文件系统冗余措施 一致性hash算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、一致性hash算法 一致性Hash介绍 分布式均匀算法--hash性一致算法--hash slot
上面是大致介绍，根据自身理解，其只是更随机更均匀的分配。本系统需要同一md5元数据不能分配到同一文件节点中，因此需要对其进行改造。
也就是计算元数据key时，会遍历对应key中是否有相同md5值的数据，如果有则寻找下一个key对应的node，直到找到为止。
本来一致性Hash能快速根据key获取信息，不用存储Key对应的文件信息，但由于本系统需求，需要存储空间记录信息。
Go语言一致性Hash代码为网上开源，只是对其功能进行修改
一致性Hash算法
package main //一致性哈希(Consistent Hashing) import ( "fmt" "hash/crc32" "sort" "strconv" "sync" ) const DEFAULT_REPLICAS = 2000 type HashRing []uint32 func (c HashRing) Len() int { return len(c) } func (c HashRing) Less(i, j int) bool { return c[i] &lt; c[j] } func (c HashRing) Swap(i, j int) { c[i], c[j] = c[j], c[i] } type Node struct { Id string Weight int } func NewNode(id string, weight int) *Node { return &amp;Node{ Id: id, Weight: weight, } } type Consistent struct { Nodes map[uint32]Node numReps int Resources map[string]bool NodeIdMap map[string]Node ring HashRing sync.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cdb331c6695a23044c09c99b91ba0cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf85c1bb47706da89b26e3f04b020c81/" rel="bookmark">
			简易文件系统-用Go语言从零开始设计(三) 文件上传 文件下载 文件删除 文件共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、文件上传
二、文件下载
三、文件删除
4、文件共享
服务之间的通信都是用tcp，定义好数据的结构即可，在其他文章提及过
一、文件上传 客户端使用QT编写，在上传文件过程中会首先会查询服务器是否有相同md5值文件，有则上传文件的基本数据
上传时会预先判断文件的大小，如果大于指定数值则对文件进行分割上传。
如果存在相同md5值文件，服务器只需数据库查询对应文件信息将其virtualDataID复制到新文件信息，完成此次文件上传
当所有文件块上传完毕后，服务器会合并数据并再次分割成适合存储元数据的大小，并生成对应的虚拟数据，再由虚拟数据根据冗余等级生成对应的元数据
经过改进版一致性Hash计算出对应元数据对应Filenode并进行存储
// 服务端处理新建文件 func ServerNewFileInsert(filedata Filedata, Tcpconn *TcpConn) error { // var file Filedata // err := json.Unmarshal(data, &amp;file) // if err != nil { // return err // } var err error Userid := filedata.UserId //判断用户文件路径树书否存在 不存在则读取mysql生成 f, exit := UserFileMap[Userid] if !exit { f, err = BuildUserFileList(Userid) if err != nil { fmt.Println(err) return err } UserFileMap[Userid] = f } // 查看用户文件夹是否有相同名称 file, err := File.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf85c1bb47706da89b26e3f04b020c81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e162588eb02e61073f1594fe2f6ee2d0/" rel="bookmark">
			Java 8 Stream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 8 Stream Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。
Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。
Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。
这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。
元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。
+--------------------+ +------+ +------+ +---+ +-------+ | stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect| +--------------------+ +------+ +------+ +---+ +-------+ 以上的流程转换为 Java 代码为： List&lt;Integer&gt; transactionsIds = widgets.stream() .filter(b -&gt; b.getColor() == RED) .sorted((x,y) -&gt; x.getWeight() - y.getWeight()) .mapToInt(Widget::getWeight) .sum(); 什么是 Stream？ 一. Stream（流）是一个来自数据源的元素队列并支持聚合操作
元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。 二.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e162588eb02e61073f1594fe2f6ee2d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc7e314a8bd91dcec0c2704694943538/" rel="bookmark">
			Sass-5【颜色函数、透明度函数、@规则】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.颜色函数 (1).rgb函数 div{ width:300px; height:300px; background-color:rgba(200,100,50); } (2).red/blue/green red(#c86432) 200 (3).mix混合函数 div{ width:300px; height:300px; background-color:mix(red,blue) } //编译结果 div{ width:300px; height:300px; background-color:purple; } 设置比例
div{ width:300px; height:300px; background-color:mix(red,blue,25%); } 代表红色百分之25 蓝色百分之75
(4).hsl色彩空间 更加直观的表单颜色
H 色相 S饱和度 L亮度
Hue值:圆环上的度数 0-360
Sataration值:高中轴的距离 0-100%
Lightness值:颜色的高度 0-100%
div{ width:300px; height:300px; background-color:hsl(100deg,20%,80%); } background-color:#c9d6c2 hue/saturation/lightness也可以是函数 hue(#c9d6c2) 99deg saturation(#c9d6c2) 19.60.... 更多函数可以查阅百度
二.透明度函数 (1).rgba函数 div{ width:300px; height:300px; background-color:rgba(200,100,20,.5); } (2).hsl透明度 div{ width:300px; height:300px; background-color:hsla(100,20%,80%,.5) } (3).opacity函数 alpha(rgba(red,.8)) 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc7e314a8bd91dcec0c2704694943538/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aa01314646656c7e8c3e00053df424b/" rel="bookmark">
			entity生成mysql指令max_EntityFrameworkCore教程：控制台程序生成数据库表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言
我们使用Code First的方式来生成数据库表，我们先讲解如何在控制台项目中生成数据库表。
在前面的文章中，我们是直接在控制台项目中安装的Mircosoft.EntityFrameworkCore，在真实的项目中，我们很少这样使用，都是采用分层的结构，将EF Core有关的操作放在一个单独的类库项目里，下面的例子中我们就以这种分层的结构来进行讲解。项目结构如下图所示：
项目结构：
EFCoreTest.Con：控制台项目，用来运行程序，在项目中会引用EFCoreTest.Data。
EFCoreTest.Data：类库项目，基于.Net Standard。存放的是与EF Core相关的内容。
EFCoreTest.Model：类库项目，基于.Net Standard。存放项目中使用到的实体类。
1、添加实体类
我们首先在EFCoreTest.Model类库项目里添加Student实体：
namespaceEFCoreTest.Model
{public classStudent
{public int Id { get; set; }public string Name { get; set; }public int Age { get; set; }public int Gender { get; set; }
}
}
2、添加Mircosoft.EntityFrameworkCore
我们在EFCoreTest.Data类库里面添加Mircosoft.EntityFrameworkCore包：
我们使用SqlServer数据库，所以我们还要安装Microsoft.EntityFrameworkCore.sqlServer包：
安装完成以后我们添加EFCoreTest.Model的引用，然后添加数据上下文类，该类继承自DbContext：
usingEFCoreTest.Model;usingMicrosoft.EntityFrameworkCore;namespaceEFCoreTest.Data
{/// ///数据上下文类，继承自DbContext/// public classEFCoreDbContext:DbContext
{/// ///重写OnConfiguring方法/// /// protected override voidOnConfiguring(DbContextOptionsBuilder optionsBuilder)
{//使用SqlServer数据库，传递连接字符串
optionsBuilder.UseSqlServer("Data Source=.;Initial Catalog=EFTestDb;User ID=sa;Password=123456;");base.OnConfiguring(optionsBuilder);
}/// ///重写OnModelCreating，主要做一些配置///例如设置生成的表名、主键、字符长度/// /// protected override voidOnModelCreating(ModelBuilder modelBuilder)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2aa01314646656c7e8c3e00053df424b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/396a479d3e26475c99a29252d826f248/" rel="bookmark">
			解决Pycharm中无法使用中文输入法问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统版本：Ubuntu 16.04
PyCharm版本：PyCharm 2020.3.3 (Community Edition)
1、在pycharm安装目录bin下的pycharm.sh中，添加如下几行：
ibus类型的输入法添加:
export GTK_IM_MODULE=ibus export QT_IM_MODULE=ibus export XMODIFIERS=@im=ibus fcitx类型的输入法添加：
export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=@im=fcitx 2、重启pycharm即可
参考链接：
解决Python开发中，Pycharm中无法使用中文输入法问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cee3f5a8eaad0e18a514402cfbfc9a6/" rel="bookmark">
			前后端分离部署方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自https://www.cnblogs.com/moveofgod/p/12363544.html
写得简洁明了。
------
例如 vue ， 这种前后端分离的框架如何部署
1. 前后端一起部署, 前端打包成静态文件后, copy 到后端项目中，然后部署后端项目。
如果选择这种方式, 需要把dist文件夹里的内容, 一样的 copy 到 resource/static 文件夹下.
这种静态资源不会被 spring security 拦截. 所以这里需要配置一下, 让它不拦截. 然后, 需要给项目整体打包. 现在的 springBoot 可以打成 jar 包, 然后把 jar 包上传到服务器, java -jar xxx.jar 就可以了.
这样就可以使用浏览器来访问了. 这种部署方案不存在跨域问题.
2. 前后端分别部署，前端使用 Nginx 部署, 后端直接运行 jar.
后端一样需要独立的部署 jar 包, 跟上边类似, 只是不需要copy前端的静态资源了.
nginx 可以通过一个配置，解决跨域问题:
nginx 监听 80端口, 如果你访问的地址是 /, 就转发到端口是8081, 对于浏览器来说, 它不知道8081的事情, 浏览器只是访问了80这个端口
如果你访问的是静态资源, 比如利用正则表达式判断你访问的是不是类似 jpg|css|js|html 等等, 如果是, 就访问nginx server本地的目录dist
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cee3f5a8eaad0e18a514402cfbfc9a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03844735b1f120831f7b800661094f40/" rel="bookmark">
			前后端分离项目的服务器部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.jianshu.com/p/cbb21c6f3427
前几天我的个人网站终于部署上线了，趁现在还记得，赶紧把流程记录下来。本文讲的是前后端分离的项目的服务器部署，这里就以我的个人网站为例子。我的个人网站前端是react，后端是nodejs，数据库是mongodb。
为了把项目部署上线，首先我们需要确保这个项目已经在本地跑通了，所谓跑通就是前端，后端，和服务器都已经被串在一起，而且可以正常运行了。在这个基础上，我们的部署分为以下几个步骤：
购买域名和远程服务器域名解析，实名制认证，备案把项目代码放在远程服务器上程服务器安装数据库前端编译静态文件nginx前端配置解决前后端跨域问题项目在线上跑通以及后续完善 步骤很多，看起来很吓人，但是实际操作起来还是很快的，下面我们就一步一步的来讲解吧。
1. 购买域名和远程服务器 域名和远程服务器推荐在阿里云上购买, 原因是购买了他们的产品后有一系列很详细的教程，对于新手来说是很友好的。
购买后的域名需要进行实名制认证，这个过程很快，几乎是即时的，具体的认证方式阿里云上都有详细的说明。
服务器我买的是阿里云的轻量应用服务器，物美价廉，对于我的个人网站来说足够用了。购买服务器时，会让你选择服务器的地域，如果你的地域选在国内的话那你的域名是需要备案的，而这个备案过程大约需要半个月，所以着急着项目上线的同学可以把地域选在香港，是不用备案的。但是服务器放在香港的缺点就是有点延迟，所以服务器放在哪里还需要自己权衡。
购买服务器时还需要选择应用镜像和系统镜像，这里我们没有用到任何应用来构建我们的网站，所以只要选择系统镜像就好了。而选择什么系统呢？什么系统你最熟悉就选择什么系统，如果你完全是个小白，而且也不熟悉Linux系统的话，我个人不负责任的推荐windows系统。至于windows系统被嫌弃的不安全等问题，对于我这个个人网站来说都是不那么重要的。
2. 域名解析 在对域名进行实名制认证之后(如果你的服务器地域在国内，还需要进行备案)，我们就可以对域名进行解析了。所谓域名解析，就是把域名的指向设置为我们购买的服务器的ip地址。域名只是一个方便我们记住的网站的名字，而我们真正需要访问的其实是服务器的那个ip地址。你也可以这么理解：我们通过域名解析来把域名和服务器关联了起来。
域名解析很简单，如果你的域名和服务器都是在阿里云购买的，可以一键解析。具体教程阿里云上写的很清楚，这里就不再赘述。
3. 把项目代码放在远程服务器上 接下来我们需要想个办法把代码搬到远程服务器上，这里我推荐使用git。我们可以把项目放在github上之后，再在远程服务器上把代码clone下来。关于git有一个很浅显易懂的教程，是廖雪峰老师写的，这是链接。
代码clone下来以后不要忘了在服务器上安装运行代码所需要的软件和依赖包。比如我的后端是nodejs所以我就需要安装node。而依赖包的安装可以借助包管理工具npm或者是yarn。具体的方法在我的另一篇文章里有，请移步。
4. 远程服务器安装数据库 前后端就准备妥当，这时候我们需要在服务器上安装数据库了。不同的数据库安装方法不同，相同的数据库库不同的操作系统安装方法也不同，这里需要根据自己的情况去找相应的文档。
如果你也是在windows系统里安装mongodb数据库的话，可以参考这个视频。
关于如何在网上准确的找到自己所需要的资料，这里我想结合我的经验说几句。找资料首先第一想到的应该是官方文档，因为官方文档是最新的，很多数据库(比如mongodb我就踩过坑)，版本的变更安装方法也会不一样，第三方网站给出的安装方法往往都是过时的，不适用的。但如果官方文档读的云里雾里怎么办？这个时候我推荐去Youtube找视频看，把视频按发布时间排序，找最新的视频看。这样再结合官方文档应该就没有问题了。
5. 文件编译 关于编译我知道的也不多，所以这里只说一下具体我是怎么操作的，留个坑以后填。
首先是前端代码的编译，前端代码里直接npm run build或者是yarn run build就可以编译出静态文件，这里的静态文件是经过压缩的，所以代码的加载速度快。另外由于我的前端代码是用ES6标准写的，执行这个编译过程(如果你正确配置了babel)也帮我把ES6编译成了服务器可以识别的ES5代码。
然后是后端，后端也使用ES6写的，所以后端也需要用babel来编译一下。
6. nginx前端配置 这里我们使用nginx主要有两个目的，第一是我们需要nginx充当我们的前端静态文件代理服务器，第二就是我们需要nginx的反向代理帮我们解决跨域的问题，因为我们这是一个前后端分离的项目，前后端运行在不同的端口上就需要解决跨域的问题。
ngnix可以去官网下载，下载完成后找到nginx.conf文件，我的是在目录C:\nginx-1.14.2\nginx-1.14.2\conf下。打开nginx.conf文件，这里我们重点关注一下server里面的配置，有几项要根据我们的具体情况进行编辑。
server { listen 80; server_name chenxin.art; root "C:/xinart/client/build"; location / { try_files $uri /index.html; } } 首先，listen在80端口，没有问题，因为我们输入网址时默认的就是访问80端口。
server_name后面应该填上你自己的域名。
root后面应该填你的前端静态文件的存放目录。
location后面的/表示当路径在主页的时候，这里不需要改动。花括号表示访问根目录里面(也就是你填写的root目录)的index.html文件。如果你的入口文件是别的名字的话记得更改。
整个连起来，着几行代码的意思就是：当输入网址chenxin.art的时候，nginx会加载root目录里的index.html文件。相信理解以后你就知道要改哪些东西了。
到这一步为止，在浏览器中输入你的域名应该可以看到静态部分的网页了，但是你会发现所有的ajax请求都会报错，因为我们的前后端还没有真正的连通，还有一个跨域的问题需要解决。
7. 解决前后端跨域问题 我们借助nginx的反向代理来解决跨域的问题。具体操作如下：在nginx.conf文件的server配置里新增几行代码，现在你的server应该如下所示：
server { listen 80; server_name chenxin.art; root "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03844735b1f120831f7b800661094f40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90116b7bcd8f24917c307c62f28a6999/" rel="bookmark">
			c语言整形数组长度_C语言获取数组长度的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何通过编程的手段获取某个数组的长度呢？
答案是使用关键字 sizeof。
前面说过，用 sizeof 可以获得数据类型或变量在内存中所占的字节数。同样，用 sizeof 也可以获得整个数组在内存中所占的字节数。因为数组中每个元素的类型都是一样的，在内存中所占的字节数都是相同的，所以总的字节数除以一个元素所占的字节数就是数组的长度。
那么如何用 sizeof 获得数组总的字节数呢？只要对数组名使用 sizeof，求出的就是该数组总的字节数。下面写一个程序看一下：
# include int main(void)
{
int a[10] = {0};
printf("sizeof(a) = %d\n", sizeof(a));
return 0;
}
输出结果是：
sizeof(a) = 40
数组 a 是 int 型的，每个元素占 4 字节，所以长度为 10 的数组在内存中所占的字节数就是 40。而总的字节数除以一个元素所占的字节数就是数组的长度，如下面这个程序：
# include int main(void)
{
int a[10] = {0};
int cnt = sizeof(a) / sizeof(a[0]);
printf("cnt = %d\n", cnt);
return 0;
}
输出结果是：
cnt = 10
这样不管数组是增加还是减少元素，sizeof(a)/sizeof(a[0]) 都能自动求出数组的长度。需要注意的是，它求出的是数组的总长度，而不是数组中存放的有意义的数据的个数。比如定义一个int型的数组：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90116b7bcd8f24917c307c62f28a6999/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a14eb87176b1799d293dacf57458e811/" rel="bookmark">
			lotus 64GB扇区 C2 使用内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 lotus 64GB扇区 C2 使用内存 C2 使用内存 170GB 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fc96b4ebcb6c2b889de1e25b8d2917d/" rel="bookmark">
			WPS的PPT 宋体 黑体显示乱码的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，要分析一下自己的显示乱码的原因，对此，我总结了两种处理方法，欢迎随时补充。 处理方案一： 首先，看一下自己是不是整个系统中的字体都是乱码。
方法一：如果系统中有微软的office软件的话，可以用微软的PPT软件打开看一下，如果字体显示正常，可能就只是WPS的原因。
方法二：用记事本或者文本文档打开，输入一些测试字符，检测一下字体能否正常显示，如果能证明就只是WPS的问题，那么就要设置WPS。
如果通过两种方法判断出来是WPS的问题，仅需要打开wps的PPT，点击 文件 —&gt; 选项 —&gt; 视图 —&gt; 禁用硬件图形加速（在前面打上勾）
处理方案二： 如果其他的程序也出现问题或者上述办法无效时，考虑此方法。
首先，需要重建系统字体库，这个一般比较困难，具体方法可以查到，我没有试，
然后测试wps，如果还不行，重装WPS软件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a859e05dfe155b1a9d7595f15b9a39a/" rel="bookmark">
			dataframe中如何筛选包含特定字符串（单个字符串、字符串列表）的列？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		里斯斯里
dataframe中如何筛选包含特定字符串（单个字符python基础教程
串、字符串列表）的列？
问题描述
dataframe的某一列均为字符串格式，想筛选出含有特定字符串的行，具体实现代码如下：
df[df['地址'].str.contains('北京') 这样就可以筛选出‘地址’这一列中含有‘北京’所对应的行了。
问题升级
但如果需要筛选不止一个地名，比如包含‘北京’、‘天津’、‘上海’…等城市所对应的行，经过测试，直接放入列表不行！
解决方法是将关键词都使用|进行连接，这样就可以一次性筛选出来了。
citys = ['北京', '天津', '上海'] address = '|'.join(citys) df_new = df[df['地址'].str.contains(address) 这样就一次性筛选出上述三个城市对应的行了。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/326/">«</a>
	<span class="pagination__item pagination__item--current">327/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/328/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>