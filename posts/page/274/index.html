<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aab88be136282c741b06cd2112c2677/" rel="bookmark">
			shiro，getPrincipals()为null的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 记录登录日志的切面，
Subject currentUser = SecurityUtils.getSubject(); ShiroUser shiroUser = null; shiroUser = (ShiroUser) currentUser.getPrincipals().getPrimaryPrincipal(); getPrincipals()这个方法怎么获取都是空，
但是token还获取成功了，也登录成功了，就是获取不到。
最后发现
token是生成了不假，但是下面的login方法当时是漏掉没加的，所以就是相当于，自己承认自己成功了，没告诉shiro，但是后面又去问shiro要登录信息，shiro当然没有。
记住不要再忘记currentUser.login(token); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40144e9841434910871556f6b2c02c20/" rel="bookmark">
			报错 | Error in render: “ReferenceError: App is not defined“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue +iview Error in render: "ReferenceError: App is not defined" (found in &lt;Root&gt;)
ReferenceError: App is not defined
突然又好了，我把项目关闭后再打开
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7999065beb877b2da1b7000b5521deb9/" rel="bookmark">
			【Python中删除字符串段首的指定字符】【lstrip()方法】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【小白从小学Python、C、Java】
【Python-计算机等级考试二级】
Python中删除字符串段首的指定字符
lstrip()方法
选择题
以下python代码输出什么?
myString="www.liujingwei.cn"
print(myString.lstrip(w))
A None
B .liujingwei.cn
C www
D ww.liujingwei.cn
欢迎大家转发，一起传播知识和正能量，帮助到更多人。期待大家提出宝贵改进建议，互相交流，收获更大。辛苦大家转发时注明出处(也是咱们公益编程交流群的入口网址)，刘经纬老师共享知识相关文件下载地址为：http://liujingwei.cn
问题解析
1.lstrip()的功能是：删除头部的多个“连续的单个字符”或多个“连续的多个字符组合”。
2.lstrip()方法的语法为：myString.lstrip([chars])，chars为可选参数，默认参数为空格、换行符、回车符、制表符。
3.lstrip()方法“删除头部重复字符”后，不对原字符串进行改变，而是将“删除头部重复字符的结果”返回。
4.题目中myString.lstrip(w)会将myString头部的多个w删除并返回删除后的字符串。
答案
正确答案是：B
温馨期待
期待大家提出宝贵建议，互相交流，收获更大，助教：lhb
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3f4a284c31360d340ca68f02561ffc4/" rel="bookmark">
			homework5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、已装完
2、
grade=input("请输入成绩") if int(grade)&lt;60: print("不及格") elif int(grade)&lt;70: print() elif int(grade)&lt;90: print("良好") elif int(grade)&lt;100: print("优秀") 3、
x=int(input("x轴")) y=int(input("y轴")) if (x==0 and y==0): print("这是原点") elif (x&gt;0 and y&gt;0): print("这是1") elif (x&lt;0 and y&gt;0): print("这是2") elif (x&lt;0 and y&lt;0): print("这是3") else: print("4") ``` 4、 `` grade=int(input("请输入成绩")) if (grade&lt;0 or grade&gt;100): input("erro,try again") else: if grade&lt;60: print("E") elif grade&lt;70: print("D") elif grade&lt;80: print("C") elif grade&lt;90: print("B") else: print("A") `` 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ada3ddb68790b98665ba03031191218/" rel="bookmark">
			Ubuntu Server21连接Wifi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装Ubuntu21,正常进入系统。打开/ect/netplan/修改yaml文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c878cd0a9b5db9999400f89100f11350/" rel="bookmark">
			大学生暑假社会实践调查问卷(HTML&#43;CSS)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图显示 HTML+CSS代码 &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;调查问卷&lt;/title&gt; &lt;style type="text/css"&gt; #div1{ width: 610px; height: 1050px; background-color: #EC4144; margin: 0 auto; border: 20px solid #EC4144; } #div2{ width: 580px; height: 1040px; border: 8px solid white; margin: 0px auto; padding-left: 10px; } h3{ text-align: center; font-size: 25px } .p1{text-indent: 2em;} #p{text-align: center} #div3{text-align: center} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="div1"&gt; &lt;div id="div2"&gt; &lt;h3&gt;大学生暑假社会实践调查问卷&lt;/h3&gt; &lt;hr&gt; &lt;p class="p1"&gt;亲爱的同学您好:&lt;/p&gt; &lt;p class="p1"&gt;为了更好地了解大学生对近年来计算机类专业填报火热现象的看法，特制定本问卷，希望得到您的配合，请认真 阅读并回答以下问题，您的回答将直接影响本调查的可信度和有效性，真诚感谢您的支持，祝你学业有成，谢谢!&lt;/p&gt; &lt;hr&gt; &lt;span&gt;1.您的姓名:&lt;/span&gt;&amp;nbsp;&amp;nbsp; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c878cd0a9b5db9999400f89100f11350/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00cdae0153af2949555b940b77941bfd/" rel="bookmark">
			org/springframework/boot/actuate/metrics/cache/CacheMeterBinderProvider not found. Make sure your ow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息如下
java.lang.IllegalStateException: Could not evaluate condition on org.springframework.boot.actuate.autoconfigure.EndpointWebMvcAutoConfiguration$EndpointWebMvcConfiguration due to org/springframework/boot/actuate/metrics/cache/CacheMeterBinderProvider not found. Make sure your own configuration does not rely on that class. This can also happen if you are @ComponentScanning a springframework package (e.g. if you put a @ComponentScan in the default package by mistake) at org.springframework.boot.autoconfigure.condition.SpringBootCondition.matches(SpringBootCondition.java:55) at org.springframework.context.annotation.ConditionEvaluator.shouldSkip(ConditionEvaluator.java:102) at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader$TrackedConditionEvaluator.shouldSkip(ConfigurationClassBeanDefinitionReader.java:443) at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader$TrackedConditionEvaluator.shouldSkip(ConfigurationClassBeanDefinitionReader.java:432) at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsForConfigurationClass(ConfigurationClassBeanDefinitionReader.java:127) at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitions(ConfigurationClassBeanDefinitionReader.java:116) at org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:320) at org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:228) at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(PostProcessorRegistrationDelegate.java:272) at org.springfram 解决办法 试一下更换redisson版本，可能是版本兼容问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00cdae0153af2949555b940b77941bfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c43bec4244e38a82ffbe99f4d1307fb/" rel="bookmark">
			node启动、关闭windows服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求： electron软件启动与关闭要同时开启与关闭一个本地数据转发服务
解决： 工具包：handleWindowsService.ts const exec = require('child_process').exec; const windowServiceStart = function (path: string) { // path必须为绝对路径 exec(`start ${path}`, function (err: any, stdout: any, stderr: any) { if (err) { throw err; } }) } const windowsServiceStop = function (port: any) { // 服务进程的端口号 let netstat_command = 'netstat -aon | findstr \":' + port + '\"'; console.log('查询服务进程...' + netstat_command); exec(netstat_command, { maxBuffer: 5000 * 1024 }, (err: any, stdout: any, stderr: any) =&gt; { if (err) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c43bec4244e38a82ffbe99f4d1307fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/108b703a5301af0f6fcd4ae656f4cc28/" rel="bookmark">
			HashMap1.8深度解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HashMap1.8剖析 1.HashMap1.8原型图 总结
从原型图上我们可以说看出，HashMap1.8的数据结构是:数组+链表+红黑树
这里我们想为什么要引入红黑树呢？
红黑树是平衡树可以提高hashmap的检索效率(时间复杂度从O(n)-&gt;O(logn))
2.我们来看作者对HashMap1.8的阐述 /** * 基于哈希表的&lt;tt&gt;Map&lt;/tt&gt;接口的实现。 这个 * 实现提供了所有可选的地图操作，并允许 &lt;tt&gt;null&lt;/tt&gt;值和&lt;tt&gt;null&lt;/tt&gt;键。 (&lt;tt&gt;HashMap&lt;/tt&gt;类大致相当于&lt;tt&gt;HashMap&lt;/tt&gt;。 * 类大致等同于&lt;tt&gt;Hashtable&lt;/tt&gt;，除了它是 * 非同步化并且允许空值）。 这个类不保证 * 地图的顺序；特别是，它不保证该顺序 * 将随着时间的推移保持不变。 * &lt;p&gt;这个实现为基本的*操作提供了恒定的时间性能。 * 操作（&lt;tt&gt;get&lt;/tt&gt;和&lt;tt&gt;put&lt;/tt&gt;）提供恒定的时间性能，假设哈希函数 * 适当地将元素分散到桶中。 迭代 * 的 "容量 "成正比的时间。 &lt;tt&gt;HashMap&lt;/tt&gt;实例的 "容量"（桶的数量）加上其大小（键值映射的数量 * 键值映射的数量）。 因此，很重要的一点是，不要把初始的 * 如果迭代性能很重要的话，不要把初始容量设置得太高（或者负载系数太低）。 * 重要。 * &lt;p&gt;一个&lt;tt&gt;HashMap&lt;/tt&gt;的实例有两个参数影响其 * 性能。&lt;i&gt;初始容量&lt;/i&gt;和&lt;i&gt;负载因子&lt;/i&gt;。 其中 &lt;i&gt;容量&lt;/i&gt;是哈希表中的桶的数量，而最初的 * 容量是创建哈希表时的容量。 负载系数 &lt;i&gt;负载因子&lt;/i&gt;是一个衡量哈希表在自动增加容量之前被允许的满载程度的标准。 * 在其容量被自动增加之前，允许哈希表达到多满的程度。 当哈希表的条目数 * 哈希表中的条目数超过了负载因子和当前容量的乘积，哈希表就会被自动增加。 * 当前的容量，哈希表会被&lt;i&gt;重新洗牌&lt;/i&gt;（也就是说，内部数据 * 结构被重建），从而使哈希表拥有大约两倍的 * 桶的数量。 * * &lt;p&gt;作为一般规则，默认的负载因子（0.75）提供了一个良好的 * 时间和空间成本之间的权衡。 更高的值会减少 * 空间开销，但增加了查找成本（反映在大多数的 &lt;tt&gt;HashMap&lt;/tt&gt;类的大部分操作，包括 &lt;tt&gt;get&lt;/tt&gt;和&lt;tt&gt;put&lt;/tt&gt;）。 地图中的预期条目数 * 在设置地图的初始容量时，应该考虑到地图的预期条目数和它的负载系数。 * 设置它的初始容量，以尽量减少 * 重洗操作。 如果初始容量大于 * 最大条目数除以负载系数，就不会发生重洗 * 操作将永远不会发生。 * &lt;p&gt;如果许多映射要存储在一个&lt;tt&gt;HashMap&lt;/tt&gt;实例中，以足够大的容量来创建它，就可以让它有足够的容量。 * 实例中，用足够大的容量来创建它将允许 * 比让它执行更有效的映射存储 * 在需要时自动重新洗牌以增加表。 请注意，使用 * 许多具有相同{@code hashCode()}的键是一个肯定的方式来减缓 * 任何哈希表的性能。为了减轻影响，当键值 * 是{@link Comparable}的时候，这个类可以使用键之间的比较顺序来帮助打破联系。 *键来帮助打破联系。 * * &lt;p&gt;&lt;strong&gt;注意，这个实现是不同步的。 * 如果多个线程同时访问一个哈希图，并且其中至少有一个 * 如果多个线程同时访问一个哈希图，并且至少有一个线程在结构上修改了该哈希图，那么它必须&lt;i&gt;&lt;/i&gt;被外部同步。 * 在外部进行同步。 (结构性修改是指任何操作 * 增加或删除一个或多个映射的操作；仅仅是改变与一个实例的键相关的值 * 仅仅改变与一个实例已经包含的键相关的值并不是 * 结构性修改）。 这通常是通过以下方式完成的 * 在一些自然封装了地图的对象上进行同步。 * * 如果没有这样的对象存在，那么地图应该被 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/108b703a5301af0f6fcd4ae656f4cc28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4123f88b45b64c3eed99b118f689ca6/" rel="bookmark">
			esmini LongSpeedAction修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 esmini的LongSpeedAction，如果shape设置为step的话，DynamicsDimension实际就无效了，
因为step的意思就是直接设置，在LongSpeedAction的Start过程中设置完就结束了，Step就不在
执行。
如果我们在step的情况下，想让LongSpeedAction持续一段时间再结束，可以这么修改。
在Start中去掉OSCAction::End()
if (transition_dynamics_.shape_ == DynamicsShape::STEP) { object_-&gt;SetSpeed(target_-&gt;GetValue()); if (!(target_-&gt;type_ == Target::TargetType::RELATIVE &amp;&amp; ((TargetRelative*)target_)-&gt;continuous_ == true)) { //OSCAction::End(); } } 在Step中加上这一句
if (transition_dynamics_.shape_ == DynamicsShape::STEP &amp;&amp; transition_dynamics_.dimension_ == DynamicsDimension::TIME) { elapsed_ += dt; if (elapsed_ &gt;= transition_dynamics_.target_value_) OSCAction::End(); return; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70bc886fe5d1c9c0fa8dbb24520354dd/" rel="bookmark">
			Rust: Box 智能指针进阶 - Rc、RefCell、Weak
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rust: Box 智能指针进阶 - Rc、RefCell、Weak 文章目录 Rust: Box 智能指针进阶 - Rc、RefCell、Weak正文1. Box 类型复习2. 自定义模拟 Box 类型3. 递归类型定义4. Box 进阶：Rc5. Box 进阶：RefCell6. 循环依赖 &amp; Weak7. 结论 其他资源参考连接完整代码示例 正文 1. Box 类型复习 Rust 内置类型: Box、Option、Result
Box 为一种特别的引用类型，实际数据存储在堆上Box 作为引用类型默认实现了 Deref 特性来实现数据访问（获取真实数据引用） 2. 自定义模拟 Box 类型 我们自定义实现 Box 类型有两个目标
作为智能指针管理真实数据的生命周期实现 Deref 特性代理真实数据的引用 下面直接看代码
/src/own_smart_pointer.rs 首先定义一个 MyBox 类型，并定义 new 方法用于构造
use std::ops::Deref; struct MyBox&lt;T&gt;(T); impl&lt;T&gt; MyBox&lt;T&gt; { fn new(x: T) -&gt; MyBox&lt;T&gt; { MyBox(x) } } 接下来实现 Deref 特性，会在引用 Box 数据的时候代理成内部数据对象的引用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70bc886fe5d1c9c0fa8dbb24520354dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ed2fd85f67a9972e06ce5651bdb6c80/" rel="bookmark">
			第五章实程教训作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		9
一、
5.
文字描述
1声明两个整型变量k，x；
2.k=0，x=0；
3.判断k &lt;= 9 &amp;&amp; x != 10真假；
4.真 执行x=x+2 然后k++，再回到第三步判断
5.假 直接输出k，x的值；
流程图
代码
#include&lt;stdio.h&gt;
int main()
{
int k, x;
for (k = 0, x = 0; k &lt;= 9 &amp;&amp; x != 10; k++)
x = x + 2;
printf("%d,%d", k, x);
return 0;
}
截图
6.
文字描述
1.声明一个字符型变量c；
2.从键盘上获取一个字符赋值给c；
3.判断获取的字符是否为‘#’；
4.字符为‘#’直接输出 不是‘#'输出一个字符 流程图
代码
#include&lt;stdio.h&gt;
int main()
{
char c;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ed2fd85f67a9972e06ce5651bdb6c80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd4276bb60436722f2817a27345b2061/" rel="bookmark">
			【TDA4系列】硬件分析与刷写程序的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TDA4 硬件分析 TDA4是AMP架构，AMP即非对称多处理器结构，简单理解为将好几种处理器集成在一块硅片上，并且不同的核运行不同的操作系统。TDA4一共有6个Cortex-R5F核，2个Cortex-A72核，2个C66核，1个C71核。如果把所有核都利用起来，需要写：
处于2个A72的Linux或者QNX的1份程序（其中openvx可以调用其他其他核的资源，OpenGL可以调用gpu的资源，2个A72是SMP架构，这里不做展开）处于6个R5F核的5份程序（mcu1_0核mcu1_1互为lockstep核），处于2个C66的2份程序，处于1个C71的1份程序。 一共10份不同的程序，不同的程序为了完成同样目标，程序之间的数据交互就非常重要了。
一个核间通信的关注点：TDA4的所有核不管在硬件上还是软件上，在内存上都是互联互通的。A72核把需要传输数据放在指定地址上，mcu1_0到指定的地址上取出数据，便完成了核间的数据交互，逻辑上非常简单，而且数据传输的时候甚至都没有经过拷贝。实现共享内存首先得找到一块合适的内存用来交互数据，因为TDA4为了提高效率，大部分内存做了缓存（cacheable），如果做了缓存，因为内存的访问速度远远比cpu的高速缓存低，修改了变量的值后，并不会马上写入到内存上，而是先写入本地cpu的高速缓存中。“因为cpu架构不同，R5F是32位处理器，A72是64位处理器，因此注意结构体中不要有类似指针这样在不同架构中长度不同的成员。”
参考链接：https://blog.csdn.net/lyp90h/article/details/121231514
刷写程序 官方写了详细的教程：https://www.ti.com.cn/cn/lit/an/spracy5/spracy5.pdf?ts=1633654253207&amp;ref_url=https%253A%252F%252Fwww.ti.com.cn%252Fproduct%252Fcn%252FTDA4VM-Q1
我总结一下
1 Flash Devices on TDA4 TDA4 板上使用的 OSPI 和 eMMC 闪存。图 2-1 描述了 SDK 中 flash 的默认布局
刷写 OSPI flash / eMMC boot partitions 补充一个知识点：
一个嵌入式 Linux 系统从软件的角度，通常可以分为四个层次。
（1） 引导加载程序。包括固化在固件(firmware)中的 boot 代码(可选)，和 BootLoader
两大部分。
（2） Linux 内核。特定于目标板的定制内核以及内核的启动参数。
（3） 文件系统。包括根文件系统和建立于 Flash 内存设备之上的文件系统。
（4） 用户应用程序。特定于用户的应用程序。有时在用户应用程序和内核层之间可能还
会包括一个嵌入式图形用户界面。
最为熟知的分区方式同时也是最主流的主要有两种：MBR（Master Boot Record）和GPT（GUID PartitionTable）。前者应用于绝大多数使用BIOS引导的PC设备（苹果使用EFI的方式），而后者主要是针对MBR的一些缺点进行了改进同时还可以兼容MBR并且支持2TB以上的存储（MBR不支持2TB以上的存储设备）。
Android 4.0版本以后就是使用的GPT分区方式。注意，不管是MBR还是GPT，他们的分区都是指“逻辑上”的！！！即通过软件实现的，文件系统级别的。而我现在要说明的是eMMC本身自己的分区，即物理上的，不是通过软件就能实现的分区。
EMMC的分区有一些是AP不能修改的（如BOOT1、BOOT2和RPMB分区），有一些是可以通过特定的命令和寄存器就可以修改的（如Enhanced Partition和GPAP）。
EMMC的UDA 分区（User Data Area）就是AP及用户可以进行读写存储的区域，通常其大小为整块EMMC表示大小的93%左右，即4GB的eMMC UDA的区域只有4GB*93%=3809MB。
Flashing eMMC User Partition 刷写 eMMC 用户分区中的文件系统
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd4276bb60436722f2817a27345b2061/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07ced2a6bc2b25bdd047fa5c1cff49c4/" rel="bookmark">
			深度强化学习(DRL)基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度强化学习（Deep Reinforcement Learning）是值得深入学习研究且非常有意思的领域，但是其数学原理复杂，远胜于深度学习，且脉络复杂，概念繁杂。强化学习是一个序贯决策过程，它通过智能体（Agent）与环境进行交互收集信息，并试图找到一系列决策规则（即策略）使得系统获得最大的累积奖励，即获得最大价值。环境（Environment）是与智能体交互的对象，可以抽象地理解为交互过程中的规则或机理，在围棋游戏中，游戏规则就是环境。强化学习的数学基础和建模工具是马尔可夫决策过程（Markov Decision Process，MDP）。一个MDP通常由状态空间、动作空间、状态转移函数、奖励函数等组成。
本文介绍与机巧围棋相关的深度强化学习基础知识，辅助理解描述阿尔法狗算法原理的强化学习语言。
1. 基本概念 状态(state)：是对当前时刻环境的概括，可以将状态理解成做决策的唯一依据。在围棋游戏中，棋盘上所有棋子的分布情况就是状态。
状态空间(state space)：是指所有可能存在状态的集合，一般记作花体字母 S \mathcal{S} S。状态空间可以是离散的，也可以是连续的。可以是有限集合，也可以是无限可数集合。在围棋游戏中，状态空间是离散有限集合，可以枚举出所有可能存在的状态（也就是棋盘上可能出现的格局）。
动作(action)：是智能体基于当前的状态做出的决策。在围棋游戏中，棋盘上有361个位置，而且可以选择PASS（放弃一次落子权利），于是有362种动作。动作的选取可以是确定的，也可以依照某个概率分布随机选取一个动作。
动作空间(action space)：是指所有可能动作的集合，一般记作花体字母 A \mathcal{A} A。在围棋例子中，动作空间是 A = { 0 , 1 , 2 , ⋯ , 361 } \mathcal{A}=\{0,1,2,\cdots,361\} A={0,1,2,⋯,361}，其中第 i i i种动作是指把棋子放到第 i i i个位置上（从0开始）,第 361 361 361种动作是指PASS。
奖励(reward)：是指智能体执行一个动作之后，环境返回给智能体的一个数值。奖励往往由我们自己来定义，奖励定义得好坏非常影响强化学习的结果。一般来说，奖励是状态和动作的函数。
状态转移(state transition)：是指从当前 t t t时刻的状态 s s s转移到下一个时刻状态 s ′ s^\prime s′的过程。在围棋的例子中，基于当前状态（棋盘上的格局），黑方或白方落下一子，那么环境（即游戏规则）就会生成新的状态（棋盘上新的格局）。
状态转移可以是确定的，也可以是随机的。在强化学习中，一般假设状态转移是随机的，随机性来自于环境。比如贪吃蛇游戏中，贪吃蛇吃掉苹果，新苹果出现的位置是随机的。
策略(policy)：的意思是根据观测到的状态，如何做出决策，即从动作空间中选取一个动作的方法。策略可以是确定性的，也可以是随机性的。强化学习中无模型方法(model -free)可以大致分为策略学习和价值学习，策略学习的目标就是得到一个策略函数，在每个时刻根据观测到的状态，用策略函数做出决策。
将状态记作 S S S或 s s s，动作记作 A A A或 a a a，随机策略函数 π : S × A ↦ [ 0 , 1 ] \pi:\mathcal{S}\times\mathcal{A}\mapsto[0,1] π:S×A↦[0,1]是一个概率密度函数，记作 π ( a ∣ s ) = P ( A = a ∣ S = s ) \pi(a|s)=\mathbb{P}(A=a|S=s) π(a∣s)=P(A=a∣S=s)。策略函数的输入是状态 s s s和动作 a a a，输出是一个0到1之间的概率值。将当前状态和动作空间中所有动作输入策略函数，得到每个动作的概率值，根据动作的概率值抽样，即可选取一个动作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07ced2a6bc2b25bdd047fa5c1cff49c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/966cf6031036fbeb481f3a201fb6b303/" rel="bookmark">
			mmdetection中的dataset
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TOV_mmdetection中的dataset 1、train.py2、build_dataset ; mmdet/datasets/builder.py3、build_from_cfg ; mmcv/utils/registry.py4、CocoFmtDataset.init ; mmdet/datasets/cocofmt.pyCocoFmtDataset.init：CustomDataset.init：一、首先将相关参数保存到属性中，值得注意的是这里的self是CocoFmtDataset。二、调用get_classes方法获取类别列表。三、拼接文件路径，这里访问文件使用的路径都是绝对路径。四、调用load_annotations方法加载标注文件中的图片信息，并将该信息存放在属性self.data_infos中。五、给self.proposal_file赋值六、过滤掉所占像素过小的标签和没有标签的图片 pipelineLoadImageFromFileLoadAnnotations_load_bboxes_load_labels ResizeRandomFlipNormalizePadDefaultFormatBundleCollect 结束 1、train.py datasets = [build_dataset(cfg.data.train)] train.py中使用上述代码实例化一个dataset。其中传入的参数如下：
2、build_dataset ; mmdet/datasets/builder.py 调用build_from_cfg()方法。其中DATASETS是提前注册好的注册库。
def build_dataset(cfg, default_args=None): from .dataset_wrappers import (ConcatDataset, RepeatDataset, ClassBalancedDataset) if isinstance(cfg, (list, tuple)): dataset = ConcatDataset([build_dataset(c, default_args) for c in cfg]) elif cfg['type'] == 'ConcatDataset': dataset = ConcatDataset( [build_dataset(c, default_args) for c in cfg['datasets']], cfg.get('separate_eval', True)) elif cfg['type'] == 'RepeatDataset': dataset = RepeatDataset( build_dataset(cfg['dataset'], default_args), cfg['times']) elif cfg['type'] == 'ClassBalancedDataset': dataset = ClassBalancedDataset( build_dataset(cfg['dataset'], default_args), cfg['oversample_thr']) elif isinstance(cfg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/966cf6031036fbeb481f3a201fb6b303/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aed1dbefde10ed6fc888dda798dcf22/" rel="bookmark">
			Vue 基础语法之计算属性(computed)、侦听器(watch)、过滤器(filters)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Vue 实例选项 在实例化Vue对象时，需要为Vue的构造函数提供一系列的配置信息，代码如下：
new Vue({ //选项 }) 当使用 new 操作符创建 Vue 实例时，可以为实例传入一个选项对象，选项对象中有很多类型的数据，具体内容如下：
数据选项：data、props、propsData、computed、methods、watchDOM选项：el、template、render、renderError生命周期选项：beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed、activated、deactivated、errorCaptured资源选项：directives、filters、components组合选项：parent、mixins、extends、provide、inject其他选项：name、delimiters、functional、model、inheritAttrs、comments 对于选项的学习，大家可以参考 Vue 官网的 API 文档，本章教程中只对 Vue 中的计算属性、过滤器、侦听器三个核心的选项做讲解。
2、计算属性（computed） 2.1、computed 的基本用法 计算属性就是 Vue 实例选项中的 computed，computed 的值是一个对象类型，对象中的属性值为函数，而且这个函数没办法接收参数，如果想为某个计算属性传参的话，可以使用闭包的方式。
这里需要注意的是，计算属性不能声明为箭头函数！ 因为箭头函数中的 this 指向的是上下文中的 this，这样就不能在计算属性的函数中获取 Vue 实例对象 this 了。
计算属性有以下特点：
模板中放入太多的逻辑会让模板过重且难以维护，使用计算属性可以让模板更加的简洁。计算属性是基于它们的响应式依赖进行缓存的。computed比较适合对多个变量或者对象进行处理后返回一个结果值，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化。 示例代码：
&lt;div id="app"&gt; &lt;p&gt;{{ total }}&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; new Vue({ el: '#app', data: { a: 1 }, computed: { total(n) { return this.a + 5 } } }) &lt;/script&gt; 在浏览器中运行的结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aed1dbefde10ed6fc888dda798dcf22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dee1847760244ea4d1f7c63818b703a1/" rel="bookmark">
			wasm逆向——（极客大挑战2021wasm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebAssembly是一种全新的Web编程语言，但是与JavaScript不同，它不是一种让你直接手动编写的语言，而是C / C ++，Rust，C＃和TypeScript等不断增加的上层语言的编译目标。
wasm是基于堆栈的虚拟机的二进制指令格式
wabt包安装
尝试了gitclone的方法，一直没安装成功，尝试：
sudo apt install wabt
我的环境：ubuntu20.4
WABT（我们将其称为“ wabbit”）是用于WebAssembly的一套工具，包括：
wat2wasm：从WebAssembly文本格式转换为 WebAssembly二进制格式wasm2wat： wat2wasm的逆函数，从二进制格式转换回文本格式（也称为.wat）wasm-objdump：显示有关wasm二进制文件的信息。与objdump类似。wasm-interp：使用基于堆栈的解释器解码并运行WebAssembly二进制文件wasm-decompile：将wasm二进制文件反编译为可读的类似C的语法。wat- desugar：解析规范解释程序支持的.wat文本格式（S表达式，平面语法或混合格式）并打印“规范”平面格式wasm2c：将WebAssembly二进制文件转换为C源代码和标头wasm-strip：删除WebAssembly二进制文件的部分wasm-validate：验证WebAssembly二进制格式的文件wast2json：将wasm spec测试格式的文件转换为JSON文件和关联的wasm二进制文件wasm-opcodecnt：计算指令的操作码使用量spectest-interp：读取Spectest JSON文件，然后在解释器中运行其测 打开压缩包，是三个这个文件
1. 静态分析： ①反汇编：
wasm2wat xorwasm.wasm -o xorwasm.wat
把wasm文件转换成webassmebly文件。
②反编译：
wasm2c xorwasm.wasm -o xorwasm.c
但是这样得到的.c代码与wasm的汇编代码没有什么区别，只是省略了⼀些出⼊栈的操作
③重新编译后⽤ida反编译进⾏优化：
之前我们得到的.c⽂件也是⽆法分析的，我们可以⽤gcc 编译.c⽂件，然后⽤ IDA 分析输出⽂件
⾸先我们要先将wabt/wasm2c⽂件夹下的wasm-rt.h和wasm-rt-impl.h头⽂件移动到我们反编译出来的.c和.h⽂件夹下
⽤gcc编译，直接gcc wasm.c会报错，因为很多wasm的函数没有具体的实现。但是我们可以只编译不链接，我们关⼼的只是程序 本⾝的逻辑，不需要真正编译出能运⾏的elf来
gcc -c xorwasm.c -o xorwasm.o
由于我没有使用clone我是去官网 上拷贝下wasm-rt.h和wasm-rt-impl.h到虚拟机中再执行
得到 xorwasm.o，放入64位IDApro
④关键函数分析：
if函数判断栈内空间，我们来看一下f11函数
几点特殊说明：f**函数一般是基本函数，print，scanf，strlen之类的
根据第一个参数猜测功能 0x400的偏移都对应常量开头，第一个参数的值减去0x400，再加上下面的基地址，就是函数所用的常量
下面我们加载看一下加密函数f10.
很简单写脚本
a=[0x35, 0x3F, 0x25, 0x1D, 0x11, 0x07, 0x15, 0x0B, 0x39, 0x2F, 0x15, 0x39, 0x35, 0x56, 0x39, 0x21, 0x09, 0x56, 0x02, 0x47, 0x47, 0x1B] for i in range(len(a)): print(chr(a[i]^ord('f')),end='') flag：SYC{wasm_Is_S0_Go0d!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dee1847760244ea4d1f7c63818b703a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f33a28da5c19a53a50223d6fbde80b1/" rel="bookmark">
			无root手机证书解决方案之VMOS&#43;小黄鸟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无root手机证书解决方案之VMOS+小黄鸟
首先简单说一下可root手机抓包的证书问题：
高版本的安卓（应该是从7.0开始）提高了安全策略，第三方证书必须放在系统区内才会生效。然而默认安装的第三方证书只是在用户区，因此很多新手抓包的时候都会碰到一抓https的包便提示无网络。
通用方法：root后用root explorer或者mt之类的文件管理器，把/data/misc/user/0/cacert-add下面的xxxx.0文件（前提是第三方的crt格式的证书已经安装了，安装形式为默认），移动或复制到/system/etc/security/cacerts 下面,移动前给予手机根目录读写权限，移动证书重启后生效。
Magisk模块方法（推荐）：现在手机root基本都用的面具，因此墙裂推荐一个Magisk模块——“Move Certificates”，在安装第三方证书之前，在Magisk模块的仓库里搜索并安装“Move Certificates”，然后重启，以后你安装的任何证书都直接在系统分区了！
下面重头戏来了——无root手机的证书方案！ 对于无法解BL的各大品牌手机还有不想root的手机，无root抓包方案我推荐：VMOS+小黄鸟
1、真机安装小黄鸟HttpCanay和安卓虚拟机vmos；
2、小黄鸟的设置中目标应用-指定为VMOS。SSL证书设置-选择导出根证书，类型System Trusted (.0)；
3、导出的证书储存路径为：内部储存/HttpCanary/cert/
4、打开虚拟机VMOS，新建一个虚拟机，推荐官方的7.1精简系统，给予root权限。
5、选择文件中转站—我要导入：你要抓包的目标APP（或者apk安装包）+xxxxx.0格式的证书；打开并赋予root explorer或者mt之类的文件管理器root权限，刚刚导入的证书自动保存在虚
拟机的VMOSfiletransferstatio目录下，将其复制到虚拟机的系统内：/system/etc/security/cacerts/目录下即可。如果无法挂载可尝试re管理器挂载读写权限。
6、返回真机启动小黄鸟，目标应用-设置VMOS-开启抓包
7、返回虚拟机-启动目标APP 即可在真机抓包了
有问题可以加群了解 80737621
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f087fb475cb9cabb8a243fa9014cdd/" rel="bookmark">
			试题 算法训练 车的放置 java 题解 996
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在一个n*n的棋盘中，每个格子中至多放置一个车，且要保证任何两个车都不能相互攻击，有多少中放法(车与车之间是没有差别的)
输入格式 包含一个正整数n
输出格式 一个整数，表示放置车的方法数
样例输入 2
样例输出 7
数据规模和约定 n&lt;=8
【样例解释】一个车都不放为1种，放置一个车有4种，放置2个车有2种。
解题思路： 车的放置是8皇后问题的简化版，当用一维数组标记时，只需考虑列不冲突就行。与8皇后不同的是，车的放置不需要将棋盘都摆满，当有某行或某列空出来也可以。最后用深度搜索加回溯解决。
java代码： import java.io.*; public class Main { public static void main(String[] args) throws NumberFormatException, IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); Temp996b temp = new Temp996b(n); temp.dfs(1);//从第一行开始摆放 System.out.println(temp.ans); } } class Temp996b{ int n; int ans = 1; boolean visited[] = new boolean[9];//表示第几列是否摆放 public Temp996b(int n) { this.n = n; } public void dfs(int step) {//表示棋子应放到第temp行 if(step &gt; n) {//递归出口：当前摆放行数超出棋盘总行数 return; } for(int i = 1; i &lt;= n; i++) { if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6f087fb475cb9cabb8a243fa9014cdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcc865dc386d84f94fa5e0ded0c090d5/" rel="bookmark">
			Docker容器操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Docker安装更换镜像源 Docker 基本操作拉取镜像创建容器启动容器创建 + 启动停止容器查看当前运行的容器查看所有容器查看最新创建的容器查看最新创建的N个容器删除容器容器重启查看端口查看容器信息查看进程查看日志容器内执行命令导出容器导入容器 你能在浪费时间中获得乐趣，就不是浪费时间。 ---- 罗素
Docker安装 Linux（CentOS、Ubuntu）：
curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun MacOS:
前往网站：https://docs.docker.com/desktop/mac/install 进行安装
Windows：
前往网站：https://hub.docker.com/editions/community/docker-ce-desktop-windows 进行安装
安装完成后执行docker -v，当显示版本后表示安装成功。
更换镜像源 避免国外镜像拉取时出现卡顿的情况，可以将镜像换成国内仓库。可以在/etc/docker/docker.json或安装好的Docker软件中找到设置中的daemon.json配置。
{ "registry-mirrors":["https://reg-mirror.qiniu.com/"] } 镜像网址：
科大镜像：https://docker.mirrors.ustc.edu.cn网易云镜像：https://hub-mirror.c.163.com七牛云加速器：https://reg-mirror.qiniu.com 配置完成后执行docker info命令，看到Registry Mirrors表示配置成功。
Docker 基本操作 拉取镜像 当本地没有的镜像的话通过docker pull命令去仓库拉取镜像。
docker pull ubuntu 创建容器 通过docker create创建容器。
docker create --name myUbuntu ubuntu --name myUbuntu表示给创建的容器起别名，此时的容器还没有启动。
启动容器 docker run -it ubuntu /bin/bash 此时已经进入到创建的ubuntu中，可以执行Liunx的ll命令查看目录，使用exit退出。
这里的-it参数中，i 表示开发容器的标准输入（STDIN），t 则表示告诉 docker，为容器创建一个命令行终端。
对于已经通过create创建的容器，也可以通过docker start name来启动。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcc865dc386d84f94fa5e0ded0c090d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d354c5374cb6e2e6ccefe9423bf0e71f/" rel="bookmark">
			mmdetection-anchor_head-loss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mmdetection之anchor_head中loss和loss_single方法 loss方法0、方法的输入与输出1、根据输入特征的尺度与图片的相关信息在相应的设别上生成anchor2、根据真实标签构造一个tensor3、整理生成anchor的格式，使之与构造的tensor相匹配4、计算预测值与真实标签之间的距离 loss_single方法0、输入与输出1、使用交叉熵计算分类损失1、使用Smooth L1计算边界框回归损失 loss方法 0、方法的输入与输出 输入
cls_scores(list[Tensor])： 每个预测框的类别得分。每个tensor的形状为：(N, num_anchors * num_classes, H,
W)，其中N表示batch_size，num_anchors表示基础anchor的数量，mun_classes表示类别数量，H、W分别表示特征图的高和宽。bbox_preds (list[Tensor]): 表示RPN输出预测框的位置，根据该值可以计算出预测框在原图上的位置。每个tensor的形状为： (N, num_anchors * 4,H, W)gt_bboxes (list[Tensor]): 表示真实标注框的位置。形状为 (num_gts, 4)的tensor，每一行表示标注框的左上角点和右下角点。gt_labels (list[Tensor]): 表示每个标注框的类别。img_metas (list[dict]): 表示输入图片的相关信息。gt_bboxes_ignore (None | list[Tensor]): 表示被忽略的标注，默认为None。 输出
dict[str, Tensor]: 一个loss字典。其中包括类别损失和边界框回归损失。 1、根据输入特征的尺度与图片的相关信息在相应的设别上生成anchor featmap_sizes = [featmap.size()[-2:] for featmap in cls_scores] assert len(featmap_sizes) == self.anchor_generator.num_levels device = cls_scores[0].device anchor_list, valid_flag_list = self.get_anchors(featmap_sizes, img_metas, device=device) 获取输入特征的尺寸。检查输入数据是否正确。获取当前工作设备。调用get_anchors()方法获取对应的anchor列表。 这里的anchor_list就是生成的anchor列表，valid_flag_list表示各个anchor是否合法。
2、根据真实标签构造一个tensor label_channels = self.cls_out_channels if self.use_sigmoid_cls else 1 cls_reg_targets = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d354c5374cb6e2e6ccefe9423bf0e71f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6581b35b4748888fa7b18a3c49ea7e5/" rel="bookmark">
			-bash: cd: /word: No such file or directory的一种解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-bash: cd: /word: No such file or directory的一种解决方法 此问题网上方案繁多，有的是书写格式错误（cd后应加空格），有的是目录尚未创建，也有的是要通过其他的创建服务手段来解决。
我这里是基于创建过“work”这个目录情况下的：
我可以通过先回到原目录下（cd ~）再重新进入想要的目录：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ff6487f9e0c326ebaf3dd42001cc2b4/" rel="bookmark">
			进制的基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进制，是人们规定的一种进位方式
表示某一位置上的数，运算时逢x进1
常见的进制 2 8 10 16
为什么学进制？？
计算机在底层运算的时候，都是以进制的进行存储运算的，便于我们深刻 理解底层的原理
在Java当中都是默认数值是十进制，不需要加任何修饰
二进制以0b开头 b大小写也是都可以的
八进制以0开头
十六进制以0x开头，x大小写都可以,书写的时候是用进制形式最后都是打印出来都是以十进制打印出来
以上的内容都是在jdk7版本以后才支持
进制的转换
快速进制转换法 8421码
8421码又称BCD码，是BCD码中最常用的一种
/
/ public static void main(String[] args) {
System.out.println(0b10);
System.out.println(010);
System.out.println(0xa);
}/
/
二进制快速转换成十进制
二进制快速转换为八进制，将三个二进制为看作一组，如果是四组就为15超过了
二进制快速转换为16进制 将四个二进制为看作一组，如果是第五组就超过范围,前四个为一组相加 后四组为一组相加，二者拼在一起就是最后的值****
学习原码，反码，补码原因
byte -128-127
计算机中的数据都是以二进制补码的形式在运算的，而补码是通过原码，反码推算出来的
原码：直观看出数据大小 0为整数，1为负数 其余表示数值大小
反码：是一个为了算出补码的一个中间变量，正数的反码与其原码相同，负数的的反码对其原码逐位取反，但是符号位不变，正数的反码与原码相同
补码，正数的补码还是原码本身，负数的补码就是末尾+1得到的
位运算
位运算指的是二进制运算，先将十进制转换为2进制后再进行运算
在二进制运算中1表示true 0表示为false
位移运算符
&lt;&lt;有符号左移运算,二进制位向左移，左边符号位丢弃，右边补齐0 规律：向左移动几位，就是乘以2的几次幂
&gt;&gt;有符号右移运算，二进制位向右移动，使用符号位进行补位（如果是正数就用0 负数就用1） 规律：向右移动几位，就是除以2的几次幂，若有小数就取整数部分
&gt;&gt;&gt;无符号右移运算，无论符号位是0还是1都补0 无论符号是0还是1都用0补位
&amp;两个都为1才1 有0则0 位或 |遇到true 为true ^异或相同为0不同为1 取反，全部取反 （包括符号位）~
异或运算的特点：
一个数被另外一个数异或两次，该数本身不变
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eee2e86c6f07f48a413c3acc39a7355/" rel="bookmark">
			DCEL(DoubleConnectEdgeList 双向链连接表)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DCEL(DoubleConnectEdgeList 双向链连接表)
DCEL用于表示平面划分:
中心线、德劳内三角划分、三角划分、维诺图等大多数平面划分结构
它连接这三种元素的关系：顶点（点Point3d）、边（有序的两个点Tuple&lt;Point3d, Point3d&gt;）、面（List&lt;Tuple&lt;Point3d, Point3d&gt;&gt;（可以转化为Polyline））
对于每一个面，内部的vector顺序都是逆时针的，最外面的外包框是顺时针的。
对于一个生成的DCEL可以进行什么操作呢？
1、对边界进行遍历寻找（寻找外包框）
从任意一个边进行顺时针走，直到遇到已经走过的点,此点之前的另一条路线全删除，留下的就是外边框。
2、通过一个面获得其旁边的面
对于这个面上的每一条边，获取反向边，通过DCEL获取这个反向边所在的多边形（面）
3、通过一个顶点获取其旁边所有链接的边
DCEL结构自带
4、拓展：给定一个DCEL描述，有一条单向线穿过这个图形，怎么找到其穿过的面?
5、遍历一个面
输入是一个边，通过这个边终点作为下一个边起点找到逆时针第一个边作为下一条边，loop直到遇到最初的起点。形成闭环。
6、加一个顶点（在某条边上）
一条对边变成两对对边，修改对应的DCEL
7、加一条边
平面分割，并修改DCEL结构
8、。。。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19d16ba9527f0e33e46797abfd7884f0/" rel="bookmark">
			TrueCrypt安装及其使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TrueCrypt是一款功能强大的磁盘加密软件，有时候我们会在电脑上放置一些重要文件，为了不让别人打开，我们就得利用TrueCrypt加密，可是很多用户不知道Win7系统TrueCrypt怎么安装及使用，为此小编赶紧整理了以下教程来帮助大家。
方法/步骤：
1、首先，下载TrueCrypt 7.1.1.0（各个版本用户操作差异不大），如图：
2、双击开始安装，选中“同意”后弹出如图，选中“Install”，点击“Next”。
3、选择安装位置，以及基本配置，可以默认，如图，点击“Install”开始安装，直到安装完成 ，完成后会提示你是否阅读它提供的说明，这里小编就不看了，有兴趣你可以点击“Yes”看一下。
4、启动，然后弹出主界面，如图，开始创建加密区域，点击红色区域按钮“Create Volume”。
5、弹出如图选项，按照默认点击“Next”，并点击“Next”。
6、同样默认，点击“Next”。
7、选择保密文件也叫保密空间，就是选择将保密空间创建在哪里，叫什么名字，选择要求，文件所在盘区剩余空间要大，这里小编选择在E盘下。
8、接上图，自己填写文件名，也就是保密空间名。
9、点击“Next”，弹出“Encryption Options”对话框，默认即可，这里配置的是加密的算法，点击“Next”。
10、弹出设置保密文件大小对话框，这里填写的大小就是之后这个保密空间的大小，保密空间等同于上面提到的保密文件，下文用保密空间，小编填写20G，这样工具会在硬盘中划分出20G的空间用于保存加密文件，点击“Next”。
11、弹出设置保密空间密码对话框，如图，填写密码，点击“Next”，会弹出提示，点击“是”即可。
12、接下来提示你是否打算在保密空间中存储大于4G的文件，这里点击“Yes”（当然按照你个人的意愿）。
13、接下来开始格式化创建保密空间，如图，点击“Format”即可。
14、如图，正在格式化，如果选择的空间比较大，可能会等一会，像小编20G，确实需要一会儿时间。
15、如图，格式化创建完成，点击“Next”，点击“Cancel”退出创建保密空间。
16、还原到主界面，如图，点击“Select File”，选中保密空间文件，再选择一个“Drive”，图中的空白区域中的盘符，小编选择“N”盘，因为在小编的电脑上没有N盘，只有C、D、E、F盘，最后点击“Mount”按钮。
17、如图，我们输入密码，点击“OK”。
18、成功挂载空间，如图：
19、打开“计算机”，我们会看到N盘，如图，好了，保密空间可以使用了，我们将要保密的文件放入到N盘中，以后要是想访问这些文件必须收下挂载保密空间，否则没有办法访问，起到加密作用。
20、我们只需要“Dismount”就可以将N盘卸载，没有密码是没有办法加载保密空间的。
以上就是Win7系统TrueCrypt安装及其使用教程了，教程比较长，不过大家只需要根据教程大胆、细心的操作下来即可成功。
Win7系统TrueCrypt安装及其使用教程 - 系统之家
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77b4cd96a58c09aab81fd3337dd1ad0a/" rel="bookmark">
			二维数组的遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 利用双重for即可
public class test4 { /* 二维数组的遍历并求和 arr={{11,22,33},{44,55,66}}遍历该数组嘛，并且打印出来 实现思路：双重for循环 1.遍历二维数组，取出里面每一个数组 2.在遍历数组中，对每一个一维数组继续完成遍历，获取内部每一个元素 */ public static void main(String[] args) { int arr[][]={{11,22,33},{44,55,66}}; int sum=0; for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt;arr[i].length ; j++) { System.out.println(arr[i][j]); sum+=arr[i][j]; } } System.out.println("最终的和为:"+sum); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84117e8ce27827432c31a46fb80d4ad9/" rel="bookmark">
			二维数组的基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class test1 { /* 二维数组索引的初始索引也是从0开始的 二维数组也是一个容器，该容器存储的是一堆容器,存储的是一堆一维数组 为什么要有二维数组？ 二维数组定义格式 int[][] arr 或者int[]arr[] 二维数组动态初始化 数据类型[][]变量名=new 数据类型[m][n]; m表示可以存放多少个一维数组 n表示一位数组中可以存放多少个元素 int[][] arr=new int[3][2] 打印出一份内存地址 @分隔符 后面就是十六进制内存地址 I表示存储的数据类型 [[两个中括号，几个中括号 几个中括号表示的几维数组 二维数组在存储一维数组的时候，存储的就是一维数组的内存 */ public static void main(String[] args) { int arr[][]=new int[2][3]; arr[0][0]=1; arr[0][1]=2; arr[0][2]=3; arr[1][0]=11; arr[1][1]=111; arr[1][2]=111; System.out.println(arr); System.out.println(arr[1][0]); } }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a82fa8c61a328143fa0e447ab3e6305/" rel="bookmark">
			如何在百度云配置SSL盾的SSL证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度云是百度旗下的综合性平台，上面有创建网站所需要的服务器功能，当然还有和网站安全相关的SSL证书功能。SSL证书主要是对网站信息传输的加密和对服务器进行身份认证，防范网站信息传输时被篡改、被截取，网站想要发展就需要安装SSL证书，近来很多浏览器都优先收录安装过SSL证书，也就是将网站链接由http变成https的网站。所以今天随SSL盾小编了解如何在百度云配置SSL盾的SSL证书。
百度云的智能服务有很多，自然也有售卖SSL证书，但是很多客户会在别的地方买SSL证书，这时候就需要在百度云进行配置了。
第一步：进入百度云官网，如果有自己的SSL证书就不用看导航栏左边的产品，直接在导航栏右边找到“管理控制台”，进去后台进行设置，如下图所示：
第二步：进入控制台之后点击左侧蓝色菜单栏，打卡之后选择产品服务-安全-SSL证书，就可以进入SSL证书管理页面，如下图所示：
第三步：进入SSL证书管理页面之后，我们已经有了SSL证书，所以就不用购买新的SSL证书，点击“证书信息管理”，如下图所示：
第四步：进入“证书信息管理”页面之后，依次操作证书管理-添加证书如下图所示：
第五步：弹出表单之后需要如实填写，一般证书是指自己的Nginx格式的SSL证书，Nginx格式的SSL证书即域名证书(服务器证书)+中间证书+根证书组成，但是在百度云添加的时候是域名证书(服务器证书)+中间证书，是少了一段的，如果没有正确填写是不会添加证书成功的。
添加成功之后，就可以在百度云的控制台中为服务器配置在ssl盾购买的SSL证书了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7316c1471c4d3a7129739e3e9fe02d1d/" rel="bookmark">
			pages.json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pages.json概述 pages.json 文件用来对uni-app进行全局配置，决定页面文件的路径、窗口表现、设置多tab页（底部导航）等。
pages.json 配置内容 （1）globalStyle Object
可选，设置默认页面的窗口表现。
（2）pages Object Array
必选，设置页面路径及窗口表现。
（3）tabBar Object
可选，设置底部tab（底部导航）的表现。
（4）condition Object
可选，启动模式配置
创建uni-app程序 下面通过新创建一个uni-app项目来记录pages.json文件的配置。
如果有uni-app项目，可以跳过该步骤，直接查看pages.json文件即可。
创建项目 目标是在多平台运行，选择uni-app(U)
项目创建完毕，会在根目录自动生成pages.json文件。
创建页面-pages 选中pages目录，右键“新建页面”，创建的页面会自动在page.json文件的pages里注册。
如下图新增了list、publish、me页面等。
此时pages.json文件会自动添加新增的页面信息。
{ "pages": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages { "path": "pages/index/index", "style": { "navigationBarTitleText": "uni-app" } } ,{ "path" : "pages/publish/publish", "style" : { "navigationBarTitleText": "", "enablePullDownRefresh": false } } ,{ "path" : "pages/list/list", "style" : { "navigationBarTitleText": "", "enablePullDownRefresh": false } } ,{ "path" : "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7316c1471c4d3a7129739e3e9fe02d1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7986c4317f7a024ff30562ceeff0198/" rel="bookmark">
			微信小程序开发之——Dialog弹窗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 概述 小程序中弹窗的两种方式：
modal弹窗WeUI组件dialog 二 弹窗原理 在布局中事先放置好要显示的Dialog布局通过一个参数dialogShow控制Dialog的显示与隐藏点击按钮时，通过 this.setData({ dialogShow: false,})改变Dialog的值并改变Dialog的状态 三 modal弹窗 3.1 布局文件(modal.wxml) &lt;view class="container-view"&gt; &lt;view&gt;主题内容&lt;/view&gt; &lt;/view&gt; &lt;!--modal--&gt; &lt;!--弹窗--&gt; &lt;view&gt; &lt;view class="modal-mask" bindtap="hideModal" catchtouchmove="preventTouchMove" wx:if="{{showModal}}"&gt; &lt;view class="modal-dialog" wx:if="{{showModal}}"&gt; &lt;video src="https://res.wx.qq.com/wxaliveplayer/htdocs/video14e1eea.mov"&gt;&lt;/video&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; 3.2 样式文件(modal.wxss) .container-view { width: 100vh; height: 100vh; display: flex; justify-content: center; align-items: center; } .modal-mask { display: flex; justify-content: center; align-items: center; position: fixed; left: 0; right: 0; top: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7986c4317f7a024ff30562ceeff0198/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e24b976c34f84a6717b2849c4daf90c7/" rel="bookmark">
			遍历数组查找数组有没有需要的数值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 public class demo8 { /* 查找 需求：已知一个数组arr={19,28,37,46,50};键盘录入一个数据，查找该数据在数组中的索引，并在控制台输出 分析：键盘录入一个数据后，将该数据与数组中的每一个值进行比较，如果数据相等，返回该数据值对应的索引即可。 */ public static void main(String[] args) { int[]arr={1,2,3,5,6}; System.out.println("请输入您要查找的元素："); Scanner sc=new Scanner(System.in); int x=sc.nextInt(); int index=-1;//假设要查找的值不存在 for (int i = 0; i &lt;arr.length ; i++) { if(x==arr[i]){ index=i; break; } } System.out.println("在该数组中索引值为："+index); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af3c5d12d63640504b3751786684ddf3/" rel="bookmark">
			使用jQuery去给元素绑定事件时，无法给新创建的元素绑定事件的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们使用jQuery库去撰写js代码的时候经常会遇到这种问题 ，比如说给某个元素绑定点击事件，原本写在文档中的元素都可以响应该事件，比如下面我点击所有的div，去修改他们的颜色。
页面骨架如下：
&lt;body&gt; &lt;section&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;/section&gt; &lt;button&gt;点我&lt;/button&gt; &lt;/body&gt; 展示效果如下：
此时我点击的第三个div那么它响应事件变成了红色
代码如下：
&lt;script&gt; $('div').click(function() { $(this).css('backgroundColor', 'red'); }) &lt;/script&gt; 此时我们在代码中创建一个div元素; $('button').click(function() { var box = $("&lt;div&gt;num&lt;/div&gt;"); $('section').append(box); }) 此时问题出现了，使用点击事件再次生成的div无法响应点击事件，为什么？
因为在我们的浏览器运行文件中的js代码时，它会通过jQuery的隐式迭代去给每一个元素绑定事件，而查找这些元素的根据就是写在选择器中的类名或者是id，在这个时候它会给现在在页面上的所有的符合条件的元素添加事件，注意，是现在在页面上的元素，而我们在页面加载完之后再通过js手动添加的页面元素则不会添加上这个事件，问题分析清楚了，那么如何解决呢？
这个时候就需要使用到on方法了，on方法用于为一个或一个系列的元素绑定事件，具体的语法如下：
$(selector).on(event,childSelector,data,function) selector是绑定的元素，event是绑定的事件的类型，childSelector是可选项，代表需要被绑定事件的子元素，子选项，data是传输到函数外的数据，function是绑定在元素上的函数。
好的，那么现在方法介绍完了，要怎么实现新元素的绑定呢？
答案就在childSelector这个选项上，下面是代码：
$('section').on('click', 'div', function() { $(this).css('backgroundColor', 'red'); }); 此时，新创建的元素就可以响应到点击事件了，因为此时的事件实际上是绑定在section盒子上面的。而div是section的子元素，所以每当我们点击section元素里的div元素的时候，就会触发该事件，改变该div元素的颜色。这样每当我们点击的时候，浏览器就会先去运行绑定在父元素上的on方法来查找类名或id符合条件的元素再运行事件，这样就避免了在页面加载完毕之前进行事件的绑定，让页面加载完毕之后再使用js生成的元素也可以享受到事件。
大家可以看到新生成的numdiv也可以响应到事件，问题解决。
（ps:第一次写博客，有错误欢迎大家指出，感谢每一个阅读者）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2d8a8c6e8f5d892b26662c187eea538/" rel="bookmark">
			什么是闭包？如何解决闭包？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是闭包：
答：当内部函数被保存到外部时，将会生成闭包。闭包会导致原有作用于不被释放，造成内存泄露。
2.如何解决闭包？
答：立即执行函数，一般用来解决闭包问题；
例：
（function (){ var a = 123; var b = 234; console.log(a+b); }()） 注：立即执行函数，执行完就会被销毁。 3.闭包实例 function test() { var arr = []; for(var i = 0;i &lt; 10; i++){ arr[i] = function(){ //给每个i赋值成函数 console.log(i) //此刻function(){}为函数声明，不能被执行 } } return arr; //将10个函数体保存到了外部，arr = [function(){console.log(i)},...,function(){console.log(i)}],此时I的值未知 } var myArr = test(); //赋值 for(var j = 0;j&lt;10;j++){ myArr[j](); //此时才执行，i = 10； } //最终输出：10，...,10(10 个10) 4.用闭包解决闭包的问题
function test() { var arr = []; for(var i = 0;i &lt; 10; i++){ (function(j){ //j为形参，此刻function为立即执行函数，无需等待，立即执行，执行后销毁 arr[j] = function(){ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2d8a8c6e8f5d892b26662c187eea538/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92a4f3518c77970e4a3b91233977c9c4/" rel="bookmark">
			人脸检测&#43;识别---04绘制矩形&#43;05检测人脸（OpenCV&#43;PyCharm适用于高中信息技术新教材）持续更新中……
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		04绘制矩形 在图像上绘制矩形和圆形还是比较简单的，直接调用opencv中的rectangle和circle函数，并给出适合的参数即可。
# 导入opencv库 import cv2 # 读取图片文件dehua.jpg（文件名不能有中文）,存入img img = cv2.imread("./images/dehua.jpg") # 坐标，（x,y）矩形左上角坐标，（w,h）矩形的宽和高 x,y,w,h=100,100,100,100 # 在图像img上绘制矩形，左上角坐标（x,y），矩形的宽和高w,h，红色外框（BGR），粗细为2 cv2.rectangle(img,(x,y,w,h),color=(0,0,255),thickness=2) # 在图像img上绘制圆形，圆心为坐标(x+int(w/2),y+int(h/2))，半径为50，蓝色外框（BGR），粗细为2 cv2.circle(img,center=(x+int(w/2),y+int(h/2)),radius=50,color=(255,0,0),thickness=2) #显示图像img cv2.imshow("img",img) while True: # 如果按下小写字母键"q",则结束循环，执行最候一句语句cv2.destroyAllWindows() if cv2.waitKey() == ord("q"): # 否则一直循环，即等待 break cv2.destroyAllWindows() # 释放内存 对应高中生来说，比较难理解的还是
while True: # 如果按下小写字母键"q",则结束循环，执行最候一句语句cv2.destroyAllWindows() if cv2.waitKey() == ord("q"): # 否则一直循环，即等待 break cv2.destroyAllWindows() # 释放内存 下面我用流程图来解释，需要对同学们理解有所帮助。
05人脸检测 用opencv进行人脸检测，一般的过程如下：
其中“将图像转换为灰度图像”、“调用人脸模型”、“获取人脸ROI”、“根据ROI进行标记”、“输出标记后的图像”这些步骤写到了函数def face_detect_demo(img)中，参数img就是读入的图像文件。
具体的代码如下：
import cv2 #自定义函数，人脸检测，参数img def face_detect_demo(img): # 转换成灰度图像 gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) # 设置人脸分类器（即用opencv内置的人脸检测模型） face_detect=cv2.CascadeClassifier("./venv/Lib/site-packages/cv2/data/haarcascade_frontalface_default.xml") # 调用人脸检测函数（参数详解见最后），得到的人脸数据存放于faces中（faces是numpy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92a4f3518c77970e4a3b91233977c9c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7330f34d159ad49e15a958a511b669b9/" rel="bookmark">
			缅怀我的虾皮，瓜皮总是马后炮，事后明明也不是不会写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import re #author:yeqibudu # pa=re.compile(r'[sS]+') #s='ssssssShopeeeeessssssss' # str=pa.findall(s) # if str: # print(str) def flongstr(s): pb=[] str2=set(s) print(str2) max=0 for i in str2: pa = re.compile(r'['+i+i.swapcase()+']+') pa=pa.findall(s) pb.append(pa) for j in range(len(pa)): lenth=len(pa[j]) # print(lenth,' ',pa) if lenth&gt;max: max=lenth tag=pa[j] # print(pa) print(tag) print('懒得注释，自己记录着玩的，有新奇思路的大佬可以相互学习一下，但是禁止囫囵照搬') #author:yeqibudu def find(num,arr,start,end): while start&lt;=end: mid=(start+end+1)&gt;&gt;1 if num&gt;arr[end] or num&lt;arr[0]: print('-1') break elif arr[mid]==num: print(mid) break elif arr[mid]&gt;num: return find(num,arr,start,mid-1) else: return find(num,arr,mid,end) else:print('-1') num=int(input('num')) arr=[]#[1,2,3]13579 n=int(input('length of arr')) for i in range(0,n): a=int(input('input')) arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7330f34d159ad49e15a958a511b669b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a992d90f30485b190b3cd6cd9ffd6159/" rel="bookmark">
			sklearn实战06：xgboost
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 梯度提升树 class xgboost.XGBRegressor (max_depth=3, learning_rate=0.1, n_estimators=100, silent=True,objective='reg:linear', booster='gbtree', n_jobs=1, nthread=None, gamma=0, min_child_weight=1, max_delta_step=0,subsample=1, colsample_bytree=1, colsample_bylevel=1, reg_alpha=0, reg_lambda=1, scale_pos_weight=1,base_score=0.5, random_state=0, seed=None, missing=None, importance_type='gain', **kwargs) 1.1 重要参数：n_estimators 对于梯度提升树来说，每个样本的预测结果表示为所有树上结果的加权求和：
其中，K是树的总数量，k代表第k棵树，γk是这棵树的权重，hk表示这棵树上的预测结果。
而对于XGB来说，每个叶子节点上会有一个预测分数（prediction score），也被称为叶子权重。这个叶子权重就是所有在这个叶子节点上的样本在这一棵树上的回归取值，用fk(xi)或者w来表示，其中fk表示第k棵决策树，xi表示样本i对应的特征向量。当只有一棵树的时候，f1(xi)就是提升集成算法返回的结果，但这个结果往往非常糟糕。当有多棵树的时候，集成模型的回归结果就是所有树的预测分数之和，假设这个集成模型中总共有K棵决策树，则整个模型在这个样本i上给出的预测结果为：
因此我们要做的第一件事是确定K，即建几棵树。
from xgboost import XGBRegressor as XGBR from sklearn.ensemble import RandomForestRegressor as RFR from sklearn.linear_model import LinearRegression as LinearR from sklearn.datasets import load_boston from sklearn.model_selection import KFold, cross_val_score as CVS, train_test_split as TTS from sklearn.metrics import mean_squared_error as MSE import pandas as pd import numpy as np import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a992d90f30485b190b3cd6cd9ffd6159/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18a54fd551c74e524efa36caf9286dbf/" rel="bookmark">
			人工智能技术在银行客服中心的应用风险
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能技术在银行客服中心的应用风险 一、人工智能在客服中心的应用现状
1、人工智能对金融业的影响
建立金融大数据系统，提升金融金融多媒体数据处理与理解能力。创新智能金融产品和服务，发展金融新业态。鼓励金融行业应用智能客服、智能监控等技术和装备。建立金融风险智能预警与防控系统。
对于金融领域来讲，人工智能的应用主要包括智能客服、智能网点、智能营销、智能风控几大块。
概要: 新一代人工智能发展规划
2、人工智能在客服中心应用场景
（1）智能客服机器人
使用自然语言理解技术，在大语料库的基础上，基于场景和业务模型开发上下文关联模型，从而实现自然叙述、智能理解这一目的。
实现由系统自动理解客户问题并进行解答和办理简单业务，如查询余额。
主要应用于网站、微信、网银、手机APP登渠道的自动问答机器人。
（2）智能语音导航
主要利用语音识别技术和自然语言理解技术理解客户语音，并根据客户的需求导航到相应节点或者引导客户完成业务办理。
主要应用在自助语音服务、手机银行APP和智能设备上。
自助语音应用
主要通过与IVR的集成实现自助语音菜单的“扁平化”，提升用户满意度
通过与客户的交互帮助客户办理相关业务，实现问题的咨询。
手机银行应用
主要为在手机银行APP上集成智能语音系统，从而实现为客户导航到手机银行相关功能，为客户办理相关业务。
（3）智能营销催收机器人-外呼机器人
通过业务场景的设计，实现自动外呼客户进行客户身份核实、催收、业务通知、满意度调查、产品营销等。
伴随着银行的转型、网贷业务的发展，主动联系客户进行关怀、营销和催收的需求会大量增长，外呼机器人是满足这些增长需求并同时控制人力成本的较好选择。
（4）智能辅助
主要应用在客服领域，机器人实时监听坐席与客户的对话。
当客户提出问题后，机器人实时理解客户的问题，并给出相关回答建议给坐席。
机器人可以实时监听坐席的话术，当发现坐席使用了违禁词、服务过程不合规或者有引起客户不满意的行为时，可以实时提醒和介入处理，从而起到推动客户服务标准的实施、提高客户满意度的作用。
（5）智能质检
基于语音识别技术实现对全量录音文件的文字转写，以及对转换后的文字进行数据分析挖掘。
发现坐席有没有使用违禁词、是否有不符合规范要求、对坐席的情绪进行监控。
分析客户来电原因、超长通话、重复来电、超长静音等通话的原因。
挖掘客户投诉原因。
对趋势进行预测，对热点问题进行分析。
挖掘潜在的营销机会。
二、目前应用中所面临的风险
1、语音识别误差带来的风险
关键字的识别错误
转账金额的识别错误，可能会给客户带来损失，从而给银行带来操作风险及声誉风险。
2、机器人回答误差带来的风险
存在不能识别客户问题或出现误答客户问题的情况。
若因为机器人的误答造成客户与机器人之间产生纠纷，恐会引起客户不满和投诉。
3、自动外呼业务带来的风险
外呼机器人通过智能语义理解技术与客户进行单轮FAQ或多轮对话交互，在缺少人工干预的情况下，如果业务模型设置不当，可能造成客户理解差异从而带来业务纠纷风险。
4、银行资料泄露风险
无论是语音识别还是客户人脸识别，都需要大量的数据材料进行模型训练，这些材料都来自于银行平时积累的各类客户数据。
这些数据包含着大量的客户隐私，一旦外泄，可能带来巨大的风险。
目前对于语音识别的模型机器学习训练，往往需要依赖供应商将寻来的材料拿到行外进行，留下了信息泄露的隐患。
5、第三方产品带来的自主可控风险
银行大多不具备自己开发人工智能算法的能力，基本采用外购人工智能算法或产品与业务系统进行整合集成的方式来实现人工智能应用。
这类产品对于银行来说都是黑盒，无法做到自主可控。
6、深度学习技术带来的效果不确定性风险
人工智能的效果验证缺乏有效的手段，从而带来不确定性风险。
7、客户满意度下降风险
在极大地节省人力的同时，强制分流导致的服务体验下降，也带来了客户满意度下降的风险。
三、应对策略
1、语音识别误差风险应对
控制语音识别业务的应用范围，将人工智能技术限定在查询等低风险的业务上。
对于高风险的业务，需要增加确认环节。
例如，在手机银行上转账业务最后需要有确认页面由客户确认。
2、机器人误答风险应对
机器人处理简单业务，复杂业务让人工来处理。
优化知识，让客户从回复中就能判断出这个知识是不是自己所提问题的答案。
提醒客户为其服务的是机器人。
3、自动外呼业务风险应对
加大模型训练的投入，提高模型训练人员的能力。对于一个业务场景设计完成后可以先试用，试用过程中不断优化。待模型成熟后再推广，采用迭代的方式不断快速优化过程。
对于一些重要场景，例如营销场景，可以通过机器人先筛选客户，当发现客户有购买意愿时转入人工，由人工提供专业的服务和营销。
可采取全过程录音方式记录外呼过程，对于容易引起歧义的业务场景，要结合按键确认等方式确认客户意图。
4、银行资料泄露风险应对
建立银行自有的人工智能深度学习平台，将数据限定在银行内部，尽量不出行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18a54fd551c74e524efa36caf9286dbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fa9eb5ce16ed776107e43bc1016acfa/" rel="bookmark">
			MySQL 5.7.21详细下载安装配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 5.7.21详细下载安装配置教程
前言
在安装MySQL的时候会遇到很多问题，博客上有很多解决问题的办法，在这里我附上一些链接，遇到问题的朋友们可以阅读参考哈~本文主要针对于刚接触数据库的小白，来安装MySQL数据库。目前官网上的MySQL版本有5.5，5.6，5.7和8，在开发的时候我们一般要选择比最新版低1到2个版本的，因此我选择了5.7作为要安装的数据库
1.下载步骤
访问官方网站：https://www.mysql.com/
选择Downloads下的Community
下载对应的版本
点击上图的MySQL Community Server,进入下载界面：
找到MySQL Community Server 5.7这一链接，点击进入：
根据你电脑的版本选择下载对应的ZIP文件，我的电脑是64位的，因此选择这项进行下载，点击Download会进入以下界面：
点击No thanks，just start my download就好，然后开始下载
下载完毕后将文件解压到你想保存到的盘和目录内。我是将文件解压到d:\Program Files\Mysql目录下面。
以上就完成了下载的全部工作。
2.配置环境变量
系统—&gt;高级系统设置—&gt;环境变量—&gt;系统变量
点击新建，变量名为：MYSQL_HOME，添加你的mysql-5.7.21-winx64文件夹所在位置。
我的是在d:\mysql-5.7.21-winx64，如图：
编辑Path，复制;%MYSQL_HOME%\bin到原有值的后面，如图：
3.配置my.ini文件
在你的mysql-5.7.27-winx64目录下新建my.ini文件，我的是在d:\mysql-5.7.27-winx64目录下新建，my.ini文件的内容为：
[mysqld]
#端口号
port = 3306
#mysql-5.7.27-winx64的路径
basedir=d:\mysql-5.7.21-winx64
#mysql-5.7.27-winx64的路径+\data
datadir=d:\mysql-5.7.21-winx64\data
#最大连接数
max_connections=200
#编码
character-set-server=utf8
default-storage-engine=INNODB
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
[mysql]
#编码
default-character-set=utf8
创建完成后进入下一步。
4.安装MySQL
1.在输入框内输入cmd，以管理员的身份运行，注意这里一定一定一定要以管理员的身份运行，否则在安装过程中会出现因为管理权限不够而导致的Install/Remove of the Service Denied!（安装/卸载服务被拒绝），这一点非常重要！
在cmd中进入到d:\mysql-5.7.21-winx64\bin目录下:
输入安装命令：mysqld -install，若出现Service successfully installed，证明安装成功；如出现Install of the Service Denied，则说明没有以管理员权限来运行cmd：
然后继续输入命令：mysqld --initialize，此时不会有任何提示：
再输入启动命令：net start mysql，出现以下提示证明MySQL启动成功：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fa9eb5ce16ed776107e43bc1016acfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9278c7d1a270cbbdccc7bd221489f35/" rel="bookmark">
			《关于sort这个狗东西，它死了……》（要用stable_sort）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这次csp用快速排序的不稳定性，在T2卡掉我好几十分
排序要用stable_sort()！！！ 排序要用stable_sort()！！！ 排序要用stable_sort()！！！ 排序要用stable_sort()！！！ 排序要用stable_sort()！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a35d2f7423c12cc9f938394dab86aa7/" rel="bookmark">
			ElasticSearch索引刷新周期(refresh_interval)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注： 部分概念介绍来源于网络
简介
当数据添加到索引后并不能马上被查询到，等到索引刷新后才会被查询到。 refresh_interval 配置的刷新间隔。
refresh_interval 的默认值是 1s。
单位：
ms: 毫秒
s: 秒
m: 分钟
如果是指定的纯数字，单位是毫秒。
当 refresh_interval 为 -1 时，意味着不刷新索引。
当需要大量导入数据到ES中，可以将 refresh_interval 设置为 -1 以加快导入速度。导入结束后，再将 refresh_interval 设置为一个正数，例如1s。或者手动 refresh 索引。
将索引的 refresh_interval 设置为 1分钟
PUT my_index/_settings
{
"index" : {
"refresh_interval" : "1m"
}
}
添加数据时忽略 refresh_interval 配置，直接触发刷新索引
POST my_index/_doc?refresh
{ "name" : "李四" }
重置 refresh_interval
PUT my_index/_settings
{
"index" : {
"refresh_interval" : null
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/451eb7de8b942a09c6c5aee4ede200d6/" rel="bookmark">
			Ansible---第二天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始练习之前：开启环境 1、设置课程
清除课程：[kiosk@foundation0 ~]$ rht-clearcourse 0
设置课程：[kiosk@foundation0 ~]$ rht-setcourse rh294
2.启用环境
启用classroom（仅一次）：[kiosk@foundation0 ~]$ rht-vmctl start classroom
启用其他服务器：[kiosk@foundation0 ~]$ rht-vmctl start all
查看状态：[kiosk@foundation0 ~]$ rht-vmctl status all
bastion RUNNING
workstation RUNNING
servera RUNNING
serverb RUNNING
serverc RUNNING
serverd RUNNING
重置环境：[kiosk@foundation0 ~]$ rht-vmctl reset servera
[kiosk@foundation0 ~]$ rht-vmctl fullreset servera
一、创建剧本config_nginx.yml。完成以下功能： 1、安装nginx 2、提供默认主页 3、启动并开机自启服务。 1.创建剧本
[student@workstation ansible]$ cat config_nginx.yml --- - hosts: dev tasks: - name: install nginx yum: name: nginx - name: index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/451eb7de8b942a09c6c5aee4ede200d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96a9256396db99ef123f98b7f76b1a93/" rel="bookmark">
			JAVA 面试大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java相关 基础&amp;进阶篇
1.什么是Java
Java是一门面向对象的高级编程语言，不仅吸收了C++语言的各种优点，比如继承了C++语言面向对象的
技术核心。还摒弃了C++里难以理解的多继承、指针等概念，，同时也增加了垃圾回收机制，释放掉不
被使用的内存空间，解决了管理内存空间的烦恼。
因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地
实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。
2. Java的特点有哪些
Java 语言是一种分布式的面向对象语言，具有面向对象、平台无关性、简单性、解释执行、多线程、安
全性等很多特点，下面针对这些特点进行逐一介绍。
面向对象
Java 是一种面向对象的语言，它对对象中的类、对象、继承、封装、多态、接口、包等均有很好的支
持。为了简单起见，Java 只支持类之间的单继承，但是可以使用接口来实现多继承。使用 Java 语言开发
程序，需要采用面向对象的思想设计程序和编写代码。平台无关性
平台无关性的具体表现在于，Java 是“一次编写，到处运行（Write Once，Run any Where）”的语言，
因此采用 Java 语言编写的程序具有很好的可移植性，而保证这一点的正是 Java 的虚拟机机制。在引入
虚拟机之后，Java 语言在不同的平台上运行不需要重新编译。
Java 语言使用 Java 虚拟机机制屏蔽了具体平台的相关信息，使得 Java 语言编译的程序只需生成虚拟机
上的目标代码，就可以在多种平台上不加修改地运行。简单性
Java 语言的语法与 C 语言和 C++ 语言很相近，使得很多程序员学起来很容易。对 Java 来说，它舍弃了
很多 C++ 中难以理解的特性，如操作符的重载和多继承等，而且 Java 语言不使用指针，加入了垃圾回
收机制，解决了程序员需要管理内存的问题，使编程变得更加简单。解释执行
Java 程序在 Java 平台运行时会被编译成字节码文件，然后可以在有 Java 环境的操作系统上运行。在运
行文件时，Java 的解释器对这些字节码进行解释执行，执行过程中需要加入的类在连接阶段被载入到运
行环境中。多线程
Java 语言是多线程的，这也是 Java 语言的一大特性，它必须由 Thread 类和它的子类来创建。Java 支持
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96a9256396db99ef123f98b7f76b1a93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a31d3e3e3af4a98f599a4717717944ed/" rel="bookmark">
			JS的this问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		daJS的this一共可分为四类。分别是：
默认绑定；隐式绑定（上下文绑定）；显式绑定；new绑定； 优先级：new绑定&gt;显示绑定&gt;隐式绑定&gt;默认绑定
那么什么是默认绑定、隐式绑定、显式绑定、new绑定呢？下面开始看例子：
var name = 'jack'; function person() { console.log(this.name); //jack } person(); 打印jack，这是因为person函数的调用环境是全局，也就是window，这就是默认绑定。需要注意的是，这是在非严格情况下，若是在严格情况下，this指向undefined。
var name = 'blob'; function foo(){ console.log(this.name); } var obj = { name: 'jack', foo:foo, } obj.foo(); //jack var foo = obj.foo; foo();//blob 打印jack是因为this的调用环境是在obj内，而这个时候的this是隐式绑定；打印blob是因为foo函数的调用环境是全局，也就是指window，这就是默认绑定了。
var name = 'blob'; function foo(){ console.log(this.name); } foo();//blob var obj = { name: 'jack', } foo.call(obj); foo();//jack 打印blob这个很好理解，它就是默认绑定。打印jack就是把foo函数通过call把它的this改为指向了obj。
function foo(name){ this.name = name; } var obj = { foo:foo } obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a31d3e3e3af4a98f599a4717717944ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55099a384cfcd666a42b3f5f662b5a51/" rel="bookmark">
			公钥密码体制1_RSA计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4.10．已知e=31，n=3599，求私钥d
答： e=31,n=3599,p=59,q=61
φ（n）=(p-1)(q-1)=3480
31d mod 3480=1
31d-3480k=1-----a
31d-8k=1------b
7d-8k=1------c
7d-k=1--------e,令d=1，得到k=6
将k=6代入c得d=7
将d=7代入b得k=27
将k=27代入a得d=3031
4.11.已知n=21，取公钥e=5，明文消息m=8，试用RSA加密m求密文c，并解密验证
加密得c = me mod n解得c=8
解密得m=cd mod n 解得 m=8
4.12已知p=43，q=59，e=13
（1）用欧几里得迭代算法求d
n=pq=2537
φ（n）=（p-1）（q-1）=2436
13d mod 2436=1
13d -2436k=1----x
13d-5k=1-----a
3d-5k=1------b
3d-2k=1------b
d-2*k=------c
令k=0，得到d=1
将d=1代入c得k=1
将k=1代入b得d=2
将d=2代入a得k=5
将k=5代入x得d=937
（2）明文 public key encryptions进行分组得=pu bl ic ke ye nc ry pt io ns
根据Z26=1520 0111 0802 1004 2404 1302 1724 1519 0814 1318
因为公钥为（13,2537）
所以加密后为：
C1=152013 mod 2537 = 0095
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55099a384cfcd666a42b3f5f662b5a51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f51a9aa793e4cbade5c67a5bb40203b1/" rel="bookmark">
			特异度（specificity）与灵敏度（sensitivity）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在论文阅读的过程中，经常遇到使用特异性（specificity）和灵敏度（sensitivity）这两个指标来描述分类器的性能。对这两个指标表示的含有一些模糊，这里查阅了相关资料后记录一下。
基础知识 考虑一个二分类的情况，类别为1和0，我们将1和0分别作为正类（positive）和负类（negative），则实际分类的结果有4种，表格如下：从这个表格中可以引出一些其它的评价指标：
ACC：classification accuracy，描述分类器的分类准确率
计算公式为：ACC=(TP+TN)/(TP+FP+FN+TN) BER：balanced error rate
计算公式为：BER=1/2*(FPR+FN/(FN+TP)) TPR：true positive rate，描述识别出的所有正例占所有正例的比例
计算公式为：TPR=TP/ (TP+ FN) FPR：false positive rate，描述将负例识别为正例的情况占所有负例的比例
计算公式为：FPR= FP / (FP + TN) TNR：true negative rate，描述识别出的负例占所有负例的比例
计算公式为：TNR= TN / (FP + TN) PPV：Positive predictive value
计算公式为：PPV=TP / (TP + FP) NPV：Negative predictive value
计算公式：NPV=TN / (FN + TN)
其中TPR即为敏感度（sensitivity），TNR即为特异度（specificity）。 参考资料 哪个大神能解释一下敏感性和特异性？学了好几年了一直不是很清楚-知乎
ROC曲线-百度百科
Positive and negative predictive values
注：文中的图片均来自参考资料。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5beb80d9fb278cca5445d2c333a2a94a/" rel="bookmark">
			Tomcat集成Skywalking的agent，多服务或多项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求描述：
需要使用skywalking监控Tomcat下面的项目链路调用跟踪，通常是需要有多个项目或者多个微服务相互调用，网上查到的案例都是配置的一个项目或者服务。下面的配置是解决多个项目或者多个服务的配置。
版本说明：
apache-skywalking-apm-8.7.0 下载地址：Downloads | Apache SkyWalkinghttp://skywalking.apache.org/downloads/
apache-tomcat-9.0.54
下载地址：
https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.54/bin/apache-tomcat-9.0.54.ziphttps://dlcdn.apache.org/tomcat/tomcat-9/v9.0.55/bin/apache-tomcat-9.0.55.zip
配置实现：
修改Tomcat配置文件:catalina.bat
文件位置：apache-tomcat-9.0.54\bin\catalina.bat
添加内容：
方式一，单个项目：
set "CATALINA_OPTS= -javaagent:D:\Tools\apache-skywalking-apm-8.7.0\agent\skywalking-agent.jar -Dskywalking.agent.service_name=demo -Dskywalking.collector.backend_service=localhost:11800" 方式二，多个项目：
set JAVA_OPTS=-javaagent:D:\Tools\apache-skywalking-apm-8.7.0\agent\skywalking-agent.jar=agent.service_name=test1,agent.service_name=test2 或者 set "CATALINA_OPTS= -javaagent:D:\Tools\apache-skywalking-apm-8.7.0\agent\skywalking-agent.jar=agent.service_name=test1,agent.service_name=test2" 说明：
agent.service_name 每个项目或者服务对应一个配置，多个项目配置多个，中间使用英文逗号分开即可。
效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15b78e557ebb0653badd307841fa1b47/" rel="bookmark">
			2021-11-25 使用kali自带的SET工具制作钓鱼网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章仅供学习和参考！
欢迎交流~
目录
一、实验题目：用SET制作钓鱼网站
二、实验内容：
三、环境准备：
四、实验步骤：
1. 打开终端，输入命令setoolkit，显示工具菜单
2. 输入1，选择菜单中的Social-Engineering Attacks(社会工程学攻击) 会显示社会工程攻击的工具
3. 输入2，选择Website Attack Vectors网站(钓鱼）攻击向导 会列出所有的网站（钓鱼）攻击的方法供你选择
4. 输入3，选择Credential Harvester Attack Method(密码收割机) 功能如其名一样
5. 输入2，选择Site Cloner，这时会提示IP address for the POST back in Harvester/Tabnabbing[你的ip]:
6. 输入需要被欺骗主机IP（本实验仅用来测试，因此输入的是本机IP）
7. 输入需要克隆的页面的网址
8. 克隆完成后如果询问是否开启Apache服务，选择开启。此时，打开输入浏览器自己的ip后就能看到克隆后的页面了
9. 输入账号密码并登录，此时账号密码已被截获
五、实验总结：
一、实验题目：用SET制作钓鱼网站 二、实验内容： 使用kali自带的SET (Social Engineering Tools)工具制作一个钓鱼网站
三、环境准备： kali虚拟机（IP：192.168.112.130）需要克隆的页面（下面以批改网为例：http://www.pigai.org/） 四、实验步骤： 1. 打开终端，输入命令setoolkit，显示工具菜单 2. 输入1，选择菜单中的Social-Engineering Attacks(社会工程学攻击) 会显示社会工程攻击的工具 3. 输入2，选择Website Attack Vectors网站(钓鱼）攻击向导 会列出所有的网站（钓鱼）攻击的方法供你选择 4. 输入3，选择Credential Harvester Attack Method(密码收割机) 功能如其名一样 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15b78e557ebb0653badd307841fa1b47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f55f8c01460648a931b8265333955244/" rel="bookmark">
			redis集群重启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、关闭redis
./redis-cli -a 密码 -c -h IP地址 -p 端口 shutdown
2、启动redis
./redis-server redis.conf
3、查看进程
ps -ef|grep redis
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daaba732ced8c872f2696d7566c14e5f/" rel="bookmark">
			【计算机网络】3数据链路层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、数据链路层设计数据链路层功能成帧差错控制 二、差错检测和纠正纠错码检错码 三、基本数据链路层协议乌托邦式单工协议（协议1）无错信道上的单工停等协议（协议2）有错信道上的单工停-等式协议（协议3） 四、滑动窗口协议一位滑动窗口协议(协议4)回退N协议(协议5)选择重传协议(协议6) 前言 DLL层设计问题
检错和纠错
数据链路层的协议 滑动窗口
数据链路层协议实例
一、数据链路层设计 数据链路层使用物理层提供的服务在通信信道上发送和接收比特。
数据链路层功能 (1)向网络层提供一个定义良好的服务接口。
(2)处理传输错误。
(3)调节数据流，确保慢速的接收方不会被快速的发送方淹没。
数据包和帧的关系：
提供给网络层的服务：
无确认的无连接服务有确认的无连接服务有确认的有连接服务无确认式指接收方在收到数据帧后无需发回一个确认无连接服务是指在数据传输前无需建立逻辑链路使用前不建立连接即不建立数据链路，但每帧传输必须得到确认，如果没有得到确认，将重传使用前先建立连接，即先建立数据链路，并且每帧的传输必须得到确认无确认并非不可靠，可靠性由上层协议负责适用于信号传播延时较大、线路状态不一定很可靠时适用于长距离不可靠的链路局域网、实时通信无线通信卫星信道、长途电话 成帧 数据链路层使用物理层提供的服务，物理层处理的是位流，数据链路层处理的是帧
为检测错误/纠正错误，将比特流拆成离散的帧，就叫成帧。
(1)字节计数法。
利用头部中的一个字段来标识该帧中的字符数。当接收方的数据链路层看到字符计数值时，它就知道后面跟着多少个字节，因此也就知道了该帧在哪里结束。
优点： 简单
缺点： 出错无法恢复，很少使用
(2）字节填充的标志字节法。
(3)比特填充的标志比特法。
这是一种面向二进制位的帧格式，把所有需传输的数据以比特位一字排开并以特殊的位模式01111110作为帧标志，即一个帧的开始（同时标志前一个帧的结束）
当帧内容中出现一个与帧标志相同的位串01111110，则在5个1后插入一0，即变成01111101，接收方将自动删除第5个1后的0。这称为位填充法，也称为透明传输。
如果由于干扰，一个帧没有正确接收，则可扫描接收串，一旦扫描到01111110，即新的一帧从此开始。即可以再同步
(4）物理层编码违禁法。
在曼切斯特编码中，连续高电平或连续低电平可用作帧边界
采用冗余编码技术，如曼切斯特编码，即两个脉冲宽来表示一个二进制位
数据0：低-高电平对
数据1：高-低电平对
高-高电平对和低-低电平对没有使用，可用作帧边界
差错控制 差错控制： 帧的校验
接收端对帧的确认（确认帧)
超时与重发（计时器)
帧的序号
流量控制： 基于反馈的流控
基于速率的流控（发送端确定，在DLL中几乎不采用)
差错类型：
单个错误突发错误分散在各块集中在各块 突发错误优点： 从优势方面来看，计算机数据总是成块发送。
突发错误缺点： 突发错误的缺点在于当它们发生时比单个错误更难以纠正。
二、差错检测和纠正 纠错码： 前向纠错技术，因其需要太多的冗余位，纠错开销太大，在有线网络中极少使用，主要用于无线网络中。
检错码 ： 只能发现错误，不能纠正，可重传，主要用于局域网
码字： 包含数据位和校验位的n位单元（模式）
海明距离： 两个码字不同位的海明距离
int x=mazi1&amp;mazi2; int distance = 0; while(x){ distance++; x -= x &amp; -x; } 海明距离越大，纠错能力越强，有效信息越少，传输效率越低
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daaba732ced8c872f2696d7566c14e5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e725b4b3cab237f4097ab3f7a5b670f/" rel="bookmark">
			Winform内存溢出的几种情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工业视觉领域，内存溢出往往是综合问题，现总结出几年来项目中遇到的内存溢出问题
一、首先明确两个概念：内存和提交内存
内存（专用工作集）/WS Private/ Private WS： 工作集的子集，它专门描述某个进程正在使用且无法与其他进程共享的物理内存值。这个值对于一个进程来说也是最重要的，它代表了一个进程到底独占了多少物理内存。
提交大小/ Private Bytes/ Private： 给当前进程使用而保留的私有虚拟内存的数量，从名字里面的Private可以看出它是专有的，但是和上面的WS Private的区别在于，WS Private是纯物理内存，而Private Bytes实际上是虚拟内存的概念，是包含WS Private的，另外一部分是在换页文件（被从物理内存里面换出去了）里面，有些内存，虽然你提交，但是如果一直没有使用，也是在页面文件（换页文件：PageFile）里面。另外，多说一句，如果要查内存泄漏，可以关注这个值。
二、明确两个概念：托管资源和非委托资源
托管资源：其中托管资源一般是指被CLR控制的内存资源，这些资源的管理可以由CLR来控制，例如程序中分配的对象，作用域内的变量等。
非托管资源：而非托管资源是CLR不能控制或者管理的部分，这些资源有很多，比如文件流，数据库的连接，系统的窗口句柄，打印机资源等等……这些资源一般情况下不存在于Heap（内存中用于存储对象实例的地方）中。
关于托管和非托管资源，详细可以参考这篇博客：​​​​​​.Net 中的托管资源和非托管资源 - Linford Xu - 博客园 (cnblogs.com) 三、视觉项目中内存溢出的几种常见情况：
1、匹配句柄没有释放
句柄ModelId属于非托管资源，一旦创建CLR不会自动释放，需要手动释放，eg:clear_shape_model ，clear_ncc_model ，如果不断重建不去释放，几个小时，内存和提交内存就爆满了
2、测量句柄没有释放
测量句柄MeasureHandle，属于非托管资源
3、队列或List的没有及时清理，比如保存图像的队列，进大于出会造成内存和提交内存不断增加
4、第三方dll，比如老版的AIDI（2.2.0-stable之前的版本）二次开发接口存在内存泄漏
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/273/">«</a>
	<span class="pagination__item pagination__item--current">274/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/275/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>