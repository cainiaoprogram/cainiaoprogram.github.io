<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0aaf3ca188739368c1a74d8f9ee5b87/" rel="bookmark">
			【10】css设置文字不换行，超过的部分用“...”代替
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置文字不换行，超过的部分用“...”代替
overflow: hidden; text-overflow: ellipsis; white-space: nowrap; width: 210px; 除width属性外，顺序不要颠倒哦！ 1.white-space ① normal 默认，空白会被浏览器忽略
② pre 空白会被浏览器保留。其行为方式类似HTML中的&lt;pre&gt;标签
③ nowrap 文本不会换行，文本会在同一行上继续，直到遇到&lt;br&gt;标签（开始换行）为止
④ pre-wrap 保留空白符序列，但是正常地进行换行
⑤ pre-line 合并空白符序列，但是保留换行符
⑥ inherit 规定应该从父元素继承white-space 属性的值
2 word-break
① normal 使用浏览器默认的换行规则
② break-all 允许在单词内换行
③ keep-all 只能在半角空格或连字符处换行
3 text-overflow
① clip ： 修剪文本
② ellipsis : 显示省略符号来代表被修剪的文本
③ string : 使用给定的字符串来代表被修剪的文本
转载于:https://www.cnblogs.com/tangiguo/p/7244019.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee20fc4f8b8759211d1bd3014006302f/" rel="bookmark">
			Android 内存溢出和内存泄漏的区别以及造成的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转载请标明出处：http://blog.csdn.net/qq_28607155/article/details/76148989
一、原理 内存溢出（Out of memory）:系统会给每个APP分配内存也就是Heap size值，当APP所需要的内存大于了系统分配的内存，就会造成内存溢出；通俗点就是10L桶只能装10L水，但是你却用来装11L的水，那就有1L的水就会溢出
内存泄漏（Memory leak）:当一个对象不在使用了，本应该被垃圾回收器（JVM）回收，但是这个对象由于被其他正在使用的对象所持有，造成无法被回收的结果，通俗点就是系统把一定的内存值A借给程序，但是系统却收不回完整的A值，那就是内存泄漏
二、两者的关系 内存泄漏是造成内存溢出（OOM）的主要原因，因为系统分配给每个程序的内存也就是Heap size的值都是有限的，当内存泄漏到一定值的时候，最终会发生程序所需要的内存值加上泄漏值大于了系统所分配的内存额度，就是触发内存溢出 三、危害 内存溢出：会触发Java.lang.OutOfMemoryError，造成程序崩溃 内存泄漏：过多的内存泄漏会造成OOM的发送，同样也会造成相关UI的卡顿现象 四、造成的原因以及处理 A、大量的图片、音频、视频处理，当在内存比较低的系统上也容易造成内存溢出 建议使用第三方，或者JNI来进行处理 B、Bitmap对象的不正确处理（内存溢出） 不要在主线程中处理图片使用Bitmap对象要用recycle释放 高效的处理大图，这里就不详细介绍了，建议郭神的文章 C、非静态匿名内部类Handler由于持有外部类Activity的引用所造成的内存泄漏 根据WeakReference对象，对handler使用弱引用，并且调用removeCallbacksAndMessages移除 D、线程由于匿名内部类runnable持有activity的引用，从而关闭activity，线程未完成造成内存泄漏 把线程改成静态内部类，调用WeakReference来持有外部资源 E、BraodcastReceiver、File、Cursor等资源的使用未及时关闭 在销毁activity时，应该及时销毁或者回收 F、static关键字修饰的变量由于生命周期过长，容易造成内存泄漏 尽量少使用静态变量，一定要使用要及时进行制null处理 G、单列模式造成的内存泄漏，如context的使用，单列中传入的是activity的context，在关闭activity时，activity的内存无法被回收，因为单列持有activity的引用 在context的使用上，应该传入application的context到单列模式中，这样就保证了单列的生命周期跟application的生命周期一样单列模式应该尽量少持有生命周期不同的外部对象，一旦持有该对象的时候，必须在该对象的生命周期结束前制null 注：好的代码习惯才能更好的写出高效代码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb03cb3459055fc7df048d3f276106ba/" rel="bookmark">
			网站如何解决图片过大加载慢的问题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 看看这些人的想法能不能帮上你：
甲：
1，不太“在乎”用户体验的省事方法：
图片保存成渐进式的，加载会慢慢变清晰，而不是从上往下依次加载，然后放在 CDN，设置缓存之类。
2，比较“在乎”用户体验的高端方案：
判断用户的设备（主要用在移动端）、网络等，分别加载不同质量的图片（例如高端 iPhone wifi 情况下，就可以加载双倍高清图等，蜂窝网络下面，就加载个单倍或者有损压缩过的）。
或者先加载低质量的图片，让浏览者可以看到，然后再在后台加载更高清的，等加载完了，浏览者还在观看，就插入替换掉。或者先加载低质量小图片列表，然后让用户点击，触发类似 fancybox 的效果，弹窗出现大图片。或者利用资源预加载（三个 HTML5 不常见特性简介）当用户还没打开的时候，就开始加载。还有好多思路，后面想到再补充。
乙：
压缩，预加载，缓存，图床。
丙：
1.使用缓存
2.使用CDN加速
3.使用jq延迟加载图片, 用到那个 加载哪个.
4.加大服务器宽带
5.检查服务器硬盘读取速度.
丁：
要尽可能的压缩，看用户的忍受程度。jpg 可以用很多方法压缩，png 推荐使用 工具（不过正文图片，显然要选择 jpg 格式的）。
推荐个压缩图片的神器：
https://tinypng.com/ 如图所示：
不过缺点就是不能设置压缩比例。只能直接压缩至最小。作为大banner图的有时候清晰度就不够达标。
戊：
直接一开始用压缩过的体积小的图，等加载完毕后，再用高清无码图来替换掉
高清无码的图片随便怎么命名，但是压缩过的命名有要求，那就是必须在原图的名称前面加上相同的便于分辨的标识。比如
高清图1命名为wozuishuai.jpg 那么相应的压缩图就叫wozuishuai_min.jpg (_min这个随你取名，但是要一致，不能一个叫_min,下一个就成了_small)
然后，高清图在网页上都不用，用压缩过的图。比如这样子
这样子，你打开网页的速度就会快很多，但是图片会失真，虽然有的时候不影响使用，但是会影响用户的体验，以及老板拍桌子骂你干什么吃的？ 不用怕，可以用下面这段代码来解决这个问题，这个是基于jq的，要先引入jq &lt;script&gt; $(function(){ //一段正则，匹配所有_min.的图片src属性 var test = /_min\./ //遍历所有的图片节点 $("img").each(function(index,obj){	if(test.test($(this).attr("src"))){ var reSrc = $(this).attr("src").replace(test,"."); $(this).attr("src",reSrc) }	}) }) &lt;/script&gt; 最后我们用一张图来测试下这个方法的可行性 其实不用1s，这些图基本上都可以用了，都可以看了，只不过我们这个是东郭先生，滥竽充数，但是最起码能知道图片讲的什么内容。但是，如果只加载高清图，那么，用户势必要等待好几s甚至十几s。这样的话，用户是很容易抛弃这个网站的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb344d95750c40aafb8dca191453f17/" rel="bookmark">
			解决文件嵌套太深无法删除问题。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在搭建前端构建工具gulp时，存在一个文件夹node_modules怎么删都删不掉。
一.首先可以用del以及rd
----------------------------------------------百度经验上原文开始---------------------------------------------
如果你要删除的整个文件夹以及文件夹里面的所有内容的话rd/s/q 盘符:\某个文件夹 （这样整个文件夹所有的文件和文件夹都删除了）比如我想删除D盘的123文件夹以及123文件夹里面所有的内容rd/s/q d:\123 这样就删除了如果只是单独删除某个文件的话用del/f/s/q 盘符:\文件名比如我想删除D盘的456文件夹里面的789这个记事本文件 del/f/s/q d:\456\789.txt删除文件的话记住要加上它的后缀名 -------------------------------------百度经验原文结束----------------------------------- 二.如果还是不行，那就用Robocopy 1&gt;首先在http://download.zol.com.cn/detail/10/91484.shtml下载robocopy。 2&gt;然后将压缩文件中的robocopy.exe复制到你想要删除的文件夹同级目录下。比如我想要删除F:\project\node_modules这个文件夹，那我就这样放F:\project\robocopy.exe. 3&gt;在F:\project\下新建一个文件夹del1 4&gt;打开cmd命令（windows+R键），然后转到想要删除文件所在盘（这里是F盘，命令F:回车） 5&gt;在F:\project下输入命令 robocopy/mir del1 node_modules（注：robocopy/mir del1 想要删除的文件夹名称这里是mode_modules） 6&gt;等待命令执行完，这时可能还未删除完，就要多运行几次这个命令，因为他是一层一层删除的，每次执行命令可看到路径在慢慢减少，直至减少到最外层为止，这时可以打开node_modules文件夹，会看到里面已经为空。 7&gt;这时，即可手动删除此文件夹。搞定！ 8&gt;原理：此命令会将目标文件夹内容改成del1文件夹内容，del1文件夹内容为空，所以node_modules文件夹内容会清空。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e65f68f7fdfc4219f9fa869c7e4b4ac6/" rel="bookmark">
			VS简易示波器（四）：绘制波形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示波器的基本框架搭建好了，接下来开始绘制波形（调试上位机软件阶段，我以产生随机数为例，以下只为部分关键代码）：
1） 在子属性对话框中添加8个通道选择复选框；
2） 定义复选框控件变量并在OnInitDialog()中关联：
CButtonm_checkDn[8];
for (int i = 0; i &lt;8; i++){
m_checkDn[i].SubclassDlgItem(IDC_CHECK_D0+ i, this); //关联控件
}
3） 在发送按钮响应函数中将通道设置参数发送到主对话框：
USHORT usData = 0;
UCHAR temp = 0x01;
for (int i = 0; i &lt;8; i++){
if (m_checkDn[i].GetCheck()){
ucCmd = ucCmd | temp;
}
temp = temp &lt;&lt; 1;
}
m_cmddata.m_ucCmd = 0xFF;
m_cmddata.m_usData = usData;
::SendMessage(this-&gt;GetParent()-&gt;m_hWnd,WM_FDM_MESSAGE, DWORD(&amp;m_cmddata), DWORD(0));
4） 在主对话框中接收信息函数中，根据参数启动定时器：
cmddata* m_cmddata = (cmddata*)wParam;
m_ucCmd = m_cmddata-&gt;m_ucCmd;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e65f68f7fdfc4219f9fa869c7e4b4ac6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5284806f75462382dc5bd5efe76e5ca2/" rel="bookmark">
			iOS UITableView禁止滚动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [firstViewsetHidden:NO]; //tableview上层的view不隐藏 self.tableView.scrollEnabled =NO; //设置tableview 不能滚动 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/606405d551b697dc69c9af122af3379c/" rel="bookmark">
			异步赠书:AI专栏（AI圣经！《深度学习》中文版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新活动:邀请10名好友关注微信公众号“异步图书”，10天，即可获得异步图书一本。
点击立即参与活动
今天小编开启了大咖重磅新书赠送活动，如果你热爱读书、热爱技术，参与到异步赠书活动中来，都有机会得到新书中的一本哦~~
本次活动已结束，没有抢到《深度学习中文版》的读者，还可以到异步社区最新送书活动："异步社区两周年庆，豪送20本书"猛击下方地址，共计1000多种IT图书免费任你选，人工智能、python、Android、深度学习、机器学习不限量
http://blog.csdn.net/epubit17/article/details/76811996
获奖读者公布名单
请在如下表单中填写邮寄信息，活动名称为：异步赠书:AI专栏（AI圣经！《深度学习》中文版）
https://www.wenjuan.com/s/eEzyYf/
《python高性能编程》
liuhmmjj yuexin2
《深度学习》
资深架构师 极简
《机器学习WEB应用》
UsherYue sjf0115
《机器学习实践应用》
c123853648 roguesir
《实用机器学习》
konglingshneg
敲重点: 活动规则：试读样章，评论区留言说一下你对本书的一些感想，同时关注异步社区博客，并留言你想要得到的图书。
活动时间：即日起-8月5日（活动奖项公告在8月8日日）
赠书数量：10本（每个品种2本） 先到先得！
更多好书可以来人邮社异步社区查看，申请下期活动：http://www.epubit.com.cn/ 新书目录
1.《深度学习》
2.《机器学习实践应用》
3.《机器学习WEB应用》
4.《python高性能编程》
5.《实用机器学习》 异步大咖新书
特别推荐：
《深度学习》AI圣经！美亚排名第一名，深度学习奠基性产品！
AI圣经 Deep Learning中文版 深度学习领域奠基性的经典畅销书
长期位居美国亚马逊AI和机器学习类图书榜首 特斯拉CEO埃隆·马斯克等国内外众多专家推荐
“花书”简介
深度学习是机器学习的一个分支，它能够使计算机通过层次概念来学习经验和理解世界。因为计算机能够从经验中获取知识，所以不需要人类来形式化地定义计算机需要的所有知识。层次概念允许计算机通过构造简单的概念来学习复杂的概念，而这些分层的图结构将具有很深的层次。本书会介绍深度学习领域的许多主题。
“花书”囊括了数学及相关概念的背景知识，包括线性代数、概率论、信息论、数值优化以及机器学习中的相关内容。同时，它还介绍了工业界中实践者用到的深度学习技术，包括深度前馈网络、正则化、优化算法、卷积网络、序列建模和实践方法等，并且调研了诸如自然语言处理、语音识别、计算机视觉、在线推荐系统、生物信息学以及视频游戏方面的应用。最后，本书还提供了一些研究方向，涵盖的理论主题包括线性因子模型、自编码器、表示学习、结构化概率模型、蒙特卡罗方法、配分函数、近似推断以及深度生成模型。
《深度学习》（“花书”）既可以被本科生或研究生用于规划其学术界或工业界生涯，也适用于希望在各种产品或平台上开始使用深度学习技术的软件工程师。作者在本书的配套网站上为读者和教师提供了补充资料。
购书地址：https://item.jd.com/12128543.html
试读地址：http://www.epubit.com.cn/book/details/4278
1.《机器学习实践应用》
编辑推荐： 人工智能，触手可及，让数据起舞，用算法扩展业务边界 。　阿里机器学习专家力作，实战经验分享 这是一本难得的面向机器学习爱好者的入门级教程，本书涉及机器学习的基础理论 和深度学习等相关内容，内容深入浅出。更加难能可贵的是，本书基于阿里云机器学习平台，针对7个具体的业务场景，搭建了完整的解决方案，给读者带来第一手的实战演练经验。
——阿里云资深专家 褚崴
机器学习算法正在逐渐渗透到数据化运营的各个方面，算法和业务数据相结合可以大幅度地提高业务效率、降低成本。本书以算法的业务应用作为切入点，包含大量的案例说明，非常适合读者快速入门。
——阿里云高级专家 陈鹏宇
内容简介：
本书通过对机器学习的背景知识、算法流程、相关工具、实践案例以及知识图谱等内容的讲解，全面介绍了机器学习的理论基础和实践应用。书中涉及机器学习领域的多个典型算法，并详细给出了机器学习的算法流程。
本书适合任何有一定数据功底和编程基础的读者阅读。通过阅读本书，读者不仅可以了解机器学习的理论基础，也可以参照一些典型的应用案例拓展自己的专业技能。同时，本书也适合计算机相关专业的学生以及对人工智能和机器学习感兴趣的读者阅读。
试读地址：http://www.epubit.com.cn/book/details/4757 购书地址：https://item.jd.com/12114501.html
2.《机器学习WEB应用》 编辑推荐：
·eBay公司EU Analytics部门负责人Davide Cervellin作序推荐
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/606405d551b697dc69c9af122af3379c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88fa00bf79e9da4e672cfee10fcccba4/" rel="bookmark">
			Fix fatal: Couldn&#39;t find remote ref refs/heads/xxx [core] fatal: The remote end hung up unexpectedly
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 造成原因 本地 git 分支出现异常 解决方案 切换到仓库根目录
$ vim .git/config （备注：红色git小写）
找到其中的一条内容 [remote "origin"] 修改其中的fetch为：fetch = +refs/heads/*:refs/remotes/origin/*
再次尝试 $git pull 拉取最新的代码之后，成功！
参考 https://stackoverflow.com/questions/6930147/git-pull-displays-fatal-couldnt-find-remote-ref-refs-heads-xxxx-and-hangs-up 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89d30a6a90bcbeb0d2f7fe8c5acf39fb/" rel="bookmark">
			TX2--NVIDIA Jetson TX2 开箱使用--精贴（jetpack）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开箱验货
1、本人作为NVIDIA Jetson TX2新手，刚拿到开发板的时候，很是惊喜，毕竟这么高配置的板子以前没接触过，当然开始比较束手束脚，怕一不好，闹坏了，不过这板子质量还是很好的，按照教程放心用，哈哈！
2、拿到东西时是这样的，如下图：
3、拆开后所有东西如下图
、
二、第一次运行 Jetson TX2
1、新手上手之前需要配备相应的外设和连接线
（1）首先需要1个显示屏、1根显示屏电源线、1根视频连接线。
注：TX2上是HDMI接口，如果显示屏和本人一样是VGA接口，那就需要1根转接线。
（2）本人的TX2配件中只有电源适配器，没有电源线，所以自己准备了电源线。
注：台式机或笔记本电源线就能直接用。
（3）还需要一个USB hub，这是要自己配备的。
（4）鼠标和键盘就简单了，手边就有。
2、准备好后就开始动手连接了，本人连接图如下
3、接着就是上电，本人的TX2上电后风扇不转的，这是正常情况（我当时以为坏了，⊙﹏⊙b汗！ ）上电后界面如下：
4、输入命令就是如下,看图，最后出现 success时就出现预装的ubuntu 系统图形界面：
5、之后就是刷机了，刷机的步骤在另一篇博客中 ^...^
致谢
1、参考视频（该视频讲的是TK1的开箱加电，不过TK1和TX2的开箱上电没区别，我就照着该视频做的！）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eba48f30dceb56d1848eb3de0777df03/" rel="bookmark">
			Android 检查应用包名是否存在并启动或安装指定包名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先，获取应用中所有程序的安装包信息，收集在集合中，然后进行循环判断：
private boolean isAvilible( Context context, String packageName ){ final PackageManager packageManager = context.getPackageManager(); // 获取所有已安装程序的包信息 List&lt;PackageInfo&gt; pinfo = packageManager.getInstalledPackages(0); for ( int i = 0; i &lt; pinfo.size(); i++ ) { // 循环判断是否存在指定包名 if(pinfo.get(i).packageName.equalsIgnoreCase(packageName)){ return true; } } return false; } 2、然后，启动或安装：
if(isAvilible(MainActivity.this, "com.tencent.mm")){ Intent i = new Intent(); //启动指定包名应用 ComponentName cn = new ComponentName("com.tencent.mm", "com.tencent.mm.WeiXinActivity"); i.setComponent(cn); startActivityForResult(i, RESULT_OK); } else { Uri uri = Uri.parse("market://details?id=com.tencent.mm");//市场下载 // 直接从指定网址下载 // Uri uri = Uri.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eba48f30dceb56d1848eb3de0777df03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf5406f7548f6295126addca7dfcf419/" rel="bookmark">
			eclipse cleanup svn时卡死或者失败的一种解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常遇到一种情况，在进行pull或者push时，svn报错，提示你应该cleanup一下，但当你cleanup时，要么就卡死，要么就报错，说是在cleanup过程中需要等待其他操作。这种情况可能是由于，以前的某次SVN操作在没有执行完就被强行终止了，导致svn会根据记录的操作尝试恢复原来的操作，或者revert到失败操作之前的状态。
网上查了写资料最后把目标锁定在项目文件.svn里的wc.db文件上。
这里面的work_queue表中是用来记录svn.的操作队列的。标题描述的问题，很大一种可能就是在强行终止svn操作时该表出现了问题。所以
解决方法：
step1: 到 sqlite官网 (http://www.sqlite.org/download.html) 下载 sqlite3.exe 找到 Precompiled Binaries for Windows，点击 sqlite-shell-win32-x86-3080500.zip 下载，300KB左右
step2: 将下载到的 sqlite3.exe 文件复制到 本地磁盘的某个临时目录下 （我的svn源代码放在共享磁盘中，发现 sqlite老是找不到 svn的 wc.db文件），
step3: 然后 设置 svn源代码 文件夹 及文件 显示 所有文件（包括隐藏文件），会发现 .svn/wc.db 文件， 将 其复制到 step2的临时目录下
step4: 开始 -&gt; 运行 -&gt; 打开 cmd命令
打开 wc.db
执行 delete from work_queue;
如图所示：
step 5: 将 wc.db 覆盖到 svn源代码目录的 .svn目录下
step 6: 对 svn源代码目录 右键, clean up, 稍等1至5分钟左右，然后会提示 清理成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf5406f7548f6295126addca7dfcf419/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa616002491cfb0bc1568a87f1ea2b6/" rel="bookmark">
			&amp;与&amp;&amp;的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，&amp;与&amp;&amp;的区别
按位与：a&amp;b是把a和b都转换成二进制数然后再进行与的运算；
逻辑与：a&amp;&amp;b就是当且仅当两个操作数均为 true时，其结果才为 true，只要有一个为false，a&amp;&amp;b就为false。
&amp;&amp;进行的是短路判断，即如果左侧的表达式的结果为false，整个的结果就为false，不再计算右侧的表达式的值。
例如：
int main() { int a = 0, b = 1; a &amp;&amp; b ++; //a为0，即左侧的表示的结果为false，整个的结果就为false，不再计算右侧的表达式 cout&lt;&lt;b; return 0; } 输出结果
1 Process returned 0 (0x0) execution time : 0.045 s Press any key to continue. 二，||与|的区别
1，&amp;&amp;和||是短路运算符，&amp;和|是非短路运算符。
2，&amp;&amp;与&amp;区别：两者都表示“与”运算，但是&amp;&amp;运算符第一个表达式不成立的话，后面的表达式不运算，直接返回。而&amp;对所有表达式都得判断。
3，|| 与|区别：两者都表示“或”运算，但是||运算符第一个表达式成立的话，后面的表达式不运算，直接返回。而|对所有表达式都得判断。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ec49c8ad7d961bc78f7bfa5fc420e39/" rel="bookmark">
			无法安装程序包“Newtonsoft.Json 6.0.4”。你正在尝试将此程序包安装到目标为“.NETFramework,Version=v4.7”的项目中，但该程序包不包含任何与该框架兼容的程序集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天在ConsoleApp里面安装SignalR.SelfHost，但是默认的SelfHost安装的JSON文件是6.0.4不兼容.NET框架，只要手动安装上JSON，再安装SignalR.SelfHost的时候，就不会安装默认的JSON了，也就不会出错了。
Install-Package : 无法安装程序包“Newtonsoft.Json 6.0.4”。你正在尝试将此程序包安装到目标为“.NETFramework,Version=v4.7”的项目中，但该程序包不包含任何与该框架兼容的程序集引用或内容文件。有关详细信息，请联系程
序包作者。
所在位置 行:1 字符: 1
+ Install-Package Microsoft.AspNet.SignalR.SelfHost
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ CategoryInfo : NotSpecified: (:) [Install-Package], Exception
+ FullyQualifiedErrorId : NuGetCmdletUnhandledException,NuGet.PackageManagement.PowerShellCmdlets.InstallPackageCommand
========== 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f357c925cf5e568b1ae900b7f8ea699/" rel="bookmark">
			C&#43;&#43; Socket编程（二） send与recv 缓冲区与阻塞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		socket缓冲区 每一个socket在被创建之后，系统都会给它分配两个缓冲区，即输入缓冲区和输出缓冲区。 send函数并不是直接将数据传输到网络中，而是负责将数据写入输出缓冲区，数据从输出缓冲区发送到目标主机是由TCP协议完成的。数据写入到输出缓冲区之后，send函数就可以返回了，数据是否发送出去，是否发送成功，何时到达目标主机，都不由它负责了，而是由协议负责。
recv函数也是一样的，它并不是直接从网络中获取数据，而是从输入缓冲区中读取数据。
输入输出缓冲区，系统会为每个socket都单独分配，并且是在socket创建的时候自动生成的。一般来说，默认的输入输出缓冲区大小为8K。套接字关闭的时候，输出缓冲区的数据不会丢失，会由协议发送到另一方；而输入缓冲区的数据则会丢失。
socket数据发送与接收问题 数据的发送和接收是独立的，并不是发送方执行一次send，接收方就执行以此recv。recv函数不管发送几次，都会从输入缓冲区尽可能多的获取数据。如果发送方发送了多次信息，接收方没来得及进行recv，则数据堆积在输入缓冲区中，取数据的时候会都取出来。换句话说，recv并不能判断数据包的结束位置。
send函数： 在数据进行发送的时候，需要先检查输出缓冲区的可用空间大小，如果可用空间大小小于要发送的数据长度，则send会被阻塞，直到缓冲区中的数据被发送到目标主机，有了足够的空间之后，send函数才会将数据写入输出缓冲区。
TCP协议正在将数据发送到网络上的时候，输出缓冲区会被锁定（生产者消费者问题），不允许写入，send函数会被阻塞，直到数据发送完，输出缓冲区解锁，此时send才能将数据写入到输出缓冲区。
要写入的数据大于输出缓冲区的最大长度的时候，要分多次写入，直到所有数据都被写到缓冲区之后，send函数才会返回。
recv函数： 函数先检查输入缓冲区，如果输入缓冲区中有数据，读取出缓冲区中的数据，否则的话，recv函数会被阻塞，等待网络上传来数据。如果读取的数据长度小于输出缓冲区中的数据长度，没法一次性将所有数据读出来，需要多次执行recv函数，才能将数据读取完毕。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb8ad534b0c0cec2804263658f986e41/" rel="bookmark">
			cs231n作业一之 在cifar-10上实现KNN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网上也看了好多代码，但是都运行不了，要不是代码问题，要不就是路径问题，本代码已经成功运行过，主要有两个问题需要注意 1.python2和python3的版本不兼容，有一些语法不同，需要改 2.关于导入cifar-10数据库，我是用的在cs231n熵下载的数据库，我直接吧数据库托到和你写代码存储的根目录的位置就可以了 import pickle as p import matplotlib.pyplot as plt import numpy as np # NearestNeighbor class class NearestNeighbor(object): def __init__(self): pass def train(self, X, y): """ X is N x D where each row is an example. Y is 1-dimension of size N """ # the nearest neighbor classifier simply remembers all the training data self.Xtr = X self.ytr = y def predict(self, X): """ X is N x D where each row is an example we wish to predict label for "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb8ad534b0c0cec2804263658f986e41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5be378a7d8818e6c256591879fc2b59/" rel="bookmark">
			MVG读书笔记——几何变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		德国著名数学家Felix Klein在他的Erlangen纲领中提出：“几何就是研究变换中的不变性的学科。”事实上，几何变换在几何的研究中占有重要地位。也是图形学应用的基础。下面我们就对常用的几何变换进行介绍：
欧氏变换 提到几何变换，最先想到的就是图形的平移和旋转，图形的平移和旋转统称为图形的欧氏变换，一个典型的欧氏变换如下图： 可以看到，从左边的正方形变成右边的正方形分为两步。一是将它沿着某方向进行平移。这一步可以用一个向量t = [x,y]T 来进行表示。t表示的平移的方向和长度。二是将它绕中心旋转一定的角度 α 。这一步可以用一个矩阵 R=[cosαsinα−sinαcosα] 来表示。 由此，左边正方形上一点x和右边正方向上一点 x′ 满足关系 x′=Rx+t 使用齐次坐标，我们可以将R和t合成一个3X3的矩阵H来简化运算。 H=[R0t1] H又称为单应性矩阵。欧氏变换在变换前后保证了线段长度的不变性。 单应矩阵 事实上，对于任意的一种几何变换，我们都可以找到一个矩阵，使得变换前后的对应点 x,x′ 满足 x′=Hx 。
同样的，对于变换前后的两幅图像，我们可以通过取多对对应点的坐标，得到它们的单应矩阵H，这在图形学和计算机视觉的很多方面都用应用。
由于 x′、x 都是齐次坐标表示，由上一节我们知道（x,y,1)和（2x,2y,2)表示同一个点。因此对单应矩阵乘一个系数k不会改变变换关系。即对任意 k∈R,k≠0 ，kH与H是等价的。对3X3的平面单应矩阵，它的自由度为8。
显然，H是一个可逆矩阵，对H求逆得到了H的逆变换，即 x=H−1x′ 。
同时可以看到由于采用了齐次坐标，对逆变换的求解也大大的简化了。以欧氏变换为例。由于 x′=Rx+t ，有 x=R−1(x′−t)=R−1x′−R−1t ，由此得到的逆变换为 R′=R−1,t′=−R−1t 。这就使得计算不是那么的统一。
其他的几种变换 其他的几种变换包括相似变换，仿射变换，射影变换。其中相似变换就是在欧氏变换的基础上增加了对图形的缩放。一个典型的相似变换如下： 设缩放系数为s，则它的单应矩阵为
H=[sR0t1] 显然，相似变换失去了线段长度的不变性，但是还保留着线段间角度的不变性。欧氏变换可以看作它在s=1时的一个特例。 对于剩下的两种变换，我们将在后面一篇博客进行介绍。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6101e561bdf3c897e6bca96990bbefe/" rel="bookmark">
			hdu 4745 Two Rabbits
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意：两只兔子在玩跳石头游戏；
题解：就是求这条串 和最长的两条回文子串（子串可以不连续，但是不可以相交）， 网上还有一种解法就是将两个这样的串连起来，然后在长度最多为n的子区间求最长回文子串， 结果就是所有长度为 区间长度为n 的dp[k][k+n-1]值， 或者为dp[k][k+n-2]+1 (可以理解为最开始站在k+n-1这块石头上， 实际上可以由第一种方法推出来）；
代码：
#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;cmath&gt; using namespace std; const int MAXN = 1008; int dp[MAXN][MAXN], a[MAXN]; int n; int main() { //freopen("in.txt", "r", stdin); while (scanf("%d", &amp;n) &amp;&amp; n) { memset(dp, 0, sizeof(dp)); for(int i = 0; i &lt; n; i++) { scanf("%d", a+i); dp[i][i] = 1; } for(int i = 1; i &lt; n; i++) { for (int j = 0; j &lt; n-i; j++) { int jj = i+j; dp[j][jj] = max(dp[j+1][jj], dp[j][jj-1]); if (a[j] == a[jj]) dp[j][jj] = max(dp[j][jj], dp[j+1][jj-1]+2); } } int res = 0; for(int i = 0; i &lt; n; i++) { res = max(dp[0][i]+dp[i+1][n-1], res); } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6101e561bdf3c897e6bca96990bbefe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd74186a6d82b1407a9de517653166d7/" rel="bookmark">
			多线程c&#43;&#43;队列的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我有一个队列的全局变量，然后一个线程不断的获取数据，向这个队列里面压入，然后另一个线程每次读取队列的第一个元素，然后删掉。 #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;windows.h&gt; #include&lt;stdlib.h&gt; #include&lt;process.h&gt; #include&lt;opencv2/core/core.hpp&gt; #include&lt;opencv2/imgproc/imgproc.hpp&gt; #include&lt;opencv2/highgui/highgui.hpp&gt; using namespace std; using namespace cv; CRITICAL_SECTION g_cs; VideoCapture cap; std::queue&lt;Mat&gt; myQ; unsigned int __stdcall producer(PVOID para) { int i = 0; Mat frame; while (1) { cap &gt;&gt; frame; EnterCriticalSection(&amp;g_cs); myQ.push(frame.clone()); LeaveCriticalSection(&amp;g_cs); //i++; Sleep(2); } } unsigned int __stdcall consumer(PVOID para) { int i = 0; Mat frame; while (1) { while (myQ.empty()) Sleep(2); EnterCriticalSection(&amp;g_cs); //cout &lt;&lt; myQ.front()&lt;&lt;" "; frame = myQ.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd74186a6d82b1407a9de517653166d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/255d403eeba54cfc9d3fb633b81991c1/" rel="bookmark">
			使用maven cxf时tomcat服务器出现Could not send Message错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 可能是服务器端口号与spring配置中的注册信息的serviceClass属性值不同,也可能需要重新编译webservice, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bca53d80718dbfda59e1748879937a8b/" rel="bookmark">
			java根据sessionId创建、删除session
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在有些情况下可能需要根据sessionId来增删改session，这时候我们可以通过监听来实现。代码如下。
1、创建监听MySessionListener.java
public class MySessionListener { public void sessionCreated(HttpSessionEvent httpSessionEvent) { MySessionContext.AddSession(httpSessionEvent.getSession()); } public void sessionDestroyed(HttpSessionEvent httpSessionEvent) { HttpSession session = httpSessionEvent.getSession(); MySessionContext.DelSession(session); } } 2、创建MySessionContext.java public class MySessionContext { private static HashMap mymap = new HashMap(); public static synchronized void AddSession(HttpSession session) { if (session != null) { mymap.put(session.getId(), session); } } public static synchronized void DelSession(HttpSession session) { if (session != null) { mymap.remove(session.getId()); } } public static synchronized HttpSession getSession(String session_id) { if (session_id == null) return null; return (HttpSession) mymap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bca53d80718dbfda59e1748879937a8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c5d643928296ffc92ebb4708415c3bd/" rel="bookmark">
			golang 字符串中的双引号显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 golang 字符串中的双引号显示 字符串中的双引号显示本人已知有以下几种方法：
不带双引号字符串
str1 := "www.hewe.vip" fmt.Println(len(str1)) fmt.Println(str1) //输出结果 12 www.hewe.vip使用反引号
str2 := `"www.hewe.vip"` fmt.Println(len(str2)) fmt.Println(str2) //输出结果 14 "www.hewe.vip"使用转义
str3 := "\"www.hewe.vip\"" fmt.Println(len(str3)) fmt.Println(str3) //输出结果 14 "www.hewe.vip" 使用strconv包
str := strconv.Quote("www.hewe.vip") fmt.Println(len(str)) fmt.Println(str1) //输出结果 14 "www.hewe.vip" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1ebb194f1ed5ff614922a6c653998e3/" rel="bookmark">
			Python&#43;Selenium xpath 定位遇到相同元素时的解决方法父节点找子节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、#先定位到父节点，再从父节点找指定节点
例如: 注意不能直接用 driver.find_element_by_xpath('//*[@id="branch_inquiry"]').find_element_by_class_name('city-picker-span') 用法
# -*- coding: utf-8 -*- from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import Select from selenium.common.exceptions import NoSuchElementException from selenium.common.exceptions import NoAlertPresentException import unittest, time, re driver = webdriver.Chrome() driver.get("http://intl.sit.sf-express.com:8980/") from selenium.webdriver import ActionChains import time driver.find_element_by_xpath('/html/body/div[3]/div[2]/a[5]').click() time.sleep(1) service_coverage = driver.find_element_by_xpath('//*[@id="range_inquiry"]').find_element_by_class_name('city-picker-span') print(service_coverage.text) service_coverage.click() 2、不是同一级的xpath 定位方法 driver.find_element_by_xpath("//input[@id='cityAddress1']/following-sibling::span").click() 3、由父节点定位子节点 # 1.串联寻找 print driver.find_element_by_id('B').find_element_by_tag_name('div').text # 2.xpath父子关系寻找 print driver.find_element_by_xpath("//div[@id='B']/div").text # 3.css selector父子关系寻找 print driver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1ebb194f1ed5ff614922a6c653998e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c30fa54bddcf616c4b2e43962d41d9cb/" rel="bookmark">
			Carson带你学Android：手把手教你实现Activity与Fragment相互通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Activity 与 Fragment 的使用在Android开发中非常多今天，我将主要讲解 Activity 与 Fragment 如何进行通信，实际上是要解决两个问题： Activity 如何传递数据到 Fragment？Fragment如何传递数据到Activity ？ 下面，我将解答这两个问题。
Carson带你学Android 文章系列：
Carson带你学Android：页面活动-Activity
Carson带你学Android：广播-BroadcastReceiver
Carson带你学Android：服务-Service
Carson带你学Android：内存承载器-ContentProvider
问题1： Activity 如何传递数据到 Fragment？ 答：采用 Bundle方式。具体Demo步骤如下：
步骤1：Activity的布局文件 activcity_2_fragment.xml
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/text" android:layout_gravity="center" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textSize="20dp" android:text="我是Activity" /&gt; &lt;FrameLayout android:layout_below="@+id/button" android:id="@+id/fragment_container" android:layout_width="match_parent" android:layout_height="500dp"/&gt; &lt;/LinearLayout&gt; 步骤2：设置 Fragment的布局文件 fragment.xml
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@color/colorAccent" &gt; &lt;TextView android:id="@+id/fragment" android:text="我是fragment" android:layout_gravity="center" android:textSize="30dp" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;TextView android:id="@+id/text" android:layout_gravity="center" android:layout_width="wrap_content" android:layout_height="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c30fa54bddcf616c4b2e43962d41d9cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b5cabb4ee3fe0c5fe9dec352186a4b/" rel="bookmark">
			[python]数据合并concat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Numpy 的concat
arr1 = np.random.randint(0, 10, (3, 4)) arr2 = np.random.randint(0, 10, (3, 4)) np.concatenate([arr1, arr2]) np.concatenate([arr1, arr2], axis=1)#按照列 Series 的concat
# index 没有重复的情况 ser_obj1 = pd.Series(np.random.randint(0, 10, 5), index=range(0,5)) ser_obj2 = pd.Series(np.random.randint(0, 10, 4), index=range(5,9)) ser_obj3 = pd.Series(np.random.randint(0, 10, 3), index=range(9,12)) pd.concat([ser_obj1, ser_obj2, ser_obj3]) # index 有重复的情况 ser_obj1 = pd.Series(np.random.randint(0, 10, 5), index=range(5)) ser_obj2 = pd.Series(np.random.randint(0, 10, 4), index=range(4)) ser_obj3 = pd.Series(np.random.randint(0, 10, 3), index=range(3)) pd.concat([ser_obj1, ser_obj2, ser_obj3], axis=1, join='inner') DataFrame上的concat
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25b5cabb4ee3fe0c5fe9dec352186a4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d1509b85c5f8d4bd2fdda76f7d910f8/" rel="bookmark">
			如何研读一篇论文？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载一个对我帮助很大的研究生手册，作者是台湾清华大学的彭明辉教授。比较长，但绝对值得一读。就我自己读研时候的体会，这个手册中的内容，至少帮我节约了一半的用于寻找/阅读参考文献的时间。
一、论文的要求 我对硕士论文的基本要求是： （1）论文的主要内容，是叙述一套方法在一个特定场合中的应用。 （2）这套方法必须要有所创新或突破，并因而对学术界有所贡献。因此，它或者是解决既有问题的新方法，或者是既有方法的新应用，或者是以一个新的方法开启一整片新的应用领域。
（3）在论文中，你必须要有能力提出足够的证据来让读者信服说：针对这个应用场合，你所提出来的方法确实有比文献中一切既有方法更优越之处。 （4）此外，你必须要能清楚指出这个方法在应用上的限制，并且提出充分证据来说服读者：任何应用场合，只要能够满足你所提出来的假设（前提）条件，你的方法就一定适用，而且你所描述的优点就一定会存在。
（5）你还必须要在论文中清楚指出这个方法的限制和可能的缺点（相对于其它文献上的既有方法，或者在其它应用场合里）。假如飧龇椒ㄓ腥魏沃卮笕钡悖诳谑允辈疟豢谑晕敝赋隼矗浜蠊锌赡苁锹畚奈薹ㄍü?nbsp;
（6）行文风格上，它是一篇论证严谨，逻辑关系清晰，而且结构有条理的专业论述。也就是说，在叙述你的方法的过程，你必须要清清楚楚地交代这个方法的应用程序以及所有仿真或实验结果的过程，使得这个专业领域内的任何读者，都有办法根据你的描述，在他的实验室下复制出你的研究成果，以便确定你的结论确实是可以「在任何时间、任何地点、任何人」都具有可重复性（可重复性是「科学」的根本要求）。
（7）而且，你对这个方法的每一个步骤都必须要提供充分的理由说明「为什么非如此不可」。 （ 8）最后，你的论文必须要在适当位置清楚注明所有和你所研究之题目相关的文献。而且，你必须要记得：只要是和你所研究的问题相关的学术文献（尤其是学术期刊论文），你都有必要全部找出来（如果漏掉就是你的过失），仔细读过。假如你在学位论文口试时，有口试委员指出有一篇既有文献，在你所讨论的问题中处理得比你的方法还好，这就构成你论文无法及格的充分理由。
（9）第（2）款所谓「对学术界的贡献」，指的是：把你的所有研究成果扣除掉学术界已经发表过的所有成果（不管你实际上有没有参考过，没有参考过也算是你的重大过失），剩下的就是你的贡献。假如这个贡献太少，也构成你论文无法及格的充分理由。
上面所叙述的九款要件中，除第（2）款之外，通通都是必须要做到的，因此没有好坏之分。一篇硕士论文的好坏（以及成绩的评定标准），主要是看第（2）款所谓「对学术界的贡献」的多寡与重要性而定。假如你要申请国外的博士班，最重要的也是看你的硕士论文有什么「贡献」而定（这往往比TOFEL、GRE、GPA还重要）。
一个判断硕士论文的好坏有一个粗浅办法：假如你的研究成果可以在国外著名学术期刊（journals，而非 magazines）上发表，通常就比一篇只能在国外学术会议（conferences）上发表的硕士论文贡献多；一篇国外学术会议的论文又通常比无法发表的论文贡献多；在国际顶尖学术期刊上发表的论文通常比一篇二流的学术期刊论文贡献多。SCI有一种叫做 Impact Factor 的指数，统计一个期刊每篇论文被引述的次数。通常这个次数（或指数）愈高，对学术界的影响力就愈大。以机械视觉相关领域的期刊而言，Impact Factor 在 1.0 以上的期刊，都算是顶尖的期刊。这些期刊论文的作者，通常是国外顶尖学府的著名教授指导全球一流的博士生做出来的研究成果。 二、完成硕士论文所需要的能力 从前面的叙述可以归纳出来，完成硕士论文所需要的能力包括以下数项，依它们的培养先后次序逐项讨论。 （1）资料检索的能力：在给定（或自己拟定）的题目范围内，你必须有能力利用文资料索引系统，查出所有相关的论文，而无任何遗漏（否则你可能在论文口试时才发现同一个题目已经有人发表过了）。你到底要用什么样的关键词和查所程序去保证你已经找出所有相关的文献？这是第一个大的挑战。每一组关键词（包含联集与交集）代表一个论文所构成的集合，假如你用的关键词不恰当，你可能找到的集合太小，没有涵盖所有的相关文献；假如你用的关键词太一般化（譬如「image」），通常你找到的集合会太大，除了所有相关文献之外还加上好几十倍的毫不相关的文献。
（2）资料筛选的能力：即使你使用了恰当的搜寻策略，通常找到的文献集合都还是明显地比你所需要的集合大，而且通常文献比数大概在一两百篇或数百篇之间，而其中会和你的的研究子题直接且密切相关的论文，通常只有廿、卅篇左右。你如何可以只读论文的题目、摘要、简介和结论，而还没有完全看懂内文，就准确地判断出这篇论文中是否有值得你进一步参考的内容，以便快速地把需要仔细读完的论文从数百篇降低到廿、卅篇？这考验着你从事资料筛选的能力。
（3）期刊论文的阅读能力：期刊论文和大学部的课本截然不同。大学部的课本是寻次渐进地从最基本的知识背景逐步交代出整套有系统的知识，中间没有任何的跳跃，只要你逐页读下去，就可以整本都读懂，不需要在去别的地方找参考资料。但是期刊论文是没头没尾的十几页文献，只交代最核心的创意，并援引许多其它论文的研究成果（但只注明文献出处，而完全没有交代其内容）。因此，要读懂一篇论文，一定要同时读懂数篇或十数篇被援引的其它论文。偏偏，这十几篇被援引的论文又各自援引十数篇其它论文。因此，相对于大学部的教科书而言，期刊论文是一个极端没有系统的知识，必须要靠读者自己从几十篇论文中撷取出相关的片段，自己组织成一个有系统的知识，然后才有办法开始阅读与吸收。要培养出这种自己组织知识的能力，需要在学校靠着大量而持续的时间去摸索、体会，而不可能只利用业余的零星时间去培养。因此，一个大学毕业后就不再念研究所的学生，不管他在毕业生和大学毕业生最大的差别，就是：学士只学习过吸收系统知识的能力（也就是读别人整理、组织好的知识，典型的就是课本）；但硕士则学习过自己从无组织的知识中检索、筛选、组织知识的能力。
（4）期刊论文的分析能力：为了确定你的学位论文研究成果确实比所有相关的学术期刊论文都更适合处理你所拟定的应用场域，首先你必须要有能力逐篇分析出所有相关期刊论文的优点与缺点，以及自己的研究成果的优点与缺点，然后再拿他们来做比较，总结出你的论文的优点和缺点（限制）。但是，好的期刊论文往往是国外著名学府的名师和一流的博士生共同的研究成果，假如你要在锁定的应用场域上「打败」他们，突出自己的优点，这基本上是一个极端困难的挑战。即使只是要找出他们的缺点，都已经是一个相当困难的工作了。一个大学毕业生，四年下来都是假定「课本是对的」这样地学下来的，从来没有学习如何分析课本知识的优缺点，也就是「只有理解的能力，而没有批判的能力」。硕士生则必须要有「对一切既有进行精确批判」的能力。但是，这个批判并非个人好恶或情绪化的批判，而是真的找得到充分理由去支持的批判。这个批判的能力，让你有能力自己找到自己的优、缺点，因此也有机会自己精益求精。所以，一个大学毕业生在业界做事的时候，需要有人指导他（从事批判性检验），帮他找出缺点和建议改进的可能性。但是，一个严格训练过的合格硕士，他做事的时候应该是不需要有人在背后替他做检证，他自己就应该要有能力分析自己的优、缺点，主动向上级或平行单位要求支持。其实，至少要能够完成这个能力，才勉强可以说你是有「独立自主的判断能力」。
（5）创新的能力：许多大学毕业的工程师也能创新，但是硕士的创新是和全世界同一个学术团体内所有的名师和博士生挑战。因此，两者是站在不同的比较基础上在进行的：前者往往是一个企业内部的「闭门造车」，后者是一个全球的开放性竞争。其次，工程师的创新往往是无法加以明确证明其适用条件，但是学术的创新却必须要能够在创新的同时厘清这个创新的有效条件。因此，大学毕业生的主要能力是吸收既有知识，但硕士毕业生却应该要有能力创造知识。此外，台湾历年来工业产品的价位偏低，这一部分是因为国际大厂的打压以及国际消费者的信任不易建立。但是，另一方面，这是因为台湾的产品在品质上无法控制，因此只好被当作最粗糙的商品来贩卖。台湾的产品之所以无法有稳定的品质，背后的技术原因就是：各种创新都是只凭一时偶然的巧思，却没有办法进一步有系统地厘清这些巧思背后可以成立的条件。但是，创新其实是可以有一套「有迹可寻」的程序的，这是我最得意的心得，也是我最想教的。
三、为什么要坚持培养阅读与分析期刊论文的能力 我所以一直坚持要训练研究生阅读与分析期刊论文的能力，主要是为了学生毕业后中长期的竞争力着想。 台湾从来都只生产国外已经有的产品，而不事创新。假如国外企业界比国外学术的技术落后三年，而台湾的技术比国外技术落后五年，则台湾业界所需要的所有技术都可以在国外学术期刊上找到主要的理论依据和技术核心构想（除了一些技术的细节和 know how 之外）。因此，阅读期刊的能力是台湾想要保持领先大陆技术的必备条件。
此外，只要能够充分掌握阅读与分析期刊论文的技巧，就可以水到渠成地轻松进行「创新」的工作。所以，只要深入掌握到阅读与分析期刊论文的技巧，就可以掌握到大学生不曾研习过的三种能力：（1）自己从无组织的知识中检索、筛选、组织知识的能力、（2）对一切既有进行精确批判的独立自主判断能力、（3）创造新知识的能力。
创新的能力在台湾一直很少被需要（因为台湾只会从国外买整套设备、制程和设计与制造的技术）。但是，大陆已经成为全球廉价品制造中心，而台商为了降低成本也主动带技术到大陆设厂（包括现在的晶元代工），因此整个不具关键性技术的制造业都会持续往大陆移动；甚至 IC 的设计（尤其数字的部分）也无可避免地会迅速朝向「台湾开系统规格，进行系统整合，大陆在前述架构下开发特定数位模块」的设计代工发展。因此，未来台湾将必然会被逼着朝愈来愈创意密集的创意中心走（包括商务创意、经营创意、产品创意、与技术创新）。因此，不能因为今天台湾的业界不需要创新的能力，就误以为自己一辈子都不需要拥有创新的能力。
我在协助民间企业发展技术研发的过程中，碰到过一位三十多岁的厂长。他很聪明，但从小家穷，被环境逼着去念高工，然后上夜校读完工专。和动态性能（ bandwidth、response speed等）无关的技术他都很深入，也因为产品升级的需要而认真向我求教有关动态性能的基本观念。但是，怎么教他都不懂，就只因为他不懂工程数学。偏偏，工程数学不是可以在工厂里靠自修读会的。一个那么聪明的人，只因为不懂工数，就注定从三十岁以后一辈子无法在专业上继续成长！他高工毕业后没几年，廿多岁就当课长，家人与师长都以他为荣；卅岁当厂长，公司还给他技术股，前途无量；谁想得到他会在卅岁以后被逼着「或者升级，或者去大陆，或者失业」？
每次想起这位厂长，看着迫不急待地要到台积电去「七年赚两千万退休金」的学生，或者只想学现成可用的技术而不想学研究方法的学生，我总忍禁不住地要想：十年后，我教过的学生里，会不会有一堆人就只因为不会读期刊论文而被逼提前退休？
再者，技术的创新并不是全靠聪明。我熟谙一套技术创新的方法，只要学会分析期刊论文的优缺点，就可拿这套方法分析竞争对手产品的优缺点；而且，只要再稍微加工，就可以从这套优缺点的清单里找到突破瓶颈所需的关键性创意。这套创新程序，可以把「创新」变成不需要太多天分便可以完成的事，从而减轻创意的不定性与风险性。因此，只要会分析论文，几乎就可以轻易地组合出你所需要的绝大部分创意。聪明是不可能教的，但这套技巧却是可以教的；而且只要用心，绝大部分硕士生都可以学会。
就是因为这个原因，我的实验室整个训练的重心只有一个：通过每周一次的 group meeting，培养学生深入掌握阅读与分析期刊论文的技巧，进而培养他们在关键问题上突破与创新的能力。
四、期刊论文的分析技巧与程序 一般来讲，好的期刊论文有较多的创意。虽然读起来较累，但收获较多而深入，因此比较值得花心思去分析。读论文之前，参考SCI Impact Factor 及学长的意见是必要的。
一篇期刊论文，主要分成四个部分。 （1）Abstract： 说明这篇论文的主要贡献、方法特色与主要内容。最慢硕二上学期必须要学会只看 Abstract 和Introduction便可以判断出这篇论文的重点和你的研究有没有直接关连，从而决定要不要把它给读完。假如你有能力每三十篇论文只根据摘要和简介便能筛选出其中最密切相关的五篇论文，你就比别人的效率高五倍以上。以后不管是做事或做学术研究，都比别人有能力从更广泛的文献中挑出最值得参考的资料。
（2）Introduction： Introduction 的功能是介绍问题的背景和起源，交代前人在这个题目上已经有过的主要贡献，说清楚前人留下来的未解问题，以及在这个背景下这篇论文的想解决的问题和它的重要性。对初学的学生而言，从这里可以了解以前研究的概况。通常我会建议初学的学生，对你的题目不熟时，先把跟你题目可能相关的论文收集个 30～40篇，每篇都只读Abstract 和 Introduction，而不要读 Main Body（本文），只在必要时稍微参考一下后面的 Illustrative examples和 Conclusions，直到你能回答下面这三个问题：（2A）在这领域内最常被引述的方法有哪些？（2B）这些方法可以分成哪些主要派别？（2C）每个派别的主要特色（含优点和缺点）是什么？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d1509b85c5f8d4bd2fdda76f7d910f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/205bf9e1722187e500f5a3e0298ded64/" rel="bookmark">
			xencenter创建快照和恢复快照
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建快照
恢复快照
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3985b7ab68c2315dace18f66b7a7951e/" rel="bookmark">
			Android JNI获取上下文Context
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当在JNI调用Android自带的类时，经常需要传入Context参数，那怎么在JNI层获取Context呢？
我们知道Application和Activity是Context的子类，由于每个Activity对应的Context是不一样的，所以一般情况下我们使用Application的Context，它在整个程序中只有一个实例。所以现在问题就变成了怎么在JNI中获取Application呢？
Android APP在启动时会创建一个Activity Thread作为主线程，只要程序存活，这个线程就一直存在，所以我们可以考虑从Activity Thread中获取Application，查看Activity Thread的源码发现，它提供了一个方法可以获取Application，如下：
public Application getApplication() { return mInitialApplication; } 也就是说我们只需要获取到Activity Thread的对象即可，Activity Thread提供了一个静态方法用于获取其实例，如下：
public static ActivityThread currentActivityThread() { return sCurrentActivityThread; } 至此获取Context的步骤已经很清晰了，代码编写如下：
jobject getGlobalContext(JNIEnv *env) { //获取Activity Thread的实例对象 jclass activityThread = env-&gt;FindClass("android/app/ActivityThread"); jmethodID currentActivityThread = env-&gt;GetStaticMethodID(activityThread, "currentActivityThread", "()Landroid/app/ActivityThread;"); jobject at = env-&gt;CallStaticObjectMethod(activityThread, currentActivityThread); //获取Application，也就是全局的Context jmethodID getApplication = env-&gt;GetMethodID(activityThread, "getApplication", "()Landroid/app/Application;"); jobject context = env-&gt;CallObjectMethod(at, getApplication); return context; } 作者：lb377463323 出处：http://blog.csdn.net/lb377463323 原文链接：http://blog.csdn.net/lb377463323/article/details/75315167 转载请注明出处！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/149f0c9e85691acf4571b0e55aa844e1/" rel="bookmark">
			TMS320C6747移植dspbios的一些问题及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在研旭6747开发板led例程的基础上移植dspbios，目的是通过操作系统dspbios让led实现亮灭。
一开始出现的问题是有声明重复定义了，查找原因发现是研旭led程序中c6474.h这个头文件里定义了unsigned int,unsigned char.int,char等等这些数据类型为uint,uchar,ushort之类的宏，而dspbios的头文件里刚好有typedefine语句也定义了这些数据类型为另外的symbol，这样就重复定义了数据类型。解决方法是把c6747.h这个头文件里的这些宏定义注释掉，同时在用到uint,uchar,ushort等等这些数据类型的宏的语句里把宏全部改为数据类型本来的名称unsigned int，unsigned char,int,char,short等。改完之后就不再出现重复定义这个问题了，还有一个方法是，把dspbios里包含了这些数据类型的定义的那个头文件，具体哪个名字忘了，把它include到c6747.h里，用dspbios的宏定义，而把原来c6747.h里的宏定义给注释掉，但是这个方法并没有尝试，因为第一个成功了。
接着出现的问题是，内存重叠了，problems窗口给出的信息是memory overlap，这是因为原来例程里的cmd文件定义了内存各段的名称，而在bios的bioscfg.cmd文件里刚好也定义了这些段的位置，两者同时链接的话就会出现重叠的问题，解决办法是把例程的cmd文件c6747.cmd给删掉，而用dspbios的cmd文件。注意，可以打开bios.tcf文件进行内存管理，分配内存的各段。内存的分配必须要根据datasheet来，不要超出范围。
最后还有一个问题就是_TskLedOn和_TskLedOff unresolved的问题，这是因为在main.c程序里，点灯和灭灯的程序的名字还是没有改过来，还是ledon和ledoff，而在dspbios里，任务的名称是TskLedOn和TskLedOff，因此报错，把main.c的亮灭灯程序改成dspbios里亮灭灯的任务名称就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98554e829e0a4b4e0990b485db3aa9d4/" rel="bookmark">
			NRL: network representation learning &amp; NE: network embedding. 相关论文总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Must-read papers on NRL/NE. NRL: network representation learning. NE: network embedding. Survey papers: Representation Learning on Graphs: Methods and Applications. William L. Hamilton, Rex Ying, Jure Leskovec 2017. paper
Graph Embedding Techniques, Applications, and Performance: A Survey. Palash Goyal, Emilio Ferrara 2017. paper
A Comprehensive Survey of Graph Embedding: Problems, Techniques and Applications. Hongyun Cai, Vincent W. Zheng, Kevin Chen-Chuan Chang 2017. paper
Journal and Conference papers: DeepWalk: Online Learning of Social Representations.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98554e829e0a4b4e0990b485db3aa9d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bec3aaa1d2f44946ad5be1c5264df0d6/" rel="bookmark">
			C#调用OCX控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写了一个调用OCX的winfrom程序，之前运行一直好使，但是突然一天，初始化控件报错，找不到指定模块。。。。。
尝试重新下载ocx，加载ocx，失败。
尝试使用之前程序生成的dll文件失败。
最后发现电脑没有注册ocx，好吧下载去注册一下吧！
以前在web端读取pdf格式都是在客户端安装adobe软件，现在为了满足不在客户端安装adobe软件也可以读取pdf格式文件，所以就用了金格的一款ocx组件，解决了客户端不安装pdf格式软件也可以读取pdf格式文件。下面就说说支持ocx组件的环境。
一、如果你是win7 64位操作系统 找到 C盘-----&gt;Windows文件夹----&gt;system32 并且system64文件夹,把命名为ocx（此demo是iwebpdf.ocx）的文件放入system32 并且system64下即可。
二、如果你是win7 32 或者windowsxp系统 找到 C盘-----&gt;Windows文件夹----&gt;system32 ，把命名为ocx（此demo是iwebpdf.ocx）的文件放入system32即可。
三、把文件夹放入上述路径下，然后wins+R 打开命令窗体，开始执行"regsvr32 iWebPDF.ocx"此命令，此时会提示注册组件成功。
四、ocx组件注册成功后 执行一遍第三方提供的"IEExecute.exe"文件，该文件执行成功后进入下一步。
五、exe执行成功后，然后wins+R 打开命令窗体，输入"regedit"命令，打开注册表，找到"HKEY_CLASSES_ROOT---&gt;CLSID"，查看CLSID下是否有一个节点与第三方提供的那个节点一致，如果有的话就证明ocx组件是真正的注册成功已写入注册表里，如果没有找到不用担心，可以手动加一个节点，需要注意到是手动加节点路径要与之前所放文件路径一致，否则会找不到。
完成上述我所说的基本就不会有什么问题，但是我最近还是因为环境问题那个ocx组件一直不成功，因为在xp系统里系统不升级到sp3会一直有问题，所以建议大家如果是xp系统的话尽量升级到sp3。环境成功后，用第三方提供的一些属性及方法就轻松无压力了。
这是一个示例说明，记录一下。 下面也记录一下如何使用ocx吧，
在工具箱邮件，选择"选择项"，选择com组件，浏览路径添加。
在from加载需要实例化ocx的组件信息。
private AxOPERATIONCARDLib.AxOperationCard _operation;
_operation = new AxOperationCard();
_operation.BeginInit();
this.Controls.Add(_operation);//add test
_operation.Visible = false;
_operation.EndInit();
_operation.CreateControl();
}
OCX使用命令生成dll文件
1、启动VS开发人员命令面板/
2、切换到ocx文件目录
3、aximp name.ocx
则会在响应目录下生成两个dll文件。
如果需要注册
regsvr 32 name.ocx
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2b0e36d5c988b2a27bdeec5d9313d5c/" rel="bookmark">
			第一个Python CGI编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是CGI
CGI（Common Gateway Interface），通用网关接口，它是一段运行在服务器上的程序。CGI程序可以是Python脚本、PERL脚本、SHELL脚本、C或者C++程序等。
在你进行CGI编程前，确保您的Web服务器支持CGI及已经配置了CGI的处理程序。下文将介绍Apache支持CGI配置。
2、下载Apache
地址：http://www.apachehaus.com/cgi-bin/download.plx
本文下载的版本是httpd-2.4.27-x64-vc11.zip，如下图：
3、安装Apache
解压httpd-2.4.27-x64-vc11.zip文件到指定目录，本文解压到C盘，如下图：
4、配置SRVROOT
进入C:\httpd-2.4.27-x64-vc11\Apache24\conf目录，打开httpd.conf文件进行编辑。
找到Define SRVROOT这一项，将其值改为Apache安装目录地址，如下图：
5、安装Apache服务
打开CMD窗口（管理员身份），进入C:\httpd-2.4.27-x64-vc11\Apache24\bin目录，输入安装命令，如下图：
该命令的意思是，安装apache服务，并将该服务名称命名为apache24。
6、启动apache服务
在C:\httpd-2.4.27-x64-vc11\Apache24\bin目录双击ApacheMonitor.exe执行文件，桌面右下角会出现图标，打开窗口界面并启动apache24服务，如下图：
7、编写Python文件
在C:\httpd-2.4.27-x64-vc11\Apache24\cgi-bin目录创建并编辑Python文件，文件命名为test.py，如下图：
其中test.py代码如下：
#!C:\Python27\python.exe print("Content-type:text/html\n") print("&lt;html&gt;") print("&lt;head&gt;") print("&lt;meta charset = \"utf-8\" /&gt;") print("&lt;title&gt;hello&lt;/title&gt;") print("&lt;/head&gt;") print("&lt;body&gt;") print("&lt;h1&gt;world&lt;/h1&gt;") print("&lt;/body&gt;") print("&lt;/html&gt;") 代码第一行为Python的安装目录，这里不再表述Python的安装。
8、运行
在浏览器地址栏中输入http://localhost/cgi-bin/test.py，结果如下：
至此第一个CGI程序完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f24be9f12577aa93e3bb9da6cf43fa6b/" rel="bookmark">
			正则表达式拆分字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天遇到这样一个问题，对一个字符串按照某个分隔符进行分割，要求用正则表达式，不能用split
import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegexTest { public static void main(String[] args) { String str = "hjg^^xgvj^^hsx^^hsjxgd^^udeggduejdehx^^exded^^ueue"; String re = "(?:([^\\^\\^]))+"; Pattern p = Pattern.compile(re, Pattern.CASE_INSENSITIVE); Matcher m = p.matcher(str); while(m.find()){ System.out.println(m.group()); } } } 结果为：
hjg xgvj hsx hsjxgd udeggduejdehx exded ueue 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11a86c7f00131381081a719dfa949e53/" rel="bookmark">
			大数据表的查询优化方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：http://www.2cto.com/database/201411/348519.html
如果有一张大表，表中的数据有几百万、几千万甚至上亿，要实现实时查询，查询的结果要在十秒钟之内出来，怎么办？如何做优化?
本人现在做的项目中，有个表的数据超过1千万行，超过3G的数据。现在需要对表中的数据进行查询统计，之前由于没做优化，导致此表的查询效率非常低下，让使用者非常苦恼，于是本人参与了此表的优化。
举个类似的例子，比如表中的结构如下，现在要统计某一天出生的人口数，或者统计某一城市的人口数，或者某一城市某一天出生的人口数。
? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 CREATE TABLE `population` ( `population_id` bigint (64) NOT NULL AUTO_INCREMENT COMMENT '人口表' , ` name ` varchar (128) COLLATE utf8_bin DEFAULT NULL COMMENT '姓名' , `city` varchar (32) COLLATE utf8_bin DEFAULT NULL COMMENT '城市' , `birthday` date DEFAULT NULL COMMENT '出生日期' , PRIMARY KEY (`population_id`) ) 查询某一城市某一天出生的人口数 SELECT COUNT (*) FROM population WHERE city= '广州' AND birthday = '2014-11-02' 查询某一城市的人口数 SELECT COUNT (*) FROM population WHERE city= '广州' 查询某一天出生的人口数 SELECT COUNT (*) FROM population WHERE birthday = '2014-11-02' 提出了两个优化方案，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11a86c7f00131381081a719dfa949e53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01c1c6ec102e7a66b56c894971df5b11/" rel="bookmark">
			微信支付/支付宝指纹支付原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着各大厂商手机相继加入了指纹解锁功能，指纹支付因为免除了密码输入，简单快捷的特点，迅速受到了广大用户的青睐。今天我们简单来探究一下指纹支付的原理。
首先，我们先看看微信的指纹支付设置页面：点击钱包----右上角------支付管理
再来看看支付宝的设置页面：
从以上流程，可以大概推断指纹支付流程：
1、支付宝、微信的后台系统不会保存用户支付指纹；支付宝和华为联合推出的指纹支付标准中，也明确提到：用户录入的指纹数据将保存在本地，不会存储到任何服务器和云端
2、支付宝、微信在开启指纹支付前，需要先设置支付密码（通过接口校验支付密码，服务器校验通过后，返回一个token给客户端，客户端调用硬件设备校验指纹，指纹通过后保存token到本地）
3、指纹支付时，先调用iOS / Android系统api，校验用户指纹是否正确，如果正确，通过支付接口，上送本地缓存的token。
4、其他问题：通过测试发现：在应用设置指纹支付成功后，卸载并重装app，支付指纹依旧有效。初步判断是登录成功后，服务器根据客户端首次登陆状态，返回了token。如果还有更好的意见，希望广大朋友不吝指正，谢谢！
2018年11月16号更新，请参考：微信官方说明
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91db4674c35f665598b42b1ee6294437/" rel="bookmark">
			war和war exploded的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用IDEA开发项目的时候，部署Tomcat的时候通常会出现下边的情况：
是选择war还是war exploded 这里首先看一下他们两个的区别：
war模式：将WEB工程以包的形式上传到服务器 ；
war exploded模式：将WEB工程以当前文件夹的位置关系上传到服务器；
（1）war模式这种可以称之为是发布模式，看名字也知道，这是先打成war包，再发布；
（2）war exploded模式是直接把文件夹、jsp页面 、classes等等移到Tomcat 部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。
（3）在平时开发的时候，使用热部署的话，应该对Tomcat进行相应的设置，这样的话修改的jsp界面什么的东西才可以及时的显示出来。
转载于:https://www.cnblogs.com/Amos-Turing/p/7154083.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efac2d3a26d84c1ff0bf860c3390f2cc/" rel="bookmark">
			【Python】产生随机数字09
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数randint(a,b)可以产生一个a和b之间，且包括a和b的随机整数。
# 产生两个整数，检测学生答案是否正确 #-*-conding:utf-8-*- from random import randint num1 = randint(0,9) num2 = randint(0,9) answer = eval(input("What is "+ str(num1)+"+"+str(num2)+"?")) print(num1,"+",num2,"=",answer,"is",num1 + num2 == answer) Python还提供了其他函数，randrange(a,b) 产生一个在a，b-1之间的随机整数，等价于randint(a,b-1) 还可以使用random()函数产生一个满足条件0&lt;=r&lt;=1.0的随机浮点数r。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9fc4370e6b8e8b26f5c8769d88fecb1/" rel="bookmark">
			重复创建fragment的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上代码：
public class MainActivity extends AppCompatActivity implements View.OnClickListener { private FrameLayout mFrameLayout; private Button btn_pan; private Button btn_twopan; private Button btn_sanpan; private Button btn_sipan; private List&lt;Fragment&gt; mFragments = new ArrayList&lt;&gt;(); private PanFragment panFragment; private TwoPanFragment twoPanFragment; private SanFragment sanPanFragment; private SiPanFragment siPanFragment; Fragment currentFragment = new Fragment(); private int currentPostion; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initListener(); panFragment = new PanFragment(); twoPanFragment = new TwoPanFragment(); sanPanFragment = new SanFragment(); siPanFragment = new SiPanFragment(); mFragments.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9fc4370e6b8e8b26f5c8769d88fecb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b35d662390568056857775a5c7c3679/" rel="bookmark">
			010 - Seajs使用实例入门介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Seajs使用实例入门介绍 seajs是啥，可以看看这篇前端模块化（CommonJs,AMD和CMD）
文章来自于
本文所用例子的代码目录结构：
seajs example |--sea-module //存在依赖文件 |--jquery |--jqeury.js |--sea.js |--static //存放自定义模块js |--main.js |--index.html //调用页面 seajs页面引入 下面开始，首先看下index：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;seajs example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id="title"&gt;seajs demo&lt;/h1&gt; &lt;script src="sea-module/sea.js"&gt;&lt;/script&gt; &lt;script&gt; seajs.use('./static/main.js'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 首先引入sea.js文件，然后通过seajs.use加载main.js文件。我们再来看看main.js:
define(function(require,exports,module) { var title= document.getElementById('title'); title.innerHTML = "yes it works" }) define()用来定义模块文件，具体参数等介绍可以参考文章开头介绍的文章。此处，页面会输出yes it works,是main.js修改了id为title的标签的文本内容，并没有引用其他模块文件。
模块文件引入 我们自定一个模块changeText.js:
define(function (require, exports, module) { var textContent = 'yes it works'; exports.text = textContent; //or //module.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b35d662390568056857775a5c7c3679/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f1f6c65be34c0db3f9babad9e557523/" rel="bookmark">
			eclipse 中导入源码出现 The declared package does not match the expected package的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eclipse 导入项目，有时候会出现 java 文件图标由实心J变成空心J的问题，这个时候是不能编辑源文件的，至于解决办法就是右键该文件夹 – &gt;BuildPath –&gt; use as source folder
当以上问题解决后，如果你选择的文件路径不对，打开一个 java 文件就会出现首行的包命报错，The declared package does not match the expected package，这个主要是右键文件的时候，没有定位到正确的位置，这个问题的解决办法就是先从 source folder 移除掉你添加的文件，然后定位到你包名的上一级目录，如 java文件包名为 com.eaphy.platform.patch.slogon.action ，报错提示包名应该是 java.com.eaphy.platform.patch.slogon.action ，那么，右键的文件夹就应该在 java 这一级，然后 BuildPath –&gt; use as source folder 这样就ok了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86a48b0cb9da4c03e16c6e089bee0aa/" rel="bookmark">
			Mongodb安装配置详细图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、安装 1 下载 MongoDB 的安装包
https://www.mongodb.com/download-center/community
进入官网，选择安装包类型为msi，点击下载
2.安装过程需要注意以下步骤
选择Custom
点Browse，设置目录为D:\Tools\MongoDB\Server\4.2
这里需要设置数据库的数据存储路径为D:\Tools\MongoDB\Server\4.2\data，日志存储路径：D:\Tools\MongoDB\Server\4.2\log
二、设置 1.win+S搜索cmd右键命令提示符，注意这里必须以管理员身份打开，否则后续配置服务会出错误：Error connecting to the Service Control Manager
win10
win7
2.输入以下命令，设置服务
D: cd D:\Tools\MongoDB\Server\4.2\bin mongod --dbpath "D:\Tools\MongoDB\Server\4.2\data" --logpath "D:\Tools\MongoDB\Server\4.2\log\MongoDB.log" --install --serviceName "MongoDB" 3.使用以下命令启动/关闭服务
NET start MongoDB NET stop MongoDB 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd34cb88b5142f5d2dc2519a324f6bd7/" rel="bookmark">
			第一篇  Python图片处理模块PIL（pillow）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇包含：一、Image类的属性：1、Format 2、Mode 3、Size 4、Palette 5、Info
二、类的函数：1、New 2、Open 3、Blend 4、Composite 5、Eval 6、Frombuffer 7、Fromstring 8、Merge
三、Image类的方法：1、Convert 2、Copy 3、Crop 4、Draft 5、Filter 6、Fromstring 7、Getbands 8、Getbbox 9、Getcolors 10、Getdata 1 1、 Getextrema 12、Getpixel 13、Histogram 14、Load 15、Paste
一、PIL的基本概念：
PIL中所涉及的基本概念有如下几个：通道（bands）、模式（mode）、尺寸（size）、坐标系统（coordinate system）、调色板（palette）、信息（info）和滤波器（filters）。
1、 通道
每张图片都是由一个或者多个数据通道构成。PIL允许在单张图片中合成相同维数和深度的多个通道。
以RGB图像为例，每张图片都是由三个数据通道构成，分别为R、G和B通道。而对于灰度图像，则只有一个通道。
对于一张图片的通道数量和名称，可以通过方法getbands()来获取。方法getbands()是Image模块的方法，它会返回一个字符串元组（tuple）。该元组将包括每一个通道的名称。
Python的元组与列表类似，不同之处在于元组的元素不能修改,元组使用小括号，列表使用方括号，元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。
方法getbands()的使用如下：
from PIL import Image
im = Image.open("xiao.png")
print(im.getbands())
输出：
('R', 'G', 'B') 2、 模式
图像的模式定义了图像的类型和像素的位宽。当前支持如下模式：
1：1位像素，表示黑和白，但是存储的时候每个像素存储为8bit。 L：8位像素，表示黑和白。 P：8位像素，使用调色板映射到其他模式。 RGB：3x8位像素，为真彩色。 RGBA：4x8位像素，有透明通道的真彩色。 CMYK：4x8位像素，颜色分离。 YCbCr：3x8位像素，彩色视频格式。 I：32位整型像素。 F：32位浮点型像素。 PIL也支持一些特殊的模式，包括RGBX（有padding的真彩色）和RGBa（有自左乘alpha的真彩色）。 可以通过mode属性读取图像的模式。其返回值是包括上述模式的字符串。
属性mode的使用如下：
from PIL import Image im = Image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd34cb88b5142f5d2dc2519a324f6bd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c764a6f6883126c14e57e0b9164a9675/" rel="bookmark">
			ado.net SqlHelp类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Data; using System.Data.SqlClient; namespace Reservation.DAL { public class SqlHelper { /// &lt;summary&gt; /// 自定义数据库连接字符串 /// &lt;/summary&gt; public static string ConnString = @"Data Source=.;Initial Catalog=DB_Date_Plan; User ID=sa;Pwd=111111"; /// &lt;summary&gt; /// 应用程序下获取连接字符串 /// &lt;/summary&gt; //public static string ConnString //{ // get { // return System.Configuration.ConfigurationManager.ConnectionStrings["connstring"].ToString(); // } //} /// &lt;summary&gt; /// 执行一个Sql语句返回受影响的行数 /// &lt;/summary&gt; /// &lt;param name="sql"&gt;insert,update,delete或相关的存储过程&lt;/param&gt; /// &lt;param name="type"&gt;命令类型：SQL语句还是存储过程&lt;/param&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c764a6f6883126c14e57e0b9164a9675/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31f0410e96b25aaedc0f212c7c7d4e69/" rel="bookmark">
			2017.07.06 IT项目管理笔记整理 第四章软件项目进度管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进度是对执行的活动和里程碑所制定的工作计划日期表。 进度问题是项目生命周期内造成项目冲突的主要原因。
时间管理原则： 1、区分重要与紧急的关系 2、适当运用Pareto原则 3、合理预算 4、有限反应 5、果断决策 6、大胆、完整的授权 7、例外管理 8、效能与效率 9、活动与效果
时间管理技巧： 1、每日计划 2、预料 3、分析时间 4、最后时限 5、上交问题 6、合并 7、反馈 8、计划躲避 9、可见性 10、习惯
软件项目进度管理的主要过程： 1活动定义，确定项目团队成员和项目干系人为完成项目可交付成果而必须完成的具体活动
2活动排序与历时估算，确定项目活动之间的关系，估计完成具体活动所需要的工作时段数
3制订进度计划，分析活动顺序、活动历时估计和资源要求，制订项目计划
4进度计划控制，分析和管理项目进度计划的变更
成本预算和进度管理是制定软件项目的计划和依据，是实现软件本身，以及获得利益的保障。
确定活动顺序之间的关系：1、强度依赖关系：工作任务中固有的依赖关系；如测试活动一定是在编码任务之后执行。 2、自由依赖关系 ：由项目组定义的依赖关系。如：安排计划的时候，哪个模块先做，哪个模块后做，这些都可以由项目组确定。 3、外部依赖关系：项目与非项目活动之间的关系，如软件项目的交付上线可能会依赖客户环境准备情况
项目工期估算的方式： 1、专家评审形式 2、模拟估算 3、定量型的基础工期
4、保留时间，在工期估算中预留一定比例的冗余时间以应付项目风险
如何确定完成项目所需的活动：（1）进行工作结构分解WBS，随着分解的细化各项活动就可得出；（2软件活动定义是一个过程，完成了这些活动就意味着完成了WBS中的各项功能。
软件项目计划的原则和要素： 原则：项目计划在项目启动时制订，并随着项目的进展不断演进。
要素：1、目标 2、合理的概念设计 3、WBS 4规模估计 5、工作量估计 6、项目进度安排
软件项目计划的逻辑要点：1项目计划的第一步就是把模糊的需求准确化
2项目的概念设计，概念设计是项目计划的基础，为工作的计划和实施提供组织框架
3资源配置和进度安排 4需求足够清晰时，应该进行详细设计，制订实现策略并纳入计划之中 5充分理解项目各部分后，确定实施细节并在下次计划更新时形成文档 6在整个项目周期中，项目计划为各种资源的配置提供框架 项目计划的内容： 1、项目的目标 2、WBS把项目分解为可直接操作的元素
3、资源配置是根据经验和相应的规则，确定各部分需要的资源
4、进度安排是根据资源配置情况和项目的实际背景，制订项目的进度 采用的活动排序工具和技术：网络图法和关键路径分析法。 项目活动排序，即活动之间的关系：涉及审查WBS中的活动、详细的产品说明书、假设和约束条件，以决定活动之间的相互关系，并需要评价活动之间的依赖关系和原因。
采用的活动排序工具和技术：网络图法和关键路径分析法。
活动排序工具——网络图：用网络分析方法编制的进度计划称为网络图。是20世纪50年代末发展起来的编制大型工程进度计划的有效方法。用图形直观地显示项目各项活动之间的逻辑关系和排序。网络图是活动排序的结果，它可以展示各项目活动之间的关系。通过网络图可识别关键活动，并确定某一活动进度的变化对后续工程和总工期的影响。两种：节点型网络图(单代号网络图PDM)和箭线型网络(双代号网络图ADM)。
关键路径法CPM和计划评审技术PERT都采用网络图来表示项目的任务。
关键路径：完成各个任务需要时间最长的路径。组成关键路径的任务称为关键任务。如果能够缩短关键任务所需的时间，就可以缩短项目的完工时间。而缩短非关键路径上的各个任务所需要的时间，却不能使项目完工时间提前。
活动排序工具——甘特图：是各种任务活动和日历表的对照图。它用水平线段表示任务工作阶段，用线段的长短表示任务需要的时间，起点和终点表示任务的开始和结束。优点：可动态反映开发进展情况。缺点：不能表达各任务之间复杂的逻辑关系
资源图用于显示项目进展过程中资源的分配情况，包括人力资源、设备资源等。
人力资源安排的技巧：安排人力资源时一定要合理，不能少也不可多，人数多了进行沟通的渠道就多了管理的复杂度就高了，对项目经理的要求也高了。 成本预算和进度管理是制定软件项目的计划和依据，是实现软件本身，以及获得利益的保障。 软件项目面临的最大挑战：按时交付.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31f0410e96b25aaedc0f212c7c7d4e69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9666f81678cdf54ea639d5a192080f3/" rel="bookmark">
			IOS Block 的使用 weakSelf strongSelf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Block块 在OC里边应该是比较常见和使用的了，本文只是根据个人经验，记录一些关键的用法提示点和注意点，以方便以后的查找和学习：
一、 首先，稍微说下block
Block是C级别的语法和运行时特性。Block比较类似C函数，但是Block比之C函数，其灵活性体现在栈内存、堆内存的引用，我们甚至可以将一个Block作为参数传给其他的函数或者Block。
二、 Block 在使用中会引起一些循环引用的问题(weakSelf的使用)
Block 会 引用 本身，而 本身 又 引用 了 Block。因为在 OC 中，直接调用一个实例变量，会被编译器处理成 ‘self-&gt;变量’，’self’ 是一个 strong 类型的变量，引用计数会加 1，于是，self 引用 队列， 队列 引用 block，block 引用 self。要判断是否会循环引用，主要是看block是否直接或间接的被self持有。
例1：
self.testBlock = ^(NSString *str){ NSLog(@"%@",self.test); }; testBlock是’self ‘的属性，‘self’对testBlock是持有关系，而又在testBlock里边调用了‘self’，如果testBlock内部没有使用weakSelf将会引起循环引用，造成内存泄露。 例2：
TestBlock testBlock = ^() { NSLog(@"%@",self.test); }; testBlock不是’self ‘的属性，因此就算是在testBlock内部使用了‘self’也不会造成内存泄露。 例3：
[Test testBlock:^(NSString *str){ NSLog(@"%@",self.test); }]; 类方法调用，因‘self’没有持有该block，就算在block内部使用了‘self’也不会造成内存泄露。就像，调用UIView的动画或者使用Masonry一样。 例4：
[self.test testBlock:^(NSString *str){ NSLog(@"%@",self.test.name); }]; block不是’self.test ‘的属性，因此就算是在block内部使用了‘self.test’也不会造成内存泄露。 例5：
self.test.testBlock = ^(NSString *str){ NSLog(@"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9666f81678cdf54ea639d5a192080f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/497b948f82d09a33c866861a009ac372/" rel="bookmark">
			linux环境下生成文件，文件名称中文乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：http://blog.csdn.net/petershusheng/article/details/56666194
原文地址：http://blog.csdn.net/youling_lh/article/details/9475519
今天项目中遇到通过web上传文件到文件系统时，中文文件名乱码，一步步排查了http通讯过程中的编解码(通过utf-8)都没有发现问题。操作系统的默认字符集也是utf-8。 通过日志打印System.getProperty(“file.encoding”)也是utf-8码。。。。一时凌乱了！！ 最后通过查资料，发现通过Java写文件时文件名编码和System.getProperty(“sun.jnu.encoding”)有关，打印此环境属性发现输出竟然是ANSI的一种编码，终于找到问题爆发点，通过在程序中设置System.setProperty(“sun.jnu.encoding”,”utf-8”)解决问题。
通过问题解决得出结论：sun.jnu.encoding 影响文件名的创建，而 file.encoding 则影响到文件内容。
所以说，在我们使用 Java 处理中文文件的时候，如果发现文件的中文内容没有乱码，而文件的中文名发生乱码，我们就应当多考虑一下 sun.jnu.encoding 和 file.encoding 的区别了。
如果实在没解决问题，看下面这个： http://blog.csdn.net/petershusheng/article/details/68491874
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/919b519649d2f32fb5073772cfa70042/" rel="bookmark">
			glReadPixels读取buffer并转换成BMP图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.glReadPixels
glReadPixels(GLint x,GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid*pixels)
glReadPixels 是将GPU渲染完数据，从GPU回传到host端的唯一方式，由入参（x,y,w,h）制定一个从一帧图像中读取内存的矩形，type和format指定格式，pixels是输出像素的buffer
注意：glReadPixels实际上是从缓冲区中读取数据，如果使用了双缓冲区，则默认是从正在显示的缓冲（即前缓冲）中读取，而绘制工作是默认绘制到后缓冲区的。因此，如果需要读取已经绘制好的像素，往往需要先交换前后缓冲
int *pixel = (int*)malloc(sizeof(int)*1440*2560);
memset(pixel,0,sizeof(int)*1440*2560);
//int pixel[1440][2560];
glPixelStorei(GL_PACK_ALIGNMENT,1);
printf("---------1-------\n");
glReadPixels(0, 0, 1440, 50,GL_RGBA, GL_UNSIGNED_BYTE,pixel );
dump_picture("simple-egl",pixel,1440,50);
2.dump buffer到本地
void dump_picture(char *name,const void *ptr,int w,inth)
{
int fd= -1;
staticint dumpcnt = 1000;
charfilename[1024];
intp_size = 0;
intret_w = 0;
sprintf(filename, "/tmp/dumpfiles/cts-%s-%d_%dx%d-%d",name,getpid(), w, h, dumpcnt);
fd =open(filename, O_WRONLY|O_CREAT|O_APPEND, 0777);
printf("------%s:[%s] dumpidx=%d, fd=%d,w,h=(%d,%d)\n", name,__func__,dumpcnt, fd,w,h);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/919b519649d2f32fb5073772cfa70042/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d67dd7950925fda8c34b3e82a2d88be/" rel="bookmark">
			Python  numpy  提取矩阵的某一行或某一列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import numpy as np a=np.arange(9).reshape(3,3) a Out[31]: array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) 矩阵的某一行
a[1] Out[32]: array([3, 4, 5]) 矩阵的某一列
a[:,1] Out[33]: array([1, 4, 7]) b=np.eye(3,3) b Out[36]: array([[ 1., 0., 0.], [ 0., 1., 0.], [ 0., 0., 1.]]) 把矩阵a的第2列赋值给矩阵b的第1列
b[:,0]=a[:,1] b Out[38]: array([[ 1., 0., 0.], [ 4., 1., 0.], [ 7., 0., 1.]]) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/282b014cdb23dc902b9baa462b5d1955/" rel="bookmark">
			初探JsonCpp - 编译与基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSON(JavaScript Object Notation，JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成，有效地提升了网络传输效率。
本文主要介绍 JSON 第三方解析库 JsonCpp 的安装编译过程以及基本使用。
编译 在 https://sourceforge.net/projects/jsoncpp/ 我们可以获取到 JsonCpp 库。
CentOS上 的编译过程如下：
1）解压缩。 2）在编译生成动态和静态库之前，我们需要安装 linux 下的自动构建工具 scons，步骤如下图。 解压缩，然后进入目录 scons-2.2.0。 3）利用自动构建工具 scons 生成所需的 libjson，操作如图。 执行完毕，会在目录 jsoncpp-src-0.5.0/libs/linux-gcc-4.4.7 下生成库文件： 然后，将动态链接库 libjson_linux-gcc-4.4.7_libmt.so 添加到搜索路径中。
至此，编译就完成了，接下来我们来看看 JsonCpp 的基本使用。
基本使用 (1)JsonCpp简介 JsonCpp 主要包含三种类型的class：Value、Reader和Writer： ①Json::Value 是 JsonCpp 中最基本、最重要的类，用于表示各种类型的对象，JsonCpp 支持的对象类型可见 Json::ValueType 枚举值。
②Json::Reader 是用于读取的，说的确切点，是用于将字符串转换为 Json::Value 对象的。
③Json::Writer 类是一个纯虚类，并不能直接使用。我们一般使用 Json::Writer 的子类：Json::FastWriter、Json::StyledWriter 和 Json::StyledStreamWriter。
(2)使用示例 1）示例1：从字符串中读取JSON 代码如下：
#include "json/json.h" #include &lt;iostream&gt; using namespace std; int main() { const char* strValue = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/282b014cdb23dc902b9baa462b5d1955/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c823e451a5c107a184cfe4489b5d207/" rel="bookmark">
			Java HotSpot VM Options
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Please note that this page only applies to JDK 7 and earlier releases. For JDK 8 please see the Windows, Solaris, Linux and Mac OS X reference pages. This document provides information on typical command-line options and environment variables that can affect the performance characteristics of the Java HotSpot Virtual Machine. Unless otherwise noted, all information in this document pertains to both the Java HotSpot Client VM and the Java HotSpot Server VM.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c823e451a5c107a184cfe4489b5d207/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b596cc7a198bbd45fa61d232c9eac45/" rel="bookmark">
			android启动流程分析（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇介绍了apk启动的流程到了创建activity的创建这里接着继续分析，先上图片
看高清图请下载
这里从handleLaunchActivity方法继续分析，如不明白的可以参考上一篇的分析android启动流程分析，这边直接就上代码了
private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) { ...... Activity a = performLaunchActivity(r, customIntent);//创建activity if (a != null) { r.createdConfig = new Configuration(mConfiguration); reportSizeConfigurations(r); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); ...... } else { ...... } } private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ...... Activity activity = null; try { java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b596cc7a198bbd45fa61d232c9eac45/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/450/">«</a>
	<span class="pagination__item pagination__item--current">451/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/452/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>