<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17270f468e554489c3d56e5eedd99125/" rel="bookmark">
			C#里的InputBox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在.NET Framework中并没有类似VB中的InputBox函数，虽然可以借助对VB 的Runtime引用，以在VB除外的.NET程序中使用VB的InputBox，但是为什么不自己写一个类实现类似的功能呢？
下面一个类实现了类似的InputBox函数的功能:
using System;
using System.Windows.Forms;
namespace Input
{
/// &lt;summary&gt;
/// clsInputBox 的摘要说明。
/// &lt;/summary&gt;
public class InputBox : System.Windows.Forms.Form {
private System.Windows.Forms.TextBox txtData;
private System.Windows.Forms.Label lblInfo; private System.ComponentModel.Container components = null; private InputBox() { InitializeComponent(); } protected override void Dispose( bool disposing ) { if( disposing ) { if(components != null) { components.Dispose(); } } base.Dispose( disposing ); } private void InitializeComponent() { this.txtData = new System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17270f468e554489c3d56e5eedd99125/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22abff334e1e57eceeb5b9ba8aab5d69/" rel="bookmark">
			PHP&#43;Ajax点击加载更多内容 －这个效果好，速度快，只能点击更多加载，不能滚动自动加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP+Ajax点击加载更多内容 －这个效果好，速度快，JS代码虽然没看懂但感觉很专业写的，测试通过了，现在是点击显示更多才会加载，只能点击更多加载，不能滚动自动加载
一、HTML部分
&lt;div id="more"&gt; &lt;div class="single_item"&gt; &lt;div class="element_head"&gt; &lt;div class="date"&gt;&lt;/div&gt; &lt;div class="author"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="content"&gt;&lt;/div&gt; &lt;/div&gt; &lt;a href="javascript:;" class="get_more"&gt;::点击加载更多内容::&lt;/a&gt; &lt;/div&gt; 二、引入jQuery插件和jquery.more.js加载更多插件
$(function(){ $('#more').more({'address': 'data.php'}) }); 三、jQuery
$(function(){ $('#more').more({'address': 'data.php'}) }); 四、data.php data.php接收前台页面提交过来的两个参数， POST[′last′]即开始记录数， _POST[‘amount’]即单次显示记录数，看SQL语句就明白，其实就是分页中用到的语句。
require_once('connect.php'); $last = $_POST['last']; $amount = $_POST['amount']; $query = mysql_query("select * from article order by id desc limit $last,$amount"); while ($row = mysql_fetch_array($query)) { $sayList[] = array( 'title' =&gt; "&lt;a href='http://www.sucaihuo.com/js/".$row['id'].".html' target='_blank'&gt;".$row['title']."&lt;/a&gt;", 'author' =&gt; $row['id'], 'date' =&gt; date('m-d H:i', $row['addtime']) ); } echo json_encode($sayList); 五、jquery.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22abff334e1e57eceeb5b9ba8aab5d69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f31b1e9fe1753ec848898d564c1b088/" rel="bookmark">
			OC代码规范总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://github.com/Tim9Liu9/TimLiu-iOS/blob/master/OC%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93.md
# Objective-C-Coding-Guidelines-In-Chinese
Objective-C编码规范，内容来自苹果、谷歌的文档翻译，[『博爱』](https://github.com/boai)的编码经验和对其它资料的总结。 详情可前往：开源项目[『BABaseProject』](https://github.com/boai/BABaseProject)！ * [转载至:](https://github.com/boai/BABaseProject)BABaseProject ##概要 Objective-C是一门面向对象的动态编程语言，主要用于编写iOS和Mac应用程序。关于Objective-C的编码规范，苹果和谷歌都已经有很好的总结： * [Apple Coding Guidelines for Cocoa](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html) * [Google Objective-C Style Guide](https://google-styleguide.googlecode.com/svn/trunk/objcguide.xml?showone=Line_Length#Line_Length) 本文主要整合了对上述文档的翻译、作者自己的编程经验和其他的相关资料，为公司总结出一份通用的编码规范。 ##代码格式 ###使用空格而不是制表符Tab 不要在工程里使用Tab键，使用空格来进行缩进。在`Xcode &gt; Preferences &gt; Text Editing`将Tab和自动缩进都设置为**4**个空格。（_Google的标准是使用两个空格来缩进，但这里还是推荐使用Xcode默认的设置。_） ###每一行的最大长度 同样的，在`Xcode &gt; Preferences &gt; Text Editing &gt; Page guide at column:`中将最大行长设置为**80**，过长的一行代码将会导致可读性问题。 ###函数的书写 一个典型的Objective-C函数应该是这样的： ```objective-c - (void)writeVideoFrameWithData:(NSData *)frameData timeStamp:(int)timeStamp { ... } ``` 在`-`和`(void)`之间应该有一个空格，第一个大括号`{`的位置在函数所在行的末尾，同样应该有一个空格。（_我司的C语言规范要求是第一个大括号单独占一行，但考虑到OC较长的函数名和苹果SDK代码的风格，还是将大括号放在行末。_） 如果一个函数有特别多的参数或者名称很长，应该将其按照`:`来对齐分行显示： ```objective-c -(id)initWithModel:(IPCModle)model ConnectType:(IPCConnectType)connectType Resolution:(IPCResolution)resolution AuthName:(NSString *)authName Password:(NSString *)password MAC:(NSString *)mac AzIp:(NSString *)az_ip AzDns:(NSString *)az_dns Token:(NSString *)token Email:(NSString *)email Delegate:(id&lt;IPCConnectHandlerDelegate&gt;)delegate; ``` 在分行时，如果第一段名称过短，后续名称可以以Tab的长度（4个空格）为单位进行缩进： ```objective-c - (void)short:(GTMFoo *)theFoo longKeyword:(NSRect)theRect evenLongerKeyword:(float)theInterval error:(NSError **)theError { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f31b1e9fe1753ec848898d564c1b088/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4c9b8f619a9ad13dcf92cbdced55083/" rel="bookmark">
			unsigned/signed int/char类型表示的数值范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个32位的signed int类型整数表示的范围：-2^31~2^31-1
一个32位的unsigned int类型整数表示的范围: 0~2^32-1
一个8位的signed char类型整数表示的范围：-2^7~2^7-1
一个8位的unsigned char类型整数表示的范围: 0~2^8-1
示例：
int main() { char a[1000]; int i = 0; for(i=0; i&lt;1000; i++) { a[i] = -1 - i; } printf("%d\n", strlen(a)); return 0; } 答案：255
分析：
当i的值为0时，a[0]的值为-1，关键就是-1在内存是如何存储的。
我们知道，在计算机内部数值一律使用补码存储。正数的补码与原码一致，负数的补码是符号位为1，其余位是该负数的绝对值按位取反后加1得到。
按照负数的补码规则，可以知道-1的补码是0xff，-2的补码是0xfe。。。当i的值为127的时候，a[127]的值为-128，是char能表示的最小的数值。当i=129时，a[128]=-129，这时候发生溢出，-129需要9位才能保存下来，但是char的类型数据只有8位，所以最高位被丢弃，剩下的8位是原来9位补码的低8位，为1000 0000,当i增加到255时候，a[255]=-256,-256的补码的低8位是0000 0000，然后i=256时，a[256]=-257的补码低8位为1111 1111，由此开始新一轮的循环。。。。
按照上面的分析，a[0]---a[254]的值都不为0，而a[255]的值为0，strlen函数是计算字符串长度的，并不包含字符串最后的'\0'。所以strlen(a)=255.
那么，+0和-0在内存是如何存储的呢？
十进制 原码 反码 补码
+0 0000 0000 0000 0000 0000 0000
-0 10000 0000 1111 1111 0000 0000
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ab974112c215ea27a171d026b164e8/" rel="bookmark">
			jquery插入元素的几种方法 insertBefore()  insertAfter() prependTo() appendTo()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、insertBefore() / insertAfter()方法，都是指在元素的外部插入新内容 如下： 创建一个a标签，并将其插入到class为 chapter 的p元素的后面。 通过下面的代码，&lt;div class="chapter"&gt; 中的每个段落后面，都会出现一个back to top的链接
$(document).ready(function(){ $('&lt;a href="#top"&gt;back to top&lt;/a&gt;').insertAfter('div.chapter p'); }) 2、prependTo() / appendTo()
在现有元素内部、之前（之后）添加内容； 例如创建一个锚并将其插入到boday元素的前面
$(document).ready(function(){ $('&lt;a id="top"&gt;&lt;/a&gt;').prependTo('body'); }) 如上，这里的a插入到了body的顶部，并且是在其内部
insertBefore() 在现有元素外部、之前添加内容insertAfter() 在现有元素外部、之后添加内容prependTo() 在现有元素内部、之前插入内容appendTo() 在现有元素内部、之后插入内容 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79363bb705a4198eb660c82270f66c1d/" rel="bookmark">
			《亿级流量网站架构核心技术》一书值得看吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扫一扫，关注我的公众号 我的新书 购买地址
在“《亿级流量网站架构核心技术》目录一览”中，已经介绍了本书的大体内容，其中主体内容是2014年/2015年/2016年公众号/博客文章的汇编，比如聊聊高并发系列、商品详情页架构系列、还有一些碰到并解决的问题等。
比如聊聊高并发系列，内容偏理论，如何实现并没有过多介绍。《亿级流量网站架构核心技术》一书会补充案例，让大家能落地到自己系统中。
聊聊高并发之隔离术
聊聊高并发系统之限流特技-1
聊聊高并发系统之限流特技-2
聊聊高并发系统之降级特技
聊聊高并发系统之HTTP缓存
应用多级缓存模式支撑海量读服务
聊聊java高并发系统之异步非阻塞
商品详情页系统的Servlet3异步化实践
聊聊高并发系统之队列术
还有一些架构方面的文章也会节选到《亿级流量网站架构核心技术》一书中，让大家有更多的思路设计高可用高并发系统。
构建亿级前端读服务
前端交易型系统设计原则
构建需求响应式亿级商品详情页
京东商品详情页服务闭环实践
使用Nginx+Lua(OpenResty)开发高性能Web应用
应用数据静态化架构高性能单页Web应用
还有一些系统要注意的问题，也会总结到《亿级流量网站架构核心技术》一书，提醒大家在开发系统时要时刻注意一些坑。
应知道的数据库连接池DBCP配置及JDBC超时设置
使用httpclient必须知道的参数设置及代码写法、存在的风险
《亿级流量网站架构核心技术》一书加了很多内容，案例更丰富，而且也有代码和源码解读，希望本书大家看后不会失望，希望这本书能成为大家的案头书，遇到问题随时查阅。
也会通过二维码嵌入一些本公众号之前发过的一些案例，给大家提供更多的案例参考来理解书中的内容。
服务降级背后的技术架构设计
高性能高并发系统的稳定性保障
京东大促备战思路和方法2.0解密
京东一元抢宝系统的数据库架构优化
《亿级流量网站架构核心技术》一书书稿已经交给电子工业出版社，侠少、杨璐等正在紧锣密鼓编辑中，希望能在春节前后与大家见面。
请关注二维码，新书的动向会第一时间发布到我的公众号中。
扫一扫，关注我的公众号 我的新书 购买地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60c7716fec91322a8df9f61b0674ef60/" rel="bookmark">
			巧妙地把windows搭建成代理服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 背景 在现实情景中，我们仅有一台windows 主机可以上网（在公司的生产环境、测试环境、各种其他场景下，由于各种安全策略或者上网限制，其他服务器均无法上网。但是我们在测试、生产中，可能需要其他服务器联网获取更新包、插件包、安装包、策略文件等。这就要求我们通过一台可以上网的机器作为代理进行中转。
0x02 CCproxy 代理软件 CCproxy 可以很简答地把一台windows server 变成代理服务器，并且提供多样的功能。
1 下载安装 地址为：http://www.ccproxy.com/，下载安装文件后，点击安装即可，然后点击桌面的图标【CCproxy 】即可运行软件。演示版其中可以提供免费的3个连接用户，也就是说同一个时间CCProxy只能有3个IP同时连接这代理服务器。如果数目超过3个，就需要购买该软件。
2 温馨小提示 我们可以根据自己的上网需求，当某些服务器需要上网的时候，连接该软件；当不需要上网的时候，断开连接。这样就可以动态使用3个用户的数目了。当然聪明的同学可以百度搜索各种破解版。或者对于我们需要通过这个代理的个人都设置为相同IP(虽然会产生IP冲突，但是不影响上网的）.当然各位同学还有各种流光溢彩的方式，欢迎补充。
3 代理服务器信息 代理服务器的IP ： 192.168.1.108
代理服务器的port ： 808
只要在其他服务器的网络设置把代理设置为以上的配置就行了，或者在其他服务器上的某个软件中，把代理设置为以上配置。例如在其他服务器中的IE把代理设置为以上IP和端口，即可使用代理上网；再如在nessus激活界面，点击 【advance】，弹出代理服务器的设置，填入以上配置，即可通过代理上网了。 0x03 使用apache 代理服务器 我们也可以使用apache 作为代理服务器，从而把一台windows 主机打造成一台代理服务器，让其他主机通过这台windows 主机来上网。
1 下载安装 下载地址：http://httpd.apache.org/docs/current/platform/windows.html#down其中前三个网站是可以独立下载apache httpd的，后面两个是包含 Apache httpd, and,PHP and MySQL的集成环境。在这里我们只是需要apache httpd 。
我选择了第一个链接：ApacheHaus， 点击后将会打开：http://www.apachehaus.com/cgi-bin/download.plx
这时，我们根据自己的windows 服务器的版本选择，我选择了 Apache2.2 点击红色箭头的图标，即可进入下载链接，进行下载。
下载得到httpd-2.2.31-x64-r6.zip ，解压到目录D:\Apache22；在目录：D:\Apache22\bin 下点击httpd.exe 可以开启服务；点击ApacheMonitor.exe可以开启监控
在浏览器中输入http://localhost/ 应当能够看到Apache的欢迎画面。
2 加载代理模块 在目录：D:\Apache22\conf 找到 文件：httpd.conf， 找到以下模块，把它们前面的【#】去掉。HTTP 、FTP 、HTTPS sites
#LoadModule proxy_module modules/mod_proxy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60c7716fec91322a8df9f61b0674ef60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66483e73d308ad13029fcb4e877fd9b6/" rel="bookmark">
			安装vs2015中文版语言提示“The language pack is already installed”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中文语言下载地址：https://www.microsoft.com/zh-CN/download/details.aspx?id=48157
选择中文“Chinese (Simplified)”，等待页面刷新，然后点击下载安装即可。
注意：有些人也是选择中文的，但是没有等页面刷新就点击下载，其实也下载成功，但是你下载的还是英文版本，运行时提示“The language pack is already installed. To install an additional language, please install the language pack for that language”，意思就是你已经安装了此语言版本。其实你安装的还是英文版本，根本没有下载中文的安装包。
如下图错误的下载界面：
此时界面还是英文介绍，所以你下载的是英文版语言包。
正确的界面如下图：
这个时候已经切换到中文版语言包，下载安装后，需要到vs菜单 “tool”=》“option”=》“区域设置” 里选择中文简体，再重启vs。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d024a124b75964457186e2e3d00337b2/" rel="bookmark">
			http调试相关文章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 快速认识和使用浏览器跟踪Http服务及Http服务调试工具 http://wwwbuild.net/CSDNnews/209445.html
2. chrome安装插件，安装Postman
http://blog.csdn.net/u010246789/article/details/51481134
3. 接口测试从未如此简单 - Postman (Chrome插件) http://www.cnblogs.com/wade-xu/p/4228954.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f230465e1c612a43211a63f7d672a5e/" rel="bookmark">
			Android 仿今日头条评论输入框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信不少小伙伴，在做评论功能的时候，都被输入框恶心过。 产品总会要求，自己的产品输入框要有自己特色。 既然如此，那就自己写一个呗。 先上效果图： 做一个输入框dialog很难吗？可能有些接触android不久的小小伙伴会觉得，难以入手。那我们就拆成几部来做，其实很简单。 第一步： 写弹出框样式布局 布局就一个EditText和一个TextView，做了下背景的圆角和描边处理，很快我们就可以撸出来了。在自定义View的时候，将这个布局inflate出来。 第二步 软键盘顶起dialog 可能有的手机什么都不设置，软键盘就会把dialog弹起，有的手机则会遮住dialog布局。
getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN); 详情参考 谷哥的小弟 探索Android软键盘的疑难杂症http://blog.csdn.net/lfdfhl/article/details/52415390 第三步 布局做好了，你的软键盘也确定在挡住dialog位置的时候，会把dialog弹起，那剩下的事，就是讲dialog置于屏幕底部，点击需要评论的时候，showDialog，然后EditText聚焦，软键盘弹出讲dialog顶起，自然我们想要的效果就出来了 自定义评论框Dialog代码
import android.annotation.SuppressLint; import android.app.Dialog; import android.app.ProgressDialog; import android.content.Context; import android.content.DialogInterface; import android.os.Bundle; import android.os.Handler; import android.support.v4.app.DialogFragment; import android.text.Editable; import android.text.TextUtils; import android.text.TextWatcher; import android.view.Gravity; import android.view.View; import android.view.Window; import android.view.WindowManager; import android.view.inputmethod.InputMethodManager; import android.widget.EditText; import android.widget.TextView; import android.widget.Toast; public class KeyMapDailog extends DialogFragment { //点击发表，内容不为空时的回调 public SendBackListener sendBackListener; public interface SendBackListener{ void sendBack(String inputText); } private ProgressDialog progressDialog; private String texthint; private Dialog dialog; private EditText inputDlg; private int numconut=300; private String tag=null; public KeyMapDailog() { } @SuppressLint("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f230465e1c612a43211a63f7d672a5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/053b0df628e6a64180c14a2f645e7b57/" rel="bookmark">
			JAVA对象jackson序列化json属性名首字母变成小写的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java代码对象如下：
package com.ctrip.market.messagepush.service.entity; import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.annotation.JsonProperty; public class WaitSendModel { public long MsgID; public String GroupID; public int SendLevel; public int SendType; public long getMsgID() { return MsgID; } public void setMsgID(long msgID) { this.MsgID = msgID; } public String getGroupID() { return GroupID; } public void setGroupID(String groupID) { this.GroupID = groupID; } public int getSendLevel() { return SendLevel; } public void setSendLevel(int sendLevel) { this.SendLevel = sendLevel; } public int getSendType() { return SendType; } public void setSendType(int sendType) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/053b0df628e6a64180c14a2f645e7b57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0426b3175b4906e2fb7117f663b44874/" rel="bookmark">
			The setup files are corrupted. Please obtain a new copy of the program. 报错解决。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 在自动更新软件时候，网络发生错误，导致已启动软件就报下面错误。
The setup files are corrupted. Please obtain a new copy of the program. 即使重新安装也是报错。
最后发现下面方法可以搞定：（操作有危险，请备份自己的注册表）
按下win+r，在弹出的运行框里面输入regedit，进入注册表。
然后选择搜索，关键字就是你的软件名称。
将含有软件名字的字段都删除。
世界，清净了。
转载于:https://my.oschina.net/u/133911/blog/809222
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b74606a24952a4b040b6c250ec05aa6/" rel="bookmark">
			操作系统--信号量经典同步问题之写者优先问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写者优先比读者优先要复杂一些，写者优先有以下两个内涵：
1. 当写者线程获得临界区的访问权限时， 其他写者线程不要需要要优先于读者线程获得临界区的访问权限，只有当所有的写者线程都执行后，读者线程才能获得权限。
2. 当读者线程获得临界区的访问权限时，写者线程可以实现抢占，即写者线程优先于其他等待的读者线程，只有当所有的写者线程都执行后，读者线程才能获得权限。
有的参考书中对写者优先的定义仅限于上述第一条。有的定义需满足上述两条。下面分别用伪代码实现这两种情况。
int WriteCount=0, ReadCount=0// 共享变量
semaphore WriteMutex=1, ReadMutex=1, x=1,y=1;
void reader()
{
while(1)
{
sem_wait( ReadMutex);
sem_wait(x); // 保证原子操作
++ReadCount;
if(ReadCount ==1)
sem_wait(WriteMutex); //当有读者线程时应避免同时有写者线程进行写操作。
sem_post(x);
sem_post(ReadMutex);
read() //进行读操作
sem_wait( x) //保证原子操作
--ReadCount;
if(ReadCount==0)
sem_wait(WriteMutex);
sem_wait(x);
}
}
void writer()
{
while(1)
{
sem_wait(x) // 保证原子性，防止多个线程对WriteMutex进行操作。
++WriteCount;
if(WriteCount == 1)
sem_wait(ReadMutex); //当有写者线程时，应该禁止读操作，使写者线程的优先于读者线程。
sem_post(x);
sem_wait(WriteMutex); //这里是防止多个写者线程同时进行写操作。
write() //对临界区资源进行写操作
sem_post(WriteMutex);
sem_wait(x); //同上
--WriteCount;
if(WriteCount == 0)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b74606a24952a4b040b6c250ec05aa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e12d143518878bda925781513af84e4b/" rel="bookmark">
			Android 根据图片高度动态设置ViewPager高度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有图片的地方，就有需求。 为什么一个App有那么多的Banner，这里就不吐槽了。我们还是直接进主题，如何让ViewPager自适应图片的高度。 效果如下： 如何去改变ViewPager的高度，都知道用setLayoutParams，我们不清楚的是，在什么时候给Viewpager设置。聪明的孩子马上就想到，我们用ViewPager的时候，有一个OnPageChangeListener是用来监听viewpager滑动翻页的。
@Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) { } @Override public void onPageSelected(int position) { } @Override public void onPageScrollStateChanged(int state) { } 在这三个方法中，只有onPageScrolled是滑动过程一直调用的，而且刚好有个positionOffset是代表Viewpager的偏移量。这里我们不用OnPageSelected，光看Log日志，我们就知道它只有在页面position位置改变才会被调用，不满足Viewpager高度慢慢变化这个动态过程。 那么在onPageScrolled里我们要如何操作呢。为了更通俗的解决这个初中数学问题，我决定拿出我封印多年的截图涂鸦技术，look 从图片1到图片2，我们可以看成是图片1高度慢慢变大的过程，高度增量y =（img1高度-img2高度）的绝对值。看到这里，相信很多小伙伴就知道怎么算了，举个例子，如果你已经滑动了20%页面，那你滑动距离就是0.2x，0.2x/高度增量h=x/y ，算出来的h就是图片1增长的高度了，而我们是要给ViewPager setLayoutParams，需要拿到的具体高度就是 图片1高度+h了。 具体代码如下：
import android.graphics.Bitmap; import android.os.Bundle; import android.support.v4.view.PagerAdapter; import android.support.v4.view.ViewPager; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.Toast; import com.bumptech.glide.Glide; import com.bumptech.glide.request.animation.GlideAnimation; import com.bumptech.glide.request.target.ImageViewTarget; import com.bumptech.glide.request.target.SimpleTarget; public class MainActivity extends AppCompatActivity { private ViewPager mViewpager; private String[] urls = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e12d143518878bda925781513af84e4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13dc549cc8e6536e5a9208a53e3c4e73/" rel="bookmark">
			MySql5.6 my.cnf配置优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://blog.imdst.com/mysql-5-6-pei-zhi-you-hua/ 系统 4核 16G Centos6.5 x64
优化后测试结果如下
#mysqlslap #--concurrency=2 #--iterations=1 #--number-int-cols=10 #--number-char-cols=10 #-a #--auto-generate-sql-guid-primary #--auto-generate-sql-secondary-indexes=2 #--number-of-queries=10000 #--auto-generate-sql-load-type=write #--engine=myisam,innodb -uroot -proot --debug-info ` 结果：
Benchmark # Running for engine myisam # Average number of seconds to run all queries: 1.064 seconds # Minimum number of seconds to run all queries: 1.064 seconds # Maximum number of seconds to run all queries: 1.064 seconds # Number of clients running queries: 2 # Average number of queries per client: 5000 # Benchmark # Running for engine innodb # Average number of seconds to run all queries: 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13dc549cc8e6536e5a9208a53e3c4e73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f277952687a8698ba119c68d10499dc8/" rel="bookmark">
			C&#43;&#43;基础知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 基础架构及定义 #include&lt;...&gt;定义要包含的头文件和类库#define 常量名 常量值 定义常量using namespace std;ifstream fin("流输入文件名"); 为文件定义流输入函数fin,函数名fin可自由定义，可为若干个不同的函数名定义各自的输入流。ofstream fout("流输出文件名"); 为文件定义流输出函数fout,函数名fout只是一个输出标识符，可自由定义多组标识符与输出流的对应关系。fin.close() 关闭fin的输入流文件（可省略）fout.close() 关闭fout对应的输出流文件（可省略）//注释内容⋯⋯ 单行注释多行注释 /* 多行注释开始标记 ⋯⋯ 注释内容 */ 多行注释结束标志主函数 MAIN(){...} 主函数无返回值 int main(){... return 0;} 主函数有返回值 二、 #include可包含的库（头文件） iostream 标准输入输出流fstream 文件输入输出流cstdlib c++标准库cstdio c++输入输出模块CMATH c++数学函数库Cstring 字符串ctime 时间climits 极限库cfloat 实数库IOMANIP 流输出格式函数库algorithm 算法库vector 支持动态数组，是扩展栈容器 支持前缀比大小map建立两类数据的关联（映射）stack 基本栈结构支持s.pop(),s.push(x),s.size(),s.empty()及&gt;,&lt; s.top()queue 支持基本队列queue及优先队列priority_queue（堆）基本队列函数：q.pop() q.front() q.push(x) q.back() q.size()在queue中有前缀比较的&gt;和&lt;set 支持自平衡查找二叉树结构表示的单值集合set及多值集合multiset，其类函数支持集合的多种运算deque 扩展队列结构（循环队列容器） 支持前缀比大小list 双向链，用it++或it–在链中寻址也可用push或pop等操作支持前缀&gt;、&lt;比较bitset 位向量集合，可当数组使用，支持与或运算c语言头文件，如math.h、string.h、stdio.h等 三、 类型 bool 布尔类型，1字节，非0(false)整数视为1(true)char 1字节，可视为有符号整数，其数组可作为字符串使用short int 2字节补码整数int 4字节补码整数long long (int) 8字节补码整数作常量赋值时应带后缀ll2——5的补码整数（有符号）前面加unsigned的前缀就是无符号类型的整数例如unsigned char变为无符号字符或整数float 4字节实数（单精度浮点编码）double 8字节双精度浮点编码long double 12字节长双精度浮点编码string 在CSTRING中可用+直接连接两个字符串、可直接赋值，也可用&gt;、&lt;、==等关系符号直接比较还可以向字符数组一样逐字符地访问，结束位置有0。string s的起始位置char* s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f277952687a8698ba119c68d10499dc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89b2847464337daf115625355e83a96a/" rel="bookmark">
			[Scrapy]模拟登陆并获取Cookie值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.分析登陆网址的方式 1.1使用Firefox或者Chrom浏览器F12，以Firefox登陆广工图书馆为例（该网址设计使用Cookie来记录登陆状态） 1.2登陆前 1.3登陆后 1.4根据登陆后可见POST方法的参数
__EVENTTARGET: __EVENTARGUMENT: __VIEWSTATE:/wEPDwULLTE0MjY3MDAxNzcPZBYCZg9kFgoCAQ8PFgIeCEltYWdlVXJsBRt+XGltYWdlc1xoZWFkZXJvcGFjNGdpZi5naWZkZAICDw8WAh4EVGV4dAUt5bm/5Lic5bel5Lia5aSn5a2m5Zu+5Lmm6aaG5Lmm55uu5qOA57Si57O757ufZGQCAw8PFgIfAQUcMjAxNuW5tDEy5pyIMTPml6UgIOaYn+acn+S6jGRkAgQPZBYEZg9kFgQCAQ8WAh4LXyFJdGVtQ291bnQCCBYSAgEPZBYCZg8VAwtzZWFyY2guYXNweAAM55uu5b2V5qOA57SiZAICD2QWAmYPFQMTcGVyaV9uYXZfY2xhc3MuYXNweAAM5YiG57G75a+86IiqZAIDD2QWAmYPFQMOYm9va19yYW5rLmFzcHgADOivu+S5puaMh+W8lWQCBA9kFgJmDxUDCXhzdGIuYXNweAAM5paw5Lmm6YCa5oqlZAIFD2QWAmYPFQMUcmVhZGVycmVjb21tZW5kLmFzcHgADOivu+iAheiNkOi0rWQCBg9kFgJmDxUDE292ZXJkdWVib29rc19mLmFzcHgADOaPkOmGkuacjeWKoWQCBw9kFgJmDxUDEnVzZXIvdXNlcmluZm8uYXNweAAP5oiR55qE5Zu+5Lmm6aaGZAIID2QWAmYPFQMbaHR0cDovL2xpYnJhcnkuZ2R1dC5lZHUuY24vAA/lm77kuabppobpppbpobVkAgkPZBYCAgEPFgIeB1Zpc2libGVoZAIDDxYCHwJmZAIBD2QWBAIDD2QWBAIBDw9kFgIeDGF1dG9jb21wbGV0ZQUDb2ZmZAIHDw8WAh8BZWRkAgUPZBYGAgEPEGRkFgFmZAIDDxBkZBYBZmQCBQ8PZBYCHwQFA29mZmQCBQ8PFgIfAQWlAUNvcHlyaWdodCAmY29weTsyMDA4LTIwMDkuIFNVTENNSVMgT1BBQyA0LjAxIG9mIFNoZW56aGVuIFVuaXZlcnNpdHkgTGlicmFyeS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuPGJyIC8+54mI5p2D5omA5pyJ77ya5rex5Zyz5aSn5a2m5Zu+5Lmm6aaGIEUtbWFpbDpzenVsaWJAc3p1LmVkdS5jbmRkZAg1DiqmaepeeQ7Rw6kLdb3ah3tb __EVENTVALIDATION:/wEWBQKNu6LYBwKOmK5RApX9wcYGAsP9wL8JAqW86pcI3FE0WSxHMScWQc3QHyrMix/0xmM= ctl00$ContentPlaceHolder1$txtlogintype:0 ctl00$ContentPlaceHolder1$txtUsername_Lib:账号 ctl00$ContentPlaceHolder1$txtPas_Lib:密码 ctl00$ContentPlaceHolder1$btnLogin_Lib:登录 1.5在登陆前界面（http://222.200.122.171:7771/login.aspx）寻找POST参数，后期使用正则表达式进行筛选 ①在登陆界面（http://222.200.122.171:7771/login.aspx）寻找POST参数： &lt;input name="__EVENTTARGET" id="__EVENTTARGET" value="" type="hidden"&gt; &lt;input name="__EVENTARGUMENT" id="__EVENTARGUMENT" value="" type="hidden"&gt; &lt;input name="__VIEWSTATE" id="__VIEWSTATE" value="/wEPDwULLTE0MjY3MDAxNzcPZBYCZg9kFgoCAQ8PFgIeCEltYWdlVXJsBRt+XGltYWdlc1xoZWFkZXJvcGFjNGdpZi5naWZkZAICDw8WAh4EVGV4dAUt5bm/5Lic5bel5Lia5aSn5a2m5Zu+5Lmm6aaG5Lmm55uu5qOA57Si57O757ufZGQCAw8PFgIfAQUcMjAxNuW5tDEy5pyIMTPml6UgIOaYn+acn+S6jGRkAgQPZBYEZg9kFgQCAQ8WAh4LXyFJdGVtQ291bnQCCBYSAgEPZBYCZg8VAwtzZWFyY2guYXNweAAM55uu5b2V5qOA57SiZAICD2QWAmYPFQMTcGVyaV9uYXZfY2xhc3MuYXNweAAM5YiG57G75a+86IiqZAIDD2QWAmYPFQMOYm9va19yYW5rLmFzcHgADOivu+S5puaMh+W8lWQCBA9kFgJmDxUDCXhzdGIuYXNweAAM5paw5Lmm6YCa5oqlZAIFD2QWAmYPFQMUcmVhZGVycmVjb21tZW5kLmFzcHgADOivu+iAheiNkOi0rWQCBg9kFgJmDxUDE292ZXJkdWVib29rc19mLmFzcHgADOaPkOmGkuacjeWKoWQCBw9kFgJmDxUDEnVzZXIvdXNlcmluZm8uYXNweAAP5oiR55qE5Zu+5Lmm6aaGZAIID2QWAmYPFQMbaHR0cDovL2xpYnJhcnkuZ2R1dC5lZHUuY24vAA/lm77kuabppobpppbpobVkAgkPZBYCAgEPFgIeB1Zpc2libGVoZAIDDxYCHwJmZAIBD2QWBAIDD2QWBAIBDw9kFgIeDGF1dG9jb21wbGV0ZQUDb2ZmZAIHDw8WAh8BZWRkAgUPZBYGAgEPEGRkFgFmZAIDDxBkZBYBZmQCBQ8PZBYCHwQFA29mZmQCBQ8PFgIfAQWlAUNvcHlyaWdodCAmY29weTsyMDA4LTIwMDkuIFNVTENNSVMgT1BBQyA0LjAxIG9mIFNoZW56aGVuIFVuaXZlcnNpdHkgTGlicmFyeS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuPGJyIC8+54mI5p2D5omA5pyJ77ya5rex5Zyz5aSn5a2m5Zu+5Lmm6aaGIEUtbWFpbDpzenVsaWJAc3p1LmVkdS5jbmRkZAg1DiqmaepeeQ7Rw6kLdb3ah3tb" type="hidden"&gt; &lt;input type="hidden" name="__EVENTVALIDATION" id="__EVENTVALIDATION" value="/wEWBQLL+rWqAwKOmK5RApX9wcYGAsP9wL8JAqW86pcI3+ohGVVAcOzsnECPPKNYB0mRpZ0="&gt; &lt;input name="ctl00$ContentPlaceHolder1$txtlogintype" type="hidden" id="ctl00_ContentPlaceHolder1_txtlogintype" value="0"&gt; &lt;input name="ctl00$ContentPlaceHolder1$btnLogin_Lib" value="登录" onclick="javascript:WebForm_DoPostBackWithOptions(new WebForm_PostBackOptions(&amp;quot;ctl00$ContentPlaceHolder1$btnLogin_Lib&amp;quot;, &amp;quot;&amp;quot;, true, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, false, false))" id="ctl00_ContentPlaceHolder1_btnLogin_Lib" class="btn" type="submit"&gt; ②其中： ctl00$ContentPlaceHolder1$txtUsername_Lib是登陆账号 ctl00$ContentPlaceHolder1$txtPas_Lib是密码 2.编写程序 2.1创建myproject的Scrapy工程（参考） 2.2编写\myproject\myproject\spiders\LoginSpider.py
# -*- coding:utf-8 -*- import scrapy import re class LoginSpider(scrapy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89b2847464337daf115625355e83a96a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fff695322a5d4ea9543ccae4d1ae04cd/" rel="bookmark">
			Entity FrameWork 6帮助类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 public class BaseDAL 2 { 3 string strConn = ""; 4 public BaseDAL(string connString) 5 { 6 strConn = connString; 7 } 8 9 #region 通用增删改查 10 #region 非原始sql语句方式 11 /// &lt;summary&gt; 12 /// 新增 13 /// &lt;/summary&gt; 14 /// &lt;param name="entity"&gt;实体&lt;/param&gt; 15 /// &lt;returns&gt;返回受影响行数&lt;/returns&gt; 16 public bool Add&lt;T&gt;(T entity) where T : class 17 { 18 using (SysDb&lt;T&gt; db = new SysDb&lt;T&gt;(strConn)) 19 { 20 db.Entry&lt;T&gt;(entity).State = EntityState.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fff695322a5d4ea9543ccae4d1ae04cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f6b987f841b5699151202d7ec44175d/" rel="bookmark">
			RESTful学习笔记 --- TypeError: __init__() got an unexpected keyword argument &#39;method&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在写restful api的时候一直报出如下的错误，
原因是因为methods参数写成了method，因此正确的写法就是加上's'，写成methods
如：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9065a1c47f4552b2d4a4d3893fe7f6f/" rel="bookmark">
			实现简单的端口连接程序C/C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序原理： 当指定了需要扫描的IP地址和端口信息后，程序便创建一个Socket，然后向指定的IP地址和端口发起建立连接的请求，如果能成功建立连接，则说明该端口处于工作状态，否则说明端口已经被关闭无法建立连接。
程序源码：
/* *简单的端口扫描程序 */ #include&lt;stdio.h&gt; #include&lt;Winsock2.h&gt; #pragma comment(lib , "ws2_32.lib") typedef unsigned int UINT ; /* *进行端口连接的测试 */ bool testConnection(char *IP , UINT nPort) ; /* *测试主函数 */ int main() { //初始化WinSock WORD wVersionRequested = MAKEWORD(2,2); WSADATA wsaData; if(WSAStartup(wVersionRequested,&amp;wsaData) != 0) { printf("初始化WinSock失败！\n") ; return 0 ; } char IP[20] , nPort ; printf("Please input scan Port and IP : " ) ; scanf("%d %s" , &amp;nPort , IP) ; //进行连接的测试 if(testConnection(IP , nPort)) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9065a1c47f4552b2d4a4d3893fe7f6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b93dd80c0572cb4dbbd420b4f71cf1a3/" rel="bookmark">
			高德地图——申请Key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取Key 1、进入控制台，创建一个新应用。如果之前已经创建过应用，可直接跳过这个步骤 2、 在创建的应用上点击”添加新Key”按钮，在弹出的对话框中，依次：输入应用名名称，选择绑定的服务为“Android平台SDK”，输入发布版安全码 SHA1、调试版安全码 SHA1、以及 Package，如下图所示： 在阅读完高德地图API服务条款后，勾选此选项，点击“提交”，完成 Key 的申请，此时您可以在所创建的应用下面看到刚申请的 Key 了。
如何获取 SHA1 调试版本（debug）和发布版本（release）下的 SHA1 值是不同的，发布 apk 时需要根据发布 apk 对应的 keystore 重新配置 Key。
获取调试版本 SHA1 需要根据不同的开发工具，分别参考 通过Eclipse获取SHA1 和 通过Android Studio获取SHA1。 获取发布版本下 SHA1 的方法请参考 使用 keytool（jdk自带工具）获取SHA1。 第一步、打开 Android Studio 的 Terminal 工具。
第二步、输入命令：keytool -v -list -keystore keystone文件路径。
第三步、输入 Keystore 密码 使用 keytool（jdk自带工具）获取 SHA1
1、运行进入控制台。 2、在弹出的控制台窗口中输入 cd .android 定位到 .android 文件夹。 3.继续在控制台输入命令。
调试版本使用 debug.keystore，命令为：keytool -list -v -keystore debug.keystore。 发布版本使用 apk 对应的 keystore，命令为：keytool -list -v -keystore apk 的 kenstore。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b93dd80c0572cb4dbbd420b4f71cf1a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177810ccf0c26fa0d975efe6429e7965/" rel="bookmark">
			实现div的大小随着内容进行动态改变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 div的动态改变有两种方式：
1.使用百分比的形式来实现div的动态改变的实现代码： #id{ width: 30%; height: 40%; } /* 这样一来，该div的宽度和高度将始终分别对应于浏览器的宽度的30%和40% */ 2.指定最小值来让浏览器自动实现div动态改变的实现代码: #id{ min-width: 100px; min-height: 200px; } /* 当其width小于100px时就为100px，大于100px时就根据当100px时内容溢出的大小来动态改变div的大小 */ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aa56f3bf598f9a502c7c9ea878fbb1c/" rel="bookmark">
			Nginx使用ssl模块配置HTTPS支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认情况下ssl模块并未被安装，如果要使用该模块则需要在编译时指定–with-http_ssl_module参数。 1.安装基础支持包 yum -y install openssl openssl-devel 2.备份原nginx.conf文件为nginx.conf.bak以防万一 3.安装ssl模块 cd /home/nginx-1.10.2 ../configure --with-http_ssl_module make make install 4.生成证书 可以通过以下步骤生成一个简单的证书： 首先，进入你想创建证书和私钥的目录，例如： $ cd /usr/local/nginx/conf 创建服务器私钥，命令会让你输入一个口令： $ openssl genrsa -des3 -out server.key 1024 创建签名请求的证书（CSR）： $ openssl req -new -key server.key -out server.csr 在这一命令执行的过程中，系统会要求您填写如下信息： Country Name (2 letter code) 使用国际标准组织(ISO)国码格式，填写2个字母的国家代号。中国请填写CN。 State or Province Name (full name) 省份，比如填写Shanghai Locality Name (eg, city) 城市，比如填写Shanghai Organization Name (eg, company) 组织单位，比如填写公司名称的拼音 Organizational Unit Name (eg, section) 比如填写IT Dept Common Name (eg, your websites domain name): 行使 SSL 加密的网站地址。请注意这里并不是单指您的域名，而是直接使用 SSL 的网站名称 例如:pay.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4aa56f3bf598f9a502c7c9ea878fbb1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c13e0afd1bcf604e03ccada4a34171b3/" rel="bookmark">
			将 ICDAR 2015 的 Ground Truth 标注在图像数据上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为要标注数据，数据集是 ICDAR 2015 比赛中的 Challenge 4: Incidental Scene Text。
原图及标注的图像，还有给定的 ground truth 文件如下所示： 最左边是原图，中间是标注的图像，右边是 ground truth 文件内容，按顺时针顺序的坐标： x1,y1,x2,y2,x3,y3,x4,y4 ，最后是 words，但是如果是 ### 这种表示的，则表示不 care 文字的内容。
用 Python 将 ground truth 框住文字，代码如下：
import os import path import glob import Image, ImageDraw # ground truth directory gt_text_dir = "/home/chenxp/Documents/Hitachi/ICDAR_2015/ICDAR2015_ch4/ch4_training_localization_transcription_gt" # original images directory image_dir = "/home/chenxp/Documents/Hitachi/ICDAR_2015/ICDAR2015_ch4/*.jpg" imgDirs = [] imgLists = glob.glob(image_dir) # where to save the images with ground truth boxes imgs_save_dir = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c13e0afd1bcf604e03ccada4a34171b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13596caa227f9fc5e23b9ccf81d86cd4/" rel="bookmark">
			获取当前时间的前一天或后一天时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Calendar类的add方法：
示例代码如下：
import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; public class DateAdd { public static void main(String[] args) { Date date = new Date(); /** * yyyy 代表年份（注意是小写） yy 显示年份的后两位 * MM 代表月份 * dd 代表天数 （小写） * mm 代表分钟 * HH 代表小时（24小时制） * hh 代表小时（12小时制） * ss 代表秒 */ SimpleDateFormat formatDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String d = formatDate.format(getNextDate(date)); System.out.println(d); } private static Date getNextDate(Date date) { Calendar calendar = Calendar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13596caa227f9fc5e23b9ccf81d86cd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc4615021c62080f5cd5122416ba7446/" rel="bookmark">
			微信小程序仿闲鱼『下拉菜单』
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下拉菜单我们非常常见了，但是要在微信小程序中实现并不容易，今天带来的是仿闲鱼下拉菜单，相信对您有一定的帮助~~
先看效果：
麻雀虽小五脏俱全，此效果很复杂，我们将其拆分为多个步骤来分析~
1）tab状态的切换
先看效果：
wxml代码：
&lt;view class="{{navindex == 1? 'active' : ''}}"&gt; &lt;view class="content"&gt;区域&lt;/view&gt; &lt;/view&gt; &lt;view class="{{navindex == 2? 'active' : ''}}" &gt; &lt;view class="content"&gt;女装&lt;/view&gt; &lt;/view&gt; &lt;view class="{{navindex == 3? 'active' : ''}}" &gt; &lt;view class="content"&gt;排序&lt;/view&gt; &lt;/view&gt; class中有个三目运算符点击的时候切换navindex值即可获得active，表示切换到另一种状态 2）菜单自上而下的动效
先看效果：
wxss代码：
@keyframes slidown{ from{ transform: translateY(-100%); } to{ transform: translateY(0%); } } @keyframes slidup{ from{ transform: translateY(0%); } to{ transform: translateY(-100%); } } 原理其实就是利用css3中的translateY做位移，就能实现自上而下的动效。
3）背景蒙层缓慢消失
先看效果：
wxss代码：
.fullbg{ background: rgb(1, 1, 1); transition: all 2s; opacity: 0; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc4615021c62080f5cd5122416ba7446/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38a2399b0c0f2807a46ec014291e05fc/" rel="bookmark">
			位带操作与OMAP-L138的举例分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在hw_types.h文件下可以找到这样一段宏定义，然后在打开工程的函数是会发现几乎所有的对寄存器的配置都是通过这几 个定义实现的，这就是位带操作，这种方法可以提高代码执行效率。 HWREG（x） 定义一个32位无符号指针x，然后在取出它的值，最终得到的是x地址的值，下面的都类似 HWREGH(x) 定义的是16位无符号指针的值 HWREGB(x) 定义的是8位无符号指针的值 HWREGBITW(x,b) 表示获取x的地址下第b为的值 下面我将通过对GPIO的配置说明一下如何使用位带操作对寄存器进行配置。 程序的初始化流程如图： 先进行外设使能，然后GPIO管脚复用配置，然后管脚初始化，我们先来看看GPIOBankPinMuxDet()函数，打开函数看到如 图的调用函数，随便选择一个，比如第一个继续打开 然后就会看到函数的源码如图： 首先定义了一个 u32 savePinmux 变量，然后用HWREG(x)获取目标地址下的值， savePinmux = (HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(13)) &amp;~(SYSCFG_PINMUX13_PINMUX13_15_12)); 打开 SOC_SYSCFG_0_RGES 可以看到宏定义在soc_OMAPL138.h下， 表示DEV外设的基地址，从数据手册中可以查到DEV外设主要功能有 1，可读设备，芯片和芯片ID 2，引脚复用控制 3，总线访问系统中不同总线主机的优先级 4，上电时捕获复位芯片BOOT引脚值，并使其可用于软件 5，控制DeepSleep电源管理功能 6，使能和选择可编程引脚上拉和下拉 7，外设的特殊情况设置 锁定PLL控制器设置 EDMA3传输控制器的默认发送大小 选择eCAP模块输入捕捉的源 8，控制用于ARM和DSP之间的信号的片上处理器间中断 9，选择外设支持的仿真挂起信号源（来自ARM或DSP） 我们配置GPIO就是用到了第二条引脚复用控制 现在我们已经知道了目标设备的基地址，现在还需要知道它控制外设的地址偏移，也就是第二个参数SYSCFG0_PINMUX(13) 它代表在基地址基础上的地址偏移，我们可以在hw_syscfg0_OMAPL138.h中找到所有的外设相对于基地址的偏移宏定义。 SYSCFG0_PINMUX(13) 在图中可知偏移地址是（ 0x120 + 13 * 4 ）
已经找到了目标外设的地址，然后就是对每一位进行设置，已完成预期功能 savePinmux = 基地址的值&amp;~（SYSCFG_PINMUX13_PINMUX13_15_12）， 找到SYSCFG_PINMUX13_PINMUX13_15_12的宏定义 #define SYSCFG_PINMUX13_PINMUX13_15_12 (0x0000F000u) 现在我们就明白它的意思是对 SYSCFG_PINMUX13_PINMUX13_15_12 取反再与外设地址取与， 目的是对 savePinmux [15:12]位清0。 最终我们搞明白了 savePinmux = (HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(13)) &amp;~(SYSCFG_PINMUX13_PINMUX13_15_12));的功能，就是对把 (HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(13) 的[15:12]清0 那么继续看下一句 HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(13)) =(PINMUX13_GPIO6_12_ENABLE | savePinmux); 先看 PINMUX13_GPIO6_12_ENABLE 的宏定义 #define PINMUX13_GPIO6_12_ENABLE (SYSCFG_PINMUX13_PINMUX13_15_12_GPIO6_12 &lt;&lt; \SYSCFG_PINMUX13_PINMUX13_15_12_SHIFT) 可以知道改宏的值是 SYSCFG_PINMUX13_PINMUX13_15_12_GPIO6_12 &lt;&lt; SYSCFG_PINMUX13_PINMUX13_15_12_SHIFT如图 从前面知道在 SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(13) 这个寄存器下管理者PINMUX13 这一组的GPIO引脚控制 ，当我们仅需要配置其中一个是，就需要用到改Pin相对有首地址的偏移 SYSCFG_PINMUX13_PINMUX13_15_12_SHIFT (注意这个偏移是该寄存器内部bit位的偏移) 同时需要选择该pin对应的控制寄存器为的值来确定配置的功能， 在这里我们选择了 SYSCFG_PINMUX13_PINMUX13_15_12_GPIO6_12 功能 最后和清空的 savePinmux 取或 ，即完成了GPIO的模式配置 最后希望能对大家有所帮助，受本人知识所限，难免有理解不当的地方，欢迎批评指正。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85637c37d60ea95e1dd937af8871e17c/" rel="bookmark">
			普及组 火星上的加法运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		普及组 火星上的加法运算
Time Limit:10000MS Memory Limit:65536K
Total Submit:26 Accepted:21 Case Time Limit:1000MS
Description
最近欢欢看到一本有关火星的书籍，其中她被一个加法运算所困惑，由于她的运算水平有限，她想向你求助，作为一位优秀的程序员，你当然不会拒绝。
Input
第一行先输入一个运算的进制N(2&lt;=N&lt;=36),接下来的两行为需要进行运算的字符，其中每个字符串的长度不超过200位.其为N进制的数。其中包括0-9及a-z(代表10-35). Output
在N进制下它们的和.
Sample Input
输入样例1： 20 1234567890 abcdefghij 输入样例2： 20 99999jjjjj 9999900001 Sample Output
输出样例1： bdfi02467j 输出样例2： iiiij00000 字母转换成数字然后高精度加法 const maxn=200; var a,b,c:array[0..maxn] of longint; n:longint; procedure init; var i,len1,len2:longint; s1,s2:string; begin readln(n); readln(s1); readln(s2); len1:=length(s1); len2:=length(s2); for i:=len1 downto 1 do if s1[i] in ['0'..'9'] then a[maxn-len1+i]:=ord(s1[i])-48 else a[maxn-len1+i]:=ord(s1[i])-87; for i:=len2 downto 1 do if s2[i] in ['0'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85637c37d60ea95e1dd937af8871e17c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/016023e6c433e9ee46b7f88c546beeb0/" rel="bookmark">
			home目录空间不足，cache占用空间太大
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备安装一个软件的（wine下安装PS+win7配置环境），碰到了home磁盘空间不足的情况，甚至连新建文本都保存不了
使用磁盘查看器查看
baobab 发现/home/user/.cache占了10G+的内存，用apt-get的三个清除命令，都没有效果。 我知道cache是缓存的意思，但还是不敢删。
后来重启发现这个文件夹又变成了500M，这下子我就知道了，缓存文件每次开机会重新生成，所以这个文件夹删了了也不会有什么
不过，cache下upstart就占了90%以上，删掉它就可以了。
要是你不怕麻烦就重启喽
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/530d235a02ccdc62089dc5fa342dd7ef/" rel="bookmark">
			STM32芯片上的5行丝印分别代表的含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、ARM代表ARM内核， ARM后面跟着的是 X，代表芯片版本 内核是不变的 只是ST的版本 X是最终版本， 就是以后这个型号就不会再升级了， 有数字的代理以后还可以升级 2/3、第二行和第三行是型号 4、原厂出厂编号 5、MYS是马来西亚封装产地， 641是代表2016年41周生产的 CHN是国内封装产地 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85a2ce719d4f45207c9cdaf11e69a079/" rel="bookmark">
			ImportError: No module named cv2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装opevncv时会出现 ImportError: No module named cv2 的错误，找不到cv2的包这时候安装apt-get installPython-OpenCV扩展包即可【或yum install opencv-python】
不过这是依赖版本，具体python3安装opencv可以参考 Adrian Rosebrock写的这篇博文
但是在树莓派编译opencv时有时会遇到找不到python3+的library，这时需要注意是否配置了LD_LIBRARY_PATH。
nano ~/.profile 1 1 在环境变量末尾加入
export LD_LIBRARY_PATH=/usr/lib/:$LD_LIBRARY_PATH 1 1 source ~/.profile 1 1 配置以后再预编译opencv时就可以看到，python的位置就都已经可以找到，在进行编译时，cv2.so就会依赖到packages path下 若还无法依赖 path的话 clean后重新make即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c9e50cb8221450e83eed0671f918e30/" rel="bookmark">
			七牛云融合CDN到底怎么配置？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 人生如戏，你得先有故事。
--老李
由于来年头一个月公司产品接入了一个旅游项目，为了保证系统的稳定性，必须要对现有架构进行改进以应对大流量的冲击。
那么问题来了？怎么改？
首先，我得清楚项目目前的瓶颈在什么地方，项目的日常应用场景是怎样的？
我先来分析一下我们项目的情况：我们这个项目主要是应用AR技术进行娱乐，原理就是利用高通家的Vuforia SDK实现边缘识别来叠加模型，哪些图像要被识别是需要提前传到高通的服务器上的，服务器会生成几个Vuforia专用的识别文件（dataset），再将识别文件整合到项目中，识别到了需要调用什么模型自己配置就可以了。
我主管后台，围绕着Vuforia的结构开发了一套程序进行后台文件的管理，简单的说就是有哪些识别图，识别到了会出现什么效果等等。
上面是后台的应用场景，再来看看用户端的使用场景，用户端只有移动端，Android和IOS，原理是这样：启动我们的app会先加载一段配置文件（json），主要就是让手机知道，哪些图片可以被识别（这里多说一句，因为识别图片会越来越多，所以启动速度也越来越慢，我特意研究了一下国内easyAR的SDK，他们可以即时更换识别图片，而且不用传到服务器等待生成识别文件这么复杂，但是搞AR的那哥们在高通的Vuforia花了太多时间，多少还是有点经验的，万一换个SDK，没啥优势了，嗯……很恐怖，所以老技术人一般不会轻易尝试新的技术，因为自己占领的优势会立马失去，哎……），长时间的加载等待后进入了主界面。我们根据识别图开发了很多周边产品，比如说识别图印在T恤上，做成钥匙扣，等等等等，总之就是各种识别图附着在各种实物上，听到这里我们的商业模式也应运而生，没错，卖实物赚钱，app免费下！
用手机扫描识别图app就会认识并给出下载提示，什么？又要下载？解释一下，这次下的是模型，也就是识别到了之后展示的效果，一个3D模型，unity开发的，这里也是一个影响用户体验的地方，用户好不容易下载了我们的app，之后好不容易进入了主界面，完了还得下载，你是用户你糟不糟心，糟！现在还是改版后的，有分类的，第一版是所有的模型都在一个包下，也就是说，进入主界面后要一次性下载所有的模型，那酸爽，简直了~
改版后的对模型进行了分类，这样下载时间能短一点，但是换到另外一个分类又得重新下载（用户已经气晕在地上了……），下载后模型会缓存在手机本地，现在即使用户断网了也依然可以愉快的玩耍了。
写了一大段介绍app的应用场景，瓶颈已经很明显了，首先就是app启动的时候从服务拉取的那一段配置文件，其次就是下载的模型文件。怎么解决就很简单了，配置文件上缓存，因为读取的都是相同的内容，典型的读多写少的场景，模型文件是大文件，静态的，全部上CDN，这样，瓶颈就解决了，至少目前是解决了，应对来年的那个流量没有任何问题了。
好了，进入正题，缓存就不细讲了，不是本文的主角，来聊聊CDN吧。
CDN（Content Delivery Network）内容分发网络，就是厂家在地球的一些地方部署了服务器，作为仓库存放用户的文件，用户访问CDN服务器的时候会经过一个路由算法找到离访问者最近的一台服务器，这样就能实现快速访问，而且可以极大地减少自己服务器的压力，你想想啊，如果你的服务器在昆明，东北的用户访问你的服务器是不是要慢多了？因为距离远了嘛。CDN通过流量来收费，很合理，用的多，花的多，用的少，花的也少。
最后来看看CDN配置的具体步骤吧：
1、先创建一个空间，以后你的乱七八糟的文件都会存放在这个空间里，如下图： 2、在融合CDN中创建加速域名列表，如下图： 加速域名随便写一个二级域名：a.b.com.cn c.d.com 等等，写在这里，然后最后的源站配置选择第一个“七牛云存储”，并选择你刚才创建的那个空间。
3、完成后你会看到这样的信息： 4、找到你们的域名管理页面，域名管理有很多网站，阿里云，万网等等，按照下图配置，肯定不一样，请照葫芦画瓢： 主机记录写加速域名里你填写的那个二级域名的前段，请看上图B中介绍，主要就是把七牛给你的CNAME填写到正确的地方，也就是D处，添加完成后会在地址后面加个 “.” 这是正常的，别手贱把它删了。
5、等待个十几二十分钟，状态就会变成“成功”（也就是第三部中的图片），下面是七牛存储空间的测试域名，如下图： 6、找到存储管理中的“镜像存储”，镜像源填写你们网站的网址，有端口的把端口也加上，下面的镜像空间是你创建的那个存储空间的名字。 7、访问第五步中的那个测试域名或者你最开始写的加速域名，幸运的话会跳转到你配置的镜像源也就是你公司的网址页面去，多访问一些页面，你会在七牛存储空间的内容管理中看到多了一些文件，其实这就是你们公司网址上的资源文件，七牛第一次访问的时候根据镜像源去你们公司抓取并存放在七牛云你创建的存储空间里，之后再次访问就直接在七牛里面拿了，大大的降低了你们公司服务器的压力。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2df1a33d8c7dcc9c99763b4a67229d26/" rel="bookmark">
			landsat、spot、ikonos等各种卫星信息介绍及几种遥感影像下载方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、说明
二、遥感影像下载
三、不同系列的卫星介绍
1. SPOT影像
2.QuickBird
3. IKONOS
4. ALOS
5. Landsat卫星
一、说明 因为学习需要，需要在网上下载某些区域的遥感影像，然后就在网上查询了各种免费遥感影像的方法，但是总是不能下载到满意的遥感影像，而且查询某些信息时并不能直接查询到有用的信息，浪费了很多时间。故整理一下信息和经验，放到这里，虽然不能保证各位能够下载到满意的影像数据，但如果能提高大家的效率，节约大家的时间，那么我这篇文章的目的也就达到了。
各位下载影像的时候一定要先确定好自己对时间和空间分辨率的要求，然后再去找相对应的资源去下载。
二、遥感影像下载 UCGS：这个网站的遥感影像下载特别方便，只要注册一个账号即可下载，浏览该网站时需要有java的jre环境才能看到地图界面。不过这个网站的数据分辨率较低，landset系列卫星的为240米/1000米，modis的为5000/10000米，其他系列卫星的分辨率最高也在100多米。如果对分辨率要求不高的话可以下载，数据比较全，时间分辨率较高。马里兰大学 无需注册，进入可直接下载。下载方法可参考如下链接：http://wenku.baidu.com/view/8701854c767f5acfa1c7cd1f.html中科院遥感所，中国资源卫星中心也可以下载。 三、不同系列的卫星介绍 1. SPOT影像 SPOT影像是由SPOT卫星高分辨率多波段扫描仪（HRV）获取的遥感影像，包括全色和多波段两种。 光谱响应范围： 全色波段为0.51～0.73微米；
多波段分别为0.50～0.59微米（绿）、0.61～0.68微米（红）和0.79～0.89微米（近红外）。
空间分辨率，前者为10米，后者为20米。SPOT影像的分辨率有2.5米的全色波段和5米及10米的多波段。 2.QuickBird QuickBird卫星于2001年10月由美国DigitalGlobe公司发射，是提供亚米级分辨率的最早商业卫星，QuickBird卫星系统每年能采集七千五百万平方公里的卫星影像数据，存档数据每天以史无前例的速度在递增。在中国境内每天至少有2至3个过境轨道，有存档数据约500万平方公里。
QuickBird卫星参数参数值星下点分辨率0.61m产品分辨率全色 0.61 -0.72m多光谱2.44 -2.88m产品类型全色、多光谱、全色增强、捆绑(全色 + 多光谱)等 QuickBird(0.6米)各波段参数 0.63～0.69微米：用于测量植物叶绿素吸收率、进行植被分类；0.65～0.70微米：对叶绿素监测有较好的作用；大多数浮游植物都清楚地展现出叶绿素的第二吸收光谱带,对水特性进行遥感时,必须考虑到水的吸收特性和反射特性 。 红光波段(630-690nm),在城市人工地物和植被混杂的区域，可以将建筑物与植被很好的区分开来。
3. IKONOS IKONOS卫星于1999年9月24日发射成功，IKONOS是可采集1米分辨率全色和4米分辨率多光谱影像的商业卫星，同时全色和多光谱影像可融合成1米分辨率的彩色影像。时至今日IKONOS 已采集超过2.5亿平方公里涉及每个大洲的影像，许多影像被中央和地方政府广泛用于国家防御，军队制图，海空运输等领域。从681千米高度的轨道上，IKONOs的重访周期为3天，并且可从卫星直接向全球12地面站地传输数据。
IKONOS卫星参数星下点分辨率0.82米产品分辨率全色1 米多光谱4 米成像波段全色0.45-0.90 微米彩色波段 1( 蓝色 )0.45-053 微米波段 2( 绿色 )0.52-0.61 微米波段 3( 红色 )0.64-0.72 微米波段 4( 近红外 )0.77-0.88 微米 4. ALOS 日本卫星，2006年升空。
卫星传感器：
（1）PRISM传感器 PRISM具有独立的三个观测相机，分别用于星下点、前视和后视观测，沿轨道方向获取立体影像，星下点空间分辨率为2.5m。其数据主要用于建立高精度数字高程模型。 注：PRISM观测区域在北纬82°至南纬82°之间。 全色波段范围520-770nm分辨率2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2df1a33d8c7dcc9c99763b4a67229d26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5898d51a9af55e483a0bc6d9e0c9144/" rel="bookmark">
			Tkinter选择路径功能的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tkinter选择路径功能的实现 效果基于Python3。
在自己写小工具的时候因为这个功能纠结了一会儿，这里写个小例子，供有需要的参考。
小例子，就是点击按钮打开路径选择窗口，选择后把值传给Entry输出。
效果预览 这是选择前：
选择：
选择后：
代码 很基础的写法。
from tkinter import * from tkinter.filedialog import askdirectory def selectPath(): path_ = askdirectory() path.set(path_) root = Tk() path = StringVar() Label(root,text = "目标路径:").grid(row = 0, column = 0) Entry(root, textvariable = path).grid(row = 0, column = 1) Button(root, text = "路径选择", command = selectPath).grid(row = 0, column = 2) root.mainloop() 注意事项 1.注意import模块时的写法。 2.askdirectory()方法是返回文件夹路径不是文件路径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e1e759fbaf482632592a6346f1a9b07/" rel="bookmark">
			springMVC项目访问静态资源时遇到的两个坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.存放静态资源文件夹放在了WEB_INF目录下，导致资源文件无法访问，最好放在项目根路径(WebRoot目录)下
2.引用资源文件路径采用了相对路径，由于资源文件路径随着controller访问路径变化而变化，导致资源文件引用不了，最好采用绝对路径引用资源文件，绝对路径示例：&lt;%=basePath%&gt;static/js/jquery.min.js, 查看 jsp页面中是否设置basePath,设置如下：
&lt;%
String path = request.getContextPath();
String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
%&gt; static是我总的资源文件夹，下面有js、image、css等文件夹，里面分别存有对应资源文件。
我访问静态资源的方法是在springmvc-servlet.xml配置文件中加&lt;mvc:resources mapping="/static/**" location="/static/" /&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd486a57994fd1942a02462d6ce2ae8f/" rel="bookmark">
			python socket编程（传输字符、文件、图片）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		socket官方文档：https://docs.python.org/2/library/socket.html
socket中文详细介绍：http://blog.csdn.net/rebelqsp/article/details/22109925
查看某端口是否被占用(如6666端口)：sudo netstat -nap | grep 6666 如果没有查找到6666端口则说明没有被占用（额，有点废话了~~）
环境说明 python2.7ubuntu 客户端 创建 socket连接到远程服务器发送数据接收数据关闭 socket #!/usr/bin/env python # -*- coding=utf-8 -*- """ file: client.py socket client """ import socket import sys def socket_client(): try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect(('127.0.0.1', 6666)) except socket.error as msg: print msg sys.exit(1) print s.recv(1024) while 1: data = raw_input('please input work: ') s.send(data) print s.recv(1024) if data == 'exit': break s.close() if __name__ == '__main__': socket_client() 服务器端 打开 socket绑定到特定的地址以及端口上监听连接建立连接接收/发送数据 #!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd486a57994fd1942a02462d6ce2ae8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff44e57ec82d6095c524b3bf3954e4fe/" rel="bookmark">
			关于 eclipse 中R类文件报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当导入项目到eclipse时，总会出现错误，比如说gen目录下R类丢失，或缺少语句，我总结了一下解决方法。 当R类丢失时：
第1种方法:右击工程-&gt;选择Android Tools-&gt;选择Fix Project Properties 第2种方法:右击工程-&gt;选择Properties-&gt;选择 Android-&gt;Apply
当R类报错时：
先看是不是一些资源文件引起的错误，如果是则直接到R.java文件中定位错误发生的位置。首先是定位哪部分资源文件出错。
这边举个例子：drawable中图片资源文件不是不能以数字开头，如果当你数字开头是，资源文件本身没有问题，然而R类就会报错了。
其次我也遇到过这样的问题，就是我配置android 6.0 sdk时（也就是说eclipse sdk从低版本切换到高版本sdk的时候 ）R类出现了错误，少了一个括号。 问题解决方法：
点击找到values文件夹 打开attrs.xml ctrl+f 查找 MenuView 将preserveIconSpacing注释掉或者删掉 clean项目
ok 完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa7f753b5af35a9e74c1dd7a98ead479/" rel="bookmark">
			java栈的输出字段的意义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java signal SIGQUIT的输出是线程：Signal Catcher完成
"SIG_0",	/* 0 */ "SIGHUP",	/* 1 */ "SIGINT",	/* 2 */ "SIGQUIT",	/* 3 */ "SIGILL",	/* 4 */ "SIGTRAP",	/* 5 */ "SIGABRT",	/* 6 */ "SIGBUS",	/* 7 */ "SIGFPE",	/* 8 */ "SIGKILL",	/* 9 */ "SIGUSR1",	/* 10 */ "SIGSEGV",	/* 11 */ "SIGUSR2",	/* 12 */ "SIGPIPE",	/* 13 */ "SIGALRM",	/* 14 */ "SIGTERM",	/* 15 */ "SIGSTKFLT",	/* 16 */ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa7f753b5af35a9e74c1dd7a98ead479/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f7f0f90defb432ffdb0fd1839c8dfee/" rel="bookmark">
			EventBus的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。比如请求网络，等网络返回时通过Handler或Broadcast通知UI，两个Fragment之间需要通过Listener通信。
EventBus3.0已经比2.0在使用和性能上有很大提高，具体使用方式可以参考源码或网上的Demo，今天主要说说，在实际使用中EventBus的一个缺点。
github地址：https://github.com/greenrobot/EventBus
EventBus在发布/订阅消息时，都需要定义一个事件类。
下面通过简单的Demo来说明更直观一些。
实际项目中，经常会用到，只发送单纯的消息通知的事件，即只发布字符串消息。
EventBus.getDefault().post("EventTypeNetStart"); EventBus.getDefault().post("EventTypeNetSuccess"); 这种消息，订阅者需要根据类型，做分发处理，无法直接通过消息定位到不同的注册方法上。
@Subscribe(threadMode = ThreadMode.MAIN) public void onEventNetStart(String eventType) { Log.d("EventBus", "onEventNetStart " + eventType); } @Subscribe(threadMode = ThreadMode.MAIN) public void onEventNetSuccess(String eventType) { Log.d("EventBus", "onEventNetSuccess " + eventType); } 这种注册会同时受到"EventTypeNetStart"和"EventTypeNetSuccess"，只能注册一个事件
@Subscribe(threadMode = ThreadMode.MAIN) public void onEventNet(String eventType) { if ("onEventNetStart".equals(eventType)){ } else if ("onEventNetSuccess".equals(eventType)){ } } 或者定义不同的类
@Subscribe(threadMode = ThreadMode.MAIN) public void onEventNet(NetStart netStart) { } @Subscribe(threadMode = ThreadMode.MAIN) public void onEventNet(NetSuccess netSuccess) { } EventBus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f7f0f90defb432ffdb0fd1839c8dfee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f95b50a831d6613b74171f12673355b8/" rel="bookmark">
			systemd实现python的守护进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。（摘自百度百科）
之前有转过一遍python实现守护进程方法的博客，这次我们看看用systemd是如何实现的。
有关systemd的介绍和使用推荐阮一峰老师的以下两篇博客，写的非常详细和全面
命令篇实践篇 下面我们看看用systemd如何实现守护进程（我的环境Centos 7）
#!/usr/bin/env python # -*- coding=utf-8 -*- """ 每隔5秒输出本地时间到指定的文件 path: /home/test.py """ import time filepath = '/home/time' # 文件路径 fm = '%Y-%m-%d %X' def get_time(): while 1: nowtime = time.strftime(fm, time.localtime()) with open(filepath, 'a') as fp: fp.write(nowtime) fp.write('\n') time.sleep(5) if __name__ == '__main__': get_time() 接着我们在/home目录下创建一个systemd的文件test.service
[Unit] Description=test deamon After=rc-local.service [Service] Type=simple User=root Group=root WorkingDirectory=/home ExecStart=/usr/bin/python test.py Restart=always [Install] WantedBy=multi-user.target 把此文件复制到systemd目录下: cp /home/test.service /etc/systemd/system/
启动: systemctl start test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f95b50a831d6613b74171f12673355b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4cfafadd3d8dbc87f060d545dbda537/" rel="bookmark">
			关于service 与 activty 之间通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资料来源：http://blog.csdn.net/xiaanming/article/details/9750689 http://blog.csdn.net/wurensen/article/details/47024961
在Android中，Activity主要负责前台页面的展示，Service主要负责需要长期运行的任务，所以在我们实际开发中，就会常常遇到Activity与Service之间的通信，我们一般在Activity中启动后台Service，通过Intent来启动，Intent中我们可以传递数据给Service，而当我们Service执行某些操作之后想要更新UI线程，我们应该怎么做呢？
当Activity通过调用bindService(Intent service, ServiceConnection conn,int flags),我们可以得到一个Service的一个对象实例，然后我们就可以访问Service中的方法。
public class MsgService extends Service { /** * 进度条的最大值 */ public static final int MAX_PROGRESS = 100; /** * 进度条的进度值 */ private int progress = 0; /** * 增加get()方法，供Activity调用 * @return 下载进度 */ public int getProgress() { return progress; } /** * 模拟下载任务，每秒钟更新一次 */ public void startDownLoad(){ new Thread(new Runnable() { @Override public void run() { while(progress &lt; MAX_PROGRESS){ progress += 5; try { Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4cfafadd3d8dbc87f060d545dbda537/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8b5dcdbae69f3e68eafa8b6508def8e/" rel="bookmark">
			LoadRunner 11压测时碰到错误Error: missing newline in *:\*****\*.dat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：
Error: missing newline in C:\hpwork\eidopenserviceinfosync_100user_10min\cardNo_100user_10min.dat
1、脚本录制后进行加压测试 2、 报错信息 ： Error: missing newline in C:\hpwork\eidopenserviceinfosync_100user_10min\cardNo_100user_10min.dat
解决方案:
参数文件中不能有空行， 但是参数文件最后一定要有一个空行 。 检查发现cardNo_100user_10min.dat最后没有空行，添加空行后，在运行就能成功 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d8a27fa725b58ac6aa65a7b00a465fa/" rel="bookmark">
			JVM实用参数_GC日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://blog.codecentric.de/en/2014/01/useful-jvm-flags-part-8-gc-logging/
The last part of this series is about garbage collection logging and associated flags. The GC log is a highly important tool for revealing potential improvements to the heap and GC configuration or the object allocation pattern of the application. For each GC happening, the GC log provides exact data about its results and duration.
-XX:+PrintGC
The flag -XX:+PrintGC (or the alias -verbose:gc) activates the “simple” GC logging mode, which prints a line for every young generation GC and every full GC.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d8a27fa725b58ac6aa65a7b00a465fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b3d927b7580d241af40a093261effe0/" rel="bookmark">
			tar 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tar 命令
[root@linux ~]# tar [-cxtzjvfpPN] 文件与目录 ....
Usage: tar [OPTION...] [FILE]...
Examples:
tar -cf archive.tar foo bar # Create archive.tar from files foo and bar.
tar -tvf archive.tar # List all files in archive.tar verbosely.
tar -xf archive.tar # Extract all files from archive.tar.
更多帮助可以：man tar 或者 tar --help 查看帮助文档。
必选其中之一参数（而且 一次只能使用其中一个，不能同时使用多个）：
（这五个参数是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用，但一次只能用其中一个）
-c：建立一个压缩文件的参数指令(create 的意思)； -x：解开一个压缩文件的参数指令！ -t：查看 tarfile 里面的文件！ -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 特别注意，在参数的下达中， c/x/t/r/u 仅能存在一个！不可同时存在！因为不可能同时压缩与解压缩。
可选参数
下面的参数是根据需要在压缩或解压档案时可选的。
-z：有gzip属性,即需要用 gzip 压缩 -j：有bz2属性,即需要用 bzip2 压缩 -Z：有compress属性的 -v ：压缩的过程中显示文件(显示所有过程)！这个常用，但不建议用在背景执行过程！ -O：将文件解开到标准输出 -f ：使用档名，请留意，在 f 之后要立即接档名！不要再加参数！ 例如：使用『 tar -zcvfP tfile sfile』就是错误的写法，要写成『 tar -zcvPf tfile sfile』才对喔！ -p ：使用原文件的原来属性（属性不会依据使用者而变） -P ：可以使用绝对路径来压缩！ -N ：比后面接的日期(yyyy/mm/dd)还要新的才会被打包进新建的文件中！ --exclude FILE：在压缩的过程中，不要将 FILE 打包！ -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 # tar -cf all.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b3d927b7580d241af40a093261effe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/580bf5e59a527b8f0547300e3dc91cbb/" rel="bookmark">
			JavaScript Study 2（类型、值和变量）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript数据类型分为：原始类型（数字、字符串、布尔值和特殊值【null、undefined】）和对象类型（Object，键值对组成）。JavaScript中，同时使用了字符串和数字，数字将会转成字符串处理。不在任何函数内声明的变量称为全局变量。
1、数字
JavaScript不区分整数值和浮点值，所有数字均用64位浮点格式表示。在任何数字直接量前加“-”号，可以得到其负数，但“-”号不是数字直接量的组成部分，只是一元求反运算。
浮点数表示：[d][.d][(E|e)[(+|-)]d] 例：6.02e23 //表示6.02*10.23。
判断x是否为NaN，不能使用 x==NaN，而应使用x!=x，因为NaN不与任何值相等，包括本身。
日期：var date = new Date()，日期相减得到两者间的毫秒数。
2、字符串
字符串长度是其所含16位值的个数；字符串的第一个位置用0表示；字符串可有单引号或双引号括起来
用到的转义字符：\n 换行符（\u000A）；\v 垂直制表符（\u000B）；\f 换页符（\u000C）；\r 回车符（\u000D）；\" 双引号（\u0022）；\' 单引号（\u0027）；\\ 反斜杠（\u005c）等等
字符串操作：JavaScript的字符串是不变的，replace()等方法都是返回新的字符串。
模式匹配：
3、布尔值
其中undefined、null、0、-0、NaN、""都会转成false；其他值都会转成true；toString()；&amp;&amp;、||、！
4、null、undefined
typeof(null) =&gt; Object，null为一个特殊的对象，表示“非对象”；typeof(undefined) ==&gt; undefined，undefined为一种类型；相等运算 null == undefined，返回true，但严格相等null === undefined，返回false。或许可以说undefined表示系统级的空值，而null表示程序级的空值，在给变量赋空值时，最好使用null。
5、全局对象
NaN、isNaN()、parseInt()、Date()、Math···
6、包装对象
string——String()；数值——Number()；布尔值——Boolean()。它们的==返回true，===返回false。使用typeof可以查看。
7、原始值不可变，对象引用可变
对象的比较是引用的比较，当引用同一个基对象它们才相等。如果需要比较对象的值，则需对它们的每个属性或元素进行比较。
8、类型转换
parseInt、parseFloat、toString()等等
9、变量声明
var i; var i,j;···
重复声明是合法的，就像一个赋值语句一样；但遗漏声明在不严格的JavaScript中会声明一个全局变量，不推荐这样，应尽量使用var声明变量。
10、变量作用域
JavaScript没有块级作用域，所有函数体内的变量声明在函数体内都是可以使用的，建议函数体内的变量声明放在函数顶部，反映变量的真实作用域。
全局变量是全局对象的属性——ECMAScript规范中强制规定的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337a236e065b390e973ad10120816684/" rel="bookmark">
			软件工程的几个步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件工程一直以来都缺乏一个统一的定义，很多学者、组织机构都分别给出了自己的定义：
Boehm：运用现代科学技术知识来设计并构造计算机程序及为开发、运行和维护这些程序所必需的相关文件资料。 IEEE：软件工程是开发、运行、维护和修复软件的系统方法。 Fritz Bauer：建立并使用完善的工程化原则，以较经济的手段获得能在实际机器上有效运行的可靠软件的一系列方法。
软件工程学的内容
软件工程学的主要内容是软件开发技术和软件工程管理．
软件开发技术包含软件工程方法学、 软件工具 和 软件开发环境 ；软件工程管理学包含软件工程经济学和软件管理学。
软件工程基本原理
著名软件工程专家B.Boehm综合有关专家和学者的意见并总结了多年来开发软件的经验，于1983年在一篇论文中提出了软件工程的七条基本原理。
（1）用分阶段的生存周期计划进行严格的管理。
（2）坚持进行阶段评审。
（3）实行严格的产品控制。
（4）采用现代程序设计技术。
（5）软件工程结果应能清楚地审查。
（6）开发小组的人员应该少而精。
（7）承认不断改进软件工程实践的必要性。
B.Boehm指出，遵循前六条基本原理，能够实现软件的工程化生产；按照第七条原理，不仅要积极主动地采纳新的软件技术，而且要注意不断总结经验。
软件工程(SoftWare Engineering)的框架可概括为：目标、过程和原则。
(1)软件工程目标：生产具有正确性、可用性以及开销合宜的产品。正确性指软件产品达到预期功能的程度。可用性指软件基本结构、实现及文档为用户可用的 程度。开销合宜是指软件开发、运行的整个开销满足用户要求的程度。这些目标的实现不论在理论上还是在实践中均存在很多待解决的问题，它们形成了对过程、过 程模型及工程方法选取的约束。
(2)软件工程过程：生产一个最终能满足需求且达到工程目标的软件产品所需要的步骤。软件工程过程主要包括开发 过程、运作过程、维护过程。它们覆盖了需求、设计、实现、确认以及维护等活动。需求活动包括问题分析和需求分析。问题分析获取需求定义，又称软件需求规 约。需求分析生成功能规约。设计活动一般包括概要设计和详细设计。概要设计建立整个软件系统结构，包括子系统、模块以及相关层次的说明、每一模块的接口定 义。详细设计产生程序员可用的模块说明，包括每一模块中数据结构说明及加工描述。实现活动把设计结果转换为可执行的程序代码。确认活动贯穿于整个开发过 程，实现完成后的确认，保证最终产品满足用户的要求。维护活动包括使用过程中的扩充、修改与完善。伴随以上过程，还有管理过程、支持过程、培训过程等。
(3)软件工程的原则是指围绕工程设计、工程支持以及工程管理在软件开发过程中必须遵循的原则。
软件工程必须遵循什么原则
围绕工程设计、工程支持以及工程管理已提出了以下四条基本原则：
(1)选取适宜的开发模型
该原则与系统设计有关。在系统设计中，软件需求、硬件需求以及其它因素间是相互制约和影响的，经常需要权衡。因此，必需认识需求定义的易变性，采用适当的开发模型，保证软件产品满足用户的要求。
(2)采用合适的设计方法
在软件设计中，通常需要考虑软件的模块化、抽象与信息隐蔽、局部化、一致性以及适应性等特征。合适的设计方法有助于这些特征的实现，以达到软件工程的目标。
(3)提供高质量的工程支撑
工欲善其事，必先利其器。在软件工程中，软件工具与环境对软件过程的支持颇为重要。软件工程项目的质量与开销直接取决于对软件工程所提供的支撑质量和效用。
(4)重视软件工程的管理
软件工程的管理直接影响可用资源的有效利用，生产满足目标的软件产品以及提高软件组织的生产能力等问题。因此，仅当软件过程予以有效管理时，才能实现有效的软件工程。
软件工程是指导计算机软件开发和维护的工程学科。
采用工程的概念、原理、 技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够 得到的最好的技术方法结合起来，这就是软件工程。
软件工程强调使用生存周期方法学和各种结构分析及结构设计技术。它们是在七十年代为了对付应用软件日益增长的复杂程度、漫长的开发周期以及用户对软件产 品经常不满意的状况而发展起来的。人类解决复杂问题时普遍采用的一个策略就是“各个击破”，也就是对问题进行分解然后再分别解决各个子问题的策略。软件工 程采用的生存周期方法学就是从时间角度对软件开发和维护的复杂问题进行分解，把软件生存的漫长周期依次划分为若干个阶段，每个阶段有相对独立的任务，然后 逐步完成每个阶段的任务。采用软件工程方法论开发软件的时候，从对任务的抽象逻辑分析开始，一个阶段一个阶段地进行开发。前一个阶段任务的完成是开始进行 后一个阶段工作的前提和基础，而后一阶段任务的完成通常是使前一阶段提出的解法更进一步具体化，加进了更多的物理细节。每一个阶段的开始和结束都有严格标 准，对于任何两个相邻的阶段而言，前一阶段的结束标准就是后一阶段的开始标准。在每一个阶段结束之前都必须进行正式严格的技术审查和管理复审，从技术和管 理两方面对这个阶段的开发成果进行检查，通过之后这个阶段才算结束；如果检查通不过，则必须进行必要的返工，并且返工后还要再经过审查。审查的一条主要标 准就是每个阶段都应该交出“最新式的”（即和所开发的软件完全一致的）高质量的文档资料，从而保证在软件开发工程结束时有一个完整准确的软件配置交付使 用。文档是通信的工具，它们清楚准确地说明了到这个时候为止，关于该项工程已经知道了什么，同时确立了下一步工作的基础。此外，文档也起备忘录的作用，如 果文档不完整，那么一定是某些工作忘记做了，在进入生存周期的下一阶段之前，必须补足这些遗漏的细节。在完成生存周期每个阶段的任务时，应该采用适合该阶 段任务特点的系统化的技术方法──结构分析或结构设计技术。
把软件生存周期划分成若干个阶段，每个阶段的任务相对独立，而且比较简 单，便于不同人员分工协作，从而降低了整个软件开发工程的困难程度；在软件生存周期的每个阶段都采用科学的管理技术和良好的技术方法，而且在每个阶段结束 之前都从技术和管理两个角度进行严格的审查，合格之后才开始下一阶段的工作，这就使软件开发工程的全过程以一种有条不紊的方式进行，保证了软件的质量，特 别是提高了软件的可维护性。总之，采用软件工程方法论可以大大提高软件开发的成功率，软件开发的生产率也能明显提高。
目前划分软件生 存周期阶段的方法有许多种，软件规模、种类、开发方式、开发环境以及开发时使用的方法论都影响软件生存周期阶段的划分。在划分软件生存周期的阶段时应该遵 循的一条基本原则就是使各阶段的任务彼此间尽可能相对独立，同一阶段各项任务的性质尽可能相同，从而降低每个阶段任务的复杂程度，简化不同阶段之间的联 系，有利于软件开发工程的组织管理。一般说来，软件生存周期由软件定义、软件开发和软件维护三个时期组成，每个时期又进一步划分成若干个阶段。下面的论述 主要针对应用软件，对系统软件也基本适用。
软件定义时期的任务是确定软件开发工程必须完成的总目标；确定工程的可行性，导出实现工程 目标应该采用的策略及系统必须完成的功能；估计完成该项工程需要的资源和成本，并且制定工程进度表。这个时期的工作通常又称为系统分析，由系统分析员负责 完成。软件定义时期通常进一步划分成三个阶段，即问题定义、可行性研究和需求分析。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/337a236e065b390e973ad10120816684/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16dab4bcdd374aed5534098aaa73c510/" rel="bookmark">
			安卓代码中获取dimen设置字体大小setTextSize，会变得比dimen的值还大——解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 holder.tvMsgContent.setTextSize(mContext.getResources().getDimensionPixelOffset(R.dimen.message_content_font));
&lt;dimen name="message_content_font"&gt;32px&lt;/dimen&gt;
实际效果： 上面第一句java代码，设置的是红框中的字体大小，按理说应该和上面的标题差不多大小吧，为什么差这么多呢？
解决 动态设置TextView字体大小时候，会出现偏差。
TextView中暴露出来设置字体大小的方法有两种。
setTextSize(float size)
setTextSize(int unit, float size)
上面用的是第一种，现在看看第二种方法的源码
/** * Set the default text size to a given unit and value. See {@link * TypedValue} for the possible dimension units. * * @param unit The desired dimension unit. * @param size The desired size in the given units. * * @attr ref android.R.styleable#TextView_textSize */ public void setTextSize(int unit, float size) { Context c = getContext(); Resources r; if (c == null) r = Resources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16dab4bcdd374aed5534098aaa73c510/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba72619faf8a895647e2db061535c685/" rel="bookmark">
			Windows小技巧4——如何取消共享的文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows小技巧4——如何取消共享的文件夹 文件共享是指主动地在网络上（互联网或小的网络）共享自己的计算机文件，以便于其它用户远程访问。关于文件共享相关的小技巧可以参考如下文章：Ubuntu小技巧9——使用Samba服务实现Windows和Linux文件访问
但是想关闭共享的时候却发现无法轻易的取消共享，以下是Windows下取消共享文件的方法。
如图1，共享普通文件夹的时候是没有取消共享一栏的，无法在共享页面取消
但是，若共享的是某个盘的话是可以选择取消的，如图2
对于普通共享的文件夹，其去下共享方式如下，具体操作如图3-图5所示，主要步骤为：
我的电脑/计算机--管理—共享文件—贡献—选择文件并右键选择停止共享、
图3
图4
图5
以上是关闭共享文件的具体步骤，贴在此处仅供学习、参考！
Windows下文件夹共享，可以参考笔者博文：
如何用网线实现两台电脑的文件共享：https://blog.csdn.net/u011127242/article/details/44893455
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17a878b0b41929f2f8fdee8ad9f9dc2b/" rel="bookmark">
			Nmap使用说明及原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nmap使用说明
Nmap（Network Mapper） 是一款支持各种操作系统的开源网络扫描工具。主要用来进行主机发现、端口扫描，并通过端口扫描推断运行系统以及运行软件版本。Nmap还提供了对防火墙/IDS的相关技术与方法。
使用Nmap操作时，其基本命令格式为：Nmap [Scan Type(s)][options] {target}
下面分别叙述Nmap四种同技术与其实现流程与对防火墙的躲避技术，结尾将叙述Nmap应用方面的一些设置使用说明。
1. 主机发现
主机发现也称为ping扫描，但是Nmap中主机发现的技术已经不是简单的采用ping工具发送简单的ICMP回声请求报文。用户完全可以通过使用列表扫描(-sL)或者通过关闭ping(-P0)跳过ping的步骤，也可以使用多个端口把TPC SYN/ACK，UDP和ICMP任意组合使用。通过获得的响应以推测某个IP地址是否是活动的。下面是Nmap在主机发现过程中常用的命令：
-sL: 列表扫描 – 简单扫描列表目标
-sn: Ping扫描 – 禁用端口扫描
-Pn: 检测所有在线主机 — 跳过主机发现
-PS/PA/PU/PY[端口列表]: TCP SYN/ACK, UDP 或 SCTP 发现指定的端口
-PE/PP/PM: ICMP echo, timestamp, 和netmask request发现
-PO[协议列表]:IP协议ping
-PR 利用ARP协议，扫描局域网
-n/-R: 从不DNS解析/始终解析 [默认: 有时]
–dns-servers &lt; 服务器1[,服务器2],…&gt;:指定自定义DNS服务器
–system-dns: 使用系统自带的DNS解析器
–traceroute: 每个主机跟踪一跳路径
2. 端口扫描
端口扫描是Nmap的核心功能，使用nmap &lt;target&gt;可以扫描主机上的超过 1660个TCP端口。Nmap将扫描得到的端口分成六个状态： open(开放的)， closed(关闭的)，filtered(被过滤的)，unfiltered(未被过滤的)，open|filtered(开放或者被过滤的)，或者 closed|filtered(关闭或者被过滤的)。下面给出了端口扫描中常用命令以及其使用方式：
-sS (TCP SYN扫描)：半开放扫描，它只发送一个SYN报文然后等待回应，若SYN/ACK表示端口在监听 (开放)，而 RST (复位)表示没有监听者。如果数次重发后仍没响应， 该端口就被标记为被过滤。如果收到ICMP不可到达错误 (类型3，代码1，2，3，9，10，或者13)，该端口也被标记为被过滤。
-sT (TCP connect()扫描)：CPConnect()扫描是默认的TCP扫描，Nmap通过创建connect() 系统调用要求操作系统和目标机以及端口建立连接，而不像其它扫描类型直接发送原始报文。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17a878b0b41929f2f8fdee8ad9f9dc2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64ee9ee98b6d4c601a58f35e9c18b948/" rel="bookmark">
			c#中foreach语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		foreach循环用于列举出集合中所有的元素，foreach语句中的表达式由关键字in隔开的两个项组成。in右边的项是集合名，in左边的项是变量名，用来存放该集合中的每个元素。 该循环的运行过程如下：每一次循环时，从集合中取出一个新的元素值。放到只读变量中去，如果括号中的整个表达式返回值为true，foreach块中的语句就能够执行。一旦集合中的元素都已经被访问到，整个表达式的值为false，控制流程就转入到foreach块后面 的执行语句。 foreach语句经常与数组一起使用，下面实例将通过foreach语句读取数组的值并进行显示。 数组的属性：Array.Length数组的容量 利用这个属性，我们可以取得数组对象允许存储的容量值，也就是数组的长度、元素个数,这个比较好理解，数组还有其他的属性，比如数组的维数等，属性的用法比较简单，学会一种，其他的格式基本一致，这里我们就不举例了。 当数组的维数、容量较多时，C#提供了foreach语句，专门用来读取集合/数组中的所有元素，我们把这种功能叫做遍历。语法书写如下： 遍历数组：foreach（type objName in collection/Array） 这段语句会逐一检查数组中的所存储的变量值，并且一一将其取出，其中的type是你所要读取的数组对象将要存储在objName变量的数据类型，而objName是定义了一个type类型的变量名，代表每一次从集合和数组（collection/Array）中取得的元素，collection/Array则是所要存取的数组对象。用这种方法只需写一个foreach就可以遍历出除交错数组以外的所有维数的数组。 注： objName的数据类型type必须与collection/Array对象的类型相同或比它大。 下面我们举一个用foreach和for遍历规则数组的例子，其中涉及到了一个数组得到维数的方法，比较foreach在一次性遍历规则数组上的优势。 int[,,] a = new int[2, 2, 2] { {{ 1, 2 }, { 3,4}},{{ 5, 6 }, { 7,8}} };//定义一个2行2列2纵深的3维数组a for (int i = 0; i &lt; a.GetLength (0) ;i++ ) //用Array.GetLength(n)得到数组[0,1,,,n]上的维数的元素数，0代表行，1列，n代表此数组是n+1维 { for (int j = 0; j &lt; a.GetLength(1); j++) { for (int z = 0; z &lt; a.GetLength(2);z++ )//2代表得到纵深上的元素数，如果数组有n维就得写n个for循环 { Console.WriteLine(a[i,j,z]); } } } 用foreach循环一次性遍历a数组 int[,,] a = new int[2, 2, 2] { {{ 1, 2 }, { 3,4}},{{ 5, 6 }, { 7,8}} };//定义一个2行2列2纵深的3维数组a foreach(int i in a) { Console .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64ee9ee98b6d4c601a58f35e9c18b948/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/457/">«</a>
	<span class="pagination__item pagination__item--current">458/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/459/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>