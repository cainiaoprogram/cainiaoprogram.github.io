<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/109b2401f6aeced52414cbabe798ca5d/" rel="bookmark">
			最新快手点号教程：成功率高达80%（仅揭秘-自我保护）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新标题：打造高成功率的快手点赞号，揭秘自我保护策略的最新教程！
文章：
引言（100字）：
快手是目前备受热爱短视频的用户追捧的平台之一。在快手上拥有一个高成功率的点赞号不仅能够吸引更多粉丝关注，还能够获得更多曝光和赞赏。本文将分享一个最新的教程，揭秘如何打造一个高成功率的快手点赞号，并提供自我保护策略，帮助你在快手平台上取得更好的表现。通过本文提供的全面攻略，你可以提升点赞号的质量，增加成功率，实现更好的用户互动和影响力。
第一部分：打造高成功率的点赞号：关键步骤（200字）
要打造一个高成功率的点赞号，关键步骤不可或缺。首先，选择一个适合自己的创作领域，定位自己的目标受众，制定一个明确的创作方向。其次，提高视频的质量和内容吸引力，包括剧情设计、画面拍摄和后期制作等方面。另外，注意快手平台的算法规则和规范，合理利用标签和关键词进行优化，增加曝光和推荐的机会。
第二部分：自我保护策略：避免封禁风险（300字）
为了自我保护，避免账号被封禁，你需要采取一些策略。首先，遵守快手平台的社区规范，不发布违规或涉及敏感内容的视频。其次，注意账号的人气和互动情况，避免使用刷粉丝等不正当手段，以免引起平台的注意。此外，关注自己账号的安全性，定期更改密码，并设置账号绑定和安全验证等功能，确保账号信息的安全。
第三部分：提升成功率的技巧：互动和推广（300字）
要提高点赞号的成功率，互动和推广是关键。通过积极与粉丝互动，回复评论、私信等方式，增强用户黏性和参与度。此外，可以与其他优质号主合作，互相点赞、合作拍摄等，扩大曝光和粉丝群体。同时，利用社交媒体平台和其他渠道进行宣传推广，引导更多用户关注和点赞你的视频。
总结（100字）
打造一个高成功率的快手点赞号需要经过关键步骤的把握和自我保护策略的运用。选择适合自己的创作领域，提高视频质量和吸引力，是关键步骤中不可或缺的部分。同时，遵守快手平台的规范，注意账号安全，是自我保护的重要策略。通过互动和推广，与粉丝互动并扩大曝光范围，可以提高成功率和用户互动度。如果你渴望在快手平台上打造一个高成功率的点赞号，那么跟随本文的教程，掌握关键技巧，并运用自我保护策略，助你在快手平台上取得更好的表现和成就！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfbd74dafc7af79a520cb476cd730846/" rel="bookmark">
			stm32f407的hal库开发-adc（dma）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#ifndef __ADC_H__ #define __ADC_H__ #include "sys.h" /******************************************************************************/ #define N 100	//每个通道缓存区长度 #define ADC_CHANNELS 8 //8个转换通道 /******************************************************************************/ extern void MY_ADC_Init(void);	//初始化ADC和DMA; extern u16 getADC_CH(uint8 channel);//获取某一通道的采样结果，内部使用冒泡排序法，取中间50个求平均值； #endif /*********** **************************************************************************************** *名称：	adc.c *描述：	adc多通道DMA模式数据采集 *作者：	WYP *接口：	void MY_ADC_Init(void);	初始化ADC和DMA; uint16 getADC_CH(uint8 channel);获取某一通道的采样结果，内部使用冒泡排序法，取中间50个求平均值； ***************************************************************************************************/ #include "adc.h" /* 私有变量 ------------------------------------------------------------------*/ u16 ADC_ConvertedValue[N][ADC_CHANNELS]; ADC_HandleTypeDef ADC1_Handler;//ADC句柄 DMA_HandleTypeDef ADC1_DMA_Handler; //DMA句柄 /*************************************************************************************************** *名称：bubbleSort(u16 a[], u16 n) *描述：排序 *入口参数：排序数组，排序数量 *出口参数：无 ***************************************************************************************************/ void bubbleSort(u16 a[], u16 n){ u16 i,j,tmp; for( i =0 ; i&lt; n-1; ++i) { for( j = 0; j &lt; n-i-1; ++j) { if(a[j] &gt; a[j+1]) { tmp = a[j] ; a[j] = a[j+1] ; a[j+1] = tmp; } } } } /*************************************************************************************************** *名称：	MYDMA_Config() *描述：	DMA配置 *入口参数：	无 *出口参数：	无 ***************************************************************************************************/ void MYDMA_Config(void) { __HAL_RCC_DMA2_CLK_ENABLE();//DMA2时钟使能	//Tx DMA配置 ADC1_DMA_Handler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfbd74dafc7af79a520cb476cd730846/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88d877688f3f487e191ed1b49b7e5365/" rel="bookmark">
			史上最详细的Python安装教程，小白建议收藏！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：Hello大家好，我是小哥谈。Python是一种高级、通用、解释型的编程语言，由Guido van Rossum于1989年开始设计，1991年首次发布。它以简洁易读的语法而著称，并且强调代码的可读性和简洁性，使得程序员能够更容易理解和编写代码。本节课就给大家讲解一下如何安装Python解释器！🌈
目录
🚀1.Python开发环境概述
🚀2.下载Python
🚀3.安装Python
🚀4.测试Python是否安装成功
🚀5.Python安装失败的解决方法
🚀1.Python开发环境概述 Python是跨平台的开发工具，它可以在多个操作系统上进行使用，编写好的程序也可以在不同系统上运行。进行Python开发常用的操作系统及说明如下表所示。
🚀2.下载Python 要进行Python开发，需要先安装Python解释器。由于Python是解释型编程语言，所以需要一个解释器才能运行编写的代码。这里说的安装Python实际上就是安装Python解释器。下面以Windows操作系统为例，介绍下载及安装Python的方法。
在Python的官方网站中，可以很方便地下载Python的开发环境，具体下载步骤如下：
步骤1：打开浏览器（例如Google Chrome浏览器），输入Python官方网站，如下图所示。👇
说明：♨️♨️♨️
1.Python官网：Welcome to Python.org
2.Python官网是一个国外的网站，加载速度比较慢，打开时请读者耐心等待即可。
步骤2：将鼠标移动到 Downloads 菜单上，将显示和下载有关的菜单项，从上图所示的菜单可以看出，Python可以在Windows、Mac OS X等多种平台上使用。这里单击Windows菜单项，进入详细的下载列表，如下图所示。👇
说明：在上图所示的列表中，带有“x86”字样的压缩包，表示该开发工具可以在Windows 32位系统上使用；而带有“x86-64”字样的压缩包，则表示该开发工具可以在Windows 64位系统上使用。另外，标记为“web-based installer”字样的压缩包，表示需要通过联网才能完成安装；标记为“executable installer”字样的压缩包，表示通过可执行文件（*.exe）方式进行离线安装；标记为“embeddable zip file”字样的压缩包，表示嵌入式版本，可以集成到其他应用中。
步骤3：在Python下载列表页面中，列出了Python提供的各个版本的下载链接，读者可以根据需要下载。由于笔者的操作系统为Windows 64位，所以单击“Windows x86-64 executable installer”超链接，下载适用于Windows 64位操作系统的离线安装包即可。
步骤4：下载完成后，将得到一个名称为“python-3.8.2-amd64.exe”的安装文件（版本可自行选择）。
🚀3.安装Python 在Windows 64位系统上安装Python的步骤如下：👇
步骤1：双击下载后得到的安装文件python-3.8.2-amd64.exe，将显示安装向导对话框，勾选“Add Python 3.8 to PATH”复选框，表示将自动配置环境变量，如下图所示。
步骤2：单击“Customize installation”按钮，进行自定义安装，在弹出的安装选项对话框中采用默认设置，如下图所示。
步骤3：单击Next按钮，打开高级选项对话框，在该对话框中，除了默认设置外，还需要手动选中“Install for all users”复选框（即表示使用这台计算机的所有用户都可以使用），然后单击“Browse”按钮来设置Python的安装路径，如下图所示。
说明：在设置安装路径时，建议路径中不要有中文或空格，以避免使用过程中出现一些莫名的错误。
步骤4：单击Install按钮，开始安装Python，并显示安装进度，如下图所示。
步骤5：安装完成后将显示如下图所示的对话框，单击“Close”按钮关闭窗口即可。
🚀4.测试Python是否安装成功 在Python安装完成后，需要测试Python是否成功安装。例如，在Windows 10系统中检测Python是否成功安装，可以单击开始菜单右侧的“在这里输入你要搜索的内容”文本框，在其中输入cmd命令，如下图所示，按下&lt;Enter&gt;键，启动命令行窗口；在当前的命令提示符后面输入“python”，并按下&lt;Enter&gt;键，如果出现如图所示的信息，则说明Python安装成功，同时系统将进入交互式Python解释器中。
🚀5.Python安装失败的解决方法 如果在cmd命令窗口中输入python后，没有出现如上图所示的信息，而是显示“'python'不是内部或外部命令，也不是可运行的程序或批处理文件”的提示内容，即
原因是在安装Python时，没有选中“Add Python 3.8 to PATH”复选框，导致系统找不到python.exe的可执行文件，这时就需要手动在环境变量中配置Python环境变量，具体步骤如下：
步骤1：在“我的电脑”图标上单击鼠标右键，然后在弹出的快捷菜单中执行“属性”命令，并在弹出的“属性”对话框的左侧单击“高级系统设置”，在弹出的“系统属性”对话框中，单击“环境变量”按钮，如图所示。
步骤2：在弹出的“环境变量”对话框中，在该对话框下半部分的 “系统变量”区域选中Path变量，然后单击“编辑”按钮。如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88d877688f3f487e191ed1b49b7e5365/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7008e69e82ce0b2d1daa46523b70744a/" rel="bookmark">
			#005 Python实现批量 Word to PNG图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有个网友在WordtoPDF的文章中留言说有没有WORDTOPNG。
有需求，必须安排，业务场景做出来在聊聊。
一、思路 第一种：用WORD TO PDF的库（win32com.client）来实现 查资料发现这个库的SaveAs方法里面的WdSaveFormat 没有图片格式。
参考微软的官方说明：
WdSaveFormat 枚举 (Word) | Microsoft Learn
这个方法应该是行不通了。
第二种：百度出来Aspose这家商业的py库可以 立刻安排：Demo都跑成功了，结果图片上有这家的水印。
裤子都脱了，给我安排这个，就这？
第三种：曲线救国 STEP1：DOC先转PDF
SETP2：PDF转PNG
可行
二、实现和讲解 先贴代码，再来讲解注意事项：
# -*- coding: utf-8 -*- """ @Author : Nick @Time : 2023/9/7 @Comment : #005 doc to pdf to png """ from datetime import datetime from pathlib import Path import fitz #pip install PyMuPDF import cv2 # pip3 install opencv-python -i http://pypi.douban.com/simple --trusted-host pypi.douban.com import numpy as np import os from shutil import copyfile import win32com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7008e69e82ce0b2d1daa46523b70744a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff294e2ad92dfebf4665025184f7ae6a/" rel="bookmark">
			微信小程序onReachBottom事件使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在微信小程序中，onReachBottom事件用于监听页面滚动到页面底部的时候触发的事件。当用户滑动页面到底部时，可以通过监听该事件来执行相应的操作。
要使用onReachBottom事件，需要在对应的页面或组件中定义一个函数，并在Page或Component的生命周期函数中注册该事件。
下面是具体的步骤：
在页面或组件中定义一个函数，例如： // pages/index/index.js Page({ // ... // 页面滚动到底部时触发的事件 onReachBottom() { // 执行相应的操作，例如加载更多数据 this.loadMoreData(); }, // 自定义函数，用于加载更多数据 loadMoreData() { // 加载更多数据的逻辑代码 }, // ... }) 在Page或Component的生命周期函数中注册onReachBottom事件，例如： // pages/index/index.js Page({ // ... onLoad() { // 注册onReachBottom事件 wx.pageScrollTo({ scrollTop: 0, duration: 0 }); this.setData({ loadingMore: true }) let that = this; setTimeout(function () { that.setData({ loadingMore: false, }); }, 2000); }, // ... }) 以上示例中，定义了一个名为onReachBottom的函数来处理页面滚动到底部时的逻辑操作。在函数内部可以编写相应的代码来加载更多数据或执行其他操作。
需要注意的是，当页面或组件的内容较长时，才会触发onReachBottom事件。如果页面内容不足以滚动到底部，则不会触发该事件。
另外，为了避免重复加载数据，可以在loadMoreData函数中添加一些判断逻辑，例如设置一个标志位，表示正在加载中，当加载完成后再将该标志位设为false，防止再次触发加载操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9debc994be0ae76d9e6ff3bedd63f27/" rel="bookmark">
			Flask路由的参数传递
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、在Flask框架中，路由是指将URL映射到相应的处理函数。在Flask中，可以使用装饰器来定义路由。
二、要传递参数给路由处理函数，可以使用Flask中的变量规则。可以在路由定义中使用尖括号 &lt;variable&gt; 来定义变量规则，然后在处理函数中通过 request.view_args 获取传递的参数。
例：
from flask import Flask, request app = Flask(__name__) @app.route('/user/&lt;username&gt;') def user_profile(username): return 'Hello, ' + username + '!' @app.route('/post/&lt;int:post_id&gt;') def post_detail(post_id): return 'You requested post with ID ' + str(post_id) if __name__ == '__main__': app.run(debug=True) 在上面的示例中，我们定义了两个路由：
/user/&lt;username&gt; 和 /post/&lt;int:post_id&gt;。
在 /user/&lt;username&gt; 路由中，我们使用 &lt;username&gt; 定义了一个变量规则，它会匹配 URL 中的任意文本，并将其作为参数传递给 user_profile() 处理函数。在 /post/&lt;int:post_id&gt; 路由中，我们使用 &lt;int:post_id&gt; 定义了一个变量规则，它会匹配 URL 中的任意整数，并将其作为参数传递给 post_detail() 处理函数。
在处理函数中，我们可以通过 request.view_args 来获取传递的参数。例如，在 user_profile() 函数中，我们可以使用 request.view_args['username'] 来获取传递的 username 参数。在 post_detail() 函数中，我们可以使用 request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9debc994be0ae76d9e6ff3bedd63f27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d8075ddd2f1a12c57ed989a92996d6/" rel="bookmark">
			人工智能入门 | K-means聚类算法的应用案例实战（含代码&#43;图示）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： Hello大家好，我是小哥谈。 K-means算法是很典型的基于距离的聚类算法，采用距离作为相似性的评价指标，即认为两个对象的距离越近，其相似度就越大。该算法认为簇是由距离靠近的对象组成的，因此把得到紧凑且独立的簇作为最终目标。🌈 目录
🚀1.k-means算法优缺点
🚀2.算法思想
🚀3.解决的问题
🚀4.k-means原理介绍
🚀5.k-means算法实战
🚀1.k-means算法优缺点 优点：容易实现 缺点：可能收敛到局部最小值，在大规模数据集上收敛较慢.
使用数据类型： 数值型数据 🚀2.算法思想 k-means算法 实际上就是通过计算不同样本间的距离来判断他们的相 近关系的，相近的就会放到同一个类别中去。📚 🚀3.解决的问题 k-means算法属于无监督学习的一种聚类算法，其目的为：在不知数据所属类别及类别数量的前提下，依据数据自身所暗含的特点对数据 进行聚类。对于聚类过程中类别数量 k 的选取，需要一定的先验知识， 也可根据“类内间距小，类间间距大“（一种聚类算法的理想情况） 为目标进行实现。🍃
🚀4.k-means原理介绍 k-means算法以数据间的距离作为数据对象相似性度量的标准，因此选择计算数据间距离的计算方式对最后的聚类效果有显著的影响，常用计算距离的方式有：余弦距离、欧式距离、曼哈顿距离等。🌻
🚀5.k-means算法实战 实现效果如下： 代码（每一步都已经清楚的进行了说明）： from numpy import * import pandas as pd import matplotlib.pyplot as plt #距离度量函数 def calc_distance(vec1,vec2): return sqrt(sum(power(vec1-vec2,2))) #创建初始聚类中心 def creat_centroid(data,k): centroids = zeros((k,n)) centroids[0,0] = 2 centroids[0,1] = 10 centroids[1, 0] = 5 centroids[1, 1] = 8 centroids[2, 0] = 1 centroids[2, 1] = 2 return centroids # k-means聚类 def kMeans(data,k,dist=calc_distance,creat_center = creat_centroid): # 初始化cluster_assment，存储中间结果 #第一列存储索引，第二列存储距离 # 样本的个数 m = shape(data)[0] init = zeros((m,2)) cluster_assment = mat(init) # 初始化聚类中心矩阵 centroids = creat_centroid(data,k) for epoch in range(1): # 对数据集合中每个样本点进行计算 for i in range(m): min_dist = inf min_index = -1 # 对每个样本点到每个中心的距离进行计算 for j in range(k): dist_ij = calc_distance(centroids[j, :],data[i, :]) # 找到距离最近的中心的距离和索引 if dist_ij &lt; min_dist: min_dist = dist_ij min_index = j cluster_assment[i,:] = min_index,min_dist # 对所有节点聚类之后，重新更新中心 for i in range(k): # .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68d8075ddd2f1a12c57ed989a92996d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a9decabb9dc2b25b27b05741c2d7540/" rel="bookmark">
			人工智能入门 | 分类算法-KNN(原理&#43;代码&#43;结果)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：Hello大家好，我是小哥谈。KNN，即K最邻近算法，是数据挖掘分类技术中比较简单的方法之一，简单来说，就是根据“最邻近”这一特征对样本进行分类。🌈
目录
🚀1.K-means和KNN区别
🚀2.KNN的算法思想
🚀3.算法步骤
🚀4.KNN算法的优缺点
🚀5.数据集
🚀6.代码实现
🚀7.结果
🚀1.K-means和KNN区别 K-means是一种比较经典的聚类算法，本质上是无监督学习，而KNN是分类（或回归）算法，是监督学习。✅
K-means算法的训练过程需要反复迭代的操作（寻找新的质心），但是KNN不需要。K-means中的 K 代表的是簇中心，KNN的 K 代表的是选择与新测试样本距离最近的前K个训练样本数。🌳
🚀2.KNN的算法思想 KNN（k-NearestNeighbor）又被称为近邻算法，它的核心思想是：物以类聚，人以群分。✅
假设一个未知样本数据x需要归类，总共有ABC三个类别，那么离x距离最近的有k个邻居，这k个邻居里有k1个邻居属于A类，k2个邻居属于B类，k3个邻居属于C类，如果k1&gt;k2&gt;k3，那么x就属于A类，也就是说x的类别完全由邻居来推断出来。🌳
🚀3.算法步骤 🍀（1）计算测试对象到训练集中每个对象的距离
🍀（2）按照距离的远近排序
🍀（3）选取与当前测试对象最近的K的训练对象，作为该测试对象的邻居。
🍀（4）统计这K个邻居的类别概率
🍀（5）K个邻居里频率最高的类别，即为测试对象的类别。
🚀4.KNN算法的优缺点 优点：非常简单的分类算法没有之一，人性化，易于理解，易于实现，适合处理多分类问题，比如推荐用户。
缺点：属于懒惰算法，时间复杂度较高，因为需要计算未知样本到所有已知样本的距离，样本平衡度依赖高，当出现极端情况样本不平衡时，分类绝对会出现偏差。可解释性差，无法给出类似决策树那样的规则。向量的维度越高，欧式距离的区分能力就越弱。
🚀5.数据集 名称：Prostate_Cancer
提取链接：https://pan.baidu.com/s/1xv8r54qaLpH8RiMRkcrzyA 提取码：66hg 数据集展示：
🚀6.代码实现 from sklearn.neighbors import KNeighborsClassifier import numpy as np import random import pandas as pd def knn(): K = 8 data=pd.read_csv(r"C:\Users\Lenovo\Desktop\course\Prostate_Cancer.csv") n = len(data) // 3 test_set = data[0:n] train_set = data[n:] train_set = np.array(train_set) test_set = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a9decabb9dc2b25b27b05741c2d7540/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1063e8328f58141be3e2f1f6daa6bda/" rel="bookmark">
			【Opencv入门到项目实战】（十一）：harris角点检测|SIFT|特征匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所有订阅专栏的同学可以私信博主获取源码文件
文章目录 1.harris角点检测2.尺度不变特征变换（SIFT）2.1图像尺度空间2.2 关键点定位2.3 消除边界响应2.4 代码示例 1.harris角点检测 这一节我们来讨论一下Harris角点检测，由Chris Harris和Mike Stephens于1988年提出。该算法通过计算图像的局部灰度变化来检测角点，并利用协方差矩阵的特征值来确定是否为角点。
它的基本思想是，对于图像I(x,y)，当在点(x,y)处平移( Δ \Delta Δx, Δ \Delta Δy)后的灰度变化有多大。我们定义其变换后的自相似性为:
w(x, y)是以点(x,y)为中心的一个窗口，一般我们用高斯窗口函数，用于平滑梯度。
然后对右边利用泰勒展开:
其中，Ix和Iy分别表示图像在x和y方向上的梯度
代入后近似得到下列结果：
其中M为协方差矩阵:
接下来我们利用协方差的特征值来计算每个像素点的角点相响应值R
其中，det(M)表示协方差矩阵M的行列式，trace(M)表示协方差矩阵M的迹， α \alpha α是一个常数，用于调整响应函数的灵敏度。
在Opencv中，我们调用cv2.cornerHarris()函数实现
import cv2 import numpy as np # 导入图片 img = cv2.imread('test_1.jpg') print ('img.shape:',img.shape) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) gray = np.float32(gray)#转换为float32格式 dst = cv2.cornerHarris(gray, 2, 3, 0.04) print ('dst.shape:',dst.shape) img.shape: (512, 512, 3) dst.shape: (512, 512) img[dst&gt;0.01*dst.max()]=[0,0,255] #非极大值抑制,将边界点标红 cv2.imshow('dst',img) cv2.waitKey(0) cv2.destroyAllWindows() 上图可以看出，我们将当中的角点都检测出来了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1063e8328f58141be3e2f1f6daa6bda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13af8a081df4272305f915da42273575/" rel="bookmark">
			python串口采集数据绘制波形图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个示例使用 matplotlib 绘制图形，它能够从串口实时读取数据并绘制成波形图。确保你已经替换了 ‘COM11’ 和 9600 为正确的串口号和波特率。
import serial import matplotlib.pyplot as plt from collections import deque import struct # 配置串口参数 ser = serial.Serial('COM11', 9600) # 将'COM1'替换为你的串口号和波特率 # 创建空的数据列表 data = deque(maxlen=100) # 保持最新的100个数据点 # 创建一个图形窗口 plt.ion() # 开启交互模式 fig, ax = plt.subplots() line, = ax.plot([]) ax.set_ylim(0, 255) # 设置y轴范围，根据你的数据范围进行调整 # 读取并绘制串口数据 try: while True: try: # 读取一个字节的16进制数据 value_hex = ser.read(1) if value_hex: # 将16进制数据转换为整数 value = struct.unpack('B', value_hex)[0] data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13af8a081df4272305f915da42273575/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5510efc5dbf79cef7b11c47ed30c370c/" rel="bookmark">
			Java 获得任意一个时间的 下一天的时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习内容： java 获得任意一个时间的 下一天的时间 的方法：
1. 使用DateUtil
public class Main {
public static void main(String[] args) {
// 指定日期
Date date = new Date();
// 指定天数 int daysToAdd = 1; // 使用 DateUtil 添加指定年数 Date newDate = DateUtils.addDays(date, daysToAdd); // 打印结果 System.out.println("原日期: " + date); System.out.println("添加 " + daysToAdd+ " 天后的日期: " + newDate); } }
2. 使用 LocalDate
public class Main {
public static void main(String[] args) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5510efc5dbf79cef7b11c47ed30c370c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efefb1f1e779690309691eaa66bb5234/" rel="bookmark">
			Android原生JsonObject、JSONObject、JSONArray及JsonArray添加内容(备注：个人整理)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【前言】：本博客是经过本人实际验证后记录下来的一些有效的固定写法，便于后续自己直接拷贝粘贴，提高开发效率
JsonArray array = new JsonArray();//初始化 JsonArray array.add("xxx");//JsonArray 添加值 array.add(array1);//JsonArray 添加另一个 JsonArray array.add(jsonObject);//JsonArray 添加 JsonObject JsonObject jsonObject = new JsonObject();//初始化 JsonObject jsonObject.addProperty("xxx", "xx");//JsonObject 添加属性及值 jsonObject.add("xxx", jsonObject1);//JsonObject 添加另一个 JsonObject jsonObject.add("xxx", array);//JsonObject 添加 JsonArray JSONObject jSONObject = (JSONObject) JSONObject.toJSON(jsvaObject);//java object转 JSONObject JsonObject jsonObject = GsonUtils.toJsonElement(jsvaObject)//java object转 JsonObject jSONObject.remove(key);//JSONObject 移除 key jSONObject.put(key, value);//JSONObject 添加 key 及 value JavaObject javaObject= GsonUtils.formJson(jSONObject .toString(), JavaObject.class);//JSONObject 转 java object JSONArray jSONArray = new JSONArray(); for (Object object : objects) { jSONArray.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efefb1f1e779690309691eaa66bb5234/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8864c3c31394219181deb53689b8a4b8/" rel="bookmark">
			使用java运行dll文件方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入依赖 &lt;dependency&gt; &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt; &lt;artifactId&gt;jna&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt; &lt;/dependency&gt; 创建接口类 public interface WinningChssInterfaceDLL extends Library { //加载文件。 WinningChssInterfaceDLL INSTANCE = Native.loadLibrary("C:\\Users\\admin\\Desktop\\usb3ea.dll",WinningChssInterfaceDLL.class); //定义ddl文件的方法 int GetCardStatus(Boolean a, Boolean b); void SetEncoding(short CardNo, int PackingVer, int FramingVer, int encoding, int bits); void StopSample(); } 继承了Structure，与本地代码进行交互 @Data public class COMWAVEDATA extends Structure { public int FrameNo; public long ArrivingTimeus; public int usInArrivingTime; public int nsInArrivingTime; public double Amp; public int ChannelId; public SYSTEMTIME ArrivingTimeST; public int RingdownCount; public int RisingRingdownCount; public long DurationTimeus; public long RiseTimeus; public double Enery; public double RMS; public double ASL; public long ArrivingTimens; public long DurationTimens; public long RiseTimens; public double[] ExParam = new double[17]; //getFieldOrder 方法指定了这些字段的顺序，这在涉及到本地代码的情况下很重要，因为它确保了Java对象的布局与本地代码的期望布局相匹配。 @Override protected List getFieldOrder() { return Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8864c3c31394219181deb53689b8a4b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae283266c7db17a06a31bb2145eae78c/" rel="bookmark">
			机器学习入门六（贝叶斯网络数据分类）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		老师要求做一个因果分析，没有思路。目前作者了解到了辛普森悖论，所以想找一个比较合适的方法做一下因果分析，于是找到了《Python机器学习算法与实战》这本书看了一眼里面的内容，偷学了一手贝叶斯网络书数据分类方法哈哈哈。
文章目录 前言一、pandas是什么？二、使用步骤 1.引入库2.读入数据总结 前言 贝叶斯网络处理一些分类问题，同时尝试用贝叶斯网络做因果分析。本文采用的数据集仍未泰坦尼克号幸存者数据集。
一、贝叶斯网络是什么？ 贝叶斯网络是一种用于概率推理的图模型，它可以描述多个变量之间的依赖关系。贝叶斯网络反映了变量之间的条件概率分布，以节点表示变量，以有向边表示变量之间的依赖关系。如果两个变量A和B有一条指向B的有向边，则表示A影响了B，即B的条件概率分布依赖于A。贝叶斯网络可以用于很多应用场景，如医学诊断、金融风险评估、机器人导航等。下图就是托马斯 贝叶斯。有点小帅，不得不说这个模型很有东西。
贝叶斯网络的推理可以分为两种类型：预测和诊断。预测是指利用已知变量的值来预测其他变量的值，而诊断是指利用已知变量的值来确定某一变量的原因。预测和诊断的核心是贝叶斯规则，即在已知其他变量的条件下，计算某一变量的概率分布。下图就是一个简单的贝叶斯网络了。
贝叶斯网络的构建通常涉及两个步骤：结构学习和参数学习。结构学习是指确定变量之间的依赖关系，而参数学习是指计算每个节点的条件概率分布。结构学习和参数学习可以使用最大似然估计、贝叶斯估计等方法进行。
我们呢本篇主要是想做一下分类，并且找到一定的特征之间的因果关系。下面我们直接来进入实战。
二、贝叶斯网络对泰坦尼克号数据进行分类实战 1.引入库和数据 #导入的库 import pandas as pd import numpy as np import matplotlib.pyplot as plt plt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签 plt.rcParams['axes.unicode_minus']=False #用来正常显示负号 import seaborn as sns #导入数据 data = pd.read_csv('预处理Titanic.csv',engine='python')#有中文路径，需要设置引擎为python data 具体导入的数据在第4篇就已经写过了过段时间我会把数据集发上去的。 这里引入的库不是很全，下面有sklearn的引入和pgmpy的引入因为作者写着写着发现总丢库哎😔 而且我看的那本书库是写在一页的导致我学起来要不停的导入模块，不过这本书的内容还是比较精致的。
2.数据再处理 因为根据上面的输出我们可以看出有一些数据是连续性的，但我看这个模型基本上都是离散型变量，所以这里我们啊这里用k-means的聚类方法分为3类
#做简单处理 不要出现连续数据 from sklearn.preprocessing import KBinsDiscretizer X = data[["Age","Fare"]].values kabins = KBinsDiscretizer(n_bins=[3,3]#分箱数 ,encode='ordinal'#编码方式 ,strategy='kmeans'#分箱方式 ) X_kb = kabins.fit_transform(X)#分箱后的数据 X = data[["Age","Fare"]]=np.int8(X_kb)#转换为int8类型 print(data.head()) 3.自定义贝叶斯网络并可视化 首先我们其实可以根据我们之前做过的决策树去制定一个贝叶斯网络
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae283266c7db17a06a31bb2145eae78c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/655cf839dd55c1757e2dbb4d473fece0/" rel="bookmark">
			【C&#43;&#43;】二进制传输结构体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;iostream&gt; #include &lt;string&gt; typedef struct{ char test[32]; int a; double b; }BaseA; typedef struct{ double b; char test[32]; int a; }BaseB; int main() { BaseA base; std::string strTemp = "hello"; snprintf(base.test, sizeof(strTemp), strTemp.c_str()); base.a = 1; base.b = 3.14; // 将结构体转换为 char* char* ptr = reinterpret_cast&lt;char*&gt;(&amp;base); // 正确 auto* base2 = (BaseA*)ptr; // 异常 需要保证传输双方使用相同的结构体 // BaseB* base2 = (BaseB*)ptr; std::cout &lt;&lt; base2-&gt;test &lt;&lt; std::endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42a732d8c1cf8c887f2ab50285b99333/" rel="bookmark">
			手眼标定详述(坐标系介绍，二维、三维的手眼标定方法@九点法、AX=XB)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手眼标定 1. 写在前面2. 手眼标定基本分类2.1 手眼标定坐标系2.2 眼在手外（EYE TO HEAD）2.3 眼在手上（EYE IN HEAD） 3. 九点法（二维）- 算法实现流程4. AX=XB方法（二维或三维）- 推导 &lt; 什么是AX=XB &gt;4.1 坐标系转换&amp;运算规则4.1.1 齐次坐标系 4.2 实际坐标系转换公式推导4.2.1 眼在手外4.2.2 眼在手上 4.3 求解 5. AX=XB方法（二维或三维）- 算法实现流程（总结）源码相关的博文 1. 写在前面 手眼标定实际上就是为了让机械臂知道相机拍出来的物品相对于机械臂在什么位置，所以无论下面的哪一种实际都是建立相机坐标系与机械臂坐标系的映射关系。
另外，相机标定的内容可以参考这里https://blog.csdn.net/m0_52785249/article/details/125973858 2. 手眼标定基本分类 2.1 手眼标定坐标系 Base坐标系(基坐标系)描述机械臂基座的位置Tool坐标系(工具坐标系)描述机械爪(机械臂末端)的位置Cam坐标系(相机坐标系)描述相机的位置Cal坐标系(标定板坐标系)描述标定板的位置 2.2 眼在手外（EYE TO HEAD） 如下图所示，眼在手外是将相机固定在相机平面；标定板固定在机械臂末端，通过移动机械臂来获取标定图像。
由于眼在手外标定时，Base坐标系和Cam坐标系的位置是固定的，因此眼在手外主要是求这两个坐标系的关系。
2.3 眼在手上（EYE IN HEAD） 如下图所示，眼在手上是将相机固定在机械臂末端；标定板固定在物品平面，通过移动机械臂来获取标定图像。
同理，眼在手上时，相机坐标系和工具坐标系的位置是相对不变的。因此，标定的就是相机坐标系和工具坐标系的关系。
3. 九点法（二维）- 算法实现流程 对于二维的手眼标定，广泛采用的方法是九点法： 在获得相机参数后，指定九个点，先通过相机获得在相机坐标系下这九个点的坐标（2d）。再通过示教器将机械臂分别移到九个点的位置，并获取对应在机械臂末端坐标系下的九个点坐标（2d）。最后，建立两者的映射关系，即可以表达相机坐标系到机械臂坐标系的关系。 4. AX=XB方法（二维或三维）- 推导 &lt; 什么是AX=XB &gt; 4.1 坐标系转换&amp;运算规则 对于旋转矩阵，坐标系转化（A&gt;&gt;C）表示为：
C A R = B A R ∗ C B R ^{A}_{C}R^{} = ^{A}_{B}R^{} * ^{B}_{C}R^{} CA​R=BA​R∗CB​R
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42a732d8c1cf8c887f2ab50285b99333/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c53f4956d9bff4eee222586ff19a7efa/" rel="bookmark">
			字、字长、机器字长、存储字长、存储容量、总线宽度关系梳理！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在梳理计算机相关知识的时候，发现网上不少人将字、字长、机器字长、存储字长、总线宽度的概念搞混了！经过多方资料查询，得到一个靠谱的结论！
直接说结论：
1. 字长=机器字长=CPU总线的宽度（一般是地址总线和数据总线）=CPU的位数=通用寄存器的宽度。
注意：
（1）数据总线宽度不一定都等于字长（可以有32位，16位等），但是一般如果题目没有具体指明数据总线的宽度，默认等于字长。
举个例子：32位计算机：字长 = 机器字长 = 地址总线宽度=数据总线宽度=通用寄存器宽度=32位！
2. 存储容量 （KB）= 存储单元数量 * 存储单元字节数
存储容量 （Kb）= 存储单元数量 * 存储单元字长
存储单元数量 = 2^地址总线宽度
注意：
（1）存储单元计算机一般默认1Byte，与数据总线宽度无关，数据总线只影响CPU数据的传输速率，不影响存储单元字节数和存储容量！！ （概念易混！）
存储单元计算机一般默认1Byte的原因直接po一段网友的精彩发言：
内存的可寻址单元是以字节为单位，也就是说不能cpu不能单独定位某个内存位（bit）而只能一次定位到byte； 机器的字长是指cpu一次可以读入的位数；32位可以读入四个字节;64位可以读入八个字节; 为了保证可以单独寻址单个字节;内存的每个字节都需要一个地址; 这样;32为地址线接口的内存只能有2^32*8bit=4GB的容量; 如果内存的寻址单元为两个字节,那么容量可以达到8GB，但是最小的单位将变成两个字节,哪怕我们只是存入一个char，也要占用两个字节；这是个寻址粒度和容量的问题； cpu和内存之间有内存控制器吧，cpu可以一次吐出四个字节到内存控制器;内存控制器分别寻址到每个字节，然后存入内存。 我们可以让只有一条地址线的cpu支持4GB的内存,但是我们只能保存一个数据进去。
（2）存储容量只跟地址总线宽度有关！
（3）存储字长是一个存储单元所存储的二进制位数，与机器字长无关，计算机一般都是8位（1Byte）
举个例子：
若256KB的SRAM具有16条数据线，则他具有多少条地址线？
答：18条
存储单元数量 = 存储容量 （KB）/存储单元字节数 = 256KB/1B = 256K = 2^8 * 2^10 = 2^18
所以有18条地址线，另外1K = 2^10 = 1024
总结：所以你经常看到网上很多说的，为什么地址总线为32位，数据总线为16位的CPU，最大可支持容量为4G（2^32） 而不是2^32 * 2B = 8GB ，因为数据总线根本不影响存储容量！只影响CPU传输速率！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b108610271d51c86071cb5b11b325ea/" rel="bookmark">
			概率论与数理统计学习笔记（7）——全概率公式与贝叶斯公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 背景2. 全概率公式3. 贝叶斯公式 1. 背景 下图是本文的背景内容，小B休闲时间有80%的概率玩手机游戏，有20%的概率玩电脑游戏。这两个游戏都有抽卡环节，其中手游抽到金卡的概率为5%，端游抽到金卡的概率为15%。已知小B这天抽到了金卡，那么请问他是在手机上抽到的还是在电脑上抽到的？
2. 全概率公式 上述问题中，我们先考虑小B抽到金卡这件事的概率，设玩电脑的概率为 P ( c ) P(c) P(c)，玩手机的概率为 P ( p ) P(p) P(p)，抽到金卡的概率为 P ( v ) P(v) P(v)：
如果小B是在电脑上抽到的金卡，那么其概率为 P ( c ) P ( v ∣ c ) P(c)P(v|c) P(c)P(v∣c)，就是玩电脑的概率乘上在电脑上抽到金卡的概率。如果小B是在手机上抽到的金卡，那么其概率为 P ( p ) P ( v ∣ p ) P(p)P(v|p) P(p)P(v∣p)，就是玩手机的概率乘上在手机上抽到金卡的概率。 上面两个式子分别计算了在手机上抽到金卡和在电脑上抽到金卡的概率，那么两者加起来就是小B抽到金卡的概率，即： P ( v ) = P ( c ) P ( v ∣ c ) + P ( p ) P ( v ∣ p ) P(v)=P(c)P(v|c)+P(p)P(v|p) P(v)=P(c)P(v∣c)+P(p)P(v∣p)。这就是全概率公式，简单来说就是该事件在所有可能的情况下发生的概率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b108610271d51c86071cb5b11b325ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aba6722256ceb96a0ececed4d6b4861e/" rel="bookmark">
			计算机发送数据的生命周期是怎样的？底层原理是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机发送数据的生命周期主要包括数据的封装、传输和接收三个阶段。下面对每个阶段的底层原理进行简要介绍。
数据的封装 在发送数据之前，应用程序首先需要将要发送的数据封装成网络报文。网络报文通常包括报文头和报文体两部分。报文头包含了一些必要的信息，如源IP地址、目的IP地址、数据包序号等。报文体则是应用程序要发送的具体数据。
在封装网络报文的过程中，操作系统会根据网络协议栈的工作方式，依次添加各个协议层的报文头信息。例如，TCP/IP协议栈中，操作系统会先添加TCP报文头，再添加IP报文头，最后再添加以太网帧头。这样，一个完整的网络报文就被封装成了多层的数据包。
数据的传输 封装完成的网络报文会被操作系统通过网络适配器（例如网卡）发送到网络上。网络适配器会将数据包转换成电信号并通过物理媒介（如光纤、电缆等）传输到接收方。在传输的过程中，数据包可能会被路由器、交换机等网络设备转发、分组等操作。
数据的接收 接收方的网络适配器会接收到发送方发送的数据包，并将其转换成计算机可读的二进制数据。接收方的操作系统会解析数据包的报文头，根据目的IP地址和端口号等信息将数据包交给相应的应用程序。
接收方的应用程序会对接收到的数据进行解析和处理。如果数据包丢失或损坏，接收方的TCP协议会发出重传请求，确保数据的可靠性。
总体来说，计算机发送数据的生命周期涉及到多个层次的协议和多个网络设备之间的交互。操作系统在其中发挥着重要的作用，负责将应用程序要发送的数据封装成网络报文，将数据包发送到网络上，并将接收到的数据包交给相应的应用程序进行处理。网络协议栈的设计也是保证数据能够顺利传输的重要因素。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d77bbaa6aa5553d81ba035cc698a67e/" rel="bookmark">
			网络架构是什么意思？底层原理是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络架构（Network Architecture）是指计算机网络中各个硬件设备、软件组件和协议之间的关系和组织方式。它包括网络的层次结构、协议的层次结构、通信方式、拓扑结构和网络安全等方面。
在计算机网络中，网络架构通常按照OSI（开放系统互连）模型或TCP/IP模型来划分，其中OSI模型将网络架构分为七个层次，每个层次都有自己的功能和责任。TCP/IP模型将网络架构分为四个层次，包括网络接口层、网络层、传输层和应用层。
底层原理是网络架构需要按照一定的规则、协议来组织和管理计算机网络中的各个部分，以便于数据的传输和交换。网络架构中的各个组成部分都有自己的功能和特点，需要遵循一定的规范和协议进行通信和交互。网络架构的设计和实现需要考虑多种因素，包括网络的拓扑结构、数据传输速度、网络安全和可靠性等方面，以满足不同应用场景和需求的要求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a48f8c8cb38dc58a3e6b249d1391e7f/" rel="bookmark">
			计算机内存地址是干什么的？底层原理是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机内存地址（Memory Address）是指内存中存储数据的位置。在计算机运行程序时，需要将程序和数据加载到内存中，程序通过访问内存地址来读取和写入数据。计算机内存地址是程序运行的关键，也是操作系统、编译器和计算机硬件设计的重要基础。
底层原理是计算机内存地址的实现是通过地址总线、数据总线和控制总线来实现的。当CPU需要访问内存时，它会向内存控制器发出地址信号，内存控制器会根据地址信号将数据发送到数据总线上，CPU通过数据总线读取或写入内存中的数据。由于每个内存地址都对应着一段物理存储空间，计算机可以通过内存地址来访问任意位置的内存，这也是计算机高速访问数据的关键之一。
计算机内存地址的大小决定了计算机可以寻址的内存容量。在32位计算机中，内存地址由32位二进制数表示，最大可以寻址2^32个内存单元，即4GB。而在64位计算机中，内存地址由64位二进制数表示，最大可以寻址2^64个内存单元，即16EB。内存地址的大小也影响着计算机的运行速度和性能，因为内存地址越大，CPU就可以一次访问更多的数据，提高了计算机的访问速度和效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd15c1133ae78097f28b0fbd5673f9c4/" rel="bookmark">
			计算机的软件和硬件是如何交互的？底层原理是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机的软件和硬件是通过中间层进行交互的，这个中间层就是操作系统。操作系统作为计算机系统的核心，负责管理计算机的硬件资源和软件资源，提供各种服务，为应用程序和硬件设备提供接口和通信。在操作系统的支持下，应用程序可以直接调用硬件设备来完成各种任务。
在具体实现上，计算机的软件和硬件是通过系统调用来进行交互的。系统调用是操作系统提供的接口，允许应用程序向操作系统请求服务。当应用程序需要访问硬件设备或者其他系统资源时，它会通过系统调用将请求传递给操作系统，操作系统会处理请求并返回结果给应用程序。
底层原理是，在操作系统内核中，系统调用会触发中断，将控制权从用户态切换到内核态，进入操作系统内核执行对应的操作。操作系统内核负责管理计算机的硬件资源和提供各种服务，可以直接访问和控制硬件设备，比如磁盘、网络、内存等。操作系统通过提供系统调用来暴露自己的功能和服务，应用程序通过系统调用向操作系统发出请求，并通过系统调用接收来自操作系统的响应。
系统调用是应用程序和操作系统之间的桥梁，为应用程序提供了访问计算机硬件资源和系统服务的接口，也保护了操作系统和硬件资源不被恶意应用程序滥用。计算机的软件和硬件通过系统调用的交互实现了紧密的联系和协作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9022ba5c4d7770a1eab9fa9cebfdf855/" rel="bookmark">
			This is often the result of over-eager type matching - consider using ‘getBeanNamesForType‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情景： 新增了一个组织岗位service类，直接使用没啥问题。 但是组织类对接外部接口，有重写。启动就报错了
org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'orgServicePortalImpl': Bean with name 'orgServicePortalImpl' has been injected into other beans [userServiceImpl,positionServiceImpl] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using 'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9022ba5c4d7770a1eab9fa9cebfdf855/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/476794ea722cf16af3a480266c05f986/" rel="bookmark">
			华为云云耀云服务器L实例评测 | 3分钟搞懂如何在华为云服务器安装Nginx并配置静态访问页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是Nginx？二、申请华为云服务器三、使用XShell连接华为云服务器并安装Nginx四、FileZilla连接服务器五、Linux下安装Nginx❇️配置80端口并关闭Linux防火墙✳️测试 六、配置静态html至华为云服务器并访问⚠️在华为服务器新建路径⏰使用Filezilla上传文件至华为云服务器⚡配置Nginx访问路径✅测试 ⛽Nginx相关命令⛵小结 一、什么是Nginx？ 百度百科
Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的
其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、简单的配置文件和低系统资源的消耗而闻名
Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。
Nginx的好处？
总结：Nginx 是一个高性能的 HTTP 和反向代理服务器，可以扛得住 5W 左右的并发。Ngnix 可以做反向代理服务器，还可以做静态资源服务器。
二、申请华为云服务器 华为云服务器官网： https://www.huaweicloud.com/
目前官网有活动，大家可自行购买。
我购买了 云耀服务器实例 ，感觉还不错，推荐购买
三、使用XShell连接华为云服务器并安装Nginx 安装XShell
xshell官网 自行下载即可
使用 xshell链接 华为云服务器进入系统
打开xshell输入ip地址进入linux系统
输入后，进行下一步，输入root，密码后，进行链接，等待响应。
连接成功~
四、FileZilla连接服务器 安装Filezilla
Filezilla官网
直接无脑式下一步安装即可
连接服务器
打开filezilla进行连接
输入站点信息
连接成功~
五、Linux下安装Nginx 安装之前先检测下linux系统有没有nginx，如果有则删除
whereis nginx 在/usr/local下新建nginx目录
进入目录 cd /usr/local 新建nginx文件夹 mkdir nginx 进入nginx
cd /usr/local/nginx 输入ll 命令查看该目录下的所有文件
ll 肯定是空文件夹，下面我们就安装nginx
打开nginx官网下载nginx
nginx官方下载
我们选择稳定版本1.20.2
下载完毕使用Filezilla将文件上传至nginx
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/476794ea722cf16af3a480266c05f986/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6edbcdb7c2719c9717eb10ac75e3ccc4/" rel="bookmark">
			C&#43;&#43;：菱形继承 （多继承的缺陷）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		菱形继承 🍁多继承🍁菱形继承🍂 菱形继承造成的数据冗余 🍁菱形虚拟继承🍂菱形虚拟继承的原理🍃对比 🍂缺陷与不足 🍁多继承 在继承语法之后，C++之父本贾尼·斯特劳斯特卢普为了更好的去描绘事物的多样性，引出了多继承的概念：
多继承：一个子类有两个或以上直接父类时称这个继承关系为多继承 好比说一个事物有两面性或者说担任多个角色，例如：
圣女果 ：既可以是水果又可以是蔬菜
研究生：既可以是老师又可以是学生
间谍：对于敌国是特务坏人，对于本国的是军官好人
实现多继承的方法即是在派生类的继承子类语法处，以逗号分隔再添不同加子类 举例：
class A { protected: size_t _a; }; class B { protected: size_t _b; }; class C : public A, public B //派生类C继承多个子类 { protected: size_t _c; }; 注意：派生类在调用构造函数时，默认调用基类的构造函数时的顺序，不是按照派生类构造函数的初始化列表进行的调用，而是看派生类在继承基类时排名先后顺序
好比上面例子：class C : public A, public B
C的构造函数在调用基类构造函数时，先是调用A，再是调用B。
🍁菱形继承 多继承的构想往往是好的一面，但是也让C++多继承语法带来很大的不便，甚至一度人让使用者抓耳挠腮。
为什么这样说呢？我们往下看。
上面提到的研究生为例子，研究生即是担任学生又是老师角色，但最终都是离不开人这个设定。
若是此时学生类和老师类同时继承同一个Person这个基类，那么就会造成以下这样的情况：
如上情况就犹如闭环的菱形，也就是所谓的菱形继承 (多继承的一种情况)：
class Person { public : string _name; }; class Student : public Person //继承Person { protected : int _num ; //学号 }; class Teacher : public Person //继承Person { protected : int _id ; // 职工编号 }; class Assistant : public Student, public Teacher //继承多个子类 { protected : string _majorCourse ; // 主修课程 }; 🍂 菱形继承造成的数据冗余 如上举例的，研究生即可以是担任老师，也可以是担任学生；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6edbcdb7c2719c9717eb10ac75e3ccc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acd1800a9113a10d968db7890c9240e5/" rel="bookmark">
			Tomcat启动！ 一文带你知道什么是Tomcat以及如何安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： Tomcat（全称为Apache Tomcat）是一个开源的Java Servlet容器，也是JavaServer Pages（JSP）的引擎。它是Apache软件基金会的一个项目，用于使Java应用能够在Web服务器上运行。Tomcat充当Web服务器和Servlet容器的角色，它可以运行在独立模式（独立的HTTP服务器）或者和其他Web服务器（如Apache HTTP服务器）进行集成使用。
目录
前言：
Tomcat介绍：
Tomcat的优点：
如何下载Tomcat：
如何向Tomcat中部署代码？
总结：
Tomcat介绍： Tomcat（全称为Apache Tomcat）是一个开源的Java Servlet容器，也是JavaServer Pages（JSP）的引擎。它是Apache软件基金会的一个项目，旨在提供一个可靠和高效的Web应用服务器环境。
Tomcat的主要功能包括：
Servlet容器：Tomcat充当Servlet容器的角色，负责处理HTTP请求和响应，以及管理Servlet的生命周期。它遵循Java Servlet规范，并提供了丰富的API供开发人员使用。
JSP引擎：Tomcat还包含了JSP引擎，可以解析和执行JSP页面。JSP是一种动态网页技术，允许将Java代码嵌入到HTML页面中，使得生成动态内容变得更加简单和灵活。
静态文件服务：除了处理Servlet和JSP请求，Tomcat还可以作为一个简单的HTTP服务器，提供静态文件服务。这对于展示静态网页、图片、CSS和JavaScript文件等非动态内容非常有用。
连接池管理：Tomcat具有连接池管理功能，可以有效地管理数据库连接、消息队列连接等资源，提高应用程序的性能和响应速度。
安全性支持：Tomcat提供了一套强大的安全机制，包括SSL/TLS加密、基于角色的访问控制、用户认证等，确保Web应用的安全性和保密性。
其他功能扩展：Tomcat支持许多其他功能扩展，如支持WebSocket协议、反向代理配置、负载均衡等，以满足更复杂的应用需求。
总的来说，Tomcat是一个用于部署和运行Java Web应用的轻量级、灵活和可扩展的服务器。它被广泛应用于Java开发领域，为开发人员提供了强大的工具和环境，使得开发和部署Web应用变得更加便捷和高效。
Tomcat的优点： 易于使用和部署：Tomcat非常易于安装和配置，可以迅速搭建一个可用的Web服务器环境。它提供了简单的命令行工具和可视化界面，方便管理和监控。
轻量级和高度可移植：Tomcat是一个轻量级的服务器，占用较少的系统资源。它可以在多种操作系统上运行，包括Windows、Linux、Mac等，具有很强的可移植性。
支持标准规范：Tomcat遵循Java Servlet和JavaServer Pages（JSP）等JavaEE标准规范，因此与其他服务器兼容性良好。它提供了丰富的API和功能，方便开发人员进行程序开发。
可扩展性和灵活性：Tomcat提供了许多功能扩展和插件，如连接池、反向代理、负载均衡等，可以根据需求进行灵活配置和扩展。
整合性和生态系统：Tomcat与其他开源项目和技术（如Spring、Hibernate等）的整合性良好，可以轻松集成和使用。此外，Tomcat拥有活跃的社区和广泛的用户群体，为用户提供了丰富的资源和支持。
安全性和稳定性：Tomcat提供了多种安全机制，包括SSL加密、角色基础的访问控制和用户认证等，确保Web应用的安全性。它经过了长时间的发展和测试，具有较高的稳定性和可靠性。
总的来说，Tomcat作为一个成熟的Java Web应用服务器，具有简单易用、轻量级、高度可移植、可扩展、安全稳定等诸多优点，适合各种规模的Web应用开发和部署。
如何下载Tomcat： 需要注意的是这里只是额外的知识介绍，Spingboot中已经内置了Tomcat，我们不需要再额外安装
我们直接访问Tomcat的官网 ：阿帕奇雄猫® - 欢迎！ (apache.org)就可以直接进行下载，找到一个自己需要的版本进行下载就可以了。
并且Tomcat和我们的Maven一样，下载下来是一个压缩包，我们对这个压缩包进行解压之后，放到一个没有汉字和空格的文件夹中就可以了。 删除也是一样的，只需要直接删除掉这个解压缩文件就可以了。
此时我们就可以得到这个一个文件目录
在bin文件夹中，我们可以找到这两个bar文件；
在这里很多人可能会出现闪退的情况，出现闪退大部分就两种可能性
1.未配置JAVA_HOME,Tomcat在运行的时候是需要这个环境变量的，如果没有配置，就会闪退。
2.8080端口被占用，我们需要打开控制端口的页面，关闭掉占用端口号的进程就可以了。
当我们第一次进入Tomcat的时候，会发现此时全是乱码，这是因为编码解码方式不同所造成的，tomcat的编码是UTF-8，但是我们在解码的时候使用的是GBK，因此会造成错误，我们只需要在conf中的logging.properties中对编码方式进行修改就可以了
把这里的UTF-8更改为GBK就可以了，然后我们再打开tomcat就可以得到正确的界面
此时我们可以看到tomcat占用的端口号是8080，那么我们在浏览器访问localhost：8080，就可以看到Tomcat的欢迎界面：
如何向Tomcat中部署代码？ 其实很简单，我们只需要把需要部署的代码打包成文件，放到webapps文件中就可以了。
总结： 在本文中，我们介绍了Tomcat作为一个开源的Java Servlet容器和JSP引擎的重要性，以及如何安装和启动Tomcat。
首先，我们了解了Tomcat的基本概念和功能。Tomcat作为一个可靠和高效的Web应用服务器环境，支持Java Servlet和JSP等标准规范，提供了丰富的API供开发人员使用。它还具有连接池管理、安全性支持和静态文件服务等功能，以满足不同的应用需求。
接下来，我们介绍了安装和启动Tomcat的步骤。首先，我们需要下载和安装适合自己操作系统的Tomcat版本，并进行简单的配置。然后，通过命令行或控制台进入Tomcat安装目录，并使用启动命令来启动Tomcat服务器。最后，我们可以通过Web浏览器访问Tomcat的管理界面，进行进一步的配置和管理。
总的来说，Tomcat作为一个轻量级、灵活和可扩展的服务器，具有简单易用、可移植性强、与标准规范兼容、安全稳定等诸多优点。通过本文所提供的安装和启动指南，您应该能够快速上手和使用Tomcat，并享受其强大的功能和性能。
如果我的内容对你有帮助，请点赞，评论，收藏。创作不易，大家的支持就是我坚持下去的动力！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/658ee189fb903cdaf11671c8e175d0aa/" rel="bookmark">
			Spring Boot自动装配原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是自动装配?
自动装配是如何实现的?
自己写一个可以被Spring Boot自动装配的依赖
什么是自动装配? 我们可以先看一段代码
@RestController public class RedisContorller { @Autowired RedisTemplate&lt;String, String&gt; redisTemplate; @GetMapping("/get") public String getName() { return redisTemplate.opsForValue().get("name"); } } 我们明明没有注册RedisTemplate这个bean，那么我们是怎么从spring容器里拿到的呢
这就是Spring Boot的自动装配，只要我们加入spring-boot-starter-data-redis依赖，就会自动的把RedisTemplate 放到spring容器里。
自动装配是如何实现的? 其实很简单，只需要第三方组件告诉Spring Boot你的Configuration所在的地方
Spring Boot的启动类上有个注解@SpringBootApplication
@SpringBootApplication又是由三个注解组成
@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan *如果不清楚Spring注册bean的几种方式应该先了解一下 Import注册bean的三种方式 这很重要
@SpringBootConfiguration其实就是@Configuration
大家都知道@ComponentScan + @Configuration是注册bean的一种方式，他会扫描@Component@Service等等的注解并把他们注册成bean
@EnableAutoConfiguration 又是由@Import(AutoConfigurationImportSelector.class)注解组成，而 @Configuration + @Import也是注册bean的方式，AutoConfigurationImportSelector实现ImportSelector类，所以我们只要把第三方组件的配置类的全类名放到AutoConfigurationImportSelector里，就可以注册第三方组件的配置类的bean了，也就相当自动装配
第三方组件的配置类就是加了@Configuration注解的，它可以通过@Configuration 把自己的bean注册到spring里. 所以Spring Boot制定了一个规则，就是第三方组件的classpath：META-INF有一个spring.factories文件，文件里是配置类的全类名，所以Spring Boot只要扫描META-INF/spring.factories就可以加载到第三方组件的配置类了
下图是Mybatis整合Spring Boot的jar包 ，它的里面就有这个spring.factories文件
spring.factories文件里面的内容 KV的结构
# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration
要注意的是 spring-boot-starter-data-redis是Spring Boot提供的官方的包，所以没有spring.factories 文件，它是由条件判断触发的装配。
条件触发装配有两种方式
@ConditionalOnClass 相当于@ConditionalMETA-INF/spring-autoconfigure-metadata.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/658ee189fb903cdaf11671c8e175d0aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd037553e142a94d63e7e7805e2ae051/" rel="bookmark">
			对称方式生成正弦波数据（execl）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整体的推导过程可以看该文章
SPWM基本原理详解（图文并茂+公式推导+C程序实现）_小麦大叔的博客-CSDN博客
下面讲讲具体用execl表格计算的方式
调制参数为：M
中值设置： N
幅值设置为：Y
周内点数：L
K 生成数据的序号
对称规则的计算公式 N+M*Y*Sin(π/(L/2))*K
设置的 M为1 N为1000 Y1000 L 400 生成数据的公式如下：
得到的波形
波形又中值都为1000 ，幅值有900,800 的计算
在execl中显示波形的方法：
先选择数据-&gt;插入-&gt;插入散点图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a91a026e73a6095f57412bbf54e0ba0/" rel="bookmark">
			Laravel 模型的关联写入&amp;多对多的关联写入 ⑩③
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@作者 : SYFStrive
@博客首页 : HomePage
📜： THINK PHP
📌：个人社区（欢迎大佬们加入） 👉：社区链接🔗
📌：觉得文章不错可以点点关注 👉：专栏连接🔗
👉 VUEJS（🔥） 👉 MYSQL（🔥） 👉 微信小程序（🔥） 👉 PHPMYSQL（🔥） 👉 UNIAPP开发（🔥） 目录 PHP LARAVEL 简介PHP LARAVEL 模型的关联写入 关联写入PHP LARAVEL 多对多的关联写入 关联写入最后 ⡖⠒⠒⠒⠤⢄⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸ ⠀⠀⠀⡼⠀⠀⠀⠀ ⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢶⣲⡴⣗⣲⡦⢤⡏⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠋⠉⠉⠓⠛⠿⢷⣶⣦⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠘⡇⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡞⠀⠀⠀⠀⠀⠀⠀⢰⠇⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⡴⠊⠉⠳⡄⠀⢀⣀⣀⡀⠀⣸⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⢸⠃⠀⠰⠆⣿⡞⠉⠀⠀⠉⠲⡏⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠈⢧⡀⣀⡴⠛⡇⠀⠈⠃⠀⠀⡗⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣱⠃⡴⠙⠢⠤⣀⠤⡾⠁⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⢀⡇⣇⡼⠁⠀⠀⠀⠀⢰⠃⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⣸⢠⣉⣀⡴⠙⠀⠀⠀⣼⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⡏⠀⠈⠁⠀⠀⠀⠀⢀⡇⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⢸⠃⠀⠀⠀⠀⠀⠀⠀⡼⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⣰⠃⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⣀⠤⠚⣶⡀⢠⠄⡰⠃⣠⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⢀⣠⠔⣋⣷⣠⡞⠀⠉⠙⠛⠋⢩⡀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀ ⠀⡏⢴⠋⠁⠀⣸⠁⠀⠀⠀⠀⠀ ⠀⣹⢦⣶⡛⠳⣄⠀⠀⠀⠀⠀ ⠀⠙⣌⠳⣄⠀⡇ 不能 ⡏⠀⠀ ⠈⠳⡌⣦⠀⠀⠀⠀ ⠀⠀⠈⢳⣈⣻⡇ 白嫖 ⢰⣇⣀⡠⠴⢊⡡⠋⠀⠀⠀⠀ ⠀⠀⠀⠀⠳⢿⡇⠀⠀⠀⠀⠀⠀⢸⣻⣶⡶⠊⠁⠀⠀ ⠀⠀⠀⠀⠀⢠⠟⠙⠓⠒⠒⠒⠒⢾⡛⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⣠⠏⠀⣸⠏⠉⠉⠳⣄⠀⠙⢆⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⡰⠃⠀⡴⠃⠀⠀⠀⠀⠈⢦⡀⠈⠳⡄⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⣸⠳⣤⠎⠀⠀⠀⠀⠀⠀⠀⠀⠙⢄⡤⢯⡀⠀⠀⠀⠀⠀⠀ ⠀⠐⡇⠸⡅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⡆⢳⠀⠀⠀⠀⠀⠀ ⠀⠀⠹⡄⠹⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣇⠸⡆⠀⠀⠀⠀⠀ ⠀⠀⠀⠹⡄⢳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡀⣧⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⢹⡤⠳⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣷⠚⣆⠀⠀⠀⠀ ⠀⠀⠀⡠⠊⠉⠉⢹⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡎⠉⠀⠙⢦⡀⠀ ⠀⠀⠾⠤⠤⠶⠒⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠒⠲⠤⠽ 提示：以下是本篇文章正文内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a91a026e73a6095f57412bbf54e0ba0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a384835e78ebfa688497393fe423e9fd/" rel="bookmark">
			07 Linux补充｜秋招刷题｜9月6日
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Linux
结构体内存字节对齐
静态变量static
空指针
Linux 结构体内存字节对齐 结构体内存字节要对⻬：
32位系统：4 8 32；64位系统：8 16 24
字节对⻬：字节对⻬是指在计算机中，各种类型数据按照⼀定的规则在空间上排列，以满⾜硬件平台对存储空间的处理要求。
静态变量static （1）在修饰变量的时候，static 修饰的静态局部变量只执⾏初始化⼀次，⽽且延⻓了局部变量的⽣命周期，直到程序运⾏结束以后才释放。
（2）static 修饰全局变量的时候，这个全局变量只能在本⽂件中访问，不能在其它⽂件中访问，即便是 extern 外部声明也不可以。
（3）static 修饰⼀个函数，则这个函数的只能在本⽂件中调⽤，不能被其他⽂件调⽤。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候⾃动初始化为 0。
（4）不想被释放的时候，可以使⽤static修饰。⽐如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调⽤结束释放可以使⽤ static 修饰。
（5）考虑到数据安全性（当程序想要使⽤全局变量的时候应该先考虑使⽤ static）。
栈区：先⼊后出（FILO）⾃动分配释放
队列：先⼊先出
malloc⽤法：开辟空间
free()：释放malloc开辟的空间
动态分配内存原则：
（1）谁建⽴，谁释放；
（2）在程序设计时，应当预留⾜够的内存空间以避免频繁地进⾏内存分配和释放。
dmesg | tail 该命令会输出系统日志的最后10行
cat /proc/cpuinfo 显示CPU info的信息
cat /proc/interrupts 显示中断
cat /proc/meminfo 校验内存使用
cat /proc/swaps 显示哪些swap被使用
cat /proc/version 显示内核的版本
cat /proc/net/dev 显示网络适配器及统计
cat /proc/mounts 显示已加载的文件系统
clock -w 将时间修改保存到 BIOS
Linux系统下文件的是：目录文件、普通文件、设备文件
用“rm -i ”系统会提示“是否真的删除”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a384835e78ebfa688497393fe423e9fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dbda26f8df440c2cfba605fec492043/" rel="bookmark">
			启动 Tomcat 遇到 Neither the JAVA_HOME nor the JRE_HOME environment variable is defined 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在命令提示符中输入startup后，出现Neither the JAVA_HOME nor the JRE_HOME environment variable is defined，可能是未安装jdk或未配置jdk的环境变量。
Neither the JAVA_HOME nor the JRE_HOME environment variable is defined既没有定义JAVA_HOME，也没有定义JRE_HOME环境变量，运行此程序至少需要这些环境变量中的一个。 解决方法：下载jdk
jdk官网：Java Downloads | Oracle --- 爪哇下载 |神谕
配置jdk环境变量
变量名：JAVA_HOME
变量值：jdk的安装目录
有疑问请留言
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c07f39f84678bcdc15903dd155ad5c4/" rel="bookmark">
			mysql之DML的select分组排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、创建表employee和department表
1.创建department表
2.创建employee表
3.给employee表格和department表格建立外键
4.给department插入数据
5.给employee表插入数据
6.删除名字为那个的数据
二、分组查询和排序查询，以及对数据的处理（avg,sum,count,max,min）
1.根据dept_id进行分组并查询他们的平均工资
2.根据dept_id分组查询他们年薪平均值
3.根据dept_id分组查询他们薪资的最高值
4.根据dept_id分组查询他们薪资的最低值
5.根据dept_id分组查询他们薪资的总和
6.根据dept_id分组查询人数的总和
7.根据dept_id分组查询人数的总和
8.按照dept_id降序的方式查询emp_name和dept_id
9.按照dept_id和emp_job分组查询薪资总和
10.在dept_id组中限制只查询工资总和大于10000的薪资，并展现出来工作和薪资
四、select查询之limit限制
1.查询前三行数据
2.查询第三条到第七条数据
一、创建表employee和department表 1.创建department表 create table department(
-&gt; depart_id int primary key auto_increment comment '部门编号',
-&gt; depart_name varchar(50) not null comment '部门名称'
-&gt; ) auto_increment=1001;
2.创建employee表 create table employee( n for the right syntax to use near 'redsodsnvjnv' at line 1
-&gt; emp_num int primary key auto_increment comment '员工编号',
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c07f39f84678bcdc15903dd155ad5c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60c6d207686b177b4efe32ae2a63c4d5/" rel="bookmark">
			Gitlab常用命令总结汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gitlab常用命令 本地
初始化
全局变量 全局配置 git config --global user.name "your name" #设置全局用户名#git config --global uer.email "your email" #设置全局邮箱#版本库配置 git config --global color.ui true #让Gitlab显示不同的颜色#git config core.ignorecase true #让 Git 对仓库中的字符大小写敏感#​ 查看所有的已设置的配置 git config -l设置默认编辑器 git config --global core.editor notepad++ #设置notepad++为编辑器#解决中文乱码问题 ls命令显示中文文件名乱码 在git/git-completion.bash中增加一行 alias ls='ls --show-control-chars --color=auto'git commit不能提交中文注释 修改git/inputrc中对应的行 set output-meta onset convert-meta off查看git log，如果乱码 LESSCHARSET=utf-8设置 commit log 提交时使用 utf-8 编码，可避免服务器上乱码，同时与linux上的提交保持一致 git config --global i18n.commitencoding utf-8git config --global i18n.logoutputencoding utf-8初始化版本库 git init设置忽略的文件 设置每个人都想要忽略的文件 在根目录建一个名为.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60c6d207686b177b4efe32ae2a63c4d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9f329d130ad5dae96079705595ce68c/" rel="bookmark">
			LCD驱动理论与实例分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、基础篇1、LCD 基础知识分辨率像素格式LCD屏幕接口LCD 时间参数LCD屏幕时序* 时钟像素显存 2、eLCDIF 接口LCDIF_CTRL 寄存器LCDIF_CTRL1 寄存器寄存器 LCDIF_TRANSFER_COUNTLCDIF_VDCTRL0 寄存器LCDIF_VDCTRL1 寄存器LCDIF_VDCTRL2 寄存器LCDIF_VDCTRL4 寄存器LCDIF_CUR_BUF 和 LCDIF_NEXT_BUF 寄存器 3、LCD 裸机开发流程硬件原理分析程序编写lcd.hlcd.clcdAPI.hlcdAPI.c 二、驱动篇* FramebufferLCD 驱动简析proc 函数如何驱动一块 LCD？LCD 屏幕 IO 配置LCD 屏幕参数节点信息修改LCD 背光节点信息 LCD 屏幕基本测试 三、实例篇：驱动 RK3568 mipi 接口LCDCSI 和 DSI 的区别* 设备树配置panel-init-sequencedisplay-timingsportspwmft5x06 配置 CONFIG检查电压 前言 基础篇和驱动篇使用 I.MX6U-ALPHA 开发板。
实例篇使用 RK3568 开发板和 mipi LCD 模块。
一、基础篇 1、LCD 基础知识 分辨率 1080P：LCD 屏幕上的像素数量是
19201080 个，屏幕一列 1080 个像素点，一共 1920 列。
而像素点就是一个 RGB 灯，也就是由 R(红色)、G(绿色)和 B(蓝色)这三
种颜色组成的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9f329d130ad5dae96079705595ce68c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/052ca45ba9a8b39f3141f09184047548/" rel="bookmark">
			Stable Diffusion — ControlNet 超详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stable Diffusion — ControlNet 超详细讲解 ControlNet 最近非常火🔥！ControlNet 和 Stable Diffusion 的结合使 Stable Diffusion 能够接受指导图像生成过程的条件输入，从而增强了 Stable Diffusion 的性能。今天为大家深入剖析 ControlNet 的工作原理。
文章目录 什么是 ControlNet内部架构前馈反向传播 与 Stable Diffusion 相结合编码器整体架构 训练输入条件总结 什么是 ControlNet ControlNet 是一个控制预训练图像扩散模型（例如 Stable Diffusion）的神经网络。它允许输入调节图像，然后使用该调节图像来操控图像生成。
这里的调节图像类型众多，例如涂鸦、边缘图、姿势关键点、深度图、分割图、法线图等，这些输入都可以作为条件输入来指导生成图像的内容。 下面是一些例子：
图片来源：https://github.com/lllyasviel/ControlNet 内部架构 图1. ControlNet 内部架构 Stable Diffusion (UNet) 中的所有参数都被锁定并克隆到 ControlNet 端的可训练副本中。然后使用外部条件向量训练该副本。
创建原始权重的副本而不是直接训练原始权重是为了防止数据集较小时出现过拟合，并保持已经训练好的大模型的高质量，这些大模型在数十亿图像上训练得到，并可以直接部署到生产环境使用。
前馈 图2. ControlNet 前馈部分 解释一下上图公式和符号：
x , y x, y x,y：神经网络中的深层特征 c c c：额外条件 + + + : 特征相加 Z ( ⋅ ; ⋅ ) \mathcal{Z}(\cdot\;;\;\cdot) Z(⋅;⋅)：零卷积运算（权重和偏差都用零初始化的 1 x 1 卷积层） F ( ⋅ ; ⋅ ) \mathcal{F}(\cdot\;;\;\cdot) F(⋅;⋅)：神经网络块操作（例如 “resnet” 块、“conv-bn-relu” 块等） Θ z 1 \Theta_{z1} Θz1​：第一个零卷积层的参数 Θ z 2 \Theta_{z2} Θz2​：第二个零卷积层的参数 Θ c \Theta_c Θc​：可训练副本的参数 第一步训练
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/052ca45ba9a8b39f3141f09184047548/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55ac210326bb6ce121a84b132aaa6a77/" rel="bookmark">
			数据权限处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据权限就该这么实现（设计篇）_java数据权限实现方案_Java技术攻略的博客-CSDN博客
添加数据规则表和数据规则组表，role表中再加上数据规则组ids的字符串字段，多个数据规则组用逗号隔开，编写代码时，在mapper层上加自定义的权限注解，标识需要对sql进行数据权限处理，即添加数据规则，注解中加上一个属性，表示你这个mapper的sql语句需要用哪个规则组来改造sql语句。（废弃）
通用版：使用注解，AOP中截取注解，并将权限sql放在threadlocal中，mybatis拦截器中再去具体实现权限sql，从而放到对应的业务sql中使用
优点：简单，当部门的层级结构不是很多的时候用他比较合适
缺点：当层级机构很多时，这种方式是要获取当前层级及其底下的所有的部门id的，所以如果层级很多，那么最终业务sql中的in (xx,xxx)数据就会很多
进阶版：和通用版差不多，首先将用户的层级结构缓存起来/xxx/xxx/xxx，然后将此层级缓存到threadlocal中，threadlocal中应该是{alias}.{fieldName} like concat ('/xxx/xxx/xxx', '%')
在mybatis拦截器中再根据注解将{alias}.{fieldName}换成具体的值。
优点：数据量比较大时也不用害怕sql文本会比较大
缺点：对应的业务表需要要对应的字段来表示哪一层(xx/xx)的权限可以查看当前这条数据。
es简单数据权限处理:
https://blog.csdn.net/u011487470/article/details/125275455
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c627c0b53f2a8f9c6a01a9abc6b1f42d/" rel="bookmark">
			测试远程mysql数据库连接的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数据库连接测试安装常用工具测试本地主机与远程数据库服务器网络连接情况连接远程mysql数据库方法一：使用命令telnet、openssl和mysql client连接示例：telnet示例：openssl示例：mysql clinent备注：示例openssl返回日志解释 方法二：使用脚本测试 数据库连接测试 设定本地主机A:
IP：192.168.2.63
​ 系统CentOs7
​ 使用工具：telnet、openssl、mysql client等
远程mysql数据库服务器B： ​ IP地址192.168.1.10，
​ 用户名：myname，
​ 密码：mypassword，
​ 数据库名称：mydate。
影响远程数据库连接的因素还是比较多的，数据库服务器的一些配置、用户权限、网络连通、防火墙等。
本文主要介绍对本地网络连接情况排查和在网络连通的情况下怎么进行连接测试。
安装常用工具 大概会使用到ping、netstat、ifconfig、route、curl、traceroute、opensll和mysql client等工具，如果你不确定你用的centos7是否已经有这些工具，没关系，重新安装一次就行。
重新安装，会把已有的工具版本更新至最新版本，执行如下命令：
yum update yum install -y ping net-tools curl traceroute yum install -y openssl yum install mysql-client 测试本地主机与远程数据库服务器网络连接情况 一般来说，我们不需要把所有涉及的网络工具都拿来用一遍，网络连接的测试要根据故障的实际情况逐步的排查：
使用ping命令简单测试连通情况 ​ 用法：ping ip地址
示例：
#- mysql数据库服务器B的IP地址192.168.1.10，使用如下命令即可 ping 192.168.1.10 ​ 如果返回“未发现主机”或“time out"等信息提示，一般就是网络配置，或连接线路有问题：
检查网络配置文件，是否正确配置本地IP地址和网关IP地址：
网络配置文件位置：/etc/sysconfig/network-scripts/
如果本地主机有多个网卡，则此文件夹中会有多个配置文件，你需要确定当前使用的网卡名称，才能查看对应的配置文件。
使用如下命令，查看活动网卡：
# ifconfig命令：该命令用于查看和配置网络接口信息，包括IP地址、子网掩码等。 # ifconfig eno1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c627c0b53f2a8f9c6a01a9abc6b1f42d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ce45b03f9dbf699df94251cec038620/" rel="bookmark">
			【一文搞懂】—带霍尔编码器的直流有刷减速电机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、直流有刷电机二、减速比三、霍尔编码器3.1 霍尔编码器3.2 霍尔编码器测速原理 四、测速程序设计4.1 跳变沿检测4.2 计算转速 一、直流有刷电机 宏观上说直流有刷电机由固定部分（定子）和旋转部分（转子）组成。在定子上装有两个励磁的磁极N和S。在其转子部分有电枢铁芯。电枢铁芯上有绕组线圈，线圈的首尾接有两个圆弧形铜片，称为换向片。两个换向片之间互相绝缘。换向片固定在转轴上，换向片与转轴之间也相互绝缘。换向器上固定着一对电刷，电刷与换向器互相接触。绕组线圈通过换向片和电刷与电源连接。下面是直流有刷电机的结构图。
电机是怎么转起来的呢？
这时候就要搬出我们高中所学的物理知识了，因为电机能转起来，离不开一个力——安培力。
首先复习一下安培力，主要是知道什么是安培力以及如何判断安培力的方向。通电导线在磁场中受到的作用力叫做安培力。判断安培力的方向我们用到左右定则，什么是左手定则？伸开左手，使拇指与其他四指垂直且在一个平面内，让磁感线从手心流入，四指指向电流方向，大拇指指向的就是安培力方向（即导体受力方向）。
有的资料上可能说是洛伦兹力，磁场对运动电荷的作用力称为洛伦兹力，安培力是洛伦兹力的宏观表现。
了解了上面的知识，我们开始正式探讨电机是怎么转起来的。
看上面的电机结构图，如果外部电源上正下负接到电刷两边，那么绕组线圈中的电流方向为顺时针，我们来对绕组线圈做一个受力分析。
电流方向垂直于磁场方向的部分是不受安培力作用的，也就是上图的蓝色部分。上图的红色部分中我们用左手定则分析一下受力。根据左手定则，上半部分受到垂直屏幕向内的安培力。下半部分受到垂直屏幕向外的安培力。上下两部分受力相反，这时电机就转起来了。同理，如果改变外部电源的接入方向，改成上负下正，上下两部分受力依旧相反，电机依旧可以转动，只不过转动方向相反。
至此，我们了解了直流有刷电机的转动原理以及如何控制正反转。
二、减速比 首先回答一个问题，为什么要有减速电机？
用简单几个字总结一下，为什么会有减速电机？目的是降低转速，增加扭矩。至于到底是怎么降低转速，增加扭矩，我们继续往后看。
什么是减速比？
用到减速电机我们难免会碰到一个概念——减速比。那么什么叫减速比？首先我们先看一下减速电机内部的结构。
减速电机内部有两个齿轮，一个是转子连接轴上的齿轮，一个是输出主轴上的齿轮。转子转动N圈，主轴转动一圈，这就实现了降低转速。比如我们常见的1:30减速比的减速电机，就是转子转动30圈，主轴转动一圈。如此一来，就实现了降低转速，增加扭矩的目的。减速比就是小齿轮数比大齿轮数的比值。
扭矩实际可以理解为电机转动的力量。如果我们不使用减速电机，拿一个小马达，我们会发现它转的很快，但是很容易用手捏住制动，力量很小。但是如果是减速电机，我们发现转速比较慢，但是我们需要用比制动小马达更大的力来制动。减速比越大，电机转动的力越大。
举一个更加常见的例子，比如我们的山地车。我们上坡时可以调节变速器，让我们用很轻松的力就能上坡，实际就是上面的原理，我们蹬好多圈，车轮才能转一圈，但是我们用的力小了，如果把我们和变速器看作一个电机，实际也就是扭矩大了。
三、霍尔编码器 3.1 霍尔编码器 什么是编码器？
编码器是把角位移或直线位移转换成电信号的一种装置。
编码器按照工作原理，可以分为增量式编码器和绝对式编码器，绝对式编码器的每一个位置对应一个确定的数字码（二进制数）。增量式编码器就是每转过单位的角度就发出一个脉冲信号。
从编码器检测原理上来分，还可以分为光学式、磁式、感应式、电容式。我们常见的是光电编码器（光学式）和我们要介绍的主角霍尔编码器（磁式）。一般来说光电编码器是霍尔编码器精度的几十倍。
编码器的作用。
了解了什么是编码器，那么我们用编码器有什么实际作用呢？通常我们会使用编码器来检测电机的转速和旋转方向。那我们常用的控制算法PID算法来说，PID算法是为了实现闭环控制，要想实现闭环控制，就需要有一个反馈。我们的编码器测得的转速就可以作为反馈，搭配PID算法，实现转速的闭环控制。
霍尔编码器的工作原理。
其实从上面的介绍就能大概了解到编码器的工作原理。我们这次主要介绍对象是霍尔编码器。霍尔编码器由码盘和霍尔元件组成。霍尔码盘与电机主轴同轴，码盘上等分的分布有多个磁极，电机转动时，霍尔元件会输出若干个脉冲信号，我们正是利用这些脉冲信号实现电机的测速和电机转向的判断。
霍尔编码器的线数。
什么是霍尔编码器的线数？转动一圈我们会产生几个脉冲，取决于编码器的线数。比如我们的霍尔编码器线数为13。那么霍尔编码器的码盘旋转一圈，会产生13个脉冲。
3.2 霍尔编码器测速原理 我们正是通过检测霍尔编码器输出的脉冲信号来测速。通常会有三相输出，A、B和Z。A和B的输出是正交的。Z是用来标记旋转一周的起始位置，我们通常不使用。
如何判断电机转向？
我们通过A相出现脉冲时检测B相电平来判断电机旋转方向。
A检测到上升沿脉冲时，B为低电平，正转；A检测到上升沿脉冲时，B为高电平，反转； 如何判断电机转速？
我们通过检测单位时间内产生的脉冲数来确定电机转速。为什么可以这么做？因为电机转动一圈产生的脉冲数是确定的。比如我们有一个减速比为1:30的减速电机，霍尔编码器的线数为13。那么霍尔码盘旋转一圈，产生13个脉冲，霍尔码盘旋转30圈，电机主轴旋转一圈。综上所述，电机主轴旋转一圈会产生13 * 30 = 390个脉冲。注意，这里是只检测A相的上升沿脉冲，电机旋转一圈有390个脉冲。
有的小伙伴可能会疑问，是转一圈A和B一共产生390个脉冲，还是A和B都产生390个脉冲？答案是后者。
接下来我们只需要检测单位时间内A相或者B相输出的脉冲数，就可以计算电机转速了。
四倍频
什么是四倍频？由上面的介绍可知，霍尔编码器输出有A相和B相两条线。我们如果只用A相，检测高电平脉冲数，那么就是上面介绍的那种。如果我们A相和B相都检测，而且不止检测上升沿脉冲，也检测下降沿脉冲，那么此时霍尔码盘旋转一圈会产生四倍于之前的脉冲数。这就是所谓的四倍频。利用四倍频可以提高检测精度。
四、测速程序设计 上面介绍了这么多理论知识，下面我们动手来实现一下利用霍尔编码器，用一个1:30减速比的减速电机，来实现测速。
4.1 跳变沿检测 检测跳变沿可以用两种方法，一种是使用外部中断，另一种是使用定时器的输入捕获功能。这里使用的是外部中断，只检测A相输出的上升沿，因此只需要配置一个引脚的外部中断，来检测上升沿并在中断中进行计数即可。外部中断初始化函数与中断服务函数如下
/* *============================================================================== *函数名称：Exit_Init *函数功能：初始化外部中断 *输入参数：无 *返回值：无 *备 注：无 *============================================================================== */ void Exit_Init (void) { // 定义结构体 NVIC_InitTypeDef NVIC_InitStructure; EXTI_InitTypeDef EXTI_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; // 开启时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOE,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); // 开启AFIO时钟 GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource0); //选择GPIO管脚用作外部中断线路 // 配置GPIO结构体 GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ce45b03f9dbf699df94251cec038620/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c714d413b89a1da042b7cfb0348a255c/" rel="bookmark">
			FAST协议详解5 后记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这段时间，花了不少精力来学习FAST协议，大致梳理下，相关博文：
1、FAST协议解析1 通过输入输出逆解析
FAST协议解析1 通过输入输出逆解析_布兰姥爷的博客-CSDN博客
2、FAST协议解析2 FIX Fast Tutorial翻译【PMap、copy操作符】
FAST协议解析2 FIX Fast Tutorial翻译【PMap、copy操作符】_布兰姥爷的博客-CSDN博客
3、FAST协议解析3 FIX Fast Tutorial翻译 HelloWorld示例
FAST协议解析3 FIX Fast Tutorial翻译 HelloWorld示例_布兰姥爷的博客-CSDN博客
4、FAST协议详解1 不同数据类型的编码与解码
FAST协议详解1 不同数据类型的编码与解码_fast编码_布兰姥爷的博客-CSDN博客
5、FAST协议详解2 操作符
FAST协议详解2 操作符_布兰姥爷的博客-CSDN博客
6、FAST协议详解3 可null（空）类型
FAST协议详解3 可null（空）类型_布兰姥爷的博客-CSDN博客
7、FAST协议详解4 存在图PMap
https://blog.csdn.net/weixin_40402375/article/details/132712272
我自己感觉通过这几篇博文的撰写，基本研究清楚了FAST协议，自己手解了一下FAST数据，除了一些小细节外，大致都清楚了。感觉已神功小成。
下面列一下我觉得重要的参考资料，如有兴趣自己研究可以参考：
1、openfast接口文档，可以对照着openfast来理解FAST协议，如果要openfast的使用方法可以翻以前的博文
https://openfast.sourceforge.net/apidocs/
2、fast英文的教程，比较完整，感觉能说清楚一些内容和设定
https://jettekfix.com/education/fix-fast-tutorial/
3、FAST规范中文版，我感觉没啥用
https://www.renrendoc.com/paper/101528528.html
4、深入理解FAST协议，非常详细，但是有点深奥，入门的话看会有点难受
https://github.com/kuangtu/fixfast
研究过程中可能会用到的一些工具：
1、十六进制、中文互转
https://www.23bei.com/tool/54.html
2、二进制、负数转换
进制转换（负整数） - 在线工具
3、ASCII对照表
ASCII_百度百科
后记：研究FAST最大的困难是资料太少，真的是比头发都少，一开始我也是没啥信心的，后来是正巧找到了深入理解FAST协议，一开始也看不懂，后来对照着fast英文的教程，同时也使用openfast对照着弄，终于是入门了。学习就是这样，多花时间、多花精力，总是能搞明白的。感叹一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c66d86c122023ade3d68dd176d5589c3/" rel="bookmark">
			使用OpenCV进行图片分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用OpenCV进行图片分割 图片分割方法1. 阈值分割2. 边缘检测3. 分水岭算法 结论 图片分割是计算机视觉领域中的一个重要任务，它可以将图像分成不同的部分或对象。OpenCV是一个强大的计算机视觉库，提供了许多用于图片分割的工具和算法。在本篇博客中，我们将介绍如何使用OpenCV来进行图片分割，并探讨一些实际应用案例。
图片分割方法 OpenCV提供了多种图片分割方法，以下是一些常用的方法：
1. 阈值分割 阈值分割是一种简单而有效的分割方法，它将图像分成两个部分：前景和背景。通过选择一个适当的阈值，您可以实现二值分割。以下是一个示例代码：
import cv2 import numpy as np # 读取图像 image = cv2.imread('image.jpg', 0) # 应用阈值 ret, thresholded = cv2.threshold(image, 128, 255, cv2.THRESH_BINARY) # 显示结果 cv2.imshow('Thresholded Image', thresholded) cv2.waitKey(0) cv2.destroyAllWindows() 2. 边缘检测 边缘检测是另一种常见的图片分割方法，它可以帮助您找到图像中的边缘或轮廓。OpenCV提供了许多边缘检测算法，包括Canny边缘检测器：
import cv2 # 读取图像 image = cv2.imread('image.jpg', 0) # 使用Canny边缘检测器 edges = cv2.Canny(image, 100, 200) # 显示结果 cv2.imshow('Edge Detected Image', edges) cv2.waitKey(0) cv2.destroyAllWindows() 3. 分水岭算法 分水岭算法是一种用于图像分割的高级技术，它可以在复杂的图像中分离不同的对象。以下是一个简单的示例：由于分水岭算法是一种复杂的图像分割技术，需要仔细的参数调整和预处理步骤，以确保正确的分割结果。以下只做示例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c66d86c122023ade3d68dd176d5589c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/872575bc6d8148dfc977d0f5ab5b00e8/" rel="bookmark">
			ETA9742中文资料-4.2V开关式锂离子电池充电器 移动电源五合一芯片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品描述：
ETA9742是一款开关式理离子电池充电器能够为电池提供高达3A的充电电流，并能够在升压操作中提供高达5V/24A的电压在充电模式和升压模式下均具有高效率。它还包括一个用于功率指示的燃油表系统。用于充电。
它采用专有的控制方案，消除了传统恒流控制的电流检测电阻，最大限度地提高了效率，减少了充电时间，降低了成本。它还可以输出5V的电压，在相反的方向上从电池升压。它只需要一个单一的电感器来提供功率双一具有专有自动模式检测和切换方案。ETA9742是电池充放电应用的理想一体化解决方案，例如移动电源、智能手机和平板电脑，只有一个USB端口可用于电池充电功能。
ETA9742适用于4.2V理离子电池充电。和ETA9742采用ESOP8封装。
产品特点：
单电感双向功率变换
自动模式切换开关充电器
5V同步升压
效率高达96%最大充电电流和24A放电
无电池检测无外部检测电阻
LED用于电池液位指示和充电/放电状态指示
应用范围：
平板电脑
智能手机
移动电源
经典电路图：
封装脚位：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d07456f45fd47b31748539c1924c1f86/" rel="bookmark">
			百度飞浆OCR识别表格入门python实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 百度飞桨（PaddlePaddle） 百度飞桨（PaddlePaddle）是百度推出的一款深度学习平台，旨在为开发者提供强大的深度学习框架和工具。飞桨提供了包括OCR（光学字符识别）在内的多种功能，可以帮助开发者在各种应用中实现高效的文本识别。官网链接：https://www.paddlepaddle.org.cn/。
初次使用，安装：
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple paddlepaddle
验证安装，使用 python 进入 python 解释器，输入 import paddle ，再输入 paddle.utils.run_check()。
python
Python 3.8.10 (tags/v3.8.10:3d8993a, May 3 2021, 11:48:03) [MSC v.1928 64 bit (AMD64)] on win32
Type “help”, “copyright”, “credits” or “license” for more information.
import paddle
paddle.utils.run_check()
Running verify PaddlePaddle program …
I0904 17:11:21.570567 15712 interpretercore.cc:237] New Executor is Running.
I0904 17:11:21.702833 15712 interpreter_util.cc:518] Standalone Executor is Used.
PaddlePaddle works well on 1 CPU.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d07456f45fd47b31748539c1924c1f86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c23123a31dbb708dee307a1a7e57a3e/" rel="bookmark">
			拼多多虚拟变现项目：讲解开店流程实操选品上架自动发货
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新标题：《拼多多虚拟变现项目：开店流程详解，实操选品上架与自动发货技巧》
正文： 在如今虚拟变现的潮流中，拼多多虚拟变现项目成为越来越多人追求副业收入的热门选择。本文将详细介绍拼多多虚拟变现项目的开店流程，并分享实操选品上架与自动发货的技巧，帮助读者更好地参与这一项目，实现副业收入的增加。
首先，让我们了解拼多多虚拟变现项目的开店流程。第一步是注册成为一个拼多多商家。通过下载拼多多商家APP并完成注册，用户可以成为拼多多的认证商家，获得开展虚拟变现项目的资格。接下来，需要进行身份认证和店铺设置。按照平台要求，提供相关证件和个人信息进行身份认证，并根据自己的需求设置店铺名称、主营类目等基本信息。完成身份认证后，便可进入到选品上架的环节。
在进行选品上架时，有几个关键点需要注意。首先，选择热门的产品。通过市场调研和观察，选择当前热卖和受欢迎的产品，以确保有足够的需求和销售潜力。其次，注重产品质量和供应链。选择有良好口碑和正规渠道的供应商，确保产品的质量和供货的稳定性。另外，关注产品的赋能和差异化。考虑产品的特点和功能，与其他产品相比是否有竞争优势，是否能满足用户的需求和期待。
选品上架完毕后，我们可以利用拼多多平台提供的自动发货技巧来提高效率和顾客满意度。首先，建立良好的供应链合作关系。与供应商建立稳定的合作关系，并与其沟通好订单处理和发货流程，确保及时的供货和发货。其次，使用拼多多平台提供的自动发货工具。通过设置好运费模板、物流方式等参数，可以实现订单自动发货，提高发货速度和效率。此外，关注顾客的评价和反馈，及时解决问题和改进服务，提升用户的满意度和口碑。
在参与拼多多虚拟变现项目的过程中，还有一些值得注意的事项。首先，保持学习和了解市场动态。通过关注行业趋势、竞争对手的动态和用户的需求，及时调整自己的经营策略和选品方向。其次，注重店铺运营和推广。通过优化商品标题、图文描述、优惠活动等手段，提升店铺的曝光率和转化率。另外，建立良好的客户关系和沟通渠道。与顾客保持积极的互动和沟通，倾听他们的反馈和建议，以提供更好的服务和产品。
拼多多虚拟变现项目不仅可以带来副业收入的增加，还可以获得更多的商业经验和机会。通过参与这一项目，可以学习到市场调研、产品选品、供应链管理、客户服务等方面的知识和技能，为未来的创业或职业发展打下基础。同时，拼多多平台作为一个庞大的电商平台，拥有海量的用户和流量，为商家提供了广阔的市场和销售机会。
综上所述，拼多多虚拟变现项目是一个值得尝试的副业增收机会。通过深入了解开店流程和实操技巧，每个人都有机会在这一项目中取得成功。希望本文的指导能够为读者提供帮助和启发，祝愿大家在拼多多虚拟变现项目中实现自己的目标和收益！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/627ebc21abfaf6deecdf31e0ac63c161/" rel="bookmark">
			vue复制剪切板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 copymathml() { const textarea = document.createElement('textarea') textarea.value = this.ml // 将 &lt;textarea&gt; 添加到 DOM 中 document.body.appendChild(textarea) // 选择 &lt;textarea&gt; 中的文本 textarea.select() // 复制选中文本到剪贴板 document.execCommand('copy') // 从 DOM 中移除 &lt;textarea&gt; document.body.removeChild(textarea) this.$message({ message: '恭喜你，复制成功', type: 'success' }) }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/887170dd29d05ea447fe8afb8d9b79eb/" rel="bookmark">
			当在PyCharm控制台中遇到中文乱码问题时，如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法：
中文乱码问题通常源于编码设置不正确或控制台字体不支持中文字符集。以下是解决这个问题的一些步骤：
1. 更改编码设置 确保您的Python文件中的字符编码与您的控制台编码一致。在Python文件的开头，可以添加以下注释行，指定文件的编码格式：
# -*- coding: utf-8 -*- 这将确保Python正确地处理Unicode字符。
2. 更改PyCharm控制台编码 在PyCharm中，您可以更改控制台的编码设置。依次选择"File"（文件） &gt; “Settings”（设置） &gt; “Editor”（编辑器） &gt; “File Encodings”（文件编码），然后将"IDE Encoding"（IDE编码）和"Project Encoding"（项目编码）设置为"UTF-8"。
3. 更改字体 如果中文仍然显示乱码，可能是因为控制台使用的字体不支持中文字符。您可以尝试更改控制台的字体设置。在PyCharm中，依次选择"File"（文件） &gt; “Settings”（设置） &gt; “Editor”（编辑器） &gt; “Color Scheme”（颜色方案） &gt; “Console Font”（控制台字体），然后选择支持中文字符的字体。
4. 重启PyCharm 有时，更改设置后需要重新启动PyCharm才能生效。
以上这些步骤通常可以解决PyCharm控制台中文乱码的问题。
术语/函数解释/用法UTF-8Unicode字符编码标准字符编码确定文本文件中字符的存储方式IDE编码PyCharm集成开发环境的编码设置项目编码项目文件的字符编码设置控制台字体控制台中文字符显示的字体设置 如果这对您有所帮助，希望点赞支持一下作者！ 😊
点击查看原文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6186af3977176b08bba0025845bd10c/" rel="bookmark">
			无人机操作系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主流飞控的嵌入式实时内核依据软件架构、接口标准、兼容性等划分为两大类：类Unix如NuttX等，微内核类如FreeRTOS和uCOSii等。
实时主要是指具备高优先级任务抢占低优先级任务的能力，调度延迟以系统时钟量级来计。
类Unix、微核本质是调度器，由一些线性数据结构实现对任务线程的管理。而ROS本质是多进程Socket通信中间件。
类Unix操作系统
PC端Unix操作系统启动之后呈现出进程树和文件系统树，进程树表达所有进程之间都具有亲缘关系，而文件系统树表达文件系统路径之间的挂载关系。
NuttX是类Unix嵌入式实时操作系统，因为处理器架构不同，又限于资源压力，相比于Linux，它对机制实现做了一些简化。NuttX支持8bit到64bit微处理器环境，支持POSIX/ANSI标准的任务控制、命名管道、计数信号量、信号、互斥量以及文件系统等机制，下面是NuttX架构图
NuttX支持用户线程和内核线程，而不具有Linux意义下的进程概念。取而代之的是NuttX线程组，包括一个主任务线程和由主线程创建的pthreads，线程组线程彼此共享资源如环境变量、文件描述符、文件流、sockets等。
NuttX上有task的概念，task是一种特殊的pthread，和pthread资源共享程度相比，task有一定独立度。对于线程/任务控制，NuttX提供了VxWorks与POSIX风格的API，实现最大程度兼容性。对于内核线程，他们相比于用户态有内核资源访问权限。
NuttX按照优先级调度，高优任务在阻塞之前独占CPU，同优先级任务按先来先调度顺序执行，NuttX任务或线程可以通过选项配置round-robin或sporadic方式调度。
除了线程与任务之外，NuttX还有一种任务执行方案，work queue。
work queue是一系列需要执行的工作加入到队列中，由一些线程来消费执行。NuttX支持三种类型work queue：
（1）高优内核work queue
一般用于处理中断句柄中的延迟任务，也可用于驱动底层处理工作，因为这些任务通常是高优快速运行的；
（2）低优内核work queue
低优先级工作队列更适合于处理面向应用层的工作，比如文件系统清理，内存垃圾回收，异步IO操作等；
（3）用户模式work queue
面向应用层，但是访问内核资源需要系统调用增加开销，用户自行结合实际情况选取。
在任务同步、通信，资源互斥保护方面，NuttX支持命名管道，计数信号量，信号，共享内存等。父子关系的线程或任务之间可以用waitpid等同步，非父子关系可以用其他如命名管道等方式做同步，PX4中的uORB就是基于命名管道实现的，命名管道支持POSIX标准文件系统操作。
NuttX接口上对外暴露Open、Close、Read、Write、Ioctl以及Poll，如设备驱动，命名管道。
NuttX伪根文件系统是全内存的，其他或真实文件系统可以挂载到根下。
NuttX设备驱动包括字符设备驱动，如常见串口驱动，模数驱动，PWM驱动，CAN驱动，正交编码器，定时器驱动，RTC驱动，FOC（Field Oriented Control）控制交流电机驱动等。除了最常见的字符设备驱动之外，还有以块为单位读写访问的字符设备驱动以及一些特殊设备驱动：SYSLOG，RAM LOG等。PX4中传感器驱动是对字符设备的进一步开发，放在PX4-Autopilot\src\drivers路径中。
微内核
与类Unix相比，微核的调度、通信等机制都是独立实现，不遵守接口标准，因此更轻量。相比于裸机编程，使用微内核，业务被模块化,架构更清楚，开发者对调度和通信的实现无需过多关注。微内核代表产品包括FreeRTOS、uCOSii，以及国产RT-thread，以FreeRTOS为例介绍。
FreeRTOS支持消息队列，用于任务间通信，本质是一段对各个任务可见的共享内存。也支持二值信号量（或互斥信号量）做资源互斥保护以及多值信号量做同步。
对中断的响应和处理也是嵌入式编程需要关注的一个特性，在FreeRTOS中，中断事件可以与常规task进行通信和同步。此外，微核支持临界区来关闭调度和中断，临界区逻辑需要尽可能短小，以保证实时性。
内存管理方面，与NuttX一样，对于没有MMU的STM32F4处理器， TCB(Task Control Block)与各自的栈链表形式保存在扁平内存中。
对于类Unix和微核，没有明显程序运行效率上差别。
类Unix操作系统遵守协议标准，对Linux特性熟悉的可以很容易上手开发，同时可以使用KConfig剪裁配置系统功能；
微核优势在于轻量级，系统代码占用几K空间，比较受到国内MCU开发者青睐。
欢迎关注公众号“我想我思”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dee59cd45db648fb4b41507eef4a6499/" rel="bookmark">
			Typora使用技巧 | 各种跳转 【必备】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Typora 的Links各种跳转 相信大家在使用Typora的时候，想要实现各种链接跳转。比如点击 跳往百度 就会去访问百度。那如果是页面的跳转呢？比如标题的跳转，或者非标题的跳转(即页面任何位置)，那要怎么办呢？
📣第一种跳转：超链接跳转 [超链接描述文本](超链接 "可选的标题") 举个例子🌰:
[跳转百度](https://www.baidu.com/) [跳转到百度](https://www.baidu.com "这是百度") 在 Typora 渲染结果如下：
🏳️‍🌈跳转百度🏳️‍🌈（点击后即可跳转)
🏳️‍🌈跳转到百度🏳️‍🌈（点击后即可跳转，鼠标悬浮会有文本显示)
📣第二种跳转：参考链接 如果你不想使用 []() 的用法，这个时候就可以使用「参考链接」的用法
[Link Text][Ref] [Ref]: link-address "optional title" 举个例子🌰
[https://www.baidu.com "百度网址"][点击后就能跳转百度] [点击后就能跳转百度]: https://www.baidu.com	"标题可选" 在 Typora 渲染如下：
可以看到在语法中 [Ref] 起到参考作用
它的缩写形式是：
[Ref][] [Ref]: link-address 好处是当我们在多处地方使用这个 跳转链接时，都没必要复制一遍地址，而是根据 Ref 来使文本和链接连接起来
📣第三种跳转：本地文件的跳转 我们可以根据 「相对路径」或者 「绝对路径」 来完成 Markdown 文件跳转到另一个本地文件的作用。而这种链接跳转跟第一种「超链接跳转」是一样的。
// 跳到当前目录下的Readme1.md文件 [Readme1](Readme1.md) // 跳到当前目录下的Readme3文件夹 [Readme3](Readme3) // 相对路径跳到上级目录的某个文件 [Readme2](../Docs/Readme2.markdown) // 绝对路径跳转到C盘下的某个md文件 [Readme4](C:/Develop/Docs/Readme1.md) 注意⚠️⚠️ ：对于相对链接地址，当基于 Markdown 的规范导出为 HTML 时，它不会转换为真正的绝对文件路径
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dee59cd45db648fb4b41507eef4a6499/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f8cdebd0028113bbb908ccae168d714/" rel="bookmark">
			gtest单元测试框架介绍及简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gtest介绍 Gtest是Google的一个开源框架，它主要用于写单元测试，检查真自己的程序是否符合预期行为。可在多个平台上使用（包括Linux, Mac OS X, Windows, Cygwin和Symbian）。它提供了丰富的断言、致命和非致命失败判断，能进行值参数化测试、类型参数化测试、“死亡测试”。
下载安装 相关地址：
http://googletest.googlecode.com/files/gtest-1.3.0.zip
GitHub - google/googletest: GoogleTest - Google Testing and Mocking Framework
windows下推荐使用vcpkg工具下载安装，安装很简便。
默认下载安装的是32位的，若需要64位的则指定.\vcpkg.exe install gtest:x64-windows
.\vcpkg.exe install gtest 相关特性 一 .断言 一般的要测试一个方法（函数）是否是正常执行的，可以提供一些输入数据。在调用这个方法（函数）后得到输出数据，然后检查输出的数据是否与我们期望的结果是一致的。若一致则说明这个方法的逻辑是正确的，否则就有问题。
在对输出结果进行检查（check）时，Gtest为我提供了一系列的断言（assertion）来进行代码测试，这些宏有点类似于函数调用。当断言失败时Gtest将会打印出assertion时的源文件和出错行的位置以及附加的失败信息。这些输出的附加信息用户可以直接通过“&lt;&lt;”在这些断言宏后面。
Gtest中，断言的宏可以理解为分为两类，一类是ASSERT系列，一类是EXPECT系列。
ASSERT_系列的断言（Fatal assertion）：
当检查点失败时，退出当前函数（注意：并非退出当前案例）。
EXPECT_系列的断言(Nonfatal assertion)：
当检查点失败时，继续执行下一个检查点（每一个断言表示一个测试点）。
通常情况应该首选使用EXPECT_，因为ASSERT_*在报告完错误后不会进行清理工作，有可能导致内存泄露问题。
断言中提供以下几种检查方法:
布尔类型检查
二值检查
字符串检查
异常检查
浮点检查
相近值检查
二 .宏测试 TEST宏 TEST宏的第一个参数是test_suite_name（测试套件名），第二个参数是test_name（测试特例名）。
测试套件（Test Case）是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。
测试特例是测试套件下的一个（组）测试。
对于测试套件名和测试特例名，不能有下划线（_）。因为GTest源码中需要使用下划线把它们连接成一个独立的类名。不能有相同的“测试套件名和特例名”的组合——否则类名重合。
测试套件名和测试特例名的分开，使得我们编写的测试代码有着更加清晰的结构。
TEST_F宏 使用TEST_F前需要创建一个固件类，继承esting::Test类。
在类内部使用public或者protected描述其成员，为了保证实际执行的测试子类可以使用其成员变量。在构造函数或者继承于::testing::Test类中的SetUp方法中可以实现我们需要构造的数据。在析构函数或者继承于::testing::Test类中的TearDown方法中可以实现一些资源释放的代码。
第一个参数为测试套件名（必须与创建的固件类名一致），第二个为测试名，可任意取。
TEST_F宏和TEST宏的实现接近，只是TEST_F宏的封装更加开放一些，对TEST宏的功能多了一些扩展。
TEST_F与TEST的区别，TEST_F提供了一个初始化函数（SetUp）和一个清理函数(TearDown)。在TEST_F中使用的变量可以在初始化函数SetUp中初始化，在TearDown中销毁。所有的TEST_F是互相独立的，都是在初始化以后的状态开始运行。一个TEST_F不会影响另一个TEST_F所使用的数据，多个测试场景需要相同数据配置的情况用 TEST_F。
TEST_P宏 在设计测试案例时，经常需要考虑给被测函数传入不同的值的情况。我们之前的做法通常是写一个通用方法然后编写在测试案例调用它。即使使用了通用方法，这样的工作也是有很多重复性的。
用TEST这个宏，需要编写如下的测试案例，每输入一个值就需要写一个测试点，这还只是在一个测试中，如果把每个测试点单独创建一个测试，工作量就更大。使用TEST_P这个宏，对输入进行参数化，就简单很多。
预处理事件机制 gtest 提供了多种预处理事件机制，方便我们在测试之前或之后做一些操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f8cdebd0028113bbb908ccae168d714/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d205f1341d913b36db5d5f81bb24d14a/" rel="bookmark">
			MySQL为什么不建议使用DELETE 删除数据？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 存储引擎数据页索引事务MySQL删除数据的方式DELETEDROPTRUNCTE为什么不建议使用DELETE 删除数据 总结 MySQL 是一种关系型数据库管理系统，它的数据存储是基于磁盘上的文件系统实现的。MySQL 将数据存储在表中，每个表由一系列的行和列组成。每一行表示一个记录，每一列表示一个字段。表的结构由其列名、数据类型、索引等信息组成。
MySQL 的数据存储采用了多种技术来优化性能和存储效率。以下是 MySQL 数据存储的一些关键特性。
存储引擎 MySQL 支持多种不同的存储引擎，每种引擎都有不同的性能和存储特性。常见的存储引擎有 InnoDB、MyISAM、Memory 等。不同的存储引擎支持不同的数据存储方式，如 B树索引、哈希索引、全文索引等。
数据页 MySQL 使用数据页来管理存储在磁盘上的数据。数据页是 MySQL 存储引擎中最基本的存储单元，通常情况下每个数据页的大小为 16KB。数据页包含多个记录，每个记录对应一行数据。
索引 MySQL 使用索引来优化数据的检索效率。索引是一种特殊的数据结构，它能够快速地查找表中的数据。MySQL 支持多种类型的索引，如 B 树索引、哈希索引、全文索引等。B 树索引是 MySQL 中最常用的索引类型，它能够快速地查找表中的数据。
事务 MySQL 支持事务，事务可以保证数据的一致性、可靠性和安全性。MySQL 的事务是基于 ACID 模型实现的，它能够确保数据在事务中的操作要么全部成功，要么全部回滚。事务的支持使得 MySQL 在多用户并发访问时能够保证数据的完整性和一致性。
总之，MySQL 的数据存储基于磁盘上的文件系统实现，采用多种技术来优化性能和存储效率，如存储引擎、数据页、索引、事务等。这些特性使得 MySQL 成为一种高性能、可靠和安全的关系型数据库管理系统。
MySQL删除数据的方式 咱们常用的三种删除方式：通过 delete、truncate、drop 关键字进行删除；这三种都可以用来删除数据，但场景不同。
执行速度 ：drop &gt; truncate &gt;&gt; DELETE
DELETE DELETE from TABLE_NAME where xxx DELETE 属于数据库DML操作语言，只删除数据不删除表的结构，会走事务，执行时会触发trigger；
在 InnoDB 中，DELETE其实并不会真的把数据删除，mysql 实际上只是给删除的数据打了个标记为已删除，因此 delete 删除表中的数据时，表文件在磁盘上所占空间不会变小，存储空间不会被释放，只是把删除的数据行设置为不可见。**虽然未释放磁盘空间，但是下次插入数据的时候，仍然可以重用这部分空间（重用 → 覆盖）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d205f1341d913b36db5d5f81bb24d14a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6224fa935b31f68318ab83e2cac413a/" rel="bookmark">
			06 科技英语｜控制与优化学科词汇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		maneuver n 策略；v 操控、调遣
manipulate vt 熟练控制
scalability n 可扩展性
leverage n 杠杆；v 促使...改变
flexibility n 弹性
dispatch n 急件；v 调度；派遣
leverage v 撬动
robustness n 鲁棒性
comprehensive review n 综述
applicability n 适应性
application n 应用
use cases n 用例
key words n 关键词
index terms n 索引项
distributed energy resources(DERs) 分布式能源
distributed optimization 分布式优化
optimal power flow(OPF) 最优潮流计算
siloed data center 孤立的数据中心
heterogeneous adj 异构的
privacy-preserving 隐私保护
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6224fa935b31f68318ab83e2cac413a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/95/">«</a>
	<span class="pagination__item pagination__item--current">96/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/97/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>