<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0a150a7f180468abc24c6a7ca4c3286/" rel="bookmark">
			论文解读：Exploiting Cloze Questions for Few Shot Text Classification and Natural Language Inference
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文解读：Exploiting Cloze Questions for Few Shot Text Classification and Natural Language Inference 随着GPT-3模型的提出，现在的预训练模型形成了一个全新的无监督范式——引入task description （demostration）。本文，我们引入Pattern Exploiting Training (PET) 方法，将输入样本转换为一种完形填空（cloze-style）的类型文本帮助语言模型理解任务，并提出一种迭代式训练的无监督PET方法——iPET。
简要信息：
序号属性值1模型名称PET2所属领域自然语言处理；文本分类3研究内容预训练语言模型；Prompt框架4核心内容Prompt-based Fine-tuning5GitHub源码https://github.com/timoschick/pet6论文PDFhttps://aclanthology.org/2021.eacl-main.20.pdf 核心要点：
Template构建：人工构建；Verbalizer的构建：人工构建；添加MLM辅助损失避免灾难性遗忘；提出PET，以及迭代式iPET实现无监督学习； 一、动机 由于大量的language、domain和task以及人工标注数据的成本，在NLP的实际使用中，通常只有少量带标签的示例，所以few-shot是值得研究的部分；如果依然使用传统的监督学习方法，效果会非常差，因为当仅有很少的样本时，仅有的文本无法让模型知道要具体如何进行分类，而如果添加一些文本解释（textual explanation），则可以帮助模型理解这个task是什么。目前可以在包括GPT、BERT、RoBERT等任何一个语言模型上进行扩展；本文我们提出PET模型，一种半监督学习方法使用自然语言模式（natural language pattern）将输入的文本重构为完形填空模式。PET主要包括三个步骤： 对于每个pattern，分别使用一个语言模型（PLM）在小规模的数据集上进行微调；集成所有的语言模型并为unlabeled数据集上进行标注，标注结果为soft-label（即每个label的概率分布）；使用带有soft-label的数据，使用标准的classifier进行分类。 二、方法 2.1 参数说明 假设 M M M 表示一个预训练语言模型，词汇表记做 V V V，其中包含一个[MASK]（原文作者用下划线表示）， L L L 表示目标任务 A A A 的所有标签集合。
任务 A A A 的输入记做 X = ( s 1 , s 2 , . . . , s k ) X=(s_1, s_2, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0a150a7f180468abc24c6a7ca4c3286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf0bb52abfa39ac11af75ab1d9bff517/" rel="bookmark">
			GNN在推荐系统中的挑战、方法和方向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GNN在推荐系统中的挑战、方法和方向 今天给大家介绍清华大学李勇、中科大何向南老师团队有关GNN和推荐系统的综述：Graph Neural Networks for Recommender Systems: Challenges, Methods, and Directions。这篇文章对图神经网络及其在推荐系统中的应用进行了详细的调研，从不同角度对GNN在推荐系统的应用进行了分类，最后基于这些调研对领域内存在的问题和发展方向进行了讨论。
推荐系统的发展历程 浅层模型
早期的推荐模型主要通过计算交互的相似度来捕获协同信号，之后随着Netflix比赛中矩阵分解模型的大放异彩，推荐系统被转化为表示学习问题。
神经网络模型
浅层的模型不足以建模复杂的用户行为和大量数据输入，以神经协同过滤NCF，深度因子分解机DeepFM为代表的神经网络方法被开发了出来。
图神经网络模型
传统的神经网络很难学习到数据中的高阶结构信息，而图神经网络GNN采用消息传递机制整合邻居信息，通过多层堆叠使得节点可以访问高阶邻居的信息。因此图神经网络模型近年来被广泛应用在推荐系统中，并成为最先进的方法。
GNN 图的构建
同构图 边和节点只有一类异构图 边和节点有多个种类超图 一条边可以链接多个点 图神经网络的建模，消息传递聚合机制
如何优化
链路预测：BPRloss节点分类：Logloss GNN为什么适合推荐系统
结构化数据
推荐系统数据多，种类杂（交互，用户画像，商品属性等），用图可以统一整合在一起，获得高质量嵌入。
高阶关联
堆叠GNN层可以自然引入高阶关联，增强协同过滤信号
监督信号
监督信号，例如交互数量稀疏。GNN在表示学习中利用半监督信号来缓解监督信号少的问题。
GNN在推荐系统上应用需要考虑的几个问题
构图—&gt; 消息传递聚合机制—&gt; 模型优化—&gt; 训练和推理效率
推荐系统的分类 根据推荐系统的不同阶段
Matching 匹配阶段：第一个推荐阶段会从非常大的item池子中匹配出几百个候选项目。该阶段的特点有数据规模大，同时出于在线服务的延迟考虑，模型通常比较简洁。此外，现实工业界中的推荐系统通常包含多个匹配渠道，来分别考虑不同方面的信息。Ranking 排序阶段：第二个推荐阶段会把来自不同渠道的多个匹配结果整合到一个列表中，并对其进行排序，选出排名靠前的items。这一阶段由于输入规模较少，系统可以为了精度来使用复杂算法，并把多种特征考虑进来。同时多种特征之间如何交互也成为了该阶段的关键挑战。Re-ranking 重排序阶段：上一阶段的优化目标主要是推荐精度，但推荐系统除了精度之外，还需要考虑新鲜度，多样性，公平性等问题。这一阶段需要考虑不同Items之间的多重关系，进行删除或者更改顺序等操作。 根据不同推荐场景
社交推荐
除了用户-商品之间的交互之外，利用用户的社交关系来增强推荐效果。
主要挑战：如何捕获社交因素，如何结合社交信息和交互行为
近期发展：
序列推荐
利用用户的历史交互序列提取用户的兴趣，来预测下一个item。
主要挑战：如何从序列中提取尽可能多的有效信息
近期发展：
会话推荐
用户档案和长期的历史交互不可用，只通过匿名用户的短会话数据进行推荐。
主要挑战：如何在会话数据中建模items的变化模式以及如何在噪声数据中提取用户的核心需求
近期发展：
捆绑推荐
给用户推荐bundle(一组items)而不是单个item
主要挑战：用户对捆绑包的决策需要考虑items的从属关系，用户和捆绑包的交互更加稀疏，高阶关联的建模
近期发展：
跨域推荐
利用用户在多领域内的历史交互，缓解冷启动和数据稀疏问题。
主要挑战：如何整合利用不同域的信息
近期发展：
多行为推荐
利用多种行为下的交互进行推荐，来缓解数据稀疏问题。
主要挑战：如何建模多种行为和目标行为之间的关系，如何通过行为建模物品的语义信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf0bb52abfa39ac11af75ab1d9bff517/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16f8e753571a412e0fc27b25b35ee842/" rel="bookmark">
			2021-10-15 远程桌面爆破
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、实验题目： 远程桌面爆破
二、实验内容： 使用Hydra工具和口令字典进行远程桌面爆破
三、环境准备： （1）kali虚拟机（9.0版本以上的hydra ）
（2）Windows 11×64 虚拟机（可以被远程连接的Windows系统均可）
四、实验步骤： （1）在kali中创建密码字典（存放位置可自定义）：
命令：touch /home/kali/Desktop/password.txt
（2）编辑密码字典，存入数据：
命令：vim /home/kali/Desktop/password.txt
（3）查看待爆破主机IP（本实验使用Windows 11×64虚拟机）：
（4）对特定用户名进行爆破：
命令：hydra -l 15 -P /home/kali/Desktop/password.txt -V 192.168.32.128 rdp -t 4 -V
（5）尝试在kali中使用爆破出来的密码登陆Win11的远程桌面：
命令：rdesktop 192.168.32.128 此时发现登录失败，我们可以先去查看一下Windows 11 版本的远程设置：
可以看到Windows 11 中的网络级别身份验证连接没关，这才导致了远程登录失败。我们关闭后再次尝试登录：
此时登录界面已经显示出来，尝试输入爆破获取到的账号密码。
（6）成功登录Windows 11虚拟机： 感兴趣的小伙伴赶快去尝试一下吧！
注意：本文章仅供学习和参考！
补充： hydra介绍：
（1）Hydra 是著名黑客组织 thc 的一款开源的暴力密码破解工具，可以暴力破解多种密码。包括FTP 、 HTTP 的 所有协议、SQL 类的所有协议、 SOCKS5 、 SSH 、 Telnet 等几乎所有类型的协议都可以爆破。 （2）这款暴力密码破解工具相当强大，支持几乎所有协议的在线密码破解，其密码能否被破解关键在于字典 是否足够强大。对于社会工程型渗透来说，有时能够得到事半功倍的效果。 （3）参数选项： hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e nsr] [-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-W TIME] [-f] [-s PORT] [-x MIN:MAX:CHARSET] [-c TIME] [-ISOuvVd46] [service://server[:PORT][/OPT]] 通用： hydra &lt; 参数 &gt; &lt;IP 地址 &gt; &lt; 服务名 &gt; -R 继续从上一次进度接着破解。 -S 采用 SSL 链接。 -s PORT 可通过这个参数指定非默认端口。 -l LOGIN 指定破解的用户，对特定用户破解。 -L FILE 指定用户名字典。 -p PASS 小写，指定密码破解，少用，一般是采用密码字典。 -P FILE 大写，指定密码字典。 -e ns 可选选项， n ：空密码试探， s ：使用指定用户和密码试探。 -C FILE 使用冒号分割格式，例如 “ 登录名 : 密码 ” 来代替 -L/-P 参数。 -M FILE 指定目标列表文件一行一条。 -o FILE 指定结果输出文件。 -f 在使用 -M 参数以后，找到第一对登录名或者密码的时候中止破解。 -t TASKS 同时运行的线程数，默认为 16 。 -w TIME 设置最大超时的时间，单位秒，默认是 30s 。 -v / -V 显示详细过程。 server 目标 ip service 指定服务名，支持的服务和协议： telnet ftp pop3[-ntlm] imap[-ntlm] smb smbnt http-{head|get} http-{get|post}-form http-proxy cisco cisco-enable vnc ldap2 ldap3 mssql mysql oracle-listener postgres nntp socks5 rexec rlogin pcnfs snmp rsh cvs svn icq sapr3 ssh smtp-auth[-ntlm] pcanywhere teamspeak sip vmauthd firebird ncp afp 等等。 OPT 可选项 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5575f7b9b86545c56b929618c5cfda1/" rel="bookmark">
			React 中使用 braft-editor 踩坑记，引用 braft-utils 有错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近接到一个需求，需要支持在文本输入框支持图片粘贴上传，但是在我们这边管理页面，对于用户提的一些问题显示又不支持 Matkdown。
所以选择 braft-editor 来实现，发现提供一些配置项，因为我这边不需要那些加粗，下划线等等按钮，只需要上传图片，粘贴然后配合 COS 存链接就好了。
遇到的问题 首先我这个是 React 项目，其它项目不太清楚，然后使用 yarn。
在 utils 官方仓库中，有相关 issues，链接在下方：
引用 braft-utils 有错误 #500
其中也有人提及了一些解决方案，但是并没有解决问题，一直报错：
TS7016: Could not find a declaration file for module ‘braft-utils’. ‘xxx/node_modules/braft-utils/dist/index.js’ implicitly has an ‘any’ type.
Try npm i --save-dev @types/braft-utils if it exists or add a new declaration (.d.ts) file containing declare module 'braft-utils';
看这个报错信息，有提示，用 npm 安装那个依赖，我已经试过了，并没有效果，不存在那个依赖包。
解决方式 直接少废话，以下是解决方式：
yarn add braft-finder yarn add braft-utils yarn add draft-js-multidecorators yarn add draftjs-utils 然后在你当前需要引入的文件那，同级目录底下创建一个名为 xxx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5575f7b9b86545c56b929618c5cfda1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9caf1a129c56d124cb715206a9c380f1/" rel="bookmark">
			解决conda activate报错IMPORTANT: You may need to close and restart your shell after running ‘conda init‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整报错是：
CommandNotFoundError: Your shell has not been properly configured to use 'conda activate'. To initialize your shell, run $ conda init &lt;SHELL_NAME&gt; Currently supported shells are: - bash - fish - tcsh - xonsh - zsh - powershell See 'conda init --help' for more information and options. IMPORTANT: You may need to close and restart your shell after running 'conda init'. 解决方法 在控制台运行：
source activate conda deactivate 问题解析 未正确退出环境，会导致这样的报错。如果按照它说的先退出并重启shell，再执行conda init并没有什么卵用…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99e21686e0b669be2ee3bb0362b4ad45/" rel="bookmark">
			Linux-脚本安装和卸载Keepalived
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 #!/bin/sh DIR=`pwd` KEEPALIVED_USR_DIR=/usr/local/keepalived KEEPALIVED_DIR=/usr/local/keepalived-1.2.18 CONF=/etc/keepalived/keepalived.conf CONF_BAK=/etc/keepalived/keepalived.conf.bak CHECK=/etc/keepalived/onos_check.sh CHECK_BAK=/etc/keepalived/onos_check.sh.bak CHECK_REQ=/etc/keepalived/onos_check_req.sh CHECK_REQ_BAK=/etc/keepalived/onos_check_req.sh.bak echo "-----------------------------------install keepalived-------------------------------" if [ -d $KEEPALIVED_DIR ]; then echo "keepalived has installed" # 替换配置文件 ## 备份原来的文件和检查脚本 mv -f $CONF $CONF_BAK mv -f $CHECK $CHECK_BAK mv -f $CHECK_REQ $CHECK_REQ_BAK ## 拷贝新文件 cd $DIR cp -f ./keepalived/keepalived.conf $CONF chmod 777 ./keepalived/onos_check.sh chmod 777 ./keepalived/onos_check_req.sh # cp -f ./keepalived/onos_check.sh $CHECK # 重启数据库 service keepalived restart exit 3 fi ## 解压keepalived.tar.gz cd $DIR mkdir -p $KEEPALIVED_DIR tar -vxf keepalived-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99e21686e0b669be2ee3bb0362b4ad45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82a0b67e3326f9a8b1eb94c2fc42ece1/" rel="bookmark">
			Docker 创建容器后再修改 hostname
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		世上是有后悔药的，只要肯琢磨！再也不用重新创建容器了！
我有一个叫m2的容器，现在想要修改它的 hostname
1、查看容器配置文件在宿主机上的位置，这里看到是
/var/lib/docker/containers/67e012c02434168aff3762ab4edf7550f0bfe1db57b396ce78660f140dd3056e
2、关闭容器、关闭 docker 服务
前提条件，非常重要！！！前提条件，非常重要！！！前提条件，非常重要！！！
3、进入该容器所在配置文件所在宿主机文件夹，搜索原 hostname，可以看到我们需要修改3个地方，文件分别是 config.v2.json、hostname、hosts
4、修改前做好备份
5、修改这3个地方
6、启动 docker 服务，启动容器，查看 hostname
hostname 修改成功！惊不惊喜！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68c34836d54ec26fe05c20dbca63ad81/" rel="bookmark">
			数据结构：双向链表p结点前插入q
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 双向链表P结点前插入q_哔哩哔哩_bilibilihttps://www.bilibili.com/video/BV1w54y1J7kK?from=search&amp;seid=17934594539040246906&amp;spm_id_from=333.337.0.0插值前提：链条不能断
data:放数据
prior:放P前一个节点的地址，通过prior可以找到前一个节点，p-&gt;prior == s
next:放P后一个节点的地址，通过next可以找到后一个节点
p-&gt;prior-&gt;next = q
q-&gt;prior = p-&gt;prior
p-&gt;prior = q
q-&gt;next = p 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab1057f4b507bd684b8af34affc6be35/" rel="bookmark">
			python选择结构练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.计算销售总金额
图书批发商店的某本书的零售价是26.5元/本，如果客户一次性购买100本以上（包括100本），则每本的价格打9折，如果客户一次性购买500本以上（包括500本），则每本的价格打8折并返回1000元给客户，请分别计算购买8本、150本、600本的应付金额是多少。要求购买书的数量从控制台输入。
2. 输入两个整数，按由小到大的顺序输出这两个数。
3.输入三个整数，按由小到大的顺序输出这三个数。
4.输入一个字符，判断它是否为大写字母，如果是，将它转换成小写字母；如果不是，不转换。然后输出最后得到的字符。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1602dae8f9cad32133e5aeaa034b5982/" rel="bookmark">
			golang 参数校验方法设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码实现地址 https://github.com/wanmei002/goutil/blob/master/verify/verify.go
先看下设计好后的使用 type Lg struct { Name string `json:"name"` Age int `json:"age"` } // 判断 Name 是否为空，判断 Age 是否大于18 并小于 100 var lgs = verify.Rules{"Name": {verify.CheckEmpty()}, "Age": {verify.Gt("18"), verify.Lt("100")}} var checkParam = Lg{Name:"zzh", Age:17} err := verify.Verify(checkParam, lgs) if err != nil { c.JSON(http.StatusOK, gin.H{// 这里使用的 gin 框架输出 "code": -1, "msg": err.Error(), }) return } 输出结果:
{ "code": -1, "msg": "Age 小于 18" } 思路 设计一个类型，保存检查参数规则 type Rules map[string][]string 设计支持的比较规则 我这里设计的是支持 是否为空 正则匹配 长度比较 大小比较
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1602dae8f9cad32133e5aeaa034b5982/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de8b79d6e68d3710de1d5944dfe11aac/" rel="bookmark">
			数据库系统概论----第六章：关系数据理论（依赖、候选码、第几范式、最小依赖集、模式的分解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.非平凡依赖+平凡依赖2.完全函数依赖+部分函数依赖3.求关系模式候选码的方法3.0 补充：求闭包3.1 具体解题步骤（看这个，绝对有用 ）3.2 例: R(U)=(ABCDEG),F={AB-&gt;C,CD-&gt;E,E-&gt;A,A-&gt;G},求候选码。(根据3.1）3.x 补充：超码、候选码、主码、主属性、非主属性、全码的区别 4.判断关系模式属于第几范式的方法4.0 求范式（看这个，绝对有用 ）4.1例题4.2 补充：1NF、2NF、3NF、BCNF4.2.1 第一范式：1NF4.2.2 第二范式：2NF4.2.3 第三范式：3NF4.2.4 BCNF范式 5.公理系统（就是里面的结论直接用）6.求最小函数的依赖集6.1 例题1 (就按这个来解题）6.2 例题2 7. 模式的分解7.1 白话理解7.2判断是否为 : 无损连接分解 / 保持函数依赖7.3 U=(A,B,C,D,E,G) F={BG-&gt;C，BD-&gt;E，DG-&gt;C，ADG-&gt;BC，AG-&gt;B，B-&gt;D} 若R不是3NF，将R分解为无损且保持函数依赖的3NF。7.4 U=(A,B,C,D,E) F={AB-&gt;C，C-&gt;B，D-&gt;E，D-&gt;C} 若R不是3NF，将R分解为无损且保持函数依赖的3NF。 为什么引⼊范式?
1数据冗余
2更新异常
3插⼊异常
4删除异常
范式分类
设计关系数据库时，遵从不同的规范要求，这些不同的规范要求被称为不同的范式， 各种范式呈递次规范，越⾼的范式数据库冗余越⼩。
⽬前关系数据库有六种范式：
第⼀范式（1NF）、第⼆范式（2NF）、第三范式（3NF）、 巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，⼜称完美范式）。
⼀般来说，数据库只需满⾜第三范式(3NF）就⾏了。
1.非平凡依赖+平凡依赖 2.完全函数依赖+部分函数依赖 3.求关系模式候选码的方法 3.0 补充：求闭包 参考博客：https://wonzwang.blog.csdn.net/article/details/80464466
候选码的概念: 可以推出所有属性
如何选出候选码?
只出现在左边的⼀定是候选码只出现在右边的⼀定不是候选码左右都出现的不⼀定左右都不出现的⼀定是候选码再求确定的候选码的闭包，如果可以推出全部，那么当前确定的就是候选码，否则就不是 3.1 具体解题步骤（看这个，绝对有用 ） 参考博客：求候选键/候选码
3.2 例: R(U)=(ABCDEG),F={AB-&gt;C,CD-&gt;E,E-&gt;A,A-&gt;G},求候选码。(根据3.1） 解答：
故候选码为ABD、BCD、BDE
3.x 补充：超码、候选码、主码、主属性、非主属性、全码的区别 以3.2的例题为例
超码: 能表示出所有属性的集合, ⽐如 (ABD),(BDC),(BDE) BDCA BDEA ABCDE
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de8b79d6e68d3710de1d5944dfe11aac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9d076901c5a9e55c7326537734d3b49/" rel="bookmark">
			yolov4的全面详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 前言 作者AlexeyAB大神！ YOLOv4 拥有43.5%mAP+65FPS ，达到了精度速度最优平衡,
作者团队：Alexey Bochkovskiy&amp;中国台湾中央研究院
论文链接：
https://arxiv.org/pdf/2004.10934.pdf
代码链接：
GitHub - AlexeyAB/darknet: YOLOv4 / Scaled-YOLOv4 / YOLO - Neural Networks for Object Detection (Windows and Linux version of Darknet )
————————————————
在讲YOLOv4之前，先介绍一下两个包：Bag of Freebies(免费包)和Bag-of-Specials(特赠包)
Bag of Freebies：指的是那些不增加模型复杂度，也不增加推理的计算量的训练方法技巧，来提高模型的准确度
Bag-of-Specials：指的是那些增加少许模型复杂度或计算量的训练技巧，但可以显著提高模型的准确度
YOLOv4主要的贡献：
①构建了一个简单且高效的目标检测模型，该算法降低了训练门槛，这使得普通人员都可以使用 1080Ti 或 2080 Ti GPU 来训练一个超快，准确的（super fast and accurate）目标检测器。
②验证了最先进的 Bag-of-Freebies 和 Bag-of-Specials 方法在训练期间的影响
BoF指的是
1）数据增强：图像几何变换（随机缩放，裁剪，旋转），Cutmix，Mosaic等
2）网络正则化：Dropout,Dropblock等
3） 损失函数的设计：边界框回归的损失函数的改进 CIOU BoS指的是
1）增大模型感受野：SPP、ASPP等
2）引入注意力机制：SE、SAM
3）特征集成：PAN，BiFPN 4）激活函数改进：Swish、Mish
5）后处理方法改进：soft NMS、DIoU NMS
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9d076901c5a9e55c7326537734d3b49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0e3a92aee69e707f2f972ebdbe4e5d9/" rel="bookmark">
			Java instanceof 各种数据类型判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java instanceof 各种数据类型判断 在导出的时候，要匹配数据，而数据有各种类型，只能用instanceof一一进行判断了。
目标： 表头： {"aa","bb","cc","dd","ee","ff","gg"}
数据
[{"aa":100,"bb":"1,2,3","cc":{"num":"99","name":"统计数值"},"dd":["10505","10508"],"ee":[["业务运营保障","批量数据"],["系统运行维护","问题故障通知"],["系统运行维护","运维优化"]],"ff":[{"name":"工单开始","state":"F"},{"name":"工单处理","state":"A"}]}]
导出：
如何进行匹配数据呢？ 再进行导出到word表格内呢？
处理： 1，模拟数据: public static List&lt;Map&lt;String, Object&gt;&gt; initData(){ List&lt;Map&lt;String, Object&gt;&gt; dataList = new ArrayList&lt;&gt;(); Map&lt;String, Object&gt; dataMap = new HashMap&lt;&gt;(); dataMap.put("aa", 100); dataMap.put("bb", "1,2,3"); // map dataMap.put("cc", new HashMap&lt;String, String&gt;(){{ put("name","统计数值"); put("num","99"); }}); // 一维字符数组 dataMap.put("dd", Lists.newArrayList("10505", "10508")); // 二维字符数组 dataMap.put("ee", Lists.newArrayList( Lists.newArrayList("业务运营保障", "批量数据"), Lists.newArrayList("系统运行维护", "问题故障通知"), Lists.newArrayList("系统运行维护", "运维优化"))); // list map dataMap.put("ff", Lists.newArrayList(new HashMap&lt;String, String&gt;(){{ put("name","工单开始"); put("state","F"); }}, new HashMap&lt;String, String&gt;(){{ put("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0e3a92aee69e707f2f972ebdbe4e5d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e50803e00bd0f469b3a451580168013/" rel="bookmark">
			[Java安全]JDK8u191之后的JNDI注入绕过(javax.el.ELProcessor依赖)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 环境Maven依赖利用分析低版本流程分析JDK8u191之后的JNDI注入绕过 参考文章 环境 我们知道在JDK 6u211、7u201、8u191、11.0.1之后，增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了
切换到8u191之后就好了，我这里随便选择了8u201
Maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-catalina&lt;/artifactId&gt; &lt;version&gt;8.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.el/com.springsource.org.apache.el --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.el&lt;/groupId&gt; &lt;artifactId&gt;com.springsource.org.apache.el&lt;/artifactId&gt; &lt;version&gt;7.0.26&lt;/version&gt; &lt;/dependency&gt; 利用分析 要知道高版本我认为还是需要先了解低版本的利用链
低版本流程分析 在桌面启一个web服务，因为我桌面有恶意类
启动server端
String uri = "http://127.0.0.1:8080/"; System.out.println("[*]classFactoryLocation: " + uri); Registry registry = LocateRegistry.createRegistry(1099); Reference refObj = new Reference("abcdefg", "TouchFile", uri); ReferenceWrapper refObjWrapper = new ReferenceWrapper(refObj); System.out.println("[*]Binding 'demo' to 'rmi://127.0.0.1:1099/YYDS'"); registry.bind("YYDS", refObjWrapper); 运行client
String uri = "rmi://127.0.0.1:1099/YYDS"; Context ctx = new InitialContext(); ctx.lookup(uri); 恶意类
import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e50803e00bd0f469b3a451580168013/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba91a9cfca8e44ef09bac79c2c29587c/" rel="bookmark">
			三种方法生成随机数之srand篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		srand（）函数：随机数发生器的初始化函数，需要提供一个种子，这个种子会对应一个随机数。如果使用相同的种子,rand() 函数会出现一样的随机数。默认种子数是1，即srand(1)。
srand()
&lt;stdlib.h&gt;
原型： void srand(unsigned int seed)
作用： 播种由函数 rand 使用的随机数发生器。
函数说明：
srand()用来设置rand()产生随机数时的随机数种子。参数seed必须是个整数，通常可以利用time(0)的返回值或NULL来当做seed.如果每次seed都设相同值，rand()所产生的随机数值每次就会一样。
rand()
&lt;stdlib.h&gt;
原型： int rand(void)
作用： 返回一个范围在 0 到 RAND_MAX 之间的伪随机数。RAND_MAX 是一个常量，它的默认值在不同的实现中会有所不同，但是值至少是 32767。
函数说明 :
rand()的内部实现是用线性同余法做的，它不是真的随机数，因其周期特别长，故在一定的范围里可看成是随机的。
rand()返回一随机数值的范围在0至RAND_MAX 间。RAND_MAX的范围最少是在32767之间(int)。用 unsigned int 双字节是65535，四字节是4294967295的整数范围。0~RAND_MAX每个数字被选中的机率是相同的。 用户未设定随机数种子时，系统默认的随机数种子为1。rand()产生的是伪随机数字，每次执行时是相同的;若要不同,用函数srand()初始化它。
#include &lt;iostream&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; using namespace std; int main() { int x; srand(time(0)); x = rand(); cout&lt;&lt;"x="&lt;&lt;x&lt;&lt;"\n"; return 0; } 因为我们定义的种子seed是关于时间的函数time()，所以得到的结果是随时间变化的
若我们默认种子为1，则
int x; srand(1); x = rand(); cout&lt;&lt;"x="&lt;&lt;x&lt;&lt;"\n"; return 0; 结果是一样的。根本原因就在于生成的不是真正意义的随机数，而是伪随机数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba91a9cfca8e44ef09bac79c2c29587c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28f1c5e109c059d1c8bd9242ba8ae49a/" rel="bookmark">
			解决CentOS系统时间与UTC时间不一致问题---实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题描述 最近在划水的鱼博客项目上用 @Scheduled 和corn表达式写了个定时器，项目在本地windows上跑是没有问题的，但是发现发布到linux服务上时，定时器运行时间不对了。与我设置的定时时间相差了8个小时。
查了相关资料发现是：linux的CentOS系统时间与UTC时间不一致导致的
2.原因 ​ 咱们在安装完Centos Linux操做系统以后，点击系统的时间发现与如今所使用的时间不一致，相差有8小时，而在安装系统的时候咱们选择的时区是上海，可是CentOS Linux默认的bios时间是utc时间(UTC是协调世界时(Universal Time Coordinated)英文缩写，是由国际无线电咨询委员会规定和推荐,并由国际时间局(BIH)负责保持的以秒为基础的时间标度。
​ UTC至关于本初子午线(即经度0度)上的平均太阳时，过去曾用格林威治平均时(GMT)来表示.北京时间比UTC时间早8小时，以1999年1月1日0000UTC为例，UTC时间是零点，北京时间为1999年1月1日早上8点整。)，因此咱们在时间上面相隔了8个小时。这个时候bios的时间和系统的时间固然是不一致，一个表明 utc 时间，一个表明cst（＋8时区），即上海的时间。
查看时间命令：
1.查看系统时间： date 2.查看utc时间 date -u 很明显两个时间相差勒8个小时，所以就出现了以上的问题。
3.解决办法 在CentOS Linux中终端命令中执行如下命令：
3.1 编辑时间配置文件 vi /etc/sysconfig/clock ------------------------------ ZONE="Asia/Shanghai"操作系统 UTC=false #设置为false，硬件时钟不于utc时间一致同步 ARC=falsei 3.2 linux的时区设置为上海时区 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 3.3 对准时间 ntpdate 47.99.xxx.xxx(你的ip) 若是没有安装ntp服务器，刚须要先执行如下命令 安装npt服务器：
yum install ntp 如果报这个问题：
解决杀掉进程
使用lsof –i:123 没有lsof命令的话：yum install -y lsof [root@izbp12w1juq9po2x7vs7nnz ~]# lsof -i:123 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME ntpd 31393 ntp 16u IPv4 48258263 0t0 UDP *:ntp ntpd 31393 ntp 17u IPv6 48258264 0t0 UDP *:ntp ntpd 31393 ntp 18u IPv4 48258269 0t0 UDP localhost:ntp ntpd 31393 ntp 19u IPv4 48258270 0t0 UDP izbp12w1juq9po2x7vs7nnz:ntp ntpd 31393 ntp 20u IPv4 48258271 0t0 UDP izbp12w1juq9po2x7vs7nnz:ntp [root@izbp12w1juq9po2x7vs7nnz ~]# kill -9 31393 然后再执行命令：ntpdate 47.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28f1c5e109c059d1c8bd9242ba8ae49a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c2f4731255eaf98dc23bf9db43682c/" rel="bookmark">
			java大厂面试题2021【Redis的应用-关注和粉丝】【Redis的应用-redis数据类型】【程序算法炒基金】【2021面试必看】A股基金投资记录（从2021-10-11起投）每日更新实操
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021年10月11日起投，通过自研小程序算法进行投资
总投入：976
实时盈亏：+2.1
天弘中证银行ETF联接C第一周第二周第三周第四周月总投入月平均成本10月钱平均成本钱平均成本钱平均成本钱平均成本定投47511月钱平均成本钱平均成本钱平均成本钱平均成本月总投入月平均成本定投盈亏 鹏华中证空天军工指数C第一周第二周第三周第四周月总投入月平均成本10月钱平均成本钱平均成本钱平均成本钱平均成本定投50111月钱平均成本钱平均成本钱平均成本钱平均成本月总投入月平均成本定投盈亏 本人自研WX小程序：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd5650a4224daf3b7642344ec613a19d/" rel="bookmark">
			[Windows]Win10关于Sysprep无法验证你的Windows安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[Windows]Win10关于"Sysprep无法验证你的Windows安装" 关于这个报错的问题
首先，去找它提示的那个日志文件
[ Panther 文件夹只要运行sysprep.exe 即会自动生成 ]
打开这个文件，可以看到 setuoact.log ，打开，可以看到如下报错，这里只随便截取一部分
如此，这好像是账户的权限不够。
好的，我们正式进入解决的操作：
WIN+R &gt;&gt; compmgmt.msc ，进入计算机管理页面
计算机管理页面 &gt;&gt; 本地用户和组 &gt;&gt; 用户 &gt;&gt; Adminstrator ，就是本地用户那个
取消禁用
注销当前账户，换用 Adminstrator ，即本地用户登录
操作如下：
删除所有其他用户
之后再运行 sysprep.exe 就没有问题了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/168126a35dbd582ea9167fdb241d698e/" rel="bookmark">
			哈工大｜NLP数据增强方法？我有15种
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每天给你送来NLP技术干货！
来自：李rumor
卷友们好，我是rumor。
这篇40多页的综述出自哈工大车万翔老师的团队，一共总结了15种NLP可以用到的数据增强方法、优缺点，还有一些使用技巧，十分良心。下面就速读一下，如果要使用的话还是建议参考原文以及其他文献的应用细节。
论文：Data Augmentation Approaches in Natural Language Processing: A Survey 地址：https://arxiv.org/abs/2110.01852 数据增强方法 数据增强（Data Augmentation，简称DA），是指根据现有数据，合成新数据的一类方法。毕竟数据才是真正的效果天花板，有了更多数据后可以提升效果、增强模型泛化能力、提高鲁棒性等。然而由于NLP任务天生的难度，类似CV的裁剪方法可能会改变语义，既要保证数据质量又要保证多样性，使得大家在做数据增强时十分谨慎。
作者根据生成样本的多样性程度，将DA方法分为了以下三种：
Paraphrasing：对句子中的词、短语、句子结构做一些更改，保留原始的语义
Noising：在保证label不变的同时，增加一些离散或连续的噪声，对语义的影响不大
Sampling：旨在根据目前的数据分布选取新的样本，会生成更多样的数据
Paraphrasing 这类方法根据替换的成分不同，又可以分为词、短语、句子级别。作者共总结了6种方法：
Thesaurus：利用词典、知识图谱等外部数据，随机将非停用词替换成同义词或上位词，如果增加多样性的话还可以替换成相同词性的其他词
Semantic Embeddings：利用语义向量，将词或短语替换成相近的（不一定是同义词）。由于每个词都有语义表示，可替换的范围更大。而上一种方法只能替换图谱里的
MLMs：利用BERT等模型，随机mask掉一些成分后生成新的
Rules：利用一些规则，例如缩写、动词变位、否定等，对句子一些成分进行改写，比如把 is not 变成 isn't
Machine Translation：分为两种，Back-translation指把句子翻译成其他语言再翻译回来，Unidirectional Translation指在跨语言任务中，把句子翻译成其他语言
Model Generation：利用Seq2Seq模型生成语义一致的句子
作者还贴心地整理了上述方法的优缺点。其中「歧义」主要是指有些多义词在不同场景下意思不一样，比如「我每天吃一个苹果」，替换成「我每天吃一个iphone」就不合适了。
P.S. 作者写的Strong application我没有太懂，个人觉得可以理解为应用效果好，如果有不同解读可以留言哈。
Noising 人在读文本时对噪声是免疫的，比如单词乱序、错别字等。基于这个思想，可以给数据增加些噪声来提升模型鲁棒性。
作者给出了以上5种增加噪声的方法：
Swapping：除了交换词之外，在分类任务中也可以交换instance或者sentence
Deletion：可以根据tf-idf等词的重要程度进行删除
Insertion：可以把同义词随机插入句子中
Substitution：把一些词随机替换成其他词（非同义），模拟misspelling的场景。为了避免改变label，可以使用label-independent的词，或者利用训练数据中的其他句子
Mixup：这个方法最近两年比较火，把句子表示和标签分别以一定权重融合，引入连续噪声，可以生成不同label之间的数据，但可解释性较差
总的来说，引入噪声的DA方法使用简单，但会对句子结构和语义造成影响，多样性有限，主要还是提升鲁棒性。
这里我私下多加几个没提到的，也是我们在做ConSERT
对抗样本
Dropout：也是SimCSE用到的，还有R-drop，都是通过dropout来加入连续噪声
Feature Cut-off：比如BERT的向量都是768维，可以随机把一些维度置为0，这个效果也不错
Sampling Sampling是指从数据分布中采样出新的样本，不同于较通用的paraphrasing，采样更依赖任务，需要在保证数据可靠性的同时增加更多多样性，比前两个数据增强方法更难。作者整理了4种方法：
Rules：用规则定义新的样本和label，比如把句子中的主谓进行变换
Seq2Seq Models：根据输入和label生成新的句子，比如在NLI任务中，有研究者先为每个label（entailment，contradiction，neutral）训一个生成模型，再给定新的句子，生成对应label的。对比之下，paraphrasing主要是根据当前训练样本进行复述
Language Models：给定label，利用语言模型生成样本，有点像前阵子看的谷歌UDG。有些研究会加个判别模型过滤
Self-training：先有监督训练一个模型，再给无监督数据打一些标签，有点蒸馏的感觉
作者依旧贴心地给出了4中方法的优点和局限：
使用技巧 方法选择 作者给出了这些方法在6个维度的对比，大家可以更好地体会他们的区别和适用场景。其中Level表示DA方法会增强的部分：t=text, e=embedding, l=label，Granularity表示增强的粒度：w=word, p=phrase, s=sentence。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/168126a35dbd582ea9167fdb241d698e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58272ad866f690a42524ac377415aafb/" rel="bookmark">
			Android 录音实现（MediaRecorder）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在项目中实现录音功能，并在逻辑中还有对录音文件的特殊要求，前前后后看了很多资料，学习了很多，今天在这里分享记录一下，以便后期回看。
Android提供了两个API用于录音的实现：MediaRecorder 和AudioRecord。
MediaRecorder：录制的音频文件是经过压缩后的，需要设置编码器。并且录制的音频文件可以用系统自带的Music播放器播放。MediaRecorder已经集成了录音、编码、压缩等，并支持少量的录音音频格式，但是这也是他的缺点，支持的格式过少并且无法实时处理音频数据。
AudioRecord：主要实现对音频实时处理以及边录边播功能，相对MediaRecorder比较专业，输出是PCM语音数据，如果保存成音频文件，是不能够被播放器播放的，所以必须先写代码实现数据编码以及压缩。
MediaRecorder MediaRecorder因为已经集成了录音、编码、压缩等功能，所以使用起来相对比较简单。
开始录音
MediaRecorder 使用起来相对简单，音频编码可以根据自己实际需要自己设定，文件名防止重复，使用了日期_时分秒的结构，audioSaveDir 是文件存储目录，可自行设定。下面贴出示例代码：
public void startRecord() {
// 开始录音
/* ①Initial：实例化MediaRecorder对象 */
if (mMediaRecorder == null)
mMediaRecorder = new MediaRecorder();
try {
/* ②setAudioSource/setVedioSource */
mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);// 设置麦克风
/*
* ②设置输出文件的格式：THREE_GPP/MPEG-4/RAW_AMR/Default THREE_GPP(3gp格式
* ，H263视频/ARM音频编码)、MPEG-4、RAW_AMR(只支持音频且音频编码要求为AMR_NB)
*/
mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);
/* ②设置音频文件的编码：AAC/AMR_NB/AMR_MB/Default 声音的（波形）的采样 */
mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);
fileName = DateFormat.format("yyyyMMdd_HHmmss", Calendar.getInstance(Locale.CHINA)) + ".m4a";
if (!FileUtils.isFolderExist(FileUtils.getFolderName(audioSaveDir))) {
FileUtils.makeFolders(audioSaveDir);
}
filePath = audioSaveDir + fileName;
/* ③准备 */
mMediaRecorder.setOutputFile(filePath);
mMediaRecorder.prepare();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58272ad866f690a42524ac377415aafb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/182199e02231f145d738e6483f066954/" rel="bookmark">
			vue，小程序，html，js 60道常见面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Vue，react，jq对比
vue 是一个以数据驱动视图的渐进式 mvvm 模式框架，双向数据绑定
react专注视图层的响应式框架，单项数据绑定
jq操作dom类库的
2.vue指令？v-if v-show ；v-html v-text区别
v-for，v-model，v-bind，v-on， v-once；
v-if控制的是元素的加载与销毁，v-show控制元素的display样式；
v-html可以渲染dom片段，v-text只能渲染文本
3.vue组件通信
1.父传子：父组件用v-bind绑定自定义属性将数据传给子组件件，子组件props接收
2.子传父：父组件用v-on绑定自定义事件将函数传递给子组件，子组件$emit接收
3.父子通信：v-model，在子组件里注入一个 value 值和 input 事件函数；
（value 在 props 获取，input 函数使用$emit 触发，好处是很简洁，坏处是不容易维护，尤其是容易和其他名字冲突）
4..sync修饰符，对属性进行假的数据双向绑定，让子组件在不调用父组件传递过来的函数的情况下修改父组件传递过来的属性值
5.跨级：vuex
6.其他：父子/provide/inject 兄弟bus
4.什么是高阶组件
高阶组件就是一个函数，传给他一个组件，返回一个新的组件，新组件使用传入的组件作为子组件，主要用于代码复用
5.为什么组件中的data必须是一个函数，然后return一个对象
Data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立，不相互影响
Object是引用数据类型，如果不用function返回，每个组件的data都是内存的同一个地址，一个数据改变其他的也会改变
6.vue2.x的双向绑定原理
API是通过object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发消息给订阅者，触发相应的监听回调。
7.Vue内置组件
动态加载组价 组件缓存
Slot 作为插槽，能让我们在组件标签内填充内容
Template 模板
Transition 为组件载入和切换提供动画效果
8.vue生命周期
创建阶段：beforeCreat和created
挂载阶段：beforeMount和mounted （请求接口）
更新阶段：beforeUpdate和updated
销毁阶段：beforeDestory（清除全局变量，定时器）和destoryed
9.修饰符
事件修饰符：.once 让事件只执行一次 ; stop：禁止冒泡； prevent：阻止默认事件； native：绑定原生事件 按键修饰符：.13 enter 监听回车 ； left，right鼠标左右点击；
指令修饰符：v-model：.number 将值转为数字
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/182199e02231f145d738e6483f066954/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d54d26e5b6aeb66286f74e6fc8ee09a/" rel="bookmark">
			太坑了，用了upgrade之后系统崩溃，无法启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		凡是有文章说用sudo apt-get upgrade这个命令的统统举报
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e3bca4ae2d9549440bef3f0ab58c945/" rel="bookmark">
			SM9原理极简介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KGC Key Generate Center可信机构
产生主私钥和主公钥: Master Priv Key 、Master Pub Key
产生用户私钥： Master Priv Key与用户Identity(如电话号码)计算生成用户私钥User Priv Key。
签名方法 签名 （User Priv Key 和 Master Pub Key）一起加密生成数字签名。
验证签名 （User Identity 和 Master Pub Key）一起验证数字签名。
需要可信机构KGC的存在，并生成与用户Identity相关联的私钥。该私钥加密生成的签名可以被(Identity+主公钥)验证，从而做到身份认证。
安全风险 所有用户的私钥都依赖Master Priv Key生成，KGC的Master Priv Key一旦泄露，所有用户的身份都将失去安全保障！
参考文章： 《GMT 0044-2016 SM9标识密码算法：第2部分 数字签名算法》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49ed4cfae96a4be6b0fe01518917bd03/" rel="bookmark">
			LOOP指令——汇编语言学习笔记3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为嵌入式系统学习需要，开始学习汇编语言
学习资料是B站的视频：汇编语言程序设计 贺利坚主讲 （P25）
这里写目录标题 一、LOOP功能与格式二、LOOP指令实例三、LOOP指令执行的要求四、用LOOP指令实现乘法的例子五、总结 一、LOOP功能与格式 功能：实现循环(计数型循环)指令格式：LOOP 标号 二、LOOP指令实例 以下是一个LOOP指令的实例
程序的功能是计算 2 12 2^{12} 212
assume cs: code code segment mov ax, 2 mov cx, 11 s: add ax, ax loop s move ax, 4c00h int 21th code ends end CPU执行LOOP指令时，要进行的操作 （LOOP指令默认会使用cx寄存器）
赋值 (cx) = (cx - 1)判断 cx 中的值：
不为零则转至标号处执行程序；
为零就向下继续执行 三、LOOP指令执行的要求 cx 中要提前存放循环次数，因为 cx 影响着LOOP指令执行的结果要定义一个标号 四、用LOOP指令实现乘法的例子 五、总结 LOOP指令是汇编语言进行循环操作的指令，要注意的是LOOP指令会默认使用 cx 寄存器，所以在使用LOOP时要提前给 cx 一个值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dbde7faa0c3788fdd20c7fecf8afde4/" rel="bookmark">
			C&#43;&#43;重温笔记(四): 继承和派生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 写在前面 c++在线编译工具，可快速进行实验: https://www.dooccn.com/cpp/
这段时间打算重新把c++捡起来， 实习给我的一个体会就是算法工程师是去解决实际问题的，所以呢，不能被算法或者工程局限住，应时刻提高解决问题的能力，在这个过程中，我发现cpp很重要， 正好这段时间也在接触些c++开发相关的任务，所有想借这个机会把c++重新学习一遍。 在推荐领域， 目前我接触到的算法模型方面主要是基于Python， 而线上的服务全是c++(算法侧， 业务那边基本上用go)，我们所谓的模型，也一般是训练好部署上线然后提供接口而已。所以现在也终于知道，为啥只单纯熟悉Python不太行了， cpp，才是yyds。
和python一样， 这个系列是重温，依然不会整理太基础性的东西，更像是查缺补漏， 不过，c++对我来说， 已经5年没有用过了， 这个缺很大， 也差不多相当重学了， 所以接下来的时间， 重温一遍啦 😉
资料参考主要是C语言中文网和光城哥写的C++教程，然后再加自己的理解和编程实验作为辅助，加深印象。
今天这篇文章是C++非常重要的一块，关于类的继承和派生，我们知道C++面向对象开发有四大特性: 抽象，封装，继承和多态。 前面发现，通过定义类，把事物的数据和功能进行抽象，而通过隐藏对象的属性和实现细节，对外只提供接口的方式对类的内部成员形成了封装。 这两个前面都已经了解过， 而这篇文章主要是整理继承，即子类继承父类的特征和行为，使得子类具有父类的成员变量和方法， 继承最大的一个好处就是代码复用，两个类有一些相同的属性和方法。
这篇内容会有些偏多，还是各取所需即可 😊
主要内容如下:
C++继承和派生初识C++继承的三种方式C++继承时的名字遮蔽问题与作用域嵌套C++继承时的对象内存模型C++基类和派生类的构造函数和析构函数C++的多继承C++虚继承(虚基类，虚继承构造函数，虚继承内存模型)C++向上转型(派生类指针赋值给基类)与过程原理剖析借助指针突破访问权限的限制 Ok, let’s go!
2. C++继承和派生初识 2.1 C++面向对象开发的四大特性 在聊C++继承和派生之前，先来看看C++面向对象开发的四大特性，这样能先宏观把握一下继承到底位于什么样的位置。
C++面向对象开发有四大特性: 抽象，封装，继承和多态， 正所谓编程语言的背后都非常相似，Java既然也是面向对象的语言，同样也会有这四大特性。
抽象和封装前面其实已经整理过了， 封装主要讲的是信息隐藏，保护数据，而抽象又可以从两个层面来理解。
抽象:
从现实生活的具体事物到类层面的抽象(包括各个成员)，比如人，有姓名，年龄等各个属性，又有学习，运动等各项功能，那么就可以定义people类把这些数据抽象出来，再通过创建对象的方式把具体实体人创建出来，调用相应的方法实现相应的功能。
宏观上，这是一种大层面的抽象，而这里面其实又可以看成数据抽象(目标的特性信息)和过程抽象(目标的功能是啥，注意不关注具体实现逻辑)封装
所谓封装，就是隐藏对象的属性和实现细节，仅仅对外公开接口，控制程序对类属性的读取和修改。在类的内部， 成员函数可以自由修改成员变量，进行精确控制，但是在类的内部，通过良好的封装， 减少耦合，隐藏实现细节。继承
继承，就是子类继承父亲的特征和行为，使得子类具有父类的成员变量和方法。 这个和生活中儿子继承他爹的家产差不多是一个道理，更有意思的是继承有两种模式，单继承和多继承，单继承比较好理解，一个子类只继承一个父类， 而多继承是一个子类，继承多个父类，联想到生活中，可能有好几个爸爸。多态
同一个行为具有多个不同表现形式或形态的能力，有两种表现形式覆盖和重载，这个到这里不理解也不要紧，下一篇文章会重点整理。 重载： 这个之前学习过，相同作用域中存在多个同名函数，但函数的参数列表会不一样重写或者叫覆盖: 主要体现在继承关系里面，子类重写了从他爸那里继承过来的函数，如果子类的对象调用成员函数的时候，如果子类的成员函数重写了他爸的，那么就执行子类自己的函数，否则继承他爸的。 这个也比较好理解，比如同样是挣钱，他爸的路子很可能和儿子的不一样，那么儿子在调用挣钱的时候，肯定是先找找儿子有没有独特的挣钱方式，如果没有，就默认和他爸一样，走他爸的挣钱方式。 2.2 再看继承 有了上面的宏观把握，再看继承就比较容易理解， 简单的讲，继承就是一个类从另一个类获取成员变量和成员函数的过程。 此时，被继承的类称为父类或基类，而继承的类称为子类或派生类。
C++中派生和继承是站在不同角度看的同种概念。继承时从儿子的角度看，派生是父亲的角度看，实际说的是一回事。
派生类除了拥有他爹的成员，还可以定义自己的新成员，增强功能，此时的好处就是只需要定义新成员即可，老的成员和功能，直接继承，实现了代码复用。
下面是两种典型使用继承的场景：
创建的新类与现有类相似，只多出若干个成员变量和成员函数的时候，用继承，减少代码量，且新类会拥有基类的所有功能创建多个类， 他们拥有很多相似的成员变量或函数，可以用继承，把这些类共同的成员提取出来，定义为基类，然后从基类继承， 可以减少代码量，也方便后续的修改。 继承的语法:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dbde7faa0c3788fdd20c7fecf8afde4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d369831731026989ab59177114e7e2f1/" rel="bookmark">
			opencv-python数字图像处理学习3：拉伸低对比度图像、过度曝光图像，观察图像变换，对图像直方图均衡算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拉伸低对比度图像、过度曝光图像，观察图像变换，对图像直方图均衡算法 一、在开始之前知识点 二、开始三、灰度拉伸，观察它们的图像变化、直方图变化1、先对 一副低对比度图像 灰度拉伸2、观察图像变化、直方图变化3、对 一副过度曝光图像 灰度拉伸4、观察图像变化、直方图变化 四、对图像直方图均衡算法，观察它们的图像变化、直方图变化 一、在开始之前 知识点 本次教程涉及到的知识点：
灰度拉伸：
定义：灰度拉伸，也称对比度拉伸，是一种简单的线性点运算。
作用：扩展图像的直方图，使其充满整个灰度等级范围内
公式：g(x,y) = 255 / (B - A) * [f(x,y) - A],
其中，A = min[f(x,y)],最小灰度级；B = max[f(x,y)],最大灰度级；
f(x,y)为输入图像,g(x,y)为输出图像
缺点：如果灰度图像中最小值A=0，最大值B=255，则图像没有什么改变
直方图均衡化的基本原理：
对在图像中像素个数多的灰度值（即对画面起主要作用的灰度值）进行展宽，而对像素个数少的灰度值（即对画面不起主要作用的灰度值）进行归并，从而增大对比度，使图像清晰，达到增强的目的。
灰度拉伸只是线性的拉宽对比度，对图像的整体影响不大。 而灰度直方图均衡化却对图像的整体效果有影响，对直方图的改变也比较大；
码云代码地址：https://gitee.com/steveqobs/opencv
chapter3
要自己准备一张低对比度照片和过度曝光照片**！**
二、开始 先引入cv2
import cv2 import numpy as np from matplotlib import pyplot as plt 如果发现报错，就是没有引入某个包，鼠标点击一下红线的地方，会跳出来一个红色小灯泡，点一下小灯泡，会冒出来一个菜单选择按照package，或者在设置中安装也可
下面两个是加下来的步骤 要调用的函数
# 灰度拉伸 def grey_scale(image): img_gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY) rows, cols = img_gray.shape flat_gray = img_gray.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d369831731026989ab59177114e7e2f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b88da1ac06388df9ce9e79e368462860/" rel="bookmark">
			numpy插值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import numpy as np import scipy.interpolate as si import matplotlib.pyplot as mp min_x = -50 max_x = 50 x = np.linspace(min_x, max_x, 15) y = np.sinc(x) mp.grid(linestyle=':') mp.scatter(x, y, s=60, color='dodgerblue', marker='o', label='Samples') #通过样本点生成插值函数 cubic = si.interp1d(x, y, kind='cubic') cubic_x = np.linspace(min_x, max_x, 1000) cubic_y = cubic(cubic_x) mp.plot(cubic_x, cubic_y, color='green', label='CA') mp.legend() mp.show() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0cd54397524e5dee808c4f9e68ed594/" rel="bookmark">
			985本科生歧视北大博导“第一学历”，“无法相信北大会有这么差的师资”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		丰色 发自 凹非寺
量子位 报道 | 公众号 QbitAI “第一学历”歧视已经“反噬”了？
以前咱见到的都是应届学生出去找工作，因大学读了个专科或者二三本直接被刷掉简历。
现在，居然有北大的博士生导师被学生歧视第一学历不够好，“不想跟了”。
最近微博的一则热搜让人哭笑不得。
原来是一位985本科生，在浏览北大数院的导师时，发现一位博导的硕士毕业院校是湘潭大学，本科更是因为只是某某学院连写都没写。
如此“第一学历”让这位同学瞬间对北大“下头”，质疑Top2招的大学老师还不如深圳中学。
并直言不讳（或者你说这叫“大言不惭”）：教书育人不是儿戏，希望北大整顿师资。
你说这事，荒唐吗？
“为什么不想人家到底有多少实力才能来北大任教？” 帖子一经曝光，在知乎相关话题下也是引来百万人来围观，当事小兄弟片面的看法少不了挨批。
首先，有网友认为，要想找导师，首先要做的应该是去搜每位导师的成就，看他们发的论文、专著、课题项目之类的。
而不是先去看导师的“第一学历”，什么更重要搞清楚。
而且就算你发现这位导师的第一学历不够亮丽，也应该首先想到的是在如今内卷社会，“得有多么可怕的实力，才能支撑一个人到北大任教”。
毕竟要成为博导，不光自己顺利硕博毕业有产出，还要几年的博士后经历，再使出浑身解数拿到教职，从助教、讲师、副教授到硕导、博导，最终评上教授，一路都要不停地产出硬货，哪步容易？
并且在现在的大学校园里，哪位教师的简历不闪闪发光？可这位教授就是在一个第一学历并不亮眼的情况下坐上了北大博导的位置。
所以，嫌弃第一学历确实如大家所说，幼稚、片面了。
更甚者，有人表示，这位小兄弟要质疑也该质疑那些第一学历优秀的人是怎么才“混”的和这位教授平起平坐。
毕竟他们的起点可比他高得多了。
其次，现如今也不是不能看第一学历。
但高考考上好大学的因素也并非自身素质，还由地域优势、家境等因素决定。
如果只拿高考成绩决定的第一学历说事，那还说明小兄弟还不能用发展的眼光看人。
并且高考成绩好导致第一学历高，也不能说明这个人的学术能力也高。
成为一个领域里的专家，成为国内Top2院校——北大数院的博导，除了能力，还至少说明他是发自内心的热爱，能够坐得住冷板凳搞科研，毕竟很多在Top院校读到博士仍然转行的也有大把人士。
至于这位“躺枪”的博导，他主要从事非标准有限元方法，特别是弹性力学问题等研究，发表专业论文50余篇。
曾获中国计算数学学会的“首届青年创新奖”，全国百篇优秀博士学位论文和德国洪堡研究奖学金等荣誉。
现任三个国际期刊的编委和北京计算数学学会秘书长。
其硕士毕业学校湘潭大学，也并非“名不见经传”，其数学院小有名声，有计算湘军的美誉。
该院数学学科在全国双一流大学第四轮学科评估中评估结果中为B+。
该院毕业生里还有2人当选中国科学院院士和发展中国家科学院院士，9人获国家杰出青年科学基金。
再者，这位教授九几年考上湘潭大学，在当时的高考录取率（包括本科、专科）仅有百分之四十左右，而目前我国高考录取率已经在2020年高达80%左右，个别省份甚至达到90%以上。
为什么会这样？ 其实并不是这位年轻人，现在整个社会都无比重视第一学历。
从一开始招聘公司人资的“懒政”行为，到“本科”一词前面加上越来越多的定语。
到现在随处可见的诸如“双非大学值不值得读？”、“研究生考到清华或者北大，不能算真正的北大或者清华人”等问题和言论，对第一学历的偏见已经深入人心。
这让一些有着985/211第一学历的学生“居功自傲”，把它看成自己最大的优势；也让高考成绩不好的那拨学生往上爬变得越来越举步维艰。
针对这种现象，教育部在今年9月29日也再次声明：
没有“第一学历”的概念，“学历”通常指的是个人获得的最高或最后的学历。
也有网友认为，“学历歧视说白了还是人太多造成内卷，从根本上，可能需要”：
1、社会资源分配均匀；
2、社会竞争降低；
3、大家的思维认知提高，“横向对比”意识降低。
那么你觉得呢？
参考链接：
https://www.zhihu.com/question/491495950
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd222f0387e82d315002491e75ad93e/" rel="bookmark">
			tc和netem模拟动态网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Netem 是 Linux 2.6 及以上内核版本提供的一个网络模拟功能模块。该功能模块可以用来在性能良好的局域网中，模拟出复杂的互联网传输性能。例如:低带宽、传输延迟、丢包等等情况。
TC 是 Linux 系统中的一个用户态工具，全名为 Traffic Control (流量控制)。TC 可以用来控制 Netem 模块的工作模式，也就是说如果想使用 Netem 需要至少两个条件，一是内核中的 Netem 模块被启用，另一个是要有对应的用户态工具 TC 。
举例：增删改网络参数，delay和loss可以合并设置（如下），也可以分开设置
# 延迟 300ms ± 100ms， 丢包率 5% sudo tc qdisc add dev eth0 root netem delay 300ms 100ms loss 5% sudo tc qdisc del dev eth0 root netem delay 300ms 100ms loss 5% sudo tc qdisc change dev eth0 root netem delay 300ms 100ms loss 5% 参考：Linux 模拟网络丢包和延迟命令_fuyuande的博客-CSDN博客_linux网络延时命令
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/076269d9ccd1b859696f4a724bfcfb26/" rel="bookmark">
			2021-10-11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、去微软官网下载win10 iso镜像
二、使用软碟通（UltraISO）制作win10启动盘
2.1 首先我们先安装软碟通，软碟通版本需与系统版本相匹配。完成安装后打开软碟通，文件-&gt;打开，打开我们的iso镜像
2.2 然后选择我们的U盘
2.3 然后点击启动-&gt;写入硬盘映像
2.4 写入方式有zip和hdd两种，一般我们选择hdd或hdd+。选择了写入方式之后要先格式化，格式化格式选择NTFS，4096字节（FAT32为传统方式，不能传大于4G的文件，不建议）。格式化完毕之后点击写入等待写入完毕即可。本人选择的HDD+，HDD+是高级的HDD，读取速度更快。
2.5 选择好写入方式直接写入即可完成U盘启动盘的制作
软碟通 链接：https://pan.baidu.com/s/1p0y1sCYW-QeSkwn8HxQ3pg 提取码：y14z
三、重新启动电脑进入bios
3.1 设置u盘为第一启动项
重启时按Enter、F2进入bios。
3.2 启动方式设为Both UEFI/Legacy。Legacy为传统方式，UEFI为新的方式。本人设置为UEFI only会启动不了。
3.3 按F10保存并退出。会直接进入win10的安装程序
注：本机系统windows10，使用此方法向移动硬盘中安装windows，会提示无法选择移动硬盘，只能装到电脑自带的硬盘中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dd06e362ee5d625494b93a5e39f039d/" rel="bookmark">
			LeetCode 5897. 将数组分成两个数组并最小化数组和的差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你一个长度为 2 * n 的整数数组。你需要将 nums 分成 两个 长度为 n 的数组，分别求出两个数组的和，并 最小化 两个数组和之 差的绝对值 。nums 中每个元素都需要放入两个数组之一。
请你返回 最小 的数组和之差。
示例 1：
输入：nums = [3,9,7,3]
输出：2
解释：最优分组方案是分成 [3,9] 和 [7,3] 。
数组和之差的绝对值为 abs((3 + 9) - (7 + 3)) = 2 。
示例 2：
输入：nums = [-36,36]
输出：72
解释：最优分组方案是分成 [-36] 和 [36] 。
数组和之差的绝对值为 abs((-36) - (36)) = 72 。
示例 3：
输入：nums = [2,-1,0,4,-2,-9]
输出：0
解释：最优分组方案是分成 [2,4,-9] 和 [-1,0,-2] 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dd06e362ee5d625494b93a5e39f039d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f1f5e5979274143369f42398904e604/" rel="bookmark">
			wsl 修改 hostname
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在使用Windows 的 wsl 功能的时候发现在默认情况下 wsl 的 hostname 是和当前 windows 系统的主机名称保持一致的。当我尝试使用 hostname 修改主机名时，发现并不能完全修改，在重新进入后又会恢复成原来的样子。经过不停的查找，终于找到了能够修改 hostname 的方法。
步骤一 首先打开控制台进入 wsl：
进入 /etc 目录 ,编辑 wsl.conf，如果没有该文件就创建一个：
vim /etc/wsl.conf 输入以下参数：
[network] hostname = node01 generateHosts = false 在 network配置组下面添加以下配置：
配置说明hostname设置当前 wsl 的主机名称generateHosts是否自动生成 hosts 文件 在设置完成后退出 wsl。
注意在直接退出wsl 之后配置并没有直接生效，而是在wsl 重启之后才会生效，所以我们可以使用命令使wsl 先关闭，然后再重新进入就会发现hostname已经修改过来了。
wsl --list --running wsl --shutdown wsl --list --running wsl wsl 修改默认用户的方法 通常我们可以通过以下命令来指定进入 wsl 的时候使用的用户：
# wsl -u &lt;Username&gt;,wsl --user &lt;Username&gt; wsl -u root 如果希望修改默认用户的话，则需要进行设置，比如我这里使用的 wsl 是 Ubuntu2004 版本，则需要进行如下设置：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f1f5e5979274143369f42398904e604/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3edcd6418c1d59f81d6a92f8722badc1/" rel="bookmark">
			java一个接口可以继承另外一个接口吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一个接口可以继承多个接口. interface C extends A, B {}是可以的. 一个类可以实现多个接口: class D implements A,B,C{} 但是一个类只能继承一个类,不能继承多个类 class B extends A{} 在继承类的同时,也可以继承接口: class E extends D implements A,B,C{} 这也正是选择用接口而不是抽象类的原因 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c6d4c7849a7dfcceffdf4de02781844/" rel="bookmark">
			精讲23种设计模式-006：深入研究单例底层实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		006：深入研究单例底层实现原理 1 深入研究单例底层实现原理课程安排2 单例模式基本概念与优缺点3 手写单例模式4 使用反射机制破解单例&amp;如何防御5 使用序列化破坏单例&amp;如何防御6 序列化如何生成一个新的对象7 枚举是最安全的单例 1 深入研究单例底层实现原理课程安排 课程内容
单例模式基本与设计思想概念单例模式的应用场景单例模式多种写法懒汉式为什么需要双重检验锁Java创建对象有哪些方式如何防止单例被反射、序列化破解反序列化创建对象底层实现原理 2 单例模式基本概念与优缺点 单例基本概念
在Jvm中只会存在一个实例
单例优缺点
优点：
不会频繁创建对象，节约服务器内存；只有一个实例实现复用，不需要再创建对象，访问速度比较快； 缺点：
因为该对象只有一个实例，多个线程同时共享同一个单例对象的时候，可能存在线程安全问题；单例对象一般创建加static存放在永久区，不会被垃圾回收机制回收，会一直占用服务器内存，如果创建过多可能导致服务器内存溢出； 单例应用场景
项目中定义的配置文件都是单例；SpringIOC容器创建对象默认单例（复用）；线程池和数据库连接池；Servlet对象默认单例，线程不安全、SpringMVC基于Servlet封装也不安全；Jvm内置缓存框架，底层基于HashMap封装+淘汰策略，hashMap对象单例；枚举、常量网站计数器 3 手写单例模式 懒汉式概念：当真正需要该对象的时候才会创建该对象。
注意：需要将构造函数私有化
手写懒汉式(线程不安全)
public class Singleton01 { private static Singleton01 singleton01 = null; /** * 私有化 */ private Singleton01() { System.out.println("singleton01"); } public static Singleton01 getInstance() { if (singleton01 == null) { singleton01 = new Singleton01(); } return singleton01; } public static void main(String[] args) { Singleton01 instance1 = Singleton01.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c6d4c7849a7dfcceffdf4de02781844/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/027ff13dbf2298d2df0d7a70ad9157f3/" rel="bookmark">
			基于阿里巴巴（cluster data v2018）数据集对表格machine_mate进行简单处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过对前一篇文章进行总结，整合为一个函数，对数据去除重复数据，并且进行重排序和进行ID重置等。
def __machine_new__(): # 数据对应的列名 columns =['machine_id','time_stamp','failure_domain_1 ','failure_domain_2','cpu_num', 'mem_size','status'] machine_mate = pd.read_csv("D:\\experiment\\machine_meta\\machine_meta.csv",names=columns) # 删除重复数据 machine_mate.drop_duplicates(subset='machine_id', inplace=True, keep='first') # 对数据进行重新排序 machine_mate.sort_values(by='machine_id',inplace=True,ascending=True) # 对机器ID进行重置 j = 1 for i in machine_mate.index: s1 = str(j) j += 1 machine_mate['machine_id'].at[i] = 'm_' + s1 # 对时间戳置为0 # machine_mate['time_stamp'] = 0 machine_mate.to_csv("D:\\experiment\\machine_meta\\machine_meta_new.csv",index=False,header=False) 故障域
参考网址：https://book.51cto.com/art/201701/529696.htm
当Virtual SAN启用故障域时，存储策略从主机级别转移到故障域级别。要配置Virtual SAN故障域，Virtual SAN集群至少需要3个故障域。每个故障域中至少要包含1台ESXi主机。这样在其中一个故障域出现故障时，也可以确保Virtual SAN的正常运行。VMware推荐使用至少4个故障域以支持全数据迁出模式和数据保护配置，如图3-52所示。本小节实验演示根据VMware推荐，使用4台主机建立4个故障域。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/563e954095eddd7518b2e01e959a215b/" rel="bookmark">
			Linux环境变量配置全攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题：https://www.cnblogs.com/youyoui/p/10680329.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b676453fba1d4b302ca7a6764d514a93/" rel="bookmark">
			Tomcat学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat 介绍 Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。
当配置正确时，Apache 为HTML页面服务，而Tomcat 实际上运行JSP 页面和Servlet。
Tomcat和IIS等Web服务器一样，具有处理HTML页面的功能，另外它还是一个Servlet和JSP容器，独立的Servlet容器是Tomcat的默认模式。不过，Tomcat处理静态HTML的能力不如Apache服务器
Web基础 C/S ，Client/Server，就是客户端与服务器，顾名思义，用户需要安装相应的客户端才能运行，典型的如QQ，微信。
优点：减轻服务端的处理压力，运算速度快，对客户端响应快
缺点：版本升级成本高，每次升级必须先卸载老版本在升级B/S，Browser/Server，浏览器/服务器，本质上来说也是cs架构，只不过client变成了browser而已。
优点：不存在客户端升级问题，只需要升级服务端程序即可。
缺点：具体业务的处理压力，全部加载了服务端，导致服务端程序运算速度降低，响应速度降低，用户体验差。 Tomcat重要目录 /bin - Tomcat 脚本存放目录（如启动、关闭脚本）*.sh 文件用于 Unix 系统； *.bat 文件用于 Windows 系统。
/conf - Tomcat 配置文件目录。
/logs - Tomcat 默认日志目录。
/webapps - webapp 运行的目录。
Tomcat的启动 找到bin目录下的statup.bat/sh，进行在windows/Linux下的启动。
如果一闪而过：说明jdk没配置成功，这里直接介绍在startup.bat中修改代码来配置jdk。
如果再加入pause的话，那么界面就不会闪退，方便我们查看错误。
如果遇到启动过程中有如下错误：
Access Error: 404 -- Not Found Cannot locate document: / 该错误是有进程在占用8080端口，需要手动在cmd终端命令行上查找占用该8080端口的进程
1，在cmd查找正在使用8080端口的进程：netstat -ano | findstr 8080
2，杀死正在使用8080端口的进程：taskkill -pid id -f（id是指进程的id）
3，重新启动的Tomcat，刷新页面即可
之后再次运行startup.bat，访问localhost:8080端口便可以访问成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b676453fba1d4b302ca7a6764d514a93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/825f4ae670920d1f04a60c8c7d20a32f/" rel="bookmark">
			near节点部署指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 准备工作硬件环境操作系统clang依赖创建账户 从github克隆项目编译nearcore二进制初始化工作目录替换config.json获取历史数据运行节点验证节点设置 准备工作 硬件环境 可使用$ lscpu | grep -oh avx 查看cpu是否支持AVX
cpu: 8-Core (16-Thread) Intel i7/Xeon or equivalent with AVX support
ram: 16GB DDR4
Storage: 500GB SSD
操作系统 CentOS Linux release 7.7.190
clang依赖 nearcore 1.21.0 以上版本 clang&gt;3.9
yum install centos-release-scl yum install llvm-toolset-7 scl enable llvm-toolset-7 bash clang --version 将 scl enable llvm-toolset-7 bash加入~/.bash_profile 并source ~/.bash_profile
创建账户 记录好助记词
https://wallet.testnet.near.org/create 从github克隆项目 clone nearcore仓库
$ git clone https://github.com/near/nearcore $ git fetch origin --tags 选择版本(目前最新版本为1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/825f4ae670920d1f04a60c8c7d20a32f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9837ff1eda25ee525e8ca09c247be1cf/" rel="bookmark">
			http请求状态码400的原因总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		会出现这个HTTP请求状态码400，说明这个请求是无效的，并没有进入后台服务器（控制器）里。
通常的原因：
前端提交的字段名称或者字段类型和后台的实体类不一样，或者前端提交的参数跟后台需要的参数个数不一致，导致无法封装。比如在SprimgMVC的控制器方法中使用了@RequestParam修饰了一个yanggb参数，但是前端在请求的时候并没有带上yanggb参数或yanggb参数为空值，就会出现这种情况；再比如前端提交到后台的数据应该是JSON字符串类型，而前端没有将对象转化为字符串类型，也会返回HTTP请求状态码400。
解决方法：
对照字段名称，类型保证一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13220278d6cf629d0a7b029d60fe7ad0/" rel="bookmark">
			足球俱乐部管理系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
网络的快速发展，信息化管理被更多的用户所接受，管理工作也随着时代的进步显得尤为重要，信息管理随着科学化的发展达到了存储量大，速度快，完善等特点，管理工作得到发展并促进信息管理。
足球俱乐部管理系统的设计与制作采用当前较为流行的B/S（浏览器/服务器）结构，系统采用了Java开发技术，其基于Windows操作系统和MySQL数据库，进行了对系统的设计分析，系统的需求分析，系统的功能分析，从开发背景、目标、流程、数据库、等方面都进行了总体的规划与设计。设计并实现了一个功能较为完善的足球俱乐部管理系统。本系统包含会员：球队队史、球员信息、教练信息、视频集锦、投票信息、赛程信息、新闻资讯、个人中心、我的收藏、会员投票管理，管理员：个人中心、赛程类型管理、会员管理、球队队史管理、球员信息管理、教练信息管理、视频集锦管理、投票信息管理、会员投票管理、赛程信息管理、系统管理等。
通过对系统进测试后，本系统运行效果良好，系统操作简单，实现的系统具有全面性，实用性以及保障用户账号安全等特点。
引言 课题背景 足球俱乐部管理系统，足球俱乐部信息通过计算机进行管理，实现用户在线查看球队信息，与传统的管理方式相比有所不同。通过使用计算机实现速度快、系统的安全性有保障、系统运行的成本低。通过使用计算机实现信息的查询效率更高以及搜索速度快。足球俱乐部管理系统的管理变得的更科学化、正规化与世界接轨的重要条件。
随着网络的快速发展，信息发展模式以崭新的姿态展现在用户面前。同时网络的发展也日趋走向成熟，企业也逐渐引进信息管理模式进行管理。互联网带给用户实时、准确高效的需求，从根本上改变了管理的方式，也是未来网络发展的趋势，网络已经成为人们生活中不可缺少的部分，用户足不出户就可以体验到网络带来的便捷，所以足球俱乐部管理系统的发展更具有开发的意义和价值。
研究现状 计算机网络的快速发展，改变了传统足球俱乐部通过人工管理的方式，由于传统的管理方式信息获取不及时、信息修改难以及存储等工作跟不上信息更新的速度，并且这些信息的管理需要花费大量的人力和物力，对接困难、浪费时间等，另外对会员投票、投票等信息的管理，特别是随着球队信息的递增，查询、修改、管理起来特别困难；最后由于信息的不断增加，信息的存储也成为了难题。目前计算机发展较快，包括网络也已经普及，很多单位和用户也开始慢慢接触网络系统。
截至如今，互联网已经深入人们的生活，电脑网络已经成为人们获取信息的主要工具，这是一个沟通无限的时代，因此，利用网络来进行球队信息的电子化管理也成为大势所趋，所以，开发一个足球俱乐部管理系统是必须的。
研究内容 球队信息的不断增加，传统的人工管理方式不能满足用户，通过人工管理的方式效率低、易出错，所以本系统通过对用户需求分析后实现足球俱乐部管理系统来进行信息管理，通过足球俱乐部管理系统的开发可以将繁杂的信息通过计算机信息信息的录入以及处理等，通过足球俱乐部管理系统用户可以有效的进行信息管理、信息查询，用户使用起来更加方便，管理者在管理的过程中也更加便捷，同时提高球队信息管理效率。
本设计对足球俱乐部管理系统主要进行了需求分析，设计分析，功能分析，从开发背景、开发环境、目标、流程、数据库、系统维护等方面都进行了总体的规划与设计。采用Java技术和MySQL数据库，充分保证了系统的稳定性，发展性。足球俱乐部管理系统使球队赛程信息管理更系统化，规范化，高效化。
系统的实现 管理员功能模块的实现 系统登录界面 用户想要登录系统需要输入正确的账号和密码方可进入系统首页界面。登录界面展示如图
系统登录界面图
会员管理界面 管理员登录后点击会员功能界面进入相关界面可以进行会员信息的添加、删除等操作，其界面展示如图5-2所示。
会员管理界面图
个人中心界面 管理员登录后可在后台管理对个人信息进行添加、删除、修改以及查看等，其界面展示如图5-3所示。
个人中心界面
赛程类型管理界面 管理员登录系统进入赛程类型信息可以对该界面进行添加、删除等操作，其界面展示如图5-4所示。
赛程类型管理界面
球队队史管理界面 管理员可以对球队队史信息进行查看、增加和管理，其界面展示如图5-5所示。
​
球队队史管理界面
精力有限就写这么多，具体系统展示有视频链接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/565bdabc6564ff36aeda0b70eda1fbf2/" rel="bookmark">
			js实现九宫格抽奖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 js实现九宫格抽奖 一、效果图二、实现思路三、核心代码 一、效果图 二、实现思路 第一步：先建立所有奖品的集合，设置随机奖品的索引第二步：设置转圈的圈数第三步：给选到的奖品变换颜色第四步：设置转圈的速度，由慢到快，再由快到慢 三、核心代码 //点击开始抽奖 var item9=document.querySelector(".item-9"); var item=document.querySelectorAll(".item"); var isStart=true; var time=null; var speed=100; var index = 0;//随机奖项的索引 var save=null; var count = 0; var num = 0; var arr = ["笔记本", '电冰箱', '谢谢惠顾', '10元代金券', '5元代金券', '2元代金券', '谢谢惠顾', '水杯(高级)']; item9.onclick=function(){ if(isStart){ isStart=false; index=Math.floor(Math.random()*arr.length); Rotate(); } } function Rotate(){ if(num&gt;=item.length){ num=0; count++; } if(save){ save.classList.remove("ck"); } item[num].classList.add("ck"); save=item[num]; //对speed速度进行设置 if(count&lt;6){ speed-=2;//提速 } else{ //大于等于5圈,开始减速 speed+=30; } //限制speed最小值 if(speed&lt;=10){ speed=10; } if(count&gt;=8&amp;&amp;num==index){ clearTimeout(time); return; } num++; time=setTimeout(Rotate,speed); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/003b33b4580961e5effec699d4414475/" rel="bookmark">
			UML详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是搜集整理学习使用，信息来源：gd_沐辰 - 博客园 (cnblogs.com)
1.UML概述 1.1.什么是UML 统一建模语言（UML）是一种通用的可视化建模语言，可以用来描述、可视化、构造和文档化软件密集型系统的各种工件。
UML是独立于过程的，它适用于各种软件开发方法、软件生命周期的各个阶段、各种应用领域以及各种开发工具。
注：UML不是一种程序设计语言，其描述的模型可以和各种编程语言相联系。
1.2.UML的目标 为建模者提供可用的、富有表达力的、可视化的建模语言，以开发和交换有意义的模型。提供可扩展性和特殊化机制以延伸核心概念。支持独立于编程语言和开发过程的规范。为理解建模语言提供正式的基础。推动面向对象建模工具市场的成长。支持更高级的开发概念。 1.3.UML的应用范围 1.4.UML的构造块：事物、关系、图 2.用例图 2.1.用例图基本概念 用例图是用来描述系统功能的技术，表示一个系统中用例与参与者及其关系的图，主要用于需求分析阶段。
用例图的基本组成元素：参与者、用例、元素之间的关系。
2.1.1.使用范围——需求分析 捕获需求。描述功能需求、行为需求（系统要完成什么任务）分析需求。明确类和对象，建立之间的关系 2.1.2.基本概念 用例图是表示一个系统中用例与参与者关系之间的图。它描述了系统中相关的用户和系统对不同用户提供的功能和服务。用例图相当于从用户的视角来描述和建模整个系统，分析系统的功能与行为。用例图中的主要元素包括参与者、用例以及元素之间的关系。此外，用例图还可以包括注解和约束，也可以使用包将图中的元素组合成模块。 2.1.3.用例图示例 2.2.参与者 2.2.1.参与者概念 参与者是与系统主体交互的外部实体的类元，描述了一个或一组与系统产生交互的外部用户或外部事物。参与者位于系统边界之外，而不是系统的一部分。参与者是从现实世界中抽象出来的一种形式，却不一定确切对应的现实中的某个特定对象。 参与者的表示： 2.2.2.如何确认参与者 通过对参与者进行关注和分析，我们可以把重点放在如何与系统交互这一问题上，便于进一步确定系统的边界。另外，参与者也决定了系统需求的完整性。
确定参与者可以从以下几个角度来考虑：
为系统提供输入的人或事物接收系统输出的人或事物需要接入的第三方系统或设备时间是否会触发某些事件负责支持或维护系统中信息的人 2.2.3. 参与者分类 主要业务参与者：主要从用例的执行中获得好处的关联人员。
主要系统参与者：直接同系统交互以发起或触发业务或系统事件的关联人员。
外部服务参与者：响应来自用例的请求的关联人员。
外部接收参与者：从用例中接收某些价值或输出的非主要的关联人员。
2.2.4.参与者的泛化关系 当系统中的几个参与者既扮演自身的角色，同时也有更一般化的角色时，可以通过建立泛化关系来进行描述。
与类相似，父参与者可以是抽象的，即不能创建一个父参与者的直接实例，这就要求属于抽象父参与者的外部对象一定能够属于其子参与者之一。
2.3.用例 2.3.1.用例的概念 用例是类元提供的一个内聚的的功能单元，表明系统与一个或多个参与者之间信息交换的顺序，也表明了系统执行的动作。
简单来说，用例就是某一个参与者在系统中做某件事从开始到结束的一系列活动的集合，以及结束时应该返回的可观测、有意义的结果，其中也包含可能的各种分支情况。
用例与用例图被广泛使用于系统的需求建模阶段，并在系统的整个生命周期中被不断细化。
用例表示如下：
2.3.2.用例与参与者的关系 一个用例可以隶属一个或多个参与者，一个参与者也可以参与一个或多个用例。用例与参与者之间存在关联关系。
主参与者与次参与者：通常来说主参与者是用例的重要服务对象，而次参与者处于一种协作地位。
2.3.4.用例的特征 用例的特征保证用例能够正确地捕捉功能性需求，同时也是判断用例是否准确的依据。
用例是动宾短语用例是相对独立的用例是由参与者启动的用例要有可观测的执行结果一个用例是一个单元 2.4.用例之间的关系 用例之间的关系有：泛化关系、依赖关系（包含、扩展）
2.4.1.泛化关系 与参与者的泛化关系相似，用例的泛化关系将特化的用例与一般化的用例联系起来。子用例继承了父用例的属性、操作和行为序列，并且可以增加属于自己的附加属性和操作。父用例同样可以定义为抽象用例。
用例之间的泛化关系表示为一根实线三角箭头，箭头指向父用例一方。如下图：
2.4.2.依赖关系——包含 包含指的是一个用例（基用例）可以包含其他用例（包含用例）具有的行为，其中包含用例中定义的行为将被插入基用例定义的行为中。
包含的两个基本约束：
基用例可以看到包含用例，并需要依赖于包含用例的执行结果，但是它对包含用例的内部结构没有了解；基用例一定会要求包含用例执行。 包含表示为一个虚线箭头附加上《include》的构造型，箭头从基用例指向包含用例。
2.4.3.依赖关系——扩展 扩展指的是一个用例（扩展用例）对另一个用例（基用例）行为的增强。
扩展使用一个附加了《enxtend》构造型的虚线箭头表示，箭头指向基用例。
注意：扩展与包含的箭头方向是相反的，这表明扩展取决于扩展用例而非基用例，扩展用例决定扩展的执行时机，基用例对此一无所知。
扩展用例的使用包括四个部分：
基用例：需要被扩展的用例，“注册”用例。扩展用例：提供所添加的行为序列的用例。扩展关系：使用虚线箭头表示，箭头指向基用例。扩展点：基用例中的一个或多个位置，表示在该位置会根据某条件来决定是否要中断基用例的执行从而执行扩展用例中的片段。 2.4.4.包含、扩展的区别 根本区别，包含是无条件执行，扩展是有条件执行。图的起点不同，终点也不同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/003b33b4580961e5effec699d4414475/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/652f87cda4e9dede1d4110fba2059c3a/" rel="bookmark">
			Spring Boot实战【上】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SpringBoot介绍 1 什么是Spring Boot Spring Boot是一个框架，一种全新的编程规范，他的生产简化了框架的使用，所谓简化是指简化了Spring众多框架中所需的大量且繁琐对的配置文件，所以Spring Boot是一个服务于框架的框架，服务范围是简化配置文件。所以从本质上来说，Spring Boot其实就是Spring框架的另一种表现形式。
2 Spring Boot特征 使用Spring Boot可以创建独立的Spring应用程序在Spring Boot中直接嵌入了Tomcat、Jetty、Undertow等Web容器，所以在使用SpringBoot 做 Web 开发时不需要部署 WAR 文件通过提供自己的启动器(Starter)依赖，简化项目构建配置尽量的自动配置 Spring 和第三方库提供了生产就绪特征，如：度量指标，运行状况检查和外部化配置绝对没有代码生成，也不需要 XML 配置文件 3 Spring Boot 版本介绍 SNAPSHOT：快照版，即开发版。
CURRENT：最新版，但是不一定是稳定版。
GA：General Availability，正式发布的版本。
二、 创建基于 Spring Boot 的项目 1 通过官网创建项目 2 通过 IDEA 的脚手架工具创建 3 通过 IDEA 的 Maven 项目创建 修改 POM 文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.bjsxt&lt;/groupId&gt; &lt;artifactId&gt;springbootdemo3&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/652f87cda4e9dede1d4110fba2059c3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/287637b7668e90f379184e377e83d347/" rel="bookmark">
			取消pycharm双击shift出现搜索框,但新版找不到ide.suppress.double.click.handler的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		取消pycharm/IDEA双击shift出现搜索框,但新版找不到ide.suppress.double.click.handler的问题解决 在使用Jetbrains产品时，例如IDEA、Pycharm，输入法切换双击shift键总是弹出全局搜索，十分不便，这里采用一种简单的方法来屏蔽这个功能。
但网上提供在registry中 找到ide.supress.double.click.handler，并勾选已不太适用。因为在新版PyCharm 已经没有这个选项了。
我的版本是2021.2.2，
下面提供的办法在Setting里进行修改即可
【中文界面】
在设置最下面的高级设置选项卡中的用户界面里，
【英文界面：】
在Advanced Settings 搜索double 可以快速定位选项
我的版本是2021.2.2， 如果是比较旧的版本，而且在高级设置没有找到上面取消双击选项，可以参考https://www.cnblogs.com/kervia/p/13857731.html 来取消双击问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6db11b80dbfe7143ddcdd79a62d02022/" rel="bookmark">
			python学习六十一（列表推导if else）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		if else列表推导格式
list=[条件1成立执行的语句 if 条件1 else 条件2 条件2成立的语句 for i]
dict1={‘name’:‘tom’,‘salary’:5000}
dict2={‘name’:‘jack’,‘salary’:8000}
dict3={‘name’:‘lily’,‘salary’:3000}
list2=[dict1,dict2,dict3]
#if 薪资&gt;5000加200工资 if 薪资&lt;5000加500工资
newlist = [employee[‘salary’]+200 if employee[‘salary’]&gt;5000else employee[‘salary’]+500 for employee in list2 ]
print(newlist)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77b940f03ef3d8e1a51518054badc662/" rel="bookmark">
			递归函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 什么是递归函数2. 递归求阶乘3. 递归的进入4. 递归的退出5. 递归的条件 1. 什么是递归函数 一个函数在它的函数体内调用它自身称为递归调用，这种函数称为递归函数。执行递归函数将反复调用其自身，每调用一次就进入新的一层，当最内层的函数执行完毕后，再一层一层地由里到外退出。
一句话总结递归：自我调用且有完成状态
2. 递归求阶乘 举个例子，我们来计算阶乘n! = 1 x 2 x 3 x ... x n，用函数factorial(n)表示，可以看出：
所以，factorial(n)可以表示为n x factorial(n-1)，只有n=1时需要特殊处理。
于是，factorial(n)用递归的方式写出来就是：
#include &lt;stdio.h&gt; //求n的阶乘 long factorial(int n) { if (n == 1) { return 1; } else { return factorial(n - 1) * n; // 递归调用 } } int main() { int a; printf("Input a number: "); scanf("%d", &amp;a); printf("Factorial(%d) = %ld\n", a, factorial(a)); return 0; } 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77b940f03ef3d8e1a51518054badc662/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/832334be1c500aadd646c1b231dd893f/" rel="bookmark">
			pycharm无法输入中文注释解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pycharm无法输入中文注释解决办法 第一步：打开pycharm,点击 File --&gt; Settings --&gt; Editor --&gt; Code Style --&gt; File Encodings, 按照图1中红色框内的状态，设置自己pycharm相应的位置的状态,点击Apply,点击ok.
图1：
第二步：点击 File --&gt; Settings --&gt; Editor --&gt; Code Style --&gt; File and Code Templates --&gt; Python Scripts,按照图2中红色框内的状态，设置自己pycharm相应的位置的状态,点击Apply,点击ok.
图2：
第三步：关闭pycharm，重启pycharm，打开项目添加中文注释即可。
感谢采纳此方法，点个赞赞叭，谢谢啦~！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bdd02a23f62778430571f47014c98cb/" rel="bookmark">
			20211008 FlinkSql测试-1.12版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、flinkSql-Client /mnt/flink-1.12.4/bin/start-cluster.sh --启动集群 /mnt/flink-1.12.4/bin/sql-client.sh embedded --进入sql客户端 二、FlinkSql函数 1、比较函数 = &lt;&gt; &gt; &gt;= &lt; &lt;= 注意：select null=null; 返回为null IS NULL 、 IS NOT NULL --非空判断 value1 IS DISTINCT FROM value2、value1 IS NOT DISTINCT FROM value2、 --不同于 value1 BETWEEN [ ASYMMETRIC | SYMMETRIC ] value2 AND value3、value1 NOT BETWEEN [ ASYMMETRIC | SYMMETRIC ] value2 AND value3、 --如：select 1 between 0 and 2; 返回true。默认ASYMMETRIC 表示value1在闭区间内 [value2,value3] string1 LIKE string2 、string1 NOT LIKE string2 --如：select 'abc' like 'a%'; 返回true，用 '用%或_模糊数据' string1 SIMILAR TO string2 、string1 NOT SIMILAR TO string2 --string2 为正则表达式.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bdd02a23f62778430571f47014c98cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d29783612c915dc2c0ccb6e552533f2/" rel="bookmark">
			element-ui 中使用svg-icon
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、阿里巴巴图标库图标svg格式下载引入
2、前端工程化svg格式图标处理
const req = require.context("../../../assets/icons/svg", false, /\.svg$/); const requireAll = requireContext =&gt; requireContext.keys(); const re = /\.\/(.*)\.svg/; const svgIcons = requireAll(req).map(i =&gt; { return i.match(re)[1]; }); export default svgIcons; webpack配置
config.module .rule("svg") .exclude.add(resolve("src/assets/icons")) .end(); config.module .rule("icons") .test(/\.svg$/) .include.add(resolve("src/assets/icons")) .end() .use("svg-sprite-loader") .loader("svg-sprite-loader") .options({ symbolId: "icon-[name]" }) .end(); 3、页面svg图标引入
&lt;template&gt; &lt;div v-if="isExternal" :style="styleExternalIcon" class="svg-external-icon svg-icon" v-on="$listeners" /&gt; &lt;svg v-else :class="svgClass" aria-hidden="true" v-on="$listeners"&gt; &lt;use :xlink:href="iconName" /&gt; &lt;/svg&gt; &lt;/template&gt; .svg-icon { width: 1em; height: 1em; vertical-align: -0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d29783612c915dc2c0ccb6e552533f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ae681cbd37fc1b8313462739e76c88c/" rel="bookmark">
			.bss段和.data段引起的文件大小增加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由 bss 段和 data 段引起的问题 起因内存四区bss段 和 data 段问题查看反汇编解决 起因 起因是我在编写 imx6ull EPIR 定时器的时候发现编译的 bin 文件居然有 69kb，而之前编译的 bin 文件只有 3kb 左右，这明显是有有问题的，而导致问题的原因就是 .bss 段和 .data 端没有处理好，在解决问题前，我们先了解什么是 bss 段和 data 段
内存四区 在C语言学习中我们会听到 “内存四区” 这个概念，分别是栈区、堆区、全局区、代码区
栈区一般存放函数的局部变量、形参等，函数执行完成就自动回收堆区由程序员手动分配和释放空间，如使用 malloc、free 在程序运行过程中，如果程序员不手动释放，生命周期和程序相同全局区用于存放全局变量和静态变量代码区存放执行代码的区域 bss段 和 data 段 在嵌入式系统中，一个程序的组成一般由 text 段、bss 段、data 段组成，当然还有栈区、堆区等等，这里不做讨论，我们主要分析 text 段、bss 段、data 段这三段
texttext 段是程序的代码段，它是只读区域，不能被修改。当我们在链接的时候通常会给 text 段链接一个地址作为程序运行的起始地址，运行程序时就会将代码加载到指定内存中运行bss存放程序中未初始化的全局变量的区域data存放已经初始化的全局变量和 static 变量的区域。值得注意的是，如果初始化的值为0，那么它会存放在 bss 段，而不是 data 段 这里有个概念值得注意： bss 段不占实际的磁盘空间（不是内存！在生成可执行文件时，这个文件会占用 pc 的磁盘空间，而不占用内存空间。只有运行程序时才会申请和占用内存），而 data 段是需要占磁盘空间的。那么为什么都是存放全局变量，bss 段却不占磁盘空间呢？这也是我开头提到的问题的关键所在。
① 首先我们要明确的一点是 bss 存储的是为初始化的全局变量，而这些全局变量最后都会被初始化为0（正点原子的代码将 bss 段全部清零了的）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ae681cbd37fc1b8313462739e76c88c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/280/">«</a>
	<span class="pagination__item pagination__item--current">281/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/282/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>