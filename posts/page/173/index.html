<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29952d291ee18ac0449df329d9c227b8/" rel="bookmark">
			多线程8锁问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程8锁 问题一： 标准访问，请问先打印邮件还是短信?问题二：邮件暂停4秒钟，请问先打印邮件还是短信？问题三：新增一个普通方法hello(),请问先打印邮件还是hello?问题四：两部手机，请问先打印邮件还是短信？问题五：两个静态同步方法，同一部手机，请问先打印邮件还是短信？问题六：两个静态同步方法，两部手机，请问先打印邮件还是短信？问题七：一个静态的同步方法，一个普通同步方法，1部手机，请问先打印邮件还是短信？问题八：1个普通同步方法，1个静态同步方法，2部手机，请问先打印邮件还是短信？ Java的8锁问题链接 8锁即8个关于锁执行顺序的问题
解决问题前，首先需要明白的是 synchronized 只会锁两样东西，一样是调用的对象，一样是Class
一个对象里面如果有多synchronized方法，某一时刻内，只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一时刻内，只能唯一一个线程去访问这些synchronized方法。锁的是当前对象this，被锁定后，其它的线程不能进入到当前对象的其它的synchronized方法
synchronized实现同步锁的基础：Java中的每一个对象都可以作为锁。
具体表现为以下3种形式：
对于普通同步方法，锁是当前实例对象
对于静态同步方法，锁是当前类的class 对象。
对于同步方法块，锁是synchronized括号里配置的对象。
问题一： 标准访问，请问先打印邮件还是短信? class Phone { public synchronized void sendEmail() throws Exception { System.out.println("------sendEmail"); } public synchronized void sendSMS() throws Exception { System.out.println("------sendSMS"); } } public class Lock8 { public static void main(String[] args) throws Exception { Phone phone = new Phone(); new Thread(()-&gt;{ try{ phone.sendEmail(); }catch (Exception e){ e.printStackTrace(); } },"A").start(); Thread.sleep(1000); new Thread(()-&gt;{ try{ phone.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29952d291ee18ac0449df329d9c227b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83dbbc6f2e9e704dd3bcb0e732bb777d/" rel="bookmark">
			mysql数据库定时备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 环境检查
1. 执行本手册前，请正确安装Mysql数据库，并知晓数据库用户名和密码；
2. 执行本手册前，请先确定Mysql数据库数据要储存的天数；默认30
2 批处理文件配置
当前步骤主要实现以下目标配置：
Ø 配置Mysql安装目录，定义Mysql目录下BIN目录路径，用于定时导出数据的命令源；
Ø 配置Mysql数据库root用户名及root密码，用于定时导出数据库数据；
Ø 配置数据库备份目录，用于存储数据库备份文件；
Ø 配置数据库备份数据存储的天数，用于清理数据时限；
当前步骤配置文件源为，\07、数据库定时备份与清理手册\databasebak.bat：
2.1 配置批处理文件变量
找到“\07、数据库定时备份与清理手册\databasebak.bat”文件，选中后右键，点击“编辑”选项；
文档内容分为两部分：
第一部分，变量配置，用于部署人员配置变量；
第二部分，不需要做任何变更。请勿随意变更。
2.1.1 配置Mysql数据库安装BIN路径
定义mysql安装路径下BIN目录。必须以实际环境目录为准。在此，举例为C:/Program Files/MySQL/MySQL Server 5.7/bin。
Ø Windows系统：将变量“mysqlfilepath”设置如下，黄色部分作废，通过REM # 命令作废Linux命令。
REM ##################################### REM # 第一部分：变量定义，维护人员仅在此部分做变量调整 REM # 无论是Windows系统还是Linux系统mysql数据库用户名和密码均更改为实际环境下配置 REM ##################################### REM # 定义mysql安装路径下BIN目录。必须以实际环境目录为准，需要变更 REM # Windows，执行命令:与Linux命令不共存 set mysqlfilepath=C:/Program Files/MySQL/MySQL Server 5.7/bin REM # Linux，执行命令:与Windows命令不共存 REM # set mysqlfilepath=/Program Files/MySQL/MySQL Server 5.7/bin Ø Linux系统：将变量“mysqlfilepath”设置如下，黄色部分作废，通过REM # 命令作废Windows命令。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83dbbc6f2e9e704dd3bcb0e732bb777d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c24c5a3a47e7a0efce84db355cec11cc/" rel="bookmark">
			给程序员的ChatGPT使用指南：优化工作流程的 3 种实用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT for Coders: 3 Practical Ways to Optimise your Workflow
自从 ChatGPT 发布以来，我在互联网上看到了很多关于它对未来编程可能意味着什么的讨论。
肯定有很多“FUD”在那里传播，但它基本上归结为两个论点：
编程将继续有利可图，我们会使用 ChatGPT 和 Copilot 等工具进行调整。
ChatGPT 和 Copilot 等工具只是未来的开始，编程的未来是不确定的。
老实说，这两种未来都是可能的，甚至可能不会相互排斥。但是，该讨论可以保留到另一篇文章。
截至今天，程序员可以从像 ChatGPT 这样的工具中受益，我们应该拥抱它而不是回避它。
在这篇文章中，我想强调 3 个 ChatGPT 用例，这些用例让我受益匪浅，也可能对您有所帮助。特别是，它们是：解释代码、调试和编写样板。
Since the release of ChatGPT, I’ve seen plenty of discussion on the internet about what it might mean for the future of programming.
There is certainly a lot of “FUD” being spread out there, but it essentially boils down to two arguments:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c24c5a3a47e7a0efce84db355cec11cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b867f6150b1c58eab4957db825911f95/" rel="bookmark">
			linux 获取本地ip接口和实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;arpa/inet.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netdb.h&gt; #include &lt;ifaddrs.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; int main(int argc, char *argv[]) { struct ifaddrs *ifaddr, *ifa; int family, s; char host[NI_MAXHOST]; if (getifaddrs(&amp;ifaddr) == -1) { perror("getifaddrs"); exit(EXIT_FAILURE); } for (ifa = ifaddr; ifa != NULL; ifa = ifa-&gt;ifa_next) { if (ifa-&gt;ifa_addr == NULL) continue; family = ifa-&gt;ifa_addr-&gt;sa_family; if (family == AF_INET) { printf("interfac: %s, ip: %s\n", ifa-&gt;ifa_name, inet_ntoa(((struct sockaddr_in *)ifa-&gt;ifa_addr)-&gt;sin_addr)); } } freeifaddrs(ifaddr); exit(EXIT_SUCCESS); } 结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b867f6150b1c58eab4957db825911f95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37e32133171b9effa58ecf1ec822fe8f/" rel="bookmark">
			K8S环境中，每次部署服务前更新数据库表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目需求：K8S环境中，每次部署Spring服务前，更新数据库表。
分析：Spring服务启动时会自动加载类路径中的liquibase文件来更新数据库，但无法读取外部路径中liquibase文件，要想使用，只能将liquibase文件打成jar加入服务启动类路径。项目要求所有的数据库操作(包括schema/table)都是by tenant级别，该逻辑是由公司自有框架实现，短期难以通过直接调用liquibase api实现by tenant级别的数据库操作。
解决方案：新建init container运行新服务，新服务包含两个功能：下载最新liquibase文件+打包jar，将jar加入主服务类路径。
目录
1.新服务部分
2.主服务部分
1.新服务部分 下载最新liquibase文件，该项目中liquibase文件存放在Azure database。
下载后，首先按照gradle目录结构存放，并在根目录添加gradle.build文件。
String changelogDir = "/liquibaseJar/src/main/resources/db/changelog/"; 新服务创建run.sh文件，用于执行build命令，app.jar实现下载功能。
#!/bin/bash #env echo "==========start download liquibase files==========" java -jar /opt/eureka/app.jar echo "==========show files in liquibaseJar==========" ls liquibaseJar echo "==========start build liquibase files jar==========" cd liquibaseJar gradle build cd ../ cp /liquibaseJar/build/libs/liquibaseJar.jar targetLiquibaseJar echo "==========show files in targetLiquibaseJar==========" ls /targetLiquibaseJar 新服务创建Dockerfile文件，准备打包环境，该文件将在CI pipline执行，将服务打包成镜像。
FROM centos:7 EXPOSE 8080 RUN sed -i -e "s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g" /etc/yum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37e32133171b9effa58ecf1ec822fe8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3b7feada08c735cb73ff6c5cf3a8ef1/" rel="bookmark">
			特征工程——数据的标准化（Z-Score,Maxmin,MaxAbs,RobustScaler,Normalizer）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据标准化是一个常用的数据预处理操作，目的是处理不同规模和量纲的数据，使其缩放到相同的数据区间和范围，以减少规模、特征、分布差异等对模型的影响。
比如线性回归模型、逻辑回归模型或包含矩阵的模型，它们会受到输入尺度(量纲)的影响。相反，那些基于树的模型则根本不在乎输入尺度(量纲)有多大。如果模型对输入特征的尺度(量纲)很敏感，就需要进行特征缩放。顾名思义，特征缩放会改变特征的尺度，有些人将其称为特征归一化。特征缩放通常对每个特征独立进行。下面讨论几种常用的特征缩放操作，每种操作都会产生一种不同的特征值分布。
标准化方法公式优点缺点转换区间适用场景Z-Score(标准化standardization) 适用大多数类型的数据，标准化之后的数据是以0为均值，方差为1的正态分布是一种中心化方法，会改变原有数据得分布结构均值为0，方差为1的标准正态分布不适合用于稀疏数据的处理Max-Min(归一化) 应用广泛，能较好的保持原有数据分布结构 1.分母可能为0，导致计算过程出错。
2.对异常值(离群值)的存在非常敏感
[0,1]不适合用于稀疏数据的处理MaxAbs 保持原有数据分布结构对异常值(离群值)的存在非常敏感[-1,1]稀疏数据、稀疏CSR或CSC矩阵RobustScaler ，Q代表分位数 能最大限度地保留数据集中的异常(离群点)--最大限度保留数据集中的异常(离群值)Normalizer(正则化Normalization)对每个样本计算其范数 ，然后该样本中每个元素进行除以该范数 (即将每一个样本点看成一个向量，将其规范化成单位向量) 一个单向量上来实现这正则化的功能。正则化有 , -- 经常被使用在分类与聚类中。
注：
1、稀疏数据集：存在稀疏性特征，特征表现为标准差小，并有很多元素的值为0，最常见的稀疏数据集是用来做协同过滤的数据集。
2、CSR(Compressed Spare Row，行压缩)和CSC(Compressed Spare Column，列压缩)是稀疏矩阵的两种存储格式，这两种稀疏矩阵在scipy.sparse包中应用广泛。
一、sklearn代码实现及相关原理 1、Z-Score(标准化) import numpy as np import matplotlib.pyplot as plt from sklearn import preprocessing data=np.array([[1,2,3],[4,5,6],[7,8,9]]) data #Z-score标准化 zscore_scaler=preprocessing.StandardScaler() data_zcore_1=zscore_scaler.fit_transform(data) data_zcore_1 #算法原理 data_zcore_2=(data-data.mean(axis=0))/data.std(axis=0) data_zcore_2 输出： array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) array([[-1.22474487, -1.22474487, -1.22474487], [ 0. , 0. , 0. ], [ 1.22474487, 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3b7feada08c735cb73ff6c5cf3a8ef1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/444c2d45eb477d068928a4d2812a89b1/" rel="bookmark">
			vue3项目使用tinymce
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有在vue3项目使用富文本编辑框的需求，查阅了tinymce 的使用，虽然有找到参考的文章，但是还是有坑导致多花了些时间。
1、下载依赖
npm install tinymce -S
npm install @tinymce/tinymce-vue -S
2、下载中文包 地址 https://www.tiny.cloud/get-tiny/language-packages/ 这里需要注意，请下拉到最后，有个蓝色的按钮写着TinyMCE 5 All Languages，下载这个，而不是上面的Chinese Simplified那个包
3、引入皮肤和汉化包
在项目public文件夹下新建tinymce文件夹，
将下载的汉化包解压到此文件夹
然后在node_modules/tinymce中找到skins文件夹，也复制到public/tinymce里
4、封装组件:在src/components下新建TEditor.vue，并写入以下代码 &lt;template&gt; &lt;main&gt; &lt;editor v-model="myValue" :init="init" :disabled="disabled" :id="tinymceId"&gt;&lt;/editor&gt; &lt;/main&gt; &lt;/template&gt; &lt;script setup&gt; import {reactive,ref,onMounted,watch} from 'vue' import tinymce from 'tinymce/tinymce' import 'tinymce/skins/content/default/content.css' import Editor from '@tinymce/tinymce-vue' import 'tinymce/themes/silver' import 'tinymce/themes/silver/theme' import 'tinymce/icons/default' import 'tinymce/models/dom' import "tinymce/icons/default/icons" import "tinymce/plugins/table" import "tinymce/plugins/lists" import "tinymce/plugins/wordcount" import "tinymce/plugins/code" const emits = defineEmits(["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/444c2d45eb477d068928a4d2812a89b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6f9fbe344e74bc8e569cc0e74c5dfd1/" rel="bookmark">
			短视频社交|电影点播平台Springboot&#43;vue&#43;ElementUI前后端分离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者主页：编程指南针
作者简介：Java领域优质创作者、CSDN博客专家 、掘金特邀作者、多年架构师设计经验、腾讯课堂常驻讲师
主要内容：Java项目、毕业设计、简历模板、学习资料、面试题库、技术互助
收藏点赞不迷路 关注作者有好处
文末获取源码 项目编号：BS-PT-071
一，项目简介 本项目基于Springboot+vue开发实现了一个电影点播和短视频分享平台，名为爱奇艺影视平台系统。系统开发采用前后端分离的模式开发实现，分为前端系统用户功能模块和后台系统用户功能模块。
前端用户的主要功能：
1.注册登陆
2.全文检索
3.视频播放
4.点赞收藏
5.弹幕播放
6.评论影视
7.关注作者
8.视频上传
9.个人中心管理等等
后台用户的主要功能：
1.用户管理
2.视频管理
3.视频审核
4.播放量统计图形报表
5.分类管理等等
二，环境介绍 语言环境：Java: jdk1.8
数据库：Mysql: mysql5.7
应用服务器：Tomcat: tomcat8.5.31
开发工具：IDEA或eclipse
后台开发技术：Springboot+Mybatis
前端开发技术：vue+ElementUI
三，系统展示 前端系统展示
注册登陆
播放视频
个人中心
消息中心
视频中心
视频上传
后台管理模块
用户管理
播放量统计
视频管理
视频审核
视频分类管理
四，核心代码展示 package com.hu.video.controller; import com.hu.video.service.IAdminEChartService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; import java.util.List; /** * @author znz */ @Controller @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6f9fbe344e74bc8e569cc0e74c5dfd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7db48948429f2a488f4fe505ee48e576/" rel="bookmark">
			CUDA编程笔记（8）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言原子函数完全在GPU中归约性能比较总结 前言 原子函数的合理使用
原子函数 在cuda里，一个线程的原子操作可以在不受其他线程的任何操作的影响下完成对某个（全局或共享内存中）数据的一套“读-改-写”操作，该操作是不可分的。原子函数是对它的第一个参数指向的数据进行一次“读-改-写”的一类原子操作的函数，一气呵成，不可分割。
如:
T atomicAdd(T *address,T val)；// 加法 T atomicSub(T *address,T val)；// 减法 T atomicExch(T *address,T val)；// 交换 T atomicMin(T *address,T val)；// 最小值 T atomicMax(T *address,T val)；// 最大值 T atomicInc(T *address,T val)；// 自增 T atomicDec(T *address,T val)；// 自减 T atomicAnd(T *address,T val)；// 按位与 T atomicOr(T *address,T val)；// 按位或 T atomicXor(T *address,T val)；// 按位异或 T atomicCAS(T *address,T camepare,T val)；// 比较-交换 第一个参数是带累加变量的地址。第二个参数是累加的值val。该函数的作用是先将地址adress中的旧值old读出，计算old+val，然后将计算的值存入地址adress。
完全在GPU中归约 在共享内存中的数组归约，没有在核函数里做全部的计算，后面线程块的求和是在主机上进行的。为了提升性能，将所有的计算在核函数里完成。有两种方法：
（1）利用另一个核函数将最后那部分在主机里的求和操作完成；
（2）在原来的核函数里利用原子函数代替在主机里的求和操作；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7db48948429f2a488f4fe505ee48e576/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6935cbf89fe7e1cb8f24114325cf1fe/" rel="bookmark">
			vue2全家桶知识点及个人理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下内容是个人整理的v2知识点和一些概念，帮助自己记忆的。如有错误欢迎纠正。
vue
以数据驱动视图的渐进式MVVM框架
渐进式：循序渐进的使用vue，可选择性强，可以只是用其中的一些小功能，不必完全使用。
MVVM：vm视图层 通过接口从后台m层请求数据，vm视图层和view层实现数据的双向绑定。
MVC：m:mode v:view c:控制器 数据改变控制页面也改变
vue底层原理
-原理：Object.defineProperty 通过getter和setter来劫持数据，实现数据的双向绑定
-vue
优点：虚拟dom，数据驱动，双向绑定，模块化开发，浏览器兼容好
缺点：由于是js生成的虚拟dom，不利于seo爬虫获取，首屏加载相对于静态页慢
data为什么是一个函数
是因为作用域的问题，函数有自己的作用域，这样data就是专属于这个组件的。如果是对象的话会提升。多个组件的data就会产生冲突
什么是虚拟dom
就是js动态生成的dom叫做虚拟dom，虚拟dom不会引发回流和重绘，性能更好
不同场景使用不同，看是否要频繁的触发大面积内容的更新
diff算法和key的关系
diff算法：同层对比，只要发现不一致的节点，就用新的替换旧的。
因为diff算出来的dom没有跟踪标识，当循环出来的dom列表任意一个元素被修改，就无法找到。但是当加了key之后，就相当于给每个元素都加了唯一标识，当想要修改时直接修改对应元素就行，节省性能。key值必须是唯一的，不推荐使用下标和随机数
生命周期
四个阶段八个函数，最大的争议为在哪发起ajax请求。服务端渲染在created发起。服务端只有创建阶段。
创建阶段：
beforeCreate：骨架屏占位，日志上传
Created：发起ajax请求。
挂载阶段：
beforeMounted：对一些数据进行初始化
Mounted：发起ajax请求
更新阶段：
beforeUpdate：二次对更新的数据进行修改
Updated：只能观察到更新后的数据
卸载阶段：
beforeDestroy：清除常驻垃圾，对用户离开进行提示
Destroyed
-组件初次挂载生命周期
创建阶段和挂载阶段
-父组件和子组件的生命周期
父 beforeCreate created beforeMounted
子 beforeCreate created beforeMounted mounted
父 mounted beforeUpdate
子 beforeUpdate Updated
父 Updated beforeDestroy
子 beforeDestroy Destroyed
父 Destroyed
都是在before前阶段执行子组件的生命周期
- 子组件更新过程
父beforeUpdate -&gt; 子beforeUpdate -&gt; 子Updated -&gt; 父Updated
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6935cbf89fe7e1cb8f24114325cf1fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51a33356c27f5a1cef4c7a673cf4b7bb/" rel="bookmark">
			【Python32位运行】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python32位运行 遇到的问题'ModuleNotFoundError: No module named 'win32'' 引用解决方案: Anaconda 使用 set CONDA_FORCE_32BIT=1 切换32位环境失败的解决方法.
在使用 set CONDA_FORCE_32BIT=1无效的情况下,
换个命令$Env:CONDA_FORCE_32BIT=1 即可成功.
接着conda create -n python32 python=3.9 自动下载并安装32位的Python.
遇到的问题’ModuleNotFoundError: No module named ‘win32’’ 解决方案: python -m pip install pypiwin32
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fc94cb037422d1079ffd80ecd2413ef/" rel="bookmark">
			Windows11、win11、Windows10、win10系统安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 相关内容 winpe是什么？ WINPE 全称 Windows Preinstall Environment，即“Windows预安装环境”。
在Windows内核上构建的具有有限服务的最小 Win32 子系统，它用于为安装 Windows 而准备计算机，以便从网络文件服务器复制磁盘映像并启动 Windows 安装程序。
ghost和iso文件区别 GHOST文件后缀名为gho，ISO文件扩展名师iso。
一般是由备份工具Ghost软件备份系统后产生的文件格式
ghost GHO文件是用ghost工具备份硬盘（C盘D盘）后的文件格式，既然可以备份C盘，也就是备份系统 所以GHO文件你可以理解为系统文件。再用相应的工具还原GHO文件到C盘上，你就重装系统了。gho文件是硬盘或分区的的克隆镜像文件，可用ghost程序恢复系统或整个硬盘。gho可能存在一些问题：蓝屏是常见现象，因为gho备份的时候磁盘的信息和驱动也备份进去了，还原时候，会修改磁盘信息，会破坏磁盘。另外如果备份的驱动和你电脑不匹配，就会出现蓝屏以及其他的问题，如驱动不兼容。 iso 利用iso文件全新安装一个系统，像新电脑第一次激活。 UEFI启动和legacy启动 legacy是传统BIOS，uefi是新式的BIOS。在legacy模式下安装的系统，只能在legacy模式下进系统。同理，如果是在uefi模式下安装的系统，也只能用uefi模式引导。uefi和legacy是两种不同的引导方式，UEFI引导windows系统的文件为winload.efi，而legacy引导windows系统的文件为winload.exe。legacy是传统模式的电脑引导模式，它可以引导32位的操作系统，也可以引导64位的操作系统，而uefi不能引导32位操作系统，只能支持64位的操作系统。目前基本是uefi启动
查看自己的电脑是哪种模式？ 按下快捷键WIN + R 或者点击开始菜单，输入运行在弹出的运行窗口中，输入“msinfo32”在系统信息中，找到BIOS模式，即可看到本机的BIOS模式信息 u盘格式化常见的格式 Fat32格式：一般用作系统安装镜像的格式，用UltraISO(软碟通)制作启动U盘，默认就是Fat32格式。UEFI启动是只能用Fat格式，但只能存储4G以下的文件，目前新版的系统镜像都是大于4G，所以NTFS格式：默认格式，平时用来存储文件就用这个格式，能存储4G+的文件大小，但不支持UEFI启动。 安装方案 大白菜/老白菜，一键制作 优点：简单，提供了安装界面，里面有分区工具等。好像是NTFS格式，可以避免4G文件限制。
都可以直接在百度上搜索下载使用。
问题记录 大白菜：一键安装系统，会自动创建一个Administrator账号，开机就会显示的名称，个人不喜欢，如果没什么要求这样也行。进去改
老白菜：一键安装系统，就不会自动创建Administrator账号，要一步一步从开始的引导页面输入相关信息，个人比较喜欢这种。
注意：win11开始微软推荐使用Microsoft账号，但不想用云端账号也可以使用本地账号。
UltraISO(软碟通)写入ISO镜像 官方界面安装系统程序，好像没什么特别的优点。可能会出现以下问题
问题记录 报错如下： Windows无法打开所需的文件 F:\Sources\install.wim。请确保安装所需的所有文件可用，并重新启动安装。错误代码：0x8007000D
原因：写入U盘的安装文件中，source目录下的install.wim出现了问题。用UltraISO(软碟通)等软件，烧录镜像，默认会格式成Fat32格式，但Fat32格式不支持4G以上的文件。烧录的镜像大概有5G，造成写入数据不全，但奇怪软件没有提示。
使用系统自带的dism命令拆分文件 UEFI不支持NFTS文件系统的启动U盘。
先用UltraISO(软碟通)等软件，烧录镜像，默认会格式成Fat32格式，但Fat32格式不支持4G以上的文件。
使用系统自带的dism命令工具将原镜像文件中的install.wim拆分为多个小的文件，并拷贝到启动U盘里面的source下。例如会形成2个文件：install.swm和install2.swm来替代install.swm。
用管理员打开CMD命令提示符
dism /Split-Image /ImageFile:@:\sources\install.wim /SWMFile:@:\sources\install.swm /FileSize:3800
命令中的第一个@改为win10镜像虚拟光驱的盘符，第二个@改为U盘盘符。
参考 U盘安装Windows10系统报错无法打开文件install.wim原因及解决办法dism-解决FAT32格式U盘安装win10时0x8007000D错误想要重装系统并且UEFI启动？ESP、GUID等你了解清楚吗-esp文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e04927ffe191e2826e9b98551824f143/" rel="bookmark">
			android获取设备内存大小及精度问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Android获取设备内存大小有两个问题需要解决：
1.类MemoryInfo的使用
2.注意最后结果的double精度问题。
我这里用的是在fragment中获取，如果你是Activity的话，稍微改动一下就行。
ActivityManager activityManager = (ActivityManager) requireActivity().getSystemService(Context.ACTIVITY_SERVICE); ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo(); activityManager.getMemoryInfo(memoryInfo); float memorySize = (float)memoryInfo.availMem/(1024*1024*1024); Log.e(TAG, "memorySize= "+ String.format("%.2f",memorySize) + 'G'); float totalMemory = (float)memoryInfo.totalMem/(1024*1024*1024); Log.e(TAG, "totalMemory= "+ String.format("%.2f",totalMemory) + 'G'); 关于int 转double或者float，我觉得直接强转比较方便，当然也可以使用Double.valueof(int)来实现：
int a = 55; double b = Double.valueOf(a); 再使用String.format("%.2f", decimalValue);获取对应值。 这里是两位小数的精度 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75220fcae44ac3c37a3f0537ceaba6f0/" rel="bookmark">
			数据质量管理深入浅出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		质量是生活中最常关注的话题，我们都期望享用高质量的商品与服务，且企业也不断加大质量管理的投入，为了更好的用户体验。
在企业数字化转型浪潮下，传统手段已无法应对数字化转型中的数据质量管理需求，我们需要探索出一条数据独有的质量管理体系应对新的需求。
本篇文章以数据质量管理为目标，探究数据质量背后的逻辑，并通过管理与技术手段进行落地。
一、概述 1、数据质量 数据质量就是通过一组维度来评价数据的方式，如同判断商品的好坏一样，数据也有评价标准。
数据是对现实世界的反映，如果当前数据代表的意义与现实世界不符，则认为数据出了质量问题。
2、质量问题原因 追根溯源，导致数据出现质量问题的原因有很多，总的来看，主要有业务、技术、管理、基础设施四个方面：
业务端： 业务源系统变更（源系统数据库表结构变更、源系统环境变更）、业务端数据输入不规范等；技术端： 数据开发任务中各种任务的流程、参数、配置等出错；管理端 ： 认知层面缺乏质量意识、缺乏有效的数据质量问题处理机制等；基础设施： 物理资源不足、基础设施不稳定等。 3、数据质量评判标准 准确性：
数据描述的信息与客观现实是否相符，准确性是数据质量中最重要的评价标准。完整性：
当前数据是否存在丢失、关键字段为空、或者不可用的情况，主要包括：实体完整、属性完整、记录完整和字段值完整。一致性：
多源数据是否遵循了统一的规范，数据集合是否保持了统一的格式。规范性：
数据是否遵循预定的语法规则并符合其定义，例如数据的类型、长度、格式、取值范围等。唯一性：
当前数据是否有重复，是否存在唯一标识保证数据的唯一性，包括：主键唯一，实体唯一，事件唯一及时性：
数据从产生到可以查看的时间间隔。数据分析对于及时性要求不高，但如果数据分析周期过长，可能导致分析结论失去借鉴意义。 4、数据质量管理 数据质量管理（Data Quality Management），是指对数据生命周期的每个阶段可能引发的数据质量问题，进行识别、度量、监控、预警等一系列管理活动，并通过改善和提高组织的管理水平使得数据质量获得进一步提高。
通俗点说就是：能够确保数据质量的管理活动，我们称其为数据质量管理。
二：意义 下图即可说明：
三：当前痛点 1、决策导向不可控（重中之重） 目前国内企业掀起了一波数字化转型的浪潮，数据作为生产要素的价值也愈发凸显出来。依赖错误的数据做出的决策，必然会将企业导向错误的方向。在此背景下，数据质量被越来越多的企业管理者重视。
2、数据使用成本高 数据质量较低，导致在数据使用过程中，开发人员需要反复对数据进行校准（准确性）、补全（完整性）、校对（一致性）、转义（规范性）、去重（唯一性）等操作，确保结果真实可用。数据使用成本激增。
3、故障恢复成本高 数据质量导致的问题，最后都会反馈到员工以及用户之中，到时无论是排错，修复，决策调整，都会占用开发-业务-管理人员大量的时间精力，增加人力成本开支。
四：主要目标 1、成本可控 高质量的数据在开发时可以省去数据清洗与预处理的成本，提高开发效率并大幅降低故障率，从而节省出大量的开发与使用成本，减少故障恢复的投入。
2、结果可靠 高质量的数据产出可靠的统计结果与报表。
3、协作高效 依据可靠的结果进行协作，降低了校对以及沟通成本，提高协作效率。
五：数据质量管理落地实施 1、痛点为导向 首先需要明确一点，数据质量在绝大多数的数据平台建设中，都不会作为前期建设的主要重点。
数据质量的建设一般不会以需求为导向，即在平台建设过程中就规划相关内容并进行开发迭代，平台建设的前期一般以业务产出为主。
平台建设完成后，数据质量相关痛点愈发凸显，导致平台遭受质疑，数据使用成本升高，此时数据质量才会被重点关注，并投入大量精力去进行整改优化。
2、事前规范 规范制定
在数据流程正常运行的前提下，大部分数据质量问题均是因为没有遵循开发规范导致。我们可以根据数据质量特性制定相关开发规范并在事前进行遵守。
数据模型规范：
数据结构清晰、分层明确-层级依赖、高内聚-低耦合-可扩展、规范化-反规范化等。元数据规范：
字段描述、字段类型-长度-取值范围、枚举范围、主键唯一等。命名规范：
表、字段名称，项目名称，文件名称、函数名称、编码规范等。安全规范：
隐私字段脱敏、权限层级管控等。上线规范：
唯一性校验、试运行正常、数据条数校验、NULL 值校验等。 规范核验
针对已经制定的开发规范，需要采取自动化或人工手段进行规范校验，并提醒相关责任人进行整改，否则规范只是流于表面。
3、事中监控（数据质量监控系统） 数据质量的落地实施，最核心还是需要通过数据质量监控系统，通过自动化的质量检核方式，极大的减少人力的投入和过程干预，提升效率，减少误差。围绕完备性、真实性性、一致性、及时性等指标监控分析数据质量问题并进行整改优化。
监控规则制定
引用系统定义的校验规则对系统表、字段进行多角度的数据质量监控，对系统关键业务数据的质量情况进行全方位把握，监控规则分为字段级与表级监控，具体包含以下几种：
唯一值监控： 监控某个字段值是否唯一，例如 ID，如果唯一值字段出现重复数据，则代表数据质量异常。空值监控： 某个字段必须有值，例如付款记录中的金额。此规则监控此类字段是否为空，为空则判断异常。指标波动监控： 某个指标例如 GMV，如果当天指标比昨天暴涨 10 倍，大概率为异常。取值范围监控： 例如年龄字段，值是否超过常规范围。枚举字段，值是否超过定义范围。记录数量波动监控： 如果当前表日均增加 1W 条记录，某天新增超过 2W 条，大概率出现异常。数据规范校验： 字段格式规范（例如时间字段是否按照指定格式）， 监控异常告警
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75220fcae44ac3c37a3f0537ceaba6f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1395662e47965189a396e7ec48a0a7d7/" rel="bookmark">
			antd中的a-select组件既可手动输入又可下拉选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有一个需求：让下拉框既可下拉选择也可手动输入，在antd官网看了下，并没有看出啥名堂（实践证明还是缺乏前端经验，特记录下，希望对有此需求的小伙伴们提供帮助，如有问题，希望指导，以免误导他人） 本文基于vue和ant design 直接上代码 下拉框是组件库自带的，主要是手动输入。亲测有效，除了业务逻辑外，其他可以直接复制即可 html： &lt;a-select v-model="newSoftName" show-search option-filter-prop="children" style="width: 230px" :filter-option="filterOption" @blur="handleBlur" @change="newHandleChange" &gt; &lt;a-select-option v-for="(item, index) in newSoftNameList" :key="index" :value="item"&gt; {{ item }} &lt;/a-select-option&gt; &lt;/a-select&gt; js: newHandleChange(value) { // console.log(`selected ${value}`); axios({ url: '', method: '', params: }).then(res =&gt; { // 业务逻辑 }).catch(err =&gt; { console.log(err) }) }, handleBlur() { // this.isSelected = false // this.getdictionarySoftType() }, filterOption(input, option) { // 重要的一步，可以console.log(input)看下输入的是啥 this.newSoftName = input // 在此前是可以手动输入，但鼠标离开后，输入的内容不能在输入框内保存，将input的值给到a-select标签的v-model绑定的newSoftName即可实现将手动输入的值赋值给input return ( option.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1395662e47965189a396e7ec48a0a7d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c4d627adff95b77cf84a9c713383dd/" rel="bookmark">
			没有开发经验的程序员，怎么快速学习进入工作？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在群里，Ace老师遇到一位没有开发经验的同学，他的情况是这样的。
问题 Ace老师：
有一些伙伴，我现在真的没有想到太好的方法去教他，我跟大家讲一下他目前的情况，你们有经验的来和他说说这样的情况应该怎么学习。是群里面的人。
Ace老师：
他现在情况就是什么呢？自己约等于0，基础什么都不懂。但是就这样还找到工作了。到了单位之后想学习，但是立马就布置了任务。但是布置的任务呢，基本上都不会。所以他只能问我和问群里面有些东西还是依托于他们公司的业务，这就让我很头疼。一个几乎是零基础的，又没时间学习，工作上面的问题基本就靠one问题去解决，但是如果跟公司业务签的比较紧，问问题可能我们也看不出到底在哪。
Ace老师：
而且很多东西我们说了答案，他还不一定能看懂，这就进入一个比较不好的循环中。首先自己没有基础。然后公司任务压的又紧。又没时间学。靠问问题。但是给的答案还不一定能看得懂。这种情况各位小伙伴有没有遇到过？换了你们这样应该怎么去学习？
Ace老师：
可以把经验都提供出来，帮帮这位小伙伴。
小伙伴的答案 我的想法 我就是这样的情况，先搞增、删、改、查；再搞登录，
这几项会了，几乎业务上就通吃了。
※如果停留在这个阶段，只是会写一些代码。如果要想自己的写的东西用户体验好，得多看看同行的产品，想要提升代码质量，多看一些优秀的代码
※进阶：看看ACE老师的论坛， 从0仿制下来；还有一些其他项目的实战；多搞搞 不出三个月，会有一个质的提升。
※只要功夫深，铁柱磨成针。
视频资料 Ace老师的博客
全栈ACE的个人空间-全栈ACE个人主页-哔哩哔哩视频
最新C#/.NET7 零基础到多项目实战大全(C#/SqlServer/MySQL/WPF/Winform/NetCore/HTML/CSS/JS)
2023年最新C#/.NET7 零基础到多项目实战大全(C#/SqlServer/MySQL/WPF/Winform/NetCore/HTML/CSS/JS)_哔哩哔哩_bilibili
最新C#/.Net 6 零基础到多项目实战大全(C#/SqlServer/MySQL/WPF/Winform/NetCore/HTML/CSS/JS)
2021年最新C#/.Net 6 零基础到多项目实战大全(C#/SqlServer/MySQL/WPF/Winform/NetCore/HTML/CSS/JS)_哔哩哔哩_bilibili
最新C#/.NET 7.0 供求信息网项目实战（SQL Server/EF Core/ORM/反射/Vue 3/WebAPI）
2022最新C#/.NET 7.0 供求信息网项目实战（SQL Server/EF Core/ORM/反射/Vue 3/WebAPI）_哔哩哔哩_bilibili
BBS实战录制教程
全栈ACE的个人空间-全栈ACE个人主页-哔哩哔哩视频
博客系统开发-上部（C#/.NET6/Mysql/Vue单页面）
博客系统开发-上部（C#/.NET6/Mysql/Vue单页面）_哔哩哔哩_bilibili
博客系统开发-中部（C#/.NET6/Vue单页面/MySQL）
博客系统开发-中部（C#/.NET6/Vue单页面/MySQL）_哔哩哔哩_bilibili
博客系统开发-下部（C#/.NET6/MySQL/Vue单页面）
博客系统开发-下部（C#/.NET6/MySQL/Vue单页面）_哔哩哔哩_bilibili
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ddd0f5b701c8fc45688698cf7e36737/" rel="bookmark">
			MATLAB-自动控制原理-时域分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
step函数（求阶跃响应）:
impulse函数（求脉冲响应）:
lsim函数（求输出）:
1，求二阶系统不同阻尼比条件下的阶跃响应曲线
2，求二阶负反馈系统的动态性能指标 利用MATLAB可以方便地进行控制系统的时域分析。洋相判断系统的稳定性，只要求出系统的闭环极点，即闭环传递函数的分母多项式的根即可，而分析系统的动态特性，只要求出系统的阶跃响应即可。
利用MATLAB控制系统工具箱中所提供的求联系系统的单位阶跃响应函数step(),单位冲激响应函数impluse(),任意输入信号下的响应函数lsim()等函数可以方便的求出系统在该信号作用下的响应。
step函数（求阶跃响应）: step(num,den)
num表示分子各阶系数，den表示分母各阶系数
作用：已知闭环传递函数，求其阶跃响应
step(num,den)会输出图像；ct2=step(num,den)输出数值。
impulse函数（求脉冲响应）: impulse(num,den)
num表示分子各阶系数，den表示分母各阶系数
作用：已知闭环传递函数，求其脉冲响应
impulse(num,den)会输出图像；ct2=impulse(num,den)输出数值。
lsim函数（求输出）: lsim(sys,u,t)
sys传递函数，u 输入函数，t时域自变量
作用：已知输入函数和传递函数，用这个可以的到每次系统的输入对应的输出（输入函数u要是时域中的，可以输出图像也可以是对应的值）
1，求二阶系统不同阻尼比条件下的阶跃响应曲线 已知典型二阶系统的传递函数为
假设Wn=1，试在同一张图上绘制当阻尼比分别为0、0.1、0.3、0.5、0.7、1、2时系统的单位阶跃曲线
dum=[4]; den1=[1 0 4]; den2=[1 0.4 4]; den3=[1 1.2 4]; en4=[1 2 4]; den5=[1 2.8 4]; den6=[1 4 4]; den7=[1 8 4]; sys1=tf(dum, den1); sys2=tf(dum, den2); sys3=tf(dum, den3); sys4=tf(dum, den4); sys5=tf(dum, den5); sys6=tf(dum, den6); sys7=tf(dum, den7); step(sys1, sys2, sys3, sys4, sys5, sys6, sys7); 可以看到阻尼比为0时无法收敛，其他阻尼比均收敛
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ddd0f5b701c8fc45688698cf7e36737/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c532a1c317aef1d81ddda5d1f27f93be/" rel="bookmark">
			Exynos4412 移植针对Samsung的Linux-6.1（二）SD卡驱动——解决无法挂载SD卡的根文件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 Exynos4412 移植针对Samsung的Linux-6.1（一）下载、配置、编译Linux-6.1Exynos4412 移植针对Samsung的Linux-6.1（二）SD卡驱动——解决无法挂载SD卡的根文件系统Exynos4412 移植针对Samsung的Linux-6.1（三）SD卡驱动——解决mmc0: Timeout waiting for hardware interrupt.Exynos4412 移植针对Samsung的Linux-6.1（四）NandFlash卡驱动Exynos4412 移植针对Samsung的Linux-6.1（五）DM9000网卡驱动 Exynos4412 移植针对Samsung的Linux-6.1（二）SD卡驱动 系列文章目录1、检查Linux内核的配置2、修改设备树3、解决无法挂载SD卡的根文件系统 Linux对于SD的支持是很全面的、很完善的。按道理来说，移植SD卡应该很简单。但是，我在移植SD卡驱动的时候，碰到了2个问题：
加载SDMMC驱动正常，但是无法发现SD卡无法挂载SD卡上的根文件系统 解决以上问题仍然花费了很长时间解决问题。问题的解决，关键是对设备树的修改。现记录下来，供大家参考以避坑。
由电路图可以看出，SD卡用到了CLK、CMD、DATA和CD这4类引脚。WP引脚是写保护，电路上是接地的，根本就不起作用。我这次出问题，就出在CD这个引脚上。CD引脚是用来检测是否插入SD卡的，当SD卡插入时引脚电平会被拉低。
另外，开发板上是接到了SDMMC2控制器上。
1、检查Linux内核的配置 执行了make exynos_defconfig之后，默认是配置加载SDMMC驱动的。但是，还是检查一下为好。有2个地方，一是Device Drivers ；另一个是File systems,要想支持中文还得选上Simplified Chinese charset 。
Device Drivers —&gt;
&lt;*&gt; MMC/SD/SDIO card support —&gt;
&lt; &gt; ARM AMBA Multimedia Card Interface support
&lt;*&gt; Secure Digital Host Controller Interface support
&lt; &gt; SDHCI platform and OF driver helper
&lt;*&gt; SDHCI support on Samsung S3C/S5P/Exynos SoC
[*] DMA support on S3C SDHCI
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c532a1c317aef1d81ddda5d1f27f93be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46012f5dbba3237e4492837aecd4c61f/" rel="bookmark">
			函数间参数传递的3种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、值传递：将主调函数的实参值传递给被调函数的形参。形参单独分配内存。 单向数据传递机制：只能将主调函数的实参的值传递给被调函数的形参，形参改变不影响实参的值。
#include
using namespace std;
void swap (int a, int b) {//实现形参a、b的交换
int c;
c = a;
a = b;
b = c;
}
int main() {
int x = 2, y = 3;
swap(x, y);//实参x,y的值并没有交换。值传递的单向数据传递机制
cout &lt;&lt; x&lt;&lt; " "&lt;&lt;y&lt;&lt; endl;//2 3
return 0;
}
2、引用传递：被调函数的形参（引用类型）引用主调函数的实参值。间接访问。 双向数据传递机制：引用&amp;，指向同一内存，其一改变，两者都改变。
函数中局部变量不能被其他函数直接访问，但可以被间接访问。
#include
using namespace std;
void swap (int &amp;a, int &amp;b) {//引用变量a、b，等效int &amp;a=x;int &amp;b=y;
int c;
c = a;
a = b;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46012f5dbba3237e4492837aecd4c61f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5472986f574ff17708fa6f2f55e4d18/" rel="bookmark">
			程序员必须收藏的网站整理（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为《程序员电脑必备软件整理（持续更新）》的姊妹篇，本文整理我认为有价值的网站链接，希望对你有所帮助
目录
1 论文相关
1.1 paperswithcode
1.2 paperweekly
1.3 sci-hub
1.4 快期刊
2 代码相关 2.1 DevDocs
2.2 stack overflow
2.3 visualgo
3 图书相关
3.1 Z-Library
3.2 熊猫搜书
​​4 PPT相关
4.1 图标下载
4.2 图片下载
4.3 模板下载
4.4 在线流程图
4.5 logo设计
5 其它
5.1 RAW pixels viewer
5.2 专利在线网
5.3 aconvert
5.4 canva
5.5 visualdata
5.7 135微信编辑器
5.8 在线公式编辑器
5.9 PDF24 Toos
5.10 显卡比较
1 论文相关 1.1 paperswithcode 链接：The latest in Machine Learning | Papers With Code
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5472986f574ff17708fa6f2f55e4d18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0caa54bd3ffaba5ff7d058c2134ea2e4/" rel="bookmark">
			基于51单片机的全自动洗衣机系统设计-protues原理图、程序（转发）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 本文详细介绍了国内洗衣机控制系统的发展现状，发展中所面临的问题。从产品质量、性能及应用方面看洗衣机的差距，同时也详尽的介绍了此次设计中最重要的组成部件单片机的概念、工作原理及设备总体结构。根据洗衣机的控制要求，从功能要求、硬件设计、软件设计三个方面描述了一个以AT89C51单片机为核心的洗衣机控制电路系统。基于AT89C51单片机的洗衣控制系统,控制面板由按键、指示灯组成.按键选择洗衣机工作方式,指示灯配合按键工作。洗衣机的整体电路模块包括键盘矩阵、指示灯、电动机控制及电源电路.控制程序设计包括定时中断服务程序、外中断服务程序及主程序。
关键词：洗衣机；单片机；控制面板
该洗衣机控制电路系统的硬件电路框图如图4.1所示，在该硬件系统中主要由核心单元电路、进/排水阀控制电路、电机控制电路、按键和开关电路、输出控制电路、特殊功能电路、电源电路等单元组成。
图4.1 硬件电路框图
在设计过程中采用AT89C51作为控制核心。其中P1.0到P2.0分别控制标准经济、单独、排水、强洗、弱洗、洗涤、漂洗、脱水的LED指示灯。由于AT89C51每根I/O线的低电平驱动电流达到20mA，所有I/O线的总驱动电流达80mA,而这7个灯最多只有3个灯同时亮，每个灯只需3.5mA左右的电流，再算上其它I/O线的驱动电流，总电流也不会超过80mA,所以可这样直接驱动LED发亮；P3.0接程序选择键，P3.1接强弱选择键，P3.2接暂停/启动/解除警报键，P3.6接水位开关，用于进/排水过程中的水位控制，为CPU提供洗衣机水位信息，P3.7接盖开关，这是安全保护措施，P2.1来控制蜂鸣器，P2.2引脚来控制进水阀和进水状态显示灯，P2.3引脚来控制排水阀和排水状态显示灯，单片机的复位引脚RST接洗衣机的强制复位键。
进/排水阀电路图如图4.5所示：
图4.5 进、排水阀电路图
在控制系统中，分别用P2.2和P2.3两引脚控制进水阀和排水阀的开启和关闭。当引脚被设置为高电平，电磁阀开启：当引脚被设置为低电平，电磁阀关闭。
论文内容 仿真电路 程序 /***************************头文件***********************/ #include &lt;reg51.h&gt; /************************数据类型宏定义******************/ #define uchar unsigned char #define uint unsigned int /***********************使能、禁止宏定义*****************/ #define Enable(); EA=1; #define Disable(); EA=0; /********************程序选择功能标志宏定义**************/ #define BIAOZHUN 0 #define JINGJI 1 #define DANDU 2 #define PAISHUI 3 /********************强弱选择功能标志宏定义**************/ #define QIANGXI 0 #define RUOXI 1 /*******************进水、排水时间限制宏定义*************/ #define T_JinShui 10 //4min*60s #define T_PaiShui 10 //1min*60s #define T_XiDi 10 //6min*60s #define T_PiaoXi_1 10 //4min*60s #define T_PiaoXi_2 10 //2min*60s #define T_TuoShui 10 //2min*60s /**********************电机控制宏定义********************/ #define ZHENGZHUAN 0 #define STOP 1 #define FANZHUAN 2 #define ZhengZhuan(); PIN_Motor_A = 0; PIN_Motor_B = 1; #define Stop(); PIN_Motor_A = 1; PIN_Motor_B = 1; #define FanZhuan(); PIN_Motor_A = 1; PIN_Motor_B = 0; /*******************暂停、继续控制宏定义*****************/ #define ZanTing(); ET0 = 0; ET1 = 0; Stop(); #define JiXu(); ET0 = 1; ET1 = 1; /*************************管脚定义***********************/ //都是低有效，因LED是灌电流，而PNP也是低电平时导通 sbit LED_BiaoZhun = P1^0; //标准程序显示灯 sbit LED_JingJi = P1^1; //经济程序显示灯 sbit LED_DanDu = P1^2; //单独程序显示灯 sbit LED_PaiShui = P1^3; //排水程序显示灯 sbit LED_QiangXi = P1^4; //强洗状态灯 sbit LED_RuoXi = P1^5; //弱洗状态灯 sbit LED_XiDi = P1^6; //洗涤状态灯 sbit LED_PiaoXi = P1^7; //漂洗状态灯 sbit LED_TuoShui = P2^0; //脱水状态灯 sbit PIN_BaoJing = P2^1; //报警喇叭 sbit PIN_JinShui = P2^2; //进水控制 sbit PIN_PaiShui = P2^3; //排谁控制 sbit PIN_Motor_A = P2^4; //电机脚A sbit PIN_Motor_B = P2^5; //电机脚B sbit K_SEL_ChengXu = P3^0; //选择程序键 sbit K_SEL_QiangRuo = P3^1; //选择强弱键 sbit p32 = P3^2; // sbit p33 = P3^3; // sbit SW_ShuiWei = P3^6; //水位开关 sbit SW_AnQuan = P3^7; //安全开关 /************************函数申明***********************/ void Programme_PaiShui(void); /*************************数据定义***********************/ uchar flag_SEL_ChengXu; //默认为标准程序， bit flag_SEl_QiangRuo; //默认为强洗，1为弱洗 bit flag_Run; //运行标志，1为运行 //bit flag_ZanTing; //暂停标志，1为暂停 bit flag_JinShui; //进水标志，1为进水 bit flag_PaiShui; //排水标志，1为排水 bit flag_XiDi; //置洗涤标志 bit flag_PiaoXi; //置漂洗标志 bit flag_TuoShui; //脱水标志 bit flag_BaoJing; //报警标志 uchar _50ms; //每50ms加一次的变量 uint s; //秒 uint T_S; //定时总时间 uchar T_Motor; //电机控制时间 /*************************延时程序*********************/ void Delay_10ms(uint T1) { uint t1,t2; for(t1=0;t1&lt;T1;t1++) for(t2=0;t2&lt;1250;t2++);//10ms } /**********************管脚初始化程序******************/ void Pin_Init(void) 编号1663，转发自：https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0caa54bd3ffaba5ff7d058c2134ea2e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd8d844eb0b8d68f248e5ff58867f7a5/" rel="bookmark">
			x86汇编语言给段寄存器赋值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给段寄存器赋值，必须先把值赋给通用寄存器，再送入段寄存器；
如下图指令运行结果如下；
给附加段寄存器es赋值也是；
如果直接把立即数赋给段寄存器，将出错；
cannot use segment register with an immediate value；
不能把立即数赋给段寄存器；
为什么立即数不能直接赋给段寄存器，根据网上资料，
由于立即数直接写入段寄存器这样的指令，被翻译成机器码之后将占用更多的字节，在事先规定的指令长度范围内无法存贮下这么多的内容，因此改由先写入通用寄存器，再由通用寄存器写入段寄存器的办法代替。立即数实际上是相当占地方的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aff3c6ca38196828e9f05169681c8b8/" rel="bookmark">
			ubuntu 防火墙命令整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、防火墙状态及规则 1.1、查看防火墙状态：firewall-cmd --state
[root@localhost ~]# firewall-cmd --state running [root@localhost ~]# 1.2、查看防火墙：firewall-cmd --list-all
[root@localhost ~]# firewall-cmd --list-all public (active) target: default icmp-block-inversion: no interfaces: eth0 sources: services: dhcpv6-client http ports: 999/tcp protocols: # ... 1.3、更新防火墙规则：firewall-cmd --reload
[root@localhost ~]# firewall-cmd --reload success [root@localhost ~]# 2、端口 2.1、临时增加(reload之后消失)：不需要reload
[root@localhost ~]# firewall-cmd --add-port=999/tcp success 2.2、永久增加：reload后生效
[root@localhost ~]# firewall-cmd --permanent --add-port=999/tcp success 2.3、临时删除端口：reload后消失
[root@localhost ~]# firewall-cmd --remove-port=999/tcp success 2.4、永久删除端口：reload后生效
[root@localhost ~]# firewall-cmd --permanent --remove-port=999/tcp success 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5aff3c6ca38196828e9f05169681c8b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17df078db04916317d8d154df58c0d7e/" rel="bookmark">
			ES（elasticSearch学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是es es是面向文档型的数据库，一条数据在es数据库就是一个文档，和关系型数据库做一个类比：
1：es的索引类比关系型数据库的数据库，
2：es的type类比数据表（7.0版本以上删除了type这个概念），
3：es的索引下的文档document类比关系型数据库的行，新增时可以指定文档主键id,不指定会自动生成
4：es的文档中的字段类比关系关系型数据库的列。
现实生产中一般一个索引类似张表，但是一个索引下的字段还可以是一个对象,可以嵌套。
match每一次全文搜索分词是针对某一个字段的，可以是嵌套搜索，一次全文搜索不是针对整个索引的全部字段，想要同时全文搜多个字段可以一次请求中match多个字段
put请求新建索引，post/put请求新增数据，新增的数据就是一个文档，新增会有一个文档id就是索引下一个数据的主键
涉及的操作索引的增删改查和文档的增删改查
什么是倒排索引 es基本入门操作 1.安装访问
在本地es执行目录：/Users/liuqinhua/Desktop/错误/elasticsearch-7.6.2/bin
执行可执行文件：./elasticsearch
访问
2.创建索引put请求http://localhost:9200/liuqinhua（liuqinhua是索引名）
3**.get请求查看索引信息**：http://localhost:9200/索引名
例如：http://localhost:9200/liuqinhua
4.get请求查看所有的索引:http://localhost:9200/_cat/indices?v
这时候他是强制返回的内容是text格式的，所以会展示成表格的格式
5.delete请求删除索引wudonghui：http://localhost:9200/索引名
例如：http://localhost:9200/wudonghui
6.post请求给索引新增文档数据http://localhost:9200/索引名字/_doc
eg：http://localhost:9200/liuqinhua/_doc
这种会返回文档id
或者post或者put请求：http://localhost:9200/liuqinhua/_doc/自定义文档id
7.get请求查询索引的数据
查询某一个文档id内容
http://localhost:9200/索引名/_doc/文档id
例如：http://localhost:9200/liuqinhua/_doc/1001
get请求查询某一个索引下所有的文档
http://localhost:9200/索引名/_search
例如：
http://localhost:9200/liuqinhua/_search
put请求根据索引下的主键id全量修改更新某一条文档数据
格式：http://localhost:9200/索引名/_doc/数据主键id
eg:http://localhost:9200/liuqinhua/_doc/1001
put全量会把该主键id的文档数据变成这一次传入的
再更新一下：
post请求局部更新某索引下某主键文档id数据
http://localhost:9200/索引名/_update/文档主键id
eg:http://localhost:9200/liuqinhua/_update/1001
delete请求删除索引下某主键的文档
格式http://localhost:9200/索引名/_doc/文档主键id
条件查询 url拼接查询条件
格式：http://localhost:9200/liuqinhua/_search?q=文档下一级key :文档下一级value
二级的key-value是搜不出来的
查询条件放requestbody进行查询放入query-match里面
放requestbody全量查询索引下文档
分页查询
get请求http://localhost:9200/索引名/_search加reqbody里面的多条件查询和范围查询 reqbody内容
{ "query":{ "bool":{ "should":[// must相当于mysql的and,should相当于or { "match":{ "uname" :"forbidden" //"gender":26 } }, { "match":{ //"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17df078db04916317d8d154df58c0d7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/460b66f616f68d815e830126eb96bab7/" rel="bookmark">
			Hashmap 的源码解析以及put流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Hashmap的定义 Hashmap是一种常用的数据结构，底层是基于数组和链表实现的。
二.Hashmap的详情结构 2.1 数据结构 HashMap提供了三个构造函数：
HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。
HashMap(int initialCapacity)：构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。
HashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和加载因子的空 HashMap。
在这里提到了两个参数：初始容量，加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。
加载因子：0.75，在容量达到0.75时，进行扩容。
2.2 整体的数据结构
简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key查找到索引位置，然后通过对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。
2.3 put操作的代码分析 2.3.1 entry类
其中Entry为HashMap的内部类，它包含了键key、值value、下一个节点next，以及hash值，这是非常重要的，正是由于Entry才构成了table数组的项为链表。
概图浏览：
一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。
2.3.2 PUT操作
两个key通过hash%Entry[].length得到的index相同，会不会有覆盖的危险？为了解决这个问题，HashMap里面用到链式数据结构的一个概念。上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。打个比方， 第一个键值对A进来，通过计算其key的hash得到的index=0，记做:Entry[0] = A。一会后又进来一个键值对B，通过计算其index也等于0，现在怎么办？HashMap会这样做:B.next = A,Entry[0] = B,如果又进来C,index也等于0,那么C.next = B,Entry[0] = C；这样我们发现index=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起。所以疑问不用担心。也就是说数组中存储的是最后插入的元素。到这里为止，HashMap的大致实现，我们应该已经清楚了。
上图中代码的意思：key的hashcode值一样且key串内容也一样
如《liu，23》，《liu，34》；存储逻辑为：
createEntry方法中：表达的逻辑为：如图
Put方法的逻辑过程：
1.首先判断key是否为null，若为null，则直接调用putForNullKey方法。
2.若不为空则先计算key的hash值，然后根据hash值搜索在table数组中的索引位置，
static int indexFor(int h, int length) {
return h &amp; (length-1);
}
计算存储位置的方法，hashcode和长度-1做与运算
2.1.若该位置没有元素，则直接插入。
2.2.如果table数组在该位置处有元素，则依次迭代遍历元素的key的内容值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/460b66f616f68d815e830126eb96bab7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37fee78057f04b58d39d0839be51d303/" rel="bookmark">
			Java开发实现图书管理系统（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文用Java代码实现图书代码管理系统，有些地方可能会有纰漏，希望各位大佬鉴赏！！ 文章目录 文章目录
一、Java实现图书管理系统
1.1创建book包
二、创建图书管理系统的操作包
2.1创建Operation接口
三、创建User包
3.1创建User类
四、主函数的实现
一、Java实现图书管理系统 1.1创建book包 首先在book中要创建Book类和BookList类，进行封装图书，在Book类中要有书名，作者，价格，类型和是否被借出图书。在BookList类中是书架对图书的封装，进行图书初始化和对图书设置的各种方法。
Book类的实现
package book; /** * @author xyk的电脑 * @version 1.0 * @description: TODO * @date 2023/1/24 13:48 */ public class Book { private String name;//书名 private String author;//作者 private int price;//价格 private String type;//类型 private boolean isBorrowed;//是否被借出 public Book(){ } public Book(String name, String author, int price, String type) { this.name = name; this.author = author; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37fee78057f04b58d39d0839be51d303/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac49e29facbba5b6502428ec776a513f/" rel="bookmark">
			YOLOV5-7.0源码阅读（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		def parse_opt(known=False): ''' store_false,则默认值是True，store_true,则默认值是False '--weights'训练的权重路径,可以使用自己训练的权重,也可以使用官网提供的权重 '--cfg', 模型参数配置文件路径 '--data',配置数据文件路径, 包括image/label/classes等信息, 训练自己的文件, 需要作相应更改, 如果设置了只显示个别类别 即使用了--classes = 0 或二者1, 2, 3等, 则需要设置该文件，数字和类别相对应才能只检测某一个类 '--hyp',超参数设置 '--epochs',模型训练的最大轮数 '--batch-size',模型训练时batch的大小,-1为自动定义batch的size '--imgsz', '--img', '--img-size', 训练，验证图像的size(pixel) '--rect',否采用Rectangular training/inference(是否采用矩阵推理的方式去训练模型)，一张图片为长方形，我们在将其送入模型前需要将其resize到要求的尺寸，所以我们需要通过补灰padding来变为正方形的图。 但是这个操作会生成过多的冗余信息影响训练效果。 所谓矩阵推理就是不再要求你训练的图片是正方形了；矩阵推理会加速模型的推理过程，减少一些冗余信息。 '--resume',接着上一次中断的结果继续训练 '--nosave',只保存最后一次 pt 文件，默认False '--noval',只在最后一次进行测试，默认False '--noautoanchor',是否禁用自动调整anchor文件，默认False '--noplots',开启这个参数后将不保存绘图文件。 '--evolve',遗传超参数进化；yolov5使用遗传超参数进化，提供的默认参数是通过在COCO数据集上使用超参数进化得来的（也就是下图这些参数）。 由于超参数进化会耗费大量的资源和时间，所以不要动这个参数。 '--bucket',谷歌云盘bucket，一般不会用到 '--cache',是否提前缓存图片到内存，以加快训练速度 '--image-weights',是否启用加权图像策略，默认是不开启的；主要是为了解决样本不平衡问题；开启后会对于上一轮训练效果不好的图片，在下一轮中增加一些权重；， '--device',训练使用的GPU选择，cpu；0(表示一个gpu设备cuda:0)；0,1,2,3(多个gpu) '--multi-scale',是否进行多尺度训练，一般设置几种不同尺度的图片，训练时每隔一定iterations随机选取一种尺度训练 这样训练出来的模型鲁棒性强，可以接受任意大小的图片作为输入，使用尺度小的图片测试速度会快些，但准确度低，用尺度大的图片测试速度慢，但是准确度高 '--single-cls',多类别的数据集是否作为一个类别训练，默认False --optimizer',优化器选择，默认SGD '--sync-bn',是否开启跨卡同步BN；开启参数后即可使用SyncBatchNorm多 GPU 进行分布式训练。 '--workers',最大worker数量；这里经常出问题，Windows系统报错时可以设置成0 00。 '--project',训练结果保存的文件夹路径 '--name',训练结果保存的文件夹名称 '--exist-ok'训练结果文件夹project/name存在时，是否覆盖，默认否 '--quad',四元数据加载器 '--cos-lr',用于对学习率进行调整，余弦函数降低学习率 '--label-smoothing',对label进行平滑处理，防止过拟合 '--patience',早停止忍耐次数 / 默认100次不更新就停止训练 '--freeze', 冻结训练网络的层，default = [0]意思是网络的第0层不训练，backbone = 10,前三层不训练可设为[0 1 2]。 数据量大的情况下，建议不设置这个参数 '--save-period', pt保存的频率，每x个epochs保存一次 '--local_rank', 进程编号 / 多卡使用 '--seed',这是v6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac49e29facbba5b6502428ec776a513f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4226cd8c9ad8163b0ee7406040594fb/" rel="bookmark">
			tomcat的启动流程及原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组件介绍： Tomcat 最重要的是两个组件是：Connector（连接器） 和 Container（容器/集装箱），Connector 组件是可以被替换，这样可以提供给服务器设计者更多的选择，因为这个组件是如此重要，不仅跟服务器的设计的本身，而且和不同的应用场景也十分相关，所以一个 Container 可以选择对应多个 Connector。
多个 Connector 和一个 Container 就组成一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境， Server 就提供了这样一个环境。所以整个 Tomcat 的生命周期由 Server 控制。
tomcat核心组件.JPG
下面来一层层的看，首先是Server，什么是server呢？
Server Server 要完成的任务很简单，就是要能够提供一个接口让其它程序能够访问到 Service 集合，同时要维护它所包含的所有 Service 的生命周期，包括如何初始化、如何结束服务、如何找到别人要访问的 Service。还有一些次要的任务，如记录Service运行日志，维护Session等等。Server包含的组件结构如下：
tomcat-Server.png
Service Service 是在 Connector 和 Container 外面多包一层，把它们组装在一起，向外面提供服务，一个 Service 可以设置多个 Connector，但是只能有一个 Container 容器。当然Service不仅仅包含这两个组件， Service 接口的方法列表如下:
tomcat-Service方法.png
Container Container本意是集装箱的意思，是一个接口，定义了下属的各种容器，重要的是Wrapper、Host、Engine、Context等
tomcat-container结构.png
tomcat-container类图.png
Engine(引擎) 负责处理来自相关联的service的所有请求，处理后，将结果返回给service，而connector是作为service与engine的中间媒介出现的。
一个engine下可以配置一个默认主机，每个虚拟主机都有一个域名。当engine获得一个请求时，它把该请求匹配到虚拟主机(host)上，然后把请求交给该主机来处理。
Engine有一个默认主机，当请求无法匹配到任何一个虚拟主机时，将交给默认host来处理。Engine以线程的方式启动Host。
Host 代表一个虚拟主机，每个虚拟主机和某个网络域名（Domain Name）相匹配。
每个虚拟主机下都可以部署一个或多个web应用，每个web应用对应于一个context，有一个context path。
当Host获得一个请求时，将把该请求匹配到某个Context上，然后把该请求交给该Context来处理匹配的方法是“最长匹配”，所以一个path==””的Context将成为该Host的默认Context所有无法和其它Context的路径名匹配的请求都将最终和该默认Context匹配。
Context 一个Context对应于一个Web应用，一个Web应用由一个或者多个Servlet组成Context在创建的时候将根据配置文件$CATALINA_HOME/conf/web.xml和$ WEBAPP_HOME/WEB-INF/web.xml载入Servlet类。当Context获得请求时，将在自己的映射表(mapping table)中寻找相匹配的Servlet类，如果找到，则执行该类，获得请求的回应，并返回。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4226cd8c9ad8163b0ee7406040594fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e03030c6776ab9bc6471b79b6f322ea/" rel="bookmark">
			NX二次开发 UFUN创建扫掠 UF_MODL_create_sweep
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NX二次开发 UFUN创建扫掠 UF_MODL_create_sweep
//VS8.0+VS2010 #include &lt;uf_modl.h&gt; #include &lt;uf_curve.h&gt; #include &lt;uf_vec.h&gt; extern DllExport void ufsta(char* param, int* returnCode, int rlen) { if (UF_initialize()) return; //创建三点圆弧，引导线 double first_point1[3] = { 0.0, 0.0, 0.0 }; double second_point1[3] = { 0.0, 0.0, 5.0 }; double third_point1[3] = { 8.0, 0.0, 2.0 }; tag_t arc_tag1 = NULL_TAG; UF_CURVE_create_arc_thru_3pts(1, first_point1, second_point1, third_point1, &amp;arc_tag1); //创建三点整圆，截面线 double first_point2[3] = { -2.0, 0.0, 0.0 }; double second_point2[3] = { 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e03030c6776ab9bc6471b79b6f322ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac075239f57e611ae75534b1997998ff/" rel="bookmark">
			数据库错误“of SELECT list is not in GROUP BY clause and contains nonaggregated column“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库错误"of SELECT list is not in GROUP BY clause and contains nonaggregated column" 与 MySQL错误-this is incompatible with sql_mode=only_full_group_by完美解决方案 数据库安装了mysql5.7，用group by 查询时抛出如下异常：
Expression #3 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'userinfo.t_long.user_name' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by 原因：
MySQL 5.7.5和up实现了对功能依赖的检测。如果启用了only_full_group_by SQL模式(在默认情况下是这样)，那么MySQL就会拒绝选择列表、条件或顺序列表引用的查询，这些查询将引用组中未命名的非聚合列，而不是在功能上依赖于它们。(在5.7.5之前，MySQL没有检测到功能依赖项，only_full_group_by在默认情况下是不启用的。关于前5.7.5行为的描述，请参阅MySQL 5.6参考手册。)
进入mysql中，执行以下个命令，可以查看 sql_mode 的相关内容：
mysql&gt; SHOW SESSION VARIABLES; mysql&gt; SHOW GLOBAL VARIABLES; mysql&gt; select @@sql_mode;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac075239f57e611ae75534b1997998ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d46fbd84379d03172f8ae99b2fb8b72/" rel="bookmark">
			nodejs基于vue的毕业设计选题阶段性资料管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目介绍 在各学校的教学过程中，vue过程管理系统是一项非常重要的事情。随着计算机多媒体技术的发展和网络的普及。采用当前流行的B/S模式以及3层架构的设计思想通过nodejs技术来开发此系统的目的是建立一个配合网络环境的vue过程管理系统的平台，这样可以有效地解决vue过程管理系统混乱的局面。 目录
1 绪论 1
1.1课题背景 1
1.2课题研究现状 1
1.3初步设计方法与实施方案 2
1.4本文研究内容 2
2 系统开发环境 4
2.1 使用工具简介 4
2.2 环境配置 4
2.3 B/S结构简介 4
2.4 MySQL数据库 5
2.5 框架介绍 5
3 系统分析 6
3.1系统可行性分析 6
3.1.1经济可行性 6
3.1.2技术可行性 6
3.1.3运行可行性 6
3.2系统现状分析 6
3.3功能需求分析 7
3.4系统设计规则与运行环境 8
毕业设计流程繁琐，指导老师与学生之间沟通不够灵活，各种毕业设计文档管理混乱。本毕业设计系统采用了现代的技术方式，提升了质量效率，降低了沟通成本和时间成本。
本系统经过实际需求分析，基于B/S架构，采用vue框架、MySQL数据库、vue前端框架， 用户权限管理子系统和注册、登录、反馈等各模块，其设计均按照简单灵活，安全稳定的原则来实现。
采用nodejs语言开发的一个基于web的毕业设计选题管理系统，一共有3个身份，超级管理员，老师和学生。管理员登录后可以管理专业信息，学院信息，教研室信息，设置系统开放时间，添加发布公告，添加维护学生信息，添加维护老师信息，其中学生和用户表一对一关系，老师和用户也是一对一关系，基于分组权限设置，学生用户属于students分组，老师用户属于teachers分组，每个分组拥有不同的权限，基于分组权限设计的思路；学生登录后可以查询导师，选择自己中意的老师，修改个人信息和密码；老师登录系统后确认选自己的学生，修改个人信息和密码。
3.5系统流程分析 8
3.5.1操作流程 8
3.5.2添加信息流程 9
3.5.3删除信息流程 10
4 系统设计 11
4.1系统设计主要功能 11
4.2数据库设计 11
4.2.1数据库设计规范 11
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d46fbd84379d03172f8ae99b2fb8b72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88c844414323d9cc8b7e09fb6692f532/" rel="bookmark">
			一芯FC1178BC/FC1179主控U盘量产分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从京东买的17元的兰可芯32gU盘突然不能用了，我的电脑无盘符显示，磁盘管理U盘显示无媒体，0字节，用了几个U盘修复软件均找不到目标，用芯片精灵4.0查询显示主控unknown,已经要丢弃了，搜索芯片精灵发现最新版为4.19，下载后运行，显示主控厂商: FirstChip(一芯)，主控型号: FC1178BC，闪存识别码: 2CA40832A100 - Micron(美光) - 1CE/单通道 [TLC] -&gt; 总容量 = 32GB。于是从网上搜索下载了一个量产工具，但不识别。后来，看网友分享（一芯FC1178BC/FC1179主控U盘量产修复指南），推荐了FirstChip_MpTools_20201118版本的量产工具，下载地址为：
http://14013833.s21d-14.faiusrd.com/0/ABUIABBQGAAgs_Da-wUowP6Y1gM?f=FirstChip_MpTools_20201118.rar&amp;v=1610002483
界面如下：
正常识别，开始量产，（设定密码什么也不填）先用原厂扫描，错误代码6，用高级格式化，错误代码4，用代级格式化正常量产，一个多小时后，量产成功，但容量只有8g,原来设定里没有选择容量优先，重新量产，选择容量优先，
Bing级设定固定为3。
终于，历经二个小时的漫长等待，量产成功，恢复32g容量。
总结如下：1、芯片精灵要最新版；2、量产工具要对路，多看前辈总结；3、代级格式化是最终量产方法，但设定要正确；4、量产时间漫长，要耐心等待。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f623a8747f47426a228f05372751ff7/" rel="bookmark">
			91年的印度程序员开发博客网站每月已赚2500美元以及他的创业历程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		他是谁 Sai Krishna ，程序员、美食家、电影爱好者。
目前正在开发和维护的superblog.ai的收入情况（截止2023年1月27日）：
此前他是 SpotPlay 的联合创始人兼首席技术官。此外，他开发的应用程序和游戏的下载量已达数百万次，其中 mHotspot 是最受欢迎的应用程序。曾使用过 C、C++、Java、C#.Net、JavaScript、jQuery、React、React Native、MeteorJS、Unity、GatsbyJS、NextJS、Mongo、Express、Node、Puppeteer、OpenWrt、Firebase、AWS/DO、Hasura、Caprover , 图谱语言。他开发过桌面、网络和移动应用程序（也很少有游戏），喜欢单枪匹马去做从 0 到 1 的产品。
他的历程 2020 年 12 月 25 日开发推出Superblog.ai，Superblog 是 wordpress 的快速替代品，自动完成SEO 审核和管理服务器。使用者可以完全专注于编写内容，其余的都由 superblog 自动处理。
2019 年 5 月 1 日加入 Digibooster 担任首席技术官。
2018 年 2 月 3 日入选智利创业公司，开发的SpotPlay 已入选著名的第 19 代创业智利计划。印度仅有的 5 家公司之一！
2017 年 1 月 9 日会见法国外长。Sai Krishna 展示他们SpotPlay 产品！
2016 年 5 月 14 日成立第二公司，被卡纳塔克邦政府选入创业孵化器计划。
2016 年 1 月 28 日WiPlay 在 CTC Autonebula 上获得了来自 250 Startups 的三等奖。WiPlay 后来更名为 SpotPlay。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f623a8747f47426a228f05372751ff7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2b9a0b4000f0397acf493549d717bd7/" rel="bookmark">
			【目标检测】yolov5简单实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习计算机视觉目标检测的相关内容，主要学习了yolov5 7.0版本
博主也是初学者，最近刚学完李沐的动深和yolo部分内容，写的错误的地方还请指出
本文只会简单概述yolov5相关的原理，需要详细了解可以看如下博客
YOLO系列算法精讲：从yolov1至yolov5的进阶之路（2万字超全整理）_AI 菌的博客
yolov5整体网络架构
input部分，一般为图片输入
yolov5的图片输入部分，使用了Mosaic进行数据增强，将几张图片融合在一起，丰富了检测目标的背景，同时在计算batch_size normalization 时计算更快
backbone部分，一般为提取特征（feature_map)
使用Focus进行切片操作，切成很多特征图（转换为单张feature_map很小，通道数较多），不属于下采样
使用了CSP结构，将feature_map分为两个part，一个part用于继续使用网络处理，其余经过简单处理直接加在第一个part的输出上（整体与ResNet有区别，ResNet是整个加上去）
关于CSP，可以看这一篇博客
深度学习_经典网络_CSPNet网络详解_WeThinkIn的博客
neck部分，一般用于学习特征
使用了FPN+PAN，可以进行高低层特征融合
head部分，一般用于输出预测
和yolov3，yolov4类似，生成多尺度的anchors，可以进行多尺度的预测
同时，从yolov3开始使用logistic回归代替了softmax，可以进行多标签判定
以上是对于yolov5的简单理论介绍，下面进行一个简单的yolov5实战
安装yolov5 7.0
通过终端拉取yolov5安装包
要求在 Python&gt;=3.7.0 环境中安装 requirements.txt ，且要求 PyTorch&gt;=1.7 。
pytorch一定要安装gpu版本，不然训练速度会很慢
git clone https://github.com/ultralytics/yolov5 国内github访问速度较慢，可以使用镜像源
git clone https://gitcode.net/mirrors/ultralytics/yolov5.git 接着是安装依赖项
cd yolov5 pip install -r requirements.txt 如何测试安装是否成功？
linux系统，在yolov5文件夹输入
python detect.py 若linux系统中有多个python版本，有时候需要
python3 detect.py windows系统则直接运行python文件即可
若运行成功且在runs/detect/exp有处理好的图片则说明运行成功
注：多次运行会出现exp1，exp2等等，如果你拉取的yolov5不是官方文件会出现这个问题
另外，在yolov5运行过程中经常出现如下字体缺少报错
Downloading https://ultralytics.com/assets/Arial.ttf 然后一直下载不下来（下载很慢之类的），可以先把这个字体下载好放在yolov5根目录里面
方法：
linux系统直接使用如下代码拉去字体文件
wget https://ultralytics.com/assets/Arial.ttf windows系统可以下载好文件后拷贝
如果还是下载不了，可以使用我分享的这个文件
链接：https://pan.baidu.com/s/1-wvA_ft3q8WfWjPUWmyu-A?pwd=07l9 提取码：07l9 进行简单的yolov5实战
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2b9a0b4000f0397acf493549d717bd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1253a7d7c2c66cb39eb102e671278d5e/" rel="bookmark">
			启动tomcat时，引入javaagent启动jar冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tomcat的catalina.sh的启动脚本中添加命令：
-javaagent:/home/tyjc/GS_DEV/sms-heartbeat-0.0.1-SNAPSHOT/sms-heartbeat.jar
启动之后，tomcat自带的包有冲突，自带的包：
报错如下：
18-Jan-2023 09:26:02.124 严重 [main] org.apache.catalina.startup.HostConfig.deployDirectory 无法部署应用目录 [/home/tyjc/JT_TEST/DEV_CACHE/webapps/examples]
java.lang.IllegalStateException: 启动子级时出错
at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:720)
at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:690)
at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:705)
at org.apache.catalina.startup.HostConfig.deployDirectory(HostConfig.java:1133)
at org.apache.catalina.startup.HostConfig$DeployDirectory.run(HostConfig.java:1866)
at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
at java.util.concurrent.FutureTask.run(FutureTask.java:266)
at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75)
at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:112)
at org.apache.catalina.startup.HostConfig.deployDirectories(HostConfig.java:1045)
at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:429)
at org.apache.catalina.startup.HostConfig.start(HostConfig.java:1576)
at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:309)
at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:123)
at org.apache.catalina.util.LifecycleBase.setStateInternal(LifecycleBase.java:423)
at org.apache.catalina.util.LifecycleBase.setState(LifecycleBase.java:366)
at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:936)
at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:841)
at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183)
at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1384)
at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1374)
at java.util.concurrent.FutureTask.run(FutureTask.java:266)
at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75)
at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134)
at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:909)
at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:262)
at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183)
at org.apache.catalina.core.StandardService.startInternal(StandardService.java:421)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1253a7d7c2c66cb39eb102e671278d5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d82c5d000693e00c228a243595597f9/" rel="bookmark">
			教育学原理笔记-整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 教育学概述
第一节 教育学的研究对象和任务（简答）15曲阜简
（一）教育与教育学的概念
教育：有目的培养人的社会活动，有广义和狭义之分，是有区别于教育学的，是一种自古就存在的现象，教育学是教育发展到一定程度才有了相关的理论学说和研究。
教育学：通过对教育现象和教育问题的研究，揭示教育规律，探讨教育价值观念和教育艺术，指导教育实践的一门学科。（总括）（名词解释）10江苏，10中山，10西南，11扬州
（二）教育学的研究对象
教育学的研究对象是教育问题和教育对象。
整个教育过程中，凡是已经看到的，察觉到的，客观存在的就是一种现象，得到了人们的普遍关注，从而衍生成一种问题，但又并非所有的教育问题都能构成教育的研究对象，只有那些有价值的，能够引起社会普遍关注的教育问题和教育现象才能构成教育学的研究对象。
（三）教育学的研究任务（名词解释）
教育学的研究任务是揭示教育规律，探讨教育价值观念和教育艺术，指导教育实践。
教育规律：不以人们意志为转移的客观存在的，必然的趋势。
教育价值观念：是主观的，不与规律的客观性矛盾，我们追寻的是主观和客观的统一，是引领和规范人的发展和人的教育。
联系：规律展示发展可能性，价值观念引领方向。教育学研究的重点在于讨论教育活动系统的多种
可能性与价值选择，实然与应然，客观与主观的统一。
教育艺术：教师将自己的课堂通过创造性的组织方式，且充满灵感，富有感情，且与众不同，易于被人接受，这个活动过程就会演变为艺术性的教育活动。教育艺术是我们整个教育学发展过程中追求的最高目标和灵魂。（名词解释）
教育学的发展不能仅仅是用来指导教育实践的，它只是教育学发展过程中的一个小小的任务。指导实践是实然的一种状态，教育学是一种应然的理想状态，教育学是游刃于实然和应然之间的。
第二节 教育学的产生与发展
（一）教育学的萌芽阶段
代表人物：乐正克《学记》，中国乃至世界上最早出现的专门论述教育教学问题的著作
‚古罗马昆体良《论演说家的培养》（也叫《雄辩术原理》），这是西方最早的教育专著。
特点：教育学的思想零星的散落在哲学、政治、文化的著作中；
‚关于教育的论述停留在描述经验的层次上，抽象概括的层次较低。
（二）教育学的独立形态阶段
代表人物：英国培根，《论科学的价值和发展》，把教育学作为一门独立的学科提了出来。
‚捷克夸美纽斯，《大教学论》，这是近代最早的一部教育学著作，标志着独立形态教育学的产生。
ƒ德国康德，在大学开始将手教育学，这是教育学首次列入大学课堂的开端。
„德国特普拉，这是世界上第一位教育学教授，《教育学研究》，西方历史上第一本以“教育学”命名的专著，标志着作为学科的教育学基本形成。
…德国赫尔巴特，《普通教育学》，这是现代的第一部系统的教育学著作，它的出现标志着教育学已成为一门独立的学科。
†法国卢梭，《爱弥儿》，阐述了自然主义教育思想。
特点：研究对象上：教育问题成为一个专门的研究领域；
‚使用概念和范畴上：有了专门的概念；
ƒ研究方法上：有了专门的研究方法；
„研究结果上：有了专门的教育学著作；
…组织结构上：有了专门的教育研究机构。
a
（三）教育学的发展多样化阶段
1、实验教育学（名词解释/简答/论述）10安徽，14扬州，14首都简，15江苏，15华中论
代表人物：德国梅伊曼，首先将实验教育思想成为“实验教育学”；
‚拉伊，《实验教育学》。
基本观点：
反对以赫尔巴特为代表的思辨教育学；
‚提倡把实验心理学的研究成果和方法应用于教育研究；
ƒ将教育实验划分为提出假设、进行试验、论证三个基本阶段；
„主张用实验、统计和比较的方法探索儿童的心理发展特点及其智力发展水平，用实验数据作为改革学制、课程和教育方法的依据。
基本评价：
提倡定量的研究方法，促进了教育科学的发展；
‚忽视了人的社会性，当涉及到人文，人性时是不能完全量化的，其提倡的实验科学方法具有局限性。
2、实用主义教育（名词解释）12河北，13曲阜论
代表人物：杜威，《民主主义与教育》
基本观点：
教育即生活
教育即生长
‚教育即个体经验的不断成长
从做中学
ƒ学校即社会
„儿童为中心
课程组织应以学生的经验为中心
教育过程应重视学生自己的独立发现和体验，尊重学生发展的差异性；
师生关系以儿童为中心，教师只是学生成长的帮助者，而非领导者。
评价：杜威的“儿童中心”教育就是解放儿童的教育，这是教育的现代转向的重要体现，产生了世界性的广泛而深远的影响
‚实用主义教育学对赫尔巴特为代表的理性主义教育理念进行了深刻的批判；
ƒ忽视了系统知识的传授，教师在教育教学过程中的主导作用。
3、批判教育学（名词解释）
代表人物：美国的鲍尔斯、金蒂斯、阿普尔、法国的布尔迪尔
主张：当代资本主义的学校教育不是一种民主的建制和解放的力量，而是维护社会的不公平和不公正的工具；
‚社会政治、经济和文化决定学校教育机构，学校教育的功能就是再生产出占主导地位的社会政治意识形态、文化关系和经济结构；（从大环境）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d82c5d000693e00c228a243595597f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15cf8bcfed2f400a03f22da76af32ba5/" rel="bookmark">
			Requests库常用方法及参数介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Requests 库中定义了七个常用的请求方法，这些方法各自有着不同的作用，在这些请求方法中 requests.get() 与 requests.post() 方法最为常用。请求方法如下所示：
方法说明requests.request()构造一个请求对象，该方法是实现以下各个方法的基础。requests.get()获取HTML网页的主要方法，对应于 HTTP 的 GET 方法。requests.head()获取HTML网页头信息的方法，对应于 HTTP 的 HEAD 方法。requests.post()获取 HTML 网页提交 POST请求方法，对应于 HTTP 的 POST。requests.put()获取HTML网页提交PUT请求方法，对应于 HTTP 的 PUT。requests.patch()获取HTML网页提交局部修改请求，对应于 HTTP 的 PATCH。requests.delete()获取HTML页面提交删除请求，对应于 HTTP 的 DELETE。 上述方法都提供了相同的参数，其中某些参数已经使用过，比如headers和params，前者用来构造请求头，后者用来构建查询字符串。这些参数对于编写爬虫程序有着至关重要的作用。本节对其他常用参数做重点介绍。
SSL认证-verify参数 SSL 证书是数字证书的一种，类似于驾驶证、护照和营业执照。因为配置在服务器上，也称为 SSL 服务器证书。SSL 证书遵守 SSL 协议，由受信任的数字证书颁发机构 CA（电子认证服务）颁发。 SSL 具有服务器身份验证和数据传输加密功能。
verify参数的作用是检查 SSL 证书认证，参数的默认值为 True，如果设置为 False 则表示不检查 SSL证书，此参数适用于没有经过 CA 机构认证的 HTTPS 类型的网站。其使用格式如下：
response = requests.get(url=url,params=params,headers=headers,verify=False) 代理IP-proxies参数 一些网站为了限制爬虫从而设置了很多反爬策略，其中一项就是针对 IP 地址设置的。比如，访问网站超过规定次数导致流量异常，或者某个时间段内频繁地更换浏览器访问，存在上述行为的 IP 极有可能被网站封杀掉。
代理 IP 就是解决上述问题的，它突破了 IP 地址的访问限制，隐藏了本地网络的真实 IP，而使用第三方 IP 代替自己去访问网站。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15cf8bcfed2f400a03f22da76af32ba5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d61f6618ad24b52df5557be05b74829/" rel="bookmark">
			【选择结构】苹果和虫子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 今天，我们将会进入到【选择结构】的升华部分，前面的几篇只是为今天打下基础。
正文： 题目描述：你买了一箱n个苹果，很不幸的是买完时箱子里混进了一条虫子。虫子每x小时能吃掉一个苹果，假设虫子在吃完一个苹果之前不会吃另一个，那么经过y小时你还有多少个完整的苹果？
输入：输入仅一行，包括n，x和y（均为整数）。
输出：输出也仅一行，剩下的苹果个数。
样例输入：10 4 9
样例输出：7
思路：利用换元法和多个if、else搭配。
这是来自大佬@守仁之人的代码：
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; using namespace std; int main(){ int x,y,n,b; cin &gt;&gt; n &gt;&gt; x &gt;&gt; y; if(y%x != 0) b = n - (y/x + 1); else b = n - y/x; if(b&gt;=0) cout &lt;&lt; b; else cout &lt;&lt; 0; return 0; } 这是本蒟蒻的代码：
#include&lt;iostream&gt; using namespace std; int main() { int n,x,y; int ans; cin&gt;&gt;n&gt;&gt;x&gt;&gt;y; if(y%x==0) { ans=n-y/x; if(ans&gt;=0) cout&lt;&lt;ans; else cout&lt;&lt;0; } else { ans=n-y/x-1; if(ans&gt;=0) cout&lt;&lt;ans; else cout&lt;&lt;0; } return 0; } 如果需要学习更多的选择结构点这里
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4c3b72d0f51509a7fe050e4b9722ae0/" rel="bookmark">
			【选择结构】收集瓶盖赢大奖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言实在是没有什么好说的，这次就不写前言了。
正文 题目描述：某饮料公司最近推出了一个“收集瓶盖赢大奖”的活动，如果你拥有10个印有“幸运”或20个印有“鼓励”的瓶盖，就可以兑换一个神秘大奖。现分别给出你拥有的印有“幸运”和“鼓励”的瓶盖数，判断是否可以去兑换大奖。
输入：仅输入一行，包含两个整数，分别是印有“幸运”和“鼓励”的瓶盖数，用一个空格隔开。
输出：仅输出一行，若可以兑换大奖，输出1，否则输出0。
样例输入：11 19
样例输出：1
思路：设a和b，当a大于等于10时或b大于等于20时就输出1。
现在来看代码：
这是来自大佬@水蛙菌的代码:
#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int a, b; while(cin &gt;&gt; a &gt;&gt; b) if(a&gt;=10 || b&gt;=20) cout &lt;&lt; "1" &lt;&lt; endl; else cout &lt;&lt; "0" &lt;&lt; endl; return 0; } 这是来自蒟蒻@mn761109的代码：
#include&lt;bits/stdc++/.h&gt; using namespace std; int main() { int a,b； cin&gt;&gt;a&gt;&gt;b; if (a&gt;9||b&gt;19) cout&lt;&lt;"1"; else cout&lt;&lt;"0"; } 严格来说，这篇代码不完全正确，正确的如下：
#include&lt;bits/stdc++.h&gt;//千万不要像我，为了省事直接写万能头 using namespace std; int main() { int a,b; cin&gt;&gt;a&gt;&gt;b; if (a&gt;=10 || b&gt;=20)//当a≥10或b≥20时 cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4c3b72d0f51509a7fe050e4b9722ae0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09acd836f0e66ac763fc27bc4a3f5914/" rel="bookmark">
			java毕业设计——基于Java&#43;Java ME的无线网络移动端的俄罗斯方块游戏设计与实现（毕业论文&#43;程序源码）——俄罗斯方块游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Java+Java ME的无线网络移动端的俄罗斯方块游戏设计与实现（毕业论文+程序源码） 大家好，今天给大家介绍基于Java+Java ME的无线网络移动端的俄罗斯方块游戏设计与实现，文章末尾附有本毕业设计的论文和源码下载地址哦。需要下载开题报告PPT模板及论文答辩PPT模板等的小伙伴，可以进入我的博客主页查看左侧最下面栏目中的自助下载方法哦
文章目录：
基于Java+Java ME的无线网络移动端的俄罗斯方块游戏设计与实现（毕业论文+程序源码）1、项目简介2、资源详情3、关键词4、毕设简介5、资源下载 1、项目简介 本系统是一个基于Java ME平台的无线网络移动端的俄罗斯方块游戏，利用Java ME Wireless Toolkit(WTK)开发包工具在无线网络移动端上实现经典的俄罗斯方块游戏。论文开始部分对无线网络移动系统开发中常使用几种开发语言和环境作了比较，说明了选择Java ME Wireless Toolkit作为开发环境的的原因并对它作了相关的介绍。并展示了在WTK中打开一个项目、把源文件打包成JAR包、产生混淆包的方法和过程。在系统设计时，遵循了无线网络移动端程序的startApp、pauseApp、destroyApp的开发生命周期。在设计与实现方面，分成难度选择、游戏规则、方块处理这几个模块进行实现。在开发与实现的同时也讲解了俄罗斯方块这款古老而经典游戏的游戏背景、规则以及相关特性。最终展示了无线网络移动端的游戏开发的基本开发过程和设计思路。 2、资源详情 项目难度：中等难度
适用场景：相关题目的毕业设计
配套论文字数：9838个字29页
包含内容：整套源码+完整毕业论文+答辩PPT
3、关键词 无线网络移动端；Java ME；俄罗斯方块；游戏开发 4、毕设简介 提示：以下为毕业论文的简略介绍，项目源码及完整毕业论文下载地址见文末。
1 引言
1.1 系统综述
综合运用以前所学专业知识，在Java ME开发平台上实现无线网络移动端的俄罗斯方块游戏。其研究主要包括以下内容：第一，克服有限的可视屏幕尺寸，使游戏正常显示；第二，解决有限的可用内存调用问题，实现游戏流畅运行；第三，俄罗斯方块游戏规则算法在Java ME平台的实现，保证游戏可玩性；第四，游戏开始、结束等逻辑在游戏进行中的判断。本系统在Windows XP的操作系统下，Java Micro Edition Wireless Toolkit 2.1为开发工具，用中文版UltraEdit做为代码编辑器而实现的。
1.2 Java ME游戏开发背景
游戏开发是艺术与编程技术相结合的完美表现。利用Java的“Write once,run anywhere”特性，可以真正达到程序只写一次，在任何平台都可以执行。同时Java语言对面向对象的良好支持，使开发具有高效性。所以Java ME(Java Micro Edition)是广大无线网络移动端游戏开发厂商和游戏开发爱好者的首选平台。
1.3 无线网络移动端游戏发展现状
省略
2 开发环境介绍
2.1 编程环境的选择
目前，移动开发有以下四种主流平台。Java Micro Edition(Java ME)，Binary Runtime Environment for Wireless(BREW)，Symbian和Window Mobile Smartphone。其中：
Binary Runtime Environment for Wireless（BREW）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09acd836f0e66ac763fc27bc4a3f5914/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec996507481b6d3e7a901ec9364c20b5/" rel="bookmark">
			Qt--解析Json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、QT5 Json简介 QT4中使用第三方库QJson解析JSON文件。
QT5新增加了处理JSON的类，类均以QJson开头，包含在QtCore模块中。QT5新增加六个相关类：
QJsonArray
封装 JSON 数组
QJsonDocument
读写 JSON 文档
QJsonObject
封装 JSON 对象
QJsonObject::iterator
用于遍历QJsonObject的STL风格的非const遍历器
QJsonParseError
报告 JSON 处理过程中出现的错误
QJsonValue
封装 JSON 值
二、QJsonDocument 1、QJsonDocument简介 QJsonDocument提供了读写Json文档的方法。
QJsonDocument是一个包含了完整JSON文档的类，支持以UTF-8编码的文本和QT自身的二进制格式来读写JSON文档。
JSON文档可以使用QJsonDocument::fromJson()将基于JSON文档的文本形式转换为QJsonDocument对象，toJSON()可以将QJsonDocument转换回文本形式。
解析文档的有效性可以使用 !isNull() 进行查询。
使用isArray()和isObject()可以分别查询一个文档是否包含了一个数组或一个object。使用array()或object()可以将包含在文档中的数组或object提取出来。
使用fromBinaryData()或fromRawData()也可以从一个二进制形式创建一个QJsonDocument对象。
2、QJsonDocument成员函数 [static] QJsonDocument QJsonDocument::fromBinaryData(const QByteArray &amp;data, DataValidation validation = Validate)
Validation决定数据是否在使用前检查数据有效性。
[static] QJsonDocument QJsonDocument::fromJson(const QByteArray &amp;json, QJsonParseError *error = Q_NULLPTR)
将json解析为UTF-8的JSON文档
[static] QJsonDocument QJsonDocument::fromRawData(const char *data, int size, DataValidation validation = Validate)
使用data数据的前size字节创建一个QJsonDocument对象
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec996507481b6d3e7a901ec9364c20b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90a5062c5dc0239d0ae9298d84617c80/" rel="bookmark">
			Linux 笔记3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5.Linux 的网络信息 5.1主机名称 5.1.1临时修改： hostname 新名字 （需要重新进入才能显示新名字）
reboot重启虚拟机
5.1.2永久： vi /etc/hostname
5.2DNS解析 dns解析域名
域名-》ip
dns域名劫持：将域名对应的ip改掉
5.2.1修改主机域名 windows：
C:\Windows\System32\drivers\etc\hosts
linux：
vi /etc/hosts
先ip 后域名
5.3网络相关命令 ifconfig 查看网卡配置信息
属于nat-tools中的一个命令，但是centos7 minimal中没有这个包
安装命令：
yum install net-tools -y 如果没有也可以用ip addr临时代替
2.netstat 查看当前网络的状态信息 一个机器默认有65536个端口号[0,65535] 这是一个逻辑的概念，将来我们需要使用程序监听指定的端口，等待别人的访问 一个端口只能被一个程序所监听, 端口已经被占用 netstat -anp 主要查看端口监听信息
netstat -r
核心路由表 == route
3.ping ip是否能够链接成功
4.telnet 端口是否能够连通
要先安装
yum install telnet telnet 域名，或ip 端口 5.crul 可以直接获取网站资源的命令。
curl -X GET http://www.baidu.com 相当于在百度搜索界面右键+V
5.4防火墙 用来保护端口的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90a5062c5dc0239d0ae9298d84617c80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b8c72d2bbdf227eff071df9bc1d6321/" rel="bookmark">
			GO-IM系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://doc.rentsoft.cn/ OpenIM 功能非常完善的开源分布式IM系统
https://github.com/alberliu/goim gim是一个即时通讯服务器，代码全部使用golang完成，主要使用mysql (多设备，消息不丢不重) 官网https://goim.io/
https://github.com/ZuoFuhong/go-IM 由gim 项目fork而来，在此基础上进行了二次开发。目的在于开发一个基于websocket的聊天（IM）室， 并且支持单用户多设备支持，离线消息同步
https://github.com/Terry-Ye/im纯go实现的分布式im即时通讯系统，各层可单独部署，之间通过rpc通讯，基于redis 做消息推送，比较适合做直播间消息
https://github.com/Terry-Mao/goim毛剑
https://github.com/GoBelieveIO/im_serviceim_service服务端（国内唯一开源IM）
http://gglinux.com/2017/04/15/IM_design/IM系统设计
http://www.52im.net/thread-307-1-1.html浅谈IM系统的架构设计
https://github.com/tinode/chatGo 即时通讯服务
https://tech.youzan.com/app_imsdk/有赞APP IM SDK 组件架构设计
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/680367cc06cdc642e99717e7e262f0ac/" rel="bookmark">
			个人流媒体服务搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 主要是个人的流媒体服务器的创建的方式分享
Centos7自建基于HLS的私人直播服务器 相关资源下载 链接：https://pan.baidu.com/s/1zhWFpFRy2v0_lyjA0-AfAg 提取码：yyds 入门操作 实现方法基于nginx和nginx的一个rtmp模块。因为epel源和nginx官方源里面安装的nginx是没有nginx-rtmp-module的，所以只能编译安装
先新建一个www用户和组专门用来跑Nginx：
groupadd www useradd www -g www -s /sbin/nologin 安装EPEL/开发工具包/以及编译Nginx所需的依赖：
yum -y install epel-release yum -y groupinstall "Development Tools" yum -y install wget openssl-devel pcre-devel zlib-devel geoip-devel gd-devel 进入到opt目录下载nginx-rtmp-module模块：
如果下载不了，可以访问我的百度网盘
链接：https://pan.baidu.com/s/1qwzHVbHqG_0SBcEb1UaeZg 提取码：yyds cd /opt git clone https://github.com/arut/nginx-rtmp-module.git 同时下载解压Nginx并进入到Nginx的源码目录：
wget http://nginx.org/download/nginx-1.15.8.tar.gz tar -xzvf nginx-1.15.8.tar.gz cd nginx-1.15.8 虽然我们本次使用Nginx只是需要用到它的RTMP功能，但既然都编译了，就编译个全面一点的Nginx吧，所以这里我还是把Nginx常用的一些功能和模块都加上：
由于我网盘里面是windows压缩的，会有文件换行的问题
yum install dos2unix dos2unix /opt/nginx-rtmp-module/config 同理，如果你的文件是在 linux 编写需要到 windows 环境使用：
unix2dos file ./configure --user=www --group=www --prefix=/usr/local/nginx --add-module=/opt/nginx-rtmp-module --with-http_ssl_module --with-http_v2_module --with-stream --with-stream_ssl_module --with-http_gzip_static_module --with-http_gunzip_module --with-http_flv_module --with-http_mp4_module --with-http_image_filter_module --with-http_geoip_module --with-http_sub_module --with-http_stub_status_module --with-http_realip_module --with-http_addition_module 如果配置没有错误，那么就可以编译并完成安装了：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/680367cc06cdc642e99717e7e262f0ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db79329fab58b22a379653c23be94dde/" rel="bookmark">
			测试开发 | 相比 Selenium，Web 自动化测试框架 Playwright 有哪些强大的优势？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Playwright 是由微软的研发团队所开发的一款 Web 自动化测试框架，这个框架具有多平台、跨语言的特点。除了基本的自动化测试能力之外，同时它还具备非常强大的录制功能、追踪功能。以下是 Playwright 与 Selenium 的对比。
​
由此可见，Playwright 不仅具备 Selenium 多语言、跨平台、多浏览器的优点。相较于 Selenium，Playwright 还有更加强大的优势。
Playwright 有哪些优点 支持所有流行的浏览器。
速度更快，更可靠的执行。
更强大的自动化测试配置。
强大的工具库：
Codegen：通过记录你的操作来生成测试。 将它们保存为任何语言。
Playwright inspector： 检查页面、生成选择器、逐步执行测试、查看点击点、探索执行日志。
Trace Viewer：捕获所有信息以调查测试失败，Playwright 跟踪包含测试执行截屏、实时 DOM 快照、动作资源管理器、测试源等等。
环境安装 Python 版本
安装 playwright 插件：pip install pytest-playwright
安装所需的浏览器：playwright install
Java 版本
在 pom.xml 中添加依赖。
&lt;!-- playwright依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.microsoft.playwright&lt;/groupId&gt; &lt;artifactId&gt;playwright&lt;/artifactId&gt; &lt;version&gt;1.29.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- maven编译使用的插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.10.1&lt;/version&gt; &lt;/plugin&gt; 创建一个项目
import com.microsoft.playwright.*; import java.nio.file.Paths; public class App { public static void main(String[] args) { try (Playwright playwright = Playwright.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db79329fab58b22a379653c23be94dde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d3f785a3556e850ad67bf9ef50b7776/" rel="bookmark">
			使用Vite安装并初始化Vue2 &#43; pinia &#43; vue-router项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用vite创建项目 使用 npm create vite 命令先创建项目，选择框架时选择 Vanilla。
这里不选择vue是因为vite的vue默认版本位vue3 。
为避免重复卸载包，所以选择vanilla vite给出的选项对应如下：
vanillavuereactpreactlitsvelte vite cli的选择
安装依赖 vite给出了接下来操作的提示，需要npm install 安装所有的依赖包，这些包都包含在package.json中，执行npm install 会读取其中的信息，自己使用npm install 也会将对应信息加入到package.json文件中。
本项目会用到vue2、pinia、vue-router三个包，首先安装vue2的包
npm install vue@2 -D
这里-D的意思是写入 package.json 文件中的 “devDependencies” 关键字下，package.json有"devDependencies"和"dependencies" 关键字，两者的区别是在生产环境下只下载安装 “dependencies” 内的包，开发环境下两个关键字中的包都会安装。（不加-D 就会安装到 “dependencies” 中)
这里我将vue2安装到了"devDependencies"中，是希望在生产环境下可以通过cdn的方法减少项目加载时间，但这点安装到哪里都无所谓。
//此时package.json的配置 { "name": "vue2pinia", "private": true, "version": "0.0.0", "type": "module", "scripts": { "dev": "vite", "build": "vite build", "preview": "vite preview" }, "devDependencies": { "vite": "^4.0.0", "vue": "^2.7.14" } } 其次安装pinia，pinia作为状态管理工具，对vue的版本没那么敏感，直接安装最新版
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d3f785a3556e850ad67bf9ef50b7776/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aea9f3842874e5eb0f253420fd8c9114/" rel="bookmark">
			mysql清空表命令-delete&amp;truncate详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql可以用delete或truncate来完成表清空：
一、 delete清空
1、使用语法
delete from table_name；
2、使用示例
DELETE FROM `order`;
二、truncate清空
1、 使用语法
truncate table table_name；
2、使用示例
TRUNCATE TABLE `order`;
三、 delete&amp;truncate两者区别
1、使用delete清空表中的记录，内容的ID仍然从删除点的ID继续建立，而不是从1开始。而truncate相当于保留了表的结构而重新建立了一张同样的新表。delete的效果有点像将mysql表中所有记录一条一条删除到删完。
2、效率上truncate比delete快。但truncate删除后不记录mysql日志，不可以恢复数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0c763ad8435d33edd8f4e83d7daf0a2/" rel="bookmark">
			比价寄快递CPS小程序开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比价寄快递CPS小程序开发
核心功能：根据地址比对价格；下单最低四元起；运费补差价；分销合伙人模式；售后工单。
特别注意：快递下单接口为易达快递平台，费用需要向易达平台充值zui低200元，无其他费用。使用方法非常简单，后台基本设置，快递管理里面的信息设置好后 手机端就可以上传使用啦，每一项设置文本框下有相应的提说说明。
小程序端：基础信息、物品信息、首次获取用户手机号、下单、各个快递价格对比、模板消息、通知下单、支付运费补差价、查询订单、取消订单、退款、分享返利、分销返利、会员等级、文章列表、售后工单、钱包、佣金提现。
后台：基本设置、快递管理、会员等级、会员中心、提现管理、订单管理、分销海报、消息公告、售后工单。
更新：增加首页客服图标可后台上传更改和开关，本次更新【需要】上传小程序。
随着互联网的发展，我们现在每天都能接触到各种不同类型的信息。这些信息中有很多是对自己生活、工作或学习有帮助和启迪意义的资讯。但如果你想要获取一个准确又全面而且实用性高的内容时就可以使用比价寄快递CPS小程序开发了！
目前，比价寄快递CPS小程序支持的功能包括：查询附近所有快递公司；搜索并浏览最新物流进度消息；根据商品标签筛选商家及优惠套餐;关注感兴趣店铺，领取专属推广红利等。该小程序还具备社交分享功能，通过将链接转发至微信群组与好友共享便捷服务体验之后即可赚钱佣金哦此外，用户也可为喜欢的店铺打call哦!总得来说，比价寄快递CPS小程序主要提供给大众更加方便快速地寻找周边寄送平台，让人们省去东奔西走的麻烦，直达心仪物美价廉的寄件渠道。另外，平台上线运营数月，已经积累超3000名忠诚客户啦!赶紧行动起来吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70dba66e255491c9edaf951f15dfffcd/" rel="bookmark">
			MC 1.19.3&#43;forge&#43;暮色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 安装java服务器forge暮色森林mod客户端后文参考网址 安装java apt install openjdk-17-jdk -y # 安装java java --version 服务器 # ~/ mkdir mcServer cd mcServer # ~/mcServer wget https://piston-data.mojang.com/v1/objects/f69c284232d7c7580bd89a5a4931c3581eae1378/server.jar java -jar server.jar nogui 服务器网址
# ~/mcServer # 修改eula为true vim eula.txt # 同意条款 # 修改online-mode = false vim server.properties # 安装到这里，服务器已经可以启动了，不过是原版 java -jar server.jar nogui # 即可启动MC服务器,端口号25565 forge # ~/mcServer # 下载forge wget https://maven.minecraftforge.net/net/minecraftforge/forge/1.19.3-44.1.8/forge-1.19.3-44.1.8-installer.jar # 安装 forge java -jar forge-1.19.3-44.1.8-installer.jar -installServer # 等待，需要的时间挺长的,安装过程中会有几个超时，实际测试不影响运行 sh ./run.sh # 启动 ctrl+c #终止后会出现mods的文件夹 forge下载网址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70dba66e255491c9edaf951f15dfffcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85414e57defcb2ca5e40877b37e8ea29/" rel="bookmark">
			Ubuntu的防火墙命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Ubuntu # 安装防火墙 sudo apt install ufw # 启动防火墙 sudo ufw enable # 系统启动时自动开启 sudo ufw default deny # 防火墙开放端口 sudo ufw allow | deny [service] # 重启防火墙(刷新配置) sudo ufw reload 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/172/">«</a>
	<span class="pagination__item pagination__item--current">173/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/174/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>