<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3704b0720ed45bc94e9e39c71ef3919/" rel="bookmark">
			linux less-分屏上下翻页浏览文件内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主推荐：获取更多 linux文件内容查看命令 收藏：linux命令大全
less命令的作用与more十分相似，都可以用来浏览文字档案的内容，不同的是less命令允许用户向前或向后浏览文件，而more命令只能向前浏览。用less命令显示文件时，用PageUp键向上翻页，用PageDown键向下翻页。要退出less程序，应按Q键。 语法 less(选项)(参数) 选项 -e：文件内容显示完毕后，自动退出； -f：强制显示文件； -g：不加亮显示搜索到的所有关键词，仅显示当前显示的关键字，以提高显示速度； -l：搜索时忽略大小写的差异； -N：每一行行首显示行号； -s：将连续多个空行压缩成一行显示； -S：在单行显示较长的内容，而不换行显示； -x&lt;数字&gt;：将TAB字符显示为指定个数的空格字符。 参数 文件：指定要分屏显示内容的文件。
转载于:https://www.cnblogs.com/mayou18/p/9558549.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce5c41b6ce96dc9e86bc1a713f44544d/" rel="bookmark">
			usb3.1和3.0的区别，usb3.1有什么优点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从测试结果来看，USB 3.1接口的实际性能要比USB 3.0高出不少，连续读写速度在500MB/s到600MB/s左右，最高成绩甚至可以突破700MB/s。而USB 3.0接口方面，其连续读写速率大概在300MB/s到400MB/s左右。
虽然USB 3.1标称的接口理论速率是10Gbps，但是其还保留了部分带宽用以支持其他功能，因此其实际的有效带宽大约为7.2Gbps，理论传输速度应该可以达
到900MB/s，因此认为，现在的USB 3.1接口还有很大的提升空间，至少应该达到800MB/s的水平。
关于USB3.1现在已是大家讨论的焦点，USB3.1是最新的USB规范，该规范由英特尔等大公司发起。数据传输速度提升可至速度10Gbps。与USB 3.0技术相比，新USB技术使用一个更高效的数据编码系统，并提供一倍以上的有效数据吞吐率。它完全向下兼容现有的USB连接器与线缆。，而相关的USB3.1产品也陆续走入人们的视线，其中尤其以为传统主机端设备提供扩展接口的主板最为活跃。虽然Intel到下一代 100系芯片组中仍不会提供原生的USB3.1支持，但就像以前USB3.0一样，在尚未有原生方案之前，都是以整合第三方的主控芯片提供新接口。
向左转|向右转
USB3.1标准于2013年7月发布，最大理论带宽相比USB3.0时翻了一番，达到10Gb/s（Super Speed+）。USB3.1编码方式从此前USB3.0的8b/10b换成了128b/132b，带宽损耗率从20%大幅下降到3%左右，换算之后带宽同样超过了1.2GB/s，这也意味着在真实使用中USB3.1的极限传输速率有望接近1GB/s。
虽然像过去的升级一样，USB3.1同样带来了更高的传输速率，并修复了此前存在的各方面问题，但人们谈论更多的都是随USB3.1引入的全新Type-C接口。与苹果的Lightning接口相似，Type-C接口取消了曾经的防呆保护设计，因此不分正反均可正常插入使用，免去了辨识插入方向的麻烦。
USB3.1 Type-C的另一个大卖点就是对移动设备充电能力的的增强。USB 3.1接口下的供电最高允许标准大幅提高到了20V/5A（仅限于Type-A/B），能够提供达100W的供电输出能力。而Type-C的最高标准为12V/3A，36W的充电能力已经足够一些轻薄型笔记本的使用，这也是New MacBook敢于放弃MagSafe而采用Type-C作为充电接口的重要原因。功能上USB 3.1 Type-C还引入了全新的Alternate Mode（交替模式），这意味着Type-C接口和数据线能传送非USB数据信号。目前Alt Mode已经能够支持DisplayPort 1.3和MHL 3.2规范，而USB-IF同时也在寻求对其他的功能标准的支持，除了视频接口，像以太网等其他接口同样也可以被Type-C支持。USB3.1与USB3.0传输速度对比
目前虽然仍没有原生的USB3.1支持，但是比起原生的USB3.0，第三方的USB3.1解决方案最高的存取速度还是能高出原生USB 3.0达到60%以上，整体性能并没有令我们失望。
USB 3.1是最新的USB规范，该规范由英特尔等大公司发起。
数据传输速度提升可至速度10Gbps。
与USB 3.0技术相比，新USB技术使用一个更高效的数据编码系统，并提供一倍以上的有效数据吞吐率。它完全向下兼容现有的USB连接器与线缆。
usb 3.1有三种连接介面，分别为Type-A（Standard-A）、Type-B（Micro-B）以及Type-C
向左转|向右转
Type-A（Standard-A）（左边）和Type-C（右边）
向左转|向右转
Type-B（Micro-B）
USB的频宽从1.0版本（1.5Mbps）、1.1版本（12Mbps）、2.0版本（480Mbps）到3.0版本（5Gbps），速度已经有很大的进步了，而面对将来的需求，新的USB 3.1介面将把频宽再翻倍，提升至10Gbps，同时值得注意的是，编码率也再度提升。
电力供应规范
相比USB 2.0的5V/0.5A，USB 3.0提供了5V/0.9A电源。但人们任然希望更强的供电能力，于是USB 3.1(SuperSpeed+)将供电的最高允许标准提高到了20V/5A，供电100W。
usb3.1有什么优点？
总得来说新的USB3.1以下五个优势。
超高理论带宽下快到飞起的读写速度
理论上USB3.1端口的带宽为10Gpbs，当然实际速度肯定是离理论值还差很远，但这也不妨碍我们在实际测试中达到800M/s的超高读写速度。
超薄接口或将带来便携电子设备新一波超薄化狂潮
老式USB端口长1.4厘米、宽0.65厘米的尺寸显然已经满足不了便携电子设备尤其是手机厂商日益迫切的超薄化需要了，而USB3.1Type-C长0.83厘米、宽0.26厘米的尺寸显然又在轻薄这点上上了一个台阶。手机端接口从最开始的Mini USB升级到Micro USB后已经成了所有智能手机的标配也间接地推动了智能手机超薄化的第一波浪潮，再到如今尺寸超薄的USB3.1 Type-C，不难想象在不久的将来新一波便携电子设备又将掀起一波“没有最薄只有更薄的浪潮了”。
双面插拔显著改善使用体验
这次USB3.1Type-C带来的一个非常大的优势在于，双面插拔不分正反的设计极大的改善了一直以来USB数据线糟糕的使用体验。相信很多安卓用户要开始感叹一声，终于闭着眼也能给手机充上电了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a960c445c66236bcffe9ad613f175a/" rel="bookmark">
			TSM文件格式及实例解析（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
格式概述
Header
Footer
Indexes
DataBlocks
TimeStamps
Data values
实例分析
数据产生
数据分析
小结：
格式概述 TSM文件格式如下
HeaderDatablocksIndexesFooter5 bytesN bytesN bytes8 bytes Header 如图所示，TSM文件由Header, Datablocks, Indexes, Footer四个部分构成。
HeaderMagic Number 4 bytesVersion
1 byte Magic Number(4 bytes)：表示何种存储引擎，TSM引擎代号就是 0x16d116d1
Version (1 bytes): 表示存储引擎版本号，目前TSM1，版本号为1
Footer FooterIndexes offset8 bytes Footer这8个bytes标明了Indexes部分的起始位置的offset. 这样就能够直接找到Indexes
Indexes IndexesIndexIndexIndex... Indexes 由一个或多个Index组成
每一个Index结构由8个部分构成
IndexKey lenKeyTypeCountMin TimeMax TimeOffsetData Size...2 bytesN bytes1 byte2 bytes8 bytes8 bytes8 bytes4 bytes Key (N bytes): seriresKey+ 分隔符(#!~#) + field
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5a960c445c66236bcffe9ad613f175a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/804af8fed093ba7dcd78f4fa7970bb52/" rel="bookmark">
			rocketmq启动mqnamesrv报错 Address already in use
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天发现mq双主双从的4个节点测试环境 有3个节点nameserver服务宕机
重启发现报错
[root@ysmq15a22 bin]# ./mqnamesrv
java.net.BindException: Address already in use
at sun.nio.ch.Net.bind0(Native Method)
at sun.nio.ch.Net.bind(Net.java:437)
at sun.nio.ch.Net.bind(Net.java:429)
at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:223)
at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:74)
at io.netty.channel.socket.nio.NioServerSocketChannel.doBind(NioServerSocketChannel.java:125)
at io.netty.channel.AbstractChannel$AbstractUnsafe.bind(AbstractChannel.java:484)
at io.netty.channel.DefaultChannelPipeline$HeadContext.bind(DefaultChannelPipeline.java:1080)
at io.netty.channel.AbstractChannelHandlerContext.invokeBind(AbstractChannelHandlerContext.java:430)
at io.netty.channel.AbstractChannelHandlerContext.bind(AbstractChannelHandlerContext.java:415)
at io.netty.channel.DefaultChannelPipeline.bind(DefaultChannelPipeline.java:903)
at io.netty.channel.AbstractChannel.bind(AbstractChannel.java:197)
at io.netty.bootstrap.AbstractBootstrap$2.run(AbstractBootstrap.java:350)
at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:380)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:357)
at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:116)
at java.lang.Thread.run(Thread.java:745)
之前4个节点安装都是一样的。
nameserver端口默认是9876
查看该端口没有被监听 netstat -tln | grep 9876
花了不少时间也没有解决 最后重启了服务器 再次启动就行了。。
浪费时间 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/235cf8998cdd9718a8b580e7a0aaa192/" rel="bookmark">
			Flutter学习之Scaffold布局控件介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 Scaffold 实现了基本的 Material 布局。只要是在 Material 中定义了的单个界面显示的布局控件元素，都可以使用 Scaffold 来绘制。
提供展示抽屉（drawers，比如：左边栏）、通知（snack bars） 以及 底部按钮（bottom sheets）。
我们可以将 Scaffold 理解为一个布局的容器。可以在这个容器中绘制我们的用户界面。
源码图示 说明 Scaffold 主要的属性说明 appBar：显示在界面顶部的一个 AppBar
相关连接：https://flutterchina.club/catalog/samples/
body：当前界面所显示的主要内容
floatingActionButton： 在 Material 中定义的一个功能按钮。
persistentFooterButtons：固定在下方显示的按钮。https://material.google.com/components/buttons.html#buttons-persistent-footer-buttons
drawer：侧边栏控件
bottomNavigationBar：显示在底部的导航栏按钮栏。可以查看文档：Flutter学习之制作底部菜单导航
backgroundColor：背景颜色
resizeToAvoidBottomPadding： 控制界面内容 body
是否重新布局来避免底部被覆盖了，比如当键盘显示的时候，重新布局避免被键盘盖住内容。默认值为 true。
代码示例 class Scaffold extends StatefulWidget { /// Creates a visual scaffold for material design widgets. const Scaffold({ Key key, this.appBar, //横向水平布局，通常显示在顶部（*） this.body, // 内容（*） this.floatingActionButton, //悬浮按钮，就是上图右下角按钮（*） this.floatingActionButtonLocation, //悬浮按钮位置 //悬浮按钮在[floatingActionButtonLocation]出现/消失动画 this.floatingActionButtonAnimator, //在底部呈现一组button，显示于[bottomNavigationBar]之上，[body]之下 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/235cf8998cdd9718a8b580e7a0aaa192/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdc94808dfaa570a7415d11f9e22876b/" rel="bookmark">
			linux strings-在对象文件或二进制文件中查找可打印的字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐：更多Linux 文件查找和比较 命令关注：linux命令大全
strings命令在对象文件或二进制文件中查找可打印的字符串。字符串是4个或更多可打印字符的任意序列，以换行符或空字符结束。 strings命令对识别随机对象文件很有用。 语法 strings [ -a ] [ - ] [ -o ] [ -t Format ] [ -n Number ] [ -Number ] [ file ... ] 选项 -a --all：扫描整个文件而不是只扫描目标文件初始化和装载段 -f –print-file-name：在显示字符串前先显示文件名 -n –bytes=[number]：找到并且输出所有NUL终止符序列 - ：设置显示的最少的字符数，默认是4个字符 -t --radix={o,d,x} ：输出字符的位置，基于八进制，十进制或者十六进制 -o ：类似--radix=o -T --target= ：指定二进制文件格式 -e --encoding={s,S,b,l,B,L} ：选择字符大小和排列顺序:s = 7-bit, S = 8-bit, {b,l} = 16-bit, {B,L} = 32-bit @ ：读取中选项 实例 列出ls中所有的ASCII文本： strings /bin/ls 列出ls中所有的ASCII文本： cat /bin/ls strings 查找ls中包含libc的字符串，不区分大小写： strings /bin/ls | grep -i libc strings命令在对象文件或二进制文件中查找可打印的字符串。字符串是4个或更多可打印字符的任意序列，以换行符或空字符结束。 strings命令对识别随机对象文件很有用。 语法 strings [ -a ] [ - ] [ -o ] [ -t Format ] [ -n Number ] [ -Number ] [ file .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdc94808dfaa570a7415d11f9e22876b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a909e0b3a25772142a76f2e201a89c5b/" rel="bookmark">
			Nuxt项目的部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目介绍 项目中整合 vue + nuxt + axios + vuex + vue-router (nuxt 自带 vuex 和 vue-router)，一个基于 Nuxt 的服务器端渲染 Demo
PC端GitHub地址
移动端GitHub地址
一、PC端项目部署 关于项目部署折腾了我好多时间，网上许多百度来的文档不适合我的项目，所以自己摸索着终于部署起来了，开心O(∩_∩)O~~
1、项目打包 详情请看 Nuxt官网
命令描述nuxt启动一个热加载的 Web 服务器（开发模式） localhost:3000nuxt build利用 webpack 编译应用，压缩 JS 和 CSS 资源（发布用）nuxt start以生成模式启动一个 Web 服务器 (nuxt build 会先被执行)nuxt generate编译应用，并依据路由配置生成对应的 HTML 文件 (用于静态站点的部署) 第一步、在本地 npm run build,会在.nuxt文件夹下生成dist文件;
第二步、把本地文件的.nuxt,static,package.json,nuxt.config.js,这四个文件夹放到服务器目录文件下，我在服务器上创建了run/www/visneyNuxt路径，四个文件放到里面;
第三步、用cmd进入目录文件夹，安装依赖，npm install -production;
第四步、npm start 此时运行的是 http://localhost:3000;
2、Nginx配置 项目进行到现在，在服务器上的项目正常没有问题，但是当我们在浏览器中输入http://www.visney.cn/，额，震惊，你并没有看到自己想要的结果，(；′⌒`)
这时候就改Nginx出场时候啦，当当当当~~~
(1)、Nginx安装 第一步、Nginx 的安装步骤比较简单，安装在windows上推荐使用压缩包的安装方式，下载地址;
第二步、有稳定版本和最新版本及以前版本，推荐使用稳定版本开发
第三步、下载完成之后，进行解压可以看到如下 文件结构 第四步、双击nginx,exe 就启动了。在页面输入localhost。出现如下界面则表示安装成功。默认监听80端口号 第五步、若你的服务器上80端口被占用，需要修改端口，Windows 下 安装目录\conf\nginx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a909e0b3a25772142a76f2e201a89c5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c3f2944e142f025fb9898580f50a41c/" rel="bookmark">
			Jquery获取select选中的文本与值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jquery获取select选中的文本与值 jquery获取select选择的文本与值
获取select ：
获取select 选中的 text :
$("#ddlregtype").find("option:selected").text();
获取select选中的 value:
$("#ddlregtype ").val();
获取select选中的索引:
$("#ddlregtype ").get(0).selectedindex;
设置select:
设置select 选中的索引：
$("#ddlregtype ").get(0).selectedindex=index;//index为索引值
设置select 选中的value：
$("#ddlregtype ").attr("value","normal“);
$("#ddlregtype ").val("normal");
$("#ddlregtype ").get(0).value = value;
设置select 选中的text:
var count=$("#ddlregtype option").length;
for(var i=0;i&lt;count;i++)
{ if($("#ddlregtype ").get(0).options[i].text == text)
{
$("#ddlregtype ").get(0).options[i].selected = true;
break;
}
}
$("#select_id option[text='jquery']").attr("selected", true);
设置select option项:
$("#select_id").append("&lt;option value='value'&gt;text&lt;/option&gt;"); //添加一项option
$("#select_id").prepend("&lt;option value='0'&gt;请选择&lt;/option&gt;"); //在前面插入一项option
$("#select_id option:last").remove(); //删除索引值最大的option
$("#select_id option[index='0']").remove();//删除索引值为0的option
$("#select_id option[value='3']").remove(); //删除值为3的option
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c3f2944e142f025fb9898580f50a41c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f03ea9de8cb0d49e98d05caa412800e/" rel="bookmark">
			idea中mybatis自动生成工具及用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在maven工程中的resource中创建generatorConfigxml配置generatorConfigxml的配置pomxml生成对象的两种方式 方式一使用idea的maven插件直接快速生成方式二在Intellij IDEA添加一个Run运行选项使用maven运行mybatis-generator-maven-plugin插件 Step1选择配置edit configurationStep2创建maven运行项Step3配置命令 mybatis-generatorgenerate -eStep4运行 1.在maven工程中的resource中创建generatorConfig.xml 配置generatorConfig.xml的 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt; &lt;generatorConfiguration&gt; &lt;!--mysql 连接数据库jar 这里选择自己本地位置--&gt; &lt;classPathEntry location="D:/mysql-connector-java-5.1.20-bin.jar" /&gt; &lt;context id="testTables" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name="suppressAllComments" value="true" /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/ecps" userId="root" password="root"&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f03ea9de8cb0d49e98d05caa412800e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1569631f9b5c2dbeb801e33234e9f743/" rel="bookmark">
			【人脸识别考勤门禁】管理系统功能解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以往都是通过工卡刷门禁，往后通过指纹，人脸识别会更多。 人脸识别门禁考勤管理平台”就是为了满足人们对现代化办公和生活场所的更高层次安全、智能管理的需要应运而生的。通过分级管理，设置管理层次，分配管理责任；通过权限管理，区分人员类型，保证出入口安全；通过考勤管理，规范考勤制度，简化工作流程等。 BaDaMa人脸识别门禁釆用最先进的人工智能人睑识别技术，对进出人员进行刷脸安全检测和识别，记录所有授权人员进出时间和地点进出拍照保存，安保人员实时监察每度门进出状况可以远程控制开关门，当非授权者试图闯入受监控场所时，系统会实时自动发出报警信号。 门禁管理系统主机是高度智能化的计算机，独立工作，统一由管理监控计算机管理。具有以下功能： 一）实时监控，安保人员通过实时监控画面能清楚看到毎一道门进出情况，包括未授权拍卡刷脸、非法时段拍卡刷脸、门未回位及门常开常闭等功能。 二）门未回位报警，人脸门禁机自带门未回位监察功能，当门被推开后，在预设时间内未回位关门及未经授权私自闯入进门，设备会实时自动发出报警信号。 三）进出拍照，人脸门禁机可以在员工进出门禁拍卡刷脸时拍下照片和保存，配合人照储存服务器能查找全厂员工每次进出门禁真实记录。 a）人脸比对识别：对由人脸采集器采集的人脸信息进行比对识别，确认用户的合法性。若为合法用户，则向电琐发出开门信号，进行门禁控制，若为非法用户则拒绝开门。 b）数据存储：存放子系统的所有设置参数、人脸信息、开门记录。 c）锁控制：对通过锁控器输入的门禁信号（如门状态信号等）进行处理，控制锁控器。 d）执行管理监控机的指令：接受管理监控计算机的指令，输出门禁信号（开门、闭门、在某段时间内门常开、在某段时间内门常闭）和报警信号给锁控器，实现远程控制功能。 e）信号采集：将锁控器采集到的锁状态信号输出给监控计算机，集中监控各子系统的工作状态； f）开门记录输出：将开门记录输出给管理监控计算机，在监控中心就可实时查询各门禁点人员的出入情况，并可集中输出门禁报表。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47ee0d3940296ac994a2562080d90989/" rel="bookmark">
			linux expr语法错误的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习写shell脚本的时候，碰到这么一个问题，
PRICE=`expr $RANDOM % 1000`
或者 PRICE=$(expr $RANDOM % 1000)，即1000内取随机数
这行代码报出expr语法错误的问题，在网上查了好久，看到也确实有同学提出这个问题，但是没有得到有效回答，在自己经过好一会儿查资料、测试之后发现问题出现在
random % 1000 这三者之间 必须有空格！
ok 问题就在这儿，但愿以后的同学不要为此耽误太长时间，初学者碰到这种问题太多了，大神也不好帮咱
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a090ffd12b09540b09c8fd54ffd90db/" rel="bookmark">
			VB中Msgbox提示框代码“vbOKOnly”与“vbOKCancel”的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在做机房系统退卡窗体时，出于要有良好的用户体验时，我觉得在选好卡号之后，点击确定，要提示一下用户，确定是否删除本卡，防止用户时候着急操作失误。
遇到的问题 当我最开始时编辑的代码是这样的
If MsgBox("是否真的要退卡？", vbOKonly, "退卡提示") = vbok Then MsgBox"退卡成功！", vbOKOnly, "提示" end if 但是很快我发现了问题，由于提示框内只有一个“确定”按钮，那如果我想取消退卡，是不是点击右上角的“×”就可以了。但是事实并非如此，不管我点击“确定”还是点击“×”，代码都是按照“确定”进行下一步。我想这可不行啊，这样的话，那这个提示不就没有任何用处了嘛！所以我就自己琢磨，自己尝试，于是乎我将代码改成下面这样，问题就解决了。
If MsgBox("是否真的要退卡？", vbOKCancel, "退卡提示") = vbok Then MsgBox"退卡成功！", vbOKOnly, "提示" end if 虽然就是将vbOkonly简单的换成了vbOKCancel,但是非常方便的解决了那个问题。现在如果不想退卡，只需要点击取消即可。
总结 当用vbOkonly时，弹出的窗体只有“确定”和“×”按钮，无论点击那个，都会按照vbOK的指令进行。
但是使用vbOkCancel时，弹出的窗体有“确定”、“取消”和“×”三个按键，这时的“×”才和“取消”按键一样，是取消该操作的过程。
小小的×，在不同的环境中还是有这么多的学问！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4abebe7f7d010d6949ae622c75e48de/" rel="bookmark">
			iview 更新左侧菜单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于iview-admin框架
原理：原理比较简单，左侧菜单的路由列表是有
&lt;side-menu accordion ref="sideMenu" :active-name="$route.name" :collapsed="collapsed" @on-select="turnToPage" :menu-list="menuListActive"&gt; 加载，menuListActive是可以随时更新的list集合，所以我们可以通过某个事件更新menuListActive的内容来更新左侧菜单
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8b79e3ed6370cda0ae1a2c037d9cc0b/" rel="bookmark">
			shell 数组遍历的3种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 shell数组的基本知识请参阅我的上一篇博客shell 数组 首先创建一个数组 array=( A B C D 1 2 3 4)
1.标准的for循环 for(( i=0;i&lt;${#array[@]};i++)) do
#${#array[@]}获取数组长度用于循环
echo ${array[i]};
done;
2.for … in 遍历（不带数组下标）：
for element in ${array[@]}
#也可以写成for element in ${array[*]}
do
echo $element
done
遍历（带数组下标）：
for i in "${!arr[@]}"; do printf "%s\t%s\n" "$i" "${arr[$i]}" done 3.While循环法： i=0 while [ $i -lt ${#array[@]} ] #当变量（下标）小于数组长度时进入循环体
do echo ${ array[$i] } #按下标打印数组元素
let i++ done 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/195efac9897d66044f29187532e2c007/" rel="bookmark">
			内核调试出现value optimized out的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在用gdb调试内核的过程中经常会有&lt; value optimized out&gt;的提示，
首先分析该提示出现的原因，我的理解是可能这些被优化的变量已从内存中被移到了寄存器中，所以会找不到。
为了能在调试过程中看到所有的变量，不知道能不把内核编译为-O0？若可以的话，又需要在什么地方来改呢？
在所有的CONFIG中，我只发现了一个CONFIG_CC_OPTIMIZE_FOR_SIZE选项，但只是用来打开-Os的
解决方法 在内核源码的Makefile文件中，找到CONFIG_CC_OPTIMIZE_FOR_SIZE，可以看到如下代码：
ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE KBUILD_CFLAGS += -Os $(call cc-disable-warning,maybe-uninitialized,) else KBUILD_CFLAGS += -O2 endif 如果你打开了CONFIG_CC_OPTIMIZE_FOR_SIZE 就把那里的-Os改为-O0， 如果关闭了CONFIG_CC_OPTIMIZE_FOR_SIZE，就把下面的-O2改为-O0试试。
编译时指定-O0：不进行优化
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fad5aa1728227a0eaa6683e542652c6a/" rel="bookmark">
			Android中线程的终止
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程对象属于一次性消耗品，一般线程执行完run方法之后，线程就正常结束了，不能再次start，只能新建一个线程对象。
所以正常退出run方法，一般就能正常结束线程。在很多情况下，run中都有循环，所以我们只要跳出循环，让run方法执行完，也就正常终止了线程
对于线程的终止，经过查询资料，大部分人提到了三种方法，就先说这三种
1.使用标志位来退出
2.使用interrupt()方法（注意，不是interrupted）
3.stop()方法
第一种：使用标志位来退出（volatile保证了只有一个线程在操作exit）
class MyThread extends Thread { public volatile boolean exit = false; public void run() { while (!exit) { Log.e("Thread", "running"); try { Thread.sleep(5000); threadSafe.exit=true; } catch (InterruptedException e) { e.printStackTrace(); break; } } Log.e("Thread", "stop"); } } 第二种:使用interrupt()方法
分两种情况：阻塞情况和正常情况
阻塞情况：
例如线程休眠时，使用interrupt()方法来抛出InterruptedException异常，在catch中break出循环
当阻塞状态时，如果有interrupt()发生，系统除了会抛出InterruptedException异常外，还会调用interrupted()函数，调用时能获取到中断状态是true的状态，调用完之后会复位中断状态为false，所以异常抛出之后通过isInterrupted()是获取不到中断状态是true的状态，从而不能退出循环。即阻塞状态下只能用break来推出，而不是标志位。
class MyThread extends Thread { public void run() { while (true) { Log.e(TAG, Thread.currentThread()+"running"); try { Thread.sleep(5000); threadSafe.interrupt(); } catch (Exception e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fad5aa1728227a0eaa6683e542652c6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84a52bdcdc6f3766718ae2864f48b82d/" rel="bookmark">
			X-editable 文档 中文版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 因为要用到 Bootstrap-table ，不可避免的会用到表格编辑功能，而 X-editable 可在页面上创建可编辑元素。 它可以与前端框架（Bootstrap，jQuery UI，jQuery ）配合使用，编辑模式包括弹出和行内模式。只是兜兜转转找了下只有英文文档，还是不方便查阅，所以进行了部分翻译。翻译范围为：Getting started与$().editable(options) 两部分，但这两部分足够完成80%的需要了，一部分是demo，另一部分是options。各输入组件（例如text、date、textarea等）一些不同的细微设置请查阅源文档。此翻译的文档版本为 X-editable 1.5.1（2018年8月）。翻译到中途的时候，发现个人能力有限，完整文档的翻译所费时间远远超出预期，向各位致以歉意。如有错误，烦请指教。
附上链接X-editable 英文文档 。
入门指导 决定使用哪一个前端框架：
BootstrapjQuery UIonly jQuery (+ Poshytip) ​
引入至页面中。以下是 bootstrap 的例子:
&lt;link href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;script src="http://code.jquery.com/jquery-2.0.3.min.js"&gt;&lt;/script&gt; &lt;script src="//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"&gt;&lt;/script&gt; 下载相应的 X-editable 库并且引入至页面中。
&lt;link href="bootstrap-editable/css/bootstrap-editable.css" rel="stylesheet"&gt; &lt;script src="bootstrap-editable/js/bootstrap-editable.js"&gt;&lt;/script&gt; 注意引入位置在前端框架之后
标记元素应该是可编辑的。 通常它是带有data-*属性的&lt;A&gt;元素。
&lt;a href="#" id="username" data-type="text" data-pk="1" data-url="/post" data-title="Enter username"&gt;superuser&lt;/a&gt; 您应该定义的主要属性是：
type - 文本输入类型(text, textarea, select 等等)url - 与服务器连接的URL，来交互一些需要处理的值 (/post, post.php 等等)pk - 要更新的记录的主键id or name - 要更新的字段的名称。 取自id或data-name属性value - 初始值。 对于select有用，其中value是要显示的文本的整数值。 如果为空 - 将取自元素html内容 ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84a52bdcdc6f3766718ae2864f48b82d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b13fd36ec2e61014b71015facbaded9/" rel="bookmark">
			CSP刷题初体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从简单的刷起吧~~
思路： ①初始化两个数组：a1用来存储输入的数据
a2用来存储a1中每个数据出现的次数
注意两个数组下标的对应
②找出a2中的最大元素max，并记录下标，找到对应的a1中的数值
③如若max有多个，映射到a1中，找出第一个后，分别和第二个、第三个……进行比较，选取最小的
知识点： 1、标准化输入输出：Scanner类
2、数组的创建：
①初始化
int a[ ] = {1,2,3,4,5}; ②用关键字new来创建
int a[ ] = new int [5]; //创建一个有5个元素的整型数组a ③使用 clone（ ）方法
int [ ]b = (int [ ])a.clone( ); //数组a和数组b的类型完全一致 ④引用其他数组
int [ ]b = a; 3、找数组中的最大元素：循环比较
详细代码： import java.util.Scanner; public class Main { public static void main(String args[]) { int min=0;	//出现相同次数的最小数字 int max=0;	//最多次数 int temp=0; Scanner sc = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b13fd36ec2e61014b71015facbaded9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3fa948a834f700932f759428c6c92e3/" rel="bookmark">
			MySQL之ORDER BY 详细解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 概述 MySQL有两种方式可以实现ORDER BY：
1.通过索引扫描生成有序的结果
2.使用文件排序(filesort)
围绕着这两种排序方式，我们试着理解一下ORDER BY的执行过程以及回答一些常见的问题（下文仅讨论InnoDB存储引擎）。
2 索引扫描排序和文件排序(filesort)简介 我们知道InnoDB存储引擎以B+树作为索引的底层实现，B+树的叶子节点存储着所有数据页而内部节点不存放数据信息，并且所有叶子节点形成一个**(双向)链表**。
举个例子，假设userinfo表的userid字段上有主键索引，且userid目前的范围在1001~1006之间，则userid的索引B+树如下(这里只是为了举例，下图忽略了InnoDB数据页默认大小16KB、双向链表，并且假设B+树度数为3、userid顺序插入)：
现在我们想按照userid从小到大的顺序取出所有用户信息，执行以下SQL：
SELECT *
FROM userinfo
ORDER BY userid;
MySQL会直接遍历上图userid索引的叶子节点链表，不需要进行额外的排序操作。这就是用索引扫描来排序。
但如果userid字段上没有任何索引，图1的B+树结构不存在，MySQL就只能先扫表筛选出符合条件的数据，再将筛选结果根据userid排序。这个排序过程就是filesort。
下文将详细介绍这两种排序方式。
3 索引扫描排序执行过程分析 介绍索引扫描排序之前，先看看索引的用途
SQL语句中，WHERE子句和ORDER BY子句都可以使用索引：WHERE子句使用索引避免全表扫描，ORDER BY子句使用索引避免filesort（用“避免”可能有些欠妥，某些场景下全表扫描、filesort未必比走索引慢），以提高查询效率。
虽然索引能提高查询效率，但在一条SQL里，对于一张表的查询 一次只能使用一个索引（注：排除发生index merge的可能性），也就是说当WHERE子句与ORDER BY子句要使用的索引不一致时，MySQL只能使用其中一个索引(B+树)。
也就是说，一个既有WHERE又有ORDER BY的SQL中，使用索引有三个可能的场景：
只用于WHERE子句 筛选出满足条件的数据
只用于ORDER BY子句 返回排序后的结果
既用于WHERE又用于ORDER BY，筛选出满足条件的数据并返回排序后的结果
举个例子，我们创建一张orderdetail表 记录每一笔充值记录的userid(用户id)、money(充值金额)、create****time(充值时间)，主键是自增id：
CREATE TABLE `order_detail` (
`id` int(11) NOT NULL AUTO_INCREMENT,
`userid` int(11) NOT NULL,
`money` float NOT NULL,
`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
PRIMARY KEY (`id`),
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3fa948a834f700932f759428c6c92e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b89fa29d82e9ef922de1a909771e5f06/" rel="bookmark">
			JavaSE基础(83) StringBuffer可变字符串(值可以改变)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		StringBuffer可变字符串 == 》值可以改变
构造方法：
StringBuffer() ： 创建一个空的可变字符串对象
StringBuffer(String s) ： 创建一个指定字面量的可变字符串对象
方法：（具体查api文档）
append(任何类型的参数)：把指定的参数拼接到当前字符串的末尾。 不会生成新的字符串对象
delete(int start,int end) : 删除索引为start到end范围的字符串，含前不含后 （基本上带start与end参数的都是含前不含后）
ex1:
/* * 此代码创建了10个字符串对象，对内存是极大的浪费 * 像这种需要频繁的修改字符串值的情况，不建议使用不可变字符串：Stirng * 建议使用可变字符串：StringBuffer * 可变字符串的特点：每次修改值，不会创建新的对象 * 修改之后：从始至终都只有一个可变字符串对象 */ public class Demo{ public static void main(String[] args) { StringBuffer sb = new StringBuffer(); for(int i = 0;i&lt;10;i++){ sb.append(i + " "); } System.out.println(sb); } } 运行结果图：
ex2:
public class Demo { public static void main(String[] args) { StringBuffer sb = new StringBuffer(); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b89fa29d82e9ef922de1a909771e5f06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34aedd82fa30673cb3160fe7555ea401/" rel="bookmark">
			SQLSERVER还原数据库失败：错误: 3154的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天将公司原有的.net程序迁移到新的服务器,往新服务器导入sql server 的备份文件的时候,出现了"SQLSERVER还原数据库失败：错误: 3154"的提示,百度了下找到了解决办法,特此将这次解决方法记录到博客里.也方便大家查看.
在SQL Server2005及以下版本做数据库备份还原时，需要首先建立数据库，然后才能进行数据库还原操作；
而在SQL Server2005以上版本做数据库还原时，不需要建立数据库，可以直接进行数据库备份操作，否则执行数据库还原操作时会报3154错误。
具体操作: 因为当时操作的时候没有截图,所以只在百度经验上找到对应的截图搬过来了.
1. 启动SQL Server2008，展开左侧目录树，在【数据库】节点上右键点击，弹出右键菜单，如图所示
2. 选择【还原文件和文件组(E)...】功能，弹出的【还原文件和文件组】对话框，在还原目标中的【目标数据库(Q)】一栏填入数据库名称，在还原的源中选择【源设备】，点击右侧红色框中的按钮，如图所示
3. 在弹出的【指定备份】对话框中选择【添加】按钮，弹出【选择文件】对话框，选择数据库备份的位置，选中后点击确认，在【指定备份】对话框中就会显示数据库备份列表，选择想要恢复的数据库备份，点击确定即开始数据库恢复，如图所示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30676817a583251b8ad7bd6f6df5da95/" rel="bookmark">
			【Codeup 1908】B: 连通图   （求图的连通块个数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://codeup.cn/problem.php?cid=100000620&amp;pid=1
问题 B: 连通图 时间限制: 1 Sec 内存限制: 32 MB
提交: 111 解决: 63
[提交][状态][讨论版][命题人:外部导入]
题目描述 给定一个无向图和其中的所有边，判断这个图是否所有顶点都是连通的。
输入 每组数据的第一行是两个整数 n 和 m（0&lt;=n&lt;=1000）。n 表示图的顶点数目，m 表示图中边的数目。如果 n 为 0 表示输入结束。随后有 m 行数据，每行有两个值 x 和 y（0&lt;x, y &lt;=n），表示顶点 x 和 y 相连，顶点的编号从 1 开始计算。输入不保证这些边是否重复。
输出 对于每组输入数据，如果所有顶点都是连通的，输出"YES"，否则输出"NO"。
样例输入 4 3 4 3 1 2 1 3 5 7 3 5 2 3 1 3 3 2 2 5 3 4 4 1 7 3 6 2 3 1 5 6 0 0 样例输出 YES YES NO 思路很简单，求连通块个数，判断是否为1？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30676817a583251b8ad7bd6f6df5da95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c33c6200b3b56888abdf3e34f2525e6a/" rel="bookmark">
			linux 排除某个文件cp多个文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查找某个文件中是否包含www关键字 用grep -i 关键字 文件所在目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f526d11d3786e05df19a37404dbd69e/" rel="bookmark">
			集线器、交换机、路由器、中继器及网关、网桥之间的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/qq_25606103/article/details/51288459
计算机网络体系中，有几样通信设备或者说网络名词出现的频率相当的高，它们是：中继器、集线器、网桥、交换机、路由器和网关。初学者或者非专业者可能会对这几个名词的含义和作用感到模糊不清，经常把这几个名词给混淆了。其实，弄清楚这几个计算机网络的名词并不困难，如果能以计算机网络层次的概念给它们划清界限的话，那就很容易把它们区分出来。那我现在就有条理地梳理一下它们各自的含义和作用，以及它们之间的联系。
那我们首先看一下这些网络设备分别处于计算机网络的哪些层次：
1.中继器 中继器(Repeater)是连接网络线路的一种装置,常用于两个网络节点之间物理信号的双向转发工作。中继器是最简单的网络互联设备,主要完成物理层的功能,负责在两个节点的物理层上按位传递信息,完成信号的复制、调整和放大功能,以此来延长网络的长度。它在OSI参考模型中的位置物理层。
由于存在损耗, 在线路上传输的信号功率会逐渐衰减,衰减到一定程度时将造成信号失真,因此会导致接收错误。中继器就是为解决这一问题而设计的。它完成物理线路的连接,对衰减的信号进行放大,保持与原数据相同。
中继器是模拟设备，用于连接两根电缆段。中继器不理解帧、分组和头的概念，他们只理解电压值。
一句话总结：中继器，就是简单的信号放大器，信号在传输的过程中是要衰减的，中继器的作用就是将信号放大，使信号能传的更远。
2.集线器 集线器（Hub）是中继器的一种形式，区别在于集线器能够提供多端口服务，也称为多口中继器。集线器在OSI／RM中的物理层。
一句话总结：集线器，差不多就是个多端口的中继器，把每个输入端口的信号放大再发到别的端口去，集线器可以实现多台计算机之间的互联，因为它有很多的端口，每个口都能连计算机。
3.网桥 网桥(Bridge)是一个局域网与另一个局域网之间建立连接的桥梁。网桥是属于数据链路层的一种设备，它的作用是扩展网络和通信手段，在各种传输介质中转发数据信号，扩展网络的距离，同时又有选择地将现有地址的信号从一个传输介质发送到另一个传输介质，并能有效地限制两个介质系统中无关紧要的通信。
一句话总结：网桥工作在数据链路层，将两个LAN连起来，根据MAC地址来转发帧，可以看作一个“低层的路由器”。
4.交换机 交换机（Swich)工作在第二层（即数据链路层），它要比集线器智能一些，它能分辨出帧中的源MAC地址和目的MAC地址，因此可以在任意两个端口间建立联系，在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。交换机通过对信息进行重新生成，并经过内部处理后转发至指定端口，具备自动寻址能力和交换作用。但是 交换机并不懂得IP地址，它只知道MAC地址。
交换机是使用硬件来完成以往网桥使用软件来完成过滤、学习和转发过程的任务。交换机速度比HUB快，这是由于HUB不知道目标地址在何处，发送数据到所有的端口。而交换机中有一张MAC地址表，如果知道目标地址在何处，就把数据发送到指定地点，如果它不知道就发送到所有的端口。这样过滤可以帮助降低整个网络的数据传输量，提高效率。但是交换机的功能还不止如此，它可以把网络拆解成网络分支、分割网络数据流，隔离分支中发生的故障，这样就可以减少每个网络分支的数据信息流量而使每个网络更有效，提高整个网络效率。
现代交换机是这样处理数据帧的：一旦目标头域（目标地址）已经进来了，尽管帧的其他部分还没有到达，则只要输出线路可以使用，交换机就开始转发该帧，而不需理会帧后面的内容，也即是说交换机并没有使用“存储—转发”交换方式。
一句话总结：交换机，可以理解为高级的网桥，他有网桥的功能，但性能比网桥强。交换机和网桥的细微差别就在于：交换机常常用来连接独立的计算机，而网桥连接的目标是LAN，所以交换机的端口较网桥多。
5.路由器 路由器（Router)工作在第三层（即网络层），它比交换机还要“聪明”一些，它能理解数据中的IP地址，如果它接收到一个数据包，就检查其中的IP地址，如果目标地址是本地网络的就不理会，如果是其他网络的，就将数据包转发出本地网络。与工作在网络物理层，从物理上划分网段的交换机不同，路由器使用专门的软件协议从逻辑上对整个网络进行划分。例如，一台支持IP协议的路由器可以把网络划分成多个子网段，只有指向特殊IP地址的网络流量才可以通过路由器。当IP子网中的一台主机发送IP分组给同一IP子网的另一台主机时，它将直接把IP分组送到网络上，对方就能收到。而要送给不同IP于网上的主机时，它要选择一个能到达目的子网上的路由器，把IP分组送给该路由器，由路由器负责把IP分组送到目的地。如果没有找到这样的路由器，主机就把IP分组送给一个称为“缺省网关（default gateway）”的路由器上。对于每一个接收到的数据包，路由器都会重新计算其校验值，并写入新的物理地址。网络中的设备用它们的网络地址（TCP／IP网络中为IP地址）互相通信。IP地址是与硬件地址无关的“逻辑”地址。目前TCP／IP网络，全部是通过路由器互连起来的，Internet就是成千上万个IP子网通过路由器互连起来的国际性网络。
路由器用于连接多个逻辑上分开的网络，几个使用不同协议和体系结构的网络。路由器利用网络层定义的“逻辑”上的网络地址（即IP地址）来区别不同的网络，实现网络的互连和隔离，保持各个网络的独立性。当一个子网传输到另外一个子网时，可以用路由器完成。它具有判断网络地址和选择路径的功能，过滤和分隔网络信息流。一方面能够跨越不同的物理网络类型（DDN、FDDI、以太网等等），另一方面在逻辑上将整个互连网络分割成逻辑上独立的网络单位，使网络具有一定的逻辑结构。
一句话总结：路由器的主要工作就是为经过路由器的每个IP数据包寻找一条最佳传输路径，并将该数据有效地传送到目的站点。 路由器的基本功能是，把数据（IP报文）传送到正确的网络。
6.网关 网关(Gateway)又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。 网关是一种充当转换重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。
一句话总结：网关，通过字面意思解释就是网络的关口。从技术角度来解释，就是连接两个不同网络的接口，比如局域网的共享上网服务器就是局域网和广域网的接口。
最后问两个问题：
1.交换机和路由器的区别？
从应用上说：
交换机和路由器的使用中最大的区别莫过于路由器内部可实现拨号上网，然后通过共享给多台电脑同时上网，而交换机内部不具有拨号功能，但交换机的作用是将网络信号分流，以实现更多电脑连接共享上网。
大家可以这样认为，交换机可以将多台电脑连接起来，与交换机互连的电脑本身则具备了互相通信的功能，组建成了一个内部局域网，但需要访问互联网还需要有网络支持，因此交换机一端需要连接到路由器，路由器即可实现交换功能，还可以拨号，实现宽带连接，并将宽带资源分配个交换机使用，这样就实现了多台电脑共享上网。
从概念上说：
路由，是三层设备，有选择道路的作用。比如你去罗马，有很多路可以走，怎么走省钱省时间，就是路由要做的，解决你应该按照那条路走的问题。当然还有基于三层的其他功能。
交换机，是二层设备。他就像你家门前的如或者你们楼道，附近的住户都知道去几层几号怎么走。
举个例子说明路由器和交换机的配合：我要去找小明借电脑，小明说他不在家，叫我自己去拿吧，同时还告诉我他家的地址是XX路XX小区XX号（好比ip地址），我根据小明告诉我的地址找到了小明的家（路由器的功能，寻找路径）。我进门发现他家居然有10台电脑，哪台是借给我的那台呢？噢，原来小明还告诉我他要借给我的电脑的编号（MAC地址），那样我就可以根据编号找到相应的电脑了。
在上述的例子中，如果我没有路由器，我就不知道怎么去小明家，更不用说拿到电脑；如果我没有拿到所需的电脑编号，我也拿不到电脑，因为有十台电脑，我不能乱拿；有个特殊情况，如果小明家只有一台电脑呢？那我就不需要编号就可以确定拿哪台电脑，也就是不需要交换机。
2.为什么有时候还要在路由器的后面先接1台交换机再接计算机？
路由器是可以直接接电脑等终端设备，为什么标准都是路由器接交换机然后再接电脑等终端，是因为路由器本来就是一个路由设备，用来选路的，不适合大量的数据交换，交换机是用来大量数据交换的，终端在内网的性质就是需要使用交换机，所以标准就是路由器地下接交换机的形式。一般是情况就是在路由器下面接交换机，路由器主要起数据转发，也就是寻址、路由的功能，交换机起到用户接入的目的。但是家用的路由器的话直接就接计算机就可以了，而不必考虑再接交换机。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f9e27eca7f3588ba18bdae8ec9e878d/" rel="bookmark">
			使用PRINTF或FORMAT 进行格式化输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1-输出格式化
package digit;
public class TestNumber {
public static void main(String[] args) {
String name ="盖伦";
int kill = 8;
String title="超神";
//直接使用+进行字符串连接，编码感觉会比较繁琐，并且维护性差,易读性差
String sentence = name+ " 在进行了连续 " + kill + " 次击杀后，获得了 " + title +" 的称号";
System.out.println(sentence);
//使用格式化输出
//%s表示字符串，%d表示数字,%n表示换行
String sentenceFormat ="%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n";
System.out.printf(sentenceFormat,name,kill,title);
System.out.format(sentenceFormat,name,kill,title);
}
}
2-换行符\n：另起一行与回车符\r：回到开头
在eclipse里敲一个回车，实际上是回车换行符
在DOS和Windows中，每行结尾是 “\r\n”；
System.out.printf("这是换行符%n");
3-关于print
int i = 4;
double j = 5;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f9e27eca7f3588ba18bdae8ec9e878d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcf731cb9d1cd331536433820c09405e/" rel="bookmark">
			【算法小结】计算图的连通块的块数的两种常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两种方法 DFS遍历法并查集法 测试数据： 样例输入：
5 3 1 2 2 3 4 5 5 1 2 5 样例输出
2 4 1. 图的DFS遍历 计算连通块的块数 //图的DFS遍历 计算连通块数 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;cstring&gt; using namespace std; const int nmax=1e5+10; vector&lt;int&gt; G[nmax]; int vis[nmax];//1已被访问 0未被访问 //遍历连通块 void DFS(int u){ vis[u]=true; for(int i=0;i&lt;G[u].size();i++){ int v=G[u][i]; if(vis[v]==0){//如果该节点未被访问，则深度遍历 DFS(v); } } } int main(int argc, char** argv) { int n;//点数 int m;//边数 while(cin&gt;&gt;n&gt;&gt;m){ memset(vis,0,sizeof(vis)); int u,v; for(int i=0;i&lt;m;i++){ cin&gt;&gt;u&gt;&gt;v; G[u].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcf731cb9d1cd331536433820c09405e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d8ad8fe0cc1aab0e52b7c08aaaa4a92/" rel="bookmark">
			tkinter 做一个exe 加法程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tkinter 做一个exe 加法程序 今天尝试用tkinter做一个window下的exe小程序，很简单的加法计算器。废话少说，直接上源码喽。
import tkinter #创建操作窗口 root = tkinter.Tk() root.title("操作窗口") root.minsize(600, 400) root.maxsize(600,400) #创建输入框 label1 = tkinter.Label(root, text= "输入第一个数字：") label1.place(relx = 0.13, rely = 0.20) entry1 = tkinter.Entry(root) entry1.place(relx = 0.29, rely = 0.20, width = 200, height = 20) label2 = tkinter.Label(root, text= "输入第二个数字：") label2.place(relx = 0.13, rely = 0.3) entry2 = tkinter.Entry(root) entry2.place(relx = 0.29, rely = 0.3, width = 200, height = 20) #创建结果框 label3 = tkinter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d8ad8fe0cc1aab0e52b7c08aaaa4a92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6488020d8044d406a56cd9c408187f84/" rel="bookmark">
			QQ第三方登录（itsdangerous生成激活token）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.成为QQ互联的开发者 注册链接：http://wiki.connect.qq.com/%E6%88%90%E4%B8%BA%E5%BC%80%E5%8F%91%E8%80%85
等个3-5 天的工作日审核，审核通过就称为一个开发者了
二.创建应用 在应用管理中创建一个应用，得到APPID
填写相关资料，审核通过得到APPKEY，记录之前的回调地址
三.项目实现 浏览器--&gt; 服务器 -- &gt; QQ服务器
1.浏览器用Vue的axios方法，GET请求服务器获取登录QQ服务器的网址（浏览器--&gt;服务器）
2.服务器拼接url路径返回给浏览器（服务器--&gt;浏览器）
3.浏览器用response接收到的url路径访问QQ服务器。（浏览器--&gt;QQ服务器）
4.QQ服务器返回code值，浏览器截取code值返回给服务器（QQ服务器--&gt;浏览器，浏览器--&gt;服务器）
5.服务器获取浏览器发送过来的code值，拼接字符串重新访问QQ服务器（服务器--&gt;QQ服务器）
6.QQ服务器返回access_token给服务器（QQ服务器--&gt;服务器）
7.服务器获取响应中的access_token值，拼接字符串给QQ服务器（服务器--&gt;QQ服务器）
8.QQ服务器返回openid（用户唯一身份标识）给服务器（QQ服务器--&gt;服务器）
QQ登录开发文档链接：http://wiki.connect.qq.com/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C_oauth2-0
前端代码放置QQ按钮，访问服务器
HTML
&lt;div class="third_party"&gt; &lt;a @click="qq_login" class="qq_login"&gt;QQ&lt;/a&gt; &lt;a href="#" class="weixin_login"&gt;微信&lt;/a&gt; &lt;a href="/register.html" class="register_btn"&gt;立即注册&lt;/a&gt; &lt;/div&gt; JS
qq_login: function(){ var state = this.get_query_string('next') || '/'; axios.get(this.host + '/oauth/qq/statues/?state=' + state, { responseType: 'json' }) .then(response =&gt; { location.href = response.data.auth_url; }) .catch(error =&gt; { console.log(error.response.data); }) }, 通过前端axios请求GET方法访问服务器，服务器返回拼接好的URL
class QQAuthURLView(APIView): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6488020d8044d406a56cd9c408187f84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddfaf149cc3069645257d740ec45bc38/" rel="bookmark">
			怎样规划自己的研究生生活？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读研的目的无非两种，要么为了更好的工作，要么觉得自己能力很强，可以在科研路上一条路走下去。这是我听一位学长的经验交流，自己做的笔记。想想研究生生涯已经过去一年，自己学了很多，却感觉到，很多都不记得？
为何如此？
无非懒于记录，懒于写点东西。师兄最近找工作，面对茫茫然的面试题目。我不经感叹，我都学过的的一些概念，刷过的题目，真要自己独立写出来，还真的写不出所以然。
立个Flag，为了已经过去的一年，懒惰的自己默哀，为了将来不后悔走上读研之路、为了那个我向往的自由！小子，你不能认输，再难再苦，别人也不会比你少努力一分，而你每多努力一分，都是在向美好未来靠近一步。
所以，不要偷懒，学过不是学会！脚踏实地，不是空口弹琴。
1.读博篇：科研
（1）具备能力：专业基础、数学基础、英语基础以及检索能力
（2）研究方向：新颖、稳定、深入
研究计划：目标明确，制定时间节点;量力而行;严格执行
研究过程：善于思考（改进空间）、敢于提问、沉下心来
研究成果：文献调研、选择合适的期刊会议、成果总结并撰写论文、投稿
读博篇：认识自己、询问交流、作出决定、坚持不懈
2.求职篇：工作 （1）求职准备：明确目标，刷题刷面经（牛客网、看准网、程序员面试宝典）Leetcode可以取看看
（2）制作简历：扬长避短，淘沙取金（岗位匹配的东西，实习经验）、有针对性
（3）面试经验：自我介绍（2～3min)，突出优点（并非简单罗列、有具体实例证明）
引导面试官（聊天，把内容引向你熟悉的方向、经历）
表达能力（结巴、语无伦次都不可）
礼貌用语
前十天可能没offer、会很受打击，熬过去就好，第一份offer收到，你就会陆续有offer来了
决定不一定对，但做了决定就不要轻易动摇！加油！给自己和能看到这篇文的人打气，加油！风雨坚持，也许不是为了远方，只为不忘初心。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a977ba0afb55e59e8940d5d6ce69d28a/" rel="bookmark">
			Android 禁止ViewPager左右滑动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 viewpager中，如果用view作为她的数据，并且动态控制viewpager的滑动与否。而且View 中的子控件还有对应 的点击事件。可以用下边的代码。
在onInterceptTouchEvent（）方法中，只是返回isSlide这个数据，会达到禁止左右滑动的效果，但是，view中的子控件的点击事件也会被屏蔽掉。 /** * Created by zys on 2018/8/24. */ public class ViewPagerSlide extends ViewPager { //是否可以进行滑动 private boolean isSlide = true; public void setSlide(boolean slide) { isSlide = slide; } public ViewPagerSlide(Context context) { super(context); } public ViewPagerSlide(Context context, AttributeSet attrs) { super(context, attrs); } @Override public boolean onInterceptTouchEvent(MotionEvent ev) { if (!isSlide) { return isSlide; } else { return super.onInterceptTouchEvent(ev); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83108b00ef0cfa76572c1a71e09fb72f/" rel="bookmark">
			aapt命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		aapt工具也支持很多子命令。
aapt l[ist]:列出资源压缩包里的内容。
aapt d[ump]：查看APK包内指定的内容。
aapt p[ackage]：打包生成资源压缩包。
aapt r[emove]：从压缩包中删除指定文件。
aapt a[dd]：向压缩包中添加指定文件。
aapt v[ersion]:打印aapt的版本。
详情命令参考 https://elinux.org/Android_aapt
https://www.jianshu.com/p/8d691b6bf8b4
个人常用的记录一下
查看apk包信息
C:\Users\Administrator&gt;aapt dump badging F:\tools\com.ss.android.ugc.aweme_250.apk
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d96ed7929fb423d94b1daac1e6752a2f/" rel="bookmark">
			Mimics CT 片导出图片格式（BMP/JPEG）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：此处以输出BMP图片格式为例，JPEG同理。
第一步：
在mimics中打开*.mcs格式的文件，如下图所示：（以轴位为例）
其中，-211.00代表当前所在厚度（单位毫米mm），153代表当前所在张数，即CT片的序号数。
第二步：
如下图所示，为已经标记好的CT片，图中绿色部分即为已标记肝部区域。
可以在下图右边箭头所指区域选择是否显示标记，单击眼镜图案即可。（当选择显示标记，眼镜图案变亮）
第三步：
在菜单栏找到Export项目（如下图箭头所指）
单击，并选择以BMP/JPEG格式输出（如下图箭头所指）
第四步：
完成以上步骤，将会出现如下图所示的对话框，Axial代表轴位，Coronal代表冠状位，Sagittal代表矢状位，要输出三个相位中任一相位的CT图片可根据需要选择。如下图表示输出轴位，当前选中的一张CT图片，输出图片格式为BMP格式。
第五步：
当有特殊需求时，也可根据需要设定。以下图为例，表示选择输出轴位，以BMP的图片格式输出。选中Specify选项，改变From到Until的值，表示可以选择所需要CT片序号的区间，下图表示输出0-289序号区间的图，Every表示输出图片的间隔数，下图Every值为1，表示图片输出序号为0，1，2，3，4，5…….;若Every值为2，表示图片输出序号为0，2，4，6，8，10…….;以此类推。Num表示总共输出的图片数目。此处表示输出290张图片。
最后在Path处，选择保存路径就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d2628c0007336bd5e5697b6669ceed1/" rel="bookmark">
			微信app支付之回调多次以及不回调的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面一篇文章我是在做app支付的时候写的，做app支付完成之后写的，这篇主要是支付完成之后的坑。
首先，支付完成之后，主要就是回调，我首先遇到的就是支付完成之后，并没有收到信息，然后就是各种网上找问答。后面突然发现，数据库里面无缘无故的竟然有了回调的信息（这个我是在回调页面里面写了日志的）。
回调信息的获取我没有用官方提供的方法，用的网上找的
//获得Post过来的数据 public string getPostStr() { Int32 intLen = Convert.ToInt32(System.Web.HttpContext.Current.Request.InputStream.Length); byte[] b = new byte[intLen]; System.Web.HttpContext.Current.Request.InputStream.Read(b, 0, intLen); return System.Text.Encoding.UTF8.GetString(b); } 使用这个，获取到了微信的回调信息。然后说下，为什么是突然能够收到回调信息了，我也是在网上找为什么不能回调的时候发现，网友说，需要清理 应用程序的缓存，突然我明白了，原来还有这个。然后每次更新代码，我都更新应用程序的缓存，这才可以了
下面说下一个问题，多次对调的问题。这个官方文档上面也说，我没有仔细看，在接收到回调信息之后，需要给官方返回信息才可以。
应该是直接Response .Write(XML字符串)吧，我试了，好像不行！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c25792436c584cc2bd3986642d82db5b/" rel="bookmark">
			python3 中通过help函数查看其它函数的说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python3 中通过help函数查看其它函数的说明 在学习python过程中，会经常遇到一些函数，那么怎么查看官方对此函数的简单介绍呢？ python提供了help方法来帮助我们。
首先，进入python3的命令行页面： 比如我们要对print（）函数进行查看 那么这段英文描述，就详细介绍了print（）函数的用法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f46d333c5ff9ebb3a95e4c5dff6c9cd3/" rel="bookmark">
			Java读取Excel时对cell格式的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		excel 将信息收集到后，通过数据上传的方式，将数据放到数据库中，而如果在操作的过程中没有把excel的数据类型对应的获取，就会报错，下面写了一个方法将row的每一个cell转换成String类型， int type = cell.getCellType(); //获取cell的类型，分别有 CellType 类型 值 CELL_TYPE_NUMERIC 数值型 0 CELL_TYPE_STRING 字符串型 1 CELL_TYPE_FORMULA 公式型 2 CELL_TYPE_BLANK 空值 3 CELL_TYPE_BOOLEAN 布尔型 4 CELL_TYPE_ERROR 错误 5 将某个Cell 设置成String row.getCell(i).setCellType(Cell.CELL_TYPE_STRING);
处理日期相对要麻烦一点，先获取日期的样式 String string_type =cell.getCellStyle().getDataFormatString(); 并且该格子得设置成数值型的， String ans = new SimpleDateFormat(“yyyy-MM-dd”).format(cell.getDateCellValue());
这样ans就能获取到String类型的日期了，不然只能获取一个5位的数字。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c25197478ae0294b4e5742b27b019338/" rel="bookmark">
			GitHub网站排版混乱并且速度慢的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 GitHub官网排序混乱并且速度慢。如图1所示。
图1 问题描述示意图 解决方法 1.在Chrome或者Firefox下进入GitHub网站，按下F12调到控制台查看输出的错误信息，如图2所示，发现是assets-cdn.github.com的资源没有加载成功。
图2 问题原因示意图 2.打开 https://www.ipaddress.com/ 在输入框(如图3所示)中输入assets-cdn.github.com然后搜索，会得到它的IP网址，如图4所示，网址是151.101.184.133
图3 搜索框示意图 图4 搜索结果图 3.修改hosts文件
Windows下的hosts文件路径是C:\Windows\System32\drivers\etc\hosts。因为不能直接修改hosts文件，我们把它复制出来，进行修改，然后再覆盖原路径下的hosts即可。
我的是直接在hosts文件末尾添加上 151.101.184.133 assets-cdn.github.com 就行了，图5是修改后的hosts结果图。
图5 修改后的hosts结果图 4.刷新GitHub网站，问题解决。图6是问题解决后的截图图。
图6 问题解决后 结果图 【原创文章，转载请注明出处，谢谢】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d36d3ec896ef350786129ba4f8fa19dd/" rel="bookmark">
			Intellij IDEA中使用MyBatis-generator 插件自动生成MyBatis代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、要用maven生成pom.xml
选中项目——&gt;右键——&gt;选择Add Framworks Support——&gt;选择maven ，他会自动生成pom.xml文件
maven在编译的时候，默认使用的是jdk1.5,如果要指定jdk的版本，需要在pom.xml文件中加入如下配置（修改jdk版本为1.8）
2、修改jdk版本和加入org.mybatis.generator插件
&lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 刚加入是红色的。
3、让IDEA自动下载插件
在pom.xml文件中点击右键-----》选择maven--------》选择reimport,它就会自动加载，等着把资源下载好。
4、添加运行maven的配置
在Command line中添加如下代码
mybatis-generator:generate -e 5、在resources下建立generatorConfig.xml 内容如下
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd" &gt; &lt;generatorConfiguration&gt; &lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包，路径不要出现中文--&gt; &lt;classPathEntry location="D:\woooooork\jar\mysqlconnnect\mysql-connector-java-5.1.44.jar"/&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接URL，用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d36d3ec896ef350786129ba4f8fa19dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/325b0ea61df93c832f746623454c170f/" rel="bookmark">
			百度地图点击标注展示信息栏，信息栏根据点击的标注，显示不同的信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度地图点击标注展示信息栏，信息栏根据点击的标注，显示不同的信息 最近做百度API的应用，鼠标点击地图上具体的一个标签，会弹出信息栏，信息栏中的信息需要根据点击的是不同的标签，显示不同的内容。过程中遇到一个问题，就是无论点击哪一个，都显示的是最后一个infowindow，最后将这个问题解决，希望给遇到同样问题的朋友一些帮助。
!!! 关键是思路：为marker建立一个title（可以理解为ID），这样在marker执行监听事件click时，才可以根据点击的marker来判断输出哪一个infowindow，输出的信息只要有同样的ID与marker对应就可以控制了（说白话点，就是自己给marker建立一个id，但百度api没有提供setid，只提供了一个setTitle，那就拿这个当id用，id就是0-x的数字，这样你就有了一个可以用来当下标的东西了）。关键代码如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19f85a20b551a3ad4d9397f4590dd321/" rel="bookmark">
			CentOS下安装Code::Blocks
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下c++编程有很多工具选择，vim是一款广受大神欢迎的编辑器，但上手难度也大。我是IDE的爱好者，自然选择喜欢的IDE，于是装了简单易用的code::blocks。下面是安装教程。
vim和IDE没有孰优孰劣，开发效率高，能熟手使用就是好东西。
工具介绍 目前最新版本 codeblocks_17.12.tar.xz http://www.codeblocks.org/downloads/source
对应wxWidgets版本是wxWidgets-3.0.4（20MB） https://www.wxwidgets.org/downloads/
codeblocks是基于wxGTK的图形工具，安装依赖关系如下：
Code::Blocks -&gt; wxWidget (&gt; libwxGTK2.8) -&gt; GTK+ (&gt; libgtk-x11-2.0) -&gt; X
意思是先安装x11-2.0版本以上的GTK+，再安装GTK2.8以上内核的wxWidget，然后安装3.0.4版本的code::blocks。
官方给出了所有Linux版本的安装引导，里面描述了大部分安装过程可能遇到的问题，
http://wiki.codeblocks.org/index.php/Installing_Code::Blocks
链接里说了如果是纯净Linux环境下，安装codeblocks需要用到的工具。通常系统都自带了这些和GTK+，CentOS查看GTK+命令
rpm -qa | grep gtk 如果能看到gtk2-devel字样，就是装了，没有的请自行安装 。
安装wxWidget 下载wxWidgets-3.0.4并解压
# 进入wxWidgets目录 cd wxWidgets-3.0.4/ # 配置属性 ./configure --prefix=/usr --enable-xrc--enable-monolithic --enable-unicode # 执行make make # 执行安装 make install make的过程有好几分钟。如果没有Makefile文件生成，多半是缺了依赖工具。
安装Code::Blocks 下载codeblocks_17.12.tar.xz，解压并安装。安装过程挺长的，用了10分钟左右。
# 解压文件 xz -d codeblocks_17.12.tar.xz tar xvf codeblocks_17.12.tar # 进入目录 cd codeblocks-17.12 # 设置配置脚本及依赖，只需运行一次。可能会遇到"问题1" ./bootstrap # 配置时指定目录并安装插件。可能会遇到"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19f85a20b551a3ad4d9397f4590dd321/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61f1be8b785d28a78c86bc243bfcdb53/" rel="bookmark">
			numpy的内存映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内存映射 Numpy 有对内存映射的支持。
内存映射也是一种处理文件的方法，主要的函数有：
memmapfrombufferndarray constructor 内存映射文件与虚拟内存有些类似，通过内存映射文件可以保留一个地址空间的区域，同时将物理存储器提交给此区域，内存文件映射的物理存储器来自一个已经存在于磁盘上的文件，而且在对该文件进行操作之前必须首先对文件进行映射。
使用内存映射文件处理存储于磁盘上的文件时，将不必再对文件执行I/O操作，使得内存映射文件在处理大数据量的文件时能起到相当重要的作用。
memmap memmap(filename, dtype=uint8, mode='r+' offset=0 shape=None order=0) mode 表示文件被打开的类型：
r 只读c 复制+写，但是不改变源文件r+ 读写，使用 flush 方法会将更改的内容写入文件w+ 写，如果存在则将数据覆盖 offset 表示从第几个位置开始。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/856c71a369eb9e9ed261060bd8ad10e8/" rel="bookmark">
			node.js&#43;express&#43;mysql&#43;腾讯云服务器实现onenet平台对接与数据存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做这个事情来自于实验室的需求，老板吩咐建立一套自己的气象监测站系统，能够通过NBIOT、2G、4G将本地数据传输到云平台，进行WEB显示与云端存储。Onenet（自行百度）很好的实现了本地到云端的对接，但问题在于没有开放数据库权限，只能通过API的形式，访问有限个数据点，不方便后期处理。但Onenet预留了一个第三方服务器接口，oennet可通过这个接口将实时接收到的数据点推送到第三方服务器。以下内容基于这个Data_push推送接口实现了第三方服务器明文模式的搭建，接收数据与mysql存储。
气象监测系统架构图
在oenent平台的开发者中心任一一个类型的设备中，左侧栏都有第三方配置菜单，需要输入URL信息，包含公网的IP和端口。
第一步：使用了官方给的第三方对接SDK包https://open.iot.10086.cn/doc/art432.html#118，采用node.js语言。
1.1、搭建node.js开发环境，我使用的是win10系统，安装node.js和vscode调试平台。安装好后，就可以用vscode调试node.js程序了。官方的给的SDK已经包括了URL验证与数据解析。对SDK分析以下。主要包括两大模块，一个是用GET方法进行URL验证。另一个是POST方法接收onenet推送的数据。具体协议请看https://open.iot.10086.cn/doc/art486.html#108
在用node.js测试时，注意一个地方就是
在onenet平台填写的端口号就是这里的port，默认是3000.
1.2、在本地用vscode调试时没有公网IP。为了能够在本地也能拥有本地ip，采用ngrok进行反代理。
输入：ngrok http 80后，我们就在本地拥有了一个公网ip和端口，注意这里的端口是80端口。所以在node.js的port中定义成80，才能使用。
得到的公网IP如红线所示，在oenent第三方配置输入后，如图。
点击提交，就会通过验证。此时，本地这个服务器就可以接收设备传上来的实时数据了，至于接收后如何处理，就看用户的需求了。
第二步：node.js对接mysql
1.1、安装mysql（http://www.runoob.com/mysql/mysql-install.html）
意安装mysql时，一定要用管理员的CMD！ 按照提示安装就可以，但8.0以后的版本在安装时没有my文件，为此，可以自己建立一个my文件，内容复制以下即可，有个别地方根据自己的安装参数修改。
[mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] # 设置3306端口 port = 3306 # 设置mysql的安装目录 basedir=C:\web\mysql-8.0.12 # 设置mysql数据库的数据的存放目录 datadir=C:\web\sqldata # 允许最大连接数 max_connections=20 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB 2.2 mysql对接node.js（http://www.runoob.com/nodejs/nodejs-mysql.html）
这里直接按照操作进行就可以了。
2.3将mysql数据管理与插入数据的相关代码插入到get推送模块的程序里，这是我的用于接收数据并存储在数据里的相关代码。
var mysql = require('mysql'); var connection = mysql.createConnection({ host : 'localhost', user : 'root', password : '123456', port: '3306', database: 'test', }); connection.connect(); app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/856c71a369eb9e9ed261060bd8ad10e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c8cb4c57e29d0d29eec1788f840ec0d/" rel="bookmark">
			阿里云  1H2G T5实例 与 腾讯云 1H2G 标准2实例 测试对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近阿里云又出了个2H4G一年只要260元的活动，看上去挺不错但发现是T5实例 30%基线性能。
仔细的看了下t5实例的说明，以1H2G T5实例说明，此实例提供 10%cpu，也就是正常情况下。如果你CPu利用率大于10%,那么扣你的Cpu积分，当你积分为0时会限制Cpu利用率为10%，这时就卡的不要不要的。
如果你Cpu利用率小于10%，那么就给你涨积分，获得积分=10%-当前利用率。T5实例介绍就是突发啥的，价格相对便宜。当初有新用户活动弄了台1H2G的，一年大概100块钱左右。
腾讯云的学生机就没有这么多限制，直接给你1H，一年120块钱。
使用UnixBench进行测试，以下为测试结果：
阿里云 腾讯云 配置相同 都为1H2G
阿里云无积分时:
System Benchmarks Index Values BASELINE RESULT INDEX Dhrystone 2 using register variables 116700.0 6003054.6 514.4 Double-Precision Whetstone 55.0 563.7 102.5 Execl Throughput 43.0 605.8 140.9 File Copy 1024 bufsize 2000 maxblocks 3960.0 72629.0 183.4 File Copy 256 bufsize 500 maxblocks 1655.0 20958.2 126.6 File Copy 4096 bufsize 8000 maxblocks 5800.0 175027.7 301.8 Pipe Throughput 12440.0 114531.4 92.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c8cb4c57e29d0d29eec1788f840ec0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ff7229538437d4730faebaa4e604749/" rel="bookmark">
			iOS UITextField设置数字键盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 纯数字键盘：
textField.keyboardType = UIKeyboardTypeNumberPad; 纯数字加小数点键盘：
textField.keyboardType = UIKeyboardTypeDecimalPad 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e0b5a89a5df2437b67411e47287fe50/" rel="bookmark">
			PIXI FlappyBird详解（9）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为了学习及使用pixi参考该文，使用pixi实现
这个实方式跟玉兔太空类似，
这里介绍下实现步骤
1.创建舞台及应用大小根据实际去定义
2.创建背景素材，可以采取纹理图集，在前边有提过或是看官网了解下
3.把加载图片放到舞台上
4.渲染舞台
技术点：
1.管子及背景移动
2.碰撞检测
3.重力加速度
4.管子轮巡
转载于:https://www.cnblogs.com/congxueda/p/9514524.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfa281eb51d27221ec1757a7d7222408/" rel="bookmark">
			jquery实现60秒倒计时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 代码：
var time = 60; //倒计时 function getRandomCode() { if (time === 0) { time = 60; return; } else { time--; $('#time i').text(time); } setTimeout(function() { getRandomCode(); },1000); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/158c7eb8e8eaa640c23f5c81e2445500/" rel="bookmark">
			spring boot配置详情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring boot配置详情如下： 1、MVC相关 mvc spring.mvc.async.request-timeout设定async请求的超时时间，以毫秒为单位，如果没有设置的话，以具体实现的超时时间为准，比如tomcat的servlet3的话是10秒. spring.mvc.date-format设定日期的格式，比如dd/MM/yyyy. spring.mvc.favicon.enabled是否支持favicon.ico，默认为: true spring.mvc.ignore-default-model-on-redirect在重定向时是否忽略默认model的内容，默认为true spring.mvc.locale指定使用的Locale. spring.mvc.message-codes-resolver-format指定message codes的格式化策略(PREFIX_ERROR_CODE,POSTFIX_ERROR_CODE). spring.mvc.view.prefix指定mvc视图的前缀. spring.mvc.view.suffix指定mvc视图的后缀. messages spring.messages.basename指定message的basename，多个以逗号分隔，如果不加包名的话，默认从classpath路径开始，默认: messages spring.messages.cache-seconds设定加载的资源文件缓存失效时间，-1的话为永不过期，默认为-1 spring.messages.encoding设定Message bundles的编码，默认: UTF-8 mobile spring.mobile.devicedelegatingviewresolver.enable-fallback是否支持fallback的解决方案，默认false spring.mobile.devicedelegatingviewresolver.enabled是否开始device view resolver，默认为: false spring.mobile.devicedelegatingviewresolver.mobile-prefix设定mobile端视图的前缀，默认为:mobile/ spring.mobile.devicedelegatingviewresolver.mobile-suffix设定mobile视图的后缀 spring.mobile.devicedelegatingviewresolver.normal-prefix设定普通设备的视图前缀 spring.mobile.devicedelegatingviewresolver.normal-suffix设定普通设备视图的后缀 spring.mobile.devicedelegatingviewresolver.tablet-prefix设定平板设备视图前缀，默认:tablet/ spring.mobile.devicedelegatingviewresolver.tablet-suffix设定平板设备视图后缀. spring.mobile.sitepreference.enabled是否启用SitePreferenceHandler，默认为: true view spring.view.prefix设定mvc视图的前缀. spring.view.suffix设定mvc视图的后缀. resource spring.resources.add-mappings是否开启默认的资源处理，默认为true spring.resources.cache-period设定资源的缓存时效，以秒为单位. spring.resources.chain.cache是否开启缓存，默认为: true spring.resources.chain.enabled是否开启资源 handling chain，默认为false spring.resources.chain.html-application-cache是否开启h5应用的cache manifest重写，默认为: false spring.resources.chain.strategy.content.enabled是否开启内容版本策略，默认为false spring.resources.chain.strategy.content.paths指定要应用的版本的路径，多个以逗号分隔，默认为:[/**] spring.resources.chain.strategy.fixed.enabled是否开启固定的版本策略，默认为false spring.resources.chain.strategy.fixed.paths指定要应用版本策略的路径，多个以逗号分隔 spring.resources.chain.strategy.fixed.version指定版本策略使用的版本号 spring.resources.static-locations指定静态资源路径，默认为classpath:[/META-INF/resources/,/resources/, /static/, /public/]以及context:/ multipart multipart.enabled是否开启文件上传支持，默认为true multipart.file-size-threshold设定文件写入磁盘的阈值，单位为MB或KB，默认为0 multipart.location指定文件上传路径. multipart.max-file-size指定文件大小最大值，默认1MB multipart.max-request-size指定每次请求的最大值，默认为10MB freemarker spring.freemarker.allow-request-override指定HttpServletRequest的属性是否可以覆盖controller的model的同名项 spring.freemarker.allow-session-override指定HttpSession的属性是否可以覆盖controller的model的同名项 spring.freemarker.cache是否开启template caching. spring.freemarker.charset设定Template的编码. spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/158c7eb8e8eaa640c23f5c81e2445500/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebffb91d0bbb54cba2d03c5ddd8152b5/" rel="bookmark">
			Object Detection(目标检测神文)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标检测神文，非常全而且持续在更新。转发自：https://handong1587.github.io/deep_learning/2015/10/09/object-detection.html，如有侵权联系删除。
更新时间：
20190226 暂时停更
不再更新，最新检测文章请移步：https://blog.csdn.net/hw5226349/article/details/88733364
我会跟进原作者博客持续更新，加入自己对目标检测领域的一些新研究及论文解读。博客根据需求直接进行关键字搜索，例如2018，可找到最新论文。
文章目录 Papers损失函数[CVPR2019] Generalized Intersection over Union: A Metric and A Loss for Bounding Box RegressionDeep Neural Networks for Object DetectionOverFeat: Integrated Recognition, Localization and Detection using Convolutional Networks R-CNNRich feature hierarchies for accurate object detection and semantic segmentation Fast R-CNNFast R-CNNA-Fast-RCNN: Hard Positive Generation via Adversary for Object Detection Faster R-CNNFaster R-CNN: Towards Real-Time Object Detection with Region Proposal NetworksR-CNN minus RFaster R-CNN in MXNet with distributed implementation and data parallelizationContextual Priming and Feedback for Faster R-CNNAn Implementation of Faster RCNN with Study for Region SamplingInterpretable R-CNN[AAAI2019]Object Detection based on Region Decomposition and Assembly Light-Head R-CNNLight-Head R-CNN: In Defense of Two-Stage Object DetectorCascade R-CNN: Delving into High Quality Object Detection MultiBoxScalable Object Detection using Deep Neural NetworksScalable, High-Quality Object Detection SPP-NetSpatial Pyramid Pooling in Deep Convolutional Networks for Visual RecognitionDeepID-Net: Deformable Deep Convolutional Neural Networks for Object DetectionObject Detectors Emerge in Deep Scene CNNssegDeepM: Exploiting Segmentation and Context in Deep Neural Networks for Object DetectionObject Detection Networks on Convolutional Feature MapsImproving Object Detection with Deep Convolutional Networks via Bayesian Optimization and Structured PredictionDeepBox: Learning Objectness with Convolutional Networks MR-CNNObject detection via a multi-region &amp; semantic segmentation-aware CNN model YOLOYou Only Look Once: Unified, Real-Time Object Detectiondarkflow - translate darknet to tensorflow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebffb91d0bbb54cba2d03c5ddd8152b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04255788e64f9b24f0b056b23906c245/" rel="bookmark">
			关于set   -o   vi  的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在普通的centos等 linux系统下，使用上下键可以使用历史命令，使用ESC+向上箭头/向下箭头，可以显示所有命令；
在AIX系统下，使用set -o vi 后，再使用ESC+K、L ，可以使用历史命令，可是有时候需要历史命令的一部分，这就要进行编辑了，
首先是要说光标的定位，和vi下一样，如shift+i/a----行首后者行尾可编辑，
其次是删除，需要使用左箭头和右箭头，
这样就方便多了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6ac3958897312fb38789edb5602a95f/" rel="bookmark">
			实现忽略大小写的copyProperties
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现的原因 Spring中的BeanUtils.copyProperties(source,target),不能忽略大小写，类型不同不能相互赋值。速度并不是特别理想。自己根据反射实现了工具类。 其中ReflectASM需要引入下面jar包
&lt;!---RelectAsm--&gt; &lt;dependency&gt; &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt; &lt;artifactId&gt;reflectasm&lt;/artifactId&gt; &lt;version&gt;1.11.7&lt;/version&gt; &lt;/dependency&gt; #具体代码
import com.esotericsoftware.reflectasm.MethodAccess; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.*; /** * * @Auther: xjw * @Description: 此类主要用于反射，对反射的一些操作进行缓存起来。 */ public class BeanUtils { /** * 集合 copy * * @param sources * @param target * @param &lt;T&gt; * @return */ public static &lt;T&gt; List&lt;T&gt; listCopyPropertiesASM(List sources, Class&lt;T&gt; target) { List list = new ArrayList&lt;&gt;(sources.size()); sources.forEach(it -&gt; { list.add(copyPropertiesASM(it, target)); }); return list; } /** * 通过 target的Class 复制 * target 必须有一个无参构造器 * * @param source * @param target * @param &lt;T&gt; * @return */ public static &lt;T&gt; T copyPropertiesASM(Object source, Class&lt;T&gt; target) { T newT = null; try { newT = target.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6ac3958897312fb38789edb5602a95f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c720710ef9ec5e24080b50721a81093/" rel="bookmark">
			轻量化神经网络模型总结：SqueezeNet、Xception、MobileNet、ShuffleNet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结今年来的几个轻量化模型：SqueezeNet、Xception、MobileNet、ShuffleNet
下面给出时间轴：
2016.02 伯克利&amp;斯坦福提出 SqueezeNet2016.10 google提出 Xception2017.04 google提出 MobileNet2017.07 face++提出 ShuffleNet 其次，说一下模型轻量化的一些方法：
卷积核分解：使用1xN和NX1卷积核代替NXN卷积核；使用深度压缩deep compression方法：网络剪枝、量化、哈弗曼编码；奇异值分解；硬件加速器；低精度浮点数保存； 小模型的好处有哪些：
在分布式训练中，与服务器通信需求小；参数少，从云端下载模型的数据量小；更适合在FPGA等内存首先的嵌入式、移动端设备上部署； 1、SqueezeNet 地址链接：https://arxiv.org/pdf/1602.07360.pdf
1.1 核心思想 在ImageNet上实现了与Alexnet相似的效果，参数只有其1/50， 模型是0.5MB，占其1/510。
SqueezeNet核心内容有以下几点：
使用1x1卷积核代替3x3卷积核，减少参数量；通过squeeze layer限制通道数量，减少参数量；借鉴inception思想，将1x1和3x3卷积后结果进行concat；为了使其feature map的size相同，3x3卷积核进行了padding；减少池化层，并将池化操作延后，给卷积层带来更大的激活层，保留更多地信息，提高准确率；使用全局平均池化代替全连接层； 上述1-3是通过fire module实现的，fire module主要分为两部分，如下图所示
squeeze：1x1卷积核，参数s_1x1表示卷积核数量expand：1x1卷积核和3x3卷积核，参数e_1x1和e_3x3分别表示两种卷积核的数量 该模块一共三参数s_1x1、e_1x1、e_3x3，关系保持s_1x1&lt; e_1x1+e_3x3
1.2 网络结构 1.3 实验结果 实验结果表示模型小，且准确率不降，反而有点提高；
参考链接：
1、https://blog.csdn.net/csdnldp/article/details/78648543
2、https://blog.csdn.net/u011995719/article/details/78908755
2、Xception 地址链接：https://arxiv.org/abs/1610.02357
2.1 核心思想 虽然本文中方法可以降低参数量，但是论文加宽了网络结构，因此这篇论文不在于压缩模型，旨在于提高性能，与同等参数量的inception v3相比，效果更好。
首先是inception v3的一系列延伸，见下图：
1、版本1：最初的inception v3
2、版本2：对1进行简化
3、版本3：对2简化，可以先使用一个统一的1x1卷积核，然后每个3x3卷积核的输入只是1x1卷积后的feature map的一部分。本图中是1/3；
4、版本4：在3的基础上进一步延伸，将1x1卷积后的所有feature map按通道全部划分，每一个通道对应一个3x3卷积，即3x3卷积核的数量就是1x1卷积后feature map的通道数。
然后在xception中，主要采用depthwise separable convolution思想（这个后面在mobile net中详细解释，好奇怪，明明是mobile net后出现的，反正都是一家的，估计公布先后的问题吧。）
首先xception类似于图4，但是区别有两点：
1、xception中没有relu激活函数； 2、图4是先1x1卷积，后通道分离；xception是先进行通道分离，即depthwise separable convolution，然后再进行1x1卷积。
此外，进行残差连接时，不再是concat，而是采用加法操作。
2.2 网络结构 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c720710ef9ec5e24080b50721a81093/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/429/">«</a>
	<span class="pagination__item pagination__item--current">430/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/431/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>