<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/638178a2c692746f2a0e012f38d6c49d/" rel="bookmark">
			linux安装codeserver实现云端开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看图
下载安装包
https://github.com/coder/code-server/releases 找到code-server-版本号-linux-amd64.tar.gz，我这里是code-server-4.16.1-linux-amd64.tar.gz
1、使用acrm用户登录目标服务器 2、切换root用户，创建 vscode 用户，并设置密码 useradd vscode passwd vscode 3、切换到vscode用户，上传code-server-4.16.1-linux-amd64.tar.gz (1)直接解压/home/vscode/下，并改名为code-server tar -xvf code-server-4.16.1-linux-amd64.tar.gz mv code-server-4.16.1-linux-amd64 code-server (2)将配套的两个shell文件也都放到/home/vscode/code-server/目录下 启动脚本start.sh
NAME='code-server' echo "clean old $NAME process" for i in `ps -ef|grep $NAME | grep -v grep |awk '{print $2}'`; do kill -9 $i ; done; echo "start $NAME process" setsid nohup /home/vscode/code-server/bin/code-server &gt; /home/vscode/code-server/console.log 2&gt;&amp;1 &amp; echo 'code-server start success!' tail -f /home/vscode/code-server/console.log 停止脚本stop.sh
NAME='code-server' echo "stop $NAME process"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/638178a2c692746f2a0e012f38d6c49d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18402f0f8ee95dc034668fd7389b9811/" rel="bookmark">
			Android——浏览网页——浏览网页实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		布局：
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:focusable="true" android:focusableInTouchMode="true"&gt; &lt;LinearLayout android:id="@+id/ll_top" android:layout_width="match_parent" android:layout_height="45dp" android:layout_alignParentTop="true" android:background="#fbfbfb" android:orientation="horizontal" &gt; &lt;EditText android:id="@+id/et_web_url" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:layout_margin="5dp" android:background="@drawable/editext_selector" android:gravity="left|center" android:inputType="textUri" android:text="" android:textColor="@color/black" android:textSize="15sp" /&gt; &lt;ImageView android:id="@+id/iv_go" android:layout_width="45dp" android:layout_height="45dp" android:padding="8dp" android:src="@drawable/icon_go" /&gt; &lt;/LinearLayout&gt; &lt;WebView android:id="@+id/wv_web" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@+id/ll_top" android:layout_above="@+id/ll_bottom"/&gt; &lt;LinearLayout android:id="@+id/ll_bottom" android:layout_width="match_parent" android:layout_height="45dp" android:layout_alignParentBottom="true" android:background="#fbfbfb" android:orientation="horizontal" &gt; &lt;ImageView android:id="@+id/iv_back" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:padding="8dp" android:src="@drawable/icon_back" /&gt; &lt;ImageView android:id="@+id/iv_forward" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:padding="8dp" android:src="@drawable/icon_forward" /&gt; &lt;ImageView android:id="@+id/iv_refresh" android:layout_width="0dp" android:layout_height="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18402f0f8ee95dc034668fd7389b9811/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/760a6ce0d08ee358fa5ae76c8f716014/" rel="bookmark">
			复杂度分析-时间复杂度和空间复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复杂度分析 事后统计法：把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小
弊端：
测试结果非常依赖测试环境（不同芯片电脑运行程序）测试结果受数据规模的影响很大（数据规模大和小可能测试结果不同） 解决办法：需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法
时间复杂度分析 概述：所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比（算法的执行时间与数据规模之间的增长关系）
T(n) = O(f(n)) T(n)：代码执行的时间n：数据规模的大小f(n)：每行代码执行的次数总和O：代码的执行时间 T(n) 与 f(n) 表达式成正比 大 O 时间复杂度表示法：并不代表代码真正的执行时间，表示 代码执行时间与数据规模增长的变化趋势，也叫 渐进时间复杂度，简称 时间复杂度
时间复杂度分析方法
只关注循环执行次数最多的一段代码（忽略常量、低阶、系数）加法法则：总复杂度等于量级最大的那段代码的复杂度乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 几种常见时间复杂度实例分析(多项式量阶 和 非多项式量级)
常量阶 O(1)对数阶 O(logn)线性阶 O(n)线性对数阶 O(nlogn)平方阶 O(n2) 立方阶 O(n3) … k次方阶 O(nk)指数阶 O(2n)阶乘阶 O(n!) 注意：当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加。非多项式量级只有两个：O(2n) 和 O(n!)
多项式量级时间复杂度 O(1) 只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。 O(logn)、O(nlogn) i = 1; while(i &lt;= n){ i = i*2; } // 时间复杂度：O(logn) 注意：对数阶时间复杂度表示法，可以忽略对数的底，统一表示为 O(logn)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/760a6ce0d08ee358fa5ae76c8f716014/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7161988d90a134932529379a14b10061/" rel="bookmark">
			Nvidia Jetson AGX Orin使用CAN与底盘通信（ROS C&#43;&#43; 驱动）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Nvidia Jetson AGX Orin使用CAN通信1.1 CAN使能配置修改GPIO口功能1.2 can收发测试 二、通过CAN协议编写CAN的SocketCan ROS1驱动程序2.1 通讯协议2.2 接收数据节点2.3 发送数据节点2.4 功能包配置 三、ROS2驱动程序 一、Nvidia Jetson AGX Orin使用CAN通信 参考：https://blog.csdn.net/vonct/article/details/129055892，使用杜邦线将Nvidia Jetson AGX Orin的CAN口（底盘CANL和CANH连接对应Orin的CANL和CANH，具体底盘CANL和CANH接口可能要看Nvidia Jetson AGX Orin说明书）接出来。
1.1 CAN使能配置修改GPIO口功能 由于默认的CAN引脚不是配置为CAN，因此需要修改4个寄存器的值。具体可以从文档看到：
以Orin为例，图中Addr就是寄存器地址，value就是需要写入的值
（1）使用busybox修改寄存器的值
sudo apt-get install busybox sudo busybox devmem 0x0c303018 w 0xc458 sudo busybox devmem 0x0c303010 w 0xc400 sudo busybox devmem 0x0c303008 w 0xc458 sudo busybox devmem 0x0c303000 w 0xc400 （2）挂载CAN内核
sudo modprobe can sudo modprobe can_raw sudo modprobe mttcan （3）CAN属性设置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7161988d90a134932529379a14b10061/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/264a5dc348e90a9dd8eeb0aba861ac14/" rel="bookmark">
			linux下删除正在使用的文件（bin、so）会发生什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在linux 系统中上线时经常会遇到需要替换原有可执行程序的操作，我通常的做法是：
删除原有可执行文件。例如：rm a.out以相同的文件名把新的可执行文件放到原文件的位置：mv b.out a.out重启服务。 一直以来都是如此操作的，也没有出现过什么问题。但是在操作过程中经常会战战兢兢,老觉得原程序正在执行时，删除了对应的磁盘文件，正在运行的程序会崩溃。
在印象中，程序通常是部分载入内存的，当遇到缺页时，系统会从磁盘文件中继续读入新的页面到内存中。如果真是这样的话，那么删除磁盘上的文件之后，系统在读入新的页面时应该会出错。可是在我多次上线的过程中，删除可执行文件后，从未出现过运行的服务出问题的情况。这种釜底抽薪的操作，没有出问题是偶然的吗？
扩展到更为通用的情况：如果一个文件正在被使用，这时对这个文件执行删除或更改其内容的操作，会发生什么？出于好奇心，决定深入研究一下。在本文中，主要探讨了以下几类被正在使用的文件：
文件正在被打开读写可执行文件正在运行动态链接库正在被使用 预备知识 在上一篇中，我们探讨了rm及 cp 命令的底层原理，特别是当目标文件存在时cp 命令的行为。当目标文件存在时，cp 命令会清空旧文件，之后把新的内容写入。为了便于理解本文的内容，建议读者先了解一下上一篇的内容。
在本篇的讨论中，由于我们的重点在于“删除正在被使用的文件“，因而我们假设所操作的所有文件的链接数都为1，即没有使用 ln 等命令为文件建立新的硬链接。基于此前提，可以更加方便的理解本篇讲述的原理。
由于一个文件有唯一的 inode 号，如果 inode 号没有变化，说明我们操作的是同一个文件。查看 inode 号可以使用如下命令：
ls -ilL filename ls 命令的 -i 选项用来打印文件的inode 号，-lL 两个选项合用时，会跟踪符号链接到真实的目标文件，显示目标文件的详细信息。
删除正在被读写的文件 在上一篇中，我们探讨了 unlink() 系统调用的行为，在其 man page 中明确说明，当文件正在被进程打开时，执行 unlink() 只会删除文件名，并不会删除文件内容，只有所有打开此文件的进程都关闭此文件后（注意当进程退出时，会自动关闭所有打开的文件），文件内容才会被真正删除。下面就对这一描述进行验证。由于 rm 命令中使用的也是 unlink() 系统调用，下面就以 rm 命令作为示例。
当一个进程运行时，会在系统的 /proc 下建立一个名字为进程 id 的子目录，其中的 fd 目录中含有所有被进程打开的文件描述符。即 /proc/pid/fd/fd_num 表示此进程正在打开的文件。我们用以下程序作为打开文件的实验程序：
#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/264a5dc348e90a9dd8eeb0aba861ac14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a00f2642ab66a0188725a7ef469044f/" rel="bookmark">
			微信小程序实战-01翻页时钟-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言需求分析功能设计界面设计界面结构设计界面样式设计 逻辑设计 单页功能实现运行结果 前言 我经常在手机上用的一款app有一个功能是翻页时钟，基于之前学习的小程序相关的基础内容，我打算在微信小程序中也设计一个翻页时钟功能，Just do it！
需求分析 作为练手项目，需求比较简单，两个功能：
支持时、分、秒显示；支持翻页效果； 整体效果大概是这个样子：
功能设计 界面设计 界面结构设计 wxml整体结构比较简单，设计6个页面和两组“:”。
界面样式设计 wxss的样式(CSS)对于我来说还是很陌生，没做过前端，也是边学边干。总体涉及的CSS的知识点会比较杂，对于样式的描述如果是动态的部分，还是不太了解，用文字描述也会不太容易。涉及的知识点，通过代码注释和理论结合进行阐述。
整体的样式也如上图所示。
逻辑设计 主要是通过js来完成计时和翻页的功能。
首先，我会先完成一个页面的渲染；然后再完成6个页面的渲染和计时，最后再完成动态翻页效果。
单页功能实现 本文先记录一个时钟数字页的渲染实现过程。
因为要有“翻页”，所以一个页面由一个view组件(item)来构造，由于涉及翻页，所以每个item设计成上下半部和一个页轴。上下半部也是通过view组件来构造，页轴通过样式来构造。
clock.wxml代码如下：
&lt;!-- clock.wxml --&gt; &lt;view class="container"&gt; &lt;view class="item"&gt; &lt;view class="up"&gt; &lt;view class="number"&gt;5&lt;/view&gt; &lt;/view&gt; &lt;view class="down"&gt; &lt;view class="number"&gt;5&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; clock.wxss代码如下：
/* 设置item的样式，固定宽高 */ .item { position: relative; width: 90rpx; height: 155rpx; border:1rpx solid rgba(121, 121, 121, 0.384); box-shadow: 0 2rpx 18rpx rgba(0,0,0,0.7); border-radius: 10rpx; } /* 时钟的单个数字 */ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a00f2642ab66a0188725a7ef469044f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b550bbeea30577a18ed25a1a509f76/" rel="bookmark">
			编程语言--C/C&#43;&#43;、python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 编程语言一、C/C++C 与 C++ 的区别(面向对象的特点)C++ 与 Python的区别判断struct的字节数static 作用Const 作用extern "C"的作用多态如何实现多态？ 虚函数虚函数怎么实现的？ 析构函数虚析构函数的作用virtual函数能不能用在构造函数中？ 继承多线程的同步问题左值和右值C++的设计模式动态内存管理智能指针long long转成stringNULL和nullstr的区别new/delete和 malloc/free的区别delete和delete []区别C++虚函数的实现机制C++基类的析构函数为什么建议是虚函数？STL中的 vector 和 list 的区别STL中的 vector 和 map 的底层结构map 和 unorder_map 区别实现atoi，即将"1234"转化成1234（int类型）实现atof，即将"1.234"转换成1.234（float类型）结构体和联合体的区别引用和指针C++ operator new 和 new operator怎么理解C++面向对象？跟Python面向对象有什么区别？C++多态特性，父类和子类的区别虚函数有哪些作用？多态的虚函数（父类和子类）返回值类型可以不一样吗？什么情况下，返回值类型不一样？C++四种强制类型转换有哪些？每种特性是什么？有什么区别？map 实现原理set 实现原理STL中的sort函数实现std::vector描述一下，如何动态扩展，如何shink内存unorder容器与ordered容器的区别说一下智能指针，shared_ptr与unique_ptr普通指针如何实现一块内存只能有一个指针指向这种功能C++ RTTI 是什么？C++是如何实现多态的？vector的iterator什么时候失效？写CmakeLists.txt，写gcc指令函数局部变量存在哪里？new出来的变量在哪里？堆区和栈区什么区别？悬空指针和野指针有什么区别？什么是内存泄漏？怎么产生的？如何检测？extern关键字的底层机制是怎么实现的？静态绑定和动态绑定是怎么实现的？虚函数表跟对象还是跟类绑定?返回函数中的静态变量的地址会发生什么？全局static变量和非static的有什么区别？STL 的 map 如何实现的？unordered_map怎么实现的？画一下底层的数据结构sorted_set 怎么实现？.h里面定义函数，会在什么阶段错误？为什么.h里面一般只放函数声明？为什么这么设计？内联函数 inline 作用析构函数 virtual 作用vector.size() 和 vector.capicity() 区别计算 vector.push_back() 的平均复杂度怎么设计一个内存池，要考虑哪些方面？lambda 捕获对象的实现参考资料 二、PythonPython中可变和不可变对象是什么意思？tuple、list 和 dict 的区别iterables、generator 和 yield的区别Python 的装饰器Python 的迭代器使用迭代器遍历和非迭代器遍历区别？ Python 的生成器Python 字典采用的是什么数据结构？Python 的 append 和 extend 有什么区别？Python 的浅拷贝和深拷贝Python的内存回收机制可变对象和不可变对象 编程语言 一、C/C++ C 与 C++ 的区别(面向对象的特点) TODO C++ 与 Python的区别 TODO 判断struct的字节数 一般使用sizeof判断struct所占的字节数，那么计算规则是什么呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08b550bbeea30577a18ed25a1a509f76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ed045b4a937b99fe862a8431b7a842f/" rel="bookmark">
			【leetcode100-033】【链表】排序链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题干】
给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。
【思路】
递归版归并法链表版～没什么特别好说的（非递归版归并也是可以哒，但是马上要考试了今天懒得写了！打个flag在这里也许哪天想起来会补写一下）首先是分割，这一步在链表里会麻烦一点，因为要找到链表的中点，得用快慢指针，快指针每次移动 2 步，慢指针每次移动 1步，当快指针到达链表末尾时，慢指针指向链表的中点。对拆出的两个子链表递归的进行拆分，直到达到递归出口（只有一个节点）逐层归并有序的子链表，done。 【题解】
class Solution { public: ListNode* sortList(ListNode* head) { return sortList(head, nullptr); } ListNode* sortList(ListNode* head, ListNode* tail) { if (head == nullptr) { return head; } if (head-&gt;next == tail) { head-&gt;next = nullptr; return head; } ListNode* slow = head, *fast = head; while (fast != tail) { slow = slow-&gt;next; fast = fast-&gt;next; if (fast !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ed045b4a937b99fe862a8431b7a842f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3042a4b51bce237205de5b16986cb05a/" rel="bookmark">
			第一个Java网络爬虫程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言第一个Java网络爬虫程序总结 前言 网络爬虫是一种获取互联网信息的技术，它可以模拟浏览器行为，访问网站并提取所需的数据。在这个小Demo中，我们使用Java语言结合HttpClient库实现了一个简单的爬虫程序，用于抓取汽车之家的车辆评测数据。在实际爬虫项目中，除了简单的HTTP请求，还需要处理页面解析、数据存储、反爬虫策略等问题。
第一个Java网络爬虫程序 引入依赖 HttpClient用于进行HTTP请求，slf4j用于日志记录。
&lt;dependencies&gt; &lt;!-- HttpClient --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 加入log4j.properties配置 创建log4j.properties文件，用于配置日志输出的格式和级别。
log4j.rootLogger=DEBUG,A1 log4j.logger.cn.itcast = DEBUG log4j.appender.A1=org.apache.log4j.ConsoleAppender log4j.appender.A1.layout=org.apache.log4j.PatternLayout log4j.appender.A1.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss,SSS} [%t] [%c]-[%p] %m%n 编写最简单的爬虫，抓取汽车之家车辆评测数据 public class AutohomeCrawlerTest { public static void main(String[] args) throws Exception { // 创建HttpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); // 声明访问地址 HttpGet httpGet = new HttpGet("https://www.autohome.com.cn/bestauto/"); // 发起请求 CloseableHttpResponse response = httpClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3042a4b51bce237205de5b16986cb05a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b273605f1d0af91dd87e6f906866a27d/" rel="bookmark">
			【书生·浦语大模型实战营03】《基于 InternLM 和 LangChain 搭建你的知识库》学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《基于 InternLM 和 LangChain 搭建你的知识库》 常见术语 RAG: Retrieval Augmented Generation，检索增强生成
1. 大模型开发范式 1.1 RAG VS Finetune RAGFinetune低成本可个性化微调可实时更新知识覆盖面广受基座模型影响大成本高昂单次回答知识有限无法实时更新 1.1.2 Finetune （2）成本高昂：需要GPU算力以及模型训练知识 3. 构建向量数据库 3.1 加载源文件 → \rightarrow →文档分块 → \rightarrow →文档向量化 确定源文件类型，针对不同类型源文件选用不同的加载器 核心在于将带格式文本转化为无格式字符串 由于单个文档往往超过模型上下文上限，我们需要对加载的文档进行切分 一般按字符串长度进行分割可以手动控制分割块的长度和重叠区间长度 使用向量数据库来支持语义检索，需要将文档向量化存入向量数据库 可以使用任意一种Embedding模型来进行向量化可以使用多种支持语义检索的向量数据库，一般使用轻量级的Chroma 4. 搭建知识库助手 4.1 RAG方案优化建议 基于RAG的问答系统性能核心受限于： 检索精度Prompt性能 一些可能的优化点： 检索方面： 基于语义进行分割，保证每一个chunk的语义完整给每一个chunk生成概括性索引，检索时匹配索引 Prompt方面： 迭代优化Prompt策略 南溪：感觉“概括性索引”就有点像论文的摘要。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/912e9ac611d0a04ceec6966ffa98872d/" rel="bookmark">
			uni-app顶部导航条固定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.准备 scroll-view 滚动容器，包裹需要滚动的区域
&lt;!-- 自定义导航栏 --&gt; &lt;CustomNavbar /&gt; &lt;scroll-view class="scroll-view" scroll-y&gt; &lt;!-- 自定义轮播图 --&gt; &lt;XtxSwiper :bannerList="bannerList" /&gt; &lt;!-- 首页分类 --&gt; &lt;CategoryPanel :CategoryPanelList="CategoryPanelList" /&gt; &lt;!-- 热门推荐 --&gt; &lt;HotPanel :HotPanelList="HotPanelList" /&gt; &lt;!-- 猜你喜欢 --&gt; &lt;XtxGuess /&gt; &lt;/scroll-view&gt; 2.给父容器page设置高度为100%，完全撑开，开启并flex弹性盒，给滚动容器设值flex值为1
这里父容器必须要给高度，要不然顶部固定不起效
page { background-color: #f7f7f7; height: 100%; display: flex; flex-direction: column; } .scroll-view { flex: 1; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7843f15444bab233211259c445d21f7/" rel="bookmark">
			AUTOSAR开发文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
目录
状态机+电源管理开发... I
文档... I
1. 综述... 1
2. 系统硬件架构图... 1
3. 状态机设计方案... 2
4. 电源管理方案... 4
综述 本文档主要描述了MCU芯片TC297的AUTOSAR方案。MCU的基础软件由AUTOSAR软件实现，AUTOSAR可简易理解为如下层次。
MCU芯片驱动层：MCU芯片的抽象层，目的是将各类MCU芯片进行抽象，向上统一接口，隔离其他层次软件，做到足够的解耦状态，以便更换芯片时其他软件无需变更只需更换这一层软件就可。MCU芯片的抽象层包含Port,CAN,SPI,ETH,MCU,WDG,GPT等。控制器抽象层：控制器抽象层（包含I/O抽象驱动），作用是将控制器的外设进行抽象，向上统一接口。这一层的目的是可以控制器不同的外设需求进行抽象，做到上下隔离，解耦。重新设计控制器时，修改本层即可。包含：Fee,Mefif,Canif,Ethif等等。Service层：这一层是Autosar核心层，包含内存管理，网络管理，数据路由，UDS诊断管理，XCP标定等汽车领域通用化的软件服务都在这一层有所体现。关联了ISO14229,ASAP2，J1939等汽车标准,同时将成熟的MCU协议软件集成到这一层中；Autosar OS:OS实际上属于Service层的模块，但较为核心且独立，所以单独列出。AUTOSAR OS是基于OSEC OS进行开发的，区别于Linux，AUTOSAR OS功能相对简洁，不包含外设驱动，只关注任务调度。且所有任务都是静态分配，不支持动态任务分配。使用调度表进行任务调度，可对任务进行优先级，是否抢占，任务堆栈等进行设置，对二类中断进行统一管理。有专门配置选项进行管理。复杂驱动：对不易被统一接口，未被AUTOSAR定义，但属于基础软件，各控制器自定义的软件可放在复杂驱动中。RTE：可理解为数据接口层。 需要完整文档私信。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f80085b554d1b1f105ec6822e99d367/" rel="bookmark">
			自动驾驶代客泊车AVP安全监控设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
安全监控设计... I
文档... I
1 文档... 1
1.1 变更历史 1
1.2 术语 1
1.3 引用文档 1
2 功能综述... 2
3 详细方案... 4
3.1 FPGA供电PMIC的监控 4
3.2 camera接口电路的监控 5
3.3 上电时序监控 6
3.4 供电电压监控 7
3.5 温度的监控 8
3.6 IMU内部故障监控 8
3.7 GPS天线接口电路监控 9
3.8 风扇驱动电路监控 9
3.9 CAN总线收发器状态监控 10
3.10 TC297硬件自检及监控（安全机制）集成 10
3.11 MCU程序流的监控 10
3.12 外部供电异常，MCU紧急响应功能 11
3.13 MCU对ZU5的程序流、心跳监控 11
3.14 监控综合管理模块 11
4 开发计划及任务分解... 12
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f80085b554d1b1f105ec6822e99d367/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44378dc7d6c2d3a4404982adcf27e04a/" rel="bookmark">
			C&#43;&#43;力扣题目--94,144,145二叉树递归遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路 这次我们要好好谈一谈递归，为什么很多同学看递归算法都是“一看就会，一写就废”。
主要是对递归不成体系，没有方法论，每次写递归算法 ，都是靠玄学来写代码，代码能不能编过都靠运气。
本篇将介绍前后中序的递归写法，一些同学可能会感觉很简单，其实不然，我们要通过简单题目把方法论确定下来，有了方法论，后面才能应付复杂的递归。
这里帮助大家确定下来递归算法的三个要素。每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！
确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。
好了，我们确认了递归的三要素，接下来就来练练手：
以下以前序遍历为例：
确定递归函数的参数和返回值：因为要打印出前序遍历节点的数值，所以参数里需要传入vector来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下： void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) 确定终止条件：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下： if (cur == NULL) return; 确定单层递归的逻辑：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下： vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 单层递归的逻辑就是按照中左右的顺序来处理的，这样二叉树的前序遍历，基本就写完了，再看一下完整代码：
前序遍历：
class Solution { public: void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 } vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; traversal(root, result); return result; } }; 那么前序遍历写出来之后，中序和后序遍历就不难理解了，代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44378dc7d6c2d3a4404982adcf27e04a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30d32a7aada2c8a8dbe42a3df512e478/" rel="bookmark">
			国产编程语言炫彩，界面库ui dll，有人了解吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中文编程: 中英文双语编程, 中英一键切换, 中英对照, 中文为主, UNICODE/ANSI编码都支持;
完全免费: 炫语言免费, 调试器免费, IDE绿色版无需安装;
纯文本: 纯文本格式代码, 随意复制粘贴, GIT代码托管, 多人合作开发;
PY风格: PY风格代码, 通过代码缩进确定作用域 非 大花括号"{}", 减少不必要的代码输入, 增加代码可读性;
32/64位: 可开发32/64位程序, 编译调试无需切换(32/64)IDE;
界面库: 内置炫彩界面库, 可视化UI设计器, 所见即所得, 灵活强大, 无需与第三方UI对接, 不限组件数量;
体积小: 编译空exe大小125KB, 带界面exe大小2M左右;
编译快: 新建项目首次秒编译, 之后每次只编译修改过的代码文件, 大大提高开发效率;
高性能: C++的运行效率, 比C++上手简单很多, C++支持的功能, 我们几乎都支持;
支持指针: 支持指针, 引用, 模板, 可面向过程, 也可面向对象, 无强制基础类;
易上手: 全中文编程, 每条命令中英对照, 命令接口中文一看就懂, 文档, 教程, 视频, 资源商城, 交流QQ群, 入门无忧;
模块易封装: C++库拿来即用, 添加注释即可汉化, 无需套娃封装, 无过度封装, 更加原汁原味;
与C++混合: 可嵌入C++代码, 可包含C++文件, 可封装为模块;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30d32a7aada2c8a8dbe42a3df512e478/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ac7ecf10244f5ba6b6071d39e1ed4ce/" rel="bookmark">
			程序猿的时间管理和生产力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 为什么时间管理很重要？如何管理时间？心理维度生理维度技术尺寸 时间管理技巧每周计划基于目标的规划番茄钟为什么是25分钟？番茄钟为什么有效？艾森豪威尔矩阵这一切都是从开发者的角度来看的 也许我从开始学习或从事软件开发工作的人那里得到的最常见的问题之一是：“你如何设法学习这么多不同的东西，同时仍然有时间工作和娱乐？”。答案很简单： 时间管理。 为什么时间管理很重要？ 管理时间的理由有 N 个，但我只列出几个主要的：
时间和生活质量：时间是我们拥有的最宝贵的资源之一，管理它可以直接影响我们的生活质量。高效的时间管理使我们能够开展日常活动、实现我们的目标，并拥有休闲和休息的时刻。
生产力：有效的时间管理可以提高我们执行任务的生产力和效率。这使我们能够在更短的时间内完成更多的任务，从而有更多的空闲时间来做其他事情。
平衡：有效的时间管理使我们能够保持平衡的生活，避免压力和超负荷的活动。这有助于我们控制身心健康，这对我们的福祉至关重要。
动力：当我们充满动力并专注于正在执行的任务时，就更容易保持专注和专注，从而提高我们的生产力和效率。另一方面，当我们对任务缺乏动力和兴趣时，我们更容易分心并在不太重要的活动上浪费时间。
除了其他几个原因之外，总而言之，在时间管理方面我喜欢引用一句话：
你无法管理你无法衡量的事物，你无法衡量你无法定义的事物，你无法定义你不理解的事物，你无法管理的事物就不会成功。~ 威廉·爱德华兹·戴明
如何管理时间？ 在进入这个主题之前，这是我在这里要讨论的最有趣的事情，重要的是要了解时间管理涉及不同的维度，包括心理、生理和技术方面。
心理维度 在心理层面，管理我们的思想、情绪和行为非常重要，这样我们才能保持对我们正在执行的活动的关注和专注。
我们必须了解时间的价值，并有动力充分利用时间。通常，我们很容易忽视时间的价值，并陷入认为未来总会有更多时间来做我们需要做的事情的陷阱。
生理维度 生理维度涉及我们的身体及其极限。就像生活中的一切一样，我们有一个生产力的最佳点，也就是我们可以高效、高质量地执行任务的点。如果超过这一点，我们最终可能会损害我们的身心健康。
为了确保您的身体始终接近最佳生产力点，需要更好地照顾 3 种机制：
睡眠-觉醒周期：睡眠是身体调节的主要机制之一，睡眠过少或过多都会损害您的表现和健康。有时间睡觉和起床，睡眠充足以便感到休息并准备好进行日常活动。
饥饿消化：身体需要能量才能发挥作用，如果饮食不当，身体将没有能量进行日常活动。此外，吃得太多也会损害你的表现，因为身体会消耗能量来消化食物，这会导致困倦和疲劳。您需要始终关注您的能量需求，已经通向下一个机制的一个好提示是开始进行体育锻炼。
压力与放松：一切都是动态的，身体也不例外，您需要放松的时刻，以便您的身体能够从日常活动造成的压力中恢复过来。这就像一个跷跷板，如果你在精神上给身体太大的压力，就必须有身体上的压力，这样你的身体才能恢复，因此进行体育锻炼很重要。
技术尺寸 技术维度包括用于有效管理时间的工具和技术。学习使用正确的工具并应用对我们的工作档案有效的技术非常重要。
时间管理技巧 有多种技术可以应用于时间管理。一些最受欢迎的包括：
每周计划 每周计划是最简单、最有效的时间管理技巧之一。这个想法是计划一周内将进行的活动，定义一周中每一天将执行哪些任务。
需要注意的是，每周计划不应该太详细，因为这可能会导致焦虑和压力。理想的情况是仅定义最重要的活动，其余的活动则根据日常情况进行定义。此外，还有很大的陷入规划谬误的危险。
计划谬误：计划谬误是当人们高估自己在给定时间内执行任务的能力时发生的一种现象。为了避免这个陷阱，重要的是要现实并考虑白天可能发生的不可预见的事件。因此，在每周计划中为不可预见的事件和计划外的活动留出空闲时间非常重要。
基于目标的规划 这种技术在公司中被广泛使用，以定义在一定时期内将实现的目标和目标。这个想法是定义一个目标以及实现该目标将要实现的目标。
请记住，目标与目标不同，目标是您想要实现的目标，而目标是您为实现该目标而要做的事情。例如，如果你想减肥，你的目标是减肥，你的目标是锻炼和健康饮食。
制定目标对于保持对我们正在执行的活动的关注和专注非常重要。此外，设定现实且可实现的目标也很重要，因为这可以提高动力和生产力。此外，创建 KPI（关键绩效指标）是衡量所执行活动的进度和效率的好方法。我建议阅读：KPI：它们是什么以及如何定义公司的绩效指标
番茄钟 番茄工作法可能是时间管理中最著名的技术，它是一种简单而有效的技术，可以提高执行任务的生产力和效率。这个想法是将时间分成 25 分钟的时间段，中间间隔 5 分钟。在每个时间段内，目标是专注于一项任务并避免分心。
就这一点而言software development，在功能开发过程中，开发人员最终会被其他事情分散注意力，例如在 Slack 上回复消息、阅读电子邮件等，这是很常见的。这可能会导致开发延迟该功能并损害开发人员的生产力。
番茄工作法有助于避免这些干扰，因为开发人员知道他们只有 25 分钟的时间来处理该功能，并且在此期间不能被其他事情分散注意力。此外，番茄钟还有助于保持注意力和集中力，从而提高执行任务的生产力和效率。
为什么是25分钟？番茄钟为什么有效？ 番茄工作法的运作遵循四个原则：
压力与放松：尊重时间管理的生理维度，通过找到一个可以保持专注的好时间，你可以更有效地工作。25 分钟的时间对于大多数人来说是一个不错的时间，但是您可以测试其他时间，看看哪个最适合您。
反对多任务处理：我们知道尝试同时做几件事并没有帮助，因为这只会让我们更累，效率更低。因此，番茄钟有助于避免多任务处理，如果你有一项任务要执行，就专门花 25 分钟来完成它。
设置时间：设置时间是开始任务所需的时间。通过一次只专注于一项任务，您可以最大限度地减少准备时间并提高工作效率。
批量处理：生产工程学的一项原理，表示批量生产比单元生产更有效率。这意味着在番茄钟期间，你将积累在 5 分钟休息时间或下一个番茄钟期间要执行的任务，例如在 Slack 上回复别人、阅读电子邮件等。
除了这 4 个原则之外，还有两种理论可以解释番茄工作法为何有效：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ac7ecf10244f5ba6b6071d39e1ed4ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c27a60575087f306dbec9cf801472ebc/" rel="bookmark">
			19.Linux Shell任务控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Linux Shell任务控制1)信号通过键盘生成信号trap 命令捕获信号 2)在后台运行脚本命令后加 &amp; 符使用nohub命令 3)作业控制4)调度优先级nice命令renice 命令 5)定时运行作业at定期执行命令reference 欢迎访问个人网络日志🌹🌹知行空间🌹🌹
Linux Shell任务控制 通常情况下运行脚本的方式就是以实时模式在命令行界面上直接运行，除此之外还有很多其他的运行脚本的方式，如后台运行，定时运行等等。除运行方式外，还可以对脚本程序的运行进行控制，包括向脚本发送信号、修改脚本的优先级以及在脚本运行时从暂停切换到运行模式。
1)信号 Linux利用信号与运行在系统中的进程进行通信，可以通过对脚本进行编程，使其在收到特定信号时执行特定命令。
信号值描述1SIGHUP挂起进程2SIGINT终止进程3SIGQUIT停止进程9SIGKILL无条件终止进程15SIGTERM尽可能终止进程17SIGSTOP无条件停止进程，但不是终止进程18SIGTSTP停止或暂停进程，但不终止进程19SIGCONT继续运行停止的进程 默认情况下，交互式shell终端本身的进程会忽略收到的任何 SIGQUIT (3) 和 SIGTERM (5) 信号，因此其不会被意外终止。
如果bash shell收到了 SIGHUP 信号，比如当要离开一个交互式shell时，它就会退出。但在退出之前，它会将 SIGHUP 信号传给所有由该shell所启动的进程。
通过键盘生成信号 Ctrl+C组合键会生成 SIGINT 信号，并将其发送给当前在shell中运行的所有进程。
Ctrl+Z组合键会生成一个 SIGTSTP 信号，停止shell中运行的任何进程。这样可以在进程运行期间暂停进程，而无需终止它。这样可以在不终止进程的情况下使用户深入脚本内部一窥究竟。
停止进程会让程序继续保留在内存中，并能从上次停止的位置继续运行。
要想启动停止的进程可以使用fg或bg在前台和后台启动。
$ sleep 100 # ^Z # [1]+ 已停止 sleep 100 方括号中的数字是shell分配的作业号 （job number）。
可以用 ps 命令来查看已停止的作业。
$ ps -l # F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD # 0 T 1001 116014 113239 0 80 0 - 2791 do_sig pts/0 00:00:00 sleep 在 S 列中（进程状态）， ps 命令将已停止作业的状态为显示为 T 。这说明命令要么被跟踪，要么被停止了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c27a60575087f306dbec9cf801472ebc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0c18426756230e34c38e1f0312e0498/" rel="bookmark">
			ubuntu常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ls /dev 查看所有设备文件
cat /proc/devices 查看所有驱动的主设备号
cat /etc/resolv.conf 查看DNS配置文件 ,直接设置这个文件没用，重启后这个文件又被清空，解决办法是在 vi /etc/network/interfaces 设置网络配置
配置环境变量 （仅对当前用户有效)
vim ~/.bashrc # 在最后一行加上 export PATH=$PATH:/home/uusama/mysql/bin source ~/.bashrc 立即生效 配置环境变量也可以用 下面代码
vim /etc/profile ​​​​​​​source /etc/profile 创建符号链接 ln -s /path/to/file link_name
交叉编译工作链安装后，有时候要执行arm-linux-gcc -v 发现报 No such file or directory，原因是我系统是64位的，需要安装32位库，此时执行 sudo apt-get install lib32z1 备注 arm-linux-gcc 是 做的符号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0afed704777446c263b4b1c6613f65a7/" rel="bookmark">
			Java动态代理机制，创建代理对象的方法（InvocationHandler，Proxy）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.什么是动态代理2.如何为Java对象创建一个代理对象 1.什么是动态代理 特点：无侵入式的给代码增加额外的功能。
在Java中，动态代理是一种机制，允许在运行时创建一个代理对象来代替原始对象，并可以在代理对象的方法执行前后追加额外的逻辑。动态代理是通过Java的反射机制实现的。
动态代理常用于在不修改原始类的情况下，增加额外的功能或在方法执行前后进行一些操作，比如日志记录、性能统计、事务管理等。
动态代理主要涉及两个关键接口：InvocationHandler和Proxy。
InvocationHandler负责实现代理对象的方法逻辑，而Proxy则用于创建代理对象。
使用动态代理，需要创建一个实现了InvocationHandler接口的类来处理代理对象的方法调用。
在InvocationHandler接口的invoke方法中，可以对原始对象的方法进行增强。
然后，通过Proxy类的静态方法newProxyInstance来创建代理对象，同时指定要代理的接口类型和InvocationHandler对象。
最后，通过代理对象来调用方法，实际上会调用InvocationHandler的invoke方法。
动态代理的优点是可以在不修改原始类的情况下，增加或改变其行为。
它具有较高的灵活性和可扩展性，可以应用于各种场景，如AOP编程、远程方法调用等。
2.如何为Java对象创建一个代理对象 ①Proxy提供了为对象产生代理对象的方法：
public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[ ] interfaces,InvocationHandler h)
参数一:用于指定用哪个类加载器，去加载生成的代理类
参数二: 指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法
参数三:用来指定生成的代理对象要干什么事情
编写一个明星行为接口Star:
public interface Star { //想要被代理的方法写在接口当中 //唱歌 public abstract String sing(String name); //跳舞 public abstract void dance(); } 创建一个BigStar类实现Star接口，重写方法：
public class BigStar implements Star { private String name; public BigStar() { } public BigStar(String name) { this.name = name; } //唱歌 @Override public String sing(String name) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0afed704777446c263b4b1c6613f65a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52448275fc17a24f44fd6f68f12dc978/" rel="bookmark">
			7 种常见的前端安全攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 七种常见的前端攻击1.跨站脚本（XSS）2.依赖性风险3.跨站请求伪造（CSRF）4.点击劫持5.CDN篡改6. HTTPS 降级7.中间人攻击 随着 Web 应用程序对业务运营变得越来越重要，它们也成为更有吸引力的网络攻击目标。但不幸的是，与后端和 DevOps 同行相比，许多 Web 开发人员在构建安全前端方面已经落后。这种差距增加了破坏性数据泄露的风险。
最近发生的诸如Balancer 协议泄露之类的事件暴露了攻击者在利用前端漏洞时可以造成多大的损害。据公开承认的消息，Balancer Protocol 据报道遭到前端攻击，造成超过 24 万美元的损失。由于黑客工具和脚本的激增，发起攻击的障碍不断下降，对 Web 应用程序的威胁持续增长。
七种常见的前端攻击 1.跨站脚本（XSS） 这是一种注入恶意客户端代码的攻击。例如，攻击者可以将窃取用户 cookie 的 JavaScript 输入到不清理条目的评论表单中。当受害者加载受感染的页面时，脚本会执行以使攻击者能够访问用户帐户。
2.依赖性风险 前端应用程序依赖许多第三方库和组件。如果这些存在漏洞，就会破坏整个应用程序。使用具有已知问题的过时依赖项是开发人员常见的疏忽。
3.跨站请求伪造（CSRF） 这些迫使受害者在他们登录的应用程序中执行不需要的操作。例如，攻击者可以通过伪装的链接欺骗用户，使用用户存储的凭据悄悄地从用户的帐户中转移资金。
4.点击劫持 在可信页面上使用透明覆盖层来诱骗用户单击与他们感知不同的内容。例如，攻击者可以将转移资金按钮覆盖在猫视频的播放按钮上。
5.CDN篡改 如果从外部CDN加载库，攻击者可以在那里修改它们以注入恶意代码，然后由应用程序用户下载。
6. HTTPS 降级 剥离 HTTPS 加密有助于监视用户流量。攻击者利用错误或缺少 HSTS 标头将 HTTP 请求降级为普通的不受保护的 HTTP。
7.中间人攻击 攻击者秘密转发并可能改变两方认为他们正在通信的方式。这使得在受害者之间监视和传播虚假信息成为可能。
随着越来越多的业务功能转移到线上，网络作为攻击媒介将继续增长。因此，构建前端应用程序的 JavaScript 开发人员需要加强他们的安全实践。此外，从攻击者的角度了解漏洞对于在漏洞成为头条新闻之前将其关闭至关重要。
python推荐学习汇总连接：
50个开发必备的Python经典脚本(1-10)
50个开发必备的Python经典脚本(11-20)
50个开发必备的Python经典脚本(21-30)
50个开发必备的Python经典脚本(31-40)
50个开发必备的Python经典脚本(41-50)
————————————————
​最后我们放松一下眼睛
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85464eb5cfeb1efe88377136f02bb993/" rel="bookmark">
			20240108移远的4G模块EC20在Firefly的AIO-3399J开发板的Android11下调通的步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20240108移远的4G模块EC20在Firefly的AIO-3399J开发板的Android11下调通的步骤
2024/1/8 17:50
缘起：使用友善之臂的Android11可以让EC20上网，但是同样的修改步骤，Toybrick的Android11不能让EC20上网。
最后确认是selinux的问题！
开发板：Firefly的AIO-3399J【RK3399】
SDK：rk3399-android-11-r20211216.tar.xz【Android11】
Android11.0.tar.bz2.aa【ToyBrick】
Android11.0.tar.bz2.ab
Android11.0.tar.bz2.ac
https://wiki.t-firefly.com/AIO-3399J/prepare_compile_android.html
AIO-3399J产品规格书 立即购买
AIO-3399J 采用 RK3399 六核(A72x2+A53x4) 64 位处理器，主频高达1.8GHz，集成了四核 Mali-T860 GPU，性能优异。
0、简略步骤：
rootroot@rootroot-X99-Turbo:~/3TB$ cat Android11.0.tar.bz2.a* &gt; Android11.0.tar.bz2
rootroot@rootroot-X99-Turbo:~/3TB$ tar jxvf Android11.0.tar.bz2 rootroot@rootroot-X99-Turbo:~/3TB$ mv Android11.0 64rk3399-android-11
rootroot@rootroot-X99-Turbo:~/3TB$ cd 64rk3399-android-11
rootroot@rootroot-X99-Turbo:~/3TB/64rk3399-android-11$ cd u-boot
rootroot@rootroot-X99-Turbo:~/3TB/64rk3399-android-11/u-boot$ ./make.sh rk3399
rootroot@rootroot-X99-Turbo:~/3TB/64rk3399-android-11/u-boot$ cd ..
rootroot@rootroot-X99-Turbo:~/3TB/64rk3399-android-11$ cd kernel/
rootroot@rootroot-X99-Turbo:~/3TB/64rk3399-android-11/kernel$ make ARCH=arm64 rockchip_defconfig android-11.config -j36
rootroot@rootroot-X99-Turbo:~/3TB/64rk3399-android-11/kernel$ make ARCH=arm64 BOOT_IMG=../rockdev/Image-rk3399_Android11/boot.img rk3399-sapphire-excavator-edp-avb.img -j36
rootroot@rootroot-X99-Turbo:~/3TB/64rk3399-android-11$ source build/envsetup.sh rootroot@rootroot-X99-Turbo:~/3TB/64rk3399-android-11$ lunch
36. rk3399_Android11-userdebug
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85464eb5cfeb1efe88377136f02bb993/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6abf762ba7d53939c4179a4704d8a9f5/" rel="bookmark">
			R语言(12)：绘图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		12.1 创建图形 12.1.1 plot函数 plot(c(1,2,3),c(1,2,4)) plot(c(1,2,3),c(1,2,4),"b") plot(c(-3,3),c(-1,5),"n",xlab = "x",ylab = "y") 12.1.2 添加线条：abline()函数 x &lt;- c(1,2,3) y &lt;- c(1,3,8) plot(x,y) lmout &lt;- lm(y~x) abline(lmout) #添加一条直线 abline(lmout$coefficients) abline(2,1) lines(c(1.5,2.5),c(3,3)) #添加一条线段，端点为(1.5,3),(2.5,3) lines(c(1.5,2.5),c(3,4),"l",lty = "dotted")#设定线条的类型 ?par 12.1.3 设备窗口（掌握） 新建窗口和新建图形不是一个东西，新建的窗口只有一个
主要的步骤（1）新建设备窗口（2）切换设备窗口
windows() #在保持原有图形的基础上新建图形窗口 X11() dev.new() plot(x,y,"n") lines(c(1.5,2.5),c(3,3),"l",lty = "dotted") lines(c(1.5,2.5),c(3,4),"l",lty = "dashed") dev.set(3) #切换图形窗口 12.1.4 在一张图中绘制两条密度曲线 一定要先新建再添加
e1 &lt;- rbinom(100,120,0.55) d1 &lt;- density(e1,from= 0,to =100) plot(d1,main= "",xlab = "") e2 &lt;- rnorm(100,60,10) d2 &lt;- density(e2,from= 0,to =100) lines(d2,lty = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6abf762ba7d53939c4179a4704d8a9f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a26517dfafdd7753ef709cc37078ad47/" rel="bookmark">
			【K8S 云原生】Kurbernets集群的调度策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Kubernetes的list-watch机制
1、List-watch
2、创建pod的过程：
二、scheduler调度的过程和策略：
1、简介
2、预算策略：predicate
3、优先策略：
3.1、leastrequestedpriority：
3.2、balanceresourceallocation：
3.3、imagelocalitypriority：
4、选择的过程：
三、kubernetes对Pod的调度策略
四、定向调度
1、调度策略简介：
2、指定节点：
3、指定标签：
五、亲和性调度：
1、介绍：
2、键值的运算关系：
3、node亲和性实例
一、Kubernetes的list-watch机制 1、List-watch K8S集群中，通过List-watch机制进行每个组件的协作，保持数据同步。这种设计可以实现每个组件之间的解耦
kubectl配置文件，统一向集群内部apiserver发送命令——通过apiserver把命令发送到各个组件
创建成功之后，kubectl get pod，kubectl describe pod nginx查看信息——在ETCD数据库中
List-watch会在每一步把监听的消息（apiserver:6443）——组件controller-manager、schedule、kubelet、ETCD都会监听apiserver的6443端口
2、创建pod的过程： 1、客户端向apiserver发送创建创建pod的请求，然后apiserver将请求信息存入到ETCD中
2、存入完之后，ETCD会通过apiserver发送创建pod资源的事件
3、controller-manager通过List-watch机制监听apiserver发送出来的事件，并创建相关的pod资源。创建完成之后，通过apiserver将信息存入到ETCD中
4、ETCD存入更新信息之后，再次通过apiserver发送调度pod资源的事件到scheduler
5、scheduler通过List-watch机制监听到apiserver发出的调度事件，通过调度算法，将pod资源调度到合适的node节点上，调度完成后通过apiserver将调度信息更新到ETCD中
6、ETCD收到更新信息后，再次向apiserver发出的创建pod的事件
7、kubelet通过List-watch机制监听apiserver发出的创建pod的事件，然后根据事件信息，在相应的node节点完成pod的创建
二、scheduler调度的过程和策略： 1、简介 scheduler是K8S集群的调度器，把pod分配到集群的节点
调度规则：
公平，每个节点都能够分配资源资源高效利用，集群中的资源可以被最大化使用效率：调度的性能要好，能够尽快的完成大批量pod的调度工作灵活：允许用户根据自己的需求，控制和改变调度的逻辑 scheduler：负责调度资源，把Pod调度到node节点上
有两种策略：预算策略、优选策略
scheduler是一个单独运行的程序，只要启动之后就会一直监听apiserver。获取报文中的字段：spec中的nodeName字段
创建pod时，为每个pod创建一个binding，表示该往哪个节点上部署
创建pod到节点时，有两个策略
先执行预算策略，在执行优先策略。这两步的操作都必须成功，否则立刻返回报错
部署的node必须满足这两个策略，少一个都不行
2、预算策略：predicate 自带一些算法，选择node节点，是scheduler自带的算法策略，不需要人工干预
podfitsresources：pod的适应策源，检查节点上剩余的资源是否满足pod请求的资源（主要是CPU和内存）podfitshost：po适应主机，如果pod指定了node的name，检测主机名是否存在，如果存在要和pod指定的名称匹配，这才能调度过去podselectormarches：pod选择器匹配，创建pod的时候，可以根据node'节点的标签来进行匹配。他查找指定的node节点上标签是否存在。存在的标签是否匹配nodeskconflict：无磁盘冲突，确保已挂载的卷和pod卷不发生冲突。除非目录是只读 如果预算策略不满足，pod将始终处于pending状态，不断重试调度，直到节点满足条件为止
若三个node节点都满足——&gt;优选策略
3、优先策略： 3.1、leastrequestedpriority： 最低请求优先级，通过算法计算节点上的CPU和内存使用率，确定节点的权重
使用率越低的节点，相应的权重就越高。调度时会更倾向于这些使用率低的节点。实现资源合理的利用
3.2、balanceresourceallocation： 平衡资源分配，算CPU和内存的使用率，给节点赋予权重。权重算的是CPU和内存使用率接近，权重越高。
和上面的最低请求优先级一起使用
举例：
node1 CPU和内存使用率：20 60
node2 CPU和内存使用率：50 50
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a26517dfafdd7753ef709cc37078ad47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1e8a0266aa05a5d7a893cc9c3d9155b/" rel="bookmark">
			网络安全之文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见文件上传点 大部分的网站和应用系统都有上传功能，如用户头像上传，图片上传，文档上传等。
任意文件上传漏洞 定义 由于对上传文件未作过滤或过滤机制不严 (文件后缀或类型)导致恶意用户可以上传脚本文件，通过上传文件可达到控制网站权限的目的
危害 攻击者可获得网站控制权限
查看、修改、删除网站数据
通过提权漏洞可获得主机权限
webshell 定义 Webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。
方式 利用文件上传漏洞，通过向服务端提交一句简短代码，配合本地客户端实现webshell功能。
所需条件 满足这三个条件，攻击者就能够成功入侵：
木马上传成功，未被杀；
知道木马的路径在哪；
上传的木马能正常运行 (解析)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ffbef1fd5aeb02d6600584f12b7f5a1/" rel="bookmark">
			设计模式的艺术P1基础—2.4-2.11 面向对象设计原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式的艺术P1基础—2.4-2.11 面向对象设计原则
2.4 面向对象设计原则概述
向对象设计的目标之一在于支持可维护性复用，一方面需要实现设计方案或者源代码的重用，另一方面要确保系统能够易于扩展和修改，具有较好的灵活性。
面向对象设计原则也是用于评价一个设计模式的使用效果的重要指标之一。
表2-2　7种常用的面向对象设计原则
2.5　单一职责原则
单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。
单一职责原则（Single Responsibility Principle，SRP）：一个类只负责一个功能领域中的相应职责。或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。
将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中；如果多个职责总是同时发生改变，则可将它们封装在同一类中。
一个简单实例：
针对某CRM（Customer Relationship Management，客户关系管理）系统中客户信息图形统计模块提出了如图2-13所示的初始设计方案结构图。
CustomerDataChart类中的方法说明如下：getConnection（）方法用于连接数据库，findCustomers（）方法用于查询所有的客户信息，createChart（）方法用于创建图表，displayChart（）方法用于显示图表。
现使用单一职责原则对其进行重构，CustomerDataChart类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。无论是修改数据库连接方式，还是修改图表显示方式，都需要修改该类，它拥有不止一个引起它变化的原因，违背了单一职责原则。
因此需要对该类进行拆分，使其满足单一职责原则。类CustomerDataChart可拆分为如下3个类。
（1）DBUtil：负责连接数据库，包含数据库连接方法getConnection（）。
（2）CustomerDAO：负责操作数据库中的Customer表，包含对Customer表的增／删／改／查等方法，如findCustomers（）。
（3）CustomerDataChart：负责图表的生成和显示，包含方法createChart（）和displayChart（）。
2.6 开闭原则
开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。
开闭原则（Open-Closed Principle，OCP）：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。
在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。
为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。
在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。
在对每个模式进行优缺点评价时，都会将开闭原则作为一个重要的评价依据，以判断基于该模式设计的系统是否具备良好的灵活性和可扩展性。
2.7　里氏代换原则
里氏代换原则（Liskov SubstitutionPrinciple，LSP）：所有引用基类（父类）的地方必须能透明地使用其子类的对象。
里氏代换原则表明，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。
例如，我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；
里氏代换原则是实现开闭原则的重要方式之一。由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。
2.8　依赖倒转原则
如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。
依赖倒转原则（Dependency Inversion Principle，DIP）：抽象不应该依赖于细节，细节应该依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。
依赖倒转原则要求在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。
为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。
在实现依赖倒转原则时，需要针对抽象层编程，而将具体类的对象通过依赖注入（Dependency Injection，DI）的方式注入其他对象中。
依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有3种：构造注入、设值注入（Setter注入）和接口注入。
一个简单实例来加深对开闭原则、里氏代换原则和依赖倒转原则的理解：
该系统经常需要将存储在TXT或Excel文件中的客户信息转存到数据库中，因此需要进行数据格式转换。
在客户数据操作类中将调用数据格式转换类的方法实现格式转换和数据库插入操作，初始设计方案结构如图：
发现该设计方案存在一个非常严重的问题，由于每次转换数据时数据来源不一定相同，因此需要更换数据转换类，如有时需要将TXTDataConvertor改为ExcelDataConvertor。此时，需要修改CustomerDAO的源代码，而且在引入并使用新的数据转换类时也不得不修改CustomerDAO的源代码，系统扩展性较差，违反了开闭原则。
由于CustomerDAO针对具体数据转换类编程，因此在增加新的数据转换类或者更换数据转换类时都不得不修改CustomerDAO的源代码。可以通过引入抽象数据转换类解决该问题。在引入抽象数据转换类DataConvertor之后，CustomerDAO针对抽象类DataConvertor编程。
更换具体数据转换类时无须修改源代码，只需要修改配置文件；如果需要增加新的具体数据转换类，只要将新增数据转换类作为DataConvertor的子类并修改配置文件即可，原有代码无须做任何修改，满足开闭原则。重构后的结构如图：
在大多数情况下，这3个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段。
2.9　接口隔离原则
接口隔离原则（Interface Segregation Principle，ISP）：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。
根据接口隔离原则，当一个接口太大时，需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。
1）当把“接口”理解成一个类型所提供的所有方法特征的集合时，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫作“角色隔离原则”。
2）如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。
实例：针对某CRM系统的客户数据显示模块设计了如图2-17所示的CustomerDataDisplay接口。其中，方法readData（）用于从文件中读取数据；方法transformToXML（）用于将数据转换成XML格式；方法createChart（）用于创建图表；方法displayChart（）用于显示图表；方法createReport（）用于创建文字报表；方法displayReport（）用于显示文字报表。
由于在接口CustomerDataDisplay中定义了太多方法，即该接口承担了太多职责。一方面导致该接口的实现类很庞大，在不同的实现类中都不得不实现接口中定义的所有方法，灵活性较差，如果出现大量的空方法，将导致系统中产生大量的无用代码，影响代码质量；另一方面由于客户端针对大接口编程，将在一定程度上破坏程序的封装性，客户端看到了不应该看到的方法，没有为客户端定制接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ffbef1fd5aeb02d6600584f12b7f5a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5f3b17c6a62e277d7fd3783bbc9f41b/" rel="bookmark">
			设计模式的艺术P1基础—2.3 类之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式的艺术P1基础—2.3 类之间的关系
在软件系统中，类并不是孤立存在的，类与类之间存在各种关系。对于不同类型的关系，UML提供了不同的表示方式
1．关联关系
关联（Association）关系是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系，如汽车和轮胎、师傅和徒弟、班级和学生等。在UML类图中，用实线连接有关联关系的对象所对应的类。
在使用类图表示关联关系时可以在关联线上标注角色名，一般使用一个表示二者之间关系的动词或者名词表示角色名（有时该名词为实例对象名），关系的两端代表两种不同的角色。
如在一个登录界面类LoginForm中包含一个JButton类型的注册按钮loginButton，它们之间可以表示为关联关系。
1）双向关联
默认情况下，关联是双向的。例如，顾客（Customer）购买商品（Product）并拥有商品，反之，卖出的商品总有某个顾客与之相关联。
2）单向关联
类的关联关系也可以是单向的，在UML中单向关联用带箭头的实线表示。例如，顾客（Customer）拥有地址（Address），则Customer类与Address类具有单向关联关系
3）自关联
在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。例如，一个节点类（Node）的成员又是节点Node类型的对象
4）多重性关联
多重性关联关系又称为重数性（Multiplicity）关联关系，表示两个关联对象在数量上的对应关系。
如，一个界面（Form）可以拥有零个或多个按钮（Button），但是一个按钮只能属于一个界面，因此，一个Form类的对象可以与零个或多个Button类的对象相关联，但一个Button类的对象只能与一个Form类的对象关联。
5）聚合关系
聚合（Aggregation）关系表示整体与部分的关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。
在UML中，聚合关系用带空心菱形的直线表示。
例如，汽车发动机（Engine）是汽车（Car）的组成部分，但是汽车发动机可以独立存在，因此，汽车和发动机是聚合关系
6）组合关系
组合（Composition）关系也表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期。一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有同生共死的关系。在UML中，组合关系用带实心菱形的直线表示
例如，人的头（Head）与嘴巴（Mouth），嘴巴是头的组成部分之一，而且如果头没了，嘴巴也就没了，因此头和嘴巴是组合关系，如图2-8所示。
2．依赖关系
依赖（Dependency）关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。
例如，驾驶员开车，在Driver类的drive（）方法中将Car类型的对象car作为一个参数传递，以便在drive（）方法中能够调用Car类的move（）方法，且驾驶员的drive（）方法依赖车的move（）方法，因此类Driver依赖类Car
3．泛化关系
泛化（Generalization）关系也就是继承关系，用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。在UML中，泛化关系用带空心三角形的直线来表示。
在Java语言中使用extends关键字。
例如，Student类和Teacher类都是Person类的子类，Student类和Teacher类继承了Person类的属性和方法，Person类的属性包含姓名（name）和年龄（age），每一个Student和Teacher也都具有这两个属性。
4．接口与实现关系
在接口中，通常没有属性，而且所有的操作都是抽象的，只有操作的声明，没有操作的实现。
UML中用与类的表示法类似的方式表示接口。（接口的类图，左上角有一个空心圆+短线）
接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现（Realization）关系。
在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。
如，定义了一个交通工具接口Vehicle，包含一个抽象操作move（），在类Ship和类Car中都实现了该move（）操作。
如在Java语言中使用implements关键字，而在C＃中使用冒号“：”来实现
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/193b35efd5183ef445bc4828b9adeadb/" rel="bookmark">
			设计模式的艺术P1基础—2.2 类与类的UML图示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式的艺术P1基础—2.2 类与类的UML图示
在UML 2.0的13种图形中，类图是使用频率最高的两种UML图之一（另一种是用于需求建模的用例图），它用于描述系统中所包含的类以及它们之间的相互关系，帮助人们简化对系统的理解，是系统分析和设计阶段的重要产物，也是系统编码和测试的重要模型依据。
在设计模式中，可以使用类图来描述一个模式的结构并对每一个模式实例进行分析。
类（Class）封装了数据和行为，是面向对象的重要组成部分，它是具有相同属性、操作、关系的对象集合的总称。
在系统中，每个类都具有一定的职责。职责指的是类要完成什么样的功能，要承担什么样的义务。一个类可以有多种职责，设计得好的类一般只有一种职责。在定义类的时候，将类的职责分解成为类的属性和操作（即方法）。
类的属性即类的数据职责，类的操作即类的行为职责。设计类是面向对象设计中最重要的组成部分，也是最复杂和最耗时的部分。
在软件系统运行时，类将被实例化成对象（Object），对象对应于某个具体的事物，是类的实例（Instance）。
类图（Class Diagram）是用出现在系统中的不同类来描述系统的静态结构，主要用来描述不同的类以及它们之间的关系。
在UML中，类使用包含类名、属性和操作且带有分隔线的长方形来表示，如定义一个Employee类，它包含属性name、age和email，以及操作modifyInfo（）。
在UML类图中，类一般由三部分组成。
（1）类名：每个类都必须有一个名字，类名是一个字符串。
（2）类的属性（Attributes）：属性是指类的性质，即类的成员变量。一个类可以有任意多个属性，也可以没有属性。
UML规定操作的表示方式为：
可见性 名称：类型[ = 默认值]
可见性在类图中分别用符号+、-和＃表示。
默认值”是一个可选项，即属性的初始值。
（3）类的操作（Operations）：操作是类的任意一个实例对象都可以使用的行为，是类的成员方法。
UML规定操作的表示方式为：
可见性 名称([参数列表])[：返回类型]
④“返回类型”是一个可选项，表示方法的返回值类型，依赖于具体的编程语言，可以是基本数据类型，也可以是用户自定义类型，还可以是空类型（void）。如果是构造方法，则无返回类型
在本书中，名词“操作（Operation）”“方法（Method）”与“函数（Function）”同义。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c02f2da907aa436e56e1e35d45d235cc/" rel="bookmark">
			【FPGA】分享一些FPGA入门学习的书籍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做FPGA工程师的这些年，买过好多书，也看过好多书，分享一下。
后续会慢慢的补充书评。
【FPGA】分享一些FPGA入门学习的书籍【FPGA】分享一些FPGA协同MATLAB开发的书籍 【FPGA】分享一些FPGA视频图像处理相关的书籍 【FPGA】分享一些FPGA高速信号处理相关的书籍【FPGA】分享一些FPGA数字信号处理相关的书籍【FPGA】分享一些FPGA进阶学习的书籍 FPGA设计技巧与案例开发详解 韩彬,于潇宇,张雷鸣著 电子工业出版社 978712
数字逻辑基础与Verilog设计（原书第3版）
FPGA软件测试与评价技术
你好FPGA：一本可以听的入门书
FPGA设计技巧与案例开发详解（第2版）
深入浅出玩转FPGA(第3版)【博客藏经阁丛书】
FPGA设计实战演练（高级技巧篇）
电子设计与嵌入式开发实践丛书：FPGA设计实战演练（逻辑篇）
FPGA深度解析出版时间：2015-05-01
博客藏经阁丛书：那些年，我们拿下了FPGA
手把手教你学FPGA设计——基于大道至简的至简设计法
DSP/FPGA嵌入式实时处理技术及应用
Xilinx FPGA数字设计：从门级到行为级双重HDL描述（立体化教程）
Verilog HDL与FPGA数字系统设计/高等院校电子信息与电气学科系列规划教材
Xilinx FPGA高速串行传输技术与应用
例说FPGA：可直接用于工程项目的第一手经验
四则运算小计算器设计过程实录：Verilog FPGA数字系统设计入门学习日
Vivado从此开始 FPGA
基于FPGA的数字图像处理原理及应用
FPGA硬件软件开发及项目开发
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fb933a54a4a9f260af3ac93e1ee9173/" rel="bookmark">
			2024 年 20&#43; 个 Node.js 开发工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024了，你准备好提升你的Node.js开发体验了吗？有了合适的工具集，你可以将你的项目提升到新的高度，简化你的工作流程，创建强大的、高性能的应用程序。这篇全面的指南将向你介绍Node.js开发的顶级工具，提供使用Node.js开发最佳工具提升工作流程的技巧，并提供资源帮助你跟上Node.js开发世界不断变化的最新最佳实践。让我们探索Node.js开发的必备工具并深入了解吧！
主要内容 探索2024年Node.js开发的关键工具，包括Express.js、Webpack和Mocha.js。了解Visual Studio Code扩展、调试工具和性能监控以提升你的工作流程。深入了解如何选择正确的工具集，并跟上Node.js项目成功的最佳实践。 顶级Node.js开发工具 Node.js已经成为软件开发领域的重要部分，因其使用JavaScript创建服务器端应用程序的能力而受到赞誉。根据Stack Overflow开发者调查2023，Node.js在网络开发中的流行度排名第二，这证明了它的影响力和多功能性。我们现在将深入探讨旨在简化你的工作流程、节省时间和帮助构建强大、高效应用程序的顶级Node.js开发工具。
一些可用的开发工具包括：
Express.jsWebpackMocha.jsChaiPM2Passport.jsBabelElectrode.ioSinon.JS 这些工具服务于各种目的，从网络应用框架和模块打包器到测试套件和身份验证中间件。这些基本的Node.js工具，以及其他必要的JavaScript工具，使你能够同时在服务器和客户端开发应用程序，利用JavaScript确保无缝的开发体验。
无论你是经验丰富的Node.js开发者还是JavaScript世界的新手，拥有正确的工具可以产生天壤之别。在接下来的小节中，我们将详细研究这些顶级Node.js开发工具，讨论它们的功能、优点以及它们在构建强大、高效应用程序中的使用。
Express.js Express.js是Node.js的广泛使用的网络框架，非常适合创建服务器端应用程序和API。将Node.js和Express.js结合起来，你可以开发一个全面的JS应用程序，其中Node.js管理服务器端组件，而Express.js负责网站应用程序的部署。
它作为一个极简的网络框架的流行度，使其成为构建服务器端应用程序和API的理想选择，而官方Express.js网站提供的全面文档确保你将获得所有需要的指导。
Webpack Webpack是一个流行的JavaScript模块打包器，通常用于：
打包用于浏览器的JavaScript文件优化资产加载简化前端开发提升用户体验减少开发者的工作量 为了利用Webpack的力量，你可以使用其命令行界面来编译用于浏览器应用程序的JavaScript文件，确保你的代码被优化以获得最大的性能。你可以查看我们的 Webpack初学者指南。
Mocha Mocha 是一个用于Node.js的快速和多功能的测试套件，提供对单元和集成测试、测试驱动开发(TDD)和行为驱动开发(BDD)的支持。它允许你在控制台和浏览器中运行测试，使其适用于各种JS项目。
Mocha.js与一系列JavaScript框架兼容，如Chai、Sinon和Should.js，确保你有灵活性选择适合你项目的正确测试工具。你可以查看我们的Mocha和Chai指南。
Chai Chai 是一个用于Node.js的测试驱动开发(TDD)和行为驱动开发(BDD)断言框架，可以与任何测试框架，如Mocha.js，一起用于应用开发。Chai提供了各种插件，包括chai-as-promised、chai-subset和chai-things，让你能够根据你的特定需求定制你的测试体验。
通过在你的测试过程中使用Chai，你可以确保你的Node.js应用程序是可靠的、高效的，并且没有错误。
PM2 PM2 是一个基于Node.js的框架和生产过程管理器，为Node.js应用程序提供了内置的负载均衡器。它允许你以集群模式运行应用程序，同时生成多个CPU核心的进程，并通过“热重载”选项在零停机时间内更新应用程序。
通过将PM2与平台即服务(PaaS)提供商集成，你可以利用以下功能：
云基础设施网络存储操作系统中间件运行时环境第三方API集成 总的来说，PM2是优化Node.js应用程序的过程管理的出色工具。
Passport.js Passport.js 是Node.js的身份验证中间件，通过提供大量的身份验证方法，简化了用户身份验证，包括：
用户名和密码模型通过Facebook登录通过Google登录通过Twitter登录 Passport的灵活性和模块化允许无缝集成到基于Express的网络应用程序中，使其成为构建安全、强大应用程序的无价工具。
我们在这里有一个很好的Passport教程。
Babel Babel 是一个JavaScript编译器，允许你在项目中使用最新的ECMAScript 2015+特性，同时也编译你的代码以与旧版浏览器兼容。将Babel纳入你的开发过程有助于编写兼容所有浏览器的现代JavaScript代码，即使是旧版本，从而确保你的用户获得最佳体验。
要开始使用Babel，你可以安装Babel命令行接口(CLI)，并运行babel src -d lib命令将源代码从src目录编译到lib目录。
请查看我们的Babel初学者指南。
Electrode.io Electrode.io 是沃尔玛实验室开发的一个开源应用平台，它有助于以有组织的方式构建大规模的、通用的React/Node.js应用程序。通过提供最佳实践、标准化结构和现代技术，Electrode.io使你能够轻松创建强大的、可扩展的应用程序。
Electrode.io提供的一些特性包括Electrode Explorer和Electrify，它们有助于简化你的开发过程，并确保你的应用程序达到最高标准。
Sinon.JS Sinon.JS 是一个跨浏览器的、独立的测试框架，支持JavaScript的stubs、spies和mocks，兼容任何测试框架。通过简化测试过程和提供能够替代测试中更具挑战性的部分的能力，Sinon.JS使你能够有信心创建强大、高效的应用程序。
无论你是在进行小项目还是大规模应用程序的开发，Sinon.JS都是确保你的代码质量和可靠性的宝贵工具。
提升你的Node.js工作流程 优化你的Node.js工作流程对于高效和有效的开发至关重要。通过使用正确的工具和技术，你可以简化你的开发过程，减少完成任务所需的时间，并确保你的代码优化了性能。
在接下来的部分，我们将研究Visual Studio Code扩展、调试工具和性能监控工具，所有这些都旨在优化你的Node.js工作流程，并帮助在开源运行时环境中创建优越的应用程序。
Visual Studio Code扩展 Visual Studio Code 是Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fb933a54a4a9f260af3ac93e1ee9173/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35b60419d1f83112729733a9ff9ff8a8/" rel="bookmark">
			亲测有效：腾讯云免费服务器30天申请流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云免费服务器申请入口 https://curl.qcloud.com/FJhqoVDP 免费服务器可选轻量应用服务器和云服务器CVM，轻量配置可选2核2G3M、2核8G7M和4核8G12M，CVM云服务器可选2核2G3M和2核4G3M配置，腾讯云百科txybk.com分享2024年最新腾讯云免费服务器申请入口、限制条件：
腾讯云免费服务器申请入口 腾讯云免费中心：https://curl.qcloud.com/FJhqoVDP 活动打开如下图：
腾讯云免费服务器申请
腾讯云百科整理了免费云服务器配置和免费时长对照表：
免费服务器CPU/内存/公网带宽用户类型免费时长轻量应用服务器2核2G3M个人认证免费1个月轻量应用服务器2核8G7M企业认证免费1个月轻量应用服务器4核8G12M不限个企免费1个月云服务器CVM2核2G3M个人认证免费1个月云服务器CVM2核4G3M企业认证免费1个月 申请限制条件 申请腾讯云免费服务器是有条件的，必须是云服务器产品新用户。简单来说，就是你的腾讯云账户之前没有购买过或申请过云服务器的用户，云服务器包括CVM和轻量应用服务器。假设我的腾讯云账号A，之前申请过免费服务器，则不可以再申请；假设我的腾讯云账号之前买过服务器，那么也不可以再申请免费服务器。
腾讯云新账户包括个人实名和企业实名认证，无论是个人和公司账号均可以申请对应的云服务器配置。
免费到期续费说明 腾讯云免费服务器仅提供1个月免费时长，到期后如果继续使用需要续费，续费可以享受原价3.5折的优惠折扣。如果需要长时间使用，腾讯云百科建议直接购买特价云服务器，活动 https://curl.qcloud.com/oRMoSucP 活动打开如下图：
腾讯云轻量应用服务器优惠价格表2024更新
轻量2核2G3M优惠价62元一年、2核2G4M价格118元，3年540元、2核4G5M带宽218元一年、3年756元，所以直接购买比先免费试用1个月，再续费要划算得多。
免费云服务器备案限制说明 想要在腾讯云备案，云服务器时长至少要3个月，所以1个月的免费云服务器是无法备案的。
以上是腾讯云百科txybk.com分享的腾讯云免费服务器申请入口、限制条件说明，详细请以官方页面为准 https://curl.qcloud.com/FJhqoVDP
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca6d2a4ba4f94eba5f717cbefe79372c/" rel="bookmark">
			吃透这68个 Python 内置函数，你的 Python 基础就算非常扎实了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内置函数就是Python给你提供的, 拿来直接用的函数，比如print，input等。
截止到python版本3.6.2 ，一共提供了68个内置函数，具体如下👇
abs() dict() help() min() setattr() all() dir() hex() next() slice() any() divmod() id() object() sorted() ascii() enumerate() input() oct() staticmethod() bin() eval() int() open() str() bool() exec() isinstance() ord() sum() bytearray() ﬁlter() issubclass() pow() super() bytes() ﬂoat() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() __import__() complex() hasattr() max() round() delattr() hash() memoryview() set() 本文将这68个内置函数综合整理为12大类，正在学习Python基础的读者一定不要错过，建议收藏学习！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca6d2a4ba4f94eba5f717cbefe79372c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abf2aac25e13dd04da23d58ed31d7bee/" rel="bookmark">
			【书生·浦语大模型实战营02】《轻松玩转书生·浦语大模型趣味Demo》学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《轻松玩转书生·浦语大模型趣味Demo》 教程文档：《轻松玩转书生·浦语大模型趣味 Demo·文档》
致谢 感谢助教 MING·X 的帮助～
1、InternLM-Chat-7B 智能对话：生成 300 字的小故事 本节中我们将使用InternLM-Chat-7B 模型部署一个智能对话 Demo。
1.1 环境准备 在InternStudio平台中选择 A100(1/4) 的配置，镜像选择 Cuda11.7-conda，选择的配置如下图所示：
申请成功后，可以看到开发机的状态，
然后点击【进入开发机】；
从本地克隆包含pytorch2.0.1的环境 conda create --name internlm-demo --clone=/root/share/conda_envs/internlm-base 激活环境 conda activate internlm-demo 2、熟悉 hugging face 下载功能，使用 huggingface_hub python 包，下载 InternLM-20B 的 config.json 文件到本地 2.1 设置国内镜像源 export HF_ENDPOINT=https://hf-mirror.com Note：更多信息请访问 hf-mirror.com - Huggingface 镜像站。
3、在激活conda环境之前执行bash命令 3.1 Q：为什么要在激活环境前执行bash呢？ 我们猜测有以下几个可能的原因；
原因一：初始化环境变量和设置 新的 Bash 实例会读取并执行 ~/.bashrc 文件，从而进行对特定的环境变量进行设置；
原因二：清晰的会话开始 在一些情况下，可能想要一个干净的、未受之前命令影响的shell环境。执行 bash 命令可以提供一个新的、干净的工作环境。
南溪：这个效果有点像恢复出厂设置；
ChatGPT4：将 bash 命令比作“手机上的恢复出厂设置”是一个有趣的类比，但它们之间还是有一定的差异；执行 bash 命令会给你一个新的、未受之前会话影响的命令行环境，但它不会对你的整个系统或用户数据进行重置。它更像是打开一个新的、未受旧会话影响的页面，而不是完全把整个“书”恢复到原始状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abf2aac25e13dd04da23d58ed31d7bee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77fa3acabc22d448d17007303bfe40dd/" rel="bookmark">
			React Hooks的useState、useRef使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React Hooks 是 React 16.8 版本引入的新特性，它允许你在不编写 class 的情况下使用 state 和其他 React 特性。其中，useState 和 useRef 是两个常用的 Hooks。
1. useState
useState 是一个允许你在函数组件中添加 state 的 Hook。
使用说明：
useState 返回一个状态变量和一个设置该变量的函数。如果传递给 useState 的初始值是 undefined，则返回的状态变量初始值为 undefined。你可以在组件的任何地方调用 useState，但通常建议在组件的顶层调用它。 代码示例：
import React, { useState } from 'react'; function Example() { // 声明一个初始值为 "A" 的状态变量 name const [name, setName] = useState('A'); return ( &lt;div&gt; &lt;p&gt;Hello, my name is {name}.&lt;/p&gt; &lt;button onClick={() =&gt; setName('B')}&gt;Change Name&lt;/button&gt; &lt;/div&gt; ); } 2. useRef
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77fa3acabc22d448d17007303bfe40dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bcfd4106460e8bb0938dba6ece705de/" rel="bookmark">
			国科大计算机体系结构期末考试——停更，手写更快
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题型一、第二章的画图 给一个逻辑表达式，画出晶体管级别的电路图 cmos电路的基本电路： 与非门的功能是对多个输入信号进行逻辑与操作，然后对结果进行取反。
或非门的功能是对多个输入信号进行逻辑或操作，然后对结果进行取反。
非门（NOT gate），也称为反相器（inverter）
将表达式用CMOS支持的门表示 所以与门有两级延迟，因为
与门需要用与非门和非门串联实现
或门需要用或非门和非门串联实现
上图中重要的这一条，AB的与的非等于AB分别取非然后或，相当于非 把括号里面的东西都非了一遍
AB的或的非，等于AB分别非的与
怎么画 难道这样表示
如果是反向n管变成p管，串联变成并联，接地GND变成接入VDD，
都是N管接地，P管接电
正反逻辑串联等于整个表达式的非
如上图，下面一半是N管的表达，上面一半是P管的表达，正反逻辑串联起来，得到表达式的非 两级与非表达与或 例子 这个用了8个晶体管，因为
是这个与非门的电路图
题型二、 第二章触发器相关计算（较难，可能不考）给出一个触发器，然后给出延迟 2.1 RS触发器 nc表示not care 不关心状态
R表示reset,S表示Setup
RS触发器组合形成D触发器 C为时钟，D是数据，个人感觉C的意思更像是Control，控制
意思是，在C等于1的时候，D能把值传递给Q，如果C=0，S和R一直等于1，原来的值不变
这是一个非门，不是二极管！！
相关参数理解和计算 之前写verilog在FPGA上仿真就碰到过这个情况，上升沿来了，但是值没有存好，今天正好看看
setup time: 里面（这样下一回合时钟过来从1变零的时候，触发锁存锁的就是正确的值），因为后面C变成0之后，就不能再存数据了。D的值在被采集采集完毕之前，需要setup坚挺的时间,我的理解是需要的采集到第一个Q的需要的时间。
hold time: 想要稳定采集到D之前的值，那么在时钟的下降沿（因为图中的C端没有接反相器，是下降沿触发储存D的数据）之后的一段时间内，D不能变化，因为控制信号沿着下图所示路径到达与或们需要时间，如果是下降沿触发，C端还需要一个反相器，延迟就从0变成一个反相器的延迟，两个门的延迟
clock to q: 是在下图
触发器的延迟等于setuptime + clock to q,但是也要保持住hold time
给C增加一个反相器，hold time 加一级， setup 就可以减一级，clock to q 增加一级
这个传输门算是一个二极管，不过选择的是高低电平是否能通过
Tlh,time from low to high 时间从低到高
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7233d202ff4d9ce13ac0f58ee0c0db6/" rel="bookmark">
			二叉树 | 二叉树的前序遍历问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树的前序遍历问题描述 提供二叉树的根节点 root ，返回它节点值的 前序 遍历。
二叉树的前序遍历是一种深度优先遍历（DFS）的方式，其遍历顺序为：先访问根节点，然后递归地对左子树进行前序遍历，最后递归地对右子树进行前序遍历。
二叉树的定义 在Java中，二叉树的定义可以通过一个类表示。以下是一个简单的二叉树节点类的定义：
public class TreeNode { int val; TreeNode left; TreeNode right; public TreeNode(int val) { this.val = val; } } 使用这个定义，可以构建任意形状的二叉树，例如：
/* * 示例二叉树: * 1 * / \ * 2 3 * / \ * 4 5 */ TreeNode root = new TreeNode(1); root.left = new TreeNode(2); root.right = new TreeNode(3); root.left.left = new TreeNode(4); root.left.right = new TreeNode(5); 这样，通过创建不同的TreeNode实例，并连接它们的left和right引用，可以构建出具体的二叉树结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7233d202ff4d9ce13ac0f58ee0c0db6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b4881d8a9b9b96f218471976f075142/" rel="bookmark">
			Python 可视化 web 神器：streamlit、Gradio、dash、nicegui
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网：https://streamlit.io/
github：https://github.com/streamlit/streamlit
API 参考：https://docs.streamlit.io/library/api-reference
最全 Streamlit 教程：https://juejin.cn/column/7265946243196436520
Streamlit-中文文档：https://github.com/wanghanbinpanda/Streamlit-Documentation-Chinese/blob/main/README.md
Gradio、Streamlit、Dash、nicegui 框架对比：Gradio、Streamlit 和 Dash：https://zhuanlan.zhihu.com/p/611828558
在机器学习领域，针对已经训练好的模型创建一个快速的 Demo 通常是必要的，下面是快速创建机器学习应用的几个框架：gradio、streamit 和 dash 进行简单的对比。
gradiostreamitdash主要使用场景可交互小 Demo工作流、DashBoardDashBoard、生产环境的复杂演示应用上手难度简单简单中等组件丰富度低高高综合扩展性低中高Jupyter Notebook 内支持是否是是否完全开源是是部分企业级功能未开源github stars13.4k23.1k18.2k案例列表GitHub - gradio-app/awesome-demos: links and status of cool gradio demosApp Gallery • StreamlitDash Enterprise nicegui
官网：https://nicegui.io/
github：https://github.com/zauberzeug/nicegui/
nicegui 中文文档：nicegui-reference-cn：https://zhuanlan.zhihu.com/p/661187865
在 Python 3.10 及更高版本中，collections模块被重构，MutableMapping 已经被弃用。
安装：pip install nicegui
NiceGUI 基于FastAPI，封装了Quasar、Vue、Tailwind CSS、AG Grid、ECharts等，可以用来快速开发web或桌面程序。
1、streamlit 简介 streamlit 简介 Streamlit 是Python可视化 web 神器 ，是一个开箱即用的工具集，可以让开发者免于学习繁杂的前端知识，仅需几行代码就可以轻松、快速的构建一个简洁、优雅、令人惊叹的可视化 web app 应用。用于机器学习、数据可视化。当快速搭建一个 web app 的时候 Streamlit 绝对是开发神器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b4881d8a9b9b96f218471976f075142/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0dbda3700b91df123d897c66a54469a/" rel="bookmark">
			vue 3.0 所采用的 Composition Api 和 vue 2.0 使用的 Option Api 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue 3.0 引入了 Composition API，这是对 Vue 2.0 中使用的 Options API 的一个补充。Composition API 提供了一种更灵活的方式来组织和重用组件逻辑，而 Options API 则更倾向于在组件实例中直接定义和操作数据和逻辑。
区别说明：
可重用性：在 Options API 中，我们通常在组件内部定义方法和计算属性，这使得它们与特定的组件紧密耦合，难以在其他地方重用。而 Composition API 通过使用 setup 函数和 ref、reactive 等 API，使得逻辑更加模块化，更容易在其他地方重用。逻辑复用：在 Options API 中，我们通常在 methods、computed 等选项中定义逻辑，这使得这些逻辑与特定的模板紧密耦合。而 Composition API 通过将逻辑抽取到 setup 函数中，使得模板和逻辑分离，逻辑可以在多个组件之间复用。逻辑的声明方式：在 Options API 中，我们通常在组件的 data、methods、computed 等选项中声明数据和方法。而在 Composition API 中，我们使用 ref、reactive 等 API 来声明响应式的数据，使用 computed API 来声明计算属性。API 风格：Options API 是一个更类似于对象字面量风格的 API，而 Composition API 则更类似于函数式编程风格的 API。 代码示例：
Options API (Vue 2.x):
export default { data() { return { count: 0, }; }, methods: { increment() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0dbda3700b91df123d897c66a54469a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52898892e186e87f3f3b0423b8726a3d/" rel="bookmark">
			消息队列-RockMQ-批量收发实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		批量收发实战 发送消息是需要网络连接的如果我们单条发送吞吐量可能没有批量发送好。剖来那个发送可以减少网络IO开销，但是也不能一批次发送太多的数据，需要根据每条消息的大小和网络带宽来确定量的数目。
比如网络带宽为可以支持一次性发送8M的数据包，如果数据包确定不会超过8M，那么我们可以除以每条消息的大小（粗略估算），然后会得到一个数值，这个数值再取70%-80%留一定的缓冲空间。
如果我们一次性发送的数据超过了8M，就需要对这些消息进行分组发送，保证每一组的数据大小不超过8M，每一组发送的数量逻辑也是按照前面这样来计算。
生产者
public class Producer { public static void main(String[] args) throws Exception { DefaultMQProducer producer = new DefaultMQProducer("producer_group"); producer.setNamesrvAddr("ip:9876"); producer.start(); List&lt;Order&gt; F = OrderBuilder.build(1, "A", "B", "C"); List&lt;Order&gt; S = OrderBuilder.build(2, "D", "Q"); List&lt;Order&gt; T = OrderBuilder.build(3, "N", "Q", "R"); ArrayList&lt;Order&gt; orders = new ArrayList&lt;Order&gt;() {{ addAll(F); addAll(S); addAll(T); }}; List&lt;Message&gt; msgs = new ArrayList&lt;&gt;(); for (Order order : orders) { Message msg = new Message("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52898892e186e87f3f3b0423b8726a3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4066c0be4357a993f074ada6d68ac57/" rel="bookmark">
			信号的互相关计算及时延估计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 信号的互相关计算 互相关反映向量x和移位（滞后）向量y之间的相似性。
最直观的解释是：互相关的作用是为了找到信号在哪一时刻与另一信号最像（另一信号为本身时就是自相关）！
滑动求互相关（图片来源：卓晴老师）
互相关和自相关在本质上是两个函数做内积运算。即向量内积的连续形式。其在线性空间角度上的意义是：一个向量在另一个向量上的投影，内积结果越大，投影越大，两个向量间夹角越小，方向越一致，相似度越高。
互相关（Cross-Correlation）计算公式：
f ( t ) ⊗ g ( t ) = ∫ − ∞ ∞ f ( τ ) g ( t + τ ) d τ f(t)\otimes g(t)=\int_{-\infty}^{\infty}f(\tau)g(t+\tau)d\tau f(t)⊗g(t)=∫−∞∞​f(τ)g(t+τ)dτ
离散形式：
f ( t ) ⊗ g ( t ) = ∑ − ∞ ∞ f ( t ) g ( t + τ ) d τ f(t)\otimes g(t)=\sum_{-\infty}^{\infty}f(t)g(t+\tau)d\tau f(t)⊗g(t)=−∞∑∞​f(t)g(t+τ)dτ
博主ccwcc给出的图片很形象的描述了这个计算过程。
注意： 如果x和y的长度不同，函数会在较短向量的末尾添加0，使其长度与另一个向量相同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4066c0be4357a993f074ada6d68ac57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa000019df1f542d9b042eb8a596f054/" rel="bookmark">
			【嵌入式移植】1、Ubuntu系统准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu系统准备 虚拟机与Ubuntu安装下载Ubuntu创建虚拟机系统配置 虚拟机与Ubuntu安装 嵌入式移植通常使用Linux操作系统的环境，使用Linux下的交叉编译工具链对BootLoader、kernel以及应用程序进行编译，然后下载运行。当然也可以通过各类IDE或者Windows下的交叉编译工具链进行。
可以直接使用带有Linux操作系统的电脑或者通过虚拟机运行Linux系统，毕竟目前世面上Windows操作系统用的人更多哈~。Ubuntu是一个以桌面应用为主的Linux发行版操作系统，可以使用VMware Workstations、ESXI或其它虚拟机方便地进行搭建。这里以ESXI为例安装ubuntu-22.04.2（推荐使用VMware Workstations，ESXI可能需要额外硬件设备）。
下载Ubuntu 可以在 Ubuntu中文网站或 Ubuntu镜像站中寻找国内镜像站进行下载，这里从 清华大学开源软件镜像站下载ubuntu-22.04.3（kernel-6.2）。
创建虚拟机 点击“虚拟机”，并点击左上角“创建/注册虚拟机”，在弹出的页面中选择“创建新虚拟机”，并点击下一页。
填写虚拟机名称，选择操作系统系列和版本。
点击“下一页”。
设置合适的硬件参数，主要为CPU核数、内存容量、硬盘容量等。
在“CD/DVD驱动器1”中选择“数据存储ISO文件”，并在弹出的界面中点击“上载”，选择下载的ubuntu-22.04.3 ISO文件上传至存储中，并点击选择。
最后确认参数设置并点击完成。
在新建的虚拟机上点击“打开电源”，开始ubuntu的安装，这里不再赘述。
系统配置 首先将IP地址设置为静态，方便后续远程登录，这里IP地址根据具体情况进行设置。
可以卸载一些用不到的组件
sudo apt remove thunderbir rhythmbox libreoffice* ... sudo apt autoremove 点击ubuntu镜像源右上角问号，复制
然后备份sources.list文件，并打开sources.list文件，将上述内容粘贴并保存，并安装可用更新
sudo cp /etc/apt/source.list /etc/apt/source.list.bak sudo gedit /etc/apt/sources.list ... sudo apt update sudo apt upgrade 安装OpenSSH，并检查服务器状态
sudo apt install openssh-server service ssh status 此时可以通过SSH进行远程登录（局域网内）。
本章完结撒花✿✿ヽ(°▽°)ノ✿
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a741da2a8ba28933dfbfa166c9ac4a8/" rel="bookmark">
			MySQL数据库添加索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL数据库添加索引： 在MySQL数据库中，通过添加索引可以提高查询性能，加速数据检索过程。下面是一些常见的方法来给MySQL数据库添加索引：
在创建表时添加索引： 当你创建表的时候，可以在字段定义后面直接添加索引，例如：
CREATE TABLE your_table ( id INT PRIMARY KEY, name VARCHAR(255), INDEX idx_name (name) ); 上述例子中，idx_name 是一个在 name 字段上的非唯一索引。
使用ALTER TABLE添加索引： 你也可以在已存在的表上使用 ALTER TABLE 语句添加索引：
ALTER TABLE your_table ADD INDEX idx_name (name); 或者，如果你想添加唯一索引：
ALTER TABLE your_table ADD UNIQUE INDEX idx_name (name); 添加主键索引： 通常，每个表都应该有一个主键索引。主键索引是唯一的，可以用来标识每一行。在创建表时，可以这样定义主键索引：
CREATE TABLE your_table ( id INT PRIMARY KEY, name VARCHAR(255) ); 或者在已存在的表上添加主键索引：
ALTER TABLE your_table ADD PRIMARY KEY (id); 添加全文索引： 如果你需要进行全文搜索，可以考虑使用全文索引。在创建表时，可以这样定义：
CREATE TABLE your_table ( id INT, content TEXT, FULLTEXT (content) ); 或者在已存在的表上添加：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a741da2a8ba28933dfbfa166c9ac4a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f022f5d7507028c7325293ffbc4da14/" rel="bookmark">
			JavaWeb——后端AOP面向特定方法编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		七、AOP 1. 概述 AOP（Aspect Oriented Programming）：面向切面编程、面向方法编程，其实就是面向特定方法编程
场景：
案例部分功能运行较慢，定位执行耗时较长的业务方法，此时需要统计每个业务方法的执行耗时，也就是我们想在方法前面或者后面执行一些操作记录操作日志权限控制事务管理 实现：
引入依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; 主流实现是动态代理。SpringAOP是Spring框架的高级技术，旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定方法进行编程——运行的就是代理对象
@Slf4j @Component @Aspect // AOP类 public class TimeAspect { // 加在哪些方法上 @Around("execution(* com.example.server.*.*(..))") // 切入点表达式 public Object recordTime(ProceedingJoinPoint jointPoint) throws Throwable { // 1. 记录开始时间 long begin = System.currentTimeMillis(); // 2. 调用原始方法运行 Object result = jointPoint.proceed(); // 3. 记录结束时间，计算方法执行耗时 long end = System.currentTimeMillis(); log.info(jointPoint.getSignature() + "方法耗时：{}ms", end - begin); return result; } } 核心概念：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f022f5d7507028c7325293ffbc4da14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12bb434ad359b17a949af214f3d3e162/" rel="bookmark">
			java 创建一个可执行的jar包小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1步：写好代码 public class Main { public static void main(String[] args) { String str = "hahah"; if (StringUtils.isBlank(str)) { System.out.println(str); } System.out.println("Hello world!"); } } 第2步：设置 Artifact 选择入口类
选中 extract to the ...表示：打完包后是一个jar包。
选中 copy to the output ... 表示：打完包后是一个jar包，外带你项目所用的jar包。
第3步：执行 Artifact 第4步：执行 jar 参考 java创建一个可执行的jar包小程序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74df2706a6292f60be9f506725dc4284/" rel="bookmark">
			​油烟净化器电源安全，保障健康餐饮生活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我最近分析了餐饮市场的油烟净化器等产品报告，解决了餐饮业厨房油腻的难题，更加方便了在餐饮业和商业场所有需求的小伙伴们。 随着人们生活水平的提高，餐饮业也得到了快速发展。然而，餐饮油烟污染也成为了人们关注的焦点。 油烟中含有大量的油脂、颗粒物、异味等有害物质，对人体健康和环境造成严重危害。餐饮油烟污染主要体现在以下几个方面：
对人体健康的危害 油烟中含有的油脂、颗粒物、异味等有害物质，会对人体呼吸道、消化道、心血管等系统造成损害。长期接触油烟，会增加患肺癌、心脏病、中风等疾病的风险。
对环境的危害 油烟排放到空气中，会形成光化学烟雾，对大气环境造成污染。光化学烟雾会对人体呼吸系统、眼睛等造成刺激，还会导致酸雨、雾霾等环境问题。
**油烟净化器是治理餐饮油烟污染的有效手段。**油烟净化器采用先进的净化技术，可以有效去除油烟中的有害物质，净化空气，改善环境。
电源安全是油烟净化器稳定运行的基石
油烟净化器是电器设备，其正常运行离不开稳定的电源。如果电源出现问题，会导致油烟净化器无法正常运行，甚至发生安全事故。
因此，油烟净化器的电源安全至关重要。在选购油烟净化器时，应选择具有过压、欠压、过载、短路等保护功能的油烟净化器，以确保电源安全。
油烟净化器电源安全的注意事项
在使用油烟净化器时，应注意以下几点：
使用合格的电源插座 油烟净化器的功率较大，应使用合格的电源插座。
避免电源线老化 电源线老化会导致电线绝缘层破损，容易发生短路等事故。
电源安全是油烟净化器稳定运行、发挥最佳净化效果的重要保障。希望广大消费者在选购和使用油烟净化器时，能够注意电源安全，共同打造健康、安全的餐饮环境。 ​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9715220a1dcd85cf4b82fd651add2f26/" rel="bookmark">
			在Spring Cloud Config Github配置中心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Spring Cloud系列我们其实讲解了很多，但是这里我们介绍一下Spring Cloud Config，它是一个解决分布式系统的配置管理方案，他包含了Client 和 Server 两个部分，server提供配置文件的存储，以接口的方式将配置文件内容提供出去，Client通过接口获取相关数据，并依据数据初始化自己的应用，Spring Cloud 使用git或者svn存放配置文件，默认情况下使用git。
我们第一步，在github上创建一个文件夹Springcloud-config用来存放配置文件，我们可以创建三配置文件，分别如下：
//开发环境 springcloud-config-dev.properties //测试环境 springcloud-config-test.properties //生产环境 springcloud-config-pro.properties 之后我们为每个配置文件都写一个springcloud.miaow,属性值分别是，你好，miaow-dev/test/pro。
springcloud: miaow: hello,miaow-dev springcloud: miaow: hello,miaow-test springcloud: miaow: hello,miaow-pro 这个是我们正常的开发逻辑，但是为了不一样，我采用我自己的方式进行，如下图所示我在gitee上进行
server端 pom.xml文件 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;springCloud&lt;/artifactId&gt; &lt;groupId&gt;com.miaow&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;spring-cloud-config-git&lt;/artifactId&gt; &lt;name&gt;spring-cloud-config-git&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9715220a1dcd85cf4b82fd651add2f26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84e7bb8417c9f6242c4bda7aa07cf5d1/" rel="bookmark">
			一分钟学会Python中pip的安装与使用..
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简单介绍 pip 是 Python 包管理工具，该工具提供了对Python 包的查找、下载、安装和卸载的功能，现在大家用到的所有包不是自带的就是通过pip安装的。Python 2.7.9 + 或 Python 3.4+ 以上版本都自带 pip 工具。
给出pip官网链接：https://pypi.org/project/pip/
二、下载安装 可以通过命令 pip --version 来判断是否已安装：
如果你还未安装，则可以使用以下方法来安装：
$ curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py # 下载安装脚本 $ sudo python get-pip.py # 运行安装脚本 三、最常用命令 1、显示版本和路径 pip --version
2、获取帮助 pip --help
3、升级 pip pip install -U pip
ps:升级需谨慎，经常看到pip提醒升级，然后输入命令回车，系统开始下载最新版安装包，
准备安装前卸载了旧版pip，然后新版又报错无法安装，只好又重装。
4、安装包 pip install SomePackage # 最新版本pip install SomePackage==1.0.4 # 指定版本pip install ‘SomePackage&gt;=1.0.4’ # 最小版本 比如我要安装sklearn，输入pip install sklearn，就会安装最新版本的包
5、升级包 pip install --upgrade SomePackage 升级指定的包，通过使用==, &gt;=, &lt;=, &gt;, &lt; 来指定一个版本号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84e7bb8417c9f6242c4bda7aa07cf5d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7047fc57b78ea8c281d0b78960d23fe0/" rel="bookmark">
			CSS全局样式中用了!important，如何修改局部样式（亲测有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当全局样式中使用了 !important 时，它会增加样式的优先级，使得其他具有相同选择器的规则难以覆盖。如果你想要修改局部样式，可以尝试以下方法：
提升选择器的特殊性： 增加选择器的特殊性是提高规则优先级的有效方法。通过在选择器中添加更多的 ID、类、或标签，使其特殊性增加。例如：
/* 全局样式 */ .example { color: red !important; } /* 局部样式，提升特殊性 */ .specific-container .example { color: blue; } 使用更具体的选择器： 使用更具体的选择器来覆盖全局样式，例如使用子选择器、后代选择器或其他组合选择器：
/* 全局样式 */ .example { color: red !important; } /* 局部样式，使用更具体的选择器 */ .specific-container .example { color: blue; } JavaScript 动态添加样式： 使用 JavaScript 动态地为局部元素添加样式，这样可以绕过全局样式：
// 在 Vue 组件中 export default { methods: { updateLocalStyle() { const element = this.$refs.localElement; // 获取局部元素的引用 element.style.color = 'blue'; // 动态添加样式 } } } 请注意，以上方法都是为了尽量避免使用 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7047fc57b78ea8c281d0b78960d23fe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e89adea7ff0a8d20d7c91fc37d2a1f0/" rel="bookmark">
			FPGA——时序分析与约束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FPGA时序分析与约束 FPGA结构基础数据传输模型Quartus II 时序报告Quartus II 中TimeQuest的操作实操 时序分析：通过分析FPGA内部各个存储器之间的数据和时钟传输路径，来分析数据延迟和时钟延迟的关系，保证所有寄存器都可以正确寄存数据。 数据和时钟传输路径是：由EDA软件，通过针对特定器件布局布线得到的。
时序约束：告知EDA软件，尽力达到约束指标。
FPGA结构基础 可编程逻辑功能结构
LUT 查找表的实现
fpga结构
内部连线：
采用行，列，局部的快速通道
数据传输模型 Tco :时钟上升沿到达D触发器 到 数据输出到Q端的延迟 。
Tsu: 建立时间，数据输入端D的数据必须提前 N ns 稳定下来，否则就没办法保存下来数据。
时钟偏斜原理：
在这个模型下：
Tclk1：时钟传到REG1有个延迟。
Tclk2：时钟传到REG2有个延迟。
Tco：触发器D 到Q输出的时间 。
Tdata：REG1的Q 传输到 REG2的D 的时间。
Tsu：建立时间。
Slack：余量时间。（下图是正的，说明可以正确读取到数据）
可以推导出公式，可以正确接收数据：
Tclk1+Tco+Tdata &lt;= Tclk(时钟周期) + Tclk2 - Tsu
化简得： Tclk +（Tclk2 - Tclk1 ）- Tco - Tdata - Tsu &gt;= 0
再得：Slack = Tclk + Tsnew - Tco - Tdata - Tsu &gt;= 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e89adea7ff0a8d20d7c91fc37d2a1f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49af6a0ac977f2df483c24bf979e95bf/" rel="bookmark">
			Spring事务控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.事务介绍 1.1什么是事务？ 当你需要一次执行多条SQL语句时，可以使用事务。通俗一点说，如果这几条SQL语句全部执行成功，则才对数据库进行一次更新，如果有一条SQL语句执行失败，则这几条SQL语句全部不进行执行，这个时候需要用到事务。
回顾一下数据库事务的四大特性ACID：
原子性：（Atomicity）
要么都执行，要么都不执行
一致性：（Consistency）
事务前后的数据都是正确的
隔离性：（Isolation）
事物之间相互隔离，互不干扰（并发执行的事务彼此无法看到对方的中间状态）
持久性：（Durability）
事务一旦提交不可再回滚 1.2数据库本身控制事物 begin transaction； //1.本地数据库操作：张三减少金额 //2.本地数据库操作：李四增加金额 rollback; 或 commit transation; 1.3jdbc中使用事物 1.获取对数据库的连接
2.设置事务不自动提交（默认情况是自动提交的）
conn.setAutoCommit(false); //其中conn是第一步获取的随数据库的连接对象。 3.把想要一次性提交的几个sql语句用事务进行提交
try{ Statement stmt = null; stmt =conn.createStatement(); stmt.executeUpdate(sql1); int a=6/0; stmt.executeUpdate(Sql2); . . . conn.commit(); //使用commit提交事务 } 4.捕获异常，进行数据的回滚（回滚一般写在catch块中）
catch（Exception e） { ... conn.rollback(); } 2.转账案例 2.1创建工程 2.2添加转账业务 2.2.1mapper package com.by.mapper; import com.by.pojo.User; import org.apache.ibatis.annotations.Param; public interface UserMapper { public void addUser(User user); void updateUserOutMoney(@Param("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49af6a0ac977f2df483c24bf979e95bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef6200c440cf48db6b2d8bb3d70e51c3/" rel="bookmark">
			手把手教你Python数据预处理，别说你还学不会！（附资源）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		凡事预则立，不预则废，训练机器学习模型也是如此。数据清洗和预处理是模型训练之前的必要过程，否则模型可能就「废」了。本文是一个初学者指南，将带你领略如何在任意的数据集上，针对任意一个机器学习模型，完成数据预处理工作。 数据预处理是建立机器学习模型的第一步（也很可能是最重要的一步），对最终结果有决定性的作用：如果你的数据集没有完成数据清洗和预处理，那么你的模型很可能也不会有效——就是这么简单。
人们通常认为，数据预处理是一个非常枯燥的部分。但它就是「做好准备」和「完全没有准备」之间的差别，也是表现专业和业余之间的差别。就像为度假做好事先准备一样，如果你提前将行程细节确定好，就能够预防旅途变成一场噩梦。
那么，应该怎么做呢？
本文将带你领略，如何在任意的数据集上，针对任意一个机器学习模型，完成数据预处理工作。
导入 让我们从导入数据预处理所需要的库开始吧。库是非常棒的使用工具：将输入传递给库，它则完成相应的工作。你可以接触到非常多的库，但在 Python 中，有三个是最基础的库。任何时候，你都很可能最终还是使用到它们。这三个在使用 Python 时最流行的库就是 Numpy、Matplotlib 和 Pandas。Numpy 是满足所有数学运算所需要的库，由于代码是基于数学公式运行的，因此就会使用到它。Maplotlib（具体而言，Matplotlib.pyplot）则是满足绘图所需要的库。Pandas 则是最好的导入并处理数据集的一个库。对于数据预处理而言，Pandas 和 Numpy 基本是必需的。
最适当的方式是，在导入这些库的时候，赋予其缩写的称呼形式，在之后的使用中，这可以节省一定的时间成本。这一步非常简单，可以用如下方式实现：
import numpy as np import matplotlib.pyplot as plt import pandas as pd 现在，可以通过输入如下语句读入数据集：
dataset = pd.read_csv('my_data.csv') 这个语句告诉 Pandas(pd) 来读入数据集。在本文中，我也附上数据集的前几行数据。
我们有了数据集，但需要创建一个矩阵来保存自变量，以及一个向量来保存因变量。为了创建保存自变量的矩阵，输入语句：
X = dataset.iloc[:, :-1].values 第一个冒号表示提取数据集的全部行，「:-1」则表示提取除最后一列以外的所有列。最后的「.values」表示希望提取所有的值。接下来，我们希望创建保存因变量的向量，取数据的最后一列。输入语句：
y = dataset.iloc[:, 3].values 记住，在查看数据集的时候，索引（index）是从 0 开始的。所以，如果希望统计列数，从 0 开始计数而不是 1。「[:, :3]」会返回 animal、age 和 worth 三列。其中 0 表示 animal，1 表示 age，2 表示 worth。对于这种计数方法，即使你没见过，也会在很短的时间内适应。
如果有缺失数据会怎么样？ 事实上，我们总会遇到数据缺失。对此，我们可以将存在缺失的行直接删除，但这不是一个好办法，还很容易引发问题。因此需要一个更好的解决方案。最常用的方法是，用其所在列的均值来填充缺失。为此，你可以利用 scikit-learn 预处理模型中的 inputer 类来很轻松地实现。（如果你还不知道，那么我强烈建议你搞明白它：scikit-learn 包含非常棒的机器学习模型）。在机器学习中，你可能并不适应诸如「方法」、「类」和「对象」这些术语。这不是什么大问题！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef6200c440cf48db6b2d8bb3d70e51c3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/16/">«</a>
	<span class="pagination__item pagination__item--current">17/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/18/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>