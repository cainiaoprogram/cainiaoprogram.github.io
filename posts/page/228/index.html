<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01242810760331ae2c90e64b52cac6ea/" rel="bookmark">
			Win11账号被锁定无法登录怎么办？Win11账号被锁定无法登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们有时候在使用Win11系统的电脑时，会不小心将账号禁用，这也就意味着该账号无法继续登录，但有部分小伙伴在遇到这种情况的时候不知道应该如何去解决，那么遇到这种情况应该怎么办呢？下面就和小编一起来看看Win11账号被锁定无法登录的解决方法。
​
1、首先我们需要在左下角使用其他可以登录的账户“登录”。
2、登录后，右键此电脑打开“管理”。
3、然后进入“本地用户和组”下的“用户”选项。
4、随后双击打开无法登录的账户。
5、进入后取消“账户已禁用”并确定，最后重启电脑就能正常登录那个账号了。
我们有时候在使用Win11系统的电脑时，会不小心将账号禁用，这也就意味着该账号无法继续登录，但有部分小伙伴在遇到这种情况的时候不知道应该如何去解决，那么遇到这种情况应该怎么办呢？下面就和小编一起来看看Win11账号被锁定无法登录的解决方法。
1、首先我们需要在左下角使用其他可以登录的账户“登录”。
2、登录后，右键此电脑打开“管理”。
3、然后进入“本地用户和组”下的“用户”选项。
4、随后双击打开无法登录的账户。
5、进入后取消“账户已禁用”并确定，最后重启电脑就能正常登录那个账号了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16bc0ae891a73888e35373610cd09d43/" rel="bookmark">
			将 Word 转换为 Markdown格式 【详细教程】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言①下载安装Writage②Word ➡ Markdown③下载安装Pandoc④再次Word ➡ Markdown总结 提示：以下是本篇文章正文内容，学习内容将会持续更新 前言 俗话说“好记性不如烂笔头”。在我们学习过程中，尤其是计算机学习方向，涉及到的知识点繁多，所以我们必须一边学习，一边做笔记。做好笔记，才能多看、多复习、学习更顺畅。
我们大部分人都会熟练使用word文档做一些学习笔记，因为这款软件使用起来比较简单。但是如果我们想把自己的笔记或学习成果分享到网络上，我们就需要学会使用markdown语法写博客了。
可能有部分小伙伴不太会使用markdown，也不想去学它的语法。那我就教你们一种方法：可以将word文档转换为markdown格式。
①下载安装Writage 官方下载地址：Writage
进入官网，点击Download Now下载，得到Writage-2.9.msi的安装包
点击安装包开始安装，一直点下一步，并且修改安装路径就可以安装成功
②Word ➡ Markdown (1)新建或打开 Word 文档，在 文件 -&gt;另存为 -&gt;查看 【保存类型】 中是否有 Markdown 格式。
（如果插件安装成功，就会自动出现Markdown选项；否则，重新安装一遍吧~）
(2)查看效果
我们可以看到的格式可能有些乱，和之前在word格式下的样式不一样。那我们可以通过与Pandoc结合，可以尽可能保留样式。
Pandoc是由John MacFarlane开发的标记语言转换工具，可实现不同标记语言间的格式转换，堪称该领域中的“瑞士军刀”。
③下载安装Pandoc 官方下载地址：Pandoc
进入官网，点击Download…下载，得到pandoc-2.18-windows-x86_64.msi的安装包
开始安装
④再次Word ➡ Markdown 此时，我们就可以最大程度的把word文档的样式以markdown的文本形式展现出来。
总结 （1）由于markdown中的图片无法设置大小，因此在word中排布的图片格式不标准，需要人工调整。
其他格式，如一级、二级标题，项目列表等也需要注意。
（2）在学习过程中，方法总比困难多。只有你想不到的功能，没有实现不了的功能。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2efabd174b2b88735e5184e7f6d1c95/" rel="bookmark">
			如何限制 NGINX 中的连接数（请求数）- Part1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NGINX提供了各种模块，允许用户控制其网站、Web 应用程序以及其他 Web 资源的流量。限制流量或访问的关键原因之一是防止某些类型的滥用或攻击，例如DoS（拒绝服务）攻击。
在NGINX中有三种主要的限制使用或流量的方法:
限制连接（请求）的数量。限制请求的速率。限制带宽。 在我们三部分系列的第一部分中，我们将讨论如何限制NGINX中的连接数以保护您的网站/应用程序。
如何限制 NGINX 中的连接（请求）数量 - 第 1 部分如何限制 NGINX 中的连接（请求）速率 - 第 2 部分如何在 NGINX 中限制带宽使用 - 第 3 部分 请记住，只有当服务器正在处理请求并且整个请求标头已被读取时， NGINX才会考虑限制连接。因此，并非所有客户端连接都被计算在内。
限制 NGINX 中的连接数 首先，您需要使用limit_conn_zone指令定义一个共享内存区域，用于存储各种键的连接指标。如前所述，密钥可以是文本、变量（例如客户端的远程 IP 地址）或两者的组合。
这个在 HTTP 上下文中有效的指令有两个参数：键和区域（格式为 zone_name:size）。
limit_conn_zone $binary_remote_addr zone=limitconnbyaddr:20m; 要设置返回给被拒绝请求的响应状态代码，请使用将HTTP 状态代码作为参数的limit_conn_status指令。它在 HTTP、服务器和位置上下文中有效。
limit_conn_status 429； 要限制连接，请使用limint_conn指令设置要使用的内存区域和允许的最大连接数，如以下配置片段所示。该指令在 HTTP、服务器和位置上下文中有效。
limit_conn limitconnbyaddr 50; 完整的配置：
upstream api_service { server 127.0.0.1:9051; server 10.1.1.77:9052; } limit_conn_zone $binary_remote_addr zone=limitconnbyaddr:20m; limit_conn_status 429; server { listen 80; server_name testapp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2efabd174b2b88735e5184e7f6d1c95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/203ab61ee7b95341a4f6a0a2c535fc24/" rel="bookmark">
			实验2 黑盒测试方法：等价类划分法&#43;边界值分析方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验2 黑盒测试方法：等价类划分法+边界值分析方法
一、实验目的
掌握等价类、有效等价类、无效等价类、边界值等概念。掌握边界值分析法、等价类划分法的测试用例设计方法。能够将这两种方法结合起来，灵活运用 二、实验任务
以下三个任务、至少完成一个
1、对三角问题综合运用边界值分析方法、等价类划分方法设计测试用例。
三角形问题：void Triangle (int a, int b, int c)函数规定输入三个整数a、b、c分别作为三边的边长构成三角形。通过程序判定所构成的三角形的类型（等边三角形、等腰三角形、一般三角形、构不成三角形），并在屏幕上输出。1&lt;=a,b,c&lt;=200。​​​​​​​
实验步骤：
输入变量
输出类型
有效等价类
无效等价类
a,b,c
不确定
三个正整数1&lt;=a,b,c&lt;=200
一个边为非正整数
（10）a为非正整数
（11）b为非正整数
（12）c为非正整数
两个边为非正整数
（13）ab为非正整数
（14）ac为非正整数
（15）bc为非正整数
三个边都为非正整数
（16）abc为非正整数
一般三角形
a+b&gt;c且abc不相等 （17）a+b&lt;c
a+c&gt;b且abc不相等 （18）a+c&lt;b
a&lt;b+c且abc不相等 （19）a&gt;b+c
等腰三角形
（6）a=b!=c
（7）a=c!=b
（8）b=c!=a
等边三角形
（9）a=b=c
划分等价类，得到等价类表。等价类表格式如下： 分析边界值： 边界值
a
b
c
[1,200]
[1,200]
[1,200]
[1,200]
综合运用这两种方法设测试用例，得到测试用例表： 等价类测试用例ID
a
b
c
预期输出
覆盖等价类
T1
5
5
9
一般三角形
（1）（2）（3）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/203ab61ee7b95341a4f6a0a2c535fc24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cc8b9288d4a32a22304f9a917f4c59c/" rel="bookmark">
			latex字母头顶两个点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		latex字母头顶两个点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f05b9fe43c5e9713b9adee4036e0c69/" rel="bookmark">
			阿里最新秋招面经，腾讯/美团/字节1万道Java中高级面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		又是一年过去了，职场的积雪还没有消融，又迎来了一次大考。疫情还没完全过去，大家强打起精神，相互问好致意，眼角却满是疲惫…
企业调薪、裁员、组织架构调整等等，坏消息只多不少，最近也有很多来咨询跳槽的朋友，都是因为之前的公司出现了比较大的薪资和组织变动
2022年开秋的秋招马上就要进行了，你筹备好了吗？
我梳理了各个大厂秋招面经分享，分享上万道面试题及答案，从实习生到开发1-10年的简历模板，面试过程的文档教程！ 阿里常问面试题（1-5年经验） String，StringBuffer，StringBuilder 的区别是什么？String为什么是不可变的？Vector，ArrayList，LinkedList的区别是什么？HashTable，HashMap，TreeMap区别？Tomcat，Apache，JBoss的区别？GET，POST区别？Session, Cookie区别？Servlet的生命周期？HTTP 报文包含内容？Statement与PreparedStatement的区别,什么是SQL注入，如何防止SQL注入sendRedirect, foward的区别关于JAVA内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。谈谈Hibernate的理解，一级和二级缓存的作用，在项目中Hibernate都是怎么使用缓存的。反射讲一讲，主要是概念,都在哪需要反射机制，反射的性能，如何优化谈谈Hibernate与Ibatis的区别，哪个性能会更高一些对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理线程同步，并发操作怎么控制描述struts的工作流程Tomcat的session处理，如果让你实现一个tomcatserver，如何实现session机制关于Cache(Ehcache,Memcached)sql的优化相关问题oracle中 rownum与rowid的理解，一千条记录我查200到300的记录怎么查？如何分析ORACLE的执行计划？DB中索引原理，种类，使用索引的好处和问题是什么？JVM垃圾回收实现原理。垃圾回收的线程优先级。jvm 最大内存设置。设置的原理。结合垃圾回收讲讲。 互联网Java工程师1000道面试题 MyBatis面试题
ZooKeeper面试题
dubbo面试题
Elasticsearch面试题
Redis面试题
MySQL面试题
并发编程面试题
Spring面试题
微服务面试题
Spring Boot面试题
Spring Cloud面试题
MQ面试题
kafka面试题
互联网Java工程师：Java. MyBatis. ZooKeeper. Dubbo、Elasticsearch. Memcached、
Redis. MySQL、Spring. Spring Boot. Spring Cloud、RabbitMQ. Kafka、
Linux面试专题及答案转发+评论，关注我私信回复“面试”即可免费获取
从实习生到开发1-10年的简历模板，面经！ 从JVM-Java集合-并发-spring-微服务-Netty-算法-云计算等30个知识点详解，面试必备核心教程！
微服务
由于文案原因，上述所展示的面试资料及面经劳烦您转发+评论，关注我私信回复“面试”免费获取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f46bd03449e1131033fd99beface38d/" rel="bookmark">
			2022年阿里高频Java面试题：分布式&#43;中间件&#43;高并发&#43;算法&#43;数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		又到了一年一度的金九银十，互联网行业竞争是一年比一年严峻，作为工程师的我们唯有不停地学习，不断的提升自己才能保证自己的核心竞争力从而拿到更好的薪水，进入心仪的企业（阿里、字节、美团、腾讯…）
话不多说，上干货！！！
助你在这次金九银十中大放光彩，更进一步！
分布式 一、大型网站系统的特点二、大型网站架构演化发展历程三、拆分VS集群四、微服务VS SOA五、前后端完全分离与Rest规范六、CAP三进二和Base定理关系型数据库遵循ACID规则 中间件 缓存消息队列搜索引擎 一、秒杀架构设计
二、数据库架构发展历程
三、MySQL的扩展性瓶颈
四、为什么要使用NOSQL NOT ONLY SQL
五、传统RDBMS VS NOSQL
六、NOSQL 数据库的类型
七、阿里巴巴中文站商品信息如何存放
八、数据的水平拆分和垂直拆分
九、分布式事务
十、BitMap
十一、Bloom Filter
十二、常见的限流算法
十三、负载均衡
十四、一 致性Hash算法
一、秒杀架构设计
二、数据库架构发展历程
三、MySQL的扩展性瓶颈
四、为什么要使用NOSQL NOT ONLY SQL
五、传统RDBMS VS NOSQL
六、NOSQL 数据库的类型
七、阿里巴巴中文站商品信息如何存放
八、数据的水平拆分和垂直拆分
九、分布式事务
十、BitMap
十一、Bloom Filter
十二、常见的限流算法
十三、负载均衡
十四、一 致性Hash算法
数据结构与算法 一、树二、BST树三、BST树四、AVL树五、红黑树六、B-树七、B+树八、字典树九、跳表十、HashMap十一、ConcurrentHashMap十二、ConcurrentlinkedQueue十三、Topk问题十四、资源池思想十五、JVM内存管理算法十六、容器虚拟化技术，Doocker思想十七、持续集成、持续发布，jenkinsJava面试突击、阿里巴巴Java面试笔记、面试答案关注我私信回复“面试”获得免费获取方式！ 面试题解析 一、设计一个分布式环境下全局唯一的发号器二、设计一个带有过期时间的LRU缓存三、设计-个分布式锁四、设计一个分布式环境下的统一配置中心五、如何准备HR面试 Java面试突击、阿里巴巴Java面试笔记、面试答案关注我私信回复“面试”获得免费获取方式！
面试宝典大合集 Java面试宝典共266页覆盖了基础、JVM、多线程、高并发、spring、mybatis、MySQL、spring cloud、dubbo、Nginx、MQ、数据结构与算法、Linux、Zookeeper、Redis、分布式、网络、设计模式的经典面试题及答案
不论是校招还是社招都避免不了各种⾯试、笔试，如何去准备这些东⻄就显得格外重要。不论是笔试还是⾯试都是有章可循的，我这个“有章可循”说的意思只是说应对技术⾯试是可以提前准备。 我其实特别不喜欢那种临近考试就提前背啊记啊各种题的⾏为，⾮常反对！我觉得这种⽅法特别极端，⽽且在稍有⼀点经验的⾯试官⾯前是根本没有⽤的。建议⼤家还是⼀步⼀个脚印踏踏实实地⾛。
2022年金九银十看这份面试合集足以，帮助你质的提升，扩展知识！
文中Java面试突击、阿里巴巴Java面试笔记、面试答案感兴趣的朋友劳烦您点赞+转发，关注我私信回复“面试” 即可获得获取方式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/017d9fdedb7a3c24a3e7ae31622a4ccf/" rel="bookmark">
			docker部署gitlab内存占用过大的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. gitlab几乎占内存50%，需要修改配置文件，进行优化
2. vi gitlab.rb
注意：所有修改需要掉注释，在注释的情况下默认是服务器上的所有线程。
减少数据库缓存
postgresql['shared_buffers'] = "64MB"
减少数据库并发数
postgresql['max_worker_processes'] = 1
减少sidekiq并发数
sidekiq['concurrency'] = 1
减少进程数
unicorn['worker_processes'] = 1
nginx['worker_processes'] = 2
减少超时时间
unicorn['worker_timeout'] = 10
减少数据库缓存
postgresql['shared_buffers'] = "64MB"
将worker内存上限设置小一点
unicorn['worker_memory_limit_min'] = "100 * 1 &lt;&lt; 20"
unicorn['worker_memory_limit_max'] = "220 * 1 &lt;&lt; 20"
禁用prometheus
prometheus_monitoring['enable'] = false
3. 修改生效
gitlab-ctl reconfigure
gitlab-ctl restart
docker生效方式：
重载配置：docker exec -it gitlab gitlab-ctl reconfigure
重启：docker exec -it gitlab gitlab-ctl restart
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/017d9fdedb7a3c24a3e7ae31622a4ccf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c4f16b2f217cc0eb23228bb7257b8d0/" rel="bookmark">
			java8 集合操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、提取某一属性的值
List&lt;User&gt; Users = new arrayList&lt;User&gt;(); List&lt;String&gt; names = infos.stream().map(User::getName).collect(Collectors.toList()); 2、
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd9f76f12367191cd7caed5315a09518/" rel="bookmark">
			线程状态锁阻塞&#43;计时等待&#43;无限等待详解&#43;(图解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中， 有几种状态呢？下面介绍一下常见的线程状态及等待唤醒机制
1. 线程状态概述 我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几个状态呢，新建与被终止还是很容易理解的，我们就研究一下线程从Runnable（可运行）状态与非运行状态之间的转换问题
先列出各个线程状态,下面会详细讲解
线程状态
导致状态发生改变的条件
NEW(新建)
线程刚被创建,但是并未启动,还没有调用start方法
Runnable(可运行)
线程可以在java虚拟机中运行的状态,可能正在运行自己代码,也可能没有,这取决于操作系统处理器
Blocked(锁阻塞)
当一个线程试图获取一个对象锁,而该对象锁被其他的线程持有,则该线程进入Blocked状态；当该线程持有锁时,该线程将变成Runnable状态
Timed Waiting(计时等待)
同waiting状态,有几个方法有超时参数,调用他们将进入Timed Waiting状态,这一状态将一直保持到超时期满或者接收到唤醒通知,带有超时参数的常用方法有Thread.sleep、锁对象.wait()
Waiting(无限等待)
一个线程在等待另一个线程执行一个(唤醒)动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒
Teminated(被终止)
因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡
1.1 BLOCKED锁阻塞 Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。 我们已经学完同步机制，那么这个状态是非常好理解的了。
比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。 这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态，而这部分内容作为扩充知识点带领大家了解一下
BLOCKED 线程状态图
1.2 Timed Waiting 计时等待 Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？ 在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就 强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。 其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)
举例说明:
实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串
/**
@Description@auther 宁宁小可爱@create 2020-01-10 13:02
*/
public class ThreadDemo {
public static void main(String[] args) {
for (int i = 0; i &lt; 100; i++) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd9f76f12367191cd7caed5315a09518/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ab5c4ab8aa6ed21469966bc4f6a83b1/" rel="bookmark">
			【每日一题LeedCode day01 存在重复元素】小夜斗力扣修炼之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们生如蝼蚁，但美若神明 Hello，好久不见呐！回想上一篇手把手教你玩转极验滑块JS逆向系列这一篇博客后，小夜斗已经将近一年没更新博客了，这一年经历的事情简直太多太多了，不过最令人安心的事情就是当你实现了你的代码，改了一个又一个bug的时刻，简直不要太爽。
然后勒这次写关于算法的博客，当然以前也有写过类似几篇，不过都没有坚持下来，小夜斗自己算法基础几乎为零，所以一方面是记录自己在算法升级打怪这个路上的经验，听到很多大佬说算法不过关，以后想找工作都是难上加难，所以咯硬着头皮也要上咯。
当然呐，要是大佬们看到了也可以给我一些指点，感谢感谢啦！题目大多数会从力扣上面刷题，然后难度也是由易到难恩诺，希望我能坚持下来，大家可以一起通过学习算法变成大佬大佬！
【217.存在重复元素】—— 题目描述：给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。
class Solution(object): def containsDuplicate(self, nums): """ :type nums: List[int] :rtype: bool """ tag_dict = {} for i in nums: if i in tag_dict: tag_dict[i] = tag_dict[i] + 1 return True else: tag_dict[i] = 1 return False 对应这个题目，我一下就冒出一个思路(Python实现）：让我判断一个数组里面是否有两个相同的数字，那我用一个容器即字典来保存每一个数字，因为键值是唯一性的，只要第一次没有在字典内，我就把它作为键值；当第二次有相同的数字出现时，那么这个键值一定是存在的，返回True；当循环遍历结束都没有相同数字出现时，说明这个数组不存在两个相同的数字。
运行一下，嘿结果还不错哦，如下图所示，不过还有一个N/A无法解决，现在不大明白是什么原因，后续再给他解决掉
俗话说，一个题目能有多个解法，但由于小夜斗脑子太笨，所以不得不求助于题解，然后看到了方法二，大概思路为：先将数组进行排序，如果出现相同元素那么这两个一定是相邻出现的，然后只要依次扫描该排好序的数组就能够判断是否出现重复元素
以下为力扣官方关于方法二的Java代码：
class Solution { public boolean containsDuplicate(int[] nums) { Arrays.sort(nums); int n = nums.length; for (int i = 0; i &lt; n - 1; i++) { if (nums[i] == nums[i + 1]) { return true; } } return false; } } 小夜斗大概看了一下还有一种解法为哈希表，大概思路和我用python实现的类似——对于数组中每个元素，我们将它插入到哈希表中。如果插入一个元素时发现该元素已经存在于哈希表中，则说明存在重复的元素。官方Java代码如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ab5c4ab8aa6ed21469966bc4f6a83b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/267ad406e5991ecb3484e35357707516/" rel="bookmark">
			linux安装zookeeper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：本文第5、6、7三个是关键点，注意看好
1、把下载好的安装包传到linux中，我放到了/home/qinSoft
2、进入linux系统，输入cd /home/qinSoft切到存放安装包的目录
使用tar -zxvf apache-zookeeper-3.8.0-bin.tar.gz -C /usr/qinTools/
(z表示文件类型是压缩包类型，x表示解压，v表示显示解压过程，f表示指定要压缩包的文件名是什么-C 加路径：将安装包解压到指定目录）
3、切到解压目录查看是否成功解压（名字太长了，我做了修改）
4、进入zookeeper目录查看其内容
5、新建一个data目录，用来存zookeeper的数据（一会需要配置）
6、进入conf目录下把zoo_sample.cfg改名为zoo.cfg，或复制一个新的命名为zoo.cfg
7、修改配置文件：vim /usr/qinTools/zookeeper-3.8.0/conf/zoo.cfg 里面有两个比较重要的配置：
dataDir==/usr/qinTools/zookeeper-3.8.0/data # 数据存放位置，根据需要修改
clientPort=2181 # 服务监听端口，可根据需要修改
按esc退出编辑模式，:wq保存退出
8、启动zookeeper
切到bin目录，执行./zkServer.sh start命令启动zookeeper 9、查看zookeeper状态
切到bin目录，执行./zkServer.sh status
(任意位置查看进程情况，ps -ef | grep xxxx) 9、关闭zookeeper
方式一：切到bin目录，执行./zkServer.sh stop
方式二：先使用ps -ef | grep zookeeper找到其进程pid，然后使用kill pid或kill -9 pid方式关闭
10、再次查看zookeeper状态，命令：./zkServer.sh status 查看zookeeper进程情况
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46c27cdfb1777bdb55ec5fb139490d85/" rel="bookmark">
			基于kubernetes平台微服务的部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Jenkins+Kubernetes+Docker完成微服务持续集成
创建NFS共享目录
配置harbor
微服务的部署
Jenkins认证k8s凭证
部署其他微服务
手动上传父工程依赖到NFS的Maven共享仓库目录中
Jenkins+Kubernetes+Docker完成微服务持续集成 创建NFS共享目录 让所有Jenkins-Slave构建指向NFS的Maven的共享仓库目录
[root@harbor /opt/nfs]# mkdir maven [root@harbor /opt/nfs]# chmod 777 maven/ [root@harbor /opt/nfs]# vim /etc/exports /opt/nfs/jenkins 192.168.37.0/24(rw,sync,no_root_squash) /opt/nfs/maven 192.168.37.0/24(rw,sync,no_root_squash) ​ #刷新 [root@harbor /opt/nfs]# exportfs -rv exporting 192.168.37.0/24:/opt/nfs/maven exporting 192.168.37.0/24:/opt/nfs/jenkins 查看k8s集群
[root@node01 ~]# showmount -e 192.168.37.106 Export list for 192.168.37.106: /opt/nfs/maven 192.168.37.0/24 /opt/nfs/jenkins 192.168.37.0/24 Docker命令执行权限问题
[root@master01 /var/run]# chmod 777 docker.sock 新建一个流水线项目
编写构建Pipeline
配置harbor 配置harbor凭证
流水线脚本
def git_url = "http://192.168.37.103:85/devops_group/tensquare_back.git" def git_auth = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46c27cdfb1777bdb55ec5fb139490d85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf6e3c8f577acfb052c9c663f62efd16/" rel="bookmark">
			监督学习中判别式模型和生成式模型的区别 | 无监督学习的生成模型GAN、VAE（生成样本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、监督学习中的判别式模型和生成式模型1.1 判别式模型（线性回归、SVM、NN）1.2 生成式模型（朴素贝叶斯、HMM）1.3 两种模型的小结 二、无监督学习中的生成式模型（生成样本）三、参考资料 一、监督学习中的判别式模型和生成式模型 有监督学习可以分为两类：判别模型和生成模型，我们所熟悉的神经网络，支持向量机和logistic regression，决策树等都是判别模型。而朴素贝叶斯和隐马尔可夫模型则属于生成式模型
1.1 判别式模型（线性回归、SVM、NN） 判别式模型由数据直接学习 P ( y ∣ x ) P(y|x) P(y∣x)来预测 y y y
1.2 生成式模型（朴素贝叶斯、HMM） 生成式模型先对联合概率 P ( x , y ) P(x,y) P(x,y)建模（由数据学习联合概率分布 P ( x , y ) P(x,y) P(x,y)），由此求得 P ( y ∣ x ) P(y|x) P(y∣x)
以分类问题为例，我们会对每个类别建一个模型，有多少个类别，就建立多少个模型。
比如类别有猫、狗、猪，那我们会学出模型P(X, Y = 猫), P(X, Y = 狗), P(X, Y = 猪)，即得到联合概率P(X,Y)，对于一个新的样本X=忠诚，我们看一下三个模型哪个概率最高，例如P(X=忠诚, Y=狗)概率最大，我们就认为该样本属于狗这个类别。 生成式模型： P ( Y ∣ X ) = P ( X , Y ) P ( X ) P(Y|X)=\frac{P(X,Y)}{P(X)} P(Y∣X)=P(X)P(X,Y)​ （贝叶斯公式）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf6e3c8f577acfb052c9c663f62efd16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e047dba6f7ef184a6e4f8168cd8a8c7/" rel="bookmark">
			Linux操作系统（一）系统初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统初始化 CPU（Central Processing Unit，中央处理器）x86 架构32 位处理器BIOS 时期bootloader 时期从实模式切换到保护模式内核初始化从内核态到用户态glibc 对系统调用的封装32 位系统调用过程 64位系统调用表 CPU（Central Processing Unit，中央处理器） 总线：用于CPU 和其他设备连接
CPU 它包括三个部分，运算单元、数据单元和控制单元。
每个进程都有一个二进制的程序放在硬盘上，再里面就是一行行的指令，会操作一些数据。
CPU 的控制单元里面，有一个指令指针寄存器，它里面存放的是下一条指令在内存中的地 址。控制单元会不停地将代码段的指令拿进来，先放入指令寄存器。 （指令分别是对数据 or 运算）。 数据单元里的数据寄存器，从数据段里 读到数据寄存器里，就可以参与运算了，运算单元做完运算，产生的结果会暂存在数据单元的数据寄存器里。最终，会有指令将数据写回内存中的数据段。
多任务系统的一个操作 ：进程切换 （A进程切换到B进程）
CPU 和内存来来回回传数据，靠的都是总线。一个是地址数据，也就是我想拿内存中哪个位置的数据，这类总线叫地址总线 （Address Bus）；另一类是真正的数据，这类总线叫数据总线（Data Bus）
地址总线的位数，决定了能访问的地址范围到底有多广。例如只有两位，那 CPU 就只能认 00，01，10，11 四个位置，超过四个位置，就区分不出来了。位数越多，能够访问的位置 就越多，能管理的内存的范围也就越广。
CPU 数据总线和地址总线越来越宽，处理能力越来越强。但是一直不能忘记 三点，一是标准，二是开放，三是兼容
x86 架构 下图是x86 86 中最经典的一款处理器 ， 8086处理器
重点 ： 寄存器的作用
8086 处理器内部有 8 个 16 位的通用寄存器，也就是刚才说的 CPU 内部 的数据单元，分别是 AX、BX、CX、DX、SP、BP、SI、DI。这些寄存器主要用于在计算过 程中暂存数据。这些寄存器比较灵活，其中 AX、BX、CX、DX 可以分成两个 8 位的寄存器来使用，分别 是 AH、AL、BH、BL、CH、CL、DH、DL，其中 H 就是 High（高位），L 就是 Low（低位）的意思。IP 寄存器/指令指针寄存器（Instruction Pointer Register) :指向代码段中下一条指令的位置。CPU 会根据它来不断地将指令从内存的代码段中，加载到 CPU 的指令队列中，然后交给运算单元去执行。切换进程：每个进程都分代码段和数据段，为了指向不同进程的地址空间，有四 个 16 位的段寄存器（ CS、DS、SS、ES）CS 就是代码段寄存器 , 通过它可以找到代码在内存中的位置DS 是数据段的寄存器 , 通过它可以找到数据在内存中的位置SS 是栈寄存器（Stack Register） : 数据的存取只 能从一端进行，秉承后进先出的原则，push 就是入栈，pop 就是出栈.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e047dba6f7ef184a6e4f8168cd8a8c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f812b9fa0ebd31af83b886f53165046/" rel="bookmark">
			MyBatis-Plus 字段为Null时不更新解决方案，MyBatis-Plus 更新空字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		©Copyright 蕃薯耀 2022-06-25
https://www.cnblogs.com/fanshuyao/
一、问题描述
使用这两个方法，不会对实体中值为Null的属性（字段）进行更新。
this.updateById(entity); this.update(entity, updateWrapper); 二、解决方案
1、使用LambdaUpdateWrapper （推荐）
LambdaUpdateWrapper&lt;BizFile&gt; lambdaUpdateWrapper = new LambdaUpdateWrapper&lt;&gt;(); //过滤条件 lambdaUpdateWrapper.eq(BizFile::getId, bizFile.getId()); //下面为设置值 //由于parentId会为空，所以要使用LambdaUpdateWrapper lambdaUpdateWrapper.set(BizFile::getParentId, parentId); lambdaUpdateWrapper.set(BizFile::getPath, newDirPath); //更新 this.update(lambdaUpdateWrapper); 2、使用UpdateWrapper
和LambdaUpdateWrapper的区别，就是设置的字段写法不一样，下面是要使用数据库字段的，如果修改字段后，容易造成字段名称没有修改。
UpdateWrapper&lt;BizFile&gt; updateWrapper = new UpdateWrapper&lt;BizFile&gt;(); updateWrapper.eq("id", bizFile.getId()); updateWrapper.set("parentId", parentId); updateWrapper.set("path", newDirPath); this.update(updateWrapper); 3、在实体中使用@TableField注解
在字段上加上注解：@TableField(fill = FieldFill.UPDATE)
@ApiModelProperty(“父ID”)
@TableField(fill = FieldFill.UPDATE)
private Long parentId;
然后通过下面的方法更新
this.updateById(entity); this.update(entity, updateWrapper); ================================
©Copyright 蕃薯耀 2022-06-25
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/110b58cd90d485e3b1d63e157cde0ec8/" rel="bookmark">
			TypeScript的泛型和泛型约束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、泛型 在使用ts封装一个函数时，由于入参是不固定的，必然参数类型也无法固定，这时就要用到泛型来定义参数类型。泛型可以理解为宽泛的类型，通常用于类和函数。
例1. 类中使用泛型 class Person&lt;T&gt;{ private name: T; constructor(value: T) { this.name = value; } } const p = new Person&lt;string&gt;('Dalon') 例2. 函数中使用泛型 function identity&lt;T&gt;(data: T): T { console.log(data) return data; } const id1 = identity&lt;string&gt;('hey boy!'); const id2 = identity&lt;number&gt;(123456); 例3. 接口中使用泛型 interface Person&lt;T1=string, T2=number&gt; { name: T1 age: T2 } const dalon:Person = { name: 'dalon', age: 18 } const tom:Person&lt;string, string&gt; = { name: 'Tom', age: '18' } 例3中的T1和T2泛型添加了默认类型，类似于函数的默认参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/110b58cd90d485e3b1d63e157cde0ec8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61c68b10d75759bb1aaa16854ce582d8/" rel="bookmark">
			嵌入式迷宫小车
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嵌入式迷宫小车 仅供参考
https://download.csdn.net/download/weixin_50722482/85826485
调试的方法 1.左前，右前小车与墙的感应距离为一个指姆的大小
2.左，前，右的感应距离可以远一些，只要该方向正常有障碍就应该感应的到
3.注释纯属娱乐
4.只为记录自己的学习
代码的实现 #include&lt;reg52.h&gt; #include&lt;intrins.h&gt; sfr P4 = 0xe8; //3——8译码器的三个输入端 sbit A0 = P4^0; sbit A1 = P2^0; sbit A2 = P2^7; //红外传感器的五个方向 sbit irR1 = P2^1; sbit irR2 = P2^2; sbit irR3 = P2^3; sbit irR4 = P2^4; sbit irR5 = P2^5; //记录哪个传感器的方向，从而控制小车转向 bit irC =0, irL =0, irR=0, irLu =0,irRu=0; //规定C为1，左前2，左3，右前5，右4 //红外发射控制宏定义(传入传感器组号) #define MOUSE_IR_ON(GROUP_NO)\ do\ {\ A0=(GROUP_NO)&amp;0X01;\ A1=(GROUP_NO)&amp;0X02;\ A2=(GROUP_NO)&amp;0X04;\ } while (0); sbit wel1 = P4^3;//数码管的位选 sbit wel2 = P4^2; sbit Beep = P3^7; //蜂鸣器 unsigned code tabal[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90}; //数码管显示的0-9 unsigned char l1=0,l2=0; //用做转向修正（减小前进步数） //堆柞，记录岔路口坐标 xdata unsigned char stack_x[20] = {-1}; xdata unsigned char stack_y[20] = {-1}; unsigned char top = 0;//堆柞指针 //单元格目标记录 unsigned char x =0,y =0; //地图数据 unsigned char map[8][8]; //地图数据 最后都会初始化 xdata unsigned char maze[8][8]; //登高表记录 //方向记录，参考书上 绝对方向与相对方向的和与4的余数 unsigned int dir = 0,dirs = 0; //记录绝对方向 //规定0为上，1为右，2为下，3为左 //对数值进行运算 unsigned int move_x[4] = {0,10,0,-10}; unsigned int move_y[4] = {1,0,-1,0}; //目标单元格坐标 unsigned char target_x = 7; unsigned char target_y = 7; //转向数组 unsigned char code turn_right[]={0x11,0x33,0x22,0x66,0x44,0xcc,0x88,0x99}; //左右电机同时右转 unsigned char code turn_left[]={0x11,0x99,0x88,0xcc,0x44,0x66,0x22,0x33}; //左右电机同时左转 unsigned char code turn_right_2[] ={0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09}; //左步机右转函数 unsigned char code turn_left_2[] ={0x10,0x90,0x80,0xc0,0x40,060,0x20,0x30};	//右步机左转函数 unsigned char code forward[] ={0x11,0x93,0x82,0xc6,0x44,0x6c,0x28,0x39}; xdata unsigned char path[20]={5}; //初始化函数 void init(); void delay_ms(unsigned int z); void display(unsigned int k); void setTime2(unsigned int us); void initTime2(); void nice_go(); void turn_Right1(); void turn_Left1(); void go_straight(); void nice_modify(); void flash_back(); unsigned int jugment(unsigned int k); int arrive(); int ending(); void cool_ergodic(); void target(); void cool_findshort();//找到最短路径 unsigned int jugment(unsigned int k) //判断的第二个条件，及是否已经走过 { int happy = 0; k = (k+dir)%4; happy = dirs + move_x[k] + move_y[k]; if(happy&lt;0) { return 0; } if((0xf0&amp;map[happy/10][happy%10])==0xf0) { return 1; } else { return 0; } } void flash_back() //回溯到上一个岔路口 { unsigned char happy; unsigned int nice=0; while(1) { happy = map[dirs/10][dirs%10]&amp;0xf0; switch(happy) { case 0x70:nice = 0;break; case 0xe0:nice = 1;break; case 0xc0:nice = 2;break; case 0xd0:nice = 3;break; default:break; } if(nice == dir) //绝对方向相同 { turn_Right1(); turn_Right1();//两次右转_掉头 delay_ms(500); go_straight(); } else if ((nice+dir)%2==0) //绝对方向相反，直接直行 { delay_ms(500); go_straight(); } else //右转左转的情况 { if(dir==0) { if(nice==3) turn_Right1(); else turn_Left1(); delay_ms(500); go_straight(); } else if(dir==1) { if(nice==0) turn_Right1(); else turn_Left1(); delay_ms(500); go_straight(); } else if(dir==2) { if(nice==1) turn_Right1(); else turn_Left1(); delay_ms(500); go_straight(); } else if(dir==3) { if(nice==2) turn_Right1(); else turn_Left1(); delay_ms(500); go_straight(); } } if(arrive()||ending()) //达到最近的一个岔路口 { Beep = 0; delay_ms(50); Beep = 1; break; } } } int arrive() { unsigned char i =0; if(dirs==0) return 0; for(i=0;i&lt;16;i++) { if((dirs/10)==stack_x[i]&amp;&amp;(dirs%10)==stack_y[i]) { return 1; } } return 0; } void jilu() { unsigned char s; unsigned char sum =0; x = dirs/10;y = dirs%10; switch (dir) //记录进入的绝对方向 上右下左,上下左右 { case 0:map[x][y]&amp;=0x7f;break; //上 case 1:map[x][y]&amp;=0xef;break; //右 case 2:map[x][y]&amp;=0xcf;break; //下 case 3:map[x][y]&amp;=0xdf;break;//左 default:break; } if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61c68b10d75759bb1aaa16854ce582d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5f290db0d5f81a482e211db5b0a4c29/" rel="bookmark">
			Ubuntu18.04 在Anaconda中配置YOLOv3-Pytorch-GPU环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Anaconda中配置YOLOv3-Pytorch-GPU环境配置 1 Anaconda创建一个虚拟环境(名为pytorch)2 激活pytorch虚拟环境3 在虚拟环境中安装cuda10.04 在虚拟环境中安装cuda对应的cudnn版本7.645 在虚拟环境中安装torch-1.2、torchvision-0.406 在虚拟环境中安装其他所需包7 训练时查看GPU-Util(GPU使用率) cuda-10.0
cudnn-7.64
torch-1.2
torchvision-0.40
1 Anaconda创建一个虚拟环境(名为pytorch) conda create -n pytorch python=3.6 2 激活pytorch虚拟环境 conda activate pytorch 3 在虚拟环境中安装cuda10.0 终端输入
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ conda config --set show_channel_urls yes 因为conda的默认源速度慢且没有cuda版本，因此需要添加国内清华或者中科大的源
conda install cudatoolkit=10.0 -n pytorch -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/linux-64/ 4 在虚拟环境中安装cuda对应的cudnn版本7.64 conda install cudnn=7.6.4 -n pytorch -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/linux-64/ 检查cuda和cudnn是否安装成功
为这里的cuda是安装在虚拟环境中的，并非直接安装在系统中。所以，在对应文件夹中无法找到对应文件，自然也无法使用ncvv -V/ncvv --version来查看版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5f290db0d5f81a482e211db5b0a4c29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42bcad7f757229a2a7243c5ec0648c7c/" rel="bookmark">
			Jmeter常用时间技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当天实时时间：${__time(yyyy-MM-dd\,HH:mm:ss,)}
当天时间0点：${__time(yyyy-MM-dd\,00:00:00,)}
一小时前的时间搓：${__intSum(${__time(/1000,)},-3600,)}
当天时间戳：${__time(,)}
当前时间+1小时：${__longSum(${__time},3600000,)}
当前时间减一小时：${__longSum(${__time},-3600000,)}
默认毫秒为单位，要是以秒为单位：${__intSum(${__time(/1000,)},-3600,)}
增加一天${__timeShift(,,P1d,,)}
增加一H ${__timeShift(,,PT1H,,)}
${__timeShift(yyyy-MM-dd HH:mm:ss:SSS,,,,)}
${__timeShift(yyyy-MM-dd HH:mm:ss:SSS,,P1d,,)}
${__timeShift(yyyy-MM-dd HH:mm:ss:SSS,,PT1H,,)}
${__timeShift(yyyy-MM-dd HH:mm:ss:SSS,,PT10m,,)}
${__timeShift(yyyy-MM-dd HH:mm:ss:SSS,,PT20S,,)}
${__timeShift(yyyy-MM-dd HH:mm:ss:SSS,,P1dT1H10m20s,,)}
${__time(YMDHMS,)}
${__time(YYYYMMDHMS,)}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d9f64c1ceea785dbdf74b1fb7ad05aa/" rel="bookmark">
			姿态估计之2D人体姿态估计 - Simple Baseline(SBL)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文地址：Simple Baselines for Human Pose Estimation and Tracking
代码地址：GitHub - leoxiaobin/pose.pytorch: Simple Baselines for Human Pose Estimation and Tracking
Simple Baselines，是2018年MSRA的工作，网络结构如下图所示。之所以叫这个名字，是因为这个网络真的很简单。该网络就是在ResNet的基础上接了一个head，这个head仅仅包含几个deconvolutional layer，用于提升ResNet输出的feature map的分辨率，我们提到过多次高分辨率是姿态估计任务的需要。这里的deconvolutional layer是一种不太严谨的说法，阅读源代码可知，deconvolutional layer实际上是将transpose convolution、BatchNorm、ReLU封装成了一个结构。所以关键之处在于transpose convolution，可以认为是convolution的逆过程。
从图中看可以发现Simple Baselines的网络结构有点类似Hourglass中的一个module，但可以发现：①该网络没有使用类似Hourglass中的skip connection；②该网络是single-stage，Hourglass是multi-stage的。但令人惊讶的是，该网络的效果却超过了Hourglass。我个人认为有两点原因，一是Simple Baselines以ResNet作为backbone，特征提取能力相比Hourglass更强。二是Hourglass中上采样使用的是简单的nearest neighbor upsampling，而这里使用的是deconvolutional layer，后者的效果更好（后面可以看到在MSRA的Higher-HRNet中依旧使用了这种结构）。
SBL网络结构 SBL（Simple Baseline） [7] 为人体姿态估计提供了一套基准框架。SBL 在主干网络后接逆卷积模块来预测热图，就是在ResNet后加上几层Deconvolution直接生成热力图。相比于其他模型，就是使用Deconvolution替换了上采样结构。将上采样和卷积参数以一种更简单的方式组合到反卷积层中，而不使用跳跃层连接。
Hourglass、CPN、SBL共同点是，采用三个上采样步骤和三个水平的非线性(来自最深处的特征)来获得高分辨率的特征图和heatmap
上图中a是Hourglass网络，b是CPN，c是本文的SimplePose，可以直观看出结构的复杂度对比前两种结构需要构造金字塔特征结构，如FPN或从Resnet构建SimplePose则不需要构建金字塔特征结构，它是直接在Resnet后面设计反卷积模块并输出结果，是从deep和low分辨率特征生成热图的最简单方法具体结构：首先：在Resnet的基础上，取最后残差模块输出特征层（命名C5）然后：后面接上三个反卷积模块（每个模块为：Deconv + batchnorm + relu，反卷积参数，256通道，4X4卷积核，stride为2，pad为1），最后：用1X1卷积层生成 k个关键点输出热力图。均方误差（MSE）被用作预测热图和目标热图之间的损失通过应用以第 k 个关节的GT位置为中心的2D高斯函数，生成 k 关节的目标热图 。 在这些模型中，可以看出如何生成高分辨率特征图是姿态估计的一个关键，SimplePose采用Deconv扩大特征图的分辨率，Hourglass，CPN中采用的是upsampling+skip方式；当然我们很难就这一个实例就判定那种方式好
姿态追踪问题描述
ICCV’17 PoseTrack Challenge[2]的获胜者[11]解决了这个多人位姿跟踪问题，首先使用Mask RCNN[12]在帧中估计人体位姿，然后使用贪婪二部图匹配算法逐帧进行在线跟踪。
这个贪婪匹配算法，简单来说就是，在视频第一帧中每个检测到的人给一个id，然后之后的每一帧检测到的人都和上一帧检测到的人通过某种度量方式（文中提到的是计算检测框的IOU）算一个相似度，将相似度大的（大于阈值）作为同一个id，并删去。重复以上步骤，直到没有与当前帧相似的实例，此时给剩下的实例分配一个新的id。
本文提出的方法保留了这一方法的主要流程，并且在此之上提出了两点改进：
一是除了检测网络之外，还使用光流法补充一些检测框，用以解决检测网络的漏检问题（比如图2©中最左边的人就没有被检测网络检测到）。
二是使用 Object Keypoint Similarity (OKS)代替检测框的IOU来计算相似度。这是因为当人的动作比较快时，用IOU可能并不合理。
OKS是关键点距离的一种度量方式，计算方式如下：
文中提出的新的相似度计算方式具体是使用光流法计算某一帧的关键点会出现在的另外一帧的位置，然后用这个计算出来的位置和这一帧检测出来的关键点之间计算OKS,以此作为两帧之间的不同人的相似度值。
Joint Propagation using Optical Flow
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d9f64c1ceea785dbdf74b1fb7ad05aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24cf31946c339395062caaa3918c982d/" rel="bookmark">
			linux系统 常用命令(全面总结)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. Linux 之 文件目录 工作机制2. Linux命令 之 文件目录管理2.1 目录管理2.1.1 cd2.1.2 ls2.1.3 pwd2.1.4 mkdir2.1.5 rmdir2.1.6 tree(需要安装) 2.2 文件管理2.2.1 touch2.2.2 ln2.2.3 rename2.2.4 stat2.2.5 file2.2.6 chmod2.2.7 chown2.2.8 locate 和 updatedb2.2.9 find2.2.10 which2.2.11 whereis 2.3 文件和目录通用管理2.3.1 cp2.3.2 mv2.3.3 rm2.3.4 scp 3. Linux 之 文件内容查看 和 编辑3.1 cat3.2 head3.3 tail3.4 more3.5 less3.6 sed3.7 vi3.8 grep 4. Linux 文件压缩和解压4.1 tar4.2 gzip4.3 zip4.4 unzip 5. Linux 之 硬件管理5.1 df5.2 du5.3 top5.4 free5.5 iotop (需要安装) 6. Linux 之 网络管理6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24cf31946c339395062caaa3918c982d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6012a6627af30e1ae36f8cd5df66c18c/" rel="bookmark">
			【命名空间】using namespace std是什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、 前言二、作用域分解运算符三、命名空间使用介绍四、using namespace std 一、 前言 C++中的using namespace std是什么意思呢？为了理解其中的含义，我们首先需要学习一个概念叫做命名空间。
我们都知道，C语言规定变量名不能与关键字冲突，但是并没有规定变量名不能与库中的变量名冲突，但这在实际的操作的过程中就会产生意想不到的错误：
例如，将一个time变量放在main函数中，根据局部优先的原则，time变量就会被理解为一个局部变量。但当time作为一个全局变量出现的时候，由于time库中也含有一个名叫time的函数名，头文件被展开后，此time被理解为变量名还是函数名就会产生歧义。
而C++中出现的命名空间概念就是为了填C语言中的这个坑。
✪总结：同一个域中不能出现两个重名的变量名/函数名，而命名空间的提出就是为了对标识符的名称进行本地化，以此解决命名污染的问题，其作用就是定义一个新的作用域
二、作用域分解运算符 在讲命名空间的时候首先给大家介绍一个作用域分解运算符 " :: " 。
✪使用说明
A，B表示两个类，而在A,B中都有成员member
A :: member表示类A成员中的memberB :: member表示类B成员中的member 当前面的类不指定的时候，默认为全局
前面说到变量名冲突的时候遵循局部优先原则，那么我们能不能就想访问到全局变量呢？我们就可以通过作用域分解运算符实现:
三、命名空间使用介绍 namespace my_variant { int time = 10; } int main() { printf("%d", my_variant::time); } ✪基本介绍①
namespace是一个C++中的一个关键字我们将变量定义在自己创建的my_variant命名空间，以避免被污染访问命名空间中的变量，需要使用作用域分解运算符命名空间只能定义在全局，其中定义的变量为全局变量 namespace my_variant { int time = 10; typedef struct Stu { char name[10]; int age; int score; }Stu; namespace _variant { int Add(int a, int b)	{ return a + b; } } } int main() { my_variant::Stu data = {0}; int ret = my_variant::_variant::Add(1, 2); } ✪基本介绍②
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6012a6627af30e1ae36f8cd5df66c18c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d855ff04317f99c1bff8b47e0eb04240/" rel="bookmark">
			网络故障排查：BGP故障排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、为确保BGP路由争取加入到全局路由表中，首先需要确保BGP路由有效，其次要确保能够在和通过其他路由协议学到的路由比较中优选。
2、查看BGP 邻居状态
2.1 如果没有BGP路由表中，未能查询到相匹配的路由信息，需要查看BGP邻居状态是否正常
# 查看对等体的信息。 &lt;Huawei&gt; display bgp peer Status codes: * - Dynamic BGP Local router ID : 10.2.3.4 local AS number : 10 Total number of peers : 2 Peers in established state : 1 Total number of dynamic peers : 1 Peer V AS MsgRcvd MsgSent OutQ Up/Down State PrefRcv 10.1.1.1 4 100 0 0 0 00:00:07 Idle 0 10.2.5.6 4 200 32 35 0 00:17:49 Established 0 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d855ff04317f99c1bff8b47e0eb04240/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3e3384eb6592c75043e079a8444caad/" rel="bookmark">
			VS2019 快速配置Onnxruntime环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考网址：(93条消息) [亲测有效]VS2019/Ubuntu配置Onnxruntime、Opencv_努力的袁的博客-CSDN博客_onnxruntime ubuntu安装
下载Onnxruntime： 当cudnn的版本为10.*时，选择下面链接下载
https://github.com/microsoft/onnxruntime/releases/tag/v1.3.0
当cudnn的版本为11.*时，选择下面链接下载
https://github.com/microsoft/onnxruntime/releases/tag/v1.9.0
注：当出现dlerror:cublas64_10.dll not found类似的错误，有可能是cudnn的版本号与onnxruntime不对应。
这里有所有的onnxruntime下载链接：https://github.com/microsoft/onnxruntime/tags
2. 打开vs新建项目——&gt;右击点击属性——&gt;C/C++属性，添加解压后的include文件路径，注意配置平台的选择。
下图红线框选择x64，配置时，选择相对应选项。（下载onnxruntime的安装包时，也要注意版本的下载）
3. 点击链接器——&gt;附加库目录，添加解压后的lib文件路径。
4. 点击输入——&gt;附加依赖项，将onnxruntime.lib添加进去。
5. 先运行一个简单程序，生成Debug文件(成功则下一步)
选择平台x64
#include &lt;iostream&gt; int main() { printf("hello, onnx!\n"); system("pause"); return 0; } 6. 将onnxruntime.dll放入到项目的Debug或Release下
注意： onnxruntime.dll是放在含有.exe的Debug文件路径下。
7. 验证是否成功
#include &lt;iostream&gt; #include &lt;onnxruntime_cxx_api.h&gt; int main() { printf("hello, onnx!\n"); system("pause"); return 0; } 结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1a702d5dc60a1e15b1632c2dec23614/" rel="bookmark">
			前端算法第五天----线性数据结构的递归遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.链表的递归遍历（常见）
递归遍历,必须有出口
// 链表的递归遍历 function Node(value){ this.value = value; this.next = null; } var a = new Node(1); var b = new Node(2); var c = new Node(3); var d = new Node(4); var e = new Node(5); a.next = b; b.next = c; c.next = d; d.next = e;	function foreachLB(firstNode){ if(firstNode == null) return;//出口 console.log(firstNode.value); foreachLB(firstNode.next); } foreachLB(a); 二.数组的递归遍历（不常用，一般用循环遍历）
// 数组的递归遍历 var arrList = [1,2,3,4,5,6,7,8]; function foreachArr(arr,i){ //i为需要从哪一位开始遍历 if(arrList == null || arrList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1a702d5dc60a1e15b1632c2dec23614/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e13051bcb46fda1b39e2a1b65fce085/" rel="bookmark">
			关于nginx容器日志按天保存的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 nginx 容器日志按天保存 nginx 容器按天保存日志配置： http { # 日志样式 log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; # 按天保存文件 map $time_iso8601 $logdate { '~^(?&lt;ymd&gt;\d{4}-\d{2}-\d{2})' $ymd; default 'nodate'; } access_log /var/log/nginx/access.log main; # 增加一个日志 access_log /var/log/nginx/access${logdate}.log main; 执行效果：
添加一个日志来做按天保存日志的原因是，nignx镜像做了重定向设置，将默认的日志输出到了stdout，所以无法直接保存日志文件，我的做法就是增加一个新的日志来保存。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1001c8ee7aa553323b89f38cd0c6bb4/" rel="bookmark">
			【基于阿里云的远程环境监控系统】一、本地数据采集与设备控制--设备认知及环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地数据采集与设备控制 设备认知及环境搭建CC2530单片机基础本地数据采集ZigBee网络编程 设备认知及环境搭建 设备 ZigBee模块CC2530 温湿度传感器 继电器 WiFi模块ESP8266-01S SmartRF04EB仿真器 USB转TTL
光敏传感器 OLED屏 工具 ZigBee MINI板原理图
CC2530中文数据手册
编译器IAR Embedded Workbench IDE - 8051 10.10.1
环境搭建 安装IAR 右击IAR安装包，选择管理员权限运行
NEXT选择accept
选择安装目录（不建议C盘）
选择 Complete 以安装所有组件
NEXT、INSTALL等待安装完成
弹出下列对话框询问是否安装Dongle驱动，因为暂时没用到，所以选择否
等待安装完成后选择启动IAR，然后点击Finish
若弹出下列对话框，表示已安装了其他版本的IAR，依次选择Don’t remind me …和Close
如果弹出以下提示框，点击取消
激活IAR 点击Help，然后选择授权管理器
在授权管理器中选择离线激活
在以下对话框中输入注册码，可在IAR官网购买注册码，或继续往下阅读。
运行激活软件“IAR_万能KEY”，根据图示步骤生成注册码。注意，在此期间千万别关闭该软件！此软件可能会被杀毒软件杀灭，建议关闭杀毒软件。
将注册码复制到前面步骤弹出的对话框中，如图所示
选择No，不需要关联Dongle（因为没有安装）
选择IAR安装目录，用来保存即将生成的文件
选好目录后点击保存，会生成一个ActivationInfo.txt文件
点击下一步，请求激活响应文件，直接点击下一步即可
对话框表示需要输注册文件（由注册软件生成），跳过此步骤，回到注册软件，根据图示选中由上述步骤生成的ActivationInfo.txt文件
点击“Activate license”，选择安装目录用来保存生成的注册文件
保存完注册文件 ActivationResponse.txt 后弹出如下对话框表示注册成功
将注册文件导入到刚跳过步骤弹出的对话框中
弹出下列对话框表示完成激活
选择否，不需要导出文件
查看是否注册完成，然后点击退出按钮
最后点击Exit退出IAR安装器，关闭注册工具，关闭IAR，然后重启即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05726eb3dc06c334f1cd5f1ed0555000/" rel="bookmark">
			基于verilog的时钟管理电路设计（奇数/偶数分频、门控时钟等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、开源资料下载链接二、行波计数器2.1 行波计数器介绍2.2 设计实例2.3 总结 三、计数分频器3.1 计数分频器介绍3.2 设计实例3.3 总结 四、门控时钟设计4.1 门控时钟介绍4.2伪门控时钟4.3 基于锁存器的门控时钟4.3 基于锁存器的门控时钟设计实例4.4 总结 五、奇数分频器5.1 奇数分频器简介5.2 设计实例5.3 另一种设计思路5.4 总结 文献参考 前言 在许多设计中，常常伴随着对时钟的各种需求，如需要进行偶数倍分频，奇数倍分频；对于时钟的处理也很重要，如何防止时钟截断，时钟毛刺，减少累计时钟偏移；在低功耗设计中，如何降低时钟网络和其中寄存器的功耗；
进而衍生出各种技术，如行波计数器、计数分频器、门控时钟、锁存器门控时钟等待。
在数字设计中，产生时钟信号的方法主要有两种，一种是通过PLL锁相环对时钟源进行分频或倍频，另一种是在设计的模块中用硬件描述语言描述分频逻辑。
在本文中将对这些技术进行简要的介绍，并给出若干设计实例。
一、开源资料下载链接 https://hihii11.github.io/verilog_clockmanager.html
二、行波计数器 2.1 行波计数器介绍 图2.1给出了一个三级行波计数器，每个D触发器的反相输出端~Q与输入端D相连。正向输出端作为下一级触发器的时钟信号。
图2.1 三级行波计数器
这样设计的行波计数器相对于其他分频器来说，其具有以下特点。
1.每级D触发器可对源时钟进行2n分频。
如上图2.1中，
clk1 = clk_source / 2；
clk2 = clk_source / 4；
clk3 = clk_source / 8；
其各级时钟波形如图2.2所示。
图2.2 各级时钟波形
2.资源消耗少
由于行波计数器仅通过若干个触发器级联产生时钟，所以其没有附加的组合逻辑，故消耗资源较少。
3.功耗低
由于行波计数器消耗资源少，故在CLK发生反转时，所带动的处于活跃的组合逻辑部分也较少，因此由这部分逻辑产生的峰值功耗大大降低。
在低功耗设计中常用行波计数器。
行波计数器也存在以下缺点：
1.行波计数器有较严重的级联效应
由于行波计数器的级联结构，其每一级时钟都会产生一定的滞后。
如：
clk1 相较于 clk_source 会产生由U1A所引入的触发器延时及布线延时（tU1A）。
clk2 相较于 clk1 会产生由U2A所引入的触发器延时（tU2A）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05726eb3dc06c334f1cd5f1ed0555000/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94aaceae6ac1f87ef2c0ab3daee1fd8b/" rel="bookmark">
			Mac下Nginx安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 简介： Nginx(“engine x”)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理服务器，也是一个IMAP/POP3/SMTP 代理服务器。在高连接并发的情况下，Nginx是Apache服务器不错的替代品。因为nginx被广泛用于业界和集团内部，所以花了些时间学习了自己搭建配置的过程。
2. nginx下载 下载地址：http://nginx.org/download/nginx-1.11.7.tar.gz
在该页面可以看到三个版本的Nginx，在此我下载的是MainLine version，nginx-1.11.7.tar.gz 压缩包
1、Mainline version(主流版本)
2、Stable version （稳定版本）
3、Legacy versions (历史版本)
3.nginx的安装 系统平台Mac Darwin Kernel Version 15.6.0
解压安装包 tar zxvf nginx-1.11.7.tar.gz
执行./configure 会检查提示是否缺失编译工具、相关依赖，通过提示信息会提示当前的配置信息是什么等，如果有缺失的工具，可以通过Mac的HomeBrew进行安装。
执行make进行编译，然后执行make install进行安装
安装完成后，需要配置相应的环境变量如下，便于快速启动
check配置文件是否正确、nginx是否安装成功
nginx启动、关闭、重启，简单转发，通过sudo nginx 启动服务器，通过ps -ef |grep nginx --color 可以查看nginx相关的进程，浏览器敲127.0.0.1可以访问到默认的nginx欢迎页面。还可以通过nginx -s stop进行关闭服务器,nginx -s reload 重启服务器。
配置目录转发，配置如下，当拦截到的路径的baidu的时候，就会转发到baidu页面
4. nginx配置 首先看一下nignx.conf文件，nginx配置分为全局配置和不同模块的设置，主要模块包含Event模块（events模块中包含nginx中所有处理连接的设置）、HTTP 模块
（HTTP模块控制着nginx http处理的所有核心特性。因为这里只有很少的配置，所以我们只节选配置的一小部分。所有这些设置都应该在http模块中，甚至你不会特别的注意到这段设置）
4.1 全局配置 常见的几个配置如下：
user nobody;
运行用户，一般设置为默认worker_processes auto;
工作线程，一般与与线程数相等worker_rlimit_nofile 100000; 4.2 模块配置 Event模块Http模块 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aea2263d61e9b49894d0d3a4b07d3249/" rel="bookmark">
			Jenkins通过kubernetes plugin连接K8s集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Jenkins安装kubernetes plugin插件 1.1 点击左侧系统管理 1.2 点击插件管理 1.3 安装插件Kubernetes plugin 1.4 安装好后重启Jenkins 浏览器输入http://192.168.0.196:8080/restart，页面点击“是”重启Jenkins
二、进入配置页 2.1 左侧点击系统管理 2.2 点击节点管理 2.3 点击Configure Clouds 三、配置 3.1 下拉框选择Kubernetes 3.2 点击Kubernetes Cloud details…进入配置详情页 3.3 填入认证信息 需要填写红框内的4个内容
Kubernetes 地址 这个通过命令行 查看
kubectl cluster-info 红框内的就是地址
Kubernetes 服务证书 key 为/root/.kube/config中的certificate-authority-data部分，并通过base64加密
终端输入下面的命令查看certificate-authority-data：
cat .kube/config 在执行下面的命令进行base64加密：
echo "certificate-authority-data冒号后面的内容" | base64 -d 红框的内容填入“Kubernetes 服务证书 key”中
Kubernetes 命名空间 使用default默认就好
凭据 这地方需要添加一个凭借
在弹出的页面中类型选Secret text
下面的Secret通过终端添加：
创建一个 kubectl create sa jenkins 获取token名
kubectl describe sa jenkins 获取token值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aea2263d61e9b49894d0d3a4b07d3249/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b813594fc4cf853e06294e476aa6d585/" rel="bookmark">
			open3d-mesh读写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、mesh读取
二、mesh写入
三、支持格式
四、代码示例
一、mesh读取 read_triangle_mesh(filename, enable_post_processing=False, print_progress=False) 从文件中读取三角网格数据
参数：
filename (str):文件名.enable_post_processing (bool, optional, default=False)是否支持后处理print_progress (bool, optional, default=False): 如果设置为true，控制台中会显示一个进度条 返回:
open3d.geometry.TriangleMesh 二、mesh写入 write_triangle_mesh(filename, mesh, write_ascii=False, compressed=False, write_vertex_normals=True, write_vertex_colors=True, write_triangle_uvs=True, print_progress=False) 参数:
filename (str): 写入文件名.mesh (open3d.geometry.TriangleMesh): 目标三角网格数据open3d.geometry.TriangleMeshwrite_ascii (bool, optional, default=False): 设置为True为ascii格式, 否则binary格式.compressed (bool, optional, default=False): 设置为' ' True ' '以压缩格式写入。 write_vertex_normals (bool, optional, default=True): 设置为“False”不写入任何顶点法线，即使在网格上也不写入write_vertex_colors (bool, optional, default=True): 设置为“False”不写入任何顶点颜色，即使网格上存在 write_triangle_uvs (bool, optional, default=True): 设置为' ' False ' '不写入任何三角形uv，即使网格上存在。 对于' ' obj ' '格式，mtl文件只在' ' True ' '设置时保存 print_progress (bool, optional, default=False): 如果设置为true，控制台中会显示一个进度条 返回:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b813594fc4cf853e06294e476aa6d585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90be4d9b82ed571b89cdb0500e0d798c/" rel="bookmark">
			open3d-点云读写和显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，点云读取
二，点云写入
二，点云显示
三、 open3d支持如下点云文件类型
​四、代码及结果示例
一，点云读取 read_point_cloud(filename, format='auto', remove_nan_points=True, remove_infinite_points=True, print_progress=False): 参数:
filename (str): 点云文件路径format (str, optional, default='auto'): 输入文件格式filehe的路径。 如果未指定或设置为“auto”，则从文件扩展名推断格式 remove_nan_points (bool, optional, default=False): 如果True，所有包含NaN的点都将从PointCloud中删除。 remove_infinite_points (bool, optional, default=False): 如果为True，所有包含无限值的点都将从PointCloud中删除 print_progress (bool, optional, default=False): 如果设置为true，控制台中会显示一个进度条 返回: open3d.geometry.PointCloud 默认情况下，Open3D尝试通过文件名扩展名推断文件类型。
pcd = o3d.io.read_point_cloud("../../test_data/my_points.txt", format='xyz') 也可以显式地指定文件类型。 在这种情况下，文件扩展名将被忽略。
二，点云写入 write_point_cloud(filename, pointcloud, write_ascii=False, compressed=False, print_progress=False) 参数:
filename (str): 点云文件保存路径名. pointcloud (open3d.geometry.PointCloud): 目标点云 compressed (bool, optional, default=False): 设置为' ' True ' '以压缩格式写入。 print_progress (bool, optional, default=False):如果设置为true，控制台中会显示一个进度条 返回:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90be4d9b82ed571b89cdb0500e0d798c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f12ae3dbaef0e71259cfdaa59b052ba0/" rel="bookmark">
			利用python爬取京东平台评论及图片并进行分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景及目的 在淘宝、京东等网络平台上购物，逐渐成为大众化的购物方式。但假冒伪劣产品在这个摸不着实物的购物平台严重危害着消费者的购物体验，即使我们可以通过七天无理由退货退款来维护我们的合法权益，但是这样浪费大量的人力和财力。
我们希望能够一次性通过网络购买到心怡的商品，其实我们可以在购买商品之前在对应商品店铺下查看以往买家的购物体验和商品评价，通过商品评价判断该商品是否值得购买。
但是事实并非如此，网络购物平台的一些商家为了吸引顾客购买商品，往往会通过刷假评论诱骗买家，同时也有一大批被‘好评返现’吸引的消费者注入大量注水评论。
虽然往往买家都能够筛选出大部分这样的评论，但人工筛查繁琐、复杂。其实一个好的筛选评论、重构评论的程序能够为消费者提供更真实的商品信息。
二、设计分析 通过搜集资料分析得知淘宝平台相对于京东平台，其反爬性更强。因此，本次设计从京东平台爬取评论、评论晒图进行分析重构制作云图。
即用户输入京东商品链接，程序分析提取出链中的id号，通过链接拼接生成该商品评论的url，从评论中提取出lastpage（评论最后一页），将0到lastpage页分成两部分分给两个线程进行爬取，爬取获得商品评论和商品晒图。
对爬取得到的评论进行筛选，即：
1、对每条评论进行逐字统计，若该评论中某字符反复不正常出现（多于该评论总数的30%）即判定为注水评论；
如评论：“这个衣服特别好看。。。。。。。。”，用户通过多次输入符号‘。’完成商家下达的某种好评返现任务或平台的评价任务，导致字符‘。’反复出现率高达30%；（由于某字符数量过多，分母过大导致比例大于30%）如评论：“好看”，用户仅输入两个字符（字符数少于4）作为评论，其参考价值不大，导致其字符‘好’和字符‘看’字反复出现率高达30%；（总字符数量过少，分子过小导致比例大于30%） 2、对于第一次筛选保留下的评论进行第二次筛选。给定出部分常见词作为好评关键字，统计每条评论的好评次数，若一条评论中好评次数高于5次判定为好评过多； 自定义的好评关键字：GoodComment={'推荐','好用','满意','舒服','喜欢','买它','优惠','很值','赞','精美','回购','漂亮','好看','不错','新款','实惠','速度快','效果好','很舒适','很柔软','很合身','真在用','好','继续买','非常好','很好','质量不错','挺好的','继续购买','特别好','蛮好','一直非常满意','特别好看'}
对绝对好评记两次好评数量，如好评关键字{'满意','非常满意'}在评论‘非常满意’中出现两次，而在评论‘比较满意’中只出现一次，即对绝对好评给予一定的筛选。
3、若单条评论总数少于30字，要求有效评论的好评数不得高于评论总字符数的20%；若单条评论总数大于30字，要求有效评论的好评数不得高于评论总字符数的10%且其单个字符重复出现率不得高于20%；
如评论：“衣服好看，非常满意，还很舒服，买它”，出现好评次数高达5次，而其字符总数为17，判定为刷假评。（由于好评次数过多，分母过大导致比例大于20%）如评论：“好看”，评论总字符为2，好评次数为1，判定为假评论，用户为完成商家下达的某种好评返现任务或平台的评价任务，任务式的评论。（总字符数量过少，分子过小导致比例大于20%） # -*- coding:utf-8 -*- import requests import urllib import time import threading import json import pandas import os import re import jieba import wordcloud from PIL import Image class myThread (threading.Thread): def __init__(self, threadID, name, counter): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.counter = counter def run(self): print ("开始线程：" ) get_information() print ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f12ae3dbaef0e71259cfdaa59b052ba0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61395be04b08245b882bab30b7a5d669/" rel="bookmark">
			Golang Gin框架搭建项目（五）jwt登录和权限验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、AuthUtil.go ： 用于生成和解析token
package utils import ( "fmt" "github.com/golang-jwt/jwt" "time" ) //自定义格式内容 type CustomerClaims struct { UserId int `json:"userId"` UserName string `json:"userName"` RoleId int `json:"roleId"` StandardClaims jwt.StandardClaims } func (c CustomerClaims) Valid() error { return nil } //生成token func GenerateJwtToken(secret string, issuer string, audience string, expiredMinutes int64, userId int, userName string, roleId int) (string, error) { hmacSampleSecret := []byte(secret) //密钥，不能泄露 token := jwt.New(jwt.SigningMethodHS256) nowTime := time.Now().Unix() token.Claims = CustomerClaims{ UserName: userName, UserId: userId, RoleId: roleId, StandardClaims: jwt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61395be04b08245b882bab30b7a5d669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad4eb7cc66518d4fd03321a6f5b2eb65/" rel="bookmark">
			eclipse中导入项目（传智书城为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、数据库引用
二、eclipse中导入项目
三、项目导入后的环境配置
1.jar包修改
2.jre和jdk修改
3.tomcat服务器修改​​​​​​​
4.编码方式修改
四、运行效果
引言：在开始教程前，请确保电脑中装有mysql、Navicat、eclipse，并且eclipse中配置好tomcat服务器。另外，本人mysql版本为5.0，8.0以及上版本需要修改导入的jar包和修改相应的连接字符串，本教程以导入传智书城项目为例。
一、数据库引用 引用其资源文件中自带的数据库文件
以记事本方式打开.sql后缀的文件，复制里面的内容。打开Navicat，点击左上角新建查询，将文本粘贴进去，点击运行 。运行成功后重启Navicat即可看到数据库已经导入成功。
没有Navicat可以在命令行中打开mysql，同样的粘贴过去运行即可，Navicat只是便于可视化操作。 二、eclipse中导入项目 打开eclipse，左上角File——import
​​​​​​​ ​​​​​​​ ​​​​​​​ ​​​​​​​ 在弹出的界面中选择Existing project into workspace，将现有项目导入工作空间，点击next下一步
在下一步中，browse选择项目目录，中间勾选要导入的项目，下面选择Copy projects into workspace，将项目复制进工作空间，这样源项目文件就还在
三、项目导入后的环境配置 导入项目后，因为原环境和现在我们的工作空间环境配置不一样，所以需要修改，修改的地方主要有jar包、tomcat服务器、jre和jdk版本、编码方式
右击项目，点击properties，打开编辑环境变量页面
1.jar包修改 点击Java Build Path，在Libraries页面中，如果包出现错误，选中错误的包，点击右下角Remove删除，再点击右侧Add JARs，从中选择项目文件目录下的包（如果目录下没有包，代表该包已经导入到项目中。如果要新添加包到项目，把包放到对应文件目录下，再Add JARs选择它加入）
2.jre和jdk修改 在Libraries，点击JRE System，点击Edit，在弹出的页面中点击第二个Alternate JRE，在下拉框中选择下载的JDK版本
再点击左侧，Java Compile，在页面中选择和JDK对应的jre版本，JDK8对应jre1.8
3.tomcat服务器修改 在Libraries页面中选中Server Runtime，点击Edit…，在里面选择tomcat服务器
值得一提的是，tomcat服务器的jre要和上面配置的jdk一致，上面我的tomcat8.5（2）就是因为原来的jre不对应，所以新建了一个tomcat。
点击底部Server，删除原来tomcat后，点击蓝色超链接，在页面中点击Add
​​​​​​​
点击下拉框，选择下载的jdk版本
4.编码方式修改 点击左侧Resource，原本是默认编码的，点击other，选择UTF-8编码
四、运行效果 最后，简单的修改下c3p0连接池中的密码为自己的数据库密码
在项目上右击，Run As运行
运行成功
​​​​​​​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e85a9c841ff8deda9ae2127619ff8270/" rel="bookmark">
			yum下载安装应用失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错中显示是yum源的问题，对应的镜像库中无法找到对应的repomd.xml文件，原centos/6/ 下已经没有相关的文件，尝试修改本地镜像配置文件
vim /etc/yum.repos.d/CentOS-Base.repo 因为$releasever 获取的是centos的版本号，我的centos获取的版本为6，但是镜像站中无对应版本文件，因此需要修改本地配置文件
:%s/$releasever/7/g # 将文件中$releasever全部改成7或其他版本 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da8f9a42af6605ae21ed7fccd094ccbd/" rel="bookmark">
			Vue中子组件给父组件传参数————props和自定义事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
相较于props，用自定义事件的方法实现子组件给父组件传参更合理和方便，但props也确实可以实现 ‘子传父’。
例子中一共有三个组件 App组件，Helloworld组件，ChildrenVue组件。app组件管理后两个组件
APP组件中的内容
//App.vue ... &lt;HelloWorld :msg="msg"&gt;&lt;/HelloWorld&gt; &lt;ChildrenVue&gt;&lt;/ChildrenVue&gt; ... import HelloWorld from './components/HelloWorld.vue' import ChildrenVue from './components/ChildrenVue.vue'; export default { name: 'App', data(){ return { msg:'Hollo,I`m a Vue.js app.' } }, components: { HelloWorld, ChildrenVue } } ... HelloWorld组件中的内容
//HelloWorld.vue ... &lt;div class="hello"&gt; &lt;h1&gt;{{msg}}&lt;/h1&gt; &lt;/div&gt; ... export default { name: 'HelloWorld', props: { msg: {type:String, default:'Send message to me,OK?'}, } 。} ... ChildrenVue组件中的内容
... &lt;div id="children"&gt; &lt;/div&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da8f9a42af6605ae21ed7fccd094ccbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae7d042eb1f0d334aba83fffeef7cc71/" rel="bookmark">
			掌握IPV6只需记住这三点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是IPv6？
IPv4与IPv6相同，用于在网络中标识机器的编号
IPv4地址长度是32bit,IPv6地址长度是128bit,所以IPv6地址比v4地址多得多
PART01 IPv6书写规则
①用冒号(：)分隔,每部分16bit
1111 : 2222 : 3333 : 4444 : 5555 : 6666 : 7777 : FFFF
②0000=0 ---压缩格式
1111:0000:0000:0000:0000:0000:AAAA:BBBB = 1111:0:0:0:0:0:AAAA:BBBB
③用一对冒号(::)表示连续的0,但每个IPv6地址只能用一次
1111:0:0:0:0:0:AAAA:BBBB=1111::AAAA:BBBB 1111:0:0:cccc:0:0:DDDD:9999=1111::CCCC:0:0:DDDD:9999=1111:0:0:CCCC::DDDD:9v
PART02 如何配置IPv6地址
(1)静态配置:手敲
(2)无状态地址自动配置(SLAAC):
(3)状态化DHCPv6: 参考IPv4的DHCP
(4)无状态DHCP:主机可获取如TFTP服务器 、WINS等其他参数
注:不要纠结状态二字,相比IPv4,v6多出了两个重要特征,一是SLAAC,二是可以获取更多参数(对比IPv4的四大参数)
(1)静态配置通常用于路由器接口,主机一般用地址自动配置
(2)SLAAC就是主机利用RA来配置自己的地址
（如下图:本地链路上,路由器通过RA信息,向所有节点提供网络类型信息(如本地链路的前缀和默认路由)
主机可通过RA提供的前缀以及mac地址构建自己独一无二的IPv6地址
PART03 IPv4→IPv6 IPv6可以与现有的IPv4网络共存过渡
双栈
配置设备同时支持允许IPv4和IPv6,应用会根据DNS请求的响应消息，来决定是使用IPv4还是IPv6。应用会根据IP流量的类型选择正确的地址
隧道
将IPv6流量封装在IPv4中,主要用于通过IPv4骨干网相连的IPv6站点之间进行通信
转换
地址族转换---AFT
IPv6地址和IPv4地址相互转换
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3c71beb06b3e462c4780a6171324d27/" rel="bookmark">
			运维面临挑战？智能运维管理系统来帮您
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能运维是未来的发展趋势。近年来运维技术飞速发展，运维团队大多数都经历建设了各种系统、虚拟化、容器化以及持续集成等。为了解决运维的难题，智能运维管理系统越来越受欢迎。它集成了性能监控、故障告警、报表管理、分析和预测一体化等功能，可以提高现有IT资源利用率、防止应用停机、及时发现故障、增强业务系统安 全性等。
智能运维可以通过APP一手掌控，无论何时何地，随时移动操作，提供实时IT资源健康状况以及全域IT资产告警总览。应用行业非常广泛,比如银行、地产、保险、园区、政府、军工、制造、医疗、教育等。
监控易智能运维- 统一监控运维平台
智能运维管理系统可以实现统一化管理，轻松面对各种复杂的网络环境以及故障，实时展现整体系统动态运行情况，快速实现故障恢复。
现在IT运维面临的挑战有很多，比如故障问题难以追踪及定位、缺乏问题解决的协作流程、机械性重复操作较多、资产管理杂乱、管理工具太多等，缺乏统一的管理平台，导致运维效率不高。
为了解决运维中的烦恼，智能运维管理系统诞生，提供设备管理、机房管理、知识库、工单管理、IP地址管理、视频监控运维、资产管理、分析数据、大屏展现、拓扑管理、监控等专业模块，通过整合、人员和技术，进行科学有效管理，实现信息化、自动化、智能化，提升工作效率以及用户满意度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d81f8f5f8cd9fc0357db5e6dd3e46108/" rel="bookmark">
			Android的六大布局详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 安卓六大布局线性布局（LinearLayout）线性布局常用的属性android:layout_weight 属性的一些说明分割线设置线性布局示例 相对布局(RelativeLayout)相对布局的一些常用属性有：按父容器定位示意图按兄弟组件定位示意图margin与padding的区别相对布局示例 表格布局 (TableLayout)常用属性如何确定所需的行数和列数表格布局的示例 帧布局(FrameLayout)常用属性帧布局示例 网格布局(GridLayout)常用属性用法归纳网格布局示例 绝对布局(AbsoluteLayout)常用属性 安卓六大布局 线性布局（LinearLayout） 在线性布局中，每一行（针对垂直排列）或每一列（针对水平排列）中只能放一个组件，Android的线性布局不会换行，当组件排列到窗体边缘后，后面的组件不会被显示出来。
线性布局常用的属性 属性说明可选值android:orientation用于设置布局管理器内组件的排列方式horizontal(水平排列)和vertical(垂直排列)默认值为verticalandroid:gravity设置布局管理器内组件的对齐方式top、bottom、left 、right、center_vertical、fill_ vertical、center_horizontal、fill horizontal、center、 fill、 clip_vertical 和clip_ horizontal；支持组合属性(要指定组件靠右下角对齐，可以使用属性值rightlbottom)android:layout_width用于设置组件的基本宽度fill_parent(该组件的宽度与父容器的宽度相同)、match_parent(该组件的宽度与父容器的宽度相同) 和wrap_content(该组件的宽度恰好能包裹它的内容)android:layout_height用于设置组件的基本高度fill_ parent(该组件的高度与父容器的高度相同)、 match parent(该组件的高度与父容器的高度相同)和wrap_content(该组件的高度恰好能包裹它的内容)android:layout_gravity该组件在父容器里的对齐方式同gravityandroid:id用于为当前组件指定一个 id属性，在Java代码中可以应用该属性单独引用这个组件。为组件指定id属性后，在R.java文件中，会自动派生一个对应的属性，在Java代码中，可以通过findViewById()方法来获取它。android:background用于为组件设置背景，可以是背景图片，也可以是背景颜色。android:layout_weight用于等比例划分区域整数（0，1，2等）android:divider为布局设置分割线，一般为一张分割线图片android:showDividers设置分割线的位置none(无),beginning(开始),end(结束),middle(每两个组件间)android:dividerPadding设置分割线的Padding 其中android:layout_width 、android:layout_height、android:layout_weight 是ViewGroup.LayoutParams所支持的XML属性,因此在Java代码中设置这些属性值时，一般需要这样声明：
setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT, 1)); android:layout_weight 属性的一些说明 设置android:layout_width="0dp"和android:layout_width="wrap_content" 属性下
如果在设置这个属性的情况下，即自适应和无宽度情况下再设置android:layout_weight 属性时使用是比较容易理解的，我们设置比重值后，组件会根据自身的大小结合我们的比重值加上 LinearLayout的orientation是水平还是竖直,决定哪个方向等比例划分 &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/LinearLayout1" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;LinearLayout android:layout_width="0dp" android:layout_height="fill_parent" android:background="#ADFF2F" android:layout_weight="1"/&gt; &lt;LinearLayout android:layout_width="0dp" android:layout_height="fill_parent" android:background="#DA70D6" android:layout_weight="2"/&gt; &lt;/LinearLayout&gt; 2. 而在设置 android:layout_width="match_parent"后，则需要进行计算，为什么需要计算呢？我们来看这个例子
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/LinearLayout1" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;TextView android:layout_weight="1" android:layout_width="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d81f8f5f8cd9fc0357db5e6dd3e46108/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8d7704e621da6f8e37ce6181188addc/" rel="bookmark">
			glTF格式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介.gltf+bin+纹理assetscene, scenes, nodesmaterialsmeshestextures, images, samplersaccessors, buffers, bufferViewscameras 压缩优化图片压缩EXT_meshopt_compression 总结 简介 本文主要通过总结glTF文件格式来对3d模型有一个整体的认识概念，对glTF有了一个清晰的概念后我们可以简单试下如何解析一个glTF文件为模型，并且简单介绍下我对glTF文件在实际项目中应用优化的落地实践。
glTF作为一个标准的3d场景和模型文件格式，类似于图形中的jpeg，有两种文件扩展名：.gltf(JSON/ASCII)或者.gbl（二进制文件）两种类型。下图我们可以看到我在blender里简单放了一个cube后导出glTF2.0文件的话可以选择以下三种格式：glTF二进制（.glb）、glTF分离（.gltf+bin+纹理）、glTF嵌入式（.gltf）。
.gltf+bin+纹理 由于glb和glTF嵌入式主要是把所有的二进制 纹理数据全部打入到了一个文件中，道理是一样的，所以我们这里重点来拆解gltf+bin+纹理结构类型。
我们先来看一个.gltf+bin+纹理图片的文件目录例子，.gltf其实就是一个json文件，里面包括了3d 模型的场景的结构和组成。我们先来看这个json文件下的top-level elements：
这其中包含了一个模型场景中必备的几个元素：
asset标签里介绍了glTF版本这些基础信息；
scene，scenes，nodes标签里包含了一个场景的基本元素；
materials标签里包含了每个对象是如何呈现出来的定义；
meshes 标签里定义了所有的3d对象的几何形状；
textures, images, samplers标签里包含了物体的表面外观，贴纸等信息；
accessors, buffers, bufferViews标签里包含了整个3d模型场景里的数据引用和数据布局的描述。
当然还有我这个gltf里不包括的，也很常见的几个标签元素：
cameras 标签里包含了查看场景的配置信息；
上面标签信息我们下文都会有各自的案例介绍来帮助大家更全面的理解。
asset glTF2.0版本以及是blender导出的等基础信息。关于glTF2.0与1.0的更新区别 可以参考这里。
scene, scenes, nodes 我们先来看我们这个gltf文件的结构
这代表我们scene里有一个场景，这个场景下包括了19个nodes节点，具体每个节点的属性我们看nodes节点，
nodes作为一个jsonArrayList包括了rotation旋转信息，scale大小 信息，translation位移信息等。然后每个节点都会指向一个mesh或者一个camera，上图中我们的模型中的nodes就指向的是meshid为0，name为转义过后的\ue573\u9762的mesh。然后在渲染的时候会将这些元素全部附加到这些个节点上，创建这些元素的实例就会使用节点上的各种旋转信息，大小信息，位移信息等进行变换了。
当然如果你的模型中出现group的时候，那么你的nodes下的节点会出现children，children是一个数组，里面的id对应的是nodes节点下的nodes[x]，即为nodes[x]是有children的节点的children。
另外在模型场景中如果我们对某个mesh做动画的话，这里的translation，scale，rotation都是可变的，会随着动画的进行而重新建模。
materials ok我们接下来来看materials，在3d设计中，要创造出逼真的效果，就必须弄清楚材质属性。材质的意思就是虚拟中模拟物体真实的物体性质，例如颜色、反光、透明、贴图等；而材质球就是对这个材质的属性整合的统称。
这里我们重点来看pbrMetallicRoughness属性，baseColorTexture属性是应用于对象的主要纹理，基本颜色因子包括了三个基础颜色，RED GREEN BLUE和代表alpha的比例因子。如果没有使用纹理的话，这些值的意思就是金属粗糙度纹理的颜色。粗糙度纹理包含金属度值“蓝色”颜色通道，粗糙度值包含“绿色”颜色通道。
metallicFactor代表了金属系数，很明显我们上面的模型中金属系数为0。
当然除了金属粗糙度以外，material可能还包括其他影响对象外观的特性，这里建议直接在threejs editor里调整好再用于开发，editor上可以很直观的看到金属感和粗糙度上变更后效果的差异。
meshes mesh的意思其实就是模型的几何体，与material配合，每个网格图元都有一个渲染模式，该模式是一个常量，指示是否应渲染为点。线。或三角形基本体还引用顶点的音调和属性，使用访问器的属性来访问其数据。这里我们主要来看primitives属性，primitives引用了顶点的vertices和属性，使用访问器的属性就可以直接访问他的数据了。每个属性都是通过将attributename映射到包含属性数据的访问器的索引来定义的。渲染网格时，此数据将用作顶点属性。例如，属性可以定义顶点的位置和法线：
textures, images, samplers textures包含有关可应用于渲染对象的纹理的信息：材质引用纹理来定义对象的基本颜色，以及影响对象外观的物理属性。
这些图像定义了用于纹理的imagedata，数据通过一个URI(图像在文件中的位置)来给定，或者通过引用一个bufferView和一个MIME类型来定义存储在缓冲区视图中的iamgedata类型。这个很好理解
accessors, buffers, bufferViews buffers包含了用于三维模型几何体、动画和蒙皮的数据缓冲区视图等结构信息。每个缓冲区使用URL引用一个二进制数据文件。它是一个原始数据块的源，每个缓冲区视图引用一个缓冲区。它是字节偏移量（byteoffset）和字节长度（abytelength），定义属于bufferview的缓冲区的部分，以及可选的Openglbuffer目标。访问器定义如何对bufferview的数据进行交互。它们可以定义引用bufferview开始的附加字节偏移量，并包含有关bufferview数据类型和布局的信息。
其实可以这么理解，例如，当类型为“VEC2”且组件类型为GL FLOAT（5126）时，可以将数据定义为浮点值的二维向量。所有值的范围存储在“最小值”和“最大值”属性中。多个存取器的数据可以在bufferview中交错。在这种情况下。bufferview将有一个bytestride属性，该属性表示Accessor的一个元素的开头之间有多少字节。
cameras camera总共分为两种，透视相机和正交相机，它们定义了投影矩阵。透视camerazfar的远剪裁平面距离的值是可选的。当省略时，摄像机会为无限投影使用一个特殊的投影矩阵。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8d7704e621da6f8e37ce6181188addc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96120033ce16f8aa1d7df5c2ee88782d/" rel="bookmark">
			三、python数据序列1-列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 列表的格式 [数据1, 数据2, 数据3, 数据4......] 列表可以一次性存储多个数据，且可以为不同数据类型。
二. 列表的常用操作 列表的作用是一次性存储多个数据，程序员可以对这些数据进行的操作有：增、删、改、查。
2.1 查找 2.1.1 下标 name_list = ['python', 'c++', 'java'] print(name_list[0]) # python print(name_list[1]) # c++ print(name_list[2]) # java list1 = ['蜘蛛侠', '环太平洋', '海王', '复仇者联盟'] print(list1[2], list1[-2]) # 正向下标，从0开始 # 负向下标,从-1开始 2.1.2 函数 index()：返回指定数据所在位置的下标 。 语法 列表序列.index(数据, 开始位置下标, 结束位置下标) 快速体验 name_list = ['Tom', 'Lily', 'Rose'] print(name_list.index('Lily', 0, 2)) # 1 注意：如果查找的数据不存在则报错。
count()：统计指定数据在当前列表中出现的次数。 name_list = ['Tom', 'Lily', 'Rose'] print(name_list.count('Lily')) # 1 len()：访问列表长度，即列表中数据的个数。 name_list = ['Tom', 'Lily', 'Rose'] print(len(name_list)) # 3 sum()，对列表求和，sum(list)max()，求最大值，列表里面必须是同类型。max(list)min()，求最小值。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96120033ce16f8aa1d7df5c2ee88782d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2978b61a15889474863b9ecc9d605a0/" rel="bookmark">
			ElasticSearch 通用化批量存储封装设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ElasticSearch 通用化批量存储封装设计 一、设计需要满足的功能场景二、约定三、功能封装1、枚举2、定义接口3、功能实现 一、设计需要满足的功能场景 为了满足在工作中，不用频繁的去写繁琐的 ES 存储的代码，一切都是为了偷懒，闲暇之余（想多了）经过多方考虑，将 ES 的存储进行了通用化封装。
封装必须保证通用型，绝大多数场景都能够直接通过调用来实现存储，而不再需要大量编码封装的入参应该越简单越好，封装一定要保证好用可以牺牲一定的灵活性以保证标准化以及易用性 二、约定 所谓的约定，就是牺牲一定的灵活性，以保证排除不可控性，来保障封装的可用，易用性
约定如下：
ES 内存储的字段，代码中必须存在对象且字段与 ES 字段一一对应。这么做的目的不言而喻，一方面保证代码的可读性，易读性，ES 内的字段可以通过代码中 ES 对象很直观的看出有哪些字段，且不参杂其他乱七八糟的无用数据。另一方面，通过这种标准化的对象，能够保证 ES 内数据的精确性，大幅度降低出问题的风险，也易于排查问题。对象中尽量以 id 字段作为 ES 的 _id。 这一点虽然很想定死，但是考虑到可能确实存在此参数需要灵活定义的情况，所以做了一些妥协，通过配置的形式指定，默认就配置为 id 即可。枚举标准化。 将所有可自定义的参数标准化到枚举中，配置时以枚举来配置，这样便于维护，不至于各写各的乱七八糟。 三、功能封装 1、枚举 indexName： 很明确，ES 对应的索引名称。name： 索引的名称，让别人明确知道这个索引是什么东西的索引干什么用的，起到一个说明的作用。clazz： ES 对象对应的类，就是前文约定的标准化类。idFieldName： _id 对应字段映射 /** 1. ES索引枚举 */ @Getter @AllArgsConstructor public enum EsIndexEnum { EsTestDTO("xxxx", "xx列表", EsTestDTO.class, "id") ; /** * 索引名 */ private String indexName; /** * 名称 */ private String name; /** * ES数据对象对应Class类型 */ private Class clazz; /** * _ID对应字段映射 */ private String idFieldName; } 2、定义接口 定一个一个单条处理的接口，一个批量处理的接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2978b61a15889474863b9ecc9d605a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/258f21db89001ae56458f65080449dce/" rel="bookmark">
			MNIST数据集mnist_784关于X[0]的bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景：MNIST数据集mnist_784X[0]bug 自学mnist_784的时候，遇到了这个问题，X[0]总是出bug
问题描述 源代码如下
# Python ≥3.5 is required import sys assert sys.version_info &gt;= (3, 5) # Scikit-Learn ≥0.20 is required import sklearn assert sklearn.__version__ &gt;= "0.20" # Common imports import numpy as np import os import cv2 # to make this notebook's output stable across runs np.random.seed(42) # To plot pretty figures %matplotlib inline import matplotlib as mpl import matplotlib.pyplot as plt from sklearn.datasets import fetch_openml mnist = fetch_openml('mnist_784', version=1) mnist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/258f21db89001ae56458f65080449dce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1183ec9201d282543ef6dcaa63e8db37/" rel="bookmark">
			pytorch实现FLOPs和Params的计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 FLOPS：指每秒浮点运算次数，理解为计算速度，是一个衡量硬件性能的指标。 计算公式： 对卷积层：(K_h * K_w * C_in * C_out) * (H_out * W_out) 对全连接层：C_in * C_out FLOPs： 注意s小写，指浮点运算数，理解为计算量。可以用来衡量算法/模型的复杂度。Params：是指模型训练中需要训练的参数总数。 模型参数量计算公式为： 对卷积层：（K_h * K_w * C_in）* C_out 对全连接层：C_in * C_out 代码实现 方法1 使用thop库
pip install thop import torch from torchvision import models from thop import profile if __name__ == '__main__': net = models.mobilenet_v2() inputs = torch.randn(1, 3, 224, 224) flops, params = profile(net, inputs=(inputs, )) print("FLOPs=", str(flops/1e9) +'{}'.format("G")) print("params=", str(params/1e6)+'{}'.format("M")) 方法2 使用torchstat库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1183ec9201d282543ef6dcaa63e8db37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a47557671ea0652b08ed89cac1b5d88/" rel="bookmark">
			gorm事务体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 gorm事务中文文档
表 CREATE TABLE `accounts` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(10) NOT NULL, `money` decimal(30,2) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 没有事务 package main import ( "fmt" "gorm.io/driver/mysql" "gorm.io/gorm" "gorm.io/gorm/logger" "log" "os" "time" ) type Account struct { ID uint `gorm:"primarykey"` Name string `gorm:"type:varchar(10);not null"` Money float64 `gorm:"type:decimal(30,2);not null"` } func main() { // 连接对应的数据库 dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local", "root", "root", "127.0.0.1", 3306, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a47557671ea0652b08ed89cac1b5d88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0186540c2c2a9d24a8d23235233e76e/" rel="bookmark">
			S32K开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、S32DS环境安装 一、S32DS环境安装 进入恩智浦官网https://www.nxp.com.cn/
（需要在官网注册一个账号）
点击产品，再点击S32汽车平台
下载安装程序
这里是许可证信息，里面有激活码，安装软件的时候需要用到激活码建议复制一下
2、在下载完S32DS安装程序后，双击打开一直NEXT即可
在安装的时候弹出激活页面的时候把从上图复制的激活码粘贴上去确定即可。
3、安装成功之后打开软件，对于弹窗都直接关闭即可，点击help查看许可证
看到如下界面就是已经安装成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/928108cb52672ce4387facd9db23a7af/" rel="bookmark">
			将本机系统打包成docker镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 创建docker镜像 1.1进入要打包的系统 ， 进入根目录，查看需要打包的系统文件 cd / 1.2 打包系统镜像为.tar包 打包 ： tar -cvpf /docker/system.tar --directory=/ --exclude=docker --exclude=proc --exclude=temp --exclude=sys --exclude=run . 拷贝到电脑 ： scp system.tar xxx@10.170.245.160:/Users/xxx/Downloads/共享文件夹/docker 其中，--directory 是打包目录，--exclude 指定不打包的目录。将系统打包成tar包。
2. 上传docker镜像到服务器 服务器信息： 10.170.xxx.xxx 22 导入镜像： docker import system.tar xxx-acr-ee-registry.cn-beijing.cr.aliyuncs.com/docker/dockercontainer:docker_031703 检查镜像： docker images|grep docker 推送镜像： docker push xxx-acr-ee-registry.cn-beijing.cr.aliyuncs.com/docker/dockercontainer:docker_031703 import 将tar包导入到镜像中，后面为镜像的名称和标签
docker images 查看是否有镜像和标签
转载：https://www.csdn.net/tags/Mtzakg5sMjExNjEtYmxvZwO0O0OO0O0O.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0836b5f389f4ac56156ca5ea3a4e77b0/" rel="bookmark">
			关于ArcMap中道路、河道中心线提取过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 数据来源：三调数据
2 问题描述：根据出图要求，需将道路，河流面状要素中心线提取出来
3 解决过程
3.1 准备工作
3.1.1 为了后面重分类，铁路面状要素新建字段recg，赋值1
3.1.2 新建要素线
3.1.3 加载ArcScan工具
3.2 面转栅格
3.3 重分类
3.4 使用ArcScan工具
3.4.1 开始编辑
​3.4.2 Vectorization（矢量化）
1 数据来源：三调数据 2 问题描述：根据出图要求，需将道路，河流面状要素中心线提取出来 3 解决过程 3.1 准备工作 3.1.1 为了后面重分类，铁路面状要素新建字段recg，赋值1 3.1.2 新建要素线 为了后面生成中线，这里新建了铁路线
3.1.3 加载ArcScan工具 3.2 面转栅格 1、Conversion Tools-To Raster-Polygon to Raster
2、Value field，选择新建属性字段；Cellsize，自定义修改。
3.3 重分类 Spatial Analyst Tools-Reclass-Reclassify
Input raster，选择之前面转栅格的图层
Reclassification，Old Values中Nodata值设置成0，其他值设置为1
3.4 使用ArcScan工具 3.4.1 开始编辑 开始编辑，选择之前新建的线图层“铁路线 ”
开始编辑之前矢量化的状态：
开始编辑之后矢量化的状态：
3.4.2 Vectorization（矢量化） 1. Vectorization-Vectorization Settings
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0836b5f389f4ac56156ca5ea3a4e77b0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/227/">«</a>
	<span class="pagination__item pagination__item--current">228/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/229/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>