<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ce48cf71c8361d7021ace6c4cca8783/" rel="bookmark">
			哥德巴赫猜想C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.每个不小于6的偶数都可以表示为两个奇素数之和；
2.每个不小于9的奇数都可以表示为三个奇素数之和。 #include&lt;stdio.h&gt; #include&lt;math.h&gt; int check(int n){//判断奇素数 int i; if(!(n%2))//判断奇数 return 0; else{ for(i=2;i&lt;=(int)(sqrt(n));i++){//判断素数 if(!(n%i)) return 0; } } return 1; } void check1(int n){ int i,j,k; for(i=3;i&lt;n-5;i++){ for(j=i;j&lt;n-5;j++){ for(k=j;k&lt;n-5;k++){ if((i+k+j==n)&amp;&amp;check(i)&amp;&amp;check(j)&amp;&amp;check(k)){ printf("%d %d %d\n",i,j,k); } } } } } void check2(int n){ int i,j; for(i=3;i&lt;n-2;i++){ for(j=i;j&lt;n-2;j++){ if((i+j==n)&amp;&amp;check(i)&amp;&amp;check(j)){ printf("%d %d\n",i,j); } } } } int main(){ int n; puts("请输入不小于6的偶数或不小于9的奇数"); scanf("%d",&amp;n); if(n%2) check1(n); else check2(n); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5c52fafb2e70431967d1870d58d94de/" rel="bookmark">
			基于HDMI的视频流输入输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本实验基于ECE-CV K7-75T FPGA开发板实现。
软件使用Vivado 2018.1。
基于HDMI的视频流输入输出实验
1 HDMI概述
HDMI高清多媒体界面（英语：High Definition Multimedia Interface）是一种全数字化视频和声音发送接口，可以发送未压缩的音频及视频信号。HDMI可用于机顶盒、DVD播放机、个人计算机、电视游乐器、综合扩大机、数字音响与电视机等设备。HDMI可以同时发送音频和视频信号，由于音频和视频信号采用同一条线材，大大简化系统线路的安装难度。
图1 HDMI硬件实物
如图1，红框为ECE-CV板的HDMI输入输出接口，最高支持到1080P@60HZ的图像输入和输出功能。
图2 HDMI_IN 和HDMI_OUT原理图
如图2所示为ECE底板的HDMI_IN和HDMI_OUT的原理图，下面对ECE-EDA和ECE-CV的HDMI接口的引脚介绍如表1所示：
表1 ECE-CV板HDMI接口引脚介绍
信号名称
Kintex7引脚标号
电平
备注
HDMI_RX0_P
R25
TMDS_33
HDMI接收数据0正
HDMI_RX1_P
T24
TMDS_33
HDMI接收数据1正
HDMI_RX2_P
T22
TMDS_33
HDMI接收数据2正
HDMI_RX_CLK_P
N21
TMDS_33
HDMI接收时钟正
HDMI_RX_CEC
P24
LVCMOS33
HDMI遥控器信号
HDMI_RX_HPD
N24
LVCMOS33
HDMI热插拔检测信号
HDMI_RX_SDA
M25
LVCMOS33
HDMI IIC数据
HDMI_RX_SCL
L25
LVCMOS33
HDMI IIC时钟
HDMI_TX0_P
M21
TMDS_33
HDMI发送数据0正
HDMI_TX1_P
N19
TMDS_33
HDMI发送数据1正
HDMI_TX2_P
P16
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5c52fafb2e70431967d1870d58d94de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37395ced3148e930e4610226b1ac6f73/" rel="bookmark">
			NumPy IO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NumPy IO Numpy 可以读写磁盘上的文本数据或二进制数据。
NumPy 为 ndarray 对象引入了一个简单的文件格式：npy。
npy 文件用于存储重建 ndarray 所需的数据、图形、dtype 和其他信息。
常用的 IO 函数有：
load() 和 save() 函数是读写文件数组数据的两个主要函数，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npy 的文件中。savze() 函数用于将多个数组写入文件，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npz 的文件中。loadtxt() 和 savetxt() 函数处理正常的文本文件(.txt 等) numpy.save() numpy.save() 函数将数组保存到以 .npy 为扩展名的文件中。
numpy.save(file, arr, allow_pickle=True, fix_imports=True) 参数说明：
file：要保存的文件，扩展名为 .npy，如果文件路径末尾没有扩展名 .npy，该扩展名会被自动加上。arr: 要保存的数组allow_pickle: 可选，布尔值，允许使用 Python pickles 保存对象数组，Python 中的 pickle 用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化。fix_imports: 可选，为了方便 Pyhton2 中读取 Python3 保存的数据。 实例 import numpy as np a = np.array([1,2,3,4,5]) # 保存到 outfile.npy 文件上 np.save('outfile.npy',a) # 保存到 outfile2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37395ced3148e930e4610226b1ac6f73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48ead37abe1aab949649b3642940c744/" rel="bookmark">
			ALLEGRO 直接转PADS方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 添加用户变量 变量名：AEX_BIN_ROOT 值： PADS软件中translators软件的bin目录路径 比如我的：AEX_BIN_ROOT= C:\MentorGraphics\9.5PADS\SDD_HOME\translators\win32\bin 添加 用户变量 变量名：AEX_ENABLE_JOBPREFS_LAYER_FIX 值：1 比如我的：AEX_ENABLE_JOBPREFS_LAYER_FIX =1 添加用户变量 变量名：Home 值：Cadence软件的pcbenv文件夹所在目录的路径 如我的：Home= C:\Cadence 打开PADS软件自带的Allegro 转换的skill文件 如我的：C:\MentorGraphics\9.5PADS\SDD_HOME\translators\skill_scripts 上面目录的文件全部复制到allegro 下面这个目录下 C:\Cadence\pcbenv 准备工作已经完成了。以后转换的话，就不需要再设置了-----------转换开始了。。。 在Allegro的command命令栏中输入skill load "dfl_main.il",回车后，会看到返回T。 注意，输入时，引号不能少，load和引号间是有空格的 上面确定有返回一个 t 后。继续下面 继续在Command中输入：main out 回车，这时会弹出一个对话框： 点击“StarOne Way Translation” ，等待运行结束 ， 运行过程中不能有报错，如果有报错请查找原因并修正，运行成功后commend命令栏提示成功，DONE （这里特别提醒：ALLEGRO的文件路径和文件名不要有中文特殊符号等，否则失败） 等待上面的结束。。 之后打开PADS LAYOUT ---file---import 之后等待转换结束即可。 转换完成，打开PCB文件了。 有一些 版本的PADS 自带 Skill 有问题，如果有问题的请下载我下面这个。这个是验证过绝对OK的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38243b7868564a29696a276a6d8fc501/" rel="bookmark">
			win10家庭版升级到专业版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10家庭版升级到专业版
思路:
断网升级
写入注册文件
联网激活
更改方法：
1.开始 设置 更新和安全 激活 更改产品密钥 输入密钥 开始升级 （全过程断开网络连接）
这里提供密钥（网上找的）
win10专业版安装密钥：VK7JG-NPHTM-C97JM-9MPGT-3V66T
使用激活软件写入注册表，然后联网激活
（会显示激活失败，然后输入密钥激活）
链接：https://pan.baidu.com/s/1KgE8cq4EaA1NpvLoIDg2iA 密码：4s3z
完成后查看激活状态 win处于通知状态(未激活)
再打开 设置 更新和安全 激活 重新输入密钥 （联网）
重启电脑
然后win+r 输入 slmgr.vbs -xpr
查看电脑激活状态
完成升级
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c99633d8b92a28c2cedd591c3b251b6a/" rel="bookmark">
			CPU中的各种寄存器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转载自：https://blog.csdn.net/qq_36838191/article/details/83216837
在CPU中至少要有六类寄存器：指令寄存器（IR）、程序计数器（PC）、地址寄存器（AR）、数据寄存器（DR）、累加寄存器（AC）、程序状态字寄存器（PSW）。这些寄存器用来暂存一个计算机字，其数目可以根据需要进行扩充。
1. 数据寄存器
数据寄存器（Data Register，DR）又称数据缓冲寄存器，其主要功能是作为CPU和主存、外设之间信息传输的中转站，用以弥补CPU和主存、外设之间操作速度上的差异。
数据寄存器用来暂时存放由主存储器读出的一条指令或一个数据字；反之，当向主存存入一条指令或一个数据字时，也将它们暂时存放在数据寄存器中。
数据寄存器的作用是 ：
（1）作为CPU和主存、外围设备之间信息传送的中转站；
（2）弥补CPU和主存、外围设备之间在操作速度上的差异；
（3）在单累加器结构的运算器中，数据寄存器还可兼作操作数寄存器。
2. 指令寄存器
指令寄存器（Instruction Register，IR）用来保存当前正在执行的一条指令。
当执行一条指令时，首先把该指令从主存读取到数据寄存器中，然后再传送至指令寄存器。
指令包括操作码和地址码两个字段，为了执行指令，必须对操作码进行测试，识别出所要求的操作，指令译码器（Instruction Decoder，ID）就是完成这项工作的。指令译码器对指令寄存器的操作码部分进行译码，以产生指令所要求操作的控制电位，并将其送到微操作控制线路上，在时序部件定时信号的作用下，产生具体的操作控制信号。
指令寄存器中操作码字段的输出就是指令译码器的输入。操作码一经译码，即可向操作控制器发出具体操作的特定信号。
3. 程序计数器
程序计数器（Program Counter，PC）用来指出下一条指令在主存储器中的地址。
在程序执行之前，首先必须将程序的首地址，即程序第一条指令所在主存单元的地址送入PC，因此PC的内容即是从主存提取的第一条指令的地址。
当执行指令时，CPU能自动递增PC的内容，使其始终保存将要执行的下一条指令的主存地址，为取下一条指令做好准备。若为单字长指令，则(PC)+1àPC，若为双字长指令，则(PC)+2àPC，以此类推。
但是，当遇到转移指令时，下一条指令的地址将由转移指令的地址码字段来指定，而不是像通常的那样通过顺序递增PC的内容来取得。
因此，程序计数器的结构应当是具有寄存信息和计数两种功能的结构。
4. 地址寄存器
地址寄存器（Address Register，AR）用来保存CPU当前所访问的主存单元的地址。
由于在主存和CPU之间存在操作速度上的差异，所以必须使用地址寄存器来暂时保存主存的地址信息，直到主存的存取操作完成为止。
当CPU和主存进行信息交换，即CPU向主存存入数据/指令或者从主存读出数据/指令时，都要使用地址寄存器和数据寄存器。
如果我们把外围设备与主存单元进行统一编址，那么，当CPU和外围设备交换信息时，我们同样要使用地址寄存器和数据寄存器。
5. 累加寄存器
累加寄存器通常简称累加器（Accumulator，AC），是一个通用寄存器。
累加器的功能是：当运算器的算术逻辑单元ALU执行算术或逻辑运算时，为ALU提供一个工作区，可以为ALU暂时保存一个操作数或运算结果。
显然，运算器中至少要有一个累加寄存器。
6. 程序状态字寄存器
程序状态字（Program Status Word，PSW）用来表征当前运算的状态及程序的工作方式。
程序状态字寄存器用来保存由算术/逻辑指令运行或测试的结果所建立起来的各种条件码内容，如运算结果进/借位标志（C）、运算结果溢出标志（O）、运算结果为零标志（Z）、运算结果为负标志（N）、运算结果符号标志（S）等，这些标志位通常用1位触发器来保存。
除此之外，程序状态字寄存器还用来保存中断和系统工作状态等信息，以便CPU和系统及时了解机器运行状态和程序运行状态。
因此，程序状态字寄存器是一个保存各种状态条件标志的寄存器
@[TOC](这里写自定义目录标题) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f2de16df094e17a7281ac62e631e184/" rel="bookmark">
			python深度学习--预训练网络：特征提取和模型微调（接dogs_vs_cats）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import numpy as np import pandas as pd import matplotlib.pyplot as plt import pylab,os from pandas import DataFrame, Series from keras import models, layers, optimizers, losses, metrics from keras.utils.np_utils import to_categorical from keras.preprocessing.image import ImageDataGenerator #更靠近底部的层是指在定义模型时先添加到模型中的层，而更靠近顶部的层则是后添加到模型中的层 ''' 通过进一步使用正则化方法以及调节网络参数（比如每个卷积 层的过滤器个数或网络中的层数），你可以得到更高的精度,可以达到86%或87%。但只靠从头开始训练自己的卷 积神经网络，再想提高精度 就十分困难，因为可用的数据太少。想要在这个问题上进一步提高精度， 下一步需要使用预训练的模型 预训练网络（pretrained network）是一个保存好的网络，之前 已在大型数据集（通常是大规模图像分类任务）上训练好。如果 这个原始数据集足够大且足够通用，那么预训练网络学到的特征 的空间层次结构可以有效地作为视觉世界的通用模型，因此这些 特征可用于各种不同的计算机视觉问题，即使这些新问题涉及的 类别和原始任务完全不同 第一次遇到这种奇怪的模型名称——VGG、ResNet、Inception、Inception-ResNet、Xception 等。 你会 习惯这些名称的，因为如果你一直用深度学习做计算机视觉的话，它们会频繁出现. 预训练网络有两种方法：特征提取和微调模型 ''' #特征提取：使用之前网络学到的表示来从新样本中提取出有用的特征。然后将这些特征输入一个新的分类器，从头开始训练。 #将VGG16卷积实例化 from keras.applications import VGG16 conv_base=VGG16( weights='imagenet',#指定模型初始化的权重检查点 include_top=False,#指定模型最后是否包含密集连接分类器(它默认对应于ImageNet的1000个类别。因 为我们打算使用自己的密集连接分类器（只有 两个类别：cat 和 dog），所以不需要包含它) input_shape=(150,150,3))#是输入到网络中的图像张量的形状。这个参数完全是可选的，如果不传入这 个参数，那么网络能够处理任意形状的输入 print(conv_base.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f2de16df094e17a7281ac62e631e184/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2099db343adb34343677b7a4bf1138ca/" rel="bookmark">
			VBA之正则表达式（5）-- 中文字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实例需求：数据保存在A列中，需要将其中中文字符提取至B列。如何匹配中文字符呢？
大家都知道匹配英文单词很简单，[a-zA-z]把26个字母大小写将都涵盖了，可是中文字符怎么搞呢，是否也可以使用类似的方法，找到中文的开始和结尾的字符。中文到底有多少个字符？其实这个问题很难回答。CJK（CJK Unified Ideographs，中日韩统一表意文字）字符集中从0x4E00到0x9FA5 的连续区域，包含了 20902 个来自于中国、韩国、日本的汉字，涵盖了多数中文字符，可以说CJK是GB2312-80和BIG5等字符集的超集。
0x4E00和0x9FA5分别对应中文中的哪个字呢？大家可以在网上使用Unicode转换器进行转换，其实在Word中使用【符号】对话框将可以进行查询，如下图所示。
0x4E00对应汉字【一】，0x9FA5对应汉字【龥】，这个字属于古汉字，其读音为yù，使用拼音输入法，需要翻页N多次，才可以找到它。
在不同字体中，0x9FA5不一定是CJK统一汉字的最后一个字，例如下图还有之后的8个字符也属于CJK统一汉字，但是这些似乎都是偏旁部首，所以一般情况下使用[一-龥]匹配汉字就足够了。由于输入龥字比较麻烦，直接使用16进制的字符编码[\u4e00-\u9fa5]来表示中文字符集更加方便。
示例代码如下。
Sub RegExpChinese() Dim strTxt As String, strMsg As String Dim objRegEx As Object, objMatch As Object Dim j As Integer Set objRegEx = CreateObject("vbscript.regexp") 'objRegEx.Pattern = "[^一-龥]" objRegEx.Pattern = "[^\u4e00-\u9fa5]" objRegEx.Global = True For Each c In Range([A1], Cells(Rows.Count, 1).End(xlUp)) strTxt = Trim(c.Value) c.Offset(0, 1).Value = objRegEx.Replace(strTxt, "") Next Set objRegEx = Nothing End Sub 【代码解析】
第6行代码使用后期绑定创建正则对象。
第7行代码指定正则匹配字符串，用于匹配非中文字符，方括号中的^代表字符集的否定，即不包含指定字符集。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2099db343adb34343677b7a4bf1138ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dbbc5fa2924d164f53f7aed376e9bb6/" rel="bookmark">
			打开office应用时报错：应用程序错误-(0xc0000142)--word, ppt, excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 我晚上在打开PPT时报错：
powerpnt.exe- 应用程序错误
应用程序无法正常启动(0xc0000142)。请单击"确认关闭应用程序"
打开word时报错：
winword.exe- 应用程序错误
应用程序无法正常启动(0xc0000142)。请单击"确认关闭应用程序"
打开excel时报错：
excel.exe- 应用程序错误
应用程序无法正常启动(0xc0000142)。请单击"确认关闭应用程序"
打开ACCESS时报错：
MSACCESS.exe- 应用程序错误
应用程序无法正常启动(0xc0000142)。请单击"确认关闭应用程序"
如下图(PPT报错示例)：
解决方案 尝试1：检查Windows系统完整性 打开cmd的管理员窗口或者powershell的管理员窗口：
输入如下命令检查Windows系统完整性：
DISM.exe /Online /Cleanup-image /Restorehealth sfc /scannow 一般来说这个尝试都是没用的，但万一有用呢？
尝试2：更新Windows 我很幸运地靠Windows更新解决了这个问题：
我安装了win10更新:March 1, 2019—KB4482887 (OS Build 17763.348)，重启后office的问题就解决了。
尝试3：打开office的启动项 office在系统中有许多启动项，有些启动项也许你觉得没用，把启动项禁止了，然后office就不能用了。
如果你之前禁止过office相关的启动项，那么可以让这些启动项恢复启动。
尝试4：重装office 卸载，然后重装office。
这个方法有奇效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/034758f21211cfbd11f452a89abf4cfa/" rel="bookmark">
			sql语句练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查询出所有学员的学员编号姓名和生日 SELECT StudentID,StudentName,Birth from tb_student;
查询出所有master的学员 SELECT * from tb_student
where Degree='master';
查询出所有学员的信息，并按班级编号倒序排序。 SELECT * FROM tb_student
order by ClassID DESC;
Asc为升序（默认），desc为倒序；
查询出每个班级的人数（group by） SELECT COUNT(ClassID),ClassID FROM tb_student
GROUP BY ClassID;
查询出每种学位的人数(group by) SELECT degree,COUNT(*) FROM tb_student
GROUP BY Degree;
查询出学员姓名的第二个字母是a的所有学员。 SELECT * from tb_student
where StudentName like '_a%';
查询出住址不在houston，并且出生日期在1981-1-1后出生的学员 SELECT * FROM tb_student
WHERE Birth &gt; '1981-1-1' AND NOT City='houston' ;
查询出班级编号是1或者学历是bachelor的所有学员 SELECT * from tb_student
where ClassID=1 or Degree='bachelor';
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/034758f21211cfbd11f452a89abf4cfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b944e9072393baac50c81784fa1bdee/" rel="bookmark">
			c语言-日期格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 7-12 日期格式化 （5 分） 世界上不同国家有不同的写日期的习惯。比如美国人习惯写成“月-日-年”，而中国人习惯写成“年-月-日”。下面请你写个程序，自动把读入的美国格式的日期改写成中国习惯的日期。
输入格式： 输入在一行中按照“mm-dd-yyyy”的格式给出月、日、年。题目保证给出的日期是1900年元旦至今合法的日期。
输出格式： 在一行中按照“yyyy-mm-dd”的格式给出年、月、日。
输入样例： 03-15-2017 输出样例： 2017-03-15 程序：
#include &lt;stdio.h&gt; int main() { int year, month, day; scanf("%d-%d-%d", &amp;month, &amp;day, &amp;year); printf("%d-%02d-%02d\n", year, month, day); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fcf77e227304df6ce76ccc91ec75b04/" rel="bookmark">
			多个Ajax请求成功后再执行后续方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常会遇到需要ajax请求完毕后调用某方法,这次是多个ajax请求成功后,用它们返回的数据传参给回调方法,查询了一下,可以用jquery中的 $.when(),使用方法如下:
$.when( $.ajax(), $.ajax(), $.ajax() ).done(function( a1, a2 ,a3) {//当内部传入的3个ajax都执行了成功的回调, done里的函数才会被触发 //a1是第一个异步返回的数据 //a2是第二个异步返回的数据 //a3是第三个异步返回的数据 } ).fail( function(){//而当有一个ajax执行失败了，fail就被触发 } ); 该方法在jQuery1.5开始被引入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec0220627dcb4afe1a082001fbe42800/" rel="bookmark">
			新手入门：PyCharm 的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初次接触 pycharm 不要怕，这篇文章帮你快速入门，点击收藏不迷路~
相关文章：
Windows 10 同时安装 Python 2 和 Python 3 推荐一个视频：
pycharm使用教程 （语速偏慢，建议2倍速观看） PyCharm 是一种 Python IDE，带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，比如调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制。此外，专业版提供了一些高级功能，以用于支持Django框架下的专业Web开发。
软件版本： 专业版 2018.3
文章目录 一、界面二、新建三、配置解释器四、安装第三方模块五、第一个 Python 程序1.编辑器中写程序2.交互模式下写程序3.使用第三方模块4.Run 和 Debug 模式 六、简单设置1.背景颜色2.文字3.编码格式4.脚本头 七、技巧1.去掉波浪线2.待办事项3.快捷键4.查看 Python 文件的结构 一、界面 PyCharm 界面如下，用到的主要是以下5个区域。
菜单栏：新建，设置都在这里。Run 和 Debug：用于运行，Run 直接启动，Debug 启动可以加断点调试。项目的目录：项目相关的文件在这里找。编辑区域：写代码的地方。终端区：TODO 记录要做的事；Terminal 是程序输出的地方；Python Console 是控制台，可以直接运行 Python 语句，就像在 cmd 里输入 python 后的效果。
二、新建 包括新建项目和文件。
新建 Python 项目，在菜单栏：File-&gt;New Project 。
一般选 Pure Python(纯 Python 项目)，Django 和 Flask 都是 Web 应用框架。
第一个 Location 是这个项目所在的文件夹，最好新建一个文件夹专门存放，第二个 Location 是项目的文件名。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec0220627dcb4afe1a082001fbe42800/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1691049a5f24fc598bd6c3bb29cba909/" rel="bookmark">
			Qt QML代码中添加ChartView程序崩溃问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Qt QML代码中添加ChartView程序崩溃问题解决
pro文件种已经添加charts模块
QT += quick charts
程序运行崩溃。
解决方法：
把main.cpp函数中，
QGuiApplication app(argc, argv); 改成 QApplication app(argc, argv); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/062e57d8d8370ee93a09aa07309ea26e/" rel="bookmark">
			UEFI启动&#43;GPT分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
随着时代和科技的发展，电脑越来越普及，似乎人人都可以张嘴就说“我懂电脑”，但是总有一些看起来完全不懂但实际上非常基础的东西让“懂”与“不懂”清晰地划清界限。比如UEFI+GPT就是其中之一。那些之前认为自己已经精通电脑的人，遇到这个东西，忽然发现自己连以前自以为驾轻就熟的分区、装系统都不会了。
尽管UEFI以及GPT从诞生迄今已经十余年了，但是对于绝大多数人来讲它们是完全陌生的，甚至根本就不知道还有这种东西。
但是由于Windows8操作系统的面世，预装Windows8的电脑开始统一采用UEFI+GPT，很多人被迫接触到，感觉就像突然从天上掉下来的东西一样，无所适从，一筹莫展——“这到底是个什么东西呢？”
一旦出现系统问题，唯一能做的解决办法除了品牌机自带的系统还原，最大能力不过就是把UEFI关闭，把硬盘从GPT再转成MBR，从而彻底毁掉UEFI+GPT的优势，重新回到陈旧落后的BIOS+MBR的系统安装和运行方式上来。而每台电脑的具体情况又不尽相同，有时候即使想用BIOS+MBR也不是肯定能成功的——“我该怎么办啊？”
正文：
之前很长一段时间对UEFI+GPT没有头绪，有种无处下手的感觉，虽然UEFI+GPT安装系统一直没遇到什么障碍，但是即使查阅了相当数量的资料，在认识上对于UEFI+GPT也没有一个完整的概念，总觉得这是一个很难理解的东西，不得要领。不像最初接触BIOS+MBR的时候那么容易入门直至熟练操作。
先说关于什么是UEFI和GPT，在此就不做详解了，感兴趣的都了解，不感兴趣的说了也没什么用处。只说一点最基本的，MBR分区结构只能支持到2.2T的硬盘，超过2.2T就必须采用GPT分区，而就Windows而言，采用了GPT的硬盘，要想安装并启动Windows操作系统，只能选择高于XP的64位操作系统，并且采用UEFI方式安装、引导，否则无法启动，而包括XP在内及其之前的32位操作系统完全不支持GPT，别说安装、引导系统，直接无法识别。3T硬盘时代并不遥远，要想正常使用你的电脑，这就是采用UEFI+GPT的必要性。
而最关键之处在于，照目前的形势来看，由于预装Windows8电脑的推动，UEFI+GPT已经是大势所趋，与是否2.2T以上硬盘也已经没什么直接关系，也许就在不久之后的某一天开始所有的电脑全部使用UEFI单一启动，不会再兼容传统BIOS。
再说一下关于BIOS+MBR，从接触电脑十几年来，一直都是用的这种组合，直至今日，不敢说对此有多么了解，最起码在日常操作中基本无障碍了。比如：Windows各个版本甚至再+Linux+Mac的混合安装、引导驾轻就熟，任意顺序安装，任意创建、修复引导，多硬盘混合引导，分区表损坏、主引导记录损坏的修复、重建等等，都不存在任何问题。
而从一接触UEFI+GPT，总是感觉这个东西无法理解。甚至一筹莫展，哪怕是引导损坏这样之前在BIOS+MBR里不叫事的事情，面对UEFI+GPT都束手无策，查了很多资料，除了重装系统，在国内网络范围内，全网竟然找不到任何一篇具体解决问题的文章。现在回想，很长一段时间内都无法理解这些问题，很多莫名其妙的所谓专业文章的误导在其中作了重要贡献。
后来索性抛开所有的那些乱七八糟的观点、定义，按照自己的想法去摸索，经过近十天，几十遍重装系统，反复的假设、实验，总算是对UEFI+GPT有了一个总体的概念和较为清晰的认识，最关键的在于能够随意进行UEFI+GPT的安装和引导修复了，这是最重要的，个人观点一直都是，必须从实际出发，即使了解的再多，什么问题也解决不了，纸上谈兵，一切等于零。可以毫不夸张的说，至少目前为止，本文是全网络唯一一篇对UEFI+GPT进行实用性介绍和以及解决实际问题的文章。
个人体会，实际上只要对BIOS+MBR有一定的了解和操作能力，完全可以继续用BIOS+MBR的思路去考虑UEFI+GPT的问题，这样的话很多事情都会迎刃而解，因为两者之间在实际应用和操作上没有本质区别，而不是像某些专业文章所渲染那么高深莫测，并且尽其能事的竭力描述两者之间的重大区别，使UEFI+GPT理解起来更加困难，在一定程度上来讲，这就是一种因循误导。（当然也不排除某些写此类文章的人其实自己对这个东西也一知半解或者根本就不明白，除了千篇一律的抄袭、转载，最多也只能翻来覆去的照搬官方术语，堆砌定义和理论，完全谈不上有自己的观点或者看法，更没有什么具体的解决方案。）
关于UEFI的优越特性，比如可操作性、安全性、兼容性、可扩展性之类的问题，在此不再多说，这是开发人员的事情，和我没有关系。仅仅总结几点两者在系统安装及引导方式方面一些异同，帮助同样有此困惑的人理解这个东西：
【重要提示：
本文旨在“授之以渔”，力求融会贯通，知其然更知其所以然。因此本文既不包含网络上“技术文章八股文”式的定义、理论的堆砌和释义，更不是“小白必备”的傻瓜式手把手操作教程，如果对以上两种千篇一律的所谓“技术文章”有偏执的爱好，请务必及时停止浏览，另寻其好。】
不同点：
1.BIOS+MBR安装系统要求硬盘只要存在非隐藏、活动的主分区就可以了；而UEFI+GPT要求硬盘上除了存在ESP分区，还必须存在至少一个主分区
2.BIOS+MBR一旦系统安装好之后，如果系统引导文件在单独的分区，此分区可以在操作系统中可见，也可以设置此分区为隐藏，系统都可以正常启动；而UEFI+GPT系统引导文件所在的ESP分区在操作系统中为不可见
3.BIOS+MBR启动要求的活动的主分区不是唯一固定的，可以任意设定某一分区为活动的主分区，然后MBR就可以通过分区表指引操作系统从此分区启动，也就是说，可以在任意分区（主分区无论是否活动或者扩展分区）安装操作系统，只要存在任意的活动主分区，就可以从此分区启动操作系统；而UEFI+GPT只能把系统引导文件放置在ESP分区
4.BIOS+MBR的系统引导文件可以和系统文件在同一分区的根目录，也可以不与系统文件同一分区，只要系统引导文件所在分区为活动的主分区即可启动操作系统；而UEFI+GPT只能把系统引导文件放置在ESP分区，且操作系统必须在另外的主分区，也就是说，UEFI+GPT强制要求系统启动文件与系统文件必须分离，不在同一分区。
相同点：
1.BIOS+MBR和UEFI+GPT的系统引导文件都可以放置在单独的分区，这一点在上面的第4点里已经说的很清楚
2.BIOS+MBR的系统引导文件所在的活动主分区位置不是固定的，可以随意设置任意分区满足此条件，UEFI+GPT的ESP的位置也是可以随意设置的，在硬盘起始位置、中间位置、末尾，都可以，只要分区属性和其中的引导文件正确，就可以引导启动操作系统（参考文中附图）
3.BIOS+MBR的系统引导文件所在的分区和UEFI+GPT的ESP分区都可以分配任意大小，而不是ESP必须100M
4.BIOS+MBR安装系统所需的非隐藏、活动主分区和UEFI+GPT的系统的ESP分区，都可以同时设置多个，但是即使有多个相同属性的分区，系统安装时安装程序都是自动写入第一个，启动时也都是从第一个启动（参考文中附图）
补充：
1.使用BIOS+MBR和UEFI+GPT安装的系统文件是一模一样的，唯一的区别只是引导方式的不同，因此使用GHOST手动备份的系统，MBR和GPT可以任意交叉还原，只要做好引导修复就没有任何问题
2.GHOST始终是系统备份还原神器，只要熟练掌握GHOST手动操作，至少目前为止Windows系统的范围之内，无论什么版本，无论MBR还是GPT，都可以随意备份还原。
3.MBR与GPT分区互转的话，与“删除所有分区”以及“全盘格式化”没有任何必然联系，你格式化一万遍硬盘也还是原来的分区结构，只有通过转换操作才可以到另一种，而这个转换操作与“删除所有分区”以及“全盘格式化”没什么关系。
着重强调一点：
以上所有经验均基于UEFI+GPT的组合，而实际上，UEFI启动（Windows操作系统）的话，并不强制要求硬盘必须为GPT分区，而是只要硬盘上存在EFI启动文件且位于FAT（16/32）分区就可以了（UEFI无法从NTFS分区启动）。因此如果是小于2.2T的硬盘，不必非得转换成GPT也可以引导系统启动。也就是说，UEFI+MBR也是可行的，而GPT硬盘的话，则必须使用UEFI引导，BIOS无法原生引导GPT硬盘上的操作系统（Windows）。
关于这一点，如果感觉不能理解的话，可以通过以下具体应用来参考。
注：
综观网上那些关于UEFI的所谓技术类文章，除了毫无实用价值和实际意义，而且都不同程度的存在各种各样的因循误导，继而被以讹传讹，最终成为一些人坚信不疑的“定律”。这样的误导主要表现为两点：
1.就是刚刚说的，“UEFI启动系统必须是GPT分区”，这个已经说得很明白了，并且有实例解析，无需再讨论
2.另外一个就是不知道从什么时候什么人开始谣传的“UEFI的优势就是启动速度快”或者“UEFI启动比传统BIOS启动速度快”。无论UEFI还是GPT，与电脑启动速度没有任何必然联系。或者说，只要硬件环境相同、系统一样，无论UEFI+GPT安装还是BIOS+MBR安装系统，启动速度没有区别
GPT
关于UEFI启动+GPT分区 的一些经验
MBR
关于UEFI启动+GPT分区 的一些经验
附：部分Windows桌面操作系统对GPT的支持
数据读写系统启动
WindowsXP32位不支持GPT不支持GPT
WindowsXP64位支持GPT不支持GPT
WindowsVista32位支持GPT不支持GPT
WindowsVista64位支持GPT支持GPT（需UEFI）
Windows732位支持GPT不支持GPT
Windows764位支持GPT支持GPT（需UEFI）
Windows832位支持GPT不支持GPT
Windows864位支持GPT支持GPT（需UEFI）
有了以上的经验总结，就可以轻松解决以下问题了：
1.UEFI+GPT环境下以任意方式安装操作系统（单系统或者多系统）。这个不必详解了
2.最主要的问题：UEFI+GPT引导修复操作（EFI引导文件损坏、ESP分区损坏或者丢失之后手动重建EFI引导等等）。这个在此也不做详解，这是这段时间反复研究、实践的最重要成果，因此姑且算是有所保留卖个关子吧，如果是结合以上几点经验总结，对UEFI+GPT有一定的了解之后，应该不难揣摩出办法
3.如果主板不支持UEFI，使用折中的办法来解决大硬盘使用问题，这个问题以前我也已经多次提过。
第一种办法就是使用多块硬盘，MBR+GPT组合，MBR硬盘作为启动引导盘。
小于2.2T的硬盘采用MBR，大于2.2T的硬盘采用GPT，这样的话，解决方案就很灵活了，可以根据以上所列相同点的第1条和补充里面第2条，使用MBR硬盘建一个非隐藏活动主分区，放置系统引导文件，然后将系统安装在MBR硬盘或者GPT硬盘都可以，无论单系统还是多系统都无所谓，两块硬盘交叉安装操作系统也没有任何问题
强调两点：
1.这样安装的话不限于64位操作系统及XP以上版本，理论上只要是能对GPT硬盘进行读写的系统版本就可以安装。实际测试，32位XP和2003sp1以及之前的版本，电脑事先安装GPT硬盘的情况下，即使系统安装在MBR硬盘，原版系统安装，没有问题，如果是Ghost系统，有可能出现卡死或者蓝屏等问题导致无法顺利安装；先在MBR硬盘安装好系统，然后再装GPT硬盘，无论原版还是Ghost系统都没有问题，只是GPT分区无法识别（解决方法很简单，就是使用2003sp2的disk.sys文件替换到以上系统，就可以完美识别GPT分区，此法简单易操作，且不涉及系统稳定问题，感兴趣的话可以自行搜索）。64位XP安装在MBR硬盘，引导、启动都没有问题，安装在GPT硬盘无法引导。其他系统无论32位还是64位，无论安装在MBR还是GPT，都可以正常引导启动；
2.BIOS安装系统到GPT硬盘仅限于Ghost方式，Ghost解压完毕后手动修复引导即可。
第二种办法是单块大于2.2T的硬盘+U盘或者光盘组合
使用GPT分区结构对硬盘进行分区，是否创建ESP分区都无所谓，因为主板不支持UEFI，创建此分区也没什么用，全凭个人爱好了。然后只能使用Ghost方式解压安装操作系统到硬盘，无论单系统还是多系统，全部安装完毕后，准备一个U盘，大小无所谓，只要不小于十几M就行，使用分区软件设为活动主分区，插在电脑上。进PE（2003sp1以上版本），手动或者使用工具软件修复单系统或者多系统引导，将引导文件写入U盘。然后就可以使用此U盘启动所安装的单系统或者多系统了。此方法实际上就是用U盘代替了第一种方法中的小硬盘而已，没什么本质区别。（这个方法大概10年前我就在电脑论坛发过帖子，当时考虑的是用U盘做一个系统启动钥匙，因为系统引导文件在U盘上，电脑如果不插这个U盘是无法启动的。MBR硬盘系统：Windows864位+Windows732位+WindowsXP32位，GPT硬盘系统：Windows832位+Windows764位+WindowsVista32位，测试环境：杂牌945主板、32M老U盘，测试通过。）
另外还可以再使用光盘来代替U盘，具体方法说起来更简单，用软件创建一个可启动光盘（创建方法自行查询，会做的不用讲，压根没接触过的，另开帖子专门讲也不一定看得懂），然后将上面U盘里的系统启动文件加进去刻录就可以了。然后使用此光盘启动电脑，效果和U盘是一样的。此方法仅仅作为一种可行性的介绍，不推荐使用，U盘比这个方便的多，没必要多此一举。
备注：使用此方法，理论上来讲凡是可以对GPT进行读写的系统都适用，但实际上XP以上系统无论32位还是64位操作系统全部测试可行，但是2003sp1及XP64位这些可以读写GPT的系统也不行，这个不知道是由于NT5.X的ntldr引导机制还是其他的什么原因，有知道原因的朋友不吝赐教！
注：
1.除专门标明“Ghost系统”，本文所提及的系统安装均为微软原版Windows系统，不包含任何修改版本
2.非UEFI主板安装原版系统到GPT磁盘，只能采取wim直接解压到分区或者先将系统Ghost化，然后解压安装的办法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/062e57d8d8370ee93a09aa07309ea26e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f89cf13313d151291225f034100a312/" rel="bookmark">
			打飞机小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计目标： 高质量的代码要有这些优点:
复用性好、扩展性好、维护性好、
可移植性好、健壮性好、效率好、可读性好…
所以设计代码的时候不要只想到功能的实现，还要考虑功能的扩展及代码复用等
设计规则： 需求分析抽取共性，设计超类和派生类中的属性和方法（数据私有化，行为公开化） 将所有派生类所共有的属性和行为，抽到超类中-----抽共性若所有派生类的行为都一样，设计为普通方法
若所有派生类的行为都不一样，设计为抽象方法将部分派生类所共有的行为，抽到接口中
接口是对继承的单根性的扩展-------------多继承 功能实现（行为公开化）
做功能的步骤: 先写行为:
若为对象所特有的行为，就将方法设计在对应的类中
若为所有对象所共有的行为，就将方法设计在超类中然后在窗口调用:
1)定时触发的，在定时器中调用
2)事件触发的，在侦听器中调用 射击游戏需求: 所参与的角色:
英雄机、子弹、小敌机、大敌机、小蜜蜂、天空对象间的关系: 英雄机可以发射子弹(单倍火力(0)、双倍火力(&gt;0))子弹可以射击敌人(小敌机、大敌机、小蜜蜂) 打掉小敌机，玩家得1分打掉大敌机，玩家得3分打掉小蜜蜂，英雄机得奖励(1条命、40火力值)
发射一次双倍火力，则火力值减2 英雄机、子弹、小敌机、大敌机、小蜜蜂都在天空上飞敌人撞到英雄机，则英雄机减1条命，同时清空火力值判断游戏状态： 英雄机命数为0时，则游戏结束，游戏运行时，鼠标移出界外游戏暂停，移入游戏继续，游戏结束界面点击鼠标重新开始一局游戏 射击游戏中的对象类: 找对象:英雄机、小敌机、大敌机、小蜜蜂、子弹、天空抽类:Hero、Airplane、BigAirplane、Bee、Bullet、Sky类中的属性 超类：
数据：宽、高、x、y、状态（存活，爆破，移除）、飞行速度行为：构造函数（敌人x、y随机生成，另三种需要传入，所以需要重载）、飞行（step）、判断是否越界、碰撞、状态判断（三种）、goDead、画图 Enemy接口：得分接口
Award接口：奖励接口
Hero:
命数life、火力值doubleFire、随鼠标移动moveTo()、射出子弹、生命和火力加减、
Airplane:
得分
BigAirplane:
得分
Bullet:
Bee:
xSpeed、ySpeed、奖励类型，奖励类型的方法
Sky:
y1（需要画两张图实现无缝连接）
images：各种图片数据的读取功能
world：有窗口宽高和各种状态常量，界面各种功能
功能实现 生成敌人敌人和子弹入场飞行物实现移动子弹击中敌人：改变飞行物的状态，并获得分数和奖励英雄机被撞：改变敌机状态，改变英雄机的命和火力移除：越界和remove状态的对象移除画图侦听器事件：侦听鼠标操作，改变游戏状态及英雄机位置定时器：重复执行，完成动态画面 游戏下载：
链接: https://pan.baidu.com/s/1x8a6F47NGK5Pcu8e0Cc1og 提取码: ugb6
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58d31d28bacfd16b04f913b4fc319688/" rel="bookmark">
			基于redis实现的延时队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 需求背景 用户抢单成功之后，如果一定时间后没有完成任务，任务自动取消用户提交任务审核后，如果商家一定时间后没有审核，任务自动通过 类似的场景比较多 简单的处理方式就是使用定时任务 假如数据比较多的时候 有的数据可能延迟比较严重,而且越来越多的定时业务导致任务调度很繁琐不好管理。
2 技术支撑 Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。
不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
有序集合的成员是唯一的,但分数(score)却可以重复。
集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。
示例
redis 127.0.0.1:6379&gt; ZADD runoobkey 1 redis (integer) 1 redis 127.0.0.1:6379&gt; ZADD runoobkey 2 mongodb (integer) 1 redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql (integer) 1 redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql (integer) 0 redis 127.0.0.1:6379&gt; ZADD runoobkey 4 mysql (integer) 0 redis 127.0.0.1:6379&gt; ZRANGE runoobkey 0 10 WITHSCORES 1) "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58d31d28bacfd16b04f913b4fc319688/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dab42f10bf62c43ac4f09f01959ea05a/" rel="bookmark">
			HTTP各个status code是什么意思【已解决】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在介绍状态码之前，要简单讲一下为什么要有状态码这个东西。计算机之间的通信以协议为共同基础，客户端和服务端都按照协议的约定进行通信。HTTP的状态码就在HTTP的协议内，规定了很多的状态。客户端请求服务端后，服务端就返回结果，同时返回状态码。告诉客户端，本次请求是成功了还是失败了，还是要客户端做什么操作。那为什么不使用文本状态码呢？不是更加清晰直观吗？这是因为这些状态协议里面已经规定了，提到状态码，就是表示本条状态。
状态码分为1-5开头的CODE,以下依次说明,请仔细阅读噢
1** 类状态码称之为Information 状态吗，表示信息正在处理。
2** 类状态码称为为Success状态码，表示请求正常完成。
3**类状态码称之为Redirection 状态码，表示需要客户端进行附加操作（如跳转。重定向）
4**类状态码称之为Error状态码，通常是由于客户端的错误导致的。
5**类状态吗称为Server Error状态码，通常是服务端的错误导致的。
小结下：状态码分为客户端错误状态码、服务端错误状态码、成功状态码，重定向状态码等。
1**不常见到哈,直接从2开始讲了
A . 200(ok) 表示从客户端成功发出去请求到服务端了,服务端也接收到了这条请求并正确返回
204 No Content 请求已经成功了，但是却没有返回任何结果（实体）。通常使用php die() exit()函数会引发204状态码
206 Partial Content 范围请求状态码。
B . 301 状态码 Moved Permanently 表示你请求的页面资源现在已经转移位置了，你需要到新的地方去需找该页面。这个即重定向，服务器的response首部里会有location字段值来提示。
302 状态码(Found)和301差不过。表示你请求的页面资源现在已经转移位置了，你要到新的地方去寻找。但是新的地方也不是固定的，说不定过几天还要换。不提示用户保存书签，提示用户跳转。
303 状态码。See other .表示你请求的页面中包含着你想要拿到资源的地址。比如你到门卫处去取快递，到了门卫处，大爷说快递已经交给前台了。这个过程会返回303状态码。
304 Not Modified 表示资源已经找到了，但是和上次相比没有更新。浏览器读取缓存。
307 Temporary Redirect 临时重定向。
C . 400 Bad Request 报文语法错误。
401 Unauthorized 需要通过HTTP认证（BASIC 或者DIGEST）.
403 Forbidden 目录、文件权限错误都会报此状态码。
404 服务器上无此资源，一般情况为路径错误。
D . 500 Internal Server Error 服务端错误，有可能是WEB应用存在错误。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dab42f10bf62c43ac4f09f01959ea05a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/752207d64b09cf9f5bf8d5fd6fac8d2b/" rel="bookmark">
			调试基于Linux Tsi721的rapidio驱动遇到的一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前我在调试基于Linux的rapidio驱动，遇到了一些问题，希望能和各位一起探讨：
调试环境：
CPU：Intel Xeon E5-2648L
系统：ubuntu 16.04
板上RapidIO芯片：Tsi721
目前一共有3个版本的驱动：
使用系统自带linux驱动，能识别Tsi721，并且ID信息能正确读出来。即在sys/class/rapidio_port下有设备的端口节点，但在/dev目录下没有节点。按照相关文档的描述，测试rapidio使用的工具有3个，分别为file_transfer、goodput、rrmapcli，这3个工具我有源码，并且编译通过，但是readme文档中，写明了它必须通过/dev目录下的诸如/dev/rio_mport0 这样的设备节点才能访问硬件，但是驱动没有生成这个节点，不知道哪里还有问题。使用IDT官方提供的驱动（https://github.com/RapidIO/kernel-rapidio），make编译，make install后，反而识别不到Tsi721，按照驱动目录下的README文档，在/sys/bus/rapidio/devices下应该能看到rapidio的节点，但是实际上没有看到。在sys/class/rapidio_port下也为空，在/dev目录下也找不到设备节点。在IDT官网中，这个文档描述了一些有关linux的相关信息，但是下载后才发现它并不是基于ko形式来编译的，也就是说它是随系统启动而启动的，不知道这份资料有什么意义：https://www.idt.com/document/msc/s-rio-linux-support 于是，我建了一个QQ群（群号：554795990），如果你也有类似的问题，欢迎加入一起讨论。如果你有解决方法，也请赐教，不胜感激。上面提到的所有资料，我也会全部提供。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec5029d3a9c917dfedaf6109fb6f1110/" rel="bookmark">
			css 水平垂直居中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;div class="box"&gt; &lt;div class="center"&gt; 需要水平垂直居中的元素 &lt;/div&gt; &lt;/div&gt; 1.flex 布局
&lt;style&gt; .box{ width:200px; height: 300px; background-color:palegoldenrod; display: flex; justify-content: center; align-items: center; } .center{ background-color: orange; } &lt;/style&gt; 2.定位加transform
&lt;style&gt; .box{ width:200px; height: 300px; background-color:palegoldenrod; position: relative; } .center{ background-color: orange; position: absolute; top: 50%; left: 50%; right: 0; bottom:0; transform:translate(-50%,-50%) } &lt;/style&gt; 3.父元素设置table,子元素利用table-cell,text-align
&lt;style&gt; .box{ width:200px; height: 300px; background-color:palegoldenrod; display: table; //为了区分出父元素 padding:10px; } .center{ background-color: orange; display: table-cell; vertical-align: middle; text-align: center; } &lt;/style&gt; 总结：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec5029d3a9c917dfedaf6109fb6f1110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf7ca15fb56613537c420b65ee4cd320/" rel="bookmark">
			使用nodejs crypto模块进行sha1、md5加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文档地址：http://nodejs.cn/api/crypto.html
使用crypto.createHash（algorithm [，options]）这个方法，该创建并返回一个Hash对象，该对象可用于使用给定的哈希摘要生成哈希摘要algorithm。其中algorithm取决于平台上OpenSSL版本支持的可用算法。不只支持sha1和md5这两种，还支持sha256、
const {createHash}= require('crypto'); /** * @param {string} algorithm * @param {any} content * @return {string} */ const encrypt = (algorithm, content) =&gt; { let hash = createHash(algorithm) hash.update(content) return hash.digest('hex') } /** * @param {any} content * @return {string} */ const sha1 = (content) =&gt; encrypt('sha1', content) /** * @param {any} content * @return {string} */ const md5 = (content) =&gt; encrypt('md5', content) module.exports={sha1,md5,encrypt} 复制代码 下面是使用es6的方法进行导出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf7ca15fb56613537c420b65ee4cd320/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c434c74f05f890e384f8c8e871f9c13/" rel="bookmark">
			小白之python开发：视频文件的爬取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天简单爬取了一个视频网站，将视频资源爬取到了本地文件夹中：
1.获取目标网站
response = requests.get('https://ibaotu.com/shipin/') 2.解析网站信息：具体获取了两个比较重要的信息，一个是视频的名称，有了这个名称可以用来命名保存到本地的视频文件，另一个信息室详细视频页面的网址url，最开始利用的是预览视频的src讲该预览信息保存了下来，后来发现该视频在预览模块还可以正常播放，一旦真的放到播放器中后分辨率过低，导致视频模糊，于是后来利用该url进入该视频的单独网页中爬取视频的src
xml = etree.HTML(response.text) src_list = xml.xpath('//a[@class="shade-box"]/@href') # print(src_list) tit_list = xml.xpath('//span[@class="video-title"]/text()') 3.根据网页url进入子视频网页，下载视频
for src, tit in zip(src_list, tit_list): response = requests.get(("http:" + src)) xml = etree.HTML(response.text) src = xml.xpath('//a[@class="video-src"]/@src') if len(src) == 1: src = src[0] else: print("视频"+tit+"保存失败") continue response = requests.get(("http:" + src)) fileName = "video\\" + tit +".mp4" print("正在保存视频"+fileName) 4.保存视频
with open(fileName, "wb")as f: f.write(response.content) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ea4a71a6ac3ae4768b34765c28cfe36/" rel="bookmark">
			Ubuntu下安装make
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：（自动安装）
1、进入root权限：su root
2、更新安装列表：apt-get update
3、安装make：apt-get install ubuntu-make
方法二：（手动安装）
1、查看make版本，在浏览器搜索：ftp://ftp.gnu.org/gnu/make/ 可进入下载页面
2、进入文件存放路径：cd /home/tool
3、下载安装包：wget http://ftp.gnu.org/gnu/make/make-3.81.tar.gz
4、解压压缩包：tar -zvxf make-3.81.tar.gz
5、进入解压文件目录：cd make-3.81
6、系统配置make：./configure --prefix=/usr/local/make-3.81
7、执行编译：make
8、安装make：sudo make install 这里加上sudo是因为这一步会将编译好的make 3.81版本的文件转移到/usr/local/make-3.81目录下，这个目录只有root有权限写入。因此需要sudo权限
9、查看安装是否成功：make -v 会显示 GNU Make 3.81则说明安装成功
转载于:https://www.cnblogs.com/CaesarTao/p/10483982.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0afef265d843b0e50bc53d7c7326c4bc/" rel="bookmark">
			如何通过Maven仓库安装Spire Java系列组件（以Spire.PDF for Java为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		E-iceblue的所有Java组件均可通过Maven安装。只需简单配置，你就可以轻松将Spire Java系列组件的JAR包通过Maven仓库安装到Maven项目中。
本文以Spire.PDF for Java和Free Spire.PDF for Java为例。
首先，在pom.xml文件中配置Maven仓库路径。
&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;com.e-iceblue&lt;/id&gt; &lt;name&gt;e-iceblue&lt;/name&gt; &lt;url&gt;http://repo.e-iceblue.cn/repository/maven-public/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; 然后，在pom.xml文件中指定Spire.PDF for Java的Maven依赖。
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt; e-iceblue &lt;/groupId&gt; &lt;artifactId&gt;spire.pdf&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置完成后，在IDEA中，您只需点击”Import Changes”即可导入JAR包；在Eclipse中，您需要点击”Save”按钮， JAR包才会自动下载。至此，您已经成功在Maven项目中添加了Spire.PDF JAR包依赖。
注： Free Spire.PDF for Java的artifactId为spire.pdf.free
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;e-iceblue&lt;/groupId&gt; &lt;artifactId&gt;spire.pdf.free&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; *所有Spire Java组件对应的artifactId和最新的version号，可在此处查看。
IDEA中的详细安装流程
第一步：创建Maven项目。
第二步：设置任意GroupId和ArtifactId。
第三步：配置porm.xml文件，然后点击”Import Changes”。
Eclipse中的详细安装流程
第一步：创建Maven项目。
第二步：设置任意GroupId和ArtifactId。
第三步：配置porm.xml文件，然后点击”Save”按钮。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea14075ac4d3a0fd33893180866fe9e4/" rel="bookmark">
			linux配置正向解析，nslookup检验时出现connection timed out
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：CentOS 7
在配置DNS正向解析时，最后用nslookup来检验，一直提示连接超时。
但是能ping通，就怀疑是不是DNS错了，遂执行cat /etc/resolv.conf查看DNS地址，果然不对劲（我的ip设置为192.168.10.10）。
用vim修改为192.168.10.10，重启systemctl restart network，再试，OK。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f702b49a32b6cfb4d7564d09c273c69/" rel="bookmark">
			Unity 之 Application各种路径在终端的本地路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dataPath :返回程序的数据文件所在的文件夹的路径（只读）。返回路径为相对路径，一般是相对于程序安装目录的位置。不同游戏平台的数据文件保存路径不同。
StreamingAssetsPath： 此属性用于返回数据流的缓存目录，返回路径为相对路径，适合设置一些外部数据文件的路径。（只读）
PersistentDataPath：返回一个持久化数据存储目录的路径，可以在此路径下存储一些持久化的数据文件。对应同一平台，在不同程序中调用此属性时，其返回值是相同的，但是在不同的运行平台下，其返回值会不一样。
temporaryCachePath：此属性用于返回一个临时数据的缓冲目录（只读）。对于同一平台，在不同程序中调用此属性时，其返回值是相同的，但是在不同的运行平台下，其返回值是不一样的。
persistentDataPath和temporaryCachePath的返回值一般是程序所在平台的固定位置，适合程序在运行过程中产生的数据文件。
（网图）
参考链接：http://tieba.baidu.com/p/3309230088
PC： Application.dataPath : /Assets
Application.streamingAssetsPath : /Assets/StreamingAssets
Application.persistentDataPath : C:/Users/xxxx/AppData/LocalLow/CompanyName/ProductName
Application.temporaryCachePath : C:/Users/xxxx/AppData/Local/Temp/CompanyName/ProductName
Android: Application.dataPath : /data/app/xxx.xxx.xxx.apk
Application.streamingAssetsPath : jar:file:///data/app/xxx.xxx.xxx.apk/!/assets
Application.persistentDataPath : /data/data/xxx.xxx.xxx/files
Application.temporaryCachePath : /data/data/xxx.xxx.xxx/cache
IOS： Application.dataPath : Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data
Application.streamingAssetsPath : Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data/Raw
Application.persistentDataPath : Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Documents
Application.temporaryCachePath : Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Library/Caches
Mac: Application.dataPath : /Assets
Application.streamingAssetsPath : /Assets/StreamingAssets
Application.persistentDataPath : /Users/xxxx/Library/Caches/CompanyName/Product Name
Application.temporaryCachePath : /var/folders/57/6b4_9w8113x2fsmzx_yhrhvh0000gn/T/CompanyName/Product Name
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8966412dcee0074f2a9a3b3f9213166a/" rel="bookmark">
			嵌入式硬件通信接口协议-IIC（一）协议基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章首发于同名微信公众号：DigCore
欢迎关注同名微信公众号：DigCore，及时获取最新技术博文。
原文链接：https://mp.weixin.qq.com/s/zJ7cnuxMzESSDnan3Izmkw
本节继续讲嵌入式硬件通信接口协议中的又一个串行通信接口-IIC。相比于UART串口协议和SPI串行外设接口协议，这个IIC又有其独特之处。
简介
IIC（Inter-Integrated Circuit），集成电路总线。
IIC 即Inter-IntegratedCircuit(集成电路总线），这种总线类型是由飞利浦半导体公司在八十年代初设计出来的一种简单、双向、二线制、同步串行总线，主要是用来连接整体电路(ICS) ，IIC是一种多向控制总线，也就是说多个芯片可以连接到同一总线结构下，同时每个芯片都可以作为实时数据传输的控制源。这种方式简化了信号传输总线接口。
--from 百度百科
https://baike.baidu.com/item/iic/3524834
相比于SPI接口《嵌入式硬件通信接口协议-SPI（一）协议基础》，此处的IIC接口定义了多主多从的通信架构，在同一IIC总线上可有多个主机和多个从机。“主-&gt;从”的通信架构使得通信的主动权在主机端，主机发起一次通信，从机做出响应。
信号线
IIC作为两线串行总线，信号线分别是：
SCL（Serial ClockLine）：串行时钟，主机输出
SDA（Serial DataLine）：串行数据，双向传输
总线信号的电平在电路连接上，一般加上拉电阻Rp，使得总线在空闲时，信号管脚处于高电平状态。
这里可以具体到一些芯片的手册里，明确写出线路连接时的上拉电阻要求：
SHT20温湿度传感器要求的上拉电阻：
在触摸按键BS116A-3芯片数据手册中：
信号时序
IIC作为同步串行总线，可以认为有两个同步信号，第一个是通信起始、结束标志，告知挂在IIC总线上的从机设备，何时开始通信并且何时结束；第二个是同步时钟信号SCL，收发双方进行数据的交互时，都是基于SCL的跳变进行逐bit输出和采样的。
起始标志
处于空闲状态下时，SCL和SDA都是高电平，某一时刻，SDA拉低，则此刻认为开始IIC传输。
结束标志
即将完成数据传输时，在SCL处于高电平时，将SDA强制拉高，则此刻认为结束IIC传输。
数据输出
在SCL为低电平时，发送方根据传输的数据内容逐bit改变SDA的电平。
数据采样
在SCL为高电平时，接收方读取SDA的电平逐bit接收，并逐8个bit组成1个Byte。
应答ACK
ACK表示在8bit数据后的第9个时钟的高电平期间，SDA保持低电平。
应答NACK
NACK表示在8bit数据后的第9个时钟的高电平期间，SDA保持高电平。
关于理解和记忆，推荐分组记忆：
SCL高电平时，SDA拉低开始，SDA拉高结束；
SCL高电平时，接收方采样SDA管脚电平；SCL低电平时，发送方改变SDA管脚电平；
应答位，SDA低电平表示ACK，SDA高电平表示NACK。
以上就是IIC在通信过程中，可能出现的信号时序状态特征。
如果要和SPI接口对比，我们发现，在IIC总线上挂了多个从设备，某个时刻某个主机要与某个从设备通信时，却不像SPI那样有单独一个片选信号管脚SS。
那么IIC要实现主机与指定从机的通信，需要每次开始通信时，主机会先把指定从机设备的地址通过接口发出，这样一来，对应的从机设备即可被选中，才能进行后续的通信操作。
类似的，每个具有IIC接口的外围器件，其数据手册中都有关于地址的配置：
SHT20温湿度芯片地址配置：
BS116-3触摸芯片地址配置：
AT24C1024B存储芯片：
我们发现，IIC设备的地址普遍是7bit，而发送一次数据都是一个字节8bit地发送，所以要发送地址时，都会带上读写位，组成一个字节后发出。
读写位的意义，主要在于明确IIC从机设备，在被主机“点名”后，接下来是被主机读取还是被主机写入，靠的就是这个读写位来判断。
另外，类似于AT24C1024B存储芯片，在7bit的地址位里，又有3个bit的A2、A1、A0可以在硬件电路上选择不同的连接方式，从而又有8种不同的从机地址，也就是说同个IIC总线上可以挂同种型号的AT24C1024B存储芯片8片。
接口配置项
相比于SPI接口丰富的配置项，然而IIC仅有2根数据线，可配置的也就是时钟SCL的翻转速率，因为这个时钟的速率直接影响到数据的传输速率。
这里所配置的推荐值，应该确认IIC总线上各个从机设备的速率极限，这样在设计IIC接口时，能够兼容总线上的所有设备通信速率。
SHT20温湿度传感器： BS116-3触摸芯片时钟极限： AT24C1024B存储芯片的时钟要求： 综上所述，IIC总线接口，属于两线、多主多从、半双工通信接口协议。熟悉两根信号线的时序图，基本上对IIC的了解就差不多了。
关于IIC接口的分层架构设计，敬请期待后续更新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c16b1f786791da3ce2e038dcbaaa3778/" rel="bookmark">
			【嵌入式编程】函数返回类型设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章首发于同名微信公众号：DigCore
欢迎关注同名微信公众号：DigCore，及时获取最新技术博文。
原文链接：https://mp.weixin.qq.com/s/JNuQ4hQ0R_hXxch9-ORbzA
不知从什么时候起，对函数返回值，有一种下意识的认识：“0”是成功、非“0”表示失败。
先讲个故事，就是项目移植时的一段小插曲——
近期工作，使用一款新的芯片进行开发。移植过程中需调用官方的函数库接口，接口有uint32_t类型的返回值。根据手册的说明，函数返回值“0”表示成功，“-1”表示失败。这里的返回值比较简单，仅有成功、失败两种，一般采用“if(!ret){成功}else{失败}”判断。就这样，移植过程中，该芯片函数库绝大部分的接口返回值都是这两种，处理结果时图省事也就把“if(!ret){成功}else{失败}”复制粘贴了。
意外出现了，当我调用库的“比对”函数接口时结果一直错误，返回值总是“1”，也就是“真”的逻辑，于是上层接口一直对应用层向用户报错。翻阅手册检查了接口的输入参数，怀疑其他接口处理的数据错误，又检查该接口之前的其他被调用接口。可偏偏，手册里对本接口描述的返回值说明，因排版而放在下一页，你如何都无法想到，这里的函数返回值，竟然是成功时返回“1”，失败返回“0”！
回想起检查这一整个执行流程时，几乎花了一中午时间，万万没想到竟然忽略这个细节，真是“踏破铁鞋无觅处，得来全不费工夫”！
总而言之，芯片厂商提供的函数库接口，返回值设计的过于简单，也没达到完全的统一规范。说到底，只能怪自己对这么重要的细节没有留意到位。作为开发者，要多从自身找原因，确保自己的每一个环节不出异常。即使面对多么棘手的代码，你都可以应对自如。
此事对自己的教训只能是不要忽略细节。但有时候本可以做好的事情，为什么不一口气做到位呢！对于函数返回值的定义，其实可以做到相对规范一些，统一起来，对自己对他人都是有帮助的。
返回值可以有两种，一个是函数执行结束得到的数据，还有就是函数执行结束的状态结果。
返回数据就是把传入参数做了某一个运算后得到的结果；返回状态结果，主要指示函数是否正确执行。
返回数据，这种返回值不能表示是否正确执行，只能认为，有返回值了就是正确执行了。所以这样的函数执行时，不该有参数正确性判断，不管传什么样的参数应该都能执行。
最简单的例子就是一个求和运算函数：
uint16_t func_sum(uint8_t val1, uint8_tval2)
{
Return (val1+val2);
}
这样的返回值就是函数执行后得到的数据结果。这个没有必要做太多的讨论。
返回状态结果，比如在上文提到的芯片官方的库接口，利用“0”和“-1”表示执行后成功或失败的结果。
在《嵌入式硬件通信接口-使用RingBuffer处理数据(二)详细设计过程》一文中的“读一个字节”、“读多个字节”和后续的其他函数，执行结束后返回的状态结果有成功和不成功的其他多个状态，这些个状态都是rb_ret_t枚举类型里的成员。
比如写多字节接口，如果执行失败，可能是参数错误、空间不足，这时非常有必要对不同的错误返回不同的状态结果，因此返回码不再是“0”和“-1”了，而是零和非零的其他值。
如何设计返回状态，也是有讲究的。如果因为一时的冲动，一闭眼一跺脚就把返回状态码给定下来，并且同一层、同一类的接口，状态结果定义的还不一致，那就太随便了，这样的接口封装出来，如果没有逐个对接口说明，指不定哪天蒙了自己也坑到别人。
定义返回状态结果，可以设计为：
布尔型(bool)的真、假；
枚举类型的各种状态码；
布尔型，在C++中使用，只有真、假两个状态，如果在基于C的嵌入式开发里使用，还需要重新定义。
类似于STM32的V3.5.0标准库里的三个枚举定义，每个枚举都只定义了两种状态，也可称之为布尔类型。
在设计自己的系统时，也可以直接使用这种枚举来定义函数返回的状态结果。
但是这里的枚举中，成员的值“0”表示失败、非“0”表示成功。这种方式定义的，失败只有一个情况，对后续的应用扩展也是个麻烦，比如不同的失败原因，如何体现到不同的返回状态结果，因此再考虑引入枚举类型的各种状态码。
“0”表示成功、非“0”表示失败，这个思维也符合计算机“0”为假、非“0”为真的逻辑特点。在程序执行时，成功了就是成功了，没必要去考虑为什么执行成功了，但是失败的时候，总是存在问题导致失败，这时候就需要对失败做分析，那么失败原因很多，对计算机而言，逻辑“真”也很多，1、2、3、…、99、…、N只要不是“0”，就是非“0”的逻辑“真”。
枚举类型的各种状态码，主要是为了解决，在出现不同的失败原因时，返回错误码，可以方便上层应用对参数进行检查，尝试调整参数重新调用接口再次执行；或者对错误码分别处理后展示在用户交互接口，提示用户执行某一功能时返回的状态。
可见在C开发里，同样是枚举类型的返回值，为什么不扩展枚举的成员来表示复杂多样的执行结果呢。
同时在编写函数时，利用枚举类型定义函数的返回类型，对开发而言，查看枚举类型中的成员表，可快速知道，函数的执行结果可能会有什么样的状态，至少有个预期的判断。
这样一来就可以为每个模块、每个层封装好的函数，设计对应的返回类型。
总结，说到底这些都只是开发者日常的编程习惯罢了，或者接口设计的规范。返回值的类型定义，谈不上绝对的对和错，对错只有在程序执行的时候，判断的依据选择。但是一个好的编码规范、统一的对照表，这对代码的维护和迭代，都有非常关键的作用！
★★★★★推荐文章
《【嵌入式编程】平台大小端存储差异解决办法》
《嵌入式硬件通信接口-使用RingBuffer处理数据(二)详细设计过程》
《嵌入式硬件通信接口-使用RingBuffer处理数据(一)》
《快速开发MQTT（一）电子工程师眼中的MQTT》
《快速开发MQTT（二）初识MQTT》
《MQTT客户端搭建-最清晰的MQTT协议架构》
《MQTT服务端搭建-最快方式验证自己开发的客户端》
★★★★★相似文章
《嵌入式硬件通信接口协议-UART（五）数据包设计与解析》
《嵌入式硬件通信接口协议-UART（四）设计起止式的应用层协议》
《嵌入式硬件通信接口协议-UART（三）快速使用串口及应用》
《嵌入式硬件通信接口协议-UART（二）不同电气规范下的标准》
《嵌入式硬件通信接口协议-UART（一）协议基础》
《嵌入式硬件通信接口协议-SPI（二）分层架构设计模拟接口》
《嵌入式硬件通信接口协议-SPI（一）协议基础》
★★★★★扩展阅读
《【硬件电路】AltiumDesigner18规则检查含义》
《【硬件电路】N沟道、P沟道MOS管基本原理与应用案例》
www.digcore.cn
更多技术干货等你来拿
长按二维码关注
戳原文，更有料！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/800658ee1ac6e403b470161d259d5745/" rel="bookmark">
			程序员干货学习资源(持续更新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言（程序员学习资料汇总-&gt;转自http://www.heqiangfly.com/2016/12/01/materials-programmer-materials/） 记录一些作为一名程序员在学习道路上经常用到的一些资料，以备不时之需。
资料篇 技术网站 开发社区
CSDN：号称全球最大的中文IT社区，很多业界大牛在上面开通有博客云栖社区：云栖社区是面向开发者的开放型技术平台。源自阿里云,服务于云计算技术全生态。ChinaUnix：号称全球最大的Linux/Unix应用与开发者社区51CTO：中国领先的IT技术网站博客园：老牌开发者社区stackoverflow：技术问题问答网站伯乐在线：技术博客、IT职场、书籍教程CTOLib码库：每日更新收录实用的开源项目和资源GitHub：代码托管平台码云：类似GitHub的代码托管平台红联Linux：中国领先的Linux技术网站PHP100中文网：中国第一档PHP资料分享门户ITPUB：IT技术社区IBM DeveloperWorks：IBM中国开发者社区，有一些不错的技术资料Intel® Developer Zone：Intel中国开发着社区MOZILLA 开发者网络：MOZILLA开发者社区百度开发者中心：PHPChina开发者社区：并发编程网：致力于让天下没有难学的技术这一使命，包括Java，C++，JS，开源框架，管理和架构等，致力于精品技术的研究和传播。 Android开发
Android Developers：Android官方开发者网站，有各种开发文档可以阅读，以及下载开发工具，英语不太好的可以选择“简体中文”哦！Android Open Source ProjectAndroid 常用自定义效果和控件： 网站开发
Discuz：Discuz社区Ecshop：开源网店系统Shopnc：商城系统WordPress：一种使用PHP语言开发的博客平台Django：Python Web应用框架webpy：Python Web应用框架 IT业界资讯
虎嗅：聚合优质的创新信息与人群,捕获精选|深度|犀利的商业科技资讯。猎云：创业项目推荐创业创新咨询cnBeta：中文业界资讯网站FreeBuf：关注黑客与极客 源码网站
codota：如果你不知道一个Android的类怎么用，可以在Codota上面快速的找到很多不错的示例代码。android.googlesource：Android所有的源代码都在这里，只需找到对应想要的模块，用Git克隆下来即可。比如，我想要的framework代码。androidxref：GrepCode：除了AndroidXRef可以查看某个类的源代码外，GrepCode同样也能做到。而且GrepCode不限于Android的源码 学习网站
W3SchoolW3Cschool：注意和W3School一字之差。W3Cschool是一个专业的编程入门学习及技术文档查询网站,提供包括HTML,CSS,Javascript,jQuery,C,PHP,Java,Python,Sql,Mysql等编程语言和开源技术的在线教程及使用手册。设计前端、服务器、大数据、移动端等技术。菜鸟教程：涵盖前端、服务器、Android等教程Leetcode，Leetcode中文版：在线技术平台，编程做题牛客网：专业IT笔试面试备考平台 技术博客 技术团队博客
美团点评技术团队：一个非常接地气的技术博客，涉及内容广泛，例如：支付通道开发、插件化实践、前端项目等等。事无巨细的总结好他们的思路给你。魅族内核团队：魅族内核团队发表的一些博客今日头条技术博客：众所周知今日头条有着一项强大的技术武器——推荐引擎。这个博客里面关于机器学习的内容非常丰富。文章也清晰有条理，他会交代实践背景、要求、失败案例、难点、最后给出一个甚至几个优选方案。Tencent ISUX：ISUX是腾讯核心设计团队,负责腾讯社交网络相关产品的用户体验设计与研究。主要涉及互联网产品的设计、重构、前端、用研等。淘宝前端团队（FED）TGidea：腾讯游戏的专业设计团队，工作范围涉及腾讯游戏旗下各类网游产品的包装、创意、网站等设计工作。Alloy Team：这个团队就厉害了，是腾讯的核心团队。他们致力于Web前端技术的研究，热衷HTML5、移动Web技术，用最酷的新技术开发各种有趣的开源项目。UED：阿里巴巴集团最为资深的用户体验设计部门之一，涉及领域有用户研究、交互设计、视觉设计、前端开发等。Google研究所：Linkdln：全球最大的职业社交网站，他们的技术团队从各个方面详细地介绍了LinkedIn技术人员如何使用高度结构化的数据来完成LinkedIn的搜索功能、社交图谱以及机器学习系统。Square：Square的技术博客包含的更多的是数据科学、数据分析、机器学习相关内容 CSDN博客
CSDN 官方博客老罗的Android之旅：CSDN排名前100，博客专栏“老罗的Android之旅”有对Android从上层应用到底层驱动的介绍，著有《Android系统源代码情景分析》一书。任玉刚：有“Android源码解析”和“Android开发小栈”两个专栏，著有《Android开发艺术探索》一书。eclipse_xu徐宜生：有“Android异步任务处理从零开始”，“android拼图游戏开发记录”和“Android UI开发详解”博客专栏，著有《Android群英传》一书。郭霖的专栏：CSDN排名前100北漂周：《Android安全技术揭秘与防范》一书的作者的CSDN博客Innost的专栏：作者邓凡平，《深入理解Android》一书的作者。 个人主页
阮一峰的网络日志：著有《ECMAScript 6入门》一书，并在该网站开源。廖雪峰的官方网站胡凯：腾讯开发者，翻译了一系列的Google Android性能优化典范的文章。Gityuan：作者是小米的MIUI系统工程师Gityuan(如果你想了解Android系统中常见模块的实现细节的话，非常推荐阅读这位开发者的博客，他的博客中文章的质量都非常高)，里面的“Friends”专栏有很多开发学习资料。Hujiawei Bujidao：很多Android系统性能相关的文章进击的程序员：老罗，罗升阳的个人博客站点Weishu’s Notes：有一些不错的文章HenCoder：大神扔物线的给高阶Android工程师的进阶手册 微信公众号 技术类
移动开发前线WeMobileDevAndroid程序员AndroidDeveloper：分享Android开发最新的技术与前沿消息Android订阅：定时发布不一样的Android干货，关注Android技术和交流平台Android干货分享：致力于Android技术交流,为大家及时快捷有效的提供Android技术方面的干货Android开发艺术探索安卓开发安卓开发精选安卓应用频道：分享安卓应用相关内容,包括:安卓应用开发、设计和推广菜鸟教程caoz的梦呓程序视界程序猿：为程序员提供最新最全的编程学习资料的查询.目前已经开通PHP、C/C++函数库、.NET Framework类库、J2SE API查询功能程序员的那点事程序员的那些事：分享国内外同行的观点,关注程序员相关话题:IT资讯、职场分享、幽默、学习资源等程序员之家codeKKCPP开发者CSDN-CODE：CSDN旗下开源平台developerWorks：码农IO(manong.io),专注于IT技术干货分享eoe移动开发者社区：eoe移动开发社区 eoe.cn官方微博 @eoe移动开发者社区鸿洋互联网思维ImportNew：专注 Java 和 Android 技术分享.ImportNew 由两个 Java 关键字 import 和 new 组成.意指:Java &amp; Android 程序员学习新知识的网站InfoQ：关注中高端技术人员的社区媒体,促进软件开发领域知识与创新的传播Java编程JAVA开发者联盟：精彩的JAVA文章,实用的JAVA技术,经典的JAVA书籍尽在JAVA开发者联盟java一日一条技术最前线Linux爱好者牛客网：最全IT名企笔试/面试题库,免费提供在线笔试真题模考,并即时反馈得分及知识结构薄弱点,系统化快速提高备考效率PiasyPython开发者软件开发务实SegmentFault：中国最大的年轻开发者极客社区,我们为开发者提供最纯粹的技术交流和分享平台算法爱好者算法与数据结构腾讯BuglyWeMobileDev移动开发前线51CTO博客：51CTO技术博客倡导“原创·技术·分享“,愿我们和你一起悦享技术,悦享生活.更有美女小编随时与您畅聊技术哦最代码：高质量的代码服务携程技术中心：携程技术中心官方帐号，分享来自携程技术人的一手干货，及各类线上线下技术活动美团点评技术团队谷歌开发者：Google中国官方帐号郭霖：CSDN上郭霖的专栏的公众号极客公园：提供科技领域的前沿报道AI科技大本营：程序员转型第一站老马说编程GitChat：一种全新的IT知识交流方式HenCoder：大神扔物线的给高阶Android工程师的进阶手册视觉求索：计算机视觉领域资深华人教授与研究员共同发起的、非盈利性的、独立于产业界的移动新媒体平台云栖社区：由阿里云负责运营、阿里巴巴技术协会和阿里巴巴集团各技术团队提供内容支持的开放式技术社区淘宝前端团队LeetCode领扣：LeetCode官方微信公众号 其他
斗牛人伯乐在线：关注职业资讯;学习各类职业感悟、心得和经验分享,扩大职业视野;体会求职、工作和创业的历程 - 就在JobBole.com 伯乐在线创业新锋管理思维拾遗玩车教授移动互联网创业网移动互联网咨询 开源项目 关于开源项目的网站
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/800658ee1ac6e403b470161d259d5745/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f008c2ef49a65148ceb8bcf45c333276/" rel="bookmark">
			关于北京中科银河芯(GXCAS)----国产新一代温度传感器芯片GX18B20的性能以及实用性研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字温度传感器
北京中科银河芯科技有限公司是中国科学院微电子研究所参股的产业化公司，公司以研发具有自主知识产权的核心芯片产品为使命，致力于传感器类芯片的研发。公司研发团队2018年成功推出新一代温度传感器产品，在精度、可靠性、稳定性等方面都达到了一个新高度。产品目前应用领域包括温度控制器、工业系统、消费品、粮情测温、智能感知和感热系统。
技术特征
采用单总线接口仅需一个端口引脚进行通信每颗芯片具有全球唯一的64位序列号具有多点分布式测温功能无需外围元器件可通过数据线供电：供电电压范围为2.5V~5.5V温度测量范围-55℃to+125℃（-67℉to+257℉）温度精度：&lt;±0.4℃（-10℃-85℃范围内）转换精度9-12为可选转换时间：&lt; 500ms超强静电保护能力：HBM 8000V MM 800V采用低功耗设计，待机电流功耗1vA/3V(典型值) 成本低
目前一颗GX18B20只需不到3元人民币，仅为DS18B20价格的60%左右，但性能已经超过DS18B20。
分布式测温
GX18B20在一根总线上可以挂接超过100颗，因此与模拟传感器以及其他接口方式（I2C、SPI）的数字传感器相比，可以大大较少布线资源，降低系统复杂度。GX18b20的特性使得它可以很便捷的应用到许多领域，例如粮情测温，目前中科银河芯已经开发出了多套应用于各种环境的测温系统。
GX18b20多颗应用
北京中科银河芯专注自主研发，打造属于自己的具有自主知识产权的高性能温度传感器芯片。
在此基础上，中科银河芯还提供多种封装，使GX18b20的应用场景更加广泛。
TO92封装 小体积封装
详情请联系：13811184996 郭先生
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ef0cc7267a08a387851389a4609d6ca/" rel="bookmark">
			设置居中的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML中设置水平居中的几种方法： 居中的元素可以分为：行内元素和块状元素，其中块状元素又定宽块状元素和不定宽块状元素。
常见行内元素有： &lt;span&gt;标签，&lt;br&gt;标签，&lt;i&gt;标签，&lt;em&gt;标签，&lt;strong&gt;标签，&lt;q&gt;标签，&lt;code&gt;标签，&lt;a&gt;标签
常见块级元素为：&lt;p&gt;标签，&lt;hx&gt;标签，&lt;hr&gt;标签，&lt;div&gt;标签，&lt;ul&gt;标签，&lt;ol&gt;标签，&lt;table&gt;标签，&lt;form&gt;标签
1.对于行内元素，如果被设置居中的元素是文字或者图形的形式，那就需要通过给父元素设置text-align：center来实现
2.对于定宽的块级元素，使用text-align：center就无效了。这里如果需要设置居中，则必须通过设置左右两边的margin值为“auto”来实现。auto的意思是自动分配剩余空间，margin：10px auto是margin-top：10px；margin-bottom：10px；margin-left：auto；margin-right：auto；的缩写形式。所以左右两边元素剩余区域各自均分，也就是元素两侧的区域各自占50%，那么元素就左右居中了。
3.对于宽度不固定的块级元素，通常有3种方式来实现居中： first ：通过table元素来实现（table元素具有长度自适应性，其长度根据其内文本长度决定，因此可以看做一个定宽度块元素。然后结合上面的定宽块级元素居中方法就可以设置居中了。 缺点是：会生成无语义的代码）
second：设置display：inline方法，将显示类型设为行内元素（该方法用于居中不定宽块级元素则更好理解，通过将元素设置为行内元素，设置行内元素的父元素属性text-align：center就可以实现居中 缺点是：由于转换成了行内元素，导致元素损失了块级元素具有长度值等属性）
third：设置position：relative，利用相对定位的方式，将元素向左偏移50%来实现居中。（该方法利用相对定位的方式来居中不定宽块级元素，首先给父元素设置float属性，float：left；然后给父元素设置relative定位属性和left：-50%，这样就能实现居中）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c54c04c409a0f49135e2c46e4337938/" rel="bookmark">
			算法 穿越沙漠问题（递推法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 一辆吉普车来到1000km宽的沙漠边沿。吉普车的耗油量为1L／km，总装油量为500L。显然，吉普车必须用自身油箱中的油在沙漠中设几个临时 加油点，否则是通不过沙漠的。假设在沙漠边沿有充足的汽油可供使用，那么吉普车应在哪些地方、建多大的临的加油点，才能以最少的油耗穿过这块沙漠?
问题分析 储油点地址的确定比较复杂，从出发点考虑问题，很难确保按要求以最少的耗油量穿越沙漠，即很难保证到达终点时，沙漠中的各临时油库和车的储油量都恰好为0。所以我们从终点向起点应用逆推法。
过程：
为了做到耗油最少，那么每次吉普车出发时都应满载，放下一部分油再返回时，油恰好用完，并且把下一个油库建好后这个油库中的油恰好用完。所以每个点的油库中的油都应是吉普车装油量的整数倍(因为出发时满载)，即500n(n为正整数)，并且每个点的 存油量为下一个点的存油量及吉普车为建立下个油库在两点之间往返的油耗之和 (下一个油库建成，前一个油库中的油恰好用完)。
（1）由题可知，吉普车满载可以走500km。所以，第一段（即离终点最近的一段）长度为500km，并且，第一个加油点station_1（也是离终点最近的）的储油量为500L。
（2）那我们来看第二个加油点station_2。
它需要储存上一个加油点的储油量 + 车来往的耗油量。为了给station_1送500L油，车至少送两次油（因为中间路程要耗油嘛）。所以，车往返路程共3趟。
又考虑最少油耗，我们使这3趟路程耗油500L。那么station_2距station_1为500/3 = 167km，总共储油1000L。
（3）同样，我们看station_3。
为了给station_2送1000L油，至少送3次嘛，所以往返共5趟。
同样考虑耗油最少，那么station_3距station_2为 500/5 = 100km。
最后附上代码吧 /* dis为储油点到终点的距离 */ #include &lt;stdio.h&gt; int main() { int dis = 500, oil = 500; int k = 1; //因为不确定循环次数，又至少做一次，所以我们用do_while do { printf("储油点%d：距离出发点%5d,",k,1000-dis); printf("储油量%5dL\n",oil); k = k+1; dis = dis +500/(2*k-1); oil = 500*k; }while(dis&lt;1000); // 再计算出发点的储油量 oil = 500*(k-1)+(1000-dis)*(2*k-1); printf("储油点%d：距离出发点%5d,储油量%5dL\n",k,0,oil); return 0; } 输出结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73cbea03f9f554502a55ba36ec7c95a7/" rel="bookmark">
			Java程序员的黄金5年，从入行到大牛的晋升之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在程序界流行着一种默认的说法叫“黄金5年”，也就是一个程序员从入职的时候算起，前五年的选择直接影响着整个职业生涯中的职业发展方向和薪资走向，如何走好这5年，彻底从一个刚入行的菜鸟蜕变成可以以不变应万变的职业大牛，这是一个涉及到自身专业知识储备和选择的大难题，那么，这五年里，一个java程序员如何做才能完成从入行到大牛的晋升之路呢？
参加工作0-1年之间，java程序员必须要做得事儿 当你学会了Java的基础知识以后，你还不足以参加工作，你还需要继续深造。你必需要学会java开发框架。公司里为了提高开发的效率，会使用一些Java Web框架。目前比较主流的是SSM框架，即spring、springmvc、mybatis。你需要学会这三个框架的搭建，并用它们做出一个简单的增删改查的Web项目。你可以不理解那些配置都是什么含义，以及为什么要这么做，这些留着后面你去了解。但你一定要可以快速的利用它们三个搭建出一个Web框架，你可以记录下你第一次搭建的过程，在搭建的过程中，也可以顺便了解一下maven的知识。在你目前这个阶段，你只需要在网络上了解一下maven基本的使用方法即可，一些高端的用法随着你工作经验的增加，会逐渐接触到的。
Spring、Spring MVC源码
MyBatis源码
参加工作1-2年之间，Java程序员必须要做得事儿 这部分时间段的同学，已经对Java有了一个更加深入的了解。
这一年，你必须对于设计模式了如指掌，此外，设计模式并不是你这一年唯一的任务，你还需要看一些关于代码编写优化的书。总而言之，这个阶段，你的核心任务就是提高你的代码能力，要能写出一手优雅的代码。
另外，在过去2年的工作当中，你肯定或多或少接触过并发。这个时候，你应该去更加深入的了解并发相关的知识，与此同时，这个阶段你要做的事情还远不止如此。这个时候，你应该对于你所使用的框架应该有了更深入的了解，对于Java的类库也有了更深入的了解。因此，你需要去看一些JDK中的类的源码，也包括你所使用的框架的源码。总而言之，这个阶段，你需要做的是深入了解Java底层和Java类库，也就是JVM和JDK的相关内容。而且还要更深入的去了解你所使用的框架，方式比较推荐看源码或者看官方文档。
设计模式
并发编程
参加工作3-4年之间，Java程序员必须要做得事儿 这个阶段的同学，提升已经是很难了，而且这个阶段的学习往往会比较多样化。因为在前3年的过程中，你肯定或多或少接触过一些其它的技术，比如大数据、分布式缓存、分布式消息服务、分布式计算、软负载均衡等等。这些技术，你能精通任何一项，都将是你未来面试时巨大的优势，因此如果你对某一项技术感兴趣的话，这个时候可以深入去研究一下。这项技术不一定是你工作所用到的，但一定是相关的。
1、初识分布式架构
2、分布式架构策略
3、分布式消息通信
4、分布式缓存
5、数据存储
6、后台服务
7、高性能框架
8、分布式解决方案
参加工作4-5年之间，Java程序员必须要做得事儿 参加工作4年到5年的同学，相信你在自己所钻研的领域已经有了自己一定的见解，这个时候，技术上你应该已经遇到瓶颈了。这个时候不要着急提高自己的技术，已经是时候提高你的影响力了，你可以尝试去一些知名的公司去提高你的背景，你可以发表一些文章去影响更多的人。当然，你也可以去Github创建一个属于你的开源项目，去打造自己的产品。技术学到这个阶段，很容易遇到瓶颈，而且往往达到一定程度后，你再深入下去的收效就真的微乎其微了，除非你是专门搞学术研究的。然而很可惜，大部分程序猿做不到这一步，那是科学家做的事情。这个时候提高影响力不仅仅是因为技术上容易遇到瓶颈，更多的是影响力可以给你创造更多的机会。所以，在这个阶段，你最大的任务是提高自己的影响力，为自己未来的十年工作生涯那一天做准备。
开源项目
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61199d9f40269f320bec370d832d87a6/" rel="bookmark">
			sklearn中使用MLPRegressor实现回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用的数据集是上篇文章生成的test.txt文件经过一些处理后得到的数据集文件。
# -*- coding: utf-8 -*- #-------------------------- #from sklearn.neural_network import MLPClassifier #用于多分类的情况 #SciKit-learn库 可以创建神经网络 #MLP是多层感知器，使用的是前馈神经网络 #只支持交叉熵损失，使用mlp.predict_proda()，最小化交叉熵，同时给似然估计p(y|x) #支持多分类使用softmax #mlp = MLPClassifier(hidden_layer_sizes=(13, 13, 13), max_iter=500) #mlp.fit(xtrain, ytrain) #-------------------------- from sklearn.neural_network import MLPRegressor from sklearn.model_selection import train_test_split import numpy as np import matplotlib.pyplot as plt from sklearn import preprocessing a = np.loadtxt("./test.txt") scaler = preprocessing.StandardScaler().fit(a) a = scaler.transform(a) #print(a.shape) #get value from txt x = a[:,0] #get the first column from a y = a[:,1] ##get the second column from a X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61199d9f40269f320bec370d832d87a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe7f2513544b72ff3c9d6d209dacc2e6/" rel="bookmark">
			二分查找法-练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。
它要求必须是有序数组
查找过程 首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。
例:在有序数组中查找某个元素的位置:
package PracticeFunction; //有序数组中查找某个元素的位置 public class BinarySearch { public static void main(String[] args) { int[] arr = {1,2,3,4,5,6}; System.out.println(binarySearch(arr,5)); } static int binarySearch(int[] arr,int target) { //查找区间开始定义为整个数组,每和中间值比较一次大小,可以缩小一半的查找区间 int min = 0;//min是查找区间最左元素角标,初始为0 int max = arr.length-1;//max是查找区间最右边角标,初始为最大值 int mid = (min+max)&gt;&gt;1;//右移n位相当于除以2的n次方. while(min&lt;=max) { if(target&lt;arr[mid]) { max = mid-1;//若target&lt;arr[mid],则说明a在左半边,把查找范围缩小到左边一半,也就是把max移到mid左边 } else if(arr[mid]&lt;target){ min = mid+1;//若arr[mid]&lt;target,则说明a在右半边,把查找范围缩小到右边一半,也就是把min移到mid右边 }else { return mid;//若arr[mid]=target,mid就是a的位置角标 } mid = (max+min)&gt;&gt;1; } return -1;//没有该元素则返回-1 } } 二分查找的递归算法 递归算法有两个特点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe7f2513544b72ff3c9d6d209dacc2e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1838d85f43a83d6b5eb7cc68de4b9e02/" rel="bookmark">
			win32diskimager 谨慎使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前一个U盘用这个软件烧录Ubuntu镜像后，再烧录Centos发现 Centos安装时U盘启动不起来，然后U盘的大小也变了。感觉Win32diskimager对U盘的引导还是什么的破坏的厉害。
网上有网友说使用USBOOT或USBImage可以重置化被Win32diskimager处理过的U盘，可以解决这个问题。
转载于:https://www.cnblogs.com/yishuad/p/10467724.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef64ed22406804235aa251372f108dde/" rel="bookmark">
			绘制sklearn分类结果图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想解决这样一个问题：
怎样使用matplotlib画出scikit-learn的分类报告，也就是 classification_report的输出。例如下面这个report：
print('\n*Classification Report:\n', classification_report(y_test, predictions), confusion_matrix_graph = confusion_matrix(y_test, predictions)) 生成总结报告：
Clasification Report: precision recall f1-score support 1 0.62 1.00 0.76 66 2 0.93 0.93 0.93 40 3 0.59 0.97 0.73 67 4 0.47 0.92 0.62 272 5 1.00 0.16 0.28 413 avg / total 0.77 0.57 0.49 858 下面代码是具体实现及结果图：
import matplotlib.pyplot as plt import numpy as np def show_values(pc, fmt="%.2f", **kw): ''' Heatmap with text in each cell with matplotlib's pyplot Source: https://stackoverflow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef64ed22406804235aa251372f108dde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bbd4f226cc18c0a478e6b1c0ccca260/" rel="bookmark">
			深度学习：batch normlization
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.zhihu.com/question/38102762/answer/607815171
数据经过归一化和标准化后可以加快梯度下降的求解速度，这就是Batch Normalization等技术非常流行的原因，它使得可以使用更大的学习率更稳定地进行梯度传播，甚至增加网络的泛化能力.
一、什么是归一化/标准化 Normalization是一个统计学中的概念，我们可以叫它归一化或者规范化，它并不是一个完全定义好的数学操作(如加减乘除)。它通过将数据进行偏移和尺度缩放调整，在数据预处理时是非常常见的操作，在网络的中间层如今也很频繁的被使用。
1. 线性归一化
最简单来说，归一化是指将数据约束到固定的分布范围，比如8位图像的0～255像素值，比如0～1。
在数字图像处理领域有一个很常见的线性对比度拉伸操作： x减最小 除 最大减最小
X=(x-xmin)/(xmax-mxin)
它常常可以实现下面的增强对比度的效果。不过这个的归一化方法有个非常致命的缺陷，当X最大值或者最小值为孤立的极值点，会影响性能。
2. 零均值归一化/Z-score标准化 减均值 除方差
零均值归一化也是一个常见的归一化方法，被称为标准化方法，即每一变量值与其平均值之差除以该变量的标准差。
经过处理后的数据符合均值为0，标准差为1的分布，如果原始的分布是正态分布，那么z-score标准化就将原始的正态分布转换为标准正态分布，机器学习中的很多问题都是基于正态分布的假设，这是更加常用的归一化方法。
以上两种方法都是线性变换，对输入向量X按比例压缩再进行平移，操作之后原始有量纲的变量变成无量纲的变量。不过它们不会改变分布本身的形状，下面以一个指数分布为例：
如果要改变分布本身的形状，下面也介绍两种。
3.正态分布Box-Cox变换
box-cox变换可以将一个非正态分布转换为正态分布，使得分布具有对称性，变换公式如下：
在这里lamda是一个基于数据求取的待定变换参数，Box-Cox的效果如下。
4. 直方图均衡化
直方图均衡也可以将某一个分布归一化到另一个分布，它通过图像的灰度值分布，即图像直方图来对图像进行对比度进调整，可以增强局部的对比度。
它的变换步骤如下：
(1)计算概率密度和累积概率密度。
(2)创建累积概率到灰度分布范围的单调线性映射T。
(3)根据T进行原始灰度值到新灰度值的映射。
直方图均衡化将任意的灰度范围映射到全局灰度范围之间，对于8位的图像就是(0,255)，它相对于直接线性拉伸，让分布更加均匀，对于增强相近灰度的对比度很有效，如下图。
综上，归一化数据的目标，是为了让数据的分布变得更加符合期望，增强数据的表达能力。
在深度学习中，因为网络的层数非常多，如果数据分布在某一层开始有明显的偏移，随着网络的加深这一问题会加剧(这在BN的文章中被称之为internal covariate shift)，进而导致模型优化的难度增加，甚至不能优化。所以，归一化就是要减缓这个问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec3fedf78cd90b978904be3bd37cdf89/" rel="bookmark">
			初步使用gstreamer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，验证您是否有可用的安装，并且可以通过键入来检查插件
$ gst-inspect-1.0 fakesrc
这应该打印出一堆关于这个特定元素的信息。如果这告诉您“没有这样的元素或插件”，则表示您尚未正确安装GStreamer。请检查如何让GStreamer的如果失败，其他任何消息，我们将不胜感激一个bug报告。
是时候尝试一些事情了。从gst-launch和两个你应该拥有的插件开始：fakesrc和fakesink。它们除了传递空缓冲区外什么都不做 在命令行键入：
$ gst-launch-1.0 -v fakesrc silent=false num-buffers=3 ! fakesink silent=false
这将打印出类似于此的输出：
RUNNING pipeline …
fakesrc0: last-message = “get ******* (fakesrc0:src)gt; (0 bytes, 0) 0x8057510”
fakesink0: last-message = “chain ******* (fakesink0:sink)lt; (0 bytes, 0) 0x8057510”
fakesrc0: last-message = “get ******* (fakesrc0:src)gt; (0 bytes, 1) 0x8057510”
fakesink0: last-message = “chain ******* (fakesink0:sink)lt; (0 bytes, 1) 0x8057510”
fakesrc0: last-message = “get ******* (fakesrc0:src)gt; (0 bytes, 2) 0x8057510”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec3fedf78cd90b978904be3bd37cdf89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e8a89c189bdf70c6fcc5c0db18a8ae0/" rel="bookmark">
			汇编指令之MOV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汇编指令之 MOV - 传送字或字节 学习来自 汇编语言MOV指令 mov指令详解 Assembly - Addressing Modes 汇编用户指南-MOV 简单格式：mov dst,src 扩展格式1：MOV{S}{cond} Rd, Operand2 扩展格式2：MOV{cond} Rd, #imm16 1、从寄存器到寄存器(寄存器寻址)
MOV EAX, EBX;	Both the operands are in registers MOV AX, BX;	将BX寄存器的16位数据传送到AX寄存器 2、立即数到寄存器(立即寻址)
MOV DX, TAX_RATE ; Register in first operand MOV COUNT, CX	; Register in second operand MOV AL, 20H;	将8位数据20H传送到AL寄存器 MOV AX, 2000H;	将16位数据2000H传送到AX寄存器 其中：B1、W1和D1分别是字节、字和双字单元。 MOV AH, 80H	ADD AX, 1234H	MOV ECX, 123456H MOV B1, 12H	MOV W1, 3456H	ADD D1, 32123456H 3、立即数到存储单元
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e8a89c189bdf70c6fcc5c0db18a8ae0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57109525069979a18a24538c35f1fafc/" rel="bookmark">
			单机多卡并行计算填坑记：keras
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 keras的单机多卡并行计算简单粗暴，可是。。。。。。。
训练一时爽，重载火葬场，哭哭。下面上干货
首先单CPU/GPU模型转多GPU模型：
from keras.utils import multi_gpu_model model = getmodel()#单卡模型 n_GPUs = 3# &gt;=2 mode_M = multi_gpu_model(model,n_GPUs)# ok,转好了 是不是简单粗暴啊，然而问题来了，当训练完成之后该如何保存呢？注意mode_M在训练后还是并行模型，直接保存将不再适用单卡的载入和使用，必需要在同样的环境下才能读入，因此我们应该：
model.save("model.h5") 这样我们在载入模型时就不会出现某些神奇的问题比如只剩一层模型这样的骚操作。（哭哭）
可是当我们想保存检查点的时候，问题就来了，保存的全是并行模型（再哭哭）。为了解决这个问题可在多卡端将该模型转成单卡模型即可解决。
from keras.utils import multi_gpu_model model_dir = "" model = get_model() n_GPUs = 2 model_M = multi_gpu_model(model,n_GPUs) model_M.load_weights(model_dir) model.summary()#验证一下 model.save(model_dir) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc31cd0d384568cac5ce7bdbe9ff481f/" rel="bookmark">
			一条SQL更新语句的执行过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一条SQL更新语句的执行过程 1、redo log（重做日志）举一个小栗子： 2、binlog（归档日志）3、两阶段提交4、两个参数 mysql&gt; update T set c=c+1 where ID=2; 执行语句前要先连接数据库，这是连接器的工作。
接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。
与查询流程不一样的是，更新流程还涉及两个重要的日志模块：redo log（重做日志）和 binlog（归档日志）。
1、redo log（重做日志） 举一个小栗子： 不知道你看过《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。
如果有人要赊账或者还账的话，掌柜一般有两种做法：
一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。 在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？
同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。
具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。
如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。
与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。
write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。
write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc31cd0d384568cac5ce7bdbe9ff481f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c68ea6c7d40e477c61ca6a970546ebaa/" rel="bookmark">
			最强最新：关于oracle developer显示 IO错误：The Network Adapter could not establish the connection解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这学期新开了Oracle 11g 数据库管理的课程，然后第一次实验就要我们自行安装Oracle 11g 今天周六原本打算花个几分钟安装了然后继续备赛蓝桥杯的，但是出现了网络适配器等等的问题，然后我就各种百度看别人的博客，最后算是成功了（附上成功的图）然后把我看到的一些问题进行总结。
- The Network Adapter could not establish the connection问题 解决办法：
1. 可能的错误主机名或用户名 我发现我最后并不是这个错误，也许你们也出现和我一样的，主机名就用localhost表示本地
我的错误在哪呢？是哪个用户名！！！我用的是自定义的 但是数据库默认的应该是system 我这里把主机名写成了 system显然会错出现网络适配器的错误！
2. 端口号的错误 我们数据库默认的端口是1521
我们可以进行查看自己的端口是不是1521
第一步，win+R 输入cmd
第二步：在dos界面中输入tnsping orcl(当然orcl是你的sid,只要你没改过默认sid就是orcl），得到如下信息：
第三步：然后注意这里：
第四步：
按照给出的文件路径找到admin目录
（其实已经知道了本地是1521了，但是我们可以从源文件里面确认一下）
我们用记事本打开 得到如下（1521）：
第六步：
在这里你看到你的端口号了吗？有的是1521有的是1522。然而连接sql developer的时候默认的端口号是1521。所以这时候你要把你的测试连接的端口号改到跟你的 tnsames.ora 文件中的端口号一致，然后测试连接！最后就能成功了
如果上面方法还没有成功！还有一种解决方式： 1. 配置监听程序:
我们先打开安装Oracle 11g配套的一个管理工具：Net Manager 按照如下方式配置：
2.打开监听服务
右键点击计算机—&gt;管理—&gt; 服务与应用程序 —&gt; 服务 —&gt; 将oracle0raDb11g_home1ClrAgent、 oracleOraDb11g_home1TNSListener和oracleServiceORCL这三项启动即可 （自己电脑开自动就行）
3.防火墙设置，将Oracle服务加入防火墙
在控制面板里面打开防火墙设置，然后高级设置出现这个界面:
只要安装包不出问题，应该是能够解决连接问题的!
学如逆水行舟，不进则退 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86fd3220dc6d8094b293cbec9263d00/" rel="bookmark">
			python实现计算精度、召回率和F1值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python实现计算精度、召回率和F1值 摘要：在深度学习的分类任务中，对模型的评估或测试时需要计算其在验证集或测试集上的预测精度（prediction/accuracy）、召回率（recall）和F1值。本文首先简要介绍如何计算精度、召回率和F1值，其次给出python编写的模块，可直接将该模块导入在自己的项目中，最后给出这个模块的实际使用效果。
一、混淆矩阵及P、R、F1计算原理 1、混淆矩阵
在进行二分类或多分类任务中，对于预测的评估经常需要构建一个混淆矩阵来表示测试集预测类与实际类的对应关系，混淆矩阵横坐标表示实际的类，纵坐标表示预测的类。混淆矩阵属于 n × n n\times n n×n 方阵，其中 n n n 表示类的个数。矩阵可用下面表示：
c o n f m a r t i x ( t r u e L a b e l , p r e d i c t L a b e l ) confmartix(trueLabel,predictLabel) confmartix(trueLabel,predictLabel)
因此该矩阵的某一个元素 c o n f m a r t i x ( i , j ) confmartix(i,j) confmartix(i,j) 表示实际类 i i i 被预测成 j j j 的样本个数。很显然，当前仅当 i = j i=j i=j ，即矩阵的主对角线上的元素表示被预测正确的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a86fd3220dc6d8094b293cbec9263d00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9251a59a3e3314a227c1eabf0eba5a66/" rel="bookmark">
			Android  腾讯信鸽集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：创建应用
信鸽官网可以直接使用QQ登录
点击个人信息—&gt;我的应用—&gt;新建应用
选择平台
填写配置
完成配置
二：开始在项目中配置
在app的build的文件中
在android里的defaultConfig里
//信鸽官网上注册的包名.注意application ID 和当前的应用包名以及 信鸽官网上注册应用的包名必须一致。 applicationId "你的包名" ndk { //根据需要 自行选择添加的对应cpu类型的.so库。 abiFilters 'armeabi', 'armeabi-v7a', 'arm64-v8a' // 还可以添加 'x86', 'x86_64', 'mips', 'mips64' } manifestPlaceholders = [ XG_ACCESS_ID:"注册应用的accessid", XG_ACCESS_KEY : "注册应用的accesskey", ] 依赖
//信鸽普通版本jar，不包含厂商通道 implementation 'com.tencent.xinge:xinge:4.0.5-release' //implementation'com.tencent.xinge:xinge:4.3.1-beta' //jg包 implementation'com.tencent.jg:jg:1.1' //wup包 implementation 'com.tencent.wup:wup:1.0.0.E-release' //mid包，minSdkVersion 14 implementation 'com.tencent.mid:mid:4.0.7-Release' 注意：
如果在添加以上 abiFilter 配置之后 Android Studio 出现以下提示： NDK integration is deprecated in the current plugin. Consider trying the new experimental plugin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9251a59a3e3314a227c1eabf0eba5a66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e7500ca049d3151c94ba7b801830678/" rel="bookmark">
			java 5种方式读取配置文件 &#43; 修改配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式一：采用ServletContext读取，读取配置文件的realpath，然后通过文件流读取出来。 因为是用ServletContext读取文件路径，所以配置文件可以放入在web-info的classes目录中，也可以在应用层级及web-info的目录中。文件存放位置具体在eclipse工程中的表现是：可以放在src下面，也可放在web-info及webroot下面等。因为是读取出路径后，用文件流进行读取的，所以可以读取任意的配置文件包括xml和properties。缺点：不能在servlet外面应用读取配置信息。
具体举例如下：
//	ServletContext.getRealPath(name)读取路径 privatevoid test1(HttpServletRequest request, HttpServletResponseresponse)throwsServletException,IOException { //response.setContentType("text/html;charset=utf-8"); String path = "/WEB-INF/jdbc_connection.properties"; //读取WEB-INF中的配置文件 String realPath = getServletContext().getRealPath(path);//getServletContext()相当于http://localhost/demo05 //所以后面的path只需要以应用demo/开头具体的部署目录路径即可，如上面的/web-in… System.out.println(realPath); InputStreamReader reader =new InputStreamReader(newFileInputStream(realPath),"utf-8"); Properties props = new Properties(); props.load(reader); //load个人建议还是用Reader来读，因为reader体系中有个InputStreamReader可以指定编码 String jdbcConValue = props.getProperty("jdbc_con"); System.out.println(jdbcConValue); System.out.println("加载src包下的资源------------------------"); path = "/WEB-INF/classes/com/test/servlet/jdbc_connection.properties"; //读取WEB-INF中的配置文件 realPath=getServletContext().getRealPath(path); System.out.println(realPath); reader = new InputStreamReader(new FileInputStream(realPath),"utf-8"); props.load(reader); //load个人建议还是用Reader来读，因为reader体系中有个InputStreamReader可以指定编码 jdbcConValue = props.getProperty("jdbc_con"); System.out.println("second::"+jdbcConValue); } 方式二：采用ResourceBundle类读取配置信息， 优点：可以以完全限定类名的方式加载资源后，直接的读取出来，且可以在非Web应用中读取资源文件。
缺点：只能加载类classes下面的资源文件且只能读取.properties文件。
/** * 获取指定配置文件中所以的数据 * @param propertyName * 调用方式： * 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e7500ca049d3151c94ba7b801830678/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1d50dea3fd4c0a9f209b85258273a36/" rel="bookmark">
			二进制负数用补码表示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
思路：
负数部分 先取绝对值 然后减一 取余化为二进制 然后全部取反
#include&lt;iostream&gt; using namespace std; class Solution { public: int NumberOf1(int n) { char B[32]={'0'}; int b=1,a,c=0; if(n&lt;0) b=-1; b&gt;0?a=n:a=b*n-1; for(int i=31;i&gt;=0;i--){ //化为2进制 B[i]=a%2+'0'; if(B[i]=='1') c++; a=a/2; } if(b&lt;0) c=32-c; //取反 return c; } }; 正常思路n&amp;1 n&lt;&lt;左移就行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e23c57f645f67e2bc3d743b7ba52690/" rel="bookmark">
			JPEG图像压缩优化-算术编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：(https://blog.csdn.net/shelldon/article/details/54234436)
开场白 JPEG使用了量化、Huffman编码等，极大地压缩了图片的大小。DropBox开源的lepton，在JPEG基础上，可以再节省22%左右的空间。lepton中使用算术编码（VP8）替换Huffman编码，以得到更高的压缩率。
算术编码（Arithmetic Coding）发展历史 1948年，香农提出将信源符号依其概率降序排序，用符号序列累计的二进制作为对信源数据的编码。
1960年，Peter Elias发现无需排序，只要编解码端使用相同的符号顺序即可，提出了算术编码的概念。
1967年，R. Pasco和J. Rissanen分别用丁昌德寄存器实现了有限精度的算术编码。
1979年，Rissanen和G. G. Langdon一起将算术编码系统化，并于1981年实现了二进制编码。
1987年，Witten等人发表了一个实用的算术编码程序，即CACM87，后用于ITUT的H.263视频压缩标准。同期，IMB公司发表了著名的Q-编码器，后用于JPEG和JBIG图像压缩标准。
算术编码介绍 无损数据压缩，熵编码。
一般熵编码把输入的消息分割为符号，然后对每个符号进行编码。算术编码是将整个要编码的数据映射到一个位于[0,1)的实数区间，这样可以让压缩率无线地接近数据的熵值，从而获得理论上的最高压缩率。
算术编码用到的两个基本参数：符号的概率和它的编码间隔。信源符号的概率决定压缩编码的效率，也决定编码过程汇总信源符号的间隔，而这些间隔包含在0到1之间。编码过程中的间隔决定了符号压缩输出后的输出。
算术编码可以是静态的或者自适应的。
在静态算术编码中，信源符号的概率是固定的。在自适应算术编码中，信源符号的概率根据编码时符号出现的频繁程度动态地进行修改，在编码期间估算信源符号概率的过程叫做建模。
需要开发动态算术编码的原因是，很难知道精确的信源概率。在压缩消息时，不能期待一个算术编码器获得最大的概率，所能做的最有效的方法是在编码过程中估算概率。因此动态建模就成为确定编码器压缩效率的关键。
算术编码思想 算术编码的基本原理是将编码的消息表示成实数０和１之间的一个间隔（Interval），消息越长，编码表示它的间隔就越小，表示这一间隔所需的二进制位就越多。
算术编码进行编码时，从实数区间[0,1)开始，按照符号的频度将当前的区间分割成多个子区间。根据当前输入的符号选择对应的子区间，然后从选择的子区间中继续进行下一轮的分割。不断的进行这个过程，直到所有符号编码完毕。对于最后选择的一个子区间，输出属于该区间的一个小数。这个小数就是所有数据的编码。
给定事件序列的算术编码步骤如下：
编码器在开始时将 “当前间隔 ” [ L， H) 设置为 [0， 1)。对每一个输入事件，编码器按下边的步骤（ a）和（ b）进行处理。
（a）编码器将“ 当前间隔”分为子间隔，每一个事件一个。一个子间隔的大小与将出现的事件的概率成正比。
（b）编码器选择与下一个发生事件相对应的子间隔，并使它成为新的 “当前间隔 ”。最后输出的 “当前间隔 ”的下边界就是该给定事件序列的算术编码。 在算术编码中需要注意几个问题：
由于实际计算机的精度不可能无限长，运算中出现溢出是一个明显的问题，但多数及其都有 16位， 32位或者 64位的精度，因此这个问题可以使用比例缩放方法解决。算术编码器对整个消息只产生一个码字，这个码字是在间隔[0,1)中的一个实数，因此译码器在接受到表示这个实数的所有位之前不能进行译码。算术编码是一种对错误很敏感的编码方法，如果有一位发生错误就会导致整个消息译错。 算术编码伪代码 定义一些变量，设 Low和 High分别表示 “当前间隔 ”的下边界和上边界；CodeRange为编码间隔的长度，即"当前间隔 "的长度；LowRange(symbol)和HighRange(symbol) 分别代表为了事件 symbol的编码间隔下边界和上边界。
如果symbol的编码间隔固定不变，则为静态编码；反之，如果 symbol的编码间隔随输入事件动态变化，则为自适应编码。
算术编码的编码过程可用伪代码描述如下：
set Low to 0 set High to 1 while there are input symbols do take a symbol CodeRange = High – Low High = Low + CodeRange *HighRange(symbol) Low = Low + CodeRange * LowRange(symbol) end of while output Low 算术编码解码过程用伪代码描述如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e23c57f645f67e2bc3d743b7ba52690/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/718bafac995cd53d85e63adeae50d231/" rel="bookmark">
			飞机大战html游戏全代码js、jquery操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		飞机大战html游戏全代码 博主的话运行图片目录路径飞机大战.htmlstyle.css进行下一个游戏的开发！注意事项 博主的话 当时博主只会html，css和原生JavaScript，假期用了一周编出来，那个时候的状态就是天天不想睡觉，就想把这个游戏编完。
后来博主开学了，去图书馆借了一本Jquery的书，于是就把原生JavaScript的代码改成了JQ形式。
我会把html文件、css文件提供下载地址，文件夹路径也展示给大家。但是图片就不给大家了，毕竟博主辛辛苦苦做出来的游戏。
但是！！！但是！！！我其实是很愿意给那些为了自己锻炼而需要参考我的代码的同志们。所以，大家有需要的话，请到这里：https://download.csdn.net/download/qq_43592352/12368541下载。
2019-3-1 留。
/***2019.11.13更新****/ 这是我最近写的横版的飞机大战，时隔9个月，游戏优化和代码优化都提升很多，大家可以看一下。
横版-飞机大战html游戏全代码js、jquery操作
运行图片 链接: 点击下载图片.
目录路径 所以大家想要程序跑起来的话，还需要jquery-3.3.1.js文件和img文件夹里面的图片。
飞机大战.html &lt;html&gt; &lt;head&gt; &lt;title&gt;飞机大战&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/style.css"/&gt; &lt;script src="jquery-3.3.1.js" type="text/javascript"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body &gt; &lt;div id="container"&gt; &lt;audio src="css/music/firstDesk.mp3" id="firstDesk" class="audio" autoplay="autoplay" loop="loop"&gt;&lt;/audio&gt; &lt;div id="tab"&gt; &lt;div id="tab_time" class="tabStyle"&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt; &lt;div id="tab_score" class="tabStyle"&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt; &lt;div id="tab_life" class="tabStyle"&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt; &lt;img src="css/img/life1.png" id="life1" class="lifeStyle"&gt; &lt;img src="css/img/life1.png" id="life2" class="lifeStyle"&gt; &lt;div id="tab_sound" class="tabStyle"&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt; &lt;img src="css/img/sound1.png" id="sound1" class="soundStyle"&gt; &lt;img src="css/img/sound2.png" id="sound2" class="soundStyle"&gt; &lt;/div&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/718bafac995cd53d85e63adeae50d231/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16c6b965fa21547856289c4d50e123ad/" rel="bookmark">
			PDF Password Remover 软件及其密钥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PDF Password Remover 软件及其密钥 下载链接操作步骤1、下载解压2、安装、注册3、软件的使用 声明 叙：在下载的一些PDF文件中存在一些有密码的（并非是指文件无法打开的，而是文件无法进行转换文件类型、格式，无法修改操作文件的密码设置），遇到这些也是很不爽，虽能理解但是毕竟要用到，所以在网上查询得知可以使用PDF Password Remover这个软件来去除掉文件上的密码，下载了个并且试了一下，但是发现要有密钥（机器码，激活码。。。都一个意思），在网上找了半天，才找到了一个，现在我把文件和密钥都压缩保存，有需要的可以下载；
下载链接 链接：https://pan.baidu.com/s/1J5_YViYHWguMej2LGAEwYA
提取码：fpay
操作步骤 1、下载解压 直接就是如下图所示的一个ppr.exe文件，还有一个名为密钥.txt的文件
2、安装、注册 安装好ppr.exe文件后打开，会发现未激活的右下角会有一个Buy …，点击它会弹出一个网页，让购买密钥，直接关闭网页，会发现有个填写密钥的弹出框，将密钥.txt文件中的密钥粘贴进去点击保存即可~
因为本人的软件已经安装成功，因为在此口述，不上操作原图了~
3、软件的使用 激活成功样式
如下图所示，右下角的购买按钮变成了此软件的官网；
激活了如何使用呢？其实使用起来很简单；
1.1、设置新文件存放位置
首先，设置好去除密码后的文件存放位置，因为此软件去除密码后的文件是一个新文件，并不是原来的那个文件（源文件还会存在），设置位置就是软件界面左下角文职的Outout Path链接区，如下所示：
点击选择新文件存放位置后即可（注意：每次启动软件都需要重新设置，否则会恢复默认的路径）；
1.2、选择去除密码的PDF文件
设置好路径后如何选择去除密码的PDF文件呢？点击如下所示的红框区域即可~
点击此红框区域后会弹出一个文件选择框，如下所示：
选择好后点击打开(O)按钮，软件会自动处理文件，速度很快，看到提示完成后去之前设定好的新文件存放路径下找到已经去除密码的文件即可~
声明 本人写此博客仅为有需要的个人提供便利，一切用于商业用途的行为均是违法的，且与本人无关，请谨慎使用；
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/413/">«</a>
	<span class="pagination__item pagination__item--current">414/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/415/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>