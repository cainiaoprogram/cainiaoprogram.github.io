<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/595e3f93c6b69b10a09b915f9eedf9b5/" rel="bookmark">
			使用ant-design组件FormModel双向绑定数据时数据字段未定义(对象有嵌套子类)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 ​ 本篇文章主要记录个人在公司项目开发中，ant-design 组件 FormModel 表单 (支持 v-model 检验)所遇到的问题。
​ 如果文章有歧义，请各位大佬指出，避免误导更多的人！！
正文 ​ 在日常项目开发中会遇到表单信息的修改提交；本人在使用ant-design-vue UI 的组件FormModel 表单 (支持 v-model 检验)时，双向绑定时会出现表单所绑定的对象下的字段不存在！
form 表单代码 &lt;a-form-model :form="form" :model="parameterEditForm" ref="ruleForm" :rules="rules"&gt; &lt;a-row :gutter="16"&gt; &lt;a-col :span="11"&gt; &lt;a-form-model-item :labelCol="labelCol" :wrapperCol="wrapperCol" prop="parameterName" label="参数名称" &gt; &lt;a-input placeholder="请输入" id="parameterName" v-model="parameterEditForm.parameterName" /&gt; &lt;/a-form-model-item&gt; &lt;/a-col&gt; &lt;a-col :span="11" &gt; &lt;a-form-model-item :labelCol="labelCol" :wrapperCol="wrapperCol" label="功能码" &gt; &lt;a-input placeholder="请输入" id="functionCode" v-model="parameterEditForm.function.functionCode" /&gt; &lt;/a-form-model-item&gt; &lt;/a-col&gt; &lt;/a-row&gt; &lt;a-row :gutter="16"&gt; &lt;a-col :span="11" :offset="1"&gt; &lt;a-button type="primary" style="margin-left:20px;"&gt; 提交 &lt;/a-button&gt; &lt;a-button style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/595e3f93c6b69b10a09b915f9eedf9b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6004371ff4409a794d1059314928a572/" rel="bookmark">
			从GitHub中下载代码并用jupter代开运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这不就打开学代码的新大门！！！！！
前提条件：
克隆步骤：
打开模式：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b100266adaaa8bbd9d2b0da0e32f442e/" rel="bookmark">
			虚拟机中的主机、NAT、桥接模式的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主机模式：host-only，仅主机模式，是一种比NAT模式更加封闭的网络连接模式，创建完全包含在主机中的专用网络。仅主机模式的虚拟网络适配器仅对主机可见，并在虚拟机和主机之间提供网络连接。在默认情况下，仅主机模式网络连接的虚拟机无法连接到Internet。在一个主机上可以设置多个仅主机模式的虚拟机，如果处于同一仅主机模式网络中，他们可以通信；如果处于不同仅主机模式网络，默认情况下无法通信，可在他们之间设置路由器来实现通信。
NAT模式：Net Address Translation的缩写，即网络地址转换。NAT模式是VMware创建虚拟机的默认网络连接模式，使用NAT模式网络连接时，VMware会在主机上建立单独的专用网络，用以在主机和虚拟机之间相互通信。虚拟机再向外部网络发送请求数据“包裹”，都会交给NAT网络适配器进行“特殊标记”并以主机名发出去，外部网络返回的响应数据“包裹”，由主机接收，交给NAT网络适配器根据“特殊标记”进行标识交给对应的虚拟机。因此，虚拟机在外部网络不需要有自己的IP地址，外部网络来看，虚拟机和主机共用一个IP地址，默认情况下，外部网络终端无法访问到虚拟机。在一台主机上只允许创建一个NAT模式的虚拟网络。在一台主机上的多个采用NAT模式网络连接的虚拟机也可进行相互访问。
桥接模式：VMware中的桥接模式将虚拟机的虚拟网络适配器与主机的物理网络适配器进行交接，虚拟机中的虚拟网络适配器可通过主机中的物理网络适配器直接访问到外部网络。好比在局域网中添加了一个独立的新的计算机。虚拟机会占用局域网络中的一个IP地址，并且可以和其他终端进行相互访问。支持有线和无线网络适配器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/727e6c955c5c11e711ca4ea6a9c050f1/" rel="bookmark">
			将时间转换为指定的时区时间，字符串时间和时间戳互相转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 时间字符串转换时间戳 export function timeNum(time: string) { let date = time.replace(/-/g, '/'); var timestamp = new Date(date).getTime(); return timestamp } // 时间戳转换字符串日期 export function timestr(num: number) { var date = new Date(num); //根据时间戳生成的时间对象 let Month = date.getMonth() + 1 &lt; 10 ? '0' + (date.getMonth() + 1) : (date.getMonth() + 1) let day = date.getDate() &lt; 10 ? '0' + date.getDate() : date.getDate() let hours = date.getHours() &lt; 10 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/727e6c955c5c11e711ca4ea6a9c050f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be667d15fe33922bf28f46b06ba5ee86/" rel="bookmark">
			scss语法，使用for循环批量设置class类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在我们写项目一般都是用scss写css，相关知识可以参考这篇文章。
scss中可以使用for循环批量设置具有相同规则的类，设计图中经常有不同透明度的颜色，如下：
color: rgba(0, 0, 0, 0.72); color: rgba(0, 0, 0, 0.12); 我们就可以把不同透明度的颜色都设置成一个class，当然可以一个一个写，但是就很麻烦，所以我们可以使用scss的for循环
注意rgba的第四个参数是0-1之间的值，这里class名称使用了乘100后的数字，是因为class中不能有小数点，乘100后用起来也更方便，随后在设置值的时候需要除100；
scss的语法可以看官方文档，在这个例子中涉及到的语法如下
@for循环
$开头定义变量，第1个例子中变量名字就是i，也可以定义成其他名称,如例子2
#{} 插值语句
// 例子1， 白色，不同透明度 @for $i from 1 through 100 { .white-#{$i} { color: rgba(255,255,255, calc($i / 100)) } } // 例子2，黑色，不同透明度 @for $myVal from 1 through 100 { .dark-#{$myVal} { color: rgba(0,0,0, calc($myVal / 100)) } } 使用的方法如下：
&lt;ol style="background: red"&gt; &lt;li class="white-54"&gt;hello world&lt;/li&gt; &lt;li class="white-87"&gt;hello world&lt;/li&gt; &lt;li class="white-100"&gt;hello world&lt;/li&gt; &lt;li class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be667d15fe33922bf28f46b06ba5ee86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04b44b40483e8dce9af1ccbd6b55e9e2/" rel="bookmark">
			ROS2安装时出现Connection failed [IP: 91.189.91.39 80]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ROS2安装出错：Connection failed [IP: 91.189.91.39 80] 虚拟机ROS2安装过程出现以下报错：解决方法1、分析问题，根据提示尝试自己解决2、解决不了，检查是不是网络问题3、修改DNS地址或者修改软件源3.1 修改DNS地址3.2 修改软件源 虚拟机ROS2安装过程出现以下报错： E: Failed to fetch http://cn.archive.ubuntu.com/ubuntu/pool/universe/f/freeglut/freeglut3_2.8.1-6_amd64.deb Connection failed [IP: 91.189.91.39 80]
E: Failed to fetch http://cn.archive.ubuntu.com/ubuntu/pool/universe/f/flann/libflann1.9_1.9.1%2bdfsg-11_amd64.deb Connection failed [IP: 91.189.91.39 80] E: Failed to fetch http://cn.archive.ubuntu.com/ubuntu/pool/universe/f/flann/libflann-dev_1.9.1%2bdfsg-11_amd64.deb Connection failed [IP: 91.189.91.38 80]
E: Failed to fetch http://cn.archive.ubuntu.com/ubuntu/pool/universe/f/fmtlib/libfmt8_8.1.1%2bds1-2_amd64.deb Connection failed [IP: 91.189.91.39 80]
E: Failed to fetch http://cn.archive.ubuntu.com/ubuntu/pool/universe/f/fyba/libfyba0_4.1.1-7_amd64.deb Connection failed [IP: 91.189.91.38 80]
E: Failed to fetch http://cn.archive.ubuntu.com/ubuntu/pool/universe/f/fyba/libfyba-dev_4.1.1-7_amd64.deb Connection failed [IP: 91.189.91.39 80]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04b44b40483e8dce9af1ccbd6b55e9e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e72111ea4353cd1a366b3208a8d8b2d/" rel="bookmark">
			跳转WIFI页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跳转到设置中的WIFI页面——
public class TurnWifi extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Intent intent = new Intent(); intent.setAction("android.net.wifi.PICK_WIFI_NETWORK"); startActivity(intent); finish(); } } 通过自己的应用强制杀掉“设置应用”（需要系统签名）——
public class KillSettings extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); stopAppByKill(this, "com.android.settings"); finish(); } public void stopAppByKill(Context context , String packageName) { ActivityManager mActivityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); Method method = null; try { method = Class.forName("android.app.ActivityManager").getMethod("forceStopPackage", String.class); method.invoke(mActivityManager, packageName); } catch (Exception e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e72111ea4353cd1a366b3208a8d8b2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09692bc1a9fc0dd44e1ea4f7cdab62fb/" rel="bookmark">
			4ASK调制前后对比、Matlab误码率仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ASK是一种数字调制技术，全称为Amplitude Shift Keying（振幅键控）。在ASK中，数字数据通过改变调制信号的振幅来传输，通常使用正弦波载波。当数字数据为1时，调制信号的振幅会增加，当数字数据为0时，调制信号的振幅会减小或完全消失。在接收端，可以通过检测接收信号的振幅来解调数字数据。ASK是一种简单的数字调制技术，但由于它容易受到噪声的影响，因此在实际应用中通常需要结合其他技术来提高传输性能。
4ASK是ASK调制中的一种，也称为四进制振幅移位键控（Quadrature Amplitude Shift Keying，QASK）。与传统的ASK调制相比，4ASK可以在同样的带宽和功率限制下传输更多的信息。在4ASK中，数字数据通常被编码为两个比特，每个比特表示为两个相邻的脉冲的振幅变化。例如，数字00表示两个连续的低电平脉冲，数字01表示一个低电平脉冲和一个高电平脉冲，数字10表示一个高电平脉冲和一个低电平脉冲，数字11表示两个连续的高电平脉冲。在接收端，可以使用相应的解调器将这些振幅变化转换回数字数据。
如图，调制符号为四元输入，调制后的波形有四种，仅幅度上存在不同
如下图所示，调制后的波形其频谱是一单一脉冲，因为调制改变的是波形幅度，频率并没有改变。
误码率仿真结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a479ab2ef8a2f273bde1ba9155d485b3/" rel="bookmark">
			运维 —— expdp、impdp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、exp/imp与expdp/impdp 1）exp和imp是客户端工具程序,它们既可以在可以客户端使用,也可以在服务端使用。
2）expdp和impdp是服务端的工具程序,他们只能在ORACLE服务端使用, 不能在客户端使用。
3）字符集的问题到expdp/impdp数据泵已经消除，因为expdp/impdp真正的导出导入操作都是在数据库服务器上完成的。
4）expdp/impdp工具需要提前创建一个路径，然后命令中加入参数directory。这个路径的创建原因是因为expdp/impdp是工作于服务器端，而这个路径就是对应的服务器端路径。
5）exp默认是传统路径，这种模式下，是用select来查询数据，然后写入buffer cache，在将这些数据写入evaluate buffer，最后传到export客户端，再写入dump文件。 exp直接路径模式下，直接从硬盘读取数据，然后写入PGA，格式就是export的格式，不需要转换，数据再直接传到export客户端，写入dump文件。这种模式没有经过evaluation buffer，少了一个过程，导出速度提高也是很明显。
exp没有并行参数，要进行并行导出，可以写多条命令同时导出，这种方式可用于特定的数据迁移情况，按表或表空间进行快速数据迁移。 expdp是Oracle 10g上推出的一种先进的数据导出方式，比exp有较大的性能提升，expdp可以看成是exp的升级版，相当于exp + direct mode + parallel。
二、操作 1、创建目录和引用目录 sys@ORCL&gt; create or replace directory dmpdir as '/home/oracle'; Directory created. sys@ORCL&gt; col OWNER for a10 sys@ORCL&gt; col DIRECTORY_NAME for a30 sys@ORCL&gt; col DIRECTORY_PATH for a50 sys@ORCL&gt; select * from dba_directories where directory_name = 'DMPDIR'; 2、常规导入导出 共有参数为：目录，dump文件名，log文件名，含义明显，不再讲解，如：directory=DUMP_DIR dumpfile=abc.dmp logfile=abc.log
以下用...代替表示，如
expdp scott/tiger@db10g ...
impdp scott/tiger@db10g ...
1）按数据表 expdp scott/tiger@db10g tables=EMP,DEPT .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a479ab2ef8a2f273bde1ba9155d485b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3e473467bb7459af5ce583623549d75/" rel="bookmark">
			Java 抽象类、普通类、接口的区别——值得你一看的干货
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概念
一、抽象类与普通类
二、抽象类与接口
三、小结
概念 抽象类和具体类是相对的概念。“抽象”是一种存在思想逻辑中的概念，而“具体”是一种可见可触摸的现实对象。简单说，比如“人”比“男人”抽象一点，“动物”又比“人”更抽象一点，而“生物”又比“动物”更抽象。 抽象的概念是由具体概念依其“共性”而产生的，把具体概念的诸多个性排出，集中描述其共性，就会产生一个抽象性的概念。抽象思维，是人类思维达到高级阶段产生的一种能力，例如，当小孩子思维尚未成熟时，他们只能掌握具体概念，他们在学习代词“你、我、他”时往往遇到困难，因为代词具有较高的抽象性。
总之，抽象概念的外延大，内涵小；具体概念的外延小，内涵大。
一、抽象类与普通类 （1）普通类可以去实例化调用；抽象类不能被实例化，因为它是存在于一种概念而不非具体。
（2）普通类和抽象类都可以被继承，但是抽象类被继承后子类必须重写继承的方法，除非自类也是抽象类。
（3）实例演示：
public class Pet { public void play(){ //这是宠物类,普通父类，方法里是空的 } } -------------------------- public class Cat extends Pet { //这是子类，是一个猫类,重写了父类方法 public void play(){ System.out.println("1、猫爬树"); } } ------------------------ public class Dog extends Pet { //这是子类，是一个狗类,重写了父类方法 public void play(){ System.out.println("2、狗啃骨头"); } } ------------------------- public class Test { public static void main(String[] args) { //这是测试类，分别调用了子类的不同方法 Pet p1=new Cat(); //多典型的多态表现啊，相当的给力 Pet p2=new Dog(); p1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3e473467bb7459af5ce583623549d75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/804749796a5c12eac47a40e9aef21f4b/" rel="bookmark">
			R语言数据可视化教程（ggplot2）_坐标轴设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 8.坐标轴
# 8.1交换x轴和y轴
# 使用coord_flip()来翻转坐标轴
library(ggplot2)
ggplot(PlantGrowth,aes(x=group,y=weight))+geom_boxplot()
ggplot(PlantGrowth,aes(x=group,y=weight))+geom_boxplot()+coord_flip()
# 如果x变量是一个因子型变量，则排列顺序可以通过使用scale_x_discrete()和参数limits=rev(levels(...))进行反转
ggplot(PlantGrowth,aes(x=group,y=weight))+geom_boxplot()+coord_flip()+scale_x_discrete(limits=rev(levels(PlantGrowth$group)))
# 8.2设置连续型坐标轴的值域
# 可以使用xlim()和ylim()来设置一条连续型坐标轴的最小值和最大值
p &lt;- ggplot(PlantGrowth,aes(x=group,y=weight))+geom_boxplot()
# 显示图形
p
p +ylim(0,max(PlantGrowth$weight))
# 使用ylim()来设定范围是通过scale_y_continuous()来设定范围的简便写法（对于xlim()和scale_x_continuous()同理）
# 以下两种表达方式等价：
ylim(0,10)
scale_y_continuous(limits = c(0,10))
# 有时需要设定scale_y_continuous()的其他属性，在这些情况下同时使用ylim()和scale_y_continuous()可能会让程序产生一些不可预知的行为，这是因为只有命令中的后一条会生效
# 示例如下，仅有第二条命令生效
p+ylim(0,10)+scale_y_continuous(breaks = c(0,5,10)) # 将刻度线放在0,5,10的位置
p+scale_y_continuous(breaks = c(0,5,10))+ylim(0,10)
# 要让两项修改均生效，舍弃ylim()并直接在scale_y_continuous()中同时设定limits和breaks即可
p+scale_y_continuous(limits = c(0,10),breaks = c(0,5,10))
# ggplot2中有两种设置坐标轴值域的方式，第一种方式是修改标度，第二种方式是应用一个坐标变换。
# 当你修改x标度和y标度的范围时，任何在范围以外的数据都会被移除
# 通过使用坐标变换，数据则不会被修剪；从本质上说，它只是将数据放大或缩小到指定的范围
p+scale_y_continuous(limits = c(5,6.5)) # 与使用ylim()相同
p+coord_cartesian(ylim = c(5,6.5))
# 最后，通过使用expand_limits()来单向扩展值域也是可以的，但是不能使用它来缩减值域
p+expand_limits(y=0)
# 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/804749796a5c12eac47a40e9aef21f4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a802b019ea773ae563dcb3d02b46ad5/" rel="bookmark">
			两个交换机vlan间通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、配置各PC机的地址
2、创建VLAN和分配端口
第一步：创建vlan10，并命名。
Switch(config)#vlan 10
Switch(config-vlan)#name test10
Switch(config-vlan)#exit
第二步：创建vlan20，并命名。
Switch(config)#vlan 20
Switch(config-vlan)#name test20
Switch(config-vlan)#exit
第三步：分配端口到vlan10
Switch(config)#int range f0/1-10
Switch(config-if-range)#switch mode access
Switch(config-if-range)#switch access vlan 10
Switch(config-if-range)#exit
第四步：分配端口到vlan20
Switch(config)#int range f0/11-20
Switch(config-if-range)#switch mode access
Switch(config-if-range)#switch access vlan 20
Switch(config-if-range)#exit
第五步：查看vlan配置情况。
第六步：配置级联端口为trunk模式
Switch(config)#int f0/24
Switch(config-if)#switchport mode trunk
Switch(config-if)#end
第七步：在第二台交换机上做相同配置。
3、测试
在Packer tracer中单击“PC0”，在弹出的窗口中单击“Desktop”选项卡下的“run”，输入ping 192.168.1.13和ping 192.168.1.21,测试结果如下图所示，其中PC0和PC5在同一VLAN内，能够ping通；PC0和PC2不在同一VLAN内，所以不能ping通。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ae83f802644b67dd789bb83c727407f/" rel="bookmark">
			go clean -modcache 把$GOPATH/pkg/mod 目录文件清空了如何恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景 scm编辑代码不通过（其实是因为go镜像低于本地go版本导致），oncall 同学抛过来一条命令go clean -modcache &amp;&amp; go mod tidy，我对go clean -modcache 是不太清楚真正含义的，以为就是清空下项目的依赖包而已（后来才知道oncall同学也没有对其正确认知），于是就很信任的复制粘贴，按下回车键，然后瞬间慌了，同时Goland打开的三个项目窗口都闪了一下然后代码都不见了，很慌，因为还有未提交的代码，啥都不说了，开始找恢复的方法吧
go clean -modcache做了什么 会清空$GOPATH/pkg/mod 下的文件，只保留目录结构
由于历史原因我的个人代码放到了此目录下（其实应该放到$GOPATH/src 下），所以我也有责任，论规范的重要性
代码恢复 了解到代码编辑器一般都会自带缓存，goland也有，按左键弹出如下框，点击Show History 查看缓存的历史版本
选择一个操作删除命令时间之前的版本，17点41删除的，那就选择16点52的版本，然后点击revert按钮（左上角），至此就恢复了
反思 对不熟悉的命令或者配置再没有彻底搞清楚原理之前不要操作应用，永远对线上怀着敬畏之心对于未经过充分测试验证的变更，一定要做好备份对于别人的建议和方法要保持辩证的态度，不可全信，实践出真理 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fd0597a19fb7e5e401345adcf2af989/" rel="bookmark">
			一、MongoDB安装与基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB安装与基本操作 1、linux安装MongoDB2、MongoDB-连接3、Mongo shell使用mongo shell常用命令 4、安全认证5、MongoDB工具 1、linux安装MongoDB 环境准备：
linux系统： centos7安装MongoDB社区版 下载MongoDB Community Server
MongoDB社区版下载地址
下载MongoDB wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.4.19.tgz tar -zxvf mongodb-linux-x86_64-rhel70-4.4.19.tgz 启动MongoDB Server
#创建dbpath和logpath
mkdir -p /mongodb/data /mongodb/log #进入mongodb目录，启动mongodb服务 bin/mongod --port=27017 --dbpath=/mongodb/data --logpath=/mongodb/log/mongodb.log \ --bind_ip=0.0.0.0 --fork –dbpath :指定数据文件存放目录
–logpath :指定日志文件，注意是指定文件不是目录
–logappend :使用追加的方式记录日志
–port:指定端口，默认为27017
–bind_ip:默认只监听localhost网卡
–fork: 后台启动
–auth: 开启认证模式
添加环境变量
#修改/etc/profile，添加环境变量,方便执行MongoDB命令 export MONGODB_HOME=/usr/local/soft/mongodb PATH=$PATH:$MONGODB_HOME/bin #重新加载环境变量 source /etc/profile 利用配置文件启动服务
编辑MONGODB_HOME/conf/mongo.conf文件
systemLog: destination: file path: /mongodb/log/mongod.log # log path logAppend: true storage: dbPath: /mongodb/data # data directory engine: wiredTiger #存储引擎 journal: #是否启用journal日志 enabled: true net: bindIp: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fd0597a19fb7e5e401345adcf2af989/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82ba30fb727bf54cabf7ef3c2fa09491/" rel="bookmark">
			redisTemplate 根据key前缀批量删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 根据key前缀批量删除 * * @param keyPrefix 键前缀字符串 * @return 结果 */ public boolean delByPrefix(String keyPrefix) { if (keyPrefix != null) { Set&lt;String&gt; keys = redisTemplate.keys(Pattern.matches("\\*$", keyPrefix) ? keyPrefix : keyPrefix + "*"); redisTemplate.delete(keys); return true; } return false; } 参考文章
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/426bf9ce15eae2d49fe8389773d49bb9/" rel="bookmark">
			写给go开发者的gRPC教程-metadata
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语
和在普通HTTP请求中一样，gRPC提供了在每一次RPC中携带上下文的结构：metadata。在Go语言中，它与context.Context紧密结合，帮助我们实现服务端与客户端之间互相传递信息
什么是 metadata？ gRPC 的 metadata 简单理解，就是 HTTP Header 中的 key-value 对
metadata 是以 key-value 的形式存储数据的，其中 key 是 string 类型，而 value 是 []string，即一个字符串数组类型
metadata 使得 client 和 server 能够为对方提供关于本次调用的一些信息，就像一次HTTP请求的Request Header和Response Header一样
HTTP Header 的生命周期是一次 HTTP 请求，那么 metadata 的生命周期就是一次 RPC 调用
metadata 创建 🌲 使用New()： md := metadata.New(map[string]string{"key1":"value1","key2":"value2"}) 🌲 使用Pairs()： 要注意如果有相同的 key 会自动合并
md := metadata.Pairs( "key1", "value1", "key1", "value1.2", // "key1" will have map value []string{"value1", "value1.2"} "key2", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/426bf9ce15eae2d49fe8389773d49bb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9321ccf91a8b75a3185ecab8e8d5622d/" rel="bookmark">
			机器学习与目标检测作业：连通块算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习与目标检测作业：连通块算法 一、连通块算法题目描述二、连通块算法文件结构三、连通块算法程序编写3.1、连通块算法conBlock.h头文件内容3.2、conBlock.cpp源文件内容3.3.3、mian.h头文件内容3.3.4、main.cpp源文件内容如下 四、连通块算法程序运行结果 一、连通块算法题目描述 连通块算法题目描述描述如下所示
S1:任选一-同色棋子作为初始种子点，S2:沿水平和垂直方向连接同色相邻棋子，得到边缘子集合S3:后者再向外扩展反复迭代，直到再没有同色相邻的棋子。得到第一个连通块。在剩下的同色棋子中任选-一个种子点，继续扩展，直到遍历所有同色棋子为止。得到所有连通块以后，再计算其相邻不重复的空位个数，得到该块的气数。 二、连通块算法文件结构 连通块算法文件结构如下所示
程序编写的头文件与源文件如下 三、连通块算法程序编写 3.1、连通块算法conBlock.h头文件内容 连通块算法conBlock.h头文件内容如下所示
#ifndef CONBLOCK_H #define CONBLOCK_H #include "mian.h" class Board { private: int goValue[line][column]; int countBlock = 0; public: void createData(); void outputData(); void DFS(int, int); void calcBlock(); }; #endif 3.2、conBlock.cpp源文件内容 conBlock.cpp源文件内容如下所示
#include "conBlock.h" void Board::createData() { srand(time(NULL)); for (int i = 0; i &lt; line; i++) { for (int j = 0; j &lt; column; j++) { goValue[i][j] = rand() % 2; } } } void Board::outputData() { for (int i = 0; i &lt; line; i++) { for (int j = 0; j &lt; column; j++) { cout &lt;&lt; goValue[i][j] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9321ccf91a8b75a3185ecab8e8d5622d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b9868df3193ed778f2f6409e60cabaf/" rel="bookmark">
			elasticsearch-浏览器地址栏-小命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查询基本结构(占用量等等) http://***:9200/_cat/indices?v 获取es集群服务健康状态 http://***:9200/_cat/health?v 查看es节点信息 http://***:9200/_cat/nodes?v 查看es指定节点信息 http://***:9200/_nodes/nodeName?pretty=true 查询全局的索引及结构 http://***:9200/_all 查询指定索引的结构 http://***:9200/索引/_mapping?pretty 先这样 ES 常用查询命令汇总,到时候在汇总下这些. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e646770bc34fd4b07a15bca66bbe0ee/" rel="bookmark">
			Android 12 Wifi 开发（获取列表、连接、断开连接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取Wifi列表：
扫描（这个方法早在Android 9.0 就被弃用），不过如果不调用的话是没法及时获取Wifi列表的广播的。（不需要也能正常获取，没有延迟，经实验毫无区别）
public static void searchWifiList(WifiManager manager) { manager.startScan(); } 创建广播并接收：
/** * 获取附近的WiFi列表 * * @param manager WifiManager * @param flag 是否保留重名但BSSID不同的wifi true保留，false不保留 * @return wifi列表 */ public static List&lt;ScanResult&gt; scanResults(WifiManager manager, boolean flag) { List&lt;ScanResult&gt; scanResults = new ArrayList&lt;&gt;(); HashSet&lt;String&gt; hs = new HashSet&lt;&gt;(); Log.d("WifiUtils", "scanResults: " + manager.getScanResults().size()); if (flag) { scanResults = manager.getScanResults(); return scanResults; } for (ScanResult scanResult : manager.getScanResults()) { if (hs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e646770bc34fd4b07a15bca66bbe0ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bd18a0a03d6212b289873ac1af1a96b/" rel="bookmark">
			Java Stream 如何提高遍历集合效率？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 什么是 Stream？Stream 如何优化遍历？ Stream 源码实现内部实现Stream 并行处理 什么是 Stream？ Stream 的聚合操作与数据库 SQL 的聚合操作 sorted、filter、map 等类似。我们在应用层就可以高效地实现类似数据库 SQL 的聚合操作了，而在数据操作方面，Stream 不仅可以通过串行的方式实现数据操作，还可以通过并行的方式处理大批量数据，提高数据的处理效率。
一个简单的例子来体验下 Stream 的简洁与强大。
这个 Demo 的需求是过滤分组一所中学里身高在 160cm 以上的男女同学，我们先用传统的迭代方式来实现，代码如下：
Map&lt;String, List&lt;Student&gt;&gt; stuMap = new HashMap&lt;String, List&lt;Student&gt;&gt;(); for (Student stu: studentsList) { if (stu.getHeight() &gt; 160) { //如果身高大于160 if (stuMap.get(stu.getSex()) == null) { //该性别还没分类 List&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); //新建该性别学生的列表 list.add(stu);//将学生放进去列表 stuMap.put(stu.getSex(), list);//将列表放到map中 } else { //该性别分类已存在 stuMap.get(stu.getSex()).add(stu);//该性别分类已存在，则直接放进去即可 } } } Map&lt;String, List&lt;Student&gt;&gt; stuMap = stuList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bd18a0a03d6212b289873ac1af1a96b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3ad90ee61fce41021d7b97f1a37a6d4/" rel="bookmark">
			Spring Controller 基本认识及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：本文是以前初学时期的笔记上传，如有错误，还望指出，一定改正，谢谢支持！有兴趣也可以关注我的博客：yumuing 博客
Controller 相关介绍 Controller 在 spring 中代表的是控制层，是将访问者请求进行分发调用不同函数，来控制获取请求参数以及返回业务层处理完的数据给访问者的层面。它在 spring 中必须在 Controller 类前添加 @Controller 注解，以注入容器中，并发挥作用。
在 Controller 中存在两种传递参数的方式，第一种是采用路径后添加 ? 参数的方式，第二种则是采用参数直接写入路径的方式，如下：
第一种：yumuing/params?username=yumuing&amp;password=1234
第二种：yumuing/user/{userId}
在 Get 请求中，获取第一种参数的方式，主要是利用 @RequestParam 这个注解得到同名的参数，获取第二种参数的方式则是采用 @PathVariable 这个注解获取 @RequestMapping 中的大括号标记的同名参数，其中，@RequestParam 和 @PathVariable 都是作为方法参数书写的，必须注明参数类型（如 String ），@RequestMapping 则是方法整体注解，在添加新参数时，路径得使用 path 进行指定，而不是一个简单的字符串书写即可，来如下：
//第一种 @RequestMappingpath="/params",method=RequestMethod.GETpath = {"/params"},method = {RequestMethod.GET}path="/params",method=RequestMethod.GET public void params@RequestParam(name="username",required=false,defaultValue="test"@RequestParam(name = "username", required = false,defaultValue = "test"@RequestParam(name="username",required=false,defaultValue="test"String username); //第二种 @RequestMappingpath="/user/userId",method=RequestMethod.GETpath = "/user/{userId}",method = {RequestMethod.GET}path="/user/userId",method=RequestMethod.GET public void params@PathVariable("userId"@PathVariable("userId"@PathVariable("userId" int userId); 当然，@RequestMapping 的参数还有很多，但必须注意的一点是尽可能使用 大括号（即 {}，会更加直观，也防止部分一定要求需要大括号的参数出错，并且这个注解既可以一个函数，也可以注解一个类。当注解一个类时，类中所有的方法都会在这个基础上再进行过滤，参数类型基本包括如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3ad90ee61fce41021d7b97f1a37a6d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29551c273fd130bd1d91600d70bcc785/" rel="bookmark">
			JS实现签发jwttoken,以及解析token获取值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载crypto-js yarn add crypto-js 2、实现代码 import { enc, HmacSHA256 } from 'crypto-js' const base64UrlEncode = (str) =&gt; { return enc.Base64.stringify(str).replace(/=+$/, '').replace(/\+/g, '-').replace(/\//g, '_') } export default { // 根据实际情况修改替换key encrypt (payload, key = '123') { const iat = new Date().getTime() payload = JSON.stringify({ ...payload, iat, // 签发时间 exp: iat + 1 * 60 * 60 * 1000 // 过期时间1小时 }) const header = JSON.stringify({ alg: 'HS256', typ: 'JWT' }) const beforeSign = base64UrlEncode(enc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29551c273fd130bd1d91600d70bcc785/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dcc6555d832639b0bd8afb940cd6186/" rel="bookmark">
			【论文-目标检测】RTMDet: An Empirical Study of Designing Real-Time Object Detectors
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文 代码 官方原理与实现详解
发展YOLO系列并方便支持实例分割和斜框检测等任务，亮点：
设计兼容性backbone和neck，采用大核深度可分离卷积；动态标签分配中采用软标签计算匹配损失；结合训练达到实时检测、实时实例分割和斜框检测SOTA。 2. 相关工作 高效的目标检测神经架构。为了提高模型效率，采用人工设计或神经架构搜索的方式主要研究高效骨干网络、模型放缩策略和多尺度特征增强三方面。最近的工作也探索了使用模型重新参数化来提高推理速度。本研究进行了骨干与neck兼容的整体架构设计，采用基于大核深度卷积构建的模块提升检测器效率。
目标检测标签分配。之前的方法在标签分配中主要采用IoU作为匹配标准来比较真值框与模型预测框或锚框。后续的工作进一步研究了更多的匹配标准，例如目标中心。辅助检测头也被研究来加速和稳定训练。受端到端目标检测匈牙利分配的启发，动态标签分配的研究显著提升了收敛速度和模型精度。不同于这些策略中使用的匹配代价函数与损失一样，本研究提出使用软标签来计算匹配代价函数，增大高质量和低质量匹配之间的差异，从而使训练更稳定并加速收敛。
实例分割。之前的方法研究了多种范式，包括mask classification、Top-Down、Bottom-Up等。最近一些工作尝试有或无边界框的一阶段实例分割。这些方法的一种代表是基于动态核，学习获取学习参数和密集特征图的动态核，并用来与掩膜特征图进行卷积。受此启发，本文通过kernel prediction和mask feature heads扩展RTMDet来进行实例分割。
旋转目标检测。斜框目标检测除了预测目标的位置和类别之外，还预测方向。基于通用目标检测器（RetinaNet或Faster R-CNN）发展起不同的特征提取网络解决旋转产生的特征不匹配问题。也有多种旋转框表达的研究（高斯分布、凸集）来简化旋转边界框回归任务。不同于这些方法，本文对通用目标检测器做了最小化的改动 （添加角度预测分支，替换GIoU为Rotated IoU损失），揭示了通过模型结构和通用检测数据集预训练可以使高精度通用目标检测器变成高精度旋转目标检测器。
3. 方法 RTMDet是典型的一阶段目标检测器。文章对模型高效的改进是通过采用大核卷积构建基础模块，以及平衡模型深度、宽度和分辨率。进一步探究了使用软标签的动态标签分配策略、更好的数据增强和优化策略组合来提升模型精度。RTMDet框架扩展性良好，可以通过很少的修改支持实例分割和旋转框检测。
3.1 主要架构 架构是一阶段检测器，包括backbone、neck和head。最近的YOLO系列大都采用CSPDarkNet作为backbone架构，包含4个阶段，每个阶段包含多个基础模块。neck利用backbone的多尺度特征，并采用和backbone相同的基础块进行bottom-up和top-down的特征传播来增强金字塔特征图。最后，检测头基于不同尺度的特征图预测目标框和类别。通过核和掩膜特征获取头，模型可以扩展支持实例分割。
3.2 模型架构 基础模块。骨干网络中大而有效的感受野对密集预测任务（检测、分割）非常有益，因为其能更加全面的捕获和建模图像语义。然而，之前的工作（例如空洞卷积和non-local模块）计算昂贵，限制了其在实时目标检测中的应用。最近的研究重新讨论了大核卷积，发现可以通过depth-wise卷积在合理计算代价下增大感受野。受此启发，本研究在CSPDarkNet中引入5*5 depth-wise卷积（Fig.3b）来增加有效感受野。其能进行更全面的语境建模并显著提升精度。
值得注意的是，最近的一些实时目标检测器研究了重新参数化的3*3卷积（Fig.3c&amp;d）。尽管其能在推理时有效提升精度，但也有副作用，例如降低了训练速度增加了训练存储。其同样增加了模型量化到低bit时的误差，需要通过重新参数化优化器和量化感知训练进行补偿。相比之下，大核卷积是更加简单有效的选择。
模型宽度与深度的平衡。由于在大核卷积后增加了1*1点卷积（Fig.3b），基础模块的层数也随之增加。这阻碍了每层的并行计算导致降低了推理速度。为了解决这个问题，本研究减少了每个骨干网络阶段的模块数并适度的增加模块的宽度来提升并行化与模型能力，最终在不牺牲精度的情况下提升了推理速度。
backbone与neck的平衡。为了增强多尺度特征，之前的工作要么使用更大的backbone要么使用更重（更多的特征金字塔连接和融合）的neck。然而，其同样增加了计算量和内存。因此，本研究采用另一种策略，通过增加neck中基础模块的膨胀率使其具有相似的能力，实现了更好的计算-精度平衡，将更多的参数和计算从backbone放到neck。
共享检测头。实时目标检测器大都采用不同特征尺度分离的检测头来增强模型性能，而不是跨尺度的共享检测头。本研究比较了不同的方案并选择跨尺度共享参数但采用不同BN层的检测头来减少检测头的参数量同时保持精度。同时，BN相比其它的归一化方法（例如Group Normalization）更加高效，因为在推理时直接使用训练中的统计。
3.3 训练策略 标签分配和损失。为了训练一阶段检测器，需要通过不同的标签分配策略将每个尺度的密集预测与真值框进行匹配。最近的工作采用动态标签分配策略，其采用与训练损失一致的代价函数作为匹配标准。然而，我们发现这种代价计算存在局限。因此，我们提出了一种基于SimOTA的动态软标签分配策略，其代价函数表达为：
其中Ccls、Ccenter、Creg分别为分类代价、区域先验代价和回归代价。三个参数 权重分别为1,3,1。
之前的方法通常采用二值标签来计算分类代价，会使具有高分类得分但错误边界框的预测得到低的分类代价，反之亦然。为了解决这个问题，在Ccls中引入软标签：
这个修改是受GFL(Generalized Focal Loss) 启发，其采用预测框与真值框的IoU作为软标签来训练分类分支。这种分配中的软分类代价不仅重新给了不同回归质量不同的匹配代价，也避免了由于二值标签导致的噪声或不稳定匹配。
采用Generalized IoI作为回归代价时，最大最小匹配的差异小于1。这使得难于区分高质量与低质量匹配。为了使不同真值-预测对的匹配质量更加差异化，研究采用IoU的对数作为回归代价，而不是损失函数中采用的GIoU，其放大了低IoU值匹配的代价。回归代价Creg表达为：
区域代价Ccenter采用软中心区域代价替代固定中心先验来使动态代价匹配更稳定
超参数alpha, beta设置为10和3。
缓存Mosaic和Mixup。诸如Mixup和CutMix这种跨样本增强在新近的目标检测器中广泛应用。这些增强很有效，但同时也带来了两个副作用。一是在每次迭代时都需要加载多幅图像来生成训练图像，引入了更多的数据加载代价减缓了训练。二是生产的训练样本是噪音，可能不属于数据集的真实分布，影响模型学习。
本研究利用缓存机制提升MixUp和Mosaic减少其对数据加载的消耗。通过使用缓存机制，混合图像的耗时可以接近单图处理水平。缓存操作通过缓存长度和popping方法控制。大的缓存长度和随机popping方法基本等效于原始的非缓存操作。同时，小缓存长度和First-In-First-Out(FIFO)popping可以被认为近似于重复增强，即在相同或连续的batch中使用不同的数据增强操作混合相同的图像。
两阶段训练。为了减少强数据增强产生的“噪声”样本的副作用，YOLOX采用了一种两阶段训练策略，第一阶段使用强数据增强，包括Mosaic、MixUp和随机旋转裁切，第二阶段使用弱数据增强，例如随机重采样和翻转。由于初始化训练阶段的随机旋转剪切等强增强导致输入和变换后的标注不匹配，YOLOX在第二阶段调优回归分支添加了L1损失。为了解耦数据增强和损失函数，研究在第一阶段280轮的训练排除了这些数据增强，通过增加每个训练样本的混合图像数量到8来补偿增强的强度。在最后的20轮，换做Large Scale Jittering（LSJ），使得模型能在更加接近真实数据分布域上进行微调。为了进一步使训练更加稳定，研究采用AdamW作为优化器，其很少用在卷积目标检测器中，但默认用于视觉transformer。
3.4 扩展到其他任务 实例分割。研究使用简单修改扩展RTMDet支持实例分割，称为RTMDet-Ins。如图4所示，基于RTMDet增加额外分支，包括核预测头和掩膜特征头，类似于CondInst。掩膜特征头包括4个卷积层，从多层特征中提取8通道掩膜特征。核预测头对每个实例预测一个169维矢量，其分解成3个动态卷积核通过与掩膜特征和坐标特征交互来生成实例分割掩膜。为了进一步利用掩膜标注里的先验信息，研究利用掩膜质心代替框中心计算动态标签分配中的软区域先验。研究采用dice损失作为实例掩膜的监督。
旋转目标检测。根据旋转目标检测回头通用（正框）目标检测的相似性，仅需3步能将RTMDet扩展到旋转目标检测器，即RTMDet-R。（1）添加1*1卷积作为旋转角度的预测分支；（2）更新正框代码支持旋转框；（3）替换GIoU为损失为旋转IoU损失。模型结构高度优化的RTMDet保证了RTMDet-R在旋转目标检测任务的高性能。同时，RTMDet-R与RTMDet共享了尽量多的参数，也保证了RTMDet在通用检测数据集（COCO）的预训练可以作为旋转目标检测的良好初始化。
4. 实验 4.1 实现细节 目标检测和实例分割。COCO数据集，检测与实例分割分别使用box AP和mask AP。score 0.001，保留top 300框进行验证。但为了加速效率，在消融实验中使用score 0.05，top 100。降低0.3%AP。
旋转目标检测。DOTA数据集。单尺度训练测试，1024尺寸256重叠。多尺度，重采样到0.5、1.0、1.5，裁剪到1024，重叠500。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dcc6555d832639b0bd8afb940cd6186/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e552056d00924874a6253a077e00bed/" rel="bookmark">
			Linux安装 hadoop-3.3.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 下载安装包 wget --no-check-certificate https://mirrors.bfsu.edu.cn/apache/hadoop/common/hadoop-3.3.1/hadoop-3.3.1.tar.gz 2 解压 tar -zxvf hadoop-3.3.1.tar.gz 3 修改 hadoop-env.sh配置文件 vim /hadoop-3.3.1/etc/hadoop/hadoop-env.sh export JAVA_HOME=/data/jdk1.8.0_141 4 修改core-site.xml vi /hadoop-3.3.1/etc/hadoop/core-site.xml &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://10.52.0.107:9000/&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/APP/hadoop&lt;/value&gt; &lt;/property&gt; 4 修改 hdfs-site.xml 配置文件 `
&lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;!--分块大小--&gt; &lt;property&gt; &lt;name&gt;dfs.blocksize&lt;/name&gt; &lt;value&gt;698351616&lt;/value&gt; &lt;/property&gt; &lt;!--NameNode存储目录，没有则新建--&gt; &lt;property&gt; &lt;name&gt;dfs.name.dir&lt;/name&gt; &lt;value&gt;/APP/hdfs/name&lt;/value&gt; &lt;/property&gt; &lt;!--DateNode存储目录，没有则新建--&gt; &lt;property&gt; &lt;name&gt;dfs.data.dir&lt;/name&gt; &lt;value&gt;/APP/hdfs/data&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.secondary.http.address&lt;/name&gt; &lt;value&gt;0.0.0.0:6002&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.address&lt;/name&gt; &lt;value&gt;0.0.0.0:9686&lt;/value&gt; &lt;/property&gt; 5 初始化namedata 进入安装目录
/hadoop-3.3.1/bin
./hdfs namenode -format 6 start-dfs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e552056d00924874a6253a077e00bed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5869f02449197c065c516ed6d778f0c/" rel="bookmark">
			python汇率兑换程序。按照温度转换程序的设计思路，按照1美元=6人民币汇率编写一个美元和人民币的双向兑换程序。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、问题？二、使用步骤代码 总结 前言 python汇率兑换程序。按照温度转换程序的设计思路，按照1美元=6人民币汇率编写一个美元和人民币的双向兑换程序。
一、问题？ python汇率兑换程序。按照温度转换程序的设计思路，按照1美元=6人民币汇率编写一个美元和人民币的双向兑换程序。
二、使用步骤 代码 a = input('输入金额:') if '美元' in a: b = a.replace('美元', '') print('{0:}人民币'.format(int(b) * 6)) elif '人民币' in a: b = a.replace('人民币', '') print('{0:.2f}美元'.format(int(b) / 6.0)) else: print('输入格式错误') 总结 首先是input()输入字符串下面通过if-else来判断用户输入的是人民币还是美元接着去除单位，保留字符串数字，将字符串数字变为整形最后进行对应的换算输出 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d34c6c132f047fc1c44ae62619766adb/" rel="bookmark">
			Linux学习笔记：文件管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建 创建文件 使用touch命令来新建一个空文件。同时，touch命令还会更新文件的访问时间和修改时间。
创建目录 要创建新目录。可以使用mkdir命令：
如果要逐路径依次创建新目录，可以使用mkdir -p 命令，如：
mkdir -p /test1/test2/test3 这条命令可以直接依次新建三个目录
复制 复制文件 使用cp命令来复制文件
cp test_1 test_2 若test_2已存在，cp 命令会直接覆盖文件
在CentOS7中，输入 cp 命令默认为 cp -i ，会给予覆盖提醒，可通过alias查看：
批量复制文件：
cp file1 file2 file.. to_file 如：
可以将test_1和test_2复制到testDir内
复制目录 与复制文件类型，目录也可以通过 cp 命令来复制
cp testDir testDir1 但是当目录非空时，会出现提示“略过目录”
这时需要通过 cp -r 命令来复制整个目录和目录下的所有文件
移动 移动文件 使用 mv 命令来移动文件
mv testfile testDir/ mv 命令还可以为文件重命名
mv testfile rename_testfile 与 cp 命令类似，在CentOS7中 mv 命令为 mv -i ；若欲重命名的文件已存在，则会提醒“是否覆盖文件”
批量移动操作命令与 cp 命令类似，不多做诠释
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d34c6c132f047fc1c44ae62619766adb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90ef048cb9bd354f49f5c56d1d2aa07c/" rel="bookmark">
			SQL server下载 2023年3月7日最新教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：
一、官网下载sql server
二、下载SSMS
一、下载sql server
1.点击链接进行下载：SQL Server 下载 | Microsoft
选择路径下载即可
在相应的盘中找到exe应用程序，然后打开
然后选择中文简体，点击接受
选择安装位置，我这里是自己设定的，点击安装
等待安装完成
安装完成，点击自定义
点击下一步
不用管警告，直接下一步
不用选择适用于SQLServer的Azure，点击下一步
按红色箭头选择功能，然后下一步
点击默认实例，下一步
如果出现了如下图一样的错误，则点击命名实例，随便命一个名即可，然后下一步
点击混合模式，输入密码，确认密码，不要忘了添加当前用户，点击下一步
点击安装，然后等待安装完成，安装完成点击关闭即可
二、安装SSMS:
点击链接进入官网：下载 SQL Server Management Studio (SSMS) - SQL Server Management Studio (SSMS) | Microsoft Learn
选择路径，点击下载
进入下载的文件夹找到exe应用程序点开
打开之后选择下载的路径，点击安装即可，等待安装完成，关闭即可 三、
在电脑左下角点击搜索
点击应用找到sql server management studio，打开
服务器类型选择数据库引擎，服务器名称输入"."，点击连接
sql server下载到此完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/618153ffbf76284fe88baed40ebc05f8/" rel="bookmark">
			Flutter-渲染原理&amp;三棵树详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 渲染原理 WidgetTree:存放渲染内容、它只是一个配置数据结构，创建是非常轻量的，在页面刷新的过程中随时会重建
Element 是分离 WidgetTree 和真正的渲染对象的中间层， WidgetTree 用来描述对应的Element 属性,同时持有Widget和RenderObject，存放上下文信息，通过它来遍历视图树，支撑UI结构。
RenderObject (渲染树)用于应用界面的布局和绘制，负责真正的渲染，保存了元素的大小，布局等信息，实例化一个 RenderObject 是非常耗能的
当应用启动时 Flutter 会遍历并创建所有的 Widget 形成 Widget Tree，通过调用 Widget 上的 createElement() 方法创建每个 Element 对象，形成 Element Tree。最后调用 Element 的 createRenderObject() 方法创建每个渲染对象，形成一个 Render Tree。
那么，flutter为什么要设计成这样呢？为什么要弄成复杂的三层结构？
答案是性能优化。如果每一点细微的操作就去完全重绘一遍UI，将带来极大的性能开销。flutter的三棵树型模式设计可以有效地带来性能提升。
widget的重建开销非常小，所以可以随意的重建，因为它不一会导致页面重绘，并且它也不一定会常常变化。 而renderObject如果频繁创建和销毁成本就很高了，对性能的影响比较大，因此它会缓存所有页面元素，只是当这些元素有变化时才去重绘页面。
而判断页面有无变化就依靠element了，每次widget变化时element会比较前后两个widget，只有当某一个位置的Widget和新Widget不一致，才会重新创建Element和widget；其他时候则只会修改renderObject的配置而不会进行耗费性能的RenderObject的实例化工作了。
课题笔记
Widget的渲染原理
所有的Widget都会创建一个Element对象
并不是所有的Widget都会被独立渲染！只有继承RenderObjectWidget的才会创建RenderObject对象！（Container就不会创建RenderObject、column和padding这些可以创建RenderObject）
在Flutter渲染的流程中，有三颗重要的树！Flutter引擎是针对Render树进行渲染！
Widget树、Element树、Render树
每一个Widget都会创建一个Element对象
隐式调用createElement方法。Element加入Element树中，它会创建RenderElement、ComponentElement（又分为StatefulElement和StatelessElement）。
RenderElement主要是创建RenderObject对象， 继承RenderObjectWidget的Widget会创建RenderElement
创建RanderElementFlutter会调用mount方法，调用createRanderObject方法 StatefulElement继承ComponentElement，StatefulWidget会创建StatefulElement
调用createState方法，创建State将Widget赋值给state调用state的build方法 并且将自己（Element）传出去,build里面的context 就是Widget的Element ！ StatelessElement继承ComponentElement,StatelessWidget会创建StatelessElement
mount方法 -&gt; firstBuild -&gt; rebuild -&gt; performBuild -&gt; build -&gt; _widget.build-主要就是调用build方法 并且将自己（Element）传出去
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/618153ffbf76284fe88baed40ebc05f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad9fd55fc58662902df7a4e4e6ebdeba/" rel="bookmark">
			Android 几种设置ImageView的图片的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 几种设置ImageView的图片的方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e957c53e772f74bc4e2c32ac0a356704/" rel="bookmark">
			论文公式符号规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考自1，记录论文公式的符号规范：
§1.变量和公式符号表达 物理量 物理量符号用英文斜体字母或希腊斜体字母，表示物理量大小用数字加单位，单位使用正体。
例如：
m = 10.05 g x = 10.12 ζ = 35.36 m V m=10.05 \mathrm{~g} \quad x=10.12 \quad \zeta=35.36 \mathrm{mV} m=10.05 gx=10.12ζ=35.36mV
下标 下标一般表示注释、条件或编号。其中
英文单词的字头表示注释用正体字母。字母表示条件或编号代号用斜体字母。阿拉伯数字表示编号用正体。 例如：
c p . m c_{p.\mathrm{m}} cp.m​表示恒压摩尔热容，下标 p p p表示恒压条件，故用斜体；下标 m \mathrm{m} m表示摩尔量，是molar的字头，用正体。比热用斜体小写字母 c c c表示。
再例如：
c B i c_{\mathrm{B}i} cBi​表示某物质 B \mathrm{B} B的第 i i i个物质的量浓度。按国际化学会规定，物质的量浓度常用斜体小写英文字母 c c c表示，单位为 m o l ∘ L − 1 \mathrm{mol}\circ \mathrm{L}^{-1} mol∘L−1(不得使用原用 M \mathrm{M} M为单位符号)。在浓度符号中大写字母 C C C表示单位体积内的数量浓度，即单位体积内的分子数、粒子数等。下标 B \mathrm{B} B代表某个化学物种，例如 N a C l 、 C 6 H 12 O 6 \mathrm{NaCl}、\mathrm{C_6H_{12}O_6} NaCl、C6​H12​O6​等，故用正体。下标 i i i表示序列号，可等于 1 , 2 , ⋯ , k 1,2,\cdots ,k 1,2,⋯,k故用斜体。 c B i c_{\mathrm{B}i} cBi​也可表示为 c i ( B ) c_i(\mathrm{B}) ci​(B),括号内常写物种、温度、压力等表达物理量比较长，比较复杂的注释。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e957c53e772f74bc4e2c32ac0a356704/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92de0c4eef63aac860f3b9e1d32019ba/" rel="bookmark">
			浅入浅出keepalived&#43;nginx实现高可用双机热备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对应用keepalived+nginx技术实现nginx高可用进行简单的分析，下面是通过对keepalived添加校验nginx存活脚本，监控nginx的状态，应用keepalived的主备模式实现nginx的高可用。
假如192.168.100.2和192.168.100.3两台机器安装了nginx，负载均衡配置一模一样。这两台机器对外的虚拟IP是：192.168.100.10，当100.2宕机或nginx未启动或启动失败，则将100.3选举为master，100.10绑定到100.3继续对外提供访问。
1、简介 1.1、keepalived Keepalived是一个基于VRRP协议来实现的服务高可用方案。VRRP协议（虚拟路由冗余协议—— Virtual Router Redundancy Protocol，简称VRRP），是由IETF提出的解决局域网中配置静态网关出现单点失效现象的路由协议，1998年已推出正式的RFC2338协议标准。VRRP广泛应用在边缘网络 中，它的设计目标是支持特定情况下IP数据流量失败转移不会引起混乱，允许主机使用单路由器，以 及即使在实际第一跳路由器使用失败的情形下仍能够维护路由器间的连通性。 简单来说就是，VRRP协议允许一台机器可以拥有一个或者多个虚拟IP。在高可用的一组机器中，有 一个master，多个slave，对外提供一个虚IP，通过虚IP访问master，slave负责监控master，如果 master宕机，则选举其中一个slave接管master，虚IP绑定到新的master上（俗称IP漂移），从而实现了高可用。具体请查看官网。
（摘自官网）
keepalived是一种高性能的服务器高可用或热备解决方案， keepalived可以用来防止服务器单点故障的发生，通过配合nginx可以实现 web 前端服务的高可用。可见keepalived的主备模式是针对宕机等情况，实现vip的漂移。
1.2、nginx nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用，具体请查看官网。
（摘自官网）
keepalived是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和nginx配合来实现web前端服务的高可用。
Keepalived+Nginx实现高可用的思路：
请求不要直接打到nginx上，应该先通过keepalived（这就是所谓虚拟IP，VIP）；keepalived应该能监控nginx的生命状态（提供一个用户自定义的脚本，定期检查nginx进程状态，进行权重变化,，从而实现nginx故障切换）； 2、环境 准备2台机器，均为linux系统，ip地址分别为192.168.100.2和192.168.100.3，分别对应keepalived的master节点和backup节点，在2台机器上均安装keepalived和nginx服务。
vipipkeepalivednginx端口192.168.100.10192.168.100.2master80192.168.100.10192.168.100.3backup80 3、下载安装 3.1、nginx下载安装 准备linux版本的nginx安装包nginx-1.22.1.tar.gz
在2台机器上(ubuntu16.04)进行安装，编译安装命令如下：
# 更新源 apt-get update # 安装gcc g++ 的依赖库 apt-get install build-essential　apt-get install libtool # 安装pcre依赖库 apt-get install libpcre3 libpcre3-dev # 安装zlib依赖库 apt-get install zlib1g-dev # 安装openssl apt-get install openssl libssl-dev # 安装nginx tar -zxvf nginx-1.22.1.tar.gz cd nginx-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92de0c4eef63aac860f3b9e1d32019ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a25e61f584a04b5b8784fd3c27c20881/" rel="bookmark">
			解决Windows10、11 远程桌面时提示用户名、密码错误的情况（实际用户名、密码正确）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
Windows10、11 远程桌面时，提示用户名、密码错误，实际用户名、密码都正确，这种情况一般出现在操作系统以本地身份安装，后登录微软账号，并启用了PIN等Windows Hello登录选项的电脑上。
解决方法：
进入系统设置，将“需要通过Windows Hello登录Microsoft帐户”开关，设置为“关”；
Windows键+L键锁定屏幕，进入登录页面，用微软账号的密码登录一次（较早版本Windows不需要执行1步骤，可以直接使用微软账号登录）；
这个时候就可以正常使用微软账号，以网络级别身份验证登录远程桌面了，1步骤关闭的选项可以打开；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb8ecf9ab019fec27b675aa94a476b78/" rel="bookmark">
			旋转框目标检测mmrotate v1.0.0rc1 之RTMDet训练DOTA（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、模型rotated_rtmdet的论文链接与配置文件 注意：
我们按照 DOTA 评测服务器的最新指标，原来的 voc 格式 mAP 现在是 mAP50。
IN表示ImageNet预训练，COCO表示COCO预训练。
与报告不同的是，这里的推理速度是在 NVIDIA 2080Ti GPU 上测量的，配备 TensorRT 8.4.3、cuDNN 8.2.0、FP16、batch size=1 和 NMS。
2、修改RTMDet-tiny的配置文件 基础配置文件：rotated_rtmdet_l-3x-dota.py _base_ = [ './_base_/default_runtime.py', './_base_/schedule_3x.py', './_base_/dota_rr.py' ] checkpoint = 'https://download.openmmlab.com/mmdetection/v3.0/rtmdet/cspnext_rsb_pretrain/cspnext-l_8xb256-rsb-a1-600e_in1k-6a760974.pth' # noqa angle_version = 'le90' model = dict( type='mmdet.RTMDet', data_preprocessor=dict( type='mmdet.DetDataPreprocessor', mean=[103.53, 116.28, 123.675], std=[57.375, 57.12, 58.395], bgr_to_rgb=False, boxtype2tensor=False, batch_augments=None), backbone=dict( type='mmdet.CSPNeXt', arch='P5', expand_ratio=0.5, deepen_factor=1, widen_factor=1, channel_attention=True, norm_cfg=dict(type='SyncBN'), act_cfg=dict(type='SiLU'), init_cfg=dict( type='Pretrained', prefix='backbone.', checkpoint=checkpoint)), neck=dict( type='mmdet.CSPNeXtPAFPN', in_channels=[256, 512, 1024], out_channels=256, num_csp_blocks=3, expand_ratio=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb8ecf9ab019fec27b675aa94a476b78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35912b2a0df208f449074ded59d95a24/" rel="bookmark">
			基于Python 处理 MODIS 遥感数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 MODIS 是一种卫星遥感仪器，每天以 250-500 米的分辨率在全球范围内收集数据。 了解如何在 Python 中导入、清理和绘制 MODIS 数据。
1、MODIS 影像简介 中分辨率成像光谱仪 (MODIS) 是一种基于卫星的仪器，可连续收集地球表面的数据。 目前，MODIS 拥有公开可用遥感数据的最佳时间分辨率，每 24 小时覆盖整个地球。
MODIS 收集 36 个光谱波段的数据； 但是，在本博客中，您只会使用前 7 个波段。
（1）MODIS 地表反射率（MOD09GA 产品） 这里有许多不同的 MODIS 数据产品。 这些是经过处理以用于科学的数据集。 在本课程中，我们使用的是 MOD09GA 产品，这是一种包含 MODIS 前 7 个波段的反射率产品。
地表反射率值的正常范围是 0 到 1，其中 1 是最亮的值，0 是最暗的值。 表面反射率是地球表面光谱反射率的量度，就像在地面上测量一样。 你可以把它想象成你的眼睛会看到什么，当然除了你的眼睛看不到电磁波谱可见部分之外的光。
MODIS 提供了许多标准化产品，包括您将在本课程中使用的表面反射率 MOD09GA 产品。 MOD09GA 产品在上表中列出的 7 个光谱带中以 500m 的空间分辨率提供表面反射率。
根据创建 MOD09 产品的 Land Surface Reflectance Science Computing Facility，这些产品是每个波段的表面光谱反射率的估计值，因为它会在地面上测量，就好像没有大气散射或吸收一样。 它校正了大气气体、气溶胶和薄卷云的影响。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35912b2a0df208f449074ded59d95a24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb99d736bc72004a7338595e9e5c5997/" rel="bookmark">
			Android自定义View之蜘蛛网雷达效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/ 今日科技快讯 /
近日，在将聊天机器人Bard作为主要用于搜索的AI服务推出后，谷歌似乎正在偏离初衷，没有提供任何具体的用例。在最近举行的全体员工会议上，该公司高管辩称，Bard不仅仅用于搜索，他们正探索构建一种协作式AI服务。
/ 作者简介 /
本篇文章转自史大拿的博客，文章主要分享了自定义View中蛛网的效果，相信会对大家有所帮助！
原文地址：
https://juejin.cn/post/7147966036803846152
/ 前言 /
系统：mac
android studio：4.1.3
kotlin version：1.5.0
gradle：gradle-6.5-bin.zip
本篇效果：
蛛网图其实就是由多个多边形来组成蛛网的，那么先来画1个多边形来练练手。
/ 画多边形 /
首先我们先来画一个五边形，想要绘制一个五边形，那么就是求出5个点即可。例如这样：
首先我们需要定义圆的半径，也是五边形的“半径”。只需要算出每一个角的角度，那么就可以通过三角函数算出每一个点的坐标。
0的角度为360 / 5 * 0
1的角度为360 / 5 * 1
2的角度为360 / 5 * 2
3的角度为360 / 5 * 3
4的角度为360 / 5 * 4
来看看代码：
class E3PolygonChartBlogView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : View(context, attrs, defStyleAttr) { companion object { // 半径 val SMALL_RADIUS = 100.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb99d736bc72004a7338595e9e5c5997/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbc7ef340989d8d498446f8661cc798c/" rel="bookmark">
			springboot&#43;springsecurity&#43;mybatis&#43;jwt实现单点登录（详细到爆了）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目下载：https://download.csdn.net/download/Kevinnsm/16751962
文章目录 Ⅰ、jwt是什么Ⅱ、为什么要使用jwt2.1、什么是有状态2.2、什么是无状态 Ⅲ、jwt的组成 三、springboot+springsecurity+mybatis+jwt实现单点登录Ⅰ、核心流程分析Ⅱ、具体代码实现及其分析1.JwtTokenUtil2.统一结果返回封装类3、handler处理类3.1、AjaxAccessDeniedHandler权限不足处理类3.2、AjaxAuthenticationEntryPoint匿名无权限处理类3.3、AjaxAuthenticationFailureHandler认证失败处理类3.4、AjaxAuthenticationSuccessHandler认证成功处理类3.5、AjaxLogoutSuccessHandler退出成功处理类 4、AuthenticationFilter（token的验证类）5、SecurityConfig配置类6、自定义异常处理类6.1、RegisterFailureException注册失败异常处理类6.2、RegisterUsernameHasBeenExists注册时用户名已经存在异常处理类6.3、Controller层全局异常处理类 7、controller，service，mapper，entity，mapper.xml编写7.1、controller7.2、service7.4、mapper7.5、mapper.xml7.6、entity 8、application.yml9、html测试 Ⅰ、jwt是什么 JWT，全称是Json Web Token， 是JSON风格轻量级的授权和身份认证规范，可实现无状态、分布式的Web应用授权。
Ⅱ、为什么要使用jwt 互联网认证方式由两种：无状态和有状态
2.1、什么是有状态 即服务端需要记录每次会话的客户端信息，典型的如session
有状态流程
1.当用户登录后，客户端会保存该用户的信息到服务端的session中，然后返回一个sessionId，将其保存到客户端的Cookie中
2.当下次用户访问时携带者Cokkie值，这样服务端就能识别对应的session
缺点
1.服务端保存大量用户状态信息，增大了服务端的压力
2.服务端保存用户状态信息，无法进行水平扩展（用户状态信息只保存在这一个服务器中，访问其他服务器还需要重新登录认证）
简单了说有状态就是服务端需要保存用户状态信息
2.2、什么是无状态 服务端不需要保存任何客户端的用户状态信息
我是刘松林的而
无状态流程
1.用户第一次访问时，服务端要求用户进行身份认证（登录）
2.用户认证成功后，服务端返回一个token，返回给客户端作为令牌
3.当用户再次访问时需要携带该token(令牌)，服务端对令牌进行解密判断
优点
1.减少了服务端的压力
2.服务端可以进行任意的伸缩
3.用户登录后可以向多个服务器进行访问而不用进行二次登录
当然无状态最重要的就是保证token的安全性
Ⅲ、jwt的组成 Jwt由三部分组成
1、header
header由两部分组成
1、声明类型：这里是jwt
2、签名算法：比如SHA256、SHA512等
header经过base64编码之后就形成了jwt第一部分
2、Payload（载荷）
payload是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据
iss：发行人
exp：到期时间
sub：主题
…
经过base64编码之后形成了jwt的第二部分
3、Signature（签名）
一般根据前两步的数据，再加上服务的的密钥（secret），通过header里面声明的加密算法生成jwt的第三部分。
secret是服务端用来进行jwt的签发和校验，所以说secret非常重要，任何时候都不应该泄露jwt，一旦jwt泄露，意味着恶意用户可以自我签发jwt了。
三、springboot+springsecurity+mybatis+jwt实现单点登录 Ⅰ、核心流程分析 如果使用springsecurity进行过认证操作，那么这下面将会对你来说很简单
1、根据前述的无状态概念，当用户登录成功后，我们需要在服务端进行token的生成（当然这里是使用jwt生成token)；然后当用户进行再次访问时，我们需要对token进行解析、判断等；所以我们可以将token的创建、解析、判断等封装到一个工具类JwtTokenUtil中。
2、我们还需要自定义一个AuthenticationFilter过滤器用来拦截请求；判断请求中是否携带token，如果携带了token，那就进行解析判断；如果没有token，则可能是首次登录，所以可以放行，交给springsecurity进行认证（也就是交给UsernamePasswordAuthenticationFilter过滤器）
3、第二步中有一个关键点，我们自定义的AuthenticationFilter过滤器应该加到哪个地方，我们都知道springsecurity本质上是一串过滤器链，将请求进行层层拦截、判断、放行或者不放行。根据第二步的分析我们可以将AuthenticationFilter过滤器加入到UsernamePasswordAuthenticationFilter过滤器前面，这样一来第二步就行很清晰了。
其他就类似于springsecurity进行认证和授权的步骤了
Ⅱ、具体代码实现及其分析 1.JwtTokenUtil package com.jwt.utils; import io.jsonwebtoken.Claims; import io.jsonwebtoken.Jws; import io.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbc7ef340989d8d498446f8661cc798c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b583d88651fe7d73edefa2d7e1bc6673/" rel="bookmark">
			Hadoop集群搭建，基于3.3.4hadoop和centos8【图文教程-从零开始搭建Hadoop集群】，常见问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hadoop集群搭建，基于3.3.4hadoop和centos8【小白图文教程-从零开始搭建Hadoop集群】，常见问题解决 Hadoop集群搭建，基于3.3.4hadoop1.虚拟机的创建1.1 第一台虚拟机的创建1.2 第一台虚拟机的安装1.3 第一台虚拟机的网络配置1.3.1 主机名和IP映射配置1.3.2 网络参数配置 1.4 第一台虚拟机的Java,Hadoop环境搭建1.4.1 Java环境搭建1.4.2 Hadoop环境搭建1、修改core-site.xml2、修改hdfs-site.xml，添加以下内容3、修改mapred-site.xml4、修改yarn-site.xml,添加以下内容5、修改 slaves文件 2、克隆另外两台虚拟机及网络配置2.1 克隆虚拟机2.2 克隆虚拟机网络配置 3、设置node-01到其余两台虚拟机的SSH免密登录3、格式化NameNode5、启动hadoop6、启动和关闭Hadoop集群6、通过UI查看Hadoop运行状态遇到的问题 Hadoop集群搭建，基于3.3.4hadoop Hadoop集群搭建，我这里采用的是Hadoop3.3.4，Jdk1.8，centos8,vmware16版本的。
1.虚拟机的创建 首先我们需要创建三台虚拟机,先创建第一台虚拟机，然后对第一台虚拟机进行配置（网络配置，免密配置，jdk,hadoop环境的安装），然后进行克隆，将第一台虚拟机克隆两个虚拟机出来，最后开始搭建集群。
一些目录说明 ：
/export/data/ :存放数据类的文件 /export/servers/ :存放服务类软件 /export/software/ :存放安装包文件 1.1 第一台虚拟机的创建 打开VMware进行第一台虚拟机的创建，点击新建虚拟机
选择典型，下一步
我这里因为提前已经准备好了centos8的镜像资源，所以直接将光盘驱动文件选择了，然后点击下一步
然后自定义虚拟机名称，已经安装的位置，我这里使用node-01（主虚拟机）作为第一台虚拟机的名称，然后点击下一步
磁盘空间默认20GB即可，下一步
点击自定义硬件，对虚拟机的内存和cpu进行一定的配置
这里我只将虚拟机的内存进行了更改，由默认的1GB改到了2GB,然后点击关闭
点击完成
1.2 第一台虚拟机的安装 然后进入到虚拟机安装的环节，通过上下键切换，选择Install Centos stream 8-stream
选择语言，中文，然后点击继续
选择root密码，对root账户的密码进行初始化设定
点击完成
接着我们再对网络进行配置，选择网络和主机名
将网络开启，然后设定主机名，并且应用，然后点击完成
然后选择时区，将时区设为ASia/Shanghai
点击完成
然后选择分区，默认分区也可以
然后进行软件的选择
因为我是小白，所以还是选择了带GUI图形界面的，然后选择网络服务器，传统的UNIX兼容性和基本的开发工具即可
然后开始安装即可，大概几分钟左右
点击重启系统即可
重新启动后，它会让你确认是否接受服务，选择接受即可，然后创建用户这项根据个人需求我就暂时不创建了。
初始界面，如下，第一台虚拟机搭建完毕
1.3 第一台虚拟机的网络配置 我们可以使用XShell来进行远程登录，使用Xftp来进行文件的传输和下载，我这里就不过多赘述，在我的另外一篇文章中都有详细的介绍。
(1条消息) Xshell和Xftp的下载和在linux虚拟机中的使用_xshell和xftp下载_杀死一只知更鸟debug的博客-CSDN博客
1.3.1 主机名和IP映射配置 配置主机名
vi /etc/sysconfig/network 将虚拟机主机名称设为 node-01,node-02,node-03
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b583d88651fe7d73edefa2d7e1bc6673/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbce3e30f37d6309c6a70cdace02caf1/" rel="bookmark">
			（小甲鱼python）函数笔记合集七 函数(IX)总结 python实现汉诺塔详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础复习 函数的基本用法 创建和调用函数 函数的形参与实参等等函数的几种参数 位置参数、关键字参数、默认参数等函数的收集参数*args **args 解包参数详解函数中参数的作用域 局部作用域 全局作用域 global语句 嵌套函数 nonlocal语句等详解函数的闭包（工厂函数）lambda()函数表达式、map()、filter()函数详解生成器的定义、使用和产生生成器的两种方法详解函数的递归、递归和迭代的区别详解 二、汉诺塔 1.汉诺塔简介
汉诺塔（Tower of Hanoi），又称河内塔，是一个源于印度古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。
汉诺塔移动规则：
规则一：一次只能移动一枚金片。小片必须在大片的上面。 2.汉诺塔代码编写
汉诺塔的代码编写，主要用到了函数的递归， 对递归不熟悉的可以看一下函数的递归、递归和迭代的区别详解
例1：当汉诺塔层数为5时
def hanoi(n,x,y,z): if n==1: print(x,'--&gt;',z) # 如果只有1层，直接将金片从x移动到z else: hanoi(n-1,x,z,y) # 将x上的n-1个金片移动到y print(x,'--&gt;',z) # 将最底下的金片从x移动到z hanoi(n-1,y,x,z) # 将y上的n-1个金片移动到z n=int(input('请输入汉诺塔的层数:')) hanoi(n,'A','B','C') 结果：
&gt;&gt;&gt; ================= RESTART: E:\xiaojiayu code\049讲：函数（IX）.py ================= 请输入汉诺塔的层数:5 A --&gt; C A --&gt; C B --&gt; C A --&gt; C B --&gt; C B --&gt; C A --&gt; C A --&gt; C B --&gt; C B --&gt; C A --&gt; C B --&gt; C A --&gt; C A --&gt; C B --&gt; C A --&gt; C B --&gt; C B --&gt; C A --&gt; C B --&gt; C A --&gt; C A --&gt; C B --&gt; C B --&gt; C A --&gt; C A --&gt; C B --&gt; C A --&gt; C B --&gt; C B --&gt; C A --&gt; C 例2：当汉诺塔层数为3时
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbce3e30f37d6309c6a70cdace02caf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34d2985e5fa635ec67bfec4b58982c61/" rel="bookmark">
			3D目标检测（二）—— 直接处理点云的3D目标检测网络VoteNet、H3DNet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 上次介绍了基于Point-Based方法处理点云的模块，3D目标检测（一）—— 基于Point-Based方法的PointNet点云处理系列,其中相关的模块则是构成本次要介绍的，直接在点云的基础上进行3D目标检测网络的基础。
VoteNet 对于直接在点云上预测3D的目标框，有一个相对于2D而言难以解决的问题，即我们扫描得到的点云都是表示在物体表面的，而如果只利用物体表面的点云信息来预测其中心及大小信息，显然是有着一定差距的，而VoteNet这篇工作的主要思路就是想办法得到物体内部的点，然后利用这种内部的点来对物体的BB的中心，大小进行预测。（如下图中，原本黑色的点为物体表面的点，通过设计网络来预测得到物体内部中心的红色点以此来进行预测）
而这种中心的获得，文章主要是通过Hough Voting的思想获得的，Hough Voting有可能大家都对此有诸多的解释，但其主要思路或者说方法就是去构造一个需要检测物体对应的参数空间，像在这里就是一个由边界点到其对应物体中心点的参数空间，那么根据这些物体表面的点在这个参数空间的映射投票，就可以确定其中的中心点。
而其实VoteNet的网络结构主要可以分为两部分来解读，分别为对点云处理的Backbone部分，和目标框的生产Proposal部分。
Backbone VoteNet是直接处理点云来进行目标检测的一个很好例子，其Backbone部分，采用了PointNet++中的SA下采样模块来对点云下采样的同时，提升其特征维度，但考虑到需要进行目标检测，最后采样后剩下的点太少了，于是会在最后接上两个FP模块来在不改变特征维度的情况下，进行上采样，扩充特征空间中的点云数量。
具体而言：
SA：FPS最远点采样-&gt;Ball-query+Group进行球查询后获得K个领域-&gt;MLP+Maxpooling经过多层全连接提取特征后汇聚特征。
FP：将输入第L个SA层的输入输出中的点云，计算距离矩阵来做为插值特征的权重，将得到的插值特征和输入特征拼接经过MLP后，升维得到上采样的点云特征。
经过Backbone得到的点云，称为Seeds，可以认为Seeds就是2维图像经过特征提取后的对图像的抽象特征表示形式。其实不经过后续的Vote操作来获得物体的中心点，也可以进行目标检测，但如上述所言，经过Vote后的物体内部的点，更能生成精确的位置信息。
Vote Vote操作即将经过Backbone生成的Seeds点，通过霍夫投票的思想来生成中心点，而为了在网络上方便的训练和融合，作者利用MLP来处理Seeds点，让网络自主的学习从Seeds点到内部中心点的变换，每个点，其中表示点在空间中的坐标，则表示点所带有的特征信息，将点经过MLP+BN+Relu后，网络学习点到其中心点的空间偏移量和特征偏移量以此通过每个投票获得中心点。
当然，这种Vote的过程是需要监督来完成的，由于我们知道每个BB框的中心点坐标，所以可以通过损失函数的形式来对坐标进行监督，而有关特征偏移量的学习，则相对于一种补偿机制。其中，我们只对是在目标物体表面的Seeds点来进行预测监督。
Proposal Generate 在得到Votes点后，我们对这些点进行一个SA操作，就相对于对这些点进行了聚合并且分成一簇簇的去提取了特征，即相对于在2D领域经过RPN后把生成的proposal一个个特征向量进一步提取特征。
在将聚合了Votes点的特征经过预测头，在这里就是MLP+BN+Relu的操作，生成2+3+num_heading_bin*2+num_size*4+num_classes的向量做为proposal向量。其中2为是否是物体判断的objectness scores，3为基于上一步SA层进一步生成聚合点的xyz坐标里真实中心的偏移量，num_heading_bin为BB框的朝向角预测划分离散形式，在sun-rgbd数据集中，就划分为12个角度，细分为180/12=15°。而num_size和2D里常常直接预测BB的大小不同，其也是一种偏移概念，作者统计了每种物体的mean size，然后通过网络来预测其对应的偏移大小，num_classes则是代表预测物体的类别信息。
像上面说的，不利用Votes点，而利用Seeds点也可以生成proposal点，其区别在于，我们可以通过FPS算法，来对Seeds进行采样获得伪的Votes点，也相对于是一种进一步聚合的方法。
如果对VoteNet进行总结，可以发现其和2D图像里的二阶段目标检测方法其实是异曲同工的，先通过Backbone来提取特征，对提取出的特征用RPN/SA生成proposal，最后对proposal进一步操作，预测其BB属性。区别的是在直接处理点云的网络中，其把许多卷积的操作换成了SA操作，而且不仅需要处理特征信息，也要注意点云原始空间信息的运用，另外在二维图像中，想要获得更多的感受野，一般都需要卷积操作，而在点云中，则可用通过FPS操作后，ball-query+SA来提升采样点的感受野信息。
H3DNet H3DNet是VoteNet的续作，其主要对VoteNet中的一些结果进行分析，然后发现仅仅利用Votes点，也就是中心点，对于如画框这种薄的物体，中心信息有可能并不如其边的信息有效，而对于几何信息丰富的BB框的边界，通过其面的约束，可以使其预测的更加精确。于是作者提出不仅要对物体中心点进行votes，对物体每个面的中心votes和物体的边进行votes也是十分有效的。
而如何Vote的细节，VoteNet中已经提及了，H3DNet需要解决的是，如何将多种Votes的结果利用起来，利用不同Votes的特征来约束生成更加精确的BB。
其主要思路在于，通过构建一个距离函数来表示每个Votes点距离其真正中心点的距离，其生成的proposal应该有最小化这个距离函数的效果。（中心点+6个面心+12条边的中点=19）
作者利用和VoteNet一样的方法，使用物体中心的Votes点来生成初始的proposal，然后利用face和edge信息来最小化这个距离函数，以达到refine初始proposal生成更精细结果的特点。
而在特征融合方面，作者将center的feature当做是初始的特征，分别和来自face和edge的feature进行match，所谓的match就是SA模块：采样+聚合，最后聚合后的face和edge特征concat起来对初始的proposal完成refine。
总结 H3DNet个人我认为，也是一篇工程性或者带有刷点性质的工作，不过其提供了一种改进直接处理点云网络的思路，就是数据的表达，会对最后的效果产生很大的影响，不像2D的工作，在3D中，由于BB的属性相对于2D而言，多了很多特征，而怎么样的表达形式，可以去更好表征BB框中的特征。如最先VoteNet提出通过内部信息的点的表达会比用表面的点，对最后生成BB框有更好的效果，和H3DNet认为face和edge特征对于BB框的表达很重要等，这种对点云不同表达，是值得研究的课题。
H3DNet虽然每种信息的表达不是完全孤立或者独立的，但如edge vote和line vote的产生是并行的，只是在特征层面稍微进行了融合，总归不是一种高效的表达形式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa228de1e24f47512f45690b18bf8c8e/" rel="bookmark">
			WGCNA分析 | 全流程代码分享 | 代码二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		–
关于WGNCA的教程，本次的共有三期教程，我们同时做了三个分析的比较，差异性相对还是比较大的，详情可看WGCNA分析 | 你的数据结果真的是准确的吗？？，这里面我们只是做了输出图形的比较差异，具体基因的差异尚未做。如果，有同学感兴趣的话，可以自己做一下。
在前面的教程，我们分享了WGCNA分析 | 全流程分析代码 | 代码一,这个教程的代码就是无脑运行即可，只需要你更改你的输入文件名称即可，后续的参数自己进行调整，基本就可以做结束整个WGCNA的分析，以及获得你想要的结果文件。
本次是WGCNA分析 | 全流程分析代码 | 代码二的教程，本次使用的代码输出的结果与上一次的结果文件类型是一致，但是由于各个方面的参数调整，让结果图形也有不同的改变。
此外，本次教程输出结果多增加了各hub基因之间的Link连接信息。这部分信息，可以直接输入Cytoscape软件中，获得hub的网络图。
对于这部分数据的输出，参考GitHub中大佬的方法也可以，原理都是一样的。只是本次教程中的代码是批量运行获得全部模块基因的link信息。
1. 教程代码 分析所需包的安装 #install.packages("WGCNA") #BiocManager::install('WGCNA') library(WGCNA) options(stringsAsFactors = FALSE) ## 打开多线程 enableWGCNAThreads() 1.1 样本数据的过滤 导入数据及处理 exr1_symbol_no_dup &lt;- read.csv("ExpData_WGCNA.csv",row.names = 1) dim(exr1_symbol_no_dup) head(exr1_symbol_no_dup) colnames(exr1_symbol_no_dup) #转置 mydata &lt;- exr1_symbol_no_dup datExpr2 = data.frame(t(exr1_symbol_no_dup)) colnames(datExpr2) &lt;- rownames(mydata) rownames(datExpr2) &lt;- colnames(mydata) head(datExpr2) dim(datExpr2) 注：如果你的数据开始就是这里类型的数据格式，即无需进行的此步骤。
基因过滤 datExpr1&lt;-datExpr2 gsg = goodSamplesGenes(datExpr1, verbose = 3); gsg$allOK if (!gsg$allOK){ # Optionally, print the gene and sample names that were removed: if (sum(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa228de1e24f47512f45690b18bf8c8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a1db7f28798d0173a9f26a627b76a8a/" rel="bookmark">
			C&#43;&#43;单例模式实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.提出的需求
​​​​​​​2.如何定义一个类，使得这个类最多只能创建一个对象？
​​​​​​​3.代码
​​​​​​​4.小结
C/C++Linux服务器开发/后台架构师【零声教育】-学习视频教程-腾讯课堂
​​​​​​​1.提出的需求 在架构设计时，某些类在整个系统生命期中最多只能有一个对象存在( Single Instance)。
​​​​​​​2.如何定义一个类，使得这个类最多只能创建一个对象？ 要控制类的对象数目，必须对外隐藏构造函数
思路
将构造函数的访问属性设置为 private定义instance 并初始化为 NULL当需要使用对象时，访问instance 的值 空值:创建对象，并用instance 标记
非空值: 返回instance 标记的对象
​​​​​​​3.代码 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class SObject { static SObject* c_instance; //1.将构造函数的访问属性设置为 private //拷贝构造声明成私有不使用 SObject(const SObject&amp;); //声明成私有不使用 SObject&amp; operator= (const SObject&amp;); //声明成私有不使用 SObject() { } public: static SObject* GetInstance(); void print() { cout &lt;&lt; "this = " &lt;&lt; this &lt;&lt; endl; } }; //静态成员变量类外初始化 //定义instance 并初始化为 NULL SObject* SObject::c_instance = NULL; //静态成员函数类外初始化 SObject* SObject::GetInstance() { //当需要使用对象时，访问instance 的值 //空值:创建对象，并用instance 标记 //非空值: 返回instance 标记的对象 if( c_instance == NULL ) { c_instance = new SObject(); } return c_instance; } int main() { SObject* s = SObject::GetInstance(); SObject* s1 = SObject::GetInstance(); SObject* s2 = SObject::GetInstance(); //唯一对象 s-&gt;print(); s1-&gt;print(); s2-&gt;print(); return 0; } ​​​​​​​4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a1db7f28798d0173a9f26a627b76a8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0163705a41d3e7510bbf32397f0407d8/" rel="bookmark">
			springboot启动报错 Field userMapper in XXXX required a bean of type ‘XXXX‘ that could not be found.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题是我复制的，因为我的解决了。
具体是报错是XXXService创建不了bean，检查一遍，@Service注解也是加了的。就在我百思不得其解的时候，我就顺手刷新了下maven的依赖，然后就好了。
应该是这个sevice是从别的模块调用的，我测试在不停的切分支，导致依赖没刷新过来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/864fd3f45eb49101bab2e0e6af16e64d/" rel="bookmark">
			深度学习被你忽略的细节系列篇——Softmax、LogSumExp和Sigmoid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平时我们用pytorch或者tensorflow框架时，基本对特别底层的函数实现关注不多，仅限于知道公式的原理。但是很多大佬往往自己会实现一些源码(比如ListNet复现)，在看这些源码时，经常出现各种有点难以理解的代码，本来很简单的东西，莫名其妙的各种转换，化简完之后可能感觉是一样的，这么费劲周折的折腾啥？殊不知还是对底层的实现原理了解少了，虽然有些源码不需要我们从底层造轮子(完全从底层造轮子也影响效率)，但是能理解其原理在我们debug以及看一些源码时不至于太多疑惑(毕竟国外很多大佬都喜欢实现一些底层utils)。
今天我们来重新认识一下我们经常用的Softmax、LogSumExp和Sigmoid
1. 背景概要 我们知道编程语言中的数值都有一个表示范围的，如果数值过大，超过最大的范围，就是上溢；如果过小，超过最小的范围，就是下溢。
今天要讨论的Softmax、LogSumExp和Sigmoid，就面临着上述溢出的问题，下面的一些梳理也主要用来解决计算Softmax或CrossEntropy时出现的上溢(overflow)或下溢(underflow)问题。
2. Softmax 在机器学习中，计算概率输出基本都需要经过Softmax函数，它的公式应该很熟悉了吧
Softmax ( x i ) = exp ⁡ ( x i ) ∑ j = 1 n exp ⁡ ( x j ) (1) \text{Softmax}(x_i) = \frac{\exp(x_i)}{\sum_{j=1}^n \exp(x_j)} \tag{1} Softmax(xi​)=∑j=1n​exp(xj​)exp(xi​)​(1)
但是Softmax存在上溢和下溢大问题。如果 x i x_i xi​太大，对应的指数函数也非常大，此时很容易就溢出，得到nan结果；如果 x i x_i xi​太小，或者说负的太多，就会导致出现下溢而变成0，如果分母变成0，就会出现除0的结果。
此时我们经常看到一个常见的做法是(其实用到的是指数归一化技巧, exp-normalize)，先计算x中的最大值 b = max ⁡ i = 1 n x i b = \max_{i=1}^n x_i b=maxi=1n​xi​，然后根据
Softmax ( x i ) = exp ⁡ ( x i ) ∑ j = 1 n exp ⁡ ( x j ) = exp ⁡ ( x i − b ) ⋅ exp ⁡ ( b ) ∑ j = 1 n ( exp ⁡ ( x j − b ) ⋅ exp ⁡ ( b ) ) = exp ⁡ ( x i − b ) ⋅ exp ⁡ ( b ) exp ⁡ ( b ) ⋅ ∑ j = 1 n exp ⁡ ( x j − b ) = exp ⁡ ( x i − b ) ∑ j = 1 n exp ⁡ ( x j − b ) = Softmax ( x i − b ) \begin{aligned} \text{Softmax}(x_i) &amp;= \frac{\exp(x_i)}{\sum_{j=1}^n \exp(x_j)} \\ &amp;= \frac{\exp(x_i - b) \cdot \exp(b)}{\sum_{j=1}^n \left (\exp(x_j - b) \cdot \exp(b) \right)} \\ &amp;= \frac{\exp(x_i - b) \cdot \exp(b)}{ \exp(b) \cdot \sum_{j=1}^n \exp(x_j - b) } \\ &amp;= \frac{\exp(x_i - b)}{\sum_{j=1}^n \exp(x_j - b)} \\ &amp;= \text{Softmax}(x_i - b) \end{aligned} Softmax(xi​)​=∑j=1n​exp(xj​)exp(xi​)​=∑j=1n​(exp(xj​−b)⋅exp(b))exp(xi​−b)⋅exp(b)​=exp(b)⋅∑j=1n​exp(xj​−b)exp(xi​−b)⋅exp(b)​=∑j=1n​exp(xj​−b)exp(xi​−b)​=Softmax(xi​−b)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/864fd3f45eb49101bab2e0e6af16e64d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09897d536b5bde271f0ab65bbd75a345/" rel="bookmark">
			av_interleaved_write_frame -32 broken pipe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个错误是底层socket传递给ffmpeg的，它是一个管道错误，意思是在管道两端，当一端不停的写，另一边却断开接收。那么就会出现：
broken pipe 这个时候有几个可排查的选项：
1.发送的码流是多少，网络带宽是否足够。
2.查看服务器的日志，比如srs流媒体，与推流端连接和断开时都会有日志，记录，看是否连接后，推流时又断开连接了。
解释一下两个函数:
avio_open(&amp;octx-&gt;pb, URL, AVIO_FLAG_READ_WRITE) 如果URL是文件，这里就完成打开文件的操作，如果是URL，那么就完成了网络连接操作，比如URL是rtmp://192.168.100.109/live/yqw，rtmp底层是tcp协议，那么此时这个函数就是帮助建立好tcp连接，等待后面av_interleaved_write_frame发送数据。可以在srs日志中看到，当执行这个函数时，日志显示完成连接。
avformat_write_header(octx, NULL) av_interleaved_write_frame(octx, &amp;enc_pkt) 这两个函数是在avio_open建立好连接后，发送数据。
如果与服务器建立连接后，服务器主动断开连接，那么就要考虑是不是一些参数设置问题了，比如编码器的参数。
设置编码器参数可参考:
https://blog.csdn.net/weixin_43466192/article/details/121036001 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25983a2104f245d7f20173544466fa15/" rel="bookmark">
			OpenCV是什么？OpenCV是干什么的？OpenCV概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 OpenCV是一种开源计算机视觉库，它提供了一些用于处理图像和视频的工具和算法。OpenCV最初是由英特尔公司开发的，现在已经成为了一种广泛使用的开源工具，它被用于各种各样的计算机视觉应用程序中，包括人脸检测、目标识别、图像分割、机器人视觉、运动跟踪、手势识别等。
OpenCV提供了许多用于图像处理和计算机视觉的功能，包括图像滤波、特征检测、特征匹配、图像分割、摄像机校准、三维重建等。它还提供了C++、Python和Java等编程语言的接口，方便用户在各种平台上进行开发。
OpenCV是什么？OpenCV是干什么的？
以下是OpenCV主要用途的一些例子：
图像处理：OpenCV提供了一系列用于处理图像的函数和算法，包括图像滤波、图像变换、图像分割、形态学操作等。
特征检测与描述：OpenCV提供了用于检测和描述图像中的特征的函数和算法，例如SIFT、SURF、ORB、FAST等。
目标检测与识别：OpenCV提供了用于目标检测和识别的函数和算法，例如Haar Cascade分类器、HOG+SVM分类器等。
视频处理：OpenCV提供了一些用于处理视频的函数和算法，包括视频捕捉、视频压缩、视频分析等。
机器学习：OpenCV提供了一些用于机器学习的函数和算法，例如支持向量机、神经网络、K均值聚类等。
总之，OpenCV提供了广泛的计算机视觉工具和算法，可以帮助开发人员快速、高效地开发各种计算机视觉应用程序。
免费分享一些我整理的人工智能学习资料给大家，整理了很久，非常全面。包括一些人工智能基础入门视频+AI常用框架实战视频、计算机视觉、机器学习、图像识别、NLP、OpenCV、YOLO、pytorch、深度学习与神经网络等视频、课件源码、国内外知名精华资源、AI热门论文等。
下面是部分截图，点击文末名片关注我的公众号【AI技术星球】发送暗号 321 领取（一定要发暗号 321） 目录
一、人工智能免费视频课程和项目
二、人工智能必读书籍
三、人工智能论文合集
四、机器学习+计算机视觉基础算法教程
五、深度学习机器学习速查表（共26张）
学好人工智能，要多看书，多动手，多实践，要想提高自己的水平，一定要学会沉下心来慢慢的系统学习，最终才能有所收获。
点击下方名片，扫码关注公众号【AI技术星球】发送暗号 321 免费领取文中资料。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a00054c162a9528820e4e26d6c2d0e54/" rel="bookmark">
			使用python selenium实现url不变的情况下，翻页爬取页面数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import requests from bs4 import BeautifulSoup import openpyxl from selenium import webdriver from selenium.webdriver.common.by import By import time wt = openpyxl.Workbook() ws = wt.create_sheet('sheet11') ws.append(['LIST']) browser = webdriver.Edge() url = 'https://www.freebuf.com/articles/security-management' html = browser.get(url) # print(browser.page_source) nextpagebutton = browser.find_element(By.XPATH, "//li[@class = ' ant-pagination-next']/a") for r in range(1,16): soup = BeautifulSoup(browser.page_source, 'html.parser') spans = soup.find_all('span', class_ = 'title text-line-1') browser.execute_script("arguments[0].click();" ,nextpagebutton) time.sleep(1) print('--------------------正在打印第' + str(r) + '页数据---------------------------') for span in spans: LIST = span.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a00054c162a9528820e4e26d6c2d0e54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b44e14004979b9fcd839b2d4763e9eb/" rel="bookmark">
			Qt学习3-Qt Creator四则运算计算器（哔站视频学习记录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算器中的“=”按钮这部分的代码解释 目录
制作计算器中的“=”按钮这部分的代码解释
一、代码部分
二、解释
三、思路
四、死循环！
一、代码部分
void Widget::on_equalButton_clicked() { QStack&lt;int&gt; s_num,s_opt; //声明两个int类型变量 char opt[128]={0};//char型数组 int i = 0,tmp = 0,num1,num2;//声明变量i，tmp,num1，num2 //把QString 转换成 char* QByteArray ba;//字节数组 ba.append(expression);//把QString转换成QByteArray strcpy(opt,ba.data());//data可以把QByteArray转换成char * while(opt[i]!='\0'||s_opt.empty()!=true)//在字符串中'\0'用作字符串的结束标志，字符串没结束且不为空的情况下 { if(opt[i]&gt;='0'&amp;&amp;opt[i]&lt;='9')//字符在0-9之间 { tmp=tmp*10+opt[i]-'0'; i++; if(opt[i]&lt;'0'||opt[i]&gt;'9')//字符不在0-9之间 { s_num.push(tmp); tmp = 0; } } else //操作符 { if(s_opt.empty() == true || Priority(opt[i]) &gt; Priority(s_opt.top()) || (s_opt.top() == '(' &amp;&amp; opt[i] != ')')) { s_opt.push(opt[i]); i++; continue; } if(s_opt.top() == '(' &amp;&amp; opt[i] == ')') { s_opt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b44e14004979b9fcd839b2d4763e9eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03a0411bc36af9bf500d8a3213af4f34/" rel="bookmark">
			ubuntu error start of central directory not found； zipfile corrupt.问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小虎刚刚想要在ubuntu上解压在win上打包的图片数据。发现无法解压，因为压缩编码方式ubuntu无法识别。
背景 运行环境：
win11 + Ubuntu 20.04
报错：
warning 205259738 extra bytes at beginning or within zipfile error start of central directory not found; zipfile corrupt. 解决代码 sudo apt-get install fastjar jar xvf yourzip.zip 类似报错 Archive: Cityscapes.zip warning [Cityscapes.zip]: 3909008000 extra bytes at beginning or within zipfile (attempting to process anyway) error [Cityscapes.zip]: start of central directory not found; zipfile corrupt. (please check that you have transferred or created the zipfile in the appropriate BINARY mode and that you have compiled UnZip properly) 参考 unzip error “End-of-central-directory signature not found”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/797e8ff67aa67f7518abb5b432889b39/" rel="bookmark">
			SAS字典的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据字典中常用信息检索DICTIONARY.COLUMNS、DICTIONARY.TABLES以及DICTIONARY.MEMBERS等字典表的内容。在编程实践中，如何以SAS字典表来提高效率。
1、DICTIONARY.COLUMNS 对于当前SAS任务的全部数据集，表格DICTIONARY.COLUMNS包含了诸如变量的名称、类型、长度和标签等信息。
表格视图中每一变量的属性都可以使用DESCRIBE语句来识别。
proc sql; describe table dictionary.columns; quit; 【例1.1】将数据集SASHELP.CARS的全部变量名存入宏变量VARNAME中，变量名之间用空格分隔。
proc sql;
select name into :varname separated by ' '
from dictionary.columns
where libname=upcase("SASHELP") and memname=upcase("CARS");
%put &amp;varname;
quit;
【例1.2】将数据集SASHELP.CARS的以"m"为首字符的变量名存入宏变量VARNAME中，
proc sql;
select name into :varname separated by ' '
from dictionary.columns
where libname=upcase("SASHELP") and memname=upcase("CARS")
and substr(strip(name),1,2) like "M%";
%put &amp;varname;
quit;
/*strip函数用来去除字符串前后空格*/
/*substr(string,1,2)函数表示从字符串位置1开始读取2个字符*/
【例1.3】将数据集SASHELP.CARS中带有FORMAT的变量找出，将这些变量的名称存入宏变量VARNAME，[名称和格式的联合字符]串存入宏变量VARFMT。
/*PS:通过此程序，可以实现批量格式转换。将表1的一部分格式复制到表2中。*/
/*先提取表1中目标变量的格式，存储其变量名和格式，再将此格式宏变量运用在表2中*/
proc sql;
select strip(name),strip(name)||' '||format
into : varname separated by ' ',: varfmt separated by ' '
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/797e8ff67aa67f7518abb5b432889b39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16cc7ee1a1b24803d6bb17cfc87a34cf/" rel="bookmark">
			Hadoop分布式生态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、Hadoop系统架构二、HDFS1.设计理念2.架构原理2.文件写入与读取4.数据备份 三、MapReduce1.设计思想2.架构原理3.计算流程 四、YARN总结 前言 Hadoop分布式系统
一、Hadoop系统架构 Hadoop的核心组件分为：
HDFS（分布式文件系统）、MapRuduce（分布式运算编程框架）、YARN（运算资源调度系统）
下图展示的是Hadoop的生态圈：
二、HDFS HDFS是Hadoop分布式文件系统（Hadoop Distributed File System）的缩写，为分布式计算存储提供了底层支持。采用Java语言开发，可以部署在多种普通的廉价机器上，以集群处理数量积达到大型主机处理性能。
HDFS是Hadoop体系中数据存储管理的基础。它是一个高度容错的系统，能检测和应对硬件故障，用于在低成本的通用硬件上运行。HDFS简化了文件的一致性模型，通过流式数据访问，提供高吞吐量应用程序数据访问功能，适合带有大型数据集的应用程序。
1.设计理念 简单来讲，HDFS 的设计理念是，可以运行在普通机器上，以流式数据方式存储文件，一次写入、多次查询，具体有以下几点。
1） 可构建在廉价机器上
HDFS 的设计理念之一就是让它能运行在普通的硬件之上，即便硬件出现故障，也可以通过容错策略来保证数据的高可用性。
2）高容错性
由于 HDFS 需要建立在普通计算机上，所以结点故障是正常的事情。HDFS 将数据自动保存多个副本，副本丢失后，自动恢复，从而实现数据的高容错性。
3）适合批处理
HDFS 适合一次写入、多次查询（读取）的情况。在数据集生成后，需要长时间在此数据集上进行各种分析。每次分析都将涉及该数据集的大部分数据甚至全部数据，因此读取整个数据集的时间延迟比读取第一条记录的时间延迟更重要。
4） 适合存储大文件
这里说的大文件包含两种意思：一是值文件大小超过 100MB 及达到 GB 甚至 TB、PB 级的文件;二是百万规模以上的文件数量。
2.架构原理 HDFS采用master/slave架构。一个HDFS集群包含一个单独的NameNode和多个DataNode。
NameNode作为master服务，它负责管理文件系统的命名空间和客户端对文件的访问。NameNode会保存文件系统的具体信息，包括文件信息、文件被分割成具体block块的信息、以及每一个block块归属的DataNode的信息。对于整个集群来说，HDFS通过NameNode对用户提供了一个单一的命名空间。
DataNode作为slave服务，在集群中可以存在多个。通常每一个DataNode都对应于一个物理节点(当然也不排除每个物理节点可以有多个DataNode，不过生产环境里不建议这么做)。DataNode负责管理节点上它们拥有的存储，它将存储划分为多个block块，管理block块信息，同时周期性的将其所有的block块信息发送给NameNode。
Client 会分别访问 NameNode 和 DataNode 以获取文件的元信息及内容。HDFS 集群的 Client 将直接访问 NameNode 和 DataNode，相关数据会直接从 NameNode 或者 DataNode 传送到客户端。
在HDFS中，主要有三个角色，Client、NameNode、DataNode。
2.文件写入与读取 文件写入
Client向NameNode发起文件写入的请求。NameNode根据文件大小和文件块配置情况，返回给Client它所管理部分DataNode的信息。Client将文件划分为多个block块，并根据DataNode的地址信息，按顺序写入到每一个DataNode块中。
具体步骤如下：
客户端调用 DistribuedFileSystem 的 Create() 方法来创建文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16cc7ee1a1b24803d6bb17cfc87a34cf/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/160/">«</a>
	<span class="pagination__item pagination__item--current">161/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/162/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>