<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e1c622836639e22e84f7f48d998b12a/" rel="bookmark">
			给定一个整数数组nums,和一个目标值target 请你在该数组中找出和为目标值的那两个整数， 并返回他们的数组下标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题： 给定一个整数数组nums和一个目标值target,请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标
要求： 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
使用python代码实现： class Solution(object): def twoSum(self,nums,target): """ 两数之和 :param nums:list[int] :param target: int :return: """ hashmap={} for index,num in enumerate(nums): author_num=target-num if author_num in hashmap: return [hashmap[author_num],index] hashmap[num]=index return None nums=[2,7,11,15] target=9 s=Solution() res=s.twoSum(nums,target) print(res) 结果展示： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a822c37389b2724bc2cc49da28dca76/" rel="bookmark">
			Win10家庭版增加本地安全策略（组策略）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows本地安全策略就是组策略
Win10家庭版是没有组策略编辑器的，只有专业版和企业版才有
但是我们真的可以自己添加，以前以为是不行的，现在亲测成功了。
在任意位置新建一个txt文档，打开后将以下代码复制粘贴上去。
@echo off pushd "%~dp0" dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txt dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txt for /f %%i in ('findstr /i . List.txt 2^&gt;nul') do dism /online /norestart /add-package:"C:\Windows\servicing\Packages\%%i" pause 保存为.bat文件，然后用管理员身份运行
然后就会出现下图。有时候卡住按个空格或者回车它就又继续了。
添加这个程序包它会添加好几次，并且添加的好像都是相同的一个。当时我差不多都要把它关掉的时候，它就好了，最后出现个“按任意键继续” （如果卡住不动的话，按一下空格或者enter键可能就好了）
然后就真的出现本地安全策略了。神奇！
参考博客：https://blog.csdn.net/gocn/article/details/83650949
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6eba7440c5c73047f33aa302ce110d3/" rel="bookmark">
			Apache ShardingSphere整合Seata AT分布式事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景知识
Seata是阿里集团和蚂蚁金服联合打造的分布式事务框架，目前版本包含了AT事务和TCC事务。其中AT事务的目标是在微服务架构下，提供增量的事务ACID语意，让用户像使用本地事务一样，使用分布式事务，核心理念同ShardingSphere一脉相承。
Github: https://github.com/seata/seata
Seata AT模型
Seata AT事务模型包含TM(事务管理器)，RM(资源管理器)，TC(事务协调器)。
其中TC是一个独立的服务需要单独部署，TM和RM以jar包的方式同业务应用部署在一起，它们同TC建立长连接，在整个事务生命周期内，保持RPC通信。
其中全局事务的发起方作为TM，全局事务的参与者作为RM ; TM负责全局事务的begin和commit/rollback，RM负责分支事务的执行和commit/rollback。
ShardingSphere分布式事务SPI
ShardingSphere提供了一套接入分布式事务的SPI，设计的目标是保证数据分片后，事务的ACID语意。分布式事务的实现目前主要包含两阶段的XA和BASE柔性事务。Seata AT事务作为BASE柔性事务的一种实现，可以无缝接入到ShardingSphere生态中。
两阶段XA事务方面，我们已经整合了Atomikos，Narayana，Bitronix事务管理器，XA事务底层依赖具体的数据库厂商对XA两阶段提交协议的支持，通常XA协议通过在Prepare和Commit阶段进行2PL(2阶段锁)，保证了分布式事务的ACID，通常适用于短事务及非云化环境（云化环境下一次IO操作大概需要20ms，两阶段锁会锁住资源长达40ms，因此事务的TPS会降到25/s左右，非云化环境通常一次IO只需几毫秒，因此锁热点数据的时间相对较低）[1]。
BASE柔性事务方面，目前我们已经完成了对ServiceComb Saga的整合，Saga通过一阶段提交+补偿的方式提高了整体事务的性能，其中补偿的方式同Seata大致相同，即对分片后的物理SQL进行revert来生成补偿的SQL，但Saga模型在理论上不支持隔离级别，适用于对性能要求较高，对一致性要求比较低的业务。Seata AT事务在一阶段提交+补偿的基础上，通过TC的全局锁实现了RC隔离级别的支持，是介于XA和Saga之间的另一种实现。消息柔性事务方面，也欢迎大家参考我们的SPI提供整合的方案。
整合方案
整合Seata AT事务时，需要把TM，RM，TC的模型融入到ShardingSphere 分布式事务的SPI的生态中。在数据库资源上，Seata通过对接DataSource接口，让JDBC操作可以同TC进行RPC通信。同样，ShardingSphere也是面向DataSource接口对用户配置的物理DataSource进行了聚合，因此把物理DataSource二次包装为Seata的DataSource后，就可以把Seata AT事务融入到ShardingSphere的分片中。
在Seata模型中，全局事务的上下文存放在线程变量中，通过扩展服务间的transport，可以完成线程变量的传递，分支事务通过线程变量判断是否加入到整个Seata全局事务中。而ShardingSphere的分片执行引擎通常是按多线程执行，因此整合Seata AT事务时，需要扩展主线程和子线程的事务上下文传递，这同服务间的上下文传递思路完全相同。
Quick Start
我们已经实现了base-seata-raw-jdbc-example，大家可以自行进行尝试。
https://github.com/apache/incubator-shardingsphere-example/tree/dev/sharding-jdbc-example/transaction-example/transaction-base-seata-example/transaction-base-seata-raw-jdbc-example
操作手册：
1.按照seata-work-shop中的步骤，下载并启动seata server。
https://github.com/seata/seata-workshop
参考 Step6 和 Step7即可
2.在每一个分片数据库实例中执行resources/sql/undo_log.sql脚本，创建undo_log表
3.Run YamlConfigurationTransactionExample.java
待优化项
Seata AT事务在Revert SQL时，需要对ShardingSphere分片后的物理SQL进行二次的解析，这里我们需要设计一个SPI，避免SQL二次解析的性能损耗。
参考论文
[1]: Transactions for Distributed Actors in the Cloud
https://www.microsoft.com/en-us/research/wp-content/uploads/2016/10/EldeebBernstein-TransactionalActors-MSR-TR-1.pdf
Apache ShardingSphere（Incubating）自2016开源以来，不断精进、不断发展，被越来越多的企业和个人认可：Github上收获7000+的stars，70+公司企业的成功案例。此外，越来越多的企业和个人也加入到Apache ShardingSphere（Incubating）的开源项目中，为它的成长和发展贡献了巨大力量。
ShardingSphere目前长期开放招聘全职研发人员，欢迎开源社区优秀人才加入我们，共同打造出色的开源生态。
ShardingSphere在进入Apache基金会孵化器以来，受到了越来越多的关注，我们的目标是将其打造为分布式数据库中间件的标准。参与开源项目的开发和社区建设，不但能够为参与者和项目本身带来收益，还能够让参与者享受乐趣、带来成就感，一举多得。
该职位长期开放，欢迎大家参与ShardingSphere的开发和社区建设。我们优先考虑对ShardingSphere有深入了解并且深度参与社区建设的同学。我们等你来一起全职玩转开源！
项目地址：
https://github.com/apache/incubator-shardingsphere
更多信息请浏览官网：
https://shardingsphere.apache.org/
职位信息：
https://mp.weixin.qq.com/s/V4qfA5KjiCWvKNQM6cdnYw
招聘邮箱：
zhangliang@apache.org
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5991179277d07fab8e830b918a47f9b8/" rel="bookmark">
			SQL Server数据库触发器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		触发器的主要作用就是能够完成主键和外键不能保证的复杂的数据完整性和数据一致性的约束，触发器可以对数据表进行级联操作，提供比CHECK约束更为复杂的数据完整性
触发器主要有以下优点：
触发器是自动执行的，一旦设立就存在一种触发机制，永远监控着数据库的事件状态。触发器可以对数据库中的表进行层叠更改。触发器可以设置比CHECK更为复杂的约束限制。触发器还可以对不同表中的约束进行引用。 --在xs表中创建safty触发器，拒绝用户对数据库中的表进行删除和更改操作。
解析：ON关键字后面的DATABASE指的是此触发器的作用域，Drop_Table、Alter_Table指定DDL触发器的触发事件，当前触发条件为删除表和修改表。
创建完成触发器执行删除表操作：
上面的触发器作用在xs数据库中，如果想让整个数据库服务器都收到DDL触发器的约束，可以创建作用在服务器中的触发器。
执行删除操作，测试触发器的创建：
实现级联操作
在SQL Server中可以通过触发器对有关系的表进行级联操作，使用触发器对表中的数据进行级联更新、级联删除。
在xs表上创建一个触发器trigcategorydelete，要求在对xs表上的数据进行删除操作时级联删除xk表中信息。
执行代码创建触发器后，执行删除语句触发该触发器：
如上描述如有不懂，或想学习更多技术知识，可以扫码关注麒琳技术栈公众号，欢迎在线咨询
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54979d7d2ba0cdb6a3ff847aa697d407/" rel="bookmark">
			C语言宏的用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介 宏在C语言中是一段有名称的代码片段。无论何时使用到这个宏的时候，宏的内容都会被这段代码替换掉。主要有两种宏，他们的区别主要是在使用上面，一种是在使用时类似于数据对象称为Object-like，另一种在使用时类似于函数调用称为Function-like。在C语言使用#define来定义宏
你可以将任意的有效的标识符定义为宏，设置C语言的关键字也可以。但是在C语言中defined不可以作为宏的名称。在C++中以下的关键字也不可以作为宏的名称and,and_eq,bitand,bitor,compl,not,not_eq,or,or_eq,xor,xor_eq。
2、两种宏的类型 2.1 Object-like宏 Object-like宏，可以比较简单的进行代码段的替换。这种方式最常用做表示常量数字。例如： #define BUFFER_SIZE 1024 使用该宏的时候就可以用来替换数字。
foo = (char *) malloc (BUFFER_SIZE); 预处理器将会把该宏替换为对应的数字,如下所示。
foo = (char *) malloc (1024); 按照惯例，宏一般都写作大写字母。
多行的宏 宏结束于#define的行尾，如果有必要的话，可以在末尾添加反斜杠来将宏定义成多行。
#define NUMBERS 1, \ 2, \ 3 int x[] = { NUMBERS }; //→ int x[] = { 1, 2, 3 }; 多次宏替换 如果宏定义的代码段依然是宏的话，预处理器会继续进行宏替换的操作。
#define TABLESIZE BUFSIZE #define BUFSIZE 1024 TABLESIZE //→ BUFSIZE //→ 1024 最终TABLESIZE会被替换成1024
2.2 Function-like宏 宏还可以被定义成下面的形式，使用该宏的时候，类似于调用函数，这类宏的定义中，宏的名称后面紧跟一堆括号(与括号之间不能有空格)。
#define lang_init() c_init() lang_init() //→ c_init() 调用该类宏的时候，也必须跟一个括号，如果不跟括号的话，会显示语法错误。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54979d7d2ba0cdb6a3ff847aa697d407/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c9c9fff942bc003ba91a7807ad93a29/" rel="bookmark">
			怎么远程传输大文件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常工作中，我们常常会遇到将电脑的文件，特别是大文件资料进行传输，比如设计稿件，软件开发包，视频素材等等大文件资料进行传输发送。虽然网络通信技术不断发展，对大数据量，高频次，远距离的文件传输成为我们工作中常常遇到的问题。常用的QQ文件传输，微信发送，邮箱，FTP等常规方式，都要面对一方发送，一方接收，或者提前上传到服务器，然后接收方下载，同时也收到附件大小的限制，导致工作效率大大降低。
传统的传输方式主要分为：http与ftp。我们常用的邮件发送就是http的一种，其主要是便捷，简单。然后很多http
服务器对链接超时、文件大小等都用种种限制，这主要是因为其最初是为了网页进行开发设计的一种协议。而FTP是另外一种较为常用的传输工具，其优点与http相似，虽然网络带宽的增加，FTP的传输效率也逐步得到提升。
这两种传输方式的共同特点是：
1.需要服务器支持，通过服务器进行数据传输发送，同时也受到服务的带宽、性能等条件限制；
2.用户大量访问容易出现阻塞，延迟，当遇到大量用户访问，可以增加服务器，但同时会影响到整体传输效率。因此在相对冷门时间传输的效果会明显高于工作时段；
3.适用于小文件分发，当进行大容量，多文件传输时，容易出现高丢包率，高延迟的问题，导致文件传输质量与时效受到严重影响；
4.远距离传输容易受到网络环境影响，导致发送失败。比如从新疆发送到深圳，或深圳发送到巴西等远距离传输都会因网络环境的因素导致丢包与延迟；
镭速传输作为一个替代FTP的高速传输软件，针对用户对大文件、远距离传输提供独有的UDP协议，能够确保低丢包率，低延迟的基础上，依靠HTTPS安全协议确保用户信息得到有效保护。在文件跨省、跨国传输为企业降低成本，提升办公效率。
与传统的FTP对比，镭速传输在传输速度得到大幅提升。依托FTPS,TLS加密技术，保护用户数据安全。通过系统自有的断点续传、错误重传保障了在恶劣网络环境下的高效传输。
在大文件跨国传输提供更加高效的服务，可一次性高速传输数百万个文件以及TB级文件，保存结构完整性和内容准确性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24739876b947f55bd7e43d3c47b5376e/" rel="bookmark">
			Java生成XML格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具： dom4j-1.6.1.jar
相关类 import org.dom4j.Attribute;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.DocumentHelper;import org.dom4j.Element;import org.dom4j.io.SAXReader;import org.dom4j.io.XMLWriter; 实例1 还是直接看例子吧,最终生成结果展示：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;root&gt; &lt;username&gt;张三&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/root&gt; 代码如下： Document document = DocumentHelper.createDocument(); //创建根节点 Element root = document.addElement("root"); //添加子节点 Element username = root.addElement("username"); Element password = root.addElement("password"); //赋值 username.addText("张三"); password.addText("123456"); String strXML = document.asXML(); System.out.println(strXML); 实例2 适用于部分子节点封装成类，最终生成结果展示：
其中,结构是重复的，可以写成一个类Course.java; &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;root&gt; &lt;username&gt;张三&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;courses&gt; &lt;course&gt; &lt;courseid&gt;课程id&lt;/courseid&gt; &lt;coursename&gt;语文课&lt;/coursename&gt; &lt;coursenum&gt;007&lt;/coursenum&gt; &lt;courseteacher&gt;王老师&lt;/courseteacher&gt; &lt;/course&gt; &lt;course&gt; &lt;courseid&gt;课程id2&lt;/courseid&gt; &lt;coursename&gt;数学课&lt;/coursename&gt; &lt;coursenum&gt;008&lt;/coursenum&gt; &lt;courseteacher&gt;李老师&lt;/courseteacher&gt; &lt;/course&gt; &lt;/courses&gt; &lt;/root&gt; 代码如下： Course.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24739876b947f55bd7e43d3c47b5376e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6be0eb40bdd1010d4ba93274d184d984/" rel="bookmark">
			查看Oracle数据库所有的用户及表空间等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看所有用户：select * from all_users; 查看表空间：select tablespace_name from dba_tablespaces; 查看用户具有怎样的角色：select * from dba_role_privs where grantee='用户名'； 查看某个角色包括哪些系统权限：select * from dba_sys_privs where grantee='DBA' 查看oracle中所有的角色：select * from dba_roles; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8511727ff9e7d7b90ded4a6b00f6b9ca/" rel="bookmark">
			Pandas数据分析实战项目(简单)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目介绍 项目背景：根据已有数据，对给定车型进行数据分析，得出给定车型近半年每个月在各个城市真实搜索指数
数据来源：数据使用百度指数给出的数据，通过对给定车型关键词进行数据抓取，得到车型的全国搜索指数。省份搜索热度、城市搜索热度。
数据：
链接：https://pan.baidu.com/s/1h5KKVESgRRHaP4DYgM8AaA
提取码：ke0o
二、项目处理 1、处理全国指数趋势表 打开百度指数趋势表，发现有如下问题需要处理：
对于个别车型是近期才有数据，之前没有数据，需要对缺失值进行处理；结果是需要月级数据，但是原始数据是按天的，需要对日期进行处理；对于原始数据关键词keyword字段，为防止合并时出现大小写区别而合并错误，需要对关键词进行统一处理。 代码实现： In [1] :import numpy as np import pandas as pd # 读取百度指数表 In [2] :index = pd.read_excel('baidu_index_0625.xlsx') prov_id = pd.read_excel('prov_id .xlsx') city_id = pd.read_excel('city_id.xlsx') # 处理缺失值 In [3] :index = index.fillna(0) # 对data字段进行格式化处理 In [4] :index['date'] = pd.to_datetime(index['date']) index['date'] = index['date'].dt.strftime('%B') # 对关键词字段进行统一处理 In [5] :index['keyword'] = index['keyword'].apply(lambda x: x.strip(' \r\n\t').upper()) # 根据keyword，date对搜索指数进行分类汇总求和 In [6] :new_index_mean = index.groupby(['keyword','date’])['_index'].sum() # 展示结果 In [7] :new_index_mean Out[7] : keyword date IX25 April 29144.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8511727ff9e7d7b90ded4a6b00f6b9ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad4d3a791f957fdd9478fdf72162e78a/" rel="bookmark">
			并发事务带来哪些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。
脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
不可重复度和幻读区别：
不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。
——作者 SnailClimb
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7724fadafed53b89de924205ac5051d/" rel="bookmark">
			RabbitMQ自学之路（七）—— RabbitMQ消息发送确认与消息接收确认机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常，一个消息被消费者消费后，就会从Queue中移除了。这是因为RabbitMQ默认会在消息被消费者接收后，立即确认。
但存在丢失消息的可能，如果消费端消费逻辑抛出异常，也就是消费端没有处理成功这条消息，那么就相当于丢失了消息。
另外一种情况就是，我们在spring中处理消息时，即使消息处理没出异常，但是后续代码出异常造成回滚，这样其实也相当于丢失消息。
所以一般情况下，手动确认要比较好一些。
达broker之前出现意外，那就造成消息丢失
一、消息发送确认 1、为什么要进行消息确认? 主要原因是为了防止消息的丢失。
对于消息发送方来说：
生产者发送一条消息，正常情况下是通过交换机发送到队列中，再由消费者接受队列中消息，由消费者进行逻辑操作。
但是RabbitMQ在收到消息后，还需要有一段时间才能将消息存入磁盘之中。
并且也并不是为每条消息都做fsync的处理，可能仅仅保存到cache中而不是物理磁盘上。如果RabbitMQ broker正巧发生了崩溃，因为消息还没来得及保存磁盘，消息将会丢失。
2、发送的消息怎么样才算失败或成功？ 当消息无法路由到任何队列时，确认消息路由失败。
消息成功路由时，当需要发送的队列都发送成功后，进行确认消息，对于持久化队列意味着写入磁盘，对于镜像队列意味着所有镜像接收成功
3、如何确定发送的消息是否成功？ RabbitMQ引入发送端消息确认机制，主要通过事务和publisher Confirm机制。
3.1、AMQP事务使用 RabbitMQ支持事务(transaction)，RabbitMQ中与事务机制有关的方法有三个：txSelect(), txCommit()以及txRollback()。
（1）txSelect用于将当前channel设置成transaction模式，通过调用tx.select方法开启事务模式。
（2）txCommit用于提交事务。当开启了事务模式后，只有当一个消息被所有的镜像队列保存完毕后，RabbitMQ才会调用tx.commit-ok返回给客户端。
（3）txRollback用于回滚事务，在通过txSelect开启事务之后，我们便可以发布消息给broker代理服务器了，如果txCommit提交成功了，则消息一定到达了broker了，如果在txCommit执行之前broker异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过txRollback回滚事务了。
关键代码：
channel.txSelect(); //ConfirmConfig.exchangeName(交换机名称) //ConfirmConfig.routingKey(路由键) //message （消息内容） channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, message)); channel.txCommit(); 事务确实能够解决producer与broker之间消息确认的问题，只有消息成功被broker接受，事务提交才能成功，否则我们便可以在捕获异常进行事务回滚操作同时进行消息重发。
事务机制的缺点 ：
使用事务机制的话会降低RabbitMQ的性能。
会导致生产者和RabbitMq之间产生同步(等待确认)，这也违背了我们使用RabbitMq的初衷。所以一般很少采用
3.2、publisher Confirm机制（发送者确认） 那么有没有更好的方法既能保障producer知道消息已经正确送到，又能基本上不带来性能上的损失呢？从AMQP协议的层面看是没有更好的方法，但是RabbitMQ提供了一个更好的方案，即将channel信道设置成confirm模式。
发送确认分为两步，一是确认是否到达交换器，二是确认是否到达队列。
confirm模式的实现原理
生产者将信道设置成confirm模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认给生产者（包含消息的唯一ID）,这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出，broker回传给生产者的确认消息中deliver-tag域包含了确认消息的序列号，此外broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理。
ConfirmCallback和ReturnCallback
对于ConfirmCallback来说： 如果消息没有到exchange,则confirm回调,ack=false 如果消息到达exchange,则confirm回调,ack=true 对于ReturnCallback来说： exchange到queue成功,则不回调return exchange到queue失败,则回调return(需设置mandatory=true,否则不回回调,消息就丢了) 比如路由不到队列时触发回调 使用该功能需要开启确认，spring-boot中配置如下：
spring: rabbitmq: #服务器ip host: 127.0.0.1 #端口号 port: 5672 #用户名 username: admin #密码 password: 123456 #开启消息发送确认机制，默认为false #如果没有本条配置信息，当消费者收到生产者发送的消息后，生产者无法收到确认成功的回调信息 publisher-confirms: true #支持消息发送失败返回队列,默认为false publisher-returns: true #虚拟空间地址 virtual-host: / RabbitConfig配置项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7724fadafed53b89de924205ac5051d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91ef4e71a1650718c12d0e569cc8fc3d/" rel="bookmark">
			MySQL数据类型详解:tinyint,smallint,mediumint,int,bigint的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
每种编程语言都有自己所定义的数据类型，mysql也不例外，平时我们在创建表时，需要根据业务要求，结合存储、索引、字段临界值等条件来为字段定制不一样的类型。下面我们一起学习下mysql的几种常用的数据类型。
Mysql中分为三大数据类型：数值型，字符型，时间日期型
整型
mysql中整数型数据类型就有五种：
tinyint，smallint，mediumint，int，bigint
tinyint：迷你整型，占用1个字节保存数据，能够表示256个数值 smallint：小整型，占用2个字节保存数据，能够表示65536个数值 mediumint：中整型，占用3个字节保存数据 int：标准整型，占用4个字节保存数据，42亿多 bigint：大整型，占用8个字节保存数据 为什么要有这么多整型？
能够最大效率的使用磁盘空间，做到最少浪费。根据实际业务分配内存空间来进行数据保存。
查询的效率变高。
如何在项目中选择使用何种整型？
根据业务需求，某一类数据的边界值，看边界值落在那个整型的范围，就是用最小的那个。
在实际操作中tinyint，int使用的较多
整型表案例 默认的，整型都是有符号类型
无符号：表示数值只能是正的，不能有负数
语法：在字段类型后面使用unsigned进行标识
age tinyint unsigned;//年龄是一个迷你整型，无符号表示（0-255） 显示宽度：占的位数，当某个数值没有达到显示宽度的时候，在数值的左边使用0来补足显示宽度（不能改变数值本身大小）
默认的，系统不会进行0填充，需要给字段显示的增加一个属性：zerofill，0填充
系统默认显示的宽度是数据类型能够显示的最大宽度。
0填充有一个特点：使用0填充的字段必须为无符号类型，不能为负数进行0填充
00填充是专门用来配合显示宽度：显示宽度只是在数据的值没有达到指定宽度的时候使用0填充，0填充或者显示宽度都不会限制原来值的大小，值的大小由数据类型决定。
什么地方会使用显示宽度？
在一些需要使用0填充地方不改变原来值的大小，却能够用宽度来固定显示数据，保证前端数据的显示不会改变原来的css结构。比如说月份，日期，时间。
小数型
带有小数部分的数据。
mysql中小数型分为两种：浮点型，定点型
浮点型：float和double float：采用4个字节保存数据 double：采用八个字节保存数据 浮点数的存储使用4个字节32位存储，第一位叫做符号位，会使用符号位后面的8位用来存储街码（底数+指数），其他的用来表示数据。
浮点数会丢失精度
float：最大有效位7位左右
double：最大有效位为15位左右
浮点数的使用方式
float(M,D)：M表示整个长度，D表示小数位的长度 数据处理
浮点数只适用于那些对于数值精确要求不高，但是数量特别大的数据。
凡是跟钱相关绝对不用浮点数。
定点型：decimal
能够自动的扩展宽度来保存数据，保证数据的精度，基于小数部分，如果超出指定长度，仍然会进行四舍五入。
语法：decimal(M,D)：M表示总长度，D表示小数部分的长度 定点型与浮点型区别
定点型的数据范围
decimal(65,30)
默认的，如果不使用括号标识decimal的长度，那么默认的是decimal(10,0);
凡是涉及到钱的都会在数据库端使用decimal来进行数据的存储和运算。
字符串型
mysql有以下字符串类型：
char，varchar，text，blob，enum，set char
定长字符串，表示磁盘会分配固定长度的空间去存储数据
如果数据不够长度，空间依然被占用
如果数据超出长度，系统会报错
语法：char(L)，L表示长度，L表示的字符长度，L的最大值是255
varchar
变长字符串，表示磁盘空间会根据实际数据的长度来自动分配存储空间，但是长度不能超过指定长度varchar(L)，存储的数据只能小于或者等于L个字符，L的理论值是65535
varchar在存储之外还有一个额外的1到2个字节来保存当前varchar的实际占用长度
char和varchar对比(utf8) ：一个字符 = 3个字节
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91ef4e71a1650718c12d0e569cc8fc3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89d79c5699761bc9b89597d8739d1ce9/" rel="bookmark">
			UDAF案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收集30分钟之内的action_id，聚合为一个list
&lt;!-- maven配置文件 --&gt; &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;netease.bigdata.course&lt;/groupId&gt; &lt;artifactId&gt;etl&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;2.7.6&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!-- 编译时引用此jar包，但打包的执行程序不会包含 --&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.anarres.lzo&lt;/groupId&gt; &lt;artifactId&gt;lzo-hadoop&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hive&lt;/groupId&gt; &lt;artifactId&gt;hive-exec&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hive&lt;/groupId&gt; &lt;artifactId&gt;hive-contrib&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;sourceDirectory&gt;src/main/java&lt;/sourceDirectory&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89d79c5699761bc9b89597d8739d1ce9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c35b4e9832bb567b933fe1d3aabd4a9/" rel="bookmark">
			欧式距离计算公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欧式距离也称欧几里得距离，是最常见的距离度量，衡量的是多维空间中两个点之间的绝对距离。
也可以理解为：m维空间中两个点之间的真实距离，或者向量的自然长度（即该点到原点的距离）。在二维和三维空间中的欧氏距离就是两点之间的实际距离
下面是具体的计算公式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd1c261819a307b3e92281030fdfaed5/" rel="bookmark">
			驱动设备节点3ch修改命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3ch adb shell ls -lZ /dev/ |grep test_dev crw-rw---- 1 system system u:object_r:test_device:s0 10, 53 2018-01-10 03:20 test_dev
1.chmod adb shell chmod 660 /dev/test_dev crw-rw----
2.chown adb shell chown system:system /dev/test_dev system system 3.chcon adb shell chcon u:object_r:test_device:s0 /dev/test_dev u:object_r:test_device:s0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f2768644e32adb6ad8eb70b1aff6fbb/" rel="bookmark">
			RN https 双向认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 概述
Rreact Native https双向认证 Android端修改，有两种方案：
一是修改 facebook桥接Android的网络请求
二是自己新建桥接 android和rn，修改android的https请求。
这里用到了第一种方法。第二种方法，有空的话可以试一下，也是可以的。
要想做RN的桥接，首先要先把android原生的 https双向认证搞明白，请看我上篇文章：
https://blog.csdn.net/BingHongChaZuoAn/article/details/93591447
二、实战操作
服务器端和Android端配置 就不讲了，上篇文章已经讲过。
1.首先是 新建 HttpsReactPackage，修改网络为自己的NetworkingModule public class HttpsReactPackage extends MainReactPackage { private String TAG ="HttpsReactPackage"; @Override public List&lt;ModuleSpec&gt; getNativeModules(final ReactApplicationContext context) { List&lt;ModuleSpec&gt; retList = new ArrayList&lt;&gt;(); List&lt;ModuleSpec&gt; superList = super.getNativeModules(context); for (ModuleSpec moduleSpec:superList){ if (moduleSpec.getProvider().get() instanceof NetworkingModule){ continue; } retList.add(moduleSpec); } retList.add(new ModuleSpec(NetworkingModule.class, new Provider&lt;NativeModule&gt;() { @Override public NativeModule get() { return getTestNetWorkingMoudle(context); } })); return retList; } private NativeModule getTestNetWorkingMoudle(ReactApplicationContext context) { NetworkingModule networkingModule = new NetworkingModule(context); try { Field field = networkingModule.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f2768644e32adb6ad8eb70b1aff6fbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/786c32ce0d4fe1f912f6d0906c82647e/" rel="bookmark">
			linux 脚本文件，后台运行jar包并输出日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/bin/bash #chkconfig: 345 90 10 #description: Starts and stops the shaungluJava daemon. ######################################################################## # Purpose: Start shaungluJava manually # ######################################################################## . ~/.bash_profile ISA_BASE_HOME=/isearch/ JAR_LIB="${ISA_BASE_HOME}/shuanglu" #LOG_BASE="${ISA_BASE_HOME}/shuanglu/log/log.out" LOG_BASE1="${ISA_BASE_HOME}/shuanglu/log/log-$(date +%Y-%m-%d).out" export JAR_LIB #CLASSPATH="${CLASSPATH}":"${JAR_LIB}/solrstart.jar" #export CLASSPATH # Set standard commands for invoking Java. #RUNJAVA=" java -Xms256m -Xmx1024m -jar /usr/local/solr/solrstart.jar" RUNJAVA="nohup java -jar /isearch/shuanglu/run.war" # Set language environment LANG=zh_CN.gb2312 export LANG LC_ALL=zh_CN.gb2312 export LC_ALL usage() { echo "Usage: ./shuanglu.sh start | stop | status" } para=$1 start_app() { #echo Use CLASSPATH: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/786c32ce0d4fe1f912f6d0906c82647e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8778629a1b34ccce3fff9010dab2b3f6/" rel="bookmark">
			一张图了解大牛直播SDK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：https://github.com/daniulive/SmarterStreaming
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83efce40b9e8d6e0fa9fc2ba177c4640/" rel="bookmark">
			Python模块学习：struct模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python strtuct模块主要在Python中的值于C语言结构之间的转换。可用于处理存储在文件或网络连接（或其它来源）中的二进制数据。
import struct ''' 数据格式 名字 职业 年 muyu coder 2018 ''' name = b'muyu' job = b'coder' year = 2018 file = open(r'test.bin', 'wb+') file.write(struct.pack('4s5si', name, job, year)) file.flush() file.seek(0) strBin = file.read() print(strBin) # b'muyucoder\x00\x00\x00\xe2\x07\x00\x00' content = struct.unpack('4s5si', strBin) print(content) # (b'muyu', b'coder', 2018) ，以二进制格式打开一个文件，以指定格式写入一个二进制串，再从文件取出二进制串，再把取出的串翻译成python数据
import struct import binascii values = (1, 'ab'.encode('utf-8'), 2.7) s = struct.Struct('I 2s f') packed_data = s.pack(*values) print('Original values:', values) print('Format string :', s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83efce40b9e8d6e0fa9fc2ba177c4640/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fd552a63368770061a37a805195bda3/" rel="bookmark">
			windows环境搭建之jmeter&#43;influxdb&#43;grafana
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此时安装目的在此不多说，都找过来了，肯定是有了解过的
此次安装，是基于windows7版本
照着我的步骤安装，一把过的几率是99.99%，所以在此就不对各类异常的解决方案进行举例了
1.jmeter和influxdb和grafanas的下载
已上传至云盘
链接：https://pan.baidu.com/s/18fJ0UbPoygXI73WQybEjfA 提取码：917i
直接解压到相应目录就行，无需安装
2.Influxdb配置文件的修改
找到influxdb.conf这个文件并进行修改，改后文件已上传至云盘，链接不变，大家记得改一下文件路径即可
目录结构最好和我一样，毕竟为了一把过嘛
3.Influxdb服务器的启动
为了避免待会grafana不显示数据，最好是在cmd执行influxd -config influxdb.conf来运行Influxdb
此时，Influxdb数据库服务器已经正常运行
4.Influxdb的配置
首先另启一个CMD并输入influx来启动Influxdb的客户端（前提是数据库服务器是开启状态），
显示所有数据库： show databases
创建数据库：create database test
使用数据库：use test
显示所有表：show measurements
此时已经创建好了一个名为test的库
5.Grafana的配置
直接运行grafana-server.exe程序启动
进入http://localhost:3000，登录默认用户名和密码都是admin，配置好的数据源如下
可以完全对着填写，因为本人也是一知半解，先保证能用再说
然后就是配置仪表板，这个就相当于是视图的插件，我选择的插件在云盘，链接不变，也可以自行下载
如上图，导入json即可
6.jmeter的配置
正常配置一个接口，并且添加后端监听器，配置如下，记住要跟我配置的一样哦
执行接口并观察Grafana上的数据，如果没有数据显示，可以做以下操作
到此，基本就是大功告成，如果有其他问题请试着完全照着我的步骤去执行
至于Telegraf的安装，我没有去做配置，据我了解它是可有可无的东西，所以就这样把
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7678555339c7f5604b0b526311e795a/" rel="bookmark">
			MTK平台camera驱动架构分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MTK6580 AndroidO（android8.1）版本camera 驱动分析 首先说说2点：
1、Camera 的成像原理:
景物通过镜头(LENS)生成的光学图像投射到图像传感器(Sensor)表面上,然后转为模拟的电信号,经过 A/D(模数转换)转换后变为数字图像信号,再送到数字信号处理芯片(DSP)中加工处理,再通过 IO 接口传输到 CPU 中处理,通过 LCD 就可以看到图像了。
图像传感器(SENSOR)是一种半导体芯片,其表面包含有几十万到几百万的光电二极管。光电二极管受到光照射时,就会产生电荷。目前的 SENSOR 类型有两种:
CCD(Charge Couple Device),电荷耦合器件,它是目前高像素类 sensor 中比较成熟的成像器件,是以一行为单位的电流信号。
CMOS(Complementary Metal Oxide Semiconductor),互补金属氧化物半导体。CMOS的信号是以点为单位的电荷信号,更为敏感,速度也更快,更为省电。
ISP 的性能是决定影像流畅的关键,JPEG encoder 的性能也是关键指标之一。而 JPEG encoder 又分为硬件 JPEG 压缩方式,和软件 RGB 压缩方式。
DSP 控制芯片的作用是:将感光芯片获取的数据及时快速地传到 baseband 中并刷新感光芯片,因此控制芯片的好坏,直接决定画面品质(比如色彩饱和度、清晰度)与流畅度。
2、Camera 常见的数据输出格式:
常见的数据输出格式有:Rawdata 格式、YUV 格式、RGB 格式。
RGB 格式:采用这种编码方法,每种颜色都可用三个变量来表示红色、绿色以及蓝色的强度。每一个像素有三原色 R 红色、G 绿色、B 蓝色组成。
YUV 格式:其中“Y”表示明亮度(Luminance 或 Luma),就是灰阶值;而“U”和“V”表示色度(Chrominance 或 Chroma),是描述影像色彩及饱和度,用于指定像素的颜色。
RAW DATA 格式:是 CCD 或 CMOS 在将光信号转换为电信号时的电平高低的原始记录,单纯地将没有进行任何处理的图像数据,即摄像元件直接得到的电信号进行数字化处理而得到的。
支持 YUV/RGB 格式的模组,一般会在模组上集成 ISP(Image Single Processor),经过A/D 转换过的原始数据经过 ISP 处理生成 YUV 标准格式传到 BB。一般来说,这种设计适用于低像素 Camera 的要求,会在主板上省去一个 DSP,可降低成本。在调试过程中,YUV/RGB 格式的摄像头,其所有参数都可在 kernel 层通过寄存器来控制。调试一般由 sensor的原厂支持。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7678555339c7f5604b0b526311e795a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c45c51efdac128859ef37128dfff562/" rel="bookmark">
			EFCore 通过实体Model生成创建SQL Server数据库表脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们的项目中经常采用Model First这种方式先来设计数据库Model,然后通过Migration来生成数据库表结构，有些时候我们需要动态通过实体Model来创建数据库的表结构，特别是在创建像临时表这一类型的时候，我们直接通过代码来进行创建就可以了不用通过创建实体然后迁移这种方式来进行，其实原理也很简单就是通过便利当前Model然后获取每一个属性并以此来生成部分创建脚本，然后将这些创建的脚本拼接成一个完整的脚本到数据库中去执行就可以了，只不过这里有一些需要注意的地方，下面我们来通过代码来一步步分析怎么进行这些代码规范编写以及需要注意些什么问题。
一 代码分析
/// &lt;summary&gt; /// Model 生成数据库表脚本 /// &lt;/summary&gt; public class TableGenerator : ITableGenerator { private static Dictionary&lt;Type, string&gt; DataMapper { get { var dataMapper = new Dictionary&lt;Type, string&gt; { {typeof(int), "NUMBER(10) NOT NULL"}, {typeof(int?), "NUMBER(10)"}, {typeof(string), "VARCHAR2({0} CHAR)"}, {typeof(bool), "NUMBER(1)"}, {typeof(DateTime), "DATE"}, {typeof(DateTime?), "DATE"}, {typeof(float), "FLOAT"}, {typeof(float?), "FLOAT"}, {typeof(decimal), "DECIMAL(16,4)"}, {typeof(decimal?), "DECIMAL(16,4)"}, {typeof(Guid), "CHAR(36)"}, {typeof(Guid?), "CHAR(36)"} }; return dataMapper; } } private readonly List&lt;KeyValuePair&lt;string, PropertyInfo&gt;&gt; _fields = new List&lt;KeyValuePair&lt;string, PropertyInfo&gt;&gt;(); /// &lt;summary&gt; /// /// &lt;/summary&gt; private string _tableName; /// &lt;summary&gt; /// /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private string GetTableName(MemberInfo entityType) { if (_tableName !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c45c51efdac128859ef37128dfff562/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be78a981b33a92800b18b133f782e6da/" rel="bookmark">
			微信小程序侧边栏二级联动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现效果如下 实现步骤 样式布局(.wxml文件) &lt;scroll-view scroll-y="{{true}}" style="height:{{height}}px;" class="nav-right-menu"&gt; &lt;!-- 一级菜单 --&gt; &lt;view class="nav-left-menu-list" wx:for="{{Menu}}" wx:for-index="idMenu" wx:key="id"&gt; &lt;view data-index="{{idMenu}}" class="nav-left-menu-text" bindtap="showmenu2" data-len="{{item.childLen}}"&gt; &lt;text&gt;{{item.txt}}&lt;/text&gt; &lt;/view&gt; &lt;!-- 二级菜单 --&gt; &lt;view class="nav-left-secondmenu" style="{{menuindex == idMenu ? menustyle : field}}"&gt; &lt;view class='nav-left-secondmenu-list' wx:for="{{item.twoMenu}}" wx:for-item="twoMenu" wx:key="id" bindtap="dosub" data-url="{{twoMenu.menupath}}"&gt; &lt;text class='nav-left-Secondmenu-text'&gt;{{twoMenu.name}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/scroll-view&gt; js文件 // pages/home/index.js var app = getApp(); var systeminfo = null; var currentMenuIndex = -1; Page({ /** * 页面的初始数据 */ data: { height: 0, Menu:[] }, showmenu2: function (event) {//显示2级菜单 var currentindex = event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be78a981b33a92800b18b133f782e6da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ac768b1c6aeb2e960c75f501bb46ef2/" rel="bookmark">
			Error in v-on handler: &#34;ReferenceError: Vue is not defined&#34;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码没有引入 Vue模块
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43c3b56ffbd219b5fb079c05c754d549/" rel="bookmark">
			Error: Flutter plugin not installed; this adds Flutter specific functionality. - Flutter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 Flutter 的时候在 Android Studio IED 处遇到了一些小的插件缺失问题，具体异常提示如下：
[!] Android Studio (version 3.4) ✗ Flutter plugin not installed; this adds Flutter specific functionality. ✗ Dart plugin not installed; this adds Dart specific functionality. 解决办法： 首先，打开 Android Studio 的 IDE 主界面，点击配置 Configure 选项，选择 Plugins 子选项；
其次，搜索如下图中的两个配置（即：Dart 和 Flutter），若搜索出的结果为未安装状态则进行安装操作即可；
最后，安装完成如上 Dart 和 Flutter 插件后，再次终端执行 flutter doctor 校验其状态即可。
以上便是此次内容的分享，希望能对大家有所帮助，也在慢慢初探 Flutter 中哈。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2b281c9730c3adcb7c8998e67d66033/" rel="bookmark">
			神经网络量化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 神经网络在图像、语音识别等领域使用越来越广泛，大部分实时性要求不高的服务都可以部署在云上，然而还是有不少模型需要在计算能力有限的可移动设备上快速运行，如人脸解锁、拍照视频的实时处理等。
一般训练的模型采用的都是32位浮点数，考虑到大部分的模型都具有比较强的抗噪能力，即即使输入受到了一定的干扰，最后预测出正确的结果，所以在手机等智能设备上，可以通过适当降低精度而基本影响结果的正确率，来达到加速计算或降低功耗的目的，例如GPU可以使用half计算、DSP上可以使用int8计算。
最近刚好了解了一下tensorflow和nnlib的一些量化的实现，踩过一些坑，在此总结和分享一下。
正文 什么是量化 引用百度百科上的一句话：
在数字信号处理领域，量化指将信号的连续取值（或者大量可能的离散取值）近似为有限多个（或较少的）离散值的过程。
对神经网络的量化，也就是将神经网络中大部分op的浮点权重值转换为定点整数表示，同时将op替换成可以执行类似的定点整数运算的op。于是网络中大部分的浮点运算，都能使用定点整数计算替代。
为什么要量化 提高计算速度&amp;降低功耗。将32位浮点数计算转换成8位定点计算，在一些支持SIMD的平台上能大大提速，例如高通的DSP支持一条指令同时计算128字节的向量。
减少存储消耗。将神经网络每层的32位浮点数权重，转换为8位定点+最小最大值的存储方式，模型的大小能减少为原来的约25%。
神经网络量化的实现 神经网络对量化的实现需要把常见操作（卷积，矩阵乘法，激活函数，池化，拼接等）转换为等价的8位整数版本的操作，然后在操作的前后分别加上quantize和dequantize操作，quantize操作将input从浮点数转换成8 位整数，dequantize操作把output从8 位整数转回浮点数。以Relu为例： 经过转换后，新的子图如下：
连续的dequantize和quantize操作可以互相抵消，如图所示： 量化操作的实现 量化操作需要将一组float输入转换成uint8（0~255），最直观的想法就是先求出这组输入的最小值min和最大值max，然后对每个输入数据可以用
q = (x - min) / (max - min) * 255 求出其量化值。反之，也可以用
x = q * (max - min) / 255 + min 实现反量化操作。
量化后引入的量化误差为(max - min)/255.
量化过程这里有一个坑，那就是真实值0.0的量化误差，一般来说需要保证输入0.0值被精确地量化成一个整数qzero表示，如果量化值qzero所表示的值和真实值0.0之间有一定误差，那么对一些操作会有比较大的影响，比如卷积或者pooling层做padding时需要在边缘补0，Relu层需要截断小于0的输入。
关于量化操作，tensorflow和nnlib的策略不太一样。
tensorflow：
分有符号输入和无符号输入两种情况。 有符号输入：调整min和max，max=MAX(-min, max), min = -max, 这样可以使得范围是对称的，[min, max]被量化至[-127, 127]无符号输入：令min=0，然后将[0, max]量化至[0, 255] 以上两种情况下，都能保证输入的0.0值能刚好被量化成0.
nnlib：
不区分是否为有符号，统一量化到0~255。下面这部分源码是为了调整min和max的值，使得0.0被量化后的误差小于2^-14. static inline void quantize_adjust_range(float *out_min, float *out_max, float *out_stepsize, float *out_recip_stepsize, float in_min, float in_max) { // 确保0被包含在[min, max] float minval = fminf(0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2b281c9730c3adcb7c8998e67d66033/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e089b4a8a7bc92567979e8eb6009a49/" rel="bookmark">
			十二色相环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本学期秉持着提升自己作品颜值的心态选了一门名为“色彩原理与应用”的公选课。然而其实这门课体验并不是很好，老师从光的波动性讲起（？？），然后是色标系统，眼睛的构造和视锥细胞视杆细胞各自的结构和作用（？？？？），人对颜色的感知现象以及色盲的原理（？？？）。后来终于进入正题后也总是感觉仿佛学完这门课设计一个有感觉的网站是不现实的，画出一个颜色分明层次清晰赏心悦目的地图倒是有可能的。当初看到这门课是印刷与包装系老师开的课时就应该意识到这点的。
但是这门课还是有些我觉得应该把它记住的东西，比如下面的将要介绍的神奇工具——十二色相环。
基本知识 在介绍十二色相环之前，先介绍一些色彩学基本知识，包括色光三原色，色相三原色，加色法原理和减色法原理。（不想看基本知识的可以直接跳过这部分） 加色法混色——由色光辐射能量的各光谱组成混合得到的结果。把不同颜色的光的混合称之为色光混合。
减色法混色——混合色为一种或几种染料（颜料）分别吸收掉相应光谱成分后，改变了原来光谱分布所引起的颜色感觉 。把颜料、染料、油漆、油墨、涂料等的混合称之为色料混合。
如果选择红、绿、蓝三种色光以不同比例进行混合，几乎可以得到自然界中所有的色彩，我们可以称该红、绿、蓝三种颜色为色光三原色。
色光加色法特点：
◇色光的相加(混合)，所获得的第三种色光其亮度增加。故称色光混合为加色法混合。
◇三原色光中的任何一种色光都不能由其它两种原色光混合得到。
色光加色表达：
红光+绿光=黄光（R+G=Y）
红光+蓝光=品红光（R+B=M）
绿光+蓝光=青光（G+B=C）
红光+绿光+蓝光=白光（R+G+B=W）
如果选择黄色、品红色和青色这三种色料两者混合或三者混合可以得到几乎所有的颜色，所以把黄（Y）、品红（M）、青（C）这三种颜色叫做色料三原色。
合光中减去一种或几种单色光而得到另一种色光的效果，称为色料减色法。
色料减色法特点：
◇两个颜色互为补色的色料混合时，适当调整比例可以得到黑色料。
◇色料的混合过程同时也是一个混合色料亮度降低的过程。
◇三原色料中的任何一种色料都不能由其它两种三原色料混合得到。
色料减色法表达（这些公式请参照下方的十二色相环进行理解）
如果三原色两者之间或三者之间等量混合，则有：
M+Y=R 白光—绿光—蓝光 = 红光
M+C=B 白光—绿光—红光 = 蓝光
Y +C=G 白光—蓝光—红光 = 绿光
M+Y+C=K 白光—绿光—蓝光—红光= 黑
两种原色等量混合，最后呈色效果是两次减色的结果。三原色等量混合得到黑色。
因为 R=M+Y M+Y+C = K
B= M+C M+Y+C = K
G= Y+C M+Y+C = K
等式左右两边相加得：
R+C=K
B+Y=K
G+M=K
顺便一提，我们在PS中常用的RGB和CMYK这两个概念。RGB配色即是基于色光加色法，它是我们设计时采用的配色模式。CMYK是基于色料减色法，我们设计的作品终究要付之于印刷，而印刷是使用各种色料进行的，所以必须用色料减色法作为配色模式。那么我们能不能在设计时就采用CMYK呢？这样做往往是会出问题的，因为电脑显示屏作为发出光的设备本质上是色光加色法的原理。
大一学习PS时学长学姐就特别强调用PS做图最后印刷前一定要把色彩模式从RGB换成CMYK，今天终于知道了原因。
十二色相环 色相环是指一种圆形排列的色相光谱 ，色彩是按照光谱在自然中出现的顺序来排列的。
在十二色相环中，色光三原色红、绿、蓝两两相差 120 度，而色料三原色黄、青、品红分别位于红与绿、绿与蓝、蓝与红的正中间。除此之外，色相环上还具有橙、黄绿、青绿、靛、紫、紫红，共计十二种颜色，故称十二色相环。
在十二色相环上，红色是色相环的暖极，距离红色越远的颜色越具有冷的性质。青色是色相环的冷极，距离青色越远的颜色越具有暖的性质。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e089b4a8a7bc92567979e8eb6009a49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59dece4541d9cf7e324aec5c8110bab6/" rel="bookmark">
			软件架构设计的七大原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、开闭原则 开闭原则（Open-Closed Principle, OCP）是指一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。所谓的开闭，也正是对扩展和修改两个行为的一个原则。强调的是用抽象构建框架，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开
闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统，例如：我们版本更新，我尽可能不修改源代码，但是可以增加新功能。
在现实生活中对于开闭原则也有体现。比如，很多互联网公司都实行弹性制作息时间，规定每天工作 8 小时。意思就是说，对于每天工作 8 小时这个规定是关闭的，但是你什么时候来，什么时候走是开放的。早来早走，晚来晚走。
实现开闭原则的核心思想就是面向抽象编程，接下来我们来看一段代码：
首先创建一个课程接口 ICourse：
整个课程生态有 Java 架构、大数据、人工智能、前端、软件测试等，我们来创建一个 Java架构课程的类 JavaCourse：
现在我们要给 Java 架构课程做活动，价格优惠。如果修改 JavaCourse 中的 getPrice()方法，则会存在一定的风险，可能影响其他地方的调用结果。我们如何在不修改原有代码前提前下，实现价格优惠这个功能呢？现在，我们再写一个处理优惠逻辑的类，
JavaDiscountCourse 类 （ 思 考 一 下 为 什 么 要 叫 JavaDiscountCourse ， 而 不 叫DiscountCourse）：
回顾一下，简单一下类结构图：
2、依赖倒置原则 依赖倒置原则（Dependence Inversion Principle,DIP）是指设计代码结构时，高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并能够降低修改程序所造成的风险。接下来看一个案例，还是以课程为例，先来创建一个类 Tom：
来调用一下：
Tom 热爱学习，目前正在学习 Java 课程和 Python 课程。大家都知道，学习也是会上瘾的。随着学习兴趣的暴涨，现在 Tom 还想学习 AI 人工智能的课程。这个时候，业务扩展，我们的代码要从底层到高层（调用层）一次修改代码。在 Tom 类中增加studyAICourse()的方法，在高层也要追加调用。如此一来，系统发布以后，实际上是非常不稳定的，在修改代码的同时也会带来意想不到的风险。接下来我们优化代码，创建一个课程的抽象 ICourse 接口：
然后写 JavaCourse 类：
再实现 PythonCourse 类：
修改 Tom 类：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59dece4541d9cf7e324aec5c8110bab6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6699f72cd11e386bd1e83a64b725482/" rel="bookmark">
			Vue初步认识，前端发展历史
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html html [1990]----&gt; html5 [2008.1.12]
css css 1.0 1996
css 2.0 1998
css 3.0 2001
EcmaScript 1997年诞生
2015 EcmaScript 2015
2016 EcmaScript 2016 dart语言 vs javascript （JavaScript胜出）
MV*架构思想发展史 随着前端项目的逻辑越来越复杂和难以维护，那么前端这边引进了后端的架构思想（ MV* ）
M Model 数据层
V View 视图层
VM ViewModel 视图模型（ 业务逻辑 VM 是 由 P 改名得来的）
P Presenter 提出者（ Controller 改名得来的 ）
C Controller 控制器 ( 业务逻辑 )
框架架构思想时间Backbone.jsMVP2010.10Angular.js( 1.0 )MVC2010.10Angular.ts ( 2.0 )MVC -&gt; MVVM2016 目前已经更新到了 Angular7 ( 也属于angular2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6699f72cd11e386bd1e83a64b725482/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e80fdd1547a9c6fb61312ffc526cd126/" rel="bookmark">
			【代码复用】File与byte[]转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		File转换为byte[]，下面是给出File的路径参数：
public static byte[] getBytesByFile(String filePath) { try { File file=new File(filePath); //获取输入流 FileInputStream fis = new FileInputStream(file); //新的 byte 数组输出流，缓冲区容量1024byte ByteArrayOutputStream bos = new ByteArrayOutputStream(1024); //缓存 byte[] b = new byte[1024]; int n; while ((n = fis.read(b)) != -1) { bos.write(b, 0, n); } fis.close(); //改变为byte[] byte[] data = bos.toByteArray(); // bos.close(); return data; } catch (Exception e) { e.printStackTrace(); } return null; } byte[]转换为File，输入参数：文件byte[]，文件转换后的路径（不含文件名.格式），文件名称（包括格式）
public static void getFileByBytes(byte[] bytes, String filePath, String fileName) { BufferedOutputStream bos = null; FileOutputStream fos = null; File file = null; try { File dir = new File(filePath); // 判断文件目录是否存在 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e80fdd1547a9c6fb61312ffc526cd126/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71df3a68f978d9d28112faf11aecb65f/" rel="bookmark">
			二分网络上的电影推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 每个用户都有自己的喜好，会给一个电影进行打分，且每个用户的评判标准是不一样的。这里根据用户观看过的电影以及对电影的打分作为基础，为其推荐其没看过但与其看过的高分电影相似度高的电影。
实验数据 MovieLens 是历史最悠久的推荐系统。它由美国 Minnesota 大学计算机科学与工程学院的 GroupLens 项目组创办，是一个非商业性质的、以研究为目的的实验性站点。MovieLens 主要使用 Collaborative Filtering 和 Association Rules 相结合的技术，向用户推荐他们感兴趣的电影。
https://grouplens.org/datasets/movielens/
数据集：ml-latest-small.zip中包括700个用户对9000部电影的100000条评价。
主要步骤 采用二分网络模型，对ml-1m文件夹中的“用户—电影”打分数据进行建模；
用户对自己看过的电影打分1-5分，其中1分表示最不喜欢，5分表示最喜欢。假设分数大于3分的，表示用户喜欢这部电影。
计算资源配额矩阵；
计算资源配额矩阵W中的元素wij表示产品j愿意分配给产品i的资源配额。假设一个用户选择过的商品j都有向该用户推荐其他产品i的能力。
kj表示产品j的度（被多少用户评价过），kl表示用户l的度（用户选择过多少产品）。
对给定用户，按照其喜欢程度，对电影进行排名，进行电影推荐；
目标用户的资源分配矢量f。初始时，将他选择过的电影对应项资源设置为1，其他为0，得到初始n维0/1向量。则最终的资源分配矢量:
将用户所有没看过的电影按照 中对应项的得分进行排序，推荐排序靠前的电影给该用户。
算法预测准确性预测；
将二部图中的边随机分为两部分，期中90%归为训练集，10%归为测试集。
对给定用户i，假设其有Li个产品是未选择的，如果在测试集中用户i选择的电影j，而电影j依据向量 被排在第Rij位，则计算其相对位置：
越精确的算法，给出的rij越小。对所有用户的rij求平均值 来量化评价算法的精确度。
具体实现代码：https://github.com/BlackJocker1995/rating_analysis
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c67ef3f06cdb00ee7321f9c549aa9a6f/" rel="bookmark">
			CPN:Cascaded Pyramid Network for Multi-Person Pose Estimation_及CPN实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Cascaded Pyramid Network for Multi-Person Pose Estimation优点CPN两阶段网络：GlobalNet 和 RefineNet多人关键点估计1.人体边界框检测2. CPN 实验技巧实验结果 Cascaded Pyramid Network for Multi-Person Pose Estimation 论文链接
tf实现源码
pytorch实现源码
论文解决的任务场景为多人姿态估计.多人姿态估计所面临的挑战，关键点遮挡，关键点不可见，复杂背景等.提出的 Cascaded Pyramid Network (CPN) 方法，即着重于处理 “困难hard” 关键点.
优点 提出了一种金字塔型的串接模型，即CPN（cascaded pyramid network），这个模型能够同时兼顾人体关节点的局部信息以及全局信息，结果取得了不错的效果;
使用了在线难例挖掘（online hard keypoints mining）的技术，这对于人体姿态估计任务中一些存在遮挡的“hard”的关键点的预测有所帮助；
测试阶段考量了soft-NMS和传统的hard-NMS（非极大值抑制）在human detection阶段产生的影响，结论是soft-NMS对于最后的结果是有所帮助的。
CPN两阶段网络：GlobalNet 和 RefineNet CPN 包括两阶段网络：GlobalNet 和 RefineNet
[1] - GlobalNet - 特征金字塔网络(feature pyramid network)，用于定位估计 “简单simple” 关键点，比如，eyes 和 hands；但难以精确识别遮挡或不可见的关键点.
[2] - RefineNet - 通过将 GlobalNet 得到的所有层次的特征表示整合一起，并结合在线困难关键点挖掘loss(online hard keypoint mining loss)，定位检测 “困难hard” 关键点.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c67ef3f06cdb00ee7321f9c549aa9a6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f102a6dc38506822c0798ecc9f29521/" rel="bookmark">
			软件构造Lab2实验要求总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem 1: Test Graph 现在只测试string类型的顶点，之后会测试更多的类型（泛型）。
在GraphStaticTest.java中写static Graph.empty()的测试策略和测试方法，由于这种方法是静态的，所以它只需要一次实现。而且测试用例已经提供了，可以不用改。
在GraphInstanceTest.java写所有的为instance methods（实例方法）实现的测试策略以及测试，在这些测试中，只能使用emptyInstance()方法来获得一个空图，就像testInitialVerticesEmpty()中写的那样。
GraphStaticTest和其他的junit test一样，但GraphInstanceTest不同，它是一个抽象类，而且你不能直接运行它，需要首先实现emptyInstance()方法，而在下一个问题中，会有GraphInstanceTest方法的两个子类，返回不同的空图。
在GraphInstanceTest中实现的test必须满足Graph的说明书，任何对应于相应实现的测试，在下一个问题中，都会进入GraphInstanceTest方法的两个子类。
Problem 2: Implement Graph 两次实现以string为顶点的带权有向图 ，对于每一个类，都要写AF, RI, how the type prevents rep exposure；同时实现checkRep来检查RI；实现toString，以人类可读的方式展示抽象变量。
今后的编程中，你写的每一个不可变类型，都应该重写equals和hashcode，以实现对象之间的契约，但是在这个问题中不要求。
每一个类都必须有清晰的类型说明书，这意味着每一个方法都有一个javadoc文档，除了当你用@override时，什么时候用@override呢：
当一个方法在接口中说明了，然后你在一个具体的类中实现了它，这个时候就用@override，不用再加说明。
ConcreteEdgesGraph和ConcreteVerticesGraph之间不应该有任何依赖关系和代码共享。
在ConcreteEdgesGraph中，必须使用
private final Set vertices = new HashSet&lt;&gt;();
private final List edges = new ArrayList&lt;&gt;();
不能加域，也不能减域。
在edge类中，需要定义specification 和 representation，同时，edge必须是不可变的。
一般来说，实现不可变类型意味着实现equals和hashcode，但在这个问题中不要求，当心！这意味着你不能用equals方法来比较edge的实例化对象，如果你需要比较edge的实例化对象的话，自己实现一个observer方法并对其进行说明。
在完成说明之后，在Concrete¬EdgesGraphTest.java中设计、写文档并实现对Edge的test。
然后紧接着实现Edge 和 ConcreteEdgesGraph，要保证在toString方法中使用@Override，应该对ConcreteEdgesGraph中的toString()方法实现更强的说明并且在Concrete¬EdgesGraphTest.java中对该方法实现测试，只能在Concrete-EdgesGraphTest.java中，不能在GraphInstanceTest中，GraphInstanceTest是用来测试Graph的。
Implement ConcreteVerticesGraph
必须使用如下表示（REP）：
private final List vertices = new ArrayList&lt;&gt;();不能在该REP中加其他的域，对于Vertex类，自己定义说明和REP，Vertex必须是可变的。
在决定了Vertex类的说明后，在Concrete¬VerticesGraphTest.java中设计、说明并实现对Vertex的test。
然后紧接着实现Vertex和ConcreteVerticesGraph。
你应该加强ConcreteVerticesGraph.toString()的说明，然后在Concrete-VerticesGraphTest中写它的测试，不要把测试写在GraphInstanceTest中，GraphInstanceTest是用来测试Graph的。
Problem 3: Implement generic Graph 说明只要求顶点是”不可变的”以及“用equals方法来比较”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f102a6dc38506822c0798ecc9f29521/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4208aa76840aa4a366aa6af38ae1a37c/" rel="bookmark">
			镭速——FTP服务器概念详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 FTP服务器，全称File Transfer Protocol Server，是在互联网上提供文件存储和访问服务的计算机，它们依照FTP协议提供服务。FTP，文件传输协议（File Transfer Protocol）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式。FTP是专门用来传输文件的协议。
FTP是一个客户机/服务器系统，用户通过使用一个支持FTP协议的客户端，连接到远程主机上的服务器程序上。用户在客户端发出命令，远程主机服务器接收到命令后执行用户所发出的命令，同时将执行结果返回到客户端。简单来说，就是用户对服务器发出一条命令，要求服务器向用户发送一份文件，服务器响应并发送文件到客户端，用户收到文件将其放置于用户工作目录中，这一过程就是FTP服务器进行的文件交流。
FTP服务器工作原理
FTP基于TCP协议服务，是互联网中进行文件传输的协议，默认使用20、21号两个端口，一个数据端口和一个命令端口，端口20是数据端口，用于文件在客户端和服务器之间传输数据流。端口21是命令端口，用于传输控制流，接受客户端发出的相关FTP命令与参数。
如图中FTP服务的工作原理所示。FTP客户端在计算机网络中向FTP服务器发送服务请求，FTP服务器接收与响应FTP客户机的请求，并向FTP客户机提供所需的文件传输服务。根据TCP协议的规定，FTP服务器使用熟知端口号20、21来提供服务，FTP客户机使用临时端口号来发送请求。FTP协议为控制连接与数据连接规定不同的熟知端口号，为控制连接规定的熟知端口号是21，为数据连接规定的熟知端口号为20。FTP协议采用的是持续连接的通信方式，它所建立的控制连接的维持时间通常较长。
讲完FTP的工作原理的主要连接方式，接着讲解FTP工作原理中两种数据连接的建立类型：主动模式和被动模式。FTP的主动模式是指客户端从任意一个非特权端口连接FTP服务器的熟知端口，即端口21。FTP服务器在收到命令后从数据端口连接客户端又一临时端口，返回数据；被动模式是指客户端开启两个任意非特权端口提交命令，FTP服务器被动开启任意非特权端口发送命令给客户端，客户端接收命令后从本地端口向FTP服务器发起建立连接的传送数据通道，在这一模式内，命令连接和数据连接都由客户端发起，解决服务器发起到客户的连接的问题。
通俗来讲，我们如果把服务端作为判断标准。
主动模式：服务端从20端口主动向客户端发起连接。
被动模式：服务端在指定范围内的某个端口被动等待客户端发起连接。
FTP的实现目标
实现文件数据安全共享，即计算机客户端通过FTP客户端和互联网能连接到世界各地的FTP服务器，实现文件数据共享及资源共享。实现信息交互户，即其他计算机客户端能通过互联网访问你的计算机上面搭建的FTP服务器，使你的信息资料能够传播到世界各地。进行有效的数据传输。不同类型、不同系统、不同格式的电脑之间能够互换文件。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f55456df823dd3ba7bb0f4d51084d89/" rel="bookmark">
			强制让chrome使用HTTP而不是HTTPS访问的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发时遇到一些特殊情况必须使用http而不能使用https尽进行请求，但是请求总是https。查找资料知，请求为https的存在两种情况：
浏览器默认开启了http转https请求，典型代表chrome，现在新版的firefox也这样了。我们能处理的只有这种。服务器自己开启了https重定向，这个光靠自己没办法解决需要联系运维 查找资料知，在chrome可以尝试使用chrome://net-internals/#hsts中delete domain security policies后进行http访问，
但是测试发现，这种方式只能该概率性解决问题，查找资料知，删除域安全策略之后，必须清除缓存信息，
而且这种方式起到只能临时解决的方式，如果所访问的域中包含了需要用https访问的静态资源(img/css/js)，那么这个域又会自动变回https
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0884bdd20d55575f17b5324592e9f6f2/" rel="bookmark">
			【WIN10】关闭/开启休眠功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如何删除系统盘下hiberfil.sys文件？
系统版本 win10 专业版64位
步骤 1、在搜索中输入cmd，右击图标以管理员身份运行。
2、在命令行输入以下命令。
关闭休眠功能
powercfg -h off 开启休眠功能
powercfg -h on 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad5d90f555a7bfda4305ee26e7e47c6f/" rel="bookmark">
			Docker 启动镜像的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、docker run启动 --env-file 表示从文件加载环境变量，文件格式为key=value每行一个变量
-v 表示将宿主机上的文件挂载到镜像中，冒号前面表示宿主机文件路径，后面表示镜像文件路径，都要用绝对路径
-p 表示将镜像中的8080端口映射到宿主机上的8083端口，10.142.8.12代表宿主机ip
-it 表示以交互式终端运行，-d表示后台运行。
docker run -it --env-file ./run/hrms.env -v /opt/hrms/hrms/hrms:/opt/hrms/hrms -p 10.142.8.12:8083:8080 55ad68601db 二、docker-compose启动 docker-compose是docker三剑客之一，用来专门编排和管理镜像的插件，可以通过pip install docker-compose安装。
可以新建一个如下目录结构的文件夹，作为镜像的启动文件夹：
编写docker-compose.yml文件：
version: '2.0' services: web: image: hrms:v1.2 restart: always ports: - "8083:8080" env_file: - ./hrms.env volumes: - /opt/hrms/logs/:/opt/hrms/logs/ 启动：
切换到docker-compose.yml所在目录下执行：
docker-compose up即可启动镜像
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26c6f4c2a78f58fed5c528f91f2532f0/" rel="bookmark">
			1 Project Overview  1.1 Project Description  Based on tensorflow and Flask, a web-based image sea...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.项目介绍
在本项目中，我们实现了对人脸图片数据的三种处理：人脸互换（face swap）、人脸融合（face morph）以及基于特征向量的人脸处理（eigen face）。
1.1 人脸互换（face swap）
人脸互换部分主要实现的功能是，给定任意两张人脸图片，通过一系列操作，使两个人的脸部交换，这部分需要的问题有：
不同的人的脸部结构千差万别，同一个人也会因为角度、面部表情的不同而导致差别，即如何实现不同图片的人脸对齐
不同人脸的肤色、光照不同，即不同图片的面部亮度不同，在换脸后如何与整体亮度统一
不同人脸的纹理不同，比如老人的皱纹等，如何实现换脸后纹理的统一
​
参考文档和完整的文档和源码下载地址： https://www.write-bug.com/article/2518.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d45715338b33677e700d2a386f47c31/" rel="bookmark">
			【android免root脚本制作】基于控件的操作——auto.js进阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在【android免root脚本制作】自动坐标操作手机——京东金融程序金果摇钱树自动收金果 之后，想要做进一步优化，因为基于坐标点击如何屏幕被移动之类就会点击错位，不同手机还需去适配坐标，甚是麻烦，所以改个改为基于控件操作。
基于控件的操作是一种稳定高效准确，适配效果强的操作功能，不同于按键精灵等其他软件，基于控件的操作可以说是Auto.js独特的功能。这个功能可以帮我们更高效的做出模拟操作行为或者获取当前页面的信息等。这也是要做一个强大的模拟操作脚本必备的功能，所有安卓机型，安卓版本都适用，而且也无需root权限。
在正式进入脚本教程前，先给萌新们普及点概念：
（1）什么是控件？ 控件是指对数据和方法的封装。控件可以有自己的属性和方法，其中属性是控件数据的简单访问者，方法则是控件的一些简单而可见的功能、控件创建过程包括设计、开发、调试工作， 然后是控件的使用。 这样理解可能有点难，萌新可以理解为，控件就是页面上的一个个内容，比如说一个图片就是一个图片控件，一个输入框就是一个输入框控件等等，常见的控件有：TextView，EditText，Button，CheckBox，RadioButton，ImageView，ImageButton，ProgressBar等。然后这些控件有着一定的属性，我们可以通过他们的属性用脚本获取到他们，也可以通过控件类的函数对他进行一定的操作和获取信息等，比如直接通过控件对齐进行点击，设置输入框控件内的文字，获取某控件的位置等等。
（2）我们如何获取到控件信息 在auto.js软件中有直接获取到控件信息的功能，在auto.js软件主页面，点击右上角，打开侧拉菜单，大致中间位置的悬浮窗打开。这个auto.js的悬浮窗就含有获取控件信息的功能。点击悬浮窗我们可以看到有5个功能，中间蓝色的就是用于查看控件信息的功能，点击之后，会让你选择用布局范围分析和布局层次分析。
布局范围分析，使用该功能，可以直接看到当前页面上所有控件的边框即控件位置，这样可以清晰的了解各种控件的位置以及大小。但是这种方法也有缺点，就是比如有两个完全相同大小的控件重叠在一起就看不见了，这时候就要用到布局层次分析。 布局层次分析，即根据软件当前页面的源码布局层次进行观察，这样可以看到所有控件及其层次等。但是这样子对于比较复杂的布局很难进行观察，毕竟内容较多，距离远的话难以比较。所以在布局层次和布局范围中进行切换查看是比较好的获取控件信息的方法。 点击选择的控件即可查看控件信息，比较主要的控件信息有id即控件的id属性，text控件的文本属性，bounds控件的边框位置，desc控件的desc值，有些控件会把text控件放空，并把上面的文本写入desc值。clickable/longClickable控件是否可以点击/长按，如果控件的clickable为false那么点击也没用。checked控件是否选中，depth在第几层次，indexInParent在父控件中是第几个，在教程文档的选择器那一栏中有更多属性。这些信息对于以后写脚本都有很大的帮助。 生成代码，这个功能可以直接人性化的智能帮你选出如何对一个控件进行操作的代码，这个功能很好用，但是一般情况只会选择最简洁的代码，和我们需要实现的功能可能会稍有偏差，需要我们人为进行修改，但是大部分情况还是可以的。另外比较复杂的布局暂时可能会有获取失败的情况。所以不要太依赖于次功能，只要学会了以下内容，自动生成出来的那些代码，自己肯定都会写。
2.如何写控件操作脚本，控件操作的脚本编程思想是什么？ 我们要对一个控件进行操作，首先我们要让脚本识别的那个函数，在js的基于空间的操作中有三大类：控件选择器，控件合集，控件。这三个类都有各自的方法，要理解这个可能有点难，这里需要面向对象编程思想，有兴趣的，可以百度了解一下。在写这类脚本语句中，一般要多重调用的，比如：id("a").text("abc").findOne().click();可以看出一句话非常的长，这里的id()，text()，.findOne()，.click()分别都是上面那三个类中的函数，比如id()这个函数是控件选择器的函数，他们可以直接作为脚本开头（全局函数），他的返回值还是控件选择器，所以后面接的函数还是控件选择器的函数，text()这就也是一个控件选择器的函数，他的返回值还是控件选择器，所以后面继续接控件选择器的函数findOne()然后这个函数的返回值是控件，所以后面接控件的函数click()。 另外上面那句语句解释一下，就是选择id属性为a的，text属性为abc的控件，直到找到一个符合以上条件的控件，对其点击。 如果有连这个都无法理解的小白，我们伟大的开发者提供了一种非常简单易懂的理解方式。其实你们可以直接把自己需要找的控件的属性用选择器筛选出来，如果有多个那就用英文的点将其连接即可。 总结：我们写控件操作的代码时，不但·要实现需要实现的功能，还要注意返回值和之后使用的函数，以及如何切换来实现需要的功能。当然，如果你愿意去学一下面向对象编程思想当然是更好的啦。
3.控件选择器 控件选择器即含有对控件进行筛选的功能，比如大部分控件选择器都是用属性来筛选控件的，并且他们的返回值都是控件选择器，在这里，返回控件选择器本生是为了，方便以后进行，链式调用，也就是将很多要筛选的属性直接串联，最后再用findOne转换成控件。 我们来说几个常用控件选择器函数的使用方法。假如有desc属性为ab，abcd，abcde，cde，cd 那么我们用教程中的选择器desc()也就是匹配desc值为传入字符串的控件，比如desc("cd")这样子的话只会匹配出上面desc值为cd的一个控件，如果用descContains("cd")，desc属性包含传入的字符串的话，那就能匹配出desc值为abcd，abcde，cde，cd的控件，还有的descStartsWith()和descEndsWith()即为分别匹配以传入的字符串开头或者结尾的·desc值的控件，自己体会肯定能懂吧，除了这四种常用的，还有一个就是descMatches(正则表达式)，这个用于传入正则表达式，进行匹配，之后我会单独写一篇文章将正则表达式的匹配，这个在百度上也都有，应该来说是可以通过自己的尝试自学会的。几乎属性数据类型是字符串的控件都有着五个选择器函数进行选择，例如：text() , textContains() , textStartsWith() , textEndsWith() , textMatches() ， id() , idContains() , idStartsWith() , idEndsWith() , idMatches() ，还有className，package等就不一一举例了。 还有一些布尔值的属性的筛选器，就很简单了，比如说clickable属性的选择器函数clickable(要匹配的找值)，同样可可以作为全局函数，比如clickable(true)这个函数就可以筛选当前页面上所有可以点击的控件，同样的布尔值属性的选择器函数还有checkable()控件是否可以勾选，selected()控件是否已经勾选，longClickable()控件是否可以长按，另外还有enabled()控件是否已经启用，scrollable()控件是否可以滑动，editable()控件是否可以编辑，等等。这些功能都大同小异，教程和示例都有详细的使用方法。那我们要写一个选择器筛选当前页面上可以点击，长按的控件，就为clickable(true).longClickable(true)。这个应该能理解，那我们继续看一些稍微复杂咋一些的内容。 有的时候真的会碰到一些奇葩的软件，或者像QQ那种故意的，所有属性要么没有，要么都一样，这个时候可以用控件的边框位置来进行筛选，主要有两个比较常用的函数，bounds()和boundsInside()，我们要传入的变量就是控件的位置范围，由四个整数值组成前两个值为控件长方形左上角的坐标，后两个值是控件右下角点的坐标。简单举个例子，我们要筛选左上角坐标233,233到右下角坐标666,666内部的控件即为boundsInside(233,233,666,666)，这样在这个框内部的所有·控件会全部筛选出来，与他不同的一个边框选择器是直接的bounds()这个函数相对来说不算很常用，因为他的作用是匹配出边框是传入的四个值的控件，必须完全一样，在很多属性都一样的时候，这个功能非常的常用，因为bounds属性完全相同的控件就是完全重叠的那些，一般都只有一个，但是这个功能也有个很大的缺点那就是做适配功能很难，在·两个分辨率不同的手机上大部分控件的bounds是完全不一样的，只要不是非常外层的普通控件，等比缩放这类方法肯定是不可取的，主要还要观察控件的出现方式，就算写出来了，计算机结果完全相同，没有一点偏差也是几乎不可能的。所以这个功能一般用于特定分辨率，不需要适配的脚本中。 还有些没说的选择器函数一个是drawingOrder();这个控件用于筛选控件在其父控件中是否是第某个，另外他可以作为全局函数使用，如果使用drawingOrder(0)，筛选出所有在父控件中的第一个控件。当然最外层的布局也是第0个，并且从筛选触来的内容角度来说，最外层控件肯定在第一个·，那直接使用findOne()就可以直接获取到UI外层控件了。 最后要介绍的是 一个最强的万能选择器函数-过滤函数，他传入的内容是一个返回布尔值的匿名函数，函数的传入值是当前符合的所有控件。他会把会让函数返回值为false的内容全部过滤掉。我们直接用文档中的一个例子来对齐进行解释，假如我们要写的是过滤出text属性有10个字符的控件，他的代码是filter(function(w){return w.text().length==10})，我们知道function是新函数的意思，return在函数中即是函数的结束也是函数返回内容的代码，这个函数中先获取了控件w，即传入进来的控件的一个，的·text属性（即后面要讲的控件.text()，获取控件信息的函数）这个属性值是字符串，可以用length属性来获取到他的长度，然后用关系运算符 == （作用是比较左右两边内容是否相同，相同返回true，不同false）把他和我们要过滤出来的10进行比较，即他最后返回的布尔值数据类型。然后他会过滤出那些所有返回值为true，即符合的控件。 说了这么久，控件用于过滤选择器算是说完了。还有就是通过各种功能让控件选择器转换成控件或者控件合集，注意：现在开始说的函数都不能作为全局函数放在开头使用，最主要常见的函数就是findOne()了，他的作用是寻找屏幕上符合前面控件选择器的函数，直到出现，并返回第一个出现的控件，另外他还可以传入一个参数—最大查找时间，即位，如果到了时间还没有找到的话，直接返回undifined，以继续脚本。和他相似的还有一个函数是findOnce()，不同于之前那个函数，这个函数只会寻找一次，如果当前屏幕上没有，则直接返回null，他也可以传入一个参数，用于写，需要获取当前屏幕上第几个符合条件的内容，如果当前屏幕上的个数，不够获取的个数，则返回null。这两个函数是比较简单的函数，就先不举例子了。 还有find()函数会把选择器转换成合集，他的功能是在当前屏幕上搜索所有符合条件的控件并且都放入控件合集，一起返回，如果当前页面没有，那就会直接返回一个空的控件合集。和他有一个相似的函数untilFind()同样是返回控件合集，但是不同在于，他会循环寻找，至少要找到一个才会返回合集。也就是说不会返回空合集。 还有一些控件选择器函数，返回的是其他数据类型，例如函数 选择器.exists()，他返回的就是当前屏幕上是否存在符合条件的控件选择器。 甚至还有一些函数没有返回值，只有一些运行效果，比如 选择器.waitFor()，他会一直等待符合条件的控件出现。
4.控件 关于控件是什么上面已经介绍过了，这里我们一样来介绍几个控件的函数，首先是可以获取到控件信息的函数，最主要有text()，desc()，id()，当热其他所有属性也是行的，他们的返回值都是自己属性对应的类型。相同的还有classname，clickable，packagename等等，所有悬浮窗中有的属性都可以直接这样用函数获取到。另外还有childCount()用来返回这个控件有多少个子控件；drawingOrder()用语返回他他在父控件中的绘制顺序， 等比较少用的功能在app内文档中都有使用说明。 其次我们可以对控件做出操作，就是有操作效果的函数，比如函数click()就可以直接点击一个控件。注：如果clickable的值为false，那点击效果是没有用的，如果明明是个按钮控件，clickable值却是false那，一般，切换到布局层次可以看到有和他重叠的clickable值为true的控件。还有longClick()长按，setText()设置输入框内内容，等等。那我们来举个例子，我们要把id为edit的输入框控件内的文字改为123456，他的代码为id("edit").findOne().setText("123456"); 非常简单，自己理解吧。还有很多类似的例如选中，等函数，文档里都有使用方法，大同小异，这里就不一一介绍了。 还有一些可以用来找到与这个控件有关的控件的函数，比如他的父控件和他的子控件，我们知道安卓的控件是由控件多层嵌套出来的，所以控件可以含有他的子控件，也有他的父控件（最外层不算）。我们通过控件函数.parent()可以获得到这个函数的父控件函数，通过child(第几个)，获取到他的第几个子控件，注意序号从零开始。 还有个函数children()用于返回这个控件的所有子控件，另一个比较常用的函数findByText(str)需要传入一段文，这个函数返回他所有子控件或者孙控件中text或者desc属性中包含这段文字的所有控件。这时候细心的朋友肯定就能注意到，前面返回控件类，只有一个，是怎么返回多个的呢。这里涉及到一个新的类那就是控件集合。他的底层类似于一个控件数组，可以存放多个控件，也可以用上一章讲的中括号下标的方法来获取到其中第几个控件，也可以用控件合集里的get(下标)函数来获取，还有就是size()获取合集大小，即为里面有多少个控件，和数组的length属性相同。下面就来详细讲讲控件合集吧。
5.控件合集 首先它是一个类，继承上一章数组类，也就是有所有数组里的功能和属性。他自然也有自己的新函数，我们获取到一个控件合集后肯定是要对它做出操作的。上面对控件的操作，比如点击 长按 选中之类的功能，这里控件合集也能用，比如点击一个控件合集，他会自动按顺序点击控件合集里的每一个控件。内部有一个自动遍历数组的功能each(遍历函数) 里面传入一个函数，写对每个控件的操作，这个函数的参数是控件。这样不需要自己写循环来遍历方便了很多。 附注：其实控件选择器后面也可以直接根操作函数，功能会是直接对当前界面上所有符合选择器条件的控件进行该操作。运行时控件选择器会调用自己的find()函数在页面上找出符合条件的所有控件的合集，再用控件合集内的遍历并对每个控件进行操作。要是你确定你想要的控件已经出现在这个界面了，那么这样子写，代码会简洁很多咯。 如何·获取到一个控件合集。除了上面说的两种方法，还有可以通过控件选择器获得，之前说的选择器内的函数find()就可以返回调用这个函数的选择器，也就是前面的所有限定条件，全部符合的所有控件。这个控件合集中也有一个find(控件选择器)函数，但是和控件选择器中的不同。他需要传入一个控件选择器，然后返回这个控件合集中符合该控件选择器的所有控件及其子孙控件的合集。比如说我们要返回一个合集中所有控件和他们子孙控件，text属性是abc，desc属性是def的控件合集，那只要再那个合集后面接.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d45715338b33677e700d2a386f47c31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ae3fa712efbaf2489af90f1c94a117/" rel="bookmark">
			一文告诉你Spring是如何利用“三级缓存“巧妙解决Bean的循环依赖问题的【享学Spring】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每篇一句 你今天的优势会被明天的趋势所取代，所以务必好好学理论，一通则百通
前言 循环依赖：就是N个类循环(嵌套)引用。
通俗的讲就是N个Bean互相引用对方，最终形成闭环。用一副经典的图示可以表示成这样（A、B、C都代表对象，虚线代表引用关系）：
注意：其实可以N=1，也就是极限情况的循环依赖：自己依赖自己
另需注意：这里指的循环引用不是方法之间的循环调用，而是对象的相互依赖关系。（方法之间循环调用若有出口也是能够正常work的）
可以设想一下这个场景：如果在日常开发中我们用new对象的方式，若构造函数之间发生这种循环依赖的话，程序会在运行时一直循环调用最终导致内存溢出，示例代码如下：
public class Main { public static void main(String[] args) throws Exception { System.out.println(new A()); } } class A { public A() { new B(); } } class B { public B() { new A(); } } 运行报错：
Exception in thread "main" java.lang.StackOverflowError 这是一个典型的循环依赖问题。本文说一下Spring是如果巧妙的解决平时我们会遇到的三大循环依赖问题的~
Spring Bean的循环依赖 谈到Spring Bean的循环依赖，有的小伙伴可能比较陌生，毕竟开发过程中好像对循环依赖这个概念无感知。其实不然，你有这种错觉，权是因为你工作在Spring的襁褓中，从而让你“高枕无忧”~
我十分坚信，小伙伴们在平时业务开发中一定一定写过如下结构的代码：
@Service public class AServiceImpl implements AService { @Autowired private BService bService; ... } @Service public class BServiceImpl implements BService { @Autowired private AService aService; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59ae3fa712efbaf2489af90f1c94a117/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78e167b5943e7187cc3c6d997fef5386/" rel="bookmark">
			使用pandas删除整列为空值的列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一：
import pandas as pd # 循环删除空列 import pandas as pd detail = pd.read_excel('./meal_order_detail.xlsx', sep=',', encoding='gbk') print(detail) print(detail.shape) for i in detail.columns: if detail[i].count() == 0: detail.drop(labels=i, axis=1, inplace=True) print(detail) print(detail.shape) 方法二：
import pandas as pd # 进行统计非空为0 col = detail.count() == 0 # 返回bool数组 print(col) for i in range(len(col)): if col[i]: detail.drop(labels=col.index[i], axis=1, inplace=True) print(detail.shape) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd04f79c32a607825ebda10462eb168/" rel="bookmark">
			基础笔记2 —— 不损失精度的前提下浮点数拆分成整型的方法浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 说明数据在内存中的存储方式1.概念2.浮点数在内存中的存储方式 思路1：内存拷贝思路2：利用指针代码 说明 浮点数是不能进行位操作的，这就导致在进行数据拆分的时候非常麻烦。如果将其转换成整型，常用的办法是使用强制转换，虽然在原理上是利用不同的数据类型去读相同的二进制内容，但实际使用过程中往往会伴随着精度损失。
而且在一些控制场合，数据传输过程中需要将浮点数拆分成多个整型或者其他类型的数来进行传输，例如某控制器通过Modbus通信协议进行数据传输，但其寄存器只支持让你压short型的数据，你要在不损失精度的情况下，用2个short型数据去表示1个float型数据，我们应该怎么做呢？
数据在内存中的存储方式 1.概念 我们先来捋一遍概念，抛开编程语言来说，数据有8种基本类型：byte、short、int、long、float、double、bool、char，在进行拆分之前我们需要先了解一下各种数据类型的属性，以便能对数据进行正确的拆分。
byte
8位、有符号的以二进制补码表示的整数min : -128（-2^7）max: 127(2^7-1)default: 0 short
16位、有符号的以二进制补码表示的整数min : -32768（-2^15）max: 32767（2^15 - 1）default: 0 int
32位、有符号的以二进制补码表示的整数min : -2,147,483,648（-2^31）max: 2,147,483,647（2^31 - 1）default: 0 long
64位、有符号的以二进制补码表示的整数min : -9,223,372,036,854,775,808（-2^63）max: 9,223,372,036,854,775,807（2^63 -1）default: 0 float
单精度、32位、符合IEEE 754标准的浮点数float 在储存大型浮点数组的时候可节省内存空间浮点数不能用来表示精确的值，如货币default: 0.0f有效小数位 6位 double
双精度、64位、符合IEEE 754标准的浮点数浮点数的默认类型为double类型double类型同样不能表示精确的值，如货币default: 0.0d有效小数位 14位 char
char类型是一个单一的 16 位 Unicode 字符最小值是 \u0000（即为0）最大值是 \uffff（即为65,535）char 数据类型可以储存任何字符 bool
bool数据类型表示一位的信息只有两个取值：true 和 false这种类型只作为一种标志来记录 true/false 情况 对于其他概念，可以参考这篇博文1。
2.浮点数在内存中的存储方式 深入的研究请参考《IEEE754》标准。
一个浮点数在内存中由3部分来表达：符号位、底数m和指数e，值得注意的是它们都使用二进制来表示。
底数部分：使用２进制数来表示此浮点数的实际值。指数部分：占用８-bit的二进制数，可表示数值范围为0－255。 但是指数应可正可负，所以IEEE规定，此处算出的次方须减去127才是真正的指数。所以float的指数可从 -126到128.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfd04f79c32a607825ebda10462eb168/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3d2ba32e0edba895b8e157656157ab2/" rel="bookmark">
			使用casbin开发rbac模型的golang权限控制模块功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景交代
RBAC数据库表结构模型如下图：
很简单的一个数据库模型，系统资源表存储系统功能url及名称等信息，角色与用户是多对多，即一个用户可以有多种角色，角色与资源表多对多，即多个角色中每一种可操作的系统资源可以各不相同。
casbin
casbin有针对数据库的adapter，它自己也能读取数据库内容，但是没细研究是否需要建立适配casbin的那一套结构，毕竟大家对rbac模型太熟悉了，决定不用casbin自己的表结构，把以上的数据组织成满足casbin规则的数据给它去用就行了。
要使用casbin必须先定义一个模型文件，文件内容用于说明使用哪一种权限模型，这里使用的权限模型如下：
rbac.conf
[request_definition] r = sub, obj, act [policy_definition] p = sub, obj, act [policy_effect] e = some(where (p.eft == allow)) [matchers] m = r.sub == p.sub &amp;&amp; keyMatch(r.obj, p.obj) &amp;&amp; (r.act == p.act || p.act == "*") 注意最后一行的p.act="*"，这个意思是说忽略客户端浏览器发起的请求类型，即不分辨GET、POST、FETCH等http方法。
以上是一个改动过的rbac权限模型，然后初始化casbin还需要一个具体写有权限内容的文件，我这里就给提供个空文件就完事了，因为规则是在数据库里面配置的，用以下代码实例化casbin对象,代码中的rbac_policy.csv文件就是个没有内容的空文件。
e := casbin.NewEnforcer("./configs/rbac.conf", "./configs/rbac_policy.csv") 在gin框架中要使用的话这么写中间件
router := gin.Default() web_router:=router.Group("/web") web_router.Use(checkLoginHandle(e)) func checkLoginHandle(e *casbin.Enforcer) gin.HandlerFunc { return func(c *gin.Context) { //获取请求的URI obj_uri := c.Request.URL.RequestURI() if strings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3d2ba32e0edba895b8e157656157ab2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ec398f1f75ffd4425b73b840e5eab14/" rel="bookmark">
			刷题Leetcode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.按奇偶排序数组
2.从尾到头打印链表
3.替换空格
4.二维数组中的查找
5.六一儿童节
6.大整数相乘
7.最大乘积
8.两数之和
9.数组中重复的数字
10.二维数组中的查找
11. 最大矩形
12.跳跃游戏
13.三角形的最大周长
14.DI序列的有效排列
15.最佳买卖股票时机含冷冻期
16.连续数组
17.汉明距离
18.汉明距离总和
1.按奇偶排序数组 给定一个非负整数数组 A，返回一个由 A 的所有偶数元素组成的数组，后面跟 A 的所有奇数元素。
你可以返回满足此条件的任何数组作为答案。
示例：
输入：[3,1,2,4]
输出：[2,4,3,1]
输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。
/** * Return an array of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */ int* sortArrayByParity(int* A, int ASize, int* returnSize) { int temp,p=0,i; for(i=0;i&lt;ASize;i++) { if(A[i]%2==0) { temp=A[i]; A[i]=A[p]; A[p]=temp; p++; } } *returnSize=ASize; return A; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ec398f1f75ffd4425b73b840e5eab14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce854f7ad91182b01bc9862dc804846b/" rel="bookmark">
			instanceof 在list
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public static void main(String args[]) {
List Listlist1 = new ArrayList();
Listlist1.add(0);
List Listlist2 = Listlist1;
System.out.println(Listlist1.get(0) instanceof Integer);
System.out.println(Listlist2.get(0) instanceof Integer);
}
打印出来是：
true true 解析
collection类型的集合（ArrayList,LinkedList）只能装入对象类型的数据，该题中装入了0，是一个基本类型，但是JDK5以后提供了自动装箱与自动拆箱，所以int类型自动装箱变为了Integer类型。编译能够正常通过。
将list1的引用赋值给了list2，那么list1和list2都将指向同一个堆内存空间。instanceof是Java中关键字，用于判断一个对象是否属于某个特定类的实例，并且返回boolean类型的返回值。显然，list1.get(0)和list2.get(0)都属于Integer的实例
不指定ArrayList类型，存入数据，再次取出时，默认是Object类型；但这个题的关键是instanceof关键字，instanceof执行时类似利用java反射机制，识别对象信息。
public class Test { public static void main(String[] args){ List list1 = new ArrayList(); List list2 = list1; list1.add(0); Object o = list1.get(0); Class&lt;?&gt; oClass = o.getClass(); System.out.println(oClass.getSimpleName()); // 实际类型为Integer。 System.out.println(list1.get(0) instanceof Integer); System.out.println(list2.get(0) instanceof Integer); // ArrayList在底层存储数据时就是采用的一个Object[]类型的数组来实现的。在get操作时会强转为泛型类型然后返回， 在 // 此例中并没有给ArrayList泛型。 所以使用的默认值， 即Object类型。所以此例中返回的是一个Object的对象。 // 但是又因为在add的时候由于0是基本类型， 所以在add时会发生自动装箱操作， 将0转换为Integer类型然后添加到ArrayList中。所以 // 通过get获取的对象的实际类型为Integer（第14行通过获取它的Class对象进行验证）; // instanceof在进行比较时会获取对象的实际类型进行比较， 所以通过list1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce854f7ad91182b01bc9862dc804846b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8f0d1561d0e2f51bc22891517979ded/" rel="bookmark">
			代码签名证书购买及使用步骤  不同品牌代码签名证书的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、代码签名证书购买与安装大致流程
1. 在www.ssldun.com/ssl/code-sign.htm购买
2. 购买成功后，填写公司资料认证，用火狐firefox浏览器填写
3. 证书官方认证通过资料后，邮件通知在原来使用的火狐浏览器上安装证书
4. 证书安装成功后，导出证书 5. 导出的证书导入软件封装后供客户下载，就不会提示软件有风险了 证书如何导入软件请参考www.ssldun.com/html/certificate/show-106.html
二、代码签名证书的作用
1. 保护您的代码的完整性 (未被篡改或破坏 )；
2. 免费提供时间戳服务，确保已经签名的代码长期有效 ；
3. 代码签名证书在有效期内可以不限次数对软件进行签名
4. 不被杀毒软件误报软件有毒或风险导致被拦截或自动删除
5. 支持 .exe, .dll, .cab, .ocx，.sys, .cat,等驱动程序文件数字签名
三、代码签名证书区别
1. comodo thawte symantec代码签名证书仅支持SHA2(SHA256)加密算法
2. digicert代码签名证书支持SHA1和SHA2(SHA256)加密算法
3. 标准代码签名证书(OV)和EV代码签名证书主要区别对照表
四、如何从IE或 Firefox浏览器导出代码签名证书 2019/6/18 2/2 一旦您安装代码签名证书在您的浏览器中，您可能想要将其导出 Internet Explorer® 或 Firefox® 使用在其他地方。例 如，您可能想要备份，或在另一台计算机上使用。
（1）要导出从 Internet explorer 中的代码签名证书 1. 在 Internet explorer 中，打开工具，然后单击Internet 选项。互联网选项窗口显示。
2. 从内容选项卡中，单击证书。
3. 从证书列表中，选择您想要导出的证书，然后单击导出。
4. 单击下一步。
5. 单击是的导出私钥，然后单击下一步。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8f0d1561d0e2f51bc22891517979ded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5ea667e70d571a04dc4c34cbebbf1d1/" rel="bookmark">
			查看Oracle数据库资源状况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于Oracle数据库的资源状况，开发人员一般不怎么关注。但是有时候也会遇到，所以这里把相关的SQL做个笔记，方便查看。
​​​​
目录
1. 检查数据库基本状况
2. 检查Oracle相关资源的使用情况
3. 检查Oracle数据库备份结果
4. 检查Oracle数据库性能
5. 检查数据库cpu、I/O、内存性能
6. 检查数据库安全性
7. 其他检查
1. 检查数据库基本状况 1.1. 检查Oracle实例状态
select instance_name, host_name, startup_time, status, database_status from v$instance; 其中“STATUS”表示Oracle当前的实例状态，必须为“OPEN”；“DATABASE_STATUS”表示Oracle当前数据库的状态，必须为“ACTIVE”。 1.2. 检查Oracle在线日志状态
select group, status, type, member from v$logfile; 输出结果应该有3条以上（包含3条）记录，“STATUS”应该为非“INVALID”，非“DELETED”。注：“STATUS”显示为空表示正常。
1.3. 检查Oracle表空间的状态
select tablespace_name, status from dba_tablespaces; 输出结果中STATUS应该都为ONLINE。 1.4. 检查Oracle所有数据文件状态
select name, status from v$datafile; 输出结果中“STATUS”应该都为“ONLINE”。或者：
select file_name, status from dba_data_files; 输出结果中“STATUS”应该都为“AVAILABLE”。
1.5. 检查无效对象
select owner, object_name, object_type from dba_objects where status!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5ea667e70d571a04dc4c34cbebbf1d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af84c131146fcf22e508a69f85a54633/" rel="bookmark">
			Pandas数据处理之数据取值与选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.3 数据取值与选择 本篇介绍Pandas的Series和DataFrame对象的数据获取与调整操作.
一、Series数据选择方法 Series对象与一维Numpy数组和标准字典在许多方面都一样。
1.将Series看做字典 和字典一样，Series 对象提供了键值对的映射：
In[1] : import pandas as pd import numpy as np In[2] : data = pd.Series([0.25,0.5,0.75,1],index=["a","b","c","d"]) data Out[2]: a 0.25 b 0.50 c 0.75 d 1.00 dtype: float64 In[3] : data['b'] Out[3]: 0.5 我们还可以用Python 字典的表达式和方法来检测键/ 索引和值：
In[4] : 'a' in data Out[4]: True In[5] : data.keys() Out[5]: Index(['a', 'b', 'c', 'd'], dtype='object') In[6] : data.items() Out[6]: &lt;zip at 0x25da40d18c8&gt; In[7] : list(data.items()) Out[7]: [('a', 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af84c131146fcf22e508a69f85a54633/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fe35b37c908116e0ff92db66fb127a5/" rel="bookmark">
			mysql安装使用问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装问题 windows10安装mysql5.8，运行net mysql start，提示服务启动失败
1、将c:\mysql\bin加入系统环境变量中
2、my.ini
[mysqld] # Remove leading # and set to the amount of RAM for the most important data # cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%. # innodb_buffer_pool_size = 128M # Remove leading # to turn on a very important data integrity option: logging # changes to the binary log between backups. # log_bin # These are commonly set, remove the # and set as required.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fe35b37c908116e0ff92db66fb127a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e4de4c71b5cabe6a052ee5083ea9238/" rel="bookmark">
			GeoTrust SSL证书详解  GeoTrust SSL证书好吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GeoTrust 是全球第二大数字证书颁发机构(CA)
也是身份认证和信任认证领域的领导者， 该公司各种先进的技术使得任何大小的机构和公司都能安全， 低成本地部署SSL数字证书和实现各种身份认证。在全球150多个国家拥有超过10万名客户，GeoTrust得到了全球各地企业的信赖 。自2001年公司复位以来，它一直专注于为各种规模的公司（从小型企业到大型企业级企业）提供业务级加密解决方案。它的数字证书用最合理的经济，最大化安全性，同时也与高度信任的网络安全品牌保持一致。
全球150多个国家有超过10多万个用户在使用GeoTrust SSL证书来进行安全的电子交易和确认并保护网上真实身份，为全球用户的电子商务保驾护航。GeoTrust 产品的全球市场占有率已经超过30%，每年的增长率高达150% ，完美支持中文域名和显示中文名称，免费提供动态安全签章。
GeoTrust SSL 证书主要有 5 种，其中：3种为只验证域名所有权而不验证营业执照的超快SSL系列(QuickSSL Premium、RapidSSL、Power Server ID)，只有一款为需要验证营业执照的证书(True Business ID)，还有一款就是新推出的EV SSL证书(True Business ID with EV) 。另外需要注意的一点是，GeoTrust的证书没有SGC技术，也就是支持128位加密。 请注意：价格便宜的 RapidSSL 不 提供免费重新颁发服务，如果需要重新颁发，则每次需要另加 148元。而其他型号证书都提供有效期内免费不限次数的自助重新颁发服务。
GeoTrust True Business ID产品特点 * 市场占有率最高的数字证书
证书包含企业身份信息有效期内丢失免费重新颁发40/56/128/256 位自适用加密支援移动设备如 PDA、Smartphone 所使用的浏览器签章显示认证有效的企业身份及防伪时间印戳，确保客户放心 本文由SSL盾小编整理发布，【**www.ssldun.com**】各类型证书介绍
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/403/">«</a>
	<span class="pagination__item pagination__item--current">404/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/405/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>