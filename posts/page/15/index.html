<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39bbf9c1486e890d02a30a95502d944e/" rel="bookmark">
			二叉树与堆的深度解析：数据结构中的关键概念及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.
个人主页：晓风飞 专栏：数据结构|Linux|C语言 路漫漫其修远兮，吾将上下而求索 文章目录 前言树概念注意： 树的基本概念及术语基本概念及术语以家谱为例 树的表示孩子兄弟表示法简介优势应用示例 树在实际中的运用文件系统的目录树结构优点实例Windows中的树Linux中的树树结构的视觉表示 二叉树概念及结构基本定义特点递归定义应用场景 二叉树的性质二叉树的存储结构顺序存储链式存储三叉链： 堆的概念及结构最大堆（大根堆）最小堆（小根堆）存储方式堆的性质操作 结语 前言 在计算机科学的丰富和多样的领域中，数据结构扮演着核心角色。特别是树和堆，作为高效组织和处理数据的关键结构，它们在算法设计和系统实现中占据着重要位置。从文件系统的层次组织到优先队列的管理，理解这些结构的基础原理对于深入掌握计算机科学至关重要。本文旨在深入探讨树和堆的基本概念、性质及其在实际中的应用，为初学者和有志者提供一个明确的理解路径。
树概念 树是一种非线性数据结构，由n（n≥0）个节点构成，这些节点形成了一个具有明确层次的集合。这种结构被称为‘树’，因为它类似于一棵倒置的真实树，即其根部位于顶部，而叶节点则位于底部。
在这种结构中，有一个特殊的节点称为根节点，它是唯一一个没有前驱（即父节点）的节点。
除了根节点，其他所有节点被划分为M（M&gt;0）个互不相交的子集T1、T2、……、Tm。每个子集Ti（1≤i≤m）本身又构成一棵结构上与原树相似的子树。”每棵子树的根节点恰有一个前驱（父节点）且可能有多个后继（子节点）。这种自相似的性质是树的一个关键特征，体现了其递归定义。。
注意： 树形结构中，子树之间不能有交集，否则就不是树形结构
树的基本概念及术语 基本概念及术语 根节点：想象一棵倒立的树，最顶部的那个点是根节点。在数据结构的树中，所有结构都是从这个根节点展开的。 节点：树中的每一个点称为节点，类似于树的小枝，可以向外延伸形成更多分支。 叶节点：位于树底部的节点，没有子节点，就像树上的叶子。 子树：从树中任一节点向下的部分，可以看作是一棵独立的、较小的树。 节点的度：一个节点含有的子树数量。例如，如果节点A有6个子树，那么A的度是6。 非终端节点/分支节点：度不为0的节点，即含有子节点的节点。 双亲节点/父节点：含有子节点的节点，这个节点是其子节点的父节点。 孩子节点/子节点：一个节点的直接下级节点。 兄弟节点：拥有相同父节点的节点。 树的度：树中所有节点的度中的最大值。 节点的层次：从根节点开始，根节点是第1层，其子节点是第2层，依此类推。 树的高度/深度：树中节点的最大层次数。 堂兄弟节点：父节点处于同一层的节点。 节点的祖先：从根节点到该节点路径上的所有节点。 子孙：某节点的所有下级节点。 森林：由多棵互不相交的树组成的集合。 以家谱为例 家谱中的曾祖父是根节点。
他的孩子（例如父亲和父亲的兄弟姐妹）是中间节点。
孙子辈（例如你）是叶节点。
在这个例子中，每一代都可以视作一个单独的“子树”。
树的表示 树结构相对线性表就比较复杂了，要存储表示起来就比较麻烦了，既然保存值域，也要保存结点和结点之间
的关系，实际中树有很多种表示方式如：双亲表示法，孩子表示法、孩子双亲表示法以及孩子兄弟表示法
等。我们这里就简单的了解其中最常用的孩子兄弟表示法。
孩子兄弟表示法简介 在孩子兄弟表示法中，每个节点存储两个指针：
孩子指针：指向该节点的第一个孩子。
兄弟指针：指向同一父节点的下一个兄弟。
typedef int DataType; struct Node { struct Node* _firstChild1; // 第一个孩子结点 struct Node* _pNextBrother; // 指向其下一个兄弟结点 DataType _data; // 结点中的数据域 }; 优势 使用孩子兄弟表示法的主要优点是它可以将任何复杂的树结构转换为类似二叉树的形式。这种转换使得对树的操作（如遍历、搜索等）更加统一和简化。此外，这种方法也便于处理树中节点数量变化的情况，如添加或删除子节点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39bbf9c1486e890d02a30a95502d944e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8850b98d398cb827b438c162f11bb91/" rel="bookmark">
			使用 std::forward 的作用---完美转发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		std::forward是什么 使用 std::forward 是为了实现完美转发（perfect forwarding）。
完美转发是一种技术，用于将函数模板的参数按原始类型转发给其他函数或对象。它可以保持原始参数的值类别（lvalue 或 rvalue）和 const 限定符，从而实现更高的灵活性和效率。
在这个特定的代码片段中，std::forward(func) 是将传递给 enqueue 函数的 func 参数完美转发给 std::packaged_task&lt;int()&gt; 对象的构造函数。
不使用std::forward的危害 #include &lt;iostream&gt; #include &lt;utility&gt; void processValue(int&amp; value) { std::cout &lt;&lt; "processValue(int&amp;): " &lt;&lt; value &lt;&lt; std::endl; value = 100; } void processValue(const int&amp; value) { std::cout &lt;&lt; "processValue(const int&amp;): " &lt;&lt; value &lt;&lt; std::endl; } template &lt;typename T&gt; void forwardExample(T&amp;&amp; value) { processValue(value); } template &lt;typename T&gt; void forwardExample2(T&amp;&amp; value) { processValue(std::forward&lt;T&amp;&amp;&gt;(value)); } template &lt;typename T&gt; void forwardExample3(T&amp;&amp; value) { processValue(std::forward&lt;T&gt;(value)); } int main() { int x = 42; forwardExample(x); // 传递左值 forwardExample(123); // 传递右值 forwardExample2(x); // 传递左值 forwardExample2(123); // 传递右值 forwardExample3(x); // 传递左值 forwardExample3(123); // 传递右值 return 0; } 以上例子的对应输出如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8850b98d398cb827b438c162f11bb91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12c66d7028bb10217e3554997e0ee796/" rel="bookmark">
			docker环境调用mysqldump进行数据备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一：宿主安装客户mysql客户端（apt-get是ubuntu命令，yum是CentOS命令，根据系统选择） RUN apt-get install -y mysql-client RUN yum install mysql -y RUN yum install mariadb 查看宿主机目录/usr/bin中找到了mysqldump，然后可以挂载盖目录到相应容器/usr/bin/mysqldump目录下，就可以执行mysqldump命令了 方法二：通过复制mysql容器目录下的mysqldump出来，命令的语法如下 docker cp &lt;容器名称或ID&gt;:&lt;容器内目录路径&gt; &lt;宿主机目录路径&gt; 例如，如果你想将名为 mycontainer 的容器中的 /app/data 目录复制到宿主机的 /host/data 目录下，可以运行以下命令： docker cp mycontainer:/usr/bin/mysqldump /opt/data 复制宿主机指定目录到指定容器中 docker cp /usr/bin/mysqldump my_container:/usr/bin/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b49e08022a84ae12faeb95fb9fb9946/" rel="bookmark">
			YOLOv8分割任务数据集标注流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLOv8分割任务数据集标注流程 半自动化标注JSON转TXT 半自动化标注 这里使用了半自动化标注工具
链接：https://pan.baidu.com/s/1x22BtI_bHKH0iUUg0eTUdA
提取码：r5ca
需要指定权重和修改类别信息
配置文件中保存了类别、界面语言、轮廓模式等信息，可以通过导入配置文件来快速配置类别；也可以导出当前配置文件。
这里，我们将Main Arm类别添加进去，并删除其他多余的类型
参考文章
选择需要标注的图片文件夹，使用segment anything半自动化标注
e 完成（此时还能精细化调整）
s 保存（需要指定保存的文件夹）
JSON转TXT 需要将Labelme格式的JSON转换为YOLOv8分割格式的TXT
先将ISIA格式的JSON转换为Labelme类型
再将JSON转换为 TXT
# -*- coding: utf-8 -*- import json import os import argparse from tqdm import tqdm from PIL import Image # 这是一个将json文件转换为YOLO格式的txt文件的脚本 def convert_label_json(json_dir, save_dir, classes): json_paths = os.listdir(json_dir) classes = classes.split(',') for json_path in tqdm(json_paths): # for json_path in json_paths: path = os.path.join(json_dir, json_path) with open(path, 'r') as load_f: json_dict = json.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b49e08022a84ae12faeb95fb9fb9946/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/441bc42e0c3a9bdc610c5959ddecbf33/" rel="bookmark">
			共享WiFi项目怎么样，靠谱吗？业内专家为你解答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		共享WiFi项目自问世以来，就备受关注，有人质疑它的可靠性，也有人对其充满信心。今天，我们就来聊聊共享WiFi项目怎么样，是否靠谱。
我们要明白共享WiFi项目是什么。共享WiFi项目是一种基于互联网的共享商业模式，通过在公共场所提供免费WiFi服务，吸引用户使用，从而实现流量变现。在这个过程中，项目方会与商家合作，将共享WiFi贴粘贴在商家店铺内，用户通过扫描共享wifi贴上的二维码即可免费使用WiFi。
从共享商业模式上来看，共享WiFi项目具有一定的创新性。它将免费WiFi作为一种吸引用户的手段，通过广告投放和流量变现来实现盈利。这种模式不仅满足了用户对免费WiFi的需求，也为商家带来了更多的客流量，实现了多方共赢。
我们来看看共享WiFi项目是否靠谱。要判断一个项目是否靠谱，我们通常需要从以下几个方面来考虑：
市场需求：共享WiFi项目满足了用户对免费WiFi的需求，同时也为商家提供了吸引顾客的手段。因此，从市场需求角度来看，共享WiFi项目具有一定的市场空间。
盈利模式：共享WiFi项目的共享商业模式创新性较高，通过广告投放和流量变现来实现盈利。这种模式在一定程度上降低了项目的风险。
团队实力：共享wifi项目的成功与否，很大程度上取决于服务商实力及技术团队。因此，在选择共享WiFi项目时，我们需要关注服务商的背景、团队技术实力。因为一个有专业团队的技术服务商单一个共享wifi项目的的运营是很难维持公司的整体运作的，所以大多还有一些周边的产品如智慧数字经营、多来k本地生活服务商系统、魔棒无人直播软件、灰t数字人克隆系统等。
综上所述，共享WiFi项目是具有一定的市场需求和盈利模式的，但合作者在选择项目时要关注共享wifi项目服务商的这块，做好实地考察上，共享WiFi项目还是值得尝试的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/320f56261a07a1faaef639e718d793e2/" rel="bookmark">
			拍立淘API：让消费者与心仪商品
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着电子商务的快速发展，消费者在购物过程中越来越注重个性化、便捷性和高效性。拍立淘API作为一种先进的购物搜索技术，通过将消费者与心仪商品更紧密地连接起来，为电商行业带来了革命性的变革。本文将详细介绍拍立淘API的原理、优势、使用场景和实现代码，以期为电商行业的技术研发人员和消费者提供有价值的参考。
一、拍立淘API原理
拍立淘API是一种基于图像识别技术的购物搜索接口。它通过分析上传的图片或直接拍摄商品实物，运用先进的机器学习算法和大数据技术，在海量商品数据库中快速匹配出相似或相同的商品，为消费者提供精准的购物推荐。
二、拍立淘API优势
精准匹配：拍立淘API能够快速准确地识别上传的图片或拍摄的实物，在海量商品数据库中找出相似或完全一致的商品，大大提高了购物搜索的准确性和效率。个性化推荐：拍立淘API通过分析消费者的搜索历史、购买记录等信息，能够为消费者提供更加个性化的购物推荐，满足不同消费者的需求和喜好。简化购物流程：拍立淘API的使用简化了购物流程，消费者只需上传图片或拍摄实物，即可快速找到心仪的商品，节省了时间和精力。提升用户体验：拍立淘API的精准匹配和个性化推荐大大提升了消费者的购物体验，增强了消费者对电商平台的信任感和满意度。 三、拍立淘API使用场景
移动端应用：拍立淘API可广泛应用于移动端电商应用中，消费者可以直接在应用内拍摄实物或上传图片进行搜索，快速找到心仪的商品。电商平台：电商平台可集成拍立淘API，为消费者提供便捷的购物搜索服务。商家也可利用拍立淘API进行商品推广和个性化营销。线下实体店：线下实体店可通过拍立淘API实现线上线下联动，消费者在店内拍摄实物或上传图片即可在线上平台进行搜索和购买。社交媒体：社交媒体平台可利用拍立淘API实现图片购物功能，用户可在平台上分享商品图片，其他用户可通过拍立淘API搜索同款或相似商品。 四、拍立淘API实现代码示例（Python）
为了帮助读者更好地理解拍立淘API的实现原理，本文将提供一个简单的Python代码示例，展示如何使用拍立淘API进行商品搜索。请注意，以下代码仅为示例，实际使用时需根据具体情况进行调整和完善。
import requests import json def get_similar_products(image_url): # 调用拍立淘API接口，获取相似商品列表 api_key = 'your_api_key' # 请替换为实际的API密钥 base_url = 'https://api.pialto.io/products/search' # 请替换为实际的拍立淘API接口地址 headers = {'Content-Type': 'application/json'} params = { 'apiKey': api_key, 'imageUrl': image_url, 'similar': True # 搜索相似商品 } response = requests.get(base_url, headers=headers, params=params) data = response.json() # 将返回的JSON数据解析为Python字典 similar_products = data.get('similarProducts', []) # 获取相似商品列表 return similar_products 在上述代码中，我们首先导入了requests和json模块，以便进行HTTP请求和JSON数据的处理。然后定义了一个名为get_similar_products的函数，该函数接受一个图片URL作为参数，调用拍立淘API接口获取与之相似的商品列表。具体实现时，你需要将api_key替换为你实际申请的拍立淘API密钥，并将base_url替换为正确的拍立淘API接口地址。最后，根据返回的JSON数据结构，我们从响应中提取出相似商品列表并返回。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbcf976729805cdecc9c84509ed55030/" rel="bookmark">
			Python开发——Python 3.11 新添加的一些高效特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Python 3.11引入了多项丰富的新特性和功能，其中包括模式匹配、类型提示、改进的错误报告等。这些新特性为开发者提供了更强大的工具，使得编写高效且可靠的代码变得更为容易。
特别值得注意的是，Python 3.11通过模式匹配的引入，为代码逻辑提供了更清晰、更紧凑的表达方式。模式匹配不仅简化了复杂的条件逻辑，还在结构匹配方面提供了更灵活的处理方式。此外，强化的类型提示和类型检查功能有助于在开发过程中及早捕获潜在的类型错误，提高了代码的健壮性。
Python 3.11还通过改进错误报告，使得开发者更容易理解和调试问题。这对于加速开发和降低调试难度都是非常有益的。
一、模式匹配 模式匹配是一种用于简化复杂条件逻辑的方法，可以被视为一种增强版的switch语句。它使得在代码中进行结构化模式匹配更为容易Python 3.11引入了模式匹配，可以简化复杂的条件逻辑。
代码示例：
def process_data(data): match data: case 0: print("收到了零") case [x, y]: print(f"收到了一个列表: {x}, {y}") case {"name": name, "age": age}: print(f"收到了一个字典: {name}, {age}") case _: print("收到了其他类型的数据") # 调用示例 process_data(0) # 输出: 收到了零 process_data([1, 2]) # 输出: 收到了一个列表: 1, 2 process_data({"name": "John", "age": 25}) # 输出: 收到了一个字典: John, 25 process_data("Hello") # 输出: 收到了其他类型的数据 二、结构模式匹配 在模式匹配的基础上，结构模式匹配可以针对针对包含特定结构的字典的模式匹配。以下是该示例的中文注释：
def process_nested_data(data): match data: # 匹配数据结构要求字典中必须包含键值对 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbcf976729805cdecc9c84509ed55030/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbbc55492137648806ae526d9ce1b31e/" rel="bookmark">
			HarmonyOS应用开发学习笔记 应用上下文Context 获取文件夹路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 HarmoryOS Ability页面的生命周期
2、 @Component自定义组件
3、HarmonyOS 应用开发学习笔记 ets组件生命周期
4、HarmonyOS 应用开发学习笔记 ets组件样式定义 @Styles装饰器：定义组件重用样式 @Extend装饰器：定义扩展组件样式
5、HarmonyOS 应用开发学习笔记 state状态管理概述
6、HarmonyOS应用开发学习笔记 包名、icon图标，应用名修改 UIAbility组件介绍、UIAbility启动模式、UIAbility组件基本用法
7、HarmonyOS应用开发学习笔记 UIAbility组件与UI的数据同步 EventHub、globalThis
8、HarmonyOS应用开发学习笔记 UIAbility组件间交互 UIAbility启动，页面跳转结果回调
概叙 Context是应用中对象的上下文，其提供了应用的一些基础信息，例如resourceManager（资源管理）、applicationInfo（当前应用信息）、dir（应用开发路径）、area（文件分区）等，以及应用的一些基本方法，例如createBundleContext()、getApplicationContext()等。UIAbility组件和各种ExtensionAbility派生类组件都有各自不同的Context类。分别有基类Context、ApplicationContext、AbilityStageContext、UIAbilityContext、ExtensionContext、ServiceExtensionContext等Context。
各类Context的继承关系
项目描述获取UIAbilityContextlet abilityStageContext = this.context;获取AbilityStageContextlet abilityStageContext = this.context;获取ApplicationContextlet applicationContext = this.context.getApplicationContext(); Context的典型使用场景 1、 获取应用文件路径 import UIAbility from '@ohos.app.ability.UIAbility'; export default class EntryAbility extends UIAbility { onCreate(want, launchParam) { let cacheDir = this.context.cacheDir; let tempDir = this.context.tempDir; let filesDir = this.context.filesDir; let databaseDir = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbbc55492137648806ae526d9ce1b31e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/759e6c6ea22436bd20c6faf8f3aacb46/" rel="bookmark">
			java基础之HashMap练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用了 外循环，自循环，Lambda表达式，keySet（）方法，values（）方法，Entry对象 ，entrySet（）方法 Map集合框架 1:(Map)关于下列Map 接口中常见的方法： ①put 方法表示放入一个键值对，如果键已存在则 修改值 ，如果键不存在则 新增一条键值对 ;
②remove 方法接受 一个键的 个参数，表示 删除对应的键值对 ;
③get 方法表示 获取该键的value ，get 方法的参数表示 key值 ，返回值表示 value值 ;
④要想获得Map 中所有的键，应该使用方法 keyset ，该方法返回值类型为 Set集合 ;
⑤要想获得Map 中所有的值，应该使用方法 values ，该方法返回值类型为 Collection 。
2:(Map)关于HashMap 和 Hashtable 的区别描述正确的是（B） A.HashMap 是实现 Map 接口，Hashtable 是实现 Table 接口
B.HashMap 性能优于Hashtable，且允许空值和空键
C.HashMap 是线程安全的
D.以上描述都不正确
3:(Map)编程：创建一个银行用户 BankUser 类，用户信息为用户 id、用户名 userName、余额 balance; ①利用 HashMap 存储用户信息：id 作为键，用户作为值，创建多个用户对象进行存储
② 遍历打印输出所有银行的用户名和对应的余额
③键盘输入一个用户名，检测是否存在此用户，存在-打印用户信息；不存在-打印查无此人
④ 打印输出余额大于 200000 的用户信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/759e6c6ea22436bd20c6faf8f3aacb46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c275f4ba946dbeae9f90b952093e9c7/" rel="bookmark">
			Linux运维工程师常见面试题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、linux 1.linux系统启动流程 第一步：开机自检，加载BIOS第二步：读取ＭＢＲ第三步：Boot Loader　grub引导菜单第四步：加载kernel内核第五步：init进程依据inittab文件夹来设定运行级别第六步：init进程执行rc.sysinit第七步：启动内核模块第八步：执行不同运行级别的脚本程序第九步：执行/etc/rc.d/rc.lo 2.linux文件类型 文件属性文件类型-常规文件，即filed目录文件bblock device 即块设备文件，如硬盘;支持以block为单位进行随机访问ccharacter device 即字符设备文件，如键盘支持以character为单位进行线性访问lsymbolic link 即符号链接文件，又称软链接文件ppipe 即命名管道文件ssocket 即套接字文件，用于实现两个进程进行通信 3.centos6和7怎么将源码安装的程序添加到开机自启动？ 通用方法：编辑/etc/rc.d/rc.local文件，在文件末尾添加启动服务命令centos6
①进入到/etc/rc.d/init.d目录下；
②新建一个服务启动脚本，脚本中指定chkconfig参数；
③添加执行权限；
④执行chkconfig --add 添加服务自启动；centos7
①进入到/usr/lib/systemd/system目录下；
②新建自定义服务文件，文件中包含[Unit] [Service] [Install]相关配置，然后添加下执行权限；
③执行systemctl enable 服务名称； 4.简述lvm，如何给使用lvm的/分区扩容？ 功能：可以对磁盘进行动态管理。动态按需调整大小概念： ①PV - 物理卷：物理卷在逻辑卷管理中处于最底层，它可以是实际物理硬盘上的分区，也可以是整个物理硬盘，也可以是raid设备。
②VG - 卷组：卷组建立在物理卷之上，一个卷组中至少要包括一个物理卷，在卷组建立之后可动态添加物理卷到卷组中。一个逻辑卷管理系统工程中可以只有一个卷组，也可以拥有多个卷组。
③LV - 逻辑卷：逻辑卷建立在卷组之上，卷组中的未分配空间可以用于建立新的逻辑卷，逻辑卷建立后可以动态地扩展和缩小空间。系统中的多个逻辑卷可以属于同一个卷组，也可以属于不同的多个卷组。
给/分区扩容步骤： ①添加磁盘
②使用fdisk命令对新增加的磁盘进行分区
③分区完成后修改分区类型为lvm
④使用pvcreate创建物理卷
⑤使用vgextend命令将新增加的分区加入到根目录分区中
⑥使用lvextend命令进行扩容
⑦使用xfs_growfs调整卷分区大小
5.为何du和df统计结果不一致？ 用户删除了大量的文件被删除后，在文件系统目录中已经不可见了，所以du就不会再统计它。然而如果此时还有运行的进程持有这个已经被删除的文件句柄，那么这个文件就不会真正在磁盘中被删除，分区超级块中的信息也就不会更改，df仍会统计这个被删除的文件。可通过 lsof命令查询处于deleted状态的文件，被删除的文件在系统中被标记为deleted。如果系统有大量deleted状态的文件，会导致du和df统计结果不一致。 6.如何升级内核？ 方法一 # 添加第三方yum源进行下载安装。 Centos 6 YUM源：http://www.elrepo.org/elrepo-release-6-6.el6.elrepo.noarch.rpm Centos 7 YUM源：http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm # 先导入elrepo的key，然后安装elrepo的yum源： rpm -import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org rpm -Uvh http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c275f4ba946dbeae9f90b952093e9c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75cf3b74932d479d34d3a50608edd911/" rel="bookmark">
			vagrant 用户名密码登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正常登录后 sudo -i 切换到root权限
vim /etc/ssh/vim sshd_config
将PasswordAuthentication no设置
为yes
重启sshd.service服务
systemctl restart sshd.service
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f4bb39c11ebfe08523b97aeedb9ad0e/" rel="bookmark">
			网卡高级设置-提高网络环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网卡高级设置，提高网络质量排除一些连接问题
一、有线网卡 1、关闭IPv6； 可以关闭协议版本6，因为它会引起一些网络连接问题，而且现在几乎用不到IP6。
2、关闭节约电源模式； 右击计算机-&gt;设备-&gt;设备管理器-&gt;网络适配器-&gt;找到网卡驱动-&gt;右击选属性 点击最后一列-&gt;电源管理-&gt;去掉节约电源选项 3、关闭大量传送减负 右击计算机-&gt;设备-&gt;设备管理器-&gt;网络适配器-&gt;找到网卡驱动-&gt;右击选属性 点击第二列-&gt;高级-&gt;找到大量传送减负（关闭） 另一种说法：
点击高级，进入网卡设置：
传送缓冲区、接收缓冲区、速度和双工可以默认设置，其它所有选项建议全部关闭！
部分网卡设置介绍：
流控制(Flow Control)：允许暂时停止传输数据包以适应接收端速度，开流控制可能会导致掉线，建议关闭。
中断调整(interrupt moderation)：根据网络的流量状况，动态调整发起处理器中断的频率，建议关闭。
IPv4和6硬件校验（IPv4 Checksum Offload）：设置硬件加速IPv4校验，很多程序因为网卡校验和问题造成连接问题，建议关闭。
大量传送减负 (IPv4和6) (Large Send Offload(IPv6))：设置网络控制器硬件加速IPv6数据包切割功能，这个一定要关，主机局域网传文件慢就是这个造成。
TCP、UDP硬件校验 (IPv4和6) （TCP Checksum Offload(IPv4和6)）：设置硬件加速TCP校验和 (IPv4)，很多程序因为网卡校验和问题造成连接问题，建议关闭，校验还是用CPU。
传送缓存区建议最大值128，接收缓存512即可，保持默认。
2、无线网卡：
无线网卡种类较多，各不相同，网上自行查阅资料，或者保持默认设置均可。
3、电源设置无线网卡工作模式：
打开电源设置，找到无线适配器设置，将节能模式设置为：最高性能，不然会降低网速，达到省电的作用，使用有线网络可以忽略这个设置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9930a0b85a9d3a38bad1e3dafc197f7e/" rel="bookmark">
			Pytorch张量通过索引获取指定数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import torch x = torch.tensor([1,2,3]) x Out[3]: tensor([1, 2, 3]) x[0] # 索引操作：取单个数字 Out[4]: tensor(1) x[0:1] # 切片操作：可以保持维度不变 Out[5]: tensor([1]) x[torch.tensor([True,False,True])] # 布尔值索引，通过条件筛选，mask掩码 # 这个条件可以是tensor也可以是列表，只要长度一致 # x[[True,False,True]] Out[6]: tensor([1, 3]) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d611069043728befb51f634f80b10a1a/" rel="bookmark">
			Js-基础语法（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运算符 赋值运算符 赋值运算符：对变量进行赋值的运算符
已经学过的赋值运算符：= 将等号右边的值赋予给左边, 要求左边必须是一个容器 其他赋值运算符： += -= *=/=%= 使用这些运算符可以在对变量赋值时进行快速操作
一元运算符 众多的 JavaScript 的运算符可以根据所需表达式的个数，分为一元运算符、二元运算符、三元运算符
具体应用：
自增：
符号：++
作用：让变量的值 +1
自减：
符号：-- 作用：让变量的值 -1
使用场景：经常用于计数来使用。 比如进行10次操作，用它来计算进行了多少次了
案例：
console.log(i++ + ++i + i) //最后结果是输出7
总结：
1.只需要一个表达式就可以运算的运算符叫一元运算符
2. 自增运算符也是为了简化写法，每次自加1，使用场景是什么？ 经常用于计数来使用。用来计算多少次
3. 实际开发中，我们一般都是单独使用的，后置++ 更多
比较运算符（有不同） 扩展：这里的比较运算符和java的基本相同，但不同的是标红的地方，在java中没有===这种用法，java中的等号大多数就是对地址进行比较（类似于全等），但对于int和String这种重写equals()的来说相当于进行值比较
扩展： 对于中文的比较，一般比较的是中文的unicode（万国码）(java也是这种方式)
// 汉字根据unicode编码来进行比较的 黄 0x9EC4（40644） 景 0x666F（26255） console.log('黄' &gt; '景') //true
逻辑运算符(有不同) 扩展：在js中的逻辑运算符相对于java来说是比较少的，只用&amp;&amp; 、||、！这三个，但在java中有更多的形式，如下图
运算符运算总结&amp;与一假则假|或一真则真^异或全真取反，全假不变，真假为真!非取反&amp;&amp;短路与 规则类似，但不同的是，对于短路与，第一个是假则不对第二个进行计算，对于短路或，
第一个是真，则不对第二个进行计算.
||短路或 在java中还有位运算符的概念，就是可以对二进制进行计算，但在js中是没有这个概念的
运算符的优先级 --和java差不多 记：（）&gt;一元运算符&gt;算术运算符&gt;比较运算符&gt;逻辑运算符&gt;（三元表达式）&gt;赋值运算符
一元运算符里面的逻辑非优先级很高逻辑与比逻辑或优先级高 答案：fasle、true、false、false 语句（几乎和java一模一样） 表达式和语句 表达式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d611069043728befb51f634f80b10a1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/456b961a9b3f242b1cfdefad9febf5b2/" rel="bookmark">
			HTML实战演练之比心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开始之前，我们需要先简单的了解一下这颗爱心的原理哦~
本期将用html实现这颗跳动的爱心，我们先从html开始吧！
HTML（HyperText Markup Language）是一种用于创建网页结构和内容的标记语言。它是Web开发中最基本的技术之一，用于描述和组织网页的内容。
HTML最初由Tim Berners-Lee于1991年创造，作为一种用于共享科学研究成果的标准化形式。HTML使用标记（tag）来定义文本的结构和语义，并将其呈现为具有超链接的富文本文档。通过使用标记、元素和属性，HTML可以定义文本的标题、段落、列表、表格和图像等内容。
HTML是一种使用尖括号包围的标签语言。标签通常由一个起始标签（opening tag）和一个结束标签（closing tag）组成，两个标签之间的内容表示要被标记的文本。起始标签和结束标签可以包含属性，用于进一步定义和修饰标记的行为和外观。
在HTML中，元素是由标签组成的，可以包含文本、其他元素或者二者的组合。最常见的HTML元素包括标题元素（如&amp;lt;h1&amp;gt;到&amp;lt;h6&amp;gt;）、段落元素（如&amp;lt;p&amp;gt;）、列表元素（如&amp;lt;ul&amp;gt;和&amp;lt;li&amp;gt;）和超链接元素（如&amp;lt;a&amp;gt;）。通过嵌套和组合这些元素，可以创建出复杂的网页结构。
HTML标记还可以使用属性来进一步定义和修饰元素。属性提供了关于元素的额外信息，如元素的尺寸、颜色或布局等。常见的HTML属性包括id（标识元素的唯一标识符），class（用于将元素分组或应用样式）和style（内联样式）等。
HTML是一种层次结构的语言，文档的整体结构由多个元素组成，可以组织成树状结构。通常使用&amp;lt;html&amp;gt;元素作为根元素，它包含&amp;lt;head&amp;gt;元素和&amp;lt;body&amp;gt;元素。&amp;lt;head&amp;gt;元素用于定义文档的元数据，如标题和链接，而&amp;lt;body&amp;gt;元素包含实际的内容。
HTML可以通过文本编辑器编写，并在Web浏览器中进行查看。一旦HTML文档完成，可以通过将其保存成.html文件并在浏览器中打开来实现呈现。浏览器将解析HTML代码并显示其内容，呈现为用户可见的网页。
虽然HTML本身具有一定的格式和样式，但它通常与CSS（Cascading Style Sheets）和JavaScript等技术一起使用，以实现更丰富和交互式的网页效果。CSS用于定义网页的样式和布局，而JavaScript用于添加交互性和动态效果。
总之，HTML是用于创建Web内容的基本技术之一，它定义了网页的结构和内容。通过使用标记、元素和属性，可以创建出具有超链接和富文本特性的网页。与CSS和JavaScript等技术结合使用，HTML可以实现更丰富和交互式的网页效果。
跳动的爱心
01
完整代码
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;跳动的爱心&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src='./js/three.min.js'&gt;&lt;/script&gt; &lt;script src='./js/TrackballControls.js'&gt;&lt;/script&gt; &lt;script src='./js/simplex-noise.js'&gt;&lt;/script&gt; &lt;script src='./js/OBJLoader.js'&gt;&lt;/script&gt; &lt;script src='./js/gsap.min.js'&gt;&lt;/script&gt; &lt;script src="./js/script.js"&gt;&lt;/script&gt; &lt;script&gt; (function () { const _face = new THREE.Triangle(); const _color = new THREE.Vector3(); class MeshSurfaceSampler { constructor(mesh) { let geometry = mesh.geometry; if (!geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3) { throw new Error('THREE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/456b961a9b3f242b1cfdefad9febf5b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b1acc9fae31aecf2493b6ce0b19eb54/" rel="bookmark">
			基于ZU19EG的100G-UDP解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 本文档介绍ZU19EG与Mellanox CX6 100G网卡通信解决方案。
环境配置 FPGA硬件：519-ZU19EG的4路100G光纤PCIe加上计算卡
电脑：国产国鑫主板（双PCU）：Gooxi G2DA-B CPU:Intel Xeon Silver @2.2GHz 内存：64GB 操作系统：ubuntu20.04
网卡：ConnectX6 MCX653106A-ECA_Ax
FPGA解决方案 板卡fpga型号：XCZU19EG-FFVC1760-2E
开发环境：Vivado2021.2
输出：QSFP28光口输出
工程代码架构如下：
UltraScale+ 100G Ethernet Subsystem配置如下：
工程代码各模块功能：
FPGA端VIO配置：
Start：控制开始发送，结束发送。
packet_length_sel：可以选择UDP包长：0是1024字节，1是2048字节，2是4096字节，3是8192字节。
time_1us：可以配置发送间隔，以1US为单位作为间隔，默认值为1000_000，即为1s钟间隔。
FPGA端发送接收速率显示是speed信号，ila在线观测，在代码中位置：
100G UDP产生模块：
UDP格式说明如下图： 下面分析一帧基于UDP的TFTP协议帧。
以太网首部
0000: 00 05 5d 67 d0 b1 00 05 5d 61 58 a8 08 00
IP首部
0000: 45 00
0010: 00 53 93 25 00 00 80 11 25 ec c0 a8 00 37 c0 a8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b1acc9fae31aecf2493b6ce0b19eb54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4fed4b47d2e8d54878d75f3305cfbf8/" rel="bookmark">
			JavaFx踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github：https://gitee.com/forgot940629/java-fx-demo
helloworld 直接用idea即可创建
MANIFEST.MF 没有MANIFEST.MF 直接用idea生成的JavaFX没有MANIFEST.MF这个文件，需要配置
jar包中MANIFEST.MF不一致 target文件中的MANIFEST.MF有Main-Class
jar包中的MANIFEST.MF没有Main-Class
此时需要添加maven插件
插件添加完之后就有Main-Class了
找不到或无法加载主类 这个报错的根本原因是主类中的javafx/application/Application找不到，需要在执行java命令时加几个参数。此外还需要下载sdk。
sdk下载地址。
修改之后的命令
D:\software\jdk17\java\bin\java.exe --module-path D:\data\BianCheng\java\phone_number_geo\geo1\javafx_lib\javafx-sdk-21.0.1\lib --add-modules javafx.controls,javafx.fxml -jar demo-1.0-SNAPSHOT.jar JPackage JPackage应该是支持–add-modules --module-path这俩参数，但是我由于工作原因我懒得试了，以后有机会尝试用JPackage将上述jar包打包成安装包。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6b3218e24e307ca49bf630ccd07cf7c/" rel="bookmark">
			408重要数据结构&#43;算法汇总——C语言手搓版（全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该套代码，大学期间跟着网课一遍一遍打下来的，408大概就这些了，别的杂七杂八其实还有很多，遗憾的是，一直没有整理和归纳。导致一遍遍地学一遍遍地忘记。大四就快毕业了，研也考了。这里做个整理，算是给408一个小小的胶带吧。后续如果有缺漏还会弥补。
目录： 线性表链表栈队列链栈链队二叉树线索二叉树堆堆排序并查集（quickfind、quickunion、w-qickunion、路径压缩）AVL树红黑树B树拓扑排序排序（插入、冒泡、归并、选择、快排、快排优化）希尔排序dijsktra算法-单源最短路kruskal算法-最小生成树Prim算法-最小生成树字符串匹配算法汇总（朴素、哈希匹配、kmp、kmp优化、Sunday、Shift-And） 请说明malloc、calloc、realloc三者的区别，并分别介绍用法 malloc函数：malloc用于分配指定大小的内存块，并返回一个指向该内存块的指针。它只分配内存，不进行初始化。如果分配成功，则返回指向分配内存的指针；如果分配失败，则返回NULL。
calloc函数：calloc用于分配指定数量和大小的连续内存块，并返回一个指向该内存块的指针。与malloc不同的是，calloc会将分配的内存块进行初始化，将每个字节都设置为0。如果分配成功，则返回指向分配内存的指针；如果分配失败，则返回NULL。
realloc函数：realloc用于重新分配已经分配的内存块的大小。它接受两个参数，第一个参数是一个已经分配内存的指针，第二个参数是需要重新分配的大小。如果分配成功，则返回指向重新分配内存的指针；如果分配失败，则返回NULL。需要注意的是，如果realloc分配的新内存大小比原来的内存大小大，那么新分配的内存区域中的内容将被清除。
malloc、calloc、realloc都是C语言中用于动态内存分配的函数。它们之间的区别如下：
malloc只分配内存，不进行初始化。calloc会将分配的内存块进行初始化，将每个字节都设置为0。malloc分配的内存块是未初始化的，因此在使用前需要进行初始化。calloc分配的内存块是初始化的，因此在使用前不需要进行初始化。malloc分配的内存块可以是任意大小的。calloc分配的内存块必须是连续的，并且大小必须是2的幂次方。malloc分配的内存块是不可变的，不能修改其大小。calloc分配的内存块是可变的，可以通过realloc函数修改其大小。 malloc、calloc、realloc的用法如下：
malloc的用法如下： #include &lt;stdlib.h&gt; int* ptr; ptr = (int*)malloc(10 * sizeof(int)); // 分配了10个int类型的内存空间 if (ptr == NULL) { // 内存分配失败的处理 } else { // 内存分配成功的处理 // 使用ptr指针访问分配的内存空间 // ... free(ptr); // 释放内存空间 } calloc的用法如下： #include &lt;stdlib.h&gt; int* ptr; ptr = (int*)calloc(10, sizeof(int)); // 分配了10个int类型的内存空间，并初始化为0 if (ptr == NULL) { // 内存分配失败的处理 } else { // 内存分配成功的处理 // 使用ptr指针访问分配的内存空间 // ... free(ptr); // 释放内存空间 } realloc的用法如下： #include &lt;stdlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6b3218e24e307ca49bf630ccd07cf7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad5c23e03d1741e422b920bad3befca8/" rel="bookmark">
			Spring Boot自定义启动Banner在线生成工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下，后续有更新添加
链接: Spring Boot自定义启动Banner在线生成工具
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0e510ee140a693d9dac39c45e9185d8/" rel="bookmark">
			树莓派ubuntu：vscode远程SSH开发调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用VSCODE可以SSH连接远程开发板，在开发板上调试开发程序
1. VSCODE安装插件"Remote - SSH" 2. 新建SSH连接配置 例如：ssh ubuntu@192.168.43.102
自动生成的配置文件内容如下：
Host 192.168.43.101 HostName 192.168.43.101 User ubuntu 添加新的连接后，可能需要重启VSCODE，否则看不到新增的SSH连接
3. 连接SSH 输入密码,点击回车
连接成功，可以像在本机一样编程开发了
4. 执行终端命令 VSCODE远程打开终端，执行编译运行等命令，调试开发更加方便
5. 安装git 将开发板上的源码同步上传到gitee或github，避免开发调试的代码只留在开发板上，造成源码丢失。
5.1 安装 sudo apt-get install git 如果出现如下错误，重启ubuntu再执行
ubuntu@ubuntu:~/pro/4WD-CAR-PY$ sudo apt-get install git E: Could not get lock /var/lib/dpkg/lock-frontend. It is held by process 2711 (unattended-upgr) N: Be aware that removing the lock file is not a solution and may break your system. E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0e510ee140a693d9dac39c45e9185d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3a142c0c0d43de0c79daf965e71ee82/" rel="bookmark">
			mysql去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 select gmsfzh, xm, hjszd, rylxfrom ( select a.gmsfzh, -- 身份证号码 a.xm, -- 姓名 a.hjszd, -- 户籍所在地 a.rylx, -- 人员类型 row_number() over( partition by a.gmsfzh order by a.gxsj desc ) as rk from tablename a ) where rk =1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89183a45970cb5ec8b8751dbaa6ef575/" rel="bookmark">
			如何通过bat文件启动应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：在windows上，任何应用程序都是通过.exe启动的。我们可以通过配置环境的方式，将应用程序的路径配置到环境变量path变量里，这样就可以使用cmd窗口，敲应用程序的名称来启动应用程序。
如下，可启动wps应用：
但是，如果某个应用程序名称过长，这样就比较麻烦。如Redis的可视化应用（Another Redis Desktop Manager.exe）：
本文介绍对于这类应用程序，如何通过bat文件来间接启动。
通过bat启动应用程序 首先，在该应用程序所在的目录创建一个bat文件，内容如下：
@echo off start "" "D:\dev\Another Redis Desktop Manager\Another Redis Desktop Manager.exe" exit 表示，启动Redis可视化工具的应用程序；
命名文件 将上面的bat文件自定义命名，如redis-show.bat；
然后配置环境变量，将当前路径配置到path变量中。启动程序，敲bat文件的文件名即可；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da53e45f4f4475195729be519d3b999f/" rel="bookmark">
			鸿蒙原生应用/元服务开发-长时任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述
功能介绍
应用退至后台后，对于在后台需要长时间运行用户可感知的任务，例如播放音乐、导航等。为防止应用进程被挂起，导致对应功能异常，可以申请长时任务，使应用在后台长时间运行。申请长时任务后，系统会做相应的校验，确保应用在执行相应的长时任务。同时，系统有与长时任务相关联的通知栏消息，用户删除通知栏消息时，系统会自动停止长时任务。
使用场景
下表给出了当前长时任务支持的类型，包含数据传输、音频播放、录音、定位导航、蓝牙相关、多设备互联和计算任务。可以参考下表中的场景举例，选择合适的长时任务类型。
长时任务类型
·申请了DATA_TRANSFER（数据传输）的长时任务，系统仅会提升应用进程的优先级，降低系统终止应用进程的概率，但仍然会挂起对应的应用进程。对于上传下载对应的功能，需要调用系统上传下载代理接口托管给系统执行。
约束与限制
申请限制：Stage模型中，长时任务仅支持UIAbility申请；FA模型中，长时任务仅支持ServiceAbility申请。
数量限制：一个UIAbility（FA模型则为ServiceAbility）同一时刻仅支持申请一个长时任务，即在一个长时任务结束后才可能继续申请。如果一个应用同时需要申请多个长时任务，需要创建多个UIAbility；一个应用的一个UIAbility申请长时任务后，整个应用下的所有进程均不会被挂起。
运行限制：系统会进行长时任务校验。若应用申请了长时任务，但未真正执行申请类型的长时任务或申请类型的任务已结束，系统会对应用进行管控。例如系统检测到应用申请了AUDIO_PLAYBACK（音频播放），但实际未播放音乐，系统则会终止对应的进程。
接口说明：
主要接口：
代码开发：stage模型下
1.申请ohos.permission.KEEP_BACKGROUND_RUNNING权限，配置方式请参见配置文件权限声明。
2.声明后台模式类型。
在module.json5配置文件中为需要使用长时任务的UIAbility声明相应的长时任务类型。
{ "module": { ... "abilities": [ { ... // 后台模式类型 "backgroundModes": [ "audioRecording" ], } ] } } 3.导入模块
import backgroundTaskManager from '@ohos.resourceschedule.backgroundTaskManager'; import wantAgent from '@ohos.app.ability.wantAgent'; 4.申请和取消长时任务。
设备本应用申请长时任务示例代码如下：
import common from '@ohos.app.ability.common'; @Entry @Component struct Index { @State message: string = 'ContinuousTask'; // 获取UIAbilityContext private context = getContext(this) as common.UIAbilityContext; startContinuousTask() { let wantAgentInfo = { // 点击通知后，将要执行的动作列表 wants: [ { bundleName: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da53e45f4f4475195729be519d3b999f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5aecce5406154f42a21171e8f511b16/" rel="bookmark">
			VirtualBox安装OpenEuler
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VirtualBox安装OpenEuler 下载地址
virtualbox下载地址：https://www.virtualbox.org/wiki/Downloads openEuler下载地址：https://www.openeuler.org/zh/download/?version=openEuler%2022.03%20LTS%20SP3 安装virtualbox virtualbox安装penEuler 点击新建
设置名称、文件夹、虚拟光盘，如需自定义安装，不要勾选跳过自动安装
设置内存带下和处理器
设置硬盘大小，建议不小于40G
点击完成
如需要支持嵌套虚拟化、桥接网络,点击设置
设置嵌套虚拟化
设置网络模式，如桥接，选择对应的网卡（选择wifi使用的网卡）
查看信息，启动
选择语言，点击Continue
按需配置
配置硬盘
选择安装软件
选择最小安装
配置网络
选择启动激活网络
按需配置网络，此处为使用静态IP
点击Done，报错网络配置
配置root账户
配置后保存
选择开始安装
安装中
关闭虚拟机
选择正常关闭
点击设置
移除安装镜像
确定删除
保存配置
启动虚拟机
启动中
使用配置密码，登录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49fc6eefc0f165b022dd5c3b02d0fcb2/" rel="bookmark">
			Skywalking(8.7)安装以及docker镜像打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Skywalking安装以及docker镜像打包 Skywalking版本：apache-skywalking-apm-es7-8.7.0
ES版本：7.17.2
一.下载Skywalking的安装包 下载地址：Index of /dist/skywalking/8.7.0 (apache.org)
上传到服务器安装目录并解压
#这里选择的安装目录是/usr/local cd /usr/local tar -zxvf apache-skywalking-apm-es7-8.7.0.tar.gz 二.查看并修改配置文件 #进入解压好的目录 cd apache-skywalking-apm-bin-es7 #编辑配置文件 vi config/application.yml 在配置文件中找到图片所在的位置
此处修改的地方为SW_STORAGE:elasticsearch7，elasticsearch7是该文档中的一个es数据存储的配置项。
然后修改es存储的地址，在图片中如下位置修改：
然后退出保存
storage.elasticsearch7，配置项，设置使用 Elasticsearch 7.X 版本作为存储器，本次安装选用的es7，所以需要配置es的地址。storage.elasticsearch，配置项，设置使用 Elasticsearch 6.X 版本作为存储器。所以无需做任何改动。storage.h2，配置项，设置使用 H2 作为存储器。 如服务器出现端口占用，还可以选择更改Skywalking的端口。
vi webapp/webapp.yml 三.启动Skywalking cd bin/ ls 这里可以看见有三个启动脚本，分别是oap启动脚本，webServer的启动脚本，和同时启动两个服务的脚本startup.sh。
因为是首次安装，所以先启动oap，执行oapService.sh，然后看日志输出。打开 logs/skywalking-oap-server.log 日志文件，查看是否有错误日志。首次启动时，因为 SkyWalking OAP 会创建 Elasticsearch 的索引，所以会一直打印日志，如下图。
最终，我们看到如下日志，基本可以代表 SkyWalking OAP 服务启动成功：
org.eclipse.jetty.server.Server - 444 [main] INFO [] - Started 因为首次启动oap会创建大量索引，所以需要花费较长时间。
然后启动webappServer，执行webappService.sh，然后通过ip加配置的端口访问UI页面，能成功进入就算安装成功。
四.使用Nginx，配置oap-server 域名 在配置SkyWalking Agent的时候，oap在接收代理数据的时候报错。所以需要通过Nginx配置grpc 通信
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49fc6eefc0f165b022dd5c3b02d0fcb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6d940984f6479aaaeb756f1d014fc2f/" rel="bookmark">
			React路由进阶方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React中的路由进阶主要涉及以下几个方面：
使用动态路由参数： React Router支持使用动态路由参数来创建可变的路由。可以通过在路由路径中使用:paramName语法，然后在组件中通过useParams()钩子或match.params.paramName来获取动态参数的值。
路由嵌套和布局： 在React中，可以将路由配置进行嵌套，以实现复杂的布局结构。可以在父级路由组件中定义公共的布局，在子级路由中渲染具体的页面内容。
路由守卫和权限控制： 对于需要进行权限控制的页面，可以通过路由守卫来实现。可以在路由配置中添加中间件函数，用于验证用户的身份和权限，并决定是否允许访问该路由。
路由传参： 除了使用动态路由参数外，还可以通过查询字符串、URL参数或状态管理库等方式进行路由传参。这样可以在不同路由之间传递数据和状态，实现更复杂的场景交互。
懒加载路由组件： 当应用规模较大时，为避免首次加载时加载过多的代码，可以将路由组件进行懒加载。可以使用React.lazy()函数和Suspense组件来实现按需加载路由组件。
路由重定向和404页面： 可以通过重定向路由配置来将用户从一个URL自动导航到另一个URL。另外，可以定义一个404页面来处理未匹配的路由，为用户提供友好的错误提示。
以上是React中路由进阶的一些常见技术点。你可以根据具体需求选择适合的方法来实现更复杂的路由功能。
以下是一个React中路由进阶的代码示例，展示了动态路由参数、路由嵌套和布局、路由守卫和权限控制、路由传参、懒加载路由组件以及路由重定向和404页面的实现：
import React from 'react'; import { BrowserRouter as Router, Switch, Route, Link, Redirect } from 'react-router-dom'; // 路由守卫函数，验证用户是否登录 const requireAuth = (Component) =&gt; { const isAuthenticated = true; // 根据实际情况判断用户是否登录 return isAuthenticated ? Component : &lt;Redirect to="/login" /&gt;; }; // 动态路由参数示例 const ProductDetail = ({ match }) =&gt; { const { id } = match.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6d940984f6479aaaeb756f1d014fc2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c7993901b2bd1b74d73a61174dc2eb1/" rel="bookmark">
			【Unity】动态申请权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、AndroidManifest.xml在&lt;application&gt;&lt;/application&gt;内添加一行：
&lt;meta-data android:name="unityplayer.SkipPermissionsDialog" android:value="true" /&gt; 作用：屏蔽应用启动时弹出申请权限弹窗（危险权限？普通权限？）
(动态申请权限也要定义在AndroidManifest.xml &lt;users-permission ... /&gt; )
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.unity3d.player" xmlns:tools="http://schemas.android.com/tools"&gt; &lt;!-- 动态添加的权限必须也要定义，例如下面的3个危险权限 --&gt; &lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt; &lt;application android:usesCleartextTraffic="true" android:requestLegacyExternalStorage="true"&gt; &lt;activity android:name="com.test.MainActivity" android:exported="true" android:theme="@style/UnityThemeSelector"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name="unityplayer.UnityActivity" android:value="true" /&gt; &lt;/activity&gt; &lt;meta-data android:name="unityplayer.SkipPermissionsDialog" android:value="true" /&gt; &lt;/application&gt; &lt;/manifest&gt; 2、Unity自带API申请权限功能实现(Unity 2019.4)
命名空间：UnityEngine.Android
判断是否有权限：bool Permission.HasUserAuthorizedPermission(权限字符串)
请求权限：Permission.RequestUserPermission(权限字符串) 【测试发现2019.4的是直接用这个API就拿到权限了，不会弹出申请权限弹窗，也不需要用户同意就拿到权限了，因此还需要自己做个弹窗模拟下】
【测试发现模拟器会直接申请到权限不会有任何系统申请权限弹窗，而真机会有所以不需要自己做弹窗】
其请求权限回调可采用协程或定时器等待自定义时间后(0.2s后)进行再次检查，若还是没有可以继续进行请求权限，可以自定义尝试次数达到n次后进行弹出弹窗提示玩家请求权限失败，重试或退出游戏。
Unity 2020.2 API接口开放了 Permission.RequestUserPermissions(权限字符串数组) 以及 PermissionCallback 回调。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c7993901b2bd1b74d73a61174dc2eb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bc674894e05f96c23de93d9dd186bb8/" rel="bookmark">
			实战：低代码表单引擎助力文件上传与数据处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今的信息化时代，数据已成为企业的重要资产。为了更好地管理和利用这些数据，许多企业开始采用表单上传组件来导入和处理数据。通过使用表单上传组件，用户可以方便地将文件上传至系统中，然后进行后续的数据处理和分析。这种方式的优点在于，用户无需掌握复杂的编程技术，即可完成数据导入工作。同时，系统可以自动对上传的文件进行解析，并将其转换为可处理的数据格式。
通过表单上传组件导入文件后对导入数据进行处理 示例演示 设计配置 设计思路：通过在列表页添加顶部按钮打开表单上传文件，配置自定义按钮提交触发逻辑，然后在逻辑引擎中对上传的文件解析并将解析的数据新增至列表页中。
【文件解析】
①：文件链接地址，通过函数公式取导入文件上传的链接地址。
②：文件类型，目前只支持xlsx格式。导入文件格式必须与文件类型一致。
③：数据开始行，指从表格第几行开始导入数据，填写数字。
④：参数名，导入文件的表头字段。
⑤：参数值，指转换后的字段名称，建议与列表字段名保持一致。
⑥：数据集名称，数据模型-数据集名称。
注意：
如果上传的文件表头字段与列表页设计的字段名称一致则不用填写参数名和参数值，直接通过数据集关联匹配。固定变量节点用集合函数“LISTGET”取链接地址，是一个数组格式。 然后添加循环容器节点对文件解析的数据进行循环取值，再在循环画布里添加新增数据节点新增数据。
最后点击【提交】并【保存】操作上传文件查看效果。
在线demo：https://frame.bctools.cn
开源基础框架：https://gitee.com/software-minister/jvs
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fa885f24e1923512daa4687c813b8eb/" rel="bookmark">
			数据库开发工具Navicat Premium 15 mac软件特色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Navicat Premium 15 mac版是一款数据库开发工具，Navicat Premium 15 Mac版可以让你以单一程序同時连接到 MySQL、MariaDB、SQL Server、SQLite、Oracle 和 PostgreSQL 数据库。
Navicat Premium mac软件特色
无缝数据迁移
数据传输，数据同步和结构同步可帮助您更轻松快捷地迁移数据，从而减少开销。提供详细的分步指南，以跨各种DBMS传输数据。通过数据和结构同步比较和同步数据库。在几秒钟内设置和部署比较，并获取详细的脚本以指定要执行的更改。
多元化的操作工具
设置数据源连接后，可以使用“导入向导”将数据从多种格式或从ODBC传输到数据库中。将数据从表/集合，视图或查询结果导出为Excel，Access，CSV等格式。使用我们的内置编辑器添加，修改和删除记录，您可以在Tree View，JSON View和类似电子表格的经典Grid View中方便地进行编辑。Navicat为您提供有效管理数据并确保流程平稳所需的工具。
简单的SQL /查询编辑
Visual SQL / Query Builder将帮助您创建，编辑和运行SQL语句/查询，而不必担心语法和命令的正确用法。通过获取关键字建议并从编码中去除重复内容，使用“代码完成”和可自定义的代码段快速编码。使用我们的调试组件，例如设置断点，单步执行程序，查看和修改变量值以及检查调用堆栈，可以快速找到并纠正PL / SQL和PL / PGSQL编码错误。
智能数据库设计器
使用我们专业的对象设计器创建，修改和管理所有数据库对象。使用复杂的数据库设计和建模工具将数据库转换为图形表示形式，以便您可以轻松地建模，创建和理解复杂的数据库。
苹果：Navicat Premium 15 for Mac(数据库开发工具)v15.0.30中文版
Win：Navicat Premium(数据库开发工具)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/979549e29efecaaeaa8e5f91754451f5/" rel="bookmark">
			利用矩阵特征值解决微分方程【1】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 特征值介绍
二. 单变量常微分方程
三. 利用矩阵解决微分方程问题
四. 小结
4.1 矩阵论
4.2 特征值与特征向量内涵
4.3 应用
一. 特征值介绍 线性代数有两大基础问题：
如果A为对角阵的话，那么问题就很好解决。需要注意的是，矩阵的基础行变换会改变特征值的大小。
在已知解的情况下，可以利用矩阵行列式解决问题。根据Cramer定则：
将以下矩阵的行列式看成一个多项式：
该多项式的根即为特征值。当矩阵维度较高时，这个方法就很难计算。
二. 单变量常微分方程 假定某函数为u(t)，其中t为自变量，满足如下微分方程：
回忆：
很容易求出该单变量常微分方程的解为：
当a大于0，函数无界（unstable）；当a等于0，函数为常函数（stable）；当a小于0时，函数趋近于0（stable）；
当a为复数时，如下：
实数部分的分析与以上类似。虚数部分则会产生振荡，如下：
三. 利用矩阵解决微分方程问题 给出以下常微分方程问题：
因为初始条件都是t=0，所以这类问题又被称之为初值问题（initial value problem），其中初值在这个地方指的就是8和5。
如果将t看成时间的话，该问题的本质则是寻找v(t)和w(t)，其中t大于0
一个常微分方程问题是怎么样跟矩阵联系在一起的呢？
首先，我们将两个未知的函数写成向量的形式，叫做u(t)，如下：
那么初始值则是u(0)，如下：
系数矩阵叫做A，如下：
那么原始的两个微分方程则可以合并成一个向量形式的微分方程，如下：
很明显这是一阶求导的方程，整个运算都是线性关系。系数均为常数结构，也就是矩阵A与时间t无关。
根据经验，v(t)和w(t)均为指数函数的结果，如果可以设两个函数的形式如下：
将两者合并为向量形式，如下：
很明显该结果满足我们想要的du/dt=Au的结构。将函数和带入原微分方程中，可得：
可以发现这两个方程都出现了，可以直接约简。这个时候最神奇的地方就出现了，当约简完后，你会发现：
这不就是特征值方程！形式如下：
该特征值方程A已知，和x未知。也就是为矩阵A的特征值，x为矩阵A的特征向量。接下来就可以直接利用我们熟悉的线性代数知识直接求解即可。
四. 小结 4.1 矩阵论 矩阵论是一个重要的数学分支，属于代数学范畴，需要抽象思维能力、数学建模能力以及科学计算能力。目前矩阵论的思想方法已经渗透到网络安全、经济管理以及军事学等各个领域，尤其是上世纪五六十年代以来，随着计算机科学技术的发展，网络工程、信息工程、测绘工程以及密码工程等各个专业都需要利用矩阵论课。矩阵论包括线性空间与线性变换、矩阵的范数理论、矩阵分析、矩阵分解、矩阵的特征值估计以及矩阵的广义逆等。
矩阵论有几个细节很重要，比如特征值理论、线性空间和线性变换、矩阵运算、多项式理论等，然后将其应用于行列式的计算、矩阵的初等变换以线性方程组解的判定和解的结构等。借助数值计算软件 matlab等，可以用来建立数学模型，然后构建算法，利用科学计算方法最终解决实际问题。
方阵的特征值与特征向量是一个重要的数学概念，在数据处理的统计方法、通信网络中的信息检索、图像压缩与恢复、机械振动等多个方面都有广泛的应用，例如，工程技术中的振动问题和稳定性问题，在数值上大都归结为矩阵的特征值与特征向量的问题。
4.2 特征值与特征向量内涵 矩阵的特征值和特征向量定义高度抽象，设 A 是 n 阶方阵，若存在数λ 和 n 维非零向量 x，使得 Ax = λx 成立，则称数λ 是方阵 A 的特征值，非零向量 x 为方阵 A 的特征向量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/979549e29efecaaeaa8e5f91754451f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccee947bb30a8079cf8c41d70bcd2a11/" rel="bookmark">
			SpringBoot 集成WebSocket详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、WebSocket概述 1、WebSocket简介 WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。
2、为什么需要WebSocket HTTP 是基于请求响应式的，即通信只能由客户端发起，服务端做出响应，无状态，无连接。
无状态：每次连接只处理一个请求，请求结束后断开连接。
无连接：对于事务处理没有记忆能力，服务器不知道客户端是什么状态。
通过HTTP实现即时通讯，只能是页面轮询向服务器发出请求，服务器返回查询结果。轮询的效率低，非常浪费资源，因为必须不停连接，或者 HTTP 连接始终打开。
WebSocket的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话。
WebSocket特点：
（1）建立在 TCP 协议之上，服务器端的实现比较容易。
（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
（3）数据格式比较轻量，性能开销小，通信高效。
（4）可以发送文本，也可以发送二进制数据。
（5）没有同源限制，客户端可以与任意服务器通信。
（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。
二、SpringBoot整合WebSocket 创建 SpringBoot项目，引入 WebSocket依赖，前端这里比较简陋。
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;version&gt;2.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;version&gt;2.7.12&lt;/version&gt; &lt;/dependency&gt; application.yml：
server: port: 8081 spring: thymeleaf: mode: HTML cache: true prefix: classpath:/templates/ encoding: UTF-8 suffix: .html check-template-location: true template-resolver-order: 1 1、WebSocketConfig 启用 WebSocket的支持也是很简单。
/** * WebSocket配置类。开启WebSocket的支持 */ @Configuration public class WebSocketConfig { /** * bean注册：会自动扫描带有@ServerEndpoint注解声明的Websocket Endpoint(端点)，注册成为Websocket bean。 * 要注意，如果项目使用外置的servlet容器，而不是直接使用springboot内置容器的话，就不要注入ServerEndpointExporter，因为它将由容器自己提供和管理。 */ @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } } 2、WebSocketServer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccee947bb30a8079cf8c41d70bcd2a11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/530bd252e655024c305617890b869a9a/" rel="bookmark">
			【MATLAB】小波_LSTM神经网络时序预测算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有意向获取代码，请转文末观看代码获取方式~也可转原文链接获取~
1 基本定义 小波-LSTM神经网络时序预测算法是一种结合了小波变换和长短期记忆神经网络（LSTM）的时间序列预测方法。
小波变换是一种信号处理方法，能够将信号分解为不同频率和尺度的分量，并对每个分量进行时频分析。通过小波变换，可以将时间序列数据转化为小波系数，这些系数可以更好地表示时间序列中的复杂模式和趋势。
LSTM是一种深度学习中的流行方法，尤其在处理长时间序列相关问题上具有独特优势。LSTM的内部结构由遗忘门、输入门、输出门和存储单元组成，通过这些门控单元的相互作用，LSTM能够学习到时间序列中的长期依赖关系。
小波-LSTM算法的基本思路是将原始时间序列通过小波变换进行分解，将小波系数作为LSTM的输入，利用LSTM模型对每个系数进行预测。通过构建多个独立的LSTM模型，每个模型都有不同的初始化条件和参数设置。每个LSTM模型都会对时间序列进行训练和预测，最后将它们的预测结果进行综合，例如通过平均或加权平均的方式得到最终的预测结果。
小波-LSTM算法的优势在于通过小波变换提取时间序列中的复杂模式和趋势，并利用LSTM学习这些模式和趋势的长期依赖关系。小波变换能够处理非线性、非平稳信号，而LSTM能够学习到时间序列中的长期依赖关系，进一步提高预测的准确性和稳定性。
在实际应用中，小波-LSTM算法可以应用于各种领域，如金融市场预测、气象预报、能源消耗预测等。需要注意的是，该算法也存在一些潜在的局限性，例如计算复杂度高、需要大量数据等。因此，在使用该算法时需要根据实际需求进行适当的调整和优化。
2 出图效果 附出图效果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b124b35ba90386c3c420efc7425fd3/" rel="bookmark">
			IC基础——如何用verilog编写半加器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		半加法器是一种基本的组合设计，可以将两个单位和结果相加到一个总和中，并将进位作为输出。
框图
真值表
输出：
S = A ^ B
Cout = A ·B
由于半加法器只考虑两个位，因此除了添加两个单位外，它不能容纳先前生成的结果中的额外进位。因此，它被称为半加法器。一个完整的加法器被设计用于容纳上一级的额外进位。
半加法器Verilog代码 module half_adder(input a, b, output s, Cout); assign S = a ^ b; assign Cout = a &amp; b; endmodule testbench代码 module tb_top; reg a, b; wire s, c_out; half_adder ha(a, b, s, c_out); initial begin $monitor("At time %0t: a=%b b=%b, sum=%b, carry=%b",$time, a,b,s,c_out); a = 0; b = 0; #1; a = 0; b = 1; #1; a = 1; b = 0; #1; a = 1; b = 1; end endmodule 输出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1b124b35ba90386c3c420efc7425fd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38b5c6c0b01860360dc06a3f4b96947f/" rel="bookmark">
			Linux与Windows下追踪网络路由：traceroute、tracepath与tracert命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在进行网络诊断或排查问题时，了解数据包从源主机到目标主机之间的具体传输路径至关重要。Linux系统提供了traceroute和tracepath工具来实时显示链路路径信息，而Windows则使用了tracert命令实现相同的功能。本文将详细介绍这三个命令的用法及其在不同操作系统中的应用。
1. Linux下的traceroute命令 在Linux环境下，traceroute是一个常用的网络诊断工具，用于跟踪IP数据包在网络中从本地主机到目标主机所经过的路由节点（路由器或网关）。它通过逐步增加数据包的生存时间（TTL）值，并监听沿途路由器对超时或不可达数据包的ICMP响应，从而获取整个路径信息。
traceroute [选项] 目标地址 例如：
traceroute 8.8.8.8 其中，8.8.8.8是Google公共DNS服务器的IP地址，可以替换为任何你想要追踪的目标地址。
2. Linux下的tracepath命令 tracepath是Linux系统中的另一个路由探测工具，相较于traceroute，它在IPv6环境下的表现更为出色，并且不依赖于特定类型的ICMP消息，因此在某些网络环境中可能更可靠。
tracepath [选项] 目标地址 同样以Google DNS为例：
tracepath 8.8.8.8 3. Windows下的tracert命令 在Windows操作系统中，对应功能的命令名为tracert，其工作原理与Linux下的traceroute类似，都是通过调整数据包的TTL值并分析返回的ICMP错误消息来描绘出通往目标主机的完整路径。
tracert [选项] 目标地址 在CMD命令提示符中执行：
tracert 8.8.8.8 示例输出解读 无论使用traceroute、tracepath还是tracert，命令执行后都会显示出一系列跃点（hop），每行代表一个网络设备，包括：
跃点编号（Hop）设备的IP地址或域名数据包往返该跃点所需的时间（通常显示三次尝试的平均值） 这些信息可以帮助网络管理员识别潜在的问题区域，如延迟过高、路由错误等。
总结来说，在不同操作系统上追踪数据包路由的过程虽然命令名称各异，但核心原理一致，均为揭示网络通信过程中数据包的详细传输路径，为网络优化和故障排查提供关键线索。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ebeb51ca15778267a4d7480792ea056/" rel="bookmark">
			JS-基础语法（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript简单介绍
变量
常量
数据类型
类型转换
案例
1.JavaScript简单介绍 JavaScript 是什么？ 是一种运行在客户端（浏览器）的编程语言，可以实现人机交互效果。
JS的作用 JavaScript的组成 JS=ECMAScript( 基础语法 )、web APIs （DOM、BOM）
权威网站： MDN（百度搜索）
JavaScript权威网站： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript
JavaScr书写(引入方式)位置？ js的引入方式基本和css差不多，也是分成三种，分别是内部，外部，内联
注意：
我们将 &lt;script&gt; 放在HTML文件的底部附近的原因是浏览器会按照代码在文件中的顺序加载 HTML。
如果先加载的 JavaScript 期望修改其下方的 HTML，那么它可能由于 HTML 尚未被加载而失效。因此，将 JavaScript 代码放在 HTML页面的底部附近通常是最好的策略。
注意：
1. script标签中间无需写代码，否则会被忽略！
2. 外部JavaScript会使代码更加有序，更易于复用，且没有了脚本的混合，HTML 也会更加易读，因此这是个好的习惯。
常用的是内部和外部，内联只在特定的场景使用 JavaScript 输入输出语法 --这个常用，需要背下来 输入：使用prompt()函数
输出：1 console.log(提示信息) ---控制台输出信息
2 document.write() --会在网页的内容部分输出信息
3 alert() --使用alert()函数以提示框的形式输出内容
输入：
作用：显示一个对话框，对话框中包含一条文字信息，用来提示用户输入文字
展示：
输出：
注意：
JavaScript 代码执行顺序： Ø 按HTML文档流顺序执行JavaScript代码
Ø alert() 和 prompt() 它们会跳过页面渲染先被执行（目前作为了解，后期讲解详细执行过程）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ebeb51ca15778267a4d7480792ea056/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31c9724c1b63befdc32455d5b5f86902/" rel="bookmark">
			Android简单控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.文本显示 设置文本内容的两种方式：
在XML文件中通过属性 android:text 设置文本
&lt;resources&gt; &lt;string name="app_name"&gt;chapter03&lt;/string&gt; &lt;string name="hello"&gt;你好，世界&lt;/string&gt; &lt;/resources&gt; &lt;TextView android:id="@+id/tv_hello" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/hello"/&gt; 在Java代码中调用文本视图对象的 setText 方法设置文本
@Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_text_view); TextView tv_hello = findViewById(R.id.tv_hello); //tv_hello.setText("你好，世界"); tv_hello.setText(R.string.hello); } 设置文本的大小：
在Java代码中调用setTextSize方法，即可指定文本的大小
@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_text_size); TextView tv_px = findViewById(R.id.tv_px); tv_px.setText(30); } 在XML文件中则通过属性android:textSize指定文本大小，此时需要指定字号的单位
px：它是手机屏幕的最小显示单位，与设备的显示屏有关dp：它是与设备无关的显示单位，只与屏幕的尺寸有关sp：它专门用来设置字体的大小，在系统设置中可以调整字体的大小 &lt;TextView android:id="@+id/tv_px" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/hello" android:textSize="30px"/&gt; &lt;TextView android:id="@+id/tv_dp" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/hello" android:textSize="30dp"/&gt; &lt;TextView android:id="@+id/tv_sp" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31c9724c1b63befdc32455d5b5f86902/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee49fc6f2ae9d75b45c7a57f57ad460/" rel="bookmark">
			图片自适应各种设备尺寸
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 设置响应式图片:
在HTML中，你可以使用&lt;picture&gt;元素或srcset属性来为不同的设备和视口尺寸提供不同的图片版本。&lt;picture&gt;元素允许你根据不同的条件（如浏览器支持、视口宽度等）提供多种媒体资源。srcset属性允许你指定多个图像版本，浏览器会根据设备能力和视口宽度选择合适的版本。 复制代码
html`&lt;!-- 使用 &lt;picture&gt; 元素 --&gt; &lt;picture&gt; &lt;source srcset="large.jpg" media="(min-width: 1000px)"&gt; &lt;img src="small.jpg" alt="描述"&gt; &lt;/picture&gt; &lt;!-- 使用 srcset 属性 --&gt; &lt;img srcset="small.jpg 500w, medium.jpg 1000w, large.jpg 2000w" sizes="(max-width: 500px) 500px, (max-width: 1000px) 1000px, 2000px" src="fallback.jpg" alt="描述"&gt;` 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d69e0e67e76d1996e3993697f5e38fc3/" rel="bookmark">
			uniapp微信小程序投票系统实战 (SpringBoot2&#43;vue3.2&#43;element plus ) -投票创建后端实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		锋哥原创的uniapp微信小程序投票系统实战：
uniapp微信小程序投票系统实战课程 (SpringBoot2+vue3.2+element plus ) ( 火爆连载更新中... )_哔哩哔哩_bilibiliuniapp微信小程序投票系统实战课程 (SpringBoot2+vue3.2+element plus ) ( 火爆连载更新中... )共计21条视频，包括：uniapp微信小程序投票系统实战课程 (SpringBoot2+vue3.2+element plus ) ( 火爆连载更新中... )、第2讲 投票项目后端架构搭建、第3讲 小程序端 TabBar搭建等，UP主更多精彩视频，请关注UP账号。https://www.bilibili.com/video/BV1ea4y137xf/新建Vote投票类:
package com.java1234.entity; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.annotation.TableName; import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import lombok.Data; import java.util.Date; import java.util.List; /** * 投票实体 * @author java1234_小锋 （公众号：java1234） * @site www.java1234.vip * @company 南通小锋网络科技有限公司 */ @TableName("t_vote") @Data public class Vote { private Integer id; // 编号 private String title; // 标题 private String explanation; // 投票说明 private String coverImage; // 封面图片 @JsonSerialize(using=CustomDateTimeSerializer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d69e0e67e76d1996e3993697f5e38fc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b656abd92b86e6bad9ccaac7d45c791/" rel="bookmark">
			设计模式之状态模式【行为型模式】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档&gt; 学习的最大理由是想摆脱平庸，早一天就多一份人生的精彩；迟一天就多一天平庸的困扰。各位小伙伴，如果您：
想系统/深入学习某技术知识点…
一个人摸索学习很难坚持，想组团高效学习…
想写博客但无从下手，急需写作干货注入能量…
热爱写作，愿意让自己成为更好的人…
文章目录 前言一、概述二、结构三、案例实现四、优缺点五、使用场景总结 前言 一、概述
二、结构
三、案例实现
四、优缺点
五、使用场景
一、概述 【例】通过按钮来控制一个电梯的状态，一个电梯有开门状态，关门状态，停止状态，运行状态。每一种状态改变，都有可能要根据其他状态来更新处理。例如，如果电梯门现在处于运行时状态，就不能进行开门操作，而如果电梯门是停止状态，就可以执行开门操作。
类图如下：
代码如下：
public interface ILift { //电梯的4个状态 //开门状态 public final static int OPENING_STATE = 1; //关门状态 public final static int CLOSING_STATE = 2; //运行状态 public final static int RUNNING_STATE = 3; //停止状态 public final static int STOPPING_STATE = 4; //设置电梯的状态 public void setState(int state); //电梯的动作 public void open(); public void close(); public void run(); public void stop(); } public class Lift implements ILift { //声明一个记录当前电梯的状态 private int state; @Override public void setState(int state) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b656abd92b86e6bad9ccaac7d45c791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee64ca4093f2aafbf30e6db3480ee9ec/" rel="bookmark">
			Excel使用pandas拆分单元格扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需要：
1. anconda环境
2. excel文件，有拆分标准的单元格内容（比如我此次的：**, ***, ****,...)
以前尝试自己写公式，唉😔，不是写不出来，就是太折腾了
3. 2行code，超级cool😎
# 拆分 new_data = df['关键字'].str.split(',', expand=True).stack().reset_index(level=1, drop=True).rename('new_column_name') new_data.shape # 合并 result = df.drop('关键字',axis=1).join(new_data) # 输出 result.to_excel("拆分后.xlsx", index=False) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a33b9c1392315d6278e4fb0aa01c1ed/" rel="bookmark">
			统计数据集句子长度信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在文本分类任务做科研写论文的时候，我们有时候需要对对数据集的大小进行分析，如果你想统计CSV文件中某一列英语句子的单词个数（不包含标题），可以使用Python的split()函数将句子拆分为单词，并计算单词的个数，具体实现代码和结果分析如下。
目录
一、Python实现 二、测试结果
一、Python实现 import csv # 读取CSV文件 filename = 'your_file.csv' # 请替换成你的CSV文件路径 with open(filename, 'r', newline='', encoding='utf-8') as csvfile: reader = csv.reader(csvfile) next(reader) # 跳过标题行 word_counts = [len(row[1].split()) for row in reader] # 假设你想要获取第二列句子的单词个数 # 统计单词个数 total_sentences = len(word_counts) average_words = sum(word_counts) / total_sentences # 打印结果 print("句子总数:", total_sentences) print("平均单词数:", average_words) 二、测试结果 下面对一个英文句子长度统计，按照上述方法
print(len('watching and loving the Thunderbirds.'.split())) 输出结果：5 ，是正确的
同时我用上述方法统计GLUE等相关数据集的训练集和测试集平均长度结果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4ee22a930509b875cd2227b96a1c160/" rel="bookmark">
			星筱授权系统源码有后台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		星筱授权管理系统有后台
随便一台主机就可以运行起来
安装教程：
先把源码导入服务器解压
解压之后访问域名 /install 进行安装即可
后台路径：http:// 域名 /admin
账号密码是你自己设置的，
完事后再修改以下两个数据库连接文件
\admin\home\index.php
\api\sqzt.php
星筱授权系统源码有后台 - 百创网-源码交易平台_网站源码_商城源码_小程序源码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/962efe95bc2daaa33022636efa5edb4c/" rel="bookmark">
			服务器哪家便宜？阿里云下场开撕
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云服务器哪家便宜？截止到目前2024年1月还得是阿里云！阿腾云atengyun.com对比国内头部云厂商阿里云、腾讯云和华为云，仅对比了入门级2核2G3M云服务器，阿里云2核2G3M轻量应用服务器不限制流量一年61元，云服务器只说入门级配置，隔壁腾讯云2核2G3M轻量应用服务器是62元一年，但是限制200GB月流量，华为云2核2G3M服务器是88元一年，其他的配置大家自行对比吧：
便宜云服务器阿里云腾讯云华为云
阿里云 https://t.aliyun.com/U/bLynLC腾讯云 https://curl.qcloud.com/oRMoSucP华为云 atengyun.com/go/huawei 另外，阿里云还推出一款新老用户均可购买的云服务器，ECS云服务器e系列2核2G、3M固定带宽、40G ESSD Entry云盘，99元一年，续费也是99元一年。这个老用户可以买的优惠政策，并且续费不涨价，无人能敌，大家直接移步到上方活动查看吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c00967d5cb74031bb8eb8f5029eadfb/" rel="bookmark">
			Flink/Doris生产环境方案选型的一些思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位总监，技术负责人，架构师们大家好。今天的文章有点短，是一些个人思考，仅做记录。
以Flink为主的计算组件和以Doris为代表的存储+计算一体的方案选择问题是我们在技术选型过程中最常见的问题之一。也是很多公司和业务支持过程中会遇到的问题。
这个问题非常「实在」也很「接地气」，因为这些技术选型问题在生产环境客观存在，更关系稳定性和成本问题。
如果大家在面试中被问到了，也是一个很好的问题。
问题和思考 目前很多公司的大部分业务完全基于Flink计算引擎来搭建实时数据链路，尤其是在大流量/较为复杂业务背景/强时效性场景中，无论是做关联，还是做指标分析，都有明显优势，Flink在这些场景不可替代。但是在一些场景中，也存在很多问题，我们随便举几个例子：
复杂的多表关联分析，在Flink中实现较为完美的多源关联/多维度表关联比较困难
这个场景相信大家都遇到过，在多源/大数据规模下做实时任务，要考虑的问题太多太多，一不小心就会踩坑，比如大家经常遇到的join key热点问题，TTL问题；维度表本身也会遇到查询瓶颈，所以又会带来缓存和限流问题等；
指标口径频繁变更
这个大家应该不陌生，在Flink中直接生产多指标，这个任务会变得非常敏感，因为你大概率会遇到状态不兼容问题、数据回溯问题，主备任务的测试切换问题等等，简直不要太离谱；
小规模非核心场景
在Flink侧做这类任务有点杀鸡用牛刀的意思，成本较高，投入产出比也很低；
所以如果我们的场景是完全基于Flink为主+OLAP查询为辅助的场景，他的优势很明显，劣势也暴露无疑。
换个思路 所以，在上面的一些场景下，不妨换个思路。我们把计算和存储下移到OLAP侧，利用Doris/StarRocks等数据库的能力，降低数仓链路的开发和维护成本。
我们用Doris作为核心存储和计算介质，主要面向近实时场景。如果建立这样的目标，我能想到的几点要做的：
开发和测试平台
这个不用详细展开，相当于开发换成了Doris SQL；
数据建模工具
例如表元数据、维度指标管理、Doris建模推荐等；
数据质量
也要做质量检测和准入机制；
数据治理
例如表的热度、慢sql检测、成本、权限问题。
综合来看 基于上面两个大的思路，我们都可以基于他们做一体化解决方案平台。当然很多公司多多少少都会这么去做，只是处在的发展阶段不同。
这样的话，我们在综合考虑业务场景、数据规模、开发和迭代成本后，技术方案就可以在两个大方向上做灵活选择。
300万字！全网最全大数据学习面试社区等你来！
如果这个文章对你有帮助，不要忘记 「在看」 「点赞」 「收藏」 三连啊喂！
2022年全网首发|大数据专家级技能模型与学习指南(胜天半子篇)
互联网最坏的时代可能真的来了
我在B站读大学，大数据专业
我们在学习Flink的时候，到底在学习什么？
193篇文章暴揍Flink，这个合集你需要关注一下
Flink生产环境TOP难题与优化，阿里巴巴藏经阁YYDS
Flink CDC我吃定了耶稣也留不住他！| Flink CDC线上问题小盘点
我们在学习Spark的时候，到底在学习什么？
在所有Spark模块中，我愿称SparkSQL为最强！
硬刚Hive | 4万字基础调优面试小总结
数据治理方法论和实践小百科全书
标签体系下的用户画像建设小指南
4万字长文 | ClickHouse基础&amp;实践&amp;调优全视角解析
【面试&amp;个人成长】2021年过半，社招和校招的经验之谈
大数据方向另一个十年开启 |《硬刚系列》第一版完结
我写过的关于成长/面试/职场进阶的文章
当我们在学习Hive的时候在学习什么？「硬刚Hive续集」
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65b4d5ae0ec11d69b4f69f40794a0801/" rel="bookmark">
			SSL安全证书普及
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，我们来了解一下什么是SSL安全证书。SSL安全证书是一种遵循SSL协议的数字证书，由受信任的第三方机构——认证中心（CA）颁发，其主要功能是为互联网通信提供加密处理，确保在用户浏览器和服务器之间传输的信息不被窃取或篡改，实现信息传输的安全性和完整性。
SSL安全证书的核心价值在于它能对网站的身份进行验证，并通过加密技术保护用户的敏感信息，如账号密码、交易详情等。当用户在浏览器地址栏看到“https”开头并显示小锁标志时，就意味着该网站已经部署了SSL证书，此时的数据传输过程处于加密状态，有效防止了中间人攻击、数据泄露等问题。
随着全球信息化进程的加速推进，个人隐私保护和网络安全意识不断提升，SSL安全证书的普及显得尤为迫切。无论是大型企业、电商平台，还是各类政府公共服务网站，乃至个人博客、论坛等，都应该积极部署SSL证书，以满足用户对于信息安全的需求，同时也能提高自身网站的信任度和专业形象。
此外，主流搜索引擎已明确表示会优先展示使用了HTTPS（基于SSL的HTTP协议）的网站，这无疑从SEO优化的角度进一步推动了SSL安全证书的普及。
免费SSL证书申请https://www.joyssl.com/certificate/select/free.html?nid=5
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5596e86a8e5c2c2d7d4280ec897f056/" rel="bookmark">
			一点点的错误就可以导致问题发生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bat文件：
本地执行ok，执行完查设备管理器，固件版本就已变化
远程执行，可以执行，执行完报错
1. Something went wrong, but the devicedoes not know what it was --》把bat里的timeout 注释掉，就会报此错误（timeout /t 5），实际上是没有进行等待，改成ping 就好了
2. 之前的脚本，实际也改为了ping，但是因为最后一个 输入参数-v 写成了 -u，导致实际执行失败
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/add4b18dc076d673fa3c999f9157b426/" rel="bookmark">
			工业自动化中RFID标签的应用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RFID标签是实现RFID数据采集的重要载体，利用RFID标签，可以将所有产品的信息写入标签中，大部分的RFID标签都以不干胶标签的形式使用，只需要在物品包装上贴RFID标签就可以。下面我们就一起来了解一下，工业自动化中RFID标签的应用案例有哪些。
工业自动化中RFID标签的应用案例
在工业领域中应用RFID标签时需要录入信息，在数据库中将物品的相关信息录入到相对应的RFID标签项中。将物品与相对应的信息编辑整理，得到物品的原始信息和数据库，便于后续的数据采集和产品识别。
1、自动化生产线管理
将RFID电子标签安装在产品或载体上，在生产线的工位节点安装RFID工业读写器，当产品经过工位时，读写器就可读取到标签内的信息，将产品型号、规格、数量等相关信息记录在标签内。
2、工序检查
RFID工业读写器可读取产品的RFID标签信息，核对生产工序是否准确无误，若有遗漏则可踪遗漏工序，将产品进行返工处理，若工序正确则生产完成。
3、生产溯源管理
产品生产完成后，系统生成生产条码，条码标识作为唯一标识码存进数据库，为以后的产品湖源提供依据，并将RFID标签与生产物料解绑，使用RFID读写器重新读写RFID标签即可重复使用该RFID标签。
ANDEAWELL高频工业读写器AR2201采用Modbus通信协议的中功率长条形读头，基于稳定的中功率HF射频模块，具备高稳定的读写性能，工作频段为13.56MHz，支持对 NXP I-CODE 2、I-CODE SLI等符合 ISO15693国际标准协议格式标签的读取，可在 生产作业自动化生产线、自动化分拣系统、零部件组装产线等工业领域应用！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbbcbffb25eb2058b8dd6a2063651443/" rel="bookmark">
			如何彻底卸除Microsoft Edge浏览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 卸载Microsoft Edge浏览器可以有不同的方法，但需要注意的是，如果你使用的是Windows 10或更高版本的操作系统，Edge浏览器是作为系统的一部分而集成的，因此完全卸载可能会比较复杂，甚至可能影响系统的稳定性。以下是一些可能的方法：
方法1：使用系统设置（仅限旧版本Edge） 如果你的电脑上安装的是旧版本的Edge，可以尝试以下步骤：
打开“设置”。点击“应用”。在应用列表中找到Microsoft Edge。如果提供了卸载选项，点击它并按照提示操作。 方法2：使用命令提示符 对于新版的Edge（基于Chromium），你可能需要使用更高级的方法：
首先，打开命令提示符（管理员）。
Win 键盘+R ，然后输入CMD ，并用鼠标右键选择以管理员身份运行。 输入以下命令：
cd %PROGRAMFILES(X86)%\Microsoft\Edge\Application\&lt;Edge版本号&gt;\Installer 注意替换&lt;Edge版本号&gt;为你电脑上的实际版本号。
3.然后输入：
setup.exe --uninstall --system-level --verbose-logging --force-uninstall 4.按回车执行命令。
方法3：使用第三方软件 还有一些第三方软件可以帮助卸载难以移除的程序，例如Revo Uninstaller、Geek Uninstaller等。这些工具通常提供更深层次的卸载选项。
注意事项 在尝试卸载Edge之前，请确保你已经备份了重要数据。卸载系统集成的浏览器可能会导致某些依赖于它的功能或应用出现问题。在某些情况下，卸载后可能需要重启电脑。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2900eea4bf02ef565093b11d46ec3aac/" rel="bookmark">
			PPT插件-大珩助手-倒计时增加姓名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 姓名+倒计时 为方便使用同一台电脑进行计时，需要对不同的计时器进行区分，因此在原有的计时器上增加了可编辑的姓名，方便多人计时使用。
软件介绍 PPT大珩助手是一款全新设计的Office PPT插件，它是一款功能强大且实用的PPT辅助工具，支持Wps Word和Office Word，能够轻松帮助您修改、优化和管理幻灯片。凭借丰富的功能和用户友好的界面，PPT大珩助手能够助力您打造出精美而专业的演示文稿。我们致力于为用户提供卓越的使用体验，始终倾听用户的反馈和建议，不断改进和创新，以满足您的各种需求。相信通过使用PPT大珩助手，您能够高效而愉悦地完成幻灯片制作任务，并展示出令人印象深刻的演示效果。
另外还有Word大珩助手。
下载地址 网盘下载：大珩助手
密码:acaq
功能预览 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b62226ac28683bb433b6b7877fcada2e/" rel="bookmark">
			什么是TSN？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TSN（Time-Sensitive Networking）是在非确定的以太网中实现确定性的最小时延协议族，是IEEE 802.1开发的一套协议标准。为以太网协议的数据链路层提供一套通用的时间敏感机制，为标准以太网提供了确定性和可靠性，以确保数据实时、确定和可靠地传输，提高数据传输效率。此外，TSN能实现时间敏感性（对实时性要求高）数据和非时间敏感性数据在同一网络的传输。
什么是TSN? TSN的重要协议是什么？ - 华为 (huawei.com)
TSN的重要协议是什么？ 传统以太网会采用载波侦听多路访问/冲突检测（CSMA/CD)的机制，当两个工作站发生冲突时，必须延迟一定时间后重发报文。
发生堵塞时，有的报文可能长时间发布不出去，造成通信时间的不确定性。以往对实时性要求高的数据通过实时以太网去实现。故现在信息技术和运营技术融合过程中会遇到很大的困难，为了实现部分数据传输的实时、确定性需求，有实时性要求的数据和没有实时性要求的数据往往需要通过两个网络进行传输。所有的控制器都是两个网口，一个是实时以太网，一个是标准以太网。
而TSN不仅能确保数据的实时、确定性传输，还能实现时间敏感数据和非时间敏感性数据在同一网络的传输。
TSN通过一套协议标准（TSN协议族）来实现数据在同一网络的实时、确定性传输，保证对实时性要求高的信息在标准以太网的不同场景下的顺利传输。TSN协议族本身具有很高的灵活性，用户可以根据应用的具体需求来选择相应的协议组合。
TSN协议族包含了时钟同步、数据调度及流量整形、可靠性、资源管理这四个类别的子协议。
时钟同步 与IEEE 802.3 的标准以太网相比，时钟在TSN 网络中起着重要的作用。对于实时通信而言，端到端的传输延迟具有难以协商的时间界限，因此TSN 中的所有设备都需要具有共同的时间参考模型，因此需要彼此同步时钟。目前TSN采用IEEE 1588 协议和IEEE 802.1AS协议来实现时间同步。
IEEE 1588 协议是一个精密时间协议 (PTP)，用于同步计算机网络中的时钟。 在局域网中，它能将时钟精确度控制在亚微秒范围内，使其适用于测量和控制系统。
数据调度及流量整形 TSN通过定义不同的整形机制将数据流的时延限定在一定范围内，以此满足不同的低时延场景需求。在传统以太网中，数据流的通信时延是不确定的，由于这种不确定性，数据接收端通常需要预置大缓冲区来缓冲输出，但是这样会导致数据流，例如音视频流，缺失了实时方面的特性。
TSN不仅要保证时间敏感流的到达，同时也要保证这些数据流的低时延传输。通过优化控制时间敏感流和best-effort流、以及其它数据流在网络中的传输过程，来保证对数据流的传输时间要求，这个优化控制的方式就是整形。
TSN用于数据调度和流量整形的协议有IEEE 802.1Qav、IEEE 802.1Qbv、IEEE 802.1Qbu、IEEE 802.1Qch及IEEE 802.1Qcr。
其中，IEEE 802.1Qbv采用非抢占式的的数据调度，流量调度方式通过时隙进行控制，需要实时传输的数据流优先传输，同时为best-effort数据及预留数据预留带宽，允许时间敏感流和非时间敏感流在同一个网络中传输，并确保数据的实时传输。
如下图（IEEE 802.1Qbv时隙划分图），使用IEEE 802.1Qbv，数据包传输被安排在一个重复周期中端到端。
IEEE 802.1Qbv中定义了三种基本类型的流量：
时间敏感流best-effort流预留流量 时间敏感流适用于对实时性要求严格的关键消息， best-effort流是不需要任何QoS 的一般以太网流量。 此外，预留流量适用于需要预留特定带宽并具有软实时要求的帧。
IEEE 802.1Qbv定义了通过调度算法启用或禁用帧传输的门，将以太网通信划分为固定长度、连续重复的周期。这些周期被分成时隙，在每个时隙中，数据通过被赋予不同的优先级实现在指定时隙中的传输。由于此操作，时间敏感流可以拥有专用时隙，从而确保此流量在传统以太网网络上的确定性传输。另一方面，预留流量和best-effort流被容纳在每个周期的剩余时隙中。预留流量保证有专用带宽，而best-effort流可以使用剩余的带宽。
图中时隙1为时间敏感流预留，时隙期间不存在其他流量。另一方面，时隙2由best-effort流和预留流量使用，同时为预留流量预留专用带宽。
由于TSN的运行基于不同的时间时隙发送不同类型的流量，因此所有网络设备必须在纳秒级范围内同步。- 可靠性 对数据传输实时性要求高的应用除了需要保证数据传输的时效性，同时也需要高可靠的数据传输机制，以便应对网桥节点失效、线路断路和外部攻击带来的各种问题，来确保功能安全和网络安全。IEEE 802.1Qci、IEEE 802.1CB及IEEE 802.1Qca用于实现TSN这方面的性能。
IEEE 802.1CB为以太网提供双链冗余特性，通过在网络的源端系统和中继系统中对每个数据帧进行序列编号和复制，并在目标端系统和其他中继系统中消除这些复制帧，确保仅有一份数据帧被接收。可用来防止由于拥塞导致的丢包情况，也可以降低由于设备故障造成分组丢失的概率及故障恢复时间，提高网络可靠性。
资源管理 在TSN网络中，每一种实时应用都有特定的网络性能需求。使能TSN网络的某个特性是对可用的网络资源进行配置和管理的过程，其允许在同一网络中通过配置一系列TSN子协议，来合理分配网络路径上的资源，以确保它们能够按照预期正常运行。TSN资源管理子协议包括IEEE 802.1Qat协议和IEEE 802.1Qcc协议。IEEE 802.1Qcc协议是IEEE802.1Qat协议的增强。
IEEE802.1Qat即流预留协议。根据流的资源要求和可用的网络资源情况指定数据准入控制，保留资源并通告从数据源发送端至数据接收端之间的所有网络节点，确保指定流在整条传输路径上有充足的网络资源可用。
TSN的应用场景是什么？ TSN的典型应用就是工业互联网，传统的工业自动化实现通过在每个接入网侧均采用硬编码逻辑控制器（硬PLC）及人机交互界面（HMI）实现对机器人、夹具的控制来实现工业自动化。每个接入网侧都需要相应的硬PLC分散地处理业务，使得管理困难，运维复杂，如下图（传统工业园区解决方案）。而且生产线往往变更频繁，硬PLC由于采用硬编码，其生产扩展不灵活，生产线变更时需要耗费很大的资源去进行生产线的适配和调测。
若将PLC直接接入到工厂数据中心，就可以采用软件编码的虚拟PLC（vPLC），如下图（传统工业园区解决方案vs采用TSN网络园区工业解决方案）融合架构的IT基础设施平台（FushionCube）上的vPLC，一方面可实现对生产设备的远程集中处理。另一方面，vPLC通过软件编程就可以完成对生产线的适配，生产扩展灵活。但工厂数据中心往往统一纳管信息技术和运营技术，生产业务流和办公业务流及其它数据流均需通过同一网络上送到工厂数据中心，而且工业自动化控制对数据流的确定性到达有毫秒级的需求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b62226ac28683bb433b6b7877fcada2e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/14/">«</a>
	<span class="pagination__item pagination__item--current">15/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/16/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>