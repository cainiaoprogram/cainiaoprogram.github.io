<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c142d50258ca60e77746222741759b7/" rel="bookmark">
			jilnk 错选芯片内核导致的No Cortex-M SW Device问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一时间手快，使用jlink选择芯片时将内核选成ARM7了，导致了程序下载错误。如下图所示。
我检查了下keil里的设置并没有修改芯片内核选项。多方查找，终于发现了问题所在。需要在工程目录下修改jlink的配置文件。
找到jLinksettings.ini 配置文件，以及JLINKLog.txt文件。删除这两个文件，并重启keil可重新配置。
keil中会重新跳出选择内核界面。当然你直接修改ini文件也可以。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/738dcd1e9aa5417395249caeae981eb3/" rel="bookmark">
			【K8S 云原生】Pod资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、pod概述：
1、pod概念
2、pod的分类：
二、 pause容器
1、pause容器概念：
2、创建pod的流程：
3、pause容器的作用：
4、pause总结：
三、pod的生命周期：
1、pod的状态：
2、pod的生命周期过程：
3、创建一个pod容器过程：
4、init容器的作用：
5、pod的重启策略
6、总结：
一、pod概述： 1、pod概念 pod是K8S中最小的资源管理组件
pod也是最小化运行容器化的应用的资源管理对象
pod是一个抽象的概念，可以理解为一个或者多个容器化应用的集合
在一个pod中运行一个容器是最常用的方式
在一个pod当中同时运行多个容器，一个pod中可以同时封装几个需要耦合的互相协作的容器
这些多个容器时共享资源，也可以互相协作，组成一个service单位。
不论是运行一个还是多个容器，K8S管理的都是pod而不是容器
一个pod内的容器，必须都运行在同一节点。
基于现代容器技术的要求，就是一个pod运行一个容器，一个容器运行一个进程
这样做的目的：
横向扩展，方便扩缩容解耦，一个pod内运行多个容器，耦合度太高，一旦一个进程失败，整个pod将全部失败。一个pod运行一个容器，可以实现解耦，可以创建多个副本，实现高可用和负载均衡管理方面，简单直观 2、pod的分类： 自主式pod：pod不会自我修复，如果pod内容器的进程终止，或者被delete删除、缺少资源被驱逐，这个pod没有办法自愈（只要不是基于控制器创建的都是自主式pod）控制器管理pod：可以滚动升级，可以自愈（自动重启），可以管理pod的数量，以及扩缩容 二、 pause容器 1、pause容器概念： pod内的容器共享资源。
共享机制：pause底层基础容器来提供共享资源的机制
pause容器时基础容器，也可以称为父容器。作用就是管理pod内容器的共享操作
pause还可以管理容器的生命周期
K8S提供了pause容器作用：
为pod内的所有容器提供一个命名空间启动容器的PID命名空间，每个pod中都作为PID为1的进程（init进程），回收僵尸进程创建pod时，先创建pause容器，然后拉取镜像，生成容器，形成pod（容器不是由pod管理，而是由pause管理容器的进程） pause相当于pod的基础容器，先有pause再有pod
kubelet 是负责管理整个 Pod 中所有容器的组件，包括pause容器。pause容器在这里充当一个辅助角色，为其他容器提供共享的运行环境。
创建一个nginx pod的过程：先拉取pause容器，在拉取nginx镜像，容器跑起来，pause管理
销毁pod：先销毁nginx，pause回收容器资源，kubelet销毁pause
pause是pod的基础，由pause管理pod内部的容器
总的来说kubelet管理节点上的pod，pause管理pod内的容器
2、创建pod的流程： 第一步：master节点发出指令，pod使用的镜像nginx，pod的副本数
第二步：scheduler来分配执行的node节点
第三步：node节点的kubelet收到master的指令，先拉pause，再拉nginx:1.22，指定副本数
第四步：pause容器先启动，提供命名空间，进程管理pid=1，来为pod内的容器提供共享服务以及容器的进程管理
3、pause容器的作用： 共享网络命名空间： 所有容器都共享同一个网络命名空间，它们可以通过 localhost 相互通信，而无需通过网络进行通信。
共享存储卷： 所有容器可以访问相同的存储卷，这使得它们之间可以共享数据。
维护 Pod 的生命周期： "pause" 容器的存在确保了 Pod 的运行。当 Pod 中的其他容器终止时，"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/738dcd1e9aa5417395249caeae981eb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea9989341f9d331b971aa564bc904792/" rel="bookmark">
			快速入门：使用 FastAPI 和 Docker 构建你的第一个 API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速入门：使用 FastAPI 和 Docker 构建你的第一个 API 编写 FastAPI 应用程序编写 Dockerfile构建 Docker 镜像运行 Docker 容器访问应用程序结论 引言：
FastAPI 是一个高性能的现代 Web 框架，而 Docker 是一个流行的容器化平台。本文将指导你使用 FastAPI 创建一个简单的 API，并将其容器化为 Docker 镜像，让你快速上手这两个强大的工具。
编写 FastAPI 应用程序 首先，在项目根目录下创建一个名为 main.py 的 FastAPI 应用程序文件：
from fastapi import FastAPI app = FastAPI() @app.get('/') def read_root(): return {'Hello': 'World'} 编写 Dockerfile 接下来，在同一目录下创建一个名为 Dockerfile 的文件：
# 使用官方 Python 3.8 镜像作为基础镜像 FROM python:3.8 # 设置工作目录为 /app WORKDIR /app # 复制当前目录下的所有文件到 /app COPY . /app # 安装 FastAPI 和 Uvicorn RUN pip install fastapi uvicorn # 容器对外暴露的端口 EXPOSE 8000 # 启动应用程序 CMD ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea9989341f9d331b971aa564bc904792/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c6963fc283b9765e70dd8c608c0af2d/" rel="bookmark">
			腾讯云域名费用（注册/续费/转入）com、cn多后缀域名报价
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云域名费用表com域名注册低至1元首年，cn后缀域名注册8.8元首年，本文包括腾讯云域名注册、域名续费、域名转入和域名赎回费用，域名后缀包括.com域名、.cn、.net、xyz、top等域名后缀，腾讯云百科txybk.com来详细说下腾讯云域名注册、第二年续费及域名从其他域名是转入到腾讯云的收费表：
腾讯云域名表
腾讯云域名费用表 腾讯云百科先来说下当前域名活动，在 https://curl.qcloud.com/HmjGZiLu 中，腾讯云企业新用户注册com域名首年1元，个人新用户注册com域名18元首年，注册cn域名8.8，如下图：
腾讯云域名专场特惠
在阿里云CLUB可以领取专属券aliyun.club 符合条件的订单可以抵扣。
下面腾讯云百科来详细说下不同域名后缀注册、续费和转入表：
腾讯云域名费用表 本文关于腾讯云域名多后缀注册、续费、转入及赎回，后缀包括com、cn、net、club、info等后缀一年及多年表：
域名注册费用续费费用转入费用赎回费用1年3年5年10年1年3年5年9年.top 站更高，看更远25元59元109元234元25元75元125元225元25元1000元.com 全球最受欢迎的域名75元201元341元691元70元210元350元630元50元800元.cn 更适合中国人的域名35元89元159元334元35元105元175元315元25元550元.xyz 创造无限可能41元146元284元629元69元207元354元621元40元800元.com.cn 国内顶级域名38元101元171元346元35元105元175元315元35元538元.club 专属您的俱乐部15元156元300元660元72元216元360元648元72元500元.中国 最具影响力的国际域名320元218元398元848元90元270元450元810元90元1520元.网址 让用户记住您的网址2800元7000元12600元26600元2800元8400元14000元25200元2800元2800元.work 有志者事竟成33元66元122元262元28元84元140元252元25元800元.vip 认真对待每一位客户25元85元155元295元30元90元150元270元30元1000元.beer 为生活干杯80元230元386元776元78元234元390元702元73元800元.在线 时刻在线，连接你我1980元5940元9900元19800元1980元5940元9900元17820元1800元2000元.net.cn 国内顶级域名38元101元171元346元35元105元175元315元35元538元.tv500元564元940元2400元188元564元940元1692元178元800元.cc79元177元295元590元59元177元295元531元59元800元.ac.cn 适合学术、教育机构38元107元183元373元38元114元190元342元38元538元.中文网 品牌与企业的中文网2800元8400元14000元28000元2800元8400元14000元25200元2800元3000元.info 向世界分享你的信息25元201元377元817元88元264元440元792元79元1000元.pro 展现专业态度21元195元371元811元88元264元440元792元88元500元.red 让您的品牌火爆全场29元192元368元808元88元264元440元792元88元2000元.网店 每间店都有自己的品牌1280元3840元6400元12800元1280元3840元6400元11520元1560元4000元.net 让企业走向国际化68元201元337元677元68元204元340元612元68元1000元.yoga 提高生活品质80元230元386元776元78元234元390元702元73元800元.fashion 表达您的时尚观点80元230元386元776元78元234元390元702元73元800元.luxe 展现华贵典雅的气质199元404元680元1370元138元414元690元1242元108元800元.love 让世界充满爱与和平158元474元790元1580元158元474元790元1422元158元800元.kim 寓意金、金牌29元211元407元897元98元294元490元882元88元2000元.blue 蓝色，最多人喜爱的颜色29元211元407元897元98元294元490元882元88元2000元.pet 适合宠物爱好者29元211元407元897元98元294元490元882元88元2000元.pink 表达您的浪漫及热情29元211元407元897元98元294元490元882元88元2000元.移动 移动互联网的标志78元274元470元960元98元294元490元882元88元2000元.ski 滑出更广阔的天地71元594元1170元2610元288元864元1440元2592元288元2000元.ltd 把你的公司搬上云端33元87元155元325元34元102元170元306元30元800元.chat 沟通是成功的基石60元160元272元552元56元168元280元504元30元800元.group 将志同道合的人聚在一起34元122元220元465元49元147元245元441元30元800元.pub 汇聚艺术家的社区34元122元220元465元49元147元245元441元30元800元.run 向前奔跑，从不妥协33元122元220元465元49元147元245元441元30元800元.city 同一座城市，同一种生活41元137元235元480元49元147元245元441元30元800元.live 全民参与的直播时代34元122元220元465元49元147元245元441元30元800元.ink 让您的创意展翅飞翔48元306元596元1321元47元141元235元423元45元800元.wiki 汇聚知识，与世界共享74元314元604元1329元70元210元350元630元66元800元.design 设计让生活更加优雅114元518元998元2198元115元345元575元1035元109元800元.email 不可或缺的电子邮件41元150元262元542元56元168元280元504元30元800元.company 全新的企业品牌50元132元224元454元46元138元230元414元30元800元.plus 体现更超前的理念34元122元220元465元49元147元245元441元30元800元.video 流媒体时代已经到来41元136元234元479元49元147元245元441元30元800元.center60元160元272元552元56元168元280元504元30元800元.cool33元119元215元455元48元144元240元432元30元800元.fund41元150元262元542元56元168元280元504元30元800元.gold42元136元234元479元49元147元245元441元30元800元.guru45元150元262元542元56元168元280元504元30元800元.life41元106元174元344元49元147元245元441元30元800元.show56元138元236元481元49元147元245元441元30元800元.team50元150元262元542元56元168元280元504元30元800元.today50元136元234元479元49元147元245元441元30元800元.world41元122元220元465元49元147元245元441元30元800元.zone34元122元220元465元49元147元245元441元30元800元.social41元150元262元542元56元168元280元504元30元800元.网站128元354元610元1250元128元384元640元1152元128元1000元.bio388元786元1562元3502元388元1164元1940元3492元388元1000元.black288元586元1162元2602元288元864元1440元2592元288元1000元.green398元806元1602元3592元398元1194元1990元3582元398元1000元.lotto9999元29997元49995元99990元9999元29997元49995元89991元9999元1000元.organic398元806元1602元3980元398元1194元1990元3582元398元1000元.poker298元606元1202元2980元298元894元1490元2682元298元1000元.promo98元206元402元892元98元294元490元882元98元1000元.vote398元1194元1990元3980元398元1194元1990元3582元398元1000元.archi398元1194元1990元3980元398元1194元1990元3582元398元1000元.voto398元1194元1990元3980元398元1194元1990元3582元398元1000元.online 将您的品牌上线49元88元128元198元49元147元245元441元49元1000元.site 站点必备域名49元88元98元178元49元147元245元441元49元1000元.store 您的品牌专门店58元98元128元198元58元174元290元522元58元1000元.tech 更具科技含量的域名49元116元214元459元49元147元245元441元49元1000元.fun 带来更多欢乐49元88元98元178元49元147元245元441元49元1000元.space 梦想从来没有边界41元88元98元178元41元123元205元369元41元1000元.host 互联网服务商首选41元117元199元404元41元123元205元369元41元1000元.press41元117元199元404元41元123元205元369元41元2000元.wang 定义王者风范41元108元190元395元41元123元205元369元40元800元.商店296元878元1470元2950元296元888元1480元2664元296元1000元.企业788元2264元3840元7780元788元2364元3940元7092元788元1000元.娱乐588元1734元2910元5850元588元1764元2940元5292元588元1000元.游戏558元1654元2770元5560元558元1674元2790元5022元558元1000元.fit80元230元386元776元78元234元390元702元73元800元.icu66元143元275元605元66元198元330元594元66元1000元.art72元216元360元720元72元216元360元648元72元1000元.website41元88元98元178元41元123元205元369元41元2000元.asia118元264元440元880元88元264元440元792元88元500元.org.cn35元101元171元346元35元105元175元315元30元538元.我爱你130元240元430元905元95元285元475元855元90元1200元.集团12000元36000元60000元120000元12000元36000元60000元108000元4500元25000元.biz99元299元499元999元100元300元500元900元99元1000元.games130元150元262元542元56元168元280元504元43元1000元.tax48元147元259元539元56元168元280元504元48元1000元.studio128元314元550元1140元118元354元590元1062元118元1000元.shopping130元150元262元542元56元168元280元504元43元1000元.media130元150元262元542元56元168元280元504元43元1000元.cash130元150元262元542元56元168元280元504元43元1000元.fyi48元147元259元539元56元168元280元504元48元1000元.vin48元147元259元539元56元168元280元504元48元1000元.sale45元147元259元539元56元168元280元504元45元1000元.mba48元147元259元539元56元168元280元504元48元1000元.band128元314元550元1140元118元354元590元1062元118元1000元.cab48元147元259元539元56元168元280元504元48元1000元.news128元314元550元1140元118元354元590元1062元118元1000元.cafe48元147元259元539元56元168元280元504元48元1000元.technology128元328元548元1098元110元330元550元990元100元1000元.market130元150元262元542元56元168元280元504元43元1000元.fans118元196元332元672元68元204元340元612元65元500元.ren118元100元170元345元35元105元175元315元33元800元.cloud110元230元450元1000元110元330元550元990元55元500元.co158元438元738元1488元150元450元750元1350元150元1000元.shop198元368元728元1628元180元540元900元1620元175元1000元.law2900元1764元2960元5950元598元1794元2990元5382元568元1000元.link118元128元238元513元55元165元275元495元52元1000元.bj.cn38元101元171元346元35元105元175元315元35元538元.tj.cn38元101元171元346元35元105元175元315元35元538元.sh.cn38元101元171元346元35元105元175元315元35元538元.cq.cn38元101元171元346元35元105元175元315元35元538元.he.cn38元101元171元346元35元105元175元315元35元538元.ha.cn38元101元171元346元35元105元175元315元35元538元.sx.cn38元101元171元346元35元105元175元315元35元538元.nm.cn38元101元171元346元35元105元175元315元35元538元.ln.cn38元101元171元346元35元105元175元315元35元538元.jl.cn38元101元171元346元35元105元175元315元35元538元.hl.cn38元101元171元346元35元105元175元315元35元538元.js.cn38元101元171元346元35元105元175元315元35元538元.zj.cn38元101元171元346元35元105元175元315元35元538元.ah.cn38元101元171元346元35元105元175元315元35元538元.fj.cn38元101元171元346元35元105元175元315元35元538元.jx.cn38元101元171元346元35元105元175元315元35元538元.sd.cn38元101元171元346元35元105元175元315元35元538元.hb.cn38元101元171元346元35元105元175元315元35元538元.hn.cn38元101元171元346元35元105元175元315元35元538元.gd.cn38元101元171元346元35元105元175元315元35元538元.gx.cn38元101元171元346元35元105元175元315元35元538元.hi.cn38元101元171元346元35元105元175元315元35元538元.sc.cn38元101元171元346元35元105元175元315元35元538元.gz.cn38元101元171元346元35元105元175元315元35元538元.yn.cn38元101元171元346元35元105元175元315元35元538元.xz.cn38元101元171元346元35元105元175元315元35元538元.sn.cn38元101元171元346元35元105元175元315元35元538元.gs.cn38元101元171元346元35元105元175元315元35元538元.qh.cn38元101元171元346元35元105元175元315元35元538元.nx.cn38元101元171元346元35元105元175元315元35元538元.xj.cn38元101元171元346元35元105元175元315元35元538元.tw.cn38元101元171元346元35元105元175元315元35元538元.hk.cn38元101元171元346元35元105元175元315元35元538元.mo.cn38元101元171元346元35元105元175元315元35元538元 上表为腾讯云域名官方收费标准，上表是官方定的收费标准。域名注册成功后，需要进行域名实名认证，否则无法解析。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f90472cfffec9c11bc3efda4958a7c1/" rel="bookmark">
			Acrel-EIoT能源物联网云平台助力电力物联网数据服务 ——安科瑞 顾烊宇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：Acrel-EIOT能源物联网云平台是一个结合在线销售的互联网商业模式，为分布广泛的互联网用户提供PAAS服务的平台。安科瑞物联网产品安装完成后，用户可以通过手机扫描代码轻松实现产品访问平台，无需注意调试和平台运行过程，可以独立选择平台功能，获得相应的数据服务。
关键词：能源物联网；物联网电表；云平台
一、引言
近年来，物联网的概念加速了与工业应用的整合，成为智能城市和信息整体解决方案的关键技术思维。目前，物联网从概念炒作、碎片化应用、闭环发展进入跨境一体化、综合创新和规模发展的新阶段，以及中国新工业化、城市化、信息化、农业现代化，在传统产业转型升级、新城镇化、智慧城市建设、人民生活质量中发挥了重要作用，取得了显著成果。
行业发展前景
到2026年中国物联网市场的复合增长率为13.2%，考虑到在“碳中和、碳达峰”的背景下，节约 能源是中国的重要任务，未来5年中国能源物联网市场规模的复合增速也将达到13%左右，到2027年中国能源物联网市场规模将超过6000亿元。
能源互联网涵盖能源侧管理(如水电、火电、核电、风电、太阳能)、储能侧管理(如相变储热、冰蓄冷、水蓄冷、各种新能源电池等。)，以及能源测量管理(如工业用电、商业用电、新能源电动汽车等)。)，实现以上三类主体和能源调度中心的信息传输，实现能效管理、互联网支付、数据监控等功能，实现互联网和能源的生产、传输、存储、消费和能源市场的深度整合。为国家电网建设“三型两网”提供解决方案，让用户随时随地实现信息连接和交互，生成共享数据，为电网、发电、供应商和用户提供服务。
Acrel-EIOT能源物联网云平台是基于安科瑞物联网数据中心的平台，建立了上下行数据标准，为互联网用户提供能源物联网数据服务。用户只需购买安科瑞物联网传感器、互感器等设备。安装后，无论是直接传输物联网仪器还是通过网关上传，都可以使用手机扫描代码获取所需的行业数据服务。
二、需求分析
Acrel-EIOT能源物联网云平台的客户群一般包括以下类型:
1.互联网用户:低成本进行水电计量并收取水电费。建设 充电桩，通过运营收费获利。
2.物业公司 :加强信息化管理，提升管理能力。拓 展服务内容，提升服务质量，提高业 主满意度。
3.园区管委会:智慧化建设形成体系，完善能源管 理制度，并使之有效运行。提供专 项配套措施，提升服务感知。
4.银行安保处:对电气火灾风险的检测进行预警及管理， 在发现电气火灾预警时，信息可多种途径 及时通知相关单位处理
5.政府部门:加强高耗能、高排放行业约束，实现能源利 用效率最大化，推动安全降碳、提效降耗， 尽早实现“双碳”目标。
6.连锁门店:实现自动抄表，减少计量误差， 降低人力成本。降低财务对账和 统计难度，提升工作效率。
传统的商业模式对这类互联网用户有几个缺点：
1.数据系统价格偏高
2.需要多样化的数据服务服务
3.调试太专业了
4.系统硬件选型过于专业
5.服务支付不方便
Acrel-EIOT能源物联网云平台的优势
人力成本低：自动抄表，实时查询数据，自主结算，自动多维度统计
即装即用、简化调试：扫码绑定设备，快速上线，辅助调试
信息化辅助、便捷运维：科学运维管理，线上线下联动，智能运维
安全预警、扼杀安全隐患：异常事件自动识别，主动切除隐患，安全更省心
系统灵活性强、业务模式多样：用户自定义监控、统计、可视化，开发成本低，周期短
三、系统结构
能源物联网以能源供应、能源管理、设备管理、能源分析能源流为主线，能源生产加工、分销传输、消费、节能环节，结合人物互联，形成能源物联网生态系统，物联网硬件和能源参与者以数据流和业务流的形式与平台互动。
3.1组网结构
Acrel-EIoT能源物联网云平台采用分层分布式结构，主要由感知层（终端采集设备）、网络层（通讯管理终端）和平台层（能源物联网云平台）三个部分组成。
● 感知层：连接于网络中的各类传感器，包括多功能仪表、预付费电表、多回路仪表、物联网电表、物联网水表、电瓶车充电桩、汽车充电桩、路灯控制器等。
● 网络层：智能网关，采集感知层的数据，进行规约转换及存储之后将数据上传至能源物联网云平台。
● 数据层：物联网数据中台
● 平台层：提供Web页面展示，APP、小程序等多种访问方式
3.2平台架构
Acrel-EIOT能源物联网云平台的系统网络结构采用分层分布式结构，包括感知层、数据层、应用层、性能层和操作层。系统架构图如图所示。
传感器层包括我们的各种产品，是整个系统的底层，也是构建能源物联网云平台的基本要素，主要包括多功能仪表、预付费电表、多回路仪表、物联网电表、物联网水表、电池充电桩、汽车充电桩、路灯控制器等设备。
中间数据处理平台主要完成数据处理、数据存储和数据交互。为了保证整个综合平台的数据处理能力，我们将实时数据、历史数据和业务数据存储在不同的数据库中，并提供各种接口，实现与第三方系统的数据交互。
上层应用层是指Acrel-EIOT能源物联网云平台，主要实现各种功能应用。根据能源流量，平台分为能源供应、能源管理、设备管理和能耗分析四个部分。能源供应包括电力复制和智能运维子模块，能源管理包括安全用电和电能质量子模块，设备管理包括智能照明、预付费和充电桩模块，能耗分析包括能源管理和增值服务子模块。该平台通过web和应用程序为用户提供人机交互界面，操作层的各种用户可以通过这两种方式访问和操作平台。咨询热线电话：172-6975-8633
四.平台功能
4.1能源供应
4.1.1电力集抄功能模块模块
随着信息网络技术的不断发展，各种规模、设备类型、不同数量的网络设备机房广泛分布在用户分支机构区域，由于缺乏与运行网络规模系统相对称的监控系统，大量无人值守机房物理运行环境、设备运行、人员活动和火灾变化，包括可能的危急情况，无法及时发现和处理，难以有效预测、预防和避免。因此，有必要在配电室内安装环境监测系统，以实现配电室内环境的在线监测，以确保配电室内设备的稳定运行。
电源复制模块可实现各种监控数据的查询、分析、预警和综合显示，确保配电室的环境友好。在智能方面，实现供配电监控系统的遥控、遥控、系统的综合检测和统一管理；在数据资源管理方面，可显示或查询供配电室内设备的运行（包括历史和实时参数），查询或打印日报、月报、年报，提高工作效率，节约人力资源。
3.1.2 智能运维功能模块
据统计全国高供高计的工商业用户数量达到200多万户，规模巨大，但是大部分日常的运行维护工作比较传统，普遍存在人力成本高、工作效率低、故障抢修时间长、风险预防薄弱等问题。国网公司和众多电力运维公司正在抢占这块巨大的市场，这是一个千亿级别的市场。
智能运维模块采用多功能电力仪表、无线通信、边缘计算网关及大数据分析技术，通过智能网关采集现场数据并存储在本地，再定时向云平台推送数据。平台可同时接入数以千计的用户变电站数据。平台采集的数据包括变电所电气参数和环境数据，包括电流电压功率、开关状态、变压器温度、环境温湿度、浸水、烟雾、视频、门禁等信息，有异常发生10S内通过短信和APP发出告警信号。平台通过手机APP下发运维任务到指定人员手机上，并通过GPS跟踪运维执行过程进行闭环，提高运维效率，即时发现运行缺陷并做消缺处理。
3.2、能源管理
3.2.1 安全用电功能模块
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f90472cfffec9c11bc3efda4958a7c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28871882ad4b2e8735106b82ee05b963/" rel="bookmark">
			解决pycharm格式化程序自动删除未使用的import或代码行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用pycharm的格式化时，不知道点了哪个导致未引用的import被自动删除
解决方法 按一下：ctrl+Shift+Alt+L，打开格式化的控制面板
把Optimize imports与Code cleanup都删除
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3b63676f683bef9d6f13bbc6c84e936/" rel="bookmark">
			Linux期末复习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、管理文件系统 1、文件系统类型 ext2：早期Linux中常用的文件类型。ext3：ext2的升级版，带日志功能。RAMFS：内存文件系统，速度很快。NFS：网络文件系统，由SUM发明，主要用于远程文件共享PROC：虚拟的进程文件。ISO9660：大部分光盘所采用的文件系统。 2、Linux文件系统的目录结构 /根目录，整个文件系统的根目录/dev存放Linux系统下的设备文件/etc存放系统的配置文件/home系统默认的用户主目录/root超级权限用户的root目录/opt自定义软件包 3、硬链接和软链接 硬链接：即便原始文件被删除，依然可以通过硬链接文件来访问。软链接：当原始文件被删除后，链接文件也将失效。 4、命令 1、工作目录切换类： pwd [目录名称] ：显示或查看当前所在的目录路径。cd [目录名称]：切换工作目录。 cd-：返回上一次所处的目录cd..：进入上级目录cd~：切换到当前用户的家目录ls [选项] [文件]： ls ./：查看当前目录的所有文件和目录，可省略./ls -l：查看当前目录所有的文件和目录的详细信息ls -a：查看文件的属性、大小等详细信息。 2、文本文件查看类： cat [选项] [文件]：查看纯文本文件（内容较少的） cat -n [文件]：显示行号more [选项] [文件]：查看纯文本文件（内容较多的），空格键向下翻页或回车键向下翻行，只能向前浏览，按q退出more程序。less [选项] [文件]：查看纯文本文件（内容较多的），允许向前向后浏览文件，PageUP或b键向上翻页，用PageDown或空格向下翻页。按q键可退出。head [选项] [文件]：查看纯文本文档前面部分的内容。 head -n 20 [文件]：查看纯文本中前20行的内容。tail [选项] [文件]：查纯文本中后面部分或持续刷新内容。 tail -n 20：查看文本内容的最后20行。tail -f 文件名：可以实时查看最新日志文件的效果。wc [参数] [文件]：统计指定文本的行数、字数、字节数。 -l只显示行数-w只显示单词数-c 只显示字节数
3、目录操作类： mkdir [选项] [目录]：创建空白的目录 mkdir -p a/b/c/d：创建具有嵌套的文件目录。rmdir [选项] [目录]：删除空白目录 可以结合-p删除具有嵌套叠层关系的文件目录。 4、文件操作类： touch [选项] [文件]：创建空文件或设置文件的时间。 -a仅修改“读取时间”（atime）-m仅修改“修改时间”（mtime）-d同时修改atime与mtimecp [选项] [源文件] [目标文件]：复制文件或目录。 如果目标文件是目录，则会把源文件复制到该目录中。如果目标文件是存在的普通文件，则会询问是否要覆盖它。如果目标文件不存在，则执行正常的复制操作。 -p保留原始文件的属性-d若对象为“链接文件”，则保留其属性-r递归持续复制（用于目录）-i若目标文件存在则询问是否覆盖-f，--force强行复制文件或目录，不论目标文件或目录是否已存在-a相当于-pdrmv [选项] [源文件] [目标路径] [目标文件名]：剪切文件或将文件重命名rm [选项] [文件]：删除文件或目录。 rm -f：强制删除。rm -r：删除一个目录。diff [参数] [文件]：比较多个文本文件的差异。 diff --brief：判断文件是否相同。diff -c：描述出文件内容具体的不同。dd [参数]：按照指定大小和个数的数据块来复制文件或转换文件 if输入的文件名称of输出的文件名称bs设置每个“块”的大小count设置要复制“快”的个数ln [选项] 目标：创建链接文件。 -s创建“符号链接”（如果不带-s参数，则默认创建硬链接）-f强制创建文件或目录的链接-i覆盖前先询问-v显示创建链接的过程 5、压缩解压命令： tar [选项] [文件]：建立，还原备份文件。 -c创建新的文档-v显示详细的tar处理的文件信息-f要操作的文件名，切记，这个参数是最后一个参数-x解压-t查看内容-z有gzip属性的-j有bz2属性的-r表示增加文件，把要增加的文件追加在压缩文件的末尾gzip [参数] [文件]：文件压缩工具。 gzip -c能指定输出并保留源文件。gunzip [参数] [文件]：解压缩gzip格式的文件。（会删除源文件） -l创建新的文档-d指定文件解压缩后要存储的目录-f要操作的文件名，切记，这是最后一个参数zip [参数] [打包后的文件名] [打包的文件路径]：压缩文件，适用于压缩多个文件的格式 -r递归压缩子目录下的所有文件，不然只压出来一个空目录-y保持符号链接，而不用把符号链接指向的文件也压进来-f要操作的文件名，这是最后一个参数unzip [参数] [文件名.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3b63676f683bef9d6f13bbc6c84e936/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4d29ab2829cf8ffca6f2902fc1d9f56/" rel="bookmark">
			51单片机相关寄存器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 单片机复习的时候对应寄存器的记忆感觉很混乱，这里进行一下整理,后面的单词是我用来辅助记忆的，可能并不是表示原本的含义。
P3口的第二功能 0RXD 串行数据输入口
1TXD串行数据输出口2INT0外部中断0输入3INT1外部中断1输入4T0定时器0外部计数输入5T1定时器1外部计数输入6WR外部数据存储器的写选通控制信号7RD外部数据存储器的读选通控制信号 程序状态字寄存器（PSW） D7D6D5D4D3D2D1D0PSWCyAcF0RS1RS0OVPD0H Cy进位标志位：也可以写成C。有进位/借位，则Cy=1；否则，Cy=0.Ac辅助进位标志位：用于在BCD码运算时进行十进位调整，当D3位D4位产生进位或借位，Ac=1；否则，Ac=0。F0用户使用的标志位：可用指令来使它置“1”或清零，也可以用指令来测试该标志位，根据测试结果控制程序的流向。RS1，RS04组工作寄存器区选择控制位1和位0：用来选择片内RAM区中的4组工作寄存器区中的某一组为当前工作寄存区。OV溢出标志位：用来指示运算结果是否产生溢出。如果结果产生溢出，OV=1；否则，OV=0。P奇偶标志位，累加器A中“1”的个数是奇数，P=1，否则，P=0. RS1RS04组寄存器010区（片内RAM 00H~07H）011区（片内RAM 08H~0FH）102区（片内RAM 10H~17H）113区（片内RAM 18H~1FH）RS1、RS0与4组工作寄存器区的对应关系 中断源的中断入口地址 中断源 入口地址
外部中断00003H定时器T0000BH外部中断10013H定时器T1001BH串行口0023H AUXR寄存器 D7D6D5D4D3D2D1D0AUXRWDIDLEDISRTODISALE8EH DISRTO：禁止/允许看门狗定时器（WDT）溢出时的复位输出。1：禁止WDT溢出时的复位输出；0：WDT溢出时，允许向RST引脚输出一个高电平脉冲，使单片机复位。WDIDLE：WDT在空闲模式下的禁止/允许位。1：禁止WDT在空闲模式下计数；0：允许WDT在空闲模式下计数。 TCON（定时器/计数器控制寄存器） D7D6D5D4D3D2D1D0TCONTF1TR1TF0TR0IE1IT1IE0IT088H位地址8FH8DH8BH8AH89H88H TF：片内定时器/计数器T的溢出中断请求标志位。启动计数后，从初值开始加1计数，当计数溢出时，又硬件自动为TF置“1”，向CPU申请中断。CPU响应TF中断时，标志位由硬件自动清零，同时也可以用软件来清零。（Flag）IE：外部中断请求的中断请求标志位（enable）IT：选择外部中断请求的中断方式，0为电平触发方式，1为负跳变触发方式。TR：计数运行控制位。1：启动定时器/计数器计数的必要条件；0：停止。软件置1或者清零。 SCON（串行口控制寄存器） D7D6D5D4D3D2D1D0SCONSM0SM1SM2RENTB8RB8TIRI98H位地址9FH9EH9DH9CH9BH9AH99H98H SM0、SM1:串行口工作方式选择位。SM2：多机通信控制位。REN：允许串行口接收位（由软件置“1”或清零），1：允许；0：禁止。TB8：发送的第9位数据。RB8：接收的第9位数据。TI：串行口发送中断请求标志位。当CPU将1字节的数据写入串行口的发送缓冲器SBUF时，就会启动一帧串行数据的发送，每发送完一帧串行数据后，硬件把TI中断请求标志位自动置“1”，发送之后需要在中断服务程序中用指令对其清零。TI必须由软件清零。（transmit）RI：串行口接收中断请求标志位。在串行口接收完一个串行数据帧，硬件自动把RI中断请求标志位置“1”，需要在中断服务程序中用指令对其清零。RI必须由软件清零。（receive） SM0SM1功能说明00方式0，同步移位寄存器方式（用于扩展I/O口）01方式1,8位异步收发，波特率可变（由定时器控制）10方式2,9位异步收发，波特率为fosc/64或fosc/3211方式3,9位异步收发，波特率可变（由定时器控制） IE（中断允许寄存器） D7D6D5D4D3D2D1D0IEEAESET1EX1ET0EX0A8H位地址AFHACHABHAAHA9HA8H EA：中断允许总开关控制位。1：允许；0：屏蔽。(enable all)ES：串行口中断允许控制位。1：允许；0：屏蔽。(enable serial）ET：定时器/计数器的溢出中断允许控制位。1：允许；0：屏蔽。(enable timer)EX：外部中断中断允许控制位。1：允许；0：屏蔽。(enable external) IP（中断优先级寄存器） D7D6D5D4D3D2D1D0IPPSPT1PX1PT0PX0B8H位地址BCHBBHBAHB9HB8H PS：串行口中断优先级控制位，1：高优先级；0：低优先级。（priority serial）PT：定时器T中断优先级控制位，1：高优先级；0：低优先级。（priority timer）PX：外部中断中断优先级控制位，1：高优先级；0：低优先级。（priority external） 同级中断的查询顺序（中断级别）：外部中断0&gt;T0溢出中断&gt;外部中断1&gt;T1溢出中断&gt;串行口中断。
TMOD（定时器/计数器工作方式存储器） D7D6D5D4D3D2D1D0TMODGATEC/TM1M0GATEC/TM1M089HT1方式字段T0方式字段 GATE：门控位，1：由外中断引脚（或INT1）INT0上的电平与运行控制位TRx两个条件共同控制；0：仅由控制位TRx（x=0,1）来控制。M1、M0：工作方式选择位。C/T:计数器模式和定时器模式选择位。1：计数器工作模式，对系统时钟12分频后的内部脉冲进行计数；0：计数器工作模式，计数器对外部输入引脚T0或T1的外部买重（负跳变）计数。 M1M0工作方式00方式0，为13位定时器/计数器01方式1，为16位定时器/计数器10方式2，为8位的常数自动重新装载的定时器/计数器11方式3:，仅适用于T0，此时T0分成2个8位计数器，T1停止计数 PCON D7D6D5D4D3D2D1D0PCONSMODGF1GF0PDIDL87H SMOD=1时要比SMOD=0时的波特率加倍。
GF1、GF0：通用标志位，用户使用，应充分利用。
PD：掉电保持模式控制位，若PD=1，则进入掉电保持模式。（掉电保持模式 power down mode）
IDL：空闲模式控制位，若IDL=1，则进入空闲运行模式。（空闲模式 idle mode）
总结 本文主要是用来区分不同寄存器的大概功能，所以不是很详细，写这个主要是给自己记忆的，所以有点水。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfdb3340da59c3b9a7eab3fd9648cb76/" rel="bookmark">
			nginx将xxx.com重定向到www.xxx.com配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候，我们网站，需要将顶级域名xxx.com统一跳转到二级域名www.xxx.com下。这时候，我们可以通过修改nginx配置达到我们的目的。
参考配置 #以下属性中，以ssl开头的属性表示与证书配置有关。 server { listen 443 ssl; #配置HTTPS的默认访问端口为443。 #如果未在此处配置HTTPS的默认访问端口，可能会造成Nginx无法启动。 #如果您使用Nginx 1.15.0及以上版本，请使用listen 443 ssl代替listen 443和ssl on。 server_name www.xxx.com; #需要将yourdomain替换成证书绑定的域名。 ssl_certificate /opt/certs/www.xxx.com.pem; #需要将cert-file-name.pem替换成已上传的证书文件的名称。 ssl_certificate_key /opt/certs/www.xxx.com.key; #需要将cert-file-name.key替换成已上传的证书私钥文件的名称。 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #表示使用的加密套件的类型。 ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; #表示使用的TLS协议的类型。 ssl_prefer_server_ciphers on; # 设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffer_size 8k; location / { # 主要是在这里进行判断，进行301重定向操作 if ($host= "xxx.com") { return 301 https://www.xxx.com$request_uri; } proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://backend; } } server { listen 80; server_name www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfdb3340da59c3b9a7eab3fd9648cb76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c04d81ffe156f53171212d6c4b04551/" rel="bookmark">
			vue3&#43;echart绘制中国地图并根据后端返回的坐标实现涟漪动画效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.效果图 2.前期准备 main.js app.use(BaiduMap, { // ak 是在百度地图开发者平台申请的密钥 详见 http://lbsyun.baidu.com/apiconsole/key */ ak: 'sRDDfAKpCSG5iF1rvwph4Q95M6tDCApL', // v:'3.0', // 默认使用3.0 // type: 'WebGL' // ||API 默认API (使用此模式 BMap=BMapGL) }); index.html &lt;script type="text/javascript" src="https://api.map.baidu.com/getscript?v=3.0&amp;ak=sRDDfAKpCSG5iF1rvwph4Q95M6tDCApL"&gt;&lt;/script&gt; &lt;div&gt; &lt;div id="main6" style="width:650px;height:400px;"&gt;&lt;/div&gt; &lt;/div&gt; 3.js，注意:import 'echarts/map/js/china.js'; 引入时需要注意当前echart是否为4.+版本，如否降级 npm install echarts@4.1.0 --save &lt;script setup&gt; import * as echarts from 'echarts'; import 'echarts/extension/bmap/bmap'; import {onMounted,defineProps} from 'vue'; import 'echarts/map/js/china.js'; //关键引入china.js const props = defineProps(['data']) var initData = JSON.parse(JSON.stringify(props)).data const initMap = () =&gt;{ var chartDom = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c04d81ffe156f53171212d6c4b04551/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f95e11f9b967ab944385c2cea13983a0/" rel="bookmark">
			Redhat7系统配置阿里源失败问题及解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redhat7系统配置阿里CentOS7源失败问题及解决办法 [root@k8s-master yum.repos.d]# pwd /etc/yum.repos.d [root@k8s-master yum.repos.d]# curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo [root@k8s-master yum.repos.d]# sed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' /etc/yum.repos.d/CentOS-Base.repo [root@k8s-master yum.repos.d]# yum clean all # 第一个报错 Loaded plugins: product-id, search-disabled-repos, subscription-manager This system is not registered with an entitlement server. You can use subscription-manager to register. Cleaning repos: base extras updates # 解决以上报错 [root@k8s-master yum.repos.d]# cat /etc/yum/pluginconf.d/subscription-manager.conf [main] #enabled=1 # 添加注释 [root@k8s-master yum.repos.d]# yum makecache # 解决报错 sed -i 's/$releasever/7/g' /etc/yum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f95e11f9b967ab944385c2cea13983a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/958d2255208d5f99dd6e1f90f188316b/" rel="bookmark">
			nuxt3 env文件、全局变量处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有两种方向 通过配置nuxt.config.ts + Nuxt提供的钩子函数，实现全局变量的获取
runtimeconfig
env文件往runtimeconfig放入内容
useAppConfig
通过env文件配置来获取服务端全局变量，客户端通过vite.define实现
nuxt.config.ts + Nuxt钩子 1. runtimeconfig服务端|全局变量 在nuxt.config.ts文件中，配置runtimeconfig对象，该对象的值只能使用useRuntimeConfig从服务器访问到，适合配置一些API秘钥相关的不暴露给前端的数据
但其中runtimeConfig.public和runtimeConfig.app中的值会暴露给前端
export default defineNuxtConfig({ runtimeConfig: { apiKey: "xxx", // 该值只能在服务端获取 // public中的值会暴露给前端 public: { baseURL: "https://www.blockxu.top", }, }, }) 客户端获取：
服务端获取：
2. env文件覆盖runtimeConfig中内容 如果在env文件中设置了相同名称（NUXT_API_xxx或NUXT_PUBLIC_xxx）的变量，就会覆盖掉runtimeConfig|runtimeConfig.app|runtimeConfig.public中的变量
NUXT_API_KEY = 'my-api-key' NUXT_PUBLIC_BASE_URL = '/foo/' 3. app.config.ts文件配置内容 在根目录创建app.config.ts，文件内部的变量可以useAppConfig()获取到
export default defineAppConfig({ foo: "bar", title: "Hello Nuxt", theme: { dark: true, colors: { primary: "#ff0000", }, }, }); const appConfig = useAppConfig(); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/958d2255208d5f99dd6e1f90f188316b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94e8f48f9a9c7c9c95b75b00245ab618/" rel="bookmark">
			快速学习SpringBoot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SpringBoot springboot传统方式构建spring应用程序使用springboot子项目构建起步依赖自动配置其它特性 SpringBoot项目部署Spring项目部署属性配置方式命令行参数方式配置环境变量方式外部配置文件方式 多环境开发-Pofiles多环境开发分组 springboot 传统方式构建spring应用程序 使用springboot子项目构建 起步依赖 自动配置 其它特性 SpringBoot项目部署 Spring项目部署属性配置方式 命令行参数方式 配置环境变量方式 外部配置文件方式 多环境开发-Pofiles 多环境开发分组 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1283a31c23d1287ad32ec7d1ca6b2d5/" rel="bookmark">
			阿里云PolarDB数据库不同配置租用价格表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云数据库PolarDB租用价格表，云数据库PolarDB MySQL版2核4GB（通用）、2个节点、60 GB存储空间55元5天，云数据库 PolarDB 分布式版标准版2核16G（通用）57.6元3天，阿里云百科aliyunbaike.com分享阿里云PolarDB数据库不同版本优惠价格表：
阿里云PolarDB数据库优惠价格表
阿里云PolarDB数据库不同版本优惠价格表 云原生数据库PolarDB是阿里云自研产品，在存储计算分离架构下，利用了软硬件结合的优势，为用户提供秒级弹性、高性能、海量存储、安全可靠的数据库服务。100%兼容MySQL和PostgreSQL生态，支持分布式扩展，高度兼容Oracle语法。活动：aliyunbaike.com/go/polardb
PolarDB数据库版本节点规格存储空间优惠价格云数据库 PolarDB MySQL 版2核4GB（通用）2个节点60 GB55.00 /5天云数据库 PolarDB 分布式版标准版2核16G（通用）60 GB57.60 /3天云原生数据库 PolarDB MySQL 版4核8GB（通用）60 GB100.00 /5天云原生数据库 PolarDB MySQL 版2核8GB（通用）100 GB620.00 /1个月云原生数据库 PolarDB MySQL 企业版4核16GB（通用）200 GB20400.00元1年云数据库 PolarDB 分布式版4核32G（独享）1968.00 /1个月云数据库 PolarDB 分布式版企业版4核16G（通用）5361.80 /1个月云数据库 PolarDB 分布式版企业版4核32G（独享）9115.06 /1个月PolarDB PostgreSQL 版2核8GB（通用）30 GB99.00 /1个月起云原生数据库 PolarDB PostgreSQL 版4核8GB（通用）50 GB8400.00 /1年起云原生数据库 PolarDB Postgre 版2核16GB（独享）按容量计费（按量计费）9547.20 /1年起 MySQL版：PolarDB 100%兼容 MySQL，交易和分析性能最高分别是开源数据库的6倍和400倍，TCO 低于自建数据库50%。分布式版：PolarDB 分布式版 (PolarDB for Xscale，简称“PolarDB-X”) 是阿里云自主设计研发的高性能云原生分布式数据库产品，为用户提供高吞吐、大存储、低延时、易扩展和超高可用的云时代数据库服务。PG版：云原生数据库 PolarDB PostgreSQL 版是阿里云完全自主研发的云原生关系型数据库产品，100%兼容 PostgreSQL，高度兼容Oracle语法。为用户提供快速弹性、高性能、海量存储、安全可靠的数据库服务，同时支持阿里云自研Ganos多维多模时空信息引擎及开源PostGIS地理信息引擎。 更多关于阿里云PolarDB数据库的说明，请参考：aliyunbaike.com/go/polardb
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/863728e172b562265bc1bf929c748251/" rel="bookmark">
			安装Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装Redis 前言1.单机安装Redis1.1.安装Redis依赖1.2.上传安装包并解压1.3.启动1.3.1.默认启动1.3.2.指定配置启动1.3.3.开机自启 2.Redis客户端2.1.Redis命令行客户端2.2.图形化桌面客户端2.2.1.安装2.2.2.建立连接 前言 大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.
此处选择的Linux版本为CentOS 7.
Redis的官方网站地址：https://redis.io/
1.单机安装Redis 1.1.安装Redis依赖 Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：
yum install -y gcc tcl 1.2.上传安装包并解压 我放到了/usr/local/src 目录：
解压缩：
tar -xzf redis-6.2.6.tar.gz 解压后，进入redis目录：
cd redis-6.2.6 运行编译命令：
make &amp;&amp; make install 如果没有出错，应该就安装成功了。
默认的安装路径是在 /usr/local/bin目录下：
该目录以及默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：
redis-cli：是redis提供的命令行客户端redis-server：是redis的服务端启动脚本redis-sentinel：是redis的哨兵启动脚本 1.3.启动 redis的启动方式有很多种，例如：
默认启动指定配置启动开机自启 1.3.1.默认启动 安装完成后，在任意目录输入redis-server命令即可启动Redis：
redis-server 这种启动属于前台启动，会阻塞整个会话窗口，窗口关闭或者按下CTRL + C则Redis停止。不推荐使用。
1.3.2.指定配置启动 如果要让Redis以后台方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（/usr/local/src/redis-6.2.6），名字叫redis.conf：
我们先将这个配置文件备份一份：
cp redis.conf redis.conf.bck 然后修改redis.conf文件中的一些配置：
# 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0 bind 0.0.0.0 # 守护进程，修改为yes后即可后台运行 daemonize yes # 密码，设置后访问Redis必须输入密码 requirepass 123321 Redis的其它常见配置：
# 监听的端口 port 6379 # 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录 dir .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/863728e172b562265bc1bf929c748251/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f11fc28dac625ff1dfc44c5822d9f33c/" rel="bookmark">
			腾讯云公网宽带价格表（官方报价详细说明）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云公网宽带价格表，腾讯云服务器网txyfwq.com分享腾讯云官方的公网宽带详细说明，公网宽带计费模式有4种，不同地域节点的公网宽带单价也不同：
腾讯云公网宽带价格表 腾讯云的公网宽带计费方式有四种，即包年包月（元／Mbps/月）、按量计费（元／Mbps／小时）、按量计费（元／GB）和共享带宽包（元／Mbps），不同计费方式下的公网宽带价格表，另外新手站长网不建议用户直接购买，因为比较贵，建议用户购买优惠活动中的云服务器机型，例如https://curl.qcloud.com/oRMoSucP 活动折扣可以低至2折，而直接购买的价格一年只有83折。
包年包月（元／Mbps/月）计费模式价格表 包年包月（元／Mbps/月）的计费方式是最常见的宽带计费方式，腾讯云将宽带按照大小不同分为三个档，带宽≦2Mbps价格为20元/M/月，2Mbps&lt;带宽≦5Mbps的价格为25元/M/月，带宽&gt;5Mbps的价格为90元/M/月，宽带值越大，宽带单价也随之上涨。详细如下表所示：
地域节点包年包月（元／Mbps/月）选择带宽≦2Mbps2Mbps&lt;选择带宽≦5Mbps选择带宽&gt;5Mbps广州20.0025.0090.00上海20.0025.0090.00北京20.0025.0090.00成都18.0022.0090.00香港20.0025.0090.00新加坡20.0025.0090.00多伦多20.0030.00100.00硅谷30.0030.00100.00韩国20.0020.0080.00法兰克福20.0020.0080.00 宽带的价格阶梯不同于其他产品，其他产品都是买得越多越便宜，而公网宽带则是买得越多单价越贵；不同地域节点的公网宽带价格也不同，从上表中可以看出，腾讯云成都地域的公网宽带最便宜，硅谷节点宽带相对贵一些。
按量计费（元／Mbps／小时）计费模式价格表 地域按量计费（元／Mbps／小时）选择带宽≦5Mbps选择带宽&gt;5Mbps广州0.06300.25上海0.06300.25北京0.06300.25成都0.06250.25香港0.08000.25新加坡0.06250.25多伦多0.06300.25硅谷0.06300.25韩国0.06300.25法兰克福0.06300.25 腾讯云公网宽带按量计费（元／Mbps／小时）计费模式下也是以5M宽带为分割点，带宽≦5Mbps价格较便宜，当带宽&gt;5Mbps后宽带价格就会上涨。
按量计费（元／GB）计费模式价格表 按量计费（元／GB）计费模式是按照流量计费的，使用多少流量付多少钱，详细参考下表：
地域节点按量计费（元／GB）流量价格广州0.80上海0.80北京0.80成都0.80香港1.00新加坡0.80多伦多0.50硅谷0.50韩国0.80法兰克福0.80 如上表所示，按量计费（元／GB）计费模式中香港节点的公网IP流量价格相对较贵，多伦多和硅谷的价格较为便宜。
共享带宽包（元／Mbps）计费模式价格表 地域节点共享带宽包（元／Mbps）带宽包内超出带宽包广州100.00108.00上海100.00108.00北京100.00108.00成都100.00108.00香港100.00108.00新加坡100.00108.00多伦多200.00216.00硅谷100.00108.00韩国100.00108.00法兰克福100.00108.00 注意事项
1. 按量计费的单位是：GB；带宽计费单位是：Mbps；1 Byte = 8 bit
2. 带宽价格不包含主机硬件（CPU、内存）及硬盘费用
3. 包年包月网络带宽购买跟随云主机购买，一同享受1年83折、3年5折的优惠
4. 本表格中的所有价格均为新购价格，续费、调整配置时的价格可能有所不同
5. 官网价格会根据情况做适当调整，具体价格请参考官网，不作为长期有效数据
综上，腾讯云服务器公网宽带计费总共有4中计费模式，其中包年包月（元／Mbps/月）计费模式是最为常见的；不同地域节点的公网宽带价格也不相同。可以领取腾讯云3785元代金券，结算时符合条件的订单，可以优先使用代金券抵扣订单金额。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e776843ba18cfbeaae24173edf93b89c/" rel="bookmark">
			腾讯云服务器价格表（价格计算器报价精准）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云服务器价格计算器可以一键计算出云服务器的精准报价，包括CVM实例规格价格、CPU内存费用、公网带宽收费、存储系统盘和数据盘详细费用，腾讯云百科txybk.com分享腾讯云价格计算器链接入口、使用方法说明：
腾讯云服务器价格计算器 打开腾讯云服务器CVM页面：txybk.com/go/cvm 打开后可以看到“价格计算器”，如下图：
腾讯云服务器价格计算器
如上图所示，点击“价格计算器”即可进入。也可以使用腾讯云百科准备的直达链接入口：txybk.com/go/calc
计算器打开如下图：
云服务器价格计算明细和预算清单
计算价格明细：选择云服务器CVM计费模式、购买时长、地域、可用区、CVM实例规格、CPU内存大小、镜像系统、系统盘、数据盘、公网带宽即可一键计算出云服务器价格明细表，表中有详细的云服务器各个配置说明。
云服务器代金券：领券 https://curl.qcloud.com/HmjGZiLu 云服务器专享满减券。
价格预算清单：还可以将选择云服务器配置加入到价格预算清单中，价格预算清单可以导出，导出格式为.csv文件。
以上是腾讯云百科txybk.com分享的腾讯云服务器价格计算器入口链接、使用方法说明。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1be0440a91c37b5feba92110f3cb7c03/" rel="bookmark">
			2024三掌柜赠书活动第一期：TVM编译器原理与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言TVM编译器的实现过程关于《TVM编译器原理与实践》编辑推荐内容简介作者简介图书目录书中前言/序言《TVM编译器原理与实践》全书速览结束语 前言 随着人工智能的发展，计算机视觉、自然语言处理和语音识别等领域的需求不断增加。为了更好地满足这些需求，许多深度学习框架被开发出来，其中TVM（TVirtual Machine）是一种优秀的编译器，能够将深度学习模型编译为高效的机器码。而且TVM编译器的核心思想，就是将深度学习模型转化为高效的计算图，并优化图中的计算节点。这样一来，模型运行时的计算时间就会大大减少，同时还可以提高模型的功耗效率。TVM编译器的实现过程可以分为三个主要部分：前端、中间层和后端。
TVM编译器的实现过程 关于TVM编译器的实现过程分为三大核心内容。首先是前端部分，它负责将深度学习框架中的模型转化为抽象的计算图。在这个过程中，前端可以根据模型的结构和特性进行一些预处理操作，例如图优化和剪枝。接下来是中间层将接收前端传递过来的计算图，并进行一系列的优化操作。这些操作包括图变换、图剪枝、数据布局、内存优化等。最后是优化后的计算图将传递给后端部分，后端将根据目标硬件的特性生成高效的机器码。
TVM编译器的实践过程需要结合具体的深度学习框架和硬件平台，比如我们需要选择一个适合的深度学习框架，并在该框架中开发和训练模型。又如我们可以使用TVM提供的前端接口将模型转化为计算图，并进行一系列的优化操作。再如需要选择适合的后端，TVM支持多种硬件平台，包括CPU、GPU和FPGA等。根据目标平台的特性，我们可以使用TVM提供的后端接口生成高效的机器码，并进行性能测试和优化。
在实践中，TVM编译器具有许多优点，比如TVM可以针对特定的硬件平台进行优化，可以充分发挥硬件的计算能力；再如TVM提供了丰富的优化功能，可以对计算图进行灵活的优化操作，有效提高模型的运行效率；又如TVM还支持多种深度学习框架和编程语言，方便开发者使用，以及TVM具有较低的学习曲线，开发者可以快速上手并进行模型的编译和优化。
关于《TVM编译器原理与实践》 接下来给大家推荐一本关于深度学习必备的书籍，这是一本关于TVM编译器的原理和实际实践的书，具体信息如下所示。另外，在本文文末评论区评论“我要入门人工智能”，将选取三名幸运读者送出纸质版《TVM编译器原理与实践》一本，截止时间：2024.01.07。
编辑推荐 适读人群 ：从事AI算法，软件，AI芯片，编译器开发工程技术人员
人工智能（Artificial Intelligence，AI）已经在全世界信息产业中获得广泛应用。深度学习模型推动了AI技术革命，如 TensorFlow、PyTorch、MXNet、Caffe等。大多数现有的系统框架只针对小范围的服务器级 GPU进行过优化，因此需要做很多的优化努力，以便在汽车、手机端、物联网设备及专用加速器（FPGA、ASIC）等其他平台上部署。随着深度学习模型和硬件后端数量的增加，TVM构建了一种基于中间表示 (IR)的统一解决方案。TVM不仅能自动优化深度学习模型，还提供了跨平台的高效开源部署框架。大模型的热度逐渐上升，将人工智能理论及算法框架转为落地项目实现，TVM是一个很好的桥梁。因此，本书将得到广大读者的喜爱。
内容简介 TVM（Tensor Virtual Machine, 张量虚拟机）是一种开源的模型编译框架，旨在将机器学习模型自动编译成可供下层硬件执行的机器语言，从而利用多种类型的算力。其工作原理是，先将深度学习模型进行优化推理、内存管理与线程调度，再借用LLVM框架将模型部署在CPU、GPU、FPGA、ARM等硬件设备上。
本书全面解析TVM的主要功能，帮助读者理解TVM工作原理，以及使用 TVM对深度学习与机器学习进行优化与部署。
本书结合作者多年的工作与学习经验，力求将TVM基础理论与案例实践融合在一起进行详细讲解。全书共9章，包括TVM基本知识，使用TVM开发，算子融合与图优化，TVM量化技术，TVM 优化调度，Relay IR，代码生成，后端部署与OpenCL（Open Computing Language，开放运算语言），自动调度、自动搜索与成本模型。各章除了包含重要的知识点和实践技能外，还配备了精心挑选的典型案例。
本书适合从事AI算法、软件、编译器开发以及硬件开发等专业的工程技术人员、科研工作人员、技术管理人员阅读，也可以作为编译器相关专业高校师生的参考用书。
作者简介 吴建明，上海交通大学模式识别与智能系统专业博士毕业。长期从事人工智能芯片设计，尤其擅长TVM/LLVM编译器、AI框架、自动驾驶、芯片制造，嵌入式系统等领域的理论研究与技术创新。长期在一线工作，包括产品设计与代码实现等，主持和参与过30多项产品的研发。还参与过国家自然科学基金、上海市科委项目，并在核心期刊公开发表过8篇论文，其中6篇是第一作者。
图书目录 第1章 TVM基本知识/
1.1TVM基本原理/
1.1.1TVM概述/
1.1.2TVM 模型优化部署概述/
1.2TVM编译过程/
1.2.1编译流程/
1.2.2TVM编译数据结构/
1.2.3TVM编译数据处理/
1.2.4TVM的Pass过程/
1.3TVM开源工程逻辑架构/
1.3.1代码库代码结构/
1.3.2代码自动内核/
1.4TVM应用支持/
1.4.1TVM的工作流程/
1.4.2支持多语言与多平台/
1.4.3TVM应用场景/
1.4.4TVM优化模型推理/
1.4.5TVM编译器与运行时组件/
1.4.6TVM运行时主要模块/
1.4.7TVM简单代码生成编译示例/
1.4.8TVM各模块之间的关系/
1.5TVM特色与挑战/
1.5.1TVM特色/
1.5.2支持多种后端设备/
1.5.3TVM应对的挑战/
第2章 使用TVM开发/
2.1配置TVM环境/
2.1.1apache TVM源码下载/
2.1.2配置TVM的开发环境/
2.1.3TVM conda环境使用方法/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1be0440a91c37b5feba92110f3cb7c03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1323ef73315f2572f0451c8114b168d/" rel="bookmark">
			工程中uint8变量文件比uint32变量文件大4字节的问题排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 （1）如果有嵌入式企业需要招聘湖南区域日常实习生，任何区域的暑假Linux驱动实习岗位，可C站直接私聊，或者邮件：zhangyixu02@gmail.com，此消息至2025年1月1日前均有效
（2）今天在一个交流群看到一个有意思的问题，网友问：开发32位单片机，能够使用unsigned char 就不使用unsigned int，这样是否可以节约内存呢？
（3）当时我看到这个问题是懵的，uint8怎么会比uint32更节省空间呢？
（4）学习本文之前，需要先了解数据的内存分配知识，所以需要各位先了解这篇博客：
RAM明明断电会丢失数据，为什么初始化的全局变量存储在RAM？详细分析程序的存储
网友问题解决思路 （1）首先申明一下这位网友的测试环境，是在STM32F103中进行的相关测试。
问题 （1）这位网友在测试代码工程的时候，发现将unsigned char修改为unsigned int的时候，工程代码会减少4字节。
解决思路 （1）对于这个问题，很容易知道大体问题是在哪里。
&lt;1&gt;首先，这个是局部变量，他不会占用实际的空间，因此我们发现，实际变化的内存大小是在code段。
&lt;2&gt;其次，在32位的机器中，CPU寄存器都是32位的，因此在处理数据的时候，低于4字节数据会被提升到4字节再进行处理。
（2）那么，我们就可以大致的推断出，这个地方大概率是需要汇编指令进行字节提升，新增加的汇编指令导致code段增多了。
（3）既然有了上述的基础概念之后，就开始定位问题。
&lt;1&gt;第一步，查看map文件。我们需要知道，这个增加的汇编指令具体是在那个文件中。
&lt;2&gt;对比uint8和uint32的map文件中Image component sizes部分，我们能够发现，提升的4字节果然是在main.o中，因此此时就知道是在main.c中的在汇编阶段导致的汇编代码不同的问题。
&lt;3&gt;查看汇编，使用keil的Debug功能，能够帮我们看到汇编内容，直接在mian.c中开断点，对比汇编代码。我们能够发现，如果是uint32，只有一个BCC的指令，但是如果是uint8就是UXTB和BLT。
&lt;4&gt;既然知道的区别之后，开始研读这几条汇编代码，进行对比分析。因为这里是无符号数据的对比，所以说，BCC和BLT其实是等效的。如果是有符号数据比较，那么就需要使用BLT。（这是arm汇编的内容，简单了解即可，不会的时候查谷歌、百度、chatgpt）
# uint8 UXTB r4 , r0 ;将一个8位无符号字节零扩展为32位无符号整数，高位的24位填充为零 CMP r4 , 0x64 ;将寄存器r4的值和0x64（十进制就是100）对比 BLT 0x0800aA8C ; 如果CMP指令的比较结果是负数（即r4&lt;0x64），则跳转到0x0800aA8C 地址 # uint32 CMP r4 , 0x64 ;将寄存器r4的值和0x64（十进制就是100）对比 BCC 0x0800aA8C ; 如果前一条CMP指令的比较结果没有产生进位（即r4&gt;=0x64），则执行分支 &lt;5&gt;知道汇编代码的大致意思之后，此时就要考虑汇编代码的大小问题。通过询问chatgpt可知，这三条指令都是4字节，因此，当我们main.c中汇编之后多了一条汇编指令，code段就会增加4字节。
扩展测试1 问题 （1）我们发现，上面测试的都是局部变量，我们要不试试全局变量看看结果如何？
（2）我们能够发现两个有意思的问题：
&lt;1&gt;对比两个全局变量，我们会发现，生成的代码一模一样。
&lt;2&gt;对比全局变量和局部变量：code段增加了，rodata不变，rw增加4字节，zi段减少了4字节。（这个我也不会，苦笑。查了很久资料，也调了很久，不知道为啥怎么是这样的结果。应该是工程中某些细节影响，具体细节没排查到）
解决思路 （1）首先我们先看两个全局变量工程怎么会一模一样的。还是直接看map文件，通过对比map文件知道内存布局信息。
（2）我们能够发现main.o的RW-data确实少了3字节数据，但是呢，在(incl. Padding)，RW-data却多了3字节数据。
（3）为什么在(incl. Padding)，RW-data却多了3字节数据呢？查阅资料可知，编译器为了满足对齐要求而在数据或代码之间插入额外的填充字节。一般来说，字节对齐只有两种可能：
&lt;1&gt;硬件要求： 许多计算机体系结构对于某些数据类型的访问有硬件对齐的要求。例如，一些处理器可能要求访问特定大小的数据类型的变量时，其地址必须是该数据类型大小的倍数。如果不满足这些要求，可能导致性能下降或者引发硬件异常。如果是采用的冯诺依曼结构，不进行字节对齐，可能导致指令和数据弄混淆。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1323ef73315f2572f0451c8114b168d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e4e385c415c508abdcb754313c17b49/" rel="bookmark">
			如何在Milk-V duo的小核FreeRTOS中跑i2c
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 （1）PLCT实验室实习生长期招聘：招聘信息链接
（2）如果有嵌入式企业需要招聘湖南区域日常实习生，任何区域的暑假嵌入式软件实习岗位，可C站直接私聊，或者邮件：zhangyixu02@gmail.com，此消息至2025年1月1日前均有效
（3）本来要尝试在RT-Thread中跑i2c，打算先Linux中测试i2c，再FreeRTOS，最后RT-Thread，最终发现卡在RT-Thread这一步了，因为移植一个文件就马上出现另外一个文件缺失缝缝补补搞了很久最终真的无能为力了。
在duo的小核FreeRTOS跑i2c的方法 修改部分 （1）因为duo的版本更新比较快，我就使用比较熟悉的Duo-V1.0.5版本进行讲解。
git clone -b Duo-V1.0.5 https://github.com/milkv-duo/duo-buildroot-sdk.git cd duo-buildroot-sdk cp freertos/cvitek/hal/cv180x/i2c/src/hal_dw_i2c.c freertos/cvitek/task/comm/src/riscv64/ cp freertos/cvitek/hal/cv180x/i2c/include/hal_dw_i2c.h freertos/cvitek/task/comm/include/ cp freertos/cvitek/driver/i2c/include/i2c.h freertos/cvitek/task/comm/include/ （2）进入FreeRTOSConfig.h文件，关闭configUSE_TICK_HOOK这个宏。
vim freertos/cvitek/kernel/include/riscv64/FreeRTOSConfig.h #define configUSE_TICK_HOOK 0 （3）进入的796行，将IC3_INTR修改为I2C3_INTR，这里有可能是官方写错了。
vim freertos/cvitek/task/comm/src/riscv64/hal_dw_i2c.c //修改前 request_irq(IC3_INTR, i2c_dw_isr, 0, "IC2_INTR int", &amp;dw_i2c[i2c_id]); //修改后 request_irq(I2C3_INTR, i2c_dw_isr, 0, "IC2_INTR int", &amp;dw_i2c[i2c_id]); （4）在comm_main.c中利用freertos的xTaskCreate()函数创建一个my_task_test()的任务函数。
vim freertos/cvitek/task/comm/src/riscv64/comm_main.c /**************************************************************************** * Function definitions ****************************************************************************/ DEFINE_CVI_SPINLOCK(mailbox_lock, SPIN_MBOX); #include "hal_dw_i2c.h" void my_task_test() { uint8_t data= 0,data_read; hal_i2c_init(I2C0); printf("hal_i2c_init after\n"); uint8_t *data_write =&amp;data; for (;;) { //i2c端口，从机地址，寄存器地址，7位从机地址，写入的数据，写1个数据 hal_i2c_write(I2C0, 0x01, 0x28, 1, data_write, 1); hal_i2c_read(I2C0, 0x28, 0x17, 1, &amp;data_read, 1); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e4e385c415c508abdcb754313c17b49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/198d7b1e3f09e48f444788f03d3c98b2/" rel="bookmark">
			松松2023年工作汇报
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注卢松松，会经常给你分享一些我的经验和观点。
今天是2024年1月3号，是我们新年上班的第2天。今天我们的开会内容主要是回顾2023年公司整体发展的情况：
1.人员方面
整个2023年是我们松松公司人员是最稳定的一年，招聘了2位兼职、离职了1位同事，但也是我们花在人力资源上最少的一年。2023年的前四个月，尤其是春节前后，应该是人心最不稳的前四个月，但是到了后半年，从4月份到12月份，人员相对来说就稳定了许多。
2.业绩方面
我原本以为2023年可能会亏损，但是昨天做了粗略一个统计。没有想到，在所有人的共同努力，我们2023年竟然盈利了。其实只要公司能盈利了，这也就意味着我们整体的方向、业务、判断是没有太大问题的。只是因为大环境的影响，大家也看到了。客户在慢慢的减少，业务产品也都在慢慢的减少，整体的市场是萎缩的。但是好在，在我们所有人共同的努力下，我们公司2023年却盈利了，这个其实已经大大的超出我的预期了。
3.业务方面
整个TO B市场端疲软、TO C市场端竞争激烈、TO G端找不到门在哪。这是当前我们的现状。
TO B端：可以说是我们松松云发展立命之本，但目前来看，所有的B端客户都偃旗息鼓，我们现在需要等待市场回暖。服务好老客户，开发一些新客户，切实帮他们解决一些问题。
TO C端：是我们的弱项，从2020年开始我们尝试了外卖CPS、直播带货、短视频带货、社群、虚拟课程。其中外卖、短视频带货都失败了，直播带货、社群不温不火，总之C端业务搞不是很理想。
TO G端：原本是我们2023年想尝试的方向，但无奈找不到大门。这个领域进入的门槛有点高。
杜绝诱惑，只要公司能盈利，就说明路子没走错，去年有位同事一直在叫我开饭店，做实体，去包地种地，还好没开。所以我们尽量在自己能力的基础上开拓新业务。
好，接下里说最后一个事：2024年的发展呢?
核心思想：坚持两手抓两手都要硬。一方面稳固好现有的业务和客户，另一方面探索一些新的项目。
(1)如何维系好想有客户?帮他们解决实际问题是重中之重，其次才是人情世故。
(2)探索一些新的项目?例如：短视频领域有了一定起色，投流花费3万多，也有了部分固定粉丝群。目前已和部分互联网大厂取得了初步联系并接到了16条广告。
在会议的最后，祝愿大家2024年新年快乐，同时也希望在2024年我们一起努力，一起发展，大家一如既往的在这里轻松愉快的工作~
最后呢，我们所有同事会在1月中旬给大家每人送一份礼物，祝大家新年快乐!~
卢松松是一位自媒体人、短视频博主。也是创业者必看的账号，关注草根创业圈、科技互联网、自媒体和短视频行业。感谢您的关注！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b91b5f2cec33712f4e74c61d1232073/" rel="bookmark">
			西电期末1015.等差数列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.题目 二.分析与思路 既然要求输出数据排序后在原数列中的位置，那最好使用结构体，排序后找出相邻差值的最大值和最小值，如果相等，那就是等差数列，反之则不是，按照题目操作即可。
三.代码实现 #include&lt;bits/stdc++.h&gt;//万能头 typedef struct number{ int value; int id; }num;//定义数列结构体 void swap(num* a,num* b){ num t=*a; *a=*b; *b=t; }//交换函数 void sort(num* a,int n){ for(int i=0;i&lt;n-1;i++){ for(int j=0;j&lt;n-1-i;j++){ if(a[j+1].value&lt;a[j].value) swap(&amp;a[j],&amp;a[j+1]); } } }//排序函数 int main() { int n; scanf("%d",&amp;n); num a[n]; for(int i=0;i&lt;n;i++){ scanf("%d",&amp;a[i].value); a[i].id=i+1;//原数列位置 } sort(a,n);//排序结构体 int max=-1000000; int min=1000000; for(int i=0;i&lt;n-1;i++){ int d=a[i+1].value-a[i].value; if(d&gt;max)max=d; if(d&lt;min)min=d; }//打擂台求出排序后最大最小差值 if(max==min){ for(int i=0;i&lt;n;i++){ printf("%d ",a[i].id); } }//相等说明是等差 else{ printf("%d %d"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b91b5f2cec33712f4e74c61d1232073/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5faea1b8ceabbea3f73ab8ac81cb4654/" rel="bookmark">
			SCS【38】单细胞转录组之免疫浸润分析(escape)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简 介 软件包功能允许用户从存储的数据或其他来源输入单细胞RNA-SEQ 计数和任何基因集路径。富集计算本身使用两种方法:
1)gsva R包和RNA的泊松分布;
2)UCell包。
在单细胞RNA测序的背景下进基因集富集分析(GSEA)。使用 raw count information, Seurat objects, or SingleCellExperiment format 作为输入，用户可以对单细胞数据进行分析并可视化GSEA结果。
我们使用这篇文字的数据集进行测试。
软件包安装 if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager") options(BioC_mirror="https://mirrors.tuna.tsinghua.edu.cn/bioconductor") BiocManager::install("dittoSeq") devtools::install_github("dtm2451/dittoSeq") BiocManager::install("escape") devtools::install_github("ncborcherding/escape@dev") devtools::install_github("ncborcherding/escape") 数据读取 准备好的数据集：https://ncborcherding.github.io/vignettes/escape_seurat_ex.rds 直接下载即可。该数据是一个更大的、已发表的皮肤T细胞淋巴瘤项目(CTCL)的一个子集，该项目包含1141个非恶性或正常T细胞(N)和847个恶性T细胞(T)。我们已经将这些数据整合并聚集成8个不同的集群。将更多地了解细胞类型之间的差异。
直接读取.rds文件，并查看单细胞数据分布：
library(escape) library(Seurat) library(dittoSeq) library(ggplot2) library(grDevices) seurat_ex &lt;- readRDS("escape_seurat_ex.rds") seurat_ex &lt;- UpdateSeuratObject(seurat_ex) DimPlot(seurat_ex, label = T) + NoLegend() 查看样本分类：
colorblind_vector &lt;- colorRampPalette(rev(c("#0D0887FF", "#47039FFF", "#7301A8FF", "#9C179EFF", "#BD3786FF", "#D8576BFF", "#ED7953FF", "#FA9E3BFF", "#FDC926FF", "#F0F921FF"))) DimPlot(seurat_ex, group.by = "Type") + scale_color_manual(values = colorblind_vector(2)) 设置数据集 Option 1: Molecular Signture Database 进行基因集富集分析的第一步是确定我们想要使用的基因集。函数getGeneSets()允许用户从GSEABase GeneSetCollection 对象列表中选择整个或多个库。可以通过将参数library设置为library/libraries of interest来对内置 Molecular Signature Database 中的基因集集合进行此操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5faea1b8ceabbea3f73ab8ac81cb4654/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64a77c1f5289ee7e74662f916e293cd4/" rel="bookmark">
			30年前的IDE，堪称上古神器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源 | OSC开源社区
30年前，windows还处于Windows3.0时代，Win95还没有发布。
那个时代，处理器性能还相对较弱，还处于文字，图形化界面也不是很流行，但已经有早期图形化界面的雏形。
那个时代，虽然软硬件资源还很匮乏，但程序员这个职位也在那个年代慢慢涌现，集成开发环境（IDE）也应运而生。
30 年前的集成开发环境 (IDE)，纯文本模式大行其道。在 20 世纪 80 年代末 / 90 年代初，DOS 操作系统上的 IDE 都是基于文本用户界面 (TUI)。这些 IDE 虽然没有图形界面，但却提供了一些令人印象深刻的功能，让程序员们能够进行编码、编译和调试他们的程序。
比如 MS-DOS 自带的编辑器 EDIT.COM。这是一个全屏 TUI 编辑器，提供了菜单栏、对话框、状态栏等功能。虽然不太适合编码，但它展示了当时的技术水平。
另一个经典的 IDE 是 Borland Turbo 系列，比如 Turbo C++。这些 IDE 提供了语法高亮、编译器集成、调试器、项目管理等功能，甚至还有完整的参考手册。这些功能在当时来说非常先进，让程序员们能够在没有互联网的情况下完成整个开发过程。
（语法高亮）
（集成编译器和诊断）
（集成项目和构建系统管理）
（包含断点、堆栈跟踪等功能的调试器）
（完整的使用手册）
有人表示，Bordland 在当时出品的 IDE 确实十分惊艳，但在使用 Bordland Turbo C++ 一段时间后，眼睛都要被亮瞎了……
与此同时，Linux 上的 IDE 并不如 DOS 上的 IDE 那么成熟。虽然也有一些文本模式的程序，比如 Vim 和 Emacs，但它们并不像 Borland Turbo 系列那样提供完整的集成开发环境。这导致了在当时许多程序员还是更倾向于使用 DOS 上的 IDE 进行开发。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64a77c1f5289ee7e74662f916e293cd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24f0d5452efc5fef2670136a0d6a5234/" rel="bookmark">
			uniapp 微信小程序 输入框限制输入2位小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 此处input的type为digit
&lt;input v-model="amount" type="digit" placeholder="请填写金额" @input="checkAmount"/&gt; data() { return { amount:"" } } methods: { // 小数点后2位 checkAmount(e){ e = (e.match(/^\d*(\.?\d{0,2})/g)[0]) || null this.$nextTick(() =&gt; { this.amount = e }) }, } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a4a8d1d94ca50e074d7ee9b2b3509d6/" rel="bookmark">
			2021-01-03 excel实现列递增，行保持不变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：excel文档数据操作的时候发现自动递增只能实现列不变行号递增
我这里里需要的是列递增行不变
解决方式：通过一些函数的组合使用
=INDIRECT("驻场明细!"&amp;CHAR(ROW()+62)&amp;ROW(驻场明细!A$28))
INDIRECT()函数的使用：
=INDIRECT(引用)
引用时一个文本字符串，指定了带引用的单元格的地址。
使用示例： CHAR()函数的使用：
=CHAR(0-255的整数) 返回对应字符
使用示例： =CHAR(65)返回大写字母”A“
=CHAR(97)返回小写字母”a“
ROW()函数的使用：
=ROW()
返回当前行行号
使用示例：
如果函数在A88单元格，则=ROW()返回88
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6381ede716f0d3fcb67569b97aa8a45d/" rel="bookmark">
			零基础开发 React&#43; TS 后台实战课程介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下面所有效果均从零开始进行演示开发：
效果演示图：
登录页 仪表盘首页搭建 引导页制作 React 国际化外语切换 React Ant-deign 组件拆分增删改查 涉及知识点 React 图片上传分页查询组件拆分遮罩层演示数据隔离
React 用户管理 React 公告管理 发布公告 编辑公告
订单管理 分类管理
字典管理 添加字典
编辑字典
字典配置
侧边栏折叠 主题切换 更新中 。。。。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b52438712b75bb97fc332bce515c42c/" rel="bookmark">
			CSS 命名规范-BEM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 BEM 介绍BEM 简单使用 一般来说，解决 css 命名冲突的方案有三种：
命名约定css in jscss modules 这里主要介绍的是通过命名约定这种方案，这种方式，就是提供一种命名的标准，来解决冲突
常见的这些标准有：BEM OOCSS AMCSS SMACSS 其他
BEM 介绍 基于组件方式的web开发方法，基本思想是将用户界面分成独立的模块
BEM 是一套针对 css 类样式的命名方法
BEM 的全称是：Block Element Modifier
一个完整的 BEM 类名：block__element–modifier 例如轮播图的下方的点，用于切换展示的图片，其中被选中的点可以命名为 banner__dot–selected
__通常用于连接元素，--通常链接不同的形态
BEM 具体代表什么呢？
block【块】 代表：Block(块)，独立的一个实体，独立的意义，通俗点理解就是一个页面中的一个大区域，例如前台首页的 header、banner、news、footer等等，每个页面都可以看做是多个 Block 组成，如图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/84d3353fd9d14a0eaf81706ea3d6f3ef.png#pic_center) element【元素】 代表：block 的一部分，比如一个卡片，卡片的头部和底部可以被命名为 card-header 和 card-footer
modifier【修饰符】 代表：通常表示属性或状态，类似与一种标记同一个 block 或者 element 可以拥有多个 modifier，例如一个标签，可以用于警告，标记成功等等状态，tag_warning、tag_success
在某些项目中，如果使用 BEM，还可能会增加一个前缀，表示用途，例如：
l：layout 表示这个样式用于布局
c：component 表示这个样式是一个组件，即一个功能区域
u：util 表示这个样式是一个通用的、工具性质的样式
j：JavaScript 表示这个样式没有实际意义，专门提供给 js 获取元素使用的
在某些公共使用的组件，团队独立封装使用的，还是增加一个标识前缀，例如熟悉的 element-ui，前缀 el
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b52438712b75bb97fc332bce515c42c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa087108377bb56576208d2e08edb22/" rel="bookmark">
			STM32 PVD掉电检测功能的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32 PVD掉电检测功能的使用方法 目录 STM32 PVD掉电检测功能的使用方法前言1 PVD简介1.1 工作原理1.2 软件配置步骤1.3 注意事项 2 程序编写结束语 前言 在实际应用场景中，可能会出现设备电源电压异常下降或掉电的情况，因此，有时候需要检测设备是否掉电，或者在设备掉电的瞬间做一些紧急关机处理，比如保存重要的用户数据，记录运行时间，紧急通知其他平台等等。
1 PVD简介 1.1 工作原理 STM32本身内置了一种掉电检测机制——PVD(Programmable Voltage Detecter)，即可编程电压检测器。
其原理是通过PVD监测电压变化，并提前设定好一个基准电压，当芯片的供电电压高于或低于该基准电压时便产生PVD中断，在PVD中断里面就可以做一些紧急处理。
PVD门限阀值如下图所示：
1.2 软件配置步骤 1、初始化配置PVD参数。
2、在中断函数加入紧急处理代码。
PVD参数具体配置如下：
通过配置电源/状态控制寄存器(PWR_CSR)和电源控制寄存器(PWR_CR)来监控电源电压。
电源控制寄存器(PWR_CR)如下：
其中，PLS[2:0]这几位选择监控电压的阀值。PVDE位用来使能PVD。
电源/状态控制寄存器(PWR_CSR)如下：
其中，PVDO标志用来表明VDD是高于还是低于PVD的电压阀值。
PVD事件在内部连接到外部中断的第16线，如果该中断在外部中断寄存器中是使能的，该事件就会产生中断。当VDD下降到PVD阀值以下和(或)当VDD上升到PVD阀值之上时，根据外部中断第16线的上升/下降边沿触发设置，就会产生PVD中断。通过这一特性可将PVD用于用于执行紧急关闭任务。
1.3 注意事项 1、如果项目使用了多个外设中断，要注意PVD中断的优先级。
2、注意紧急处理代码的执行时间，要在MCU电压降到完全不能工作前执行完（可以通过调整PVD阈值电压，或者在MCU供电电源处加大电容以延缓掉电时间）。
3、PVD的阀值触发有100mV的迟滞（可能是为了消抖，详见上面的PVD门限阀值图），因此，设置阀值时最好留一点余量。
4、如果PVD中断触发方式使用上升下降沿触发，在电压不稳定的情况下可能会反复触发中断，此时可以通过设置标志位来保证紧急代码只运行1次。
2 程序编写 参考测试代码：
/** * @brief This function handles the PVD Output interrupt request. * @param None * @retval None */ void PVD_IRQHandler(void) { if(EXTI_GetITStatus(EXTI_Line16) != RESET) { /* 掉电时运行的紧急代码 */ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aa087108377bb56576208d2e08edb22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/584ccd9191e866a73c946f1f4968ceea/" rel="bookmark">
			重定向的原理及代码演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、重定向的概念 客户浏览器发送http请求，当web服务器接受后发送302状态码响应及对应新的location给客 户浏览器客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location地址，服务器根据此请求寻找资源并发送给客户。 二、代码演示 1、编写界面 创建空工程，在工程中创建javaEE模块
配置中设置tomcat的部署
编写register界面
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;重定向测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="redirectServlet" method="post"&gt; &lt;input type="submit" value="重定向"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 2、编写Servlet 重定向 编写servlet
RedirectServlet
package com.example.sendredirect_demo02; import javax.servlet.*; import javax.servlet.http.*; import java.io.IOException; public class RedirectServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/584ccd9191e866a73c946f1f4968ceea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd52560f5c738cc0870151482ffcbecb/" rel="bookmark">
			STM32内部温度传感器使用方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32内部温度传感器使用方法详解 目录 STM32内部温度传感器使用方法详解前言1 温度传感器简介1.1 工作原理1.2 软件配置步骤1.3 注意事项 2 程序编写结束语 前言 STM32内部集成了一个片上温度传感器，可以用来测量MCU及周围的温度。测量范围：-40~125，精度±1.5℃。虽然精度不高，但在某些应用场景下是够了的，相比于外部接入传感器，使用内部温度传感器既可以节省成本，又可以简化电路。
1 温度传感器简介 1.1 工作原理 STM32内部温度传感器在芯片内部与ADCx_IN16输入通道相连接，此通道把传感器输出的电压转换成数字值，继而换算成温度值。因此，我们只需设置一下内部ADC，并激活其内部通道就可以了。
温度换算公式如下：
T（℃）= ((V25 - Vsense) / Avg_Slope) + 25
注：
1、V25：Vsense在25度时的数值（典型值为：1.43）。
2、Avg_Slope：温度与Vsense曲线的平均斜率（单位为 mv/℃或 uv/℃）（典型值为4.3mv/℃）。
3、Vsense：温度传感器的当前输出电压（温度传感器模拟输入推荐最快采样时间是17.1μs）。
温度传感器特性如下：
1.2 软件配置步骤 1、配置ADC参数。
2、使能内部温度传感器。
3、读取ADC数值并转换成温度值。
1.3 注意事项 1、温度传感器输出电压随温度线性变化，由于生产过程的变化，温度变化曲线的偏移在不同芯片上会有不同(最多相差45°C)。
2、内部温度传感器更适合于检测温度的变化，而不是测量绝对的温度，如果需要测量精确的温度，应该使用一个外置的温度传感器。
3、硬件设计上注意VREF+和VREF-的接入电压（如果该MCU封装有VREF引脚的话，一般64pin及以下的没有）。
2 程序编写 根据上面的原理介绍，使用ADC1的通道16作为采集输入信号，采集到ADC电压值以后根据温度转换公式转换成温度数据。
参考测试代码：
#include "delay.h" #include "sys.h" #include "usart.h" // 初始化配置ADC参数（以规则通道为例） void T_Adc_Init(void) { ADC_InitTypeDef ADC_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_AFIO, ENABLE); // 使能ADC1通道时钟 RCC_ADCCLKConfig(RCC_PCLK2_Div6); // 分频因子6时钟为72M/6=12MHz ADC_DeInit(ADC1); // 将外设ADC1的全部寄存器重设为缺省值 ADC_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd52560f5c738cc0870151482ffcbecb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8d771ef38d83dfc6d59f76b957c1119/" rel="bookmark">
			小猫爪：嵌入式小知识14 - ISO15765（UDS on CAN）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小猫爪：嵌入式小知识14 - ISO15765（UDS on CAN）简介 1 前言2 ISO15765和OSI的联系3 ISO15765-2 网络层定义3.1 拆包和组包（SDU和PDU）3.1.1 帧的定义1. 单帧（SF）2. 首帧（FF）3. 连续帧（CF）4. 流控帧（FC） 3.1.2 帧的传输1. 单帧2. 多帧 3.2 地址定义3.3 超时控制 4 ISO15765-3 应用层定义4.1 超时控制4.2 数据定义 5 AUTUSAR上的实现END 1 前言 ISO15765，相信很多人都听说过这个协议，它还有另外一个小名叫做CAN诊断协议规范，还有个ISO14229(UDS协议规范)，这两者又是什么关系呢，其实可以简单粗暴的理解成ISO15765它规定了基于CAN的UDS协议，而ISO14229则规定了UDS协议应用层以及UDS协议在不同的车载总线(CAN, Ethernet, LIN等)上的应用和限制。想搞清楚这两者的联系和区别可以参考这两篇文章：《聊聊诊断协议——UDS》，《汉子之解读ISO 14229（UDS）协议》。
接下来就来简单介绍一下ISO15765这个ISO协议里面主要规定了哪些东西。
2 ISO15765和OSI的联系 ISO15765共有四个部分，每个部分所规定的信息如下：
名称规定内容ISO15765-1基本信息，大致介绍了一下ISO15765的大致内容ISO15765-2网络层服务ISO15765-3统一诊断服务在CAN上的实现（UDS on CAN）ISO15765-4相关排放系统要求 其中第一部分第四部分对我们理解UDS on CAN用处不到，这里就不多作介绍了，感兴趣的朋友可自行去查看，接下来着重对第二部分和第三部分进行简单介绍。简单的拉出OSI（Open System Interconnect），OSI参考模型是ISO组织在1985年研究的网络互联模型，该体系结构标准定义了网络互联的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层），CAN诊断协议就是基于OSI模式建立的，两者的关系如下：
OSI汽厂增强诊断诊断应用用户自定义应用层ISO15765-3表示层无会话层无传输层无网络层ISO15765-2链路层ISO11898-1物理层用户自定义 从上表中可以看出其中ISO15765-3规定的是OSI模型中的应用层，而ISO15765-2规定了网络层，可以看到CAN的UDS协议还是比较简单的，这得益于CAN通讯比较简单。至于ISO11898-1不用想就知道它就是CAN协议标准。
注：其实对于上表中的各层对应关系，在不同的文档中存在着较大的差异，在部分文档的描述中，会话层并不是空白，而是由ISO15765-3定义，传输层也不是空白，而是由ISO15765-2定义。
3 ISO15765-2 网络层定义 在ISO15765-2中规定了网络层它需要定义什么呢？最主要的就是拆、组包以及超时控制。下面我们来针对这两个方面分别来介绍。
3.1 拆包和组包（SDU和PDU） 所谓拆包和组包其实就是SDU（服务数据单元）和PDU（协议数据单元）两者之间的转换。SDU和PDU是数据在网络模型中上下两层传输过程中格式变换的说法，这样说可能有点抽象，下面就以很通俗的说法来介绍一下。
都知道经典CAN有8个字节，每一帧最大只能传输8个字节的数据，上层网络要想通过CAN帧来传递信息就会出现两种情况，有些消息长度很短，只需要CAN的一帧就可以解决；而有些消息长度很大，无法通过CAN的一帧来完整传输，那么就需要将该消息按照一定规则进行分割成若干个CAN帧进行传输。以上其实就是ISO15765-2中定义的最关键的部分，下面具体看一下这个ISO15765中制定的拆包和组包的规则。
3.1.1 帧的定义 ISO15765-2为实现上一目标将CAN帧分成了以下四种类型。
1. 单帧（SF） 一条消息仅用一帧即可完成传输，即为单帧（SingleFrame），单帧第一个字节byte0的高4位为0，第一个字节byte0的低四位（SF_DL）为接下来准备传输的数据长度，从第二个字节byte1至最后一个字节byte7为传输的数据，所以CAN诊断数据发送长度得小于等于7个字节。
单帧中SF_DL定义如下：
16进制值描述0保留1 ~ 6单帧数据长度值（SF_DL）7SF_DL = 7 时，只允许标准地址8 ~ F无效 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8d771ef38d83dfc6d59f76b957c1119/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8e084ebd216f809c041194018042c85/" rel="bookmark">
			【计算机网络】网络基础--协议/网络协议/网络传输流程/地址管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、计算机网络背景二、协议1.协议是什么2.为什么要有协议 三、网络协议1.为什么要进行协议分层2.OSI七层模型3.TCP/IP五层(或四层)模型 四、网络传输基本流程1.协议报头2.局域网3.数据包封装和分用4.网络传输流程图 五、网络中的地址管理1.认识IP地址2.认识MAC地址3.理解IP地址和MAC地址的关系 一、计算机网络背景 网络的发展分为一下几个阶段：
独立模式: 计算机之间相互独立：
此时计算机之间是相互独立的，每个人在执行任务的时候是独立的，需要等待前一个将任务完成之后，自己才能进行执行任务，是串行执行的，效率很低。
网络互联: 多台计算机连接在一起, 完成数据共享：
此时数据完成了共享，每个人都使用独立的计算机，业务之间可以随时自由切换，共享数据由服务器集中处理
局域网LAN: 计算机数量更多了, 通过交换机和路由器连接在一起
广域网WAN: 将远隔千里的计算机都连在一起
注意：所谓 “局域网” 和 “广域网” 只是一个相对的概念. 比如, 我们有 “天朝特色” 的广域网, 也可以看做一个比较大的局域网。
一台计算机内部本质也是一个小型的网络结构。
比如我们将一台计算机的磁盘拉到很远的地方，此时依然可以进行存储，此时为云存储，同理，其他的硬件结构也可以这样，所以计算机 体系结构中有网络，网络中有体系结构
二、协议 1.协议是什么 我们举一个例子进行说明，以前的时候，只有台式的座机，然而那个时候话费也特别的贵，你要上学去读书，你到了学校需要向自己的父母进行报备，没有了零花钱需要找父母要，这时，你和你的爸爸进行约定，你打电话过来一声之后就挂断了就说明安全到学校了，打电话过来两声之后才挂断电话说明没有了零花钱，打电话过来三声都还没有挂断，则说明有其他重要的事情，这样就可以省很多的电话费，同时也能够达到通信的目的。
上面的例子中，电话响一声，表明安全到学校了，电话响两声，表明没有了零花钱，电话响三声，说明有其他重要的事情。
3种都代表不同的含义，而这个含义不用解释，双方早已有了共识。所以协议就是约定
计算机之间的传输媒介是光信号和电信号. 通过 “频率” 和 “强弱” 来表示 0 和 1 这样的信息. 要想传递各种不同的信
息, 就需要约定好双方的数据格式.
只要通信的两台主机, 约定好协议就可以了么?
当然不是，我们举一个例子来进行说明，比如我们门卫的口令是天王盖地虎，宝塔镇河妖，但是我们这里的人来自全国各地，回答的时候可能就是自己的方言，那么门卫就不知道回答的对不对。所以我们需要要求在回答口令的时候，全部都使用普通话，这样才可以。
所以，计算机生产厂商有很多; 计算机操作系统, 也有很多; 计算机网络硬件设备, 还是有很多; 如何让这些不同厂商之间生产的计算机能够相互顺畅的通信? 就需要有人站出来, 约定一个共同的标准, 大家都来遵守, 这就是 网络协议;
2.为什么要有协议 我们面对面进行交谈的时候，障碍比较少，不容易出错，但是当我们两个人站在相隔500米的桥的两端的时候，此时进行交流通信就会变得极其困难。
对于计算机来说，所有的网络问题，本质都是传输距离变长了，此时就可能会引入新的通信问题，为了尽可能减少通信成本，就需要定制协议，如果使用计算机语言来进行表达，则称为计算机协议
三、网络协议 1.为什么要进行协议分层 协议分层有如下的原因：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8e084ebd216f809c041194018042c85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72b32e237da3b9327e8cbead80e55b27/" rel="bookmark">
			Java Integer之IntegerCache
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前两天看了篇帖子，两个Integer对象做比较时，会产生意想不到的结果。想起之前也有遇到这样的情况，一直没有总结，今天简单记录一下。
相信大家一定遇到过这样的问题：==与equals有什么不同？
两者都需要区分基本数据类型与非基本数据类型。
对于==来说，如果是基本数据类型则比较值是否相等，如果是（非基本数据类型）对象则比较指向该对象的引用是否相等。
举个小例子：
Integer a = 100; Integer b = 100; System.out.println(a == b);// true Integer c = 1000; Integer d = 1000; System.out.println(c == d);// false 然而
int e = 1000; int f = 1000; System.out.println(e == f);// true 那么为什么呢？
Java的8中基本类型分别是：byte、short、int、long、float、double、char和boolean。
Integer作为int类型的包装类型，并不属于Java中的8种基本类型。在Java中，除了上面的这8种类型，其他的类型都是对象，保存的是引用，而非数据本身。
至于为什么两次比较的结果不一致，暂且别急，先看看下面的问题：
Integer a = 1000; Integer a = new Integer(1000); // 这两者的区别在哪里？ 区别：
内存使用：对于较小的整数值（在缓存范围内），使用自动装箱的方式可以节省内存空间，而使用显式的构造函数调用方式则会在堆内存中为每个新创建的对象分配不同的内存空间。
对象的唯一性：对于较小的整数值（在缓存范围内），使用自动装箱的方式，每次使用相同的值创建的Integer对象都是同一个对象。而对于较大的整数值，无论使用哪种方式，每次创建的Integer对象都是不同的。
性能：对于较小的整数值（在缓存范围内），自动装箱的方式由于使用了缓存机制，创建和比较对象的速度更快。对于较大的整数值，自动装箱和显式构造函数调用方式都需要在堆内存中分配新的对象，性能相对较低。
对于前者来说，当你将一个基本类型值直接赋给一个包装类型的变量时，编译器会自动进行装箱操作，将基本类型值包装成对应的包装类型对象。
而后者这种方式使用了显式的构造函数调用。在这种情况下，通过使用构造函数new Integer(1000)来创建一个新的Integer对象。这种方式会在堆内存中为每个新创建的对象分配不同的内存空间，即使两个Integer对象的值相同。
要注意的是，前者写法并不是后者的简写形式。对后者来说其正确的简写形式为：
Integer a = Integer.valueOf(1000); 在定义对象a和b时，Java自动调用了Integer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72b32e237da3b9327e8cbead80e55b27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70ddc6e087181933ae067f1d1e006e3c/" rel="bookmark">
			机器学习期末复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习 选择题名词解释：简答题计算题一、线性回归二、决策树三、贝叶斯 选择题 机器学习利用经验 ，须对以下（）进行分析
A 天气 B 数据 C 生活 D 语言
归纳偏好值指机器学习算法在学习的过程中，对以下（）的偏好
A 数据 B 某种类型假设 C 标记 D 运行速度
有的情况下 ，模型学习到了训练数据满足的特有性质，但这些性
质不是一般规律，这种现象被称为（）
A 欠拟合 B 过拟合 C 欠配 D 以上三个选项都不是
最小二乘法估计 得到的线性回归模型 满足（）性质
A 均方模型为 0 B 均方误差偏大 C 均方误差偏小 D 均方误差为 1
下列（）是决策树的预测过程。
A 将测试示例从一个中间节点开始，沿着划分属性所构成的“判
定测试序列”下行，知道叶节点、
B 将测试实例从一个中间节点开始，沿着划分属性所构成的“判
定测试序列”上行，直到根节点。
C 将测试示例从叶节点开始，沿着划分属性 所构成的“判定测试
序列”上行，直 到根节点。
D 将测试示例从根节点开始，沿着划分属性所构成的“判定测试
序列”下行，直到叶节点。
BP 算法基于（）策略对参数进行调整
A 梯度下降 B 梯度上升 C 最小化误差 D 误差逆传播
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70ddc6e087181933ae067f1d1e006e3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11eab0503e57f056022d28e4b8a1c8f5/" rel="bookmark">
			机械键盘音乐律动无效、改键无效等问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：最近买了第一把机械客制化键盘，因为是98键的，而我习惯了104键位的，所以刚拿到就找客服要了驱动，想要改键，没想到怎么都没效果，而且音乐律动也没用，琢磨了两天，我总结了下面几个解决方法，希望对后来者有所帮助
以下步骤主要解决音乐律动，因为音乐律动解决了，改键也就基本成功了。
目录
1.做好准备工作
2.到控制面板进行设置
主要操作
补充（关于连接蓝牙耳机）
3.重启电脑
1.做好准备工作 音乐律动需要先做以下准备工作：
必须是连线的，多模的键盘先将键盘使用USB连线方式与电脑连接，蓝牙模式下是无法开启音乐律动的！驱动软件必须是打开的！而且要调到音乐律动的界面 （之前我一直以为音乐律动有另外的开关，但其实只要调到那个界面就可以了）如下所示： 备注：不同键盘有自己的驱动软件，可以找卖家问，如果有他会告诉你下载地址的。
2.到控制面板进行设置 如果你做完准备工作后键盘没有效果，那么恭喜你进入第二步。
主要操作 打开控制面板 进入硬件和声音点击声音 右键点击扬声器，选择属性 取消红框中的两个选项 到这里基本大部分就可以了，如果不行的就进入第三步。
补充（关于连接蓝牙耳机） 如果蓝牙耳机没有律动的话，还可以尝试下面这个，将空间音效改成 用于耳机的Windows Sonic试试。（但是笔者不是很推荐，亲测会改变音乐原本的声音，听李荣浩的歌，差点没听出来是他唱的就离谱）
还可以尝试关闭驱动软件，重新再开一下。
或者多设置几种方案，然后切换试试。
3.重启电脑 因为设置了 声音 的属性，所以可能一时无法生效，因此最后你可以试试重启电脑，并且我建议在重启前就把USB线插上，以及设置驱动软件自动开启。
最后，做完以上步骤，我的问题就解决了，如果你还有问题可以发在评论区大家一起探讨，如果不会改键的话，也可以在评论区提出来，人数多的话我就再出一篇教程说一下我的经历 ^_^。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deec6a537f3a6131cea3febe39fceed2/" rel="bookmark">
			QT上位机开发（数据库sqlite编程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【 声明：版权所有，欢迎转载，请勿用于商业用途。 联系信箱：feixiaoxing @163.com】
编写软件的时候，如果用户的数据比较少，那么用json保存是非常方便的。但是一旦数据量大了之后，建议还是用数据库来进行管理比较好。数据库在增、删、改、查这方面还是比较好用的。目前，有一种小型的开源数据库sqlite，特别适合大家来使用。它是嵌入在软件程序里面的。和mysql不一样，mysql是单独一个数据库服务器。
1、qt对sqlite的支持 本身qt可以直接访问sqlite数据库，引用头文件的时候，直接输入QtSql即可，如下所示，
#include &lt;QtSql/QtSql&gt; 2、链接时的注意事项 默认，qt是没有把QtSql的lib放入到链接库当中的，所以这部分需要自己手动来完成，如下所示，
3、测试方法 首先我们可以创建一个简单的qt widget工程。在界面部分不需要再做任何的修改，所以也就不需要designer的参与。代码部分呢，可以编写一个loadDB的类函数。在这个类函数里面，为了测试sqlite的功能，我们可以做一些增、删、改、查的操作，如果所有的操作都是ok的，那就代表测试代码是正确的、没问题的。
4、loadDB函数的编写 测试的过程基本是这样的。首先，利用QSqlDatabase创建一个data.db的数据库。有了这个数据库之后，打开数据库。接下来用QSqlQuery进行第一个操作，就是创建一张mytable的表。有了表之后，我们就可以插入数据、查询数据、更改数据、查询数据、删除数据、查询数据，总共是6个动作。所有动作都做完毕之后，就可以关闭数据库了。在数据库操作的过程当中，还可以通过qDebug打印的办法来判断操作是否正确。qDebug打印的地方就在输出窗口里面，如下所示，
整个测试的源代码是这样的，
int QtWidgetsApplication::loadDB() { // create database QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE"); db.setDatabaseName("data.db"); // open database if (!db.open()) { qDebug() &lt;&lt; "Error: Unable to open database"; return 1; } // execute query QSqlQuery query; // create a table if (!query.exec("CREATE TABLE IF NOT EXISTS mytable (id INTEGER PRIMARY KEY, name TEXT)")) { qDebug() &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/deec6a537f3a6131cea3febe39fceed2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3369e526a083b3c15a493db4c862cba/" rel="bookmark">
			明明加了唯一索引，为什么还是产生重复数据？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 前段时间我踩过一个坑：在mysql8的一张innodb引擎的表中，加了唯一索引，但最后发现数据竟然还是重复了。
到底怎么回事呢？
本文通过一次踩坑经历，聊聊唯一索引，一些有意思的知识点。
1.还原问题现场 前段时间，为了防止商品组产生重复的数据，我专门加了一张防重表。
如果大家对防重表，比较感兴趣，可以看看我的另一篇文章 《高并发下如何防重？》，里面有详细的介绍。
问题就出在商品组的防重表上。
具体表结构如下：
CREATE TABLE `product_group_unique` ( `id` bigint NOT NULL, `category_id` bigint NOT NULL, `unit_id` bigint NOT NULL, `model_hash` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL, `in_date` datetime NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin; 为了保证数据的唯一性，我给那种商品组防重表，建了唯一索引：
alter table product_group_unique add unique index ux_category_unit_model(category_id,unit_id,model_hash); 根据分类编号、单位编号和商品组属性的hash值，可以唯一确定一个商品组。
给商品组防重表创建了唯一索引之后，第二天查看数据，发现该表中竟然产生了重复的数据：
表中第二条数据和第三条数据重复了。
这是为什么呢？
2.唯一索引字段包含null 如果你仔细查看表中的数据，会发现其中一个比较特殊地方：商品组属性的hash值（model_hash字段）可能为null，即商品组允许不配置任何属性。
在product_group_unique表中插入了一条model_hash字段等于100的重复数据：
执行结果：
从上图中看出，mysql的唯一性约束生效了，重复数据被拦截了。
接下来，我们再插入两条model_hash为null的数据，其中第三条数据跟第二条数据中category_id、unit_id和model_hash字段值都一样。
从图中看出，竟然执行成功了。
换句话说，如果唯一索引的字段中，出现了null值，则唯一性约束不会生效。
最终插入的数据情况是这样的：
当model_hash字段不为空时，不会产生重复的数据。
当model_hash字段为空时，会生成重复的数据。
我们需要特别注意：创建唯一索引的字段，都不能允许为null，否则mysql的唯一性约束可能会失效。
3.逻辑删除表加唯一索引 我们都知道唯一索引非常简单好用，但有时候，在表中它并不好加。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3369e526a083b3c15a493db4c862cba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f68cce2442b6172651167f6b7d357afa/" rel="bookmark">
			Java中100==100为true，而1000==1000为false？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天跟大家聊一个有趣的话题，在Java中两个Integer对象做比较时，会产生意想不到的结果。
例如：
Integer a = 100; Integer b = 100; System.out.println(a==b); 其运行结果是：true。
而如果改成下面这样：
Integer a = 1000; Integer b = 1000; System.out.println(a==b); 其运行结果是：false。
看到这里，懵了没有？
为什么会产生这样的结果呢？
1 Integer对象 上面例子中的a和b，是两个Integer对象。
而非Java中的8种基本类型。
8种基本类型包括：
byte
short
int
long
float
double
boolean
char
Integer其实是int的包装类型。
在Java中，除了上面的这8种类型，其他的类型都是对象，保存的是引用，而非数据本身。
Integer a = 1000; Integer b = 1000; 可能有些人认为是下面的简写：
Integer a = new Integer(1000); Integer b = new Integer(1000); 这个想法表面上看起来是对的，但实际上有问题。
在JVM中的内存分布情况是下面这样的：
在栈中创建了两个局部变量a和b，同时在堆上new了两块内存区域，他们存放的值都是1000。
变量a的引用指向第一个1000的地址。
而变量b的引用指向第二个1000的地址。
很显然变量a和b的引用不相等。
既然两个Integer对象用==号，比较的是引用是否相等，但下面的这个例子为什么又会返回true呢？
Integer a = 100; Integer b = 100; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f68cce2442b6172651167f6b7d357afa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6476de785d3d6c84788fa095dbc59d96/" rel="bookmark">
			关于HAL库外部中断的开关流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过HAL库配置好外部中断后，会生成如下代码：
static void MX_GPIO_Init(void) { GPIO_InitTypeDef GPIO_InitStruct = {0}; /* USER CODE BEGIN MX_GPIO_Init_1 */ /* USER CODE END MX_GPIO_Init_1 */ /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOD_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); /*Configure GPIO pin : PA3 */ GPIO_InitStruct.Pin = GPIO_PIN_3; GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); /* EXTI interrupt init*/ HAL_NVIC_SetPriority(EXTI3_IRQn, 0, 0); HAL_NVIC_EnableIRQ(EXTI3_IRQn); /* USER CODE BEGIN MX_GPIO_Init_2 */ /* USER CODE END MX_GPIO_Init_2 */ } 设置中断引脚
GPIO_InitStruct.Pin = GPIO_PIN_3;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6476de785d3d6c84788fa095dbc59d96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdb4a8fce047be8c98792a5ddc77f14f/" rel="bookmark">
			用 MATLAB 产生单位抽样序列、单位阶跃序列、矩形序列、正弦序列和复指数序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		%% 单位抽样（脉冲）序列（冲激函数） % 参数设置 n = -10:10; % 定义时间范围 delta = (n == 0); % 生成单位抽样序列 % 绘图 figure; stem(n, delta); title('单位抽样序列'); xlabel('n'); ylabel('delta[n]'); %% 单位阶跃序列 % 参数设置 n = -10:10; % 定义时间范围 u = (n &gt;= 0); % 生成单位阶跃序列 % 绘图 figure; stem(n, u); title('单位阶跃序列'); xlabel('n'); ylabel('u[n]'); %% 矩形序列 % 参数设置 n = -10:10; % 定义时间范围 rect = (n &gt;= -5) &amp; (n &lt;= 5); % 生成矩形序列 % 绘图 figure; stem(n, rect); title('矩形序列'); xlabel('n'); ylabel('rect[n]'); %% 正弦序列 % 参数设置 n = 0:50; % 定义时间范围 A = 1; % 振幅 f = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdb4a8fce047be8c98792a5ddc77f14f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cac09ab3ec3cc72248c8fd0a94c2c42e/" rel="bookmark">
			大数据平台Bug Bash大扫除最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 随着越来越多的"新人"在日常工作以及大促备战中担当大任，我们发现仅了解自身系统业务已不能满足日常系统开发运维需求。为此，大数据平台部门组织了一次Bug Bash活动，既能提升自己对兄弟产品的理解和使用，又能促使自家产品功能日趋完善。今天来给大家分享一些实际操作过程和经验总结~
二、什么是Bug Bash？ Bug Bash，顾名思义就是缺陷大扫除。通常由QA主导发起，团队全员放下手中的活，找个会议室一起集中精力来找缺陷。
图 1
三、Bug Bash好处 1、常规测试的有效补充，更多用户测试发现更多问题或需求。
有可能发现业务流程上存在不同类型、不同层次的疏漏，整体设计上隐蔽的缺陷，甚至产品规划上暗藏的新需求。不同的人员更容易发现兼容性、权限差异等问题。测试人员也可以根据发现的问题完善自己的测试策略，
2、提高团队凝聚力，促进团队彼此沟通。
在增加了一些比赛的元素缺陷大扫除中，比如时不时的播报谁发现的bug多，配上轻松愉悦的音乐，让大家你追我赶的找出bug。这样来推动人员之间的良性竞争，从而鼓舞团队人员的士气，增加团队的凝聚力。
3、深入产品学习，带来更多附加价值。
在日常的工作中，产研测更多时间都是在独立的工作，只关注自己负责的部分，很少就产品问题进行集体交流，很少深度使用整个产品。通过bugbash可以让团队其他角色作为用户体验产品，深入了解业务。在对这些问题进行集中讨论，并详细解释如何处理以及为什么这么处理过程中，可以引发更多产品的思考。
四、Bug Bash组织实践 图 2
1、活动准备 1.1、部门宣贯 在部门工作咚咚群内通知本次bugbash活动的计划安排（https://joyspace.jd.com/sheets/XXXX），确定活动组织时间、活动会议室、小组划分情况。目前部门内产品主要包括JDQ、JRC、集成平台三大产品，为更有效的进行相互"扫除"，我们进行了轮次划分，小组划分。如下表所示：
轮 次小 组答疑人员时 间地 点备 注第1轮JRC vs JDQJRC：段东妮 JDQ：尹伟2023.11.15 18:00红河会议室自由探索人员自行选择产品扫除第2轮集成平台 vs JRC+JDQ集成平台：郭卫卫 JRC：段东妮 JDQ：尹伟2023.11.22 18:00红河会议室自由探索人员自行选择产品扫除 表 1
提示：本次bugbash是针对生产环境进行扫除，涉及到流程审批环节时需提前通知对方审批，避免因未审批导致阻塞后面的流程。
1.2、用例准备&amp;评审 bugbash正式开始之前，测试人员应提前准备各自负责产品的测试用例，并邀请产品经理、产品主研发一起进行用例评审，划定活动范围。可以参考以下几个方面：
产品的主流程业务场景。比如创建binlog采集任务、正常消费topic数据等。
日常运维工作中经常用到的场景。比如消费者暂停消费操作等。
跨平台联合查询场景。比如通过JDQ消费者username查询关联的JRC的flink任务等。
隐藏性功能场景。比如正常情况下A功能不会显示，需要打开某个开关才可正常显示等。
图 3
1.3、测试数据准备 根据用例场景、活动参加人数来准备测试数据。主要包括所属平台、测试数据类型、测试jed数据表、测试ck数据表、测试数据说明、使用人如下图所示：
图 4
提示：提前给活动参与人员统一添加权限。比如使用指定的项目空间。
2、活动进行 活动时间安排：10分钟介绍本活动轮次情况，50分钟任务执行，10分钟交流发言。
2.1、任务分配 根据活动轮次、小组划分情况进行任务划分，以JRC vs JDQ为例，JRC的研发等相关人员执行JDQ的任务，反之，JDQ的研发相关人员执行JRC的任务。
2.2、测试数据分配 为避免使用相同测试数据导致任务创建冲突等情况，双方人员需对测试数据进行标记认领。如上图4 使用人列。
2.3、问题记录 双方人员在大扫除过程中发现问题及时记录到joyspace中，不需要现场讨论产品细节，标明测试验证人、测试时间、结果填写、测试验证结果。将来可以根据问题的价值与重要程度给予不同奖励。如上图3 所示
2.4、现场答疑 产品主测试人员为活动答疑人员，双方人员可能存在以下场景需要现场支持：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cac09ab3ec3cc72248c8fd0a94c2c42e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4e21c954132310ce97b8074b0112942/" rel="bookmark">
			新型冠状病毒肺炎国内分省分日期从1.16起的全部数据爬取与整理代码（附下载）（网址已失效！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一 新型冠状病毒肺炎国内分省分日期全部数据（1.16起）：原始json格式数据下载csv格式数据下载 二 数据来源与抓取数据到手流程 三 数据下载与整理成csv 一 新型冠状病毒肺炎国内分省分日期全部数据（1.16起）： 原始json格式数据下载 https://ncportal.esrichina.com.cn/JKZX/yq_20200117.json
https://ncportal.esrichina.com.cn/JKZX/yq_20200118.json
https://ncportal.esrichina.com.cn/JKZX/yq_20200119.json
等等…（把后面的yq_…换成自己想要的日期即可）
csv格式数据下载 链接：https://pan.baidu.com/s/10hpprJ8sMoucJQfvik5SzQ
提取码：6lhy
这是从json格式数据整理来的，整理的代码在下面
二 数据来源与抓取 来自最权威的网站：http://2019ncov.chinacdc.cn/2019-nCoV/
如果了解爬虫的可以往下看，不熟悉的可以直接到上面拿数据
数据到手流程 进入网站后f12，当我们点击地图，在切换省市查询具体数值时，HTML中有一个“data-zr-dom-id=“zr_0””的canvas在动态变化，所以证明这些数据是由js文件操作的。切换省市查询时在Network中并没有新的数据包，所以证明所有的数据都已经下载在本地了，而js只是读取数据填充并绘图，哎嘿嘿！在Sources中我们看到2019ncov.chinacdc.cn主机下2019-nCoV文件夹下有个js文件夹和config.js文件，当我们点开config.js时，数据的芳香扑面而来。从config.js文件中我们可以看到，它列了很多json格式的文件，如yq_20200116.json，yq_20200117.json等，我们通过网址 https://ncportal.esrichina.com.cn/JKZX/yq_20200117.json 可以得到2020年1月17日那天的全部数据原始数据是json格式，而且地点，日期，各项指标写的很清楚，我们直接转换就行 三 数据下载与整理成csv 数据有省市之分，有日期之分，有新增、累积之分，有确诊、疑似之分，因此这里我导出csv格式后，横坐标是省份，纵坐标是日期，每个单元格格式是：新增确诊-新增疑似-新增死亡-累积确诊-累积疑似-累积死亡
自动下载json格式原始数据代码：
import requests import datetime import time # 得到从startdate开始后N天的日期 def get_n_day_after(start_date, n): date_datetime = datetime.datetime.strptime(start_date, "%Y-%m-%d") date = str( datetime.datetime(date_datetime.year, date_datetime.month, date_datetime.day) + datetime.timedelta(n)).split() return date[0] for i in range(60): date = get_n_day_after('2020-01-16', i) date = "".join(date.split("-")) url = "https://ncportal.esrichina.com.cn/JKZX/yq_" + date + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4e21c954132310ce97b8074b0112942/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feda7673df013d947a7e1cb23b47cdbe/" rel="bookmark">
			linux系统下sql脚本的执行与导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		terminal中执行 执行
mysql -u [username] -p -D [databasename] &lt; [XXX.sql]
导出
mysql -u [username] -p [datbasename] &gt; [XXX.sql]
导出的数据库名自定义。
mysql -u [username] -p [databasename] [tablename] &gt; [xxx.sql]
导出表名自定义
mysql shell 执行 source [绝对路径]
source /home/xiaoxu/projetc/food_platform/food_platform.sql
runboob.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02c1727bb907aefa019a657268934f88/" rel="bookmark">
			postman设置下载文件大小限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 本地写了一个下载文件的接口，调用postman测试的时候，小文件可以，但时大文件就会报错，postman提示：
解决方案 点击postman的设置按钮，点击【Settings】，在打开的弹窗中选择【General】Tab页，然后再页面找到【Max response size in MB】，默认是50M，改为你需要的就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc7f7b777c5a4b9878c5146bcdab7415/" rel="bookmark">
			数字孪生在区块链的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字孪生与区块链的结合可以为一些应用场景提供额外的安全性、透明度和可追溯性。以下是数字孪生在区块链上的一些潜在应用，希望对大家有所帮助。北京木奇移动技术有限公司，专业的软件外包开发公司，欢迎交流合作。
1.供应链管理：
区块链可以用于建立数字孪生的供应链管理系统，确保产品的全生命周期数据都被安全地记录在不可篡改的区块链上。这有助于提高供应链的透明度、追溯性和安全性。
2.智能合同：
使用区块链的智能合同功能，数字孪生可以与智能合同相结合，使得在数字孪生中发生的事件可以自动触发合同条款的执行。这有助于简化合同管理流程。
3.知识产权管理：
将数字孪生与区块链结合，可以用于管理知识产权。通过将知识产权的信息记录在区块链上，确保数据的不可篡改性，从而更好地保护知识产权。
4.产品认证和防伪：
区块链可以用于数字孪生的产品认证和防伪。每个产品的信息都被记录在区块链上，消费者可以通过区块链查询产品的真实性和生产信息。
5.数字孪生市场交易：
区块链可以用于数字孪生市场的交易。通过区块链技术，确保数字孪生数据的安全传输和可信交易，减少中间商和数据篡改的可能性。
6.数据共享和隐私保护：
区块链提供了去中心化的数据管理方式，可以用于数字孪生的数据共享。参与方可以通过区块链共享数据，同时确保数据隐私和安全。
7.设备生命周期管理：
将数字孪生与区块链结合，可以实现设备生命周期的安全管理。从制造到维护再到报废，每个阶段的信息都被记录在不可篡改的区块链上。
8.智慧城市和物联网：
在智慧城市和物联网应用中，数字孪生可以与区块链一起使用，以确保城市基础设施的可靠性和数据的安全性。这包括智能交通、能源管理等方面。
9.环境监测和溯源：
在农业和食品产业中，数字孪生可以结合区块链，实现对农产品生产环境的数字孪生化监测和产品追溯。这有助于提高产品的质量和安全性。
数字孪生和区块链的结合可以为这些应用场景带来更高的信任度、数据安全性和可追溯性，推动数字孪生在更多领域的应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6183126130557ae23a1ddab32a7332bd/" rel="bookmark">
			探访纳尔逊美术馆里的绝世中华艺术品收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		位于美国中部的堪萨斯城（Kansas City）对于绝大多数中国人来说，其实是很陌生的。然而，坐落在此处的纳尔逊-阿特金斯艺术博物馆（Nelson-Atkins Museum of Art）却对每个到访美国的中国人来说应该是具有某种特殊意义的，因为这里是海外收藏中国古代艺术品最丰富的几个博物馆之一（不可否认，其中很多都是在过去兵荒马乱的时候流失海外的珍贵文物）。在总计超过八千件中国收藏品中，有许多精品已然于国内再也无法看到同类收藏了。
当然，这里除了为数众多的中国藏品之外，其实世界各国的大师之作也是随处可见。下面这幅是梵高的画作：
以及印象派大师莫奈的作品：
下面重头戏来了，博物馆里的中国馆有好几个大型展厅，展品极其丰富，商代的青铜器，到元代的壁画、唐代的石雕，令人叹为观止。
商朝、西周时期的青铜器：
汉代的一对儿石狮：
后面的三件值得更详细介绍一下。如果你时间有限，那么这几件绝对不要错过。
1）广胜寺壁画《炽盛光佛法会图》（元代）
山西省洪洞县的广胜寺为第一批全国文物重点保护单位。广胜寺分为上寺和下寺，其中下寺以精美绝伦的元代壁画而著称。下寺的前殿、后殿原本各有一幅巨型壁画，内容分别是药师菩萨经辩图和炽盛光佛法会图。尺寸更大的药师菩萨经辩图现收藏于纽约大都会博物馆，纳尔逊美术馆中的就是这幅尺寸稍小的炽盛光佛法会图（如下所示）。当你静静伫立在这幅鸿篇巨制之前，会不觉显得人如此渺小。当你仔细端详斑驳的带有明显切割痕迹的古代遗珍，加上前面的宋代木雕水月观音像，内心真是五味杂陈，感慨万千。
2）易县三彩罗汉像（辽代）
上个世纪初，军阀混战，民不聊生。1912年，河北易县一个偏僻的山洞里惊现十六尊令人叹为观止的等身三彩罗汉像。而且，这也是迄今为止唯一发现的辽代孤品（你肯定听过唐三彩，但辽三彩极其罕见）。
辽代三彩等身罗汉像原本一共16尊，偷盗和运输过程中至少毁坏了3尊。目前，可查的存世罗汉像共10尊（其中一尊还是不完整的，只有头胸部分），却没有一尊留在中国。可想而知它们的珍贵程度。纳尔逊美术馆里现收藏有其中的一尊，如果你有幸到此，千万不要错过。
3）文昭皇后礼佛图（北魏）
《文昭皇后礼佛图》是20 世纪 30 年代龙门石窟宾阳中洞被盗凿的几幅大型浮雕之一。原本是一对儿，分别是孝文帝礼佛图和文昭皇后礼佛图，这两幅浮雕一起雕刻在洞窟出口处显眼的位置。孝文帝礼佛图藏于纽约大都会艺术博物馆，《文昭皇后礼佛图》藏于美国堪萨斯城的纳尔逊艺术博物馆。
这组浮雕是魏宣武帝为了纪念他的父母孝文帝（467-499）和文昭皇后（469-496）而建造的，表现了皇室成员步入洞窟礼佛的场景。其中呈现皇后出行的浮雕描绘了手捧各类贡品的侍女，两位头戴莲冠的宫妃在她们的簇拥下迎风徐行。浮雕中身披霞帔，下摆有密集褶皱的人物很可能是文昭皇后。而那位站在文昭皇后身边，体量较小的人物则可能是辅佐幼年孝文帝执政的冯皇太后（442-490）。出现在队伍最后的侍从手持扇子华盖。
这幅《文昭皇后礼佛图》运至海外时损坏程度较大，博物馆里的展品是基于残件修复而来的。
同一展厅里还有很多唐代的“佛头”，显然都是从原件上切割下来的。可见当年的文物盗掘和倒卖对这些稀世珍品的损害有多大。有些东西，一旦流失，真的是再难追回。中国人想再看一眼祖先们巧夺天工的存世遗珍，也不得不远渡重洋。现在想来还是不禁令人唏嘘。
【本文完】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/125c61d55a6b701911995604c8bcb46f/" rel="bookmark">
			基于SpringBoot的康复中心管理系统 JAVA简易版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 普通用户模块2.2 护工模块2.3 管理员模块 三、系统展示四、核心代码4.1 查询康复护理4.2 新增康复训练4.3 查询房间4.4 查询来访4.5 新增用药 五、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL的康复中心管理系统，包含了访客管理、房间管理、入住退房管理、缴费管理、药品档案管理、康复训练、网上咨询模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，康复中心管理系统基于角色的访问控制，给医院管理员、护理人员使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
1.2 项目录屏 二、功能模块 2.1 普通用户模块 （1）登录注册：用户填写相关信息后并注册，可以登录登出系统
（2）信息管理：管理个人资料信息，修改可修改的信息项
（3）入住登记：患者编号、姓名、年龄、性别，具体入住的楼层以及房间号
（4）来访登记：具体来访人的身份证信息、姓名、年龄登记
（5）网上咨询：用户可以输入咨询问题，咨询问题的编号，用户账号，审核状态，等具体回复审核等
（6）康复护理：患者的康复护理安排事宜，安排时间等
（7）缴费中心：罗列患者需要缴费的清单，患者编号、姓名、用户账号、缴费价格等
（8）用药记录：记录患者康复时所用所有药品
（9）退房登记：楼层、房间号、床位号、患者编号、退房时间等
2.2 护工模块 （1）患者护理：对入住患者进行必要的日常护理安排
（2）康复训练：对入住患者进行康复训练安排
（3）用药记录录入：对患者的用药情况进行记录
（4）药品库存：对药品的入库出库进行记录
（5）房间信息：可以查询所有入住患者的信息
（6）收费标准：药品的具体名称、价格、收费价格等
2.3 管理员模块 （1）普通用户管理：删除普通用户账号，冻结普通用户账号等
（2）护工管理：可以增删查改护工人员
（3）药品管理：输入药品编号、名称、用途、图片以及对药品库管理
三、系统展示 四、核心代码 4.1 查询康复护理 @RequestMapping(value = "/getByPage", method = RequestMethod.GET) @ApiOperation(value = "查询康复护理") public Result&lt;IPage&lt;Nurse&gt;&gt; getByPage(@ModelAttribute Nurse nurse ,@ModelAttribute PageVo page){ QueryWrapper&lt;Nurse&gt; qw = new QueryWrapper&lt;&gt;(); if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/125c61d55a6b701911995604c8bcb46f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42a81b65bd765ceab0f4ac1f1d4f4617/" rel="bookmark">
			Qt/C&#43;&#43;编写视频监控系统82-自定义音柱显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 通过音柱控件实时展示当前播放的声音产生的振幅的大小，得益于音频播放组件内置了音频振幅的计算，可以动态开启和关闭，开启后会对发送过来的要播放的声音数据，进行运算得到当前这个音频数据的振幅，类似于分贝，分贝越大，听到的声音越大，振幅越大。在如何摆放音柱控件这个问题上，考虑过多种方案，比如一开始做的是固定放在视频控件的右侧，也就是在一个垂直布局中先放一个视频控件，然后放左通道音柱，最后放一个右通道音柱，三个控件之间设置好间距。后面用户又提出来直接音柱控件悬浮在视频控件上方，这样可以节约位置，以便视频控件争取最大的地方展示，所以近期又专门重新搞了下，音柱可以放置在左侧、右侧、顶部、底部、两侧、悬浮等位置，然后还可以设置音柱的尺寸，如果是垂直摆放对应尺寸就是宽度，如果是上下摆放对应尺寸就是高度，还有个难点就是纯音频的通道，音量条需要摆放在中间位置，比如音量条左右两侧是一个弹簧，音量条尺寸取宽度的四分之一，这样看起来就非常美观了。
由于视频控件还有悬浮条，所以这个音柱的摆放位置，还需要留出足够的位置给悬浮条展示，然而呢悬浮条又有多种位置，比如也可以设置在底部，所以需要根据悬浮条的位置，再留出对应的间隙。在Qt的便利性，要设计这样一个带视频带悬浮带音柱，而且还支持非常灵活的各种参数设置，还是非常方便的，比如就新建个frmVideoWidgetVolume带音柱的视频窗体，悬浮条也是一个独立的widget，根据尺寸变化对应移来移去。音柱控件这边，通过表格布局来插入对应的控件。比如需要两侧显示音柱，则先插入左声道音柱，然后插入视频控件，最后插入右声道音柱控件。难点就在纯音频的音道控件，他需要根据尺寸占比自动拉伸，而且一个窗体需要根据打开的地址来区分当前是否是纯音频，所以需要在解码完成和结束的时候去做判断处理，打完收工。
二、效果图 三、体验地址 国内站点：https://gitee.com/feiyangqingyun国际站点：https://github.com/feiyangqingyun个人作品：https://blog.csdn.net/feiyangqingyun/article/details/97565652体验地址：https://pan.baidu.com/s/1d7TH_GEYl5nOecuNlWJJ7g 提取码：01jf 文件名：bin_video_system。 四、相关代码 #include "frmvideowidgetvolume.h" #include "ui_frmvideowidgetvolume.h" #include "qthelper.h" #include "videowidgetx.h" #include "barvolume.h" frmVideoWidgetVolume::frmVideoWidgetVolume(int position, VideoWidget *videoWidget, QWidget *parent) : QWidget(parent), ui(new Ui::frmVideoWidgetVolume) { ui-&gt;setupUi(this); this-&gt;position = position; this-&gt;videoWidget = videoWidget; bgText = videoWidget-&gt;getBgText(); isVertical = true; if (position == 2 || position == 4) { isVertical = false; } //实例化音柱控件并设置方向 leftVolume = new BarVolume; rightVolume = new BarVolume; leftVolume-&gt;setVertical(isVertical); rightVolume-&gt;setVertical(isVertical); //实例化布局并设置边距间距 QGridLayout *layout = new QGridLayout(this); layout-&gt;setContentsMargins(0, 0, 0, 0); layout-&gt;setSpacing(3); //将音柱控件和视频控件插入到对应位置/可以自行拓展各种布局 if (position == 1) { layout-&gt;addWidget(leftVolume, 0, 0); layout-&gt;addWidget(rightVolume, 0, 1); layout-&gt;addWidget(videoWidget, 0, 2); } else if (position == 2) { layout-&gt;addWidget(leftVolume, 0, 0); layout-&gt;addWidget(rightVolume, 1, 0); layout-&gt;addWidget(videoWidget, 2, 0); } else if (position == 3) { layout-&gt;addWidget(videoWidget, 0, 0); layout-&gt;addWidget(leftVolume, 0, 1); layout-&gt;addWidget(rightVolume, 0, 2); } else if (position == 4) { layout-&gt;addWidget(videoWidget, 0, 0); layout-&gt;addWidget(leftVolume, 1, 0); layout-&gt;addWidget(rightVolume, 2, 0); } else if (position == 5) { layout-&gt;addWidget(leftVolume, 0, 0); layout-&gt;addWidget(videoWidget, 0, 1); layout-&gt;addWidget(rightVolume, 0, 2); } else if (position == 6) { //实例化弹簧控件 spaceLeft = new QSpacerItem(0, 0, QSizePolicy::Expanding, QSizePolicy::Preferred); spaceCenter = new QSpacerItem(0, 0, QSizePolicy::Expanding, QSizePolicy::Preferred); spaceRight = new QSpacerItem(0, 0, QSizePolicy::Expanding, QSizePolicy::Preferred); //实例化布局并插入控件 hlayout = new QHBoxLayout; hlayout-&gt;addWidget(leftVolume); hlayout-&gt;addItem(spaceCenter); hlayout-&gt;addWidget(rightVolume); videoWidget-&gt;setLayout(hlayout); layout-&gt;addWidget(videoWidget); } //关联音频振幅信号 connect(videoWidget, SIGNAL(sig_receiveLevel(qreal, qreal)), this, SLOT(receiveLevel(qreal, qreal))); //打开和关闭后需要清空下(有可能残留上一次的数据) connect(videoWidget, SIGNAL(sig_receivePlayStart(int)), this, SLOT(reset())); connect(videoWidget, SIGNAL(sig_receivePlayFinsh()), this, SLOT(reset())); //音柱窗体参数变化后需要重置 connect(AppEvent::Instance(), SIGNAL(changeVolumeWidget()), this, SLOT(reset())); } frmVideoWidgetVolume::~frmVideoWidgetVolume() { delete ui; } void frmVideoWidgetVolume::resizeEvent(QResizeEvent *) { int width = this-&gt;width(); int height = this-&gt;height(); //根据宽度动态设置音量条宽度或者高度/也可以设置成固定值 int size = (isVertical ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42a81b65bd765ceab0f4ac1f1d4f4617/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d5f52fed53e81ae1276893d6c851c60/" rel="bookmark">
			解决Gitlab Prometheus导致的磁盘空间不足问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决Gitlab Prometheus导致的磁盘空间不足问题 用docker搭建了一个gitlab服务，已经建立了多个项目上传，但是突然有一天就503了。
df -TH查看系统盘，发现已经Used 100%爆满了。。。
💡Tips：/dev/vda1目录是系统盘目录。
去云服务器上面看，短短半个月就占满了整个系统盘。。。
然后，看了看gitlab容器卷挂载目录data中，有一个prometheus目录居然占了29G，百度了一下，原来这个是用来监控的。。。所以，内容一直堆积堆积，导致磁盘满了。。。
GitLab中的 Prometheus 解释如下：
GitLab中的Prometheus是一个用于监控和报警的开源系统，它能够收集并汇总时间序列数据，用于检测异常。同时，GitLab还提供了一些关于Prometheus的基础功能，包括数据聚合、存储时间等。这些功能可以帮助用户更好地了解其系统运行状况，并及时发现和解决潜在问题。
/var/opt/gitlab/prometheus/data是 Prometheus 生成的监控数据文件，可参考文档 Monitoring GitLab with Prometheus。
解决办法：
先备份一下，云服务器购买个存储库，备份一下，临时的话可以用先按需计费省钱。因为，我已经备份了，所以我就可以肆无忌惮的删一点。就把gitlab/data/prometheus/data/wal里面的一大文件删了一部分，保证gitlab的服务能启动起来。 💡Tips：可能因为系统盘已经爆满，项目启动不起来，可以手动删除wal目录下面的一些大文件，先让磁盘有些空余，保险起见还是要提前备份一下。
修改一下gitlab/config/gitlab.rb 配置文件。 周期默认是15d是15天，意思是15天后重新记录。此处，我就改为了1d也就是1天。
也可以直接把prometheus禁用了。
prometheus['enable'] = false 💡参考：gitlab prometheus占用磁盘过大-腾讯云开发者社区-腾讯云
再次，重启项目docker restart gitlab 就healthy启动了。 系统盘也释放了很多。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/40/">«</a>
	<span class="pagination__item pagination__item--current">41/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/42/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>