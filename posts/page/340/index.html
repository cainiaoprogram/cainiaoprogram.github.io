<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7a72abbfe768586b31bcd4992a6b7f7/" rel="bookmark">
			canny算子图像处理实现（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		canny算子图像处理实现（C++） 一、基本原理二、实现流程2.1 计算步骤2.2 流程图 三、实现代码四、处理结果 一、基本原理 先利用高斯函数对图像进行低通滤波；然后对图像中的每个像素进行处理，寻找边缘的位置及在该位置的边缘法向，并采用一种称之为“非极值抑制”的技术在边缘法向寻找局部最大值；最后对边缘图像做滞后阈值化处理，消除虚假响应。
二、实现流程 2.1 计算步骤 先利用高斯平滑滤波器来平滑图像以除去噪声(即用高斯平滑滤波器与图像作卷积)；计算梯度的幅值和方向；对梯度幅值进行非极大值抑制；用双阈值检测和连接边缘。 2.2 流程图 三、实现代码 #include "gdal_priv.h" #include "cpl_conv.h" #include &lt;iostream&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/opencv.hpp&gt; #include&lt;cmath&gt; #include &lt;string&gt; #include &lt;vector&gt; //栈与队列 #include&lt;stack&gt; #include&lt;queue&gt; using namespace std; using namespace cv; #define PI 3.141592 typedef Point Cpoint; int main(int argc, char** argv) { void canny(Mat image); //将所有需要的库函数等，导入进来并改变位数为X64 //包括VC++目录，C/C++常规、连接器常规等，不同的库路径不同，引入的位置也不同 string filename = "G:/myself/Major/MathPhotograph/Experiment/Picture05.jpg";//斜杠的方向不能反 //Mat image = readImage(argc, argv,filename); //Mat pInterValue(image.rows, image.cols, CV_8UC1, Scalar::all(0));//创建一个全为0的Mat格式,注意，c：通道数 //argc: 整数, 用来统计你运行程序时送给main函数的命令行参数的个数 //* argv[ ]: 指针数组，用来存放指向字符串参数的指针，每一个元素指向一个参数 if (argc &gt; 1)	//如果参数比1大的话，就把第一个参数赋值给filename { filename = argv[1];	//将参数赋值给filename } Mat image = imread(filename, IMREAD_GRAYSCALE);	//灰色样式读取图像到Mat中IMREAD_COLOR//IMREAD_GRAYSCALE//IMREAD_UNCHANGED if (image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7a72abbfe768586b31bcd4992a6b7f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3270c2b7a7ad4da72dabc223f232cd15/" rel="bookmark">
			flask基础根据知了课堂整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1安装Python2.7： Mac下使用Python2.7.Windows下安装Python2.7. 从python官网下载python2.7的版本。双击python2.7，然后选择安装路径，一顿下一步就可以了。设置环境变量，把python的安装路径添加到PATH变量中。还需要设置一个环境变量，一定要设置，不然后面就不能正常安装flask了。 2Python虚拟环境介绍与安装： 因为python的框架更新迭代太快了，有时候需要在电脑上存在一个框架的多个版本，这时候虚拟环境就可以解决这个问题。通过以下命令安装虚拟环境：pip install virtualenv开辟新的虚拟环境：virtualenv [virtualenv-name]激活虚拟环境： [类linux]：source [虚拟环境的目录]/bin/activate[windows]：直接进入到虚拟环境的目录，然后执行activate退出虚拟环境：deactivate 3pip安装flask： 执行activate脚本，进入指定的虚拟环境。在该虚拟环境中，执行以下命令安装：pip install flask验证flask是否安装成功： 进入python命令行。 import flask
print flask.version
认识url： 如果使用的是http协议，那么浏览器就会使用80端口去请求这个服务器的资源。如果使用的是https协议，那么浏览器会使用443端口去请求这个服务器的资源。
http://www.jianshu.com/
https://www.baidu.com/
https://www.baidu.com/s?ie=utf-8&amp;f=8 http://baike.baidu.com/link?url=ELcglgxAgFQ9WlMytXEhxu-WBtI7mTlDj3TJ-Ht6ZSecAYt0hgqY0euqaB60opaEEZ7JChin5vUd_YkOgMi7BT5kc3E85ZXeoVL2iVfKZu_jHMcNabK8NXilqnfJknKs
http://baike.baidu.com/link?url=ELcglgxAgFQ9WlMytXEhxu-WBtI7mTlDj3TJ-Ht6ZSecAYt0hgqY0euqaB60opaEEZ7JChin5vUd_YkOgMi7BT5kc3E85ZXeoVL2iVfKZu_jHMcNabK8NXilqnfJknKs#3
http://baike.baidu.com/link?url=ELcglgxAgFQ9WlMytXEhxu-WBtI7mTlDj3TJ-Ht6ZSecAYt0hgqY0euqaB60opaEEZ7JChin5vUd_YkOgMi7BT5kc3E85ZXeoVL2iVfKZu_jHMcNabK8NXilqnfJknKs#5
4URL详解 URL是Uniform Resource Locator的简写，统一资源定位符。
一个URL由以下几部分组成：
scheme://host:port/path/?query-string=xxx#anchor scheme：代表的是访问的协议，一般为http或者https以及ftp等。
host：主机名，域名，比如www.baidu.com。
port：端口号。当你访问一个网站的时候，浏览器默认使用80端口。
path：查找路径。比如：www.jianshu.com/trending/now，后面的trending/now就是path。
query-string：查询字符串，比如：www.baidu.com/s?wd=python，后面的wd=python就是查询字符串。
anchor：锚点，后台一般不用管，前端用来做页面定位的。
5web服务器和应用服务器以及web应用框架： web服务器：负责处理http请求，响应静态文件，常见的有Apache，Nginx以及微软的IIS.
应用服务器：负责处理逻辑的服务器。比如php、python的代码，是不能直接通过nginx这种web服务器来处理的，只能通过应用服务器来处理，常见的应用服务器有uwsgi、tomcat等。
web应用框架：一般使用某种语言，封装了常用的web功能的框架就是web应用框架，flask、Django以及Java中的SSH(Structs2+Spring3+Hibernate3)框架都是web应用框架。
01Flask基础 6第一个flask程序讲解： 第一次创建项目的时候，要添加flask的虚拟环境。添加虚拟环境的时候，一定要选择到python这个执行文件。
比如你的flask的虚拟环境的目录在/User/Virtualenv/flask-env/bin/python。flask程序代码的详细解释：# 从flask这个框架中导入Flask这个类 from flask import Flask # 初始化一个Flask对象 # Flaks() # 需要传递一个参数__name__ # 1. 方便flask框架去寻找资源 # 2. 方便flask插件比如Flask-Sqlalchemy出现错误的时候，好去寻找问题所在的位置 app = Flask(__name__) # @app.route是一个装饰器 # @开头，并且在函数的上面，说明是装饰器 # 这个装饰器的作用，是做一个url与视图函数的映射 # 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3270c2b7a7ad4da72dabc223f232cd15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bcb635a1ad30eb78f95523f7791a1d5/" rel="bookmark">
			父与子的编程之旅 python 3 pdf_父与子的编程之旅pdf微盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		父与子的编程之旅pdf微盘下载！《父与子的编程之旅》全书以爱的漫画、有趣的例子，生动地介绍了变量、循环、输入和输出、数据结构以及图形用户界面等编程的基本概念，让读者能够更加容易地读懂此书！有需要的点击下载看看！
内容简介
本书是一本家长与孩子共同学习编程的入门书。作者是一对父子，他们以Python语言为例，详尽细致地介绍了Python如何安装、字符串和操作符等程序设计的基本概念，介绍了条件语句、函数、模块等进阶内容，最后讲解了用Python实现游戏编程。书中的语言生动活泼，叙述简单明了。 为了让学习者觉得编程有趣，本书编排了很多卡通人物及场景对话，让学习者在轻松愉快之中跨入计算机编程的大门。
第 2 版新增内容
首先，我们来说说第 2 版中有哪些内容没有改变，那就是我们决定在第 2 版中继续使用 Python 2，而不是转换到 Python 3。我们会在第 1 章解释其中的原因。
下面是第 2 版与第 1 版的不同之处
增加了一些说明，解释 Python 2 和 Python 3 的区别。
第 12 章增加了一节关于 Python 字典的内容。
在第 20 章的 GUI 编程部分，我们将不再被支持的 PythonCard 换成了应用更广泛的 PyQt。PyQt 也用在第 22 章的 Hangman 程序和第 24 章的电子宠物程序中。
增加了第 25 章，用来详细解释第 10 章中的 Skier 程序。
增加了第 26 章，讲述在简单的对战游戏中，如何编写一个有人工智
作者简介
Warren Sande
毕业于加拿大里贾那大学电气工程系。一直在面向计算机初学者教授软件基础课程，编写过大量广受欢迎的技术文档。
Carter Sande
是Warren之子，高中生，热爱计算机技术，喜欢编写复古的视频游戏。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/738633fbdad2a397fb1f5434d821451f/" rel="bookmark">
			图像处理——同态滤波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是同态滤波
同态滤波（Homomorphic filter）是信号与图像处理中的一种常用技术，它采用了一种线性滤波在不同域中的非线性映射。
首先介绍两个概念
同态系统：是将非线性问题，转化为线性问题处理。即对非线性（乘性）混杂信号，通过某种数学运算（如对数变换），变成加性模型，而后采用线性滤波方法进行处理。
同态滤波：是把频率滤波和空域灰度变换结合起来的一种图像处理方法，它根据图像的照度/反射率模型作为频域处理的基础，利用压缩亮度范围和增强对比度来改善图像的质量。
同态滤波的原理
一幅图像可看成由两部分组成，即
fi代表随空间位置不同的光强（Illumination）分量，其特点是缓慢变化，集中在图像的低频部分。
fr代表景物反射到人眼的反射（Reflectance）分量，其特点包含了景物各种信息，高频成分丰富。
同态滤波过程，分为以下5个基本步骤：
① 原图做对数变换，得到如下两个加性分量，即
② 对数图像做傅里叶变换，得到其对应的频域表示为：
③ 设计一个频域滤波器H(u,v)，进行对数图像的频域滤波。
④ 傅里叶反变换，返回空域对数图像。
⑤ 取指数，得空域滤波结果。
综上，同态滤波的基本步骤如下图所示。
首先上面的分析一共有三点需要注意：
① 取对数，目的是基于我们假定的图像模型将低频和高频信号进行分离
② 然后频域处理，即减弱低频增强高频达到增强细节的作用
③ 反操作得到处理后图像
可以看出，同态滤波的关键在于滤波器H的设计。对于一幅光照不均匀的图像，同态滤波可同时实现亮度调整和对比度提升，从而改善图像质量。为了压制低频的亮度分量，增强高频的反射分量，滤波器H应是一个高通滤波器，但又不能完全cut off 低频分量，仅作适当压制。
因此，同态滤波器一般采用如下形式，即
其中，rL&lt; 1, rH &gt;1，控制滤波器幅度的范围。Hhp通常为高通滤波器，如高斯（Gaussian）高通滤波器、巴特沃兹(Butterworth)高通滤波器、Laplacian滤波器等。
如果Hhp采用Gaussian高通滤波器，则有：
其中，D0为gaussian滤波器的截止频域，c为一个常数，控制滤波器的形态，即从低频到高频过渡段的陡度（斜率），其值越大，斜坡带越陡峭，见图2。
其中我们需要关注的参数一共有4个，分别为：
① rh 高频权重
②rl 低频权重
③ c 高斯函数的陡峭程度(并不是很重要)
④d0 手动区分低频和高频的比例
图2 同态滤波器幅频曲线
同态滤波作用
同态滤波利用去除乘性噪声(multiplicative noise)，可以同时增加对比度以及标准化亮度，借此达到图像增强的目的。
一副图像可以表示为其照度(illumination)分量和反射(reflectance)分量的乘积，虽然在时域上这两者是不可分离的，但是经由傅立叶转换两者在频域中可以线性分离。由于照度可视为环境中的照明，相对变化很小，可以看作是图像的低频成分；而反射率相对变化较大，则可视为高频成分。通过分别处理照度和反射率对像元灰度值的影响，通常是借由高通滤波器(high-pass filter)，让图像的照明更加均匀，达到增强阴影区细节特征的目的。
代码实现
import cv2 import numpy as np def homomorphic_filter(src, d0=10, rl=0.5, rh=2.0, c=4, h=2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/738633fbdad2a397fb1f5434d821451f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ead2f8b6754d8a25492657b19d48933/" rel="bookmark">
			运营新人也可以做的副业平台丨闲鱼运营（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		没有副业的运营是失败的
如果你是程序员不做副业可以理解，因为你的薪水高如果你是产品经理不做副业也可以理解，因为项目太大，一个人完成困难如果你是UI、剪辑不做副业的也可以理解，有可能是自己不会推广 但是你做运营工作，日常就会接触到各个领域的运营和玩法，完全可以利用业余时间做一些自己的事情，比如你是一名新媒体运营，日常负责公司的公众号，那业余时间也可以开一个自己的公众号运营。
不过这也涉及到一个情况，对于新手来说能力成熟前做副业也确实比较困难，接下里四哥给大家分享的是，不用写作、不用出镜做视频、不用囤货只要掌握玩法和运营套路，新人也可以做的运营副业
这次给大家分享的是咸鱼运营副业玩法
那首先我们先明确一个问题啊，咸鱼是什么？
首先这个闲鱼它是阿里巴巴旗下的一个闲置交易平台，阿里巴巴旗下有很多产品，包括淘宝、天猫，咸鱼就是其中之一
那咸鱼它的定位是一个闲置交易平台，简单来说就是一个二手交易平台
它的登录方式和注册非常简单
如果你有淘宝或者支付宝的账号的话，你就可以直接绑定登录，没有什么复杂的流程，它的开店流程，相比于淘宝来说非常的简便
只要是你有淘宝或者说支付宝的账户，你就可以一键转卖个人淘宝号当中的一些已买到了宝贝，或者说你自己卖一些，自己比如说不打算要了一些二手产品，你就拍一张照片儿，然后上传到这个平台，这样你就可以直接发布这个商品了。
非常简便，如果大家有兴趣的话，也可以现在就下载一下这个APP，然后你的去继续去上传一些商品
闲鱼的功能是非常简单，而且它不止如此，市场潜力也是非常大的。
具艾瑞数据提供
一个专业媒体报道说2019年咸鱼的交易额是两千亿
这个两千亿是一个很夸张的数字
如果说你没有什么概念的话，我做一个类比，就是说一个70年的知名品牌，全国有3万家分店，也就是说基本能做到家喻户晓的这样一个品牌
麦当劳他一年的销售额有多少呢？撑死了一千亿。
所以你想想，咸鱼它这种线上二手交易平台，它的一个全年交易额能超过两千亿，其实是一个非常庞大的规模
而且未来大家对互联网技术普及，包括大家对这个平台的了解越来越多，我相信未来这个数字肯定还会继续扩大。
那说完咸鱼，我们来看一下咸鱼上究竟如何去赚钱？
咸鱼赚钱的方式是一种无货源、信息差、价格差的玩法，它是怎么做的呢？
就是像拼多多、1688这样的低价商品平台，你去选择一些性价比比较高的商品，将这些商品的信息上架到咸鱼这个平台上，然后咸鱼上如果说有人想购买你的商品，那你就去这些拼多多，1688这些低价商品平台去下单
然后将地址跟单号变成买家的，就是相当于赚钱一个中间商的一个差价
闲鱼其实就是这样一个赚钱的模式，赚钱的逻辑其实打的就是一个价格差。
知道了闲鱼的赚钱逻辑，闲鱼具体该如何运营呢？
其实就是分为三个部分
第一个部分是闲鱼养号，第二部分是内容编辑，第三部分是产品运营。
第一个养号不要多介绍，很多新媒体平台，比如抖音、头条、小红书这些平台主流的新媒体平台，他们都是有一个养号的过程，那包括闲它也是如此，只不过他的养号方式肯定跟那些图文或者内容型的产品有些区别。
第二个就是内容编辑，就是说你想上架一个商品，首先这个商品要有详情页，要有内容，要有文案，那这些内容如何去编辑？那这是我们第二个要考虑的问题。
第三个问题是产品运营，也就是说我们在运营过程中会遇到哪些问题？
我们应该如何更好的去解决？
那好，今天我们的文章主要就是围绕着三部分，我们详细来看一下。
一、闲鱼养号 闲鱼养号主要分为两个部分，第一部分是店铺权重，第二部分是芝麻积分。
在开始前跟大家说一下，闲鱼本质上是一个电商平台，并不像那种自媒体平台，比如说像什么公众号、今日头条、抖音这种自媒体平台。
电商平台它有一个特点是什么呢？
就是说它的流量分配算法跟自媒体的是有很大区别的
比如说像今日头条、一点资讯，或者说抖音之类有算法加持的这种主流新媒体平台，他们是怎么运作的呢？
他们是追求人和内容的匹配度。
比如说你的文章关键词跟读者本身这个标签儿很匹配，那算法就会把这篇文章推荐给相应人群，如果这时候用户对此篇文章得到反馈，比如转发了或者点赞了，那么平台就会认为这是一篇优质内容，就会推荐给更多的人群。
那电商平台其实相比于算法来说，它更注重的是内容质量
这里的内容质量跟传统意义上的图文平台也有区别，这里内容的质量简单概括为买的人多，退款人少，好评多，差评少。
其实总体来说，电商平台也就是通过这四个维度来判定优质情况
那接下来我们看一下闲鱼养号的第一个流程：芝麻积分
芝麻积分大家应该很熟悉了
芝麻积分是你支付宝里面的一个功能，包括你借钱、用花呗、用借呗等一些就是信贷功能，你都需要用到这个芝麻积分
这个积分它其实是一个信誉系统，可以判定你这个人的信用如何，咸鱼引入这个体系也是有原因的。
假如说你是一个守信用的卖家，那很好，那你相对稳定。
你推荐或者说你上架的商品，肯定更靠谱更有保障一些
积分这个功能在阿里很多产品其实都有广泛的应用，咸鱼作为阿里旗下的产品肯定当仁不让也是引用了这套系统判定基本信誉，也就是说这个芝麻积分
那这里我们就是简单给大家归类，也做了一个总结，就是说你想要运营好咸鱼就是两个方面
第一个方面店铺权重要要做高越高越好。第二个部分是芝麻分数也要做高越高越好。 那我们看先看一下这个芝麻。
这个芝麻积分前面我们说过了，它是一种信誉体系，就是判定你这个人的信誉如何。
这个评分主要根据五个维度判定
首先这个芝麻积分是跟你过往的经历相关的。
也就是相当于你的一个个人档案，你曾经做过什么事情，比如说失信的一些记录，或者说逾期的记录，积分里都会有记录。
那么看一下评判这个芝麻积分的维度。
第一个是什么社交链的关系，这里是什么呀？就是说你的交友方面。
你的朋友是否评分高，或者说是否有一些固定的资产，或者说你们之间有没有经常的来往。
这里我建议是每个月你可以加20个650分以上的好友或者说其他阿里平台的一些就是高信用的好友也可以。
然后和家人朋友有一些金钱来往。另外就是可以绑定一下钉钉脉脉这些平台，钉钉跟脉脉是职场人比较常用的APP。
这里简单跟大家介绍一下钉钉，钉钉的功能类似于一种办公软件，也是阿里开发的一个产品。
这个钉钉其实如果你绑定支付宝支付的话，那其实你的信用分会有一个提高。
另外一个就是脉脉，就是说你如果要个人认证的话，会需要你的一些身份认证信息。这个时候你绑定一下支付宝支付，那这样的话你的信用分数也会提高。总之就是能绑定支付宝支付的地方。都是可以提高你的信用分数。
第二个是历史信誉。
就是说你是否有过理财的记录，或者说你是是否正常履约了。比如说像一些电费呀、水费呀，你是否正常缴纳了。
重要的还是这个履约你到底有没有逾期记录。如果你有逾期的话，那你的分数肯定会降低
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ead2f8b6754d8a25492657b19d48933/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78cd686c9e4bfb0923a8396e9eca3afd/" rel="bookmark">
			部署dashboard
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部署dashboard 1.编写RBAC.yaml文件
apiVersion: v1 kind: ServiceAccount metadata: name: nginx-sa --- apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: name: nginx-role rules: - apiGroups: - "" resources: - pods verbs: - get - list - watch --- apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: nginx-rolebinding roleRef: apiGroup: rbac.authorization.k8s.io kind: Role name: nginx-role subjects: - kind: ServiceAccount name: nginx-sa 2.查看secret
kubectl get secret 3.查看对应的token
kubectl describe secret nginx-sa-token-775kt 4.定义dashboard.yaml
# Copyright 2017 The Kubernetes Authors. # # Licensed under the Apache License, Version 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78cd686c9e4bfb0923a8396e9eca3afd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a5f6881b6aab693ad8a0b429f1c0edc/" rel="bookmark">
			openwrt下tcpdump抓取usb数据包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址::https://blog.csdn.net/m0_38134493/article/details/72723733?utm_source=blogxgwz3
相关文章
1、linux下的usb抓包方法----https://www.cnblogs.com/listenerln/p/7263481.html
2、Linux下Tcpdump使用----https://www.cnblogs.com/hzl6255/p/6147985.html
3、linux下usb抓包方法----https://blog.csdn.net/tommy_ly/article/details/97666028
4、Linux 抓USB包----https://blog.csdn.net/zmnqazqaz/article/details/50497733?utm_source=blogxgwz2
这两天在看USB转串口的驱动，并在想办法解决一个4G设备通过USB插入openwrt后枚举的串口无法收发的问题。看了大概有一个星期了，大概把USB是什么搞清楚了。但是USB的世界实在是太复杂了，除了USB协议本身，枚举出来的设备和系统中的其他总线总是有一腿，才刚接触linux内核的东西，感觉头大，实在不是短时间能啃下来的。好了废话不多说，先看看我处理tcpdump是怎么抓取usb总线数据的吧。
相关软件 openwrt(我用的是bb版本，linux内核3.10.49)wireshark(我用的最新版本2.2.6)tcpdump(抓包神奇)libpcap (tcpdump以来的库)usbmonitor (usb数据包，就靠它了) 一，编译openwrt支持tcpdump和libpcap 1.1, 在 menuconfig中选择tcpdump和libpacap中的usb Network--&gt; [*] tcpdump Libraries--&gt; -*- libpcap--&gt; Configuration---&gt; [*] Include USB support （注意这个一定要选上，否则你别想通过tcpdump抓usb包） 1234567 下面还有一个 tcpdump mini，我没有用，也没管。
1.2, 在menuconfig 中选择usbmointor Kernel modules---&gt; USB support--&gt; [*] kmod-usbmon 123 1.3， 在kernel_menuconig 内核配置中选择usb monitor Device Drivers --&gt; [*] USB support ---&gt; &lt;*&gt; USB Monitor 123 二，执行make编译 三，下载到目标板 具体的板子不一样，我这里就不写了
四，抓包 终于到了抓包了。
4.1，确认一下你的设备在USB哪个总线上 $ cat /sys/kernel/debug/usb/devices T: Bus=01 Lev=01 Prnt=01 Port=00 Cnt=01 Dev#= 2 Spd=12 MxCh= 0 D: Ver= 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a5f6881b6aab693ad8a0b429f1c0edc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b09823a8ca60bd67418b253c45459a8/" rel="bookmark">
			Java String类型的特性（复用性，值不可变性）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java String类型的特性 " 复用性 "， “ 值不可变性 " Java String类型的特性复用性直接赋值直接赋值与new关键创建对象区别 值不可变性 Java String类型的特性 Java 中的 String 类型不同与其他引用类型，一般的引用类型的特性在 String 类型上你会发现并不适用。其实是 Java 对 String 类进行了包装，所以你会感觉他与其他引用类型有所不一样。这其中就要说到他的两个特性：复用性和值不可变性。
复用性 直接赋值 String s1 = "abc"; String s2 = "abc"; System.out.println(s1 == s2); 上面程序运行的结果：true
这是一个令人疑惑的问题，为什么会是 true 呢？引用对象 ” == “ 比较的不是地址吗？难道它们的地址是一样的？
它们的地址是一样的，这个就是 String 的复用性。"abc"是存放在常量池中的，并且 s1 和 s2 都指向同一个地方。
当把字符串 “abc” 赋值给 s1 时，Java虚拟机会先查看常量池中是否有 “abc” 这个值，如果没有就开辟一个空间把 “abc” 存放进去然后把地址赋值给 s ，如果有就直接把 “abc” 对应的地址赋值给 s1。同理当把字符串 “abc” 赋值给 s2 时会进行相同的操作，所以 s1 与 s2 指向的地址会是同一个。这个与Java对String的封装有关，为了减少内存的浪费，赋予了 String 复用性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b09823a8ca60bd67418b253c45459a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fba60974910a753c17ffb7caabbf65f/" rel="bookmark">
			[MT8167S][Android 9.0]MTK平台的LCM流程分析——lk层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在MTK平台点亮一块屏不是难事，因为MTK的LCM框架很完善，我们的屏驱动需要的工作不是很多。不过要想成为一个优秀的工程师，不能仅仅满足于此，至少要了解整个框架流程。
MTK平台的lcm流程分为Lk和kernel两个阶段，这篇文章我们先来分析lk阶段的流程。
正文 lk阶段起来后，display相关的初始化主要在platform_init()函数中完成。
vendor\mediatek\proprietary\bootable\bootloader\lk\platform\mt8167\platform.c
void disp_thread_routine() { #ifdef LK_PROFILING unsigned int time_disp_init; time_disp_init = get_timer(0); #endif /* initialize the frame buffet information */ g_fb_size = mt_disp_get_vram_size(); --------------------- （1） /* framebuffer的起始地址 */ g_fb_base = mblock_reserve(&amp;g_boot_arg-&gt;mblock_info, g_fb_size, 0x10000, 0x100000000, RANKMAX); dprintf(CRITICAL, "FB base = 0x%x, FB size = %d\n", g_fb_base, g_fb_size); #ifdef VDEC_LDVT_RESERVED_MEMORY_SIZE g_vdec_base = mblock_reserve(&amp;g_boot_arg-&gt;mblock_info, VDEC_LDVT_RESERVED_MEMORY_SIZE, 0x200000, 0x100000000, RANKMAX); g_vdec_base = ALIGN_TO(g_vdec_base,0x200000); dprintf(CRITICAL, "VDEC base = 0x%x, VDEC size = %d\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fba60974910a753c17ffb7caabbf65f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37745792c54d6083c8bda1626f3dacc9/" rel="bookmark">
			python计算思维、数组计算与曲线绘制_用Python学计算思维海龟作图小提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.
import turtle
#
导入海龟画图模块
2.
turtle.forward(100)
#
向右画一条长度为
100
单位的直线
3.
turtle.left(90)
#
左转
90
度
4.
turtle.bgcolor(
“
black
”
)
#
设置背景颜色为黑色
5.
turtle.pensize(3)
#
设置画笔宽度为
3
6.
turtle.pencolor("red")
#
设置颜色为红色
7.
turtle.speed(5)
#
设置画笔移动速度，画笔绘制的速度范围
[0,10]
整数，数字越大越快。默认是
6
8.
turtle.penup()
#
抬笔
9.
turtle.pendown()
#
落笔
10.
turtle.goto(-100,100)
#
移到坐标为(
-100,100
)的位置
11.
条件循环结构
While(
条件
)
：
循环体
1.
import turtle
#
导入海龟画图模块
2.
turtle.forward(100)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37745792c54d6083c8bda1626f3dacc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da6a2231bb61609097313b28bb0829b7/" rel="bookmark">
			C&#43;&#43;中STL用法超详细总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++中STL用法超详细总结 转载，原文由于某些原因打开之后格式不太正确，影响阅读体验固转载方便查看。
原文链接：https://blog.csdn.net/u010183728/article/details/81913729
版权
目录
1 什么是STL？
2 STL内容介绍
2.1 容器
2.2 STL迭代器
2.3 算法
2.4 仿函数
2.4.1 概述
2.4.2 仿函数(functor)在编程语言中的应用
2.4.3 仿函数在STL中的定义
2.5 容器适配器
2.5.1 stack
2.5.2 queue &amp; priority_queue
3 常用容器用法介绍 3.1 vector
3.1.1 基本函数实现
3.1.2 基本用法 3.1.3 简单介绍
3.1.4 实例 3.2 deque
3.2.1 声明deque容器
3.2.2 deque的常用成员函数
3.2.3 deque的一些特点
3.2.4 实例
3.3 list
3.3.1 list定义
3.3.2 list定义和初始化
3.3.3 list常用操作函数
3.3.4 List使用实例
3.4 map/multimap
3.4.1 基本操作函数
3.4.2 声明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da6a2231bb61609097313b28bb0829b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10756c7a5187128826ecf44903030841/" rel="bookmark">
			python读取mp4文件失败_Python代码打开本地.mp4格式文件的方法-mp4文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python开发技术的应用相信有不少的小伙伴都有所了解，简单的说那就是非常的强大，Python开发技术的应用是非常广泛的，本篇文章扣丁学堂Python培训小编就给读者们分享一下Python代码打开本地.mp4格式文件的方法有哪些，对Python开发技术感兴趣的小伙伴就随小编过来看看吧。
Python培训
想通过编写Python代码来打开本地的.mp4格式文件，使用os模块来操作文件。我的电脑默认的是QQ影音播放器，执行Python代码打开默认播放器，播放代码中指定的视频文件。
class Video(object):
def __init__(self,path):
self.path = path
def play(self):
from os import startfile
startfile(self.path)
class Movie_MP4(Video):
type = 'MP4'
movie = Movie_MP4(r'D:\my_video.mp4')
movie.play()
以上就是扣丁学堂Python在线学习小编给大家分享的Python代码打开本地.mp4格式文件的方法，希望对小伙伴们有所帮助，想要了解更多内容的小伙伴可以登录扣丁学堂官网咨询。
想要学好Python开发小编给大家推荐口碑良好的扣丁学堂，扣丁学堂有专业老师制定的Python学习路线图辅助学员学习，此外还有与时俱进的Python课程体系和Python视频直播课供大家学习，想要学好Python开发技术的小伙伴快快行动吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccd5c413f21a00725dd13f56b9943324/" rel="bookmark">
			SPI通讯协议必备知识。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SPI简介 SPI 协议是由摩托罗拉公司提出的通讯协议(Serial Peripheral Interface)，即串行外围设备接口，是一种高速全双工的通信总线。
它被广泛地使用在 ADC、LCD 等设备与 MCU 间，要求通讯速率较高的场合。
二、基本原理 1. 物理层 SPI内部结构图：
SPI连接方式图：
引脚介绍
SPI通讯采用3条总线以及片选线，即上图中的SCK、MOSI、MISO、SS。
（1）：（SS）'为片选信号线，也被称为NSS、CS，其功能是寻址。在STM32中，I2C是通过设备地址来选择不同的设备，但SPI没有设备地址，只能通过CS信号线来寻址，因此每个设备都有一条单独的CS信号线与主机相连。当CS信号线设置为低电平时，即该设备被选中，选中后就可以进行SPI通信，CS信号线被拉高，作为结束信号。
（2）：SCK (Serial Clock)：时钟信号线，用于同步通讯数据。它由通讯主机产生，并决定通讯的速率，但由于不同设备的最高通讯速率不同，当两个设备通讯时，受限于设备的最低速率。在STM32中，SPI时钟频率最大为fpclk/2。手册规定SPI最快为18MHz，但SPI1挂载在APB2时钟总线下，理论最快为36MHz。
（3）：MOSI (Master Output， Slave Input)：主设备输出/从设备输入引脚。主机的数据从这条信号线输出，从机由这条信号线读入主机发送的数据，即这条线上数据的方向为主机到从机。
（4）：MISO(Master Input,，Slave Output)：主设备输入/从设备输出引脚。主机从这条信号线读入数据，从机的数据由这条信号线输出到主机，即在这条线上数据的方向为从机到主机。
2.协议层 2.1 SPI通讯基本过程 通讯时序图：
这是一个主机的通讯时序。NSS、SCK、MOSI 信号都由主机控制产生，而 MISO 的信号由从机产生，主机通过该信号线读取从机的数据。MOSI 与 MISO 的信号只在 NSS 为低电平的时候才有效，在 SCK 的每个时钟周期 MOSI 和 MISO 传输一位数据。 2.2 通讯的起始和停止信号 在上图中的标号（1）处，NSS 信号线由高变低，是 SPI 通讯的起始信号。
NSS 是每个从机各自独占的信号线，当从机在自己的 NSS 线检测到起始信号后，就知道自己被主机选中了，开始准备与主机通讯。
在图中的标号（6）处，NSS 信号由低变高，是 SPI 通讯的停止信号，表示本次通讯结束，从机的选中状态被取消。
2.3 数据有效性 SPI 使用 MOSI 及 MISO 信号线来传输数据，使用 SCK 信号线进行数据同步。MOSI及 MISO 数据线在 SCK 的每个时钟周期传输一位数据，且数据输入输出是同时进行的。数据传输时，MSB 先行或 LSB 先行并没有作硬性规定，但要保证两个 SPI 通讯设备之间使用同样的协定，一般都会采用图中的 MSB 先行模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccd5c413f21a00725dd13f56b9943324/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a810ef5b50658d2d9d48d6f1d534787/" rel="bookmark">
			个人微信api接口java调用代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人微信api接口java调用代码
1、微信好友收发消息
/**
* 给微信好友发消息
* @author wechatno:tangjinjinwx
* @blog http://www.wlkankan.cn
*/
@Async
public void handleMsg(ChannelHandlerContext ctx, TransportMessage vo, String contentJsonStr) {
try {
log.debug(contentJsonStr);
TalkToFriendTaskMessage.Builder bd = TalkToFriendTaskMessage.newBuilder();
JsonFormat.parser().merge(contentJsonStr, bd);
TalkToFriendTaskMessage req = bd.build();
// 消息记录数据库
asyncTaskService.savePcMessage(req);
// 将消息转发送给手机客户端
asyncTaskService.msgSend2Phone(ctx, req.getWeChatId(), EnumMsgType.TalkToFriendTask, vo, req);
} catch (Exception e) {
e.printStackTrace();
MessageUtil.sendJsonErrMsg(ctx, EnumErrorCode.InvalidParam, Constant.ERROR_MSG_DECODFAIL);
}
}
/**
* 微信好友发来聊天消息通知
* @author wechatno:tangjinjinwx
* @blog http://www.wlkankan.cn
*/
@Async
public void handleMsg(ChannelHandlerContext ctx, TransportMessage vo) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a810ef5b50658d2d9d48d6f1d534787/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a065894f8e8b397beca2397ff05735f2/" rel="bookmark">
			Python实现多个pdf文件合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python实现多个pdf文件合并 背景具体实现效果 背景 由于工作原因，经常需要将多个pdf文件合并后打印，有时候上网找免费合并工具比较麻烦（公司内网不能访问公网），于是决定搞个小工具。
具体实现 需要安装 PyPDF2
pip install PyPDF2 代码
# -*- coding=utf-8 -*- """ 功能: 将当前目录下的所有pdf文件合并为一个文件，新文件命名为 all_merge_年月日_时分秒.pdf 被合并的pdf文件不包含 all_merge 开头的文件 """ import PyPDF2 import pathlib import datetime def do_merge(the_dir): prefix = 'all_merge' output_file = '%s_%s.pdf' % (prefix, datetime.datetime.now().strftime('%Y%m%d_%H%M%S')) pdf_files = [] path_dir = pathlib.Path(the_dir) for filename in path_dir.iterdir(): if not filename.is_file(): continue if filename.name[0:len(prefix)] == prefix: continue elif filename.name.endswith('.pdf'): pdf_files.append(filename.name) pdf_files.sort(key=str.lower) pdf_writer = PyPDF2.PdfFileWriter() print("find %d pdf file(s).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a065894f8e8b397beca2397ff05735f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbc78116b80f26dcd5371b74f1fadcec/" rel="bookmark">
			lotus挖矿常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lotus 常用命令 lotus启动停止lotus导出链数据快照压缩链数据以减少磁盘占用修改矿工地址（owner、worker、control）从矿工账户转FIL到owner地址管理钱包安全重启miner daemon封装承诺扇区（pledge sectors）自定义存储位置订单备份和恢复Lotus Miner连接其他lotus daemonlotus在国内运行注意常用命令 Filecoin is a peer-to-peer network that stores files on the internet, with built-in economic incentives to ensure files are stored reliably over time. lotus启动停止 # 首次启动，从快照导入链数据 lotus daemon --import-snapshot &lt;filename&gt; # 普通启动 lotus daemon # 停止 lotus daemon stop # 导入快照不启动 lotus daemon --import-snapshot --halt-after-import &lt;filename&gt; lotus导出链数据快照 lotus chain export --recent-stateroots=900 --skip-old-msgs snapshot.car 压缩链数据以减少磁盘占用 # 共三步 # step1 lotus daemon stop	#停止lotus节点 # step2 rm $LOTUS_PATH/datastore/char/*	# 删除链数据 # step3 lotus daemon --import-snapshot &lt;filename&gt;	# 从新的快照同步链 修改矿工地址（owner、worker、control） # 查看矿工关联的地址信息 lotus-miner actor control list # 修改owner地址 lotus-miner actor set-owner --really-do-it &lt;address&gt; # 修改control地址 lotus-miner actor control set --really-do-it &lt;address1 address2 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbc78116b80f26dcd5371b74f1fadcec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78aa63ceebf4c860f98a237e2216c083/" rel="bookmark">
			树莓派连接蓝牙音箱播放音频-bluealsa
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 主要步骤参照bluealsa使用方法
按照上述链接操作，其中存在问题的点如下：
aplay -D bluealsa:HCI=hci0,DEV=18:BC:5A:BD:BD:01,PROFILE=A2DP test.wav
有HCI参数时会报错，A2DP需要改为全小写；在只有一个蓝牙连接的系统上可以不用HCI和PROFILE这两个参数测试音频可以使用/usr/share/sounds/alsa目录下的.wav文件最有用的参考链接，很全面 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a5dd465a37fa262ce8dd6e24d7c0f24/" rel="bookmark">
			Vim骚操作：使用q记录器，大大提高效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、批量反注释1.1 先上动图感受感受1.2 操作步骤 二、批量注释2.1 先上动图感受感受2.2 操作步骤 附录：博客动图中操作的示例代码 vim中的记录器可以用来记录文本操作时大量重复性的劳动，从而后面直接使用快捷键就行，骚操作可以大大简化劳动力。
此博客只是简单举例2个，而Vim记录器使用广泛不止于此，比如这样：
其他使用场景请体会后自行斟酌。我另一篇博客举了一些例子可以参考：【Vim生成一列连续按规则递增递减的数字】
大体来说，vim记录器使用流程如下：
1. 打开记录器 #按下q打开记录器跟一个按键即可，如：qa表示将后续操作记录与按键a中 2. 开始vim骚操作 #操作文本 3. 关闭记录器 #再按q表示退出记录器， 4. 重复执行记录器 #然后重复执行则按下【@a】即可在执行一次按键a中记录的动作。 下面通过两个小例子来简述记录器的使用
备注：下面例子需要有vim快速注释插件【NerdCommenter】结合一起使用，安装与使用方法这里不再赘述。
一、批量反注释 1.1 先上动图感受感受 1.2 操作步骤 按顺序执行如下操作
qa #打开记录器 shift+v #选中当前行 2j #光标下移2行 ,c空格 #注释选中的文本 f[ #光标跳转到字符 [ ctrl+v #进入多行操作模式 2jk #光标下移2行并右移一个字符 s / * ESC #替换成*/，并进入普通模式 f&lt; #光标跳转到字符 &lt; ctrl+v #进入多行操作模式 2jk #光标下移2行并右移一个字符 */ESC #替换成*/，并进入普通模式 5j0 #光标下移5行，并跳转到行首 q #退出记录器 @a #重复执行 @a #重复执行 @a #重复执行 @a #重复执行 @a #重复执行 @a #重复执行 二、批量注释 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a5dd465a37fa262ce8dd6e24d7c0f24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c5210643b3997b7012f967ca1a9c607/" rel="bookmark">
			SAS-A00-255 Predictive Modeling Use SAS EM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SASPredictive Modeling Use SAS EM考试主要考察深度学习和机器学习理论知识的理解，以及对SAS代码和软件的掌握程度。我从前期准备、需要学习的内容、现场考试这几个方面说下如何拿到EM认证。
目录
1、前期准备 1.1 确定考点大纲 到官网找最新的考试大纲。大纲分为4个部分，分别是对数据源的操作、建模、模型评估和模式分析。
During the testing of these objectives; you will be expected to perform common tasks, such as:
 Create a new project in Enterprise Miner
 Open an existing project in Enterprise Miner
 Add diagrams to projects in Enterprise Miner
 Create libraries within Enterprise Miner
 Add nodes to diagrams in Enterprise Miner
 Copy nodes within Enterprise Miner
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c5210643b3997b7012f967ca1a9c607/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/354455688a89aba7ae2d90a2a1b525e6/" rel="bookmark">
			vue中eventbus被多次触发（vue中使用eventbus踩过的坑）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一开始的需求是这样子的，我为了实现两个页面组件之间的数据传递，假设我有页面A，点击页面A上的某一个按钮之后，页面会自动跳转到页面B，同时我希望将页面A上的某一些参数携带过去给页面B。（我知道，小参数的时候可以通过路由的params或者query去传参数，或者大型数据可以用vuex来处理，很遗憾我到现在还没有做很大型的项目，所以还没有用过vuex，接下来会学习一下。）
然后我就想，这不就是不同组件之间的数据传递问题而已吗？直接用bus 巴士事件来传递数据不就行了吗。于是，我就很愉快地进行了。关于vue中的eventbus的使用，我之前在一篇vue中的数据传递中有提到过… 先给你们看一下我一开始的代码：
实现目标： 点击之后，bus emit事件，然后顺便跳转路由到/moneyRecord页面。 接下来就是在MoneyRecord页面中去on接收这个事件，然后接受参数。 // 这是页面A的内部触发bus事件的代码 editList (index, date, item) { // 点击进入编辑的页面，需要传递的参数比较多。 console.log(index, date, item) bus.$emit('get', { item: item.type, date: date }) this.$router.replace({path: '/moneyRecord'}) } // moneyRecord页面 created () { //这里我将icon的list给保存下来了 bus.$on('get', this.myhandle) }, methods: { myhandle (val) { console.log(val, '这是从上个页面传递过来的参数') } } 就当我欣喜若狂的时候，觉得自己只要在页面A触发了get事件，页面B中就会理所当然的接受了数据。然而，结果却不如人意，看一下下面的动图。 主要是看这是从上个页面传来的数据这一行数据的输出次数情况来判断事件触发次数 不知道你有没有发现，就是我第一次进去list页面的时候，我随便点击一下list下的任何一个item，控制台没有输出。但是当我第二次再点击触发事件的时候，就会输出一个测试数据。再一次进去点击，就输出两个数据。。。依次增加了。（控制台上那个“这是从上个页面传来的数据”就是测试数据） 问题：
问题1： 为什么第一次触发的时候页面B中的on事件没有被触发? 问题2： 为什么后面再一次依次去触发的时候会出现，每一次都会发现好像之前的on事件分发都没有被撤销一样，导致每一次的事件触发执行越来越多? 解决：
针对问题1
这个还得从vue的生命周期说起了，我先进行了测试，就是当从页面组件A跳转到页面组件B的时候，两个组件的生命周期分别是怎么样的，关于vue的生命周期具体每一个时期做什么事情我就不再赘述了，下面po一张vue生命周期的图。 我自己做了实验来验证，这个页面跳转过程中，这两个组件的生命周期的执行情况。
// 我分别在页面A和页面B中去添加以下代码： beforeCreate () { console.group('%c%s', 'color:red', 'beforeCreate 创建前状态===============组件2》') }, created () { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/354455688a89aba7ae2d90a2a1b525e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/730db77aaec609a57c45736995c17495/" rel="bookmark">
			pandas._libs.tslibs.timestamps.Timestamp数据类型转化为13位时间戳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d78300c4307c62f6bc4dd0a60044077d/" rel="bookmark">
			密码攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、密码在线破解
1、Hydra工具:支持几乎所有协议的在线密码破解，如ftp,http,https,mysql…
1）启动Hydra攻击
2）、target页面如下
passwords界面
tuning选项卡
设置任务的编号和超时时间，如果任务太多，服务的响应速率下降，将原来默认的任务编号16修改为2，超时时间改为15，将Exit after first found pair复选框勾上，找到第一匹配时停止攻击
3)、单击start进行攻击
2、medusa工具：通过并行登录暴力破解的方法，尝试获取远程验证服务访问权限，medusa能验证的远程服务：AFP,FTP,HTTP,IMAP…
例如：用medusa暴力破解地址为IP的路由器
medusa -h IP -u admin 密码文件 -M http -e ns -n 80 -F -h 指定主机
-u 指定用户
-M 指定模块
-e 指定额外的密码检查，ns变量允许我们使用用户名作为密码，并且使用空密码
-n 指定端口号
-F 允许我们在成功找到用户名密码组合之后停止爆破
二、分析密码（通过从目标系统、组织中收集信息来获得一个较小的密码字典）
1、Ettercap工具：用户能够使用Ettercap工具快速地创建伪造的包，从而实现网络适配器到应用软件各种级别的包，绑定监听数据到本地端口
1）修改配置文件
locate etter.conf #定位配置文件位置，ec_uid和ec_gid都设置为0
2）ettercap -G启动ettercap
与之前中间人攻击一样嗅探密码ettercap 8.3.1 中间人攻击
2、使用MSFCONSOLE分析密码（通过search_email_collector模块搜集一个组织相关的各种邮件信息，这些邮件信息有助于构建字典）
msfconsole #使用MSFCONSOLE search email collector #查询search_email_collector模块 use auxiliary/gather/search_email_collector #切换模块 show options #查看有效选项 set DOMAIN xxx.com #配置DOMAIN选项 set outfile xxx #配置输出文件路径 3、哈希值识别工具Hash Identifier（识别哈希值的加密方式）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d78300c4307c62f6bc4dd0a60044077d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f398becc54d149e26264a833c563dff6/" rel="bookmark">
			JAVA常见异常信息（保存）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 java基础编程中常见的错误（基本类型） 包装类型参与运算时，要做null值校验,否则可能出现空指针异常。包装类型比较大小，不能使用compare(i,j)直接比较，因为该方法是用来比较基本类型的，我们需使用CompareTo()方法比较。判断对象是否相等的时候使用equals方法，避免使用“==”产生非预期结果。使用New 生成的两个包装类必然不同，通过包装类的ValueOf生成的包装类实例可以显著提高空间和时间性能。无特殊要求，优先使用基本类型。在java中，随机数的产生取决于种子，随机数种子之间的关系遵从以下两个原则：
1 ）种子不同，产生不同的随机数
2）种子相同，即使实例不同也产生相同的随机数。
例子：new Random(1000)显式地设置了随机种子为1000，运行多次，虽然实例不同，但都会获得相同的三个随机数，所以除非必要，否则不要设置随机种子
通过java.util.Random类获取随机数的原理和Math.random方法相同，没有差别。奇数偶数的判断，用偶判断，不用奇判断一定要注意边界不要让类型默默转化。用整数类型处理货币 BigDecimal 使用整型，扩大100倍，再缩小100倍。 二、 Java 常见异常种类 Java Exception：
ErrorRuntime Exception 运行时异常Exceptionthrow 用户自定义异常
异常类分两大类型：Error类代表了编译和系统的错误，不允许捕获；Exception类代表了标准Java库方法所激发的异常。Exception类还包含运行异常类Runtime_Exception和非运行异常类Non_RuntimeException这两个直接的子类。
运行异常类对应于编译错误，它是指Java程序在运行时产生的由解释器引发的各种异常。运行异常可能出现在任何地方，且出现频率很高，因此为了避免巨大的系统资源开销，编译器不对异常进行检查。所以Java语言中的运行异常不一定被捕获。出现运行错误往往表示代码有错误，如：算数异常（如被0除）、下标异常（如数组越界）等。
非运行异常时Non_RuntimeException类及其子类的实例，又称为可检测异常。Java编译器利用分析方法或构造方法中可能产生的结果来检测Java程序中是否含有检测异常的处理程序，对于每个可能的可检测异常，方法或构造方法的throws子句必须列出该异常对应的类。在Java的标准包java.lang java.util 和 java.net 中定义的异常都是非运行异常。 三、 常见异常 算术异常类：ArithmeticException
空指针异常类：NullPointerException
类型强制转换异常：ClassCastException
数组负下标异常：NegativeArrayException
数组下标越界异常：ArrayIndexOutOfBoundsException
违背安全原则异常：SecturityException
文件已结束异常：EOFException
文件未找到异常：FileNotFoundException
字符串转换为数字异常：NumberFormatException
操作数据库异常：SQLException
输入输出异常：IOException
输入类型不匹配异常：InputMismatException
NoSuchMethodException
方法未找到异常。方法没有定义或导入错误，参数不匹配
java.lang.AbstractMethodError
抽象方法错误。当应用试图调用抽象方法时抛出。
java.lang.AssertionError
断言错。用来指示一个断言失败的情况。
java.lang.ClassCircularityError
类循环依赖错误。在初始化一个类时，若检测到类之间循环依赖则抛出该异常。
java.lang.ClassFormatError
类格式错误。当Java虚拟机试图从一个文件中读取Java类，而检测到该文件的内容不符合类的有效格式时抛出。
java.lang.Error
错误。是所有错误的基类，用于标识严重的程序运行问题。这些问题通常描述一些不应被应用程序捕获的反常情况。
java.lang.ExceptionInInitializerError
初始化程序错误。当执行一个类的静态初始化程序的过程中，发生了异常时抛出。静态初始化程序是指直接包含于类中的static语句段。
java.lang.IllegalAccessError
违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。
java.lang.IncompatibleClassChangeError
不兼容的类变化错误。当正在执行的方法所依赖的类定义发生了不兼容的改变时，抛出该异常。一般在修改了应用中的某些类的声明定义而没有对整个应用重新编译而直接运行的情况下，容易引发该错误。
java.lang.InstantiationError
实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.
java.lang.InternalError
内部错误。用于指示Java虚拟机发生了内部错误。
java.lang.LinkageError
链接错误。该错误及其所有子类指示某个类依赖于另外一些类，在该类编译之后，被依赖的类改变了其类定义而没有重新编译所有的类，进而引发错误的情况。
java.lang.NoClassDefFoundError
未找到类定义错误。当Java虚拟机或者类装载器试图实例化某个类，而找不到该类的定义时抛出该错误。
java.lang.NoSuchFieldError
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f398becc54d149e26264a833c563dff6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6324b5a471bcfa6e2db6b68cc77eec7/" rel="bookmark">
			[转载] Java：获取数组中的子数组的多种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接： Java中的数组Array
我的个人博客：zhang0peter的个人博客 Java：从一个数组中创建子数组 使用Arrays.copyOfRange函数 Arrays.copyOfRange支持：boolean[]， byte[] ，char[]，double[]，float[]，int[]，long[]以及泛型的 T[] 使用示例如下： import java.util.Arrays;
public class hello {
public static void main(String[] args) {
int[] src = new int[]{1, 2, 3, 4, 5};
int newArray[] = Arrays.copyOfRange(src, 0, 2);
for (int i : newArray) {
System.out.println(i);
}
}
}
官方文档如下： copyOfRange
public static &lt;T&gt; T[] copyOfRange(T[] original,
int from,
int to)
Copies the specified range of the specified array into a new array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6324b5a471bcfa6e2db6b68cc77eec7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2508f94a45f72231d9bf4505c32244aa/" rel="bookmark">
			（毕业设计资料）基于51单片机的音乐喷泉设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：
本设计由STC89C52单片机电路+水泵控制电路+ADC0832采样电路+LM386功率放大器电路+LED灯显示电路+电源电路组成。
1、本设计可以播放电脑、手机、MP3里面的音乐。
2、通过ADC0832芯片对音频信号的采集，转换为数字信号给单片机，然后PWM脉冲宽度调制控制水泵水柱对的高低。
3、同事有流水灯表示音乐大小情况。
【资源下载】下载地址如下：
https://docs.qq.com/doc/DTlRSd01BZXNpRUxl
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81bd9df91ca415faabc8f0dcc0d3e38a/" rel="bookmark">
			instanceof的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		instanceof是Java的一个二元操作符（运算符）,也是Java的保留关键字。它的作用是判断其左边对象是否为其右边类的实例，返回的是boolean类型的数据。用它来判断某个对象是否是某个Class类的实例。
用法：
boolean result = object instanceof class
参数：
result ：boolean类型。
object ：必选项。任意对象表达式。
class：必选项。任意已定义的对象类。
说明：
如果该object 是该class的一个实例，那么返回true。如果该object 不是该class的一个实例，或者object是null，则返回false。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13302ce2e1cdb4e0d274e00ab3a1ff99/" rel="bookmark">
			使用VMware 16搭建Centos 7 Linux虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用VMware 16搭建Centos 7 Linux虚拟机 前言一、新建虚拟机1、打开VMware软件，点击创建新的虚拟机2、默认典型即可3、选择稍后安装操作系统4、选中Linux和CentOS 7 64 位5、修改虚拟机名称和路径6、虚拟机磁盘容量根据需求填写，默认20GB足够7、点击自定义硬件7.1、内存根据需求填写，此处我只需要2GB7.2、处理器设置为1个，内存数量为2个（还是根据实际需求定）7.3、这时选择下载好的Linux镜像文件（下载地址在文章末尾） 8、点击开启此虚拟机9、点击我已完成安装10、语言根据需要选择，此处选择中文11、软件选择也可根据需求，此处选择最小安装12、点击安装位置12.1、选择我要配置分区12.2、选择标准分区，然后点击 **+** 号12.3、添加启动分区（/boot），200M足够12.4、选择文件系统为 ext412.5、添加内存交换区空间，可以选择为内存的2倍12.6、将剩余的空间全部给根目录（ /）12.7、最后点击完成，显示如下图即可 13、配置网络，点击网络和主机名13.1、点击打开网络，然后修改主机名13.2、点击配置，进行网络的配置13.3、配置完成如下图，点击完成，然后开始安装14、设置ROOT密码14.1、这里设置为root，由于密码过短，需要点击两次完成 15、等待安装完成重启即可16、启动成功，显示让我们登录17、使用root用户登录，登录成功，OK，到这里我们的虚拟机就搭建完成了 总结 前言 本篇博客我们一起来学习在windows平台上使用VMware Workstation 16 Pro来搭建一个Linux（Centos7）虚拟机。这应该算是学习大数据的第一步，让我们开始吧。、
VMware Workstation 16 Pro软件和Centos7的镜像文件，会在文章的尾部给出下载地址。
一、新建虚拟机 1、打开VMware软件，点击创建新的虚拟机 2、默认典型即可 3、选择稍后安装操作系统 4、选中Linux和CentOS 7 64 位 5、修改虚拟机名称和路径 6、虚拟机磁盘容量根据需求填写，默认20GB足够 7、点击自定义硬件 7.1、内存根据需求填写，此处我只需要2GB 7.2、处理器设置为1个，内存数量为2个（还是根据实际需求定） 7.3、这时选择下载好的Linux镜像文件（下载地址在文章末尾） 到这里点击关闭、完成。
8、点击开启此虚拟机 9、点击我已完成安装 10、语言根据需要选择，此处选择中文 11、软件选择也可根据需求，此处选择最小安装 注意 最小安装 是只有命令行界面的，如果想要桌面显示的，可以选择如下图的GNOME桌面
12、点击安装位置 12.1、选择我要配置分区 12.2、选择标准分区，然后点击 + 号 12.3、添加启动分区（/boot），200M足够 12.4、选择文件系统为 ext4 12.5、添加内存交换区空间，可以选择为内存的2倍 文件系统格式不用修改
12.6、将剩余的空间全部给根目录（ /） 12.7、最后点击完成，显示如下图即可 13、配置网络，点击网络和主机名 13.1、点击打开网络，然后修改主机名 13.2、点击配置，进行网络的配置 注意此次需要查看VMware网卡的NAT模式的网段信
在VMware主页点击编辑 -&gt; 虚拟机网络编辑器查看 NAT模式对应的虚拟网卡，可以看出 VMnet8为我们使用的网卡，我们需要到windows中继续查看我们的网卡信息，两者信息需要一致才行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13302ce2e1cdb4e0d274e00ab3a1ff99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d0403919ba69dc6412f7dbd28737265/" rel="bookmark">
			2020-12-13
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根本解决：无法加载+DLL“halcon”:+找不到指定的模块 该问题的解决方案摘自：https://www.51halcon.com/thread-997-1-1.html；https://blog.csdn.net/yue1453544229/article/details/92063231
这个问题处理时是使用下面的方法：
根本解决方法：
把Halcon运行支持目录添加到系统环境配置中去(windows系统环境支持都需要在PATH目录)，因为这个目录里面还有很多采集的库需要依赖，特别很多人写halcon的相机采集的时候，其实整个目录里面的dll都是需要依赖的，也就是Runtime内容，所以上面那种简单解决不能有效解决hAcqGigeVision.dll这种缺少，你要拷贝好多依赖的把整个bin都拷贝到system32下面去？没必要。
Win10打开设置：此计算机-&gt;右键属性-&gt;系统“高级系统设置”-&gt;系统属性-&gt;高级-&gt;底部“环境变量(N)”
比如现在的Halcon安装目录为：
D:\Program Files\MVTec\HALCON-12.0\bin\x86sse2-win32; 那么对应的环境变量代码为：
%HALCONROOT%\bin\%HALCONARCH%; 把上面这句代码添加到环境变量PATH目录中即可，记得该句前面和后面的分号不可少，然后重启即可解决（推荐方式）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0838a4a26b207c696bea013c2c51f748/" rel="bookmark">
			pytorch 多元回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拟合函数y = 0.90 + 0.50 * x + 3.00 * x^2 + 2.40 * x^3
import torch import numpy as np import matplotlib.pyplot as plt #%% # 定义一个多变量函数 w_target = np.array([0.5, 3, 2.4]) b_target = np.array([0.9]) #%% f_des = 'y = {:.2f} + {:.2f} * x + {:.2f} * x^2 + {:.2f} * x^3'.format( b_target[0], w_target[0], w_target[1], w_target[2]) print(f_des) print(f'y = {b_target[0]} + {w_target[0]} * x + {w_target[1]} * x^2 + {w_target[2]} * x^3') #%% # 画出函数图像 x_sample = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0838a4a26b207c696bea013c2c51f748/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95482d243a4178dc155926a68b9d407b/" rel="bookmark">
			Ubuntu 查看IP、网关及DNS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看IP 方式一：ifconfig -a 首先需要安装net-tools工具，命令：sudo apt install net-tools　，否则会报错：
然后通过命令ifconfig查看就可以了
方式二：ip addr 查看的网关 查看默认的网关地址命令：route -n
查看DNS 查看DNS命令：nsloopup hcos
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39bf2c4e2535f1fcf68bc4a3ffbb2975/" rel="bookmark">
			mobaxterm连接ubuntu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一步：Ubuntu中必须启动SSH服务 在终端运行命令：sudo apt-get install openssh-server
检查SSH服务是否启动命令：ps -e |grep ssh
第二步：关闭Ubunt防火墙 关闭防火墙命令：sudo ufw disable
查看防火墙状态命令：sudo ufw status
第三步：配置Ubuntu静态IP 查看本机默认ip
查看默认的网关地址命令：route -n
上面两步查看ip、网关及dns主要为下步配置ip提供数据用的。
具体设置IP命令：sudo vi /etc/netplan/01-network-manager-all.yaml
上面配置信息中的192.168.1.1来自：
mobaxterm连接ubuntu 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b961e3b99ed66146d55cc974b1285051/" rel="bookmark">
			华为ARP代理的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：使用华为设备
三种类型的ARP： 路由式arp：
使用场景：
路由器或者交换机三层转发的情况下
原理：
也就是普通的arp代理，当PC1没有网关时去ping不是同一网段的设备（直接封装目的IP的请求报文），到达了最近的路由器时，因为为广播帧，路由器会拆包查看，一般情况下请求的IP地址不是自己的，不会处理，但是开启了的路由的arp代理后，如果发现目的IP地址是自己有相应的路由表，并且出接口不是原来的接口，这时就会按照路由表项路由表的出接口请求ARP地址（如果是直连，直接请求，如果不是直连，请求下一跳），然后会将自己的ARP地址发送个请求端，让对方来找自己就行了，相当于自己就是一个中间人，帮助别人转发。
命令：在相应接收的接口下开启：arp-proxy enable //三层交换机是在对应的vlanif接口下使用
Vlan内ARP：
使用场景：
Vlan内的arp代理是在隔离端口处使用的，仅仅对二层隔离有效果（三层的端口隔离没有效果），双方设备处于同一个网段，在同一个vlan，如果设置了隔离的端口，就不能正常的互相通信了，但是我们在S1上的对应vlan上开启了arp代理，仍然PC1和PC2可以通信。
原理：
PC1发送arp报文请求PC2的信息，S1不会将从与S1相连的接口收到的信息通过二层转发从与PC2相连的接口发送出去。
如果开启了arp代理，当S1收到了PC1发送给PC2的信息时同样不会进行二层的发送，而是SW检查打上的tag和请求的IP地址从而将报文从允许此tag的接口上发送出去（不包括原来的接口），这样就是通过S1向PC2请求MAC地址。PC2进行arp报文回复，S1收到回复报文后将自己接口的MAC地址通过查找MAC地址表从与PC1相连的接口发送出去，完成了ARP代理，以后PC1其实都是将发送给PC2的报文发送给了S1进行代处理S1再进行转发，避免了两个接口间无法进行正常通信。
命令：
interface Vlanif1 //进入双方的都在的vlan中
ip address 10.1.1.254 255.255.255.0 //arp代理是三层技术，需要配置ip地址
arp-proxy inner-sub-vlan-proxy enable //开启区域内的arp代代理
Vlan间ARP：
使用场景：
Vlan间arp代理是使用在super vlan中的，也就是同一网段，不同vlan间的arp代理
原理：
因为目的地址在同一网段，PC发送arp请求信息的时候是直接请求对面的MAC地址的，并且会打上自己网段的tag，这时候super vlan会检测sub vlan间的通信（正常情况下只有本vlan的三层接口才会检测），查看arp请求报文的IP地址，正常情况下发现对方的IP地址不是自己就不做任何操作，所以arp请求报文就只能在原来的vlan泛洪，但是目标主机确是在另外一个vlan，所以无法正常请求到。当开启了arp区域间代理的时候，super vlan发现了arp请求报文，并且请求的地址和自己是同一网段的主机IP，它会知道这是他sub vlan的报文，但是到底是哪个sub vlan并不清楚，所以打上其余sub vlan的tag从可以通过对应tag的出接口发送出去，这样当arp请求报文回复以后，带有的tag就是对方所在sub vlan的tag，这样交换机就获取的了对方的MAC地址，现在就只需要将自己的MAC地址封装进入arp回复消息发送给请求端即可，回复的具体物理端口需要查看MAC地址表进行，由于PC请求的时候SW已经在相应的接口上学习到了，现在只需要从这个接口发送出去即可。
命令：
interface Vlanif1 //进入双方的都在的vlan中
ip address 10.1.1.254 255.255.255.0 //arp代理是三层计算，需要配置ip地址
arp-proxy inter-sub-vlan-proxy enable //开启区域间的arp代理
总结： 相同点：
3种arp代理都是都是将自己接口的MAC地址发送回复给对方（对方请求的都不是自己的MAC）做一个善意的欺骗，帮助别人进行通信过程。并且既然要进行arp的代理，就必须解封装到网络层，然后被识别，因为arp请求报文都是广播的报文，肯定是能够被对应的三层接口进行接收的（聚合vlan中因为super vlan和sub vlan进行了相互的关联，所以super vlan的接口也会处理sub vlan发送来的arp报文）。
不同点：
应用的环境不同中，路由arp的环境是一个路由器或者三层交换机连接了两个不同的网段，两台互相通信的设备在这两个不同的网段，并且需要请求的设备没有设置网关，这时候请求的设备会直接对方的MAC地址，当开启了ARP代理后接受的接口会帮助处理。
Vlan内路由适用于端口二层隔离的环境，这个在双方设备在同一个vlan中，只不过开启了二层隔离，当在对应vlan的接口上创建了IP地址后，配置了arp代理，arp请求报文虽然不能直接发送到对方，但是相应的vlanif接口会代为处理，发送arp请求报文发往其他允许其vlan tag通过的物理接口，得到回复后，将自己的MAC地址返回给原请求设备。以后进行的二层通信，都只需要将报文发送给S1，因为是S1vlanif接口的MAC地址，关于解封装到网络层查看，发现目的IP地址不是自己，然后查路由表，转发到相应的接口即可。
Vlan间arp代理使用在聚合vlan中，也就是在super vlan的接口上进行配置，super vlan关联sub vlan以后会处理sub vlan的信息，例如arp广播报文，虽然是sub vlan接收到的，但是也会转发到super vlan的接口下查看，这个时候如果开启了arp代理，super vlan会向其sub vlan关联的接口发送对应的arp请求消息代理请求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b961e3b99ed66146d55cc974b1285051/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d25a6d6d7c0e56be127ef647a6883e5e/" rel="bookmark">
			到底什么是载波聚合（CA）？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1
为什么需要载波聚合？
一般来说，要提升网速或者容量，有下面几个思路：
建更多的基站：这样一来同一个基站下抢资源的人就少了，网速自然就上去了。但缺点是投入太大了，运营商肯定不会做亏本的买卖。
提升频谱效率：从2G到5G，有多少专家潜心钻研，一头青丝变华发，就是为了提升效率，在每赫兹的频谱上传更多的数据！可见这项工作是真的很艰难。
增加频谱带宽：这是提升容量最简单粗暴的办法了，从2G到5G，单个载波的带宽不断增长，从2G的200K，再到3G的5M，4G的20M，在5G时代甚至达到了100M（Sub6G频段）乃至400M（毫米波频段）！
然而，这一切努力在汹汹流量面前还是杯水车薪，这可怎么办？
只能再增加频谱带宽了！4G的做法主要是把2G和3G，乃至Wifi的频段抢过来用，5G的做法主要是扩展新频段，从传统的低频向带宽更大的高频发起冲击。
频谱千方百计搞到了，但载波的带宽却已经由协议定好了，不容再改，这又咋办？
说起来要实现也简单，人多力量大是永恒的真理，一个载波容量不够，我就再加一个一起传数据，不信速度上不去。什么，还不够？那就继续增加载波！
这种技术就叫做：载波聚合。
话说LTE的第一个版本因为容量有限，虽然被广泛宣传为4G技术，但实际上达不到国际电联的4G标准，业内也就称之为3.9G。
后来LTE演进到LTE-Advanced时，引入了5载波聚合，把单用户可用的带宽从20MHz扩大到了100MHz，这才坐稳了4G的头把交椅。
后面的5G，自然是继承了4G的衣钵，把载波聚合作为提升容量的利器。
2
载波聚合的分类及发展史
话说频谱资源是稀缺的，每个频段就那么一小段，因此载波聚合需要支持多种方式，以两载波聚合为例：
如果两个载波的频段相同，还相互紧挨着，频谱连续，就称作频段内连续的载波聚合。
如果两个载波的频段相同，但频谱不连续，中间隔了一段，就称作频段内不连续的载波聚合。
如果两个载波的频段不同，则称作频段间的载波聚合。
这三种方式包含了所有的情况，可谓任你几路来，都只一路去，再多的载波，也能给拧成一股绳。
参与载波聚合的每一个载波，又都叫做分量载波（Component Carrier，简称CC）。因此，3载波聚合也可称之为3CC。
这些载波在一起工作，需要相互协同，就总得有个主辅载波之分。
所谓主载波，就是承载信令，并管理其他载波的载波，也叫Pcell（Primary cell）。
辅载波也叫Scell（Secondary cell），用来扩展带宽增强速率，可由主载波来决定何时增加和删除。
主辅载波是相对终端来说的，对于不同终端，工作的主辅载波可以不同。并且，参与聚合的多个载波不限于同一个基站，也可以来自相邻的基站。
从4G的LTE-Advanced协议引入载波聚合之后，该技术就如脱缰的野马一样狂奔，从最初的5载波聚合，总带宽100MHz，再到后面的32载波聚合，总带宽可达640MHz！
到了5G时代，虽说可聚合的载波数量仅为16个，但架不住5G的载波带宽大啊。
Sub6G的单载波带宽最大100MHz，16个载波聚合一共就1.6GHz带宽了；毫米波频段更夸张，单载波带宽最大400MHz，16个载波聚合一共就有6.4GHz带宽！
时代的车轮就这样滚滚向前。前浪以为自己已经很牛逼了，但回头一看，后浪简直就是滔天巨浪啊，然后还没反应过来就已经被拍在了沙滩上摩擦。
3
5G的载波聚合技术
话说5G的载波聚合，相比4G来说更复杂一些。
首先5G的频段分为两类，FR1和FR2，也就是俗称的6GHz以下的频段（Sub6G），以及高频，也就毫米波（mmWave）。
FR1包含了众多从2G，3G和4G传承下来的频段，有些是FDD的，有些是TDD的。
这样一来，在FR1内部就存在FDD+FDD频段间的载波聚合，FDD+TDD频段间的载波聚合，以及TDD+TDD频段间的载波聚合。
在上述的每个FDD或者TDD的频段内部，还可以由多个带内连续的载波聚合而成。3GPP定义了多种的聚合等级，对应于不同的聚合带宽和连续载波数。
比如上图中的FR1频段内载波聚合等级C，就表示2个带内连续的载波聚合，且总带宽在100MHz到200MHz之间。
不同于FR1，FR2是全新定义毫米波频段，双工方式全部都是TDD。
跟FR1类似，3GPP也为FR2频段定义了带内连续的多种的聚合等级，对应于不同的聚合带宽和连续载波数。
比如上图中的FR2频段内载波聚合等级M，就表示8个带内连续的载波聚合，且总带宽在700MHz到800MHz之间。
有了上述的定义，我们就可以在FR1内部频段内，频段间进行载波聚合，还能和FR2进行聚合，并且载波数量，以及每个载波的带宽也都可以不同，它们之间的排列组合非常多。
举个例子，“CA_n78A-n258M”这个组合，就代表n78（又称3.5GHz或者C-Band）和n258（毫米波26GHz）这两个频段间的聚合，其中n78的频段内聚合等级为A，也就是单载波，n258的频段内聚合等级为M，也就是有8个载波且总带宽小于800MHz。
4
NSA组网下的双连接技术
且说上面的5G内部载波聚合已经很强悍了，但这还只是带宽扩展的冰山一角。
5G在NSA架构下引入了双连接（Dual Connection，简称DC）技术，手机可以同时连接到4G基站和5G基站。
在双连接的基础上，4G部分和5G部分还都可以在其内部进行载波聚合，这就相当于把4G的带宽也加进来，可进一步增强下行传输速率！
在双连接下，手机同时接入4G基站和5G基站，这两基站也要分个主辅，一般情况下Option3系列架构中，4G基站作为控制面锚点，称之为主节点（Master Node），5G基站称之为辅节点（Secondary Node）。
主节点和辅节点都可以进行载波聚合。其中主节点的主载波和辅载波称为Pcell和Scell，辅节点的主载波和辅载波称为PScell和Scell。
带载波聚合的主节点和辅节点又可以被称作MCG（Master Cell Group，主小区组）和SCG（Secondary Cell Group，辅小区组）。
虽说NSA架构的初衷并不是提升速率，而是想着藉由4G来做控制面锚点，这样一来不但现网的4G核心网EPC可以利旧，还能使用成熟的4G覆盖来庇护5G这个初生的孩童。
但是客观上来讲，通过双连接技术，手机可同时连接4G和5G这两张网络，获取到的频谱资源更多，理论上的峰值下载速率可能要高于SA组网架构，除非以后把4G载波全部重耕到5G。
这些双连接加载波聚合的组合，也都是由协议定义的。
如果看到这串字符：DC_1A_n78A-n257M，我们先按照下划线“_”把它拆解为三个部分，DC，1A，和n78A-n257M。
DC就表示双连接，1A表示LTE band1（2100MHz）单载波，后面的n78A-n257M见前文的解释，这串字符综合起来就是5G FR1和FR2多个载波聚合后，在和一个4G载波进行了双连接。
5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d25a6d6d7c0e56be127ef647a6883e5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74f405ac303941e184d64d7409b959ae/" rel="bookmark">
			抖音批量取消喜欢的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 抖音批量取消喜欢,批量取消抖音喜欢。
我自己有这个需求，喜欢列表里点赞的美女太多了😅，然后发现抖音没有批量取消的功能，只能自己一个一个点进去取消，太麻烦了。所以我自己写了一个脚本，批量取消抖音喜欢。
批量取消抖音喜欢的脚本
有需求的可以在评论区告诉我哦！我无偿提供给大家！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54b0dcbf172b66d16ffa5de8f517b79b/" rel="bookmark">
			word目录怎么跳转到相应页码_Word目录不会做？请看完整操作步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录的制作是我们在排版过程中遇到最大的难题，本期Word妹与大家详细分享有关目录自动生成技巧。
自动目录生成的步骤：
1、设置好样式
选中文本，点击开始——样式——在样式库中选择合适格式。
2、添加空白页
设置好样式之后在标题前面添加相应空白页，添加方式如下：
将光标定在标题前面，之后按快捷键Ctrl+Enter组合键即可插入空白页，当然可以点击插入——页面——空白页。
3、添加目录
点击引用——目录——选择自动目录即可。
4、删除目录页码
如果不需要页码？想删除，可以直接点击引用——目录——自定义目录，在打开的界面中取消【显示页码】选框，点击确定即可删除页码。
5、添加自动编号
如果想让目录添加自动编号，需要用到前面推送的文章《Word干货|多级标题的自动编号怎么添加？》中的技巧。
打开多级列表界面，根据需要设置相应的编号等级，且链接到指定的样式，比如这里将等级1链接到标题1，等级2链接到标题2，等级3链接到标题3，而编号的格式则选择默认即可(其他样式也可以)。
6、目录更新
虽然更改了正文内容，但你会发现目录还没有更新，这时可以选中目录，右击选择更新域选择更新整个目录即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d32a3998cb122f24cd6dbd94ba38e86e/" rel="bookmark">
			CSS(css3)背景图片属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.css背景-用于定义HTML元素的背景 background-color：背景颜色 background-color:yellow; background-color:#00ff00; background-color:rgb(255,0,255); 值描述color指定背景颜色。在CSS颜色值近可能的寻找一个颜色值的完整列表。transparent指定背景颜色应该是透明的。这是默认inherit指定背景颜色，应该从父元素继承 background-images：背景图像 background-image:url('paper.gif'); //可以给不同的图片设置多个不同的属性 #example1 { background-image: url(img_flwr.gif), url(paper.gif); background-position: right bottom, left top; background-repeat: no-repeat, repeat; } 值说明url('URL')图像的URLnone无图像背景会显示。这是默认linear-gradient()创建一个线性渐变的 "图像"(从上到下)radial-gradient()用径向渐变创建 "图像"。 (center to edges)repeating-linear-gradient()创建重复的线性渐变 "图像"。repeating-radial-gradient()创建重复的径向渐变 "图像"inherit指定背景图像应该从父元素继承 background-origin：内容框相对定位的背景图片 background-origin: padding-box|border-box|content-box; 值描述padding-box背景图像填充框的相对位置border-box背景图像边界框的相对位置content-box背景图像的相对位置的内容框 background-position：设置背景图像的起始位置 background-position:center; //可以给不同的图片设置多个不同的属性 #example1 { background-image: url(img_flwr.gif), url(paper.gif); background-position: right bottom, left top; background-repeat: no-repeat, repeat; } 值描述left top
left center
left bottom
right top
right center
right bottom
center top
center center
center bottom如果仅指定一个关键字，其他值将会是"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d32a3998cb122f24cd6dbd94ba38e86e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed84edccfaad0436dca66e9555fca4a6/" rel="bookmark">
			短信自动转发到另一个手机_原来华为手机电源键这么强大！第一个还能“自动救主”，之前真是小瞧你了...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说起手机的电源键，好似除了能够开关机也没有什么其他的作用了？如果你是这么想的，那么我只能回你一个字：“错”。手机电源键除了能够开关机以外，它还有特别多的强大功能，下面我们就赶快来了解一下吧！
一、连续五次电源键
很多人可能不知道这个隐藏极深的功能，只要我们连续按击5次电源键就会触发到一个神奇的界面。你就进入到SOS紧急联系界面，用途还是非常强大的，学会后可以给家里的长辈小孩设置一下。以防万一，当然，希望大家永远都用不到这个功能!
设置的方法很简单，进入手机设置，接着点进“安全和隐私”功能，找到SOS紧急求助进入，你可以先点击个人紧急信息，进入后可以添加个人信息，医疗救援信息、紧急联系人等等；
编辑完成后返回到上一个SOS紧急求助界面，将“自动发送求助信息”按键开启。开启此功能的方法也很简单，连续点击手机电源键5次，会弹出一个SOS界面，它就会将你的求救短信发送给你的紧急联系人。
除此之外，其实手机电源键还有很多用处，各个都很实用和强大。
二、截屏
我们在使用手机的时候，想要将某一个页面截屏下来，同时点击手机下键+电源键就能实现。当听到“咔”的一声，手机就把当前的页面截屏下来了，我们进入手机相册就能找到截屏的图片。
三、即时“静音”
如果我们处于一个很正式的场合，在手机没有静音的情况下打来一个电话，这个时候等你点取消就要耗费4—5秒的时间，而点击电源键就可以在不到一秒的时间里取消并一键静音，这个技巧在一些紧急的情况下还是非常有帮助的。
四、快速关闭手电筒
我们通常使用手电筒功能的时候，都会在手机下拉界面开启电筒，使用完毕后手机都会处于一个黑屏状态。要想关闭手电筒就得解锁，再进入下拉界面关闭。这一系列操作还是非常繁琐的，其实我们关闭手电筒的时候有一个快捷操作。在手机电筒开启的时候，直接点击电源键 就能立即关掉。
除此之外，我们在使用手机的过程中尽量都把能用的功能都用上，不然放哪儿太浪费了。比如说：华为手机的备忘录语音速记功能，可以帮助我们快速实现文字录入。如果你需要将中文翻译成英文的话，它就不支持了，这时候我们可以打开“录音转文字助手”，它会比语音速记功能更全、更强大。手机浏览器就可以找到，能很轻松的提高我们的工作和学习效率！
手机电源键的技巧就介绍到这了，感兴趣的小伙伴赶紧去试试吧！如果大家有什么其他不错的功能技巧记得分享出来哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24e4eea9d7a22b6a66da0d0d3c14d31c/" rel="bookmark">
			get请求和post请求的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		既然get和post只是在传递数据的方式上不同，那么是否意味着，无论是获取数据还是提交数据两种方式可以混用呢？
可以混用，但是不推荐不建议混用。
1.get请求通常用于获取数据。
2.post请求通常用于提交数据。
3.get请求发送的数据都写在地址栏上，用户可见。
4.post请求发送的数据用户不可见。
5.get请求不能提交大量数据，但post可以，因此不要混用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a07f0ffec787f73d9d6e77422b18c8cf/" rel="bookmark">
			并发编程 — 原子类 AtomicReference 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过对 AtomicInteger、AtomicBoolean 和 AtomicLong 分析我们发现，这三个原子类只能对单个变量进行原子操作，那么我们如果要对多个变量进行原子操作，这三个类就无法实现了。那如果要进行多个变量进行原子操作呢？操作方式就是，先把 多个变量封装成一个类，然后通过 AtomicReference 进行操作。
众所周知，对象的引用其实是一个4字节的数字，代表着在JVM堆内存中的引用地址，对一个4字节数字的读取操作和写入操作本身就是原子性的，通常情况下，我们对对象引用的操作一般都是获取该引用或者重新赋值（写入操作），我们也没有办法对对象引用的4字节数字进行加减乘除运算，那么为什么JDK要提供AtomicReference类用于支持引用类型的原子性操作呢？
1、AtomicReference的应用场景 这里通过设计一个个人银行账号资金变化的场景，逐渐引入AtomicReference的使用，该实例有些特殊，需要满足如下几点要求。
个人账号被设计为不可变对象，一旦创建就无法进行修改。个人账号类只包含两个字段：账号名、现金数字。为了便于验证，我们约定个人账号的现金只能增多而不能减少。 根据前两个要求，我们简单设计一个代表个人银行账号的Java类DebitCard，该类将被设计为不可变。
public class DebitCard { private final String name; private final int account; public DebitCard(String name, int account) { this.name = name; this.account = account; } public String getName() { return name; } public int getAccount() { return account; } @Override public String toString() { return "DebitCard {name=\""+name+"\"," + "account="+account+"}"; } } 1.1、通过 volatile 修饰的多线程 public class AtomicReferenceDemo1 { // 定义为 volatile 修饰的变量 volatile static DebitCard debitCard = new DebitCard("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a07f0ffec787f73d9d6e77422b18c8cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11052ca6f5781e79da2b1d228dc87673/" rel="bookmark">
			理解对比表示学习(Contrastive Learning)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、前言二、对比学习三、主要论文（附代码分析）1. AMDIM ([Bachman](https://arxiv.org/pdf/1906.00910.pdf) *et al.* 2019)2. SIMCLR ([Geoffrey Hinton](https://arxiv.org/pdf/2002.05709.pdf) *et al* 2020)3.MOCO ([Kaiming He](https://ieeexplore.ieee.org/document/9157636) *et al.* 2020) 四、总结 一、前言 监督学习近些年获得了巨大的成功，但是有如下的缺点：
人工标签相对数据来说本身是稀疏的，蕴含的信息不如数据内容丰富；监督学习只能学到特定任务的知识，不是通用知识，一般难以直接迁移到其他任务中。 由于这些原因，自监督学习的发展被给予厚望。监督学习，无监督学习和自监督学习的区别
如果说自监督学习是蛋糕，那么监督学习就是蛋糕上的小冰块，强化学习就是蛋糕上点缀的樱桃。(“self-supervised learning is the cake, supervised learning is the icing on the cake, reinforcement learning is the cherry on the cake”) —Yann LeCun
自监督学习不需要人工标注的类别标签信息，直接利用数据本身作为监督信息，学习样本数据的特征表达，应用于下游的任务。自监督学习又可以分为对比学习(contrastive learning) 和 生成学习(generative learning) 两条主要的技术路线。对比学习的核心思想是讲正样本和负样本在特征空间对比，学习样本的特征表示，难点在于如何构造正负样本。
最近，诸如BERT和T5之类的自然语言处理模型已经表明，可以通过首先在一个大型的未标记数据集上进行预训练，然后在一个较小的标记数据集上进行微调，从而用很少的类标签来获得良好的结果。 同样，对未标记的大型图像数据集进行预训练，有可能提高计算机视觉任务的性能。这点已经在对比表示学习的相关论文，例如Exemplar-CNN, Instance Discrimination, CPC, AMDIM, CMC, MoCo，获得了证实。对比学习训练得到的神经网络模型，可以被用作下游的任务，例如分类、分割、检测等。经过对比学习预训练得到的神经网络，已经具有很强的表达能力，一般只需要再用很少的有标签数据微调，就可以获得非常优秀的性能。
以下图片引用
二、对比学习 对比学习首先学习未标记数据集上图像的通用表示形式，然后可以使用少量标记图像对其进行微调，以提升在给定任务(例如分类)的性能。简单地说，对比表示学习可以被认为是通过比较学习。相对来说，生成学习(generative learning)是学习某些（伪）标签的映射的判别模型然后重构输入样本。在对比学习中，通过在输入样本之间进行比较来学习表示。对比学习不是一次从单个数据样本中学习信号，而是通过在不同样本之间进行比较来学习。可以在“相似”输入的正对和“不同”输入的负对之间进行比较。以下图片引用。
对比学习原理 对比学习通过同时最大化同一图像的不同变换视图(例如剪裁，翻转，颜色变换等)之间的一致性，以及最小化不同图像的变换视图之间的一致性来学习的。 简单来说，就是对比学习要做到相同的图像经过各类变换之后，依然能识别出是同一张图像，所以要最大化各类变换后图像的相似度（因为都是同一个图像得到的）。相反，如果是不同的图像（即使经过各种变换可能看起来会很类似），就要最小化它们之间的相似度。通过这样的对比训练，编码器(encoder)能学习到图像的更高层次的通用特征 (image-level representations)，而不是图像级别的生成模型(pixel-level generation)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11052ca6f5781e79da2b1d228dc87673/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a73dcbe0176da46ba116f0b80f11f738/" rel="bookmark">
			MyBatis二级缓存异常 org.apache.ibatis.cache.CacheException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CacheException 启动二级缓存:在mybatis全局配置文件中配置
&lt;settings&gt; &lt;!--启动二级缓存--&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;/settings&gt; 在Mapper.xml的配置文件中加入cache标签表示使用二级缓存。
&lt;!--使用二级缓存--&gt; &lt;cache/&gt; 需要被二级缓存的对象必须要实现java的序列化接口。
org.apache.ibatis.cache.CacheException: Error serializing object. Cause: java.io.NotSerializableException: com.leslie.entry.User
at org.apache.ibatis.cache.decorators.SerializedCache.serialize(SerializedCache.java:100)
at org.apache.ibatis.cache.decorators.SerializedCache.putObject(SerializedCache.java:56)
at org.apache.ibatis.cache.decorators.LoggingCache.putObject(LoggingCache.java:51)
at org.apache.ibatis.cache.decorators.SynchronizedCache.putObject(SynchronizedCache.java:45)
Caused by: java.io.NotSerializableException: com.leslie.entry.User
出现错误原因是因为二级缓存的对象没有实现序列化接口
将JavaBean实现序列化接口即可序列化
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba4c48331403312e1d6537a1e196699c/" rel="bookmark">
			xdf文件改word_真正Txt 文本文件和Doc Word文件批量互转工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电近经常上网下载小说文本，电脑里一大堆，虽然文本文件简洁方便，可是用记事本打开阅读，眼睛看起来却很累，还是觉得保存为WORD文件，阅读起来更舒服，也许一个两个TXT文本，转换成WORD，我们直接打开复制粘贴一下就行了，可是，现在我突然要将一个目录中的文本文件转换为WORD文件，感觉就有些为难了，而且在转换后还要加粗标题，设置行间距、段落缩进之类的，如果纯手工操作实在太辛苦了，于是想在百度上找找看，有没有这方面的软件，结果找了十几页，也没发现一款好用的软件，很多地方是告诉我们，直接建议一个批处理文件，改一下扩展名，这不是忽悠人吗？而且，还有WORD文件批量转换为TXT文本文件的需求吧，于是昨天我索性自己开发一个，最终搞出来了，界面如下样子：
怎么样？它可以将先定的一个目录中的所有文本文件批量转换成WORD文件，转换时可以删除所有多余行间空行，删除行首行尾空格，删除非段落换行，能选择是否以文件名为粗体字标题行，或是以文件第一行为粗体标题行，同时会自动设置行间距为1.5倍行间距，也可选择是否首行缩进。另外也可选择批量将WORD文件转为文本文件，转换过程中有进度显示，也可随时中断，最最重要的是，本软件支持你直接在资源管理器中，将一个或多个文本文件或WORD文件直接拖到软件图标上进行转换，而且支持同时拖文本文件和WORD文件一起去转换，拖放转换直到结束也不会显示程序窗口界面，方便吧！好了，想要批量将文本文件转换为WORD文件吗？或者想批量将WORD文件转换为文本文件吗？想要获得此软件吗？只要在下面评论留言转发一下，再私信给小编，前20名用户免费获得注册码哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f66957ef3efcbcc24077b0a3b613e2c/" rel="bookmark">
			tensorflow / tensorflow-gpu / tensorflow-cpu区别?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在tensorflow 1.x中，
环境tensorflow==1.xtensorflow-gpu==1.x只有CPUcpu运行和tensorflow一样运行有GPU且装Cuda和Cudnncpu运行gpu运行有GPU未装Cuda或Cudnncpu运行和tensorflow一样运行 在tensorflow 2.x中，
环境tensorflow-cpu==2.xtensorflow==2.x只有CPUcpu运行cpu运行有GPU且装Cuda和Cudnncpu运行gpu运行有GPU未装Cuda或Cudnncpu运行cpu运行 tensorflow 2.x不再区分是否gpu，当检测到gpu并安装cuda后，自动调用gpu。
但是，有些人不需要或没有gpu，gpu适配对这部分群体是浪费的（占用不必要的资源），于是有了tensorflow-cpu，我们可以理解其为cpu only版本
（综上，也可以理解为：tensorflow==1.x对应tensorflow-cpu==2.x，tensorflow-gpu==1.x对应tensorflow==2.x）
个人理解，如有错误请指正。
参考：
https://github.com/tensorflow/tensorflow/tree/v2.3.1
https://github.com/tensorflow/tensorflow/tree/r1.14
Difference between installation libraries of Tensorflow GPU vs CPU
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/420b10cbb03a66ad029952a60f8c24e6/" rel="bookmark">
			按条件增加列_EXCEL实用技巧：简单思维，实现vlookup同一条件引用多个结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平常工作中，vlookup函数是使用率最高的函数之一，vlookup组合函数广泛用于查找和引用，是一个好帮手；
vlookup是一个纵向查找函数，简单来说是这样使用的(要查找的值，查找区域，在第几列找，精确/模糊匹配)；
如果不使用组合函数，vlookup函数有很大的局限性，它通常仅单条件引用某组数据的第一个数据；
今天我们演示一个简单技巧，实现使用一个条件查找多个结果，如下图：
B列是区域，C列是城市，我们在F1列输入条件，使每个区域所对应C列的城市在F列中展开；
实现这个动态效果，并不难，使用简单思维就可以了，
首先，需要一个辅助列，然后再需要用到两个函数：countif和vlookup；
将A列设为辅助列，输入公式：COUNTIF(B$2:B2,F$1)，主要用于统计F1输入的条件所对应的个数；
在单元格F2开始输入公式：IFERROR(VLOOKUP(ROW(A1),A:C,3,0),"")
通过GIF图，可以明白，当F1的条件出现时，辅助列自动统计F1的条件在B列出现的次数，按升序排列，再通过vlookup函数进行引用到F列，为防止格式等问题导致引用失败，使用iferror函数显示成空白；
这个思维可以运用的场景也是很多的，你学会了吗？这里是日记坊，如果喜欢请右上角点关注并留言，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81f5963cea026261ca01eadb8b206c45/" rel="bookmark">
			slam入门——十四讲笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第1讲 预备知识 第1部分 数学基础第2讲 初识SLAM2.1 引子：小萝卜的例子2.2 经典视觉SLAM框架2.3 SLAM问题的数学表述2.4 实践：编程基础1. 安装Linux操作系统2. 使用cmake3. 使用库4. 使用IDE 第1讲 预备知识 了解什么是slam，如何使用本书和配套代码；对高等数学、线性代数、概率论；C++；Linux有基本的了解；
此处就略过，不细说了。 第1部分 数学基础 第2讲 初识SLAM 2.1 引子：小萝卜的例子 阅读一下即可，略
2.2 经典视觉SLAM框架 整个视觉SLAM流程包括以下步骤：
传感器信息读取。在视觉 SLAM 中主要为相机图像信息的读取和预处理。如果在机 器人中，还可能有码盘、惯性传感器等信息的读取和同步。视觉里程计 (Visual Odometry, VO)。视觉里程计任务是估算相邻图像间相机的运动， 以及局部地图的样子。VO 又称为前端（Front End）。后端优化（Optimization）。后端接受不同时刻视觉里程计测量的相机位姿，以及回 环检测的信息，对它们进行优化，得到全局一致的轨迹和地图。由于接在 VO 之后， 又称为后端（Back End）。回环检测（Loop Closing）。回环检测判断机器人是否曾经到达过先前的位置。如果 检测到回环，它会把信息提供给后端进行处理。建图（Mapping）。它根据估计的轨迹，建立与任务要求对应的地图。 2.3 SLAM问题的数学表述 什么是运动？我们要考虑从 k − 1 时刻到 k 时刻，小萝卜的位置 x 是如何变化的。什么是观测？假设小萝卜在 k 时刻，于 xk 处探测到了某一个路标 yj，我们要考虑 这件事情是如何用数学语言来描述的。 先来看运动。
无论是什么传感器，我们都能使用一个通用的、抽象的数学模型：
x k = f ( x k − 1 , u k , w k ) \mathbf{x}_k = f (\mathbf{x}_{k-1}, \mathbf{u}_k, \mathbf{w}_k) xk​=f(xk−1​,uk​,wk​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81f5963cea026261ca01eadb8b206c45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b607ffb7e900642430895678cfa6c15f/" rel="bookmark">
			ply格式转为obj,stl等格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ply格式转为obj,stl等格式 一般方法是使用meshlab或matlab等软件工具进行转化，需要配置环境，调试程序等一系列准备工作，工作量大，一般人只是使用一下，并不准备研究这些工具。
在这里推荐一个在线转换工具：https://www.meshconvert.com/zh.html
支持格式：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24b1e2f2303c0470b5c362963234ec95/" rel="bookmark">
			海康威视ip摄像头通过网线直接连接笔记本电脑使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海康威视ip摄像头通过网线直接连接笔记本电脑使用 1. ip摄像头连接电源，并通过网线连接电脑。长按reset恢复设置，听到语音即可。
2. 到海康威视官网下载 设备网络搜索 应用，可以找到你所连接摄像头设置密码进行激活，记录激活时的ip，恢复设置后默认是192.168.1.64。
3. 然后浏览器输入此ip，用户名admin，密码为你设置的密码。
4. 手动设置你电脑的网络ip及网关，不要选择自动分配ip。
5. 到第三步摄像头设置界面，更改其配置，改成和你电脑同一网段下的ip（不要和你电脑ip一样），设置结束后等待重启设备
6. 如若按以上步骤设置成功，打开命令行是可以ping通你设置的摄像头ip的，rtsp://admin:yourpwd@yourip:554为你的视频流地址，我用python和opencv即可获取到视频流进行图像处理了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/525edebeb288566787cfbc7ca593296c/" rel="bookmark">
			java中stringBuilder常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		String对象是不可改变的。每次使用 System.String类中的方法之一时，都要在内存中创建一个新的字符串对象，这就需要为该新对象分配新的空间。在需要对字符串执行重复修改的情况下，与创建新的 String对象相关的系统开销可能会非常昂贵。如果要修改字符串而不创建新的对象，则可以使用System.Text.StringBuilder类。例如，当在一个循环中将许多字符串连接在一起时，使用 StringBuilder类可以提升性能。
通过用一个重载的构造函数方法初始化变量，可以创建 StringBuilder类的新实例，正如以下示例中所阐释的那样。
StringBuilder MyStringBuilder = new StringBuilder(“Hello World!”);
(一)设置容量和长度 虽然 StringBuilder对象是动态对象，允许扩充它所封装的字符串中字符的数量，但是您可以为它可容纳的最大字符数指定一个值。此值称为该对象的容量，不应将它与当前 StringBuilder对象容纳的字符串长度混淆在一起。例如，可以创建 StringBuilder类的带有字符串“Hello”（长度为 5）的一个新实例，同时可以指定该对象的最大容量为 25。当修改 StringBuilder时，在达到容量之前，它不会为其自己重新分配空间。当达到容量时，将自动分配新的空间且容量翻倍。可以使用重载的构造函数之一来指定 StringBuilder类的容量。以下代码示例指定可以将 MyStringBuilder对象扩充到最大 25个空白。
StringBuilderMyStringBuilder = new StringBuilder(“Hello World!”, 25);
另外，可以使用读/写 Capacity属性来设置对象的最大长度。以下代码示例使用 Capacity属性来定义对象的最大长度。
MyStringBuilder.Capacity= 25;
(二)下面列出了此类的几个常用方法： (1)Append Append方法可用来将文本或对象的字符串表示形式添加到由当前 StringBuilder对象表示的字符串的结尾处。以下示例将一个StringBuilder对象初始化为“Hello World”，然后将一些文本追加到该对象的结尾处。将根据需要自动分配空间。
StringBuilderMyStringBuilder = new StringBuilder("Hello World!"); MyStringBuilder.Append(" What a beautiful day."); Console.WriteLine(MyStringBuilder); 此示例将 Hello World! What abeautiful day.显示到控制台。
(2)AppendFormat AppendFormat方法将文本添加到 StringBuilder的结尾处，而且实现了 IFormattable接口，因此可接受格式化部分中描述的标准格式字符串。可以使用此方法来自定义变量的格式并将这些值追加到 StringBuilder的后面。以下示例使用 AppendFormat方法将一个设置为货币值格式的整数值放置到 StringBuilder的结尾。
int MyInt= 25; StringBuilder MyStringBuilder = new StringBuilder("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/525edebeb288566787cfbc7ca593296c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a5e3958674b30cb8eab37a18c691bff/" rel="bookmark">
			pytorch torch.nn到底是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyTorch提供了模块和类torch.nn， torch.optim， Dataset和DataLoader 来创建和训练神经网络。例子使用MNIST数据集训练基本神经网络。
MNIST数据设置 使用经典的MNIST数据集，该数据集由手绘数字的黑白图像组成（0到9之间）。
下载数据集
from pathlib import Path import requests DATA_PATH = Path("data") PATH = DATA_PATH / "mnist" PATH.mkdir(parents=True, exist_ok=True) URL = "https://github.com/pytorch/tutorials/raw/master/_static/" FILENAME = "mnist.pkl.gz" if not (PATH / FILENAME).exists(): content = requests.get(URL + FILENAME).content (PATH / FILENAME).open("wb").write(content) 读取数据
该数据集为numpy数组格式，并已使用pickle（一种用于序列化数据的python特定格式）存储。
import pickle import gzip with gzip.open((PATH / FILENAME).as_posix(), "rb") as f: ((x_train, y_train), (x_valid, y_valid), _) = pickle.load(f, encoding="latin-1") x_train.shape # (50000, 784) 每个图像为28 x 28，存储为长度为784（= 28x28）的扁平行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a5e3958674b30cb8eab37a18c691bff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8afe0d0aaae161d3d09f28cfdfc368cd/" rel="bookmark">
			python爬虫获取数据失败请稍后访问_Python爬取拉勾网数据返回&#34;success&#34;:false,&#34;msg&#34;:您操作太频繁,请稍后再访问？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		headers = {
'Cookie': '_ga=GA1.2.922961630.1527598469; user_trace_token=20180529205427-6be5a91c-633f-11e8-8f27-5254005c3644; LGUID=20180529205427-6be5b0a9-633f-11e8-8f27-5254005c3644; index_location_city=%E5%8C%97%E4%BA%AC; _gid=GA1.2.1648551100.1532305833; WEBTJ-ID=20180724085434-164c9c7d78778-09b1f2f8b3da92-47e1f32-1327104-164c9c7d788306; _gat=1; LGSID=20180724085434-220c9119-8edc-11e8-a379-525400f775ce; PRE_UTM=m_cf_cpc_baidu_pc; PRE_HOST=www.baidu.com; PRE_SITE=https%3A%2F%2Fwww.baidu.com%2Fbaidu.php%3Fsc.K00000jqTgoHCHWeZa5tm_Mn-7o1hRsTpgd5Aft4aFAeIFCmk1MPUOomATl49rRv-56MQdMX78tlhPndTxS1qn_-ZsbCMr-u_bmMBZaJbpyU4vugwA2ErCbLcjWZzjkEw5K_L6h3ZLVwS_asOJ5UoU80lOitPwNmpM07Dn4RflfVCSKw0s.DD_NR2Ar5Od663rj6tJQrGvKD7ZZKNfYYmcgpIQC8xxKfYt_U_DY2yP5Qjo4mTT5QX1BsT8rZoG4XL6mEukmryZZjzL4XNPIIhExzLu2SMcM-sSxH9vX8ZuEsSXej_qT5o43x5ksSEzseld2s1f_U2qS4f.U1Yk0ZDqs2v4VnL30ZKGm1Yk0Zfqs2v4VnL30A-V5HczPfKM5yF-TZnk0ZNG5yF9pywd0ZKGujYk0APGujYs0AdY5HDsnHIxnH0krNtknjc1g1DsPjuxn1msnfKopHYs0ZFY5Hf10ANGujYkPjRkg1cknjb3g1cznHR30AFG5HcsP0KVm1YLPWnznj6Yn1KxnH0snNtkg1Dsn-ts0Z7spyfqn0Kkmv-b5H00ThIYmyTqn0K9mWYsg100ugFM5H00TZ0qn0K8IM0qna3snj0snj0sn0KVIZ0qn0KbuAqs5H00ThCqnfKbugmqTAn0uMfqn0KspjYs0Aq15H00mMTqnH00UMfqn0K1XWY0IZN15Hn1rjRdP10zPHbYPW6sP10LnW00ThNkIjYkPHnzn1b1PWTsrjD30ZPGujdhn16LPWRsuH0snjf1mWTv0AP1UHdKnjfzfHNAnYm3wDN7nHD40A7W5HD0TA3qn0KkUgfqn0KkUgnqn0KlIjYs0AdWgvuzUvYqn7tsg1Kxn7ts0Aw9UMNBuNqsUA78pyw15HKxn7tsg1nkrHb1PNts0ZK9I7qhUA7M5H00uAPGujYs0ANYpyfqQHD0mgPsmvnqn0KdTA-8mvnqn0KkUymqn0KhmLNY5H00uMGC5H00uh7Y5H00XMK_Ignqn0K9uAu_myTqnfK_uhnqn0KWThnqPjDsrj6%26ck%3D742.1.87.298.565.298.557.393%26shh%3Dwww.baidu.com%26sht%3Dbaidu%26us%3D1.0.1.0.1.302.0%26ie%3Dutf-8%26f%3D8%26tn%3Dbaidu%26wd%3D%25E6%258B%2589%25E5%258B%25BE%25E7%25BD%2591%26rqlang%3Dcn%26inputT%3D3159%26bc%3D110101; PRE_LAND=https%3A%2F%2Fwww.lagou.com%2Flp%2Fhtml%2Fcommon.html%3Futm_source%3Dm_cf_cpc_baidu_pc%26m_kw%3Dbaidu_cpc_bj_e110f9_d2162e_%25E6%258B%2589%25E5%258B%25BE%25E7%25BD%2591; JSESSIONID=ABAAABAABEEAAJABC29FEBF1344B3EAF297880D6D2C3B4D; Hm_lvt_4233e74dff0ae5bd0a3d81c6ccf756e6=1532305833,1532333926,1532393675,1532393679; TG-TRACK-CODE=index_search; LGRID=20180724085445-280d3562-8edc-11e8-a379-525400f775ce; Hm_lpvt_4233e74dff0ae5bd0a3d81c6ccf756e6=1532393685; SEARCH_ID=f0feaea9597b46a6add3ed1909a978dd',
# 防盗链
'Referer': 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.62 Safari/537.36'
}
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/339/">«</a>
	<span class="pagination__item pagination__item--current">340/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/341/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>