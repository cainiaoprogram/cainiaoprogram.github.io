<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3004c263f016efd8389aeb5f20341819/" rel="bookmark">
			NodeMCU ESP8266 基于Arduino IDE的串口使用详解（图文并茂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NodeMCU ESP8266 的UART使用 文章目录 NodeMCU ESP8266 的UART使用前言硬件连接串口使用日志打印读取数据常用接口beginprintprintln 总结 前言 UART (Universal Asynchronous Receiver/Transmitter)，串口通讯在嵌入式开发中至关重要，我们可以通过串口打印程序里的数据，也可以通过串口将数据发送到PC上并进行可视化的图形显示。
注意：相关的串口通讯的知识可以参考这篇文章
UART串口协议快速扫盲（图文并茂+超详细）
NodeMCU ESP8266开发板可以直接通过MicroUSB线和PC进行连接，在Arduino IDE内置的串口工具进行数据显示，下面我们进一步介绍。
硬件连接 基于 NodeMCU 的 ESP8266 有两个 UART 接口：UART0 和 UART1。
ESP8266通过UART接口的数据传输速度可以达到115200的40倍，即4.5Mbps。
默认情况下，对于 40MHz 振荡器，UART0 波特率为 115200。
可以根据应用的需要将其更改为用户定义的值。具体的引脚定义如下所示；
TXD（数据发送引脚）
该引脚用于串行传输数据。
RXD（数据接收引脚）
该引脚用于串行接收数据。
注： SD_DATA_1/RXD1引脚在内部用于 Flash 的 SPI 四路通信。
因此，我们只能使用 UART1 的 TXD1 引脚。
串口使用 日志打印 具体的示例代码如下所示；
int time_cnt = 0; void setup() { // put your setup code here, to run once: Serial.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3004c263f016efd8389aeb5f20341819/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36da28127d6bd2b4dfe2568fc603b976/" rel="bookmark">
			亲测解决Clearing orphaned inode 或者recovering journal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两个问题其实是同时出现的，下面就来说一下解决方法。
背景 坏境：
Ubuntu 22.04 + CUDA driver 535
在配置cuda driver的时候，意外选择了一个扩展包，然后就突然黑屏，强制重开后出现
Clearing orphaned inode recovering journal 之类的提示（当时没法完整复制error，所以只记下了关键词）。
解决方法 这是由于显卡驱动没有正确安装导致的。所以先进入GRUB，这个可能系统会提示F几进入。小虎的电脑是F11，然后进入setting （最后一行），然后退出会自动进入。
然后选择Advanced Options -&gt; Recovery mode -&gt; Root access。在带#号的prompt里面，输入：
sudo ubuntu-drivers autoinstall 如果有提示其他安装信息，请按照其提示输入。直到
nvidia-smi 正常使用为止。
然后重启，使用指令：
reboot 英文原版笔记 In grub,
Boot to the GRUB menu.
Choose Advanced Options.
Choose Recovery mode.
Choose Root access.
At the # prompt, type
sudo ubuntu-drivers autoinstall
The above command will autoinstall the drivers suited to your machine and update them.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36da28127d6bd2b4dfe2568fc603b976/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e4dacf31c946f9800f7fd76f80cd365/" rel="bookmark">
			[清华大学]漏洞挖掘之状态敏感的模糊测试StateFuzz
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dr.赵博栋 Prof.张超 清华大学 网络研究院 INSC
本文主要介绍了通过State Fuzz对Linux驱动程序进行模糊测试，该Fuzz方法由赵博栋博士在InForSec会议上分享，并在USENIX Security上发布.StateFuzz :System Call-Based State-Aware Linux Driver Fuzzing.该篇文章主要介绍了核心方法，为展示测试数据与实验展望.
前言： 模糊测试是当前主流的漏洞挖掘方法，近年来发现了大量的未知漏洞，受到工业界和学术界的广泛关注。其中，以代码覆盖率为进化指标的灰盒测试方案得到大量研究，衍生出了大量优化改进方案。但是，代码覆盖率与漏洞之间存在gap，提高代码覆盖率不一定能够有效发现潜在的安全漏洞。提出了状态敏感的模糊测试方法StateFuzz (USENIX’22)，引入了程序状态作为进化指标，实验结果表明了该方法的有效性，在Linux和Android驱动中发现了数十个未知漏洞。本次报告将与大家探讨这一方案。
背景 漏洞：网络空间重要安全威胁 重要事件：乌克兰断电事件 震网病毒事件 WannaCry HeartBleed(websites) Aurora(Google)
漏洞：网络攻击的突破口 制导部分(漏洞) 战斗部分(漏洞利用) 控制部分(恶意代码)
美国军火商Lockheed-Martin提出的"杀伤链"
Reconnaissance 目标侦查 （漏洞挖掘）
Research,identification,and selection of targets
Weaponization 武器定制 （漏洞利用）
Pairing remote access malware with exploit into a
deliverable payload(e.g.Adobe PDF and Microsoft Office files)
Delivery 武器投放（主动/被动）
Transmission of weapon to target(e.g. via email attachments websites,r USB drivers)
Exploitation 武器生效（漏洞触发与劫持）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e4dacf31c946f9800f7fd76f80cd365/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46c4dd0180088f639c3183e1573fc882/" rel="bookmark">
			华为eNSP防火墙USG6000V 导入包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度网盘下载地址：
链接：https://pan.baidu.com/s/1Ma2PguH9q_Kse7-vqMnd-Q 提取码：6666
下载好后直接把文件导入进去耐心等待即可
输入NAME，和密码：默认name：admin
默认pass：Admin@123
首次登录需要修改密码输入Y,再次输入输入旧密码：Admin@123
填写新密码：Admin@1234
再次填写新密码：Admin@1234
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a16f507ca238b315be2148a947002b6/" rel="bookmark">
			windows11家庭版升级专业版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows11家庭版转专业版（白嫖教程） 1. 第一步
打开设置，复制windows11专业版密钥，我用的密钥是：82XM6-23JJG-44W4Q-W3QPQ-V9FY4
完成如图以下内容（注意关闭网络），等待关机重启进入第二步
2.新建文件输入以下内容：（保存退出，后缀改为.bat,右击以管理员身份运行，然后会出现提示框，一路点确定就行，最后查看设置是否成功，windows11专业版）
slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX
slmgr /skms kms.03k.org
slmgr /ato
3.到设置查看是否成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6b82d24f44b19a20fb7f0219fa500ee/" rel="bookmark">
			福建省标准地图矢量下载、使用和对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		福建省标准地图矢量下载、使用和对比 文章目录 福建省标准地图矢量下载、使用和对比前言下载使用对比总结 前言 福建省标准地图前几天发布了，其中包含了GDB的矢量地理要素和ArcGIS mxd制图模板
下载 1.打开以下网站，福建省标准地图服务系统 (fjmap.net)
2.选择上方菜单中的【标准地图】,进入以下界面，再通过上面的搜索栏，输入“GDB”，点击【搜索】进行搜索，出现以下界面
3.在该模块中，可以通过点击【说明】查看数据的说明和格式标准，点击【下载】之后即可下载rar压缩包
使用 1.压缩包解压之后其中有以下两个资源，使用ArcGIS打开文档后，需要通过【属性】设置各地理要素源
2.有些数据源在GDB中并没有直接显示，如“高程”，在设置完所有数据源之后即可自动匹配
3.将设置好的模板通过【导出地图】的功能，导出500dpi分辨率的地图如下
4.其中的地理矢量数据坐标系信息如下，如果需要使用WGS84投影的需要进行通过ArcGIS的【投影】功能转换坐标信息：
对比 找到了之前搜集的网络上的China admin division shp行政边界数据，进行对比，发现在主要是在海岸线有所差距，其次可能是由于分辨率的问题，China admin division shp的细节更多（这里就不放图片了）
总结 最后放上以上涉及数据的原始相关链接，有能力的可以前往数据原地址下载，使用数据时记得附上相关引用链接和论文
1.福建省地图示意图版(GDB)16开1_300万2023年_闽S[2023]254号：http://bzdt.fjmap.net/index.html
2.China admin division shp：https://github.com/GaryBikini/ChinaAdminDivisonSHP
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/510a718fe0ac98f5e7180224dd1bbf2b/" rel="bookmark">
			【操作系统】文件描述符 文件句柄 区别 linux命令查看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查找了很多资料才区分出来，这里不主要介绍概念，而是告诉大家区分的关键点
文件描述符（file descriptor, fd）：是文件描述符表中的一种索引标识，标识对象除了普通文件和目录外，还包括管道、FIFO（命名管道）、Socket、终端、设备等
文件描述符表（file descriptor table）：每个进程会在其进程控制块（PCB）内维护属于自己的文件描述符表
打开文件表（open file description table）：系统内所有打开的文件及其相关的元信息，该结构称为打开文件表
文件描述（file description）= 文件句柄（file handle）：打开文件表中的一行称为一条文件描述，也经常称为文件句柄
举例：两个程序的进程打开的同一文件状态不一样，一个进程对这个文件进行写的操作，另外一个进程进行读的操作，就产生了两个文件描述符和一个文件句柄
下面是linux命令查看：
查看进程文件描述符 lsof -p pid | wc -l 查看进程使用句柄数
保存着这个服务对文件执行读写操作的文件描述符存在状态，只记录读写执行文件这种状态 ,不会记录MEM，TXT这种的
这也是为什么这个命令ls -l /proc/pid/fd/ | wc -l执行结果的数值比lsof -p pid | wc -l 的执行结果小 ls -l /proc/pid/fd/ | wc -l 查看操作系统当前的情况
分别输出已分配文件句柄（已打开的文件数目）的数目、 已分配但未使用文件句柄的数目、 文件句柄的最大数目 cat /proc/sys/fs/file-nr 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/563515ec7e4b5d68700dc87922b3022e/" rel="bookmark">
			【Redis】举例让你快速理解！Redis数据结构与命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 数据存内存，C语言实现，单线程架构
基于键值对 ，值可以为字符串、哈希、列表、集合、有序集合
键过期功能实现缓存，流水线功能减少网络开销
持久化（数据内存-&gt;磁盘）、主从复制（数据多副本）
高可用（故障发现与自动转移）、分布式
*奇数是不稳定版，如4.1，4.3等。偶数稳定，如5.2，5.4jk00…0
4.0.11，6.0.9，6.0.9去看更新文档
主要应用 缓存：键值过期，淘汰策略排行榜：列表与集合计数器：计数社交网络：订阅和阻塞 启动与停止 服务器：任何目录下均可
redis-server 客户端
redis-cli -h 127.0.0.1 -p 6379 停止
redis-cli shutdown （nosave|save） 关闭前是否生成持久化文件
不要kill -9杀死redis，但可以kill+进程号
数据库级别的部分用法 dbsize输出键的总数 127.0.0.1:6379&gt; dbsize (integer) 4 select切换数据库 redis默认有16个数据库，不同数据库之间没有管理，可以是相同数据，但如果是使用多个数据库，最好还是用多个不同端口的redis客户端
redis-cli默认是0号数据库
select index
#切到第一个库 select 0 #切到第16个库 select 15 flushdb&amp;flushall清除数据库 flushdb清除当前数据库
flushall清除所有数据库
键值数目多的时候可能阻塞
键级别的部分用法 set插入与get查看 一个键值对 127.0.0.1:6379&gt; set hello world OK 127.0.0.1:6379&gt; get hello "world" 一个列表型 127.0.0.1:6379&gt; rpush mylist a b c d e f g (integer) 7 get获取的键不存在，返回nil（空）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/563515ec7e4b5d68700dc87922b3022e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb0c552f31e0f9d569a016e918713a5b/" rel="bookmark">
			【游戏开发】程序化动画的基础流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序化动画（Procedural Animation）是一种由程序通过 IK 和约束来控制动作的方式形成的动画，适用于动作较复杂的异形角色，如多足机器人、蜘蛛、蛇等。
优点缺点易于实现复杂角色的动画，如多足性能不佳动画更连贯动画动作生硬 又说连贯，又说生硬，要不要听听你在说什么？
连贯是我觉得的。由于受到 IK 驱动，因而不存在动画切换时的快速过渡导致的滑步等问题，动画会更连贯，；生硬是我的动画师朋友觉得的。在他们看来，由 IK 驱动的动画是被动的，不自然。 对于这里的主动与被动，我是这样理解的：假设给一个人穿上轮滑鞋，主动就是他自己向前滑，被动就是我们在后面推他往前走，可以想像一下这个差别。当然，我想我们仍然有办法从代码层面让程序化动画看起来更主动，但可能会过于复杂。如果过于复杂的话，为什么不直接播动画呢？ 制作多足角色的程序化动画的流程 绑定 IK 足部的 IK 通常会包含两个控制器：
末端控制器（Effector/Target）：指示末端的目标位置；极坐标控制器（PoleVector/JointTarget/Hint）：指示末端应从哪个方向抵达目标位置。 计算末端的目标位置 Target 末端的目标位置应随着角色移动而变化。由于地面可能高低不平，因此这个目标位置应该是在水平面上像对于锚点的偏移，而高度则通过射线检测得到。
计算目标位置与当前末端控制器所处位置的距离 直接计算欧式距离即可：
d i s t a n c e = Δ x 2 + Δ y 2 + Δ z 2 distance = \sqrt{\Delta x^2 + \Delta y^2 + \Delta z^2} distance=Δx2+Δy2+Δz2 ​
比较距离与容忍度 Endurance 如果距离超过容忍度，则移动末端控制器至目标位置。
关于目标位置
与目标位置相关的参数是球心位置，它可以根据当前移动速度变化，即球心应向速度方向偏移。
此外，Hint 也可以向速度方向偏移。
另外还有一点，就是也可以检测一下目标位置的旋转，例如双足的原地旋转。关于容忍度
与容忍度的比较时的主要参数是半径，它也可以根据当前移动速度变化，即半径可以随速率变高而变大。 以防你不知道：这里的比较可以使用平方距离，这样省得开根号。
关于末端控制器的移动：
末端控制器可以以曲线的形式进行过渡，即添加一个 y y y轴的曲线，来表示"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb0c552f31e0f9d569a016e918713a5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/708cdf274b5179e63416e62755bd7b4e/" rel="bookmark">
			Bug的严重等级和优先级别与分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 Bug的严重等级定义：
1、 Blocker 即系统无法执行、崩溃或严重资源不足、应用模块无法启动或异常退出、无法测试、造成系统不稳定。
严重花屏
内存泄漏
用户数据丢失或破坏
系统崩溃/死机/冻结
模块无法启动或异常退出
严重的数值计算错误
功能设计与需求严重不符
其它导致无法测试的错误, 如服务器500错误
2、Critical 即影响系统功能或操作，主要功能存在严重缺陷，但不会影响到系统稳定性。
功能未实现
功能错误
系统刷新错误
数据通讯错误
轻微的数值计算错误
影响功能及界面的错误字或拼写错误
安全性问题
3、Major 即界面、性能缺陷、兼容性。
操作界面错误（包括数据窗口内列名定义、含义是否一致）
边界条件下错误
提示信息错误（包括未给出信息、信息提示错误等）
长时间操作无进度提示
系统未优化（性能问题）
光标跳转设置不好，鼠标（光标）定位错误
兼容性问题
4、Minor 即易用性及建议性问题。
界面格式等不规范
辅助说明描述不清楚
操作时未给用户提示
可输入区域和只读区域没有明显的区分标志
个别不影响产品理解的错别字
文字排列不整齐等一些小问题
二、 Bug的优先等级
1. Immediate 即“马上解决”，表示问题必须马上解决，否则系统根本无法达到预定的需求。
2. Urgent 即“急需解决”，表示问题的修复很紧要，很急迫，关系到系统的主要功能模块能否正常。
3. High 即“高度重视”，表示有时间就要马上解决，否则系统偏离需求较大或预定功能不能正常实现。
4. Normal 即“正常处理”，进入个人计划解决，表示问题不影响需求的实现，但是影响其他使用方面，比如页面调用出错，调用了错误的等。
5. Low 即“低优先级”，即问题在系统发布以前必须确认解决或确认可以不予解决。
备注：严重性和优先级并不总是一一对应。有时候严重性高的软件缺陷，优先级不一定高，甚至不需要处理，而一些严重性低的缺陷却需要及时处理，具有较高的优先级。
三、一般 BUG 的正规的处理流程
四、其他划分方法
BUG严重等级划分：
1级：致命
1.由于程序引起的非法死机，退出，数据丢失，主要功能完全丧失，系统悬挂等错误
2.操作或使用某一功能时，导致程序异常退出，或其余功能无法使用，或造成经常性死机和重启
3.正常的用户操作，导致系统崩溃
2级：严重
1.严重影响系统要求或基本功能的实现，且没有办法避免冲突
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/708cdf274b5179e63416e62755bd7b4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d55fb546a5b9372950c5a6bbccb6b83/" rel="bookmark">
			声音克隆，定制自己的声音，使用最新版Bert-VITS2的云端训练&#43;推理记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 本次训练服务器使用Google Colab T4 GPUBert-VITS2库为：https://github.com/fishaudio/Bert-VITS2，其更新较为频繁，使用其2023.10.12的commit版本：主要参考：B站诸多大佬视频，CSDN:https://blog.csdn.net/qq_51506262/article/details/133359555,
码云：https://gitee.com/Sake809/Bert-VITS2-Integration-package部署过程中出现诸多问题，对原版Bert-VITS2个别代码也有调整，调整后的代码已放码云：https://gitee.com/ajianoscgit/bert-vits2.git本项目是确定可运行的，后续随着Bert-VITS2的持续更新，当前能稳定运行的代码后续可能会出问题。 环境准备 包括下载代码、下载模型等等步骤
下载项目 %cd /content/drive/MyDrive # 这里是下载原仓库代码 #!git clone https://github.com/fishaudio/Bert-VITS2.git # 这是下载码云调整后的代码 !git clone https://gitee.com/ajianoscgit/bert-vits2.git 下载模型 这里只下载了中文语音的模型，在https://huggingface.co/hfl/chinese-roberta-wwm-ext-large/tree/main 下载即可，根据/content/drive/MyDrive/Bert-VITS2/bert/chinese-roberta-wwm-ext-large目录缺失的文件下载补全。
%cd /content/drive/MyDrive/Bert-VITS2/bert/chinese-roberta-wwm-ext-large !wget https://huggingface.co/hfl/chinese-roberta-wwm-ext-large/resolve/main/flax_model.msgpack !wget https://huggingface.co/hfl/chinese-roberta-wwm-ext-large/resolve/main/pytorch_model.bin !wget https://huggingface.co/hfl/chinese-roberta-wwm-ext-large/resolve/main/tf_model.h5 下载底模文件：
底模文件使用b站大佬裁切好的底模，效果更好，https://www.bilibili.com/video/BV1hp4y1K78E
由于cloab无法直接下载到模型文件，只好先在站点下载完成之后再上传到谷歌云盘中，放在logs/base/目录下。
# 这是原版底模，使用1.1版b站大佬的底模替代！ %cd /content/drive/MyDrive/Bert-VITS2 #!wget -P logs/base/ https://huggingface.co/Erythrocyte/bert-vits2_base_model/resolve/main/DUR_0.pth #!wget -P logs/base/ https://huggingface.co/Erythrocyte/bert-vits2_base_model/resolve/main/D_0.pth #!wget -P logs/base/ https://huggingface.co/Erythrocyte/bert-vits2_base_model/resolve/main/G_0.pth 编写数据预处理脚本 训练特定音色的模型时，需要首先将准备好的音频干声文件进行分割，将分割后的文件文本提取出来备用。
可以本地将这些文件先准备好，也可以服务器上制作，服务器上制作就用以下脚本实现。
以下脚本为实现此功能的相关脚本(该脚本根据csdn大佬的代码进行了调整，实现读取运行时参数和音频转写文本时汉字繁体转简体)：
import os from pathlib import Path import librosa from scipy.io import wavfile import numpy as np import whisper import argparse from langconv import * def split_long_audio(model, filepath, save_dir="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d55fb546a5b9372950c5a6bbccb6b83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/474a15e2e3dca44d3dc0ace66021c159/" rel="bookmark">
			SpringBoot IOC容器深入分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot IOC容器深入分析 核心容器 SpringBoot的IOC容器的核心是由BeanFactory和ApplicationContext组成的。BeanFactory提供了配置框架和基本功能，ApplicationContext添加了更多企业级功能，例如事件发布、国际化处理等。
Bean生命周期 Bean的生命周期包括Bean定义的加载、Bean的初始化、Bean的使用和Bean的销毁。SpringBoot的IOC容器管理了Bean的完整生命周期。
依赖注入（DI） 依赖注入是实现IOC的主要方式，它减少了代码的耦合度，使得代码更加模块化和易于测试。
实战示例：构建一个简单的SpringBoot应用 步骤1：创建Spring Boot项目 spring init --name=springboot-ioc-example --dependencies=web 步骤2：定义Bean 创建一个接口和两个实现类：
public interface GreetingService { String greet(); } @Service public class MorningGreetingService implements GreetingService { @Override public String greet() { return "Good Morning!"; } } @Service public class EveningGreetingService implements GreetingService { @Override public String greet() { return "Good Evening!"; } } 步骤3：注入依赖 使用@Autowired注解来注入依赖：
@RestController public class GreetingController { @Autowired private GreetingService greetingService; @GetMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/474a15e2e3dca44d3dc0ace66021c159/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/539a515fcf0fb24b2ccdb5f37bf48257/" rel="bookmark">
			pytorch环境的配置（超级详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、创建conda虚拟环境
1、查询创建了哪些conda虚拟环境的方法
2、创建虚拟环境
3、激活需要的虚拟环境
4、查看环境下有哪些包
二、查询本机cuda版本
三、安装pytorch
1、进入pytorch官网
2、选择对应版本
​3、采用清华镜像下载pytorch
4、验证是否安装成功
5、查看torch版本
四、验证cudnn版本的方法
五、安装tensorboard
六、在pycharm中配置刚才的conda环境
一、创建conda虚拟环境 1、查询创建了哪些conda虚拟环境的方法 按windows+R键输入cmd
再输入如下代码查询conda环境下有哪些虚拟环境
conda info --envs 2、创建虚拟环境 name是可以自定义的任意环境名字，python=x.x指定python版本
conda create -n name python=x.x 3、激活需要的虚拟环境 name是指需要激活环境的名字
conda activate name 4、查看环境下有哪些包 conda list 5、删除不用的环境 name是需要删除的环境名字，如果不加上--all的话代表删除的是当前环境下的一个库，加上是删除当前环境
conda remove -n name --all 二、查询本机cuda版本 cmd命令后输入nvidia-smi，如下图绿色框线内即是cuda版本号
三、安装pytorch 1、进入pytorch官网 点击Get Started
2、选择对应版本 版本一定要比第二步的cuda版本小
如果上图没有对应的版本可以从下图绿色框线里找到
3、采用清华镜像下载pytorch 进入cmd命令后，依次输入下面四行代码，将路径更改为清华源
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes conda config --add channels https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/539a515fcf0fb24b2ccdb5f37bf48257/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab9eacebf9533f3f3da1ce55612bd74e/" rel="bookmark">
			Redis部署安装&amp;常见命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Win版本Redis安装 1、下载Redis安装包
2、进入到Redis下载后文件中（将下载后的压缩包进行解压），在windows系统中进入该目录下dos窗口
例如：cd C:\Users\sunway\Documents\Tencent Files\1571711197\FileRecv\Redis-x64-3.2.100
3、进入Redis-x64-3.2.100\redis.windows.conf文件，修改Redis相应登录密码
4、在当前路径dos窗口运行命令
命令①：redis-server.exe redis.windows.conf（创建临时redis服务器）
命令②：redis-server.exe --service-install redis.windows.conf --loglevel verbose（创建永久服务）
5、启动Redis服务
操作①：在此路径的dos窗口运行：redis-server --service-start
操作②：在服务界面进行启动
二、Linux版本redis单点部署 1、解压redis安装包
tar -zxvf redisXXXX
2、编译安装
make make PREFIX=/usr/local/redis install
3、redis在后台运行，不占据当前终端。使用vi 编辑器打开 redis的配置文件，daemonize默认为no改为yes,让redis在后台运行。修改databases 256
启动
4、复制redis配置文件
cp redis.conf /usr/local/redis/
5、修改配置密码，编辑redis.conf，修改requirepass 为对应密码
6、启动
./redis-server /usr/local/redis/redis.conf
7、检查redis端口监听是否正常
netstat -anlp|grep 6379 三、Linux版本redis集群部署 1、搭建linux版本redis集群前提是部署好redis（第二点：Linux版本redis单点部署）
2、创建redis集群目录
mkdir -p /usr/local/redis-cluster/6001;
mkdir -p /usr/local/redis-cluster/6002;
mkdir -p /usr/local/redis-cluster/6003;
mkdir -p /usr/local/redis-cluster/6004;
mkdir -p /usr/local/redis-cluster/6005;
mkdir -p /usr/local/redis-cluster/6006;
3、拷贝redis.conf配置文件到6001.6002,6003,6004,6005,6006目录下作为各个节点的配置文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab9eacebf9533f3f3da1ce55612bd74e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e29ec209f8fe2ed9ddc5291e3f2aaff8/" rel="bookmark">
			基于DeepLabV3 &#43;网络的注意力机制图像语义分割方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：图像语义分割是一种通过为目标类别中的每个点分配基于其“语义”的标签来区分图像中不同种类事物的技术。目前使用的Deeplabv3+图像语义分割方法计算复杂度高，内存消耗大，难以在计算能力有限的嵌入式平台上部署。在提取图像特征信息时，Deeplabv3+难以充分利用多尺度信息。这可能导致详细信息的丢失和损害分割的准确性。提出了一种基于DeepLabv3+网络的改进图像语义分割方法，以轻量级的MobileNetv2作为模型的主干。将ECAnet通道关注机制应用于底层特征，降低了计算复杂度，提高了目标边界的清晰度。在ASPP模块之后引入极化自注意机制，改善特征图的空间特征表示。在VOC2012数据集上进行验证，实验结果表明，改进模型的MloU和mAP分别达到了69.29%和80.41%，能够预测更精细的语义分割结果，有效地优化了模型复杂度和分割精度。
1.介绍
人工智能(AI)的出现极大地改变了我们生活的方方面面。语义分割的概念很容易理解。当人们看到一张图片时，很容易理解图片的内容。语义分割允许机器理解图片的内容。在现实中的应用也越来越广泛，例如自动驾驶技术的场景识别、医学图像分割领域的手术导航、广告推荐等。图像语义分割的广泛应用具有很高的实用价值(Iftikhar et al, 2022, 2023)。
迄今为止，已经提出了许多不同的语义分割算法，包括传统的和深度学习的语义分割。从传统的方法，如阈值(Otsu, 1979)、基于直方图的捆绑、区域增长(Nock和Nielsen, 2004)、k-means聚类(Dhanachandra等人，2015)和分水岭(Najman等人，1994)，到更高级的算法，如活动轮廓(Dhanachandra等人，2015)、图切(Najman等人，1994)、条件和马尔可夫随机场(Kass等人，2004)和基于稀疏的方法(Boykov等人，2001;普拉斯等人，2009)。为了弥补传统方法的不足，深度学习的语义分割方法从模型结构上主要有两种分类方式:基于信息融合和基于编码-解码器(Minaee et al, 2021)。在信息融合方法的基础上，通过增加网络层数来提高模型利用率(Starck et al .， 2005;Minaee et al, 2017)。代表性算法包括全卷积网络(FCN)算法和一系列改进算法(彪等，2018)，如FCN - 32s、FCN - 16s和FCN - 8s。基于编码器-解码器方法(Liu et al .， 2018;Fu et al .， 2022)，通过采用不同的骨干网形式和金字塔池化模块，提高了网络的准确率。代表性算法包括金字塔场景解析网络(PSPNet)(Sun and Wang, 2018)和DeepLabv系列。目前基于Deeplabv3+的方法计算复杂度高，内存消耗大，难以在计算能力有限的嵌入式平台上部署。Deeplabv3+在提取图像特征信息时不能充分利用多尺度信息，容易造成细节信息的丢失，导致分割精度受损。进一步提高能力。2的DeepLabv3 plus网络获取关键品类信息，主要基于DeepLabv3 plus进行改进。本文的主要贡献总结如下:
1. 对DeepLabv3+网络进行了改进，使其适合于现实场景的需求。原始特征提取网络参数量过大，模型采用轻量级的MobileNetV2作为骨干网，在此基础上进一步优化，解决了空间细节丢失和特征提取不足的问题。
2. 在DeepLabv3+中，在ASPP模块之后加入极化自注意机制(PSA-P、PSA-S)，增强特征图提取细节信息的能力，提高语义分割的准确性。在MobileNetv2底层特征之后加入通道注意机制(ECA-Net)，恢复更清晰的分割边界。
3.ASPP模块使用分条池代替原有的全局平均池来有效捕获远程依赖关系，使用混合池代替原有的全局平均池来有效捕获不同位置之间的短程和远程相互依赖关系，从而提高了系统的效率和可靠性
2.DeepLabv3 plus网络
DeepLabv3 plus网络(Yang et al .， 2020)如图1所示。骨干网的作用是提取特征语义信息(Zhao et al .， 2017)。ASPP的功能是从骨干网中重新提取特征信息，以获得足够的特征信息。DCNN通常是一个深度卷积神经网络。ASPP模块主要由5部分组成，1 × 1卷积和孔隙比分别为6次、12次和18次，3 × 3卷积和全球平均池化。这五个部分是并行的，共同构成了ASPP部分。骨干网底层特征后接入1 × 1。然后将卷积和ASPP连接到4次下采样部分进行特征融合，再连接到3 × 3卷积和4次下采样部分恢复图像的大小。
3.改进的v3＋网络
以DeepLabv3 plus模型为主体进行改进。在基于DeepLabv3 plus网络的图像语义分割中，本文采用轻量级的MobileNetV2作为骨干网。然后，利用ASPP方法从图像中提取多尺度信息。利用条带池化代替全局池化在骨干网中获得的特征图，保留更详细的信息。引入注意机制，增加极化自注意机制，对ASPP模块得到的特征映射进行加权。加入ECA-Net来融合MobileNetV2和提高图像分割性能。改进后的模型如图2所示。
全局平均池化的池化窗口是方形的，有一定的局限性，难以获得不同方向图尺度的相关性。条带池化比全局平均池化具有更多的优点。条形池化的池化窗口为矩形，条形池化的设计可以从水平和垂直两个维度获取全局信息，扩大了获取特征信息的范围(Hou et al .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e29ec209f8fe2ed9ddc5291e3f2aaff8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/283214d129dcd909759f34d9a7e44bfd/" rel="bookmark">
			配置XP虚拟机和Win 10宿主机互相ping通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、关闭虚机和宿主机的防火墙1、关闭XP虚拟机的防火墙1.1 方式一：XP右下角图标进入1.2 方式二 ：控制面板进入1.3 方式三：services服务进入1.4 方式四 ：cmd命令行进入 2、关闭宿主机的防火墙 二、设置XP和宿主机VMnet8的IP地址、网关和DNS1、获取VMWare的虚拟网络配置信息2、设置XP的VMnet8的IP地址、网关和DNS3、设置宿主机VMnet8的IP地址、网关和DNS 三、获取IP地址进行互Ping测试1、获取IP地址2、互Ping测试 宿主机也是主机,这个概念是相对于子机而言的,比如你安装有虚拟机的话,那么相对于虚拟机而言,你正在使用的计算机就是宿主机。一般使用NAT模式连接，NAT模式不行再使用桥接模式 一、关闭虚机和宿主机的防火墙 1、关闭XP虚拟机的防火墙 1.1 方式一：XP右下角图标进入 1.2 方式二 ：控制面板进入 1.3 方式三：services服务进入 也可以cmd进入服务，效果一样的
想一直关闭防火墙的话，可以把启动类型设为 “ 禁用 ”
1.4 方式四 ：cmd命令行进入 在 Windows XP 中，使用cmd命令行关闭防火墙
//1.查看防火墙状态： netsh firewall show state //2.关闭防火墙： net stop sharedaccess //3.再次查看防火墙状态： netsh firewall show state 若使防火墙彻底禁用，则可将启动状态设为禁用：
netsh firewall set opmode mode=disable 若使防火墙自动启动，则可将启动状态设为自动，防火墙立刻自动启动：
netsh firewall set opmode mode=enable 启动状态非禁用状态且防火墙被关闭下，开启防火墙：
//开启防火墙： net start sharedaccess 2、关闭宿主机的防火墙 以Win 10为例：
分别选择“专用网络设置”与“公用网络设置”项的“关闭Windows防火墙
二、设置XP和宿主机VMnet8的IP地址、网关和DNS 需Windows虚拟网卡VMnet8的IP地址 和 VMWare虚拟网卡VMnet8的子网IP地址 和 网卡设置文件的IPADDR在同一个局域网下；需Windows虚拟网卡VMnet8的网关和DNS地址 和 VMWare虚拟网卡的网关和DNS地址一致;需以上所有都在同一个网段下（IP地址的前三位，如192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/283214d129dcd909759f34d9a7e44bfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/955d33f89b994ada09106234aeecedec/" rel="bookmark">
			Docker基础操作-使用dockerfile、docker-compose操作镜像和容器(常用命令)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 目录
简介
一个开源的应用容器引擎
基本操作
镜像
容器
数据卷 Dokerfile自定义镜像：
Docker-Compose Docker搭建私有镜像仓库
可视化工具（Portainer）
常用命令
一个开源的应用容器引擎 Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？
Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像
Docker应用运行在容器中，使用沙箱机制，相互隔离
Docker如何解决开发、测试、生产环境有差异的问题？
Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行
Docker是一个快速交付应用、运行应用的技术，具备下列优势：
可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统
运行时利用沙箱机制形成隔离容器，各个应用互不干扰
启动、移除都可以通过一行命令完成，方便快捷
docker和虚拟机的差异：
docker是一个系统进程 体积小、启动速度快、性能好
虚拟机是操作系统中的操作系统 体积大、速度慢 性能一般
镜像：理解为软件的安装包
容器：通过镜像进行创建，运行起来就是容器，一个容器可以看作是一个进程 。一个镜像可以创建多个容器
docker架构（C/S）：
client ---&gt; 发送命令或者请求到Docker服务端 负责与主机中存在的守护进程通讯
server ---&gt; 主机中存在一个守护进程 负责管理docker中的对象
常见的对象：镜像、容器、数据卷、网络
获取镜像：1.自己构建
2.获取镜像仓库（Docker Registry）中的镜像
安装相关命令：
systemctl start docker # 启动docker服务
systemctl stop docker # 停止docker服务
systemctl restart docker # 重启docker服务
systemctl status docker #查看docker状态
docker info #查看配置
docker -v #查看版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/955d33f89b994ada09106234aeecedec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a933bd2d3fc6505d6e70264ffb52fe79/" rel="bookmark">
			Linux系统移植框架简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、系统移植简介 系统移植就是给开发板安装一个linux系统。需要从官方下载u-boot源码，linux内核源码，根文件系统的源码，对源码进行配置和编译，生成对应的源码的镜像文件，将镜像文件部署到开发板中，使开发板可以启动linux系统。
系统移植分为开发阶段和产品阶段，以下简单介绍：
二、开发阶段系统移植 1. tf-a-stm32mp157a-fsmp1a-trusted.stm32 --&gt; tf-a(trusted firmware-ARM)的镜像文件，tf-a源码编译生成的镜像文件 --&gt; tf-a的镜像文件默认已经烧写到开发板中的EMMC或者TF卡 2. u-boot-stm32mp157a-fsmp1a-trusted.stm32 --&gt; u-boot(通用的引导程序)的镜像文件，u-boot源码编译生成的镜像文件 --&gt; u-boot的镜像文件默认已经烧写到开发板中的EMMC或者TF卡 关于tf-a和u-boot的镜像文件如何部署到EMMC或者TF卡中明天讲解u-boot移植时在进行讲解。 3. uImage ---&gt; linux内核的镜像文件 ---&gt; 使用tftp命令下载到内存中 4. stm32mp157a-fsmp1a.dtb ---&gt; linux内核的设备树文件 ---&gt; 使用tftp命令下载到内存中 5. rootfs ---&gt; 根文件系统 ---&gt; 使用nfs服务通过网络从ubuntu中挂载根文件系统 三、产品阶段系统移植 1. tf-a-stm32mp157a-fsmp1a-trusted.stm32 --&gt; tf-a(trusted firmware-ARM)的镜像文件，tf-a源码编译生成的镜像文件 --&gt; tf-a的镜像文件默认已经烧写到开发板中的EMMC或者TF卡 2. u-boot-stm32mp157a-fsmp1a-trusted.stm32 --&gt; u-boot(通用的引导程序)的镜像文件，u-boot源码编译生成的镜像文件 --&gt; u-boot的镜像文件默认已经烧写到开发板中的EMMC或者TF卡 关于tf-a和u-boot的镜像文件如何部署到EMMC或者TF卡中明天讲解u-boot移植时在进行讲解。 3. uImage ---&gt; linux内核的镜像文件 ---&gt; 部署到开发板中的EMMC或者TF卡 4. stm32mp157a-fsmp1a.dtb ---&gt; linux内核的设备树文件 ---&gt; 部署到开发板中的EMMC或者TF卡 5. ramdisk.img ---&gt; 根文件系统的镜像文件，通过使用工具将rootfs根文件系统打包压缩生成。 ---&gt; 部署到开发板中的EMMC或者TF卡 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1ca20e9b660fb02a57ef6ba32e1f804/" rel="bookmark">
			mnist for android
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在安卓app上运行手写数字图片识别（MNIST）（修改中） 代码请看链接(github：https://github.com/sunkekek/mnistForAndroid.git) 保存pytorch模型 新建一个安卓项目 在安卓项目中引入mnist模型 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/256efa403251011f98f6a4296610f2ca/" rel="bookmark">
			Linux中如何测试端口是否正常？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux系统中，测试端口通不通是非常常见的情况之一，比如我们进行网络调试的时候就需要测试验证对应的端口是否正常，那么Linux中测试端口通不通的方法是什么?以下是详细内容介绍。
1、使用telnet命令
telnet命令是一个网络工具，可以用于测试远程主机的端口是否开放。它通过尝试与指定的主机和端口建立TCP连接来测试端口。
以下是使用telnet命令测试端口的步骤：
telnet
其中，是远程主机的IP地址或域名，是要测试的端口号。
2、使用nc命令
nc命令是一个功能强大的网络工具，可以用于创建、监听、扫描和传输网路连接。它也可以用于测试端口的连通性。
以下是使用nc命令测试端口的步骤：
nc -zv
其中-z表示在扫描完成时关闭连接，-v表示显示详细的输出信息。和的含义与上述相同。
3、使用ping命令
虽然ping命令主要用于测试网络连接，但也可以用于测试端口连通性。ping命令默认使用ICMP协议进行网络连接测试，但你可以使用端口重定向的方式，将ICMP数据包重定向到指定的端口，从而测试端口的连通性。
以下是使用ping命令测试端口的步骤：
ping -c 1 -p
其中，-c表示发送的ping数据包数量，-p表示将ICMP数据包重定向到指定的端口。是要测试的端口号，是远程主机的IP地址或域名。
4、使用wget命令
wget命令是一个Linux下的下载工具，但它也可以用于测试端口的连通性。wget命令可以下载指定URL的文件，如果指定的URL是端口开放的，则可以下载成功。因此，我们可以利用这个特性来测试端口的连通性。
以下是使用wget命令测试端口的步骤：
wget -S
其中，-S表示显示HTTP状态信息。是要测试的端口开放的URL。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca4893abebe90d3076670cc434351065/" rel="bookmark">
			PythonWeb开发项目完整案例（详细教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 PythonWeb开发是使用Python语言进行Web应用程序开发的过程。Python是一种简洁、易读且功能强大的编程语言，因此在Web开发领域广受欢迎。
文章目录 前言一、PythonWeb开发简介二、开发准备工作三、开发步骤四、开发案例1、使用Flask框架创建一个简单的Web应用程序2、使用Django框架创建一个简单的待办事项应用程序3、使用Flask框架创建一个简单的博客应用程序4、使用Django框架创建一个简单的电影评分应用程序 总结关于Python学习指南👉Python所有方向的学习路线👈👉Python学习视频600合集👈 温馨提示：篇幅有限，已打包文件夹，获取方式：文末自取👉Python70个实战练手案例&amp;源码👈👉Python大厂面试资料👈👉Python副业兼职路线&amp;方法👈 一、PythonWeb开发简介 PythonWeb开发可以涵盖多个方面，包括服务器端开发、数据库管理、前端设计和API开发等。在服务器端开发中，常用的Python Web框架有Django、Flask和Bottle等。这些框架提供了一套工具和结构，使得开发者能够更高效地构建Web应用程序。
在PythonWeb开发中，数据库管理也是一个重要的方面。Python提供了多种数据库连接库，如SQLAlchemy和psycopg2，可以轻松地与主流数据库（如MySQL、PostgreSQL和SQLite）进行交互。
另外，前端设计也是PythonWeb开发中的一个关键部分。Python提供了一些优秀的模板引擎，如Jinja2和Django模板，用于生成动态的HTML页面。
最后，API开发是现代Web应用程序中常见的需求之一。Python提供了一些库，如Flask-RESTful和Django REST framework，用于构建RESTful API。
总结来说，PythonWeb开发是使用Python语言构建Web应用程序的过程。通过选择合适的框架、数据库管理工具、前端设计和API开发库，开发者可以高效地构建出功能强大的Web应用程序。
二、开发准备工作 安装Python：首先，确保你的计算机上已经安装了Python。你可以从Python官方网站（https://www.python.org/）下载并安装最新版本的Python。安装虚拟环境：为了隔离不同项目的依赖关系，建议在项目中使用虚拟环境。你可以使用 venv 模块创建和管理虚拟环境。在命令行中执行以下命令： python -m venv myenv 这将在当前目录下创建一个名为 myenv 的虚拟环境。
3.激活虚拟环境：在Windows系统中，执行以下命令激活虚拟环境：
myenv\Scripts\activate 在Mac和Linux系统中，执行以下命令激活虚拟环境：
source myenv/bin/activate 三、开发步骤 选择Web框架：根据你的需求和偏好选择一个适合的Python Web框架，如Django、Flask或Bottle等。创建项目：在命令行中进入你想要创建项目的目录，并执行以下命令： django-admin startproject myproject 这将创建一个名为 myproject 的Django项目。
3. 定义数据模型：在项目中，你可以使用框架提供的ORM（对象关系映射）工具来定义数据模型。通过定义模型类和字段，你可以创建数据库表和关系。
4. 编写视图函数：视图函数负责处理请求并返回响应。你可以在项目中的视图文件中编写自己的视图函数，处理URL路由和业务逻辑。
5. 设计URL路由：URL路由将请求映射到相应的视图函数。在项目中的URL配置文件中，你可以定义URL路由规则。
6. 创建HTML模板：HTML模板用于生成动态的页面内容。你可以在项目中的模板文件中编写HTML和模板标签，以便在视图函数中渲染数据。
7. 运行开发服务器：在命令行中执行以下命令来启动开发服务器：
python manage.py runserver 这将在本地启动一个开发服务器，监听默认端口8000。你可以在浏览器中访问 http://localhost:8000来查看你的应用程序。
四、开发案例 1、使用Flask框架创建一个简单的Web应用程序 from flask import Flask app = Flask(__name__) @app.route('/') def hello(): return 'Hello, Flask!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca4893abebe90d3076670cc434351065/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3dcb982ad58302902b47bde4f2880ec/" rel="bookmark">
			Redis - php通过ssh方式连接到redis服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.应用场景
主要用于使用php通过ssh方式连接到redis服务器，进行一些操作. 2.学习/操作
1.文档阅读 chatgpt
&amp; 其他资料
SSH - 学习与实践探究_ssh应用场景
2.整理输出 2.1 是什么 TBD
2.2 为什么需要「应用场景」 TBD
2.3 什么时候出现「历史发展」 TBD
2.4 怎么实践 TBD
php 通过ssh方式连接到redis服务器 要通过 SSH 方式连接到 Redis 服务器，可以使用 PHP 的 ssh2 扩展和 Redis 扩展。
首先，需要安装 ssh2 扩展和 Redis 扩展。可以使用以下命令安装：
sudo apt-get install libssh2-1-dev sudo pecl install ssh2 redis 安装完成后，在 PHP 中加载这两个扩展：
extension=ssh2.so extension=redis.so 然后，可以使用以下 PHP 代码连接到 Redis 服务器：
&lt;?php // SSH 连接参数 $ssh_host = 'ssh_host'; $ssh_port = 22; $ssh_user = 'ssh_user'; $ssh_pass = 'ssh_pass'; // Redis 连接参数 $redis_host = '127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3dcb982ad58302902b47bde4f2880ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e64842df4f9e47ecb26bef3201c904b/" rel="bookmark">
			RPA是什么?怎么成为RPA高手？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RPA（机器人流程自动化）是一种新型的自动化生产工具，可以在各种行业和场景中实现高效、精准的自动化流程。近年来，随着企业对生产效率和成本控制的需求不断提高，RPA的应用逐渐成为企业关注的焦点。不少大学生也在积极关注和学习RPA技术，以增加自己的职业竞争力和实践经验。那么，学习RPA难易程度如何？作为一名在校大学生，学习RPA是否可行？
首先，学习RPA需要一定的计算机基础知识。RPA是基于软件机器人技术的自动化生产工具，因此需要学习者具备一定的编程和计算机基础知识。例如，了解一些常用的编程语言如JavaScript、Python等，以及了解一些常用的开发工具和库，都是学习RPA的必要条件。但是，对于有一定计算机基础的大学生来说，这些基础知识并不难掌握。
其次，学习RPA需要一定的学习资源和时间。学习RPA需要投入一定的时间和精力，需要系统的教程和实战经验来帮助学习者掌握技能。幸运的是，现在有很多在线教育平台和社区提供了丰富的RPA学习资源，如视频教程、在线课程、论坛交流等，可以帮助学习者快速入门和提高技能水平。同时，还可以通过参加线下培训课程或加入相关社群来与专业人士交流学习心得和经验。
再次，学习RPA需要有耐心和实践精神。学习RPA需要耐心和实践精神，尤其对于初学者来说，需要花费大量的时间和精力来理解概念和掌握技能。同时，实际应用中也会遇到各种各样的问题和挑战，需要学习者不断尝试和调整，逐步完善自动化流程。只有在耐心和实践的基础上，才能逐渐掌握RPA技术并实现自己的应用目标。
最后，学习RPA需要有明确的目标和计划。学习RPA需要有明确的目标和计划，例如了解RPA的应用场景、学习时间安排、实践项目等。通过明确的目标和计划，可以更好地掌握学习进度和提高学习效率。同时，还可以通过参加相关竞赛、实践项目等方式来检验自己的学习成果和实践能力。
综上所述，学习RPA并不难，只要具备一定的计算机基础知识、掌握正确的学习方法和拥有实践精神与明确的目标与计划就可以成功入门RPA。对于在校大学生来说，学习RPA不仅可以提高自己的职业竞争力还可以通过实践项目等方式锻炼自己的实践能力这对其未来的工作和发展都非常有益。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff0e72b12d4ff7d5cd4fde9ce624d2ed/" rel="bookmark">
			谷歌浏览器ie兼容模式怎么设置在哪里?google怎么设置兼容模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		google浏览器，它的应用功能也是比较完善的。最近就有用户问小编，使用谷歌浏览器遇到需要兼容模式才能进行打开的网页，下面就跟小编一起去看看google浏览器怎么设置兼容模式打开页面的吧。
工具/原料：
系统版本：Windows 10系统
品牌型号：戴尔Latitude 95
软件版本：google浏览器105.0.5148.2
方法/步骤：
google浏览器设置兼容模式教程：
1.点击打开谷歌浏览器，点击菜单，点击"设置”。
2.在设置中找到“默认浏览器设置”，点击打开“允许在Internet Explorer模式下重新加载网站”，点击重启;
3.重启谷歌浏览器之后，打开需要使用IE兼容的网页界面，在左侧菜单界面找到“更多工具”，选择“在Internet Explorer模式下重新加载的选项”，就可以用兼容模式打开当前啦。
拓展知识：google浏览器的更多使用方法
google浏览器下载安装后打不开网页怎么解决
google浏览器使用教程
总结：
1.打开谷歌浏览器，点击"设置”;
2.打开“允许在Internet Explorer模式下重新加载网站”，点击重启;
3.重启谷歌浏览器之后，选择“在Internet Explorer模式下重新加载的选项”，即可用兼容模式打开当前界面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35e95b34079738d6ae6369d61927d1b5/" rel="bookmark">
			c#复制文件夹下所有文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/// &lt;summary&gt;//From:www.13le.com
/// 复制文件夹下所有文件
/// &lt;/summary&gt;
/// &lt;param name="sourceFolder"&gt;原文件路径&lt;/param&gt;
/// &lt;param name="destFolder"&gt;目标文件路径&lt;/param&gt;
public void CopyFolder(string sourceFolder, string destFolder)
{
try
{
//如果目标路径不存在,则创建目标路径
if (!System.IO.Directory.Exists(destFolder))
{
System.IO.Directory.CreateDirectory(destFolder);
}
//得到原文件根目录下的所有文件
string[] files = System.IO.Directory.GetFiles(sourceFolder);
foreach (string file in files)
{
string name = System.IO.Path.GetFileName(file);
string dest = System.IO.Path.Combine(destFolder, name);
System.IO.File.Copy(file, dest);//复制文件
}
//得到原文件根目录下的所有文件夹
string[] folders = System.IO.Directory.GetDirectories(sourceFolder);
foreach (string folder in folders)
{
string name = System.IO.Path.GetFileName(folder);
string dest = System.IO.Path.Combine(destFolder, name);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35e95b34079738d6ae6369d61927d1b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22c1803e9dafd2e49e121468ab3b6392/" rel="bookmark">
			Win11磁盘分区后在恢复之前分区的方法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑磁盘分区对于新购买的电脑来说，是整理电脑第一步要做的事情，大家一般都会根据自己的需要把磁盘划分为C盘、D盘、E盘等等方面文件的管理，今天小编给大家介绍一下Win11操作系统下，如何进行分区，如何恢复之前的分区，希望对大家给电脑分区提供一些帮助！
一、合并了分区
1、在桌面上找到“此电脑”，右键它，点击“管理”。
2、接着在左边栏找到并打开“磁盘管理”。
3、打开后，我们找到被合并的分区，右键它。
4、在右键菜单里选择“压缩卷”。
5、然后选择被合并的分区空间量，再点击“压缩”。
6、压缩完成后，右键新增的可用空间，选择“新建简单卷”。
7、然后选择分区大小，并持续点击“下一页”。（其余设置保持默认）
8、最后点击“完成”就可以恢复之前的分区了。
二、新增了分区
1、如果是新增了不需要的分区，那么只要右键该分区。
2、接着点击“删除卷”，就能将它删除为可用空间了。
3、删除后，右键旁边的磁盘，点击“扩展卷”。
4、最后选择空间量并连续点击“下一页”就可以合并回分区了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb3033411c541ceaf7bf136e8316b223/" rel="bookmark">
			MySQL 2 环境搭建（MySQL5.7.43和8.0.34的下载；8.0.34的安装、配置教程 ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
MySQL的下载、8.0.34的安装及配置 1 MySQL版本介绍 2 MySQL 下载
1. 下载地址
2. 打开官网，点击DOWNLOADS
​编辑
3. 点击 MySQL Community Server
4. 在General Availability(GA) Releases中选择适合的版本
5.下载8.0.34和5.7.43版本
3 MySQL8.0 版本的安装
步骤1：双击下载的mysql-installer-community-8.0.34.0.msi文件，打开安装向导。
步骤2：打开“Choosing a Setup Type”（选择安装类型）窗口
步骤3：打开“Select Products” （选择产品）窗口
步骤4：配置MySQL安装目录 步骤5：执行安装
步骤6：安装完成后在“Status”（状态）列表下将显示“Complete”（安装完成），如图所示。 4 配置MySQL8.0
步骤1：在上一个小节的最后一步，单击“Next”（下一步）按钮，就可以进入产品配置窗口
步骤2：单击“Next”（下一步）按钮，进入MySQL服务器类型配置窗口，如图所示。端口号一般选择默认
步骤3：单击“Next”（下一步）按钮，打开设置授权方式窗口.
步骤4：单击“Next”（下一步）按钮，打开设置服务器root超级管理员的密码窗口
步骤5：单击“Next”（下一步）按钮，打开设置服务器名称窗口
步骤6：设置服务器文件权限
步骤7：应用配置界面，点击 Execute ，等待程序执行完毕
步骤8：完成配置，如图所示。单击“Finish”（完成）按钮，即可完成服务器的配置。 步骤9：如果还有其他产品需要配置，可以选择其他产品，然后继续配置。
步骤10：结束安装和配置。
5 验证是否安装成功
1）命令提示符cmd窗口验证
1、在电脑中找到安装好的MySQL的bin文件目录
2、在地址栏输入cmd后敲击回车
3、在命令提示符中输入 登录MySQL：
4、输入 status 命令可以查看 MySQL的更多版本信息版本信息​编辑
2）MySQL控制台验证
可在“开始”菜单栏找到并打开 MySQL 8.0 Command Line Client - Unicode 程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb3033411c541ceaf7bf136e8316b223/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/786648ca6cbfcd2e1d722cbeaaa92604/" rel="bookmark">
			torch训练gpu利用率不高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPU的显存占用和算力利用直接影响模型的训练速度
显存一直占用，但是显卡使用率大多数情况为0
GPU利用率低问题
1.提高线程数
2.打开pin_memory
# 在pytorch 加载数据时提高线程数，打开pin_memory torch.utils.data.DataLoader(image_datasets[x], batch_size=batch_size, shuffle=True, num_workers=8, pin_memory=True) 3.数据预处理占用比较久
mmdetection中yolov3的数据预处理
# dict( # type='Expand', # mean=img_norm_cfg['mean'], # to_rgb=img_norm_cfg['to_rgb'], # ratio_range=(1, 2)), # dict( # type='MinIoURandomCrop', # min_ious=(0.4, 0.5, 0.6, 0.7, 0.8, 0.9), # min_crop_size=0.3), 这部分注释掉会比较快
暂时不知道如何处理
参考链接：
模型训练 GPU利用率低，占用低怎么破_vmare gpu使用低_Dennis-Ning的博客-CSDN博客
Images normalization using too much cpu during inference · Issue #4488 · open-mmlab/mmdetection · GitHub
yolov5训练加速--一个可能忽视的细节（mmdetection也一样），为什么显卡使用率老是为0？_kv1830的博客-CSDN博客
深度学习训练时GPU利用率忽高忽低如何解决？ - 知乎 (zhihu.com)
【深度学习】踩坑日记：模型训练速度过慢，GPU利用率低_模型跑的慢的原因-CSDN博客
深度强化学习遇到问题：模型训练速度过慢、GPU利用率较低，CPU利用率很低问题总结与分析。 - 知乎 (zhihu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/786648ca6cbfcd2e1d722cbeaaa92604/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/665836c0b1e92bbea71d1e1c500a95af/" rel="bookmark">
			LaTeX 调整行距、列宽，以及表格的整体大小和字体大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认表格 表格行距 默认行距1
\begin{table}[h] \renewcommand{\arraystretch}{1.5} 表格列宽 默认列宽6pt
\begin{table}[h] \setlength{\tabcolsep}{3pt} 表格大小 \usepackage{graphicx} \scalebox{0.8}{ \begin{tabular}{lll} ...... } 下面分别是scalebox{0.8}、scalebox{1.0}和scalebox{1.2}。
或者使用固定值：
\resizebox{8cm}{!}{ \begin{tabular}{lll} ...... } 其中resizebox{}{}{}参数分别是宽、高（!为保持原宽高比）和实际内容。
字体大小 直接在表格环境里使用以下命令：
\tiny
\scriptsize
\footnotesize
\small
\normalsize
\large
\Large
\LARGE
\huge
\Huge
或者仅改变一些字的大小：
{\small Xovee Xu} 一个在线例子 https://www.overleaf.com/read/kqysmfdgvqzh
什么是Overleaf？ 一个超炫的 LaTeX 在线编译工具，想使用的可以用下我的邀请链接：https://www.overleaf.com?r=969b656f&amp;rm=d&amp;rs=b
————————————————
版权声明：本文为CSDN博主「Xovee」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/xovee/article/details/126026878
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac06daf5a6d490fbf82262205b2f17ed/" rel="bookmark">
			ModuleNotFoundError: No module named ‘supervision‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境
anaconda3python 3.8pytorch 2.0.0 supervision是一个cv图像绘制检测，或者计算区域中有多少个检测
官方网站：https://supervision.roboflow.com/
目前要求python版本在3.11~3.8之间
不需要图形界面，使用安装指令
pip install supervision 安装完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c51c4cec939fd6e372a9a741ddb2b1b/" rel="bookmark">
			java agent部署到tomcat上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要将 Java Agent 部署到 Tomcat 上，您可以按照以下步骤操作：
编写 Java Agent
首先，您需要编写您的 Java Agent 代码。Java Agent 是一个 Java 应用程序，它可以通过 Java Instrumentation API 来修改或监视正在运行的 Java 应用程序的字节码。确保您的 Java Agent 代码已经完成并可以单独运行。
将 Java Agent 打包成 Jar 文件
将您的 Java Agent 代码打包成一个 Jar 文件，其中包含了代理程序的实现和 Manifest 文件，以指定代理程序的入口。
在 Tomcat 的启动脚本中配置 Java Agent
要在 Tomcat 启动时加载 Java Agent，您需要在 Tomcat 启动脚本中配置 Java Agent。具体的操作步骤会根据您使用的操作系统和启动脚本有所不同。
Linux/Unix 上的 Catalina.sh：
在 catalina.sh 启动脚本中添加以下行，将 -javaagent 参数指向您的 Java Agent Jar 文件路径：
bash
export CATALINA_OPTS="$CATALINA_OPTS -javaagent:/path/to/your-agent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c51c4cec939fd6e372a9a741ddb2b1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b7830bd35d917389dec5656b4613dc/" rel="bookmark">
			百度 RT-DETR 算法原理解析 | 超越YOLO的目标检测新高度？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0. 前言1. RT-DETR结构设计1.1 主干网络1.2 颈部网络1.3 数据增强和训练策略 2. Query Selection 和 Decoder3. 实验结果3.1 设置3.2 与SOTA的比较3.3 关于混合编码器的消融研究3.4 关于IoU感知的查询选择的消融研究3.5 关于解码器的消融研究 总结参考文献 0. 前言 论文地址：https://arxiv.org/abs/2304.08069
代码地址：https://github.com/PaddlePaddle/PaddleDetection
中文翻译：https://blog.csdn.net/weixin_43694096/article/details/131353118
这篇博文将介绍百度的RT-DETR，首先让我们来看一下RT-DETR的论文标题，它声称“在实时目标检测领域打败YOLO”。尽管从数据的角度来看，RT-DETR似乎确实在某些方面超越了YOLO，但与经过时间考验的YOLO相比，仍有许多需要进一步研究和探索的地方。当然，在当前Transformer技术如此火热的今天，RT-DETR绝对是是一个非常引人注目的方向。接下来，我们将深入探讨RT-DETR。
与最新的YOLOv8算法相比，RT-DETR在训练时间方面要求更少，大约只需要进行 75 75 75 到 80 80 80 轮训练（而YOLOv8通常需要进行 300 300 300 到 400 400 400 轮训练）。此外，RT-DETR对数据增强的依赖较小。在相同的测试条件下，RT-DETR表现更出色，具有更好的性能和平衡，而且速度也与YOLO相当。
虽然YOLO检测器在目标检测中表现出色，但它面临一个重要问题，就是需要使用NMS（非极大值抑制）来处理多个重叠的检测框，这会导致速度延迟并且难以进行有效的优化。
为了克服这个问题，研究人员将目光转向了DETR(DEtection TRansformer)，这是一种基于Transformer架构的端到端目标检测器。与YOLO不同，DETR无需NMS后处理，它可以直接在网络中完成整个目标检测过程。
然而，虽然DETR在消除NMS的需求方面具有优势，但与YOLO系列检测器相比，它的处理速度明显较慢。这意味着尽管不需要NMS，但在速度方面并没有表现出明显的优势。因此，这个问题促使研究人员寻找一种方法，设计一个实时的端到端目标检测器，以克服NMS对速度的延迟影响。
由此，百度正式推出了——RT-DETR (Real-Time DEtection TRansformer) ，一种基于 DETR 架构的实时端到端检测器，其在速度和精度上取得了 SOTA 性能。
每次提到DETR，我们不得不说到NMS，NMS是目标检测领域的一项重要后处理技术，旨在解决检测器生成的存在重叠的多个检测框的问题。该技术的核心包括两个关键超参数：置信度阈值和IoU（交并比）阈值。
首先，NMS会将置信度低于设定置信度阈值的检测框直接过滤掉，即将那些置信度不高的框排除。接着，对于那些交并比(IoU)大于设定IoU阈值的检测框，NMS会保留其中置信度较高的框，而将置信度较低的框排除。这一过程将不断迭代执行，直到对所有目标类别的检测框都进行了处理。
NMS算法的执行时间主要受两个因素影响，即预测框的数量和上述两个阈值的设定。为了详细研究这一影响，作者使用了YOLOv5（基于锚点的方法）和YOLOv8（无锚点方法）进行了实验，考察了不同置信度阈值下保留的检测框数量，以及在不同超参数组合下检测器在COCO验证集上的性能和NMS的执行时间。
实验结果表明，NMS不仅会减慢检测器的推理速度，还需要仔细选择合适的超参数才能实现最佳性能。这一实验结果强调了设计实时端到端目标检测器的重要性，以克服NMS引入的性能瓶颈和不足之处。
为了验证这一观点，我们利用YOLOv5（基于锚点）和YOLOv8（无锚点）进行实验。我们首先统计在相同输入图像下，通过不同的分数阈值对输出框进行过滤后剩余的预测框数量。我们从0.001到0.25之间随机选择一些分数作为阈值，统计两个检测器的剩余预测框并绘制成直方图，直观地反映了NMS对其超参数的敏感性，如图2所示。
此外，我们以YOLOv8为例，评估了该模型在COCO val2017数据集上的准确率，并在不同的NMS超参数下测试了NMS操作的执行时间。需要注意的是，我们在实验中采用的NMS后处理操作是指TensorRT efficientNMSPlugin，其中包含多个CUDA内核，包括EfficientNMSFilter、RadixSort、EfficientNMS等，我们只报告EfficientNMS内核的执行时间。我们在T4 GPU上进行速度测试，上述实验中的输入图像和预处理保持一致。我们使用的超参数及相应结果如表1所示。
1. RT-DETR结构设计 接下来，我们来介绍一下RT-DETR的结构。从结构上来看，RT-DETR可以分为三部分：主干网络、颈部网络以及头部网络。下面分别来说一下这三部分。
1.1 主干网络 对于 backbone 部分，采用了经典的 ResNet 和可缩放的 HGNetv2 两种，两种 backbone 各训练了两个版本 ，以 HGNetv2 为 backbone 的 RT-DETR 包括 L 和 X 版本，以 ResNet 为 backbone 的 RT-DETR 则包括 RT-DETR-R50 和 RT-DETR-R101 。 RT-DETR-R50 / 101 做主干是方便和现有的DETR变体进行对比，而 RT-DETR-HGNet-L / X 则用来和现有的实时检测器进行对比，值得注意的是，HGNetv2是由百度自家研发的主干结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08b7830bd35d917389dec5656b4613dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0249f5d3c6a92139fe0a5a3ae6954c16/" rel="bookmark">
			ubuntu mmdetection配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mmdetection配置最重要的是版本匹配，特别是cuda，torch与mmcv-full
本项目以mmdetection v2.28.2为例介绍
1.查看显卡算力 因为gpu的算力需要与Pytorch依赖的CUDA算力匹配，低版本GPU可在相对高的CUDA版本下运行，相反则不行
算力不匹配运行torch训练会报如下错误：
CUDA error: no kernel image is available for execution on the device torch和cuda适配信息参考链接
我们用的显卡是A40和4080，其中4080算力8.9，A40算力8.6
2. cuda安装 根据显卡算力，cuda选择用11.6版本
下载链接
添加权限
chmod 700 cuda_11.6.0_510.39.01_linux.run 安装
sh chmod 700 cuda_11.6.0_510.39.01_linux.run 注意要将driver取消，即按空格显示不执行即可
3.安装对应版本的torch1.13.0 参考链接
pip install torch==1.13.0+cu116 torchvision==0.14.0+cu116 torchaudio==0.13.0 --extra-index-url https://download.pytorch.org/whl/cu116 ps：可以通过如下命令查看torch与cuda算力是否匹配
&gt;&gt;&gt; import torch torch.cuda.get_arch_list() &gt;&gt;&gt; torch.cuda.get_arch_list() ['sm_37', 'sm_50', 'sm_60', 'sm_70', 'sm_75', 'sm_80', 'sm_86'] &gt;&gt;&gt; torch.__version__ '1.13.0+cu116' torch1.13.0+cu116可支持sm_86，在A40和4080上都可以运行
4.下载安装mmdetection 参考链接
git clone https://github.com/open-mmlab/mmdetection.git cd mmdetection pip install -v -e .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0249f5d3c6a92139fe0a5a3ae6954c16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdfedcbe272623ecfcfffb76c7112562/" rel="bookmark">
			VS Code #include ＜bits/stdc&#43;&#43;.h＞ 错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示： 正常情况你需要使用 MinGW g++ 编译器才可以使用 bits/stdc++.h
在其他文章中有一种解决办法是复制 bits/stdc++.h （需要新建bits文件夹）到 MSVC 编译器的 include 文件夹下，然后可以识别了，而且在 MSVC 中也能使用 bits/stdc++.h，但由于其改动了 MSVC 的库，所以不推荐使用此方法。
实际上这个问题原因是 bits/stdc++.h 是由 MinGW 提供的，而 VS Code 的 “C/C++ 扩展” 默认使用 MSVC 编译器和 windows-msvc-x64 intellisense，MSVC 根本没有提供 bits/stdc++.h
所以只需把编译器指定为 MinGW 就能解决问题。
具体操作： 1. 点击 VS Code 右下角的 "Win32"
2. 编辑配置(UI)
3. 编译器路径修改为你 mingw g++ 的路径，IntelliSense mode 修改为 windows-gcc-x64
OK
为了更好的辨识性，我将这个配置命名为 MinGW-g++，上述修改也可以在 C/C++ 插件的 .json 配置文件中操作。
题外话： 由于其便利性 bits/stdc++.h 在算法竞赛中经常被使用，被称为万能头文件，但它也有些缺点：
1. stdc++.h（以及 bits 下的所有文件）不属于 C++ 标准（所以 MSVC 里没有这东西），需要特定编译器编译，实际开发中应该避免 compiler-specific 的代码，也就是需要特定编译器才能过编译的代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdfedcbe272623ecfcfffb76c7112562/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d75173ee059f6ee88d7f57a42ec7591/" rel="bookmark">
			cshrc配置和GVIM配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、cd进入目录后显示目录中文件（.cshrc）
alias cd 'chdir \!*; set prompt="`hostname`:$cwd&gt;"; ls '
chdir：相当于正常的linux的cd命令
prompt：命令提示符
pwd 是linux 自带的命令. 全称: pathname of the current working directory. cwd不是系统自带的命令, 但是属于 系统的属性 . 全称: current working directory .
或者：用下面这个（上面那个有些情况用不了）
alias cd 'cd \!*; set prompt="hello:${cwd}[\~]--&gt;"; ls '
bash:(2023-10-7)
实际使用：（PS1:bash里面的提示符变量）
export PS1=“[\u:\w]\$”
cd() { builtin cd "$@" &amp;&amp; ls; }
参考链接：
Linux Sheel中cd dir后直接显示dir下的所有文件_linux下cd后直接显示目录_TimeAmber的博客-CSDN博客
bashrc:
如果是在bash的环境，在.bashrc中加入：
alias cd="cd $1; ll "
Note the leading space (" ") in the bash version, it prevents the result to be alias expanded again.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d75173ee059f6ee88d7f57a42ec7591/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c56a64633cdef1241c473cb892efed8/" rel="bookmark">
			【Matlab】用窗口形式选择图片，自动粘贴到word当中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 编码逻辑：
1、新建图片变量
2、设置图窗尺寸
3、窗口选图片文件
4、将图片呈现到figure画布上
5、将图片发送到剪切板
6、粘贴图片到word中
hFigure = figure(1); set(hFigure,'position',[100 50 150 150],'visible','off');% 设置一个figure，图片是300*300的 hAxes = axes('parent',hFigure); set(hAxes,'units','pixels','position',[1 1 150 150]); [Pic,selpath,Indx] = uigetfile('选择图片');% 窗口选图片,path:文件路径；Indx：文件类型 imshow(Pic,'parent',hAxes);% 呈现图片到figure上 print(hFigure,'-dbitmap'); % 将图片发到剪切板 Selection.Range.PasteSpecial;% 粘贴图片，设置图片属性为浮于文字上方(若是嵌入式粘贴：Paste) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7d079a263e1240a12aff978ec611caf/" rel="bookmark">
			java中对象和JSON格式的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java中对象和JSON格式的转换 JSON JSON(javaScript Object Notation)是一种轻量级的数据交换格式，具有良好的可读性和可拓展性。
它采用键值对的方式表示数据，支持基本数据类型和复合数据类型。可用于描述结构化数据和非结构化数据。
结构 对象结构（无序）： 无序的对象结构在不同语言中称法不同
对象（object）：一个对象包含一系列非排序的键／值对，一个对象以 {开始，并以 }结束。每个键／值对之间使用 :分区。多个键值对之间通过 , 分割。
数组结构（有序）： 有序的的数组结构。将数组作为有序数组进行转换JSON，就可以得到有序的JSON数组结构
数组：一个数组包含一系列排序的键／值对，一个对象以 [开始，并以 ]结束。每个键／值对之间使用 :分区。多个键值对之间通过 , 分割。
tips: 需要注意的是JSON 的键是一个 String 类型的字符串。值（value）：可以是双引号括起来的字符串（string）、数值(number)、true、false、 null、对象（object）或者数组（array）。这些结构可以嵌套使用。JSON格式不支持注释，且字符串必须使用双引号""，而不是 单引号。JSON格式可以使用一些转义字符 JSON在java中的使用 Java中并没有内置JSON的解析，因此使用JSON需要借助第三方类库。
java 中常见的解析 json 的第三方库(jar包)：
-JSON官方- GSON- FastJson- Jackson 2- hutool-json 每种方式生成和解析进行阐述 1.使用JSON官方提供的JSON 官方提供的JSON具有通用性，就是解析时有点费事。
maven依赖:
&lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;20180130&lt;/version&gt; &lt;/dependency&gt; 生成JSON对象
1.使用JSONObject添加对象
代码：
@Test public void Test3(){ //创建JSON对象 JSONObject jsonObject = new JSONObject(); Object obj = null; //像JSON对象中添加数据 jsonObject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7d079a263e1240a12aff978ec611caf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ec6083247e11f71f323515f26c37b0d/" rel="bookmark">
			Pycharm 2023 设置远程调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pycharm 版本 ： 2023.2.1
整体流程参考：https://blog.csdn.net/xuanhaolaile/article/details/128293254
首先确定远程服务器上已经安装好 requirements.txt 中所需的依赖包。
1、SSH Configurations 添加远程服务器
2、Python Interpreter 注意：设置 Python Interpreter 的同时，pycharm 会自动添加一个 Deployment ，所以不再需要单独去添加一个 Deployment 了。
Add Interpreter —&gt;On SSH
设置远程服务器
选择 System Intepreter，并设置 Sync folders
检查一下远程服务上的依赖包安装情况，确保之后项目能正常运行
3、Deployment 在设置 Python Interpreter 的时候，pycharm 自动添加了一个 Deployment ，找到 Deployment 设置项，可看到以 root@ipAddress 命名的Deployment 。
按照图示设置3个地方即可。这里重命名为 remote。
回到主界面，在 Tools —&gt;Deployment 菜单里可看到上传和下载的选项
设置过程中的注意事项 1、设置 SSH Configurations 时，要取消勾选 Visible only for this project 和 Parse config file ~/.ssh/config
2、设置 Deployment 时，要取消勾选 Visible only for this project 并设置编码为 utf-8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ec6083247e11f71f323515f26c37b0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb976e16335141e93d38c81a46487530/" rel="bookmark">
			srand()函数的简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		srand函数是C语言中的种子函数，它的更能是生成一个随机数，并将其作为接下来的随机数中使用的种子参数。它主要用于生成不完全相同的随机数列。在C语言中，srand函数主要通过使用指定参数来设置随机数生成的种子，从而将生成的随机数设置完全不同的序列。
srand函数是C语言中用于控制随机数生成器的核心函数，它的功能是为随机数的生成器设置一个种子，srand函数的内部原理是：从指定的参数中提取出一个随机数，并将该随机数作为随机数生成器的种子。这样一来，当一个随机数被生成的时候，就可以使用随机数生成器的种子来自动生成另外一个全新的随机数。
srand函数有两个参数，第一个参数指定种子，第二个参数是一个C函数，用于获得另一个随机数。
rand()是C语言中的随机数生成函数，定义在&lt;stdlib.h&gt;头文件中，返回0到RAND_MAX之间的整数。RAND_MAX通常是32767。要生成指定范围内的随机数，可以使用模运算符（%）。
例题：
题目描述
让计算机来想一个数，然后让用户来猜，用户每输入一个数，就告诉它是大了还是小了，直到用户猜中为止，在最后还要告诉用户它猜了多少次。
解题思路（循环条件是a和number不相等）
1、计算机随机想一个数，记在变量number里；
2、一个负责计次数的变量count初始化为0；
3、让用户输入一个数字a；
4、count递增（加一）；
5、判断a和number的大小关系，如果a大，就输出“大”；如果a小就输出“小”；
6、如果a和number是不相等的（无论大还是小），程序转回到第3步；
7、否则，程序输出“猜中”和次数，然后结束。
代码演示
#include &lt;stdio.h&gt; #include &lt;stdlibe.h&gt; #include &lt;time.h&gt; int main() { srand(time(0)); int number = rand()%100+1; int count = 0; int a = 0; printf("我已经想好了一个1到100之间的数。"); do { printf("谁猜这个1到100之间数："); scanf("%d",&amp;a); count ++; if(a&gt;number) { printf("你猜的数大了。\n"); } else if(a&lt;number) { printf("你猜的数小了。\n"); } } while(a!=number); printf("太好了，你用了%d次就猜到了答案。\n",count); return 0; } 注：srand(time(0))来使用当前时间使随机数发生器随机化，这样就可以保证两次运行时可以得到不同的随机数列，同时要求程序的两次运行时间间隔超过1s。
知识点
随机数：每次召唤rand()就得到一个随机的整数
%100：x%n的结果是[0,n-1]的一个整数
头文件&lt;time.h&gt;用于需要时间方面的函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aed5b42bcc0422e10f35c261b29f191f/" rel="bookmark">
			C# 正确实现IDisposable 释放非托管资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 实现IDisposable 接口主要目的是为了释放非托管资源，如果没有非托管资源一般不必实现此接口。
实现了IDisposable的类都可以使用using来释放资源，会自动调用Dispose()，如果忘了using或显式调用Dispose()，那么析构函数就是兜底的了，否则没必要执行析构函数，析构函数执行情况比较复杂，性能不好。
public class MyClass : IDisposable { private readonly HttpClient _httpClient; private volatile bool _disposed; //实现了IDisposable的类都可以使用using来释放资源，会自动调用Dispose()。 public void Dispose() { Dispose(true); //告知垃圾处理器，不必再调用此对象的析构方法: ~MyClass() //如果不加这句，执行析构方法有复生的可能性，导致回收性能不好。 GC.SuppressFinalize(this); } protected virtual void Dispose(bool disposing) { if(_disposed) return; if (disposing) { //释放一些继承了IDisposable 的托管资源。一般很少 } //释放托管资源 _httpClient?.Dispose(); _disposed = true; } //析构函数，正常情况下调用了Dispose(),就不需要再执行析构函数。 ~MyClass() { Dispose(false); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d2f238db25852ef562253bf0231b84d/" rel="bookmark">
			4位整数倒序输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 描述：
输入一个4位的正整数，输出它的倒序数。
输入：
无
输出：
无
输入样例1：
2000
1234
输出样例1：
0002
4321
解法：
#include &lt;stdio.h&gt; int main() { int a,b,c,d,g; scanf("%d",&amp;a); b=a%10; c=a%100/10; d=a/100%10; g=a/1000; printf("%d%d%d%d",b,c,d,g); return 0; } 代码中a%10表示a除以10的余数，%表示取余，/表示除号，&amp;表示取缔值。
运用循环解题：
#include&lt;stdio.h&gt; int main() { int x，y=0; printf("请输入一个整数:"); scanf("%d",&amp;x); while(x!=0) { y = y*10+x%10; x =x/10; } printf("%d",y); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/066bd88970858ce823d7c9cbf69290cb/" rel="bookmark">
			通过docker安装emqx（mqtt）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建所需目录 mkdir -p /opt/emqx/etc /opt/emqx/lib /opt/emqx/data /opt/emqx/log 预先拷贝文件 1、安装并运行emqx:latest
docker run -dit --name emqx -p 1883:1883 -p 8081:8081 -p 8083:8083 -p 8883:8883 -p 8084:8084 -p 18083:18083 emqx/emqx:latest 2、拷贝文件
docker cp emqx:/opt/emqx/etc /opt/emqx/ 3、关闭并移除emqx
docker stop emqx docker rm emqx 运行emqx并挂载文件 docker run -d \ --name emqx \ --restart=always \ -p 1883:1883 \ -p 8883:8883 \ -p 8083:8083 \ -p 8084:8084 \ -p 8081:8081 \ -p 18083:18083 \ -v /opt/emqx/:/opt/emqx/etc \ emqx/emqx:latest 默认账密为：admin/public
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/066bd88970858ce823d7c9cbf69290cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28043752d5859178d40069a020f7aeac/" rel="bookmark">
			Latex写作如何划钩与打叉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 概要实现`在这里插入代码片`效果 概要 我们经常在论文写作中需要划钩 “√” 与打叉 “×”，本文介绍在latex中的几种实现方式。
实现在这里插入代码片 \documentclass{article} \usepackage{bbding} %重要：首先在导言区调用bbding包 \begin{document} %然后在需要插入的地方用如下命令实现 \Checkmark %标准的勾 \XSolid %标准的叉 ---------------- \XSolidBrush ---------------- %加粗 \CheckmarkBold \XSolidBold \end{document} 原文链接：https://blog.csdn.net/sdu_hao/article/details/105179282
效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02f43360efa0247c2d4991fff6178004/" rel="bookmark">
			Docker概念|容器|镜像|命令详细（创建，删除，修改，添加）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker概念|容器|镜像|命令详细（创建，删除，修改，添加） 一，Docker简介二，Docker与虚拟机的区别三，容器核心技术四，Docker核心概念五 docker的安装5.1关闭防火墙,关闭文件防护5.2 安装依赖包5.3 设置阿里云镜像源5.4 安装Docker-CE并设置为开机自动启动5.5 查看docker信息5.6查看docker状态 六 Docker镜像操作6.1 搜索镜像6.2 获取镜像6.3 查看镜像6.3 查看镜像信息6.4 修改镜像名字和标签6.5 删除镜像6.6 镜像导出导入到本地6.7 批量删除所有镜像 七 Docker容器操作7.1 容器的创建7.2 查看容器状态7.3 启动容器7.4 停止容器7.5 创建并启动容器7.6 修改容器名称7.7 进入容器7.8 实现容器和宿主机之前的文件传输7.9 容器导出和导入7.10 删除容器其他命令 一，Docker简介 Docker是一个开源的应用容器引擎，基于go语言开发并遵循了apache2.0协议开源
是在Linux容器里运行应用的开源工具
是一种轻量级的”虚拟机“
Docker的容器技术可以在一台主机上轻松为任何应用创建一个轻量级的，可移植的，自给自足的容器。
二，Docker与虚拟机的区别 三，容器核心技术 docker本质就是宿主机的一个进程，docker是通过namespace（命名空间）实现资源隔离，通过cgroup实现资源限制，通过写时复制技术（copy-on-write）实现了高效的文件操作（类似虚拟机的磁盘比如分配500g并不是实际占用物理磁盘500g)。
四，Docker核心概念 ●镜像
Docker的镜像是创建容器的基础，类似虚拟机的快照，可以理解为一个面向 Docker容器引擎的只读模板。
通过镜像启动一个容器，一个镜像是一个可执行的包，其中包括运行应用程序所需要的所有内容包含代码，运行时间，库、环境变量、和配置文件。
Docker镜像也是一个压缩包，只是这个压缩包不只是可执行文件，环境部署脚本，它还包含了完整的操作系统。因为大部分的镜像都是基于某个操作系统来构建，所以很轻松的就可以构建本地和远端一样的环境，这也是Docker镜像的精髓。
●容器
Docker的容器是从镜像创建的运行实例，它可以被启动、停止和删除。所创建的每一个容器都是相互隔离、互不可见，以保证平台的安全性。
可以把容器看做是一个简易版的linux环境（包括root用户权限、镜像空间、用户空间和网络空间等）和运行在其中的应用程序。
●仓库
Docker仓库是用来集中保存镜像的地方，当创建了自己的镜像之后，可以使用push命令将它上传到公有仓库（Public)或者私有仓库(Private)。当下次要在另外一台机器上使用这个镜像时，只需从仓库获取。
Docker的镜像、容器、日志等内容全部都默认存储在/var/lib/docker
五 docker的安装 5.1关闭防火墙,关闭文件防护 systemctl stop firewalld setenforce 0 5.2 安装依赖包 yum install -y yum-utils device-mapper-persistent-data lvm2 yum-utils:提供了yum-config-manager 工具。device mapper: 是Linux内核中支持逻辑卷管理的通用设备映射机制，它为实现用于存储资源管理的块设备驱动提供了一个高度模块化的内核架构。device mapper存储驱动程序需要 device-mapper-persistent-data和 lvm2。 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02f43360efa0247c2d4991fff6178004/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f9dee9f632297f41c1f2403fff7e470/" rel="bookmark">
			Lumen/Laravel - 数据库读写分离原理 - 探究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.应用场景
主要用于学习与探究Lumen/Laravel的数据库读写分离原理。 2.学习/操作
1.文档阅读 chatgpt
&amp; 其他资料
数据库入门 | 数据库操作 | Laravel 8 中文文档
入门篇（一）：数据库连接配置和读写分离 | 数据库与 Eloquent 模型 | Laravel 入门到精通教程
2.整理输出 2.1 是什么 TBD
2.2 为什么需要「应用场景」 TBD
2.3 什么时候出现「历史发展」 TBD
2.4 怎么实践 TBD
先放截图
文字版以及代码实现/实践
tbd
后续补充
...
3.问题/补充
TBD
后续补充
...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29944f8eefaf851008801988b7abe160/" rel="bookmark">
			定向模糊测试aflgo中的能量调度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对应部分代码主要在
aflgo::afl-fuzz.c::4820
AFL 的一个核心思想是在模糊测试过程中动态地调整每个输入样本的 “power”，以便更有效地探索新的代码路径。功率在此上下文中用作一种权重，表示给定输入样本的变异应该尝试多少次。
传统的 AFL 通过比较直观的方式计算功率，但随着时间的推移，这种方法可能不是最优的。
“Adaptive Power Scheduling” (APS) 意味着使用更复杂、更智能的策略来决定如何为每个输入分配权重或功率。模拟退火是其中可能用于APS的一种策略。
double power_factor = 1.0; if (q-&gt;distance &gt; 0) { double normalized_d = q-&gt;distance; if (max_distance != min_distance) normalized_d = (q-&gt;distance - min_distance) / (max_distance - min_distance); if (normalized_d &gt;= 0) { double p = (1.0 - normalized_d) * (1.0 - T) + 0.5 * T; power_factor = pow(2.0, 2.0 * (double) log2(MAX_FACTOR) * (p - 0.5)); }// else WARNF ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29944f8eefaf851008801988b7abe160/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c8fcbef3888ff9fec675a9820ec23e0/" rel="bookmark">
			Go基础笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go Linux下安装Go开发包 首先找到Go官网https://golang.google.cn/dl/
对于386的是32位OS的，所以针对自己的OS选择合适的安装包
选择安装目录通过cd命令切换到自己安装的目录
[root@bogon ~]# cd /usr/local/ [root@bogon local]# ll total 0 drwxr-xr-x. 2 root root 6 Apr 11 2018 bin drwxr-xr-x. 2 root root 6 Apr 11 2018 etc drwxr-xr-x. 2 root root 6 Apr 11 2018 games drwxr-xr-x. 2 root root 6 Apr 11 2018 include drwxr-xr-x. 2 root root 6 Apr 11 2018 lib drwxr-xr-x. 2 root root 6 Apr 11 2018 lib64 drwxr-xr-x. 2 root root 6 Apr 11 2018 libexec drwxr-xr-x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c8fcbef3888ff9fec675a9820ec23e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62643ea980715421d08c68a481172224/" rel="bookmark">
			【Matlab】求阶跃响应的性能指标参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		明确控制系统的单位阶跃响应性能指标在时域主要有以下几个（参考《自动控制原理（非自动化版）--孟庆明主编》）：
延迟时间：单位阶跃响应曲线上升到稳态值的50%所需时间上升时间：单位阶跃响应曲线从稳态值的10%上升到90%所需要的时间峰值时间：单位阶跃响应曲线超过稳态值而达到第一个峰值所需要的时间调节时间：整个过渡过程所经历的时间，输出衰减到与稳态值偏差不大于稳态值的2%或5%所经历的时间（本文均选用2%误差带）超调量：响应过程中输出量超出稳态值的最大偏差，用它与稳态值比值的百分数表示振荡次数：单位阶跃响应曲线在0~调节时间内，穿越稳态值次数的一半（向下取整）稳态误差：时间趋于无穷时单位阶跃响应期望值与实际值之差 假设我们有一堆数据，只知道其中存在单位阶跃响应，但不知道起点和终点在哪里，首先需要做的是找出这一个数据段并截取下来，例如下图。
由图可见，这段数据有一个特征：开头段和末尾段收敛。默认开头段跟随指令开始阶跃，将末尾段“进入收敛区”的标准定义为该点数据与之后4个步长的数据之差小于0.02%，且该点之后的3个点都满足这个要求（加粗的具体数值可以根据data的实际情况调整）。
clear；clc data=[0;0.00483333333333333;0.0186683055555556;0.0405167920787037;0.0694085086899066;0.104398538880760;0.144573903698365;0.189059202767804;0.237021361240398;0.287673522615346;0.340278131701575;0.394149255474025;0.448654192280081;0.503214421816537;0.557305949576903;0.610459100115863;0.662257813546533;0.712338499231021;0.760388499699967;0.806144216495655;0.849388947928371;0.889950486717681;0.927698523208254;0.962541897350610;0.994425739965037;1.02332854100393;1.04925917963288;1.07225394800038;1.09237359759342;1.10970043411138;1.12433548386208;1.13639575181432;1.14601158865432;1.15332418150591;1.15848318040403;1.16164447016947;1.16296809503280;1.16261634120350;1.16075198058459;1.15753667699601;1.15312955459563;1.14768592667393;1.14135618164745;1.13428482188350;1.12660964995128;1.11846109600710;1.10996167927856;1.10122559600674;1.09235842573047;1.08345694744393;1.07460905691990;1.06589377635798;1.05738134748040;1.04913339924957;1.04120318151180;1.03363585607241;1.02646883696958;1.01973217203024;1.01344895815182;1.00763578315232;1.00230318745955;0.997456139362198;0.993094518013621;0.989213598858538;0.985804536636825;0.982854841602793;0.980348845077900;0.978268150925661;0.976592069995978;0.975298035029005;0.974361993933308;0.973758779757089;0.973462456052826;0.973446636693325;0.973684779529684;0.974150453588402;0.974817579785241;0.975660645387362;0.976654892682831;0.977776482518114;0.979002633540263;0.980311738131874;0.981683456154438;0.983098787720582;0.984540126298874;0.985991293517862;0.987437557079918;0.988865633221821;0.990263675169225;0.991621249027565;0.992929298534181;0.994180100066718;0.995367209262777;0.996485400556595;0.997530600881617;0.998499818724455;0.999391069647122;1.00020329932170;1.00093630504591;1.00159065663038;1.00216761746944;1.00266906652858;1.00309742190289;1.00345556652387;1.00374677651640;1.00397465263500;1.00414305513805;1.00425604239211;1.00431781343510;1.00433265466766;1.00430489078670;1.00423884002401;1.00413877370575;1.00400888010620;1.00385323253075;1.00367576152924;1.00348023111056;1.00327021880420;1.00304909939194;1.00282003211538;1.00258595114994;1.00234955912520;1.00211332346334;1.00187947530209;1.00165001076687;1.00142669435602;1.00121106420630;1.00100443900937;1.00080792635647;1.00062243229612;1.00044867189848;1.00028718063011;1.00013832635397;1.00000232178090;0.999879237211502;0.999769013419301;0.999671474539584;0.999586340840609;0.999513241267068;0.999451725658172;1.00423460988852;1.01802962608073;1.03984803101812;1.06871888684573;1.10369659794603;1.14386748967007;1.18835545755267;1.23632672175364;1.28699372666792;1.33961822997390;1.39351362888330;1.44804657406263;1.50263792366677;1.55676309120815;1.60995184163654;1.66178759007591;1.71190625721227;1.75999473440383;1.80578901024483;1.84907200861061;1.88967118619395;1.92745593526082;1.96233483485397;1.99425279100032;2.02318810367390;2.04914949537019;2.07217313319581;2.09231967340318;2.10967135433352;2.12432916080049;2.13641008007617;2.14604446685110;2.15337353185143;2.15854696622301;2.16172071134924;2.16305488146682;2.16271184429002;2.16085446285622;2.15764449996646;2.15324118491871;2.14779994071685;2.14147126858580;2.13439978542921;2.12672340882718;2.11857268328286;2.11007024068267;2.10133038732796;2.09245880942025;2.08355238852796;2.07469911832353;2.06597811374567;2.05745970370452;2.04920559849852;2.04126912324167;2.03369550880049;2.02652223200190;2.01977939718900;2.01349015156235;2.00767112714310;2.00233290262235;1.99748047881371;1.99311376189388;1.98922804909600;1.98581451200438;1.98286067308412;1.98035087155867;1.97826671521963;1.97658751521187;1.97529070128035;1.97435221538979;1.97374688203306;1.97344875392562;1.97343143214175;1.97366836008085;1.97413309095925;1.97479952880367;1.97564214317661;1.97663615809176;1.97775771577948;1.97898401613849;1.98029343286166;1.98166560735147;1.98308152164583;1.98452355165810;1.98597550209867;1.98742262448897;1.98885161970578;1.99025062650361;1.99160919745859;1.99291826375962;1.99417009024271;1.99535822202459;1.99647742404227;1.99752361474846;1.99849379514951;1.99938597430348;2.00019909232379;2.00093294185767;2.00158808893121;2.00216579397376;2.00266793375556;2.00309692489384;2.00345564950535;2.00374738350806;2.00397572800150;2.00414454408516;2.00425789140766;2.00431997067571;2.00433507029288;2.00430751724225;2.00424163227636;2.00414168943040;2.00401187983229;2.00385627974481;2.00367882274088;2.00348327588323;2.00327321975395;2.00305203215731;2.00282287530139;2.00258868624921;2.00235217041915;2.00211579790621;2.00188180239070;2.00165218239844;2.00142870467687;2.00121290945345;2.00100611734734;2.00080943771135;2.00062377818864;2.00044985527777;2.00028820570979;2.00013919845171;2.00000304716285;1.99987982294240;1.99976946721938;1.99967180464875;1.99958655589067;1.99951335016234;1.99945173746494;1.99940120040004;1.99936116550256;1.99933101402817;1.99931009214483;1.99929772048799;1.99929320304933;1.99929583537789;1.99930491208103;1.99931973362062;1.99933961240676;1.99936387819811;1.99939188282336;1.99942300424353;1.99945664997934;1.99949225993132;1.99952930862374;1.99956730690582;1.99960580314572;1.99964438395411;1.99968267447544;1.99972033828497;1.99975707693034]; cmd=[1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2;2]; le = length(data); h_start = cmd(1); flag_start = 0; count_steady = 0; index_steady = 0; index_overstart = 0; h_end = -1; %% 判是否收敛，确定稳态值 for i = 1:(le-7) convergence_flag = 0;% 是否收敛的标志 if (cmd(i) &gt; h_start) &amp;&amp; (flag_start == 0) index_overstart = i;% 记录阶跃开始的标签 flag_start = 1;% 第一次阶跃开始了 end % 判断末尾是否进入收敛区 if data(i) &gt; h_start difference = abs((data(i)-data(i+4))/data(i)); if difference &lt;= 0.0002% 该点稳定，疑似进入收敛区 k = 1; for j = i:(i+3) % 该点之后的3点能否都保持稳定 error(k) = abs((data(j)-data(j+4))/data(j)); k = k+1; end for k = 1:4 if error(k) &gt; 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62643ea980715421d08c68a481172224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00dc8a537653f7d0a60dbb6167416920/" rel="bookmark">
			nix包管理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nix包管理器
特点：
允许多版本存在，
nix语言配置，
解决Linux依赖包冲突问题
类似node.js的包管理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0a08264f70c1a104756d9acad03f21e/" rel="bookmark">
			SLAM从入门到精通（ROS和底盘Stm32的关系）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【 声明：版权所有，欢迎转载，请勿用于商业用途。 联系信箱：feixiaoxing @163.com】
学过Ros的同学，一般对subscribe、publish、话题、服务这些内容都比较熟悉。如果再熟悉一点的话，还会知道slam、move_base、moveit这些框架。再了解多一点的呢，会对框架里面的算法，比如和hector slam、gmapping、amcl、迪杰斯特拉、a*算法比较熟悉。但是，对机器人底盘的知识，尤其是Ros和stm32怎么通信的，很多人却是不算太了解的。
1、Ros和Stm32的物理连接 一般来说，Ros和Stm32会通过串口进行通信。就算两者通信的是usb，也会在stm32开发板上面通过芯片把usb信号转换成串口信号。
2、操作系统不同 通常Ros都是运行在linux系统之上的，如果需要界面的话，还会搭载一个ubuntu系统。而stm32开发板上面一般不会安装操作系统，就算有操作系统，也会是一个简单的rtos，比如开源的freertos之类的。在这个板子上面，会根据不同的运动类型，实现不同的控制算法。简单的运动控制算法用pid实现就可以。
3、报文协议 既然Ros和Stm32之间需要进行通信，那么不管是Ros读数据，还是Ros写数据，都需要按照一定的报文格式进行。通常会采用0x55 0xaa这样的报文头，还会有报文长度、报文内容、校验码，这些都是常规的报文协议格式。
4、Ros从底盘获取的数据 Ros系统从底盘获取的数据主要有这么几种。第一，里程计数据。这个数据一般是底盘根据轮速和底盘模型计算出来的。第二，imu数据。imu这类传感器，一般也是直接由底盘负责处理的。好一点的底盘程序，会直接融合里程计和imu的数据。第三，避障、电量、电机转速这些原始数据。电量比较好理解，比如机器人没电了，就可以直接发命令让机器人去自动充电。电机转速这些很多情况不一定需要，但是如果机器人需要做功能安全的话，是需要的。
5、Ros发送给底盘的命令数据 Ros发送给底盘的数据其实就比较简洁了，主要就是cmd_vel数据。这里面包含了x/y/z的线速度，还有围绕x/y/z的角速度。
6、底盘厂家提供的Ros包 很多时候，底盘厂家会直接提供一个Ros包给Robot开发厂家。这样Robot开发企业就可以专注在算法领域和业务领域，不用关于底盘这些操作细节了。Ros包实现的内容就是上面提及的3、4、5中描述的工作。此外，Ros包还要把从底盘获得数据publish出去，当然对于需要发送给底盘的速度要求也要提前向roscore subscribe一下。
最后还有一个要注意的就是，如果Ros包退出，相关的class对象在进行析构的时候，一定要让底盘停止，发送最后一次停止命令报文。这样整个工作环境才是安全的，这一点务必要牢记在心。做工业自动化、或者汽车自动驾驶的同学，这方面尤其要注意。
7、stm32开发板上的cmd_vel目标分解说明 前面我们说过，对于差速轮来说，它的线速度公式是这样的，vl和vr分别是左右轮的速度，
v = (vr + vl) /2 角速度公式是这样的，其中l是轮距，
w = (vr - vl) / l 假设这个时候，底盘从ros获取了vx、vy和w的要求，此时应该如何转变成vl和vr呢？处理过程其实是一样的。首先计算一下v，
v = sqrt(vx * vx + vy * vy) 接着就是利用数组计算，
vr + vl = 2 * v vr - vl = w * l 所以简单计算一下，
vr = v + w*l/2 vl = v - w*l/2 进一步带入v和w，那么公式就变成，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0a08264f70c1a104756d9acad03f21e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/83/">«</a>
	<span class="pagination__item pagination__item--current">84/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/85/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>