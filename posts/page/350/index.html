<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1603c8be96c81cf4f6f73aa735b387e/" rel="bookmark">
			网络如何通讯：tcp详解以及网络通信做了什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络 人与人之间要有语言才可以进行通讯，语言就是一种可以共享数据信息的规则，那么计算机与计算机之间也要有统一的连接标准才能够完成相互通信，这个标准被称为互联网协议，而网络是就是物理连接介质(电平信号) + 互联网协议。
互联网协议 TCP/IP 五层 互联网协议是有很多的，TCP/IP 五层模型的出现目的就是将众多的互联网协议根据功能以及解决的问题分成几个模块，这样更容易发现问题并且去针对性的处理问题。
每层运行的常见设备如下所示：
物理层 物理层主要解决的是数据如何通过介质从一台机器传送给另外一台机器的问题。物理层通过基于电器特性发送高低电平信号传输数据，从一个基站传送到另一个基站。点平即是 “电压平台”，指的是电路中某一点电压的高低状态，在网络信号中高电平用数字 “1” 标识，低电平用数字 “0” 表示。电平的高低是个相对概念，3v 对于 7v是低电平，但对于 1v 就是高电平。
在这一层的工作的基建主要有中继器、中继塔、集线器、双绞线、光缆等。
数据链路层 由于单纯的电平信号是没有任何意义的，所以我们需要一套协议以及设备来将这些电平信号进行处理，处理成为互联网中可以传输的内容，比如电平信号多少位一组，每组表示什么含义。数据链路层的功能就是定义电平信号的分组方式。
1. 以太网协议 数据链路层基于以太网协议进行数据传输，通过mac地址寻址的广播方式进行数据传输，只能在局域网内传播。
Ethernet 以太网规定：一组电平信号构成一个数据包，叫做“帧”，每一数据帧由报头 Head 和数 data 两部分组成。
Head：固定18字节，其中发送者 / 源地址6字节，接受者 / 目标地址6字节，数据类型6字节。
Data：最短46字节，最长1500字节。
数据链路层的数据最短为64字节，最长为1518字节，超过的部分分片发送。
2. MAC 地址 数据链路层中的数据包中Head部分有发送者与接受者的地址，这个地址便是网卡的mac地址，Ethernet 规定接入 Internet 的设备必须配有网卡，Mac地址就是网卡的地址。所以数据包寻址的时候，会根据网卡的地址来决定数据会被谁所接受，这也是网卡所起的作用。
Mac地址，每块网卡在出厂的时候都会刻上一个全世界唯一的Mac地址，这个地址是不允许重复的，长度为48位的二进制数，通常用12位的十六进制数表示，前6位是厂商编号，后六位是流水线号。
3. 数据链路层的通讯，广播 Ethernet 以太网通讯的协议非常粗暴，直接以广播的形式在局域网中传输数据，所以一个局域网中的所有电脑都会受到广播信号，但因为有MAC地址的缘故，会根据数据包中的目标地址来匹配自己的MAC地址决定是否响应这个数据，如果匹配则相应，如果不匹配则丢弃掉这条消息。
所以数据链路层会带着MAC地址将数据通过传输层广播到局域网中，一个局域网中是有很多的PC机器的，每台PC机器的MAC地址唯一。
网络层 有了传输层、数据链路层的协议，计算机之间已经可以通信了，但是数据链路层的协议作用范围只能在局域网中进行数据传输，如果是广域网中，仍然采用广播的方式，那么整个广域网中的所有计算机都会收到这个广播，那么这份传输量是很巨大的，如果有几亿台机器，这份性能以及效率都是个灾难，所以广域网之间传输肯定不能用广播的方式。
广域网是由一个一个的局域网组成的，以太网包只能在一个局域网中发送，要想在广域网中发送，只能通过路由转发。所以就需要一种协议可以区分是广域网还是局域网。
网络层解决的就是这种问题，规定通过一个网络地址来区分不同广播域，不同广播域之间通过路由通信，这就是网络地址。
1. IP IP 协议是用来规定网络地址的协议，它规定的地址叫做IP地址。一般采用IPV4或者IPV6，IPV4规定网络地址由32位二进制数表示，通常斜撑4段十进制数，比如 172.16.10.1，取值范围为：0.0.0.0 ~ 255.255.255.255。
IP 地址由两部分组成：网络部分(用来标识子网) 和主机部分 (用来标示主机)。
2. 子网以及子网掩码 Internet组织机构定义了五种IP地址，有A、B、C三类地址。A类网络有126个，每个A类网络可能有16777214台主机，它们处于同一广播域。而在同一广播域中有这么多节点是不可能的，网络会因为广播通信而饱和，结果造成16777214个地址大部分没有分配出去。所以Internet组织机构把基于每类的IP网络进一步分成更小的网络，每个子网由路由器界定并分配一个新的子网网络地址,子网地址是借用基于每类的网络地址的主机部分创建的。划分子网后，通过使用掩码，把子网隐藏起来，使得从外部看网络没有变化，这就是子网掩码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1603c8be96c81cf4f6f73aa735b387e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a50a39613e384387cf369268c8f3bbc4/" rel="bookmark">
			2020-10-19 Nvidia与vGPU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NVIDIA虚拟GPU（vGPU）软件主要用于支持交付图形丰富的虚拟桌面和工作站，NVIDIA GPU是当今市场上最强大的数据中心GPU，使用虚拟GPU软件可以将GPU资源重新划分，以保证GPU资源可以在多个虚拟机之间共享，或者可以将多个GPU分配给一个虚拟机，可提升任意工作负载的性能。
类型介绍 NVIDIA虚拟GPU解决方案目前已经更新到最新的9.2版本，在最新的版本中，新增了面向AI、深度学习和数据科学服务器虚拟化场景的vComputeServer类型。至此，NVIDIA vGPU产品组合共包含四种类型：
NVIDIA Quadro® Virtual Data Center Workstation (Quadro vDWS)NVIDIA GRID® Virtual PC (GRID vPC)NVIDIA GRID Virtual Applications (GRID vApps)NVIDIA Virtual Compute Server (vComputeServer) NVIDIA Quadro vDWS 虚拟工作站可通过数据中心提供GPU资源让用户随时随地在任何设备上安全访问数据，用户不再受物理位置的限制，NVIDIA Quadro vDWS能够进一步发挥Quadro的优势，实现真正的GPU加速数据中心，通过数据中心虚拟化应用程序为终端用户如建筑师、工程师和设计师提供专业工作站级别的用户体验。常见应用程序有：Ansys Discovery Live、ESRI ArcGIS、Autodesk AutoCAD、Autodesk Maya、Autodesk Revit、CATIA、Petrel、Siemens NX、SOLIDWORKS等。
NVIDIA GRID vPC/vApps NVIDIA GRID™虚拟PC(GRID vPC) 和虚拟应用程序(GRID vApps)等虚拟化解决方案提供的用户体验与本地PC几乎别无二致。借助服务器端图形以及全面管理和监控功能，GRID为您的VDI环境提供长效的解决方案。为组织中的每台VM(虚拟机)提供GPU加速能力，为各种现代企业应用程序提供卓越用户体验的解决方案，这些程序包括Microsoft Outlook、Office 2016、网络浏览器、Adobe Photoshop以及Windows 10操作系统。成本有效地扩展至整个企业，并将VDI的覆盖范围扩展到每个成员。
NVIDIA vComputerServer NVIDIA vComputerServer提供了虚拟化GPU和加速计算密集型服务器工作负载的能力，包括AI，深度学习和数据科学。这样，汽车制造商可以使用最新的模拟和计算技术来创建最节省燃料和时尚的设计，研究人员可以分析基因的功能，以更快地开发医疗。
授权方式 GRID vAPP(vApps) – 基于使用vGPU的并发用户会话数授权
GRID vPC(vPC) – 基于使用vGPU的并发数授权
vComputeServer(vCS) - 基于物理GPU授权，且仅支持订阅模式
Quadro Virtual Data Center Workstation (vDWS) – 基于使用vGPU的并发数授权
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a50a39613e384387cf369268c8f3bbc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03021071593b55e113b6a0005afb13f2/" rel="bookmark">
			iOS  WKWebview 白屏检测实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 自ios8推出wkwebview以来，极大改善了网页加载速度及内存泄漏问题，逐渐全面取代笨重的UIWebview。尽管高性能、高刷新的WKWebview在混合开发中大放异彩表现优异，但加载网页过程中出现异常白屏的现象却仍然屡见不鲜，且现有的api协议处理捕捉不到这种异常case，造成用户无用等待体验很差。
针对业务场景需求，实现加载白屏检测。考虑采用字节跳动团队提出的webview优化技术方案。在合适的加载时机对当前webview可视区域截图，并对此快照进行像素点遍历，如果非白屏颜色的像素点超过一定的阈值，认定其为非白屏，反之重新加载请求。
获取快照 ios官方提供了简易的获取webview快照接口，通过异步回调拿到当前可视区域的屏幕截图。
- (void)takeSnapshotWithConfiguration:(nullable WKSnapshotConfiguration *)snapshotConfiguration completionHandler:(void (^)(UIImage * _Nullable snapshotImage, NSError * _Nullable error))completionHandler API_AVAILABLE(ios(11.0)); 其中snapshotConfiguration 参数可用于配置快照大小范围，默认截取当前客户端整个屏幕区域。由于可能出现导航栏成功加载而内容页却空白的特殊情况，导致非白屏像素点数增加对最终判定结果造成影响，考虑将其剔除。
- (void)judgeLoadingStatus:(WKWebView *)webview { if (@available(iOS 11.0, *)) { if (webView &amp;&amp; [webView isKindOfClass:[WKWebView class]]) { CGFloat statusBarHeight = [[UIApplication sharedApplication] statusBarFrame].size.height; //状态栏高度 CGFloat navigationHeight = webView.viewController.navigationController.navigationBar.frame.size.height; //导航栏高度 WKSnapshotConfiguration *shotConfiguration = [[WKSnapshotConfiguration alloc] init]; shotConfiguration.rect = CGRectMake(0, statusBarHeight + navigationHeight, _webView.bounds.size.width, (_webView.bounds.size.height - navigationHeight - statusBarHeight)); //仅截图检测导航栏以下部分内容 [_webView takeSnapshotWithConfiguration:shotConfiguration completionHandler:^(UIImage * _Nullable snapshotImage, NSError * _Nullable error) { //todo }]; } } } 缩放快照 为了提升检测性能，考虑将快照缩放至1/5，减少像素点总数，从而加快遍历速度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03021071593b55e113b6a0005afb13f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d72ebf1eeaa3c3eea7bf0e852c32d7a1/" rel="bookmark">
			到底5大云厂商有什么不同？看这篇文章就足够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全球公有云计算市场的领导地位竞争是激烈的三方竞争： AWS vs Azure vs Google，国内市场则是阿里云、腾讯云和AWS。对于基础架构即服务 (IaaS) 和平台即服务 (PaaS)，亚马逊 Web 服务 (AWS)、Microsoft Azure 和 Google 云平台 (GCP) 在众多云公司中占据着优势，另外紧随其后的是阿里云和腾讯云。
AWS依旧占主导地位 Synergy Research Group 首席分析师 John Dinsdale 曾表示：“云服务和数据中心基础设施市场是真正全球性质的，但是中国是个例外。全球市场以每年 50% 的速度增长，而中国市场则以每年超过 70% 的速度增长。并指出：”尽管市场规模几乎翻了两倍，但AWS在全球的市场份额连续12个季度内一直稳定在33% 左右。
以下为 Synergy Research Group发布的2018年Q4全球云基础设施服务市场份额。
与此同时，微软在 SaaS 方面的实力尤为强劲，而谷歌云 (Google Cloud) 在2018年从Gartner魔力象限中的愿景者象限升级为领导者象限，并以提供折扣闻名，处于积极增长的地位。
中国市场份额上，阿里云以40.5%的市场份额仍旧位列第一，腾讯云紧追其后（16.5%）， Sinnet（光环新网，AWS中国伙伴）以9.7%排名第三（但AWS中国另一个合作伙伴西云数据并没有计算入内）。
比较从这儿开始 AWS – 随着庞大的工具集继续呈指数级增长，亚马逊的功能是无与伦比的。然而，其成本结构可能会让人感到困惑，它只关注公有云，而不是混合云或私有云意味着与您的数据中心进行交互并不是 AWS 的首要任务。
Microsoft Azure – 拥有卓越功能的云基础架构的AWS的紧密竞争对手。面对企业客户，Azure将从企业角度去考虑如何结合现有的数据中心，但很少有公司具有 Microsoft 这样的企业背景 (Windows支持)。Azure知道很多客户仍在运行数据中心，Azure平台努力与数据中心进行交互——混合云是一种真正的优势。
Google Cloud – 作为竞争中资金充足的弱势群体，谷歌进入云市场晚了一步，它也没有特别吸引企业客户的地方。但它有自己的技术优势，比如行业领先的深度学习和人工智能、机器学习和数据分析工具。
阿里云 – 界面友好，适合于国内中小型企业。有比较多电商、物联网方面的客户案例。国内数据中心众多，产品服务比较全面。阿里云作为国内云计算的龙头老大，在市场占有率和行业经验都有比较领先的地位。
腾讯云 – 游戏和视频行业的技术比较突出，侧重于构造产业生态圈。并且能够很好地打通腾讯开放平台。有比较多的政企、游戏界的客户经验。
优劣分析 许多专家建议企业在个案基础上评估其公有云需求，并让最适合其需求的供应商提供特定的应用程序和工作负载。每个领先的供应商都有特殊的优势和弱点，这使得他们成为某些项目的最佳选择。
AWS的优点和缺点： 亚马逊最大的优势是其在公共云市场的主导地位。Gartner 指出，在其“基础架构即服务” 的Magic Quadrant中，”10多年来，AWS 一直是云 IaaS 的市场份额领导者。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d72ebf1eeaa3c3eea7bf0e852c32d7a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b94c779e27e35fb17e48b913cc1733cf/" rel="bookmark">
			UE4 局域网联机开发历程 - （一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 ，创建房间（按钮事件）
红 ：房间人数
绿 ：在联机中跳转关卡需要添加的 listen
二 ，加入房间（按钮事件）
红 ：寻找到的房间地址变量
三 ， 寻找房间（按钮事件）
四 ， 离开房间（按钮事件）
五 ，场景漫游
红 ：要漫游的关卡名称
打包设置请看：UE4 局域网联机开发历程 - （二）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b15e4967f082a048ddb4529a7b678b5/" rel="bookmark">
			Ubuntu 16.04安装realsense D435i SDK以及realsense-ros
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先直接上一个报错信息，折腾了半天才解决 在使用catkin_make编译realsense-ros时，报错
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- ~~ traversing 4 packages in topological order:
-- ~~ - realsense_camera_msgs (plain cmake)
-- ~~ - ddynamic_reconfigure
-- ~~ - realsense2_camera (plain cmake)
-- ~~ - realsense2_node (plain cmake)
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CMake Error at /opt/ros/kinetic/share/catkin/cmake/catkin_workspace.cmake:95 (message):
This workspace contains non-catkin packages in it, and catkin cannot build
a non-homogeneous workspace without isolation. Try the
'catkin_make_isolated' command instead.
Call Stack (most recent call first):
CMakeLists.txt:67 (catkin_workspace)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b15e4967f082a048ddb4529a7b678b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/246ea4252761a66f029a920f1c205a56/" rel="bookmark">
			阿里云突发性能实例介绍 突发性能实例适合什么样的应用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		突发性能实例是一种面向入门级计算场景，应对突发性能需求的经济型实例规格。本文介绍突发性能实例规格族的特点和应用场景，以及基准性能、CPU积分、性能模式等概念，并列出了具体的实例规格。 什么是突发性能实例 突发性能实例是一种通过CPU积分来保证计算性能的实例规格，适用于平时CPU使用率低，但偶尔有突发高CPU使用率的场景。突发性能实例在创建后可以持续获得CPU积分，在性能无法满足负载要求时，通过消耗更多CPU积分来无缝提高计算性能，不会影响部署在实例上的环境和应用。较之其他实例规格，突发性能实例的CPU使用更加灵活且成本较低。 通过CPU积分，您可以从整体业务角度分配计算资源，将业务平峰期的计算能力转移到高峰期使用，以节约使用成本。如果偶尔会出现计划外的高性能需求，您还可以选择为突发性能实例打开无性能约束模式。 突发性能实例规格包括以下两类： 突发性能实例规格族t6突发性能实例规格族t5 基准性能、CPU积分和性能模式是突发性能实例的基本概念，相关说明如下表所示。 基本概念说明详情及示例基准性能实例可以持续稳定地提供的CPU性能，由实例规格决定。基准性能初始CPU积分创建突发性能实例时一次性获得的CPU积分，固定为每vCPU 30个积分。CPU积分CPU积分余额突发性能实例持续获得的CPU积分超过消耗的CPU积分，即转化为CPU积分余额，用于将CPU使用率提升到基准性能以上。CPU积分最大CPU积分余额一台突发性能实例24小时可以获得的CPU积分，CPU积分余额最多保存24小时，保持动态平衡。对指定实例规格来说，CPU积分获得速度是固定的，因此CPU积分余额有上限。CPU积分性能模式 分为性能约束模式和无性能约束模式。 在性能约束模式下，如果没有可用的CPU积分，CPU使用率将无法超过基准性能。在无性能约束模式下，突发性能实例可以透支或付费使用CPU积分，在任意时间段保持高于基准性能的CPU使用率，但是可能会产生相应费用。 性能模式预支CPU积分未来24小时可以获得的CPU积分，可能产生费用。仅在打开无性能约束模式时可以透支使用。性能模式超额CPU积分预支CPU积分消耗完毕后，继续维持高于基准性能的CPU使用率会使用的CPU积分，产生费用。仅在打开无性能约束模式时可以使用。性能模式 突发性能实例应用场景 在购买企业级等类型的实例后，您拥有实例vCPU的完全使用权，同时意味着无论CPU使用率是0%还是100%，您都需要为整个vCPU付费。如果您的业务场景规律，仅在特定的时段有较高的CPU性能需求，相当于在其它时段也在为未能使用的计算资源付费。这种情况下，您可以选择突发性能实例打造高性价比、经济实用的服务器。 突发性能实例适用于在某些时段对计算性能有突发性要求的场景，例如开发测试压测服务应用、轻负载应用、微服务、Web应用服务器等。购买前请评估业务在平峰期和高峰期的实例性能需求，至少选择基准性能满足平峰期需求的实例规格，选择得当可以在满足整体性能需求的同时节省成本。 关于阿里云突发性能实例更详细介绍，请参考：阿里云突发性能实例概述 原文链接：https://www.9i0i.com/article-95491-1.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf85ba2a6282d62064b78d1f95437ac/" rel="bookmark">
			统计学习 - 贝叶斯估计及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我现在觉得贝叶斯是哲学+数学
贝叶斯估计 用来 决策：贝叶斯决策
贝叶斯估计 用来 分类：贝叶斯分类器
…
目录 概念与原理统计推断频率学派与贝叶斯派 贝叶斯公式从最大似然估计（MLE）到最大后验概率估计（MAP）似然函数极大似然估计（MLE）最大后验概率估计（MAP）最大似然估计和最大后验概率估计的区别最大后验概率的意义 朴素贝叶斯条件独立性假设 例水果糖（贝叶斯推断，先验后验）假阳性问题（贝叶斯推断，先验后验） 概念与原理 统计推断 统计推断，是指统计学中研究如何根据样本数据去推断总体数量特征的方法。
统计推断可能使用如下三种信息：
一 总体信息，即总体分布或所属分布族的信息。譬如“总体视察指数分布”或“总体是正态分布”。
二 样本信息，即从总体抽取的样本的信息。
三 先验信息，即在抽样之前有关统计问题的一些信息，主要来源于经验和历史资料。
只用前两种信息的统计学称为经典统计学，三种信息都用的统计学称为贝叶斯统计学。
频率学派与贝叶斯派 频率学派认为“概率”是一种事件本身所带规律，并试图从样本信息中提取出来“概率”。但是贝叶斯派认为“概率”是人们对于一件事的相信度，根据样本信息，不断地调整之前的相信度。
频率学派认为世界是确定的，有一个本体，这个本体的真值是不变的，我们的目标就是要找到这个真值或真值所在的范围；而贝叶斯学派认为世界是不确定的，人们对世界先有一个预判，而后通过观测数据对这个预判做调整，我们的目标是要找到最优的描述这个世界的概率分布。
《概率论沉思录》 简单地说，频率学派与贝叶斯学派探讨「不确定性」这件事时的出发点与立足点不同。
频率学派从「自然」角度出发，试图直接为「事件」本身建模，即事件A在独立重复试验中发生的频率趋于极限p，那么这个极限就是该事件的概率。举例而言，想要计算抛掷一枚硬币时正面朝上的概率，我们需要不断地抛掷硬币，当抛掷次数趋向无穷时正面朝上的频率即为正面朝上的概率。
然而，贝叶斯学派并不从试图刻画「事件」本身，而从「观察者」角度出发。贝叶斯学派并不试图说「事件本身是随机的」，或者「世界的本体带有某种随机性」，这套理论根本不言说关于「世界本体」的东西，而只是从「观察者知识不完备」这一出发点开始，构造一套在贝叶斯概率论的框架下可以对不确定知识做出推断的方法。频率学派下说的「随机事件」在贝叶斯学派看来，并不是「事件本身具有某种客观的随机性」，而是「观察者不知道事件的结果」而已，只是「观察者」知识状态中尚未包含这一事件的结果。但是在这种情况下，观察者又试图通过已经观察到的「证据」来推断这一事件的结果，因此只能靠猜。贝叶斯概率论就想构建一套比较完备的框架用来描述最能服务于理性推断这一目的的「猜的过程」。因此，在贝叶斯框架下，同一件事情对于知情者而言就是「确定事件」，对于不知情者而言就是「随机事件」，随机性并不源于事件本身是否发生，而只是描述观察者对该事件的知识状态。
总的来说，贝叶斯概率论为人的知识（knowledge）建模来定义「概率」这个概念。频率学派试图描述的是「事物本体」，而贝叶斯学派试图描述的是观察者知识状态在新的观测发生后如何更新。为了描述这种更新过程，贝叶斯概率论假设观察者对某事件处于某个知识状态中（例如：小明先验地相信一枚硬币是均匀的，可能是出于认为均匀硬币最常见这种信念），之后观察者开始新的观测或实验（小明开始不断地抛硬币，发现抛了100次后，居然只有20次是正面朝上）。经过中间的独立重复试验，观察者获得了一些新的观测结果，这些新的观测将以含有不确定性的逻辑推断的方式影响观察者原有的信念（小明开始怀疑这枚硬币究竟是不是均匀的，甚至开始断定硬币并不均匀）。在这一过程中，观察者无法用简单的逻辑来推断，因为观察者并没有完全的信息作为证据，因此只能采用似真推断（plausible reasoning），对于各种各样可能的结果赋予一个「合理性」（plausibility）。
例子中，小明原先认为硬币的分布是均匀的，于是根据小明原有的信念，这个论断合理性非常高；在观察到100次抛掷中只有20次正面朝上后，小明开始怀疑硬币的均匀性，此时小明很可能认为「硬币不均匀」这一推断的合理性很高，支持的证据就是他刚刚实验的观测结果。上面的例子用贝叶斯概率论的语言来描述，就是观察者持有某个前置信念（prior belief），通过观测获得统计证据（evidence），通过满足一定条件的逻辑一致推断得出的关于该陈述的「合理性」，从而得出后置信念（posterior belief）来最好的表征观测后的知识状态（state of knowledge）。这里，贝叶斯概率推断所试图解决的核心问题就是如何构建一个满足一定条件的逻辑体系赋予特定论断一个实数所表征的论断合理性的度量（measure of plausibility），从而可以允许观测者在不完全信息的状态下进行推断。这里，观察者对某变量的信念或知识状态就是频率学派所说的「概率分布」，也就是说，观察者的知识状态就是对被观察变量取各种值所赋予的「合理性」的分布。从这个意义上来讲，贝叶斯概率论试图构建的是知识状态的表征，而不是客观世界的表征。因此，在机器学习、统计推断中，许多情况下贝叶斯概率推断更能解决观察者推断的问题，而绕开了关于事件本体的讨论，因为没有讨论本体的必要性。
贝叶斯公式 贝叶斯是机器学习的核心方法之一，贝叶斯方法源于他生前为解决一个“逆概”问题写的一篇文章，而这篇文章是在他死后才由他的一位朋友发表出来的。
在贝叶斯写这篇文章之前，人们已经能够计算“正向概率”，如“假设袋子里面有N个白球，M个黑球，你伸手进去摸一把，摸出黑球的概率是多大”。
而一个自然而然的问题是反过来：“如果我们事先并不知道袋子里面黑白球的比例，而是闭着眼睛摸出一个（或好几个）球，观察这些取出来的球的颜色之后，那么我们可以就此对袋子里面的黑白球的比例作出什么样的推测”。这就是所谓的逆概问题。
贝叶斯派认为现实世界本身就是不确定的，人类的观察能力是有局限性的，我们日常所观察到的只是事物表面上的结果，比如从袋子中取球，我们往往只能知道从里面取出来的球是什么颜色，而并不能直接看到袋子里面实际的情况。这个时候，就需要提供一个猜测。
朴素贝叶斯是贝叶斯决策理论的一部分。
贝叶斯公式给出了对于先验概率的调整方法
在贝叶斯法则中，每个名词都有约定俗成的名称：
P(A)是A的先验概率或边缘概率。之所以称"先验"是因为它不考虑任何B方面的因素，即在B事件发生之前，我们对A事件概率的一个判断。
P(A|B)是已知B发生后A的条件概率，在B事件发生之后，我们对A事件概率的重新评估，也被称作A的后验概率。
P(B|A)是已知A发生后B的条件概率，也被称作B的后验概率。
P(B)是B的先验概率或边缘概率，也作标准化常量（normalized constant）
P(B|A)/ P(B)称为"可能性函数"（Likelyhood），这是一个调整因子，使得预估概率更接近真实概率。
后验概率=先验概率*调整因子
贝叶斯公式结合全概率公式有：
从最大似然估计（MLE）到最大后验概率估计（MAP） 似然函数 概率是已知模型和参数，推数据。
似然是已知数据，推模型和参数。
考虑P(x|θ)
输入有两个：x表示某一个具体的数据；θ表示模型的参数。
如果θ是已知确定的，x是变量，这个函数叫做概率函数(probability function)，它描述对于不同的样本点x，其出现概率是多少。
如果x是已知确定的，θ是变量，这个函数叫做似然函数(likelihood function), 它描述对于不同的模型参数，出现x这个样本点的概率是多少。
极大似然估计（MLE） 假设有一个造币厂生产某种硬币，现在我们拿到了一枚这种硬币，想试试这硬币是不是均匀的。即想知道抛这枚硬币，正反面出现的概率（记为θ）各是多少？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbf85ba2a6282d62064b78d1f95437ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfc926cd6efe9f66c3abf7dd7e2a5152/" rel="bookmark">
			@vue_cli 项目使用 pdf.js 实现 pdf 文件在线预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近用 vue 做的一个移动端项目，在某些浏览器中无法直接打开预览 pdf 文件，所以选择了使用 pdf.js 去实现
实现步骤如下：
1、首先去 pdf.js 官网下载，地址：https://mozilla.github.io/pdf.js
2、解压下载的zip文件，将解压后的整个目录（pdfjs-2.3.200-dist）拷贝到项目的 public 目录下（放在 public 目录下的文件不会被 webpack 处理）
3、使用 pdf.js 自带的预览界面 viewer.html 预览，可以在 viewer.css 文件对 viewer.html 做一些样式调整。在需要使用的地方直接一个 a 标签 href 链接即可，a 标签的 href 链接形式为：/pdfjs-2.3.200-dist/web/viewer.html?file=pdf文件地址
&lt;a href="/pdfjs-2.3.200-dist/web/viewer.html?file=http://0.0.0.0:1112/file/demo.pdf"&gt; 预览文件 &lt;/a&gt; 4、在浏览器中打开文件后如果报错 file origin does not match viewer's ，只需要在 viewer.js 文件中找到 throw new Error('file origin does not match viewer\'s'); 这一行，并注释掉即可
也可以通过 vue 路由组件实现预览，具体实现步骤如下：
1、在项目 views 文件夹下新建一个组件用于 pdf 文件预览，比如我这里的 views/pdf-preview/index.vue
2、index.vue 文件内容如下，主要是通过 iframe 实现：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfc926cd6efe9f66c3abf7dd7e2a5152/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d26c0fac9ef1fe7780b229b8ddb7ba6/" rel="bookmark">
			SMS-EMOA:基于超体积支配的多目标选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文献：
《Nicola Beume, Boris Naujoks, Michael Emmerich：SMS-EMOA: Multiobjective selection based on dominated hypervolume》
《Multi-objective Optimisation using S-metric Selection: Application to three-dimensional Solution Spaces》
要点：
超体积测量（S度量）是一种常用的质量度量，用于比较进化多目标优化算法结果;提出了基于超体积测量和非支配排序的选择算子的稳态EMOA;该算法种群演化出一组分布良好的解，聚焦于帕累托前沿感兴趣区域。 一、介绍
质量指标来衡量帕累托前沿近似值的质量。其中，超体积测量或S度量是一个尤为重要的质量指标，它奖励向帕累托前沿的收敛以及沿前沿的代表性点分布。Λ表示勒贝格测度，那么S度量定义为：
此处，yref∈Rm表示一个参考点，该参考点应由所有帕累托最优解所支配。
Fleischer证明，给定有限的搜索空间和参考点，超体积测量的最大化等同于找到Pareto集。因此，对于一组给定有界的空间，最大S度量值可能仅由帕累托最优解组成。从经验上已经观察到，固定数量的点，超体积测量的最大化产生了Pareto前沿的子集，这些子集分布均匀。
本文作者提出的一种方法是根据候选解对超体积的贡献来选择候选解。
二、S度量选择(SMS-)EMOA
SMS-EMOA借鉴了其他EMOA的思想，如著名的NSGA-II和诺尔斯等人提出的归档策略。这是一个基于两个支柱的稳态算法：
非支配排序被用作等级评判标准；超体积用作选择标准以丢弃最差等级前沿上对超体积贡献最小的个体。 1、SMS-EMOA细节
SMS-EMOA基本算法在算法1中描述。首先从μ个个体的初始种群开始，通过随机变异算子生成一个新个体。如果用S度量测出，用新个体替换另一个个体可以产生更高质量的种群，则新个体将成为下一代种群的成员。
算法2中描述从子种群中选择μ个个体的Reduce过程。
从最差等级前沿中剔除一个个体，其中，ΔS表示个体s对相应前沿的S度量值的唯一贡献，有最小ΔS值的个体被剔除。
此度量保留那些使总体S度量值最大化的个体，因此，以下不等式恒成立。
2、SMS-EMOA的选择变体
支配点数d(s,P(t))是集合P(t)中支配点s的点数，形式上：
算法3中给出了一个改进的Reduce过程。支配点数d(s,P(t))被用作选择标准，当P(t)的所有个体都是非支配时，ΔS被应用。如果群体由多个前沿组成，则在最差等级前沿的解中具有最高d(s,P(t))值的个体被丢弃。否则，所有个体的d(s,P(t))值等于零，使用ΔS选择。
开发这种度量的一个动机是，与超体积测量相比，运行时复杂性更小。此外，这样做的动机是为了获得支配解的不同等级以加强解空间中稀疏区域的填充。在这里，个体被保留了几代，以填补帕累托近似前沿的空白。贡献超体积用于将解很好地分布在他们所在的前沿。虽然最终目的是在第一个非支配前沿很好地分布解，但这并不是其他前沿的目的。d(s,P(t))措施对位于较好的前沿且个体稀少的区域的解有利。想法是，后代解可能会上升到更好的前沿，并填补这些空缺。
如上图所示。贡献的超体积度量支持y8而不是y9，但是d(s,P(t))度量支持y9，因为只有一个支配点。y9显然要有趣得多，因为第一前沿上y5和y6之间的空缺很大。
3、贡献超体积ΔS的计算
在两个目标的情况下，取排名最差的非支配前沿的点，并根据第一个目标函数f1的值以升序对它们进行排序，得到一个关于f2值降序的序列，因为点是相互非支配的。
三目标情况下，第三个目标被视为长方体的高度。如果一个解支配它的右下角，这个解被称为弱支配一个单元。这些弱支配解被用来计算长方体的高度。高度是最佳和第二最佳f3值的差值。体积为每个单元格面积×高度。如图所示，贡献是体积的累加。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65fe502083ab86b9dcce58f40364ddf5/" rel="bookmark">
			markdown语法最全汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、markdown简介 （注：如果对markdown有一定了解。可以略过此处，第一章主要对markdown基础知识做个补充,摘自菜鸟教程此处原文档 ）
博客原地址,欢迎收藏访问 1.1 markdown背景 1. markdown是一种轻量级标记语言，她与徐人们使用易读易写的纯文本格式编写文档。 2. Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。 3. Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 4. Markdown 编写的文档后缀为 .md, .markdown。 1.2 markdown应用 Markdown 能被使用来撰写电子书，如：Gitbook。 当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。 1.3 编辑器 编辑器有很多种，基本各大编辑器都可以编辑markdown格式文档。 比如：Typora，sublime Text, coderunner,印象笔记，vim等等等。具体的可以百度，都非常好用。 二、markdown基本操作 1.标题 使用#号标记，可以表示1-6级标题，随#个数递增。如：
# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 注：最后一个#与文字间一定要有一个空格。
显示效果：
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-05hcz9cY-1602941673686)(https://i.loli.net/2020/02/17/wIWVKahMtmTLu4n.png)]
2.换行 markdown换行方式有很多种
直接在一句话后面敲两个空格两句话之间加一个空行如果你在编辑的时候，想让一行文字分成几段在显示的时候换行，就在中间加 此点是我想在表格里换行时get到的，也很实用,后面讲到表格我会展示。
3.字体 markdown支持几种字体：
*斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ***粗斜体文本*** ___粗斜体文本___ 把你想修改的字段直接放在中间即可。显示效果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65fe502083ab86b9dcce58f40364ddf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17e30b7a41884d11cd4ef6cc5152a30c/" rel="bookmark">
			C/C&#43;&#43;编程日记：用C语言实现的简单Web服务器(Linux)，全代码分享！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信大家对Apache都有所听闻，Apache是目前使用最为广泛我Web服务器。大家可以从news.netcraft.com/这个网站得到证实。
这是腾讯的uptime.netcraft.com/up/graph?site=www.qq.com.Apache强大的功能和高效的性能并且开放源代码的这种模式对我很有吸引力，但无赖自己水平有限，无法从Apache庞大的source code里面理清头绪。
于是，我就冒出了个自己动手写一个小型的简单的Web服务器的想法，希望对这方面也和我一样感兴趣的朋友有所帮助。
我的实验环境为:
OS:Red Hat Enterprise Linux 5
gcc:4.1.2
libc:2.5
editor:Vim
lang:C
阅读该源代码需要以下预备知识：
C语言基础
Linux编程基础
socket编程基础(Linux)
TCP/IP基本原理
HTTP基本原理
关键字(Key Words):
Linux C, Web HTTP Server, Linux Socket.
-----------------------------------------------------------------------------------
下面是Mutu的第一个版本(0.1 Alpha)，实现了WEB 服务器的最基本功能
包括以下源文件:
webserver.c----程序入口
init_socket.h init_socket.c----完成一些WEB服务器的初始化工作
get_time.h get_time.c----获得服务器的时间
http_session.h http_session.c----处理一次HTTP会话
以下是各文件源码：
webserver.c:
/*
* file:webserver.c
*/
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;strings.h&gt;
#include&lt;unistd.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;
#include&lt;arpa/inet.h&gt;
#include"get_time.h"
#include"init_socket.h"
#include"http_session.h"
intmain(intargc,char*argv[])
{
intlisten_fd;
intconnect_fd;
structsockaddr_inserver_addr;
structsockaddr_inclient_addr;
bzero(&amp;server_addr,sizeof(structsockaddr_in));
bzero(&amp;client_addr,sizeof(structsockaddr_in));
if(init_socket(&amp;listen_fd,&amp;server_addr)==-1)
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17e30b7a41884d11cd4ef6cc5152a30c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/437571b2c82b68a2614546b7a03d868f/" rel="bookmark">
			操作POSTMAN请求WebService的操作记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1、查看WebService规定的请求格式2、PostMan设置的地方 1、查看WebService规定的请求格式 2、PostMan设置的地方 返回200表示OK啦 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca79e6b9421a4262a6cd87236c7cd444/" rel="bookmark">
			基于深度学习的信道估计（DL-CE）基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文献：《基于机器学习的信道估计算法优化研究》（电子科技大学，李红，硕士学位论文）
文献下载地址：
链接：https://pan.baidu.com/s/1mys6ADy50uDRHNMzcxT__Q
提取码：bhd2
基于深度学习的信道估计：Deep Learning - Channel Estimation（DL-CE）
DL-CE一般都包括两个部分：离线训练和在线估计 DL-CE基本结构 目前把深度学习应用到无线通信系统中所存在的问题 （1）没有大量可靠的真实数据集，目前常用的训练数据大多都是使用仿真得到的，即实际的信道传输函数比较难获得
（2）当前深度学习的网络层数都较大（模型较大），还不能有效地运用到移动设备上
方案一、深度学习网络用在LS算法得到导频处信道特性（或者说信道频域响应CFR）之后 基本思路是：根据初步的导频数据或者粗略的信道传输矩阵，通过深度学习网络，拟合重建出高精度的信道传输矩阵。利用多种信道条件下的信道传输矩阵数据建立训练数据集，进行网络训练。在网络的不断训练和迭代的过程中，输入的初始的数据会逐步拟合和逼近真实的标签值，最终实现较高精度的CSI插值、回馈或重建
神经网络的输入： 导频处的CSI或者经过传统算法粗略估计出的信道CSI（或者叫信道传输矩阵）
神经网络的输出： 高精度的信道CSI
这种方案的深度学习网络结构如下图：
上图就是把深度学习网络用在了经过LS算法得到导频处的**信道特性CSI（或者说信道频域响应CFR）**之后，那么网络的输入就是一个OFDM符号内各个导频处的CFR，然后经过多个隐藏层之后，输出层输出的就是一个OFDM符号内所有载波处的CFR。
模型训练：首先使用仿真得到训练数据（训练数据包括导频处的CSI和一个OFDM符号的CSI），然后进行离线训练，离线训练时使用导频处的CSI作为输入，使用一个OFDM符号的CSI作为标签数据。
但是需要注意的是，信道估计处理的数据大多都为复数，但是现有的深度学习的库函数并不支持复数域的操作，所以说现在的一般做法就是在输入到网络之前需要对数据进行预处理，把复数的实部和虚部提取出来，然后当成两种实数输入到神经网络中，这种做法的缺点就是没有挖掘复数的相位信息，带来了一定的信息丢失。
该方案的一个栗子： 参考文献：《基于机器学习的信道估计算法优化研究》（电子科技大学，李红，硕士学位论文）
该种方案神经网络的输出是信道的频域响应，注意与方案二的不同点。
方案二、实现端到端的恢复原始信号，即训练一个神经网络来拟合传输过程，从而在接收机端到端的恢复出原始的发送信号。 端到端的意思就是输出的就是最终结果。
基于端到端（文献中把这种称为全连接的神经网络）的信道估计器通过对接收信号和原信号之间的关系的学习，不估计出信道的频域响应，而是直接输出发送的调制信号。
系统结构图如下图：
由上图可知该方案神经网络的输出就是原始的发送信号，而方案一中神经网络的输出只是信道的频域响应。
这种方法完全把信道当成了一个黑匣子，我们不会直接输出信道的传输函数（或者CSI），而是直接输出预测的原始的发送信号，即神经网络学习了发送信号与接收信号之间的映射关系。
基本思路是，首先在MATLAB中生成一些仿真数据，包括原始发送信号和最终信道接收到的信号，把这两部分信号输入到深度学习网络中，让网络学习到一种OFDM的发送和接收符号之间的映射关系，也就是频域响应H。训练完成的神经网络最终便学习到了两者的映射关系，即信道传输系数。
这种方案存在的两个问题：
（1）首先信道是随时间变化的，即信道具有时变性，这意味着如果我们简单地训练一个神经网络，然后将其用于连续数据传输，是无法适用的。例如，实际场景中的多普勒频移或非线性噪声都将导致神经网络在训练过程中学到的映射关系与实际的信道环境不一致。一个折中的解决方案就是假设估计得到的信道在接收到下一个导频序列为止都是保持不变的（这不就是块状导频么），若采用此方法，由于数据块与块之间的传输间隔通常是很短的，那么神经网络模型的收敛速度和泛化能力便是很关键的指标。
（2）导频数目多的话会降低频谱效率，导频数目少的话会造成样本不足。
综上所述，问题的挑战主要在于我们如何依靠较少的监督样本、快速迭代来完成信道估计。
为了解决上述问题，有论文提出了基于元学习的深度学习算法RoemNet（Robust channel Estimation with Meta neural Network）。元学习解决的是学习如何学习的问题，他可以解决极少样本情况下的模型训练问题。
元学习是一种模型无关的学习算法（MAML），MAML需要在各种任务上进行训练。该算法需要学习训练一种可以很快适应新任务的方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d69c8697626c00126e82f3bbffc053c9/" rel="bookmark">
			常见的反爬虫方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的反爬虫
爬虫一般分为 数据采集，处理，储存三个部分。
一般网站从三个方面反爬虫：用户请求的Headers，用户行为，网站目录和数据加载方式。前两种比较容易遇到，大多数网站都从这些角度来反爬虫。第三种一些应用ajax的网站会采用，增大了爬取的难度。
一、通过Headers反爬虫
从用户请求的Headers反爬虫是最常见的反爬虫策略。很多网站都会对Headers的User-Agent进行检测，还有一部分网站会对Referer进行检测（一些资源网站的防盗链就是检测Referer）。如果遇到了这类反爬虫机制，可以直接在爬虫中添加Headers，将浏览器的User-Agent复制到爬虫的Headers中；或者将Referer值修改为目标网站域名。对于检测Headers的反爬虫，在爬虫中修改或者添加Headers就能很好的绕过。
二、三、 基于用户行为反爬虫
还有一部分网站是通过检测用户行为，例如同一IP短时间内多次访问同一页面，或者同一账户短时间内多次进行相同操作。
大多数网站都是前一种情况，对于这种情况，使用IP代理就可以解决。可以专门写一个爬虫，爬取网上公开的代理ip，检测后全部保存起来。这样的代理ip爬虫经常会用到，最好自己准备一个。有了大量代理ip后可以每请求几次更换一个ip，这在requests或者urllib2中很容易做到，这样就能很容易的绕过第一种反爬虫。
对于第二种情况，可以在每次请求后随机间隔几秒再进行下一次请求。有些有逻辑漏洞的网站，可以通过请求几次，退出登录，重新登录，继续请求来绕过同一账号短时间内不能多次进行相同请求的限制。
四、动态页面的反爬虫
上述的几种情况大多都是出现在静态页面，还有一部分网站，我们需要爬取的数据是通过ajax请求得到，或者通过JavaScript生成的。首先用Firebug或者HttpFox对网络请求进行分析。如果能够找到ajax请求，也能分析出具体的参数和响应的具体含义，我们就能采用上面的方法，直接利用requests或者urllib2模拟ajax请求，对响应的json进行分析得到需要的数据。
能够直接模拟ajax请求获取数据固然是极好的，但是有些网站把ajax请求的所有参数全部加密了。我们根本没办法构造自己所需要的数据的请求。我这几天爬的那个网站就是这样，除了加密ajax参数，它还把一些基本的功能都封装了，全部都是在调用自己的接口，而接口参数都是加密的。遇到这样的网站，我们就不能用上面的方法了，我用的是selenium+phantomJS框架，调用浏览器内核，并利用phantomJS执行js来模拟人为操作以及触发页面中的js脚本。从填写表单到点击按钮再到滚动页面，全部都可以模拟，不考虑具体的请求和响应过程，只是完完整整的把人浏览页面获取数据的过程模拟一遍。
用这套框架几乎能绕过大多数的反爬虫，因为它不是在伪装成浏览器来获取数据（上述的通过添加 Headers一定程度上就是为了伪装成浏览器），它本身就是浏览器，phantomJS就是一个没有界面的浏览器，只是操控这个浏览器的不是人。利用 selenium+phantomJS能干很多事情，例如识别点触式（12306）或者滑动式的验证码，对页面表单进行暴力破解等等。它在自动化渗透中还 会大展身手，以后还会提到这个。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e53adefc16af22d939024e366eb9005d/" rel="bookmark">
			CCFCSP 201503-2 数字排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 思路：数组标记存每个数出现的次数，遍历一下这个桶，用结构体存数字和出现的次数，排序一下即可
#include&lt;bits/stdc++.h&gt; using namespace std; int a[1005]; struct node{ int x; int num; }q[1005]; bool cmp(node a,node b){ if(a.num==b.num) return a.x&lt;b.x; return a.num&gt;b.num; } int main(){ int n;cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ int x;cin&gt;&gt;x; a[x]++; } int cnt=0; for(int i=0;i&lt;1001;i++){ if(a[i]){ q[cnt++]={i,a[i]}; } } sort(q,q+cnt,cmp); for(int i=0;i&lt;cnt;i++) cout&lt;&lt;q[i].x&lt;&lt;" "&lt;&lt;q[i].num&lt;&lt;endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73b9298c82e24e5e57a0200cdd658f84/" rel="bookmark">
			听说生鲜领军企业k8s集群都上云了，鱼会飞了？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这个中秋都和国庆在一起的双节里，我们的小明还在辛辛苦苦的找工作，听说他经历了一段“难忘”的面试。
小明面对着面试官的“层层拷问”，游刃有余的化解了这些难题。
面试官：请问你知道哪些“编排管理工具”？
小明：有Docker平台、Google GKE、Amazon EKS这类的平台。
面试官：那你知道k8s嘛？
小明：了解的，k8s就是Kubernetes（首字母为 k、首字母与尾字母之间有 8 个字符、尾字母为 s，所以简称 k8s），又叫做 "kube" ，是一种可自动实施Linux 容器操作的开源平台。它可以帮助用户省去应用容器化过程的许多手动部署和扩展操作。
也就是说，可以将运行 Linux 容器的多组主机聚集在一起，由 Kubernetes 帮助我们轻松高效地管理这些集群。而且，这些集群可跨公共云、私有云或混合云部署主机。
因此，对于要求快速扩展的云原生应用而言（例如借助 Apache Kafka 进行的实时数据流处理），Kubernetes 是理想的托管平台。
面试官：嗯，说的是挺详细的，能用一句话概括一下吗？
小明：k8s就是为容器服务而生的一个可移植容器的编排管理工具，就相当于你家有相当于一个足球队的孩子（当然，超生是不提倡的，请大家响应国家计生政策！！！），然后你需要一个专职保姆来帮你管理这些孩子的起居生活。这个专职保姆就是k8s，这些孩子就是你的每一个集群。
面试官：嗯，这样讲，更加的通俗易懂了，看来是真的会这些东西，不是在百度上背下来的，先来公司试用一段时间吧...
小明：好的，感谢。
k8s现在作为业界的扛把子，从各个方面都能够完美的解决问题。
从架构设计层面，我们关注的可用性，伸缩性都可以结合k8s得到很好的解决，如果你想使用微服务架构，搭配k8s，真的是完美，再从部署运维层面，服务部署，服务监控，应用扩容和故障处理，k8s都提供了很好的解决方案。
基于k8s的特性，很多公司现在都选择利用这个管理平台来发展业务，但是不乏有些公司他缺少专业的运维团队无法将平台的优势发挥出来，并且会承担这巨大的运维压力。
某专业的生鲜电子商务有限公司是一家采用“预订制”模式，通过全程冷链配送和社区智能冷柜自提方式，为用户提供优质生鲜服务的中国新零售领军企业。
该公司响应政府新一轮加快“菜篮子工程”建设的号召，立足于家庭生鲜农产品的供应，以生鲜直投站为社区服务点，打造种植、采摘、分拣、包装、冷链配送于一体的产业链。
业务发展初期，该公司自建了云下Kubernetes集群，但随着容器技术的快速迭代和自身业务不断拓展，需要同时维护多个版本的集群，每次升级集群的过程都都是一次极大的业务调整和巨大的运维负担。
为了降低运维成本，通过垂直伸缩容来快速应对数据分析业务的峰值。该公司决定将云下自建的Kubernetes集群迁移到云上，同时在云上构建一个Kubernetes集群部署新的应用，实现新老业务请求交互并对权限进行统一集中管理。
为减轻运维压力及成本，并保证业务的稳定运行，云掣基于丰富的Kubernetes运维经验，为客户提供Kubernetes迁移服务：
基于物理专线连接云上和云下的网络互通，并对链路的性能进行测试，确保物理专线可以满足迁移需求。
基于多个专有网络构建VPC互联场景下的多Kubernetes集群，打通VPC间的物理链路，实现数据请求转发的互通性。
基于Kubernetes集群内部的网络通信限制，结合专有网络的特性设计阿里云资源的IP地址范围、路由表和网关，保持新老业务网络环境的隔离性。
基于岗位角色创建自定义授权策略进行最小化授权，避免人为因素对集群产生错误变更操作。
基于CRD扩展，采集容器日志，展示整体流量水平，网站实时状态，用户请求分布等信息，实现业务监控概览。
在云掣抗打的专业能力下，帮助该企业实现了自建Kubernetes集群的平滑上云，简化了集群的扩容操作，实现业务架构云化，提升了业务的连续性及可扩展性，为打造高效的运营模式和完善的供应链体系提供了保障。
该企业将为更多消费者带去新鲜、丰富、价优、安全的生鲜食材，不断降低交易费用、提升用户体验，实现生鲜零库存。
更多技术细节可以去官网查看哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e844b5e7eb74f6fe0179c111c50df56/" rel="bookmark">
			Maven项目无法使用JSONObject.fromObject方法的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSONArray jsonArray = JSONArray.fromObject (arrayStr);
解决方案
导包依赖
import net.sf.json.JSONObject; &lt;!-- JSONObject对象依赖的jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-beanutils&lt;/groupId&gt; &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt; &lt;version&gt;1.9.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.ezmorph&lt;/groupId&gt; &lt;artifactId&gt;ezmorph&lt;/artifactId&gt; &lt;version&gt;1.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt;&lt;!-- 指定jdk版本（一定要有） --&gt; &lt;/dependency&gt; 问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/605f6e46968098886fe59f615f0ecf3c/" rel="bookmark">
			Python pandas用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python pandas用法 无味之味关注
0.8622019.01.10 15:43:25字数 2,877阅读 57,516
介绍 在Python中，pandas是基于NumPy数组构建的，使数据预处理、清洗、分析工作变得更快更简单。pandas是专门为处理表格和混杂数据设计的，而NumPy更适合处理统一的数值数组数据。
使用下面格式约定，引入pandas包：
import pandas as pd pandas有两个主要数据结构：Series和DataFrame。
Series Series是一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成，即index和values两部分，可以通过索引的方式选取Series中的单个或一组值。
Series的创建 pd.Series(list,index=[ ])，第二个参数是Series中数据的索引，可以省略。
第一个参数可以是列表\ndarray import numpy as np, pandas as pd arr1 = np.arange(10) s1 = pd.Series(arr1) print(s1) #由于我们没有为数据指定索引，于是会自动创建一个0到N-1（N为数据的长度）的整数型索引 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 第一个参数可以是字典，字典的键将作为Series的索引第一个参数可以是DataFrame中的某一行或某一列 Series类型的操作 Series类型索引、切片、运算的操作类似于ndarray，同样的类似Python字典类型的操作，包括保留字in操作、使用.get()方法。
Series和ndarray之间的主要区别在于Series之间的操作会根据索引自动对齐数据。
DataFrame DataFrame是一个表格型的数据类型，每列值类型可以不同，是最常用的pandas对象。DataFrame既有行索引也有列索引，它可以被看做由Series组成的字典（共用同一个索引）。DataFrame中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）。
DataFrame的创建 pd.DataFrame(data,columns = [ ],index = [ ])：columns和index为指定的列、行索引，并按照顺序排列。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/605f6e46968098886fe59f615f0ecf3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b45249137406f8d9d21a9d426cf066/" rel="bookmark">
			Qt 编程 —— 字体对话框（QFontDialog）的使用 【学习笔记】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文档声明：
以下资料均属于本人在学习过程中产出的学习笔记，如果错误或者遗漏之处，请多多指正。并且该文档在后期会随着学习的深入不断补充完善。感谢各位的参考查看。
笔记资料仅供学习交流使用，转载请标明出处，谢谢配合。
如果存在相关知识点的遗漏，可以在评论区留言，看到后将在第一时间更新。
作者：Aliven888
1、简述 QFontDialog类是 Qt 提供的一个用于设置字体样式的对话框小部件。
2、使用详解 2.1、头文件 在使用字体对话框之前，需要调用如下头文件。
#include &lt;QFontDialog&gt; //字体对话框 2.2、使用演示 //成员函数介绍 //获取当前用户设置的字体样式 QFont getFont(bool *ok, const QFont &amp;initial, QWidget *parent = Q_NULLPTR, const QString &amp;title = QString(), FontDialogOptions options = FontDialogOptions()) QFont getFont(bool *ok, QWidget *parent = Q_NULLPTR) 代码演示： bool bFlag = true; QFont font = QFontDialog::getFont(&amp;bFlag); qDebug("当前选择的字体是[%s]-是否加粗[%d]-是否倾斜[%d]-字号[%d]", font.family().toUtf8().data(), font.bold(), font.italic(), font.pointSize()); 参数介绍：
bool *ok：true - 用户点击了确认按钮， false - 用户点击了取消按钮。
const QFont &amp;initial：默认字体样式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25b45249137406f8d9d21a9d426cf066/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b39a4c51379ef18f5b4939ca47948ee0/" rel="bookmark">
			HRNet剪枝记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一版github：https://github.com/vvhj/APRCP-HRNet-Adaptive-Pruning-Rate-Channel-Pruning-for-HRNet
目前公开模型压缩率为W48模型36%无损压缩。W32模型42%无损压缩。
最新工作进展：
W48模型60+%压缩率下性能有些许提升。相关进展请关注我的github和博客，有同志们能用到的话给小弟github赏一颗星呗，哈哈。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d3bc0c2e5f962eaaef71de9c263b4ab/" rel="bookmark">
			idea编译错误的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用IDEA开发工具,提示编译错误的问题。 比如 switch语句提示 incompatible types found java.lang.string, require:
byte, char, short or int，意思就是类型错误，不支持字符串类型。其实这个是java的语言级别没有设置好导致的问题，因为jdk1.7之前的版本是不支持switch的字符串类型的，所以我们只需要调整IDEA编译器的语言级别为1.7及以上级别即可。 1、报错：（switch里面是String类型）编译器提示类型错误
2、解决：
文件菜单File，然后点击Project Structure，打开项目结构对话框
在左边菜单列表点击project，右侧设置Project SDK，选择1.7及以上；Project language level一开始显示的当前语言级别是6，选择7及以上即可。
再点击Modules，然后设置Language level，这个是模块级别的语言设置，默认是随着项目级别变动的，如果之前手动修改过低级别的，这样就需要手动调整了。
以上设置完成之后，点击确定按钮，然后回到一开始代码编译报红的switch语句的地方，这个时候就不再报错了。String类型可以正常的被switch语句识别了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55066eb7b8ca1ac11337b1bff217a18a/" rel="bookmark">
			三维重建（SFM）：针对360全景切割图像的单目重建的增量问题的分析与改进（colmap）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		360摄像机街拍视频根据FOV切割5视角图片进行重建。
狭窄复杂街道，人群多，光影复杂，匹配度较差（核心问题是畸变造成的干扰过度，后续会加其他实验），图像匹配实验：https://blog.csdn.net/huqinweI987/article/details/108850821
使用colmap进行点云生成。
因为colmap的增量过程采用了分块模式，并且此模式在倾斜摄影中应用效果可接受，所以此功能被保留用于AR街景的场景重建。
分块本身对AR增量过程产生影响的典型情况示意图： 因为360图像采集、切割不当，图像畸变大，图像画幅低（而畸变大小和画幅大小在全景切割中是矛盾的），图像间特征匹配不佳，拓扑结构脆弱，分块容易导致图片间匹配关系的割裂。
分块后增量实验： 以742张图的第一块为例。
增量产生多块子模型的间接原因（某些场景会发生，但是根本还是Reconstruct过程）： 首次Reconstruct失败，产生0个manager，for循环，放宽参数继续重建（如成功，则size大于0，break）：
放宽的参数和负面作用：
放宽最小角度：容易产生噪声，产生无穷远点（其实三维重建，尤其街景的重建，不需要远点）
放宽最小内点数量：允许加入匹配更差的图，影响重建质量。
产生多个模型的直接原因： 启用了“多子模型”模式，一次性无法注册所有图片，且单个子模型满足下限，导致产出多个子模型。
上图，不注册所有图片无法break，下图，不break需循环指定次数才会结束
多模型模式下，最小模型size直接影响产出子模型数量和单个模型的规模，且参数数值固定
结果：并不能注册所有图片，而是产生多个注册图片很少的子模型，具体能利用多少，首先取决于一次初始化能否增量覆盖其他图，其次取决于各种阈值限制和允许的重试次数，一旦重试次数超限，且有任何子模型成立，增量重建过程结束。需要针对参数进行优化（最直观地，增加最小模型注册图限制，增加重试次数）
产生多个模型的根本原因： 360采集切割数据自身问题，现有参数设定和逻辑对AR应用场景的数据兼容性差。
实验：不同“最小模型注册图数”对产出模型的影响。 下图是一次重建结果，分别产出13、108、11图片数的子模型，目前不确定建出size=13的块与建出size=108的块的顺序颠倒是否可能影响互相的融合关系（先108，是否会直接产生108+13=121或更大的块，而不是割裂的）。根据局部增图和BA得流程猜测有影响（又或者，有更好的大块可以做增量基础，但是超过重试次数导致没有被发现）
调整参数(默认10)：options_-&gt;min_model_size = 100 结果可以一个模型注册所有块
所有图片被注册，也不需要放宽参数
只产生一个文件夹（对比，之前产生过三四个文件夹）
下图：对比，一次重建产生了0、1、2三个目录，本次产生0一个目录
作为对照，排除干扰，直接使用原有分块结果，不重新分块。
调整参数(默认10)：options_-&gt;min_model_size = 10 不能完成所有图片的注册，产生4个子模型，丢图数=742-19-14-20-11=678，极其烂的结果
结束是因为超过10次重建重试（也可修改此参数，对于此场景，是很应该改的）
重建结束后，（分块的）合并过程会使用其中最大的（20张图）子模型，导致丢图722张。
针对上次实验（最大20）的结果，做一个修补尝试，修改阈值为30： 产出单个模型742张图，不丢图！证明阈值更改有效！拉高阈值能促进寻找更好的优化起点，结果子模型不是从20变30，而是直接变成742全图。
文件大小对比： 一次成型结果 多个子模型结果 结论与方案： 但是，这个方案只是基于已有数据质量前提下的优化，根本问题是数据的质量和关联度。其实想把模型建好，主要还是依赖行进方向的关联度，这样才能把图片串起来。
我会单独写一篇实验总结。https://blog.csdn.net/huqinweI987/article/details/109497931
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76a7b4d3da9fc5058d566dedeb82f22a/" rel="bookmark">
			github请求超时_使用危险js和github操作自动执行常见的请求请求反馈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github请求超时
One of the things I love about software engineering is that if I find myself doing a task often, I can instead choose to invest the time in automating it to save time in the long term.
我喜欢软件工程的一件事是，如果我发现自己经常执行某项任务，那么我可以选择花费时间进行自动化，以长期节省时间。
I have used this technique across many things both inside the workplace and at home.
我已经在工作场所和家里的许多地方使用了此技术。
One such example of when I have automated something was when I wanted to buy a particular house.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76a7b4d3da9fc5058d566dedeb82f22a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6ce994726500030e3d8db440c06701b/" rel="bookmark">
			vc sne和t sne是我的邻居
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Many dimensionality reduction techniques attempt to preserve distances of the original data. However, it can be beneficial to focus on preserving the nearest neighbours for visualization. t-SNE[van der Maaten/Hinton 2008] abstracts away density and distance information. Since it preserves the neighbours, it often reveals the cluster structure more clearly than any other dimensionality reduction technique. t-SNE is really popular in many applications including life science.
许多降维技术试图保留原始数据的距离。 但是，专注于保留最近的邻居以进行可视化可能是有益的。 t-SNE [van der Maaten / Hinton 2008]提取了密度和距离信息。 由于它保留了邻居，因此与其他降维技术相比，它通常更清楚地揭示出簇结构。 t-SNE在包括生命科学在内的许多应用中确实很受欢迎。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6ce994726500030e3d8db440c06701b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04e4c2d220c79c9455100cdd686b015d/" rel="bookmark">
			Web前端面试题-应用CSS样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、嵌入在HTML文档中的图像格式有哪些，都有些什么特点？
答案：ps： alpha透明是指使用alpha通道实现的透明
格式透明压缩动画颜色数浏览器兼容性特点GIF支持，但不是alpha透明无损支持8位全部支持简单动画，颜色少，有锯齿PNGalpha透明无损不支持8位和24位IE6不支持透明 压缩比高，色彩好，除了动
画，其余方面可替代GIF
JPEG不支持有损不支持24位全部支持 存储照片或颜色丰富的复杂
图像
APNGalpha透明支持支持8位和24位 Firefox和部分Chrome、Safari、
Opera支持，IE不支持
PNG格式的扩展，可替代GIFWEBPalpha透明 有损和
无损
支持24位 Chrome和Opera支持，IE、Safari
和Firefox不支持
更优的图像数据压缩算法
2、元素的布尔属性disabled和readonly有何区别？
答案：元素操作是指读取、写入等操作。Tab导航是指能否使用Tab键定位到该元素
属性元素外观元素操作获取焦点Tab导航表单提交元素支持disabled修改否否否没有发送数据 input、textarea、option、select
和button等元素
readonly维持是是是会发送数据input和textarea 3、请列举表格布局的弊端。
答案：表格布局主要有以下5方面的弊端。
可访问性差，表格布局中的内容从左到右和从上到下的读取并不总是有意义，并且还缺乏依赖关系，无障碍工具从这些文档中获取的数据会非常混乱，影响用户的浏览难以实现响应式，通常可用媒体查询对不同设备呈现适合的界面，但表格布局需要用单元格嵌套表格，而单元格之间的合并要用元素的colspan或rowspan属性，不能用CSS属性简单的设置可维护性差，表格布局需要使用大量的元素属性，并且表格之间需要相互嵌套。这使得代码难以阅读，特别是如果不缩进，标签没有层次感，更加难以理解代码的意图不够语义化，表格布局会用到大量的单元格，单元格（td、th）不像nav、header、footer等元素有明确的含义。语义化的界面既能保持代码整齐，又能提升搜索引擎优化加载速度慢，嵌套的表越多，文档就变得越臃肿，不但会加长网络传输的事件，而且也会增加渲染的时间 4、iframe元素有哪些缺点？
答案：iframe元素主要有4个方面的缺点
浏览器对同一域名的并发请求数是有限制的。 浏览器请求数Chrome/Firefox/Opera/Safari6IE 6/IE72IE8/IE96IE108UC Browser7 阻塞父窗口的load事件由于脚本的执行是同步和阻塞的，将script元素放置于iframe之前，会阻塞iframe中资源的请求制造点击劫持，将一个不可见的iframe或包括用户感兴趣内容的iframe覆盖在文档的某个位置上，诱使用户点击iframe中的内容 5、除了video和audio元素，HTML5还支持哪些其他的多媒体元素？
答案：HTML5还支持embed和track元素。embed元素用于嵌入外部资源，例如SVG矢量图形、应用程序或插件等。track元素是audio和video的子元素，为多媒体文件添加辅助文本信息，例如字幕、屏幕阅读器说明和主题等。在chrome浏览器中，可用WebVTT文件和track元素结合
6、canvas元素用属性和用CSS设置宽高有什么区别？
答案：可将canvas元素简单理解为两部分：容器和画布。CSS控制的是容器的尺寸，而属性控制的是画布的尺寸，绘图都是在画布上进行
7、用什么方法可以防止Cookie被盗取
答案：cookie是先由浏览器向服务器发起请求，再由服务器响应后回传Set-Cookie首部（此时可设置HttpOnly属性）向客户端浏览器写入Cookie。在给Cookie设置HttpOnly属性后，就能够禁止页面的JavaScript访问这个Cookie，从而避免被盗取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e883834e0573bd4c7c5203b11e6db5e7/" rel="bookmark">
			CloudCompare右边显示长方形色域图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上查了很多资料，发现都是有问题的，不是按钮没法点击就是根本没用，最后自己试出来了。
cloudcompare版本2.10.alpha
导入tif(注意有的图片没有Color Scale属性,无法显示颜色柱)图片，然后选择属性Color CScale,勾选Visible就可以了。
如果没有Color Scale属性，可以选择PLY的Mesh属性，依次设置Height Ramp-&gt;Convert To Scaler Field
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3253d1d76b5861ac74d70477746feaef/" rel="bookmark">
			【ros学习】12.ros启动gazebo时摄像头的发布进程被杀死，导致rqt_image_view无法显示画面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ros启动gazebo时摄像头的发布进程被杀死，导致rqt_image_view即使订阅了正确的话题也无法显示画面
原因是gazebo的版本过低，与Rviz不兼容。ubuntu16.04匹配的ros版本是kinetic，kinetic安装过程中会自动下载低版本的gazebo，然后RViz又是新版本的。
升级gazebo版本就可以了
参考：ubuntu16.04安装gazebo9
1.卸载gazebo7： sudo apt-get remove gazebo7 gazebo7-common gazebo7-plugin-base libgazebo7:amd64 libgazebo7-dev:amd64 2.添加源： sudo sh -c 'echo "deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main" &gt; /etc/apt/sources.list.d/gazebo-stable.list' 3. wget http://packages.osrfoundation.org/gazebo.key -O - | sudo apt-key add - 4. sudo apt-get update 5. sudo apt-get install gazebo9 6. sudo apt-get install ros-kinetic-gazebo9-ros-control 7. sudo apt-get install ros-kinetic-gazebo9-ros-pkgs 重新启动虚拟机，再开就可以看到摄像头画面了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ecb6a1fbcd04ea63f15ae7fd8adfd61/" rel="bookmark">
			JVM相关概念入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、JVM位置：
二、JVM体系结构：
垃圾回收器在执行引擎中，JVM调优一般都是在方法区和堆中；
三、类加载器：
作用：加载class文件；
1、虚拟机自带的加载器；
2、启动类（根）加载器；
3、扩展类加载器；
4、应用程序加载器；
当我们要使用某个类的时候，顺序是这样的，首先先去启动类加载器bootstrap找，如果有就直接用，如果没有就去扩展类加载器找，如果扩展类加载器没有，就去应用程序加载器找，如果还是没有，就报ClassNotFoundException异常。
双亲委派机制：
1、如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类加载器去执行；
2、如果父类加载器还存在其父类加载器，则会进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器。
3、如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式
优点：
1、避免类的重复加载
2、保护程序安全，防止核心API被随意篡改
沙箱安全机制：防止恶意代码污染java源代码
比如我定义了一个类名为String所在包为java.lang，因为这个类本来是属于jdk的，如果没有沙箱安全机制的话，这个类将会污染到我所有的String,但是由于沙箱安全机制，所以就委托顶层的bootstrap加载器查找这个类，如果没有的话就委托extsion,extsion没有就到aapclassloader，但是由于String就是jdk的源代码，所以在bootstrap那里就加载到了，先找到先使用，所以就使用bootstrap里面的String,后面的一概不能使用，这就保证了不被恶意代码污染。
四、方法区
静态变量，常量，类信息（构造方法、接口定义），运行时的常量池，即static、final、Class、常量池存在方法区中，但是实例变量存在堆内存中与方法区无关。
五、堆和栈
1、堆区：
存储的全部都是对象，每个对象包含了一个与之对应的 class 类的信息。
一个JVM只有一个堆内存，它会被所有线程共享，堆中不存放基本数据类型和对象引用，它只存放对象本身，堆内存的大小是可以调节的。
类加载器读取了类文件后，一般会把类、变量、方法、常量放到堆中，保存所有引用类型的真实对象。
堆内存细分为三个区域：
新生区（伊甸园区 Eden Area）； 养老区； 永久区； GC垃圾回收主要是在伊甸园区和养老区；
假设内存满了，报OOM（OutOfMemory）异常，堆内存不够！
新生区：
类诞生、成长、死亡的地方；
伊甸园区：所有的对象都是从伊甸园区new出来的；
幸存者区（0，1）
永久区：
这个区域是常驻内存的，用来存放JDK自身携带的class对象，Interface元数据，存储的是Java运行时的一些环境或类信息，这个区域不存在垃圾回收，关闭VM虚拟就会释放这个区域的内存。
当一个启动类加载了大量的第三方jar包，TomCat部署了太多的应用，大量动态生成的反射类，不断的被加载，直到内存满就会出现OOM。
在JDK1.6之前：有永久代，常量池在方法区中；
JDK1.7：有永久代，但是慢慢退化了，形成了“去永久代”，常量池在堆中；
在JDK1.8之后：无永久代，常量池在元空间；
2、栈内存，主管程序的运行，生命周期和线程同步；线程结束，栈内存也就释放，对于栈来说不存在垃圾回收问题 ，一旦线程结束，栈就自动销毁。
栈中存放：8大基本类型+对象的引用+实例方法
3、栈和堆的区别：
栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。
JAVA对象在内存中实例化的过程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c568fc25608810da285f3a919ab04918/" rel="bookmark">
			079-mxd-冒险岛-自主学习搭建-单机联机都可以，详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多小伙伴想在自己的电脑上怀旧，可是又不会搭建，我今天就出一个简单的教程，全部自动化，不需要太多的配置，把文件下载下来运行脚本就可以了，接下来就开始吧！！！！！！！！！！！！！！！！！！！！
附上地址：https://github.com/iamxiaohuihui
(如果进不去网站的同学可以移步到群里自行下载)
1、随便找个（没有中文的）目录，然后新建一个目录mxd
2、进入到mxd目录下面
3、把代码下载下来
点进去，就像这样下载
下载好了放在刚才那个mxd文件下面 ，解压 --------------------------别忘了那个scripts 也要这样下载解压哦
友情提示：全部解压完成后是这样的
接下来进入到maple文件夹中，是这样的
我写好了脚本，直接双击就能运行了
第一步双击那个 【 初始化(只需要执行一次就可以了).exe 】 ，执行完之后是这样的
！！！！记住这个只需要执行一次就可以了哦！！！！ 不过就算你再执行也没关系的，哈哈哈
接下来就双击运行 【startServer.exe】 就可以了，长这样
ok~~~~
这样服务端就启动完成了，接下来进入游戏就可以了
如果还有问题可以在裙里聊哦，
裙：917544648
视频教程如下：
B站：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b571a8aabda41897cf90b681f5b126e1/" rel="bookmark">
			if cv2.waitKey(1) &amp; 0xFF == ord(‘q‘): break的解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，cv2.waitKey(1) &amp; 0xFF将被执行，等待用户按1ms。
如果用户按，例如，q，那么q的waitKeyreturnDECIMAL VALUE是113。在二进制中，它表示为0b01110001。接下来，执行AND运算符，两个输入分别是0b01110001和0xFF（0b111111111）。0b01110001AND0b11111111=0b01110001。确切的结果是DECIMAL VALUE的q
其次，将左表达式0b01110001的值与ord(‘q’)进行比较。显然，这些值与另一个值相同。最后的结果是break被调用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcd9522c28329a4744d0004bd09d9a2a/" rel="bookmark">
			用Github Pages&#43;Hexo搭建博客之(七)如何删除一篇已经发布的文章 #成功解决：同时删除掉.deploy_git文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【置顶】【专栏】用Github Pages+Hexo搭建博客 文章目录 【置顶】【专栏】[用Github Pages+Hexo搭建博客](https://blog.csdn.net/qq_34243930/category_9662425.html)起因解决步骤总结具体步骤如下原因分析 起因 我删除了文件夹source/_posts下想要删掉的文章之后，执行hexo clean，hexo g，hexo g 发现文章还是在网页里，删除失败了。
解决步骤总结 1、删除文件夹source/_posts下目标文章markdown文件
2、删除.deploy_git文件夹
3、执行hexo clean后，再执行hexo g，hexo g 即可。
具体步骤如下 第一步，去文件夹source/_posts下删除你想要删除的文章
第二步，删除.deploy_git文件夹
.deploy_git是git部署用的文件。当你为 git 部署选项运行hexo d命令时，Hexo 会创建一个名为.deploy_git的文件夹，并将生成的文件复制到该文件夹​​。
第三步，执行hexo clean后，再执行hexo g，hexo g 即可。
发现文章删除成功✔ 原因分析 因为在本地在执行hexo g后，会在博客根目录下生成一个public文件夹，这个文件夹里的文件组合起来就是一个完整的静态博客。
接着如果执行hexo d，就会把这个public文件夹的东西完完整整地拷贝到.deploy_git文件夹里，并把该文件夹里的所有文件全部推送push到远程库。
之后会触发Pages服务的钩子去build项目，然后部署到网站上。
markdown文章在之前的hexo g之后，把生成的静态文件拷贝到了.deploy_git文件，但hexo clean并没能删除·.deploy_git·里的markdown的静态文件，所以每次部署的时候，它还会冒出来。
所以同时删掉.deploy_git文件夹即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/078c0e87ada0994c01edb09ddeff3c3e/" rel="bookmark">
			python解决上n级台阶问题，步长为3k&#43;1，k为任一自然数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem 竺竺为了追求漂亮温柔的学姐，决定走到学姐所在的第n级平台上，由于他心情欢快连跑带跳，他一次只能向上走1,4,7,10…(即3n+1)级台阶。竺竺想知道他有多少种方法走上这n级台阶，你能帮帮他吗？
Input 一行一个整数n（n&lt;=10000），表示一共有n级台阶。
Output 一行一个整数，表示竺竺上台阶的方案数，结果对100003取余。
Sample Input 5
Sample Output 3
初步想法 def count(n)，计算上n级台阶的方案数；
所有的方案按照最后一步的走法分类；
最后一步可能走1，4，7……，m；m是数列{3k+1}中不大于n的最大项；
那么按照加法原理：
c o u n t ( n ) = c o u n t ( n − 1 ) + c o u n t ( n − 4 ) + … … + c o u n t ( n − m ) count(n)=count(n-1)+count(n-4)+……+count(n-m) count(n)=count(n−1)+count(n−4)+……+count(n−m)
代码一 def count(n): if n%3==0: #先求得m m=i-2 elif n%3==1: m=i else: m=i-1 if n&lt;4: return 1 #递归出口 else: s=sum([count(n-i) for i in range(1,m+3,3)]) #递归 return s%100003 n=int(input()) print(count(n)) 输入：50 输出：13886 耗时：54.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/078c0e87ada0994c01edb09ddeff3c3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9af2b7a3f9bb3d2d47f2e5a3dcf2b75f/" rel="bookmark">
			Java中的方法重载和方法重写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法重载（Overload）：一个类中定义多个相同名称的方法。
要求：1 方法名称相同。
2 参数列表不同（类型、个数、顺序）。
3 与访问修饰符、返回值类型无关。
方法重写（Override）：
要求：1 方法名称、参数列表、返回值类型必须与父类相同。
2 访问修饰符可与父类相同或是比父类更宽泛。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5b3eacac9b8b1b0da307ec28083727d/" rel="bookmark">
			【ros学习】11.ros建模时遇到No transform from [back_caster_link] to [base_link]不显示轮子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		踩的坑，搜了好久才发现问题所在
建模时说No transform from [back_caster_link] to [base_link]
原因是启动文件里的joint_state_publisher节点没有启动，它是用来发布机器人的关节状态的
因为我们缺少这个功能包，当然无法启动这个节点
sudo apt-get install ros-xxx-joint-state-publisher-gui
xxx替换为当前ros版本 kinetic indigo melodic 安装后再重新启动就有了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc3b6a3f5a5f3d9b78a4abdee2e79472/" rel="bookmark">
			主机ping不了虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：虚拟机是程序员平时练习与开发经常要用到的工具，平时经常会有本机与虚拟机连接、传输等需求，比如本机与虚拟机文件共享，本机与虚拟机网络连接（ssh连接，web访问虚拟机服务等等）。这篇文章记录的问题是，主机访问不了虚拟机的web服务，ssh也连接不上，ping都ping不同，初步判断是虚拟机的IP地址换了（如果没有配静态IP的话），但查看了IP发现没有换，第二次判断是虚拟机开启了防火墙，把80和22端口屏蔽了，但是想想不应该呀，web服务和ssh连接不上还可能是因为防火墙的问题，但是ping都ping不通，所以排除是防火墙的原因，最后查阅资料才初步定为是网段不同的原因。
环境：Win10、VMware Workstation Pro工具
现象：主机连不了虚拟机的centos系统，也ping不通IP
原因：主机与虚拟机不在同一网段
解决办法：修改VMware Network Adapter VMnet8为自定义IP地址，与虚拟机一致，如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7647398a62ed0b6f7830c1e9f9d8e12/" rel="bookmark">
			操作系统之文件管理：2、文件的逻辑结构(有结构文件、无结构文件、顺序文件、索引文件、索引顺序文件)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2、文件的逻辑结构 思维导图逻辑结构VS物理结构文件的逻辑结果分类1、无结构文件2、有结构文件按照记录的长度来分：按照逻辑结构来分：1、顺序文件问题：能否实现随机存取? 2、索引文件3、索引顺序文件 梳理： 思维导图 逻辑结构VS物理结构 文件的逻辑结构和物理结构可直接类比于线性表的逻辑结构和物理结构
文件的逻辑结果分类 1、无结构文件 2、有结构文件 按照记录的长度来分： 按照逻辑结构来分： 1、顺序文件 1、顺序文件：逻辑上一个接一个排列，可以类比于线性表
2、顺序文件可以以顺序存储的方式存储，类比于顺序表；也可以用链式存储的方式存储，可以类比于链表
3、顺序文件有两种结构：串结构和顺序结构；主要的区别是关键字的顺序和记录的顺序是否一致；
4、问题：已经知道了文件的起始地址（也就是第一个记录存放的位置），能否快速找到第 i 个记录对应的地址？（即能否实现随机存取）
问题：能否实现随机存取? 上图中给出结果：
1、当记录变长时，由于每条记录长度不同，我们就没法用一种特定的规律来直接计算想要的记录的地址
2、当记录定长时，且采用串结构存储时，无法随机查找到某个关键字的位置，但是可以随机查找到某个记录的位置
3、当记录定长时，且采用顺序结构存储时，可以随机查找到某个关键字的位置，但是可以随机查找到某个记录的位置
2、索引文件 建立索引与记录一一对应关系，又因为索引表是定长的顺序文件，所以，在索引表上可以实现随机存取，因此可以快速找到第 i 个记录对应的索引项。
3、索引顺序文件 顺序索引文件区别与索引文件的地方在于：并不是每一个数据项都建立一个索引表项，这样也可以极大的提高效率。例如：
对于上图中的问题：当记录很多很多时查找的效率仍然不高，因此根据索引表的思想，可以继续建立二级索引表来提高查找效率
梳理： 上述有点结构太乱，梳理一下
随机查找：是指否可以直接找到某记录，例如，可以直接用地址找到数组下标为i的值，而不需要从数组开始顺序访问
快速查找：指是否可以用高效的查找算法进行查找，例如冒泡、折半等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e36c247f390873fe33e66841689e4e07/" rel="bookmark">
			220V降5V芯片，220V降12V电源芯片模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 220V降5V芯片，220V降12V电源芯片模块 220V降5V芯片，220V降12V芯片，交流220V降直流12V芯片，220V降12V高压降压IC，220V降12V智能开关电源芯片，220V降12V非隔离降压IC，交流220V降直流12V芯片，220V降12V智能电表电源芯片，220V降12V小家电专用芯片，220V降5V降压IC，220V降5V电源IC
超宽电网电压范围输入，内部集成650V高压功率开关MOS
专为BUCK降压转换器设计
采用PMW工作模式
极低的待机功率和极高的转换效率
满足能源之星5级能效要求 极少外围器件
可工作于380Vac超宽电网电压范围
应用 小家电控制电源板
非隔离电源供电
智能家电
开关非隔离电源产品
应急灯产品
概述 电路简单、BOM成本低（外围元件简单：无需变压器、光耦）,电源体积小、无音频噪音、损耗小发热低。输出可调5V(3.3~38V) 保护功能：VDD欠压保护、逐周期电流限制、输出过压保护、过热保护、过载保护和 VDD 过压保护
参数秦s134.8012.0665 输入电压： 20 -400v
输出电压 : 3.3V-36V
输出 电流 : 500mA
输出功率 : 0.8W
保护功能 : 过热 过载 过压 欠压 短路保护
工作环镜 : -10℃~+60℃ 20%~90%
储存环境 :-20℃~+85℃
ADD开启电压 :7.5V
VDD 工作电流 :60KHZ 800LIA
内部软启动时间 :3ms
开关频率 :46-60KHZ
MOSFET击穿电压: 650V 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed12aea91936c31d8e48ab0e9ea2c99b/" rel="bookmark">
			sqlserver扩展函数使用dll
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建类库 namespace Core { public static class Globals { public static string test(string name) { return name; } } } 2.启用CLR功能，不同版本默认开启与否不一样。 exec sp_configure 'clr enabled',1 reconfigure 3.sql创建程序集 CREATE ASSEMBLY testHelloWorld FROM 'C:\Core.dll' 4.创建函数 CREATE FUNCTION dbo.HelloWorld ( @name as nvarchar(200) ) RETURNS nvarchar(200) AS EXTERNAL name testHelloWorld.[Core.Globals].test 5.调用函数 SELECT dbo.HelloWorld('hello world') 6.执行结果
未命名1hello world ALTER ASSEMBLY testHelloWorld FROM 'C:\test.dll'这句可以将最新版本的程序集注册到数据库中.
也可以删除程序集DROP ASSEMBLY testHelloWorld之后再执行CREATE ASSEMBLY testHelloWorld from 'C:\test.dll'语句
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee78dfb44d5195c6fd35989e94351bf3/" rel="bookmark">
			编写一个能实现移位密码的小程序，对输入的明文字符串进行移位加密后打印输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本关任务：编写一个能实现移位密码的小程序，对输入的明文字符串进行移位加密后打印输出。
相关知识
移位加密是密码学中一种非常经典、也是很重要的加密方法，学好移位加密对后面其他加密方法的学习有着至关重要的作用。
为了完成本关任务，你需要掌握：
1.数论中的模运算；
2.定义模 m 上的运算；
3.移位密码体制。
模运算知识补充
假设a和b均为整数，m是一正整数。若m整除b−a，则可将其表示为：
a≡b(mod m)
该式读作“a与b模m同余”，正整数m称为模数。
下面给出计算一组数据中符合指定模数的同余的数字对，具体 C++ 代码示例如下：
constexpr int mod=9; // 模数 mod 取值为9
int a[10]= {2,11,12};
for(size_t i=1; i&lt;3; i++) // 循环遍历数组 a 中所有的数字对
if((a[i]-a[i-1])%mod==0) // 判断mod是否可以整除两数之差
cout&lt;&lt;a[i-1]&lt;&lt;“与”&lt;&lt;a[i]&lt;&lt;“模”&lt;&lt;mod&lt;&lt;“同余”&lt;&lt;endl;
输出：
2与11模9同余
上述代码通过遍历数组 a 中的所有数字对，判断模数能否整除数字对中两数之差，从而找出符合条件的数字对。
模上的运算
通俗的理解，模 m 上的运算就是：在模 m 的集合上定义加法和乘法，下面给出具体定义。
令Z
m
​ 表示集合{0,1,…,m-1}，在其上的加法和乘法运算类似于普通实数域上的加法和乘法，所不同的只是所得的值是取模以后的余数。具体运算法则如下：
1.对加法运算封闭：对任意的a,b∈Z
m
​ ，有a+b∈Z
m
​ 。
2.加法运算满足交换律：对任意的a,b∈Z
m
​ ，有a+b=b+a。
3.加法运算满足结合律：对任意的a,b,c∈Z
m
​ ，有(a+b)+c=a+(b+c)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee78dfb44d5195c6fd35989e94351bf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fe8b8927aa3f462d7aefa88fa6b0b9d/" rel="bookmark">
			使用Curlftpfs挂载远程Ftp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 安装curlftpfs
sudo apt-get install curlftpfs 2 挂载
sudo curlftpfs -o codepage=gbk ftp://username:password@192.168.0.2 /mnt 3.取消挂载
取消挂载umount /mnt 挂载时候也可以直接挂在具体的位置 curlftpfs -o codepage=utf8 ftp://user:passwd@ip:port/path /mnt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63c992a611a86bc4360526172245b1cb/" rel="bookmark">
			使用Cartool工具包分析EEG源成像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Cartool工具包分析EEG源成像 1 基本要求1.1 EEG预处理 (EEG Pre-processing)1.2 时间过滤 (Temporal Filtering)1.3 下采样（降低采样率） (Down-Sampling)1.4 电极插值与ICA (Electrode Interpolation and ICA)1.5 空间过滤 (Spatial Filtering)1.6 检测不良时段 (Detecting Bad Epochs) 2 构建头部模型2.1 MRI处理 (MRI Processing)2.2 重采样和重定位 (Re-sampling and Re-orientation)2.3 颅骨分离和偏压校正 (Skull-Stripping and Bias Field Correction)2.4 灰质提取 (Gray Matter Segmentation)2.5 检测灰质中的解点 (Determining the solution point in the Gray Matter) 3 电极数量及位置3.1 电极布置 (Electrode Layout)3.2 三维电极位置 (3D Electrode Positions)3.3 MRI头部电极的协同配准 (Co-registration of the Electrodes on the MRI Head) 4 计算导程电场4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63c992a611a86bc4360526172245b1cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88b2360ca31f465da4da07870d67f297/" rel="bookmark">
			Vue基础-2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue基础-2 1.表单修饰符
.number 转换为数值**(表单中输入的值为字符串类型，number可将其转换为数字类型)**.trim 自动过滤用户输入的首尾空白字符，只能去掉首尾的 不能去除中间的空格.lazy 将input事件切换成change事件（在表单校验时使用）在失去焦点 或者 按下回车键时才更新 &lt;!-- 自动将用户的输入值转为数值类型 --&gt; &lt;input v-model.number="age" type="number"&gt; &lt;!--自动过滤用户输入的首尾空白字符 --&gt; &lt;input v-model.trim="msg"&gt; &lt;!-- 在“change”时而非“input”时更新 --&gt; &lt;input v-model.lazy="msg" &gt; 2.计算属性 computed
模板中放入太多的逻辑会让模板过重且难以维护 使用计算属性可以让模板更加的简洁计算属性是基于它们的响应式依赖进行缓存的computed比较适合对多个变量或者对象进行处理后返回一个结果值，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化 &lt;div id="app"&gt; &lt;!-- 当多次调用 reverseString 的时候 只要里面的 num 值不改变 他会把第一次计算的结果直接返回 直到data 中的num值改变 计算属性才会重新发生计算 --&gt; &lt;div&gt;{{reverseString}}&lt;/div&gt; &lt;div&gt;{{reverseString}}&lt;/div&gt; &lt;!-- 调用methods中的方法的时候 他每次会重新调用 --&gt; &lt;div&gt;{{reverseMessage()}}&lt;/div&gt; &lt;div&gt;{{reverseMessage()}}&lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; /* 计算属性与方法的区别:计算属性是基于依赖进行缓存的，而方法不缓存 */ var vm = new Vue({ el: '#app', data: { msg: 'Nihao', num: 100 }, methods: { reverseMessage: function(){ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88b2360ca31f465da4da07870d67f297/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e6438e5a130029c03d052437125847e/" rel="bookmark">
			Eclipse、Tomcat安装配置及部署教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想用Tomcat作为服务器，必须分以下两步。首先要配置好JDK的环境变量，再去下载Tomcat的压缩包。
下载、安装JDK，并且配置好环境变量 1、打开浏览器，输入JDK搜索，根据搜索结果下载安装包安装应用
2、先接受协议，再根据自己的电脑下载相应的JDK版本，默认安装就行了。
3、配置环境变量。找到安装路径，默认安装的一般都是在这个路径下
C:\Program Files\Java\jdk1.8.0_77
最好改一下安装路径，避开C盘。
4、然后点击电脑开机键，打开控制面板
5、然后点击系统安全，打开进入
6、点击系统
7、点击“高级系统设置”
8、点击高级中的“环境变量”
9、在下面的系统变量中点击“新建”
10、新建JAVA_HOME、CLASSPATH这两个项，最后在path中添加上去就完成了
11、新建CLASSPATH，变量值 .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar，注意前面有个点的
12、将这两个变量加到path里面，直接在后面添加 ;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin，注意前面要有个分号“;”
13、变量操作界面点击确定关闭
14、系统高级设置页面点击“确定”关闭
15、两个变量配置好了，到时直接可以在控制台编译运行Java文件，运行cmd查看Java环境是否配好。
16、输入javac，按回车键，出现下面这些说明编译环境配好了
17、再输入java，按回车键，出现下面这些，说明运行环境也好了。
Apache Tomcat下载、安装、配置图文教程 1、Tomcat下载
（1）Tomcat官网：Tomcat官方网址，可以在此处下载Tomcat。
（2）点击左侧Download下的对应版本。
注意有zip和exe两种格式的，zip是免安装版的，exe是安装版。同时观察自己的电脑是64位系统还是32位系统。
例如进入：Tomcat 9 版本下载页面，下滑，到core处选择自己需要的版本，如图所示：
我的电脑是64位，可以直接选择32-bit/64-bit Windows Service installer(pgp,md5,sha1)，点击即可选择下载位置，点击下载，此处选择下载的是exe安装版本。若想下载免安装版本的，选择下载64-bit Windows zip(pgp,md5,sha1)。
2、Tomcat安装
2.1 exe版本安装
1、从下载位置双击下载的zip
点击next；
2、同意安装协议：即点击I Agree
3、点开Tomcat，选中Service，以后将可以在管理的服务中启动和关闭Tomcat（也可以默认，不改变配置），点击next
4、出现管理提示框，要求输入端口和管理密码，保持默认设置就行。默认的端口号就是8080，这里一般不用设置。点击Next。
5、点击Next后会出现下图，它会自动找到JRE位置，如果用户没有安装JRE，可以修改指向JDK目录（很多用户安装后无法编译JSP，就是这里没找到JRE，请务必先要安装JDK，并把这个目录正确指向JRE或者JDK的目录）。
6、点击next，之后会出现Tomcat安装路径选择，一般默认安装到C盘，可以直接把C改成D，没有的文件夹会自动创建。修改完毕后点击Install。
7、安装完毕，点击finish。
8、打开浏览器 键入 http://localhost:8080 进入如下页面则表示安装成功：
2.2 zip版（免安装版本）
直接解压缩，找到目录bin下的startup.bat，启动Tomcat；shutdown.bat：关闭Tomcat。
3、Tomcat配置
配置Tomcat之前要保证jdk已经配置完成。
右击，计算机——属性——高级系统设置——打开环境变量的配置窗口，在系统环境变量一栏点击新建。变量名为TOMCAT_HOME，变量值为Tomcat安装目录，此处为：D:\Program Files (x86)\Apache Software Foundation\Tomcat 9.0。点击确定即可。
Tomcat环境变量配置：
如果你的Tomcat安装在C盘里，如：C:\Program Files\Apache Software Foundation\Tomcat 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e6438e5a130029c03d052437125847e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79f7b94bc4851d7b4cba3955fd648973/" rel="bookmark">
			Ubuntu18.04版本的Docker的坑  汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu18.04版本的Docker的坑 汇总 1、Docker获取镜像报错docker: Error response from daemon **docker: dial tcp: lookup auth.docker.****io: Temporary failure in name resolution.**See ‘docker run --help’. 一、问题 docker search sameersbn Error response from daemon: Get https://index.docker.io/v1/search?q=sameersbn&amp;n=25: dial tcp: lookup index.docker.io on 192.168.65.1:53: read udp 192.168.65.2:45190-&gt;192.168.65.1:53: i/o timeout ➜ ~ docker pull sameersbn Using default tag: latest Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) ➜ ~ 二、处理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79f7b94bc4851d7b4cba3955fd648973/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c093cd78406f84564c12e869a4eeb1c/" rel="bookmark">
			（吴恩达课后编程作业）Course 1 - 神经网络和深度学习 - 第二周作业01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		吴恩达课后编程作业）Course 1 - 神经网络和深度学习 - 第二周作业 环境准备下载资料安装库显示图片查看数据集情况数据维度转换标准化数据定义sigmoid函数初始化参数w和b了计算成本函数优化函数预测函数整合到model函数中画图测试某张图片进一步研究最后使用非数据集的图片进行测试 首先进行数据处理
然后建立神经网络，主要步骤是：
定义模型结构（例如输入特征的数量）
初始化模型的参数
循环：
3.1 计算当前损失（正向传播）
3.2 计算当前梯度（反向传播）
3.3 更新参数（梯度下降）
环境准备 pycharm+anaconda
我是用pycharm 还有anaconda的python3.7
下载资料 【中文】【吴恩达课后编程作业】Course 1 - 神经网络和深度学习 - 第二周作业
我是从这位博主的下载的，也是基于他的教程写下这篇文章，主要还是记录自己的学习过程；
安装库 首先新建一个project，把下载的东西解压到project里
numpy ：是用Python进行科学计算的基本软件包。h5py：是与H5文件中存储的数据集进行交互的常用软件包。matplotlib：是一个著名的库，用于在Python中绘制图表。lr_utils ：在本文的资料包里，一个加载资料包里面的数据的简单功能的库。 在anaconda的环境中直接搜索安装就可以
或者创建main.py
添加
import numpy as np import matplotlib.pyplot as plt import h5py from lr_utils import load_dataset 如果报错就按提示安装
显示图片 打开lr_utils.py看看
- train_set_x_orig ：保存的是训练集里面的图像数据（本训练集有209张64x64的图像）。 - train_set_y_orig ：保存的是训练集的图像对应的分类值（【0 | 1】，0表示不是猫，1表示是猫）。 - test_set_x_orig ：保存的是测试集里面的图像数据（本训练集有50张64x64的图像）。 - test_set_y_orig ： 保存的是测试集的图像对应的分类值（【0 | 1】，0表示不是猫，1表示是猫）。 - classes ： 保存的是以bytes类型保存的两个字符串数据，数据为：[b’non-cat’ b’cat’]。 在main文件中添加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c093cd78406f84564c12e869a4eeb1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/489931594ae4e95991ce8c6904157d8d/" rel="bookmark">
			说说在 Spring Boot 中如何整合与配置 log4j2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 引入 log4j2 首先打开 pom.xml ，然后排除掉 Spring Boot 2 所默认使用的日志组件 log-back，接着引入 log4j2：
&lt;!--log4j2--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; 2 配置 log4j2 在工程目录的 resources/ 下，新建 log4j2.xml（如果取名为 log4j2-spring.xml，单元测试时会找不到 log4j2 配置）：
log4j2 的日志级别以及优先级排序为： OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL。
2.1 配置 Configuration 配置时会首先使用 Configuration 标签，它有以下这些常用属性：
属性名说明name配置名称status记录到控制台的内部Log4j事件的日志级别，可选值为“trace”，“debug”，“info”，“warn”，“error”和“fatal”monitorInterval配置文件更新检查时间间隔（以秒为单位） 2.2 Properties 然后使用 Properties 标签，定义好常量。形如：
&lt;Property name="LOG_PATH"&gt;xxx&lt;/Property&gt; 定义好后，就可以在后续的 pattern 中这样引用 ${LOG_PATH}。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/489931594ae4e95991ce8c6904157d8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60deebac2228527dc67fe83b4e495a09/" rel="bookmark">
			numpy中数组合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要对numy的数组进行合并，做以下整理：
目录
1、"+"合并
2、append
3、concatenate
1、"+"合并 c1 = ["Red","Green","Blue"] c2 =["Orange","Yellow","Indigo"] c3 = c1 + c2 =&gt; c3 ==["Red","Green","Blue","Orange","Yellow","Indigo"] 2、append 特点：可读性好，比较灵活，但是占内存大（主页复制）。参数形式如下：
1）不同维度数组合并，未指定axis
import numpy as np a = np.array([1, 2, 3]) b = np.array([[4, 5, 6], [7, 8, 9]]) c = np.append(a, b) # 结果合并为一行 print("c =", c) 2）不同行、相同列数，同纬度，按列合并axis=0
import numpy as np a = np.array([[1, 2, 3]]) b = np.array([[4, 5, 6], [7, 8, 9]]) c = np.append(a, b, axis=0) # 结果合并三行 print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60deebac2228527dc67fe83b4e495a09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8575146a675e5fea0dd129ce9d640cbd/" rel="bookmark">
			《视觉SLAM十四讲》详细笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《视觉SLAM十四讲》笔记摘抄 ch02 初识SLAM 经典视觉SLAM框架SLAM问题的数学表述ch03 三维空间刚体运动 旋转矩阵 点和向量,坐标系坐标系间的欧氏变换变换矩阵与齐次坐标齐次坐标(Homogeneous Coordinate)的优势 优势1:方便判断是否在直线或平面上优势2:方便表示线线交点和点点共线优势3:能够区分向量和点优势4:能够表达无穷远点优势5:能够简洁的表示变换旋转向量和欧拉角 旋转向量欧拉角四元数 四元数的定义用单位四元数表示旋转ch04 李群与李代数 李群与李代数基础 群的定义李代数的定义李代数 s o ( 3 ) \mathfrak{so}(3) so(3)李代数 s e ( 3 ) \mathfrak{se}(3) se(3)李群与李代数的转换关系:指数映射和对数映射 S O ( 3 ) SO(3) SO(3)和 s o ( 3 ) \mathfrak{so}(3) so(3)间的转换关系S E ( 3 ) SE(3) SE(3)和 s e ( 3 ) \mathfrak{se}(3) se(3)间的转换关系李代数求导: 引入李代数的一大动机就是方便求导优化 李群乘法与李代数加法的关系S O ( 3 ) SO(3) SO(3)上的李代数求导 李代数求导扰动模型(左乘)S E ( 3 ) SE(3) SE(3)上的李代数求导ch05 相机与图像 针孔相机模型畸变模型单目相机的成像过程ch06 非线性优化 状态估计问题 最大后验与最大似然最小二乘 基于观测数据 z z z的最小二乘基于观测数据 z z z和输入数据 u u u的最小二乘非线性最小二乘 一阶和二阶梯度法高斯牛顿法列文伯格-马夸尔特方法ch07 视觉里程计01 特征点匹配 特征点根据特征点匹配计算相机运动 2D-2D匹配: 对极几何 对极约束本质矩阵 E E E的求解对极几何的讨论3D-2D匹配: PnP(Perspective-n-Point) 直接线性变换(DLT): 先求解相机位姿,再求解空间点位置P3P: 先求解空间点位置,再求解相机位姿Bundle Adjustment: 最小化重投影误差,同时求解空间点位置和相机位姿3D-3D匹配: ICP SVD方法非线性优化方法 ch02 初识SLAM 经典视觉SLAM框架 视觉SLAM流程包括以下步骤:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8575146a675e5fea0dd129ce9d640cbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa0bad82d3f7599ec47064431233347/" rel="bookmark">
			python中os.path.isdir()和os.path.isfile()的正确用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先介绍一下os.listdir()方法，此方法返回一个列表，其中包含有指定路径下的目录和文件的名称
import os dirct = '/home/workespace/notebook/' for i in os.listdir(dirct): print(i) redis study_test.ipynb mnist_dataset .ipynb_checkpoints yaml-tool sweetwater makeyourownneuralnetwork Untitled.ipynb AI-Practice-Tensorflow-Notes working cornfield os.path.isdir()和os.path.isfile()需要传入的参数是绝对路径，但是os.listdir()返回的只是一个某个路径下的文件和列表的名称.
常见错误：直接使用os.listdir()的返回值当做os.path.isdir()和os.path.isfile()的入参
正确用法：需要先使用python路径拼接os.path.join()函数，将os.listdir()返回的名称拼接成文件或目录的绝对路径再传入os.path.isdir()和os.path.isfile().
os.path.join()用法：
''' 遇到问题没人解答？小编创建了一个Python学习交流QQ群：778463939 寻找有志同道合的小伙伴，互帮互助,群里还有不错的视频学习教程和PDF电子书！ ''' import os dirct = '/home/workespace/notebook/' for i in os.listdir(dirct): fulldirct = os.path.join(dirct,i) print(fulldirct) /home/workespace/notebook/redis /home/workespace/notebook/study_test.ipynb /home/workespace/notebook/mnist_dataset /home/workespace/notebook/.ipynb_checkpoints /home/workespace/notebook/yaml-tool /home/workespace/notebook/sweetwater /home/workespace/notebook/makeyourownneuralnetwork /home/workespace/notebook/Untitled.ipynb /home/workespace/notebook/AI-Practice-Tensorflow-Notes /home/workespace/notebook/working /home/workespace/notebook/cornfield os.path.isdir()用于判断某一对象(需提供绝对路径)是否为目录
''' 遇到问题没人解答？小编创建了一个Python学习交流QQ群：778463939 寻找有志同道合的小伙伴，互帮互助,群里还有不错的视频学习教程和PDF电子书！ ''' import os dirct = '/home/workespace/notebook/' for i in os.listdir(dirct): fulldirct = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fa0bad82d3f7599ec47064431233347/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/349/">«</a>
	<span class="pagination__item pagination__item--current">350/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/351/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>