<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cfb1cede24f8b317844342850cf63c3/" rel="bookmark">
			互联网大厂“组团”宕机，都怪降本增“笑”？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前不久，国际数据公司 IDC 发布了《中国公有云服务市场（2023 上半年）跟踪》报告。该报告显示，2023 年上半年中国公有云服务整体市场规模（IaaS/PaaS/SaaS）为 190.1 亿美元。其中，IaaS（基础设施即服务）市场规模为 112.9 亿美元，同比增速 13.2%；PaaS（平台即服务）市场规模为 32.9 亿美元，同比增速为 26.3%。
伴随着 AIGC 技术的崛起，云计算市场增长迅速。但另一方面我们也不得不注意到，最近半年来互联网基础设施宕机事件频发，服务器这个曾经被我们视为坚不可摧的巨人，如今却倒在了自己的重量之下。它的宕机，像一座大山瞬间崩塌，带来的震动与影响远远超出了人们的想象。
当宕机事件发生，我们就犹如被困在了一座孤岛上，只能眼睁睁地看着外面的世界在不断运转，这些曾经熟悉的工具都变得遥不可及，也给客户带来了无尽的失望和不满。
最后，我们开始反思这一切的根源。是什么导致了这场技术灾难？是技术不够先进，还是管理存在问题？是对风险的评估有误，还是对备份方案的准备不足？
本文总结了近半年来的云宕机事故，以期能沉淀出更加清醒的认知，降低类似事件发生的频率。
宕机事件频发，云基础设施靠不住了？ 腾讯视频 App“崩了”，回应称出现短暂技术问题 12 月 3 日晚，腾讯视频出现网络故障，有网友反馈出现首页无法加载内容、VIP 用户看不了会员视频等情况。稍晚些时候，@腾讯视频就“App 崩了”发布致歉声明：
尊敬的用户：目前腾讯视频出现了短暂技术问题，我们正在加紧修复，各项功能在逐步恢复中。感谢您的耐心等待，由此给您带来的不便我们深感歉意。
除了腾讯视频，近期遭遇宕机事件的还有滴滴、语雀、Boss、钉钉、淘宝、闲鱼盘等多个 App。
阿里云一个月内崩完了再崩 11 月 27 日，阿里云服务器遭遇了近两小时的中断，影响到中国和美国的客户，这是该业务一个月内第二次宕机。
随后，11 月 28 日，阿里云在网站上发布的声明中表示，北京时间 2023 年 11 月 27 日 09 时 16 分起，阿里云监控检测到资料库产品的控制台和 OpenAPI 访问异常，称问题已于当天 10 点 58 分解决。
受到此次事件影响的主要是北京、上海、杭州、深圳、青岛、香港以及美东、美西等多个地区的数据库产品，包括 PostgreSQL、Redis 和 MySQL 等。
而类似的事故，在双十一刚过的第二天，也就是 11 月 12 日刚刚发生过。
11 月 12 日，阿里云发生了宕机，旗下的钉钉、淘宝、闲鱼等产品皆受到了不同程度的影响，此次事故还影响到了使用阿里云的一些企业级客户，受影响地区从东亚和东南亚，覆盖到了中东和北美。经过数小时的修复后，服务恢复正常。 有人猜测，阿里云 11 月 27 日的宕机甚至可能造成了滴滴出行 App 崩了一夜，但业内人士认为这种情况概率比较低。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cfb1cede24f8b317844342850cf63c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12ca0719f85c96dfabbd1703cf7822a7/" rel="bookmark">
			软件测试面试中基础与功能的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 你们的测试流程是怎么样的？ 答：1.项目开始阶段， BA （需求分析师） 从用户方收集需求并将需求转化为规格说明书，接 下来在 项目组领导 会组织需求评审。 2.需求评审通过后，BA 会组织 项目经理 、 开发人员 和 测试人员 交接需求( 交接需求的过程中， 我一般会关注 需求是否清晰 ， 是否具有可测性 ，并识别出测试的 难易程度 和测试的 大概工作 量 )。 需求交接结束后，项目经理根据交接过程中的一些问题评估需求交接是 否通过，交接不通 过的，BA 会修改需求文档并组织二次交接，交接通过的需求。 3.测试 Leader 根据需求编写测试方案和测试计划，并评审。 4.然后根据需求的难易程度和组员的个人能力分配测试任务。测试人员根据分配到的需求进 行分析同时编写测试用例，用例完成后，测试 Leader 组织项目经理、BA、开发人员、测试 人员评审用例，评审完成后，对于有问题的测试用例，测试人员会做相应的修改。在测试人 员编写用例的同时，TA 同时进行测试环境的准备。 5.在测试执行阶段，测试经理会通知各模块测试人员进行冒烟测试。 6.冒烟通过后，测试人员开始启动测试（测试的轮次根据实际的测试时间调整，测试时间较 充足的情况下，一般进行 3 轮测试用例的执行（第一轮：全用例覆盖执行，第二轮:进行重 点用例的执行，第 3 轮：全量回归第一轮用例。）测试时间比较紧张的情况下，一般进行 2 轮测试（第一轮：全用例覆盖执行，第二轮：进行重点用例的执行），测试过程中发现的 bug， 通过缺陷管理工具禅道进行管理，为方便开发人员高效率的解决问题、减少沟通等，测试录 入 bug 时，严格按照 bug 的严重等级进行定义，缺陷单中会记录测试环境，测试账号，操 作步骤，预期结果，实际结果，截图。 7.开发人员解决问题并将程序部署到环境后，提交问题单给测试人员进行验证，问题验证不 通过的，驳回问题单并通知开发人员继续修改，问题验证通过的，关闭 BUG 。 8.测试周期结束前几天，测试经理开始着手准备测试报告，这个时候测试经理会关注 bug 单 的情况（未关闭的 bug 数据有多少，严重的问题有多少），如果 bug 单还有很多没有关闭， 项目组一般会安排开发人员和测试人员加班加点修改及验证问题单。如果 bug 单关闭率及 遗留率 满足项目规定，测试用例轮次也按计划完成。测试经理按照实际情况输出测试报告让 项目组领导决策上线。 二、 CRM 项目的各个模块是独立的吗？功能测试写了多少用例？ 答：不是。比如线索模块和客户模块就是有联系的，当确定线索是潜力客户时，需要在线索 模块点击转换按钮，把线索信息导入到客户模块成为客户信息。 这个项目我写了大概 800 条。 1 三、 CRM 市场信息系统管理业务是怎样的？介绍下新建线索这是 怎样的模块？ 答：背 crm 的流程 四、 CRM 项目做了多久？ 答：这个项目做了半年（甚至可以说一年），一般 2 个月左右一个大版本，两周左右一个小 版本 五、 你们这个 P2P 的业务流程是怎么样的，这个项目做了多久，你 负责哪些模块，写了多少用例？发现了多少个 BUG 答：背熟流程。 这个项目做了半年（甚至可以说一年），一般 2 个月左右一个大版本，两周左右一个小 版本，负责借贷管理、理财管理、会员管理、资金管理，还有首页。大概写了上千条用例， 发现几百个 BUG。 六、 P2P ，你们如何托管客户的资金，这些资金的流向是怎么样的？ 答：借款人和投资人双方，一旦投钱，钱就到第三方账号，借款人和投资人可以看到钱在第 三方账号里 第三方资金托管公司 ：宝付，易宝，环视资金。。。。 一般 p2p 平台不会直接吸收这笔借款，避免 p2p 公司自己去挪用资金，所以借款人和投资 人在投资过程中双方都会在第三方托管公司有一个自己的账号，投资过程中，投资人投借款 的标，那么这笔资金会直接流入第三方账号里，借款人也可以直接从第三方账号拿到借款， 用户把钱冲到第三方公司，也会受到第三方托管公司监管，不管投资还是提现都要经过第三 方资金托管公司即投资、借款、充值、提现都要经过第三方。借款人也是从第三方手上拿到 这款资金用户资金不管是充值和资金都受到自己托管的第三方的管理 2 七、 你们第三方支付的有哪些？用户怎么充值和提现？ 答：我们分为线上和线下充值，线上：各种的第三方方式充值进来，在 p2p 后台资金管理会 有记录，相应的也支持线下：线下会有方式提供选择，p2p 后台会对其进行充值。提现的话 只有在平台的上实现，扣除相对应的手续费后充值相对应账号。每提现一笔资金，p2p 生成 一条信息记录保存 八、 对于提前还款提现是怎么做？ 答： 要提前申请要符合平台要求。合同里面有签署关于提前还款的要求，平台会对这一业务对服 务费的减少，进行要向平台支付本金和利息，还有剩余的本金的 3%的违约金。 九、 如果让你去申请贷款，要怎么做 答：我要借款—申请贷款— 到后台页面的表单里面的内容要说具体点，线下合同肯定是要写一份的。合同里会有一系列 的规定，违约的处理做法。个人的认证资料， 前台：用户要登录线上平台，他会点击到借款页面里面，选择固定的借款模版取选，长期短 期的选择。借款信息的填写内容：标题，用途，有误抵押，借款金额，还款日期，期限，年 利率，还款方式，担保机构， 后台：这条借贷信息会出现借贷审核管理页面，后台的管理人员会对这条信息审核，会审核 他的基本信息，会和借款人签署一份线下合同，这些合同模版是 p2p 和借款人协商，工作人 会和借款人核实抵押物，借款利率还款日期之类的问题。工作人员办理好手续后重新编辑初 审信息提交给复审，复审的工作人员会判断这份贷款能否通过，符合借款要求就会给他审核 通过，如果不符合就会驳回，当最后复审通过，借款人就会接到审核通过的通知，前台就会 出现这条借贷信息，投资人可以进行投资 十、 你们在 P2P 项目中用到第三方的接口，怎么用，这些接口怎么 测试？ 答：在后台的“系统设备设置”—“接口设置”（背几个接口名字） 实名认证接口，中诚信征信 资金托管接口，已报，环讯，宝付 支付接口，支付宝，银联，微信支付，网银； 3 第三方提供接口规则（开发有） 知道接口规则，根据接口规则需求文档进行接口测试，先调通接口，再用功能测试测试 页面功能 第三方接口不需要找 bug 调试接口：接口不通报错（调试，权限） 根据报错调通接口 十一、 项目周期，测试周期，写了多少用例 答：这个项目做了半年（甚至可以说一年），一般 2 个月左右一个大版本，两周左右一 个小版本，负责借贷管理、理财管理、会员管理、资金管理，还有首页。大概写了上千条用 例，发现几百个 BUG。 十二、 你负责什么模块？你的货款管理有什么内容 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12ca0719f85c96dfabbd1703cf7822a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68330752d9a37320fd2c51895bf2e813/" rel="bookmark">
			软件测试面试中的自动化问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 你们的自动化是怎么做，流程是怎么样？ 1. 答：先判断是否达到使用自动化的条件 2. 熟悉需求和系统操作的条件下，分析系统功能，参照功能测试用例编写自动 化测试用例，以保证测试覆盖全面（需要等价类边界值等不要考虑，只考虑 功能是否完整，能有 50% 的覆盖率就不错了） 3. 比如我们首先写一个脚本，然后使用 find_element_by_id,name,Xpath 等方式 抓取系统页面元素，编写这个场景的流程。再加入等待时间，检查元素对 象。 4. 为了实现自动化脚本加入不同场景的管理，无人值守完成所有用例测试并最 后生成 html 报告，我们测试组会编写自动化框架。我们使用的是 Python 的 unittest ，这个框架是由自动化项目的主要负责人编写，然后我会把我负责的 模块代码融合到框架中。如我们的那个 sales 运营管理平台项目，会有登录 模块，线索模块，客户模块，商机模块 5. 首先，我们会把一个场景分为数据层，控制层，逻辑层，用例层和执行总脚 本 6. 先根据测试用例在数据层中编写 excel 数据，以及调用数据的方法 7. 把场景中的操作，特别是一些公共操作封装在控制层中的代码 control 中 8. 为该模块的所有测试用例定义一个类。每个用例定义为类里面的一个方法， 方法的名称按照《自动化测试用例》 &lt;testcase1….&gt; 的用例编号命名；读取 1 data 里 excel 的数据，调用 control 的方法编写操作步骤，调用逻辑判断层 business 里的 方法断言是否通 过 9. 编写一个总的测试脚本，将所有的测试用例类加入到框架的测试集 TestSuite 中，也就是相当于把所有测试用例类装入一个容器中，调用 “ 生成 HTML 报 告的方法 ” ，并选择报告保存的路径；执行这个总脚本，这个自动化测试完 成后会生成一个 HTML 报告。 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68330752d9a37320fd2c51895bf2e813/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13fc54956aa91dbadc14882cba4aeef4/" rel="bookmark">
			【css】边框有个缺口，css实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 结果 代码 &lt;fieldset&gt; &lt;legend&gt;Personalia:&lt;/legend&gt; Name: &lt;input type="text"&gt;&lt;br&gt; Email: &lt;input type="text"&gt;&lt;br&gt; Date of birth: &lt;input type="text"&gt; &lt;/fieldset&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/253b08824daea9d0bd8db318c9908a9a/" rel="bookmark">
			audio相关的网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		alsa project
ALSA project - the C library reference: PCM Interface
Dshare
https://alsa.opensrc.org/Dshare
dshare bug fix patch
[alsa-lib] pcm_dshare: Fix segfault when not binding channel 0 - Patchwork
plugin document
Alsa Opensrc Org - Independent ALSA and linux audio support site
alsalib plugin
Audio multi-channel routing and mixing using alsalib - Bootlin's blog
alsa channel mapping
Setting Up Audio Channel Mapping with AWS Elemental Server - AWS Elemental Server
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/253b08824daea9d0bd8db318c9908a9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbea5d56845d86ff9306e34cf4aae96f/" rel="bookmark">
			HLPP 最大流 O(V^3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HLPP 最大流 O(V^3) | INIT: network g; g.build(nv, ne); | CALL: res = g.maxflow(s, t); | 注意 : 不要加入指向源点的边 , 可能死循环 . \*==================================================*/ #define typef int // type of flow const typef inf = 0x3f3f3f3f; // max of flow typef minf(typef a, typef b) { return a &lt; b ? a : b; } struct edge { int u, v; typef cuv, cvu, flow; edge ( int x=0, int y=0, typef cu=0, typef cv=0, typef f=0) : u(x), v(y), cuv(cu), cvu(cv), flow(f) {} int other( int p) { return p == u ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbea5d56845d86ff9306e34cf4aae96f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27a879d690c8adf1c0806d986f8dbe31/" rel="bookmark">
			2023年度盘点：智能汽车、自动驾驶、车联网必读清单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年，智能驾驶和新能源汽车行业仍然有着肉眼可见的新进展。自动驾驶技术继续尝试从辅助驾驶向自动驾驶的过渡，更重要的是相关技术成本的下降。根据《全球电动汽车展望2023》等行业报告，预计2023年平均成本将降至100美元/千瓦时以下；电机的效率、功率密度和可靠性也得到了提升，平均成本降至20美元/千瓦以下。
自动驾驶技术逐步成熟，新能源汽车市场规模不断扩大，预计2023年全球销量将达到1400万辆，同比增长29.3%，其中中国市场将达到850万辆，同比增长26.3%。如果你想进一步了解自动驾驶和智能汽车相关行业的技术进展，推荐你读这6本书。
&gt;&gt;01 《智能汽车》
《智能汽车：电子电气架构详解》 推荐语：当智能与机械相遇，汽车成为一种生活方式。本书以智能汽车的电子电气架构为主线，微观层面上，从复杂系统工程视角讲解了智能汽车电子电气架构的原理、技术、设计、开发与管理；宏观层面上，用全局性和前瞻性的视角梳理了电子电气架构与“软件定义汽车”、“新四化”以及智能座舱、自动驾驶、汽车安全等新技术的关系，揭示了以电子电气架构变革为代表的汽车行业变迁的底层逻辑，旨在帮助车企能更快地实现转型并看清未来的发展方向。
&gt;&gt;02 《SoC底层软件低功耗系统设计与实现》
《SoC底层软件低功耗系统设计与实现》 推荐语：这是一本系统剖析SoC底层软件低功耗系统设计、实现与定制化的著作，同时它还全面讲解了低功耗的知识点以及各种低功耗问题的定位与优化。作者在华为海思等半导体企业深耕低功耗领域10余年，本书内容基于作者的实际商用经验撰写而成。
&gt;&gt;03 《SoC设计指南》
《SoC设计指南：基于Arm Cortex-M》 推荐语：本书针对SoC和FPGA设计师详细阐述了将Cortex-M处理器集成到SoC芯片设计中时需要掌握的所有关键技术内容，包括总线协议、总线互连和外围设计等等。作者姚文祥（Joseph Yiu）是Arm公司的杰出工程师，早在2000年就开始设计SoC，并在该领域担任了近20年的领导岗位。
&gt;&gt;04 《蜂窝车联网与网联自动驾驶》
蜂窝车联网与网联自动驾驶》 推荐语：汇聚网联自动驾驶与蜂窝通信技术领域的研究成果，不仅包含电信和汽车领域专家的行业见解，还包含工业与学术界的最新技术进展与理论知识。
&gt;&gt;05 《智能汽车网络安全权威指南（上册）》
智能汽车网络安全权威指南（上册）》 推荐语：汽车网络安全标准读本，知名电动汽车厂商安全总监撰写，43位汽车和安全领域专家力荐，9大主题全面展开。
&gt;&gt;06 《智能汽车网络安全权威指南（下册）》
《智能汽车网络安全权威指南（上册）》 推荐语：由于内容覆盖面广，而且比较深入和细致，因此本书篇幅较大。为了方便不同需求的读者阅读和各取所需，全书分为了上、下两册。下册详细总结了汽车黑客的攻击思维和方法，并列举了汽车网络安全架构视角和汽车功能应用视角下的常用攻击手法与防御措施。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56e7f3dddc7a97e4dc6ae4e0b9a2fe08/" rel="bookmark">
			PLG | Prometheus &#43; Loki &#43; Grafana 是时候把你的ELK扔掉了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
零、瞎BB
一、Pomtail
二、Loki
三、对接Grafana
Prometheus和Grafana默认你懂，本篇直接上 promtail 组件和 loki 。本文采用二进制安装部署 零、瞎BB PLG 通常指的是 Prometheus ， Loki ， Grafana 的日志和监控栈，这是一个常见的开源解决方案组合，用于收集、存储和可视化日志和度量数据。
Prometheus 主要用于收集和存储指标数据。 Loki 专注于日志聚合和管理。 Grafana 是用于数据的可视化和监控的工具。 在这个组合中， Promtail 是 Loki 的一个代理，负责收集日志并发送给 Loki 。 Loki 则负责存储和查询这些日志数据。日志文件本身通常存储在你的系统中的某个地方， Promtail 会监视这些日志文件，并将新的日志条目推送到 Loki 。
例如，如果你有一个应用程序，它的日志被写入到 /var/log/myapp 目录中，你会在 Promtail 的配置文件中指定这个目录。 Promtail 会监视目录中的变化，并将日志数据发送到Loki 。 Loki 则接收这些数据并将其存储在其数据库中，通常是结合使用本地存储和/或对象存储（如Amazon S3、Google Cloud Storage等）。这意味着，日志数据的生命周期如下：
1.应用程序生成日志，写入到它的日志文件中 2.Promtail 被配置为监视这些日志文件，捕获其内容 3.Promtail 将日志数据发送到 Loki 4.Loki 接收日志数据并将其存储在后端存储中 在 Grafana 中，你可以配置 Loki 数据源，然后创建仪表板来查询和可视化 Loki 中的日志数据。总的来说，PLG 栈的组件都有各自的职责，Promtail 不存储日志文件，它仅仅是作为一个中介，将日志数据从你的系统发送到 Loki 服务。Loki 是负责存储和查询日志数据的组件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56e7f3dddc7a97e4dc6ae4e0b9a2fe08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da7643a7f795034fd40d38ed5a7d6717/" rel="bookmark">
			Linux和Mac中不能使用ll命令查看文件解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 linux中不能使用ll命令查看文件原因:Mac Terminal终端没有ll命令解决办法 linux中不能使用ll命令查看文件原因: "ll"命令不是linux的基本命令，它是"ls -l"的别名，部分版本并不直接支持“ll”命令输出。
解决办法：
vi ~/.bashrc 查看该文件里是否有“alias ll=‘ls -l’”这样的内容，如有将数据前的注释“#”去掉，如果没有，将下面代码加进去并保存。
alias ll='ls -l' 然后运行 “source ~/.bashrc”命令，即可使用啦!
Mac Terminal终端没有ll命令解决办法 在～/.zshrc 文件中加入如下命令
vim ～/.zshrc #添加 alias ll='ls -alF' #生效 source ~/.zshrc 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a19401786d2568b2b15855fd8599c4b/" rel="bookmark">
			以企业架构为中心的SABOE数字化转型五环法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 01 传统企业数字化转型面临诸多挑战02 SABOE数字化转型五环法为企业转型破除迷雾 01 传统企业数字化转型面临诸多挑战 即将过去的2023年，chatGPT大模型、数据资产入表等事件的发生，标志着数字经济正在加速发展。数字经济是人类社会继农业经济、工业经济之后的第三种经济形态，将推动生产方式、生活方式和治理方式深刻变革，对于国家、企业和个人都将产生重大影响。当前，我们正在处于迈向数字经济时代的关键阶段，企业和个人如何才能抓住这一重大机遇实现快速发展而不是被时代淘汰呢？这是值得我们每一个企业、每一个人关注和思考的问题。
国家高度重视数字经济发展，将发展数字经济作为发展新动能。2021年3月，国家发布《国民经济和社会发展第十四个五年规划和2035年远景目标纲要》，提出要“加快数字化发展，建设数字中国”。今年3月份，中共中央和国务院又印发了《数字中国建设整体布局规划》，吹响了全面建设数字中国、实现中国式现代化的号角。
随着数字经济的蓬勃发展，许多企业开始进行数字化转型，希望抓住时代机遇，实现华丽转身。但这一过程并不是一帆风顺的，会面临许多挫折甚至失败。根据世界著名咨询公司麦肯锡的数据，传统企业数字化转型的失败率非常高，甚至高达80%的企业都会经历失败。
为什么会这样呢？数字化转型是要通过数据和数字技术赋能实现业务变革，但很多企业都面临着战略缺失或不落地、业务流程割裂、数据孤岛、数据质量差、业务和科技两张皮、系统竖井林立等老大难问题。这些问题是多年发展中遗留下来的问题，可谓沉疴痼疾，阻碍了企业数字化转型的步伐。
02 SABOE数字化转型五环法为企业转型破除迷雾 那么企业如何实现有效的数字化转型？数字化转型其实是一项非常复杂的系统工程，需要一整套的方法论进行指导。国资委在《关于加快推进国有企业数字化转型工作的通知》中就明确指出：“加快企业数字化治理模式、手段、方法升级，以企业架构为核心构建现代化IT治理体系，促进IT投资与业务变革发展持续适配。”
SABOE数字化转型五环法就是一套以企业架构为核心的、端到端覆盖数字化转型全过程的方法论，它是企业架构和数字化转型专家武艳军先生以近20年的企业信息化工作经验和央企、银行数字化转型实践经验凝练而成。
SABOE数字化转型五环法，如下图所示。之所以称为五环法，是因为它主要是由5个环节来构成的，包括数字化战略（Strategy）、数字化架构设计（Architecture），数字化建设（Build）、数字化运营（Operation）和数字化评估（Evaluation），SABOE就是由五个单词的首字母组合而成。
传统企业数字化转型会存在很多误区，比如将数字化转型当做科技部门的事情，或者认为做几个数字化项目就行了，项目上线就转型成功了。或者让业务部门和科技部门各行其是，百花齐放。这些误区会导致企业投入了大量资源却难以见到转型效果，数字化转型成为一场运动。 SABOE数字化转型五环法认为，企业数字化转型要真正见效，并为企业长远发展奠定坚实基础，必须要关注五个方面：
一、企业转型从制定数字化战略开始，以战略指引企业的转型方向，并由企业老板、管理层亲身参与推进。在战略方面，SABOE五环法提出了四看三定的战略规划方法，并介绍了华为采用的业务领先者模型BLM。
二、企业转型要在战略规划基础上进一步开展数字化架构设计，融合组织、流程、数据IT，形成完整架构蓝图，然后再进行相关的建设。在架构方面，SABOE五环法提出了DEAF数字化企业架构框架，融合和升级了等传统企业架构方法，具有数据化、智能化、敏捷化、生态化和体验化等五个特点，更加适应数字经济时代的需要。
三、在建设过程中，要严格遵循架构蓝图，保证一张蓝图绘到底。同时，重视变革管理，破除变革阻力，保证转型工作顺利推进。SABOE五环法介绍了项目群管理、架构管控、变革管理、目标管理以及组织能力建设、数据能力建设等方法及案例，帮助企业完成架构项目群的实施工作。
四、企业转型要重视运营工作，通过运营将数字化能力与业务实际结合起来，实现业务价值。SABOE五环法提出了数字化运营的框架和方法，帮助企业开展用户价值运营、内外协同运营和科技运营为一体的数字化运营工作。
五、企业转型是一个长期持续的过程，要定期复盘总结。通过数字化评估，企业可以明确现状、分析差距，明确下一步发展思路。SABOE五环法提出了数字化成熟度评估模型UDM，帮助企业开展科学的数字化评估工作。
此外，SABOE数字化转型五环法还提出了两大周期、五大原则，为企业转型工作提供指导。SABOE数字化转型五环法覆盖了从战略制定、架构设计、能力建设、日常运营到复盘评估等环节，能够为企业转型提供完整、全面的指导。这一方法论已经总结成一本书 《企业架构驱动数字化转型：以架构为中心的端到端转型方法论》，由机械工业出版社于近期出版，并在京东上架。
如果你是：
企业的CIO、CDO、架构师和工程技术人员；
企业各级管理人员、业务人员，
企业数字化转型提供服务的咨询和技术服务人员，
高校信息化等相关领域的教师和学生。
那么强烈推荐你阅读这本《企业架构驱动数字化转型：以架构为中心的端到端转型方法论》
京东正版链接：https://item.jd.com/14260994.html
这是一本以企业架构为核心切入点的数字化转型著作，是作者近20年的企业架构和数字化转型经验的集大成。企业架构是企业数字化转型的底层方法论，作者首先提炼出了数字化企业的架构框架DEAF，然后据此向前后延伸，总结出SABOE数字化转型五环法，涵盖企业数字化转型从顶层设计到落地实施、从建设到运营、从效果评估到迭代改进各个方面，为企业提供端到端的方法论指导。
端到端覆盖企业数字化转型全过程，从数字化战略开始，重点介绍数字化架构设计，但没有止步于蓝图规划，而是进一步延伸到数字化建设和运营，并通过评估为下一阶段转型做好准备。
融合了多学科知识，引入战略管理、企业架构、数据管理、项目管理、运营管理、数字化成熟度评估等方法并融合创新，为企业提供全视角、全体系的数字化转型指导方法。
推荐理由：
作者背景资深：资深企业架构师和数字化转型专家，曾在中国出口信用保险公司和百信银行担任PMO团队负责人、科技规划团队负责人和企业架构师。
作者经验丰富：从事信息化工作近20年，从IT架构再造到企业级业务架构设计和实施，从传统金融企业到一线互联网银行，对数字化时代的企业架构有深厚沉淀。
独创方法论：从实践中提炼出数字化企业架构框架DEAF和SABOE数字化转型方法论，让企业数字化转型不走弯路、有法可依。
源于实践总结：书中的方法论和经验全部来自作者在央企和一线互联网企业的实践总结，在实践中被证明有效。
大量模型框架：作者将各种方法和重要知识点，全部提炼为框架和模型图，便于读者理解，让读者的学习事半功倍。
大量名企案例：书中分析了建设银行、招商银行、网商银行、百信银行、平安集团、太平洋保险、中国人保、中国人寿、美的集团、华为、三一集团等近20家知名企业的数字化转型案例。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03f55f7068973062c8554b9f7e61d6af/" rel="bookmark">
			【EI会议征稿中|IEEE出版】第三届信息技术与当代体育国际学术会议（TCS 2023）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【IEEE出版】第三届信息技术与当代体育国际学术会议（TCS 2023）
2023 3rd International Conference on Information Technology and Contemporary Sports
2023年第三届信息技术与当代体育国际学术会议（TCS 2023）将于2023年12月22-24日在中国广州召开。会议由广东外语外贸大学主办、广东外语外贸大学体育部、AEIC学术交流中心承办。为加强全国各院校体育工作，增进在体育教学、科研方面经验的交流，促进体育教学、科研、训练、群体活动等方面得发展，会议将围绕“信息技术”、"体育“等领域，为来自国内外高等院校、科学研究所、企事业单位的专家等提供一个分享专业经验，扩大专业网络，面对面交流新思想以及展示研究成果的国际平台。
*往届会议均已被IEEE Xplore、EI Compendex、Scopus检索收录
TCS 2021 丨IEEE Xplore 丨EI Compendex （点击查看）
TCS 2022 丨IEEE Xplore 丨EI Compendex （点击查看）
重要信息 截稿倒计时 大会官网：www.icitcs.net （点击）
大会时间：2023年12月22-24日
大会地点：中国-广州
（*经主办方与组委会商议，会议改为线上召开）
（*文章见刊检索不受影响）
录用通知：投稿后1周内
收录检索：EI Compendex, Scopus，IEEE Xplore
终轮截稿时间：
2023年12月18日（早投稿、早审核、早录用）
论文模板：点击下载 IEEE-Template
【Hot News】 最新消息： TCS 2023已通过审核并已上线至IEEE官方会议列表，详情可点击：链接
主办单位
简介：广东外语外贸大学坐落于广东省广州市，是一所具有鲜明国际化特色的广东省属重点大学，是广东省高水平大学重点建设高校，为华南地区国际化人才培养、外国语言文学、全球经济治理、涉外法治和中华文化国际传播的重要基地，入选国家“2011计划” 、国家“特色重点学科项目”、国家大学生文化素质教育基地、教育部来华留学示范基地。校训为“明德尚行、学贯中西”。广东外语外贸大学位列2023年ABC中国大学排名语言类第5名、2022软科中国语言类大学排名第6名。 承办单位
简介：广东外语外贸大学体育部是学校二级教学机构，承担着开展全校体育课教学和课外体育活动的二级教学单位。体育部坚持以“健康第一、终身体育”为指导思想，并认真贯彻学校的各项政策方针、紧密围绕学校中心工作，在体育部党政班子带领下，全体教职工团结奋进、开拓创新，在教学、科研和群体竞赛等方面均取得了令人瞩目的成绩，有力推动了学校体育工作的全面发展。 大会组委
大会主席
焦方太-教授，博士
广东外语外贸大学 副校长
简介：主要从事国际贸易政策、国际经济合作、企业国际化经营等方面的教学和研究工作。曾获得广东省高教系统教书育人先进个人荣誉称号。先后在《经济日报》、《国际贸易》、《学术研究》、《南方经济》、《武汉大学学报》等重要期刊上发表学术论文20篇。作为主要成员，参与亚洲开发银行（ADB）委托的“广-梅-汕铁路的社会经济效益分析”等课题的研究。主持或作为主要成员参与“基于国际经验的区域创新体系动力机制研究”、“广外与拉美高等院校校际交流与科研合作探索”等省级研究课题（含省级教改项目）5项。先后担任广东省跨国公司研究中心秘书长、广东省WTO事务咨询服务中心理事、广东省高等教育学会外国文教专家工作委员会会长、广东省高等学校教学管理学会常务理事等职务。程序委员会主席 Prof. Xing Liu
广东外语外贸大学
A.Prof.Chaoyang Chen
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03f55f7068973062c8554b9f7e61d6af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbbb479b9ab9da0f32491e9c767a36d1/" rel="bookmark">
			MYsql第三次作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
问题：
解答
1.查询student表的所有记录
2.查询student表的第2条到4条记录
3.从student表查询所有学生的学号（id）、姓名（name）和院系（department）的信息
4.从student表中查询计算机系和英语系的学生的信息
5.从student表中查询年龄18~22岁的学生信息
6..从student表中查询每个院系有多少人
7.从score表中查询每个科目的最高分
8.查询张四的考试科目（c_name）和考试成绩（grade）
9.用连接的方式查询所有学生的信息和考试信息
10.计算每个学生的总成绩
11.计算每个考试科目的平均成绩
12.查询计算机成绩低于95的学生信息
13.查询同时参加计算机和英语考试的学生的信息
14.将计算机考试成绩按从高到低进行排序
15.从student表和score表中查询出学生的学号，然后合并查询结果
16.查询姓张或者姓王的同学的姓名、院系和考试科目及成绩
17.查询都是湖南的学生的姓名、年龄、院系和考试科目及成绩
问题： 解答 1.查询student表的所有记录 2.查询student表的第2条到4条记录 3.从student表查询所有学生的学号（id）、姓名（name）和院系（department）的信息 4.从student表中查询计算机系和英语系的学生的信息 5.从student表中查询年龄18~22岁的学生信息 6..从student表中查询每个院系有多少人 7.从score表中查询每个科目的最高分 8.查询张四的考试科目（c_name）和考试成绩（grade） 9.用连接的方式查询所有学生的信息和考试信息 10.计算每个学生的总成绩 11.计算每个考试科目的平均成绩 12.查询计算机成绩低于95的学生信息 13.查询同时参加计算机和英语考试的学生的信息 14.将计算机考试成绩按从高到低进行排序 15.从student表和score表中查询出学生的学号，然后合并查询结果 16.查询姓张或者姓王的同学的姓名、院系和考试科目及成绩 17.查询都是湖南的学生的姓名、年龄、院系和考试科目及成绩 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/211ebbc9e04550549dd000dc9d897c20/" rel="bookmark">
			Linux-KeyarchOS安装Puppet教程：实现IT基础设施自动化管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 概述
2 安装准备
2.1 操作系统环境
2.2 工具版本
3 安装
3.1 下载Puppet自定义仓库
3.2 master端安装Puppet-server
3.3 agent端安装Puppet-agent
4 运行Puppet
4.1 master端启动Puppet服务
4.2 agent端启动Puppet服务
4.3 签发证书测试
1 概述 浪潮信息KOS是浪潮信息基于Linux Kernel、OpenAnolis等开源技术自主研发的一款服务器操作系统，支持x86、ARM等主流架构处理器，性能和稳定性居于行业领先地位，具备成熟的 CentOS 迁移和替换能力，可满足云计算、大数据、分布式存储、人工智能、边缘计算等应用场景需求。详细介绍见官网链接浪潮信息KOS服务器操作系统-服务器操作系统-浪潮信息。
Puppet是一个IT基础设施自动化管理工具，它能够帮助系统管理员管理基础设施的整个生命周期：供应(provisioning)、配置(configuration)、联动(orchestration)及报告(reporting)。基于puppet ，可实现自动化重复任务、快速部署关键性应用以及在本地或云端完成主动管理变更和快速扩展架构规模等。Puppet对于系统管理员是抽象的，只依赖于ruby与facter，能管理多达40 多种资源，例如：file、user、group、host、package、service、cron、exec、yum repo等。详细介绍见官网链接https://www.puppet.com/。
2 安装准备 2.1 操作系统环境 版本信息：KeyarchOS 5.8sp1
硬件平台：X86_64
本次适配使用两台虚拟机，一台作为server端（master端），一台作为agent端。
2.2 工具版本 Puppetserver-7.14.0
Puppet-agent-7.27.0
3 安装 3.1 下载Puppet自定义仓库 两台机器均需执行以下步骤：
1、下载Puppet 实验室提供的自定义仓库，根据系统版本选择对应的rpm包
Index of /
2、下载完成后进入存放路径，使用rpm -ivh命令安装：
3.2 master端安装Puppet-server 在master端执行以下操作：
1、安装puppetserver：
yum install puppetserver
2、设置主机名称后重启机器
hostnamectl set-hostname master.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/211ebbc9e04550549dd000dc9d897c20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f97a033baac1ee16fd735ff52f594c72/" rel="bookmark">
			【常用字符大全】含emoji表情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用符号大全 ❤❥웃유♋☮✌☏☢☠✔☑♚▲♪✈✞÷↑↓◆◇⊙■□△▽¿─│♥❣♂♀☿Ⓐ✍✉☣☤✘☒♛▼♫⌘☪≈←→◈◎☉★☆⊿※¡━┃♡ღツ☼☁❅♒✎©®™Σ✪✯☭➳卐√↖↗●◐Θ◤◥︻〖〗┄┆℃℉°✿ϟ☃☂✄¢€£∞✫★½✡×↙↘○◑⊕◣◢︼【】┅┇☽☾✚〓▂▃▄▅▆▇█▉▊▋▌▍▎▏↔↕☽☾の•▸◂▴▾┈┊①②③④⑤⑥⑦⑧⑨⑩ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩ㍿▓♨♛❖♓☪✙┉┋☹☺☻تヅツッシÜϡﭢ™℠℗©®♥❤❥❣❦❧♡۵웃유ღ♋♂♀☿☼☀☁☂☄☾☽❄☃☈⊙☉℃℉❅✺ϟ☇♤♧♡♢♠♣♥♦☜☞☝✍☚☛☟✌✽✾✿❁❃❋❀⚘☑✓✔√☐☒✗✘ㄨ✕✖✖⋆✢✣✤✥❋✦✧✩✰✪✫✬✭✮✯❂✡★✱✲✳✴✵✶✷✸✹✺✻✼❄❅❆❇❈❉❊†☨✞✝☥☦☓☩☯☧☬☸✡♁✙♆。，、＇：∶；?‘’“”〝〞ˆˇ﹕︰﹔﹖﹑•¨….¸;！´？！～—ˉ｜‖＂〃｀@﹫¡¿﹏﹋﹌︴々﹟#﹩$﹠&amp;﹪%*﹡﹢﹦﹤‐￣¯―﹨ˆ˜﹍﹎+=&lt;＿-\ˇ~﹉﹊（）〈〉‹›﹛﹜『』〖〗［］《》〔〕{}「」【】︵︷︿︹︽﹁﹃︻︶︸﹀︺︾ˉ﹂﹄︼☩☨☦✞✛✜✝✙✠✚†‡◉○◌◍◎●◐◑◒◓◔◕◖◗❂☢⊗⊙◘◙◍⅟½⅓⅕⅙⅛⅔⅖⅚⅜¾⅗⅝⅞⅘≂≃≄≅≆≇≈≉≊≋≌≍≎≏≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟≠≡≢≣≤≥≦≧≨≩⊰⊱⋛⋚∫∬∭∮∯∰∱∲∳%℅‰‱㊣㊎㊍㊌㊋㊏㊐㊊㊚㊛㊤㊥㊦㊧㊨㊒㊞㊑㊒㊓㊔㊕㊖㊗㊘㊜㊝㊟㊠㊡㊢㊩㊪㊫㊬㊭㊮㊯㊰㊙㉿囍♔♕♖♗♘♙♚♛♜♝♞♟ℂℍℕℙℚℝℤℬℰℯℱℊℋℎℐℒℓℳℴ℘ℛℭ℮ℌℑℜℨ♪♫♩♬♭♮♯°øⒶ☮✌☪✡☭✯卐✐✎✏✑✒✍✉✁✂✃✄✆✉☎☏➟➡➢➣➤➥➦➧➨➚➘➙➛➜➝➞➸♐➲➳⏎➴➵➶➷➸➹➺➻➼➽←↑→↓↔↕↖↗↘↙↚↛↜↝↞↟↠↡↢↣↤↥↦↧↨➫➬➩➪➭➮➯➱↩↪↫↬↭↮↯↰↱↲↳↴↵↶↷↸↹↺↻↼↽↾↿⇀⇁⇂⇃⇄⇅⇆⇇⇈⇉⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇚⇛⇜⇝⇞⇟⇠⇡⇢⇣⇤⇥⇦⇧⇨⇩⇪➀➁➂➃➄➅➆➇➈➉➊➋➌➍➎➏➐➑➒➓㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩ⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅬⅭⅮⅯⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹⅺⅻⅼⅽⅾⅿ┌┍┎┏┐┑┒┓└┕┖┗┘┙┚┛├┝┞┟┠┡┢┣┤┥┦┧┨┩┪┫┬┭┮┯┰┱┲┳┴┵┶┷┸┹┺┻┼┽┾┿╀╁╂╃╄╅╆╇╈╉╊╋╌╍╎╏═║╒╓╔╕╖╗╘╙╚╛╜╝╞╟╠╡╢╣╤╥╦╧╨╩╪╫╬◤◥◄►▶◀◣◢▲▼◥▸◂▴▾△▽▷◁⊿▻◅▵▿▹◃❏❐❑❒▀▁▂▃▄▅▆▇▉▊▋█▌▍▎▏▐░▒▓▔▕■□▢▣▤▥▦▧▨▩▪▫▬▭▮▯㋀㋁㋂㋃㋄㋅㋆㋇㋈㋉㋊㋋㏠㏡㏢㏣㏤㏥㏦㏧㏨㏩㏪㏫㏬㏭㏮㏯㏰㏱㏲㏳㏴㏵㏶㏷㏸㏹㏺㏻㏼㏽㏾㍙㍚㍛㍜㍝㍞㍟㍠㍡㍢㍣㍤㍥㍦㍧㍨㍩㍪㍫㍬㍭㍮㍯㍰㍘☰☲☱☴☵☶☳☷☯
特殊符号 ♠♣♧♡♥❤❥❣♂♀✲☀☼☾☽◐◑☺☻☎☏✿❀№↑↓←→√×÷★℃℉°◆◇⊙■□△▽¿½☯✡㍿卍卐♂♀✚〓㎡♪♫♩♬㊚㊛囍㊒㊖Φ♀♂‖KaTeX parse error: Expected 'EOF', got '&amp;' at position 3: @*&amp;̲#※卍卐Ψ♫♬♭♩♪♯♮⌒¶∮…
编号序号 ①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳⓪⓿❶❷❸❹❺❻❼❽❾❿⓫⓬⓭⓮⓯⓰⓱⓲⓳⓴⓵⓶⓷⓸⓹⓺⓻⓼⓽⓾㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉㈠㈡㈢㈣㈤㈥㈦㈧㈨㈩⑴⑵⑶⑷⑸⑹⑺⑻⑼⑽⑾⑿⒀⒁⒂⒃⒄⒅⒆⒇⒈⒉⒊⒋⒌⒍⒎⒏⒐⒑⒒⒓⒔⒕⒖⒗⒘⒙⒚⒛ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩ⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵
数学符号 ﹢﹣×÷±±*/^=≌∽≦≧≒﹤﹥≈≡≠≤≥≮≯∷∶∝∞∧∨∑∏∪∩∈∵∴⊥∥∠⌒⊙√∛∜∟⊿㏒㏑%‰⅟½⅓⅕⅙⅐⅛⅑⅒⅔¾⅖⅗⅘⅚⅜⅝⅞≂≃≄≅≆≇≉≊≋≍≎≏≐≑≓≔≕≖≗≘≙≚≛≜≝≞≟≢≣≨≩⊰⊱⋛⋚∫∮∬∭∯∰∱∲∳℅øπ∀∁∂∃∄∅∆∇∉∊∋∌∍∎∐−∓∔∕∖∗∘∙∡∢∣∤∦∸∹∺∻∼∾∿≀≁≪≫≬≭≰≱≲≳≴≵≶≷≸≹≺≻≼≽≾≿⊀⊁⊂⊃⊄⊅⊆⊇⊈⊉⊊⊋⊌⊍⊎⊏⊐⊑⊒⊓⊔⊕⊖⊗⊘⊚⊛⊜⊝⊞⊟⊠⊡⊢⊣⊤⊦⊧⊨⊩⊪⊫⊬⊭⊮⊯⊲⊳⊴⊵⊶⊷⊸⊹⊺⊻⊼⊽⊾⋀⋁⋂⋃⋄⋅⋆⋇⋈⋉⋊⋋⋌⋍⋎⋏⋐⋑⋒⋓⋔⋕⋖⋗⋘⋙⋜⋝⋞⋟⋠⋡⋢⋣⋤⋥⋦⋧⋨⋩⋪⋫⋬⋭⋮⋯⋰⋱⋲⋳⋴⋵⋶⋷⋸⋹⋺⋻⋼⋽⋾⋿ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅬⅭⅮⅯↁↂↃↅↆↇↈ↉↊↋■□▢▣▤▥▦▧▨▩▪▫▬▭▮▯▰▱▲△▴▵▶▷▸▹►▻▼▽▾▿◀◁◂◃◄◅◆◇◈◉◊○◌◍◎●◐◑◒◓◔◕◖◗◘◙◚◛◜◝◞◟◠◡◢◣◤◥◦◧◨◩◪◫◬◭◮◯◰◱◲◳◴◵◶◷◸◹◺◿◻◼◽◾⏢⏥⌓⌔⌖
上标下标 ⁰ ¹ ² ³ ⁴ ⁵ ⁶ ⁷ ⁸ ⁹ ⁺ ⁻ ⁼ ⁽ ⁾ ⁿ ₀ ₁ ₂ ₃ ₄ ₅ ₆ ₇ ₈ ₉ ₊ ₋ ₌ ₍ ₎ ₐ ₑ ₒ ₓ ₔ ₕ ₖ ₗ ₘ ₙ ₚ ₛ ₜ
爱心符号 ♥❣ღ♠♡♤❤❥
标点符号 。，、＇：∶；?‘’“”〝〞ˆˇ﹕︰﹔﹖﹑•¨….¸;！´？！～—ˉ｜‖＂〃｀@﹫¡¿﹏﹋﹌︴々﹟#﹩$﹠&amp;﹪%*﹡﹢﹦﹤‐￣¯―﹨ˆ˜﹍﹎+=&lt;＿-\ˇ~﹉﹊（）〈〉‹›﹛﹜『』〖〗［］《》〔〕{}「」【】︵︷︿︹︽﹁﹃︻︶︸﹀︺︾ˉ﹂﹄︼❝❞‐‑‒–―‖‗‘’‚‛“”„‟†‡•‣․‥…‧‪‫‬‭‮ ‰‱′″‴‵‶‷‸※‼‽‾‿⁀⁁⁂⁃⁄⁇⁈⁉⁊⁋⁌⁍⁎⁏⁐⁑⁒⁓⁔⁕⁖⁗⁘⁙⁚⁛⁜⁝⁞
单位符号 °′″＄￥〒￠￡％＠℃℉﹩﹪‰﹫㎡㎥m²m³㎜㎟㎣㎝㎠㎤㍷㍸㍹㎞㎢㎦㏎㎚㎛㏕㎍㎎㎏㏄º○¤%$º¹²³㍺㎀㎁㎂㎃㎄㎅㎆㎇㎈㎉㎊㎋㎌㎐㎑㎒㎓㎔㎕㎖㎗㎘㎙㎧㎨㎩㎪㎫㎬㎭㎮㎯㎰㎱㎲㎳㎴㎵㎶㎷㎸㎹㎺㎻㎼㎽㎾㎿㏀㏁㏂㏃㏄㏅㏆㏇㏈㏉㏊㏋㏌㏍㏎㏏㏐㏑㏒㏓㏔㏕㏖㏗㏘㏙㏚㏛㏜㏝㏞㏟㍱㍲㍳㍴㍵㍶
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f97a033baac1ee16fd735ff52f594c72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f12c353d67b753efaec522e330a5e9c/" rel="bookmark">
			『OPEN3D』1.1 点云处理 python篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.open3d中的点云IO
2.点云的可视化
3 点云voxel下采样
4. 顶点法线估计
5.最小外界矩
6. 凸包计算
7. 点云距离计算
8. DBSCAN clustering聚类
9. RANSAC(Random Sample Consensus) 10. 点云平面分割
11. 隐藏点移除
12.outliers移除
13 最远点采样（Farthest Point Sample）
专栏地址：https://blog.csdn.net/qq_41366026/category_12186023.html
1.open3d中的点云IO open3d.io.read_point_cloud( filename, # 点云文件路径 format='auto', # 点云文件的格式，auto代表根据文件名自动推导点云格式 remove_nan_points=False, # 如为真则删除点云数据中存在NaN的点云 remove_infinite_points=False, # 如为真，删除无穷值 print_progress=False # 如为真，显示加载进度条 ) """函数返回值为open3d.geometry.PointCloud""" open3d.io.write_point_cloud(filename, # 保存的文件路径 pointcloud, # open3d.geometry.PointCloud类型的点云文件 write_ascii=False, # 为真设置输出点云数据格式为ascii编码，默认使用二进制编码 compressed=False, # 为真设置为压缩的点云编码格式 print_progress=False) #为真在控制台中显示进度条 """函数返回值为布尔类型""" 使用o3d中的data中的样例进行读取，如不能下载样例点云文件，可以自行更改读取文件地址
import open3d as o3d if __name__ == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f12c353d67b753efaec522e330a5e9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddb3f68df64a8e7f210b1f85512be105/" rel="bookmark">
			Warning: Don’t paste code into the DevTools Console that you don’t understand or haven’t reviewed 解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Warning: Don’t paste code into the DevTools Console that you don’t understand or haven’t reviewed yourself. This could allow attackers to steal your identity or take control of your computer. Please type ‘allow pasting’ below to allow pasting. 新 chrome 出了这么一个东西，表示不让你在 console 中粘贴一些你不懂的东西，完完全全是针对普通用户的。
解决办法 它这个提示中也说了，如果你不想以后再看到它，就在下面打出 allow pasting 这两个单词即可。
allow pasting 然后就可以正常粘贴了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe77fa998fb6b8820ad70ea0a0e6514f/" rel="bookmark">
			Spring Boot 升级 3.2 报错 Invalid value type for attribute ‘factoryBeanObjectType‘: java.lang.String
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀 作者主页： 有来技术
🔥 开源项目： youlai-mall 🍃 vue3-element-admin 🍃 youlai-boot
🌺 仓库主页： Gitee 💫 Github 💫 GitCode
💖 欢迎点赞 👍 收藏 ⭐留言 📝 如有错误敬请纠正！
目录 问题描述原因分析解决方案开源项目 问题描述 youlai-boot 升级 Spring Boot 3.2 版本项目启动报错：
java.lang.IllegalArgumentException: Invalid value type for attribute 'factoryBeanObjectType': java.lang.String 报错截图如下：
原因分析 mybatis-spring 官方 ISSUE: https://github.com/mybatis/spring/issues/855
项目中使用 mybatis-plus-boot-starter 当前最新版本 3.5.4.1 ，其中依赖的 mybatis-spring 版本为 2.1.1
在 mybatis-spring 2.1.1 版本的 ClassPathMapperScanner#processBeanDefinitions 方法里将 BeanClassName 赋值给 String 变量
并将 beanClassName 赋值给 factoryBeanObjectType
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe77fa998fb6b8820ad70ea0a0e6514f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a88b0ec4908a87f1a6b4b40374e69df/" rel="bookmark">
			通过keepalived&#43;nginx实现 k8s apiserver节点高可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境准备 K8s 主机配置：
配置： 4Gib 内存/4vCPU/60G 硬盘
网络：机器相互可以通信
k8s 实验环境网络规划：
podSubnet（pod 网段） 10.244.0.0/16
serviceSubnet（service 网段）: 10.96.0.0/12
物理机网段：192.168.1.0/24
2个控制节点2个工作节点
K8S集群角色IP地址主机名安装的组件控制节点192.168.1.63xuegod63apiserver、controllermanager、schedule、kubelet、etcd、kubeproxy、容器运行时、calico、keepalived、nginx、kubeadm、kubectl
控制节点192.168.1.64xuegod64apiserver、controllermanager、schedule、kubelet、etcd、kubeproxy、容器运行时、calico、keepalived、nginx、kubeadm、kubectl
工作节点192.168.1.65xuegod65Kube-proxy、calico、coredns、容器运行时、kubelet、kubeadm、kubectl工作节点192.168.1.62xuegod62Kube-proxy、calico、coredns、容器运行时、kubelet、kubeadm、kubectlVIP192.168.1.199 初始化安装安装到第三步https://candy.blog.csdn.net/article/details/134723910?spm=1001.2014.3001.5502
上面的安装到第三步，安装初始化 k8s 需要的组件，三台都安装
[root@xuegod63 ~]# yum install -y kubelet-1.26.0 kubeadm-1.26.0 kubectl-1.26.0
[root@xuegod63 ~]# systemctl enable kubelet
二、63、64 安装keepalived+nginx 1、安装 nginx 和 keepalived 在 xuegod63 和 xuegod64 上安装 keepalived 和 nginx，实现对 apiserver 负载均衡和反向代
理。Xuegod63 是 keepalived 主节点，xuegod64 是 keepalived 备节点。
[root@xuegod63 ~]# yum install epel-release nginx keepalived nginx-mod-stream -y
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a88b0ec4908a87f1a6b4b40374e69df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70b1e5a43c7a6bc62c72649c5b0a74fe/" rel="bookmark">
			了解 git rebase
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解 git rebase 大多数人习惯使用 git merge 将更改从功能分支合并到主分支，但还有其他方法。我们是否曾经遇到过 git rebase 这个术语并想知道它是什么？或者我们可能听说过 rebase 和 merge ，但不确定何时使用哪个？不用担心，因为本文就是关于 git rebase 的介绍及使用。
什么是 git rebase？ 为了理解 git rebase，我们首先需要掌握 Git 本身。Git 是一个分布式版本控制系统，这意味着它有助于管理项目随时间的变化。将其视为代码的神奇时间机器；它允许我们在不同版本之间来回切换。
git rebase 是一个命令，可以帮助我们将更改的代码从一个分支集成到另一个分支。想象一下我们正在建造一座塔，我们已经建立了一个坚固的基础，但在中途，我们决定在不影响上面的结构的情况下改 rebase 础。这就是 rebase 的作用 —— 它改变了分支的基础。
用技术术语来说，rebase 是将一系列提交移动或组合到新的基础提交的过程。
rebase 和 merge 为了更深入地探讨，让我们把 rebase 与 merge 进行比较。假设我们有一个包含主分支和功能分支的 git 存储库，并且我们希望将功能分支更改合并到主分支。我们的存储库可能如下所示：
标准方法是将功能分支使用 merge 合并到主分支。这会在主分支上创建一个新的提交，添加累积更改并将其作为合并提交添加到主分支上。这会保留其他功能分支的历史记录，以备我们需要时再次使用。
或者，我们可以使用 rebase 我们的代码。这将获取功能分支的更改并将它们附加到主分支，这有效地删除了作为单独工作分支的历史记录。
功能：
merge ：从一个分支获取所有更改并将它们合并到另一个分支中，创建一个新的合并提交。rebase：从一个分支获取更改并在另一分支之上“重播”它们。 提交记录：
merge：维护原始分支历史记录并添加一个新的提交，显示两个分支的合并位置。rebase：通过 rebase 将分支的整个历史记录放在其移动到的分支顶部来提供线性历史记录。 还有另一种理解它的方式：假设我们正在写一个故事。merge 就像在中间添加一章来解释前面章节中发生的事情。另一方面，rebase 就像重新安排章节以使故事更加流畅。
git rebase 的优点和缺点 优点：
更清晰的项目历史记录：rebase 提供了更精简、线性的项目历史记录。消除不必要的提交：通过重放提交，可以使提交历史记录更清晰、更容易理解。灵活的工作流程：有经验的开发者可以在 rebase 过程中修改提交、更改提交消息或将多个提交压缩为一个。 缺点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70b1e5a43c7a6bc62c72649c5b0a74fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0e7d45c762585cc614135c2cf80e176/" rel="bookmark">
			解决ImportError: cannot import name ‘VectorQuantizer2‘ from ‘taming.modules.vqvae.quantize‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行中遇到一个错误：ImportError: cannot import name ‘VectorQuantizer2’ from ‘taming.modules.vqvae.quantize’ ，按 https://github.com/CompVis/stable-diffusion/issues/72 中的方法处理，即用 https://github.com/CompVis/taming-transformers/blob/master/taming/modules/vqvae/quantize.py 新文件，替换错误提示文件中的全部内容即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f316e40cffc69a5bfd7fae2a3976a8b9/" rel="bookmark">
			【C语言】【数据结构】自定义类型：结构体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 这是一篇对结构体的详细介绍，这篇文章对结构体声明、结构体的自引用、结构体的初始化、结构体的内存分布和对齐规则、库函数offsetof、以及进行内存对齐的原因、如何修改默认对齐数、结构体传参进行介绍和说明。
✨ 猪巴戒：个人主页✨
所属专栏：《C语言进阶》
🎈跟着猪巴戒，一起学习C语言🎈
目录
引言
结构体的声明
结构体的基础
结构的声明
匿名结构体类型
结构体的自引用
typedef作用于结构体的问题
结构体变量的定义和初始化
多个元素的初始化要用大括号{ }
结构体的内存对齐
1.对齐规则
1.例子
2.例子
3.例子
4.例子
offsetof
offsetof的使用
​编辑
为什么要存在内存对齐
修改默认对齐数
结构体传参
结构体的声明 结构体的基础 结构是一些值的集合，这些值被称为成员变量。结构的每个成员可以是不同类型的变量。
在一个变量中，要存放性别、年龄、成绩、地址多种类型的数据时，C语言允许用户自己建立由不同类型数据组成的组合型的数据结构，它称为结构体。
结构的声明 结构体是怎么声明的呢？
struct tag { member_list; }variable_list; //分号不能丢 struct Student { //学生的相关信息 char name[20]; int age; }s1,s2; tag，Student是结构体名member_list是成员表列struct是声明结构体类型是必须使用的关键字，不能省略s1,s2变量就是学生变量。{ }后面要记得把“ ；”带上 struct tag就是一个结构体类型，我们可以根据自己的需要建立结构体类型，struct Teacher,struct Student等结构体类型，各自包含不同的成员。
如果将s1,s2放在main函数的外面，那么s1,s2就是全局变量。
struct Student { //学生的相关信息 char name[20]; int age; }s1,s2; int main() { return 0; } 匿名结构体类型 结构体在声明的时候省略了结构体标签（tag）,没有名字的结构体类型只能使用一次，被称为匿名结构体类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f316e40cffc69a5bfd7fae2a3976a8b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db37970332bcd1b7d49b9aafd5737279/" rel="bookmark">
			git获取远端分支和merge
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将远程分支拉取到本地 你可以使用以下命令：
1. 首先，使用`git fetch`命令从远程仓库获取最新的分支信息：
``` git fetch origin ``` 这个命令将会将远程仓库`origin`的分支信息下载到本地。
2. 接下来，可以使用`git checkout`命令切换到你想要拉取的分支：
``` git checkout &lt;branch-name&gt; ``` 其中，`&lt;branch-name&gt;`是你要拉取的远程分支的名称。 如果这个分支在本地不存在，Git会自动在本地创建一个新分支，并把远程分支的代码拉取到本地。 如果这个分支在本地已经存在，Git会自动切换到该分支，并将远程分支的最新代码合并到本地分支。 现在，你已经将远程分支成功拉取到本地了。
在merge过程中有冲突：
1）需要解决冲突；（选择采用谁的代码）； 冲突文件的构成有 3 个标记符：
1，头部的 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
2，中间的 =======
3，尾部的 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 远程分支名
解决完后：git add 冲突文件
提交：git commit
假如不想解决冲突并退出merge状态：git merge --abort；
将`master`分支的更改合并到`slave`分支上 可以按照以下步骤进行操作：
1. 确保你在`slave`分支上工作。如果不是，请使用以下命令切换到`slave`分支：
``` git checkout slave ```
2. 使用以下命令将`master`分支的更改合并到`slave`分支上：
``` git merge master ```
这将会将`master`分支的更改合并到当前的`slave`分支上。
3. 如果存在冲突，需要手动解决冲突。Git会提示你冲突的文件和具体的冲突位置，你需要编辑这些文件并手动解决冲突。
4. 在解决完所有冲突后，使用以下命令将解决冲突后的更改提交到`slave`分支上：
git add .
git commit -m "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db37970332bcd1b7d49b9aafd5737279/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/608a4bb530715ff63b009c0cdf6ca22f/" rel="bookmark">
			java.lang.NoClassDefFoundError: Could not initialize class sun.awt.X11GraphicsEnvironment
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因分析：
验证码采用awt图形处理并内存中生成，java程序会去寻找linux上的图形界面是否启动 ，如linux缺少组件则, 缺少了显示设备、键盘或鼠标会报这个错误;
所以需要开启无头模式, Headless模式是系统的一种配置模式 , 开始激活headless模式，告诉程序，现在你要工作在Headless mode下，就不要指望硬件帮忙了，你得自力更生，依靠系统的计算能力模拟出这些特性来继续;
解决方案：
jar启动时，增加如下命令：
-Djava.awt.headless=true war包启动，更改tomcat/bin/catalina.sh的文件，增加：
JAVA_OPTS="$JAVA_OPTS -Djava.awt.headless=true 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25ed05627f675b33221ee41b7afa4d32/" rel="bookmark">
			cogvlm：visual expert for large lanuage models
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CogVLM: Visual Expert For Large Language Models论文笔记 - 知乎github: https://github.com/THUDM/CogVLM简介认为原先的shallow alignment效果不好（如blip-2，llava等），提出了visual expert module用于特征的deep fusion在10项任务上达到SOTA，效果堪比PaLI-X 55B分为专家模…https://zhuanlan.zhihu.com/p/6627642351.introduction
shallow alignment不好，blip2，minigpt4，llava，visualglm等通过可训练的Q-former或线性层将冻结的预训练视觉编码器和语言模型连接起来，将图像特征映射到语言模型的输入嵌入空间中，虽然收敛速度快，但是不如联合训练视觉和语言模块的方法，例如PaLi-X，容易产生幻觉。shallow alignment较差的原因是视觉和语言之间缺乏深度融合deep fusion。这一想法来自于高效微调中的p-tuning和lora的比较，其中p-tuning通过学习输入中的任务前缀嵌入，而lora通过地址矩阵调整每个层的模型权重，lora效果更好更稳定。在VLM中，shallow alignment中，图像特征起到了p-tuning中的前缀嵌入作用，导致p-tuning和shallow alignment性能下降的原因包括：1.语言模型的权重是用文本token训练的，视觉特征在输入文本空间中并不能很多的对齐，因此在多层转换之后，视觉特征可能不再与深层权重的输入分布相匹配。2.在预训练阶段，cation中的先验信息只能被编码到浅层对齐方法中的视觉特征中，这削弱了视觉特征和文本之间的一致性。当然这也不全然，QWen-VL采用的三阶段训练，语言模型也会训练应该会解决一些对齐和融合的问题。一种方法是将语言模型和图像-文本联合训练，包括PaLI和QWen-VL，但是这种方式会导致语言模型能力下降，PaLM-E语言模型在VLM预训练期间可能会灾难性遗忘，导致8B的语言模型NLG下降87.3%.
CogVLM相反，向语言模型中添加了一个可训练的visual expert，在每一层中，序列中的图像特征使用一个新的不同的QKV矩阵和MLP层与文本特征并行。visual expert保证FLOPS不变的同时使参数数量翻倍。语言模型使用的是Vicuna-7B.
2.method
2.1 architecture
cogvlm由四个基本组件组成：VIT，MLP adapter，预训练语言模型，visual expert。
VIT：CogVLM-17B，预训练的EVA2-CLIP-E，VIT最后一层被移除。大概有4.4B。
MLP adapter：2层MLP，用于将VIT的输出映射与词嵌入的文本特征相同的空间。
预训练语言模型：Vicuna-7B-V1.5.
visual expert模块：在语言模型的每一层上都加了visual expert，以实现深层次的视觉语言对齐，由一个QKV矩阵和一个MLP组成，和语言模型中的QKV矩阵，MLP的形状相同，并从语言模型中初始化，语言模型中的每个attention head捕捉语义信息，可训练的visual expert可以将图像特征转换为与不同的attention head对齐，从而实现深度融合。
2.2 pretraining
数据：
开源数据集：LAION-2B，COYO-700M，剔除有问题的，大概还有15亿张图像用于预训练。
构造一个40M的视觉grounding数据集，在LAION-115M中采样，GLIPv2预测，确保75%的图像都至少有2个边界框。
训练：第一阶段针对image captioning loss，即文本的下一个预测。将CogVLM-17B在15亿个图像文本对上进行了120k迭代训练，bs为8196，得到base模型；预训练第二阶段是Referring Expression Comprehension和image captioning混合训练，15亿图像-文本对，bs为1024，60k迭代，最后30k把图片尺寸从224提升到490，得到CogVLM Grounding model。REC通过给出对象的文本描述，预测图像中的边界框，以VQA的形式进行训练，即Question：对象在哪里？Answer：[[x0，y0，x1，y1]]。可训练参数为65亿，消耗4096个A100/天。
2.3 alignment
对CogVLM进行微调，使其能够与任何主题自由形式指令相对齐。微调之后的模型为CogVLM-chat。
数据：SFT从LLAVA-INstruct、LRV-INstruction、LLaVAR和内部数据集中收集，共计50w个VQA对。SFT至关重要，LLaVA-Instruct由GPT4生成，手动进行了纠错。
训练：8k迭代，bs为640，lr为10-5，warmup迭代次数为50，为了防止过度拟合数据中的文本答案，使用了较小的学习率来更新语言模型，SFT中除了VIT，所有参数都参与训练。
3.experiments
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cab04a9e2150dc0f4d9bfb145473b3be/" rel="bookmark">
			Bert-VITS2 v2.1.0部署简单教程（加处理数据集脚本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不是什么很详细很正经的教程，自己写来自己以后看的脚本，方便后面加东西，主要是数据集的处理这一块。没啥加啥异常处理，就是简单的脚本，如果炸了就删掉重新来。
有不懂的可以去GitHub加作者的群
或者加我的讨论群869029039
有偿接代训练，加群找管理私聊
拉取最新分支 git clone https://github.com/fishaudio/Bert-VITS2.git 环境 pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple 下载模型 https://huggingface.co/audeering/wav2vec2-large-robust-12-ft-emotion-msp-dim/tree/main
把这个地方的pytorch_model.bin放在Bert-VITS2/emotional/wav2vec2-large-robust-12-ft-emotion-msp-dim文件夹里面
下载数据集 可以下原神/星穹铁道的数据集，从红血球那里下
红血球B站空间
处理数据集 新建文件夹
import os import shutil # 文件夹和文件的路径 base_dir = "./Data/StarRail" directories = ["audio/raws", "audio/wavs", "audio/temp", "filelists"] file_path = "filelists/StarRail.list" config_file_src = "./configs/config.json" # 源配置文件路径 # 创建文件夹 for directory in directories: dir_path = os.path.join(base_dir, directory) if not os.path.exists(dir_path): os.makedirs(dir_path) print(f"文件夹 '{dir_path}' 已创建。") else: print(f"文件夹 '{dir_path}' 已存在。") # 创建文件 full_file_path = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cab04a9e2150dc0f4d9bfb145473b3be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca7f8e8d733df2dc301916eccb93a123/" rel="bookmark">
			数据安全之标准-规范-政策-报告 集合收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载连接：https://note.youdao.com/s/Xu9Xu0Gz 20231211 更新 法律条例 商用密码管理条例-20230427 .pdf 中华人民共和国数字经济促进法-20230415.pdf 研究报告 基于数据资产全生命周期估值与实践报告-瓴羊-阿里云-DSI-202310.pdf 中国网络安全产业分析报告（2023年）-中国网络安全产业联盟-20230916.pdf 员工数据外泄管控建设指南-飞驰云联-202309.pdf 2023年中国网络安全市场与企业竞争力分析-中国网络安全产业联盟-20230620 开放银行数据保护与合规实践案例报告-中银联开放银行工作组-202305 数据安全体系数据绿洲建设指南-启明星辰数据绿洲-(2022-2023内部使用版).pdf 人工智能安全标准化白皮书-信安标委大数据安全标准工作组-202305.pdf 数控机床网络安全研究报告（2023年）-信通院&amp;绿盟-202304.pdf 2023年网络安全重要趋势-毕马威-202305.pdf 数字安全能力洞察报告-中国评测&amp;安恒-202305.pdf 2023年Q1数据资产泄露分析报告-威胁猎人-202304.pdf 企业数据确权与全球合规趋势报告(2023年）-清华大学&amp;DAMA&amp;环球律师事务所-202304.pdf 数联网(DSSN)白皮书-中国移动-202304.pdf 2023中国数字政府建设与发展白皮书-IDC&amp;CEC-202304.pdf 企业数据安全风险管理指南-CSA-202304.pdf 信通院 2023 大模型治理蓝皮书报告-从规则走向实践(2023)-信通院-202311.pdf 全球数字经贸规则年度观察报告（2023年）-信通院-202311.pdf 区块链白皮书（2023）-信通院-202312.pdf 人工智能安全标准化白皮书-信安标委大数据安全标准工作组-202305.pdf 移动物联网业务转售研究报告（2023年）-信通院&amp;中国通信企业协会-202311.pdf GA∕T 公安行业标准 GA 1277.6-2023 互联网交互式服务安全管理要求 第6部分：移动应用软件分发服务.pdf GA 1277.7-2023 互联网交互式服务安全管理要求 第7部分：云服务.pdf GA 1277.8-2023 互联网交互式服务安全管理要求 第8部分：电子商务服务.pdf GA 1277.9-2023 互联网交互式服务安全管理要求 第9部分：搜索服务.pdf 交通-汽车安全 GB∕T 36415-2018 汽车行业信息化实施规范.pdf 通信-移动安全 GB∕T 42884-2023 信息安全技术 移动互联网应用程序（App）生命周期安全管理指南.pdf GB∕T 42582-2023 信息安全技术 移动互联网应用程序（App）个人信息安全测评规范.pdf 智慧城市-智能制造 GB∕T 42888-2023 信息安全技术 机器学习算法安全评估规范.pdf 安全设备 GB∕Z 42885-2023 信息安全技术 网络安全信息共享指南.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca7f8e8d733df2dc301916eccb93a123/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9a9f1cc0ee3d23a10c71e8a9759ba92/" rel="bookmark">
			研发应用安全规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		研发应用安全规范
**1.**目的 确保在软件开发过程中应用了恰当的安全措施，以降低潜在的安全风险和漏洞。此规范为开发团队提供了一系列的标准和最佳实践，以确保在设计、编码和测试时充分考虑了安全性。
**2.**适用对象及范围 适用于各种类型的软件开发项目
**3.**安全准则 安全准则由三个总体目标来描述：
秘密性（也被称为秘密），计算系统的内容只能被授权对象访问；完整性，内容只能被授权对象以被授权的方式所修改；可用性，内容可以被授权对象使用。该目标经常提到的反义词就是拒绝服务。 **4.**应用安全规范 为了加强对程序开发应用安全问题的控制，下述列举了几个方面的应用安全措施、原则和规范，是各种编程语言均要遵守的安全准则，也作为系统设计、各类评审、程序开发、安全核查、测试案例编写的依据。
4.1设计安全规范 最小化原则。仅提供完成业务所需要的最少资源，包括功能、权限等；接入层和DB的物理环境必须分离。运行web的物理机器上不得同时安装存储数据DB；接入层不能直接访问DB，接入层不涉及业务逻辑，业务逻辑以中间层/逻辑层原子操作方式提供；敏感信息的通信协议建议采用加密协议(敏感信息:用户名/密码,短信内容，邮件内容等，防止被轻易破解)；COOKIE存放尽量少的信息，且存储非敏感信息，仅仅作为客户端的缓存作用。系统消息做频率限制、流量控制等措施 (内部系统之间，系统内部模块之间的消息通知)；手机消息做频率限制、流量控制等措施 (下发消息到用户手机)；频率限制要求至少对单个ID（手机号码等）、单个IP（用户外网IP）做一定时间内的访问次数限制，具体限制指标根据业务需要进行设定；站点登录管理界面不能对外公布；web站点目录下的读写目录做好统一规划并分开，便于做统一权限和安全管理，控制黑客限制上传文件的目录，以及完全控制黑客获取webshell权限。 4.2编码安全 登录和重要操作必须使用验证码(图片验证码或短信验证码) (登陆，自写短信，彩信，传真发送等)；对于绑定外网IP的server需要做安全防御措施：IP访问频率限制；用户访问频率限制；过载保护，拒绝超过服务器允许的连接上限阀值的请求；重要系统需要防止“connect后立即close”攻击；防止“connect后客户端不发包长期占用连接”攻击；防止“connect后客户端慢速发包长期占用连接”攻击；安全措施必须在网络接入层实现，及早发现，及时拦截和处理。避免攻击传播到server的业务逻辑层。(分层设计思想，异步处理思路)；对于来自第三方的平台请求,服务端必须有身份认证机制(IP信赖、IP和密码约定)；除非提供对外服务，server不能绑定外网IP；数据库侦听地址必须显式绑定在内部IP，无外网接口，也需要显式绑定；不允许没有校验用户登录状态就能执行用户私有请求的操作；不能信任从其它网元获取的参数，对于不能让用户修改的数据（如当前登陆的手机号码），需要使用Session机制进行安全控制；验证用户登录态（session期内）时，除了SSO调整外，还要验证用户IP是否变化，以防止URL被传播后在其它机器上重复执行；需要校验登录态的地方必须使用公司统一的session server接口进行session id的校验；对于从其它系统跳转而来的URL（例如SSO跳转URL）请求，必须对该URL参数进行全签名，保证服务器获取的信息未被篡改。URL的参数里也必须包含时间戳，服务端检查该URL是否超时；如果程序要求留有后门，必须在部门级评估、备案，且必须绑定内网IP。严禁为了方便测试或者活动在代码中直接写死手机号码，如果确实无法避免，必须经部门级评估，备案；防止SQL攻击，必须使用Escape函数过滤字符串Value值。严禁将底层错误直接显示给用户，造成表结构泄漏等危害 (错误提示重定向设计)；程序严禁使用外部输入的数字、字符串做文件名、路径名、环境变量的一部分（无论读写） (外界输入不可控；太长内存溢出；本地程序无错误，后端处理系统溢出之类的风险)；不得将外界用户输入串直接加入html文件、js脚本、xml文件、配置文件、模板文件；如因业务需要，必须在部门级评估、备案；后台程序必须对javascript语句进行过滤或转换；对于web页面的输入域，必须对输入的内容进行过滤处理，防止XSS跨站漏洞的产生；对于用户提交的字符内容，要做内容过滤，例如敏感字、不雅内容等(从必要性考虑政治，色情，暴力)；开源软件的引入必须由引进人经过详细的安全风险评估，并明确告知应用范围，经部门室经理、总监审批同意后才可应用。开源代码请注意清理无效文件、危险文件，不要使用默认代码目录，否则很容易被暴力猜解获取URL登录地址。 4.3参数处理 使用其它系统传来的参数前，必须对参数值进行合法性检验，不能依赖于客户端的检查：
对数据类型进行合法性检查，如仅能包含数字；仅能包含A-Z,a-z的字母；仅能包含数字与字母的组合；对数据长度合法性进行检查，接收到的参数值的长度是否超出了预期的范围，如：手机号码长度是否等于13（长度检查要注意中英文的单双字节的影响）；参数的校验必须在服务端程序中进行，不能完全依赖客户端脚本检查；处理字符串协议时，对数值型参数必须校验合法性（是否为数字字符）后再进行转化（如atoi），校验转换后的数值必须判断在允许范围。 4.4客户端异常提示 程序出错时专门打印错误页面。打印专门的错误页面时不得在错误页面中打印任何与程序结构、逻辑、数据、环境等有关的任何信息，如：不能直接将调用函数失败时返回的错误提示打印在错误页面上；打印错误页面时仅尽可能少的提示信息。在不影响业务，不影响用户体验感的前提下，打印尽可能少的错误提示信息，如果业务允许可以仅打印一个“系统繁忙，请稍后再试”的简单页面；对于用户恶意攻击，直接断开连接，或者以界面不友好方式迷惑攻击者，不留下被对方用于分析的线索。 4.5日志信息 重要操作信息必须记录完整，能够完全重现用户操作，至少包含如下关键信息：时间（精确到毫秒）、流水号、用户编号（手机号码等）、用户操作IP、前端服务器IP、操作内容；运营环境严禁在日志中明文记录敏感信息。(个人敏感信息、系统敏感信息、业务敏感信息等；日志文件必须定期进行抽样检查和脱敏处理；控制日志文件的大小。必须采用滚动日志或其他方式保证日志文件不超过规定的大小（1-100M,建议值10M），日志需要定期归档、备份，防止日志文件夹过度膨胀影响性能；在保证准确的情况下尽量保证日志对于业务处理逻辑的完备性。记录了完备的交易和上下游（第三方接口）的信息，供系统查询和恢复数据以及用于异常跟踪和定位；异常造成的业务失败，必须单独按照固定格式记录，便于故障恢复和投诉处理；应用服务器如IIS、Tomcat自己产生的日志，这些日志要注意调整日志输出级别，避免输出过多信息，生产环境应保持在INFO级别以上，同时，有些应用服务器的日志是不会自动滚动的，如Tomcat的stdout.log，要避免拖慢服务器，需要用crontab设定计划任务进行按日分割；日志必须记录在专有的外网不能访问的目录，绝对不能放在能被外界List到的目录下，如Htdocs等。对于调试日志，建议如无特殊需要，应在生产环境中去掉，避免因此造成的信息泄漏，以及服务器性能下降等问题。 4.6密码与加密 严禁在自己系统处理用户Login，必须采用公司统一的认证系统（session server）。如有特殊需要，需报部门技术总监审批备案后，方可实施；系统是否由于特殊性，没有采用Login进行登录，而是自行验证密码的。如有，必须增加频率限制和监控，必须有附加码校验等频率控制措施，且报部门技术总监审批备案后，方可实施；用户资料修改、校验密码、密码设置等敏感的地方必须有附加码校验；操作系统密码、数据库密码、后台管理密码不得明显包含用户帐户名或用户全名的一部分；长度至少为六个字符；包含来自以下四个类别中的三个的字符：英文大写字母、英文小写字母、10 个基本数字、非字母字符（!、$、#、%）；动态原则。安全策略必须动态变化的，比如加密过程中使用的密钥，不能在所有的过程或者相当长的一段过程中使用同样的密钥,必须动态改变；签名、KEY的算法必须采用MD5等标准算法，不得自己臆造算法，加密密钥必须是同时包含数字、字母、特殊字符，8位以上的字符串。 4.7核心数据和重要数据 用户数据、定购关系、业务数据等核心数据必须做备份，对于重要的数据必须做双机热备；对于用户隐私数据显示，如手机号码、身份证号码，应该采取部分信息用替代等方式，建议方式为后4位采用（业务有硬性要求除外）。 4.8客户端打包和插件升级 安装包必须保证没有病毒、木马；开源服务器，如apache、lighttpd、memcached、tomcat、mysql、jboss等必须使用经运维裁剪和安全配置的安装包；需使用开源的开发库时，要从官网下载稳定的版本，并在部门级备案。（使用stable版，不要使用release版）。 4.9接口协议安全 参见《接口协议标准》
4.10数据库应用安全 使用绑定变量的方式访问数据库；资源释放要配套，连接句柄，会话的打开和关闭要配套；数据库中存放的用户隐私数据需要脱敏处理；数据库中存放的密码，密钥等信息需要进行加密码，且符合相关安全标准；数据库需要定期升级，应使用不存在严重安全漏洞的安全版本；数据库所在的系统环境需要定期升级，以保证数据库环境安全。 4.11jsonp跨域安全 jsonp跨域访问的接口，必须针对接口进行合法性校验，如增加token校验、referer校验等；内网环境不建议使用jsonp跨域访问，建议设置反向代理实现访问；公网使用jsonp跨域访问，必须针对访问来源IP进行白名单校验。 4.12http跨域安全 http跨域访问的接口，必须针对接口进行合法性校验，如增加token校验、referer校验等；内网环境不建议使用http跨域访问，建议设置反向代理实现访问；公网使用跨域访问，必须针对访问来源进行白名单校验,如Access-Control-Allow-Origin指定白名单域名，不能设置为*。 **5.**应用系统开发安全 5.1安全原则 保护最薄弱的环节原则：保护最易受攻击影响的部分；纵深防御原则：不同层面、不同角度之间需要相互配合；最小权限原则：只授予执行操作所需的最小权限；最小共享原则：使共享文件资源尽可能少；权限分离原则：授予不同用户所需的最小权限，并在它们之间形成相互制约的关系。 5.2需求管理阶段 根据业务目标分析并制定系统安全目标；确认安全需求规格说明。 5.3系统设计阶段 根据安全目标执行威胁建模，识别威胁和风险；根据威胁建模制定对应开发安全任务：确定安全体系架构，设计安全协议和安全接口；确定访问控制与身份鉴别机制，定义主体角色和权限；信息输入的安全过滤，信息输出的校验和控制；数据结构安全设计，选择加密方法和算法；确定敏感数据保护方法；内部处理逻辑安全设计；评估内部通信机制，确定完整性机制。 5.4系统实现阶段 开发环境安全管理要求：软件系统开发、测试禁止在生产环境中进行；开发环境中的开发用机应进行统一安全配置及时进行系统补丁升级和漏洞修复；编码安全要求（后面会有详细讲解）：遵循代码编写安全规范，根据代码编写安全规范以及安全设计方案进行系统开发；遵循通用安全编程准则，包括输入验证、缓存溢出、安全调用组件和程序编译等；遵循机密性要求，保护用户访问信息的机密性，严禁在客户端存放敏感数据；避免内存溢出，严格检查和验证输入输出信息等；遵循结构化异常处理机制，捕捉并处理程序异常，防止系统信息泄露遵循代码脆弱性防范要求，包括缓冲区溢出、SQL注入、跨站脚本攻击、XML注入攻击、HTTP HEAD注入等。开发流程安全要求：开发过程中应对阶段性开发成果进行有效管理；开发过程中应定期进行代码静态分析，使用代码审核工具对源代码进行检测，并报告源代码中存在的安全弱点；开发人员不得超越其规定权限进行开发，不得在程序中设置后门或恶意代码程序；开发过程中应阶段性对敏感数据的加密传输、加密存储、对外提供或展示前进行脱敏处理第三方组件/库安全版本审计要求：开发过程中应对开发依赖库、框架、组件、容器进行安全版本审计；使用依赖库审计工具OWASP-dependency-check辅助进行审计，按漏洞等级修复。“高危"及以上必须修复（不能升级修复的需要说明原因），优先级由高到低依次为：CRITICAL是“严重”，HIGH"高危”，MEDIUM"中危"，LOW“低危”。 同级漏洞先修复存在远程执行漏洞的或对业务影响较小的组件；输出组件安全检查表，提交质量部（QA），QA人员对组件安全检查表进行审计，无“高”风险以上组件确认为符合安全求，特殊情况存在“高”风险以上组件的，需提供合理原因说明，并进行备案，定期组织相关人员对如上组件进行评审，评审不通过的需要及时更新升级。 5.5系统测试阶段 测试内容应包括代码的安全测试和安全功能测试；代码的安全测试是指使用代码测试工具或渗透测试来识别代码的安全脆弱性，并应按照其提供的修复建议进行修复；安全功能测试主要包括身份认证和访问控制的功能测试；测试系统环境应尽可能模拟生产环境并与生产环境进行安全隔离；真实数据不得直接在测试环境中使用，须进行适当修改或屏蔽，在测试完成之后须立即从测试应用系统清除运行信息；测试人员编制安全测试方案，构造安全测试用例；验收测试不得由开发人员兼岗。 5.6系统上线阶段 系统上线须在内部验收通过后进行；需进行上线前试运行，确认应用系统是否符合上线要求；上线成功后，记录上线的日期和内容；系统上线后需全面梳理与清理暴露面资产，按照最小化原则收敛暴露资产，消除 “无管理、无使用、无防护、无必要”四无暴露面资产。全面梳理清理防火墙策略，做好公网策略最小化管理；应确保每条策略落实到人，用途清晰，策略合规（如无维护端口开放公网、禁止any to any策略等）；加强短板系统安全管理，对防护短板系统重点梳理；全面清理应用资产，对内外网所有应用资产，按APP、SDK、公众号、单页面、应用接口、WEB网站等类型进行梳理，摸清IP端口、URL链接、中间件、开发框架等信息，全面清理已下线、过期、无效、测试页面等，确保每条资产责任到人；重点关注已下线但未清理设备、无人防护小系统、支撑系统开放公网、历史旧系统问题；全面清理网站目录文件，做好访问权限控制。严禁在网站目录下存放网站源码、日志、账号密码、测试代码、项目资料等敏感信息文件，对于网站目录应按照最小化原则进行访问权限控制；开展数据安全风险排查整改：各部门需强化业务数据安全管理，按要求对敏感数据进行分类分级管理，确保业务数据安全可控。同时加强对涉敏人员的管理，提高涉敏人员的安全防护意识，强化对涉敏人员的操作审计工作，定期审计涉敏人员的数据访问记录；各部门应加强数据库安全防护，采取有效措施防范对数据库的攻击（如数据库密码设置为强口令、网站配置文件中禁止明文存储数据库账号密码信息、加强数据库异常登录请求的分析、发现疑似注入行为时应及时告警并添加记录备查） 。完成主机及应用系统账号全面梳理认领与清理，加强账号与敏感数据操作审计；完成主机账号梳理认领与清理工作，对全量账号进行梳理，对无用账号进行清理，确保主机账号100%责任到人。全面梳理应用系统账号，清除历史无用账号及离职人员账号，确保所有账号归属在职人员。严禁绕行4A行为，加强账号与敏感数据操作审计。禁止在GitHub、百度文库、公网邮箱、在线笔记等公网系统上存储工作相关信息及帐号密码，开展全面清查（可在搜索引擎查询邮箱、电话、系统名称等关键字），消除上述渠道中存储的工作信息；口令安全教育与监督检查，组织全员开展个人账号（邮箱、即时通讯、网盘）弱口令自查，提高口令强度，避免被盗号后获取个人信息，用于开展社会工程学攻击；上线强口令策略，建议全体员工修改统一认证及内部生产系统密码，避免与外部系统个人账号相同或相似。 5.7文档管理 源代码的变更和版本发布进行统一控制，对程序资源库的任何修改、更新和发布都需代码管理员授权和批准；应指定专人妥善保管程序源代码及相关技术文档。 **6.**基本/特定语言安全规范 每种编程语言均有自己的语法和特色，以下列出了Java、C/C++、C#的特有安全规范。
6.1基本代码安全要求 6.1.1****输入验证 对函数入口参数的合法性和准确性进行检查，具体如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9a9f1cc0ee3d23a10c71e8a9759ba92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/776491cc4a45507fbac81035b45de32d/" rel="bookmark">
			t-SNE完整笔记 (附Python代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		t-SNE(t-distributed stochastic neighbor embedding)是用于降维的一种机器学习算法，是由 Laurens van der Maaten 和 Geoffrey Hinton在08年提出来。此外，t-SNE 是一种非线性降维算法，非常适用于高维数据降维到2维或者3维，进行可视化。
t-SNE是由SNE(Stochastic Neighbor Embedding, SNE; Hinton and Roweis, 2002)发展而来。我们先介绍SNE的基本原理，之后再扩展到t-SNE。最后再看一下t-SNE的实现以及一些优化。
1.SNE 1.1基本原理 SNE是通过仿射(affinitie)变换将数据点映射到概率分布上，主要包括两个步骤：
SNE构建一个高维对象之间的概率分布，使得相似的对象有更高的概率被选择，而不相似的对象有较低的概率被选择。SNE在低维空间里在构建这些点的概率分布，使得这两个概率分布之间尽可能的相似。 我们看到t-SNE模型是非监督的降维，他跟kmeans等不同，他不能通过训练得到一些东西之后再用于其它数据（比如kmeans可以通过训练得到k个点，再用于其它数据集，而t-SNE只能单独的对数据做操作，也就是说他只有fit_transform，而没有fit操作）
1.2 SNE原理推导 SNE是先将欧几里得距离转换为条件概率来表达点与点之间的相似度。具体来说，给定一个N个高维的数据 (x_1, … , x_N)（注意N不是维度）, t-SNE首先是计算概率(p_{ij})，正比于(x_i)和(x_j)之间的相似度（这种概率是我们自主构建的），即：
[{p_ {j \mid i} = \frac{\exp(- \mid \mid x_i -x_j \mid \mid ^2 / (2 \sigma^2_i ))} {\sum_{k \neq i} \exp(- \mid \mid x_i - x_k \mid \mid ^2 / (2 \sigma^2_i))}}]
这里的有一个参数是(\sigma_i)，对于不同的点(x_i)取值不一样，后续会讨论如何设置。此外设置(p_{x \mid x}=0),因为我们关注的是两两之间的相似度。
那对于低维度下的(y_i)，我们可以指定高斯分布为方差为(\frac{1}{\sqrt{2}})，因此它们之间的相似度如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/776491cc4a45507fbac81035b45de32d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77b2f0e3f7fab16907f776de5c25de2b/" rel="bookmark">
			C# WPF上位机开发（文本编辑器的界面开发）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【 声明：版权所有，欢迎转载，请勿用于商业用途。 联系信箱：feixiaoxing @163.com】
通常我们学习一个新软件的时候，一般都要看下这个软件有哪些菜单、工具栏有什么、状态栏有什么。每一个菜单或者工具代表着什么意义，这就是我们学习新软件的基本方式。为什么要这么做，那是因为大部分软件都是在windows平台开发的，平台本身推荐的软件开发方式也是这么一种模式。所以，大家如果是开发windows软件，最好也是按着这种套路来进行开发，降低使用者学习的成本。
这里为了学习菜单、工具栏和状态栏的设计，可以自己设计一款简单的文本编辑器，通过这样的方式，掌握一下这种模式开发应该怎么进行的。
1、菜单添加 菜单主要是由Menu和MenuItem构成的。MenuItem里面可以嵌套MenuItem，这就是所谓的菜单嵌套。如果需要点击菜单的时候，弹出对应的窗口，那么只需要实现对应的函数就可以了。
&lt;Menu DockPanel.Dock="Top"&gt; &lt;MenuItem Header="文本"&gt; &lt;MenuItem Name="menuCreate" Header="创建文本" Click="MenuItem_Click"&gt;&lt;/MenuItem&gt; &lt;MenuItem Header="删除文本"&gt;&lt;/MenuItem&gt; &lt;MenuItem Header="复制文本"&gt;&lt;/MenuItem&gt; &lt;/MenuItem&gt; &lt;MenuItem Header="编辑"&gt;&lt;/MenuItem&gt; &lt;MenuItem Header="视图"&gt;&lt;/MenuItem&gt; &lt;MenuItem Header="关于"&gt;&lt;/MenuItem&gt; &lt;/Menu&gt; 2、工具栏 和菜单栏相比较，工具栏简单很多。首席我们需要创建一个Toolbar的控件，接着在这个空间里面放上各种Button，Button和Button之间添加分隔符，这就是工具栏的形式。当然，如果需要美观一点的话，可以在Button的旁边插入各种图片，这样整体的布局效果要好看的多。
&lt;ToolBar DockPanel.Dock="Top"&gt; &lt;Button Content="保存" Click="Button_Click"&gt;&lt;/Button&gt; &lt;Separator&gt;&lt;/Separator&gt; &lt;Button Content="另存为"&gt;&lt;/Button&gt; &lt;Separator&gt;&lt;/Separator&gt; &lt;Button Content="打印预览"&gt;&lt;/Button&gt; &lt;Separator&gt;&lt;/Separator&gt; &lt;Button Content="打印"&gt;&lt;/Button&gt; &lt;Separator&gt;&lt;/Separator&gt; &lt;Button Content="属性设置"&gt;&lt;/Button&gt; &lt;/ToolBar&gt; 3、状态栏 状态栏和工具栏很类似，同样我们也需要创建一个Statusbar的控件。在这个控件里面，通过插入TextBlock、Label等方式，就可以呈现出状态栏的效果了。这里只是为了演示，添加了一个TextBlock控件。
&lt;StatusBar DockPanel.Dock="Bottom"&gt; &lt;TextBlock Text="编辑状态"&gt;&lt;/TextBlock&gt; &lt;/StatusBar&gt; 4、整体布局 上面只是简单了说明一下菜单、工具栏、状态栏是怎么编写的。如果是整体设计的话，我们可以Grid里面嵌套一个DockPanel，通过它的Top、Bottom机制来实现全部控件的布局。另外空间中涉及到的回调函数也是非常简单，主要就是调用MessageBox.Show函数来完成对应按钮的功能响应。最后有需要的朋友，可以参考下这个xaml布局，在后续的项目开发作为基础，做进一步的开发和应用。
&lt;Window x:Class="WpfApp.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:local="clr-namespace:WpfApp" mc:Ignorable="d" Title="文本编辑器" Height="400" Width="700"&gt; &lt;Grid&gt; &lt;DockPanel Margin="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77b2f0e3f7fab16907f776de5c25de2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/206baabd5713f43e8e7fd1b55dae6ef5/" rel="bookmark">
			JAVA 微信APPV3支付(保姆级)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在Java微信支付文章五花八门 看不懂 看的懵 掺杂业务逻辑不知名的返回封装 爆红一片 不妨看看这篇 由于微信更新了0.4.9版本 部分使用微信支付会解析报错 原因是微信内置了Jackson2.13.xxx依赖会与springboot这个Jackson产生冲突 可能会无法升级依赖 因为升级了也会使用老版本依赖 解决方法需要把微信支付解析 验签等方法分离重写 目前没时间写文章 无法自行解决的请私信 1.加入Maven依赖 &lt;!-- 微信支付V3 目前新版本--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.wechatpay-apiv3&lt;/groupId&gt; &lt;artifactId&gt;wechatpay-apache-httpclient&lt;/artifactId&gt; &lt;version&gt;0.4.7&lt;/version&gt; &lt;/dependency&gt; 2.创建WxV3PayConfig.java配置类 /** * implements WXPayConfig */ @Data public class WxV3PayConfig { //平台证书序列号 public static String mchSerialNo = "xxxxxxxxxxxxxx"; //appID public static String APP_ID = "xxxxxxxxxxxxxx"; //商户id public static String Mch_ID = "xxxxxxxxxxxxxx"; // API V3密钥 public static String apiV3Key = "xxxxxxxxxxxxxx"; // 商户API V3私钥 public static String privateKey = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/206baabd5713f43e8e7fd1b55dae6ef5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dc488c48f19ec7ea7280fc19cac3652/" rel="bookmark">
			预制凭证及取消凭证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预制凭证及取消凭证（带增强） 事务代码：
FBV1：创建预制凭证
FBV2：修改预制凭证
FBV3：查看预制凭证
FBV0：预制凭证过账/冲销
FB08：已过账凭证冲销
SE19：实现 BADI 增强 ACC_DOCUMENT
BAPI：BAPI_ACC_DOCUMENT_POST
预制凭证 输入事务代码FBV0，输入数据，回车
下一行明细
保存生成凭证号。
预制凭证过账：FBV0
输入公司代码、凭证号、财年回车，点击保存
增强部分 SE11创建增强结构
SE19创建BADI实施
选择 BKPFF，表示这个 BADI 实现只适用于会计凭证直接输入，并激活
新建，保存激活成功
CHANGE是我们需要的方法
拷贝这段代码（不需要修改）
data: wa_extension type bapiparex, ext_value(960) type c, wa_accit type accit, l_ref type ref to data. field-symbols: &lt;l_struc&gt; type any, &lt;l_field&gt; type any. sort c_extension2 by structure. loop at c_extension2 into wa_extension. at new structure. create data l_ref type (wa_extension-structure). assign l_ref-&gt;* to &lt;l_struc&gt;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dc488c48f19ec7ea7280fc19cac3652/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffa3168bb52903e3c3ebd482ae6ac03c/" rel="bookmark">
			12.23每日一题（分段函数的导数在某点连续相关定理！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、通过导数的定义求函数的左右导数 2、通过所给的分段函数求出相应的导数表达式，求出分段函数导数的极限值 3、判断1、2是否相等，并推出范围 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f693b2966b7aec114ddbcf8ae2cf2fad/" rel="bookmark">
			AI智能监控巡检系统，赋能多场景巡检应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI智能监控巡检系统，赋能多场景巡检应用
随着社会智能化水平的推进，传统人眼巡查模式耗时长、效率低，难以实时发现异常事件，造成了采集的数据不准、主观影响因素大、处理不及时、面对问题常处于被动局面等问题，已无法适应当前的巡查需求，利用AI视频智能巡检代替传统人工巡检，已逐渐在电力、水利、边防、环卫、地铁、物业、道路养护、建筑工地等诸多场景的巡检工作中做出新贡献。
基于AI智能分析网关平台SkeyeVSS的端-边-云一体化视频融合云平台从实际场景需求出发，为客户提供全新的AI智能巡检解决方案，该方案基于视频智能分析进行自动巡检，实现对海量巡检点位的全天时、无人化、智能化、巡检，有效弥补「人工巡检+传统监控」在视觉感知和实时响应上的局限性，为企业降本增效。
核心优势 1、视频融合管理
平台支持视频监控、7*24h录像，提供录像、检索、回放、云存储、云报警关联等功能，结构化摘录视频内容的信息可包含如时间、地点等信息进行统一存储，并对接入的视频进行录像备份，实现数据的分布式存储和备份，保障了视频资源的可靠性、安全性及可追溯性，为执法、追溯提供凭证。
2、预警联动预案
此外，平台还可对智能监控摄像头、报警主机、传感器等智能设备进行数据采集以及提供非结构化的视频数据与结构化的业务数据诸如AI智能分析结果、报警上报信息等建立关联关系，并提供丰富的联动预案（弹屏、上墙、声光报警、语音广播、抓拍、录像、云台预置点等），同时支持报警事件的强制提醒和处理；事后支持对报警记录检索、处理以及报警统计分析，形成对应视频信息和视频增值分析、报警、设备关联监测业务等的迅速调用和灵活检索。
3、最大化算力利用
平台实现对视频内容、视频结构化信息的智能分析，实现结构化摘录信息与相应时间、信息的智能分析和应用；当前端设备在检测到事先规定的特殊事件发生时，发送告警信息到平台。
4、可扩展的微服务应用架构
基于微服务架构体系实现系统通用框架以及可插拔的应用体系（包括：监控、报警、人/车管控、智能分析、电子地图、传感大数据等），可根据项目需求选择性地灵活部署。
5、遵循标准，开放互联
支持多终端（C/S、B/S、App）应用以及二次开发接口，同时遵循GB/T 28181、GA/T 1400等标准，快速实现平台级的互联互通。
二、场景应用
1、智慧电力
可实现变电站、配电室、机房等场景的自动巡检，实时监测和识别重要设备状态，对检测到的异常情况实时告警，并将告警信息推送给相关人员处理，降低和减少意外事故发生的风险，推动电力运维管理的智能化和自动化发展。
2、智慧水利
对水库大坝、地下水机井等水利设施进行自动化巡检，设置多维数据采集、视频综合应用、AI自动巡检、多维感知融合联动、智能运维等功能，实现对水利设备的全面监测，大大降低了巡检成本，有效地保证水利设施的安全性和稳定性。
3、边防海防
自动检测边海防异常事件，实现点位多维数据采集、AI自动巡检、人员安全管控、设备状态识别、事件异常预警等功能，有效降低巡检人员的安全风险，提高边海防综合管控水平。
4、智慧环卫
助力城市环卫进行AI智能视频监管升级，通过对前端视频的分析，对环卫作业质量和作业规范进行自动巡检和督查，及时发现异常事件并告警联动，实现环卫作业高效化，推动城市精细化管理，为智慧城市建设赋能。
5、智慧物业
系统利用AI智能视频分析技术直观、准确、及时地呈现设防区域的现场情况、信息设备状态等，结构化分析人、车、物等场景元素，做到自动感知、识别和理解场景行为，强化态势感知、提前发现潜在威胁，将物业管理模式从传统的被动信息接收升级为主动管理。
6、道路巡检
运用AI视觉算法、边缘计算、高精度定位等技术打造道路智慧巡检系统,替代人力巡查且更高效精准,助力道路巡检单位提质增效;同时为管理部门提供数据支撑,实现道路养护由人工经验决策向智能数据决策的转变。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d69afb32d0c7e83b8907d3f4336dfb5/" rel="bookmark">
			【KeyarchOS】Kubernetes安装部署实践-从零开始配置K8s 集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 概述
2 安装准备
2.1 操作系统环境
2.2 Kubernetes版本
2.3 Docker版本
3 安装
3.1 安装Kubernetes
3.2 部署Kubernetes集群
4 常见问题
1 概述 浪潮信息KOS是浪潮信息基于Linux Kernel、OpenAnolis等开源技术自主研发的一款服务器操作系统，支持x86、ARM等主流架构处理器，性能和稳定性居于行业领先地位，具备成熟的 CentOS 迁移和替换能力，可满足云计算、大数据、分布式存储、人工智能、边缘计算等应用场景需求。详细介绍见官网链接浪潮信息KOS服务器操作系统-服务器操作系统-浪潮信息。
kubernetes，简称K8s，是用8代替名字中间的8个字符“ubernete”而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。 传统的应用部署方式是通过插件或脚本来安装应用。这样做的缺点是应用的运行、配置、管理、所有生存周期将与当前操作系统绑定，这样做并不利于应用的升级更新/回滚等操作，当然也可以通过创建虚拟机的方式来实现某些功能，但是虚拟机非常重，并不利于可移植性。
新的方式是通过部署容器方式实现，每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。相对于虚拟机，容器能快速部署，由于容器与底层设施、机器文件系统解耦的，所以它能在不同云、不同版本操作系统间进行迁移。
容器占用资源少、部署快，每个应用可以被打包成一个容器镜像，每个应用与容器间成一对一关系也使容器有更大优势，使用容器可以在build或release 的阶段，为应用创建容器镜像，因为每个应用不需要与其余的应用堆栈组合，也不依赖于生产环境基础结构，这使得从研发到测试、生产能提供一致环境。类似地，容器比虚拟机轻量、更“透明”，这更便于监控和管理，详情见官网：https://kubernetes.io/。
2 安装准备 2.1 操作系统环境 版本信息：KeyarchOS 5.8sp1（两台，分别作为master主节点和node节点）
硬件平台：X86
2.2 Kubernetes版本 版本号：kubernetes 1.20.5
GitHub主页：GitHub - kubernetes/kubernetes: Production-Grade Container Scheduling and Management
2.3 Docker版本 版本号：Docker-20.10.16(已经在KOS AppSteam仓库发布)
3 安装 3.1 安装Kubernetes 1、编辑master节点和node节点的 /etc/hostname 文件，分别设置为master和node,编辑/etc/resolv.conf,添加DNS
nameserver 8.8.8.8
nameserver 114.114.114.114
2、关闭防火墙和Selinux，以及swap分区
sed -i 's/enforcing/disabled/' /etc/selinux/config
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d69afb32d0c7e83b8907d3f4336dfb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc7db5162da45534fe058fe9c2343b6/" rel="bookmark">
			机器学习周记（第二十周：文献阅读-TCN and LSTM）2023.12.4~2023.12.10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘要
ABSTRACT
1 论文标题
2 论文摘要
3 问题描述
4 过去方案
5 论文方案
6 相关代码
摘要 本周阅读了一篇关于TCN和LSTM进行光伏功率预测的文章，光伏功率数据是非线性不平稳的数据，在一定程度上也能反应论文模型在水质预测方面的效果。论文模型可以通过单步或者多步对光伏功率进行预测，实验结果表明，其具有非常优异的表现。本周也针对论文模型进行了简单的复现，预测结果并不非常准确，仍需进一步优化和调参。
ABSTRACT This week, We read a paper on photovoltaic power prediction using Temporal Convolutional Network (TCN) and Long Short-Term Memory (LSTM). Photovoltaic power data is characterized by non-linear and non-stationary patterns, which, to some extent, can reflect the performance of the proposed models in water quality prediction. The paper's models can forecast photovoltaic power through single-step or multi-step predictions, and experimental results demonstrate their outstanding performance.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cc7db5162da45534fe058fe9c2343b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcca3367b302fa801223594ee7420a58/" rel="bookmark">
			IDEA 上传到gitee 详细步骤（适合初学者）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 环境1.1 gitee 简介1.2 gitee发展 2 准备工作2.1 注册登录【gitee】2.2 新建仓库2.3 IDEA配置（1）选择本地仓库位置（2）选择本地仓库位置（3）代码变为红色说明创建成功（4）右击选择【git】（5）选择【git】里面的【add】（6）变颜色说明成功（7）设置远程仓库的地址（8）把本地的资料传递到【git】上 3 一些说明 1 环境 1、Windows10系统
2、IDEA 2018
3、需要下载好git
1.1 gitee 简介 Gitee 是开源中国社区于2013年推出的基于Git的代码托管平台、企业级研发效能平台。它支持中国本土化的代码托管服务，提供私有仓库托管，并为开发者提供稳定、高效、安全的云端软件开发协作平台。无论是个人、团队、或是企业，都可以使用 Gitee 实现代码托管、项目管理、协作开发，同时还有代码质量分析、项目演示等丰富功能。
Gitee 目前已经成为国内最大的代码托管平台，致力于为国内开发者提供优质稳定的托管服务，与GitHub类似区别在于码云国内，GitHub国外。 Gitee 于 2016 年推出企业版，提供企业级代码托管服务，成为开发领域领先的 SaaS 服务提供商。
1.2 gitee发展 2013年，Gitee 前身 Git@OSC 面世。2016年，Gitee 推出企业版，打造一体化的云端协作开发平台。2018年，Gitee 高校版上线。2019年，专注于企业私有化部署的 Gitee 专业版上线。2020年，针对超大规模企业私有化部署 Gitee 旗舰版上线。2020年，承接工信部国家开源托管平台项目。2021年，举办首届全球开源技术峰会 GOTC。2022年，Gitee 用户总数突破 800 万。2023年，拥抱 AI 发展，Gitee 支持 AI 大模型托管。2023年，开源中国/Gitee 获得7.75亿元B+轮战略融资，股份重组成为完全中立平台。 2 准备工作 2.1 注册登录【gitee】 官网：码云官网
登录即可
2.2 新建仓库 创建成功，
2.3 IDEA配置 测试一下是否连上git
（1）选择本地仓库位置 （2）选择本地仓库位置 选择本地项目作为仓库位置，位置可以任意选择。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcca3367b302fa801223594ee7420a58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9bbb60e081209e5b63047b74819f98f/" rel="bookmark">
			Yocto 还是 Buildroot，构建自定义嵌入式系统时，您会选择哪一种？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设您正在采用集成平板开发新一代大型智能微波炉。这个创意不错吧！现在，您需要构建自定义操作系统，在保证不会烧焦食物（更不要烧毁房屋哦）的前提下，辅助管理各项事务。除此之外，您还需要创建一个专门的项目，帮助您实施高效的 Linux 构建，而且，时间必须要快。好消息是：我们有很多不错的项目，都可以帮助您实现目标。但真正的问题是，您应该选择哪一个？
可供选择的方案很多，不过在本文中，我们只重点介绍其中两种最受欢迎的方案：Yocto 和 Buildroot。各个团队出于不同的原因，都希望构建嵌入式系统。对于他们来说，Yocto 和 Buildroot 已经成为他们的首选工具。这两种工具各有不同的优点（和一些缺点），值得我们仔细探讨。因此，让我们深入分析，判断哪一种更适合您。
注意事项 值得注意的是，Yocto 和 Buildroot 本身并不是 Linux 发行版，它们只是帮助开发人员构建基于 Linux 的嵌入式系统（选择 Yocto，您可以构建 Linux 发行版；选择 Buildroot，您可以开发用于构建发行版的根文件系统）。
这是二者之间重要的区别之一，也体现了两个项目之间的差异，以及它们深受喜爱的原因。言归正传，让我们回到原定的主题上来。
首先，介绍一下我们要讨论的对象 让我们深入解析这两种方案及其效果。
Yocto Yocto 是一种伞式项目，侧重于通过开放式嵌入内核，打造嵌入式系统 Linux 发行版，而不受硬件架构的限制。其中要切记的关键是：Yocto 本身并非发行版，而是帮助您构建发行版的框架。Yocto 已然成为必可不少的首选工具。有了它，开发人员和嵌入式系统制造商可以根据其自身硬件和软件限制以及实际应用程序，度身打造最适合自己的 Linux 版本。
更重要的是，Yocto 内置各种现有工具，拥有大量的开源支持，以灵活多变的特点而闻名。丰富的工具、维护、模板和社区产品，可以帮助您完成各种无与伦比的特殊构建任务。Yocto 有三大关键组件：
BitBake —— 实质上就是 Yocto 的构建系统引擎。它负责创建配方，构建特定系统所需的任务列表，以及解析元数据和执行配方。OpenEmbedded-Core —— 元数据，它保存了创建系统所需的基本配方、相关文件和类。构建时设定为通用，以便适用于各种基于 OpenEmbedded 的系统。Poky —— 包含一个基于 Linux 的全平台构建工具和各种其他技术，帮助各大团队以可靠的方式快速地开发新系统。Poky 基于各种架构生成文件系统镜像。其中的典型示例就是 QEMU 全系统仿真，一种极其出色的嵌入式软件测试平台。 Yocto 还支持将其他关键组件（例如 QT、Chromium、LLVM 等）内置到您的嵌入式发行版中，这也是它极受欢迎的原因之一。
Buildroot Buildroot 是一组生成文件和脚本。在它的帮助下，您可以更轻松地在源代码上构建嵌入式 Linux 发行版。与 Yocto 不同，Buildroot 是一个完整的项目，包含多个层级和工具。它的构建目标就是简单方便。Buildroot 的设计理念就是使用尽可能少的核心 Buildroot 工具，避免操作过于复杂，防止增加构建时间。这样，Buildroot 就易于理解和使用。例如，如果条件允许，Buildroot 构建会反复利用现成的工具，如 kconfig，而不是针对每种自定义发行版创建新的工具。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9bbb60e081209e5b63047b74819f98f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34386aa2086036d9807c68e650a65884/" rel="bookmark">
			12.2每日一题（1无穷型幂指函数：二倍角公式&#43;三部曲&#43;等价无穷小代换（只有整体的因子不为0才能先算出来））
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 注意：求极限不能想先算哪里就先算哪里，只有整体的因子不为0才能先算出来，部分不为0不可以先算 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cc80f10f9f761eecb6cbbf0f442d0d4/" rel="bookmark">
			12.1每日一题（1无穷型幂指函数：三部曲（分1！加1减1有时候不好用）&#43;等价无穷小、次幂四则运算&#43;等价无穷小代换）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a0608881dd12d4b4122d85c5b5eac27/" rel="bookmark">
			提升 Python 执行速度：Codon、C/C&#43;&#43;、Rust、Numba(JIT)、Taichi、Nuitka、MatxScript
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几种流行的 Python 性能加速方案对比：https://zhuanlan.zhihu.com/p/604519817
对程序执行性能没有强烈需求的，可以紧跟官方步伐，升级到最新版本的 Python 既可。Numba、Codon、Taichi 等这一类，原理上基本相同，也都是从某个场景发展过来的较为通用的方案，但是也都有各自的一些限制，按照场景选择自己顺手的即可。
Cython、Pybind11、PyO3 可以看做一类，都需要学习新语言，相对而言 Cython 在语言学习上成本最低（10分钟入门Cython：https://zhuanlan.zhihu.com/p/49573586 ）。Pybind11、PyO3 比较适合的场景是为现有的 C++、Rust 代码提供 Python API，如果不想写 C++、Rust，又对性能有很高的诉求，Cython 是个不错的选择，如果是新开项目则可以尝试下 Rust。Codon 是一种 Python 兼容的语言，许多 Python 程序只需要很少的修改就可以工作，如果了解 Python，你就已经知道 99% 的 Codon。 如果追求极致性能，推荐使用 C、C++开发，然后使用 ctypes 粘起来。
如果只熟悉 Python，推荐使用 Codon，兼容 Python 语言。
1、高性能 Python 编译器 Codon Codon 简介 ：https://github.com/exaloop/codon
文档：https://docs.exaloop.io/codon/general/intro
编译器 充当着高级语言与机器之间的翻译官，不同版本的 Python 编译器已被开发出来，其中Codon 就是一个高性能的 Python 编译器。
Codon 作为高性能 Python 编译器，可将 Python 代码编译为本机机器代码，而无需任何运行时开销。在单线程上，Python 的典型加速大约为 10-100 倍或更多。Codon 的性能通常与 C/C++ 的性能相当。与 Python 不同，Codon 支持本机多线程，这可以使速度提高很多倍。Codon 可通过插件基础结构进行扩展，它允许用户合并新的库、编译器优化甚至关键字。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a0608881dd12d4b4122d85c5b5eac27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf08abba714cade5ce2c45292899a423/" rel="bookmark">
			IS420UCSCH1B GE 通用电气工业交换机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IS420UCSCH1B GE 通用电气工业交换机是一款高性能的工业级交换机，具有多种优势和特点。
首先，该交换机采用了高速的以太网交换技术，能够实现快速数据传输和高效网络通信，适用于各种工业应用场景。
其次，IS420UCSCH1B GE 通用电气工业交换机具有坚固耐用、可靠性强、易于维护和安全等特点。它采用工业级设计，能够适应恶劣的工作环境，保证长时间稳定运行。同时，它还支持多种安全协议和加密技术，保障网络通信的安全性和稳定性。
此外，该交换机还支持多种网络协议和接口标准，可以与各种设备进行无缝连接，实现数据的实时传输和共享。它还具有灵活的扩展能力，方便用户进行扩展和升级。
IS420UCSCH1B GE 通用电气工业交换机是一款高性能的设备，具有以下性能特点：
高效性：该交换机采用先进的交换技术，能够实现高速数据传输和低延迟，支持大规模网络流量和并发连接，从而提高网络性能和生产效率。可靠性：IS420UCSCH1B交换机采用高可靠性的设计和制造工艺，具有出色的稳定性和耐用性，能够在恶劣的工业环境中长时间稳定运行，减少故障和停机时间，提高生产效率。安全性：该交换机支持多种安全协议和标准，可以保护网络免受外部干扰和攻击，确保数据的安全性和完整性。灵活性：IS420UCSCH1B交换机支持多种网络协议和标准，可以与各种工业设备和系统无缝集成，实现高效的数据传输和共享。可扩展性：该交换机支持多种扩展模块和选项，可以根据不同的应用需求进行定制配置，适应各种传感器和执行器的需求。经济性：IS420UCSCH1B交换机提供高性价比的解决方案，可以帮助用户降低系统成本和维护成本。此外，它还支持多种语言和国际化标准，可以满足不同国家和地区的需求。 总之，IS420UCSCH1B GE 通用电气工业交换机是一款高效、可靠、安全、灵活和经济性的设备，适用于各种工业控制系统和自动化生产线。
The IS420UCSCH1B GE General Electric Industrial Switch is a high-performance device with the following performance characteristics:
Efficiency: This switch adopts advanced switching technology, which can achieve high-speed data transmission and low latency, support large-scale network traffic and concurrent connections, thereby improving network performance and production efficiency.
Reliability: The IS420UCSCH1B switch adopts a highly reliable design and manufacturing process, which has excellent stability and durability.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf08abba714cade5ce2c45292899a423/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/296d617e9135db5c749f4d66ffc185b2/" rel="bookmark">
			IIS服务启动失败：万维网发布服务(W35VC)已停止。除非万维网发布服务(W3SVO正在运行，否则无法启动网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如上图所示，iis网站服务处于停止状态，当点击启动时，报以下错误：
这是由于系统iis服务被手动停止了。
启动IIS服务 net start w3svc
关闭IIS服务 net stop w3svc
以管理员身份运行cmd
然后打开iis管理器，就可以正常启动网站了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2b6b2e123c45a5a9ef5dc1f68558c23/" rel="bookmark">
			运维中的有趣事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		章节一 运维道路上的些许指令
1.端口测试
telnet IP 端口 root@519fa7d1930d:~# telnet qq.com 80 Trying 58.250.137.36... Connected to qq.com. Escape character is '^]'. nc -vzw 2 ip 端口 Ncat: Version 7.50 ( https://nmap.org/ncat ) Ncat: Connected to 192.168.29.7:6611. Ncat: 0 bytes sent, 0 bytes received in 0.01 seconds. 2.sed替换
sed -ri 's/需要替换的变量/替换成这个变量/g' 文件名 3.Centos解决tab问题
先查找： rpm -qa bash-completion yum查找一下： yum list | grep bash 安装： yum -y install bash-completion 4.解决netstat命令没有的问题
yum install net-tools netstat -ntulp Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2b6b2e123c45a5a9ef5dc1f68558c23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c4482060cd9de7a24be27b733d26a04/" rel="bookmark">
			[git] Git撤销&amp;回滚操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[git] Git撤销&amp;回滚操作 开发过程中，你肯定会遇到这样的场景： 场景一：
糟了，我刚把不想要的代码，commit到本地仓库中了，但是还没有做push操作！
场景二：
彻底完了，刚线上更新的代码出现问题了，需要还原这次提交的代码！
场景三：
刚才我发现之前的某次提交太愚蠢了，现在想要干掉它！
撤销 上述场景一，在未进行git push前的所有操作，都是在“本地仓库”中执行的。我们暂且将“本地仓库”的代码还原操作叫做“撤销”！
情况一：文件被修改了，但未执行git add操作（working tree内撤销）
$ git checkout fileName $ git checkout . 情况二：同时对多个文件执行了git add操作，但本次只想提交其中一部分文件
$ git add * $ git status # 取消暂存 $ git reset HEAD &lt;filename&gt; 情况三：文件执行了git add操作，但想撤销对其的修改（index内回滚）
# 取消暂存 $ git reset HEAD fileName # 撤销修改 $ git checkout fileName 情况四：修改的文件已被git commit，但想再次修改不再产生新的Commit
# 修改最后一次提交 $ git add sample.txt $ git commit --amend -m"说明" 情况五：已在本地进行了多次git commit操作，现在想撤销到其中某次Commit
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c4482060cd9de7a24be27b733d26a04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8bef617dc44c164788f613362158261/" rel="bookmark">
			[git] 远程删除分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [git] 远程删除分支 1. git删除远程分支 git push origin --delete [branch_name] 2. 删除本地分支区别 git branch -d 会在删除前检查merge状态（其与上游分支或者与head）。 git branch -D 是git branch --delete --force的简写，它会直接删除。 共同点
都是删除本地分支的方法（与删除远程分支命令相独立，要想本地和远程都删除，必须得运行两个命令）。
3. git查看分支： 查看本地分支 git branch 查看远程分支 git branch -r 查看本地和远程分支 git branch -a 4.git删除分支： 删除本地分支 git branch -d 本地分支名 删除远程分支 git push origin --delete 远程分支名 推送空分支到远程（删除远程分支另一种实现）git push origin :远程分支 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f4b1c7e1e3cdc57a8d300a7de343ce7/" rel="bookmark">
			[Qt] 软件重启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [Qt]软件重启 //main.cpp void SEHExitConfig() { SetUnhandledExceptionFilter(CallBackUnhandled); SetErrorMode(SEM_NOGPFAULTERRORBOX); set_terminate( TermFunc ); set_unexpected(UnexpectedFunc); } int main { ... ... int retValue = a.exec(); if(retValue == 1000) //自进程重启 { SEHExitConfig(); sema.release(); QString exePath = commandParaList[0]; commandParaList.erase(commandParaList.begin()); QProcess::startDetached(exePath, commandParaList); } } 程序任意处重启： qApp()-&gt;exit(1000); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/893b8108656e3800da0b29454d083ca2/" rel="bookmark">
			【二叉树 OJ题】二叉树基础知识 与 OJ题完成（二叉树构建与遍历问题，子树查找问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树 ！ 二叉树概念与OJ题完成 二叉树 ！1 树1.1 树的概念1.2 树的相关概念1.3 树的表示方式 2 二叉树2.1 二叉树的概念2.2 二叉树的构建2.3 特殊的二叉树 3 二叉树OJ题的解决3.1 二叉树构建与遍历问题3.1.1 二叉树遍历3.1.2 二叉树构建3.1.3 题目完成 3.2 子树查找问题 Thanks♪(･ω･)ﾉ下一篇文章见！！！ 1 树 1.1 树的概念 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。
把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。有一个特殊的结点，称为根结点，根节点没有前驱结点除根节点外，其余结点被分成M(M&gt;0)个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti(1&lt;= i &lt;= m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继因此，树是递归定义的。
1.2 树的相关概念 1.节点的度：一个节点含有的子树的个数称为该节点的度；
2.叶节点或终端节点：度为0的节点称为叶节点；
3.非终端节点或分支节点：度不为0的节点；
4.双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；
5.孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；
6.兄弟节点：具有相同父节点的节点互称为兄弟节点；
7.树的度：一棵树中，最大的节点的度称为树的度；
8.节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
9.树的高度或深度：树中节点的最大层次； 如上图：树的高度为5
10.堂兄弟节点：双亲在同一层的节点互为堂兄弟；
11.节点的祖先：从根到该节点所经分支上的所有节点；
12.子孙：以某节点为根的子树中任一节点都称为该节点的子孙。
13.森林：由m（m&gt;0）棵互不相交的树的集合称为森林；
1.3 树的表示方式 一般来说最简单的想法是使用复杂链表结构
typedef int TreeData; typedef struct TreeNode { TreeData val; struct TreeNode* node1 struct TreeNode* node2 struct TreeNode* node3 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/893b8108656e3800da0b29454d083ca2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fa34242b33e653d6c5c60152975dcad/" rel="bookmark">
			基于深度学习的超分辨率图像技术一览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超分辨率(Super-Resolution)即通过硬件或软件的方法提高原有图像的分辨率，图像超分辨率是计算机视觉和图像处理领域一个非常重要的研究问题，在医疗图像分析、生物特征识别、视频监控与安全等实际场景中有着广泛的应用。
SR取得了显著进步。一般可以将现有的SR技术研究大致分为三大类：监督SR，无监督SR和特定领域SR（人脸）。
先说监督SR。 如今已经有各种深度学习的超分辨率模型。这些模型依赖于有监督的超分辨率，即用LR图像和相应的基础事实（GT）HR图像训练。虽然这些模型之间的差异非常大，但它们本质上是一组组件的组合，例如模型框架，上采样方法，网络设计和学习策略等。从这个角度来看，研究人员将这些组件组合起来构建一个用于拟合特定任务的集成SR模型。由于图像超分辨率是一个病态问题，如何进行上采样（即从低分辨率产生高分辨率）是关键问题。基于采用的上采样操作及其在模型中的位置，SR模型可归因于四种模型框架：预先采样SR，后上采样SR，渐进上采样SR和迭代上下采样SR，如图所示。
除了在模型中的位置之外，上采样操作如何实现它们也非常重要。为了克服插值法的缺点，并以端到端的方式学习上采样操作，转置卷积层（Transposed Convolution Layer）和亚像素层（Sub-pixel Layer）可以引入到超分辨率中。转置卷积层，即反卷积层，基于尺寸类似于卷积层输出的特征图来预测可能的输入。具体地说，它通过插入零值并执行卷积来扩展图像，从而提高了图像分辨率。为了简洁起见，以3×3内核执行2次上采样为例，如图所示。首先，输入扩展到原始大小的两倍，其中新添加的像素值被设置为0（b）。然后应用大小为3×3、步长1和填充1的内核卷积（c）。这样输入特征图实现因子为2的上采样，而感受野最多为2×2。
由于转置卷积层可以以端到端的方式放大图像大小，同时保持与vanilla卷积兼容的连接模式，因此它被广泛用作SR模型的上采样层。然而，它很容易在每个轴上产生“不均匀重叠（uneven overlapping）”，并且在两个轴的乘法进一步产生了特有的不同幅度棋盘状图案，从而损害了SR性能。亚像素层也是端到端学习的上采样层，通过卷积生成多个通道然后重新整形，如图所示。首先卷积产生具有s2倍通道的输出，其中s是上采样因子（b）。假设输入大小为h×w×c，则输出大小为h×w×s2c。之后，执行整形（shuffle）操作产生大小为sh×sw×c的输出（c）。感受野大小可以达到3×3。
由于端到端的上采样方式，亚像素层也被SR模型广泛使用。与转置卷积层相比，亚像素层的最大优势是具有较大的感知场，提供更多的上下文信息，能帮助生成更准确的细节。然而，亚像素层的感受野的分布是不均匀的，块状区域实际上共享相同的感受野，这可能导致在块边界附近的一些畸变。各种深度学习的模型已经被用于SR，如图所示。
ResNet学习残差而不是彻底的映射，已被SR模型广泛采用，如上图（a）所示。其中，残差学习策略可以大致分为两种类型，即全局和局部残差学习。由于超分辨率是图像到图像的转换任务，其中输入图像与目标图像高度相关，全局残差学习仅学习两个图像之间的残差。在这种情况下，它避免学习从完整图像到另一个图像的复杂转换，而只需要学习残差图来恢复丢失的高频细节。由于大多数区域残差接近于零，模型的复杂性和学习难度都大大降低。这种方法在预上采样的SR框架普遍采用。局部残差学习类似于ResNet的残差学习，用于缓解不断增加的网络深度引起的退化问题并提高学习能力。实践中，上述方法都是通过快捷连接（通常有小常数因子的缩放）和逐元素加法操作实现的。区别在于，前者直接连接输入图像和输出图像，而后者通常在不同深度的网络中层之间添加多个快捷方式。• 递归学习递归学习（以递归方式多次应用相同模块）也被超分辨率采用，如上图 （b）所示。在实践中，递归学习固有地带来了消失（vanishing）或爆涨（exploding）梯度问题，因此残差学习和多信号监督等一些技术通常与递归学习相结合，以减轻这些问题。• 通道关注考虑到不同通道之间特征表征的相互依赖和作用，一种“挤压-激发（SAE，squeeze-and-excitation）”模块明确对通道相互依赖性建模，来提高表示能力，如上图（c）所示。其中用全局平均池化将每个输入通道压缩到通道描述子（即一个常数）中，然后将这些描述子馈送到两个全连接层产生通道尺度因子。基于通道乘法，用尺度因子重新缩放输入通道得到最终输出。• 致密连接致密连接在视觉任务中变得越来越流行。在致密块的每个层，所有前层的特征图用作输入，并且其自身特征图用作所有后续层的输入，在一个有l层致密块中带来l·（l - 1）/ 2个连接。致密连接，不仅有助于缓解梯度消失问题、增强信号的传播并促进特征重用，而且在连接之后采用小增长率（即致密块的通道数）和通道缩减来大大减少参数量。为了融合低级和高级特征以提供更丰富的信息来重建高质量的细节，致密连接被引入SR领域，如上图（d）所示。• 多路径学习多路径学习指模型存在多个路径传递特征，这些路径执行不同的操作以提供更好的建模功能。具体而言，它可以分为三种类型：全局法、局部法和特定尺度法。全局多路径学习是指用多个路径提取图像不同方面的特征。这些路径可以在传播中相互交叉，从而大大增强了特征提取的能力。本地多路径学习用新块进行多尺度特征提取，如上图（e）所示。该块采用不同内核大小的卷积同时提取特征，然后将输出连接起来并再次进行相同的操作。快捷方式通过逐元素添加来连接该块的输出和输入。通过这种局部多路径学习，SR模型可以更好地从多个尺度提取图像特征，进一步提高性能。特定尺度多路径学习共享模型的主要部分（即特征提取的中间部分），并分别在网络的开头和结尾附加特定尺度的预处理路径和上采样路径，如上图（f）所示。在训练期间，仅启用和更新与所选尺度对应的路径。这样大多数参数在不同尺度上共享。• 高级卷积卷积运算是深度神经网络的基础，改进卷积运算可获得更好的性能或更快的速度。这里给出两个方法：扩张卷积（Dilated Convolution）和群卷积（Group Convolution）。众所周知，上下文信息有助于在图像超分辨率生成逼真的细节。扩张卷积能将感受野增加两倍，最终实现更好的性能。群卷积以很少的性能损失可减少大量的参数和操作，如上图（g）所示。• 像素递归学习大多数SR模型认为这是一个与像素无关的任务，因此无法正确地确定生成像素之间的相互依赖性。在人注意力转移机制推动下，一种递推网络可依次发现参与的补丁并进行局部增强。以这种方式，模型能够根据每个图像自身特性自适应地个性化最佳搜索路径，从而充分利用图像全局的内依赖性（intra-dependence）。不过，需要长传播路径的递归过程，特别对超分辨率的HR图像，大大增加了计算成本和训练难度。• 金字塔池化金字塔池化模块更好地利用全局和局部的上下文信息，如上图（h）所示。具体地，对于尺寸为h×w×c的特征图，每个特征图被划分为M×M个区间，并经历全局平均池化产生M×M×c个输出。然后，执行1×1卷积输出压缩到一个单信道。之后，通过双线性插值将低维特征图上采样到与原始特征图相同的大小。使用不同的M，该模块可以有效地整合全局和局部的上下文信息。• 小波变换众所周知，小波变换（WT）是一种高效的图像表示，将图像信号分解为表示纹理细节的高频小波和包含全局拓扑信息的低频小波。将WT与基于深度学习的SR模型相结合，这样插值LR小波的子带作为输入，并预测相应HR子带的残差。WT和逆WT分别用于分解LR输入和重建HR输出。另外学习策略问题，涉及损失函数的设计（包括像素损失，内容损失，纹理损失，对抗损失和周期连续损失）、批处理归一化（BN）、课程学习（Curriculum Learning）和多信号监督（Multi-supervision）等等。
再说无监督SR。 现有的超分辨率工作主要集中在监督学习上，然而难以收集不同分辨率的相同场景的图像，因此通常通过对HR图像预定义退化来获得SR数据集中的LR图像。为了防止预定义退化带来的不利影响，无监督的超分辨率成为选择。在这种情况下，只提供非配对图像（HR或LR）用于训练，实际上得到的模型更可能应对实际场景中的SR问题。• 零击（zero shot）超分辨率单个图像内部的统计数据足以提供超分辨率所需的信息，所以零击超分辨率（ZSSR）在测试时训练小图像特定的SR网络进行无监督SR，而不是在大数据集上训练通用模型。具体来说，核估计方法直接从单个测试图像估计退化内核，并在测试图像上执行不同尺度因子的退化来构建小数据集。然后在该数据集上训练超分辨率的小CNN模型用于最终预测。ZSSR利用图像内部特定信息的跨尺度复现这一特点，对非理想条件下（非bi-cubic退化核获得的图像，受模糊、噪声和压缩畸变等影响）更接近现实世界场景的图像，比以前的方法性能提高一大截，同时在理想条件下（bi-cubic插值构建的图像），和以前方法结果差不多。尽管这样，由于需要在测试期间为每个图像训练单个网络，使得其测试时间远比其他SR模型长。• 弱监督SR为了在超分辨率中不引入预退化，弱监督学习的SR模型，即使用不成对的LR-HR图像，是一种方案。一些方法学习HR-LR退化模型并用于构建训练SR模型的数据集，而另外一些方法设计周期循环（cycle-in-cycle）网络同时学习LR-HR和HR-LR映射。由于预退化是次优的，从未配对的LR-HR数据集中学习退化是可行的。一种方法称为“两步法”：
1）训练HR-LR 的GAN模型，用不成对的LR-HR图像学习退化；2）基于第一个GAN模型，使用成对的LR-HR图像训练LR- HR 的GAN模型执行SR。 对于HR到LR 的GAN模型，HR图像被馈送到生成器产生LR输出，不仅需要匹配HR图像缩小（平均池化）获得的LR图像，而且还要匹配真实LR图像的分布。训练之后，生成器作为退化模型生成LR-HR图像对。对于LR到HR 的GAN模型，生成器（即SR模型）将生成的LR图像作为输入并预测HR输出，不仅需要匹配相应的HR图像而且还匹配HR图像的分布 。在“两步法”中，无监督模型有效地提高了超分辨率真实世界LR图像的质量，比以前方法性能获得了很大改进。无监督SR的另一种方法是将LR空间和HR空间视为两个域，并使用周期循环结构学习彼此之间的映射。这种情况下，训练目的包括推送映射结果去匹配目标的域分布，并通过来回（round trip）映射使图像恢复。• 深度图像先验知识CNN结构在逆问题之前捕获大量的低级图像统计量，所以在执行SR之前可使用随机初始化的CNN作为手工先验知识。具体地讲，定义生成器网络，将随机向量z作为输入并尝试生成目标HR图像I。训练目标是网络找到一个Iˆ y，其下采样Iˆy与LR图像Ix相同。因为网络随机初始化，从未在数据集上进行过训练，所以唯一的先验知识是CNN结构本身。虽然这种方法的性能仍然比监督方法差很多，但远远超过传统的bicubic上采样。此外，表现出的CNN架构本身合理性，促使将深度学习方法与CNN结构或自相似性等先验知识相结合来提高超分辨率。
特定SR。 特定SR领域主要包括深度图、人脸图像、高光谱图像和视频等内容的SR应用。面部图像超分辨率，即面部幻觉（FH， face hallucination），通常可以帮助其他与面部相关的任务。与通用图像相比，面部图像具有更多与面部相关的结构化信息，因此将面部先验知识（例如，关键点，结构解析图和身份）结合到FH中是非常流行且有希望的方法。利用面部先验知识的最直接的方式是约束所生成的HR图像具有与基础事实（GT）的HR图像相同的面部相关信息。与全色图像（PAN，panchromatic images），即具有3个波段的RGB图像相比，有数百个波段的高光谱图像（HSI，hyperspectral images）提供了丰富的光谱特征并有助于各种视觉任务。然而，由于硬件限制，收集高质量的HSI比收集PAN更困难，收集的HSI分辨率要低得多。因此，超分辨率被引入该领域，研究人员倾向于将HR PAN和LR HSI结合起来预测HR HSI。就视频超分辨率而言，多个帧提供更多的场景信息，不仅有帧内空间依赖性而且有帧间时间依赖性（例如，运动、亮度和颜色变化）。大多数方法主要集中在更好地利用时空依赖性，包括显式运动补偿（例如，光流算法、基于学习的方法）和递归方法等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f76fef21e287b71201213f46b19f706/" rel="bookmark">
			机器学习算法性能评估常用指标总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		考虑一个二分问题，即将实例分成正类（positive）或负类（negative）。对一个二分问题来说，会出现四种情况。如果一个实例是正类并且也被 预测成正类，即为真正类（True positive）,如果实例是负类被预测成正类，称之为假正类（False positive）。相应地，如果实例是负类被预测成负类，称之为真负类（True negative）,正类被预测成负类则为假负类（false negative）。
TP：正确肯定的数目；
FN：漏报，没有正确找到的匹配的数目；
FP：误报，给出的匹配是不正确的；
TN：正确拒绝的非匹配对数；
列联表如下表所示，1代表正类，0代表负类：
预测1预测0实际1True Positive(TP)False Negative(FN)实际0False Positive(FP)True Negative(TN) 1. TPR、FPR&amp;TNR 从列联表引入两个新名词。其一是真正类率(true positive rate ,TPR), 计算公式为
TPR = TP / (TP + FN)
刻画的是分类器所识别出的 正实例占所有正实例的比例。
另外一个是负正类率(false positive rate, FPR),计算公式为
FPR = FP / (FP+ TN)
计算的是分类器错认为正类的负实例占所有负实例的比例。
还有一个真负类率（True Negative Rate，TNR），也称为specificity，计算公式为
TNR = TN /(FP+ TN) = 1 - FPR
2. 精确率Precision、召回率Recall和F1值 精确率（正确率）和召回率是广泛用于信息检索和统计学分类领域的两个度量值，用来评价结果的质量。其中精度是检索出相关文档数与检索出的文档总数的比率，衡量的是检索系统的查准率；召回率是指检索出的相关文档数和文档库中所有的相关文档数的比率，衡量的是检索系统的查全率。
一般来说，Precision就是检索出来的条目（比如：文档、网页等）有多少是准确的，Recall就是所有准确的条目有多少被检索出来了，两者的定义分别如下：
Precision = 提取出的正确信息条数 / 提取出的信息条数
Recall = 提取出的正确信息条数 / 样本中的信息条数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f76fef21e287b71201213f46b19f706/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dec8c1398a83e10e202b3fb570a5dd4e/" rel="bookmark">
			【C&#43;&#43;】早绑定、析构与多态 | 一道关于多态的选择题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文首发于 ❄️慕雪的寒舍
今天在和群友聊天的时候看到了一道很坑的题目，分享给大家
1.看题！ 先来看看题目
struct Dad { public: Dad(){ echo();} ~Dad(){ echo();} virtual void echo() { cout &lt;&lt; "DAD "; } }; struct Son:Dad { public: void echo() const override { cout &lt;&lt; "SON "; } }; Son ss; 请问这个的输出是什么？
A "DAD DAD " B "DAD SON " C "SON DAD " D "SON SON " E 编译出错 F 运行出错 答案是E，编译出错！
2.涉及到的知识点 2.1 知识点 先来说说这道题目里面涉及到了什么知识点
多态调用；多态重写函数需要满足什么条件；类内函数后加const的作用；类内函数后加override的作用；什么是早绑定和晚绑定 一个一个复习吧！
多态调用是父类指针/引用指向子类时，调用虚函数会调用子类重写后的版本多态重写函数的条件：函数名/参数/返回值都必须相同（注意还有协变）类内函数后加const修饰的是这个对象的this指针，被修饰的函数中无法修改类内成员变量类内函数后加override是让编译器来严格检查是否构成重载早绑定：静态绑定；晚绑定：动态绑定（具体请看CPP多态的博客） 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dec8c1398a83e10e202b3fb570a5dd4e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/57/">«</a>
	<span class="pagination__item pagination__item--current">58/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/59/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>