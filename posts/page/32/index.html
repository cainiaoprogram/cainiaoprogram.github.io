<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab089f10a0fbd71047d179e6b947340e/" rel="bookmark">
			提升网络安全重要要素IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字化时代，网络安全已经成为人们关注的焦点。本文将深入探讨网络安全与IP地址之间的紧密联系，以及IP地址在构建数字世界的前沿堡垒中的关键作用。
网络安全是当今数字社会中不可忽视的挑战之一。而IP地址，作为互联网通信的基础协议，既是数字化时代的桥梁，也是网络安全的关键节点。本文将剖析IP地址在网络安全领域的作用，以及如何利用其特性建立有效的网络安全策略。
IP地址的基础知识
IP地址（Internet Protocol address）是一种用于标识和定位网络上设备的数字标签。它分为IPv4和IPv6两个版本，其中IPv6由于更大的地址空间更适应互联网的不断增长。
IP地址与网络安全的紧密关系
身份识别与追踪：IP地址可用于识别设备和用户，帮助追踪网络活动。在网络安全中，追溯攻击源头对于调查和防范威胁至关重要。
访问控制：IP地址作为访问控制的基础，允许或阻止特定IP地址的访问，有助于保护敏感数据和资源。
流量监控和分析：通过分析网络流量中的IP地址，网络管理员可以监控异常活动，检测潜在的攻击，并及时做出反应。
入侵检测和防御：入侵检测系统（IDS）和入侵防御系统（IPS）使用IP地址信息来识别和防范潜在的威胁，提高网络的安全性。
IP地址在网络安全中的应用
黑白名单过滤：利用已知的恶意IP地址建立黑名单，同时将受信任的IP地址列入白名单，有助于过滤恶意流量，提高网络安全性。
地理位置信息利用：利用IP地址的地理位置信息，网络管理员可以进行地理位置过滤，限制来自特定地区的访问，降低潜在威胁。IP地址查询：IP数据云 - 免费IP地址查询 - 全球IP地址定位平台
虚拟专用网络安全：IP地址在建立VPN连接时发挥重要作用，确保远程用户的安全连接，防范信息泄漏风险。
挑战与应对策略
隐私问题：IP地址的收集与隐私问题密切相关。采用匿名化技术、合规规定等手段，平衡安全需求和用户隐私。
IP欺骗和地址伪造：攻击者可能通过IP欺骗和地址伪造来规遍检测。网络安全专业人员需要采用先进的检测技术，及时发现异常行为。
未来发展方向
人工智能与机器学习应用：结合人工智能和机器学习，提高对异常行为的识别能力，降低误报率。
区块链技术：区块链的去中心化特性可以帮助建立更加安全、透明的IP地址管理系统，防范地址劫持等攻击。
IP地址作为网络通信的基石，与网络安全紧密相连。构建数字世界的前沿堡垒需要网络安全专业人员充分理解和利用IP地址的信息，采取有效的策略应对不断演化的威胁。未来，随着技术的不断发展，IP地址在网络安全领域的重要性将更为凸显。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff75679642bdb4cb11eb6b87c4c37585/" rel="bookmark">
			C#上位机与欧姆龙PLC的通信10----开发专用的通讯工具软件(WPF版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、介绍 上节开发了一个winform版的通讯测试工具，这节再搞个wpf版的，wpf是什么？请自行百度，也可以看前面的博客，WPF真入门教程，wpf的界面效果是比winform漂亮，因为wpf使用了web项目中的css样式来美化界面，在这个例子中用到wpf的控件，资源样式，命令绑定等，采用的是mvvm的渲染模式，界面如图：
前面的winform界面：
2、开工干 2.1 创建wpf项目 2.2 创建目录及PLC模型类对象 2.3 创建自定义的消息弹窗 MsgBoxWindow.xaml代码
&lt;Window x:Class="OmronFinsWPFApp.MsgBoxWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:local="clr-namespace:OmronFinsWPFApp" mc:Ignorable="d" Title="消息框" Height="200" Width="420" WindowStartupLocation="CenterScreen" BorderThickness="1,0,1,1" ResizeMode="NoResize" WindowStyle="None" AllowsTransparency="True" Background="Transparent"&gt; &lt;Window.Resources&gt; &lt;Style TargetType="Button" x:Key="msgbtnStyle"&gt; &lt;Setter Property="Width" Value="60"/&gt; &lt;Setter Property="Height" Value="25"/&gt; &lt;Setter Property="Margin" Value="10,0,15,0"/&gt; &lt;/Style&gt; &lt;/Window.Resources&gt; &lt;Grid Background="Transparent" MouseLeftButtonDown="Grid_MouseLeftButtonDown" &gt; &lt;Border BorderBrush="#FFA9AEB1" BorderThickness="2" CornerRadius="10" Margin="5"&gt; &lt;Border.Effect&gt; &lt;DropShadowEffect BlurRadius="10" Color="#FFB8BBC8" Direction="300" ShadowDepth="2"/&gt; &lt;/Border.Effect&gt; &lt;Border.Background&gt; &lt;LinearGradientBrush EndPoint="0.5,1" StartPoint="0.5,0"&gt; &lt;GradientStop Color="#FFFBFBFB" Offset="0.16"/&gt; &lt;GradientStop Color="#FFB4D8E2" Offset="0.986"/&gt; &lt;/LinearGradientBrush&gt; &lt;/Border.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff75679642bdb4cb11eb6b87c4c37585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/915f205ee27b817e9afd0db40b8e64ee/" rel="bookmark">
			Vue3-37-路由-组件内的路由守卫 onBeforeRouteLeave 和 onBeforeRouteUpdate
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 组件内的路由守卫，实际上就是两个 API 方法。 他们与普通的守卫不同的是 ： 他们是写在组件内的，在组件中监听路由的变化，不是全局的，比较灵活。 以下是两个 API 的功能说明： onBeforeRouteLeave() : 守卫在当前路由离开时触发，例如 ：从 /c 跳转到 /a
onBeforeRouteUpdate(): 守卫在当前路由发生改变时触发,例如 ： 从 /c/100 跳转到 /c/200
案例 本案例演示上述两个 API 的基本使用，没有太多的逻辑操作。
路由配置 // 导入 定义路由的两个方法 import {createRouter,createWebHistory} from 'vue-router' // 引入组件 import componentA from "./componentA.vue"; import componentC from "./componentC.vue"; // 声明路由跳转的路径与组件的对应关系 const routsList = [ {path:'/a',name:'aroute',component:componentA}, { path:'/c/:id', name:'croute', component:componentC } ] // 创建路由的实例对象 const routerConfigObj = createRouter({ history:createWebHistory('abc'), // 带一个参数，表示是路由的一个前缀 routes:routsList // 指定路由的配置列表 }) // 导出路由的对象 export default routerConfigObj; 组件C 中的API 使用代码(核心) &lt;template&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/915f205ee27b817e9afd0db40b8e64ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ecf2fd479a4db412785c1a7c6482fd5/" rel="bookmark">
			Spring Boot 生产就绪中文文档-上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为官方文档直译版本。原文链接
由于篇幅较长，遂分两篇。下半部分中文文档
Spring Boot 生产就绪中文文档-上 引言启用 Production-ready 功能端点（Endpoints）启用端点暴露端点安全跨域请求伪造保护 配置端点敏感值脱敏执行器网络终端的超媒体CORS 支持实现自定义端点接收输入输入类型转换 自定义 Web 端点Web 端点请求谓词路径HTTP 方法消耗生产Web 端点响应状态Web 端点范围请求Web 端点安全 Servlet 端点控制器端点 健康信息自动配置HealthIndicators编写自定义HealthIndicators反应式健康指标自动配置ReactiveHealthIndicators健康小组数据源健康 Kubernetes 探针利用 Kubernetes 探测器检查外部状态应用程序生命周期和探针状态 应用信息自动配置InfoContributors自定义应用信息Git 提交信息构建信息Java 信息OS 信息编写自定义InfoContributors 通过 HTTP 进行监控和管理自定义管理端点路径自定义管理服务器端口配置管理专用 SSL自定义管理服务器地址禁用 HTTP 端点通过 JMX 进行监控和管理自定义 MBean 名称禁用 JMX 端点 可观察性（Observability）通用键值防止观察OpenTelemetry 支持 Loggers配置Logger 引言 Spring Boot 包含大量附加功能，可帮助您在将应用程序推向生产时对其进行监控和管理。您可以选择使用 HTTP 端点或 JMX 来管理和监控应用程序。审计、健康状况和指标收集也可自动应用于您的应用程序。
启用 Production-ready 功能 spring-boot-actuator 模块提供了 Spring Boot production-ready 的所有功能。启用这些功能的推荐方法是添加对 spring-boot-starter-actuator "Starter "的依赖。
执行器(Actuator)的定义
执行器是一个制造术语，指用于移动或控制某物的机械装置。推杆可以通过微小的变化产生较大的运动。
要将执行器添加到基于 Maven 的项目中，请添加以下 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ecf2fd479a4db412785c1a7c6482fd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c4a463480603d44cbb2cf2493ff0868/" rel="bookmark">
			MySQL基础笔记（4）DQL数据查询语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DQL用于查找数据库中存放的记录~
目录
一.语法
二.基础查询
1.查询多个字段
2.设置别名
3.去除重复记录
三.条件查询
1.基础语法
2.常见条件
四.分组查询
1.聚合函数
2.语法
五.排序查询
六.分页查询
附注：DQL执行顺序
1.编写顺序
2.执行顺序 ​​​​​​​
一.语法 select：字段列表from：表名列表where：条件列表group by：分组字段列表having：分组后条件列表order by：排序字段列表limit：分页参数 二.基础查询 1.查询多个字段 select 字段1,字段2,...from 表名; 当要查询全部的字段时，可以采用如下的操作：
select * from 表名; 不过实际开发中不建议这样写，一方面效率不高，另一方面并不直观~ 2.设置别名 意义在于赋予字段更加直接现实的意义~
select 字段名 as 别名 from 表名; 3.去除重复记录 select distinct 字段列表 from 表名; 三.条件查询 1.基础语法 select 字段名 from 表名 where 条件列表; 注意：条件可以有多个~ 2.常见条件 in相当于一个并列多项的“or”：（满足其一即可）
select * from students where age in(21,23); 如上，查询年龄为21岁或者23岁的存在~
like用于模糊匹配的场景：_表示一个任意字符，而%表示多个任意字符
如：任意两个字符组成的名字，即“--”最后一位是h的字符串：“%h”——前面是什么、多少个都无所谓~ null值时一定要注意是is null的运算公式不等号&lt;&gt;是一个比较区别于主流语言的写法~between后面跟着最小值，and后面跟着最大值，顺序很重要（类比积分上下限，虽然没什么理论上的相似性） 四.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c4a463480603d44cbb2cf2493ff0868/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8ac6ef2cfe3fd6d1d5965de9c2d8446/" rel="bookmark">
			2022版全站最全最详细的python零基础学习路线（附14张脑图，一套学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是博主学习Python时的一套学习路线，花了两周的时间整理出来，分享给大家。希望这套Python学习路线图 能对Python初学者有帮助，少走弯路。同时也给大家分享一些我觉得对于零基础同学比较有帮助的学习资料，放在文末了，需要的小伙伴可以拿去看看，希望能帮助到大家。
一、基础知识 Python语言特点基本规则变量赋值如何运行Python计算机语言标识符Python对象动态类型内存管理IO编程流程模块结构和布局 二、数据类型 “类型”的作用标准类型数值类型其它 三、序列 内涵操作符BIF 四、字符串 操作符独特特性编码问题BIF 五、列表|元素 listtuple拷贝问题 六、字典|集合 dictset 七、条件|循环 条件循环相关BIF列表解析迭代器生成器 八、文件对象 文件对象文件迭代标准文件对象分隔符 九、错误|异常 概述异常处理调试补充 十、函数 概述装饰器参数函数式编程匿名函数高阶函数 BIF返回函数变量作用域偏函数 十一、模块 概述包作用域标准文件模板名称空间 十二、面向对象编程 基本概念结构继承与多态BIF对象的性质访问限制总结 这就是我为大家整理的Python学习路线，不论是入门还是精进Python，这 14 张图都值得反复多看看。
Python 入门 相信很多人学习某门编程语言的时候，都会找各种学习资源。说句实话，资源太多，反而没用，根据自己所需要的，选择相应的资源坚持学就好了。
因为每个人的需求不同，这里我也把三个月到入职所学的一批 Python比较好的学习资源整理了出来：
朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】
一、Python所有方向的学习路线
Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python课程视频
我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
三、Python实战案例
光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
四、Python漫画教程
用通俗易懂的漫画，来教你学习Python，让你更容易记住，并且不会枯燥乏味。
五、互联网企业面试真题
我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c2f038f16448e05c861d75e20c80efc/" rel="bookmark">
			Apache Paimon:Streaming Lakehouse is Coming
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：本文整理自阿里云智能开源表存储负责人，Founder of Paimon，Flink PMC 成员李劲松（花名：之信）、同程旅行大数据专家，Apache Hudi &amp; Paimon Contributor 吴祥平、汽车之家大数据计算平台负责人邸星星、联通数科大数据高级技术专家，Apache Paimon Contributor 王云朋在 Flink Forward Asia 2023 主会场的分享。内容主要分为以下三部分：
数据分析架构从 Hive 到 LakehouseApache Paimon用户对话环节：Paimon 企业实践分享 点击查看原文视频
一、数据分析架构从 Hive 到 Lakehouse 旧的数据分析架构如 Hive、Hadoop、HDFS、MapReduce、HiveSQL、Hive 存储等，如今国内外的各大企业都在逐步转向 Lakehouse 架构，即 Spark、Flink、Presto，底层的湖存储格式：Iceberg、Delta、Hudi，以及下面数据存储在 HDFS、对象存储 OSS 或 S3。
1.1 Lakehouse 架构的优势 之所以进行架构的转变与迁移，是因为湖仓架构为数据分析与存储带来了诸多益处。
实现了计算存储分离
旧的架构 Hadoop 计算存储都在一个集群中，若要扩容，就要计算与存储部分同时扩容，但目前，各行各业都会有庞大的数据，却不一定可以匹配足够的计算，行业现状催生了计算存储分离的需求。如此，可以实现存储变大的同时，计算资源基本维持不变，当落到 OSS 对象存储上之后，计算存储分离变得非常简单。
实现了存储冷热分层
这是对象存储带来的独特优势。对于对象存储，我们可以利用它的冷存，因为其价格相对低廉，但其冷存访问成本会上升，因此，不常使用的数据可以使用冷存，从而大大降低成本。
操作更加灵活
前面提到的两点实际上 Hive 存储也可以实现，但相较而言，Lakehouse 操作更加灵活，因为湖存储格式提供了更多的 ACID，包括 DELETE、UPDATE 之类的语法，可以让数仓的操作更加方便，而不像 Hive 只能 INSERT OVERWRITE。
查询速度更快
因为湖存储带来的 Meta 上的 skipping 可使得数据根据 Filter 条件做出更多的下推，查询性能更高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c2f038f16448e05c861d75e20c80efc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16e35fbbd5a59bc8b06eb10d463b18fe/" rel="bookmark">
			神仙级python数据分析入门教程(非常详细)，零基础入门到精通，从看这篇开始！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近几年，互联网领域进入大数据红利时代。包括腾讯、阿里、字节在内的各大巨头，依靠基于大数据的商业模式成为了当下最挣钱的公司。
所以行业对数据人才的需求量巨大，仅字节一家在本季度就有近千个数据类职位虚席以待。以当下的发展速度，未来数据类岗位的需求量将呈指数级上升。
据统计，掌握数据分析技能的职场人，其薪资是其他同行的两至三倍，普遍月薪均不低于35K，精通者年薪500K很轻松。
学习数据分析技能，是公认的涨薪捷径。对新手来说，想入门数据分析却并不容易。
虽然网上能够找到的学习资源很多，但是很多繁琐而又杂乱的内容，除了给初学者增加理解和认识的噪音外，真正能够起到明确的方向指引导的，确实不多。
以至于很多人一开始没有明确的方向就一头扎进去，学了很久却不知道自己到底在学什么，或者自己学了很久不知道能够做什么。
学习一门技术之前，你应该知道，你想要达成的目标是什么样的。
也就是说，你想通过这门技术来解决哪些问题。你就可以知道要达成这样的目标，它的知识体系是怎么样的。
今天就分享给大家这份字节大佬开源分享的《Python数据分析实例》，从入门到精通成体系的一套教程，非常适合初学者以及想要进阶的同学。
第1章 准备工作 第2章 引言 第3章 ipython：一种交互式计算和开发环境 ipython基础内省使用命令历史与操作系统交互软件开发工具ipython html notebook利用ipython提高代码开发效率的几点提示高级ipython功能 第4章 numpy基础：数组和矢量计算 numpy的ndarray：一种多维数组对象通用函数：快速的元素级数组函数利用数组进行数据处理用于数组的文件输入输出线性代数随机数生成范例：随机漫步 第5章 pandas入门 pandas的数据结构介绍基本功能汇总和计算描述统计处理缺失数据层次化索引其他有关pandas的话题 第6章 数据加载、存储与文件格式 读写文本格式的数据二进制数据格式使用html和web api使用数据库 第7章 数据规整化：清理、转换、合并、重塑 合并数据集重塑和轴向旋转数据转换字符串操作示例：usda食品数据库 第8章 绘图和可视化 matplotlib api入门pandas中的绘图函数绘制地图：图形化显示海地地震危机数据python图形化工具生态系统 第9章 数据聚合与分组运算 groupby技术数据聚合分组级运算和转换透视表和交叉表示例：2012联邦选举委员会数据库 第10章 时间序列 日期和时间数据类型及工具时间序列基础日期的范围、频率以及移动时区处理… 第11章 金融和经济数据应用 数据规整化方面的话题分组变换和分析更多示例应用 第12章 numpy高级应用 ndarray对象的内部机理高级数组操作广播ufunc高级应用结构化和记录式数组更多有关排序的话题高级数组输入输出性能建议 上述这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【python数据分析实例】
以上就是这份《Python数据分析实例》，大家学的时候完全不用担心，其实我们每个人都天生数据敏感，自带分析事物的天赋，只不过在没有分析方法加持之前，我们凭的是经验和直觉。
你不必完全回炉重造，像开发程序一样去学代码、像考试一样去背函数和方法，只需要一些业务的常识，像均值、极值、排序、相关性、中位数……
这些东西我们信手捏来的东西往往占据数据分析的绝大多数内容，你所学的只不过是实现这些的工具而已。
就像一个100行的数据，给任何一个智力正常的人，不用任何工具和编程技术，他也能获得一份基本的结论，而工具则是让我们在效率、可扩展性和实现维度方面得到更好的提升，仅此而已。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e69a7e30269fffa2a56aee9a54511a4d/" rel="bookmark">
			解决 POST http://x.x.x.x:8000/aaa/ net::ERR_CONNECTION_TIMED_OUT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下我遇到的问题和解决办法
我的项目前后端分离，在前端用的vue访问后端时连接不上后端，一切操作都触发不了后端，数据也传不到后端去；
原因：url有问题，url地址写的不是本机，所以导致连接超时无法连接后端；
解决办法：将url改成自己的，就可以连接上后端了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94e353e6c88fba1bbbc014de7d0a7e0a/" rel="bookmark">
			如何选择最适合的采购付款 (P2P) 解决方案？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无论企业的业务流程执行得如何，流程中始终存在改进空间。更好的管理系统是获得更好结果的关键，尤其是当企业处于增长阶段时。强大的采购到付款（P2P）系统是加快采购流程，同时保持采购支出可见性的最有效方法之一。
什么是采购到付款系统？
进入 21 世纪以来，数字化转型已深入到所有业务领域，包括 P2P 流程。由于电子采购软件（如采购到付款系统）的使用日益广泛，曾经冗长、成本高昂、动辄就会受到干扰和破坏的一系列手工工作流程，如今已发展成为一个更加便捷、高效的流程。
P2P 流程本身涵盖三个特定领域：
1、采购
● 供应商评估和选择
● 征求建议书（RFP）或采购申请（内部）
● 合同谈判
● 采购订单流程
● 接收并记录货物和服务（货物接收）
2、开具发票
● 供应商向买方开具发票（可包括电子发票）
● 三方匹配和异常调节
● 发票审批
3、付款
● 付款审批工作流程
● 通过应付账款付款
● 更新会计记录
采购到付款系统的目标都很简单：利用技术实现 P2P 流程的自动化和精细化。实施电子采购软件所支持的具体目标可能因组织而异，但总的来说包括以下目标：
● 改善现金流。
● 消除欺诈和异常支出，同时实现总支出的可视性。
● 优化业务流程，减少浪费，消除人为错误，提高生产率。
● 通过透明的供应链管理支持战略性支出。
● 在所有工作流程中实施持续改进，并及时让所有业务部门参与类似的流程优化。
● 将采购部门从最低限度的节约来源转变为可靠的增值来源。
一般来说，企业研究和实施采购到付款系统有两个最常见原因：
1.企业正在采取措施，通过升级过时的人工工作流程来迎接数字化转型。这需要企业文化的重大转变，尤其是在传统大于创新的企业。采购团队可能需要向最高管理者提出令人信服的理由，以启动这一进程，并在过渡前、过渡期间和过渡后开展教育和培训工作，以确保企业完全接受。
2.企业现有一个过时的企业资源规划（ERP）系统，该系统正在升级以满足不断变化的需求。与纸质流程带来的浪费、延误和挫败感相比，企业目前使用的解决方案在其鼎盛时期能显著提高绩效。它甚至具有一些前瞻性的功能，如与会计系统集成或审批实时警报。
但现在，该系统已经有点力不从心了，在当今竞争激烈、自动化驱动的市场中，保持竞争能力、生产率和健康的利润已经超出了它的能力范围。
为企业找到合适的采购到付款系统
选择和实施采购到付款系统等重大流程转型时，首先需要进行需求分析。确定最需要关注和改进的领域，是找到最能满足这些需求的采购软件的第一步。
在考虑任何 P2P 解决方案之前，需要理清以下问题：
1.当前的 P2P 流程状况如何？无法看到或量化的东西是无法衡量、修复或简化的。
2.哪些采购流程需要优化？ 贵公司是否需要在现有的软件环境中添加新功能，或者贵公司是否在寻求向数字化采购管理转型？或是更换过时的解决方案？是否需要通过战略采购工具或专用合同管理解决方案来全面控制整个供应链？
3.哪些问题需要优先考虑？对于一些公司来说，控制异常支出和整顿供应链是首要任务。其他公司可能已经有了处理付款的ERP系统，需要一个可靠兼容的解决方案来自动处理从采购申请到最终发票之间的所有工作。
4.哪些利益相关者对转型的成功至关重要？从上层管理人员到使用新系统采购商品和服务的员工，在转换之前、期间和之后，确定并与流程中的每个重要人员进行接触，这样更有可能成功实施。
5.在研究、实施和跟进方面的预算和时限是多少？找到愿意花时间与企业一起制定方案并提供培训的供应商，可以缩短时间、降低成本、减少停机时间，同时提高用户性能和合规性。
例如，国内资深企业管理软件厂商高亚科技与客户合作，提供专门的采购管理解决方案8Manage SRM，在满足当前需求的同时，还为企业未来发展留有余地。
8Manage SRM采购管理软件为各种规模的企业提供简单明了、功能强大且灵活的采购到付款功能。该系统通过供应商公开预选、电子招投标与询比价、采购订单及交付、合同和发票管理来支持企业一站式采购。同时8Manage SRM还具有基于角色权限、实时审计跟踪、广泛报告功能、精准三向匹配以及实时开支分析等高级功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94e353e6c88fba1bbbc014de7d0a7e0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aebe1c25cf0763b4970002575694591d/" rel="bookmark">
			【Nodejs】基于express|ejs的用户博客管理系统前后端代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
package.json
后端：
server.js
router/admin/index.js
router/admin/login.js
router/admin/blog.js
router/admin/users.js
router/web/index.js
前端：
views/admin/common/top.ejs
views/admin/index.ejs
views/admin/login.ejs
views/admin/blog.ejs
views/admin/users.ejs
无开发，不安全。
这个小项目用了express框架，ejs模板渲染引擎，调用了mysql的api。
实现了session登录验证，session过期机制，用户和博客文章的CURD操作，上传头像图片的操作。
下面直接贴出代码：
package.json { "name": "ejs-express-mysql", "version": "1.0.0", "description": "ejs+express+mysql实现的后台管理", "main": "server", "scripts": { "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" }, "keywords": [ "node", "express", "ejs", "mysql" ], "devDependencies": { "body-parser": "^1.16.1", "consolidate": "^0.14.5", "cookie-parser": "^1.4.3", "cookie-session": "^2.0.0-beta.1", "ejs": "^2.5.6", "express": "^4.18.2", "express-router": "0.0.1", "express-static": "^1.0.3", "multer": "^1.3.0", "mysql": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aebe1c25cf0763b4970002575694591d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c791e68d56a34cf7bd24b6a1fe0539/" rel="bookmark">
			虚幻UE 增强输入-触发器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇增强输入基础：虚幻UE 增强输入-第三人称模板增强输入分析与扩展
主要对第三人称模板的增强输入进行分析、复刻和扩展
本篇将会对增强输入中的触发器中的各参数进行讲解
文章目录 前言触发器参数1、下移TriggerDown2、已按下TriggerPressed3、已松开TriggerReleased4、弦操作TriggerChordAction5、点按TriggerTap6、脉冲TriggerPulse7、长按TriggerHold8、长按和松开TriggerHoldAndRelease9、组合TriggerCombo 总结参考 前言 触发器作为增强输入四大概念其中之一，我们上一篇文章也对其作用进行了说明，
在参数讲解的开始、我们再一次回顾一下概念。
输入触发器（UInputTrigger）： 使用经过修饰器修改的输入值， 或者使用其他输入动作的输出值，来确定是否激活输入动作。 触发器参数 1、下移TriggerDown 参数只有：驱动阈值
驱动阈值是按压的程度，没按压是0（0默认不起作用，得大于0），按压到底是1
驱动阈值有效范围（0,1]
键鼠无法测试，只能靠手柄进行测试。
大于驱动阈值，且在有效范围时才能触发开始
触发逻辑如下：
先：开始Started（一次） 然后：触发Triggered（持续） 最后：完成Completed（一次） 这是正常进行的方式、但是由于无法测试按键程度，所以无法测试其他结果。 2、已按下TriggerPressed 参数只有：驱动阈值
同上面逻辑一模一样，不再说明。
触发逻辑如下：
先：开始Started（一次） 然后：触发Triggered（一次） 最后：完成Completed（一次） 这是正常进行的方式、但是由于无法测试按键程度，所以无法测试其他结果。 3、已松开TriggerReleased 参数只有：驱动阈值
同上面逻辑一模一样，不再说明。
触发逻辑如下：
先：开始Started（一次） 然后：持续Ongoing（持续，直到松开） 再：触发Triggered（一次，松开时） 最后：完成Completed（一次） 这是正常进行的方式、但是由于无法测试按键程度，所以无法测试其他结果。 4、弦操作TriggerChordAction 参数有：驱动阈值（同上）、弦操作
弦操作是按键同时按下才会产生逻辑。
为了更方便的查看信息，我们打开debug调试窗，输入：
ShowDebug EnhancedInput
只点击鼠标触发逻辑如下：
此时没有打印消息是因为点击左键设置了弦操作，得两键同时按下
空格跳跃结束前点击鼠标左键触发逻辑如下：
一定要是在跳跃完成前按下鼠标左键才有效，按下鼠标不松时则一直为Trigger
点击鼠标左键松开前点击空格跳跃触发逻辑如下：
一定要在鼠标松开之前按下跳跃空格，在跳跃结束时逻辑结束
先：开始Started（一次，弦操作中任一一个按键结束前按下其他按键触发） 然后：触发Triggered（持续） 最后：完成Completed（一次，弦操作中全部按键结束后触发） 这是正常进行的方式、但是由于无法测试按键程度，所以无法测试其他结果。 5、点按TriggerTap 参数有：驱动阈值（同上）、点按释放时间阈值、受时间膨胀影响
点按释放时间阈值：当释放时间小于该值则正常结束，当大于该值则非正常结束。
受时间膨胀影响：如果为真，点按释放时间阈值得乘以时间膨胀的倍数
正常结束触发逻辑如下：（小于该值）
释放时间内松开鼠标触发完成
非正常结束触发逻辑如下：（大于该值）
超过释放时间则触发取消
先：开始Started（一次） 然后：持续Ongoing（持续）1/2，判定条件释放时间 1： 再：触发Triggered（一次，释放时间内松开） 最后：完成Completed（一次） 2： 最后：取消Canceled（一次，释放时间内未松开） 这是正常进行的方式、但是由于无法测试按键程度，所以无法测试其他结果。 6、脉冲TriggerPulse 参数有：驱动阈值（同上）、受时间膨胀影响（同上）、开始时触发、间隔、触发限制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70c791e68d56a34cf7bd24b6a1fe0539/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2641ca211f1c608839aa3ab2a5ddd63d/" rel="bookmark">
			初学编程100个代码大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Hello World二、变量三、条件语句四、循环语句五、数组六、函数七、面向对象编程八、异常处理 关于Python技术储备一、Python学习路线二、Python基础学习1. 开发工具2. 学习笔记3. 学习视频 三、Python小白必备手册四、Python实战案例五、Python爬虫秘笈六、数据分析全套资源七、Python面试集锦2. 简历模板 资料领取 前言 编程是一项需要练习的技能，而初学者往往会在学习的过程中遇到各种各样的问题。为了帮助初学者更好地掌握编程知识，我们整理了100个适合初学者学习和练习的代码示例，这些示例涵盖了各种编程语言。以下是对这些代码示例的详细介绍。
一、Hello World 作为编程世界中的第一步，Hello World 程序毫无疑问是最基础的代码。它的目的是输出 “Hello World”。
# 使用 Python 输出 Hello World print("Hello World") // 使用 C 输出 Hello World #include &lt;stdio.h&gt; int main() { printf("Hello World"); return 0; } Hello World 代码示例很简单，它是每个编程新手必须学习的内容，因为它是上手编程之前的基础。
二、变量 变量是编程的重要组成部分。在编程中，变量是用来存储数据的特殊容器。以下是一段定义变量和输出变量值的代码示例。
# 使用 Python 定义变量并输出变量的值 name = "Alice" age = 21 print("My name is", name, "and I am", age, "years old") // 使用 C++ 定义变量并输出变量的值 #include &lt;iostream&gt; using namespace std; int main() { string name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2641ca211f1c608839aa3ab2a5ddd63d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e027d0eab2c44479d0e3da7577dacaab/" rel="bookmark">
			音量控制软件sound control mac功能亮点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sound control mac可以帮助用户控制某个独立应用程序的音量，通过每应用音量，均衡器，平衡和音频路由独立控制每个应用的音频，还有整个系统的音量。
sound control mac功能亮点
每个应用程序的音量控制
独立控制应用的数量。
键盘音量
添加键盘音量控制，DisplayPort显示器，HDMI电视和接收器以及其他缺少它们的设备。
应用程序EQ
使用系统范围的EQ或在每个应用程序上设置不同的EQ。每个EQ可以是10或31个频段。
触摸栏支持
使用MacBook Pro上的触控条控制应用程序音量。
每个应用程序余额
独立调整每个应用程序的左/右平衡。还可以选择向下混合到单声道，允许您将所有音频移动到左或右声道。
苹果：Sound Control for Mac(mac应用音量控制软件) 2.6.4中文版
Win：VoiceBot Pro(语音控制游戏软件)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bdd9ced74d442ac33b619f5128acad7/" rel="bookmark">
			第十章 数据库恢复技术——（数据库系统原理不挂科系列，数据库期末看完必过——思维导图Thanks♪(･ω･)ﾉ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c882af4809a50e88b9b3a2079dced50/" rel="bookmark">
			第九章 关系查询和优化查询——（数据库系统原理不挂科系列，数据库期末看完必过——思维导图Thanks♪(･ω･)ﾉ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab6d4dd380cb5d2c87bb817f3d13a730/" rel="bookmark">
			windows配置使用supervisor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、使用步骤1.安装supervisor-win2.配置supervisord3.配置program4.启动supervisord.exe5.supervisorctl.exe管控 二、后台启动总结 前言 windows使用supervisor和linux略有不同，严格来说比linux略难，而且不是所有的特性都支持。
一、使用步骤 1.安装supervisor-win 其实有一个纯exe版本的supervisor，但是实际使用起来比python版的功能差些。所以，经过对比还是supervisor-win更有性价比。
建议使用anaconda3，因为本篇文章基于annaconda3，原生python目录请自行查找，这里不再赘述。
pip install supervisor-win -i https://mirrors.aliyun.com/pypi/simple 安装完成后在anaconda的Scripts下面有exe文件。用到的就红框括起来的几个exe。
2.配置supervisord 使用过linux的都知道/etc/supervisor.conf是配置文件，windows上的配置文件需要用命令生成。
echo_supervisord_conf.exe &gt; D:\supervisord.conf 可以指定目录，不一定非得是D盘。
3.配置program 直接在supervisord.conf里面填就行了。下面是conf示例：
[program:theprogramname] command=cmd.exe ; the program (relative uses PATH, can take args) directory=%(ENV_TMP)s ; directory to cwd to before exec (def no cwd) autostart=true ; start at supervisord start (default: true) startsecs=1 ; # of secs prog must stay up to be running (def. 1) startretries=3 ; max # of serial start failures when starting (default 3) autorestart=unexpected ; when to restart if exited after running (def: unexpected) redirect_stderr=true ; redirect proc stderr to stdout (default false) stdout_logfile=a\\path ; stdout log path, NONE for none; default AUTO stdout_logfile_maxbytes=1MB ; max # logfile bytes b4 rotation (default 50MB) stdout_logfile_backups=10 ; # of stdout logfile backups (0 means none, default 10) 在supervisord.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab6d4dd380cb5d2c87bb817f3d13a730/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2f8364c77b74977a18a4d734e0b7c10/" rel="bookmark">
			用Python实现神经网络（附完整代码）！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在学习神经网络之前，我们需要对神经网络底层先做一个基本的了解。我们将在本节介绍感知机、反向传播算法以及多种梯度下降法以给大家一个全面的认识。
【----帮助Python学习，以下所有学习资料文末免费领！----】
一、感知机 数字感知机的本质是从数据集中选取一个样本（example），并将其展示给算法，然后让算法判断“是”或“不是”。一般而言，把单个特征表示为xi，其中i是整数。所有特征的集合表示为，表示一个向量：，
类似地，每个特征的权重表示为 其中 对应于与该权重关联的特征的下标，所有权重可统一表示为 一个向量:
这里有一个缺少的部分是是否激活神经元的阈值。一旦加权和超过某个阈值，感知机就输出1，否则输出0。我们可以使用一个简单的阶跃函数（在图5-2中标记为“激活函数”）来表示这个阈值。
注：所有神经网络的基本单位都是神经元，基本感知机是广义神经元的一个特例，从现在开始，我们将感知机称为一个神经元。
二、反向传播算法
2.1 代价函数 很多数据值之间的关系不是线性的，也没有好的线性回归或线性方程能够描述这些关系。许多数据集不能用直线或平面来线性分割。比如下图中左图为线性可分的数据，而右图为线性不可分的数据：
而我们训练神经网络（感知机）的目标是最小化所有输入样本数据的代价函数
2.2 反向传播 权重通过下一层的权重（）和（）来影响误差，因此我们需要一种方法来计算对误差的贡献，这个方法就是反向传播。
感知机的每个输入都有一个权重，第二层神经元的权重不是分配给原始输入的，而是分配给来自第一层的各个输出。从这里我们可以看到计算第一层权重对总体误差的影响的难度。第一层权重对误差的影响并不是只来自某个单独权重，而是通过下一层中每个神经元的权重来产生的。反向传播的推导过程较为复杂，这里仅简单展示其结果：
如果该层是输出层，借助于可微的激活函数，权重的更新比较简单, 对于第 个输出，误差的导数如下
如果要更新隐藏层的权重，则会稍微复杂一点儿：
函数表示实际结果向量，表示该向量第个位置上的值，，是倒数第二层第个节点和输出第个节点的输出，连接这两个节点的权重为，误差代价函数对求导的结果相当于用（学习率）乘以前一层的输出再乘以后一层代价函数的导数。公式中表示层第个节点上的误差项，前一层第个节点到层所有的节点进行加权求和。
2.3 多种梯度下降法 到目前为止，我们一直是把所有训练样本的误差聚合起来然后再做梯度下降，这种训练方法称为批量学习（batch learning）。一批是训练数据的一个子集。但是在批量学习中误差曲面对于整个批是静态的，如果从一个随机的起始点开始，得到的很可能是某个局部极小值，从而无法看到其他的权重值的更优解。这里有两种方法来避开这个陷阱。
第一种方法是随机梯度下降法。在随机梯度下降中，不用去查看所有的训练样本，而是在输入每个训练样本后就去更新网络权重。在这个过程中，每次都会重新排列训练样本的顺序，这样将为每个样本重新绘制误差曲面，由于每个相异的输入都可能有不同的预期答案，因此大多数样本的误差曲面都不一样。对每个样本来说，仍然使用梯度下降法来调整权重。不过不用像之前那样在每个训练周期结束后聚合所有误差再做权重调整，而是针对每个样本都会去更新一次权重。其中的关键点是，每一步都在向假定的极小值前进（不是所有路径都通往假定的极小值）。
使用正确的数据和超参数，在向这个波动误差曲面的各个最小值前进时，可以更容易地得到全局极小值。如果模型没有进行适当的调优，或者训练数据不一致，将导致原地踏步，模型无法收敛，也学不会任何东西。不过在实际应用中，随机梯度下降法在大多数情况下都能有效地避免局部极小值。这种方法的缺点是计算速度比较慢。计算前向传播和反向传播，然后针对每个样本进行权重更新，这在本来已经很慢的计算过程的基础上又增加了很多时间开销。
第二种方法，也是更常见的方法，是小批量学习。在小批量学习中，会传入训练集的一个小的子集，并按照批量学习中的误差聚合方法对这个子集对应的误差进行聚合。然后对每个子集按批将其误差进行反向传播并更新权重。下一批会重复这个过程，直到训练集处理完成为止，这就重新构成了一个训练周期。这是一种折中的办法，它同时具有批量学习（快速）和随机梯度下降（具有弹性）的优点。
三、Keras：用Python实现神经网络
用原生Python来编写神经网络是一个非常有趣的尝试，而且可以帮助大家理解神经网络中的各种概念，但是Python在计算速度上有明显缺陷，即使对于中等规模的网络，计算量也会变得非常棘手。不过有许多Python库可以用来提高运算速度，包括PyTorch、Theano、TensorFlow和Lasagne等。本书中的例子使用Keras。
Keras是一个高级封装器，封装了面向Python的API。API接口可以与3个不同的后端库相兼容：Theano、谷歌的TensorFlow和微软的CNTK。这几个库都在底层实现了基本的神经网络单元和高度优化的线性代数库，可以用于处理点积，以支持高效的神经网络矩阵乘法运算。
我们以简单的异或问题为例，看看如何用Keras来训练这个网络。
import numpy as np from keras.models import Sequential　# Kera的基础模型类 from keras.layers import Dense, Activation　# Dense是神经元的全连接层 from keras.optimizers import SGD　# 随机梯度下降，Keras中还有一些其他优化器 # Our examples for an exclusive OR. x_train = np.array([[0, 0],[0, 1],[1, 0],[1, 1]]) # x_train是二维特征向量表示的训练样本列表 y_train = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2f8364c77b74977a18a4d734e0b7c10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f077bf7b3f5df2367c7c417916ba7962/" rel="bookmark">
			ubuntu桥接方式上网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vmvare:VMware® Workstation 17 Pro
ubuntu: Ubuntu 14.04.6 LTS
window10
下面是我的电脑配置
下面是ubuntu虚拟机的配置
vi /etc/network/interfaces 下面的gateway就是window -ipconfig 截图里的默认网关
auto lo iface lo inet loopback auto eth0 iface eth0 inet static address 10.1.54.57 netmask 255.255.255.0 gateway 10.1.54.254 dns-nameserver 8.8.8.8 8.8.4.4 vi /etc/resolv.conf nameserver 8.8.8.8 如果window可以ping通虚拟机，但是虚拟机不可以ping通windows，是防火墙的问题
FR:hunkxu
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/688a5de4f3aeeb5ac6dacd5547822863/" rel="bookmark">
			都说今年行情差，那还能学IT编程吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“今年各行各业都在大裁员，工作真的不好找！”
“IT技术岗位饱和了，就业很难很难。”
“IT技术很卷，大家不要再卷下去了”
…
今年，不少同学应该都听说过这些个言论，话里话外无外乎是IT程序员也不行了！
但是，IT行业的高薪神话并未因此而终止，入行IT技术岗位拿高薪的年轻人也有不少！
那么，既然IT技术这么卷，还值得大家去入行吗？
01 卷的不止互联网行业，而是各行各业 首先可以肯定的是，市场上终归是需要IT人才的，但是总会有人来问，IT程序员的就业前景还好吗？是因为看了太多人说自己学完了，培训完了，没有找到工作；甚至有人不断贩卖焦虑，程序员早就没前途了，学编程就是浪费时间。
但事实上真的是如此吗？我们要客观看待问题！
首先，今年高校毕业生预计1158万，这么巨大的一个数额，可见整体就业压力大是必然的，就业竞争也会更加激烈！所以，不是说IT程序员不好找工作，而是整个市场的就业竞争更大了！
在3月13日，在十四届全国人大一次会议闭幕后，李强总理回答中外记者提问也谈及到就业问题：
我们将全面落实就业优先战略，进一步加大就业服务、技能培训等方面的政策支持力度，多措并举稳定和扩大就业岗位，支持和规范发展新就业形态。
其次是，随着互联网IT行业不断发展，如今不再是当时野蛮成长的状态，那个时候，只要你随随便便会点技术就能拿到接近万元的薪资水平。
现在呢，反而趋向平和稳健的发展时段，你不仅是要懂技术，更要吃透技术，因为企业对于IT的从业者要求变高了，求职门槛也是相对应提高了！
02 学编程技术仍是普通人拿高薪的逆袭之道 互联网发展越来越快，大浪淘沙，不学习，不努力，没有真才实学的程序员终究会被淘汰。如果小伙伴想进入软件行业，不必为程序员过多而担忧，这个行业永远不缺人，永远缺人才。
要知道，大多数人选择IT行业，真的能够达到改变命运一说。它累点无所谓，它难点也无所谓，但学完IT技术，进入程序员岗位，真的能够快速的改变生活，它能够帮助很多人在合法且不违背自己的道德和价值观的情况下，快速独立。
跟金融行业出了名的要求名校学历不同，IT圈里多的是普通大学毕业，大专毕业甚至高中毕业的从业人员。此外，因为学习IT可以让你掌握实实在在的专业技能，它可以让你有过硬的能力面对以后的生活，即便社会在不断变化，但是你依然可以做一个饿不死的“手艺人”。
一个刚入行的程序员可能年薪10w，而一个资深的程序员，可能年薪百万，他们之间差了10倍，可能都不止。
如果换成其他的工种和行业，连东西都不需要怎么学的那种，才会感觉可怕——第1年入行月薪1万块，第10年月薪1万5，一眼望到底。
这世上从来没有稳定的工作，只有不断提升自己的知识和能力，才更给你稳定的生活。
普通人想要逆袭确实很难，需要付出更多的时间精力，去努力去改变。
但同样的，普通人也不是不可能逆袭，从改变自己开始，一次又一次地投身新的挑战，不断去充实自己，机会自然会出现在面前！
关于Python学习指南 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后给大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
包括：Python激活码+安装包、Python web开发，Python爬虫，Python数据分析，人工智能、自动化办公等学习教程。带你从零基础系统性的学好Python！
👉Python所有方向的学习路线👈 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取）
👉Python学习视频600合集👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
温馨提示：篇幅有限，已打包文件夹，获取方式在：文末 👉Python70个实战练手案例&amp;源码👈 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
👉Python大厂面试资料👈 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
👉Python副业兼职路线&amp;方法👈 学好 Python 不论是就业还是做副业赚钱都不错，但要学会兼职接单还是要有一个学习规划。
👉 这份完整版的Python全套学习资料已经上传，朋友们如果需要可以扫描下方CSDN官方认证二维码或者点击链接免费领取【保证100%免费】
点击免费领取《CSDN大礼包》：Python入门到进阶资料 &amp; 实战源码 &amp; 兼职接单方法 安全链接免费领取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/568451014038bb9d5cc9b23822c382d1/" rel="bookmark">
			用MATLAB求最短路径（graphshortestpath）和求最小生成树（minspantree），代码演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		求最短路径（graphshortestpath），求最小生成树（minspantree） 文章目录 求最短路径（graphshortestpath），求最小生成树（minspantree）1、最短路径问题2、最小生成树 1、最短路径问题 最短路径：从图中的某个顶点出发，到达另外一个顶点的所经过的边的权重之和最小的一条路径。
图：边和节点组成的结构，在数学建模中例如本题中道路和城市。边：带有方向的是有向图，否则为无向图。权重：每条边都有与之对应的值，本题中边道路，边的权重就是道路长度，当然是越小越好。 MATLAB求解最短路径：**Dijkstra算法，或MATLAB的graphshortestpath**函数
例：
%sparse生成稀疏矩阵，也就是除了注明的几个元素外，其余都是0 %spare里第一个和第二个矩阵相同位置的元素值就是非零元素的索引 %非零元素的值 %w是每条边的权值 w=[10,5,2,1,4,6,7,3,9,2] DG = sparse([1,1,2,2,3,4,4,5,5,5],[2,5,5,3,4,3,1,2,3,4],w) % 没有就默认为零，这样快速生成一个稀疏矩阵 生成
% dist是最短路径的值, path是最短路径的节点顺序 % pred是到每一个节点的最短路径的终点前一个节点 % 如果求节点1到其他所有节点的最短路径呢? [dist,path,pred] = graphshortestpath(DG,1,3) %后面的数字参数是起点和终点，然后计算最短路径 显示
% biograph生成图对象; view显示该图 point_name =["城市1", "城市2", "城市3","城市4", "城市5"] h = view(biograph(DG,point_name, 'Showweights', 'on')) 优化
% 将最短路径的节点和边缘标记为红色并增加线宽 % getedgesbynodeid得到图h的指定边的句柄 % 第一个参数是图，第二个是边的出点，第三个是边的入点%句柄确保能找到对应的东西 % get查询图的属性，h.Nodes(path), 'ID'得到图h中最短路径的 % set函数设置图形属性 edges = getedgesbynodeid(h,get(h.Nodes(path),'ID')); %选取最短路径，并找到ID set(edges,'LineColor', [1 0 0])% RGB数值，红绿蓝 set(edges,'Linewidth',2) 最终结果：
2、最小生成树 最短路径的区别：最短路径是针对某一顶点作为起点而言的，最小生成树是所有顶点连通且总路径最小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/568451014038bb9d5cc9b23822c382d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0e0c5d0c6ca82f1d114456e82a40190/" rel="bookmark">
			【附安装包】Adobe XD2023安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 软件下载
软件：Adobe XD版本：2023
语言：简体中文
大小：464.83M
安装环境：Win11/Win10（1809版本以上）硬件要求：CPU@2.0GHz 内存@4G(或更高，不支持7代以下CPU）下载通道①百度网盘丨64位下载链接：
https://pan.baidu.com/s/1Zf_4kMDgUZ8ql2PVYU-IQg?pwd=7777
提取码：7777
软件介绍
Adobe Experience Design（XD）是一款优秀的图形化界面UX设计工具，主要用于视觉、交互、线框图、原型设计以及预览和共享。同时它也是唯一一款结合设计与建立原型功能，并同时提供工业级性能的跨平台设计产品，可以更高效准确的完成静态编译或者框架图到交互原型的转变。
安装步骤
1.鼠标右击【Adobe XD 55.1(64bit)】压缩包选择（win11以上系统需先点击“显示更多选项”）【解压到 Adobe XD 55.1(64bit)】。
2.打开解压后的文件夹，鼠标右击【autoplay】选择【以管理员身份运行】。
3.点击【Install】。
4.安装中……
5.点击【关闭】。
6.点击【OK】。
7.点击桌面任务栏中的【开始图标】，点击【Adobe XD】图标启动软件。
8.安装成功！
---------------------------END--------------------------- 题外话 “不是只有程序员才要学编程？！”
认真查了一下招聘网站，发现它其实早已变成一项全民的基本技能了。
连国企都纷纷要求大家学Python!
世界飞速发展，互联网、大数据冲击着一切，各行各业对数据分析能力的要求越来越高，这便是工资差距的原因，学习编程顺应了时代的潮流。
在这个大数据时代，从来没有哪一种语言可以像Python一样，在自动化办公、爬虫、数据分析等领域都有众多应用。
更没有哪一种语言，语法如此简洁易读，消除了普通人对于“编程”这一行为的恐惧，从小学生到老奶奶都可以学会。
《2020年职场学习趋势报告》显示，在2020年最受欢迎的技能排行榜，Python排在第一。
它的角色类似于现在Office，成了进入职场的第一项必备技能。
如果你也想增强自己的竞争力，分一笔时代的红利，我的建议是，少加点班，把时间腾出来，去学一学Python。
因为，被誉为“未来十年的职场红利”的Python，赚钱、省钱、找工作、升职加薪简直无所不能！
目前，Python人才需求增速高达**174%，人才缺口高达50万，**部分领域如人工智能、大数据开发， 年薪30万都招不到人！
感兴趣的小伙伴，赠送全套Python学习资料，包含面试题、简历资料等具体看下方。
👉CSDN大礼包🎁：全网最全《Python学习资料》免费赠送🆓！（安全链接，放心点击）
一、Python所有方向的学习路线
Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python必备开发工具
工具都帮大家整理好了，安装就可直接上手！
三、最新Python学习笔记
当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、Python视频合集
观看全面零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例
纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
六、面试宝典
简历模板 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f8e3f661539fbe46c5b13210d6f68e/" rel="bookmark">
			Android.mk里的LOCAL_SRC_FILES
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写法：
LOCAL_SRC_FILES 变量代表需要编译的文件，all-subdir-java-files 函数返回 LOCAL_PATH 子目录的所有 java文件。
LOCAL_SRC_FILES := $(call all-subdir-java-files) 也可以直接写出需要编译的文件路径：
LOCAL_SRC_FILES :=src/com/example/test/MainActivity.java \ src/com/example/test/Demo1.java \ src/com/example/test/Demo2.java // 需要在文件最后面加上以下语句，指明 LOCAL_PATH 目录。 include $(call all-java-file-under,$(LOCAL_PATH)) 或者每个文件路径下都加上 LOCAL_PATH ：
LOCAL_SRC_FILES :=$(LOCAL_PATH)/src/com/example/test/MainActivity.java \ $(LOCAL_PATH)/src/com/example/test/Demo1.java \ $(LOCAL_PATH)/src/com/example/test/Demo2.java 几个常用的获取源文件的方法：包名之外的路径（com之前的）
$(call all-java-files-under, src) ：获取指定目录下的所有 Java 文件。
$(call all-c-files-under, src) ：获取指定目录下的所有 C 语言文件。
$(call all-Iaidl-files-under, src) ：获取指定目录下的所有 AIDL 文件。
$(call all-makefiles-under, folder)：获取指定目录下的所有 Make 文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c6b844c89b36db32a45b387fbeb40c4/" rel="bookmark">
			go语言gin框架的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先在linux环境上安装go环境，这个网上搜搜就行
2.初始化一个go mod，网上搜搜怎么初始化
3.下面go代码的网址和端口绑定自己本机的就行
4.与另一篇CSDN一起食用，效果更好哟---&gt; libcurl的get、post的使用-CSDN博客
package main import ( "github.com/gin-gonic/gin" "flag" "fmt" ) func downFile(c *gin.Context, filePath string, filename string) { c.Writer.Header().Add("Content-Disposition", fmt.Sprintf("attachment; filename=%s", filename)) c.Writer.Header().Add("Content-Type", "application/octet-stream") fmt.Println(filePath) c.File(filePath) } // go build -o go_gin main.go func main() { var downPath *string = flag.String("down", "/tmp", "the down dir") flag.Parse() fmt.Printf("downPath = %s\n", *downPath) r := gin.Default() r.GET("/", func(c *gin.Context) { c.JSON(200, gin.H{ "message": "Hello World!", }) }) r.GET("/ping", func(c *gin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c6b844c89b36db32a45b387fbeb40c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a719eab63542ed103c9d52b4f48021e/" rel="bookmark">
			etcd基本介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		etcd基本介绍 ETCD是SoreOs公司发布的一个分布式的、高可用的、key-value存储的数据库。基于Go语言实现，k8s中也使用了ETCD作为数据库。主要用于共享配置和服务发现。相对于zookeeper采用的Paxos，ETCD采用的是Raft算法，该算法具备的性能更佳、数据一致性强等优点。
服务发现 服务发现要解决的也是分布式系统中最常见的问题之一，即在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。 本质上来说，服务发现就是想要了解集群中是否有进程在监听udp或tcp端口，并且通过名字就可以查找和连接。
要解决服务发现的问题，需要有下面三大支柱，缺一不可:
1.一个强一致性、高可用的服务存储目录。基于Raft算法的etcd天生就是这样一个强一致性高可用的服务存储目录。 2.一种注册服务和监控服务健康状态的机制。用户可以在etcd中注册服务，并且对注册的服务设置key TTL，定时保持服务的心跳以达到监控健康状态的效果。 3. 一种查找和连接服务的机制。通过在etcd指定的主题下注册的服务也能在对应的主题下查找到。为了确保连接，我们可以在每个服务机器上都部署一个Proxy模式的etcd，这样就可 以确保能访问etcd集群的服务都能互相连接。 Raft选举算法 一、什么是Raft算法 Raft算法是基于Multi-Paxos 思想 提出的一种易于理解的共识算法，主要解决了分布式中的一致性问题。
二、选举过程 Raft算法中每个节点拥有三种状态： Follower 跟随者状态 Candidate 候选者状态 Leader 领导者状态 1、所有的节点初始都是在跟随者状态下 2、如果一个跟随者在一定时间内（150ms 至300ms，随机值）没有收到领导者的心跳信息，自己将变成候选者状态，先投自己一票，并向群体内的其它节点发送选举投票请求 3、群体内的其它节点如果在这一任期内没有投过票，收到投票请求后将投一票给候选者，并返回 4、如果一个候选者收到了群体内大多数人（N/2 + 1）的投票，它将变成一名领导者，选举完成，开始不断地向其它节点发送心跳检测。任期将一直持续到某一个跟随者在一定时间内没有收到领导者的心跳信息。 选举完成之后，所有的数据操作将都通过领导者进行
通过上述的选举过程发现，肯定会有一定几率，两个跟随者节点同时进入候选者状态。 Raft算法中还有一个概念叫做任期（term），在一个任期中，每个节点只能投一次票。每次处理群体内其它节点的请求时，都会对term进行校验或者更新，当某个节点发现自己的 term 号比其他人小，那么它会更新到较大的 term 值。如果一个 Candidate 或者 Leader 发现自己的 term 过期了，他会立即退回成 Follower。如果一台服务器收到的请求的 term 号是过期的，那么它会拒绝此次请求。
个人理解可以想象成你们村儿选第二百五十届村长，term相当于第250个任期，总共有2个村名，还有2个候选者去竞选，你爸是村民，你家在这个任期只能投一票，你爸投给了张三，就不能投给李四了。
这时候他们会进行 2 步骤：先投自己一票，并向群体内的其它节点发送选举投票请求 并且两人都拉到了一名村民（跟随者）的投票，这时两位候选者都拥有两票，这一轮的选举就失败了，赋随机等待值继续等待下一轮的选举，重复2-4步骤.
etcd常用术语 Raft：etcd所采用的保证分布式系统强一致性的算法。
Node：一个Raft状态机实例。
Member： 一个etcd实例。它管理着一个Node，并且可以为客户端请求提供服务。
Cluster：由多个Member构成可以协同工作的etcd集群。
Peer：对同一个etcd集群中另外一个Member的称呼。
Client： 向etcd集群发送HTTP请求的客户端。
WAL：预写式日志，etcd用于持久化存储的日志格式。
snapshot：etcd防止WAL文件过多而设置的快照，存储etcd数据状态。
Proxy：etcd的一种模式，为etcd集群提供反向代理服务。
Leader(领导者)：Raft算法中通过竞选而产生的处理所有数据提交的节点。
Follower(跟随者)：竞选失败的节点作为Raft中的从属节点，为算法提供强一致性保证。
Candidate：当Follower超过一定时间接收不到Leader的心跳时转变为Candidate开始Leader竞选。
Term：某个节点成为Leader到下一次竞选开始的时间周期，称为一个Term。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a719eab63542ed103c9d52b4f48021e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42fe44d83a6517a8fc5ee3c8660f2c94/" rel="bookmark">
			打破闲鱼商品搜索瓶颈！云端电商API接口让你畅享商品详情关键词搜索的便利！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在闲鱼卖家的日常经营中，商品搜索是一个至关重要的环节。但是，由于闲鱼平台商品信息繁杂，卖家往往很难通过手动搜索的方式找到符合自己需求的商品。为了解决这一问题，云端电商API接口应运而生。联讯数据将详细介绍云端电商API接口的功能和优势。
商品详情关键词搜索的便利
云端电商API接口通过云计算技术，能够实时获取闲鱼平台上的商品信息，并提供关键词搜索功能。卖家只需输入相应的关键词，即可得到与关键词相关的商品列表，大大简化了搜索的流程。无论你是想要了解竞争对手的商品情况，还是想找一些特殊款式的商品进行参考，云端电商API接口都能满足你的需求。
商品筛选功能的高级化
除了基本的关键词搜索功能外，云端电商API接口还提供了丰富的商品筛选功能。卖家可以根据自己的需求选择过滤的条件，如商品类别、价格范围、地区等等，以获得更准确的搜索结果。通过这样的高级筛选功能，卖家可以快速找到符合自己业务需求的商品，提高了工作效率。
商品数据的实时更新
云端电商API接口有一个重要的优势是商品数据的实时更新。闲鱼平台上的商品信息在不断变化，通过云端电商API接口，卖家可以实时获取到最新的商品数据，及时了解市场的变化趋势。这对于卖家来说，是一个非常重要的竞争优势。
提供数据分析功能
云端电商API接口还提供了数据分析功能，卖家可以通过接口获取到商品的销售数据、评价数据等重要信息。通过对这些数据的分析，卖家可以更好地了解市场需求，制定合适的销售策略。在激烈的竞争环境中，数据分析是提高销售效果的重要手段，云端电商API接口为卖家提供了这样的功能。
接口使用简便、稳定可靠
云端电商API接口的使用非常简便，只需要简单的接口调用，就可以获取到所需的商品信息。接口的稳定性也得到了广大用户的认可，毫秒级的响应时间和强大的硬件支持，保证了接口的可靠性。所以无论是大型电商企业，还是个体商家，都可以放心使用云端电商API接口。
响应示例
"v": "1.0", "msg": "调用成功", "left_nums": 333295, "data": { "topMoreInfoDO": { "trackParams": { "page": "Page_xySearchResult", "args": { "url": "fleamarket://FunShare?more=true", "search_id": "ed6b58a4fc17f740e89e4261b2686155", "rn": "c68d95e78b4bb8c6085391025b5e9a24", "page": "Page_xySearchResult", "keyword": "摩托车" }, "arg1": "TopMoreButton" }, "target": "fleamarket://FunShare?more=true", "showMoreIcon": "true", "params": { "shareInfo": "{"sceneType":"search","customIcons":[{"icon":"https://gw.alicdn.com/imgextra/i2/O1CN01CJNPRw1UUfDwpeAV0_!!6000000002521-2-tps-144-144.png","title":"足迹","type":"link","url":"fleamarket://footprint?flutter=true","key":"SearchFootprint"},{"icon":"https://gw.alicdn.com/imgextra/i3/O1CN01aQ54kt1xwiKaJNJT9_!!6000000006508-2-tps-144-144.png","title":"闲鱼小蜜","type":"link","url":"https://alimebot.goofish.com/intl/index.htm?from=2BpzapR8M1&amp;orderId=orderId","key":"SearchXiaomi"},{"icon":"https://gw.alicdn.com/imgextra/i4/O1CN01vNmCi71qKVzXxrxIh_!!6000000005477-2-tps-144-144.png","title":"反馈","type":"link","url":"https://market.m.taobao.com/app/alimama-engineering-fe/search_new_h5/xianyu.html?taskId=343","key":"SearchFeedback"}],"contentParams":{"headerParams":{},"mainParams":{}},"version":"2"}", "params": "{"sceneType":"search","customIcons":[{"icon":"https://gw.alicdn.com/imgextra/i2/O1CN01CJNPRw1UUfDwpeAV0_!!6000000002521-2-tps-144-144.png","title":"足迹","type":"link","url":"fleamarket://footprint?flutter=true","key":"SearchFootprint"},{"icon":"https://gw.alicdn.com/imgextra/i3/O1CN01aQ54kt1xwiKaJNJT9_!!6000000006508-2-tps-144-144.png","title":"闲鱼小蜜","type":"link","url":"https://alimebot.goofish.com/intl/index.htm?from=2BpzapR8M1&amp;orderId=orderId","key":"SearchXiaomi"},{"icon":"https://gw.alicdn.com/imgextra/i4/O1CN01vNmCi71qKVzXxrxIh_!!6000000005477-2-tps-144-144.png","title":"反馈","type":"link","url":"https://market.m.taobao.com/app/alimama-engineering-fe/search_new_h5/xianyu.html?taskId=343","key":"SearchFeedback"}],"contentParams":{"headerParams":{},"mainParams":{}},"version":"2"}" } }, "topList": [ { "type": "DX", "style": "flow", "data": { "template": { "version": "1675239483586", "url": "https://dinamicx.alibabausercontent.com/pub/idlefish_search_graphic_navigation_tabs/1675239483586/idlefish_search_graphic_navigation_tabs.zip", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42fe44d83a6517a8fc5ee3c8660f2c94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/507b9bbb6617ce77b4b2a3d69dd8a66d/" rel="bookmark">
			选择排序！！！基础排序详解 C语言版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.什么是选择排序
2.选择排序源代码
3.优化代码
1.什么是选择排序 这是一个选择排序的流程图，其实很简单，就是每次挑选数字中最小的作为第一个 ，直到整个数据有序就结束了
顾名思义，选择，那就是选取，选取其中最小的，放在最前面的位置，已经选好的位子，下一次就不加入选择了。
每一次安排一个位置，直到所有位置都安排了。
2.选择排序源代码 void Swap(int* a, int* b) { int tmp = *a; *a = *b; *b = tmp; } // initial verse void My_SelctSort(int* arr,int sz) { int mini = 0; for (int i = 0; i &lt; sz; i++) { int mini = i; for (int j = i; j &lt; sz; j++) { if (arr[mini] &gt; arr[j]) { mini = j; } } Swap(&amp;arr[mini], &amp;arr[i]); } } swap函数就是自写的交换数据的函数。变量必须是指针！！！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/507b9bbb6617ce77b4b2a3d69dd8a66d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/541d318cd5ccaee66ca52b617ea8d19b/" rel="bookmark">
			插入排序详解!!!（简单排序），基本功排序C语言版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.什么是插入排序
2.插入排序的源代码
3.源代码详解
1.什么是插入排序 这是一个插入排序的流程图，插入排序 很像我们玩斗地主，玩牌，斗地主在开始前，我们是不是要给我们手上的牌排序啊，假设我们理牌有一个规矩就是只能一张一张拿起来。并且我们给牌换位置也只能一张一张换。不能中间跳过一张直接换（因为机器和人脑不同）
那我们拿起第一张的时候，和上图一样我们拿到一个3，那现在就只有一个3，你也不用排序
但我们拿到第二张的时候，这时有两张牌，拿到的是5，它确实比3大，那5就在3的后面就好
我们拿到第三张2的时候，这时候2是不是比5小，那2 和 5就交换，现在手牌就是 3 2 5，然后因为现在 2 的 前一张牌还是大于2，我们就再交换一下，手牌就变成了2 3 5.
这样就完成了一次插入排序。
后面的插入排序也是在这个基础上循环即可
2.插入排序的源代码 #include&lt;stdio.h&gt; void Swap(int* a, int* b) { int tmp = *a; *a = *b; *b = tmp; } void My_Insertsort(int* arr,int sz) { for (int i = 1; i &lt; sz; i++) { if (arr[i] &lt; arr[i - 1]) { for (int j = i - 1; j &gt;= 0; j--) { if (arr[j] &gt; arr[j + 1]) { Swap(&amp;arr[j], &amp;arr[j+1]); } else { break; } } } } } int main() { int arr[] = { 2,4,1,6,7,2,10,22,44,0 }; int sz = sizeof(arr) / sizeof(arr[0]); My_Insertsort(arr, sz); return 0; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/541d318cd5ccaee66ca52b617ea8d19b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3afdbbc30779ecdbfdd5251c35cbd7e/" rel="bookmark">
			TransmittableThreadLocal使用踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：为了获取相关字段方便，项目里使用了TransmittableThreadLocal上下文，在异步逻辑中get值时发现并非当前请求的值，且是偶发状况(并发问题)。
发现：TransmittableThreadLocal是阿里开源的可以实现父子线程值传递的工具，其子线程必须使用TtlRunnable\TtlCallable修饰或者线程池使用TtlExecutors修饰（防止数据“污染”），如果没有使用装饰后的线程池，那么使用TransmittableThreadLocal上下文，就有可能出现线程不安全的问题。
参考代码：
封装的上下文，成员变量RequestHeader
package org.example.ttl.threadLocal; import com.alibaba.ttl.TransmittableThreadLocal; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import lombok.ToString; import org.apache.commons.lang3.ObjectUtils; /** * description: * author: JohnsonLiu * create at: 2021/12/24 23:19 */ @Data @AllArgsConstructor @NoArgsConstructor public class RequestContext { private static final ThreadLocal&lt;RequestContext&gt; transmittableThreadLocal = new TransmittableThreadLocal(); private static final RequestContext INSTANCE = new RequestContext(); private RequestHeader requestHeader; public static void create(RequestHeader requestHeader) { transmittableThreadLocal.set(new RequestContext(requestHeader)); } public static RequestContext current() { return ObjectUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3afdbbc30779ecdbfdd5251c35cbd7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6cb53f27099518b69eeabb841239a10/" rel="bookmark">
			Android 编译过程介绍，Android.mk 和 Android.bp 分析， 在源码中编译 AndroidStudio 构建的 App
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 编译过程介绍，Android.mk 和 Android.bp 分析， 在源码中编译 AndroidStudio 构建的 App_.mk编译目录所有.bp-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ff16f8638baffdb98fe05d1a69ccd34/" rel="bookmark">
			opencv期末练习题（2）附带解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像插值与缩放 %matplotlib inline import cv2 import matplotlib.pyplot as plt def imshow(img,gray=False,bgr_mode=False): if gray: img = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) plt.imshow(img,cmap="gray") else: if not bgr_mode: img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB) plt.imshow(img) plt.show() 这段代码主要是一个用于在Jupyter Notebook中显示图像的辅助函数。让我们逐行解读：
%matplotlib inline: 这是一个Jupyter Notebook的魔法命令，它告诉Jupyter在Notebook中内联显示matplotlib的图表，而不是弹出新的窗口。
import cv2: 导入OpenCV库，用于图像处理。
import matplotlib.pyplot as plt: 导入matplotlib.pyplot库，用于绘图和图像显示。
def imshow(img, gray=False, bgr_mode=False):：定义了一个名为imshow的函数，该函数用于显示图像。它接受三个参数：
img: 要显示的图像。gray: 一个布尔值，指示是否将图像转换为灰度（默认为False）。bgr_mode: 一个布尔值，指示是否将图像从BGR模式转换为RGB模式（默认为False）。 if gray:: 如果 gray 参数为 True，则执行以下语句块：
img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY): 使用OpenCV将图像转换为灰度。
plt.imshow(img, cmap="gray"): 使用matplotlib.pyplot的imshow函数显示灰度图像。
else:: 如果 gray 参数为 False，则执行以下语句块：
if not bgr_mode:: 如果 bgr_mode 参数为 False，则执行以下语句块：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ff16f8638baffdb98fe05d1a69ccd34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e19fa0e5d0c908eaaea09e8267a612/" rel="bookmark">
			java字节码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 字节码 1.1 什么是字节码？ Java之所以可以“一次编译，到处运行”，一是因为JVM针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class文件）供JVM使用。
因此，也可以看出字节码对于Java生态的重要性。之所以被称之为字节码，是因为字节码文件由十六进制值组成，而JVM以两个十六进制值为一组，即以字节为单位进行读取。
在Java中一般是用javac命令编译源代码为字节码文件，一个.java文件从编译到运行的示例如图：
对于开发人员，了解字节码可以更准确、直观地理解Java语言中更深层次的东西，比如通过字节码，可以很直观地看到Volatile关键字如何在字节码上生效。
另外，字节码增强技术在Spring AOP、各种ORM框架、热部署中的应用屡见不鲜，深入理解其原理对于我们来说大有裨益。
除此之外，由于JVM规范的存在，只要最终可以生成符合规范的字节码就可以在JVM上运行，因此这就给了各种运行在JVM上的语言（如Scala、Groovy、Kotlin）一种契机，
可以扩展Java所没有的特性或者实现各种语法糖。理解字节码后再学习这些语言，可以“逆流而上”，从字节码视角看它的设计思路，学习起来也“易如反掌”。
1.2 字节码结构 .java文件通过javac编译后将得到一个.class文件，比如编写一个简单的ByteCodeDemo类，如下图2的左侧部分：
编译后生成ByteCodeDemo.class文件，打开后是一堆十六进制数，按字节为单位进行分割后展示如图2右侧部分所示。上文提及过，JVM对于字节码是有规范要求的，那么看似杂乱的十六进制符合什么结构呢？
JVM规范要求每一个字节码文件都要由十部分按照固定的顺序组成，整体结构如下图所示：
1.3 查看字节码工具 如果每次查看反编译后的字节码都使用javap命令的话，好非常繁琐。这里推荐一个Idea插件：jclasslib。
使用效果如图15所示，代码编译后在菜单栏”View”中选择”Show Bytecode With jclasslib”，可以很直观地看到当前字节码文件的类信息、常量池、方法区等信息。
2. 字节码增强 在上文中，着重介绍了字节码的结构，这为我们了解字节码增强技术的实现打下了基础。字节码增强技术就是一类对现有字节码进行修改或者动态生成全新字节码文件的技术。
接下来，我们将从最直接操纵字节码的实现方式开始深入进行剖析。
2.1 ASM 对于需要手动操纵字节码的需求，可以使用ASM，它可以直接生产 .class字节码文件，也可以在类被加载入JVM之前动态修改类行为（如下图17所示）。
ASM的应用场景有AOP（Cglib就是基于ASM）、热部署、修改其他jar包中的类等。当然，涉及到如此底层的步骤，实现起来也比较麻烦。
接下来，本文将介绍ASM的两种API，并用ASM来实现一个比较粗糙的AOP。但在此之前，为了让大家更快地理解ASM的处理流程，强烈建议读者先对访问者模式进行了解。
简单来说，访问者模式主要用于修改或操作一些数据结构比较稳定的数据，而通过第一章，我们知道字节码文件的结构是由JVM固定的，所以很适合利用访问者模式对字节码文件进行修改。
2.1.1 ASM API
2.1.1.1 核心API
ASM Core API可以类比解析XML文件中的SAX方式，不需要把这个类的整个结构读取进来，就可以用流式的方法来处理字节码文件。好处是非常节约内存，但是编程难度较大。
然而出于性能考虑，一般情况下编程都使用Core API。在Core API中有以下几个关键类：
ClassReader：用于读取已经编译好的.class文件。ClassWriter：用于重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。各种Visitor类：CoreAPI根据字节码从上到下依次处理，对于字节码文件中不同的区域有不同的Visitor，比如用于访问方法的MethodVisitor、用于访问类变量的FieldVisitor、用于访问注解的AnnotationVisitor等。为了实现AOP，重点要使用的是MethodVisitor。 2.1.1.2 树形API
ASM Tree API可以类比解析XML文件中的DOM方式，把整个类的结构读取到内存中，缺点是消耗内存多，但是编程比较简单。
TreeApi不同于CoreAPI，TreeAPI通过各种Node类来映射字节码的各个区域，类比DOM节点，就可以很好地理解这种编程方式。
2.1.2 利用ASM实现AOP
利用ASM的CoreAPI来增强类。这里不纠结于AOP的专业名词如切片、通知，只实现在方法调用前、后增加逻辑，通俗易懂且方便理解。
首先定义需要被增强的Base类：其中只包含一个process()方法，方法内输出一行“process”。增强后，我们期望的是，方法执行前输出“start”，之后输出”end”。
public class Base { public void process(){ System.out.println("process"); } } 为了利用ASM实现AOP，需要定义两个类：一个是MyClassVisitor类，用于对字节码的visit以及修改；另一个是Generator类，在这个类中定义ClassReader和ClassWriter，
其中的逻辑是，classReader读取字节码，然后交给MyClassVisitor类处理，处理完成后由ClassWriter写字节码并将旧的字节码替换掉。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01e19fa0e5d0c908eaaea09e8267a612/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64e2f05160e74dfa5041fa873e0e5394/" rel="bookmark">
			AWTK 开源串口屏开发(5) - MCU端 SDK 用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AWTK 开源智能串口屏，不但开放了串口屏端全部源码，还提供了MCU 端 SDK，大大加快 MCU 软件的开发。本介绍一下 MCU 端 SDK 在不同平台上的用法。
完整示例可以参考下面的几个例子：
普通嵌入式系统 mcu/stm32/hmi_app/hmi_app.c
低端嵌入式系统 mcu/mini-sdk/hmi/examples/socket/main.c
Arduino 系统 mcu/mini-sdk/hmi/examples/arduino/awtk_hmi_demo.ino
MCU 模拟器 simulator/src/pages/home_page.c 基本用法 创建 hmi 对象 创建 hmi 对象时，需要提供一个回调函数，当属性变化时，会调用这个函数。
示例
static ret_t hmi_on_prop_change(hmi_t* hmi, const char* name, const value_t* v) { /*处理参数变化*/ if (tk_str_eq(name, "温度")) { int32_t temp = value_int(v); log_debug("temp=%d\n", temp); } return RET_OK; } ... io = tk_stream_factory_create_iostream(url); hmi = hmi_create(io, hmi_on_prop_change, NULL); 设置属性 示例
hmi_set_prop_int(hmi, "温度", 36); 获取属性 示例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64e2f05160e74dfa5041fa873e0e5394/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a693f98fbc6eb0fce7e3936519135e11/" rel="bookmark">
			safari缓存清理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		safari缓存清理 点击顶端Safari浏览器–&gt;点击偏好设置
点击隐私–&gt;管理网站数据
全部移除
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/094c84e40713cd00f49459ca1cbe9bbc/" rel="bookmark">
			职场欢乐大冒险：奇葩同事、创意领导与BUG奇遇记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		职场生活就像一部精彩的喜剧电影，每个人都有自己独特的角色和故事。当我们的工作和生活交织在一起时，总会发生一些令人哭笑不得的趣事。今天，让我带你进入一个充满乐趣和惊喜的办公室，见识一群不同寻常的人物。
在这个办公室中，有一位被称为“创意之王”的领导，总是满脑子奇思妙想，千奇百怪。他的决策总是让人啼笑皆非，让团队陷入可爱的混乱。
曾经有一位领导，让我们称他为“创意之王”。他总是充满创意，且乐于将他的创意付诸行动。有一次，他突然决定要改变办公室的布局，以提升团队的协作和创造力。于是，他命令我们将所有的办公桌转为圆形，以便大家坐一起讨论和分享点子。
当我们听到这个决定的时候，眼前一片混乱的画面浮现出来：大家围坐在一个圆形的桌子周围，不知道怎么摆放电脑和其他工作物品。更为尴尬的是，该布局并没有解决我们实际工作中的问题，反而让沟通和协作更加困难。
然而，我们没有办法抗拒“创意之王”的命令，只好乖乖照做。结果，整个团队在圆桌布局下变得笨手笨脚，没有了私人空间，做事效率反而下降了。
可笑的是，过了不久，另一个奇迹出现了：我们的领导突然又改变了主意，坚持认为方形布局才是团队合作的真谛。于是，我们不得不再次调整办公桌的布局，这回变回方形。
创意是重要的，但创意的实施也需要考虑到实际情况和团队成员的需求。有时，有些创意看起来很有趣，但并不一定实用或适合当前团队的工作方式。
还有一位同事，我们亲切地称他为“缺脑回路小王子”。他总是以令人难以置信的思维方式和行为举止让人哭笑不得。他总能在工作中搞出一些匪夷所思的状况，给大家带来无尽的笑声。
有一次，我们正在进行一个重要的项目，每个人都在全力以赴，准备交付结果。在这个关键时刻，小王子的电脑突然崩溃了，无法启动。他的第一个反应居然是找到团队最忙碌的成员，然后问他能否借用他的电脑。
其他人纷纷投来诧异的目光，因为大家的电脑都在紧张地运行着重要的任务，根本无法分心。然而，小王子似乎对此毫不在意，继续坚持借用一个电脑。
于是，这位被问到的同事果断地回答：“抱歉，我的电脑很重要，里面有一些私人文件和敏感信息，我不能随便借给别人使用。”
小王子听后一脸茫然，似乎没有意识到这位同事的回答是非常合理的。他说：“你不懂我的困境，我的电脑崩溃了，我急需借一个使用啊！”
在场的人顿时笑翻，小王子的无知和迷茫引发了一阵欢笑。后来，一位好心的同事向小王子解释了情况并帮助他解决了电脑问题。
有时候在职场中会遇到一些思维方式与常人不同的同事。每个人的经验和知识不尽相同，因此在交流中需求耐心和理解。
我们还有一位同事，被大家亲切地称为“Bug奇侠”。他似乎总是遇上各种奇怪的Bug和故障。有时候，他修复一个问题，却引发另一个更奇特的故障，让大家捧腹大笑，同时愿意把他称为团队的“Bug奇侠”。
这位同事似乎总是那么运气不佳，无论做什么，总能够引发一系列奇怪的Bug和故障。
有一次，我们正在紧张地进行一个系统的升级，而Bug奇侠也投入了精力去修复之前的一些问题。然而，只要他一修改某个代码，系统就开始出现各种莫名其妙的问题。
于是，我们开始玩起了“猜Bug”的游戏。每当我们发现一个问题，就会集体来猜想：“这次是Bug奇侠搞的鬼吗？”有时候结果是正中目标，而有时候却是一个无辜的巧合。
尽管如此，Bug奇侠总是乐观地面对问题，并且总能够通过耐心的调试和修复最终解决Bug。他对自己的“奇特技能”从不气馁，反而成为团队的“Bug奇侠”。
在职场中，我们每个人都有自己的特点和不足，没有人是完美的。有时候，我们的不足之处可能成为团队的乐子，但重要的是如何积极面对并解决问题。尊重和欣赏每个人的特长和不同之处，将会使团队更加有趣且具有活力！
还有一位同事被大家亲切地称为“办公室忍者”。这位同事有着出色的反应速度和身手，总是能够以迅雷不及掩耳之势出现在你的身边，让你大跌眼镜。
有一次，我们正在开会，大家都集中精力听取领导的汇报。突然间，办公室忍者从椅子上站了起来，并纵身一跃，飞速穿过会议室，让人大惊失色。然后，他就在大家的面前拔出一支笔，做出一系列华丽的空中表演，最后准确地将笔插入了白板上的目标处。
大家瞠目结舌，不知所措地看着办公室忍者。他平静地转过头来，微笑着说：“我只是想帮大家找到演示用的笔而已。”
从那以后，办公室忍者成为了团队的“娱乐之星”，无论在会议室还是在日常生活中，他总能通过一系列的惊奇动作和幽默表演给大家带来欢乐和轻松的氛围。
在职场中保持一点幽默和创意是非常重要的。无论遇到多大的挑战，都能用一点轻松和娱乐的方式来缓解压力，增加团队的凝聚力和愉快度。办公室忍者的存在使我们意识到，工作是严肃的，但也可以充满乐趣和惊喜！
我们这个办公室就像是一个欢乐大马戏团，每个人都在演绎着自己的角色，创造出一系列啼笑皆非的故事和场景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/205bcbb9aa88099ca5fdbfc9084187b4/" rel="bookmark">
			Fontfabric：一款字体与设计的完美结合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、产品介绍
Fontfabric是一款由国际字体设计公司Fontfabric开发的字体设计软件。它提供了一整套完整的字体设计工具，让用户可以轻松地创建、设计和定制自己的字体。Fontfabric拥有丰富的字体库，包括各种风格和类型，能够满足用户在不同场景下的设计需求。
二、应用场景
Fontfabric适用于各种设计领域，如平面、网页、移动端等。无论是品牌标识设计、海报设计、广告宣传，还是网页界面设计、APP UI设计，甚至是个人创意设计，Fontfabric都能帮助用户快速创建出高质量的字体效果。
三、特色功能
字体编辑工具：Fontfabric提供了一系列的字体编辑工具，如字距、字宽、倾斜、装饰等，可以轻松调整字体的细节和风格。
矢量图形绘制：Fontfabric内置了强大的矢量图形绘制功能，用户可以轻松地创建各种形状和线条，为字体设计增添更多的创意元素。
字体定制：Fontfabric允许用户根据需求定制自己的字体，包括字形、笔画、曲线等，让字体更加符合用户的设计要求。
自动生成字体：Fontfabric可以根据用户输入的文本自动生成字体，省去了手动调整的繁琐过程，提高设计效率。
多平台支持：Fontfabric支持Windows、Mac和Linux等多个操作系统，同时也可以输出多种格式的字体文件，方便用户在不同平台上的使用。
四、适用人群
Fontfabric适用于所有需要进行字体设计的用户，包括平面设计师、UI设计师、品牌策划师、个人创意设计师等。无论是初学者还是专业设计师，Fontfabric都能帮助他们快速完成高质量的字体设计。
五、总结
Fontfabric是一款功能强大、操作简便的字体设计软件。它不仅提供了丰富的字体库和多种设计工具，还支持自定义字体的生成和多平台的使用。通过Fontfabric，用户可以轻松地创建出独具特色的字体效果，为各种设计项目增添更多的创意元素。无论你是初学者还是专业设计师，Fontfabric都是你进行字体设计的最佳选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d1533ea935b0e958a7dde2baae402ff/" rel="bookmark">
			支持向量机（Support Vector Machines，SVM）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是机器学习 支持向量机（Support Vector Machines，SVM）是一种强大的机器学习算法，可用于解决分类和回归问题。SVM的目标是找到一个最优的超平面，以在特征空间中有效地划分不同类别的样本。
基本原理 超平面 在二维空间中，超平面是一条直线，而在更高维的空间中，它是一个平面。对于二分类问题，SVM试图找到一个超平面，使得两个类别的样本被最大间隔分开。
支持向量 在SVM中，支持向量是离超平面最近的样本点。这些支持向量对决定超平面的位置和方向起关键作用。
间隔 SVM的目标是最大化支持向量到超平面的间隔，即最大化决策边界的宽度。
核函数 SVM可以使用核函数将数据映射到高维空间，从而在低维空间中无法线性分离的数据可以在高维空间中变得线性可分。
支持向量机（SVM）可以使用不同的核函数来处理线性不可分的问题，将数据映射到高维空间，以便在该空间中找到线性的超平面。以下是一些常见的SVM核函数：
线性核函数（Linear Kernel）： 在特征空间中直接进行线性划分。适用于线性可分的情况。
多项式核函数（Polynomial Kernel）： 将数据映射到更高次的多项式特征空间。c 是常数，d 是多项式的次数。
径向基核函数（Radial Basis Function，RBF或Gaussian Kernel）： 使用高斯分布函数进行映射，可以处理非线性问题。σ 是控制核函数宽度的参数。
Sigmoid核函数（Sigmoid Kernel）： 使用双曲正切函数进行映射，常用于神经网络。
Laplacian核函数（Laplacian Kernel）： 使用拉普拉斯分布进行映射，与RBF核类似，但对异常值更敏感。
这些核函数允许SVM在更高维度的空间中进行非线性映射，从而使得在原始特征空间中线性不可分的问题变得可分。选择适当的核函数通常依赖于具体问题和数据的性质，以及对模型的理解。
软间隔 对于非线性可分的数据，SVM引入软间隔，允许一些样本不满足硬间隔条件，以提高模型的泛化能力。
优点 适用于高维空间，对于特征数量大于样本数量的情况仍然有效。在处理非线性问题时，可以使用核技巧。对于二分类和多分类问题都有良好的适应性。 适用场景 二分类和多分类问题。高维数据集，例如文本分类、图像分类等。数据维度较小但需要有较好泛化性能的情况。 代码示例（使用Python和scikit-learn）： 以下是一个简单的SVM分类示例：
from sklearn import datasets from sklearn.model_selection import train_test_split from sklearn.svm import SVC from sklearn.metrics import accuracy_score, classification_report # 加载数据集 iris = datasets.load_iris() X = iris.data y = iris.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d1533ea935b0e958a7dde2baae402ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83803ed19f8bdbb1f29576048a533122/" rel="bookmark">
			Trino：分区表上的SQL提交 &amp; 查询流程浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Trino SQL执行过程的关键特性 Client、Coordinator、Worker之间的通讯，基于HTTP协议。SQL提交、解析、调度、执行等的流程全异步，最大化运行效率。逻辑计划树被在Coordinator侧被拆分成PlanFragment，可以对应于Spark中的Stage概念，会通过StageScheduler被调度。一个PlanFragment对应一个Stage，而一个Stage对应一个或多个Data Partition；一个Data Partition对应一个SqlTask，它是在Worker结点上处理数据的实体（容器）。一个Partition被拆分成一个或多个Split，是任务调度的最小单元，由Coordinator生成且数量确定。一个Split会由Worker负责处理，而一个Split会被分割成一个或多个Page，它是数据处理的最小单元。Worker可以并行处理Split，且按时间片的调度线程处理Split，如果执行线程超过时间片的限额或由于其它原因被阻塞，则线程会主动放弃当前Split的执行。（具体过程会在另外的文章中分析）Block是Trino集群中数据传输的最小单元，以列式的格式存储和压缩。默认情况下，如果资源足够，一个SQL作业的所有Stage会被同时调度和创建，此时作业的处理模型类似Flink，是一个流式的过程，一旦有一个Source Split生成，就可以流经所有的Stage产生最终的输出结果。默认情况下，所有的SQL作业共用一个Resource Group，一旦有一个可用的Worker，就会调度作业执行。SQL执行期间，每一个SqlTask的执行都是全内存的，意味着无法进行故障恢复，因此一旦某个任务失败，则最终整个作业的会失败。 SQL提交&amp;注册 通过/v1/statement/queued API向coordinator提交新的Query，会首先将此query放入QueryManager的缓存池中，然后返回给客户端下一次应该访问的地址。
客户端提交SQL成功后，会立即调用queued/{queryId}/{slug}/{token} REST API，轮询SQL的执行状态。
public class QueuedStatementResource { @ResourceSecurity(AUTHENTICATED_USER) @POST @Produces(APPLICATION_JSON) public Response postStatement( String statement, @Context HttpServletRequest servletRequest, @Context HttpHeaders httpHeaders, @Context UriInfo uriInfo) { if (isNullOrEmpty(statement)) { throw badRequest(BAD_REQUEST, "SQL statement is empty"); } // 注册新的query这里仅仅是创建Query实例，并添加到QueryManager的缓存池中 Query query = registerQuery(statement, servletRequest, httpHeaders); return createQueryResultsResponse(query.getQueryResults(query.getLastToken(), uriInfo)); } private Query registerQuery(String statement, HttpServletRequest servletRequest, HttpHeaders httpHeaders) { Optional&lt;String&gt; remoteAddress = Optional.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83803ed19f8bdbb1f29576048a533122/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c92c7c18e935539087c814ba4b3f0a6/" rel="bookmark">
			C&#43;&#43;获取GIF图片的长和宽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++
bool GetGifSize(const char* file_path, int* width, int* height) { bool has_image_size = false; int file_size; *height = -1; *width = -1; file_size = -1; FILE * fp = fopen(file_path, "rb"); if (fp == NULL) return has_image_size; struct stat st; char sigBuf[26]; if (fstat(fileno(fp), &amp;st) &lt; 0) { fclose(fp); return has_image_size; } else { file_size = st.st_size; } if (fread(&amp;sigBuf, 26, 1, fp) &lt; 1) { fclose(fp); return has_image_size; } char* gif87_signature = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c92c7c18e935539087c814ba4b3f0a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b88a59b4d9b7ab4a210c1cc9585a9eb6/" rel="bookmark">
			Mac 软件出现「意外退出」及「打不开」解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac 软件出现「意外退出」及「打不开」解决方法 软件出现意外退出及软件损坏的情况，这是因为苹果删除了TNT的证书，所以大部分TNT破解的Mac软件会出现无法打开，提示意外退出。
终端需先安装Xcode或Apple命令行工具
如未装Xcode可以使用下列命令安装Apple命令行工具（如安装有Xcode可忽略）
xcode-select --install
sudo codesign --force --deep --sign - 文件位置（直接将应用拖进去即可）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eea3b1b1a38b2452f5254c4ca4ff9220/" rel="bookmark">
			怎么打开外部sql文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你有VS Code软件就一步到位了
1、选中你的sql文件
2、拖到VS Code软件上，就是用VS Code打开sql文件
打开就是类似sql语句的样子，可以看也可以复制，我jio的挺方便的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab11a95c63ea61482e7308f1a7a6977b/" rel="bookmark">
			JVM加载class文件的原理机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、JVM 简介 JVM 是我们Javaer 的最基本功底了，刚开始学Java 的时候，一般都是从“Hello World ”开始的，然后会写个复杂点class ，然后再找一些开源框架，比如Spring ，Hibernate 等等，再然后就开发企业级的应用，比如网站、企业内部应用、实时交易系统等等，直到某一天突然发现做的系统咋就这么慢呢，而且时不时还来个内存溢出什么的，今天是交易系统报了StackOverflowError ，明天是网站系统报了个OutOfMemoryError ，这种错误又很难重现，只有分析Javacore 和dump 文件，运气好点还能分析出个结果，运行遭的点，就直接去庙里烧香吧！每天接客户的电话都是战战兢兢的，生怕再出什么幺蛾子了。我想Java 做的久一点的都有这样的经历，那这些问题的最终根结是在哪呢？—— JVM 。
JVM 全称是Java Virtual Machine ，Java 虚拟机，也就是在计算机上再虚拟一个计算机，这和我们使用 VMWare不一样，那个虚拟的东西你是可以看到的，这个JVM 你是看不到的，它存在内存中。我们知道计算机的基本构成是：运算器、控制器、存储器、输入和输出设备，那这个JVM 也是有这成套的元素，运算器是当然是交给硬件CPU 还处理了，只是为了适应“一次编译，随处运行”的情况，需要做一个翻译动作，于是就用了JVM 自己的命令集，这与汇编的命令集有点类似，每一种汇编命令集针对一个系列的CPU ，比如8086 系列的汇编也是可以用在8088 上的，但是就不能跑在8051 上，而JVM 的命令集则是可以到处运行的，因为JVM 做了翻译，根据不同的CPU ，翻译成不同的机器语言。
JVM 中我们最需要深入理解的就是它的存储部分，存储？硬盘？NO ，NO ， JVM 是一个内存中的虚拟机，那它的存储就是内存了，我们写的所有类、常量、变量、方法都在内存中，这决定着我们程序运行的是否健壮、是否高效，接下来的部分就是重点介绍之。
回到顶部
2、JVM 的组成部分 我们先把JVM 这个虚拟机画出来，如下图所示：
从这个图中可以看到，JVM 是运行在操作系统之上的，它与硬件没有直接的交互。我们再来看下JVM 有哪些组成部分，如下图所示：
该图参考了网上广为流传的JVM 构成图，大家看这个图，整个JVM 分为四部分：
## Class Loader 类加载器 类加载器的作用是加载类文件到内存，比如编写一个HelloWord.java 程序，然后通过javac 编译成class 文件，那怎么才能加载到内存中被执行呢？Class Loader 承担的就是这个责任，那不可能随便建立一个.class 文件就能被加载的，Class Loader 加载的class 文件是有格式要求，在《JVM Specification 》中式这样定义Class 文件的结构：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab11a95c63ea61482e7308f1a7a6977b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ecdf116fec21f5d88675c408da4823a/" rel="bookmark">
			C&#43;&#43;获取系统时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法1：
GetLocalTime是一个Windows API 函数，用来获取当地的当前系统日期和时间。
函数原型:
VOID GetLocalTime(
LPSYSTEMTIME lpSystemTime //address of system times structure
);
参数说明:
lpSystemTime: 指向一个用户自定义包含日期和时间信息的类型为 SYSTEMTIME 的变量，该变量用来保存函数获取的时间信息。
此函数会把获取的系统时间信息存储到SYSTEMTIME结构体里边
typedef struct _SYSTEMTIME { WORD wYear;//年 WORD wMonth;//月 WORD wDayOfWeek;//星期，0为星期日，1为星期一，2为星期二…… WORD wDay;//日 WORD wHour;//时 WORD wMinute;//分 WORD wSecond;//秒 WORD wMilliseconds;//毫秒 }SYSTEMTIME,*PSYSTEMTIME; #include&lt;stdio.h&gt; #include&lt;windows.h&gt; #include&lt;winbase.h&gt; intmain(intargc,char*argv[]) { SYSTEMTIME time; GetLocalTime(&amp;time); printf("当前时间为：%2d:%2d:%2d\n",time.wHour,time.wMinute,time.wSecond); return0; } 方法2：
time() 是指返回自 Unix 纪元（January 1 1970 00:00:00 GMT）起的当前时间的秒数的函数，主要用来获取当前的系统时间，返回的结果是一个time_t类型。
#include&lt;stdio.h&gt; #include&lt;windows.h&gt; #include&lt;winbase.h&gt; intmain(intargc,char*argv[]) { time_t tt = time(NULL);//这句返回的只是一个时间cuo tm* t= localtime(&amp;tt); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ecdf116fec21f5d88675c408da4823a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/928c4b773b40a4f973dfec2a5400398d/" rel="bookmark">
			TemporalKit的纯手动安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在用本地SD安装temporalkit插件
本地安装插件最常见的问题就是，GitCommandError:…
原因就是，没有科学上网，而且即使搭了ladder，在SD的“从网址上安装”或是“插件安装”都不行，都不行！！！！
一气之下，不如自己先从git上下载文件夹，再解压到SD本地文件夹里
过程遇到了一些问题报错，逢山开路，遇水搭桥，记录一下
Git下载并解压文件 首先，先搭ladder，没有ladder，git文件很难顺利快速下载
得到一个名为TemporalKit-main.zip的压缩包
解压到SD本地的extensions目录里，文件名一定要去掉-main的后缀
重启SD的weiui后，遇到一系列问题，需要修复
问题1：tqdm.auto 解决1：tqdm调整到4.45.0版本 再重启SD的webui，大功告成
补充：安装temporalkit的方法 安装temporalkit的四种方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1012d0e25a0235d070b63e284842033a/" rel="bookmark">
			在 Docker 中配置 MySQL 数据库并初始化 Project 项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 文件准备
1.1. 添加 SQL 文件头部内容
每个 SQL 文件的头部需要添加以下内容：
DROP DATABASE IF EXISTS xx_..; CREATE DATABASE xx_..; USE xx_..; 1.2. 修改 AUTO_INCREMENT
在每个 SQL 文件中，将 AUTO_INCREMENT 修改为 1。
1.3. 插入机型
在 SQL 文件中插入机型相关数据。
1.4. 插入管理员
在 SQL 文件中插入管理员相关数据。
1.5. 创建目录结构
创建目录 /project/mysql 以及 /project/mysql_data。
1.6. 拷贝 SQL 文件
将准备好的 SQL 文件复制到 /project/mysql 目录。
1.7. 创建 init.sql
新建 init.sql 文件，内容如下：
-- 创建数据库 CREATE DATABASE IF NOT EXISTS xxproject; USE xxproject; -- 导入其他 SQL 文件 SOURCE /docker-entrypoint-initdb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1012d0e25a0235d070b63e284842033a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbbb7a90dc29b041c7f1035c889a17f8/" rel="bookmark">
			CentOS 7.8 安装 Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.卸载旧版本
sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine 2.安装依赖
sudo yum -y install gcc sudo yum -y install gcc-c++ 3.安装软件包
sudo yum install -y yum-utils 4.设置 stable 镜像仓库(使用国内阿里云仓库链接下载)
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 5.更新 yum 软件包索引
sudo yum makecache fast 6.安装 Docker 引擎
sudo yum -y install docker-ce docker-ce-cli containerd.io docker-compose-plugin 7.启动 Docker
sudo systemctl start docker # 启动 sudo systemctl status docker # 查看状态 sudo systemctl enable docker # 设置开机自启 sudo ps -ef | grep docker # 查看进程 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbbb7a90dc29b041c7f1035c889a17f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/573769c9a87348a134ae7e80760f0ab4/" rel="bookmark">
			CentOS 7 更新和还原 yum 源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 更新 yum 源
备份原始的 CentOS-Base.repo 文件
sudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 使用阿里云仓库链接下载新的 CentOS-Base.repo 文件
sudo wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo 更新 yum 软件包索引
sudo yum makecache 还原 yum 源
恢复原始的 CentOS-Base.repo 文件
sudo mv /etc/yum.repos.d/CentOS-Base.repo.backup /etc/yum.repos.d/CentOS-Base.repo 清理并重新构建 yum 缓存（可选）
sudo yum clean all sudo yum makecache 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37a76d174fe37b0072a8efd54d763a6b/" rel="bookmark">
			存储过程从表中获取数据库名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ---------------业务数据库信息 CREATE TABLE [dbo].[app_erp_datbabase_conf] (
[id] [int] IDENTITY(1,1) NOT NULL,
[database_type] [varchar](200) NOT NULL, [database_name] [varchar](200) NOT NULL, [create_time] [datetime] NULL,
[modify_time] [datetime] NULL,
[enable] [int] NOT NULL
);
GO DECLARE @DatabaseName NVARCHAR(255); -- 假设您有一个特定的id来查找对应的database_name DECLARE @ConfId INT = 1; -- 替换为实际要查询记录的id SELECT @DatabaseName = database_name FROM dim_erp_datbabase_conf WHERE id = @ConfId; -- 如果确保表中存在对应id且database_name不为空，则可以直接使用 -- 如果可能有多条记录匹配或需要返回第一条记录，则可以考虑使用TOP 1 -- 如果可能不存在匹配项，则应在之后检查@DatabaseName是否已成功赋值 -- 示例：检查数据库名是否成功获取 IF (@DatabaseName IS NOT NULL) BEGIN PRINT N'获取到的数据库名为: ' + @DatabaseName; -- 在此处执行后续需要用到@DatabaseName的操作 END ELSE BEGIN PRINT N'未找到相应的database_name'; END; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a11be91e6521bc82d4a6f534c845dba2/" rel="bookmark">
			vite 如何设置 pwa，让网页类似 app 那样运行，使用插件 vite-plugin-pwa
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vite 如何设置 pwa，让网页类似 app 那样运行，使用插件 vite-plugin-pwa 一、概述 情况还是那么个情况，还是原来的项目 vue2 改为 vite+ts+vue3 遇到的问题，今天这个问题是如何 在 Vite 环境下设置 PWA。
PWA 就是网页应用可以像 app 那样不显示上下边栏在手机中使用，也可以从 PC 端脱离浏览器而显示为一个独立程序的样子使用。
vue-cli 环境时是这样实现的： Vue3 PWA 如何配置
今天就来说说如何在 vite 环境下实现上面的操作
二、实现 要实现 PWA 需要满足两个条件：
index.html 中需要添加指定的属性vite.config.ts 中需要添加指定的配置 1. 安装插件 vite-plugin-pwa vite 中要想实现 pwa 配置，需要在项目环境中安装一个插件 vite-plugin-pwa，它有 ServiceWorker 也 PWA
vite-plugin-pwa 官方 pwa 说明： https://vite-pwa-org.netlify.app/guide/pwa-minimal-requirements.html
yarn、npm 两种安装环境自行选择
yarn add -D vite-plugin-pwa # 或 npm i -D vite-plugin-pwa 2. 在 vite.config.ts 中添加对应配置 一般插件都配在非常健全文档，只需要访问它的官网就可以，找到 github 找到 npm 中的包页面。根据文档设置就可以了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a11be91e6521bc82d4a6f534c845dba2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d2e90cf8156d5c57a0b696912c162c4/" rel="bookmark">
			一分钟看懂Python中的//, /, %的作用和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在python中，我们经常需要对数字进行一些基本的运算，比如加、减、乘、除等。为了实现这些运算，我们可以使用一些特殊的符号，称为算术运算符。
例如，我们可以用+号表示加法，用-号表示减法，用*号表示乘法，用/号表示除法等。这些运算符都遵循一定的语法规则和优先级顺序，我们可以用它们来构建复杂的数学表达式。
为//、/、%的区别 除了上面提到的四个基本的算术运算符，python还提供了另外三个有用的运算符：//, /, %。它们分别表示整除、除法和取余。它们的作用和区别如下：
整除（//）：整除运算符返回两个数字相除后的商的整数部分。例如，17 // 4 的结果是 4，因为 17 除以 4 的商是 4.25，而整数部分是 4。如果两个数字中有一个是浮点数（小数），则返回的结果也是一个浮点数，但是小数部分会被舍去。例如，17.0 // 4 的结果是 4.0，因为 17.0 除以 4 的商是 4.25，而小数部分被舍去后是 0。
除法（/）：除法运算符返回两个数字相除后的商的精确值。无论两个数字是什么类型，返回的结果都是一个浮点数（小数）。例如，17 / 4 的结果是 4.25，因为 17 除以 4 的商就是 4.25。如果两个数字都是整数，并且能够整除，则返回的结果也是一个浮点数，但是小数部分会是 0。例如，16 / 4 的结果是 4.0，因为 16 除以 4 的商是 4，而小数部分是 0。
取余（%）：取余运算符返回两个数字相除后的余数。例如，17 % 4 的结果是 1，因为 17 除以 4 的余数是 1。如果两个数字中有一个是浮点数，则返回的结果也是一个浮点数。例如，17.5 % 4 的结果是 1.5，因为 17.5 除以 4 的余数是 1.5。
为什么需要整除、除法和取余 那么，为什么我们需要这三个运算符呢？有哪些情况下我们会用到它们呢？下面举几个例子来说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d2e90cf8156d5c57a0b696912c162c4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/31/">«</a>
	<span class="pagination__item pagination__item--current">32/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/33/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>