<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e3dad1909773f78ef18785ea52e3161/" rel="bookmark">
			React Table 表格组件使用教程 排序、分页、搜索过滤筛选功能实战开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React Table 表格组件使用教程 react-table 安装和使用React Table 表格排序功能React Table 表格搜索过滤筛选功能React Table 表格分页功能React table 排序、搜索过滤筛选、分页示例代码React table 实战案例模拟 API构建基础 React Table 组件服务端分页服务端排序服务端搜索过滤筛选 React Table 组件与卡拉云 本文完整版：《React Table 表格组件使用教程 排序、分页、搜索过滤筛选功能实战开发》
在日常开发中，特别是内部使用的后台系统时，我们常常会需要用表格来展示数据，同时提供一些操作用于操作表格内的数据。简单的表格直接用原生 HTML table 就好，但如果要在 React 中实现一个功能丰富的表格，其实是非常不容易的。
在本站之前的文章《最好的 6 个 React Table 组件详细亲测推荐》 中有提到过 react-table 这个库，如果对这个库不太了解的同学可以先了解一下，这里不再赘述。
简而言之，react-table 是一个非常强大的库，它与常见的表格组件不同，它不负责渲染 HTML 和 CSS，而是提供了一系列的 hooks 让我们可以灵活地构建功能强大的表格组件。
因此使用 react-table 进行开发具有一定的难度，而本文将由浅入深地讲解如何在 React 项目中使用 react-table 实现各种常见的需求，例如：排序、分页、搜索过滤筛选等；同时还会结合一个完整的案例给大家讲解如何搭配使用 Material-UI 以及模拟从后端获取数据进行分页等功能。
如果你正在搭建后台管理工具，又不想处理前端问题，推荐使用卡拉云 ，卡拉云是新一代低代码开发工具，可一键接入常见数据库及 API，内置表格等常见的前端组件，无需懂前端，仅需拖拽即可快速搭建属于你自己的后台管理工具，一周工作量缩减至一天，详见本文文末。
跟随本文你将学到
如何使用 react-table 在 React 中搭建表格组件如何使用 react-table 表格组件进行数据的分页、排序、搜索过滤筛选react-table 实战案例：手把手教你使用 react-table 表格组件实战分页、排序、搜索过滤筛选 扩展阅读：《顶级好用的 React 表单设计生成器，可拖拽生成表单》
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e3dad1909773f78ef18785ea52e3161/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b14954efe3c6320683d5c9fd12fd96fd/" rel="bookmark">
			后端实战手把手教你写文件上传接口：如何使用 Node.js &#43; MongoDB 开发 RESTful API 接口（Node.js &#43; Express &#43; MongoDB）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后端实战手把手教你写文件上传接口 ✦ 文件上传管理后台 Node.js + Express + Multer + MongoDB后端项目结构 配置 Node.js 开发环境配置 MongoDB 数据库配置文件上传存储的中间件创建文件上传的控制器定义 routes 路由创建 Express 服务器运行项目并测试「文件上传」前后端搭建总结及卡拉云 本文完整版：《后端实战手把手教你写文件上传接口：如何使用 Node.js + MongoDB 开发 RESTful API 接口（Node.js + Express + MongoDB）》
本教程手把手教你搭建一套后端文件上传 API 接口，它使用 Node.js + Express + MongoDB 构建的后端服务。本文详细描述通过 Node.js 与数据库通讯。整个服务搭建起来后，我们使用 Postman 对整个后端服务进行测试。
本教程每段代码我都亲手测过，保证百分百没有错误，请打开你的 terminal 跟随本教程一起操作，从这里开始，成为一名后端工程师。
全栈实战教程：
Vue + Node.js+Expres+MySQL 开发「待办清单」APPVue + Axios + Node.js + Express 搭建带预览的「上传图片」管理后台Vue + Axios + Node.js + Express 搭建「文件上传」管理后台React + Nodejs 搭建带预览的「上传图片/预览」管理后台React + Axios + Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b14954efe3c6320683d5c9fd12fd96fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f511289b260f368a1fe3440545828206/" rel="bookmark">
			【Mac M1】docker、docker-compose、Nacos、Redis、RabbitMQ的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker 安装 docker 安装docker 状态docker-compose安装docker nacos安装docker redis安装docker RabbitMQ安装 docker 安装 1. yum 包更新到最新 sudo yum update 2. 安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 3. 设置yum源为阿里云 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 4. 安装docker sudo yum install docker-ce 5. 安装后查看docker版本 docker -v docker 状态 启动：systemctl start docker 停止：systemctl stop docker 重启：systemctl restart docker 查看状态：systemctl status docker docker-compose安装 1. 查看内核 uname -r 2. 更新yum sudo yum update 利用安装包下载安装docker-compose 1. 下载compose https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f511289b260f368a1fe3440545828206/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13cff6a7485203267aca47a4f36937bc/" rel="bookmark">
			Cannot resolve plugin org.springframework.boot spring-boot-maven-plugin:＜unknown＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在创建springboot项目的时候，出现了如标题所示的问题，并且一直提示Clean up the broken artifacts data (.lastUpdated files) and reload the project.，点击链接清理后也无效，重启idea也没用，最后才发现是缺少版本信息导致不能找到spring-boot-maven-plugin。
报错信息：
Cannot resolve plugin org.springframework.boot:spring-boot-maven-plugin:&lt;unknown&gt; Clean up the broken artifacts data (.lastUpdated files) and reload the project. 解决办法：添加&lt;version&gt;2.3.4.RELEASE&lt;/version&gt;即可解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b57fc78eb100b49cfca225a31aa67fb/" rel="bookmark">
			解决vscode&#34;无法加载文件 ，因为在此系统上禁止运行脚本&#34;报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 在使用 vscode 自带程序终端时，会报“无法加载文件 ，因为在此系统上禁止运行脚本”，这是因为 PowerShell 执行策略的问题。
&gt; tsc --init tsc : 无法加载文件 D:\nodejs\tsc.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。 所在位置 行:1 字符: 1 + tsc --init + ~~~ + CategoryInfo : SecurityError: (:) []，PSSecurityException + FullyQualifiedErrorId : UnauthorizedAccess 解决方法： 以管理员身份运行 vscode执行：get-ExecutionPolicy，会显示 Restricted，表示状态是禁止的;执行：set-ExecutionPolicy RemoteSigned再次执行：get-ExecutionPolicy，会显示 RemoteSigned，表示状态是允许的; window.powershell解释说明
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a649b170a5891be71d195917f7433545/" rel="bookmark">
			Java面试必懂知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、介绍一下面向对象 面向对象是基于万物皆对象。
封装：隐藏方法的具体实现细节，提供出一个公共接口给API调用，提高了代码的可维护性，和安全性。
继承：继承就是在已知类上建立新类的技术，子类继承父类的方法，子类也可以有自己的属性和方法。但不能选择性地继承父类。通 过使用继承可以提高代码复用性。继承是多态的前提。
多态：父类后接口定义的引用变量可以指向子类或具体实现类的实例对象。Java实现多态有三个必要条件：继承、重写、向上转型。
编译时多态：方法的重载运行时多态：方法的重写 2、Java语言的反射机制 Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性的方法，对于任何一个对象，都能调用它的任意属性和方法，这种在动态的获取类信息和调用对象的方法和属性的功能，称为Java语言的反射机制。
实现反射机制的三种反射： 1.通过new对象实现反射机制
2.通过路径实现反射机制
3.通过类名实现反射机制
1 public class Student { 2 private int id; 3 String name; 4 protected boolean sex; 5 public float score; 6 } 1 public class Get { 2 //获取反射机制三种方式 3 public static void main(String[] args) throws ClassNotFoundException { 4 //方式一(通过建立对象) 5 Student stu = new Student(); 6 Class classobj1 = stu.getClass(); 7 System.out.println(classobj1.getName()); 8 //方式二（所在通过路径‐相对路径） 9 Class classobj2 = Class.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a649b170a5891be71d195917f7433545/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e5ea7bff56ff052a51bfd95f6787c8d/" rel="bookmark">
			深度之眼（十一）——矩阵对角化及二次型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、相似矩阵的定义以及矩阵的对角化1.1 相似矩阵的定义1.2 矩阵的对角化 二、矩阵对角化的条件以及对称矩阵的对角化2.1 一般矩阵对角化的条件2.2 对称矩阵对角化2.3 推论2.4 例 三、对角化在数据压缩算法中的应用四、二次型与矩阵的正定性。五、矩阵的正定性在机器学习线性回归算法中的运用5.1 矩阵的正定性的定义5.2 线性回归（高级） 一、相似矩阵的定义以及矩阵的对角化 1.1 相似矩阵的定义 1.2 矩阵的对角化 p1–pn是线性无关的
矩阵A要有N个线性无关的
二、矩阵对角化的条件以及对称矩阵的对角化 2.1 一般矩阵对角化的条件 2.2 对称矩阵对角化 2.3 推论 2.4 例 三、对角化在数据压缩算法中的应用 四、二次型与矩阵的正定性。 旋转矩阵
五、矩阵的正定性在机器学习线性回归算法中的运用 5.1 矩阵的正定性的定义 对称阵A为正定的充分必要条件是: A的特征值全为正.
x != 0
半正定
5.2 线性回归（高级） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e76cd61672bc96b88883d5f9b6bb707/" rel="bookmark">
			万字详解Linux下安装软件的方式（yum配置&#43;rpm&#43;源码安装）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Linux下有哪些软件安装方式1.rpm包（二级制软件包）2. 源码软件包3. 二进制源码包4. 常见的二进制软件包5. 二进制包和源码包区别6. 二进制软件包的安装方式 二、各种软件包安装步骤1. rpm软件包的安装和卸载1）rpm安装2）rpm卸载3） rmp升级包4）查看rpm包相关信息4）rmp其它选项5）如何获取rpm包6）如何选择合适的rpm包 2. yum软件包管理工具1）yum安装rpm包2）yum工具卸载rpm包3）yum升级rpm包4）yum常用选项 三、源码安装1. 源码安装步骤2. 源码安装示例3. 详解源码安装的配置过程1. axel多线程下载软件源码安装2. 使用软链接解决command not found3. 使用环境变量解决command not found4. 解决源码安装man手册找不到问题5. 卸载源码安装的软件 四、yum1. yum源1. yum源作用2. yum源优点3. yum源分类1）本地yum源2）网络yum源 4. 本机yum备份 2. 本地yum源配置man 5 3. 网络yum源配置4. EPEL源配置5. 特定软件的yum源配置6. 自建yum源仓库1. 缓存安装软件包 2. 如何缓存软件安装包3. 把软件及依赖软件全部下载到某个路径4. 自定义YUM仓库 注意：本文采用CentOS7.6
一、Linux下有哪些软件安装方式 RPM软件包管理（格式一般为软件名.rpm）yum软件管理包（使用yum命令安装软件）源码编译安装（手动编译+安装） 1.rpm包（二级制软件包） 二进制包，指的是已经编译后的软件包，直击安装就能使用了二进制包需要根据自己的CPU以及操作系统去选择合适的包，和Window的.exe软件包类似 2. 源码软件包 源码包，是程序员写好的源代码，不能在计算机上直击运行源码包，需要编译生成二进制软件包后，才能安装使用，源码包一般可以在任何计算机上使用源码包的命名方式一般为 .tar.gz.tar.bz2tar.xzzip 3. 二进制源码包 二进制源码包，是一个半成品，安装后不能直接使用二进制源码包，需要使用rpmbuild工具重建成真正的rpm包或者重建成源码包才可安装使用二进制源码包，命名方式一般为： mysql-community-5.7.25-1.el6.src.rpmmysql-community-5.7.25-1.el7.src.rpm 4. 常见的二进制软件包 系统平台包类型工具在线安装RedHat/CentOS/Fedora/SUSErpmrpm,rpmbuildyumUbuntu/Debiandebdpkgapt 5. 二进制包和源码包区别 软件包类型是否编译安装难易程度可定制性二进制包否直接安装差源码包是麻烦（配置+编译+安装）好 6. 二进制软件包的安装方式 基于rpm进行安装（先下载软件到本地再进行安装）基于yum进行安装（在线下载然后进行安装） 二、各种软件包安装步骤 1. rpm软件包的安装和卸载 1）rpm安装 命令：rpm -ivh 软件包名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e76cd61672bc96b88883d5f9b6bb707/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23a278c4a333567d6b706bd86ef4df7f/" rel="bookmark">
			OneDNS终端网络安全接入服务原理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OneDNS 互联网安全接入 目录 一、互联网中的GPS——DNS二、OneDNS是什么?2.1 简介2.2 功能概述 三、基于OneDNS规避网络安全风险3.1 OneDNS原理解析：在DNS基础上进行改造升级3.2 OneDNS高性能防御：3.3 核心能力3.4 OneDNS防护实现检测、拦截、定位、取证闭环3.5 SaaS化部署方式和接入流程3.6 Agent-终端取证定位原理3.7 OneDNS网络安全防御相比于代理技术或者杀毒软件的优势? 四、下载安装五、个人版配置和使用OneDNS流程六、测试拦截功能 在讲解OneDNS如何发挥网络安全防御效果之前，先了解下什么是DNS
一、互联网中的GPS——DNS DNS：域名系统(DomainNameSystem)的缩写，因特网的一项核心服务，相当于互联网的GPS。 可以看成一个巨大的通讯录，主机访问域名时，把网址解析为对应IP地址给出终端。
我们可以把DNS看做是一个分布式数据库，命名系统采用层次的逻辑结构，如同一颗倒置的树，这个逻辑的树形结构称为域名空间，由于DNS划分了域名空间，所以各机构可以使用自己的域名空间创建DNS信息。
DNS域名空间中，树的最大深度不得超过127层，树中每个节点最长可以存储63个字符。，DNS树的每个节点代表一个域，通过这些节点，对整个域名空间进行划分，成为一个层次结构。域名空间的每个域的名字，通过域名进行表示。
什么是递归DNS？
我们可以把递归DNS看成一个巨大的通讯录，根据域名查出IP地址，进行网络访问。
为什么要在获取ip地址？
因为计算机并不认识www.aaa.com这样的域名，域名只是人们为了方便阅读和记忆被创造出来的。
如果没有域名，我们每次浏览网页都要输入一串ip地址，这会造成诸多不便。所以递归DNS起到了将域名翻译成IP的作用，使用户完成域名访问。
公网访问互联网解析流程：
DNS安全风险：
DNS是网络威胁流通的主管道，监控、存储、分析DNS数据对企业网络安全建设有着极其重要的意义，然 而几乎所有的企业都允许DNS协议类型数据报文不受限制的传输，DNS覆盖超过91.3%的恶意软件与远控的通信。
针对递归DNS的攻击：Dos&amp;DDos、缓存投毒、服务器劫持、 DNS劫持、DNS欺骗、DNS重绑定…利用递归DNS的攻击：C&amp;C域名、恶意DGA域名、恶意软件、 钓鱼网址、色情网址、黑产广告网址… 二、OneDNS是什么? 2.1 简介 OneDNS 互联网安全接入服务是北京微步在线科技有限公司提供的具备安全防护能力的 DNS 递归解析服务，该服务可以保护任何一台终端、任何一个办公职场、任何一个家庭均可安全地接 入到互联网，为企业和家庭用户有效防护：恶意软件、勒索病毒、APT 攻击、钓鱼链接、非法站点。并且屏蔽各类广告骚扰和欺诈类网站，净化网络环境，保护数据安全。
2.2 功能概述 阻断软件恶意攻击：
OneDNS可以有效组织恶意软件攻击。
内置的OneDNS WebGuard威胁站点拦截引擎，阻断带有恶意软件、恶意脚本的站点，或者钓鱼站点，防止您中招或用户数据被窃。
机器好像已经中招了该怎么办？阻断已中招的机器与攻击者之间的恶意网络通信，避免机器进一步的数据失窃、系统被破坏，或者被勒索加密等。
为防止DNS解析服务被滥用，OneDNS个人版对来自每个IP地址的解析请求量做了限制，我们保证这一阈值足够家庭及个人用户使用。
减少广告骚扰：
过多的广告骚扰是非常影响我们的浏览体验的，这个困扰OneDNS就可以解决这一问题。
屏蔽广告骚扰，优化页面加载速度，节约流量的同时让上网体验更优。屏蔽获取个人信息用于广告推送的站点，减少个人隐私数据泄漏。
三、基于OneDNS规避网络安全风险 3.1 OneDNS原理解析：在DNS基础上进行改造升级 改造后的，新的网络请求链路如下图所示：
OneDNS拿到请求域名，与云端情报库实时碰撞，安全域名稳定高效解析，返回解析IP给用户进行访问； 检测到恶意域名不做解析，直接拦截，返回拦截页面，实现安全防护。
3.2 OneDNS高性能防御： OneDNS可以全面防护新型威胁及变种，确保任何一台终端、任何一个办公职场安全地接入到互联网，有效防护恶意软件、勒索病毒、APT攻击、钓鱼链接、非法站 点等多种新型高级威胁，实现检测、拦截、定位、取证闭环。
3.3 核心能力 电脑终端高性能威胁防护：风险网站情报搜集同步至云端，99.9%的情报准确度。全面防护恶意软件、勒索病毒、APT攻击、钓鱼链接、非法站点等。安全闭环：威胁检测、自动拦截、失陷定位、 进程取证，提升安全运营效率高、 轻松无忧。与杀毒软件及时互补。远程办公安全防护： 轻松安装上千终端 随时随地、自动接入OneDNS防护 进入办公区自动切换到企业内部网络。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23a278c4a333567d6b706bd86ef4df7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cba5e6f3dff4d37d6498d0e5e03bc744/" rel="bookmark">
			MindSpore入门避雷踩坑篇(2)——在Ubuntu18.04上用编译安装GPU环境的MindSpore1.3.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 准备Ubuntu18.04系统2. 系统环境信息要求3. 通过终端编译C语言4. 无法获得锁 开幕雷击：本篇文章记录的是安装失败的经验分享，所以甭想通过本文配置好GPU环境！ 1. 准备Ubuntu18.04系统 由于本人使用的是含NVIDIA GPU环境的Win10操作系统，而MindSpore1.3.0 GPU版本仅支持Linux-x86_64系统，因此首先从VMware虚拟机上安装了Ubuntu18.04（基于Linux内核的桌面PC操作系统）:
然而最终忘记了致命的一点：VMware的虚拟机是采用软件虚拟化，从主机那分配了一些内存供于虚拟机使用，
不像ESXi硬件虚拟化的虚拟机，可以直接调用硬件资源，所以是无法直接使用主机的显卡驱动，（学过微处理器的盆友们应该能避开这个愚蠢的尝试）
建议的解决办法是：安装Windows和Linux的双系统，
所以如果你已经有Linux的系统，大概率可以根据官网指南快速完成配置。
以下是发现这个问题之前失败的一系列尝试，主要与Ubuntu配置gcc依赖文件，以及终端的一些操作命令使用有关，供读者避雷作参考！
具体安装过程可参考B站教程：《Linux非官方指南》第三期-Windows下在虚拟机VMware中安装Ubuntu18.04 Linux操作系统——差点成了程序员的老师
2. 系统环境信息要求 2.1 官方文档要求确认安装64位操作系统，glibc&gt;=2.17，其中Ubuntu 18.04是经过验证的：
在Ubuntu终端中输入ldd --version，可查看版本号；
2.2 安装GCC 7.3.0版本
GCC7.3.0下载Portal
将下载的"gcc-7.3.0.tar.gz”代码包保存至任意目录，
如:/home/gao/桌面/gcc-7.3.0.tar.gz，
在终端输入cd~/桌面将目录切换至桌面，
运行如命令解压：tar -xzf gcc-7.3.0.tar.gz（可能会暂时卡顿，请耐心等待加载完毕）
继续输入cd gcc-7.3.0，进入到源码包目录，
运行以下命令，进行安装前的配置：
./configure --enable-checking=release --enable-languages=c,c++ --disable-multilib 这里checking报错：没有检测到C/C++编译器（可能之前没安装过），需要进行编译安装：
首先要确保虚拟机联网！否则任何安装命令都会失效，
虚拟机联网方法：这回就听度娘的就行
笑不活了…
分别输入以下三个指令： 安装C/C++编译器
bash sudo apt-get install gcc gcc安装相关构建工具
bash sudo apt-get install build-essential 安装make
bash sudo apt-get install make 这里输入gcc --version发现安装的是7.5.0版本，而MindSpore要求的是7.3.0版本(不知道7.5.0是不是向下兼容，但看着网上那么多教程都在往下改，我也不知道了呢，可以自己试试哦~)，
再重新回到桌面的地址输入：cd gcc-7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cba5e6f3dff4d37d6498d0e5e03bc744/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdea88997a2680b1540cf71ab0cd2da6/" rel="bookmark">
			webpack5性能优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发优化 使用html-webpack-plugin 自动引入打包资源通过 eslint 格式化代码babel处理 js 文件设置缓存（cacheDirectory）loader 都可以设置缩小扫描范围的规则（include/exclude）开启 sourcemap 帮助我们快速定位问题使用 oneOf 解决 rules 匹配性能浪费的问题使用 thread-loader 多进程打包 生产优化 资源文件打包 base64
{ test: /\.(png|jpe?g|gif|webp|svg)$/, type: 'asset', parser: { dataUrlCondition: { maxSize: 4 * 1024 // 4kb 以下打包base64 } } } css文件的单独提取（1. 单独提取利用浏览器并行加在机制，2. 可以使用 splitchunk 减少重复引用导致的代码冗余）
const MiniCssExtractPlugin = require("mini-css-extract-plugin"); css 样式的兼容性处理（使用了postcss）
npm install postcss-loader postcss postcss-preset-env -D ... 具体配置流程详见 4. css 样式压缩
npm install css-minimizer-webpack-plugin --save-dev 使用 babel 对 js 代码进行兼容性处理（简单的）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdea88997a2680b1540cf71ab0cd2da6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83927408d2847a3903d33a2aac8bb48a/" rel="bookmark">
			Class.forName()用法简介说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：
Class.forName()用法简介说明
下文笔者讲述Class.forName()方法的功能简介说明，如下所示:
class对象简介说明
class对象用于表示类 每一个类在JVM中都对应一个class对象 jvm中将使用class对象加入到类加载器中 注意事项: 1.java程序运行之前,并不会将所有的Class对象放入jvm中 2.每一个****.class类在jvm中只会对应一个Class实例对象 3.Class类只有一个私有构造函数，并且Class对象只能由JVM创建和加载 4.Class类对象功能:运行时提供和获取某个对象的类型信息 获得class对象的三种方法
1.调用Object类的getClass()方法来得到Class对象 如： ObjectTest t; Class c1 = t.getClass(); 2、使用Class类的中静态forName()方法获得与字符串相应的Class对象 如： Class c2=Class.forName("ObjectTest") ObjectTest:须是接口或类的名字 class.forname()语法: Class c=Class.forName("类的全限定名") 3、直接使用类名的class 如: Class c3 = User.class; Class c4 = int.class; Class c5 = Double[].class; class的功能和方法
getname(): 以string类型返回class对象表示的实体（类，接口，数组，基本类型，void等）名称 newInstance(): 创建一个实例，只能调用默认构造器 getsuperclass(): 返回class表示的实体超类的名称 getClassLoader(): 返回该类的类加载器 getSimpleName(): 不办含包名的类名 isInterfence: class对象是否表示某个接口 Class.forName()用法
Class.forName(xxx.xx.xx): 返回的是一个类 Class.forName(xxx.xx.xx)的功能: JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段 Class.forName是一个静态方法，相同能够用来载入类 Class.forName语法: Class.forName(String name, boolean initialize, ClassLoader loader) 或 Class.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83927408d2847a3903d33a2aac8bb48a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d17d67039f57acc1cf7cb7dae9970296/" rel="bookmark">
			python实现 logistic 回归 二分类算法 （通俗讲解逻辑回归本质与由来）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		logistic回归 将数据样本看作是欧式空间的点，尝试找到一个超平面，将空间分成两部分，如果样本点在”正面“，则它被分为0类；如果样本点在”负面“，则它被分为1类。怎么判断样本点在超平面的哪一面？将样本点坐标 x x x代入超平面方程 a T x = 0 a^Tx=0 aTx=0的等式左边 a T x a^Tx aTx，如果大于0，则在”阳面“；小于0，则在”阴面“；等于0，则在超平面上。根据上面大于0 or 小于0 已经能判断属于哪一类了，再代入符号函数(机器学习里叫阶跃函数，数学人觉得就是个符号函数)，直接输出类别0 or 1，就更好了。这样就有了一个完整模型，即 s i g n ( a T x ) {\rm sign}(a^Tx) sign(aTx)。为什么非要套一个符号函数呢？我直接用大于0，小于0判断不行嘛？不行，因为后面要进行优化选参数 a a a，有完整模型才能建立评价指标，比如风险函数，然后这个风险函数作为优化目标，取其极值点不是吗？ s i g n ( a T x ) {\rm sign}(a^Tx) sign(aTx)这个模型并不是很好，因为后续要进行优化，绝大多数优化算法依靠的是导数信息(虽然现在有很多非光滑优化算法)，参数 a a a作为变量，函数 s i g n ( a T x ) {\rm sign}(a^Tx) sign(aTx)最好要是光滑的，但是它不是，因为原点是符号函数的跳跃间断点，它甚至都不连续啊…性质太差了！怎么解决上面的问题？光滑化呗，取一个光滑函数去近似符号函数，下图是符号函数图像：
我想让它变成下面这样光滑去近似符号函数：
正好，sigmoid函数完美符合要求，连续光滑，长得像符号函数。把上面模型的符号函数替换成sigmoid函数就是逻辑回归模型了。 sigmoid函数：
σ ( x ) = 1 1 + e − x \sigma (x)=\frac{1}{1+e^{-x}} σ(x)=1+e−x1​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d17d67039f57acc1cf7cb7dae9970296/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56a4bd9bce7463b3f33a37faf33fc5e9/" rel="bookmark">
			【MySQL &#43; VBA】从Access将数据update到MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MS Access, MySQL, Ado
一. Access连接到MySQL： 在本机状态下，用mysql（8.0）做后台，用Access（2019）做前端`
并在VBA界面中，点『运行』-『引用』-microsoft activex data objects 6.1 library，做好ADO的引用
连接MySQL的准备 Option Compare Database Option Explicit Const MYDRIVER = "Driver={MySQL ODBC 8.0 Unicode Driver};" '驱动程序 Const MYSERVER = "Server=127.0.0.1;" '服务器 Const MYPORT = "Port=3306;" '端口 Const MYDATABASE = "Database=abc;" 'MySQL数据库名称 Const MYUSER = "User=root;" '用户名 Const MYPASS = "PWD=123456789abcd;" 'Mysql密码 Public constr As String ADO的定义 在Option Compare Database下
Public cn As New ADODB.Connection Public rs As New ADODB.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56a4bd9bce7463b3f33a37faf33fc5e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6582b4ae9fef05ef7803f4e48e387a2/" rel="bookmark">
			mac 设置ll命令始终生效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先在 ~/.bash_profile 文件中加入如下命令
alias ll='ls -alF'
2、执行 source ~/.bash_profile 命令，使修改生效
这样就可以使用 ll 命令了，但是每次新开的终端 ll 命令都会失效，以下是解决方案
1、在 ～/.zshrc 文件中加入如下命令
source ~/.bash_profile
若没有.zshrc 文件，则执行 touch .zshrc 命令就可以；
2、执行 source ~/.zshrc 是文件生效，这样每次打开的新终端，都可以使用 ll 命令啦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7554a089e86d98dc7a32dc13928a5aaa/" rel="bookmark">
			使用Origin绘制弦图全流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		弦图是一种常用的进行表示一种成分向另一种成分转移或表示占比情况等的图。最常接触到的是在生物、医学等论文中，在地理学论文中发现也有人使用，做粮食安全、土地利用转移等。
本科时候就给老师干活，画过弦图，现在自己做一个类似于土地利用转移矩阵的图，所以也想使用弦图进行绘制。
关于弦图有很多介绍的代码，19年当时会用R语言画，现在已经都忘记了，再从头学代码太麻烦，所以使用Origin出图会简单很多。
当时使用的R语言代码 当时啥也不懂，也没有写代码的注释，导致自己现在再看的时候，除了知道修改输入和输出以及相关的行列名，里面的参数都不知道干啥的了。所以代码还是要有注释才行啊
library(statnet) library(circlize) data&lt;-read.csv("liangshi.csv",header=T,row=1) my.data&lt;-as.matrix(data) grid.col = NULL colnames(my.data) &lt;-c("X", "N", "C", "W") rownames(my.data) &lt;-c("S1", "S2", "S3", "S4","S5") grid.col[c("S1", "S2", "S3", "S4","S5"] = c("PowderBlue", "DeepSkyBlue", "CornflowerBlue", "Blue","MidnightBlue"); grid.col[colnames(my.data)] = c("lavender", "khaki","mistyrose", "sienna1") circos.par(gap.degree = c(rep(2, nrow(my.data)-1), 10, rep(2, ncol(my.data)-1), 10), start.degree = 180) chordDiagram(my.data, directional = TRUE, diffHeight = 0.06, grid.col = grid.col, transparency = 0.5) legend("bottomright",pch=20,legend=colnames(my.data), col=grid.col[colnames(my.data)],bty="n", cex=1,pt.cex=3,border="black") legend("topright",pch=20,legend=rownames(my.data), col=grid.col[rownames(my.data)],bty="n", cex=1,pt.cex=3,border="black") pdf(file="liangshi.pdf", width=8, height=5, pointsize=8) chordDiagram(my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7554a089e86d98dc7a32dc13928a5aaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c4642d337e8d54ae5cf9dc7f6606c3c/" rel="bookmark">
			【记录】docker容器无法启动后,如何修改里面的配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：在容器内修改了一个配置文件，然后保存。再重新启动容器结果就启不来了。然而我们又想把刚才修改的配置给修改为原来的再启起来，我们该怎么办呢？ 解决办法： 第一步：把docker容器中的配置文件复制到主机中，然后在主机中修改，修改完成后再复制到docker容器中，这里需要使用的docker的命令：
// docker cp [容器id]：docker容器中配置文件路径 主机路径 // 例如 docker cp 4177f35c38d8:/usr/local/lib/python3.8/site-packages/superset/utils/core.py /home/core.py 第二步：到 /home下找到core.py文件修改好后再复制回去即可
docker cp /home/core.py 4177f35c38d8:/usr/local/lib/python3.8/site-packages/superset/utils/core.py 第三步：重新启动容器即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eec717fc692c611bcbf287150c07ed9/" rel="bookmark">
			stack-protector enabled but compiler support broken
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译驱动模块时，出现如下错误：
make -C "/lib/modules/3.10.0-1160.el7.x86_64/build" M=/root/hydcu_fixup_header/hydcu_pci_fixup_header modules make[1]: 进入目录“/usr/src/kernels/3.10.0-1160.el7.x86_64” arch/x86/Makefile:96: stack-protector enabled but compiler support broken arch/x86/Makefile:166: *** CONFIG_RETPOLINE=y, but not supported by the compiler. Compiler update recommended.。 停止。 make[1]: 离开目录“/usr/src/kernels/3.10.0-1160.el7.x86_64” make: *** [all] 错误 2 解决办法：
编辑： /usr/src/kernels/3.10.0-1160.el7.x86_64/include/config/auto.conf /usr/src/kernels/3.10.0-1160.el7.x86_64/.config 这两个文件，搜索CONFIG_RETPOLINE=y等关键字样，然后注释掉。
注： 此环境为centos环境下，kernel后跟的目录为自己环境的内核版本名称，可使用uname -r查看自己所使用的内核版本。编译需要保证环境下安装gcc编译器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30b0b623df940f91594d3c8cacd05a80/" rel="bookmark">
			【强烈推荐】基于STM32的TFT-LCD各种显示实现（内容详尽含代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：TFT-LCD模块作为人们日常生活中常见屏幕类型之一，使用的受众面非常广阔。例如：显示各个传感器数值，显示精美界面，多级化菜单系统等等都不离不开他的身影。可以说学会TFT-LCD模块是嵌入式开发必须掌握的驱动开发技能之一，同时，也是嵌入式开发调试配置的重要手段与技巧！（文章结尾会有代码开源）
实验硬件：STM32F103C8T6；2.4寸TFT-LCD（240×320）
硬件实物图：
效果图：
引脚连接：
VCC --&gt; 3.3V
GND --&gt; GND
CS --&gt; PB11
Reset --&gt; PB12
DC --&gt; PB10
SDI --&gt; PB15
SCK --&gt; PB13
LED --&gt; PB9（控制LCD背光，可以同PWM调节改变LCD亮暗）
一、TFT-LCD模块简介 TFT-LCD（Thin Film Transistor）液晶显示屏是薄膜晶体管型液晶显示屏，也就是“真彩”（TFT）。TFT液晶为每个像素都设有一个半导体开关，每个像素都可以通过点脉冲直接控制，因而每个节点都相对独立，并可以连续控制，不仅提高了显示屏的反应速度，同时可以精确控制显示色阶，所以TFT液晶的色彩更真。
TFT液晶显示屏的特点是亮度好、对比度高、层次感强、颜色鲜艳，但也存在着比较耗电和成本过高的不足。TFT液晶技术加快了手机彩屏的发展。新一代的彩屏手机中很多都支持65536色显示，有的甚至支持16万色显示，这时TFT的高对比度，色彩丰富的优势就非常重要了。
市面上的TFT-LCD有需要的芯片驱动类型（不同的驱动芯片，其显存大小与其驱动时的传输LCD初始化数据不一样。其显示功能的API函数可以互通），市面上常见的芯片驱动有：ILI9341/ ILI9325/ RM68042/ RM68021/ ILI9320/ ILI9328/ LGDP4531/ LGDP4535/ SPFD5408/ SSD1289/ 1505/ B505/ C505/ NT35310/ NT35510 等。
笔者所用的TFTLCD驱动芯片为常见的ILI9341，这里就以ILI9341给大家为例讲诉（需要其他驱动芯片资料的可以评论留言，笔者基本上市面上常见的都有其代码与资料）。
ILI9341液晶控制器自带显存，其显存总大小为 172800（240*320*18/8），即 18 位模式（26万色）下的显存量。在 16 位模式下，ILI9341 采用 RGB565 格式存储颜色数据（在更高级的32位RGB储存颜色中还有RGBA888，Linux开发板中较为常见），此时 ILI9341的 18 位数据线与 MCU 的 16 位数据线以及 LCD GRAM 的对应关系如图 所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30b0b623df940f91594d3c8cacd05a80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddc6361160a8593423a785af118703dd/" rel="bookmark">
			OPenGL 学习笔记之 VBO VAO EBO 概念和使用方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 基本概念：
二. 理解缓冲对象 glVertex 函数
顶点数组(Vertex Array)
三. VBO（Vertex Buffer Object）顶点缓冲区对象
大体流程理解：
Qt 中使用QOpenGLWidget 的VBO 例子 四. VAO（Vertex Array Object）顶点数组对象
Qt 中使用QOpenGLWidget 的VAO 例子 五. EBO 索引缓冲对象
EBO示例 六. 总结
七. 参考链接：
一. 基本概念： VAO（vertex-array object）顶点数组对象，用来管理VBO。VBO（vertex buffer object）顶点缓冲对象，用来缓存用户传入的顶点数据。EBO（element buffer object）索引缓冲对象，用来存放顶点索引数据。 这里的object指的都是GPU中的一块内存，每个内存对象都有不同的作用，但创建、绑定、数据传送等方式都比较类似，通过不同的类型加以区分，掌握了一种，其他的就很好理解。
二. 理解缓冲对象 glVertex 函数 最原始的设置顶点方法，在glBegin和glEnd之间使用。OpenGL3.0已经废弃此方法。每个glVertex与GPU进行一次通信，十分低效。
glBegin(GL_TRIANGLES); glVertex(0, 0); glVertex(1, 1); glVertex(2, 2); glEnd(); 顶点数组(Vertex Array) 顶点数组也是收集好所有的顶点，一次性发送给GPU。不过数据不是存储于GPU中的，绘制速度上没有显示列表快，优点是可以修改数据。
显示列表和顶点数组都是过时的东西了，下面的VBO和VAO才是重点！
#define MEDIUM_STARS 40 M3DVector2f vMediumStars[MEDIUM_STARS]; //在这做点vMediumStars的设置// glVertexPointer(2, GL_FLOAT, 0, vMediumStars); glDrawArrays(GL_POINTS, 0, MEDIUM_STARS); 三.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddc6361160a8593423a785af118703dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c458b814a1a8fa398780f44c1a35678/" rel="bookmark">
			VS Code中#include报错（新建的头文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：#include 的头文件报错（找不到自己新建的头文件） 解决方法： （1）找到头文件的路径，并在终端中打开，输入pwd，获取详细路径信息;
（2）把路径信息复制到 c_cpp_properties.json 文件的 "includePath" 里;
（3）配置完后保存关闭，就能正常找到头文件了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8fc5c9f09d08200505b4816f09ec3bc/" rel="bookmark">
			Error in v-on handler: “ReferenceError: isShow is not defined“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码如下：
const vm=new Vue({ el:'#app', data:{ isShow:true }, methods:{ dian(){ isShow=!isShow } } }) 错误原因是因为：
在v-on命令中，isShow这个变量没有定义，但是在代码中我已经在data中定义了isShow这个变量，经过检查原来是因为在方法中如果想要使用实例上面的变量，必须要使用this来指向这个变量，经过给isShow添加this指向，问题解决
修改代码如下：
问题解决，大家一定要清楚来龙去脉，不然就会像我一样犯糊涂☹。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2943dba47adc7eeb1dc124311b969c0/" rel="bookmark">
			MFC 各控件背景颜色设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、添加OnCtlColor消息响应函数；
类视图中，在需要添加OnCtlColor消息的类中选择"类导向"
"类向导"界面如下
"确定"后会在对应类中添加如下函数； CStand::CStand(CWnd* pParent /*=NULL*/) : CDialogEx(CStand::IDD, pParent) { m_Brush=::CreateSolidBrush(RGB(76,136,166)); bLen = 0; } HBRUSH CStand::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) { HBRUSH hbr = CDialogEx::OnCtlColor(pDC, pWnd, nCtlColor); HBRUSH hbr_red = ::CreateSolidBrush(RGB(200,60,60)); pDC-&gt;SetBkMode(TRANSPARENT); pDC-&gt;SetTextColor(RGB(0,255,255)); pDC-&gt;SetBkColor(RGB(255,136,166)); if(nCtlColor == CTLCOLOR_DLG || nCtlColor == CTLCOLOR_STATIC) return m_Brush; if (pWnd-&gt;GetDlgCtrlID() == IDC_EDIT_ZERO1) { if(m_Value1 &gt; 500) return hbr_red; } // TODO: 在此更改 DC 的任何特性 // TODO: 如果默认的不是所需画笔，则返回另一个画笔 return hbr; } 更改对话框背景颜色或控件背景颜色需要了解控件类型；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2943dba47adc7eeb1dc124311b969c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40f30ce07b2984326df6c2e162b1755a/" rel="bookmark">
			Maven home directory不能修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 我们现在使用的idea都自带maven,但是实际开发中，可能idea自带的版本和我们使用的框架或jdk版本不兼容，那么就需要我们更改idea中的maven版本。然而Maven home directory不能修改。那么请看以下内容
解决 参考来源 来源忘记，记录类信息参考有用点赞谢谢！
步骤 1.查看项目目录是否存在.mvn文件夹，如果有可以删除整个文件夹或者删除内部的properties文件。
2.如果idea配置不生效可以删除.idea文件夹。重新打开重新设置相关配置。
3.修改maven配置信息如下：
点击file&gt;&gt;&gt;setting打开设置页面找到Build,Exe…&gt;&gt;&gt;Maven Maven home path 修改maven版本User settings file 修改maven配置文件。配置文件位置一般在maven根目录下的conf文件夹内的.xml文件。修改D:\maven tomcat\maven\LocalWarehouse 可以调整maven仓库位置。将 Override 打钩配置才能生效。Local repository 修改maven本地仓库。即配置文件修改的路径D:\maven tomcat\maven\LocalWarehouse 同样效果。
配置修改后记得点击Apply或者ok配置才能生效 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e39579c9e017c45c9f8fd4c4c164129d/" rel="bookmark">
			skynet设计原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		skynet设计原理 多核并发编程的模型skynetActor创建Actor运行Actor消息定时消息消息是如何推送到ActorActor的调度工作线程流程工作线程权重这个权重的作用是什么？ 第一个主要是skynet设计原理，skynet主要是一个actor模型的一个封装，详细的介绍actor是什么，actor之间的一个消息是怎样来进行通讯的以及如何来调度的
第二个讲解一些lua原理，以及我们的这个网络封装相关
第三节会讲解具体的实际应用，实际应用主要从这三个方面来讲解，第一个网关的封装，第二个实际项目当中的热更新到底怎么做，第三个会跟大家讲解比较常用的一个技术，就是我们的监听发布
skynet它是属于一个多核并发编程的模型
多核并发编程的模型 网络编程当中memcached是多线程，多线程的数量是跟我们的核心数是相同的，然后它的目标呢也是为了充分cpu，利用我们的核心数。
nginx当中它是一种多进程的解决方案，多进程的工作进程的个数呢也跟我们的CPU的核心是一样的，然后这里面就涉及到一些加锁，那么多进程，它安全方面主要是通过我们的共享内存来共享数据进行worker进程之间的通讯的，它是共享内存来实现的。
还有一种就是我们的CSP模型，CSP模型就是以go语言为代表，内核线程的数量呢也是跟我的CPU核心数是一样的，那么上一层就是我们用户态的并发型是我们的协程。
Actor模型呢它也是一种多核并发编程的模型，那么它的内核线程就是实际运行的内核线程数呢也是跟我们的cpu的核心数是一样的，可以看出来我们多核并发编程呢都是为了充分利用我们多个核心数，然后呢尽量避免我们线程的一个切换。
我们虽然上面都是有4种不同的多核并发编程的模型，但是呢它们有2种不同的分类，第一个是多线程与多进程，
我们通常说的多线程，是指在一个进程当中开启多个线程。
在一个进程当中多个线程他们共享的资源，就是我们这些线程之间的一些资源共享，那么它是利用到我们的一个进程当中的内存，那么在这里就涉及到一个共享资源问题，那么就会涉及到一个加锁问题？那么在这里面加锁呢我们就需要考虑了，像memcached加锁，因为它里面支持的数据类型非常简单，就是一个哈希结构，那么我们在他多线程加锁的时候呢，它的力度非常的小，那么通常呢我们也是采用一种粒度很小的锁，也就是我们的自旋锁或者是用我们的原子变量来实现自旋锁。
那么在多进程当中大家思考一下，在nginx当中呢它是采用的一个共享内存，这个数据结构ngx_shmtx_t锁的类型，
如果能够符合我们的原子操作的话，那么它采用的是一个自旋锁，那么如果原子操作不支持的话，它采用的是一个信号量,如果信号量也不支持，那么呢他就会用其中的一个文件锁。
可以看出来多线程，多进程它里面的锁的锁的力度都是首选于自选锁，那么它们的目的呢也非常的明确，就是尽量减少这个多线程切换，进程的切换。
多线程当中它是利用一个进程当中的内存，那么多进程当中，使用的一个共享内存来进行加索，我们使用一个slab技术，在共享内存当中可以使用红黑树，红黑树它里面加锁也是采用的这个锁。
多线程多进程，他们都是通过共享内存来进行共享数据
CSP和Actor是采用通信来共享内存，
最好的方式是就是不要通过共享内存来通讯，而应该要通过通讯来共享内存，
CSP它是GO语言，它里面的并发实体是协程，协程是轻量级的线程，那么我们开启线程它耗的资源比较高，协程的耗资源比较低，可以开启成千上万的协程，那么协程之间怎么共享数据？
go语言采用channel来进行通讯，就相当于我们多线程采用pipe来通讯，它是一种管道，Actor也是通过也是这一档相同的哲学，它也是通过发送数据通信的方式来共享内存。
我们有两个Actor它是一个轻量级的进程，注意它们两者的区别，CSP是轻量级的线程，
它是以采用的协程，我们的Actor它是在我们的应用层把它封装出一个进程，抽象出一个进程，这个进程，抽象的进程之间是怎么通讯？
它是通过我们发送消息的方式来进行通信，就比如说我们这个 A进程要跟B进程共享数据的话，我们是通过发送消息的方式来进行交换数据或者是共享数据。
采用这种不要通过共享内存来通信，而应该通过通信来共享内存的编程哲学我们编写代码它的速度要快一些，为什么？因为我们通过通讯来共享数据呢其实是一种解耦的过程。
如果我们两个功能是耦合在一起的话，那么我们去调试测试的时候要两者一起进行调试或者测试。那么现在我们解耦合把这两个功能模块，分成两个不同的模块当中处理，就是两个不同的进程，我们叫Actor，抽象成两个进程去处理，那么这个时候我们两个功能模块呢可以分别测试跟调试，进行优化，它是一种解解耦合的过程。
同时呢它能够方便我们来快速的开发，它同时呢也符合我们开发的思路，我们开发是不是喜欢将一个大的问题把它拆分成若干个小问题，然后将这些小问题，单个的去调试优化，然后再把它组织在一起来完成这个任务，它非常符合我们去解决问题的思路，所以学习一下Actor的编程的思路，体会一下这种思想
skynet skynet它就是一种Actor模型，它也是封装的一个轻量级的进程，GO语言是采用的轻量级的线程。
skynet它是一个轻量级的游戏服务器框架，当然了它不仅仅用于游戏，那么轻量级主要体现在哪里呢？
它既然是一个轻量级的游戏服务器框架，那么是不是都实现了跟游戏相关的所有服务器模块呢？它并没有因为它是个轻量级的，轻量级它主要体现在它仅实现了actor模型以及相关的
脚手架，这个相关的是指actor模型当中通讯的这些原理以及调度，以及比如说我们actor之间的一个广播以及actor之间他们可以共享一些资源，那么在这里呢他已经把我们封装好了，脚手架是就是工具集的意思。
第二个就是服务器框架的基础组件，它实现一些比如说它实现了一个
我们Actor模型，它是一个抽象的进程，那么这个抽象的进程跟我们的内核进程有什么区别？
我们的Actor模型它有一个实体，我们的进程跟进程之间他们里面的内存是不共通的，他们不能互相访问，属于一个隔离的环境。
那么我们的Actor模型，它抽象的进程，那么自然我们的每一个Actor它都是一个独立的运行单元，并且Actor跟Actor之间他们的数据以及我们运行这些函数，比如说这些变量他们都是不一样的，他们都是独立的。
所以我们的Actor它首先要有一个隔离的环境，那么在我们skynet中主要是采用lua虚拟机来进行。lua语言它也有个lua虚拟机，能用来实现我们这个隔离的环境。
Actor模型它的实现，可以看到这里面呢都会有一个队列，这个队列呢是我们的一个消息队列，这里面存放的是我们具体的消息，这里面有4个Actor，那么4个actor有3个，他们互相之间有发送消息，那么这个消息呢会插入到对方的Actor模型当中，消息队列当中。这个有消息的Actor我们称之为活跃Actor，这个没有消息的，那么它是非活跃Actor,
消息队列当中有消息叫做活跃Actor。
Actor模型是如何来定义的？
首先我们的Actor它是用于并行计算，什么叫并行计算？
就是他们这几个Actor可以同时运行，我们会开启多个线程，比如说我们开启4个线程，每1个线程都去执行1个Actor，也就是说我们在Actor模型当中，这些Actor可以同时运行，是真正的并行，并行的运行，就跟我们的进程一样，我们同时开启多个进程他们是同时来运行的。
Actor它是最基本的计算单元，也就是说Actor是我们最小的并发单元，我们前面讲的多核并发编程，多线程当中并发实体是我们的线程，多进程它的并发实体是我们的进程，有多少个核心数，那么核心数去运行进程，那么进程就是它的一个最基本的运算单元，
CSP呢它的并发实体是我们的协程，我们的这里的Actor，就是轻量级的进程。
它是基于消息计算这句话怎么来理解？
Actor分为活跃的非活跃的，非活跃的Actor就是这个当中没有消息，没有消息我们这个Actor不会运行，我们Actor的运行依据就是它能够执行的依据就是它的消息队列当中有消息，Actor是基于消息来进行计算的。
并且呢我们Actor是通过消息来进行沟通的，这个Actor需要通知，往这个Actor通知数据，那么我们通知他的方式，就是以消息的方式来通知。
我们再来看组成第一个隔离的环境，就是我们的运行环境的隔离，跟我们进程一样，大家思考这个进程隔离就行了。
我们运行的依据呢是这个消息队列，我们这里面会有消息队列一个一个的消息，当然呢这个消息呢是按照有序存放的，这个有序的是指我们有多个Actor跟他发消息，先到达的放在前面后到达的放在后面，这样的就是按先后到达的数据来进行存放，那么执行的时候也是一样的，
就按照我们插入消息的先后顺序来进行，这主要是为了实现我们运行的一个时序。
**那么我们怎么去消费这个消息？**我们的这个Actor如果没有回调函数，光有消息它也是不会运行的，消息队列当中有消息，并且还要有回调函数，回调函数就是去把这个消息取出来，作为我们回调函数的参数来进行执行。
这个呢主要是告诉我们怎么去运行Actor。
思考一下我们的进程是怎么运行的，有一个main函数？里面只要是个while死循环，它会一直执行到函数结束，进程的运行就是这么运行的。
Actor它不一样，它是通过回调函数，回调函数呢要有消息，消息作为我们回调函数的参数来进行执行。
区别这个进程跟我们Actor的运行方式，他们是不一样的，就是带有消息，并且要有回调函数把消息作为回调函数的参数去执行
Actor创建 Actor是怎么来创建的？
skynet.newserice，通过这种方式呢我们就启动调用了一个服务，那么我们现在呢直接走到这一步skynet_context_new，来看一下我们的Actor在我们的skynet当中是怎么体现的？
我们去创建lua服务的时候，这里面都会生成一个动态库，我们采用这个get_api去获取这一个动态库，把它动态库加载，加载到我们里面，然后呢去取出它的函数地址，第一步加载我们的动态库，然后呢具有获取函数指针。
通过这个 dlsym就是去获取它的函数指针，进行一个加载lua虚拟机的一个过程，
它是通过这种这4个接口函数的对动态加载函数地址，
然后呢来执行我们加载流程。
我们query的时候是把这里面的内容取出来，内容取出来之后，我们就尝试把它给打开，打开之后我们把函数取出来，函数取出来之后呢
接下来就开始去调动这个函数里面的内容了。
struct skynet_context * skynet_context_new(const char * name, const char *param) { struct skynet_module * mod = skynet_module_query(name); if (mod == NULL) return NULL; void *inst = skynet_module_instance_create(mod); if (inst == NULL) return NULL; struct skynet_context * ctx = skynet_malloc(sizeof(*ctx)); CHECKCALLING_INIT(ctx) ctx-&gt;mod = mod; ctx-&gt;instance = inst; ATOM_INIT(&amp;ctx-&gt;ref , 2); ctx-&gt;cb = NULL; ctx-&gt;cb_ud = NULL; ctx-&gt;session_id = 0; ATOM_INIT(&amp;ctx-&gt;logfile, (uintptr_t)NULL); ctx-&gt;init = false; ctx-&gt;endless = false; ctx-&gt;cpu_cost = 0; ctx-&gt;cpu_start = 0; ctx-&gt;message_count = 0; ctx-&gt;profile = G_NODE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e39579c9e017c45c9f8fd4c4c164129d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0608dcfb590b4d2c40b2ee6d6f6161f1/" rel="bookmark">
			python生成多维矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误的生成方法 先展示一个错误的方法：
a = [[['unknown', 0.0, 0]] * 2] * 6 生成：
[[[‘unknown’, 0.0, 0], [‘unknown’, 0.0, 0]],
[[‘unknown’, 0.0, 0], [‘unknown’, 0.0, 0]],
[[‘unknown’, 0.0, 0], [‘unknown’, 0.0, 0]],
[[‘unknown’, 0.0, 0], [‘unknown’, 0.0, 0]],
[[‘unknown’, 0.0, 0], [‘unknown’, 0.0, 0]],
[[‘unknown’, 0.0, 0], [‘unknown’, 0.0, 0]]]
当我们修改其中一项时：
a[0][0] = 5 生成：
[[5, [‘unknown’, 0.0, 0]],
[5, [‘unknown’, 0.0, 0]],
[5, [‘unknown’, 0.0, 0]],
[5, [‘unknown’, 0.0, 0]],
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0608dcfb590b4d2c40b2ee6d6f6161f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/676f586a2261c96ef059f27699bf4193/" rel="bookmark">
			Ubuntu18.04&#43;ROS melodic &#43;RealSense D435i的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、RealSense D435i相机结构介绍 RealSense 是一款立体视觉深度相机，如下图所示，其集成了两个红外传感器（IR Stereo Camera）、一个红外激光发射器（IR Projector）和一个彩色相机(Color Camera)。立体深度相机系统主要包括两部分：视觉处理器D4和深度模块。主机处理器连接 USB 2.0 / USB 3.1 Gen 1。视觉处理器 D4 位于主处理器主板上，RGB颜色传感器数据通过主处理器主板和 D4 板上的彩色图像信号处理器（ISP）发送到视觉处理器D4。IntelRealSense D435i提供了完整的深度相机模块，集成了视觉处理器、立体深度模块、RGB 传感器以及彩色图像信号处理模块。深度模块采用立体视觉的左右成像器、可选的红外激光发射器和 RGB 色彩传感器。
硬件参数信息
最高 1280×720 双目深度分辨率；
最高 1920×1080 RGB 分辨率；
最高 90 FPS 深度视频流。深度流与普通 RGB 视频流类似，只不过每个像素点的值不再是 RGB 或灰度值，而是物体相对于相机的距离；
更大的85度左右的镜头视场(FOV)；
只能对相同帧率的 RGB 与深度视频流做同步设置；
双目 baseline 为 50 mm；
深度探测范围 0.2 m ~ 10 m ；
6DOF追踪功能（six degree of freedom）；
深度坐标系以左侧相机为中心（上图中 centerline of 1/4-20 是指三脚架螺丝空的中心）；
内含一个 6 自由度的 IMU，对应刚体在三维空间中 6 种运动方式：前后、左右、上下的平移，以及绕刚体三个轴的旋转 —— 绕前后方向轴旋转 roll, 绕左右方向轴旋转 pitch, 绕上下方向轴旋转 yaw；【亮点，该款相机具备IMU】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/676f586a2261c96ef059f27699bf4193/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4b4c30984e3d3d95aba907a6822f5b0/" rel="bookmark">
			ps 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		From：http://blog.chinaunix.net/uid-25681671-id-3201927.html
进程和作业管理命令：http://man.linuxde.net/sub/进程和作业管理
Linux 关于 进程/线程 的命令
kill 和 pgrep 和 pidof 和 awk 和 pkill 和 killall：https://blog.csdn.net/freeking101/article/details/53445749
简介 Linux 中的 ps 命令是 Process Status 的缩写。ps 命令用来列出系统中 当前正在运行 的那些进程，就是执行 ps 命令的那个时刻的那些进程的快照。使用该命令可以确定有哪些进程 正在运行 和 运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。
ps 查看的结果不是动态连续的，如果想要动态的显示进程信息，就可以使用 top、htop 命令。
kill 命令用于杀死进程。
ps 命令支持的 3 种语法格式 三种语法格式：
1. UNIX 风格。 选项可以组合在一起，并且选项前必须有 "-" 连字符2. BSD 风格。 选项可以组合在一起，但是选项前不能有 "-" 连字符3. GNU 风格的长选项。 选项前有 两个 "-" 连字符 可以混用这几种风格，但是可能会发生冲突。较多使用 UNIX 风格 的 ps 命令。
十二 个经典 Linux 进程管理命令介绍 ps、pstree、top、htop、nice、renice、kill、ulimit、w 和 who 和 whoami、pgrep、fg 和 bg、ipcs
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4b4c30984e3d3d95aba907a6822f5b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b348040aad646ee5dab1f4c7ecc255d/" rel="bookmark">
			pyppeteer：比 selenium 更高效的爬虫利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		API 接口文档：API Reference：https://miyakogi.github.io/pyppeteer/reference.html
pyppeteer github 地址：https://github.com/miyakogi/pyppeteer
pyppeteer 英文文档地址：https://miyakogi.github.io/pyppeteer/
pyppeteer 官方文档 API Reference ：https://miyakogi.github.io/pyppeteer/reference.html
puppeteer( Nodejs 版 selenium )快速入门：https://blog.csdn.net/freeking101/article/details/91542887
python爬虫利器 pyppeteer(模拟浏览器) 实战：https://blog.csdn.net/xiaoming0018/article/details/89841728
重点：pyppeteer使用遇到的 bug 及解决方法：http://www.sanfenzui.com/pyppeteer-bug-collection.html
pyppeteer 进阶技巧 ( Xvfb 配合实现 headless 效果 )：https://www.cnblogs.com/dyfblog/p/10887940.html
Python 爬虫之pyppeteer 的使用(爬虫、获取cookie、截屏插件、防爬绕过)：https://mohen.blog.csdn.net/article/details/107312709
爬虫神器 Pyppeteer 的使用：https://blog.csdn.net/weixin_38819889/article/details/108684254
Pyppeteer 简介 提起 selenium 想必大家都不陌生，作为一款知名的 Web 自动化测试框架，selenium 支持多款主流浏览器，提供了功能丰富的API 接口，经常被我们用作爬虫工具来使用。但是 selenium 的缺点也很明显，比如速度太慢、对版本配置要求严苛，最麻烦是经常要更新对应的驱动。还有些网页是可以检测到是否是使用了selenium 。并且selenium 所谓的保护机制不允许跨域 cookies 保存以及登录的时候必须先打开网页然后后加载 cookies 再刷新的方式很不友好。
今天就给大家介绍另一款 web 自动化测试工具 Pyppeteer，虽然支持的浏览器比较单一，但在安装配置的便利性和运行效率方面都要远胜 selenium。
介绍 Pyppeteer 之前先说一下 Puppeteer，Puppeteer 是 Google 基于 Node.js 开发的一个工具，主要是用来操纵 Chrome 浏览器的 API，通过 Javascript 代码来操纵 Chrome 浏览器的一些操作，用作网络爬虫完成数据爬取、Web 程序自动测试等任务。其 API 极其完善，功能非常强大。 而 Pyppeteer 又是什么呢？它实际上是 Puppeteer 的 Python 版本的实现，但他不是 Google 开发的，是一位来自于日本的工程师依据 Puppeteer 的一些功能开发出来的非官方版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b348040aad646ee5dab1f4c7ecc255d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87e1134e64ab4c1629ae9b37d87c9a6a/" rel="bookmark">
			汇编语言（王爽第三版） 实验5编写、调试具体多个段的程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：http://blog.sina.com.cn/s/blog_171daf8e00102xclx.html
汇编语言实验答案 (王爽)：https://wenku.baidu.com/view/a1cd7c6c1fb91a37f111f18583d049649b660ede.html
一。将下面的程序编译连接，用Debug加载、跟踪，然后回答问题。 汇编代码：
assume cs:code,ds:data,ss:stack data segment dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h data ends stack segment dw 0,0,0,0,0,0,0,0 stack ends code segment start: mov ax,stack mov ss,ax mov sp,16 mov ax,data mov ds,ax push ds:[0] push ds:[2] pop ds:[2] pop ds:[0] mov ax,4c00h int 21h code ends end start 程序分析：由于是初次接触，我们逐步讲解，废话多点。 (1)此程序考察的是内存中数据段和栈段的定义。 程序共定义了 3 个段(依次 是 数据段、栈段、代码段。注意 段的前后顺序)
1个数据段，data段。首先明确，在程序运行开始(标号start处)，这个数据段就已经被定义好了，并且分配了内存空间，并赋值了。1个栈段，stack。同理这个数据段在没有被人工定义为栈结构时，也被定义好了。并且分配了内存空间，并赋值了。1 个代码段。 将此程序编译并连接后，使用 debug 调试，(这里需要注意，以下的段地址可能由于系统不同而有差异，主要是理解概念。)
C:\huibian&gt;debug shiyan_5.exe 然后执行 r 命令：
程序分析：我们什么也没执行，此时我们在 data段 定义的数据在哪 ？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87e1134e64ab4c1629ae9b37d87c9a6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a079313f3154962822828dd1ee75b76d/" rel="bookmark">
			C&#43;&#43; AFX_MANAGE_STATE(AfxGetStaticModuleState())的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/linlf03/archive/2011/11/16/2251318.html
从AFX_MANAGE_STATE(AfxGetStaticModuleState())说起https://blog.csdn.net/optman/article/details/332277
AFX_MANAGE_STATE(AfxGetStaticModuleState())的作用：用于模块切换时的状态保护，
1.AfxGetStaticModuleState()指向当前模块状态;
2.当前函数调用结束后原模块的状态自动被恢复；
3.用于DLL中所调用MFC函数、类、资源时的模块状态切换;
[MSDN]
By default, MFC uses the resource handle of the main application to load the resource template. If you have an exported function in a DLL, such as one that launches a dialog box in the DLL, this template is actually stored in the DLL module. You need to switch the module state for the correct handle to be used. You can do this by adding the following code to the beginning of the function:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a079313f3154962822828dd1ee75b76d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6afcf97dd5eb2df483f9c4c578af39dc/" rel="bookmark">
			C语言关于链表的代码看不懂?一篇文章让你拿捏二级指针并深入理解函数参数列表中传参的多种形式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：别人以梦为马，而我要以码为梦。我是叶落秋白，努力学后端中
✨个人主页：叶落秋白的主页
🔥系列专栏：数据结构干货分享
📃推荐一款模拟面试、刷题神器👉进入刷题的世界
🔥前言
这篇博客即将解决你看不懂或者不会写链表的基本操作的问题，对于初学者而言，有很多地方肯定是费解的。比如函数的参数列表的多样化，动态分配内存空间函数malloc等，其实这些知识和指针联系紧密，尤其是二级指针。那么开始好好的学习这篇博客吧！
📃目录
二级指针讲解
链表的应用 定义双链表的结构体
创建双链表
传入一级指针
传入指针的引用
传入二级指针
✨刷题网推荐
二级指针讲解 简述：其实就是一个指针指向另一个指针的地址。
我们都知道指针指向地址，但是指针自身也是一个变量，当然也可以被二级指针所指向。
语法：形如 int x = 10; int *q = &amp;x; int **p = &amp; q;
那么这里的q指针指向x的地址，p指针指向指针q的地址，*q可以得到x的值，*p可以得到q指针本身，**p也可以得到x的值。
代码示例：
int main(void) { int x = 10; int* q = &amp;x; int** p = &amp;q;	printf("x 的地址为： %d\n", &amp;x); printf("q 指向的地址为：%d\n", q); printf("*p的值为： %d\n", *p); //p指向指针q的地址，那么*p是解引用操作， //就等于了q本身 printf("x 的值为： %d\n", x); printf("q 存取的值为： %d\n", *q); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6afcf97dd5eb2df483f9c4c578af39dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77b17a89ef54c582ddce585fc3f4051d/" rel="bookmark">
			Apache Httpd报错：AH00558
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【现象】
httpd[1409]: AH00558: httpd: Could not reliably determine the server’s fully qualified domain name, using 127.0.0.1. Set the ‘ServerName’ directive globally to suppress this message
【原因】
httpd配置文件/etc/httpd/conf/httpd.conf中的ServerName配置有问题。
【解决】
#ServerName www.example.com:80
修改为
ServerName www.example.com:80
重启httpd
[root@server conf.d]# systemctl restart httpd
[root@server conf.d]# systemctl status httpd
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/315e1cb0b6d7209044c47739864583ee/" rel="bookmark">
			[ECharts] Component legend is used but not imported.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在vue中用百度ECharts按需导入，报了下图的错误：
报错原因：是使用时，没有导入legend组件！
解决方法：在js区域头部增加导入即可，代码如下
require('echarts/lib/component/legend') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42164693b56709f2e59c9062aff061b2/" rel="bookmark">
			虚拟机使用主机显卡(hyper-v和WSL2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的系统版本WSL2+Ubuntu20.04+CUDA启用WSL2+安装Ubuntu20.04 主机安装WSL Cuda显卡驱动WSL2 Ubuntu安装cuda和cudnncudacudnn安装TensorFlow使用自带测试程序测试keras训练模型参考链接 hyper-v+win10准备iso镜像使用hyper-v安装win10系统使用脚本配置GPU-Pv显卡驱动 hyper-v安装ghost备份文件创建虚拟机新建一个硬盘接着将这个硬盘添加到虚拟机里分区然后还原系统将DVD驱动器移除参考链接 我的系统版本 我更新到了最新的版本，这样可以避免很多不必要的麻烦。
WSL2+Ubuntu20.04+CUDA 启用WSL2+安装Ubuntu20.04 这个很简单，请看：https://blog.csdn.net/RenLJ1895/article/details/122741040
主机安装WSL Cuda显卡驱动 在最新的显卡驱动都已经包含了WSL Cuda驱动，所以显卡驱动已经更新到最新版本，就不用重新安装了。另外：WSL2的Ubuntu系统里不需要再安装任何显卡相关的驱动
我的显卡驱动版本
WSL2 Ubuntu安装cuda和cudnn cuda 这个和再Ubuntu安装没有多大的区别，CUDA安装的命令查看地址：https://developer.nvidia.com/cuda-toolkit-archive
我选择的版本是11.6.0，接着再Ubuntu里面一个一个敲下面的命令等待安装完成。
更新~/.bashrc文件
#把这三行复制到文件底部 export CUDA_HOME=/usr/local/cuda export PATH=$PATH:$CUDA_HOME/bin export LD_LIBRARY_PATH=/usr/local/cuda-11.6/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} #更新一下bashrc文件 source ~/.bashrc #更新一下可能需要的依赖 sudo apt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev #用以下代码检查cuda是否检查成功，注意此处的cuda版本是你在toolkit下载那里决定的，这个版本可能和nvidia-smi显示的版本号不一样，可高可低，这是因为nvidia给cuda开了两个api，这两个api只要差不是太远，基本都可以保证正常运行cuda nvcc -V ubuntu中的nvidia-smi目录再/usr/lib/wsl/lib/nvidia-smi，可以建个软链接到/usr/local/bin下，也可以将这个目录加到环境变量里，任何执行nvidia-smi(这里识别出cuda版本是11.7应该是主机的版本，这个不重要)
cudnn 下载地址：https://developer.nvidia.com/rdp/cudnn-archive (需要登录，下载最新的11.x, 其实就是11.6)
解压到cuda安装目录
#以下是安装命令 tar -zxvf cudnn-自己补全版本号.tgz sudo cp -P cuda/lib64/* /usr/local/cuda-11.6/lib64/ sudo cp cuda/include/cudnn.h /usr/local/cuda-11.6/include/ #为更改读取权限： sudo chmod a+r /usr/local/cuda-11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42164693b56709f2e59c9062aff061b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fa91cc77f26cae9821e19b462700aa1/" rel="bookmark">
			力扣每日一题-第33天-599. 两个列表的最小索引总和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022.7.10今天你刷题了吗？
题目：
假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。
你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。
分析：
给你两个字符串数组，你需要确定里面相同的元素，并且计算相同元素的下标之和，找到下标之和最小的那个，如果有多个最小的，则把那些元素输出。
思路：利用一个哈希表，先把其中一个字符串数组存入，其中键值为字符串，键值对为下标。然后开始遍历第二个字符串数组，每遍历一次就判断当前元素是否存在于map中，如果存在，则计算一下下标和，不存在则不管。
注意：当判断当前的下标最小时，需要把之前的数组内部全部清空，然后再插入，而如果和之前一样都是一样小，则不需要清空直接插入
解析：
1.哈希表
class Solution { public: vector&lt;string&gt; findRestaurant(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2) { unordered_map&lt;string, int&gt;map; vector&lt;string&gt;res={"aaa"}; int minindex = 1000000; for (auto i=0;i&lt;list1.size();i++) { map[list1[i]] = i; } for (auto i = 0; i &lt; list2.size(); i++) { if (map.count(list2[i]) &gt; 0) { //存在相同元素，j为list1中的下标 int j = map[list2[i]]; if (j + i &lt; minindex) { res.clear(); res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fa91cc77f26cae9821e19b462700aa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ff0a7dedd0214c1858214310fea68c2/" rel="bookmark">
			IIS 发布Web网站或接口，提示错误“未能加载文件或程序集“XXXX, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IIS 发布Web网站或接口，提示错误“未能加载文件或程序集“XXXX, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null” 一、产生错误的原因二、解决办法1、修改IIS应用程序池的兼容性2、修改Visual Sstudio 平台属性 一、产生错误的原因 原因分析：Visual Studio 生成的dll文件是32位的，服务器上运行的环境是64位的；
二、解决办法 1、修改IIS应用程序池的兼容性 修改办法： 控制面板-&gt;管理工具-&gt;Internet 信息服务(IIS)管理器-&gt;应用程序池 右键-&gt;高级管理-&gt;启动32位应用程序设置为true。 *这种办法比较常用。
2、修改Visual Sstudio 平台属性 修改办法：如果是32位的就设置为：Any CPU，64位的就设置为x84。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc38d638e946bc947cef41eb5768d5a9/" rel="bookmark">
			深度学习框架(PaddlePaddle)使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机巧围棋使用飞桨(PaddlePaddle) 框架构建并训练阿尔法狗落子策略中的深度神经网络——策略网络和价值网络。
本文讲解飞桨框架的基本使用方法：第1部分介绍神经网络的构建；第2部分讲解神经网络训练过程；第3部分介绍模型权重的保存和加载。
1. 神经网络构建 使用飞桨框架构建神经网络的流程如下：
导入paddle库；定义继承自paddle.nn.Layer的类，在__init__()方法中初始化神经网络的子层（或参数）；重写forward()方法，在该方法中实现神经网络计算流程。 在__init__()方法中初始化神经网络子层的本质是初始化神经网络的参数，不同的子层实质上是不同的部分参数初始化及前向计算流程的封装。下面两种网络构建方式是等同的：
import paddle # 构建方法一：使用飞桨框架内置封装好的子层 class LinearNet1(paddle.nn.Layer): def __init__(self): super(LinearNet1, self).__init__() # 使用飞桨框架封装好的Linear层 self.linear = paddle.nn.Linear(in_features=3, out_features=2) def forward(self, x): return self.linear(x) # 构建方法二：自定义神经网络参数 class LinearNet2(paddle.nn.Layer): def __init__(self): super(LinearNet2, self).__init__() # 自定义神经网络参数 w = self.create_parameter(shape=[3, 2]) b = self.create_parameter(shape=[2], is_bias=True) self.add_parameter('w', w) self.add_parameter('b', b) def forward(self, x): x = paddle.matmul(x, self.w) x = x + self.b return x if __name__ == "__main__": model1 = LinearNet1() model2 = LinearNet2() print('LinearNet1模型结构信息：') paddle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc38d638e946bc947cef41eb5768d5a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/249b2f39f6f068689458db0b9517dac1/" rel="bookmark">
			[TI TDA4 J721E]TIOVX OpenVX Graph Pipelining理解和移植使用（更新版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先感谢阅读，如果您也对TDA4相关的开发感兴趣，我们这边有个学习交流微信群，可以入群和大家一起交流学习。
资历较浅，水平有限，如遇错误，请大家多指正！
保持开源精神，共同分享、进步！
博主WX ： AIR_12 我会拉你入群。
链接：TDA4 相关专栏 链接：TDA4 Demo Gitee开源库
欢迎大家加入，一起维护这个开源库，给更多的朋友提供帮助。
更新时间：2022年06月30日
一、Graph和Pipeline的区别和对比： 1、Pipeline的本质：通过分时复用的方式，提高了硬件的整体利用率，但在本质上，运行单条流水线和运行一次graph的时间是相同的。
2、原有的Graph，如果执行vxProcessGraph，那么graph一旦运行起来，就不允许被打断；且同一个时刻，只有一个核参与整体的graph的处理过程。
3、但是Pipeline，可以实现在graph运行过程中，对关心的数据即通过（graph_parameters_queue_params_list）进行调整，比如图片替换、复制等等。
4、同时，pipeline还允许不同的核在同一个时间，参与到不同流水线的处理过程中。整体上提升了硬件的利用效率。
GraphPipeline是否可打断不可以可以（通过graph_parameters_queue_params_list）硬件同时运行不可以可以（同一个时刻，允许多个核同时运行不同的pipeline的处理） 二、例程说明 本例程以SDK 0800版本为基准，使用 ./apps/dl_demos/app_tidl_od_cam 作为示例。
在app_create_graph 函数内，创建了一下一系列的 node 顺序如下：
节点名称节点主要功能CaptureNode从摄像头获取传感器图像数据VpacVissNode将RAW 数据转换成YUV格式的数据AewbNode实现图像自动白平衡等相关的处理VpacLdcNode对图像进行畸变矫正等VpacMscScaleNode图像缩放处理节点（缩放至训练网络接收的size） ImgPreProcNode
图像预处理节点（将图像数据预处理转换成Tidl模块可以处理的RGB格式等）TIDLNode深度网络，实现目标检测、推理等功能DrawBoxDetectionsNode绘制检测到物体框的节点ImgMosaicNode图像镶嵌节点，将多个图像嵌入到同一个图像内DisplayNode显示节点，将经过镶嵌的图像显示到显示器 其中 VpacVissNode AewbNode VpacLdcNode VpacMscScaleNode ImgPreProcNode
在创建的时候，会使用vxReplicateNode节点进行相应节点的复制。这里我当时的主要疑问是复制了几个这样的节点。
在创建这些node的时候，会传入一个vx_object_array，具体说明参考这里
[TI TDA4 J721E] TIOVX 常用函数详解 之——vxReplicateNode_AIRKernel的博客-CSDN博客
创建的总数量应该是和这个参数包含的成员数量相当。（成员数量=4 ，创建的个数 = 4-1 =3），因为已经创建了一个Node了。
三、graph_parameters_queue_params_list graph_parameters_queue_params_list 必须被设置，这个列表表示在graph运行过程中可以被访问对象的索引。
graph_parameter_index = 0; add_graph_parameter_by_node_index(obj-&gt;graph, obj-&gt;captureObj.node, 1); //将captureNode 的序号为1的参数，加入到 graph_parameters_queue_params_list中 obj-&gt;captureObj.graph_parameter_index = graph_parameter_index; //设置capture节点的 索引 graph_parameters_queue_params_list[graph_parameter_index].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/249b2f39f6f068689458db0b9517dac1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/937bc8fa6b08d0eecbf359c6371416d7/" rel="bookmark">
			Linux应急响应Gscan使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该工具检查项目如下： 1、主机信息获取 2、系统初始化alias检查 3、文件类安全扫描 3.1、系统重要文件完整行扫描 3.2、系统可执行文件安全扫描 3.3、临时目录文件安全扫描 3.4、用户目录文件扫描 3.5、可疑隐藏文件扫描 4、各用户历史操作类 4.1、境外ip操作类 4.2、反弹shell类 5、进程类安全检测 5.1、CUP和内存使用异常进程排查 5.2、隐藏进程安全扫描 5.3、反弹shell类进程扫描 5.4、恶意进程信息安全扫描 5.5、进程对应可执行文件安全扫描 6、网络类安全检测 6.1、境外IP链接扫描 6.3、恶意特征链接扫描 6.4、网卡混杂模式检测 7、后门类检测 7.1、LD_PRELOAD后门检测 7.2、LD_AOUT_PRELOAD后门检测 7.3、LD_ELF_PRELOAD后门检测 7.4、LD_LIBRARY_PATH后门检测 7.5、ld.so.preload后门检测 7.6、PROMPT_COMMAND后门检测 7.7、Cron后门检测 7.8、Alias后门 7.9、SSH 后门检测 7.10、SSH wrapper 后门检测 7.11、inetd.conf 后门检测 7.12、xinetd.conf 后门检测 7.13、setUID 后门检测 7.14、8种系统启动项后门检测 8、账户类安全排查 8.1、root权限账户检测 8.2、空口令账户检测 8.3、sudoers文件用户权限检测 8.4、查看各账户下登录公钥 8.5、账户密码文件权限检测 9、日志类安全分析 9.1、secure登陆日志 9.2、wtmp登陆日志 9.3、utmp登陆日志 9.4、lastlog登陆日志 10、安全配置类分析 10.1、DNS配置检测 10.2、Iptables防火墙配置检测 10.3、hosts配置检测 11、Rootkit分析 11.1、检查已知rootkit文件类特征 11.2、检查已知rootkit LKM类特征 11.3、检查已知恶意软件类特征检测 12.WebShell类文件扫描 12.1、WebShell类文件扫描 该工具支持功能如下: sh-3.2# python GScan.py -h _______ _______.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/937bc8fa6b08d0eecbf359c6371416d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0906d21baad729e55a2be7a592b1b854/" rel="bookmark">
			云原生（二）阿里云服务器突发型、共享型、独享型介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		突发型：共享实例，适用于平时cpu使用不多，但是偶尔会有突发高cpu使用率的场景。
提供的服务：平时限制cpu利用率，如果需要高cpu利用率时，用积分换取cpu资源。创建实例后，持续获得cpu积分。
特点：价格便宜
共享型：适用于一般场景。
提供的服务：和别的共享型实例共通使用空闲 CPU 资源和空闲系统资源。
特点：适中
通用型：也成为独享型，适用于需要长期要求性能稳定、提供可靠计算服务的场景。
提供的服务：通用型(独享)实例的每个 CPU 绑定到一个物理 CPU 超线程上，实例之间无 CPU 资源争抢，实例计算性能稳定且有严格的 SLA 保证。
特点：性能稳定
对初次接触的朋友来说刚开始使用共享型实例是性价比最高的，用于做个人网站、博客、项目等，后期流量达到一定量了再考虑是否升级到通用型(独享)实例。
参考：阿里云ECS共享型、通用型和突发型实例类型有什么区别
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a3bda0e72873f4cb10644938036321/" rel="bookmark">
			JavaScript和TypeScript入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、JavaScript特点二、JavaScript初步（一） 基本语法（二）流程结构1.顺序结构2.选择结构3.循环结构 （三）函数(四) 对象1.创建对象2.MATH对象3.日期对象4.字符串对象 (五) 数组1.创建数组2.元素联合3.数组增删4.截取数组 三、TypeScript简介1.TS配置2.let 和 const3.解构4.函数5.类 总结 前言 JavaScript(Java脚本)是一种基于对象（Object）和事件驱动（ Event Driven）并具有安全性能的脚本语言，使用JavaScript可以轻松的实现与HTML的互操作，并且完成丰富的页面交互效果，它是通过嵌入或调入在标准的HTML语言中实现的，它的出现弥补了HTML的缺陷，是java与HTML折衷的选择。
JavaScript基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。
基于对象：
指的是程序的内部已经为用户提供好了若干个对象，用户直接使用这些对象即可。
面向对象：
java属于面向对象的语言，面向对象是指用户自己定义类，对象需要用户自己产生。
java与JavaScript没有关系。
一、JavaScript特点 1、 解释性
与其他脚本语言一样，JavaScript也是一种解释性语言，它提供了非常方便的开发过程。JavaScript的基本语法结构与C、C++、Java非常相似。
但是在使用之前，与这些语言不同，它们需要先被编译，但是在运行程序的过程中需要逐行解释。javascript与HTML标识符结合使用，方便操作。
2、基于对象
它也可以看作是一种面向对象的语言，这意味着JavaScript可以使用它创建的对象。因此，许多函数可以来自脚本环境中对象方法和脚本之间的交互。
3、简单而弱的类型
它的简单性主要体现在：第一，JavaScript是一个基于Java基本语句和控制流的简单而紧凑的设计，这是一个非常好的过渡，供用户学习Java或其他C语言编程语言。
而对于具有C语言编程能力的人来说，JavaScript非常容易使用，但是其不使用严格的数据类型。
对于JavaScript来说，其语法松散，且在编译阶段并不检查错误，在运行阶段如果有错才会报错。这对于大型的项目来说，编译阶段不报错，在运行的时候才崩溃报错，是很难找出错误的。
4、事件驱动
javascript以事件驱动的方式响应用户。通过在网页中执行操作生成的操作称为事件。例如，按下鼠标，移动窗口，选择菜单等都可以视为事件。
当一个事件发生时，它可能会引起相应的事件响应并执行一些相应的脚本。这种机制称为“事件驱动”。
二、JavaScript初步 （一） 基本语法 变量
变量是对“值”的引用，使用变量等同于引用一个值。每一个变量都有一个变量名。
var a = 1; 上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，也称为将数值1“赋值”给变量a。以后，引用变量a就会得到数值1。最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。
在js中，如果先将a赋值为数值类型，然后再将一个字符串类型赋给它，由于其松散的语法特性，也能够成功运行。
如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个JavaScript关键字，表示“无定义”。
标识符
标识符（identifier）是用来识别具体对象的一个名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript语言的标识符对大小写敏感，所以a和A是两个不同的标识符。
标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript引擎遇到非法标识符，就会报错。
简单说，标识符命名规则如下：
第一个字符，可以是任意字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。
第二个字符及后面的字符，除了字母、美元符号和下划线，还可以用数字。
以下是不符合命名格式的字符
中文是合法的标识符，可以用作变量名。
注意：JavaScript有一些保留字，不能用作标识符：
arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。
操作符
操作符用于数据值，操作符包括算术操作符（如加号和减号）、位操作符、关系操作符和相等操作符等。JavaScript的操作符适用于很多值，例如字符串、数字值、布尔值，甚至对象。在应用于对象时，相应的操作符会调用对象的valueOf()和（或）toString()方法，来取得可以操作的值。
算术操作符 + - * / %
一元加和减操作符主要用于基本的算术运算，也可以用于转换数据类型
一元加操作符以一个加号(+)表示，放在数值前面 应用于数值时，对数值不会产生任何影响
在对非数值应用一元加操作符时，该操作符会像Number()转型函数一样对这个值执行转换
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5a3bda0e72873f4cb10644938036321/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/650eecad8c3dd6caf6ec6493981f56e8/" rel="bookmark">
			C语言后缀表达式还原为中缀表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文提供了C++支持下的C语言后缀表达式还原为中缀表达式。
可供初学者自学，如有出错不吝提出。
/* Updated 2022.7.9 Bug fixed: cannot calculate decimals. comments: change int to float. */ #include&lt;stdio.h&gt; typedef struct{ float data[100]; int top; }SqStack; bool InitStacks(SqStack &amp;S){ S.top = -1; return true; } bool EnStack(SqStack &amp;S, float pushData){ S.data[++S.top] = pushData; return true; } bool CalcElem(SqStack &amp;S,int info){ switch(info){ case '+' : S.data[S.top - 1] += S.data[S.top];S.top--;break; case '-' : S.data[S.top - 1] -= S.data[S.top];S.top--;break; case '*' : S.data[S.top - 1] *= S.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/650eecad8c3dd6caf6ec6493981f56e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fc424ac37113627b2d67aa881d76aa1/" rel="bookmark">
			神州笔记本电脑开机出现CMOS message【已解决】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 配置信息如下
开机出现这个
The CMOS battery is bad or was recent ly replaced.(If you cont inue to see this message, consult the system user 's guide for more information.)
CMOS电池坏了或最近更换过。(如果您继续看到此消息，请参阅系统用户指南以获取更多信息。)
按回车
A first boot or NVRAM reset condition has been detected. (If you cont inue to see this message, consult the system user’s guide for more informat ion.)
检测到第一次启动或NVRAM重置条件。(如果您继续看到此消息，请参阅系统用户指南以获取更多信息。)
按回车
The CMOS defaults were loaded. (If you cont inue to see this message, consult the system user’s guide for more informat ion.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fc424ac37113627b2d67aa881d76aa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5eb3127adcc3eabe43745f7572975ed/" rel="bookmark">
			GeoJSON快速入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GeoJSON (Geo+ JSON ) 这个名字本身就是一个赠品。GeoJSON 是一种使用JavaScript 对象表示法(JSON) 对地理数据结构进行编码的格式。简而言之，GeoJSON 为你提供了一种简单的格式来表示简单的地理特征以及它们的非空间属性。
如RFC 中所述，JSON 被设计为一种轻量级、基于文本且与语言无关的数据交换格式，人类和机器都易于读写。GeoJSON 基本上使用这种设计策略来表示有关地理特征、它们的属性和它们的空间范围的数据。
想看看具体例子吗？
GeoJSON 对象可以定义以下内容：
空间中的几何对象：例如，点、线串或多边形等。特征：特征是空间有界的实体。特征集合： 也称为 FeatureCollection。 1、GeoJSON对象 几何对象表示坐标空间中的点、曲线和曲面。GeoJSON RFC定义了 GeoJSON 对象可以表示的 7 种几何形状“类型” 。它们是“Point”、“MultiPoint”、“LineString”、“MultiLineString”、“Polygon”、“MultiPolygon”和“GeometryCollection”。
点、线串和多边形形状也称为单一类型的几何对象。而 MultiPoint、MultiLineString 和 MultiPolygon 也称为同构类型的多部分 Geometry 对象。
一旦理解了位置的概念，许多这些形状的构造就会变得清晰。
位置是一个基本的几何结构。简单地说，它是一个由 2 个或 3 个数字组成的数组。前两个数字代表经度和纬度（按此顺序）。第三个（可选）数字代表高度或海拔。因此，位置基本上是数组 [经度、纬度、海拔/高度]。
注意：在不同的地理工具或库中，应该是 [longitude, latitude] 还是 [latitude, longitude] 还没有达成共识。例如，Google Maps API 和 Leaflet.js 期望坐标为 [latitude, longitude]，而 GeoJSON、shapefile、D3.js、ArcGIS API 期望坐标为 [longitude, latitude] 格式。因此，请始终注意你的应用程序需要什么顺序。作为参考，可以使用Tom MacWright在他的博客上提供的表格：
所有几何形状都有两个定义该形状的键值对。你可能还在上面看到的示例 GeoJSON 对象中注意到了它们。这两个键是类型和坐标。“type”必须是我们上面看到的七种类型之一，“coordinates”是一个位置值数组。该数组中元素的确切结构由几何类型决定。
1.1 Point 如你所料，如果我们想表示一个 Point 几何图形，我们需要有一个位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5eb3127adcc3eabe43745f7572975ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80fe28f12168927b9448f0e97093e11d/" rel="bookmark">
			Nginx -- 基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx -- 基础 目录结构基本配置最小配置虚拟主机配置反向代理配置负载均衡配置动静分离Url Rewrite配置防盗链 高可用配置https证书配置 目录结构 conf ：存放配置文件相关html ：存放静态文件默认目录html、css等sbin ：nginx的主程序 基本配置 最小配置 worker_processes 1；默认开启一个业务进程worker_connections 1024；单个业务进程可以接收的链接数include mime.types；引入http mime类型deflut_type application/octet-stream；mime类型没匹配上会默认使用二进制流方式传输sendfile on；开启linux的0拷贝keepalive_timeout 65；超时时间 虚拟主机配置 server { listen 80; 监听端口号 server_name localhost; 主机名 location / { 匹配路径 root html; 文件根目录 index index.html index.htm; 默认页名称 } error_page 500 502 503 504 /50x.html; 报错编码对应页面 location = /50x.html { root html; } } 虚拟主机：原本一台服务器只能对应一个站点，通过虚拟主机技术可以虚拟化成多个站点同时对外提供服务server_name：servername匹配分先后顺序，写前面的匹配上就不会继续匹配 完整匹配：同一个servername中可以匹配多个域名 ，server_name a.xxx.com b.xxx.com;通配符开始匹配：server_name *.xxx.com通配符结束匹配：server_name a.xxx.*正则匹配：server_name ~^ [0-9]+.xxx.com$ 反向代理配置 proxy_pass location / { proxy_pass http://atguigu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80fe28f12168927b9448f0e97093e11d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dd8351c66cf2d9593a39e86c816f291/" rel="bookmark">
			解决“无法获得下列许可 solidworks standard无法连接到服务器”的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决“无法获得下列许可 solidworks standard无法连接到服务器”的问题
1、找到安装路径下的文件SolidWorks_Flexnet_Server并打开；
2、先右键以管理员身份运行server_remove，根据提示按任意键退出；
3、再右键以管理员身份运行server_install，根据提示按任意键退出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d6c5fd9f9e32d95205221cf71016e9b/" rel="bookmark">
			Spring中如何获取到一个Bean实例（一）？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关联博文
Spring后置处理器中的InstantiationAwareBeanPostProcessor详解
Spring中Bean实例化过程中的initializeBean方法
Spring中Bean实例化过程中的populateBean方法
Spring中@Autowired与@Resource自动注入实现原理
Spring中如何获取到一个Bean实例？
Spring中如何获取到一个Bean实例（二）？
其实这里想要说的是Spring容器中getBean的原理，也就是当你想从容器中获取到一个Bean时，Spring都做了什么？
如下所示，本文我们以常见的controller实例化过程为例进行分析。
AbstractBeanFactory#getBean(java.lang.String) AbstractBeanFactory#doGetBean 【1】doGetBean AbstractBeanFactory的doGetBean方法是获取到Bean实例的地方，但却不是创建、设置属性、解析依赖及后置处理的地方。这句话比较拗口，这个方法可以认为返回的是一个“处理”后的bean实例，但是其中一些环境比如设置属性、依赖解析是在更深层的的方法进行处理的。
protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException { //处理bean名称，如去掉factoryBean的&amp;前缀，解析别名 final String beanName = transformedBeanName(name); Object bean; // Eagerly check singleton cache for manually registered singletons. // 急切检测单例bean是否正在创建或已经创建--这里涉及到三级缓存、依赖解决 //尝试从一级、二级、三级缓存获取实例， //如果三级缓存获取到则放入二级缓存并从三级缓存移除 Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) { if (logger.isTraceEnabled()) { if (isSingletonCurrentlyInCreation(beanName)) { logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d6c5fd9f9e32d95205221cf71016e9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8b0d96d55c9ed3d9a5308f36c57bb8d/" rel="bookmark">
			vue10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		App.vue
&lt;template&gt; &lt;div id="root"&gt; &lt;div class="todo-container"&gt; &lt;div class="todo-wrap"&gt; &lt;MyHeader @addTodo="addTodo" /&gt; &lt;List :todos="todos" :checkTodo="checkTodo" :deleteTodo="deleteTodo" /&gt; &lt;MyFooter :todos="todos" :checkAllTodo="checkAllTodo" :clearAllTodo="clearAllTodo" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import MyHeader from './components/MyHeader.vue' import MyFooter from './components/MyFooter.vue' import List from './components/List.vue' export default { name: 'App', components: { MyFooter, MyHeader, List }, data() { return { todos: [ { id: '001', title: '抽烟', done: true }, { id: '002', title: '喝酒', done: false }, { id: 'eo3', title: '开车', done: true } ] } }, methods: { //添加一个todo addTodo(todoObj) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8b0d96d55c9ed3d9a5308f36c57bb8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed3e858c456dedf0cdf00810c3d4d8a4/" rel="bookmark">
			神经网络如何利用C语言实现动画?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何利用C语言实现动画? 基于擦除法的C语言动画设计与实现。
Movie design implement in C language base on erasure way。
东华理工学院计算机与通信系　姜林　何月顺　江西　南昌　330013。
摘要：
本文介绍了程序设计语言中动画设计的原理，在C语言中的动画设计常用方法，并提出了在C语言中新的动画设计方法――擦除法。阐述擦除法动画设计的原理，并通过一个具体的实例详细介绍了这种方法的设计实现，文中末尾总结了擦除法动画设计的优点及适用的范围。
关键字：擦除法；C语言；TurboC2.0；动画设计；原理；实现　中图分类号：TP312。方椅365 一键论文降重_就用方椅365
Summary:。
Through the principium of movie design in program design language, the。
thesis present movie design general way in C language, and bring。
forward new movie design way――erasure . The thesis also expatiate。
the principium of erasure way, particular describe the design。
implement of erasure by a instance.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed3e858c456dedf0cdf00810c3d4d8a4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/224/">«</a>
	<span class="pagination__item pagination__item--current">225/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/226/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>