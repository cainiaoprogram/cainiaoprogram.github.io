<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/004cc951d439f398cafd0b9b8adcc887/" rel="bookmark">
			软件设计的七大原则，超详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、开闭原则
1、开闭原则的定义
2、开闭原则的作用
3、开闭原则的实现方法
二、里氏替换原则
1、里氏替换原则的定义
2、里氏替换原则的作用
3、里氏替换原则的实现方法
三、依赖倒置原则
1、依赖倒置原则的定义
2、依赖倒置原则的作用
3、依赖倒置原则的实现方法
四、单一职责原则
1、单一职责原则的定义
2、单一职责原则的优点
3、单一职责原则的实现方法
五、接口隔离原则
1、接口隔离原则的定义
2、接口隔离原则的优点
3、接口隔离原则的实现方法
六、迪米特法则
1、迪米特法则的定义
2、迪米特法则的优点
3、迪米特法则的实现方法
七、合成复用原则
1、合成复用原则的定义
2、合成复用原则的重要性
3、合成复用原则实现的方法
设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中：
开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭。里氏替换原则告诉我们不要破坏继承体系。依赖倒置原则告诉我们要面向接口编程。单一职责原则告诉我们实现类要职责单一。接口隔离原则告诉我们在设计接口的时候要精简单一。迪米特法则告诉我们要降低耦合度。合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。 一、开闭原则 1、开闭原则的定义 开闭原则（Open Closed Principle，OCP）由勃兰特·梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。
开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。
2、开闭原则的作用 开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。
（1）对软件测试的影响：软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。
（2）可以提高代码的可复用性：粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。
（3）可以提高软件的可维护性：遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。
3、开闭原则的实现方法 可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。// 实现方法-&gt;抽象
因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。
下面以 Windows 的桌面主题为例介绍开闭原则的应用。
【例1】Windows 的桌面主题设计。
分析：Windows 的主题是桌面背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的桌面主题，也可以从网上下载新的主题。这些主题有共同的特点，可以为其定义一个抽象类（Abstract Subject），而每个具体的主题（Specific Subject）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的，其类图如下图所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/004cc951d439f398cafd0b9b8adcc887/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a4e831237790099b5a50b35f4680f68/" rel="bookmark">
			ESP32驱动1.28寸GC9A01播放视频（一、视频分辨率的调整和视频格式的转换）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ESP32驱动1.28寸GC9A01播放视频（一、视频分辨率的调整和视频格式的转换） 播放前准备转换视频分辨率用FFmpeg将.MP4转换为.mjpeg格式FFmpeg的win10环境搭建FFmpeg的下载环境变量的搭建 MP4转换成mjpeg格式 总结 播放前准备 1.28寸GC9A01屏幕的分辨率是240x240，所以需要把视频分辨率改成240x240的；而且还需要把MP4格式的视频转换成mjpeg形式的
转换视频分辨率 1、用格式工厂可以自行百度搜索下载（也可以自己用其它的软件转化），下载后点开MP4，、
2、添加相应的MP4文件，可以看到分辨率不是240x240的，然后点击输出配置
3、在屏幕大小后面手动输入240x240，也可以自己选择相应的分辨率，然后确定
3、选择输出的视频路径，然后点击确定
4、点击开始即可输出对应的视频，然后在对应的文件下即可看到对应的文件
用FFmpeg将.MP4转换为.mjpeg格式 我们用的是FFmpeg，如果自己有更好的软件也可以用自己的
FFmpeg的win10环境搭建 我们用的是win10，其它系统环境需要自行百度
FFmpeg的下载 1、打开FFmpeg官网：https://ffmpeg.org，点击Download
2、鼠标放到windos图标上，然后点击第一个下载链接
3、点击ffmpeg-git-ful.7z,会下载一个压缩包，下载之后解压好
环境变量的搭建 1、打开文件里面的bin文件，复制当前路径，
2、打开搜索，输入环境变量，点开编辑系统环境变量
3、点击环境变量
4、找到Path，然后双击
5、点击新建，然后把刚刚复制的路径粘贴好，确定即可
MP4转换成mjpeg格式 1、在刚刚的bin路径下按住“shift”右击鼠标.选择“在此处打开 Powershll 窗口”
2、执行以下命令将mp4文件转换为mjpeg格式
./ffmpeg -i [你的mp4文件路径] -vf "fps=30,scale=-1:240:flags=lanczos,crop=240:in_h:(in_w-240)/2:0" -q:v 9 [输出路径]
比如：
./ffmpeg -i D:\FFOutput\240x240\1.mp4 -vf "fps=30,scale=-1:240:flags=lanczos,crop=240:in_h:(in_w-240)/2:0" -q:v 9 D:\FFOutput\ffmpeg-240\240_30fps.mjpeg
1.mp4是视频名字，需要手动输入，输出的文件名240_30fps.mjpeg也是自己手动输入的
3、点击回车，出现下图表示成功
总结 本篇文章是为了后面ESP32驱动1.28寸屏显示视频做的准备，需要FFmpeg下载包的可以留下邮箱获取，感谢支持
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aca4761b22167cef267f950626427d65/" rel="bookmark">
			jdbc通过kerberos认证连接hive
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pom依赖添加hive-jdbc 根据实际情况添加依赖，主要看服务器hive版本
&lt;dependency&gt; &lt;groupId&gt;org.apache.hive&lt;/groupId&gt; &lt;artifactId&gt;hive-jdbc&lt;/artifactId&gt; &lt;version&gt;2.1.1-cdh6.3.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;*&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 认证文件 配置文件krb5.conf,认证文件krb5.keytab,一般由服务器生成后获取
放到resources目录下
认证方法KerberosAuth.java 指定krb5配置文件：krb5.conf，根据实际情况替换
认证文件：krb5.keytab，根据实际情况替换
认证用户：hive，根据实际情况修改
这里是通过将配置文件和认证文件拷贝到临时目录进行认证，可以根据需要指定固定目录认证
public class KerberosAuth { private static Logger log = LoggerFactory.getLogger(KerberosConnect.class); // kerberos配置文件，从服务上获取 private static String krbConfig="krb5.conf"; // kerberos认证文件 private static String krbKeytab="krb5.keytab"; // kerberos认证用户 private static String krbUser="hive"; private static String tempDir; public static void init(){ initkerberos(); } public static void initkerberos() { log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aca4761b22167cef267f950626427d65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d8afbcd7003fb8a1c1b3c411d641fcc/" rel="bookmark">
			源码----1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring大致概述 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("spring.xml"); UserService userService = (UserService) context.getBean("userService"); userService.test(); 第一行代码，会构造一个ClassPathXmlApplicationContext对象，ClassPathXmlApplicationContext该如何理解，调用该构造方法除开会实例化得到一个对象，还会做哪些事情？第二行代码，会调用ClassPathXmlApplicationContext的getBean方法，会得到一个UserService对象，getBean()是如何实现的？返回的UserService对象和我们自己直接new的UserService对象有区别吗？第三行代码，就是简单的调用UserService的test()方法
​ ClassPathXmlApplicationContext其实已经过时了，在新版的Spring MVC和Spring Boot的底层主要用的都是AnnotationConfigApplicationContext，比如：
AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); //ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("spring.xml"); UserService userService = (UserService) context.getBean("userService"); userService.test(); AnnotationConfigApplicationContext的用法和ClassPathXmlApplicationContext是非常类似的，只不过需要传入的是一个class，而不是一个xml文件
而AppConfig.class和spring.xml一样，表示Spring的配置，比如可以指定扫描路径，可以直接定义Bean，比如：
​
spring.xml中的内容为：
&lt;context:component-scan base-package="com"/&gt; &lt;bean id="userService" class="com.service.UserService"/&gt; AppConfig中的内容为：
@ComponentScan("com") public class AppConfig { @Bean public UserService userService(){ return new UserService(); } } 所以spring.xml和AppConfig.class本质上是一样的。
​
目前，基本很少直接使用上面这种方式来用Spring，而是使用Spring MVC，或者Spring Boot，但是它们都是基于上面这种方式的，都需要在内部去创建一个ApplicationContext的，只不过：
Spring MVC创建的是XmlWebApplicationContext，和ClassPathXmlApplicationContext类似，都是基于XML配置的Spring Boot创建的是AnnotationConfigApplicationContext AnnotationConfigApplicationContext和ClassPathXmlApplicationContext大部分底层都是共同的。
Spring中是如何创建一个对象？ 其实不管是AnnotationConfigApplicationContext还是ClassPathXmlApplicationContext，目前，我们都可以简单的将它们理解为就是用来创建Java对象的，比如调用getBean()就会去创建对象（此处不严谨，getBean可能也不会去创建对象）。
​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d8afbcd7003fb8a1c1b3c411d641fcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38091a7491c3d96670302b9bc246ee64/" rel="bookmark">
			Vue.js报错：Property or method “XXX“ is not defined on the instance but referenced during render. .....
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天学习vue组件的时候发现控制台出现报错，意思是属性或方法没有在实例上定义。然后看了看源码，发现
应该是stuList而不是list，改正后不再报错。
完整代码：
&lt;body&gt; &lt;div id="box"&gt; &lt;my-component :stu-list="list" @delid="doDel"&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;script&gt; Vue.component('my-component', { props: ['stuList'], template: ` &lt;div&gt; &lt;ul&gt; &lt;li v-for="(stu, index) in stuList" :key="index"&gt; {{stu.name}} - {{stu.age}} &lt;button @click="del(index)"&gt;删除&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `, methods: { del: function (value) { this.$emit('delid', value); } } }) var vm = new Vue({ el: '#box', data: { list: [ { name: '张三', age: 20 }, { name: '李四', age: 21 }, { name: '王五', age: 19 } ] }, methods: { doDel: function (value) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38091a7491c3d96670302b9bc246ee64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b6ded5e45fd9b9c612552c464ed5eb7/" rel="bookmark">
			运行python代码时遇到module ‘numpy‘ has no attribute ‘float‘解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 运行python代码时遇到如下问题
module ‘numpy‘ has no attribute ‘float‘ 二、解决方法 出现这种解决方法的原因，主要是因为 np.float 从版本1.24起被删除。但是这里所用的代码是基于旧版本的Numpy。
查看当前的 numpy版本：
（利用安装指令查看当前的 numpy版本）
pip install numpy 反馈结果： Requirement already satisfied: numpy in /home/wong/.local/lib/python3.8/site-packages (1.24.1) # 说明我当前电脑的 numpy 版本是 1.24.1 所以有两种解决方法：
一种是更新当前所用的python代码，使其不使用np.float 。
另一种是将你的Numpy版本降级到1.23.5.
具体步骤：
卸载原来的 numpy pip uninstall numpy 安装1.23.5版本的numpy pip install -U numpy==1.23.5 参考链接 [1] 昔阳z. 遇到module ‘numpy‘ has no attribute ‘float‘ [EB/OL]. https://blog.csdn.net/Yao_Wan/article/details/128767735, 2023-01-26/2023-04-11.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdb149f87b63bf4fbfee2c87e8d8ab0c/" rel="bookmark">
			Gitlab Java API 使用示例（亲测、有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 简介一、依赖、常量Maven依赖定义常量类 二、增删改查1.新增私有仓库2.删除指定仓库3.修改项目简介和是否开源 三、后续更新~ 简介 在开发中，偶尔会有一些关于Gitlab的二开需求，本文将介绍使用Java语言操作Gitlab提供的API，进行仓库的相关操作
GitLab的部署可以查阅docker部署GitLab文章进行搭建
一、依赖、常量 Maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.gitlab4j&lt;/groupId&gt; &lt;artifactId&gt;gitlab4j-api&lt;/artifactId&gt; &lt;version&gt;4.19.0&lt;/version&gt; &lt;/dependency&gt; 定义常量类 可以将常量抽取到配置文件XML中，通过@ConfigurationProperties读取，本文采用常量类方式进行抽取。
public class EduConstants { /** * GitLab远程主机地址 */ public static final String GITLAB_REMOTE_USERNAME = "http://192.168.200.250:9980"; /** * GitLab远程主机密码（自己搭建的时，设计的密码） */ public static final String GITLAB_REMOTE_PWD = "123456789"; /** * gitLab部署远程主机地址（免邮箱注册用户时用到） */ public static final String REMOTE_HOSTNAME = "192.168.200.200"; /** * gitLab部署远程主机用户名 */ public static final String REMOTE_USERNAME = "root"; /** * gitLab部署远程主机密码 */ public static final String REMOTE_PWD = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdb149f87b63bf4fbfee2c87e8d8ab0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/650f0832ef33676db0477fbd1ed3aae7/" rel="bookmark">
			消息队列Pulsar入门(一) 生产者/消费者/Topic详解,附源码演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 对于pulsar的特性以及优异,这里不多讲解,直接上干货,主要讲一下Pulsar的docker部署,生产者/消费者几种 不同模式,以及Topic的使用规则 复制代码 Docker部署pulsar docker run -it -p 80:80 -p 8080:8080 -p 6650:6650 -d apachepulsar/pulsar-standalone 复制代码 部署问题 因为我用的是腾讯云最基础的服务器,在执行docker命令后,发现Pulsar会启动失败或启动不久便停止,查看日志发现是内存顶不住 复制代码 查看官网Pulsar默认启动是2g,因此把启动配置修改成机器支持的即可; docker exec -it pulsar-test sh cd /pulsar/conf/ vim conf/pulsar_env.sh; 之后重启pulsar即可 复制代码 连接Pulsar /** * pulsar 连接bean */ @Bean public PulsarClient getPulsarClient() throws PulsarClientException { return PulsarClient.builder() .serviceUrl("pulsar://Ip地址:6650") .build(); } 复制代码 基础概念了解 Produce 消息的源头,也是消息的发布者，负责将消息发送到 topic。 Consumer 消息的消费者,负责从 topic 订阅并消费消息。 Topic 消息数据的载体，在 Pulsar 中 Topic 可以指定分为多个 partition，如果不设置默认只有一个 partition (这个指定多个partition,我会在文中后面示例演示,可以留意下) Brkber 一个无状态组件,主要负责接收 Producer 发送过来的消息,并交付给 Consumer,可以理解成送快递的小哥 复制代码 Produce详解 创建方式 简单方法创建
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/650f0832ef33676db0477fbd1ed3aae7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f8c9eb0fa2540d9c281c89c733b6e7a/" rel="bookmark">
			如何在webstorm中配置node
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何在webstorm中配置node
Webstorm是一款流行的JavaScript开发工具，它支持多种前端和后端框架，包括node.js。如果你想在webstorm中开发和调试node应用，你需要先进行一些配置。本文将介绍如何在webstorm中配置node的基本步骤。
第一步：安装node.js
要在webstorm中使用node，你首先需要在你的电脑上安装node.js。你可以从官网下载安装包，或者使用nvm等工具来管理不同版本的node。安装完成后，你可以在命令行中输入`node -v`来检查是否安装成功，以及查看当前的node版本。
第二步：配置webstorm的node解释器
接下来，你需要告诉webstorm你安装的node在哪里，以及如何运行它。这就是所谓的配置node解释器。打开webstorm的设置（Preferences），然后在左侧导航栏中找到Languages &amp; Frameworks &gt; Node.js and NPM。在右侧面板中，你会看到一个Node interpreter的选项，点击右边的...按钮来选择你的node路径。一般情况下，webstorm会自动检测到你的node路径，但如果没有，你可以手动选择或者输入。选择好后，点击OK按钮保存设置。
第三步：创建和运行一个简单的node应用
现在你已经配置好了webstorm的node解释器，你就可以创建和运行一个简单的node应用了。首先，在webstorm中创建一个新的项目（File &gt; New &gt; Project），选择Node.js Express App作为模板，并填写项目名称和位置等信息。点击Create按钮后，webstorm会自动为你生成一个基于Express框架的node应用，并安装所需的依赖包。
然后，在项目结构中找到app.js文件，这是你的主要入口文件。你可以在这里编写你的业务逻辑和路由等代码。为了测试一下，我们可以在app.js中添加一行代码来输出Hello World：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d665753ad113387f4f052728a1033bfa/" rel="bookmark">
			X-former系列（Transformer大家族）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Transformer提出大致时间线：
Transformer 分类：
目录
Vanilla Transformer（2017）Reformer（2020.1）Linear Transformer（2020.1）：注意力计算线性复杂度Performer（2020.9）Longformer（2020.4）Informer（2020.12）Autoformer（2021.6）Transformer-XL（2019.1）：引入跨层的循环机制，支持长距离依赖建模Compressive Transformer（2019.11）：增加压缩记忆模块，增长捕捉的语义长度Infinite-former（2021.9）:使用连续空间注意力框架，它的注意力复杂性与上下文的长度无关 1. Vanilla Transformer（2017） 注意力机制：
理想情况下，位置嵌入（Positional Encoding）的设计应该满足以下条件：
它应该为每个字输出唯一的编码不同长度的句子之间，任何两个字之间的差值应该保持一致它的值应该是有界的 相对位置编码（Sinusoidal Position Encoding）：可区别位置关系但无法区别前后关系
绝对位置编码（Learned Positional Embedding）：不同位置随机初始化可学习参数编码
绝对位置编码展开：
2. Reformer（2020） 一个基于局部敏感哈希（LSH）的注意力模型，引入了可逆的Transformer层，有助于进一步减少内存占用量。复杂度从 O(N^2) 降为 O(N logN)，N 为句子长度。
模型的关键思想，是附近的向量应获得相似的哈希值，而远距离的向量则不应获得相似的哈希值，因此被称为“局部敏感”。
并且，标准残差 Layer 替换为可逆残差 Layer，使得训练中只存储一次激活值，而不是 N 次，N 为 Layer 数量。
3. Linear Transformer（2020） 【论文翻译】
这个模型通过使用基于核的自注意力机制、和矩阵产品的关联特性，将自注意力的复杂性从二次降低为线性O(N)。已经被证明可以在基本保持预测性能的情况下，将推理速度提高多达三个数量级。
将softmax attention 线性化： 使用特征图的线性点积来逼近 softmax具有线性复杂度和常数内存的自回归变换器模型 Attention自注意力机制广义公式，Q 和 K 利用相似（sim）函数计算出一个分数，之后除以分数总和获得 Attention 权重，之后去 V 里取值:
接着用核函数 ，对 sim 函数进行处理，再利用结合律，将 Q 运算提出来
简化
4. Performer（2020） 这个模型利用正交随机特征（ORF），采用近似的方法避免存储和计算注意力矩阵。
5. Autoformer Autoformer算法与代码分析_布川酷籽的博客-CSDN博客
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d665753ad113387f4f052728a1033bfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7ed204044dea8e0a9537a53eaec3c72/" rel="bookmark">
			【论文精读】Arxiv 2023 - Segment Anything
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【论文精读】Arxiv 2023 - 分割一切 【论文原文】：Segment Anything
【作者信息】：Kirillov, Alexander and Mintun, Eric and Ravi, Nikhila and Mao, Hanzi and Rolland, Chloe and Gustafson, Laura and Xiao, Tete and Whitehead, Spencer and Berg, Alexander C. and Lo, Wan-Yen and Doll’ar, Piotr and Girshick, Ross
论文：https://arxiv.org/pdf/2304.02643.pdf 代码：https://github.com/facebookresearch/segment-anything 博主关键词：语义分割，少样本，零样本，提示学习
推荐论文：无
摘要 我们介绍了Segment Anything (SA)项目:一个用于图像分割的新任务、模型和数据集。在数据收集循环中使用我们的高效模型，我们构建了迄今为止(到目前为止)最大的分割数据集，在1100万张授权的图像上拥有超过10亿个掩码。该模型被设计和训练为可提示的，因此它可以将零样本迁移到新的图像分布和任务。我们评估了它在许多任务上的能力，发现它的零样本表现令人印象深刻——经常与之前的完全监督结果媲美，甚至更好。我们在https://segment-anything.com上发布了分割任何模型(SAM)和对应的10亿掩模和1100万图像数据集(SA-1B)，以促进对计算机视觉基础模型的研究。
1、简介 在网络规模的数据集上预训练的大型语言模型正在以强大的零样本和少样本泛化彻底改变NLP。这些“基础模型”[8]可以泛化到训练过程中看不到的任务和数据分布。这种功能通常通过提示工程实现，在提示工程中，使用手工制作的文本提示语言模型为手头的任务生成有效的文本响应。当用网络上丰富的文本语料进行扩展和训练时，这些模型的零样本和少样本性能与微调模型(在某些情况下甚至匹配)相比惊人地好[10,21]。经验趋势表明，这种行为随着模型规模、数据集大小和总训练计算而改善[56,10,21,51]。
基础模型也在计算机视觉中进行了探索，尽管程度较轻。也许最突出的说明是将成对的文本和图像从网络上对齐。例如，CLIP[82]和ALIGN[55]使用对比性学习来训练文本和图像编码器，使两种模式对齐。一旦训练完成，工程化的文本提示就能实现对新的视觉概念和数据分布的零样本泛化。这样的编码器还能与其他模块有效地组合，以实现下游任务，如图像生成（如DALL-E[83]）。虽然在视觉和语言编码器方面已经取得了很多进展，但计算机视觉包括了超出这一范围的广泛问题，而且对于其中的许多问题，并不存在丰富的训练数据。
在这项工作中，我们的目标是建立一个基础的图像分割模型。也就是说，我们试图开发一个可提示的模型，并在一个广泛的数据集上使用一个能实现强大泛化的任务对其进行预训练。有了这个模型，我们的目标是利用提示工程解决新数据分布上的一系列下游分割问题。
这个计划的成功取决于三个部分：任务、模型和数据。为了发展它们，我们解决了以下关于图像分割的问题：
什么任务可以实现零样本泛化？什么是相应的模型结构？什么数据可以为这个任务和模型提供动力？ 这些问题错综复杂，需要综合解决。我们首先定义了一个可提示的分割任务，该任务足够通用，可以提供强大的预训练目标，并实现广泛的下游应用。此任务需要一个支持灵活提示的模型，并且可以在提示时实时输出分割掩码，以便进行交互使用。为了训练我们的模型，我们需要一个多样化的、大规模的数据源。不幸的是，没有用于分割的网络规模的数据源；为了解决这个问题，我们构建了一个“数据引擎”，即我们在使用高效的模型来帮助数据收集和使用新收集的数据来改进模型之间进行迭代。接下来，我们介绍每个互连的组件，然后是我们创建的数据集和证明我们方法有效性的实验。
任务。在NLP和最近的计算机视觉中，基础模型是一个很有前途的发展，使用“提示”技术情况下，它可以对新数据集和任务执行零样本和少样本学习。受这项工作的启发，我们提出了可提示的分割任务，其中的目标是在给定任何分割提示的情况下返回有效的分割掩码（见图第1a段）。提示只是指定在图像中分割什么，例如，提示可以包括标识对象的空间或文本信息。有效输出掩码的要求意味着，即使提示不明确，并且可能涉及多个目标（例如，衬衫上的一个点可能指示衬衫或穿着衬衫的人），输出也应该是这些目标中至少一个的合理掩码。我们使用可提示的分割任务作为预训练目标，并通过提示工程解决一般的下游分割任务。
模型。可提示的分割任务和现实世界使用的目标对模型体系结构施加了约束。特别是，该模型必须支持灵活的提示，需要实时计算掩码以允许交互式使用，并且必须具有模糊性。令人惊讶的是，我们发现一个简单的设计满足了所有三个约束：一个强大的图像编码器计算图像嵌入，一个提示编码器嵌入提示，然后将这两个信息源组合在一个预测分割掩码的轻量级掩码解码器中。我们将此模型称为Segment Anything Model或SAM（见图1b）。通过将SAM分离为图像编码器和快速提示编码器/掩码解码器，可以在不同提示下重复使用相同的图像嵌入（并分摊其成本）。在给定图像嵌入的情况下，在web浏览器中提示编码器和掩码解码器从提示预测掩码的时间大约为50ms。我们专注于点、框和掩码提示，并通过自由形式的文本提示显示初始结果。为了让SAM意识到歧义，我们将其设计为预测单个提示的多个掩码，使SAM能够自然地处理歧义，例如衬衫和人的例子。
数据引擎。为了实现对新数据分布的强泛化，我们发现有必要在一组庞大而多样的掩码上训练SAM，超越现有的任何分割数据集。虽然基础模型的一种典型方法是在线获取数据[82]，但掩码并不自然丰富，因此我们需要一种替代策略。我们的解决方案是建立一个“数据引擎”，即我们与模型在环数据集标注共同开发我们的模型（见图1c）。我们的数据引擎有三个阶段：辅助手动(assisted-manual)、半自动(semi-automatic)和全自动(fully automatic)。在第一阶段，SAM帮助标注者标注掩码，类似于经典的交互式分段设置。在第二阶段，SAM可以通过提示可能的对象位置来自动生成对象子集的掩码，标注者专注于标注其余对象，有助于增加掩码的多样性。在最后阶段，我们用前景点的规则网格提示SAM，平均每张图像产生约100个高质量掩码。
数据集。我们最终的数据集，SA-1B，包括来自1100万张许可和隐私保护图像的10亿多个掩码（见图2）。SA-1B是使用我们的数据引擎的最后阶段完全自动收集的，比任何现有的分割数据集[66, 44, 117, 60]有400倍的掩码，而且正如我们广泛验证的那样，这些掩码具有高质量和多样性。除了用于训练SAM的鲁棒性和通用性，我们希望SA-1B成为旨在建立新基础模型的研究的宝贵资源。
负责任的AI。我们研究并报告了使用SA-1B和SAM时潜在的公平性问题和偏见。SA-1B中的图像跨越了地理上和经济上不同的国家，我们发现SAM在不同人群中的表现相似。我们希望这将使我们的工作在现实世界的使用案例中更加公平。我们在附录中提供了模型和数据集卡。
实验。我们对SAM进行了广泛的评估。首先，使用一套新的23个分割数据集，我们发现SAM从单个前景点生成高质量的掩码，通常仅略低于手动标注的真实情况。其次，我们使用提示工程在零样本传输协议下的各种下游任务上发现了一致的强定量和定性结果，包括边缘检测、对象建议生成、实例分割和文本到掩码预测的初步探索。这些结果表明，SAM可以与即时工程一起开箱即用，以解决涉及SAM训练数据之外的对象和图像分布的各种任务。尽管如此，正如我们在第8节中所讨论的那样，仍有改进的空间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7ed204044dea8e0a9537a53eaec3c72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bfc0a5ca1d4558181b7d533f9a1b2b4/" rel="bookmark">
			【遗传算法整数交叉】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遗传算法整数交叉 一、简介二、代码 一、简介 遗传算法及整数编码的内容我就不介绍了（偷个懒），可以参考其他博主的文章。该整数交叉代码来自我本科毕设的部分内容，意在分享自己的思路，也欢迎各位大佬指教。代码注释都在代码中，还是直接举个例子吧，一对整数交叉的基因如下图所示：
在图示父代个体编码串中随机选择一个交叉中点，在交叉中点两侧进行基因交换，同时考虑交换后结果产生基因重复的情况，并做出相应调整，即保证新个体均为有效个体。父代中X1与Y1在交叉中点两侧进行交叉，X1中的3号基因交换后的结果应该是6，但由于X1本身的交叉中点中已包含6号基因，则3号基因的结果就取本身交叉中点中6号基因对应Y1的2号基因，如此查找交换即可得到无重复基因的X2。
二、代码 % @brief Chromosome crossover based on integer coding % @author wszeng % @param X1:Chromosome1 % @param X2:Chromosome2 % @retval chromosomes after crossing X3 and X4 %--------------test--------------------------------------------% clear,clc; X1 = [1 2 3 4 5 6 7 8 9]; X2 = [9 8 7 6 5 4 3 2 1]; %--------------test--------------------------------------------% %function [X3,X4]=cross_operation(X1,X2) %随机生成交叉点 n1 = floor(rand(1,1)*length(X1)+1); n2 = floor(rand(1,1)*length(X2)+1); if(n1 &gt; n2) temp = n1; n1 = n2; n2 = temp; end X3=X1;X4=X2; %初始化后代 for i=1:size(X1,2) %遍历染色体长度 if(sum(ismember(n1:n2,i)) == 1) continue; %保留交叉中点 end %交叉X2 if(sum(ismember(X2(1,n1:n2),X1(i))) == 1) %交叉中点外端与交叉点有基因冲突 index = find(ismember(X2(1,n1:n2),X1(i))); %找X1(i)在X2(1,n1:n2)的位置 X4(i) = X1(n1 + index - 1); %交叉点内无冲突 while(sum(ismember(X2(1,n1:n2),X1(n1 + index - 1))) == 1) index1 = find(ismember(X2(1,n1:n2),X1(n1 + index - 1))); index = index1; X4(i) = X1(n1 + index1 - 1); %交叉中点内有冲突 end else X4(i) = X1(i); %内外无冲突，直接交换 end %交叉X1 if(sum(ismember(X1(1,n1:n2),X2(i))) == 1) %交叉中点外端与交叉点有基因冲突 index = find(ismember(X1(1,n1:n2),X2(i))); %找X2(i)在X1(1,n1:n2)的位置 X3(i) = X2(n1 + index - 1); %交叉中点内无冲突 while(sum(ismember(X1(1,n1:n2),X2(n1 + index - 1))) == 1) index1 = find(ismember(X1(1,n1:n2),X2(n1 + index - 1))); index = index1; X3(i) = X2(n1 + index1 - 1); %交叉中点内有冲突 end else X3(i) = X2(i); %内外无冲突，直接交换 end end %%变量说明 %n1:交叉中点上界 %n2:交叉中点下界 %temp: 互换n1、n2中间变量 %index: 染色体下标索引变量 %index1:染色体下标索引中间变量 然后跑一下试试看吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1aebcd3148936a5c4163c5191dd99f8/" rel="bookmark">
			GPT分区中有活动分区吗？最多支持多少个主分区和扩展分区?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPT和MBR有什么区别?为什么常说UEFI+GPT，UEFI不能和MBR一起用吗?为什么UEFI+GPT装64位win7会出问题?
GPT没有主分区和扩展分区的概念～
简单的说，都是主分区，最多128个(包括一些被系统做了标记，隐藏起来的)。
GPT没有活动分区概念。
UEFI也不依赖活动分区标记。
UEFI可以和MBR一起用，但Windows做了限制，装系统的时候，如果检测到了是UEFI模式，不允许把系统装在MBR分区表的磁盘上。
UEFI+ GPT，装64位Win7，理论上讲，是可以的。事实上，大部分硬件，也的确是可以的。
但是，Win7不支持UEFI里的SecureBoot功能，需要在主板设置里关掉SecureBoot，否则没法启动Win7。现在的预装Win10的电脑，微软要求SecureBoot功能必须在出厂的时候默认开启。
其次，Win7依赖PIC芯片，这需要在UEFI主板的主板设置里打开CSM功能。少部分电脑，比如Surface Pro 3的主板，不支持CSM，Win7会在启动时卡在“正在启动”那个画面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86f3fe7b0611d6a64a96dfe271afdff4/" rel="bookmark">
			现代C&#43;&#43;语言核心特性解析part1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1章　新基础类型（C++11～C++20） 1.1　整数类型long long C++标准中定义，long long是一个至少为64位的整数类型。C++标准还为其定义LL和ULL作为这两种类型的字面量后缀。要强调的是，字面量后缀并不是没有意义的，在某些场合下我们必须用到它才能让代码的逻辑正确，比如下面的代码：
long long x1 = 65536 &lt;&lt; 16; std::cout &lt;&lt; "x1 = " &lt;&lt; x1 &lt;&lt; std::endl; long long x2 = 65536LL &lt;&lt; 16; std::cout &lt;&lt; "x2 = " &lt;&lt; x2 &lt;&lt; std::endl; //x1 = 0 //x2 = 4294967296 这里的65536被当作32位整型操作，在左移16位以后，这个32位整型的值变成了0。在计算x2的过程中，代码给65536添加了字面量后缀LL，这使编译器将其编译为一个64位整型，左移16位后仍然可以获得正确的结果：4294967296（0x100000000）。
和其他整型一样，long long也能运用于枚举类型和位域，例如：
enum longlong_enum : long long { x1, x2 }; struct longlong_struct { long long x1 : 8; long long x2 : 24; long long x3 : 32; }; std::cout &lt;&lt; sizeof(longlong_enum::x1) &lt;&lt; std::endl; // 输出大小为8 std::cout &lt;&lt; sizeof(longlong_struct) &lt;&lt; std::endl; // 输出大小为8 尽量少使用宏，使用numeric_limits类模板获得整形的大小限制：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86f3fe7b0611d6a64a96dfe271afdff4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d6528a30dd28abc6db2284820179238/" rel="bookmark">
			集成学习之Adaboost
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Adaboost 0.参考内容及思维导图链接1.集成学习1.1 思想1.1.1 类比1.1.2 补充概念 1.2 优点1.3 需要关注的问题1.3.1 个体学习器如何训练得到？1.3.2 如何将个体学习器组合？ 1.4 分类1.4.1 对于boosting1.4.2 对于bagging 2.Adaboost2.1 参考资料2.2 思路2.2.1 数学表达2.2.2 基本思路 2.3 算法流程2.3.1 基本流程2.3.2 例题 2.4 加法模型2.4.1 预测函数2.4.2 损失函数的设计 2.5 算法原理2.5.1 需要优化的问题：二分类2.5.2 模型：加法模型2.5.3 最终分类器2.5.4 损失函数：指数损失函数2.5.5 优化方法：前向分步算法 3.四个问题3.1 如何计算学习误差率 e m e_m em​?3.2 如何得到基学习器权重系数 α \alpha α？3.3 如何更新样本权重 w w w?3.4 使用何种结合策略？ 4.小结 0.参考内容及思维导图链接 参考连接：AdaBoost 作者：老弓的学习日记思维导图：https://github.com/QianJoe/Ensemble-Learning 1.集成学习 1.1 思想 集成学习通过构建并结合多个学习器来完成学习任务
1.1.1 类比 三个臭皮匠，顶个诸葛亮
如下图：
1.1.2 补充概念 在集成学习中，学习器相当于模型，又分为强学习器和弱学习器，弱分类器又叫基分类器。
强学习器：可以认为它是一种准确率很高但相对复杂的模型，比如一些神经网络构建出来的模型，它耗费时间精力多，对算力要求高，花费代价高；
弱学习器：可以认为它是一种比较简单的模型，预测效果不太好，如逻辑回归等简单的模型。
总结就是三个臭皮匠顶个诸葛亮
1.2 优点 集成学习通过将多个学习器进行结合，常常可以获得比单一学习器更加显著的优越性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d6528a30dd28abc6db2284820179238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/307ff0b46268f8c61e32e04aea4a0c17/" rel="bookmark">
			【C语言】一维数组-输入10个整数，求其中正数的个数及平均值，精确到小数点后两位。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入10个整数，求其中正数的个数及平均值，精确到小数点后两位。
**输入格式要求："%d" 提示信息："Input integer:"
**输出格式要求："Plus number:%d,average value:%.2f" "Plus number:0,average value: 0"
程序运行示例如下：
Input integer:1
Input integer:2
Input integer:-9
Input integer:8
Input integer:-3
Input integer:3
Input integer:81
Input integer:3
Input integer:0
Input integer:5
Plus number:7,average value:14.71
形式1：
#include&lt;stdio.h&gt; int main() { int i,max=0,plus=0; float av,tol=0; int num[10]={0}; //初始化数组 for(i=0;i&lt;=9;i++) { printf("Input integer:"); scanf("%d",&amp;num[i]);//输入所需的十个数（与0-9 一一对应） } for(i=0;i&lt;=9;i++) { if(num[i]&gt;0) { plus++;//如果数字大于0，正数的个数加一 } } printf("Plus number:%d,",plus); for(i=0;i&lt;=9;i++) { if(num[i]&gt;0) { tol=tol+num[i];//如果数字为正，正数相加 } } av=tol/plus; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/307ff0b46268f8c61e32e04aea4a0c17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec8b7306b5fe65ac4f0ab228b859842d/" rel="bookmark">
			【C语言】逆序数的拆分计算从键盘输入一个4位数的整数，编程计算并输出它的逆序数（忽略整数前的正负号）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 逆序数的拆分计算
从键盘输入一个4位数的整数，编程计算并输出它的逆序数（忽略整数前的正负号）。例如，输入-1234，忽略负号，由1234分离出其千位1、百位2、十位3、个位4，然后计算4*1000+3*100+2*10+1 = 4321，并输出4321。再将得到的逆序数4321拆分为两个2位数的正整数43和21，计算并输出拆分后的两个数的平方和的结果。
以下是程序的输出示例：
Input x:
-1234↙
y=4321
a=43,b=21
result=2290
输入格式:"%d"
输出格式：
输入提示信息："Input x:\n"
逆序数输出格式："y=%d\n"
逆序数拆分后的输出格式："a=%d,b=%d\n"
平方和的输出格式："result=%d\n"
#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main() { int a , b , c, d,m,n,x,y,sum; printf("Input x:\n"); scanf("%d",&amp;x); x = fabs(x); n=x/1000; m=x/100%10; d=x/10%10; c=x%10; a=(c*10+d); b=(m*10+n); y=(c*1000+d*100+m*10+n); printf("y=%d\n",y); printf("a=%d,b=%d\n",a,b); sum=a*a+b*b; printf("result=%d\n",sum); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20d46d8d24f94f4b27050be32978708a/" rel="bookmark">
			深度学习入门代码详解（附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、数据处理 1.1 读入数据
1.2 数据形状变换 1.3 数据集划分 1.4 数据归一化处理
1.5 封装成load data函数
二、模型设计
2.1 训练配置
2.2 训练过程
2.3 梯度下降法
2.4 计算梯度
2.5 使用Numpy进行梯度计算
2.6 确定损失函数更小的点
2.7 代码封装Train函数
2.8 训练扩展到全部参数
三、随机梯度下降法（ Stochastic Gradient Descent）
3.1 数据处理代码修改
3.2 训练过程代码修改
四、总结
波士顿房价预测是一个经典的机器学习任务，类似于程序员世界的“Hello World”。和大家对房价的普遍认知相同，波士顿地区的房价受诸多因素影响。该数据集统计了13种可能影响房价的因素和该类型房屋的均价，期望构建一个基于13个因素进行房价预测的模型，如 图1 所示。
数据下载链接：https://pan.baidu.com/s/1IEuef7z5EZropO-tJUnvbw 提取码：dkmo
图1
对于预测问题，可以根据预测输出的类型是连续的实数值，还是离散的标签，区分为回归任务和分类任务。因为房价是一个连续值，所以房价预测显然是一个回归任务。下面我们尝试用最简单的线性回归模型解决这个问题，并用神经网络来实现这个模型。
线性回归模型
模型的求解即是通过数据拟合出每个和。其中，和分别表示该线性模型的权重和偏置。一维情况下，和 是直线的斜率和截距。 线性回归模型使用均方误差作为损失函数（Loss），用以衡量预测房价和真实房价的差异，公式如下：
思考：
为什么要以均方误差作为损失函数？即将模型在每个训练样本上的预测误差加和，来衡量整体样本的准确性。这是因为损失函数的设计不仅仅要考虑“合理性”，同样需要考虑“易解性”，这个问题在后面的内容中会详细阐述。
线性回归模型的神经网络结构
神经网络的标准结构中每个神经元由加权和与非线性变换构成，然后将多个神经元分层的摆放并连接形成神经网络。线性回归模型可以认为是神经网络模型的一种极简特例，是一个只有加权和、没有非线性变换的神经元（无需形成网络），如 图2 所示。 图2 构建波士顿房价预测任务的神经网络模型
深度学习不仅实现了模型的端到端学习，还推动了人工智能进入工业大生产阶段，产生了标准化、自动化和模块化的通用框架。不同场景的深度学习模型具备一定的通用性，五个步骤即可完成模型的构建和训练，如 图3 所示。
图3：构建神经网络/深度学习模型的基本步骤 正是由于深度学习的建模和训练的过程存在通用性，在构建不同的模型时，只有模型三要素不同，其它步骤基本一致，深度学习框架才有用武之地。 一、数据处理 数据处理包含五个部分：数据导入、数据形状变换、数据集划分、数据归一化处理和封装load data函数。数据预处理后，才能被模型调用。
说明：
本教程中的代码都可以在AI Studio上直接运行，Print结果都是基于程序真实运行的结果。由于是真实案例，代码之间存在依赖关系，因此需要读者逐条、全部运行，否则会导致命令执行报错。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20d46d8d24f94f4b27050be32978708a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6a24ecbbf2db64387a53067993dbf81/" rel="bookmark">
			EMC经典问答85问（75-77问）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		75、某个手持测试产品，可以电池供电，同时也可以采取外置适配器供电方式。适配器单独带负载辐射发射（RE）测试可以通过，手持产品在电池供电情况下辐射发射（RE）也可以通过，并且余量都比较大，但是在带外置适配器的情况下，却在 160M 频率左右超标较多，不能通过认证。是何原因？怎么定位干扰源？耦合途径？定位清楚如何解决？
答：本身这个问题干扰源有两个可能，适配器的开关频率，手持测试产品本身的晶振以及内部的开关电源频率。单独测试没有超标，搭配测试超标说明耦合途径是产品的电源电缆。
定位时可以有多个办法：
1、在电源输出线缆（也就是产品电源输入线）的两端分别加磁环试验，如果靠近适配器相对下降比较大，说明是适配器导致，否则原因就是由手持产品内部干扰源导致；
2、在手持产品的电源输入接口共模电感采取频谱仪测试看那一端干扰幅度大，如果是共模电感里侧的干扰大，则说明是手持产品的干扰；
3、如果怀疑外部适配器，干脆直接替换测试，如果没有这个频点，就说明是适配器问题。
通过上面方法定位后发现，确实是电源适配器问题。尽管开关电源频率只有 KHZ 级别，但往往干扰能够到几十、几百 MHZ，同时电源适配器负载不同，空间辐射发射的测试结果也会不一样。
76、我们做的是一个手持设备，带电池工作在做辐射发射测试时，在 700M 的点超标。回来后我们把辐射源定位在了 10M 的有源晶振和 dsp 的内部 PLL 电路上。首先我们改善了晶振的电源滤波电路，加上了 10uf和 0.1uf 的电容，700M 这个点有明显的降低，但是 800M 点上却上升较多。其次我们更换了直插的晶振为贴片的，以减小其扇出能力，改善效果不大。请问还有其他什么办法可以改进吗？晶振的滤波电路有什么特殊要求？
答：从你描述情况看，本身源头可能是 10MHZ 晶振，或内部的 10MHZ 倍频，对于 700MHZ 或 800MHZ 的高频超标，有几个方面可以处理：晶振处理：供电电源滤波，时钟走线采取 RC 滤波，或用磁珠替代电阻滤波；另外如果能够定位是单板走线对外辐射的话，可以针对对外辐射走线进行滤波，如磁珠、电容；由于超标是高频，很有可能是你的 PCB 单板地阻抗比较大，有较大地地环路，这个方面需要你查看 PCB 设计；另外如果你的设备是金属壳，那可以从屏蔽角度看是否有屏蔽泄漏！如果是接口电缆对外辐射，可以对电缆接口进行滤波处理，具体措施针对不同接口有所不同。
77、经常设计时候没有人提起 EMC，或对 EMC 重视程度不够；开模后或产品定型后有关 EMC 问题就出来了。怎么解决这个问题？
答：这个问题在我们大多企业都会遇到，关键是企业没有一套严格的 EMC 设计流程！大多工程师没有 EMC设计经验，导致工程师没有把 EMC 设计理念融入到产品前期的研发过程中，这样出现问题也就不足为怪了。我们建议企业首先需要培养工程师的 EMC 设计水平，同时提高他们的设计意识，另外更重要的是要建立一套 EMC 的设计流程与平台，比如，需要有 EMC 设计的原理图规范，并有设计检查控制列表，有引导，有监控，那么，EMC 设计在前期才能真正落实，后期的产品出来的 EMC 指标也才有保证！ 这个问题当然还是一个系统问题，涉及范围比较广，结构、电源、硬件电路、PCB 等方面。
下载地址：
https://download.csdn.net/download/u013749113/87622718
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaa2f94acfd506b9203aa783aeb087e1/" rel="bookmark">
			【C语言】猴子吃桃问题。猴第一天摘下若干个桃子，当即吃一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第10天早上再想吃时，见只剩一个桃子。求第一天共摘了多少桃子。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		猴子吃桃问题。猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第10天早上再想吃时，见只剩一个桃子。求第一天共摘了多少桃子。 **输出格式要求："桃子总数=%d\n" 程序运行示例如下： 桃子总数=xxxx【for循环结构】
倒推运算思想
第十天-1个 第9天-（1+1）*2=4 猴子第8天剩（4+1）*2=10 猴子第7天剩（10+1）*2=22 猴子第6天剩（22+1）*2=46 猴子第5天剩（46+1）*2=94 猴子第4天剩（94+1）*2=190 猴子第3天剩（190+1）*2=382 猴子第2天剩（382+1）*2=766 猴子第1天剩（766+1）*2=1534个桃
#include &lt;stdio.h&gt; int main() { int a, i, sum = 1; for (i = 9; i &gt; 0; i--) { sum=(sum+1)*2; a = sum; } printf("桃子总数=%d\n", a); return 0 } #include &lt;stdio.h&gt;
int main()//首先确定变量的个数：需要三个变量，for循环的i，桃子总数，第十天剩下的桃子(赋值为1）
{
int a, i, sum = 1;
for (i = 9; i &gt; 0; i--)//for循环计算-从9-&gt;1.
{
sum=(sum+1)*2;//今天桃数=（明天桃数+1）*2
a = sum;（此句可省略）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaa2f94acfd506b9203aa783aeb087e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6969d7b867f528d066e1f2122dd7034/" rel="bookmark">
			【C语言】从键盘任意输入一个3位整数，编程计算并输出它的逆序数（忽略整数前的正负号）。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 C语言实战题目：从键盘任意输入一个3位整数，编程计算并输出它的逆序数（忽略整数前的正负号）。例如，输入-123，则忽略负号，由123分离出其百位1、十位2、个位3，然后计算3*100+2*10+1 = 321，并输出321。
**输入格式要求："%d" 提示信息："Input x:"
**输出格式要求："y = %d\n"
程序运行示例如下：
Input x:-123
y = 321
#include &lt;stdio.h&gt; #include&lt;math.h&gt; int main() { int a, b, c, sum, num; scanf("%d", &amp;num); printf("Input x:"); num = fabs(num); a =num% 10; b =num% 100 / 10; c =num/ 100; sum= (a * 100 + b * 10 + c); printf("y = %d\n", sum); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/565dbf9193c106d0940a58b49a065c30/" rel="bookmark">
			C语言：逻辑挑战-用C语言验证哥德巴赫猜想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言：逻辑挑战-用C语言验证哥德巴赫猜想
1：什么是哥德巴赫猜想？
哥德巴赫猜想在现代论述为：任一大于5的整数都可以写成3个质数之和。
任一大于2的偶数都可以写成两个质数的和。
2：如何用4-100以内所有偶数来验证哥德巴赫猜想？
只需验证4-100内所有偶数都可以写成两个质数之和。
3：解析+代码如下：
解析：我们只需将4-100中每一个数拆分为a+b的形式，a的范围为2—k/2
如果a和b都是质数的话我们就将其打印出来，说明对于这个数的验证
成功了。
如： 4=2+2
6=3+3
8=3+5
10=3+7=5+5
12=5+7.......
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;Windows.h&gt; int main() { int a, b, i, j, count1, count2; for (i = 4; i &lt;= 100; i+=2) //4-100之内的数用来验证 { for (a = 2; a &lt;= i / 2; a++)//i=a+b { //开始判断a是否为质数 count1 = 0;//在第二层循环内，为count1赋值 for (j = 2; j &lt;= a - 1; j++)//质数的判断方法2-a-1的数除以他本身 { if (a % j == 0) { count1++; break; } } if (count1 == 0)//count1==0说明a是一个质数 { //开始判断b是否为质数 count2 = 0; b = i - a; for (j = 2; j &lt;= b - 1; j++) { if (b % j == 0) { count2++; break; } } if (count2 == 0)//如果b也是质数-循环输出 { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/565dbf9193c106d0940a58b49a065c30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/653348c27a9c2cc3704d9d32ff662c6e/" rel="bookmark">
			【C语言】使用for循环打印菱形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言实战题目:使用for循环打印菱形详解
这是菱形的图案
for循环打印9层的菱形
打印方法-分为上三角形和下三角形来分别打印
1：for循环嵌套
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;Windows.h&gt;
int main()
{
int i, j;
system("color f2");//f-亮白色背景；2-绿色前景
//打印上三角形
for (i = 1; i &lt;= 5; i++)//i控制行数-上面为5行
{
for (j = i; j &lt;= 4; j++)
//内循环1-控制打印的空格数（打印空格数时只需要考虑左边半部分的空格即可）
/*j从i的值开始，表示第几行打印5-i个空格数（如第一行打印4个空格j=1 j=2 j=3 j=4都符合j&lt;=4的条件，打印四个空格）*/
//打印的空格数1-5行依次为4 3 2 1 0
{
printf(" ");
}
//打印*号-打印*号的个数需要计算：1-5行依次为1 3 5 7 9；刚好满足算式2*i-1
for (j = 1; j &lt;= 2 * i - 1; j++)
{
printf("*");
}
printf("\n");
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/653348c27a9c2cc3704d9d32ff662c6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69a7aab24ab0d89fb5f0eac9946967f3/" rel="bookmark">
			Redission入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.15.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加热部署--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;scope&gt;true&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;!--热部署配置--&gt; &lt;configuration&gt; &lt;!--fork:如果没有该项配置,整个devtools不会起作用--&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 2、application.yml配置 spring: redis: database: 1 # Redis使用DB1 timeout: 60000 # 相应超时时间：毫秒 password: admin1234 host: localhost port: 6379 server: port: 8081 3、Redission配置类 /** * @author DeyouKong * @description TODO * @date 2023/3/23 23:34 */ @Configuration public class MyRedissonConfig { @Value(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69a7aab24ab0d89fb5f0eac9946967f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eb718489395eae866af0257544800d1/" rel="bookmark">
			vue中添加在标签上增加动态属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;el-card class="box-card" v-for="item in countData" :key="item.name"&gt; &lt;i class="icon" :class="`el-icon-${item.icon}`" :style="{background:item.color}"&gt;&lt;/i&gt; &lt;div&gt; &lt;p&gt;{{item.value}}&lt;/p&gt; &lt;p&gt;{{item.name}}&lt;/p&gt; &lt;/div&gt; &lt;/el-card&gt; :style="{background:item.color}" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d8b16d82223ef0f5c53d02c99e81c49/" rel="bookmark">
			嵌入式大赛初探之-（1）CH32V307介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为记录贴，记录下本次参加嵌入式大赛的经过，关于RISC-V架构与沁恒系列芯片，新的知识，从最基础学起。 一、沁恒微电子及赤菟开发板 本次嵌入式大赛我选择的是沁恒赛道，利用赤菟CH32V307开发板完成项目。 产品特点
青稞V4F处理器，最高144MHz系统主频
支持单周期乘法和硬件除法，支持硬件浮点运算(FPU)
64KB SRAM，256KB Flash
供电电压：2.5/3.3V，GPIO单元独立供电
多种低功耗模式：睡眠、停止、待机
上/下电复位、可编程电压检测器
2组18路通用DMA
4组运放比较器
1个随机数发生器TRNG
2组12位DAC转换
2单元16通道12位ADC转换，16路触摸按键TouchKey
10组定时器
USB2.0全速OTG接口
USB2.0高速主机/设备接口（480Mbps 内置PHY）
3个USART接口和5个UART接口
2个CAN接口（2.0B主动）
SDIO接口、FSMC接口、DVP数字图像接口
2组IIC接口、3组SPI接口、2组IIS接口
千兆以太网控制器ETH（内置10M PHY）
80个I/O口，可以映射到16外部中断
CRC计算单元，96位芯片唯一ID
串行2线调试接口
封装形式：LQFP64M、LQFP100
性能分析
赤菟CH32V307是沁恒开发的一款基于32位RISC-V指令集的互联型微控制器，外设丰富，用途广泛。可以看到，青稞处理器最高支持144MHz主频，性能对标STM32F4系列，同时比STM系列更加有性价比。
赤菟CH32V307采用沁恒微电子自研的RISC-V青稞内核。赤菟是三国中的一匹战马，像老虎一样凶猛的神驹。兔取菟字意思，解释为老虎，乃是马中的皇者，渡水登山，辅佐英雄；青稞这种植物极其耐寒、适应性广，生命力旺盛，是战马的饲料。
不同于CH32V103系列开发板（几乎是裸板，各类引脚外设需要自行外接设备及定义），赤菟开发板加入丰富的板载外设，可以应用于人机交互，无线传输，工业控制，AIoT等领域。这颗芯片及这块开发板，能带给用户战马般的速度和力量，提升开发体验，作为通用MCU，赋能社区和开发者。
图片：
二、编译环境介绍：MounRiver Studio MRS既可以编译ARM架构，也可以编译RISC-V架构，其内部集成了多种型号芯片的示例代码，因此不需要像keil一样完成复杂的初始化各类文件，直接按照教程即可建立工程。
（1）首先下载安装开发环境-MRS
进入官网下载页面(http://mounriver.com/download)） 下载，具体安装过程省略。注意可以将语言设置为中文。
（2）建立第一个工程
①点击 创建MounRiver Studio
②选择工程所用芯片 CH32V307
③选择 CH32V307VCT6
④编辑工程名
⑤选择工程存放路径
⑥点击 完成
三、MounRiver Studio实例项目分析 #include "debug.h"//包含ch32库文件 接下来是最简单的点灯程序，首先初始化GPIO，如下图，格式类似于STM32标准库，初始化引脚PA0，输出模式为上拉输出。
void GPIO_Toggle_INIT(void) { GPIO_InitTypeDef GPIO_InitStructure = {0}; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d8b16d82223ef0f5c53d02c99e81c49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92126ea5811d359ceb725bc815671bf9/" rel="bookmark">
			matlab进行傅里叶分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		license需求：需要使用到simulink工具包simscape
1.在matlab的command window中输入power_fftscope命令,并按回车键，该操作会打开FFT分析的窗口
2.加载用于FFT分析的数据到matlab worksapce,该数据需要按照一定的格式显示才能被FFT分析窗口自动识别到。
能够识别到的数据格式需要是一个结构体：
该结构体包含三个元素：
time: 一维数组
signals：结构体，该结构体包含五个元素，values(一维或多维数组), dimensions（单个数值，表示values的维度）,lable（字符串）,title字符串）,plotStyle（单个数值）
blockName：字符串
将需要进行FFT分析的数据按照上述格式准备好以后，点击FFT分析窗口的Refresh按钮，会自动识别到需要进行分析的数据
3.进行相应项的设置： 4. 点击Display按钮，显示结果。点击export按钮可以输出matlab figure
示例使用了一个标准的sin波形进行分析sin(2*pi*10),所以FFT出来的结果就只有10Hz的基波，没有谐波。我们对该sin波注入幅值为0.1的5次和7次谐波，0.1*sin(2*pi*50)，0.1*sin(2*pi*70)再次进行FFT分析，能明显的看到五七次谐波的存在。
Y轴表示的含义：当我们Display style选择是Bar(relative to fundamental)时，图形显示的是谐波幅值占基波幅值的百分比大小，基波处（harmonic order = 1）显示就是100，因为除以自身得到的结果就是1，即100%。而五次谐波和七次谐波的幅值是0.1，基波的幅值是1，所以结果是10%，图形在五次和七次谐波处的Y轴就是10。
图形title表示的含义：
图形的title显示的就是基波的幅值大小（Fundamental（10Hz）= 1）,而THD = 14.14%表示的是：
THD（Total Harmonic Distortion），总谐波失真度，表征被输入波形的失真程度，THD数值越大，输入波形的失真越严重。在matlab中定义为信号总谐波的均方根 (RMS) 值除以其基波信号的 RMS 值。这边就是sqrt(0.1^2 + 0.1^2)/sqrt(1^2) = 0.1414。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/341499eb457741a1af26bc118df3c52b/" rel="bookmark">
			正则截取字符串中指定某个字符之前、指定某个字符之后、指定两个字符之间的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.截取指定两个字符之间的内容，如下
let str = 'aaabbbcccddd' str = str.match(/aaa(\S*)ddd/)[1] console.log(str) // 得到bbbccc,如果想截取""之间的内容，也是一样，用 match(/"(\S*)"/)[1] // 比如 let str1 = 'name="xiaoming",age="18"' str1 = str1.match(/"(\S*)"/)[1] console.log(str1) // 得到的是 xiaoming ———————————————— 版权声明：本文为CSDN博主「猛男找1」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/sw_onload/article/details/109194195 2.截取指定字符串之前的内容：
let str1 = 'name="xiaoming",age="18"' str1 = str1.match(/=(\S*)/)[1] console.log(str1) // 得到的是 name 3.截取指定字符串之后的内容：
let str1 = 'name="xiaoming",age="18"' str1 = str1.match(/name=(\S*)/)[1] console.log(str1) // 得到的是 "xiaoming",age="18" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f9b4f0e8a5823d448a67d5a92b0c030/" rel="bookmark">
			虚拟机安装ubuntu窗口自适应问题以及软件窗口显示不全解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这部分查了很多博客，首先感谢前人栽树。
直接上我在安装过程中的有效解决步骤，
文后会描述遇到的非有效解决步骤，以供遇到相同问题的同学参考。
打开终端窗口 (ctrl+alt+t),当然肯定是一条一条的执行。
sudo apt-get update sudo apt-get upgrade sudo apt-get install open-vm-tools sudo reboot 执行完其实我发现没用，后来又试着从这调了一下分辨率，结果可以，完美解决。
右键，然后红框位置，然后调节到合适的分辨率。
有可能直接调分辨率或许也可以，但就像《三体》中说的，或许就是下午的一杯咖啡也会影响晚上对天体的观测。也懒得验证前面的命令有没有用了。
过程中遇到的问题。
1、一开始想尝试的
Guest” --&gt; "Install/Upgrade VMware Tools
即虚拟机 --&gt; 安装VMware Tools(T)
等等等等步骤
记得以前安装的时是这个方法，但这次在搜索过程中有人说现在这种方法不太好了
现在都用open-vm-tools
2 然后我就用这个方法但遇到这个问题
理论上可能直接写这个命令就可以的，但可能需要更新一下。
然后就想着更新一下，结果没加sudo,又卡住了。
不够专业，还请指教。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89d2b381699c7b0383a97e49afae834d/" rel="bookmark">
			如何学习计算机视觉？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI的专业领域知识是指AI与具体应用领域相结合时所需要的该应用领域的知识。AI的应用领域非常广泛，例如计算机视觉、智能交通、智能制造、智慧金融、智慧教育、智慧农业、智慧能源、智能通信、智能芯片等。本文主要介绍计算机视觉的基本概念、发展历程、主要研究内容、常用教材、学习路线等方面的内容。
1. 基本概念
计算机视觉（Computer Vision）是指用计算机和摄像头实现人的视觉功能，即实现对客观世界的三维场景的感知、识别和理解等。计算机视觉是AI中非常热门的一个研究领域，已经有一些比较成熟的应用，例如人脸识别、车牌识别、装配机器人等。计算机视觉仍然是一个朝气蓬勃的学科，还有大量的问题没有解决，需要广大的人员进行研究，例如人眼底层视觉信号的传感和作用机制深度解析、图像的高级语义识别及理解等。
一个计算机视觉系统的组成部分通常包括：光源、摄像头、数据传输线、计算机、执行机构等。光源的作用是为物体打光，提高成像质量；摄像头实现现场图像的采集；数据传输线将采集到的图像或视频传送给计算机；计算机对图像或视频进行分析和处理，根据计算的结果进行决策；执行机构负责执行计算机的决策。图 5‑1显示了一个对特种砖表面缺陷进行检测的计算机视觉系统的示意图，该系统由光源、摄像头、数据传输线、计算机、机械手、传送带等几部分组成。摄像头会对传送带上的特种砖进行拍照，如果计算机检测出特种砖有缺陷，则会启动机械手将特种砖从传送带上取下来。
图 5‑1 对特种砖进行检测的计算机视觉系统示意图
2. 发展历程
计算机视觉的发展大致经历了如下几个阶段。
(1) 学科领域的开创
1977年David Marr在MIT人工智能实验室提出了计算机视觉理论，这是与 Lawrence Roberts当初引领的积木世界分析方法截然不同的理论。计算机视觉理论成为80年代计算机视觉重要理论框架，使计算机视觉有了明确的理论体系，极大地促进了计算机视觉的发展。1982年David Marr的《Vision》一书的问世，标志着计算机视觉成为了一门独立学科。该书在心理学基础上，建立了图像图形特征的数学模型，提出了图像边沿特征与边沿检测算法、光流与纹理特征的概念、图像特征匹配和立体视觉的概念、运动理解和目标表面三维重建的设想，引入了目标识别的理念。
(2) 先驱研究
以傅京孙（King Sun Fu）、黄煦涛（Thomas S. Huang）、Azriel Rosenfeld、Olivier Faugeras、J. K. Aggarwal、N. Ahuja为代表的先驱们在图像特征提取、图像特征匹配、三维重建、三维定位、三维运动分析等计算机视觉的新领域进行了开创性的研究，极大地促进了计算机视觉学科的发展壮大。这一时期的研究主要采用视觉几何的方法进行研究，其理论基础包括射影几何、多视图几何等。
(3) 发展成熟
这一时期计算机视觉在图像标注、图像检索、人脸识别、人体三维运动分析、动作识别、场景语义理解、虚拟现实、增强现实等多个研究方向取得突破性进展，部分计算机视觉成果开始进行实际应用的尝试，如人脸识别、场景目标分析、工业部件检测等，但是在错检率、漏检率、测量精度等方面还需要做进一步改进。这一时期主要采用视觉学习的方法进行研究，即机器学习技术被广泛应用于解决计算机视觉中的问题。
(4) 部分技术取得大范围的应用
这一时期深度学习框架TensorFlow、Pytorch、Keras、Caffe等得以发布和不断完善，深度学习的使用门槛越来越低，使用深度学习框架越来越方便。深度学习技术极大地提升了计算机视觉算法的性能，特别是基于无监督学习的算法。基于深度学习的计算机视觉技术使得某些领域的应用开始大范围的落地，创造了重大的经济价值，受到了政府部门的高度重视，例如人脸识别技术的广泛应用等。近些年来，计算机视觉技术的成功应用案例越来越多。这一时期主要采用视觉计算的方法进行研究，即基于深度学习的框架对大量的视觉数据进行计算，从而实现算法性能的提升。
3. 主要研究内容
计算机视觉的研究内容庞杂，要清晰明了地说清楚其研究内容是非常困难的。根据个人的理解，做一下简明扼要的阐述，以便读者对整个计算机视觉的研究领域有更清晰的了解。
根据所使用的摄像机的数目，可以将整个计算机视觉领域分为：单目视觉、双目视觉、结构光视觉、多目视觉。下面分别加以介绍。
单目视觉只使用一个摄像机或摄像头进行图像采集。单目视觉的研究内容包括：图像滤波、图像增强、二值图像处理、边缘检测、轮廓分析、图像分割、目标检测、物体识别等。图 5‑2显示了一个用于啤酒瓶瓶口缺陷检测的单目视觉系统的示意图，啤酒瓶被摆放在传送带上运输，当定位器检测到啤酒瓶到达摄像机正下方时会启动摄像机对啤酒瓶进行拍照，并将拍摄的照片传送给计算机进行分析。如果啤酒瓶没有检测出缺陷，则通过传送带；否则，则会被机械装置从传送带上取下。
图 5‑2 单目视觉系统示例
双目视觉使用两个摄像机或摄像头对场景中的物体进行拍摄，所采集的数据主要用于三维视觉的分析。双目视觉的研究内容主要包括：基于双目视觉的物体定位、尺寸检测、三维匹配、三维重建、运动分析、目标跟踪等。大部分情形下，单目视觉系统只能获得物体的二维信息，也就是只能计算出物体的平面坐标；双目视觉系统、多目视觉系统、结构光视觉系统则能够获得物体的三维信息，即可以计算出物体的三维空间坐标。简单点说，在通常情形下，要获得物体的三维信息至少要两个摄像机，或者用一个摄像机再加上结构光。如果你只用一个眼睛看世界就无法感觉到物体离你的距离，这就是单目视觉在通常情形下无法获得三维信息的最好例证。人之所以有两只眼睛，就是为了获得物体的三维信息。图 5‑3显示了两个双目视觉系统的实例，该系统为一个手术机器人系统，通过两个摄像头对人手持的石膏仿制的腿骨进行三维空间的跟踪和定位。
图 5‑3 双目视觉系统实例:手术机器人
结构光视觉基于光学三角法测量原理，一般使用一个摄像机或摄像头，再加上一个结构光投射器。如图 5‑4所示，结构光投射器将一定模式的结构光投射于物体表面，同时由处于另一位置的摄像机或摄像头对物体和结构光的图像进行采集,采集的信息被传送给计算机进行处理，可以获得物体的三维信息。结构光视觉也是一种3D视觉的分析模式，其主要研究内容包括：基于结构光视觉的物体定位、尺寸检测、三维重建等。
图 5‑4 结构光视觉系统示例
多目视觉由多个摄像机或摄像头（数目通常多于2个）对场景中的物体进行拍摄，所采集的图像数据被用于3D视觉的分析。其主要研究内容包括：基于多目视觉的物体定位、尺寸检测、三维匹配、三维重建、运动分析、目标跟踪等。图 5‑5显示了一个运用多目视觉技术进行人体运动分析的例子。通过在人体周围布置一圈摄像头，对场景中的人进行拍摄，运用计算机视觉技术构建出人体的三维模型，对人体的运动姿态和模式进行分析。
图 5‑5 多目视觉系统示例
对前文进行总结，将计算机视觉各领域的主要研究内容总结于图 5‑6中，方便读者理解。
图 5‑6 计算机视觉的主要研究内容
4. 常用教材推荐
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89d2b381699c7b0383a97e49afae834d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa6db588c10e63fadd525fbfc83e4c35/" rel="bookmark">
			INS-06006错误处理（oracle11.2.0.4）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两节点执行
[root@host03 /]# ls -ld /usr/bin/ssh
-rwxr-xr-x. 1 root root 405800 Nov 21 2013 /usr/bin/ssh
[root@host03 /]# ls -ld /usr/bin/scp
-rwxr-xr-x. 1 root root 59456 Nov 21 2013 /usr/bin/scp
[root@host03 /]# ln -s /usr/bin/ssh /usr/local/bin/ssh
[root@host03 /]# ln -s /usr/bin/scp /usr/local/bin/scp
[root@host03 /]# ls -l /usr/local/bin
total 0
lrwxrwxrwx 1 root root 12 Apr 11 14:01 scp -&gt; /usr/bin/scp
lrwxrwxrwx 1 root root 12 Apr 11 14:01 ssh -&gt; /usr/bin/ssh
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa6db588c10e63fadd525fbfc83e4c35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/309ed1cb1e87b7a64b9d0729df05038a/" rel="bookmark">
			ChatGPT常用的指令（prompts）系列六
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 内容翻译自：https://github.com/f/awesome-chatgpt-prompts，并加入自己的实践内容
1、 ChatGPT常用的提示语（prompts）系列一
2、 ChatGPT常用的提示语（prompts）系列二
3、 ChatGPT常用的提示语（prompts）系列三
4、 ChatGPT常用的提示语（prompts）系列四
5、 ChatGPT常用的提示语（prompts）系列五
文章目录 系列文章目录21、担任影评人（Act as a Movie Critic）22、担任关系教练（Act as a Relationship Coach）23、扮演诗人（Act as a Poet）24、 扮演说唱歌手（Act as a Rapper） 21、担任影评人（Act as a Movie Critic） 英文原文
I want you to act as a movie critic. You will develop an engaging and creative movie review. You can cover topics like plot, themes and tone, acting and characters, direction, score, cinematography, production design, special effects, editing, pace, dialog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/309ed1cb1e87b7a64b9d0729df05038a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e13d8d32e7f8cd80eece14f28363e9d/" rel="bookmark">
			分享 20 道关于 React 开发相关的面试题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React 面试可能你会觉得有点吓人，为了帮助您自信并准备好迎接下一次面试，我们列出了 20 个常见的 React 问题和参考答案。
希望通过本篇文章的内容，能够帮助你重新温习你的 React 知识，复习重要概念，并为你的下一次面试做好更充分的准备，展示你的自信。
那么，让我们开始吧！
React JS 面试问题和答案——练习测试
1. 你能解释一下什么是 React 以及它与其他 JavaScript 框架的区别吗？
React 是一个用于构建用户界面的 JavaScript 库。它的独特之处在于它使用虚拟 DOM 来有效地更新 UI，从而可以更快、更轻松地处理 UI 的更改。
React 不同于其他 JavaScript 框架，因为它只关注应用程序的视图层，可以更好地与其他库和框架集成。
2. 你能解释一下 React 中虚拟 DOM 的概念吗？
React 中的虚拟 DOM 是实际 DOM 的轻量级内存表示。React 更新虚拟 DOM 而不是实际 DOM，并且只更新 DOM 中发生变化的部分，这使得它比更新整个 DOM 的其他库或框架要快得多。
通过仅更新已更改的内容，React 确保 UI 对用户保持响应和快速，即使有大量更新。
3. React 的主要特点是什么？
组件：可以组合以构建复杂 UI 的可重用 UI 元素。
虚拟 DOM：实际 DOM 的虚拟表示，可提高性能。
JSX：一种语法扩展，允许您在 JavaScript 中编写类似 HTML 的代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e13d8d32e7f8cd80eece14f28363e9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/596526afc2f4a333ce64b8164d33d3f0/" rel="bookmark">
			matlab系统辨识工具箱及其反向验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统辨识工具箱
什么时候使用系统辨识，当系统传递函数不确定(在多大程度上不确定？)时，通过对输入输出数据采集，通过数学迭代找到控制对象的近似模型。在找到近似模型(传递函数)后，就可以使用线性化调参工具对系统控制参数进行整定，进行控制系统设计。
调用命令：systemIdentification
一般过程：
将数据数组从matlab工作区导入程序；
绘制数据；
数据归一化；
估计、验证、 线性模型；
模型导出到工作区
1输入输出数据的导入和处理
数据导入过程中，采样时间设置为真实系统的仿真时间
在more中的次级菜单可设置导入信号的名称和单位，如果是多路信号，这一步就很重要了。
数据处理操作，可在process菜单中选择quick start选项，即可生成归一化后的输入和输出数据，并且划定了训练集和验证集。
2进行模型估计。同样可以使用quick start操作生成阶跃响应图imp、频率响应图spad、状态空间n4s3和多项式模型arxqs的输出，然后可以在模型输出modeloutput窗口窗口对比验证效果。
未生成spad模型的适应度值。
右键可查看模型相关信息。
除此之外，还可以使用基于其他算法的计算模型。
多项式方程。
编辑Orders字段以尝试极点、零点和延迟的所有组合，其中每个值都从 1 到 10：
点击estimate，
该窗口有3个突出显示部分：
图中以绿色、蓝色和红色突出显示了三个矩形。每种颜色表示一种最佳拟合标准，如下所示：
红色——最佳拟合最小化验证数据输出和模型输出之间的差异的平方和。此矩形表示整体最佳拟合。
绿色 - 最佳拟合最小化了 Rissanen MDL 标准。
蓝色 — 最佳拟合最小化 Akaike AIC 标准。
基于MDL和AIC的标准补偿了因使用过多参数而导致的过拟合问题。
选择绿色图块对应的参数，insert，适应度为arx342所示。
对于estimate中的识别顺序其实是很关键的，因为实际中许多要辨识的系统特征（零极点分布状况）是未知的，所以不能一开始就选择传递函数模型进行辨识。
在使用利用多项式辨识过程中，得到了三种评估标准下的模型零极点个数，为后续其他数据模型辨识提供了基础。在上述ARX模型中，最终最佳拟合的模型分布为极点个数为3，零点为4，延迟为2。
下面就基于上述零极点分布情况对传递函数进行估计。
根据上上面估计后得到的零极点个数可以预设传递函数极点状况（3 4 2），不过零点个数保留系统默认值1，延迟环节换算公式为（样本延迟nk=2）转换为连续时间延迟为（nk-1）*Ts
拟合度如图，这比直接进行传递函数估计要来的准确。
下面使用状态空间模型估计，同样是基于多项式估计的基础，全体最佳拟合度极零点分布（3 4 2），估计时仅需给定阶数（极点个数）即可。
Focus设置为模拟输出。当然，这个选项也可以在拟合度窗口进行统一设置。
还可以使用ARMAX模型进行系统模拟，它比ARX更灵活，其结构中包含一个额外的多项式来模拟附加性扰动。
设置结构列表。
前述使用ARX估计最佳拟合极零点分布为3 4 2，可以从这些数目组合开始，最后再加上一列。
从2 2 2 2开始。
3 3 3 3
3 3 3 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/596526afc2f4a333ce64b8164d33d3f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6ccb4c404e91b91aaab804203c2c5d2/" rel="bookmark">
			ES核心干货学习（原理及数据结构）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要为帮助大家理解ES原理，了解它为啥快，简化部分内容便于理解。 1. ES用途 1.1 ES是什么？ ES是建立在Lucene基础之上的分布式准实时搜索引擎。
核心：分布式和Lucene全文搜索。
1.2 什么场景需要用ES 1. 业务需要进行大量数据实时检索时，传统关系型数据库无法支撑。
2. 需要进行分词检索，语义检索
3. 需要大数据分析
符合上面特征都可以考虑，如日志收集、订单数据链查询，文章检索等。
1.3 为啥选ES 1. 能支持千万级亿级的实时检索。
2. 支持restful API接口，使用门槛低。
3. 分布式，可扩展。
4. 在OLAP场景下与市面上现有竞品（不包括ClickHouse）相比有明显性能优势。
5. 与ClickHouse相比主要是运维优势和用户基础，云服务平台支持较好，减低个人或公司的运维成本。
2. ES安装 后续补上
3. ES基础概念 3.1 数据结构 类型
说明
举例
与Mysql逻辑对应
index
索引（自定义）
test
表名
doc
行
行
field
具体字段名，又称域（自定义）
name
字段名称
type
字段类型（ES定义）
text、keyword、integer
字段类型
1.索引
在ES中用户的数据新增、搜索和更新等操作的对象全部对应索引。但是ES中的索引和Lucene中的索引不是一一对应的。ES中的一个索引对应一个或多个Lucene索引，这是由其分布式的设计方案决定的，在使用上类似Mysql表的概念。
2.文档
文档对应关系型数据库中行的概念，ES的文档中可以有一个或多个字段，每个字段可以是各种类型。用户对数据操作的最细粒度对象就是文档。ES文档操作使用了版本的概念，即文档的初始版本为1，每次的写操作会把文档的版本加1，每次使用文档时，ES返回给用户的是最新版本的文档。另外，为了减轻集群负载和提升效率，ES提供了文档的批量索引、更新和删除功能。
3.字段
一个文档可以包含一个或多个字段，每个字段都有一个类型与其对应。除了常用的数据类型（如字符串型、文本型和数值型）外，ES还提供了多种数据类型，如数组类型、经纬度类型和IP地址类型等。ES对不同类型的字段可以支持不同的搜索功能。例如，当使用文本类型的数据时，可以按照某种分词方式对数据进行搜索，并且可以设定搜索后的打分因子来影响最终的排序。再如，使用经纬度的数据时，ES可以搜索某个地点附近的文档，也可以查询地理围栏内的文档。在排序函数的使用上，ES也可以基于某个地点按照衰减函数进行排序。
3.2 存储结构 1.集群和节点
在分布式系统中，为了完成海量数据的存储、计算并提升系统的高可用性，需要多台计算机集成在一起协作，这种形式被称为集群，这些集群中的每台计算机叫作节点。ES集群的节点个数不受限制，用户可以根据需求增加计算机对搜索服务进行扩展。
要检查群集运行状况，我们可以在 Kibana 控制台中运行以下命令 GET /_cluster/health，得到如下信息：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6ccb4c404e91b91aaab804203c2c5d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f508743f01b28faaad7c6809c820faf3/" rel="bookmark">
			使用mybatis plus实现多表查询操作，（无需xml）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是一些使用 QueryWrapper 实现多表操作的例子：1. 多表关联查询
```java
// User 和 Role 是多对多关系，使用中间表 user_role
public List&lt;User&gt; getUserListByRoleId(Integer roleId) {
QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();
wrapper.select("user.*").distinct()
.from("user")
.leftJoin("user_role").on("user.id=user_role.user_id")
.eq("user_role.role_id", roleId);
return userMapper.selectList(wrapper);
}
```
上面的代码实现了查询拥有指定 roleId 的所有用户信息。
2. 多表关联查询并排序
```java
public List&lt;User&gt; getUserListOrderByRoleName() {
QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();
wrapper.select("user.*").distinct()
.from("user")
.leftJoin("user_role").on("user.id=user_role.user_id")
.leftJoin("role").on("user_role.role_id=role.id")
.orderByAsc("role.name");
return userMapper.selectList(wrapper);
}
```
上面的代码实现了查询所有用户信息，并按照角色名称升序排序。
3. 多表关联查询并分页
```java
public IPage&lt;User&gt; getUserListByPage(Integer roleId, Integer pageNum, Integer pageSize) {
QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f508743f01b28faaad7c6809c820faf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0f65f23530333a1c8fd4957d366448e/" rel="bookmark">
			Nginx 中常见 header 配置及修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 nginx 中，经常需要因为各种原因，修改 header，所以今天整理下 nginx 中 header 的一些指令
header 是 http 中的消息头，里面包含很多信息，通常又分为 request headers(请求头)和 response headers(响应头)
客户端向服务器发送的请求中包含请求头，服务器向客户端回复的响应中包含响应头，消息头通常是以冒号分隔的键值对
在 nginx 中有 headers 模块，其中有三条指令，分别是：
add_header
add_trailer
expires
expires 就不用多说了，用来控制缓存时间的，证书就是缓存的时间，0 或负数就是缓存无效
add_trailer 和 add_header 一样的效果，都是在 headers 中添加字段，不过 trailer 是添加到响应头的末尾
nginx 中通常就通过这三个控制 response 的 headers 信息
另外涉及到 headers 修改的指令，通常是在反向代理的时候，也就是 proxy_pass 的时候，有以下几个指令可以操作 header
proxy_set_header
proxy_ignore_headers
proxy_pass_header
proxy_hide_header
proxy_pass_request_headers
proxy_set_header 通常用的最多，可以在提交给上游服务器的 header 中添加或重写 header，比如通常用到的，反向代理的时候，添加客户端 IP、XFF 等字段
proxy_ignore_headers 通常用来禁用上游服务器的某些响应字段，如：
X-Accel-Expires
Expires
Cache-Control
Set-Cookie
Vary
X-Accel-Redirect
X-Accel-Limit-Rate
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0f65f23530333a1c8fd4957d366448e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6acd62296011e8494bfb274a5e6086f/" rel="bookmark">
			LSTM 易用代码 (pytorch)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文意在飞速使用LSTM，在数学建模中能更加快速。数据输入支持一维数据（单变量预测）或者为二维数据（多变量同时预测）。包含置信区间的计算。推荐使用 jupyter，因为可以保存训练步骤，重写画图代码更加便捷。
完整代码下载链接
数据输入 api def data_basic(): """2023美赛C：https://www.pancake2021.work/wp-content/uploads/Problem_C_Data_Wordle.xlsx""" date, data = Utils.openfile("Problem_C_Data_Wordle.xlsx", data_col=[1], date_col=0) return date, data def data01(): # 测试二维数组多变量 data1 = np.sin(np.arange(300) * np.pi / 50) + np.random.randn(300) * 0.1 data2 = np.sin(np.arange(300) * np.pi / 25) + np.random.randn(300) * 0.1 + 3 return np.c_[data1[:, np.newaxis], data2[:, np.newaxis]] def data02(): # 测试一维数组 return np.sin(np.arange(300) * np.pi / 50) + np.random.randn(300) * 0.1 def data03(): # 测试二维数组单变量 return data02()[:, np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6acd62296011e8494bfb274a5e6086f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6245e7602215eb70cb4e21ed35935405/" rel="bookmark">
			Python的界面神器Streamlit初使用,一个漂亮的界面有多简单,超乎想象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python的界面神器Streamlit初使用,一个漂亮的界面有多简单,超乎想象 废话不多说,直接上干货
首先安装好所需要的库 pip install streamlit 新建一个 Python 文件(test.py)，导入所需要的库， import streamlit as st import pandas as pd 打开命令，行输入命令， streamlit run test.py 启动服务，可以看到输出信息证明已经成功启动了一个服务，浏览器会自动打开这个地址。
现在页面什么东西都没有，加一句代码，打印一些文字
import streamlit as st import pandas as pd st.text("走过路过不要错过") 保存文件，此时页面右上角出现了一些选项按钮，选择总是返回，回到代码修改内容，现在页面可以自动刷新了。
接下来添加一个文件上传的组件参数type，指定接受的文件后缀名可以指定多种文件类型，所以是一个列表函数返回的是一个文件对象。我们可以直接使用 Pandas 读取数据，然后试试输出到界面上，这里有一个快捷方式，直接把变量 df写在这里，就会在界面上显示成一个表格。不过保存文件后发现页面出现报错信息。
uploaded_file = st.file_uploader('excel文件',type=['xlsx']) df = pd.read_excel(uploaded_file) st.dataframe(df) streamlit每次页面更新都会执行一遍代码，我们还没有选择任何文件，所以文件上传组件的函数返回了一个None，到了 Pandas 加载数据就会报错。
这里要划重点了。 streamlit与其他框架非常不一样的地方就在于，我们写的代码就像一个描述了整个界面的文档， streamlit 每次都要从头到尾执行一次，才能知道画面上应该描绘出哪些内容。因此每当调用一个组件函数，就要注意判断空的情况。这里在上传组件函数之后，判断返回的文件对象是否有东西。这里有一个技巧，逻辑，尽可能描述空的情况下，然后跳出执行有专门的函数 stop 做这个事情，这样可以避免我们的代码出现大量的判断嵌套。
uploaded_file= st.file_uploader('excel文件',type=['xlsx']) if uploaded_file is None: st.stop() 选择一个文件看看效果，可以正常显示。接着我们让 Pandas 一次性加载所有的工作表，不需要直接显示数据，而是做一个下拉列表框，让用户选择工作表名字，看看页面效果。
为了让大家更好理解其过程，我们再次分解其显示过程。第一次执行时，上传文件组件函数由于没有选择任何文件，所以返回了none，从而在下面的判断中执行了stop。因此这次执行只收集到上传文件组件的描绘，页面只显示这个组件。在页面上点击组件，选择了一个文件，页面上的上传文件组件数据有了变化，于是页面通知后台重新执行一遍代码，同时页面把上传文件组件的文件数据返回给后台，代码开始重新执行第一句代码时，函数返回了页面给的文件数据，因此函数有了返回值，不再是None。后续的创建，下拉选择框的代码也顺利被执行。本次执行结果收集到两个组件的创建信息，所以页面上创建了下拉框。接下来使用多选下拉框函数返回的列表创建页签，每个页签内创建表格即可。千万别忘了，如果没有选择任何工作表，要提前跳出执行看看，效果，很不错。
dfs=pd.read_excel(uploaded_file,None) names = list(dfs.keys()) sheet_selected = st.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6245e7602215eb70cb4e21ed35935405/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f84ee1de6542dd4433b86e6afc4827fb/" rel="bookmark">
			Android开发之截图当前view并保存到相册的标准姿势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上截图：
方法分为2种一种是Java版本，一种是kotlin版本
Java版本截图View
/** * 截图当前View的Java版本方法 * @param view view * @return 返回截图 */ public Bitmap getBitmapFromView(View view) { Bitmap bitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); view.layout(0, 0, view.getWidth(), view.getHeight()); Log.d("ss", "combineImages: width: " + view.getWidth()); Log.d("ss", "combineImages: height: " + view.getHeight()); view.draw(canvas); view.requestLayout(); return bitmap; } Kotlin版本截图View
非常简单一行代码
view.drawToBitmap() 注意此方法不能在打开view的时候立马调用会抛出如下异常
Caused by: java.lang.IllegalStateException: View needs to be laid out before calling drawToBitmap() 原因：java.lang.IllegalStateException：在调用 drawToBitmap（） 之前需要对视图进行布局
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f84ee1de6542dd4433b86e6afc4827fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdcb7382ba6c97c61011884de230afe6/" rel="bookmark">
			如何使用rpm安装jdk环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先检查linux服务器上是否存在jdk环境
java -version 存在的话，会显示jdk版本
这样子，需要先卸载jdk，如果需要知道rpm安装过程的可以跟一下，并且如果环境是openjdk的版本，就需要卸载原来的jdk，并安装sun公司的jdk。
1、检查一下jdk版本信息
rpm -qa|grep jdk 2、删除jdk，删除的是上面查询到的jdk
rpm -e --nodeps jdk1.8.0_121-1.8.0_121-fcs.x86_64 删除成功后，再次通过java -version 命令查询，此时环境中没有jdk的版本信息了
3、卸载完毕后，通过rpm -ivh 命令安装
rpm -ivh 这里是那个jdk的rpm安装包 4、 安装完毕，接下来就是配置环境变量
rpm安装的jdk不需要配置环境变量
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4496d06d79e3c27fe637a416f0920a3/" rel="bookmark">
			windows端口大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		netstat -aon|findstr “提示的端口”！！！！！！！！！！ windows查询固定端口号和他的PID
tasklist|findstr “PID” ！！！！！！！！！！！ 根据PID查询进程名
taskkill /f /t /im 程序名！！！！！！！！ 根据进程名关闭进程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/451c070661c6e18fa6ebaf6897419a7c/" rel="bookmark">
			VS2019配置VTK8.2.0，以及找不到vtkCommoncore-8.2.dll，vtkImagingSources.dll问题的解决方法。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们需要一个VS2019,一个CMAKE，一个VTK8.2.0的包：
先把VTK解压，在VTK文件夹里新建一个bin文件夹：
然后用cmake来编译VTK：
按照图中所示，勾选我勾选的几项,QT不勾选，如果你电脑中没有QT，你勾选了CMAKE也会找不到而报错。
然后执行configure、Generate、OpenProject。
打开工程会打开这样的一个VS2019界面：
在里面生成ALL_BUILD就可以将库生成到上面Cmake设置的目录
C:\Program Files\VTK：
如果没有生成这个目录，说明生成失败了。
注意，如果它默认是C:/programe file(x86)/vtk。需要改一下，可能写不进去。
(注意，这里有个坑，在生成上。来自：https://blog.csdn.net/annjeff/article/details/88597051）
此时选择【生成】--&gt;【批生成】
在ALL_BUILD Release x64 栏 勾选 √----&gt;点击【生成】
然后再点击生成，才能生成有效的库。我很多库有问题，重装了一次才发现这里有个坑。
上面的完成了ALL_BUILD的生成，还差一步INSTALL的生成：
把刚刚勾选的ALL_BUILD Release后面的√去掉，下拉，在INSTALL Release后面勾选。这一步就是在安装VTK的Release版本。其本质就是生成Release版本的库文件：
如果成功生成就可以在VS中新建一个项目：
代码如下：
#include "vtkCylinderSource.h" #include "vtkPolyDataMapper.h" #include "vtkActor.h" #include "vtkRenderer.h" #include "vtkRenderWindow.h" #include "vtkRenderWindowInteractor.h" #include "vtkProperty.h" #include "vtkCamera.h" #include &lt;vtkAutoInit.h&gt; #include &lt;vtkAutoInit.h&gt; VTK_MODULE_INIT(vtkRenderingOpenGL2) VTK_MODULE_INIT(vtkInteractionStyle) int main() { // This creates a polygonal cylinder model with eight circumferential facets. // 创建圆柱体 并设置为八边形圆柱体 vtkCylinderSource* cylinder = vtkCylinderSource::New(); cylinder-&gt;SetResolution(8); // The mapper is responsible for pushing the geometry into the graphics // library.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/451c070661c6e18fa6ebaf6897419a7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbd76df7e03830fa80a8ce0fed1ffdeb/" rel="bookmark">
			linux下安装两个或多个tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装jdk 链接：https://pan.baidu.com/s/1V1xVsB4SSGEwCMVrONiANw 提取码：jj0n 安装tomcat 链接：https://pan.baidu.com/s/19-6k0V9wOT2xzJVAc75R9w 提取码：xi66 编辑环境变量profile vi /etc/profile 加入以下代码(tomcat路径要配置自己实际的tomcat安装目录)
##########first tomcat########### CATALINA_BASE=/usr/local/tomcat8 CATALINA_HOME=/usr/local/tomcat8 TOMCAT_HOME=/usr/local/tomcat8 export CATALINA_BASE CATALINA_HOME TOMCAT_HOME ##########first tomcat############ ##########second tomcat########## CATALINA_2_BASE=/home/TwinMapServer/twinmap/apache-tomcat-8.5.51 CATALINA_2_HOME=/home/TwinMapServer/twinmap/apache-tomcat-8.5.51 TOMCAT_2_HOME=/home/TwinMapServer/twinmap/apache-tomcat-8.5.51 export CATALINA_2_BASE CATALINA_2_HOME TOMCAT_2_HOME ##########second tomcat########## export JAVA_HOME=/usr/local/java/jdk1.8.0_11 CLASSPATH=$JAVA_HOME/lib/ PATH=$PATH:$JAVA_HOME/bin export PATH JAVA_HOME CLASSPATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 保存退出。
再输入：source /etc/profile
才能生效。
修改catalina.sh 分别来到tomcat的bin目录下，打开catalina.sh ，找到下面红字
# OS specific support. $var _must_ be set to either true or false.
在下面增加如下代码，与profile中配置对应
export CATALINA_BASE=$CATALINA_BASE export CATALINA_HOME=$CATALINA_HOME export CATALINA_BASE=$CATALINA_2_BASE export CATALINA_HOME=$CATALINA_2_HOME 修改server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbd76df7e03830fa80a8ce0fed1ffdeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66e0cd7e91ffb9da5aa7c223897d8fa5/" rel="bookmark">
			深入了解 gRPC：协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过很长一段时间的开发，TiDB 终于发了 RC3。RC3 版本对于 TiKV 来说最重要的功能就是支持了 gRPC，也就意味着后面大家可以非常方便的使用自己喜欢的语言对接 TiKV 了。
gRPC 是基于 HTTP/2 协议的，要深刻理解 gRPC，理解下 HTTP/2 是必要的，这里先简单介绍一下 HTTP/2 相关的知识，然后再介绍下 gRPC 是如何基于 HTTP/2 构建的。
HTTP/1.x HTTP 协议可以算是现阶段 Web 上面最通用的协议了，在之前很长一段时间，很多应用都是基于 HTTP/1.x 协议，HTTP/1.x 协议是一个文本协议，可读性非常好，但其实并不高效，笔者主要碰到过几个问题：
Parser 如果要解析一个完整的 HTTP 请求，首先我们需要能正确的读出 HTTP header。HTTP header 各个 fields 使用 \r\n分隔，然后跟 body 之间使用 \r\n\r\n分隔。解析完 header 之后，我们才能从 header 里面的 content-length拿到 body 的 size，从而读取 body。
这套流程其实并不高效，因为我们需要读取多次，才能将一个完整的 HTTP 请求给解析出来，虽然在代码实现上面，有很多优化方式，譬如：
一次将一大块数据读取到 buffer 里面避免多次 IO read读取的时候直接匹配 \r\n的方式流式解析 但上面的方式对于高性能服务来说，终归还是会有开销。其实最主要的问题在于，HTTP/1.x 的协议是 文本协议，是给人看的，对机器不友好，如果要对机器友好，二进制协议才是更好的选择。
如果大家对解析 HTTP/1.x 很感兴趣，可以研究下 http-parser ，一个非常高效小巧的 C library，见过不少框架都是集成了这个库来处理 HTTP/1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66e0cd7e91ffb9da5aa7c223897d8fa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0d92e780022f7e86cdd65ca75bd021e/" rel="bookmark">
			基于Redis实现任务队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务队列 1、List 特点
使用list作为任务队列时，最大长度取决于内存的大小，没有限制；当任务队列为空时，消费者拉取消息，会根据不同的操作产生不同的结果： 消费者使用BLPOP等阻塞式操作，会一直阻塞等待新的数据到来，直到超时或有新的数据插入到队列中。消费者使用的是非阻塞式的取出操作，如LPOP等，当队列为空时，这些操作将返回空值（null）； 消息只能被单个消费者消费，无法重复消费；redis宕机时，会存在消息丢失问题； blpop task_queue 60 lpop task_queue ltrim task_queue 1 4 2、Pub/Sub pub/sub的最大特点是支持多生产者、多消费者，每个正常的消费端都能获取到生产者发出的消息。
但问题是channel本身并不存储消息，生产者创建的消息，channel会实时地将消息发送给消费端；所以，一旦一个消费者断开连接，那么它将再也无法处理断连过程中生产的消息。
=所以，pub/sub作为消息队列，完全不具备“可靠性”，它的优点在于消息的及时通知其他节点，因此，redis集群中的哨兵模式使用的就是pub/sub模型。
_哨兵模式_最简单的模型如下，哨兵进程通过监控主服务器状态是否正常，如果不正常，就通知所有从服务器。
在这里，从服务器是消费端，哨兵进程所在的服务器是生产者。
3、Stream Stream主要用于消息队列，从它的支持命令可以看出，和redis list的使用方法类似，但stream支持重复消费，而且消息还能持久化，以及消费确认。
XADD - 添加消息到末尾XTRIM - 对流进行修剪，限制长度XDEL - 删除消息XLEN - 获取流包含的元素数量，即消息长度XRANGE - 获取消息列表，会自动过滤已经删除的消息XREVRANGE - 反向获取消息列表，ID 从大到小XREAD - 以阻塞或非阻塞方式获取消息列表 消费确认，以示例演示
新建生产者，创建4条消息 创建消费组，表示开始消费的位置，0是指从头部消费消息 以消费组的方式消费消息，但需要指定具体的消费者，即consumer1 通过xpending查看消费组待消费的消息；可以看到因为之前消费消息时，没进行确认，现在任然是4条待消费消息。 xack确认消费后，看到待消费消息减少 参考 http://focus-1.wiki/redis/redis-list-blpop/
https://www.runoob.com/redis/redis-stream.html
https://blog.csdn.net/lt_xiaodou/article/details/126525965
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2893bd312f61d4366cae8005127687f/" rel="bookmark">
			Golang并发编程-context
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过创建context上下文关系树，达到控制协程的效果；
介绍 golang.org/x/net/context，是golang中的一个标准库，主要作用就是创建一个上下文，对程序中创建的协程通过传递上下文信息来实现对协程的管理
方法以下
创建根context，两个方法没区别，底层实现都是返回空context对象，但因为Background()更好理解，所以比较常用。 context.Background() context.TODO() 创建子context，下面方法的作用都是创建一个以parent context为根的子 context。 context.WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) context.WithValue(parent Context, key, val any) Context context.WithDeadline(parent Context, d time.Time) (Context, CancelFunc) context.WithCancel(parent Context) (ctx Context, cancel CancelFunc) 作用 控制子协程 对于存在若干个协程的程序，协程之前可能会存在如下的关系，这就需要在父协程关闭时，对子协程及时关闭，否则协程可能会持续存在与内存中，造成内存泄漏；
context对子协程的控制销毁就是基于协程创建的过程中，为每个子协程_创建子context_，以WithCancel()方法为例进行分析：
WithCancel()会返回一个新的子context和一个上下文取消方法，当执行cancel时，当前协程下的子context都会被销毁。
func WithCancel(parent Context) (ctx Context, cancel CancelFunc) { if parent == nil { panic("cannot create context from nil parent") } c := newCancelCtx(parent) propagateCancel(parent, &amp;c) return &amp;c, func() { c.cancel(true, Canceled) } } 下面时cancelCtx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2893bd312f61d4366cae8005127687f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0366bc1e1eda0012bc9b38b10b71c47/" rel="bookmark">
			TypeError: unsupported operand type(s) for -: ‘generator‘ and ‘NoneType‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发生此错误的原因是您使用 model.addConstr（） 方法通过 Python 生成器表达式将多个约束添加到模型中。您需要在发布的代码片段的前两行中使用 model.addConstrs（） 方法而不是 model.addConstr（）。
参考链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a048670836ea9263b57599f3a88debf7/" rel="bookmark">
			【Django用户认证】通过阿里云如何实现实名认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言前世今生场景基本概念相关法律一、实名二要素（一）阿里云云市场-三方公司1.链接2.参数3.示例 （二）阿里云服务-API接口1.链接2.准备3.参数4.计费 总结 前言 我最近在我的项目上有实名认证的需求，主要实现人名和身份证号码的验证，针对这一块具体怎么做的文章比较少，我解决问题之后，觉得还是把这些坑都写清楚，方便初学者。
前世今生 网络并非法外之地。然而，却存在部分网络用户利用虚拟的网络空间，实施网络暴力、造谣诽谤、购买水军、传播违法侵权视频图片等行为，严重侵害了他人的合法权益与社会公共利益。为治理网络不良现象，净化网络空间，中国相关政府主管部门采用以网络用户实名认证为基础的网络实名制的管理方式，2015年3月1日生效的《互联网用户账号名称管理规定》强调“互联网信息服务提供者应当按照“后台实名、前台自愿”的原则，要求互联网信息服务使用者通过真实身份信息认证后注册账号。”自此，对互联网信息服务提供者明确了“后台实名、前台自愿”的实名认证原则。知
实践中，目前存在以下四种主流的实名认证方式：
1、基于手机号的实名认证方式。这是最简单、最基本的实名认证方式。指互联网平台运营者通过收集用户的实名认证的手机号并转给第三方服务商，由第三方服务商向用户发送验证码，如果用户输入验证码一致，则证明用户是在使用已经实名认证的手机号注册。
2、基于第三方应用接口的实名认证方式。指互联网平台运营者提供用户从第三方应用接口注册登录方式，例如微信、支付宝等接口登录，以获得第三方的相关实名认证信息。
3、基于身份证实名认证方式。在此种模式下，根据对于实名认证信息真实性的要求不同，与第三方身份验证服务商合作，通过收集二要素（姓名和身份证号码）、三要素（姓名、身份证号码、银行卡）、四要素（姓名、身份证号码、银行卡、手机预留号码）等信息进行实名认证。
4、基于视频活体检测实人认证方式。如果说实名认证是为了证明注册某账号使用的身份信息是真实的，那么实人认证就是为了证明持证者本人在使用此账号，通常会采用活体检测、人脸识别等方式，多用于金融机构（如支付宝）、政府机构（如随申办、交管12123）、网络游戏未成年人防沉迷系统等。
上述四种实名认证方式所需要的个人信息以及实名认证的准确性依次递增，一般而言，APP运营者通过“基于手机号的实名认证方式”即满足了最基本的实名认证要求，如APP所处行业类型需要遵守更加严格的安全要求，亦可增加更加准确的实名认证方式。
场景 场景一：用户实名注册
在很多网站或app里实现在线刷脸实名认证，可以有效防止冒名开户，减少用户现场开户的时间成本，提高服务效率。
场景二：身份验证
在保险行业，由于被保人因为年龄、疾病等原因无法由本人办理业务时，可以调用增强版实人认证服务，确定参保人的真实身份和存活状态。
基本概念 实名认证主要分为实名认证二三四要素，二要素就是身份证、姓名. 三要素就是身份证、姓名、银行卡号. 四要素就是身份证、姓名、银行卡号、手机号. 此外还有身份证，姓名、银行卡号，手机号，CVV2，EXP的六要素验证。我这里介绍的都是以阿里云平台上的二要素验证方案。
相关法律 《网络安全法》第四十三条规定，网络运营者应按照法律、行政法规的规定和与用户的约定，收集使用个人信息。 据此规定，以实名认证为由收集的个人信息不应用于其他用途，在使用实名认证接口服务时，不得私自截留、存储此部分信息。
《互联网用户账号信息管理规定》第九条规定，公众账号信息服务平台对申请注册从事经济、教育、医疗卫生、司法等领域信息内容生产的公众账号，应当要求用户在注册时提供其专业背景，以及依照法律、行政法规获得的职业资格或者服务资质等相关材料，并进行必要核验。
提示：以下是本篇文章正文内容，下面案例可供参考
一、实名二要素 实名二要素也有叫做身份证二要素
（一）阿里云云市场-三方公司 此处以云市场其中一个为例。
1.链接 https://market.aliyun.com/products/57000002/cmapi025518.html
2.参数 参数包括AppCode以及名字和号码，AppCode是在云视窗控制台获得。
3.示例 import json import requests host = 'https://idenauthen.market.alicloudapi.com' path = '/idenAuthentication' method = 'POST' appcode = '' # 你自己的AppCode querys = '' bodys = {} url = host + path bodys['idNo'] = '13028********058' #身份证号码 bodys['name'] = '李四' # 名字 post_data = json.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a048670836ea9263b57599f3a88debf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5752f31ee2240cc8c4ca9a90ed76f9b4/" rel="bookmark">
			科研论文写作--综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		科研论文写作
可以参考b站的专栏，会持续更新科研论文写作相关内容。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/147/">«</a>
	<span class="pagination__item pagination__item--current">148/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/149/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>