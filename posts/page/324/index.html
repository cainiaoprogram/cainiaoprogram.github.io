<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f3c0ec30045002e00ce59a401ded4c2/" rel="bookmark">
			matlab将一幅图像缩小,基于matlab的图像缩小算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基于matlab图像缩小算法
缩小算法与放大算法不同，图像缩小是通过减少像素个数来实现的。因此，需要根据缩小的尺寸来选择合适的像素点，使得图像缩小后尽可能保持源图像特征。基于等间隔采样的缩小算法。
这种算法是通过对图像像素的均匀采样来保持所选择的像素仍旧保持像素的概貌特征。
算法1通过matlab实现可得：
function small=big2small(A,h,l)
[m,n]=size(A);
k1=m/h;k2=n/l;
small=zeros(h,l);
for i=1:h
for j=1:l
i0=i*k1;j0=j*k2;
i1=floor(i0+0.5);
j1=floor(j0+0.5);
small(i,j)=A(i1,j1);
end
end
end
1、基于局部均值的缩小算法。
这种算法通过采样间隔dx，dy将原图像矩阵分割为一系列小的矩阵，并计算这些小矩阵的元素的和，再求其均值赋给目标矩阵相应的像素。这样就避免了算法1中某些未取到的元素不能将其信息反映到目标矩阵的缺点。
算法2通过matlab实现可得：
function small=big2small2(A,h,l)
[m,n]=size(A); %获得矩阵A大小
A=im2double(A);
small=zeros(h,l);
for i=1:h
for j=1:l
sum=0;
i1=round((m/h).*(i-1)+1); %将矩阵分块
j1=round((n/l).*(j-1)+1); %i1,j1为矩阵小块左上角元素下标
i2=round((m/h).*i);
j2=round((n/l).*j); %i2,j2为矩阵小块右下角元素下标
for ii=i1:i2
for jj=j1:j2
sum=sum+A(ii,jj); %计算矩阵内元素值的和
end
end
small(i,j)=sum/((i2-i1+1).*(j2-j1+1)); %将均值赋给目标矩阵
end
end
end
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1261657ea0ddd46371c19785dc8fb6e0/" rel="bookmark">
			bluetoothctl No default controller available
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bluetoothd问题,首先解决问题的办法，先去快速直面问题，代码里面加打印比架构分析比对来的迅速直接。
通过加打印发现内核里面缺少
+#define BT_SNDMTU 12
+#define BT_RCVMTU 13
，然后发现旧版本的bluez是可以正常运行的。
所以编译问题是不存在的，和工具链不相干。编译问题是编译不过。
代码报错都是代码逻辑问题，目前这个问题是bluez 5.54和内核3.10.14+不匹配。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42c32c1f991805b6ad60ba697cdefa15/" rel="bookmark">
			Java Artifacts 找不到exploded Tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringMVC无法正常运行
首先应该是lib没有一起出来
所以去找 Artifacts
但是 Java Artifacts 找不到exploded
所以
Java Artifacts 找不到exploded Tomcat
打开后为空 所以
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d223a99fa59e8d25b2c8a280b2a0411/" rel="bookmark">
			使用pandas读取excel文件时出现unpack requires a buffer of 2 bytes错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景： 在使用pandas时，读取excel文件出现unpack requires a buffer of 2 bytes错误
df1 = pd.read_excel('C:\\Users\\peng\\Desktop\\Code.xls') 原因分析： 这个excel文件是受保护视图，无法修改
解决方案： 点击保存 启用保存，就可以读取了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a23ac1b71c3c1e205263c305427f2824/" rel="bookmark">
			微信小程序页面如何滚动到底部
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在需要滚动的页面根节点定义一个id="page"
&lt;view id="page"&gt; &lt;text&gt;需要滚到的页面&lt;/text&gt; &lt;/view&gt; 点击事件触发以下方法
wx.createSelectorQuery().select('#page').boundingClientRect(rect =&gt; { wx.pageScrollTo({ duration: 500, // 动画时长 scrollTop: rect.height }) }).exec() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b59335493257bd215a880a0887e80fc7/" rel="bookmark">
			matlab算2个数组的关系,匹配不用MATLAB中的函数,两个矩阵互相关系数怎么求?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		%% 互相关函数，获取到输入块block1 在block2中相关最高的位置及对应的相关函数结果
% 输入参数
% Block1：需要匹配的块，在Block2中检索与该快相似性最高的块；大小小于等于Block2
% Block2：大于等于Block1
% 其中Block1与Block2的正中心重合，即Block1的位置在Block2的正中心
% lateralstep：互相关过程中，横向移动步进，单位为像素点的整数倍
% axialstep：互相关过程中，纵向移动步进，单位为像素点的整数倍
% halflateralnum：横向块移动次数的一半，负数向左，正数向右
% halfaxialnum：纵向块移动次数的一半，负数向上，正数向下
% 输出参数
% x：在Block2中，与Block1最相似的块移动的横向距离,单位为像素点
% y：在Block2中，与Block1最相似的块移动的纵向距离，单位为像素点
% R12：Block1与Block2中最相似的块之间的互相关结果(复数)
%% 对Block2是有要求的，BLock2是Block1步进的偶数倍，即要保证Block1在Block2中的移动是对称的
function [x y R12] = ZPP_CrossCorrelation(Block1,Block2,lateralstep,axialstep,halflateralnum,halfaxialnum)
[m1 n1] = size(Block1);
[m2 n2] = size(Block2);
Ra = zeros(halfaxialnum*2+1,halflateralnum*2+1);
pro_data = Block1;
for i = 1 : halfaxialnum*2+1
for j = 1 : halflateralnum*2+1
clear temp;
clear post_data;
axial_num = (1:m1) + (i - 1)*axialstep;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b59335493257bd215a880a0887e80fc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f418ec886409f4c2d62fbe7877c0cfec/" rel="bookmark">
			ADC输入接地输出不为0，ADC值跳动厉害
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近用到某品牌国产32bit MCU，调试ADC时发现这个问题：ADC输入接地输出不为0（ADC值100多），ADC值跳动厉害。
1.一开始PA0用作ADC输入，以为是PA0有WAKE复用引起，改到PB0。无改善！
2.数字地模拟地分开，单点0欧姆电阻连接。无改善！
3.电源纹波大，电源加磁珠隔开，加滤波电容，无改善！
4.最后发现！ADC初始化配置改为下拉输入模式，ADC值跳动厉害的问题改善了！！！之前跳几十个ADC值，现在10个ADC 值以内跳，也算正常。加软件滤波就很稳了！
5.没用到的ADC端口，一定要接到固定电平，不要悬空！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/701f607a5331407f29f59db20fcd3e9a/" rel="bookmark">
			matlab 无穷符号,如何用matlab进行级数或数列的符号求和?matlab符号求和指令分享...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何进行级数或数列的求和，在高中《数学》课上的数列和大学《高等数学》中的级数都有有遇到过这种问题，这如果用人脑来计算的话非常耗时，难度较大。但是用matlab就可以轻松解决。下面我就介绍如何用matlab进行级数或数列的求和的具体方法，一起去看看吧。
1、matlab符号求和指令
matlab提供了一个符号求和指令，可以轻松解决级数、数列的符号求和，即symsum()。具体的调用格式为：S=symsum(f,v,a,b)，其功能是求通式f在指定自变量v取遍[a,b]中所有整数时的和。下面是用指令“help symsum”得到的matlab关于symsum()的帮助信息。
2、详细帮助信息
如果还是有疑问，还可以用指令“doc symsum”，在帮助浏览器窗口查看更详细的帮助信息，里面包括一些详细的例题！有助于我们更好的学习理解。
3、有限项级数求和
这里计算的级数为有限项级数求和，自变量区间为[1,n]。下面是级数求和代码及求和结果：
4、无限项级数的求和
此时的计算为无限项级数求和，所以自变量区间为[1,inf]。下面是级数求和代码及求和结果：
5、符号通式数组级数求和
在这一步里，f是符号通式数组，求和要对元素逐个进行，但自变量是定义在整个数组上的。下面是级数求和代码及求和结果：
6、说明：
1. f是矩阵时，求和对元素逐个进行，但自变量定义在整个矩阵上。
2. v省缺时，f中的自变量由symvar自动辨认；b可以取有限整数，也可以取无穷大。
3. a、b可同时省缺，此时默认求和的自变最区间为[0,v-1]。
4. 通式中的自变量只取整数。
教程结束，以上就是关于如何用matlab进行级数或数列的符号求和?matlab符号求和指令分享的全部内容，希望对大家有所帮助！更多matlab使用技巧与下载，尽在我们网站！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24a2a61275a0b51e135446d68462f214/" rel="bookmark">
			将注意力机制引入ResNet，视觉领域涨点技巧来了！附使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，加州大学伯克利分校和谷歌的科研团队共同提出了一个概念上非常简单，但是功能很强大的骨架网络，该网络将自注意力机制纳入了各种计算机视觉任务，包括图像分类、目标检测和实例分割，指标都有了很大的提升，该网络叫做 BoTNet（Bottleneck Transformer）。
为什么要使用 BoTNet？设计思想 近年来，卷积骨架网络在计算机视觉的各个领域取得了非常大的进展，这得益于卷积能够有效捕捉图像中局部的信息，但是对于实例分割、目标检测和关键点检测之类的视觉任务，需要对长期的依赖进行建模。
一、为什么要引入注意力机制？传统基于卷积的体系结构，需要堆叠很多个卷积层，以全局汇总捕捉局部信息的计算结果。尽管堆叠更多的层可能能够提高这些骨架网络的性能，但是显式的对全局依赖性进行建模可能是一种更强大且更具扩展性的解决方案。
二、为什么不全部替换成注意力机制？目标检测领域的输入图像（1024像素）相比于图像分类（224像素）来说非常大。而对于自注意力机制，消耗的显存和计算量与输入的大小成4倍增长，导致训练和测试效率太低，不切实际。
因此，作者提出利用自注意力机制来替换 ResNet 的最后三个 BottleNeck Layer ，这样的结构，使用卷积提取图像中局部的信息，然后利用自注意力机制来对全局的依赖性进行建模，能够解决上述的两个问题。
网络设计 该所提方法基于ResNet网络，与ResNet的唯一区别，是在 c5 中，将 3×3 卷积替换成了 MHSA（Multi-Head Self Attention）结构。可以看到，参数量相比于ResNet减少了18.4%，加乘操作的数量增加了20%。
实验部分 作者在实例分割和目标检测上进行了实验。
相比ResNet，提升了COCO 实例分割上的性能 其中，R50 代表 ResNet-50。
相对的位置编码能够提升性能 MHSA层中有两种交互：内容和内容的交互(qkT)，以及内容和位置的交互（qrT）。而使用相对位置进行交互，带来的性能提升是非常明显的。
三个卷积都替换成 MHSA 吗？ c5中有三个卷积层，作者进行消融实验，来看是否需要三个都替换成MHSA？
结论是：三个卷积层全都替换，在小目标上效果非常好，但是大目标上效果就不太行了。作者说这可能是优化得不好，把这个留给了未来工作。
通过替换引入了全局依赖，那么性能是否与更深的卷积网络相当？ 随着卷积网络的不断加深，更容易关注到全局的信息。而使用自注意力机制直接就关注的是全局的信息，所以说使用自注意力的网络不那么深，也能够达到类似的性能。作者通过实验也说明了这一点。
通过上表，我们可以看出，当配置是[0,1,1]时，BoT 50的效果要好于 R101的效果。
可以得出结论：替换为自注意力比卷积的堆叠更加有效。
BoTNet可以提升所有ResNet家族网络的性能 这里就是增加了152层的ResNet的结果，性能也有一定的提升。
除此之外，作者还进行了非常多详细的实验，有兴趣的可以参考原论文。
使用方式 这里官方都为我们实现好了，话不多说，直接上代码。这个实现方式是基于PyTorch的，基于TensorFlow的代码在最下面有。
安装 pip install bottleneck-transformer-pytorch 使用 import torch from torch import nn from torchvision.models import resnet5 from bottleneck_transformer_pytorch import BottleStack layer = BottleStack( dim = 256, # 输入通道数 fmap_size = 56, # 对于imagenet 224 x 224的图，特征图大小为56 x 56 dim_out = 2048, # 输出通道数 proj_factor = 4, # 压缩通道的倍数，压缩后的通道数 = 输入通道数 / proj_factor downsample = True, # 第一层是否下采样 heads = 4, # MHSA 的头数 dim_head = 128, # 每个头的维度，默认128维 rel_pos_emb = False, # 是否使用相对的位置嵌入 activation = nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24a2a61275a0b51e135446d68462f214/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8af3352d2654f2c8f6a8ee0b69b2c0d6/" rel="bookmark">
			PaddleOCR加载chinese_ocr_db_crnn_server/chinese_ocr_db_crnn_modile模型进行中英文混合预测（代码）实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 环境搭建 参考：《PaddleOCR加载chinese_ocr_db_crnn_server模型进行中英文混合预测（命令行）实践》
2. 代码 import paddlehub as hub import cv2 # 待预测图片 test_img_path = ["./pic/0-1.jpg"] def predict(): # 选择chinese_ocr_db_crnn_server模型 ocr = hub.Module(name="chinese_ocr_db_crnn_server") # 选择chinese_ocr_db_crnn_mobile模型 # ocr = hub.Module(name="chinese_ocr_db_crnn_mobile") np_images = [cv2.imread(image_path) for image_path in test_img_path] results = ocr.recognize_text( images=np_images, # 图片数据，ndarray.shape 为 [H, W, C]，BGR格式； use_gpu=False, # 是否使用 GPU；若使用GPU，请先设置CUDA_VISIBLE_DEVICES环境变量 output_dir='ocr_result', # 图片的保存路径，默认设为 ocr_result； visualization=True, # 是否将识别结果保存为图片文件； box_thresh=0.5, # 检测文本框置信度的阈值； text_thresh=0.5) # 识别中文文本置信度的阈值； for result in results: data = result['data'] save_path = result['save_path'] for infomation in data: print('text: ', infomation['text'], '\nconfidence: ', infomation['confidence'], '\ntext_box_position: ', infomation['text_box_position']) if __name__ == '__main__': # show_img() predict() 关于模型的几点说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8af3352d2654f2c8f6a8ee0b69b2c0d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26f99c9e2f4abe8bc69bf721981b0094/" rel="bookmark">
			PaddleOCR加载chinese_ocr_db_crnn_server模型进行中英文混合预测（命令行）实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装相关库文件 # 安装paddlehub和paddlepaddle pip install paddlehub -i https://pypi.tuna.tsinghua.edu.cn/simple pip install paddlepaddle -i https://pypi.tuna.tsinghua.edu.cn/simple # 该Module依赖于第三方库shapely、pyclipper，使用该Module之前，请先安装shapely、pyclipper pip install shapely -i https://pypi.tuna.tsinghua.edu.cn/simple pip install pyclipper -i https://pypi.tuna.tsinghua.edu.cn/simple 使用的是清华的源，在安装时出现过https连接池超时的问题，换个网络环境，多试几次就好了。
2. 安装预训练模型 选择的是识别精度相对较高的：chinese_ocr_db_crnn_server
命令是：hub install chinese_ocr_db_crnn_server==1.1.1
(venv) E:\test\PycharmProjects\PaddleStudy2&gt;hub install chinese_ocr_db_crnn_server==1.1.1 e:\test\pycharmprojects\paddlestudy2\venv\lib\site-packages\pip\_vendor\packaging\version.py:127: DeprecationWarning: Creating a LegacyVersion has been deprecated and will be removed in the next major release warnings.warn( e:\test\pycharmprojects\paddlestudy2\venv\lib\site-packages\pip\_vendor\packaging\version.py:127: DeprecationWarning: Creating a LegacyVersion has been deprecated and will be removed in the next major release warnings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26f99c9e2f4abe8bc69bf721981b0094/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11fef4decfe63dd786808935d142b456/" rel="bookmark">
			java的executor,带你进入java中的ExecutorService
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概览
ExecutorService是一个由JDK提供的框架，它简化了以异步模式运行task的工作。通常来说，ExecutorService会自动提供一个线程池以及常用的API。
2.实例化ExecutorService
2.1 Executors类的工厂方法
创建ExecutorService的最简单的方法是使用Executors类的一个工厂方法。例如，下面的一行代码将会创建一个拥有10个线程的线程池。ExecutorService executor = Executors.newFixedThreadPool(10);
还有其他几个工厂方法用于创建预定义的ExecutorService，它们会满足特定的使用场景。寻找最合适你的方法，可以咨询Oracle的官方文档。
2.2 直接创建一个ExecutorService
由于ExecutorService是一个接口，所以可以使用它的任一实现来创建一个实例。在java.util.concurrent包中有好几个实现可供选择，或者你可以创建自己的实现。例如，ThreadPoolExecutor类就有好几个构造方法可用于配置一个executor service以及它内部的线程池。
ExecutorService executorService = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());
你可能注意到了，上面的代码和工厂方法newSingleThreadExecutor()的源代码很像，在大多数情况下，详细的手工配置都不是必需的。
3.分配task给ExecutorService
ExecutorService可以运行 Runnable 以及Callable任务。为了让事情简单一点，我们将使用俩个最基本的任务。注意：这里我们使用拉姆达表达式来取代匿名内部类。Runnable runnableTask = () -&gt; {
try {
TimeUnit.MILLISECONDS.sleep(300);
} catch (InterruptedException e) {
e.printStackTrace();
}
};
Callable callableTask = () -&gt; {
TimeUnit.MILLISECONDS.sleep(300);
return "Task's execution";
};
callableTasks.add(callableTask);
callableTasks.add(callableTask);
callableTasks.add(callableTask);
有好几个方法可以用于把task分配给ExecutorService,包括： execute()、 submit()、 invokeAny()、 invokeAll()。其中，execute()方法是继承自Executor接口。execute()方法的返回值是void,使用它无法获取任务的运行结果或者检查任务的状态(例如，是正在运行还是已经被执行了)。executorService.execute(runnableTask);
submit()可以提交一个Callable或Runnable任务给ExecutorService，并且返回一个Future类型的结果。Future future = executorService.submit(callableTask);
invokeAny()可以给ExecutorService分配一个任务集合。导致他们中的每一个都被执行，并且返回一个任务成功运行的结果(如果存在一个成功运行的话)。String result = executorService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11fef4decfe63dd786808935d142b456/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7c0c55f5d7de31ff3cfa12566d59fbb/" rel="bookmark">
			AMESim2020&amp;MATLAB2020b联合仿真设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AMESim2020&amp;MATLAB2020b联合仿真 提示：本文按照作者的个人经验完成，不代表经验的普适性；如有侵权，请联系作者删除。
文章目录 AMESim2020&amp;MATLAB2020b联合仿真前言一、AMESim2020的安装二、VS2019 community版本安装三、MATLAB2020b的安装破解四、配置环境变量五、修改文件信息六、软件编译器的选择七、联合仿真运行八、总结 前言 本文的软件安装版本为AMESim2020，MATLAB2020b，编译器为Microsoft Visual Studio 2019 community版本。安装顺序为：
VS2019——AMESim2020——MATLAB2020b
1、电动汽车仿真
掌控车辆电动化的工程复杂性。Simcenter Amesim 提供对所有关键子系统进行仿真所需的建模级别。无论是处理电池容量还是电机设计，您都可以从高效的建模工作流中获益，为从架构创建到集成的工程工作提供支持，包括详细的设计。
2、动力总成子系统仿真
加快汽门机构、曲轴系统、燃油喷射、润滑和冷却系统的设计过程。Simcenter Amesim 可用于调整组件大小，评估和优化系统效率，并验证控制策略。通过评估不同子系统之间以及子系统与燃烧室之间的相互作用，您将能够准备传动环境中子系统的集成，并分析子系统设计对发动机性能、燃油经济性或排放的影响。
3、动力总成传动系统仿真
从早期设计阶段优化各类变速箱和车辆的集成，以平衡性能、燃油经济性、驾驶性、舒适性和可靠性。Simcenter Amesim 通过预测损耗来帮助您改善燃油消耗，还通过检测和修改固有模态的影响因素来减少振动，并减少接触力的变化、离合器颤振声、空腔噪鸣声和咔嗒声。
4、飞机发动机和设备系统仿真
Simcenter系统仿真软件使您能够在设计周期的早期集成最佳概念，以评估整体性能并获得最佳的适应性引擎。 您可以轻松地评估和实现您的创新想法。
5、ADAS和自动驾驶汽车仿真
使用包括正确的车辆动力学和高保真动力总成物理模型的模型验证高级驾驶员辅助系统和自动驾驶系统。 Simcenter补充了我们的PreScan环境和传感器仿真解决方案，并通过提供现成的保真度可缩放组件使您在小型或大型仿真活动中更有效。 在安全性，舒适性，燃料和电能消耗以及污染物排放评估方面，您始终可以在CPU时间和准确性之间获得最佳平衡。
一、AMESim2020的安装 下载Amesim2020软件并解压，首先将LMS_RLM_Server文件夹复制到C盘目录下，以管理员身份运行server_install.bat启动服务。（PS.在任务管理器中可以看到有LMS RLM Server的服务启动，如果安装错误要卸载软件，一定要先使用server_remove.bat关闭服务再删除文件夹。）
创建系统环境变量
变量名：LMS_LICENSE
变量值：5053@localhost
使用虚拟光驱或者直接解压Simcenter Amesim and System Architect 2020.1 dvd1.iso镜像文件，之后，运行setup_win.bat文件进入安装向导界面，选择要安装的产品，在此选择第一项。
之后一直点next。
输入用户信息和激活码：这里提供一组参考，7ZZXW 40TI2 6Z070 039M0 20LN9
选择安装类型，默认即可，单击next。
可以两个都安装。
选择软件安装位置，默认的是为C盘，可以单击 browse 修改。本文选择的路径为E:\Simcenter\2020.1\Amesim
弹出安装路径窗口，点击yes。
确认安装信息，单击 install 开始安装。
安装时间较长，点击next之后选择Specify port@host，输入5053@localhost即可，与第一步的环境变量设置一致。
继续按照提示安装，这里必须选择稍后重启电脑并结束安装。（此处没有截到图，在安装到这个界面时会有一个弹窗，需要先装载另一个虚拟光驱Simcenter Amesim and System Architect 2020.1 dvd2，在弹窗中选择对应盘符如G:或F:等，之后继续按照前述步骤安装，完成后弹窗会自动消失，否则可能丢失demo库）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7c0c55f5d7de31ff3cfa12566d59fbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffd3185cf15e8d84180751675cb597c2/" rel="bookmark">
			微服务架构-SpringCloudAlibaba-098：Gateway高可用集群与动态网关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		098：Gateway高可用集群与动态网关 1 网关部署实现集群设计思路2 基于Nginx部署GateWay集群环境3 部署动态GateWay的思路4 基于数据库形式构建动态网关5 代码实现创建动态网关实现 1 网关部署实现集群设计思路 课程内容：
Gageway如何实现集群Gateway集群部署方案Gateway如何实现动态网关Gateway动态网关部署方案 如果网关宕机，会出现什么情况？如何解决？
导致整个微服务无法通讯。网关实现集群。
网关实现集群如何访问？
使用Nginx或者lvs虚拟vip。
2 基于Nginx部署GateWay集群环境 环境配置：
网关1：127.0.0.1:81
网关2：127.0.0.1:82
Nginx服务器：127.0.0.1:80
网关的请求头中放端口号
@Component public class TokenGlobalFilter implements GlobalFilter { @Value("${server.port}") private String serverPort; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { // 如何获取参数 String token = exchange.getRequest().getQueryParams().getFirst("token"); if (StringUtils.isEmpty(token)) { ServerHttpResponse response = exchange.getResponse(); response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR); String msg = "token not is null "; DataBuffer buffer = response.bufferFactory().wrap(msg.getBytes()); return response.writeWith(Mono.just(buffer)); } // 在请求头中存放serverPort ServerHttpRequest request = exchange.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffd3185cf15e8d84180751675cb597c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ac89d94b942ea217125ab8c5820e949/" rel="bookmark">
			如何创建自定义navigation注解处理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建自定义的navigation注解处理器主要有以下几个步骤-&gt;对慕课的jetpack项目进行一个小总结 1.创建libnavannotation和libnavcompiler
libnavannotation中还需要创建创建ActivityDestination和FragmentDestination注解文件
ActivityDestination
import java.lang.annotation.ElementType; import java.lang.annotation.Target; @Target(ElementType.TYPE) public @interface ActivityDestination { String pageUrl(); boolean needLogin() default false; boolean asStarter() default false; } FragmentDestination
@Target(ElementType.TYPE) public @interface FragmentDestination { String pageUrl(); boolean needLogin() default false; boolean asStarter() default false; } 在libnavcompiler要创建NavProcessor生成器
import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.google.auto.service.AutoService; import com.mooc.libnavannotation.ActivityDestination; import com.mooc.libnavannotation.FragmentDestination; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStreamWriter; import java.lang.annotation.Annotation; import java.lang.reflect.Type; import java.util.HashMap; import java.util.Set; import javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ac89d94b942ea217125ab8c5820e949/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e151986452bf1125c7b7c3139bb9b2ce/" rel="bookmark">
			2021最新BATJ等一线互联网大厂春招面试题汇总，拿走不谢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文收集整理了各大厂常见面试题N道，你想要的这里都有内容涵盖：
Java、MyBatis、ZooKeeper、Dubbo、Elasticsearch、Memcached、Redis、MySQL、Spring、Spring Boot、Spring Cloud、RabbitMQ、Kafka、Linux等技术栈……
希望大家都能找到适合自己的公司，开开心心的撸代码。
由于题量较多，篇幅的限制，文章中的面试题分享没有全部附上详细的解析，但是整理成了一份详细的PDF文档可分享给大家（一键三连（点赞+收藏+关注） 后，添加微信：mxm9843 即可免费获取到）
看面试题可以是为了面试，也可以是对自己学到的东西的一种查漏补缺，更加深刻的去了解一些核心知识点
MyBatis 面试题 1、什么是 Mybatis？2、Mybaits 的优点：3、MyBatis 框架的缺点：4、MyBatis 框架适用场合：5、MyBatis 与 Hibernate 有哪些不同？6、#{}和${}的区别是什么？7、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？8、 模糊查询 like 语句该怎么写? ZooKeeper 面试题 ZooKeeper 是一个开源的分布式协调服务，由雅虎创建，是 Google Chubby 的开源实现。分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、配置维护，名字服务、分布式同步、分布式锁和分布式队列等功能。
zookeeper 负载均衡和 nginx 负载均衡区别Zookeeper Watcher 机制--数据变更通知客户端注册 Watcher 实现zookeeper 是如何保证事务的顺序一致性的？Zookeeper 对节点的 watch监听通知是永久的吗？为什么不是永久的?zk 节点宕机如何处理？ Dubbo 面试题 Spring Eureka 从开源转变为闭源，Consul 正在崛起，而 Dubbo 又开始重新更新。目前市场上仍有不少公司使用dubbo我们也需要继续学习。
为什么要用 Dubbo？默认使用的是什么通信框架，还有别的选择吗?服务调用是阻塞的吗？一般使用什么注册中心？还有别的选择吗？默认使用什么序列化框架，你知道的还有哪些？Dubbo 的整体架构设计有哪些分层? Elasticsearch 面试题 elasticsearch 了解多少，说说你们公司 es 的集群架构，索引数据大小，分片有多少，以及一些调优手段 。elasticsearch 索引数据多了怎么办，如何调优，部署elasticsearch 是如何实现 master 选举的Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法详细描述一下 Elasticsearch 更新和删除文档的过程。Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法？(文末附面试答案) Redis面试题 随着应用研发技术的不断成熟，Redis 缓存技术已经成为后台研发同学必备的能力之一。在很多公司面试的过程中，都必不可少地考察 Redis 知识点的掌握。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e151986452bf1125c7b7c3139bb9b2ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cb382aa6f48e7e2db1f7c54a999460e/" rel="bookmark">
			17.Cluster集群结构搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集群简介 现状问题 业务发展过程中遇到的峰值瓶颈
redis提供的服务OPS可以达到10万/秒，当前业务OPS已经达到20万/秒内存单机容量达到256G,当前业务需求内存容量1T使用集群的方式可以快速解决上述问题 集群架构
集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果。 集群的作用
分散单台服务器的访问压力，实现负载均衡分散单台服务器的存储压力，实现可扩展性降低单台服务器宕机带来的业务灾难
Redis集群结构设计 数据存储设计
通过算法设计，计算出key 应该保存的位置将所有的存储空间计划切割成16384份，每台主机保存一部分
每份代表的使一个存储空间，不是一个key的保存空间将key按照计算出的结果放到对应的存储空间
集群内部通讯设计各个数据库相互通信，保存各个库中曹的编号数据一次命中，直接返回一次未命中，告知具体位置，最多两次才命中 Cluster配置
设置加入cluster，成为其中的节点 cluster-enabled yes|no
cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容 cluster-config-file &lt; filename&gt;
节点服务响应超时时间，用于判定该节点是否下线或切换为从节点 cluster-node-timeout &lt; milliseconds&gt;
master连接的slave最小数量 cluster-migration-barrier &lt; count&gt;
Cluster节点操作命令
查看集群节点信息 cluster nodes
进入一个从节点redis，切换其主节点 cluster replication &lt; master-id&gt;
发现一个新节点，新增主节点 cluster meet ip:port
忽略一个没有solt的节点 cluster forget 手动故障转移 cluster failover
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a96999dd1137383b2e8e6f9e9fb4edbe/" rel="bookmark">
			汇编语言学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前序 因为今年想转向二进制安全，感觉毕业一定要有个方向，这样好投递岗位，所以学习汇编语言是第一站，在学校的智云课堂上，找了老师的课来上，讲的特别好，老师不让传任何相关资源到网上，我在这里做一个对汇编学习简要的总结，我之后逆向或者搞二进制漏洞的时候，也可以方便查阅，虽然网上一搜都是，这里写一下，也算是巩固一下自己学的东西，以后回头看的时候，能够快速弄懂。
环境 我的编程环境在xp虚拟机中，使用masm进行编译，连接，td(Turbo Debugger)来进行调试，安装教程在这里：https://www.jianshu.com/p/43c8661b381d, 我没进行尝试，反正我是直接用的老师的打包好的xp虚拟机，贼方便：）
基本调试环境如下图所示，我最常用的几个操作如下：
F2设断点F7跟踪进入（trace into）F8单步执行（step over， 不进函数）F9直接运行，会在断点断下在寄存器窗口右键，能转换成32位寄存器，因为这个环境也能写32位汇编程序，就是偏移得用16位在各个cs,ds,ss窗口点击Ctrl+G，输入ds:0587，就能到对应的全局变量地址window下有个User Screen，能看到当前黑窗口内输出了什么
基本知识 寄存器 16位cpu的寄存器有：
ax, bx, cx, dx（前四个寄存器加减乘除，逻辑运算，二进制运算，其中bx可用作偏移，其他都不能）
其中上面四个都可以再划分，比如ax，可以分为al(低8位)和ah(高8位)
sp, bp, si, di（sp，bp是栈寄存器，si，di负责偏移和计算）
cs, ds, es, ss（段地址寄存器，其中es:extra segment附加段，它跟ds类似，可以用来表示一个数据段的段址）
ip, fl （两个寄存器无法被用户直接修改，可以采用一些间接方法进行修改）
上图比较清晰的讲解了寄存器，图片来源于网上，https://blog.csdn.net/cqkxboy168/article/details/8994479
32位cpu的寄存器有：
eax, ebx, ecs, edx
esp, ebp, esi, edi
cs, ds, es, ss(这里的段寄存器是16位，其他都是32位)
eip, efl
堆栈 网上找了一个解释堆栈的图：
最上面是栈（stack），一般用来保存局部变量，有 8 MB 的大小限制，因此不建议在函数内开大数组，递归的效率低是因为容易栈溢出。栈的增长方向是向下的。堆（heap），动态分配的内存会在这里处理，例如 malloc、new。堆是向上增长的。data 区，静态存储区，存放全局变量，静态变量，常量等。text 区和共享库，是可执行机器指令，是只读的。 在汇编语言中，ss: stack segment(用来表示堆栈的段地址)，sp:stack pointer(堆栈指针, 表示堆栈顶端的偏移地址), 但是不能用[sp]或[sp+常数或其它寄存器]的形式来引用某个变量。可以使用[bp+常数或其它寄存器]的形式来引用某个变量。
汇编代码结构 ;16位汇编语言程序 data segment ;这里定义全局变量(数据) data ends code segment ;assume的作用 ;帮助编译器建立段寄存器与段的关联, 当源程序中引用了某个段内的变量时，编译器会在编译出来的机器码中把变量的段地址替换成关联的段寄存器 assume cs:code, ds:data main: mov ax, data mov ds, ax code ends end main ;表示开始地址为main hello world ;变量的偏移地址就是该变量离它所在段开端的距离 data segment hello db "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a96999dd1137383b2e8e6f9e9fb4edbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bbea84928ea48b8770e369759537d67/" rel="bookmark">
			ODL安装、ODL与mininet连接可视化显示拓扑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ODL安装、ODL与mininet连接可视化显示拓扑 一、OpenDaylight安装step1.安装ODL依赖包step2.下载OpenDaylight控制器：step3.配置Java环境step4.测试一下Java的环境step5.测试是否安装成功除此之外，我还修改了一些参数（可略过）补充，这里还有组件的安装 二、ODL与mininet连接可视化显示拓扑 一、OpenDaylight安装 step1.安装ODL依赖包 #sudo apt-get update #sudo apt-get install openjdk-8-jdk step2.下载OpenDaylight控制器： opendaylight官网下载
自行选择你想要的版本，我选择的是distribution-karaf-0.3.0-Lithium.tar.gz 点进去找到distribution-karaf-0.3.0-Lithium.tar.gz就可以 这里注意下载的速度超级慢，你可以选择代理服务器和IDM多线程下载就可以快一点，可以选择晚上期间下载
#tar zxvf distribution-karaf-0.3.0-Lithium.tar.gz step3.配置Java环境 #vim /etc/profile vim 打开末尾添加记得wq！保存退出 JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-amd64 JRE_HOME=$JAVA_HOME/jre CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin export JAVA_HOME JRE_HOME CLASS_PATH PATH #source /etc/profile step4.测试一下Java的环境 # java -version openjdk version "1.8.0_282" OpenJDK Runtime Environment (build 1.8.0_282-8u282-b08-0ubuntu1~16.04-b08) OpenJDK 64-Bit Server VM (build 25.282-b08, mixed mode) step5.测试是否安装成功 #cd distribution-karaf-0.3.0-Lithium #./bin/karaf 显示如下:
除此之外，我还修改了一些参数（可略过） 修改是因为我使用时mininet和ODL controller链接不上，所以做了修改
#cd distribution-karaf-0.6.0-Carbon/etc #vim org.apache.karaf.management.cfg 修改：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bbea84928ea48b8770e369759537d67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c3111bf4f3605b9dd066a5b3d7a8625/" rel="bookmark">
			zepto touch 拖动元素，获取移动坐标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;div id="m" style="position:absolute;width: 100px;height: 100px;background: red"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var start_piont,end_point,delta_x,delta_y; $(document).ready(function(){ $("#m").on("touchstart",function(e){ var touch = e.touches[0]; start_piont = { x: touch.pageX, y: touch.pageY } console.log(start_piont); $("#m").css("top",touch.pageY); $("#m").css("left",touch.pageX); }).bind('touchmove',function(e){ //在这里不断刷新 var touch = e.touches[0]; end_point = { x: touch.pageX, y: touch.pageY } console.log(end_point); $("#m").css("top",touch.pageY); $("#m").css("left",touch.pageX); }).bind('touchend', function(e){ //在这里取值计算 delta_x = end_point.x - start_piont.x; delta_y = end_point.y - start_piont.y; console.log(delta_x); console.log(delta_y); });	}); &lt;/script&gt;	
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da2daa0f68e175100a512a6e5e946a63/" rel="bookmark">
			QFlags详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、描述 QFlags&lt;Enum&gt;类是一个模板类，其中Enum是枚举类型。QFlags在Qt中用于存储枚举值的组合。
用于存储或组合枚举值的传统C++方法是使用整型变量。这种方法的不便之处在于根本没有类型检查，任何枚举值都可以与任何其他枚举值进行逻辑运算。
enum Orientation { Up = 1, Down = 2, Left = 4, Right = 8, }; enum Direction { horizontal = 2, vertical = 3, }; 这两种操作编译器不会报错：
Orientation::Up | Direction::horizontal; Orientation::Up | Orientation::Down; 第一种两个不相关的枚举值做逻辑运算没有意义，第二种运算结果是3，但Orientation中没有值是3的标识符。
Qt使用QFlags来提供类型安全性。
如果要对自己的枚举类型使用QFlags，应使用Q_DECLARE_FLAGS()和Q_DECLARE_OPERATORS_FOR_FLAGS()。
例：
class MyClass { public: enum Orientation { Up = 1, Down = 2, Left = 4, Right = 8, }; Q_DECLARE_FLAGS(Orientations, Orientation) ... }; Q_DECLARE_OPERATORS_FOR_FLAGS(MyClass::Orientations) 这样为枚举Orientation创建了一个Flags：Orientations，这个Orientations的类型就是QFlags&lt;MyClass::Orientation&gt;。可以用Orientations对象接收逻辑运算的值了：
Orientations f = Orientation::Up | Orientation::Down; 二、Flags和元对象系统 要在元对象系统和Qt Designer中使用枚举必须加上：Q_FLAG(Orientations)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da2daa0f68e175100a512a6e5e946a63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8cc1dd8e86774d3e6d176e1b1246e53/" rel="bookmark">
			逻辑斯谛回归（Logistic回归）最详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Logistic回归学习思路
一.逻辑回归模型的原理与定义（主要思想） 逻辑斯谛回归是经典的分类方法，它属于对数线性模型，原理是根据现有的数据对分类边界线建立回归公式，以此进行分类。（主要思想）
定义： 在线性回归模型的基础上，使用Sigmoid函数，将线性模型的结果压缩到[0,1]之间，使其拥有概率意义，它可以将任意输入映射到[0,1]区间，实现值到概率转换。
属于概率性判别式模型线性分类算法 在学习逻辑回归模型之前，先来看一下逻辑斯谛分布，因为我们的逻辑斯蒂模型就是根据逻辑斯蒂分布得到的；通过参数估计方法直接估计出参数，从而得到P(Y|X)。
下面给出《统计学习方法》上逻辑斯蒂分布的定义：
二.逻辑回归的推导过程 为了实现根据所有输入预测出类别，为此引入了sigmoid函数p=1/（1+exp(-z)）,sigmoid函数刚好也有二分类的功能。
1. 为什么要使用sigmoid函数作为假设？
因为线性回归模型的预测值为一般为大于1的实数，而样本的类标签为（0,1），我们需要将分类任务的真实标记y与线性回归模型的预测值联系起来，也就是找到广义线性模型中的联系函数。如果选择单位阶跃函数的话，它是不连续的不可微。而如果选择sigmoid函数，它是连续的，而且能够将z转化为一个接近0或1的值。
当z=0时，p=0.5
当z&gt;0时，p&gt;0.5 归为1类
当z&lt;0时，p&lt;0.5 归为0类
确定了分类器的函数形式，最佳回归系数是多少，如何确定？
sigmoid函数的输入记为z,将线性模型结果赋值到z,即：
z=w0x0+w1x1+w2x2+w3x3...wnxn
如果采用向量的写法，
上述公式写成z=WT*X，
其中向量X是分类器的输入数据，即为特征值；向量W就是我们要找到的最佳参数，从而使得分类器尽可能精确。
为了找出最佳的回归系数，所以我们可以对两种损失函数进行优化算法
①均方差 （后面会介绍舍弃使用这种作为损失函数）
②对数极大似然估计法
三.数学模型 二项逻辑斯蒂回归模型
知道分布的定义和推导过程之后，就是给出我们的逻辑斯蒂模型了：
引用了李航的《统计学习方法》书中如下
注意：（1）最终的结果是通过比较P(Y=1|X)和P(Y=0|X)的大小来确定类别的（类似于朴素贝叶斯）；
（2）b在这里其实可以看做是w0x0，其中x0 = 1；
（3）其实本质上这个就是一个二项分布，所以遵循二项分布的分布律。
事件的对数几率（log odds）
也就是说，如果我的模型是逻辑回归模型，那么事件{Y=1|X}发生的对数几率就是输入X的线性函数（模型），反之，知道了这个推论，我们是可以反推出逻辑斯蒂模型的形式的
四.目标函数 求目标参数，常用目标函数的选取：
①损失函数：均方差（标准值-预测值）
②对数似然函数
首先极大似然函数是一种确定模型参数的方法，它确定参数值的方法是通过找到最大化模型产生真实数据的那一组参数。
最大似然估计就是通过已知结果去反推最大概率导致该结果的参数。
极大似然估计是概率论在统计学中的应用，它提供了一种给定观察数据来评估模型参数的方法，即 “模型已定，参数未知”，通过若干次试验，观察其结果，利用实验结果得到某个参数值能够使样本出现的概率为最大，则称为极大似然估计。逻辑回归是一种监督式学习，是有训练标签的，就是有已知结果的，从这个已知结果入手，去推导能获得最大概率的结果参数，只要我们得出了这个参数，那我们的模型就自然可以很准确的预测未知的数据了。（对极大似然函数的详细理解可以参考：https://blog.csdn.net/qq_44543774/article/details/109735754）
通过极大似然推导得出逻辑回归的目标函数，这里我给出手写的推导：
极大似然函数是概率论在统计学中的应用，它提供了一种给定观察数据来评估模型参数的方法，即 “模型已定，参数未知”，通过若干次试验，观察其结果，利用实验结果得到某个参数值能够使样本出现的概率为最大，则称为极大似然估计。通过求极大似然函数来得到参数w的估计值。
以上就是通过极大似然函数作为目标函数，得出了参数向量w值
综上logistic回归模型的目标函数是极大似然函数
五.算法源码 源码：
from sklearn.linear_model import LogisticRegression from math import exp from math import * from sklearn.datasets import load_iris from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8cc1dd8e86774d3e6d176e1b1246e53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66e52d0f1ad6b2c881c7bf2fd555abd2/" rel="bookmark">
			各向异性滤波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本原理 各向异性扩散滤波主要是用来平滑图像的，克服了高斯模糊的缺陷，各向异性扩散在平滑图像时是保留图像边缘的，和双边滤波很像。各向异性扩散也叫P-M扩散，各向异性扩散(Anisotropic diffusion)的算法可以详见论文：《Scale-space and edge detection using anisotropic diffusion》
通常我们有将图像看作矩阵的，看作图的，看作随机过程的。各向异性扩散滤波将图像看作热量场了。每个像素看作热流，根据当前像素和周围像素的关系，来确定是否要向周围扩散。比如某个邻域像素和当前像素差别较大，则代表这个邻域像素很可能是个边界，那么当前像素就不向这个方向扩散了，这个边界也就得到保留了。
论文有具体的推导公式，都是热学上的，这里只介绍一下最终结论用到的公式。主要迭代方程如下：
I就是图像了，因为是个迭代公式，所以有迭代次数t。
四个散度公式是在四个方向上对当前像素求偏导，news就是东南西北嘛，公式如下：
而cN/cS/cE/cW则代表四个方向上的导热系数，边界的导热系数都是小的。公式如下：
其中g函数是
最后整个公式需要先前设置的参数主要有三个，迭代次数t，根据情况设置；导热系数相关的k，取值越大越平滑，越不易保留边缘；lambda同样也是取值越大越平滑。
示例演示 各向异性滤波可以用于做人像美颜磨皮算法。工程代码链接
#include &lt;opencv2/opencv.hpp&gt; #include &lt;iostream&gt; using namespace cv; using namespace std; float k = 15; float lambda = 0.25; int N = 20; void BilateralFilter(Mat &amp;image, Mat &amp;result); int main(int argc, char** argv) { Mat src = imread("D:\\TestData\\lena.jpg"); if (src.empty()) { printf("could not load image...\n"); return -1; } namedWindow("input image", CV_WINDOW_AUTOSIZE); imshow("input image"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66e52d0f1ad6b2c881c7bf2fd555abd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56423a6616b99f60a80dfbd5a2aca130/" rel="bookmark">
			网段划分 &amp;&amp; 教你如何在一个有500台PC以上的局域网配置IP、子网掩码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于ip地址我们前面通过多次文章，大家都有一定的理解，不过通过的留言，有部分朋友还是对子网掩码、ip地址的网段有些疑问，那么今天我们一起来解下这方面的内容。
一、什么是子网掩码？
在了解ip地址的网段之前，我们先来了解子网掩码，很多对网络了解不深的朋友都对子网掩码有些迷惑， 不了解它是用来干什么的？
子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。
说的通俗的话，就是用来分割子网和区分那些ip是同一个网段的，那些不是同一网段的。
例如，两个人都叫张三，但一个张三是张家村的，另一个张三是张村的，那么如何区分这两个张三分别是属于那个村的呢？得让村长来区分，就可以准确的把各自的张三领回村，那么子网掩码就相当于村长，它就是用来区分ip该ip地址是属于那个网段的。
在实际项目中，我们通常会遇到这样的ip地址。
ip地址：192.168.1.1 子网掩码：255.255.255.0
ip地址：192.168.1.2 子网掩码：255.255.255.0
我们可以直接的判断，他们是同属于一个网段的ip地址。
那么对于下面这样的呢？
ip地址：192.168.1.1 子网掩码：255.255.255.0
ip地址：192.168.1.2 子网掩码：255.255.0.0
这两个ip地址虽然在不看掩码的情况下，比较像，但他们并不是同一个网段内的。
这个可以从子网掩码来判断，
192.168.1.1 255.255.255.0是属于192.168.1.0网段的。
而192.168.1.2 255.255.0.0是属于192.168.0.0网段。
二、如何根据掩码来确定ip地址网段
上面我们已经举例了解了子网掩码的作用，接下来我们再来了解如何确定子网掩码和判断ip地址的网段。
通常我们在划分vlan的时候会使用以下例子：
例1：
创建vlan1：ip地址：192.168.1.1 子网掩码：255.255.255.0
创建vlan2: ip地址：192.168.2.1 子网掩码：255.255.255.0
那么他们是不是在同一个网段呢？平时配置ip地址较多的朋友，可以直观的判断，他们并不是属于同一个网段，那么如何计算呢？要想判断两个ip地址是不是在同一个网段，只需将ip地址与子网掩码做与运算，如果得出的结果一样，则这两个ip地址是同一个子网当中。
详细计算
将ip地址192.168.1.1转换为二进制
11000000 10101000 00000001 00000001
将子网掩码255.255.255.0转换成二进制
11111111.11111111.11111111.00000000
然后将两者相“与（and）"运算：
11000000 10101000 00000001 00000001
11111111.11111111.11111111.00000000
然后得到：
11000000 10101000 00000001 00000000
转换成网络号就是：192.168.1.0
将ip地址192.168.2.1转换为二进制
11000000 10101000 00000010 00000001
将子网掩码255.255.255.0转换成二进制
11111111.11111111.11111111.00000000
然后将两者相“与（and）"运算：
11000000 10101000 00000010 00000001
11111111.11111111.11111111.00000000
然后得到：
11000000 10101000 00000010 00000000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56423a6616b99f60a80dfbd5a2aca130/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e749e66e74dfa4c72c16c0be8c03060/" rel="bookmark">
			python 格式化打印print常见用法（更新中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 格式化打印print常见用法 1.一般打印1.1打印到控制台1.2 打印到文件 2.格式化打印2.1 % 方法2.1.1 格式化常用符号2.1.2 格式化操作符辅助命令 2.2 .format（）方法 参考文章 最近一段时间，经常在用到print格式化或模式化输出的时候，不是弄混了用法，就是忘记了一些格式。现在，将常用的例子和符号给自己做一次总结。以便下一次忘了时候方便查找。 1.一般打印 也就是我们最简单的打印，不需要格式化的用法。
1.1打印到控制台 我们最最经常的用法就是将程序的结果在控制台上显示，我们可以用print打印各种数字、字符串、变量等。大家耳熟能详，不再一一举例展示。
Python 3.8.1 &gt;&gt;&gt; t=[1,2,3] &gt;&gt;&gt; print(t) [1, 2, 3] 1.2 打印到文件 除了在控制台显示结果外，我们有的时候还需要将结果打印到指定文件中。这种用法也是大家都很熟悉的：
f = open('filename','w',encoding='utf-8',errors='ignore') ……省略中间过程 print(i,file=f) f.close() 2.格式化打印 2.1 % 方法 也就是通过%加特殊符号来对要打印的内容进行格式化，用法如示例代码：
&gt;&gt;&gt; print('%d' % 10.1) 10 2.1.1 格式化常用符号 %c	格式化字符及其ASCII码 %s	格式化字符串 %d	格式化整数 %u	格式化无符号整型 %o	格式化无符号八进制数 %x	格式化无符号十六进制数 %X	格式化无符号十六进制数（大写） %f	格式化浮点数字，可指定小数点后的精度 %e	用科学计数法格式化浮点数 %E	作用同%e，用科学计数法格式化浮点数 %g	%f和%e的简写 %G	%f 和 %E 的简写 %p	用十六进制数格式化变量的地址 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e749e66e74dfa4c72c16c0be8c03060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/542d763fb1ff323ddf5f237cd173d0f5/" rel="bookmark">
			openstack安装问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前序 研究生半年干了什么？最多的事就是运维hhh，实验室项目要求，安装openstack，进行运维，如果机器好点还好，有些机器真的是不行，一天天的崩，来来回回估计安装过两三次，分别在centos7，ubuntu16，ubuntu18上进行过安装，运维过程中遇到过各种头秃的问题，但就是这样之后，能力才能提升。。。，下面我将详细介绍一下我的学习流程，以及当时按照哪个博客进行安装的，遇到的问题，以及有些难理解的稍微说一下，同时也方便我几年后再次接到类似需求能够快速回炉重造。
openstack安装 官方文档 openstack官方安装文档
这个文档基本包含了非常全的安装过程，那个系统应该用哪个版本什么的，非常全，当然这个是那种分布式结点啊，服务分别安装的，也可以是一键安装，就那种DevStack工具，听说不太稳定，我就没采用，如果就是为了学习openstack的话，而不是项目要用，完全可以采用一键安装。
openstack安装指导
这个就是类似博客一样的过程，非常详细，只要照着安装就行，就是过程中会遇到各种各样的问题，整个一个纠错的过程就是自己成长的过程，首先查看日志，找到错误error是什么，到google去查，一般都会找到解决方法。
具体安装 总共有这么多个服务需要安装：
有两个网络，一个内网用来管理，一个外网进行访问（也可以一个网络，就是openstack启动会创建网桥，这样你就出现一些网桥没映射网卡等问题，不过也可以解决）ntp时间同步(所有node)安装train版yum源（所有node）安装客户端（所有node）安装数据库(controller)安装消息队列服务(controller)安装memcache(controller)安装etcd(controller)安装keystone身份认证服务(controller)安装glance服务(controller)安装placement放置服务(controller)（好像ubuntu系统安的那个版本，不用这个服务）安装nova计算服务(控制结点)安装nova计算服务(计算节点)安装neutron网络服务(控制节点)安装neutron网络服务(计算节点) centos系统 安装openstack的Train版本
配置：一台控制结点，三台计算结点，一个存储结点
当然当时安装的时候，还是决定不全看官方文档，就害怕有一些坑，就连着网上的博客和官网文档对照的一起来弄，刚开始是比较慢的，后面就快了，当时参考的博客有两个：
暗香流行风缥缈
实力捍卫尊严あ
unbuntu系统 不同版本的ubuntu系统，安装的openstack版本也略有差异，下图来自官方文档
配置：一台控制结点， 两台计算结点，这个配置高点，opensatck比较稳定
安装流程 我自己也写了一个环境搭建的过程文档，但肯定没有官网的全，完全可以去网上找到详细地安装文档，我等会会记述运维遇到的问题（这个是真实遇到的，很具有参考性）。关键的是那个，很有用。我这个没脱敏，一些密码没改，涉及到密码复用的安全问题，我还是不放链接了。
网络理解 我记得当时网络这里没理解什么意思，所以这里记录一下。
其中最主要的就是网络部分，因为可以选择两种，一种是提供商网络，一种是自助服务网络
提供商网络：由admin创建，普通用户或租户不能建立自己的局域网（需要加路由），相当于只有一个网络，不能建局域网，就没有NAT选项了，只有桥接网络。自助服务网络：普通租户可以创建自己的子网，自己的路由，租户的子网依托在admin的提供商网络上，admin也可以创建自己的网络。既可以桥接，也可以用NAT。 日志 因为排错还是非常需要日志的，通过日志找到错误，然后利用搜索引擎找到解决方法。主要是下面两个日志出错：
nova日志
nova-api.log：用户与OpenStack交互以及OpenStack组件间交互的消息相关日志nova-compute.log：虚拟机实例在启动和运行中产生的日志nova-scheduler.log：有关调度的，分配任务给节点以及消息队列的相关日志nova-conductor.log：nova-compute和数据库操作均通过conductor实现nova-consoleauth.log：关于nova-console服务的验证细节nova-manage.log：运行nova-manage命令时产生的日志nova-novncproxy.log：关于nova的VNC服务的详细信息 Neutron日志
dhcp-agent.log：关于dhcp-agent的日志l3-agent.log：与l3代理及其功能相关的日志neutron-metadata-agent.log：通过neutron代理给Nova元数据服务的相关日志openvswitch-agent.log：与openvswitch相关操作的日志项，在具体实现OpenStack网络时，如果使用了不同的插件，就会有相应的日志文件名neutron-server.log：与Neutron API服务相关的日志 问题以及解决方法 现在就是有一个需求，当前服务器有两个网卡，一个网卡连接的内网，不能上网，一个网卡连接的路由器，可以利用这个网卡上网，但是呢，我这边内网连接还想用ssh连接，还想能上网，因为一个机器只能有一个默认网关（可能也有设置的方法，但是我不知道。。。)，怎么办呢？
解决： 新建一个路由表，在这个路由表中添加内网的网关作为该路由表的默认网关，主机的默认路由表就用路由器的那个网关就行，linux下建立多网卡多网关 //其中10段是内网，192段是连接的路由器的局域网 //增加路由表 echo "100 Intranet" &gt;&gt; /etc/iproute2/rt_tables //每个路由表里面建立默认网关 sudo ip route add default via 10.15.196.1 dev eno1 table Intranet //增加路由原路返回规则，使来自不同的口的走不同的路由表 sudo ip rule add from 10.15.196.125 table Intranet //添加192段为默认路由，可以访问外网 sudo route add default gw 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/542d763fb1ff323ddf5f237cd173d0f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03f9508b4d6dd1367d4bae5724bcf9e7/" rel="bookmark">
			Qt事件：定时器事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qt中的定时器除了实用QTimer之外，凡是继承了QObject的对象都可以使用定时器事件。
1、开启定时器：
int QObject::startTimer(int interval, Qt::TimerType timerType = Qt::CoarseTimer)
返回值是定时器ID。
参数1是时间间隔，可以有几种写法：
最常用的是直接写数字，单位是毫秒标准库时间： using namespace std::chrono; startTimer(milliseconds(50));//毫秒 startTimer(seconds(1));//秒 startTimer(minutes(1));//分钟 标准库时间字面值常量 c++自定义类型的字面值常量 using namespace std::chrono_literals; startTimer(100ms); startTimer(5s); startTimer(2min); startTimer(1h); 参数2是定时器精度：
Qt::PreciseTimer 精密计时器试图保持毫秒的精确度Qt::CoarseTimer 粗计时器试图将精度保持在所需间隔的5%以内Qt::VeryCoarseTimer 非常粗糙的计时器只能保持完全的秒精度 在UNIX（包括Linux、macOS和iOS）上，Qt将保持Qt::PreciseTimer的毫秒精度。对于Qt::CoarseTimer，间隔将调整到5%，以使定时器与预期在同一时间或大约在同一时间触发的其他计时器对齐。其目的是使大多数定时器同时唤醒，从而减少CPU唤醒和功耗。
在Windows上，Qt将使用Windows的多媒体定时器工具（如果可用）来实现Qt::PreciseTimer，并使用普通Windows定时器来实现Qt::groassetimer和Qt::VeryCoarseTimer。
在所有平台上，Qt::VeryCoarseTimer的间隔四舍五入到最接近的整秒（例如，23500ms的间隔将四舍五入到24000ms，20300ms将四舍五入到20000ms）。
2、定时器事件
void timerEvent(QTimerEvent *event) { int id = event-&gt;timerId(); if(id == xx) { //do something } } 3、停止定时器
void QObject::killTimer(int id)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b28d814bade314e6702c1e698fab8617/" rel="bookmark">
			Windows更改鼠标滚轮方向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目前Windows10系统设置里没有可以更改鼠标滚轮方向方向的选项，默认方向是非自然方向，Mac OS默认是自然方向且可更改。
Windows更改滚轮方向方法：
打开 Registry Editor 注册表编辑器；打开目录 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Enum\HID；里面很多项，依次打开，找到 Device Parameter，有FlipFlopWheel选项的，将其置为1，即为自然滚动；因为不确定哪一个是当前鼠标设备的选项，只能全部查看一下，如果自己能查看设备参数也可以去找对应的选项。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d5f69af9a06167dfcac701d5e80f235/" rel="bookmark">
			用 Python  分分钟让旧照片修复清晰
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		翻开家里的的相片册，可以看到每张照片都是那么的弥足珍贵，特别是很久以前的照片，都是美好的回忆，还有那些年错过的场景，都被记录下来了，不过可惜的是，随着时间的流逝，照片可能泛黄，出现划痕，画质损失等等，那么这时候，如果可以让这些老旧的照片修复回来，那就忒棒啊！
如何使用呢？今天小编和你一起玩一下，把旧照片修复清晰。
在此之前，确保你的电脑有：
Python3的运行环境
GPU或着CPU
环境准备 首先将微软的「Bringing-Old-Photos-Back-to-Life」库 clone 到本地：
git clone https://github.com/microsoft/Bringing-Old-Photos-Back-to-Life.git
下载 Synchronized-BatchNorm-PyTorch 接着进入项目文件，进入 「Face_Enhancement/models/networks/」，把「Synchronized-BatchNorm-PyTorch」clone下来：
clone https://github.com/vacancy/Synchronized-BatchNorm-PyTorch
同样的，在「Global/detection_models」下同步下载 「Synchronized-BatchNorm-PyTorch」：
下载 landmark detection pretrained model 进入 「Face_Enhancement」，使用 wget 命令下载地标检测预训练模型：
wget http://dlib.net/files/shapepredictor68facelandmarks.dat.bz2
接着解压：
bzip2 -d shapepredictor68facelandmarks.dat.bz2
下载训练模块 进入「Face_Enhancement」，使用 wget 下载：
wget https://facevc.blob.core.windows.net/zhanbo/oldphoto/pretrain/FaceEnhancement/checkpoints.zip
接着解压一波：
unzip checkpoints.zip
进入 「Global」，下载：
wget https://facevc.blob.core.windows.net/zhanbo/old_photo/pretrain/Global/checkpoints.zip
同样解压一波：
unzip checkpoints.zip
创建 python3 虚拟环境 python3 -m venv .venv
source .venv/bin/activate
安装项目依赖库 pip3 install -r requirements.txt
至此，我们该安装都特么安装完成了，接下来就可以使用了。
修复没有划痕的老照片 我们可以创建两文件夹，分别用来存放旧照片和生成的修复照片：
比如你要修复这样的旧照片：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d5f69af9a06167dfcac701d5e80f235/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce9afa6ba7e0a9990adb9979b77b1289/" rel="bookmark">
			无法部署应用目录 [D:\Tomcat\apache-tomcat-9.0.44\webapps\ROOT]java.lang.IllegalStateException: 启动子级时出错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起因是刚开始导入一个web项目，没有导入Tomcat的jar包，导致找不到javax.servlet.http 和 javax.servlet.jsp，看了下网上的建议，将Tomcat7.0\lib下的el-api.jar、jsp-api.jar这两个jar包放到Java\jdk1.8.0_131\jre\lib\ext目录下，导入jar后没有报错了。还有一个报错，是因为从Tomcat8转到Tomcat7,需要修改一个配置文件，在项目下.settings\org.eclipse.wst.common.project.facet.core.xml文件下Tomcat的那行配置删除。
项目是没有错误之后，在Tomcat上启动，就开始报下面的错误：
java.lang.NoClassDefFoundError: Could not initialize class org.apache.jasper.el.ELContextImpl 看了很多，都说是使用Activiti时，关于Could not initialize class org.apache.jasper.el.ELContextImpl问题，是由于jar包冲突导致的，但是我没有导入Activiti的jar包，
我开始寻找问题，看见有的说是Tomcat版本和jdk版本不一致导致的，我又下载了Tomcat的8.5和9.0版本。但是发现问题没有丝毫解决，甚至更多了，出现了下面的问题：
13-Mar-2021 19:17:23.253 信息 [main] org.apache.catalina.startup.HostConfig.deployDirectory Web应用程序目录[D:\Tomcat\apache-tomcat-9.0.44\webapps\manager]的部署已在[47]毫秒内完成 13-Mar-2021 19:17:23.269 信息 [main] org.apache.catalina.startup.HostConfig.deployDirectory 把web 应用程序部署到目录 [D:\Tomcat\apache-tomcat-9.0.44\webapps\ROOT] 13-Mar-2021 19:17:23.284 严重 [main] org.apache.catalina.startup.HostConfig.deployDirectory 无法部署应用目录 [D:\Tomcat\apache-tomcat-9.0.44\webapps\ROOT] java.lang.IllegalStateException: 启动子级时出错 发现虽然本地启动会报错，但是Tomcat服务器可以启动，不过http://localhost:8080/访问会出现404的报错，搜遍网上也没找到原因，最后还是切回Tomcat7.0，
发现没有报上面的错误，但是在http://localhost:8080/访问会出现500的报错，报的是这个错误：
javax.servlet.ServletException: java.lang.NoClassDefFoundError 然后参考了这个文章：https://blog.csdn.net/qq_39188306/article/details/89672188
解决办法： 1、进入你tomcat安装目录：我的是D:\Tomcat7.0\lib，找到el-api.jar包；
2、找到你安装使用的JDK版本目录，我的是在C:\Program Files\Java\jdk1.8.0_131\jre\lib\ext目录下；
3、将tomcat中的el-api.jar包拷贝到JDK安装目录下的jre/lib/ext目录下（如果已经存在，请覆盖）；
按这样的方法解决了，但是总觉得不对劲，这不是我刚开始导入的Tomcat7.0\lib下的el-api.jar、jsp-api.jar这两个包流程吗？
然后我将Java\jdk1.8.0_131\jre\lib\ext目录下el-api.jar、jsp-api.jar和servlet-api.jar三个jar包删除，然后运行发现问题完美解决，然后又使用Tomcat的8.5和9.0版本
发现都可以正常访问http://localhost:8080/
总结：不要随便向Java\jdk1.8.0_131\jre\lib\ext目录下放 jar包，容易导致Tomcat服务器启动时出现jar冲突，出现java.lang.NoClassDefFoundError: Could not initialize class org.apache.jasper.el.ELContextImpl的异常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a12204c5918618067b5fc25ed29be6fb/" rel="bookmark">
			将指定excel的一列数据提取到另一个excel的指定列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/usr/bin/env python import openpyxl bj='D:/地市县公司/西藏台账数据分析-设备台帐分析.xlsx' wb = openpyxl.load_workbook (bj) get_sheets = wb.sheetnames #print(get_sheets) TA01='TA01' TA02='TA02' TA03='TA03' TE01='TE01' YG201='YG201' YG202='YG202' YG203='YG203' YG204='YG204' YG205='YG205' a=0 max=0 for name in get_sheets: ws = wb[name] sheet = wb.active a = 0 num=1 for row in ws: if not all([cell.value == None for cell in row]): num += 1 i=0 b = [] total=0 while i &lt; num: if TE01 == name: # b.insert(i, ws.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a12204c5918618067b5fc25ed29be6fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/992dde315259f5c0cedee444220ba66c/" rel="bookmark">
			springboot集成spring security实现登录和注销
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、导入坐标二、Users实体类及其数据库表的创建三、controller，service，mapper层的实现四、核心–编写配置文件五、页面的实现运行结果 一、导入坐标 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.3&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.zsh&lt;/groupId&gt; &lt;artifactId&gt;springsecurity&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springsecurity&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;2.3.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/992dde315259f5c0cedee444220ba66c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba9f766219b9b743a72136b51dc77d79/" rel="bookmark">
			信号槽连接和断开的几种常用形式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		connect 一、使用SIGNAL()和SLOT()宏的形式： [static] QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection)
1、创建从发送方对象中的信号到接收方对象中的方法的给定类型的连接。返回连接的句柄，稍后可用于断开连接。
2、指定信号和方法时，必须使用SIGNAL()和SLOT()宏，例如：
QLabel *label = new QLabel; QScrollBar *scrollBar = new QScrollBar; QObject::connect(scrollBar, SIGNAL(valueChanged(int)),label, SLOT(setNum(int))); 3、signal和slots参数不能包含任何变量名，只能包含类型。
4、一个信号也可以连接另一个信号。
5、一个信号可以连接到多个槽和信号。多个信号可以连接到一个槽。
6、如果信号连接到多个槽，则在信号发出时，插槽的激活顺序与连接的顺序相同。
7、如果成功地将信号连接到槽，则该函数返回一个QMetaObject::Connection，表示连接的句柄。如果连接句柄无法创建连接，例如，如果QMetaObject无法验证信号或方法的存在等则该连接句柄将无效。
8、默认情况下，每一个连接发出一个信号，重复连接将发出两个信号。可以通过一次disconnect()调用来断开所有的重复连接。如果传递Qt::UniqueConnection类型，则只有在连接不是重复时才会进行连接。如果已经有重复的（同一对象上的同一插槽的信号完全相同），则连接将失败，connect将返回无效的QMetaObject::Connection。
注意：Qt::UniqueConnections不适用于lambdas、非成员函数和函数对象。仅适用于连接到成员函数。
9、参数5描述要建立的连接类型。特别地，它确定特定信号是立即发送到插槽，还是在排队等待处理。如果信号排队，参数必须是Qt元对象系统已知的类型，因为Qt需要复制参数以将它们存储在队列事件中。如果尝试使用排队连接并获得以下错误消息：
QObject::connect: Cannot queue arguments of type 'MyType'(Make sure 'MyType' is registered using qRegisterMetaType().)
则在建立连接之前，调用qRegisterMetaType()注册数据类型。
二、函数指针的形式 [static] QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type = Qt::AutoConnection)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba9f766219b9b743a72136b51dc77d79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ef08d984c5bbf039a8bbb4e86524e54/" rel="bookmark">
			4面阿里、3面拼多多归来，分享个人总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里一面： 1：自我介绍
2：面：谈谈你做过项目中印象较深或自认为做的比较好的地方?
答：我觉得我在Xx做的不错，用了XX需求实现XX功能，性能提高了N倍…等噼里啪啦的说了一堆。
3：面：你说使用到了AOP，能谈谈它的实现原理嘛?
答：它是依靠动态代理实现的，动态代理又分为JDK自身的以及CGLIB…
4：面：嗯，能说说他们的不同及优缺点嘛?
答：JDK是基于接口实现，而CGLIB继承代理类。。。（就是这样会直问下去，如果聊的差不多了就开始问一些零散的问题）
5：JMM内存模型，如何划分的?分别存储什么内容?线程安全与否?
6：类加载机制，谈到双亲委派模型后会问到哪些违反了双亲委派模型?为什么?
7：为什么要双亲委派?好处是什么?
8：平时怎么使用多线程?有哪些好处?线程池的几个核心参数的意义?
9：线程间通信的方式?
10：HashMap的原理：当谈到线程不安全时自然引申出ConcurrentHashMap，它的实现原理？
11：分库分表如何设计?垂直拆分、水平拆分?
12：业务ID的生成规则，有哪些方式?
13：SQL调优?平时使用数据库有哪些注意点?
14：当一个应用启动缓慢如何优化?
15：对乐观锁和悲观锁的理解；
其他的想不起来了，大概是以上这些，最后还简单的聊了之前做过得项目上的问题，
结束之前告诉我之后会换一个同事和我沟通，听到这样的回复一面应该就这样过了。
一面小结 首先确认对阿里的意向度（如果异地更会考虑对工作地点(杭州）的意向度！阿里很看重这个）；
其次面试官一般会针对您所做过的项目来做具体技术的交流，会比较关注个人对项目细节是不是掌握到位，
主要考察java的技术基础和原理，比如Spring框架以及数据库和JVM三个方面，也会交流到分布式、线程池的实现等等
重点考察是不是有比较钻研技术和技术上的亮点【不一定每个面都很厉害但一定要有亮点】
阿里二面 1：变着法的问了一大堆线程池的知识 （主要考对应的参数）
2：java内存模型
3：lock和synchronized的区别
4：B+树和B-树的区别
5：复合索引
6：聚集索引和非聚集索引的区别？
7：数据库索引 主键和唯一索引有什么区别
8：索引失效条件，什么时候该建立索引
9：innDB和MyISAM的区别？
10：线程安全（阻塞同步，非阻塞同步，无同步）
11：说说Java 类加载过程？
12：描述一下 JVM 加载 Class 文件的原理机制?
13：GC 是什么? 为什么要有 GC？
14：简述 Java 垃圾回收机制。
15：如何判断一个对象是否存活？（或者 GC 对象的判定方法）
16：垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
17： stop() 和 suspend() 方法为何不推荐使用？
18：sleep() 和 wait() 有什么区别?
19：同步和异步有何异同，在什么情况下分别使用他们？
20：简述 synchronized 和
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ef08d984c5bbf039a8bbb4e86524e54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12c7e12b19e1b3e5ef1dcc0057c56838/" rel="bookmark">
			iOS布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 2021年也在奋力的学习iOS开发呀，一些自己踩到的小坑也可以说是常用解决方案吧，记录分享。
1.UIButton设置图片后点击无响应 UIButton点击无响应的原因有很多，最近我遇到一个问题是因为设置图片尺寸过小的原因。
一次UI改版中，漂亮的UI小姐姐给的Button切图比以前的切图要小很多，没关系，我是自己长大的程序员，我可以设置Button属性为setBackgroundImage，就可以根据尺寸随意调整大小啦；OK，Button的样式显示非常nice！
Button点击事件调试中，为什么触发率这么低？偶尔点得到、偶尔点击无响应？聪明的我很快意识到是因为Button的尺寸太小而点击不到，如果把button尺寸放大，bgImage尺寸失调不符合UI、如果设置为setImage属性UI切图过小也不行，程序员为难；是找UI小姐姐重新切图还是另寻方法？
解决方案：
设置图片为ImageView，调整图片大小；将图片添加到Button上，完美解决。 如果是你，你会找UI小姐姐重新切图还是独自长大？
2.TableView中嵌套CollectionView滑动冲突 一个合格的程序员总会被UE安排各种混合布局的页面，她想要的样子，我这里都有！
表格布局和流水布局离不开最核心的就是它的滑动，这次遇到的问题比较简单，均是上下滑动、只让tableview滑动，但是滑动时有两个滑动条，设置CollectionView.scrollEnabled = NO;即可。
3.CollectionView的高度自适应 百度一通，全部给我cell如何自适应高度，然后教我如何计算cell的高度！不是不是，
在我复杂而美丽的布局页面中，collection中的section是实时更新的，即collectionView的高度会变化，前面说了嵌套，同时我需要在tableview中根据collectionview的高度变换，实时刷新整个UI布局。
关键点：
设置collectionView布局时，上下左右设置约束即可 [self.collectionView mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(self.view); make.left.right.equalTo(self.view).offset(0); make.bottom.equalTo(self.view); }]; 获取collectionview本身的高度： CGFloat height = _collectionView.collectionViewLayout.collectionViewContentSize.height; 将高度传给tableview @property (nonatomic,copy) void (^refreshCollectionViewHeight)(CGFloat height); if(self.refreshCollectionViewHeight){ self.refreshCollectionViewHeight = height; } 刷新高度 self.collectionView.frame = CGRectMake(0,0,500,400);//随意设置一个高度 self.collectionView.refreshCollectionViewHeight = ^(CGFloat height){ self.collectionView.frame = CGRectMake(0,0,500,height); } [self.tableView reloadData];//刷新视图 现在就很丝滑，是UI想要的样子！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afe30e1d6209fbc80c58426aa550203a/" rel="bookmark">
			C语言求亲密数问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 如果A的全部真因子（包括1，不包括A自身）之和等于B；B的全部真因子之和等于A，则称整数A和B为一对亲密数。
求3000以内的亲密数对，每行输出一对，每对使用空格隔开。
每对亲密数的前一个数为较小数，后一个数为较大数。
#include &lt;stdio.h&gt; int main(void) { int i,b,n; int a=1; while(a&lt;3000) { for(i=1,b=0;i&lt;=a/2;i++) { if(!(a%i)) { b+=i; } } for(i=1,n=0;i&lt;=b/2;i++) { if(!(b%i)) { n+=i; } } if(n==a&amp;&amp;a&lt;b) { printf("%d %d\n",a,b); } a++; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f5c823bf22292967341fc3db7b7c81a/" rel="bookmark">
			第一讲：基本输入输出函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本输入输出函数用法 输出：printf()
输入：scanf()
printf用法（输出） 将变量的内容输出到显示器上
四种用法： 1.printf(“字符串\n”) 2.printf(“输出控制符，输出参数”) eg:
#include&lt;stdio.h&gt; int main() { printf("哈哈\n"); return 0; } #include&lt;stdio.h&gt; int main() { int i=10 printf("%d",i); //d表示十进制 return 0; } 输出结果：10 3.printf(“输出控制符1 输出控制符2…”,输出参数1，输出参数2) eg:
int i=3; int k=5; printf("%d %d",k,j); //V printf("%d\n",j,k); //X 输出控制符和输出参数不匹配，必须一一对应 4.printf(“输出控制符，非输出控制符”，输出参数) 输出（入）控制符：
%d: 十进制 int
%ld: 十进制 long int
%c: 字符型 char
%f: 浮点型 float
%lf: double
%x(%X,%#X): 十六进制 int,long int,short int
%o: 八进制 int,long int,short int
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f5c823bf22292967341fc3db7b7c81a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57f7c096664117950a7ebaa408ae02fd/" rel="bookmark">
			java得到上下文环境,获取Spring的上下文环境ApplicationContext的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web项目中发现有人如此获得Spring的上下环境：
public class SpringUtil {
public static ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
public static Object getBean(String serviceName){
return context.getBean(serviceName);
}
}
在web项目中这种方式非常不可取！！！
分析：
首先，主要意图就是获得Spring上下文；
其次，有了Spring上下文，希望通过getBean()方法获得Spring管理的Bean的对象；
最后，为了方便调用，把上下文定义为static变量或者getBean方法定义为static方法；
但是，在web项目中，系统一旦启动，web服务器会初始化Spring的上下文的，我们可以很优雅的获得Spring的ApplicationContext对象。
如果使用
new ClassPathXmlApplicationContext("applicationContext.xml");
相当于重新初始化一遍！！！！
也就是说，重复做启动时候的初始化工作，第一次执行该类的时候会非常耗时！！！！！
正确的做法是：
@Component
public class SpringContextUtil implements ApplicationContextAware {
private static ApplicationContext applicationContext; // Spring应用上下文环境
/*
* 实现了ApplicationContextAware接口，必须实现该方法；
*通过传递applicationContext参数初始化成员变量applicationContext
*/
public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
SpringContextUtil.applicationContext = applicationContext;
}
public static ApplicationContext getApplicationContext() {
return applicationContext;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57f7c096664117950a7ebaa408ae02fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/218f2fd85ebe1a86c6bb4f38a5a22327/" rel="bookmark">
			ArcGIS道路网拓扑检查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArcGIS道路网拓扑检查 新建拓扑数据集 ​ 新建个人地理数据库“PDB.gdb”，右击新建要素数据集“Topology”，设置要素数据集的坐标系与道路相同，为“GCS_WGS_1984”。
​ 右击要素数据集“Topology”，选择【导入单个要素类】，导入图层“道路”，点击确定，结果如下图所示。
新建拓扑 ​ 点击【新建】→【拓扑】，选择参与拓扑的要素为“道路”，设置道路等级为1，并添加拓扑规则
“道路 - 不能有悬挂点”、“道路 - 不能有伪节点”、“道路 - 不能相交” 其余属性保持默认，点击确定新建拓扑，并立即验证，如下图所示。
​ 进行拓扑检查的最终结果如下。
打开【编辑器】，打开【拓扑】工具条，点击【错误检查器】→【搜索所有规则中的错误】，取消勾选【仅搜索可见范围】，点击确定，可以看到共有2086个错误，如图。
修改拓扑错误 ​ 全选该类错误，右击选择【合并至最长的要素】，进行批量处理，对于无法合并的要素，则右键【标记为异常】，如图。
​ 对于悬挂点，同样全选该类错误，右键选择【修剪】或【延伸】，对于不能进行修剪或延伸的悬挂点，右键选择【标记为异常】，如下图。
​ 对于“不能相交”的错误，全选该类错误，右键【分割】，如下图。
对于不能分割的要素，则右键【标记为异常】，如下图。
验证拓扑 ​ 修改完所有错误后，点击【拓扑工具条】→【验证拓扑】，可以看到拓扑中的所有错误均已修改完毕，验证成功，如下图所示。
视频教程可以参见https://www.bilibili.com/video/BV1t5411K7ds，喜欢就点个关注吧！！！ღ( ´･ᴗ･` )比心
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bed0cf60a419a7fafb996f7ae250313/" rel="bookmark">
			centos 定时重启mysql,linux centos服务器设置自动定时重启的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux centos服务器设置自动定时重启的方法:
例如: 设置每天凌晨5点重启的方法:
使用SSH工具成功登陆服务器后, 运行如下命令:
crontab -e
按Insert键, 进入编辑模式
然后在文档中输入:
0 5 * * * /sbin/reboot
(注意中间的空格, 0 5表示每天凌晨四点重启 以此类推 .. 0 6表示凌晨6点..)
编辑好后按esc键退出编辑模式。
键入 :wq 保存退出
重启crond 服务即可.
service crond restart
输入内容可通过"crontab -l"命令查询刚刚编辑过的命令.
参考
cron是一个linux下的定时执行工具，可以在无需人工干预的情况下执行命令。
crontab命令各个参数的含义：
用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：
minute hour day month week command
其中：
minute： 表示分钟，可以是从0到59之间的任何整数。
hour：表示小时，可以是从0到23之间的任何整数。
day：表示日期，可以是从1到31之间的任何整数。
month：表示月份，可以是从1到12之间的任何整数。
week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。
command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。
linux centos服务器设置自动定时重启的方法
在以上各个字段中，还可以使用以下特殊字符：
星号(*)：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。
逗号(,)：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”
中杠(-)：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”
正斜线(/)：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。
crontab命令详解
1．命令格式：
crontab [-u user] file
crontab [-u user] [ -e | -l | -r ]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bed0cf60a419a7fafb996f7ae250313/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b13356664ebf6fb7abe3b91af6bd0906/" rel="bookmark">
			WIN键失灵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一般就是win键被锁住了，可以用快捷键解锁。
方法一：Fn+(F1-F12某个键，根据品牌不同有区别，一个个试过去) 华为 Fn+F3Cherry Fn+F9外星人 Fn+F6… 方法二：Fn+Win方法三：Fn+PrtSc（ikbc键盘适用）方法四：拔掉键盘，重启电脑。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f3f7b57d58ed88da880fe030870b829/" rel="bookmark">
			canvas的drawImage方法参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言： canvas很有意思的一项特性就是图像操作能力。可以用于动态的图像合成或者作为图形的背景，以及游戏界面（Sprites）等等。浏览器支持的任意格式的外部图片都可以使用，比如PNG、GIF或者JPEG。 你甚至可以将同一个页面中其他canvas元素生成的图片作为图片源。
一旦获得了源图对象，我们就可以使用 drawImage 方法将它渲染到 canvas 里。
drawImage 方法有三种形态： drawImage(image, dx, dy) 在画布指定位置绘制原图
drawImage(image, dx, dy, dw, dh) 在画布指定位置上按原图大小绘制指定大小的图
drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) 剪切图像，并在画布上定位被剪切的部分
参数描述image规定要使用的图像、画布或视频sx可选。开始剪切图片的 x 坐标位置sy可选。开始剪切图片的 y 坐标位置sw可选。被剪切图像的宽度（就是裁剪之前的图片宽度，这里的宽度若小于图片的原宽。则图片多余部分被剪掉；若大于，则会以空白填充）sh可选。被剪切图像的高度（就是裁剪之前的图片高度）dx在画布上放置图像的 x 坐标位置dy在画布上放置图像的 y 坐标位置dw可选。要使用的图像的宽度（就是裁剪之后的图片高度，放大或者缩放）dh可选。要使用的图像的高度（就是裁剪之后的图片高度，放大或者缩放） 看实例（源图片是120*120的） drawImage(image, dx, dy) 在画布指定位置绘制原图 var canvas = document.getElementById("canvas"); canvas.width=240; canvas.height=240; var ctx=canvas.getContext("2d"); var image = new Image(); image.src="./images/head.jpeg"; image.onload=function(){ ctx.drawImage(this,0,0); } 效果如下 可以看到图片没有做任何的处理，直接从0,0位置绘制出来
drawImage(image, dx, dy, dw, dh) 在画布指定位置上按原图大小绘制指定大小的图 var canvas = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f3f7b57d58ed88da880fe030870b829/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaf07e79b6fbb4f220670cec7506de91/" rel="bookmark">
			更换Centos的yum源为阿里云的源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：备份
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
ShellCopy
第二步：下载新的Centos-base.repo 到/etc/yum.repos.d/
#Centos 6版本
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo
ShellCopy
或者
curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo
ShellCopy
#Centos 7版本
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
ShellCopy
或者
curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
ShellCopy
第三步：清除缓存、生成缓存
yum clean all
ShellCopy
yum makecache
原文链接：http://github.crmeb.net/u/defu
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91407571afa4b19f2483a231e473c7a6/" rel="bookmark">
			allegro 走线切换层,布线的时候方便的快捷的换层？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		布线的时候方便的快捷的换层?用默认的option里面选择不是很方便
add via 是否可以：可以ctrl+鼠标点击 只打孔不继续走线；shift+鼠标点击 换层走线
换层可以写.color或者写skill或者录script。
打完孔之后右键选择done就可以只打孔不走线。换层都是在options面板设置，不过可以设置快捷键。
16.6可以自动切换到当前显示的层,,
另外快捷键有可以设置+-号换层的..小编可以查询下别人发的env,应该可以找到~
可以试下把以下加到ENV里。
funckey 1 'pop bbdrill;pop swap;subclass top'
funckey 3 'pop bbdrill;pop swap;subclass top;+'
funckey 4 'pop bbdrill;pop swap;subclass top;+;+'
funckey 5 'pop bbdrill;pop swap;subclass top;+;+;+'
funckey 6 'pop bbdrill;pop swap;subclass top;+;+;+;+'
funckey 2 'pop bbdrill;pop swap;subclass bottom'
同意楼上，不过有更简洁的写法
funckey + subclass -+
funckey - subclass --
按+或者-都可以换层
谢谢分享
錄製腳本，改env，skill等都可以實現。
回头尝试一下 多谢交流
习惯问题
可以把布线命令中的next命令设置成一个快捷键，双击打孔后，按这个快捷键就是只打孔不继续走线；
在布线过程中，按这个快捷键，再点击一下所要换层的线，再按一次这个快捷键，就会切换到目标层了；
用+-切换层有时也挺累，碰到层数多的，可能切好几次
学习一下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd806a10c5bb0d96b53dad8d0ff0d7c9/" rel="bookmark">
			串口服务器常见五大问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		串口服务器提供串口转网络功能，使得串口设备能够立即具备TCP/IP网络接口功能，连接网络进行数据通信，极大的扩展串口设备的通信距离。为了更方便我们操作和使用，今天飞畅科技的小编来为大家介绍下串口服务器常见五大问题解决方案，一起来看看吧！
串口服务器常见的五大问题及解决方案：
串口服务器在工控领域有着非常广的应用，在实际应用过程中也会遇到各种各样的问题，下面小编给您介绍串口服务器经常遇到的问题以及解决方法。
问题一：串口服务器怎么进行配置?
方案：在配置串口服务器之前必须根据自己的应用场景需求开进行。需要配置的参数主要包括串口工作方式、网络参数、设备本身管理信息等，一般串口服务器会提供串口、浏览器网页、管理器多种方式进行配置。
问题二：多个串口服务器做TCP Client时，通过公网连到服务器端，服务器端只有一个开放一个IP端口，要如何实现连接 ?
方案：上位机通过虚拟串口设置为服务器端，通过串口助手调用串口发送的相应指令码给从设备，只要设备ID对应，从设备就会响应。
问题三：在使用虚拟串口传输文件时为什么会出现数据丢失?
方案：数据丢失主要是因为虚拟串口程序结束数据时和向远程设备发送数据时串口传输本身速度不一样，所以才会丢数据。解决方法是可以通过在虚拟程序中的设置“模拟波特率”。
问题四：多台计算机能否同时访问一个串口服务器?
方案：多台计算机同时访问，在轮询状态下，只能有一台计算机与串口服务器相连。并且实现自动轮询，不需要人为设置其他参数。
问题五：如何设置串口服务器的串口和波特率等?
方案：在配置界面里中进入"方案配置"，选中某方案后，进入"串口参数"。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3f710be4e24047d93a044b52d738bc0/" rel="bookmark">
			SpringBoot 中LocalDateTime日期格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 LocalDateTime 在GMT+8 默认格式为 yyyy-MM-ddTHH:mm:ss,如 2021-01-01T10:15:12
比如需要格式化为yyyy-MM-dd HH:mm:ss
1. 方式一
@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8") private LocalDateTime createTime; 2. 方式二：全局配置
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer; import org.springframework.beans.factory.annotation.Value; import org.springframework.boot.autoconfigure.jackson.Jackson2ObjectMapperBuilderCustomizer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; @Configuration public class LocalDateTimeSerializerConfiguration { @Value("${spring.jackson.date-format:yyyy-MM-dd HH:mm:ss}") private String pattern; @Bean public LocalDateTimeSerializer localDateTimeDeserializer() { return new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(pattern)); } @Bean public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() { return builder -&gt; builder.serializerByType(LocalDateTime.class, localDateTimeDeserializer()); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27a7baf4428eab66aea78a911b013711/" rel="bookmark">
			java公共私人4属性,关于java：Getter / Setter与公共列表的私人列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将类中的全局列表设为私有并使用getter和setter方法会更好吗？或者将它公开更好吗？ Java中的标准是什么？
我被教导要将变量设为私有，并且只使用getter和setter方法，但访问公共列表肯定比私有列表更好。
public exampleclassThatContainsTheList.goodieList.add("Candy");
private exampleclassThatContainsTheList.setGoodieList(exampleclassThatContainsTheList.getGoodieList().add("Candy"));
这是我的看法，但当然我更倾向于遵循标准，而不是通过看起来不错的东西。
它是使用私有实例成员以及公共getter / setter的好方法，以避免对变量状态进行不必要的修改。这里setter方法用作安全防护。它提供单点联系。阅读有关封装的更多信息
为什么不使用方法add()来获取对象"Candy"并将其添加到列表中？ classThatContainsTheList.add("Candy");？
虽然不是一成不变的，但得墨忒耳法在这些情况下提供了一些很好的建议。
@AntonH如果我这样做了，我不会被要求添加与集合相关的所有其他方法吗？不是必需的，但如果我打算使用它们，我也可以。
这称为封装。好处很多，但通常属于抽象的范畴。您可以在不破坏依赖类的情况下更改get方法的功能。您无法通过直接成员访问来执行此操作。
@dalawh您可以添加提供所需功能的方法。如果您只需要添加和删除，只需要有方法来执行这些操作。这些方法将以经典方式作用于列表。我不是说它是最好的方式，但可以考虑。
@MarkPeters如果我为私有列表提供getter和setter方法，它最终会是一样的吗？
@dalawh：仅实现客户端需要的优点是您可以在以后更改底层实现细节。例如，如果要将其更改为Set而不是List，则可以执行此操作。但是如果你公开列表并且客户开始依赖，比方说，getGoodieList().get(2)，你就无法做到这一点。
@BoristheSpider我知道这一点，但我不打算在功能上增加额外功能。回到你的陈述;你推荐我私有吗？
@AntonH明白了。
@MarkPeters明白了。
首先，你不应该直接使用public字段，除非它们是常量(static final)字段并确保它们的状态不会改变。应该使用Encapsulation公开它们，以避免类的客户端修改状态。这是一个通过以防御方式实现getter / setter编写自己的框架的示例，以便不改变List的当前状态：
public class Foo {
private List stringList;
public Foo() {
//always initialized, never null
this.stringList = new ArrayList&lt;&gt;();
}
public List getStringList() {
//defensive implementation
//do not let clients to alter the state of the list
//for example, avoiding clear the list through getStringList().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27a7baf4428eab66aea78a911b013711/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cadf553f95b92503743cea743ace8f0a/" rel="bookmark">
			笔记本电脑升级内存指南（如何选择内存条）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先确定你是否要升级内存，在任务管理器看一下内存占了多少
如果在你运行游戏，使用软件的时候超过了70%，那很有必要加上
2、确定是加内存还是换内存，加内存需要有空余卡槽
在任务管理器就能查看
看到1/4了没，这就表示有四个插槽，只有一个已使用。
3、关于容量
①先考虑下你需要的内存是多大（普通用户8G就足够大了，各种专业软件用户请自行百科自己需要多大内存才合适）
②根据容量需要购买。
如果可以的话，最好是买一个与电脑原先内存一样规格的内存条，然后开启双通道（一种让两个同时工作的内存条发挥更好效果的模式），这样效果比较好。
但是也不是一定要双通道，例如你当前内存是2G，目标内存是8G及以上，那最佳选择是2G+8G，而不是强行双通道成2G+2G。
4、查看电脑插口是什么类型
打开CPU-Z（可以官网下载，也可以下载我网盘里的），查询你的内存类型。
链接：https://pan.baidu.com/s/1u8_2I6nSVKD19NfPf_p3Cw 提取码：2uqj
注意一下这两个点
①内存类型 决定你要买的内存条也是要相同类型（一般情况下只有两条相同类型的内存才能一起工作）
②最大内存容量 决定了你能买多大。
ps：
如果你电脑支持DDR3，那也可以两条DDR3或者DDR3+DDR3L或者两条DDR3L。
但如果你电脑仅支持DDR3L，那你只能用两条DDR3L。
DDR3表示第三代标准版1.5V，DDR3L表示第三代低电压版1.35V 。
注：一般2015年后的电脑才有DDR4接口。
5、查一下你内存的频率
例如：1333，1600，2133，2400，在任务管理器同样可以查到。
虽然越高频率，性能越好（当然价格也越高）
但两个不同频率的内存条同时使用，会使高频率的那个调频至低频率。
比如原先是1600，加个1333，效果就是1333，降低了功效；加个2400，效果也只有1600，买亏了。
接着就可以开始剁手啦~~
搜索框输入：笔记本内存 xxG 内存类型 频率
举个栗子：笔记本内存 8G DDR4 2400
就可以买到啦，当然建议大牌子好一些，像金士顿业界排行第一，而且价格也不贵。
PS：怎么装内存条以及怎么开启双通道就去百度对应机型的教程或者问问身边的大神吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f344623d4aa9ef954e76af79546ef9e5/" rel="bookmark">
			Sql server 2016 Always on 实现无域高可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sql server 2016 Always on 实现无域高可用 上一篇：sql server 2016 Always on 无域部署教程 使用三台服务器组成了sql server 高可用，但是基于成本考虑很多情况下我们只有两台服务器，今天就来测试下用两台服务器来组建sql server 高可用。
一、环境准备 ①、服务器及IP规划 主机名IP地址描述sql3.yishoe.com192.168.6.53数据库sql4.yishoe.com192.168.6.54数据库win-cluster192.168.6.56集群侦听IPsqlcluster192.168.6.57sql 高可用侦听IP ②、设置集群节点主机名，每个节点都需要设置 修改hosts文件，文件路径：C:\Windows\System32\drivers\etc
192.168.6.53 sql3.yishoe.com 192.168.6.54 sql4.yishoe.com 192.168.6.56 win-cluster.yishoe.com 192.168.6.57 sqlcluster.yishoe.com 直至可以使用主机名互相ping通
③、防火墙放行 注：两台服务器都需要放行
3.1、开启ICMP回显已检测服务器是否可以ping通
3.2、放行1433（Sql Server数据库端口）/5022（数据库镜像端口）
3.3、开启WMI、及远程相关应用和功能防火墙放行。（生产环境不建议关闭防火墙）
回显开启，方便测试服务器是否通达
故障转移集群需要允许通过防火墙
④、安装Windows Failover Cluster Feature（win 故障转移集群） 注：两台服务器都需要安装
⑤、安装sql server 注：两台服务器单独安装
二、创建Win 故障转移集群 ①、使用powershell创建故障转移集群 管理员启动powershell
New-Cluster –Name win-cluster -Node sql3.yishoe.com,sql4.yishoe.com -AdministrativeAccessPoint DNS -StaticAddress 192.168.6.56 创建完成
–获取集群名
Get-Cluster
–群集详情
Get-ClusterResource
②、验证集群高可用 先ping一下试试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f344623d4aa9ef954e76af79546ef9e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4b868aa84ca13a5563552af17663f7c/" rel="bookmark">
			人人都想了解的BGP，路由策略这样处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BGP路由策略处理流程 前言Routing Information Base（RIB）Route ProcessingBGP Adjacent in RIBInput PolicyBest path SelectionBGP Local RIBOutput PolicyBGP Adjacent out RIB 前言 路由协议，套用IT里面的术语，实际上就是分布式数据库系统，它包含了节点间的数据传递和节点内的数据处理。对于BGP来说，节点间基于TCP（端口179）的连接，在这个基础上，可以构建AS间的EBGP，AS内的IBGP，IBGP有full mesh，BGP路由反射器等，这些都是BGP节点之间的连接方式，这次看看BGP router内部是如何处理数据。
BGP是一种path vector路由协议，对比其他类的路由协议，path vector随路由携带的辅助信息更多，处理也稍微复杂一些。
Routing Information Base（RIB） RIB其实是设备商的术语。或许不太恰当，但是Global RIB可以对应操作系统里面的路由表。Global RIB和路由表都决定IP packet的三层转发的路径。RIB除了存放路由条目，还保存一些路由协议相关的辅助信息。除了Global RIB，每个路由协议都有自己的RIB，这样，路由协议可以将一些生（Raw）数据与真正应用的数据进行隔离。BGP维护几个RIB，包括了：
BGP Adjacent In RIB：保存所有接收到的BGP Message，这里可能存在多条BGP Message指向同一个目的IP prefixBGP Local RIB：保存经过处理和运算得到的最优BGP Message，对于同一个目的IP prefix，只存在一条最优的BGP MessageBGP Adjacent out RIB：保存将要发送给BGP Peer的BGP Message BGP协议收发的数据不会直接写到Global RIB里，而是放到了BGP自己的RIB里面，在适当的时候写入Global RIB，前面说过，这样可以实现数据隔离，有选择的将BGP数据写入主路由表。BGP的三个RIB保存着不同处理阶段的BGP Message，为不同阶段的操作提供数据。接下来过一下BGP路由处理过程。
Route Processing BGP Adjacent in RIB 这一步比较简单，来者不拒，所有收到的BGP Message都存到了BGP Adjacent in RIB
Input Policy input policy会完成两部分工作，filtering和manipulation。
Filtering会根据Path Attribute过滤BGP Message，这里需要注意两个内置的过滤，一个是判断当前的AS是否在BGP Message的AS_PATH中，如果在的话，那么这是一条之前已经经过当前AS的Message，这条Message会被过滤。另一个会判断BGP Message里的NEXT_HOP是否可达，如果不可达，那么这条Message会被标成Invalid，也会被过滤。除了内置的过滤，用户（对，就是网工）和控制程序也可以添加过滤规则，例如通过route-map，access-list，distribution-list等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4b868aa84ca13a5563552af17663f7c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/323/">«</a>
	<span class="pagination__item pagination__item--current">324/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/325/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>