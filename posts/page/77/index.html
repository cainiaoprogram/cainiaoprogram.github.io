<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aa77a5a50a9356d1052123077f42561/" rel="bookmark">
			小猫爪：S32K3学习笔记02-S32K3之FlexCAN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		S32K3学习笔记02-S32K3之FlexCAN 1 前言2 CAN协议简介2.5 CAN资源介绍3 FlexCAN简介3.1 MB（邮箱）系统3.1.1 正常模式下3.1.2 激活了CAN FD情况下3.1.3 激活了Legacy RX FIFO情况下3.1.4 激活了Enhanced RX FIFO情况下 3.2 过滤机制3.2.1 **标准x邮箱**的过滤器3.2.2 Legacy RX FIFO的过滤器3.2.3 Enhanced RX FIFO的过滤器 3.3 匹配机制 4 CAN MCAL配置4.1 时钟源的选择4.2 波特率的设置4.3 Can ID Message Type4.4 Polling vs Interrupt4.5 使能FIFO4.6 DMA+CAN4.7 Filter的配置4.7.1. 标准邮箱的Filter配置4.7.2. Legacy FIFO的Filter配置4.7.3. Enhanced FIFO的Filter配置 5 CAN MCAL例程下载END 1 前言 努力学习一下S32K3的CAN外设，CAN的使用场景还是非常多的，特别在汽车电子更是主流的通信网络，下面就基于S32K3的FlexCAN模块学习一下CAN的相关知识以及S32K3有关CAN的MCAL配置示例。
2 CAN协议简介 CAN的基本协议在这里就不多说啥了，网上资料巨多，随便搜一搜就有了。在这里贴出几个推荐的文章供大家参考：
《CAN通信协议(一)》《CAN数据链路层的帧格式介绍——数据帧和远程帧》《CAN-FD协议浅析》 CAN进阶篇：《CAN、CAN-FD 错误帧 Bus-Off 排查定位》
2.5 CAN资源介绍 关于S32K3系列的FlexCAN资源请详见下表：
3 FlexCAN简介 NXP的FlexCAN外设IP如果按我来评价的话，那是巨复杂，下面就让我们一点点的拨开它。下面框图为FlexCAN的功能框图。
功能框图乍一看上去那是非常的简单，其中：
名称描述BIU可以理解成是一个总线接口控制器，用来做信号连接的，啥时钟信号，数据信号，中断信号等等信号CHI可以理解成是FlexCAN的控制中心PE可以理解成是控制中心的执行机构RAM一段专门给FlexCAN使用的RAM空间，用来存储收发的报文，也就是MB（message buffer） 就是这个简单的框图里面包含的东西巨复杂，巨恐怖，继续往下看。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4aa77a5a50a9356d1052123077f42561/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbc7f1285b84427b53df324bf582dc05/" rel="bookmark">
			Spring AOP源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、AOP是什么
2、AOP 的作用及其优势
3、AOP 的底层实现
3.1 JDK动态代理：
3.2 CGLIB动态代理
4、AOP相关概念
5、AOP运行流程图
6、AOP源码解析
6.1 源码解析须知
6.2 注册自动代理创建器
6.3 触发后置处理器
6.4 创建Proxy过程分析
6.5 代理回调增强
6.6 增强器执行
6.7 增强器执行顺序
7、源码总结
1、AOP是什么 AOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。
AOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。
直接看一个例子：
业务接口及其实现
public interface UserService { public void login(String name ,int length); } @Service public class UserServiceImpl implements UserService { public void login(String name, int length) { System.out.println("-----我是一个接口,我的信息：用户-" + name + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbc7f1285b84427b53df324bf582dc05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e8b0eaa7f07ea5b5c7ef7b12497a65b/" rel="bookmark">
			阿里面试官内部题库！阿里发布2023年Java社招岗(正式版)面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里巴巴2023年Java架构师岗面试题（正式版） 这不马上就是金三银四的面试跳槽季了嘛，糖糖老师也是通过一些小手段为大家拿到了一份阿里巴巴2023年Java架构师岗面试题（正式版）现在分享给大家，这份资料也是阿里面试官或者说业界的一份面试参考准则！
大致目录参考 由于文章的篇幅有限，所以老师这里只为大家展示部分题目目录的截图以及太过基础的问题老师这里就不给大家截图浪费大家时间了。
JVM篇 JVM在执行Java程序时，会把它管理的内存划分为若干个的区域，每个区域都有自己的用途和创建销毁时间。如下图所示，可以分为两大部分，线程私有区和共享区。
虚拟机为什么使用元空间替换了永久代？
「什么是元空间？什么是永久代？为什么用元空间代替永久代？」 我们先回顾一下「方法区」吧,看看虚拟机运行时数据内存图，如下:
高并发编程篇 线程池原理知道吗？以及核心参数
MySQL篇 ZooKeeper篇 注意：回答面试题，切忌只是简单一句话回答，可以将你对概念的理解，特点等多个方面描述一下，哪怕你自己认为不完全切中题意的也可以说说，面试官不喜欢会打断你的，你的目的是让面试官认为你是好沟通的。当然了，如果不会可别装作会，说太多不专业的想法。
Redis篇 网络篇 HTTP1.0、HTTP1.1、HTTP2.0的关系和区别
最后的最后需要领取这套面试题PDF解析+视频解析+全部大厂面试题汇总的同学麻烦帮忙点赞之后，然后私信【学习】或关注工众号【小柴学Java】都可领取更多资料
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3b58a6ed04d90fa0bba5920729d673a/" rel="bookmark">
			uniapp开发微信小程序uview里的u-upload组件上传图片点击没反应，开发者工具点击正常，正式上手机上点击没反应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 用uniapp开发的微信小程序，uview插件ui，u-upload上传文件，上传头像等方法，早就审核发布过的突然反应上传图片，文件啥的点击没反应 问题描述 原因分析： 根据查资料得知可能是因为小程序隐私协议的变动，需要在小程序后台网站上找到 用户隐私保护指引 点击进去更新隐私配置
解决方案： 把这里的关于上传图片的，访问相册的等等权限信息类型都增加上去，并写明用途之后，点击确认生成协议，提交过后显示审核中，这个审核过程大概需要几十分钟，耐心等待，审核通过后即可，成功之后你删除掉小程序重新登录会有一个用户隐私保护提示，选择拒绝或者同意，点击同意之后就能点击上传文件了
备用方案：
上面的东西弄完后还不行，重新上传审核代码，在提交的时候提交审核按钮上方同样有更新隐私保护内容，点击进去更新，一样的操作，提交审核即可
成功后新版微信登录会弹出用户隐私保护弹框，点击同意
官方隐私协议更改链接：https://developers.weixin.qq.com/miniprogram/dev/framework/user-privacy/PrivacyAuthorize.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf59e269421444c3c55d96611f9b7e45/" rel="bookmark">
			纯CSS实现卡片上绘制透明圆孔
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div class="dot-card-wrapper"&gt; &lt;div class="top-wrapper"&gt; &lt;slot name="top"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;!--&gt;核心是下面这部分&lt;/--&gt; &lt;div class="dot-row"&gt; &lt;div class="left-block"&gt;&lt;/div&gt; &lt;div class="color-block"&gt;&lt;/div&gt; &lt;div class="right-block"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="bottom-wrapper"&gt; &lt;slot name="bottom"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt;&lt;/script&gt; &lt;style lang="scss" scope&gt; .dot-card-wrapper { box-shadow: -4px 0px 4px 4px rgba(93, 109, 137, 0.15); position: relative; .top-wrapper, .bottom-wrapper { background: #ffffff; } .dot-row { $dotSize: 10px; display: flex; align-items: stretch; .color-block { background-color: #fff; flex: 1; height: $dotSize * 2; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf59e269421444c3c55d96611f9b7e45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26cbe74241da247c7055631768980186/" rel="bookmark">
			数据表 设计、规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命名规范 所有数据库对象名（库名、表名、字段名），必须使用小写字母并用下划线分割，避免使用数据库关键字、预留字，即使要使用也应该用反引号包裹。常见的数据库关键字、预留字如下
DATA FILE TEXT DESC STATUS TYPE KEY KEYS VALUE VALUES LEVEL 字段类型选择 1、少用TEXT，避免使用BLOB。
mysql内存临时表不支持text、blob这样的大字段类型，如果查询中包含大字段，排序等操作就不能使用内存临时表，会强制生成硬盘临时表进行操作。mysql是以页为单位存储数据的，含有大字段时容易出现跨页存储、加载数据，导致频繁进行磁盘IO，严重影响数据库性能。不建议直接存储在数据库中，占用空间，使用起来也低效。
文件之类的二进制数据，尽量使用专门的文件服务器进行存储，数据表中保存文件地址。如果非要在数据表中存储大字段，也尽量把大字段拆分到单独的扩展表中。
2、避免使用ENUM枚举类型
相比于tinyint之类的普通类型，enum需要额外处理，操作效率低。
3、避免使用 NULL 字段，尽量指定默认值。
null字段做比较、计算需要特殊处理，null字段的复合索引无效，难以对null字段进行查询优化；null字段加索引后，每条记录都需要1个字节的额外存储空间；在代码层面需要进行大量判空，容易造成NPE。 字段使用规范 1、没有特殊需求的情况下，数据表尽量都使用 Innodb 存储引擎，支持事务、行级锁，更好的恢复性，高并发下性能更好。
2、尽量控制单表字段数、数据量。
字段数越多，把表装载进内存缓冲池时所占用的内存也就越大，会消耗更多的IO，建议单表字段数上限不超过20~50个，可以拆分冷热字段、大字段作纵向分表，避免加载大量冷门字段数据、大体积字段数据，尽量让一行数据在一页中，减少IO次数，避免翻页加载。建议控制单表数据量的大小在500万以内，过大会造成修改表结构，备份，恢复都会有很大的问题。可以归档历史数据（应用于日志数据）、分库分表（应用于业务数据）等手段来控制数据量大小，可以按时间（年月日）、地区、主键范围等做横向分表。 3、少用 text 类型，避免使用 blob 类型，如果大字段类型很多，尽量拆分到单独的数据表中。大字段类型，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时 通常存储于文件服务器，数据库只存储文件地址信息。
4、金额财务等需要精确存储的数值字段，可以作为整型存储的就使用整型，比如金额可以采用最小单位分来存储，存储为整型，涉及到小数存储的，float、double表示浮点数有误差，一律使用decimal，以保证精度。
eg. decimal(20,2) 总长度20位，小数部分2位
5、手机号、密码、身份证号、银行卡号等敏感数据加密存储
6、避免在数据库直接使用外键，添加外键后关联表的写操作需要额外处理，会拉低性能，外键尽量在业务代码中自行维护。
7、insert 语句都应该指定要操作的字段列表。
8、设计表时，如果记录会发生变化，则应该考虑添加 create_time、update_time 字段；如果涉及状态变更，则应该考虑添加 status 字段；如果需要后续需要用到变更前的数据，则考虑在数据变更时通过流水表之类的方式记录快照。
字段约束 1、InnoDB根据主键建立聚簇索引（数据的物理存储顺序和索引顺序相同），InnoDB引擎的表推荐使用有序递增的数值作为主键列, 避免字符串做主键，便于InnoDB引擎对主键列建立聚簇索引。
2、避免使用外键、级联更新，有业务代码自行维护关联关系、关联更新。
使用外键有额外开销，数据变化时需要加锁处理关联的其它表的记录，影响数据库的插入效率，高并发时容易造成死锁；级联更新是强阻塞，存在数据库更新风暴的问题。
索引使用原则 1、谨慎合理添加索引
添加索引是为了改善查询，索引不是越多越好，索引可以提高效率也可能降低效率，添加索引会减慢插入、更新，甚至有些情况下会降低查询效率。mysql优化器会对每一个可能用到的索引进行评估，生成出一个较好的执行计划，如果索引比较多，会增加评估、生成执行计划的时间，会降低查询性能。综合评估数据密度和数据分布，最好不超过字段数20%，最好不要超过5、6个，结合核心SQL优先考虑覆盖索引，值重复率高的字段不适合建索引。
1、对索引进行函数转换、计算时会导致无法使用索引，尽量不对索引字段做函数、表达式计算。
不管是不是索引字段，都尽量不要在数据库做运算，尽量在业务代码层计算。
2、避免使用%前缀模糊查询
例如LIKE “%name”或者LIKE “%name%”，这种查询会导致索引失效而进行全表扫描。但是可以使用LIKE “name%”。
3、避免负向查询
负向查询主要有 !=、&lt;&gt;、NOT EXISTS、NOT IN、NOT LIKE等，否则引擎放弃使用索引而进行全表扫描。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26cbe74241da247c7055631768980186/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb8b2c0b17bc31e3b2881d77316aa549/" rel="bookmark">
			MySQL 锁机制、存储引擎、数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 数据库锁的分类mysql的存储引擎MyISAMInnoDB mysql常用数据类型数值型字符串日期时间二进制数据关于 enum 枚举 mysql标识符命名规则mysql中utf8、utf8mb4字符集的区别关于null 数据库锁的分类 数据库本身也提供了一些锁，按加锁方式分为
乐观锁：需要增加一个额外的版本号字段，标识记录的数据版本，提交更新时校验数据版本是否一致。实际并没有加锁，并发支持好。悲观锁：数据库本身提供的锁机制，直接调用相关语句即可，可细分为排它锁、共享锁。操作之前需要先加锁，并发支持差。
按照读写权限分为
排它锁：又叫做写锁、X锁，同一时刻，最多只能被一个线程持有，最多只能有1个线程对加锁的这块数据进行读写。共享锁：又叫做读锁、S锁，同一时刻，可以被多线程共同持有，可以有多个线程同时对加锁的这块数据进行读，但读的同时所有线程都不能对这块数据进行写操作，进行写操作需要等对这块数据的所有读操作都完成、共享锁被释放。 排它锁、共享锁都是数据库提供的锁机制，直接调用数据库的相关语句即可。
共享锁可能发生死锁问题：一块数据已经加了共享锁，如果一个事务先对这块数据进行读，再进行写，写操作需要等待共享锁释放才能执行，而这个事务的写操作尚未执行，事务没有提交，一直持有共享锁，写操作永远等不到共享锁释放，即造成了死锁。
其它线程等待获取锁，如果等待指定时间后还没获取到锁，会抛出超时等待异常。
按锁粒度分为
行级锁：针对行加锁，加锁慢；锁粒度小，并发支持好。表级锁：直接给整张表加锁，加锁快；锁粒度大，并发支持差。间隙锁：对InnoDB引擎的表进行范围查找时，给整个范围区间加锁，区间上不存在的行也会被加锁。 eg. where id&gt;=1 and id&lt;=10，操作id在[1,10]上的记录，会给[1,10]整个id区间加锁，加锁范围的整个区间，不仅仅只是区间上存在的记录。
假设之前删除了id=5、id=8的记录，这2行不存在的记录即间隙，也会被锁住，暂时不能被其它线程访问。
mysql的存储引擎 mysql提供了多种存储引擎，最常见的有2种：MyISAM 、InnoDB 。
MyISAM 不支持事务、外键使用表级锁，不支持行级锁，并发支持差。读时自动给表加上读锁（也叫作共享锁），其它事务可以读、但不能写，其它事务要执行写操作需要等待表被释放；写时自动给表加上写锁（也叫作x锁、排它锁），其它事务不能读、写，直到表被释放。支持全文索引，但全文索引一般用ES、Solr，基本不使用mysql的全文索引
MyISAM是5.5之前默认的存储引擎，适合创建
不需要事务、不使用外键的表主要进行读操作的表。由于MyISAM写时要加表锁，性能差，所以不适合创建频繁增删改的表 InnoDB 支持外键。mysql的存储引擎中只有InnoDB支持外键支持事务。默认的事务隔离级别是可重复读默认使用行级锁（通过MVCC实现），也支持表级锁，并发支持好。读时自动给使用的行加读锁，写时自动给使用的行加写锁。
InnoDB是mysql5.5及其之后的默认存储引擎，适合创建
需要使用外键的表对安全性要求高、要使用事务的表频繁增删改的表
执行insert、update、delete语句之前，InnoDB会自动给涉及到的数据集加排它锁，但只有在sql语句走索引时加的排它锁才是行锁，表没有建立索引或者sql语句没有走索引时加的排它锁是表锁。
InnoDB的行锁是给索引中的行加锁，表锁是给数据表中的行加锁。行锁的性能远高于表锁，尽量让sql语句走索引，一来可以快速定位记录位置，二来借助行锁可以实现更高的并发。
mysql常用数据类型 数值型 数据类型描述tinyint1字节，-128 ~ 127。如果指定无符号，则为0~255，下列的其它整型可依此类推smallint2字节，正负3w+mediumint3字节，正负800w+int 或者 integer4字节，正负21亿+bigint8字节，正负900千万亿+float单精度，4字节，10的-38次方double双精度，8字节，10的-308次方decimal定点型 整型不能指定最大存储位数，但可以指定显示位数，需要和 zerofill 搭配使用才有效，超过指定位数时完整展示，长度不够时自动在开头补0凑齐位数，示例 status tinyint(4) zerofill not null comment '状态'。型的显示位数比较鸡肋，不建议指定。
float、double有误差，如果对精度要求很高，比如涉及到钱财，用decimal。
float 、decimal、decimal 都可以指定最大总位数、小数部分固定位数，示例：float(4,2)，总位数最多4位，小数部分固定2位，就是说整数部分最多2位
#小数部分位数不足时，自动在末尾补0 1.1 =&gt; 1.10 #整数部分位数超出时，即超出能存储的最值时，不会报错但会有warning，自动取能存储的最值 111.1 =&gt; 99.99 #整数部分位数ok，小数部分位数超出时，不会报错也没有warning，会自动对小数超出部分四舍五入，以满足小数部分的位数要求 11.1111 =&gt; 11.11 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb8b2c0b17bc31e3b2881d77316aa549/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cc7e9d7914c3237b2b850c6fc74bbb9/" rel="bookmark">
			输入一行字符，分别统计出其中英文字母、空格、数字和其他字符的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt;
int main()
{
char c;
int zimu=0,kongge=0,shuzi=0,qita=0;
printf("请输入字符:\n");
while((c=getchar())!='\n')//注意：其中c=getchar()需要用括号扩起来！
{
if(c&gt;='a'&amp;&amp;c&lt;='z'||c&gt;='A'&amp;&amp;c&lt;='Z')
{zimu++;}
else if(c==' ')
{kongge++;}
else if(c&gt;='0'&amp;&amp;c&lt;='9')//数字也需要打单引号！
{shuzi++;}
else {qita++;}
}
printf("字母个数是%d个\n空格个数是%d个\n数字个数是%d\n其他字符个数是%d个\n",zimu,kongge,shuzi,qita);
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c63f5e96e0e72fa0dc12bcd901054f2b/" rel="bookmark">
			【PHPCUSTOM】打包PHP程序为EXE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、下载PHPCUSTOM
二、PHP网站打包
1、打开PHPCUSTOM
2、配置参数
3、生成exe文件
网上很多PHP程序打包成EXE的文章，但是都不能用，最后找到了PHPCUSTOM，使用PHPCUSTOM可以把PHP程序打包成exe。我们都知道PHP是服务端语言，需要运行环境apache、MySQL、PHP，而PHPCUSTOM工具本质就是把这些运行环境打包起来，搭建一个本地环境，把项目入口套上个exe的外壳，打开exe其实还是调用浏览器运行项目。
一、下载PHPCUSTOM PHPCUSTOM免费下载地址（不想看预告和介绍内容就往下拉） - 网站相关 - lccee_技术网
下载完成后，无需安装，直接打开PHPCUSTOM.exe即可，需要注意的是保存路径不能是汉字。
二、PHP网站打包 1、打开PHPCUSTOM 选择“功能大全”-&gt;“精品工具”-&gt;”PHP网站打包“
2、配置参数 选择服务器：和原项目保持一致PHP版本：和原项目保持一致，如果版本不一致，可以首页-&gt;网站管理里面下载网站目录：此目录是原项目的目录，选择到根目录。如果是ThinkPHP框架选择到public的上一级目录，系统会自动以public为根目录生成位置：就是生成的exe存放位置，存放在不含有中文的目录下简单生成网站包：生成文件包含源代码封装源码生成EXE文件：生成文件内不包含源代码 3、生成exe文件 根据需要选择生成模式，生成之后文件夹下会有PHPCUSTOM_Pack.exe，点击exe就可以运行项目了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cefa31df730ffd8ba41924ed6e00d341/" rel="bookmark">
			propertyEditor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类型转化类
1、JDK自带的工具类
继承PropertyEditorSupport，实现PropertyEditor
2、向Spring中（CustomEditorConfigurer）注册PropertyEditor
最终实现 @Value的功能
spring自带的类型转化类
1、实现ConditionalGenericConverter
2、向DefaultConversionService注册该实现类
整合了PropertyEditor和ConversionService的功能
SimpleTypeConverter converter = new SimpleTypeConverter();
converter.registerCustomEditor(User.class,new StringToUserPropertyEditor());
User user = converter.convertIfNecessary("12", User.class);
System.out.println(user);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a534a690640387592f3a8ce883eb8973/" rel="bookmark">
			青龙面板APP： 2.0.3版本（2023-11-02）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件介绍 青龙面板是支持python3、javaScript、shell、typescript 的定时任务管理面板。本APP基于青龙面板接口开发，支持面板大部分原生功能 ，同时提供拓展模块，帮助用户快捷管理。
使用环境 安卓版本：8.0+面板版本：参考下表，选择合适软件版本 软件版本开发API 面板版本
备注1.x.x2.10.132.10.x仅支持2.10.x2.0.x2.10.13、2.15.17 全部，建议2.15.x
部分版本可能出现部分功能不可用2.1.0+2.10.13、2.15.17全部，建议2.15.x未发布，停止维护2.10.x版本，部分版本可能出现部分功能不可用 功能介绍 基础功能 提供定时任务、环境变量、配置文件、脚本管理、依赖管理、任务日志和系统设置功能，更多详细介绍请前往项目主页查看。
定时任务：支持增改删查、批量操作、查看日志、查看脚本、任务去重、本地备份和本地导入；环境变量：支持增改删查、批量操作、变量去重、快捷导入、本地备份和本地导入；配置文件：支持查看和修改配置；依赖管理：支持新建、删除、批量操作和查看日志；脚本管理：支持查看、编辑和删除脚本；任务日志：支持查看日志文件列表；系统设置：支持常规设置和登录日志查看； 拓展模块 拓展模块将在后续版本逐步开放，具体使用方法请查看相应文档。
Web助手 Web开发者工具，提供代码调试、cookie查看等功能。
Docker助手 docker容器可视化操作，提供容器操作、运行查看等功能。
LanProxy 网络开发工具，提供内网穿透、流量转发功能具体，使用请查看文档。。
界面预览 更新日志 修复服务地址解析异常修复已知场景闪退异常优化代码和部分细节 下载地址 本APP为开源项目，如需进行二次开发，拉取仓库即可。 Giteehttps://gitee.com/wsfsp4/QingLong
Githubhttps://github.com/FuShengPing/android-qinglong APP下载地址 giteehttps://gitee.com/wsfsp4/QingLong/releases
交流反馈 如果你在使用过程中发现Bug或者有功能需求请创建Issue。
欢迎加入QQ交流群，可以获取到最新的软件资讯和最快的问题反馈！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cc3a89057e3ea405e6cf83e96a79da5/" rel="bookmark">
			步进电机最简单的驱动方法_步进电机控制方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最简单的步进电机驱动方法是单相双极驱动方式，也称为双相步进驱动方式。该方式只需要使用一个 H桥驱动器和一个脉冲发生器，即可实现步进电机的驱动控制。
具体的驱动过程如下：
将步进电机的两个相连接到 H桥驱动器的两个输出端口。
将脉冲发生器连接到 H桥驱动器的输入端口，通过控制脉冲的频率和占空比，可以控制步进电机的转速和方向。
通过控制脉冲的数量和频率，可以控制步进电机旋转的步数和转角。
需要注意的是，单相双极驱动方式只能实现单个步进电机的基本驱动控制，对于需要高精度、高速度和高扭矩的应用场景，需要采用更复杂的驱动方式和控制算法。
步进电机控制方法
步进电机的控制方法主要有以下几种：
单步控制：单步控制是最基本的控制方式，即每次只控制电机旋转一个步距角度，通过单步控制可以实现较为简单的运动控制，但精度较低。
半步控制：半步控制是在单步控制的基础上，每次控制电机旋转半个步距角度，通过半步控制可以实现更高的控制精度。
微步控制：微步控制是将电机每一步距分成更小的微步距，通过对电机控制信号的精细调节，实现更高的控制精度。微步控制需要使用特殊的微步驱动器，通常可以实现较高的分辨率和精度。
闭环控制：闭环控制是通过反馈系统来实现精确的位置和速度控制，通常需要配合伺服驱动器和编码器等设备使用。闭环控制可以实现更高的控制精度和稳定性，但成本较高。
需要注意的是，不同的控制方法适用于不同的应用场景和精度要求，具体的选择需要根据具体应用需求进行选择。同时，控制电路的设计和实现也需要根据不同的控制方法进行相应的调整和优化。
步进电机的优点
步进电机有以下优点：
高精度：步进电机的旋转角度可以精确控制，通常可以达到 1.8 度的精度，因此在需要高精度定位的场合使用较多。
稳定性好：步进电机由于采用磁力作为驱动力，没有机械接触，因此运行稳定，噪音低。
简单控制：步进电机的驱动方式简单，只需要发出相应的脉冲信号就能控制步进电机转动，且不需要进行速度和位置的反馈控制。
低速高扭矩：步进电机的转矩与转速成反比，因此在低速运行时能够提供较高的扭矩，可以适应负载较大的应用场合。
可靠性高：步进电机结构简单，寿命长，因此运行可靠性高。
价格低廉：相对于伺服电机等其他控制方式，步进电机价格较为低廉，因此在一些应用场合使用较多。
综上所述，步进电机在一些需要精确定位、低速高扭矩、稳定可靠等场合具有一定的优势。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aba7c62662202318daaa3ede576d8c4f/" rel="bookmark">
			【python】SQLite3的简单使用（创建数据库、数据表、增删改查、修改字段）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.说明 sqlite是一款轻型的SQL类型数据库，处理速度快且占用资源非常低，所以非常适合存储本地数据，据说处理速度比Mysql、PostgreSQL还快。目前Django默认的数据库就是SQLite3
2.导入模块 python3就已经内置了sqlite，所以我们不用额外安装，直接导入即可
import sqlite3 3.使用步骤 # 因为是本地文件，所以只需指定db文件位置即可，如果该文件不存在它会自动创建 # 也可以使用":memory:"代替文件路径，则存储在内存里而不是数据库文件 conn = sqlite3.connect('./data/eth_gas_price.sqlite3') # 获取游标 cur = conn.cursor() # 执行SQL cursor.execute("SQL") # 获取查询结果 cur.fetchone() # 取出第一条,返回元组或None cur.fetchall() # 取出所有（返回列表套元组或空列表） cur.fetchmany(6) # 取出指定数量（返回列表套元组或空列表） # 提交（如果有DML操作则需要提交事务才生效） conn.commit() # 受影响行数 cur.rowcount # 记得关闭游标和连接，避免内存泄露 cur.close() conn.close() 3.举例 3.1 创建数据库 import sqlite3 from sqlite3 import OperationalError conn = sqlite3.connect('./data/eth_gas_price.sqlite3') cur = conn.cursor() try: sql = """CREATE TABLE gas_price ( id integer primary key autoincrement, coin_name varchar(15) not null, low integer, avg integer, high integer, c_time integer );"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aba7c62662202318daaa3ede576d8c4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d373c1f51b13ca07b39eb207a41920f7/" rel="bookmark">
			就在国庆假期，一小时轻松入账600元的副业案例你想知道怎么回事吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		就在国庆假期，一小时轻松入账600元的案例你想知道怎么回事吗？
下面详细给你说说整个过程：
通过朋友介绍接了一个用AI绘制12张图工作；
刚开始害怕达不到对方要求，专门先试画了两张，没想到客户非常满意，立刻付200元定金，确定了这次合作，大概一小时就完成了12张图的绘制。
对方看到图后立马转款完成了交易。
下面是我参考提示词画出的另外的12张图：
思考： AI绘画是一个充满机会和潜力的领域。下面从多方面对AI绘画的好处和机会进行分析和总结：
效率的显著提升： AI绘画大大提高了绘图效率，使原本需要一天时间完成的工作能在几分钟内完成。这种效率的提升不仅能节省时间，还能让绘画师有更多时间投入到更高层次或更有创意的工作中。
成本的显著降低： 由于AI绘画大大减少了人力和时间的投入，制作成本也随之降低。根据描述，手绘的成本从500-2000元/张降到了50元/张，这对于影片策划制作等行业来说，降低了制作成本，同时也为客户提供了更为实惠的价格。
质量和技术的提升： AI绘画能够生成逼真的颜色和三维效果，提高了绘图的质量和技术水平。通过AI技术，可以实现传统手绘难以达到的效果。
市场需求的提升： 成本的降低和效率的提升可能会刺激更多的市场需求。比如，影片策划和制作行业可能会有更多的项目愿意尝试使用AI绘画，而不是传统的手绘。
学习和使用的便捷性： 对于传统的绘画师和没有绘画基础的普通人来说，AI绘画提供了一个快速学习和提升的渠道。通过简单的培训，个人可以快速掌握AI绘画技术，进一步拓宽了人们的技能范围。
创新和艺术的发展： AI绘画为艺术和创新提供了新的可能。它不仅可以辅助艺术家创作，还能为那些想要尝试新技术的人提供平台。通过AI的辅助，艺术家可以探索前所未有的创意和技术，推动艺术领域的进步。
个人和企业的新机遇： AI绘画为个人和企业提供了新的商业机会和副业选择。随着技术的进步和普及，越来越多的人和组织可能会选择利用AI绘画开展业务，创造新的价值。
AI绘画的发展不仅仅局限于提高效率和降低成本，它的出现也为艺术领域、教育培训、影视制作等多个领域带来了新的机遇和可能，推动了技术和艺术的融合发展。同时，它也为普通人提供了学习和创新的平台，降低了绘画技能的门槛，使更多人能够享受到绘画和创作的乐趣。
我还曾通过AI绘画制作过建筑效果图： 利用ChatGPT和Midjourney AI应用轻松生成概念设计创意方案
关于AI绘画技术储备 学好 AI绘画 不论是就业还是做副业赚钱都不错，但要学会 AI绘画 还是要有一个学习规划。最后大家分享一份全套的 AI绘画 学习资料，给那些想学习 AI绘画 的小伙伴们一点帮助！
对于0基础小白入门：
如果你是零基础小白，想快速入门AI绘画是可以考虑的。
一方面是学习时间相对较短，学习内容更全面更集中。
二方面是可以找到适合自己的学习方案
包括：stable diffusion安装包、stable diffusion0基础入门全套PDF，视频学习教程。带你从零基础系统性的学好AI绘画！
零基础AI绘画学习资源介绍 👉stable diffusion新手0基础入门PDF👈 （全套教程文末领取哈）
👉AI绘画必备工具👈 温馨提示：篇幅有限，已打包文件夹，获取方式在：文末
👉AI绘画基础+速成+进阶使用教程👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
温馨提示：篇幅有限，已打包文件夹，获取方式在：文末
👉12000+AI关键词大合集👈 这份完整版的AI绘画全套学习资料已经上传CSDN，朋友们如果需要可以点击下方链接免费领取【保证100%免费】 CSDN大礼包：《全套AI绘画基础学习资源包》免费分享
CSDN大礼包：《全套AI绘画基础学习资源包》免费分享
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59b6268a2cc6f3055b1256230a3265be/" rel="bookmark">
			Unity Perception合成数据生成、标注与ML模型训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线工具推荐： Three.js AI纹理开发包 - YOLO合成数据生成器 - GLTF/GLB在线编辑 - 3D模型格式在线转换 - 3D场景编辑器
任何训练过机器学习模型的人都会告诉你，模型是从数据得到的，一般来说，更多的数据和标签会带来更好的性能。 收集数据，尤其是标记数据非常耗时，因此成本高昂。 因此，机器学习专业人士越来越多地寻求通过使用人工生成的数据样本变体来“增强”其数据集的更有效方法，但也越来越多地使用混合或完全合成的数据。
游戏引擎公司 Unity 提供了一个名为 Unity Perception 的工具，它允许你以不同的方式模拟对象并拍摄模拟的虚拟图片。 通过这种方式，可以从对象扫描中生成大量标记图像，这些图像可用作训练数据。
另一种更好的方法是使用UnrealSynth 虚幻合成数据生成器，基于虚幻引擎开发的UnrealSynth渲染效果极其逼真，并且自动标注生成的图像，非常方便：
官网：https://tools.nsdt.cloud/UnrealSynth
在这篇博文中，我介绍了我在 ML6 实习的结果，在此过程中我研究了使用 Unity Perception 为对象检测模型生成训练数据。 更具体地说，我将描述我如何：
使用激光雷达相机获得物体扫描使用 Unity 为这些对象生成合成数据集使用合成图像和真实图像训练目标检测模型评估将合成图像添加到训练集中的潜在好处 1、扫描物体 为了创建对象网格，我在带有激光雷达摄像头的手机上使用了名为 Scaniverse 的应用程序。 为了做好这件事，有一些要求。 你必须能够从各个侧面捕捉物体，并且需要物体的所有角度都有良好且均匀的照明
因此，我将对象放在光线良好的底座上，使用应用程序扫描对象，然后单独拍摄底部表面的照片，将其添加到 Blender 中的对象网格中。 使用 Scaniverse，你可以将对象导出为 fbx 或 obj 文件，两者均可与 Blender 和 Unity 配合使用。
Blender 中的对象扫描示例
然而，并非所有物体都易于扫描。 尤其是具有反射表面、薄或透明部分的物体，使用这种方法进行扫描时会出现问题。 如果扫描结果不太好，仍然可以使用 Blender 进行编辑。
主要用于裁剪和重新调整它们的位置； 或者将它们与底面组合以获得完整的物体。
我还对每个物体进行了多次扫描，以增加合成图像中物体的变化，并在不同的房间和位置为我扫描的每个物体拍摄了大约 200 张照片。 我尝试将这些物体放置在不同的位置，并从不同的角度拍摄照片。 我确保图片有时更加模糊或仅部分显示物体，以进一步增加变化。
下面是我使用过的 3 个物体的扫描图：一只鞋子、一个可口可乐罐和一个家乐氏麦片盒。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59b6268a2cc6f3055b1256230a3265be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/522cb5fba017543eb2a1d7fe0f37a889/" rel="bookmark">
			maven项目active: @profiles.active@报错，idea工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体
08:45:20.671 [main] ERROR org.springframework.boot.SpringApplication - Application run failed org.yaml.snakeyaml.scanner.ScannerException: while scanning for the next token found character '@' that cannot start any token. (Do not use @ for indentation) in 'reader', line 14, column 13: active: @profiles.active@ 解决方案
点击项目，右键
maven &gt;&gt; reload project
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34c91d9898c22b70067b27442ea87973/" rel="bookmark">
			python 无符号左移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 def left_shift(based, counter): val = based &lt;&lt; (counter % 32) maxint = 2147483647 if not -maxint - 1 &lt;= val &lt;= maxint: val = (val + (maxint + 1)) % (2 * (maxint + 1)) - maxint - 1 return val import ctypes def left_shift(x, y): x,y = ctypes.c_int32(x).value,y % 32 return ctypes.c_int32(x &lt;&lt; y).value print(left_shift(2145874521,2)) print(left_shift(2145874521,2)) print(2145874521&lt;&lt;2) # -6436508 # -6436508 # 8583498084 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36d0c2dce003f5f37f9ad5032b4703ce/" rel="bookmark">
			SpringCloud-Alibaba-Seata
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringCloud-Alibaba-Seata 注意：最好使用JDK1.8，使用JDK17整合seata会出现一些问题！！！
Docker部署Seata1.5.2 1：拉取Seata1.5.2镜像： docker pull seataio/seata-server:1.5.2 2：在MySQL数据库上执行下面的SQL，生成Seata所需要的数据库表： -- 创建名为seata的数据库 CREATE DATABASE seata; -- 使用seata数据库 USE seata; -- -------------------------------- The script used when storeMode is 'db' -------------------------------- -- the table to store GlobalSession data CREATE TABLE IF NOT EXISTS `global_table` ( `xid` VARCHAR(128) NOT NULL, `transaction_id` BIGINT, `status` TINYINT NOT NULL, `application_id` VARCHAR(32), `transaction_service_group` VARCHAR(32), `transaction_name` VARCHAR(128), `timeout` INT, `begin_time` BIGINT, `application_data` VARCHAR(2000), `gmt_create` DATETIME, `gmt_modified` DATETIME, PRIMARY KEY (`xid`), KEY `idx_status_gmt_modified` (`status` , `gmt_modified`), KEY `idx_transaction_id` (`transaction_id`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4; -- the table to store BranchSession data CREATE TABLE IF NOT EXISTS `branch_table` ( `branch_id` BIGINT NOT NULL, `xid` VARCHAR(128) NOT NULL, `transaction_id` BIGINT, `resource_group_id` VARCHAR(32), `resource_id` VARCHAR(256), `branch_type` VARCHAR(8), `status` TINYINT, `client_id` VARCHAR(64), `application_data` VARCHAR(2000), `gmt_create` DATETIME(6), `gmt_modified` DATETIME(6), PRIMARY KEY (`branch_id`), KEY `idx_xid` (`xid`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4; -- the table to store lock data CREATE TABLE IF NOT EXISTS `lock_table` ( `row_key` VARCHAR(128) NOT NULL, `xid` VARCHAR(128), `transaction_id` BIGINT, `branch_id` BIGINT NOT NULL, `resource_id` VARCHAR(256), `table_name` VARCHAR(32), `pk` VARCHAR(36), `status` TINYINT NOT NULL DEFAULT '0' COMMENT '0:locked ,1:rollbacking', `gmt_create` DATETIME, `gmt_modified` DATETIME, PRIMARY KEY (`row_key`), KEY `idx_status` (`status`), KEY `idx_branch_id` (`branch_id`), KEY `idx_xid_and_branch_id` (`xid` , `branch_id`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4; CREATE TABLE IF NOT EXISTS `distributed_lock` ( `lock_key` CHAR(20) NOT NULL, `lock_value` VARCHAR(20) NOT NULL, `expire` BIGINT, primary key (`lock_key`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4; INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES ('AsyncCommitting', ' ', 0); INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES ('RetryCommitting', ' ', 0); INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES ('RetryRollbacking', ' ', 0); INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES ('TxTimeoutCheck', ' ', 0); 3：为了获取Seata的配置文件，先运行一下Seata容器： docker run -d --name seata-server-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36d0c2dce003f5f37f9ad5032b4703ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acb690e738942c4665ce24ae4afedb93/" rel="bookmark">
			STM32:AHT20温湿度传感器驱动程序开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：温湿度传感器AHT20数据手册.pdf
http://www.aosong.com/userfiles/files/AHT20%E4%BA%A7%E5%93%81%E8%A7%84%E6%A0%BC%E4%B9%A6(%E4%B8%AD%E6%96%87%E7%89%88)%20B1.pdf
一、分析AHT数据手册文档 (1).准备工作 1.新建工程。配置UART2
2.配置I2C1为I2C标准模式，并开启中断和DMA设置
3.设置工程参数为每个外设初始化生成头文件和源文件，而后生成代码。
(2).根据数据手册，编写AHT20驱动 数据手册中的传感器读取流程如下:
1.上电后要等待40ms，读取温湿度值之前， 首先要看状态字的校准使能位Bit[3]是否为 1(通 过发送0x71可以获取一个字节的状态字)，如果不为1，要发送0xBE命令(初始化)，此命令参数 有两个字节， 第一个字节为0x08，第二个字节为0x00。 2.直接发送 0xAC命令(触发测量)，此命令参数有两个字节，第一个字节为 0x33，第二个字节为0x00。 3.等待75ms待测量完成，忙状态Bit[7]为0，然后可以读取六个字节(发0X71即可以读取)。 4.计算温湿度值 1.第一条的意思是，开机后，要等待40ms才能够与AHT20通信。因此在AHT20建立通信前要等待40ms。而后0x71地址实际上AHT20作为IIC从机的地址。按照AHT20手册，在启动传输后，随后传输的 II C首字节包括 7位的 I I C设备地址0x38。因为IIC通信一般使用7为地址码，但是读写数据都是一个字节一个字节的读写。0x38的七位二进制为0111000。规定从机地址要左一位。多出来的第八位就是读写位。IIC协议规定，如果主机发起通信的目的是为了写从机，那么读写位是0,此时AHT20的地址是01110000，即0x70.如果主机发起通信的目的是为了读从机传入的数据，那么读写位就是1。此时AHT20的地址是0x71。对于第8位的读写设置，HAL库已经帮我们封装好了，所以不用特意去操作。用户只当作AHT20的地址是0x70就行。 2.直接发送信息，略 3.等待75ms后，读取6个字节数据，里面包含了状态信息，湿度信息，和温度信息。其中第0个字节是状态位，需获取bit[7]判断设备是否空闲。而后，湿度数据由20个bit位组成：第1个字节是湿度的高8位，第2个字节是湿度的次高8位.第3个字节的高4个bit位是湿度的低4位。温度数据也由20个bit位组成。第3个字节的低4个bit位是温度的高4位，第4个字节是温度的次高8位，第5个字节是温度的低8位。 4.解析完温度、湿度数据后，进行计算 (3),关键代码 aht.h声明函数, aht.c函数定义如下 #include "aht20.h" #define AHT20_ADDRESS 0x70 //AHT20初始化 void AHT20_Init(){ uint8_t readBuffer; //1.工作前延迟40ms HAL_Delay(40); //2.从AHT20收取一个字节，判断第Bit[3]是否为1 HAL_I2C_Master_Receive(&amp;hi2c1, AHT20_ADDRESS, &amp;readBuffer, 1, HAL_MAX_DELAY); //加上状态位后实际上要判断Bit[4] if( (readBuffer &amp; 0x08)== 0x00){ //如果不为1，要发送0xBE命令(初始化) //发送0xBE命令(初始化)，此命令参数有两个字节， 第一个字节为0x08，第二个字节为0x00。 uint8_t sendBuffer[3] ={0xBE,0x08,0x00}; HAL_I2C_Master_Transmit(&amp;hi2c1, AHT20_ADDRESS, sendBuffer, 3, HAL_MAX_DELAY); } } void AHT20_Read(float *O_Temperature,float* O_Humidity){ //输入触发命令和参数 uint8_t sendBuffer[3] ={0xAC,0x33,0x00}; HAL_I2C_Master_Transmit(&amp;hi2c1, AHT20_ADDRESS, sendBuffer, 3, HAL_MAX_DELAY); //等待75ms测量完成 HAL_Delay(75); //读6个字节 uint8_t readBuffer[6]; HAL_I2C_Master_Receive(&amp;hi2c1, AHT20_ADDRESS, readBuffer, 6, HAL_MAX_DELAY); //其中第0个字节是状态位，需获取bit[7]判断设备是否空闲。为0则不再工作 if((readBuffer[0] &amp; 0x80 )==0x00){ uint32_t tempdata = 0; //湿度数据由20个bit位组成：第1个字节是湿度的高8位，第2个字节是湿度的次高8位.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acb690e738942c4665ce24ae4afedb93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09e7605c30ff5299971399ce5d7eb80d/" rel="bookmark">
			C# 使用Thread类建线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# 使用Thread类建线程 目录 C# 使用Thread类建线程引言Thread类启动线程优先级后台运行线程状态线程名称线程ID最后 引言 线程(thread)是操作系统能够进行运算调度的最小单位。它被包含在进程之中,是进程中的实际运作单位。线程是我们程序常用的并行运行控制手段，进程可以是单线程也可以使多线程，这里我用C# 中的Thread类构建线程来简要地说一下线程的基础使用。
Thread类 Thread类位于System.Threading命名空间下，System.Threading命名空间提供一些可以进行多线程编程的类和接口。Thread类主要用于创建并控制线程、设置线程优先级并获取其状态。
启动线程 Thread类的使用确实方便，受到大部分人的喜爱。看下面代码通过定义myThread为线程对象，定义开始运行的函数为ThreadLoop，Priority属性定义其优先级，IsBackground=true置为后台线程，Name给线程取名。通过Start()方法启动线程。
private void Thread_Start() { Thread myThread = new Thread(new ThreadStart(ThreadLoop))//指定线程函数 { Priority= ThreadPriority.BelowNormal,//指定优先等级 IsBackground = true,//可后台运行 Name = "my_Thread"//线程名 }; //启动线程 myThread .Start(); } public void ThreadLoop() { //打印线程ID Console.Write($" myThread.ID:{myThread.ManagedThreadId}\n"); //打印线程状态 Console.Write($" myThread.state:{myThread.ThreadState}\n"); //休眠 thread.sleep(100); while（true） { } } 优先级 优先级（Priority）指示线程的调度优先级。该类设置的优先级为枚举类型，可以设置也可以随时读取，其从低到高包括Lowest, BelowNormal, Normal, AboveNormal, Highest。
后台运行 通常主线程之外我们会定义为后台线程，即IsBackground = true。前台线程执行完后，不管后台线程有没有执行完毕，都会直接关闭后台进程。
线程状态 线程状态是以枚举位控制的方式表示的， System.Threading.ThreadState 包括有 10个状态
Running = 0x0,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09e7605c30ff5299971399ce5d7eb80d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d06129c7ffa6fcf8d77be3bd0c0c68/" rel="bookmark">
			Opencv实现的三次样条曲线(Cubic Spline)插值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.样条曲线简介 样条曲线(Spline)本质是分段多项式实函数，在实数范围内有： S:[a,b]→R ，在区间 [a,b] 上包含 k 个子区间[ti−1,ti]，且有：
a=t0&lt;t1&lt;⋯&lt;tk−1&lt;tk=b(1)
对应每一段区间 i 的存在多项式： Pi:[ti−1,ti]→R，且满足于：
S(t)=P1(t) , t0≤t&lt;t1,S(t)=P2(t) , t1≤t&lt;t2,⋮S(t)=Pk(t) , tk−1≤t≤tk.(2)
其中， Pi(t) 多项式中最高次项的幂，视为样条的阶数或次数（Order of spline），根据子区间 [ti−1,ti] 的区间长度是否一致分为均匀（Uniform）样条和非均匀（Non-uniform）样条。
满足了公式 (2) 的多项式有很多，为了保证曲线在 S 区间内具有据够的平滑度，一条n次样条，同时应具备处处连续且可微的性质：
P(j)i(ti)=P(j)i+1(ti);(3)
其中 i=1,…,k−1;j=0,…,n−1 。
2.三次样条曲线 2.1曲线条件 按照上述的定义，给定节点：
t:z:a=t0z0&lt;t1z1&lt;⋯⋯&lt;tk−1zk−1&lt;tkzk=b(4)
三次样条曲线满足三个条件：
在每段分段区间 [ti,ti+1],i=0,1,…,k−1 上， S(t)=Si(t) 都是一个三次多项式；满足 S(ti)=zi,i=1,…,k−1 ;S(t) 的一阶导函数 S′(t) 和二阶导函数 S′′(t) 在区间 [a,b] 上都是连续的，从而曲线具有光滑性。 则三次样条的方程可以写为：
Si(t)=ai+bi(t−ti)+ci(t−ti)2+di(t−ti)3,(5)
其中， ai,bi,ci,di 分别代表 n 个未知系数。
曲线的连续性表示为： Si(ti)=zi,(6)
Si(ti+1)=zi+1,(7)
其中 i=0,1,…,k−1 。
曲线微分连续性： S′i(ti+1)=S′i+1(ti+1),(8)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1d06129c7ffa6fcf8d77be3bd0c0c68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f789eb07ec91e9a02043ce027feb35ee/" rel="bookmark">
			与云栖的浪漫邂逅：记一段寻找云端之美的旅程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云端之旅 2023 年的云栖大会如约而至，这次云栖大会也是阿里新任掌门蔡老板当任阿里巴巴董事局主席以来的第一次。大会与以往有很多不一样的地方，其中 AIGC 更是本届大会的重点议题！你会感叹，阿里还是猛啊！
我逛了下展区，ChatGPT 有的，阿里通义千问也基本有了！这就是进步！我在这也深深感受到科技的魅力，发现未来，无限可能！
同时，我在这里经历了许多难忘的瞬间和深深的思考。首先，云栖大会的规模和氛围真的让我印象深刻。来自全球的科技精英们聚集在这里，分享最新的研究成果，讨论未来的发展趋势。每个展台、每个演讲都充满了激情和热情，仿佛置身于一个未来的科技世界。
在云栖大会上，我听到了很多关于人工智能、云计算、大数据等前沿技术的讲解和展示。这些技术不仅在理论上听起来很高级，而且在实践中也具有广泛的应用前景。比如，对标 CoPilot，通义灵码已经支持 Jetbrain 那些常见编译器了。
还有对标 MidJourney，通义万相也可以文生图，或者画几笔生图。在垂直领域，阿里云也有，比如法律、医疗啥的，这种回答问题更精准。甚至开源模型也有，通义千问 72B 版本开源了，这个规模比一些闭源的还大。
除了前沿技术的展示外，云栖大会还让我感受到了科技与人文的结合。在大会的许多角落，都可以看到科技与艺术、文化的融合。比如，一些展台上展示了一些科技与音乐、绘画等艺术形式结合的作品，让人感受到科技不仅可以改变我们的生活和工作方式，也可以丰富我们的精神世界。
在云栖大会上，我也结识了很多志同道合的朋友和行业精英。他们分享了自己的经验和见解，让我受益匪浅。在与他们的交流中，我更加明白了一个道理：在这个日新月异的时代里，我们需要不断学习和进步，才能跟上时代的步伐。
旅程感悟 总之，云栖大会是一次非常棒的经历。它让我深刻认识到科技的力量和无限可能，也让我对未来的发展充满了期待和憧憬。我相信，在未来的日子里，我会将这次参会的经验和感悟运用到生活和工作中，努力提升自己的科技素养和创新能力，为推动科技创新做出自己的贡献。同时，我也期待着再次参加云栖大会，继续学习、交流和成长。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf83520e8c1e43710651bb18888c63d/" rel="bookmark">
			iOS GCD(Grand Central Dispatch)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iOS 常用有三种线程管理方式，分别是 NSThread、GCD 与 NSOperation，现在我们先来了解一下其中的 GCD
串行与并行针对的是任务队列，而同步与异步，针对的则是线程。
Serial Queue + Sync 序列执行+同步
Serial Queue + Async 序列执行 + 异步 （按顺序）
Concurrent Queue + Sync 并发 + 同步 （按顺序）
Concurrent Queue + Async 并发 + 异步 （真正多线程）（不按顺序）
自定义串行队列有能力启动主线程和后台线程（只能启动一个后台线程），不会发生死锁。同步任务，会自动安排在主线程执行；遇到异步任务，自动安排在后台线程执行，所以不会死锁。
DispatchWorkItem 可添加 item 到队列中 //1. 只带尾随闭包 let item1 = DispatchWorkItem { print("item1") } //2. 指定qos（执行优先级）或flags（特殊行为标记） let item2 = DispatchWorkItem(qos: .userInteractive, flags: .barrier) { print("item2") } DispatchQueue Main queue (串行队列) 仅能运行在主线程上
let mainQueue = DispatchQueue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bf83520e8c1e43710651bb18888c63d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/253ad5c946e35a81f6e3895f33f733e2/" rel="bookmark">
			孪生素数C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述
编程输入正整数a(10000&gt;=a&gt;=2)，输出不小于a的第一对孪生素数。差是2的两个素数被称为孪生素数。
输入
无
输出
无
输入样例
10000
输出样例
10007 10009
代码演示
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int sushu(int i) { int j,flag; if(i==1) flag=0; for(j=2; j*j&lt;=i; j++) { if(i%j==0) { flag=1; break; } else { flag=0; continue; } } return flag; } int main() { int a,n; scanf("%d",&amp;a); { for(n=a; ; n++) { if(sushu(n)==0&amp;&amp;sushu(n+2)==0) break; else continue; } printf("%d %d",n,n+2); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/059e1062e2cf1db3f46d71d154981ab6/" rel="bookmark">
			聚水潭对接金蝶，自动同步订单信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据自动同步技术有很多的优点，其中最重要的是它可以提高工作的效率。此外，数据自动同步技术还可以减少错误的发生。由于数据在所有设备之间始终同步，因此就不必在不同的设备上进行重复的操作了，从而减少了出错的机会。
数环通通过打通聚水潭erp和金蝶云星辰的对接，实现了跨应用对接，使订单信息能及时自动同步。数环通不仅打通了聚水潭和金蝶的对接，还有与支付宝等应用之间的对接。
下面就先介绍聚水潭和金蝶云星辰的集成对接应用场景示例。
01 | 聚水潭和金蝶云星辰对接场景介绍 对接方法：聚水潭+金蝶云星辰
创建数环通账号并登录选择创建方式根据提示选择触发和执行应用：聚水潭和金蝶云星辰，选择操作，添加账号最后完成配置 触发条件：当有新采购订单创建时
执行操作：上传采购单
最终实现目标效果：每当金蝶云星辰有新采购订单创建时，聚水潭自动上传采购单，帮助企业轻松地同步订单数据，提高工作的效率。
02 | 产品介绍 数环通数据连接器iPaaS是一款开箱即用、安全稳定与多场景适用的一站式企业级应用集成平台。基于云原生基座，通过预置连接器、可视化流程编排和API治理等能力，将企业内外部不同的业务、活动、应用、数据、API、设备连接起来，实现各个系统间的业务衔接、数据流转、资源整合，高效实现企业上下游、内外网应用系统的数据互通，从而实现企业流程自动化，助力企业敏捷创新发展和数字化转型升级。
目前，数环通已对接打通钉钉、金蝶云、维格表、抖音、企业微信、CRM、巨量千川、用友等600+应用系统，拥有超10000+指令动作，且持续周周更新。
中国南方电网、上佰电商、拾花社、苏泊尔、盛耳食品、佳帮手等数千家企业已选择数环通助力企业数字化经营。
03 | 未来展望 上面就是金蝶云星辰和聚水潭对接的简单场景示例，还可以将数环通与其他应用连通起来，比如网易邮箱、旺店通等，构建更智能、自动化的工作流程，实现企业工作的更高度集成 。在未来，数环通将为更多的用户和合作伙伴创造更高的商业价值，实现互利共赢，为推动数字经济发展做出更大的贡献。欢迎免费进行金蝶云星辰和聚水潭的对接试用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ba99bb507d4b427bee85605f6f8a2f7/" rel="bookmark">
			各种运算符的介绍，超详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果文中有出现错误的地方或者有疑问的地方，请私信博主，博主第一时间回复！
目录
1.算术运算符
基本算术运算符（+ - * / %）
自增（++）、自减（--）运算符
2.关系运算符（&gt; &lt; == &gt;= &lt;= !=）
3.逻辑运算符 ( ！&amp;&amp; || ) 4.位运算符（&lt;&lt; &gt;&gt; ~ | ^ &amp;）
&amp;按位或 ||按位与 ^按位异或
~ 对一个数的二进制按位取反 &lt;&lt; 左移操作符 &gt;&gt; 右移操作符
5.赋值运算符（=）
6.条件运算符（？：）
7.逗号表达式（，）
8.指针运算符(*和&amp;)
9.求字节数运算符（sizeof）
10.强制类型转换运算符（类型）
11.成员运算符（-&gt; .）
12.下标运算符([ ])
13.其他（函数调用操作符）
C语言提供了以下运算符：
（1）算术运算符 （+ - * / % ++ -- ） （2）关系运算符 (&gt; &lt; == &gt;= &lt;= ！ =) （3）逻辑运算符 ( ！&amp;&amp; || ) （4）位运算符 (&lt;&lt; &gt;&gt; ~ | ^ &amp;) （5）赋值运算符 (=及其扩展赋值运算符）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ba99bb507d4b427bee85605f6f8a2f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fcde7e998b311b886a7c2d735d8b381/" rel="bookmark">
			【Mybatis-plus】updateById()方法不能更新字段为null的原因及解决办法---@TableField(updateStrategy = FieldStrategy.ALWAYS)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Mybatis-plus】updateById()方法不能更新字段为null的原因及解决办法 一、问题描述
在日常项目开发过程中，经常会使用Mybatis-plus的updateById()方法，快速将接收道德参数或者查询结果中原本不为null的字段更新为null，并且该字段在数据库中可为null，这个时候使用updateById()并不能实现这个操作，不会报错，但是对应的字段并没有更新为null。
二、问题原因
Mybatis-plus的字段策略（FieldStrategy）有三种策略：
IGNORED：0 忽略NOT_NULL：1 非 NULL，默认策略NOT_EMPTY：2 非空 而默认的更新策略是NOT_NULL：非NULL; 即通过接口更新数据时数据为NULL值时将不更新进数据库。
三、解决方案
1.直接在mapper.xml中写sql: update table A set 字段a = null where 字段b = 条件 2.设置全局的FieldStrategy 在配置文件中修改全局策略
#properties文件格式： mybatis-plus.global-config.db-config.field-strategy=ignored #yml文件格式： mybatis-plus: global-config: #字段策略 0:"忽略判断",1:"非 NULL 判断",2:"非空判断" field-strategy: 0 这样做是进行全局配置，在更新时会忽略对所有字段的判断。但是如果一些字段没有传值过来，会被直接更新为null，可能会影响其它业务数据的准确性。不推荐使用此方法。
3.对指定的字段单独设置field-strategy 根据具体情况，在需要更新的字段中调整验证注解，如验非空：
@TableField(strategy=FieldStrategy.NOT_EMPTY)
这样的话，我们只需要在需要更新为null的字段上，设置忽略策略，如下：
@TableField(updateStrategy = FieldStrategy.IGNORED) private String updateBy; 最新版本：
@TableField(updateStrategy = FieldStrategy.ALWAYS) package com.baomidou.mybatisplus.annotation; /** * 字段策略枚举类 * &lt;p&gt; * 如果字段是基本数据类型则最终效果等同于 {@link #ALWAYS} * * @author hubin * @since 2016-09-09 */ public enum FieldStrategy { /** * 忽略判断，该字段存在语义理解问题，后续版本将废弃 github issues/5129 */ @Deprecated IGNORED, /** * 任何时候都加入 SQL */ ALWAYS, /** * 非NULL判断 */ NOT_NULL, /** * 非空判断(只对字符串类型字段,其他类型字段依然为非NULL判断) */ NOT_EMPTY, /** * 默认的,一般只用于注解里 * &lt;p&gt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fcde7e998b311b886a7c2d735d8b381/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/775956c6ba35e9422a4880c543126cf0/" rel="bookmark">
			MS-VS C# 简单开发记录（GUI）１ －从一个菜单点击打开新窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： C# 的使用，似乎在机器视觉的集成项目里面变得越来越多了，笔者无奈的熟悉起来这个环境，不过，据说，如果做界面的设计，C#的使用是异常方便的，有的不行了，做几个实例看看？
今天的实例，就是我要从以前的应用里面加一个新的检测的项目，那么，肯定不能全面瘫倒主菜单去选吧，所以，应该是从一个下拉菜单里面去选择，于是就有了本文的标题的一个小定义：
项目环境： Windwos10 64位
Microsoft Visual Studio Community 2019
版本 16.11.22
1 先要加一个新的窗口： 在菜单里面选取【项目】，然后下拉菜单里面有 【添加，窗体、控件、类等等各种添加的选项】
我们这里添加一下新的窗体，自然，选择，【添加窗体】
这里好像选项很多，笔者选择【窗体】，然后，下面有一个名称设定，这里可以改一下，点击【添加】就有如下：
编译器这时候不仅仅编译好了窗口，还会自动生成一些相关的代码和类：
namespace VisionSystem { partial class frm3Ddetect { /// &lt;summary&gt; /// Required designer variable. /// &lt;/summary&gt; private System.ComponentModel.IContainer components = null; /// &lt;summary&gt; /// Clean up any resources being used. /// &lt;/summary&gt; /// &lt;param name="disposing"&gt;true if managed resources should be disposed; otherwise, false.&lt;/param&gt; protected override void Dispose(bool disposing) { if (disposing &amp;&amp; (components !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/775956c6ba35e9422a4880c543126cf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4103ee96af887c77ecb36ebaa3648dd1/" rel="bookmark">
			Ubuntu 如何根据NVIDIA显卡型号确定对应的显卡驱动版本并安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍如何在Ubuntu系统中安装NVIDIA的显卡驱动，主要提供三种安装方式：
终端安装（推荐）软件窗口安装官网程序安装 1. 通过终端安装，只安装 nvidia 驱动(推荐安装方式) 打开终端执行：ubuntu-drivers devices
如果没有显示nvidia相关驱动列表，请检查显卡设置是否完整。
可以看到这里推荐安装nvidia-driver-470，因此我们直接运行指令进行安装（recommend：建议、推荐）：
sudo apt install nvidia-driver-470 #安装470驱动 然后重启计算机：sudo reboot
2. 通过 software &amp; Updates 安装nvidia 驱动 software &amp; Updates 安装
然后重启计算机。
3. 通过官网程序安装 官网查询适合自己电脑的GPU的最新驱动版本。
比如我的显卡是 NVIDIA GeForce GTX 1650 ：
点击 SEARCH 进行搜索：
如果想要安装最新的 NVIDIA显卡驱动，可以之间点击 DOWNLOAD进行下载，然后安装下载的文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/643fcdc272a613c1988a0bc966771971/" rel="bookmark">
			【C&#43;&#43;】ifstream、file.good、 file.seekg、file.tellg、file.read详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要对ifstream、file.good、 file.seekg、file.tellg、file.read等函数功能进行详细解析，包括原理和步骤，最后通过一个示例进行总结。
原理详解 std::ifstream file（） std::ifstream 是C++中用于打开一个输入文件的语句。std::ifstream 是C++标准库中的一个类，用于从文件进行输入。
std::ifstream file(file_name, std::ios::binary); 在这行代码中：
file_name 是一个字符串，表示要打开的文件的名称。
std::ios::binary 是一个打开模式，表示以二进制形式打开文件。这意味着你可以读取例如字节等二进制数据。如果不指定这个模式，文件将以文本模式打开，这意味着行尾字符可能会被处理（例如在Windows中，文本模式会将 “\r\n” 转换为 “\n”）。
file.good（） file.good() 是C++中用来检查文件流是否处于良好状态的方法。如果文件流没有错误，那么 file.good() 将返回 true。否则，如果有错误发生，它将返回 false。
这个函数通常在读取或写入文件后被调用，以检查操作是否成功。例如：
std::ifstream file("example.txt"); if (!file.good()) { std::cerr &lt;&lt; "File operation failed!" &lt;&lt; std::endl; return; } file.seekg() file.seekg(0, file.end); 是 C++ 中的一个文件操作函数，用于将文件读取指针移到文件的末尾。
这个函数的作用是将读取指针移动到文件的结尾，这样在下次读取文件时，将从文件的末尾开始读取。
file.seekg() 函数的第一个参数是一个整数，**表示偏移量，而第二个参数是一个枚举值，表示偏移的起始位置。**在这个例子中，起始位置是 file.end，表示从文件末尾开始计算偏移量。
file.seekg(0, file.beg); file.seekg(0, file.beg);它用于移动文件读取指针到文件的开始位置。
file.beg 是 std::istream 类的一个成员常量，表示从文件的开始位置开始偏移。
需要注意的是，file.seekg() 函数并不会改变文件中已经读过的内容，它只是改变了下一次读取操作的位置。此外，如果在打开文件时没有指定模式为 ‘r’（即只读模式），那么在执行 file.seekg() 时可能会抛出 IOError 异常。
file.tellg() size = file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/643fcdc272a613c1988a0bc966771971/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aa270413a6a8d21c352956b3af346b3/" rel="bookmark">
			C/C&#43;&#43;：gcc选项-fno-access-control的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在测试代码时需要访问私有和保护成员，使用这个选项可以忽略访问控制。
class A { public: A() {} protected: void test_protected() {} private: void test_private() {} }; int main(int argc, char* argv[]) { A a; a.test_protected(); a.test_private(); return 0; } $ g++ main.cpp -fno-access-control 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbc11742bc4b128eaa2d401c30b37963/" rel="bookmark">
			pip install mysqlclient报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 mysqlclient 报错
解决办法1
下载 ：https://www.lfd.uci.edu/~gohlke/pythonlibs/
cp 后是Python 版本 am 后是 几位
pip install mysqlclient-1.4.6-cp37-cp37m-win_amd64.whl 安装完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72feac39146b6764633d264f43bb8d2d/" rel="bookmark">
			【MATLAB】全网唯一的7种信号分解&#43;ARIMA联合的时序预测算法全家桶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有意向获取代码，请转文末观看代码获取方式~
大家吃一顿火锅的价格便可以拥有7种信号分解+ARIMA组合的时序预测算法，绝对不亏，知识付费是现今时代的趋势，而且都是我精心制作的教程，有问题可随时反馈~也可单独获取某一算法的代码（见每一算法介绍后文）~
1 【MATLAB】VMD-ARIMA联合时序预测算法 接下来详细介绍一下最新的 EMD-ARIMA 联合时序预测算法的原理和思路。
信号分解可以将原始数据分解为 N 层 imf 分量，然后本研究对每层的 imf 分量展开 ARIMA 时序预测，并将预测后的 imf 分量的预测值进行重构，即可得到 EMD-ARIMA 联合时序预测值。
将该EMD-ARIMA 联合时序预测值与单纯的 ARIMA 时序预测值分别与真实值进行对比，求其相关系数、均方根误差以及平均误差可以发现，EMD-ARIMA 联合时序预测算法有较好的预测效果。究其原因不难发现，信号分解是将原始数据分解为不同频率的数据，也即每一层imf分量的频率大致相同，是具有较好的周期性和规律性的数据、因而当采用 ARIMA 时序预测算法对每一层 imf 分量展开预测的时候其预测效果会更加接近真值。
算法示意图
2【MATLAB】EEMD-ARIMA联合时序预测算法 接下来详细介绍一下最新的 EEMD-ARIMA 联合时序预测算法的原理和思路。
信号分解可以将原始数据分解为 N 层 imf 分量，然后本研究对每层的 imf 分量展开 ARIMA 时序预测，并将预测后的 imf 分量的预测值进行重构，即可得到 EEMD-ARIMA 联合时序预测值。
将该EEMD-ARIMA 联合时序预测值与单纯的 ARIMA 时序预测值分别与真实值进行对比，求其相关系数、均方根误差以及平均误差可以发现，EEMD-ARIMA 联合时序预测算法有较好的预测效果。究其原因不难发现，信号分解是将原始数据分解为不同频率的数据，也即每一层imf分量的频率大致相同，是具有较好的周期性和规律性的数据、因而当采用 ARIMA 时序预测算法对每一层 imf 分量展开预测的时候其预测效果会更加接近真值。
算法示意图
3【MATLAB】CEEMD-ARIMA联合时序预测算法 接下来详细介绍一下最新的 CEEMD-ARIMA 联合时序预测算法的原理和思路。
信号分解可以将原始数据分解为 N 层 imf 分量，然后本研究对每层的 imf 分量展开 ARIMA 时序预测，并将预测后的 imf 分量的预测值进行重构，即可得到 CEEMD-ARIMA 联合时序预测值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72feac39146b6764633d264f43bb8d2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acdca89e42661845b923809bd5fb29d3/" rel="bookmark">
			较高的采样频率和较低的采样频率的结果有什么不同？比如10240和5120的采样频率的结果有什么不同？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		较高的采样频率和较低的采样频率之间的主要区别在于对信号细节的捕获能力。
较高的采样频率 (例如10240 Hz):
能够更准确地捕捉信号的快速变化，包括高频成分。提供了更丰富的频率信息，可以分析高频信号的特性。对于快速变化的信号或包含高频成分的信号，更适合使用较高的采样频率。 较低的采样频率 (例如5120 Hz):
不能够精确地捕捉信号中的高频细节，可能会导致失真或信号信息丢失。对于相对平缓变化的信号，可以降低数据量和计算成本，同时保留主要特征。可能会丧失高频信号的部分信息，对于高频成分的分析不够精确。 因此，选择采样频率应基于信号本身的特性和分析的需求。如果信号中包含重要的高频信息，那么较高的采样频率可能更合适。如果信号相对平滑或对高频信息不敏感，较低的采样频率可能足够了，并可以节省资源。
需要注意的是，选择采样频率时，也要考虑到采样定理（奈奎斯特定理）的要求，确保采样频率至少是信号中最高频率的两倍，以避免混叠失真。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f6197780e84e742f29605bb3cea7c10/" rel="bookmark">
			rabbitmq消费端限流:一次只能消费一条消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是消费端的限流？ 场景：在订单高峰期，rabbitmq上已经堆积了很多消息等待消费，如果没有任何限流措施，贸然启动一个消费者时，如此多的消息瞬间推送给消费者，消费者可能因无法处理这么多的消息而承受巨大压力，甚至崩溃！
2. 解决方案 rabbitmq 提供了basicQos方法实现了限流，也就是在关闭了消费端的自动ack的前提 下，我们可以设置阈值（出队）的消息数。 没有手动确认，那么就不会推送新的消息过来！可以有效防止消费者压力过大而崩溃。
/** * 限流设置: prefetchSize：每条消息大小的设置，0是无限制 * prefetchCount:标识每次推送多少条消息 一般是一条 * global:false标识channel级别的 true:标识消费者级别的 */ channel.basicQos(0,1,false); 3. 代码示例 生产者：
public class Producer { public static void main(String[] args) throws Exception{ // 1、创建连接工厂 ConnectionFactory factory = new ConnectionFactory(); factory.setVirtualHost("/"); factory.setPort(5672); factory.setHost("192.168.200.130"); factory.setUsername("mqs"); factory.setPassword("mqs123"); // 2、创建连接 Connection connection = factory.newConnection(); // 3、获取通道 Channel channel = connection.createChannel(); // 4、声明交换机和路由 String exchangeName = "limit_exchange"; String routingKey = "limit.key"; //消息体 String msg = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f6197780e84e742f29605bb3cea7c10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cce416a914253766b24e17862688714/" rel="bookmark">
			数组基础知识二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特别说明
一维数组的定义（对数组空间进行清理，置0，不会产生随机值）：数组在使用前要先定义；告诉编译器数组元素的类型；编译器会给这个数组预先分配连续的存储空间；定义的格式为：元素类型名 数组名[数组长度]。
1、一维数组的遍历：在操作数组时，经常需要依次访问数组中的每个元素，这种操作称作数组的遍历。接下来使用for循环依次遍历数组中的元素。
代码示例
#include &lt;stdio.h&gt; int main() { int x[5] = {1,2,3,4,5}; int i = 0; for(i=0;i&lt;5;i++) { printf("x[%d]:%d\n",i,x[i]); } return 0; } 例题1：输入n(n&lt;=10）及n个整数，将这组整数逆置并输出。
#include &lt;stdio.h&gt; int main() { int a[10]; int n; int i = 0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); for(i=0;i&lt;n/2;i++) { int t; t=a[i]; a[i]=a[n-1-i]; a[n-1-i]=t; } for(i=0;i&lt;n;i++) printf("%d",a[i]); return 0; } 注意：输入的时候以回车作为结束
2、一维数组的最值：在操作时，经常需要获取数组中元素的最值。
例题2：输入n(n&lt;=10)及n个整数，输出最大整数及其位序。
#include &lt;stdio.h&gt; int main() { int n,maxn,maxk; int a[10]; int i; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cce416a914253766b24e17862688714/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bb8b5ea72e42bbc4bd70dabf52a1727/" rel="bookmark">
			java String 和ArrayList转换 换化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		------------------------------------------------------------
String转为JSON对象: String Token = URLEncoder.encode(token, "UTF-8"); String requestUrl = url + "?token=" + Token; String response = HttpUtils.post(requestUrl); JSONObject responseJson = JSONUtils.parseObject(response, JSONObject.class); JSONArray dataArray = responseJson.getJSONArray("data"); JSON对象中取JSON数组： JSONObject responseJson = JSONUtils.parseObject(response, JSONObject.class); JSONArray dataArray = responseJson.getJSONArray("data"); ------------------------------------------------------------
[Ljava.lang.String; cannot be cast to java.util.List
原因：
Map&lt;String, Object&gt; parameters = (Map&lt;String, Object&gt;) jsonResult.getData(); parameters 参数中refrenceIds 是个string
（比如："refrenceIds": ["1438647705516691456", "1436069122789134336"],）
下步代码：
List&lt;Long&gt; refrenceIds = (List&lt;Long&gt;) MapUtils.getObject(parameters, SystemConst.REFRENCEIDS); 就会转换报错
解决：
@Override public int submitCheckBatchAgreeOrder(Map&lt;String, Object&gt; parameters) throws Exception { //List&lt;Long&gt; refrenceIds = (List&lt;Long&gt;) MapUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bb8b5ea72e42bbc4bd70dabf52a1727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b4e7a0e5fe84ad35fb5f95b9ceeac79/" rel="bookmark">
			aaaaaa
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[ WARN:0@10.287] global /home/pi/opencv460/opencv-4.6.0/modules/dnn/src/ocl4dnn/src/ocl4dnn_conv_spatial.cpp (1924) loadTunedConfig OpenCV(ocl4dnn): consider to specify kernel configuration cache directory through OPENCV_OCL4DNN_CONFIG_PATH parameter.
OpenCL program build log: dnn/dummy
Status -43: CL_INVALID_BUILD_OPTIONS
-cl-no-subgroup-ifp
error: unknown OpenCL C option '-cl-no-subgroup-ifp'
sudo cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local -D OPENCV_GENERATE_PKGCONFIG=ON -D OPENCV_ENABLE_NONFREE=YES -D OPENCV_EXTRA_MODULES_PATH=/home/pi/opencv460/opencv_contrib-4.6.0/modules -D WITH_GTK=ON -D CMAKE_VERBOSE_MAKEFILE=ON -D WITH_OPENGL=ON -D WITH_FFMPEG=ON -D FFMPEG_INCLUDE_DIR=/usr/local/include -D FFMPEG_LIBRARY_DIR=/usr/local/lib ..
bool Yolo::readModel(Net&amp; net, string&amp; netPath, bool isCuda = false,bool isNpu = false) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b4e7a0e5fe84ad35fb5f95b9ceeac79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5caf9d2cb1be945850545b64f965eba4/" rel="bookmark">
			Nacos简介和控制台服务安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是 Nacos 官方文档： https://nacos.io/zh-cn/docs/what-is-nacos.html
1、Nacos简介 Nacos 是 Dynamic Naming and Configuration Service 的首字母缩写。
Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。
Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。
Nacos 的关键特性包括：
服务发现和服务健康监测动态配置服务动态 DNS 服务服务及其元数据管理 使用 Nacos 简化服务发现、配置管理、服务治理及管理的解决方案，让微服务的发现、管理、共享、组合更加容易。
2、Nacos基本概念 Nacos 引入了一些基本的概念，系统性的了解一下这些概念可以帮助您更好的理解和正确的使用 Nacos 产品。 更多概念查看官方文档。
1）命名空间
用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。
Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。
2）配置分组
Nacos 中的一组配置集，是组织配置的维度之一。通过一个有意义的字符串（如 Buy 或 Trade ）对配置集进行分组，从而区分 Data ID 相同的配置集。当您在 Nacos 上创建一个配置时，如果未填写配置分组的名称，则配置分组的名称默认采用 DEFAULT_GROUP 。
配置分组的常见场景：不同的应用或组件使用了相同的配置类型，如 database_url 配置和 MQ_topic 配置。
3）服务注册中心
存储服务实例和服务负载均衡策略的数据库。
4）元信息
Nacos数据（如配置和服务）描述信息，如服务版本、权重、容灾策略、负载均衡策略、鉴权配置、各种自定义标签 (label)，从作用范围来看，分为服务级别的元信息、集群的元信息及实例的元信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5caf9d2cb1be945850545b64f965eba4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/110a300a3adc4adafbe58866c0821d92/" rel="bookmark">
			maven--pom.xml--标签大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文网址：maven--pom.xml--标签大全_IT利刃出鞘的博客-CSDN博客
简介 说明
本文介绍maven的pom.xml的结构及常用标签的使用。详细讲解的标签包括：parent，relativePath，modules，repositories，profiles，build等。
官网
pom.xml - maven
简介 对于Idea来说，最后maven的插件总会覆盖掉生成的pom.xml文件，这时可以使用ctrl+z来取消。
pom.xml构成
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 基础设置 --&gt; &lt;groupId&gt;...&lt;/groupId&gt; &lt;artifactId&gt;...&lt;/artifactId&gt; &lt;version&gt;...&lt;/version&gt; &lt;packaging&gt;...&lt;/packaging&gt; &lt;name&gt;...&lt;/name&gt; &lt;description&gt;...&lt;/description&gt; &lt;url&gt;...&lt;/url&gt; &lt;dependencies&gt;...&lt;/dependencies&gt; &lt;parent&gt;...&lt;/parent&gt; &lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt; &lt;modules&gt;...&lt;/modules&gt; &lt;properties&gt;...&lt;/properties&gt; &lt;!--构建设置 --&gt; &lt;build&gt;...&lt;/build&gt; &lt;reporting&gt;...&lt;/reporting&gt; &lt;!-- 更多项目信息 --&gt; &lt;inceptionYear&gt;...&lt;/inceptionYear&gt; &lt;licenses&gt;...&lt;/licenses&gt; &lt;organization&gt;...&lt;/organization&gt; &lt;developers&gt;...&lt;/developers&gt; &lt;contributors&gt;...&lt;/contributors&gt; &lt;!-- 环境设置--&gt; &lt;issueManagement&gt;...&lt;/issueManagement&gt; &lt;ciManagement&gt;...&lt;/ciManagement&gt; &lt;mailingLists&gt;...&lt;/mailingLists&gt; &lt;scm&gt;...&lt;/scm&gt; &lt;prerequisites&gt;...&lt;/prerequisites&gt; &lt;repositories&gt;...&lt;/repositories&gt; &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt; &lt;distributionManagement&gt;...&lt;/distributionManagement&gt; &lt;profiles&gt;...&lt;/profiles&gt; &lt;/project&gt; parent 简介 其他网址
Maven 的聚合（多模块）和 Parent 继承_偶尔记一下 - mybatis.io-CSDN博客_maven parent
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/110a300a3adc4adafbe58866c0821d92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/005df14a168af56341f785a4212f0fb8/" rel="bookmark">
			驱动开发platform
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务 : 基于platform驱动模型完成LED驱动的编写，实现三盏灯的点亮
应用层程序
#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;sys/ioctl.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #define LED_ON _IOW('l',1,int) #define LED_OFF _IOW('l',0,int) int main(int argc, char const *argv[]) { // 打开第一个设备文件 int fd1 = open("/dev/myled0", O_RDWR); if (fd1 &lt; 0) { printf("打开设备文件失败\n"); exit(-1); } // 打开第二个设备文件 int fd2 = open("/dev/myled1", O_RDWR); if (fd2 &lt; 0) { printf("打开设备文件失败\n"); exit(-1); } // 打开第三个设备文件 int fd3 = open("/dev/myled2", O_RDWR); if (fd3 &lt; 0) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/005df14a168af56341f785a4212f0fb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd6c2d5229582fcd8db15b028ab3238c/" rel="bookmark">
			【雕爷学编程】MicroPython手册之 ESP32-S2 定时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MicroPython是为了在嵌入式系统中运行Python 3编程语言而设计的轻量级版本解释器。与常规Python相比，MicroPython解释器体积小(仅100KB左右)，通过编译成二进制Executable文件运行，执行效率较高。它使用了轻量级的垃圾回收机制并移除了大部分Python标准库，以适应资源限制的微控制器。
MicroPython主要特点包括:
1、语法和功能与标准Python兼容,易学易用。支持Python大多数核心语法。
2、对硬件直接访问和控制,像Arduino一样控制GPIO、I2C、SPI等。
3、强大的模块系统,提供文件系统、网络、图形界面等功能。
4、支持交叉编译生成高效的原生代码,速度比解释器快10-100倍。
5、代码量少,内存占用小,适合运行在MCU和内存小的开发板上。
6、开源许可,免费使用。Shell交互环境为开发测试提供便利。
7、内置I/O驱动支持大量微控制器平台，如ESP8266、ESP32、STM32、micro:bit、掌控板和PyBoard等。有活跃的社区。
MicroPython的应用场景包括:
1、为嵌入式产品快速构建原型和用户交互。
2、制作一些小型的可 programmable 硬件项目。
3、作为教育工具,帮助初学者学习Python和物联网编程。
4、构建智能设备固件,实现高级控制和云连接。
5、各种微控制器应用如物联网、嵌入式智能、机器人等。
使用MicroPython需要注意:
1、内存和Flash空间有限。
2、解释执行效率不如C语言。
3、部分库函数与标准版有差异。
4、针对平台优化语法,订正与标准Python的差异。
5、合理使用内存资源,避免频繁分配大内存块。
6、利用原生代码提升速度关键部位的性能。
7、适当使用抽象来封装底层硬件操作。
ESP32-S2是一款低功耗且集成多种功能的WiFi微控制器芯片,其主要参数如下:
使用Xtensa单核32位LX7 CPU,主频高达240MHz
320KB SRAM、2M PSRAN （板载）
集成802.11b/g/n HT40 Wi-Fi
支持Bluetooth 5.0 BR/EDR 和Bluetooth Low Energy
丰富外设接口:SPI、SPI Slave、SDIO Slave、I2C、I2S、RMT等
USB OTG 接口,可配置为host或device
支持时钟和功耗管理,节能模式功耗仅2uA
内置安全启动和flash 加密功能
工作温度范围:-40°C到105°C
封装规格:QFN48 7x7 mm
综上,ESP32-S2集成度高,有更好的功耗性能,非常适合物联网和可穿戴应用。相比ESP32,该款芯片在无线网络和功耗管理方面进行了优化。
MicroPython的ESP32-S2提供了定时器功能，下面从专业的视角详细解释其主要特点、应用场景以及需要注意的事项。
主要特点：
多个定时器：ESP32-S2内置了多个硬件定时器，可以同时使用多个定时器来执行不同的定时任务。每个定时器都有独立的计数器和配置寄存器，可以根据需求进行灵活配置和使用。
精确的定时触发：ESP32-S2的定时器可以实现精确的定时触发功能。可以根据指定的时间间隔（以微秒为单位）设置定时器，当计数器达到指定值时，会触发相应的中断或执行特定的操作。
周期性任务：定时器可以用于周期性任务的触发。通过设置定时器的重载值，可以实现定时器在固定时间间隔内不断循环触发的功能。
应用场景：
时间敏感应用：定时器适用于对时间敏感的应用场景。例如，可以利用定时器进行精确的时间测量、时间同步、时间戳记录等操作。
调度和任务管理：定时器可以用于调度和管理多个任务。通过设置不同的定时器以不同的时间间隔触发，可以实现任务的优先级控制和时间片轮转调度等功能。
周期性数据采集：定时器的周期性触发功能可用于周期性数据采集。例如，可以设置定时器每隔一定时间执行一次数据采集操作，用于传感器数据的定期获取。
需要注意的事项：
资源冲突：ESP32-S2的定时器资源是有限的，如果需要同时使用多个定时器，请确保它们之间没有资源冲突。在设计应用时，需仔细规划和管理定时器资源。
中断处理：定时器触发时通常会通过中断来处理。在使用定时器时，需要编写相应的中断处理程序，确保及时响应定时器触发事件。
精度和误差：定时器的精度和误差受到系统时钟频率和定时器配置等因素的影响。在对定时器精度要求较高的应用中，需要进行实际测试和调整，以确保满足要求的精度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd6c2d5229582fcd8db15b028ab3238c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19eab896676305cd506296c36e27ad03/" rel="bookmark">
			python 提取ts文件数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 提取TS文件数据 在视频处理和流媒体应用中，TS（Transport Stream）是一种常用的容器格式。TS文件通常包含了视频、音频和其他相关的数据流。在某些情况下，我们可能需要从TS文件中提取特定的数据流，例如只提取视频流或音频流。
本文将介绍如何使用Python提取TS文件中的数据，并给出相应的代码示例。
TS文件格式简介 TS文件是一种基于MPEG-2传输流的容器格式，通常用于数字电视广播和流媒体传输。TS文件由一系列的数据包（Packet）组成，每个数据包的大小为188字节。每个数据包包含了一个4字节的同步头（Sync Byte），用于标识数据包的开始。
在TS文件中，不同的数据流被分为多个PID（Packet Identifier）。例如，视频流通常使用PID 0x100，音频流通常使用PID 0x101。每个数据包都包含了一个PID，用于标识该数据包所属的数据流。
提取TS文件中的数据流 要提取TS文件中的数据流，我们首先需要读取TS文件，并解析数据包的头部信息。然后根据PID过滤出所需的数据包，并将数据包中的数据流保存到文件中。
下面是一个使用Python提取TS文件中视频流的示例代码：
import os def extract_video_stream(ts_file, output_file): # 打开TS文件并读取数据 with open(ts_file, 'rb') as file: data = file.read() # 遍历数据包 packet_size = 188 packet_count = len(data) // packet_size for i in range(packet_count): packet_start = i * packet_size packet = data[packet_start:packet_start + packet_size] # 解析数据包头部 sync_byte = packet[0] pid = ((packet[1] &amp; 0x1F) &lt;&lt; 8) | packet[2] # 过滤视频流数据包（PID为0x100） if pid == 0x100: # 保存视频流数据到文件 video_data = packet[4:] with open(output_file, 'ab') as output: output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19eab896676305cd506296c36e27ad03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/846374473a5deee388b81e60782c485d/" rel="bookmark">
			关于CSS的几种字体悬浮的设置方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于CSS的几种字体悬浮的设置方法 1. 鼠标放上动态的2. 静态的（位置看上悬浮）2.1 参考QQ邮箱2.2 参考知乎 1. 鼠标放上动态的 效果如下：
代码如下：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; table{ background-color: cadetblue; height: 150px; width: 300px; } th,td{ border: 1px solid; text-align: center; } .test{ position: relative; } .test:before{ content: "1314"; /*如果不给数据就是清空伪元素内容*/ position: absolute; /*设置为绝对定位*/ opacity: 0; /*初始透明度为0 ,注意：如果是非0就会一直悬浮，如果是0的话，鼠标放上去悬浮*/ background-color: rebeccapurple; /*设置背景颜色*/ color: #d5d5e1; /*设置文字颜色*/ transform: translateY(-10px); /*向上移动10像素*/ transition: all 0.2s ease-in-out; /*设置过渡效果*/ padding: 10px; /*设置内边距*/ top: -50%; /*将其移出父容器*/ /* left: 0; 在左侧 */ right: -25px; /*在右侧*/ /* width: 100%; 与父容器同宽 */ width: 20px; height: 10px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/846374473a5deee388b81e60782c485d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/262fdb0d0b3fe2df212955edc3121692/" rel="bookmark">
			CSP-S 2023 T1密码锁 T2消消乐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		T1 密码锁 对于一种状态，其可能产生的其他状态共有两种情况，一种情况是只转一个拨圈，这样产生的密码共有 5 ∗ 9 = 45 5*9=45 5∗9=45种，另一种情况是转相邻的两个拨圈，这样产生的密码共有 4 ∗ 9 = 36 4*9=36 4∗9=36种，所以一种状态能产生的密码共有 45 + 36 = 81 45+36=81 45+36=81种。现在题目中给出了 n ( n ≤ 8 ) n(n\leq 8) n(n≤8)个状态，问能满足所有这些状态的密码有多少种。
由于密码只有 5 5 5位，所以总共的情况也只有 1 0 5 10^5 105种，对于每种密码，我们只需要判断它是不是能到达给出的 n n n个状态。判断时，我们遍历 n n n个状态，对每个状态分别进行转一个拨圈的变换和转两个拨圈的变换，看是否能够得到该密码，若 n n n个状态都符合条件，则答案加一。复杂度是完全可以接受的。
再讲一种复杂度较小的做法。对于每种状态 ( n ≤ 8 ) (n\leq 8) (n≤8)，枚举这个状态所能到达的所有密码（ 81 81 81种），记录每种密码被枚举到的次数。枚举完 n n n个状态能到达的密码后，遍历所有密码，若这个密码被枚举到的次数为 n n n，也就说明每个状态都能到达这个密码，则答案加一。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/262fdb0d0b3fe2df212955edc3121692/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b49866081bc7b4eaeb663ac906d5685/" rel="bookmark">
			二叉树的层次建树和中序线索化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;iostream&gt; typedef struct TreeNode{ int data; TreeNode* lchild; TreeNode* rchild; int ltag; int rtag; }TreeNode,*Bi_TreadTree; TreeNode* createNode(int data) { TreeNode* newNode = (TreeNode*)new TreeNode(); newNode-&gt;data = data; newNode-&gt;lchild = NULL; newNode-&gt;rchild = NULL; newNode-&gt;ltag = 0; newNode-&gt;rtag = 0; return newNode; } //层次建树 Bi_TreadTree createTree(int data[],int size) { Bi_TreadTree root; TreeNode** queue = (TreeNode**)new TreeNode*[size]; int rear = 0; int front = 0; TreeNode* parent = createNode(data[0]); root = parent;//记录树根，最后返回 queue[rear++] = parent; for (int i = 1; i &lt; size; i++) { parent = queue[front]; TreeNode* newNode = createNode(data[i]); if (parent-&gt;lchild == NULL) { parent-&gt;lchild = newNode; } else if (parent-&gt;rchild == NULL) { parent-&gt;rchild = newNode; front++; } queue[rear++] = newNode; } free(queue); return root; } //二叉树的中序线索化 void inOrderThreadedTree(TreeNode* p, TreeNode* &amp;pre) { if (p !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b49866081bc7b4eaeb663ac906d5685/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44962665d84d64ad7d704a5b1c6f1059/" rel="bookmark">
			UNext翻译（UNext基于MLP的医学图像快速分割网络）（有那么一丢丢没看懂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（发表在miccai期刊）
摘要
近年来，UNet及其最新扩展如TransUNet已成为领先的医学图像分割方法。然而，由于这些网络参数多、计算复杂且使用速度慢，因此不能有效地用于即时护理应用中的快速图像分割。为此，我们提出了一种基于卷积多层感知器(MLP)的图像分割网络UNeXt。我们以一种有效的方式设计了UNeXt，其中包s和潜伏阶段的MLP阶段。我们提出了一个标记化（切片）的MLP块，我们有效地标记和投影（关联）卷积特征，并使用MLP来建模表示。为了进一步提高性能，我们建议在向mlp输入的同时改变输入的通道，以便专注于学习局部依赖关系。在潜在空间中使用标记化mlp减少了参数的数量和计算复杂性，同时能够产生更好的表示来帮助分割。该网络还包括各级编码器和解码器之间的跳过连接。我们在多个医学图像分割数据集上对UNeXt进行了测试，结果表明我们将参数数量减少了72倍，计算复杂度降低了68倍，推理速度提高了10倍，同时也获得了比目前最先进的医学图像分割架构更好的分割性能
(让我通过一个示例来解释什么是MLP（多层感知器）和什么是标记化MLP。
假设我们有一个文本分类任务，我们需要判断一段文本是正面评价还是负面评价。我们使用一个简单的模型来处理这个任务。
普通的MLP：首先，我们考虑一个普通的MLP。在这个模型中，我们将整个文本编码为一个固定大小的向量，然后通过MLP进行分类。例如：
输入：一段文本 "这部电影非常好看！"预处理：将文本转换为数字序列或词嵌入（例如："这部电影非常好看！" -&gt; [0.2, 0.5, -0.1, 0.8, ...])MLP：将整个向量送入一个MLP，包括一个或多个全连接层，激活函数等。输出：模型输出正面评价或负面评价。在这种情况下，整个文本被视为一个输入，并且MLP将应用于整个输入向量。
标记化MLP：现在，让我们考虑标记化MLP。在这个情况下，我们会将文本分成标记或词语，并且每个标记都会通过相同的MLP层进行独立的处理。例如：
输入：一段文本 "这部电影非常好看！"预处理：将文本分成标记：["这部", "电影", "非常", "好看", "！"]MLP（标记化）：将每个标记分别送入相同的MLP层。输出：每个标记都会有一个输出，然后可以对这些输出进行汇总或合并以进行最终的分类决策。 在标记化MLP中，每个标记都会通过相同的MLP进行处理，这意味着MLP的权重和参数是共享的，但它们独立应用于每个标记。这有助于模型更好地捕捉文本中的局部信息和特征，而不仅仅是整个文本的全局信息。
总之，标记化MLP允许模型在处理序列数据时更细粒度地考虑每个标记，而不仅仅是整个序列，这在自然语言处理等任务中非常有用。
)
1 介绍
医学成像解决方案在医疗保健领域的诊断和治疗中发挥了关键作用。医学成像应用中的一个主要任务是分割，因为它对计算机辅助诊断和图像引导手术系统至关重要。在过去的十年中，文献中的许多工作都集中在开发高效和鲁棒的分割方法。UNet[17]是一项具有里程碑意义的工作，它显示了具有跳过连接的编码器-解码器卷积网络对于医学图像分割的效率。近年来，UNet已成为几乎所有主要医学图像分割方法的支柱。继UNet之后，还有一些关键扩展，如unet++ [29]， UNet3+ [13]， 3D UNet [7]， V-Net [16]， Y-Net[15]和KiUNet[21,22]已经被提出。最近，许多基于transformer的网络被提出用于医学图像分割，因为它们学习了对图像的全局理解，这有助于分割。TransUNet[6]将ViT架构[10]修改为用于二维医学图像分割的UNet。其他基于transformer的网络如MedT[20]、TransBTS[25]和UNETR[11]也被提出用于医学图像分割。请注意，上述几乎所有的工作都集中在提高网络的性能上，但没有太多关注计算复杂性、推理时间或参数数量，而这些在许多现实世界的应用中是必不可少的。由于其中大多数用于实验室环境中的分析，因此使用具有高计算能力(如gpu)的机器进行测试。这有助于加快推理的速度，也有助于适应大量的参数。
近年来，医学成像解决方案已经从实验室转移到床边。这被称为即时成像，因为测试和分析是在病人身边完成的。即时成像[23]帮助临床医生扩大服务选择，改善患者护理。它有助于减少病人去放射中心的时间和程序。围绕护理点成像的技术改进正在带来更高的患者满意度。近年来，即时医疗设备的使用一直在增加。例如，即时超声(POCUS)设备[1]已被证明可用于快速检查肺部胸膜不规则性、心脏血流动力学流量和自动膀胱体积计算。基于手机摄像头的图像也被用于检测和诊断皮肤状况[2]。磁共振成像仪(MRI)也被开发用于床边操作和快速分析[3]。这些最近的诊断发展有助于在医疗点清晰快速地获取医学图像，如图1所示。分割、分类和注册等任务也与这些设备集成在一起，以帮助患者和临床医生加快诊断过程。这些任务的主要基于深度学习的解决方案(如UNet和TransUNet)具有固有的计算开销大量的参数使它们难以在护理点应用中使用。在这项工作中，我们专注于解决这个问题，并设计了一个高效的网络，该网络具有更少的计算开销，更少的参数数量，更快的推理时间，同时保持良好的性能。设计这样一个网络对于适应医学影像从实验室到床边的转变趋势至关重要。为此，我们提出了使用卷积网络和(多层感知器)mlp设计的UNeXt。
图1所示。开发UNeXt的动机:随着医疗成像解决方案越来越适用于医疗点，重点是使深度网络轻量化、快速，同时又高效。(a)护理点医疗干预工作流程。(b)最近的医学成像发展:POCUS设备[1]和(c)基于手机的皮肤病变检测和识别应用[2]。
最近，基于mlp的网络[27,19,14,18]也被发现能够胜任计算机视觉任务。特别是MLP-Mixer[18]，这是一种基于全mlp的网络，计算量更少，性能与transformer相当。受这些工作的启发，我们提出了基于卷积和mlp的网络UNeXt。我们仍然遵循UNet的5层深度编码器-解码器架构，并使用跳过连接，但改变了每个块的设计。我们在UNeXt中有两个阶段——卷积阶段和MLP阶段。我们在网络的初始和最终块中使用卷积核数量较少的卷积块。在瓶颈中，我们使用了一种新的token化MLP (TokMLP)块，它可以有效地保持更少的计算，同时也能够建立良好的表示模型。Tokenized MLP将卷积特征投影到抽象标记中，然后使用MLP学习有意义的信息进行分割。我们还在mlp中引入了移位操作（相当于是滑动窗口），以提取不同轴向移位对应的局部信息。由于标记化特征的维数较少，mlp比卷积或自关注和变形更简单;我们能够在保持良好性能的同时显著减少参数数量和计算复杂度。我们在ISIC皮肤病变数据集[8]和乳腺超声图像(BUSI)数据集[4]上评估了UNeXt，并表明它比最近的通用分割架构获得了更好的性能。更重要的是，与TransUNet相比，我们减少了72倍的参数数量，减少了68倍的计算复杂度，并将推理速度提高了10倍，使其适合于即时医疗成像应用。
（什么叫标记化MLP会将卷积特征投影到抽象标记中，然后使用MLP学习有意义的信息进行分割）
示例文本：假设我们有以下一段文本评论，其中标记已经分好了：
文本： "这部电影非常好看！"
标记： ["这部", "电影", "非常", "好看", "！"]
卷积操作：我们使用一维卷积操作来捕捉局部特征。假设我们有一个卷积核（窗口大小为3），它在文本上滑动。卷积操作会计算每个窗口中的局部特征。
例如，卷积核从文本的开头开始，覆盖标记 ["这部", "电影", "非常"]。它可以识别到这个窗口中包含了一个形容词 "非常"，这是一个积极的修饰词。
接着，卷积核向右滑动一个标记，覆盖标记 ["电影", "非常", "好看"]。这时它可能会注意到 "电影" 和 "好看" 之间的关系，这是一个积极的评价。
将卷积特征与标记相关联：在卷积操作的每一步，生成的局部特征与当前窗口中的标记相关联。例如，生成的第一个特征可能与标记 "非常" 相关联，第二个特征可能与标记 "好看" 相关联。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44962665d84d64ad7d704a5b1c6f1059/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bde57a64ae2fc48dee9809c2fb94fe7/" rel="bookmark">
			二叉树的前、中、后、层序的非递归遍历C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//前序遍历：结点右孩子先入栈，左孩子后入栈，空结点不入栈 vector&lt;int&gt; preorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if(root == NULL) return result; st.push(root); while(!st.empty()){ TreeNode *node = st.top(); st.pop(); result.push_back(node-&gt;val); if(node-&gt;right) st.push(node-&gt;right); //先入栈右结点 if(node-&gt;left) st.push(node-&gt;left); } return result; } //后序遍历：结点左孩子先入栈，右孩子后入栈，空结点不入栈。并且将结果数组反转 vector&lt;int&gt; postorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if(root == NULL) return result; st.push(root); while(!st.empty()){ TreeNode *node = st.top(); st.pop(); result.push_back(node-&gt;val); if(node-&gt;left) st.push(node-&gt;left);//先入栈左结点 if(node-&gt;right) st.push(node-&gt;right); } reverse(result.begin(),result.end()); //反转结果数组 return result; } //中序遍历：用指针来访问结点，用栈来保存中间结点 vector&lt;int&gt; inorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; TreeNode* cur = root; while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bde57a64ae2fc48dee9809c2fb94fe7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c19e7679974bf9d2055c4fd956baaa5/" rel="bookmark">
			安装最新版vue-cli，并搭建一个vue2项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装最新版vue-cli，并搭建一个vue2项目 卸载旧版本环境 卸载node.js 可以使用qq电脑管家，找到nodejs卸载即可 cmd查看vue cli版本（可以看到我们是vue cli 2.x） C:\Users\youzhengjie666&gt; vue -V 2.9.6 卸载vue cli 2.x npm uninstall vue-cli -g 卸载vue cli 3.x npm uninstall -g @vue/cli 安装新版本环境 安装nodejs 1：进入nodejs官网 官网
2：下载并安装nodejs（除了图片放出来的，其余的一直点击next即可） 3：检查node和npm是否安装成功： C:\Users\youzhengjie666&gt; node -v v16.17.1 C:\Users\youzhengjie666&gt; npm -v 8.15.0 配置npm仓储和缓存 npm config set registry https://registry.npm.taobao.org npm config set prefix “C:\Program Files\nodejs\global” npm config set cache “C:\Program Files\nodejs\cache” 配置环境变量 添加这三个Path环境变量，下面的路径要修改成自己的nodejs目录！ C:\Program Files\nodejs\ %NODE_PATH% C:\Program Files\nodejs\global 升级npm最新版本 npm install -g npm C:\Users\youzhengjie666&gt; npm -v 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c19e7679974bf9d2055c4fd956baaa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec420bfa770b8ade2d4211f5514ea75f/" rel="bookmark">
			Git Cherry Pick详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 简介 Git是一款分布式版本控制系统，它提供了许多强大的功能来管理代码的版本和变更。`cherry-pick`是一个非常常用的Git命令，它的功能是将某个分支的某次提交应用到当前分支。这对于将特定的代码改动从一个分支移动到另一个分支非常有用。例如，你可能在开发分支上修复了一个bug，然后想要将这个修复应用到主分支，而不带入其他开发分支的改动，这时候就可以使用`cherry-pick`命令。本篇博客将详细介绍cherry-pick命令的使用方法和示例。
2. cherry-pick命令的基本用法 cherry-pick命令的基本语法如下：
git cherry-pick &lt;commit&gt; 其中，&lt;commit&gt;是要应用的提交的哈希值或分支名。该命令会将指定的提交应用到当前分支上，并创建一个新的提交。
3. cherry-pick的使用场景 cherry-pick命令常用于以下场景：
合并单个提交：当我们只想应用某个分支上的一个提交到当前分支时，可以使用cherry-pick命令，而不需要合并整个分支。修复bug：当我们在一个分支上修复了一个bug，并希望将这个修复应用到其他分支上时，可以使用cherry-pick命令。提取特定功能：当我们在一个分支上开发了一个新功能，并希望将该功能应用到其他分支上时，可以使用cherry-pick命令。 4. cherry-pick的示例 为了更好地理解cherry-pick命令的使用方法，下面将给出一些示例。
示例1：合并单个提交 假设我们有一个分支feature，其中有一个提交abc123，我们想将该提交应用到master分支上。可以使用以下命令：
git cherry-pick abc123 这将在master分支上创建一个新的提交，包含与abc123相同的更改。
示例2：修复bug 假设我们在bugfix分支上修复了一个bug，并希望将这个修复应用到develop分支上。可以使用以下命令：
git cherry-pick bugfix 这将在develop分支上创建一个新的提交，包含bugfix分支上的修复。
示例3：提取特定功能 假设我们在feature1分支上开发了一个新功能，并希望将该功能应用到feature2分支上。可以使用以下命令：
git cherry-pick feature1 这将在feature2分支上创建一个新的提交，包含feature1分支上的功能。
示例4：在IntelliJ IDEA中使用cherry-pick 下面是在IntelliJ IDEA中使用`cherry-pick`的一个详细例子：
假设你有两个分支，一个是`master`分支，一个是`feature`分支。你在`feature`分支上做了一个小的bug修复，并且提交了这个改动。现在你想要将这个bug修复应用到`master`分支。
1. 在IDEA中，首先切换到`Version Control`窗口。你可以通过`View` -&gt; `Tool Windows` -&gt; `Version Control`来打开它，或者直接使用快捷键`Alt + 9`。
2. 在`Version Control`窗口中，切换到`Log`标签。
3. 在`Log`标签中，你会看到所有的提交记录。找到你在`feature`分支上的bug修复提交，然后右键点击这个提交。
4. 在右键菜单中，选择`Cherry-Pick`选项。
5. 在弹出的对话框中，确认你想要cherry-pick的提交，然后点击`Cherry-Pick`按钮。
6. 现在，IDEA会将你选中的提交应用到当前分支。如果有冲突，IDEA会提示你解决冲突。解决完冲突后，你可以选择提交或者暂时不提交。
7. 完成以上步骤后，你在`feature`分支上的bug修复提交就被应用到了`master`分支。
注意：在使用`cherry-pick`时，你需要确保你的工作区是干净的，也就是说，你没有未提交的改动。如果你有未提交的改动，你需要先提交或者撤销这些改动，然后再进行`cherry-pick`操作。
5. cherry-pick的注意事项 在使用cherry-pick命令时，有一些注意事项需要了解：
cherry-pick会创建一个新的提交，因此可能会引入冲突。如果发生冲突，需要手动解决冲突后再继续应用提交。cherry-pick只能应用一个提交，如果要应用多个提交，可以使用git rebase -i命令进行交互式变基。cherry-pick不会自动合并提交的作者和提交日期，而是使用当前分支的作者和日期。如果需要保留原有的作者和日期信息，可以使用--no-commit选项，并手动修改提交信息后再提交。 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec420bfa770b8ade2d4211f5514ea75f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/76/">«</a>
	<span class="pagination__item pagination__item--current">77/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/78/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>