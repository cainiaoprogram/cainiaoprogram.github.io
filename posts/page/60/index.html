<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ad8be1e029d540e841bd28984ea1bc5/" rel="bookmark">
			Crypto--RSA系列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录自己学习RSA所做的一些题。 目录
【RSA1】P1（p，q，e，c）
【RSA1】P2（n，e，c）
【RSA1】P4 (yafu)
【RSA1】P5 （yafu）
【RSA1】P6（e，n1，c1，n2，c2）
【SRA1】P7（e，p，q，r）
【RSA1】P8
【RSA1】P9（考虑flag很短）
【RSA1】P10 （e和phi不互素）
【RSA2】P1（低加密指数）
【RSA2】P3（Rabin）
【RSA2】P4（Weiner）
【RSA2】P6（p-1光滑）
【RSA2】P7 (p+1)光滑
【RSA2】P8 共模攻击
【RSA2】P9 dp、dq泄露
【RSA2】P10 dp泄露
【RSA2】p11 大指数dp泄露
【RSA2】P12 d泄露
【RSA3】P1（扩展欧几里得）
【RSA3】P2（高次Rabin）
【RSA3】P3（连分数利用）
低加密指数广播攻击
【RSA1】P1（p，q，e，c） 已知p,q,e,c,可直接求出d,然后求出m
import gmpy2 p = 10554915510546378513140074459658086644656654144905337809416976066414771647836950941616441505897207397834928781511863699153349798682451297889979721668885951 q = 8246403321715011123191410826902524505032643184038566851264109473851746507405534573077909160292816825514872584170252311902322051822644609979417178306809223 e = 65537 c = 40005881669517895877352756665523238535105922590962714344556374248977905431683140065629966778249773228248201807844489945346731806741025157651474530811920115794270396320935022110691338083709019538562205165553541077855422953438117902279834449006455379382431883650004540282758907332683496655914597029545677184720 n = p*q phi1 = (q-1)*(p-1) d = gmpy2.invert(e, phi1) m = gmpy2.powmod(c, d, n) m = hex(m).replace('0x', '') flag = bytes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ad8be1e029d540e841bd28984ea1bc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/610e42876e849e8cc1f83ed8ece40779/" rel="bookmark">
			手把手系列！用 Milvus 和 Python 搭建电影推荐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐系统（推荐引擎）是根据用户行为和兴趣点等信息去预测并推送用户当前需要或感兴趣的物品（服务）的一类应用。常见推荐系统包括电影、书籍、音乐或新闻文章推荐系统等。
基于不同的算法或技术，推荐系统有很多种类型，如协同过滤算法（Collaborative Filtering）推荐系统、基于内容（Content-Based）的推荐系统、混合推荐系统和基于向量的推荐系统。其中，基于向量的推荐系统使用向量空间来寻找（即推荐）数据库中最相似的产品或内容。而存储向量数据最有效的方法便是使用 Milvus 这样全球领先的向量数据库。
本文将介绍如何使用 Milvus 和 Python 搭建电影推荐系统。在搭建过程中，我们会使用 SentenceTransformers 将文本信息转换为向量，并将这些向量存储在 Milvus 中。搭建完成后，用户便可输入描述并在推荐系统中搜索到相似的电影。如需本教程中的所有代码，参考：
GitHub上的 Milvus Bootcamp 仓库
Jupyter Notebook
01.设置环境 开始前，请先安装：
Python 3.x
Python Package Manager (PIP)
Jupyter Notebook
Docker
至少 32 GB RAM 的硬件系统或 Zilliz Cloud 账号
使用Python安装所需工具和软件 $ python -m pip install pymilvus pandas sentence_transformers kaggle 向量数据库 Milvus 本教程中我们将用 Milvus 存储由电影信息转化而来的 Embedding 向量。由于使用到的数据集较大，推荐大家创建 Zilliz Cloud 集群来存储向量数据库。但如果仍想安装本地实例，可下载 docker-compose 配置文件并运行文件。
$ wget https://github.com/milvus-io/milvus/releases/download/v2.3.0/milvus-standalone-docker-compose.yml -O docker-compose.yml $ docker-compose up -d 一切准备就绪后，便可以搭建电影推荐系统啦！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/610e42876e849e8cc1f83ed8ece40779/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8dd908a6d97cf3f41e56326c97f3fa6/" rel="bookmark">
			网络工程师【目录】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 从2023年下半年开始，所有的软考全面改革，由原来的笔试改为机考，据说难度会有一些增加，望悉知。
报名地址：中国计算机技术职业资格网
历史报名时间和考试时间：3月份报名，5月底考试；8月份报名，11月初考试。
报名费用：因地区不同可能存在差异，平均一科七八十元左右
整理网络资料 资料来源自网络，请及时保存。
软考网络工程师VIP持续更新-2024年【百度网盘密码1234】
软考中级网工-网络工程师资料分享【哔哩哔哩】
CTO说 - 网络工程师【百度网盘密码qqj4】
网络工程师5天修炼 第三版
章节笔记【自用】 章节名称状态第一章计算机网络概论未完成第二章数据通信基础未完成第三章广域通信网未完成第四章局域网和城域网未完成第五章无线通信网未完成第六章-0考点分析未完成第六章-1网络互联设备未完成第六章-2网络层协议IP和ICMP未完成第六章-3传输层协议TCP UDP未完成第六章-4路由协议未完成第七章下一代互联网IPV6未完成第八章网络安全未完成第九章网络操作系统与应用服务器（上）未完成第九章网络操作系统与应用服务器（下）未完成第十章组网技术未完成第十一章网络管理未完成第十二章网络规划设计未完成第十三章华为配置专题基础篇未完成第十四章华为配置专题进阶篇未完成补充知识1计算机组成原理未完成补充知识2操作系统未完成补充知识3软件工程未完成补充知识4标准化与知识产权未完成 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45751153a6c283028717ba5be56f906e/" rel="bookmark">
			VLAN接口的基本配置、Access接口模式、Trunk接口模式、Hybrid接口模式，STP生成树协议的基本概念与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、vlan 1.将多个端口加入vlan [Huawei]port-group 1创建端口组
[Huawei-port-group-1]group-memberg0/0/1 to g0/0/10 添加端口组成员
[Huawei-port-group-1]port link-type access
[Huawei-port-group-1]port default vlan 10
2、如何区分不同的VLAN数据？ 1） 要使交换机能够区分不同VLAN的数据帧，需要在帧中添加标识VLAN信息的字段
2） IEEE 802.1Q协议规定：在以太网数据帧的源MAC地址字段之后、协议类型字段之前加入4个字节的VLAN标签（又称VLAN Tag，简称Tag），用以标识VLAN信息。
3） VLAN数据帧：目的地址+源地址+【Vlan-Tag】+类型+数据+帧校验序列
-Vlan-Tag : 共4个字节，分为4个字段，只需要记住最后一个字段 VID即可
-VID： 可以理解为VLAN编号， 是vlan-tag中的第四个字段，大小12个bit
-2的12次方是4096 ，所以可以创建（0~4095）个vlan,但是0和4095 是被保留了
所以一个交换机中可以创建的vlan编号范围是 1 ~ 4094
3、PVID： -PVID：Port Default VLAN ID，又称缺省VLAN，表示接口所属的VLAN
-每一个接口都有一个PVID
-默认情况下，交换机所有的接口的的PVID都是1
4、在一个VLAN交换网络中，以太网帧分类： 有标记帧（Tagged帧）：加入了4字节VLAN标签的帧 目的地址+源地址+ 【Vlan-Tag】 +类型+数据+帧校验序列 无标记帧（Untagged帧）：原始的、没有加入4字节VLAN标签的帧 目的地址+源地址+类型+数据+帧校验序列 常用设备中：
用户主机、服务器只能收发Untagged帧。交换机、路由器既能收发Tagged帧，也能收发Untagged帧。 5、Access 接口模式： 工作场景： 通常用于交换机连接终端设备（主机、服务器）
特点：
-同时只能属于一个VLAN
-当交换机接收数据帧时，若该帧不带VLAN标签，用接口PVID的数值作为标签，给数据帧打标签
-接收数据帧时，若该帧带VLAN标签，判断VLAN标签和本接口的PVID是否一致，一致则接收数据，不一致则丢弃数据
-发送数据帧时，一律剥离VLAN标签
6、Trunk 接口模式： 工作场景： 通常用于交换机与交换机互联
特点：
-同时可以属于多个vlan，同一时间可以传递多个vlan数据流
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45751153a6c283028717ba5be56f906e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/774051f65af8257eec7b70a5de240187/" rel="bookmark">
			Linux文件和目录的777、755、644权限解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.文件权限 在linux系统中,文件或目录的权限可以分为3种:
r:4 读
w:2 写
x:1 执行(运行)
－：对应数值0
数字 4 、2 和 1表示读、写、执行权限
rwx = 4 + 2 + 1 = 7 (可读写运行）
rw = 4 + 2 = 6 （可读写不可运行）
rx = 4 +1 = 5 （可读可运行不可写）
示例:
最高权限777:(4+2+1) (4+2+1) (4+2+1)
第一个7:表示当前文件的拥有者的权限,7=4+2+1 可读可写可执行权限
第二个7:表示当前文件的所属组（同组用户）权限,7=4+2+1 可读可写可执行权限
第三个7:表示当前文件的组外权限,7=4+2+1 可读可写可执行权限
示例:
755:(4+2+1) (4+1) (4+1)
第一个7:表示当前文件的拥有者的权限,7=4+2+1 可读可写可执行权限
第二个5:表示当前文件的所属组（同组用户）权限,5=4+1 可读可执行权限
第三个5:表示当前文件的组外权限,5=4+1 可读可执行权限
示例:
644:(4+2) (4) (4)
第一个6:表示当前文件的拥有者的权限,6=4+2 可读可写不可执行权限
第二个4:表示当前文件的所属组（同组用户）权限,4=4 可读权限
第三个4:表示当前文件的组外权限,4=4 可读权限
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/774051f65af8257eec7b70a5de240187/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f42a0b16b5a9cc7bf94dc055136b9169/" rel="bookmark">
			[INS-06006]AIX7.2 安装19c互信通不过
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在给某客户AIX7.2上安装19c的集群软件时，报错[INS-06006]Passwordless SSH connectivity not set up between the following…在尝试了手动互信和自带脚本的互信都通不过之后,其中通过自带脚本的互信已经可以实现节点间互相免密ssh，但是互信这一步就是检测不通过:
ssh node date是可以的
验证用户等效性也是通过的： $GI_HOME/runcluvfy.sh comp admprv -n rac1,rac2 -o user_equiv -sshonly -verbose 后面通过mos匹配发现：
INS-06006 GI RunInstaller Fails If OpenSSH Is Upgraded to 8.x (文档 ID 2555697.1) 由于操作系统OpenSSH版本太高可能会导致此问题的报错：
解决办法：
1.已验证通过
安装前，以root用户身份：（如果您的“scp”的位置与以下不同，请更改路径）
# 重命名原来的scp。 mv /usr/bin/scp /usr/bin/scp.orig #新建文件&lt;/usr/bin/scp&gt;. vi /usr/bin/scp # 将以下行添加到新创建的文件&lt;/usr/bin/scp&gt;。 /usr/bin/scp.orig -T $* # 更改文件权限。 chmod 555 /usr/bin/scp 安装完成后修改回去： mv /usr/bin/scp.orig /usr/bin/scp 2.打补丁(未验证)
在运行“gridSetup.sh”之前应用补丁 30159782，有关如何在运行“gridSetup.sh”之前应用 OneOff 补丁，请参阅（Doc ID 1410202.1）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bc77d202d2867dfe3e90742158b9c1d/" rel="bookmark">
			MindOpt APL：一款适合优化问题数学建模的编程语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是建模语言 建模语言是一种描述信息或模型的编程语言，在运筹优化领域，一般是指代数建模语言。
比如要写一个线性规划问题的建模和求解，可以采用C、Python、Java等通用编程语言来实现计算机编程（码代码），也可以换采用建模语言。
本文将以阿里达摩院研发的MindOpt建模语言(MindOpt Algebra Programming Language, MindOptAPL，简称为MAPL)来讲解。MAPL是一种高效且通用的代数建模语言，当前主要用于数学规划问题的建模，并支持调用多种求解器求解。
代数建模语言工作原理 在数学规划领域，遇到一个实际问题时候，我们需要数学建模成优化问题模型、然后编程、然后计算优化结果，得到这个实际问题的解决方案。
在这个编程过程中，可以根据选用的计算工具——优化求解器提供的通用编程语言的API来编写代码，也可以采用建模语言来编写代码。如下示例，就是一个利用MAPL建模语言来进行一个优化问题码的代码。
左边是数学模型，三要素：两个变量xa和xb，目标函数是最大化一个公式，约束是最下面两行，限定取值关系。中间是用MAPL建模语言编的代码。可以看到前面4行就表达清楚了左边的数学公式。最后“option solver mindopt；”是设置计算这个问题的求解器为mindopt求解器，“solve；”是执行求解。右边就是求解器的计算结果，xa = 3，xb=5，此时目标函数最大，是1050。 为什么要用建模语言 语法更简单（代码对比） 从上面我们可以看到建模语言可以方便地进行数学建模和求解的代码。这里我们对比一下建模语言和通用的编程语言，来看看用建模语言优势。
以下面这个问题为示例：
| 线性规划模型：
max x0 + 2 * x1 + 3 * x2 + x3
s.t. (-1) * x0 + x1 + 3 * x2 + 10 * x3 &lt;= 20
x0 - 3 * x1 + x2 = 30
x1 - 3.5 * x3 = 0
0 ≤ x0 ≤ 40
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bc77d202d2867dfe3e90742158b9c1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad22681c06131715c36ab02121a84448/" rel="bookmark">
			android开发在android13中存储权限发生变化，READ_EXTERNAL_STORAGE，WRITE_EXTERNAL_STORAGE无法使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原来的两个存储权限在android13中已经无法使用
&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; 在android13中读取图片需要以下权限：
&lt;uses-permission android:name="android.permission.READ_MEDIA_IMAGES" /&gt; 视频权限：
&lt;uses-permission android:name="android.permission.READ_MEDIA_VIDEO" /&gt; 音频权限：
&lt;uses-permission android:name="android.permission.READ_MEDIA_AUDIO" /&gt; 如果需要访问pdf,word等其他类型文件，请使用以下权限：
&lt;uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE"/&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6778b88f38e0018fe3c3c82831b12159/" rel="bookmark">
			latex使用技巧：其中一行文字超出正文边界（设置自动换行，两端对齐）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在用latex写论文时，如果一行中有一个单词过长，或者是有一个比较长的公式，有的模板中不会自动换行，这一行的内容就会超出正文的边界，如下图所示：
解决方法：
\begin{document} \begin{sloppypar} 文本内容 \end{sloppypar} \end{document} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c76011b58f4e798f9fa9304ab8fa95a5/" rel="bookmark">
			AI 训练框架：Pytorch TensorFLow MXNet Caffe ONNX PaddlePaddle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 https://medium.com/jit-team/bridge-tools-for-machine-learning-frameworks-3eb68d6c6558 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0477790600f89abd13b246f0e6f1a360/" rel="bookmark">
			golang rsa 加解密兼容 PKCS8 PKCS1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package rsa import ( "bytes" "crypto/rand" r "crypto/rsa" "crypto/x509" "encoding/base64" "encoding/pem" "errors" "strings" ) // RSAEncryptor 结构体 type RSACryptor struct { privateKey []byte publicKey []byte rsaPrivateKey *r.PrivateKey rsaPublicKey *r.PublicKey } // new struct func NewRSACryptor(privateKey, publicKey string) (obj *RSACryptor, err error) { obj = &amp;RSACryptor{ privateKey: []byte(privateKey), publicKey: []byte(publicKey), } obj.rsaPrivateKey, err = obj.getRsaPrivateKey() if err != nil { return } obj.rsaPublicKey, err = obj.getRsaPublicKey() if err != nil { return } return } // 加密 func (this *RSACryptor) Encrypt(origData []byte) ([]byte, error) { //加密 return r.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0477790600f89abd13b246f0e6f1a360/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae437c031792d0e781f50489a564c2da/" rel="bookmark">
			Swagger页面报错Resolver error at definitions
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 打开swagger页面报错Resolver error at definitions
原因分析： 从错误提示可以看出，是由map引起的原因，具体是因为swagger配置没有默认添加map的复杂结构引起的，需要手动添加。
解决方案： 找到swagger配置类，在Docket方法里添加mapRule即可，Map的类型就按报错的标题格式添加。
@Configuration @EnableSwagger2 public class SwaggerConfig { @Bean public Docket createRestApi() { Docket docket = new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)) .paths(PathSelectors.any()) .build(); //参数可以多个 docket.alternateTypeRules( AlternateTypeRules.newMapRule(String.class, Object.class), AlternateTypeRules.newMapRule(String.class, List.class) ); return docket; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ee11bd00dd2e723f4ee5406941fb127/" rel="bookmark">
			【JavaEE进阶】 Spring使用注解存储对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🌴序言🍀前置⼯作：配置扫描路径🎄添加注解存储 Bean 对象🌳类注解🚩为什么要这么多类注解🚩注解之间的联系 🎋⽅法注解 @Bean🚩⽅法注解需要配合类注解使⽤ ⭕总结 🌴序言 在博主前面所写的《【JavaEE进阶】 Spring 的创建和使⽤》中我们已经可以实现基本的 Spring 读取和存储对象的操作了，但在操作的过程中我们发现读取和存储对象并没有想象中的那么“简单”，所以接下来我们要学习更加简单的操作 Bean 对象的⽅法。
在 Spring 中想要更简单的存储和读取对象的核⼼是使⽤注解
之前我们存储 Bean 时，需要在 spring-config 中添加⼀⾏ bean 注册内容才⾏，如下图所示：
⽽现在我们只需要⼀个注解就可以替代之前要写⼀⾏配置的尴尬了，不过在开始存储对象之前，我们先要来点准备⼯作
🍀前置⼯作：配置扫描路径 注意：
想要将对象成功的存储到 Spring 中，我们需要配置⼀下存储对象的扫描包路径，只有被配置的包下的所有类，添加了注解才能被正确的识别并保存到Spring 中 在 spring-config.xml 添加如下配置
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:content="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;content:component-scan base-package="org.example"&gt;&lt;/content:component-scan&gt; &lt;/beans&gt; 其中标红的⼀⾏为注册扫描的包，如下图所示
注意
如果不是在配置的扫描包下的类对象，即使添加了注解，也是不能被存储到 Spring 中的 🎄添加注解存储 Bean 对象 想要将对象存储在 Spring 中，有两种注解类型可以实现：
类注解：@Controller、@Service、@Repository、@Component、@Configuration。
⽅法注解：@Bean。
🌳类注解 由于这五种类注解的使用方式基本相同，所以博主在这里只演示一种即可
@Controller // 将对象存储到 Spring 中 public class UserController { public void sayHi(String name) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ee11bd00dd2e723f4ee5406941fb127/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa15af49b18d94af858a3c0a2003018a/" rel="bookmark">
			Swagger提示请确保swagger资源接口正确
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 在项目开发过程中集成swagger-bootstrap-ui，打开swagger-ui.html页面正常，但是打开doc.html页面提示"请确保swagger资源接口正确"。 原因分析： 原因是JSON格式非法，一般出现此情况时，是因为后端在给属性赋予了exmpale属性时，赋值了json字符串导致。
比如：
@ApiModelProperty(value = "客户字段数据",example = "{'id':'xxx'}") private List&lt;String&gt; fields; @ApiModelProperty(value = "参数数据",example = "{'name':'xxx'}") private String param; 解决方案： 把属性中的example去掉，或者把单引号替换成转义后的双引号
@ApiModelProperty(value = "客户字段数据",example = "{\"id\":\"xxx\"}") private List&lt;String&gt; fields; @ApiModelProperty(value = "参数数据",example = "{\"name\":\"xxx\"}") private String param; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47712e5599696dfdd5438a2dcff01adc/" rel="bookmark">
			脚本修改linux时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于一些可能的业务，可能需要修改系统时间，这时候可以使用很多命令（注意，时间修改需要超级管理员权限）
1.date
date date 可以直接获得当前系统时间
date -s "2023-01-01 12:00:00" 修改时间，注意这个指令很容易失败，系统可能有系统自动获取时间的锁。
2.timedatectl
timedatectl timedatectl可以获取当前系统和时区等所有时间
例：
timedatectl set-time '2023-01-01 18:08:08' 这个指令为设置时间的指令
如果不被允许，显示自动获取时间打开可以通过一下指令修改：
timedatectl set-ntp no //关闭自动同步时间 timedatectl set-ntp yes //开启自动同步时间 3.等等还有一些获取时间指令，不列了，够用就行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf759d0476ea0edd0b4ecff92cf14013/" rel="bookmark">
			ArcMap中构建金字塔详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.金字塔 1.1 定义 金字塔可用于改善性能。它们是原始栅格数据集的缩减采样版本，可包含多个缩减采样图层。金字塔的各个连续图层均以 2:1 的比例进行缩减采样。如下图所示。从金字塔的底层开始每四个相邻的像素经过重采样生成一个新的像素，依此重复进行，直到金字塔的顶层。重采样的方法一般有以下三种: 双线性插值（BILINEAR）、最临近像元法（NEAREST）、三次卷积法（CUBIC）。其中最临近像元法速度最快，如果对图像的边缘要求不是很高，最适合使用该方法。三次卷积由于考虑的参考点数太多、运算较复杂等原因，速度最慢，但是重采样后图像的灰度效果较好。
1.2 作用 金字塔通过仅检索使用指定分辨率(取决于显示要求)的数据，可以加快栅格数据的显示速度。利用金字塔，可在绘制整个数据集时快速显示较低分辨率的数据副本。而随着放大操作的进行，各个更精细的分辨率等级将逐渐得到绘制;但性能将保持不变，因为您在连续绘制更小的各个区域。数据库服务器会根据用户的显示比例自动选择最适合的金字塔等级。如果不使用金字塔 (pyramid)，则必须从磁盘中读取整个数据集，然后将其重采样为更小的大小。这便称为“显示重采样”，发生在刷新 ArcGIS 显示内容时。
每个栅格数据集只需构建一次金字塔，之后每次查看栅格数据集时都会访问这些金字塔。栅格数据集越大，创建金字塔集所花费的时间就越长。但是，这也就意味着可以为将来节省更多的时间。
尽管无法为栅格目录构建金字塔，但是可以为栅格目录中的每个栅格数据集构建金字塔。镶嵌数据集与栅格目录类似。您可以为镶嵌数据集中的每个栅格数据集构建金字塔;而为镶嵌数据集构建金字塔时只能使用镶嵌数据集工具集中的特定工具。
2.构建方法 2.1单景影像金字塔构建 ArcToolbox-&gt;Data ManagementTools-&gt;Raster-&gt;Raster Properties-&gt;Build Pyramids
对于尚未构建金字塔的单景影像，在影像添加至ArcMap窗口时，会得到“是否构建金字塔”的提示，这个时候也可以选择构建金字塔。
2.2批量影像金字塔构建 ArcToolbox-&gt;Data ManagementTools-&gt;Raster-&gt;Raster Properties-&gt; Build Pyramids And Statistics
对于数据量比较大的影像，推荐利用批量工具进行金字塔构建
或者ArcToolbox-&gt;Data ManagementTools-&gt;Raster-&gt;Raster Properties-&gt; Batch Build Pyramids
3 提速金字塔构建
金字塔构建过程中有几个可设的参数，它们正是提速金字塔构建的秘密所在。如上图所示
（1）金字塔级别 Pyramidlevels (optional)
金字塔等级是指建立的金字塔层级数量。默认的级别是-1，此时会构建完整的影像金字塔。如果这里设成空值，得到的效果和-1相同。
如果设为0，那么将不会建立金字塔。同时，这也是删除影像金字塔的方法。
金字塔最高级别可以设为29，任何高于29的值都会当作-1处理。
如果按照默认的设置，完整的构建出影像金字塔，耗费的时间一定会较长，所以可以根据需要进行金字塔级别设置。
（2）重采样方法 Pyramidresampling technique (optional)
重采样的方法一般有以下三种: 双线性插值（BILINEAR）、最临近像元法（NEAREST）、三次卷积法（CUBIC）。其中最临近像元法速度最快，如果对图像的边缘要求不是很高，最适合使用该方法。三次卷积由于考虑的参考点数太多、运算较复杂等原因，速度最慢，但是重采样后图像的灰度效果较好。
对于影像，建议采用双线性差值法；对于离散数据，建议采用最邻近像元法。
（3）压缩方式 Pyramidcompression type (optional)
提供了5种压缩方式：
默认——如果源数据采用了小波压缩，金字塔将采用JPEG的压缩方法；否则，则采用LZ77的压缩方法。
LZ77——无损压缩方式，适合于任何类型的数据。
JPEG——有损压缩方式，选择了JPEG压缩，可以设置压缩质量。对于影像数据，通常选择此种压缩方式，如果对影像质量要求不高，可以将压缩比设置为25。
JPEG_YCbCr——种有损压缩，使用亮度（Y）和色度（ Cb和Cr ）色彩空间组件。
NONE——不对金字塔进行压缩。
（4） 设置环境变量 Parallel Processing Factor
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf759d0476ea0edd0b4ecff92cf14013/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1550f4b19213c8d979cee206b79d1c0/" rel="bookmark">
			Docker部署.NET6项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker的三大核心概念 1、docker仓库（repository） docker仓库（repository）类似于代码库，是docker集中存放镜像的场所。实际上，注册服务器是存放仓库的地方，其上往往存放着很多仓库。每个仓库集中存放某一类镜像，往往包括多个镜像文件，通过不同的标签（tag）来进行区分。
根据存储的镜像公开分享与否，docker仓库可以分为公开仓库（Public）和私有仓库（Private）两种形式。目前，最大的公开仓库是Docker Hub,存放了数量庞大的镜像供用户下载，国内的公开镜像包括Docker Pool,可以提供稳定的国内访问，与GitHub类似。
2、docker镜像（Image） docker镜像类似于虚拟机镜像，可以将其理解为一个只读模板。除了提供容器运行时所需的程序、库、资源、配置等文件外，docker镜像还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）
我们把项目打包才成一个镜像，那么这个镜像中就有了我们项目所依赖的所有环境和资源
3、 docker容器（container） .Net项目部署到Docker 1、生成构建Image镜像文件 Vs中右键项目-&gt;添加-&gt;Docker 支持-&gt;目标OS选择 Linux 在项目中会生成个Dockerfile文件
这个Dockerfile文件就是用来构建你项目的Image镜像的，它是一个创建当前项目镜像的所有命令的文本文件
2、将你的项目存放到Linux中 我们可以用MobaXterm 或者其他文件工具将我们的项目存放到Linux中，我们就在Linux系统的root文件下创建了一个叫ZKHK的文件用于存放我们的项目代码，然后我又单独的将Dockerfile文件单独的放在了与项目文件夹同级的ZKHK文件夹下。
3、构建项目镜像 #docker build:表示要构建镜像
#myimagename :是我们自己要构建的镜像的名称，随便我们自己取名（主要名称小写）
#dockerfile：是我们要构建的镜像需要的文件，文件名叫Dockerfile
docker build -t net6projecttest -f Dockerfile .
构建镜像的时候如果提示：
[Warning] IPv4 forwarding is disabled. Networking will not work. 则需要开启 Linux 操作系统的 IP 转发功能
临时开启： 如果你只是希望临时开启 IP 转发功能，可以使用以下命令：
sudo sysctl -w net.ipv4.ip_forward=1
永久开启： 如果你希望永久开启 IP 转发功能，需要编辑配置文件，使其在系统重启时仍然生效
1、编辑 /etc/sysctl.conf 文件
sudo nano /etc/sysctl.conf
或者
sudo vim /etc/sysctl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1550f4b19213c8d979cee206b79d1c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3495aa758b59156605d6ada7517ba06a/" rel="bookmark">
			位(bit)、字节(byte)、字符、编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/ChineseSoftware/article/details/122533596
一、位/比特位
位/比特位，数据存储的最小单位。每个二进制数字0或者1就是1个位。
二、字节(Byte)
字节(Byte)是一种计量单位，表示数据量多少，它是计算机信息技术用于计量存储容量的一种计量单位。
8个位构成一个字节。即：1 byte (字节)= 8 bit (位)；
1 B = 1 byte(字节);
1 KB = 1024 B(字节);
1 MB = 1024 KB;(2^10 B)
1 GB = 1024 MB;(2^20 B)
1 TB = 1024 GB;(2^30 B)
三、字符
字符是指计算机中使用的文字和符号，比如1、2、3、A、B、C、~！·#￥%……—* () ——+、等等。
a、A、中、+、*、の…均表示一个字符；
一般 utf-8 编码下，一个汉字字符占用 3 个 字节；
一般 gbk 编码下，一个汉字字符占用 2 个 字节；
四、“字节”与“字符”
它们完全不是一个维度的概念，所以两者之间没有“区别”这个说法。不同编码里，字符和字节的对应关系不同：
①ASCII码中，一个英文字母(不分大小写)占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。
②UTF-8编码中，一个英文字符等于一个字节，一个中文(含繁体)等于三个字节。
③Unicode编码中，一个英文等于两个字节，一个中文(含繁体)等于两个字节。
符号：英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占1个字节的大小，中文句号“。”占2个字节的大小。
④UTF-16编码中，一个英文字母字符或一个汉字字符存储都需要2个字节(Unicode扩展区的一些汉字存储需要4个字节)。
⑤UTF-32编码中，世界上任何字符的存储都需要4个字节。
五、字符集
即各种各个字符的集合。也就是说汉字，字母(A、b、c)和符号(空格、引号…)会被收入标准中。
六、编码
utf-8和Unicode实际上并不是同一个层次的概念。
规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储，这个规定就叫做“编码”。(其实际是对字符集中进行编码，即：每个字符用二进制在计算中表示存储)；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3495aa758b59156605d6ada7517ba06a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d07d463e1ac7689f51b87c8b1b8a574/" rel="bookmark">
			自建ocr接口动态识别验证码 配bp进行验证码爆破
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 声明：本文仅限学习研究讨论，切忌做非法乱纪之事！
一、插件简介
captcha-killer要解决的问题是让burp能用上各种验证码识别技术！
注意：
插件目前针对的图片型验证码，其他类型目前不支持。
captcha-killer本身无法识别验证码，它专注于对各种验证码识别接口的调用
二、下载地址：
burp2020前使用：
https://github.com/c0ny1/captcha-killer/tree/0.1.2
burp2020后的版本使用：
https://github.com/Ta0ing/captcha-killer-java8
1.下载插件并加载
下载DDDDdocr API 服务器{kali环境下有docker环境}
地址：https://github.com/sml2h3/ocr_api_server.git
git clone https://github.com/sml2h3/ocr_api_server.git cd ocr_api_server # 修改entrypoint.sh中的参数，具体参数往上翻，默认9898端口，同时开启ocr模块以及目标检测模块 # 编译镜像 docker build -t ocr_server:v1 . # 运行镜像 docker run -p 9898:9898 -d ocr_server:v1 部署好之后，docker ps -a看看
映射到9898端口了，接下来验证连通性
curl -v http://ip:9898/ping 返回pong，表示成功
访问验证码的链接地址，抓验证码的请求包,并发送到插件
然后到切换到captcha-killer插件面板，点击获取即可拿到要识别的验证码图片内容（下方验证码url栏处，直接点击获取验证码也行，无需复制验证码url，再点击获取）
注意：获取验证码的cookie一定要和intruder发送的cookie相同！
配置识别接口的地址和请求包
接口地址：http://api.ttshitu.com:80
请求包，username，password处去http://ttshitu.com注册账号，该平台识别500次一元钱：
POST /predict HTTP/1.1
Host: api.ttshitu.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d07d463e1ac7689f51b87c8b1b8a574/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b36976e90c25f3cf1aaa9c7b8a78ec4/" rel="bookmark">
			Shell脚本中if [[-f ]]什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在shell脚本中，if [[ -f 文件路径 ]] 是一个条件语句，用于检查指定路径是否是一个文件。这个条件语句中的关键部分是 -f，它是一个文件测试运算符，用于检查文件是否存在且是一个常规文件（而不是目录或其他类型的文件）。
示例说明：
-f：测试运算符检查指定的路径是否存在，且是一个常规文件。如果条件成立（即文件存在且是一个常规文件），则 if 语句的代码块将被执行。 #!/bin/bash if [[ -f /etc/redhat-release ]]; then echo "文件存在，且是一个常规文件。" else echo "文件不存在或不是一个常规文件。" fi 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be3640cee88f3a541fb5d382db04afa3/" rel="bookmark">
			单片机常见的复位方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几种较为常见的单片机复位方式：外部复位（NRST引脚复位）、看门狗复位、软件复位、低功耗管理复位。
1、外部复位 外部复位依赖硬件的设计，考虑应用设计复位电路。
1.1、上电复位 低电平上电复位：电容两端的电压 不会突变，所以在上电的一刹那NRST引脚的是低电平，单片机复位重启，在很短的时间内，引脚电平由低变到高，单片正常工作。
图1 低电平上电复位电路图
高电平上电复位：引脚在上电前一直是低电平，在上电的一段时间内，引脚由低电平变为高电平实现复位。
图2 高电平上电复位电路图
1.2、手动复位 低电平手动复位：在单片机工作时，想要对其进行复位操作。下图不仅可以上电复位，在按键按下时NRET变成低电平，进行复位。
图3 低电平手动复位图 低电平手动复位：按键按键引脚变成高电平，进行复位。
图4 高电平手动复位图 2、看门狗复位 2.1、看门狗简介和复位原理 一个是独立看门狗另外一个是窗口看门狗,当计数器达到给定的超时值时，触发一个中断(仅适用于窗口型看门狗)或产生系统复位。
独立看门狗(IWDG)由专用的低速时钟(LSI)驱动，即使主时钟发生故障它也仍然有效，LSI 的频率一般在 30~60KHZ 之间，根据温度和工作场合会有一定的漂移，我们一般取 40KHZ。窗口看门狗由从APB1时钟分频后得到的时钟驱动，通过可配置的时间窗口来检测应用程序非正常的过迟或过早的操作。
单片机系统在外界的干扰下会出现程序跑飞的现象导致出现死循环，看门狗电路就是为了避免这种情况的发生。看门狗的作用就是在一定时间内（通过定时计数器实现）没有接收喂狗信号（表示 MCU 已经挂了），便实现处理器的自动复位重启（发送复位信号）。
2.2、代码示例 2.2.1、iwdg.c代码 #include "iwdg.h" /*初始化独立看门狗 prer：分频数：0~7（只有低3位有效！） 分频因子=4*2^prer.但最大值只能是256！ rlr：重装载寄存器值：低11位有效 时间计算（大概）：Tout=((4*2^prer)*rlr)/40(ms). */ void IWDG_Init(u8 prer,u16 rlr) { IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);	//使能对寄存器I写操作 IWDG_SetPrescaler(prer);	//设置IWDG预分频值 IWDG_SetReload(rlr);	//设置IWDG重装载值 IWDG_ReloadCounter();	//按照IWDG重装载寄存器的值重装载IWDG计数器 IWDG_Enable();	//使能IWDG } //喂独立看门狗 void IWDG_Feed(void) { IWDG_ReloadCounter(); } 2.2.2、主函数调用代码 #include "iwdg.h" int main(void) {	IWDG_Init(4,2000);	//初始化看门狗 while (1) { IWDG_Feed();	//喂看门狗 /* 程序代码 */ } } 一旦程序跑飞，一段时间内没有“喂狗”，程序复位。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be3640cee88f3a541fb5d382db04afa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c86a74e5957a5c456b1c6844702af5d/" rel="bookmark">
			使用wire重构商品微服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.wire简介 Wire 是一个轻巧的Golang依赖注入工具。它由Go Cloud团队开发，通过自动生成代码的方式在编译期完成依赖注入。
依赖注入是保持软件 “低耦合、易维护” 的重要设计准则之一。
此准则被广泛应用在各种开发平台之中，有很多与之相关的优秀工具。
其中最著名的当属 Spring，Spring IOC 作为框架的核心功能对Spring的发展到今天统治地位起了决定性作用。
依赖注入很重要，所以Golang社区中早已有人开发了相关工具， 比如来自Uber 的 dig 、来自Facebook 的 inject 。他们都通过反射机制实现了运行时依赖注入。
二.快速使用 2.1安装 安装很简单，运行 go get github.com/google/wire/cmd/wire 之后， wire 命令行工具 将被安装到 $GOPATH/bin 。只要确保 $GOPATH/bin 在 $PATH 中， wire 命令就可以在任何目录调用了。安装成功后运行如下命令
2.2快速入门 设计一个程序，其中 Event依赖Greeter，Greeter依赖Message
package main import ( "fmt" "github.com/pkg/errors" "time" ) type Message string func NewMessage(phrase string) Message { return Message(phrase) } type Greeter struct { Message Message } func NewGreeter(m Message) Greeter { return Greeter{Message: m} } func (g Greeter) Greet() Message { return g.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c86a74e5957a5c456b1c6844702af5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2d61257730a9113272b7b56c72fc987/" rel="bookmark">
			寄存器、缓存、内存、硬盘、存储器的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/heixiaolong7/article/details/51226378
只要能存储数据的器件都可以称之为存储器，它的含义覆盖了寄存器，缓存，内存，硬盘。cpu访问快慢的速度依次为
寄存器-&gt; 缓存-&gt;内存-&gt;硬盘
寄存器是中央处理器的组成部分，是一种直接整合到cpu中的有限的高速访问速度的存储器，它是有一些与非门组合组成的，分为通用寄存器和特殊寄存器。cpu访问寄存器的速度是最快的。那为什么我们不把数据都存储到寄存器中呢，因为寄存器是一种容量有限的存储器，并且非常小。因此只把一些计算机的指令等一些计算机频繁用到的数据存储在其中，来提高计算机的运行速度。
缓存其实是内存中高速缓存（cache）,它之所以存在，是因为当cpu要频繁访问内存中的一些数据时，如果每次都从内存中去读，花费的时间会更多，因此在寄存器和内存之间有了缓存，把cpu要频繁访问的一些数据存储在缓冲中，这样效率就会更高，但需要注意的是，缓冲的大小也是很小的，不能存放大量的数据，并且缓存中存放的数据会因为cpu的访问而被替代，必须某个数据开始被cpu频繁访问，但后来不再频繁，那这个数据的空间会被其他访问频繁的数据所占据（那些数据会被暂时存储在缓存中是算法问题）。缓存又可以分为一级和二级缓存，一级的速度大一二级的速度。因此cpu在访问数据时，先到缓存中看有没有，没有的话再到内存中读取。
内存分为只读（ROM）和随机存储器（RAM）一级最强悍的高速缓存存储器（cache）。其中RAM应用非常广泛，例如在平常用的开发板中的内存指的就是RAM，还有我们电脑上的内存条指的就是RAM。
硬盘、U盘等存储器都归入外存储器，它们的访问速度是最慢的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfcb1370acf88592e62f995d11cbdd35/" rel="bookmark">
			c&#43;&#43; redis客户端， 带详情输入输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 使用方法输入输出解释代码输出 使用方法 g++ main.cpp
./a.out -h 127.0.0.1 -p 6379
输入 一行内输入 redis 命令
keys*
set name
get name
等等 redis命令
输出解释 输入redis: redis收到的redis协议的数据
human输入： 你输入的原始字符
redis输出： redis返回的基于 redis协议的数据
human输出： 稍微处理过的 redis放回的数据
代码 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;vector&gt; #include &lt;unistd.h&gt; #include &lt;sstream&gt; #include &lt;getopt.h&gt; using namespace std; string ip = "127.0.0.1"; int p = 6379; class TcpCli { public: string ip; int port; int fd; explicit TcpCli(const string&amp; ip = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfcb1370acf88592e62f995d11cbdd35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/088e122d38ce2e3733253f89129a01f2/" rel="bookmark">
			AI创作系统ChatGPT网站源码，AI绘画，支持GPT联网提问/即将支持TSS语音对话功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、AI创作系统 SparkAi创作系统是基于ChatGPT进行开发的Ai智能问答系统和Midjourney绘画系统，支持OpenAI-GPT全模型+国内AI全模型。本期针对源码系统整体测试下来非常完美，可以说SparkAi是目前国内一款的ChatGPT对接OpenAI软件系统。那么如何搭建部署AI创作ChatGPT？小编这里写一个详细图文教程吧！本系统使用Nestjs+Vue+Typescript框架技术，持续集成AI能力到本系统。支持GPT-4-Turbo模型、支持DALL-E3文生图，支持最新GPT-4-Turbo模型、GPT-4-1106-Preview多模态模型。支持GPT-4图片对话能力上传图片并识图理解对话。
《SparkAi系统详情及搭建部署文档》:
https://www.yuque.com/yuqueyonghutq9yt2/egy0d0
新增已支持GPT-4图片对话能力，上传图片并识图理解对话
可同时支持5张图同时上传对话
1.1 AI模型提问 1.2 AI绘画 Midjourney局部重绘（Vary Region）在线编辑功能
1.3 程序核心功能 已支持OpenAI GPT全模型+国内AI全模型+Midjourney绘画池系统！
AI提问：程序已支持GPT3.5，GPT4.0提问、OpenAIGPT全模型+国内AI全模型、支持GPT联网提问
已支持OpenAIGPT全模型+国内AI全模型，已支持国内AI模型 百度文心一言、微软Azure、阿里云通义千问模型、清华智谱AIChatGLM、科大讯飞星火大模型、腾讯混元大模型等！
AI绘画：Midjourney绘画（全自定义调参）、Midjourney以图生图、Dall-E3绘画
支持最新GPT-4多模态模型、OpenAI GPT-4-Turbo-With-Vision-128K模型
支持GPT-4图片对话能力（上传图片并识图理解对话）
新增支持对话插件系统，后续逐步增加插件功能，扩展AI能力
新增KEY支持单独配置消耗费率，比如GPT4-32K比GPT4成本更高应该消耗更多的额度次数
微信公众号+邮箱+手机号注册登录
一键智能思维导图生成
应用广场，支持用户前台自定义添加私密或共享
AI绘画广场（画廊）
邀请+代理分销模式、用户每日签到功能
会话记录同步保存
支持对接微信官方支付、易支付、码支付、虎皮椒支付等
自定义聚合会员套餐、卡密系统
其他核心功能
后续其他免费版本功能更新
1.4 更新日志 SparkAi最近大版本更新日志：
【V3.3.1】更新功能（2023.11.24号更新）
新增支持GPT-4-Turbo-Vision插件
新增已支持GPT-4图片对话能力（上传图片并识图理解对话）可同时支持5张图同时上传对话
OpenAI DALL-E3文生图对话形式及图片大小占比优化，效果与OpenAI PLUS一致
优化合并DALL-E3和GPT-4-Turbo-Vision的计费方式为GPT-4-Turbo，只需配置gpt-4-1106-Preview模型即可
新增MJ绘画系统并发执行数量设置，可后台设置系统并发数量
新增阿里云OSS存储可配置自定义域名，实现用户可以直接预览图片
新增大模型Agent代理多插件调用处理任务并总结返回结果
修复GPT联网提问失效和不稳定问题（后期将开发新的联网功能，可控制联网模块）
优化MJ单次绘画查询的超时时间为4分钟，应对MJ官方慢速绘画太慢可能导致绘画失败的问题
修复绘画存储不走绘画池Discord-CND代理，导致部分时候存储失败问题
新增DALL-E3文生图连续对话可对同一张图提出修改意见，DALL-E3文生图插件的调用时机由大模型理解用户提问动态择机调用。与OpenAI同步，支持gpt-4、gpt-4-1106-preview、gpt-4-0613、gpt-3.5-turbo、gpt-3.5-turbo-1106、gpt-3.5-turbo-0613模型调用。
二、系统模块演示 2.1 快速体验 SparkAi官方演示站：
https://ai.sparkaigf.com
管理后端:
https://ai.sparkaigf.com/sparkai/admin
测试账号：admin、123456
2.2 系统文档 如不能访问请查看《SparkAi系统详情及搭建部署文档》获取最新地址。
三、系统功能模块 3.1 ChatGPT模型提问 支持GPT联网提问提问
3.2 Prompt应用 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/088e122d38ce2e3733253f89129a01f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6dca5c051fe1c3286a8bd154faf6632/" rel="bookmark">
			利用R语言heatmap.2函数进行聚类并画热图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据聚类然后展示聚类热图是生物信息中组学数据分析的常用方法，在R语言中有很多函数可以实现，譬如heatmap,kmeans等，除此外还有一个用得比较多的就是heatmap.2。最近在网上看到一个笔记文章关于《一步一步学heatmap.2函数》，在此与大家分享。由于原作者不详，暂未标记来源，请原作者前来认领哦，O(∩_∩)O哈哈~
数据如下：
library(gplots)data(mtcars)x &lt;- as.matrix(mtcars)rc &lt;- rainbow(nrow(x), start=0, end=.3)cc &lt;- rainbow(ncol(x), start=0, end=.3) X就是一个矩阵，里面是我们需要画热图的数据。
Rc是一个调色板，有32个颜色，渐进的
Cc也是一个调色板，有11个颜色，也是渐进的
首先画一个默认的图：
heatmap.2(x) 然后可以把聚类数可以去掉：就是控制这个dendrogram参数
heatmap.2(x, dendrogram=“none”) 然后我们控制一下聚类树
heatmap.2(x, dendrogram=“row”) # 只显示行向量的聚类情况heatmap.2(x, dendrogram=“col”) #只显示列向量的聚类情况 下面还是在调控聚类树，但是我没看懂跟上面的参数有啥子区别！
heatmap.2(x, keysize=2) ## default - dendrogram plotted and reordering done.heatmap.2(x, Rowv=FALSE, dendrogram=“both”) ## generate warning!heatmap.2(x, Rowv=NULL, dendrogram=“both”) ## generate warning!heatmap.2(x, Colv=FALSE, dendrogram=“both”) ## generate warning! 接下来我们可以调控行列向量的label的字体大小方向
首先我们调控列向量，也就是x轴的label
heatmap.2(x, srtCol=NULL)heatmap.2(x, srtCol=0, adjCol = c(0.5,1) )heatmap.2(x, srtCol=45, adjCol = c(1,1) )heatmap.2(x, srtCol=135, adjCol = c(1,0) )heatmap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6dca5c051fe1c3286a8bd154faf6632/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/587256c6e2c4aca32141c170cae537f0/" rel="bookmark">
			使用InfluxDB 3.0提高性能并降低存储成本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键字: [Amazon Web Services re:Invent 2023, 亚马逊云科技, Working Backwards Process, Customer Centric Approach, Align Go-To-Market Framework, Invent And Define Stages, Listen And Test Stages]
本文字数: 1000, 阅读完需: 5 分钟
视频 如视频不能正常播放，请前往bilibili观看本视频。&gt;&gt; https://www.bilibili.com/video/BV1Ji4y1v71e
导读 您能用查询响应时间在一秒内的实时分析应用程序吗?您能永久保留数据但仍然降低存储费用吗?您能从基础设施中挤出更多性能吗?如果以上全部兼具呢?InfluxDB 3.0是一个时间序列数据平台,能实现所有这些。加入这个闪电式演讲,了解强大的Rust、Apache Arrow和Apache Parquet组合在InfluxDB 3.0列式架构中的魔力,它实现了几乎无限的数据基数,更快的摄入和查询,同时通过使用低成本的对象存储来降低存储成本。本演讲由InfluxData(亚马逊云科技合作伙伴)呈现。
演讲精华 以下是小编为您整理的本次演讲的精华，共700字，阅读时间大约是4分钟。如果您想进一步了解演讲内容或者观看演讲全文，请观看演讲完整视频或者下面的演讲原文。
莉兹·伯顿（Liz Burton）担任亚马逊云科技（Amazon Web Services）全球战略部门的高级合作伙伴营销负责人。在一次共有102位合作伙伴参加的活动上，她运用亚马逊云科技的内部“逆向工作”流程，为合作伙伴们带来了一场关于如何构建市场推广框架的深度演讲。她首先承认，在re:Invent等高级别会议上，合作伙伴们经常向她咨询关于亚马逊的创新方法和市场推广策略的问题。伯顿解释道，她将分享亚马逊以客户为中心的创新产品和服务原则，以及合作伙伴如何通过运用与Alexa、Amazon Echo、Kindle、Prime Video和亚马逊云科技等成功创新相同的“逆向工作”流程来调整自己的市场推广框架。
伯顿表示，尽管亚马逊并不声称他们的创新方法是最好的，但在数千种产品和服务上实践多年的这种方法已经取得了巨大的成功。她概述了演讲的主要内容，包括探讨亚马逊云科技的创新、研究逆向工作文件、协调市场推广框架以及提供更多的资源。伯顿强调，亚马逊云科技的所有业务都遵循他们的使命宣言——成为“地球上最以客户为中心的公司”。这个广泛的使命声明为在不限制领域、地域、市场、行业或技术的情况下进行创新提供了灵活性。评估解决方案的依据是它们对客户的影响，并在会议中频繁引用使命声明。亚马逊独特的领导原则，如以客户为中心和偏好转向行动，也在将客户置于核心地位的基础上指导着公司的各项任务。
伯顿表示，亚马逊云科技的创新源于从客户需求出发的逆向工作方法。他们的终极目标是让客户满意并解决紧迫挑战。逆向工作过程分为五个连续阶段：倾听、定义、发明、优化和测试/迭代。每个阶段都与收集见解和数据的客户问题相关联。例如，倾听阶段关注“客户的身份以及我们对他们的了解”，定义阶段关注“客户所面临问题的背景”。在产品开始开发之前，这些阶段必须完成。著名的亚马逊产品如Alexa、Echo、Kindle和Prime Video等都是通过这种以客户为中心的逆向工作方法开发的。这种方法可适用于任何对客户产生有意义影响的大或小项目。
伯顿指出，逆向工作文档是在开发开始之前编写的，包括新闻稿、常见问题解答和展示端到端客户体验的视觉材料。新闻稿设想了未来的客户体验，而常见问题解答则提供详细信息。例如，Alexa用户可以通过与设备和服务对话来播放音乐、获取新闻和控制智能家居设备。团队会对这些文档进行广泛讨论，第一稿通常会被拆解并重写，以找到最佳解决方案。如果做得好的话，它需要提前工作，但可以避免稍后的更大问题。从营销角度来看，它可以防止创建吸引不了顾客而无法销售的东西。
尽管伯顿承认了过去失败的例子，如耗资1.7亿美元的Fire Phone亏损，但在发明过程中出现失败是可以接受的。将上市与逆向工作相结合增加了敏捷性并降低了风险，而不是做出假设并行动得太快。它提前确定了目标客户、价值主张和讯息。这就像有10万合格潜在客户而非只有1000个原始交易的销售目标。它还符合营销规划。倾听和分析与逆向工作的倾听阶段相匹配。规划与发明阶段相匹配。测试和执行与测试/迭代阶段相匹配。
总的来说，伯顿鼓励在场的一百零二位合作伙伴采用以客户为中心的滞后性工作方式，并为她们提供了如创新团队等亚马逊云科技的资源来帮助她们实施这种方式。她建议通过客户经理或直接联系她的方式来充分利用这些资源。伯顿还推荐了两本关于滞后性和上市策略的书籍，以便进一步学习。最后，她感谢了与会者，并敦促他们提供反馈，以改进未来以客户为中心的创新为主题的亚马逊云科技项目。
下面是一些演讲现场的精彩瞬间：
亚马逊云科技的领导者们分享了一些关于他们与客户合作的创新原则。
始终以客户需求为导向使得公司能够快速灵活地应对市场变化。
在这个过程中，他们会研究各种解决方案来应对客户的挑战，并在实施前评估这些方案的影响。
领导者们会设想如果客户采用了他们所推荐的亚马逊云科技解决方案，他们的业务未来将如何发展。
为了与市场营销规划相协调，他们还会将这些逆向思考的过程展示出来。
领导者们鼓励观众们在自己的组织中采用这种“逆向工作”的方法，并提供了一些调查问卷，以便收集对未来改进的反馈。
此外，他们还鼓励观众们通过电子邮件、LinkedIn或Twitter等渠道寻求协助和支持。
总结 亚马逊云科技专家Liz Burton分享了她对于如何运用亚马逊的以客户为中心的逆向工作法来构建市场策略的见解。根据她的解释，这一方法包含五个关键环节：倾听、定义、发明、优化和迭代。通过在倾听阶段充分了解客户需求，企业能够明确需要解决的核心问题。在发明阶段，团队会进行头脑风暴，探讨各种可能的解决方案；而在优化阶段，焦点将放在设计端到端的客户体验上。最后，在迭代阶段，团队将对解决方案进行测试和改进。
Burton以Alexa和Kindle等热销产品为例，展示了逆向工作法的实际应用。她强调这种方法有助于降低风险并提高企业的灵活性。在企业推出产品或服务之前，逆向工作法可以帮助他们规划面向市场的策略，包括确定目标客户、价值主张和传播信息。
总的来说，Burton提倡企业在深刻理解客户需求、激发创意、优化客户体验以及根据反馈进行调整的基础上，实现成功的创新。采用这种逆向工作法所打造出的产品和服务才能真正让客户满意。
演讲原文 https://blog.csdn.net/just2gooo/article/details/134868200
想了解更多精彩完整内容吗？立即访问re:Invent 官网中文网站！ 2023亚马逊云科技re:Invent全球大会 - 官方网站
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/587256c6e2c4aca32141c170cae537f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c697d2e58dc6e6381d8c910d9c90974/" rel="bookmark">
			【QT】Qt 使用MSVC2017找不到编译器的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址::【QT】Qt 使用MSVC2017找不到编译器的解决办法_qt构建套件中未设置编译器-CSDN博客
一、问题原因：刚安装好的qtcreator ，版本中的MSVC2017是没有设置编译器和调试器的。
二、MSVC2017 64bit套件配置流程：
VS2017下载官网 ：https://my.visualstudio.com/Benefits
或者点击这个：一步到位
下载好后，在本地双击打开
选择 Visual Studio 2017 以及 VC++ 2017 version 15.9 v14.16 latest v141 tools
点击继续
等待安装
点击以后再说
再次打开 Qt ，发现有 MSVC2017 的编译器了，如下：
三、调试器（Debugger）选择使用Windows SDK程序自动生成的调试器：
Windows SDK官网链接：https://developer.microsoft.com/zh-cn/windows/downloads/windows-sdk/
选择安装路径
双击winsdksetup
默认选择，点击下一步
Yes，点击下一步
点击接受
点击安装
等待安装
安装成功
再次打开Qt，发现调试器已经添加上了
选择Qt Versions，发现红色感叹号已经消失了
配置构建套件Kit 后，Desktop Qt 5.12.2 MSVC2017 64bit 是黄色的警告，不影响，如下：
————————————————
版权声明：本文为CSDN博主「Cappuccino-jay」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Cappuccino_jay/article/details/125550242
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de6cd2258861400d16e2da9d80d7f51a/" rel="bookmark">
			YOLOv6 学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、YOLOv6贡献和改进二、YOLOv6核心概念三、YOLOv6架构改进四、YOLOv6重参思想五、YOLOv6的损失函数总结 前言 在计算机视觉领域，目标检测技术一直是研究的热点和挑战，尤其是在实时应用中。YOLO（You Only Look Once）系列作为其中的佼佼者，一直以其快速和高效的检测性能受到广泛关注。本文旨在深入探讨YOLOv6的主要贡献、核心概念、架构改进、重参数化思想以及损失函数设计，以全面了解这一先进的单阶段目标检测框架。
一、YOLOv6贡献和改进 YOLOv6的主要贡献和改进可以总结如下：
技术创新与优化:
网络设计：YOLOv6提出了两种可重参数化的backbones和necks，以适应不同大小的模型，并引入了一种高效的解耦头部设计，采用混合通道策略。这种设计有助于提高硬件友好性和模型的灵活性。标签分配策略：引入了Task Alignment Learning（TAL）作为默认的标签分配策略，相比于之前的SimOTA，TAL提供了更稳定的训练和更高的准确性。损失函数：对分类和回归损失函数进行了详细的探索和优化，最终选择了VFL作为分类损失函数，以及对于不同模型尺寸，选择了最优的IoU系列损失函数。 性能提升:
YOLOv6在保持高精度的同时，显著提高了检测速度。例如，YOLOv6-N在COCO数据集上达到了35.9%的AP，同时拥有1234 FPS的处理速度，这在同类模型中是非常出色的表现。 针对实际部署的优化:
量化和部署：为了加速模型运行时间并减少性能损失，YOLOv6采用了先进的量化方法，包括后训练量化（PTQ）和量化感知训练（QAT）。此外，还采用了针对重参数化优化的RepOptimizer，以及灵活处理图像边缘的灰色边框策略，这些都有助于提高模型的部署效率。 实用的工业改进:
更长的训练周期和自我蒸馏技术的应用，进一步提高了模型的准确性，而不会引入太多的额外计算成本。 二、YOLOv6核心概念 YOLOv6的核心概念包括以下几个方面：
网络结构（Network Design）:
YOLOv6的网络结构由三部分组成：背景（Backbone）、颈部（Neck）和头部（Head）。背景（Backbone）：负责提取特征，对模型的特征表示能力和推理效率至关重要。颈部（Neck）：用于聚合低层物理特征和高层语义特征，构建多层次的特征图。头部（Head）：包含多个卷积层，根据颈部汇集的多级特征预测最终的检测结果。 标签分配（Label Assignment）:
标签分配是训练阶段中为预定义锚点（anchors）分配标签的过程。YOLOv6采用Task Alignment Learning（TAL）作为标签分配策略，提高了训练稳定性和准确性。 损失函数（Loss Functions）:
在YOLOv6中，损失函数包括分类损失、框回归损失和可选的目标损失。损失函数的选择对于模型的性能有重要影响。 量化和部署（Quantization and Deployment）:
量化是将模型参数从浮点数转换为低精度（如整数）表示的过程，旨在加速模型的推理速度并减少内存占用。YOLOv6采用了高级的量化方法来实现这一点。 自我蒸馏（Self-distillation）:
自我蒸馏是一种通过教师模型（在YOLOv6中是模型自身的预训练版本）来提高学生模型（同一模型的后续版本）性能的技术。 工业级部署（Industrial Deployment）:
YOLOv6特别关注于工业级应用，因此在设计和优化时考虑到了在实际部署环境（如低功耗GPU）中的性能需求。 三、YOLOv6架构改进 YOLOv6的架构改进主要体现在以下几个方面：
优化的网络结构:
背景（Backbone）: YOLOv6引入了可重参数化的背景，这意味着更有效地在不同大小的模型之间扩展网络结构。这种设计有助于提高网络的特征提取能力和推理效率。颈部（Neck）: YOLOv6采用了修改后的PAN（Path Aggregation Network）拓扑作为检测颈部的基础，并对其进行了改进，以更好地集成不同尺度的特征。 高效的头部设计（Efficient Head）:
YOLOv6采用了一种高效的解耦头部设计，该设计采用混合通道策略，以优化参数使用和提高检测性能。 标签分配策略:
YOLOv6中采用了Task Alignment Learning（TAL）作为标签分配策略，相比于以往的策略如SimOTA，TAL提供了更稳定的训练和更高的准确性。 损失函数的优化选择:
在损失函数的选择上，YOLOv6进行了深入的实验和分析，最终选择了最适合自身架构的分类损失和回归损失函数。 量化和部署策略的改进:
为了更好地适应工业级部署，YOLOv6在量化和部署方面进行了创新，包括使用后训练量化（PTQ）和量化感知训练（QAT）方法来优化模型的推理速度和效率。 针对工业应用的实用改进:
包括更长的训练周期、自我蒸馏技术以及对图像处理策略的调整（如图像边缘的灰色边框处理），这些都是针对实际应用环境的优化。 四、YOLOv6重参思想 YOLOv6中的重参（Reparameterization）思想是一个关键创新点，其主要目的是提高模型的灵活性和效率。这一思想体现在以下方面：
可重参数化的背景（Backbone）:
在YOLOv6中，背景被设计为可重参数化的结构。这意味着模型的某些部分可以在不改变其功能的情况下，以不同的方式重构。这种设计使得模型在保持其原有功能的同时，可以根据不同的应用需求和硬件条件进行优化。 优化的量化过程:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de6cd2258861400d16e2da9d80d7f51a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e38dfa5701cc9e2b7ed147993b2b7e6c/" rel="bookmark">
			【读点论文】A review of convolutional neural network architectures and their optimizations
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A review of convolutional neural network architectures and their optimizations Abstract 本文详细分析和阐述了卷积神经网络（CNN）的典型架构及其优化的研究进展。本文提出了一种基于模块对 CNN 架构进行分类的典型方法，以适应更多具有多种特征的新网络架构，这些架构很难依赖于原始的分类方法。通过对各种网络架构的优缺点分析及其性能比较，对六种典型的 CNN 架构进行了详细的分析和解释。还探讨了 CNN 架构的内在特征。而且，本文根据各种优化算法的数学原理，对网络压缩和加速网络架构优化算法进行了全面的分类。最后，本文分析了 NAS 算法的策略，讨论了 CNN 的应用，并揭示了当前 CNN 架构及其优化的挑战和前景。解释了优化不同网络架构类型所带来的优势，为在具体设计和应用中建设性地选择合适的 CNN 提供了基础。本文将帮助读者在具体设计和应用中建设性地选择合适的 CNN。基于模块的分类方法：这种分类方法通过将网络架构划分为不同模块，并分析各个模块的功能和交互方式，从而能够更好地理解不同网络架构的特性。不同分类方法的优缺点及适用范围：分类方法的选择取决于具体的应用需求和数据集特性。网络压缩算法：通过减少模型参数的数量或降低参数的精度来减小模型大小，提高计算效率。常见的算法有量化、剪枝和知识蒸馏等。加速网络架构优化算法：通过改进训练过程或使用特定硬件来提高模型训练速度。常见的算法有分布式训练、硬件加速和混合精度训练等。网络压缩和加速优化算法的优缺点及适用范围：需要根据具体应用需求选择合适的算法，并权衡压缩和加速带来的影响。NAS算法介绍：通过自动化方式搜索和优化神经网络结构，以获得更好的性能。常见的算法包括基于搜索空间的NAS算法和基于神经网络的NAS算法等。NAS算法的应用范围及挑战：在具体应用中需要考虑搜索空间的大小、搜索时间和模型性能之间的关系以及如何评估和比较不同结构的模型等问题。 Introduction 机器学习（ML）最早于 1952 年加拿大达特茅斯会议上提出，是计算机科学中应用极为广泛的跨学科前沿分支。经过60多年的发展，机器学习已经衍生出深度学习、计算机视觉、语音识别等众多子领域。
深度学习被认为是机器学习中的一个新颖的研究领域，其概念发表在 Hinton 和 Salakhutdinov (2006) 的研讨会论文中。论文提出了一种基于深度置信网络（DBN）的高效无监督贪婪逐层训练算法。随后，包括神经网络（NN）在内的大量深度学习网络开始引起广泛关注。典型的深度学习模型包括DBN、堆叠式自动编码器网络和卷积神经网络（CNN）等。理论研究表明，当更深层次网络架构所代表的功能通过浅层网络架构来表达时，其计算单元呈指数级增长（Håstad和戈德曼 1991）。这种函数表达的潜力充分表明了深度学习网络的广阔前景。
因此，针对计算机视觉任务的需求，出现了一种特殊类型的神经网络架构，即CNN。 CNN 被认为是学习图像内容的最佳技术之一，在图像识别、图像分割、目标检测等相关领域取得了显着的效率。该网络最初受到视觉系统神经机制的启发，其架构受到 Hubel 和 Wiesel 于 1962 年在猫视觉皮层细胞上进行的神经生物学实验的启发。
1989 年，LeCun 等人。基于其前身 Neocognitron 提出了第一个名为 ConvNet 的多层 CNN。它定义了CNN最基本的框架，即卷积层、池化层和全连接（FC）层，成功解决了手写数字和邮政编码识别的相关问题。后来在 1998 年，LeCun 等人通过将卷积层与下采样层相结合，改进了 ConvNet 的架构，并将其命名为 LeNet-5，这就是现代 CNN 的雏形。
然而，从 20 世纪 90 年代末到 2000 年代初，由于计算机性能的限制，人们对深度学习兴趣不大。特别是，尽管仍然有研究人员优化 CNN 架构，但支持向量机 (SVM) 受到的关注远多于 CNN。 Simard 等人于 2003 年修改了 CNN 架构，该架构在手写基准混合国家标准与技术研究所 (MNIST) 数据库上表现出比 SVM 更好的效率。 2010年，李在斯坦福大学的团队构建了一个名为ImageNet的大型图像数据库，其中包含数百万张标记图像。基于该数据库，每年举办一次ImageNet大规模视觉识别挑战赛（ILSVRC），对各种模型进行性能评估和评分。在经历了10多年的停滞之后，AlexNet崛起并赢得了2012年-ILSVRC冠军，这标志着CNN性能的重大转折。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e38dfa5701cc9e2b7ed147993b2b7e6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a9076dd621d20f9ce52936c6e77a39e/" rel="bookmark">
			Python 将模糊图像清晰化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV 将模糊图像清晰化 在 Python 中要将一个模糊图像清晰化可以使用第三方库OpenCV来实现，使用OpenCV前需确保其已经安装，如果未安装，可通过如下命令安装：
pip install opencv-python 如下是使用OpenCV将模糊图像清晰化的具体步骤：
使用 3 行 3 列的卷积核将模糊图片进行均值模糊操作。对模糊图片进行高斯模糊操作，让模糊图片中临近的像素点具有更高的权重。对模糊图片进行归一化方框滤波操作。对模糊图片进行双边滤波操作，以便保留空间信息和灰度差异信息。使用 1 行 3 列的卷积核将模糊图片进行高斯模糊操作，以便去除高斯噪声。展示清晰化后的图片。 如下是代码示例:
import cv2 def blur_demo(image_file): # 读取图像 image = cv2.imread(image_file) # 均值模糊 cv2.blur(image, (3, 3)) # 高斯模糊 cv2.GaussianBlur(image, (5, 5), 15) # 方框滤波 cv2.boxFilter(image, -1, (5, 5), normalize=1) # 双边滤波 cv2.bilateralFilter(image, 25, 50, 25 / 2) # 中值模糊 dst = cv2.medianBlur(image, 5) cv2.imshow("clear_image", dst) cv2.waitKey(0) cv2.destroyAllWindows() image_file= "mohu.jpg" # 调用模糊化函数 blur_demo(image_file) 上述代码通过blur_demo实现模糊图片清晰化的操作，函数接受一个模糊图像的路径image_file作为参数，在函数内部通过对模糊图像进行均值模糊、高斯模糊、方框滤波、双边滤波、中值模糊等操作实现模糊图像的清晰化，执行代码时你需要将测试图像路径提花那位你自己的图像路径。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a9076dd621d20f9ce52936c6e77a39e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/728da3ff14981ea335f16d1760b1d262/" rel="bookmark">
			文心ERNIE Bot SDK&#43;LangChain：基于文档、网页的个性化问答系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在各行各业纷纷选择接入大模型，其中最火且可行性最高的形式无异于智能文档问答助手，而LangChain是其中主流技术实现工具，能够轻松让大语言模型与外部数据相结合，从而构建智能问答系统。ERNIE Bot SDK已接入文心大模型4.0能力，同时支持对话补全、函数调用、语义向量等功能。
本教程是基于文心一言ERNIE Bot SDK与LangChain构建基于Embedding Vector方式的文本问答系统，整体可以解构为三部分。
1、基于ERNIE Bot与LangChain结合的Embedding，获取向量矩阵并保存
2、基于用户问题，在向量矩阵库中搜寻相近的原文句子
3、基于检索到的原文与Prompt结合，从LLM获取答案
背景介绍
问答系统处理流程
加载文件 -&gt; 读取文本 -&gt; 文本分割 -&gt; 文本向量化 -&gt; 问句向量化 -&gt; 在文本向量中匹配出与问句向量最相似的top_k个 -&gt; 匹配出的文本作为上下文和问题一起添加到Prompt中 -&gt; 提交给LLM生成回答
技术工具
ERNIE Bot SDK
ERNIE Bot SDK 提供便捷易用的接口，可以调用文心大模型的能力，包含文本创作、通用对话、语义向量、AI作图等。
LangChain
LangChain 是一个强大的框架，旨在帮助开发人员使用语言模型构建端到端的应用程序。它提供了一套工具、组件和接口，可简化创建由大型语言模型 (LLM) 和聊天模型提供支持的应用程序的过程。LangChain 可以轻松管理与语言模型的交互，将多个组件链接在一起，并集成额外的资源，例如API和数据库。
项目代码
环境准备
安装相关库
!pip install -qr requirements.txt 读取 access_token
在星河社区的控制台访问令牌中找到自己的access_token，替换access_token.txt或下面代码中的access_token。
fileName='access_token.txt' access_token='' if len(access_token)==0: with open(fileName,'r') as f: #逐行读取文件内容 lines = f.readlines() for line in lines: if line[:13]=='access_token=': access_token=line[13:] assert len(access_token)&gt;10 print('access_token:',access_token) LangChain及Embedding部分
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/728da3ff14981ea335f16d1760b1d262/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab1dddae23895c07ca8d3bacb724d08d/" rel="bookmark">
			Docker-compose容器编排与容器监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Docker-compose 1、概念： Docker-Compose 是 Docker 官方的开源项目，负责实现对Docker容器集群的快速编排。
2、作用： Docker-Compose可以管理多个Docker容器组成一个应用。需要定义一个yaml格式的配置文件 docker-compose.yml，配置好多个容器之间的调用关系，然后只需要一个命令就能同时启动/关闭这些容器。
3、compose核心概念： ① 一文件：docker-compose.yml
② 两要素：
项目 (project)：由一组关联的容器组成的一个完整业务单元；
服务 (service)：一个项目中的某一个容器实例 。
4、compose 使用步骤： ① 编写 Dockerfile 定义各个应用容器，构建出对应的镜像文件；
② 使用 docker-compose.yml，定义一个完整的业务单元，安排好整体应用中的各个容器服务；
③ 执行 docker-compose up 命令，创建并运行整个应用程序，完成一键部署上线。
5、compose示例： compose模版：https://docker_practice.gitee.io/compose/compose_file.html
(1) 创建一个项目： mkdir /root/ems/ （以ems目录作为项目名）
(2) 在ems目录里创建一个docker-compose.yml文件： ① version：
每个模版文件需要写上version版本号，代表所使用的docker-compose的项目版本。
● 版本号的选择与docker引擎有关：
官方提供的compose版本号与docker引擎的对应关系：
② services：
在模版文件里定义需要启动的容器：
● 启动 tomcat：
若要启动另一个tomcat，则要再写一组服务：
● 启动 redis：
● 启动 mysql：
(3) 启动docker-compose服务： docker compose up
这个命令必须在docker-compose.yml配置文件目录下执行
● 查看服务：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab1dddae23895c07ca8d3bacb724d08d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f1d8b22869a39f29478fdd9745b30e9/" rel="bookmark">
			飞机机翼数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Airfoil Tools
螺旋桨数据
飞机气动分析
NACA
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d57184b8b72d4304ea69503722a4ed3f/" rel="bookmark">
			【Git】本地代码如何托管到远程仓库（保姆级教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意前提是你本地已经安装了Git
1. 新建远程仓库 选一个git服务器，新建一个远程仓库，这里我选用的是gitee
点击确定后，显示如下界面表示仓库已经新建完成
2.建立本地仓库 本地新建一个空文件夹，在里面写一些你的初始代码文件。
然后右键打开git bash命令窗口
接下来输入命令：git init，初始化创建本地仓库就完成啦
3. 关联远程仓库 命令 git remote add origin 远程仓库地址
4.提交到远程仓库托管 三行命令：
git add . — 暂存所有文件git commit -m 'init' — 提交到本地git仓库git push origin master — 推送到远程仓库的master分支 完成后，打开远程仓库，就可以看到已经提交的代码了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4410932a921f4d595aecf7c1a4c4d004/" rel="bookmark">
			嵌入式工程师校招经验与学习路线总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：不知不觉2023年秋招已经结束，作者本人侥幸于秋招中斩获数十份大差不差的OFFER，包含：Top级的AIGC，工控龙头，国产MCU原厂，医疗器械，新能源车企等。总而言之，秋招总体情况本人还是非常满意的，当然薪资方面可能稍微欠缺了点。考虑到经济下行，各行各业普遍降薪裁员的特殊情况，作者本人也能理解！应群内粉丝要求，写一篇帖子总结一下秋招以及学习路线规划！
一、嵌入式工程师校招经验 1.1 作者有话 【免责申明】作者本人目前也只是一名学生，可能这种概括性和指导性的博客帖子会存在很大的主观性因素！希望各位读者朋友辩证的看待此博客！
实话实说，嵌入式工程师目前就业压力是非常大的，各大培训机构疯狂鼓吹嵌入式行业的火爆，导致大量人员涌入嵌入式这个行业，使得该行业迅速趋于饱和内卷状态！以前嵌入式工程师的学历门槛是非常低的，在作者的角度看来是非常不吃学历的。可是现在稍微好点的公司，嵌入式工程师都要很好的学历和学校（985，211，QS100等）。
行业技术的深度与广度也在不断增加，依稀记得还是本科生的时候，会玩51单片机接触过STM32就可以找到不错的工作了。现在，秋招你这种情况完全不够打的！所以想在秋招中脱颖而出就只能去内卷自己的技术与经历！
1.2 秋招简历 简历作为就业机会的敲门砖是非常重要的，一份优秀的简历需要不断地去优化（数十遍优化）。作者在秋招过程中一共优化了 16 遍简历，更是为了心仪公司定制了几份简历！花费大量时间去制作适合自己的简历是非常重要且值得的！
推荐简历组成：（1）个人信息（2）教育背景（3）专业技能（4）项目经历（5）证书与荣誉
1.2.1 个人信息 个人信息这点其实最主要的就是留下你的个人联系方式这点是很重要的，其次，个人建议把你的出生地给删除， 很多HR特别在意出生地是否匹配，不匹配的可能直接pass掉！！！个人信息，作者的设计出发点是越简单越好，尤其私企而言，提供年龄和联系方式就OK了！！！
1.2.2 教育背景 教育背景也就是学历门槛，在校期间绩点优异的，可以把自己绩点排名也写上去！！！
1.2.3 专业技能 专业技能是HR和面试官快速识别你与该工作是否匹配的点，也是你工作时候大概率需要使用的技能。这一点可以去各大招聘APP去看看岗位需求，结合自己实际情况填写！
【BOSS直聘】上的著名公司的招聘技能要求，读者朋友平时学习技能的时候也可以专门面向企业学习。看看招聘需求是什么，你就学什么，这样操作下来基本就不会毕业就失业！当然，好公司除了基础的技能门槛，学历和人生经历也是很重要的考核点！！！
【专业技能例程】
1.2.4 项目经历 嵌入式工程师作为偏硬件行业的岗位是非常吃项目经验的，很多公司现在都希望应届生一入职就可以上手工作，所以项目经验就显得非常重要了！作者个人建议是【以赛代练】，通过电赛去获得项目经验是学生阶段性价比最高的方案。当然如果因为种种因素导致无法参加比赛，可以尝试自己去网上复现一些嵌入式项目作为项目经历也是可以的！
项目经历模板
1.2.5 证书与荣誉 证书与荣誉一般是简历上HR比较关注的点，尤其是含金量高的比赛，比如：ACM，CCF，华为杯，数模国赛美赛，本科电赛等！
以上为学习生涯部分电赛与数模比赛奖项（防止不良人员盗用故打上水印），其中，有水赛也有个人感觉含金量还行的比赛！
全国大学生英语4，6级（雅思托福），全国计算机等级考试（语言类2级，嵌入式系统设计3级，嵌入式工程师4级），计算机软考等都是简历中可以写得！证书永远都是韩信点兵，多多益善得东西！
1.3 秋招面试技巧 1.3.1 自我介绍 1.3.2 技术面八股文 这里直接推荐作者的面经：http://t.csdnimg.cn/Hym4F
1.3.3 HR综合面 HR综合面不确定因素太多了，这个东西更看个人素养和临时决策，这里就不细说了！
二、学习路线规划 2.1 基础学习 【初级阶段】专业知识： 数电，模电，C语言，电路；学习各类传感器，完成小demo编程；
【中级阶段】以常见的STM32为例，学习各类通信协议与外设；选择一款RTOS学习，例如：FreeRTOS，UCOS-II，RT-Thread；
【高级阶段】学习Linux驱动与Linux应用，学习Qt，学习深度学习部署与轻量化；
2.2 高级进阶 上述基础学习是常规的嵌入式工程师的路线。其实，嵌入式工程师还有很多分支，比如：电控工程师，嵌入式AI工程师，物联网工程师（IOT），Android工程师等；
三、博客终语 3.1 粉丝群 嵌入式技术交流群（1）：958820627（可能已满）；嵌入式技术交流群（2）：876919359 ；欢迎加群，有问题可以群内分享技术交流（看到且会基本都会回答），秋招和春招会有诸多大厂内推码或者内推名额推荐。希望大家友好讨论技术知识！！！ 3.2 感慨 岂不闻，光阴如骏马加鞭，日月如落花流水，曾经的孔乙己终需褪下长衫！转眼间，作者投身于嵌入式已经6年了，6年时间收获了很多，也失去了很多，青春就此错过！希望后来者可以持之以恒地奋斗在嵌入式与开源的第一线，后生可畏矣！春风若有怜花意，可否许我再少年！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d259a3d03d4691c5aa53bae08d5afe6/" rel="bookmark">
			git学习笔记02（小滴课堂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		window
安装教程：https://www.yuque.com/u1106272/cai80g/skawco
查看：
创建文件夹：
我们把这个文件夹当作我们的暂存区。
这样就进入了工作区。
初始化：
可以看到.git文件夹。
查看本地仓库状态：
我们进入这个idea项目目录。
提交代码到暂存区：
我们去提交：
再查看状态：
已经提交了，所以是干净的暂存区。
再去修改：
我们再查看状态：
再执行add命令：
提交到暂存区会变成绿色。
提交：
查看修改作者：
将新增的代码添加暂存区
也可以选择只提交部分文件，而不是全部文件：
git add +文件名称。
但是在我们的文件夹里还是存在这个文件的。
将新增的代码提交本地仓库
版本历史回滚
如果最后提交的代码有问题，我们想回到前面的版本应该怎么做呢？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b704c91b1efe6f6d86706271bd6791a7/" rel="bookmark">
			用户案例｜Milvus 助力 Credal.AI 实现 GenAI 安全与可控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AIGC 时代，企业流程中是否整合人工智能（AI）对于的企业竞争力至关重要。然而，随着 AI 不断发展演进，企业也在此过程中面临数据安全管理、访问权限、数据隐私等方面的挑战。
为了更好地解决上述问题，Credal.AI（以下简称 “Credal”） 提供的解决方案使组织能够在释放生成式人工智能（GenAI）潜力的同时降低其风险。Credal 解决方案的核心向量数据库 Milvus，在 Milvus 的加持下，Credal 能够更好地实现其企业愿景——【打造安全且实用的 AI】 。
01.Credal：GenAI 与企业数据安全间的桥梁 Credal 的目标是使企业能安全且方便地使用 GenAI。为此，Credal 提供了强大的数据集成和治理功能，能从 Microsoft Office、Google Workspace 以及 Slack 等多种平台中拉取数据。他们推出了类似于“Okta 的 AI 版本”，从而严格管理访问和权限，以便为开发者和终端用户提供一个流畅且安全的接口。因此，Credal 成为一个端到端的解决方案，支持安全、企业级的 GenAI 部署。
从用户的角度来看，他们无需精通编码或复杂的算法便可利用大量数据，发挥 GenAI 的力量。用户能够使用 Credal 创建代理，确保能够最大化利用 GenAI 技术。
对于管理员和 IT 团队，Credal 提供了监控数据和管理工具，包括强制根据使用条款实施、审计跟踪、日志记录、数据目录和数据治理等功能。这些功能都是在大型企业中高效部署 GenAI 的关键部分。用户可以通过 Credal 的聊天界面或 API 使用诸多重要功能，如 PII 删除、审计日志、数据访问控制等。
02.Credal 痛点：缺乏生产就绪的向量数据库 在 Credal AI 产品开发的初期阶段，公司遭遇了多个挑战。其中一个核心功能是语义搜索，但发现使用基本的向量搜索插件在大规模实现这个功能颇为困难。当语义搜索被嵌入到需要高数据库性能的定制工作流中时，这些挑战变得更为严重。为了构造这些由 GenAI 驱动的工作流，需要对传统的搜索机制进行改进，因为这些工作流需要根据复杂、用户定义的标准实时处理大量数据集。
另外，由于拥有多种托管环境，包括云基础设施和现场部署，Credal 需要有一个可以自我托管，且得到活跃开源社区支持的向量数据库，一个快速、可扩展且多功能的数据库，以应对复杂的数据管道和多种托管条件的需求。而在进行技术选型的过程中，Credal 发现市面上有许多向量数据库解决方案，但都无法满足其企业级的需求。
03.选择 Milvus：以开发者为核心的全能向量数据库 经过对众多市面上主流的向量数据库的评估，评估指标包括：是否支持自托管、可扩展性、是否拥有庞大的社区。
Milvus 在评估中脱颖而出。Milvus 在 GitHub 上获星超过 24 K，拥有高度活跃的社区，且处于不断迭代的过程中，高频推出新功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b704c91b1efe6f6d86706271bd6791a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d93cd112dc71904ac0ff7068295e44e/" rel="bookmark">
			【Excel如何快速合并相同项？】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先点击数据工具栏，在下方功能区找到“向下排序”的图标，如下图所示，点击该图标，在弹出的排序提醒框中，选择“扩展选定区域”执行排序。
点击排序后，系统自动执行降序排序，效果如下图所示：
此时所有相同项都排序在一起，这时我们就可以通过分类汇总来进行同类项的合并了。
如下图所示，点击数据工具栏，在下方功能区找到“分类汇总”功能并点击，会弹出一个提示窗口，可以直接点击确定按钮。
此时进入分类汇总设置框，由于之前选择了D列来执行分类汇总，则系统会自动选定该列作为汇总列，所以可以直接点击下方确定按钮。
随后我们回到表格中，可见执行分类汇总后的数据表发生了一些变化，它在每组相同项下方插入了汇总行，同时也生成了一个包含众多空单元格的计数字段列，如下图所示：
接下来我们选定D列，并按住Ctrl键点击D列的首个单元格，也就是D1单元格，系统会取消该单元格的选定。
此时我们再按下Ctrl+G快捷键组合，呼出定位条件设置框，并选择其中“空值”选项！
定位空值的目的是将D列中所有空单元格选定，以便后续将这些连续的空单元格进行合并操作。
如下图所示，直接点击开始工具栏下方“合并后居中”功能。
这个操作会将刚才选定的空单元格中，每组相连区域进行合并，成为一个合并单元格。
随后我们选择合并空单元格后的D列，并点击开始工具栏下方“格式刷”功能。
这一步会将D列的格式进行复制，我们再粘贴到E列上，E列数据便会调整为D列格式。
如下图所示：
到这一步，基本达成了相同项的合并效果，但数据表还包含了D列字段列和各组行业的汇总行，接下来就是删除这些不需要的数据。
操作很简单，再次点击分类汇总，在弹出的设置框中，点击下方“全部删除”的选项。
系统会自动删除之前创建时生成的字段列和汇总行，得到的效果图如下所示，此时数据表中还有一个空值列D列，我们手动删除即可！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f1ce238dee8576022a7a13be307b0da/" rel="bookmark">
			NLP自然语言处理学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：NLP（自然语言处理）介绍 - 知乎 (zhihu.com)
一、NLP是什么
自然语言处理( Natural Language Processing, NLP)是计算机科学领域与人工智能领域中的一个重要方向。它研究能实现人与计算机之间用自然语言进行有效通信的各种理论和方法。自然语言处理是一门融语言学、计算机科学、数学于一体的科学。因此，这一领域的研究将涉及自然语言，即人们日常使用的语言，所以它与语言学的研究有着密切的联系，但又有重要的区别。自然语言处理并不是一般地研究自然语言，而在于研制能有效地实现自然语言通信的计算机系统，特别是其中的软件系统。因而它是计算机科学的一部分。
自然语言处理，即实现人机间自然语言通信，或实现自然语言理解和自然语言生成是十分困难的。造成困难的根本原因是自然语言文本和对话的各个层次上广泛存在的各种各样的歧义性或多义性（ambiguity）。
自然语言的形式（字符串）与其意义之间是一种多对多的关系。但从计算机处理的角度看，我们必须消除歧义，而且有人认为它正是自然语言理解中的中心问题，即要把带有潜在歧义的自然语言输入转换成某种无歧义的计算机内部表示。
目前存在的问题有两个方面：一方面，迄今为止的语法都限于分析一个孤立的句子，上下文关系和谈话环境对本句的约束和影响还缺乏系统的研究，因此分析歧义、词语省略、代词所指、同一句话在不同场合或由不同的人说出来所具有的不同含义等问题，尚无明确规律可循，需要加强语用学的研究才能逐步解决。另一方面，人理解一个句子不是单凭语法，还运用了大量的有关知识，包括生活知识和专门知识，这些知识无法全部贮存在计算机里。因此一个书面理解系统只能建立在有限的词汇、句型和特定的主题范围内；计算机的贮存量和运转速度大大提高之后，才有可能适当扩大范围.
二、NLP类别
1、文本挖掘：主要包含了文本的分类、聚类、信息抽取、摘要、情感分析以及对挖掘的信息和知识的可视化、交互式的呈现界面，这些统称为文本挖掘任务。
2、信息检索：对大规模文档进行索引。可简单对文档中的词汇，赋予不同的权重来建立索引，也可以使用算法来建立更深层的索引。查询时，首先对输入进行分析，然后在索引里面查找匹配的候选文档，再根据一个排序机制把候选文档排序，最后输出排序得分最高的文档。
3、句法语义分析：针对目标句子，进行各种句法分析，如分词、词性标记、命名实体识别及句法分析、语义角色识别和多义词消歧等。
4、机器翻译：随着通信技术与互联网技术的飞速发展、信息的急剧增加以及国际联系愈加紧密，让世界上所有人都能跨越语言障碍获取信息的挑战已经超出了人类翻译的能力范围。
5、问答系统：随着互联网的快速发展，网络信息量不断增加，人们需要获取更加精确的信息。传统的搜索引擎技术已经不能满足人们越来越高的需求，而自动问答技术成为了解决这一问题的有效手段。
自动问答是指利用计算机自动回答用户所提出的问题以满足用户知识需求的任务，在回答用户问题时，首先要正确理解用户所提出的问题，抽取其中关键的信息，在已有的语料库或者知识库中进行检索、匹配，将获取的答案反馈给用户。
6、对话系统：系统通过多回合对话，跟用户进行聊天、回答、完成某项任务，主要涉及用户意图识别、通用聊天引擎、问答引擎、对话管理系统等技术。此外，为了提现上下文相关，要具备多轮对话能力。同时，为了提现个性化，对话系统还需要基于用户画像做个性化回复。
总的来看，自然语言处理有2大核心任务，自然语言理解（NLU）和自然语言生成（NLG）。
语言的鲁棒性都是导致自然语言理解的主要难点，其中包括：语言的多样性、歧义性、知识依赖、上下文关系等。这些难点也将会带来实际处理时的一系列困难：生成语句的语法结构、语义表达是否准确，信息是否重复等。
鲁棒性（Robustness）是一个广泛应用于计算机科学、控制理论、统计学和工程学等领域的概念，用来描述一个系统或算法在面对各种变化、异常情况、错误输入或干扰时的稳定性、可靠性和适应性。简而言之，鲁棒性是指系统的健壮程度。
在不同的上下文中，鲁棒性有不同的含义：
在软件工程中，鲁棒性指软件能够处理错误数据、不正确使用或者恶意攻击的能力。例如，一个具有鲁棒性的Web服务器应该能够在遭受拒绝服务攻击时保持运行，而不是崩溃。在控制系统设计中，鲁棒性意味着控制器能在参数变化、模型不确定性或外部扰动下保持性能稳定。在优化领域，鲁棒优化关注的是找到对问题参数变化有抵抗力的解决方案。在机器学习和人工智能中，鲁棒性是指模型在遇到训练集中未出现的数据分布变化时仍然能保持准确预测的能力。 实现鲁棒性的方法包括但不限于：
异常检测和处理：通过监测系统状态来识别异常，并采取相应的恢复措施。系统冗余：通过复制关键组件或增加备用路径来提高系统的可靠性。输入验证：确保所有输入都在预期范围内，以防止意外情况。自适应算法：根据环境的变化动态调整系统行为。鲁棒优化技术：寻找对模型参数或数据扰动具有稳健性的最优解。 总的来说，鲁棒性是评估系统质量和安全的重要指标，特别是在复杂、不确定或不断变化的环境中。
为了解决上述问题，一些基本的自然语言处理方向便应运而生，包括：分词、词性标注、词形还原、依赖关系解析、命名实体识别、序列标注、句子关系识别等。
除此之外，自然语言处理还包括了很多具体应用，例如：信息检索、信息抽取、文本分类与聚类、机器翻译、摘要生成、聊天机器人等等。它涉及与语言处理相关的数据挖掘、机器学习、语言学研究，以及近年来非常流行的深度学习等。
参考：什么是自然语言处理？看这篇文章就够了！ - 知乎 (zhihu.com)
熵（entropy）是热力学中的一个核心概念，它表征了一个系统中无序或混乱的程度。在物理学中，它是描述物质状态的参量之一，用符号S表示。克劳修斯（Rudolf Clausius）于1865年提出了熵的概念。
熵的基本性质和意义：
熵是一个状态函数，这意味着它只取决于系统的当前状态，而不依赖于达到该状态的过程。在封闭系统中，根据热力学第二定律，自发过程总是导致整个系统的熵增加。当两个热力学系统处于热平衡时，它们具有相同的温度，并且当它们互相接触时不会发生热量交换。这种情况下，可以定义一个共同的熵值。克劳修斯提出了著名的熵增原理，即在一个孤立系统中，自然发生的任何过程都使系统的总熵增大，直到达到最大熵状态，这时系统达到最稳定的热力学平衡状态。系统的熵可以通过其微观状态的统计来计算，这就是统计力学的基础。玻尔兹曼（Ludwig Boltzmann）提出了熵与微观状态数目的关系，即著名的玻尔兹曼熵公式：S = k ln W，其中k是玻尔兹曼常数，W是系统的微观状态数。 熵在信息论中的应用：
除了在物理学中的应用外，熵也被引入到信息论中，作为衡量不确定性或信息含量的度量。香农（Claude Shannon）将这个概念应用于通信理论，提出信息熵的概念，用于描述信号源的信息内容。
信息熵通常以比特为单位进行测量，它可以用来量化消息的不确定度或编码的效率。例如，在数据压缩中，高熵的数据更难被有效地压缩，因为它们包含更多的不确定性；而在密码学中，随机密钥的熵越高，就越难以破解。
简而言之，熵是一个非常重要的跨学科概念，它不仅限于物理领域，还广泛应用于工程、计算机科学、生物信息学等多个领域。
最大熵原理（Principle of Maximum Entropy）是概率论和统计学中的一种方法，它用于从一组已知约束条件下推断出最合理的概率分布。该原理是由物理学家E.T. Jaynes在1957年提出的，并且在信息理论、决策理论、信号处理、机器学习等领域有着广泛的应用。
最大熵原理的基本思想：
在给定一些关于随机变量的有限知识的情况下，应该选择熵最大的概率分布来描述这个随机变量。假设我们只知道一个随机变量的一些期望值或均值（即某些特定函数的期望），那么所有满足这些期望值的概率分布构成了一个可能性空间。最大熵原理建议我们在这些可能的概率分布中选择熵最大的那个，因为它对未知的信息做出了最少的假设。 为什么选择具有最大熵的分布？
熵是衡量不确定性的一个度量。熵越大，表示随机变量越不确定或者越随机。选择最大熵分布可以确保我们的预测尽可能地不偏不倚，因为我们没有额外引入任何不必要的结构或假设。这种选择避免了过拟合问题，因为最大熵分布不会过度依赖于已知的数据，而是保持了一定程度的灵活性来适应未来的观测结果。 应用示例：
文本分类：当需要为文档分配类别时，可以根据每个类别的频率和文档中的单词出现频率来计算条件熵，然后选择使整体熵最小的类别分配。自然语言处理：在构建语言模型时，可以使用最大熵模型来估计下一个词的概率，其中考虑到了词汇、语法和其他上下文信息的影响。 总之，最大熵原理提供了一个系统的框架，用于从部分信息出发推断完整的概率分布，它强调了保守性和不确定性原则，在许多情况下被证明是一个有效的工具。
2、国内外发展 进入21世纪，尤其是近十年来，深度学习技术的发展极大地推动了自然语言处理的进步。基于深度神经网络的模型，如循环神经网络（RNN）、长短时记忆网络（LSTM）和Transformer等，这些技术大大提高了自然语言处理的效率和准确性。百度的ERNIE、阿里巴巴的BERT等预训练模型在多种中文自然语言处理任务上表现出色。在国际上，谷歌、Facebook、OpenAI等科技巨头在自然语言处理领域也取得了一系列重要的突破。例如，谷歌推出的BERT模型和OpenAI的GPT系列模型，都在多个自然语言处理任务上取得了超过人类水平的表现。
3、底层原理 自然语言处理的底层原理涉及多个层面，包括语言学、计算机科学和统计学等。它涉及对语言的结构、语义、语法和语用等方面的研究，以及对大规模语料库的统计分析和模型建立。在具体实现过程中，需要对自然语言进行多个层次的处理，主要包括以下几个方面：
3.1、语言模型 语言模型是自然语言处理中最重要的概念之一，它用于计算给定文本序列的概率。语言模型可以基于规则、统计或深度学习等方法构建。在语言模型中，通常会使用一些概率模型来表示文本的生成概率，如n-gram模型、隐马尔可夫模型（HMM）和条件随机场（CRF）等。
3.2、词向量表示和语义分析 词向量表示是将自然语言文本转换为计算机可以处理的向量形式。在词向量表示中，通常会使用词袋模型（Bag of Words Model）或者分布式表示（Distributional Representation）等方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f1ce238dee8576022a7a13be307b0da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e9f4728059d4e154cb6dfa3748e90fe/" rel="bookmark">
			深度学习之网络优化与正则化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频链接：7.1 神经网络优化的特点_哔哩哔哩_bilibili
神经网络优化的特点 网络优化的难点 （1）网络结构差异大：不同模型之间的结构差异大——没有通用的优化算法、超参数多
（2）非凸优化问题：导致得到的最优解可能是全局最优解——参数如何初始化、如何逃离局部最优或鞍点
（3）梯度消失和爆炸问题：当网络非常深时，靠下的层的参数的梯度要么接近0，要么非常大，十分难优化
高维空间中的非凸优化问题 鞍点 低维空间中的非凸优化问题要解决的核心问题是如何逃离f'(x)=0的局部最优解
而在高维空间中的非凸优化问题要解决的核心问题是如何逃离鞍点
鞍点：梯度为0的点
鞍点在某些维度上是局部最小点，而在某些维度上是局部最大点
假设在D维空间中有一点为鞍点，在每一维上，如果它是一个非凸优化问题，基本上一个局部最低点与局部最高点的比例是1：1。因此在每个维度上一个梯度为0的点是局部最优点的概率为1/2，因此在D维空间的鞍点为全局最优点的概率为(1/2)^D
平坦最小值 在高维空间中，大部分的最小值都是平坦最小值，当参数冗余的时候，改变一个参数一般不会引起损失的大幅变化
由于局部最小解往往十分接近全局最优解，所以很多时候没必要去找全局最优解，反而是过于追求全局最优解可能会带来过拟合
优化地形的可视化 加入了残差连接的网络还可以使优化地形变得平滑
优化方法 优化算法改进 随机梯度下降（SGD） 对训练集中的样本进行随机排序，然后按照顺序每次取一个样本计算梯度，再反向传播更新参数至错误率不再下降
小批量随机梯度下降（MiniBatch） 每次取K个样本，更新是按步长更新，可以理解为把K个当成整体
批量大小（Batch Size） 与学习率的关系 当每次取K个样本、更新m次时，得到的Δ梯度如图左下角所示，可以看到这个式子是每次取batchsize为m的K个样本时的Δ梯度的m倍。为了使它们的步长差不多，学习率也要变成m倍。但是在实际应用中不需要过于追求线性关系，超参调整趋势大致一致就行
对收敛的影响 Iteration是更新一次，Epoch是整个数据集更新一次
如何改进 动态学习率 学习率衰减 周期性学习率调整 学习率不是一味的衰减，整体趋势是下降的，可以使模型更好地跳出sharp的局部最优点，得到更加平坦的局部最优点，增强模型的鲁棒性
左图是普通学习率调整，右图是周期性学习率调整（经过多个局部最优，方便找到更好地局部最优点）
其他学习率调整方法 （1）固定学习率调整批量大小，相当于减小了学习率
（2）先设置一个小的时间间隔，让学习率逐渐上升到预设点再开始衰减。因为参数初始化时的选点一般是未知的，梯度很不稳定，如果一开始就给一个大的学习率，是不利于稳定的优化的
自适应学习率 Adagrad：Gt是所有t的每一维度上的学习率的平方和，Gt随着训练次数增加而增加，学习率随之减小
RMSprop：把Gt从绝对的累计改成移动平均，β是超参数。移动平均的好处是：它不是历史上所有梯度的平方和，不会像Adagrad的Gt一样一直递增导致学习率过小
Adadelta：把分子也变成动态调整的，由上上次的ΔX的平方＋上次参数更新方向的平方构成。好处是：例如某点梯度比较大，那么你可以试着学习率变大一点，多走一下，可以帮助更好的收敛
梯度方向优化 Momentum动量 图1是每次更新的轨迹，图2是加了动量后的轨迹，可以看到像图1这样在垂直方向上无意义的抖动，加上动量后上下抵消，有利于梯度的下降
Nesterov加速梯度 动量法的缺陷：动量法可以看作是两步走，第一步走历史的一小段，第二步走θt-1的梯度。把连接点看作θ’，那么第二步直接求θ‘处的梯度而不是θt-1的梯度，有利于梯度估计
Adam算法 移动平均和真正的平均是有差异的，所以需要偏差修正
例如在t=1时的移动平均如图所示，M0=0，则
但实际上M1是=g1的，所以需要偏差修正
梯度截断 当梯度过大时，就算是小的学习率也会走出很远，极可能错过最优解
参数初始化 对称权重问题 因为权重都为0，那么计算出来的两个激活值a1和a2也相等，所以误差也相等。进而导致，代价函数对两个参数的偏导数也相等，所以用梯度下降更新后的参数值也会相等，只是可能不为0，但还是一直保持相等，后续也都会这样，一直相等。所以这样的话，两条蓝色的线的权重会相等，红色的会相等，绿色的也会相等，所以这个神经网络计算不出什么有趣的函数，每一层的神经元都在进行着相同的计算，这是一种高度冗余的情况
预训练初始化 在大量数据上训练骨干网络（backbone），再到固定的数据集上做微调
固定值初始化 bias通常初始化为0；在forget gate中的bias需要设大一点，让门一直打开，这样梯度比较好计算
随机初始化 Gaussian分布与均匀分布 如何确定均值、方差、r取多少合适：
例如上图中，x∈(0, 1)，将wx+b经过sigmoid后我们希望它落在左图蓝色的梯度较大的部分，通过这种方式取反推均值、方差、r应该取多少
范数保持性 因为 δ(l-1) = W(l).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e9f4728059d4e154cb6dfa3748e90fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59937e9fcc567968c57d75e41a326f32/" rel="bookmark">
			Cython批量编译py文件并打包python项目为whl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、Cython批量编译py文件
2、生成whl文件
3、关于使用报错找不到模块
1、Cython批量编译py文件 Cython是一个编程语言，它通过类似Python的语法来编写C扩展并可以被Python调用。能够将Python+C混合编码的.pyx脚本转换为C代码，主要用于优化Python脚本性能或Python调用C函数库。基于它的原理，可以得到一种代码加密的思路：将 .py/.pyx 编译为 .c 文件，再将 .c 文件编译为 .so(Unix) 或 .pyd(Windows)，这样得到的文件更难反编译。
优点
生成的二进制 .so 或 .pyd 文件难以破解同时带来了性能提升 不足
兼容性稍差，对于不同版本的操作系统，可能需要重新编译虽然支持大多数 Python 代码，但如果一旦发现部分代码不支持，完善成本较高 批量加密代码：
from setuptools import setup, find_packages from Cython.Build import cythonize import os def print_files(path): ''' 循环遍历文件夹与文件 :param path: 路径 :return: ''' for root, dirs, files in os.walk(path): for file in files: print(os.path.join(root, file)) # 打印完整路径 print(file) # 打印文件名 print(os.path.splitext(file)[0]) # 打印无扩展名的文件名 filepaths = [] def encrypt_py(path): ''' 加密路径下除了__init__.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59937e9fcc567968c57d75e41a326f32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eeb6db361d1c45260f901bea70d9fea/" rel="bookmark">
			结构体和链表例题2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、成绩系统之输入输出
题目描述
陈老师布置同学们完成一个小型的成绩管理系统，据说完成后至少可以有200行以上的代码，这可是课程学习到现在最大的编码量了。一下子写这么大的一个程序你可能会觉得无从着手，所以老师希望你先从输入输出开始。已知有n个学生，每个学生信息包含学号、姓名、性别、3门课程成绩，现在请你设计两个函数，完成学生信息的输入和输出，并在主程序中得到检测。
输入要求
先输入一个整数n表示有n个学生信息。(假设学生最多有50人)。接下来输入这n个学生的学号、姓名（不超过20个字符，可能带空格）、性别、3门课程成绩。每个学生输入中第一行输入学号、姓名，第二行包括性别、3门课成绩，具体见样例。
输出要求
输出n个学生的信息，按照输入的顺序
输入样例
2
15001 Peter Li
m 90 91 92
15002 Susan Wang
f 81 82 83
输出样例
---Student Information---
15001 Peter Li m 90 91 92
15002 Susan Wang f 81 82 83
代码示例：
#include&lt;stdio.h&gt; typedef struct student { int ID; char Name[20]; char Gender; int score[3]; }STU; STU s[50]; void add(STU *p,int n); void disp(STU st); int main() { int n,i; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eeb6db361d1c45260f901bea70d9fea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfc19b3e660d4b67d3266fd95b3c11e2/" rel="bookmark">
			sqlite3常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.系统命令 .help 帮助手册 .exit 退出 .table 查看当前数据库的有的表格名 .databases .schema 查看表的结构属性 另一批：
.backup NAME #备份数据库，备份的是db文件 .restore 备份文件的名字 # 恢复数据库 .output tablexx.sql # 备份数据库，备份的是SQL语句 .dump tablexx # 利用dump命令，将数据导出到文件。如果dump不带参数，则导出整个数据库 .read tablexx.sql # 恢复数据库 数据备份也可以在数据库外的命令行进行，例：
sqlite3 sqlite.db ".backup sqlite_backup.db" 2.sql语句 记得加 ; 结尾 具体例子以及实现参考：
SQlite3数据库相关相关命令_sqlite3 命令-CSDN博客
sqlite3常用指令_sqlite3 命令-CSDN博客
sqlite3 常用命令 - 百度文库
3.命令笔记： 将数据库某一列或几列设为空：
UPDATE table SET name1=NULL AND name2=NULL; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3df986099355afebd0dbdbaaf376e12/" rel="bookmark">
			HC-05蓝牙模块学习（两个蓝牙模块连接互发信息）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、进入AT模式和连接前注意事项
2、实现两个蓝牙完美配对
3、HC-05_1初始化配置
4、HC-05_2初始化配置
5、HC-05_1与HC-05_2绑定
6、设置模块通信波特率&amp;通信验证
1、进入AT模式和连接前注意事项 USB转TTL(串口助手)和蓝牙模块连接好后(VCC-VCC GND-GND RXD-TXD TXD-RXD )，插上电脑
进入AT模式的两种方法。
方法一：先按住按键不放，再给模块上电。此时LED 2S闪一次，进入AT模式。波特率固定为38400。
方法二：模块直接上电，此时LED灯快闪(1s两次)。再按下按键，模块也会进入AT指令，此时LED还是快闪。这个时候的波特率和自己设置的一样,默认为9600。1位停止位，无奇偶校验。
进入AT指令模式后
串口调试助手中一定要勾上发送新行，才会在发送字符后面添加\r\n 。不然每次就自己添加
1.测试通信是否有问题发送：
AT 返回：OK
2.设置波特率发送：
AT+UART=115200,0,0 返回：OK
3. 查询波特率：发送：
AT+UART? 返回：+UART=115200,0,0
OK‘’
4.设置蓝牙的名称和密码发送：
AT+NAME=Master (默认 名称HC-05)
返回：OK
5. 设置密码发送：
AT+PSWD="0000" 返回：OK
AT+PSWD?查询密码
2、实现两个蓝牙完美配对 前提：
1、准备两个可以进行主从连接的HC-05模块。HC-05_1 HC-05_2 （为区分两个模块其下标分为 1，2)。
2、两个TTL转USB模块，并与两个蓝牙模块完成接线。
VCC---VCC
RX-----TX
TX-----RX
GND---GND
3、两个不同的串口串口调试助手，分别用于HC-05_1和HC-05_2的初始化配置。
返回 OK，则成功配置
3、HC-05_1初始化配置 1、先按住按键不放，再给模块上电。此时LED 2S闪一次，进入AT模式，波特率固定为38400。（注意在串口调试助手上应设置波特率为38400发送AT指令才有效,返回ok表示可以正常使用）
AT 返回 OK，则成功配置
2、串口调试助手将蓝牙HC-05_1恢复默认设置：
AT+ORGL 返回 OK，则成功配置
3、配置蓝牙1的配对码，注意因为在步骤2中已经恢复默认设置，所以以下操作串口的波特率应调为9600（而且每次发送AT指令都要长按按钮来发送，否则会发送失败），或者重复步骤1，断电重新长按按钮上电，进入AT模式（此时发送AT指令则不需要再长按模块按钮），我此处是选择后者断电长按按钮重新进入AT模式：
AT+PSWD="0000" 返回 OK，则成功配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3df986099355afebd0dbdbaaf376e12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00184f439d568856fdb2c2402c1560db/" rel="bookmark">
			el-date-picker二次封装 自定义右侧图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这次的封装兼容日期范围选择器和日期时间范围选择器
element里选择器长这样
（日期）
（日期时间）
而设计图需要实现这样的效果
DOM部分
&lt;el-date-picker class="lj-date-range-picker" v-model="dateTime" :type="type" range-separator="~" :format="format" :start-placeholder="startPlaceholder" :end-placeholder="endPlaceholder" /&gt; &lt;svg-icon v-show="isIconShow" class="date-icon" name="ic--date" width="17px" height="16px"&gt;&lt;/svg-icon&gt; 然后我们需要把原来的icon隐藏，再通过定位把自定义图标放到合适的位置，这里我是放在了公共样式里，因为其他组件有用到，正常放在封装的文件下就行了
.date-container { position: relative; // 日期选择器隐藏图标（这个例子里用不到） .lj-date-picker { .el-input__prefix { display: none; } } // 日期范围选择器隐藏图标 .el-range__icon { display: none; } .date-icon { position: absolute; right: 8px; top: 8px; } } 这时当组件内有值就会出现鼠标划入时清除图标和自定义图标重叠的现象
所以我们要加两个事件，使得鼠标移上去后只显示清除图标
const isIconShow = ref(true) // 鼠标离开 const setDateIcon = () =&gt; { isIconShow.value = true } // 鼠标移入 const removeDateIcon = () =&gt; { if (dateTime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00184f439d568856fdb2c2402c1560db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ec32bb3ffd2e4c096ba6d09077a146d/" rel="bookmark">
			Go-目录结构及源文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.目录结构及源文件 目录结构
一个Go语言项目的目录一般包含以下三个子目录：
src 目录：放置项目和库的源文件；pkg 目录：放置编译后生成的包/库的归档文件；bin 目录：放置编译后生成的可执行文件。 三个目录中我们需要重点关注的是 src 目录，其他两个目录了解即可
src 目录 用于以包（package）的形式组织并存放 Go 源文件，这里的包与 src 下的每个子目录是一一对应。例如，若一个源文件被声明属于 log 包，那么它就应当保存在 src/log 目录中。
包是Go语言管理代码的重要机制，其作用类似于Java中的 package 和 C/C++ 的头文件。Go 源文件中第一段有效代码必须是package &lt;包名&gt; 的形式，如 package hello。
另外需要注意的是，Go语言会把通过go get 命令获取到的库源文件下载到 src 目录下对应的文件夹当中。
pkg 目录 用于存放通过go install 命令安装某个包后的归档文件。归档文件是指那些名称以“.a”结尾的文件。
该目录与 GOROOT 目录（也就是Go语言的安装目录）下的 pkg 目录功能类似，区别在于这里的 pkg 目录专门用来存放项目代码的归档文件。
编译和安装项目代码的过程一般会以代码包为单位进行，比如 log 包被编译安装后，将生成一个名为 log.a 的归档文件，并存放在当前项目的 pkg 目录下。
bin 目录 与 pkg 目录类似，在通过go install 命令完成安装后，保存由 Go 命令源文件生成的可执行文件。在类 Unix 操作系统下，这个可执行文件的名称与命令源文件的文件名相同。而在 Windows 操作系统下，这个可执行文件的名称则是命令源文件的文件名加 .exe 后缀。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ec32bb3ffd2e4c096ba6d09077a146d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/983a38afb53fd8ba1e84976c2e26828e/" rel="bookmark">
			【S32K144】MCAL基础工程搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、在S32DS创建Application Project
二、MCAL工程
三、基于MCAL的集成
以下示例基于S32K144EVB开发板进行。
一、在S32DS创建Application Project （1）新建工程Application Project
（2）工程配置
（3）一路选择Next以及Finish完成工程创建，新建工程是可以正常编译成功的
二、MCAL工程 NXP的MCAL安装这里就不赘述了，在MCAL安装的路径下查找以下路径：.\eclipse\plugins
该路径下的各个文件夹包含各个模块的静态代码以及示例工程，以下以DIO模块为例：
以下讲解主要是将MCAL集成到S32DS工程中，这里直接就不单独新建和配置MCAL工程，直接使用MCAL安装后的示例工程：
打开EB工具，导入对应MCAL工程，选择生成配置源代码文件生成：
以下为MCAL配置工程生成的源文件，在MCAL工程的generate目录下：
三、基于MCAL的集成 （1）以下需要将MCAL的静态代码以及MCLA配置工程生成动态代码集成到S32DS工程中：
（2）由于S32DS新建的工程部分文件与MCAL源代码重复，需要删除以下文件：
include目录下的头文件：debassert.h、S32K144.h
（3）添加全局宏定义
（4）mian.c编辑：完成一个Led闪烁操作
#include "Mcu.h" #include "Port.h" #include "Dio.h" void TestDelay(uint32 delay); void TestDelay(uint32 delay) { static volatile uint32 DelayTimer = 0; while(DelayTimer&lt;delay) { DelayTimer++; } DelayTimer=0; } int main(void) { uint8 count = 0U; /* Initialize the Mcu driver */ Mcu_Init(&amp;Mcu_Config_VS_0); Mcu_InitClock(McuClockSettingConfig_0); while ( MCU_PLL_LOCKED != Mcu_GetPllStatus() ) { /* Busy wait until the System PLL is locked */ } Mcu_DistributePllClock(); Mcu_SetMode(McuModeSettingConf_0); /* Initialize all pins using the Port driver */ Port_Init(NULL_PTR); while (count++ &lt; 10) { /* Get input level of channels */ Dio_WriteChannel(DioConf_DioChannel_LED, STD_HIGH); TestDelay(2000000); Dio_WriteChannel(DioConf_DioChannel_LED, STD_LOW); TestDelay(2000000); } return 0; } （5）编译代码，结果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c5f38cac1838833e2177bcf6e615514/" rel="bookmark">
			关于ThreadLocal的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么threadLoacl要设计改为thread类里面有threadLocalMap？ 为什么threadLoacl要设计改为thread类里面有threadLocalMap，然后map里面key为threadLoacl，value为value，而不是一个threadLoaclMap里面根据thread当key呢。
其实在早起jdk版本就是用后者，后来改成了前者。
主要原因：
1、减少hash冲突。这样把每个thread分多个map，可以减少每个map的存储数据，从而提高查询效率。
2、节省内存。最主要的还是因为thread里面放map，可以在thread销毁的时候自动删除map和里面的threadLocal这些，更节省内存。
ThreadLoaclMap到底是什么结构？ threadLoaclMap其实不是map，而是threadLoacl里面的内部类，map里面有个entry对象，就是key和value的形式，这个key定死了只能是threadloacl对象，而且是弱引用，为了让线程的生命周期和threadlocal解绑，下面会说。
Threadlocal的弱引用（重点） Threadlocal的内存泄漏其实跟弱引用没有关系，不管key是不是弱引用，他的value都会发生内存泄漏的，如果没有remove掉entry对象的话，所以如果我们用完threadlocal记得romove掉，要不然就只能等thread类销毁，然后他的map这些都会销毁了，用了线程池是很难达成的。
为什么key需要弱引用 因为threadlocal源码中的get、set方法里会对如果key为null，value也为null这种操作，是可以来防止内存泄露的，也就是当年让家remove掉entry的时候，弱引用其实可以提供一个保障
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b684bbb4ea4d2b2e331bda2dd94bf0aa/" rel="bookmark">
			【C&#43;&#43;】String类经典OJ题目分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 字符串相加字符串里面最后一个单词的长度反转字符串||反转字符串中的单词 字符串相加 链接: link
class Solution { public: string addStrings(string num1, string num2) { int next = 0;//存放进位 int end1 = num1.size()-1; int end2 = num2.size()-1; int ret = 0; string str;//存放相加后的结果 while(end1&gt;=0||end2&gt;=0) { int x1 = end1&gt;=0?num1[end1]-'0':0; int x2 = end2&gt;=0?num2[end2]-'0':0; ret=x1+x2+next; next = ret/10; ret = ret%10; str+=(ret+'0'); end1--; end2--; } if(next==1) { str+='1'; } reverse(str.begin(),str.end()); return str; } }; 本题要点：
1、两个存放数字的字符串相加，需要向最高位进位，定义next进位位。
2、定义两个尾指针分别指向num1和num2的最后一个字符（不是\0）。
3、循环结束条件以两个字符串中最长的为主，所以循环条件判断使用或运算符，定义两个相加变量时使用三目运算符，这个地方设计的很巧妙。
4、循环结束时如果进位位是1，则str+=1。
5、计算结束后使用reverse逆置得到相加后的字符串。（不使用insert，因为要挪动数据，开销大）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b684bbb4ea4d2b2e331bda2dd94bf0aa/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/59/">«</a>
	<span class="pagination__item pagination__item--current">60/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/61/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>