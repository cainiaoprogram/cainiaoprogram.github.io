<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00061030b2b4ec79c51d218ed195150f/" rel="bookmark">
			在工作表中调用Python自定义函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 在工作中调用Python自定义函数 1.1 在Excel中加载xlwings插件 步骤1 启动Excel并创建一个空白工作簿，单击“文件-&gt;选项”命令，打开“Excel选项”对话框。
在对话框左侧单击“自定义功能区”选项在右侧的“主选项卡”列表框中勾选“开发工具”复选框 步骤2 在“Excel选项”对话框左侧单击“信任中心”选项，在右侧单击“信任中心设置”按钮
步骤3 在打开的“信任中心”对话框左侧单击“宏设置”选项，在右侧单击“启用VBA宏（不推荐；可能会有潜在危险的代码）”单击按钮，勾选“启用VBA宏时启用Excel 4.0宏（X）”，勾选“信任对VBA工程对象模型的访问”复选框，单击“确定”按钮 说明：勾选“启用VBA宏时启用Excel 4.0宏（X）”。是因为有时候该文档的宏代码中使用了属于Excel 4.0宏的函数。
安全风险提醒：
若非确信你使用的文档是安全的，应禁用 “Excel 4.0宏”！
Excel 4.0宏（XLM）是Visual Basic for Applications（VBA）的前身，是出于向下兼容的需求而被纳入Microsoft Excel的一个遗留功能。微软在其支持文件中也曾警告，如果启用所有的宏将会导致 "潜在危险代码 "的运行。
步骤4 在“Excel选项”对话框中单击“确定”按钮，返回工作表中，切换到“开发工具”选项卡，在“加载项”组中单击“Excel加载项”按钮
步骤5 打开“加载项”对话框，如果在“可用加载宏”列表框中未看到xlwings插件，则单击“浏览”按钮
步骤6 打开“浏览”对话框，进入Python安装路径下的“site-packages”文件夹，找到并打开xlwings模块的文件夹，打开“addin”文件夹，选中名为“xlwings.xlam"的Excel加载宏文件，单击”确定“按钮
步骤7 随后”Xlwings“插件会自动显示在”可用加载宏“列表框中，勾选该插件的复选框，单击”确定“按钮
步骤8 返回工作簿，即可在功能区看到”xlwings“选项卡 1.2 导入并调用Python自定义函数 完成了xlwings插件的加载后，就可以在该选项卡下导入并调用Python自定义函数，准备一个带宏工作簿（扩展名为”.xlsm“）和一个包含自定义函数的Python代码文件（扩展名为".py"）。常用的操作模式有两种。
1.2.1 使用xlwings模块的命令创建文件实现调用 xlwings模块提供的quickstart命令可以快速创建带宏工作簿和Python代码文件，再以这两个文件为模块进行修改，就能实现Python自定义函数的导入和调用。
步骤1 按快捷键【Win+R】，在打开的“运行”对话框中输入“cmd”，按【Enter】键，打开命令行窗口，在当前路径后输入磁盘盘符“D:”，按【Enter】键，表示要在C盘创建带宏工作簿和Python代码文件，当前路径转到D盘的根文件夹下后，输入命令“xlwings quickstart table”，按【Enter】键，等待一段时间，如果出现xlwings的版本信息，就表示带宏工作簿和python代码文件已经创建成功。
提示
这里是在D盘的根文件夹下进行创建，如果要在D盘的其他已有文件夹下创建，可以先输入“cd 文件夹名"，按【Enter】键，将当前路径转到对应的文件夹下，在执行quickstart 命令。
命令“xlwings quickstart table”中的“table”是指要创建的文件夹以及文件夹中的带宏工作簿和Python代码文件的文件名，这个名称可根据实际需求更改。
步骤2 随后进入D盘，可以看到文件夹下创建了一个名为“table”的文件夹，打开该文件夹，可以看到“table.py”和“table.xlsm”两个文件
步骤3 打开“table.py”文件，可看到该文件包含自动生成的4段代码，我们可以用该文件作为模板，编写自定义函数。
例如，在代码末尾输入自定义函数double_sum()的代码段，该函数用于返回两个数之和的两倍。
步骤4 以”table.py"文件中的默认自定义函数hello()和自己编写的自定义函数double_sum()为例，演示如何在Excel中导入并调用Python自定义函数。在Excel中打开步骤2中创建的“table.py”，切换至“xlwings”选项卡，单击“User Defined Functions（UDFs）”组中的“import Functions”按钮
步骤5 现在就可以在工作表中像使用Excel工作表函数那样调用导入的Python自定义函数了。
在单元格A1中输入文本“Tom”，然后再单元格B1中输入公式“=hello(A1)"，按【Enter】键，即可得到hello()函数的执行结果。再单元格A2和A3中分别输入数值25和45，然后再单元格A4中输入公式“=double_sum(A2,A3)”，按【Enter】键，即可得到double_sum()函数的计算结果。
1.2.2 自定义Python代码文件的位置和名称 上面介绍的这种操作模式有一个前提条件：带宏工作簿和Python代码文件必须位于同一个文件夹下，并且具有相同的文件主名。如果带宏工作簿和Python代码文件不在同一个文件夹下，或者文件主名不同，则需要在Excel的“xlwings”选项卡下设置Python代码文件的位置和名称，才能导入Python自定义函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00061030b2b4ec79c51d218ed195150f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bc25d590e988dd6ab5a1d102e09d0cd/" rel="bookmark">
			邮件收发原理及部署postfix邮件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、邮件收发原理
1、原理图及名词解释
2、MTA功能介绍
3、POP和IMAP获取邮件介绍
二、部署postfix邮件系统
1、环境准备
2、DNS服务器部署
3、部署Postfix
4、部署Dovecot
三、使用Foxmail测试
1、修改DNS服务器
2、Foxmail登录测试账户
3、发送测试邮件 4、 服务端查看邮件
一、邮件收发原理 1、原理图及名词解释 MUA(Mail User Agent)：邮件用户代理，例如常见的Foxmail、网易客户端等。
MTA(Mail Transfer Agent)：英特网邮件传输代理，转发来自MUA的信件给指定的用户的程序。
MX(Mail Exchanger)：DNS中的邮件交换记录指向一个邮件服务器。
POP(Post Office Protocol)：邮局协议，即用户从SMTP存储中将邮件下载到本地。
IMAP(Internet Mail Access Protocol)：邮件访问协议，用户在线在SMTP存储中查看邮件等信息。
sent/receive：表示发送和收件的用户
2、MTA功能介绍 ①邮件传输：MTA邮件服务器负责接收、传输和投递电子邮件。
②邮件路由：MTA邮件服务器通过设置邮件传输规则和路由策略，将电子邮件从发送方传递到接收方。
③邮件排队和重试：MTA邮件服务器会将电子邮件放入队列中进行排队，以便在传输过程中遇到问题时重新尝试投递。
④邮件安全：MTA邮件服务器可以应用各种邮件安全机制，如加密、验证和防垃圾邮件（SPAM）过滤等。它可以使用加密协议（如TLS/SSL）来保护邮件的传输安全性。
⑤邮件管理和监控：MTA邮件服务器提供管理和监控功能，使管理员能够监视邮件传输状态、调整服务器配置和策略，管理用户帐户和邮件存储等。管理员可以跟踪邮件传递的流程，检查错误日志和排查故障，确保邮件系统的正常运行。
3、POP和IMAP获取邮件介绍 ①邮件存储位置：使用POP时邮件通常会从邮件服务器上下载到本地并在服务器上删除、而使用IMAP时邮件保留在服务器上本地设备只保留邮件的副本。
②邮件同步：由于POP将邮件下载到本地所以设备查看时不会同步状态(已读/未读)、IMAP可以与服务器保持同步，无论那个设备上查看邮件都会同步状态。
③邮件使用：POP下载到本地后无需网络即可查看邮件、IMAP需要网络连接访问服务器上的邮件。
④邮件管理：POP管理邮件的功能相对较少、IMAP可以在服务器创建删除移动文件夹管理邮件。
二、部署postfix邮件系统 1、环境准备 主机名操作系统IP地址安装程序作用mail-servercentos7.6192.168.30.20named、postfix、dovecotDNS服务器及邮件服务器windows10windows10192.168.30.200Foxmail客户端测试邮件功能 2、DNS服务器部署 mail-server执行： hostnamectl set-hostname mail-server #修改主机名 systemctl stop firewalld setenforce 0 iptables -F #关闭firewalld、selinux清空iptables规则 yum install bind -y #安装bind服务器提供DNS服务 vim /etc/name.conf options{ listen-on port 53 { any; }; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bc25d590e988dd6ab5a1d102e09d0cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf789744590610cc02c25cc526fa77b8/" rel="bookmark">
			Flutter最强大的图表库fl_chart的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介简单使用折线图柱状图饼图 简介 fl_chart是Flutter中功能最全、最强大的图表库。在flutter中的地位相当于前端的echarts、android端的MPAndroidChart
支持常见的LineChart(折线图)、BarChart(柱状图)、PieChart(饼图)。
库地址：https://pub-web.flutter-io.cn/packages/fl_chart
简单使用 库文档提供了详细的api说明，但是太过形式主义，全是对参数的说明。
没有每种图的简单使用，只提供了例子代码，需要自己去看，对不熟悉的人非常不友好！
以下是我经过使用后整理出来的最快速使用的说明。
折线图 柱状图 _buildBarChart() { return BarChart( BarChartData( /// 格式线样子设置 gridData: FlGridData( /// 是否隐藏垂直线 drawVerticalLine: false, /// 水平线的间隔值 horizontalInterval: 10, /// 水平线样式 getDrawingHorizontalLine: (v) { return FlLine( color: Color(0xffe5e5e5), strokeWidth: 1, ); }, ), /// 边框样式 borderData: FlBorderData( border: const Border( top: BorderSide(width: 1), right: BorderSide(width: 1), left: BorderSide(width: 1), bottom: BorderSide(width: 1), )), /// y轴最大值，从0开始 maxY: maxYValue, /// Bar的数据集合及样式 barGroups: _generateBar(values), /// 只有在alignment为center时，groupsSpace才生效。否则会按宽度平分。 groupsSpace: 30, alignment: BarChartAlignment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf789744590610cc02c25cc526fa77b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c41d430334f6949620769dec1c1b6915/" rel="bookmark">
			倒序输出一个四位整数(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 任意读入一个四位整数，颠倒后输出。
输入 输入一行，只有一个整数x(1000&lt;=x&lt;=9999)。
输出 输出只有一行，包括1个整数。
样例输入 复制 4567 样例输出 复制 7654 #include &lt;iostream&gt; using namespace std; int main() { int n; cin &gt;&gt; n; int reversedNum = 0; while (n &gt; 0) { // 将每一位上的数字反转，并求出新数字 reversedNum = reversedNum * 10 + n % 10; n /= 10; } cout &lt;&lt; reversedNum &lt;&lt; endl; // 输出反转后的数字 return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9e25c7cfbbf8a6220ecdc74b87f13f0/" rel="bookmark">
			SSL证书是什么？SSL证书的作用是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
SSL英文全称：英文全称: Secure Socket Layer Certificate,中文全称:安全套接字层证书。
SSL是一种由数字证书颁发机构(CA) 签发的数字证书。它用于建立安全的加密连接，确保通过网络传输的数据在客户端和服务器之间的安全性和完整性。
SSL证书通过使用公钥加密技术来实现安全连接。当浏览器或设备与一个使用SSL证书保护的网站通信时，它会验证证书的有效性，包括确认证书是否由可信的颁发机构签发，并检查域名是否与证书中的信息匹配。主要用于建立安全的加密连接，确保通过网络传输的数据在服务器与客户端之间的安全性完整性。
​
SSL安全证书的作用
1)加密数据传输: SSL证书使用公钥加密算法对传输的数据进行加密，确保敏感信息在传输过程中不被窃听或篡改。
2)身份验证: SSL证书通过验证网站的身份，确保用户正在与合法的网站进行通信，而非恶意伪造的网站。
3)信任度和可信度:由于SSL证书是由可信的数字证书颁发机构签发的，浏览器和设备都信任这些颁发机构的根证书，从而建立起信任关系。
4)改善搜索引擎排名:搜索引擎通常将使用SSL证书保护的网站作为安全性的指标，并将其排名较高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f3591e5f6fa76cc10d7d828d0675f7d/" rel="bookmark">
			系统监控(ps、htop等)、网络监控系列(jnettop、nmap、netstat等)、日志监控、系统工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		htop 官网：http://htop.sourceforge.net/
Linux top 命令的用法详细详解：https://www.cnblogs.com/zhoug2020/p/6336453.html
htop 使用详解：https://www.cnblogs.com/programmer-tlh/p/11726016.html
使用 yum 无法直接安装 htop，需要先安装 epel-release
yum -y install epel-release
yum -y install htop
1、htop 简介 htop 类似于 top 命令，但可以让你在垂直和水平方向上滚动，所以你可以看到系统上运行的所有进程，以及他们完整的命令行。可以不用输入进程的 PID 就可以对此进程进行相关的操作 (killing, renicing)。htop 是 Linux 系统中的一个互动的进程查看器，一个文本模式的应用程序(在控制台或者X终端中)，需要ncurses。与 Linux传统的 top 相比，htop 更加人性化。它可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。与 top 相比，htop有以下优点：
可以横向或纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。在启动上，比top 更快。杀进程时不需要输入进程号。htop 支持鼠标操作。top 已经很老了。 htop 参数 可以使用命令：apt-get install htop 来安装 htop，安装完成之后，键入 htop 命令，打开 htop。
可以看到总共分四个区域：
第一区域：CPU、内存、Swap的使用情况；第二区域：任务、线程、平均负载及系统运行时间的信息。平均负载部分提供了三个数字，这仅仅表示的是过去的5分钟、10分钟和15分钟系统的平均负载而已，在单核的系统中平均负载为1表示的是百分之百的 CPU 利用率。最后，运行时间 （uptime）标示的数字是从系统启动起到当前的运行总时间。第三区域：当前系统中的所有进程。各列说明：
PID：进程标志号，是非零正整数
USER：进程所有者的用户名
PR：进程的优先级别
NI：进程的优先级别数值
VIRT：进程占用的虚拟内存值
RES：进程占用的物理内存值
SHR：进程使用的共享内存值
S：进程的状态，其中S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值是负数
%CPU：该进程占用的CPU使用率
%MEM：该进程占用的物理内存和总内存的百分比
TIME+：该进程启动后占用的总的CPU时间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f3591e5f6fa76cc10d7d828d0675f7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47108ff28527e070ccb03bd1a0021cde/" rel="bookmark">
			Vue&#43;Springboot视频压缩&amp;清晰播放的前后端技术实现要点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路介绍 在互联网应用中，视频是一种常见的媒体形式，但是视频文件往往占用较大的存储空间和网络带宽，影响用户的体验和效率。为了解决这个问题，我们可以使用视频压缩技术，将视频文件的大小和质量进行平衡，减少视频传输和存储的成本。同时，我们也需要保证视频的清晰度和流畅度，让用户能够观看高质量的视频内容。
本文将介绍如何使用Vue+Springboot框架实现一个视频压缩&amp;清晰播放的前后端应用，主要包括以下几个方面：
前端使用Vue框架搭建一个简单的视频上传和播放界面，使用Element UI组件库提供美观的样式和交互。后端使用Springboot框架搭建一个RESTful API服务，提供视频上传、压缩、下载和播放的功能，使用FFmpeg工具进行视频压缩处理，使用H2数据库存储视频元数据。使用axios库实现前后端的数据交互，使用video.js库实现视频播放器的自定义和控制。 技术要点讲解 前端部分 1. 创建Vue项目 我们可以使用Vue CLI工具创建一个Vue项目，命令如下：
vue create video-compression 复制
选择默认的配置即可，等待项目创建完成后，进入项目目录，运行以下命令启动开发服务器：
npm run serve 复制
打开浏览器访问http://localhost:8080/，可以看到一个简单的欢迎页面。
2. 安装依赖库 我们需要安装以下几个依赖库：
axios：用于实现前后端的数据交互element-ui：用于提供美观的UI组件video.js：用于实现视频播放器的自定义和控制 运行以下命令安装这些库：
npm install axios element-ui video.js --save 复制
3. 配置Element UI 在main.js文件中，引入element-ui的样式文件和组件库，并注册为全局组件：
import Vue from 'vue' import App from './App.vue' import ElementUI from 'element-ui' import 'element-ui/lib/theme-chalk/index.css' Vue.use(ElementUI) Vue.config.productionTip = false new Vue({ render: h =&gt; h(App), }).$mount('#app') 复制
4. 创建视频上传和播放界面 在src目录下创建一个components文件夹，并在其中创建一个VideoUpload.vue文件，这个文件是我们的视频上传和播放组件。在这个文件中，我们需要定义以下几个数据和方法：
videoFile：用于存储用户选择的视频文件对象videoUrl：用于存储用户上传的视频文件的URL地址compressedVideoUrl：用于存储用户下载的压缩后的视频文件的URL地址uploadVideo：用于实现视频文件的上传功能，调用后端的/upload接口，并将返回的URL地址赋值给videoUrlcompressVideo：用于实现视频文件的压缩功能，调用后端的/compress接口，并将返回的URL地址赋值给compressedVideoUrldownloadVideo：用于实现视频文件的下载功能，调用后端的/download接口，并将压缩后的视频文件保存到本地playVideo：用于实现视频文件的播放功能，使用video.js库创建一个视频播放器，并将videoUrl或compressedVideoUrl作为视频源 在&lt;template&gt;标签中，我们需要使用element-ui的组件来构建一个简单的界面，包括以下几个部分：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47108ff28527e070ccb03bd1a0021cde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1408b2b6f106e1eb808dd7f3b605a9bb/" rel="bookmark">
			kubernetes Pod Lifecycle生命周期与livenessProbe、 readinessProbe探测方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kuberenetes pod Liveness, Readiness and Startup Probes tags: Pod,探针,健康检测
文章目录 kuberenetes pod Liveness, Readiness and Startup Probes1. Pod 状态2. Ready 状态3. 为什么需要健康检查4. Pod 生命周期条件5. 容器探针5.1 ReadinessProbe5.2 LivenessProbe5.3 StartupProbe 6. 什么时候应该使用活动探针与就绪探针？7. 配置技巧7.1 使用命名端口7.2 使用启动探测器保护慢启动容器 8. 探测方法8.1 http 探测8.2 cmd 探测8.3 TCP 探测 1. Pod 状态 Pod 的生命周期是 PodStatus 对象，其中包含一个phase字段。
值描述Pending该Pod已被Kubernetes系统接受，但是尚未创建一个或多个Container映像。这包括计划之前的时间以及通过网络下载图像所花费的时间，这可能需要一段时间。RunningPod已绑定到节点，并且所有容器都已创建。至少一个容器仍在运行，或者正在启动或重新启动。SucceededPod中的所有容器已成功终止，并且不会重新启动。FailedPod中的所有容器均已终止，并且至少一个容器因故障而终止。也就是说，容器要么以非零状态退出，要么被系统终止。Unknown由于某些原因，通常由于与Pod主机通信时出错而无法获得Pod的状态。 我们最常接触到的 Pod 状态是 Pending 和 Running。Pending 代表 Pod 正在创建中，而 Running 状态则要求至少有一个容器正在启动中或者正在运行。而对于 Pod 中的容器，也有下面 3 种状态。
而对于 Pod 中的容器，也有下面 3 种状态：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1408b2b6f106e1eb808dd7f3b605a9bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e90c7a56dacdc6c9f7c75eb3165bdde3/" rel="bookmark">
			Jupyter notebook安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、安装步骤1、安装 Python 编译器2、安装 jupyter3、运行 Jupyter notebook 二、 更改打开文件位置和快捷启动方式1、更改打开文件位置2、创建快捷启动方式 前言 Jupyter Notebook 是以网页的形式打开，可以在网页页面中直接编写代码和运行代码，代码的运行结果也会直接在代码块下显示的程序。如在编程过程中需要编写说明文档，可在同一个页面中直接编写，便于作及时的说明和解释。
一、安装步骤 1、安装 Python 编译器 ①、在安装Jupyter notebook 之前，确认你已安装python编译器（python官网）
打开命令行，执行：
python --version 2、安装 jupyter pip3 install jupyter 报错了，报错信息：
Could not find a version that satisfies the requirement jupyterthemes (from versions: none)
解决方法：
（1）可能是pip版本低，需要更新pip（多更新几次）：
python -m pip install --upgrade pip （2）还会继续报错，可以利用国内镜像源：
pip install jupyter -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com 3、运行 Jupyter notebook ①、输入启动命令 jupyter notebook 回车
jupyter notebook 选择以谷歌浏览器打开 html 文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e90c7a56dacdc6c9f7c75eb3165bdde3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdcd86cc32385ea0ec4c402b645fa4d1/" rel="bookmark">
			opencv学习笔记——5.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四章 图像算术运算 图像加法 cv.add对两副图像相加，要求两幅或多幅相加的图像的大小应该相同，处理时将两副图像相同位置的像素的灰度值（灰度图像）或彩色像素各通道值（彩色图像）分别相加；对一副图像和一个标量相加时，则将图像所有像素的各通道值分别与标量进行相加。
numpy加法是直接将数据相加取模。
参考以下代码：
x = np.uint8([250]) y = np.uint8([10]) # uint8是专门用于储存各种图像的，范围是0-255 # cv.add为饱和运算：[250] + [10] = [250+10](&gt;255) = 255 print(cv.add(x, y)) # numpy加法是模运算：[250] + [10] = [250+10]%256 = 4 print(x+y) 运算结果：
[[255]] [4] 图像融合 也是图像加法，但是对图像赋予不同的权重，达到融合或透明的效果。
这里使用的是cv.addWEighted()来实现对图像的加权。其中第一个参数是第一个图像；第二个参数是第一个图像的权值；第三个是第二个图像；第四个是第二个图像的参数；第五个是偏置，具体代码：
img1 = cv.imread('./picture/5_1.jpg') img2 = cv.imread('./picture/5_2.jpg') # print(img1.shape) dst = cv.addWeighted(img1, 0.3, img2, 0.7, 0) dst = cv.resize(dst, (108*3, 240*3), interpolation=cv.INTER_AREA) cv.imshow('dst', dst) cv.waitKey(0) cv.destroyAllWindows() 实现的效果：
按位运算 opencv中按位运算是十分重要的运算方式，其中与、或、异或、取反分别为cv.bitwise_and()、or()、xor()、not()，四个函数的参数都由src1、src2两个图像数据，以及mask可选操作掩码
img1 = cv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdcd86cc32385ea0ec4c402b645fa4d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5539ea5d6090e6786f52983ad98a8bc0/" rel="bookmark">
			Git 分支详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、分支概念介绍 1. 主分支（主干/主线/main/master） 包含所有最终修改的历史，反映项目的最终版本。
建议不要乱动主干，如果你编辑了一个小组项目的主干分支，你的改动会影响到其他人，而且很快就会出现合并冲突。
2. 开发分支（集成分支/develop/dev） 与主分支平行，该分支包含了为下一个版本所做的最新开发修改。它拥有该版本的最终源代码。
当开发分支达到稳定状态并准备发布时，应与主干分支合并，并标记为发布版本。
3. 什么是分支？ 分支可以理解为当前工作目录的一个副本。
4. 为什么要使用分支？ 使用分支的意义在于：将项目划分了多条线
譬如：在开发分支（开发线）上进行修改，之后合并到主线（产品线）上，保证主线的稳定性。
二、分支基本命令 1. 创建分支 ① 同时创建：仓库+分支
git init -b &lt;分支名称&gt;
② 已有仓库，再创建分支
仅创建分支：git branch&lt;分支名称&gt;
创建并切换到分支：git checkout -b &lt;分支名称&gt; 2. 分支查看 git branch
3. 切换分支 git checkout &lt;分支名称&gt;
4. 删除分支 git branch -D &lt;分支名称&gt;
5. 重命名分支 git branch -m &lt;原名称&gt; &lt;新名称&gt;
6. 分支合并 git merge &lt;被合并分支名称&gt;
三、实操流程 1. 创建分支：创建版本库同时创建分支 git init -b dev
-b：代表 branch 分支意思dev：代表开发分支 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5539ea5d6090e6786f52983ad98a8bc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ffb2e6d7c523c6411fd37c02a06d025/" rel="bookmark">
			Nmap扫描工具使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 理论 Nmap是一款基于C语言开发的开源网络扫描和安全审计工具。它可以通过扫描目标主机的端口、协议、应用程序版本等信息，帮助安全管理员评估网络和主机的安全性，并检测漏洞。Nmap支持的操作系统：Linux、Windows、MacOSX等操作系统。开源免费
Nmap支持多种扫描技术，包括TCP SYN扫描、TCP连接扫描、UDP扫描、ICMP扫描等。它还支持指定特定端口或范围的扫描，跨越多个子网的扫描，脚本扫描，版本探测，操作系统探测等。
Nmap的实现原理主要是基于TCP/IP协议栈的用法来研究和探测目标主机和网络设备的各种信息和状态。TCP/IP协议栈：Nmap是基于TCP/IP协议栈的网络扫描工具，可以通过对目标主机和网络设备的TCP/UDP端口进行快速扫描，实现对目标主机和网络设备的服务和状态探测。扫描策略：Nmap的实现策略主要是通过TCP SYN、TCP Connect、UDP和ACK等多种扫描方式进行网络扫描，从而快速地发现网络设备和主机的各种状态和信息。
2. 扫描IP地址 nmap -sn 192.168.120.0/24 192.168.120.100-254 3. 扫描端口 nmap -sS 192.168.120.85 #基于SYN的一个扫描端口 scan SYN nmap -sA 192.168.120.85 #基于ACK包的扫描 基本扫描 nmap -Pn 192.168.120.85 #不进行ping扫描 和sS效果一样 ​ nmap -sV 192.168.120.85 #重要，扫描端口并显示对应服务的版本信息 nmap -p6370-6380 192.168.120.85 #扫描对应端口范围 4. 扫描系统 nmap -O 192.168.120.85 #重点 5. 其他命令 nmap -A 192.168.120.85 #更多详细信息 nmap -F 192.168.120.85 #FAST扫描 nmap -sP 192.168.120.0/24 #scan ping网段 nmap --traceroute www.woniuxy.com #跟踪路由并扫描端口 6. 扩展命令 绕过防火墙
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ffb2e6d7c523c6411fd37c02a06d025/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c8aa6c4796a6f2ab07dead21e8cfef2/" rel="bookmark">
			使用宝塔面板搭建个人网站（博客）超详细2023
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介一、打开自己服务器控制面板二、安装宝塔 [宝塔地址](https://www.bt.cn/new/download.html)三、配置宝塔面板五、为你的网站导入模板总结 简介 提示：这里可以添加本文要记录的大概内容：
一直有一个执念想搭一个自己的网站，今天才付出行动，分享给同样想法的鼠鼠
个人网站地址：https://ooooooooooooooooooooooo.ooo/ooooοооoοᴏοoοᴏοoοᴏoooᴏооoоᴏᴏoоᴏᴏoᴏοοoᴏoooоᴏоoᴏоοoᴏoᴏoоᴏоoᴏoоoᴏoooᴏοοoоᴏоoᴏoоoᴏoоoᴏoo
当前的样子：
后续想换成这个模板样子（超符合我的审美）：
准备工作：
linux服务器一台 （腾讯云、阿里云、雨云）
域名一个(非必须)
一、打开自己服务器控制面板 可以使用 Xshell、WinSCP工具连接
我没用工具 win+R + cmd + ssh root@服务器地址 这是我买的服务器 ：雨云(推荐)
二、安装宝塔 宝塔地址 我是Ubuntu 系统 ：
wget -O install.sh https://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh ed8484bec
Centos系统：
yum install -y wget &amp;&amp; wget -O install.sh https://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh ed8484bec
将命令放入服务器：
宝塔安装成功后会有登录信息：
然后有些伙伴会发现，外网地址登录不上
（一般刚买的服务器 防火墙规则 ，大部分端口不让访问）
需要再服务器控制中 开发 宝塔的18728 端口 才能访问
开放 服务器 18728 端口
在你购买服务器 的设置里，选择 防火墙规则
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c8aa6c4796a6f2ab07dead21e8cfef2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f8d206ae571737fb25ccbefb11f1887/" rel="bookmark">
			oracle的oci.dll下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle InstantClient 下载http://www.oracle.com/technetwork/database/database-technologies/instant-client/downloads/index.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bffcde4044d3e7c5b69043495e255d6a/" rel="bookmark">
			Android 简单的获取当前可用运行内存，总运行内存，获取包含系统软件在内的所有内存，获取系统参数显示的内存大小。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 获取系统存储空间大小（不是内存） public String getDataTotalSize(Context context){ StatFs sf = new StatFs(context.getCacheDir().getAbsolutePath()); long blockSize = sf.getBlockSize(); long totalBlocks = sf.getBlockCount(); return Formatter.formatFileSize(context, blockSize*totalBlocks); } Android 最新获取手机可用内置存储大小，SD 卡存储空间大小方法 /** 得到系统可用内置存储大小 **/ @SuppressLint("NewApi") private String getMemFree(){ StatFs fs = new StatFs(Environment.getDataDirectory().getPath()); return Formatter.formatFileSize(this, (fs.getAvailableBytes())); } /** 得到SD可用存储大小 **/ @SuppressLint("NewApi") private String getSdFree(){ if(Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)){ StatFs fs = new StatFs(Environment.getExternalStorageDirectory().getPath()); //Android API18之前：fs.getAvailableBlocks()*fs.getBlockSize() return Formatter.formatFileSize(this, (fs.getAvailableBytes())); } return "未装载"; } 说明：上面的方法包不包含系统占用的部分，我看是不包含。
1.获取手机系统参数显示的内存大小：
/** * RAM内存大小, 返回1GB/2GB/3GB/4GB/8G/16G * @return */ public static String getTotalRam(){ String path = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bffcde4044d3e7c5b69043495e255d6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be3319ef9599f5a82aa2c206125ab42e/" rel="bookmark">
			InfluxDB-FLUX语法介绍以及查询InfluxDB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 FLUX 语法介绍最简示例FLUX 的基本语法注释变量与复制基本表达式谓词表达式控制语句 FLUX 中的数据类型十个基本数据类型Boolean （布尔型）bytes （字节）Duration 持续时间Regular expression 正则表达式String 字符串Time 时间点Float 浮点数Integer 整数UIntegers 无符号整数Null 空值 FLUX 类型不代表 InfluxDB 类型4 个复合类型Record（记录）Array（数组）Dictionary（字典）function（函数） 函数包 FLUX 查询 InfluxDBFLUX 查询InfluxDB 的语法表、表流以及序列filter 维度过滤类型转换函数与下划线字段map 函数自定义管道函数在文档中区分管道函数和普通函数window 和 aggregateWindow 函数yield 和 join FLUX 语法 介绍 Flux 是一种函数式的数据脚本语言，它旨在将查询、处理、分析和操作数据统一为一种语法。
想要从概念上理解 FLUX，你可以想想水处理的过程。我们从源头把水抽取出来，然后按照我们的用水需求，在管道上进行一系列的处理修改（去除沉积物，净化）等，最终以消耗品的方式输送到我们的目的地（饮水机、灌溉等）。
注意：InfluxData 公司对 FLUX 语言构想并不是仅仅让它作为 InfluxDB 的特定查询语言，而是希望它像 SQL 一样，成为一种标准。按照这个计划，FLUX 语言应该具备处理来自不同数据源的数据的能力。
注意InfluxDB 支持的 FLUX 语言版本：
需要注意，因为 InfluxDB 是一个用 Go 语言编写的数据库，它的整个项目成果就是一个单独的可执行二进制文件，所以 FLUX 语言其实也会被编译到同一个文件里。这意味着InfluxDB 和 FLUX 会有版本绑定的关系。
这里，我放了一个链接 https://docs.influxdata.com/flux/v0.x/influxdb-versions/ ，它是官方 FLUX 文档的一部分，这里明确记录了 InfluxDB 版本的 FLUX 语言版本的对应关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be3319ef9599f5a82aa2c206125ab42e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9ca4a3af08be976f6330059d6d395aa/" rel="bookmark">
			二叉排序树、平衡二叉树、红黑树、B树、B&#43;树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全民制作人们，大家好。我是练习时长两天半的个人练习册，喜欢B树 ，B+树， BST树， AVL树，来 red black ~
目录
一、二叉排序树(BST树)
1.1二叉排序树的定义
1.2二叉排序树的查找
1.3二叉排序树的插入
1.4二叉排序树的构造 1.5二叉排序树的删除 1.6二叉排序树的查找效率分析 二、平衡二叉树(AVL树)
2.1平衡二叉树的定义
1.2平衡二叉树的插入
1.3平衡二叉树的删除 1.4平衡二叉树的查找效率分析 三、红黑树
3.1红黑树的定义
3.2红黑树的插入 3.3红黑树的构造
3.4红黑树的删除 四、B树
4.1 B树的定义 4.2 B树的高度
4.3 B树的查找 4.4 B树的插入 4.5 B树的删除 五、B+树
5.1 B+树的定义 5.2 B树与B+树的对比
5.3 B+树的两种查找运算：
六、小结 顺序查找、折半查找、分块查找都是对线性表进行查找操作，它是静态查找表。即我们一般不对它进行插入和删除操作，因为如果是无序的，插入删除很方便但是查找的效率过低；如果是有序的，折半查找的效率不错但是插入删除太麻烦，所以我们下面要讨论的诸多树型查找就是动态查找表，它们方便进行插入删除操作的同时查找效率也不错。值得一提的是，它们是我们为了方便查找而定义的一种逻辑结构，属于是面向查找操作的数据结构，那么我们对它们复杂的定义也不足为奇了，这里点名红黑树。
一、二叉排序树(BST树) 1.1二叉排序树的定义 又称二叉查找树、二叉搜索树、BST(BinarySearch Tree)树。
它是一棵空树，或者是具有以下性质的二叉树：
若左子树非空，则左子树上所有结点的值均小于根结点的值。若右子树非空，则右子树上所有结点的值均大于根结点的值。左、右子树也分别是一棵二叉排序树。 对二叉排序树进行中序遍历，可以得到一个递增的有序序列。
1.2二叉排序树的查找 二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程。若二叉排序树非空，先将给定值与根结点的关键字比较，若相等，则查找成功；若不等，如果小于根结点的关键字，则在根结点的左子树上查找，否则在根结点的右子树上查找。
BSTNode *BST_Search(BiTree T,ElemType key) {//非递归 while(T!=NULL&amp;&amp;key!=T-&gt;data) {//若树空或者查找成功退出循环 if(key&lt;T-&gt;data) T=T-&gt;lchild;//继续往左子树中查找 else T=T-&gt;rchild;//继续往右子树中查找 } return T; } BSTNode *BST_Search(BiTree T,ElemType key) {//递归 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9ca4a3af08be976f6330059d6d395aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/695d25868947b26ff5beea39a517e2b7/" rel="bookmark">
			初始化安装K8s集群以及docker服务（附详细步骤和代码！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、什么是K8S？二、初始化安装k8s集群的实验环境1、配置好ip地址和设置对应的主机名2、关闭SELINUX和防火墙3、修改/etc/hosts文件，添加k8s集群里的主机和ip地址的映射关系4、互相之间建立免密通道（每台机器都要）5、关闭swap分区6、加载内核模块7、配置阿里云repo源8、配置安装k8s组件需要的阿里云的repo源9、配置时间同步 三、安装docker服务10、安装docker服务和开机启动11、配置docker镜像加速器和驱动12、安装初始化k8s需要的软件包13、kubeadm初始化k8s集群14、基于kubeadm.yaml文件初始化k8s15、配置kubectl的配置文件config16、扩容k8s集群，添加工作节点（在node1、2上输入命令）17、安装kubernetes网络组件-Calico 一、什么是K8S？ Kubernetes，也被称为K8s，是一个用于自动化部署、扩展和管理容器化应用程序的开源系统，是生产级别的容器编排系统.
二、初始化安装k8s集群的实验环境 环境介绍：3台全新的centos7.9系统、cpu2核、内存4G、磁盘20G
1、配置好ip地址和设置对应的主机名 控制节点 k8s-master 192.168.145.2213
工作节点 k8s-node1 192.168.145.222
工作节点 k8s-node2 192.168.145.223
（注意：以下操作三台服务器均要完成，可使用发送键输入到所有会话功能，然后在master一端输入即可，工作节点会同步进行）
2、关闭SELINUX和防火墙 [root@k8s-master ~]# sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config [root@k8s-master ~]# service firewalld stop Redirecting to /bin/systemctl stop firewalld.service [root@k8s-master ~]# systemctl disable firewalld Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service. Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service. ##重启 [root@k8s-master ~]# reboot 3、修改/etc/hosts文件，添加k8s集群里的主机和ip地址的映射关系 [root@localhost ~]# cat /etc/hosts 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 192.168.145.221 k8s-master 192.168.145.222 k8s-node1 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/695d25868947b26ff5beea39a517e2b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4729bf18c10cf99de65b7c634105b246/" rel="bookmark">
			【Linux配置Tomcat和JDK】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装Xshell 用于连接Linux服务器； 1、连接服务器 输入IP和连接名（自定义） 2、输入密码 3、成功登录 二、安装Xftp 用于Windows与Linux文件传输 1、输入名称、主机、用户名和密码 2、成功登录 二、下载配置环境所需要的安装包，通过Xftp传输到Linux系统文件夹下面（home或root文件夹都可以） 1、tomcat安装包 apache-tomcat-8.5.90.tar.gz
2、在Xshell中输入命令，解压 tomcat *先定位到安装包所在目录 比如：cd home
输入 tar -zxvf apache-tomcat-8.5.90.tar.gz 命令
3、jdk安装包 jdk-17.0.3_linux-x64_bin.tar.gz
4、在Xshell中输入命令，解压 jdk *先定位到安装包所在目录 比如：cd home
输入 tar -zxvf jdk-17.0.3_linux-x64_bin.tar.gz -C /usr/local命令, 解压 jdk到/usr/local目录
5、解压成功后指定目录会出现jdk文件夹 6、修改环境变量（很重要） 输入 vi /etc/profile ，去配置像Windows中的环境变量那样，进入之后，按 a 或 i ，进入编辑模式。
7、在文件的末尾输入以下信息 JAVA_HOME=/usr/local/jdk-17.0.3
PATH= J A V A H O M E / b i n : JAVA_HOME/bin: JAVAH​OME/bin:PATH
CLASSPATH=.: J A V A H O M E / l i b / d t .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4729bf18c10cf99de65b7c634105b246/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/628da6112a5b05c72130ee7752ead467/" rel="bookmark">
			自动生成的webservice客户端设置请求消息头信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里讲的头消息是指发送webservice请求的HTTP头信息（MIME 头信息），而不是SOAP报文里面的Header标签内容。
package example; import mypackage.GetOperInfoRequest; import mypackage.GetOperInfoResponse; import mypackage.Webservice11; import mypackage.WebservicePortType; import javax.xml.ws.BindingProvider; import javax.xml.ws.handler.MessageContext; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map; public class HelloWorldClient { public static void main(String[] args) { // 自动生成的客户端，新增请求消息自定义头 //Add HTTP request Headers // 此处value类型必须为List，因为下方HTTP request headers定义的类型是java.util.Map&lt;java.lang.String, java.util.List&lt;java.lang.String&gt;&gt; Map&lt;String, List&gt; requestHeaders = new HashMap&lt;&gt;(); requestHeaders.put("sender", Collections.singletonList("SYS028")); requestHeaders.put("receiver", Collections.singletonList("SYS001")); // 创建自动生成的webservice实例 Webservice11 service = new Webservice11(); WebservicePortType port11 = service.getWebservicePort11(); ((BindingProvider) port11).getRequestContext().put(MessageContext.HTTP_REQUEST_HEADERS, requestHeaders); // 创建生成的请求实体实例 GetOperInfoRequest req = new GetOperInfoRequest(); req.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/628da6112a5b05c72130ee7752ead467/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8dd25daa96d09e9c729a2a91d152c25/" rel="bookmark">
			【洛谷】P1952 火星上的加法运算（高精）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实方法和正常的十进制高精加一样，只不过把10换成了n
中间还要特判484字符……
#include&lt;bits/stdc++.h&gt; using namespace std; #define int long long int a[1005],b[1005],c[1005]; char s1[1005],s2[1005]; void solve() { int n; cin&gt;&gt;n&gt;&gt;s1&gt;&gt;s2; int l=strlen(s1); for(int i=0;i&lt;l;i++) if(s1[i]&gt;='a'&amp;&amp;s1[i]&lt;='z') a[l-i]=s1[i]-87; else a[l-i]=s1[i]-48;//输入特判×1 l=strlen(s2); for(int i=0;i&lt;l;i++) if(s2[i]&gt;='a'&amp;&amp;s2[i]&lt;='z') b[l-i]=s2[i]-87; else b[l-i]=s2[i]-48;//输入特判×2	l=max(strlen(s1),strlen(s2)); for(int i=1;i&lt;=l;i++) {//高精加 c[i]+=a[i]+b[i]; c[i+1]=c[i]/n; c[i]%=n; } if(c[l+1]) l++; for(int i=l;i&gt;0;i--) if(c[i]&gt;9) cout&lt;&lt;char(c[i]+87);//输出特判 else cout&lt;&lt;c[i]; } signed main() { ios::sync_with_stdio(false),cin.tie(0),cout.tie(0); int tt=1; //cin&gt;&gt;tt; while(tt--) { solve(); } return 0; } over~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/212b5ab057a774e6839a1f228d69094a/" rel="bookmark">
			WPF调用海康工业相机SDK采集图像并在halcon控件中成像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原参考文章
本篇大部分代码都是原参考文章中的，详情可以看原参考文章。
所需引用的名控件如图所示，前两个原文章有写，后两个需要在右击引用的程序集中自己找，如下2图。
项目目标平台要改成*64（右击你当前的项目，最后有个属性）
完成前期名空间引用后，写一个专门类放海康工业相机需要调用的方法，降低前端代码的代码量，代码复制粘贴了原大佬文章中的内容，这里整合了一下。
using System; using System.Collections.Generic; using System.Linq; using System.Runtime.InteropServices; using System.Text; using System.Threading.Tasks; using System.Windows; using System.Windows.Controls; using HalconDotNet; using MvCamCtrl.NET; namespace UnionHalcon { public class Hikvision { private MyCamera m_pMyCamera; MyCamera.MV_CC_DEVICE_INFO_LIST m_pDeviceList;//设备列表 private MyCamera.MVCC_INTVALUE stParam;//用于接收特定的参数 //为读取、保存图像创建的数组 UInt32 m_nBufSizeForDriver = 3072 * 2048 * 3; byte[] m_pBufForDriver = new byte[3072 * 2048 * 3]; UInt32 m_nBufSizeForSaveImage = 3072 * 2048 * 3 * 3 + 2048; byte[] m_pBufForSaveImage = new byte[3072 * 2048 * 3 * 3 + 2048]; //要转成的Halcon图像 HImage image = new HImage(); //查找设备 public void DeviceListAcq(ref ComboBox cbDeviceList) { int nRet; // ch:创建设备列表 en:Create Device List System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/212b5ab057a774e6839a1f228d69094a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/156cca96ce467af9c2fe057c85f86264/" rel="bookmark">
			【23-07-03：HTTP协议的结构学习】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 HTTP 请求的结构HTTP 请求的整体架构请求方法（Method）请求路径（URI）GET 参数（Parameters for GET)协议说明（Protocol）头部字段（Headers）请求体（Body） HTTP 响应的结构协议说明（Protocol）状态码（StatusCode）与状态说明（StatusDescription）头部字段（Header）响应体（Body） HTTP 协议的交互 HTTP协议主要分为请求和响应两部分。请求和响应都是采用标准的HTTP格式，分为“头（header）”和“体（Body)”两部分，使用单独的一行空行来隔开。请求头和响应头都是必需的（在HTTP/0.9,没有响应头，不做讨论），而请求体和响应体则可以缺省 HTTP 请求的结构 HTTP 请求的整体架构 请求方法（Method） 请求方法体现了本次请求的目的
方法名说明GET最为常见的方法，单击链接打开网页通常使用的都是GET方法，表示一次普通的请求POST提交数据时常用POST方法，主要用于登录、提交表单、上传文件等OPTIONS返回服务器针对特定资源所支持的HTTP请求方法HEAD与GET请求基本一致，但不返回响应体PUT早期用于向服务器上传文件，后来被RESTFul架构所重用，用来更新资源DELETE早期用于删除服务器上指定文件，后来被RESTFul架构所重用，用来删除资源TRACE回显服务器收到的请求，主要用于调试和诊断CONNECTHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器 此外，被许多服务器认可的方法还有：ACL、CANCELUPLOAD(cancelupload),CHECKOUT、COPY、LOCK、MKCALENDAR、MKCOL、MOVE、UPDATE、SEARCH等 请求路径（URI） （URI表示了请求的资源路径。）
(统一资源标识符（Uniform Resource Identifier，URI))
请求方法与URI之间是以若干个空格或TAB(制表符）来分隔的，通常是一个空格传统架构下，URI对应了网站目录结构。在新型的web架构下，会配置Web路由，根据URI映射不同的处理接口。当服务器被配置为HTTP代理时，这里通常是一串形如“http://xxxx”或“http://xxxxx”的数据。但在一般情况下，这里都是一串以“/”开头的资源路径。若所请求的资源是该服务器主页时，往往写作“/”即网站根目录，这时Web Server会根据当前的配置返回默认的首页，通常是”/index.html“或”/index“等。 GET 参数（Parameters for GET) GET参数通常是一些细化请求的描述
例如：文章id、页码、请求时间等。MVC架构主要以GET参数作为请求路径和接口对应。在URI之后如果还需要提交 GET 参数会以"?"作为分割符，在问号之后是一串参数序列。特殊情况下，如果请求的是首页并且存在“？”，此时“/”可以缺省，但是这个特性仅限于Apache服务器，Nginx则不行。“？”后面的一串参数序列也有特定的格式约束，总体来说是以“&amp;”作为不同参数的分割。每个参数由“key=value”的形式组成，key和value以第一个“=”划分。当参数出现数组时，以"key[name]=value"的形似进行提交。 协议说明（Protocol） 协议说明表示了当前请求使用的协议和版本。
以“HTTP/”开头，然后加上版本号，例如“HTTP/1.1”。URI(没有GET参数的情况)或GET参数与协议说明之间也是采用若干个空格或TAB(制表符）分割的，通常是一个空格。到这里，第一行的内容已经结束了，此时一般需要一个“\r\n”作为换行符，之后的几行是HTTP请求的头部字段，各字段之间的换行符默认均为“\r\n”,在一些Web Server中也是支持单独的“\n”. 头部字段（Headers） 头部字段说明了本次请求的域名（HOST）、使用的浏览器（User-Agent)以及Cookie等。头部字段有很多，下面列举几个常见的
字段名说明Host指定所访问的域名，对于一台服务器搭建了多个网站的情况，Web Server 依据Host不同来决定分别交给哪个网站应用来处理请求。一般所说的修改本机Host文件，在HTTP请求中也可以通过修改HTTP包中的Host字段来完成Referer当由一个页面A 单击超链接跳转到另外一个页面B，或通过提交表单到另外一个页面时，浏览器会自动将页面A的URL放在请求B页面的Referer字段中，这个字段主要时是告诉服务器这个请求时哪里来的。User-Aagent浏览器特征说明会告诉服务器当前用户所用的操作系统以及浏览器的类型和版本号，方便网站呈现在适合当前用户的前端展示效果Cookie这个字段十分重要，它会用来存储一些用户的状态，服务器通过读取这个字段可以清楚地了解用户当前地身份信息以及其他状态信息。 请求体（Body） GET请求通常没有请求体，而POST请求通常会有。
注意，这里使用了了两个“通常”，表示都不是绝对地。HTTP协议地任何字段都是可以人为修改的，这也是我在接触和学习web安全非常重要的心得体会，不少漏洞正是存在这样的修改之中。请求体主要用于提交大量不便于在请求头中传递的信息，之所以不便于在请求头中传递，主要是受长度限制和字符编码等因素影响，另外，如密码之类的信息，也比较适合放在请求体中传递，能够起到一定的保护作用。请求体的应用常见于POST方式提交的请求中。 HTTP 响应的结构 协议说明（Protocol） 协议说明用于说明当前响应是基于HTTP协议的哪一个版本，通常以“HTTP/”开头，后面加协议版本号，如：“HTTP/1.1” 状态码（StatusCode）与状态说明（StatusDescription） 这个字段相当重要，它说明了当前请求执行的结果。对有些漏洞的检测就是以响应状态码来判断的，比如大家熟知的“200 OK”"404 Not Found"等，常见的状态码及说明如下表
状态码状态码说明中文说明100Continue继续。常见于服务器接收大文件上传101Switching Protocol切换协议。一般用于HTTP协议升级，在HTTP/1.1转向HTTP/2.0中使用较多200OK一切正常。这是最为常见的状态码、201Created创建成功。在PUT文件成功后会提示301Moved Permanently永久跳转。网站永久跳转的新地址。在HTTP请求转为HTTPS时经常遇到302Moved Temporarily临时跳转。一般用于登录等功能，常见于URL跳转304Not Modified未改动。说明网站启用了缓存服务，与头部字段中的Cache-Control 字段信息相关，与安全也有联系。400错误。常见于构造后的HTTP数据包不被Web Server 认可，是一个非常重要的状态码401Unauthorized未授权。一般出现该请求头说明需要进行HTTP身份认证。HTTP身份认证是直接与Web Server 做登录交互，与普通的网站登录是有区别的。在某些Web Server 管理界面（如Tomcat），保留了HTTP认证的方式403Forbidden禁止浏览。在目录浏览漏洞中会介绍404Not Found找不到。请求的资源不存在，这是除200以外，日常生活中遇到最多的状态码405Method Not Allowed方法不被允许。通常是指请求最开始的方法，如GET，POST，有些网站不允许使用GET方法访问POST接口500Internal Server Error服务器内部错误。说明服务器执行的程序出现问题。开发人员经常和它打交道，在反序列化漏洞中会经常遇到502Bad Gateway网关错误。通常是域名没有配置正确或提交的Host字段有错误造成的 HTTP状态码与安全息息相关。在漏洞挖掘中，不同的状态码表达了不同的服务器内部情况，细心的人往往能通过服务器细微的变化来感知漏洞是否存在。 头部字段（Header） 这一点与请求基本类似，但略有区别。服务器响应中的头部字段Server 往往会包含服务器的Banner信息，从这一字段可以看出服务器使用的软件和版本号。此外，有一些响应的头部字段还约束者前端漏洞是否存在，是否能够被大范围利用。 响应体（Body） 响应头与响应体以一个独立的换行作为分割。对于大多数网站来说，主要采用HTML语言返回内容。HTML的中文全称为超文本标记语言。超文本是一种组织信息的方式，它通过超级链接方法将文本中的文字、图表与其他信息媒体相关联，HTML采用的是以左右尖括号包裹的标签和标签对的形式。浏览器会对HTML语言进行解析，解析完成之后，原本普通的标签文本就变成了文字、图片、链接、视频等多种元素混合的、丰富多彩的网页。除了HTML形式以外，还有二进制流数据（octet-stream），这种格式下会直接传递二进制字节信息，主要场景是文件下载；JSON格式主要用于AJAX架构的数据交互；还有XML格式以及基于XML的SOAP格式等。 HTTP 协议的交互 相比于TCP协议，HTTP协议的交互要简单得多，因为连接已经建立，不需要再“握手”和“挥手”了。HTTP协议基于采用“一问一答”的形式，即客户端发送一个HTTP请求（Request），服务器端返回了一个HTTP响应（Response）在弄清楚HTTP协议和TCP协议的关系时，需要掌握以下几点 1、一个HTTP报文可能存在多个TCP分片 有些请求或响应中，由于内容过长，导致被TCP分到了多个不 同的分片 2、一次TCP会话可能含有多个HTTP报文完成“三次握手”之后，连接发送了多次GET请求，这些请求时属于同一个TCP会话的。3、 一份HTTP报文可能包含多个HTTP请求或响应在这里直接将HTTP协议简单拼接，把三次请求放在同一个数据包内。但是，这样的请求服务器端未必当作三次来响应。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96399bdbbabac5ede09423bbac62f488/" rel="bookmark">
			KVM 一条命令创建VM虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		virt-install --name 主机名称 --ram 内存大小（Kb） --disk path=img路径（需要kvm有权限操作目录，自动创建）,size=vm磁盘大小（Gb） --vcpus 内核个数 --os-type linux --os-variant rhel7 --network bridge=br0（网卡名称） --graphics none --console pty,target_type=serial --location=/home/kvm/CentOS-7.7-x86_64-Minimal-1908.iso（镜像路径） --extra-args 'console=ttyS0,115200n8 serial'（console配置）
举例：
virt-install --name VM-name --ram 16384 --disk path=/kvm/images/VM-name.img,size=500 --vcpus 8 --os-type linux --os-variant rhel7 --network bridge=br0 --graphics none --console pty,target_type=serial --location=/home/kvm/CentOS-7.9-xxxxxx.iso --extra-args 'console=ttyS0,115200n8 serial'
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14540e87e1a35f95d433a64c8e6ae764/" rel="bookmark">
			【笔记】-升级frps服务端版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、安装包准备
安装包前往: github 进行下载
这里我们下载Linux和window两个版本 分别为frps和frpc
二、frps端更改
停止当前运行的 frps服务 systemctl stop frps找到服务端注册服务时的文件 frps.service
可以看到ExecStart 中定义了启动命令，前面 frps 为frps的应用包 -c 后为配置文件地址我们依据以上地址分别替换为最新的安装包和配置文件即可执行命令启动frps服务 systemctl start frps启动完毕后看服务状态是否正常 systemctl status frps
以上状态为正常情况，至此 我们frps端就升级完毕了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea7678dfb85f7a1b860f72084cef5a58/" rel="bookmark">
			Linux的scp 命令使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： 1、简介2、scp的基本语法3、将文件复制到远程 Linux 服务器4、将文件从远程系统复制到本地系统 1、简介 scp 命令是用于通过 SSH 协议安全地将文件复制到远程系统和从远程系统复制文件到本地的命令。使用 SSH 意味着它享有与 SSH 相同级别的数据加密，因此被认为是跨两个远程主机传输文件的安全方式。
2、scp的基本语法 $ scp [option] /path/to/source/file user@server-ip:/path/to/destination/directory /path/to/source/file – 这是打算复制到远程主机的源文件。
user@server-IP: – 这是远程系统的用户名和 IP 地址。请注意 IP 地址后面加冒号。
/path/to/destination/directory – 这是文件将复制到的远程系统上的目标目录。
以下是scp命令常用的几个选项：
-C - 这会在复制过程中压缩文件或目录。
-P - 如果默认 SSH 端口不是 22，则使用此选项指定 SSH 端口。
-r - 此选项递归复制目录及其内容。
-p - 保留文件的访问和修改时间。
3、将文件复制到远程 Linux 服务器 在下面的示例中，我将logs.tar.gz 复制到远程主机的/root目录下。主机IP为192.168.43.137，用户名为root。
[root@server1 ~]# scp logs.tar.gz root@192.168.43.137:/root 如果要复制目录，请使用-r选项，如下所示。在这里，我们将 /root/syslog目录复制到远程节点的/root目录中。
[root@server1 ~]# scp -r syslog root@192.168.43.137:/root 如果不添加-r选项复制目录，会提示如下错误。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea7678dfb85f7a1b860f72084cef5a58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d50884087c1a6e0a5a2b25015a262682/" rel="bookmark">
			实战分享！spring内存马（Controller）构造
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring部分运行机制 我们在controller处下断点
可以看到红框是涉及spring的部分，因为调用栈的帧顺序是从下往上，也就是下面的先运行，我们从下往上看。
可以看到先run运行起来，然后进入process部分，在进入service部分，进入invoke部分，进入dofilter部分，在返回到service部分，然后就进入了spring中，spring中继续请求，到doDispatch中进行请求的处理。
可以看到DispatcherServlet类中的doDispatch方法进行处理web请求。
这个方法中用handle()进行处理request和response，并且用 mappedHandler.getHandler()获取了mappedHandler的Handler。
那么老样子，我们先不看调用，先看handle()的参数中的mappedHandler.getHandler()。我们看看mappedHandler是干什么的。
这里用了getHandler(processedRequest)，那么我们跳入。
可以看到这里对handlerMappings（处理器映射）进行了遍历，调用mappedHandler的getHandler()方法对processedRequest进行了遍历。
handlerMappings介绍：
接着我们继续跟进mapping.getHandler。
跟进之后是个接口，那么找其实现。
我们进入AbstractHandlerMapping。
可以看到用到了getHandlerInternal()方法。
可以看到对mappingRegistry（spring的路径注册）上了锁，acquireReadLock方法用于获取读锁，如果持有写锁的线程数量或请求读锁的线程数大于0则让线程进入等待状态，releaseReadLock方法用于释放读锁，将读锁线程数减一并唤醒其它线程，acquireWriteLock方法用于获取写锁，如果持有读锁的线程数量或持有写锁的线程数量大于0则让线程进入等待状态。releaseWriteLock方法用于释放写锁，将写锁线程数减一并唤醒其它线程。mappingRegistry中存有路由信息如下：
继续回到getHandlerInternal看看。
因为lookupHandlerMethod()涉及请求，传入的参数是lookupPath和request，那么我们看看他是干嘛的。
阅读这一块代码，这里通过mappingRegistry获得请求映射地址，如果directPathMatches不为null，则调addMatchingMappings()进行添加路由，这里可以理解成 集合中的每一个RequestMappingInfo均会和request进行匹配，匹配上的话就创建一个Match对象并加入Match对象集合。
然后就是Matches的校验了，如果为null，就用mappingRegistry.getRegistrations()注册，Match集合不为空则从Match集合中找到最匹配的Match对象，并返回该Match对象的HandlerMethod对象。
也就是说模拟注册向mappingRegistry中添加内存马路由，就能注入内存马。
在AbstractHandlerMethodMapping中就提供了MappingRegistry添加路由。但是该类为抽象类。它的子类RequestMappingHandlerMapping能进行实例化。
RequestMappingInfoHandlerMapping也是抽象类，所以只能用RequestMappingHandlerMapping的registerMapping方法去进行注册（也就是通过AbstractHandlerMethodMapping的子类，也就是实现类去进行注册）。
一个spring内存马的生成 获取webApplicationContext 之前写的tomcat内存马，也是先需要获得容器的context对象。在tomcat中获得的是standardContext，spring中获取的是WebApplicationContext。
可以看到初始化WebApplicationContext的过程，那么如何获得WebApplicationContext呢？
那么这样就可以得到WebApplicationContext对象了，当然不只这一种方法，我们先往下走。
注册Controller 有了WebApplicationContext，接下来便是注册Controller，在第一部分《spring部分运行机制》中我们说了在AbstractHandlerMethodMapping中就提供了MappingRegistry添加路由。但是该类为抽象类。它的子类RequestMappingHandlerMapping能进行实例化。
可以看到RequestMappingHandlerMapping的registerMapping有三个参数mapping，handler，method
那么我们先看看第一个参数mapping怎么写，跳入看看mapping的类型的RequestMappingInfo的构造函数。
有四种，我们用的是第二种构造函数，共7个参数。
/** @deprecated */ @Deprecated public RequestMappingInfo(@Nullable PatternsRequestCondition patterns, @Nullable RequestMethodsRequestCondition methods, @Nullable ParamsRequestCondition params, @Nullable HeadersRequestCondition headers, @Nullable ConsumesRequestCondition consumes, @Nullable ProducesRequestCondition produces, @Nullable RequestCondition&lt;?&gt; custom) { this((String)null, patterns, methods, params, headers, consumes, produces, custom); } 再看第一个参数patterns的构造函数，PatternsRequestCondition是路径匹配，也就是定义访问 controller 的 URL 地址，那么这里写url。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d50884087c1a6e0a5a2b25015a262682/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2967b4060736039e9f5529eaf3fd9bb8/" rel="bookmark">
			做开发时你遇到最无理的需求是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作过程中难免遇见一些“神奇的甲方”，他们总是会给你提出一些匪夷所思甚至无厘头的需求。你是否也有这样的经历，面对这样“无理的需求”你又是怎么做的呢？
目录 前言一、案例一无理需求如何处理如何避免 二、案例二无理需求如何处理如何避免 总结最后 前言 大家好，我是空空star，本篇给大家分享一下《做开发时你遇到最无理的需求是什么？》。
个人主页inscode主页空空star的主页inscode主页 一、案例一 无理需求 希望在极短时间内完成一个复杂的系统或者功能，而且不愿意付出额外的费用或者人力资源。
如何处理 我们需要客观地评估这个需求的可行性和实际性。如果这个需求确实是无法在短时间内完成或者需要额外的费用和人力资源，我们需要与需求方进行交流，解释这个情况，并与他们协商达成一个更为合理的方案。如果需求方仍然坚持完成这个需求，我们需要明确地告诉他们可能会产生的问题和风险，并让他们做出决定，是否继续推进这个需求。在这个过程中，我们需要保持清晰的沟通和透明度，以确保需求方了解情况并做出明智的决定。 如何避免 首先，我们需要向需求方清晰地传达系统或功能的开发流程和时间成本，并告知他们，复杂系统或功能的开发需要更多的时间和更多的资源。如果他们期望在极短时间内完成项目，则需要额外的费用或人力资源来保证开发的高效性和质量。如果需求方仍不同意，则需要告知他们项目可能会受到影响，无法按时完成或质量不达标。其次，我们可以在项目合同中写明时间计划和工作要求，并与需求方达成共识。这样可以确保双方都明确了项目的可行性和时间成本，从而避免在后期出现争议。最后，我们可以尝试使用敏捷开发方法，将系统或功能拆分成多个小阶段进行开发，逐步完成和测试，这样可以使项目的迭代更加控制，同时也可以规避需求方对项目进度的不合理要求或压力。 二、案例二 无理需求 开发过程中，需求方对系统的功能和设计进行频繁修改，导致开发难以按时交付，并且可能会导致延迟甚至项目失败。
如何处理 确定变更的优先级：与需求方一起确定每个变更的优先级，从而确保开发团队能够优先处理最重要的变更事项。确定变更的成本：和需求方一起评估每项变更的影响和成本，以帮助他们理解影响和成本，并根据项目的时间表和范围进行取舍。透明度：保持透明度，及时地更新需求方项目的状态和进度，并与他们讨论任何变更可能带来的影响。迭代开发：采用敏捷开发方法，采用迭代开发模型，每次迭代可以优先实现客户最需要的功能。学习与优化：在项目结束后，与团队梳理整个项目，总结其中每个变更的成本及影响，并学习如何更好地处理类似情况，减少变更带来的不利影响。 如何避免 在项目启动时，确保需求方和开发团队都理解业务需求和目标，并且在开发过程中保持沟通和协作。这可以建立一个共同的视角和目标，以便更容易达成共识并减少需求变更的数量。
在开发过程中，及早识别需求变更的可能性，以便尽早进行调整。例如，可以通过包含反馈周期和评估机制来计划和评估变更请求，以确保它们符合项目目标和可行性要求。
建立一个清晰的需求管理和变更控制过程，以确保开发团队和需求方都明确了如何提交和评估变更请求，并且变更请求的优先级和影响已经确定。这可以帮助确保变更的有效管理和最小化其影响。
了解和评估变化的成本，以及对其他方面的影响，如开发时间、资源需求、质量、风险等。这可以帮助开发团队和需求方更好地权衡变更的利弊，并在必要时进行调整。
引入敏捷开发方法和工具，例如迭代开发、用户故事、原型设计等，以便更容易地进行快速原型迭代，并及早识别和解决设计和功能缺陷。
通过以上措施，我们可以更好地管理需求变更，减少其对项目进度的影响，从而更好地满足需求方的需求，确保项目顺利完成。
总结 InsCode AI 创作助手 轻松帮你完成创作。
最后 如果您不知道如何支持我， InsCode AI列了一些支持博主的句子供您参考： 博主写的文章很有深度，收获了很多知识。
博主的写作风格幽默风趣。
博主勇于分享自己的经验和教训，让初学者从中受益匪浅。
博主的思想独到，文章读起来让人格外振奋。
博主为人很好，乐于助人，回复读者的问题也非常及时。
博主的专业知识非常全面，无论是哪个领域的问题都能给出详细的解答。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c94683147d08ea29cd90e52bac0c05fb/" rel="bookmark">
			ffmpeg硬件解码器的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是硬件解码?
普通解码是利用cpu去解码也就是软件解码 硬件解码就是利用gpu去解码
为什么要使用硬件解码?
首先最大的好处 快 硬解播放出来的视频较为流畅，并且能够延长移动设备播放视频的时间； 而软解由于软解加大CPU工作负荷，会占用过多的移动CPU资源，如果CPU能力不足，则软件也将受到影响 最主要就是一个字 快
怎样使用硬件解码？ ffmpeg内部为我们提供了友好的接口去实现硬件解码
注意事项
ffmpeg内部有很多编解码器 并不是所有的编解码器都支持硬件解码 并且就算支持硬件解码的编解码器也不一定能支持你的显卡 也就是说在使用硬件解码时我们首先要去判断这个解码器是否支持在这个平台对这个显卡进行硬件编解码 不然是无法使用的
对显卡厂家SDK进行封装和集成，实现部分的硬件编解码
其次在ffmpeg中软件编解码器可以实现相关硬解加速。如在h264解码器中可以使用cuda 加速，qsv加速，dxva2 加速，d3d11va加速，opencl加速等。cuda qsv等就是不同公司推出的针对gpu编程的工具包
AV_CODEC_ID_H264；代表是h264编解码器。而name代表某一个编码器或解码器。通常我们使用avcodec_find_decoder(ID)和avcodec_find_encoder(ID)来解码器和编码器。默认采用的软件编解码。如果我们需要使用硬件编解码，采用avcodec_find_encoder_by_name（name）和avcodec_find_decoder_by_name(name)来指定编码器。其他代码流程与软件编解码一致。
//codec = avcodec_find_decoder(AV_CODEC_ID_H264); codec = avcodec_find_decoder_by_name("h264_cuvid"); if (!codec) { fprintf(stderr, "Codec not found\n"); exit(1); } 通过id找到的可能并不是你预期中的编解码器 通过name找到的一定是你想要的
下面是ffmpeg官方的硬件解码例子 我加上了中文注释方便理解
#include &lt;stdio.h&gt; #include &lt;libavcodec/avcodec.h&gt; #include &lt;libavformat/avformat.h&gt; #include &lt;libavutil/pixdesc.h&gt; #include &lt;libavutil/hwcontext.h&gt; #include &lt;libavutil/opt.h&gt; #include &lt;libavutil/avassert.h&gt; #include &lt;libavutil/imgutils.h&gt; static AVBufferRef *hw_device_ctx = NULL; static enum AVPixelFormat hw_pix_fmt; static FILE *output_file = NULL; static int hw_decoder_init(AVCodecContext *ctx, const enum AVHWDeviceType type) { int err = 0; //创建硬件设备信息上下文 if ((err = av_hwdevice_ctx_create(&amp;hw_device_ctx, type, NULL, NULL, 0)) &lt; 0) { fprintf(stderr, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c94683147d08ea29cd90e52bac0c05fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a06c8fb3c1ce9ae55d56e51767ae3fc/" rel="bookmark">
			企业微信{“errcode“:60020,“errmsg“:“not allow to access from your ip, hint: [1681129678500613099333714]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		企业微信{“errcode“:60020,“errmsg“:“not allow to access from your ip, hint: [1681129678500613099333714]
配置企业微信小程序时，报了如下错误：企业微信{“errcode”:60020,“errmsg”:“not allow to access from your ip, hint: [1681129678500613099333714], from ip: xxx.xx.xxx.165, more info at https://open.work.weixin.qq.com/devtool/query?e=60020”}
解决方案：
1、找到【应用管理】-&gt;【企业可信IP】-&gt;【配置】-&gt;将上面报错信息中的【from ip】给填充，并保存。再重新进入自建应用，就不会报错了
在最新版本中是在应用中的最下方可以看到 企业可信IP
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bd5235b1ef9d8f0291523f7776a62cb/" rel="bookmark">
			【数据结构】双向带头循环链表的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.概念
2.示例
3.实现
3.1接口
3.2生成一个节点 3.3初始化
3.4插入和删除的特点
3.5删除
头删
尾删
删除pos位置的数据
3.6插入
头插
尾插
pos位置之前插入
3.7打印数据
3.8销毁
1.概念 双向带头循环链表（下面统称该链表）和普通链表区别，很明显：
1、双向。 是指该链表有两个指针域，一个和普通链表一样，指向后一个节点（next），另一个指向前一个节点（prev）。
2、带头。 是指该链表有哨兵位，该位置不存储任何数据，只是为了帮我们定位该链表。
3、循环。 是指该链表头尾连接。
如下，是该链表每一个节点的定义，以及图示。
typedef int LTDataType; typedef struct LinkListNode { LTDataType data; struct LinkListNode* prev; struct LinkListNode* next; }LTNode; 2.示例 如下图，是一个双向带头循环链表的示例，可以看出，哨兵位头节点的prev指针指向该链表的尾节点，尾节点的next指针指向该链表的哨兵位头节点 ：
那么，该链表为空的时候，其结构如何呢？ 无论该链表是否为空，哨兵位都存在，那么，哨兵位既是头节点，又是尾节点，所以其prev指针指向自己，而next指针也指向自己。如下图，实际上，该链表为空即该链表初始化。
3.实现 3.1接口 如下，其各个接口和普通链表类似，涉及头插、尾插、头删、尾删、任意节点的插入和删除等等。
3.2生成一个节点 生成一个节点，该接口只需要传入 生成的节点的数据域的值 即可，两个指针指向NULL，然后返回指向该节点的指针。
LTNode* BuyLinkListData(LTDataType x) { LTNode* newnode = (LTNode*)malloc(sizeof(LTNode)); newnode-&gt;data = x; newnode-&gt;next = NULL; newnode-&gt;prev = NULL; return newnode; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bd5235b1ef9d8f0291523f7776a62cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4be720aa8fd2b7ed189d1c0ec341f323/" rel="bookmark">
			vue3 vite解决跨域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用vite创建项目，配置代理跨域，需要在vite.config.js的文件中，去配置。
这是使用vite搭建项目vite.config.js文件初始化的样子
import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' // https://vitejs.dev/config/ export default defineConfig({ plugins: [vue()],//使用vue插件。 resolve: { alias: { "@": fileURLToPath(new URL("/src", import.meta.url)) } },//通过@符，来快速找到src文件。不用使用相对路径来找来找去。 }) 下面通过server来配置
export default defineConfig({ plugins: [vue()],//使用vue插件。 resolve: { alias: { "@": fileURLToPath(new URL("/src", import.meta.url)) } },//通过@符，来快速找到src文件。不用使用相对路径来找来找去。 server: { port:4000,//设置服务启动端口号，是一个可选项，不要设置为本机的端口号，可能会发生冲突 open:true,//是否自动打开浏览器，可选项 cors:true,//允许跨域。 // 设置代理 proxy: { // 将请求代理到另一个服务器 '/api': { target: 'https://alloyteam-api.onrender.com/',//这是你要跨域请求的地址前缀 changeOrigin: true,//开启跨域 rewrite: path =&gt; path.replace(/^\/api/, ''),//去除前缀api } } } }) 这是配置跨域代理之后的vite.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4be720aa8fd2b7ed189d1c0ec341f323/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa51624f7162eb57b6762de5222fd849/" rel="bookmark">
			JAVA如何连接redis以及Springboot整合redis详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. java连接redis 1.1 java连接单机redis 首先创建一个普通的maven工程
（1）引入依赖
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; （2）测试
public class demo1 { public static void main(String[] args) { //String数据类型 // redisString(); //hash数据类型 // redisHash(); //List&lt;列表&gt;数据类型 Jedis jedis = new Jedis("172.16.7.220",6379); } private static void redisHash() { Jedis jedis = new Jedis("172.16.7.220",6379); jedis.select(1); jedis.hset("k1","name","syf"); HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put("name","ljh"); map.put("age","18"); map.put("address","shanghai"); Long k2 = jedis.hset("k2", map);//将哈希表 key 中的字段 field 的值设为 value hget key field: 获取存储在哈希表中指定字段的值。 Map&lt;String, String&gt; all = jedis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa51624f7162eb57b6762de5222fd849/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74f22b7f73aceb83d329ad4fd3ec4e92/" rel="bookmark">
			chatglm docker镜像，一键部署chatglm本地知识库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久没有写文章了，今天有空，记录一下chatglm本地知识库的docker镜像制作过程。
核心程序是基于“闻达”开源项目，稍作改动。镜像可以直接启动运行，大家感兴趣可以进入镜像内部查看，代码位于 /app 目录下。
一、制作镜像： docker tag chatglm:v1 ch1949/chatglm:latest docker push ch1949/chatglm:latest 1) Tag 这里注意： tag的名字斜线前面部分ch1949需要是本人docker的用户名，才能push成功。
本人的docker用户名，可以进入docker hub网站查看。
2) 通用化总结一下： 上传自己的镜像到 Docker Hub 上可以分为以下几个步骤：
注册 Docker Hub 账号并登录。在 Docker Hub 的官方网站上注册账号后，使用 docker login 命令登录到 Docker Hub。
$ docker login 构建 Docker 镜像。在本地使用 Dockerfile 构建出需要上传的镜像，
FROM python:3.9 WORKDIR /app COPY . /app RUN pip install -r requirements.txt CMD ["python", "app.py"] 通过 docker build 命令进行构建。
$ docker build -t myusername/myapp:1.0 . 给镜像打标签。使用 docker tag 命令给构建出的镜像打上标签，格式为 &lt;用户名&gt;/&lt;镜像名&gt;:&lt;标签&gt;，其中 &lt;用户名&gt; 是在 Docker Hub 上注册的用户名，&lt;镜像名&gt; 是自己给镜像起的名字，&lt;标签&gt; 是版本号或者其他标识符。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74f22b7f73aceb83d329ad4fd3ec4e92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc148b335e42ebccda364d6eb5d23e12/" rel="bookmark">
			单元测试使用mybatis从数据库查询信息报错(不适合所有人)org.mybatis.spring.MyBatisSystemException: nested exception is org
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要报错看这句：
Caused by: org.apache.ibatis.type.TypeException: Could not set parameters for mapping: ParameterMapping{property='end', mode=IN, javaType=class java.lang.Object, jdbcType=null, numericScale=null, resultMapId='null', jdbcTypeName='null', expression='null'}. Cause: org.apache.ibatis.type.TypeException: Error setting non null for parameter #4 with JdbcType null . Try setting a different JdbcType for this parameter or a different configuration property. Cause: org.apache.ibatis.type.TypeException: Error setting non null for parameter #4 with JdbcType null . Try setting a different JdbcType for this parameter or a different configuration property.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc148b335e42ebccda364d6eb5d23e12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9353b00788c28c53cfdf38a59d69917b/" rel="bookmark">
			swap分区相关操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交换分区swap 用途：swap 分区就是交换分区，(windows平台叫虚拟内存)
在物理内存不够用时，操作系统会从物理内存中把部分暂时不被使用的数据转移到交换分区，
从而为当前运行的程序留出足够的物理内存空间
关闭swap原因：swap启用后，在使用磁盘空间和内存交换数据时，性能表现会比较差，会减慢程序执行的速度。
查看swap当前的状态
[root@localhost ~]# free -m total used free shared buff/cache available Mem: 1819 172 1510 9 137 1500 Swap: 0 0 0 用swapon查看所属设备和大小:
[root@localhost ~]# swapon -v NAME TYPE SIZE USED PRIO /dev/dm-1 partition 2G 0B -2 临时关闭swap
查看swapoff的版本
[root@localhost ~]# swapoff -V swapoff from util-linux 2.23.2 关闭swap
root@localhost ~]# swapoff -a 临时关闭swap后启用swap
[root@localhost ~]# swapon -a 永久关闭swap
通过修改/etc/fstab文件永久关闭swap，找到swap分区的记录并且注释掉即可
[root@localhost ~]# vim /etc/fstab # # /etc/fstab # Created by anaconda on Tue Nov 8 21:08:57 2022 # # Accessible filesystems, by reference, are maintained under '/dev/disk' # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info # /dev/mapper/centos-root / xfs defaults 0 0 UUID=9173f045-3f4b-42e8-b9ee-e8c46cdc4c6b /boot xfs defaults 0 0 # /dev/mapper/centos-swap swap swap defaults 0 0 重启机器查看是否关闭成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9353b00788c28c53cfdf38a59d69917b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1621768b16486674f46fe4b0fd5c8fc0/" rel="bookmark">
			笔记-Centos7设置静态IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Esxi创建Centos虚拟机后，需要手动固定IP地址。具体设置方式如下：
1.1 排查是否有自动在DHCP中获取到IP地址
输入命令： ip -a address
这个时候我们能够看到，ens192这个虚拟的网卡内没有获取到任何IP，所以这个时候我们手动更改配置文件 设置固定IP地址
1.2 找到 /etc/sysconfig/network-scripts目录下面的 ifcfg-ensXX 此处ensXX为上一步查询导的网卡名称 如：ens192
在命令行内执行：vim /etc/sysconfig/network-scripts/ifcfg-ens192
1.3 配置文件调整
其中，绿色框标注的为关键配置
BOOTPROTO：指定网卡IP获取类型，DHCP/static
ONBOOT：是否在启动时启用或禁用服务，需要设置成yes
IPADDR：IP地址
NETMASK：子网掩码
GATEWAY：网关地址
1.4 调整完毕后，保存文件。输入命令 systemctl restart network 重启网络
1.5 在使用 ipconfig 或 ip -a address 检查网络IP是否正常，然后在外部使用 ping 命令看是否能够联通
参考博文链接：https://blog.csdn.net/m0_60487995/article/details/124225387
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1186cb37db2aa301c371740dfa401761/" rel="bookmark">
			【区块链】BLS门限签名介绍及实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基础知识传统BLS - 实现步骤1.初始化2.密钥生成3.签名4. 验签 BLS门限签名 - 实现步骤原理门限签名定义实现步骤1. 初始化（一样）2. 密钥生成3.签名4.验证 代码实现 基础知识 参考：BLS数字签名算法介绍及拓展
传统BLS - 实现步骤 1.初始化 G 1 , G 2 G_1,G_2 G1​,G2​ 是阶为 p p p 的 乘法循环群 。生成元分别是 g 1 , g 2 g_1, g_2 g1​,g2​
e e e 是 双线性映射:G1 * G2 -&gt; GT ,
安全 h a s h hash hash函数:h:{0,1}*-&gt; G1
公开参数是 ( G 1 , G 2 , G T , e , g 1 , g 2 , p , h ) (G_1, G_2, G_T, e, g_1, g_2,p,h) (G1​,G2​,GT​,e,g1​,g2​,p,h)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1186cb37db2aa301c371740dfa401761/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e30c54dafcbea2be8390dbc9ddd519d/" rel="bookmark">
			一、VUE3——setup、ref、reactive理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Vue3 改变1、性能提升2、源码的升级3、拥抱TypeScript 二、setup 使用1、注意点一2、注意点二 三、ref 函数1、作用2、语法3、接收的数据 四、reactive 函数1、作用2、语法3、实现原理 一、Vue3 改变 1、性能提升 （1）打包大小减少41%
（2）初次渲染快55%，更新渲染快133%
（3）内存减少54%
2、源码的升级 （1）使用Proxy代替defineProperty实现响应式
（2）重写虚拟DOM的实现和Tree-Shaking
3、拥抱TypeScript Vue3可以更好地支持TypeScript
二、setup 使用 &lt;template&gt; &lt;h1&gt;信息&lt;/h1&gt; &lt;h2&gt;姓名：{{name}}&lt;/h2&gt; &lt;h2&gt;年龄:{{age}}&lt;/h2&gt; &lt;button @click="sayHello"&gt;speak&lt;/button&gt; &lt;/template&gt; &lt;script&gt; export default{ name:'App', // 测试setup，不考虑响应式 setup(){ // 数据 let name='张三' let age=18 // 方法 function sayHello(){ alert(`${name},${age}`) } // 返回一个对象 return{ name, age, sayHello } } } &lt;/script&gt; 1、注意点一 尽量不要与vue2.x配置混用，vue2.x配置（data、methods、computed）中可以访问到setup中的属性、方法。但在setup中不能访问到vue2.x配置（data、methods、computed）。如果有重名，setup优先。
2、注意点二 setup不能是一个async函数，因为返回值不再是return对象，而是promise。
三、ref 函数 &lt;template&gt; &lt;h1&gt;个人信息&lt;/h1&gt; &lt;h2&gt;姓名：{{name}}&lt;/h2&gt; &lt;h2&gt;年龄:{{age}}&lt;/h2&gt; &lt;h3&gt;工作种类：{{job.type}}&lt;/h3&gt; &lt;h3&gt;工资：{{job.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e30c54dafcbea2be8390dbc9ddd519d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f26a93d13d80b545e45b0a9e8ea7d230/" rel="bookmark">
			如何开发微信小程序|基于微信小程序就诊预约系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者主页：编程千纸鹤
作者简介：Java、前端、Python开发多年，做过高程，项目经理，架构师
主要内容：Java项目开发、Python项目开发、大学数据和AI项目开发、单片机项目设计、面试技术整理、最新技术分享
收藏点赞不迷路 关注作者有好处
文末获得源码
项目编号：BS-XCX-013 一，环境介绍
二，项目简介
2.1 基本介绍
2.2 需求分析
2.3 功能设计
2.4 数据库设计
三，系统展示
四，核心代码展示
五，相关作品展示
一，环境介绍 语言环境：Java: jdk1.8
数据库：Mysql: mysql5.7
应用服务器：Tomcat: tomcat8.5.31
开发工具：IDEA或eclipse
前端开发技术：微信小程序+Vue+ElementUI
后台开发技术： springboot+mybatis-plus
二，项目简介 2.1 基本介绍 信息化技术在目前的中国，己得到普遍应用，涉及到民生的各个方面和角度，教育上的信息化应用、医疗上的信息改革、交通上的信息化普及等等，业己显示中国在向科技强国的方向前进。
中国经济水平的提升也让中国人民的日子富裕起来了，富裕生活的开始也让老百姓的对自身的健康日益重视起来了，中国的全面发展也带动了全民医疗资源的普及，看病就医也越来越方便。如何利用现代化技术手段，基于移动互联网技术，让老百姓更加方便快捷的进行在线预约就诊，这就是本系统要着重解决的问题。
经过调查和走访研发的这套在线就诊预约管理系统，采用微信小程序开发实现，基于MySQL数据库进行数据存储，前端使用微信小程序开发实现，后端基于Springboot框架，以及Nodejs开发实现，前端页面展示采用Vue+ElementUI实现。系统前端用户主要实现查看资讯信息、挂号大厅实现在线预约挂号、查看自己的预约、修改个人资料等；医生用户可以通过微信小程序端查看预约患者、填写诊断情况、管理预约信息等。后台主要实现用户管理、内容管理、活动和预约管理、统计预约用户数等功能。这套系统的上线对于人们就医就诊提供了很大方便，节约很多时间。
2.2 需求分析 基于微信小程序开发实现这套就诊预约管理系统，经过调研分析，得出需要两类用户角色，一类是系统的前端用户，一类是后端管理员用户。前端用户又分为患者用户和医生用户，患者通过微信小程序登陆后，主要的需求是通过此平台获得最新的资讯信息推送和在线预约挂号；医生用户登陆小程序端后主要就是通过此平台查看预约信息并填写就诊说明，同时发布预约时间信息等 。后台管理员用户主要实现相关数据的的管理功能，一是实现新闻动态的管理操作，二是实现预约信息的管理，三是实现注册用户的信息管理功能，四是进行在线信息的查看统计等功能。
2.3 功能设计 根据调查走访后进行的需求分析，得出基于微信小程序的在线就诊预约管理系统的各用户角色的主要功能模块图，如下图所示。
后台管理员登陆后台管理系统可以实现的主要功能模块有：用户管理、公告管理、轮播图管理、资讯分类管理、资讯信息管理、挂号信息管理、信息统计报表等功能。
图2-1 后台功能结构图
前端患者用户注册后可以登陆微信小程序，主要实现查看系统公告、查看相关资讯信息、查看挂号大厅里的就诊医生信息并进行在线挂号，对资讯文章进行点赞收藏，对医生进行评论，并可以在个人中心查看个人收藏的信息，维护个人信息，并可以维护自己的预约挂号信息。
图2-2 小程序端患者用户功能结构图
前端医生用户登陆微信小程序，主要实现查看系统公告、查看相关资讯信息、查看挂号大厅里的就诊医生信息，对资讯文章进行点赞收藏，查看预约了自己就诊时段的预约信息并进行管理，并可以在个人中心查看个人收藏的信息，维护个人信息，并可以发布自己的预约挂号信息。
图2-3 小程序端医生用户功能结构图
2.4 数据库设计 数据库表的详细设计主要基于实体模型的分析，在主要业务字段的基础上添加一些数据存储的必要字段比较主键信息等。下面展示一下就诊预约系统中涉及到的数据库物理表结构。
article_type：资读文章分类信息表，主要存储资讯文章分类信息。
表3-1资讯分类信息表（article_type）
名称
类型
空
默认值
其他
备注
type_id
smallint(5) unsigned
否
&lt;auto_increment&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f26a93d13d80b545e45b0a9e8ea7d230/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/270798cb88c262de8ddf3344e18a6e63/" rel="bookmark">
			JavaScript 与 TypeScript 的区别：一篇详细的解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
JavaScript 与 TypeScript 的区别：一篇详细的解析
1. 类型系统
1.1 JavaScript
1.2 TypeScript
2. 类和接口
2.1 JavaScript
2.2 TypeScript
3. 编译
3.1 JavaScript
3.2 TypeScript
总结
JavaScript 与 TypeScript 的区别：一篇详细的解析 在这篇文章中，我们将深入探讨 JavaScript 和 TypeScript 的区别。JavaScript 是一种动态类型语言，广泛应用于 Web 开发。而 TypeScript 是 JavaScript 的一个超集，引入了静态类型检查，以提高代码的可读性和维护性。接下来，我们将详细地介绍这两门语言的特点及它们之间的差异。
1. 类型系统 1.1 JavaScript JavaScript 是一种动态类型语言，意味着在运行时才能确定变量的类型。这为开发者提供了很大的灵活性，但同时也容易产生难以发现的错误。
let num = 42; num = 'Hello, World!'; 上面的代码中，变量 num 先是一个数字，然后被赋值为一个字符串。在 JavaScript 中，这是合法的。
1.2 TypeScript TypeScript 是静态类型语言，要求在编写时就指定变量的类型。这使得代码更加清晰，有助于发现和防止潜在的错误。
let num: number = 42; num = 'Hello, World!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/270798cb88c262de8ddf3344e18a6e63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92469c3af780014bb3076f859361a214/" rel="bookmark">
			Vue 2 与 Vue 3 的区别（模板和语法对比）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Vue 2 与 Vue 3 的模板和语法对比
1. 组件定义
2. 生命周期钩子
Vue 3 的其他新特性
1. 多个根节点
2. 更好的自定义指令 API
3. 更强大的 组件
4. 组件支持异步组件加载
结语
Vue 2 与 Vue 3 的模板和语法对比 1. 组件定义 Vue 2：
// Vue 2 export default { data() { return { count: 0 } }, methods: { increment() { this.count++ } } } Vue 3：
// Vue 3 import { ref } from 'vue' export default { setup() { const count = ref(0) function increment() { count.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92469c3af780014bb3076f859361a214/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4541564050ce1d280ac374bb9384e26/" rel="bookmark">
			获取R、G、B通道的直方图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 clc;%clc的作用就是清屏幕 clear;%clear是删除所有的变量 close all;%close all是将所有打开的图片关掉。 image=imread('E:\我的桌面\MATLAB\练习\2.jpg');%绝对路径的 R=image(:,:,1); G=image(:,:,2); B=image(:,:,3); hr=imhist(R); hg=imhist(G); hb=imhist(B); x=0:1:255; figure plot(x,hr,'r'); hold on plot(x,hg,'g'); hold on plot(x,hb,'b'); figure;imshow(image); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e6d16b144b2a90c34faa47ee02d517/" rel="bookmark">
			VMware虚拟机安装Linux系统教程（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware虚拟机安装Linux系统教程 一. 在VM中的安装与设置1.1 前言1.2 操作系统 二. Linux系统的具体配置2.1 启动项选择2.2 语言选择2.3 安装信息摘要2.3.1 本地化2.3.2 软件2.3.3 系统2.3.3.1 手动分区 2.3.4 用户设置2.3.4.1 ROOT密码2.3.4.2 创建用户 2.3.4 初始设置2.3.5 登录界面 一. 在VM中的安装与设置 1.1 前言 在VM中的设置大致和win10相同，详情可参考我的win10教程，这里只标出不同的地方。
1.2 操作系统 选择所需版本，这里以CentOS 7 64位为例。
二. Linux系统的具体配置 2.1 启动项选择 光标移动选择Install CentOs 7，然后按下回车键 。
等待页面加载完成并跳转。
2.2 语言选择 这里以简体中文为例，然后点击继续。
2.3 安装信息摘要 2.3.1 本地化 本地化下的这三个一般不用再配置。
2.3.2 软件 安装源可以按照默认配置，点击软件选择。
选择GNOME桌面，勾选开发工具，安全性工具可装可不装。
点击左上角完成，等待加载。
2.3.3 系统 点击安装位置，其余项目默认。
默认磁盘自动配置分区，可以直接点完成。
也可以点击我要配置，手动分区。
2.3.3.1 手动分区 选择我要配置分区，点击左上角完成。
一般需要三个分区 / /boot swap
分区功能/根分区目录，其他所有分区目录都位于其下/boot存放系统启动时所需的各种文件swap这不是目录，是一个特殊的 Linux 分区，通过文件系统的方式模拟物理内存，以应对物理内存使用时的不足 swap分区一般是虚拟内存的两倍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70e6d16b144b2a90c34faa47ee02d517/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cdb2936648875ebfb0d31b8185a6a01/" rel="bookmark">
			Arcgis对每个采样点提取NDVI值存入xls
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Arcgis对每个采样点提取NDVI值存入xls 数据导入 首先在Arcgis中导入上一篇文章中处理好的NDVI的tiff格式文件
然后是导入了一个点的shp文件，该文件存储了大厂区域采样点的地理位置（经纬度）信息（该文件是我师姐提供的），如果没有该现成的文件，也可以通过自己制作EXCEL格式的点经纬度信息，然后通过导入XY数据添加（在我的Arcgis制图的文章中有提及）。
下面比较重要的一步还是导出数据到图层中，导出完毕之后可以移除原先的文件
多值提取至点 接下来打开ArcTool，准备提取每个采样点对应的NDVI值
点要素选择图层中的点数据信息，栅格选择tif文件，然后确定
存入XLS 右键点击点，打开属性表可以查看提取结果
点击属性表左上方第一个按钮，导出
保存为txt文件，注意.txt后缀不要漏了，然后问你保存结果要不要添加到图层中，选否
导出的txt文件结果如下
然后新建一个xls文件，文件—打开中，打开这个txt文件
框选逗号，然后就会自动分栏了
结果如下：
最后再将该文件导出为.xls格式的文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc5ce86e2028fe8ed1f3961af3ecc12d/" rel="bookmark">
			分布式任务调度框架对比：OpenJob 和 XXJob
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一丶OpenJob：分布式任务调度框架 介绍 OpenJob 是一个开源的分布式任务调度框架，用于在分布式环境下调度和执行各种类型的任务。它提供了灵活的任务调度和分布式任务执行能力，使得开发人员可以轻松地管理和执行大规模的任务。
OpenJob 基于 Java 开发，使用了分布式调度算法和可靠的任务执行机制，确保任务的高可用性和可靠性。它提供了简单易用的 API 和丰富的功能，使得开发人员可以快速构建和管理任务调度系统。
本篇博客将详细介绍 OpenJob 的特性、架构和使用方法，并通过详细的 Java 示例来演示其功能和用法。
特性 OpenJob 提供了以下主要特性：
分布式任务调度：OpenJob 支持在分布式环境下调度任务，可以在多个节点上同时执行任务，实现任务的高并发处理。灵活的调度策略：OpenJob 提供了多种灵活的调度策略，如固定频率、固定延迟、Cron 表达式等，满足不同任务调度需求。任务依赖管理：OpenJob 支持任务之间的依赖关系管理，可以定义任务的前置依赖任务，确保任务按照正确的顺序执行。任务执行监控：OpenJob 提供了任务执行监控和统计功能，可以实时查看任务的执行状态、执行时间等信息，方便进行任务管理和优化。分布式任务锁：OpenJob 提供了分布式任务锁机制，保证同一任务在分布式环境下只能被一个节点执行，避免重复执行和冲突。任务失败重试：OpenJob 支持任务失败自动重试功能，可以配置任务的重试次数和重试间隔，提高任务的执行成功率。可扩展性：OpenJob 的架构设计具有良好的可扩展性，可以方便地扩展和定制各种功能，满足特定的业务需求。 架构 OpenJob 的架构包括以下核心组件：
调度器（Scheduler）：负责任务的调度和执行管理，根据调度策略和任务依赖关系确定任务的执行时间和执行节点。执行器（Executor）：在指定的节点上执行任务，负责任务的具体执行逻辑和结果返回。任务存储（Job Store）：存储任务的元数据信息，如任务的调度配置、依赖关系等。执行日志存储（Execution Log Store）：存储任务的执行日志和统计信息，方便任务的监控和分析。分布式锁（Distributed Lock）：提供分布式任务锁机制，确保同一任务在分布式环境下只能被一个节点执行。 使用示例 下面通过一个简单的 Java 示例来演示如何使用 OpenJob 进行任务调度和执行：
// 导入 OpenJob 相关的类和接口 import com.openjob.scheduler.Scheduler; import com.openjob.scheduler.Job; import com.openjob.executor.Executor; // 定义一个任务类 public class MyTask implements Job { @Override public void execute() { // 任务的具体执行逻辑 System.out.println("Hello, OpenJob!"); } } public class Main { public static void main(String[] args) { // 创建调度器 Scheduler scheduler = new Scheduler(); // 创建任务并添加到调度器 Job myTask = new MyTask(); scheduler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc5ce86e2028fe8ed1f3961af3ecc12d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16b0d44ddb6e8b493fd81a48b728b084/" rel="bookmark">
			Git入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.Git和SVN的区别1.1本地版本控制1.2集中版本控制1.3分布式版本控制 2.安装Git及环境配置3.基本的Linux命令学习4.Git的必要配置4.1System系统级4.2Global全局级4.3设置用户名与邮箱 5.Git基本理论5.1工作区域5.2工作流程 6.Git项目搭建6.1本地仓库搭建6.2克隆远程仓库 7.Git文件操作7.1查看文件状态7.2忽略文件 8.Git分支 1.Git和SVN的区别 1.1本地版本控制 1.2集中版本控制 1.3分布式版本控制 2.安装Git及环境配置 Git Bash:Unix与Linux风格的命令行，使用最多，推荐最多
Git CMD：Windows风格的命令行
Git GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令
3.基本的Linux命令学习 项目Valuecd改变目录cd …回退到上一个目录，直接cd进入默认目录pwd显示当前所在的目录路径ls（ll）都是列出当前目录中的所有文件，只不过ll列出的内容更为详细touch新建一个文件夹 如touch index.js 就会在当前目录下新建一个index.js文件rm删除一个文件mkdir新建一个目录rm -r删除一个文件夹，rm-r src删除src目录mv移动文件，mv index.html src index.html是我们要移动的文件，src是目标文件夹，当然这样写reset重新初始化终端/清屏clear清屏history查看命令历史help帮助exit推出 4.Git的必要配置 4.1System系统级 4.2Global全局级 4.3设置用户名与邮箱 Git config --global user.name “xxx”
Git config --global user.email “xxx@qq.com”
5.Git基本理论 5.1工作区域 Workspace ：工作区，就是你平时存放代码的地方Index/Stage ：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息Repository ：仓库区（或本地仓库），安全存放数据的位置，这里面有你提交的所有版本数据。其中HEAD指向最新放入仓库的版本Remote ：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换 5.2工作流程 6.Git项目搭建 6.1本地仓库搭建 git init 6.2克隆远程仓库 git clone 【url】 7.Git文件操作 7.1查看文件状态 #查看指定文件状态 git status 【filename】 #查看所有文件状态 git status # git add .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16b0d44ddb6e8b493fd81a48b728b084/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9deabc46751c569917642fd52a60afaa/" rel="bookmark">
			2023最新ELK日志平台（elasticsearch&#43;logstash&#43;kibana）搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 去年公司由于不断发展，内部自研系统越来越多，所以后来搭建了一个日志收集平台，并将日志收集功能以二方包形式引入自研系统，避免每个自研系统都要建立一套自己的日志模块，节约了开发时间，管理起来也更加容易。
这篇文章主要介绍ELK最新版本的搭建，二方包的介绍可以看小霸王的另外一篇文章。
ELK介绍 Elasticsearch 是一个分布式、Restful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。作为 Elastic Stack 的核心，Elasticsearch 会集中存储您的数据，让您飞快完成搜索，并对数据进行强大的分析。Logstash 是免费且开放的服务器端数据处理管道，能够从多个来源采集数据，转换数据，然后将数据发送到数据库中。Kibana 是一个免费且开放的用户界面，能够让您对 Elasticsearch 数据进行可视化，从跟踪查询负载，到查看应用请求的整个过程，都能轻松完成。 搭建平台版本 平台版本linuxcentos stream 9javaopenjdk 17elasticsearch8.6.2logstash8.6.2kibana8.6.2VMware Workstation Pro17 安装 首先在linux虚拟机上安装docker
先卸载旧版本
sudo yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine 升级yum
yum update 设置仓库
yum install -y yum-utils device-mapper-persistent-data lvm2 使用阿里云镜像地址
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装 Docker Engine-Community
sudo yum install docker-ce docker-ce-cli containerd.io 设置docker开机启动并启动docker
sudo systemctl enable docker sudo systemctl start docker 至此，docker已安装完成，可以使用docker -v查看版本，接下来就要安装三大金刚了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9deabc46751c569917642fd52a60afaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17acceaf832a4baa250ef8236b0e3aeb/" rel="bookmark">
			2023同济大学非全日制085400电子信息在职考研历程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0.相关参考网站1.初试-03方向2.专业课888工程能力综合2.1 工程伦理学2.2 物理2.3 计算机2.4 真题 3.个人学习计划4.复试4.1 复试内容4.2 复试分数线参考4.3 复试计划4.3.1 综合面试4.3.2 个人经验 序：这是一个很急促的在职考研历程，只想试着达到自己预期目标，略显功利。 0.相关参考网站 可以查院校、专业、录取人数、分数线、初试、复试等各种信息 中国研招网
硕士专业目录
同济研招网
同济招生平台
2023年电子与信息工程学院招收硕士生指导教师信息表（专业学位型）
电子与信息工程学院指导教师信息表A-G
1.初试-03方向 专业课888大纲：
2.专业课888工程能力综合 2.1 工程伦理学 选政治正确的就好，类似行测，逻辑判断为主，可以了解下，不用花时间复习。 2.2 物理 考试范围内 4 章的课后习题都做明白，结合重点总结，把公式和易错点记好。 第1，2，9，10章，可以主要看经典基础题型 大物课后习题笔记及练习题节选
2.3 计算机 大致过一遍知识点，考的都是基础常识知识，可以看看推荐的课本，有基础的话可不用复习 2.4 真题 无，专业课以物理课后习题为主，其他不用想着真题，全力复习数学即可 某学姐初试心得： 结合 888 考试范围来看，长篇大论，考点繁琐。但是事实上最大的考分占比是在逻辑思维+ 写作这两部分。类似公务员考试中的行测和申论，占分比几乎 70%。其他科目也需要复习但 是希望你可以好好分配时间~ - 选择题：大多是逻辑题（类似行测）+少量物理题+少量计算机题，比较基础 - 判断题（大约有 10 题）：大多逻辑题+少量物理题+少量计算机题，比较基础。 - 填空题（大约有 5 道）：计算机题+物理题，其中计算机题包含补充流程图。；2023物理（运动和电场） - 计算题（1 道）：都是物理题，10 分。力和运动，比较基础，课后习题为主； - 问答题（三四道，不少于 200 字）：30 分 其实就是小作文，问题类似你如何看待人工智能发展，你为何选择读研，双碳发展，打算如何和现有工作内容结合。只要笔迹工整，政治正确，字数不少。 - 作文题（3选2，不少于 500 字）：大作文，和上面的问法类似，就是一些陈述题。只要笔迹工整，政治正确，字数不少。 大物复习方法：把考试范围内 4 章的课后习题都做明白； 计算机复习方法：结合考纲把书翻翻，有个印象 补码反码什么的要会算（有填空），流程图知道什么框框是什么意思（不会让你画整个，只是填空）。 工程伦理学:我去年并没有复习…考试时也没有印象直接考题，选择或判断碰到了选政治正确的就好了。 如我上面所说，占比分最大的就是逻辑题和作文，如果没有接触过或者这方面有些弱的， 找些公务员行测的题多做做，找找感觉。这部分少丢分，你就稳了。 请结合自己的学习情况酌情参考 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17acceaf832a4baa250ef8236b0e3aeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab882287b12e87d15679484924759d1b/" rel="bookmark">
			docker安装RocketMQ(附填坑经验connect to ＜172.17.0.3:10909＞ failed)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、docker部署RocketMQ1、简易说明2、docker拉取RocketMQ镜像\RocketMQ控制台3、获取RocketMQ配置文件4、RocketMQ配置文件描述5、docker启动RocketMQ6、进入RocketMQ控制台 二、填坑经验错误一: connect to &lt;172.17.0.3:10909&gt; failed错误二: maybe your broker machine memory too small 本人安装版本：最新版(rocketmq-4.4.0),以下均对应4.4.0版本 一、docker部署RocketMQ 1、简易说明 在RocketMQ中，有三个关键组件：Namesrv（Name Server）、Broker和Console-ng（管理控制台）。
Namesrv（Name Server）：Namesrv是RocketMQ的命名服务，负责管理整个RocketMQ集群的路由信息。每个RocketMQ集群中都至少需要一个Namesrv实例。它维护了Broker的网络信息、Topic的路由规则以及Consumer的消费进度等元数据，并提供给Producer和Consumer使用。
Broker：Broker是RocketMQ的消息存储和处理节点，负责存储消息、处理消息的读写请求和转发消息等功能。在RocketMQ集群中，可以有多个Broker实例，各个Broker通过与Namesrv交互来维护消息的元数据和路由信息，以实现高可用、负载均衡的消息传输。
Console-ng（管理控制台）：Console-ng是RocketMQ官方提供的管理控制台，用于管理和监控RocketMQ集群。它提供了图形化界面，可以进行Topic、Consumer等的配置管理、消息查询与追踪、监控指标展示等操作。Console-ng对于集群的监控和运维非常有用。
这三个组件共同构成了RocketMQ的核心架构，并协同工作以实现高可用、高性能的消息传输和数据管理。您可以通过启动Namesrv、Broker来搭建一个RocketMQ集群，并使用Console-ng进行集群的管理与监控。
2、docker拉取RocketMQ镜像\RocketMQ控制台 拉取最新的RocketMQ，如果下载指定版本可以去docker官网查看
注：Namesrv、Broker均采用rocketmqinc/rocketmq同一个镜像
# 最新(rocketmq) docker pull rocketmqinc/rocketmq # 指定版本号(rocketmq) docker pull rocketmqinc/rocketmq:&lt;版本号&gt; # 最新(RocketMQ控制台) docker pull pangliang/rocketmq-console-ng 3、获取RocketMQ配置文件 可以启动RocketMQ，然后从docker容器中拷贝出配置文件，拷出配置文件后启动的容器就可以删除了
docker run -d --name rmqnamesrv -p 9876:9876 rocketmqinc/rocketmq:latest sh mqnamesrv # 进入容器(用于进入容器找到broker.conf 的位置) docker exec -it 容器ID /bin/bash # 从容器中下载文件到虚拟机 docker cp 容器ID:/opt/rocketmq-4.4.0/conf/broker.conf 虚拟机路径 4、RocketMQ配置文件描述 ongPollingEnable=true offsetCheckInSlave=false # nameServer地址，分号分割 namesrvAddr=172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab882287b12e87d15679484924759d1b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/117/">«</a>
	<span class="pagination__item pagination__item--current">118/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/119/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>