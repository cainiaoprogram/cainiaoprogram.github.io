<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82a91e3c81638029b457cef37c3c426a/" rel="bookmark">
			安卓彻底退出程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用List 依次添加Activity,然后需要时调用finish(),同时调用System.exit(0);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21362145987b6a8b4e5ad3f764eb8108/" rel="bookmark">
			【安徽集训】字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Description 给定小写字母串 \(s,t\)，你可以对 \(s\) 进行以下 \(4\) 种操作：
1. 在任意位置添加一个字符，代价为 \(a\)
2. 删除任一字符，代价为 \(b\)
3. 替换任一字符，代价为 \(c\)
4. 交换相邻两个字符，代价为 \(d\)
求将 \(s\) 变为 \(t\) 的最小代价。
\(|s|,|t|\le 4000,\space 0\lt a,b,c,d\le 10000,\space a+b\le 2d\)
Solution 有一个不存在操作 4 的子任务……
只考虑前 3 个操作的话，由于要成为 \(t\) 串一部分的所有字符之间的相对顺序不会变，这就变成了一个普及组 dp 题。
设 \(f(i,j)\) 表示将 \(s\) 的前 \(i\) 个字符修改为 \(t\) 的前 \(j\) 个字符的代价。
操作1：\(f(i,j)=f(i,j-1)+a\)
操作2：\(f(i,j)=f(i-1,j)+b\)
操作3：\(f(i,j)=f(i-1,j-1)+c\)
然后考虑丧心病狂的操作 \(4\)。
由于 \(a+b\le 2\times d\)，因此每个数只会交换一次。（我之前不知道 constraint 里这条是干嘛的）
操作4：记 \(k\) 为 \(s\) 中上一个 \(t[j]\) 的位置，\(l\) 为 \(t\) 中上一个 \(s[i]\) 的位置，则 \(f(i,j)=f(k-1,l-1)+d+(i-k-1)*b+(j-l-1)*a\)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21362145987b6a8b4e5ad3f764eb8108/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90fb841ab37be3f3380a2047258252b4/" rel="bookmark">
			被那个记过整的干什么都顾虑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		。
转载于:https://www.cnblogs.com/zhangzs000/p/11590153.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c18ab744d6dd037b51b082181ef31e40/" rel="bookmark">
			pands:numpy函数应用与映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		numpy函数应用与映射
from pandas import Index from pandas import Series,DataFrame import numpy as np import pandas as pd #numpy函数在Series/DataFrame的应用 frame=DataFrame(np.arange(9).reshape(3,3), columns= ['A','B','C'], index= ['a','b','c']) print(frame) ''' A B C a 0 1 2 b 3 4 5 c 6 7 8 ''' print(np.square(frame)) ''' A B C a 0 1 4 b 9 16 25 c 36 49 64 ''' series=frame.A print(series) ''' a 0 b 3 c 6 Name: A, dtype: int32 ''' print(np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c18ab744d6dd037b51b082181ef31e40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/112fef2a390e97cd4c7c67b9982b42bb/" rel="bookmark">
			SQL SERVER 还原误操作导致还原无法停止，处理办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天遇到运行库不知道单位哪个小伙子，把数据库还原了，导致单位业务全部瘫痪，主数据库一直显示正在还原，真的是不敢动，经过多方寻找，找到此脚本-------------------------数据库还原日志，导致数据库一直在正在还原状态，运行此脚本有一定的几率可以恢复
RESTORE database YXHIS_BAK（库名） with recovery
RESTORE database YXHIS_BAK（库名） with norecovery
转载于:https://www.cnblogs.com/since-1995/p/11588716.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96c09ced268b397c50b0f063e04c9fad/" rel="bookmark">
			吐血整理！绝不能错过的24个顶级Python库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“AI算法与图像处理”，选择加"星标"或“置顶”
重磅干货，每天 8:25 送达
来源：读芯术
全文共11815字，预计学习时长24分钟
Python有以下三个特点：
· 易用性和灵活性
· 全行业高接受度：Python无疑是业界最流行的数据科学语言
· 用于数据科学的Python库的数量优势
事实上，由于Python库种类很多，要跟上其发展速度非常困难。因此，本文介绍了24种涵盖端到端数据科学生命周期的Python库。
文中提及了用于数据清理、数据操作、可视化、构建模型甚至模型部署(以及其他用途)的库。这是一个相当全面的列表，有助于你使用Python开启数据科学之旅。
用于不同数据科学任务的Python库
用于数据收集的Python库
· Beautiful Soup
· Scrapy
· Selenium
用于数据清理和数据操作的Python库
· Pandas
· PyOD
· NumPy
· Spacy
用于数据可视化的Python库
· Matplotlib
· Seaborn
· Bokeh
用于建模的Python库
· Scikit-learn
· TensorFlow
· PyTorch
用于模型解释的Python库
· Lime
· H2O
用于语音处理的Python库
· Librosa
· Madmom
· pyAudioAnalysis
用于图像处理的Python库
· OpenCV-Python
· Scikit-image
· Pillow
作为数据库的Python库
· Psycopg
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96c09ced268b397c50b0f063e04c9fad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b8cbc8092cf86991dfb71fa30e077d8/" rel="bookmark">
			如何准备算法工程师面试，斩获一线互联网公司机器学习岗offer？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“AI算法与图像处理”，选择加"星标"或“置顶”
重磅干货，每天 8:25 送达
推荐文章【点击下面可直接跳转】： 来源：王喆的机器学习笔记 作者背景：《百面机器学习》作者之一，知乎大V，从事算法工程师多年
如何准备算法工程师面试，斩获一线互联网公司机器学习岗offer？
最近互联网公司的秋招如火如荼的进行，我也收到过不少同学的关于面试和选择offer的咨询，因为在之前的专栏文章和一些回答中已经介绍过一些相关经验，这篇文章就做一个全面的总结。
本文将分三个部分：
1.机器学习算法工程师的能力结构；
2.算法工程师面试中的一些不确定性因素和解决办法；
3.准备算法工程师面试的十条建议。
今年是我作为算法工程师工作的第七个年头，期间拿到过hulu，阿里巴巴，腾讯，美团以及一些startup的算法工程师offer，也作为面试官面试过清北，海外top30，北邮，以及一些二本学校等不同背景的百余位candidates，跟hulu的同事们一起写过一本书《百面机器学习》，作为面试者和面试官的经验还比较丰富。所以希望自己的经验对正在参加秋招的应届生和刚参加工作不久的同行们有所帮助。
既然我们的目标非常明确，就是斩获一线互联网公司机器学习岗的offer，那么在准备面试之前，我们首先要非常清楚：
一线互联网公司的机器学习岗对一名合格的算法工程师的要求应该是什么？
虽然每个岗位都有JD，但抛开具体的岗位需求，从稍高的角度看待这个问题，一名算法工程师的技术能力基本可以拆解成下面四个方面：知识、工具、逻辑、业务。
如果用技能雷达图的形式来展现机器学习岗相关的几个职位所需的能力，大致应如下图所示，大家可以初步体会一下。
机器学习相关岗位技能雷达图
简单来说，任何工程师都应该满足四项技能的最小要求，因为在成为一名合格的算法工程师之前，你应该是一名合格的“工程师”。我曾经面试过一位计算广告算法工程师职位的候选人，这位同学发过一些计算广告相关的paper和专利，从research的角度是不错的人选，但当我想验证一下他coding的能力时，他明确告诉我说他不愿意写代码。这就是不满足“工具”这项技能的最小要求，自然是不能通过面试的。
在最小要求的基础上，算法工程师的能力要求是相对全面的。作为算法模型的实现者和应用者，算法工程师在机器学习知识扎实的基础上，还应该具有算法的改进和实现的能力，因此工具和业务层面的要求也稍高。除此之外，大数据工程师更注重大数据工具和平台的改进，研究员则在知识和逻辑层面相对突出。有些临时抱佛脚的同学喜欢恶补知识，不注重理解业务和模型本身的内在逻辑，是我经常见到的面试“悲剧”情况。
当然，只用四个词描述四个方面的能力还是过于形而上了，这里我们用一些具体的内容来描述一下算法工程师的四个技能点：
知识：主要是指你对machine learning相关知识和理论的储备
工具：将你的machine learning知识应用于实际业务的工具
逻辑：你的举一反三的能力，解决问题的条理性，发散思维的能力，你的聪明程度
业务：深入理解所在行业的商业模式，从业务中发现motivation并进而改进模型算法的能力
也许还不够具体，那我们再从一些实际例子中体会一下，比如我去面试“计算广告算法工程师”的职位，上面四项对应着哪些具体的能力呢？
知识：主流CTR模型以及预算控制，流量预估，bidding策略等模型算法的原理和技术细节
工具：coding能力，spark、Flink、tensorflow、ps-lite等模型训练、serving相关工具
逻辑：算法题，模型之间的演化关系
业务：展示广告和搜索广告在构建模型时的区别和联系，如何根据公司的business model制定模型的objective
当然，以上只是让大家体会一下这四项素质是什么，真实的计算广告算法工程师面试中，你不一定要都掌握，也不一定局限于这些内容。如果你遇到一位资深的面试官，他不会预设一个框架往面试者身上套，而是会从简历出发检验面试者能不能达到这四项素质的标准。所以为了能够有的放矢的准备算法工程师的面试，我们首先要清楚的是面试官是：
面试官会如何在"限定的时间内"检验你这四项素质能不能达到"技术合格"的标准呢？
既然是限定的时间，面试官就不可能拿出一本西瓜书，从头问到尾，也不可能拿出一本葫芦书，从100道面试题中抽出50道给你来个马拉松问答。面试官要做的是在1个小时的时间内确认你能力的"深度"和"广度"。所以在这里面试官就像一个采样算法，要从你脑子里采几个点，把你的能力雷达图描绘出来。
重点再重复一遍，面试官会从“深度”和“广度”两个维度构建你的能力雷达图。
对于"深度"方面，有经验的面试官会从你已经做过的项目中挑出你最擅长的部分做层次式的递进。
比如一位面试同学介绍自己实习时候用过XGBoost预测股票涨跌，那面试官可能会由浅入深依次考察下列问题：
比如一位面试同学介绍自己实习时候用过XGBoost预测股票涨跌，那面试官可能会由浅入深依次考察下列问题：
GBDT的原理（知识）
决策树节点分裂时是如何选择特征的？（知识）
写出Gini Index和Information Gain的公式并举例说明（知识）
分类树和回归树的区别是什么？（知识）
与Random Forest作比较，并以此介绍什么是模型的Bias和Variance（知识）
XGBoost的参数调优有哪些经验（工具）
XGBoost的正则化是如何实现的（工具）
XGBoost的并行化部分是如何实现的（工具）
为什么预测股票涨跌一般都会出现严重的过拟合现象（业务）
如果选用一种其他的模型替代XGBoost或者改进XGBoost你会怎么做，为什么？（业务+逻辑+知识）
这是一条由简历出发，由“知识”为切入点，不仅考察了“知识”的深度，而且还考察了“工具”、“业务”、“逻辑”深度的面试路径。
当然，如果你介绍的项目是实现了一种类似阿里DIN的CTR预估模型。那么问题路径可能是这样的：
softmax函数的定义是什么？（知识）
深度神经网络为什么会产生梯度消失现象，如何解决它？（知识）
常见的激活函数有哪些？都有什么特点？（知识）
挑一种激活函数推导梯度下降的过程。（知识+逻辑）
Attention机制什么？（知识）
阿里将attention机制引入推荐模型的动机是什么？（知识+业务）
DIN中将用户和商品进行了embedding，请讲清楚两项你知道的embedding方法。（知识）
推荐系统中embedding技术都可以有哪些应用？（业务+知识）
你如何serving类似DIN这样的深度学习模型(工具+业务)
这条路径侧重于考查“知识”深度的路径。为了弥补其他方向考察的不足，面试官肯定还会问一个从工具或者业务出发的问题来确定你其他方面的深度。
因为面试官选择的是你最熟悉的领域深入下去，我们可以假设，如果一位面试者在最擅长的项目中都答不上一些细节性的问题，那几乎可以肯定你在任何其他领域的钻研都不够深入，你的技能雷达图的面积肯定是一个很小的面积。也有像我之前所提到的一些临时抱佛脚的面试者，也许知识方面达到了要求，但经不起面试官对“工具”和“逻辑”的考察，这也毫无疑问会“悲剧”。
如果面试者的能力深度达到了最低的要求，下一步面试官会确定你能力的广度，对于任何算法工程师，我都会随机check以下知识点中的几个：
NN，RNN，个别聚类算法，模型评估等知识的理解程度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b8cbc8092cf86991dfb71fa30e077d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d22100628910c5efe2037530c6ff82a7/" rel="bookmark">
			糖果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意 John得到了n罐糖果。不同的糖果罐，糖果的种类不同（即同一个糖果罐里的糖果种类是相同的，不同的糖果罐里的糖果的种类是不同的）。第i个糖果罐里有 mi个糖果。John决定吃掉一些糖果，他想吃掉至少a个糖果，但不超过b个。问题是John 无法确定吃多少个糖果和每种糖果各吃几个。有多少种方法可以做这件事呢？
思路 第i种糖果的生成函数是\(1+x+...+x^{m_i}\)，乘在一起就是\(\Pi 1+x+...+x^{m_i}=\frac{\Pi (1-x^{m_i+1})}{(1-x)^n}\)
本题的答案显然为前b项系数和减去前a-1项系数和。
代码 #include &lt;bits/stdc++.h&gt; using namespace std; namespace StandardIO { template&lt;typename T&gt;inline void read (T &amp;x) { x=0;T f=1;char c=getchar(); for (; c&lt;'0'||c&gt;'9'; c=getchar()) if (c=='-') f=-1; for (; c&gt;='0'&amp;&amp;c&lt;='9'; c=getchar()) x=x*10+c-'0'; x*=f; } template&lt;typename T&gt;inline void write (T x) { if (x&lt;0) putchar('-'),x*=-1; if (x&gt;=10) write(x/10); putchar(x%10+'0'); } } using namespace StandardIO; namespace Project { #define int long long const int N=101; const int MOD=2004; int n,a,b; int mul=1; int m[N]; inline int C (int x,int y) { if (x&lt;y) return 0; int res=1; for (register int i=x-y+1; i&lt;=x; ++i) { res=i%(mul*MOD)*res%(mul*MOD); } return (res/mul)%MOD; } int dfs (int pos,int a,int b,int mm) { if (pos==n+1) return a*C(n+mm-b,n)%MOD; return (dfs(pos+1,a,b,mm)+dfs(pos+1,-a,b+m[pos]+1,mm))%MOD; } inline void MAIN () { read(n),read(a),read(b); for (register int i=1; i&lt;=n; ++i) mul*=i; for (register int i=1; i&lt;=n; ++i) read(m[i]); write(((dfs(1,1,0,b)-dfs(1,1,0,a-1))%MOD+MOD)%MOD); } #undef int } int main () { // freopen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d22100628910c5efe2037530c6ff82a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0685133b6dae4eaecb6f29ae5e12332/" rel="bookmark">
			查询SQL SERVER 数据库版本号脚本语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库直接执行此语句即可
select @@version
示例：
Microsoft SQL Server 2014 - 12.0.2000.8 (X64) Feb 20 2014 20:04:26 Copyright (c) Microsoft Corporation Enterprise Edition (64-bit) on Windows NT 6.1 &lt;X64&gt; (Build 7601: Service Pack 1) 转载于:https://www.cnblogs.com/since-1995/p/11587109.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e93d429a11ad0a0b0dc2982952be831b/" rel="bookmark">
			配置mysql ODBC驅動(mysql-connector-odbc-5.1.13版本)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统：windows 2008 64位
数据版本：SQL server 2008
注：如果在ODBC中創建的用戶DSN可能在MS SQL無法調用，這時候可以在系統DSN中創建，然後用管理員賬號進入MS SQL創建連接服務器，如果MS SQL其他賬號也要用到該連接服務器那麼可以在鏈接服務器屬性-》安全性-》添加對應的MSSQL賬號
配置步骤：
第一步：安装Microsoft Visual C++ 2010，mysql ODBC驱动版本不同需要安装VS运行库也是不同的。
下载地址32X：https://www.microsoft.com/zh-TW/download/details.aspx?id=5555
下载地址64X：https://www.microsoft.com/zh-TW/download/details.aspx?id=14632
第二步：安装mysql-connector-odbc-5.1.13，一直next，下载地址：https://dev.mysql.com/downloads/connector/odbc/
第三步：配置ODBC驱动 （1）、点击添加
（2）、选择安装的MySQL ODBC驱动，点击完成
（3）、配置数据源
1、这是数据源名称可以用于SQL server中创建链接服务器，可以使MySQL和Server SQL之间做交互
2、点击测试可以判断配置是否成功，提示Connection successful 证明配置成功
第四步：在SQLserver中配置对MySQL的link
（1）、右键服务器对象选择新建链接服务器 （2）、数据源处填写刚刚创建ODBC数据源名称，配置完成点击确认
、
第五步：在SQL server操作MySQL的操作示例：
select * from openquery(KQ130,'SELECT NG_ID FROM SYS_USER') update co set co.NG_ID=999 from openquery(KQ130,'SELECT NG_ID FROM SYS_USER ') co where co.NG_ID=666 INSERT INTO openquery(KQ130,'SELECT NG_ID FROM SYS_USER ')(NG_ID)VALUES('6666') 有個奇怪的現象：在MS SQL2008以下可以直接用KQ130...SYS_USER直接進行增刪改查
在MS SQL2008R2以上無法直接使用KQ130...SYS_USER只能通過openquery
是MS SQL版本升級捨去了KQ130...SYS_USER的形式？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e93d429a11ad0a0b0dc2982952be831b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c95be4450abefb0b1e82af8a838f720b/" rel="bookmark">
			Caused by: java.lang.IllegalArgumentException: WebView cannot be used with device protected storage
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前两天我们的应用要集成到手机里作为系统应用添加了如下属性
android:directBootAware="true" android:defaultToDeviceProtectedStorage="true" 然后打开webview就报错如下；
java.lang.RuntimeException: Unable to start activity ComponentInfo{-------}: android.view.InflateException: Binary XML file line #14: Binary XML file line #14: Error inflating class android.webkit.WebView --- Caused by: android.view.InflateException: Binary XML file line #14: Binary XML file line #14: Error inflating class android.webkit.WebView 09-25 15:12:44.364 25765 25765 E AndroidRuntime: Caused by: android.view.InflateException: Binary XML file line #14: Error inflating class android.webkit.WebView 09-25 15:12:44.364 25765 25765 E AndroidRuntime: Caused by: java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c95be4450abefb0b1e82af8a838f720b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc8111e95d0f552285142dd82c584b36/" rel="bookmark">
			sql  题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、用一条sql查询出每门课都大于80分的学生姓名
SELECT S.name FROM Student S GROUP BY S.name Having MIN(S.score)&gt;=80 转载于:https://www.cnblogs.com/jiayu123/p/11379001.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8773d7a0905f91f8f353f73b33edee4e/" rel="bookmark">
			（一）初识Mybatis-Plus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mybatis-plus愿景：
我们的愿景是成为 MyBatis 最好的搭档，就像 魂斗罗 中的 1P、2P，基友搭配，效率翻倍。
前言： mybatis在持久层框架中还是比较火的，使用也很方便。虽然mybatis可以直接在xml中通过SQL语句操作数据库，很是灵活。但正其操作都要通过SQL语句进行，就必须写大量的xml文件，很是麻烦。
mybatis-plus就很好的解决了这个问题。
一、mybatis-plus简介： Mybatis-Plus（简称MP）是一个 Mybatis 的增强工具，在 Mybatis 的基础上只做增强不做改变，为简化开发、提高效率而生。这是官方给的定义，关于mybatis-plus的更多介绍及特性，可以参考mybatis-plus官网。那么它是如何增强的呢？其实就是它已经封装好了一些crud方法，我们不需要再写xml了，直接调用这些方法就行，就类似于JPA。
二、特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer2005、SQLServer 等多种数据库内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 三、框架结构 官网：https://mybatis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8773d7a0905f91f8f353f73b33edee4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8b76c913514517b847220fad34dbedf/" rel="bookmark">
			LaTeX公式与MathType公式的快速互相转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 LaTeX公式与MathType公式的快速互相转换 abstract1. LaTeX在线公式编辑器：2. MathType公式编辑器：3. MathType公式转LaTex公式：3.1 例：MathType公式转LaTex公式 4. LaTex公式转MathType公式：4.1 例LaTex公式转MathType公式 abstract 声明：本文只为我闲暇时候学习所做笔记，仅供我无聊时复习所用，若文中有错，误导了读者，敬请谅解！！！
1. LaTeX在线公式编辑器： http://latex.91maths.com/https://private.codecogs.com/latex/eqneditor.php?lang=zh-cn
2. MathType公式编辑器： http://www.zdfans.com/html/21546.html
3. MathType公式转LaTex公式： 在Word文档中选中用MathType编辑的公式，按住“Alt+\”键，可以将 MathType 公式快速转换成 LaTex 格式。
3.1 例：MathType公式转LaTex公式 选中word中MathType编辑的公式 按下快捷键：Alt+\当前选中的公式即可变为了LaTeX的公式，只是在公式的两边各多了一个$符号 打开在线LaTeX公式编辑器 将word里$$中间的代码粘贴到在线LaTeX公式编辑器中，即可看到LaTeX的公式 4. LaTex公式转MathType公式： 将Latex格式的公式代码复制到 Word 中，前后分别加上“$”符号，按下“Alt+\”键，就将公式切换成MathType 格式。
4.1 例LaTex公式转MathType公式 在LaTeX在线公式编辑器中写好LaTeX公式代码，复制到剪切板 打开word，在word中输入一对$$符号 将LaTeX公式代码粘贴到$$的中间 4.选中整个公式代码块，按下Alt+&lt;br /&gt;
LaTeX公式即刻转换成为MathType格式的公式 双击公式即可在MathType中打开公式进行编辑 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89dc6c6f28a910b04eb63acaad02f67c/" rel="bookmark">
			VM快照设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VM快照设置 VM快照相当于新建一个备份，在需要的时候可以还原到之前的时间点
1.通过快照中的拍摄快照来新建一个快照
2.所拍摄的快照都存放在快照管理器中。
3.通过选中所拍摄的快照来进行还原到之前的拍摄快照的位置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69f6ebf04f279f3685f45a2f2eacad2d/" rel="bookmark">
			神奇的SQL之层级 →为什么 GROUP BY 之后不能直接引用原表中的列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GROUP BY 后 SELECT 列的限制
标准 SQL 规定，在对表进行聚合查询的时候，只能在 SELECT 子句中写下面 3 种内容：通过 GROUP BY 子句指定的聚合键、聚合函数(SUM 、AVG 等)、常量。我们来看个例子
我们有 学生班级表(tbl_student_class) 以及 数据如下 ：
DROP TABLE IF EXISTS tbl_student_class;
CREATE TABLE tbl_student_class (
id int(8) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增主键',
sno varchar(12) NOT NULL COMMENT '学号',
cno varchar(5) NOT NULL COMMENT '班级号',
cname varchar(20) NOT NULL COMMENT '班级名',
PRIMARY KEY (id)
) COMMENT='学生班级表';
-- ----------------------------
-- Records of tbl_student_class
-- ----------------------------
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69f6ebf04f279f3685f45a2f2eacad2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7b83fe501050fbdaa59fc2a0d0eb751/" rel="bookmark">
			【转载】配置jupyter notebook，更改默认路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 版权声明：本文为CSDN博主「章遇小姐姐」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 第一次打开anaconda中自带的jupyter notebook，默认路径都是C:\Users\Admin(自己的用户名)，需要更换成自己的工作路径。虽然网上很多此类文章，可多数只讲了一部分，需要翻很多文章才能看懂，我把所有需要注意的步骤放在一起，查遗补漏就知道自己缺在哪一步了。
先看下修改之后三种不同方式打开jupyter notebook的结果。
1、从左下角程序快捷启动
2、从cmd启动
3、从D盘安装的scripts文件夹中启动程序
我们一步步来看下配置jupyter notebook全步骤。
1、新建一个jupyter-notebook的文件夹
操作的目的是以后启动jupyter notebook打开的都是这个文件夹。
我的操作：我在E盘新建文件夹”jupyter-notebook“，路径位E:\jupyter-notebook
2、生成jupyter_notebook_config.py文件
流程：打开调出命令提示符cmd → 输入“jupyter notebook --generate-config”（注意没有引号）生成文件，打开C盘下jupyter文件夹查看是否生成成功，
我的操作：在C:\Users\Administrator.jupyter下没有生成之前只有一个migrated文件。
3、接步骤2，修改config路径
打开刚生成的jupyter_notebook_config.py文件，找到这一行#c.NotebookApp.notebook_dir = ’ '，将步骤1生成的路径添加上去，c.NotebookApp.notebook_dir = ‘(自己的路径)’，注意一定要去掉前面的#。
我的操作：将214行 #c.NotebookApp.notebook_dir = ’ ’ 修改为 c.NotebookApp.notebook_dir = ‘E:\jupyter-notebook’。
4、添加环境变量
操作流程（以win10为例）：此电脑→右键→属性→更改设置→高级→环境变量→双击path→新建→ 将安装anaconda路径下的Scripts路径复制过来(这是jupyter-notebook.exe的路径。
我的操作： 比如我的是路径D:\install\anaconda\Scripts
5、修改开始菜单中Jupyter Notebook的快捷方式
操作流程（以win10为例）：程序→Anaconda→ Jupyter Notebook→ 右键→ 属性→ 快捷方式→ 去掉“目标”一项中后面的" %USERPROFILE%" 。
我的操作
好了，对照以上5步，检查下自己的路径是否配置正确，是不是也不再跳出“Jupyter不是内部或外部命令也不是可运行的程序或批处理 ”的提示了。
&lt;/div&gt; &lt;link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-095d4a0b23.css" rel="stylesheet"&gt; &lt;/div&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8800956319185b67333ac04080fe04d6/" rel="bookmark">
			css布局 三个按钮一排显示如何居中对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 将div的css设置为text-align:center;就可以了 &lt;div style="width: 100%;height: 100px;background-color: darkblue;text-align:center;"&gt; &lt;button style="width: 200px;"&gt;1&lt;/button&gt; &lt;button style="width:200px;"&gt;2&lt;/button&gt; &lt;button style="width:200px;"&gt;3&lt;/button&gt; &lt;/div&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f37fc1bb12ff3a06881252cca7eed0c/" rel="bookmark">
			深度学习模型压缩方法综述（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 深度学习模型压缩方法综述（一） 深度学习模型压缩方法综述（二） 深度学习模型压缩方法综述（三）
前言 在前两章，我们介绍了一些在已有的深度学习模型的基础上，直接对其进行压缩的方法，包括核的稀疏化，和模型的裁剪两个方面的内容，其中核的稀疏化可能需要一些稀疏计算库的支持，其加速的效果可能受到带宽、稀疏度等很多因素的制约；而模型的裁剪方法则比较简单明了，直接在原有的模型上剔除掉不重要的filter，虽然这种压缩方式比较粗糙，但是神经网络的自适应能力很强，加上大的模型往往冗余比较多，将一些参数剔除之后，通过一些retraining的手段可以将由剔除参数而降低的性能恢复回来，因此只需要挑选一种合适的裁剪手段以及retraining方式，就能够有效的在已有模型的基础上对其进行很大程度的压缩，是目前使用最普遍的方法。然而除了这两种方法以外，本文还将为大家介绍另外两种方法：基于教师——学生网络、以及精细模型设计的方法。
基于教师——学生网络的方法 基于教师——学生网络的方法，属于迁移学习的一种。迁移学习也就是将一个模型的性能迁移到另一个模型上，而对于教师——学生网络，教师网络往往是一个更加复杂的网络，具有非常好的性能和泛化能力，可以用这个网络来作为一个soft target来指导另外一个更加简单的学生网络来学习，使得更加简单、参数运算量更少的学生模型也能够具有和教师网络相近的性能，也算是一种模型压缩的方式。
Distilling the Knowledge in a Neural Network 论文地址 较大、较复杂的网络虽然通常具有很好的性能，但是也存在很多的冗余信息，因此运算量以及资源的消耗都非常多。而所谓的Distilling就是将复杂网络中的有用信息提取出来迁移到一个更小的网络上，这样学习来的小网络可以具备和大的复杂网络想接近的性能效果，并且也大大的节省了计算资源。这个复杂的网络可以看成一个教师，而小的网络则可以看成是一个学生。 这个复杂的网络是提前训练好具有很好性能的网络，学生网络的训练含有两个目标：一个是hard target，即原始的目标函数，为小模型的类别概率输出与label真值的交叉熵；另一个为soft target，为小模型的类别概率输出与大模型的类别概率输出的交叉熵，在soft target中，概率输出的公式调整如下，这样当T值很大时，可以产生一个类别概率分布较缓和的输出： 作者认为，由于soft target具有更高的熵，它能比hard target提供更加多的信息，因此可以使用较少的数据以及较大的学习率。将hard和soft的target通过加权平均来作为学生网络的目标函数，soft target所占的权重更大一些。 作者同时还指出，T值取一个中间值时，效果更好，而soft target所分配的权重应该为T^2，hard target的权重为1。 这样训练得到的小模型也就具有与复杂模型近似的性能效果，但是复杂度和计算量却要小很多。 对于distilling而言，复杂模型的作用事实上是为了提高label包含的信息量。通过这种方法，可以把模型压缩到一个非常小的规模。模型压缩对模型的准确率没有造成太大影响，而且还可以应付部分信息缺失的情况。
Paying More Attention to Attention: Improving the Performance of Convolutional Neural Networks via Attention Transfer 论文地址 作者借鉴Distilling的思想，使用复杂网络中能够提供视觉相关位置信息的Attention map来监督小网络的学习，并且结合了低、中、高三个层次的特征，示意图如下： 教师网络从三个层次的Attention Transfer对学生网络进行监督。其中三个层次对应了ResNet中三组Residual Block的输出。在其他网络中可以借鉴。 这三个层次的Attention Transfer基于Activation，Activation Attention为feature map在各个通道上的值求和，基于Activation的Attention Transfer的损失函数如下： 其中Qs和Qt分别是学生网络和教师网络在不同层次的Activation向量，作者提出在这里在这里对Q进行标准化对于学生网络的训练非常重要。 除了基于Activation的Attention Transfer，作者还提出了一种Gradient Attention，它的损失函数如下： 但是就需要两次反向传播的过程，实现起来较困难并且效果提升不明显。 基于Activation的Attention Transfer效果较好，而且可以和Hinton的Distilling结合。 目前已有基于Activation的实现源码：https://github.com/szagoruyko/attention-transfer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f37fc1bb12ff3a06881252cca7eed0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bbb7f6a1340123c6870f06c75e9dfe7/" rel="bookmark">
			深度学习模型压缩方法综述（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 深度学习模型压缩方法综述（一） 深度学习模型压缩方法综述（二） 深度学习模型压缩方法综述（三）
前言 上一章，将基于核的稀疏化方法的模型压缩方法进行了介绍，提出了几篇值得大家去学习的论文，本章，将继续对深度学习模型压缩方法进行介绍，主要介绍的方向为基于模型裁剪的方法，由于本人主要研究的为这个方向，故本次推荐的论文数量较多，但都是非常值得一读的。
基于模型裁剪的方法 对以训练好的模型进行裁剪的方法，是目前模型压缩中使用最多的方法，通常是寻找一种有效的评判手段，来判断参数的重要性，将不重要的connection或者filter进行裁剪来减少模型的冗余。同样也分为regular和irregular的方式。 这类方法最多，下面列举几篇典型的方案。
Pruning Filters for Efficient Convnets 论文地址 作者提出了基于量级的裁剪方式，用weight值的大小来评判其重要性，对于一个filter，其中所有weight的绝对值求和，来作为该filter的评价指标，将一层中值低的filter裁掉，可以有效的降低模型的复杂度并且不会给模型的性能带来很大的损失，算法流程如下： 裁剪方式如下： 对于ResNet之类的网络： 作者在裁剪的时候同样会考虑每一层对裁剪的敏感程度，作者会单独裁剪每一层来看裁剪后的准确率。对于裁剪较敏感的层，作者使用更小的裁剪力度，或者跳过这些层不进行裁剪。目前这种方法是实现起来较为简单的，并且也是非常有效的，它的思路非常简单，就是认为参数越小则越不重要。
Network Trimming: A Data-Driven Neuron Pruning Approach towards Efficient Deep Architectures 论文地址 作者认为，在大型的深度学习网络中，大部分的神经元的激活都是趋向于零的，而这些激活为0的神经元是冗余的，将它们剔除可以大大降低模型的大小和运算量，而不会对模型的性能造成影响，于是作者定义了一个量APoZ（Average Percentage of Zeros）来衡量每一个filter中激活为0的值的数量，来作为评价一个filter是否重要的标准。APoZ定义如下： 作者发现在VGG-16中，有631个filter的APoZ超过了90%，也就说明了网络中存在大量的冗余。作者的裁剪方式如下： 但是作者仅在最后一个卷积层和全连接层上进行了实验，因此该方法在实际中的效果很难保证。
An Entropy-based Pruning Method for CNN Compression 论文地址 作者认为通过weight值的大小很难判定filter的重要性，通过这个来裁剪的话有可能裁掉一些有用的filter。因此作者提出了一种基于熵值的裁剪方式，利用熵值来判定filter的重要性。 作者将每一层的输出通过一个Global average Pooling将feature map转换为一个长度为c（filter数量）的向量，对于n张图像可以得到一个n*c的矩阵，对于每一个filter，将它分为m个bin，统计每个bin的概率，然后计算它的熵值 利用熵值来判定filter的重要性，再对不重要的filter进行裁剪。第j个feature map熵值的计算方式如下： 在retrain中，作者使用了这样的策略，即每裁剪完一层，通过少数几个迭代来恢复部分的性能，当所有层都裁剪完之后，再通过较多的迭代来恢复整体的性能，作者提出，在每一层裁剪过后只使用很少的训练步骤来恢复性能，能够有效的避免模型进入到局部最优。作者将自己的retrain方式与传统的finetuning方式进行比较，发现作者的方法能够有效的减少retrain的步骤，并也能达到不错的效果。 在VGG16上作者的裁剪方式和结果如下，由于作者考虑VGG-16全连接层所占的参数量太大，因此使用GAP的方式来降低计算量： Designing Energy-Efficient Convolutional Neural Networks using Energy-Aware Pruning 论文地址 这篇文章也是今天的CVPR，作者认为以往的裁剪方法，都没有考虑到模型的带宽以及能量的消耗，因此无法从能量利用率上最大限度的裁剪模型，因此提出了一种基于能量效率的裁剪方式。 作者指出一个模型中的能量消耗包含两个部分，一部分是计算的能耗，一部分是数据转移的能耗，在作者之前的一片论文中（与NVIDIA合作，Eyeriss），提出了一种估计硬件能耗的工具，能够对模型的每一层计算它们的能量消耗。然后将每一层的能量消耗从大到小排序，对能耗大的层优先进行裁剪，这样能够最大限度的降低模型的能耗，对于需要裁剪的层，根据weight的大小来选择不重要的进行裁剪，同样的作者也考虑到不正确的裁剪，因此将裁剪后模型损失最大的weight保留下来。 每裁剪完一层后，对于该层进行locally的fine-tune，locally的fine-tune，是在每一层的filter上，使用最小二乘优化的方法来使裁剪后的filter调整到使得输出与原始输出尽可能的接近。在所有层都裁剪完毕后，再通过一个global的finetuning来恢复整体的性能。整个流程如下： 作者从能耗的角度对层的裁剪程度进行分析，经过裁剪后，模型的能耗压缩较大： Coarse Pruning of Convolutional Neural Networks with Random Masks 论文地址 此文的方法比较有意思，作者认为，既然我无法直观上的判定filter的重要性，那么就采取一种随机裁剪的方式，然后对于每一种随机方式统计模型的性能，来确定局部最优的裁剪方式。 这种随机裁剪方式类似于一个随机mask，假设有M个潜在的可裁剪weight，那么一共就有2^M个随机mask。假设裁剪比例为a，那么每层就会随机选取ML*a个filter，一共随机选取N组组合，然后对于这N组组合，统计裁剪掉它们之后模型的性能，然后选取性能最高的那组作为局部最优的裁剪方式。 算法流程如下： 作者同样将这种裁剪方式运用在kernel上，对kernel进行裁剪，并将filter级和kernel级的裁剪进行组合，得到了较好的结果。 方法简单粗暴，看起来也比较有效，没有考虑每一层对于裁剪的敏感性，也没有评价参数的重要性，可能需要尝试多个mask才能得到较好的结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bbb7f6a1340123c6870f06c75e9dfe7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35c8d6af6e90dc3d1cea6f19572a55e9/" rel="bookmark">
			深度学习模型压缩方法综述（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/wspba/article/details/75671573 深度学习模型压缩方法综述（一） 深度学习模型压缩方法综述（二） 深度学习模型压缩方法综述（三）
前言 目前在深度学习领域分类两个派别，一派为学院派，研究强大、复杂的模型网络和实验方法，为了追求更高的性能；另一派为工程派，旨在将算法更稳定、高效的落地在硬件平台上，效率是其追求的目标。复杂的模型固然具有更好的性能，但是高额的存储空间、计算资源消耗是使其难以有效的应用在各硬件平台上的重要原因。
最近正好在关注有关深度学习模型压缩的方法，发现目前已有越来越多关于模型压缩方法的研究，从理论研究到平台实现，取得了非常大的进展。
2015年，Han发表的Deep Compression是一篇对于模型压缩方法的综述型文章，将裁剪、权值共享和量化、编码等方式运用在模型压缩上，取得了非常好的效果，作为ICLR2016的best paper，也引起了模型压缩方法研究的热潮。其实模型压缩最早可以追溯到1989年，Lecun老爷子的那篇Optimal Brain Damage（OBD）就提出来，可以将网络中不重要的参数剔除，达到压缩尺寸的作用，想想就可怕，那时候连个深度网络都训练不出来，更没有现在这么发达的技术，Lecun就已经想好怎么做裁剪了，真是有先见之明，目前很多裁剪方案，都是基于老爷子的OBD方法。
目前深度学习模型压缩方法的研究主要可以分为以下几个方向： 更精细模型的设计，目前的很多网络都具有模块化的设计，在深度和宽度上都很大，这也造成了参数的冗余很多，因此有很多关于模型设计的研究，如SqueezeNet、MobileNet等，使用更加细致、高效的模型设计，能够很大程度的减少模型尺寸，并且也具有不错的性能。 模型裁剪，结构复杂的网络具有非常好的性能，其参数也存在冗余，因此对于已训练好的模型网络，可以寻找一种有效的评判手段，将不重要的connection或者filter进行裁剪来减少模型的冗余。 核的稀疏化，在训练过程中，对权重的更新进行诱导，使其更加稀疏，对于稀疏矩阵，可以使用更加紧致的存储方式，如CSC，但是使用稀疏矩阵操作在硬件平台上运算效率不高，容易受到带宽的影响，因此加速并不明显。 除此之外，量化、Low-rank分解、迁移学习等方法也有很多研究，并在模型压缩中起到了非常好的效果。
基于核的稀疏化方法 核的稀疏化，是在训练过程中，对权重的更新加以正则项进行诱导，使其更加稀疏，使大部分的权值都为0。核的稀疏化方法分为regular和irregular，regular的稀疏化后，裁剪起来更加容易，尤其是对im2col的矩阵操作，效率更高；而irregular的稀疏化后，参数需要特定的存储方式，或者需要平台上稀疏矩阵操作库的支持，可以参考的论文有：
Learning Structured Sparsity in Deep Neural Networks 论文地址 本文作者提出了一种Structured Sparsity Learning的学习方式，能够学习一个稀疏的结构来降低计算消耗，所学到的结构性稀疏化能够有效的在硬件上进行加速。 传统非结构化的随机稀疏化会带来不规则的内存访问，因此在GPU等硬件平台上无法有效的进行加速。 作者在网络的目标函数上增加了group lasso的限制项，可以实现filter级与channel级以及shape级稀疏化。所有稀疏化的操作都是基于下面的loss func进行的，其中Rg为group lasso： 则filter-channel wise： 而shape wise： 由于在GEMM中将weight tensor拉成matrix的结构，因此可以通过将filter级与shape级的稀疏化进行结合来将2D矩阵的行和列稀疏化，再分别在矩阵的行和列上裁剪掉剔除全为0的值可以来降低矩阵的维度从而提升模型的运算效率。该方法是regular的方法，压缩粒度较粗，可以适用于各种现成的算法库，但是训练的收敛性和优化难度不确定。作者的源码为：https://github.com/wenwei202/caffe/tree/scnn
Dynamic Network Surgery for Efficient DNNs 论文地址 作者提出了一种动态的模型裁剪方法，包括以下两个过程：pruning和splicing，其中pruning就是将认为不中要的weight裁掉，但是往往无法直观的判断哪些weight是否重要，因此在这里增加了一个splicing的过程，将哪些重要的被裁掉的weight再恢复回来，类似于一种外科手术的过程，将重要的结构修补回来，它的算法如下： 作者通过在W上增加一个T来实现，T为一个2值矩阵，起到的相当于一个mask的功能，当某个位置为1时，将该位置的weight保留，为0时，裁剪。在训练过程中通过一个可学习mask将weight中真正不重要的值剔除，从而使得weight变稀疏。由于在删除一些网络的连接，会导致网络其他连接的重要性发生改变，所以通过优化最小损失函数来训练删除后的网络比较合适。 优化问题表达如下： 参数迭代如下： 其中用于表示网络连接的重要性 h 函数定义如下： 该算法采取了剪枝与嫁接相结合、训练与压缩相同步的策略完成网络压缩任务。通过网络嫁接操作的引入，避免了错误剪枝所造成的性能损失，从而在实际操作中更好地逼近网络压缩的理论极限。属于irregular的方式，但是ak和bk的值在不同的模型以及不同的层中无法确定，并且容易受到稀疏矩阵算法库以及带宽的限制。论文源码：https://github.com/yiwenguo/Dynamic-Network-Surgery
Training Skinny Deep Neural Networks with Iterative Hard Thresholding Methods 论文地址 作者想通过训练一个稀疏度高的网络来降低模型的运算量，通过在网络的损失函数中增加一个关于W的L0范式可以降低W的稀疏度，但是L0范式就导致这是一个N-P难题，是一个难优化求解问题，因此作者从另一个思路来训练这个稀疏化的网络。算法的流程如下： 先正常训练网络s1轮，然后Ok(W)表示选出W中数值最大的k个数，而将剩下的值置为0，supp(W,k)表示W中最大的k个值的序号，继续训练s2轮，仅更新非0的W，然后再将之前置为0的W放开进行更新，继续训练s1轮，这样反复直至训练完毕。 同样也是对参数进行诱导的方式，边训练边裁剪，先将认为不重要的值裁掉，再通过一个restore的过程将重要却被误裁的参数恢复回来。也是属于irregular的方式，边训边裁，性能不错，压缩的力度难以保证。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35c8d6af6e90dc3d1cea6f19572a55e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/781afc7e95df2868691c7a241844110b/" rel="bookmark">
			使用 ajax 多次请求，并将结果集合并（ajax 非异步）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上代码吧... 里面有注释
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="js/jquery-3.4.1.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; (function() { var data = {stuId:'4231'}; var list = []; getInfo(function(data,obj){ // 第一次查询没有数据或者条数不满足3条数据,进行参数分割 if( data ){ list.push(data); }else{ // 参数分割 var stuIds = obj.stuId.split(""); // 循环请求获取数据 for (var i = 0; i &lt; stuIds.length; i++) { // 参数对象 var obj = {stuId: stuIds[i]}; //先判断 list 是否的条数 是否满足条件 if( list.length &gt;= 2 ){ // 中止请求 break; //throw Error("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/781afc7e95df2868691c7a241844110b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d92a1c2234d1994229c1d723ea8696b8/" rel="bookmark">
			修改pycharm的运行内存避免循环运行python导致内存不足
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编辑PyCharm安装目录下PyCharm 4.5.3\bin下的pycharm.exe.vmoptions文件， 如下
-Xms128m
-Xmx768m
-XX:ReservedCodeCacheSize=240m
-XX:+UseConcMarkSweepGC
-XX:SoftRefLRUPolicyMSPerMB=50
-ea
-Dsun.io.useCanonCaches=false
-Djava.net.preferIPv4Stack=true
-XX:+HeapDumpOnOutOfMemoryError
-XX:-OmitStackTraceInFastThrow
-Xms 和 -Xmx是java 命令的一个选项，用来设置你的应用程序启动时的可用内存大小和运行时的可用的内存大小。 修改 -Xms为 256m -Xmx为 2048m 修改后设置为：
-Xms256m
-Xmx2048m
-XX:ReservedCodeCacheSize=240m
-XX:+UseConcMarkSweepGC
-XX:SoftRefLRUPolicyMSPerMB=50
-ea
-Dsun.io.useCanonCaches=false
-Djava.net.preferIPv4Stack=true
-XX:+HeapDumpOnOutOfMemoryError
-XX:-OmitStackTraceInFastThrow
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29f4bb0907de2772fd93dbf746de27fe/" rel="bookmark">
			Qt 的新建步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt：“新建” 步骤：
首先：在“欢迎”的栏有New Project 点击 或者
点击“文件” 在第二栏点击“新建我呢间或项目（N）”（或者 直接使用快捷键“Ctrl + N”）
选择：“Application” --&gt; Qt Widgets Application 在 名称 上 写项目的名（最好以英文形式）
路径中可以放在c盘，d盘，e盘，，但路径中决不允许有“中文”，路径必须以 英文 的形式
编译器：在这里，因为只装了Qt的编译器，没有装安卓的编译器，所以只会显示这一个编译器
MainWindow：PC端使用，带菜单栏（Window端）；QWidget：图形画面控件的一个基类；QDialog：对话框
最常用的是：QWidget
将创建界面的对勾取消，（在刚接触时，用不到界面）
最后点击“完成”
① ：编译并运行
②：编译并调试
③：编译不运行
编译的三种方法：
1、点击 ① 2、右击 项目名：点“运行”
3、快捷键：ctrl+r
运行结果为：空白窗口
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f5ab20e5703b42f500b4031d8e8d368/" rel="bookmark">
			FreeSql 访问 Oracle 解决大小写问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一 new FreeSqlBuilder() .UseSyncStructureToUpper(true) .Build() 方法二 全局转换实体属性名方法，这种只能转属性。
其实是通过Aop方法完成的功能，Aop可以对属性名和类名进行全局拦截处理大小写。
new FreeSql.FreeSqlBuilder() .UseEntityPropertyNameConvert(StringConvertType.Upper) .Build()); 现在添加了6种转换类型
public enum StringConvertType { /// &lt;summary&gt; /// 不进行任何处理 /// &lt;/summary&gt; None = 0, /// &lt;summary&gt; /// 将帕斯卡命名字符串转换为下划线分隔字符串 /// &lt;para&gt;&lt;/para&gt; /// BigApple -&gt; Big_Apple /// &lt;/summary&gt; PascalCaseToUnderscore, /// &lt;summary&gt; /// 将帕斯卡命名字符串转换为下划线分隔字符串，且转换为全大写 /// &lt;para&gt;&lt;/para&gt; /// BigApple -&gt; BIG_APPLE /// &lt;/summary&gt; PascalCaseToUnderscoreWithUpper, /// &lt;summary&gt; /// 将帕斯卡命名字符串转换为下划线分隔字符串，且转换为全小写 /// &lt;para&gt;&lt;/para&gt; /// BigApple -&gt; big_apple /// &lt;/summary&gt; PascalCaseToUnderscoreWithLower, /// &lt;summary&gt; /// 将字符串转换为大写 /// &lt;para&gt;&lt;/para&gt; /// BigApple -&gt; BIGAPPLE /// &lt;/summary&gt; Upper, /// &lt;summary&gt; /// 将字符串转换为小写 /// &lt;para&gt;&lt;/para&gt; /// BigApple -&gt; bigapple /// &lt;/summary&gt; Lower } 注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f5ab20e5703b42f500b4031d8e8d368/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fbc41a25b0fa71f00feb1f7aad5f2b4/" rel="bookmark">
			一条超级简单的故意让linux死机/宕机的命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近因为测试需要，需要观察机器在死机状态下其它外设的反应，学习到了一条超级简单的能让Linux瞬间死机的命令：
echo c &gt; /proc/sysrq-trigger
运行后效果如下：
可以看到，一旦运行后，系统立马死机。
原来，这是linux /proc/sysrq-trigger的强大机制：
# 立即重新启动计算机
echo b &gt; /proc/sysrq-trigger
# 立即关闭计算机
echo o &gt; /proc/sysrq-trigger
# 导出内存分配的信息 （可以用/var/log/message 查看）
echo m &gt; /proc/sysrq-trigger
# 导出当前CPU寄存器信息和标志位的信息
echo p &gt; /proc/sysrq-trigger
# 导出线程状态信息
echo t &gt; /proc/sysrq-trigger
# 故意让系统崩溃
echo c &gt; /proc/sysrq-trigger
# 立即重新挂载所有的文件系统 echo s &gt; /proc/sysrq-trigger
# 立即重新挂载所有的文件系统为只读
echo u &gt; /proc/sysrq-trigger
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d59929d283ee36fcc0f439c4c2fcfca/" rel="bookmark">
			计算机网络总结：第四章 网络层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四章 网络层 4.1 概述 4.1.1 转发和路由选择 转发（forwarding）：当一个分组到达路由器的一条输入链路时，路由器必须将该分组移动到适当的输出链路路由选择（routing）：当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径连接建立：网络层第三个重要的网络功能
–网络层的连接：一对节点之间的连接，所有属于这个连接的数据包遵循同一条路径
–传输层的连接：进程之间的连接，同一个数据包可能在网络层经不同路径 4.1.2 网络服务模型：定义了分组在发送与接收端系统之间的端到端运输特性 提供的服务
–确保交付
–具有时延上界的确保交付
–有序分组交付
–确保最小带宽
–确保最大时延抖动
–安全性服务两个最重要的ATM服务模型
–恒定比特率
–可用比特率 4.2 虚电路和数据报网络 网络层能在两台主机之间提供无连接服务或连接服务，连接服务以源和目的主机间的握手开始，无连接服务则没有任何握手预备步骤网络层和运输层在面向连接和无连接服务的差异
–在网络层，这些服务是由网络层向运输层提供的主机到主机的服务。在运输层中，这些服务则是运输层向应用层提供的进程到进程的服务
–网络层不能同时提供两种服务（面向连接的、无连接的）。仅在网络层提供连接服务的计算机网络称为虚电路（Virtual-Circuit，VC）网络；仅在网络层提供无连接五福的计算机网络称为数据报（datagram network）网络
–网络层连接服务除了在端系统中，也在位于网络核心的路由器中实现；运输层面向连接服务是在位于网络边缘 4.2.1 虚电路网络 虚电路的组成
–源和目的主机之间的路径
–VC号，沿着该路径的每段链路的一个号码
–沿着该路径的每台路由器的转发表表项虚电路中有3个明显不同的阶段
–虚电路建立
–数据传送
–虚电路拆除 4.2.2 数据报网络 每当一个端系统要发送分组，它就为该分组加上目的端系统的地址，然后将分组推进网络中。当分组从源到目的地传输，它通过一系列路由器传递。这些路由器中的每台都使用分组的目的地址来转发该分组 4.3 路由器工作原理 组成成分：输入端口，交换结构，输出端口，路由选择处理器关键功能：运行路由算法/协议（RIP，OSPF，BGP），将数据报从入链路传到出链路
4.3.1 输入端口 4.3.2 交换结构 经内存交换
–最简单、最早的路由器是传统的计算机，交换是在CPU的直接控制下完成的
–数据包被复制到系统的内存中
–速度受内存带宽限制（2个总线交叉/数据报）经总线交换
–输入端口经一根共享总线将分组直接传送到输出端口
–交换带宽受总线速率的限制经互联网络交换
–克服总线带宽限制
–将数据报分段为固定长度的单元，通过结构切换单元。 4.3.3 输出端口 4.3.4 何处出现排队 4.4 网际协议（IP） 4.4.1 数据包格式 IP数据报分片
–链路层协议能承受的网络层分组长度不同，一个链路层帧能承载的最大数据量叫做最大传送单元（Maximum Transmission Unit，MTU）
–过大的IP数据报会被分成多个较小的数据报（称为fragment，片）
说明：
–ID是初始数据报的标识号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d59929d283ee36fcc0f439c4c2fcfca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a68e19730c9de2cea1448bdc40d5e905/" rel="bookmark">
			java中某个类实例.getClass().getName()取得的类名字，用split(&#34;.&#34;)分割后，获取不到分割后的数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该方法返回类似"xx.xx.xx"的结构
不能直接这样split(".")，需要将点进行转义，转义后：split("\\.")
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4195e771244fa09481207e23900901a/" rel="bookmark">
			图像分割之水平集（Level Set）分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几何活动轮廓模型——水平集分割：Active Contours Without Edges
水平集方法 水平集是跟踪轮廓和表面运动的一种数字化方法，它不直接对轮廓进行操作，而是将轮廓设置成一个高维函数的零水平集。这个高维函数叫做水平集函数。然后对该水平集函数进行微分，通过从输出中提取零水平集来得到运动的轮廓。使用水平集的主要优点是可以对任意复杂的结构进行模式化和拓扑变换。
水平集（Level Set）方法是由Sethian和Osher于1988年提出。简单来说，水平集方法把低维的一些计算上升到更高一维，把N维的描述看成是N+1维的一个水平。比如，一个二维平面的圆，如x2+y2=1，可以看成三维中二元函数f(x,y) = x2+y2的1的水平集。如下图
专业描述：水平集方法将平面闭合曲线隐含地表达为连续函数曲面
几何活动轮廓模型 这里具体介绍2001年的文献《Active Contours Without Edges》，即Chan-Vese模型。作者提出了基于Mumford–Shah分割技术和水平集方法的活动轮廓模型，该模型不依赖边缘函数，即图像梯度。能量函数有fitting项和一些正则项组成。
作者把上面关于曲线C的能量函数写成关于水平集函数ϕ的能量函数，然后求解。
其中Heaviside函数和Delata函数，如下
最后得到水平集函数的迭代公式：
示例演示 下面基于OpenCV实现该算法。完整工程代码。
头文件
/********************************************************************** Copyright (c) Mr.Bin. All rights reserved. For more information visit: http://blog.csdn.net/webzhuce **********************************************************************/ /** * @brief This is a filter that implements Tony F. Chan. Active * Contours Without Edges[J].2001 */ #pragma once #include "opencv2/opencv.hpp" class LevelSet { public: LevelSet(const cv::Mat &amp;src); //initialize level set void initializePhi(cv::Point2f center, float radius); void evolving();	private: int iterationnum_ = 100; float lambda1_ = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4195e771244fa09481207e23900901a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/297103f5c85c65a542aafba303adb34c/" rel="bookmark">
			Java 网络编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、网络编程基础概念 首先理清一个概念：网络编程不等于网站编程，网络编程即使用套接字来达到进程间通信，现在一般称为TCP/IP编程。
计算机网络：
把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大，功能强的网络系统，从而使众多的计算机可以方便的互相传递信息，共享硬件，软件，数据信息等资源。
计算机网络的主要功能：
资源共享信息传输与集中处理均衡负荷与分布处理综合信息服务（www / 综合业务数字网络 ISDN） 计算机网络三高问题： 高并发，高性能，高可用。
计算机网络分类：
局域网城域网广域网互联网等等…
（Local Area Network；LAN） 通常我们常见的“LAN”就是指局域网，这是我们最常见、应用最广的一种网络 二、网络通信协议及接口 网络通信协议：
计算机网络中实现通信必须有一些约定，即通信协议；包括对速率，传输代码，代码结构，传输控制步骤，出错控制等制定的标准。
网络通信接口：
为了使两个节点之间能进行对话，必须在他们之间建立通信工具（即接口），使彼此之间，能进行信息交换。接口包括两部分：
硬件装置：实现结点之间的信息传送
软件装置：规定双方进行通信的约定协议
三、通信协议分层思想 为什么要分层：
由于结点之间联系很复杂，在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常用的复合方式就是层次方式，及同层间可以通信，上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展。
通信协议的分层规定：
把用户应用程序作为最高层，把物理通信线路作为最底层，将其间的协议处理分为若干层，规定每层处理的任务，也规定每层的接口标准。
四、参考模型 五、IP协议 每个人的电脑都有一个独一无二的IP地址，这样互相通信时就不会传错信息了。IP地址是用一个点来分成四段的，在计算机内部IP地址是用四个字节来表示的，一个字节代表一段，每一个字节代表的数最大只能到达255。
InetAddress类 说到IP地址，就要引入一个类：InetAddress
此类表示互联网协议 (IP) 地址。
InetAddress类无构造方法
常用方法摘要
byte[] getAddress()
返回此 InetAddress 对象的原始 IP 地址。
static InetAddress getByName(String host)
在给定主机名的情况下确定主机的 IP 地址。
String getHostAddress()
返回 IP 地址字符串（以文本表现形式）。
String getHostName()
获取此 IP 地址的主机名。
static InetAddress getLocalHost()
返回本地主机。
127.0.0.1：本机地址，主要用于测试。别名：Localhost
案例一
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/297103f5c85c65a542aafba303adb34c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6966f25e887b7a855b8c1f2f673a48c7/" rel="bookmark">
			6张拓扑图揭秘中心化交易所的5种行为, 原来中心化比你想象的重要！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源 | Hackernoon 编译 | 火火酱
责编 | Carol
出品 | 区块链大本营（blockchain_camp） 中心化交易所可以说是加密资产市场中最难分析的部分之一。虽然加密领域中很多参与者的行为都被透明地记录在分布式账本中，但中心化交易所仍然在很大程度上是脱链操作的，只是将活动的子集发布到相应的区块链上。
毫无疑问，中心化交易所会带来一定程度的不透明性，甚至会对最复杂的分析技术造成挑战。
不过，对中心化交易所行为的分析，可以为加密投资者和交易者带来许多有意思的好处。
想象一下，如果你能追踪交易间的大型密码传输，能够预测特定密码资产的大量位置，岂不美哉？然而，所有的这一切都需要了解中心化交易所中的基本模型。
本文作者一直在积极研究真正先进的机器学习模型，帮助我们了解加密领域中包括中心化交易所在内的已知参与者的行为。
尽管机器学习模型已经相当成熟了，但很多时候，我们还是需要依赖以人为中心的数据探索来验证一些结果。
为了应对这一挑战， IntoTheBlock的技术主管 Pablo Biancotto领导实现了一个内部图表浏览器工具，该工具能够将可视化地址、交易所以及区块链内的其他已知实体之间的关系行程拓扑图。
让初学者生动且直观地了解中心化交易所中每天都在发生的优雅的模型。
中心化交易初探
要了解中心化加密交易所行为，需要单独或成组地分析一些关键组件，并且在较高层次上概括一些概念。 以下是几个有关中心化密码交易所行为的关键组件： 热钱包： 热钱包通常是指外部各方参与者和交易所之间的主要沟通方式，可以使用这种钱包来交易加密货币资产。 冷钱包： 冷钱包被看作是一种加密资产安全储存的手段。这类钱包通常会持有大量不打算频繁交易的资产。 存款地址： 通常是指临时的、用于将资金转入交易所的区块链上地址。这类地址主要用途是方便用户兑换现金流。 取款地址： 通常是指临时的、用于从主交易钱包中转移资金的区块链上地址。有时取款地址也可以扮演存款地址的双重角色。 虽然这四个组件代表了中心化交易所链上体系结构的核心，但是要识别它们则需要相当复杂的启发法或机器学习方法。其中有一部分挑战在于这些组件之间的交互模型可能是任意且复杂的，并且不是很好理解。 在IntoTheBlock的交易机器学习分类器的帮助下，区块链数据集的可视化探索揭示了一些十分优雅迷人的模型。 可视化区块链中的密码交易 为了更好地理解中心化密码交易所关键组件的行为，我们首先说明一些突出了它们关键交互模式的可视化组件。 1、存款地址将资金转入交易主钱包 密码交换中的主要模型之一， 是将资金从存款地址转移到交易主钱包中 。下图清楚地说明了该模型，蓝色圆圈表示存款地址，绿色圆圈表示主钱包。需要注意的是，许多个存款地址是如何在单次交易中绑定到主钱包的。 下图表示的是更大范围中的同一模型： 2、主钱包将资金分配到取款地址
中心化交易所中的另一传统模型是将交易发送到取款地址。下图可视化演示了这一模型，橙色圆圈表示取款地址，蓝色圆圈表示主交易钱包。 3、取款地址同时充当存款地址
在某些情况下，取款地址也会充当其他交易的存款地址。该模式的可视化模型如下图。蓝色圆圈表示存款地址，绿色圆圈表示取款地址。 4、交易所间交易
下图表示的是发生在在Poloniex交易所和Binance交易所之间的交易模型： 5、用于提款的共同消费交易
未消费交易输出（UTXO）是存在于比特币、Litecoin或比特币现金等加密货币中的一种重要的模式。从交易所的角度来看，许多交易使用未消费交易输出作为特定交易的输入。 在下面的图中，粉色的小圆圈表示一个未消费输出，与主交易钱包中的资金相结合，以便将资金分配到取款地址。 需要注意的是，另一个未消费交易输出（粉红色的大圆圈）会被分配到一个不同的地址。 正如你看到的那样， 机器学习 和 高级数据可视化 的结合解释了中心化交易所行为中有趣的模型。 有时候，聪明的数 据可视化会激发人类直 觉的魔力，来识别机器学习模型所遗漏的场景。 中心化交易所仍然是加密生态系统的黑匣子之一，但是， 机器学习和数据可视化技术将会一点点地帮助我们揭开它们的秘密。 推荐阅读：
6大思维模型, 揭秘硅谷高管如何做区块链应用决策 计算机简史： 从分布式到中心化的博弈螺旋 幼儿识字从比特币开始? 小哥出了本区块链幼教书, 画风真泥石流… 走出腾讯和阿里，大厂员工转型记
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6966f25e887b7a855b8c1f2f673a48c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d9646a27486f4af3ab183fb44380753/" rel="bookmark">
			c&#43;&#43;复合类型：引用和指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 复合类型指基于其他的类型定义的类型。
引用和指针的相同与不同：
都是实现了对其他对象的间接访问引用不是对象，但是指针就是一个对象，允许对指针赋值和拷贝，而且再指针的生命周期内先后指定几个不同的对象指针无需在定义时赋值，但是最好赋初值。 1.引用
一句话概括一下就是：引用不是对象，是一个已经存在的对象的别名，即就是一个名字。
int ival = 10; int &amp;re_ival = ival; //re_ival指向ival，是ival的另一个名字 int &amp;re_ival; //错误：引用必须被初始化 int re_val = 11; //改变ival的值 引用必须初始化：一旦初始化完成，引用将和它的初始值对象一直绑定在一起，无法重新绑定到另一个对象。
引用只能绑定在对象而不是字面值或者某个表达式的计算结果：
int &amp;re = 10; //错误 double a = 3.2; int &amp;re = a; //错误，此处引用类型的初始值对象必须是int类型 2.指针、
通常指针应该处于下面4中状态之一：
指向一个对象空指针指向紧邻对象所占空间的下一个位置无效指针 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c0102566ace00e3b662b4314d25b7c7/" rel="bookmark">
			一步一步做项目（4）配置SSH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一步一步做项目（4）配置SSH 导入JAR包导入Struts2.5.20库导入Hibernate5.4.4库导入c3p0连接池 导入Spring5.1.9库导入MySQL JDBC驱动器 配置SSHweb.xmlstruts.xmlhibernate.cfg.xmlweb.xml中添加Spring支持applicationContext.xmljdbc.properties 创建SSH项目包结构 在前面一步一步做项目（3）创建Web项目的基础上继续。
导入JAR包 在Project Explorer中，展开项目节点cmis-&gt;WebContent-&gt;WEB-INF-lib上，单击鼠标右键，弹出全局菜单，如下图所示：
选择Import…命令，弹出Import对话框，如下图所示：
导入Struts2.5.20库 展开General，选择File System，点击Next &gt;按钮，继续导入File System，如下图所示：
通过点击Browse…按钮，选择Struts2.5.20所在目录，导入Struts支持库，选择要导入的JAR包，点击Finish，完成导入，如下图所示：
这里添加的struts2-config-browser-plugin包，可以提供浏览器配置支持，在浏览器中，可以在浏览器地址栏输入下面地址来查看Struts2的配置信息。
http://localhost:8080/cmis/config-browser/actionNames.action?namespace=action struts2-spring-plugin包用来整合Spring。
导入Hibernate5.4.4库 选择required最小支持包，如下图所示：
通过点击Browse…按钮，选择Hibernate5.4.4所在目录，导入基本要求的Hibernate支持库，选择required要导入的JAR包，点击Finish，完成导入。
导入c3p0连接池 选择c3p0支持包，以便提供自动回收空闲连接功能，如下图所示：
通过点击Browse…按钮，在Hibernate5.4.4所在目录中找到optional，选择c3p0所在目录，选中要导入的JAR包，点击Finish，完成导入。
导入Spring5.1.9库 选择Spring支持包，如下图所示：
通过点击Browse…按钮，在Spring5.1.9所在目录中找到libs目录，选中要导入的JAR包，点击Finish，完成导入。
这里需要导入以下JAR包：
导入MySQL JDBC驱动器 选择MySQL JDBC驱动器存放目录，如下图所示：
通过点击Browse…按钮，在MySQL JDBC8.0.17所在的目录，选中要导入的JAR包，点击Finish，完成导入。
这里也可以通过项目属性对话框，配置Java Build Path，通过添加Libraries，选择User Libraries，将已经配置好的MySQL JDBC库添加到构建路径上。
配置SSH 导入基本的SSH支持JAR包后，需要进行相关配置文件的设置。
web.xml 在web.xml中，添加Struts2过滤器配置，内容如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" id="WebApp_ID" version="4.0"&gt; &lt;display-name&gt;cmis&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- START Struts2的框架的核心过滤器的配置 --&gt; &lt;filter&gt; &lt;filter-name&gt;action2&lt;/filter-name&gt; &lt;filter-class&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c0102566ace00e3b662b4314d25b7c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ade7faa8d7db025baa272421414a58c6/" rel="bookmark">
			react-native RSA 非对称加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天要介绍的是 RSA非对称加密。 非对称加密分为两个秘钥，公钥和私钥。
关于rsa加密过长的一种解决方案是，先采用MD5加密明文，再对加密后的md5 进行rsa加密。
1.先用openssl生成 公钥和私钥，不会的自己百度。
2. 下面是rn的 rsa 加密步骤：
先添加依赖库：
npm i jsencrypt
然后 加解密代码如下：
import React, {Component} from 'react'; import { Button, StyleSheet, Text, TextInput, View } from 'react-native'; import 'jsencrypt'; // 公钥 const PUB_KEY = 'xxx'; // 私钥 const PRIV_KEY = 'xxx'; export default class Demo extends Component{ constructor(props) { super(props); this.state = { data: '', text: '' } } render(){ return ( &lt;View style={styles.container}&gt; &lt;TextInput onChangeText={(text) =&gt; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ade7faa8d7db025baa272421414a58c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f125917b6b7ae98e5cef79e75a95be7b/" rel="bookmark">
			Python3解leetcode Kth Largest Element in a Stream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.
Your KthLargest class will have a constructor which accepts an integer kand an integer array nums, which contains initial elements from the stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f125917b6b7ae98e5cef79e75a95be7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c21c07a77a74e15ebe7fb3ab8833c55/" rel="bookmark">
			3DES 加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天介绍下对称加密的3DES加密。
3des加密是比较安全的对称加密算法，是3层des加密后的算法。
双方约定好相同的key，以及偏移量iv，加密模式，填充，然后进行加解密。
只有4个变量都相同才能加解密一致，所以安全上来说是比较安全的。
1.加密模式包含：
EBC、CBC、CTR、OFB、CFB
2.填充包含：
pcks5padding、pcks7padding 、zeropadding、iso10126、ansix923
3 key和iv 双方约定就好了。
以下是js的3des加密：
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;title&gt;3des加解密&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;script type="text/javascript" src="3DES.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var str = "15629551180"; document.write("原字符串:&lt;/br&gt;"+str); var key = "sdghjsdhgjhsdkjghioewiouew234231"; //alert(decrypt_3des); var des3en = DES3.encrypt(key,str); document.write("&lt;/br&gt;des3加密后:&lt;/br&gt;"+des3en); document.write("&lt;/br&gt;des3解密后:&lt;/br&gt;"+DES3.decrypt(key,des3en)); &lt;/script&gt; &lt;/body&gt; 3DES.js
/** * DES 加密算法 * * 该函数接受一个 8 字节字符串作为普通 DES 算法的密钥（也就是 64 位，但是算法只使用 56 位），或者接受一个 24 字节字符串作为 3DES * 算法的密钥；第二个参数是要加密或解密的信息字符串；第三个布尔值参数用来说明信息是加密还是解密；接下来的可选参数 mode 如果是 0 表示 ECB * 模式，1 表示 CBC 模式，默认是 ECB 模式；最后一个可选项是一个 8 字节的输入向量字符串（在 ECB 模式下不使用）。返回的密文是字符串。 * * 参数： &lt;br&gt; * key: 8字节字符串作为普通 DES 算法的密钥,或 24 字节字符串作为 3DES &lt;br&gt; * message： 加密或解密的信息字符串&lt;br&gt; * encrypt: 布尔值参数用来说明信息是加密还是解密&lt;br&gt; * mode: 1:CBC模式，0:ECB模式(默认)&lt;br&gt; * iv:&lt;br&gt; * padding: 可选项, 8字节的输入向量字符串（在 ECB 模式下不使用） */ //this takes the key, the message, and whether to encrypt or decrypt function des (key, message, encrypt, mode, iv, padding) { if(encrypt) //如果是加密的话，首先转换编码 message = unescape(encodeURIComponent(message)); //declaring this locally speeds things up a bit var spfunction1 = new Array (0x1010400,0,0x10000,0x1010404,0x1010004,0x10404,0x4,0x10000,0x400,0x1010400,0x1010404,0x400,0x1000404,0x1010004,0x1000000,0x4,0x404,0x1000400,0x1000400,0x10400,0x10400,0x1010000,0x1010000,0x1000404,0x10004,0x1000004,0x1000004,0x10004,0,0x404,0x10404,0x1000000,0x10000,0x1010404,0x4,0x1010000,0x1010400,0x1000000,0x1000000,0x400,0x1010004,0x10000,0x10400,0x1000004,0x400,0x4,0x1000404,0x10404,0x1010404,0x10004,0x1010000,0x1000404,0x1000004,0x404,0x10404,0x1010400,0x404,0x1000400,0x1000400,0,0x10004,0x10400,0,0x1010004); var spfunction2 = new Array (-0x7fef7fe0,-0x7fff8000,0x8000,0x108020,0x100000,0x20,-0x7fefffe0,-0x7fff7fe0,-0x7fffffe0,-0x7fef7fe0,-0x7fef8000,-0x80000000,-0x7fff8000,0x100000,0x20,-0x7fefffe0,0x108000,0x100020,-0x7fff7fe0,0,-0x80000000,0x8000,0x108020,-0x7ff00000,0x100020,-0x7fffffe0,0,0x108000,0x8020,-0x7fef8000,-0x7ff00000,0x8020,0,0x108020,-0x7fefffe0,0x100000,-0x7fff7fe0,-0x7ff00000,-0x7fef8000,0x8000,-0x7ff00000,-0x7fff8000,0x20,-0x7fef7fe0,0x108020,0x20,0x8000,-0x80000000,0x8020,-0x7fef8000,0x100000,-0x7fffffe0,0x100020,-0x7fff7fe0,-0x7fffffe0,0x100020,0x108000,0,-0x7fff8000,0x8020,-0x80000000,-0x7fefffe0,-0x7fef7fe0,0x108000); var spfunction3 = new Array (0x208,0x8020200,0,0x8020008,0x8000200,0,0x20208,0x8000200,0x20008,0x8000008,0x8000008,0x20000,0x8020208,0x20008,0x8020000,0x208,0x8000000,0x8,0x8020200,0x200,0x20200,0x8020000,0x8020008,0x20208,0x8000208,0x20200,0x20000,0x8000208,0x8,0x8020208,0x200,0x8000000,0x8020200,0x8000000,0x20008,0x208,0x20000,0x8020200,0x8000200,0,0x200,0x20008,0x8020208,0x8000200,0x8000008,0x200,0,0x8020008,0x8000208,0x20000,0x8000000,0x8020208,0x8,0x20208,0x20200,0x8000008,0x8020000,0x8000208,0x208,0x8020000,0x20208,0x8,0x8020008,0x20200); var spfunction4 = new Array (0x802001,0x2081,0x2081,0x80,0x802080,0x800081,0x800001,0x2001,0,0x802000,0x802000,0x802081,0x81,0,0x800080,0x800001,0x1,0x2000,0x800000,0x802001,0x80,0x800000,0x2001,0x2080,0x800081,0x1,0x2080,0x800080,0x2000,0x802080,0x802081,0x81,0x800080,0x800001,0x802000,0x802081,0x81,0,0,0x802000,0x2080,0x800080,0x800081,0x1,0x802001,0x2081,0x2081,0x80,0x802081,0x81,0x1,0x2000,0x800001,0x2001,0x802080,0x800081,0x2001,0x2080,0x800000,0x802001,0x80,0x800000,0x2000,0x802080); var spfunction5 = new Array (0x100,0x2080100,0x2080000,0x42000100,0x80000,0x100,0x40000000,0x2080000,0x40080100,0x80000,0x2000100,0x40080100,0x42000100,0x42080000,0x80100,0x40000000,0x2000000,0x40080000,0x40080000,0,0x40000100,0x42080100,0x42080100,0x2000100,0x42080000,0x40000100,0,0x42000000,0x2080100,0x2000000,0x42000000,0x80100,0x80000,0x42000100,0x100,0x2000000,0x40000000,0x2080000,0x42000100,0x40080100,0x2000100,0x40000000,0x42080000,0x2080100,0x40080100,0x100,0x2000000,0x42080000,0x42080100,0x80100,0x42000000,0x42080100,0x2080000,0,0x40080000,0x42000000,0x80100,0x2000100,0x40000100,0x80000,0,0x40080000,0x2080100,0x40000100); var spfunction6 = new Array (0x20000010,0x20400000,0x4000,0x20404010,0x20400000,0x10,0x20404010,0x400000,0x20004000,0x404010,0x400000,0x20000010,0x400010,0x20004000,0x20000000,0x4010,0,0x400010,0x20004010,0x4000,0x404000,0x20004010,0x10,0x20400010,0x20400010,0,0x404010,0x20404000,0x4010,0x404000,0x20404000,0x20000000,0x20004000,0x10,0x20400010,0x404000,0x20404010,0x400000,0x4010,0x20000010,0x400000,0x20004000,0x20000000,0x4010,0x20000010,0x20404010,0x404000,0x20400000,0x404010,0x20404000,0,0x20400010,0x10,0x4000,0x20400000,0x404010,0x4000,0x400010,0x20004010,0,0x20404000,0x20000000,0x400010,0x20004010); var spfunction7 = new Array (0x200000,0x4200002,0x4000802,0,0x800,0x4000802,0x200802,0x4200800,0x4200802,0x200000,0,0x4000002,0x2,0x4000000,0x4200002,0x802,0x4000800,0x200802,0x200002,0x4000800,0x4000002,0x4200000,0x4200800,0x200002,0x4200000,0x800,0x802,0x4200802,0x200800,0x2,0x4000000,0x200800,0x4000000,0x200800,0x200000,0x4000802,0x4000802,0x4200002,0x4200002,0x2,0x200002,0x4000000,0x4000800,0x200000,0x4200800,0x802,0x200802,0x4200800,0x802,0x4000002,0x4200802,0x4200000,0x200800,0,0x2,0x4200802,0,0x200802,0x4200000,0x800,0x4000002,0x4000800,0x800,0x200002); var spfunction8 = new Array (0x10001040,0x1000,0x40000,0x10041040,0x10000000,0x10001040,0x40,0x10000000,0x40040,0x10040000,0x10041040,0x41000,0x10041000,0x41040,0x1000,0x40,0x10040000,0x10000040,0x10001000,0x1040,0x41000,0x40040,0x10040040,0x10041000,0x1040,0,0,0x10040040,0x10000040,0x10001000,0x41040,0x40000,0x41040,0x40000,0x10041000,0x1000,0x40,0x10040040,0x1000,0x41040,0x10001000,0x40,0x10000040,0x10040000,0x10040040,0x10000000,0x40000,0x10001040,0,0x10041040,0x40040,0x10000040,0x10040000,0x10001000,0x10001040,0,0x10041040,0x41000,0x41000,0x1040,0x1040,0x40040,0x10000000,0x10041000); //create the 16 or 48 subkeys we will need var keys = des_createKeys (key); var m=0, i, j, temp, temp2, right1, right2, left, right, looping; var cbcleft, cbcleft2, cbcright, cbcright2 var endloop, loopinc; var len = message.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c21c07a77a74e15ebe7fb3ab8833c55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e686e32b52b1d8b515a1b98404144d5c/" rel="bookmark">
			JDK8：HashMap源码解析：put方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述
Map的put方法接受两个参数，key和value，该方法用于存储键值对。
HashMap的put方法只有一行代码：
return putVal(hash(key), key, value, false, true); //参见：hash方法解析 可知put方法是一个方便用户使用的快捷方式，具体逻辑都是在putVal方法中实现的，我们就针对putVal方法的实现来做解析。
二、方法解析
/** * @param hash key的hash值 * @param key 键 * @param value 值 * @param onlyIfAbsent 设为true表示如果键不存在，才会写入值。 * @param evict * @return 返回value */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 定义元素数组、当前元素变量 // 如果当前Map的元素数组为空 或者 数组长度为0，那么需要初始化元素数组 // tab = resize() 初始化了元素数组，resize方法同时也可以实现数组扩容，可参见：resize方法解析 if ((tab = table) == null || (n = tab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e686e32b52b1d8b515a1b98404144d5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/692f6d960dcf190bab390bf57eeb1f02/" rel="bookmark">
			vscode 编辑器快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码段同时缩进：
选中代码段，按下tab键可以同时时代码缩进。
先按下shift+tab键可以取消缩进，向前移动。
转载于:https://www.cnblogs.com/150536FBB/p/11555744.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/430a0c16c1a576a6b3bd135e2b5ac51a/" rel="bookmark">
			Python3解leetcode Count Binary Substrings
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.
Substrings that occur multiple times are counted the number of times they occur.
Example 1:
Input: "00110011" Output: 6 Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/430a0c16c1a576a6b3bd135e2b5ac51a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa1b366b84cc914c90a6f8176f8cd93/" rel="bookmark">
			HTML插入的视频怎么居中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先，打开html编辑器，新建html文件，例如：index.html，编写问题基础代码。
2、在index.html中的标签中，添加样式代码：style=“text-align: center;”。
3、浏览器运行index.html页面，此时插入的视频被居中了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cb424ffda3a0da45826f26bd89e7f3d/" rel="bookmark">
			非极大值抑制（Non-Maximum Suppression，NMS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述
非极大值抑制（Non-Maximum Suppression，NMS），顾名思义就是抑制不是极大值的元素，可以理解为局部最大搜索。这个局部代表的是一个邻域，邻域有两个参数可变，一是邻域的维数，二是邻域的大小。这里不讨论通用的NMS算法(参考论文《Efficient Non-Maximum Suppression》对1维和2维数据的NMS实现)，而是用于目标检测中提取分数最高的窗口的。例如在行人检测中，滑动窗口经提取特征，经分类器分类识别后，每个窗口都会得到一个分数。但是滑动窗口会导致很多窗口与其他窗口存在包含或者大部分交叉的情况。这时就需要用到NMS来选取那些邻域里分数最高（是行人的概率最大），并且抑制那些分数低的窗口。
NMS在计算机视觉领域有着非常重要的应用，如视频目标跟踪、数据挖掘、3D重建、目标识别以及纹理分析等。Faster-RCNN中有两处使用NMS，第一处是训练+预测的时候，利用ProposalCreator来生成proposal的时候，因为只需要一部分proposal，所以利用NMS进行筛选。第二处使用是预测的时候，当得到300个分类与坐标偏移结果的时候，需要对每个类别逐一进行非极大值抑制。也许有人问为什么对于每个类别不直接取置信度最高的那一个？因为一张图中某个类别可能不止一个，例如一张图中有多个人，直接取最高置信度的只能预测其中的一个人，而通过NMS理想情况下可以使得每个人（每类中的每个个体）都会有且仅有一个bbox框。
原理
NMS(Non Maximum Suppression)，又名非极大值抑制，是目标检测框架中的后处理模块，主要用于删除高度冗余的bbox，先用图示直观看看NMS的工作机制。从下图处理的结果可以看出，在目标检测过程中，对于每个obj在检测的时候会产生多个bbox，NMS本质就是对每个obj的多个bbox去冗余，得到最终的检测结果．
对于Bounding Box的列表B及其对应的置信度S,采用下面的计算方式.选择具有最大score的检测框M,将其从B集合中移除并加入到最终的检测结果D中.通常将B中剩余检测框中与M的IoU大于阈值Nt的框从B中移除.重复这个过程,直到B为空.
重叠率(重叠区域面积比例IOU)阈值
常用的阈值是 0.3 ~ 0.5.
其中用到排序,可以按照右下角的坐标排序或者面积排序,也可以是通过SVM等分类器得到的得分或概率,R-CNN中就是按得分进行的排序.
就像上面的图片一样，定位一个车辆，最后算法就找出了一堆的方框，我们需要判别哪些矩形框是没用的。非极大值抑制的方法是：先假设有6个矩形框，根据分类器的类别分类概率做排序，假设从小到大属于车辆的概率 分别为A、B、C、D、E、F。
(1)从最大概率矩形框F开始，分别判断A~E与F的重叠度IOU是否大于某个设定的阈值;
(2)假设B、D与F的重叠度超过阈值，那么就扔掉B、D；并标记第一个矩形框F，是我们保留下来的。
(3)从剩下的矩形框A、C、E中，选择概率最大的E，然后判断E与A、C的重叠度，重叠度大于一定的阈值，那么就扔掉；并标记E是我们保留下来的第二个矩形框。
就这样一直重复，找到所有被保留下来的矩形框。
原文: https://www.cnblogs.com/makefile/p/nms.html NMS 在目标检测中的应用
人脸检测框重叠例子
face box
我们的目的就是要去除冗余的检测框,保留最好的一个.有多种方式可以解决这个问题,Triggs et al. 建议使用Mean-Shift 算法,利用bbox的坐标和当前图片尺度的对数来检测bbox的多种模式.但效果可能并不如使用强分类器结合NMS的效果好.
目标检测 pipline
产生proposal后使用分类网络给出每个框的每类置信度,使用回归网络修正位置,最终应用NMS.
实现步骤
人脸检测的一些概念
（1） 绝大部分人脸检测器的核心是分类器，即给定一个尺寸固定图片，分类器判断是或者不是人脸；
（2）将分类器进化为检测器的关键是：在原始图像上从多个尺度产生窗口，并resize到固定尺寸，然后送给分类器做判断。最常用的方法是滑动窗口。
以下图为例，由于滑动窗口，同一个人可能有好几个框(每一个框都带有一个分类器得分)
而我们的目标是一个人只保留一个最优的框：于是我们就要用到非极大值抑制，来抑制那些冗余的框： 抑制的过程是一个迭代-遍历-消除的过程。
（1）将所有框的得分排序，选中最高分及其对应的框：
（2）遍历其余的框，如果和当前最高分框的重叠面积(IOU)大于一定阈值，我们就将框删除。
（3）从未处理的框中继续选一个得分最高的，重复上述过程。
测试
可以看到：置信度为0.99的框保留下来是因为其置信度最高。第一次迭代时就已经存入了pick数组中。
置信度为0.88的框保留下来是因为其与0.99的框交并比IOU &lt; overlap = 0.8
置信度为0.82的框保留下来是因为其与任何框都无重叠。
注意此时经过NMS后，每类别还可能会剩余不止一个的候选框。而对于图像中的每个类别我们只需一个候选框即可。所以还有后续处理。
后续：R-CNN分别用20个回归器对上述20个类别中剩余的候选框进行回归操作。最终得到每个类别修正后的得分最高的bounding box。
代码
#!/usr/bin/env python3 # -*- coding: utf-8 -*- "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cb424ffda3a0da45826f26bd89e7f3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffc91ca28f205c08a8f66662b1458653/" rel="bookmark">
			SVN安装过程中遇到的问题及注意事项**
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装过程中的问题
自己练习时需要在同一台电脑上安装客户端及服务器端，服务器端地址https://www.visualsvn.com/server/download/，客户端安装的时候遇到了很多问题，其一点击右键图标出不来，其实这个不重要，不影响使用；其二就是官网下载的插件安装后没有svn.exe文件（官网地址https://tortoisesvn.net/downloads.html），最后使用的版本是(https://sliksvn.com/download/).
2.在webstorm中配置svn
步骤如下
①打开webstorm,点击File -&gt; Settings -&gt; Version Control -&gt; Subversion
②在输入框中输入svn.exe的地址，如下图③设置完点击ok
3.怎么让webstorm上有svn的提交及更新功能
①打开svn服务端，在repositories里新建一个文件夹；
②在User中设置用户名及密码；
③鼠标放在新建的文件夹上点击右键，复制文件地址如下图
④回到webstorm,点击菜单栏上的VCS及checkout from version control和subversion，如下图⑤点击加号输入刚刚复制的地址，随后点击确认即可将服务器上的文件提取到本地，如果没有成功或webstorm上没有更新及提交等按钮，就需要下载点击File -&gt; Setting -&gt;Plugins -&gt; 搜索SVNToolBox并安装即可。如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84f6a63b8892cd179707475075cbcae3/" rel="bookmark">
			常用git命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始跟踪新文件/把已跟踪的文件放到暂存区
git add main.go
提交修改到本地
git commit
推送提交的修改到远程
git push git@url.git gethistory_api
克隆现有代码库
git clone git@url.git
可选指定文件夹名
git clone git@url.git dirName
查看文件状态
git status
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e8bc5257366b8a552ab9a41909ec6f9/" rel="bookmark">
			VueCli3之更改icon图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初次使用更改icon图标的时候，可能会根据脚手架搭建完成后的public中修改index.html中的link,如下
但是，会发现即使修改了之后，重新刷新也没有任何作用。
那么接下来我来讲一下解决的方法。
一、先将自己的icon直接替换原的图标
二、在根目录创建一个vue.config.js文件，然后写下之前
module.exports = { pwa: { iconPaths: { favicon32: 'favicon.ico', favicon16: 'favicon.ico', appleTouchIcon: 'favicon.ico', maskIcon: 'favicon.ico', msTileImage: 'favicon.ico' } } } 这边有个GitHub上的详细讲解pwa
记得修改完成之后需要重启项目，这样图标才会生效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d966bc09885dc72f3a0f5c4e2487cd/" rel="bookmark">
			JS阻止冒泡和取消默认事件(默认行为)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：http://caibaojian.com/javascript-stoppropagation-preventdefault.html
js冒泡和捕获是事件的两种行为，使用event.stopPropagation()起到阻止捕获和冒泡阶段中当前事件的进一步传播。使用event.preventDefault()可以取消默认事件。对于冒泡和捕获的优先顺序请看之前文章：JavaScript捕获和冒泡探讨
防止冒泡和捕获 w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true
stopPropagation也是事件对象(Event)的一个方法，作用是阻止目标元素的冒泡事件，但是会不阻止默认行为。什么是冒泡事件？如在一个按钮是绑定一个”click”事件，那么”click”事件会依次在它的父级元素中被触发 。stopPropagation就是阻止目标元素的事件冒泡到父级元素。如：
&lt;div id='div' onclick='alert("div");'&gt; &lt;ul onclick='alert("ul");'&gt; &lt;li onclick='alert("li");'&gt;test&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 上面的代码，Demo如下,我们单击test时，会依次触发alert(“li”),alert(“ul”),alert(“div”)，这就是事件冒泡。
冒泡事件 阻止冒泡·
window.event? window.event.cancelBubble = true : e.stopPropagation(); 停止冒泡 取消默认事件 w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false;
preventDefault它是事件对象(Event)的一个方法，作用是取消一个目标元素的默认行为。既然是说默认行为，当然是元素必须有默认行为才能被取消，如果元素本身就没有默认行为，调用当然就无效了。什么元素有默认行为呢？如链接&lt;a&gt;，提交按钮&lt;input type=”submit”&gt;等。当Event 对象的 cancelable为false时，表示没有默认行为，这时即使有默认行为，调用preventDefault也是不会起作用的。
我们都知道，链接&lt;a&gt;的默认动作就是跳转到指定页面，下面就以它为例，阻止它的跳转：
//假定有链接&lt;a href="http://caibaojian.com/" id="testA" &gt;caibaojian.com&lt;/a&gt; var a = document.getElementById("testA"); a.onclick =function(e){ if(e.preventDefault){ e.preventDefault(); }else{ window.event.returnValue == false; } } 演示：阻止链接跳转的默认行为
caibaojian.com
return false javascript的return false只会阻止默认行为，而是用jQuery的话则既阻止默认行为又防止对象冒泡。
下面这个使用原生js，只会阻止默认行为，不会停止冒泡
//code from http://caibaojian.com/javascript-stoppropagation-preventdefault.html &lt;div id='div' onclick='alert("div");'&gt; &lt;ul onclick='alert("ul");'&gt; &lt;li id='ul-a' onclick='alert("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1d966bc09885dc72f3a0f5c4e2487cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/989f7f6c3d3f89048c6583a361e1acb0/" rel="bookmark">
			EF Core中CodeFirst的建库建表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建项目
1、创建web项目
2添加项目依赖
1、Microsoft.EntityFrameworkCore
这是ef core的核心包
2、Microsoft.EntityFrameworkCore.SqlServer
sqlserver 数据库驱动包
3、Microsoft.EntityFrameworkCore.Tools
工具扩展包
4、Microsoft.EntityFrameworkCore.Proxies
延迟加载实现包
[Table("UserInfo")] public class UserInfo { [Key] [DatabaseGenerated(DatabaseGeneratedOption.Identity)] public int id { get; set; } [MaxLength(50),Required] public string name { get; set; } [MaxLength(50),Required] public string password { get; set; } } Table==&gt;对应数据库表名
Key==&gt;主键
DatabaseGenerated.Identity ==&gt;数据库自动增长列
public class TestDbContext:DbContext { public DbSet&lt;UserInfo&gt; userInfos; public TestDbContext(DbContextOptions&lt;TestDbContext&gt; options) :base(options) { } protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { optionsBuilder.UseLazyLoadingProxies(false); } protected override void OnModelCreating(ModelBuilder modelBuilder) { base.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/989f7f6c3d3f89048c6583a361e1acb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68782a8a5e284453f854ce2bb97570db/" rel="bookmark">
			golang 数据库操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		golang操作数据库一般使用开源项目gorm，该项目拥有15000多star，功能较全面。
简单增删改查 类似于java的hibernate将数据封装到结构体（java到对象）中进行操作
package models import ( "fmt" "github.com/astaxie/beego" "github.com/jinzhu/gorm" "riskcontrol/database" "riskcontrol/utils/snowflake" "time" ) const( score = "user_score" ) type ScoreModel struct { BaseModel UserId string `json:"user_id",gorm:"type:varchar(18);not null;comment:'用户id';"` Score int32 `json:"score",gorm:"type:int;null;comment:'分数'"` BindFacebook bool `json:"bind_facebook",gorm:"type:boolean;not null;comment:'中文名称'"` //IsValid bool `json:"-",gorm:"type:boolean;not null;default:1;comment:'是否有效(0：无效,1:有效)'"` } func init() { database.GetDB().AutoMigrate(&amp;ScoreModel{}) } /** 设置匹配的表名称 */ func (ScoreModel) TableName() string { return score } func (userMode *ScoreModel)BeforeCreate (scope *gorm.Scope) error { id,err := snowflake.NewSnowFlake().Generate() if err != nil{ beego.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68782a8a5e284453f854ce2bb97570db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/339db6ca4dffd1e73bae763567412ab1/" rel="bookmark">
			经典调度问题：读者优先/写者优先算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 算法介绍读者优先:写者优先:多线程编程注意事项写者优先算法流程图 算法介绍 创建一个包含n 个线程的控制台进程。用这n 个线程来表示n个读者或写者。每个线程按相应测试数据文件的要求，进行读写操作。请用信号量机制分别实现读者优先和写者优先的读者-写者问题。
读者优先：如果一个读者申请进行读操作时已有另一读者正在进行读操作，则该读者可直接开始读操作。
写者优先：如果一个读者申请进行读操作时已有另一写者在等待访问共享资源，则该读者必须等到没有写者处于等待状态后才能开始读操作。
首先要明白在多线程编程中的互斥关系: 读写互斥和写写互斥.两个优先方式都遵循这个出发点.在满足以上条件的情况下,进来的线程都好像是在排队,然后看当前谁优先.自己如果是优先的,那么可以直接插队.再考虑正在执行的是否和自己阻塞,如果正在执行的和自己阻塞,那自己也得排队,只不过排在前面.(类似写者优先的写写线程),如果正在执行的和自己不是阻塞的,那么自己就可以直接进去执行(读者优先的读读进程).如果自己不是优先的,那么自己只能老老实实的排队,就算自己前面有和自己不互斥的线程执行也不行.类似写者优先中读线程在执行,新的写进程等待资源,更新的读线程只能等写进程释放,如果有新的写进程进来,还可以排在这个读线程前面. 读者优先: 读者就是优先的。假设a，b都是同时请求，但是a是读者那么a优先使用资源，还有一点很重要的就是读者优先的读者可以并行执行。而写着只能单线程执行。在执行过程中，只要阻塞的写者在等待过程中有新的读者进来那么他要等待所有读者完成才能自己释放自己。
写者优先: 无疑所有写的操作是优先的，这个过程可能会产生大量阻塞，因为相对较快（本来可以并行的读者被大量阻塞）。如果资源中没有写者那么读者依然可以并行，但是一旦出现写者在等待读者资源，那么新的读者就不能在并行执行，要等待所有写者执行完毕才可执行读者。
多线程编程注意事项 读者优先和写者优先是两个不同的策略方法，方法有相似之处但是也有很大不同，函数需要分开完成。最主要的排序方式基于时间排序，次要的排序以读者还是写者谁优先为准则读者优先或者写者优先的阻塞会导致线程开始时间的变化。而不过采用双队列一个存进入时间的排序，一个存结束时间的排序，修改其中的一个会影响另一个队列中元素值不错，但是如果不对另一个队列进行增/删是不会触发堆排序的功能（挺重要的）。可能有些阻塞时候的等待时间和开始时间改变处理比较复杂，要考虑当前是读致使阻塞，还是写致使阻塞，还是前面有写的资源再等待致使阻塞。要用多个变量维系系统使得正确的更改线程的阻塞时间。 写者优先算法流程图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b9bfbe752932a8c04706765def42380/" rel="bookmark">
			6大思维模型, 揭秘硅谷高管如何做区块链应用决策
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源 | Readwrite 编译 | 火火酱
责编 | Carol
出品 | 区块链大本营（blockchain_camp） 说起硅谷，最引人注目的特点之一要数它从不受困于传统的底线。
当大多数公司专注于收益和利润率时，硅谷的领导者往往将估值视为成功的晴雨表。正是由于这种心态，只要有助于实现宏大的愿景，硅谷的公司并不介意承担重大风险。
因此在区块链的应用方面，我们可以向硅谷学习一下。今天我们不妨跟着硅谷高管们的思维模型，去判断如何在自己的业务中使用区块链技术。
模型1：什么是区块链风险？
区块链本身就是一个已经开始显现的风险，并且，非硅谷公司已经注意到这一点。国际数据公司（International Data Corporation）预测，到2022年，区块链支出将达到117亿美元，并会将其触角扩展到科技和银行业以外的领域。
尽管区块链的确适用于多个行业，但仍有一些领导者并未接受这一解决方案。
这种犹豫一定程度上源于他们混淆了区块链与加密货币，事实上两者各有利弊。另一方面，导致他们犹豫不定的原因之一是，他们认为区块链对利润的直接帮助微乎其微。
然而在2019年，区块链的潜在价值正在变得越来越明显。大多数意识到这一点的领导者都在认真考虑其用例，而更多持怀疑态度的高管也逐渐发现，自己对于投资这项技术的态度变得更加开放了。
硅谷起草了拥抱区块链的蓝图——湾区以外的公司是时候冒险效仿了。
模型2：清除区块链混乱
与其他新兴技术一样，区块链也带来了一系列新术语，但这些术语其实也没什么大不了的。 有兴趣为自己创造独特营销机会的人可以好好利用一下区块链、人工智能和大数据等术语自带的吸睛光环。这些流行语能帮助他们兜售那些实际上没有任何新功能或根本不存在的产品和服务。 模型3：错误的信息四处流传
高管们对新技术持怀疑态度也是可以理解的
由于四处流传着太多错误的信息，这也就不难理解为什么高管们会对新技术持有怀疑态度，同时对在老问题上采用更为现代的解决方案犹豫不决。
为了更好地理解区块链的价值，领导者们必须了解几个常见误解的真相：
1、区块链和比特币是一样的
虽然区块链对加密货币的运作起着至关重要的作用，但其价值的有无并不随比特币的开始和结束而改变。区块链的核心是一种分散且安全的保存数字记录的方法。区块链由不同的数据“区块”组成，这些数据区块通过加密技术连接在一起，从而创建出储存在各种计算机上的信息字符串（或链）。 区块链不透明和不可变的特性将区块链的地位置于传统业务记录方法之上。它不能被篡改或更改，并且每个区块都可以被访问和查看。对于区块的保护建立了一套清晰且完整的问责机制，这可远不仅仅是对创造货币有用。 2、区块链代替了关系数据库
因为像SQL Server 和Oracle这样的服务覆盖了与区块链类似的领域，所以有些人认为它是为了取代传统关系数据库而存在的。然而，区块链平台大多还处于起步阶段，并不打算取代那些更为根深蒂固的解决方案。区块链仅作为一种补充选项而存在。
3、区块链将彻底摆脱中介的角色
虽然区块链确实使比特币能够消除交易中的中间人，但在其他应用程序中却不是这样的。只要交易保留在内部生态系统中，那么就不需要外部验证。然而，当涉及到与整个世界交互时，中介仍然可以帮助进行数据输入和身份验证。 4、区块链仅仅是一个公共的点对点系统。
许多应用使用区块链技术实现的最大卖点是交易的公共性。这种透明性使很多企业认为区块链只能存在于公共环境中，或者不可能创建依赖权限的应用程序。虽然这是当前最为常见的版本，但区块链不必向所有参与者开放，它可以仅对那些需要知道特定信息的人开放。 和其他所有新技术一样，区块链的成功与失败取决于其应用。
模型4：高管们必须要先让区块链“走下神坛”
高管们需要摒弃那些，让区块链看起来 像一时科技潮一样的营销术语和浮夸 承诺。 相反，它们必须要确定自己的核心目标，然后决定区块链是否能帮助他们更快地实现这些目标。
模型5：区块链在当今商业环境中的地位
对于企业来讲，硅谷冒险本性的好处之一是，它使其他人能够从它的成功和失败中吸取教训。以下是几种区块链已经证明其价值的方法：
1.协调文档控制和第三方共享
尽管区块链作为一种公开分布的解决方案享有盛誉，但它仍是一种可以安全地共享信息，而不让信息落入坏人之手的完美方式。这可能会改变安全至上的医疗保健等行业中的游戏规则。它为正确的人提供了访问全面数据的便利性，大大降低了安全风险。
2．与人工智能合作以提高监管和洞察力
在传统工作领域，数据库常常会变成数据孤岛——难以跨越部门或公司间共享数据。然而，区块链应该被分享给那些需要其作为商业或整个行业完美通用储存库的人。
这种共享对于实现更好地通讯和数据洞察力都起到至关重要的作用。随着收集和共享的信息越来越多，机器学习算法可以从更多的信息中训练模型。
此外，对于一位专家来说可能不太明显的事情，或许对另一位具有不同技能和知识的人来讲是显而易见的——这使在数据孤岛无法实现的开箱即用思维成为可能。
3.利用客户数据来改善源头
由于区块链可以轻松实现安全分发，因此合作者们可以轻松地收集、读取和分析来自全球各地的信息。当涉及到需要确定哪个供应商能够生产最高品质的产品时，来自顾客的数据可以准确地洞察到调查方向。
4.预测设备维护模式
TMW Systems等平台提供的解决方案会在出现问题时使用区块链来提醒公司。它们还会收集每次事件的相关数据。从长远来看，协助公司了解设备故障的时间和原因会节省资本和时间。
模型6：区块链不再是最适合硅谷居民的技术
任何企业都可以使用特定的用例，区块链已经不再是硅谷最好的技术了。对于企业高管们来说，仅仅考虑是否该使用区块链是远远不够的，你应该已经要考虑如何更好地使用它了。
搞清楚区块链如何帮助企业发展，如何在这个技术的基础上更上一层楼，才是所有高管该思考的事情。
区块链技术的发展一定是以应用为核心基础的，这件事情不仅需要开发者们去考虑，更需要企业管理者们一同参与。
如何少走弯路，利用不同区块链的数据结构实现项目上链？ 数据架构是区块链的重要组成部分，了解数据架构，可以让我们对于自身业务是否适合上链做出明智的判断。 9月19日，【 dfuse小聚：区块链数据应用讨论会 】将在上海举行，dfuse CTO&amp;联合创始人、EOS加拿大联合创始人 Alex Bourget ；慢雾科技合伙人兼安全产品负责人 启富 （Keywolf）；MYKET联合创始人/EOS Cannon联合创始人 Ricky胖哥 ， 与你一起深度探索区块链应用搭建以及区块链数据结构的奥秘，让你明白到底你的业务该如何上链！ 长按识别下方二维码，了解详细议程 推荐阅读：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b9bfbe752932a8c04706765def42380/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12afded1c7086ddf6762c20d907204f5/" rel="bookmark">
			连接Oracle数据库的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里介绍两种连接 Oracle 数据库的方法（其实就是两种工具的连接方法）
一、PLSQL连接 连接本地数据库 如果连接是本地数据库话，只要开启数据库后输入用户名密码，选择对应的数据库（服务命名）即可，点击确定就可以连接了。
而连接远程数据库要稍微复杂一点，这里也有两种方式
连接远程数据库 方式一：
找到 tnsnames.ora 文件
我这里的目录在 D:\Oracle\product\11.2.0\dbhome_1\NETWORK\ADMIN，大家可以根据自己的目录去找到自己安装目录下的 tnsnames.ora，用记事本工具打开 tnsnames.ora 文件
打开后大家能够看到类似红色框中的配置，我们可以复制一份放到 tnsnames.ora 文件底部，然后对其进行修改
大家可以根据自己的情况设置上面图片中标出的四个位置：1、自定义数据库名；2、根据远程数据库地址修改地址；3、根据远程数据库端口号修改端口号；4、根据远程数据服务名修改服务名
修改完成后保存，再次打开 PLSQL
这里只要填写正确的用户名密码，并选择刚刚自定义的数据库名，点击确定就可以连接数据库了。
方式二：
从开始菜单中找到 Oracle 的 Net Manager 工具，单击打开
找到服务命名这里可以看到刚刚配置的数据库名（服务命名），里面的配置和刚刚在 tnsnames.ora 文件修改的是一样的。我们可以通过左上角的创建按钮添加新的数据库配置，配置步骤可以参考tnsnames.ora 中的配置步骤。
二、Navicat连接 打开 Navicat
修改 OCI 的路径，我这里改成了我本地 Oracle 安装的 OCI 路径大家可以参考下：D:\Oracle\product\11.2.0\dbhome_1\BIN\oci.dll
改完重启后，再次打开Navicat
按照上图操作进入 Oracle 新建连接界面
连接名自己定义，主机 ip 地址、端口和 PLSQL 连接是一样的，需要注意的是这里的服务名不要写成对应 PLSQL 中的服务命名。
大家可以跟上图比较一下，配置完后就可以使用连接测试测试下是否成功啦！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/393/">«</a>
	<span class="pagination__item pagination__item--current">394/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/395/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>