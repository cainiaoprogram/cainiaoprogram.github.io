<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b56b623d76d9d01ddc9f5340fa43db3e/" rel="bookmark">
			eNSP基础常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要收集了基础的常用ensp命令及其简写方式
基础命令 命令可通过tap键进行补全，当输入的不完整的命令能补全能匹配到的命令有且只有一个时，不进行补全亦可执行该命令
system-view：从用户模式切换成系统模式，简写为“sys”，ctrl +z 可以退回用户模式；
sysname：修改当前设备主机名；
undo info-center enable ：关闭信息中心功能，关闭后，在配置过程部分配置信息不会显示；
quit：退出当前模式，逐级退出，简写为“q”；
save：保存当前设备的配置，否则设备重启后配置会恢复；
reboot：重启设备；
display current-configuration:查看当前生效配置，即当前设备所有接口的配置命令都会显示出来，按回车一行一行翻，按空格一页一页翻；
display clock：显示设备时间；
display this：可以显示当前界面配置生效的命令；
undo + 配置命令：可用于删除当前界面配置的命令；
清除整个交换机或路由器配置的命令 需要在用户视图下执行reset saved-configuration命令
&lt;Huawei&gt;reset saved-configuration Warning: The action will delete the saved configuration in the device. The configuration will be erased to reconfigure. Continue? [Y/N]:y //询问擦除以重新配置，选择y Warning: Now clearing the configuration in the device. May 31 2023 22:32:17-08:00 Huawei %%01CFM/4/RST_CFG(l)[0]:The user chose Y when deciding whether to reset the saved configuration.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b56b623d76d9d01ddc9f5340fa43db3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5873d6ae79fbad3dc3beb489c9a35d04/" rel="bookmark">
			单张图片一键换脸（github爆火工程——roop）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 roop 单张图片一键换脸工程简介免责声明程序安装CPU版本GPU版本 程序运行资源包 roop 单张图片一键换脸 工程简介 该工程实现的功能为：提供单张源人脸图像，可实现一键替换目标视频中的人脸，输出替换人脸后的视频，替换前后效果见上述动图。
该工程基于tkinter库设计了简洁的GUI界面，用以选取源人脸图像和目标视频，操作简介。
程序的使用有两种方式：CPU方式和GPU方式。CPU方式环境安装简单，但运行较慢，GPU方式环境安装相对而言较为复杂，但运行速度非常之快。
项目地址：https://github.com/s0md3v/roop
免责声明 本文只对roop工程进行介绍，不承担任何责任，请读者合理合法的使用工程。以下为源工程的免责声明：
比这更好的 deepfake 软件已经存在，这只是我为了学习 AI 而创建的一个业余项目。用户在使用自己的脸之前必须征得相关人员的同意，并且在网上发布内容时不得隐瞒这是一个深度造假的事实。我不对最终用户的恶意行为负责。
为了防止误用，它有一个内置的检查功能，可以防止程序在不合适的媒体上运行。
程序安装 本文只介绍Windows系统下的程序的安装与使用，Linux和MacOS用户请参考源工程。
CPU版本 1.安装python3.10以上，需要安装有python的pip工具。建议采用conda创建虚拟环境进行安装。
2.安装ffmpeg多媒体处理工具，并设置环境变量。
3.安装Visual Studio（包括桌面开发C ++），尽可能安装较为新的版本（本人测试VS2019可以）。
4. 下载仓库：https://github.com/s0md3v/roop，进入roop目录并执行命令 pip install -r requirements.txt 安装所需的依赖库。（需要能够访问github,如果不能访问可从文末的资源包中免费下载）
5. 从以下网站中下载此文件并将其保存在roop目录中。如果文件名不是inswapper_128.onnx，请将其重命名。镜像1 镜像2 镜像3 镜像4
（访问上述网站需要魔法，也可在我提供的资源包中获取inswapper_128.onnx。获取链接见文末，免费获取。）
GPU版本 本文仅针对Nvidia显卡的用户，A卡请参考源工程。
1.安装CPU版本所需要的工具环境（见上一小节）。
2.安装CUDA和对应的CUDNN。主要CUDA和CUDNN一定要匹配。
3.安装GPU版本的pytorch和onnxruntime-gpu。注意pytorch的安装需要和CUDA版本对应。
pip uninstall onnxruntime onnxruntime-gpu pip install torch==2.0.0+cu118 torchvision==0.15.1+cu118 torchaudio==2.0.1 --index-url https://download.pytorch.org/whl/cu118 pip install onnxruntime-gpu 程序运行 1.运行python程序
CPU版本运行：
python run.py GPU版本运行：添加gpu的选项
python run.py --gpu 除了–gpu选项，程序还提供了其他的选项。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5873d6ae79fbad3dc3beb489c9a35d04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e075ffc931aaf645410d11cbdc8fe211/" rel="bookmark">
			随机森林原理和性能分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 随机森林入门构造随机森林随机森林性能随机森林特点 随机森林入门 决策树入门、sklearn实现、原理解读和算法分析中针对决策树进行了详细的描述，但是其只考虑了一颗决策树的情况。俗话说，三个臭皮匠，顶个诸葛亮。本文将研究如何通过组合多颗决策树的方式，进一步提升模型的效果，即随机森林。
为了理解清楚随机森林算法背后的原理，我们先来看一个非常简单但却很有意思的实例：有3位法官需要判断被告是否有罪，最终的判断结果使用少数服从多数的方式确定。
假设每位法官判断正确的概率均为 p p p，如果只有1位法官，那么该法官判断正确的概率就是 p p p。
当法官数量增加至3位时，最终能够判断正确的情况有两种：一种是3位法官均判断正确，另一种是只有一位法官判断错误，其余两位则判断正确。其总概率为
p 3 + 3 p 2 ( 1 − p ) p^3+3p^2(1-p) p3+3p2(1−p)
只有3位法官判断正确的概率高于1位法官判断正确的概率时，增加法官数量才是有意义的，此时
p 3 + 3 p 2 ( 1 − p ) &gt; p p^3+3p^2(1-p)&gt;p p3+3p2(1−p)&gt;p
化简得到
p ( p − 1 ) ( p − 0.5 ) &lt; 0 p(p-1)(p-0.5)&lt;0 p(p−1)(p−0.5)&lt;0
因为 p p p的基本约束是 0 ≤ p ≤ 1 0≤p≤1 0≤p≤1，结合上式可以将约束条件变为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e075ffc931aaf645410d11cbdc8fe211/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69159e479644e9be179d607c880e7094/" rel="bookmark">
			【SpringBoot无需重启修改代码页面生效】SpringBoot热部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在实际开发中，我们使用SpringBoot进行开发的时候，需要频繁启动tomcat服务器，每次修改一次代码就需要重启一次，这使得我们的开发效率收到严重影响。
市面上的热部署插件有很多，下面介绍两种比较常用的热部署插件：
1. 使用maven引入dev-tools依赖 步骤：
第一步：在maven的配置文件pom.xml中引入dev-tools的依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;!-- 可选 --&gt; &lt;/dependency&gt; 另外，需要在pom.xml中添加相关插件的支持
&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; 第二步：打开项目自动构建设置
可以使用Ctrl+Alt+S打开setting
File – &gt; setting – &gt; Build,Execution,Deployment–&gt; Compiler
第三步：勾选compiler.automake.allow.when.app.running
CTRL+shift+Alt+/ 选择 Registry 选中打勾 “compiler.automake.allow.when.app.running” ：
第四步：开启IDEA热部署策略
找到SpringBoot-&gt;Running Application Update Policies
第三步：关闭浏览器缓存
network-&gt;disabled cache
测试：
在Product 类中定义了toStrting()方法，启动tomcat服务器，观察控制台打印的日志 @Component //prefix绑定到application.yml文件中的product对象，进行属性的注入 @ConfigurationProperties(prefix="product") @PropertySource({"classpath:application.yaml"}) //JSR303数据校验 @Validated public class Product { // 自定义提示信息 @Email(message="邮箱格式有误") private String myEmail; /** * 注意：依赖注入一定要getter和setter */ private Double totalPrice; private String name; @Override public String toString() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69159e479644e9be179d607c880e7094/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ad1e66a9f6dff8663952a742993b46/" rel="bookmark">
			python编程——编译器与解释器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：Insist--
个人主页：insist--个人主页
本文专栏：python专栏
专栏介绍：本专栏为免费专栏，并且会持续更新python基础知识，欢迎各位订阅关注。
目录
一、编译器与解释器的介绍
二、编译器与解释器的区别
三、python编译器与解释器种类
1、Brython
2、winPython
3、Pyjs
四、总结
前言 通过上篇文章对python的介绍，大家对python了解了多少？今天这篇文章将给大家讲解编译器与解释器。
一、编译器与解释器的介绍 无论是python编译器还是解释器都是高级语言与机器之间的翻译官。
作用：两者作用都是将代码翻译成机器可以执行的二进制机器码，两者不同的是在运行原理和翻译过程不同。
二、编译器与解释器的区别 编译器：先整体编程后，再执行。
解释器：一边解释一边执行。
通俗的来说就是：我们去饭店吃饭，点了一堆菜。
编译器的方式是厨师把所有的菜都做好后，一块给你端上来，至于你在哪吃，趴着吃还是倒立着吃，都不管你。
解释器的方式是厨师做好一个菜就给你上一个菜，你就得吃这个菜，而且必须在店里吃完。
三、python编译器与解释器种类 1、Brython Brython是一种流行的Python编译器，可将Python转换为Javascript代码。它提供对所有Web浏览器(包括一种手机Web浏览器)的支持。它还支持Html5 / CSS3规范，可以使用流行的CSS框架，如BootStrap3和LESS。
2、winPython 它是为Windows操作系统设计的。它有一些CPython的特性。它预装了一些针对数据科学和机器学习的流行库，例如Numpy、Pandas和Scipy。它带有C/C++编译器，大多数时候不会用到。除此之外，它只有Python编译器，没有其它包。
3、Pyjs Pyjs是一个丰富的Internet应用程序框架，也是一种轻量级的Python编译器，可以从Web浏览器直接执行Python脚本，可以从浏览器的JS控制台执行程序。它是从Python到Javascript的编译器，可以使代码在Web浏览器上运行。它带有Ajax框架和Widget SetAPI。
四、总结 Python 是一种为许多实现提供了可能的开发语言，例如 Python 到 Java，Python 到 Javascript，Python 的这些编译器有助于我们理解它是多么的全能。
欢迎关注订阅，本专栏会支持更新
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6723a5400554988ebf0a33473c050917/" rel="bookmark">
			手把手教你在 CentOS 7 下升级 OpenSSL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 引言2. 升级 OpenSSL 的必要性3. 升级前的准备4. 安装依赖5.OpenSSL 的下载和安装5.1下载5.2 解压5.3 安装 6. 检查7. 处理可能出现的问题6. 总结 1. 引言 这篇文章记录着如何在 CentOS 7 上升级 OpenSSL。会逐步介绍所需步骤，包括备份，下载和安装，以及配置等。
2. 升级 OpenSSL 的必要性 OpenSSL 是用于保护数据安全的重要工具。它能提供加密，解密等多项功能。然而，随着技术的发展和新的安全漏洞的出现，使用最新版本的 OpenSSL 成为了重要的需求。
最主要的是有些较新的应用只能安装在openssl3上，所以不更换centos7只
能升级。
3. 升级前的准备 备份现有配置为了防止升级过程中出现问题，我们需要首先备份现有的配置。执行查找命令find /usr -name openssl,例如我查找出来的是**/usr/bin/openssl** 和 /usr/lib64/openssl
则执行拷贝命令 [root@localhost ~]# find /usr -name openssl /usr/bin/openssl /usr/lib64/openssl [root@localhost ~]# cp -r /usr/bin/openssl /usr/bin/openssl_backup [root@localhost ~]# cp -r /usr/lib64/openssl /usr/lib64/openssl_backup 检查系统版本
我们需要确认当前的 CentOS 和 OpenSSL 的版本，以确定升级的需求。例如，我们可以使用命令 cat /etc/centos-release 和 openssl version 来检查。 [root@localhost ~]# cat /etc/centos-release CentOS Linux release 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6723a5400554988ebf0a33473c050917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c555e907ed0719196cd77ce137a66ca/" rel="bookmark">
			DNS地址修改和软件源修改汇总（基于ubuntu22.04）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DNS修改方法和软件源修改方法 1、修改DNS地址2、修改软件源 教育源 企业源 其它源 3、单独修改软件源 3.1选择Ubuntu软件源 3.2添加其他软件源 1、修改DNS地址 /etc/resolv.conf文件是DNS客户机配置文件，它只能对本次有效，下次启动就失效了。
/etc/systemd/resolved.conf文件是DNS系统初始配置文件，修改这个文件就可以永久修改DNS。
这里我们修改/etc/resolv.conf文件。
# 1)修改DNS地址（这里用echo实现，如果对vim编辑器熟练，也可以用vim打开resolv.conf文件修改） sudo echo "nameserver 8.8.8.8" | sudo tee /etc/resolv.conf &gt; /dev/null # 可换的DNS有: # 114公共DNS: 114.114.114.114和114.114.115.115 # 阿里的DNS: 223.5.5.5和223.6.6.6、 # 腾讯的DNS: 119.29.29.29和182.254.116.116 # 百度的DNS: 180.76.76.76 # Google的DNS: 8.8.8.8和8.8.4.4 # 2)测试是否修改成功（用gedit查看也行） cat /etc/resolv.conf # 3)重新更新（也可以重新执行你当时安装出错的命令，比如：sudo apt install ros-humble-desktop） sudo apt-get update --fix-missing 2、修改软件源 （1）保险起见可以先备份待修改文件
sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak （2）用gedit方式打开软件源配置文件
因为/etc/apt/sources.list文件是普通可编辑的文本文件，可以采用普通文本编辑器打开修改。
sudo gedit /etc/apt/sources.list 另外，用vim编辑器也是可以修改的（新手不推荐）
# 按i键进入编辑模式，Esc键退出编辑模式，在退出编辑模式下，窗口输入:wq可保存并退出vim编辑器。 sudo vim /etc/apt/sources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c555e907ed0719196cd77ce137a66ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32a5ffd14cfd17cf23dac98267028639/" rel="bookmark">
			idea 2023版 安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一步:官网安装idea
IntelliJ IDEA – the Leading Java and Kotlin IDE 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dbeaf0cfb6a37ee452546234f2a7e88/" rel="bookmark">
			教你用Appium搭建Android自动化测试框架（详细教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题，本文附有仓库地址以及代码，目录如下：
1.下载安装appium
2.配置并使用appium
3.配置工程
一、下载安装appium 下载appium-desktop的mac版本，我选择用1.17.1版本，最新的版本1.22.0，拆分一个桌面应用为两个桌面应用了，一个叫做Appium Server,另外一个叫做AppiumInspector。
下载链接：github.com/appium/appi…
UI Automator,google提供的自动化测试框架，appium集成了它。详细了解如下：developer.android.google.cn/training/te…
二、配置并食用appium a.电脑配置好adb，jdk,sdk环境变量,打开appium应用。
Host和端口不需要修改，点击start后页面如下，点击箭头位置，配置app的信息。
b.开始配置appium
c.涉及到的adb命令
adb devices -l adb shell dumpsys activity | grep "mResume" Json的信息，要根据具体的手机和要测试的app的信息进行配置，第一个矩形框为appPackage的内容，第二个矩形框为appActivity的内容，输入如下命令获得需要的信息； adb shell dumpsys activity | grep "mResume"
输入如下命令，获得矩形框的内容，填充Json中的deviceName选项
adb devices -l
d.点击了start session后，正式进入了appium的使用，代表配置成功了，界面如下：
三、配置工程 a.点击录制
b.生成UI自动化的脚本
点击1-》界面控件-》2-》3，从而复制3中的脚本
c.通过AS新建一个工程
如Java工程，在maven-resposity下载三个依赖的jar包，在新建模块的libs目录下拷入 commons-lang3-3.1.jar 、java-client-7.3.0.jar、selenium-server-standalone-3.141.59.jar这三个jar库，build.gradle中配置依赖junit和jar包。
新建一个app的文件夹，然后复制对应要测试的apk到这个目录下面，主义，对应的apk一定要是testonly设置为false了，否则会发生错误，同时，手机在测试前，先卸载掉已经安装的测试应用，避免安装不上去；
d.最后，编写测试代码，作为普通的控制台程序进行执行，代码如下：
package com.mobile.searchandclick; import org.junit.After; import org.junit.Before; import org.junit.Test; import org.openqa.selenium.remote.DesiredCapabilities; import java.io.File; import java.net.MalformedURLException; import java.net.URL; import io.appium.java_client.MobileElement; import io.appium.java_client.android.AndroidDriver; import io.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dbeaf0cfb6a37ee452546234f2a7e88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96d68ea55eb8d6343e559631d3339e4a/" rel="bookmark">
			【自用】pycharm远程SSH遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、pycharm连接不上远程
解决方案：
(107条消息) PyCharm远程SSH调用服务器python解释器_强壮的小蛋蛋的博客-CSDN博客
2、自定义函数调用失败
解决方案：改为服务器里面的绝对路径
3、运行控制台报错Cannot find remote credentials for target config com.jetbrains.plugins.remotesdk.target.webDeployment.
解决方案:
4、使用远程服务器跑代码
5、GPU和pytorch不兼容 6、如果右键“部署”不显示
选择部署路径
7、
No module named 'cv2' 安装命令是： pip install opencv-contrib-python 8、
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4be00e43aeb350aa961bd4edd38e6bad/" rel="bookmark">
			Ubuntu的安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Ubuntu 的安装教程1、Ubuntu的镜像下载2、服务器版的安装教程2.1.1、允许 root 远程登录 3、桌面版的安装教程3.1.1、允许 root 远程登录 一、Ubuntu 的安装教程 1、Ubuntu的镜像下载 ​ 这里我选择阿里云的镜像下载你也可以选择Ubuntu的官网下载
Ubuntu官网
如果英文版的看着有点歪瓜裂枣就选择中文版
在这里我们选择阿里云的镜像网站下载
2、服务器版的安装教程 ​ 点击创建虚拟机
回车
选择稍后安装操作系统
选择 English
服务器版，没有简体中文，所以选English
也可以手动设置静态IP
选择Manual
选择 Continue
一些可选的额外软件
回车，然后输入用户名密码
设置root密码
agan@cloudsino:~$ sudo passwd root [sudol password for agan: 先输入agan用户的密码9639 New password: 再设置root用户密码 cloudsino_666 Retype new password:passwd: 确认root用户密码 cloudsino_666 password updated successfully # 设置密码成功 agan@cloudsino:~$ echo $? # 表示上一条命令是否执行成功 0 agan@cloudsino:~$ su - root # 登录root用户 Password: cloudsino_666 root@cloudsino:~# 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4be00e43aeb350aa961bd4edd38e6bad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f2d9850ff64e4ea079cc4b406a8a906/" rel="bookmark">
			基于图像分析技术的条码识别软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开条形码识别软件。 2、导入图片。条形码识别软件支持从本地文件、相机或截屏中导入图片，可以将需要提取条形码的图片导入到软件中。 3、识别条形码。在软件中，点击识别条形码的按钮开始扫描图片中的条形码。如果图片中包含了一个或多个条形码，软件会自动识别并显示条形码的内容。 4、执行相应的操作。根据需要，您可以将条形码的内容复制到剪贴板、保存为文件或分享到其他应用程序中。
https://download.csdn.net/download/sinoyard/87858479
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a93779726e636b7d6bc03f5c69908f45/" rel="bookmark">
			python-while循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python-while循环 文章目录 python-while循环while循环的基本概念while循环的语法条件表达式是一些函数break和continue的运用whlie循环在列表集合元组字典的运用while的注意事项： while循环的基本概念 while循环是一种在满足特定条件的情况下重复执行一段代码的控制结构。它允许我们在不知道确切循环次数的情况下执行代码，只要条件保持为真，代码块就会一遍又一遍地执行。
基本上，while循环不断地检查一个条件表达式，只要该条件为真，循环中的代码就会被执行。一旦条件变为假，循环就会停止，控制流会跳出循环，继续执行循环之后的代码。
这种循环结构非常有用，特别是在我们需要根据特定条件来重复执行某段代码时。例如，当我们需要从用户那里获取输入，直到满足某个条件时才停止获取。while循环还可以用于遍历列表、处理数据集，以及实现其他需要重复执行的逻辑。
需要注意的是，在编写while循环时，我们必须确保在循环体内能够改变条件表达式的值，否则可能导致无限循环。我们应该始终有一个方法来改变循环条件，以便在适当的时候终止循环。这就是while循环的基本概念：重复执行一段代码，直到条件变为假。
while循环的语法 当谈到while循环的语法时，以下是其基本组成部分和相关知识点：
while关键字：while是Python中用于定义循环的关键字。
条件表达式：while循环的条件表达式决定了循环是否执行。条件表达式应该是一个能够返回布尔值（True或False）的表达式。只要条件表达式为真，循环中的代码块就会被执行。
代码块：代码块是while循环中需要重复执行的一组代码。代码块通常用缩进来表示，缩进的代码会成为循环体。可以是单行或多行代码。
循环执行流程：当while循环开始执行时，首先检查条件表达式的值。如果条件为真，则执行循环体中的代码块。然后再次检查条件，如果仍为真，则再次执行循环体中的代码块。这个过程会一直重复，直到条件为假才会停止循环，控制流程将离开while循环，继续执行循环之后的代码。
下面是一个示例代码，演示了while循环的基本语法：
count = 0 while count &lt; 5: print("Count:", count) count += 1 print("Loop finished") 这个示例代码中的while循环使用一个计数器变量count，初始值为0。条件表达式count &lt; 5检查计数器是否小于5，如果为真，则执行循环体中的代码块。在循环体中，打印计数器的值并将计数器增加1。循环体执行完毕后，再次检查条件，如果仍为真，则再次执行循环体。这个过程会重复执行，直到计数器的值达到5，条件变为假，循环停止。最后，打印出"Loop finished"，表示循环结束。
执行上述代码的输出结果将是：
Count: 0 Count: 1 Count: 2 Count: 3 Count: 4 Loop finished 条件表达式是一些函数 是的，条件表达式可以是函数。在Python中，条件表达式可以是任何返回布尔值的表达式，包括函数调用。
下面是一个示例，演示了如何在条件表达式中使用函数：
def is_positive(num): return num &gt; 0 def is_even(num): return num % 2 == 0 x = 10 while is_positive(x) and not is_even(x): print(x, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a93779726e636b7d6bc03f5c69908f45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8163464f481cacb7c45d24903d4bf2ae/" rel="bookmark">
			c# mudbus TCP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 建议先大致了解c# Socket通讯，之后再学习modbusTCP协议
ModbusTCP 协议概念：1996年施耐德公司推出基于以太网TCP/IP的Modbus协议。 Modbus协议是一项应用层报文传输协议,包括ASCII、RTU、TCP三种报文类型。报文格式是协议的重点。 TCP 协议 知道格式就完事了，主要是格式里面的数据。
二、ModbusTCP 报文格式–读取保持寄存器 1、ModbusTCP报文格式：报文头+功能码+数据 ① 报文头：服务器与客户端之间的“握手”，当一台服务器连接n台客户端，报文头能够保证服务器精准地给其中一客户端发送数据（或者服务器接收到数据，能够明白是哪一台客户端发送的）。
② 功能码：服务器与客户端交流是读取数据 还是写数据
③ 数据：读取的数据内容 或者要写数据的内容（前面一对乱七八糟 就是为了得到这个玩意）
2、报文头 报文头字节长度作用事务标志符2个字节Modbus 请求/响应事务（一般为16进制 00,00 ）协议标志符2个字节Modbus 协议（一般为00，00）长度 标志符2个字节单元标志符+功能码+数据 总共的字节数量（知道字节数，可以知道数据是否丢失）单元标志符1个字节总线的从站识别（相当于给每一个客户端一个号码/地址，知道你是谁） 一般格式为：
事务协议长度单元标志0x00,0x000x00,0x000x00,0x060x01 解释：报文格式均为16进制
事务/协议：0x00000000
长度：0x06 — 6个字节–后面的报文的字节总数量 ：单元1+功能码1+地址2+线圈数量2
单元标识：0x01 —客户端号码/地址为1
2、功能码 Modbus的操作对象有四种：线圈、离散输入、保持寄存器、输入寄存器。占用一个字节
功能码含义0x01读线圈0x05写单个线圈0x0F写多个线圈0x02读离散量输入0x04读输入寄存器0x03读保持寄存器0x06写单个保持寄存器0x10写多个保持寄存器 不同的操作对象，报文格式不同，这里下面的主要介绍0x03 读保持寄存器----就是可以读取数据。
明白其中一种操作对象报文格式，其它功能码内容类似。
3、数据（寄存器） 读取保持寄存器报文又分为发送报文和返回报文两种
例如当你给服务器发送数据，这个数据格式是按照读保持寄存器报文格式发送的
服务器接收到你发的信息，就明白你是来读取数据的，之后就会回复给你信息，因为你发送很规范，服务器回复你的时候就会按照的你报文格式回复（返回报文格式）
发送报文格式如下：
起始地址低位、起始地址高位、线圈数量高位、线圈数量低位均占一个字节
事务协议缩写 0x00000000，实际为：0x00，0x00，0x00，0x00
长度缩写0x0006，实际为：0x00，0x06
--------------报文头--------------功能------------------------数据-------------------------- 事务协议长度单元标志功能码起始地址高位起始地址低位数量高位数量低位0x000000000x00060x010x030x000x6B0x000x02 发送报文含义：
读取1号服务器保持寄存器(数据)，数据起始地址0x6B=107，对应地址40108，读取寄存器数量0x02=2，即读取1号数据，地址从40108-40109，共两个寄存器数组（4个字节）。
为什么地址是从40000开始，因为读保持寄存器地址为0x03；前面有0x00、0x01、0x02。
返回报文格式如下：
事务协议缩写 0x00000000，实际为：0x00，0x00，0x00，0x00
长度缩写0x0006，实际为：0x00，0x06
--------------报文头--------------功能----------------------------------数据----------------------------------- 事务协议长度单元标志功能码字节数量1寄存器高位1寄存器低位2寄存器高位2寄存器低位0x000000000x00070x010x030x040x000x010x000x02 返回报文含义：
返回服务器1号从站保持寄存器40108-40109，共两个寄存器的数值，返回的字节数为4个
40108对应数值为0x0001,40109对应数值为0x00109；转换为10进制分别为1和2；
即读取到数据为1 和 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8163464f481cacb7c45d24903d4bf2ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a311e2b68494dd72453654af2195a63/" rel="bookmark">
			Java中的适配器模式（Adapter Pattern）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中的适配器模式（Adapter Pattern） 简介： 适配器模式（Adapter Pattern）是一种常用的设计模式，用于将一个类的接口转换成客户端所期望的另一个接口。在Java中，适配器模式可以帮助我们解决不兼容接口之间的问题，提供一种灵活的方式来重用现有的类。
作用： 适配器模式的主要作用是使不兼容的接口能够协同工作。它通过将一个类的接口转换成另一个类的接口，使得原本由于接口不匹配而无法在一起工作的类能够合作。适配器模式可以有效地将现有类库、第三方组件或旧系统与新系统进行集成，从而提高代码的复用性和可维护性。
优势： 代码重用：适配器模式允许我们重用现有的类，而不需要修改其原始代码。通过适配器，我们可以将这些类纳入到新的系统中，无需进行大规模的重构。
系统扩展：适配器模式允许我们在不修改现有代码的情况下，扩展系统的功能。通过添加适配器类，我们可以引入新的接口或类，并使其与现有代码无缝集成。
接口转换：适配器模式提供了一种接口转换的方式，使得不兼容的接口能够协同工作。这样，我们可以将不同的接口统一起来，简化系统的复杂度。
应用场景： 适配器模式在以下情况下特别有用：
老旧代码的重用：当我们需要在新的系统中重用旧有的代码时，适配器模式可以帮助我们无缝集成这些代码，并与新代码协同工作。
第三方组件的集成：当我们需要使用某个第三方组件，但其接口与我们的系统不兼容时，适配器模式可以提供一个适配器，将第三方组件的接口转换为我们所期望的接口。
接口转换：当我们需要将一个接口转换成另一个接口时，适配器模式可以提供一种简单而灵活的解决方案。这对于系统的整合和扩展非常有帮助。
总结：
适配器模式在Java中是一种常用的设计模式，用于解决不兼容接口之间的问题。它可以帮助我们重用现有的类，扩展系统的功能，并提供接口转换的能力。适配器模式适用于需要将旧有代码与新代码无缝集成的情况，以及需要将不兼容接口转换为兼容接口的情况。通过适配器模式，我们可以提高代码的复用性、可维护性和系统的灵活性。
举例说明 假设我们有一个旧的音频播放器接口 OldAudioPlayer，它定义了播放音频文件的方法 playAudio(String fileName)，但我们希望使用一个新的音频播放器类 NewAudioPlayer，它具有不同的接口 play(String audioType, String fileName)。
这时候就可以使用适配器模式来解决接口不兼容的问题。我们可以创建一个适配器类 AudioPlayerAdapter，它实现了新的音频播放器接口 NewAudioPlayer，并且内部持有一个旧的音频播放器对象 OldAudioPlayer。适配器类会将新接口的方法转换为调用旧接口的方法，从而实现对新旧接口的适配。
下面是适配器模式在Java中的示例代码：
// 旧的音频播放器接口 interface OldAudioPlayer { void playAudio(String fileName); } // 旧的音频播放器实现类 class OldAudioPlayerImpl implements OldAudioPlayer { public void playAudio(String fileName) { System.out.println("Playing audio file: " + fileName); } } // 新的音频播放器接口 interface NewAudioPlayer { void play(String audioType, String fileName); } // 适配器类 class AudioPlayerAdapter implements NewAudioPlayer { private OldAudioPlayer oldAudioPlayer; public AudioPlayerAdapter(OldAudioPlayer oldAudioPlayer) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a311e2b68494dd72453654af2195a63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a5f0264325c0e4a831fe764de81c201/" rel="bookmark">
			刘知远团队提出：如何通过扩大高质量指导性对话数据集，来提高模型的性能和效率...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习自然语言处理 原创
作者 | 刘嘉玲
随着开源语言大模型(LLM)的百花齐放，模型的性能和效率关乎到产品的成本和服务体验的均衡。那么，有没有办法让语言大模型变得更高效、更优秀呢？
为了进一步提高开源模型的上限，清华大学的研究团队给出了一个答案：通过扩大高质量指导性对话数据，显著提高了模型的性能和效率。如下图所示，UltraLLaMA问鼎LLM榜！
被网友评价：包含150万个高质量，多样化的多回合对话的UltraChat，优于SotA开源模型Vicuna。我们一起仔细读读论文，看看能带来哪些启示~
论文：Enhancing Chat Language Models by Scaling High-quality Instructional Conversations
地址：https://arxiv.org/pdf/2305.14233.pdf
代码：https://github.com/thunlp/UltraChat
进NLP群—&gt;加入NLP交流群
1 论文项目概述 为了进一步提高开源模型的上限，论文提出了一种新的聊天语言模型——UltraLLaMA，它是通过提供多样化、高质量的指令对话数据集UltraChat上微调LLaMA模型得到的，成功提升了聊天语言模型的性能。
图：GPT-4生成的论文架构 2 UltraChat多模态数据集是如何构建的？ 构建设计：UltraChat的总体思路是使用单独的LLM来生成开场白、模拟用户和响应查询。UltraChat的三个方案：关于世界的问题、写作和创作、对现有材料的协助都有特点的设计，如下图：
图：UltraChat的构建过程 2.1 关于世界的问题
这部分数据主要关注的是现实世界中存在的概念、对象和实体。
收集这部分数据的方法有两个角度：一个是围绕主题和概念，另一个是围绕现实世界的实体。
请求ChatGPT生成30个涵盖我们日常生活各个方面，具有代表性和多样性的元主题，如下图：
表：30个用于生成超端聊天数据的第一部分的元概念 构建过程：
首先，根据这些元主题生成了1100多个子主题；同时从维基数据中收集了最常用的10,000个现实世界的命名实体，比如人物、地点、事件等。
再为每个子主题设计了最多10个具体的问题；每个实体设计了5个基本问题，10个具体问题和20个扩展问题。
然后使用Turbo API为10个问题中的每一个生成新的相关问题。想用这些问题来创建对话，所以从大约500,000个问题中筛选和抽样了一些作为对话的开头。
使用手工制作的prompt来指示模型生成涵盖各种常见概念和对象的各种问题，要求它回答简洁、有意义，并且考虑到对话历史的上下文。
最后对200k个特定问题和250k个一般问题以及50k个元问题进行采样，并迭代地生成多轮的对话。
2.2 写作和创作
这部分的目的是根据用户的指示，自动生成不同类型的写作文本。
使用ChatGPT使其根据用户的指示，生成20种不同类型的写作文本，比如故事、诗歌、论文等。
表：20种类型的用于案例2和3的聊天生成的文本材料 构建过程：
对于每种类型的写作，生成200条不同的prompt，让AI助手生成文本材料，其中80%的指令被进一步扩展和细化。
将生成的指令作为初始输入，分别生成2~4轮的对话。
2.3 对现有材料的协助
这部分的目的是根据现有的文本材料，生成不同类型的任务，比如改写、翻译、总结等。
用到包含了大量文本片段和源URL的数据集的C4语料库，和20种故事、诗歌、论文等不同的材料类型。
构建过程：
从C4数据集中提取了约10w种不同的材料。
为每种类型设计了一些关键字，得到了根据关键字和URL对文本片段进行归类后的材料。
用ChatGPT为每份材料生成最多5个问题/说明。
将每个问题/指令的材料与一组手动设计的模板结合起来，作为用户的初始输入，开始与 AI 助手的对话。
得到了50万个对话开头，每个对话开头包含了一个文本片段和一个任务指令。对于每个输入，生成 2~4 轮对话。
表：手动设计用于连接现有材料和生成的说明的模板 2.4 数据集评价
UltraChat数据集是一个大规模的多模态对话数据集，它包含了超过100万个对话，每个对话平均包含8轮对话。其中不仅包含了文本信息，还包含了音频、视频和屏幕共享数据。
UltraChat与其他几个指令数据集进行统计分析比较，结果下表所示。
表：现有指令数据集的统计数据 UltraChat在规模、平均回合数、每个实例的最长平均长度和词汇多样性方面都优于其他数据集，是最大的开源数据集之一。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a5f0264325c0e4a831fe764de81c201/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ac316f75ff2bcdda53d4a204c3a45af/" rel="bookmark">
			【笔记】【YOLO学习】YOLOV5环境配置与代码运行问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文基于该博客（目标检测—教你利用yolov5训练自己的目标检测模型）撰写，意为记录在配置yolo5运行环境运行代码时遇到的一系列问题的解决方法。
训练集、测试集、验证集的区别 训练集、测试集和验证集都是在机器学习中用于评估和调整模型的数据集，它们的主要区别在于它们在机器学习的不同阶段使用。
训练集（Training set）是用于训练模型的数据集，机器学习模型会通过训练集中的数据进行学习和训练，以便对未知数据进行预测。训练集通常是数据集的大部分，通常在80%到90%之间，其余部分用于测试集和验证集。
测试集（Test set）是用于评估模型性能的数据集，它用于测试模型的泛化能力，即模型在未见过的数据上的表现。测试集必须与训练集是相互独立的，这意味着测试集中的数据不应该在训练集中出现过。
验证集（Validation set）是用于调整模型超参数的数据集，它用于选择最佳模型。验证集通常是从训练集中划分出来的，通常在10%到20%之间，与测试集一样必须是与训练集是相互独立的。在训练过程中，模型的超参数会被不断地调整，同时在验证集上进行评估，以找到最佳的超参数。
总之，训练集是用于训练模型的数据集，测试集是用于评估模型性能的数据集，验证集是用于调整模型超参数的数据集。在机器学习中，合理地使用这些数据集可以帮助我们获得更好的模型性能和泛化能力。
Error:module ‘numpy’ has no attribute ‘int’ 原因 官方在 requirements.txt 文件中，对于 numpy 版本要求如下：
numpy&gt;=1.18.5
但是 numpy.int 在NumPy 1.20中已弃用，在NumPy 1.24中已删除。
解决方法 降级 numpy 版本：
pip install numpy==1.85 opencv-python安装问题 安装opencv-python报错 在添加的 anaconda channels （已经换了清华源）中找不到 opencv-python 软件包，报错信息如下：
Solving environment: ...working... failed with initial frozen solve. Retrying with flexible solve. PackagesNotFoundError: The following packages are not available from current channels: - opencv-python[version='&gt;=4.1.2'] Current channels: - https://conda.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ac316f75ff2bcdda53d4a204c3a45af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdab8ef1e887e3984d1bb54b7aa7736c/" rel="bookmark">
			SDF(Signed-distance-field: 有向距离场)(7): 距离场函数-基于CUBE计算方式产生的若干变体A
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SDF非常好玩的地方之一就是通过距离场函数的实现来实现空间分布函数，这样可以创造神奇的空间几何体造型。这个样例就是通过变换CUBE的距离场函数，来实现其各种各异的变形，下面的demo只是展示了基本的变体(改变cube的计算方式生成的Cube变体)。
Demo1:Rendering &amp; Art
效果图:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35fce80fa793e4526f4e03aba7b4551b/" rel="bookmark">
			MySQL之数据查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.单表查询1.1 查询所有字段1.2 查询指定字段1.3 查询指定数据1.4 带关键字in的查询1.5 带关键字between...and的范围查询1.6 带like的字符匹配查询1.7 用关键子is null查询空值1.8 带关键字and的多条件查询1.9 带关键字or的多条件查询1.10 用关键字distinct去除结果中的重复行1.11 用关键字order by对查询结果排序1.12 用关键字limit限制查询结果的数量 2.聚合函数查询2.1 count()函数2.2 sum()函数2.3 avg()函数2.4 min()函数和max()函数 3.连接查询3.1 内连接查询(inner join/join)3.2 外连接查询3.3 复合条件连接查询3.4 交叉连接(cross join) 4.合并查询结果4.1 union4.2 union all 5.使用正则表达式查询5.1 匹配指定字符中的任意一个5.2 匹配以指定字符开头和结束的记录 6.case when语句 数据查询是指从数据库中获取所需要的数据。数据查询是数据库操作中最常用，也是最重要的操作。通过不同的查询方式可以获得不同的数据。用户可以根据自己对数据的需求使用不同的查询方式。 1.单表查询 单表查询是指从一张表中查询所需要的数据。
1.1 查询所有字段 语法：select * from 数据表名;
1.2 查询指定字段 语法：select 字段名 from 数据表名;
如果是查询多个字段，可以使用“,”对字段进行分隔。
例如：查询tb_one中的name和score字段
1.3 查询指定数据 如果要从很多记录中查询出指定的记录，那么就需要一个查询的条件。设置查询条件应用的是where子句。
语法：select 字段 from 数据表名 where 条件;
例如：向tb_one表中查询name=小明的数据
1.4 带关键字in的查询 关键字in可以判断某个字段的值是否在指定的集合中。如果字段的值在集合中，则满足查询条件，该记录将被查询出来；如果不在集合中，则不满足查询条件。
语法：select 字段 from 数据表名 where 条件 [not] in(元素1，元素2…);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35fce80fa793e4526f4e03aba7b4551b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de302b9a0ed41e6c7cf58d06529e6e92/" rel="bookmark">
			C语言学习-循环语句，if-else循环，while循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简单的 if-else循环语句
#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { int input = 0; printf("加入CSDN\n"); printf("你要好好学习吗?(1/0)&gt;:"); scanf("%d",&amp;input); if (input == 1) printf("CSDN大神额\n"); else printf("捡破烂\n"); return 0; } 2、简单的while循环
#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { int line =0; printf("加入CSDN\n"); while(line&lt;200) { printf("学习一天C语言：%d\n",line); line++; } if(line&gt;=200) { printf("学成了耶"); } return 0; } 3、简单函数的建立 sum函数
#include &lt;stdio.h&gt; #include &lt;string.h&gt; int Add(int x,int y) { int z=x+y; return z; } int main() { int num1 = 10; int num2 = 20; int sum = 0; sum = Add(num1,num2); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de302b9a0ed41e6c7cf58d06529e6e92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/325c8c62c55b2442449a7c742405cb78/" rel="bookmark">
			POI合并单元格后设置合并单元格边框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XSSFWorkbook workbook = new XSSFWorkbook(); XSSFSheet sheet = workbook.createSheet("Sheet"); // 创建合并单元格区域 CellRangeAddress mergedRegion = new CellRangeAddress(0, 0, 0, 5); sheet.addMergedRegion(mergedRegion); //创建单元格样式 // 创建字体对象 Font font = workbook.createFont(); font.setFontName("PMingLiU"); font.setFontHeightInPoints((short) 12); // 创建样式对象，并将字体应用于样式 CellStyle style = workbook.createCellStyle(); style.setFont(font); style.setVerticalAlignment(VerticalAlignment.TOP); // 设置边框样式 style.setBorderTop(BorderStyle.THIN); style.setBorderBottom(BorderStyle.THIN); style.setBorderLeft(BorderStyle.THIN); style.setBorderRight(BorderStyle.THIN); XSSFRow row = sheet.createRow(0); XSSFCell cell = row.createCell(0); cell.setCellValue("Hello World"); //循环合并的单元格，每个单元格都设置相同的样式 for (int i = 0; i &lt;= 5; i++) { XSSFCell cell1 = row.getCell(i); if (cell1 == null) { cell1 = row.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/325c8c62c55b2442449a7c742405cb78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/114e9ffa5a229e9dae6660c77abfd7e4/" rel="bookmark">
			学习路之gis--如何获取中国地图的shp文件（含省级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载地图json文件 网址：DataV.GeoAtlas地理小工具系列
http://datav.aliyun.com/tools/atlas/index.html
2、点击下载文件 也可以用geopandas打开。
3、点开https://mapshaper.org/ 选择文件并输出
export
本文转自：如何获取中国地图的shp文件（含省级） - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/794bdf75f7dc96955167b818b8e77af7/" rel="bookmark">
			Android退出应用方法 Exit App
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Android退出App应用代码 测试过了以下代码，但是很多情况都无法正常退出APP。
System.exit(0); //杀死该应用进程 android.os.Process.killProcess(android.os.Process.myPid()); 以下为可正常退出代码：
在当前Activity添加以下代码 Intent intent = new Intent(this, MainActivity.class); intent.putExtra("IsExist",true); intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK|Intent.FLAG_ACTIVITY_NEW_TASK); this.startActivity(intent); finish(); 在MainActivity添加以下代码 Intent intent = getIntent(); boolean exist = intent.getBooleanExtra("IsExist",false); if(exist) finish(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ada5d88fa73274f74b4a2ef3ef5b6bb/" rel="bookmark">
			用C&#43;&#43;实现8皇后问题&#43;代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先感谢B站小姐姐耐心讲解
主要思路： 用二维列表表示摆放皇后后的攻击位置，（即1表示不可放，0表示可放），记为attack。如图 每行放置一个皇后后，更新attack，然后遍历下一行的每列，通过判断该位置是否为0，寻找可放位置（注意要备份attack，以回溯）关于棋盘用一维queen来表示，用“.”表示空，“Q”表示皇后 最后将每种棋盘摆放方法记录 代码： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n); void backtrack(int k, int n, vector&lt;string&gt;&amp; queen, vector&lt;vector&lt;int&gt;&gt;&amp; attack, vector&lt;vector&lt;string&gt;&gt;&amp; solve);//k表示下一个需要摆放皇后行位置 void put_queen(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; attack); int main() { vector&lt;vector&lt;string&gt;&gt; res; //保存棋盘摆放情况 res = solveNQueens(8); cout &lt;&lt; "8皇后问题一共有"&lt;&lt;res.size()&lt;&lt;"种情况"&lt;&lt;endl; //展示 cout &lt;&lt; "结果如下：" &lt;&lt; endl; for (int i = 0; i &lt; res.size(); i++) { cout &lt;&lt; "第" &lt;&lt; i+1 &lt;&lt; "种" &lt;&lt; endl; for (int j = 0; j &lt; res[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ada5d88fa73274f74b4a2ef3ef5b6bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e50f0207f958cc82f429b48abb4705b/" rel="bookmark">
			Linux搭建redis真集群(三主三从)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.环境准备 三台服务器，一台服务器一主一从，如果是一台服务器，那是伪集群
2.解压 tar xzf redis-5.0.7.tar.gz
3.进入解压后的目录 cd redis-5.0.7
4.输入make命令 注:如果没有make命令需要下载yum -y install gcc ，因为make install命令需要此环境
make install PREFIX=/home/redis-5.0.7/redis-cluster
5.进入到redis-cluster文件夹下面，把bin改成7000，把redis-5.0.7里面的配置文件redis.conf复制到7000里面 cp /home/redis-5.0.7/redis.conf /home/redis-5.0.7/redis-cluster/7000/
6.修改配置文件 6.1修改bind 地址 6.2把端口从6379，修改成7000 6.3指定日志文件路径 6.4指定rdb、apf文件写入路径 6.5持久化配置 6.6开启集群 6.7集群配置文件名称 6.8超时时间 6.9连接主节点密码，各个节点访问密码(暂不设置密码) 6.10守护线程模式 6.11关闭保护模式用于公网访问 7.启动redis两个端口 回到/home/redis-5.0.7/src
./redis-server /home/redis-5.0.7/redis-cluster/7000/redis.conf &amp;
./redis-server /home/redis-5.0.7/redis-cluster/7001/redis.conf &amp;
ps -ef | grep redis
把另外两台服务器的redis也按照此步骤进行配置和启动，最后应该三台服务器应该是这样的
8.创建集群 ./src/redis-cli --cluster create IP:端口 IP:端口 IP:端口 --cluster-replicas 0
执行之后会提示，可以设置上述配置嘛，这块输入yes即可，三个主节点建立完成
9.查看集群 master是主节点
10.测试集群效果
10.1模拟主节点宕机操作 把服务器里的6380主节点进程干掉
现在服务器只有一个6381从节点进程，启动6380端口，去看集群6381端口是否变成了主节点
可以看到，6381端口已经变成了master
主从验证成功
11.设置密码 进入到redis节点，config set masterauth 123456
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e50f0207f958cc82f429b48abb4705b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4fbf0c8156d05a50977ee06837d9548/" rel="bookmark">
			NUC980编译错误，arm-linux-gcc: Command not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错问题： make: arm-linux-gcc: Command not found /bin/sh: 1: arm-linux-gcc: not found dirname: missing operand
昨天编译的时候，还小甜甜，今天就牛夫人了。啥也没干啊！
---------------------------------------------------------------------------------
百度： 一会说编译设置不对，一会说权限不够 来个777 ，一会说没有32位的库。
一通瞎折腾没有用啊。
ChatGPT: make: arm-linux-gcc: Command not found /bin/sh: 1: arm-linux-gcc: not found dirname: missing operand
这个错误提示是因为在编译过程中找不到arm-linux-gcc这个命令。可能是由于交叉编译工具链没有正确安装或者没有配置环境变量导致的。请检查你的交叉编译工具链是否正确安装，并且将其所在的路径添加到环境变量中。你可以通过执行echo $PATH命令查看当前的环境变量路径是否包含交叉编译工具链的路径。如果没有，请将其添加到环境变量中。
你可以尝试以下步骤来解决这个问题：
确认你已经正确安装了交叉编译工具链。你可以通过执行arm-linux-gcc --version命令来检查是否安装成功。
如果你已经安装了交叉编译工具链，但是仍然出现了这个错误提示，那么可能是因为你没有将交叉编译工具链所在的路径添加到环境变量中。你可以通过执行echo $PATH命令来查看当前的环境变量路径是否包含交叉编译工具链的路径。如果没有，请将其添加到环境变量中。
如果你不确定交叉编译工具链的路径，可以通过执行which arm-linux-gcc命令来查找其所在的路径。
如果你还是无法解决这个问题，可以尝试重新安装交叉编译工具链，并确保正确地配置了环境变量。
希望这些步骤能够帮助你解决问题。如果你还有其他问题，请随时提出。
虽然没有真正的解决问题，但是思路是对的：
arm-linux-gcc --version
echo $PATH
which arm-linux-gcc
看来也是没有问题的，那么问题出现在哪里了呢？
解决办法:
关键字：CROSS_COMPILE
注意啊，手动输入绝对路径这个地方不要带gcc ,脚本会重新拼接的，不然报错！
看来和这个有关系：
CROSS_COMPILE = /usr/local/arm_linux_4.8/bin/arm-linux-
然后就成功了：
根本原因是哪里的路径配置不对：
无法获取编译器的路径：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1156668d0e8aefefd89e614699a9406/" rel="bookmark">
			在Android11中创建自己的HAL模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hidl_interface 是 Android 系统中 HAL（Hardware Abstraction Layer）层中重要的一个概念。HAL 的作用是为系统上层提供硬件抽象层接口，使不同的硬件设备可以在 Android 中得到统一的访问和使用。hidl_interface 则是定义了 HAL 接口中所需要实现的方法和数据结构。
hidl_interface 实际上是由 Android 框架层（Framework Layer）自动生成的 C++ 接口类，在此类中定义了客户端和服务端共通的纯虚函数，这些函数描述了 HAL 层与其他层交流所需的操作。当客户端需要访问某个 HAL 服务时，需要向该服务发出请求并传递相关参数，通过调用 hidl_interface 中定义的函数，来与 HAL 服务进行交互。
同时，hidl_interface 还隐式地定义了一些常量、类型以及其它辅助性结构等，这些都为 HAL 层与其他层之间的交互提供支持。因此，hidl_interface 可以说是 HAL 层接口的基础和核心。
总之，hidl_interface 的作用是规范化 HAL 层的接口规格并提供给上层进行访问，使得 HAL 层可以在不同的硬件设备和不同的 Android 平台上提供相同的抽象层级的接口，并达到更好的可驱动性和可维护性。
这里给出一个简单的 HIDL 接口示例，该接口用于获取 Android 设备中的 CPU 温度。
首先在/hardware/interfaces/thermal/目录下创建 thermal.hal 文件，并在文件中定义 HIDL 接口：
1：创建Hal文件，定义服务方法： // thermal.hal package android.hardware.thermal; interface IThermal { // 获取 CPU 温度 int32_t get_cpu_temperature() generates(ERR_OTHERWISE, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1156668d0e8aefefd89e614699a9406/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f779e09adc274ff0ebdba3cb103e544b/" rel="bookmark">
			vue 检测打开网页设备是移动端还是PC端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 methods: { isMobile() { let flag = navigator.userAgent.match( /(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i ); return flag; }, }, mounted() { if (this.isMobile()) { alert("手机端"); } else { alert("pc端"); } }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5cb928d82744a338029ed7347753ef1/" rel="bookmark">
			Linux中解压缩zip文件的命令是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux系统中命令有很多，可进行磁盘管理、文件管理、文件传输、文档编辑等，而且相同功能的命令也有很多，比如解压缩命令，常用的有：tar、gzip、bzip2、zip、unzip、rar、unrar等，本文为大家详细介绍一下unzip命令，一起来看看吧。
Linux unzip命令用于解压缩zip文件。
unzip为.zip压缩文件的解压缩程序。
语法：
unzip [-cflptuvz][-agCjLMnoqsVX][-P &lt;密码&gt;][.zip文件][文件][-d &lt;目录&gt;][-x &lt;文件&gt;] 或 unzip [-Z]
参数：
-c 将解压缩的结果显示到屏幕上，并对字符做适当的转换。
-f 更新现有的文件。
-l 显示压缩文件内所包含的文件。
-p 与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换。
-t 检查压缩文件是否正确。
-u 与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。
-v 执行时显示详细的信息。
-z 仅显示压缩文件的备注文字。
-a 对文本文件进行必要的字符转换。
-b 不要对文本文件进行字符转换。
-C 压缩文件中的文件名称区分大小写。
-j 不处理压缩文件中原有的目录路径。
-L 将压缩文件中的全部文件名改为小写。
-M 将输出结果送到more程序处理。
-n 解压缩时不要覆盖原有的文件。
-o 不必先询问用户，unzip执行后覆盖原有文件。
-P&lt;密码&gt; 使用zip的密码选项。
-q 执行时不显示任何信息。
-s 将文件名中的空白字符转换为底线字符。
-V 保留VMS的文件版本信息。
-X 解压缩时同时回存文件原来的UID/GID。
[.zip文件] 指定.zip压缩文件。
[文件] 指定要处理.zip压缩文件中的哪些文件。
-d&lt;目录&gt; 指定文件解压缩后所要存储的目录。
-x&lt;文件&gt; 指定不要处理.zip压缩文件中的哪些文件。
-Z unzip -Z等于执行zipinfo指令。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff2c2200e7bbf6fc30a1c52f05b0f625/" rel="bookmark">
			总结了几百个ChatGPT模型的调教经验，确定不来看看？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
chatgpt调教指南
提示词
1.清晰的问题或请求：
2.上下文设置：
3.具体的主题或领域：
4.陈述性问题：
5.追问和澄清：
6.限定问题范围：
角色扮演
充当 Linux 终端
担任产品经理
充当 SQL 终端
担任 SVG 设计师
作为 项目经理
担任高级前端开发人员
上下文持续关联
英文调教
个人如何使用chatgpt
编程&amp;改bug
写文案脚本
问答助手
写到最后
大家好，我是AI大侠，AI领域的专业博主
前言 ChatGPT已经风靡了将近半年，大部分小伙伴们只停留在聊天，却苦于 ChatGPT的答案不够准确，或答非所问。
今天给大家分享，大侠通过调教数百个模型总结出的经验
chatgpt调教指南 提示词 与chatgpt对话一定要讲究技巧，不然会产生不达意的效果
下面大侠来说说需要注意哪些点
1.清晰的问题或请求： 正面例子： "请给我一些关于健康饮食的建议。"
反面例子： "嘿，告诉我点东西吧。"
2.上下文设置： 正面例子： "我们刚刚讨论了自动驾驶汽车技术，你能解释一下它的工作原理吗？"
反面例子： "解释一下自动驾驶汽车的工作原理。"
3.具体的主题或领域： 正面例子： "我对区块链技术的应用非常感兴趣，你能举个例子吗？"
反面例子： "给我一个例子。"
4.陈述性问题： 正面例子： "请解释一下为什么太阳能是一种可持续能源。"
反面例子： "太阳能是可持续能源吗？"
5.追问和澄清： 正面例子： "你提到了一些优点，但具体有哪些缺点呢？"
反面例子： "你说的太笼统了，再具体点。"
6.限定问题范围： 正面例子： "对于机器学习中的监督学习算法，你能给我列举一些例子吗？"
反面例子： "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff2c2200e7bbf6fc30a1c52f05b0f625/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd2f5a94f757d4f114fb60ef8f37d570/" rel="bookmark">
			c&#43;&#43;学习笔记（10）文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基本概念
1 文本文件
1.1写文件
1.2 读文件
2 二进制文件
2.1 写文件
2.2 读文件
基本概念 程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放
通过文件可以将数据持久化
c++中对文件操作需要包含头文件&lt;fstream&gt;
文件类型分为两种：
1 文本文件 文件以文本的ASCII码形式存储在计算机中
2 二进制文件 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们
操作文件的三大类：
1 ofstream 写操作
2 ifstream 读操作
3 fstream 读写操作
1 文本文件 1.1写文件 步骤：
1 包含头文件
#include &lt;fstream&gt;
2 创建流对象
ofstream ofs;
3 打开文件
ofs.open("文件路径",打开方式);
4 写数据
ofs&lt;&lt;"写入的数据";
5 关闭文件
ofs.close();
打开方式
#include &lt;iostream&gt; using namespace std; #include&lt;string&gt; #include&lt;fstream&gt; //包含头文件 void test01() { //写文件 //创建流对象 ofstream ofs; //指定打开方式 ofs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd2f5a94f757d4f114fb60ef8f37d570/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa5bc0a779cd7a3826bf9e3a70545e89/" rel="bookmark">
			【华为OD统一考试B卷 | 100分】找车位（C&#43;&#43; Java JavaScript Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为OD统一考试A卷+B卷 新题库说明 2023年5月份，华为官方已经将的 2022/0223Q(1/2/3/4)统一修改为OD统一考试（A卷）和OD统一考试（B卷）。 你收到的链接上面会标注A卷还是B卷。请注意：根据反馈，目前大部分收到的都是B卷。但是仍有概率抽到A卷。 A卷对应2023的新题库（2022Q4 20223Q1） B卷对应20022部分考题以及新出的题目
专栏：2023华为OD机试(A卷+B卷)（C++JavaJSPy） 专栏：2023华为OD机试(A卷)（C++ Java JS Py） 专栏：2023华为OD机试(B卷)（C++ Java JS Py）
题目描述 停车场有一横排车位，0代表没有停车，1代表有车。至少停了一辆车在车位上，也至少有一个空位没有停车。
为了防剐蹭，需为停车人找到一个车位，使得距停车人的车最近的车辆的距离是最大的，返回此时的最大距离。
输入描述 一个用半角逗号分割的停车标识字符串，停车标识为0或1，0为空位，1为已停车。停车位最多100个。 华为OD统一考试A卷+B卷 新题库说明 2023年5月份，华为官方已经将的 2022/0223Q(1/2/3/4)统一修改为OD统一考试（A卷）和OD统一考试（B卷）。 你收到的链接上面会标注A卷还是B卷。请注意：根据反馈，目前大部分收到的都是B卷。但是仍有概率抽到A卷。 A卷对应2023的新题库（2022Q4 20223Q1） B卷对应20022部分考题以及新出的题目
专栏：2023华为OD机试(A卷+B卷)（C++JavaJSPy） 专栏：2023华为OD机试(A卷)（C++ Java JS Py） 专栏：2023华为OD机试(B卷)（C++ Java JS Py）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e76756fbe53220e2bd6094582d0a9dfd/" rel="bookmark">
			大文件分片上传与下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gitee地址：OPEN-文件上传下载+大文件断点续传+漂亮的前端页面: 基于Springboot2.x的文件上传下载经典案例，文件上传下载+大文件断点续传、秒传+漂亮的前端页面
大文件上传/下载_大文件上传下载_前端阿彬的博客-CSDN博客
主要靠前端进行分片上传：
前端利用web worker和spark-md5计算文件hash值,调用后端接口查询是否存在该hash值的文件，如果有则实现秒传。
如果没有，前端对文件file.splic进行分片，再调用后端接口，后端接口接收到文件分片后，需要将文件写入本地磁盘或缓存中，且计算该分片的md5值进行保存。分片上传完成后，返回前端成功标识，前端对对应的分片进行成功标识。再传下一个分片，直到所有分片上传完成。
当前端上传完所有分片后，调用后端接口通知服务器合并分片。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d1a5fbbaf06a395db87bb070f850a92/" rel="bookmark">
			配置YOLOv7训练自己是数据集【踩坑记录】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置YOLOv7训练自己是数据集 参考资料 1、第一次踩坑【未解决】1.1、数据集准备1.2、配置YOLO1.2.1、配置网络参数1.2.2、修改数据集配置1.2.3、配置训练参数 2、第二次踩坑【已解决】2.1、修改数据集配置2.2、配置数据集2.2.1、划分训练集、测试集2.2.2、生成对应的文件 3、训练 随手记录一下YOLOv7的配置。环境：
window 10 专业版
Python3.8
Pytorch2.1
参考资料 1、HIT-UAV-Infrared-Thermal-Dataset
2、WongKinYiu/yolov7
3、【小白教学】如何用YOLOv7训练自己的数据集
4、目标检测中数据集格式之间的相互转换–coco、voc、yolo
5、YoloV7实战：手把手教你使用Yolov7进行物体检测（附数据集）
6、【特训营第三期】无人机高空红外检测
7、YOLOv7保姆级教程（个人踩坑无数）----训练自己的数据集
1、第一次踩坑【未解决】 1.1、数据集准备 使用开源的HIT-UAV数据集。有四种格式的数据，使用normal_xml文件下的，这个是voc格式的数据
1.2、配置YOLO 创建文件夹datasets，统一管理数据集创建文件夹weights，存放模型参数 1.2.1、配置网络参数 复制文件..\yolov7-main\cfg\training\yolov7.yaml，重命名为yolov7-HITUAV.yaml，修改分类的种类：
1.2.2、修改数据集配置 复制文件..\yolov7-main\data\coco.yaml，重命名为..\yolov7-main\data\HITUAV.yaml，针对数据集进行修改：
1.2.3、配置训练参数 在官网下载预训练模型yolov7_training.pt，放到文件夹weights中。
在train.py文件中，针对上面的配置，设定相关的参数：
就这样运行训练，会报错的：
需要把.yaml文件中的中文删除掉，不能留有中文，不然会报错。
就算是这样修改了，也是跑不起来的：
2、第二次踩坑【已解决】 找到了这篇博客：YOLOv7保姆级教程（个人踩坑无数）----训练自己的数据集，作者讲的很好，解决了我很多疑问和问题，推荐看！！
网络参数用上面修改的，不用修改了。
2.1、修改数据集配置 复制文件..\yolov7-main\data\coco.yaml，重命名为..\yolov7-main\data\HITUAV.yaml，针对数据集进行修改：
# COCO 2017 dataset http://cocodataset.org # download command/URL (optional) # download: bash ./scripts/get_coco.sh train: ./datasets/HITUAV/VOC/TrainVal_train.txt # val: ./datasets/HITUAV/VOC/TrainVal_val.txt # test: ./datasets/HITUAV/VOC/Test_test.txt # # number of classes nc: 5 # class names names: ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d1a5fbbaf06a395db87bb070f850a92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3edb2997e337f64ba26ce3d35639a8ea/" rel="bookmark">
			我的Cadence Allegro PCB学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Allegro快捷键 快捷键功能备注Ctrl+F5打开颜色显示设置界面F3添加布线F6DoneF9Cancle 2. Allegro文件类型 文件后缀名文件类型.brd普通电路板文件.dra符号绘制文件.padPadstack文件，做symbol时可直接调用.psmLibrary文件，存一般元器件.osmLibrary文件，存由图框及图文件说明所组成的元器件.bsmLibrary文件，存板外框及螺钉孔所组成的元器件.mdd模块定义文件.tap输出的包含NC drill数据的文件.scrScript和macro文件.art输出的底片文件.log输出的一些临时信息文件.colorView层面切换文件.jrl记录操作Allegro的事件 3. 焊盘制作 3.1 Parameters标签页 English中文Hole type钻孔类型Plating孔壁是否上锡：Plated(上)、Non-Plated(不上)、Optional(任意)Drill diameter钻孔直径Decimal places十进制数，0为整数Tolerance孔径的公差Offset X钻孔的X轴偏移量Figure钻孔符号的形状：Null(空)、 Circle(圆形)、Square(正方形)、 Hexagon(六角形),、Octagon(八边形),、Cross(十字形)、Diamond(菱形)、Triangle(三角形)、Oblong(椭圆形)、Rectangle（长方形）Characters表示图形内的文字Width表示图形的宽度Height表示图形的高度 3.2 Layers标签页 English中文BEGIN LAYER顶层DEFAULT INTERNAL中间层END LAYER底层Regular Pad设定焊盘尺寸Themal Relief设定散热孔尺寸Anti Pad设定焊盘的隔离孔尺寸Geometry形状：Null(空)、 Circle(圆形)、Square(正方形)、Oblong(椭圆形)、Rectangle(长方形)、Shape(自定义外形)Shape选择焊盘和隔离孔的外形Single layer mode单层模式（绘制贴片焊盘需要勾选）Flash选择Flash类型的热风焊盘 3.3 通过孔焊盘制作标准 元器件引脚的直径（D）PCB焊盘孔径D≤40milD+12mil40mil&lt;D≤80milD+16milD&gt;80milD+20mil 3.4 贴片焊盘制作标准 符号含义X焊盘长度Y焊盘宽度Z元器件引脚宽度D元器件中心到引脚端点的距离W引脚与焊盘接触的长度P引脚间距 ​ X=W+48
​ S=D+24
P≤26milY=P/2+1P&gt;26milY=Z+8 rec：长方形
4.元器件封装制作 4.1封装符号基本类型 类型注释Package Symbol（.psm）在PCB里有footprint的元器件（R0603、C0805）Mechanical Symbol（.bsm）在PCB理的机械类型的零件（螺钉孔）Format Symbol（.osm）关于PCB的Logo、assembly等的注解Shape Symbol（.ssm）用于定义特殊的padFlash Symbol（.fsm）这个零件是用于thermal relief和内层的负片的连接 封装元器件的基本组成：
元器件脚：Padstack
元器件外框：Assembly outline Silksscreen outline
限制区：Packae Boundary，Via Keepout
标志：Labels
4.2 IC的制作 文件类型：.dra
Drawing Type：Package symbol(wizard)
English中文Number of pins(N)引脚数Lead pitch(e)引脚中心间距Terminal row spacing(el)左右引脚中心间距Package width(E)封装宽度Package length(D)封装长度 需要绘制与设置的内容：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3edb2997e337f64ba26ce3d35639a8ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8c7d0a4a7fb7ef16ab50a1fc1bc5087/" rel="bookmark">
			专治疑难系列 - 解决Ubuntu忘记root密码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ‍‍🏡博客主页： Passerby_Wang的博客_CSDN博客-系统运维,云计算,Linux基础领域博主
🌐所属专栏：『专治疑难系列』
🌌上期文章： 专治疑难系列 - 解决win11中xbox开机自启问题
📰如觉得博主文章写的不错或对你有所帮助的话，还望大家多多支持呀！关注、点赞、收藏、评论。
一、问题描述 博主在整理库存服务器时候，发现一台长期不使用服务器，多次尝试登录root账号，提示“抱歉，登录失败，请在试一次”的尴尬情况。本篇博文以Ubuntu20.04系统为例，详细介绍了Ubuntu系统重置root密码的解决方法，如有问题欢迎各位博友积极讨论。
二、解决方法 1、重启Ubuntu系统并在启动时按下Shift键，进入GRUB菜单，选择”Ubuntu的高级选项”并回车进入； 2、选择对应的系统内核并回车进入恢复模式； 3、找到“ro recovery nowmodeset”修改为“quiet splash rw init=/bin/bash”； 4、使用快捷键“CTRL + X”进入系统并输入“passwd root”修改密码，此处密码需要填写2遍，显示“password updated successfully”表示密码更新成功。 三、问题已解决 1、Ctrl+Alt+Delete进行重启系统就可以使用新的root密码进行登陆了，如果图形化页面无法登录，可使用快捷键“Ctrl+Alt+F2”进入命令行页面输入账号密码登录。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61f69266ca2c6d9e84807b2407c89c44/" rel="bookmark">
			开源项目you-get的下载和使用、使用Cookie、配置ffmpeg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载you-get 1.1 下载python 因为you-get需要用到python，所以我们应该先安装python。可以在python官网下载最新的python版本
当前的最新稳定版是python3.8，根据系统平台去选择一个版本，比如说我这里选择一个64位的Windows版可执行程序
安装包不大，才26M，但是因为是国外的网站，所以下载速度非常慢，我下载了半小时…
1.2 安装python 下载好之后双击运行python安装包启动安装。记得一定要勾选AddPython 3.8 to PATH，然后选择Install Now，一键安装。如果对Python熟悉的话，也可以选择自定义安装，这样可以自己选择安装的可选插件或改变安装路径等
安装过程很快，安装完之后点击close关闭即可
之后打开cmd，输入python，回车，如果能进入到python交互环境，说明安装成功，然后输入exit()，回车，退出python
1.3 安装you-get 安装you-get的方式有多种，我们选择的是最方便的pip安装方式。打开cmd窗口，输入如下代码安装you-get
pip install you-get --upgrade 注意，如果使用pip过程中遇到安装不成功或者速度超慢，我们可以使用国内源进行下载，可以指定pip源提高下载速度
2.you-get使用方式 2.1 支持的列表 you-get支持的网站很多，以下是部分国内常用视频网站
网站URL哔哩哔哩http://www.bilibili.com/优酷http://www.youku.com/腾讯视频http://v.qq.com/爱奇艺http://www.iqiyi.com/央视网http://www.cntv.cn/芒果TVhttp://www.mgtv.com/快手https://www.kuaishou.com/抖音https://www.douyin.com/西瓜视频https://www.ixigua.com/百度贴吧https://tieba.baidu.com/豆瓣http://www.douban.com/斗鱼http://www.douyutv.com/凤凰视频http://v.ifeng.com/风行网http://www.fun.tv/激动网http://www.joy.cn/酷6网http://www.ku6.com/新浪视频http://video.sina.com.cn/搜狐视频http://tv.sohu.com/当然，这些网站的视频也并非都能解析的，比如说会员视频或付费视频 2.2 使用方式 最简单的使用命令就是you-get + 完整的视频URL，例如
you-get https://v.youku.com/v_show/id_XMzk4NDE2Njc4OA==.html?firsttime=0 然后静静等它下载完成即可
那这样又会有其他问题，比如说下载格式是什么？清晰度怎么选择？下载到哪个文件夹了…所以我们需要了解一下you-get命令的一些选项，我把常用的选项以及参数列出来了
选项说明-i显示资源信息，比如说格式、清晰度、大小等-u指定下载或查看的url，有时候可以省略-u直接加上url-o设置输出文件夹，即保存路径，若不指定，则保存在当前工作目录-O设置文件名，可采用默认文件名-f强制覆盖已存在的文件-F指定下载的格式（不同画质），-i选项会给出可选格式-l优先下载整个列表-P使用密码（若访问视频需要密码）-t设置超时时间，单位是秒-c使用cookie，加载cookies.txt 或者cookies.sqlite 那我们再举一个例子
还是刚才那个视频，我们先查看清晰度的信息
C:\Users\panme&gt;you-get -i https://v.youku.com/v_show/id_XMzk4NDE2Njc4OA==.html?spm=a2hcb.playlsit.page.3 site: 优酷 (Youku) title: 序章：罗网之心 streams: # Available quality and codecs [ DEFAULT ] _________________________________ - format: mp4hd2v2 container: mp4 video-profile: 超清 size: 408.0 MiB (427772864 bytes) m3u8_url: http://pl-ali.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61f69266ca2c6d9e84807b2407c89c44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3b03d0a3acb270bb6e6fe555c532cc3/" rel="bookmark">
			int *p[] 与 int (*p)[]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区分int *p[n]; 和int (*p)[n]; 就要看运算符的优先级了。
int *p[n]; 中，运算符[ ]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组。
int (*p)[n]; 中( )优先级高，首先说明p是一个指针，指向一个整型的一维数组。
实例：int *p[5]与 int (*p)[5]的区别
int *p[5]：
表示定义一个指针数组p，说白了p就是一个数组，数组内的元素是可以用于存放5个指针，而数组内的每一个指针指向一个int型的变量；即：p[0]、p[1]、p[2]、p[3]、p[4]里面都可以用于存放一个指针（地址），其实就类似于定义了5个指针变量。
int (*p)[5]：
表示定义了一个指向5个int元素的一维数组的指针。即：这个指针所指的值是一个大小为5个int的数组的首地址。p+1（数组地址+1）代表内存地址下移了5个int单位。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e9bb408c29ac4808c626be3a65863b2/" rel="bookmark">
			oracle和mysql语法区别大吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据类型 1. Number类型 MySQL中是没有Number类型的，但有int/decimal 类型，Oracle中的Number(5,1)对应MySQL中的decimal(5,1)，Number(5) 对应 int(5)。MySQL中的数字型类型比较多，分的也比较细，还有tinyint、smallint、mediumint、bigint等类型 2. Varchar2(n)类型 MySQL中对应Oracle Varchar2(n)类型的替代类型是varchar(n)类型。 3. Date 类型 MySQL 中的日期时间类型有Date、Time、Datetime等类型，MySQL中Date类型仅表示日期(年-月-日)，Time类型仅表示时间（时:分:秒），而Datetime类型表示日期时间(年-月-日 时:分:秒)，Oracle中的Date类型和MySQL中的Datetime类型一致。 二、函数 1. length(str)函数 Oracle中的length(str)是获取字符串长度的函数，MySQL 中对应的函数为char_length(str)。 2. sys_guid()函数 Oracle中可通过sys_guid()函数是生成随机序列，MySQL通过UUID()生成随机序列。 3. 时间格式化函数 将时间转换为字符串型时间 MySQL date_format(NOW(),’%Y-%m-%d’) 对应Oracle的 Oracle中的 to_char(sysdate, ‘YYYY-MM-DD’); 将字符串型时间转换为时间类型 MySQL str_to_date(‘2019-01-01′,’%Y-%m-%d’) 对应Oracle中的 to_date(‘2019-01-01’, ‘YYYY-MM-DD’); 包括时分秒的函数转换：DATE_FORMAT(NOW(),’%Y-%m-%d %H:%i:%s’)，str_to_date(‘2019-01-01′,’%Y-%m-%d %H:%i:%s’)。 4. 条件函数（nvl()、nvl2()、decode()） nvl(tab.columnName, 0)：如果tab.columnName值为空，则返回值取0，否则取tab.columnName；对应的MySQL函数为：ifnull(tab.columnName, 0)。 nvl2(expr1,expr2,expr3)：如果expr1不为null，则返回expr2，否则返回expr3；对应的MySQL函数为：if(expr1,expr2,expr3)。 DECODE(value, val1, val2, val3)：如果value等于val1，则返回val2，否则返回val3；MySQL可用IF函数表示：if(value=val1, val2, val3)； DECODE(value, if1, val1, if2,val2,…,ifn, valn, val)：如果value等于if1，则返回val1，如果value等于if2，则返回value2…如果value等于ifn，则返回valn，否则返回val；MySQL对于这种判断可以通过case when then else end;l来判断，即：case when value=if1 then val1 when value=if2 then val2,,,when value=ifn then valn else val end; 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e9bb408c29ac4808c626be3a65863b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1445f01a386fbc2b34ecb24fb69031d6/" rel="bookmark">
			项目遇到的实际需求: java从信任所有证书到对server证书进行校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目上开发了一个rest api，放在了一台linux服务器上，并且这个服务器配置了证书，启用了https连接；在另一台服务器上写了一个功能需要去调用linux机器上的api。
项目里面自己封装了一个HttpsClient的类，用来发送https请求，并且在里面重写了TrustManager，方法体都为空，这样就不会对server的证书以及client的证书进行校验，能够顺利的从另一台服务器调用linux上的api。如下：
/** * * A default TrustManager which will trust any certificate. * */ private static class DefaultTrustManager implements X509TrustManager { @Override public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException { } @Override public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException { } @Override public X509Certificate[] getAcceptedIssuers() { return null; } } 但是上面的这种方法是不安全的，对server的证书以没有进行校验，就不能确定和自己进行通信的server，到底是不是真正的那个我想要通信的server，有可能是一个中间的，黑客部署的server，这样就会导致数据的安全问题。
于是需要对linux server端的证书进行认证，确认server是不是真正想要的server。
解决方案:
在linux服务器上，使用openssl生成了一个自签名的ssl证书(如何生成ssl证书)，用这个证书来启用linux server的https证书，并且将这个证书放到另一台的某个目录，然后另一台系统上的java代码，在发送请求的时候，将证书放到keyStore里面，这样java就能对这个证书进行认证。
下面是ChatGPT给出的示例代码: 读取指定的每一个路径上的证书，放到JKS格式的keyStore里面，然后用这个keyStore初始化TrustManager，最后用TrustManager创建sslcontext。
private SSLContext getSSLContext(JSONArray certificates, String protocol) throws Exception { SSLContext sc = null; if (certificates !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1445f01a386fbc2b34ecb24fb69031d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6a1f340fff3e1528da0f692d575d5f9/" rel="bookmark">
			mysql和oracle的区别有什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、宏观上:
1、Oracle是大型的数据库而Mysql是中小型数据库；Mysql是开源的，Oracle是收费的，且价格昂贵。
2、Oracle支持大并发，大访问量，是OLTP的最好的工具。
3、安装占用的内存也是有差别，Mysql安装完成之后占用的内存远远小于Oracle所占用的内存，并且Oracle越用所占内存也会变多。
二、微观上:
1、对于事务的支持
Mysql对于事务默认是不支持的，只是有某些存储引擎中如：innodb可以支持；而Oracle对于事物是完全支持的。
2、并发性
什么是并发性？并发性是OLTP(On-Line Transaction Processing联机事务处理过程)数据库最重要的特性，并发性涉及到资源的获取、共享与锁定。
Mysql，既支持表锁，也支持行级锁。表锁，对资源锁定的力度很大，如果一个session对一个表加锁时间过长，会让其他session无法更新此表的数据。
Oracle使用行级锁，对资源锁定的力度要小很多，只是锁定sql需要的资源，并且加锁是在数据库中的数据行上，不依赖于索引。所以oracle对并发性的支持要好很多。
3、数据的持久性
Oracle保证提交的事务均可以恢复，因为Oracle把提交的sql操作线写入了在线联机日志文件中，保存到磁盘上，如果出现数据库或者主机异常重启，重启Oracle可以靠联机在线日志恢复客户提交的数据。
Mysql默认提交sql语句，但是如果更新过程中出现db或者主机重启的问题，也可能会丢失数据。
4、事务隔离级别
MySQL是repeatable read的隔离级别，而Oracle是read commited的隔离级别，同时二者都支持serializable串行化事务隔离级别，可以实现最高级别的。
读一致性。每个session提交后其他session才能看到提交的更改。Oracle通过在undo表空间中构造多版本数据块来实现读一致性，每个session 查询时，如果对应的数据块发生变化，Oracle会在undo表空间中为这个session构造它查询时的旧的数据块。
MySQL没有类似Oracle的构造多版本数据块的机制，只支持read commited的隔离级别。一个session读取数据时，其他session不能更改数据，但可以在表最后插入数据。session更新数据时，要加上排它锁，其他session无法访问数据
5、提交方式
Oracle默认不自动提交，需要手动提交。Mysql默认自动提交。
6、逻辑备份
Mysql逻辑备份是要锁定数据，才能保证备份的数据是一致的，影响业务正常的DML(数据操纵语言Data Manipulation Language)使用；Oracle逻辑备份时不锁定数据，且备份的数据是一致的。
7、sql语句的灵活性
mysql对sql语句有很多非常实用而方便的扩展，比如limit功能(分页)，insert可以一次插入多行数据；Oracle在这方面感觉更加稳重传统一些，Oracle的分页是通过伪列和子查询完成的，插入数据只能一行行的插入数据。
8、数据复制
MySQL：复制服务器配置简单，但主库出问题时，丛库有可能丢失一定的数据。且需要手工切换丛库到主库。
Oracle：既有推或拉式的传统数据复制，也有dataguard的双机或多机容灾机制，主库出现问题是，可以自动切换备库到主库，但配置管理较复杂。
9、分区表和分区索引
MySQL的分区表还不太成熟稳定；Oracle的分区表和分区索引功能很成熟，可以提高用户访问db的体验。
10、售后与费用
Oracle是收费的，出问题找客服；Mysql是免费的的，开源的，出问题自己解决。
11、权限与安全
Oracle的权限与安全概念比较传统，中规中矩；MySQL的用户与主机有关，感觉没有什么意义，另外更容易被仿冒主机及ip有可乘之机。
12、性能诊断方面
Oracle有各种成熟的性能诊断调优工具，能实现很多自动分析、诊断功能。比如awr、addm、sqltrace、tkproof等 ；MySQL的诊断调优方法较少，主要有慢查询日志。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04283094bb40fd86fd5723e8331b2caf/" rel="bookmark">
			c&#43;&#43;学习笔记（9）多态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基本概念
分为两类：
区别：
动态多态满足条件
动态多态使用：
多态的优点：
案例一：利用多态实现计算器
纯虚函数和抽象类
案例二：制作饮品
虚析构和纯虚析构
虚析构和纯虚析构共性：
区别：
虚析构语法：
纯虚析构语法：
总结：
案例三 电脑组装
基本概念 c++面向对象三大特性之一
分为两类： 静态多态：函数重载和运算符重载属于静态多态，复用函数名
动态多态：派生类和虚函数实现运行时多态
区别： 静态多态的函数地址早绑定 编译阶段确定函数地址
动态多态的函数地址晚绑定，运行阶段确定函数地址
动态多态满足条件 1、有继承关系
2、子类重写父类的虚函数
动态多态使用： 父类的指针或者引用 执行子类对象
重写：函数返回值类型 函数名 参数列表 完全一致称为重写
#include &lt;iostream&gt; using namespace std; #include&lt;string&gt; //多态 //动物类 class Animal { public: //虚函数 virtual void speak() { cout &lt;&lt; "小动物在说话" &lt;&lt; endl; } }; //重写：函数返回值类型 函数名 参数列表 完全一致称为重写 class Cat:public Animal { public: void speak() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04283094bb40fd86fd5723e8331b2caf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f6b4a2302901ec15faa2d42261cb836/" rel="bookmark">
			Android Studio Flamingo编译项目问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统版本：macOS 13.4
Android Studio Flamingo | 2022.2.1 Patch 2
下载地址：Download Android Studio &amp; App Tools - Android DevelopersAndroid Studio provides app builders with an integrated development environment (IDE) optimized for Android apps. Download Android Studio today.https://developer.android.google.cn/studio
所需插件版本：3.2-8.0，gradle 8.0
更新gradle插件及环境变量 Mac环境变量配置 1. 进入当前用户的home路径：cd ~/ 2. 创建.bash_profile文件：touch .bash_profile 3. 打开.bash_profile文件：open .bash_profile 4. 使配置文件生效：source .bash_profile 编译问题 No matching variant of com.android.tools.build:gradle:8.0.2 was found. The consumer was configured to find a library for use during runtime, compatible with Java 8, packaged as a jar, and its dependencies declared externally, as well as attribute 'org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f6b4a2302901ec15faa2d42261cb836/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0958685177f4d3aa4abc1278ad3e905/" rel="bookmark">
			如何使用宝塔面板搭建网站（搭建宝塔页面）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 书接上回，咱们已经搭建好咱们的Linux服务器，接下来改是搭建宝塔页面的教程了。
这里我们需要一个域名，自行去各家云服务器购买域名（例如：腾讯云，阿里云，华为云等等）
购买一个域名之后我们就可以开始搭建了。
首先，启动你的Linux服务器。
在此页面下输入以下安装命令：
yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh
当出现下面内容时输入 y 按一下回车。
当出现以下界面时表示你已安装成功。
注意： 请记住这里的内外网面板地址，username（用户名），password（密码），最好复制粘贴保存到一个文档里，方便下次使用。如果忘记的话就在Linux服务器里输入bt就可以查看了。 这里如果显示的不一样，请把Linux服务器重新装一下系统。(必须是Linux系统)！ 提示：选中内容后右击鼠标就已经复制到粘贴板了，直接到文档里Ctrl+V粘贴就行了。
这里请记住内外网地址的端口，图上的是8888，你们的可能和我的不一样，记住自己的端口，去云服务器官网，找到自己的服务器 （这里演示的是华为云，各家平台页面不一样，但是都有这一项），找到安全组。
点击新建安全组 点击配置规则。
点击添加规则。
填好之后点击确定。
这时候我们新建一个浏览器页面，输入刚刚复制的外网面板地址，回车。
会出现以下界面
此时我们只需要把刚刚复制的username（用户名）填到账号里，password（密码）填写到密码里点击登录即可
这样，我们的宝塔页面就搭建完毕了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a80bf13ec639cb64c6dbd699a1d41980/" rel="bookmark">
			在Linux上部署KVM和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验前，我们关闭防火墙。
systemctl stop firewalld systemctl enable firewalld 如果我们之前安装过KVM或者有残余，可以先执行以下命令来清除一下。
yum remove `rpm -qa | egrep 'qemu|virt|KVM'` -y rm -rf /var/1ib/libvirt /etc/1ibvirt/ yum clean all &amp;&amp; yum makecache 清楚后我们在这一个干净环境下来安装KVM。
如果执行下面这条命令什么都没显示
lsmod | grep kvm #查看是否加载了kvm模块 #grep -E '(vmx|svm)' /proc/cpuinfo #这条命令也可以查看，显示有vmx或svm就表明支持虚拟化 可以看下虚拟化开启了没有，如果是物理机上的，可以进BIOS界面查看。 开启后再执行如下图所示：
执行下面命令来安装我们的KVM的一些依赖（KVM属于内核态，不需要安装。但是需要一些类似于依赖的）
yum install libvirt virt-install qemu-kvm -y 如果觉得下载慢，我们可以更换阿里源来安装，更换如下：
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo 安装好后，我们可以查看它的当前状态
systemctl status libvirtd | grep Active #查看KVM的状态 systemctl start libvirtd #开启KVM virsh list --all #查看KVM上创建的所有虚拟机 ps -ef|grep dns #libvirtd启动了一个dnsmasqp进程用来dhcp连接的，它作用在给虚拟机分配 IP 地址 可以看到，我们刚安装完，状态是active，还没有创建虚拟机，所有列表是空的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a80bf13ec639cb64c6dbd699a1d41980/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d5fa5e63127066a42ad9ecb6b333bc6/" rel="bookmark">
			Mysql触发器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主针对小白：如何在数据库有数据变动得时候及时得到内容。
MySQL触发器（Triggers）是一种数据库对象，它在指定的事件（例如插入、更新或删除数据）发生时自动执行一系列预定义的操作。触发器通常用于实施业务规则、数据完整性约束和自动化任务。
下面是MySQL触发器的一般语法：
CREATE TRIGGER trigger_name {BEFORE | AFTER} {INSERT | UPDATE | DELETE} ON table_name FOR EACH ROW trigger_body 其中：
trigger_name 是触发器的名称，你可以自定义。BEFORE 或 AFTER 关键字表示触发器在指定事件之前或之后执行。INSERT、UPDATE 或 DELETE 关键字表示触发器与哪种操作相关联。table_name 是触发器所在的表名。FOR EACH ROW 表示触发器将为每个受影响的行执行。trigger_body 是触发器的具体操作代码，可以包含一系列的SQL语句。 要查看已创建的触发器列表，可以使用以下命令：
SHOW TRIGGERS; 要删除触发器，可以使用以下语法：
DROP TRIGGER IF EXISTS trigger_name; 请注意，在MySQL中，触发器的使用可能受到特定版本和配置的限制。在创建和使用触发器之前，请确保你有足够的权限，并且了解数据库的配置和限制。
下面是一个示例，展示如何创建一个触发器，使得对表 testA 的 INSERT、UPDATE 和 DELETE 操作能够同步到 testB 表：
-- 创建触发器，同步插入操作 CREATE TRIGGER sync_insert_testA_to_testB AFTER INSERT ON testA FOR EACH ROW BEGIN INSERT INTO testB (column1, column2, column3) VALUES (NEW.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d5fa5e63127066a42ad9ecb6b333bc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb00a26ac1b729aedfbc924921e5d2c9/" rel="bookmark">
			MySQL和Oracle的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Oracle是大型数据库，体系比较庞杂。Mysql是中小型数据库，而且是开源的
2.Oracle占有内存空间大，Mysql占有空间比较小
3.Oracle支持大并发访问量，是OLTP最好的工具，Mysql并发小，面对大访问量可以做分表分库优化
4.Oracle没有自动增长类型，Mysql一般使用自动增长类型
5.Oracle处理翻页的SQL语句就比较繁琐了。每个结果集只有一个ROWNUM字段标明它的位置,并且只能用ROWNUM&lt;100,不能用ROWNUM&gt;80，MYSQL处理翻页的SQL语句比较简单，用LIMIT开始位置,记录个数
6.MYSQL里用 字段名 like '%字符串%'
ORACLE用 字段名like '%字符串%'但不能使用索引,速度不快。（这种方法不能使用索引）
7.事物提交方式不同，oracle默认不自动提交，需要用户手动提交。Mysql默认是自动提交。不支持事物。
Mysql默认自动提交，也就是你提交一个query，他就直接执行，我们可以通过：
set autocommit=0 禁止自动提交
set autocommit=1 开启自动提交
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b10f2cdf17f7a5eba8e689dd09cbfb8/" rel="bookmark">
			OpenGL 学习笔记(六)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、OpenGL索引缓冲对象(EBO)
如果我们要用OpenGL绘制一个正方形，能想到的是用两个三角形来拼凑，这个时候就要用到 EBO 了。
1、VBO、VAO 与 EBO 之间的联系与区别
(1).顶点缓冲对象 VBO 是在显卡存储空间中开辟出的一块内存缓存区，用于存储顶点的各类属性信息，如顶点坐标、顶点法向量、顶点颜色数据等。在渲染时，可以直接从 VBO 中取出顶点的各类属性数据，由于 VBO 在显存而不是在内存中，不需要从CPU传输数据，所以处理效率更高。所以可以理解为 VBO 就是显存中的一个存储区域，可以保持大量的顶点属性信息。并且可以开辟很多个 VBO ，每个 VBO 在 OpenGL 中有它的唯一标识 ID ，这个 ID 对应着具体的 VBO 的显存地址，通过这个 ID 可以对特定的 VBO 内的数据进行存取操作。
(2).VAO 是一个保存了所有顶点数据属性的状态结合，它存储了顶点数据的格式以及顶点数据所需的 VBO 对象的引用。
因为 VBO 保存了一个模型的顶点属性信息，每次绘制模型之前需要绑定顶点的所有信息。当数据量很大时，重复这样的动作变得非常麻烦。VAO 可以把这些所有的配置都存储在一个对象中，每次绘制模型时，只需要绑定这个 VAO 对象就可以了。另外，VAO 本身并没有存储顶点的相关属性数据，这些信息是存储在 VBO 中的，VAO 相当于是对很多个 VBO 的引用，把一些 VBO 组合在一起作为一个对象统一管理。
(3).索引缓冲对象 EBO 相当于 OpenGL 中的顶点数组的概念，是为了解决同一个顶点多次重复调用的问题，可以减少内存空间浪费，提高执行效率。当需要使用重复的顶点时，通过顶点的位置索引来调用顶点，而不是对重复的顶点信息重复记录，重复调用。
EBO 中存储的内容就是顶点位置的索引 indices，EBO 跟 VBO 类似，也是在显存中的一块内存缓冲器，只不过 EBO 保存的是顶点的索引。
2、EBO
● 首先，我们现在要绘制正方形，则需要 4 个顶点。在主函数中我们将 4 个顶点的位置信息给出。并用顶点位置的索引 indices 数组将它们 “缝合” 起来。示意图如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b10f2cdf17f7a5eba8e689dd09cbfb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5f94a46e75222ea30d8babf9b8a1c90/" rel="bookmark">
			springboot如何热部署（无需重启即可进行重新编译）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用 spring-boot-devtools 模块：
Spring Boot DevTools 模块可以在修改代码后自动重新编译应用并且无需重启。在 pom.xml 文件中添加如下依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 在 application.properties 或 application.yml 中添加如下配置：
spring.devtools.restart.enabled=true spring.devtools.restart.additional-paths=src/main/java 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd7ebf37ef33b3769a88ef6e45fd7bc8/" rel="bookmark">
			Python（5）正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言正则表达式的步骤匹配模式： flags=xxx反斜杠：\分组 一、re模块常用方法1.编译compile(pattern[, flags])2.匹配match(pattern,string[,flags])3.匹配search(pattern,str[,flags])4.匹配findall(pattern,str[,flags])5.分割split(pattern,str[maxsplit=0,flags])6.替换sub(pat,repl,str,count=0,flags=0) 二、匹配练习习题集一习题集二 前言 正则表达式的步骤 确定模式有几个子模式各部分的字符分类是什么子模式怎么重复是否有外部位置的限制是否有内部制约关系 正则表达式本质上是一门语言，它不从属与Python！Python只是将他人写好的正则引擎集成到了语言内部，大多数编程语言都是这么干的！
正则表达式诞生的时间很长，应用非常广泛，是业界公认的字符串匹配工具。虽然有不同版本的内部引擎，但基本通用，也就是说，你在Python内写的正则表达式，可以移植到Linux的shell，Java语言等任何支持正则的场景中去。
正则表达式默认从左往右匹配。
正则表达式默认是贪婪模式。
正则表达式默认在匹配到了内容后，则终止匹配，不继续匹配。
对同一个问题，编写的正则表达式不是唯一的！
匹配模式： flags=xxx 缩写全称含义AASCIIASCII字符模式IIGNORECASE不区分大小写LLOCALE本地化识别local-aware匹配MMULTILINE多行匹配，每一行匹配一次,影响^ $SDOTALL使 . 字符能够匹配包括 \n 换行符的所有字符，针对多行匹配XVERBOSE该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解（emm 有点点废话）UUNICODE根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B 史上最全ASCII码对照表0-255（%d）
Unicode字符代码
字符集与编码系列：Unicode字符集
反斜杠：\ print(re.match(r"\d\wabc",str)
print(re.match(“\d\wabc”,str)
原字符串\\\\----&gt;表示\\----&gt;正则表达式中表示 很复杂！很恼火！
如果需要匹配 “D:\abc\s\1.txt",可以写成：
print(re.search(r"\w:\\w+\\w+\\w+.\w+",“sadaD:\abc\s\1.txt”))
python提供原生字符串的功能， 很好地解决了这个问题，这个例子中的正则表达式可以使用r"\“表示。同样，匹配一个数字的”\d"可以直接写成r"\d"。有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。
分组 把正则表达式分成几组，这样就可以重复某个部分
分组正则匹配(…)捕获一个组(?P…)捕获一个组，命名name(?:…)不捕获组\Y匹配第Y个匹配的组，可以数左括号的个数(?P=name)匹配名为name的组(?#…)注释 一、re模块常用方法 引用博客的传送门
方法描述返回值compile(pattern[,flags])根据包含正则表达式的字符串创建模式对象re对象search(pattern,string[,flags])在字符串中查找第一个匹配到的对象或者nonematch(pattern,string[,flags])在字符串中开始处匹配返回re对象或nonesplit(pattern,string[,maxsplit=0,flags])分割字符串返回分割后的字符串列表listfindall(pattern,string,flags)字符串中所有匹配项返回字符串列表sub(pat,repl,string[,count=0,flags])repl替换所有的pat返回替换后的string 1.编译compile(pattern[, flags]) compile一个re对象 ，提高效率！
返回的re对象就可以正常调用re模块中的噶种方法！
根据包含正则表达式的字符串创建模式对象
当你需要多次匹配string时候，比如需要for的时候，就可以提前compile
f=re.compile(r"\d{8}--\d{4}--\d{4}") for i in str: f.match(i) 2.匹配match(pattern,string[,flags]) 在字符串的开始位置进行匹配，不成功就返回None，这个我个人认为在代码编辑中不常用该方法。
** group()方法**
group(0) – 输出原字符串；； group(i) --从pattern左边数第i个左括号中匹配的字符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd7ebf37ef33b3769a88ef6e45fd7bc8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/129/">«</a>
	<span class="pagination__item pagination__item--current">130/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/131/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>