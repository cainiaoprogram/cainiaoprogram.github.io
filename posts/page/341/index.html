<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d055ed07cf598a0e89fa8f50197f1bdb/" rel="bookmark">
			vue 全局方法（单个和多个方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、单个方法 新建goBack.js var goBack = function() { xxx } export default goBack; main.js中引入并定义 import goBack from '../static/js/goBack'; Vue.prototype.$back = goBack; //用$与组件内自定义的函数区分，其他符号也可以 组件中使用 go: function() { this.$back(); } 二、多个方法 新建all.js exports.install = function(Vue, options) { Vue.prototype.$back = function() { //全局函数1 xxx }; Vue.prototype.$pushH = function() { //全局函数2 xxx }; Vue.prototype.$pushHN = function() { //全局函数3 xxx }; }; main.js中引入并注册 import all from '../static/js/all'; Vue.use(all);//将全局函数当做插件来进行注册 组件中使用 go: function() { this.$back(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b9c8cf5ad631455356136f0d4a427db/" rel="bookmark">
			python serverless_Serverless 实战：用 20 行 Python 代码轻松搞定图像分类和预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像分类是人工智能领域的一个热门话题，通俗来讲，就是根据各自在图像信息中反映的不同特征，把不同类别的目标区分开。图像分类利用计算机对图像进行定量分析，把图像或图像中的每个像元或区域划归为若干个类别中的某一种，代替人的视觉判读。
在实际生活中，我们也会遇到图像分类的应用场景，例如我们常用的通过拍照花朵来识别花朵信息，通过人脸匹对人物信息等。通常，图像识别或分类工具都是在客户端进行数据采集，在服务端进行运算获得结果。因此，一般都会有专门的 API 来实现图像识别，云厂商也会有偿提供类似的能力：
华为云图像标签
腾讯云图像分析
本文将尝试通过一个有趣的 Python 库，快速将图像分类的功能搭建在云函数上，并且和 API 网关结合，对外提供 API 功能，实现一个 Serverless 架构的 " 图像分类 API"。
入门 ImageAI
首先，我们需要一个依赖库：ImageAI。
什么是 ImageAI 呢？其官方文档是这样描述的：
ImageAI 是一个 python 库，旨在使开发人员能够使用简单的几行代码构建具有包含深度学习和计算机视觉功能的应用程序和系统。ImageAI 本着简洁的原则，支持最先进的机器学习算法，用于图像预测、自定义图像预测、物体检测、视频检测、视频对象跟踪和图像预测训练。ImageAI 目前支持使用在 ImageNet-1000 数据集上训练的 4 种不同机器学习算法进行图像预测和训练。ImageAI 还支持使用在 COCO 数据集上训练的 RetinaNet 进行对象检测、视频检测和对象跟踪。 最终，ImageAI 将为计算机视觉提供更广泛和更专业化的支持，包括但不限于特殊环境和特殊领域的图像识别。
简单理解，就是 ImageAI 依赖库可以帮助用户完成基本的图像识别和视频的目标提取。不过，ImageAI 虽然提供一些数据集和模型，但我们也可以根据自身需要对其进行额外的训练，进行定制化拓展。
其官方代码给出了这样一个简单的 Demo:
from imageai.Prediction import ImagePredictionimport osexecution_path = os.getcwd() prediction = ImagePrediction()prediction.setModelTypeAsResNet()prediction.setModelPath(os.path.join(execution_path, "resnet50_weights_tf_dim_ordering_tf_kernels.h5"))prediction.loadModel()predictions, probabilities = prediction.predictImage(os.path.join(execution_path, "1.jpg"), result_count=5 )for eachPrediction, eachProbability in zip(predictions, probabilities):print(eachPrediction + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b9c8cf5ad631455356136f0d4a427db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18bcf3648b699af059bd14a974bd136a/" rel="bookmark">
			基于python的亮度检测,使用Python调整基于直方图的曝光（亮度/对比度）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I'm trying to make a program with a GUI (most likely using Kivy) in Python to match the exposure of two images. I want to display both images (RGB or grayscale) side by side with their corresponding histograms and have a slider to be able to control the exposure on the selected image. I would like some advise on how to go about this.
So far I have read several posts and there seem to be several ways to approach calculating the histogram of an image (numpy, matplotlib, openCV, and PIL), however I'm confused about which would be best (least libraries/dependencies to install) for me to implement.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18bcf3648b699af059bd14a974bd136a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03ad8cae64b96ddc2b740d532864b726/" rel="bookmark">
			usb调试软件_【生产力工具】做自媒体不容错过的软件，真生产力工具！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家应该都听说过华为之前发布会出现的一个新功能——多屏协同，就是一个能实现在电脑页面操作手机的神器，不仅可以随意操作手机，还能实现电脑手机间拖拽传输文件。
图片源自网络
这个神器真的是一件不折不扣的生产力工具，尤其是对于做自媒体的朋友们来说，更是一件必备的工具了吧。
给大家介绍的是一款无需root，开源的免费软件，支持有线连接和无线连接。
软件名：QtScrcpy
软件开发者：Barry
网站链接：见文末，不要忘记关注我哦！
先给大家展示一下，软件使用的界面
使用方法：
进入官网→软件压缩包进行下载→解压→安装，无需在手机端安装任何工具，手机端只需要打开usb调试模式就好，具体如何打开见后文，下面是图解。
第一个下载链接是mac端的，所以这款软件是支持mac的，第二个链接Windows64位，第三个是Windows32位，先自行查看自己的电脑是多少位的处理器，然后选择相应的文件进行下载。
解压后，安装鼠标光标指示的应用文件。
用数据线连接手机，打开usb调试模式，以小米手机为例，先连点7下miui版本，打开开发者模式，然后进入设置找到usb调试模式，打开相应的功能，如果不是很清楚，请自行百度。
按照图片顺序点击，第一步点击后在设备序列号后会出现你的设备，然后点击第二步，就能完美连接了，这个软件最多支持同时连接16台安卓设备。
我觉得这个软件对于不做自媒体的朋友最大的用处就是，能够直接连接电脑，通过映射电脑键盘，在电脑上玩刺激战场，这个真的太刺激了吧，再也不用花好几百去买手机的外设了，此乃省钱利器！
最后奉上大佬的，也就是本期软件的下载链接：https://gitee.com/Barryda/QtScrcpy/releases
真的感谢每一位软件的开发者，他们的默默奉献让我们普通人也能体验到前端的科技，向每一位开发者致敬！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c208d7cbb90042ef5423c7bd5d8005/" rel="bookmark">
			dict zip python_zip()和dict()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zip()函数用于将可迭代的对象作为参数，将对象中的元素打包成一个个元组，然后返回由这些元组组成的列表。
zip()的使用方法：
&gt;&gt;&gt;a = [1,2,3]
&gt;&gt;&gt; b = [4,5,6]
&gt;&gt;&gt; c = [4,5,6,7,8]
&gt;&gt;&gt; zipped = zip(a,b) # 打包为元组的列表
[(1, 4), (2, 5), (3, 6)]
&gt;&gt;&gt; zip(a,c) # 元素个数与最短的列表一致
[(1, 4), (2, 5), (3, 6)]
&gt;&gt;&gt; zip(*zipped) # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式
[(1, 2, 3), (4, 5, 6)]
dict()函数
&gt;&gt;&gt;dict() # 创建空字典
{}
&gt;&gt;&gt; dict(a='a', b='b', t='t') # 传入关键字
{'a': 'a', 'b': 'b', 't': 't'}
&gt;&gt;&gt; dict(zip(['one', 'two', 'three'], [1, 2, 3])) # 映射函数方式来构造字典
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04c208d7cbb90042ef5423c7bd5d8005/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ed5d5155c6a3a1a1de410017056810a/" rel="bookmark">
			ug 二次开发 由一个对话框打开另一个对话框_ug经典使用技巧总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Ug NX3模型树可以改成以前版本一样
Ug NX3模型树可以改成以前版本一样
在菜单Tool下的partnavigator子项中timestamp order点下就可以了.
2、NX3图标改为到原来简洁的nx1图标效果
进入安装目录下的ugii文件夹，修改bitmaps文件夹名字，可以改成任何名字。（例如：改成bitmaps-1）
另外，想把图标效果改为到原来的NX3的效果，只要改回到原来的bitmaps文件夹名字就可以了。
再补充另外一种方法：
也可实现同样的效果。
操作步骤：在win2000中，按快捷键Ctrl+PauseBreak，添加一个系统变量：
(1)设置变量名：UGII_BITMAP_QUALITY
设置变量值：HIGH （说明：显示华丽的界面效果，即同nx3一样）
(2)设置变量名：UGII_BITMAP_QUALITY
设置变量值：STANDARD （说明：显示传统的界面，即同nx1一样）
(3)设置变量名：UGII_BITMAP_QUALITY
设置变量值：APPLICATION （说明：使用预定义模式）
3、如何在一张图纸上既有装配图、又有各个零件图 将各零部件分层设置。
4、出工程图时，如何屏蔽掉多余的轮廓线？
方法一：选中要修改的视图---按右键---选择“型式”--出现“查看形式”对话框 ---选择“光滑边”栏---把“光滑边”的勾去掉就好了
方法二：选中要修改的视图---按右键---选择“视图相关编辑”--出“视图相关编辑”对话框 --可以删除修改任何线
方法三：在ug_metic.def中修改，使第一种方法的默认选项为”光滑边“不显示
方法三：NX3.0版本中：打开UG，新建文件，选择“文件”----“用户工具”----“用户默认” 打开““用户默认””对话框-----在左边一栏选择“制图”-----“视图”，在右边选择“光滑边” 把勾去掉就行了,重新启动UG就行了
5、UG工具栏备份恢复法
在布局好自己的工具栏之后退出UG,然后打开"C:Documents and Settingsusername(个人帐户)Local SettingsApplication DataUnigraphics SolutionsNX",把user.mtx给备份一下即可,下一次想用的时候直接覆盖现有文件即可,此法对UGNX3有用。
6、将UG-Drafting无缝转换成DXF文件的具体步骤
(1) 在UG中，打开要转换的零部件，进入Drafting,选择要转换的图 纸名称。
(2) 选择File-Export-CGM，这时出现输入CGM文件名称的对话框，要求用户指定一个文件名称 ，输入文件名filename（扩展名可以 不输入，系统会自动加上）后，再OK。
(3) 这时出现转换设置对话框，先在图形窗口中使用Fit，确信 要转换的内容全部出现在图 形窗口中；再按下面设置对话框中各选项： source: display CGM size: scale factor 1 pen selection: width text selection: polyline(必须设置，否则不能显示中文) VCD coordinates: real fonts: 4 cals 然后OK，这样就生成了CGM文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ed5d5155c6a3a1a1de410017056810a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e60096477b6f03f917f45d3607992110/" rel="bookmark">
			PyMol安装教程(Windows10&#43;Python2.7)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyMol安装教程(Windows10) pymol的使用需要基于python环境，本教程从python环境配置开始，基于python2.7进行安装。如果您曾经安装过python，可以直接进入pymol安装步骤，但是要留意下载对应版本的whl文件。
本次使用到的文件：链接：https://pan.baidu.com/s/1aPQggII3HvvTM6X3j-wlhA 提取码：1234 Python环境配置 1.下载与安装 首先进入python官网的Windows版本下载页面 点这里
点击红框里的链接下载2.7版本的python。
红框里的两个文件需要根据系统版本选择。查看操作系统版本的方法：双击进入“我的电脑”，空白处右键“属性”，找到系统类型，如果为“64位系统，则选择下图中的“Windows x86-64 MSI Installer” ；否则选择另一个进行下载。
将下载得到的文件双击运行，开始安装。第一个界面选择Install for all users。
然后是选择安装路径(红框里的东西)的环节，默认一般为C:\Python27\，如果想装在别的位置要注意路径不能包含中文名的文件夹(像 D:\学习\Python 这样的路径是不可以的)。
之后一路next就好了。点Finish结束，就快要装好了。
2.配置环境变量 首先找到安装python的文件夹，即上文的安装路径，复制红框里的内容。
之后还是进入“我的电脑”，空白处右键选择“属性”。选择红框里的“高级系统设置”。
按照箭头的指示，先点击“系统属性”中的“环境变量”；然后在“环境变量”中找到“Path”，点击下面的编辑；点击新建，粘贴刚刚复制的路径。之后一路确定只可。
这里安装和配置就完成了。可以通过以下的方法来验证是否安装成功：同时按住小窗户键+R键，在弹出的窗口中输入cmd并回车，在弹出的黑框界面输入：
python -V 如果出现了python版本即按照正确，可以关掉了；也可以再输入“python”查看python版本信息。
安装PyMol 1.下载whl文件 点这里下载
在页面中找到如下三个文件进行下载。numpy版本无需关注，27代表python2.7，amd64代表64位cpu，如果不确定选择含有win32字样的版本即可。
三个文件分别位于以下两个个分栏：NumPy，Pymol-open-source。
将下载好的三个文件放在一个英文路径的文件夹中，例如C:\pymol，然后进入cmd界面(小窗户+R，输入cmd回车)，分别输入以下三条命令(复制，并在命令行界面点击右键)：
C:\Python27\python.exe -m pip install C:/pymol/numpy-1.16.6+mkl-cp27-cp27m-win_amd64.whl C:\Python27\python.exe -m pip install C:/pymol/pymol-2.1.0-cp27-cp27m-win_amd64.whl C:\Python27\python.exe -m pip install C:/pymol/pymol_launcher-2.1-cp27-cp27m-win_amd64.whl 如果出现successflly installed字样则说明安装成功。
关于三条命令，红框部分是python.exe的位置，如果您之前修改了python的安装路径，找到它的位置，并检查是否有意python.exe，然后分别修改三条命令中的红框内容为你的路径；绿色框是我们存放whl文件的位置，蓝色框为文件名称，这些都可以按您实际的安装位置进行修改。
至此pymol安装完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc9be6c0751161e15045a6063489e58a/" rel="bookmark">
			mysql 一次插入多条数据和一次一条数据效率对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql 一次插入多条数据和一次一条数据效率对比 insert into `user`(name,password) VALUES ("12","kk啊"),("15","好好学习"),("13","天天向上"); insert into `user`(name,password) VALUES ("12","kk啊"); 其实时间是一样的，为什么呢？因为sql执行的次数是一样的。 用处，在进行数据转移的时候，很多时候插入数据嘛，都会用这个一条一条插入，是吧，很慢，真的很慢，而且为了防止数据库崩溃，还得5000条或者一万条插入一下，为什么，因为sql执行次数的原因，所以可以在后端把数据拼成这样的sql，就执行一次，因为sql是String类型，长度可以很长，然后运行sql，这个时候稍微注意一点就可以，一个小小的细节，程序会快很多倍。 对了在进行数据迁移的时候还有更快的譬如: 浅析INSERT INTO SELECT用法及多数据源操作.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c13ec80747ef3bbbb79d80ffb83a171/" rel="bookmark">
			数通基础-二层交换原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MAC地址 MAC地址有48bit，通常被表示为十六进制格式。
MAC地址分为单播、组播及广播MAC地址三类。
单播MAC地址全球唯一，由 IEEE对这些地址进行管理和分配。
每个单播MAC地址由两部分组成，其中前24bit代表OUI（组织唯一标识），剩下的24位由厂商自己分配。
以太网二层交换机 主要功能 使得终端用户能够接入网络；
维护MAC地址表；
数据帧的转发及过滤；
二层环路避免及链路冗余性。
交换机转发数据帧
收到单播数据帧（mac地址表存在记录），根据mac地址表指定接口转发。收到单播数据帧（mac地址表不存在记录），复制数据帧，在除收到数据帧以外的接口进行泛洪。收到广播数据帧，在除收到数据帧以外的接口进行泛洪。 工作原理 PC1、PC2连接在同一台二层交换机上。
以太网中基于MAC地址通信。
初始情况下，交换机的MAC地址表是空的。
PC1发送数据帧给PC2（假设PC1已经知道了PC2的MAC地址）。
交换机在GE0/0/1口接收帧后，在MAC地址表中查询该帧的目的MAC地址。
MAC地址表中没有任何表项匹配该目的MAC地址，于是交换机将这个数据帧进行泛洪（将数据帧的拷贝从所有接口发送出去，除了接收该帧的接口）。
同时，交换机学习该帧的源MAC地址并创建MAC地址表项，将该MAC地址与接收该帧的GE0/0/1接口进行关联。
连接在交换机其他接口的PC都会收到这个数据帧，但是它们会丢弃该数据帧，因为这并不是发送给它们的，PC2接收并处理这个帧。
现在PC2向PC1回复数据，数据帧发往交换机。
交换机收到数据帧后，首先在MAC地址表中查询该帧的目的MAC地址，发现有一个匹配的表项，于是将数据帧从GE0/0/1接口转发出去。
VLAN VLAN（Virtual Local Area Network）即虚拟局域网，是将一个物理的LAN在逻辑上划分成多个广播域的通信技术。VLAN内的主机间可以直接通信，而VLAN间不能直接互通，从而将广播报文限制在一个VLAN内。
不同的VLAN是不同的广播域，通常使用不同的IP网段。
可根据业务需求灵活的进行VLAN的规划。
不同的VLAN之间无法进行二层互访。
VLAN知识点小结 一个VLAN中所有设备都是在同一广播域内，不同的VLAN为不同的广播域。
VLAN之间互相隔离，广播不能跨越VLAN传播，因此不同VLAN之间的设备一般无法直接互访（二层互访），不同VLAN间需通过三层设备实现相互通信。
一个VLAN一般为一个逻辑子网。
VLAN中成员多基于交换机的端口分配，所谓的VLAN划分，通常指的是将交换机的接口添加到特定的VLAN中，从而该接口所连接的设备也即加入到了该VLAN。
VLAN是二层交换机的一个非常基本的工作机制。
交换机接口类型（Link-type） Access Access接口只能加入一个VLAN，该VLAN又被称为Access接口的缺省VLAN。
Access接口只发送无标记帧，且只接收无标记帧或打了缺省VLAN Tag的标记帧。
Access接口常用于连接PC、服务器或其他终端，或路由器等设备。
Access接口只能加入一个VLAN，该种类型的接口通常用于连接PC、服务器及路由器等设备。
Trunk 当一条链路需要承载多VLAN数据的时候，可将该链路配置为Trunk链路。
Trunk链路两端的接口是Trunk类型的接口。两端交换机需采用相同的干道协议。
Trunk链路一般见于交换机之间或交换机与路由器之间。
Trunk接口可以加入多个VLAN，可以收发多个VLAN的报文。一般用于交换机之间的互联接口，也用于交换机与以太网子接口对接。
Hybrid Hybrid接口也可以收发多个VLAN的报文，而且可以指定该接口在发送特定VLAN的报文时是否携带Tag。
802.1q IEEE 802.1q以及VLAN Tagging属于互联网下IEEE 802.1的标准规范，允许多个网桥(Bridge)在信息不被外泄的情况下公开的共享同一个实体网上。IEEE 802.1q-英文缩写写为dot1q，经常在实现以太网封装协议的架构下被提及。以下是打上VLAN Tag的数据帧
端口的缺省ID（PVID） 每个Access、Trunk及Hybrid的接口都有一个接口缺省VLAN-ID，称为PVID（Port Default VLAN ID），当接口接收到无标记帧时，为数据帧打上PVID。
对于Access类型的接口，PVID缺省为1，由于Access接口只能加入一个VLAN，因此PVID也即该接口所属的VLAN。
对于Trunk及Hybrid类型端口，PVID缺省也为1，这两种接口都允许多个VLAN数据帧通过，当接口收到无标记帧时，为数据帧打上PVID。
原始的以太网数据帧（或无标记帧、Untagged帧）：指的是采用以太网封装的数据帧，例如普通PC或服务器网卡收发的数据帧。
802.1Q数据帧（或标记帧、携带VLAN Tag的数据帧、Tagged帧）：指的是插入了802.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c13ec80747ef3bbbb79d80ffb83a171/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f7ee14ab16e8c8164755f0735e58932/" rel="bookmark">
			excel中如何运用新建格式规则比较两个表格中的数值_Excel表格里面常用的5个技巧，越早知道越好！...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在职场当中Excel办公软件是我们每天都会接触上的，虽然Excel里面一些比较基础的操作我们都会，但是还有一些能够帮助我们提升工作效率的Excel技巧还是要多了解一下！
那么今天小编就作为一名分享者，在这为大家分享一下个人觉得在职场办公当中会经常使用上的一些技巧，希望能够帮大家一些绵薄之力！
1、 自动添加Excel边框线 在Excel表格里面其实我们可以自动设置边框线，意思就是当我们在Excel里面录入内容时候，边框就自动设置好了!
设置步骤：
选中将要设置的区域-点击【条件格式】-【新建规则】-规则类型选中最后一个【使用公式确认要设置格式的单元格】-输入公式：=A1&lt;&gt;"" – 点击右下角【格式】-设置边框颜色以及边框即可！
2、 一键删除边框 添加边框说完了我们说说如何才能一键删除边框呢？其实添加边框麻烦，但是如何想要删除边框的话就非常简单了，只需要一组快捷键就可以帮你完成！
设置步骤：
一键选中表格边框内容，依次按下键盘Ctrl+Shift+-(减号)，即可一键删除表格里面的所有边框啦！
3、 如何填充相同的数据 我们在编辑Excel表格中，经常需要记录序号或者日期等数据，不过当我们下拉填充数据时候常常会发现填充的数据会依次根据单元格递增！
例如：
设置步骤：
只需要当我在填充数据时候，按住键盘Ctrl键即可！
4、 ＞3000000显紫色 如何才能快速区Excel里面的表格数据呢？其实还是在条件格式里面设置，只需要新建一个规则就可以完成！
设置步骤：
依次点击【条件格式】-【新建规则】-点击使用公式确认要设置格式的单元格-输入公式：=$E2&gt;3000000，然后在格式里面选择紫色即可！
5、 汇总合并单元格数据 在Excel里面如何才能汇总合并单元格里面的数据呢？一般的设置都是无法实现的，那么如何才能帮助我们呢？其实直接引用Excel里面函数就OK啦！
设置步骤：
输入函数：=SUM(C2:C11)-SUM(D3:D11)，函数前面的坐标是对应的汇总数据，后面坐标是你汇总显示的空单元格，输入进去后按住快捷键【Ctrl+Enter】就可以啦！
今天为大家分享的Excel函数就这些啦！感兴趣的小伙伴可以收藏学习一下，帮你快速提升工作效率呦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebef23110d9e7d242719ce9db147b4ff/" rel="bookmark">
			C&#43;&#43;值返回和引用返回的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果是值返回，一定是创建了一个新对象，并返回新对象。如果是引用返回，一定不会创建新对象，返回的是之前的对象。 现有一个Point类
class Point { public: void setX(int x)//公共接口 { X = x; } int getX() { return X; } void setY(int y) { Y = y; } int getY() { return Y; } Point addXY_1(int x,int y)//值返回 { X += x; Y += y; return *this;//this是指针，*this就是解引用，返回调用这个函数的对象。 } Point&amp; addXY_2(int x,int y)//引用返回 { X += x; Y += y; return *this; } private: int X;//私有属性 int Y; }; 实例化Point类的对象，并设置其属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebef23110d9e7d242719ce9db147b4ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70bcc0d60628f62369903b946cb35e17/" rel="bookmark">
			openssl升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要部署nginx的https环境，之前是yum安装的openssl，版本比较低，如下：
[root@nginx ~]# yum install -y pcre pcre-devel openssl openssl-devel gcc [root@nginx ~]# openssl version -a OpenSSL 1.0.1e-fips 11 Feb 2013 built on: Wed Mar 22 21:43:28 UTC 2017 platform: linux-x86_64 options: bn(64,64) md2(int) rc4(16x,int) des(idx,cisc,16,int) idea(int) blowfish(idx) compiler: gcc -fPIC -DOPENSSL_PIC -DZLIB -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -DKRB5_MIT -m64 -DL_ENDIAN -DTERMIO -Wall -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic -Wa,--noexecstack -DPURIFY -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DWHIRLPOOL_ASM -DGHASH_ASM OPENSSLDIR: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70bcc0d60628f62369903b946cb35e17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/358f4eea704aefb18f33081ee7ccdc2d/" rel="bookmark">
			MATLAB绘制音频波形及频谱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [x,Fs]=audioread('test.mp3'); x = x(:,1); x = x'; N = length(x);%求取抽样点数 t = (0:N-1)/Fs;%显示实际时间 y = fft(x);%对信号进行傅里叶变换 f = Fs/N*(0:round(N/2)-1);%显示实际频点的一半，频域映射，转化为HZ subplot(211); plot(t,x,'g');%绘制时域波形 xlabel('Time/s');ylabel('Amplitude'); title('信号的波形'); grid; subplot(212); plot(f,abs(y(1:round(N/2)))); xlabel('Frequency/Hz');ylabel('Amplitude'); title('信号的频谱'); grid; 参考文献：
https://blog.csdn.net/u010288945/article/details/46619069 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd2129f9ccf56265ac237e97a3670ede/" rel="bookmark">
			vscode  c&#43;&#43;配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.vscode c++配置
1. task.json
{ "version": "2.0.0", "tasks": [{ "label": "g++", "command": "g++", "args": [ "-g", "${file}", "-o", "${fileDirname}/${fileBasenameNoExtension}.exe" ], "problemMatcher": { "owner": "cpp", "fileLocation": [ "relative", "${workspaceRoot}" ], "pattern": { "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$", "file": 1, "line": 2, "column": 3, "severity": 4, "message": 5 } }, "group": { "kind": "build", "isDefault": true } } ] } 1. launch.json
{ "version": "0.2.0", "configurations": [ { "name": "(gdb) Launch", // 配置名称，将会在启动配置的下拉菜单中显示 "type": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd2129f9ccf56265ac237e97a3670ede/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25adc8f77ae730d050be01e8f469ea4d/" rel="bookmark">
			==和equals的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本类型存储在栈中,对象存储在堆中.
equals与==的区别详解：
==比较的是变量(栈)中存放的对象的(堆)内存地址，即引用的地址，比较的是真正意义上的指针操作。
equals比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。
String s=“abcd"是一种非常特殊的形式,和new 有本质的区别。它是java中唯一不需要new 就可以产生对象的途径。以String s=“abcd”;形式赋值在java中叫直接量,它是在常量池中而不是象new一样放在压缩堆中。 这种形式的字符串，在JVM内部发生字符串拘留，即当声明这样的一个字符串后，JVM会在常量池中先查找有有没有一个值为"abcd"的对象,如果有,就会把它赋给当前引用.即原来那个引用和现在这个引用指点向了同一对象, 如果没有,则在常量池中新创建一个"abcd”,下一次如果有String s1 = “abcd”;又会将s1指向"abcd"这个对象,即以这形式声明的字符串,只要值相等,任何多个引用都指向同一对象.
而String s = new String(“abcd”);和其它任何对象一样.每调用一次就产生一个对象，只要它们调用。
也可以这么理解: String str = “hello”; 先在内存中找是不是有"hello"这个对象,如果有，就让str指向那个"hello".
如果内存里没有"hello"，就创建一个新的对象保存"hello". String str=new String (“hello”) 就是不管内存里是不是已经有"hello"这个对象，都新建一个对象保存"hello"。
本文出处:https://blog.csdn.net/qq_36522306/article/details/80550210
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edf66e76155aae69b5188a414456d93d/" rel="bookmark">
			Centos 6无法使用yum解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 找了很多解决方案，基本都是说添加DNS或者修改ONBOOT值的，但是我依然不能成功，错误提示的最后一行都是一样的，希望和我初学遇到一样困难的朋友们能参考我的解决方案
CentOS 6已经随着2020年11月的结束进入了EOL（Reaches End of Life），不过有一些老设备依然需要支持，CentOS官方也给这些还不想把CentOS 6扔进垃圾堆的用户保留了最后一个版本的镜像，只是这个镜像不会再有更新了
官方便在12月2日正式将CentOS 6相关的软件源移出了官方源，随之而来逐级镜像也会陆续将其删除。
不过有一些老设备依然需要维持在当前系统，CentOS官方也给这些还不想把CentOS 6扔进垃圾堆的用户保留了各个版本软件源的镜像，只是这个软件源不会再有更新了。
正题 1.首先把fastestmirrors关了 #编辑 vi /etc/yum/pluginconf.d/fastestmirror.conf #修改 enable=0 #或者执行以下命令 sed -i "s|enabled=1|enabled=0|g" /etc/yum/pluginconf.d/fastestmirror.conf 2.先把之前的repo挪到备份 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak 3.替换为官方Vault源(海外服务器用) curl -o /etc/yum.repos.d/CentOS-Base.repo https://www.xmpan.com/Centos-6-Vault-Official.repo 或者替换为阿里云Vault镜像(国内服务器用)
curl -o /etc/yum.repos.d/CentOS-Base.repo https://www.xmpan.com/Centos-6-Vault-Aliyun.repo 4.下面是报错详情 [root@c8-20 ~]# yum makecache Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile YumRepo Error: All mirror URLs are not using ftp, http[s] or file. Eg. Invalid release/repo/arch combination/ removing mirrorlist with no valid mirrors: /var/cache/yum/x86_64/6/base/mirrorlist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edf66e76155aae69b5188a414456d93d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9da7eebad7866568c24bc0d24b795fa2/" rel="bookmark">
			【洛谷 P7073】【2020 CSP-J】 表达式  题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【洛谷 P7073】【2020 CSP-J】 表达式 题解 题目 解题思路 奇怪小知识
s s c a n f sscanf sscanf
从空终止字符串读取数据
string s="1 2 3 12 13 123" int a; sscanf(s,"%d",&amp;a); a为1
手写暴力栈
读入的是一个后缀表达式
很明显要用栈
接下来会有q个询问
如果改变其中某个值
是否会改变最终答案
那么我们就是求某个值会不会对最终答案造成影响
定义f[i]为这个值或运算会对那个值或运算造成直接影响
分为三种情况
运算符为！
直接改变当前栈顶的值
所以f[x]=i运算符为|
如果另一边的值为1就无法造成影响
if (!y) f[x]=i;
if (!x) f[y]=i;运算符为&amp;
如果另一边的值为0就无法造成影响
if (y) f[x]=i;
if (x) f[y]=i; 最后每次回溯一遍
如果最后返回的值为1
说明最终答案会被改变
将最终答案取反
代码 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; using namespace std; struct hhx{ int id,q; }st[100010],x,y; int n,l,t,res,m,j,k; int xw[1000010],a[1000010],e[2000010],f[1000010]; char ss[2020]; int main() { while (1) { cin&gt;&gt;ss; if (ss[0]&lt;='9'&amp;&amp;ss[0]&gt;='0') break; //读完表达式，读到了n l++; if (ss[0]=='x') //第几个数 { sscanf(ss+1,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9da7eebad7866568c24bc0d24b795fa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a3e0d5ff9b6caa9f5c654aee373b401/" rel="bookmark">
			PyTorch查看模型和数据是否在GPU上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转载自：https://www.cnblogs.com/picassooo/p/13736843.html，本文只做个人记录学习使用，版权归原作者所有。
import torch import torch.nn as nn # ----------- 判断模型是在CPU还是GPU上 ---------------------- model = nn.LSTM(input_size=10, hidden_size=4, num_layers=1, batch_first=True) print(next(model.parameters()).device) # 输出：cpu model = model.cuda() print(next(model.parameters()).device) # 输出：cuda:0 model = model.cpu() print(next(model.parameters()).device) # 输出：cpu # ----------- 判断数据是在CPU还是GPU上 ---------------------- data = torch.ones([2, 3]) print(data.device) # 输出：cpu data = data.cuda() print(data.device) # 输出：cuda:0 data = data.cpu() print(data.device) # 输出：cpu 此外，用.is_cuda也可以判断模型和数据是否在GPU上，例如： data.is_cuda 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09a39ec723aa44ad0786c29da48c82b7/" rel="bookmark">
			点击箭头下拉菜单_一分钟学会Excel下拉菜单，让你的表格上档次！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下拉菜单是什么？ 很多人在Excel中都见过 但是不会使用 学会下拉菜单的两种设置方法 表格提升格调就靠它 昨天小编在的群里，就有一个小姐姐询问了下拉菜单的设置方法， 我们可以看到，群里的小伙伴回答了两种设置方法。不了解的朋友肯定看到云里雾里，今天我们来详细分享一下这两种方法的操作步骤： 01 控 件 我们以此表 B 列“性别”为例，将“男、女”由录入形式变为选择形式。 1、选择“开发工具”——“插入”——“表单控件”——“组合框(窗体控件)”； 2、选择后，我们会发现鼠标变成了 “+”字形状，在 D2 单元格按住鼠标左键，拖动；可以看到形成了图中的控件。 3、右键选中控件，“设置控件格式”； 4、在弹出的对话框中，点击“控制”——“数据源区域”，点击后面的红箭头；数据源区域就是我们在“性别”中会用到的选项数据； 5、在这里，我们首先在旁边录入“性别”的数据源 “男、女”，拖动鼠标左键选择“男、女”单元格，点击框中红色键头返回； 6、可以看到，“数据源区域”已经有了数据，“确定”； 7、确定后，我们再点击控件，发现出现了“男”、“女” 两个下拉选项，选择对应的选项就可以了。 有的小伙伴会发现，我的Excel里没有 “开发工具”，没办法添加控件，怎么办呢？ 别担心，跟着小编操作，就可以找到控件啦~ (1)在功能区(红框区域)空白处，单击鼠标右键，选择“自定义功能区”； (2)在弹出的“Excel选项”对话框中，右侧“自定义功能区” 选择 “主选项卡”，在下方找到“开发工具” ，勾中前方的框中“√”，确定； (3)这样“开发工具”就出现啦。 02 数 据 有 效 性 还有一种下拉菜单是直接在单元格完成的，不需要插入控件。 我们以表中 C列 “班级” 为例： 1、选中“班级”区域内容，“数据”——“数据验证”——“数据验证”； 2、在弹出的对话框中，选择“设置”——验证条件中允许选择 “序列”； 来源，就是数据来源，同上；点击来源后方红箭头； 3、在空白单元格录入“班级”数据源，拖动鼠标，选择数据“3年1班”“3年2班”“3年3班”； 4、设置完成后，我们会发现在单元格旁边出现了小三角； 5、点击小三角，可以看到出现了“3年1班”“3年2班”“3年3班”选项，这样就完成了。 今天的内容有帮到你吗 你学会了吗 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27b586864d00963516f83b7568f3e3ef/" rel="bookmark">
			用dmp文件方法转移一个数据库的表到另一个数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用dmp文件方法转移一个数据库的表到另一个数据库
新建文本写入如下语句
exp cts_dev/cts_dev@192.168.1.166/ctsdb file=CTS_PROD.dmp tables=cf_formuladefine log=daochu.log statistics=none
包含拷贝出表的这个数据库的ip、账户密码、sid信息 保存文本后修改文本名后缀为bat 然后双击运行
导出成功后会生成dmp文件与日志
接着再再同路径下写一个bat文件 内容如下
imp cts_db3/cts_db3@192.168.1.55/ctsdb file=CTS_PROD.dmp full=y log=opt_db1.log
包含需要导入此表的数据库ip、用户密码与sid等信息
双击运行
这样就能把一个表的从一个库拷贝到另一个库了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4d937e134e68df394c6cb5f37eb54c0/" rel="bookmark">
			c语言实现哥德巴赫猜想(函数版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 c语言实现哥德巴赫猜想(函数版) 大家好，1个多月前我发布了一篇《c语言实现哥德巴赫猜想》的文章，获得了许多的浏览和点赞。但是当时我c语言还没有学习到函数，所以当时的文章直接用循环写的。
今天我们用函数来写《c语言实现哥德巴赫猜想》，这样代码会更简洁。(如果有误，还请大家见谅，希望大家指出错误)
#include&lt;stdio.h&gt; int Prime (int n); int main(void) { int x; int number_one,number_two; int i,j; printf("请输入一个大于6的偶数:"); scanf("%d",&amp;x); for(i=3;i&lt;=x/2;i++) //寻找【3，x/2】内的素数 { number_one = Prime(i); if(number_one == 1) //如果number_one ==1 ，说明函数返回了1，说明i是素数 { for(j=x/2;j&lt;x;j++) //在i是素数的情况下，继续寻找【x/2,x)内的素数j { number_two = Prime(j); if((number_two == 1)&amp;&amp;(x==i+j)) //如果number_two ==1 ，说明函数返回了1，说明j是素数 { printf("%d = %d + %d\n",x,i,j); //如果i和j都是素数，且i+j == x,则将它们输出 } } } } return 0; } //函数功能：判断一个数字是否为素数 //函数入口参数：需要判断是否为素数的整型变量 //返回值：如果该数是素数，则返回1;否则，返回0 int Prime(int n) { int i; for(i=2;i&lt;=n/2;i++) //让i从2循环到该数的一半 { if(n%i==0) //让该数除于 i ，如果有一项能够整除，说明该数不是素数，返回0 { return 0; } } return 1; //循环结束，上面的都不能整除，则说明该数是素数 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9e047508a5d0706340c77e7f4c81651/" rel="bookmark">
			AUTOSAR资料下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AUTOSAR的地位越来越高，现在很多MCU软件开发工作岗位都要求熟悉AUTOSAR。今天给大家分享一些AUTOSAR的学习资料，对AUTOSAR感兴趣的同学不要错过。
资料包含AUTOSAR架构基础和上层应用视频讲解，Vector培训资料以及AUTOSAR好文分享等。
获取方式，微信搜索并关注公众号"汽车软件后花园"，回复AUTOSAR或者点击 资料下载-&gt;AUTOSAR 即可获取下载链接，以后会有更多资料分享。大家拿到资料后要好好利用，不要让它躺在你的网盘里睡觉，囤积资料并不等于你掌握了它们。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72ec27a206c81082f1bab2df6a3740a3/" rel="bookmark">
			echart 折线图点击区域获取对应参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天有个新需求，需要点击某片区域获取对应参数，但是发现echart折线图必须点到点上面才可以，于是查阅了几篇博客，总算解决了，解决方法如下：
首先需要在option的xAxis中增加
triggerEvent: true 然后调用
echart.setOption(optionData) 生成图形后新增点击事件
chart.getZr().on('click', function(params) { var pointInPixel = [params.offsetX, params.offsetY] if(chart.containPixel('grid', pointInpixel)) { var xIndex = chart.convertFromPixel({seriesIndex: 0}, pointInPixel)[0] console.log('你在点击第', xIndex, '个格子') } }) 这样就可以获取到点击的是哪个格子，再根据传入的data索引获取对应的数据就OK了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5bf5f281580213e9808efcdff57fdef/" rel="bookmark">
			并发容器和队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“晏霖”，选择“置顶或者星标”
曾经有人关注了我
后来他有了女朋友
2.9.1 Java中的并发容器
在我们开发中，经常会使用到容器来存储对象或数据，容器的作用非常大，合理使用各个容器的特性和方法可以简化开发，提高系统性能和安全性。
我们所说的容器，在Java中可分为两大块，首先就是Collection接口的分支，有Set、List、Queue，另一块就是Map接口的分支，代表集合HashMap，他们派生出来的子类也很多，每个子类都有自己的特性。这部分属于Java基础，在面试中几乎常常被问到，熟练掌握Java集合特性，是面试官在试探一个Java程序员基础知识扎实程度重要手段之一。
早期，我们在Java多线程下操作一个容器除了借助synchronized关键字，就是使用同步容器。典型的同步容器有Vector和Hashtable，而且当时在设计Hashtable的时候还没有考虑到驼峰命名。我们列举出一些常见的线程安全的和非线程安全的容器，如下表2-14所示。
表2-14 早期Java中线程安全与非安全容器
线程安全
非线程安全
Vector
ArrayList、LinkedList
Properties
HashSet、TreeSet
HashTable
HashMap
……
……
在多线程中，无论是使用同步方法还是同步容器，使其对容器操作具有线程安全都是允许的，但是最大的问题就是效率，我们为了提高效率才使用的多线程，或者某些并发场景下，都是对效率问题不可忽视的，或者有些复杂的场景还会多线程交替对容器进行存取，可能会发生ArrayIndexOutOfBoundsException异常。又例如在多线程处理HashMap使，put操作会引起死循环，这种死循环会导致cpu接近100%。总结一下就是，同步容器对所有容器操作串行化，来实现他们的线程安全性，代价就是效率，因为串行化严重降低并发性和吞吐量。所以，在Java5.0提供来多种并发容器，不仅可以保证线程安全同时又能保证高效操作。增加来ConcurrentHashMap来代替基于散列的Map，以及CopyOnWriteArrayList在多线程操作下代替List，还有为提高阻塞队列性能的ConcurrentLinkedQueue。在我所接触的项目中，开发人员对ConcurrentHashMap使用率远远高于CopyOnWriteArrayList和ConcurrentLinkedQueue，原因可能第一是因为并发场景使用少，第二对于数据容器结构，Map使用起来较为广泛和方便。本小结有必要解释一下CopyOnWriteArrayList，其实对于我来说，更比较喜欢用List，只是个人习惯而已，在多线程和并发情况下，CopyOnWriteArrayList可以代替List，类似这样的还有CopyOnWriteArraySet代替同步Set。使用方法和普通的List和Set没有区别。可以看到他们的命名规则是在ArrayList和ArraySet加前缀CopyOnWrite，CopyOnWrite理解成“写时复制”，这也是他保证线程安全的特征，指的是，在每次修改或写入时，都会创建并重新生成一个新的容器副本。我们可以把这个过程形象的理解成项目的版本迭代开发，每个人每次迭代都会对前一个版本进行完整更新，在此基础上进行开发。每次要变更这个容器都会复制一份，在此基础上进行修改，这样保证了多个线程同时对这个容器进行迭代时，不会被彼此干扰。CopyOnWriteArrayList更像是一种读写分离的实现，他不能保证修改过程中对于读取数据的实时准确性，但是可以保证最终一致性。可见COW这一过程需要复制底层数组，这是有一定性能开销对，特别对于容器数据量较大时，影响比较大。CopyOnWriteArrayList还有一个应用场景，在循环中对普通的List进行remove操作时会出现ConcurrentModificationException异常，还可能会出现数组下标越界异常，对于这样的操作我们可以使用CopyOnWriteArrayList代替List，但是我推荐把集合转成Iterator进行循环对其remove操作。
2.9.2 ConcurrentHashMap原理
大家对ConcurrentHashMap应该是非常熟悉的，在并发和多线程中代替HashMap，保证线程安全，并且提高并发效率。对于使用者来说也是很简单的，其内部提供操作容器的方法与HashMap基本一致，而且在设计上也沿用了一些HashMap的概念。ConcurrentHashMap是在JDK5时引入的线程安全的哈希式集合，在JDK8之前一直采用分段锁的设计思想，分段锁是由Segment内部类实现的，他继承ReentrantLock，用来管理每个HashEntry，相当于把容器分成众多的Segment，对于修改数据时只需对他所在对Segment进行同步达到线程安全对。在JDK8之后，ConcurrentHashMap抛弃了分段锁的概念，直接使用Node内部类作为存储具体的键值对，把put流程的控制粒度更加细化，引入了CAS无锁操作和synchronized来保证并发安全。并且数据结构跟HashMap1.8的结构一样，数组+链表/红黑树。以上我只是简单说一些变更的内容和一些概念，这些概念可以引申出许多问题，很多同学可能在面试过程中已经领教过了。而且在JDK8之后的ConcurrentHashMap源码已经达到了6300多行，引入了很多内部方法，涉及到的知识点是非常多的。要了解每一行代码的含义是一件非常难的事，所以我们要归纳其重点，了解其精华即可。下面我们要结合源码来聊一聊ConcurrentHashMap原理的重要内容。还是老办法，深入一个容器或者对象的源码，首先要看内部定义的属性和类，请看示例代码2-37。
代码清单2-37 ConcurrentHashMap.java //最大容量 private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //默认容量 private static final int DEFAULT_CAPACITY = 16; //array的大小，只用于toarray方法 static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //根据这个数来计算segment的个数,segment的个数是仅小于这个数且是2的几次方的一个数（ssize） private static final int DEFAULT_CONCURRENCY_LEVEL = 16; //加载因子 private static final float LOAD_FACTOR = 0.75f; //变成红黑树的链表节点数，超过8就由链表转换成红黑树 static final int TREEIFY_THRESHOLD = 8; //当树节点小于6自动转换成链表 static final int UNTREEIFY_THRESHOLD = 6; // 在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。 static final int MIN_TREEIFY_CAPACITY = 64; //每次进行转移的最小值这个值作为一个下限来避免Rsisize遇到过多的内存争用 private static final int MIN_TRANSFER_STRIDE = 16; // 生成sizeCtl所使用的bit位数 private static final int RESIZE_STAMP_BITS = 16; // 进行扩容所允许的最大线程数 private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1; // 记录sizeCtl中的大小所需要进行的偏移位数 private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS; // 一系列的标识 //forwarding nodes 主要作用是表征一个节点已经被处理干净（resize的时候被转移到新表了） static final int MOVED = -1; // hash for forwarding nodes //表示树的根节点 static final int TREEBIN = -2; // hash for roots of trees //表示transient static final int RESERVED = -3; // hash for transient reservations //31个1用来计算普通的node的哈希码 static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash // 获取可用的CPU个数 static final int NCPU = Runtime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5bf5f281580213e9808efcdff57fdef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9e7177dfef6c23cf6d92463e8c1e668/" rel="bookmark">
			服务器图片加载慢_影响页面加载速度的8大原因（实用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		影响页面加载速度的8大原因:
1.图片或者flash过大，未压缩
2.域名证书未使用付费的(iOS系统下，域名使用免费证书加载慢)
3.加了多重授权
4.中间多了跳转链接
5.尽量减少HTTP的请求次数 比如：提前加载好图片，减少与后端服务器的交互
缓存技术。访问量大的页面(如首页)生成。 静态页，常用的且变更不频繁的模块使用局部缓存，减少数据库查询次数
6.高并发现象
大型互联网公司通常会采用扩容、动静分离、缓存、服务降级及限流这五种常规手段保护系统的稳定运行。
我们可以使用freeMark对页面进行静态化。
限流和静态化都是为了减轻服务器后端的压力，但是最终用户的请求还是会落到服务器中，为了增加用户的体验 度，我们也应加快相应速度。后端代码和数据库之间的交互会降低相应速度，所以我们可以采用Redis来进行数据 的高速读取。
7.服务器的问题
服务器环境异常、不稳定，或者终止服务，网站自然会打不开。在建站时，选择服务器或者主机、空间时一定要选择好，按照自身网站的需求来选择，不要为了方便或者便宜而选择一些比较差的服务器。
8.网络原因
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33b915e8acee285d9203dcf0fb1fdd56/" rel="bookmark">
			python 树状图代码_利用Django模版生成树状结构实例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
我们经常会有这样的需求，比如评论功能，每个评论都有可能会有自己的子评论，如果在界面只展示成一列的话非常不美观，也不能体现出他们的层级关系。那么我们今天就来看看如何使用Django的模版来生成树状结构，以本站为例,效果如下图所示：
那么我们要怎么实现呢？首先先看看评论实体的定义，如下所示:
class Comment(models.Model):
body = models.TextField('正文', max_length=300)
author = models.ForeignKey(settings.AUTH_USER_MODEL, verbose_name='作者', on_delete=models.CASCADE)
article = models.ForeignKey(Article, verbose_name='文章', on_delete=models.CASCADE)
parent_comment = models.ForeignKey('self', verbose_name="上级评论", blank=True, null=True, on_delete=models.CASCADE)
可以看到，有一个parent_comment字段，关联自己。这样就可以根据这个字段来生成层级关系。 为了方便我们使用，我们自定义了一个叫query的tag，也可以叫修饰器。定义tag的代码如下，tag的定义应该定义在app/templatetags目录下，这里py文件命名为blog_tags.py：
@register.simple_tag
def query(qs, **kwargs):
""" template tag which allows queryset filtering. Usage:
{% query books author=author as mybooks %}
{% for book in mybooks %}
...
{% endfor %}
"""
return qs.filter(**kwargs)
接下来下面这段代码是树节点的模版代码。
{% load blog_tags %}
{% load comments_tags %}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33b915e8acee285d9203dcf0fb1fdd56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cac19a9723500a0f98e17edb2d21c172/" rel="bookmark">
			基于VUE从零实现一个价格日历(附带讲解,一看就懂)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Vue从零实现一个自己的价格日历 获取当前时间, methods里面定义方法获取当前传入日期的年月份, 绑定time对象中的年月,
实现思路, 每个日期都有一套固定的模板, 共42天如图, 我们只需要拿到当月1号的日期,和拿到当月1号属于一周中的第几天(0-6), 以此推算出当前日历模板42天中每天的日期
代码如图, computed中依赖time中月份或者年份的改变, 计算出每个月的日历模板数据
打印取得的数据结果
将计算结果遍历至模板上, 模板代码如下
接下来实现日历头部, 样式如下
我们需要给每个元素绑定点击事件, 点击一次, data中的time对象年或者月会随之递增或者递减,点击后time更新,computed属性会将visibeDays[]重新计算,
现在,一个简单的日历功能已经差不了多少了, 要开始向日历中注入一些自己想要展示的数据, 接收数据
根据业务需求,日历上需要展示剩余库存和价格,小伙伴可根据自己实际业务需求自定义数据 data数据: [{ calendar: "2020-11-24", price: "1111.00",stock: 11109}, {calendar: "2020-11-23", price: "1111.00",stock: 1111}] field数据: [{'stock': '库存'}, {'price': '价格'}] //要展示的字段和key 将数据渲染至对应日期中
6.置灰无效日期和过期日期
不属于本月日期,置灰
&lt;!-- 调用方法! data: 传入的所有数据数据 (用户可点击的所有日期) 数组格式 格式如下 [{ calendar: "2020-11-24", price: "1111.00",stock: 11109}, {calendar: "2020-11-23", price: "1111.00",stock: 1111}] field: 要在价格日历上展示的字段 如 价格, 库存等... 数组格式 格式如下 [{'stock': '库存'}, {'price': '价格'}] @formaDate: 用户点击可点击的日期点击回调 回调参数返回用户点击的日期 --&gt; &lt;template&gt; &lt;div v-click-outside style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cac19a9723500a0f98e17edb2d21c172/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81212a631c560d0767e6dab953a87145/" rel="bookmark">
			JS数组之Reduce()用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS数组之Reduce()用法 文章目录 JS数组之Reduce()用法一.语法二.实例运用1.数组里所有值求和2.数组中对象的某一项所有值求和3.多维数组扁平化4.统计字符串中出现次数最多的字符5.求数组中最大的值6.数组去重 三.总结 一.语法 arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) reduce()函数的参数有2个，第一个参数是一个函数（必须），第二个参数是一个初始值（非必须）。
callback：是一个回调函数，执行数组中每个值，注意：如果没有提供initialValue,将不会执行第一个值。包含4个参数：
accumulator 累计器累计回调的返回值，是上一次调用回调时返回的累计值，如果提供了initialValue，那么第一次执行时，为初始值initialValuecurrentValue 当前数组中正在处理的元素index 可选 数组中正在处理的当前元素的索引。如果提供了initialValue，则起始索引为0，如果没有提供，则起始索引为1array 可选 原数组 initialValue: 初始值，本参数可选，作为第一次调用callback函数时的第一个参数的值。如果没有提供初始值，则将使用数组中的第一个元素。
PS:在没有初始值的空数组上调用Reduce函数会报错！
二.实例运用 1.数组里所有值求和 var arr = [1, 2, 3, 4, 5] var result = arr.reduce(function (acc, cur, idx, src) { return acc + cur },0) console.log(result);//15 也可以写成箭头函数形式：
var result = arr.reduce((acc, cur) =&gt; acc + cur, 0) console.log(result);//15 2.数组中对象的某一项所有值求和 var arr = [ { classId: 1, score: 90 }, { classId: 2, score: 80 }, { classId: 3, score: 90 } ] var result=arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81212a631c560d0767e6dab953a87145/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cb573d0124bf7e92d3ab879e870265a/" rel="bookmark">
			自定义修改input=radio的样式(选中&#43;禁用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义修改input=radio的样式 前言实现 前言 鉴于在移动端开发中用到的移动端的组件库内没有符合UI设计要求的radio样式，只能使用最原始的input来造成符合需求的框
实现 样式与原始的差不多，只是选中的颜色改成绿色
&lt;input id="inputChoice1" v-model="advice" class="select" type="radio" :disabled="!isLeader" name="leaderadvice" value="choice1" /&gt; &lt;label for="inputChoice1"&gt;&lt;/label&gt; &lt;span&gt;choice1&lt;/span&gt; &lt;input id="inputChoice2" v-model="advice" class="select" type="radio" :disabled="!isLeader" name="leaderadvice" value="choice2" /&gt; &lt;label for="inputChoice2"&gt;&lt;/label&gt; &lt;span&gt;choice2&lt;/span&gt; 选中时：
禁用时
样式的修改主要还是借助各种选择期，以及将选中框的样式寄托在label上
样式代码如下
//将input的圆框隐藏 input[type='radio'] { width: 0.32rem; height: 0.32rem; display: none; } //定位label到圆框的位置，并修改样式为圆框 label { position: relative; top: 0.1rem; width: 0.32rem; height: 0.32rem; border-radius: 50%; border: 1px solid #999;//默认为边框 } /*设置选中的radio的样式*/ /* + 是兄弟选择器,获取选中后的label元素*/ input:checked + label { background: url('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cb573d0124bf7e92d3ab879e870265a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d585be58237915b86512292036d31079/" rel="bookmark">
			基于dnn的车牌识别_基于paddlepaddle的车牌识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了进行车牌识别，需要以下几个基本的步骤：
1、牌照字符分割，把牌照中的字符分割出来；
2、牌照字符识别，把分割好的字符进行识别，最终组成牌照号码。
车牌识别过程中，牌照颜色的识别依据算法不同，可能在上述不同步骤实现，通常与车牌识别互相配合、互相验证。
牌照字符分割
完成牌照区域的定位后，再将牌照区域分割成单个字符，然后进行识别。字符分割一般采用垂直投影法。由于字符在垂直方向上的投影必然在字符间或字符内的间隙处取得局部最小值的附近，并且这个位置应满足牌照的字符书写格式、字符、尺寸限制和一些其他条件。利用垂直投影法对复杂环境下的汽车图像中的字符分割有较好的效果。
# 对车牌图片进行处理，分割出车牌中的每一个字符并保存 license_plate = cv2.imread('车牌/1.png') gray_plate = cv2.cvtColor(license_plate, cv2.COLOR_RGB2GRAY) ret, binary_plate = cv2.threshold(gray_plate, 175, 255, cv2.THRESH_BINARY) result = [] for col in range(binary_plate.shape[1]): result.append(0) for row in range(binary_plate.shape[0]): result[col] = result[col] + binary_plate[row][col]/255 character_dict = {} num = 0 i = 0 while i &lt; len(result): if result[i] == 0: i += 1 else: index = i + 1 while result[index] != 0: index += 1 character_dict[num] = [i, index-1] num += 1 i = index characters = [] for i in range(8): if i==2: continue padding = (170 - (character_dict[i][1] - character_dict[i][0])) / 2 ndarray = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d585be58237915b86512292036d31079/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db59855aa03be5ff0d3173c1d27dbf56/" rel="bookmark">
			调试接口前端报400，postman可以调通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：postman可以跑通，但是前端返回400， 检查了传递的参数，请求方式等都没有问题，后来发现前端使用axios post请求默认传递的的json格式的数据，后端接收格式
application/x-www-form-urlencoded，传递和接收的类型不一致导致报400错误
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e57e1639ecc3dc9eeacc55a5d4253a8/" rel="bookmark">
			K8s JavaClient watch Pod检测状态变更、和Read timed out异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		watch k8s很多命令都有watch机制，持续检测状态变化，如pod列表，如果pod状态发生变化，就会输出
kubectl get pod -w 或者--watch JAVA Cient watch podList 官网介绍:https://kubernetes.io/zh/docs/reference/using-api/api-concepts/#standard-api-terminology
K8sJavaClient官方github有一个watch namespace的例子，https://github.com/kubernetes-client/java/blob/master/examples/examples-release-11/src/main/java/io/kubernetes/client/examples/WatchExample.java
我们改成watchpod列表。watch 命名空间为default、标签为userId=user1Id的pod，将listNamespacedPodCall方法的watch参数设置为true
@BeforeAll public static void connectK8s() throws IOException { String kubeConfigPath = "config"; //加载k8s, config client = ClientBuilder.kubeconfig(KubeConfig.loadKubeConfig(new FileReader(kubeConfigPath))).build(); //设置http的读取超时时间，设置为0永远不超时，但不安全，如果watch的时间大于此时间，则会socket read timeout异常 client.setReadTimeout(20000); Configuration.setDefaultApiClient(client); } @Test public void watchPod() throws ApiException, InterruptedException, IOException { System.out.println("重新访问"); CoreV1Api api = new CoreV1Api(); Call call = api.listNamespacedPodCall("default", null, null, null, null, "userId=user1Id", null, null, null, true, new ApiCallback() { public void onFailure(ApiException e, int statusCode, Map responseHeaders) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e57e1639ecc3dc9eeacc55a5d4253a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0ce30da73af61a9c72c45a0243b5fea/" rel="bookmark">
			AS4.1 代码报错不提示、无高亮；控制台乱码；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 AS4.1 代码报错不提示、无高亮； AS升级到4.1后，感觉就像记事本一样，无高亮、无提示；
解决方法：把 Android ButterKnife Zelezny禁用；如下图；
AS4.1 控制台乱码： 1、双击Shift快捷键 ， 输入Edit Custom VM Options回车查找；
2、Create创建 studio64.exe.vmoptions 文件；
3、文件结尾添加： -Dfile.encoding=UTF-8 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab8477cedfd014b302e559e753a657a8/" rel="bookmark">
			Vue深入-2【VUE3使用proxy】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(1).Proxy 1.与defineProperty区别 与defineProperty的区别是缺少了key这个参数，也就是说它是对与某一个key的
proxy得兼容性比较差
defineProperty只要遇到对象就会劫持，proxy则是只会代理第一层
2.proxy得基础使用 new Proxy(obj,{ get(){}, set(){} }) person.name ="xx" 这样并不会响应get set let proxyPerson = new Proxy(obj,{ get(){}, set(){} }) proxyPerson.name="xx"这样就可以 所以说proxy只能监听代理后的对象 3.get与set中得参数 而proxy中的get/set中有两个参数则可以获取对象中具体的key对应的值 get(target,key){} target 代理前的对象 具体取得属性key 这样使用 get(target,key){ return target[key] } set(target,key,value){ target[key] = value } 4.与Reflect结合 如果设置了writerble为false则上面得方法无效了
get(target,key){ return Reflect.get(target,key) } set(target,key,value){ return Reflect.set(target,key,value)//成功返回true } (2).vue3遇到对象后的原理 1.代码 const handler = { get(target,key){ if(typeof(target[key]) === 'object' &amp;&amp; typeof(target[key] !== null){ return new Proxy(target[key],handler) } return Reflect.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab8477cedfd014b302e559e753a657a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/213c451aabae138192d85f72c74b28c7/" rel="bookmark">
			python中os.path.join()的循环用法_Python os.path.join()用法及代码示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中的OS模块提供了与操作系统进行交互的功能。操作系统属于Python的标准实用程序模块。该模块提供了使用依赖于操作系统的功能的便携式方法。 os.path模块是Python中OS模块的sub-module，用于通用路径名操作。
os.path.join()Python中的方法会智能地连接一个或多个路径组件。此方法将各个路径组成部分与每个非空部分之后的最后一个路径组成部分恰好用一个目录分隔符(/)串联在一起。如果要连接的最后一个路径组件为空，则将目录分隔符('/')放在末尾。
如果路径组件表示绝对路径，那么将放弃所有先前连接的组件，并且从绝对路径组件继续进行连接。
用法： os.path.join(path, *paths)
参数：
path：代表文件系统路径的path-like对象。
*paths：代表文件系统路径的path-like对象。它表示要连接的路径组件。
path-like对象是表示路径的字符串或字节对象。
Note:python函数定义中的特殊语法* args(此处为* paths)用于将可变数量的参数传递给函数。
返回类型：此方法返回一个表示串联路径组件的字符串。
代码:使用os.path.join()方法连接各种路径组件
# Python program to explain os.path.join() method
# importing os module
import os
# Path
path = "/home"
# Join various path components
print(os.path.join(path, "User/Desktop", "file.txt"))
# Path
path = "User/Documents"
# Join various path components
print(os.path.join(path, "/home", "file.txt"))
# In above example '/home'
# represents an absolute path
# so all previous components i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/213c451aabae138192d85f72c74b28c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47d721411839d27248accd6eded55411/" rel="bookmark">
			python中ix用法_Python numpy.ix_() 使用实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The following are code examples for showing how to use . They are extracted from open source Python projects. You can vote up the examples you like or vote down the exmaples you don’t like. You can also save this page to your account.
Example 1
def test_large_fancy_indexing(self, level=rlevel):
# Large enough to fail on 64-bit.
nbits = np.dtype(np.intp).itemsize * 8
thesize = int((2**nbits)**(1.0/5.0)+1)
def dp():
n = 3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47d721411839d27248accd6eded55411/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7642e903cef38ea0b835758330285902/" rel="bookmark">
			python中ix用法_在python的pandas模块中，DataFrame对象，如何选择一行？索引、loc、iloc、ix的用法及区别...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在python的pandas模块中，DataFrame对象，如何选择一行？索引、loc、iloc、ix的用法及区别
在dataframe对象中，如何选择一行数据？如何选择某一个数据？先创建一个dataframe对象，进行演示：
df = pd.DataFrame(np.arange(16).reshape(4, 4),
index = ['a','b','c','d'],
columns=['Ohio', 'Texas', 'California','Los'])
df输出如下：
一、方法1：使用数字索引选取行。这是最简单的方法。
df[:1]
输出如下：
.。这里需要注意一点，不能使用df[1]这样的方式，选取第一行。使用df[1]的时候，会报错。
二、方法2：使用轴标签loc选取行数据
loc的用法为df.loc[行索引]
df.loc['a']，会选取a这一行，如果两行的话，可以用df[['a','b']]来实现。
输出如下：
三、方法三：使用整数标签iloc选取行数据
iloc的用法为df.iloc[行数]。用法类似于loc，只不过把索引变为了数字。
例如：df.iloc[0]选取第一行数据，输出如下：
输出的第一行的数据，该数据类型为Series。
四.方法四：使用ix可以实现。ix可以同时包括标签和整数。但是pandas的设计者认为ix有些神奇的索引行为，已经不建议使用。这里不进行介绍了。
五、读取dataframe中同时在某一行和某一列的数据
使用df.loc['行索引', '列索引']实现，例如:df.loc['a','Ohio']
得到在第一行，第一列的数据0。同样可以使用df.iloc[0]起到相同的效果。
标签：loc,索引,python,选取,ix,df,iloc
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cccfe56a2f977a1d1dbb008731f7a8e/" rel="bookmark">
			Windows 下的MySQL安装keyring_file插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
前言
一、配置my.ini
二、安装keyring插件
三、查看插件状态
四、加解密数据表
五、卸载keyring插件
前言 从5.7.11开始，mysql开始支持物理表空间的加密，它使用两层加密架构。
包括：主密钥（master key） 和 表空间加密密钥（tablespace key）
主密钥用于加密加密密钥，加密后的加密密钥存储在表空间文件的header中。加密密钥用于加密数据
当用户想访问加密的表时，innoDB会先用 主密钥 对之前存储在表空间header中被加密的加密密钥进行解密，得到明文的加密密钥。
再用 加密密钥 解密数据信息。加密密钥是不会被改变的（除非进行alter table testt encrytion=NO/YES）。
而 主密钥 可以通过以下命令随时改变
查看变更前keyring文件
执行主密钥变更命令
mysql&gt; ALTER INSTANCE ROTATE INNODB MASTER KEY; Query OK, 0 rows affected (0.01 sec) mysql&gt; 再次查看变更后keyring文件 一、配置my.ini 如没有该文件，可在创建一个在MySQL安装目录或C:\下，文件添加如下内容，目录以实际为准，然后重启MySQL。
[mysqld] 。。。其他配置。。 early-plugin-load=keyring_file.dll keyring_file_data='D:\mysql-8.0.22\mysql-8.0.22-winx64\keyring' # 其中keyring文件MySQL会自动创建，无需手动创建 二、安装keyring插件 登录MySQL，然后执行以下语句安装
mysql&gt; install plugin keyring_file soname 'keyring_file.dll'; Query OK, 0 rows affected (0.01 sec) 三、查看插件状态 mysql&gt; SELECT PLUGIN_NAME, PLUGIN_STATUS -&gt; FROM INFORMATION_SCHEMA.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cccfe56a2f977a1d1dbb008731f7a8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf2c9209d6fddce7224295d8a8d24834/" rel="bookmark">
			python与pycharm链接_Python（Pycharm）连接Oracle数据库之cx_Oracle的使用（cx_Oracle在pyCharm中报错）-Go语言中文社区...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先声明Python27+Windows32安装
我的电脑Windows版本是64位的，但是由于Pycharm中的pycrypto中使用了C语言的代码所以我在装Pycharm的时候装的是32位的，不需要下载其他插件去支持它。
其次，为了兼容32位Pycharm所以我安装了32位的Oracle，这也是需要特别注意的一点，Pycharm的版本必须和Oracle数据库版本相对应。否则安装上去之后连接不了。我就吃了一次亏，然后就是各种找注册表完全卸载Oracle重装。折腾了一天多时间遇到很多问题，例如终端可以运行成功但是IDE总是cx_Oracle.InterfaceError: Unable to acquire Oracle environment handle、找不到指定模块、32位与Python不兼容等等，按照我这个流程走的话不到十分钟你就可以搞定了数据库的连接了，如果你也遇到以上问题可以看看自己少了哪一步。
废话少说先上资源：
1.如果没有Python的先安装Python27.具体安装步骤一直next就行。
安装完成之后根据你安装的Oracle目录找到以下这两个文件并复制：
把以上两个文件复制到你安装的Python的根目录例如我将这两个文件复制到我的Python根目录：
3.安装cx_Oracle，一直next就行。
4.解压缩instantclient-basic-win32-11.2.0.1.0.zip得到文件
(解决Pycharm运行中cx_Oracle.InterfaceError: Unable to acquire Oracle environment handle问题)
全选复制到你的Python根目录Libsite-packages例如我的：
5.然后打开Pycharm-File-Setting你会发现
6.接下来让我们运行一段代码吧
cmd终端直接运行
python
import cx_Oracle
cx_Oracle.connect('Nfcos_dev/nfc2017dev@//192.168.39.198:1521/nfcos')
cursor = conn.cursor()
cursor.execute('select * from tbl_pay_order_info')
result = cursor.fetchall()
print (cursor.rowcount)
for row in result:
print row#此处特别注意前面空格
cursor.close()
conn.close()
用Pycharm
# coding:UTF-8
#引用模块cx_Oracle
import cx_Oracle
import unittest
class ConnectOracle(unittest.TestCase):
def test_oracleConnect(self):
try:
#连接数据库，参数参考cx_Oracle使用
conn = cx_Oracle.connect('用户名/密码@localhost：1521/数据库名称')
#获取cursor
cursor = conn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf2c9209d6fddce7224295d8a8d24834/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37f9c7af7ff4b5383465dd93db4b5920/" rel="bookmark">
			SpringBoot集成MyCat实现分库分表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mycat 它是一个开源的分布式数据库系统，是一个实现了 MySQL 协议的Server，前端用户可以把它看作是一个数据库代理，用 MySQL 客户端工具和命令行访问，而其后端可以用 MySQL 原生（Native）协议与多个 MySQL 服务器通信，也可以用 JDBC 协议与大多数主流数据库服务器通信，其核心功能是分表分库，即将一个大表水平分割为 N 个小表，存储在后端 MySQL 服务器里或者其他数据库里。
Mycat关键特性 支持SQL92标准
支持MySQL、Oracle、DB2、SQL Server、PostgreSQL等DB的常见SQL语法
遵守Mysql原生协议，跨语言，跨平台，跨数据库的通用中间件代理。
基于心跳的自动故障切换，支持读写分离，支持MySQL主从，以及galera cluster集群。
支持Galera for MySQL集群，Percona Cluster或者MariaDB cluster
基于Nio实现，有效管理线程，解决高并发问题。
支持数据的多片自动路由与聚合，支持sum,count,max等常用的聚合函数,支持跨库分页。
支持单库内部任意join，支持跨库2表join，甚至基于caltlet的多表join。
支持通过全局表，ER关系的分片策略，实现了高效的多表join查询。
支持多租户方案。
支持分布式事务（弱xa）。
支持XA分布式事务（1.6.5）。
支持全局序列号，解决分布式下的主键生成问题。
分片规则丰富，插件化开发，易于扩展。
强大的web，命令行监控。
支持前端作为MySQL通用代理，后端JDBC方式支持Oracle、DB2、SQL Server 、 mongodb 、巨杉。
支持密码加密
支持服务降级
支持IP白名单
支持SQL黑名单、sql注入攻击拦截
支持prepare预编译指令（1.6）
支持非堆内存(Direct Memory)聚合计算（1.6）
支持PostgreSQL的native协议（1.6）
支持mysql和oracle存储过程，out参数、多结果集返回（1.6）
支持zookeeper协调主从切换、zk序列、配置zk化（1.6）
支持库内分表（1.6）
集群基于ZooKeeper管理，在线升级，扩容，智能优化，大数据处理（2.0开发版）。
更多信息可以访问官方网站。项目中需要下载的server也是从官网上下载的，版本是1.6-RELEASE，Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz，上传到服务器使用。
准备工作 将mycat安装在106服务器上，mysql在105服务器。
1、下载并解压
从官网下载 Mycat，http://dl.mycat.org.cn/1.6-RELEASE/ 我们是基于 CentOS7 来搭建 Mycat 环境的，所以下载版本：
Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz
2、配置切分规则：
将如下配置复制粘贴覆盖 mycat/conf/schema.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37f9c7af7ff4b5383465dd93db4b5920/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4feceda54cc3b03150198435066fe2e6/" rel="bookmark">
			Java服务端获取URL请求参数的几种方法以及接收参数注解说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下面为7种服务端获取前端传过来的参数的方法 常用的方法为：@RequestParam和@RequestBody
1、直接把表单的参数写在Controller相应的方法的形参中，适用于get方式提交，不适用于post方式提交。 /** * 1.直接把表单的参数写在Controller相应的方法的形参中 * @param username * @param password * @return */ @RequestMapping("/addUser1") public String addUser1(String username,String password) { System.out.println("username is:"+username); System.out.println("password is:"+password); return "demo/index"; } url形式：http://localhost/SSMDemo/demo/addUser1?username=lixiaoxi&amp;password=111111提交的参数需要和Controller方法中的入参名称一致。
2、通过HttpServletRequest接收，post方式和get方式都可以。 /** * 2、通过HttpServletRequest接收 * @param request * @return */ @RequestMapping("/addUser2") public String addUser2(HttpServletRequest request) { String username=request.getParameter("username"); String password=request.getParameter("password"); System.out.println("username is:"+username); System.out.println("password is:"+password); return "demo/index"; } 3、通过一个bean来接收,post方式和get方式都可以。 (1)建立一个和表单中参数对应的bean
package demo.model; public class UserModel { private String username; private String password; public String getUsername() { return username; } public void setUsername(String username) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4feceda54cc3b03150198435066fe2e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/129e3a00a6757f1d8e1d911af11f0028/" rel="bookmark">
			阿里云对象存储OSS权限管理设置-新手基础设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 读写权限 Bucket ACL
设定为“公共读”权限 （不然每次查看文件都要验证） 防盗链 防止其他域名访问你的文件
Referer
本地调试 http://192.168.1.100:* 你的域名 http://*baidu.com 空 Referer
不允许 跨域设置 防止其他域名上传文件
来源
本地调试 http://192.168.1.100:* 你的域名 http://*baidu.com 允许 Methods
选中GET、POST、PUT、DELETE以及HEAD。 允许 Headers
* 暴露 Headers
不填会导致上传失败 ETag x-oss-request-id x-oss-version-id 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/969b76f73e733623d9d465b8f07c84b9/" rel="bookmark">
			uni-app中使用vant注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需要下载vant的weapp版源码，将dist目录复制到uniapp项目中，路径：项目/wxcomponents/vant引入后hbuilderx会自动给每个组件生成一个vue文件，但是会包一层uni-shadow-root，如果同时使用uni官方的组件且是通过easycom的custom使用的，则会冲突，需要将正则改为^uni-((?!(shadow-root)).*)如果报了vant的css错误（Unclosed bracket），则全局搜索https://img.yzcdn.cn/vant/vant-icon-d3825a.woff，把所有的url前加一个空格，不管是wxss还是vue里。vant的组件无法直接使用v-model，因为uni会自动给事件的值套一层，可以自己再封装一层处理。vant的组件(如：button)无法直接使用click事件，需要添加.native装饰器在直接使用vant的组件时要注意，由于自动生成的vue组件包了一层，在组件上添加的class会没有效果，需要通过/deep/重写内部样式hbuilderx会给wxcomponents下的组件在每次运行的时候自动生成/重置index.vue，所以每次修改里面的组件时，原文件和index.vue都要修改在APP中如果要使用本地字体文件，可以到vant的icon样式复制相关的src并修改本地vant的icon目录下的index.wxss里的src field
在使用left-icon的插槽时，原来的写法&lt;slot name="left-icon" slot="icon"&gt;&lt;/slot&gt;在uni里没有效果，需要改成&lt;view slot="icon"&gt;&lt;slot name="left-icon"&gt;&lt;/slot&gt;&lt;/view&gt;，注意：wxml和vue都要改在field中，只对value的做了赋值，没有对innerValue赋值，导致clearable等功能会出现异常，所以需要在给value赋值时也得手动给innerValue赋值field没有监听value的变化，需要通过ref调用setValue更新值 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5aeb686abfab62a2f1a01058cb06af3/" rel="bookmark">
			windows下ConcurrentLogHandler因锁机制导致的卡死问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用concurrent-log-handler替换ConcurrentLogHandler可解决windows因锁机制导致的卡死问题。
即pip install ConcurrentLogHandler 改为pip install concurrent-log-handler.
大写的好用~
感谢老哥的分享
作者：PyKailyn
链接：https://www.jianshu.com/p/def0a24974e4
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c4cd8a38ec8f722e631f0bbcd8be601/" rel="bookmark">
			JAVA Thread.sleep模拟网络延时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前台页面访问，延时10秒后显示 package com.chenxb.mySpringboot.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @RequestMapping("/hello") public String hello() { //模拟网络延时 try { Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } return "hello"; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dec17aa9f61caf66da74ac7e257b92c/" rel="bookmark">
			python的映射类型tuple_【Python 秘籍】映射名称到序列元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：【Python 秘籍】映射名称到序列元素
学Python,用RPA
艺赛旗RPA2020.1版本 正在免费下载使用中，欢迎下载使用
艺赛旗-RPA机器人免费下载
www.i-search.com.cn/index.html?from=line1
问题
你有一段通过下标访问列表或者元组中元素的代码，但是这样有时候会使得你的代码难以阅读，于是你想通过名称来访问元素。
解决方案
collections.namedtuple() 函数通过使用一个普通的元组对象来帮你解决这个问题。这个函数实际上是一个返回 Python 中标准元组类型子类的一个工厂方法。你需要传递一个类型名和你需要的字段给它，然后它就会返回一个类，你可以初始化这个类，为你定义的字段传递值等。代码示例：
&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Subscriber = namedtuple('Subscriber', ['addr', 'joined'])
&gt;&gt;&gt; sub = Subscriber('jonesy@example.com', '2012-10-19')
&gt;&gt;&gt; sub
Subscriber(addr='jonesy@example.com', joined='2012-10-19')
&gt;&gt;&gt; sub.addr
'jonesy@example.com'
&gt;&gt;&gt; sub.joined
'2012-10-19'
&gt;&gt;&gt;
尽管 namedtuple 的实例看起来像一个普通的类实例，但是它跟元组类型是可交换的，支持所有的普通元组操作，比如索引和解压。比如：
&gt;&gt;&gt; len(sub)
2
&gt;&gt;&gt; addr, joined = sub
&gt;&gt;&gt; addr
'jonesy@example.com'
&gt;&gt;&gt; joined
'2012-10-19'
&gt;&gt;&gt;
命名元组的一个主要用途是将你的代码从下标操作中解脱出来。因此，如果你有一个很大的元组列表，通过下标去操作其中的元素，当这个元组的结构发生调整的时候你的代码可能就会出错了。但是如果你使用了命名元组，那么就不会有这样的顾虑。
为了说明清楚，下面是使用普通元组的代码：
# 其中records是一个元素为元组的列表
def compute_cost(records):
total = 0.0
for rec in records:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dec17aa9f61caf66da74ac7e257b92c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7d50afca017dbaf6362af3f9de8a720/" rel="bookmark">
			WireShark 抓包日期格式如何设置？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 最近使用UDP编程的时候，出现了一些问题，需要抓包调试。如何在Android端打印了日志，抓取的包希望可以和打印的日志对应起来。
但是，默认我打开的时候，时间格式如下所示，完全无法看，没法和日志对应起来。
怎么样，才能调整这个日期展示的格式呢？
二、调整WireShark抓包的日期格式展示 我们打开【视图】 --&gt; 【时间显示格式】 --&gt; 然后选择右边的格式类型。
比如我们选择 【日期和时间（1970-01-01 01:02:03.123456） Ctrl+Alt+1】 那么展示的格式如下所示：
比如我们选择 【日期和时间（1970-01-01 01:02:03.123456） Ctrl+Alt+2】 展示的格式如下所示：
这样，可以展示出时分秒的话，我们就可以和打印的日志对应起来。可以便于分析问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c25f488d1f9f8737a8e51dbfa48e68de/" rel="bookmark">
			史上最牛的Linux教程—兄弟连 --笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技术交流 qq群 922850187
博客网站 www.lczze.cn
第一章 Linux起源 unix，C语言，TCP-IP 可以看作三胞胎，他们结合在一起相互诞生，其他具体自行可以看：计算机组成原理，计算机网络，以及C语言。可以结合在一起来学习，效果更佳。
第二章 系统分区 Linux与Windows一样，它的主分区和拓展分区加起来不能超过四个，而且拓展分区最多一个且不能放入数据文件以及它不能格式化，拓展分区里放的逻辑分区可以放数据和格式化。
Linux 硬件全为文件 这一点与Windows不一样，下面介绍一些Linux的主要硬件文件名已经存放路径。
IDE硬盘 /dev/hd[a-d]
SCSI/SATA/USB硬盘 /dev/sd[a-p]
光驱 /dev/cdrom或/dev/sr0
软盘 /dev/fd[0-1]
打印机（25针） /dev/lp[0-2]
打印机（USB） /dev/usb/lp[0-15]
鼠标 /dev/mouse
分区：把大硬盘分为小的逻辑分区
格式化：写入文件系统
分区设备文件名：给每个分区定义设备文件名
挂载：给每个分区分配挂载点
注意：根分区 “/ ” 以下的子分区可以单独使用硬盘
在虚拟机安装中 swap 的大小为内存的两倍但是超过2G没有意义，建议1000MB合适
/boot路径是为了让Linux系统可以顺利运行 里面最好不要存放数据 在虚拟机安装中分配200M左右大小就可以了
安装教程可以观看一下视频，新手学习建议安装CentOS
链接: Linux安装.
第三章 Linux安装与配置 在Linux远程登录管理配置IP时，需要的一些简单命令：
ifconfig 查询当前网卡信息 ifconfig eth0 配置网卡 ifconfig eth0 后+ VmNAT8的网络IP df 查看系统分区 ls /bin/ 里面存放的为Linux命令文件 12345 注意：这些配置都是临时配置，在重启之后IP会丢，永久修改需要在配置文件中修改
VmNAT8为VMware虚拟中虚拟网卡 可以自行查询IP
具体操作看以下视频：
链接: VMware环境配置.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c25f488d1f9f8737a8e51dbfa48e68de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c039b7863e737bcf158cee4a96655034/" rel="bookmark">
			CSDN 博客主页加打赏功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 获取收款二维码 微信和支付宝的支付功能的收款码，选择保存二维码 ，最好不要截图，不上上面一堆乱七八糟的信息都带出来了。
上传二维码 将二维码保存到服务器的方法还是通过创建一篇文章，将图片上传到文章中，图片同步就上传到了csdn的服务器了。
创建栏目 当前只能创建一个栏目，栏目中创建多个分块，有公众号的分块 有支付宝打赏分块 微信打赏分块，分块限制不清楚。
&lt;div id="custom_column_41051715" class="panel"&gt; &lt;ul class="panel_head"&gt; &lt;span&gt;感悟&lt;/span&gt;&lt;/ul&gt; &lt;ul class="panel_body"&gt; 坚持就有赢的可能 &lt;img src="https://img-blog.csdnimg.cn/20201203084648159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1d2Vpd2VpMTg2MA==,size_16,color_FFFFFF,t_70#pic_center"&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="custom_column_41051715" class="panel"&gt; &lt;ul class="panel_head"&gt;&lt;span&gt;支付宝打赏&lt;/span&gt;&lt;/ul&gt; &lt;ul class="panel_body"&gt; &lt;img src="https://img-blog.csdnimg.cn/20201208083915805.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1d2Vpd2VpMTg2MA==,size_16,color_FFFFFF,t_70#pic_center" alt="支付宝" title="支付宝二维码" height="100%" width="100%"&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="custom_column_41051842" class="panel"&gt; &lt;ul class="panel_head"&gt;&lt;span&gt;微信打赏&lt;/span&gt;&lt;/ul&gt; &lt;ul class="panel_body"&gt; &lt;img src="https://img-blog.csdnimg.cn/20201208083915715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1d2Vpd2VpMTg2MA==,size_16,color_FFFFFF,t_70#pic_center" alt="微信" title="微信二维码" height="100%" width="100%"&gt; &lt;/ul&gt; &lt;/div&gt; 跟新img src 就可以了，分块就是靠了
&lt;div id&gt; &lt;/div&gt; 效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/859a2038e9f7182870e1c916a948465b/" rel="bookmark">
			python手机屏幕控制_用Python控制墨水屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照基础教程墨水屏用了起来，但是，教程是用C写的，以后是想用python做开发的，这之间可咋切换？
万能的github上已经有人这么做了
https://github.com/GregDMeyer/IT8951
不过环境搭建还是踩了些坑，记录如下：
安装numpy失败
解决方法：
apt-get install libssl-dev libncurses5-dev libsqlite3-dev libreadline-dev libtk8.5 libgdm-dev libdb4o-cil-dev libpcap-dev
安装tck/tk过程中
X11/Xlib.h: 没有那个文件或目录
解决方法：
apt-get install libghc-x11-dev
运行工程，出错
libf77blas.so.3: cannot open shared object file: No such file or directory
解决方法：
apt-get install libatlas-base-dev
总算成功，上图：
651586328181_.pic.jpg
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/340/">«</a>
	<span class="pagination__item pagination__item--current">341/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/342/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>