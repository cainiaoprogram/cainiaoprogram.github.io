<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc953ad14a08eb8ca0a26b65b45fcbc2/" rel="bookmark">
			隐私政策
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们尊重并保护所有使用倪匡平台服务的用户的个人信息及个人隐私。本隐私权条款包含了我们收集、存储、使用、共享和保护用户（“您”）的个人信息的条款，我们希望通过本隐私权条款向您清晰地介绍我们对为您提供的访问、更新、控制和保护您个人信息的方式。
一、适用范围 为用户提供更好、更优、更个性化的服务是倪匡坚持不懈的追求，也希望通过我们提供的服务可以使您的生活更方便。本隐私权条款适用于倪匡平台提供的所有服务（以下称“服务”或“我们的服务”），您访问登录倪匡使用倪匡平台提供的服务，均适用本隐私权条款。
此外，针对某些特定服务，我们还将制定特定隐私条款，以便更具体地说明我们在该特定服务中如何收集、处理、存储、使用、共享和保护您的信息。该特定服务的隐私条款构成本隐私条款的一部分。如相关特定服务的隐私条款与本隐私条款有不一致之处，适用该特定服务的隐私条款。
本隐私权条款不适用于通过我们的服务而接入的其他第三方（“其他第三方”，包括但不限于您的交易相对方、任何第三方网站以及第三方服务提供者）向您提供的服务而收集的信息，我们对前述第三方使用您个人信息的行为及后果不承担任何责任。请您注意，其他第三方可能有自己的隐私权保护条款；当您查看其他第三方创建的网页或使用其他第三方开发的应用程序时，可能会发现该网页或应用程序放置的Cookie或像素标签。这些Cookie或标签不受我们的控制，而且它们的使用不受本隐私权条款的约束。
二、信息收集 我们收集信息是为了遵守法律法规的要求，向您提供更好以及更个性化的服务，并努力提高您的用户体验。您可以选择不提供某一或某些相关信息，但是这样可能使您无法成为我们的用户，或无法享受我们提供的某些服务，或者无法达到相关服务拟达到的效果。请您理解，我们使用您提供的信息是为了回应您的要求，为您享受我们提供各项服务提供便利，完善我们的服务以及与您进行信息沟通。您向我们提供下述信息或使用我们的服务时，即表示您同意我们按照本隐私权条款规定收集信息。我们收集信息的种类如下：
1、您向我们提供的信息 为了遵守法律法规的要求，以及向您提供更个性化、更便捷的服务，我们需要识别您的身份，当您通过注册登录倪匡及您在使用我们的相关服务无时，需要您填写、提交及/或以其他任何方式提供您的个人信息，包括但不限于您的姓名、性别、出生年月日、身份证号码、电话号码、收货地址及相关附加信息（如您地址中的所在省份和城市、邮政编码等）或其他支付工具的账户信息等信息。在您主动注销账号时，我们将根据适用法律法规的要求尽快使其匿名或删除您的个人信息。您在倪匡发布信息内容过程中所提交的任何文字、照片、视频等各种形式的信息，也可能会包含或者关联到您的个人信息。
2、我们在您使用服务过程中获得的信息 为了提高服务质量和用户体验，我们会留存您使用服务以及相关使用方式的信息，这类信息包括以下内容：
（1）您的浏览器和计算机上的日志信息。在您使用倪匡平台服务，或访问倪匡平台网页时，我们的系统自动接收并记录的您的浏览器和计算机上的信息，包括但不限于您的IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据。（2）您的位置信息。当您开启设备定位功能，下载或使用我们开发的应用程序，或访问移动网页使用我们的服务时，我们可能会读取您的位置（大多数移动设备将允许您关闭定位服务，具体方法建议您联系您的移动设备的服务商或生产商）。（3）您的设备信息。如您下载或使用倪匡或其关联公司客户端软件，或访问移动网页使用倪匡平台服务时，我们可能会读取您访问我们或使用我们服务时所使用的终端设备的信息，包括但不限于设备型号、设备识别码、操作系统、分辨率、电信运营商等。（4）您的行为、风格和喜好信息。为满足您的服务要求，和向您提供更加个性化的服务，我们可能会记录您访问我们或使用我们服务时所进行的搜索和其他操作、记录您的收藏/爱好等信息。 请您理解，单独的设备信息、日志信息等是无法识别特定自然人身份的信息。如果我们将这类非个人信息与其他信息结合用于识别特定自然人身份，或者将其与个人信息结合使用，则在结合使用期间，这类非个人信息将被视为个人信息，除取得您授权或法律法规另有规定外，我们会将该类个人信息做匿名化、去标识化处理，请您了解并同意，在此情况下我们有权使用已经去标识化的信息；并在不透露您个人信息的前提下，我们有权对用户数据库进行分析并予以商业化的利用。
3、征得授权同意的例外 根据相关法律法规规定，以下情形中收集您的个人信息无需征得您的授权同意：
（1）与国家安全、国防安全有关的；（2）与公共安全、公共卫生、重大公共利益有关的；（3）与犯罪侦查、起诉、审判和判决执行等有关的；（4）出于维护个人信息主体或其他个人的生命、财产等重大合法权益但又很难得到您本人同意的；（5）所收集的个人信息是您自行向社会公众公开的；（6）从合法公开披露的信息中收集个人信息的，如合法的新闻报道、政府信息公开等渠道；（7）根据您的要求签订合同所必需的；（8）用于维护所提供的产品或服务的安全稳定运行所必需的，例如发现、处置产品或服务的故障；（9）为合法的新闻报道所必需的；（10）学术研究机构基于公共利益开展统计或学术研究所必要，且对外提供学术研究或描述的结果时，对结果中所包含的个人信息进行去标识化处理的；（11）法律法规规定的其他情形。 三、信息使用的目的和方式 为向您提供服务、提升我们的服务质量以及优化您的服务体验，我们会在符合法律规定或根据您授权的情况下使用您的个人信息，并主要用于下列用途：
1、向您提供您使用的各项服务，并维护、改进这些服务。2、我们可能使用您提供的个人信息中的联系方式与您通信，例如通知您有关您的账户、安全性更新、产品和服务信息。 为了更好的为您提供服务，请您及时查看倪匡发送的相关信息。3、向您推荐您可能感兴趣的内容，包括但不限于向您发出产品和服务信息，或通过系统向您展示个性化的第三方推广信息，或者根据本隐私权条款与倪匡的合作伙伴共享信息以便他们向您发送有关其产品和服务的信息。如果您不希望接收上述信息，可通过相应的退订功能进行退订。4、我们可能使用您的个人信息以验证身份，预防、发现、调查欺诈、危害安全、非法或违反与我们或其关联方协议、政策或规则的行为，以保护您、其他我们用户，或我们或其关联方的合法权益。5、我们可能会将来自某项服务的个人信息、交易信息与来自其他服务所获得的信息结合起来，进行综合统计、分析或加工等处理，用于为了给您提供更加个性化的服务使用，例如让您拥有更广泛的社交圈的需要而使用、共享或披露。6、我们会对我们的服务使用情况进行统计，并可能会与公众或第三方分享这些统计信息，以展示我们的产品或服务的整体使用趋势。但这些统计信息不包含您的任何身份识别信息。7、让您参与有关我们产品及服务的调查。8、经您同意或授权的其他用途。 四、信息共享 您的个人信息是我们为您提供服务的重要部分，我们会遵循法律规定对您的信息承担保密义务。 除以下情形外，我们不会将您的个人信息披露给第三方：
1、事先获得您或您的监护人的同意或授权；2、为免除您在生命、身体或财产方面的紧急危险；3、根据法律法规的规定或行政、司法机构的要求；4、以学术研究或公共利益为目的，且无害于您的重大利益；5、如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷；6、您通过点击相关产品的相应按键同意向第三方提交个人信息； 因此，请您谨慎考虑通过我们的服务上传、发布和交流的信息内容。在一些情况下，您可通过我们某些服务的隐私设定来控制有权浏览您共享信息的用户范围。如要求从我们的服务中删除您的相关信息，请通过该等特别服务条款提供的方式操作。
五、您的个人信息保护 1、我们会采取合理可行的措施，尽力避免收集无关的个人信息。我们仅在本隐私条款所述目的所必需的期间和法律法规要求的时限内保留您的个人信息。为保障您的信息安全，我们努力采取各种合理的物理、电子和管理方面的安全措施来保护您的信息，使您的信息不会被泄漏、毁损或者丢失，包括但不限于SSL、通过https等方式提供浏览服务、信息加密存储、数据中心的访问控制等。我们对可能接触到您的信息的员工或外包人员也采取了严格管理，包括但不限于根据岗位的不同采取不同的权限控制，与他们签署保密协议，监控他们的操作情况等措施。倪匡会按现有技术提供相应的安全措施来保护您的信息，提供合理的安全保障，倪匡将尽力做到使您的信息不被泄漏、毁损或丢失。
2、您的账户均有安全保护功能，请妥善保管您的微信账户、手机号及验证码信息。倪匡将通过向其它服务器备份等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您理解，由于技术的限制以及可能存在的各种恶意手段，即便竭尽所能加强安全措施，在信息网络上也不存在“完善的安全措施”。我们强烈建议您不要使用非倪匡推荐的通信方式发送个人信息。如因您自己的原因导致账户、手机号码及验证码信息泄露而造成的任何法律后果需由您本人负责。
3、在使用倪匡平台服务进行网上交易时，如您不可避免地要向交易对方或潜在的交易对方披露自己的个人信息（例如联系人、联络方式等），请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息已经被泄露或者存在被泄露的可能，且有可能会危及您注册登录获得的倪匡账户安全，或者给您造成其他的损失的，请您务必在第一时间通知倪匡客服，以便倪匡采取相应措施维护您的倪匡账户安全，防止损失的发生或者进一步扩大。为避免疑义，如果您未在第一时间通知倪匡客服，则您应自行承担由此给您造成的损失（及扩大的损失）。
4、请注意，您在使用我们服务时自愿共享甚至公开分享的信息，可能会涉及您或他人的个人信息甚至个人敏感信息，如您在评价时选择上传包含个人信息的图片。请您更加谨慎地考虑，是否在使用我们的服务时共享甚至公开分享相关信息。
5、如果我们的物理、技术或管理防护设施遭到破坏，导致信息被非授权访问、公开披露、篡改或毁坏，导致您的合法权益受损，我们将承担相应的法律责任。在不幸发生个人信息安全事件后，我们将按照法律法规的要求向您告知：安全事件的基本情况和可能的影响、我们已采取或将要采取的处置措施、您可自主防范和降低风险的建议、对您的补救措施等。事件相关情况我们将以邮件、信函、电话、推送通知等方式告知您，难以逐一告知个人信息主体时，我们会采取合理、有效的方式发布公告。同时，我们还将按照监管部门要求，上报个人信息安全事件的处置情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a917f866ab2a301c67d72f633d5b2743/" rel="bookmark">
			python 66：re正则表达式7（全- tcy）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：
1.re-概述 https://mp.csdn.net/postedit/85156839
2.re-函数 https://mp.csdn.net/postedit/85156993
3.re-Pattern https://mp.csdn.net/postedit/85157041
4.re-match https://mp.csdn.net/postedit/85157072
5.re-分组 https://mp.csdn.net/postedit/85157147
6.re-扩展符号 https://mp.csdn.net/postedit/85157297
7.re- 预定义字符 https://mp.csdn.net/postedit/85157352
8.re-修饰符 https://mp.csdn.net/postedit/85157464
9.re-实例 https://mp.csdn.net/postedit/85157513
预定义字符： NO
类别
模式
描述
实例
匹配字符串
1
分界符
[…]
匹配任意1个字符；逐个列出或给出范围；可以用\w\S等
rub[ye]
匹配 "ruby" 或 "rube"
特殊字符用作原字符；]和-应该放字符集开头或加\；注1
[xyz]No或[a-c]No
匹配xNo,yNo,zNo ；[a-zA-Z0-9_]
2
功能字符
[^...] 反义
首字符^表示不在[]中的字符; [a^b] 匹配字符 ’a^b’ [^abc]
匹配除abc 之外字符
3
功能字符
[...]|[...]
匹配前或后的全部；限定范围用无捕获组 ‘(?: ) dog|cat
匹配dog或cat； r’I have a (?:dog|cat)’ 预定义字符
可写在字符集中[...]
1
预定义字符
\d
1位数字; 等价[0-9]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a917f866ab2a301c67d72f633d5b2743/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84a9ad840f64826e0ab1043d523464a9/" rel="bookmark">
			如何快速找到适合发表的期刊
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者收集了几个有用的网站供大家参考。
1、 https://journalfinder.elsevier.com/
2、https://journalsuggester.springer.com/
3、http://publication-recommender.ieee.org/home, IEEE 的recommender还能推荐会议，还是比较好用的
4、http://www.sjfinder.com/
5、https://unikllib.wordpress.com/2016/09/21/top-7-online-tools-that-provide-journal-recommendation-to-researchers/， 一个外国人汇总的地址
前4个应该足够用了。
笔者认为，主要找到适合自己工作发表的方式包括：
1、导师或者同僚的推荐
2、查看与自己相近工作的发表的期刊
3、查看自己follow的学者发表的期刊
4、使用期刊推荐系统
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bea9e4b0b7d5aa186eadedd0b2c319b/" rel="bookmark">
			react报错： dispatch is not a function
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		react报错： dispatch is not a function，需要在类前添加@connect(() =&gt; ({}))
import {connect} from 'dva'
@connect(() =&gt; ({}))
class Methods extends Component{
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ec78b433364bcb5ddfd9db59dc8e94d/" rel="bookmark">
			查看tomcat版本信息（32位还是64位）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开dos命令（windows键+r，输入cmd）
2、进入tomcat的bin目录，例如 cd F:\tools\apache-tomcat-8.5.37\bin，再输入f: 回车
3、输入catalina version 回车
4、完成。信息如下：architecture的后面，x86就是32位，amd64就是64位
Using CATALINA_BASE: "F:\tools\apache-tomcat-8.5.37"
Using CATALINA_HOME: "F:\tools\apache-tomcat-8.5.37"
Using CATALINA_TMPDIR: "F:\tools\apache-tomcat-8.5.37\temp"
Using JRE_HOME: "D:\java\jdk1.8.0_101\jre"
Using CLASSPATH: "F:\tools\apache-tomcat-8.5.37\bin\bootstrap.jar;F:\tools
\apache-tomcat-8.5.37\bin\tomcat-juli.jar"
Server version: Apache Tomcat/8.5.37
Server built: Dec 12 2018 12:07:02 UTC
Server number: 8.5.37.0
OS Name: Windows 7
OS Version: 6.1
Architecture: amd64
JVM Version: 1.8.0_101-b13
JVM Vendor: Oracle Corporation
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e8b693dd919edad0e48f52c32dc9f2b/" rel="bookmark">
			关于WEB网页出现Failed to execute ‘send’ on ‘XMLHttpRequest’：Failed to load ‘Url‘ 问题处理方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误截图：
场景：
在调用XMLHttpRequest是爆无法执行send的错误，百度 谷歌了一下回答千奇百怪跟我的问题产生场景不符合，所以自己手工调试跑代码，一行一行的测，后来发现是因为调用XMLHttpRequest 的Open方法至目标页面时，目标页面执行Response.Write(值)后流并没有完全释放，导致一直占用，然后XMLHttpRequest的send方法无法执行
奇怪的是我在context.Response.Write后面添加了Close();压根就没起作用导致流一直没有释放，后来直接把Flush()及Close()注释掉改成了End()就可以了，踩了个大坑，做个笔记记录一下
2020/12/22产生了相同的问题，经过调试当请求超时没返回请求结果时调用send()也会报相同的错误！！！
导致的原因更多的是在调用send()时目标方法执行过程中产生错误导致没有返回有效结果才使程序产生Failed to execute ‘send’ on ‘XMLHttpRequest’：Failed to load ‘Url‘
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd6939e7c4771900768d124ed994ef31/" rel="bookmark">
			这可能是最详细的目标检测YOLO_v1的解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLO 是 2016 年提出来的目标检测算法，在当时比较优秀的目标检测算法有 R-CNN、Fast R-CNN 等等，但 YOLO 算法还是让人感到很新奇与兴奋。
YOLO 是 You only look once 几个单词的缩写，大意是你看一次就可以预测了，灵感就来自于我们人类自己，因为人看一张图片时，扫一眼就可以得知这张图片不同类型目标的位置。
1.创新 YOLO将物体检测作为回归问题求解。基于一个单独的end-to-end网络，完成从原始图像的输入到物体位置和类别的输出。从网络设计上，YOLO与rcnn、fast rcnn及faster rcnn的区别如下：
[1]
YOLO训练和检测均是在一个单独网络中进行。YOLO没有显示地求取region proposal的过程。而rcnn/fast rcnn 采用分离的模块（独立于网络之外的selective search方法）求取候选框（可能会包含物体的矩形区域），训练过程因此也是分成多个模块进行。Faster rcnn使用RPN（region proposal network）卷积网络替代rcnn/fast rcnn的selective
search模块，将RPN集成到fast rcnn检测网络中，得到一个统一的检测网络。尽管RPN与fast rcnn共享卷积层，但是在模型训练过程中，需要反复训练RPN网络和fast rcnn网络（注意这两个网络核心卷积层是参数共享的）。
[2]
YOLO将物体检测作为一个回归问题进行求解，输入图像经过一次inference，便能得到图像中所有物体的位置和其所属类别及相应的置信概率。而rcnn/fast rcnn/faster rcnn将检测结果分为两部分求解：物体类别（分类问题），物体位置即bounding box（回归问题）。
2.设计理念 整体来看，Yolo算法采用一个单独的CNN模型实现end-to-end的目标检测，整个系统如下图所示：首先将输入图片resize到448x448，然后送入CNN网络，最后处理网络预测结果得到检测的目标。相比R-CNN算法，其是一个统一的框架，其速度更快，而且Yolo的训练过程也是end-to-end的。
YOLO将输入图像分成SxS个格子，每个格子负责检测‘落入’该格子的物体。若某个物体的中心位置的坐标落入到某个格子，那么这个格子就负责检测出这个物体。如下图所示，图中物体狗的中心点（红色原点）落入第5行、第2列的格子内，所以这个格子负责预测图像中的物体狗。
每个格子输出B个bounding box（包含物体的矩形区域）信息，以及C个物体属于某种类别的概率信息。
Bounding box信息包含5个数据值，分别是x,y,w,h,和confidence。其中x,y是指当前格子预测得到的物体的bounding box的中心位置的坐标。w,h是bounding box的宽度和高度。注意：实际训练过程中，w和h的值使用图像的宽度和高度进行归一化到[0,1]区间内；x，y是bounding box中心位置相对于当前格子位置的偏移值，并且被归一化到[0,1]。
confidence反映当前bounding box是否包含物体以及物体位置的准确性，计算方式如下：
若bounding box包含物体，则P(object) = 1；否则P(object) = 0. IOU(intersection over union)为预测boundingbox与物体真实区域的交集面积（以像素为单位，用真实区域的像素面积归一化到[0,1]区间）。
因此，YOLO网络最终的全连接层的输出维度是 S * S * (B * 5 + C)。YOLO论文中，作者训练采用的输入图像分辨率是448x448，S=7，B=2；采用VOC 20类标注物体作为训练数据，C=20。因此输出向量为7 * 7 * (20 + 2 * 5)=1470维。作者开源出的YOLO代码中，全连接层输出特征向量各维度对应内容如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd6939e7c4771900768d124ed994ef31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71456ad179783594572a593d2759dc53/" rel="bookmark">
			vue实现后台实时编辑预览页面，小程序端展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个功能是在后台编辑小程序页面，然后在小程序端展示出来。
左侧预览，右侧编辑，下方点击可以添加对应组件。
图片广告(轮播图)组件：
富文本组件：
整体功能的思路是这样的：
新建与编辑是同一个页面，进入页面时请求后端提供的接口拿到数据库中的数据，并展示出来，点击发布按钮请求后端接口把数据保存到数据库中。
json数据格式：
list:[ { cardRight: 1, type: "image_ad", showRight: false, images:[ { url:'', title:'' } ] } { cardRight: 2, type: "rich_text", showRight: false, content: "&lt;p&gt;这是富文本的内容&lt;/p&gt;" } ] 父组件左侧思路：
&lt;!--左侧预览区域--&gt; &lt;div class="list" v-for="(item,index) in list" :key="index" @click="left_click(index)" :class="leftIndex == index ? 'border' : ''"&gt; &lt;!--删除按钮--&gt; &lt;div v-if="leftIndex == index" class="close" @click.stop @click="close(index)"&gt; &lt;img src="../../assets/xx.png" alt=""&gt; &lt;/div&gt; &lt;!--图片广告左侧预览组件--&gt; &lt;imageAd v-if="item.type == 'image_ad'" :list="list" :leftIndex="index"&gt;&lt;/imageAd&gt; &lt;!--富文本左侧预览组件--&gt; &lt;richText v-if="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71456ad179783594572a593d2759dc53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c511ec6a49537ad300b9e1ae90f8a0f6/" rel="bookmark">
			实现element-ui对话框可拖拽功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		element-ui对话框可拖拽及边界处理 应业务需求，需要实现对话框可拖拽问题，应element-ui没有提供官方支持，于是便参考大神的文章，得出了适合业务需要的解决方案。很多大神给出的代码是没有解决边界问题的，但是不解决边界问题存在一个bug，拖到不可视区域后边再也拖不回来了，不信你们可以试试。
在实现的功能的情况下，封装成了js文件，然后再main.js中引入后可全局使用。先看下vue-draggable-resizable 可拖拽缩放的组件
还是上代码吧
功能实现代码directives.js代码如下：
import Vue from 'vue'; // v-dialogDrag: 弹窗拖拽属性 Vue.directive('dialogDrag', { bind(el, binding, vnode, oldVnode) { const dialogHeaderEl = el.querySelector('.el-dialog__header'); const dragDom = el.querySelector('.el-dialog'); //dialogHeaderEl.style.cursor = 'move'; dialogHeaderEl.style.cssText += ';cursor:move;' dragDom.style.cssText += ';top:0px;' // 获取原有属性 ie dom元素.currentStyle 火狐谷歌 window.getComputedStyle(dom元素, null); const sty = (function() { if (window.document.currentStyle) { return (dom, attr) =&amp;gt; dom.currentStyle[attr]; } else{ return (dom, attr) =&amp;gt; getComputedStyle(dom, false)[attr]; } })() dialogHeaderEl.onmousedown = (e) =&amp;gt; { // 鼠标按下，计算当前元素距离可视区的距离 const disX = e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c511ec6a49537ad300b9e1ae90f8a0f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/878ef0dc744a9ca7985a0994fb68aeda/" rel="bookmark">
			Spring里面Bean的生命周期和循环依赖问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是Spring的循环依赖？
循环依赖不是我们程序里面的死循环，它是一种对象之间的依赖关系。
2. Spring如何检测循环依赖？
Spring在创建Bean的时候做一个标记，采用递归进行调用如果发现Bean还在创建中，就说明有循环依赖。
3. Spring循环依赖产生的时机？
我们知道Spring注入的方式有三种 ，分别是构造方法，属性注入，自动注入，构造方法和属性注入是比较常用的。
现在这样一个场景，A---》B-- &gt;C ---》A，A依赖B，B依赖C，C依赖A，如果使用构造方法，将会产生错误，错误信息是正在制作的Bean。
但是使用属性注入的方式，将不会产生错误，这是因为Spring采用构造方法先实例化Bean，然后把它放到对应CurrentHashMap中，但是没有设置属性值。也就是说我们可以得到未设置属性的bean，及可以得到实例化BeanA，但是A依赖B，这样就可以从map里面取出B的实例，这样就可以循环依赖问题。
4. 如何解决Spring循环依赖？
那么需要在spring源码里面的看createBean() --- 》doCreateBean()方法
分析：我们得到一个完整实例bean，需要通过上面三个步骤：
1. createBeanInstance方法： 得到一个实例bean，但是没有进行属性值的注入
2. populateBean方法：就是对bean进行属性值注入。
3. initializeBean方法：如果配置文件里面有init方法，需要执行init方法。
可以看出第一步和第二部比较重要，这里面就是解决bean依赖的关键
分析：我们可以看出进行createBeanInstance方法，得到了bean实例对象，但是没有属性注入。把没有完全实例化的bean，放到addSinletonFactory方法里面去，这样相当于就是提前暴露bean，接下来addSinletonFactory方法，这里面使用三个Map类型的，及三级缓存来解决循环依赖。接下我们看一下addSingletonFactory方法实现。
分析：这三个Map类型是什么呢？
singleObjects--》单例对象的cache：一级缓存
earlySingletonObjects --》提前暴光的单例对象的Cache ：二级缓存
singletonFactories --》单例对象工厂的cache ：三级缓存
分析：这就是得到一个未完全实例化的bean，以及得到它的过程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dd8385df30d6f18e086d349715eb110/" rel="bookmark">
			Pycharm永久激活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://mp.weixin.qq.com/s?__biz=MzI0OTc0MzAwNA==&amp;mid=2247484191&amp;idx=1&amp;sn=d27e586afed417ffa7fe4151694ff268&amp;chksm=e98d90ecdefa19fa725ed7a2b2fe6c6096f6682392a73fd04ea306d6f53701dcf564bf429dc3&amp;mpshare=1&amp;scene=1&amp;srcid=1219GCs9SGFYBH1B72kkDzjz&amp;pass_ticket=r43X5bZsAiN98vxhXkAsSzO7%2BXF4Xjb%2B8kNntPq%2FFTRLP92ksCw6LkHSmbNboV4Z#rd
1.下载新版破解补丁 下载链接为：https://pan.baidu.com/s/1mcQM8CLUnweY02ahKEr4PQ 或点击阅读原文下载破解补丁。然后将下载的补丁保存到PyCharm安装目录下的\bin目录下。其实保存在哪并没有关系，只是放在\bin目录下更合理也更安全些，防止以后误删除。例如我的PyCharm安装目录为D:\JetBrains\PyCharm，所以我把补丁放在D:\JetBrains\PyCharm\bin目录下面，总之记住这个路径，因为后面需要添加到配置文件中。
2.修改配置文件 在PyCharm安装目录下的\bin目录中找到pycharm.exe.vmoptions和pycharm64.exe.vmoptions，以文本格式打开并同时在两个文件最后追加一行内容：-javaagent:你的安装路径\bin\JetbrainsCrack-release-enc.jar，然后保存。
例如：-javaagent:D:\JetBrains\PyCharm \bin\JetbrainsCrack-release-enc.jar
注意：这里的D:\JetBrains\PyCharm\bin\JetbrainsCrac-release-enc.jar就是第一步下载的补丁保存的路径，自己填写的时候千万记得要修改成你的安装路径
3.输入激活码 启动PyCharm，选择激活码激活，直接复制下面的内容到激活框内（如果你原来已使用激活码已经激活，先下载补丁，然后点击：Help-&gt;Register-&gt;Activation code然后复制下面的内容到输入框）然后点激活就okay啦~
下面是破解补丁激活方式的激活码：
ThisCrackLicenseId-{
“licenseId”:”11011”,
“licenseeName”:”Wechat”,
“assigneeName”:”IT--Pig”,
“assigneeEmail”:”1113449881@qq.com”,
“licenseRestriction”:””,
“checkConcurrentUse”:false,
“products”:[
{“code”:”II”,”paidUpTo”:”2099-12-31”},
{“code”:”DM”,”paidUpTo”:”2099-12-31”},
{“code”:”AC”,”paidUpTo”:”2099-12-31”},
{“code”:”RS0”,”paidUpTo”:”2099-12-31”},
{“code”:”WS”,”paidUpTo”:”2099-12-31”},
{“code”:”DPN”,”paidUpTo”:”2099-12-31”},
{“code”:”RC”,”paidUpTo”:”2099-12-31”},
{“code”:”PS”,”paidUpTo”:”2099-12-31”},
{“code”:”DC”,”paidUpTo”:”2099-12-31”},
{“code”:”RM”,”paidUpTo”:”2099-12-31”},
{“code”:”CL”,”paidUpTo”:”2099-12-31”},
{“code”:”PC”,”paidUpTo”:”2099-12-31”}
],
“hash”:”2911276/0”,
“gracePeriodDays”:7,
“autoProlongated”:false}
4.查看有效期 当你激活完毕后，PyCharm右下角会有个Registration小长条提示框，大致的内容为：You copy is Licensed to XXX意思就会告诉你：兄弟，你已经激活成功了，激活码的许可来源是：XXX。
查看有效期的步骤为点击：Help-&gt;About这里可以看到你的pycharm的版本号、许可来源、有效期、以及一些环境
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ade1422f08469b0cb35a10a9a3ad8f3/" rel="bookmark">
			PyTorch 学习笔记（一）：让PyTorch读取你的数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文截取自《PyTorch 模型训练实用教程》，获取全文pdf请点击：https://github.com/tensor-yu/PyTorch_Tutorial
文章目录 Dataset类构建Dataset子类 想让PyTorch能读取我们自己的数据，首先要了解pytroch读取图片的机制和流程，然后按流程编写代码。
Dataset类 PyTorch读取图片，主要是通过Dataset类，所以先简单了解一下Dataset类。Dataset类作为所有的datasets的基类存在，所有的datasets都需要继承它，类似于C++中的虚基类。
源码如下：
class Dataset(object): """An abstract class representing a Dataset. All other datasets should subclass it. All subclasses should override ``__len__``, that provides the size of the dataset, and ``__getitem__``, supporting integer indexing in range from 0 to len(self) exclusive. """ def __getitem__(self, index): raise NotImplementedError def __len__(self): raise NotImplementedError def __add__(self, other): return ConcatDataset([self, other]) 这里重点看 getitem函数，getitem接收一个index，然后返回图片数据和标签，这个index通常指的是一个list的index，这个list的每个元素就包含了图片数据的路径和标签信息。
然而，如何制作这个list呢，通常的方法是将图片的路径和标签信息存储在一个txt中，然后从该txt中读取。
那么读取自己数据的基本流程就是：
制作存储了图片的路径和标签信息的txt将这些信息转化为list，该list每一个元素对应一个样本通过getitem函数，读取数据和标签，并返回数据和标签 在训练代码里是感觉不到这些操作的，只会看到通过DataLoader就可以获取一个batch的数据，其实触发去读取图片这些操作的是DataLoader里的__iter__(self)，后面会详细讲解读取过程。在本小节，主要讲Dataset子类。
因此，要让PyTorch能读取自己的数据集，只需要两步：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ade1422f08469b0cb35a10a9a3ad8f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5689407e699ea2a3d26629a470870d3/" rel="bookmark">
			eclipse更换jdk版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Window—Preferences—Java—Compiler—右侧面板设置为1.6
2.Window—Preferences—Java—Installed JREs—右侧面板“Add”本地的1.6版本jdk路径，并勾上
以上已经完成eclipse的jdk的变更
3.在你需要变更jdk版本的项目右键选择
可以编辑你的jdk和添加jdk
4.与Java Build Path同级目录下的Java Compiler中的右侧面板设置为你需要的jdk版本
5.与Java Build Path同级目录下的Project Facets中的右侧面板设置为你需要的jdk版本
以上项目中的jdk版本设置完毕
注意事项：所有的设置必须要Applly才能生效
如果你导入了别人的新项目，新项目导入进来项目报错，很可能是因为对方的Jdk版本和你不一致，所以可以尝试修改项目的Jdk,前提是你导入的项目在对方的电脑上能运行，且在你的电脑配置正确，比如数据库等配置信息，配置文件中的路径没有问题，然后重新Build一下项目。
博主遇到过一个问题：jdk1.6的版本必须使用tomcat7.0的服务器，不然很可能运行出错。
说在最后的话：编写实属不易，若喜欢或者对你有帮助记得点赞+关注或者收藏哦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbd91e90dd39b023eeccea2b86eeef7e/" rel="bookmark">
			VS 编译报“常量中有换行符”错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法：
在资源管理器中找到报错代码文件，用文本编辑器打开，然后另存选择编码选项为UTF-8，覆盖原有文件，重新编译即可！
转载于:https://www.cnblogs.com/PieDaoChuan/p/10141141.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ed48a97255da2b20a5a4c1c48f1df26/" rel="bookmark">
			MATLAB 正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB 正则表达式 文章目录 MATLAB 正则表达式与正则表达式相关的函数regexp 用法输出类型如何构建 exp元字符字符转义重复限定符重复限定符的三种模式分组运算符锚点选项（option） 例子 与正则表达式相关的函数 matlab 中与正则表达式相关的函数：
函数名功能regexp匹配正则表达式，大小写敏感regexpi匹配正则表达式，大小写不敏感regexprep基于正则表达式进行字符替换 regexp 用法 以 regexp 为例说明用法
startIndex = regexp(str, exp) [startIndex, endIndex] = regexp(str, exp) [out1, out2, ...] = regexp(str, exp, outkey1, outkey2, ...) out = regexp(str, exp, option, ...) 其中，str 为待匹配的字符串，exp 为正则表达式，outkey 用于指明输出的类型。option 为可选的选项。
输出类型 outkey 取值：
如何构建 exp 元字符 . : 匹配任意一个字符 [c1c2c3] : 匹配来自方括号内的任意一个字符（+，-，.，*，?，|，$ 按照字面处理, - 表示范围除外） [^c1c2c3] : 匹配除方括号内字符以外的任意一个字符（+，-，.，*，?，|，$ 按照字面处理, - 表示范围除外） [c1-c2] : 匹配介于 c1-c2 之间的任意一个字符 \w : 匹配字母、数字、下划线中的任意一个字符 &lt;==&gt; [a-z_A-Z0-9] \W : 匹配除字母、数字、下划线以外的任意一个字符 &lt;==&gt; [^a-z_A-Z0-9] \s : 匹配任意一个空白符 \S : 匹配任意一个非空白字符符 \d : 匹配任意一个数字 \D : 匹配任意一个非数字字符 字符转义 重复限定符 重复限定符的三种模式 重复限定符 *, +, ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ed48a97255da2b20a5a4c1c48f1df26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d74e44ecb26d7b377fa55419f66d005/" rel="bookmark">
			PyTorch学习之归一化层（BatchNorm、LayerNorm、InstanceNorm、GroupNorm）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BN，LN，IN，GN从学术化上解释差异：
BatchNorm：batch方向做归一化，算NHW的均值，对小batchsize效果不好；BN主要缺点是对batchsize的大小比较敏感，由于每次计算均值和方差是在一个batch上，所以如果batchsize太小，则计算的均值、方差不足以代表整个数据分布
LayerNorm：channel方向做归一化，算CHW的均值，主要对RNN作用明显；
InstanceNorm：一个channel内做归一化，算H*W的均值，用在风格化迁移；因为在图像风格化中，生成结果主要依赖于某个图像实例，所以对整个batch归一化不适合图像风格化中，因而对HW做归一化。可以加速模型收敛，并且保持每个图像实例之间的独立。
GroupNorm：将channel方向分group，然后每个group内做归一化，算(C//G)HW的均值；这样与batchsize无关，不受其约束。
SwitchableNorm是将BN、LN、IN结合，赋予权重，让网络自己去学习归一化层应该使用什么方法。
1 BatchNorm torch.nn.BatchNorm1d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
torch.nn.BatchNorm2d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
torch.nn.BatchNorm3d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
参数：
num_features： 来自期望输入的特征数，该期望输入的大小为’batch_size x num_features [x width]’
eps： 为保证数值稳定性（分母不能趋近或取0）,给分母加上的值。默认为1e-5。
momentum： 动态均值和动态方差所使用的动量。默认为0.1。
affine： 布尔值，当设为true，给该层添加可学习的仿射变换参数。
track_running_stats：布尔值，当设为true，记录训练过程中的均值和方差；
实现公式：
2 GroupNorm torch.nn.GroupNorm(num_groups, num_channels, eps=1e-05, affine=True)
参数：
num_groups：需要划分为的groups
num_features： 来自期望输入的特征数，该期望输入的大小为’batch_size x num_features [x width]’
eps： 为保证数值稳定性（分母不能趋近或取0）,给分母加上的值。默认为1e-5。
momentum： 动态均值和动态方差所使用的动量。默认为0.1。
affine： 布尔值，当设为true，给该层添加可学习的仿射变换参数。
实现公式：
3 InstanceNorm torch.nn.InstanceNorm1d(num_features, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
torch.nn.InstanceNorm2d(num_features, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d74e44ecb26d7b377fa55419f66d005/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53324e14cb3f1530355999b0920f7a17/" rel="bookmark">
			Android全局异常捕获，并将错误信息保存到SD卡中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//首先实现接口，重写方法 public class UnCatchHandler implements Thread.UncaughtExceptionHandler { //静态，实例化一下当前的类 private static UnCatchHandler mUnCatchHandler = new UnCatchHandler(); //上下文 private Context mContext; //写一个静态方法，返回当前类的实例 public static UnCatchHandler getInstance() { return mUnCatchHandler; } public void init(Context context) { //获取默认的系统异常捕获器 //把当前的crash捕获器设置成默认的crash捕获器 Thread.setDefaultUncaughtExceptionHandler(this); mContext = context.getApplicationContext(); } 这是重写的方法 @Override public void uncaughtException(Thread t, Throwable e) { try { //抽取成一个方法 saveSD(e); } catch (Exception ex) { ex.printStackTrace(); } } //存储到sd卡 private void saveSD(Throwable throwable) throws Exception { //首先判断SD卡的挂载状态 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53324e14cb3f1530355999b0920f7a17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea84c4ac22e39c594d9e17977eae0099/" rel="bookmark">
			ImageView设置setSelected()无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//xml定义如下 &lt;ImageView android:id="@+id/iv_yang" android:layout_width="0dp" android:layout_weight="1" android:layout_height="wrap_content" android:src="@drawable/select_yang_sleep"/&gt; 其中drawable中
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@mipmap/ic_yang_normal"/&gt; &lt;item android:drawable="@mipmap/ic_yang_select" android:state_selected="true"/&gt; &lt;/selector&gt; 就问问哪里不妥了······各种姿势试了一遍，愣是一点反应也没有······
最后，看以前自己写的xml做对比，就继续摆姿势：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@mipmap/ic_yang_select" android:state_selected="true"/&gt; &lt;item android:drawable="@mipmap/ic_yang_normal"/&gt; &lt;/selector&gt; 仅仅是把，默认状态放下面，就amazing般的有效了······
原理：********会的补充
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/823d6b148d0d50ff64b72e9a2e3d1a16/" rel="bookmark">
			mount时候遇到mount: /dev/sdd1 写保护，将以只读方式挂载。mount: 未知的文件系统类型“(null)”...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 昨天遇到一个问题，由于之前的硬盘坏了，说磁道有问题，最后只好放弃数据（因为有其他备份）然后重新复制其他盘数据过来，格式化硬盘后我一直按照之前的方式都没有报错，但是当我挂载硬盘时候错误来了
[root@localhost mnt]# mount /dev/sdd1 /mnt/data1/ mount: /dev/sdd1 写保护，将以只读方式挂载 mount: 未知的文件系统类型“(null)” 查了好多文章开始时候都说可以采用只读方式挂载试试，但是我又不是光驱，肯定要读取，蛮试试
[root@localhost mnt]# mount -o ro /dev/sdd1 /mnt/data1/ mount: 未知的文件系统类型“(null)” 看来问题不在这，那就是文件系统问题，可是我明明格式化过了啊，再格式化一次
[root@localhost mnt]#mkfs.ext4 /dev/sdd 正常结束，然后重试了上面的命令还是不行，后面不知道哪个筋搭对了，我发现了一个猫腻，再看下面的命令
[root@localhost mnt]#mkfs.ext4 /dev/sdd1 然后再试了上面的命令，居然成功了，看来是自己经验不足，在这里卡了好久，以后记得注意格式化是要格式化分完区的盘，而不是分区前的盘符名
转载于:https://my.oschina.net/ZhenyuanLiu/blog/2990085
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/434a04009b263e3484678be8bd88a5e7/" rel="bookmark">
			mysql8创建用户并授权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以下的权限和root一样权限
创建用户 CREATE USER 'zhangsan'@'%' IDENTIFIED BY zhangsan123'; 授予所有权限 GRANT ALL PRIVILEGES ON *.* TO 'zhangsan'@'%' WITH GRANT OPTION; 错误信息 ：
1251 client does not support
解决方法：
修改用户密码
ALTER USER 'zhangsan'@'%' IDENTIFIED WITH mysql_native_password BY 'zhangsan111'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7291829959702652c14e917d4c232b7/" rel="bookmark">
			Luogu P2708 硬币翻转 题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Luogu p2708题解 思路： 由于我们这个题目的长度不知道，所以我们不能一次性输入所有的硬币的状态，也许会爆数组(Ps:我没试过我不是知道)。所以我们为了保险采取用getchar()一个一个读入硬币的状态的方法。然后我们可以发现假如当前输入的硬币的状态和之前所有硬币的状态不一样的时候我们要把当前硬币之前的所有硬币的状态修改掉。如果不修改那么之后不管怎样改变状态都不能让所有硬币的状态都一样了。我们要去把之前所有的硬币都修改得和当前的硬币一样。最后我们这样做硬币肯定都是一样的了。然后判断所有硬币是否都朝上，如果都不朝上那么就还要再翻动一次硬币。最后我们不可能去真的修改前缀要不然很可能会超时，并且这样做的话前面的所有硬币都是一样的。所以我们用一个bool变量flag来存储当前硬币之前的所有硬币是否朝上，如果是true就是朝上否则朝下。
代码： #include &lt;cstdio&gt; int get_ans() { int ans = 0; char ch = getchar(); bool flag = (ch == '1'); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { if ((ch == '1') != flag) { ++ans; flag = (ch == '1'); } ch = getchar(); } if (!flag) ++ans; return ans; } int main(int argc, char const *argv[]) { int ans = get_ans(); printf("%d\n", ans); return 0; } 转载于:https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7291829959702652c14e917d4c232b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbe641b23d8a0609eab9c7259ebeba3a/" rel="bookmark">
			免费资源网站大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网盘类：网盘类百搭，放第一个了
推荐
盘多多： http://www.panduoduo.net
去转盘： http://www.quzhuanpan.com
Bdsola: http://www.3134.cc
西林街： http://www.xilinjie.com
潜力股
探索云盘搜索： http://tansuo233.com
BDY搜： http://www.bdysou.com
盘窝窝： http://www.panww.com
百度网盘搜索： http://uzi8.cn
网盘007： https://wangpan007.com 其他
胖次： http://www.panc.cc
盘搜搜： http://www.pansoso.com
番茄搜索： https://www.fqsousou.com
微友搜索： http://www.weiyoou.com
凌风云： https://www.lingfengyun.com
盘优搜： http://www.panuso.comsoso
云盘：http://www.sosoyunpan.com 特百度： http://www.tebaidu.com 搜百度盘：http://www.sobaidupan.com pan115:http://www.pan115.com 鸵鸟搜索：http://www.tuoniao.me 我的盘： http://www.wodepan.com 搜网盘： http://www.swangpan.com 51菜场： http://wx01.51caichang.com 网盘之家：http://www.wangpanzhijia.net
及搜盘：http://www.jisoupan.com 众人搜索：http://wangpan.renrensousuo.com 行笑网： http://www.walksmile.com 史莱姆搜索：http://www.slimego.cn 百度云盘：http://www.baiduyunpan.com 3百搜：http://www.3bsou.com 58网盘搜索：http://www.58wangpan.com 56网盘搜索：http://www.56wangpan.com 我搜云： http://www.wosouyun.com 91百度盘：http://www.91baidupan.com 坑搜：http://www.kengso.com 搜盘吧： http://www.sopanba.com 搜盘侠： http://www.sopanxia.com
电影类：
电影首发站：http://www.dysfz.cc
The Pirate Ba：https://thepiratebay.org
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbe641b23d8a0609eab9c7259ebeba3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/116955e2c2fe2e4c060101002bfa8e42/" rel="bookmark">
			Java通过Jpcap 操作网路数据链路层对报文数据解析、监听网络数据包（服务器&#43;客户端）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，Java语言虽然在TCP/UDP传输方面给予了良好的定义，但对于网络层以下的控制，却是无能为力的。JPCAP扩展包弥补了这一点。
JPCAP实际上并非一个真正去实现对数据链路层的控制，而是一个中间件，JPCAP调用wincap/libpcap，而给JAVA语言提供一个公共的接口，从而实现了平台无关性。在官方网站上声明，JPCAP支持FreeBSD 3.x, Linux RedHat 6.1, Fedora Core 4, Solaris, and Microsoft windows 2000/XP等系统。
使用Jpcap能做的事：
1.Jpcap是直接抓取经过数据链路层的数据包。 因此可以自己写IP数据包直接发送给数据链路层。
2.Jpcap会对抓取到的数据包进行一定程序的解析，根据数据包内容，将数据包封装为对应的对象（）。
3.根据用户设定的信息，过滤数据包（其实就是在解析的时候，对不需要的数据直接丢弃，不解析）
4.Jpcap 只是直接从数据链路层上读取数据，并向数据链路层中发送数据，因此，Jpcap并不能操作 其他程序从数据链路层中读数据或者向网卡中发送数据。（IP层协议程序）
二话不说首先我们先上项目结构
所需要的jar包我已打包好
0、客户端 InfraredSensorClient.java
package com.airtimes.netty.network.client; import com.airtimes.netty.network.client.handler.InfraredSensorClientHandler; import io.netty.bootstrap.Bootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioSocketChannel; /** * * 服务器持续监听宿主机的网卡信息、并时时返回报警中心协议在网卡中交换的数据 * 客户端接收服务器端数据，打印出服务器送的消息 * */ public class InfraredSensorClient { public static void main(String[] args) throws Exception { // 创建EventLoopGroup线程池 Netty内部都是通过线程在处理数据 EventLoopGroup workerGroup = new NioEventLoopGroup(); try { // 创建客户端连接基类 用于连接服务器 Bootstrap bootstrap = new Bootstrap(); // (1) // 将 EventLoopGroup 加入线程池 bootstrap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/116955e2c2fe2e4c060101002bfa8e42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e87e7e10e2453fad76576c8aceda064/" rel="bookmark">
			MATLAB中用fprintf函数实现矩阵原样输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[l1,l2,l3] = size(A3);
fid = fopen(‘test.txt’,‘w’);
for j = 1:l3
for k = 1:l2
fprintf(fid,’%e\t’,A3(:,k,j));
fprintf(fid,’%s\n’,‘一行finish’);
end
fprintf(fid,’%s\n’,"------------------------------------------");
end
fclose(fid);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8cdd8d84eaba516d5afbbb4f0ef4ff4/" rel="bookmark">
			C6748芯片的运行频率设到最大300MHz，但实际运行速度很慢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体情况如下：
目的：通过c6748定时器控制其GPIO引脚输出特定的脉冲，用于控制 led 芯片 tlc5973的灰度；
遇到的问题：代码实际运行的时候发现脉冲周期比实际设定的定时周期大很多（定时器周期为设为4us，实际周期30多个us），相差很大，检查之后发现cpu实际运行速度根本达不到所设定的300MHz，写GPIO引脚的输出寄存器这一句代码都需要240纳秒，其他函数的运行时间也都比较长，普遍在10us左右。
编程环境及细节：我是在ccs开发环境下创建sys/bios工程中运行得出的结果，为了控制脉冲的变化，需要在定时中断中反复的重设定时周期并重启定时器，定时器的周期设置和重新启动使用的是sys/bios提供的函数Timer_setperiod()和Timer_start()，这两个TI官方提供的函数的运行时间也都在10us以上，因为定时器设为单次运行模式即一次定时中断后即停止，在中断中重新设置周期后再启动，这两个定时器函数在定时器中断中调用，二者的运行时间很长，导致最终GPIO引脚输出的脉冲周期超过所设长度。
PLL和PSC的设置都检查过了，编译器选型也都没有改过，应该是CCS软件默认设置，考虑过可能是调试状态的影响，试过在release模式下运行，结果还是异常，刚接触dsp，没经验，困在这个问题中很久了，急需高手指点迷津，在此先行谢过！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/831590144464c45700997bddb039e342/" rel="bookmark">
			为什么使用Spring的@autowired注解后就不用写setter了？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么使用Spring的@autowired注解后就不用写setter了？ 刚学习Spring的时候，知道了@autowired注解是非常灵活的，既可以直接写在Properties（属性）上，也可以写在属性相应的setter方法上，亦或者直接写在Constructer(构造器）上，但是有一天，我却惊奇的发现，为什么在Properties上写了@autowired注解后，不写这个属性相应的setter方法，竟然一点问题都没有？？？喵喵喵？怀着好奇心，我决定探索一番，看一看Spring究竟是如何神奇得make it的！ 问题描述 我使用Spring有一段时间了，并且我认为通过使用@autowired注解来完成一个属性的依赖注入，一定需要在类中写与这个属性相对应的setter方法，这样Spring才能够成功的完成注入。
所以，我平常都是像下面这样来使用Spring的@autowired注解的:
然而有一天，我偷懒忘记写injectedService属性的setter方法了，就像下面这样：
当我启动之后，我想，这下完了，肯定又要报错重写了。。然而，神奇的事情却发生了，没有编译错误，也没有启动错误，程序运行的非常的完美。。。
问题是老师不是说过吗？在java中如果属性或者方法的标识符是private的话，是不能直接访问这个属性的，必须通过setter和getter方法才能够访问这个属性的啊？莫非老师讲的是错误的？真奇怪啊。。。
所以，我的问题是：使用@autowired注解来完成属性的依赖注入，一定要写属性相应的setter方法吗？
解决办法 当使用@autowired注解时，你不需要再去写getter和setter方法了，之所以不用写，秘诀就在于java的“反射机制”。
java允许用户关闭【属性】或者【方法】的【访问控制权限】，也就是说，本来你的属性或者方法声明了【private】，在访问类中的这个private标识的某个属性时，Java首先会进行一个【安全检查】，确认一下你要访问的这个属性的访问权是啥，如果是【public】,那好，你可以直接访问。如果是【private】，对不起，你不能直接访问我类中的这个私有属性。
按照正常的操作是这样的，但是！Java还提供了一个方法，能够让你关闭属性或者方法的【访问控制权限】，比如你即使声明了这个属性是private的，但是我仍然还是可以通过【类.属性】的方法直接访问你的这个【私有属性】，那么这个神奇的方法是什么呢？那就是我们反射框架中：
讲到这个地方就涉及到我们的“反射机制”了，如果还不了解【反射机制】的同学，可以看我的另一篇介绍反射机制的博文。
那么，Java是如何通过反射机制来改变控制权限的呢？
首先，让我们来看一看官方文档是如何介绍这个setAccessible（）方法的吧：
重点在这里，我们的【构造器】，【属性】，【方法】原来都是一个叫做【AccessibleObject】类的子类啊！那么我们的【属性】能够更改【访问控制权限】，是不是在他的父类【AccessibleObject】中有实现了逻辑呢？
我们再从中找一下看看【AccessibleObject】这个类中有没有什么相关的“线索”：
果不其然，我们发现了一个下面的方法：
public void setAccessible(boolean flag) throws SecurityException 下面是官方文档对这个方法的作用的具体解释：
Set the accessible flag for this object to the indicated boolean value. A value of true indicates that the reflected object should suppress Java language access checking when it is used. A value of false indicates that the reflected object should enforce Java language access checks.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/831590144464c45700997bddb039e342/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fb6572cddeee5e5a2aa420f884d445c/" rel="bookmark">
			CSS3可以设置边框是向内还是向外，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果要设置为内边框使用box-sizing: border-box;
外边框box-sizing: content-box;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb946f6b291a3e1dbd4bb18b0fbffac4/" rel="bookmark">
			Ubuntu18.04安装搜狗输入法-问题全讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu18.04安装搜狗输入法 文章目录 Ubuntu18.04安装搜狗输入法序言细数Ibus的坑坑一坑二坑三坑四 转投fcitx的坑 从完全卸载fcitx输入框架开始以最简配置安装fcitx安装搜狗拼音输入法配置和重启更改默认输入法框架为fcitxfcitx配置将fcitx设置为开机自启动搜狗拼音输入法配置最后重启，确保设置都已生效 RAQ：罕见问题答疑问题一：搜狗输入法候选面板乱码问题二：搜狗输入法的候选面板有两个 总结 序言 吐槽时间。
Ubuntu系统我是从14.04_LTS，一路系统升级到18.04_LTS的。由于Ibus输入框架的不完善和不友好，从Ubuntu-14.04_LTS开始我就一直用搜狗输入法的Linux版，升级到16.04_LTS没问题，但是升级到18.04_LTS就有问题了。搜狗输入法打不出字了，卸载重装之后，发现候选面板是乱码，呵呵哒！！！
然后……
谁天天有时间倒腾一个输入法啊，在尝试了几次重装搜狗输入法和fcitx输入框架仍不生效的情况下，我换用了Ibus框架。接着，无数的坑就来了。
细数Ibus的坑 坑一 Ibus输入框架是Ubuntu-18.04_LTS官方指定的输入框架。所以，他的各种操作都是分散在各个系统设置中的，呵呵哒！！！
比如:
切换输入法的快捷键的设置在“系统设置”中的“键盘”设置的“打字”项中。
输入源的位置也是奇葩，在“系统设置”中的“区域和语言”设置的“输入源”项中。而且输入源也超级少，只有“智能拼音”和“Sun拼音”两种。
坑二 除了上面设置项位置不统一的问题之外，最严重的还是使用Ibus输入框架输入法本身的问题，响应速度超级慢，绝对不跟手。谁用谁知道。而且总是容易卡顿，你敢信。注意，是真的卡顿，经常性的。
坑三 输入法的另外一个问题就是：字符拆分简直脑残。尤其是Sun拼音，问题最严重。因为Sun拼音比智能拼音响应速度快，所以我一直用的都是Sun拼音。我打个“qinaide”（就是想打出“亲爱的”），他给我的候选词是“其奈的”，而且后面的候选词越差越远。要想打出想要的词，还得自己拆分，要打成“qin’ai’de”。呵呵哒！！！
坑四 系统“默认使用”的Ibus框架，这个比较狠。这就意味着，即使你替换了Ibus框架，选用了fcitx框架，也只是普通应用可以使用。像系统搜索等需要输入法的地方，还是会继续用Ibus的，不管此时的默认输入法框架是不是Ibus。所以，即使不用Ibus框架，也要将这个框架配置好。
转投fcitx的坑 今天，2018-12-15号，再一次经历了Ibus的Sun拼音卡顿，最后卡死的情况之后，我决定，重整fcitx，将搜狗拼音输入法的问题搞定。毕竟，搜狗输入法的跟手感，和用起来的畅快感，是其他输入法比不了的。而且还可以换皮肤，有云词库，账号中心。这些都是很有吸引力的。
话不多说，走起！
从完全卸载fcitx输入框架开始 由于之前倒腾搜狗输入法时，把fcitx卸载并重新安装了，在着急用输入法的情况下，把fcitx弄的一团糟。所以，我们现在把fcitx及其相关的东西，完全卸载、清除掉。
执行如下语句：
# 先卸载掉fcitx，及其所有相关的软件 sudo apt -y --purge remove *fcitx* # 然后来个彻底清除 sudo apt clean *fcitx* 其实也就是下面这么干的，不过上面的相当简洁：
# 先列出系统中安装的所有与fcitx相关的软件 sudo apt list | grep fcitx # 然后根据列出来的东西，删除掉所有能删除掉的软件 sudo apt -y --purge remove fcitx* fcitx-table* fcitx-config* # 然后清除其依赖的残余的库 sudo apt clean fcitx* fcitx-table* fcitx-config* 这样，fcitx输入法框架就清理干净了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb946f6b291a3e1dbd4bb18b0fbffac4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03d3e23f6f68d4ce38a9b28035e9f028/" rel="bookmark">
			理解vue项目webpack配置中的path.reslove
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上图后解释
path.resolve()将路径或者路径序列转换成绝对路径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d1328b88bb64d9e27b311198c68b1ad/" rel="bookmark">
			Eclipse安装JRebel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：JRebel有什么用呢？JRebel可快速实现热部署，节省了大量重启时间，提高了个人开发效率。对于Java应用程序来说，热部署就是在运行时更新Java类文件。大部分的时候就不需要重新启动Tomcat，但是如果你修改了配置文件，热部署就没有用了，还是需要重新启动Tomcat。除此之外，如果你的热部署有时还没有用，就有可能是缓存问题。
一、安装 1.eclipse——&gt;Help——&gt;Eclipse Marketplace——&gt;搜索JRebel
2.没安装的会显示【Install】,点击Install进行安装
(注：此是已安装的显示)
3.点击【Finish】Eclipse会进行安装，现在还不要关闭它
4.当它询问你是否要重启时，你直接点击【Restart Now】,你不小心关掉这个询问框也没有关系，关掉Eclipse重新打开就好了
（必须重新启动Eclipse）
5.再次打开Eclipse,此时你的JRebel就安装好咯
请多多指教！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c08f96cc936b6c607c507ece04dc9099/" rel="bookmark">
			雅可比(Jacobi)计算特征值和特征向量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		雅可比迭代法法 在图形图像中很多地方用到求矩阵的特征值和特征向量，比如主成分分析、OBB包围盒等。编程时一般都是用数值分析的方法来计算，这里介绍一下雅可比迭代法求解特征值和特征向量。雅可比迭代法的原理，网上资料很多，详细可见参考资料1。这里我们简单介绍求解矩阵S特征值和特征向量的步骤：
初始化特征向量为对角阵V，即主对角线的元素都是1.其他元素为0。在S的非主对角线元素中，找到绝对值最大元素 Sij。用下 式计算tan2θ，求 cosθ、sinθ 及旋转矩阵Gij 。
用下面公式求S‘；用当前特征向量矩阵V乘以矩阵Gij得到当前的特征向量V。
若当前迭代前的矩阵A的非主对角线元素中最大值小于给定的阈值e时，停止计算；否则, 令S =S‘, 重复执行(2) ~ (5)。 停止计算时，得到特征值 li≈(S‘) ij ，i,j= 1,2,…,n.以及特征向量V。这一步可选。根据特征值的大小从大到小的顺序重新排列矩阵的特征值和特征向量。 代码实现 用C++实现，并与参考资料1示例对比。
#include &lt;iostream&gt; #include &lt;map&gt; #include&lt;math.h&gt; #include &lt;iomanip&gt; using namespace std; /** * @brief Jacobi eigenvalue algorithm * @param matrix	n*n array * @param dim	dim represent n * @param eigenvectors	n*n array * @param eigenvalues	n*1 array * @param precision precision requirements * @param max	max number of iterations * @return */ bool Jacobi(double* matrix, int dim, double* eigenvectors, double* eigenvalues, double precision, int max) { for (int i = 0; i &lt; dim; i++) { eigenvectors[i*dim + i] = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c08f96cc936b6c607c507ece04dc9099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e9b07f3fbe27b9f115717814175c888/" rel="bookmark">
			最全的数据中心(IDC)机房整体工程介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机房建设不仅包含机房中所涉及的各个专业，如机房装修、供配电、空调、综合布线、安全监控、设备监控与消防系统等，还包括从数据中心到动力机房整体解决方案咨询、规划、设计、制造、安装和维护服务，因此不能孤立的看待机房的各个系统，而应看成一个更大的统一系统来进行设计和实施，以提高整体方案实施的可靠性、可用性、安全性和易管理性。
对于用户来说，采用整体机房解决方案，即降低了选型、采购、工程管理的整体成本，又有利于得到整体的设计、实施和服务，提高稳定性和兼容性，缩短建设周期等。
◆机房装修系统
机房装修工程不仅仅是一个装饰工程，更重要的是一个集电工学、电子学、建筑装饰学、美学、暖通净化专业、计算机专业、弱电控制专业、消防专业等多学科、多领域的综合工程，并涉及到计算机网络工程等专业技术的工程。在设计施工中应对供配电方式、空气净化、环境温度控制、安全防范措施以及防静电、防电磁辐射和抗干扰、防水、防雷、防火、防潮、防鼠诸多方面给予高度重视，以确保计算机系统长期正常运行工作。
机房天花工程
机房棚顶装修多采用吊顶方式。机房内吊顶主要作用是：在吊顶以上到顶棚的空间做为机房静压送风或回风风库、可布置通风管道；安装固定照明灯具、走线、各类风口、自动灭火探测器；防止灰尘下落等等。
综上所述，吊顶应具有一定的承载能力，必须能够承受住全部安装设备的重量。依使用方式而言，吊顶以上的空间要留有300mm~800mm的间隔，当吊顶上安装空调管道时，其间距要根据风管的结构来确定，并要留有人员安装及检修的空间。吊顶构件最好是可拆的，至少是在规定的地段是可拆的，以便于人员能够进入吊顶空间。如果用吊顶以上空间作为空气调节的静压风库时，吊顶以上空间及屋顶应采取防尘措施，防止灰尘通过吊顶落入机房内。所选用的吊顶板及其构件还应具有质轻、防火、防潮、吸音、不起尘、不吸尘等性能。
为了使吊顶板也能像活动地板那样，不论房间的形状和面积如何，都能较方便地装配，而且能满足防火、吸音和隔热等方面的要求，人们常采用铝制穿孔骨吊顶板。铝制穿孔骨吊顶板是一个轻质铝壳体，并有不同孔距和孔径的通孔，其中填充的材料具有消声、防火性能。
机房墙面工程
机房内墙装修的目的是保护墙体材料，保证室内使用条件，创造一个舒适、美观而整洁的环境。内墙的装饰效果是由质感、线条和色彩三个因素构成。目前，在机房墙面装饰中最常见的贴墙材料（如铝塑板、彩钢板）饰面等，其特点：表面平整、气密性好、易清洁、不起尘、不变形。墙体饰面基层做防潮、屏蔽、保温隔热处理。
土建墙体厚度要符合热负荷要求，使室内热负荷减少到最低限度。所采用的材料应该不易燃烧，而且隔热、隔音、吸音性好。
墙体表面涂附的材料种类很多，设计者可根据实际情况，参阅有关资料合理选择。要求不易产生尘埃、不产生静电、无毒的材料。
机房隔断工程
为了保证机房内不出现内柱，机房建筑常采用大跨度结构。争对计算机系统的不同设备对环境的不同要求，便于空调控制、灰尘控制、噪音控制和机房管理，往往采用隔断墙将大的机房空间分隔成较小的功能区域。隔断墙要既轻又薄，还能隔音、隔热。机房外门窗多采用防火防盗门窗，机房内门窗一般采用无框大玻璃门，这样既保证机房安全，又保证机房内有通透、明亮的效果。
隔音
机房基建结构需做隔音处理。隔音材料选择需符合环保要求，并使得房间内部形成吸音整体环境，从而才能确保达到建设目的。 保温在机房建设系统中，保温环境建设可以说是重中之重。保温系统的建设直接决定了机房系统的运营费用。建设优秀的保温环境，可有效的控制机房环境运营所产生的电费、维修费及管理费用。
机房地面工程
机房工程的技术施工中，机房地面工程是一个很重要的组成部分。机房地板一般采用抗静电活动地板。活动地板具有可拆卸的特点，因此，所有设备的导线电缆的连接、管道的连接及检修更换都很方便。活动地板下空间可作为静压送风风库，通过带气流分布风口的活动地板将机房空调送出的冷风送入室内及发热设备的机柜内，由于气流风口地板与一般活动地板可互换性，因此可自由的调节机房内气流的分布。活动地板下的地表面一般需进行防潮处理。若活动地板下空间作为机房空调送风风库，活动地板下地面还需做地台保温处理，保证在送冷风的过程中地表面不会因地面和冷风的温差而结露。
防静电地板敷设前期需要需要进行场地清理及找平工作，并按标准在地表面做多层多次处理方可进行下步施工。 ◆机房屏蔽系统
计算机机房固态电磁屏蔽工程一般有三种形式：即焊接式电磁屏蔽壳体、装配式电磁屏蔽壳体和薄膜屏蔽，还有多层屏蔽体。
·焊接式电磁屏蔽壳体是按设计将预加工的单元金属板块在机房内焊接成整体，形成电磁屏蔽壳体。
·装配式电磁屏蔽壳体是预先将屏蔽壳体制成组件，在机房内进行组装成整体，形成电磁屏蔽壳体。
·薄膜屏蔽是一种金属膜附着在一支撑金属膜结构上，而不是靠金属膜本身之支撑力，以金属薄腊抵挡电磁场的干扰。
·多层屏蔽是将屏蔽面作成多层，表面与金属之间留很小的空间，而不是紧密的接触在一起，在很小的空间中充满空气或其它电介质，多层屏蔽能起到很好的屏蔽效果。
计算机机房的电磁屏蔽应根据机房内设备工作的性能和安全的要求来选择。一般有以下三种方法：屏蔽机房、屏蔽工作间、设备专项屏蔽。屏蔽机房是为了保障国家和部门的政治、经济、军事上的安全，需要用屏蔽的手段来防止计算机泄密。屏蔽工作间是为了保密和防止减少电磁场的干扰，在局部范围内采取的屏蔽手段。设备专项屏蔽是为了保证电子仪器设备调试维修正确，需要在一个无电磁信号干扰的场合来进行，这种屏蔽专门为设备调试准备的屏蔽场所。◆机房防雷系统
众所周知，雷电具有极大的破坏性。雷电灾害所涉及的范围几乎遍布各行各业。尤以大规模集成电路为核心组件的测量、监控、保护、通信、计算机网络等先进电子设备广泛运用的电力、航空、国防、通信、广电、金融、交通、石化、医疗以及其它现代生活的各个领域，这些电子设备普遍存在着对暂态过电压、过电流耐受能力较弱的缺点，暂态过电压很可能造成电子设备的损害或产生误操作。 机房交流供电系统采用三相五线制供电方式。电力供电系统防雷设计的目标是确保机房设备和工作人员的安全，防止由于电力供电系统引入雷击。
机房的总电源取自大楼的总低压配电室。从交流供电线路进入总配电柜开始，到计算机机房设备电源入口端，电力供电系统自身应采取分级协调的防护措施，还应与信号系统的防雷、建筑物防雷、接地线路等协调配和。 防直击雷
现代防直击雷设施的主要构造是由接闪器（避雷针、避雷带、避雷线、避雷网、金属屋面等）、引下线（金属圆条、扁条、钢筋、金属柱等）和接地装置组成。
防感应雷
感应雷防护措施是限制、阻塞雷电脉冲沿电源线或数据、信号线进入设备，从而保护建筑物内各类电器设备的安全。内部防雷主要由浪涌保护器（SPD防雷器）、屏蔽系统、等电位连接系统、共用接地系统、合理布线系统等组成。安装防雷器是分流感应雷电流和限制浪涌过电压的有效措施，可分为电源防雷、信号防雷和天馈防雷。
屏蔽
屏蔽是防止任何形式电磁干扰的基本手段之一。就是用金属网、箔、壳或金属管等导体把需要保护的对象包围起来，使闪电的电磁脉冲波从空间入侵的通道全部截断。所有的屏蔽套、壳均要接地。屏蔽的目的，一是限制某一区域内部的电磁能量向外传播，二是防止或降低外界电磁辐射能量向被保护的空间传播。
等电位连接
等电位连接是将分开的装置、诸导电物体用等电位连接导体或电涌保护器连接起来，并最后与等电位连接母排相连，其目的在于消除防雷空间内各金属部件及各（信息）系统相互间的电位差。
接地系统
接地是分流和泻放直击雷和雷电电磁干扰能量最有效的手段之一，也是电位均衡补偿系统基础。目的是使雷电流通过低阻抗接地系统向大地泄放，从而保护建筑物、人员和设备的安全。将各部分防雷装置、建筑物金属构件、低压配电保护线（PE）、等电位连接带、设备保护地、交直流工作地、屏蔽地、防雷地、防静电地等连接在一起形成的共用接地系统。
备注：根据国家气象局有关规定，防雷工程的设计和施工必须由持有相关资质的专业公司实施；防雷工程竣工后须报相关部门进行验收，合格后才能交付使用。
◆机房配电系统
机房负荷均需按照机房现场供电负荷单独设计。计算机机房负载分为主设备负载和辅助设备负载。
主设备负载指计计算机主机、服务器、网络设备、通讯设备等，由于这些设备进行数据的实时处理与实时传递，所以对电源的质量与可靠性的要求最高。这部分供配电系统称为"设备供配电系统"，应采用UPS不间断电源供电来保证供电的稳定性和可靠性，并可配相应的蓄电池以便在突然停电时能支持一定时间的电源供应。
辅助设备负载指专用精密空调系统、动力设备、照明设备、测试设备等，其供配电系统称为"辅助供配电系统"，其供电由市电直接供电。 机房内的电气施工应选择优质阻燃聚氯乙烯绝缘电缆、敷设镀锌铁线槽和插座。配电线路安装过流、过载保护。插座应分为市电、UPS注明易区别的标志。机房往往采用机房专用配电柜来规范机房供配电系统，保证机房供配电系统的安全。 机房一般采用市电、发电机双回路供电，发电机作为主要的后备动力电源。
◆机房环境照明系统
◆空调与新风系统
机房精密空调系统的使用功能是为保证机房设备能够连续、稳定、可靠地运行，需要排出机房内设备及其它热源所散发的热量，维持机房恒温恒湿状态，并控制机房的空气含尘量。为此要求机房精密空调系统具有送风、回风、加热、加湿、冷却、减湿和空气净化的能力。机房精密空调系统是保证良好机房环境的最重要设备，应采用恒温恒湿精密空调系统。
机房新风换气系统主要有两个作用：其一给机房提供足够的新鲜空气，为工作人员创造良好的工作环境；其二维持机房对外的正压差，避免灰尘进入，保证机房有更好的洁净度。
机房内的气流组织形式应结合计算机系统要求和建筑条件综合考虑。新排风系统的风管及风口位置应配合空调系统和室内结构来合理布局。其风量根据空调送风量大小和机房操作人员数量而定，一半取值为每人新风量为：50m3/h,新风换气系统可采用吊定式安装或柜式机组，通过风管进行新风与污风的双向独立循环。新风换气系统中应加装防火阀并能与消防系统联动，一但发生火灾事故，便能自动切断新风进风。如果机房是无人值守机房则没必要设置新风换气系统。
◆机房不间断供电电源系统
计算机场地电力系统的高可用性是建立在电力系统从高压、低压、UPS到插座这样一个完整的供配电系统基础上的。电力系统中每一个环节都具有可扩展性和可管理性；低压配电自动切换系统以及UPS冗余系统等，对于这些系统我们不仅要精心设计，还要精心施工和系统化测试。
选择UPS品牌故然重要，UPS系统电力配套安装服务更为重要。为UPS配套的供配电系统，空气开关配置的参数性能稳定，保护完整，过载短路熄弧分断能力强，以及浪涌电压吸收装置的选择安装部位等都要进行系统化的精心设计。UPS及电池设备的安装环境，楼板承重问题，UPS发热量及环境热负荷对空调机制冷量的配置等一系列的服务是精密机房系统解决方案的核心。由于对UPS系统设施进行了全方位的保护，不仅可使UPS系统工作稳定，而且还使UPS系统负载故障范围大大缩小，从而提高了UPS供配电系统的高可靠性。
◆机房消防系统
（1）机房电气的消防安全，必须在设计时就要充分考虑，但是就目前机房建设而言，许多项目业主都以总包的形式包给专业的机房建设公司，合同中涵盖所有装修、主设备、软件以及消防设施，基本达到交钥匙工程，业主对消防的要求基本上是“消防部门验收过关，万事大吉！”，这种消防观念基本上是停留在被动消费层面，我国的消防管理力量与其它发达国家相比是非常薄弱的，消防部门不可能每个工程都监管的无懈可击。利润最大化驱使消防投入在总包合同中艰难前进，投资不足这只是其一；其二，机房主设备大多数是高精尖设备，但消防设施还停留在“通过验收就行！”的层面，使损失减少到最小可能是每个消防设计人员最想达到的设计境界，目前市场上的不少消防产品可以做到，但大家一提到此问题立刻出现一个问题：钱不够！；其三，机房建设公司在计算机和装修方面是很专业的，但对消防应用科学都很陌生，往往在估计投资时过于克扣，使得很多项目估价不足，机房建设公司应该与消防公司经常进行交流，并确定三到四家消防和作单位进行长期合作，这样一来可以降低造价而提高消防工程的性能。
（2）电气线路短路、过载、接触电阻过大等引发火灾事故。如：1995广东汕头金砂邮电大楼的特大火灾，就是因电线老化、绝缘性能降低而短路引起的；2001海南省电信公司微波大楼火灾是因为电源接线端头接触电阻过大引起的；
（3）静电产生火灾。通信设备的运行及工作人员所穿的衣服等都能产生静电。如果电信机房接地处理不当，产生的静电负荷不能很快导人大地而是越积越多，一旦形成高电位，就会发生静电导电现象，产生火花并引燃周围可燃物发生火灾；
（4）雷击等强电侵入导致火灾。雷电放电时所产生的电效应，能产生高达数万伏、甚至数十万伏的冲击电压，足以烧毁电力线路和设备，引发绝缘击穿，发生短路引发火灾。雷电放电时所产生的热效应、静电感应以及电磁感应都可能引发火灾；
（5）电信机房内电脑、空调等用电设备长时间通电、设备故障引发火灾。2000年5月北京电信公司大兴县青云店支局传输机房操作终端因长时间运行，致使显示器自燃引发火灾，造成传输机房瘫痪，2万部固定电话用户不能正常通信。由于电信机房的用电设备始终处于24小时的工作状态，容易疲劳和老化。
（6）使用可燃装修材料，尤其是空调隔热层和风管隔热材料容易被人们疏忽；
（7）管理不善，杂乱堆放易燃物品或保养維修时引入易燃易爆的清洗溶剂；
机房的消防监控，可以单独作为机房集中监控的一部分，也可以作为机房所在建筑物的一部分根据实际需求来处理。机房的消防措施要求机房的建筑装饰材料的选用必须是防火材料。机房的灭火方法按要求必须是惰性气体灭火，要根据实际情况来决定。
◆机房监控系统
机房环境及动力设备监控系统主要是对机房设备（如供配电系统、UPS电源、防雷器、空调、消防系统、保安门禁系统等）的运行状态、温度、湿度、洁净度、供电的电压、电流、频率、配电系统的开关状态、测漏系统等进行实时监控并记录历史数据，实现对机房遥测、遥信、遥控、遥调的管理功能，为机房高效的管理和安全运营提供有力的保证。
电源参数监控
监控机房内电源进线柜和出线柜电压、电流、频率状态。
UPS监控
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e9b07f3fbe27b9f115717814175c888/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c61597c29d1d5128159aeb6f7be12ef6/" rel="bookmark">
			C语言 递归算法及简单递归练习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		递归 ：大师 L. Peter Deutsch 说过：To Iterate is Human, to Recurse, Divine.中文译为：人理解迭代，神理解递归。
简单理解：
递归：你打开面前这扇门，看到屋里面还有一扇门。你走过去，发现手中的钥匙还可以打开它，你推开门，发现里面还有一扇门，你继续打开它。若干次之后，你打开面前的门后，发现只有一间屋子，没有门了。然后，你开始原路返回，每走回一间屋子，你数一次，走到入口的时候，你可以回答出你到底用这你把钥匙打开了几扇门。
循环：你打开面前这扇门，看到屋里面还有一扇门。你走过去，发现手中的钥匙还可以打开它，你推开门，发现里面还有一扇门（若前面两扇门都一样，那么这扇门和前两扇门也一样；如果第二扇门比第一扇门小，那么这扇门也比第二扇门小，你继续打开这扇门，一直这样继续下去直到打开所有的门。但是，入口处的人始终等不到你回去告诉他答案。
详细参考：添加链接描述
递归：函数调用自身的编程技巧
人理解迭代，神理解递归。毋庸置疑地，递归确实是一个奇妙的思维方式。
递归的两个必要条件
1、存在限制条件，当满足这个条件时，递归便不再继续。
2、每次递归调用之后越来越接近这个限制条件。
1.递归和非递归分别实现求第n个斐波那契数。
斐波纳契数列fibonacci,又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、……
在数学上，斐波纳契数列以如下被以递归的方法定义：
//F0=0，F1=1，Fn=F(n-1)+F(n-2)（n&gt;=2，n∈N*）。
递归实现斐波那契数C程序
#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int fibonacci(int n) { if(n &lt;= 2) { return 1; } else { return fibonacci(n - 1) + fibonacci(n - 2); } } int main() { int n; printf("请输入你想输出第几项的斐波那契数：\n"); scanf("%d", &amp;n); printf("%d\n", fibonacci(n)); system("pause"); return 0; } 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c61597c29d1d5128159aeb6f7be12ef6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d9a56e5785462f2aca76c680641eb7f/" rel="bookmark">
			使用action与reducer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这里主要研究通过action(借书人说的话)传递给store(管理员)，store再从reducer(记录本)查询数据，reducer将查询到的数据返回给store,最后store再返回给组件(借书用户)。最终要实现当reducers数据发生变化的时候，组件的数据也跟着变化
1.当组件的input框输入内容发生改变时，自动调用handleInputChange,通过store.dispatch（）将数据发送给store(管理员) handleInputChang (e){ const action = { type: 'chang_input_value', value: e.target.value } store.dispatch(action); } 2.store会自动将previousState与接收到的action传递给reducers(记录本) 3.reducers接收store传递过来的数据进行判断，如果为真将其新数据返回给store //reducer可以接收state的数据，但是不可以修改 export default (state = defaultState , action) =&gt; { if(action.type === 'chang_input_value') { const newState = JSON.parse(JSON.stringify(state)) //深拷贝 newState.inputValue = action.value; return newState; } return state; } 4.组件订阅store的改变，只要store改变，就触发该方法 //订阅store的改变，只要store改变，就触发该方法 store.subscribe(this.handleStoreChange) 将其写到custructor中
5.将最新的store数据获取到
handleStoreChange () { this.setState(store.getState()) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f0419ffe3e630527eb2911a7925f1ad/" rel="bookmark">
			jupyter notebook import tensorflow as tf 报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在anaconda5.2.0下 安装tensorflow完毕，在cmd下测试成功，但是在jupyter notebook中测试报错：大意是找不到指定的模块
python版本为3.6.5
解决方法：
1、安装ipython，安装jupyter
需要切入之前安装tensorflow时创建的tensorflow运行环境
打开anaconda prompt，进行安装ipython
(tensorflow)C:\Windows\system32&gt;conda install ipython
···
进行安装jupyter
(tensorflow)C:\Windows\system32&gt;conda install jupyter
...
2、执行这句关键代码：ipython kernelspec install-self --user
(tensorflow)C:\Windows\system32&gt;ipython kernelspec install-self --user
3、重新打开jupyter notebook ,再测试import tensorflow as tf成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ee0da748362a4c98ff8d5acb31c19a2/" rel="bookmark">
			后台开发之--行政区划功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、数据库模型设计，使用powerDesigner将数据库结构生成pdm文件，便可以直接使用其SQL语句生成数据库；
2、新建maven工程， 根据引入的catalog，会将java api 代码和web页面分成两个模块, 两个模块各自有resource目录，其中
web模块中有config目录，用来配置数据库以及spring框架等信息：
数据库配置：
jdbc.driver=com.mysql.jdbc.jdbc2.optional.MysqlXADataSource
jdbc.url=jdbc:mysql://XXXXXX?useUnicode=true&amp;characterEncoding=utf-8
jdbc.username=XXX
jdbc.password=XXX
jdbc.reconnect=true
在数据库的使用方面，如果不使用框架配置的话，也是可以自己用java代码连接的：
private static Connection getConn() {
Connection conn = null;
try {
Class.forName("com.mysql.jdbc.Driver"); //classLoader,加载对应驱动 } catch (ClassNotFoundException e) {
e.printStackTrace();
}
String url = "jdbc:mysql://localhost:3306/test";
String username = "root";//数据库账户，一般为root
String password = "****";//数据库密码
try{
conn = DriverManager.getConnection(url, username, password);
} catch (SQLException e) {
e.printStackTrace();
}
return conn;
}
其他关于框架的配置信息在spring-mvc.xml 中， web模块负责后面放在tomcat容器中运行。
此处注意如果在运行后访问之后要有页面显示的话，记得在webapp 下的 WEB-INF 目录下添加index.html，访问路径记得使用IP+端口，然后就是项目路径：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ee0da748362a4c98ff8d5acb31c19a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0b586ca27e59685c38ec379c557e675/" rel="bookmark">
			input标签multiple属性用法简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天一个朋友问我，是否可以一次上传多个文件，想了下，之前做过呀，使用多个input空间，type设置为file呀
如果使用一个input控件呢，是否可以，咨询了下前端同事，发现确实可以，使用multiple属性。
多文件上传 基于之前的多文件上传看，页面改造非常简单，将之前的多个input控件，删除的只剩一个，在input控件内增加multiple属性即可。
&lt;div class="input-group col-md-4"&gt; &lt;span class="input-group-addon"&gt;&lt;i class="glyphicon glyphicon-search"&gt;&lt;/i&gt;&lt;/span&gt; &lt;input class="form-control" placeholder="请选择文件" type="file" name="files" multiple="multiple" /&gt; &lt;/div&gt; 看效果，页面上似乎没有太大区别
点击选择文件后，在选中一个文件后，可以按住Ctrl 键再选择其他的文件，个数的上限暂时没有特意测试
选择好后，点击打开，可以看到，页面上会显示本次选中了几个文件
然后点击文件上传，便与之前的操作相同了，这里不再赘述。
这里的多文件上传，与多个input控件上传方式类似，不同的是，多个input控件单次上传的附件数据取决于input控件的个数，而使用multiple属性，则不限制单次上传文件个数。对于文件类型，多控件方式和multiple方式相同，单次均可以上传不同类型的文件。
select多选 form表单中，有个select标签，是个下拉单选效果，是否可以做出下拉复选效果呢，可以，使用multiple属性。
&lt;select name="car" id="car" multiple="multiple"&gt; &lt;option value ="volvo"&gt;Volvo&lt;/option&gt; &lt;option value ="saab"&gt;Saab&lt;/option&gt; &lt;option value="opel"&gt;Opel&lt;/option&gt; &lt;option value="audi"&gt;Audi&lt;/option&gt; &lt;option value="iveco"&gt;IVECO&lt;/option&gt; &lt;option value="benz"&gt;Benz&lt;/option&gt; &lt;/select&gt; 查看下页面效果
选择时，先选中一个元素，按住Ctrl键，便可以选择其他元素
提交到后台后，后台需要使用request.getParameterValues("car") 方法来获取前台选中值
运行程序后，可以从后台看到后台获取到前端传值 [opel, iveco]
这里给select增加multiple属性同CheckBox效果类似，后台的获取数据方式相同，唯一区别就是页面展现样式。
以上，今天学习到的一个知识点，记录下来，如果有不严谨地方，欢迎批评指正。谢谢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/084fe7949786bf021bf3ec5be9a4c317/" rel="bookmark">
			Zabbix监控平台（二）深入理解zabbix
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，Zabbix Web操作深入 1.1 Zabbix Web下的主机和模版以及监控项的添加方式 （1）创建一个模版 我们所有的功能几乎都是在模版中定义的
我们再点进新创建的模版查看
模版里几乎可以设定我们需要的所有功能
（2）在模版里创建应用集 应用集的作用就是将众多的监控项进行一个分类，方便我们的管理
（3）在模版里创建一个zabbix自带的监控项 cpu模板监控项
mem模板监控项
disk模板监控项（随便找了一个键值）
（4）监控项里的键值我们到底要如何写？我们需要学会照葫芦画瓢 我们选择一个系统模版Template OS Linux查看
5）当然我们也可以自定义监控项的键值，但是并不推荐这样。因为，都是自己写太慢了。系统自带了很多键值我们要学会利用 自定义系统监控项的键值创建，请参考前一节的知识
6）把新添加的模板链接到主机里面并检测 1.2 Zabbix Web下触发器与表达式的编写方法 （1）avg 参数：秒或#num 支持类型：float,int 作用：返回一段时间的平均值
举例： avg(5)：最后5秒的平均值 avg(#5)：表示最近5次得到值的平均值 avg（3600,86400）：表示一天前的一个小时的平均值 如果仅有一个参数，表示指定时间的平均值，从现在开始算起，如果有第二个参数，表示漂移，从第二个参数前开始算时间，#n表示最近n次的值
（2）last 参数：秒或#num 支持值类型：float，int，str，text，log 作用：最近的值，如果为秒，则忽略，#num表示最近第N个值，请注意当前的#num和其他一些函数的#num的意思是不同的。
last(0)等价于last（#1） last（#3）表示最近第3个值（并不是最近的三个值） 本函数也支持第二个参数time_shift,例如last（0,86400）返回一天前的最近的值。 如果在history中同一秒中有多个值存在看，Zabbix不保证值的精确顺序#num从Zabbix1.6.2起开始支持，timeshift从1.8.2起开始支持，可以查询avg（）函数获取它的使用方法
（3）max 参数：秒或#num 支持值类型：float，int 描述：返回指定时间间隔的最大值。时间间隔作为第一个参数可以是秒或收集值的数目（前缀为#）。从Zabbix1.8.2开始，函数支持第二个可选参数time_shift,可以查看avg（）函数获取它的使用方法。 例如：max(#3)=0 返回3次值如果都是0则触发告警
（4）min 参数：秒或#num 支持值类型：float，int 描述：返回指定时间间隔的最小值。时间间隔作为第一个参数可以是秒或收集值的数目（前缀为#）。从Zabbix1.8.2开始，函数支持第二个可选参数time_shift，可以查看avg（）函数获取它的使用方法。
（5）nodata 参数：秒 支持值类型：any 描述：当返回值为1表示指定的间隔（间隔不应小于30秒）没有接收到数据，0表示获取到了。 例：nodata(5m)=1 ===&gt;5分钟之内获取不到数据就告警
（6）prev 参数：忽略 支持值类型：float，int，str，text，log 描述：返回之前的值，类似于last（#2）
（7）sum 参数：秒或#num 支持值类型：float，int 描述：返回指定时间间隔中收集到的值的总和，时间间隔作为第一个参数支持秒或收集值的数目（以#开始）.从Zabbix1.8.2开始，本函数支持time_shift作为第二个参数。可以查看avg函数获取它的用法。
（8）change 参数：忽略 支持类型：float,int,str,text,log 作用：返回最近获得值与之前获得值的差值，对于字符串0表示相等，1表示不同 change（0）&gt;n:忽略参数一般输入0，表示最近得到的值与上一个值的差值大于n
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/084fe7949786bf021bf3ec5be9a4c317/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/666c2a0712285a04a0cd9d236b277938/" rel="bookmark">
			在Idea里面用SSM注解写一个项目遇到的种种坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先分享一下搭建项目环境的网址：https://www.cnblogs.com/hackyo/p/6646051.html
写代码的时候没有将前台页面一块写了，只是在一个叫做Restlet Client的工具里面输入网址进行调试
1.在网址部署环境进行测试的时候，报一个404的错误
tomcat报错404请注意。我用ieda创建玩项目，webapp下面是index.jsp。但是大神是index.html。在WEB-INF/web.xml里面，把index.html改成index.jsp就可以了。
&lt;welcome-file-list&gt; &lt;welcome-file&gt;indexhtml&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 改成
&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 2.写第一个查询所有信息的功能，查询所有信息的时候，会遇到没有返回值的情况，明明代码逻辑和SQL语句都没有问题啊，仔细一看自己在类上面的注解是@Controller，实际上写@Controller的时候必须有前台页面，它返回到前台页面里面了，在类上面，将@Controller改成@RestController就好了，或者在每一个方法前面加上一个@ResponseBody就好了。
3.写一个根据key查询信息的功能，发现在了一个常用注解@RequestParam
4.在写插入功能的时候必须每一条属性都有值，但是SQL语句进行了判断是否为空
这时候我发现创建表的时候的一系列问题，创建表的时候没有进行允许空值的勾选所以要想生效，就必须勾选上允许控制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8074a2ecd533ecaadf98e94824aa13a7/" rel="bookmark">
			报错：Bootstrap&#39;s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错：Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3. 一般认为新的发现 一般认为 从字面上理解，可能是因为jQuery的版本太低了，然后需要更高的版本才行，而且，确实有大部分是这样的情况。但是，有时候当你更换了更高版本的jQuery库，你会发现仍然会报错。。。
新的发现 在Stack Overflow上面搜索了一下，发现是Bootstrap v3.3.6与jQuery 3.0不兼容。这将在即将推出的Bootstrap版本3.3.7中修复。在GitHub上面还有相关的issue，https://github.com/twbs/bootstrap/issues/16834
参考资料：https://stackoverflow.com/questions/29170799/bootstraps-javascript-requires-jquery-version-1-9-1-or-higher
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/351109611ee85cbec3f0fe66a183a3ac/" rel="bookmark">
			Python 中 if not 的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		if not 判断是否为NONE
代码中经常会有判断变量是否为NONE的情况,主要有三种写法:
第一种: if x is None(最清晰)
第二种: if not x
第三种: if not x is None
&gt;&gt;&gt; x = 1 &gt;&gt;&gt; not x False &gt;&gt;&gt; x = [1] &gt;&gt;&gt; not x False &gt;&gt;&gt; x = 0 &gt;&gt;&gt; not x True &gt;&gt;&gt; x = [0] # You don't want to fall in this one. &gt;&gt;&gt; not x False 使用if not x这种写法的前提是：必须清楚x等于None, False, 空字符串"", 0, 空列表[], 空字典{}, 空元组()时对你的判断没有影响才行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/351109611ee85cbec3f0fe66a183a3ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b03d57a49b020b4f11a5dc05164bc8a/" rel="bookmark">
			文献阅读笔记5：Cascaded Pyramid Network for Multi Person Pose Estimation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章来源：CVPR2018,COCO 2017的冠军模型文章。
主要贡献：提出了基于Cascaded Pyramid Network的多人关键点检测框架。
网络结构：
整个网络分为GlobalNet和RefineNet两个stages，采用的是top-down的策略，即先找出所有人的bounding box,再对bounding box 中的人进行关键点检测：
Global Net:
这个部分的功能是学习一个良好的特征表示，并检测出容易检测的关键点。主要是基于ResNet的架构，并在其中嵌入了U型结构，以此来保证输出为后面的层的特征中既能包含丰富的空间位置信息，又能包含足够的语义信息。在进行element-wise操作时，都进行了1×1卷积操作。Global Net最终会输出一张关键点的heat map,如图所示:
GlobalNet可以有效地定位像眼睛一样的关键点，但可能无法精确定位臀部的位置。
Refine Net:
这个部分则主要解决GlobalNet无法检测到的key points。
各个level的特征会进行相互传输，并在最后通过上采样和拼接的方法进行融合。在更深的层中堆叠了更多的bottleneck，在有效性和效率之间实现了很好的权衡
由于随着训练的进行，网络会比较关注容易检测的关键点，因此，作者通过修改训练的损失函数来选择难以检测的点，即Refine Net只对这些难检测点进行损失函数的回归。
其他改进：
soft NMS：
soft NMS会将重叠较大的框中分数较小的那个框的分数拉到很低，但仍旧保留这个框，这样召回率相对较高。hard NMS就是传统的NMS，直接将IOU大于一定阈值的框中得分较低的框直接去掉，相对召回率较低。作者将soft NMS用到了CPN网络的Person Detector中，提高了0.3的人体检测AP。
ROIAlign:
作者将目标检测算法FPN中的ROI Pooling层改成了ROIAlign，这样可以减少ROI Pooling两次量化中浮点数取整造成的rigion proposal偏差
模型性能
作者在 MS COCO test-dev ， testchallenge dataset分别将CPN网络与其它方法进行了比较：
在没有额外训练数据的情况下，一个CPN模型AP达到了72.1，使用不同ground truth heat map的CPN集成模型实现了73.0的AP。在test-challenge2017 dataset年数据集上实现了最先进的性能:72.1AP.表11显示了CPN和CPN(集成模型)在CocoMinival数据集上的性能，为COCO Minval数据集与CoCO数据集的标准Testdev或test-Change数据集之间的差别提供了参考。
遗留问题
1.哪里用到了hourglass？
2.bottleneck在Refine Net中如何发挥作用？
3.U型结构怎么发挥融合低层位置信息和高层语义信息的效果？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99d4a3d3cebcdb9e786b93670a3bd077/" rel="bookmark">
			[20181212]bash shell 字符串 补零.txt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[20181212]bash shell 字符串 补零.txt --//上午写bash shell脚本,遇到一个问题,字符串前面补零的问题. $ echo $BASH_VERSION 3.2.25(1)-release $ a='12345' $ printf "%08s\n" $a 12345 $ printf "%8s\n" $a 12345 --//对于字符串%8s,%08s都是一样的,都是前面补充空格. --//数值可以使用类似的方法补零. $ a='12345' $ printf "%08d\n" $a 00012345 --//奇怪的是我在windows下安装git,里面自带bash就是ok的. $ a='12345' $ printf "%08s\n" $a 00012345 --//实际上在linux下printf有2个命令.一个是shell内建的,一个是外部命令. $ type -a printf printf is a shell builtin printf is /usr/bin/printf --//看了文档感觉没用. --//正好我的字符串原来是16进制值. $ a=0x12345 $ printf "%08x\n" $a 00012345 --//真要实现字符串前面补零,还是比较麻烦. $ a=1a2b3c $ printf "%08x\n" "0x"$a 001a2b3c $ a=$(printf "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99d4a3d3cebcdb9e786b93670a3bd077/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec71f1f3965fe6992c52fdf44d5dc355/" rel="bookmark">
			笔记：线性模型：线性回归简介和线性回归中的损失函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性回归简介 - 回归任务
- 线性回归模型
- 回归模型中的预测残差
1回归任务的定义
训练：特点：y是连续值 属于R
学习/目标：
预测：
2回归任务举例 （预测的都是数值型）
根据全球经济形势和石油
产量预测石油价格
根据广告投入预测产品销量
根据房屋属性预测房屋价格
根据降雨量预测水果收成
根据雇员的工作年限和其他
属性预测其薪水
根据学生学习时长预测其成绩
3线性回归
线性回归就是假设输出y和输入x之间存在线性关系 即为样本x的每一个特征与对应权重相乘就和就是y的值
W0 代表线性模型中的截距项 在矩阵乘法中其对应的权重是1。
4预测残差
残差就是预测值和真实值之间的差值。
在线性回归图像中可以理解为数据到拟合直线之间的距离。
残差平方 残差计算之后有正负号 可以看残差的平方 而忽略掉正负号的影响
残差平方和： 在训练集上 所有的残差的平方的总和
线性回归中的损失函数 - 掌握回归模型中的损失函数：L2损失、L1损失
和Huber 损失
- 理解上述损失的适用场景
1最佳模型
2 L2损失：残差平方 L2损失对噪声敏感 噪声：就是直线预测不准的一个数据点 可以理解为在图上 距离直线比较远的一个点
L2损失是根据 残差来计算的 由于本身拟合直线和噪声之间的残差比较大 而L2损失是在此基础上再平方考虑的
所以L2损失会更更大。
这样影响的结果就是 我们使用的拟合直线会更加“看重”噪声点 使拟合直线整体偏向噪声点的方向
L2损失的优点 ：L2损失是根据残差平方计算的是二次项的函数 二次项的函数处处可导 方便优化计算 3 L1损失：残差绝对值
直观的在图像上面看就是点到线的距离大小（没有正负）。
优点L1损失是根据残差的绝对值计算的 是根据残差本身数值上的大小即不考虑正负号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec71f1f3965fe6992c52fdf44d5dc355/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e66881f57380045ea7846b2bd13efe4/" rel="bookmark">
			QQ浏览器劫持html5的视频video标签的问题（怎么解决？）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 无解，暂无解决办法，哪位朋友知道告之一下，感激
QQ浏览器真的不讲一点规则，强制劫持视频video标签，这已经很 XX 了吧？还在视频结束时加载他们自己的广告，这... 就无语了。
相信开发html5视频播放器的朋友，都会遇到这个问题。
参见： 腾讯的移动浏览器劫持 &lt;Video&gt; 换成它自己的播放器还插广告： https://www.v2ex.com/t/411564
video标签在微信内置浏览器和QQ浏览器（手机端）的怪异现象？https://www.zhihu.com/question/27472010
我的原创文章整理： 视频中常用的HLS(m3u8)协议分析新版谷歌Chrome允许flash的选项已不再保存和添加了（如何解决？）视频播放常见问题让IIS支持mp4、flv等mime类型的设置HTML5倍数功能视频播放器（加速2倍，1.5倍播放）HTML5之Video对象属性和方法（html5播放器设计必须研究的） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00ddde820cc3491509f1c3f1605933d8/" rel="bookmark">
			关于nginx限速的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		limit_req zone=req_one burst=20; zone定义了一个req_one的name，burst表示允许超过限制的请求数不多于20个，后面可加参数（nodelay）：超过的请求不会被延迟处理,直接返回503 limit_rate 150k; 限速指令，150k limit_conn one 10; 同一时间只允许有10个连接，one只是定义了一个名字 转载于:https://www.cnblogs.com/yeyu1314/p/10107173.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df6f8f6cf3ee5d0b6172ed6c3964b2c1/" rel="bookmark">
			VirtualBox在Windows 10 高分屏下显示的修正以及显示字体的修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给自己的笔记本外接了大屏显示屏以后，就会时不时在笔记本和屏幕之间拖动，VirtualBox没有适配高分屏，加上给屏幕设置了不同的缩放比（笔记本100%和大屏150%）。VirtualBox就显得格外的丑。上网搜了下解决办法，然后解决了。
记录如下：
高分屏的修正 在参考链接中找到了解决方案。
Manifest file must be copied into application folder of VirtualBox (e.g. C:\Program Files\Oracle\VirtualBox).
For completeness, here the important bits from other article (Adobe App Scaling on High DPI Displays):
Press Windows Button + R, type “regedit”, and then click OK.
Navigate to the following registry subkey:
HKEY_LOCAL_MACHINE &gt; SOFTWARE &gt; Microsoft &gt; Windows &gt; CurrentVersion &gt; SideBySideRight-click, select NEW &gt; DWORD (32 bit) Value
Type PreferExternalManifest, and then press ENTER.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df6f8f6cf3ee5d0b6172ed6c3964b2c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/103154315f5f5944722afa2f6b58108f/" rel="bookmark">
			Java 数组转list
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 List&lt;String&gt; tbList = Arrays.asList(result.getTb_name().split(",")); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/984e5d6d80e239ad2ef3077837937a6a/" rel="bookmark">
			LayaBox入门基础之JS代码实现按钮删除功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.2.3 实现List增加功能删除功能
​ 实现List删除功能需要实现多选框checkbox功能、删除按钮的鼠标侦听，删除操作后的数据重新渲染。详情直接查看代码与注释：
(function() { //------&gt;用于显示UI组件 var Stage= Laya.Stage; //定义变量Stage为Laya的封装好的Stage var Handler= Laya.Handler; var Loader= Laya.Loader; var Event = Laya.Event; //点击鼠标的时候事件监听需要引用这个包 var WebGL= Laya.WebGL; var CheckBox = Laya.CheckBox; //实现多选框checkbox功能需要导入Laya提供的包 var ListDemoView; //定义整个界面的UI为一个变量 var arr; (function() { Laya.init(640,1136,WebGL); //Laya引擎的初始化 Laya.stage.bgColor = "#ffffff"; //设置为缩放模式 Laya.stage.scaleMode = Stage.SCALE_SHOWALL; //预加载资源文件（图集路径根据自己的项目实际情况定）后执行回调 Laya.loader.load(["res/atlas/comp.atlas","res/atlas/template/ButtonTab.atlas"],Handler.create(this,onLoaded)); })(); //要执行的回调函数 function onLoaded(){ ListDemoView = new ListPageUI(); //这个ListPageUI类是在layaUI.max.all.js中发布UI的时候自动生成的 Laya.stage.addChild(ListDemoView); //这舞台中添加这个ListPage的UI组件 //获取List模拟数据，并渲染 getListData(); //侦听增加按钮点击事件 ListDemoView.add.on(Event.CLICK,this,onAddClick); //on()方法：四个入参，一个返回值；入参：type：事件的类型，caller：事件侦听函数的执行域，listener：事件侦听函数，args：事件侦听函数的回调参数 //返回值：EventDispatcher :此EventDispatcher对象 //侦听删除按钮点击事件 ListDemoView.del.on(Event.CLICK,this,onRemoveClick); } //&lt;------用于显示UI组件 //-------&gt;编写代码逻辑，实现List序号逻辑 //要实现List序号的数据添加，需要用到"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/984e5d6d80e239ad2ef3077837937a6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c7ab83971665945c5e8976387a7e208/" rel="bookmark">
			LayaBox入门基础之JS代码实现按钮增加功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.2.3 实现List增加功能
​ 实现List增加，需要用到LayaAir引擎laya.display.Sprite中的事件侦听on()方法对鼠标点击事件CLICK进行侦听，以及laya.ui.List API中添加单元格数据源的方法addItem()；
​ ​ （图25）
​ ​ （图26）
(function() { var Handler= Laya.Handler; var Loader= Laya.Loader; var WebGL = Laya.WebGL; var Event = Laya.Event; var Stage = Laya.Stage; var ListDemoView; var arr; (function() { Laya.init(640,1136,WebGL); Laya.stage.bgColor = "#ffffff"; Laya.stage.scaleMode = Stage.SCALE_SHOWALL; //预加载资源文件后执行回调 Laya.loader.load(["res/atlas/ListPage.atlas","res/atlas/template/ButtonTab.atlas"], Handler.create(this, onLoaded)); })(); function onLoaded(){ ListDemoView = new ListPageUI(); Laya.stage.addChild(ListDemoView); //获得List模拟数据，并渲染 getListData(); //侦听增加按钮点击事件 ListDemoView.add.on(Event.CLICK,this,onAddClick); } function getListData(){ //添加list数据 arr = []; for (var i = 1; i &lt;= 30; i++) { arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c7ab83971665945c5e8976387a7e208/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/419/">«</a>
	<span class="pagination__item pagination__item--current">420/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/421/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>