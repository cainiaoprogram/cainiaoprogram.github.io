<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed7306bf22077142d34314f2e9d429d3/" rel="bookmark">
			java反射异常报错解决：java.lang.NoSuchFieldException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我这里是学习测试开发时报错，关联：运行代码中调用另一个代码文件的私有属性并且这个私有属性还需与本地excel文件中的title一致！
报错信息如下图：
69行代码：
103行代码：
Caseinfo私有属性代码：
excel下标0行的列头：
总结：最终通过反复查看java.lang.NoSuchFieldException源代码的注解信息得到以下：
1.程序未找到相应的Field（解析比如：excel列名和CaseInfo属性，大小写都需对应上）；
2.有该Field，但是该Field是使用private修饰的，而在获取该Field的时候，需要使用getDeclaredField这个方法。
3.死死往这两个方面去找原因吧。
问题解决：我main方法输出的caseInfo.getId() 和caseInfo.getIsDbCheck()与excel中列头不一致导致报错没有找到FieId。详情见总结-序号1；
最后祝愿大家在IT行业一路长虹。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1db617978c20f8c900b0df3d9a84011/" rel="bookmark">
			YOLO（二）：YOLOv4在Windows7（GTX960）下的配置&#43;opencv3.1.0&#43;VS2015
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提醒：本文为64位Windows7操作系统下GTX960的配置，YOLOv4的数据训练问题还是先挖个坑，后期再更新。
主要参考：windows7+VS2017+GPU+OpenCV3.4 编译YOLO_v4
自己上一篇的YOLOv3在windows7仅CPU模式下配置好之后，刚发出去没多久，其实YOLOv4就出来了，性能相比v3提升了不少，前段时间也趁着有空，试了一下，这里友情提醒一下，v4最好使用显卡，自己的显卡正好是刚从叔叔家网咖淘汰下来的GTX960，所以也就凑合着用吧。
前面说过对于初学者，YOLO上手是非常友好的，所以v4出来之后，好多配置教程都出来了，不过大多数都是Ubuntu系统的，自己暂时还没换笔记本，所以就查询了好多windows版本的配置，这里大部分又都是基于cmake的，自己在cmake上试了好几次都失败了，原因暂时没找到，后面找到上面那位同学的方法，也出现了一点问题，不过很快就解决了，后面图片和视频测试都成功了。好啦！废话不多说，开始正题！
（一）环境及配置:
1、VS2015；（没试过VS2013、vs2017，有兴趣的同学可以试一下（不保熟））
2、opencv3.1.0；（参考的那位是用的3.4.0，我用的是3.1.0（链接：https://pan.baidu.com/s/19IM-uyyC9lB6f1oDvebFUg ，提取码：sgh9 ），应该是3.0版本以上都可以，opencv官网上面也都有，安装时记得环境变量的配置）
3、CUDA10.1（+cudnn）其他版本亦可，取决于你显卡的配置，我的是GTX960
4、YOLOv4（darknet源码）；
AlexeyAB/darknet中下载好zip文件解压，我放在E:\yolov4下
5、yolo4.weights；（链接：https://pan.baidu.com/s/1IuYsvLW5RPRTv_jPd1ZRZQ 提取码：sx3s ）
（二）配置环境及darknet编译:
1、在yolov4下面创建YOLOV4_build文件夹，打开并创建VS2015工程，选择NVIDIA
我的工程名为yolov4
2、将下载解压后的源码中的以下几个文件夹拷贝到新建工程下：3rdparty、cfg、data、include、src。model为自己新建的，存放权重文件yolo-v4.weights
3、在工程下建立三个文件夹c、h、cu（右键点击工程，新建筛选器，依次命名为上述3个文件夹），从src中分别添加c文件、h文件、cu文件到各自文件夹（.cpp和.c文件均存放在c文件夹下）
4、配置属性
点击“项目”打开“属性”，|选择x64-Release
包含目录中添加：
E:\yolov4\YOLOV4_build\yolov4\3rdparty\pthreads\include;
E:\yolov4\YOLOV4_build\yolov4\3rdparty\stb\include
E:\yolov4\YOLOV4_build\yolov4\include
D:\Program Files\opencv310\opencv\build\include
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.1\include
库目录中添加：
E:\yolov4\YOLOV4_build\yolov4\3rdparty\pthreads\lib
D:\Program Files\opencv310\opencv\build\x64\vc14\lib
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.1\lib\x64
C/C++ 预处理定义中添加：
WIN32;WIN64;NDEBUG;_CONSOLE;_LIB;OPENCV;CUDNN_HALF;CUDNN;_TIMESPEC_DEFINED;_SCL_SECURE_NO_WARNINGS;_CRT_SECURE_NO_WARNINGS;_CRT_RAND_S;GPU
CUDA device中修改算力：根据显卡配置
compute_30,sm_30;compute_52,sm_52（我的是GTX960，如果是其他显卡，自己修改，参考文中是Titan Xp，所以他的配置是compute_30,sm_30;compute_75,sm_75）
在链接器中添加上相应的lib文件（参考文中未说明，所以自己当时一头雾水，直接编译就失败了）
cudart_static.lib
cublas.lib
pthreadVC2.lib
curand.lib
保存以上配置之后，编译生成解决方案，成功！
（三）测试:
1、把yolo4.weights，E:\yolov4\darknet-master中cfg、data文件夹复制到E:\yolov4\YOLOV4_build\yolov4\x64\Release中
2、将E:\yolov4\darknet-master\build\darknet\x64中darknet_yolo_v3.cmd，darknet_yolo_v3_video.cmd也复制到E:\yolov4\YOLOV4_build\yolov4\x64\Release中，分别重命名为darknet_yolo_v4.cmd，darknet_yolo_v4_video.cmd
3、修改darknet_yolo_v4.cmd如下：
yolov4.exe detector test cfg/coco.data cfg/yolov4.cfg yolov4.weights -ext_output data/dog.jpg pause 修改darknet_yolo_v4_video.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1db617978c20f8c900b0df3d9a84011/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4944b73455fdb37f1c900c54e682098a/" rel="bookmark">
			Mac OS安装IDEA和JDK（超级详细教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先安装IDEA（使用教育账号） 在官网进行下载：
Idea官网地址直接下载
我下载的是apple silicon的，这个取决于电脑，如果Intel的就下载上面的镜像
下载好了以后，直接点击下载好的那个包，就完成了。
二、下载安装JDK 到Oracle官网直接下载安装包：
官网网址：
SE：Standard edition，标准版
EE：Enterprise edition，企业版
ME：Micro edition，是为机顶盒、移动电话和PDA之类嵌入式消费电子设备提供的Java语言平台
同意协议后即可下载
打开下载好的文件，点击运行
一直点继续就行
下一步进行环境配置：
首先打开终端：
1.查看安装路径： /Library/Java/JavaVirtualMachines/jdk1.8.0_341.jdk/Contents/Home 2.修改配置文件 sudo vim ~/.bash_profile #如果没有这个文件使用torch进行创建 #在文件中添加下面的内容，注意JAVA_HOME为刚刚查到的JDK安装路径，根据自己的进行修改！ export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_341.jdk/Contents/Home export PATH=$JAVA_HOME/bin:$PATH:. export CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:. 3.使配置文件生效 source ~/.bash_profile 4.查看JDK是否安装成功 java -version 5.查看相关命令 javac 至此IDEA和JDK安装成功！
参考文章：
MAC 系统安装 JDK 及环境变量配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8f7cdbaf9355623680b4013b15a2d86/" rel="bookmark">
			【sdp】notepad&#43;&#43; \r\n替换成回车换行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大神的原文：notepad++ \r\n替换成回车换行sdp 很长的字符串，包含很多"\r\n"，将"\r\n"替换成换行后将方便查看。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/982cb817e336c6d09583aa0a9d550361/" rel="bookmark">
			CSS基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CSS基本选择器 基本选择器又可以分为一下几类:
通配符选择器标签选择器类选择器id选择器属性选择器 1. 通配符选择器 使用*表示通配符选择器，用来表示所有的标签。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; * { color:blue; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span&gt;我是内容&lt;/span&gt; &lt;p&gt;我是一个p&lt;/p&gt; &lt;div&gt;我是一个div&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2. 标签选择器 可以使用标签名来控制页面上的标签。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; p { color:red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span&gt;我是span里的内容&lt;/span&gt; &lt;p&gt;我是一个p&lt;/p&gt; &lt;p&gt;我也是一个p&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 3. 类选择器 使用类选择前，需要先给符合一定规律的标签按照特点进行分类，给这些标签添加class属性，再通过class属性来找到对应的元素。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; /* 使用 .类名 的形式找到对应类的标签，对同一类的标签设置同样的样式 */ .chinese { color:red; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/982cb817e336c6d09583aa0a9d550361/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c7945d96d78d7d2f767d966122d0116/" rel="bookmark">
			RFID读写器的工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RFID读写器是数据采集关键性部件，数据采集的质量一般用读取率来衡量，较高的识别读取率是RFID系统最基本的要求，提高识读率也成为RFID系统不断优化的追求。
RFID读写器是一种通过无线通信，实现对标签识别和内存数据的读出或写入操作的装置。读写器又称为阅读器或读头(工业读写器)、读出装置等。
RFID读写器的基本原理是利用射频信号与空间耦合传输特性，使电子标签与阅读器的耦合元件在射频耦合通道内进行能量传递、数据交换，实现对标识对象的自动识别。
发生在读写器和电子标签之间的射频信号耦合有两种类型。
1.电感耦合 ：变压器原理模型。依据电磁感应定律，射频信号通过空间高频交变磁场实现耦合。电感耦合方式一般发生在中、低频工作的近距离射频识别系统中。典型的工作频率有125kHz、225kHz和13.56MHz。识读距离一般小于1m，典型识读距离为10~20cm，也称为近场耦合。
2.电磁反向散射耦合：雷达原理模型。依据电磁波的空间传播定律，电磁波碰到目标后反射，同时携带回目标信息。电磁反向散射耦合方式一般发生在高频、微波工作的远距离射频识别系统。典型的工作频率有433MHz、915MHz、2.45GHz、5.8GHz。识别作用距离大于1m，典型作用距离为3~10m，也称为远场耦合。
典型的读写器包含有射频模块(发送器和接收器)、读写控制模块以及读写器天线。
射频模块的主要功能是产生高频发射能量;对发射信号进行调制，并传输给标签；接收并解调来自标签的射频信号。
读写控制模块也称为控制系统，主要具有以下功能
1.与应用系统软件进行通信，并执行从应用系统软件发来的动作指令;
2.控制与标签的通信过程;
3.信号的编码与解码;
4.执行防碰撞算法（RFID的防碰撞技术能实现什么功能）;
5.对读写器和标签之间传送的数据进行加密和解密;
6.进行读写器和标签之间的身份验证。
读写器根据使用的结构和技术不同，可以分为只读和读/写装置，RFID读写器通常包含基础的中间件软件，是RFID系统信息控制和处理中心。读写器通过电感或电磁耦合给电子标签提供能量和时序，一般采用半双工通信方式进行数据交换。在实际应用中，可以通过以太网或WLAN等实现对物体识别的数据采集、处理及远程传送等管理功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/371f50b07653fc0e1a90cc56a9b3f884/" rel="bookmark">
			【无人机】基于混合粒子群算法求解无人机航迹规划问题附Matlab代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，matlab项目合作可私信。
🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
⛄ 内容介绍 文章首先将无人机航迹问题转换 为多目标的TSP问题数学模型,建立了航迹规划问题的数学模型.然后将轨迹规划问题转换成一个求最短路径的单目标的有约束的优化问题,针对这类问题的求 解,采用了一种新的粒子群算法并利用软件编程求解.最后验证了结果的可行性,同时讨论了结果的稳定性和收敛性.
⛄ 部分代码 % The dodes for the paper "Cost-sensitive feature selection using
% two-archive multi-objective artificial bee colony algorithm"
% The program was completed by Yong Zhang. If you any questions, please call email:YONGZH401@126.COM
% The parameter X is the selected dataset
% D-1 is the size of features
% cost is the cost vector of all the orignal features
%%%%% the optional data sets are as follows:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/371f50b07653fc0e1a90cc56a9b3f884/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d30e41e70b9d867e9f065b7d611f820/" rel="bookmark">
			【redisson】【redis】redisson初始化失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息 Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'redissonLockExecutor' defined in class path resource [com/baomidou/lock/spring/boot/autoconfigure/RedissonLockAutoConfiguration.class]: Unsatisfied dependency expressed through method 'redissonLockExecutor' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'redisson' defined in class path resource [org/redisson/spring/starter/RedissonAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.redisson.api.RedissonClient]: Factory method 'redisson' threw exception; nested exception is org.redisson.client.RedisConnectionException: Unable to init enough connections amount! Only 7 of 8 were initialized.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d30e41e70b9d867e9f065b7d611f820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d8d2a6b1212e4187c1f70fe2805526c/" rel="bookmark">
			使用Sqlite构建服务端简易DBProxy数据库代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Sqlite构建服务端简易DBProxy数据库代理 目前博主构建的建议数据库代理（DBProxy）是依附于主线程单独开一个线程处理的（注意，这里只开了一个线程，这个线程依附于主线程）。单独开一个线程管理DBProxy，主要目的是不想让存盘（文件操作）的耗时影响到主线程，即我们将存盘操作从同步策略变换为异步策略。
关于Sqlite的封装可参考：https://ufgnix0802.blog.csdn.net/article/details/128192088
关于C++11的线程库封装可参考：https://ufgnix0802.blog.csdn.net/article/details/128069481
关于单例类模块的实现可参考：https://ufgnix0802.blog.csdn.net/article/details/128121759
以下代码仅供思路，不做演示。
DBProxy.h #pragma once class IDBModule { public: IDBModule() {} virtual ~IDBModule() {} bool virtual DBExec(U::DB::DBSqlite* pSqlite) = 0; bool virtual OnDBExec() = 0; bool virtual Release() = 0; }; class DBProxy { SINGLETON_CLASS_FUNC_DECL(DBProxy) public: int Init(const char* dbPath); bool UnInit(); bool Start(); bool Stop(); //同步初始化场景和商城 bool GamaServiceSubmoduleConfig(class Scene* scene, class Shop* shop); bool PostHandlerEvent(IDBModule* iDBModule); bool OnPostHandlerEvent(IDBModule* iDBModule); private: U::DB::DBSqlite m_sqlite; U::THREAD::Thread m_thread; //任务队列 std::mutex m_mutexWork; std::vector&lt;IDBModule*&gt; m_workArr; int m_version; //数据库版本号 }; DBProxy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d8d2a6b1212e4187c1f70fe2805526c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11d437df2bd56dd849643bac56aa3773/" rel="bookmark">
			修改mysql表中的一个字段类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		您可以使用以下 SQL 语句来修改 MySQL 表中的一个字段类型：
ALTERTABLE 表名 MODIFY 字段名 字段类型 [可选的字段属性] [可选的字段约束]; 例如，假设您想要将表 "users" 中的 "email" 字段的类型从 VARCHAR(255) 改为 VARCHAR(100)，您可以使用以下语句：
ALTER TABLE users MODIFY email VARCHAR(100); 请注意，在修改字段类型时，您应该小心谨慎。如果您将字段类型修改为不适合原有数据的类型，则可能会导致数据丢失或损坏。因此，在修改字段类型之前，您应该先备份表中的数据，以便在修改失败时能够恢复数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05c374c3ea78a31daf97124acb3eca21/" rel="bookmark">
			aardio网页自动化和窗口自动化的学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网页自动化用于采集、填表等任务，现在一般用Chrome，aardio提供了chrome driver和chrome driverex扩展库，支持cdp命令。
窗口自动化，无非是win、winex、mouse、key几个库配合，标准窗口就是句柄操作，非标准窗口可以使用winex.accObject，还不行就找图找色找字，扩展库里还有大漠。
下面是我之前的两个小练习：
一、网页自动化
import win.ui; /*DSG{{*/ var winform = win.form(text="Chrome Driver 练习";right=584;bottom=539;bgcolor=12639424;border="thin";max=false) winform.add( button={cls="button";text="开始采集";left=394;top=27;right=462;bottom=56;z=2}; button2={cls="button";text="保存结果";left=474;top=26;right=547;bottom=57;disabled=1;z=10}; combobox={cls="combobox";left=69;top=199;right=211;bottom=225;edge=1;items={};mode="dropdown";z=6}; edit={cls="edit";text="http://m.titan007.com/info.htm#section1";left=70;top=27;right=388;bottom=54;edge=1;multiline=1;readonly=1;z=1}; edit2={cls="edit";left=69;top=67;right=548;bottom=192;edge=1;hscroll=1;multiline=1;vscroll=1;z=4}; listview={cls="listview";left=66;top=236;right=548;bottom=527;edge=1;fullRow=1;gridLines=1;hscroll=1;vscroll=1;z=9}; static={cls="static";text="网址：";left=18;top=26;right=59;bottom=50;align="center";center=1;transparent=1;z=3}; static2={cls="static";text="日志：";left=17;top=65;right=64;bottom=89;align="center";center=1;transparent=1;z=5}; static3={cls="static";text="大洲：";left=14;top=203;right=61;bottom=227;align="center";center=1;transparent=1;z=7}; static4={cls="static";text="国家：";left=14;top=244;right=61;bottom=268;align="center";center=1;transparent=1;z=8} ) /*}}*/ winform.listview.setColumns({"","序号","国家","链接"},{1,50,100,-1},{0,2,2,0}) var result={} var log=function(...){ winform.edit2.print(tostring(time(,"%H:%M:%S")),...);	} import chrome.driverex var driver,err=chrome.driverex() if !driver return win.msgbox(err); driver.disableAutomation() driver.setHeadless() winform.button.oncommand = function(id,event){ winform.button.disabled=true log("打开浏览器") wb=driver.startBrowser() log("打开网页") wb.go(winform.edit.text) wb.wait() log("获取大洲名称") var lables=wb.getEles("xpath",`//*[@id="tabHeader"]/ul/li`) for (i=2;#lables){ var lableText=lables[i].getText() winform.combobox.add(lableText) } winform.combobox.add("全部") winform.combobox.selText="全部" var n=0 for (i=2;#lables){ var lableText=lables[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05c374c3ea78a31daf97124acb3eca21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c18754cb09c6cf60d71df449bdb75f09/" rel="bookmark">
			毕业设计 STM32空气质量检测仪 - 单片机 嵌入式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 简介2 系统设计概述3 系统总体方案4 硬件设计方案4.1 stm32 主控4.2 温度采集模块4.3 甲醛浓度检测模块4.4 PM2. 5 浓度检测模块4.5 液晶显示模块设计4.6 GSM 模块4.7 蓝牙模块 5 软件部分设计5.1 初始化5.2 温湿度检测程序设计5.3 甲醛浓度检测程序设计5.4 PM2. 5 浓度检测程序设计5.5 短信发送程序设计 效果展示6 项目源码6.1 ADC部分6.2 DS18B206.3 RTC部分6.4 main部分 7 最后 1 简介 Hi，大家好，学长今天向大家介绍一个 单片机项目
基于STM32的空气质量检测仪
大家可用于 课程设计 或 毕业设计
2 系统设计概述 如今人们大约 80%的时间是在室内度过的， 室内空气质量与我们每个人的工作和生活都息息相关， 因此对生活环境的空气质量提出了更高的要求。 针对雾霾、 室内装修等污染问题， 人们还没有有效的办法控制空气中的有害物质， 这一问题也成为人们的健康隐患， 因此对室内的空气质量进行检测至关重要。
当室内有害气体的浓度超标时， 会对人们的身心健康带来不可忽视的影响。 为了让人们及时准确地获得室内有害气体甲醛、 PM2.5 的浓度， 采取有效措施改善生活环境的空气质量， 提高工作效率。 根据我国室内空气监管标准 GB50325-2010， 学长设计了一款基于STM32F103C8T6 单片机的便携式、 低功耗室内空气质量检测仪。 该检测仪可以实时测量室内的温湿度、 甲醛浓度、 PM2.5 浓度， 并在液晶显示屏 LCD12864 上实时显示出来， 当甲醛浓度或 PM2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c18754cb09c6cf60d71df449bdb75f09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dc1246c61a16e5346a8f028b0983654/" rel="bookmark">
			如何实现大文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、解决方案 既然大文件上传不适合一次性上传，那么将文件分片散上传是不是就能减少性能消耗了。
分片上传就是将大文件分成一个个小文件（切片），将切片进行上传，等到后端接收到所有切片，再将切片合并成大文件。通过将大文件拆分成多个小文件进行上传，确实就是解决了大文件上传的问题。因为请求时可以并发执行的，这样的话每个请求时间就会缩短，如果某个请求发送失败，也不需要全部重新发送。
二、具体实现 （1）读取文件 准备HTML结构，包括：读取本地文件（input类型为file）、上传文件按钮、上传进度。
&lt;input type="file" id="input"&gt; &lt;button id="upload"&gt;上传&lt;/button&gt; &lt;!-- 上传进度 --&gt; &lt;div style="width: 300px" id="progress"&gt;&lt;/div&gt; JS实现文件读取：
监听input的change事件，当选取了本地文件后，打印事件源可得到文件的一些信息：
let input = document.getElementById('input') let upload = document.getElementById('upload') let files = {}//创建一个文件对象 let chunkList = []//存放切片的数组 ​ // 读取文件 input.addEventListener('change', (e) =&gt; { files = e.target.files[0] console.log(files); //创建切片 //上传切片 }) （2）创建切片 文件的信息包括文件的名字，文件的大小，文件的类型等信息，接下来可以根据文件的大小来进行切片，例如将文件按照1MB或者2MB等大小进行切片操作：
// 创建切片 function createChunk(file, size = 2 * 1024 * 1024) {//两个形参：file是大文件，size是切片的大小 const chunkList = [] let cur = 0 while (cur &lt; file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dc1246c61a16e5346a8f028b0983654/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d82fe6bd50f9fce55b3cb512328f59f/" rel="bookmark">
			Mysql查询日期timestamp格式的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Navicat中，时间戳(timestamp)格式的数据表现为：
查询某一天的数据 SELECT * FROM my_table WHERE `update_time` LIKE '2022-10-06%' 或是：
SELECT * FROM my_table WHERE `update_time` BETWEEN '2022-08-04 00:00:00' AND '2022-08-04 23:59:59' 或是：
SELECT * FROM my_table WHERE `update_time` &gt;= '2022-08-04 00:00:00' AND `update_time` &lt;= '2022-08-04 23:59:59' 同理，如果是某一天的某个小时的数据，可以使用：
SELECT * FROM my_table WHERE `update_time` LIKE '2022-06-29 10:%' 查询时间区间内的数据 比如查询 2022-08-04 到 2022-08-05 之间的数据，可以得到：
SELECT * FROM my_table WHERE `update_time` BETWEEN '2022-08-04' AND '2022-08-05' 取某个时间点之后、之前的数据 某个时间点之后：
SELECT * FROM my_table WHERE `update_time` &gt;= '2022-08-04 00:00:00' 之前：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d82fe6bd50f9fce55b3cb512328f59f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/befb51674bb73f6514c98f4b89ad1f35/" rel="bookmark">
			eNSP:如何解决防火墙上出现大量的提示信息呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如何解决eNSP中防火墙上出现大量的提示信息呢？
我们任意选择一个视图，输入如下命令，就可以解决防火墙上出现提示信息的干扰问题。
在用户视图下，我们可以输入undo terminal monitor，关闭终端监控器，同时也关闭了大量的信息提示。
在系统视图下，我们可以输入undo info-center enable，关闭信息提示中心，同时也关闭了大量的信息提示。
注：
用户视图是用尖括号&lt;&gt;括起来的，系统视图是用方括号[]括起来的Tab键可以补全你正在输入的代码，但前提是你正在输入的代码必须是在选择进入的视图中，该视图存在拥有的代码。否则，按Tab键也无济于事，没办法补全。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab1cdb75de26960b645903233aade5ea/" rel="bookmark">
			spring cloud gateway网关转发websocket请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springcloud gateway网关是所有微服务的统一入口。
1、springcloud gateway关键术语
Route：路由，网关配置的基本组成模块。一个Route模块由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配，目标URI会被访问。Predicate：断言，可以使用它来匹配来自 HTTP 请求的任何内容。Filter：过滤器，可以使用它拦截和修改请求，并且对上游的响应，进行二次处理。过滤器为org.springframework.cloud.gateway.filter.GatewayFilter类的实例。 2、springcloud gateway处理流程
客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。
3、在springcloud gateway网关中，在yml配置文件中通过如下配置对websocket请求进行转发：
spring: cloud: gateway: routes: - id: websocket1 uri: ws://127.0.0.1:9099 #使用方式1：websocket配置，直接地址 #uri: lb:ws://serviceName #使用方式2：websocket配置，通过nacos注册中心调用serviceName predicates: - Path=/websocket 当websocket服务为基于netty的socketio，netty需要单独开端口访问，上面方式要直接指定websocket服务的端口，多个websocket服务时，可以配置多个相同的路由规则，每个指定一个socketio服务，然后通权重实现负载均衡：
spring: cloud: gateway: routes: - id: websocket1 uri: ws://127.0.0.1:8081 predicates: - Path=/socket - Weight=group1,50 - id: websocket2 uri: ws://127.0.0.1:8082 predicates: - Path=/socket - Weight=group1,50 4、在springcloud gateway网关中转发websocket请求时，连上websocket后出现立马断开问题，报错java.lang.UnsupportedOperationException，详细如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab1cdb75de26960b645903233aade5ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b372df5d7d6f3f3135cae673879ae2bb/" rel="bookmark">
			aardio嵌入外部窗口（以scrcpy手机投屏窗口为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		scrcpy是一个安卓手机投屏到电脑的开源组件。手机在开发者选项中打开USB调试开关，使用数据线连接到电脑，运行scrcpy.exe，就可以在电脑上查看手机屏幕，可以使用鼠标、键盘进行操作，并且提供了一系列命令行和快捷键，方便二次开发。我下载的是scrcpy-win32-v1.25，你也可以到github下载其他版本。
嵌入外部窗口并不是一个值得推荐的开发方式，但这个方法还是要掌握，有时候可以作为应急之选。下面是个小练习。
import win.ui; /*DSG{{*/ var winform = win.form(text="未连接";right=759;bottom=469;bgcolor=12639424) winform.add( btnConnect={cls="button";text="连接手机";left=473;top=59;right=614;bottom=101;dr=1;dt=1;z=1}; btnDisconnect={cls="button";text="断开连接";left=472;top=127;right=613;bottom=169;dr=1;dt=1;z=2} ) /*}}*/ import process.popen import winex import winex.key winform.btnConnect.oncommand = function(id,event){ if pp return ; pp=process.popen("\scrcpy\scrcpy.exe") device=pp.expect("Device\:(.+?)\r",5000) if (!device ){ pp.terminate() pp=null hwnd=null return win.msgbox("连接失败"); } winform.text=device hwnd=winex.wait(,,"@SDL_app",,,pp.process.id) win.modifyStyle(hwnd,0x800000/*_WS_BORDER*/|0x40000/*_WS_THICKFRAME*/) winex.attach(hwnd,true) winex.key.combine(hwnd,"ALT","W") winex.attach(hwnd,false) _,_,w0,h0=win.getPos(hwnd) win.setParent(hwnd,winform.hwnd) adjust(hwnd) win.show(hwnd) } winform.btnDisconnect.oncommand = function(id,event){ if pp pp.terminate(); pp=null hwnd=null winform.text="未连接" } winform.onClose = function(hwnd,message,wParam,lParam){ if pp pp.terminate() } winform.adjust = function( cx,cy,wParam ) {	adjust(hwnd) }; adjust=function(hwnd){ if !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b372df5d7d6f3f3135cae673879ae2bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de2119a4f77ed4a61a7bd0215be616e9/" rel="bookmark">
			Merry Christmas！一起用C语言绘制一个动态的圣诞树吧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一起用C语言绘制一个动态的圣诞树吧 下面就是演示效果
动态圣诞树视频
一、实现步骤 我们利用ANSI Escape Sequences实现文字和背景颜色的绘制，之后使用系统命令定时刷新窗口并重新绘制圣诞树，以实现动态效果。相关函数如下所示：
clrscr()：用于清理窗口；printRandLeaf()：随机化树叶的形状；triangle()：绘制圣诞树的每一层；printTree()：调用triangle()完成整个树冠的绘制；printLog()：完成整个树杆的绘制； 几个关键宏含义如下：
RefRate：圣诞树的刷新频率，越小刷新越快；randomness：控制树叶中‘ * ’的密度，越大密度越高；WIDTH_FACTOR：控制圣诞树在窗口中的位置，最小值为2。值越大越往右边偏移； 二、编码实现 // 此C程序用于生成一棵圣诞树 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #define RefRate 40000 #define randomness 5 // 越高树叶越少 #define WIDTH_FACTOR 4 void clrscr() { system("@cls||clear"); } void printRandLeaf() { char leaftypes[5] = { '.', '*', '+', 'o', 'O' }; int temp = rand() % randomness; // Giving preference to * if (temp == 1){ int other = rand() % 5; if(other == 3) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de2119a4f77ed4a61a7bd0215be616e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7561962ba5e73dac5167a460e89d95b0/" rel="bookmark">
			YoloV5实战：手把手教物体检测——YoloV5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘要
训练
1、下载代码
2、配置环境
3、准备数据集
4、生成数据集
5、修改配置参数
6、修改train.py的参数
7、查看训练结果
测试
摘要 YOLOV5严格意义上说并不是YOLO的第五个版本，因为它并没有得到YOLO之父Joe Redmon的认可，但是给出的测试数据总体表现还是不错。详细数据如下：
YOLOv5并不是一个单独的模型，而是一个模型家族，包括了YOLOv5s、YOLOv5m、YOLOv5l、YOLOv5x、YOLOv5x+TTA，这点有点儿像EfficientDet。由于没有找到V5的论文，我们也只能从代码去学习它。总体上和YOLOV4差不多，可以认为是YOLOV5的加强版。
项目地址：GitHub - ultralytics/yolov5: YOLOv5 🚀 in PyTorch &gt; ONNX &gt; CoreML &gt; TFLite
训练 1、下载代码 项目地址：GitHub - ultralytics/yolov5: YOLOv5 🚀 in PyTorch &gt; ONNX &gt; CoreML &gt; TFLite，最近作者又更新了一些代码。
2、配置环境 matplotlib&gt;=3.2.2 numpy&gt;=1.18.5 opencv-python&gt;=4.1.2 pillow PyYAML&gt;=5.3 scipy&gt;=1.4.1 tensorboard&gt;=2.2 torch&gt;=1.6.0 torchvision&gt;=0.7.0 tqdm&gt;=4.41.0 3、准备数据集 数据集采用Labelme标注的数据格式，数据集从RSOD数据集中获取了飞机和油桶两类数据集，并将其转为Labelme标注的数据集。
数据集的地址： https://pan.baidu.com/s/1iTUpvA9_cwx1qiH8zbRmDg
提取码：gr6g
或者：LabelmeData.zip_物体检测yolov5-深度学习文档类资源-CSDN下载
将下载的数据集解压后放到工程的根目录。为下一步生成测试用的数据集做准备。如下图：
4、生成数据集 YoloV5的数据集和以前版本的数据集并不相同，我们先看一下转换后的数据集。
数据结构如下图：
images文件夹存放train和val的图片
labels里面存放train和val的物体数据，里面的每个txt文件和images里面的图片是一一对应的。
txt文件的内容如下：
格式：物体类别 x y w h 坐标是不是真实的坐标，是将坐标除以宽高后的计算出来的，是相对于宽和高的比例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7561962ba5e73dac5167a460e89d95b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0669449e0b17cbbed787db24ad5dd013/" rel="bookmark">
			声明式服务调用OpenFeign
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. OpenFeign1. Feign 与 OpenFeign 二. OpenFeign的使用三. OpenFeign自定义配置1. 修改日志级别2. 超时控制 四. OpenFeign性能优化五. OpenFeign最佳实践1. 继承2. 抽取 PS: 本文为作者学习笔记，实际技术参加意义不大，本文将持续改进完善。
一. OpenFeign OpenFeign是一个声明式的http客户端，SpringCloud生态中服务调用的一个组件。
相关的服务调用组件还有: Feign、Ribbon、LoadBalancer等等
官方地址：点击跳转
其作用就是帮助我们优雅的实现http请求的发送
1. Feign 与 OpenFeign Feign:
Feign,是Spring Cloud组件中的一个轻量级RESTfulE的HTTP服务客户端，Feign内置了Ribbon,用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用这个接口就可以调用服务注册中心的服务。
依赖:
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; OpenFeign：
OpenFeign,是Spring Cloud在Feign的基础上支持了SpringMVC的注解如@RequesMapping等等。OpenFeign的@FeignClienti可以解析,SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。
依赖:
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; PS: 其实完全可以将OpenFeign理解为Feign的升级版。
二. OpenFeign的使用 想要使用OpenFeign，首先需要引入OpenFeign的依赖:
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 然后在模块的主启动类上添加 @EnableFeignClients 注解，如下:
@SpringBootApplication @EnableFeignClients public class OrderFeignMain80 { public static void main(String[] args) { SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0669449e0b17cbbed787db24ad5dd013/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ca3269e17fb901c96363f35bdc5141e/" rel="bookmark">
			clion 配置 cmakelist.txt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 cmake_minimum_required(VERSION 3.24) project(test01) set(CMAKE_CXX_STANDARD 17) #添加include路径 include_directories(/home/qf/TensorRT_8.2.5.1/include) include_directories(/home/qf/TensorRT_8.2.5.1/samples/common) #添加.so库文件路径 相当于 -L link_directories(/usr/local/cuda-11.4/targets/x86_64-linux/lib) #添加动态连接库的路径 link_directories(/home/qf/TensorRT_8.2.5.1/targets/x86_64-linux-gnu/lib) #添加一个lib文件下所有so文件 set(TENSORRT_LIB_PATH “/home/qf/TensorRT_8.2.5.1/lib”) file(GLOB LIBS “${TENSORRT_LIB_PATH}/*.so”) #快捷添加CUDA find_package(CUDA 11.4 REQUIRED) message(“CUDA_LIBRARIES:${CUDA_LIBRARIES}”) message(“CUDA_INCLUDE_DIRS:${CUDA_INCLUDE_DIRS}”) include_directories(${CUDA_INCLUDE_DIRS}) #总链接操作 -lcudart add_executable(test01 main.cpp) target_link_libraries(test01 ${LIBS} ${CUDA_LIBRARIES} cudart nvinfer ) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/410501cb72052da2571b274a3b136e01/" rel="bookmark">
			如何使用js(jQuery)加载json？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前期准备： 1.网站开发工具(这里以HBuilderX为例)
2.一台能开机的电脑
一、ajax（XMLHttpRequest）: // index.json文件 { "data": { "list": [ {"name": "数据表1", "id": "1"}, {"name": "数据表2", "id": "2"}, {"name": "数据表3", "id": "3"} ] } } html代码如下：
&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;加载json&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;script&gt; var xmlhttp = new XMLHttpRequest(); xmlhttp.onreadystatechange = function(){ if(xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) { // 当满足返回第四阶段和状态码为200时执行 var json = JSON.parse(this.responseText); //转换读取到的文件内容为json格式 console.log(json); } } xmlhttp.open('GET', '/index.json'); // 导入JSON文件 xmlhttp.send(); &lt;/script&gt; &lt;/html&gt; 这里采用的是js里ajax的异步加载，创建XMLHttpRequest参数之后通过这个属性读取json文件，最后使用JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/410501cb72052da2571b274a3b136e01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ddef377a03544bb3a4c14b6b063149a/" rel="bookmark">
			Remote side unexpectedly closed network connection
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		"Remote side unexpectedly closed network connection" 意思是远程端意外地关闭了网络连接。这通常表示在两台计算机之间建立的网络连接已经意外中断。这可能是由于多种原因造成的，包括网络故障、计算机硬件故障、软件故障或其他原因。如果您在使用软件时看到这条消息，则可能需要检查网络设置、更新软件或重启计算机，以便解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/049cb3daddee481572513df8a2d0bb1c/" rel="bookmark">
			Graphviz安装向导及入门指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、首先在官网下载graphviz
2、安装。
3、测试并在Windows命令行中使用
4、在Python中使用 5、在自带的gvedit.exe 程序中使用
6、在语雀中使用 7、绘制一棵简单的二叉树
8、详细语法介绍
8.1 带标签
8.2 修改方框颜色和形状
8.3子视图 8.4 结构视图
8.5 继承关系 1、首先在官网下载graphviz 下载网址：Download | Graphviz
根据自身电脑位数选择合适的下载地址 2、安装。 打开第一步已经下载好的软件。点击下一步，在安装路径选择时可将安装路径修改为 E:\Graphviz
注意必须要将Graphviz添加到系统PATH中 选择好安装目录后，点击下一步，即可安装成功 验证PATH有没有正确添加到系统中 可以看到bin文件夹已经添加到环境变量中
3、测试并在Windows命令行中使用 测试是否安装成功，Win+R 或者在搜索栏打开命令提示符窗口 输入 dot -version （注意dot后面后一个空格）。成功出现如下信息表示注册成功。若出现dot不是内部或外部命令，则表示安装失败。
在桌面上保存一个test.dot文件，在命令行中调用如下的命令
dot -Tpng test.dot -o test.png 我们可以发现桌面上果然出现了我们想要的test.png文件 打开test的属性，我们可以看到文件类型是DOT文件，我们可以用Windows自带的文本编辑器打开，但是必须要另存为DOT文件。否则会出现错误
dot: can't open test.dot
4、在Python中使用 在命令行输入如下指令 pip install graphviz 5、在自带的gvedit.exe 程序中使用 在Windows的所有程序里G开头的文件夹中，点击打开gvedit.exe。这个程序是随着程序一起安装到电脑中的。注意程序要下载msi资源。
graphviz-2.37.20140115.zip_graphviz-HTML5文档类资源-CSDN下载
双击会跳出如下图所示的界面 我们要牢记一点，就是dot语言是一种工具，我们目的不是要多精通这种语言，仅仅是为了能够画出自己想要的图片，不要舍本逐末。
6、在语雀中使用 语雀自带了文本绘图功能，非常方便 7、绘制一棵简单的二叉树 黑色跑步的人的方框代表编译
digraph BinaryTree { a -&gt; b a -&gt; c b -&gt; d d [label="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/049cb3daddee481572513df8a2d0bb1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9af95d5ff95c0ca3a429061defa991d3/" rel="bookmark">
			输出：每行由n个*组成的，高度为n的平行四边形。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【题目描述】
输入大于1的正整数n，输出一个平行四边形，要求每行有n个*号，高度为n。
【输入】
整数n。
【输出】
每行由n个*组成的，高度为n的平行四边形。
【样例输入】
7↙
【样例输出】
*******
*******
*******
*******
*******
*******
*******
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include&lt;math.h&gt; int main() { int n,i,j,k; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) { for(j=1;j&lt;i;j++) { printf(" "); } for(k=1;k&lt;=n;k++) { printf("*"); } printf("\n"); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab3873d4625b0f55acdead496bb3ac7/" rel="bookmark">
			redis中springboot的redisTemplate简单的增删查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.
private static final Logger LOGGER = LoggerFactory.getLogger(HttpServiceImpl.class); @Resource private RedisTemplate&lt;String, Object&gt; redisTemplate; @PostMapping("delete") public Result delete(boolean flag) { //设置存储的过期时间 redisTemplate.opsForValue().set("hha","dada",50, TimeUnit.SECONDS); //设置不过期时间的Key redisTemplate.opsForValue().set("kk","hhh"); System.out.println(redisTemplate.opsForValue().get("kk")); //删除指定的key redisTemplate.delete("kk"); studentService.removeById(2); return flag ?Result.ok("第一个"):Result.fail("第二个"); } 过期时间的查看命令 ttl name
在图形化界面中也可以查看redis的过期时间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0214b572af017bb3559795436780b51d/" rel="bookmark">
			迷宫求解(使用队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在迷宫中，从入口到出口往往有一条或者多条最短路径。可以使用队列来求解迷宫的最短路径，使用队列时，搜索路径是一层一层向前推进，第一次找到出口是搜索的层数最少，这种搜索方法与广度优先算法类似。
使用队列Qu记录走过的方块，该队列的结构如下：
struct{ int i; //方块的行号 int j; //方块的列号 int pre; //前一方块在队列中的下标 }Qu[MaxSize]; //定义顺序队列 int front=0,rear=0; //定义队头和队尾指针并置初值为0 这里使用的队列Qu不是环形队列，为什么不采用环形队列呢？因为元素出队后，还要利用它输出路径，所以不将出队元素真正地删除。
搜索从(x1,y1)到(x2,y2)路径的过程是：首先将(x1,y1)入队，在队列Qu不为空时循环，出队一次(由于不是环形队列，该出队元素仍在队列中)，称该出队的方块为当前方块，front为该方块在Qu中的下标。
如果当前方块为出口，则输出路径并结束。否则，按顺时针方向找出当前方块的4个方位中可走的相邻方块(对应的mg数组为0)，将这些可能的相邻方块均插入到队列Qu中，其pre设置为搜索路径中上一个方块在Qu中的下标值，也就是当前方块的front值，并将相邻方块对应的mg数组值置为-1，以避免重复搜索。如果队列为空，表示未找到出口，即不存在路径。
如图(1)所示的迷宫，求它从起点到终点所有的最短路径。
代码如下：
//migong.cpp
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define MaxSize 100 #define M1 6 //迷宫的最大行数 #define N1 6 //迷宫的最大列数 struct { int i; //方块的行号 int j; //方块的列号 int pre; //前一方块在队列中的下标 }Qu[MaxSize]; //定义顺序队列 int front = 0, rear = 0; //定义队头和队尾指针并置初值为0 int mg1[M1][N1] = { //1: 代表墙，0: 代表通道 { 1,1,1,1,1,1 }, { 1,0,0,0,1,1 }, { 1,0,1,0,0,1 }, { 1,0,0,0,1,1 }, { 1,0,0,0,0,1 }, { 1,1,1,1,1,1 } }; int minlen = 0; //最短路径长度 int num = 1; //路径计数 //从队列中输出路径 void print1(int front) { int k = front, j; int ns = 0; do { j = k; k = Qu[k].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0214b572af017bb3559795436780b51d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31727fbac3ffe5f257e775b3e907f11d/" rel="bookmark">
			centos7.9 python安装pillow报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sudo yum install python-devel
sudo yum install zlib-devel
sudo yum install libjpeg-turbo-devel
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b0deea1cd820487309a9ae5841e61d7/" rel="bookmark">
			vmware使用显卡 | vmware切换显卡 | vmware显卡配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 通过vmwarelog 日志文件查看可用显卡 打开虚拟机目录下的vmware.log日志文件, 找到自己的显卡位置
Enumperting是在遍历所有可用显卡， 后面的vendor， 指示显卡代号， 这里是0x10de
第二个红框adapter ‘显卡名称’　说明他使用了显卡　NVIDIA GeForce GTX1050Ti
2. 修改 vmx文件切换可用显卡 我们想切换到1050Ti， 那么就打开虚拟机目录下的.vmx文件
添加：mks.dx11.vendorID = "0x10de"行
0x10de 在 .log文件中搜索 vendor 即可得到
3. 重启vmware查看显卡是否更换 重启vmware再次查看vmware.log文件， 不出意外已经切换
转载：https://blog.csdn.net/wayle123/article/details/126450830添加链接描述
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d2f338a4933a70c60a9364371734c35/" rel="bookmark">
			DCEL C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DECL DECL结构是比较通用的来表示几何的数据结构
主要包括三种数据结构：
1.点 vertex
2.半边 edge
3.面 face
点 存储点的位置以及任意一条由该点为起点向量的半边
半边 其中几何边由两条半边组成
这也是一种表示方式
面 存储一个面的外边界和内边界，如果外边界或者内边界不存在那么直接等于nullptr
像下面这种情况内部空洞需要用一个vector来存储了
通用的表达方式 数据结构简单实现（不包括具体操作） template&lt;typename type = float, size_t dim = DIM3&gt; struct VertexDCEL { Vector&lt;float, dim&gt; point;// 1.Coordinates EdgeDCEL&lt;type, dim&gt;* incident_edge = nullptr;// 2.以point任意为起点的半边 VertexDCEL(Vector&lt;type, dim&gt;&amp; _point) :point(_point) {} //...... }; template&lt;typename type = float, size_t dim = DIM3&gt; struct EdgeDCEL { //1.起始点 VertexDCEL&lt;type, dim&gt;* origin = nullptr; //2.与该半边相关联的三条半边 EdgeDCEL&lt;type, dim&gt;* twin = nullptr; EdgeDCEL&lt;type, dim&gt;* next = nullptr; EdgeDCEL&lt;type, dim&gt;* prev = nullptr; //3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d2f338a4933a70c60a9364371734c35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad817a4cd4073be8b8595634e6170982/" rel="bookmark">
			30：C语言之亲密数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; void solve(){ /*********Begin*********/ int a,b,c=0,m=0; for(a=1;a&lt;=3000;a++) {	for(b=1;b&lt;a;b++) { if(a%b==0) c=c+b; } for(b=1;b&lt;c;b++) { if(c%b==0) m=m+b; } if(m==a) { if(a!=c&amp;&amp;a&lt;c) printf("(%d,%d)",a,c); } c=0,m=0; } /*********End**********/ } int main(void) { solve(); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/038c1ced560c0cc9e74e5729bab62ef4/" rel="bookmark">
			win10家庭版转专业版后，专业版功能仍然不能用怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、win10家庭版转专业版方法
1.taobao购买转版激活码（8元和12元的都行）
2.百度搜索激活码（一般时代久远不可用）
3.软件一键转版本
二、激活专业版
1.购买淘宝转版激活码的，商家会负责再发个激活码激活专业版
2.kms激活器，亦是美网络的
三、激活后专业版后，发现组策略和远程桌面仍然不能用怎么办
去win10官网下载版本更新器，版本更新器有两个功能
1.给win7，win8升级win10，给win10修bug
此功能不会导致自己的文件，应用被格式化
2.u盘转录成系统和ISO镜像文件
该功能为系统重装所用
这里我们选择功能1，用来解决win10的bug
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cab9b75cd4963d78b80b0b1d53514cee/" rel="bookmark">
			cmd常用命令讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cmd命令目录
一、ping命令
1、-a：ping -a IP地址
2、-t：持续发送数据包 3、 -n：指定发送数据包次数
4、 -l：指定数据包大小
二、NETSTAT命令
1、netstat -a：查看当前计算机的端口信息；
2、netstat -e：查看以太网统计数据；
3、netstat -r：查看当前网络接口信息、路由表信息；
三、NBTSTAT命令
1、nbtstat -a IP：查看目标的NetBIOS信息
2、nbtstat -n：查看当前计算机的NetBIOS信息
四、TRACERT命令
五、IPCONFIG命令
1、ipconfig：查看TCP/IP的简单配置信息：IP、子网掩码、网关等；
2、ipconfig/all：查看更详细的配置信息；
3、ipconfig/release和ipconfig/renew结合使用
4、ipconfig/flushdns：清除DNS缓存
六、ARP命令
1、arp -a：查看arp缓存表
2、arp -s IP MAC：添加arp缓存（管理员权限）
3、arp -d IP：删除指定arp缓存条目
八、NSLOOKUP命令
1、nslookup：查看主机默认dns服务器名称和地址
2、输入要查询IP的网址
九、NET命令
十、FTP命令
十一、TELNET命令 一、ping命令 ping主要用来检查网络是否通畅或者检查网络的连接速度。
常用参数：
-a：将地址解析成主机名；
-t：不间断的向目标发送数据包，直至强迫目标下线停止；如我们使用的是100M的宽带，而目标是一个50K左右的小猫，那么可能用不了多久其就会因为承受不了那么多的数据而掉线。
-n：定义向目标IP发送数据包的次数；默认是4次。
-l：（小写的L）定义数据包的大小，默认为32字节，最大可以定义到65500字节，结合-t参数达到目的；
1、-a：ping -a IP地址 可以看到目标主机的主机名，而且收到了数据包，说明目标网络可通；
2、-t：持续发送数据包 可以看到一直持续对目标进行ping操作，网络延迟很低，网络良好；退出的话要进行强制退出：ctrl+c；
3、 -n：指定发送数据包次数 指定发送两个数据包，发送成功；默认数据为：32字节；
4、 -l：指定数据包大小 指定数据包大小为64字节，发送成功； 结合-t使用，可以发送大量数据包，强制对方下线。
二、NETSTAT命令 netstat命令用于监控tcp/ip网络，查看开放的端口、协议、路由信息、实际网络连接及网络接口设备的状态信息；
-a：查看所有的开放端口，知道机器的开启的服务等信息；
-r：列出当前的路由信息，包括网关子网掩码等信息；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cab9b75cd4963d78b80b0b1d53514cee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9b6c489251a98603342077200d02f0f/" rel="bookmark">
			【Multisim 14.0】信号发生器和示波器的使用---方波、三角波、正弦波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Multisim 14.0仿真要求：
仿真
信号发生器产生正弦波
信号发生器产生方波
信号发生器产生三角波
单相交流电源（电压220V，频率50赫兹）
三相交流电源（相电压220V，频率50赫兹）
Multisim 14.0仿真要求： 要求1：
用示波器测交流电源和信号发生器产生的各种波形。观察波形形式，查看三相交流电源的相序，测每一个波形幅值、周期、有效值和频率并计算其数值。
要求2：
信号发生器产生正弦波信号发生器产生方波信号发生器产生三角波单相交流电源（电压220V，频率50赫兹）三相交流电源（相电压220V，频率50赫兹） 提示：
注意示波器显示波形周期和频率计算时，显示屏上虚线方形边长与扫描时间和衰减量间的关系。
测三相电源相序，建议用四输入示波器观测，用双输入示波器测也可以，但考验你的智慧。
仿真 信号发生器产生正弦波 Multisim 14.0软件右侧有一列器件，第一个是万用表，第二个是函数发生器，第四个是示波器
接地的符号
接线图如下：
双击函数发生器，就可以修改波形、频率、占空比、振幅……
示波器通道A刻度：10V/Div这代表竖向一大格是10V，如果波形不完整超出图示范围或者不明显，幅度很小，都可以上下调节这个刻度，达到理想的波形。
上图 幅值是10V，峰 - 峰值为20V时基标度：10ms/Div 这代表横向一大格是10ms，图中一格完整的波形占两个大格，周期T就是2*10ms = 20ms正弦波中幅值和有效值的关系： 幅值 = √2有效值 理论计算：
由示波器读数及计算可得：
幅值A = 10V
周期T = 10 * 2 ms = 20ms
频率 = 1 / T = 50Hz
有效值 = 幅值A / √2 = 0.707*A = 7.07V
正弦波中幅值和有效值的关系： 幅值 = √2有效值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9b6c489251a98603342077200d02f0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/236922da3448ede7198600168943a350/" rel="bookmark">
			WZOI-288火星A&#43;B
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述:
读入两个不超过25位的火星正整数A和B，计算A+B。需要注意的是：在火星上，整数不是单一进制的，第n位的进制就是第n个素数。例如：地球上的10进制数2，在火星上记为“1,0”，因为火星个位数是2进制的；地球上的10进制数38，在火星上记为“1,1,1,0”，因为火星个位数是2进制的，十位数是3进制的，百位数是5进制的，千位数是7进制的……,每位的进制基数按从小到大的素数递增。
输入格式:
输入包含多组测试数据，每组测试数据一行，包含两个火星正整数A和B，火星整数的相邻两位数用逗号分隔，A和B之间有一个空格间隔。当A和B都为0时输入结束，相应的结果不要输出。
输出格式:
针对每组测试数据输出1行，即火星表示法的A+B的值。
样例输入:
3,2,0 1,2,0 0 0 样例输出:
1,0,1,0 提示:
首先要把前25位素数给求出来，然后把两个数从低位到高位依次相加。我们知道十进制加法是逢十进一，对于此题则是逢prime[i]进1（prime[i]表示第i小的素数），最后再按相应的格式要求输出即可。
时间限制: 1000ms
空间限制: 32MB
代码如下：
#include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int a[25]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97}; char b[101],c[101]; while(1){ int x[101]={0},y[101]={0},m=0,n=0; cin&gt;&gt;b&gt;&gt;c; if(strcmp(b,"0")==0&amp;&amp;strcmp(c,"0")==0){ break; } int x1=1,x2=1; for(int i=0,j=strlen(b)-1;j&gt;=0;j--){ if(b[j]==','){ x1=1; i++; continue; } x[i]+=(b[j]-'0')*x1; x1*=10; } x1=1; for(int i=0,j=strlen(c)-1;j&gt;=0;j--){ if(c[j]==','){ x1=1; i++; continue; } y[i]+=(c[j]-'0')*x1; x1*=10; } for(int i=0;i&lt;25;i++){ x[i]=x[i]+y[i]; if(x[i]&gt;=a[i]){ x[i]=x[i]-a[i]; x[i+1]++; } } for(int i=24;i&gt;=0;i--){ if(x[i]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/236922da3448ede7198600168943a350/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5d65c5641647fecb7e1055747a27a82/" rel="bookmark">
			Vue3 &#43; ts 第三篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. vue3 使用ref vue2 中 用 this.$refs.xxx 获取标签元素 或者 组件实例 vue3 中 没有this 用的麻烦 的 1. let proxy = getCurrentInstance() proxy.ctx.$refs.xxx 获取 2. 简单法 &lt;son ref="btn"&gt;&lt;/son&gt; let btn = ref() 重点是让 ref="xxx" 和 声明的响应式对象的属性保持一致 在 onMounted 钩子中获取到组件 onMounted(()=&gt;{ btn.value.fn()//调用子组件方法 }) 前提是子组件要先暴露出来 defineExpose({}) 不用引入 defineExpose({ fn }) 稍后复习 vue3.2 语法糖 define系列 defineProps defineEmit defineExpose 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75477604bccc7de614658b6f35e4cf5b/" rel="bookmark">
			最全http状态码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是http状态码
当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含 HTTP 状态码的信息头用以响应浏览器的请求。HTTP 状态码的英文为 HTTP Status Code。HTTP状态码，可以根据请求响应代码检查服务器及程序是否正常，判断网页处于什么工作状态。就需要了解不同的状态码分别是什么含义，常见的一些含义见下表：
状态码含义100客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。101服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。102由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。200请求已成功，请求所希望的响应头或数据体将随此响应返回。201请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。202服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。203服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。204服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。205服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。206服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。207由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。300被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。301被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75477604bccc7de614658b6f35e4cf5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0637723d820fb16892ae49df7289be20/" rel="bookmark">
			Vue3父子组件传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、子组件
export default { //给子组件取个名字 name:"SheduleComponent", props:{ personalDetail:{ type:Object,//类型 required:true }, dialogPersonDetail:{ type:Boolean, required:true }, // 子组件使用父组件的方法 getFatherMethod: { type: Function, default:()=&gt; { return Function } } }, data(){ return{ // vue3中直接修改夫组件的值会报错 dialogVisible:this.dialogPersonDetail, } }, methods:{ isVisible(){ //调用夫组件的方法 this.getFatherMethod() } }, //实时监听夫组件传递过来的值 watch: { dialogPersonDetail(newValue, oldValue){ console.log(newValue); console.log(oldValue); // 获得新的值后进行赋值 this.dialogVisible = newValue } } } 2、父组件
//使用子组件 //当父组件传递的值在子组件中渲染失败时，后续就不能动态的对子组件进行传值了，因此要添加判断 &lt;shedule-component v-if="personalDetail.username!=''" :dialog-person-detail="dialogPersonDetail" :personal-detail="personalDetail" :getFatherMethod="test"&gt; &lt;/shedule-component&gt; // 引入子组件 import SheduleComponent from '@/components/SheduleComponent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0637723d820fb16892ae49df7289be20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b3071753ad4885a21a7067ee442dac2/" rel="bookmark">
			yolov5的推理输出detect.py部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言detect.py1.输入参数2.设置文件保存路径3.加载训练好的模型权重4.数据处理5.进行推理6.yolov5里的nms 总结yolov5 系列 前言 推理阶段是整个检测模型完成后，要对模型进行测试的部分。很重要的一部分，只有了解了这个部分，才能在比赛或者项目提交中很好的输出自己模型的检测结果。同时，推理输出对模型部署在不同的环境下也是十分重要的。
源码：https://github.com/ultralytics/yolov5
版本yolov5 v6.1
detect.py 1.输入参数 @torch.no_grad() # 装饰器，推理部分不进行反向传播计算 def run( weights=ROOT / 'yolov5s.pt', # 加载的训练模型权重路径 source=ROOT / 'data/images', # 输入图像或视频文件路径 data=ROOT / 'data/coco128.yaml', # dataset.yaml path，自己生成的数据集yaml文件路径 imgsz=(640, 640), # inference size (height, width) conf_thres=0.25, # confidence threshold iou_thres=0.45, # NMS IOU threshold max_det=1000, # maximum detections per image，默认一张图最多输出1000个目标 device='', # cuda device, i.e. 0 or 0,1,2,3 or cpu，选择推理输出的设备 view_img=False, # show results，推理后是否展示结果图片 save_txt=False, # save results to *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b3071753ad4885a21a7067ee442dac2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b76ae3639f6e871af2c0fba277a03d73/" rel="bookmark">
			【前端面试整理 | vue相关知识整理 】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mvvm理解 MVVM是Model-View-ViewModel的缩写。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。 在MVVM架构下，View 和 Model 没有直接的联系，通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 vue.js核心 数据驱动：ViewModel，保证数据和视图的⼀致性 组件化：应⽤类UI可以看做全部是由组件树构成的 vue优点 低耦合：视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 可复用性：可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。 独立开发：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。 可测试：界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。 轻量级的框架、双向数据绑定、组件化开发、单页面路由、学习成本低、虚拟dom、渐进式框架、数据和结构的分离、运行速度快、插件化 vue组件 封装组件：为了解耦，提高代码复用率 组件是html、css和js的聚合体，相当于库，把一些能在项目里或者不同项目里可以复用的代码进行需求性的封装 组件中的data是一个函数，是因为让每个返回的实例都可以维护一份被返回对象的独立的拷贝 多个组件有相同逻辑，应该使用mixin对公共部分的逻辑进行抽离 组件之间传值 使用vue-router通过跳转链接带参数传参。 使用本地缓存localStorge。 使用vuex数据管理传值 封装组件 1、Vue.extend()创建一个组件 2、使用Vue.component()方法注册组件 3、如果子组件需要数据，可以在props中接受定义 4、子组件修改好数据之后，想把数据传递给父组件，可以使用emit()方法 可复用组件 Props 允许外部环境传递数据给组件 Events 允许组件触发外部环境的副作用 $emit Slots 允许外部环境将额外的内容组合在组件中。 尽量减少组件对外部条件的依赖 数据扁平化：每一个prop应该是一个简单类型的数据，这样组件的接口清晰，props校验方便 vueCli使用自定义组件 1、在 components 目录新建组件文件 2、在需要用到的页面import中导入 3、使用component注册 4、在 template 视图中使用组件标签 插件使用步骤 采用ES6的import .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b76ae3639f6e871af2c0fba277a03d73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeb0ba37968f28d1995909d4cb1034a4/" rel="bookmark">
			服务注册配置中心Nacos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 前言二. 下载安装1. 下载安装包2. Windows环境安装3. Linux环境安装1. 单击模式启动2. 集群模式启动3. 远程web控制4. 注册为系统服务 三. 基本使用1. 添加依赖2. 服务注册3. 配置实例集群属性4. 实例权重负载均衡5. 环境隔离6. 临时实例与非临时实例 四. Nacos配置管理1. Nacos实现配置热更新2. Nacos多环境配置共享 五. Nacos集群搭建1. 搭建数据库2. 启动3. 安装Nginx 一. 前言 PS: 本篇博客为作者学习笔记实际技术参考意义不大，小编将持续更新完善本篇文章。
Nacos服务注册配置中心，一个更易于构建云原生应用的动态服务发现，配置管理和服务管理平台，属于Springcloud Alibaba 体系中的组件之一，也是目前企业开发中最流行的服务注册与配置中心。
更多详细信息各位小伙伴可以参照Springcloud Alibaba官网: 点击跳转官网
Nacos源码地址: 点击跳转源码地址
Nacos官网地址: 点击跳转官网
一些注册中心特性对比:
二. 下载安装 1. 下载安装包 Nacos既可以在Windows上使用，也可以在Linux上面使用，下面两种系统的Nacos安装小编都会介绍到，首先我们要准备好Nacos的安装包，点进入Nacos的仓库 点击跳转。
点击 【发行版】就可以看到Nacos的全部历史版本
点击 【标签】可以选择想要的版本下载
选择好版本点击最右边的【下载】后翻到最下面就可以看到对应的下载文件，【zip】则是windows版本 【tar.gz】就是Linux使用的版本。
2. Windows环境安装 准备好Windows环境下的安装包后，就可以开始Windows环境下Nacos的安装了。
将准备好的安装包解压到任意目录下(最好是全英文的路径)解压后文件夹内结构如下:
bin目录是存放启动脚本的目录 conf目录是存放Nacos配置文件的目录。
关于端口配置，Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。如果无法关闭占用8848端口的进程，也可以进入nacos的conf目录，修改配置文件中Nacos默认启动占用的端口：
确认端口没有问题后就可以进入bin目录启动cmd窗口，使用下面的命令启动Nacos:
startup.cmd -m standalone 也可以直接双击startup.cmd文件启动Nacos
看到上面这个样子就是启动成功了，也标明了启动占用的端口和后台的访问地址。
我们用浏览器直接访问 http://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeb0ba37968f28d1995909d4cb1034a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb657e5f9f21bb63b5b948fe645ceaac/" rel="bookmark">
			前端面试常考 | 事件循环-eventloop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 前言二. 同步与异步三. 宏任务与微任务 一. 前言 事件循环-eventloop前端笔试中的高频考点，了解事件循环也可以更好的理解代码底层运行机制，夯实基本功，比如下面这一段代码:
console.log(1); setTimeout(function () { console.log(2); }, 2000); console.log(3); // 输出结果 1 3 2 输出的结果毫无疑问： 1 3 2
那么下面一段代码呢?
console.log(1); setTimeout(function () { console.log(2); }, 0); console.log(3); // 输出结果 1 3 2 输出的结果还是 ： 1 3 2 ，那么这是为什么呢?
二. 同步与异步 众所周知jS是单线程的，也就是说，事情只能一件一件的做，但是有些任务是耗时的，会阻塞代码的执行，为了解决这个问题，我们有了同步和异步的概念。
这样我们就可以把代码分为同步代码（同步任务)和异步代码（异步任务)，比如上面的例子我们可以向下面这样拆分:
// 同步代码 console.log(1); console.log(3); // 异步代码 setTimeout(function () { console.log(2); }, 2000); 同步代码：立即放入JS引擎(JS主线程)执行，并原地等待结果。
异步代码：先放入宿主环境(浏览器/Node)，不必原地等待结果，并不阻塞主线程继续往下执行，异步结果在将来执行。
所以输出的顺序是 1 3 2
执行过程:
同步代码放到执行栈中立即执行，而异步代码先会存放到宿主环境中，当达到触发条件后，就会将这个异步任务推送给任务队列(推送回调函数)，当执行栈执行完毕后就会去任务队列中拉取其中的任务进行执行，这个去任务队列中拉取异步任务的过程就是事件循环。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb657e5f9f21bb63b5b948fe645ceaac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba373aa770a6c3e6a07b5627eb343a62/" rel="bookmark">
			函数递归（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数递归（详解） 一.什么是函数递归？1.函数递归的优点2.函数递归缺点 二.函数递归的两个限制条件三.递归试题试题1试题2试题3试题四 一.什么是函数递归？ 首先我们可以从字面上来解释一下：
递归的递：可以理解为递推
递归的归：可以理解为回归
接下来我们来看看递归的定义：
程序调用自身的编程技巧称为递归（ recursion）。
递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法。
它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。
函数递归的思考方式：把大事化小
1.函数递归的优点 只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。
2.函数递归缺点 如果递归层次太深容易造成死递归，最后导致程序崩掉。
有时侯递归的效率会很低。
二.函数递归的两个限制条件 1.存在限制条件，当满足这个限制条件的时候，递归便不再继续。
2.每次递归调用之后越来越接近这个限制条件
三.递归试题 在简单了解递归是什么之后，接下来我将会用几个列子带大家更加深刻的了解递归。
试题1 接受一个整型值(无符号)，按照顺序打印它的每一位
列如输入1234 ，打印 1 2 3 4
先上思路：
接下来让我们用代码来实现它
void Print(int n) { if (n &gt; 9) //限制条件 { Print(n / 10);//无限的接近限制条件 } printf("%d ", n % 10); } int main() { int n = 0; scanf("%d", &amp;n); Print(n); return 0; } 运行结果：
如果在这里大家还不是很清晰的明白的话，不要慌，我们来画图解释一下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba373aa770a6c3e6a07b5627eb343a62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab6d463688d627f5be74604ffcc8f36/" rel="bookmark">
			贝尔曼最优方程(Bellman Optimality Equation)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		贝尔曼最优方程 目录回顾 + 补充逻辑场景设置 贝尔曼最优方程最优策略与最优价值函数最优状态价值函数最优状态-动作价值函数 小小的题外话 - 最大值/期望值最大值和期望值之间的大小关系 最优策略与两种价值函数间的关系贝尔曼最优方程表达式 本节使用 更新图的方式对 V π ( s ) V_\pi(s) Vπ​(s)和 q π ( s , a ) q_\pi(s,a) qπ​(s,a)之间的关系进行详细说明，并在贝尔曼期望方程(Bellman Expectation Equation)基础上介绍 贝尔曼最优方程(Bellman Optimality Equation)。 目录 回顾 + 补充 上一节我们介绍了贝尔曼期望方程(Bellman Expectation Equation)，并重点介绍了状态价值函数 V π ( s ) V_\pi(s) Vπ​(s)和状态-动作价值函数 q π ( s , a ) q_\pi(s,a) qπ​(s,a)之间的关系。
针对上一节中 G t = R t + 1 + γ G t + 1 G_t=R_{t+1}+\gamma G_{t+1} Gt​=Rt+1​+γGt+1​成立需要满足的4个条件，本节使用更新图的方式对该步骤进行补充。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bab6d463688d627f5be74604ffcc8f36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db01b2e0378b9efff97d12b816312db3/" rel="bookmark">
			Mac中安装homebrew全过程(附常用问题解决办法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021-01-24更新：
由于homebrew已经移除了下面的脚本，所以下面的方法不一定还有效.而科大镜像源提供的帮助文档未能成功，所以，这里提供清华镜像源的帮助文档
清华镜像源homebrew安装帮助文档
1.最简单粗暴的方法直接去homebrew的官网，复制命令，粘贴到终端里执行，如果一切正常，那你就不用往下看了。
2.如果安装过程特别慢，最后报错。你可以这么做。
首先：curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install &gt;&gt; brew_instal，复制此命令到终端，执行。
执行完这个命令之后，你去Mac里的当前目录去找，应该会有一个brew_instal的文件。
这一步和下面一步的目的主要是因为:
官网的命令执行的太慢，我们先把官网的install脚本中的地址改为科大的镜像地址，然后再安装.
其次：打开这个文件，将BREW_REPO = "https://github.com/Homebrew/brew".freeze这句话改为BREW_REPO = "git://mirrors.ustc.edu.cn/brew.git".freeze
紧接着：在终端里执行/usr/bin/ruby ./brew_install这个命令，此时你会发现安装过程相比较之前特别的快，但是最后会报这个错误：
fatal: unable to access 'https://github.com/Homebrew/homebrew-core/': LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54
Error: Failure while executing: git clone https://github.com/Homebrew/homebrew-core /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core --depth=1
Error: Failure while executing: /usr/local/bin/brew tap homebrew/core
最后：执行下面的命令，替换源：
1.cd "$(brew --repo)"
2.git remote set-url origin git://mirrors.ustc.edu.cn/brew.git
3.cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"
4.git remote set-url origin git://mirrors.ustc.edu.cn/homebrew-core.git
默认不安装cask 有需要的可以替换(以下步骤可选)
cd "$(brew --repo)/Library/Taps/homebrew/homebrew-cask"
git remote set-url origin git://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db01b2e0378b9efff97d12b816312db3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c64bcbbf0fac7a59710656035ad8851a/" rel="bookmark">
			基于开源的Micro-RTSP，使用VLC和ffmpeg拉流播放RTSP视频流，本例使用安信可ESP32 CAM进行推流。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于开源的Micro-RTSP，使用VLC和ffmpeg拉流播放RTSP视频流，本例使用安信可ESP32 CAM进行推流。
vlc播放命令为：rtsp://192.168.43.128:8554/mjpeg/1。
ffmpeg播放命令为：ffplay rtsp://192.168.43.128:8554/mjpeg/1。
使用ESP-IDF5.0编译成功。esp-idf-v4.4.2编译不成功，有成功的小伙伴可以分享一下。
1.源码地址： git clone https://github.com/brainrecall/Micro-RTSP
2.保存源码： 保存在本地D:\Espressif\esp-idf-5.0\examples\Micro-RTSP
3.下载并保存esp32-camera库 git源码：https://github.com/espressif/esp32-camera/tree/afcb7b07272200f69373cb3ba97e3a0afc188ba2
esp32-camera库保存在目录D:\Espressif\esp-idf-5.0\examples\Micro-RTSP\examples\esp-idf\components\esp32-camera
4.使用vscode esp-idf5.0环境创建本工程 使用vscode esp-idf打开目录D:\Espressif\esp-idf-5.0\examples\Micro-RTSP\examples\esp-idf，后面工程的编辑修改都是在此目前进行
vscode工程目录如下：
5.修改文件OV2640.cpp D:\Espressif\esp-idf-5.0\examples\Micro-RTSP\src\OV2640.cpp
将下面代码注释掉：
6.修改wifi ssid和password: 7.编译下载 看到rtsp://esp32cam3.localdomain:8554/mjpeg/1代表ESP32CAM rtsp串流以及准备好了。
8.下载完成后esp32cam链接上手机ap热点 esp32cam的ip地址是192.168.43.128
9.下载安装VLC，并配置网络协议 PC中安装完vlc后，链接到同样的手机热点。并在下图中输入网络URL。
rtsp://192.168.43.128:8554/mjpeg/1
其中192.168.43.128是esp32cam的ip地址
10.大功告成： 使用ffmpeg也是可以播放的，命令为：ffplay rtsp://192.168.43.128:8554/mjpeg/1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/284ee45100d9374dcbdf04af1e586cdd/" rel="bookmark">
			Simulink代码生成： Switch模块及其代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文描述Switch模块的建模并研究生成的代码。
文章目录 1 Simulink中的Switch模块2 Switch模块建模及代码生成3 Switch模块其他用法3.1 多重Switch3.2 通过标定量Switch 4 总结 1 Simulink中的Switch模块 在Simulink中Switch模块时非常常见的，通常用于根据一定地条件选择信号进行输出，类似于C语言中的if-else语句。
Switch模块如下：
左侧有三个信号输入端口，其中中间的那个是条件端口。如果条件为真，则输出上路信号，反之则输出下路。
另外还有个MultiSwitch模块，其效果类似，只是能够切换多种输入。
本文就以Switch模块为例研究用法。
2 Switch模块建模及代码生成 本文就以Switch模块进行一个简单的建模。例如，CAN信号传来车速，车速低于30kph时判断车辆为低速，否则为高速。
1）首先拖出一个Switch模块，双击进入属性，将判断条件改成u2 ~ = 0；
这一步操作是遵循《MAAB规范》主工的 jc_0141: Use of the Switch block。该规范要求第二个端口（条件）必须是该信号不等于0，不能是大于或小于0。
2）然后把判断条件建模为车速小于30kph，Port1为LowSpeed的宏定义，Port3为HighSpeed的宏定义，如下：
模型比较容易理解，即VehSpd小于30时，输出LowSpeed，否则输出HighSpeed。
3）配置Embedded Coder并生成代码如下：
生成的代码用了一段if-else语句，其中if中的条件就是判断车速大小。
3 Switch模块其他用法 3.1 多重Switch 在Switch模块的port3可以接入其他Switch模块的输出，形成一连串Switch，例如下图：
车速小于30，对应LowSpeed；车速介于30~60，对应MiddleSpeed；否则车速大于60，对应HighSpeed；
生成代码如下：
3.2 通过标定量Switch 汽车实车测试的时候，经常通过标定量切换信号来调试。假设ADAS软件通过当前道路环境，在一系列复杂算法后得出应该向发动机请求一个扭矩（即图中的TorqueRequest）。当SwitchFlag标定为1时，将软件算出的请求值发给Engine，然后发动机进行响应。如果将SwitchTorque标定为一个工程师想要的一个自定义的数值，再将SwitchFlag标定为0，就可以发出自定义的一个扭矩请求，从而不依赖算法去调试车辆的性能。
4 总结 在Simulink中Switch模块比较简单也比较常用，需要掌握好它的用法。
&gt;&gt;返回个人博客总目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e0a32598d89045914a46a9a2b05c429/" rel="bookmark">
			Springboot传参详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介 作者名：编程界明世隐
简介：CSDN博客专家，从事软件开发多年，精通Java、JavaScript，博主也是从零开始一步步把学习成长、深知学习和积累的重要性，喜欢跟广大ADC一起打野升级，欢迎您关注，期待与您一起学习、成长、起飞！
测试工具 IDEA、postman
一、@RequestParam 针对QueryString参数传递，在请求URL中直接拼接请求参数，如URL?param1=value1&amp; param2=value2
传递基本类型参数 在接收的方法中用@RequestParam注解修饰，指定前端传递的参数名称
@RequestMapping("QueryStringTest1") public String QueryStringTest1(@RequestParam("id") String id,@RequestParam("name") String name){ return "id is "+ id+",name is "+ name; } Postman 中调用
如果传递的参数和接收的参数名一致，甚至可以省略相关配置
省略1 @RequestParam(“id”) 中的参数名id被省略
@RequestMapping("QueryStringTest2") public String QueryStringTest2(@RequestParam String id,@RequestParam String name){ return "id is "+ id+",name is "+ name; } 注意：因为有RequestParam注解的存在，所以传参必须包含所有使用RequestParam注解的接收参数，否则会报错（允许传空，但是必须包含参数）；
可以使用@RequestParam(value = “id”,required = false) 的方式，让id未传也可以。
省略2 @RequestParam 注解直接被省略
@RequestMapping("QueryStringTest3") public String QueryStringTest3(String id, String name){ return "id is "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e0a32598d89045914a46a9a2b05c429/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91150686dab894348b33b025d5c04fa8/" rel="bookmark">
			Netflix Eureka 2.0.0正式发布：借尸还魂还是虚晃一枪？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文已被https://yourbatman.cn收录；女娲Knife-Initializr工程可公开访问啦；程序员专用网盘https://wangpan.yourbatman.cn；技术专栏源代码大本营：https://github.com/yourbatman/tech-column-learning；公号后台回复“专栏列表”获取全部小而美的原创技术专栏
你好，我是YourBatman：一个俗人，贪财好色。
TitleLink所属专栏[YourBatman]-资讯/新特性，[YourBatman]-Spring技术栈新特性源代码https://github.com/yourbatman/FXP-java-ee程序员专用网盘公益上线啦，注册送1G超小容量，帮你实践做减法https://wangpan.yourbatman.cnJava开发软件包(Mac)https://wangpan.yourbatman.cn/s/rEH0 提取码：javakit女娲工程http://152.136.106.14:8761版本约定[Mac OS 13.1]，[IDEA 2022.3.1]，[Spring Boot 3.0.0] 📚前言 北京时间2022-12-14，Netflix的Eureka 2.0.0正式发布。
惊不惊喜，意不意外，Eureka 2.x闭源、停止更新似乎已成共识，突然间“借尸还魂”发布新版本？难道是虚晃一枪？先看下它们的压压惊：
Spring Boot 3.0.0正式发布，Banner不再支持图片&amp;增强可观测性Spring Boot 2.7.0正式发布，弃用从spring.factories加载自动配置类Spring Boot 2.6.0正式发布，循环引用终于被禁Spring Boot 2.5.0正式发布，环境变量可指定前缀的功能很赞Spring Boot 2.4.0正式发布，全新的配置文件加载机制Spring Boot 2.3.0正式发布：优雅停机、配置文件位置通配符 ✍正文 本文之所以聊一聊Eureka，是因为它还是有一定话题度的。换句话讲，在Spring Cloud的加持下，Eureka作为注册中心的市场占有率蛮高的，大概率还是第一名（非官方数据，笔者个人直觉而已）。
🚀真的or假的？ 这，虽然有点难以置信，但，一图胜千言：
结论：真的，毋庸置疑！！！
🚀谁在提交代码？ 继续看图：
一直提交代码的竟是Spring Cloud的作者，并非奈飞的工程师？
其实不然，Spencer Gibb确实有过不少的commit，但他绝非唯一。但他的源动力是很足的，作为Spring Cloud项目的负责人之一，也得负责将Release Train上的组件整合进来嘛。说到底，还是谁最痛，谁去推！
PS：代码肯定不会是他一个人来写（commit也有不少奈飞的工程师），但主要推手之一一定有他
🚀为什么还在维护Eureka？ 既然Netflix官方都不愿去继续发展Eureka了，为何还在持续迭代升级呢？
这其中非常重要的一个原因是：Eureka作为配置中心组件，足够优秀！！！
整体设计、表现、性能、代码水平…都属非常优秀级别无明显短板：性能可能算一个，但只要不是超大规模集群就不成问题 这里祭出各个注册中心对比图，感受下Eureka的“强悍”：
乍一看Nacos貌似完胜？但“国产软件”想要走向世界，还有一段路要走。这不体现在它是否实现的功能，而体现在实现的非功能（如文档、宣传、设计、代码水平等）。
🚀这次更新的目的是啥 结合Spring Framework、Spring Boot、Spirng Cloud的发布节点，以及上面截图中
Spring Cloud作者一直提交代码的迹象来看，本次升级的目的就显而易见了：继续拥抱Spring Cloud。这不，最新的Spring Cloud 2022已经“拥抱”它了：
本次升级的目的，Release Note上也做了说明：这个2.0.0版本是一项新的工作，和2.x-archive分支是完完全全的两码事，从代码分支里也能看出来：
本次升级，Eureka Server的Http API接口和数据结构没有任何改变。言外之意：协议层面，100%向下兼容，兼容1.x的Client客户端。所以本次升级的目的主要是：Spring Framework 6.0和Spring Boot 3.0兼容，并且拥抱Jakarta EE 9。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91150686dab894348b33b025d5c04fa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3de92e7de2753568d49f97a7de06664/" rel="bookmark">
			MySQL外键（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL外键（详解） 什么是外键： 外键是指引用另外一个表中的一列或多列数据，被引用的列应该具有主键约束或者唯一性约束（简单来说外键是另一个表的主键或者唯一约束）。外键可以有重复的, 可以是空值，用来建立和加强两个表数据之间的连接
一、主外键关系
在上图上涉及的两个表中，学生信息表 (stuInfo)为主表，学生
成绩表(score)为从表；那么主从表之间有什么关系呢？
1、当主表中没有对应的记录时，不能将记录添加到子表
--------学生成绩表中不能出现学生信息表中没有的学号
2、不能更改主表中的值而导致子表中的记录孤立
--------学生信息表中的id变化了，学生成绩表中的id也要随着发生改变
3、子表存在与主表对应的记录，不能从主表中删除该行
--------不能把部门表中的数据删除
4、删除主表前，先删子表
--------先删除成绩表、后删除学生信息表
二、外键的使用
外键的使用需要满足下列的条件： 1、两张表必须都是InnoDB表，并且它们没有临时表。
2、建立外键关系的对应列必须具有相似的InnoDB内部数据类型。
3、建立外键关系的对应列必须建立了索引。
创建外键的两种方式：
方式一：在创建表的时候进行添加
方式二：表已经创建好了，继续修改表的结构来添加外键。
在创建表的时候添加外键：
表1：
create table stuInfo(	Scode int primary key, --学生的学号 	Sname char(10), --学生的姓名 	Saddress varchar(50), --学生的住址 	Sgrade int, --学生所在班级 	Semail varchar(50), --学生的邮箱地址 	Sbrith date	)DEFAULT CHARSET='utf8';	表2：
create table score( studentID	int, coureseID int,	score int,	scoreID int primary key,	foreign	key(studentID) references stuInfo(Scode) --添加外键 ) DEFAULT charset='utf8'; 建表以后添加外键：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3de92e7de2753568d49f97a7de06664/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/179/">«</a>
	<span class="pagination__item pagination__item--current">180/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/181/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>