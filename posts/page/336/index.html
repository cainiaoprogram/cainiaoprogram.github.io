<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bdf7669ad2a68326ac95ed7012d2f40/" rel="bookmark">
			Argument of type ‘‘ is not assignable to parameter of type ‘never‘.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简而言之，言而简之，记录一下日常开发中遇到的问题；
在创建初始化数组后向数组中 push 数据的时候抛出了如下异常：
Argument of type '{}' is not assignable to parameter of type 'never'. ts 语法上的一些规范，规范强个人感觉还是很不错的，更加规规矩矩，初始化的时候完善一下定义类型就行了，具体 code 如下；
// 问题的写法 const dataSource = []; // 完善后的写法 const dataSource: any[] = []; 注：js 写惯了经常会 var，ts 的时候用 const 即可。
以上便是此次分享的全部内容，希望能对大家有所帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50b552951814f2441171471a7912c522/" rel="bookmark">
			微信原版提示音_微信消息提示音可以修改了！！赶快get起来~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近风靡抖音的微信提示音“阿dou 阿dou”
大家都刷到了嘛？
是不是分分钟被萌哭了~
测测可没有偷懒，第一时间为各位整理出来了教程，
需要注意的是，
该教程只适合IOS为12.1-12.12的系统
机型最好为6s及以上iphone才会修改成功~
测测的同事用了iphone7 ios12.1也成功了，
但部分手机会出现闪退、重启、白屏等现象，
所以各位机友一定要谨慎尝试！
快来跟着测测一起动起来~
0
1
苹果商店搜索下载“捷径”这款app
0
2
关注“评测工场”订阅号，在菜单栏输入“微信声音”获取隐藏连接
0
3
获取到限时链接后，点击“修改微信提示音”，点击右上角三个点“···”
选择Safari浏览器打开后选择下载快捷指令。
↓↓
0
4
安装完成后，打开桌面的快捷指令App，点击“修改微信提示音”，点击①安装通道，点击安装。
↓↓
安装完成后，桌面会出现“Fizaescaped12.x”的应用程序。
不要慌张~这是第三方的应用，接下来，点击iPhone中的【设置】-【通用】-【描述文件与信任管理】，选择信任操作。
接着继续在快捷指令App中打开“修改微信提示音”，选择④微信提示音。
火爆抖音的“阿dou 阿dou”铃音叫做“Kako”找到喜欢的提示音后点击左上角【完成】，之后在底部的导入提示中，点击【直接导入到 Fizaescaped 】。
之后会自动跳转到 FilzaEscaped 这个 App 中，找到 in.caf 的文件。
点击编辑后选择 in.caf，再点击下面的复制。
复制完成之后我们就点击左上角的返回，返回到不能返回就可以了。
然后依次进入 /var/containers/Bundle/微信/Application/WeChat.app 文件夹，一定要按照这个顺序哦！
当我们进入 WeChat.app 这个文件夹之后，选择左下角的这个剪贴板按钮，选择粘贴。
这时会跳出提示，选择替换就可以了。
最后我们重启微信，这样提示音就修改完成啦！
0
5
如果大家想换回之前的系统提示音，那么我们在快捷指令App中打开“修改微信提示音”，选择官方原版提示音进行替换(其余步骤一样)。
❤️
— 【 THE END 】—
图片与文字来自网络
如有侵权请联系删除
目前600000+人已关注加入我们
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3c8c8123d4a5eb448ce5f55a0fe966d/" rel="bookmark">
			将华为云/阿里云 RDS相关监控指标集成到Zabbix/Grafana中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.需求分析 1.监控需求：将云厂商的RDS数据库监控指标集成到自己公司的监控系统中 2.集成方法：调用厂商提供的API接口 3.华为云/阿里云RDS的监控指标异同 ##注意： 调用接口有如下两种认证方式，您可以选择其中一种进行认证鉴权。 Token认证：通过Token认证通用请求。 AK/SK认证：通过AK（Access Key ID）/SK（Secret Access Key）加密调用请求。推荐使用AK/SK认证，其安全性比Token认证要高。【文章采用该方式演示】 二.华为云RDS监控 1.支持的监控指标：https://support.huaweicloud.com/usermanual-rds/rds_06_0001.html mysql的dim.0=rds_cluster_id postgres 的 dim.0=postgresql_cluster_id 2.支持监控的服务列表：https://support.huaweicloud.com/api-ces/ces_03_0059.html 3.下载使用Python SDK: https://obs.cn-north-1.myhuaweicloud.com/apig-sdk/APIGW-python-sdk.zip 4.监控说明 urlhttps://support.huaweicloud.com/api-ces/ces_03_0033.html .5整理可参考性的指标： rds001_cpu_util CPU使用率 rds002_mem_util 内存使用率 rds003_iops IOPS,单位时间内系统处理的I/O请求数量（平均值）。 rds006_conn_count 数据库总连接数 rds007_conn_active_count 当前活跃连接数 rds008_qps QPS,该指标用于统计SQL语句查询次数，含存储过程，以次/秒为单位。 rds009_tps TPS,该指标用于统计事务执行次数，含提交的和回退的，以次/秒为单位。 rds039_disk_util 磁盘利用率 rds072_conn_usage 连接数使用率 rds074_slow_queries 慢日志个数统计 6.简单编写python代码main部分 # coding=utf-8 import requests import time import sys from apig_sdk import signer if __name__ == '__main__': sig = signer.Signer() # Set the **AK/SK** to sign and authenticate the request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3c8c8123d4a5eb448ce5f55a0fe966d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/511fb085f69c7a7bda152c69a10cfb76/" rel="bookmark">
			ap模式和sta模式共存_WLAN、蓝牙、ZigBee和Thread在2.4GHz频段共存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍了无线技术在2.4 GHz ISM频段运行的的共存方案。许多流行的无线技术如无线局域网(WLAN)、蓝牙、ZigBee、Thread等使用通用的2.4 GHz运行。因此，它们可能会彼此干扰，降低所有相关链路的总输送量。已知解决此类共存问题的方案包括共用通道的协作和非协作方案。我们探讨Quantenna的4线分组流量仲裁器(PTA)协作方案的详细资讯，并分析其对降低由于干扰导致性能退化的影响。视乎内置的对共存技术的保护，Quantenna的PTA可以减少一半甚至更多有问题的干扰。 前言
许多当前流行的无线通讯技术如Wi-Fi®、蓝牙[1]，ZigBee[2]、Thread等使用相同的免授权的2.4 GHz频段运行。由于通道的共用性质，这些技术在同一时频空间区域中运行时会相互干扰。视乎干扰通道强度和传输功率，这种干扰会导致相当大的性能下降。其中一些技术内置一些协议保护如载波侦听、自我调整跳频，跳频等可部分避免其他使用同一通道的技术的干扰。
图1描述了WLAN和蓝牙模组位于同一QSR10G系统单晶片(SoC)的典型共存场景。WLAN接入点和蓝牙主机共同置于QSR10G上。它显示了WLAN站(STA)的两种可能情况：STA靠近接入点时为近端情况，STA离接入点较远时为远端情况。在近端情况下，STA可以听到并置的蓝牙主设备的传输，在远端情况下，STA无法听到主设备的传输，这可同时引发WLAN RX(没有QSR10G)和蓝牙TX事件。视乎通道，在附近的WLAN STA和蓝牙从站之间的链路可能存在或不存在。对任何一条链路的干扰都可能由于不确定的网路条件由这种隐藏节点情况引起。但是，在并置于QSR10G的两种技术之间引入合作可减少某些干扰事件。例如，在给定时间限制一条链路处于活动状态。这种合作可以提高共用通道的有效性和所有相关链路的总输送量。
图1、WLAN和蓝牙用户端联接到1个QSR10G接入点(AP)的示例网络
现有的共存方案
早在这些技术的开发过程中，就意识到了潜在的干扰问题和对共存方案的需求。IEEE 802.15.2标准[3](由IEEE 802.15共存任务组2开发)解决了WLAN和WPAN网络之间的共存问题。该标准描述了推荐的做法，并提供了干扰(在802.11b和802.15.1之间)的电脑模型。该标准描述了协作方案(在发射机并置时使用)，例如：
• 交替通道接入(MAC层方案)这种方法将信标间隔分为两个部分，并且两种技术都使用了TDMA以避免干扰。• 分组流量仲裁(MAC层方案)单独的PTA块授权不同界面使用同一通道进行所有传输。PTA块根据流量负载和优先顺序来协调媒介的共用。• 确定性干扰抑制(PHY层方案)这种方法在WLAN接收器中使用可程式设计陷波滤波器来消除窄频段蓝牙干扰。
该标准还包含以下非协作方案：
• 自我调整干扰抑制(PHY层方案)此方法在WLAN接收器处使用自我调整滤波以删除窄带干扰。• 自我调整资料包选择和调度(MAC层方案)这种方法自我调整地选择资料包属性(有效载荷长度、向前纠错(FEC)码和自动重发请求(ARQ))并调度低干扰区的流量。• 自我调整跳频这种方法积极地估计并避免了通道在高干扰的WPAN处跳频。
与非协作方案相比，协作方案在正交化通道接入方面效果更好，因此降低了潜在的干扰。但是，协作方案需要在相应的共存技术之间紧密集成，并且经常会涉及到硬件或软件握手信号。
除上述技术外，跳频协作方法还可减少同时接入同一通道的机会。用这种方法，并置的无线电避免使用公用频率。例如，如果WLAN无线电正在通道1上运行，则蓝牙无线电会避开通道0-21或ZigBee无线电会避开通道11-14。
Quantenna的2线共存仲裁器
Quantenna使用基于802.15.2标准中推荐的PTA的硬件方案来实现协作共存。介面使用2线在并置的WLAN和WPAN元件之间握手，以减少同时接入公共通道的机会。图1显示了PTA模组与外部(EXT)蓝牙/ZigBee/Thread模组之间的介面信号。
图2、Quantenna的在QSR10G PTA和外部模组之间的4线介面
图1所示的不同信号的含义和运行如下：
1. REQUEST - 这是输入到PTA模块的输入信号，指示来自外部模组的请求正在请求接入道。2. GRANT - 这是输出到外部模块的输出信号，指示外部模组是否被授予接入该通道的许可权。当外部模组发送请求信号时，该信号有效，WLAN既不接收也不发送帧。
当WLAN必须传输时，它会检查是否已授予外部模组存取权限。如果外部模块正在接入该通道，则WLAN会一直等到取消授予权限后再进行传输。在正常模式下，当WLAN正在发送或接收时，来自EXT模组的任何请求都会被拒绝。当EXT模组必须发送帧时，它发送一个REQUEST并等待获得GRANT后再发送。当EXT模块接收到一个帧时，它将发送一个REQUEST并继续接收该帧，而不受GRANT信号影响。
除了上面提到的2线模式之外，上述介面还可以以1线模式运行。在1线模式下，PTA模块的唯一输出是Grant信号。在此模式下，Grant信号用作WLAN繁忙的指示。当WLAN不使用通道时，PTA会取消授权Grant信号。
TX/RX事件的顺序(WLAN TX，WLAN RX，EXT TX或EXT RX)可能导致不同的工作或干扰情况。图3显示了一个示例，在进行蓝牙传输时接收到WLAN帧。如果将WLAN帧发送到接入点的STA距离很远，因此无法以较低功率听到蓝牙传输(如图1所示)，则会出现这种情况。
表1列出了当使用2线PTA介面减少WLAN和EXT模组之间的干扰时TX/RX事件的所有可能顺序及其影响。枚举忽略了当通道处于空闲状态并且只有一个介面具有TX/RX事件而另一个介面处于空闲状态时的情况。
Time：时间
图3、在正在进行的BT TX事件中间发生WLAN RX事件的示例
请注意，在隐藏节点的情况下(当WLAN STA和/或EXT从站无法听到发送器时)，一条链路上接收帧，同时另一条链路上正在进行传输是不可避免的。
表1
第1事件第2事件行为结果(接入点)1EXT TXWLAN TX等待直到REQ被取消授权WLAN TX延迟2EXT TXWLAN RX继续WLAN RX。BT TX可能会或可能不会停止，取决于其模式WLAN干扰或资料包丢失3EXT RXWLAN TX等待直到REQ被取消授权WLAN TX延迟4EXT RXWLAN RX继续WLAN RX。BT发送REQ，两者继续接收。EXT和WLAN干扰或资料包丢失5WLAN TXEXT TXBT发送一个REQ并等待GNT。PTA然后等待WLAN TX完成授权GNT。BT或延迟TX或完全错过视窗并不得不重复。EXT TX延迟6WLAN TXEXT RXWLAN不会停止。BT发送REQ并继续接收。EXT干扰或资料包丢失7WLAN RXEXT TXBT发送一个REQ并等待GNT。PTA等待WLAN RX完成授权GNT。BT或延迟TX或完全错过视窗并不得不重复。EXT TX延迟8WLAN RXEXT RXWLAN不会停止。BT发送REQ并继续接收。EXT和WLAN干扰或资料包丢失 注意：TX/RX事件的顺序及其对采用4线方案的共存介面的影响。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/511fb085f69c7a7bda152c69a10cfb76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1dbc0e609cb04d44198b25a4c4569a1/" rel="bookmark">
			信号处理：常见信号仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 二进制振幅键控 BASK e B A S K = { A sin ⁡ 2 π f c t 1 0 0 e_{\rm{BASK}}=\left\lbrace \begin{array}{cl} A\sin2\pi f_c t &amp; 1 \\ 0 &amp; 0 \end{array}\right. eBASK​={Asin2πfc​t0​10​
仿真：码元数 P = 10 P=10 P=10，仿真周期 T = 10 s T=10\mathrm{s} T=10s，载频 f c = 5 H z f_c=5\mathrm{Hz} fc​=5Hz。
信号产生过程 数字基带信号：
载波信号：
BASK信号：
频谱：
信号解调过程 加入噪声：
与载波相乘：
低通滤波输出：
抽样判决器输出：
2. 二进制频移键控 BFSK e B F S K = { A sin ⁡ 2 π f c 1 t 1 A sin ⁡ 2 π f c 2 t 0 e_{\rm{BFSK}}=\left\lbrace \begin{array}{cl} A\sin2\pi f_{c1} t &amp; 1 \\ A\sin2\pi f_{c2} t &amp; 0 \end{array}\right.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1dbc0e609cb04d44198b25a4c4569a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42532f046a5cc3af37bc60108532dc30/" rel="bookmark">
			噪音 扫地机器人 楼下_石头扫地机器人T7使用体验，你们看到底值不值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人是罗永浩的忠粉，整个大学是听着他的相声度过的。他做英语培训我报班学英语，他做锤子手机我买手机，如今老罗转战直播，基本上他推荐什么我就买什么，不为别的，就为了支持老罗，交个朋友。4月份，老罗直播推荐了T7石头扫地机器人，家里正好缺一个果断下手，谁让咱也是宠妻狂魔呢！
没想到机器用了十几天，就被老婆疯狂吐槽，咯吱咯吱开始异响，噪音还算再能忍受的范围内，至少说楼下的邻居没有找上来，说的好静音功能静是个坑。主打的卖点智能也是非常打脸，天天在家里横冲直撞，连个地毯都上不去，还需要我助一臂之力，说的牛逼算法也真是人算不如天算！
但这些我也就忍了，要命的把家里的地板还弄出来一个划痕，就这被媳妇喷了好几次，就像我刚买这扫地机器人跟她喷有多厉害一样。
续航能力什么的就不用说了，虽然达不到宣传上说的牛逼程度，还是可以接受的。以上是我的个人使用体验，可能是今年本命年比较败人品，摊上了个有问题的机器。本来不想说什么的，但毕竟接近3千大洋的东西，不吐不快，只是希望准备入手的小白，可以多个品牌研究后选择入手，毕竟智商税这东西还是能省就省吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa9ca8e8b056c747be98bd8d23a4b7d9/" rel="bookmark">
			PMP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线教材：
http://hellokittycn.com/chapter/526
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cbb6959f5cec1a1be045873af8e5625/" rel="bookmark">
			Brinson归因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章参考
http://www.doc88.com/p-8039993862334.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e055e97cf78ffba18c3c755efb00471f/" rel="bookmark">
			心电图心电轴怎么计算_心电图part1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 心电图part1
土土的白话整理的心电图的笔记（初稿），凑合看吧。
1、 复习一下概念
心肌细胞的四种特性：自律性、节律性、传导性、收缩性。窦房结是自律性最高的起搏点，内有许多有自律节律性的细胞，从窦房结发出纤维束分布于心房的肌肉支配其收缩。其实这里的房室结其实是一个中转站，房室结再往下延续就是左右束支，病理状态下发生阻滞，左边多于右边。比如左束新发阻滞，你就要分析患者既往是否有高血压，心肌出现急性的缺血缺氧，这时需要高度注意并分析心电图胸导联（就是V1-V6，特殊情况加到V9）找出缺血的部位。从窦房结到房室结是PR间期，这部分发生阻滞是房室传导阻滞。
2、 复习几个概念，
电偶：1个心肌细胞产生的心电向量；
心电向量：几个及一片心肌细胞产生的心电向量；
心电轴（这个很重要）：整个心肌产生的心电向量，我理解的就向高中物理学过的一样，所有的向量计算的总和后汇聚成一个向量一个方向，那么这就是你的心电轴。如果心电轴的电量传输方向和电极方向相同就是正向，如果相反就是负向。V1-v6是在水平方向测量（就是解剖位置的横断面），电极片放的部分是正极，负极在心脏中心。
3、 1导的负极在右手，正在左手，2导负在右手，2正在左脚，3导负在左手，3正在左脚。（这三个导联不好记，凑合记吧，这个1，2，3应该是罗马数字，我简化了）Avr正在右手，avL正在左手,avf正在脚，你看最后一个字母，right、left，foot.
4、2导方向从右上到坐下，心电轴就是从右上到左下。所以看就看2导。1导加3导等于2导，不信你自己加P波值算一下。肢体导联采冠状面。当心脏放电的方向背离电极是负向波，向着电极正向波，心脏正好除极波形有上有下，这个上下正负都是围绕基线来得。
5、 这个波形怎么出来的，它对应的是心脏收缩的一刹那，窦房结先放电，心房收缩挤血到心室，这个圆而钝P波就是心房挤血的一刹那产生的，PR间期是挤完血往心室传导的一刹那到房室结，房室结开始放电心室开始收缩产生QRS波，后面还可以产生t波，是心室复极的过程。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bc8e6f8c20363e27bd86b9b86000ee5/" rel="bookmark">
			三阶魔方大中小魔公式_二至七阶大中小魔
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hi～新朋友，记得关注我们哟
众所周知，大中小魔(又称魔中魔)是正阶魔方中最为经典的花式了，通过不断翻转循环交换三个相邻面的各块，形成一层套一层循环往复的颜色，具有极大的观赏性。
三阶是一切的基础，首先来讲解三阶大中小魔。三阶大中小魔是有公式的，例如下面这条公式：F D2 L2 B D B' F2 U' F U F2 U2 F' L D F' U。但是对于公式都要背到吐血的魔友们来说，一个花式的公式会去背才怪呢(bushi)。那么今天我们来讲解的大中小魔教程中使用的公式，都是我们之前学习过的，如果还不会的话，翻翻之前的推送去面壁思过
首先我们做一个构造y F R，使得我们要交换的UF FR UR棱块处于同一平面内，接着做U-(perm)，最后reverse R' F' y'，这样UF FR UR棱块就完成了一次交换。我们再做x2 y'翻到背面，仍然做前面的步骤，只不过把U-(perm)换成U+(perm)。接着翻回来，做换心公式M E' M' E。最后为了美观，我们调整一下UFR和DBL角块的朝向，得到一个颜色循环，即从侧面看，每三条中不会有重复的颜色，这在高阶上会显现得更加明显。
其他阶数的大中小魔使用的仍然是上述套路，只不过翻转、交换的次数不同，某些步骤中转动层数会有一些变化。详情请点击下方视频，观看《二至七阶大中小魔》视频教程。
Ps：视频中表示高阶翻角中，出现了“UwFwRw”“DwBwLw”等诸如此类表达方式。这种表达方式有可能不够标准，只是为了让魔友们更容易理解。魔友们如有更简便准确的表达方式，请在后台留言。
编辑｜silly girl
视频｜图文｜晓城大毓
cuicube，让魔方成为一种生活～
点“在看”给我一朵小黄花
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22fdf2c4be272c0d9577b64b92d40cc1/" rel="bookmark">
			python学习笔记-11.函数参数和返回值进阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 函数参数和返回值的作用 函数根据有没有参数以及有没有返回值，可以相互组合，共有4种形式：
无参数，无返回值无参数，有返回值有参数，无返回值有参数，有返回值 定义函数时，是否接收参数，或者是否返回结果，是根据实际的功能需求决定的。
如果函数内部处理的数据不确定，就可以将外界的数据以参数传递到函数内部。如果希望一个函数执行完成后，向外界汇报执行结果，就可以增加函数的返回值。
2. 函数的返回值进阶 问题：一个函数执行后能否返回多个结果？
元组-可以包含多个数据，因此可以使用元组让函数一次返回多个值；如果函数返回的类型是元组，小括号可以省略；如果函数返回的类型是元组，同时希望单独处理元组种的元素，可以使用多个变量，一次接收函数的返回结果；
注意，使用多个变量接收结果时，变量的个数应和元组中元素的个数保持一致。 举个栗子
# 测量温度和湿度 def measure(): print("测量开始") temp = 39 wet = 56 print("测量结束") return temp,wet # 返回的数据类型为元组，可省略'()' gl_temp, gl_wet = measure() # 定义两个变量接收返回的结果 print(gl_temp) output：
测量开始
测量结束
39
56
举个栗子-交换数字（经典面试题）
在不使用其他变量的情况下，交换a和b的值。
a = 6 b = 100 a,b = b,a # python专有，利用元组。等号右边是一个元组，只是把小括号省略了 print(a) print(b) output：
100
6
3. 函数的参数进阶 3.1 不可变和可变的参数 问题1：在函数内部，针对参数使用赋值语句，会不会影响调用函数时传递的实参变量？——不会！
无论传递的参数是可变还是不可变，只要针对参数使用赋值语句，会在函数内部修改局部变量的引用，不会影响到外部变量的引用。 举个栗子
def demo(num,num_list): print("函数内部的代码") # 在函数内部，针对参数使用赋值语句 num = 100 # 不可变的参数 num_list = [1,2,3] # 可变的参数 print(num) print(num_list) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22fdf2c4be272c0d9577b64b92d40cc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7f5837b04016751c5118e4dc1d0b8a7/" rel="bookmark">
			ANR 最佳实战 之 该如何分析？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、ANR 简介2、ANR 的类型3、watchdog 在负责监控是否发生了 ANR4、ANR 问题分析 "套路"5、ANR 分析实战实例一：主线程进行耗时操作，或被进程内其它线程阻塞实例二：应用内部线程逻辑依赖关系导致超时实例三：系统内存过低，kernel进行内存交换过程会引起整个系统运行缓慢(卡顿)实例四：Binder资源耗尽，导致通信难以及时响应实例五：高CPU过度抢占时间片，导致其它应用或任务难以及时调度实例六：日志不全，缺少Trace或其它日志 综述：参考资料 整理自：徐磊在2017年的技术分享。
ANR问题，相信是每位开发日常都会遇到的问题，对于这类问题的分析，按照官方的推荐，或网络博客的总结思路，能解决一定的问题，但是多数时候大家的困惑就是：应用逻辑很简单，耗时很短或应用堆栈完全正常，又或者处于空闲状态，可系统为什么就认为接收者发生ANR了呢？
下面我就从下面几个实例，从不同角度分析导致ANR产生的Root Case。也希望对大家以后分析该类问题有一定参考价值。
1、ANR 简介 ANR 全称呼为：Application Not Responding 的简写。
Android 系统对于一些事件需要在一定的时间范围内处理完成，如果超过预定时间能未能得到有效响应或者响应时间过长，都会造成 ANR。一般而言，这时往往会弹出一个提示框，告知用户当前 xxx 程序未响应，用户可选择继续等待或者 Force Close。
2、ANR 的类型 1、Service Timeout: service 在 20s 内未执行完成;2、BroadcastQueue Timeout：比如前台广播在 10s 内执行完成3、ContentProvider Timeout：内容提供者执行超时4、inputDispatching Timeout：输入事件分发超时 5s，包括按键分发事件的超时。 3、watchdog 在负责监控是否发生了 ANR Android 系统的 watchdog 是用来监控系统进程的。System server 运行起来的时候，会创建一个 watchdog 的线程，每隔一段时间调用 ActivityManagerService、WindowManagerService、 PowerMangerService 中的 monitor() 函数，以此来监听这些关键服务进程是否执行超时或者死锁。如果死锁超过一分钟，则会 kill 对应进程，并重启 system server.
以 ActivityManagerService 为例:
/** In this method we try to acquire our lock to make sure that we have not deadlocked */ public void monitor() { synchronized (this) { } } ANR 和 watchdog 触发的时候，都会生成 traces.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7f5837b04016751c5118e4dc1d0b8a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8729ec731231387d0a5fa740cb3bb170/" rel="bookmark">
			STM32的PWM和DAC练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32的PWM和DAC练习 相关简介一、用STM32F103输出一路PWM波形二、用STM32F103的DAC功能完成波形输出（一）DAC简介（二）输出一个周期2khz的正弦波（三）将一段数字音频歌曲数据转换为模拟音频波形输出 三、总结 相关简介 PWM是 Pulse Width Modulation 的缩写，中文意思就是脉冲宽度调 制，简称脉宽调制。它是利用微处理器的数字输出来对模拟电路进行控 制的一种非常有效的技术，其控制简单、灵活和动态响应好等优点而成 为电力电子技术最广泛应用的控制方式，其应用领域包括测量，通信， 功率控制与变换，电动机控制、伺服控制、调光、开关电源，甚至某些 音频放大器，因此学习PWM具有十分重要的现实意义。 其实我们也可以这样理解，PWM是一种对模拟信号电平进行数字编码 的方法。通过高分辨率计数器的使用，方波的占空比被调制用来对一个 具体模拟信号的电平进行编码。PWM 信号仍然是数字的，因为在给定的 任何时刻，满幅值的直流供电要么完全有(ON)，要么完全无(OFF)。电压 或电流源是以一种通(ON)或断(OFF)的重复脉冲序列被加到模拟负载上去 的。通的时候即是直流供电被加到负载上的时候，断的时候即是供电被 断开的时候。只要带宽足够，任何模拟值都可以使用 PWM 进行编码。
一、用STM32F103输出一路PWM波形 1.找到野火提供的官方资料，并且打开。
2.主函数代码：
#include "stm32f10x.h" #include "bsp_led.h" #include "bsp_AdvanceTim.h" int main(void) {	ADVANCE_TIM_Init(); while(1) { } } 3.通过主函数查看相关函数代码。
4.相关函数代码：
static void ADVANCE_TIM_GPIO_Config(void) { GPIO_InitTypeDef GPIO_InitStructure; // Êä³ö±È½ÏÍ¨µÀ GPIO ³õÊ¼»¯ RCC_APB2PeriphClockCmd(ADVANCE_TIM_CH1_GPIO_CLK, ENABLE); GPIO_InitStructure.GPIO_Pin = ADVANCE_TIM_CH1_PIN; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(ADVANCE_TIM_CH1_PORT, &amp;GPIO_InitStructure); // Êä³ö±È½ÏÍ¨µÀ»¥²¹Í¨µÀ GPIO ³õÊ¼»¯ RCC_APB2PeriphClockCmd(ADVANCE_TIM_CH1N_GPIO_CLK, ENABLE); GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8729ec731231387d0a5fa740cb3bb170/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d08a89fe08c32249c19bfd089a7c121/" rel="bookmark">
			设计模式之依赖倒置设计原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		周末在看《深入理解Java虚拟机》，其中有关于Java虚拟机部分的描述，忽然来了灵感，感觉可以从这个角度来阐述 依赖倒置 设计原则。
最初接触 依赖倒置，是在《HeadFirst设计模式》这本书中，此后，每当业务重构或者开始一个新项目，我都会先翻一翻这本书，常读常新，每次也都会有新的体悟。
一、破题 - Java虚拟机规范和语言规范 Java 在刚刚诞生之时曾经提出过一个非常著名的宣传口号：“一次编写，到处运行”。“与平台无关” 的理想最终实现在操作系统的应用层上：Sun公司以及其他虚拟机提供商发布了许多可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的 “一次编写，到处运行”。各种不同平台的虚拟机与所有操作系统平台都使用同一程序存储格式–字节码(ByteCode)，这也是平台无关性的基石。
有了Java语言，程序员就可以忽略具体操作系统平台(Win、Mac、Linux等)、忽略特定硬件底层指令集(x86、ARM等)，只需要关注Java语言规范，就可以“一次编写，到处运行”。
二、编程思维的依赖倒置 2.1、在 Java 语言出来之前： 程序员需要依赖特定操作系统来完成具体的工作。例如：绘制一个圆，需要调用不同操作系统的GUI绘制库来完成，库的名称以及API接口是不同的，都需要在代码中具体适配。
从依赖关系来看，高层 的应用程序，依赖 低层 的操作系统绘制库。
每当新增一个运行平台，就是在新增依赖一个绘制库。另外，后续该绘制库API改变了或者有了调整，高层的应用程序也需要跟着调整。
2.2、在 Java 语言出来之后： 程序员只需依赖 Java语言规范 即可完成具体的工作，不需要关心平台。例如：绘制一个圆，调用 Java GUI 库的API，Java 虚拟机会与特定的操作系统平台对接，绘制一个圆。
再去看依赖关系，高层 的应用程序，依赖 Java虚拟机或者语言规范，低层组件也依赖Java虚拟机或者语言规范完成功能对接。
每当新增一个运行平台，只要该平台支持 Java虚拟机或者语言规范 ，就什么都没有发生改变，后续该平台绘制库API改变了或者有了调整，高层的应用程序亦不需要跟着调整。
在Java语言出现的前后，程序编写的思维方式也跟着发生了改变。从 高层组件 依赖 低层组件，到 高层组件 和 低层组件 都依赖于 抽象，这里的 抽象 就是 Java虚拟机或者语言规范，或者说 Java 虚拟机 。
三、这和我们的依赖倒置设计原则有什么关系呢？ 其实，上面的开发思维就是“依赖倒置”设计原则，依赖倒置设计原则有如下几种不同的说法：
要依赖抽象，不要依赖具体类针对接口编程，不针对实现编程。不能让高层组件依赖低层组件，两者都应该依赖于抽象。 刚刚接触这个设计模式时，最困惑的莫过于：依赖倒置原则，究竟倒置在哪里？
依赖倒置设计原则中的“倒置”指的是和一般的面向对象的思考方法完全相反。正常思维，先从顶端设计开始，然后往下到具体的低层类设计。依赖倒置设计原则要求我们先别从顶层开始，而是先看看能“抽象化”些什么。
总结 实际的案例中，完美应用依赖倒置设计原则非常难，尤其是新业务的工程架构设计，往往业务稳定铺开一段时间之后，抽象模型才会慢慢变得“清晰”。
更普遍的场景往往是，新需求无法在旧业务架构实现中迭代，不得不做架构设计调整(架构调整的第一目标就是调整前后，业务效果要一模一样，对用户来讲要像什么都没发生过一样。由于不产生新的增量，不到万不得已，不会做架构调整的）。
踩过坑，才会体会依赖倒置的强大，不说了，说多了都是眼泪。
参考资料 Head First 设计模式（中文版）-- [美] 弗里曼（Freeman，E）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d08a89fe08c32249c19bfd089a7c121/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2db5ea5d4e6d6163c50105130c09f807/" rel="bookmark">
			Kotlin 实战经验中的那些坑&#43;最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		确认过眼神，遇上对的人；确认过“坑”点，遇上对的 kotlin
Num 1：方法入参是常量，不可修改 在Kotlin中，参数是常量，这一点可能让 Java 程序员的思维范式有点不太适应。
class Main { /** * Kotlin 入参是常量 */ fun print(a: Int = 1, b: String = "") { // a = 10; // 错误：Val cannot be reassigned!!! } } Num 2：不想要 Companion、INSTANCE关键字？ Java 访问 Kotlin 中定义的静态变量以及静态方法，需要 Companion关键字。例如：
// Main.kt class Main { companion object { val EMPTY = "" fun isEmpty(string: String = EMPTY) { //todo code } @JvmField val FULL_NUMBER = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2db5ea5d4e6d6163c50105130c09f807/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ddc6a992d8143bc540fd09674596f41/" rel="bookmark">
			深入理解Java虚拟机高级特性与最佳实践 - 全国统一考试试卷(下)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文整理自 深入理解Java虚拟机：JVM高级特性与最佳实践 – 周志明
第三部分 高效并发 物理机对并发的处理方案对于虚拟机的并发实现有相当大的参考意义。计算机的存储设备的运算速度与处理器的运算速度，有几个数量级的差距，所以现代计算机系统不得不加入一层读写速度尽可能接近处理器运算速度的高度缓存(Cache)来作为内存与处理器之间的缓冲。
工作原理如下：
将运算需要使用到的数据复制到缓存中，让运算能够快速进行运算结束后，再从缓存同步回内存之中。 Num 1：缓存一致性 在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存(Main Memory)。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，如果真出现此情况，那同步到主内存的数据以谁的缓存数据为准呢？为了解决这个缓存一致性的问题，需要各个处理器读写访问缓存时按照协议约定进行操作。这些协议包括但不限于：MSI、MESI、MOSI、Synapse、Firefly及Dragon Protocol等。不同架构下的物理机器使用不一样的缓存一致性协议，也就拥有不一样的内存模型。
Num 2：Java 内存模型的由来 C/C++：直接使用物理硬件和操作系统的内存模型。由于不同操作系统平台上内存模型的差异，因此，运行结果也不同。
Java：Java虚拟机试图定义一种内存模型规范来屏蔽各种硬件、操作系统的内存访问差异，以实现让Java程序在各种平台上，都能达到一致的内存访问效果。
问题 1 Java 内存模型的英文简称是： 1 。
A：Java Working Memory,JWMB：Java Main Memory,JMMC ：Java Memory Model,JMM Num 3：Java 内存模型 Java 内存模型的主要目标是定义程序中各变量的访问规则，即：在虚拟机中，将变量存储到内存和从内存中取出变量(这里的变量包括了：实例字段、静态字段、构成数组的元素。不包括：局部变量与方法参数，因为这些属于线程私有的，不会被共享，也不存在竞争问题)。
问题 2 Java 内存模型规定了所有的变量都存储在 1 中，每条线程都有自己的工作内存(Working Memory，类比：Num 1：缓存一致性中的高速缓存)。线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取/写入等)，都必须在工作内存中，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。线程、主内存、工作内存三者的交互关系如下：
A：高速缓存B：工作内存(Working Memory，类比：Num 1：缓存一致性中的高速缓存)C：主内存(Main Memory，类比：Num 1：缓存一致性中的主内存) Num 4：内存间交互操作 Java 内存模型中定义了8中操作来完成主内存和工作内存之间具体的交互协议。虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。
lock(锁定)：作用于主内存的变量，把一个变量比欧式为一条线程独占的状态。unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。read(读取)：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。load(载入)：作用于工作内存的变量，把read操作从主内存得到的变量值放入工作内存的变量副本中。use(使用)：作用于工作内存的变量，把工作内存中的一个变量的值传递给执行引擎。assign(赋值)：作用于工作内存的变量，当虚拟机遇到一个给变量赋值的字节码指令时，把一个从执行引擎接收到的值赋给工作内存的变量store(存储)：作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。write(写入)：作用于主内存，把store操作从工作内存中得到的变量的值放入主内存的变量中。 long 和 double型变量的特殊规则 java 内存模型要求上述8种操作具有原子性，但对于64位的数据类型(long和double)，特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，
问题 3 如果要把一个变量从主内存复制到工作内存，顺序执行： 1 A：lock -&gt; unlockB：unlock -&gt; readC：read -&gt; load 问题 4 如果要把一个变量从工作内存复制到主内存，顺序执行： 1 A：use -&gt; assignB：assign -&gt; storeC：store -&gt; write Num 5：Volatile 型变量 关键字volatile可以说是虚拟机提供的最轻量级的同步机制，Java 内存模型对volatile专门定义了一些特殊的访问规则。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ddc6a992d8143bc540fd09674596f41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea81cc4be9752fef7f1d1fc499800dee/" rel="bookmark">
			python学习笔记-9.高级变量5-公共方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5. 公共方法 5.1 python内置函数 len() 计算容器中元素的个数del() 删除变量max() 返回容器中元素的最大值，如果是字典，只比较key值min() 返回容器中元素的最小值cmp(item1,item2) 比较两个值。python3x取消了cmp函数，可以用比较运算符进行比较，字典无法进行比较。
– 字符串比较符合以下规则： “0” &lt; “A” &lt; “a” 5.2 切片 切片使用索引值来限定范围，从一个大的字符串切出小的字符串。列表和元组都是有序的集合，都能够通过索引值获取到对应的数据。字典是一个无序的集合，是使用键值对保存数据，无法使用切片。 5.3 运算符 + 合并，支持字符串、列表、元组 （extend与append有相似的作用。） num_list1 = [1,2] num_list2 = [3,4] print(num_list1+num_list2) # 输出一个新的列表变量 output：
[1, 2, 3, 4]
* 重复，支持字符串、列表、元组 num_list1 = [1,2] print(num_list1*3) output：
[1, 2, 1, 2, 1, 2]
成员运算符
– in 元素是否存在，支持字符串、列表、元组、字典（key值）
– not in 元素是否不存在 num_list1 = [1,2] print(3 in num_list1) output:
False
5.4 for循环 语法格式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea81cc4be9752fef7f1d1fc499800dee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67dee22a19cb4cb18dbf4b574c5de21c/" rel="bookmark">
			java当前时间转化毫秒_Java学习笔记day08
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Object类
java.lang.Object
类Object是类层次结构的根类
每个类都使用Object作为 超(父)类
所有对象（包括数组）都实现这个类的方法
Object类的toString方法
任何一个类都是从Object类继承下来的，因此在任何一个类里面都可以重写这个toString()方法。toString()方法的作用是当一个引用对象和字符串作连接的时候，或者是直接打印这个引用对象的时侯，这个引用对象都会自动调用toString()方法，通过这个方法返回一个表示引用对象自己正常信息的字符串，而这个字符串的内容由我们自己去定义，默认的字符串内容是“类名+哈希编码”
Object类的equals方法
Person类默认继承了Object类，所以使用Object类的equals方法
boolean equals(Object obj) 指示其他某个对象是否与此对象相等
equals方法源码：
public boolean equals(Object obj) {
return (this == obj);
}
参数：
Object obj;可以传递任意的对象
== 比较运算符，返回的是一个布尔值 true false
基本数据类型：比较的是值
引用数据类型：比较的是两个对象的地址值
this是谁？哪个对象调用的方法，方法中的this就是那个对象：p1调用的equals方法所以this就是p1
obj：传递过来的参数p2
this == obj --&gt;p1 == p2毫秒值
java.util.Date:表示日期和时间的类
类 Date 表示特定的瞬间，精确到毫秒
毫秒：千分之一秒 1000毫秒=1秒
毫秒值作用：可以对时间进行计算
把日期转换为毫秒：
当前的日期：2088-01-01
时间原点（0毫秒）：1970-01-01 00:00:00
就是计算当前日期到时间远点之间一共经历了多少毫秒
Date类的构造方法和成员方法
import java.util.Date; public class Demo02Date { public static void main(String[] args) { demo01(); demo02(); demo03(); } /* long getTime() 把日期转换成为毫秒值（相当于currentTimeMillis()） 返回自1970.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67dee22a19cb4cb18dbf4b574c5de21c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a18ffd190892c75bdc5c0c22086970d9/" rel="bookmark">
			西门子ug通用后处理_优胜PM2017PM2021_三轴通用后处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个后处理就够了，PM2017-PM2020版本通用，不用安装老版本1610后处理器，简单设置即可保存为发那科、三菱、新代、法格、西门子等系统手动和自动换刀后处理2020.05.20 更新，简化了操作2020.05.29 更新，优化攻牙输出(三菱F=节距，发那科F=S*节距，刚性攻牙输出Q)2020.06.15 更新，Fagor系统优化2020.06.26 更新，修复一处逻辑错误2020.07.23 更新，优化参数
后处理如需修改，点“
优胜PM2017-PM2021_三轴通用后处理 一、从开始菜单打开PM后处理构造器Manufacturing Post Processor Utility 2017 (64-bit)，初始参数设置如下 二、支持G54-G59坐标输出，不重复输出相同坐标，默认坐标输出G54可修改(夹具偏置不设置) 三、刀补输出设置 四、攻丝不输出Q，刚性攻丝输出啄孔深度Q &gt;&gt;优胜模具培训学校小程序
&gt;&gt;优胜中国模具资料网小程序
&gt;&gt;优胜引进科德高端精密五轴数控实习机床
&gt;&gt;优胜史老师著《Moldflow模流分析实例教程》
&gt;&gt;优胜原创UG_3-4-5轴后处理下载
&gt;&gt;优胜原创PM_3-4-5轴后处理下载
&gt;&gt;大国工匠-“分毫不差”的导弹部件精雕师
热门文章
免费为网友提供技术服务
免费为企业输送人才服务
←加小编微信，进优胜技术交流群
点“
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d383fbb1a54a41b0a290360438b110b/" rel="bookmark">
			三层交换机与路由器对接上网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		~交换机作为用户网关，实现跨网段转发。同时作为DHCP服务器，为用户分配IP地址。
~路由器通过NAT转换，使用户可以访问外网。
~路由器R2 GE0/0/0接口作为外网地址
交换机配置：
路由器配置：
//PC1上查看IP获取情况
PC1 ping 测试外网200.0.0.1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c699b307f9108aeab509292416adba8b/" rel="bookmark">
			linux 查看文件系统 的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. df -T -h
2. cat /etc/fstab file system table
[root@localhost test1]# df -T -h 文件系统 类型 容量 已用 可用 已用% 挂载点 /dev/mapper/centos-root xfs 10G 2.2G 7.9G 22% / devtmpfs devtmpfs 901M 0 901M 0% /dev tmpfs tmpfs 912M 0 912M 0% /dev/shm tmpfs tmpfs 912M 8.8M 903M 1% /run tmpfs tmpfs 912M 0 912M 0% /sys/fs/cgroup /dev/sdb5 ext4 2.0G 6.0M 1.8G 1% /disk5 /dev/sdb1 ext4 2.0G 6.0M 1.8G 1% /disk1 /dev/sda1 xfs 197M 123M 75M 63% /boot tmpfs tmpfs 183M 0 183M 0% /run/user/0 tmpfs tmpfs 183M 0 183M 0% /run/user/1000 tmpfs tmpfs 183M 0 183M 0% /run/user/1001 [root@localhost test1]# cat /etc/fstab # # /etc/fstab # Created by anaconda on Fri Nov 20 22:18:54 2020 # # Accessible filesystems, by reference, are maintained under '/dev/disk' # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info # /dev/mapper/centos-root / xfs defaults 0 0 UUID=dd5dc158-66a3-4610-ace2-d302d8e6fd87 /boot xfs defaults 0 0 /dev/mapper/centos-swap swap swap defaults 0 0 /dev/sdb1	/disk1	ext4	defaults	1 2 /dev/sdb5	/disk5 ext4	defaults	1 2 /dev/sdb6	swap	swap	defaults	0 0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cf46b2a1f4ca8e0c2d312a5f8557ea5/" rel="bookmark">
			cpu过剩是什么意思_电脑硬件小白进阶篇：教你认识CPU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇小白向导，老哥尽量比喻让小白知道
什么是CPU
CPU的命名
这玩意咋干活的
大家都容易对CPU产生什么样的误区
接下来让我们
首先啥是CPU呢？
你可以说相当于是汽车的发动机
能跑多快取决于CPU
也可以说相当于人类大脑
你的计算能力相当于爱因斯坦还是麦兜
也取决于它
所以我想告诉之前问我这玩意太贵配电脑不按CPU行不行的人
也行！
买张显卡躺床上嘴里叼着脑补游戏
保证绝地求生次次吃鸡
英雄联盟把把VIP
Intel和AMD
所以只要是电脑CPU都是正规厂商出产的
不会出现路边小作坊生产CPU这种情况
(有这样的小作坊国家早就大力扶持或者收购了 还能打着科学院的名头)
那CPU不会买到假冒伪劣的就不会被骗了嘛？
这其中的猫腻我们后面再谈
好多小白一看到CPU的名字一脸懵逼
看到I3 I5 I7还大致知道啥意思
到了AMD的R5？？这个A8什么意思？？奥迪A8？
后面的数字啥玩意？？有的还带着字母？？
这都是啥？啥？啥？？？
首先呢，我们要先知道CPU的命名规则
以Intel为例
CPU分也为高中低端，
最低端的是G系列，其次是低端I3系列，然后是中端I5系列，高端I7系列和至尊I9系列。
这个系列就像宝马车的三系五系七系一样！
而不是I3出完出I5，I5出完出I7，然后是I9、I12、I15……
可能是小白以为CPU跟手机更新一样3GS、4、4S、5、5S……
不是的！！！
Intel的命名可不止就是I3 I5 I7，他后面还是有另外一串数字的，比如常见的I7 8700K，I5 8400，I7 7700HQ，I3 8100，I3 I5 I7只是代表了他属于哪一个定位的产品
所以现在我们清楚了一件事，I3 I5 I7只是代表CPU中高低端产品线
而不是具体的产品型号
那后面的数字字母是嘛意思呢？
别急！听我说
这竹板这么一打啊
别的咱不夸
夸一夸这因特尔的赛屁油顶呱呱
I3和I5啊
那只是产品线
后面的数字字母跟着到底是为点嘛？
好了好了
好了好了
以我用的CPU为例子吧
Intel core I5 9400F
然后我拆分一下大致的标注出来
抛开厂商品牌不谈
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cf46b2a1f4ca8e0c2d312a5f8557ea5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf76469f5706a1c44f1d24c30fe50fa1/" rel="bookmark">
			计算机网络（期末复习第4章）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人博客排版更舒适，建议点击跳转
一、网络层提供的两种服务方式及特点（面向连接服务和无连接服务）
网络负责可靠交付：
模仿电信网络，使用面向连接的通信方式。
通信之前先建立虚电路，以保证双方通信所需的一切网络资源再使用可靠传输的网络协议，使所发送的分组无差错、按序到达终点，不丢失、不重复 网络提供数据报服务：
网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务
网络在发送分组时不需要先建立连接。网络层不提供服务质量的承诺。 虚电路服务与数据报服务的对比：
二、网络互连的概念、设备、层次、协议
网络互连是指将不同的网络连接起来，以构成更大规模的网络系统，实现网络间的数据通信、资源共享和协同工作。网络互连都是只用路由器进行网络互连和路由选择。
与IP协议配套使用的还有三个协议：
地址解析协议ARP网际控制报文协议ICMP网际组管理协议IGMP 有以下五种不同的中间设备：
物理层中继系统：转发器数据链路层中继系统：网桥或桥接器网络层中继系统：路由器网桥和路由器的混合物：桥路器网络层以上的中继系统：网关 使用IP协议的虚拟互联网络可以简称为IP网，互联网就是一个虚拟互联网络。
三、IP值的组成、分类
IP地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围内唯一的32位标识符。
IP地址现在由互联网名字和数字分配机构进行分配。
IP地址的编址方法：
分类的IP地址子网的划分构成超网 分类IP地址 将IP地址划分为若干个固定类每一类地址都由两个固定长度的字段组成，其中一个字段是网络号net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号host-id，它标志该主机（或路由器）主机号在它前面的网络号所指明的网络范围内必须是唯一的
一个IP地址在整个互联网范围内是唯一的。两级的IP地址结构：网络号+主机号（32位）两级的IP地址记为：IP地址::={&lt;网络号&gt;,&lt;主机号&gt;}，符号“::”=代表“定义为” 各类IP地址的网络号字段和主机号字段 四、子网的划分（子网数、主机数、子网号、子网掩码等）和CIDR的基本概念及应用
三级IP地址记为：IP地址::={&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}。划分子网只是把IP地址的主机号host-id这部分进行再划分，而不改变IP地址原来的网络号net-id.
三级结构的好处：
减少IP地址的浪费使网络的组织更加灵活更便于维护和管理 子网掩码
使用子网掩码可以找到IP地址中的子网部分。
子网掩码长度 = 32位；
某位 = 1：IP地址中的对应位为网络号和子网号
某位 = 0：IP地址中的对应位为主机号
IP地址的各字段和子网掩码：
地址分类默认子网掩码A类地址255.0.0.0B类地址255.255.0.0C类地址255.255.255.0 无分类编址CIDR
CIDR消除了传统的A类、B类和C类地址以划分子网的概念，使用各种长度的“网络前缀”来代替分类地址中的网络号和子网号。
无分类的两级编址的记法为：
CIDR把网络前缀都相同的连续的IP地址组成“CIDR地址块”。全0和全1的主机号地址一般不使用。
路由聚合
一个CIDR地址块可以表示很多地址，这种地址的聚合常称为路由聚合。路由聚合有利于减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能路由聚合也称为构成超网。对于/20地址块，它的掩码是20个连续的1.斜线记法中的数字就是掩码中1的个数。 CIDR记法的其他形式
CIDR地址块中的地址数一定时2的整数次幂。
CIDR好处：更加有效地分配IPv4的地址空间，可根据客户的需要分配适当大小的CIDR地址块。
最长前缀匹配：
在查找路由表时可能会得到不止一次匹配结果应当从匹配结果中选择具有最长网络前缀的路由：最长前缀匹配网络前缀越长，其地址块就越小 ，因而路由就越具体最长前缀匹配又称为最长匹配或最佳匹配 五、IP数据报格式，各字段的含义及作用
IP数据报的格式
一个IP数据报由首部和数据两部分组成首部的前一部分是固定长度，共20字节，是所有IP数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。 版本——占4位，指IP协议的版本（即IPv4）首部长度——占4位，因此IP的首部长度的最大值是60字节。总长度——占16位，指首部和数据之和的长度，单位为字节。总长度必须不超过最大传送单位MTU标识——占16位，是一个计数器，用来产生IP数据报的表识标志——占3位，只有前两位有意义。最低位MF:MF=1（还有分片）、MF=0（最后一个分片）；中间位DF，只有当DF=0时才允许分片片偏移——占13位，片偏移以8给字节为偏移单位生存时间——占8位，记为TTL，指示数据报在网络中可通过的路由器的最大值协议——占8位，指出此数据报携带的数据为何种协议，以确定目的主机的IP层需要将数据部分上交给哪个协议进程首部检验和——占16位，只检验数据报的首部，不检验数据部分。采用校验和计算方法。（采用16位二进制反码求和算法）源地址和目的地之各占4个字节 六、ARP协议的基本概念和应用，IP地址和MAC地址的区别
地址解析协议ARP:
通信时使用了两个地址：
IP地址（网络层地址）MAC地址（数据链路层地址） ARP协议的作用：
解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。
使用ARP的四种典型情况：
IP地址和MAC地址的区别:
硬件地址是数据链路层和物理层使用的地址，是一种物理地址；IP地址是网络层和以上各层使用的地址，是一种逻辑地址。（IP地址是用软件实现的）。MAC地址具有唯一性；IP地址不具有唯一性MAC地址是Ethernet网卡上带的地址，长度为48位；IP地址目前主流是32位长。IP地址放在IP数据报的首部，而硬件地址则放在MAC帧的首部。 七、ICMP报文类型、作用
ICMP是互联网的标准协议，ICMP允许主机或路由博鳌公安差错情况和提供有关异常情况的报告。ICMP不是高层协议，而是IP层的协议。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf76469f5706a1c44f1d24c30fe50fa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4e52b36664d3b90e158ff3fbc37b253/" rel="bookmark">
			eclipse插件绘制flowable流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1. 安装插件2. 创建并绘制流程文件3. 保存流程文件并生成图片4. Flowable Eclipse 路程文档设计器缺陷 1. 安装插件 Flowable 流程设计器名称为：Flowable Eclipse Designer，官方下载地址为：http://flowable.org/designer/archived/flowable-designer-5.22.0.zip
这里使用eclipse在线安装
name：Flowable BPMN 2.0 designer
location：http://flowable.org/designer/update
根据提示完成安装即可。我这里已经安装过了
2. 创建并绘制流程文件 3. 保存流程文件并生成图片 Ctrl+s 保存
查看XML文件
4. Flowable Eclipse 路程文档设计器缺陷 Flowable 提供的 Eclipse 插件本质上是基于 5.22.0 版本的，因此Flowable 6 版本中的新增特性无法使用Flowable 提供的 Eclipse 插件其实就是Activiti插件，只是换了个图标而已Eclipse 安装插件时，只能选择Flowable和Activiti两者中的一个，两个插件不能同时存在 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47c33ed21e814f25deae4ed437356828/" rel="bookmark">
			Python subprocess模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.pynote.net/archives/490
https://www.pynote.net/archives/2088
https://www.pynote.net/archives/1757
https://www.pynote.net/archives/1775
目录 介绍引入subprocess模块subprocess.run() 函数的使用subprocess.Popen()函数的使用用subprocess启动后台进程关于subprocess子进程的communicate函数实时获取subprocess子进程的输出 介绍 Python的subprocess模块，用来创建和管理子进程（不是线程），并能够与创建的子进程的stdin，stdout，stderr连接通信，获取子进程执行结束后的返回码，在执行超时或执行错误时得到异常。
从Python3.5版本开始，subprocess模块内部又进行了一次整合 ，最后就剩下官方推荐的两个接口函数，分别是：
subprocess.run() subprocess.Popen() run() 函数的使用场景更多，它的底层调用的是Popen函数，Popen函数更灵活，适合更复杂的场景。我们只要好好学习这两个函数接口的使用，就能够掌握subprocess模块的几乎所有功能。
引入subprocess模块 由于subprocess这个名字很长，考虑到这个模块对外接口的函数和对象名称都比较特别，本文就这样来引入吧：
&gt;&gt;&gt; from subprocess import * &gt;&gt;&gt; dir() ['CalledProcessError', 'CompletedProcess', 'DEVNULL', 'PIPE', 'Popen', 'STDOUT', 'SubprocessError', 'TimeoutExpired', '__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'call', 'check_call', 'check_output', 'getoutput', 'getstatusoutput', 'run'] call，check_call，check_output，getoutput，getstatusoutput这些函数，都被run函数代替了，它们在存在只是为了保持向下兼容。从上面的打印还可以看出，subprocess这个模块提供的接口并不多。
subprocess.run() 函数的使用 run函数的作用是：执行args参数所表示的命令，等待命令执行完毕，返回一个CompletedProcess对象。注意，run函数是同步函数，要等待！
run()函数的接口参数：
subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, capture_output=False, shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None, text=None, env=None, universal_newlines=None) args参数，就是要通过创建进程而执行的命令及参数，run函数通过args来创建一个进程并执行。
shell参数，表示是否通过shell来执行命令（Linux下默认为/bin/sh），默认是False，这时args只能是一个不带参数的命令字符串，或者是命令和参数组成的一个list，如果shell=True，args就可以是一个我们常见的命令字符串。下面举例：
&gt;&gt;&gt; run('ls') acme.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47c33ed21e814f25deae4ed437356828/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ae63c2a2c1fb81412cf33f2581e4c38/" rel="bookmark">
			springSecurity 学习（一）创建springSecurity项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建springsecurity项目的方式有很多，最简单的是 使用Spring Initializr工具，
点击下一步，输入项目基本信息，选择jdk版本
再下一步，选择要使用的组件
完成项目创建。
项目目录如下
打开pom文件，
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.hzau&lt;/groupId&gt; &lt;artifactId&gt;securitydemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;securitydemo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ae63c2a2c1fb81412cf33f2581e4c38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8ca4bfae878330ce177dbe75fb49f6a/" rel="bookmark">
			引导修复_利用老毛桃系统修复Windows引导故障
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们选择启动windows7系统后，BOOTMGR 就会去启动盘寻找 WINDOWS\system32\winload.exe，然后通过winload.exe加载windows7内核，从而启动整个windows7系统。
常见故障：bootmgr is missing，是代表硬盘的主引导记录(MBR)出错，从而导致无法引导系统。
1、制作老毛桃PE U盘，下载好老毛桃安装程序，运行程序之前请尽量关闭杀毒软件和安全类软件，插入U盘之后点击一键制成USB启动盘 按钮，程序会提示是否继续，因为制作会格式化U盘的数据，请确认所选U盘无重要数据后开始制作。
2、制作完成后按快捷键启动U盘。
3、进入老毛桃winpe主菜单后，选择【1】Win10X64PE(2G以上内存)，按【回车】进入winpe桌面。
5、在winpe桌面中，找到并打开【引导修复】软件。
6、然后，在老毛桃引导修复界面中，勾选需要修复的操作系统，点击【开始修复】。
7、等待引导修复成功后，界面会有弹窗提示，点击【确定】即可
8、然后重启故障电脑，看看能否进入Windows系统。
欢迎关注【5分享】(fivsha)公众号获取更多帮助和资讯。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e6e2c8dd875be7846b5ae49a7f54b34/" rel="bookmark">
			多核cpu应用场景_你就和说我CPU多核有什么用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚刚去看来AMD的官网，我看到了它图片来自：AMD官网
这是锐龙3950X！！！
这个应该是3000系列中最强的CPU了吧，我也发现到它有32个核心和64线程。
突然先看看自己的小笔记本用的是什么？图片来自：intel官网
我自己的电脑只有四核四线程，哈哈哈！！！
留下了不争气的眼泪。
我很好奇多核心有什么用，神奇的比喻又开始了！
如果把电脑运行程序比作造房子，核心数就代表了劳动力，同时还有一个叫线程的东西，刚刚也说了锐龙3970X 有32核64线程，我的i5-7300HQ只有4核4线程。
为什么3970X的线程可以是核心数的两倍？线程代表了核心可以同时进行的进程，就好比，有的工人可以一边搬砖一边砌墙，但是有些只能做一件事情，一般来说，每个核心最多就是有两个线程。
多核心多线程有什么用？
1、应用开起来！多线程就代表了可以开更多的应用，同时当你一个程序卡住的时候，其他程序也还是可以正常工作的
2、渲染和游戏都可以有核心参与，渲染软件一般会调用尽多核来进行渲染，因为渲染的场景一般是可以分开做的，任务不具备连贯性。之前的游戏以单核为主，这才有了，i3默秒全，游戏吃单核，性能差距拉不开。但是现在越来越多的游戏去优化多核，使得性能能够更好的被利用。
了解更多更多黑科技知识，请关注星辰小堂！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01ba0e45e6211eca5463eb2f4dd8046e/" rel="bookmark">
			cpu过剩是什么意思_现在的电脑，处理器CPU性能过剩，为什么使用起来还是会卡顿？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		既然现在处理器性能过剩，为什么PC用起来不流畅？我们都知道，一台PC电脑，是由很多的配件组装而成，主要的配件有：电脑主板、处理器CPU、内存、硬盘、显卡、电源、显示器。要想电脑运行流畅，就要让这几个配件相互协调、配合默契，才能达到最佳效果。
很多情况下，PC电脑之所以不流畅，就是因为电脑的配置不协调造成的，如：CPU配置很高，而内存却配置很低。这就好比汽车，CPU是汽车的发动机，内存是汽车的四个轮胎，有好的发动机，没有好的轮胎，汽车开起来的速度和性能都会大打折扣。电脑也是一样的，在这点上，我是有亲身体会的。
2017年我4000左右入手了一款神舟数码品牌的战神笔记本电脑，型号是K650D-SL5D1，当时的配置是：CPU是Intel 酷睿i5 6300HQ，原装内存是4G，硬盘是1TB的机械硬盘，显示是集成显示和独立显示。当时，我主要是看上了这款电脑的CPU和显卡，都是很不错的。操作系统是windows7，我买回来主要是一般办公，开始使用时，感觉还可以。
后来，我要使用photoshop软件来修图，这时，问题就开始慢慢出现了，打开photoshop 非常慢，使用时会很卡，360卫士提示内存使用率达到99%，我查看了一下系统的任务管理器，系统内存已经基本用完，而CPU的使用率却只达到10%，可见，运行photoshop时，CPU是没有任何压力的，压力主要来自于系统的内存，是内存太小了。于是，我把笔记本的内存从4G升级到了8G，在运行photoshop时，就没有再出现卡顿的现象，问题解决。
从我的这个案例中，我们可以看出，我电脑之所以出现卡顿现象，问题是出在系统内存太小的原因上，而CPU在性能上已远远达到了photoshop的需求。可见，电脑流畅不流畅，并不是CPU一个人所决定的。系统不流畅的原因，其实很多，如：CPU散热效果不好、内存太小、机械硬盘出现坏道、显卡不给力、系统垃圾过多、系统盘过于臃肿、同时打开的软件太多等等。
如果觉得对你有帮助，欢迎【转发】和【点赞】。
如有不同意见，欢迎发表【评论】。同时，欢迎【关注】我，观看更多精彩内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/099c0a15dccc96d249d47039840337fd/" rel="bookmark">
			cpu过剩是什么意思_现在为什么人们都说CPU性能过剩，而不说显卡性能过剩？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CPU和显卡究竟性能过不过剩是分情况的，我们平常说的CPU性能过剩是因为在用电脑日常办公中，哪怕是一些复杂的3D游戏中，I3或者I5的CPU就可以达到足够的性能，如果再往上提升效果变化不大。就现在I5 8400这样的CPU，大部分用户恐怕都很难使其占用率超过50%，因此也造就了很多“低U配高显”的装机模式。
然而面临这种情况的电脑用户比例能达到90%以上，而对于其中那些喜欢玩游戏的玩家来说，显卡则是往往是永远不够用的。帧数不足要求稳定60帧，60帧还不够流畅，往上还有120帧、144帧；1080P分辨率过时了，2K和4K更清晰，还有用户们对游戏画质的要求也是没有止境的，而目前的游戏画质与真实世界仍然差距很大，这些就会一直对显卡性能不断提出更高的要求，实际上每一代显卡的性能提升幅度确实相当大。
为什么CPU这几年性能增长缓慢？一方面是因为如今的CPU架构已经非常成熟，很难在单核效能上继续提高，近两年AMD和英特尔也只能通过多核来提升CPU性能；另一方面在于如今的半导体工艺进步越来越难，尤其是进入14nm以后，再也无法像以前那样两年一换代，成本和风险都大大增加了，关键的制程工艺进步慢，CPU自然进步也就慢下来了。
不过虽然这几年CPU进步缓慢，日常性能过剩，这也不代表CPU就真的“过剩”了，面对服务器和工作站领域，可以说CPU永远不够用，像我日常接触较多的3D渲染和视频剪辑方面，对CPU频率和核心数都有很高的要求，只有更快没有最快，始终都想和换新显卡那样换一颗更好的CPU来加快工作效率。
就电脑游戏而言，虽说目前看似CPU性能过剩，但也是正因为目前的CPU性能有限，很多游戏开发者的想法无法变成现实，所以我们看到大量开放性游戏中的同屏显示人数是比较低的(CPU需要处理大量NPC智能运算)，像《全面战争》这样的超大规模对战类游戏，当人数达到一定程度时，再好的CPU都会出现卡顿。所以CPU在目前的游戏中所谓的“过剩”也是游戏开发者无奈的妥协造成的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/966a55387cafd6edf73ad4d861c2ee5d/" rel="bookmark">
			SuccessFactors（SF） - 年假帐户配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		年假帐户配置逻辑图 年假帐户配置时，需要对三个模块进行配置，三个模块相互关联。
时间档案假期日历休假流程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffdc39c801a819c8d6ef241d3a06942b/" rel="bookmark">
			STM汇编程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM汇编程序设计 一、STM32的三种Boot模式（一）三种BOOT模式简介（二）串口烧录程序（三）DAP仿真器烧录程序 二、基于MDK创建纯汇编语言的STM32工程（一）汇编简介（二）环境搭建（三）硬件连接（三）汇编程序编写（四）编译调试（五）结果 三、汇编基础练习（一）建立工程（二）代码（三）结果 四、总结 一、STM32的三种Boot模式 （一）三种BOOT模式简介 用户可以通过设置BOOT1和BOOT0引脚的状态，来选择在复位后的启动模式。
BOOT0BOOT1启动模式0X主存储器模式10系统存储器模式11内置SRAM模式 1.主存储器模式
是STM32内置的Flash，一般我们使用JTAG或者SWD模式下载程序时，就是下载到这个里面，重启后也直接从这启动程序。
==2.系统存储器模式 ==
从系统存储器启动，这种模式启动的程序功能是由厂家设置的。一般来说，这种启动方式用的比较少。系统存储器是芯片内部一块特定的区域，STM32在出厂时，由ST在这个区域内部预置了一段BootLoader， 也就是我们常说的ISP程序， 这是一块ROM，出厂后无法修改。一般来说，我们选用这种启动模式时，是为了从串口下载程序，因为在厂家提供的BootLoader中，提供了串口下载程序的固件，可以通过这个BootLoader将程序下载到系统的Flash中。
3.内置SRAM​模式
内置SRAM，既然是SRAM，自然也就没有程序存储的能力了，这个模式一般用于程序调试。假如我只修改了代码中一个小小的地方，然后就需要重新擦除整个Flash，比较的费时，可以考虑从这个模式启动代码（也就是STM32的内存中），用于快速的程序调试，等程序调试完成后，在将程序下载到SRAM中。
4.三种BOOT模式启动方式
STM32的启动方式一般以储存器的类型来区分，如下： 内部FLASH启动方式 ，内部SRAM启动方式 ，系统储存器启动方式。
（二）串口烧录程序 1.开发板和电脑连接，先简单的使用串口和电脑连接起来。
2.安装USB驱动。
右击“此电脑”—&gt;“属性”—&gt;“设备管理器”—&gt;“端口”进行查看，确认连接后，使用配套驱动软件，点击安装即可。
3.开发板的BOOT0和BOOT1接地，RXD和TXD分别接PA9和PA10。
4.打开串口下载软件，找到生成的hex文件，然后进行串口烧录程序（串口烧录程序可以参考本人之前的文章，有更详细的介绍）。
5.打开野火多功能调试助手，则可以查看结果，如下图所示。
（三）DAP仿真器烧录程序 1.在野火提供的资料中，找到如下工程。
2.打开工程文件，如果有其他需求可以修改代码。
3.对程序进行编译。
4.对工程进行设置。
5.点击Flash Download，按照下图顺序进行设置。
6.配置好文件之后，再次进行编译看是否有错误，无错误后，点击Load进行烧录。
7.烧录完成之后，通过串口调试助手查看结果。
二、基于MDK创建纯汇编语言的STM32工程 （一）汇编简介 汇编语言是一种最低级、最古老、不具有移植性的编程语言，它能够直接访问计算机硬件，所以执行效率极高，占用资源极少，一般用于嵌入式设备、驱动程序、实时应用、核心算法等。汇编指令是机器指令的助记符，同机器指令一一对应，通常由操作码和地址码（操作数）两部分组成，每组CPU都有其汇编指令集。
（二）环境搭建 1.打开keil5软件，新建一个工程。
2.选择自己开发板的型号。
3.CMIS下选择CORE，Device下Startup，包含了启动文件。
4.右键点击source group1添加新文件。
5.由于要使用汇编语言，所以添加.s文件，然后命名和修改文件路径。
（三）硬件连接 杜邦线将开发板和st-link相连，其中开发板的SWDIO连st-link的SWDIO，开发板的SWCLK连st-link的SWCLK，开发板的GND连st-link的GND，开发板的3v3连st-link的3v3。
开发板st-linkSWDIOSWDIOSWCLKSWCLKGNDGND3v33v3 （三）汇编程序编写 1.点击魔法棒，进行设置。
2.如下图所示进行配置。
3.选择SW，如下图所示。
4.设置Flash Download。
5.代码如下：
AREA MYDATA, DATA AREA MYCODE, CODE ENTRY EXPORT __main __main MOV R0, #10 MOV R1, #11 MOV R2, #12 MOV R3, #13 ;LDR R0, =func01 BL	func01 ;LDR R1, =func02 BL	func02 BL func03 LDR LR, =func01 LDR PC, =func03 B .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffdc39c801a819c8d6ef241d3a06942b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a9f5539bb16fd8beedcf2730f5d1349/" rel="bookmark">
			大小写 数据库 达梦_达梦数据库操作手册 -
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		10. 开始菜单文件夹建立
11. 完成安装配置，显示安装小结
12. 完成安装，修改安装目录下dm.ini文件中的部分参数，详见1.2.3节内容。
1.2.2字符形式安装
某些情况下，无法使用图形话界面连接到服务器上，此时安装达梦数据库可以使用字符
界面安装。
1．运行达梦安装文件 ./DMInstall.bin -i
如果提示权限不够，进行授权，执行： chmod+xDMInstall.bin
2. 开始安装，根据提示输入dm.key所在位置
Welcome to DM Install Program Please Input the Path of the Key File[/home/d5000/dm_install/dm.key]: 方括号内为key文件所在位置默认路径，回车选择默认路径。 3．选择安装类型
Expiration Date: unlimited Server Series: Enterprise Edition Server Type: Trial Edition Customer Name: 国电南瑞 Authorized User Number: 1 Concurrency User Number: unlimited Installation Type: 1 Typical 2 Server 3 Client 4 Custom Please Input the number of the Installation Type [1 Typicail]: 选择Typical，输入1。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a9f5539bb16fd8beedcf2730f5d1349/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b42c39ed346bd364bcb1911846b48d6/" rel="bookmark">
			origin中文版散点图拟合曲线_大学物理实验Origin作图范例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 对于物理实验，计算机作图的方法很多，除了Excel，还可以使用一款功能强大的绘图软件—Origin。Origin是一款专业实用的绘图软件，具备统计、信号处理、图像处理、峰值分析和曲线拟合等功能，并提供50多种2D和3D图形模板，是科研人员和工程师常用的高级数据分析和制图工具。对于初学者，我们今天跟大家介绍一下其基本的直线拟合功能。
一、在origin中输入数据
以下为Origin 打开时的默认页面，自变量和因变量可以直接输入Data1中，也可以通过Excel导入进来
二、 设置变量名称 输入数据后，可以对列所代表的量进行设置，选定A(X)B(Y)列点击右键，选择Perporties，出现如图所示窗口，在窗口中Column name可以改变其所代表的物理量，如温度T
三、绘制散点图
选中需要绘制图线的数据，点击Plot下的Scatter，或者屏幕中间按，会出现一个新的窗口Graph1，散点图绘制完成
四、 线性拟合 点击工具栏上的“Analysis”，选择“Fit Linear”。
将中间状态条往上拉，可以看到完整的拟合结果
说明：A: 截距及其标准差 B: 斜率及其标准差 R: 相关系数 P: R为零的概率
N：点数 SD:回归标准差
五、对坐标轴进行设置
双击x轴或者Y轴的刻度，出现以下窗口，该窗口可以对对纵坐标和横坐标的刻度，起点，终点等进行设置。
双击x轴或者Y轴的旁的Axis Title，可以改变其文字，对纵坐标和横坐标的标注，物理量符号，单位进行设置。
说明：图表空白处，用文本框可填写图表标题、学院、班级、姓名、日期信息等
好了
以上就是本次Origin作图教学的全部内容了
实际上Origin的绘图功能非常强大，如果有兴趣可以自行学习，网上也有很多教程
多掌握几种绘图软件，你可成为绘图高手！
图文丨吴肖 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/094497ce4424339c603a5dd7ca32a191/" rel="bookmark">
			数据结构期末速成复习资料 (一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路漫漫其修远兮，吾将上下而求索 今天是2020年的倒数第二天，此时的我还窝在寝室复习数据结构，莫得办法，为了部落为了胜利然后以下是一些我复习数据结构时的习题，分享给大家！ 一、填空题 数据结构是一门研究非数值计算的程序设计问题中计算机的 操作对象 以及它们之间的 关系 和运算等的学科数据结构被形式地定义为（D, R），其中D是 数据元素 的有限集合，R是D上的 关系 有限集合数据结构包括数据的 逻辑结构 、数据的 存储结构 和数据的 运算 这三个方面的内容数据结构按逻辑结构可分为两大类，它们分别是 线性结构 和 非线性结构线性结构中元素之间存在一对一关系，树形结构中元素之间存在一对多关系，图形结构中元素之间存在多对多关系数据的存储结构可用四种基本的存储方法表示，它们分别是顺序 、 链式 、 索引 和 散列数据的运算最常用的有5种，它们分别是插入 、 删除、修改、 查找 、排序一个算法的效率可分为 时间 效率和 空间 效率 二、选择题 非线性结构是数据元素之间存在一种：
A）一对多关系 B）多对多关系 C）多对一关系 D）一对一关系数据结构中，与所使用的计算机无关的是数据的 结构；
A) 存储 B) 物理 C) 逻辑 D) 物理和存储 数据的逻辑结构反映的是数据元素之间的逻辑关系，与使用的计算机无关
算法分析的目的是：
A) 找出数据结构的合理性 B) 研究算法中的输入和输出的关系
C) 分析算法的效率以求改进 D) 分析算法的易懂性和文档性算法分析的两个主要方面是：
A) 空间复杂性和时间复杂性 B) 正确性和简明性
C) 可读性和文档性 D) 数据复杂性和程序复杂性 算法分析是对一个算法需要多少计算时间和存储空间作定量的分析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/094497ce4424339c603a5dd7ca32a191/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5279d2b0134b5e87fe9073cac7ca614e/" rel="bookmark">
			Postgres主进程文件—postmaster.pid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		postmaster内容 使用cat -n 命令可以查看postmaster.pid文件内容：
)
根据每一行进行解释，并给出对应的源代码说明 13795: 代表Postgres主进程的PID /usr/local/pgsql/data: 代表数据目录
1529235109： 代表postmaster文件的创建时间。
5432: 代表数据库监听端口，在postgresql.conf中对应port = 5432
来自源代码说明：
/* The socket number we are listening for connections on */ int	PostPortNumber; 12 /tmp: 代表是unix socket的监听目录，在postgresql.conf中对应 unix_socket_directory = '/tmp' 来自源代码说明：
/* The directory names for Unix socket(s) */ char	*Unix_socket_directories; 12 *** **: 代表数据库监听地址，对应postgresql.conf的listen_addresses = '\* ' 来自源代码说明：
/* The TCP listen address(es) */ char	*ListenAddresses; 12 5432001 163840:代表的是共享内存的地址(shared memory segments中的key和shmid)。 输入ipcs可以查看：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5279d2b0134b5e87fe9073cac7ca614e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/414e0ca02f6afc857b14901198c9a841/" rel="bookmark">
			10重新录入人脸识别_门禁对讲住户信息（卡、人脸）登记录入时间安排
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中环花苑小区业主、住户：
小区新门禁对讲系统安装施工即将完工。定于2020年 10月5日起，对小区全体业主、住户的鉴权信息进行登录录入。现将相关事项通知如下： 录入地点：小区15号物业管理处 时间：2020年10月5日起，每天8：30——21：00
门禁卡采取老卡换新卡的方式，即一张有效的老卡免费更换一张加密的新卡，原旧卡无法再使用
新门禁系统支持人脸识别(三个小区大门、地下车库入户门、门栋门)，可实现无钥匙进出。如需要录入人脸识别的业主请携带房产证(或售房合同、户口本)和本人身份证到物业管理处登录，身份证一人一证。
[* 人脸识别为可选方式，非必需，门禁卡也可正常进出]
小区租户携带租房合同，鉴权有效期为租房合同到期日
待小区所有住户登录录入完毕，小区新门禁对讲系统将正式启用后，届时所有门岗保安将不会再为无门禁卡(包括忘带)人员，外来人员开门。 特此通知。
上海中环陆家嘴物业中环花苑管理处
上海中环花苑业主委员会
2020年9月
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9f1c5b57ecbd9e1c09aaaec4732f23d/" rel="bookmark">
			的cipher加密原理_安全第12讲——PBE加密算法的介绍与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、引言 PBE，是Password Based Encryption的缩写，即“基于口令的加密算法”。
IETF制定了两个相关的标准：
rfc2898：PKCS #5: Password-Based Cryptography Specification Version 2.0
rfc8018：PKCS #5: Password-Based Cryptography Specification Version 2.1
这两个标准对MAC和PBE算法制定了规范，有兴趣的朋友可以仔细阅读。
2、PBE的原理 前面第8讲介绍过不可逆加密算法HMAC，HMAC其实算不上独立的不可逆加密算法，而是一种融合了密钥和其它不可逆加密算法的实现。
PBE和HMAC比较类似，并不是一个独立的对称加密算法，而是一种融合了口令、盐值、哈希算法和其它对称加密算法的实现。
使用PBE进行加密操作的原理如下图所示：
PBE的实现原理，其实是根据口令，生成密钥，然后利用生成的密钥进行加密或解密操作。
3、使用JDK的PBE功能 在JDK中，实现了PBE功能。下面的示例代码，使用了基于MD5和DES算法的PDE实现：
package com.flying.pbe;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import javax.crypto.*;import javax.crypto.spec.PBEKeySpec;import javax.crypto.spec.PBEParameterSpec;import java.security.*;import java.security.spec.InvalidKeySpecException;@SpringBootApplicationpublic class PbeApplication { public static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeySpecException, InvalidKeyException, NoSuchPaddingException, InvalidAlgorithmParameterException, BadPaddingException, IllegalBlockSizeException { SpringApplication.run(PbeApplication.class, args); //密码为my_password String password = "my_password"; printBytes("The password of PBE is", password.getBytes()); PBEKeySpec pbeKeySpec = new PBEKeySpec(password.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9f1c5b57ecbd9e1c09aaaec4732f23d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/457b9c508c61c2e9031e1c2a8daa04ee/" rel="bookmark">
			python爬虫app步骤_Python爬虫抓取手机APP的传输数据，python爬虫抓取app
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python爬虫抓取手机APP的传输数据，python爬虫抓取app
大多数APP里面返回的是json格式数据，或者一堆加密过的数据 。这里以超级课程表APP为例，抓取超级课程表里用户发的话题。
1、抓取APP数据包
方法详细可以参考这篇博文：Fiddler如何抓取手机APP数据包
得到超级课程表登录的地址：http://120.55.151.61/V2/StudentSkip/loginCheckV4.action
表单：
表单中包括了用户名和密码，当然都是加密过了的，还有一个设备信息，直接post过去就是。
另外必须加header,一开始我没有加header得到的是登录错误，所以要带上header信息。
2、登录
登录代码：
import urllib2
from cookielib import CookieJar
loginUrl = 'http://120.55.151.61/V2/StudentSkip/loginCheckV4.action'
headers = {
'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
'User-Agent': 'Dalvik/1.6.0 (Linux; U; Android 4.1.1; M040 Build/JRO03H)',
'Host': '120.55.151.61',
'Connection': 'Keep-Alive',
'Accept-Encoding': 'gzip',
'Content-Length': '207',
}
loginData = 'phoneBrand=Meizu&amp;platform=1&amp;deviceCode=868033014919494&amp;account=FCF030E1F2F6341C1C93BE5BBC422A3D&amp;phoneVersion=16&amp;password=A55B48BB75C79200379D82A18C5F47D6&amp;channel=MXMarket&amp;phoneModel=M040&amp;versionNumber=7.2.1&amp;'
cookieJar = CookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookieJar))
req = urllib2.Request(loginUrl, loginData, headers)
loginResult = opener.open(req).read()
print loginResult
登录成功 会返回一串账号信息的json数据
和抓包时返回数据一样，证明登录成功
3、抓取数据
用同样方法得到话题的url和post参数
做法就和模拟登录网站一样。详见：Python爬虫模拟登录带验证码网站
下见最终代码，有主页获取和下拉加载更新。可以无限加载话题内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/457b9c508c61c2e9031e1c2a8daa04ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6236830de5d25dea29a6d535071a1ae0/" rel="bookmark">
			sas univariate 结果解释_SAS第四章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人课程笔记 第四章的内容
教科书：A Handbook of Statistical Analyses Using SAS
学校的视频，slides，lab的代码和report
配合参考资料，官方文档
https://support.sas.com/documentation/onlinedoc/stat/131/anova.pdf
基本介绍 第二章考虑过一个response variable和一个categorical variable之间的关系。当categorical variable只有两个可能的值得时候可以使用two sample t test 来判断mean是否相等。
这一章介绍ANOVA model，可以解释更广泛的情况。要求有一个Response variable（是numerical data或者说是连续的数据），predictors可以有任意多个categorical variables，而且这些categorical variables取值数量可以任意多个，超过两个也没问题。但是局限性是predictors只能是categorical variables。按照categorical variables的数量称为
N-way analysis of variance: based on n independent categorical variables
我们可以分析response关于一个categorical variables的变化
Main effect: effect of single categorical predictor
也可以考虑两个categorical variable互相有interaction。
First-order interaction: an interaction between two categorical predictors
n-th order interaction: interaction of a categorical predictor with n-1 other categorical predictors
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6236830de5d25dea29a6d535071a1ae0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f68a84558a03c22e752e9d4890171155/" rel="bookmark">
			百旺如何看是否清卡_百旺税控怎么看反写成功
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百旺税控怎么看反写成功
一般纳税人才有税控盘.每个月月初把税控盘里的上月的开票信息通过网络汇总抄报到国家税务总局的报税平台.
首先,航天金穗的是金税盘,百旺金赋的是税控盘,您要区分清楚哟,税控盘反写 :
至于具体的操作流程,可以整理成这样:
(1)点击"报税处理",选择"网上抄报",对所有发票种类,依次点击"上报汇总"
(2)提示成功后,隔天到申报系统操作报表申报;
(3)申报扣款成功后,再登录开票软件,点击"报税处理",选择"网上抄报",依次点击"返写",提示成功即可.
百旺税控如何清卡?
首先,在清卡之前要先进行抄税.将百旺税盘插入电脑,打开开票软件,点击报税处理.
进入之后,在报税处理界面点及下方的上报汇总.
然后,进行税款申报.登录网上电子税务局,点击综合申报(我要申报),进行申报表填报.若急需清卡,可先填报增值税申报表,提交申报.
申报完成后,点击票表比对,比对通过,申报工作就没问题了.不通过的话就要查找问题所在.
然后,重新打开开票软件,点击报税处理,点击清卡,系统提示完成即可.
清卡完成后,点击报税处理界面的状态查询,查看截止开票时间,若已跳转到下个月,则清卡成功.
现阶段,税盘抄税和清卡之间,至少要间隔两小时,否则可能清卡失败.若清卡失败,携带税盘到大厅进行清卡即可.
百旺税控怎么看反写成功、.其实很简单,只需要登录软件中,然后在报税处理中点击网上抄报,再点击反写就可以看到是否成功了.另外,纳税人在下一个月报数之前必须要进行清卡,否则会影响到下月报税.文章中还整理了清卡的操作步骤.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63f4863efc19c28f1121d391522e3236/" rel="bookmark">
			dm8达梦数据库安装使用详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、达梦数据安装以及相关认证培训体系二、安装环境1.检查操作系统内核版本：2.检查操作系统版本：检查cpu版本信息:查看内存信息:Glibc版本信息检查： 三、安装dm8企业版:首先准备好dm8镜像包导入opt目录进入opt创建mnt目录挂载到mnt目录下：规划用户：创建安装路径以及权限分配：安装之前先配置配置图形化界面启动（用dmdba账号）：文件打开数配置：开始安装:调出图形化界面：点击下一步：勾选同意，进入下一步：key文件可以不用选直接下一步：典型安装，进入下一步：选择你创建的安装目录/dm8，点击确认进入下一步：点击安装：复制弹出框信息。以root用户执行，执行完点击确认关闭：选择初始化：选择创建实例：选择一般用途：安装路径用默认：端口用默认直接下一步：控制文件目录直接选择默认，进入下一步：大小写敏感勾去掉，其余默认:勾住所有用户使用同一个密码，密码为dameng123,方便后期维护：可以不选择创建实例库，也可以都勾上：点击完成：以root用户执行下面3条语句：关闭弹出框选择完成：查看实例信息进入/dm8/tool目录下：使用manager管理工具进行实例登录，输入dameng123：安装完成： 四、达梦的客户端工具DM 控制台工具（脱机工具、console）数据库备份和还原、参数配置修改：DTS 数据迁移工具（dts）支持 sql 文件、数据文件、oracle、mysql、DM 迁移 DM如下是 DM 数据库中的表数据迁移到文件：DM 性能监测工具DM 数据审计分析工具： 五、 DMSQL:sql分类：SQL：Group by 使用样例having 使用样例： 六、 DM 的体系结构：七、 表空间管理：设置文件路径以及大小，扩充，右击修改表空间，DDL查看生成的Sql语句：管理重做日志文件：归档管理: 八、用户管理：设置权限: 九 、模式对象管理：管理表：新建表设置约束创建引用约束后，数据要符合引用的表的数据，否则会报错：主键约束：外键的创建，注意：外键的引用一定要是另一张表的主键。 十、 备份还原：联机备份与还原数据库：联机全库备份：DM 管理工具联机全量备份：使用 DM 控制台工具还原：表空间的备份和恢复：逻辑备份： 十一、 ODBC 配置：总结 前言 因公司业务上需求需要接触达梦数据库，同时也不断开阔视野扩展知识层面，记录下学习过程，以便日后复盘加深印象。
一、达梦数据安装以及相关认证培训体系 二、安装环境 1.检查操作系统内核版本： 2.检查操作系统版本： 检查cpu版本信息: 查看内存信息: Glibc版本信息检查： 三、安装dm8企业版: 首先准备好dm8镜像包导入opt目录进入opt创建mnt目录挂载到mnt目录下： root@localhost dm]# mkdir mnt
[root@localhost mnt]# mount -o loop dm8_setup_rh7_64_ent_8.1.1.88_20200629.iso /mnt
mount: /dev/loop0 写保护，将以只读方式挂载
规划用户： 创建安装路径以及权限分配： 安装之前先配置配置图形化界面启动（用dmdba账号）： 文件打开数配置： dmdba soft nofile 10240
dmdba hard nofile 65563
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63f4863efc19c28f1121d391522e3236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d3fd36f9d9881b2f4e1c263d26908c1/" rel="bookmark">
			rust怎么拆除墙壁指令_腐蚀有什么指令？基本指令及服务器指令汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腐蚀有什么指令？基本指令及服务器指令汇总
2018-02-01 09:14:38来源：游戏下载编辑：野狐禅评论(0)
​RUST++ MOD
(以下在聊天框内输入)
基本命令
/share playername 【shares your doors with a player(共享你的门给一个玩家)】
/unshare playername 【unshares your doors with a player(解除对一个玩家的门共享)】
/help 【Shows commands(显示所有指令)】
/pm "playername" "message" 【private messages a player.(私聊一个玩家，名字必须写全)】
/r message here 【quick reply to last PM(快速回复上一个私聊你的玩家)】
/history 【Shows chat history, last 6 messages by default(显示前6个聊天内容)】
/players 【Shows online players(显示当前在线玩家)】
/location 【Shows the coordinates of the player(显示玩家的当前坐标)】
/ping 【shows latency between client and server(显示服务器的延迟)】
/starter 【gives a configurable starter kit(给予初始装备)】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d3fd36f9d9881b2f4e1c263d26908c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41b5adedec7c6d0ba8f2ad82c2fc9937/" rel="bookmark">
			c&#43;&#43; idea 插件_有了这些配置，idea好用到飞起
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b40472b80fc60957db92e639a6dbbb96/" rel="bookmark">
			职场怪谈:技术面试过了一般HR多久联系？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 之前在看准上看到一个问题：技术面试过了一般HR多久联系？ 技术面试过了，说等hr会联系，但是等了几天也没有消息。这是什么情况。当时分管领导以及说技术面试过了。
分析 这个问题估计是跳槽求职的朋友们比较关心的问题：时间和精力都付出了，什么时候能够给答复呢？这里具体多久回复，每家公司情况都不太一样，这里我从公司的角度分享下我的看法。
我经历过大厂，也经历过创业公司，相对比较有发言权吧。不同的公司，流程虽有不一样，但是大概上是一致的，例如：
一面：一面面试官一般是你的同事，可能是高级别的，相当于初筛，绝大多数人一面都能通过，就是进入二面。二面：大公司的二面面试官一般是资深的技术人员或者是主管/经理；中小型公司里二面面试官可能直接就是总监或者老板（也有小公司和老板和hr一起面试你）三面：大公司可能会由总监/vp过来面试；小公司可能三面就hr这一关了四面：大公司一般会有hr终面把关；小公司四面的情况相对少些。 当然也有一些互联网有五六面的情况。但不管怎样，最后一面一般是hr或者大boss，之前面试环节且统称为技术面吧。
还是回到今天的问题：技术面过了，是不是hr应该马上面试你，或者是hr之后联系你？
大多数的情况下，如果面试官说“之后hr会联系你”，一般不通过的概率比较大，为什么这么说？且听我分析：
说hr之后会联系你，一般有如下情况：
第一种情况：面试者不是特别合适（介于没毛病和特别合适之间的那种）。不出意外，公司之前都会有几个备选的候选人，会考虑对比着看。如果你也成为备选，那么说明两点：
面试者确实不是特别合适（和之前已经面试过的人半斤八两，没有明显的优势倾向，当然也不差到哪里去） 公司这个岗位不是那么缺人。 不管是哪种情况，都不要抱希望耗在等hr联系你，而是应该继续去面试其他家公司，把这家不联系你的公司当成候选公司（说不定会联系你，如果其他人拒绝了offer或者已经找到了工作）
第二种情况：公司内部的流程比较多，不排除hr在开会或者暂时不在公司，过几天联系你。这里分享一个小技巧给你探虚实：我已经有一家公司的offer，可能在两周后入职，如果我通过的话，希望hr能够尽快联系我。这句话相当于玩心理战术了，如果面试的部门觉得你不错且很需要你，相信我，hr一定三天内联系你；否则，那大概率是技术面没通过。
第三种情况：面试者确实不合适，这种情况一般自己都能感受出来，有一些常见的迹象：一面就完事了，然后跟你说二面不在；或者说今天的面试结果需要内部商定一下；再或者说hr暂时有事，可能后面会联系你；更直接的是技术面当场告诉你，今天先到这里之类的话。技术面不合适就这几类话术，本质上都是为了双方面子好看。遇到这种情况，我们礼貌回应即可。如果可以的话，最好向面试官礼貌地问下自己今天面试中的不足，请他给点建议。通过他给的建议，你也能知道你今天的面试到底ok不ok，顺便也能从他人的角度来反思自己需要进步的点。
以上就是“hr之后联系你”的三种情况。作为公司而言，遇到一个合适的面试者，就像咱们找到了一个非常合适的offer一样。如果招聘方真的特别满意，你一定能感受到这种超预期的热情。我曾经面试过两家公司都是上午面试，下午就发offer，就生怕我去其他家面试拿offer了，不断地催促我入职。所以这种情况，你一般不需要关心hr什么时候联系你，该什么时候联系你的反倒是是这个职位的需求部门了。
另外，问这个问题的朋友应该是选择自己网上投递的简历。刚毕业时候我也经常自行投递简历。工作这么多年，我发现这种方式的效率很低，不管是成功率还是入职周期，另外个人的求职体验也很糟糕。如果可以的话，建议尽量通过校友，前同事，猎头，或者是某些公众号发布的招聘信息投递简历。因为只有这样，你才有一个中间人来获知你的面试结果情况，而不用一个人在那里瞎猜，面试就很累了，等待更费劲，求职不应该承担过多的心理压力。
最后还有一点，一个面试结果过了一个多月才告诉你的公司，不建议你去，原因有两个：第一，公司效率如此低下，这样的公司发展有限，你也待不久。第二，多半你是备胎转正，这种情况你去了可能需要承受扭转原有负面印象的压力，性价比相对低一点。
以上就是我分享一些粗浅看法。留一个小问题：在技术面通过后，hr是多久联系你的呢?欢迎留言讨论~ 传送门：2021最新测试资料与大厂招聘合集
博主：测试生财（一个不为996而996的测开码农）
座右铭：专注测试开发与自动化运维，努力读书思考写作，为内卷的人生奠定财务自由。
内容范畴：技术提升，职场杂谈，事业发展，阅读写作，投资理财，健康人生。
csdn：https://blog.csdn.net/ccgshigao
博客园：https://www.cnblogs.com/qa-freeroad/
51cto：https://blog.51cto.com/14900374
微信公众号：测试生财（定期分享独家内容和资源）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97aa18c43281b749981ddd587afe63ed/" rel="bookmark">
			Knife4j使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 springboot整合knife4jspringcloud zuul聚合接口文档 knife4j是swagger的增强版，更契合微服务架构，ui前身是swagger-bootstrap-ui，api注解的使用方式和swagger一致。
springboot整合knife4j 依赖
&lt;!-- 包含了ui界面 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;!-- 2.x基于springfox2.x，3.x基于springfox3.x--&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/dependency&gt; 配置类
@Configuration @EnableSwagger2 //2.x用 @EnableSwagger2WebMvc public class Knife4jConfig { private ApiInfo apiInfo(){ return new ApiInfoBuilder() .title("xm商城接口文档") .description("xm商城1.0的接口文档，仅限内部使用") .termsOfServiceUrl("http://www.xmmall.com") .contact(new Contact("chy", "www.chy.com", "xxxxxxx@qq.com")) .version("1.0") .build(); } @Bean public Docket defaultApi2() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) //分组名称 //.groupName("1.0版本") .select() //指定controller（接口）扫描的包路径 .apis(RequestHandlerSelectors.basePackage("com.chy.mall.orderserver.controller")) .paths(PathSelectors.any()) .build(); } } 和swagger-bootstrap-ui的访问地址一致，都是 doc.html 。
如果使用JRebel启动，会报一些错，这是jrebel、knife4j之间的兼容问题，影响不大
JRebel: ERROR Class ‘springfox.documentation.schema.CachingModelDependencyProvider’ could not be processed by org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97aa18c43281b749981ddd587afe63ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35b53955d92a37e4ad4d5b1407040bc3/" rel="bookmark">
			点击换图 秀米的svg_能换色的.svg图片怎么用？看这篇就够了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：能换色的.svg图片怎么用？看这篇就够了！
请抢答
秀米的图库里可以上传哪些格式的图片？
.jpg
.png
.gif
.svg
以上格式你们都答对了吗？
嗯？秀米支持的.svg图片和 互动图文的svg是一回事吗？从技术原理上来看，也许可以说他们是同宗同源，但是从产品角度来说，它们的用途是不一样的。秀米的布局可以用来制作类似答题、字幕等交互式的图文内容；.svg图片在秀米则是可以换色，而且用户可以上传自己设计的.svg图片。这篇文章主要想讲一下可以换色的.svg图片。
其实关于.svg图片的介绍，我们推送过两篇文章，一篇讲了如何从Ai导出svg格式，另一篇讲了使用.svg图片有哪些坑需要避免。很多小伙伴可能只看了其中一篇，那么在秀米上使用.svg图片的时候就碰到好多问题。所以这篇文章就将前两篇的知识点合二为一，围绕以下三个问题来讲解：
1、.svg图片是怎么构成的？
2、.svg如何从Ai导出？
3、.svg有哪些使用禁忌？
01
SVG图片如何构成
.svg图片并不是单纯地把任意一个图片文件的后缀改成".svg"就能转换出来的。熟知Ai或者其他矢量图制作工具的小伙伴应该比较了解，制作一个矢量图形，就是将多个锚点围成一个形状，这个形状可以添加填充色或者是边框：
那么换句话说，矢量图就是由多个锚点围成的一个或者多个形状的集合。矢量图和位图(常见的位图如JPG、PNG)最明显的区别就是矢量图有锚点，而位图没有：
矢量图有锚点
位图没有锚点
常见的矢量图文件格式有 “.svg”、“.ai”、“.eps”，而在秀米和公众号上适用的矢量图格式只有“.svg”。
02
.svg格式如何从Ai导出
首先，我们需要准备一下工具：
Adobe Illustrator软件(小米使用的是下图中的版本🔻)
准备好一个矢量图。一定要记住了，矢量图是由多个锚点组成的平面图形，不是任意一张位图后缀修改为.svg就变成矢量图了。这里我们假设已经从Ai里做好了一个矢量图：
材料和工具注备好后，我们来看看如何导出.svg图片：
打开AI软件，新建一个文件，大小不论
然后我们将已准备好的矢量图形文件复制(ctrl+c或command+c)粘贴(ctrl+v或command+v)到编辑区:
然后我们就在这个编辑区的左边，特别特别长的标签栏中，找到画板工具(如下图)：
我们选中它，对准南瓜矢量图点击一下
这样，我们就拥有了两个画布：
继续在当前状态下，我们点击一下外面比较大的画布，点击delete删除：
那个刚好能贴近矢量图大小的画布就保留下来了：
接下来，我们摁住ctrl(command)+shift+s，会弹出一个界面框：
在格式选项中，我们点击后面的三角，选择最后一个格式SVG(svg):
设置好图片的格式，以及图片保存的位置等，点击确定，会继续出现一个弹窗：
我们点击左下角的较多选项，展开整个界面；在CSS属性一栏选项中，点击右边的小三角，选择样式属性：
最后点击一下，右下角的确定，我们的.svg图片就制作好了！
接下来，只要将它上传到秀米图库中就好啦：
如果你与小米一样，SVG图片处于灰色状态，只要将上传的文件类型切换成所有文件就好了。
最后给大家展示一下南瓜通过换色变异成“西瓜”的状态：
03
SVG有哪些使用禁忌
秀米的小伙伴们在上传或者使用.svg图片的过程中经常会遇到像“该矢量图形中包含不支持的内容”，“使用了过多SVG图形无法同步”这样的问题。使用.svg图片的禁忌有哪些呢？我们总结了一下：
锚点特别多的SVG不能用
每一篇公众号图文，其实相当于一个网页页面，除了表面上能看到的正文字数之外，其实公众号图文还会统计背后的代码字数。不少小伙伴在使用了一些复杂SVG图形后，同步到公众号时会出现这样一个提示：
这时小伙伴可能会纳闷：我既没有写太多的字数，也没有用过多图形，怎么就无法同步呢？如果是用了SVG图形，出现了这个报错，但却又不是因为用了过多的SVG图形，那么绝对是因为所用的SVG图形包含了过多的锚点。有些锚点很复杂的SVG图形表面上看起来是这样的：
光看着就有数不清的锚点
而这些锚点的html代码形式更是夸张，这一个花的SVG代码多达两万多字：
别说网页会崩溃，我看着都崩溃了
虽然举了个夸张的例子，可能一般情况下也碰不着，但还是奉劝大家，尽量不要用锚点过于复杂的SVG图形。
SVG的描边是无法改色的
有些小伙伴在制作SVG图形是，会给图形加上描边，例如像下放的星星图形有一圈黑色的描边：
当这个图片上传到秀米后，描边是可以正常显示的，但是在秀米的SVG换色功能里却不能改色。如果希望描边是可以改色的话，解决方法很简单。在Ai里选中这个图形，然后执行对象→路径→轮廓化描边：
这个操作可以让原来的描边转变成图形，图形上传到秀米后就能改色了。
SVG不支持字体
小伙伴制作的SVG图形中，可能包含了一些未转化成轮廓路径的文字。大多数字体在秀米和微信公众号上都是不支持的，但如果想在SVG图形中保留字体的话，可以给文字创建轮廓。在Ai创建字体轮廓的方法是，选中文字，右键菜单中选择“创建轮廓”：
温馨提醒各位，使用字体前记得了解清楚这款字体是否可商用哦。
SVG中不能包含位图和剪切蒙板
有些小伙伴可能会用到一些带图案的JPG或者是PNG格式的图片作为SVG图形的底纹，虽然生成的文件是“.svg”没错，但是网页上不支持含有位图的“.svg”格式。同样的将一个JPG或者是PNG文件强行保存为SVG文件也是不可行的，请务必记住这句话：网页上只能识别SVG图形中的锚点以及填充色！
同样在SVG各式中不支持的内容还有“剪切蒙板”。例如有些图形用了剪切模板来裁剪，那么你只能释放剪切蒙板：
下一步
就想办法做个一样的
小结
.svg图片是由多个锚点围成一个或者是多个图形的集合；从Ai里导出.svg的时候，记得要选择“样式属性”这项CSS属性；制作.svg图片的时候，尽量不要用过多的锚点，图形描边以及字体可以在Ai中先轮廓化之后再使用。位图和剪切蒙板SVG图形中是不支持的，切记只有锚点和图形的填充色能被网页识别。
9102年都快过完了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35b53955d92a37e4ad4d5b1407040bc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abb44ddbb5683b812e4b0983e7c33729/" rel="bookmark">
			k8s修改service端口范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vi /etc/kubernetes/manifests/kube-apiserver.yaml
添加到如下位置，放在第一行参数
- command:
- kube-apiserver
- --service-node-port-range=1-65535 有时候，修改文件后自动会重建 api pod。
如果没有，直接删除kube-apiserver pod 就行了 会自动重启
kubectl delete pod kube-apiserver -n kube-system
不能用dashborad修改，不允许修改
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f32a9a436909a1b229bbcfb26d167820/" rel="bookmark">
			nginx 配置https证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 server { listen 443 ssl; #SSL协议访问端口号为443。此处如未添加ssl，可能会造成Nginx无法启动。 server_name www.example.com; #将localhost修改为您证书绑定的域名，例如：www.example.com。 root html; index index.html index.htm; ssl_certificate xxx/xxxxx.pem; #将domain name.pem替换成您证书的文件名。 ssl_certificate_key xxx/xxxxx.key; #将domain name.key替换成您证书的密钥文件名。 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #使用此加密套件。 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用该协议进行配置。 ssl_prefer_server_ciphers on; location / { root home/web; #站点目录。 index index.html index.htm; } # 关键参数：这个变量开启后，我们才能自定义错误页面，当后端返回404，nginx拦截错误定义错误页面 proxy_intercept_errors on; #开启error_page error_page 404 /404.html; error_page 500 502 503 504 /50x.html; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/369735fea126cf598fed92e50bf9e700/" rel="bookmark">
			PaddleOCR 识别使用遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PaddleOCR 识别使用遇到的问题 文章目录 PaddleOCR 识别使用遇到的问题前言错误1：AttributeError: module 'paddle.distributed' has no attribute 'get_rank'错误2：OSError: [WinError 126] 找不到指定的模块。错误3。 error: Microsoft Visual C++ 14.0 or greater is required. Get it with "Microsoft C++ Build Tools": https://visualstudio.microsoft.com/visual-cpp-build-tools/错误4.AttributeError: module 'paddleocr' has no attribute 'PaddleOCR'错误5.[2020/12/29 10:51:41] root ERROR: error in loading image:11.jpg（xx图片） 前言 识别时用的代码，注意更改图片地址
博文：PaddleOCR简单使用，识别文字测试
我是用PyCharm IDE
from paddleocr import PaddleOCR, draw_ocr # 模型路径下必须含有model和params文件，如果没有，现在可以自动下载了，不过是最简单的模型 # use_gpu 如果paddle是GPU版本请设置为 True ocr = PaddleOCR(use_angle_cls=True, use_gpu=False) img_path = 'D:/PythonCode/paddle/ocr/11.jpg' # 这个是自己的图片，自行放置在代码目录下修改名称 result = ocr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/369735fea126cf598fed92e50bf9e700/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/335/">«</a>
	<span class="pagination__item pagination__item--current">336/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/337/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>