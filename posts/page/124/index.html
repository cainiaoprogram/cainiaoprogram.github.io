<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bfef80bf340c4b6338f92288a53f97e/" rel="bookmark">
			【计算机组成原理】信息编码与数据表示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、进位计数制
二、信息编码
三、定点数的表示
四、校验码
五、浮点数的表示
一、进位计数制 整数部分：
二进制、八进制、十六进制 ---&gt; 十进制：加权求和二进制 ---&gt; 八进制：每三位分为一组，转为八进制数二进制 ---&gt; 十六进制：每四位分为一组，转为十六进制数十进制 ---&gt; 二进制：除2取余，先得到低位十进制 ---&gt; 八进制、十六进制：先转为二进制，再转为八进制数或十六进制数 小数部分：
十进制转换为任意进制：乘积取整法，结果不能得到准确值，则取精度值二进制 ---&gt; 八进制、十六进制：与整数部分类似二进制 ---&gt; 十进制：加权求和八进制、十六进制 ---&gt; 十进制：先转为二进制，再转为十进制 真值：符合人类习惯的数字
机器数：数字实际存在机器里的形式
二、信息编码 BCD码：Binary Coded Decimal，二-十进制码，即用二进制数表示十进制数。
BCD码分为有权码和无权码。常见的有权码有8421码、2421码、84-2-1码，常见的无权码有格雷码、余三码。
有权码的共性：都是自补码，即任意两个和为9的编码，互为补码。
格雷码：任何相邻的两个编码之间只有一位二进制位不同。
余三码：每个编码都是其8421码加上0011所得。
汉字编码
汉字输入码：也称外码，是为了将汉字输入计算机而编制的代码，代表某一汉字的键盘符号汉字交换码：不同的具有汉字处理功能的计算机之间在交换汉字信息时所使用的标准代码汉字内码：用于汉字信息的存储、交换、索检等操作的机内代码，一般用两个字节表示汉字字形码：将汉字字形经过点阵数字化之后形成的一串二进制数，用于汉字的显示和打印 国内标准信息处理交换码：国标码
国标码采用两个字节对汉字进行编码，第一版的6763个汉字分为94个区，每个区94位，每个汉字在分区中的位置就是区位码，如“中”字位于54区48位，“中”字的区位码就是5448。
国标码 = 区位码 + 2020H，如“中”字的区位码是5448，转换为十六进制为3630H，则“中”字的国标码为 3630H + 2020H = 5650H
汉字内码 = 国标码 + 8080H，最高位皆为“1”，区别于英文字符的最高位为“0”
汉字字库：将所有汉字的字，字模点阵代码按内码顺序集中起来，构成了汉字库。
如上图字模码：16 × 16 点阵，每个汉字所占空间 = 16 × 16bit = 32B
三、定点数的表示 原码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bfef80bf340c4b6338f92288a53f97e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6abb244d39b637861bc95b7cc088962c/" rel="bookmark">
			VUE 实现滑块验证 共鞥Ⅰ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@作者 : SYFStrive
@博客首页 : HomePage
📜： 微信小程序
📌：个人社区（欢迎大佬们加入） 👉：社区链接🔗
📌：觉得文章不错可以点点关注 👉：专栏连接🔗
💃：感谢支持,学累了可以先看小段由小胖给大家带来的街舞
👉 VUE专栏（🔥） 目录 V u e j s Vuejs Vuejs滑块图示结构框架 Html 结构 Css 结构 JS 结构 完整代码 实现效果总结 ⡖⠒⠒⠒⠤⢄⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸ ⠀⠀⠀⡼⠀⠀⠀⠀ ⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢶⣲⡴⣗⣲⡦⢤⡏⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠋⠉⠉⠓⠛⠿⢷⣶⣦⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠘⡇⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡞⠀⠀⠀⠀⠀⠀⠀⢰⠇⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⡴⠊⠉⠳⡄⠀⢀⣀⣀⡀⠀⣸⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⢸⠃⠀⠰⠆⣿⡞⠉⠀⠀⠉⠲⡏⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠈⢧⡀⣀⡴⠛⡇⠀⠈⠃⠀⠀⡗⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣱⠃⡴⠙⠢⠤⣀⠤⡾⠁⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⢀⡇⣇⡼⠁⠀⠀⠀⠀⢰⠃⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⣸⢠⣉⣀⡴⠙⠀⠀⠀⣼⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⡏⠀⠈⠁⠀⠀⠀⠀⢀⡇⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⢸⠃⠀⠀⠀⠀⠀⠀⠀⡼⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⣰⠃⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⣀⠤⠚⣶⡀⢠⠄⡰⠃⣠⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⢀⣠⠔⣋⣷⣠⡞⠀⠉⠙⠛⠋⢩⡀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀ ⠀⡏⢴⠋⠁⠀⣸⠁⠀⠀⠀⠀⠀ ⠀⣹⢦⣶⡛⠳⣄⠀⠀⠀⠀⠀ ⠀⠙⣌⠳⣄⠀⡇ 不能 ⡏⠀⠀ ⠈⠳⡌⣦⠀⠀⠀⠀ ⠀⠀⠈⢳⣈⣻⡇ 白嫖 ⢰⣇⣀⡠⠴⢊⡡⠋⠀⠀⠀⠀ ⠀⠀⠀⠀⠳⢿⡇⠀⠀⠀⠀⠀⠀⢸⣻⣶⡶⠊⠁⠀⠀ ⠀⠀⠀⠀⠀⢠⠟⠙⠓⠒⠒⠒⠒⢾⡛⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⣠⠏⠀⣸⠏⠉⠉⠳⣄⠀⠙⢆⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⡰⠃⠀⡴⠃⠀⠀⠀⠀⠈⢦⡀⠈⠳⡄⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⣸⠳⣤⠎⠀⠀⠀⠀⠀⠀⠀⠀⠙⢄⡤⢯⡀⠀⠀⠀⠀⠀⠀ ⠀⠐⡇⠸⡅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⡆⢳⠀⠀⠀⠀⠀⠀ ⠀⠀⠹⡄⠹⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣇⠸⡆⠀⠀⠀⠀⠀ ⠀⠀⠀⠹⡄⢳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡀⣧⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⢹⡤⠳⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣷⠚⣆⠀⠀⠀⠀ ⠀⠀⠀⡠⠊⠉⠉⢹⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡎⠉⠀⠙⢦⡀⠀ ⠀⠀⠾⠤⠤⠶⠒⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠒⠲⠤⠽ 提示：以下是本篇文章正文内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6abb244d39b637861bc95b7cc088962c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e0fd5833b485d4ca45a872c4528e2b0/" rel="bookmark">
			如何用两台二层交换机实现不同vlan之间的通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		老四留的作业，老师最近狂迷于chatgpt，没办法，我也去问chantgpt
1.老师给的拓扑图是这样的 分析如下
2.pc1的配置如下 3.pc2的配置如下配置完后记得点应用 3.然后： 打开交换机lsw1
sys vlan batch 55 56 int g0/0/1 port link-type access port default vlan 55 int g0/0/2 port link-type trunk port trunk allow-pass vlan 55 56 int vlanif 55 ip address 192.168.1.254 24 int vlanif 56 ip address 192.168.2.254 24 q 虚拟端口的ip要和对应的虚拟vlan网关相同。
4.进入交换机2 sys vlan batch 55 56 int g0/0/2 port link-type access port default vlan 56 int g0/0/1 port link-type trunk port trunk allow-pass vlan 55 56 q 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e0fd5833b485d4ca45a872c4528e2b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3113c6769fc3eeb92aacf1978e2f7cd9/" rel="bookmark">
			Android应用开发基础—实现一个简易的计算器学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、设计思路
布局：
后台：
三、演示：
四、总结
一、前言 学习目标：根据课程所学的相关知识，完成一个简易的计算器，并实现一定的功能。
工具环境：Android studio、Java语言
实现功能：
1.完成简单的页面布局，要有数字、加、减、乘、除、删除、清零等基本按钮
2.完成后台对有关功能的基本实现
二、设计思路 布局： 1.新建一个Android Studio项目，并创建一个Activity用于显示计算器的UI界面
2.在布局文件中添加TextView用于显示用户输入的表达式和计算结果，以及多个Button控件用于用户的操作。
一、布局使用GridLayout完成布局：
1.整体布局放一个GridLayout，其中：
（1）第一个GridLayout放入两个编辑框，作为计算器的结果框和输入过程框
&lt;GridLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical" &gt; &lt;EditText android:id="@+id/ed_input" android:layout_width="match_parent" android:layout_height="100dp" android:hint="输入框" /&gt; &lt;EditText android:id="@+id/ed_output" android:layout_width="match_parent" android:layout_height="100dp" android:hint="输出口" /&gt; &lt;/GridLayout&gt; （2）第二个GridLayout放入操作的按钮
&lt;GridLayout android:layout_width="match_parent" android:layout_height="304dp" android:columnCount="4" android:rowCount="4"&gt; &lt;Button android:id="@+id/buttonc" android:layout_width="180dp" android:layout_height="60dp" android:layout_columnSpan="2" android:backgroundTint="#a6a6a6" android:text="c" /&gt; &lt;Button android:id="@+id/buttondel" android:layout_width="90dp" android:layout_height="60dp" android:layout_columnSpan="1" android:backgroundTint="#a6a6a6" android:text="DEL" /&gt; &lt;Button android:id="@+id/buttonchu" android:layout_width="90dp" android:layout_height="60dp" android:backgroundTint="#ff9500" android:text="/" /&gt; &lt;Button android:id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3113c6769fc3eeb92aacf1978e2f7cd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0e6816a7f709f0e76b7f575db23ef86/" rel="bookmark">
			2023年的深度学习入门指南(17) - 深度学习的硬件加速技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年的深度学习入门指南(17) - 深度学习的硬件加速技术 有了前面的知识之后，想必大家对于算力需求的理解已经越来越深刻了。
除了使用CPU，GPU这样的通用器件之外，采用专用的硬件来进行加速是一个大家都能想到的选择。
其中的代表器件就是我们上一节刚刚用到的TPU。下图是TPU的样子及其结构图：
那么，TPU为什么设计成以矩阵乘法为核心呢？我们先从深度学习的原理开始了解一下。
神经网络和注意力的计算方法 人工神经网络的基本计算单元是神经元。每个神经元的结构如下图所示：
用公式来表示就是：
y j = Φ ( ∑ k = 0 n − 1 x k w k j + b ) y_j=\Phi\left(\sum_{k=0}^{n-1} x_k w_{k j}+b\right) yj​=Φ(∑k=0n−1​xk​wkj​+b)
其中， x k x_k xk​是输入， w k j w_{k j} wkj​是权重， b b b是偏置， Φ \Phi Φ是激活函数， y j y_j yj​是输出。
我们可以看到，每个神经元的计算都是一个矩阵乘法加上一个偏置，再经过一个激活函数。
我们再复习一下之前讲多头自注意力模型的结构图：
我们可以看到，主要的计算仍然是矩阵乘法和加法。
Q u e r y : Q i = X ∗ W i Q Query: Q_i = X * W_i^{Q} Query:Qi​=X∗WiQ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0e6816a7f709f0e76b7f575db23ef86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f05816283cc5c9615c2972de6dfe02a6/" rel="bookmark">
			DES/MD5加解密方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		private const string Key = "自定义秘钥"; /// &lt;summary&gt; /// DES+Base64加密 /// &lt;para&gt;采用ECB、PKCS7&lt;/para&gt; /// &lt;/summary&gt; /// &lt;param name="encryptString"&gt;加密字符串&lt;/param&gt; /// &lt;param name="key"&gt;秘钥&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string Encrypt(string encryptString, string key = null) { return Encrypt(encryptString, key, false, true); } /// &lt;summary&gt; /// DES+Base64解密 /// &lt;para&gt;采用ECB、PKCS7&lt;/para&gt; /// &lt;/summary&gt; /// &lt;param name="decryptString"&gt;解密字符串&lt;/param&gt; /// &lt;param name="key"&gt;秘钥&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string Decrypt(string decryptString, string key = null) { return Decrypt(decryptString, key, false); } /// &lt;summary&gt; /// DES+16进制加密 /// &lt;para&gt;采用ECB、PKCS7&lt;/para&gt; /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f05816283cc5c9615c2972de6dfe02a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc4261ad480f1a44b29769cd1c8b8b51/" rel="bookmark">
			JDK1.8环境安装及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK1.8环境安装及配置 一、下载JDK1.8二、安装三、环境变量配置四、验证 一、下载JDK1.8 本教程使用的是8u202版本，若需要其他版本可点击下方链接跳转下载。
Oracle下载，点击跳转选择版本 如下图所示，选择自己需要的版本下载
点击8u202版本 下载 二、安装 双击后等待开始安装 下一步，选择安装位置，默认安装C盘 这里的安装位置是jdk的路径
在该过程中可能会弹出如下提示框 确定即可，该提示信息为java许可信息的更改，从8u211及之后版本的协议更改，商用收费
确定后若弹出另一提示，将安装路径修改为上面路径的同级即可，点击下一步。如下图所示
这里的安装路径是jre的路径。
我这里两次路径的选择如图所示
等待安装完成
三、环境变量配置 右键此电脑，点击属性 选择高级系统设置 选择环境变量 点击新建 变量名JAVA_HOME，变量值为jdk安装目录，点击浏览目录选择自己的安装路径，如下所示 解释： Classpath是Java虚拟机（JVM）用于查找类文件和资源文件的路径。它是一个包含目录路径和JAR文件路径的集合，用于告诉JVM在哪里查找需要加载的类和资源。当你在Java程序中使用import语句引入其他类时，JVM就会根据classpath来定位这些类所在的位置。通过配置classpath，你可以指定类文件和资源文件所在的目录或JAR文件的位置。
选中Path变量，点击编辑 解释： Path是操作系统用于查找可执行程序的路径。在Java开发中，Path环境变量用于告诉操作系统在哪里找到Java编译器（javac）和Java虚拟机（java）。当你在命令行中执行javac或java命令时，操作系统会根据Path变量中的路径来查找这些可执行程序。通过将Java的安装路径添加到Path变量中，你可以在任何位置运行Java编译器和虚拟机，而不需要指定完整的路径。
点击新建，输入以下内容%JAVA_HOME%\bin , %JAVA_HOME%\jre\bin; 返回系统变量，新建CLASSPATH变量，变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
解释： JAVA_HOME是指向Java安装目录的环境变量。它在配置Java开发环境时非常有用。JAVA_HOME变量的设置可以告诉各种开发工具和应用程序Java的安装路径。许多Java开发工具（如IDE和构建工具）会使用JAVA_HOME来定位Java的安装位置，以便正确地配置和使用Java编译器和运行时环境。 四、验证 Win+R 快捷键输入cmd打开命令行，输入java，javac，java -version 即可查看java相关命令，以及当前jdk版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5339d7838ad627b92da0b41930e18fc/" rel="bookmark">
			java ee大作业校园二手交易平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是介绍期末大作业校园二手交易平台的功能和框架结构，有借鉴
1.注册。用户访问校园闲置物品交易平台时，如果没有登录，只能浏览商品信息，如果想要体验更完全的功能必须先登录或注册，在注册页面注册时，会先验证注册的用户名是否重复，如果重复就要换一个用户名，在点击提交时，会先验证表单填写是否完整，然后在检查相关信息的格式是否填写错误，最后再提交。
2.登录。用户输入正确用户名和密码登录网站，进而浏览主页面。发布商品。用户有闲置物品想要进行交易处理的时候，可以运用此功能，进入跳转页面，填写相应信息，发布自己的闲置物品。
举报评论。用户登录后可以点击想要查看的商品，点击后会显示商品的信息，用户感觉这个商品有一些违规信息，可以选择举报或评论，并填写合适的理由。
3.求购商品。当用户在网站的主页面上没有找到自己需要的商品时，可以运用此功能，进入跳转页面，填写相应信息，发布自己所求购的闲置物品，当有用户正好有此闲置物品就会主动联系。
校园闲置物品交易平台使用了相对方便的B/S架构模式，这是目前为止最适合本系统的架构，在此基础上运用Springboot框架，整合MySQL、Bootstrap等技术，只需简单的项目配置，即可进行开发。经过分析可得，系统需要进行前后端分离的模式，以便不同的角色应用此系统。其活动图详细情形见图4-1所示。
图 4-1 系统活动图
校园闲置物品交易平台顶层数据流图将输出和输入的数据流作为为系统平台的输入和输出数据，表明校园闲置物品交易平台的范围，以及与系统平台的数据交换关系。管理员登入系统之后，通过向系统发送请求，对系统进行对应操作。用户输入用户信息进行登录验证以及操作请求也可以对系统进行访问，而校园闲置物品交易平台可以将系统管理员发布的公告向用户进行推送，用户可以进行查阅。系统顶层数据流图详细情形如图4-2所示。
图 4-2 顶层数据流图
0层数据流图的作用在于更详细的表述系统与数据表之间的联系。管理员通过向系统发送请求进行系统管理，在此期间系统从数据库中获取数据来配合管理员进行的系统的操作。而用户从数据信息表中接收数据信息，进行查阅以及修改个人信息，还会将用户提交的其余操作请求提交给管理中心并储存在数据库当中，还会从数据信息表中获取的系统通知显示给用户，用户和数据信息是在安全的情况进行连接以及双向获取和存储。如果数据没有正常获取显示，将会导致管理员或者用户的操作无效，也会在页面显示部分显示空白等情况。0层数据流图详细情形如图4-3所示。
图 4-3 0层数据流图
4.1.1 前端框架设计
系统的前端就是让用户进行体验使用的，在经过Bootstrap的页面布局与渲染下，将文字、图片等内容信息呈现给用户，设计成简洁大方的网站，让系统对于用户来说具有良好的交互体验。在符合系统规定情况下，用户可以注册账号在此页面上进行挑选闲置物品，通过相关交流并达成交易。主要包括登录注册功能，求购商品功能，发布商品功能，举报功能，评论功能和管理个人信息等功能来服务用户进行良好的交易。系统用户结构功能图如图4-4所示。
图 4-4 用户结构图
4.1.2 后端框架设计
后端主要是提供给管理员进行使用，通过用户、管理、权限之间的联系与差异，让管理员可以在后端就收从前端传输的数据，然后通过对数据信息的处理，改变在数据库可视化工具和前端页面中的UI显示。管理员对系统进行更新与维护，保证平台的稳定与性能。校园闲置物品交易平台管理员是在后台进行操作与系统发生交互的，管理员主要是对数据库的数据表进行操作，管理员模块主要包括系统设置功能、物品管理功能、学生管理功能、评论管理功能、举报管理功能、新闻公告等功能。这些功能通过轻度耦合的方式建立起关联关系，保障系统正常服务用户学生使用。系统管理员结构功能图如图4-5所示。
图 4-5 管理员结构图
4.2 系统功能模块设计
4.2.1 前端功能模块设计
登录注册功能模块。用户在浏览器进入系统的主界面，此时除可以浏览观看已发布的商品，所以要想有下一步的操作必须注册账号进行登录，如果信息输入不全或有误则会有相对应的提示，必须填写完整修改无误之后才可以进行注册。注册成功之后就会在数据库表中填写所输入的正确信息，然后根据相应的权限进行页面跳转进入对应的页面，从而使用户进行下一步的操作，所以注册登录是进入系统的前提条件。
发布商品功能模块。用户有闲置物品想要进行交易处理的时候，可以进入发布商品页面。此页面就是让用户处理手中的闲置物品，当有想要购买此商品的用户在主页看见发布的信息可以进行联系，从而达成交易。在发布商品模块中，用户可以通过对商品的真实图片的写实外加客观的描述，以及合理的价格吸引其他用户的注意力，让其他用户产生购买的欲望从而使自己手中的物品可以促销出去，做到真正互惠互利，让闲置物品可以循环利用。
举报功能模块。为了保障用户有个良好的交易体验，当在主页发现已发布的商品有违规，已登录的用户只需点击“举报”即可进行举报，经管理员核实，进行下架处理。此功能模块在系统的存在是有重大意义的，一个系统的存在必须是合规合法，保障用户利益，如果全由发布者的描述，很难保持真实客观的表达，而举报功能的实现就是让其引起管理员的注意，对商品及时下架，以免产生不利影响。
求购商品功能模块。当用户在网站的主页面上没有找到自己需要的商品时，可以根据页面所提示内容，在此模块上发布求购信息，经管理员审核成功，将之发布，发布成功之后将信息记录在数据库内，这样拥有此商品的用户看见发布的信息可以进行联系，从而达成交易。此功能就是相当于求助信息，通过此功能可以得到商品主页没有发布，用户又需求的商品。
评论功能模块。通过用户精心的评论可以提高商品的价值，拥有高评论的商品不仅可以使用户更加细致的了解商品的功能，还会提高其他用户的兴趣，获得更多用户关注，从而导致商品的促销，而且也会增加用户对此系统的粘性。当然除此之外，还要控制恶意评价，防止因其他用户的不实言论对商品以及系统造成不良影响，所以管理员应及时处理做到公平公正。
4.2.2 后端功能模块设计
系统设置功能模块。主要就是对系统、菜单、用户、还有数据库中的数据，产生的日志进行的管理，可以说此模块涉及到了系统的核心，没有此设计，系统将管理起来极其复杂。超级管理员可以在此模块上对系统的后台进行修改，以及添加普通管理员及任意权利的管理员，将权利下放，减缓压力。同时还可以观看日志，以及对系统数据的备份、删除以及还原等操作。
物品管理功能模块。包含了分类管理、物品管理等功能。拥有此权限的管理员可以对系统主页商品的分类做出更改，便于商品的更新换代，让系统与时俱进。物品管理则是对所上架的商品进行增删改查、推荐等功能，防止商品发生已售出仍在架的情况。求购物品则是对用户所求购的商品进行管理，防止用户发布违规求购、和已经购入但求购信息依旧存在，造成系统数据的冗余，给用户造成不良影响，从而降低用户对整个系统的满意度。
学生管理功能模块。主要就是对注册的用户也就是学生进行管理。管理员可以根据实时状况对已经注册的学生用户的账号进行相对应的操作，对于忘记密码的用户可告知管理员进行密码查找，从而找回账号。但是管理员也应及时处理，以免因账号问题处理的不及时造成用户的反感。同时对于注册用户较多，查找不便的情况，还可以应用搜索框精确查找。除此之外，此功能也能删除冻结一些违规账号，避免一些别有用心的用户给系统造成恶劣的影响。
评论管理功能模块。包含了评论列表。作为系统的管理员有权将一些违规和老旧的评论进行删除操作，避免因一些人胡言乱语影响到了整个系统适用人群，造成用户的流失。当用户增多就会造成评论较多，如果出现查找某条评论很困难的情况，还可以应用搜索框快捷查找，这样可以快速的查找所需的评论。
举报管理功能模块。主要就是对于商品的举报，存在于系统之中的商品并不都是符合规定的，总会有一些“漏网之鱼”会存在于系统之中，在管理员没有及时发现之时，就需要用户的举报提醒管理员此商品存在违规信息，在管理员经核实处理之后可以运用删除功能将其删除。此功能的存在目的就是让用户远离一些不符合规定的商品，避免上当受骗，对系统的声誉造成影响。同时对于举报较多，查找不便的情况，还可以应用搜索框快捷查找。
新闻公告功能模块。主要就是发布公告列表。管理员可以在此添加、编辑、删除一些规则，也可以将系统更新公告发布与此，此功能处理系统更新可能会造成用户短时间的不适应的问题，以便用户参考，与此同时，将此公告陈列到系统较为突出的地方，以便用户可以第一眼看到。管理员对此拥有同时对于公告较多，查找不便的情况，还可以应用搜索框快捷查找。
4.3 系统数据库设计
4.3.1 数据库E-R图设计
数据库设计就是把面向对象的方法和数据库联合一起，能够对数据库简单的分析，方便数据库开发人员与用户之间的沟通。合理的实体图能够有效的帮助开发者理清设计思路，快速构建项目。校园闲置物品交易平台设计主要的实体就是用户、管理员、商品、公告、评论等实体。各实体之间通过联系共同组成数据库，其中一个用户可以发布多条评论属于一对多关系，管理员发布公告、用户查看公告、用户添加商品、管理员审核商品和用户和管理员之间都是属于多对多关系。校园闲置物品交易平台总体E-R图详细情形如图4-6所示。
图 4-6 数据库E-R图
4.4 前台功能模块实现
4.4.1 登录注册模块
登录功能的实现，打开系统之后进入登录界面，输入数据库对应的用户名实现登录。登录成功之后进入到系统主界面，然后可以进行相关功能性操作。校园闲置物品交易平台登录注册功能具体详情如图4-7所示。
图 4-7 登录注册图
4.4.2 发布商品模块
发布商品功能模块的实现，用户根据系统提示填写相关信息，正确无误之后，点击发布即可发布商品。页面具体详情如图4-8所示。
图 4-8 发布商品图
4.4.3 求购商品模块
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5339d7838ad627b92da0b41930e18fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9104bab5e92650ab2fd02785921fae94/" rel="bookmark">
			Linux中安装rpm格式的jdk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.自行下载rpm格式的jdk并将其通过Xshell上传到linux服务器中
2.传入linux服务器中后ls显示存在该文件
3.使用命令yum install jdk-7u40-linux-x64.rpm进行安装
4.cd /usr/java/再ls查看是否存在jdk
5.javac查看jdk运行情况
6.java -version查看jdk版本号，有的话说明已经安装成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcc182577280c764b4ee692a14ae4b20/" rel="bookmark">
			生物信息学——常见的OrgDB包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 物种OrgDB人（Humanm)org.Hs.eg.db小鼠（Mouse）org.Mm.eg.db猪（Pig)org.Ss.eg.db按蚊（Anopheles）org.Ag.eg.db拟南芥（Arabidopsis）org.At.tair.db牛（Brovine)org.Bt.eg.db蠕虫（Worm）org.Ce.eg.db犬（Canine）org.Cf.eg.db苍蝇（Fly)org.Dm.eg.db斑马鱼（Zebrafish）org.Dr.eg.db大肠杆菌strain K12（E coli strain K12）org.EcK12.eg.db大肠杆菌strain Sakai(E coli strain Sakai)org.EcSakai.eg.db鸡（Chicken）org.Gg.eg.db恒河猴（Rhesus）org.Mmu.eg.db疟原虫（Malaria）org.Pf.plasmo.db黑猩猩（Chimp）org.Pt.eg.db大鼠，褐家鼠（Rat)org.Rn.eg.db酵母（Yeast)org.Sc.sgd.db爪蟾(Xenopus)org.Xl.eg.db 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb89444512e17f8a909c11b0379a4c72/" rel="bookmark">
			Mysql find_in_set()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、find_in_set函数的语法 FIND_IN_SET(str,strlist)
str--查询的字符串
strlist---字段名，参数以”,”分隔 如:(1,2,6,8)
查询字段(strlist)中包含(str)的结果，返回结果为null或记录
例：
SELECT FIND_IN_SET('c', 'a,d,c,b'); -&gt; 3 因为c 在strlist集合中放在3的位置 从1开始
2、与in/like的区别 in常用于where中，用来查询范围内的数据，范围的值必须为常量，可以走索引。
用法：select * from table where field in (value1,value2,value3,…)
例：
// 1.查询的是范围数据 // 2.查询的值必须是常量 select * from t1 where id in (2,3,4,5); select * from t1 where name in ('张三','李四'); like是模糊匹配，可以走索引
用法：select * from table where field like '%value%'
例：
SELECT * FROM `user01` where `name` LIKE '%4%' 3、与in/like查询结果对比 一张user01表，表数据如下：
查询name中有4的数据结果如下：
in查询
SELECT * FROM `user01` where `name` in (4); 查询结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb89444512e17f8a909c11b0379a4c72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bebd2cc0cf7da4ddd46d721a22d1996/" rel="bookmark">
			（五）Langchain PGVector 补充智能客服匹配式问答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 资料背景目标FAQ-匹配式问答安装PGVector 向量数据库text2vec-large-chineseLangchain-PGVector测试向量化文本写入QA问答对特别注意问题langchain pgvector表和数据相识性问题匹配 PGSQL扩展知识 结论 资料 NLP领域五大QA问答场景总结：FQA、DOC-QA、KBQA、TableQA、TaskQA等场景概述与对比解析Langchain PGVector使用文档pgvector 背景 最近在做智能客服，通过 https://github.com/imClumsyPanda/langchain-ChatGLM 可以完成DOC-QA 部分智能问答
摘要项目原理说明
本项目实现原理如下图所示，过程包括加载文件 -&gt; 读取文本 -&gt; 文本分割 -&gt; 文本向量化 -&gt; 问句向量化 -&gt; 在文本向量中匹配出与问句向量最相似的top k个 -&gt; 匹配出的文本作为上下文和问题一起添加到prompt中 -&gt; 提交给LLM生成回答。
其中注意介绍中的这一句，在文本向量中匹配出与问句向量最相似的top k个，也就是第7和第10个步骤，有几个问题在实践中需要解决
测试过程中大部分答案还是满意的，但是由于原始文档切割，部分答案会丢失上下文（切割没了，top k也没匹配出来）固定的问答对很难保障，比如操作流程，这种需求内容长且要求答案文本顺序不能乱文本上下文存在复杂的内容，比如图片，音频，视频，需要处理才能让大模型呈现FAISS 向量库不支持matedata过滤，在复杂度更高的场景失去灵活性FAISS 不支持单条语句删除或更新 为了问答质量效果，既要保障高质量语料，也得寻求匹配式问答解决方案，这才选择了Langchain PGVector 补充智能客服匹配式问答
目标 先让用户的问题，匹配问答中的问题（多问一答），相同的问题意图需要泛化，如果问题相识度满足一定的阈值，则返回问题对应的答案，如果不满足相关度阈值，则把问题提交给文档问答库（适合有一定的业务文档积累场景）作为兜底，同样的也需要满足一定的相关度top k
FAQ-匹配式问答 安装PGVector 向量数据库 什么是 pgvector ？ Postgres的开源向量相似性搜索，支持
精确和近似最近邻搜索L2 距离、内积和余弦距离任何带有Postgres客户端的语言 为了快速验证可行性，使用 https://github.com/pgvector/pgvector 中docker方法启动项目
FROM ankane/pgvector LABEL maintainer="Ben M &lt;git@bmagg.com&gt;" CMD ["postgres"] EXPOSE 5432 构建启动docker
docker build -t pgvector .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bebd2cc0cf7da4ddd46d721a22d1996/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb81bc4d630f7609130557cd9d1f31da/" rel="bookmark">
			阿里云对象存储OSS迁移流程(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景信息 阿里云在线迁移服务是阿里云提供的存储产品数据通道。使用在线迁移服务，您可以将第三方数据轻松迁移至阿里云对象存储OSS，也可以在对象存储OSS之间进行灵活的数据迁移。
使用在线迁移服务，您只需在控制台填写源数据地址和目的OSS地址信息，并创建迁移任务即可。启动迁移后，您可以通过控制台管理迁移任务，查看迁移进度、流量等信息。
迁移流程如下图所示： OSS之间迁移，会全链路做CRC64校验。 如果源端支持CRC32、CRC64或MD5校验，则会根据源端校验方式全链路做校验。如果源端不支持CRC32、CRC64或MD5校验，则源端到在线迁移服务之间不做校验，无法保证下载数据的正确性、完整性，在线迁移服务到目的端之间依然会进行CRC64校验。 出于数据安全性和一致性考虑，建议您使用HTTPS，确保传输链路中的数据安全。创建迁移任务流程如下图所示： 重要
创建目标存储空间 创建目标存储空间，用于存放迁移的数据。具体操作，请参见创建存储空间。
创建RAM用户并授予相关权限 说明 如果需要跨账号迁移数据，请分别在源阿里云账号和目标阿里云账号创建相应RAM用户并授予相关权限。
数据地址与控制台同Region时，推荐选择internal内网Endpoint。当源端和目的端数据地址都选择internal内网Endpoint时，数据上传和下载均在阿里云内网中进行，不会产生流量费用。数据地址与控制台跨Region时，只能选择公网Endpoint。当源端和目的端数据地址都选择公网Endpoint时，数据上传和下载均在公网进行，迁移时会在源端产生下行流量费用，不产生上传费用。OSS之间的数据迁移，源地址不支持存储类型为归档或冷归档的文件迁移。 准备工作 解冻源存储空间待迁移数据
对于归档和冷归档类型的数据，需要您进行解冻操作，待解冻完成后再新建迁移任务。在线迁移服务并不会对源端数据执行解冻操作。若您源端有未解冻、解冻中的文件，则这些文件都会迁移失败。归档和冷归档类型的数据解冻请参见归档迁移方案。说明
请您务必完成解冻操作后再创建源数据地址和迁移任务。请您根据待迁移的数据总量确保解冻时长，以防迁移期间数据再次变成冻结状态。解冻操作可能会收取一定的费用，计费规则可咨询您的源站存储服务提供商。登录RAM控制台。在左侧导航栏，选择身份管理 &gt; 用户。在用户页面，单击创建用户。在创建用户页面的用户账号信息区域，输入登录名称和显示名称。在访问方式区域，选中控制台访问和OpenAPI调用访问。并保存生成的账号、密码、AccessKey ID和AccessKey Secret。 控制台访问：设置控制台密码、需要重置密码和MFA多因素认证。OpenAPI调用访问：自动为RAM用户生成访问密钥（AccessKey），支持通过API或其他开发工具进行访问。说明 如果需要跨账号迁移数据，请分别保存源阿里云账号和目标阿里云账号生成的RAM用户对应的账号、密码、AccessKey ID和AccessKey Secret。
创建RAM用户成功后，在用户页面，单击目标RAM用户操作列的添加权限，授予RAM用户存储空间读写权限（AliyunOSSFullAccess）。授权完成后，在左侧导航栏，单击概览。在账号管理区域，单击用户登录地址下的链接，使用刚创建的RAM用户的用户名和密码进行登录。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb9ccee8195cf496e9f250fe793c1204/" rel="bookmark">
			基于51单片机的数字时钟设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、总体概述
1、计时控制方案
2、主控制器模块
3、显示电路模块
4、调试按键模块
5、电源模块
6、闹钟声光报警模块
二、系统总体结构
1.电路图
三、系统的硬件设计与实现
1、电源电路
2、显示电路
3、单片机基本电路
4、按键电路
四、功能测试及结果分析
五、程序附录
一、总体概述 摘 要
本设计采用89S52系列单片机作为时钟的控制核心，电路使用了八个数码管作为时钟显示，用计数器中断程序作为了一秒钟的精确计数，并用按钮实现了调闹钟时间和时钟时间的校对功能。
关键词：单片机、控制、显示、调时。
Abstract
This design's adopting a single slice of the 89 S52 serieses machine is the control core of the clock, the electric circuit used eight piece code tubes as the clock manifestations,
The precision that used to count the machine interruption procedure conduct and actions for a second count, counteracting a button to carry out to adjust check of the alarm clock time and the clock time function.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb9ccee8195cf496e9f250fe793c1204/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8bc935a8c1efe95f17769307dd96285/" rel="bookmark">
			CCD 技术介绍（基于innovus引擎CCOpt）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： Ø CCOpt 概念 Ø 传统 CTS 介绍 Ø CCOpt 技术介绍 Ø CCOpt 优化流程 Ø Worst Chain Analysis 概念介绍 CCD ： 全称是 Concurrent Clock Datapath ，并行优化 clock 和 data path 。 CCOpt ： 全称是 Clock Concurrent Optimization clock 的timing 分为两种模式， ideal clock 和 propagated clock 。 pre CTS 并没有 clock, 因此需要建立一个 ideal clock ，从 clock 端口到寄存器 CK 端的 network delay 来自 sdc 中的 set_clock_latency 设置； post CTS update IO latency ， clock 就会自动的转换成 propagated clock ，这时 network delay 就是实际时钟互连线网络的 RC extraction delay 。 在实际设计中， clock 起始于 ideal 模式，并以 propagated 模式结束。如下图所示： 传统 CTS 介绍 对传统的flop to flop之间的电路，setup和hold time需要满足以下两个条件，如图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8bc935a8c1efe95f17769307dd96285/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1ed09a2b31771afff4a073fd6c3034f/" rel="bookmark">
			三、Kafka的消费全流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka的消费全流程 我们接着继续去理解最后这条消息是如何被消费者消费掉的。其中最核心的有以下内容。
1、多线程安全问题
2、群组协调
3、分区再均衡
多线程安全问题 当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。
对于线程安全，还可以进一步定义：
当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替进行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。
生产者 KafkaProducer的实现是线程安全的。
KafkaProducer就是一个不可变类。线程安全的，可以在多个线程中共享单个KafkaProducer实例
所有字段用private final修饰，且不提供任何修改方法，这种方式可以确保多线程安全。
如何节约资源的多线程使用KafkaProducer实例
package com.msb.concurrent; import com.msb.selfserial.User; import org.apache.kafka.clients.producer.Callback; import org.apache.kafka.clients.producer.KafkaProducer; import org.apache.kafka.clients.producer.ProducerRecord; import org.apache.kafka.clients.producer.RecordMetadata; import org.apache.kafka.common.serialization.StringSerializer; import java.util.Properties; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * 类说明：多线程下使用生产者 */ public class KafkaConProducer { //发送消息的个数 private static final int MSG_SIZE = 1000; //负责发送消息的线程池 private static ExecutorService executorService = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors()); private static CountDownLatch countDownLatch = new CountDownLatch(MSG_SIZE); private static User makeUser(int id){ User user = new User(id); String userName = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1ed09a2b31771afff4a073fd6c3034f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ba93dadfde9a3819700b7a65b6b1853/" rel="bookmark">
			yolov7模型部署——环境搭建(python 导出onnx模型，c# OnnxRunTime-GPU版调用) 踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，导出onnx模块 1.1 运行python .\export.py导出onnx模块 yolov7提供了简单的点对点预测，不需要再重新写NMS，非常方便，于是当然采用--end2end方法啦，命令如下图：
运行时发现没装onnx, 那就安装好了
1.2 安装onnx conda install -c conda-forge onnx
但是！又出现了这个问题
原因是__int__()需要2到7个参数，但给了8个参数。查看代码export.py 159行，确实是8个参数：
修改为义下代码：
问题解决。
2，.NET C# Microsoft.ML.OnnxRuntime.GPU版调用onnx模型 2.1 安装onnxruntime Nuget c#版onnxruntime安装：VS-&gt;工具-&gt;NuGet包管理器-&gt;管理解决方案的NuGet程序包
公主用的GPU版本，安装好了（记住，这里有个坑，公主用了好几天时间才把这个坑填上T_T）
貌似岁月静好，根据ONNX RUNTIME官网的提示配置了CUDA GPU的选项，然而~~~写了个小demo运行时出现了找不到“OrtGetApiBase”入口点的问题：
找不到入口点，最直接的就是dll的函数名变了呗，用dllimport解决！然而，用VS自带的dumpbin.exe查看函数的入口点函数名，名称并没有改变：
公主很抓狂，难道是依赖问题？DW查看依赖包，hin好，又是一堆飘红：
网上查了查，这里说明原来是DW不维护了的原因：
看了下，飘红的全是上述几个类型的包，也就是说依赖包也没有问题。继续查：终于有人遇到和我一样的问题了，他是这么解决的： 可是，人家估计是个大项目，我只是一个小demo，项目本身就是启动项目了。所以这个方案也pass掉。继续查看代码：引用块中妥妥的引用了
，程序运行的时候也加载了模块
model list中也都存在了.
公主真的快把头发薅光了~~~想摔桌子~~~一直到偶然看到这里
真的想哭啊~~~~所以，查对文章很重要！！！为什么官网不介绍（至少我没找到）？为什么到处都说cpu版只能用在cpu上，gpu版本的既能用cpu也能用gpu？ 坑爹啊~~~！！！火速装好，onnxruntime。果然入口点的问题解决了！
然而，又出现了新问题：
以为是版本问题，按照官网介绍重新卸载安装CUDA 11.4.4版本，一定要是11.4.4才能满足Notes提到的版本。ONNXRuntime也改成1.12版。
然并卵~~~ 查看了下，visual studio模板中并没有CUDA的模板，难道因为cuda并没有装载到visual studio上？难道不是自动装载的吗？更新了下visual studio的配置：
模板出现了：
然鹅，问题并没有解决。公主实在没办法了，网上资料甚少。直接在github上发邮件给作者，member回复的非常及时，一下子就指出了痛点，说我还是用的CPU 包：
赶紧去bin/debug下查看dll包，确实是CPU版的。得！！！问题又回去了，安装上就用的是CPU包，不安装就有Entry point 问题~~~~~~
公主抱着试试看的态度，按照这个list重新升级安装了依赖包
然后删除了CPU版的onnxruntime。果然通过了，喜极而泣！！！上一张缺陷检测demo效果图：
PS：公主训练照片的尺寸是512*512, 实际预测时用的照片尺寸是1024*1024，但准确率也还是8错哒！！！！！
T_T 难受，想哭~~~~~~这个破玩意整了四天，吃饭睡觉都在想着要怎么解决。公主都想说实在不行用python把项目重构一次直接用python算了~~~~还好还好，给自己点个赞顺便去吃顿火锅犒劳一下自己。还是想哭T_T
代码有时间整理一篇博客出来，公主根据yolov7官方python代码一点点整理翻译成c#的，也是耗费了巨大的精力T_T。换平台调用实在是太坑了！！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3ae5353ea617ead419aaa16fc152b8e/" rel="bookmark">
			平衡小车学习教程1——硬件资源及其小车底层硬件介绍篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起因 大家在学会了Stm32后，可以做一个项目来进行来进行练手，平衡小车就是一个很好的练手项目，可以检验自己的学习成果，也可以对学习到的知识进行一个复习。再一个就是通过做项目来锻炼自己的工程能力。
好啦，废话不多说，本套教程预计分为两部分，硬件底层介绍篇和软件移植篇，经过这两个部分的学习，大家可以体会软硬件资源如何相互配合，在本教程的基础上快速做成自己的第一辆平衡小车。
当然，博主抽空更新啦，最近期末，要准备课程考试和课程设计，大家可以期待一下下
一、制作平衡小车所需要的模块选型 1、小车底板及带有编码器电机 推荐方案 小车底板 大家可以选择到淘宝自行购买平衡小车底板，如下图所示，一般如果不加电机的话，价格在30元左右，加上电机的话大概在130左右
带有编码器的电机 只要选择带有编码器的减速直流电机即可，大家注意要选择带有支架和轮胎的，不然买回来就只有一个电机，轮胎和支架还要另外买，查看淘宝的价格，两个带编码器的电机大约在120元左右
我的方案 小车底板 自己纯手工制作，直接采用的绿色洞洞板，自己使用螺丝挖孔，采用铜柱作为支撑
编码器电机 使用实验室的电机，型号为JGB37520电机，65mm大轮胎
2、电机驱动 推荐方案 使用TB6612FNG电机驱动模块,我认为这个电机驱动比较好用，就是要注意使用，一不小心就烧了，驱动倒是不贵嘞，但是可能会把MCU烧了噢
3、电源以及稳压模块 推荐方案 电池 1.采用3S航模电池，就是价格有点小贵,价格大概在50元左右
大家一定要注意转接头是否匹配，多买几条相应的转接头，有XT60、JST、T插等接口
2.大家也可以选择下图18650电池组，12V输出，电流参数大家可以自行选择
稳压 采用LM2596S-DC-DC可调模块,将12V电压降压成5V，给MCU和其他外设模块供电
4、OLED显示屏 这个就没什么好推荐的嘞，直接采用0.96OLED屏，主要是用来调试参数使用，查看陀螺仪角度等,大概10元左右
5、MCU 这个也请大家根据个人需求选择，可以选择Stm32单片机或者其他型号的单片机
我这里采用的是Stm32F103RCT6单片机，一般的Stm32F103C8T6就已经够用嘞
6、陀螺仪模块(MPU6050) 推荐方案 1、上淘宝买一个MPU6050，8脚的，大概价格在15元左右
2、采用ATK-MPU6050
原子家的MPU6050,6脚的,小贵，一个都快60块嘞，但是貌似精度更高？
由于手上有这个模块，就直接采用了原子家的
7、蓝牙模块 大家自行去淘宝购买，我选择的是HC-05，价格大概在20元左右
大家也可以选择购买HC-06/07/08等
二、集成上述模块，画出PCB 1、原理图 下图为集成模块，所画出的PCB,将各个模块进行继承整合，下图即为所使用到的硬件原理图
还添加了三个按钮，三个LED和一个蜂鸣器，扩展出了两个串口，这块板子很强，表扬一下硬件大哥
12V电压经过LM2596S DC-DC可调电压模块降压成5V,给外设和MCU供电
2、PCB PCB如下图所示,太棒了，硬件大哥非常给力，再次点赞
三、规划MCU的IO口资源，以及使用到的软件资源 1、电机及编码器 注意这里的规划资源是根据TB6612逻辑来进行使用的，但是其他驱动模块同理
PB12 PB13 PB14 PB15控制电机的正反转
PB6(TIM4-CH1) PB7(TIM4-CH2)控制电机转速
PA0(TIM2-CH1) PA1(TIM2-CH2) PA6(TIM3-CH1) PA7(TIM3-CH2)编码器读取脉冲
2、OLED OLED这里选择的是IIC通信的四脚OLED，可以随意选择两个通用IO,作为SCL和SDA引脚
PC5(SCL)
PC4(SDA)
3、MPU6050 MPU6050也是使用IIC通信的模块，有一个中断引脚INT，SCL引脚和SDA引脚
PB5(INT引脚)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3ae5353ea617ead419aaa16fc152b8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f561ff646bb59ea9a8209ae82bf2cdbe/" rel="bookmark">
			cookie和session
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cookie和session cookie 客户端技术，服务端返回一个信件，下次来带着就行了
关闭浏览器后,没有设置有效期的 cookie 会被清掉,设置了有效期的 cookie 会继续生效,直到过期时自动清掉（或手动清掉）
Session 服务端技术，服务器登记你来过，下次来的时候服务器匹配你，可以把信息和数据存在session了
（1）服务器会给每一个用户（浏览器）创建一个session
（2）一个session独占一个浏览器，关闭也会存在，可以设置过期时间
（3）用户登录后，整个网站都可以访问（保存用户信息）
区别 cookie是把用户的数据写给用户的浏览器，浏览器保存 重要信息
Session是把用户的数据写到用户独占的session，服务器保存 重要信息，减少服务器资源浪费）
maven项目转web项目:
https://www.jb51.net/article/184954.htm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06ea80f3606e81e4e7fc275c70cfcd10/" rel="bookmark">
			Mybatis-plus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欲买桂花同载酒，终不似，少年游。
添加mybatis-plu依赖 &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.1.tmp&lt;/version&gt; &lt;/dependency&gt; 程序运行 1、建pojo
2、建mapper 继承BaseMapper
3、加扫描
@MapperScan("com.pfj.mybatisplustest.mapper") @SpringBootApplication public class MybatisplusTestApplication { … } 4、测试代码
@Autowired private UserMapper userMapper; @Test void contextLoads() { List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println); } 配置日志 mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 执行测试：
￼
CRUD 插入
@Test void insrtUser(){ User user = new User(); user.setAge(3); user.setName("李克勤"); user.setEmail("9243435666@qq.com"); int id = userMapper.insert(user); //返回受影响的行数 } id是雪花算法生成的
雪花算法：开源分布式ID生成算法。结果是long型ID, 全球唯一
主键自增，配置主键：
1、字段添加TableId
2、数据库字段设置自增
@TableId(type = IdType.INPUT) private Long id ; 枚举： AUTO(0), //数据库自增 NONE(1), // 未设置主键 INPUT(2), //手动输入id，不写会写成null ASSIGN_ID(3), // ASSIGN_UUID(4), //UUID 修改
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06ea80f3606e81e4e7fc275c70cfcd10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfcb9e362baff27c8ae58c326d070c4e/" rel="bookmark">
			jmeter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 、jmeter基础 1、顺序执行和并发执行
勾选后顺序执行，否则会并发执行
2、setUp线程组和tearDown线程组
setUp优先执行，tearDown最后执行，不受勾选独立运行线程组影响
3、线程属性
线程数：模拟多少个用户并发执行
Ramp-Up时间：多长时间内启动完这些线程
循环次数：
勾选永远表示会一直执行，不勾选根据次数执行
勾选调度器：延迟3s后在2s内永远执行，不勾选一直执行；
二、参数化 1、用户定义变量
通过${变量}引用
2、CSV数据文件设置
CSV逗号分隔符，可以批量操作回车换行,如：
id1,name1,sex1,desc1
id2,name2,sex2,desc2
实现步骤：
a. CSV存储文件数据（UTF-8格式），如cvs.txt
b. 设置CVS数据文件
3、用户参数
a、编写脚本txt
b、使用参数存储
c、数据导入参数模板
d、设置执行次数
4、函数
计数器counter
生成随机数Random（闭区间）
生成时间
三、参数提取传递 线程组内提取
跨线程组提取（设置全局变量）
生成全局变量
设置全局变量
在另一个线程组获取全局变量
四、控制器 1、仅一次控制器
在每个线程内，该控制器下的内容只会执行一遍，无论循环多少次，都只会执行一遍。
比如：用户登录，只会登录一次，就可以将登录的请求放置在此控制器中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80e253d8777e1ce047c656db7feecd12/" rel="bookmark">
			2023年计算机视觉最不卷的方向：三维重建学习路线梳理！如何入门一览便知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近几年来，人工智能领域出现过很多热门的话题，有些热度持续很长时间，有些如同昙花一现，而随着机器人、自动驾驶、AR等技术的飞速发展，这些领域涌现了大量独角兽公司，开发出大量以3D感知、融合定位、重建、测距等多个应用场景的产品。三维重建这个名词也再次变得火热起来。
简单来说，三维重建（3D Reconstruction）是指用相机等传感器拍摄真实世界的物体、场景，并通过计算机视觉技术进行处理，从而得到物体的三维模型。
三维重建是增强现实（AR）、混合现实（MR）、机器人导航、自动驾驶等领域的核心技术之一。也同样，很多大厂在招聘相关岗位的时候都会要求掌握三维重建理论和技术。
作为一个交叉学科，三维重建涉及到高等数学、计算机视觉、计算机图形学等学科，涉及的主要技术有：多视图立体几何、深度图估计、点云处理、网格重建和优化、纹理贴图、马尔科夫随机场、图割等。
很多同学因为导师分配了这个方向，自己去一个人去啃算法框架，奈何无人指导没办法学通，导致很痛苦，3D算法内容多，学习曲线陡，还是需要一定的功力才能入门。
我们邀请在视觉测量、三维重建等方向有深厚经验的Hally老师，为大家讲解三维重建、成像原理及相机标定。Hally老师在业界和学界都有多年的扎实积累，可引导学生由传统视觉入门，逐步进入到深度学习领域的实战性转化以及熟悉各类视觉软件和计算库，如Open3d、PCL、opencv、SfM等。
扫描二维码领取公开课
三维重建最新论文合集
传统的重建方法是使用光度一致性等来计算稠密的三维信息。虽然这些方法在理想的Lambertian场景下，精度已经很高。但也有一些常见的局限性，例如弱纹理，高反光和重复纹理等，使得重建困难或重建的结果不完整。因此，传统三维重建方法在重建的完整性等方面仍有很大的改进空间。
另一方面，相机标定作为一种计算相机二维图像和三维世界相对映射关系的一种方法。毫不夸张的说，相机标定是一切是三维视觉的基础，它广泛应用于双目视觉、手眼机械臂、机器人定位建图、图像拼接、三维重建等场景。
扫码获取三维重建
相机标定免费公开课
领取最新CV顶会论文、书籍
研究各大厂招聘要求就会发现，有没有顶会论文已经成为一项重要的考核指标，而想要从科研小白变身顶会大神，我觉得有两点至关重要：
1、紧跟风口，把握住最近的热门研究风向。
尤其是对于科研还没什么思路的小白，顺着领域内的研究趋势确定自己的方向，是一个正确的选择，毕竟热门研究方向意味着，创新点和idea远比其他非热门领域多。比如刚刚推荐的画质增强。
2、有一位有经验有能力的前辈指导。选对一个好的老师，掌握正确的科研思路和写作方法！
都说SCI论文只有0篇和无数篇的区别，这句话告诉我们，其实做科研写论文也是有方法有套路可循，掌握了窍门，后面的路才会走得通畅。
但是作为一个小白，还在“蹒跚学步”阶段，怎么去掌握窍门？来自前辈的指点必不可少。
一个好的指导老师的作用是，没有课题，能够结合所在课题组具体情况，结合最近热门研究方向，帮你规划课题，如果有了课题而缺少创新方向，老师能够快速帮你找到几种切入点，几种框架，甚至连需要读哪些文献都帮你想好了......
为了论文，大家都在努力的设计新网络、新策略、新training算法，只要能够在某一问题上做到一个很好的performance，论文就水到渠成。而想要快速达到，来自前辈的指点不可或缺。
扫码获取大佬的科研指导
领取最新CV顶会论文、书籍
课程福利
作为日常为了论文而忙碌的科研人，小编知道大家一定很需要一些资料。因此，小编精心整理了一份超过20G的AI顶会论文大礼包！包含最新顶会论文、书籍等资料，全部帮你整理好~
扫码免费领课程资料↑
-END-
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ae2b8bd86b6f1d004e66a4f51ec968a/" rel="bookmark">
			SpringCloudStream整合RabbitMQ用ttl&#43;死信实现延迟队列的实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇是关于我使用Spring Cloud Steam操作RabbitMQ采用ttl+死信队列的方式实现的延迟队列。
前言 在公司项目中遇到了需要延迟队列的需求，为了以后可维护性和扩展性要求必须要用Springcloud Stream组件来操作mq，而且公司的rabbit也不允许安装延迟插件，只能用最原始的ttl+死信来实现，在搭建过程中遇到很多问题，最终成功实现，下面是代码，采用的是spring cloud steam3.1后的函数式编程实现。
先科普下原理：生产者发送消息到普通交换机绑定了个设置ttl时间的队列，这个队列绑定了个死信交换机且没人消费，如果消息过期就会发送到死信队列里，消费者就监听这个死信队列实现延迟队列的效果。
yaml配置文件 function中definition就是定义你的函数名称（后面发送和接收方法的名字）
bindings中的xxx-in/out-0，分为三个部分。第一个部分就是方法名，第二部分是输入或输出代表生产者out还是消费者in的意思，第三部分的0在rabbitmq里面是固定的，他是为了兼容kafkaf提供的，我们死写0就行。destination里面配置交换机的名字，后面的变量是环境的意思，到时候会变成dev、test、uat这些。group分组要设置一下我这里就叫模块的名字了。
重点:下面的producer：required-groups一定要配置，就是那个分组名字。
然后就是配置消费者，绑定的交换机要是最下面为生产者配置的死信交换机，分组名字也要记得填上不然不会消费。
后面的content-type是类型，可以不指定，默认就是这个
最下面是rabbit的配置，bingdings里面我配置了为生产者邦迪一个死信交换机，然后设置生产者多久没消费就会到死信的ttl。dead-letter-exchange是指定交换机名字，你就设置为原本交换机名称_DLX就好了为了规范，然后配置死信队列的名字，就是在交换机后面加上那个分组，一定要和上面的分组一致。
因为这里死信队列出来的消息是direct的，消费者是监听死信队列已经过期的消息的，所以交换机类型也要设置为direct，不然会报：direct消息转化topic异常，但是这个异常只会第一个消息报，后面的消息都不会了，可能是springcloud stream底层帮我们处理了，但为了避免第一次报错还是设置一下交换机类型。
cloud: function: definition: memberAccountUpdateTaskDelayed;handleTaskDelayed; stream: bindings: memberAccountUpdateTaskDelayed-out-0: destination: MEMBER_TOPIC_${spring.profiles.active} #延迟exchange,交换模式是topic content-type: application/json #设置消息的类型为json group: ${spring.application.name} producer: required-groups: ${spring.application.name} #必须要制定生产者分组,不然发不过去 handleTaskDelayed-in-0: destination: MEMBER_TOPIC_DLX_${spring.profiles.active} content-type: application/json group: ${spring.application.name} rabbit: bindings: memberAccountUpdateTaskDelayed-out-0: producer: ttl: 10000 #延时队列的延时时间，单位毫秒 auto-bind-dlq: true #开启死信队列 dead-letter-exchange: MEMBER_TOPIC_DLX_${spring.profiles.active} #死信交换机 dead-letter-queueName: MEMBER_TOPIC_DLX_${spring.profiles.active}.${spring.application.name} #死信队列名称 handleTaskDelayed-in-0: consumer: exchange-type: direct #死信交换机必须是direct类型的才能接受 生产者发送消息 这里我发送的是对象，在TaskDelayMessage就是发送的对象，实体类里面的属性上记得加上JSON反序列化的注解，不然消费者监听的时候会报反序列化错误。
方法名要和配置文件你配置的那个方法名一样
@Repository @Slf4j public class MemberAccountUpdateTaskHandleTimeoutTaskRepositoryImpl implements MemberAccountUpdateTaskHandleTimeoutTaskRepository { private final Sinks.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ae2b8bd86b6f1d004e66a4f51ec968a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c325194bbf6a398441b3349bc57f1cab/" rel="bookmark">
			videojs-player视频播放技术学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍：
videojs是一个开源的HTML5视频播放器，它可以在各种设备和浏览器上播放视频。videojs提供了丰富的API和插件，可以实现自定义的视频播放功能。
使用videojs实现视频播放的步骤：
1. 引入videojs库 在HTML文件中引入videojs库的CSS和JS文件。
```html &lt;link href="https://vjs.zencdn.net/7.11.4/video-js.css" rel="stylesheet" /&gt;
&lt;script src="https://vjs.zencdn.net/7.11.4/video.min.js"&gt;&lt;/script&gt; ```
2. 创建video标签 在HTML文件中创建一个video标签，并设置视频的URL和封面图。
```html &lt;video id="my-video" class="video-js" controls preload="auto" width="640" height="264" poster="poster.jpg" data-setup="{}"&gt;
&lt;source src="my-video.mp4" type='video/mp4'&gt;
&lt;p class="vjs-no-js"&gt;
To view this video please enable JavaScript, and consider upgrading to a web browser that
&lt;a href="https://videojs.com/html5-video-support/" target="_blank"&gt;supports HTML5 video&lt;/a&gt; &lt;/p&gt;
&lt;/video&gt; ```
3. 初始化videojs 在JS文件中初始化videojs，并设置视频的配置选项。
```javascript var player = videojs('my-video', { autoplay: true, controls: true, sources: [{ src: 'my-video.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c325194bbf6a398441b3349bc57f1cab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bc09b08f6da130410de3dde1164c185/" rel="bookmark">
			C语言深度解析-fibonacci斐波那契数列数列的几种解法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、采用递归的方法 Fib(n) n&gt; 2 n=Fib(n-1)+Fib(n-2)
#include &lt;stdio.h&gt; //Fibonacci斐波那契数列 //1 1 2 3 5 8 13 21 34 55 //Fib(n) n&lt;= 2 数是1 //Fib(n) n&gt; 2 n=Fib(n-1)+Fib(n-2) int Fib(int n) { if (n&lt;=2) { return 1; } else { return Fib(n-1)+Fib(n-2); } } int main() { int n = 0; int ret = 0; scanf("%d",&amp;n); //TDD-测试驱动开发，先考虑函数怎么用，怎么测试，再考虑开发 ret = Fib(n); printf("ret=%d\n",ret); return 0; } 二、采用迭代的方法-倒退迭代的思路 c = a+b;
a = b;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bc09b08f6da130410de3dde1164c185/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8563471f77a2dc1182ce8c45c4257f1/" rel="bookmark">
			61、基于51单片机无线蓝牙音乐喷泉控制系统设计(程序&#43;原理图&#43;PCB源文件&#43;参考论文&#43;参考PPT&#43;元器件清单等)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案选择
单片机的选择
方案一：AT89C52是美国ATMEL公司生产的低电压，高性能CMOS型8位单片机，器件采用ATMEL公司的高密度、非易失性存储技术生产，兼容标准MCS-51指令系统，片内置通用8位中央处理器(CPU)和Flash存储单元，功能强大。其片内的8K程序存储器是FLASH工艺的，这种单片机对开发设备的要求很低，开发时间也大大缩短。写入单片机内的程序还可以进行加密，这又很好地保护我们的劳动成果。再者，AT89C52目前的售价比8031还低，市场供应也很充足。AT89C52可构成真正的单片机最小应用系统，缩小系统体积，增加系统的可靠性，降低系统的成本。只要程序长度小于8K，四个I/O口全部提供给用户。可用5V电压编程，而且擦写时间仅需lOms。AT89C51芯片提供三级程序存储器加密，提供了方便灵活而可靠的硬加密手段，能完全保证程序或系统不被仿制。PO口是三态双向口，通称数据总线口，因为只有该口能直接用于对外部存储器的读/写操作。
方案二：STC89C52系列单片机的指令系统和AT89C52系列的完全兼容，但实际操作起来却存在很多问题：
（1）AT89C52不带ISP下载，要用下载器才行，STC89C52可以用你的USB转串口下载，下载软件可以到STC厂家网上去下。
（2）STC单片机执行指令的速度很快，大约是AT的3-30倍，尽管快是好事，但这样一来，你在AT上好使的程序在STC上不一定好用，最典型的例子就是那些对时序有严格要求的模块，用STC时注意得加长延时，大约是AT的10—30倍就差不多，这一点自己调试就知道了。
（3）STC单片机对工作环境的要求比较低，电压低于5伏时仍然正常工作，甚至3伏到4伏之间都还可以工作，然而这样的环境下AT肯定不行了，所以当一个系统用STC单片机好用，但用AT的单片机不工作时，直接查最小系统，看单片机的供电是否正常。
比较这两种方案，由于在学校期间学过数字电路、单片机原理、C语言程序设计，综合考虑单片机的各部分资源和作为学生能够获得的资源，经过对比此次设计要求，我选择用STC系列芯片完成。而且学校也提供了相应的硬件操作平台，实际操作起来比较方便，故STC为更合理的选择。本系统选择STC89C52单片机作为主控芯片。足够本设计运行，且价格便宜，下载程序方便。
STC89C52单片机核心系统电路设计
STC89C52RC是STC公司生产的一种低功耗、高性能CMOS8位微控制器，具有8K字节系统可编程Flash存储器。STC89C52使用经典的MCS-51内核，但是做了很多的改进使得芯片具有传统51单片机不具备的功能。在单芯片上，拥有灵巧的8 位CPU 和在系统可编程Flash，使得STC89C52为众多嵌入式控制应用系统提供高灵活、超有效的解决方案。具有以下标准功能：8k字节Flash，512字节RAM， 32 位I/O 口线，看门狗定时器，内置4KB EEPROM，MAX810复位电路，3个16 位定时器/计数器，4个外部中断，一个7向量4级中断结构（兼容传统51的5向量2级中断结构），全双工串行口。另外 STC89C52 可降至0Hz 静态逻辑操作，支持2种软件可选择节电模式。空闲模式下，CPU 停止工作，允许RAM、定时器/计数器、串口、中断继续工作。掉电保护方式下，RAM内容被保存，振荡器被冻结，单片机一切工作停止，直到下一个中断或硬件复位为止。最高运作频率35MHz，6T/12T可选。
一、STC89C52主要特性如下：
（1）8K字节程序存储空间；
（2）512字节数据存储空间；
（3）内带4K字节EEPROM存储空间;
（4）可直接使用串口下载。
二、STC89C52主要参数如下：
（1）增强型8051单片机，6时钟/机器周期和12 时钟/机器周期可以任意选择，指令代码完全兼容传统8051；
（2）工作电压：5.5V～3.3V（5V单片机）/3.8V～2.0V（3V 单片机）；
（3）工作频率范围：0～40MHz，相当于普通8051的0～80MHz，实际工作 频率可达48MHz；
（4）用户应用程序空间为8K字节；
（5）片上集成512 字节RAM；
（6）通用I/O 口（32个），复位后为：P1/P2/P3 是准双向口/弱上拉，P0口是漏极开路输出，作为总线扩展用时，不用加上拉电阻，作为 I/O口用时，需加上拉电阻；
（7）ISP（在系统可编程）/IAP（在应用可编程），无需专用编程器，无需专用仿真器，可通过串口（RxD/P3.0,TxD/P3.1）直接下载用户程序，数秒即可完成一片；
（8）具有EEPROM功能；
（9）共3个16 位定时器/计数器。即定时器T0、T1、T2；
（10）外部中断4路，下降沿中断或低电平触发电路，Power Down 模式可 由外部中断低电平触发中断方式唤醒；
（11）通用异步串行口（UART），还可用定时器软件实现多个UART；
（12）工作温度范围：-40～+85℃（工业级）/0～75℃（商业级）；
（13）PDIP封装。
三、STC89C52单片机相关引脚说明：
（1）VCC：供电电压。
（2）GND：接地。
（3）P3.0 RXD（串行输入口）
（4）P3.1 TXD（串行输出口）
（5）P3.2 /INT0（外部中断0）
（6）P3.3 /INT1（外部中断1）
（7）P3.4 T0（记时器0外部输入）
（8）P3.5 T1（记时器1外部输入）
（9）P3.6 /WR（外部数据存储器写选通）
（10）P3.7 /RD（外部数据存储器读选通）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8563471f77a2dc1182ce8c45c4257f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f392c61a746c0c0db886660a479b4627/" rel="bookmark">
			小知识点系列：Homebrew的安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. HomeBrew介绍 Homebrew 是 macOS 系统上一款强大的包管理工具，它使得在终端中安装、升级和管理软件包变得非常简单。本文将介绍如何安装 Homebrew，并展示一些常用的使用方法。
2. 安装 Homebrew 在开始之前，请确保已经安装了 macOS 操作系统，并具有管理员权限。按照以下步骤来安装 Homebrew：
打开终端：你可以通过“Spotlight 搜索”或在“应用程序文件夹”中找到“终端”。
在终端中输入以下命令并按下回车键：
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" 这个命令会自动下载并安装 Homebrew。
安装过程可能需要一些时间，请耐心等待。在安装完成后，终端会显示相应的提示信息。
安装完成后，可以通过运行以下命令来验证 Homebrew 是否安装成功：
brew --version 如果安装成功，会显示 Homebrew 的版本号。
3. 使用 Homebrew 安装软件包 Homebrew 使用简单的命令来安装软件包。例如，要安装最新版本的 Python，可以运行以下命令：
brew install python 这将自动下载并安装 Python。类似地，你可以安装其他软件包，如 Node.js、Git 等。
升级软件包 使用 Homebrew，你可以轻松地升级已安装的软件包。运行以下命令来升级 Homebrew 和所有已安装的软件包：
brew update brew upgrade brew update 用于更新 Homebrew 自身，而 brew upgrade 用于升级已安装的软件包。
搜索软件包 如果你想搜索可用的软件包，可以使用 brew search 命令。例如，要搜索与 “mysql” 相关的软件包，可以运行以下命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f392c61a746c0c0db886660a479b4627/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/882cf4e93cf9eaded66e0dae0e823e96/" rel="bookmark">
			一个项目的测试计划模板该怎么写？【附案例】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言
二、测试任务
三、测试进度
四、测试资源
五、测试策略
六、测试完成标准
七、风险和约束
八、问题严重程度描述和响应时间规范
九、测试的主要角色和职责
软件测试是使用人工或者自动的手段来运行或者测定某个软件系统的过程，其目的在于检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别。
在软件投入使用前，要经过一系列的严格测试，才能保证交付质量。
一、引言 1.编写目的 本文档涵盖了测试范围、测试需求、测试策略、测试方法、测试工具、测试资源、测试交付文档、风险分析等内容，为后续的测试工作提供清晰的流程，确保测试工作有效地进行。
2.项目背景 随着人们生活水平的提高，目前汽车已经成为大众出行必不可少的交通工具之一，每天新购买需要上牌的汽车数量已经超过100万辆，导致各个车管所车辆上牌网点无法满足人们轻松上牌的需求，湖南交警特地委托我司定制开发此软件，旨在让人们在家即可轻松选择自己中意的车牌号码。以及完成与车牌号码相关的交易、转让、赠送等事项。
3.适用范围 4.专业术语 二、测试任务 1.测试范围 本计划文档覆盖《湖南交警一网通》功能测试、压力测试、负载测试、兼容测试、验收测试等。
2.测试目标 测试《湖南交警一网通》系统与需求规格要求的功能和性能是否全部实现，是否满足用户的明确需求和隐含需求，系统发布是否存在风险等。
3.参考文档 ​4.提交文档(交付件) 三、测试进度 四、测试资源 1 .人力资源 2 .环境资源 硬件环境
软件环境
3 测试工具
五、测试策略 1.功能测试 2..压力测试 3.载测试 4.兼容测试 六、测试完成标准 1.测试充分性
a.用例已全面覆盖需求：测试用例覆盖率要求达到100%。
b.原则上要求所有用例都100%执行，即优先级高、中、低的用例都必须100%执行。
c.工作投入充分性：项目测试工作要充分投入，保障测试投入的合理性。
2测试有效性
a.严重性以上程度的缺陷解决率必须达到100%。
b.缺陷密度达到一定的标准，Bug数呈正态分布。
c.相关责任部门认可测试结果,包括客户的试用、验收测试等。
七、风险和约束 1.流程约束
(1)开发流程：略
(2)测试流程：略
(3)缺陷流程：略
2.风险分析 八、问题严重程度描述和响应时间规范 九、测试的主要角色和职责 测试不是测试组一个团队的事情，需要整个项目的所有同事一起参与，测试工作所涉及的主要角色和职责大致如下：
这篇贴子到这里就结束了，最后，希望看这篇帖子的朋友能够有所收获。
文中的项目我也都备好了，有需要的请回复【项目】免费领取。
如果你觉得文章还不错，请大家 点赞、分享、留言 下，因为这将是我持续输出更多优质文章的最强动力！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59027363841a46258235d93fbf6feb3d/" rel="bookmark">
			[Vue warn]: Maximum recursive updates exceeded in component ＜ElTableColumn＞.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题出现在我自己部署到服务器上的项目中（实际上部署好的项目在浏览器中不会报这个错误，在本地调试的时候才能发现）
bug的主要体现是页面卡死或非常卡顿（我的就卡死了，因为使用的服务器性能较差），但在本地运行则没事（因为本地性能、内存绰绰有余）
在本地调试后发现此警告（之前没管它doge）翻译如下
解决方法为定位到相应vue组件，一行一行的注释测试，一般来说大概率是表格的操作列出了问题。我的问题是有一个开发时写来测试用的值，后来忘记删掉它了，如下图
把这一行删掉后浏览器控制台不再警告，重新部署到服务器后也能正常的访问了。
遇见此类问题不知道具体是哪一处出了错，大可以注释反复测试，但是项目越大此类问题就越要避免，最好的方法就是写完一个功能点之后自己快速的查验一遍，能够有效的把一些bug扼杀在摇篮之中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ff44e58277d1bd1009345b66e4c41b2/" rel="bookmark">
			crx文件浏览器插件的安装方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		crx文件浏览器插件的安装方法
从网站下载浏览器插件一般都是crx类型的文件，当我们需要安装插件可以打开浏览器设置找到扩展程序，然后把开发者模式打开就可以正常安装了
安装方法:
1，直接将crx文件拖拽到浏览器的扩展程序界面进行插件的添加
2，部分插件安装后可能会显示 "扩展程序未在应用商店找到，可能在不知情情况下添加" 这个错误提示。
解决办法: 直接将crx文件后缀名改为zip格式，重新拖拽安装一遍
3，有些用户浏览器可能因为安全问题，暂不支持用户拖拽文件到浏览器上安装，出现拖拽被禁用的情况。
解决办法: 将改成zip的插件文件，直接解压成同名文件，点击浏览器的"加载已解压的扩展程序"，选择刚刚解压出来的文件夹，注意是整个文件夹即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e089e724f86940b8bf64bfc5260174fb/" rel="bookmark">
			IP地址与Mac地址的关系与区别 - 学习/实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.应用场景
主要用于学习IP地址与Mac地址的关系与区别，更加了解掌握计算机网络相关知识 2.学习/操作
下面是一个跨网段的网络请求根据 IP 地址和 MAC 地址最终到达目标主机的流程图
为了方便理解，我们画了一幅数据传输的示意图：
1.文档阅读 网络协议概论 | Laravel 学院 - IP 协议（七）： IP 地址与 MAC 地址是如何映射的
IP地址和MAC地址的区别和联系是什么？ - 知乎
网络协议概论 | Laravel 学院 - 传输层的定义及端口号设置 -- 其中涉及到Mac地址，IP地址，端口的区别
https://blog.csdn.net/william_n/article/details/121964034
14 | IP 网络：连接世界的桥梁-极客时间 -- 推荐
如果让你来设计网络 -- 推荐「简洁通俗易懂地讲解」
2.整理输出 2.1 Mac地址 MAC 地址是数据链路的地址，用来识别同一链路中的不同计算机，
2.2 IP地址 IP 地址，是网络层中的地址，用来识别计算机网路中互连的主机和路由器。
2.3 程序地址 主机中的通信端口。
传输层使用 端口号 这种识别码，识别在传输层上一层的应用层中所要进行处理的具体程序。
详情参见：
计算机 - 知名端口号和注册端口号 - 收集与查询_穿素白衫的中少年的博客-CSDN博客_注册端口号
后续补充
...
3.问题/补充
1. Mac地址，IP地址，端口的联系与区别 数据链路和网络层中的地址，分别指的是 MAC 地址和 IP 地址，前者用来识别同一链路中的不同计算机，后者用来识别计算机网路中互连的主机和路由器。在传输层中也有类似于地址的概念，那就是端口号，端口号用来识别同一台计算机中进行通信的不同应用程序，因此，它也被称为程序地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e089e724f86940b8bf64bfc5260174fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/698580151a6ba5c3e66118ba2a7303a0/" rel="bookmark">
			coverage代码覆盖率测试介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		coverage代码覆盖率测试介绍 背景知识补充 1、什么是覆盖率
测试过程中提到的覆盖率，指的是已测试的内容，占待测内容的百分比，在一定程度上反应测试的完整程度。
覆盖率有可以根据要衡量的对象细分很多种，比如接口覆盖率、分支覆盖率、行覆盖率等等
2、做覆盖率有什么用处
覆盖率的好处是可以将测试的完整性量化，可以作为补充测试的手段，也可以在一定程度上佐证测试结果的可靠性。
简介 代码覆盖率测量通常用于衡量测试的有效性。它可以显示你的代码的哪些部分正在被测试执行，哪些没有被执行。
coverage是一个测量 Python 程序代码覆盖率的工具。它监视你的程序，并分析源码生成代码覆盖率报告。
安装 coverage依赖python环境
python环境安装：https://computingforgeeks.com/install-latest-python-on-centos-linux/
安装coverage
python3 -m pip install coverage or pip3 install coverage 安装完成
coverage --version Coverage.py, version 7.2.5 with C extension Full documentation is at https://coverage.readthedocs.io/en/7.2.5 命令概览 coverage支持命令如下
[yhgao@localhost ~]$ coverage --help Coverage.py, version 7.2.5 with C extension Measure, collect, and report on code coverage in Python programs. usage: coverage &lt;command&gt; [options] [args] Commands: annotate Annotate source files with execution information.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/698580151a6ba5c3e66118ba2a7303a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9776e05b8bdf977843d8330e6933ad75/" rel="bookmark">
			k8s部署redis集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 一般来说，REDIS部署有三种模式。
单实例模式，一般用于测试环境。哨兵模式集群模式 后两者用于生产部署
哨兵模式
在redis3.0以前，要实现集群一般是借助哨兵sentinel工具来监控master节点的状态。
如果master节点异常，则会做主从切换，将某一台slave作为master。
引入了哨兵节点，部署更复杂，维护成本也比较高，并且性能和高可用性等各方面表现一般。
集群模式
3.0 后推出的 Redis 分布式集群解决方案
主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用
如果master节点异常，也是会自动做主从切换，将slave切换为master。
总的来说，集群模式明显优于哨兵模式
那么今天我们就来讲解下：k8s环境下，如何部署redis集群（三主三从）？
前置准备 一、nfs安装 nfs # 服务端 # 1.安装 yum -y install nfs-utils # nfs文件系统 yum -y install rpcbind # rpc协议 # 2.配置（需要共享的文件夹） vi /etc/exports /opt/nfs/pv1 *(rw,sync,no_subtree_check,no_root_squash) /opt/nfs/pv2 *(rw,sync,no_subtree_check,no_root_squash) /opt/nfs/pv3 *(rw,sync,no_subtree_check,no_root_squash) /opt/nfs/pv4 *(rw,sync,no_subtree_check,no_root_squash) /opt/nfs/pv5 *(rw,sync,no_subtree_check,no_root_squash) /opt/nfs/pv6 *(rw,sync,no_subtree_check,no_root_squash) # 3.创建文件夹 mkdir -p /opt/nfs/pv{1..6} # 4.更新配置并重启nfs服务 exportfs -r #更新配置 systemctl restart rpcbind systemctl restart nfs systemctl enable nfs #开机启动 systemctl enable rpcbind # 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9776e05b8bdf977843d8330e6933ad75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d1432a36ee7b5c682027fbd66cf6c23/" rel="bookmark">
			基于微信小程序的智能推荐点餐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
在社会高速发展的过程中，计算机系统在社会生产的过程中大量应用，并且随着相关技术的高速发展，这一过程在不断加速。因此，将智能推荐点餐系统管理与当前的网络相结合，利用计算机构建以微信小程序为基础的智能推荐点餐系统，从而实现智能推荐点餐系统的信息化。则对于进一步提高智能推荐点餐系统管理发展，丰富智能推荐点餐系统管理经验能起到不少的促进作用。
系统阐述的是使用基于微信小程序的智能推荐点餐系统，对于Java、B/S结构、MySQL进行了较为深入的学习与应用。从设计到实现，到分析测试，再到测试的各个环节。在此基础上，提出了一种基于 MySQL的软件开发方法，利用这些技术结合实际需求开发了具有首页，个人中心，用户管理，商家管理，餐品信息管理，餐品分类管理，餐品论坛，系统管理等功能的系统，最后对系统进行相应的测试，测试系统有无存在问题以及测试用户权限来优化系统，最后系统达到预期目标。
关键字：智能推荐点餐系统；Java；springboot；MySQL数据库
1.2 研究意义 近几年来，随着网络技术的飞速发展，人们对外卖点菜模式的要求发生了很大变化。如今，微信小程序已经成为了一款非常受欢迎的手机软件。所以，在此基础上，建立一个以微信小程序为基础的智能点菜推荐系统，就显得非常有意义。
首先，在微信小程序基础上开发的“智能点菜”系统，为用户提供了更加便捷、快速和有效的点菜模式。在传统点餐模式下，顾客往往需要在餐厅浏览菜单、挑选菜品并下订单，这个过程可能会花费较长时间，而基于微信小程序的智能推荐点餐系统可以通过对用户的历史点餐记录和口味偏好进行分析，向用户推荐相关菜品，从而减少用户选择菜品的时间和难度。
其次，利用微信小程序开发出的智能点菜推荐系统，能够有效地提升餐馆的运营效率。通过分析用户点餐趋势和口味偏好，餐厅可以准确了解用户的需求，不断优化菜品的口味和质量，从而提高用户的满意度和忠诚度。同时，餐厅可以通过系统数据的分析，优化菜品的搭配和价格的制定，从而达到降低成本、提高利润的目的。
第三，在此基础上，利用微信小程序开发出的智能点餐推荐系统，为餐饮企业提供了一种新的、更好的服务。通过系统，用户可以分享自己的点餐记录和口味偏好，与其他用户进行交流和分享。这样不仅可以增加餐厅的曝光度，也可以拓展用户社交圈。
总之，利用微信小程序开发的智能点餐推荐系统，无论对餐馆还是顾客来说，都具有重要的现实意义，它能够提升餐馆的运营效率，为顾客提供更方便、更高效、更个性化的点餐服务。
1.3 研究内容 整个的系统的开发采用了 Java技术、 springboot框架和 MySQL数据库技术，在其大力支持下，对该系统进行了同步的开发，从而使智能推荐点餐系统的管理达到了信息化的程度，使得管理者在操作上有了更清晰的思路，也更方便了，使用者也能够体验到更好的智能推荐点餐系统管理，具体目的如下：
(1)减轻了后台管理人员的工作负担，极大提升用户信息管理的效率；
（2）必须要方便快捷的查看搜索信息并管理信息；
（3）用户是多种多样的，因此要将界面设定得简洁清晰，操作起来也要更加便捷。。
（4）编写开发系统的技术文件。
（5）对系统进行了系统测试。
4.1 系统总功能模块设计 基于微信小程序的智能推荐点餐系统分三大部分，即管理员管理，商家管理和用户管理。系统按照商家和用户的实际需求开发而来，贴近生活。从管理员出拿到分配好的账号密码可以进入系统，使用相关的系统应用，管理员权限最大，紧接的是商家和用户。
系统整体模块设计：系统分为管理员，商家和用户三大用户角色，系统管理员有最大的权限，整体功能展示如图4-1所示。
图4-1 系统整体功能图
4.2.1 数据库系统概要设计 从设计到制造，研发一个系统，涉及到的技术非常多，对于开发程序语言、数据库和框架布局都有严格的要求[5]。这个系统的数据储存使用的是 MySQL的数据库，这个数据库既轻又快，在日常使使用中，系统非常稳定，更易于维护和运行[6]。
4.2.2 E-R模型结构设计 E-R图是将相关的实体和相关的实体联系起来形成的一种关系图，通过E-R图对可以将系统中各实体间的联系清晰地表示出来。在系统中对一些主要的几个关键实体如下图。
(1) 餐品信息评论表实体属性图如下图4-2所示。
图4-2餐品信息评论表实体属性图
(2)餐品论坛实体属性图如下图4-3所示。
图4-3餐品论坛实体属性图
5.1.1登录界面的实现
首先双击打开小程序客户端，连上网络之后会显示出本系统的登录界面，这是进入小程序的初始页面“登录”，能成功进入到该登录界面则代表小程序的开启是成功的，接下来就可以操作本系统所带有的其他所有的功能。登录界面如图5-1所示。
图5-1 登录界面
5.1.2 小程序首页功能的实现
小程序首页是用户注册登录后进入的第一个界面，在这里，人们能够看到小程序的导航条，内容包括首页，餐品信息，餐品论坛，购物车，我的等。小程序首页界面如图5-2所示。
图5-2 小程序首页界面图
管理员登陆功能包括：首页，个人中心，用户管理，商家管理，餐品分类，餐品信息，餐品论坛，系统管理，订单管理如图5-8所示：
图5-8管理员功能界面
参考文献 [1] 沈德鸿. 高校外卖市场现状下的餐厅联合外卖模式[J]. 经贸实践,2017(8):155.
[2] 张传佳, 李远浩, 丘远斌,等. 基于安卓平台的基于微信小程序的智能推荐点餐系统《order》的设计与应用[J]. 电脑知识与技术, 2018, 14(21):127-130.
[3]李艳杰. 手机端网上外卖系统的设计与实现[J]. 现代信息科技, 2019, 000(018):P.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d1432a36ee7b5c682027fbd66cf6c23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23b400667e198bbca24787137e7f1c70/" rel="bookmark">
			mybatis-plus 代码生成器的实战 自动生成代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中，通过mybatis-generator插件自动生成代码，直接构建出项目全面的基本结构。例如常用的POJO，DAO，Service，Service实现类，Controller层以及mapper.xml文件;进而达到快速开发的目的; 下面介绍两种方式实现,基本相同,写法不同而已;
1. 使用插件+ xml配置 引入pom插件
&lt;plugin&gt; &lt;!--Mybatis-generator插件,用于自动生成Mapper和POJO --&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;!--配置文件的位置 --&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;/executions&gt; &lt;/plugin&gt; generatorConfig.xml 配置文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt; &lt;!-- 自动生成mybatis相关类文件 --&gt; &lt;generatorConfiguration&gt; &lt;!-- classPathEntry:数据库的JDBC驱动的jar包地址 --&gt; &lt;!--&lt;classPathEntry location="?\mysql-connector-java-5.1.47.jar"/&gt;--&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name="suppressAllComments" value="true" /&gt; &lt;!-- 数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;/commentGenerator&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="数据库地址" userId="xxx" password="xxx"&gt; &lt;/jdbcConnection&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23b400667e198bbca24787137e7f1c70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/348bf6f5ca5c50592ceb03b21db01766/" rel="bookmark">
			P1809 过河问题【解析】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有一类贪心问题具有一定的迷惑性，大多数同学初步思考时会很快得到一种‘看上去很正确’的贪心策略，但是对于大部分贪心问题不能贸然得出结论。我们可以尝试构造一些反例推翻该策略。但是，即使该策略被推翻了，也不一定说明它完全错误，还有可能是在不同条件下贪心策略不同，此时需要分类讨论。因此，在解决贪心问题时，需要我们使用“构造方法、反例验证、打表观察、数学推导”等多种方式结合、多次尝试后，才能最终得到正确的方法。
例如过河问题
有四个人要从 A 点坐一条船过河到 B 点，船一开始在 A 点。该船一次最多可坐两个人。 已知这四个人中每个人独自坐船的过河时间分别为 1,2,4,8，且两个人坐船的过河时间为两人独自过河时间的较大者。则最短（ ）时间可以让四个人都过河到 B 点（包括从 B 点把船开回 A 点的时间）。
A. 14
B. 15
C. 16
D. 17
【解析】 深入思考发现每次过河船只能承受两个人，且返回还需要一个人折返的时间，因此折返的工作最好交给时间最短的人和次最短的人去做，尽量减少回程时间，使去程贡献最大。由此想到另外一种贪心策略：首先最快和次快的人先过河，最快的人返回，然后最慢与次慢的人再过河，次快的人返回，最后最快和次快的人过河。
那么进入正题，我们来看一下洛古的P1809 过河问题
过河问题 题目描述 有一个大晴天，Oliver 与同学们一共 N N N 人出游，他们走到一条河的东岸边，想要过河到西岸。而东岸边有一条小船。
船太小了，一次只能乘坐两人。每个人都有一个渡河时间 T T T，船划到对岸的时间等于船上渡河时间较长的人所用时间。
现在已知 N N N 个人的渡河时间 T T T，Oliver 想要你告诉他，他们最少要花费多少时间，才能使所有人都过河。
注意，只有船在东岸（西岸）的人才能坐上船划到对岸。
输入格式 输入文件第一行为人数 N N N，以下有 N N N 行，每行一个数。
第 i + 1 i+1 i+1 行的数为第 i i i 个人的渡河时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/348bf6f5ca5c50592ceb03b21db01766/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45d1691b1b9a2587fa7d5b82c96cd6fd/" rel="bookmark">
			Springboot 中RESTtemplate的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一 概述
二 应用
1.get请求
2.post请求
一 概述 RESTtemplate提供了http请求连接的功能。spring 框架提供的 RestTemplate 类可用于在应用中调用 rest 服务，它简化了与 http 服务的通信方式，统一了 RESTful 的标准，封装了 http 链接， 我们只需要传入 url 及返回值类型即可。相较于之前常用的 HttpClient，RestTemplate 是一种更优雅的调用 RESTful 服务的方式。
二 应用 先建立一个Springboot项目，写出测试所需的Controller层和entity类。目录如下
先看entity类，用于测试post请求提供入参
@Data @AllArgsConstructor @NoArgsConstructor public class Person { private String name; private int age; private int height; } controller 层，提供get和post请求接口
@RestController public class TestController { @GetMapping("get") public String getTest(String str){ return "ok"; } /** * json参数 * @param person * @return */ @PostMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45d1691b1b9a2587fa7d5b82c96cd6fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d24f9ecc40fede75f691df0c10dceb2/" rel="bookmark">
			TCP客户端的WPF实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、TCP实现类
internal class TcpClient { Socket ClientSocket { get; set; } public byte[] ReceiveBuffer { get; set; } /// &lt;summary&gt; /// 构造函数 /// &lt;/summary&gt; /// &lt;param name="receiveBufferLength"&gt;&lt;/param&gt; public TcpClient(int receiveBufferLength) { ReceiveBuffer = new byte[receiveBufferLength]; } /// &lt;summary&gt; /// 连接服务器 /// &lt;/summary&gt; /// &lt;param name="ip"&gt;&lt;/param&gt; /// &lt;param name="port"&gt;&lt;/param&gt; public void Start(string ip, string port) { ClientSocket = CreateSocket(ip, port); CreateThread(); } /// &lt;summary&gt; /// 发送消息 /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d24f9ecc40fede75f691df0c10dceb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/954532fcd80b466352d6d8679989ace3/" rel="bookmark">
			手机校园导航管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
现在，随着智能手机的普及，校园内也有越来越多的地点和服务，用户对校园导航和查询的需求也越来越高，传统的地图导航软件通常只包含城市等地标性地点，校园内的地图和位置服务相对较弱。因此，开发一款针对校园导航和查询的管理系统已成为必然趋势。
本次设计的手机校园导航管理系统采用了Java语言进行开发，结合SSM框架、MySQL数据库等多种软件技术进行开发，系统内设计了用户与管理员两个角色，管理员主要设计了用户管理、校园信息管理、校园建筑管理、系统管理等功能。该系统的实现界面美观，操作简单，为用户提供了一个高效率、高安全性的手机校园导航管理系统。手机校园导航管理系统为师生提供了方便的校园地图导航功能，帮助用户快速准确地到达目的地，提高了校园生活的便利度和安全性，为学校带来了良好的口碑和社会认可，有助于提高学校整体竞争力和品牌影响力。同时，该系统还为学校和市场推广部门提供了新的渠道和手段，可以通过该系统发布校园相关资讯、广告和促销活动，提高校园公共信息传播和营销效果。
关键词 手机校园导航管理系统，Java，SSM 论文结构 本文按照章节内容共六章进行了详细的阐述：
第一章为绪论，简要地阐述了选题的研究背景和研究的重要性，并简要分析了手机校园导航管理系统的发展过程，并对全文的章节和思想进行了总结。
第二章主要是介绍有关技术，以 Windows 10作为开发平台， 采用SSM框架作为后端框架，前端选用前端用 html语言编写，整体采用了MySQL数据库进行数据处理。这一章介绍了有关技术和为什么要利用这一技术来开发这款手机校园导航管理系统。
第三章具体介绍了手机校园导航管理系统的需求，主要介绍了手机校园导航管理系统的基本需求，并对手机校园导航管理系统可行性做了详尽的介绍。
第四章为手机校园导航管理系统的设计，具体地介绍了其主要的功能，并提供了相关的数据库。
第五章为本论文的具体实现，本章对各模块的设计思路及实现方法进行了较为详尽的阐述，并提出了相关的设计思路，并给出了相关的软硬件接口。
第六章是系统的测试，在本文中，我们介绍了本课题的测试目的和实现方式，然后对该系统的主要功能进行了深入的分析，并进行了一些测试。
3.5功能需求分析 手机校园导航管理系统的手机导航功能主要包括以下几点：
1. 地图导航：系统可以提供校园地图的导航功能，帮助用户快速找到指定建筑、场所或路线。
2. 景点介绍：系统可以提供校园各个景点的详细介绍、图片、视频等，以及景点的开放时间、门票等信息。
3. 课表查询：系统可以提供学生或教师的课表查询功能，帮助用户更方便地了解自己的日程安排。
4. 教学楼导航：系统可以提供对教学楼的导航功能，帮助用户快速找到指定教室。
5. 宿舍导航：系统可以提供宿舍的导航功能，帮助用户快速找到指定宿舍区和宿舍楼。
6. 活动查询：系统可以提供校园各种活动的时间安排、地点、报名信息等，以及活动的宣传和推广。
7. 学术讲座查询：系统可以提供学术讲座的日期、地点、报名信息等，帮助用户快速找到自己感兴趣的讲座。
8. 社团信息查询：系统可以提供社团信息的查询，包括社团名称、介绍、联系方式等，并提供相关活动和推广信息。
总之，手机校园导航管理系统的手机导航功能主要是为了方便用户在校园内快速地查找目标，包括地点、日程、活动等。通过这些功能，用户可以轻松地掌握校园资源并更好地融入校园生活。
3.5.1用例概述 （1）用户
图3.1 用户用例图
（2）管理员
图3.2 管理员用例图
经过需求分析之后，下一步要做的是定下能够满足基本要求的系统，进而设计出对应的系统。系统设计内容应该需要包括明确手机校园导航管理系统的设计方法，将系统功能分成若干个模块，确立各个模块需要什么功能以及与其它模块的关系，对划分的功能模块采取技术设计和评价。系统功能结构图，如图4-3所示。
图4-3 功能结构图
手机校园导航管理系统，用户通过输入用户名、密码进行登录进入系统，如图5-4所示。
图5-4登录界面图
图5-7管理员功能界面图
7.1 测试概述 （1）页面的错别字和样式，系统中的页面包含了很多文字，错别字是不能要有的。另外，系统信息在显示的时候需要注意文字间距和行间距。前端页面字符显示乱码，在编写前端页面的时候需要注意字符的一致性。
（2）浏览器的兼容性，本手机校园导航管理系统使用的单元测试主要通过Firefox浏览器完成的，浏览器之间的内核是不一样的，解析语法的方式也有所差别。因此在测试的时候需要注意浏览器的兼容问题，通过CSS样式来调整页面的布局。
（3）增删改查功能，一般系统的查询功能采用的是模糊查询的方式，测试查询速度的快慢是否会影响到用户的体验，如果速度过慢的话需要优化查询SQL代码从而加快查询速度。查询出来的记录能否符合输入的关键字信息。在添加的时候，需要检测输入框是否有信息是必填的还是需要限制。
注：展示部分文档内容和系统截图，需要完整的视频、代码、文章和安装调试环境请私信up主。
目 录
摘 要 Abstract 目 录 第1章 绪论 1.1 选题的背景和意义 1.2 研究现状 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/954532fcd80b466352d6d8679989ace3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/608ece39894bc041cdd4e1692d3b6610/" rel="bookmark">
			opencv 将多帧图像合成为视频 cv2.VideoWriter()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 应用场景代码补充说明 应用场景 将文件夹下有时间戳或者有序的 *.jpg 图像合成为一个 mp4 格式的视频。
附加：加进度条看合成进度。
代码 import os import cv2 from tqdm import tqdm # python 进度条库 image_folder_dir = "/your/folder/path" fps = 24 # fps: frame per seconde 每秒帧数，数值可根据需要进行调整 size = (640, 360) # (width, height) 数值可根据需要进行调整 fourcc = cv2.VideoWriter_fourcc('m', 'p', '4', 'v') # 编码为 mp4v 格式，注意此处字母为小写，大写会报错 video = cv2.VideoWriter("/path/you/want/to/save/your/video/your_video_name.mp4", fourcc, fps, size, isColor=True) image_list = sorted([name for name in os.listdir(image_folder_dir) if name.endswith('.jpg')]) # 获取文件夹下所有格式为 jpg 图像的图像名，并按时间戳进行排序 for image_name in tqdm(image_list): # 遍历 image_list 中所有图像并添加进度条 image_full_path = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/608ece39894bc041cdd4e1692d3b6610/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b84f7f22981b3bef32fee6ad2f06ff3/" rel="bookmark">
			在win10电脑上搭建python环境下的本地AI绘画工具Stable Diffusion
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着Chatgpt的横空出世，人工智能受到了前所没有的热棒，AI绘画也进入大众的视野。
Stable Diffusion是一种可以部署在本地环境上运行的人工智能绘画工具，图形运算主要用到的是显卡的GPU性能，因此最好有至少4G显存的显卡。
Stable Diffusion首先需要搭建本地的UI界面即：stable-diffusion-webui，然后下载使用模型文件即可开始创作，模型可以直接使用别人训练好的。
安装Stable Diffusion不是一件简单的事情，在安装过程中会出现各种各样的问题，因此本教程将一步一步带领大家来完成安装。
操作环境：Windows 10中文版 操作步骤 一：安装Python。 Stable Diffusion的运行依赖于Python，因此为了保证整个项目能成功运行我们需要在本地环境安装Python，但是Stable Diffusion目前与最新版Python的兼容性并不是特别好，因此建议安装Python 3.10.9或者Python 3.10.10版本。
请确保安装Python时 勾选“ Add Python 3.10 to PATH”选项。
为了确认Python成功安装，请打开CMD终端窗口并输入“python”命令，如果能查询到Python的相关信息则证明安装已经成功，否则请重新安装。
步骤二：安装Git。
安装git来克隆完整的stable-diffusion-webui仓库，直接访问：Git - Downloading Package来进行下载，对于目前的大部分电脑来说都是64位的系统因此直接点击下载网页中的“64-bit Git for Windows Setup”。
下载完成后直接点击该EXE文件即可开始运行安装向导，所有选项均选择默认选项进行安装即可。
步骤三：使用git安装stable-diffusion-webui。 在电脑的C盘创建一个文件夹如“sd”来保存stable-diffusion-webui库文件，进入该文件夹后，右键鼠标在打开的下拉列表中选择“Git bash Here”可打开命令窗口并进入此文件夹，以保证后续的安装文够正确的安装在当前文件夹中。
在打开的命令窗口中复制以下代码（先复制到记事本再复制，以去掉一些控制符，https://ghproxy.com/部分能使访问网站快速，下同）点击回车键运行：
git clone https://ghproxy.com/https://github.com/AUTOMATIC1111/stable-diffusion-webui.git
安装过程中请不要关闭电脑或者断网，否则会安装失败。
安装完成后关闭Windows命令窗口，我们可以在sd文件夹中看到stable-diffusion-webui文件夹即表示安装成功了。
步骤四：下载面部重建插件GFPGAN。 打开浏览器访问Github：GitHub - TencentARC/GFPGAN: GFPGAN aims at developing Practical Algorithms for Real-world Face Restoration.去来下载GFPGAN插件，打开网页后向下拖拽点击如下图所示的“GFPGANv1.3.pth”插件即可开始下载。也可以直接用这个连接下载更快。
https://ghproxy.com/https://github.com/TencentARC/GFPGAN/releases/download/v1.3.0/GFPGANv1.3.pth
完成下载后直接将GFPGANv1.3.pth拖拽至stable-diffusion-webui文件夹中即可，如：“C:\sd\stable-diffusion-webui”。
步骤五：配置并运行webui-user.bat文件来自动安装所需文件。
如果你在安装Python时没有勾选了“ Add Python 3.10 to PATH”选项，在运行webui-user.bat批处理文件之前需要对其进行配置，右键该文件选择编辑即可在记事本中打开此文件开始编辑：在set PYTHON=参数后粘贴当前环境中Python.exe的路径，如：“C:\Users\50275\AppData\Local\Programs\Python\Python310\python.exe”。
当一切都配置成功后双击运行webui-user.bat文件，此过程可能需要一到两个小时左右，具体时间取决于你的网速。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b84f7f22981b3bef32fee6ad2f06ff3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f960488354c59590f038ec335c8687eb/" rel="bookmark">
			详解4种模型压缩技术、模型蒸馏算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.模型压缩概述 1.1模型压缩原有 理论上来说，深度神经网络模型越深，非线性程度也就越大，相应的对现实问题的表达能力越强，但相应的代价是，训练成本和模型大小的增加。同时，在部署时，大模型预测速度较低且需要更好的硬件支持。但随着深度学习越来越多的参与到产业中，很多情况下，需要将模型在手机端、IoT端部署，这种部署环境受到能耗和设备体积的限制，端侧硬件的计算能力和存储能力相对较弱，突出的诉求主要体现在以下三点：
首先是速度，比如像人脸闸机、人脸解锁手机等应用，对响应速度比较敏感，需要做到实时响应。其次是存储，比如电网周边环境监测这个应用场景中，要图像目标检测模型部署在可用内存只有200M的监控设备上，且当监控程序运行后，剩余内存会小于30M。最后是耗能，离线翻译这种移动设备内置AI模型的能耗直接决定了它的续航能力。 以上三点诉求都需要我们根据终端环境对现有模型进行小型化处理，在不损失精度的情况下，让模型的体积更小、速度更快，能耗更低。
但如何能产出小模型呢？常见的方式包括设计更高效的网络结构、将模型的参数量变少、将模型的计算量减少，同时提高模型的精度。 可能有人会提出疑问，为什么不直接设计一个小模型？ 要知道，实际业务子垂类众多，任务复杂度不同，在这种情况下，人工设计有效小模型难度非常大，需要非常强的领域知识。而模型压缩可以在经典小模型的基础上，稍作处理就可以快速拔高模型的各项性能，达到“多快好省”的目的。
上图是分类模型使用了蒸馏和量化的效果图，横轴是推理耗时，纵轴是模型准确率。 图中最上边红色的星星对应的是在MobileNetV3_large model基础上，使用蒸馏后的效果，相比它正下方的蓝色星星，精度有明显的提升。 图中所标浅蓝色的星星，对应的是在MobileNetV3_large model基础上，使用了蒸馏和量化的结果，相比原始模型，精度和推理速度都有明显的提升。 可以看出，在人工设计的经典小模型基础上，经过蒸馏和量化可以进一步提升模型的精度和推理速度。
1.2模型压缩的基本方法 模型压缩可以通过以下几种方法实现：
剪裁：类似“化学结构式的减肥”，将模型结构中对预测结果不重要的网络结构剪裁掉，使网络结构变得更加 ”瘦身“。比如，在每层网络，有些神经元节点的权重非常小，对模型加载信息的影响微乎其微。如果将这些权重较小的神经元删除，则既能保证模型精度不受大影响，又能减小模型大小。量化：类似“量子级别的减肥”，神经网络模型的参数一般都用float32的数据表示，但如果我们将float32的数据计算精度变成int8的计算精度，则可以牺牲一点模型精度来换取更快的计算速度。蒸馏：类似“老师教学生”，使用一个效果好的大模型指导一个小模型训练，因为大模型可以提供更多的软分类信息量，所以会训练出一个效果接近大模型的小模型。神经网络架构搜索（NAS）：类似“化学结构式的重构”，以模型大小和推理速度为约束进行模型结构搜索，从而获得更高效的网络结构。 除此以外，还有权重共享、低秩分解等技术也可实现模型压缩。
2.Patient-KD 模型蒸馏 2.1. Patient-KD 简介 论文地址：Patient Knowledge Distillation for BERT Model Compression
图1: Vanilla KD和PKD比较
BERT预训练模型对资源的高需求导致其很难被应用在实际问题中，为缓解这个问题，论文中提出了Patient Knowledge Distillation（Patient KD）方法，将原始大模型压缩为同等有效的轻量级浅层网络。同时，作者对以往的知识蒸馏方法进行了调研，如图1所示，vanilla KD在QNLI和MNLI的训练集上可以很快的达到和teacher model相媲美的性能，但在测试集上则很快达到饱和。对此，作者提出一种假设，在知识蒸馏的过程中过拟合会导致泛化能力不良。为缓解这个问题，论文中提出一种“耐心”师生机制，即让Patient-KD中的学生模型从教师网络的多个中间层进行知识提取，而不是只从教师网络的最后一层输出中学习。
2.2. 模型实现 Patient-KD中提出如下两个知识蒸馏策略：
PKD-Skip: 从每k层学习，这种策略是假设网络的底层包含重要信息，需要被学习到（如图2a所示）PKD-last: 从最后k层学习，假设教师网络越靠后的层包含越丰富的知识信息（如图2b所示） 图2a: PKD-Skip 学生网络学习教师网络每两层的输出 图2b: PKD-Last 学生网络从教师网络的最后六层学习
因为在BERT中仅使用最后一层的[CLS] token的输出来进行预测，且在其他BERT的变体模型中，如SDNet，是通过对每一层的[CLS] embedding的加权平均值进行处理并预测。由此可以推断，如果学生模型可以从任何教师网络中间层中的[CLS]表示中学习，那么它就有可能获得类似教师网络的泛化能力。
因此，Patient-KD中提出特殊的一种损失函数的计算方式：
2.3. 实验结果 图3: results from the GLUE test server
作者将模型预测提交到GLUE并获得了在测试集上的结果，如图3所示。与fine-tuning和vanilla KD这两种方法相比，使用PKD训练的BERT3BERT3​和BERT6BERT6​在除MRPC外的几乎所有任务上都表现良好。其中，PKD代表Patient-KD-Skip方法。对于MNLI-m和MNLI-mm，六层模型比微调（FT）基线提高了1.1%和1.3%，
我们将模型预测提交给官方 GLUE 评估服务器以获得测试数据的结果。 结果总结在表 1 中。 与直接微调和普通 KD 相比，我们使用 BERT3 和 BERT6 学生的 Patient-KD 模型在除 MRPC 之外的几乎所有任务上都表现最好。 此外，6层的BERT6−PKDBERT6​−PKD在7个任务中有5个都达到了和BERT-Base相似的性能，其中，SST-2（与 BERT-Base 教师相比为-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f960488354c59590f038ec335c8687eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b2f6a31a89c8ed5f50e5b9deedfeb6f/" rel="bookmark">
			关于【C语言】中scanf与getchar的用法和常见错误详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写这篇博客的起因是最近博主自己学习中总是遇到类似的错误，并曾百思不得其解。
今天分享出来是希望帮助大家在写代码时避免这些错误。话不多说，我们直接开始吧！
君兮_的个人主页 勤时当勉励 岁月不待人 C/C++ 游戏开发 输入函数scanf与getchar 一.scanf的用法1. scanf(“输入控制符”, 输入参数);2.scanf(“输入控制符非输入控制符”, 输入参数)输入多个参数 3.scanf的返回值 二.getchar的用法1.getchar的返回类型及使用效果 三.几种常见错误详解1.不理解原理导致的错误2.输入参数不符合输入控制符要求 总结参考博客 一.scanf的用法 我们先来看看再MSDN里对scanf的解释
- scanf 的功能用一句话来概括就是“通过键盘给程序中的变量赋值”。下面来讲讲它的两种基本用法： 1. scanf(“输入控制符”, 输入参数); 功能：将从键盘输入的字符转化为“输入控制符”所规定格式的数据，然后存入以输入参数的值为地址的变量中。
在通常情况下，我们不希望某个值是由我们程序员指定的，而是在程序运行中由用户从键盘输入的，这更能满足在日常使用时用户的需要，提高我们程序的灵活性用 scanf 即可实现即可很好的满足我们的要求： # include &lt;stdio.h&gt; int main() { int n=0; scanf("%d", &amp;n); //&amp;n 表示取变量 n 的地址，&amp;是取地址符 printf("n = %d\n", i); return 0; } 上面这个基本的程序中，有以下两点需要注意:
(1)我们从键盘输入的全部都是字符。比如从键盘输入 125，它表示的并不是数字 125，而是字符 ‘1’、字符 ‘2’ 和字符 ‘5’。
操作系统在接收键盘数据时会将它当成字符来接收。这时就需要用“输入控制符”把它转化成相应的内容(如%d 是有符号十进制数 %f 是浮点数)。
上面代码中的%d就是要将从键盘输入的这些合法的字符转化成对应的十进制数字。比如经过 %d 转化之后，字符 125 就是数字 125 了。
(2)&amp;是一个取地址运算符，&amp;加变量名表示“该变量的地址”，所以&amp;n就表示变量 n 的地址。又称为“取地址n”，相当于将数据存入以变量 n 的地址为地址的变量中(即存入变量n的地址中)。也就是把转化后的数字125放到变量 n 中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b2f6a31a89c8ed5f50e5b9deedfeb6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7825e3ae7c6b2021907b080f1f93800a/" rel="bookmark">
			Ansible 的脚本 --- playbook 剧本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、playbook简介 Playbook（剧本）是系统 Ansible 指令的集合，其利用 YAML 语言编写，自上而下按顺序一次执行。它可以实现一些 Ad-Hoc 指令无法实现的操作，例如从一台机器的文件中抓取内容并赋为另一台机器的变量等操作。
playbook本身由以下各部分组成 Tasks任务，即通过 task调用 ansible的模板将多个操作组织在一个playbook中运行Variables变量Templates模板Handlers处理器，当notify所在任务满足changed状态条件时，触发执行的操作Roles角色 Playbook 的执行结果有三种颜色： 红色： 表示有task执行失败或者提醒的信息黄色：表示执行了且改变了远程主机状态绿色：表示执行成功 Playbook 剧本语法 一个 Playbook 主要有以下四部分构成：
**target section：**定义将要执行 playbook 的远程主机组；**variable section：**定义 playbook 运行时需要使用的变量；**task section：**定义将要在远程主机上执行的任务列表；**handler section：**定义task执行完成以后需要调用的任务； 二、编写playbook 示例1：yum安装apache vim test1.yaml --- #yaml文件以---开头，以表明这是一个yaml文件，可省略 - name: first play #定义一个play的名称，可省略 gather_facts: false #设置不进行facts信息收集，这可以加快执行速度，可省略 hosts: webservers #指定要执行任务的被管理主机组，如多个主机组用冒号分隔 remote_user: root #指定被管理主机上执行任务的用户 tasks: #定义任务列表，任务列表中的各任务按次序逐个在hosts中指定的主机上执行 - name: test connection #自定义任务名称 ping: #使用 module: [options] 格式来定义一个任务 - name: disable selinux command: '/sbin/setenforce 0' #command模块和shell模块无需使用key=value格式 ignore_errors: True #如执行命令的返回值不为0，就会报错，tasks停止，可使用ignore_errors忽略失败的任务 - name: disable firewalld service: name=firewalld state=stopped #使用 module: options 格式来定义任务，option使用key=value格式 - name: mount cdrom mount: src=/dev/sr0 path=/mnt state=mounted fstype=iso9660 ignore_errors: True - name: install httpd yum: name=httpd state=latest - name: install configuration file for httpd copy: src=/opt/httpd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7825e3ae7c6b2021907b080f1f93800a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8be42561fa44719170c1889eb896cdff/" rel="bookmark">
			llvm程序手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址 注：单纯机翻
1 Introduction2 General Information 2.1 The C++ Standard Template Library2.2 Other useful references 3 Important and useful LLVM APIs 3.1 The isa&lt;&gt;, cast&lt;&gt; and dyn_cast&lt;&gt; templates3.2 Passing strings (the StringRef and Twine classes) 3.2.1 The StringRef class3.2.2 The Twine class 3.3 Formatting strings (the formatv function) 3.3.1 Simple formatting3.3.2 Custom formatting3.3.3 formatv Examples 3.4 Error handling 3.4.1 Programmatic Errors3.4.2 Recoverable Errors 3.4.2.1 StringError3.4.2.2 Interoperability with std::error_code and ErrorOr3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8be42561fa44719170c1889eb896cdff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5273414177cb49360beb3c4ce8a2902e/" rel="bookmark">
			Linux MTD子系统(二)——mtdblock驱动分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前的文章Linux MTD子系统(一)中有提到过mtd块设备，mtd块设备是在MTD设备之上模拟的块设备。
它的作用实际上只有一个——便于我们使用mount(umount)挂载(卸载)MTD设备中的文件系统，例如yaffs2，JFFS2等等。
本文将介绍mtdblock是如何实现模拟块设备的，以及它与mtd设备之间的关系。
本文基于linux-5.10.181内核代码分析。
mtd设备节点 当我们查看/dev/mtd*时，通常情况下，我们可以看下类似如下的设备：
root@OpenWrt:~# ls /dev/mtd* -alh crw------- 1 root root 90, 0 Jan 1 1970 /dev/mtd0 crw------- 1 root root 90, 1 Jan 1 1970 /dev/mtd0ro crw------- 1 root root 90, 2 Jan 1 1970 /dev/mtd1 crw------- 1 root root 90, 3 Jan 1 1970 /dev/mtd1ro crw------- 1 root root 90, 4 Jan 1 1970 /dev/mtd2 crw------- 1 root root 90, 5 Jan 1 1970 /dev/mtd2ro brw------- 1 root root 31, 0 Jan 1 1970 /dev/mtdblock0 brw------- 1 root root 31, 4 Jan 1 1970 /dev/mtdblock1 brw------- 1 root root 31, 8 Jan 1 1970 /dev/mtdblock2 实际上/dev/mtd0，/dev/mtd0ro,/dev/mtdblock0代表的是同一个MTD分区，但是/dev/mtd0，/dev/mtd0ro都是字符设备，其中/dev/mtd0ro是只读字符设备，/dev/mtdblock0是块设备。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5273414177cb49360beb3c4ce8a2902e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbeb617b64356b1d68ced5a91e4b9533/" rel="bookmark">
			nvm安装及设置node默认版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要设置默认的Node版本，您可以使用nvm（Node版本管理器）。
首先，使用以下命令安装nvm：
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash 或者
wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash 安装完成后，重新打开终端窗口或运行以下命令以使nvm生效：
source ~/.bashrc 然后，使用以下命令安装所需的Node版本：
nvm install &lt;version&gt; 例如，要安装Node.js v14.17.5，请运行以下命令：
nvm install 14.17.5 安装完成后，使用以下命令将所需的Node版本设置为默认版本：
nvm alias default &lt;version&gt; 例如，要将Node.js v14.17.5设置为默认版本，请运行以下命令：
nvm alias default 14.17.5 现在，您已经成功设置了默认的Node版本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f5c29c3fe0dfcedf7516aa206182290/" rel="bookmark">
			使用arduino IDE开发ESP8266NodeMCU连接DHT11实现温湿度检测并上传onenet官网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 本篇博客记录一下以arduino IDE来开发一下ESP8266NodeMCU，实现用DHT11进行温湿度检测，并且上传新版的onenet官网；我在实现这个小项目的时候，发现网上资料有关onenet的资料都是旧版的，这就有点难受了，本着开源的精神，这篇博客就来弥补一下这方面资料的缺失。
前期准备工作： 硬件方面： 1、ESP8266NodeMCU
2、DHT11传感器
3、一根USB转micoUSB线，杜邦线若干
在新版Onenet上创建一个设备 1、首先我们要先注册一个onenet账号，这里我就不再给大家写具体步骤了。
2、注册完之后，点击箭头所指，进入开发者中心
3、继续点击费用中心
4、接下来会弹出一个崭新的界面
5、将鼠标悬停在左侧箭头所指区域，会展开以下界面 6、选择多协议接入
7、我们点击添加产品
8、根据箭头和方框提示来写一些必要的信息，这个是可以随便写的，只要我们确定联网方式是wifi、接入协议是MQTT(旧版)这几个即可。
9、我们点击立刻添加设备
10、点击添加设备
11、会给我们弹出一个新的界面
12、这里也是可以随便写的，写完必选的选项，点击添加。
13、添加完成之后，我们就可以看到一个新的界面，在这个界面里，设备一开始离线的，这是正常的，此外，我们的设备ID需要记录一下，后续我们需要来根据设备ID来修改一下自己的代码。
14、我们点击这个详情，可以看到我们总的一个设备情况
15、进入新界面后，我们点击添加APIkey
16、这个APIKey是可以由我们自己来设定，这里我就随便写写了，这个官网会给我们生成一个对应的APIKey码，我这里就是随便写的，只要凑够16个就可以。
17、点击提交之后，就会给我们生成一个新的APIKey，这个也要记住，后续写代码也是要记住的。
19、我们点击产品概况，来查看一下我们的产品ID，这个也要记录一下，因为后续写代码我们也要用到的。
到这一步为止，我们的onenet设备就算是配置好了，接下来就是在arduinoIDE上添加一个ESP8266设备了。
arduinoIDE添加ESP8266 如果一开始我们选择使用arduino IDE来编辑ESP8266是需要在编辑器上进行一些操作的
1、打开菜单栏的文件-&gt;首选项，将下面的网址复制到指定位置
http://arduino.esp8266.com/stable/package_esp8266com_index.json 2、然后再打开工具，将鼠标悬停在开发板那个位置，会出现开发板管理，如果没有出现的话，也只是说明arduino版本不同罢了，这一点没啥问题的，如图所示
3、我们点击开发板管理，弹出以下界面，我们在箭头所指区域搜索ESP8266，然后找到一个合适的版本进行下载。
4、开始下载。
5、这过程很容易出错，出错了也不要紧，一旦报错，那就多下载几次，一定要保证网络的通畅，否则会下载不了。
6、 下载完成后，我们需要重启一下我们的IDE才能在开发板的位置发现我们的下载下来的开发板，这里一定要选择我鼠标悬停的开发板，我们的ESP8266NodeMCU对应的开发板就是NodeMCU 1.0，这里千万不能选错，否则很容易出现一些错误。
安装CP2102的驱动 我们一开始将ESP8266NodeMCU与我们的电脑连接的话，是没办法识别到我们的串口的，也就是说，一开始烧录代码是烧录不进去的。大家如果插上ESP8266NodeMCU之后，电脑的设备管理器是会出现下面这个界面。
这里我是之前安装过CP2102的驱动，一开始我看错了以为这个ESP8266NodeMCU板载的是CH340驱动呢，后来仔细看了一下不是，我们还需要安装一个CP2102的驱动，这里我也给大家找了一款合适的驱动，我放在了百度网盘里面CP2102驱动 提取码是:brqt
下载下来之后，我们根据电脑的类型来选择对应的驱动。64位的话，我们就选择X64，如果是32位的话，我们选择X86。
双击运行即可。直接点击下一步，傻瓜式安装。
安装完之后，我们就可以发现串口被识别到了。
至此，我们的前期准备工作算是完成了。
硬件引脚连接 DHT11管脚ESP8266NODEMCU管脚GNDGNDVCC3V3DATAD6 代码部分： #include &lt;ESP8266WiFi.h&gt; #include &lt;PubSubClient.h&gt; #include &lt;ArduinoJson.h&gt; #include &lt;Ticker.h&gt; #include &lt;dht11.h&gt; #define WIFI_DEBUG 0 //1：使用一键配网，其它值则使用默认无线账号密码 #define DHT11PIN 12 //设置DHT引脚为Pin 12 #define ONENET_DISCONNECTED 1 //已经断开 #define ONENET_CONNECTED 2 //已经连接上 #define ONENET_RECONNECT 3 //重连成功 #define VER "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f5c29c3fe0dfcedf7516aa206182290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa4e4a3f793ef14b8f5c7b716def92bd/" rel="bookmark">
			Flask问题解决：Cannot find reference ‘MigrateCommand‘ in ‘__init__.py‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题:Cannot find reference 'MigrateCommand' in '__init__.py' 问题描述 `from flask_migrate import Migrate, MigrateCommand` 报错`ImportError: cannot import name 'MigrateCommand' from 'flask_migrate'` 问题原因 新版的flask_migrate已经删除了MigrateCommand，可以直接在命令行中使用
解决方法 删除`import MigrateCommand`，直接在命令行中使用即可
问题：ModuleNotFoundError: No module named ‘flask._compat’ 问题描述 在flask,flask_script,flask_migrate均使用最新版本时，使用`from flask_script import Manager`时，报错`ModuleNotFoundError: No module named 'flask._compat' 问题原因 可能是Flask的版本更新问题，导致Flask._compat的目录发生变化。
解决方法 编辑flask_script\__init.py文件 修改第十五行的 from flask._compat import text_typef 改为 from flask_script._compat import text_type` AttributeError: ‘Migrate’ object has no attribute ‘create_parser’ 问题描述 使用manager.add_command('db', Migrate)时报错
问题原因 新版本的Migrate没有MigrateCommand，所以不能使用manager.add_command('db', MigrateCommand) 而使用manager.add_command('db', Migrate)时会报错 解决方法： flask_script已经很久没有更新了，flask_migrate已经不再兼容 而flask2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa4e4a3f793ef14b8f5c7b716def92bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3fa473ba7359fbc02548878abe9145e/" rel="bookmark">
			JavaScript面试题：Array.prototype.reduce()的使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		reduce()方法的使用场景 1、语法 array.reduce((previousValue,currentValue,currentIndex,array)=&gt;{},initialValue)
对数组累计执行回调函数并返回最终结果
2、使用场景 2.1 数组元素累计求和 // 不设置初始值initialValue时 let result1 = arr.reduce((previousValue,currentValue,arr) =&gt; { console.log(previousValue,"previousValue ============"); console.log(currentValue,"currentValue ============"); return previousValue + currentValue }) console.log(result1); // 15 // 设置初始值initialValue时 let initialValue = 0 let result2 = arr.reduce((previousValue,currentValue,arr) =&gt; { console.log(previousValue,"previousValue ============"); console.log(currentValue,"currentValue ============"); return previousValue + currentValue },initialValue) console.log(result2); // 15 2.2 二维数组扁平化 let arr = [ [20,30,20,10,32], [21,20,24,19,92], [20,43,20,20,32], [70,30,29,10,12], ] let result = arr.reduce((previousValue,currentValue) =&gt; { return previousValue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3fa473ba7359fbc02548878abe9145e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/123/">«</a>
	<span class="pagination__item pagination__item--current">124/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/125/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>