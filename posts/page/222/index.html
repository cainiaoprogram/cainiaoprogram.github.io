<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/178e76e5aa5c17ecc1a5d393b259502d/" rel="bookmark">
			MySQL之数据查询（聚合函数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SELECT子句的表达式中可以包含所谓的聚合函数（Aggregation Function）。聚合函数常常用于对一组值进行计算，然后返回单个值。除COUNT()函数外，聚合函数都会忽略空值。聚合函数通常与GROUP BY子句一起使用。若SELECT语句中有一个GROUP BY子句，则该聚合函数对所有列起作用。若没有，则SELECT语句只产生一行作为结果。
常用的聚合函数：
COUNT：求组中项数，返回int类型整数
MAX：求最大值
MIN：求最小值
SUM：返回表达式中所有值的和
AVG：求组中值的平均值
1、COUNT()函数
聚合函数中最常用的是COUNT()函数，其用于统计表中满足条件的行数或总行数，返回SELECT语句检索到的行中非NULL值的数目，若找不到匹配的行，则返回0。
语法格式为：COUNT（ { [ALL | DISTINCT]表达式} | *）
例：求会员总人数
SELECT COUNT(*)AS '会员数' FROM Members; 例：统计已结清的订单数
SELECT COUNT(是否结清)AS'已结清的订单数' FROM Sell; 2、MAX()函数和MIN()函数
MAX和MIN函数分别用于求表达式中所有值项的最大值和最小值
语法格式：MAX / MIN （[ALL | DISTINCT]表达式）
例：求订购了图书编号为IS-001的订单的最高订购册数和最低订购册数 SELECT MAX(订购册数),MIN(订购册数) FROM Sell WHERE 图书编号='IS-001'; 3、SUM()函数和AVG()函数
SUM和AVG分别用于求表达式中所有值项的总和与平均值
语法格式：SUM / AVG ( [ ALL | DISTINCT ] 表达式 )
例：求订购了图书编号为IS-01图书的订购总册数
SELECT SUM(订购册数)AS'订购总册数' FROM Sell WHERE 图书编号='IS-01'; 例：求订购图书编号为IS-02图书的订单平均册数
SELECT AVG(订购册数)AS'每笔订单平均册数' FROM Sell WHERE 图书编号='IS-02'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21e6261e02c45d9f478d4e82e2c693a5/" rel="bookmark">
			MySQL2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
数据库
约束
概念和分类
非空约束
唯一约束
主键约束
默认约束
外键约束
数据库设计
数据库设计简介
表关系
数据库 约束 概念和分类 1.约束的概念
约束是作用于表中列上的规则，用于限制加入表的数据。约束的存在保证了数据库中数据的正确性、有效性和完整性
2.约束的分类
非空约束 1.概念
.非空约束用于保证列中所有数据不能有NULL值
2.语法
(1)添加约束
--创建表时添加非空约束 CREATE TABLE表名( 列名 数据类型 NOT NULL, ); --建完表后添加非空约束 ALTER TABLE 表名 MODIFY 字段名 数据类型 NOT NULL; （2)删除约束
ALTER TABLE 表名 MODIFY 字段名 数据类型; 唯一约束 1.概念
唯一约束用于保证列中所有数据各不相同
2.语法
(1)添加约束
--创建表时添加唯一约束 CREATE TABLE表名( 列名 数据类型 UNIQUE [AUTO_INCREMENT], -- AUTO_INCREMENT:当不指定值时自动增长 ); CREATE TABLE 表名( 列名 数据类型， [ CONSTRAINT][约束名称]UNIQUE(列名)); --建完表后添加唯一约束 ALTER TABLE 表名MODIFY 字段名数据类型 UNIQUE; （2）删除约束
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21e6261e02c45d9f478d4e82e2c693a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/becb60d3c7785fa8267e754d9fa8888f/" rel="bookmark">
			Yolov3 模型结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 模型总体结构：
Yolov3可以看作有三部分：Darknet53, FPN, Yolo Head.
Darknet53是Yolov3的主干网络，用来提取图像特征。共提取了三个特征层进行下一步网络的构建，这三个特征层即为“有效特征层”。
FPN 从backbone获取三个有效特征层后，进一步提取特征，进行特征融合，其目的是结合不同尺度的特征信息。
Yolo Head是YoloV3的分类器与回归器。 通过Darknet53与FPN, 可以获得三个加强过的特征层。他们的shape分别是：（52，52，128）, （26，26，256）， （13，13，512）.
1. 结构分析：
1.1：backbone:
YoloV3的主干网络是Darknet53. 它使用残差网络Residual.
主干部分是一次1x1 conv和一次3x3 conv. 残差shortcut部分不做任何处理，直接将主干和的输出和从shortcut过来的输入结合。
如上图所示，共有5个残差模块。后面的xN,表示这个残差模块包含N个残差块。
Darknet53的每一个darknetConv2D后都紧跟BatchNormalization标准化与LeakyReLU部分。
摒弃了POOLing，用conv的stride来实现降采样。在这个网络结构中，使用的是步长为2的卷积来进行降采样。
例子代码：
import tensorflow as tf import tensorflow.keras as keras from tensorflow.keras.models import Sequential import tensorflow.keras.layers as layers #filters_shape: kernel_Size_H, kernel_Size_W, Input_Channel,filter_count def convolutional(input_layer, filters_shape, downsample=False, activate=True, bn=True, activate_type='leaky'): if downsample: input_layer = tf.keras.layers.ZeroPadding2D(((1, 0), (1, 0)))(input_layer) padding = 'valid' strides = 2 else: strides = 1 padding = 'same' conv = tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/becb60d3c7785fa8267e754d9fa8888f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/264cb1e0031cc4cc3315f29bac143f1d/" rel="bookmark">
			（仿牛客社区项目）Java开发笔记6.2：开发社区搜索功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 开发社区搜索功能1.dao层2.service层3.event包4.controller层5.view层6.功能测试 开发社区搜索功能 1.dao层 discusspost-mapper.xml中的insertDiscussPost这一行添加keyProperty属性，插入数据Mybatis会将生成的主键放入实体类中。
&lt;insert id="insertDiscussPost" parameterType="DiscussPost" keyProperty="id"&gt; insert into discuss_post(&lt;include refid="insertFields"&gt;&lt;/include&gt;) values(#{userId},#{title},#{content},#{type},#{status},#{createTime},#{commentCount},#{score}) &lt;/insert&gt; 2.service层 添加ElasticsearchService类，EventConsumer类中添加方法。
package com.gerrard.community.service; import com.alibaba.fastjson.JSONObject; import com.gerrard.community.dao.elasticsearch.DiscussPostRepository; import com.gerrard.community.entity.DiscussPost; import org.apache.lucene.search.TotalHits; import org.elasticsearch.action.search.SearchRequest; import org.elasticsearch.action.search.SearchResponse; import org.elasticsearch.client.RequestOptions; import org.elasticsearch.client.RestHighLevelClient; import org.elasticsearch.index.query.QueryBuilders; import org.elasticsearch.search.SearchHit; import org.elasticsearch.search.builder.SearchSourceBuilder; import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder; import org.elasticsearch.search.fetch.subphase.highlight.HighlightField; import org.elasticsearch.search.sort.SortBuilders; import org.elasticsearch.search.sort.SortOrder; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.data.domain.Page; import org.springframework.data.elasticsearch.client.elc.ElasticsearchTemplate; import org.springframework.stereotype.Service; import java.util.HashMap; import java.util.LinkedList; import java.util.List; import java.util.Map; @Service public class ElasticsearchService { @Autowired private DiscussPostRepository discussPostRepository; // @Autowired // private ElasticsearchTemplate elasticsearchTemplate; @Qualifier("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/264cb1e0031cc4cc3315f29bac143f1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/546eda645b953a8eb09220c5a5358d71/" rel="bookmark">
			python生成二维矩阵的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、直接用列表生成m行n列的矩阵 m,n = map(int,input().split()) matrix = [[0]*(m)]*(n) 输出为：
注意：这种方式生成的矩阵存在一定的问题，比如，无法给特定位置的元素赋值，例如：
matrix[1][1] = 9 输出为：
可见，第二列的元素全部被赋值为9了
2、采用numpy生成想要维度的矩阵 import numpy as np x,y = map(int,input().split()) a = np.ones((x+1,y+1)) 输出为：
上面的输出特别漂亮，一个完美的矩阵形式输出，下面我们试一下修改特定位置的元素值。
import numpy as np x,y = map(int,input().split()) a = np.ones((x+1,y+1)) # 参数为元组 (x+1,y+1) a[1][1] = 9 print(a) 输出为：
可见，我们成功修改了第二行第二列的元素值，因此通过numpy生成的矩阵更具有可操作性。比如下面的操作：
import numpy as np x,y = map(int,input().split()) a = np.ones((x+1,y+1)) for i in range(1,x+1): for j in range(1,y+1): a[i][j] = a[i-1][j] + a[i][j-1] print(a) 输出为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/546eda645b953a8eb09220c5a5358d71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b573f1531060d7810fe5afee85b20a18/" rel="bookmark">
			IDEA创建springboot时Maven home directory修改不起作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IDEA创建springboot时Maven home directory修改不起作用 首先我已经将idea默认的maven配置修改
但是新建springboot项目的时候Maven home directory又自动改变了
这是因为用idea创建的springboot目录中的.mvn在作祟
把这些没用的都删除掉，然后改回自己的Maven home directory刷新maven就好了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7439385faf1363b6a50c7540c4ba7e92/" rel="bookmark">
			VMware ESXI7.0版本的安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware vSphere是一套业内最完整最强健的虚拟化平台。创建资源池来管理计算、 网络和存储容量与易用性，并提供最高水平的服务，每个应用程序工作负载以最低的总成本。VSphere 取决于世界上要求最苛刻的数据中心虚拟化您业务关键型应用程序为空前的灵活性和可靠性。
VMware-VMvisor-Installer-7.0b-16324942.x86_64.iso 下载链接
链接：https://pan.baidu.com/s/1trQfQSLDo0DNS1_81hPLRw 提取码：6itq
安装方法
首先下载VMware-VMvisor-Installer-7.0b-16324942.x86_64.iso文件，用虚拟光驱挂载或者解压运行
加载VMkernel文件 按【Enter】键开始安装VMware ESXi 7.0 系统出现“End User License Agreement（EULA）”界面，是用户许可协议，按【F11】键接受“Accept and Continue”，许可协议
扫瞄到的硬盘装置，没有问题直接按键盘『Enter』，如有多块硬盘，请依需求选择
提示选择键盘类型，选择“US Default”，默认美国标准，按【Enter】键继续 系统提示配置root用户的密码，输入自己的密码，按【Enter】键继续
该硬盘要被分区格式化了，确定请按键盘『F11』
系统安装中
安装完成，按键盘『Enter』，重新启动
进入VMware ESXi 7.0正式界面 下图为安装完成的开机画面，要进行系统设定/ 登陆，请按键盘『F2』；关机/ 重启，请按键盘『F12』。按键盘『F2』进行设置
输入帐号root / 密码，输入完毕后按『Enter』键登录
选择“Configure Management Network”配置管理网络
选择“IPv4 Configuration”对IP进行配置 设置要使用『动态』或『静态（固定）』的IP 设定。如要指定固定IP，请选择「Set static IPv4 address and network configuration」，并且输入相对应的IP，确认没问题请按键盘『Enter』一般我们选择静态ip地址
按键盘『Esc』，离开系统设置，离开设定时，会询问是否要改变设定并退出，是请按键盘『Y』；否请按键盘『N』。
完成主机IP配置
使用浏览器登录 ESXi 7.0主机 地址：https://192.168.100.201/ 进入ESXi 7.0主机操作界面，可以进行基本的配置和操作，更多的功能实现需要依靠vCenter Server实现
创建虚拟机 选择自己系统镜像 然后一直下一页
最后
虚拟机部署完成 打开虚拟机，输入账号密码即可操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2fc821aa472f2b51ed785122fec5168/" rel="bookmark">
			【方向盘】使用IDEA的60&#43;个快捷键分享给你，权为了提效（Live Template&amp;Postfix Completion篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文已被https://yourbatman.cn收录；女娲Knife-Initializr工程可公开访问啦；程序员专用网盘https://wangpan.yourbatman.cn；技术专栏源代码大本营：https://github.com/yourbatman/tech-column-learning；公号后台回复“专栏列表”获取全部小而美的原创技术专栏
你好，这里是Java方向盘，我是方向盘(YourBatman)，坐稳扶好，开始发车。
TitleLink所属专栏【方向盘】-IntelliJ IDEA源代码https://github.com/yourbatman/FXP-java-ee程序员专用网盘公益上线啦，注册送1G超小容量，帮你实践做减法https://wangpan.yourbatman.cnJava开发软件包(Mac)https://wangpan.yourbatman.cn/s/rEH0 提取码：javakit女娲工程http://152.136.106.14:8761版本约定[Mac OS 12.3],[iTerm2 3.4.15（zsh 5.8）],[IntelliJ IDEA 2021.3.3] 📚前言 本系列上篇文章介绍了IDEA里关于代码重构相关的快捷键，利用好Java强类型语言的特性，加上IDEA的重构快捷键，可以在重构代码时带来大大的便捷及“安全保障”，进而为那颗很想重构但迟迟不敢动手的心提供先决条件。
敲代码过程中，总是“讨厌”经常写些重复代码，如：logger日志声明、main方法、System.out.println() 。。。本文就针对这个“痛点”，一起来学习IDEA的Live Template和Postfix Completion功能，看看能给我们带来多大的便捷。
✍正文 初级程序员热衷于“自动”生成代码，各式各样的代码生成工具，譬如MyBatis逆向工程、easycode插件等等。很多公司在团队内是禁止使用这类工具的，理由很简单：生成出来的垃圾代码太多。
但日常编程过程中，我们确实经常会遇到需要重复写的代码片段，怎么破？这就是接下来要讨论的内容，使用IDEA的“工具”来替代这些“重复劳动”。
IntelliJ IDEA快捷键 本文并非直接介绍快捷键，但是Live Template和Postfix Completion都有着类似的作用，因此放在此专栏一并介绍了。
✌Live Template 何为Template？ 顾名思义，按照预先定义好的内容、格式执行或者输出。使用模板一般有一些优势：
写出来的代码风格能保持一致仅需输入几个引用字符即可获得完整的代码块逻辑，并能保证正确性不会出现CV代码，忘记改某些参数出现的编译甚至运行期问题 那何为Live Template呢？ 区别在于这个Live，单词直译为：现场直播的，当前所关心的。所以笔者对Live Template的理解是：具有上下文感知能力的模板，相较于普通的Template更为智能、聪明。
网上其实有不少文章“吹嘘” Live Template功能强大、好用的，可谓不吝赞美之词。但是呢，笔者结合自己不短的工作经验以及学习经验，发现此功能吹嘘的人多，用的人是真的少。所以每每看到这类文章时，想问作者三句：这真的是你的使用经验分享吗？那些“强大”的功能真的在用？还是就为了吸引眼球博取流量而已呢？
在这，笔者先将自己个人的观点摆在前头哈：Live Template这个功能确实很强大，支持很多方式甚至groovy脚本，但从效率的角度来讲，它的强大和灵活反倒让 通用性和实用性 变差。因此，即使笔者在刚使用IDEA时（2017年）就已经接触和使用过Live Template，但直到现在对它依旧不感冒，使用的功能点甚至越来越少。
话说回来，仅是个观点而已，这和个人的使用习惯、认知是强相关的嘛。虽然我用得少，但还是在用滴，下面就简单聊聊这个功能吧。如下图所示：这是笔者当前使用的所有Live Template模板了。
Tips：按快捷键commond + j可显示出当前环境下（类里or方法里）能用的所有的Live Template模板
类里（6个）：
方法里（3个）：
下面是笔者IDEA的设置：
由于笔者好些年不写前端、不会写Android，偶尔写写Groovy、Shell等脚本，所以从上图可以看到只打开了Java的几个模板项而已。
效果总览 通过录制的这张动图，能感受到Live Template的强大，感受到其效果：
这里一共用到了三个模板：
psvm：生成main方法fori：生成普通for循环sout：生成标准输出语句 话不多说，下面通过介绍笔者自己用的模板，来简单感受一下Live Template吧。
main和psvm 使用方式：在类内任意地方，敲main或者psvm，然后按tab键触发。
效果：快速生成/声明main方法
值得注意，在早期的IDEA版本中只支持psvm这一个Live Template，从xxx版本开始（具体从哪个版本开始我记不得了）也支持main了（这对eclipse转过来的开发者是福音呀），效果完全同psvm。本人偏爱使用main，明显更见名知意些嘛。
sout、serr 在方法内部触发，快速“生成”标准输出和错误输出语句。
sout：
System.out.println(); // sout标准输出 serr
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2fc821aa472f2b51ed785122fec5168/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/457d52bf9a662d034eba5548f891b1ed/" rel="bookmark">
			【论文精读】Grounded Language-Image Pre-training（GLIP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 背景 https://arxiv.org/abs/2112.03857 https://github.com/microsoft/GLIP 这篇论文做的任务是phrase grounding，属于visual grounding的一种。phrase grounding的任务是输入句子和图片，将句子中提到的物体都框出来。visual grounding其他任务和细节可以参考
https://zhuanlan.zhihu.com/p/388504127
GLIP既可以做目标检测也可以做grounding，
目标检测：
在扩增目标检测领域为SOTA，zero-shot效果较好，也可以做zero-shot目标检测任务。
与常规目标检测任务相比语义丰富。grounding：
与常规grounding任务相比可以做目标检测任务。 二、贡献 贡献
将目标检测和phrase grounding任务统一起来进行预训练扩大视觉语义迁移学习能力强 性能
27M关联数据上训练。在目标识别任务上有很强的零样本和小样本迁移性能Zero-shot：coco val上49.8AP，LVIS val上26.9AP微调后：COCO val上60.8AP下游13个目标检测任务时，1个样本的GLIP可以与Dynamic Head相匹敌 三、方法 3.1 方法1：检测和grounding任务统一 1. background: 对于检测数据集：
训练时输入标签名(person、hairdryer）、框、图片。
测试时输入图片，预测出框和标签名。
训练过程如下：
2. background as grounding：
groudning模型的输入是短语、短语中名词的框和图片。
将object模型转为grounding的办法：通过prompt的方式将标签名转化为短语。
如coco有80个标签，将80个标签用逗号连接，短语前加“Detect：”，来组成短句。
公式2变成公式3的过程中，T的大小会变化，从Nc变成NM
构建token：上图流程图中，M(sub-word tokens)总是比短语格式c多，原因有四个1）一些短语占了多个toeken位置，比如 traffic light。2）一些短语被分开成sub words，比如toothbrush分成了 tooth#, #brush。3）一些是添加的token，如逗号，Deteckt等，4）结尾会添加[NoObj]的token。在训练的时候，phrase是正例的话，多个subwords都是正例。测试时多个token的平均pro作为短语的probability。
3. detection和grounding联动：由上面的方法，可以用grounding模型来预训练检测任务，从而可以迁移GLIP模型做zero-shot的检测
3.2 方法2: deep fusion，视觉和语言联合 fusion部分公式如下：
​​​​​​​​​​​​​​O0是视觉backbone的feature, P0 是文本backbone的feature
X-MHA（cross-modality multi-head attention module）
L是DyHead中DyHeadModules个数，BERT Layer为新增。
attention部分在多模态中比较常见，比如co-attention、guided attention等。可以参考多模态中attention其他优化。
DeepFusion优点：
提高了phrase grounding效果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/457d52bf9a662d034eba5548f891b1ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd44308d10112412630a3c3cc63ae2a3/" rel="bookmark">
			最简单理解并实现斐波那契数列函数（c语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现斐波那契数列数列函数前我们要知道它是什么？
最简单理解就是一个数列为：0 1 1 2 3 5 8 13 21。。。。。。
第一个数为0第二个数为1，之后的每个数为前面两个数的的和（是不是很简单呢）
第二步就是实现它了！
第一种方法是循环（for循环）
#include&lt;stdio.h&gt;//（这里引下头文件） int main() { int a=0;//(初始化你要找的数） scanf("%d",&amp;a);//(赋值给它噢） int n1=0;//(定义第一个数） int n2=1;//(定义第二个数） int n=1;//(定义第三个数） int i=0;//(为循环找循环数） if(a==1)//（如果是第一个数直接输出0） { return printf("0\n"); } else if(a==2)//（如果是第二个数直接输出1） { return printf("1\n"); } else { for(i=0;i&lt;a-2;i++)//（因为已经排除了前面两个数，从第三个数开始，所以要n-2噢） {n=n1+n2;//第三个数等于前面两数之和 n1=n2;//第一个数等于第二个数 n2=n;//第二个数等于第三个数 } //上面循环的意思就是三个数三个数的依次遍历斐波那契数列，直到找到你要的数噢 return printf("%d\n",n);//找到了直接返回它 } //到这里循环实现就完成了噢 return 0; } //第二种方法是递归
#include&lt;stdio.h&gt;//（这里引下头文件） int is_num(int n)//递归 { if (n == 1 ) { return 0;//如果是第一个数直接返回0 } else if (n == 2) { return 1;//如果是第二个数直接返回1 } else return is_num(n - 1)+ is_num(n-2);//直接返回前n两个数依次迭代计算直到计算到第一个数和第二个数为止 } int main() { int n = 0;//(初始化你要找的数） scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd44308d10112412630a3c3cc63ae2a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/858b8b8e143dbd037bf80d2c0d8ba950/" rel="bookmark">
			js鼠标点击事件监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鼠标移动监听：
&lt;script&gt; var cont = 0; function f() { document.getElementById("an1").innerHTML = ++cont; } &lt;/script&gt; &lt;p&gt;移动次数：&lt;span id="an1"&gt;0&lt;/span&gt;&lt;/p&gt; &lt;div style="width: 100px; height: 100px; background-color: aqua;" onmousemove="f()"&gt;&lt;/div&gt; 鼠标在指定区域div中每移动一次就会更改数值。
innerHTML：可以更改值
页面加载监听：
&lt;script&gt; window.onload=function(){ //加载完毕执行代码 window.open("https://www.baidu.com"); } &lt;/script&gt; 下拉框选着监听：
&lt;script&gt; function f(obj) { var url = obj.value; if (url != "请选择") { window.open(url); } } &lt;/script&gt; &lt;select onchange="f(this)"&gt; &lt;option value="请选择"&gt;请选择&lt;/option&gt; &lt;option value="http://www.baidu.com"&gt;百度&lt;/option&gt; &lt;/select&gt; window.open(url)：打开地址，要加http协议哦:http://
按钮提交监听：
&lt;script&gt; function f(obj) { var url = document.getElementById("name").value; if (url.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/858b8b8e143dbd037bf80d2c0d8ba950/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/716c5bd32475ce925ec3fd04d63b8153/" rel="bookmark">
			使用锁代替节流的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目背景 购物车修改商品数量
代码 async skuNumChange(num, index) { //规定修改后的值必须为整数且大于0，同时非数字无法通过 if (this.cartInfoList[index].skuNum + num &gt; 0 &amp;&amp; num % 1 === 0) { const { code } = await reqAddOrUpdateShopCart( //发起请求修改数量 this.cartInfoList[index].skuId, num //增加或减少多少商品，正数为加，负数为减 ); if (code != 200) { alert("修改失败"); } } else { alert("输入有误，请重新输入"); } this.getDate(); //发起请求返回购物车数据 }, 当快速点击“-”号时，数量会小于1，原因是没有进行节流处理，当快速点击时，异步请求没来得及返回服务器的最新数据，所以此时浏览器商品数量还没有发生改变，跳过了判断条件
（比如现在数量为2，快速点击，第一次点击修改后的数据为1，发起请求修改商品数量，第二次点击，此时浏览器端 cartInfoList 中的商品数量仍为2，所以通过判断条件，再次发起请求修改商品数量，最终商品数量为2-1-1=0，出现bug）
解决 一般方法是用节流，在这里用lock锁实现
data() { return { lock: true, //加上锁防止点击过快 }; }, async skuNumChange(num, index) { if (this.lock){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/716c5bd32475ce925ec3fd04d63b8153/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd8dd52f59038c8a1e1528023e536285/" rel="bookmark">
			hidl开发实践记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、hidl基本语法
二、编写hal文件
三、编译环境设置
四、生成Android.bp文件
六、编译
七、添加hidl接口清单
八、selinux配置
一、hidl基本语法 hidl文件后缀为.hal，语法借鉴了C语言和Java语言，相对来说比较简单。
/** */ 表示文档注释。此样式只能应用于类型、方法、字段和枚举值声明。
/* */ 表示多行注释。
// 表示注释一直持续到行尾。除 // 之外，换行符与任何其他空格一样。
文件第一行非注释语句为package 包名@版本;
interface声明接口，不含显式 extends 声明的接口会从 android.hidl.base@1.0::IBase（类似于 Java 中的 java.lang.Object）隐式扩展。隐式导入的 IBase 接口声明了多种不应也不能在用户定义的接口中重新声明或以其他方式使用的预留方法。这些方法包括：
ping
interfaceChain
interfaceDescriptor
notifySyspropsChanged
linkToDeath
unlinkToDeath
setHALInstrumentation
getDebugInfo
debug
getHashChain
import 语句是用于访问其他软件包中的软件包接口和类型的 HIDL 机制。import 语句本身涉及两个实体：
导入实体：可以是软件包或接口；以及被导入实体。
被导入实体：也可以是软件包或接口。
导入语句使用完全限定类型名称语法来提供被导入的软件包或接口的名称和版本：
import android.hardware.nfc@1.0; // import a whole package import android.hardware.example@1.0::IQuux; // import an interface and types.hal import android.hardware.example@1.0::types; // import just types.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd8dd52f59038c8a1e1528023e536285/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c1bb2a71d29d5e5add1c2bccbf92108/" rel="bookmark">
			Ublox F9P通过NTRIP实现实时RTK定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在开一个新坑，后面慢慢填~
2022-07-23更新：测试视频 NTRIP_ROS测试
一、前言 首先，什么RTK呀、NTRIP呀，RTKLIB呀，我都还是新手不是很懂，所以可能会有搞错的地方，望包涵~（什么？你也不懂，那就上百度必应一下吧~）
之前在跑GVINS的时候，发现曹博（就是GVINS作者）写的 ublox_driver 不仅可以解析ZED-F9P模块的 UBX-RXM-RAWX 、 UBX-RXM-SFRBX 、 UBX-NAV-PVT 数据 （废话~因为GVINS要用呀~），还可以接收RTCM数据以实现RTK，于是想利用它配合F9P实现实时的RTK，可以作为算法的参考。
不过呢， ublox_driver 中获取RTK的方式也存在一些问题，就是它只能使用免费、免认证、无需提供GGA语句的NTRIP server（NTRIP caster），而需要认证，也就是要用户名和密码、需要提供GGA语句的NTRIP server就不行了，比如说我在用的千寻位置就是这种。具体原因是这样的：
1）ublox_driver 的readme告诉我们，在 ublox_driver 中可以指定一个TCP端口，利用这个端口接收RTCM 数据流；
2）这个RTCM数据流是通过RTKLIB从NTRIP server那里获取的，具体来说就是利用了RTKLIB里面的 str2str 这个小程序拿到了RTCM数据（可以简单理解为差分修正数据），然后通过指定的TCP端口发送给ublox_driver，然后ublox_driver利用RTCM数据拿到RTK解，具体可以看 ublox_driver 里面写的很详细；
3）str2str 通过指定NTRIP caster 域名、端口号、挂载点（也就是in），再指定将数据输出到指定的TCP端口（也就是out），比如说 ublox_driver 给出的格式（具体的的格式说明得参考RTKLIB的使用手册）：
./str2str -in ntrip://${NTRIP_SITE}:${NTRIP_PORT}/${MOUNT_POINT} -out tcpsvr://:3503 其实问题就出现在上面的第三点。
这里如果使用的是免费、无需认证的NTRIP caster（比如说我试过的 rtk2go.com:2101，挂载点选择的杭州的 ）那么上述方法似乎好像是可以使用的，但是在我这里始终没有收敛到固定解，一直是浮点解。
（PS: 上面这种情况我猜测是因为我没有将GGA 语句发送给NTRIP caster）
当我尝试使用付费的NTRIP caster（比如千寻位置，因为我买了）时，在上述操作的基础上添加了用户名和密码，但是不行。于是查了好久，才发现千寻不仅需要认证，而且需要你的GGA语句，而 str2str 其实是可以生成并发送GGA语句的，只需要提供一个给定的经纬高即可。具体可以看我在github上提的 issue 9 。
但是，问题又来了，运行 str2str 的时候输入的是一个固定的经纬高，如果我移动了呢？我总不能又Ctrl + C把 str2str 停掉，然后再输入一个新的当前位置吧？也就是说用 str2str 这种方式在移动过程中可能会不能用（当然，也有可能是我打开方式不对）。
于是，一个简单的想法来了：既然我们可以通过 ublox_driver 的PVT 消息获取当前的经纬高，然后再给到 str2str 不就行了？很遗憾，我不会~可能得改 str2str 部分的源码吧。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c1bb2a71d29d5e5add1c2bccbf92108/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/034a161f442a4850090002fc11450eff/" rel="bookmark">
			uview框架upload组件遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 废话不多说，直接上代码
&lt;view class="wrap"&gt;
&lt;view class="pre-box" v-if="!showUploadList"&gt;
&lt;view class="pre-item" v-for="(item, index) in lists" :key="index"&gt;
&lt;image class="pre-item-image" :src="item.url" mode="aspectFill" style="width: 120rpx;height: 120rpx;"&gt;&lt;/image&gt;
&lt;view class="u-delete-icon" @tap.stop="deleteItem(index)"&gt;
&lt;u-icon name="close" size="20" color="#ffffff"&gt;&lt;/u-icon&gt;
&lt;/view&gt;
&lt;/view&gt;
&lt;/view&gt;
&lt;u-upload :deletable="true"
:custom-btn="true" ref="uUpload" name="file"
:max-count='4'
@on-uploaded="onUploaded"
@on-change="onChange"
:header = "heard"
:show-upload-list="false" :action="action"&gt; &lt;view slot="addBtn" class="slot-btn" hover-class="slot-btn__hover" hover-stay-time="150"&gt;
&lt;u-icon name="photo" size="50" color="#c0c4cc"&gt;&lt;/u-icon&gt;
&lt;/view&gt;
&lt;/u-upload&gt;
&lt;/view&gt;
这里我使用的是自定义上传图片样式，（声明lists为数组）
根据官方文档的写法：
然后我就直接在onReady(){}方法中调用如上的赋值变量
但是很奇怪，赋值的变量是初始值，导致于上传文件后，显示的图片为空，
解决方法，直接在组件的onUploaded()事件命名一个空数组赋值，如下：
然后lists的数据能正常获取 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8653dba527b469fa0de4840477bb9bd5/" rel="bookmark">
			aardio从高级选项卡中分离出独立窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		就像很多浏览器一样，标签页可以变成独立窗口。arrdio的高级选项卡也可以。
总的思路很简单，就是把选项卡窗体的父窗口和样式修改一下。
里面有一个关键点，就是必须把独立出来的窗体从选项卡容器（container）的子窗口队列中移除。因为tbs.loadform的本质是tbs.container.loadform，也就是mainform.custom.loadform。而custom 控件的 loadForm 函数会将窗体加载为子窗口, 自动维护一个子窗口队列，显示一个子窗口就会隐藏其他子窗口。如果不从这个队列中移除，就会出现，一切换选项卡，窗体就看不见了的情况。这个队列就是custom._forms。虽然它的名字带下划线，像个常量，其实可以移除其中的元素。
此外还有一些细节，代码里有说明。
下面的代码是aardio工程模板“横版导航”，其中50-93行是我们增加的代码，其余没有修改。
import fonts.fontAwesome; import win.ui; /*DSG{{*/ mainForm = win.form(text="高级选项卡分离为独立窗口";right=1040;bottom=642;bgcolor=16777215;border="none") mainForm.add( caption={cls="bkplus";text="选项卡变独立窗口";left=35;top=12;right=160;bottom=30;color=15780518;dl=1;dt=1;font=LOGFONT(h=-16);z=5}; custom={cls="custom";left=0;top=40;right=1040;bottom=643;bgcolor=16777215;db=1;dl=1;dr=1;dt=1;z=1}; logo={cls="bkplus";text='\uF0AD';left=6;top=9;right=35;bottom=34;color=15780518;dl=1;dt=1;font=LOGFONT(h=-18;name='FontAwesome');z=4}; navFirst={cls="plus";text="主页";left=166;top=5;right=260;bottom=40;align="left";color=16777215;dl=1;dt=1;font=LOGFONT(h=-16);iconStyle={align="left";font=LOGFONT(h=-19;name='FontAwesome');padding={left=12;top=4}};iconText='\uF00A';notify=1;paddingLeft=1;paddingRight=1;paddingTop=3;textPadding={left=39;bottom=1};x=0.5;y=0.2;z=3}; navHelp={cls="plus";text="帮助";left=462;top=5;right=556;bottom=40;align="left";color=16777215;dl=1;dt=1;font=LOGFONT(h=-16);iconStyle={align="left";font=LOGFONT(h=-19;name='FontAwesome');padding={left=12;top=4}};iconText='\uF06A';notify=1;paddingLeft=1;paddingRight=1;paddingTop=3;textPadding={left=39;bottom=1};x=0.5;y=0.2;z=7}; navHotkey={cls="plus";text="热键";left=265;top=5;right=359;bottom=40;align="left";color=16777215;dl=1;dt=1;font=LOGFONT(h=-16);iconStyle={align="left";font=LOGFONT(h=-19;name='FontAwesome');padding={left=12;top=4}};iconText='\uF11C ';notify=1;paddingLeft=1;paddingRight=1;paddingTop=3;textPadding={left=39;bottom=1};x=0.5;y=0.2;z=8}; navSetting={cls="plus";text="设置";left=363;top=5;right=457;bottom=40;align="left";color=16777215;dl=1;dt=1;font=LOGFONT(h=-16);iconStyle={align="left";font=LOGFONT(h=-19;name='FontAwesome');padding={left=12;top=4}};iconText='\uF0AD';notify=1;paddingLeft=1;paddingRight=1;paddingTop=3;textPadding={left=39;bottom=1};x=0.5;y=0.2;z=6}; titleBar={cls="bkplus";left=0;top=0;right=1042;bottom=41;bgcolor=14977280;dl=1;dr=1;dt=1;z=2} ) /*}}*/ import win.ui.simpleWindow; win.ui.simpleWindow( mainForm ); import win.ui.tabs; var tbs = win.ui.tabs( mainForm.navFirst, mainForm.navHotkey, mainForm.navSetting, mainForm.navHelp ); tbs.skin({ foreground={ active=0xFFFFFFFF; default=0x00FFFFFF; hover=0x38FFFFFF }; color={ default=0xFFFFFFFF; }; checked={ foreground={default=0xFFFFFFFF;}; color={default=0xFF42A875;}; } }) tbs.loadForm(1,"\dlg\first.aardio" ); tbs.loadForm(2,"\dlg\hotkey.aardio" ); tbs.loadForm(3,"\dlg\setting.aardio" ); tbs.loadForm(4,"\dlg\help.aardio" ); tbs.selIndex = 1; //为每个选项卡设置两个事件函数 for(i=1;tbs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8653dba527b469fa0de4840477bb9bd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c8602068b4d5c54396c49c30920f1af/" rel="bookmark">
			为什么会出现梯度爆炸和梯度消失现象？怎么缓解这种现象的发生？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：梯度消失现象在深度神经网络训练过程中表现得尤为突出，随着网络层数的加深，损失在反向传播时梯度在不断减小，导致浅层网络的学习进行不下去，参数得不到有效更新。为什么会出现这种现象呢？下面小编将从神经网络反向传播（BP）原理上揭露出现梯度消失和梯度爆炸现象本质以及如何缓解。
目录
1、梯度消失和梯度爆炸的原因
2、解决办法
1、梯度消失和梯度爆炸的原因 以下图为例，通过推导反向传播过程来讲解网络训练过程中梯度消失和梯度爆炸现象产生的原因。
假设训练时需要使用梯度下降法对、、进行参数更新，那么就需要损失反向传播分布对这三个参数求取梯度。
①针对，
②针对，
③针对，根据链式求导法则可知，有3条路径可以到达，如图中的红黄蓝3条线，对的偏导等于这3条路径之和，为了方便，就以红色这条线为例，其中非线性变换部分，是非线性函数。
由上面3式求导过程可以推广，当网络深度大大增加，损失对浅层网络权重参数的偏导可以表示为：
其中表示大致的网络层数，表示非线性变换的次数。
根据上面求参数梯度的公式不难发现，如果要细分的话，梯度消失和梯度爆炸有以下几种原因：①网络深度过大；②激活函数选择不当；③参数初始化不当，导致参数​​​过大或过小；④损失函数选择不当；⑤神经元激活值的分布不当，神经元值过大或过小。在网络的实际学习过程中，①②③项是导致梯度消失和梯度爆炸现象发生的主要因素，但梯度消失和梯度爆炸问题的根源都是因为网络太深，网络权值更新不稳定造成的，本质上是因为梯度反向传播中的连乘效应。总之，不管发生梯度爆炸还是梯度消失现象，都会导致网络很难学习下去，所以在深度学习任务中要尽量避免这些现象的发生。
2、解决办法 （1）预训练+微调(pre-training+fine-tunning)：其基本思想是每次训练一层隐节点，训练时将上一层隐节点的输出作为输入，而本层隐节点的输出作为下一层隐节点的输入，此过程就是逐层“预训练”（pre-training）；在预训练完成后，再对整个网络进行“微调”（fine-tunning）。此思想相当于是先寻找局部最优，然后整合起来寻找全局最优，此方法有一定的好处，但是目前应用的不是很多了。
（2）梯度剪切（对梯度设定阈值）：这个方案主要是针对梯度爆炸提出的，其思想是设置一个梯度剪切阈值，然后更新梯度的时候，如果梯度超过这个阈值，那么就将其强制限制在这个范围之内，这可以防止梯度爆炸。
（3）权重正则化：另外一种解决梯度爆炸的手段是采用权重正则化，正则化主要是通过对网络权重做正则来限制过拟合。如果发生梯度爆炸，那么权值就会变的非常大，反过来，通过正则化项来限制权重的大小，也可以在一定程度上防止梯度爆炸的发生。
（4）选择relu等梯度大部分落在常数上（梯度越接近1越好）的激活函数：relu函数的导数在正数部分是恒等于1的，因此在深层网络中使用relu激活函数就不会导致梯度消失和爆炸的问题。
（5）BN：其可以有效解决梯度的理由参考文章https://blog.csdn.net/Mike_honor/article/details/125915321?spm=1001.2014.3001.5501。
（6）残差网络结构
相比较于以前网络的直来直去结构，残差网络中有很多这样的跨层连接结构，这样的结构在反向传播中具有很大的好处，因为跨层连接结构（短路机制）可以无损地传播梯度，不会导致梯度消失。
（7）LSTM的“门(gate)”结构
LSTM全称是长短期记忆网络（long-short term memory networks），是不那么容易发生梯度消失的，主要原因在于LSTM内部复杂的“门”(gates)，如下图，LSTM通过它内部的“门”可以接下来更新的时候“记住”前几次训练的”残留记忆“。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd35483c6c11d513fcce8fcbd9f52fcb/" rel="bookmark">
			c语言经典50道例题---精华篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码1. 阶乘相加，当输入为5时-&gt;5!+4!+3!+2!+1!的和 define _CRT_SECURE_NO_WARNINGS 1 #include &lt;math.h&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() { //阶乘的进阶版 int n, i, sum = 0, k = 1;// n为阶乘, i为循环次数, sum求和 scanf("%d", &amp;n);//当输入为5时-&gt;5!+4!+3!+2!+1!的和 for (i = 1; i &lt;= n; i++) { k = k * i;//求阶乘 sum += k;//求每个阶乘的和 } printf("%d!=%d", n, sum); } 代码2. 1-2+3-4+5......的和 int main() { int i, sum = 0, sign = 1;//i用于循环,sum求和,sign用于调整正负号 int n; scanf("%d", &amp;n);//输入一个数，从1开始累加到这个数 for (i = 1; i &lt;= n; i++) { //i&gt;n时结束循环 sum += i * sign;//通过i*sign变正负号，在通过sum相加求和 sign = -sign;//变正负号作用 } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd35483c6c11d513fcce8fcbd9f52fcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9d34613aa3469f4c1dbf517d74acfc9/" rel="bookmark">
			如何为VBA的私有过程设置快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 VBA中的Sub过程有两种，分别是公用（Public）和私有（Private），如果Sub之前省略关键字，那么该过程为公用过程。
示例文件中模块中有如下两个过程。
按&lt;Alt+F8&gt;组合键打开【宏】对话框，如下图所示。
在【宏】对话框中，仅显示公用过程PublicDemo。
单击【宏】对话框中【选项】按钮，打开【宏选项】对话框，可以为代码过程设置快捷键，如下图所示。
那么问题来了，【宏】对话框中不显示私有过程，是否可以为私有过程设置快捷键呢？
答案是肯定的，Excel操作界面中无法直接设置，可以使用VBA代码过程进行设置。
代码如下。
Private Sub SetShortKey() Application.OnKey "^+W", "PrivateDemo" End Sub 运行过程SetShortKey，在Excel界面中按&lt;Ctrl+Shift+W&gt;组合键，将运行过程PrivateDemo显示如下所示的对话框。
使用如下代码可以取消快捷键关联
Private Sub SetShortKey() Application.OnKey "^+W", "" End Sub 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/809c4e97e1efced8344b4f6bab307758/" rel="bookmark">
			（仿牛客社区项目）Java开发笔记4.5：实现关注列表、粉丝列表功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 实现关注列表、粉丝列表功能1.service层2.controller层3.view层4.功能测试 实现关注列表、粉丝列表功能 1.service层 FollowerService类中添加findFollowees方法，findFollowers方法
package com.gerrard.community.service; import com.gerrard.community.entity.User; import com.gerrard.community.util.CommunityConstant; import com.gerrard.community.util.RedisKeyUtil; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.dao.DataAccessException; import org.springframework.data.redis.core.RedisOperations; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.core.SessionCallback; import org.springframework.stereotype.Service; import java.util.*; @Service public class FollowService implements CommunityConstant { @Autowired private RedisTemplate redisTemplate; @Autowired private UserService userService; public void follow(int userId, int entityType, int entityId) { redisTemplate.execute(new SessionCallback() { @Override public Object execute(RedisOperations operations) throws DataAccessException { String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType); String followerKey = RedisKeyUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/809c4e97e1efced8344b4f6bab307758/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22bd94a10c8ca028b328ba81e5880859/" rel="bookmark">
			基于MTuner软件进行qt的mingw编译程序的内存泄漏检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 软件下载
2 检测方法
3 本文使用的测试程序
1 软件下载 MTuner的release版本下载https://github-releases.githubusercontent.com/101243856/653e3780-f216-11ea-8baa-c25d772eaee7?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20210622%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20210622T090209Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=fee7579cf8749bf5733a0e5457ecadc27d02d78ceea5e0373e0960166a54d107&amp;X-Amz-SignedHeaders=host&amp;actor_id=29192658&amp;key_id=0&amp;repo_id=101243856&amp;response-content-disposition=attachment%3B%20filename%3Dmtuner64.zip&amp;response-content-type=application%2Foctet-stream
链接：https://pan.baidu.com/s/1imfUokNdTjoURqKcidEEZw 提取码：smws 该软件是开源的，仓库地址如下：
GitHub - milostosic/MTuner: MTuner is a C/C++ memory profiler and memory leak finder for Windows, PlayStation 4 and 3, Android and other platforms
2 检测方法 将可以双击运行的debug程序，拖入起始页如下位置即可。
按照《MinGW版Qt环境下如何检测内存泄漏_u014804795的博客-CSDN博客》的测试代码，测试出了下面的内存泄漏位置，其他label位置也可通过文件路径查看，文末有测试程序：
QLabel *label1 = new QLabel("label"); 3 本文使用的测试程序 如下：
testHeob.7z-CSDN下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b28842f9e63a0ab287a5401727f433b/" rel="bookmark">
			微机原理与技术接口随堂练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 前言随堂练习 🎬本文章是 【微机原理技术接口】 专栏的文章，主要是实验内容
🔗微机原理技术接口专栏 传送门
💻提示：本文的环境是emu8086仿真系统
前言 这篇为止，微机原理就结束啦，想要更深入了解这门课，推荐看一下慕课吴宁老师的课，我看了三遍，百看不厌！
《微型计算机原理与技术接口》第四版—吴宁，随堂练习个人汇总，题目源于课堂抽查，如有错误欢迎指出
随堂练习 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd412c84b5f2337607bd7244ff052c57/" rel="bookmark">
			方法重载与方法重写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法重载 目的：为了解决两个或多个功能相同的不同方法在命名时出现多个不同方法名的问题，重载把一组功能相同的方法命名为同一个方法名，这样就可以减轻开发者在方法的命名上的痛苦。
什么是方法重载
在同一个类中, 具有相同方法名的一组方法, 但是参数列表不一样的这一组方法称为方法重载
参数列表不一样：
①参数个数不一样
②对应位置的参数类型不一样
无关项：
①参数名
②返回值类型
方法重写 目的：子类实现父类中共有资源以外的特有资源，也就是对父类方法的拓展延伸
什么是方法重写
子类中的某个（多个）方法与父类中的某一个（多个）方法的返回值、方法名、参数列表相同，但是方法体不一样这就是方法重写。
public class Student {//创建父类Student类 private String name;//定义学生姓名内部属性 ​ public String getName() { return name; } ​ public void setName(String name) { this.name = name; } ​ public void study(){//创建父类study（）方法 System.out.println("Student类中学习方法,学生名字是"+name); } } public class UnStudent extends Student{//创建大学生类UnStudent子类继承与父类Student类 public void study(){//创建父类study（）方法 System.out.println("我是来自广西科技大学的一名学生，名字叫："+ getName()); } } public class TestStudent { public static void main(String[] args) { UnStudent unStudent = new UnStudent(); unStudent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd412c84b5f2337607bd7244ff052c57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/032f3fbf2a8b408455dc06a51f8785fc/" rel="bookmark">
			前端开发--CSS基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速生成css样式 采用简写的方式即可 w200 tab键 width：200px；lh200 tab键line-height：200px； ## web服务器 免费的远程服务，免费空间 http://free.3v.do/ ## css的书写顺序 * 布局定位属性：display/position/float/clear/visibility/overflow（dispaly第一个写） * 自身相关的属性：width/height/margin/padding/border/background * 文本属性：color/font/text-decoration/text-aglin/vertical-align/white-space/break-word * css3其他属性：content/coursor/border-radius/box-shadow/text-shadow/background-linear-gradient... ## css ### 标签属性，有些标签是自带属性的 &lt;标签名 属性名1='属性值' 属性名2='属性值'&gt;标签体&lt;/标签名&gt; * 标签的通用属性，即每个标签都会有的属性，通用属性是写在标签里的 id class style title * 注意，有些自带属性是不能写在css样式中的，比如a链接的href属性，img的url属性，通用属性等... * 有些标签会自带一些样式属性，不推荐使用，标签的样式要写在css样式中，这样才能实现结构与样式相分离 ### css作用：美化html，给网页布局 ​	1:选择标签 2:给标签设置样式 ### css引入方式 1：行内样式 标签添加style属性，属性值必须用双引号包围，只作用在当前标签 ```&lt;p style="coler:red;font-size:18px;"&gt;&lt;/p&gt;``` 2:内嵌样式（内部样式表） head标签内写style标签，作用于整个html页面 3:外链样式 （外部样式表）head标签内写link标签，推荐使用，结构与样式 将css样式编写在一个外部的css文件中，并通过link便签引入外部样式表 将样式表编写在css样式表中可以使用到浏览器的缓存机制，从而加快网页的加载速度，提高用户体验 在外部样式表中直接书写css样式即可 使用外链样式表的优点是：实现了结构于样式相分离，可作用于多个页面， 总结：行内样式：书写方便，权重高，不符合结构于样式相分离，只能控制一个标签，不推荐使用 ​	内嵌样式：部分结构与样式相分离，多用于练习时，控制一个页面 ​	外链样式：需要引入外部样式文件，实现了结构于样式相分离，可作用于多个页面，推荐使用 ### css语法格式 css的主要构成，由选择器以及一条或多条样式声明 ```css 选择器{ 属性：属性值； } 选择器是用来选择页面中指定的元素
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/032f3fbf2a8b408455dc06a51f8785fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bea5ff68e4041feaa6e8b6f1ed54969/" rel="bookmark">
			【测试】 FIO：ceph/磁盘IO测试工具 fio（iodepth深度）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
随看随用
NAS文件系统测试
块系统测试
FIO用法
FIO介绍
FIO 工具常用参数：
FIO结果说明
I/O 的重放('录'下实际工况的IO，用fio'重放')
fio工作参数可以写入配置文件
fio的iodepth参数说明
IO状态监控：
Iostat介绍
其他相关工具和内容
与FIO相似的工具
fio测试脚本
提取iops和bw
gunplot画图
IO优化思路和IO栈图
Fio 输出内容的解释
相关命令
附录
作者：bandaoyu本文随时更新，地址：https://blog.csdn.net/bandaoyu/article/details/113190057
随看随用 NAS文件系统测试 随机读 IOPS/吞吐-4K
fio -numjobs=1 -iodepth=128 -direct=1 -ioengine=libaio -sync=1 -rw=randread -bs=4K -size=1G -time_based -runtime=60 -name=Fio -directory=/mnt
随机写 IOPS/吞吐-4K fio -numjobs=1 -iodepth=128 -direct=1 -ioengine=libaio -sync=1 -rw=randwrite -bs=4K -size=1G -time_based -runtime=60 -name=Fio -directory=/mnt
NAS性能测试_使用指南_云主机 - 七牛开发者中心
混合读写测试
随机混合读写 IOPS/吞吐-4K
fio -numjobs=1 -iodepth=128 -direct=1 -ioengine=libaio -sync=1 -rw=randrw -bs=4K -size=1G -time_based -runtime=60 -name=Fio -directory=/mnt
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bea5ff68e4041feaa6e8b6f1ed54969/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9cc9693d61e18ddeb7c1dafddad0b91/" rel="bookmark">
			yocto 使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相当详细的文章就是转运一下，方便大家阅读，原版文章可以看原链接。
对于大家使用Yocto中的一些疑问，使用寥寥数语进行解答，让大家快速高效地使用Yocto。
(1): Yocto 编译后文件放在了哪里 输出文件位置 编译完成后内核以及rootfs，内核，uboot以及dtb会放在相对于build目录的tmp/deploy/images/MACHINE/下面,这里MACHINE需要可能为空（对于老版本的poky/yocto），也可能是你的板子名字，例如sabresd。
对于toolchain，那么放在mp/deploy/sdk/MACHINE/下。
图片示例：
编译完成后内核以及rootfs以及dtb会放在相对于build目录的tmp/deploy/images/imx6qsabresd/下面
各个文件都有一个软连接来指向最新编译产生的文件，因此如果需要看到最新的文件，可以直接使用软链接即可：
(2): Yocto Linux内核编译目录在哪？ 内核放在了哪里？ 这个是放在了如下位置，我们可以用下面命令来确定：
bitbake -e linux-imx | grep ^S=
图示：
(3): Yocto 如何重新编译Linux内核与dtb，并放到deploy目录？ 编译内核，并生成uImage+dtb，编译的命令如下：
bitbake linux-imx -C compile
注意这里的-C的C是大写，和小写的c是有区别的。
注意这里的linux-imx是针对imx的内核，你的内核名字可能不一样，关于如何确定一个包的名字，请看：Yocto tips (4): Yocto 如何确定(找到)
(4): Yocto 如何确定(找到)一个包的名字 使用下面命令来却确定：
bitbake -s | grep XXX
其中XXX为包的关键字，例如linux或者uboot，这样就可以看到所有带有关键字的包了，如下图，就是为了找到内核：
(5): Yocto如何更改source code的下载与git clone地址 现象 Yocto中在fetch一些软件包的时候经常出现一天也下载不下来，这种情况极大浪费了我们的时间。
例如，下面有三个Package下载了一天也没有完成：
解决方法 确定下载的地址，手动下载 先确定软件包的下载地址，例如对于opencv与opencv-samples软件包：
可以看到他们的git地址都是一样的，因此，我们可以手动来git clone：
可以看到我们只使用了几十分钟而已。clone下来以后，我们就可以让软件包使用我们本地的这个repo了，而不需要忙忙的去远程repo去clone。
让package克隆时使用本地的git
找到软件包对应的bb文件 我们可以使用find命令来查找
更改bb文件 注意里面添加了一个protocol指定。
再一次获取 bitbake opencv -c fetch
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9cc9693d61e18ddeb7c1dafddad0b91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e22dde7f80e1056a674ce02a0294f86/" rel="bookmark">
			java多线程Future.cancel(true)取消线程，线程还是会执行catch与finally里面的代码，只要资源回收的代码没有乱写，不必担心资源回收问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.代码展示 public static void main(String[] args) { //定义线程池 ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 30, 30, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;()); //信号量定义 CountDownLatch countDownLatch = new CountDownLatch(2); //提交异步任务1 Future&lt;Integer&gt; future1 = threadPoolExecutor.submit(() -&gt; { try { System.out.println("任务1获取连接"); Thread.sleep(1000); System.out.println("任务1开始处理查询结果"); return 1 ; } catch (Exception e){ System.out.println("任务1catch="+e.getMessage()); return null ; }finally { //信号量递减 countDownLatch.countDown(); System.out.println("任务1归还连接"); } }); //提交异步任务2 Future&lt;Integer&gt; future2 = threadPoolExecutor.submit(() -&gt; { try { System.out.println("任务2获取连接"); Thread.sleep(20000); System.out.println("任务2开始处理查询结果"); return 2 ; } catch (Exception e){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e22dde7f80e1056a674ce02a0294f86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d44748ecf32aaf3dea35ca2fe2856fe4/" rel="bookmark">
			VNC使用中Screen is locked until the remote user unlock this window
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：有一段时间，使用UltraWNC进行远程连接，输入密码后，出现的远程界面是黑屏，然后显示红色字体报警信息
“UltraWNC running as application doesn’t have permission to acces UAC protected windows. This screen is locked until the remote user unlock this window”
如上图所示，试了很多的方法，也
1.调节windows10 的UAC设置，-----------------不行
2.重新安装UltraWNC ------------------------------可以
需要注意的是，在卸载UltraWNC 的时候，需要把所有的遗留项目都删除干净，然后才可以进行。
---------------------------------------------20220722
登录远程电脑后，将VNC，右键–&gt;&gt;run as server就好了，
解释：以服务的运行，而不是以应用运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c249dddc872cd78fdb49e6baf947a9c8/" rel="bookmark">
			世界坐标系、相机坐标系和图像坐标系的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相机标定笔记 坐标系转换四个不同类型的坐标系1. 世界坐标系2. 相机坐标系3. 图像物理坐标系4. 图像像素坐标系 坐标转换世界坐标 → 相机坐标（刚性变换）绕 X X X旋转 θ \theta θ度绕 Y Y Y轴旋转 θ \theta θ度绕 Z Z Z轴旋转 θ \theta θ度 相机坐标 → 图像坐标系（中心投影）图像坐标系 → 像素坐标系（离散化） 坐标系转换 之前只是停留在会用的阶段，一直没去读懂计算的原理，今天通读了大佬的文章，写的言简意赅，感谢感谢~~特此记录一下，仅用作个人笔记
贴链接，十分感谢~
https://blog.csdn.net/weixin_44278406/article/details/112986651
https://blog.csdn.net/guyuealian/article/details/104184551
四个不同类型的坐标系 将三维物体转换成照片上的二维坐标，由四个坐标系进行转换。
1. 世界坐标系 世界坐标系是一个特殊坐标系，它建立了描述其他坐标系需要的参考框架。能够用世界坐标系描述其他坐标系的位置，而不能用更大的、外部的坐标系描述世界坐标系。从非技术意义上讲，世界坐标系建立的是我们所关心的最大坐标系，而不必真的是整个世界。
用 ( X w ， Y w ， Z w ) (X_w，Y_w，Z_w) (Xw​，Yw​，Zw​)来表示，世界坐标系可通过旋转和平移得到相机坐标系。
2. 相机坐标系 以相机透镜的几何中心（光心）为原点，坐标系满足右手法则，用 ( X c ， Y c ， Z c ) (X_c，Y_c，Z_c) (Xc​，Yc​，Zc​)来表示；相机光轴为坐标系的Z轴，X轴水平，Y轴竖直。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c249dddc872cd78fdb49e6baf947a9c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b31b458d9ca05560440f34b4d29f39b2/" rel="bookmark">
			服务注册到nacos集群失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象 nacos单机部署时，服务orderservice启动不会出现任何问题，但是集群部署时，服务orderservice启动提示服务注册失败，异常信息如下：
07-22 10:06:35:305 ERROR 7288 --- [ main] c.a.c.n.registry.NacosServiceRegistry : nacos registry, orderservice register failed...NacosRegistration{nacosDiscoveryProperties=NacosDiscoveryProperties{serverAddr='192.168.11.xxx:80', endpoint='', namespace='', watchDelay=30000, logName='', service='orderservice', weight=1.0, clusterName='HZ', group='DEFAULT_GROUP', namingLoadCacheAtStart='false', metadata={preserved.register.source=SPRING_CLOUD}, registerEnabled=true, ip='192.168.10.xxx', networkInterface='', port=8080, secure=false, accessKey='', secretKey='', heartBeatInterval=null, heartBeatTimeout=null, ipDeleteTimeout=null, failFast=true}}, com.alibaba.nacos.api.exception.NacosException: failed to req API:/nacos/v1/ns/instance after all servers([192.168.11.xxx:80]) tried: ErrCode:400, ErrMsg:&lt;html&gt;&lt;body&gt;&lt;h1&gt;Whitelabel Error Page&lt;/h1&gt;&lt;p&gt;This application has no explicit mapping for /error, so you are seeing this as a fallback.&lt;/p&gt;&lt;div id='created'&gt;Fri Jul 22 10:06:35 CST 2022&lt;/div&gt;&lt;div&gt;There was an unexpected error (type=Bad Request, status=400).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b31b458d9ca05560440f34b4d29f39b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16477670f0e3cb0a93009bc573290b71/" rel="bookmark">
			Numpy.where()/np.where() 函数的使用----修改数组中符合条件的元素值/查找数组中符合要求的元素的位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		numpy.where() 用法 1. np.where(condition, x, y)：用于修改满足条件的元素值 用法解释：满足condition将数组元素修改为x，否则修改为y，最后生成一个新的数组。
注意：np.where不会修改原数组的数值，而会生成一个新的数组
1.1 一维数组 # 生成-5到4的一维数组 arr1 = np.arange(-5,5) print('原数组 :',arr1) arr2 = np.where(arr1&gt;0,1,-1) print('查看原数组是否修改:',arr1) print('修改后的数组 :',arr2) 输出结果：
原数组 : [-5 -4 -3 -2 -1 0 1 2 3 4] 查看原数组是否修改: [-5 -4 -3 -2 -1 0 1 2 3 4] 修改后的数组 : [-1 -1 -1 -1 -1 -1 1 1 1 1] 如果只对一个条件进行修改：&gt;0 保持不变，小于0变为-1
将where语句修改为如下即可：
arr2 = np.where(arr1&gt;0,arr1,-1) 即，不修改的位置为arr原数组的值
1.2 二维数组 arr1 = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16477670f0e3cb0a93009bc573290b71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b9b30a001a503e1816f1a98ea32fb4/" rel="bookmark">
			JavaScript实现调用摄像头完成拍照取图 重命名并下载或上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境条件 具有内置摄像头 或 外设摄像头Vue + Element + axios（环境不同可自行修改，本文主要为逻辑，除展示的上传控件其他与js基本无异） 全文 &lt;template&gt; &lt;div id="all"&gt; &lt;el-upload :headers="{token:userinfo.token}" class="upload-demo" list-type="picture-card" :multiple="false" :limit="5" :action="uploadimgUrl" :on-success="uploadPhoto" :on-remove="handleRemovePhoto" :file-list="fileListimg" multiple&gt; &lt;i class="el-icon-plus"&gt;&lt;/i&gt; &lt;/el-upload&gt; &lt;div class="gp"&gt; &lt;video ref="gpp2"&gt;&lt;/video&gt; &lt;/div&gt; &lt;div class="footer" style="display: flex;justify-content: space-between;margin-top: 10px"&gt; &lt;el-button type="primary" @click="takeGpp"&gt;抓 拍 上 传&lt;/el-button&gt; &lt;/div&gt; &lt;canvas ref="canvas" v-show="false" height="960" width="1600"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import request from "@/utils/request"; export default { name: "demo", data(){ let url = process.env.VUE_APP_BASE_API; let baseUrl = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58b9b30a001a503e1816f1a98ea32fb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ab3ac82e85a47e3482fb51168e2e61f/" rel="bookmark">
			ubuntu22.04 LTS 从源码安装ROS2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考官方安装指导:
https://docs.ros.org/en/humble/Installation/Alternatives/Ubuntu-Development-Setup.html
ubuntu22.04对应的ROS2版本为ROS2 humble
下面是参考官方教程的安装过程.
系统设置 设置语言环境 语言环境须支持UTF-8, 最好是英文环境.
首先运行
locale 可查看是否支持UTF-8, 如需要, 可使用下面的命令安装UTF-8环境.
sudo apt update &amp;&amp; sudo apt install locales sudo locale-gen en_US en_US.UTF-8 sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 export LANG=en_US.UTF-8 再次确认
locale 添加ROS 2 apt 软件库 首先确保已添加ubuntu universe
apt-cache policy | grep universe 查看是否包括这一行:
500 http://us.archive.ubuntu.com/ubuntu jammy/universe amd64 Packages release v=22.04,o=Ubuntu,a=jammy,n=jammy,l=Ubuntu,c=universe,b=amd64 如果没有上面这行,则添加universe软件源:
sudo apt install software-properties-common sudo add-apt-repository universe 下面添加ROS 2源的GPG密钥
sudo apt update &amp;&amp; sudo apt install curl gnupg lsb-release sudo curl -sSL https://raw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ab3ac82e85a47e3482fb51168e2e61f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e80d1994813bf0bdf5902d9025adeff0/" rel="bookmark">
			2021-03-08 Android Studio 生成JAR包和调用JAR包方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio 生成JAR包和调用JAR包方法 一、生成JAR包步骤。
1、新建Module，New-&gt;New Module。
2、选择Android Library。
3、module name 为mylibrary。
4、生成mylibrary文件夹
5、新建mylibrary\src\main\java\com\example\mylibrary\Jarlibrary.java
package com.example.mylibrary; import android.os.Bundle; import android.widget.ImageView; import androidx.annotation.Nullable; import androidx.appcompat.app.AppCompatActivity; public class Jarlibrary { static int val; public static void setvalue(int v) { val=v; } public static int getvalue() { return val; } } 6、mylibrary\build.gradle 添加
//Copy类型 task makeJar(type: Copy) { //删除存在的 delete 'build/libs/jarsdk.jar' //设置拷贝的文件 // from('build/intermediates/bundles/release/') from('build/intermediates/aar_main_jar/release/') //打进jar包后的文件目录 into('build/libs/') //将classes.jar放入build/libs/目录下 //include ,exclude参数来设置过滤 //（我们只关心classes.jar这个文件） include('classes.jar') //重命名 rename ('classes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e80d1994813bf0bdf5902d9025adeff0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f072772316a40170f8eae61cbeaf8e2/" rel="bookmark">
			数据结构——循环顺序队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.介绍 队列其实在生活中有很多例子，比如说看电影买票需要排队，上公交车需要排队刷卡。
这种队列就是前头出，后头进的结构，即先进先出（FIFO）。
因此，我们只能对队首和队尾进行操作，如果你插队操作的话，别人会说你不守公德。
实际中，我们分别用head和tail两个指针分别管理队首和队尾。
普通顺序队列容易假溢出，即只要当前面的元素出队列，head指针就会向后指，就再也不会回头。
这样，前面的一段空间实际上并没有用上，因此普通顺序队列实际意义并不大。
而且如果，我们每次将元素出队列，将后面的元素向前面复制，那么维持类似顺序表的结构时间开销是很大的。
因此，我们一般采用循环列表，循环列表可以想象成一个圆，这样两个指针就可以在一段连续的存储空间来回指向。
类似于这样：
现在来看具体操作如何实现。
2.操作 下面都是基于动态存储的顺序栈，其实链式队列是用不着循环的。
（1）创建
head指针指向队首元素，而tail指向队尾元素后一个位置。因此，初始时我们可以将head和tail初始为0。
head只有在和tail相等时，才和它的意义不同，因为我们要知道此时队列使用长度，只需要用（tail-head+maxSize）%maxSize就可求得。
至于这个公式，需要数论的知识，但可以拿家里的钟用几个数字实验一下。
也可以拿下面两个图试一下。
因此，head和tail相等，这时的长度是为0的。
template&lt;typename T&gt; Queue&lt;T&gt;::Queue() { head = tail = 0; data = new T[10]; maxSize = 10; } （2）判空
template&lt;typename T&gt; bool Queue&lt;T&gt;::isEmpty() { if (head == tail) return true; return false; } （3）判满
因为，我们的tail指向队尾之后的元素，而一旦这个元素就是head的话，判空函数就会一直为true，不能出队列，因此我们规定tail所指元素不能存放元素。
也就是maxSize个存储空间，只能存放maxSize-1个元素。
template&lt;typename T&gt; bool Queue&lt;T&gt;::isFull() { if ((tail + 1) % maxSize == head) return true; return false; } 其实，也有其他的判断方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f072772316a40170f8eae61cbeaf8e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c44cf042cc0c2f1c65389776dc5958c2/" rel="bookmark">
			在js脚本中直接引入本地json文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到一个需要引入本地json文件的问题，同时又不能使用jQuery包
首先需要在本地创建json文件
在json中定义一个对象保存数据
var jsonData2 = { "businessCode": "success", "count": 4, "currentTime": 1658386745555, "description": "", "resultSet": [ { "id": 1488, "code": "media_80522792-f192-4f11-b824-3cd9436ac17f", "name": "新大头儿子小头爸爸 第二季", "genreCode": "genre_a6325b19-85d2-48bf-a793-1501c48c8ca9", "currentEpisodeNumber": 102, "type": "103", "template": null, "img1": null, "img2": "./movie1.png", "img3": null, "mark": null, "seq": 1617950689, "tag": null, "cp": null, "playTimes": null, "score": null, "fee": 1, "desc": "一个中国典型的三口之家，八零后的父母——小头爸爸和围裙妈妈，一个调皮可爱的的大头儿子。他们生活在现代化的城市中，过着平凡并充满乐趣的生活。 ", "param2": "20000002000000000000000006699471", "param6": 12, "param7": 28, "param8": "0013", "param9": 6, "param10": 102 } ] } 有些json文件格式可能会提示报错，类似这种
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c44cf042cc0c2f1c65389776dc5958c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d4fb0b01e4bee25a56b892f80a824fe/" rel="bookmark">
			如何强制删除需要卸载密码的软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00 背景 现在的互联网安全监管趋严，存在不少案例是某某软件需要卸载密码，但是电脑使用者并不知道这个密码，但他有需要需要卸载电脑的某某软件，但该软件需要密码才能进行卸载。例如离职员工安装了前东家的安全软件，但离职时未卸载。
此外，使用普通的软件管理工具无法卸载，如360的软件管家、腾讯的软件管家、软媒魔方的软件管理，电脑本身的程序卸载等。
0x01 删除思路 思路1：强制结束进程 --&gt; 删除启动项和文件 --&gt; 粉碎软件安装路径文件夹。
思路2： 粉碎软件安装路径文件夹（主文件夹无法删除或者删除不干净的，可以删除二级或三级的文件夹或者文件） --&gt; 重启 （进程结束）--&gt; 删除启动项和文件 --&gt; 再次粉碎软件安装路径的剩余文件夹。
思路3：由以上思路1,2进行自由组合，可以删除顽固的软件。
安全工具：使用PowerTool、PCHunter、火绒剑等安全分析工具。
文件粉碎: 软媒魔方的软媒文件大师、360粉碎机等文件粉碎软件。
以上工具可以百度搜索，或者私信博主本人索取
0x02 实践案例1 在程序管理或者开始菜单里面找到该软件，进行卸载，发现出现需要卸载密码。
此时，以下案例参考以下思路1 ：
1. 强制结束进程 找到该软件相关的进程，可以根据映像名称、进程路径、软件签名等信息找到与之关联的所有进程，然后选择结束进程（或者是，强制结束进程，结束进程并删除文件等）。
重要提示：如果使用其中一个工具无法结束进程，可以考虑使用另外一种工具。
2.删除启动项和文件 找到该软件相关的启动项，可以根据映像名称、进程路径、软件签名等信息找到与之关联的所有启动项，然后选择，删除启动项（或者是，删除启动项和启动文件）
重要提示：如果使用其中一个工具无法删除启动项，可以考虑使用另外一种工具。
3. 粉碎软件安装路径文件夹 定位到该软件的安装目录和其他目录，进行文件粉碎，可以选择整个目录或者是二级目录。
如果反复无法删除，可以看看是不是进程再次启动了，需要及时结束进程，在进程结束未恢复的时间点把文件进行粉碎。
重要提示：如果使用其中一个工具无法粉碎文件，可以考虑使用另外一种工具。
0x03 实践案例 2 此时，以下案例参考以下思路2 ：
当思路1：无法结束该进程或者尝试多个工具都无法结束该进程，这时候，我们需要按照思路进行。
找到该软件相关的进程，根据进程找到相关的安装文件夹或者配置文件夹，定位到该软件的安装目录和其他目录，进行文件粉碎，可以选择整个文件夹。或者是二级文件夹。或者三级文件夹。
1. 粉碎软件安装路径文件夹 删除完成后，重启电脑
2.重启 （进程结束） 重新开机后，发现该软件在桌面的快捷方式已经变白了，无法直接打开了。
3.删除启动项和文件 找到该软件相关的启动项，可以根据映像名称、进程路径、软件签名等信息找到与之关联的所有启动项，然后选择，删除启动项（或者是，删除启动项和启动文件）
重要提示：如果使用其中一个工具无法删除启动项，可以考虑使用另外一种工具。
这个类似实践案例1的
4. 再次粉碎软件安装路径的剩余文件夹。 这个类似步骤1。
0x04 总结思考 1、通过这种方式卸载删除了软件及其桌面的图标。如需重新安装该软件，可能需要提前进行注册表垃圾清理和删除启动信息。
2、如果以上方式存在用户权限问题，请在电脑开机时候使用管理员登录或者进入windows的修复模式等
欢迎分享更好的思路！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06b5e0437d293a15987ccdd128bff3f9/" rel="bookmark">
			（仿牛客社区项目）Java开发笔记4.2：实现点赞功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 实现点赞功能1.util包2.service层3.controller层4.view层5.功能测试 实现点赞功能 1.util包 在util包中添加RedisKeyUtil类。
package com.gerrard.community.util; public class RedisKeyUtil { private static final String SPLIT = ":"; private static final String PREFIX_ENTITY_LIKE = "like:entity"; // 某个实体的赞 // like:entity:entityType:entityId -&gt; set(userId) public static String getEntityLikeKey(int entityType, int entityId) { return PREFIX_ENTITY_LIKE + SPLIT + entityType + SPLIT + entityId; } } 2.service层 添加LikeService类。
package com.gerrard.community.service; import com.gerrard.community.util.RedisKeyUtil; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.stereotype.Service; @Service public class LikeService { @Autowired private RedisTemplate redisTemplate; // 点赞 // (from-&gt;to userId给entityUserId点赞) public void like(int userId, int entityType, int entityId) { String entityLikeKey = RedisKeyUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06b5e0437d293a15987ccdd128bff3f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad53680bdd766e62b1fa5d5c96f4d699/" rel="bookmark">
			H5, 遇到的 ios 兼容性问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		H5, 遇到的 ios 兼容性问题 1.ios 中日期格式 new Date('2019-10-11') 无效; 解决: new Date('2019-10-11'.replace(/\-/g, '/')); 2.ios 中日期格式 new Date(' 2019-07-24 11:35:00.0') 无效; 解决: new Date(' 2019-07-24 11:35:00.0'.replace(/\-/g, '/').replace('.0', '')); 3.ios 中 input[type='date'] placeholder 默认显示空白问题; 解决( 用伪类添加一个placeholder属性, onfoucs时removeAttribute('placeholder'), onblur的时候setAttribute('placeholder', '') ): input[type='date']:before { content: attr(placeholder); color: rgba(0,0,0,0.7); } input:-webkit-input-placeholder{ color: #999; } 4.ios 中 overflow: scroll 滚动效果卡顿; 解决: -webkit-overflow-scroll: touch; -webkit-overflow-scrolling: touch; /* 当手指从触摸屏上移开，会保持一段时间的滚动 */ -webkit-overflow-scrolling: auto; /* 当手指从触摸屏上移开，滚动会立即停止 */ 5.ios 中 input disabled 时的color 很浅; 原因: iPhone Safari/webview input disabled 会有默认样式； 解决: input:disabled { color: #999; opacity: 1; -webkit-text-fill-color: #999; } 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad53680bdd766e62b1fa5d5c96f4d699/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e35553f5fb9943749688159ece0a80a/" rel="bookmark">
			Monocle3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、monocle3介绍 monocle3可以执行的3个主要的功能
对细胞进行聚类、分类和计数。Monocle 3 可识别新的（可能是罕见的）亚型细胞
构建单细胞轨迹。通过拟时序分析帮助大家解析生物体发育、疾病等过程中细胞发生的变化。这是最主要的功能。
差异表达分析。Monocle 3 包括一个复杂但易于使用的差分表达系统，可以表征新的细胞类型和状态始于与其他更好理解的细胞进行比较。
主要流程
1.读取数据，创建cell_data_set对象。
2.数据预处理：标准化，去除批次效应
3.降维
4.聚类
5.进行差异基因表达分析
6.拟时序分析
二、关于不同数据的读取办法 （一）Bioconductor的ExpressionSet对象： monocle3读取的数据要包含3个部分：
expression_matrix：表达式值的数字矩阵，其中行是gene，列是cellcell_metadata:数据框，其中行是cell，列是细胞属性（如细胞类型、培养条件、获取日期等）gene_metadata :数据框，其中行是特征（例如基因），列是基因属性，例如生物型，GC含量等。 输入前应该确保几个“等式”
expression_matrix 列数= cell_metadata 行数 并且两者要相匹配 expression_matrix 行数= gene_metadata 列数 并且两者要相匹配 gene_metadata的其中一列应为“gene_short_name”,表示每个基因的基因符号或简要名称 创建对象示例 # Load the data expression_matrix &lt;- readRDS(url("https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/cao_l2_expression.rds")) cell_metadata &lt;- readRDS(url("https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/cao_l2_colData.rds")) gene_annotation &lt;- readRDS(url("https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/cao_l2_rowData.rds")) # Make the CDS object cds &lt;- new_cell_data_set(expression_matrix, cell_metadata = cell_metadata, gene_metadata = gene_annotation) （二）从 10X 输出生成cell_data_set 要找到正确的文件，必须提供包含未修改的Cell Ranger“outs”文件夹的文件夹的路径。文件结构应如下所示：10x_data/outs/filtered_feature_bc_matrix/，其中filtered_feature_bc_matrix包含 files features.tsv.gz、barcodes.tsv.gz 和 matrix.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e35553f5fb9943749688159ece0a80a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa9dece43029afd8dfb90a4a8e290552/" rel="bookmark">
			Spring 框架(声明式)事务学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 ：声明式事务部分：参考网上课程，自己写的总结，如有侵权，联系删除。
目录
Spring事务_事务简介
Spring事务_Spring事务管理方案
Spring事务_Spring事务管理器
Spring事务_事务控制的API
PlatformTransactionManager接口
Spring事务_事务的相关配置
Spring事务_事务的传播行为 Spring事务_事务的隔离级别
Spring事务_注解配置声明式事务
Spring事务_事务简介 事务：不可分割的原子操作。即一系列的操作要么同时成功，要么 同时失败。
开发过程中，事务管理一般在service层，service层中可能会操作多次数据库，这些操作是不可分割的。否则当程序报错时，可能会造成数据异常。
如：张三给李四转账时，需要两次操作数据库：张三存款减少、李 四存款增加。如果这两次数据库操作间出现异常，则会造成数据错误。
准备数据库 CREATE DATABASE `student` ; USE `spring`; DROP TABLE IF EXISTS `account`; CREATE TABLE `account` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) DEFAULT NULL, `balance` double DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8; insert into `account`(`id`,`username`,`balance`) values (1,'张三',1000),(2,'李四',1000); 创建maven项目，引入依赖 &lt;dependencies&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动包--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa9dece43029afd8dfb90a4a8e290552/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77cb5592dadeb95303b729f1d2046223/" rel="bookmark">
			lotus 导出区块高度 最小快照
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lotus 导出最小快照 最小快照2022-05-012022-07-22 导入快照同步链参考 最小快照 screen -S chia lotus chain export --recent-stateroots=901 --skip-old-msgs snapshot.car 日志lotus 区块高度导出 3个小时 # lotus --version lotus version 1.14.1+mainnet+git.d2dca7b21 # cat daemon.log | grep export 2022-03-26T03:03:10.491Z	INFO	chainstore	store/snapshot.go:155	export started 2022-03-26T05:16:22.689Z	INFO	chainstore	store/snapshot.go:98	export	{"height": "1664640"} 2022-03-26T05:52:14.048Z	INFO	chainstore	store/snapshot.go:98	export	{"height": "0"} 2022-03-26T05:52:14.353Z	INFO	chainstore	store/snapshot.go:166	export finished	{"duration": 10143.861824855} 2022-05-01 导出时间 5h61G May 1 15:21 snapshot.car # cat daemon.log | grep export 2022-05-01T10:24:36.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77cb5592dadeb95303b729f1d2046223/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12021ccd34efb100dce2df39008561c3/" rel="bookmark">
			Android Bluetooth OPP的理解与使用之六
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题点14：如何查看已收到的OPP 文件；
在Android Bluetooth 菜单中，可以看到“Received files”标签；
点击后如图所示：
通过log确认其执行的是BluetoothOppTransferHistory；
确认其是通过广播“com.android.bluetooth.action.TransferHistory”形式拉起来；
对应的是ACTION_OPEN_FILES，在类BluetoothFilesPreferenceController中,其属于packages\apps\Settings\src\com\android\settings\bluetooth，不在Bluetooth.apk中；
问题点15：BluetoothShare.CONTENT_URI中具体存储的内容和
BluetoothOppReceiveFileInfo的generateFileInfo得到的全路径文档的关系是什么；
BluetoothOppObexServerSession的mFileInfo关联了两者；
其在BluetoothOppObexServerSession 的“addShare”中被保存；
而在BluetoothOppObexServerSession 的“onPut”中进行操作写入动作；
Note：实际log显示方法onPut可以长时间运行，这段时间可以通过方法receiveFile完成文件从BluetoothShare.CONTENT_URI输出到全路径名称上；
问题点16: BluetoothOppService中的方法 start在哪被执行的；
---BluetoothOppService 继承于ProfileService，其方法start 和stop是重写了
ProfileService中的实现，通过BluetoothOppService的其方法start 和stop被调用体现在ProfileService的方法doStart和doStop中；
而ProfileService的方法doStart和doStop则被onStartCommand调用；
问题点17：Android Bluetooth中Obex response command定义位置；
在framework层的obex文件夹ResponseCodes.java中；
问题点18：Android Bluetooth OBex定义的最大MAX packet size是；
ObexHelper.MAX_PACKET_SIZE_INT
问题点19：Android Bluetooth OPP的拒绝文件接收请求；
请留意Log “mimeType is null or in unacceptable list, reject the transfer”，在方法onPut中；
Attention：Android Bluetooth OPP 并不是所有文件类型都会接收(存在限制)， 当接收到的文件类型不符时，将拒绝接收；允许接收的具体文件类型定义在
ACCEPTABLE_SHARE_INBOUND_TYPES；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55d1dfc399114868908eea9c9a895723/" rel="bookmark">
			Android Bluetooth OPP的理解与使用之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前OPP Source Code基于Android O(8)；
Andorid 中Bluetooth OPP的实现与其HFP、A2DP等Profile不一样，其没有Framework层实现，即
frameworks\base\core\java\android\bluetooth中并没有OPP的对外接口；
同时在Server 层中，packages\apps\Bluetooth\src\com\android\bluetooth\opp的命名也和HFP等Profile不一样：其Java file命名使用了Bluetoothxxx字样，这通常只出现在Framework等对外的接口中；
本文继续以问答形式展开：
问题点1: Android 手机的OPP 如何使用？
OPP的使用并不是先配对连接再操作，而是在Android手机中先选择需发送的文件，然后选择蓝牙发送，其会弹出已配对设备，选择后将直接发送，发送完成后将自动断开OPP连接；
以下截图是OPP手机操作文件发送：
问题点2：Android Bluetooth OPP Server 层相关OPP files的作用；
在packages\apps\Bluetooth\src\com\android\bluetooth\opp中相关OPP files比别的profile多很多，理清基本file作用，有助于对OPP的理解；
BluetoothOppBatch：This class stores information about a batch of OPP shares that should be transferred in one session;用于保存一个或一批OPP 发送或接收对象信息，其作为OPP的操作单元去理解；
BluetoothOppBtEnableActivity: 用于BluetoothOppLauncherActivity，若当前BT 没有打开时，BluetoothOppLauncherActivity将执行当前Activity弹出提示菜单用于User 点击确认(将执行mOppManager.enableBluetooth();)或取消打开BT(此时不做任何处理直接关闭当前dialog)；
BluetoothOppBtEnablingActivity: 当前菜单将在BluetoothOppBtEnableActivity点击确认后弹出，其内部设置20S超时Message BT_ENABLING_TIMEOUT用于等待BT on成功或失败； BluetoothOppBtErrorActivity: 这是一个错误提示菜单，用于基于实际情形进行错误信息提示；
BluetoothOppFileProvider：继承于FileProvider(但FileProvider本身是ContentProvider的子类)，用于操作已经接收到的文件(注意：这里并不是操作接收的过程，而是对已经接收到的文件进行操作)；
BluetoothOppHandoverReceiver: 用于接收特定4个Message
"android.btopp.intent.action.WHITELIST_DEVICE",
"android.btopp.intent.action.STOP_HANDOVER_TRANSFER",
"android.nfc.handover.intent.action.HANDOVER_SEND",
"android.nfc.handover.intent.action.HANDOVER_SEND_MULTIPLE"
其在Androidmanifest.xml中静态注册；
BluetoothOppIncomingFileConfirmActivity: 同于提示User，OPP 收到新的文件；
Note：注意其与方法updateIncomingFileConfirmNotification的区别及关联；
Android O实测：当收到新文件，在系统通知(updateIncomingFileConfirmNotification中发出的系统通知)中点击ACCEPT时，Log显示收到了“Constants.ACTION_ACCEPT” 但并没有显示收到“Receiver ACTION_INCOMING_FILE_CONFIRM”，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55d1dfc399114868908eea9c9a895723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c4f8e4a7abd3ca0e24526d80b1c86a3/" rel="bookmark">
			什么是系统？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、什么是系统？
2、通信系统
（1）模拟通信系统
（2）数字通信系统
3、控制系统
4、计算机系统
1、什么是系统？ 系统，是由若干个相互作用和相互依赖的事物组合而成的具有特定功能的整体。一般来说，系统涉及的范围十分广泛，包括各种物理系统和非物理系统、人工系统以及自然系统。比如通信系统、电力系统、机械系统可以称为物理系统；政治结构、经济组织、生产管理等则属于非物理系统；计算机网、交通运输网以及交响乐队等属于人工系统；原子核、太阳系、动物神经网络则是自然系统。
我们知道，电子信息工程主要研究主要研究信息的获取与处理，电子设备与信息系统的设计、开发、应用和集成。由于本文章是属于电子信息知识专栏的，所以着重介绍信息科学技术领域中涉及的一些系统，比如通信系统、控制系统以及计算机系统，这些系统常用来进行信号的传输、交换以及处理，多个多种系统系统共同组成一个综合性的复杂整体，比如航天系统。
2、通信系统 通信系统：用以完成信息的传输的系统的总称，一般由信源（发射端）、信宿（接收端）以及信道（传输通道）组成，如下图（来源于百度百科）：
（1）模拟通信系统 传输模拟消息的通信系统被称为模拟通信系统。其核心为调制与解调单元。一般的模拟系统的结构如下：
调制：在时域实现，在频域表现为频谱的搬移
解调：调制的逆过程
（2）数字通信系统 传输数字信号的系统被称为数字通信系统。一个较为完善的现代数字通信系统如下图所示，其中的白色实线框为必不可少的部分，但灰色虚线框中的部分是可以选择的。
比起模拟通信系统，数字通信系统可以有效地避免被噪声干扰，更有利于长距离传输，而且成本也更低，易于实现。
3、控制系统 控制系统：由控制主体、控制客体和控制媒体组成的具有自身目标和功能的管理系统（来源于百度百科）。通过采用的信号技术的不同可以分为数字控制系统和模拟控制系统。
4、计算机系统 计算机系统：计算机系统由硬件（子）系统和软件（子）系统组成。前者是借助电、磁、光、机械等原理构成的各种物理部件的有机组合，是系统赖以工作的实体。后者是各种程序和文件，用于指挥全系统按指定的要求进行工作。计算机系统也较为复杂，任何一个子系统以及子系统的组成都可以进行专门的学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a98939e3679113e6a2f594322a187b16/" rel="bookmark">
			Spring框架AOP学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 ：AOP部分：参考网上课程，自己写的总结，如有侵权，联系删除。
目录
SpringAOP_AOP简介
SpringAOP_AOP相关术语 SpringAOP_AOP入门
SpringAOP_通知类型
SpringAOP_切点表达式
SpringAOP_多切面配置
SpringAOP_注解配置AOP
SpringAOP_原生Spring实现AOP SpringAOP_SchemaBased实现AOP
SpringAOP_AOP简介 AOP的全称是Aspect Oriented Programming，即面向切面编程。 是实现功能统一维护的一种技术，它将业务逻辑的各个部分进行隔 离，使开发人员在编写业务逻辑时可以专心于核心业务，从而提高 了开发效率。
作用：在不修改源码的基础上，对已有方法进行增强。实现原理：动态代理技术。优势：减少重复代码、提高开发效率、维护方便应用场景：事务处理、日志管理、权限控制、异常处理等方面。 SpringAOP_AOP相关术语 名称说明Joinpoint（连接点）指能被拦截到的点，在Spring中只有方法能被拦截。（路上的车好多）Pointcut（切点）指要对哪些连接点进行拦截，即被增强的方法。 （拦住一个车）Advice（通知）指拦截后要做的事情，即切点被拦截后执行的方法。Aspect（切面）切点+通知称为切面Target（目标）被代理的对象Proxy（代理）代理对象Weaving（织入）生成代理对象的过程 SpringAOP_AOP入门 AspectJ是一个基于Java语言的AOP框架，在Spring框架中建议使用 AspectJ实现AOP。
接下来我们写一个AOP入门案例：dao层的每个方法结束后都可以打印一条日志：
引入依赖
&lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- AspectJ --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 编写连接点（就是好多方法，可以切的都是拦截点）
@Repository public class UserDao { public void add(){ System.out.println("用户新增"); } public void delete(){ System.out.println("用户删除"); } public void update(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a98939e3679113e6a2f594322a187b16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60b5496639fb91f172d21df12e370f2b/" rel="bookmark">
			（十一）51单片机——用AT24C02实现存储秒表数据（附成果展示）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
存储器
RAM
ROM
存储器简化模型
AT24C02介绍
引脚及应用电路
内部结构框图
I２C总线
I2C总线介绍
I2C电路规范
I2C时序结构
起始条件
终止条件
发送一个字节 接受一个字节 发送应答 接收应答
I2C数据帧
AT24C02数据帧
字节写
随机读
代码部分
遇到的问题 代码 硬件
今天我们来介绍一下AT24C02，首先呢，它是一种可以实现掉电不丢失的存储器，可用于保存单片机运行时想要永久保存的数据信息，在介绍AT24C02之前，我们先来介绍一下存储器！
存储器 先来简单介绍一下RAM（随机存储器）以及ROM（只读存储器）的优缺点吧！
优点缺点RAM储存速度快掉电丢失ROM存储速度慢掉电不丢失 RAM RAM主要分为SRAM（静态RAM）和DRAM（动态RAM），SRAM主要用于电脑CPU以及我们的单片机CPU；而DRAM主要用在电脑内存条以及手机的运行内存，因为电容器会掉电，所以需要不断进行扫描。
组成优点缺点SRAM触发器存储速度较快容量小，成本较高DRAM电容存储速度较慢容量大，成本较低 ROM ROM主要分为Mask ROM（掩膜ROM），PROM（可编程ROM），EPROM（可擦除可编程ROM ），E2PROM （电可擦除可编程ROM ），这四个是一家的，还有Flash（闪存），硬盘、软盘、光盘等，其中Flash目前使用十分广泛，基本上打败了ROM一家。
特点Mask ROM只能读PROM可以写，但只能一次EPROM可以写多次，但要紫外线照射３０分钟E2PROM可以写多次，并且只要几毫秒即可Flash与E２PROM类似，但集成度更高硬盘、软盘、光盘等软盘和光盘目前见的比较少了 存储器简化模型 这个地方涉及到了数电的知识，稍后会出数电寄存器一章的笔记，目前我们只能简单的讲解一下。左边是地址总线，下面是数据总线，首先我们选择地址总线，比如像赋值１０００００００，相当于打开了第一行，之后选择连接的结点（之前都没有连接上），将其连上，Mask　ROM使用的方法是一个二极管（这么做的原因是防止电流经过上面的节点导致数据混乱），而PROM使用了两个二极管（一个二极管和保险丝），但是其中一个二极管（保险丝）比较容易击穿，当给高电压的时候，蓝色电容（保险丝熔断）击穿，实现数据写入。这也是我们“烧录”的由来，然后我们现在的就是属于给电之后会恢复，实现反复写入，具体是怎么样的，我们在稍后的数电笔记中进行详细的介绍。 AT24C02介绍 接下来我们来简单介绍一下AT24C02吧！ AT24C02是一种可以实现掉电不丢失的存储器，可用于保存单片机运行时想要永久保存的数据信息存储介质：E2PROM通讯接口：I2C总线容量：256字节 引脚及应用电路 内部结构框图 接下来我们来简单的介绍一下内部结构，我们从每个部分进行讲解！
第一个就是我们刚刚介绍的存储器简化模型那样，网状结构第二个是一个译码器，用于输入地址第三个是输入输出端，通过Y　DEC将数据输出第四个也是译码器，用来帮助MUX输出数据，然后就直接输出数据第五个是用来擦除数据用的第六个是用来设置地址的，里面有个寄存器是用来存储地址的，每写入和读出寄存器自动加一，读出不指定地址，默认拿出寄存器的地址第七个是开始结束逻辑第八个是一个地址比较器第九个是一个控制串行逻辑 I２C总线 I2C总线介绍 I2C总线(Inter IC BUS)是由Philips公司开发的一种通用数据总线两根通信线:SCL(Serial Clock)、SDA(Serial Data)同步、半双工，带数据应答通用的I2C总线，可以使各种设备的通信标准统一，对于厂家来说，使用成熟的方案可以缩短芯片设计周期、提高稳定性，对于应用者来说，使用通用的通信协议可以避免学习各种各样的自定义协议，降低了学习和应用的难度 I2C电路规范 其中一个IC的内部结构
我们来抽象一下I2C的通信方式
通信规则：
1、杠子在上方代表1，下方代表0
2、每个人只能拉杆子或者松开手
3、每个人需要地址进行通信
I2C时序结构 接下来我们来介绍一下六个时序结构，只要集齐了这六个时序结构，就可以召唤数据帧了！
起始条件 起始条件：SCL高电平期间，SDA从高电平切换到低电平（相当于告诉大家我要发送信息了） 终止条件 终止条件：SCL高电平期间，SDA从低电平切换到高电平（相当于告诉大家我要停止了）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60b5496639fb91f172d21df12e370f2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/588dcaded97c23e8f19529e1553c0425/" rel="bookmark">
			Windows C/C&#43;&#43; 开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 项目需要在Windows下进行开发，所以进行开发环境的搭建，涉及编译器安装和IDE的设置。
MinGW下载和安装教程 网上找到的连接大部分是从sourforge上下载，但我从其中下载的有问题，安装失败，后来参考了下面的连接才搞定：
MinGW下载和安装教程
为防止连接失效，特复制主要部分如下：
下载安装包 官方链接：
MinGW 官网
点击安装 下载完成后，会得到一个名为 mingw-get-setup.exe 的安装包，双击打开它，可以看到如下的对话框：
直接点击“Install”，进入下面的对话框：
读者可根据自己操作系统的实际情况，自定义 MinGW 的安装位置（例如我选择将其安装到 E 盘–注意：不要选择带空格的路径！！！），然后点击“continue”，进入下面的对话框：
进入安装 MinGW 配置器的界面，读者耐心等待安装完成（显示 100%）即可。安装完成之后，我们会得到一个名为 “MinGW Installer Manager” 的软件，借助它，我们可以随时根据需要修改 GCC 编译器的配置。点击“continue”,会自动弹出配置界面，如下所示：
为使 GCC 同时支持编译 C 语言和 C++，需勾选图中标注的 2 项。我们知道，GCC 还支持其它编程语言，读者可借助此配置器，随时实际需要安装自己需要的编译环境。勾选完成后，在菜单栏中选择Installation -&gt; Apply Changes，弹出如下对话框：
选择“Apply”。然后耐心等待，直至安装成功，即可关闭此界面。注意，整个安装过程中可能会提示某些组件下载失败，但没关系，后续需要时，可以通过 MinGw Installer（图 4 所示）安装界面中的 “All Packages”选项中，手动选择指定的安装包进行安装。
环境变量设置 在安装完成的基础上，我们需要手动配置 PATH 环境变量。依次右击计算机（我的电脑） -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量，建议读者在当前用户的 PATH 环境变量中增加 MinGW 的安装路径，例如我将其安装到了E:\MinGW文件夹中，因此 PATH 环境变量的设置如下：
验证 打开命令行窗口（通过在搜索栏中执行 cmd 指令即可），输入gcc -v指令，如果输出 GCC 编译器的具体信息，则表示安装成功，例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/588dcaded97c23e8f19529e1553c0425/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1fe929b173e10f108aa498a99bfdeeb/" rel="bookmark">
			Mybatis plus无介绍快使用，MybatisPlus3.5版本设置批量插入附源码（十一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis plus无介绍快使用，MybatisPlus3.5版本设置批量插入附源码（十一） 问题背景Mybatis-plus无介绍快使用，CRUD增删改查基本使用附源码（一）Mybatis-plus无介绍快使用，自定义sql语句CRUD增删改查附源码（二）Mybatis-plus无介绍快使用，自带封装service层的使用附源码（三）Mybatis-plus无介绍快使用，注解的使用（四）Mybatis-plus无介绍快使用，Wrapper条件构造器的使用附源码（五）Mybatis-plus无介绍快使用，分页插件和乐观锁插件的使用附源码（六）Mybatis-plus无介绍快使用，枚举变量的使用附源码（七）Mybatis-plus无介绍快使用，多数据源的使用（八）Mybatis-plus无介绍快使用，MybatisX自动生成代码插件的使用（九）Mybatis-plus无介绍快使用，可继承通用的基础实体类（十） MybatisPlus批量插入总结Lyric： 放晴 等雨说放弃 问题背景 项目中，尽量使用批量插入，减少数据库磁盘IO的操作，提高效率
注意事项：
官方网站：https://baomidou.com/官方文档：https://baomidou.com/pages/24112f/可以自己创建工程，也可以下载源码进行参考MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id，实体类entity属性都使用对象，使用Long，不能使用long，不然雪花算法会失效
Mybatis-plus无介绍快使用，CRUD增删改查基本使用附源码（一） Mybatis-plus无介绍快使用，自定义sql语句CRUD增删改查附源码（二） Mybatis-plus无介绍快使用，自带封装service层的使用附源码（三） Mybatis-plus无介绍快使用，注解的使用（四） Mybatis-plus无介绍快使用，Wrapper条件构造器的使用附源码（五） Mybatis-plus无介绍快使用，分页插件和乐观锁插件的使用附源码（六） Mybatis-plus无介绍快使用，枚举变量的使用附源码（七） Mybatis-plus无介绍快使用，多数据源的使用（八） Mybatis-plus无介绍快使用，MybatisX自动生成代码插件的使用（九） Mybatis-plus无介绍快使用，可继承通用的基础实体类（十） MybatisPlus批量插入 1 MybatisPlus3.5版本和3.3版本有些许不同，3.3版本会少一个tableInfo参数，创建EasySqlInjector类
package com.lanran.transactional.config; import com.baomidou.mybatisplus.core.injector.AbstractMethod; import com.baomidou.mybatisplus.core.injector.DefaultSqlInjector; import com.baomidou.mybatisplus.core.metadata.TableInfo; import com.baomidou.mybatisplus.extension.injector.methods.InsertBatchSomeColumn; import java.util.List; /** * @Author suolong * @Date 2022/7/21 9:59 * @Version 2.0 */ public class EasySqlInjector extends DefaultSqlInjector { @Override public List&lt;AbstractMethod&gt; getMethodList(Class&lt;?&gt; mapperClass, TableInfo tableInfo) { // TODO Auto-generated method stub List&lt;AbstractMethod&gt; methodList = super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1fe929b173e10f108aa498a99bfdeeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f2df77f78664db5dcb2aea6c01b496/" rel="bookmark">
			php7.4安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统: CentOS 7.2.1511
内核版本: 3.10.0-327.el7.x86_64
php版本: php7.4.25
可以根据情况先下载所需要的安装包，如果没下载，走的有的是国外的站点去下载的，会比较慢，不怕慢的可忽略
注意：这里php配置mysql.sock是/tmp/mysql.sock，如果mysql配置sock文件不一致了，可以改php配置，或者对mysql.sock文件做软连接
执行该脚本可以直接部署php7.4.25，脚本信息如下
#!/usr/bin/env bash ################################################################# # # 用途: 安装php7.4.25 # # 日期: 2022-07-18 # # 作者: moyuanbo # ################################################################# # 切换到执行脚本的目录里 cd $(dirname $0) bash_dir=$(pwd) # ====================================== 变量修改信息 ====================================== # 执行日志存放路径 [[ -d logs ]] || mkdir logs execute_log=${bash_dir}/logs/execute.log # php安装包相关信息 php_tar_dir=php-7.4.25 php_tar_name=${php_tar_dir}.tar.gz # php启动用户和用户组 default_php_user=nginx default_php_group=nginx # php启动端口 default_php_port=9000 # 软件服务存放目录 default_software_dir=/data/software # php安装目录 default_php_init_dir=${default_software_dir}/php74 # 其他安装包版本信息 # wget https://libzip.org/download/libzip-1.2.0.tar.gz --no-check-certificate libzip_tar_dir=libzip-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6f2df77f78664db5dcb2aea6c01b496/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/221/">«</a>
	<span class="pagination__item pagination__item--current">222/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/223/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>