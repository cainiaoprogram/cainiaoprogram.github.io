<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9fa5c547ce542be3f665e0c72fb5720/" rel="bookmark">
			用函数来算平均分c语言,3.输入5个学生3门课的成绩，分别用函数实现下列功能： A）计算每个学生的平均分 B）计算每门课的平均分 C）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		满意答案
vxufh
2013.10.10
采纳率：51% 等级：12
已帮助：10462人
你好！求二位数组的行列总和可以考虑用双重for循环语句来实现。
一下是学生成绩系统：
可以实现：(1) 求各门课的平均分；
(2) 找出有两门以上不及格的学生，并输出其学号和不及格课程的成绩；
(3) 找出三门课平均成绩在85-90分的学生，并输出其学号和姓名
#include
void main(void)
{
int i,j,elect,num,count,average_score;
struct student
{
int yuwen;
int yingyu;
int shuxue;
int count;
float average_score;
}stu[5]={{78,45,76,0,0},{65,78,90,0,0},{29,46,63,0,0},{34,98,59,0,0},{80,90,99,0,0}};
for(i=0;i&lt;5;i++)
{
stu[i].count=stu[i].yuwen+stu[i].yingyu+stu[i].shuxue;
stu[i].average_score=stu[i].count/3.0;
}
printf("1.students' score demand\n2.look for disqualified student\n3.look for good student\n\nplease input your elect number:\n");
scanf("%d",&amp;elect);
switch(elect)
{
case 1:printf("\nplease input the number fo student[1-5]\n");
scanf("%d",&amp;num);
printf("yuwen=%d,yingyu=%d,shuxue=%d,count=%d,average=%f",stu[num-1].yuwen,
stu[num-1].yingyu,stu[num-1].shuxue,stu[num-1].count,stu[num-1].average_score);break;
case 2:for(i=0;i&lt;5;i++)
{
if(stu[i].yuwen&lt;60&amp;&amp;stu[i].yingyu&lt;60&amp;&amp;stu[i].shuxue&lt;60||stu[i].yuwen&lt;60&amp;&amp;stu[i].yingyu&lt;60||stu[i].yuwen&lt;60&amp;&amp;stu[i].shuxue&lt;60|| stu[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9fa5c547ce542be3f665e0c72fb5720/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5ab0a6332e2deec7ad9fc25f508267c/" rel="bookmark">
			利用scanf函数输入数据C语言,c语言：用scanf函数输入数据，举例并分析错误原因...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用scanf函数输入数据，举例并分析错误原因
用下面的scanf函数输入数据，使a=3，b=7,x=8.5,y=71.82,c1=’A’,c2=’a’。问在键盘上如何输入。
程序：
#include
int main()
{
int a, b;
float x, y;
char c1, c2;
scanf("a=%d b=%d",&amp;a,&amp;b);
scanf("%f %e",&amp;x,&amp;y);
scanf("%c%c", &amp;c1, &amp;c2);
printf("a=%d,b=%d,x=%f,y=%f,c1=%c,c2=%c\n",a,b,x,y,c1, c2);
return 0;
}
输入方式一及结果分析：
a=3 b=7
8.5 71.82Aa
a=3,b=7,x=8.500000,y=71.820000,c1=A,c2=a
请按任意键继续. . .
在输入8.5和71.82两个实数给x和y后，应紧接着输入字符A，中间不要有空格，由于字母A不是数字，系统在遇到字母A时，就确定输入给y的值已经结束，字符A就送到下一个scanf语句中的字符变量c1。
输入方式二及结果分析：
a=3 b=7
8.5 71.82 Aa
a=3,b=7,x=8.500000,y=71.820000,c1= ,c2=A
请按任意键继续. . .
在输入8.5和71.82两个实数后，输入的空格符就被c1读入，c2读入了字符A，故输出c1时就输出空格，输出c2的值为A。
输入方式三及结果分析：
a=3 b=7
8.5 71.82
Aa
a=3,b=7,x=8.500000,y=71.820000,c1=
,c2=A
请按任意键继续. . .
在输入8.5和71.82两个实数后，按回车键再输入Aa,这时“回车”被作为一个字符送到内存输入缓冲区，被c1读入，字符A被c2读取，故在输出c1时，就输出一个换行，在下一行输出逗号和c2的值A。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc1d17b4efc321e4859802d1d8c00692/" rel="bookmark">
			麦克纳姆小车底盘跟随云台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		麦克纳姆小车底盘跟随云台 一、简介二、程序流程三、逻辑解释 一、简介 底盘跟随在RoboMaster比赛中，是一种常见的底盘控制方式。而底盘的轮子是两种不同类型的麦克纳姆轮，如下图所示：
根据麦轮小滚轮的旋向，可以组成如下图所示的X型底盘小车：
其中，连接麦轮的电机为比赛使用的3508电机。本文规定：以电机底面顺时针旋转方向为正方向 （如下图从左往右看）
（图片来源于官方文档）
二、程序流程 底盘控制流程图如下所示，实际代码中是将YAW轴角度PID的控制量与遥控遥感值叠加，最后再赋值到底盘电机的速度环目标值中。
过零处理戳这里
这个流程图的代码能实现的效果是，当YAW轴的机械角度不在车头机械角度时，底盘就会沿着YAW轴当前的机械角度方向一直旋转。
当云台控制YAW轴电机保持不动时，就能实现底盘跟随。
流程图中PID各个量赋值如下图所示：
三、逻辑解释 解释起来其实不难，如下图所示，
左图中，angle_output&lt;0, 四个电机均反转，表现为底盘原地向左旋转。
右图中，angle_output&gt;0, 四个电机均正转，表现为底盘原地向右旋转。
此时，如果云台对YAW轴电机无控制，则表现为：底盘电机一直跟，永远跟不上。
要想让云台能被跟上，则需要通过云台上陀螺仪提供的角度进行串级PID控制，当云台的目标角度确定时（即云台保持不动），底盘才能“跟得上”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6755d4a17d8628ed53ab36a5914b5ca1/" rel="bookmark">
			minicom-linux串口工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装sudo apt install minicom
使用sudo minicom -D /dev/ttyUSB -b 115200
无法输入的情况
按下ctrl+A Z然后进入串口设置，然后修改硬件流控制为否
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80f2b8aa2c668b054a6486abcdc28fe6/" rel="bookmark">
			BMP的“数据4字节对齐”以及像素定位算法的个人探究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BMP的“数据4字节对齐”以及像素定位算法的个人探究
首先对于一个BMP图片，其扫描方式为
从下至上，从左至右，直到顶端
但是真正在写代码的过程中却因为这个对齐的问题，导致了像素数组的空间不足。故在此研究BMP数据并找寻解决的方案。
对于BMP格式的图片来说，一定是4字节对齐，这个所谓的4字节对齐不仅在于图片显示时的以4对齐，更在于图片数据的4字节对齐。以下内容将分为两部分：第一部分将探究BMP具体数据结构层面的“4字节对齐”，第二部分则基于Windows系统的BMP图片显示方式和像素定位/像素区域选取时易出现的——行列像素不对齐的问题进行算法上的研究。
Part1：
这里以一个100X100(宽X高)24位真彩色（RGB三通道）的BMP为例子，基于大量的实验发现：
如果是100X100，则取出的像素数为10000，字节数为30000 bytes
但是图片改变为101X100之后，如果仍以原方案取数据，则理应读取10100个数据。可将这些数据放入另一个自建的BMP文件中会发现根本无法显示。
检查之后发现一个有趣的现象：（由于0x76f6和0x76f7的两个00 00是可以忽略的，所以认为是0x76f5截止）
图 1 101X100的图像末尾数据
而新的BMP，理应是原封不动的，但是实际上是这样的：
图 2 新的BMP末尾数据
也就是说，新的图片在0x7691时已经结束，而原图像则在0x76f5结束
这时候便出现了惊人的一幕：
新图片与原图片整整少了100字节。少了100X1的字节
同样使用103x100重复步骤发现：
少了整整300个字节，也就是说少了100X3的字节。
再使用531X485的图片同样得出，确实缺少了1455字节，即485X3字节。
综合上述可见，（103*3bytes）mod4 = 1
（101*3bytes）mod4 = 3
（531*3bytes）mod4 = 1
P.S.这里*3计算字节数，531像素（RGB）有531*3字节的数据
暂且把这些余数称为 剩余行量A
可以发现 （（4-A）*Height） = 丢失字节量
这也就说明了必须保证4字节对齐，不足的情况
那么现在找到这个量，开始分析问题所在，
在实际拿数据的过程中，我使用的二维数组大小为10100x3,也就是说可以容纳10100个像素共30300字节的数据，但是通过上面的实验发现，需要扩大((4-A)*Height)bytes的空间
即扩大至30400字节，为了方便，一次性扩大Height像素的字节量，也就是（100*3）=300字节，最终的数组大小应该为30600字节，也就是10200像素。
而对于A = 1的状况，即上面531X485的状况，理论上应该使用的字节数为 772605 ，即257535像素（RGB）大小，实际应该增补（4-A）*485 = (4-1)*485 = 1455字节，即485像素的大小，即531-&gt;532，直接增加1455的量即可。
倘若A = 2，实际应该增补2*Height，这样的情况下，为了方便，则直接增加 3*height字节的量，从而实现补齐。
所以综合上述表达：
如果数据量不能满足被4整除，则可以在定义取用数组时多加3*Height的数据量，保证数据全部拿出。至于BMP文件中多余的字节，内容均为00，系统读取显示时会自动忽略，无需担心。
如果不计内存容量，仅从方便起见，则可以在每个数组初始化之时，都可以多加3*Height的数据量（即1Height像素）
Part2：
那么接下来说的是第二个点，关于实际显示时的问题
大量实验中发现，以100X100(Width*Height)的BMP图片为例子，由于BMP从下至上，从左至右的扫描方式，如果我想只显示最下面两行的图像，而将之后的图像屏蔽，理论上我需要取出 2*Width的像素，即3*2*Width字节（RGB）的数据，
即200像素，600字节的数据，实验结果是正常的：
图 3 100X100只显示最开始的两行数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80f2b8aa2c668b054a6486abcdc28fe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed3abdf5625ae0798706ab65a9a37379/" rel="bookmark">
			c语言用指针将姓名排序,利用指针将输入的10个同学的姓名按拼音全拼升序排序...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2016-05-31 回答
c语言是这样的 #include void main() { void select_sort(int *, int); int *p,i,a[10]; p=a; printf("input 10 numbers:\n"); for(i=0;i&lt;10;i++) scanf("%d",p++); p=a; select_sort(p,10); // select_sort(a,10); printf("the sorted numbers:\n"); for(p=a,i=0;i&lt;10;i++) { printf("%d ",*p++); } printf("\n"); } void select_sort(int *x, int n) { int i, j, k, temp; for(i=0; i #include void input(char (*p)[10],int n) { int i; //int for(i=0;i0) { strcpy( t,p[i] ); strcpy( p[i],p[j] ); strcpy( p[j],t); } } int main() { char s[4][10]; input(s,4); sort(s,4); output(s,4); system("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed3abdf5625ae0798706ab65a9a37379/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88d0b43a15362247814f84cae8149096/" rel="bookmark">
			linux下的exe文件怎么打开,exe文件扩展名，exe文件怎么打开？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.exe
文件类型1：PortableApps.com Application
文件说明：Computer program that can run from a portable device such as a USB flash drive, iPod, or portable hard drive; contains user settings on the portable device, allowing the program to run the same on multiple computers.
Portable apps use the compound file extension .PAF.EXE.
打开.exe文件
Mac OS
WindowsRare Ideas PortableApps.com software
Linux
其它内容
.exe
文件类型2：Windows Executable File
文件说明：DOS or Windows executable program or self-extracting archive; runs when opened; any Windows file that ends in .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88d0b43a15362247814f84cae8149096/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f16f9a4085904411f7e66025711b52a/" rel="bookmark">
			操作系统实战45讲第一课：实验环境搭建和遇到bug解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 搭建实验环境实验问题1、正在等待缓存锁：无法获得锁：https://blog.csdn.net/qq_44231964/article/details/1170028832、make: *** 没有规则可以创建目标“menuconfig”3、重启选择HelloOS启动后显示 error: file `/boot/HelloOS.bin’ not found.4、set root='hd0,msdos5' #boot目录挂载的分区,怎么写5、没有出现引导菜单，让选择HelloOS来启动 课程思维导图 搭建实验环境 首先点击该篇博文：无法获得锁
完成以上步骤：就安装好了gcc和nasm，此时再安装make sudo apt install -y gcc nasm make //不安装会报错make: *** 没有规则可以创建目标“menuconfig” 克隆代码，进入源码目录 git clone https://gitee.com/lmos/cosmos // 克隆源代码 cd cosmos/lesson02/HelloOS/ //进入源码目录 sudo apt install -y gcc nasm make //记得安装 make # 编译HelloOS内核文件HelloOS.bin sudo cp HelloOS.bin /boot/HelloOS.bin //拷贝内核文件到grub的引导分区里 添加grub启动项 # 编辑grub的配置文件 sudo vim /boot/grub/grub.cfg # 在键盘上依次按下： shift + g + o #进入文件，这些都是vim相关的操作 # 把下面内容粘贴到文末 #### BEGIN HelloOS.bin #### menuentry 'HelloOS' { insmod part_msdos #GRUB加载分区模块识别分区 insmod ext2 #GRUB加载ext文件系统模块识别ext文件系统 set root='hd0,msdos5' #注意boot目录挂载的分区，这是我机器上的情况 multiboot2 /boot/HelloOS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f16f9a4085904411f7e66025711b52a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51bcf935361d27332f8f963557331335/" rel="bookmark">
			idea2021启动失败 Could not find main class com/intellij/idea/Main
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
环境信息：
问题描述：
起因：
操作：
解决方案：
搜索结果：
解决思路：
解决方法：
结论：
环境信息： idea2021.1.1（注：如果是其它版本的idea，也可能会出现这个问题）
jdk1.8、jdk11
问题描述： 起因： 因为idea在启动项目的时候耗时很长，5分钟左右，于是百度了下idea占用cpu和内存过高的问题，发现有文章是说要更改idea的Runtime Version，
比如： 彻底解决Idea内存消耗严重和CPU资源占比严重的问题 (baidu.com)
intellij idea cpu占用率太大太满 运行速度太慢 使了五个解决方法最终成功_trusause的博客-CSDN博客_idea占用内存过大
操作： Choose Runtime，从默认的sdk11改成sdk8，idea自动重启的时候失败了，提示：
---------------------------
Error launching IDEA
---------------------------
Could not find main class com/intellij/idea/Main
解决方案： 搜索结果： 搜索了下这个错误，国内文章给的解决方案大多是配置jdk的路径，如 IDEA 启动报错could not find main class com/intellij/idea/main解决办法_人生如戏 全靠演技-CSDN博客
在环境变量里配置IDEA_JDK_64等等。
解决思路： 思路其实是对的，只是没能找到启动idea时设置使用的jdk路径的地方。
idea提供了命令行启动的方式，在idea的安装路径下bin目录（和idea64.exe同一个路径）有个idea.bat批处理文件，用cmd或PowerShell执行该bat之后，即能看到启动的详细信息，以PowerShell为例：
PS C:\Users\xxx&gt; cd D:\develop\IDEA\bin
PS D:\develop\IDEA\bin&gt; .\idea.bat
Error: A JNI error has occurred, please check your installation and try again
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51bcf935361d27332f8f963557331335/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/334913019789d32907e2cdd177800f33/" rel="bookmark">
			Windows 下的高 DPI 应用开发（UWP / WPF / Windows Forms / Win32）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://blog.walterlv.com
作者：吕毅
本文将介绍 Windows 系统中高 DPI 开发的基础知识。由于涉及到坐标转换，这种转换经常发生在计算的不知不觉中；所以无论你使用哪种 Windows 下的 UI 框架进行开发，你都需要了解这些内容，以免不断踩坑。
本文内容
各种不同的 Windows 桌面 UI 框架对普通用户而言的 DPI 级别对 Windows 应用而言的 DPI 感知级别（Dpi Awareness）不同 UI 框架对 DPI 的支持情况 UWPWPFWindows Forms其他 UI 框架混合 DPI 感知级别DPI 相关的 Windows API 的迁移关于 DPI 相关 API 变化的故事 关于 Windows 10关于 Windows Vista 之前的系统 各种不同的 Windows 桌面 UI 框架 微软主推的 Windows 桌面 UI 框架有：
UWPWPFWindows FormsWin32 与 C++DirectX 后两者实际上并不是 UI 框架，是 UI 框架的底层不同实现。当然你单纯凭借 Win32 和 DirectX 去开发 GUI 应用也没有人拦你，只不过如果你试图只用 Win32 和 DirectX 而不进行各种 UI 组件封装的话，最终会非常痛苦的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/334913019789d32907e2cdd177800f33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18cc3cd7b533b6b7bd3b23a1f2dfde26/" rel="bookmark">
			AWS CLI SSL: CERTIFICATE_VERIFY_FAILED 错误分析与解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在前面的一些文章中，我们用到了 AWS Cli。比如为 ECS Fargate 建 Task 和 Service。
处于安全原因，很多公司都是通过 http 代理访问 internet，这时使用 AWS Cli 操作 AWS 时，可能会碰到“SSL validation failed”错误。
比如运行如下命令
aws sts get-caller-identity 会产生如下报错
SSL validation failed for https://sts.cn-north-1.amazonaws.com.cn/ [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1056) 图 1
这时可以用“–no-verify-ssl”参数解决
aws sts get-caller-identity --no-verify-ssl 但这种方式不但降低了安全性，而且结果总会带有一长串恼人的告警
urllib3/connectionpool.py:1013: InsecureRequestWarning: Unverified HTTPS request is being made to host 'pitc-zscaler-americas-cincinnati3pr.proxy.corporate.ge.com'. Adding certificate verification is strongly advised. See: https://urllib3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18cc3cd7b533b6b7bd3b23a1f2dfde26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb9d53f6d5b2d7976434be3657cfd501/" rel="bookmark">
			Swagger @Api position失效，解决解决接口排序问题（最简单版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在网上看了很多版本关于如何解决这个问题，但是都很复杂，现在提供一个最简单的方式
Swagger依赖
&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 如下所示，只是需要这么写：
@Api(tags = "1.系统健康检查接口")
@Api(tags = "2.后台管理接口")，
@Api(tags = "3.测试管理接口")，
那么接口就会按照1.2.3这个顺序排序了，只是说这样必须要在接口说明前加个编号，他就会自动按照这个排序了，简单吧，嗯，很简单！！
/** *@description : 健康检查 *@author jianglin *@date 2021/04/23 17:29 */ @Api(tags = "1.系统健康检查相关接口") @RestController @RequestMapping("/") public class HealthController { /** * 健康检查 * @return : 成功返回200 */ @ApiOperation("健康检查接口") @GetMapping(value = "/health") public String health() { return "200"; } /** * 准备就绪 * @return ： 成功返回200 */ @ApiOperation("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb9d53f6d5b2d7976434be3657cfd501/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fc3721117a8837481da46f1765a7019/" rel="bookmark">
			Jqgrid 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jqgrid入门-显示基本的表格(一) 首先对Jqgrid网格插件做个简要的说明。在众多的表格插件中，Jqgrid的特点是非常鲜明的。
特点如下:
完整的表格呈现与运算功能，包含换页、栏位排序、grouping、新增、修改及删除资料等功能。自定义的工具列。预设的Navigator工具列，可以很容易的使用新增、删除、编辑、检视及搜寻等功能。完整的分页功能。按下任一栏位的标头，皆可以该栏位为排序项目。无论是升序或降序皆可。预设的action formatter，可以快速而直觉地对每笔资料做运算。支持多种数据格式。比如json、xml、array等。 （1）HTML部分 想要顺利的使用Jqgrid，需要引用下面6个文件。分别是：
jquery-ui-1.8.1.custom.css（jQuery UI界面的CSS文件）ui.jqgrid.custom.css（专用于jqGrid界面的CSS文件）jquery-1.7.2.js（jQuery的核心）jquery-ui-1.8.1.custom.min.js（用于支持jQuery UI界面）grid.locale-zh-CN.js（针对jqGrid的locale设置，根据locale不同，选择不同的尾缀）jquery.jqGrid.min.js（jqGrid的核心，可以到jqGrid网站，根据需求选择模块下载） 然后在html的body里面创建一个table和div并赋予id属性就行了。如图，非常简洁。
&lt;link href="&lt;%=basePath%&gt;main/css/ui.jqgrid.css" rel="stylesheet" type="text/css" /&gt; &lt;link href="&lt;%=basePath%&gt;main/css/jquery-ui-1.8.1.custom.css" rel="stylesheet" type="text/css" /&gt; &lt;script type="text/javascript" src="&lt;%=basePath%&gt;main/js/jquery-1.7.2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="&lt;%=basePath%&gt;main/js/grid.locale-zh_CN.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="&lt;%=basePath%&gt;main/js/jquery.jqGrid.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="&lt;%=basePath%&gt;main/js/grid.custom.js"&gt;&lt;/script&gt; &lt;table id="list"&gt;&lt;/table&gt; &lt;div id="page"&gt;&lt;/div&gt; table是jqgrid的表格获取的id
div#page是分页使用
（2）JS部分 官方文档说实现一个要想生成一个 Jqgrid ，最直接的方法就是：
$(“#grid_id”).jqGrid(options);也就是得到一个table的jquery对象，然后传递options就可以得到一个Jqgrid对象。
简单的介绍下options中最重要的部分。
1. jqGrid的重要选项 具体的options参考，可以访问Jqgrid文档关于option的章节（http://www.trirand.com/jqgridwiki/doku.php?id=wiki:options）。其中有几个是比较常用的，重点介绍一下：
url：提交处理数据的地址。datatype：这个参数用于设定将要得到的数据类型。我最常用的是“json”，其余的类型还包括：xml、xmlstring、local、javascript、function、local。mtype: 定义使用哪种方法发起请求，GET或者POST。height：Grid的高度，可以接受数字、%值、auto，默认值为150。width：Grid的宽度，如果未设置，则宽度应为所有列宽的之和；如果设置了宽度，则每列的宽度将会根据shrinkToFit选项的设置，进行设置。shrinkToFit：此选项用于根据width计算每列宽度的算法。默认值为true。如果shrinkToFit为true且设置了width值，则每列宽度会根据width成比例缩放；如果shrinkToFit为false且设置了width值，则每列的宽度不会成比例缩放，而是保持原有设置，而Grid将会有水平滚动条。autowidth：默认值为false。如果设为true，则Grid的宽度会根据父容器的宽度自动重算。重算仅发生在Grid初始化的阶段；如果当父容器尺寸变化了，同时也需要变化Grid的尺寸的话，则需要在自己的代码中调用setGridWidth方法来完成。pager：定义页码控制条PageBarsortname：指定默认的排序列，可以是列名也可以是数字。此参数会在被传递到服务端。viewrecords：设置是否在PagerBar显示所有记录的总数。caption：Grid的标题。如果设置了，则将显示在Grid的Header层 ；如果未设置，则标题区域不显示 。rowNum：用于设置Grid中一次显示的行数，默认值为20。rowList：一个数组，用于设置Grid可以接受的rowNum值。例如[10,20,30]。prmNames：这是一个数组，用于设置jqGrid将要向服务端传递的参数名称。我们一般不用去改变什么。colModel：最重要的数组之一，用于设定各列的参数。（稍后详述）jsonReader：这又是一个数组，用来设定如何解析从Server端发回来的json数据。（稍后详述） 2. colModel的重要选项 和Jqgrid一样colModel也有许多非常重要的选项，在使用搜索、排序等方面都会用到。这里先只说说最基本的。
name：为Grid中的每个列设置唯一的名称，这是一个必需选项，其中保留字包括subgrid、cb、rn。index：设置排序时所使用的索引名称，这个index名称会作为sidx参数传递到服务端。label：表格显示的列名。width：设置列的宽度，目前只能接受以px为单位的数值，默认为150。sortable：设置该列是否可以排序，默认为true。search：设置该列是否可以被列为搜索条件，默认为true。resizable：设置列是否可以变更尺寸，默认为true。hidden：设置此列初始化时是否为隐藏状态，默认为false。formatter：预设类型或用来格式化该列的自定义函数名。常用预设格式有：integer、date、currency、number等（具体参见文档）。 3. jsonReader选项 jsonReader是Jqgrid的一个重要选项，用于设置如何解析从服务端发回来的json数据。其默认值为：
jsonReader : { root : "rows", // 实际模型的人口 page : "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fc3721117a8837481da46f1765a7019/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf5a2ac422fc9f95dcf60b40588a7de/" rel="bookmark">
			Vue前端项目打包成exe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue前端项目打包成exe 1、Vue打包成dist文件 1、确保router文件的index.js
这里将mode：“history"，隐藏起来，默认使用hash模式。
const router = new VueRouter({ // mode: 'history', routes }) 2、vue.config.js
const { resolve } = require('path') module.exports = { assetsDir: 'static', devServer: { port: 8000, open: true }, lintOnSave: false, // 打包成exe文件这个必有 publicPath: './', // publicPath: process.env.NODE_ENV === 'production' // ? '/production-sub-path/' // : '/', configureWebpack: { resolve: { alias: { // 以@代表src目录 '@': resolve('src') } } } } 2、Electron项目文件（Electron官网教程） 1、创建打包项目文件和安装Electron
mkdir my-electron-app &amp;&amp; cd my-electron-app npm init -y npm i --save-dev electron 2、在项目根目录下创建main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bf5a2ac422fc9f95dcf60b40588a7de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c3eee2d56fbd318fe0ed5eb13e0299b/" rel="bookmark">
			int **p c语言,深入解析int(*p)[]和int(**p)[]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. int(*p)[10]:根据运算符的结合律，()的优先级最高，所以p是一个指针，指向的一个维度为10的一维数组。
p一个指向数组的某一行
复制代码 代码如下:
int a[1][4]={1,2,3,4};
int (*p)[4] = a;//p point to the row of array a
for(int i=0;i&lt;4;i++)
{
cout&lt;
}
2. int(**q)[10]这个的意义：q是一个指针，指向的元素就是1.中的p.
下面给一个例子：
复制代码 代码如下:
#include
#include
using namespace std;
int main()
{
int a[2][2]={1,2,3,4};
int (*p)[2] = a;//p point to the row of array a
for(int i = 0;i&lt;2;i++)//output matrix using p
{
for(int j = 0;j&lt;2;j++)
{
cout&lt;
}
cout&lt;
}
int (**q)[2] = &amp;p;//q point to p
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c3eee2d56fbd318fe0ed5eb13e0299b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b3c7d52eefe62c27d17a76b6c7112a8/" rel="bookmark">
			c语言char用scanf,[求助]使用scanf时，char型的正确输入方法应该是如何？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[求助]使用scanf时，char型的正确输入方法应该是如何？
首先是第一段代码
#include
#include
main()
{
char c1,c2;
scanf("%c,%c",&amp;c1,&amp;c2);
printf("c1='%c',c2='%c'\n",c1,c2);
system("pause");
}
建立c1,c2为字符型变量，输入c1,c2的值后输出c1,c2。
输入：
a,b
输出：
c1='a',c2='b'
以上没有问题。
然后我修改了一下代码
#include
#include
main()
{
int a,b;
char c1,c2;
scanf("%d,%d",&amp;a,&amp;b);
scanf("%c,%c",&amp;c1,&amp;c2);
printf("c1='%c',c2='%c'\n",c1,c2);
system("pause");
}建立了两个整型变量 a,b。并先用scanf输入a,b的值。然后再输入c1,c2的值。
输入：
12，34
a,b
输出：
c1='
',c2='f'
出问题了……这应该是程序把换行符\n当成了c1的值。我刚开始以为这里应该断开一下，于是又改了下代码。
#include
#include
main()
{
int a,b;
char c1,c2;
scanf("%d,%d",&amp;a,&amp;b);
printf("1\n");
scanf("%c,%c",&amp;c1,&amp;c2);
printf("c1='%c',c2='%c'\n",c1,c2);
system("pause");
}在输入a,b的值后，让它先输出个1，然后再输入c1,c2。
输入：
12，34
(输出1)
a,b
输出：
c1='
',c2='f'
依然如旧……
于是我用了第二个程序，不过改变了一下输入方法。
输入：
12，34a,b
输出：
c1='a',c2='b'
以上。
我的问题是，要如何写代码才能保证在不出错的情况下将a,b的值和c1,c2的值分为两行输入？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b3c7d52eefe62c27d17a76b6c7112a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf220f716365883ec29cb69578cb6fed/" rel="bookmark">
			C语言的32个关键字怎么背,C语言32个关键字，精心整理带中文翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言32个关键字，精心整理带中文翻译。关键字按照字母表顺序排列。
auto 局部变量(自动储存)
break 无条件退出程序最内层循环
case switch语句中选择项
char 单字节整型数据
const 定义不可更改的常量值
continue 中断本次循环，并转向下一次循环
default switch语句中的默认选择项
do 用于构成do.....while循环语句
double 定义双精度浮点型数据
else 构成if.....else选择程序结构
enum 枚举
extern 在其它程序模块中说明了全局变量
float 定义单精度浮点型数据
for 构成for循环语句
goto 构成goto转移结构
if 构成if....else选择结构
int 基本整型数据
long 长整型数据
register CPU内部寄存的变量
return 用于返回函数的返回值
short 短整型数据
signed 有符号数
sizeof 计算表达式或数据类型的占用字节数
static 定义静态变量
struct 定义结构类型数据
switch 构成switch选择结构
typedef 重新定义数据类型
union 联合类型数据
unsigned 定义无符号数据
void 定义无类型数据
volatile 该变量在程序中执行中可被隐含地改变
while 用于构成do...while或while循环结构
main 主函数
printf 打印
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf220f716365883ec29cb69578cb6fed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49ee87145abd9d76c58431e8867cb48d/" rel="bookmark">
			2021-05-19 ASP.NET Core笔试题 说说如何使用C#实现简单模式gRPC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说说如何使用C#实现简单模式gRPC 分为客户端和服务端；
服务端：
1.通过vs新建一个gRPC服务，会内置一proto文件；内容如下，可以理解成是一个模板，通过这个模板可以生成对应的类文件。
syntax = "proto3"; //规范---标准---工具生成C# option csharp_namespace = "Zhaoxi.gRPCDemo.DefaultServer"; package greet; // The greeting service definition. service Greeter { // Sends a greeting rpc SayHello (HelloRequest) returns (HelloReply); } // The request message containing the user's name. message HelloRequest { string name = 1; } // The response message containing the greetings. message HelloReply { string message = 1; } 2.需要让这个文件生效，就必须要在项目文件中配置使用这个文件；GrpcServices=“Server”,这是服务端的配置；
&lt;ItemGroup&gt; &lt;Protobuf Include="Protos\CustomMath.proto" GrpcServices="Server" /&gt; &lt;Protobuf Include="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49ee87145abd9d76c58431e8867cb48d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de0a3289602dff693cac502f2bce00ce/" rel="bookmark">
			Error: EPERM: operation not permitted, mkdir ‘D:\Program Files\nodejs\node_cache\_cacache‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装vue时，出现如下错误：
E:\QianDuan\Vue3&gt;npm install -g @vue/cli
npm ERR! code EPERM
npm ERR! syscall mkdir
npm ERR! path D:\Program Files\nodejs\node_cache_cacache
npm ERR! errno -4048
npm ERR! Error: EPERM: operation not permitted, mkdir ‘D:\Program Files\nodejs\node_cache_cacache’
npm ERR! [OperationalError: EPERM: operation not permitted, mkdir ‘D:\Program Files\nodejs\node_cache_cacache’] {
npm ERR! cause: [Error: EPERM: operation not permitted, mkdir ‘D:\Program Files\nodejs\node_cache_cacache’] {
npm ERR! errno: -4048,
npm ERR! code: ‘EPERM’,
npm ERR! syscall: ‘mkdir’,
npm ERR! path: ‘D:\Program Files\nodejs\node_cache\_cacache’
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de0a3289602dff693cac502f2bce00ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98d13f797752a9b16e575fd700248a0f/" rel="bookmark">
			GRASP模式学习心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GRASP模式学习心得 文章目录 GRASP模式学习心得 本文分三个层次一、GRASP—“通用职责分配软件模式”二、九个模式的概念、提出的问题以及解决方案三、在实际编程中的应用# 系列文章目录参考文献 本文分三个层次 GRASP是学习使用设计模式的基础
一、GRASP—“通用职责分配软件模式” 1、概念
GRASP，全称为General Responsibility Assignment Software Pattern，即通用职责分配软件模式。GRASP模式描述了对象设计和责任分配的基本原则和模式。 确定需求并创建领域模型后，如何将方法添加到Class类中，并定义对象之间的消息传递以满足要求。GRASP是学习使用设计模式的基础，是一种学习辅助工具，可帮助人们理解基本对象设计，并以有条理，合理，可解释的方式应用设计推理。这种理解和使用设计原则的方法基于分配责任的模式。
2、核心思想
它是站在面向对象设计的角度，告诉我们怎样设计问题空间中的类与分配它们的行为职责，以及明确类之间的相互关系等，而不像GoF模式一样是针对特定问题而提出的解决方案。因此GRASP站在一个更高的角度来看待面向对象软件的设计，它是GoF设计模式的基础。GRASP是对象职责分配的基本原则，其核心思想是**职责分配(Responsibility Assignment)，用职责设计对象(Designing Objects with Responsibilities)。
3、有九个模式：信息专家、创建者、高内聚、低耦合、控制器、多态性、纯虚构、间接性、防止变异。（下面对九个模式具体讲解）
二、九个模式的概念、提出的问题以及解决方案 1、五个基本模式：信息专家、创建者、高内聚、低耦合、控制器；
2、四个扩展模式：多态性、纯虚构、间接性、防止变异。
（1）信息专家
“信息”不单指数据。
问题：给对象分配职责的基本原则是什么？
解决方案：把职责分配给信息专家，它具有实现这个职责所必需的信息
优点：
• 对象使用自身信息来完成任务，所以信息的封装性得以维持，因此支持了低耦合（至少不会增加耦合性）。
• 行为分布在那些具有所需信息的类之间，这样功能更集中，因此支持了高内聚。
相关模式或原则：
• GRASP：低耦合、高内聚
注意：和“关注点分离”一起使用使得对象进一步内聚，从而达到高内聚，也能降低耦合。
举例：获取所有买的商品总金额，Order和Goods是一对多的关系。
分析：Order本身关联了Goods，并且理解Goods的结构。在图例中Client通过Order获取了Goods并做了逻辑运算得出商品总金额，这种做法产生了不必要的依赖增加了耦合数量，商品总金额计算的职责由Order承担最合适。
延伸：在某些情况下，该方案并不合适，通常是由于耦合与内聚问题产生的，如：谁应该把对象A存入数据库？按照原则每个类都应该具有把自己持久化的能力。
（2）创建者
创建者指导我们分配那些与创建对象有关的职责。如此选择是为了保持低耦合。
问题：谁应该负责创建某类的新实例？
解决方案：满足以下条件之一时，将创建类A的职责分配给类B（当满足1条以上时，通常首选包含或聚合）。
• B“包含”或聚合A。
• B记录A。
• B频繁使用A。
• B具有A的初始化数据，该数据将在创建时传递给A。
优点：支持低耦合，因为创建者和被创建者已经存在关联，所以这种方式不会增加耦合性。
相关模式或原则：
• GRASP：低耦合
• GoF：具体工厂、抽象工厂
• 其他：整体-部分
注：包含（作者在这里标注了“”，因为包含在uml是表达用例关系的，用来说明对象关系也可以）、聚合、整体-部分 看UML定义；包含强调了强依赖（A是B的子集，A属于B，缺少了A时B不是整体），聚合是弱依赖（B由A组成，A不属于B）。
例子：
• Order包含Goods（Order脱离Goods就失去了完整性，没有存在的意义）。
• Order记录相关的Goods。
• Goods初始化数据：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98d13f797752a9b16e575fd700248a0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f517e6c4d01bdf7e80f2bb9f089f5873/" rel="bookmark">
			ubuntu创建android studio并配置图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版本：ubuntu 20
文章目录 一、安装jdk二、解压下载好的AS三、创建图标文件3.1创建软链，将studio.sh链接到/usr/bin目录中。3.2创建启动图标文件 一、安装jdk sudo apt-get install openjdk-8-jdk //安装完后检测是否成功 java -version 查找jdk默认的安装路径
1. which java --提示：/usr/bin/java 根据软连接查找下一级 ls -l /usr/bin/java --提示 /usr/bin/java -&gt; /etc/alternatives/java 再次执行软连接查询 ls -l /etc/alternatives/java --提示 /etc/alternatives/java -&gt; /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java 这样jdk安装目录就找到了。
二、解压下载好的AS tar -xzvf as.tar.gz -C /bin/androidstudio 解释：x是解压命令 z表示压缩包具有gz属性 v展示流程 f一定是最后一个，指定了源文件名称（绝对路径） -C解压到哪个目录。
然后在里面找到studo.sh运行。
不过这样运行只能在命令行中，在ubuntu软件中心是看不到的。所以我们需要将它链接到ubuntu的appstore。
三、创建图标文件 3.1创建软链，将studio.sh链接到/usr/bin目录中。 代码如下（示例）：
sudo ln -s /bin/androidstudio/bin/studio.sh /usr/bin/astudio 3.2创建启动图标文件 sudo vi /usr/share/applications/as.desktop 并将如下内容填入：
[Desktop Entry] Type=Application Name=Android studio Comment= this is android studio Icon=/bin/androidstudio/bin/studio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f517e6c4d01bdf7e80f2bb9f089f5873/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa5a19f16a45e4fe85cfcc2670658b0e/" rel="bookmark">
			jquery实现复选框全选、反选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML:
&lt;input id="all" type="checkbox" value="" /&gt; &lt;label for="all"&gt;全选&lt;/label&gt; &lt;input id="fan" type="checkbox" value="" /&gt; &lt;label for="fan"&gt;反选&lt;/label&gt; &lt;button id="getValue"&gt;获得所有选中值&lt;/button&gt; &lt;ul class="list"&gt; &lt;li&gt;&lt;input type="checkbox" value="Monday" /&gt;周一&lt;/li&gt; &lt;li&gt;&lt;input type="checkbox" value="Tuesday" /&gt;周二&lt;/li&gt; &lt;li&gt;&lt;input type="checkbox" value="Wednesday" /&gt;周三&lt;/li&gt; &lt;li&gt;&lt;input type="checkbox" value="Thursday " /&gt;周四&lt;/li&gt; &lt;li&gt;&lt;input type="checkbox" value="Friday" /&gt;周五&lt;/li&gt; &lt;/ul&gt; 1.全选/全不选
当勾选全选，列表中所有复选框全部选中，反之取消勾选，列表中所有复选框全部呈未选中状态
$('#all').click(function(){ if($(this)[0].checked){ // 全选 $(".list :checkbox").prop("checked",true) }else{ //全不选 $(".list :checkbox").prop("checked",false) } }) 2.反选
当勾选反选，列表中所有被选中的选项变为未选中状态，而所有未选中的选项变为已选中状态
// 反选 $('#fan').click(function(){ $('.list :checkbox').each((index,item)=&gt;{ $(item).prop("checked",!$(item).prop("checked")) }) checkall() }) 3.获取选中的值
// 获得选中值 $('#getValue').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa5a19f16a45e4fe85cfcc2670658b0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a43e71ea8d5160064faa518a19e26cf/" rel="bookmark">
			c语言程序报告数据输入输出,(C语言,实验报告数据类型及输入输出函数答案.doc...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(C语言,实验报告数据类型及输入输出函数答案
大 连 东 软 信 息 学 院
实 验 报 告
评
语
教师签字： 日期：成绩学时姓 名李义彪学号11160500112班级集成电路11001组别实验编号2实验名称C语言数据类型及输入输出函数课程名称计算机基础及c语言程序设计实验时间2011/10/18至实验地点A6 319,A5实验目的或要求熟悉C语言编译环境Turbo C 2.0；
熟悉C语言的基本数据类型；
熟悉C语言的基本输入及输出函数；
使用TC编写简单的程序。实验内容(算法、程序、步骤和方法)
1.putchar()函数的使用方法
#include main()
{ int c; /*定义c为整形变量 */
char a; /*定义a为字符变量 */
c=65; a='B'; /*将65赋值给c，‘b’赋值给a*/
putchar(c); putchar('\n'); putchar(a);
} /*向终端输出字符 */
2.getchar()函数的使用方法
#include main()
{ int c; /*定义c为整形变量 */
printf("Enter a character:");/*打印Enter a character*/
c=getchar(); /*输出字符c */
printf("%c---&gt;hex%x\n",c,c);/*打印%c---&gt;hex%x\n */
}
3.printf()函数的使用方法
main()
{
int a=1234;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a43e71ea8d5160064faa518a19e26cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccb4b3756c1326e370ebb28179812164/" rel="bookmark">
			ESP8266(micropython)读取adc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ADC类提供了一个模拟-数字转换器的接口，并表示可以对连续电压进行采样并将其转换为离散值的单个值。
ADC可在专用引脚上使用。注意，ADC引脚上的输入电压必须在0v和1.0v之间
import machine adc = machine.ADC(pin) # create an ADC object acting on a pin val = adc.read_u16() # read a raw analog value in the range 0-65535 类:
classmachine.ADC(id)
访问与id标识的源相关联的ADC。这个id可以是一个整数(通常指定一个通道号)，一个Pin对象。或者其他由底层机器支持的值。
方法
ADC.read_u16()
取一个模拟读数并返回一个范围为0-65535的整数。返回值表示ADC进行的原始读取，缩放后的最小值是0，最大值是65535（精度更高）。
测试 from machine import ADC import time adc = ADC(0) for i in range(100): time.sleep(1) print('voltage is '+str(3.3/1024*adc.read())+'v') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef2f2f7095ad4c42f78156d4714640fb/" rel="bookmark">
			分段函数c语言编程noi,NOI1.4-13分段函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目大意：计算分段函数y=f(x)的值，注意，自变量的不同取值范围，函数的计算方法有所不同。
题目描述
编写程序，计算下列分段函数y=f(x)的值。
y=-x+2.5; 0 &lt;= x &lt; 5
y=2-1.5(x-3)(x-3); 5 &lt;= x &lt; 10
y=x/2-1.5; 10 &lt;= x &lt; 20
输入
一个浮点数N,0 &lt;= N &lt; 20
输出
输出N对应的分段函数值：f(N)。结果保留到小数点后三位。
样例输入
1.0
样例输出
1.500
解题思路
判断自变量x的值在哪个范围内，根据公式进行计算，并输出结果。
程序实现
对于每个范围，都判断一下，满足条件就执行计算对应的函数表达式。由于3个范围没有重叠，不会出现同时使用多个方法计算函数值的情况。
分支嵌套：已知x的范围是[0, 20)，如果x&lt;5，那么x肯定在区间[0, 5)之间，否则x取值范围在[5, 20)；在[5, 20)范围内，如果x&lt;10，那么x必定在[5, 10)范围内，否则在[10, 20)范围内。
分支嵌套简写：大括号里面如果只有一个语句，可以不加大括号，并写在同一行；再把else里面的if语句写在同一行就得到下面的代码。if…else if……else if…else连写，其实就是分支结构的嵌套：后面语句的执行，必定不满足前面的所有条件；反之，如果满足前面的某个条件，分支嵌套中后面的语句必不会执行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67447188f45c5a5e12341d56bd503d36/" rel="bookmark">
			notepad 如何编译C语言,notepad&#43;&#43;怎么运行c语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先需要在电脑上搭建MinGW编译环境。(推荐学习：notepad++)
下载后安装，安装完成后需要在Path中添加bin环境变量，具体安装步骤不多说，这里要注意MinGW一定要安装在C盘，以免之后不必要的错误。
编译环境搭建完成以后，打开NotePad++，创建一个.c文件并写一段C语言代码
写完之后，点击菜单栏--》运行--》运行，弹出框中输入编译命令：cmd /k gcc -o "$(CURRENT_DIRECTORY)\$(NAME_PART).exe" "$(FULL_CURRENT_PATH)" &amp; pause &amp; exit
选择快捷键后保存为： gcc编译，注意快捷键不要有重复，在点击弹出框的运行，Ok。
下一步，再点击菜单栏--》运行--》运行，弹出框中输入：cmd /k "$(CURRENT_DIRECTORY)\$(NAME_PART).exe"
同理保存名称换为为： gcc运行，再点运行程序就会执行了。
搭建完成！可以运行c语言了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a476ca0b84490574cbde547cc8cd6cc9/" rel="bookmark">
			Es6类的继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Es6之前，写一个继承的实现方法是创建一个构造函数， 如下：
function Person(name,age){ this.name=name; this.age=age; } let person = new Person("nike","18") ES6实现继承的方法： class Person(){ //表示类的构造方法 constructor(name,age){ this.name=name; this.age=age } //类的一般方法 showName(){ console.log(this.name) } } //创建类的实例 let person=new Person("lisa",17) 在实例对象上可以调用类中的方法：
person.showName() 现在写一个子类，子类要继承Person这个类，要通过**[extends]** super关键字表示调用父类的构造方法，也就是父类constructor中的内容
子类必须在constructor方法中调用super方法，否则new实例时会报错。因为子类没有自己的this对象，而是继承父类的this对象
class starPerson extends Person{ constructor(name,age,salary){ super(name,age); //子类中新加了salary属性，因为父类中没有这个属性，所以要自己添加 this.salary=salary } } let person = new starPerson('james',19,10000) console.log(person) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a513133ff48d461237f2b97ec7922f5/" rel="bookmark">
			C：单链表的插删(超详细图解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C:单链表的构建(超详细图解)
C:单链表的查找(超详细图解）
单链表-插入： 【样例】 从键盘依次输入某班学生的姓名和成绩并保存。然后输入某个学生的待插入位置，以及该学生的姓名和成绩。如果可以插入，则输出插入该学生后的单链表；如果不能插入，则输出NO。
【输入样例】 3 a 50 b 70 c 65 3 d 60 【输出样例】 a 50 b 70 d 60 c 65 【分析】 bool insertNode(node* first,int location,string name,int score){ node *s=first; node *c; c=new node; for(int i=1;i&lt;location;i++) { if(s-&gt;next==NULL) return 0; s=s-&gt;next; } c-&gt;name=name; c-&gt;score=score; c-&gt;next=s-&gt;next; s-&gt;next=c; return 1; } 【完整代码】 #include &lt;iostream&gt; #include&lt;stdio.h&gt; using namespace std; typedef struct node{ string name; int score; node* next; }node; node* create(node* head,string name[],int score[],int len); void show(node* first); bool insertNode(node* first,int location,string name,int score); int main() { int n; cin&gt;&gt;n; string name[n]; int score[n]; node* first=NULL; for(int i=0;i&lt;n;i++) cin&gt;&gt;name[i]&gt;&gt;score[i]; first=create(first,name,score,n); int location,stuScore; string stuName; cin&gt;&gt;location&gt;&gt;stuName&gt;&gt;stuScore; bool flag=insertNode(first,location,stuName,stuScore); if(flag == false) cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a513133ff48d461237f2b97ec7922f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fa9e8644771c2b0ba486762227a8697/" rel="bookmark">
			【Web前端HTML5&amp;CSS3】04-CSS语法与选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记来源：尚硅谷Web前端HTML5&amp;CSS3初学者零基础入门全套完整版
文章目录 CSS语法与选择器1. CSS简介层叠样式表内联样式（行内样式）内部样式表外部样式表 2. CSS基本语法注释css中的注释html中的注释JS(JavaScript)和JQuery中的注释 基本语法选择器声明块 3. CSS选择器通配选择器（Universal selector）元素选择器（Type selector）类选择器（Class selector）ID选择器（ID selector）属性选择器（Attribute selector） 4. 复合选择器交集选择器并集选择器（选择器分组） 5. 关系选择器子元素选择器（Child combinator）后代元素选择器（Descendant combinator）兄弟元素选择器（Sibling combinator） 6. 伪类选择器7. 伪元素选择器8. CSS Dinner游戏 CSS语法与选择器 1. CSS简介 层叠样式表 网页实际上是一个多层的结构，通过CSS可以分别为网页的每一个层来设置样式，而最终我们能看到只是网页的最上边一层
总之一句话，CSS用来设置网页中元素的样式
使用CSS来修改元素样式的方式大致可以分为3种
内联样式（行内样式） 在标签内部通过style属性来设置元素的样式
&lt;p style="color:red;font-size:60px;"&gt;内联样式（行内样式）&lt;/p&gt; 问题：使用内联样式，样式只能对一个标签生效。如果希望影响到多个元素，必须在每一个元素中都复制一遍；并且当样式发生变化时，我们必须要一个一个的修改，非常的不方便。（注意：开发时绝对不要使用内联样式）
内部样式表 将样式编写到head中的style标签里然后通过css的选择器来选中元素并为其设置各种样式可以同时为多个标签设置样式，并且修改时只需要修改一处即可。内部样式表更加方便对样式进行复用
&lt;style&gt; p{ color:green; font-size:50px; } &lt;/style&gt; 问题：我们的内部样式表只能对一个网页起作用，它里边的样式不能跨页面进行复用
外部样式表 可以将css样式编写到一个外部的CSS文件中，然后通过link标签来引入外部的CSS文件
&lt;link rel="stylesheet" href="./style.css"&gt; 外部样式表需要通过link标签进行引入，意味着只要想使用这些样式的网页都可以对其进行引用使样式，可以在不同页面之间进行复用
将样式编写到外部的CSS文件中，可以使用到浏览器的缓存机制，从而加快网页的加载速度，提高用户的体验。
2. CSS基本语法 注释 css中的注释 只能使用/*和*/包裹。即不管是单行注释，还是多行注释，都是以/*开头，以*/结尾
/* css中的单行注释 */ /* css中的多行注释 css中的多行注释 css中的多行注释 */ 我们对比下其他几种前端语言的注释
html中的注释 只能使用&lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fa9e8644771c2b0ba486762227a8697/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d211036cf242c241a93293b2fa513620/" rel="bookmark">
			c语言实验二输入与输出答案,C语言,实验报告数据类型及输入输出函数答案资料讲解.pdf...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		名师整理 优秀资源
大 连 东 软 信 息 学 院
实 验 报 告
评
成绩
学时
语 教师签字： 日期：
集 成 电 路
姓 名 李义彪 学号 11160500112 班级 组别
11001
实验编号 2 实验名称 C 语言数据类型及输入输出函数
课程名称 计算机基础及 c 语言程序设计
实验时间 2011/10/18至 实验地点 A6 319,A5
实验目的 1、 熟悉 C 语言编译环境 Turbo C 2.0 ；
2 、 熟悉 C 语言的基本数据类型；
3 、 熟悉 C 语言的基本输入及输出函数；
或要求 4 、 使用 TC 编写简单的程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d211036cf242c241a93293b2fa513620/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaa1a4204cbeed7328f1dcafd160dcfe/" rel="bookmark">
			2021-05-17 C#.NET面试题 说说什么事集群，什么是分布式。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说说什么事集群，什么是分布式。 集群: 多台服务器来完成业务处理，业务请求来了以后，每一台服务器都能独立的完成业务计算；每个服务器都是独立的个体；多台服务器集合起来，通常也需要做负载均衡；
分布式：多台服务器完成业务处理，也去请求来了以后，需要多个服务器合作来完成，比方说一个业务处理有5个环节，可能在处理的时候，A服务器处理第一个环节，B服务器处理第二个化解，C服务器处理第三个环节，D服务器处理第四个环节，E服务器来处理第五个环节；一个业务请求的5个环节，被五台服务器来合作完成了一个业务连，此类架构叫分布式架构；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a901148a56e5795b2531a45b588d32d0/" rel="bookmark">
			netstat命令下载、使用方法及其选项详情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux中netstat 命令用于显示网络状态，非常好用！
下载命令：
[root@backup ~]# yum install net-tools -y
命令使用格式：netstat [选项]
常用选项：
-a或–all 显示所有连线中的Socket。
-A&lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。
-c或–continuous 持续列出网络状态。
-C或–cache 显示路由器配置的快取信息。
-e或–extend 显示网络其他相关信息。
-F或–fib 显示路由缓存。
-g或–groups 显示多重广播功能群组组员名单。
-h或–help 在线帮助。
-i或–interfaces 显示网络界面信息表单。
-l或–listening 显示监控中的服务器的Socket。
-M或–masquerade 显示伪装的网络连线。
-n或–numeric 直接使用IP地址，而不通过域名服务器。
-N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称。
-o或–timers 显示计时器。
-p或–programs 显示正在使用Socket的程序识别码和程序名称。
-r或–route 显示Routing Table。
-s或–statistics 显示网络工作信息统计表。
-t或–tcp 显示TCP传输协议的连线状况。
-u或–udp 显示UDP传输协议的连线状况。
-v或–verbose 显示指令执行过程。
-V或–version 显示版本信息。
-w或–raw 显示RAW传输协议的连线状况。
-x或–unix 此选项的效果和指定"-A unix"选项相同。
–ip或–inet 此选项数的效果和指定"-A inet"选项相同。
常用选项组合:
[root@backup ~]# netstat -lntup
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d8053b19862d02c9cd121a57f77d345/" rel="bookmark">
			FISSA: Fusing Item Similarity Models with Self-Attention Networks for Sequential Recommendation未完成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ABSTRACT 顺序推荐由于其实用性和通过捕获顺序信息的高精度而一直是研究的热点。由于广泛采用基于深度学习（DL）的方法来对用户行为序列下的本地和动态偏好进行建模，因此用户的全局和静态偏好的建模往往被低估了，通常只有一些简单而粗略的用户潜在表示是介绍。此外，大多数现有方法都假设通过考虑历史行为可以完全捕获用户的意图，而忽略了现实中用户意图的可能不确定性，这可能会受到要推荐候选项目的出现的影响。因此，在本文中，我们着眼于这两个问题，即大多数基于DL的顺序推荐方法中用户全局偏好的不完善建模以及候选项目带来的用户意图的不确定性，并提出了一种新的解决方案，即融合项目相似性具有自我注意网络（FISSA）的模型以进行顺序推荐。具体来说，我们将最先进的自我关注顺序推荐（SASRec）模型作为本地表示学习模块，以捕获FISSA中用户行为序列下的动态偏好，并进一步提出一个全局表示学习模块，以改进了用户全局偏好的建模，以及通过考虑候选项目的信息来平衡本地和全局表示的选通模块。全局表示学习模块可以看作是基于位置的关注层，可以有效地与自我注意框架的并行化训练过程很好地吻合。选通模块通过使用MLP层对候选项目，最近交互的项目以及每个用户的全局首选项之间的关系进行建模来计算权重。对五个常用数据集的大量实证研究表明，就两个常用指标而言，我们的FISSA明显优于八个最新基准。
1 INTRODUCTION 推荐系统是缓解信息过载问题的智能工具，尤其是在用户意图不确定时。传统推荐系统仅处理一般推荐，其中用户-项目交互记录可以放置在二维评级矩阵中，以便通过填充该矩阵的空缺来实现预测。与一般推荐不同，顺序推荐将用户的历史记录视为项目序列而不是项目集，以便准确预测他们将与之互动的下一个项目。
顺序推荐现在得到了广泛的研究，因为它与实际情况更加一致，并且在考虑更多信息的情况下有望获得更准确的结果。既然已经在一般推荐中很好地研究了用户的全局和静态偏好，那么开发顺序推荐方法的一种直观方法就是对局部和动态偏好进行建模，并将其与全局偏好相结合。这正是最先进的因式分解个性化马尔可夫链（FPMC）[32]所做的。
具体而言，FPMC由两部分组成，即，将一类反馈矩阵分解的传统矩阵分解（MF）模型，以及对通过个性化马尔可夫链生成的过渡矩阵进行分解的新型MF模型。称为Fossil [8]的改进模型用因子项目相似性模型（FISM）替换了FPMC的前一个组件，通过包括多个转换矩阵将后者的组件扩展到更高阶版本，并且还引入了一些个性化的加权因子平衡这些全球和本地偏好。
最近，越来越多的基于深度学习（DL）的方法被用来对动态兴趣进行建模。应用递归神经网络（RNN）进行顺序推荐的最早作品之一是GRU4Rec [13]，它在每个步骤中逐步学习用户的偏好。Caser [38]利用卷积神经网络（CNN）通过滑动滤波器学习复杂的短期兴趣（即点级，联合级和跳跃级）。 在许多其他作品中，注意力机制已经成为一个重要的组成部分，可以发现用户的意图不受固定顺序的束缚。 SASRec [16]堆叠了多个自我注意模块，以有效地捕获序列中的长期和短期转变。 但是，这些基于DL的方法大多数都没有对静态表示学习给予足够的重视，例如，在静态和动态表示的结合中，例如在Caser中，简单地采用了可学习用户的潜在表示和并置操作， 这仍然使它们仍然面临着设计良好的全局表示和平衡组合方法（例如Fossil）的模型的挑战。
此外，几乎所有现有的顺序推荐方法均基于理想主义的假设，即可以通过使用用户的历史行为（即用户偏好的最终表示形式与新项目（或候选项目）之间的交互作用）完全捕获用户的意图。 （建议））通常在算法的最后一步执行，在此之前，候选项目的信息永远不会用于偏好学习。 实际上，用户的意图可能不确定，尤其是当他们参与长期的习惯行为（例如购买）序列而不是短暂的活动（例如听音乐）会话时。 判断一项新产品是否可以吸引用户的一种正确方法是考虑它如何引起用户兴趣的不同部分（即短期和长期）。
基于以上分析，本文提出了一种新颖的解决方案，称为融合项目相似性模型和自注意网络（或简称为FISSA），用于顺序推荐。我们的FISSA不仅将有效的全局表示学习与行之有效的方法（即自注意顺序推荐（SASRec）[16]）结合起来，而且还可以平衡用户对每个候选商品的短期和长期兴趣。具体而言，我们的模型包含三个主要组件，即本地表示学习模块，全局表示学习模块和用于平衡这两种表示的选通模块。对于局部表示学习，我们遵循SASRec，因为它具有出色的性能，并且增强动态兴趣建模不是本文的重点。对于全局表示学习，我们应用基于位置的关注层来实现FISM的专注版本[15]，其中引入了所有序列共享的查询向量，从而区分了生成全局变量的不同项目的重要性。序列的表示。受神经注意项目相似性（NAIS）[9]的启发，该相似性通过考虑项目与候选项目的关系来权衡项目，我们设计了基于多层感知器（MLP）的门控网络，该网络通过考虑以下因素来决定局部和全局表示的贡献率候选项目，最近交互的项目与目标用户的整体偏好之间的关系
We summarize our main contributions as follows:
针对目前大多数基于DL的序贯推荐方法对用户的全局偏好建模不完善和用户意图受候选项目影响的不确定性这两个问题，我们提出了一种新的解决方案FISSA。我们在FISSA中设计了一个全局表征学习模块来有效地捕捉用户的全局偏好，它可以看作是一个基于位置的关注层，与自我注意框架的并行化训练过程很好地契合。我们在FISSA中设计了一个基于MLP的门控模块，该模块通过考虑候选项的信息来平衡局部和全局表示，从而同时处理用户意图的不确定性。我们在五个常用的数据集上进行了广泛的实证研究，结果表明，我们的FISSA显著超过了八个最先进的基线。特别是，我们的FISSA在Rec@10和NDCG@10方面分别平均超过SASRec 10.11%和10.05%。我们还进行了烧蚀研究，并讨论了全局模块和选通模块等细节的一些选项。 2 REALTED WORK 在这一部分中，我们分别回顾了通用推荐和顺序推荐的最新方法，并指出了我们的FISSA与这些作品之间的联系和区别，以及我们的FISSA如何显著地推动了与所研究问题密切相关的作品的发展。
2.1 General Recommendation 协同过滤(CF)方法通常将用户的行为历史视为一组用户-项目交互对。CF方法主要有三个分支，即基于邻域的方法[1，34]、基于矩阵分解(MF)的方法[28，31]和混合方法[15，17]。基于MF的方法以其高效、准确的特点得到了广泛的应用。在基于MF的方法[28，31]的早期工作中，通过对评分矩阵进行奇异值分解(SVD)直接学习特定用户和特定项目的潜在表示向量，并通过两个对应向量的内积获得预测的评分。稍后，有建议15，17通过汇总他/她的交互项目的表示来获得用户的表示。通过这种方式，预测的评分可以看作是用户的历史项目和候选项目之间的因数相似度，这使得基于MF的模型与基于邻域的模型具有良好的可解释性。此外，复合用户表示在处理有限数量的用户记录时提供了更多信息。最近，基于深度学习(DL)的方法[2，10，21，42]被用来改进上述方法。例如，神经协同过滤(NCF)[10]使用多层感知器(MLP)来学习特定于用户和特定于项目的潜在表示向量，并且可以很容易地与传统的MF模型相结合。在另一种称为注意力协同过滤(ACF)[2]的模型中，注意力机制被应用于权衡不同的历史项目，并建立更全面的模型。神经注意项相似度(NAIS)[9]也应用了注意机制，但侧重于为候选项区分更重要的项，而不是为用户区分更重要的项。也有其他基于DL的方法使用自动编码器(AE)[21，22，42]或受限Boltzmann机器(RBM)[33]作为一般推荐。在本文中，我们实现了FISM[15]的一种关注形式，以获得用户行为序列的全局表示，并通过对候选项、最近交互的项和用户的全局偏好之间的关系建模，设计了一种平衡局部和全局表示的项相似度门控。
2.2 Sequential Recommendation 最早的顺序推荐工作使用马尔可夫链(MC)来建模项目之间的一阶转变[49]，或者使用马尔可夫决策过程(MDP)[35]来处理长期影响。后来，因式分解的个性化MC[32]被提出并扩展到高阶版本[8]，这些MC受到一般基于MF的方法[15，31]的启发并与之相结合。为了保持稀疏过渡数据的三角不等式，提出了度量嵌入[5]和基于平移的方法[7，19]。而目前大多数研究者都是随大流采用基于DL的方法来捕捉非线性和动态特征进行序贯推荐。基于RNN的模型[4，12，13，20，30，37，47]几乎是第一个被采用的，因为它们天生就是逐步建模序列的。为了避免RNN带来的消失梯度问题，还采用了其他基于DL的方法，使用CNN[38，48]，并增加了多个灵活的滤波器大小等特性来提炼短期特征。在RNN和CNNS的基础上，一些新兴的网络模型的应用开始流行。例如，记忆网络[3，14]、图神经网络(GNN)[26，29，41，43]配合注意机制被用来提取更具一致性或邻接性的短期特征。注意，注意机制本身也被证明是有效的，具有适当的层次结构[16，23，46]。在本文中，我们的局部表示学习模型基于自关注序列推荐(SASRec)模型[16]，它被发现是一种优秀的序列推荐模型，具有令人满意的简洁性和效率。值得注意的是，与其他通过引入图神经网络[43]或双向结构[36]来改进SASRec的工作不同，这些工作仍然侧重于局部和动态偏好建模，本文提出的FISSA旨在以平衡的方式将SASRec与有效的全局和静态偏好学习模型相结合。SASRec的另一项改进工作(即一致性感知推荐(CAR)[11])类似于我们的FISSA，将在第4节进一步讨论。
为了处理序列中用户意图的不确定性，现有的工作主要集中在区分序列中项目的重要性。例如，在最近的工作中，一个名为基于流会话推荐(SSR)[6]的模型关注流会话数据，并将基于MF的注意力引入基于RNN的会话编码器中，使得用户在当前会话中的意图与来自历史会话的长期偏好相关。与这项工作不同的是，我们关注的是一些长期存在的习惯行为(例如，查看、签到、购买等)，因此只考虑每个用户的一个序列。此外，除了通过自我关注模型学习序列中每个项目的重要性外，我们还分别对用户的短期偏好和长期偏好进行建模，然后根据不同的候选项目对它们进行平衡，这意味着我们的FISSA捕捉到了候选项目外观影响的变化意图，并且更加全面。
3 PROPOSED METHOD 我们在图1中说明了我们的FISSA，它包含三个主要组件，包括局部表示学习模块、全局表示学习模块和用于平衡这两种表示的门控模块。在本文中，我们用粗体的大写字母表示矩阵，用它们的小写形式表示相应的行向量。
3.1 Local Representation Learning 首先，我们通过提取每个用户最近的L行为来修正他/她的输入序列，缩写为
(通常选择相对较大的L值，例如，对于我们研究的数据集，选择L=50来保留大多数用户的整个序列，并且在需要时在序列的开头附加填充项)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94da35b2e17c0c0e76a50ed0ecf0fb19/" rel="bookmark">
			解决FTP服务器FileZilla server中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决FTP服务器FileZilla server中文乱码问题
参考文章：
（1）解决FTP服务器FileZilla server中文乱码问题
（2）https://www.cnblogs.com/dupeng0811/archive/2013/01/06/2847862.html
（3）https://www.codeprj.com/blog/2b74761.html
备忘一下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49da41bd4deb0017bc2c8803bdf0069e/" rel="bookmark">
			mmdetection的安装、测试（以Faster-rcnn为例进行训练测试）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、如何创建虚拟环境 看看有几个cpu： watch --color -n1 gpustat -cpu
创建自己的环境：conda create -n jj python=3.7
失败：出现下面的
-30-generic ubuntu/14.04.2 glibc/2.19 UID:GID : 1062:1063 netrc file : None offline mode : False An unexpected error has occurred. Conda has prepared the above report. 解决办法：
conda clean -i 重新进行创建
查询是否创建成功：conda info --envs
运行自己环境：source activate jj
退出虚拟环境：conda deactivate
建立一个文件夹：make ljj
进入文件夹：cd ljj
下载darknet： git clone https://github.com/pjreddie/darknet.git
进入darknet：cd darknet/
改makefile
运行：make
安装opencv：pip install opencv-python==4.1.0.25
conda install cudatookit=10.1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49da41bd4deb0017bc2c8803bdf0069e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0eaab5eaab5bf13f4cc8886cedeb29e/" rel="bookmark">
			c语言模拟存储流程图,初学单片机的40个实验(含汇编程序、C程序、流程图)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：
1． 闪烁灯 1
2． 模拟开关灯 4
3． 多路开关状态指示 7
4． 广告灯的左移右移 11
1． 实验任务 11
2． 电路原理图 11
3． 系统板上硬件连线 11
4． 程序设计内容 11
5． 广告灯(利用取表方式) 14
6． 报警产生器 18
7． I/O并行口直接驱动LED显示
8． 按键识别方法之一
9． 一键多功能按键识别技术
10． 00－99计数器
11． 00－59秒计时器(利用软件延时)
12． 可预置可逆4位计数器
13． 动态数码显示技术
14． 4×4矩阵式键盘识别技术
15． 定时计数器T0作定时应用技术(一)
16． 定时计数器T0作定时应用技术(二)
17． 99秒马表设计
18． “嘀、嘀、……”报警声
19． “叮咚”门铃
20． 数字钟
21． 拉幕式数码显示技术
22． 电子琴 103
23． 模拟计算器数字输入及显示 117
24． 8X8 LED点阵显示技术 124
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0eaab5eaab5bf13f4cc8886cedeb29e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c364615d3b5130e504a012f77d09e849/" rel="bookmark">
			python基础教程：python中@的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@是一个装饰器，针对函数，起调用传参的作用。
有修饰和被修饰的区别，‘@function’作为一个装饰器，用来修饰紧跟着的函数（可以是另一个装饰器，也可以是函数定义）。
代码1
def funA(desA): print("It's funA") def funB(desB): print("It's funB") @funA def funC(): print("It's funC") 结果1
It's funA 分析1
@funA 修饰函数定义def funC()，将funC()赋值给funA()的形参。
执行的时候由上而下，先定义funA、funB，然后运行funA(funC())。
此时desA=funC()，然后funA()输出‘It’s funA’。
代码2
''' 遇到问题没人解答？小编创建了一个Python学习交流QQ群：531509025 寻找有志同道合的小伙伴，互帮互助,群里还有不错的视频学习教程和PDF电子书！ ''' def funA(desA): print("It's funA") def funB(desB): print("It's funB") @funB @funA def funC(): print("It's funC") 结果2
It's funA It's funB 分析2
@funB 修饰装饰器@funA，@funA 修饰函数定义def funC()，将funC()赋值给funA()的形参，再将funA(funC())赋值给funB()。
执行的时候由上而下，先定义funA、funB，然后运行funB(funA(funC()))。
此时desA=funC()，然后funA()输出‘It’s funA’；desB=funA(funC())，然后funB()输出‘It’s funB’。
代码3
def funA(desA): print("It's funA") print('---') print(desA) desA() print('---') def funB(desB): print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c364615d3b5130e504a012f77d09e849/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a597286d038cbb9d0539641632c96074/" rel="bookmark">
			babel-plugin-transform-runtime
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章向大家介绍babel-plugin-transform-runtime，主要包括babel-plugin-transform-runtime使用实例、应用技巧、基本知识点总结和需要注意事项，具有一定的参考价值，需要的朋友可以参考一下。
引言 babel默认只转换新的 JavaScript 语法，比如箭头函数、spread。
不转换新的 API，例如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。
需要为当前环境提供一个垫片polyfill（一组代码，能够让旧的浏览器支持一些新的功能和特性），有三种：
1.babel-polyfill
2. babel-runtime
3. babel-plugin-transform-runtime
babel-polyfill
npm install --save babel-polyfill 因为这是一个 polyfill （它需要在你的源代码之前运行），我们需要让它成为一个 dependency，而不是一个 devDependency 。
babel-polyfill则是通过改写全局prototype的方式实现，比较适合单独运行的项目。
开启babel-polyfill的方式，可以直接在代码中require，或者在webpack的entry中添加，也可以在babel的env中设置useBuildins为true来开启。
但是babel-polyfill会有近100K，打包后代码冗余量比较大，对于现代的浏览器,有些不需要polyfill，造成流量浪费污染了全局对象
注意：你可能不需要 babel-polyfill 或者运行时插件，这取决于你实际想用 ES2015 中的哪个方法。你可能只想载入某些你正在使用的特定 polyfills (比如 Object.assign)，或者只是记录加载 library 的环境应该包含特定的 polyfills 。
babel-runtime
npm install --save babel-runtime babel-runtime 是为了减少重复代码而生的。babel-runtime插件能够将这些工具函数的代码转换成require语句，指向为对babel-runtime的引用。每当要转译一个api时都要手动加上require(‘babel-runtime’)。
runtime转换器插件主要做了三件事：
1、当你使用generators/async方法、函数时自动调用babel-runtime/regenerator
2、当你使用ES6 的Map或者内置的东西时自动调用babel-runtime/core-js
3、移除内联babel helpers并替换使用babel-runtime/helpers来替换
babel-plugin-transform-runtime
以插件的形式在打包时引入到文件里，主要的功能是为api提供沙箱的垫片方案，更因此适合用在第三方的开发产品中（开发工具包，库），一方面是体积够小，另一方面是用户（开发者）不会因为引用了我们的工具，包而污染了全局的原生方法，产生副作用。
安装
在大多数情况下，你应该安装 babel-plugin-transform-runtime 作为开发依赖（使用 --save-dev）。
npm install --save-dev babel-plugin-transform-runtime 并且将 babel-runtime 作为生产依赖（使用 --save）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a597286d038cbb9d0539641632c96074/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b39efee20b05c4fe82d20209912e56f6/" rel="bookmark">
			webpack 报错 ReferenceError: regeneratorRuntime is not defined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学webpack,打包时遇到，遇到下面的错误信息：
ReferenceError: regeneratorRuntime is not defined 这个报错是由于 async function 语法被 babel 转译之后的代码使用了 regeneratorRuntime 这个变量，但是这个变量在最终的代码里未定义造成的报错。
解决办法：
安装babel的插件：@babel/plugin-transform-runtime
补充这个插件的安装使用方法： 1、首先写一个 babel 配置文件：【.babelrc】
目录结构位置如下：
.babelrc 文件的配置： { "plugins": [ [ "babel-plugin-transform-runtime", { "absoluteRuntime": false, "corejs": false,//使用哪个core-js的版本，有2，和3两个版本一般用2 "helpers": true, "regenerator": true, "useESModules": false } ] ] } 选项说明 辅助(helpers)
默认值是:true
表示是否开启内联的babel helpers(即babel或者环境本来的存在的垫片或者某些对象方法函数)(clasCallCheck,extends,etc)在调用模块名字(moduleName)时将被替换名字。
垫片/polyfill
默认值是:`true’
表示是否把内置的东西(Promise,Set,Map,tec)转换成非全局污染垫片。
重新生成/regenerator
默认值是:true
是否开启generator函数转换成使用regenerator runtime来避免污染全局域。
模块名字/moduleName
默认值:babel-runtime
当调用辅助（内置垫片）设置模块（module）名字/路径.
再次致谢npm run dev 又报错
执行 npm install babel-plugin-transform-runtime 最终顺利执行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbe695ebd58a0c9fc71597b060b61de6/" rel="bookmark">
			【SPSS笔记01】交叉分析表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交叉表 交叉表用途&amp;使用步骤Step1Step2变量解释 Step3 交叉表结果观察卡方分析的解释 交叉表用途&amp;使用步骤 主要用途：主要用于分析分类变量的相关关系，如果是连续变量的相关性，主要使用相关分析
Step1 分析——描述统计——交叉表
Step2 将对应的分类型变量分别放在行和列，选择Statistics中的卡方，通过假设检验判断量分类变量之间的关系
变量解释 ①：卡方：选择卡方会计算Pearson 卡方、似然比卡方、Fisher 的精确检验和Yates 修正卡方（连续性修正）
②：对于行和列都包含排序值的表（比如客户的满意度），相关将生成Spearman 相关系数rho（仅数值数据）。Spearman 的rho 是秩次之间的关联的测量。
【注意：当两个表变量都是定量变量时，卡方将产生线性关联检验。相关产生Pearson 相关系数r，这是变量之间的线性关联的定量。】
③：对于名义变量（即数据大小没有实际意义且没有大小区分，如男1，女2）可以选择列联系数、Phi（系数）和Cramér 的V、Lambda（对称和非对称lambda 以及Goodman 和Kruskal的tau）和不确定性系数。
1）相依系数：基于卡方的关联性测量，范围在[0,1），
0表示变量之间毫不相关，接近1表示相关性较大。
（具体的数值大小与变量的个数相关）
2）Phi and Cramer’s V. Phi ：Phi=平方根（卡方检验统计量/样本大小），Cramer 的V 也是基于卡方统计量的关联性测量。
3）Lambda： 相关性测量，它反映使用自变量的值来预测因变量的值时，误差成比例缩小。值为1 表示自变量能完全预测因变量；值为0 表示自变量对于预测因变量没有帮助。
4）不确定系数：表示当一个变量的值用来预测其他变量的值时，误差成比例下降的程度。例如，值0.83 指示如果知道一个变量的值，则在预测其他变量的值时会将误差减少83%。程序同时计算不定性系数的对称版本和不对称版本。
④：对于有序变量（比如客户满意度，1代表非常不满意，5代表非常满意）
1）Gamma：两个有序变量之间的相关性的对称度量，它的范围是从-1 到1。绝对值接近1 的值表示两个变量之间存在紧密的关系。接近0 的值表示关系较弱或者没有关系。对于二阶表，显示零阶gamma。对于三阶表到n 阶表，显示条件gamma。
2）Sommer’s d：与Gamma相似，也反映两个有序变量之间相关性的测量：绝对值接近1的值表示两个变量之间存在紧密的关系，值接近0 则表示两个变量之间关系很弱或没有关系。Somers 的d 是gamma 的不对称扩展，不同之处仅在于它包含了未约束到自变量上的成对的数目。还将计算此统计量的对称版本。
3）Kendall’s tau-b：将结考虑在内的有序变量或排序变量的非参数相关性测量。系数的符号指示关系的方向，绝对值指示强度，绝对值越大则表示关系强度越高。可能的取值范围是从-1 到1，但-1 或+1 值只能从正方表中取得。
4）Kendall’s tau-c忽略结的有序变量的非参数关联性测量
⑤按区间标定：Eta
注意：如果是定量变量与定型变量之间分析，一定要选择Eta
Step3 点击单元格——选择计数（观察值表示基本的个数）——百分比（按需求选择按行、列划分百分比）
交叉表结果观察 如图，选择了按照行计算的百分比&amp;总记得百分比：
比如，第一行第二列的数据为42.1%，代表男性中有42.1%的人认为日报周末版更适合在周末阅读
卡方分析的解释 主要看Pearson卡方检验，计算出的统计量为7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbe695ebd58a0c9fc71597b060b61de6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e77da07184fae3c9b92396a94720de06/" rel="bookmark">
			SpringBoot基础系列-使用日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创文章，转载请标注出处：《SpringBoot基础系列-使用日志》
一、概述 SpringBoot使用Common Logging进行日志操作，Common Logging是一个日志功能框架，没有具体的实现，具体的日志操作需要具体的日志框架来实现。
常用的日志框架包括：JUL(Java Util Logging)、Log4J2、Logback。
默认情况下，使用的是Logback作为底层实现。
二、日志格式 SpringBoot的默认的日志格式如下：
2018-11-21 10:23:34.966 INFO 12588 --- [ restartedMain] c.e.s.SpringbootdemoApplication : Starting SpringbootdemoApplication on PC-20170621WOWM with PID 12588 (F:\Code\etongdai\etongdai-reactor\springbootdemo\target\classes started by Administrator in F:\Code\etongdai\etongdai-reactor\springbootdemo) 2018-11-21 10:23:34.968 INFO 12588 --- [ restartedMain] c.e.s.SpringbootdemoApplication : No active profile set, falling back to default profiles: default 2018-11-21 10:23:34.968 DEBUG 12588 --- [ restartedMain] o.s.boot.SpringApplication : Loading source class com.example.springbootdemo.SpringbootdemoApplication 格式为：(date) (time) (log level) (process Id) --- ([thread name]) (logger name) : (log message)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e77da07184fae3c9b92396a94720de06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a7523d1cb4e36dc7314381c2c2ff4bf/" rel="bookmark">
			S=x&#43;xx&#43;xxx&#43;xxxx……的代码实现过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：计算s=x+xx+xxx+xxxx…… 目录 题目：计算s=x+xx+xxx+xxxx…… 解题思路：当我们计算像这种题目的的时候可以优化一下： 第一步：把我们的x可以换做1~9的任何一个数； 第二步：假如我们取为1；那么s=1+11+111+1111+11111…… 第三步：找规律，他们的每一位都是相同的，其次他们的最后一位也同样是相同的； 第四步：思路：0先加1=1；然后将这个1乘上10后再加1=11；然后同样的道理，再给这个数乘以10后再加上1，以此类推……我们就可以得出我们的值s=1+11+111+1111+11111…… 以下是关于这个题目的代码部分，帮助理解哦~ import java.util.Scanner; public class TestAdd { public static void main(String []args){ Scanner input=new Scanner(System.in); int num=input.nextInt(); int n=0; long result =0; for (int i=0;i&lt;num;i++) { n=n*10+1; result+=n; } System.out.println(result); }} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/109767879a971a5ee0a1b2d01d3b5e1f/" rel="bookmark">
			export ‘OrbitControls‘ was not found in ‘three‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用three时导入遇到问题，vue正确引入OrbitControls：
import * as THREE from "three"; //引入Threejs
import OrbitControls from 'three-orbitcontrols';
使用：new OrbitControls(camera,renderer.domElement);//创建控件对象
中文网那个 new THREE.OrbitControls(camera,renderer.domElement);是不行的，还是要参考官方文档，因为中文文档存在滞后。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34170d24da5040290a3a94da0b0aa088/" rel="bookmark">
			光通信的最新技术趋势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小枣君。
上周，我参加了“2021中国光通信高质量发展论坛”，有一些收获与思考。特此撰文，与大家分享。
▉ 光通信的发展现状
1966年，华裔科学家高锟博士发表了那篇划时代的经典论文——《光频率介质纤维表面波导》，奠定了光纤通信的理论基础，也开启了伟大的光通信时代。
高锟（1933-2018）
如今，光纤通信已经走过了半个多世纪的发展历程。它彻底改变了人类通信技术的发展轨迹，也改变了我们每一个人的生活。
我们现在之所以能够享受高速且低价的网络连接服务，很大程度上要归功于光纤通信的贡献。
光纤（光导纤维）
如今，光纤通信已然成为整个通信网络的支柱和底座。全网超过98%以上的信息，都是通过光纤通信传递的。
《光纤通信55年的发展》，毛谦，中国信科
在产业方面，光通信作为承载网（传送网）和数据中心的关键技术，支撑了规模庞大的产业链。根据研究机构的数据，2020年全球光通信下游市场收入规模达到1.4万亿元。
中国企业在光通信产业链中，占据较高的比例：
《光纤通信55年的发展》，毛谦，中国信科
面向未来的光通信，还有很大的发展空间。现网中的数据流量，正在按照每年30%~40%的速度增长。从整体来看，技术变革仍然跟不上业务流量的增长速度。
流量增长＞单光纤流量＞端口速率＞电子波特率，需要新技术
《超100G高速智能光网络关键技术探讨》，张德朝，中国移动
在“云-管-端”架构下，光通信的业务流量压力，一方面来自用户端，另一方面来自云端。
用户端这边很明显。随着5G（蜂窝5G）、F5G（固网5G）的持续发展，4K/8K超高清视频的普及，用户侧终端的带宽在不断增加，承载网（传送网）的带宽也必须紧密跟进。
云端的带宽增长需求，更多是来自云业务的增长。
云业务具有横向流量（东西向流量）大的特点，分布式部署的方式，也加剧了这一类型的流量。
云业务、云服务的增长，刺激了数据中心（DC，Data Center）的建设热潮。
《高速光模块发展机遇与挑战》，张金双，新易盛
数据中心之间的连接——DCI（DC Interconnect，数据中心互联），带宽需求明显增加，成为一个重要的增长点。
▉ 光通信的技术发展路线
如何才能解决光通信网络带宽不足的问题呢？
从总体来看，还是两个思路。一，是通过更先进的技术，把传输网网络的物理带宽变得更大。二，是加强网络的调度能力，提升效率。
这就好比是我们的城市交通。一方面，要把路修得更宽，单车道变双车道、四车道甚至八车道。另一方面，设立更多、更智能的红绿灯，安排更多的交警，进行合理调度。
我们先看看底层的带宽提升技术。
目前，光纤通信的单波100G已经广泛商用。200G、400G的光模块光通道，基本上都是基于单波100G。
单波：100G ▶ 200G
光口：400G ▶ 800G ▶ 1.2T ▶ 1.6T
《高速光模块发展机遇与挑战》，张金双，新易盛
400G光模块在2019年左右就已经成熟商用，主要是国外Google、Facebook等公司的数据中心在普及。国内并没有广泛采用400G，一方面是因为要循序渐进（考虑成本），另一方面是基于网络架构的需求。也就是说，如果运营商的网络架构，设计接口是需要200G，那就是用200G，没有必要强行上400G。
未来，单波400G将是下一代OTN技术的基础传输速率。
从底层技术来看，提升带宽的主要手段，还是离不开最基础的通信原理。
方法一，采用更先进的调制技术。
《超100G高速智能光网络关键技术探讨》，张德朝，中国移动
方法二，使用更大的频谱带宽。
一般情况下，波道采用C波段，频谱资源是4THz。扩展为CE波段后，频谱资源增加20%，为4.8THz。如果采用C++波段，是6THz。如果采用C+L波段，是11THz，相比C波段提升了175%。
《智能新光网，铸就5G新基建》，刘哲，中兴通讯
毫无疑问，这可以显著提升光纤资源的利用率。
方法三，在芯片和算法上做文章。
《超100G高速智能光网络关键技术探讨》，张德朝，中国移动
方法四，研发新型光纤，提高单根光纤中的纤芯数，或引入材料学技术，降低光纤传输过程中的损耗。
新型光纤
《超100G高速智能光网络关键技术探讨》，张德朝，中国移动
除了载波带宽之外，节点的能力提升也是光网络的关注重点。
这里就是之前我反复写文章提到的全光网络。通过ROADM、OXC等技术，将节点全光化，避免光电交叉转换，减少环节，提升带宽，降低时延。
OXC
《超100G高速智能光网络关键技术探讨》，张德朝，中国移动
目前，骨干网的全光化已经很大程度完成。后续就是城域网（先城域核心，再汇聚、接入）的全光化。
OTN/WDM的下沉，也是专家们关注的重点，一方面可以支撑带宽增长需求，另一方面可以大幅节约光纤资源。
《加速千兆光网建设，打造全光智慧城市》，王金辉，华为
看完物理带宽的提升，我们再重点看看网络调度的演进。
这条路线，目前仍然是集中在SDN思路上。简而言之，还是开放和解耦。
运营商希望光通信网络进一步解耦，控制平面和数据平台进一步分离，厂商将控制面开放给运营商，运营商自己开发平台，对整个网络进行调度和管理。
《光网络的开放与解耦》，张成良，中国电信
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34170d24da5040290a3a94da0b0aa088/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52ee72385ac121bbbc8d4addde928ac9/" rel="bookmark">
			【机器学习基础】集成模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述1. Boosting2. Bagging偏差和方差的区别 3. Stacking4. Dropout训练Random Forest1.原理2.优缺点拓展：【RF模型能够输出特征的重要性程度】 GBDT1. GBDT适用范围？2. GBDT和随机森林（RF）的区别？3. GBDT相较于决策树有什么优点？4. GBDT的gradient体现在哪里？5. GBDT的re-sample Xgboost建树方式树分裂方式:exact树集成方式分布式稀疏数据level_wise LGBM树分裂方式建树方式:hist分布式类别特征 常见问题1. Bagging vs Boosting2. Xgboost vs GBDT拓：Xgboost vs LGBM3. 为什么xgboost使用泰勒展开？4. Xgboost如何寻找最优特征？是有放回还是无放回？5. gbdt原理6. xgboost源码看过吗 概述 个体学习器之间存在强依赖关系，必须串行生成的序列化方法*个体学习器之间不存在强依赖关系，可同时生成的并行化方法
1.【机器学习基础】决策树及其ensemble方法（RF, LGBM, Xgboost, GBDT, 梯度提升boosting） 1. Boosting 降低偏差（bias)
2. Bagging 降低方差
偏差和方差的区别 偏差：预估值与真实值的偏离程度，是算法对数据的拟合能力。
方差：数据扰动，训练集变化时，模型的学习性能。
噪声：任何学习算法在泛化能力的下界，是学习问题本身的难度。
3. Stacking 将第一层的输出train再结合其他的特征集再做一层，就是stacking。例如gbt+lr
4. Dropout训练 Dropout 训练继承模型的方式 from 花书7.12
Dropout 训练的集成包括所有从基础网络除去非输出单元后形成的子网络。在 Dropout 的情况下，所有模型共享参数，其中每个模型继承父神经网络参数的不同子集。
Random Forest 1.原理 在Bagging集成的基础上，进一步在决策树的训练过程中引入了随机特征选择。过程分为四个部分：
随机选择样本（bootstrap放回抽样）随机选择特征构建决策树随机森林投票（平均） 2.优缺点 （1）缺点：
随机森林在分类的效果比回归好。因为RF并不能给出一个连续型的输出。而且预测的时候不能超出数据的范围，可能导致有噪声的数据出现过拟合。忽略属性之间可能存在的相关性无法控制模型内部的运行，只能在不同的参数和随机种子之间进行尝试
（2）优点:高度并行，易于分布式实现随机森林可以解决分类和回归，方差和偏差都较低，泛化性能比较好对高维数据处理很好，并确定最重要的变量，因此被认为是一个不错的降维方法。存在分类不平衡时，可以提供平衡数据集误差的方法？由于是树模型，不需要归一化即可直接使用 拓展：【RF模型能够输出特征的重要性程度】 利用随机森林对特征重要性进行评估
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52ee72385ac121bbbc8d4addde928ac9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a34fbf4e686b2b1f40df78f0cf385a6/" rel="bookmark">
			轻量级网络——MobileNetV2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.MobileNetV2的介绍2.MobileNetV2的结构1）Inverted Residuals2）Linear Bottlenecks 3.MobileNetV2的性能统计4.MobileNetV2的pytorch实现 1.MobileNetV2的介绍 MobileNet v2网络是由google团队在2018年提出的，相比MobileNet V1网络，准确率更高，模型更小。
网络中的亮点 ：
Inverted Residuals （倒残差结构 ）Linear Bottlenecks（结构的最后一层采用线性层） 2.MobileNetV2的结构 1）Inverted Residuals 在之前的ResNet残差结构是先用1x1的卷积降维，再升维的操作。而在MobileNetV2中，是先升维，在降维的操作。
所以对于ResNet残差结构是两头大，中间小。而对于MobileNetV2结构是中间大，两头小的结构。
其中，在MobileNet结构中，采用了新的激活函数：ReLU6
2）Linear Bottlenecks 针对倒残差结构中，最后一层的卷积层，采用了线性的激活函数，而不是ReLU激活函数。
一个解释是，ReLU激活函数对于低维的信息可能会造成比较大的瞬损失，而对于高维的特征信息造成的损失很小。而且由于倒残差结构是两头小中间大，所以输出的是一个低维的特征信息。所以使用一个线性的激活函数避免特征损失。
结构如下所示：
ps：当stride=1且 输入特征矩阵与输出特征矩阵shape 相同时才有shortcut连接
shape的变化：其中的k是扩充因子
3.MobileNetV2的性能统计 Classification分类任务
其中MobileNetV2（1.4）中的1.4代表的是倍率因子也就是α，其中α是控制卷积层卷积核个数的超参数，β是控制输入图像的大小
可以看见，在CPU上分类一张图片主需要花75ms，基本上达到了实时性的要求。
Object Detection目标检测任务
可以看见，MobileNetV2的提出，已经基本上可以实现在移动设备或者是嵌入式设备来跑深度学习的模型了。将研究与日常生活结合了起来。
4.MobileNetV2的pytorch实现 MobileNetV2的网络结构
其中：
t是扩展因子，第一层1x1卷积层中卷积核的扩展倍率c是输出特征矩阵深度channeln是bottleneck的重复次数s是步距（ 针对第一层，其他为1 ，与ResNet的类似，通过第一层的步长改变尺寸变化） 参考代码
import torch import torch.nn as nn import torchvision # 分类个数 num_class = 5 # DW卷积 def Conv3x3BNReLU(in_channels,out_channels,stride,groups): return nn.Sequential( # stride=2 wh减半，stride=1 wh不变 nn.Conv2d(in_channels=in_channels, out_channels=out_channels, kernel_size=3, stride=stride, padding=1, groups=groups), nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a34fbf4e686b2b1f40df78f0cf385a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4d1fbf003ad55c9174d22c9d4a9f8c1/" rel="bookmark">
			JS完成QQ空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		登陆成功之后跳转到 qq.com （由于没有用数据库，密码设置的 123456）
// window.onload = function() {w // // 生成随机数，切换背景图片 // document.getElementById("body").style = // "background: url(img/bg" + Math.floor(Math.random() * 4) + ".jpg);" // + "background-size: 1366px 909px;"; + "background-position: 0px -135px;"; // } window.onload = function() { document.getElementById("body").style = "background: url(img/bg" + Math.floor(Math.random() * 4) + ".jpg);" + "background-size: 1366px 909px;" + "background-position: 0px -135px;"; } /* 校验表单 QQ： 1、不能为空（你还没有输入账号） 2、QQ号长度 &gt;=5 并且 &lt;= 11 （请输入正确的账号） 密码： 1、不能为空 （你还没有输入密码） 2、查询匹配（假数据 123456 进行匹配， 模拟交互） （错误：你输入的账号或密码不正确，请重新输入。） */ // 初始化数据 var qq_msg = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4d1fbf003ad55c9174d22c9d4a9f8c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6feeb4933889afa8d22429a3fa9e0074/" rel="bookmark">
			c语言中的false的作用,C语言中 false是不是关键字或函数?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言中 false不是关键字也不是函数,但是在c++中false 是关键字。
在计算机语言中，false表示常数0. 一个表示与 true 相反的唯一布尔值。true表示"1",false表示"0".当自动数据类型指定将 false 转换为数字时，它变为0；将 false 转换为字符串时，它变为 "false" 。
关键字(keyword)又称保留字，是整个语言范围内预先保留的标识符。每个C++关键字都有特殊的含义。经过预处理后，关键字从预处理记号(preprocessing-token)中区出来，剩下的标识符作为记号(token)，用于声明对象、函数、类型、命名空间等。不能声明与关键字同名的标识符。
C语言关键字有：由ANSI标准定义的共32个 :
auto double int struct break else long switch case enum register typedef char extern return union const float short unsigned continue for signed void default goto sizeof volatile do if while static
C++关键字有：
ISO C++98/03关键字共63个，此处严格按标准原文排版：
asm do if return typedef auto double inline short typeid bool dynamic_cast int signed typename break else long sizeof union case enum mutable static unsigned catch explicit namespace static_cast using char export new struct virtual class extern operator switch void const false private template volatile const_cast float protected this wchar_t continue for public throw while default friend register true delete goto reinterpret_cast try
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41bde38ce6a39ea1e71018beaecb920b/" rel="bookmark">
			阿里巴巴集群跟踪数据 Cluster Data V2017翻译文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://github.com/alibaba/clusterdata/blob/v2018/cluster-trace-v2017/trace_201708.md
以下阿里巴巴2017年公布的集群跟踪数据集（ Cluster Data V2017）,在公布该数据集以后，该公司又公布了 Cluster Data V2018，但由于2018数据集中有些数据情况说明并不详细，故翻译下2017的文档，以提供思考
概述： 阿里巴巴集群跟踪计划由阿里巴巴集团发布。通过提供来自实际生产的集群跟踪，该计划帮助研究人员、学生和对该领域感兴趣的人更好地了解现代互联网数据中心 （IDC） 的特征和工作负载。
到目前为止，已经发布了两个版本：
集群跟踪-v2017在12小时内包括约1300台机器。跟踪-v2017首先引入了在线服务（又名长运行应用程序）和批量工作负载的搭配。
集群跟踪-v2018包括约4000台机器，在8天的周边。除了比 Trace-v2017 具有更大的缩放器外，此件跟踪还包含我们生产批次工作负载的 DAG 信息。
我们的动机 正如最初所说，我们发布这些数据的动机是帮助相关领域的人们更好地了解现代数据中心，并为研究人员提供生产数据，以改变他们的想法。你可以随地使用跟踪，只要它是为重新seach或研究的目的。
从我们的角度来看，这些数据是为了应对阿里巴巴在IDC在线服务和批量工作并存方面面临的挑战。我们将挑战作为以下主题来提炼：
工作负载特征。如何以具有代表性的方式模拟各种生产工作量，以对阿里巴巴的工作量进行定性，以便进行调度和资源管理战略研究。将工作负载分配给机器的新算法。如何分配和重新安排工作负载到机器，以便更好地利用资源，并确保不同应用的性能 SLA（例如，通过减少资源争夺和确定适当的专业版）。在线服务调度器和批次作业调度器之间的协作。如何调整在线服务与批量作业之间的资源配置，提高批次作业的吞吐量，同时保持可接受的QoS（服务的可口性）和在线服务快速故障恢复。随着配置规模（由不同调度员管理的工作量）不断增加，协作机制的设计也变得越来越重要。 最后但并非最不重要的一点是，我们始终愿意与研究人员合作，提高我们集群的效率，并且有为研究实习生开放的职位。如果您有任何想法，请通过Aliababa 聚类数据或海阳鼎联系我们（海阳维护此集群跟踪，并为阿里巴巴的资源管理和调度组工作）。
介绍 随着数据中心规模的增长，大规模在线服务和批量作业共同分配用于提高数据中心效率。共同分配给现有的集群管理系统带来了巨大挑战，特别是对服务和工作调度员的挑战，它们必须共同努力，提高集群的利用率和效率。
我们提炼出我们认为对学术界和工业界都感兴趣的以下研究主题的挑战：
工作负载特征：我们如何以一种具有代表性的方式模拟各种生产工作量来描述阿里巴巴的工作量，以便进行调度员研究。将工作负载分配给机器和 cpu 内核的新算法。如何分配和重新调整工作负载到不同的机器和cpus，以更好地利用资源和可接受的资源争夺。在线服务与批量作业调度合作：如何调整在线服务与批量作业之间的资源配置，提高批次作业的吞吐量，同时保持可接受的服务质量和在线服务快速故障恢复。 为了帮助研究人员解决上述问题，我们提供 24 小时内从生产集群中获取的微量数据。数据包括部分机器和整个集群的工作负载。所有机器包括可以同时运行在线服务和批量作业。
通用技术和领域 出于保密原因，我们混淆了跟踪中的某些信息
时间和时间戳 跟踪中的每个记录都包含一个时间戳，该时间戳在几秒钟内，相对于跟踪周期的开始。此外，0 的时间表示事件发生在跟踪期之前。在某些文件中，有一小部分条目（例如，少于 0.1%）带有负时间戳，它们还指示事件发生在跟踪开始时间之前。batch_instance.csv
使用情况（包括实例和机器使用情况）的测量以 60 秒的时间间隔进行，平均超过 300 秒。出于保密原因，我们仅连续 12 小时披露使用数据。
唯一标识符 每台机器、在线和服务工作负载都给出一个数字 ID，这在跟踪期间是独一无二的。未提供服务和任务名称。
资源单位 大多数资源利用测量和请求已归一化，包括：
内存大小磁盘空间 Cpu核心计数未归一化
数据表 下面我们描绘对所提供的表。提醒：并非所有跟踪都将包括此处描述的所有类型的数据。列可能以不同的顺序出现，或者名称与此处报告的名称不同：此类详细信息的最终规范可以在schema.csv文件中找到。
机器 机器由两个表描述：机器事件表和机器资源利用表
机器事件 时间戳机器事件类型事件详细信息容量：CPU容量：内存容量：磁盘 此跟踪包括三种类型的机器事件：
add。集群中可用了一台机器。跟踪中的所有机器都有 ADD 事件，并且具有值为 0 的时间戳，因为所有机器都是在跟踪收集之前添加的。softerror。由于软件故障（如低磁盘空间和代理故障），机器暂时不可用。harderror。由于硬件故障（如磁盘故障），机器无法使用。 在软件和硬件错误的情况下，不应将新的在线服务和批量作业放置在机器中，但现有服务和作业仍可能正常工作。错误原因可以从事件详细信息字段中推断。
机器容量反映了每个维度的每台机器的规范化物理容量。每个维度（CPU 内核、RAM 大小）均独立正常化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41bde38ce6a39ea1e71018beaecb920b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee8c7db1951f47502f6252930f3a25a8/" rel="bookmark">
			c语言横纵坐标乘法,C语言  ·  猜算式  ·  乘法竖式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：猜算式
你一定还记得小学学习过的乘法计算过程，比如：
273
x 15
------
1365
273
------
4095
请你观察如下的乘法算式
***
x ***
--------
***
***
***
--------
*****
星号代表某位数字，注意这些星号中，0~9中的每个数字都恰好用了2次。 (如因字体而产生对齐问题，请参看图p1.jpg)
条件：每个数字要出现两次、公式要成立、结果是五位数。
请写出这个式子最终计算的结果，就是那个5位数是多少？
#include
#include
int jinwei(int i,int *f){
while(i&gt;){
if(f[i%]==){
return ;
}
f[i%]++;
i/=;
}
return ;
}
bool check(int i,int j,int a,int b,int c,int d){
int x[]={i/,(i/)%,i%,j/,(j/)%,j%,a/,(a/)%,a%,b/,(b/)%,b%,c/,(c/)%,c%,d/,(d/)%,(d/)%,(d/)%,d%};
int y[]={};
for(int h=;h
y[x[h]]++;
}
for(int h=;h
if(y[h]!=){
return false;
}else{
return true;
}
}
}
int main(){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee8c7db1951f47502f6252930f3a25a8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/312/">«</a>
	<span class="pagination__item pagination__item--current">313/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/314/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>