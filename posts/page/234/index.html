<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6356a4c05bedd13ea68e6f1c8fd00377/" rel="bookmark">
			VScode中无法使用转到定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 原先好用的Python 环境，也可以使用转到定义，但是现在无法使用转到定义
解决方案一 在文件夹中创建出.vscode的工作区配置文件夹
打开当前文件中.vscode\settings.json 路径是你要用的python的路径 { "python.pythonPath": "C:\\Users\\XXXX\\AppData\\Local\\Programs\\Python\\Python37-32\\python.exe", } 重启再次尝试使用
注意 1.文件夹不要设置为工作区或者加入到任何工作区。
解决方案二（该方案不一定OK） 安装Pylance 自动补齐和提示插件
重启后尝试。
综上，出现该问题原因如下 1.python的路径定位错误导致的，所以方案一就可以，一定需要重启。
2.方案二只是尝试方案，没有验证这两个那个是解决了，反正一起使用方案一方案二都解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/848822af48b20050c4aaf42df5e30c90/" rel="bookmark">
			EF Core CodeFirst 添加表字段表述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、通过Fluent API 来添加描述 使用HasComment实现
protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;User&gt;(a =&gt; a.Property("UserName").HasComment("用户姓名")); } 2、通过实体类中的Description属性实现 实体类代码示例
using System; using System.ComponentModel; using System.ComponentModel.DataAnnotations; using Cari.IBP.Platform.Utility.Models; using Cari.Disp.Context; namespace Cari.Disp.Entities { /// &lt;summary&gt; /// 年计划 /// &lt;/summary&gt; public class YearPlan: BaseEntity { /// &lt;summary&gt; /// 年度 /// &lt;/summary&gt; [Required] [MaxLength(50)] [Description("年度")] public string Year { get; set; } /// &lt;summary&gt; /// 原煤产量计划 /// &lt;/summary&gt; [Description("原煤产量计划")] public decimal? CoalOutput { get; set; } /// &lt;summary&gt; /// 进尺计划 /// &lt;/summary&gt; [Description("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/848822af48b20050c4aaf42df5e30c90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b206f726fb9b9bc7d68753a43dfcad2a/" rel="bookmark">
			JVM中的垃圾回收器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述垃圾回收器分类GC的性能指标HotSpot虚拟机中的垃圾收集器Serial 垃圾收集器（单线程）Serial Old 垃圾收集器（单线程）ParNew 垃圾收集器Parallel Scavenge 垃圾收集器Parallel Old垃圾收集器CMS垃圾收集器三色标记算法多标（又叫浮动垃圾）漏标（错杀）解决漏标（错杀）问题 G1（Garbage First）收集器 概述 如果说收集算法是内存回收的方法论，那么收集器就是内存回收的实践者。
垃圾收集器没有在Java虚拟机规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。
由于JDK的版本处于高速迭代的过程中，因此JAVA发展至今已经衍生了众多的GC版本。
从不同的角度来分析垃圾收集器，是可以将GC分为不同的类型。
垃圾回收器分类 按线程数分，可以分为串行垃圾回收器和并行垃圾回收器。 串行垃圾回收： 指的是在同一个时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。
并行垃圾回收： 是和串行垃圾回收相反的，并行运算可以拥有多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用“Stop The World”的机制。在回收的时候，需要暂停所有的线程。
按照工作模式分，可以分为并发式垃圾回收器和独占式回收器
并发式垃圾回收器： 与应用程序交替工作，以尽可能减少应用程序的停顿时间。
独占式垃圾回收器： 就是Stop - The - World。一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。
按照工作的内存区间，又可分为年轻代垃圾回收器和老年代垃圾回收器
年轻代垃圾回收器： 效率高，采用复制算法，但对内存的占用控制不精确，容易造成内存溢出。
老年代垃圾回收器： 效率低，在执行的时候，会STW，但一般启动次数少。
GC的性能指标 吞吐量：运行用户代码的时间栈总运行时间的比例。
（总运行时间：程序的运行时间+内存回收时间）
垃圾收集开销：垃圾收集所用时间与总运行时间的比例。
暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。
收集频率：相对于应用程序的执行，收集操作发生的频率。
内存占用：Java堆区所占的内存大小。
快速：一个对象从诞生到被回收所经历的时间。
HotSpot虚拟机中的垃圾收集器 因为HotSpot的虚拟机是现在主流的商用虚拟机，也是非常经典的一款虚拟机所以在这我就自己学了一下这款虚拟机的垃圾收集。
这些经典的收集器尽管已经算不上最先进的技术，但它们曾在实践中千锤百炼，足够成熟，基本上可认为是现在能够在商用生产环境中放心使用的全部垃圾收集器了。
各款经典收集器之间的关系如图。
如果两个收集器中间存在连线，就说明他们可以搭配使用。图中收集器所处的区域，则表示它是属于新生代收集器或者老年代收集器。
串行回收器：Serial，Serial old;
并行回收器：ParNew，Parallel scavenge，Parallel old;
并发回收器：CMS、G1;
新生代收集器：Serial，ParNew，Parallel scavenge；
老年代收集器：Serial old，Parallel old.cMS；
整堆收集器：G1；
虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来，虽然垃圾收集器的技术在不断进步，但是直到现在还没有最好的收集器出来，更加不存在“万能”的收集器，所以我们选择的只是对具体应用最合适的收集器。
如果有一种放之四海，任何场景都使用的完美收集器存在，那么HotSpot虚拟机就完全没有必要实现那么多种不同的收集器了。
在说收集器的时候，会接触到“并发”和“并行”
并行： （Parallel）描述的是多条垃圾收集器线程之间的关系。
说明同一时间有多条这样的线程协同工作，通常默认此时用户线程是处于等待状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b206f726fb9b9bc7d68753a43dfcad2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e57a7ec11ef77f1369d087f32a8d550/" rel="bookmark">
			vmware虚拟机开机黑屏的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天有一个项目需要用到OSX坯境，打开vmware,启动原来安装的 OSX10.11,结果启动后，无轮怎么操作就是黑屏，然后就百度了一下vmware黑屏的解决办法，尝试了一下问题解决，同时也把解决过程记录一下。
1、挂起的时候我们是能够见到显示，可是vmware虚拟机开机就出现黑屏，如图：
2、首先，我们在开始菜单里的搜索栏，搜索“CMD”，找到命令提示符，我们鼠标右键鼠标点击“命令提示符”，弹出对话框菜单栏之后，选择“以管理员身份运行”，如图：
3、在命令提示符对话框中键入“netsh winsock reset”，然后重启电脑就可以解决了，如图：
vmware虚拟机开机黑屏解决方法二：
同样，还是“以管理员身份运行”，在命令提示符对话框中依次执行这五个命令“netsh winsock reset、net stop VMAuthdService、net start VMAuthdService、net stop VMwareHostd、net start VMwareHostd”。
vmware虚拟机开机黑屏解决方法三：
如果还是不行的话，在VM-&gt;Settings-&gt;Hardware-&gt;Display在右面的内容栏中将Accelerate 3D graphics取消打勾之后，重启电脑就可以了
如有问题请留言反馈，若对您有帮助，请帮点个赞，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d2252bf5440378c03b8608a807d7716/" rel="bookmark">
			spring boot 使用 aop 记录日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.msxf.demo.aspect; import cn.hutool.core.collection.CollUtil; import cn.hutool.core.map.MapUtil; import cn.hutool.core.util.URLUtil; import cn.hutool.extra.servlet.ServletUtil; import cn.hutool.json.JSONArray; import cn.hutool.json.JSONObject; import com.msxf.demo.annotation.Log; import lombok.Data; import lombok.SneakyThrows; import lombok.extern.slf4j.Slf4j; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.springframework.stereotype.Component; import org.springframework.validation.BindingResult; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.springframework.web.multipart.MultipartFile; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.time.LocalDateTime; import java.util.*; import java.util.stream.Collectors; /** * 日志记录 * * @author: hzq * @date: 2022/6/2 */ @Slf4j @Aspect @Component public class LogAspect { @SneakyThrows @Around("@annotation(aLog)") public Object around(ProceedingJoinPoint joinPoint, Log aLog) { // todo 获取操作人信息 客户端id long start = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d2252bf5440378c03b8608a807d7716/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d8db72834e43be3630e8e64ea0fff5c/" rel="bookmark">
			Pico-实时预览工具PreviewTool
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装说明 Unity XR SDK与Preview Tool下载链接：SDK - Pico Developer Platform
1、下载Preview Tool后，将PreviewTool的APK先安装在VR头显里
2、在PC端打开Preview Tool.exe文件
二、步骤 1、项目中导入PicoSDK Window -&gt; Package Manager -&gt; Add package from disk，选择下载的pico sdk中的package.json（如下图），Open导入。
2、sdk配置 Edit -&gt; Project Settings，设置设备和安卓版本，如下：
3、场景中添加XR Rig 在Hierarchy面板中，也就是场景中右击，新建“XR Rig”对象（下图），XR Rig就是一体机对象，包含头显设备和两个手柄。
连接Pico一体机
先设置pico一体机为开发者模式：
设置 -&gt; 通用 -&gt; 关于本机，连续点几次“软件版本号”，就会出现“开发者”选项
打开“USB调试开关”，并设置“USB连接”为“传输文件”
用USB将一体机与PC连接
4、编译运行 5、难题：出现连接失败情况 解决方法
关闭所有防火墙即可连接成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e511d8edde6af54d173b18aaf75e530c/" rel="bookmark">
			多面体分析资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://zhuanlan.zhihu.com/p/310142893
PPCG
ISL
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d39783b439b948ea901ae5e9a8de3f5/" rel="bookmark">
			同一接口被多次请求，数据还未来得及入库导致数据不一致的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 有一个接口，使用了事务，而且会自建数据，但是只能允许自建一种类型的数据。如果请求分开来，一次结束后接着第二次，那么就会如期只自建一个。但如果请求同时发起，同一种类型的就会出现多条自建数据。
原因： 在因为有个事务的原因，事务会完成之后再写入到数据库。这时候如果当前事务还没完成的时候，就进行第二次请求，就会导致查数据库的时候没有自建数据，然后这次请求也进行了自建，这样就导致了只允许自建一次的数据自建了两次。
解决方案： 开发中经常会遇到这种问题，主要核心在事务身上。事务注解里面有个值可以设定事务隔离级别，将事务隔离级别设为可以读取其他事务未提交的数据 就行了。
isolation : 事务的隔离级别 ： Isolation.DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION.READ_COMMITTED（读已提交）。但是MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。
TransactionDefinition.Isolation.READ_UNCOMMITTED(读取未提交)：
该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。
TransactionDefinition.Isolation.READ_COMMITTED(读取已提交)：
该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。
TransactionDefinition.Isolation.REPEATABLE_READ(可重复读)：
该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。
TransactionDefinition.Isolation.SERIALIZABLE(可串行化)：最高的隔离级别，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。
此时我就是设置的可读取未提及的数据
就解决了这个问题。
事务注解中还有其他的注释，下来可以看看，只是这个问题只需要用到这个注释而已。
但写到这时候我又发现个问题：如果读取其他事务未提交的数据时候，这边进行判断默认为已创建，但是之前那个请求发生了异常，这时候数据并没有提交，而第二次请求又是默认它提交了，这个时候就会出现bug。
这时候就有一个其他的注释了
Propagation : 事务的传播行为 可以理解为当同时遇见两个事务的时的运行策略
默认值：Propagation.REQUIRED;如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
Propagation.REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。
Propagation.SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
Propagation.NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。
Propagation.NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。
Propagation.MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。
Propagation.NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；
这个注释就很很明确了，如果有一个事务在进行中，下面这个事务该怎么进行。
总结： 看样子最方便的是选择嵌套运行，但如果是多个请求，不同类型的数据同时请求进来呢，这时候这两个事务没有必然关系，如果第一个请求发生了错误，回退了，那么后面这个事务也会跟着回退。这就会导致这一个事务回滚了，所有这同一时间进行的事务都回滚。
如果选择当前事务挂起，等待前面事务运行结束后再进行当前事务，这看起来是最严谨的，但会牺牲一些程序的性能，可能导致程序速度较慢。
具体使用策略还得看具体业务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ed033af7d68e2ce19c50ffac86deedb/" rel="bookmark">
			使jieba用户词典支持空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将原始jieba字典中的空格更改为 @@　1.原来：雅不可攀 3 nr　2.现在：雅不可攀@@3@@nr 原始目字典在jieba包路径下，通常为...site-packages/jieba/dict.txt 将自定义用户词典加入的词与词性中间的空格更改为@@ 1.原来：牵连关系 50 n 2.现在：牵连关系@@50@@n 更改jieba根目录下的__init__.py文件下代码: 1.原来：re_userdict = re.compile('^(.+?)( [0-9]+)?( [a-z]+)?$', re.U) 2.现在：re_userdict = re.compile('^(.+?)(\u0040\u0040[0-9]+)?(\u0040\u0040[a-z]+)?$', re.U) 1.原来：re_han_default = re.compile("([\u4E00-\u9FD5a-zA-Z0-9+#&amp;\._%]+)", re.U) 2.现在：re_han_default = re.compile("(.+)", re.U) 1.原来：word, freq = line.split(' ')[:2] 2.现在：word, freq = line.split('\u0040\u0040')[:2] 1.原来：self.user_word_tag_tab[word] = tag 2.现在：self.user_word_tag_tab[word] = tag.replace('\u0040\u0040', '') 1.在 word, freq, tag = re_userdict.match(line).groups() if freq is not None: 下加入一行代码 2.freq = freq.replace('\u0040\u0040', '') 更改jieba根目录下posseg文件下的__init__.py下代码： 1.原来：re_han_internal = re.compile("([\u4E00-\u9FD5a-zA-Z0-9+#&amp;\._]+)") 2.现在：re_han_internal = re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ed033af7d68e2ce19c50ffac86deedb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ed7c8e3c9a18eb24d0dcc5e9e5e3e00/" rel="bookmark">
			unigui是什么？能用来干什么？一篇文章让你全面了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多初次接触unigui的delphier都不太明白他的特点，能干些什么，这里就自己的经验，做个记录，分享给大家。
1、unigui和以前的vcl有啥不一样。
本质上就是一个网页形式，前端展示仍然是html/css/js这些东西，基于业内大名鼎鼎的Extjs做为前端核心。
开发方式符合delphi的使用习惯，可以拖放控件，双击事件写入delphi代码来实现业务和数据存储。unigui会自动将delphi业务代码转换成网页形式展现给用户端。
2、数据库类型使用没有什么限制。
目前不可视控件都可以使用，VCL能用的，unigui一样能用。各种数据连接组件可以直接使用，ado控件也是支持的，只需要在前端展现时，使用unigui的数据组件。比如：vcl显示表格用的是DBGrid组件，在unigui中则需要用UniDBGrid组件，其他属性一样设置。
3、支持什么方式布署。
支持windows系统的exe和系统服务形式， IIS的dll方式；以及Liunx系统apache\Nginx下布署。
4、实用性怎么样，可以用来做项目吗。
目前出现已超过10年，已有相当多的delphier已经在大量的项目中实践过了。是delphi用来做B/S后台或管理系统的最佳选择之一。
5、哪些项目不适合用unigui来做。
（1）高并发产品，指日访问量超过1万+；对服务器性能消耗高；
（2）网站、to c、对用户界面个性化要求高的产品，不适宜用unigui，因为前端封装较多，修改样式比较复杂；同时初次加载文件多，打开较慢。
6、性能怎么样。
目前就官方论坛和用户反馈，能满足绝对大部分要求；并且支持服务器集群。
7、用户端怎么打开。
用户端访问的是一个网址，所以只要是浏览器就能打开。微信、电脑、苹果手机、安卓手机、平板都能打开。
8、打开速度慢怎么办。
第一次打开，系统需要下载约2M左右的库文件，后面就会直接在浏览器缓存里面加载，速度会按秒的速度打开。
要想进一步提升速度，可以使用cdn加速；或者提升服务器的带宽。
9、默认样式不符合要求，可以定制吗？
前端是可以自己定制的，需要具备一定的css/html/js知识，理论上可以修改成任意样式，包括商城、网站等等。
10、unigui的移动控件和fmx做的app有啥区别？
界面部分可以都做到相似。
在功能上：
unigui做的移动app本质还是一个h5的手机网页，对硬件上的功能支持有限；但直接支持跨平台，用浏览器就能访问，兼容性更好。
fmx做的app，可以支持更多硬件方面的操作，比如：震动、指纹识别、陀螺仪等；但是跨平台复杂，比如苹果还需要上应用市场发布才能下载。
11、学习成本高吗？怎么快速入门？
由于开发方式和delphi一样，门槛还是很低的。
安装包目录下有demos文件夹，对各个控件都有使用范例，可以直接参考和复制使用。
12、可以用来做微信小程序吗？
不可以。因为小程序的前端并不是H5，而是微信自己封装的前端代码。unigui只能用来做微信小程序的后端接口或消息推送。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f96029809cb849e27e217e9c3f7b326d/" rel="bookmark">
			feignClient Autowired失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因： 大概率是包没有扫到，启动类@EnableFeignClients注解没有加扫包路径。
解决： @EnableFeignClients(basePackages = { "com.xxx.feignClient.*" }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6f42d27379d8f541b38be9ed5a66dba/" rel="bookmark">
			前端开发常用的几种编辑器,你了解多少?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.VS Code
一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代Web和云应用的跨平台源代码编辑器。
2.HBuilder
一款支持HTML5的Web开发IDE。 [1] HBuilder的编写用到了Java、C、Web和Ruby。
3.Sublime Text
一个先进的代码编辑器，支持多种编程语言，同时支持Windows、Linux、Mac OS X等操作系统。
4.WebStorm
一款超级强大的JavaScript开发工具，被广大中国JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”，继承了IntelliJ IDEA强大的JS部分的功能。
5.Atom
专门为程序员推出的一个跨平台文本编辑器，支持CSS，HTML，JavaScript等网页编程语言。
6.Codepen
完全免费的前端代码托管服务，可以用来制作和测试页面的网站，在这里编辑前端代码可以实时预览。
7.Brackets
是一款开源的轻量级的可视化网页编辑器，它没有很多的视图或者面板，也没太多花哨的功能，它的核心目标是减少在开发过程中那些效率低下的重复性工作。
8.RunJs
一款专为JavaScript打造的代码编辑工具，拥有实时预览、高亮显示、代码格式化等功能，支持多种登录方式。
9.Adobe Dreamweaver
集网页制作和管理网站于一身的所见即所得网页代码编辑器，借助经过简化的智能编码引擎，轻松地创建、编码和管理动态网站。
10.wangEditor
一款开源 Web 富文本编辑器，开箱即用，配置简单，它兼容常见的 PC 浏览器：Chrome，Firefox，Safar，Edge，QQ 浏览器，IE11
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/070368ffc5df098470a1a60eceb7101d/" rel="bookmark">
			TextBox焦点事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计器里没得焦点事件，那就自己写呗
先写下面的四个事件， 分别对应两个TextBox的得到焦点事件和失去焦点事件
private void AccountInputTextBox_GotFocus(object sender, EventArgs e) { if (AccountInputTextBox.Text == "请输入您的账号") { AccountInputTextBox.Text = ""; AccountInputTextBox.ForeColor = Color.Black; } } private void AccountInputTextBox_LostFocus(object sender, EventArgs e) { if (AccountInputTextBox.Text == "") { AccountInputTextBox.Text = "请输入您的账号"; AccountInputTextBox.ForeColor = Color.Silver; } } private void PasswordInputTextBox_GotFocus(object sender, EventArgs e) { if (PasswordInputTextBox.Text == "请输入您的密码") { PasswordInputTextBox.Text = ""; PasswordInputTextBox.PasswordChar = '*'; PasswordInputTextBox.ForeColor = Color.Black; } } private void PasswordInputTextBox_LostFocus(object sender, EventArgs e) { if (PasswordInputTextBox.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/070368ffc5df098470a1a60eceb7101d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b118f5ada8efb979eece0b93507176c/" rel="bookmark">
			【notepad&#43;&#43;】notepad&#43;&#43;一键编译运行C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【notepad++】notepad++一键编译运行C语言 第一步：写入c代码 #include&lt;stdio.h&gt; int main() {	printf("hello world"); return 0;	} 第二步：按F5运行进行宏定义 cmd /k gcc -o "$(CURRENT_DIRECTORY)\$(NAME_PART).exe" "$(FULL_CURRENT_PATH)" &amp;&amp; CLS &amp;&amp; "$(CURRENT_DIRECTORY)\$(NAME_PART).exe" &amp; PAUSE &amp; EXIT 按下回车即可出结果选择保存后可以选择一个快捷键，下次直接按下快捷键即可完美运行！ 第三步：完美运行 补充 编译： cmd /k gcc -Wall -o "$(CURRENT_DIRECTORY)\$(NAME_PART).exe" "$(FULL_CURRENT_PATH)" &amp; PAUSE &amp; EXIT 运行： cmd /k "$(CURRENT_DIRECTORY)\$(NAME_PART).exe" &amp; PAUSE &amp; EXIT 关于脚本行：cmd /k gcc -o "$(CURRENT_DIRECTORY)\$(NAME_PART).exe" "$(FULL_CURRENT_PATH)" &amp;&amp; CLS &amp;&amp; "$(CURRENT_DIRECTORY)\$(NAME_PART).exe" &amp; PAUSE &amp; EXIT
cmd /k是弹出cmd窗口并执行后续指令。&amp;和&amp;&amp;表示连接作用，说明有多行指令合为一行。
gcc -o “ ( C U R R E N T D I R E C T O R Y ) (CURRENT_DIRECTORY) (CURRENTD​IRECTORY)(NAME_PART).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b118f5ada8efb979eece0b93507176c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/939bc15b9a402f8045063589517fbc20/" rel="bookmark">
			CentOS 8 安装screen
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 8安装不上screen，以为是yum源的问题，搞了半天才发现，要在CentOS 8上安装screen，先要安装EPEL库才可以。
[root@centoss8 yum.repos.d]#yum -y install screen
Last metadata expiration check: 0:00:17 ago on Thu 02 Jun 2022 01:09:34 AM CST.
No match for argument: screen
Error: Unable to find a match: screen
[root@centoss8 yum.repos.d]#yum -y install epel-release
....
[root@centoss8 yum.repos.d]#yum -y install screen
....
[root@centoss8 yum.repos.d]#rpm -qi screen
Name : screen
Version : 4.6.2
Release : 12.el8
Architecture: x86_64
Install Date: Thu 02 Jun 2022 01:17:06 AM CST
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/939bc15b9a402f8045063589517fbc20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a340888a1bd0f1b1e2dc1cf5cfc4a28/" rel="bookmark">
			解决应用matplotlib画图中存在的中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import matplotlib.pyplot as plt import numpy as np X = np.linspace(1,20,50) def func(x): return x**2+2*x+2 y = func(X) plt.plot(X,y,label='二次函数图像') plt.legend(loc='best') 一，用以上画出的图片，会出现如下的结果，可以看出会出现中文乱码的问题
解决方法：在代码中设置如下的代码
plt.rcParams['font.family'] = 'SimHei' 如上图所示就可以得到解决中文乱码问题。
解决方法二：找到电脑中自带的字体，进行相应的设置，代码如下
import matplotlib.pyplot as plt from matplotlib import font_manager ff = font_manager.FontManager() [i.name for i in ff.ttflist] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67d42da80801df2b38da78c23418e6fa/" rel="bookmark">
			新华三用户与权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华三的设备里面有很多角色，我们创建一个用户的时候，都会将该用户与某个权限互相绑定，于是这个用户就具有角色拥有的权限。默认创建的用户的角色是network-operator
上面是缺省的一些角色，当然你也可以通过 role name xxx 的方式去创建角色，但是这种授权有点麻烦。但是一般来说缺省的也是足够使用的，如果想要啥都能操控就将该用户设置为network-admin,如果是仅仅限于display那么就将该用户设置为level-1的等级或者设置角色为network-operator。
如果要自己设置权限也不是不可以，但是确实有些麻烦
关于用户权限管理的几个主要命令 local-user xxx class [ manage | network ] //创建新用户并设置它的默认角色是admin还是operator，如果是manage那么就是admin角色，如果是network那么就是operator角色
password [ simple | cipher ] xxx //设置用户的密码
authorization-attribute user-role xxx //为用户赋予新的角色
service-type xxx //设置用户的服务类型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/668a6ae7127f66b3cb1ff9a41617d97b/" rel="bookmark">
			selenium headless
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 系列文章目录 selenium
selenium headless 系列文章目录前言一、selenium headless参考 前言 selenium headless 不打开浏览器界面
一、selenium headless macos from optparse import Option from selenium import webdriver from selenium.webdriver.chrome.options import Options chrome_options = Options() chrome_options.add_argument('--headless') chrome_options.add_argument('--disable-gpu') chrome_options.binary_location = '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome' browser = webdriver.Chrome(options=chrome_options) url = 'https://www.baidu.com/' browser.get(url) browser.save_screenshot('baidu.png') 参考 尚硅谷Python爬虫教程小白零基础速通（含python基础+爬虫案例）Web Scraping with Selenium and Headless Chrome on macOS 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb369695cd5ca2e924db97758d028f03/" rel="bookmark">
			安装yum（Ubuntu中的安装，带讲解，以及源的更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【2021 04 25 更新】大家可以多留意一下评论区哈，感觉评论区说的干货比这篇文章多（笑哭），这篇文章是大学那会儿随手记的，没想到浏览的人还挺多，如果评论区有解决自己的问题，请将该评论点个赞哦~感谢
【2020 09 24 更新】由于此文章写的时间很长了，现在Ubuntu版本都更新了很多次，如果您的版本不是完全和我一样，建议去看看别的文章，但本文提出的更新源的问题可以作为一个idea，以此为突破口查找解决办法。
此外，关于安装这件事，大家也可以参考一下我新写的这篇文章《CSDN一群沙雕只说$ sudo apt-get upgrade $ sudo apt-get update解决包损坏问题》，如果对您有用的话将是我的荣幸
Ubuntu中yum的安装 先放上我这只菜鸟的绝望，在网上找了好久都搞不定。那些文章都不带人思考，一路给一堆命令，然而都搞不定，白瞎了（或者说我实在太菜）
冷静，calm down（重要的一步） 我们来分析一下，这边说的是在软件包里面无法定位yum，问题是什么？怎么解决直接的问题呢？
right！直接的解决方法就是去更新软件包！而那种去找各种代码来安装yum的，只要源一修改，什么软件没有？!
问题的转化 好，接下来问题就转化为：如何寻找镜像源。
（@20220601 清华源好像不能用了，我在文章里也放了阿里源、中科大源和163源，可以用那些源换一下，而不用清华源）
国内一个好的镜像源是清华做的，这个是网址：https://mirrors.tuna.tsinghua.edu.cn/
找到Ubuntu，点击它旁边的问号，重要，点问号！
进去之后就会发现你想要的源了（注意修改Ubuntu的版本，选择你自己的版本）
阿里源：
#添加阿里源 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 中科大源：
#中科大源 deb https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb369695cd5ca2e924db97758d028f03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aee92a94c22bee3645fc6c4c300c4198/" rel="bookmark">
			软件工程与项目管理——期末复习。主编肖汉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年5月30日考完。按照肖汉博士给的重点去背是没有问题的，也花不了很长时间。今年出的还容易了一些，因为时间太紧张啦。
因果分析图可以看网上的例子，考了红茶绿茶
类图是课件版例一升级版
简答题有类结构当时懵了，选择判断我太菜了，有几个写的有点犹豫。比如动态模型图我都记串了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d258d01e6bd635fbec6e78557cc2481/" rel="bookmark">
			【MATLAB笔记】绘制图中图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.创建数据
2.设置坐标范围在（0.12,0.12），宽和高均为0.8
3.绘制主图
4.在同一图上设置第二组坐标 5.在同一图上设置第三组坐标
6.Matlab代码
7.显示结果
1.创建数据 t=linspace(0,2*pi);%返回包含 0 和 2*pi 之间的 100 个等间距点的行向量。
t(1)=eps;%t(1)为非零最小值
y=sin(t);
2.设置坐标范围在（0.12,0.12），宽和高均为0.8 figure
handaxes1 = axes('Position',[0.12 0.12 0.8 0.8]);
3.绘制主图 plot(t,y)
set(handaxes1,'Box','off')
xlabel('t')
ylabel('sin(t)')
4.在同一图上设置第二组坐标 handaxes2 = axes('Position',[0.6 0.6 0.2 0.2]);
fill(t,y.^2,'y')
set(handaxes2,'Box','off')
xlabel('t')
ylabel('sin^2(t)')
5.在同一图上设置第三组坐标 handaxes3 = axes('Position',[0.25 0.25 0.2 0.2]);
plot(t,y.^3)
set(handaxes3,'Box','off')
xlabel('t')
ylabel('sin^3(t)')
6.Matlab代码 %绘制图中图 %1.创建数据 t=linspace(0,2*pi);%返回包含 0 和 2*pi 之间的 100 个等间距点的行向量。 t(1)=eps;%t(1)为非零最小值 y=sin(t); %2.设置坐标范围在（0.12,0.12），宽和高均为0.8 figure handaxes1 = axes('Position',[0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d258d01e6bd635fbec6e78557cc2481/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de8020f2497922c22955aa3c973a1799/" rel="bookmark">
			如何开发一个系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、流程二、需求分析1、调研2、画图 三、系统设计1、架构2、模块设计3、画图 四、系统开发1、开发2、协作3、测试 总结体会 前言 作为一名大二学生，参加校内比赛做了一个绩效管理系统，所以写一下如何开发一个系统。
一、流程 制作一个系统有三步，首先进行需求分析，其次进行系统设计，最后进行系统开发。
前面的步骤做好以后，系统开发和进度规划方面就有了参考，不会在开发过程中感到迷茫。
二、需求分析 只有准确了解了用户需求，才能设计出一个实用的系统。
如果只是让系统成为技术的载体，这个系统是称不上一个作品的，一定要完成某些能够称之为需求的任务，并且是准确完成用户需求才好。
1、调研 做一个简单的系统，可以直接询问你的用户，想要让系统完成什么事情。比如想做一个社区，为了让某个群体有交流的平台，再细致一点，想要交流得更舒适，喜欢用语音、图片交流或者日志等。
也可以在网上搜索，通过对比，补全、优化想要的需求。
还可以通过实际考察和数据平台上调研的方式获取最贴近实际的需求，找出当前这个用户群体最缺乏什么，比如互联网+刚兴起时，很多传统的企业都需要摆脱复杂的纸质记账，或者只能在本地设备使用的系统，需要一个随处可以登录、并且操作简单、数据安全、处理高效的财务管理系统。
需求调研，甚至是为了让系统做得更好而去做竞品分析，这在做产品方面，有更加成熟的模式进行参考。
如：如何做需求调研
2、画图 我们可以利用画图工具，抽象出用户的需求
例如，系统要被不同的人使用，登录后有普通用户和管理员。普通用户的需求就是修改自己的账户信息，查看自己的一些排名，而管理员的需求除了修改信息还要管理排名数据库、账户数据库。
管理员 登录 修改账户信息 管理数据库 普通用户 登录 修改账户信息 查看排名 三、系统设计 根据分析得到的系统需求，我们要进行系统架构的设计和功能模块的设计。
1、架构 一个简单的系统一般具有界面和数据库两个部分架构，也就是开发中常提到的前端和后端。
当前业界常见的架构设计
除此之外，系统部署在网络上，还是本地，这也叫做架构。
从前有C/S模式(Client/Server，客户/服务器模式)，现在基本都是B/S模式(Browser/Server，浏览器/服务器模式)了
C/S和B/S模式
2、模块设计 一个系统不可避免的具有许多模块，他们之间有的互相独立，有的相互联系，而每个模块又有自己许多的功能和事件等，这一步仍然需要依靠需求部分的结果来设计相应的模块。
3、画图 我们仍需将架构和模块设计画成实体图或者根据需要画出流程图、时序图、类图等，对于一个系统来说，功能模块间如何互相作用，以及作用的顺序也是需要详细设计的，同样，这个部分也要画图。画图有利于直观的理解和程序开发。
现在有各种画图工具通过点击、拖拽图形就能够画好图，这里不做推荐。作者喜欢使用输入文本生成图片的工具，比如Typroa支持的mermaid工具，进行画图，“a((圆形))–&gt;b[矩形]”可以生成下面这样的图片
圆形 矩形 四、系统开发 1、开发 按照前面的设计开发系统，这时候主要是代码怎么实现逻辑和界面布局的设计了，具有一定的专业性
2、协作 开发一个系统可能会遇到多个人协作的情况。
简单一点的协同工具可以使用SVN，适合小组内有程序功底不强的成员，理解和学习能力较强建议使用git。
3、测试 开发一个系统，难免会有需求考虑不周到、需求没有完全完成、代码逻辑有漏洞等情况发生，所以我们需要测试，对每一个函数编程时需要测试，对每一个功能、模块开发时需要测试，最后，整个系统是否完善等等也需要测试。
软件测试方法
总结 本文仅仅简单介绍了如何开发一个系统，提供了一个思路和一些参考，可实际操作部分很少，实际开发还需要对各部分进行深入了解和学习。
第一篇博客，多有不足，欢迎指正。
体会 比赛体会：由于作者参加的比赛是创新创业作品设计大赛，在比赛最后评委老师说有的选手没有做到创新，这一点让我印象深刻。
关于创新：有的作品说自己的创新点在于，用上了B/S架构，但是B/S模式早就已经流行；有的作品里有很多新兴的技术，比如做出来一个大数据分析平台，上面有很多花哨的可视化数据…但其实，包括作者在内，很多作品都没有做到创新，只是学习了自己没有学过的技术，或者用上了没有用过的技术。真正的创新一定是要对当下的市场或者说行业做调研，有足够多的信息对比、数据支撑下，才能有自己的想法，做出创新。不一定是用最新的技术，创新也不是只比谁学习能力强，短期内谁先掌握某种技术谁就获胜。
开发收获：开发过程中还涉及到了时间管理、资料查找、团队协作、文档写作、答辩等方面的锻炼，作者确实体会到了以赛促学，用项目带动自己技术提升的好处，有可能会另写博客介绍这些方面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/867a3138c70cdadb64e0f31c82438799/" rel="bookmark">
			【C语言】字符串读入没有警告越界的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现问题 用C语言实现输入9个字符，判断出多少个字符大写，多少字符小写的程序。但是当输入多个字符后，程序正常运行，没有出现数组越界的情况。
原因 我们知道scanf()函数接收到回车才停止输入，字符串则是接收到空格、回车时才加上'\0'结束字符串的存入。
在这里scanf()函数只管检查数据流是否结束，不会计算字符串长度是否符合设置好的长度，字符串数组又是以数组名作为指针，将整个串连续的存在指针指向的连续地址，所以输出和计算串时只根据'\0'的位置处理。这样会导致数组越界，占用其他可能的内存空间，应该避免。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d5d57e387374dd82fa968c13e90a751/" rel="bookmark">
			Rust Rc&#43;RefCell详解，实现二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		error[E0507]: cannot move out of dereference of Ref＜‘_, xxx::TreeNode＞
rust编程中出现这个编译报错问题，大概率是因为Rc/RefCell使用不正确。
希望通过本节的分享能够帮助读者学会在rust单一所有权机制下，正确使用Rc/RefCell来表达一颗二叉树。
文章目录 Rc(Reference Counted)外部可变性RefCell和内部可变性rust表达二叉树引用方式Rc+RefCell 二叉树的中序遍历力扣题目 Rc(Reference Counted) Rc(Reference Counted)：是Rust标准库中，用于处理引用计数的智能指针。用来突破单一所有权的限制。其基本操作是通过clone()增加引用计数。
// Reference Counted Rc会把对应的数据结构创建在堆上 // 堆上的数据才适合被用来在多个函数调用栈帧中共享 let i1 = Rc::new(1); // 复制引用计数 let i2 = i1.clone(); let i3 = i1.clone(); // 现在引用计数值为3 println!("{}", Rc::strong_count(&amp;i1)); //3 println!("{}", Rc::strong_count(&amp;i2)); //3 println!("{}", Rc::strong_count(&amp;i3)); //3 外部可变性 简单来说，mut关键字注明的可修改性就是外部可变性。
我们前面学习了，Rust中提供了两种引用/借用类型：
&amp;：只读引用，只读引用不允许修改被引用的对象。
&amp;mut：可变引用，可变引用才有修改权限。
在编译阶段，Rust会检查，同一作用域内，对于某一个对象的引用，只允许存在两种情况：
要么只有一个活跃的可变引用，要么同时存在多个只读引用。
RefCell和内部可变性 RefCell，提供内部包装类型的内部可变性，用来突破mut变量才能被修改（外部可变性）的限制。
//Rc是线程内部以只读的方式共享数据 //RefCell提供内部可变性 let cell = RefCell::new(10); {// 运行时会检查借用规则，所以这里必须加大括号 // 将可写借用跟后面的只读借用隔离开来 let mut mut_ref = cell.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d5d57e387374dd82fa968c13e90a751/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b64a9f4f9e4cd6f595bdf4e9d5b38e68/" rel="bookmark">
			TCP/IP协议抓包分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、TCP/IP协议在协议中分层的位置
二、TCP三次握手流程
三、打开wireshark抓包
四、TCP三次握手分析
1、TCP第一次握手
五、四次挥手流程
六、四次挥手抓包分析
一、TCP/IP协议在协议中分层的位置 二、TCP三次握手流程 1、客户端向服务端发送⼀个SYN=1（请求建立连接），并生成一个序列号seq=j。
2、服务端接收到SYN=1后，给客户端发送⼀个SYN=1与ACK=1；并将ack置为j+1;同时生成一个序列号seq=k。
3、客户端接收到会检查ack是否为j+1与ACK是否为1，如果是，则会给服务端发送一个ACK=1与ack=k+1，以及自己的序列号seq=j=1; 服务端接收到会检查ACK是否为1与ack是否为k+1,如果是则代表连接建立成功，两者间可以传递数据。
三、打开wireshark抓包 本地IP：10.168.1.112
百度IP：39.156.66.18
筛选规则：tcp and ip.addr==10.168.1.112 and tcp.port==50830
封包详细信息用来查看协议中的每个字段，各行信息显示对应的不同层级，如下图所示，分别是物理层、数据链路层、网络层、传输层，如果有应用层数据会显示第五层
四、TCP三次握手分析 1、TCP第一次握手 客户端向服务端发送⼀个SYN=1（请求建立连接），并生成一个序列号seq=j（实验中j=0）
源端口50830 ----&gt;目标端口36688
2、服务端接收到SYN=1后，给客户端发送⼀个SYN=1与ACK=1；并将确认序列号ack置为j+1（即SYN+1=0+1=1）;同时生成一个序列号seq=k（实验中k=0）
3、客户端接收到会检查服务端回复的确认序列号ack是否为j+1（即SYN+1=0+1=1）与ACK是否为1，如果是，则会给服务端发送一个ACK=1与ack=k+1（即第二次握手时服务端生成的序列号seq，k+1=0+1=1），以及自己的序列号seq=j=1; 服务端接收到会检查ACK是否为1与ack是否为k+1,如果是则代表连接建立成功，两者间可以传递数据
4、也可直接通过标志位看三次握手的数据包
五、四次挥手流程 1、Client端发起中断连接请求，也就是发送FIN报文。意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。
2、Server端接到FIN报文后，发送ACK，告诉Client端，“你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。
3、当Server端确定数据已发送完成，则向Client端发送FIN报文，告诉Client端，”好了，我这边数据发完了，准备好关闭连接了"。
4、Client端收到FIN报文后，就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传
Server端收到ACK后，就知道可以断开连接了。
Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！
六、四次挥手抓包分析 抓包过程中，四次挥手只抓到了三个包的报文，查询了相关资料，说是因为服务器端在给客户端传回的过程中，将两个连续发送的包进行了合并。以下是基于抓到的三个包做的分析，如有错误请指正
1、第一次挥手：Client端发起中断连接请求，也就是发送FIN报文。意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据
将标志位FIN和ACK置为1，序号seq=306，确认序号ack=21
2、第二次挥手：Server端接到FIN报文后，发送ACK，告诉Client端，“你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文
此时，服务端回复客户端：FIN和ACK(标志位FIN=1,ACK=1)，确认序列号ack为收到的序列号（即第一次挥手携带的SYN）加1，即ack=306+1=301。序列号seq为收到的确认序列号21
（抓包时第二次挥手和第三次挥手合并了）
3、第四次挥手：Client端收到FIN报文后，就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传
客户端收到服务器发送的FIN之后，发回ACK确认(标志位ACK=1),确认序列号为收到的序号加1，即21+1=22。序列号为收到的确认序列号307
Server端收到ACK后，就知道可以断开连接了。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5fb8a85bfc1bb7b1b7171e6700fffe0/" rel="bookmark">
			Java异常：Throwable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述
1、Throwable接口 1）Error 类 2）Exception 类 编译期问题： 不是 RuntimeException 的异常必须进行处理的，因为你不处理，编译就不能通过。运行期问题： RuntimeException 异常这种问题我们也不处理，因为是你的问题，而且这个问题出现肯定是我们的代码不够严谨，需要修正代码的。 二、异常的处理： （一）异常的处理方式 1、JVM的默认处理：报错。 把异常的名称，原因，位置等信息输出在控制台，程序不能继续执行了。 2、自己处理 1）方式1： try...catch...finally ：自己编写处理代码，后面的程序可以继续执行 。spring事务中不可以继续执行，其默认只要是RuntimeException ,都会回滚。 2）方式2： throws ：把自己处理不了的，在方法上声明，告诉调用者，这里有问题。 3、面试题：编译期异常和运行期异常的区别? 编译期异常： 必须要处理的，否则编译不通过 运行期异常： 可以不处理，也可以处理 （二）处理详解 1、try...catch...finally 处理（实例） &lt;span style="font-size:18px;"&gt;&lt;span style="font-family:Arial;"&gt;	/* * 多个异常 * b:写一个try，多个catch * try{ * ... * }catch(异常类名 变量名) { * ... * } * catch(异常类名 变量名) { * ... * } * ... * * 注意事项： * 1:能明确的尽量明确，不要用大的来处理。 * 2:平级关系的异常谁前谁后无所谓，如果出现了子父关系，父必须在后面。 * * 注意： * 一旦try里面出了问题，就会在这里把问题给抛出去，然后和catch里面的问题进行匹配， * 一旦有匹配的，就执行catch里面的处理，然后结束了try.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5fb8a85bfc1bb7b1b7171e6700fffe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39d32695889c9613a6178a6bbd38c678/" rel="bookmark">
			集合详解（四）：Map
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Map （一）Map概述 1、Map集合：将键映射到值的对象。 1）一个映射不能包含重复的键； 2）每个键最多只能映射到一个值。 2、Map集合和Collection集合的区别 1）Map集合存储元素是成对出现的，Map集合的键是唯一的，值是可重复的。可以把这个理解为：夫妻对 。 2）Collection集合存储元素是单独出现的，Collection的儿子Set是唯一的，List是可重复的。可以把这个理解为：光棍(11.11) 3、注意： 1）Map集合的数据结构只针对键有效，跟值无关 ，HashMap，TreeMap。 2）Collection集合的数据结构是针对元素有效 。 （二）功能 1、添加功能 1）V put(K key,V value)：添加元素。这个其实还有另一个功能 如果键是第一次存储，就直接存储元素，返回null 如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值 2、删除功能 1）void clear()：移除所有的键值对元素 2）V remove(Object key)：根据键删除键值对元素，并把值返回 3、判断功能 （有意思） 1）boolean containsKey(Object key)：判断集合是否包含指定的键 2）boolean containsValue(Object value)：判断集合是否包含指定的值 3）boolean isEmpty()：判断集合是否为空 4、长度功能 int size()：返回集合中的键值对的对数 5、获取功能 1）基本方法： Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：遍历获取V get(Object key)：根据键获取值Set&lt;K&gt; keySet()：获取集合中所有键的集合Collection&lt;V&gt; values()：获取集合中所有值的集合 2）遍历Map的方法 方法1：先拿到所有的key，然后遍历获取所有的value keySet()get(Object key)方法2：先拿到所有的键值对，然后遍历，获取每一个键值对对象-Entry（推荐）。 entrySet()Map.Entry 3）图解 4）具体代码 &lt;span style="font-size:18px;"&gt;&lt;span style="font-family:Arial;font-size:18px;"&gt;	/* * Map集合的遍历。 * 方法1：先拿到所有的key，然后遍历获取所有的value * 方法2：先拿到所有的键值对，然后遍历，获取每一个键和值（推荐） * */ public void test3(){ // 创建集合对象 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // 创建元素并添加到集合 map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39d32695889c9613a6178a6bbd38c678/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd2bf6a3fdce3031e7aeb4973e4bd2ca/" rel="bookmark">
			集合详解（三）：Set
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述
1、无序，存储顺序和取出顺序不一致 2、不能重复，唯一 二、HashSet
（一）特点：
1、不保证 set 的迭代顺序，特别是它不保证该顺序恒久不变。 虽然Set集合的元素无序，但是，作为集合来说，它肯定有它自己的存储顺序， 而你的顺序恰好和它的存储顺序一致，这代表不了有序，你可以多存储一些数据，就能看到效果。 2、不能重复，唯一性。 3、HashSet底层是HashMap实现的，而数据结构为哈希表 （二）唯一性的分析：源码解析。 1）通过查看add()方法的源码，我们知道这个方法底层(其实是HashMap的put方法)依赖两个方法：hashCode()和equals()。 2）步骤： 先调用hashCode()方法，得出哈希值进行比较。如果不同，就直接添加到集合中 。如果相同，继续走，比较地址值（==）或者equals() 方法 返回true： 说明元素重复，就不添加返回false：说明元素不重复，就添加到集合 3）如果类没有重写这两个方法，默认使用Object()的，一般来说不会相同。 （三）唯一性内存图解 1、底层数据结构为哈希表 2、哈希表为一个元素为链表的数组，综合了数组与列表的好处。（新华字典） &lt;span style="font-size:18px;"&gt;package collection; public class Student implements Comparable&lt;Student&gt;{ // 成员变量 private String name; private int age; // 构造方法 public Student() { super(); } public Student(String name, int age) { super(); this.name = name; this.age = age; } // 成员方法 // getXxx()/setXxx() public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd2bf6a3fdce3031e7aeb4973e4bd2ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d07fee5a07222a0585e7a1d51baf25b0/" rel="bookmark">
			分类评价指标（二分类）——f1score sensitivity specificity roc曲线 auc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：此文章为记录学习历程，无参考价值。最近在学习分类（二分类）的时候，需要用到一些常用的分类指标，各大中文网站的的代码不仅看不懂，甚至还千篇一律，都不知道到底是谁抄的谁的，自己在一些英文网站看人家写的代码一点一点理解，总算是能弄出结果来了，故写此文章以记录
由于我也是新手，故关于理论的讲解请参考其他文章：
敏感性和特异性
roc曲线和auc，f1score等
(1)roc 曲线以及面积auc和f1score的实现
这三个方法的实现主要是用sklearn官方库里面的函数
f1_score, roc_curve, auc
建议去sklearn 官方查看示例官方roc_curve示例
from sklearn.metrics import roc_curve, f1_score, auc fp, tp, thresholes = roc_curve(all_labele, all_prescore) roc_auc = auc(fp, tp) f1score = f1_score(all_labele, all_pre) 此处，all_lable代表数据数据的标签，all_pre代表预测出来的标签，也就是经过torch.argmax(outputs.data, 1)操作提取出来的标签，all_prescore是结果softmax回归后关于每一类预测的得分，也就是操作torch.max(outputs.data, 1)[0]
然后画出roc曲线：
plt.plot(fp, tp, 'r', label='ROC curve (area = %0.2f)' % roc_auc) plt.legend(loc='lower right') plt.plot([0, 1], [0, 1], 'g') print(f'loss:{val_loss / len(val_loader):.4f}, acc:{correct / total}, auc:{roc_auc:.3f}, f1score:{f1score:.3f}') # plt.savefig('./result/1.png') plt.show() 下面给出完整的代码：
import numpy as np import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d07fee5a07222a0585e7a1d51baf25b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4a2913f28c0ec47354bf334eab4560d/" rel="bookmark">
			WKWebView 线程终止的原因——之 OOM 的控制逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在 WKWebView 中展示三维图像渲染的功能时，经常遇到 WKWebView 莫名其妙的 reload 的现象。
WKWebView 会在 APP 的进程外执行其所有的工作，并且 WKWebView 的内存使用量与 APP 的内存使用量分开计算。这样当 WKWebView 进程超出其内存限制时，就不会导致 APP 程序终止，最多也就是导致空白视图。
为了定位具体的原因，先查看一下 WKWebView 的代理提供的回调方法。在 WKNavigationDelegate 中定义了回调方法 webViewWebContentProcessDidTerminate(_)：
/** @abstract Invoked when the web view's web content process is terminated. @param webView The web view whose underlying web content process was terminated. */ @available(iOS 9.0, *) optional func webViewWebContentProcessDidTerminate(_ webView: WKWebView) 当 web 视图的内容进程终止时，将通过此回调通知 APP，然而并没有提供更多的错误信息。
可以通过 https://github.com/WebKit/WebKit 看到 WKWebView 的源码。通过搜索 webViewWebContentProcessDidTerminate的方法，可以一步步知道 WKWebView 的异常流程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4a2913f28c0ec47354bf334eab4560d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36ecee9306dfb3932013337effae5635/" rel="bookmark">
			Android:shareUserId知多少
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
shareUserId简介
shareUserId设置方法
shareUserId的作用之获取系统权限
shareUserId的作用之apk之间的数据访问
shareUserId简介 在学习shareUserId之前我们先了解一下Android App Sandbox(android沙箱机制)。在Linux中的Sandbox主要做隔离工作，将不同的任务或者用户间的耦合降到最低。Android应用也借用了Linux Sandbox技术，将不同的APP之间做客隔离，其主要表现就是资源和权限访问隔离。每个Android APP都运行在他们自己的Linux线程中（UID不同），每个应用程序彼此独立，默认情况下无法访问其他应用程序资源。APP权限机制为应用程序之间资源的互访提供了可能性，APP必须申请权限并经过用户的授权才能访问Android系统API或者其他服务。
通过Shared User id，拥有同一个User id的多个APK可以配置成运行在同一个进程中。所以默认就是可以互相访问任意数据。 也可以配置成运行成不同的进程，同时可以访问其他APK的数据目录下的数据库和文件，就像访问本程序的数据一样。
shareUserId设置方法 在需要共享资源的项目的每个AndroidMainfest.xml中添加shareuserId的标签。
android:sharedUserId="com.example.XX"
id名自由设置，但必须保证每个项目都使用了相同的sharedUserId。一个mainfest只能有一个Shareuserid标签。
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.shareusertesta" android:versionCode="1" android:versionName="1.0" android:sharedUserId="com.example"&gt; shareUserId的作用之获取系统权限 step1.在AndroidManifest.xml中添加android:sharedUserId = "android.uid.system"
step2.在Android.mk文件里面添加LOCAL_CERTIFICATE := platfrom(使用系统签名)
step3.在源码下面进行mm编译
这样生成的apk能够获取system权限，可以在任意system权限目录下进行目录或者文件的创建，以及访问其他apk资源等。常见的情景有：
Setting.apk 在manifest节点中增加android:sharedUserId = "android.uid.system"，然后再Android.mk中增加LOCAL_CERTIFICATE:= platfromLauncher.apk 在manifest节点中增加android:sharedUserId = "android.uid.shared"，然后再Android.mk中增加LOCAL_CERTIFICATE:= sharedGallery.apk 在manifest节点中增加android:sharedUserId="android.media"，然后在Android.mk中增加LOCAL_CERTIFICATE := media shareUserId的作用之apk之间的数据访问 在有些时候，我们自己开发了多个APK并且需要他们之间互相共享资源，那么就需要通过设置shareUserId来实现这一目的。下面看一下两个应用A和B如何进行数据访问。
step1.添加两个APP manifest.xml 文件中属性 android:sharedUserId，均设置为相同的值或名字(其实是设置成相同的UID)。
step2.两个 APP 要用相同的 private key 来签名
//A应用的代码，保存数据 private void writeData(Context context, String data) { FileOutputStream fileOutputStream = null; OutputStreamWriter outputStreamWriter = null; try { //文件保存在/data/data/com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36ecee9306dfb3932013337effae5635/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a65fee373b18b910138c37ed1740ade/" rel="bookmark">
			factorial函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		factorial() 是数学模块的库方法，用于查找给定数字的阶乘，它接受正整数并返回数字的阶乘。
import math r=math.factorial(5) 1.factorial()不可以被定义为负数
2.factorial() 可以定义为0或者正整数
3.factorial() 不可以被定义为浮点数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19adc6279c355bafd632741d7a9d57bc/" rel="bookmark">
			如何查看一个网页的请求头header信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何查看一个网页的请求头header信息 首先使用浏览器打开一个网页，然后按F12，然后点击右边的Network，并按下Ctrl + R，如下图所示：
在下面的文件栏里面找到以.cn/.com类型结尾的文件，点击，右边就会出现相应的内容，如下图所示：
这个时候就能在右边找到header等信息了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fe289a104bde01da79c7757486cbfe6/" rel="bookmark">
			java自定义异常并处理异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义异常： /** * 自定义异常 * * @author ruoyi */ @Data public final class MyException extends RuntimeException { private Integer status = ExceptionCode.SERVICEEXCEPTION.getCode(); public MyException() { } public MyException(ExceptionCode status,String message) { super(status.getCode()+"&amp;"+message); this.status = status.getCode(); } public MyException(Throwable cause) { super(cause); } public MyException(String message, Throwable cause) { super(message, cause); } public MyException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) { super(message, cause, enableSuppression, writableStackTrace); } } /** * 自定义异常状态 * * @author ruoyi */ public enum ExceptionCode { TOKENEXCEPTION(40000),//登录TOKEN异常 SERVICEEXCEPTION(41000),//业务异常（包括参数） AUTHEXCEPTION(42000);//权限异常 private final Integer code; ExceptionCode(Integer code) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fe289a104bde01da79c7757486cbfe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab2fb0c2a8e276d985e16b8713354815/" rel="bookmark">
			机器学习篇-逻辑回归的分类预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习篇-逻辑回归的分类预测 1 逻辑回归的介绍和应用 1.1 逻辑回归的介绍 逻辑回归（Logistic regression，简称LR）虽然其中带有"回归"两个字，但逻辑回归其实是一个分类模型，并且广泛应用于各个领域之中。虽然现在深度学习相对于这些传统方法更为火热，但实则这些传统方法由于其独特的优势依然广泛应用于各个领域中。
而对于逻辑回归而且，最为突出的两点就是其模型简单和模型的可解释性强。
逻辑回归模型的优劣势:
优点：实现简单，易于理解和实现；计算代价不高，速度很快，存储资源低；
缺点：容易欠拟合，分类精度可能不高
1.2 逻辑回归的应用 逻辑回归模型广泛用于各个领域，包括机器学习，大多数医学领域和社会科学。例如，最初由Boyd 等人开发的创伤和损伤严重度评分（TRISS）被广泛用于预测受伤患者的死亡率，使用逻辑回归 基于观察到的患者特征（年龄，性别，体重指数,各种血液检查的结果等）分析预测发生特定疾病（例如糖尿病，冠心病）的风险。逻辑回归模型也用于预测在给定的过程中，系统或产品的故障的可能性。还用于市场营销应用程序，例如预测客户购买产品或中止订购的倾向等。在经济学中它可以用来预测一个人选择进入劳动力市场的可能性，而商业应用则可以用来预测房主拖欠抵押贷款的可能性。条件随机字段是逻辑回归到顺序数据的扩展，用于自然语言处理。
逻辑回归模型现在同样是很多分类算法的基础组件,比如 分类任务中基于GBDT算法+LR逻辑回归实现的信用卡交易反欺诈，CTR(点击通过率)预估等，其好处在于输出值自然地落在0到1之间，并且有概率意义。模型清晰，有对应的概率学理论基础。它拟合出来的参数就代表了每一个特征(feature)对结果的影响。也是一个理解数据的好工具。但同时由于其本质上是一个线性的分类器，所以不能应对较为复杂的数据情况。很多时候我们也会拿逻辑回归模型去做一些任务尝试的基线（基础水平）。
说了这些逻辑回归的概念和应用，大家应该已经对其有所期待了吧，那么我们现在开始吧！！！
2 学习目标 了解 逻辑回归 的理论
掌握 逻辑回归 的 sklearn 函数调用使用并将其运用到鸢尾花数据集预测
3 代码流程 基于鸢尾花（iris）数据集的逻辑回归分类实践
Step1:库函数导入
Step2:数据读取/载入
Step3:数据信息简单查看
Step4:可视化描述
Step5:利用 逻辑回归模型 在二分类上 进行训练和预测
Step5:利用 逻辑回归模型 在三分类(多分类)上 进行训练和预测
4 基于鸢尾花（iris）数据集的逻辑回归分类实践 在实践的最开始，我们首先需要导入一些基础的函数库包括：numpy （Python进行科学计算的基础软件包），pandas（pandas是一种快速，强大，灵活且易于使用的开源数据分析和处理工具），matplotlib和seaborn绘图。
Step1： 库函数的导入 ## 基础函数库 import numpy as np import pandas as pd ## 绘图函数库 import matplotlib.pyplot as plt import seaborn as sns 本次我们选择鸢花数据（iris）进行方法的尝试训练，该数据集一共包含5个变量，其中4个特征变量，1个目标分类变量。共有150个样本，目标变量为 花的类别 其都属于鸢尾属下的三个亚属，分别是山鸢尾 (Iris-setosa)，变色鸢尾(Iris-versicolor)和维吉尼亚鸢尾(Iris-virginica)。包含的三种鸢尾花的四个特征，分别是花萼长度(cm)、花萼宽度(cm)、花瓣长度(cm)、花瓣宽度(cm)，这些形态特征在过去被用来识别物种。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab2fb0c2a8e276d985e16b8713354815/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0da5275234b87e8fdd60f5cf2d04836d/" rel="bookmark">
			springboot启动报错The Bean Validation API is on the classpath but no implementation could be found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springBoot启动报错
Description: The Bean Validation API is on the classpath but no implementation could be found Action: Add an implementation, such as Hibernate Validator, to the classpath 2022-05-31 09:12:33.145 WARN 12516 --- [ Thread-5] c.a.n.common.http.HttpClientBeanHolder : [HttpClientBeanHolder] Start destroying common HttpClient 上一次启动还好好的，这次就报错了？
添加依赖解决
&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.3.0.Final&lt;/version&gt; &lt;/dependency&gt; 然后成功启动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faf0e6a77cff3a10fbaf0167b5146710/" rel="bookmark">
			单链表的初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 链表的节点2. 头节点，头指针和首元节点3. 链表的创建 1. 链表的节点 链表存储的数据元素，其物理存储位置是随机的。链表给每个数据元素都配备一个指针，用于指向自己的直接后继元素，来表示数据之间逻辑关系
链表中每个数据的存储都由以下两部分组成：
数据元素本身，其所在的区域称为数据域指向直接后继元素的指针，所在的区域称为指针域； 即链表中各节点的结构如图所示：
链表实际存储的是一个一个的节点，真正的数据元素包含在这些节点中：
链表中每个节点的具体实现，需要使用 C 语言中的结构体，具体实现代码为：
typedef struct node { char elem; //代表数据域 struct node *next; //代表指针域，指向直接后继元素 }Node; //Node为节点名，每个节点都是一个 Node 结构体 2. 头节点，头指针和首元节点 头指针：一个普通的指针，它的特点是永远指向链表第一个节点的位置。很明显，头指针用于指明链表的位置，便于后期找到链表并使用表中的数据头节点：其实就是一个不存任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，它的作用只是为了方便解决某些实际问题；首元节点：由于头节点（也就是空节点）的缘故，链表中称第一个存有数据的节点为首元节点。首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义； 因此，一个存储 {1,2,3} 的完整链表结构如下图所示：
3. 链表的创建 创建一个链表需要做如下工作：
声明一个头指针（如果有必要，可以声明一个头节点）；创建多个存储数据的节点，在创建的过程中，要随时与其前驱节点建立逻辑关系； 例如，创建一个存储 {1,2,3,4} 且无头节点的链表，C 语言实现代码如下：
Node *InitLink() { Node *P = NULL; //创建头指针 Node *temp = (Node*)malloc(sizeof(Node)); //创建首元节点 //首元节点先初始化 temp-&gt;elem = 1; temp-&gt;next = NULL; p = temp; //头指针指向首元节点 //从第二个节点开始创建 for(int i = 2; i &lt; 5; i++) { //创建一个新节点并初始化 Node *a = (Node*)malloc(sizeof(Node)); a-&gt;elem = i; a-&gt;next = NULL; //将temp节点与新建立的a节点建立逻辑关系 temp-&gt;next = a; //指针temp每次都指向新链表的最后一个节点，其实就是 a节点，这里写temp=a也对 temp = temp-&gt;next; } //返回建立的节点，只返回头指针 p即可，通过头指针即可找到整个链表 return p; } 如果想创建一个存储{1,2,3,4}且含头节点的链表，则 C 语言实现代码为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faf0e6a77cff3a10fbaf0167b5146710/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14772f3d79887df807c1347fd8539f89/" rel="bookmark">
			RabbitMQ入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MQ的基本概念
1、MQ的概述
2、MQ的优势
应用解耦
异步提速
削峰填谷
3、MQ的劣势
系统可用性降低
系统复杂度提高
一致性问题
4、MQ的使用条件
5、常见的MQ的产品
二、什么是RabbitMQ
1、RabbitMQ概念
Broker（服务端）
Virtual host（虚拟机）
Connection（连接）
Channel（管道）
Exchange（交换机）
Queue（队列）
Binding（）
2、AMQP
3、JMS
三、RabbitMQ的工作模式（简述）
1、简单模式
2、work queues
3、Publish/Subscribe 发布与订阅模式
4、Routing 路由模式
5、Topics 主题模式
6、RPC 远程调用模式（远程调用，不太算MQ；暂不作介绍）
一、MQ的基本概念 1、MQ的概述 MQ全称Message Queue（消息队列），是在消息的传输过程中保存消息的容器。多用于分布式系统之间进行通信。
在没有RabbitMQ之前，我们通常是使用远程调用的方式建立两者的通信。
有了RabbitMQ之后，两者之间的结构如下：
2、MQ的优势 应用解耦：提高系统容错性和可维护性异步提速：提升用户体验和系统吞吐量削峰填谷：提高系统稳定性 应用解耦 系统的耦合性越高，容错性就越低，可维护性就越低。
在订单系统与各个子系统之间加了MQ，减少了订单系统与各个系统的耦合！
使用MQ使得应用间解耦，提升容错性和可维护性。
异步提速 在没有MQ的时候，项目的逻辑架构如下所示：
一个下单操作耗时：20 + 300 + 300 + 300 = 920ms
用户点击完下单按钮后，需要等待920ms才能得到下单响应，太慢！ 引入MQ之后：
用户点击完下单按钮后，只需等待25ms就能得到下单响应 (20 + 5 = 25ms)。
提升用户体验和系统吞吐量（单位时间内处理请求的数目） 注：系统可以先给用户做出反应，后续的未执行的事情交由MQ慢慢执行！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14772f3d79887df807c1347fd8539f89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3f3b2486a80f67b07d46dc5da3bf237/" rel="bookmark">
			超大规模与轻量化模型，谁会成为AI主流？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《中智观察》第1672篇推送
作者：赵满满
编辑：小宏
编审：杨小天
头图来源：搜狐新闻
本文是《中智观察》“企业数字服务供需市场”行业洞察之人工智能篇。大模型已成为AI领域的新高地，实现“让人工智能像供水供电一样流向终端，流向用户、流向企业”，但AI越来越“笨拙”、越来越奢侈。改变这一格局的轻量化人工智能（Tiny AI）异军突起，通过对人工智能模型及其计算载体的“瘦身”，提升效率，降低能耗，部署到越来越多移动端和边缘设备上，让人工智能越来越精彩。
——海比研究院
2022年5月30日
阿里达摩院在研发L4级无人车“小蛮驴”时，其技术路线演变足可以说明AI轻量化的重要性。L4级别自动驾驶是指能在限定的道路及环境中，车辆可完全不需人为干预，自行完成驾驶。
早期Demo阶段的“小蛮驴”无人车使用工控机执行所有的自动驾驶计算任务。2020年亮相的小蛮驴则改用自研的嵌入式异构计算单元，仅以原有1/3算力就实现了工控机级别的智能水平。2021年，一种高性能网络轻量化方法模型，应用于“小蛮驴”，解决了以往算法硬件效率低下的问题，超越业界当时的最优方法。
我们正在走向一个嵌入式人工智能的世界。如在输电线路维护上，具备多种智能识别、检测和分析功能的自主巡检无人机、缺陷识别分析便携终端、通道可视化智能感知摄像头等，可有效保障输配电线路的安全和电力系统稳定。
轻量化的算法及轻量化神经网络计算架构，可有效实现暗光增强、超分辨率等，为手机终端、安防终端提供了影像增强效果。
人工智能特别是深度学习虽好，但却很难部署到移动端设备和嵌入式设备上。同时深度学习模型对硬件的算力和内存也有很高要求，而移动端设备或者嵌入式设备往往算力有限，因此，模型轻量化成为行业发展的一个重要方向。
AI轻量化的发展势头正越来越强劲。
1.大模型与轻量化，机器学习的不同发展道路
深度学习近年来发展迅猛，在人工智能领域显现出了强大的威力。其两大方向，尤其引人注目。
一个是解决通用性问题的AI大模型迅速发展，AI产业步入大模型时代。
人工智能的需求呈现出碎片化、多样化的特点，致使人工智能模型面临众多挑战，通用性低是首要问题。也就是说，A模型往往专用于特定A领域，应用到B领域便差强人意。
布局被简称为“大模型”的“超大规模预训练模型”已成为一项世界性趋势，从国外的谷歌、OpenAI，到国内的浪潮、百度、智源、华为、阿里云等，都纷纷推出自己的超大模型系统。
作为当前人工智能发展的重要方向，预训练大模型已成为AI领域的技术新高地。大模型从大规模知识和海量数据中融合学习，效率更高，效果更好，包含基础通用的大模型，也包含面向重点领域、重点任务的大模型，以及丰富的工具与平台，“让人工智能像供水供电一样流向终端，流向用户、流向企业”，有助于促进技术创新和产业发展。
专家预言，超大规模预训练模型的出现，很可能改变信息产业格局，从基于数据的互联网时代、基于算力的云计算时代，将进入基于大模型的AI时代。
另一个方向就是轻量化人工智能（Tiny AI），发展潜力惊人。
为了完成日益复杂的AI任务，神经网络模型体量暴增，对服务器的储存和算力要求也水涨船高，由此产生的经济成本、耗费的电量、对环境的污染等都困扰着整个行业。
大模型的人工智能这场游戏正变得越来越“笨拙”，也越来越奢侈。于是，轻量化人工智能（Tiny AI）被寄予厚望，通过对人工智能模型及其计算载体的“瘦身”，提升效率，降低能耗。
专家认为，轻量化人工智能是以一系列轻量化技术为驱动，提高算法、平台和芯片的效率，在更紧密的物理空间上实现低功耗的人工智能训练和应用部署，不依赖与云端交互就能实现智能化操作，被视为人工智能的另一个重要应用方向。
2020年，《麻省理工科技评论》将“Tiny AI”列为“全球十大突破性技术”。在技术革新的浪潮下，智能硬件结合人工智能越来越广泛地进入到我们的生活，小到智能手机、手表，大到智能交通系统、工业自动检测平台等，无不渗透了人工智能的威力。
同时，为人工智能深度学习定制的硬件，包括处理器等，近年来也有井喷之势。在多种服务平台、多种硬件下，深度学习模型在实际场景中的推理计算应用越来越多。
虽然硬件的快速发展带来了计算性能的提升，但多样化的硬件平台也给应用开发带来了挑战。同时，对深度学习任务而言，实际应用中的算力和内存的限制仍然显得非常苛刻。
因此，我们需要轻量级人工智能：在保持性能的同时使神经网络更小。我们正在走向一个嵌入式人工智能的世界，智能冰箱可以自动订购食品杂货，无人机可以自行导航飞遍整个城市，强大的机器学习方法应该能够下载到个人电脑、手机和小型芯片上。
2.持续探索技术，计算效率提升，轻量化AI前景诱人
轻量化AI的发展既紧迫，又亟需。
这几年深度学习发展迅猛，在图像、文本、语音、推荐等多个领域都取得了显著成果，并将深度学习模型应用于更广泛到的实际业务中，取得了不错的效果。
但是深度学习应用或多或少都会面临一个问题：业务数据量大，计算资源紧缺，导致模型训练慢，延时高，上线难。
因此在实际应用中，模型除了效果好，还需用得起，跑得快，才能在更多的场景下得到推广应用。
人工智能在行业应用中，大多依赖海量的训练数据和大规模服务器的算力支持，存储暴涨、数据堰塞、隐私泄露、能耗高企等问题也随之而来。随着近5年来摩尔定律的逐步放缓，IT硬件的发展愈发难以满足当前人工智能模型动辄万亿级规模的存储和算力需求。
因此，当前对人工智能设备和应用的快速响应、隐私保护以及节能减排的需求越发凸显。如何将人工智能模型及其计算载体前端化、轻量化，成为亟待解决的问题。
轻量化人工智能所带来的突破是显而易见的。
信通院发布的《人工智能白皮书（2022）》中表明，轻量化深度学习技术不断探索，计算效率显著提升。
目前来看，轻量化AI的优势包括：
轻量化人工智能使现有的服务比如语音助手、手机拍照等变得更好、更快，不必每次都需要连接云端才能运行深度学习模型。
此外，轻量化人工智能也将使新的应用成为可能，比如基于移动端的医学检测分析、对反应时间要求更快的自动驾驶汽车等。
最后，本地化的人工智能更利于隐私保护，用户的数据不再需要离开设备，就能实现服务功能的进化。
更重要的是，将人工智能推向更主流，大大降低AI系统的部署难度和成本，把AI从一场高门槛的竞赛，变成普惠民生的智能生态。
在人工智能领域的角逐中，以“轻量化”为赛点的下半场已经来临。
剪枝、量化、知识蒸馏等，成为AI轻量化的主要技术手段。
剖析智能化应用，可以发现，人工智能使能架构是由芯片（硬件）、AI操作系统（深度学习框架平台）和算法三个部分组成。
而Tiny AI就是以一系列轻量化技术为驱动提高芯片、平台和算法的效率，在更紧密的物理空间上实现低功耗的人工智能训练和应用部署，不需要依赖于与云端交互，就能实现智能化操作。
信通院发布的《人工智能白皮书（2022）》报告认为，复杂的深度学习模型往往需要消耗大量的存储空间和计算资源，难以在端、边等资源受限情形下应用，具备低内存和低计算量优势的技术成为业界需求。
轻量化深度学习成为解决这一挑战的重要技术，包括设计更加紧凑和高效的神经网络结构、对大模型进行剪枝（即“裁剪”掉部分模型结构），以及对网络参数进行量化，从而减少计算量等方向。
深度学习模型加速技术就是以“多快好省”为目标，试图从计算优化、系统优化以及硬件优化等多方面提升深度学习模型在训练和推理阶段的速度，如下表所示。
3.开源、轻量化，深度学习框架的世界异常精彩
前几年，开源深度学习框架的 “山头” 主要由国外科技巨头和高校所“盘踞”，如TensorFlow、PyTorch两大“双子星”，基本占领90%的开发者份额。
但目前这个局面正在发生细微变化。国产深度学习开源框架开始不断涌现，如百度推出Paddle Paddle，华为推出 MindSpore深度学习框架，旷视也开源了其深度学习框架 “MegEngine等。
在开源深度学习框架轻量化的大潮中，国内外企业的开源框架发展都非常迅速，竞争异常激烈。
PyTorch Lightning是PyTorch轻量级的包装。一直以来，PyTorch就以简单又好用的特点，广受AI研究者的喜爱。但是，一旦任务复杂化，就可能会发生一系列错误，花费的时间更长。于是， 2020年10月，一个“友好”的PyTorch Lightning就诞生了。
PyTorch是对初学者友好的深度学习框架，直接在GitHub上斩获6.6k星。它把研究代码与工程代码相分离，将PyTorch代码结构化，更加直观的展现数据操作过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3f3b2486a80f67b07d46dc5da3bf237/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0183ce13fcc9bb4a76f7b143bd0a653a/" rel="bookmark">
			QT基础 - QString使用arg() 格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.3. QString使用arg(int, int, int) 格式化 原型【1】为：
QString QString::arg(int a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char( ' ' )) const a：表示要处理的数字； fieldWidth：字宽； base：数字基数; fillChar为当设置了fieldWidth之后，自动补齐的字符 示例如下：
str = QString("十进制 63 的十进制为 %1").arg(63, 0, 10); //输出："十进制 63 的十进制为 63" str = QString("十进制 63 的十六进制为 %1").arg(63, 0, 16); //输出："十进制 63 的十六进制为 3f" str = QString("%1 %L2 %L3").arg(12345) .arg(1987654321) //根据结果，可知道这个L的作用 .arg(12345, 0, 8); //但使用这种方式时，L失效 //输出为：12345 1,987,654,321 30071 //这里%L3的L没有任何作用 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0183ce13fcc9bb4a76f7b143bd0a653a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f6bf052b29b4bb7c632498e09531d28/" rel="bookmark">
			山东大学移动互联网开发期末复习提纲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android等移动开发开发环境，各部、功能、用法、流程等，术语SDK、NDK、clang、avd、adb、studio等。
Android中的技术，GUI元素和界面设计、声音录放、静图/动图、网路通信、性能C、权限、GPS和地图、二维码等。
传感器技术和创意应用设计，再举例：街头棋局app。
https://blog.csdn.net/lanrenxiaowen/article/details/108051656
通信技术，ip、port、socket、tcp/udp/sctp、multicast/mdns、proxy、http/s、socks、
mq、p2p、nat、socat、ssh/-L-R-D、JSch
与桌面开发不同的移动开发技术。
移动开发和云的结合：计算能力和续航能力的平衡、分布式计算或数据存储、云备份、安全加密等。
与时俱进的移动开发技术，各方面：接入、通信、存储、界面、显示、Web/HTML、云、各种识别等。
从HTML/5到WebView的开发技术和过程。
H5/Canvas和Android/Canvas
Android上app代码运行优化的机制和过程等：JVM、DVM、JIT、AOT、ART等
从APK结构解析，到Android安全技术和对抗逆向。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d78b536b1b9ee9d5cf2a4cb657549532/" rel="bookmark">
			【SOLIDWORKS-详细记录】解决默认模板无效问题及添加自定义模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题说明 第一次安装完成SOLIDWORKS18，新建一个零件会弹出如下警告：
默认模板无效。通过修改选项对话框中的默认模板可以解决此问题。 您要继续使用一个空模板吗?
本博文就是解决这个弹窗警告的问题，并介绍如何添加自定义模板。
解决思路 添加定义好的模板即可。
可以分别添加零件、装配体的模板。
主要修改如下图。
解决步骤 添加模板 如下图依次点击
至此重启软件，就解决新建弹窗的问题了。
自定义模板 如下图模板查看
而GB就是国标的意思，它所包播的有标准、注解、尺寸等。
随手绘制一个矩形，简单固定其大小。发现文字的形式也就是模板里面所规定的。
也就是汉仪仿宋四号字体。
一般将3.5改为5.5mm确定后，发现标准变为GB-修改。
返回绘图页面，字体也变大了。看起来就舒服些了。
将修改文字高度的模板保存。
如何保存自己的新模板。
以将文字高度修改为5.5mm为例，详述步骤。 新建一个新零件，如下图操作将文字改为5.5mm
然后保存文件。
路径选系统保存模板的默认路径。
文件格式后缀选择prtdot。
我用的版本是2018，参考的默认路径C:\ProgramData\SOLIDWORKS\SOLIDWORKS 2018\templates
保存文件名称，自己定。我的如下图，然后点保存。
点击设置中选择这个保存的模板。
操作步骤如下图。
然后新建零件测试，发现字体大小果然是5.5mm。恭喜，大功告成了。同理也可以将装配体的模板改为GB修改。
新建装配体。如下图依次点击。
保存选择asmdot后缀
然后在设置中，将默认模板选择刚保存的这个文件。
其他要求，也可以自己尝试。
感谢阅读。有帮助的话点个赞呀。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c62e86dbd0a957477319e5281a4f73be/" rel="bookmark">
			requestparam与requestbody
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@RequestParam 注解@RequestParam接收的参数是来自HTTP请求体或请求url的QueryString中。
RequestParam可以接受简单类型的属性，也可以接受对象类型。
@RequestParam有三个配置参数：
required 表示是否必须，默认为 true，必须。defaultValue 可设置请求参数的默认值。value 为接收url的参数名（相当于key值）。 @RequestParam用来处理 Content-Type 为 application/x-www-form-urlencoded 编码的内容，Content-Type默认为该属性。@RequestParam也可用于其它类型的请求，例如：POST、DELETE等请求。
所以在postman中，要选择body的类型为 x-www-form-urlencoded，这样在headers中就自动变为了 Content-Type : application/x-www-form-urlencoded 编码格式。如下图所示：
但是这样不支持批量插入数据啊，如果改用 json 字符串来传值的话，类型设置为 application/json，点击发送的话，会报错，后台接收不到值，为 null。
但可以入参后再转换，参考如下：
@PostMapping("/ali-receive")
public void aliReceive(@RequestParam("message") String message) { ReceiveLog receiveLog = JSON.parseObject(message, ReceiveLog.class);
}
解决Spring/SpringBoot @RequestParam注解无法读取application/json格式数据：https://blog.csdn.net/weixin_42536015/article/details/106906055
@RequestParam 接受JSON的字符串：https://blog.csdn.net/qq_40470612/article/details/104225419
不推荐使用@RequestParam接收application/json，这时候就需要使用到@RequestBody。
@RequestBody 注解@RequestBody接收的参数是来自requestBody中，即请求体。一般用于处理非 Content-Type: application/x-www-form-urlencoded编码格式的数据，比如：application/json、application/xml等类型的数据。
就application/json类型的数据而言，使用注解@RequestBody可以将body里面所有的json数据传到后端，后端再进行解析。
GET请求中，因为没有HttpEntity，所以@RequestBody并不适用。
POST请求中，通过HttpEntity传递的参数，必须要在请求头中声明数据的类型Content-Type，SpringMVC通过使用
HandlerAdapter 配置的HttpMessageConverters来解析HttpEntity中的数据，然后绑定到相应的bean上。
向表中批量插入数据
举个批量插入数据的例子，Controller层的写法如下图所示：
由于@RequestBody可用来处理 Content-Type 为 application/json 编码的内容，所以在postman中，选择body的类型为row -&gt; JSON(application/json)，这样在 Headers 中也会自动变为 Content-Type : application/json 编码格式。body内的数据如下图所示：
批量向表中插入两条数据，这里的 saveBatchNovel()方法已经封装了 JPA的 saveAll() 方法。body 里面的 json 语句的 key 值要与后端实体类的属性一一对应。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c62e86dbd0a957477319e5281a4f73be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/facf4610594d7904a8dc051f82f6ecd6/" rel="bookmark">
			【游戏开发环境】Unity使用Mac电脑开发，开发环境的搭建（Mac mini M1 | VSCode | Git | 好用工具）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、Unity下载安装三、VSCode1、VSCode下载安装2、VSCode插件2.1、unity3d-pack插件2.2、Bracket Pair Colorizer 2插件2.3、其他插件 3、代码无法提示与补全的问题3.1、Windows解决办法3.2、Mac解决办法3.2.1、安装Mono3.2.2、设置Omnisharp: Use Global Mono为always (新版没有这个设置了，不用管)3.2.3、安装.NET Core SDK 4、设置External Script Editor为VSCode 四、安装JRE五、安装HomeBrew六、安装adb七、安装oh-my-zsh八、Git无法自动补全的问题九、Mac安卓模拟器（兼容M1芯片）十、Mac免费好用工具推荐1、iTerm2终端2、Alfred（应用快捷查找）3、EasyFind（类似于Everything）4、Xnip或iShot（截图工具）5、GIPHY Capture （GIF录屏工具）6、FastZip（压缩解压缩）7、待补充 十一、你是win，但想玩一下mac十二、完毕 一、前言 嗨，大家好，我是新发。
我最近换用Mac mini进行办公了（M1芯片），新电脑需要搭建软件开发环境，写篇博客记录一下，如果你也是使用Mac电脑，希望对你有帮助~
我安装的系统是macOS Monterey 12.3.1
二、Unity下载安装 Unity的安装直接在官网（https://unity.cn/）下载Unity Hub，然后使用Unity Hub安装对应版本的Unity即可，与Windows没什么区别，这里不赘述。
三、VSCode 1、VSCode下载安装 代码编辑器我喜欢用VSCode，它比Visual Studio轻量美观，而且插件丰富，推荐。
VSCode官网：https://code.visualstudio.com/
你可能会发现下载速度很慢：
我们可以把前面的域名替换为vscode.cdn.azure.cn，比如上面的链接是https://az764295.vo.msecnd.net/stable/da15b6fd3ef856477bf6f4fb29ba1b7af717770d/VSCode-darwin-universal.zip，
替换后是
https://vscode.cdn.azure.cn/stable/da15b6fd3ef856477bf6f4fb29ba1b7af717770d/VSCode-darwin-universal.zip
下载速度有10MB/s，非常快
2、VSCode插件 使用VSCode作为Unity的代码编辑器，需要安装相关的插件，下面我列一下我安装的插件。
2.1、unity3d-pack插件 unity3d-pack插件是一个插件套件，它会自动安装对应的依赖插件：C# Snippets、C# XML Documentation Comments、Unity Code Snippets、Shader language support for VS Code、Unity Tools、Debugger for Unity、ShaderlabVSCode
2.2、Bracket Pair Colorizer 2插件 这是一个括号颜色匹配的插件，方便代码的阅读，也建议大家安装。
2.3、其他插件 如果你的项目有使用lua，你还需要安装一下lua相关的插件，我一般安装的是：
EmmyLua和Lua这连个插件
然后为了方便查看工程目录结构，会再安装一个vscode-icons插件，
基本上就够用了，大家可以根据自己的实际情况安装相关的插件。
3、代码无法提示与补全的问题 安装完插件，大家可能会发现写代码依然没有代码提示和自动补全功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/facf4610594d7904a8dc051f82f6ecd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af969b4678986ef49e5cd2ede9a109da/" rel="bookmark">
			C语言实现输出亲密数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 C语言实现两个不同的自然数A和B，如果整数A的全部因子(包括1，不包括A本身)之和等于B；且整数B的全部因子(包括1，不包括B本身)之和等于A，则将整数A和B称为亲密数。求3000以内的全部亲密数。
#include "stdio.h" //可使用枚举算法实现 int main() { int a,b,i,j,k,sum1,sum2; // scanf("%d %d",&amp;a,&amp;b); for(i=1;i&lt;=3000;i++)//对30000以内的数进行穷举 { sum1=0; sum2=0; for(j=1;j&lt;i;j++)//判断1~i-1内的数j是否为i的因子 if(i%j==0) sum1+=j;//i的所有因子求和 for(k=1;k&lt;sum1;k++)//判断1~sum1-1内的数k是否为sum1的因子 if(sum1%k==0) sum2+=k;//sum1的所有因子求和 if(sum2==i&amp;&amp;i&lt;sum1)//“A与B”和“B与A”是一样的，只要输出一个	printf("(%d,%d)",i,sum1); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73a87c7245060b2a493dde50be2f47ea/" rel="bookmark">
			小猫爪：S32K3学习笔记14-S32K3之REG_PORT,MPU和XRDC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小猫爪：S32K3学习笔记14-S32K3之REG_PORT,MPU和XRDC 1 前言2 REG_PORT3 MPU3.1 MPU简介3.2 MCAL配置 4 XRDC4.1 XRDC的原理和工作机制4.2 MCAL配置 END 1 前言 这一节就来看看S32K3的资源访问保护器，S32K3在资源管理方面主要有三个玩意可以对其片上资源提供了强有力的保护，分别是REG_PORT（Register Protection），MPU（Memory Protection Unit）和XRDC（Extended Resource Domain Controller）。其中REG_PORT针对的是寄存器操作的保护；MPU其实是ARM核里自带的一个外设，它所管理的是单核对整个片上内存的访问权限；XRDC管理的则是所有访问Master（核，DMA等）对外设和Memory的访问权限。
2 REG_PORT REG_PORT功能简单来说就是给寄存器加一把硬件锁，当需要修改寄存器时，必须先解锁才能进行相关操作，其功能框图如下：
但是并不是K3所有的寄存器都可以通过REG_PORT来加锁保护，可以在RM手册的附件里面有个叫做S32K3xx_REG_PROT_details.xlsx的表格，在这个表格里记录所有能够被REG_PORT上锁保护的寄存器。那这个功能在MCAL中怎么去配置呢？其实很简单，在很多模块中，都会有一个Enable User Mode Support选项，我以Port模块为例，如下：
查看这个选项的描述如下：
仔细一读就可以知道在user mode下，REG_PORT就会被使能，但是一般这个功能用的不多，在一般的应用下，CPU都是工作在Supervisor模式下的，所有REG_PORT感觉就是被浪费了。
3 MPU 3.1 MPU简介 MPU是ARM核自带的一个核内外设，它所要保护的其实MPU所在核对内存（这里的内存包括整个MCU地址映射空间，包括外设寄存器，RAM，Flash等）的访问权限，所以MPU管理的访问Mater为M7核，访问Slave为整个内存空间。对MPU不太清楚的可以参考这篇文章：《小猫爪：嵌入式小知识11-MPU详解及其应用》，我在这里就不多嘴了。
当使能和配置MPU后，一旦核非法访问禁止区域就会触发MemManage_Handler中断（需通过写SCB-&gt;SHCSR使能，否则触发HardFault_Handler中断）。
3.2 MCAL配置 接下来，废话不多说，直接进入主题，怎么在MCAL中实现MPU的相关配置？MPU以CDD的形式被集成在了Rm模块中，如下：
点开后，在配置页面中配置MPU，如下：
接下来就是配置和添加域，对于S32K3来说，可以最大配置16个MPU域，下图为K3的默认MPU配置如下：
我们可以根据上表来添加域和配置每个域的类型和权限，如下：
注意①：配置MPU域的大小起始地址需要满足两个条件，第一就是域的大小必须是2的次方大小，第二就是起始地址必须要是域大小的整数倍。
注意②：在配置域的类型时最好根据域的物理和功能特性来配置，可参考下表：
域的类型MPU 类型code flashNormal CacheableITCM and DTCMStrong orderedSystem RAMNormal CacheableShared RAMNormal IO No CachePeripherals registersDevice sharedData flashDevice sharedQSPI buffersDevice no sharePrivate peripheraDevice no share 注意③：另外Inter Cache和Outer Cache指的是分层Cache，对于一个多核MCU来说，它可能有多层Cache，L1 Cache，L2 Cache，L3 Cache，而Inter和Outer则是指的是在位置上来区分，一般独属于CPU微架构的叫Inter Cache，不属于CPU微架构的叫outer Cache。K3只有一层Cache，即只有Inter Cache，所以在配置时让Outer Cache Policy和Inner Cache Policy 保持一致即可。至此关于MPU的配置就结束了，非常简单。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73a87c7245060b2a493dde50be2f47ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efa7f7f5824abeffd26b34046158dce5/" rel="bookmark">
			Wireshark找不到本地接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象：在打开wireshark之后显示没有接口。
方法：
1、使用管理员身份运行CMD.exe；之后输入
net start npf 2、在启动wireshark即可看到网络接口信息。（如果还是看不到接口，再用管理员权限运行Wireshark试试）
如果还是不行可参考如下文章： 参考：​​​​​​​​​​​​​​https://blog.csdn.net/wkk521000/article/details/109450088
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29c9eb4f17fa5e358d5b9b9464c84d35/" rel="bookmark">
			打印菱形（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打印菱形 首先，可以将菱形分成上下两部分
上部分； 总行数 line 1.先打印空格，从图中可以发现： 左侧空格数由(line -1)每次减少一个，到0为止。（右侧同理） 2.后打印*，从图中可以发现： *的个数从1开始每次增加2个 -&gt; (2*i+1) 代码如下
int line = 0; scanf("%d", &amp;line); //上部分 int i = 0; for (i = 0; i &lt; line; i++) { int j = 0; //打印空格 for (j = 0; j &lt; line - 1 -i; j++) { printf(" "); } //打印* for (j = 0; j &lt; 2 * i + 1; j++) { printf("*"); } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29c9eb4f17fa5e358d5b9b9464c84d35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d3164339e0e497a7b63a450a1fb9c23/" rel="bookmark">
			TensorRT 系列 （2）动态shape
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TensorRT支持输入动态shape的推理，在编译模型时可以指定shape的动态范围为[L, H]，推理时允许L &lt;= shape &lt;= H，输入动态shape可通过createOptimizationProfile优化配置文件，来指定输入的shape可以变换的范围，当然也可以通过ONNX导出模型时进行指定，本次只演示前一种。
示例代码：
// tensorRT include #include &lt;NvInfer.h&gt; #include &lt;NvInferRuntime.h&gt; // cuda include #include &lt;cuda_runtime.h&gt; // system include #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; // 后面要用到ios这个库 #include &lt;vector&gt; using namespace std; class TRTLogger : public nvinfer1::ILogger { public: virtual void log(Severity severity, nvinfer1::AsciiChar const* msg) noexcept override { if(severity &lt;= Severity::kINFO) { printf("%d: %s\n", severity, msg); } } } logger; nvinfer1::Weights make_weights(float* ptr, int n) { nvinfer1::Weights w; w.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d3164339e0e497a7b63a450a1fb9c23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d8295521afd0198d9d039b26a9ecb0b/" rel="bookmark">
			Autosar Time Sync 时间同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入车载以太网之后，很好地解决了有大量数据交换或者发布/订阅模式需求的场景，不过呢，车内也有不少对通信过程中包含时间约束的应用场景，本文将介绍Classic AUTOSAR中和时间同步有关的内容。
前言 首先，我们考虑以下场景：
我们创建了两个不同的Runnable，它们都需要根据某一操作指令，控制对应的执行机，为了保证执行能正确达到预期，我们需要保证它们能同时（或者以固定的偏移量）去控制执行机。车身周围的环视摄像头，我们需要读出图像数据并且做融合，需要保证处理的各个摄像头数据时同步的；或者是发生故障时记录当时的故障数据，也需要保证能记录到当前时间点的所有数据 无论是哪一种情况，关键词就是“同步”，我们需要有一个模块来管理同步时间基准。当然，在AUTOSAR的规范里，被称作为StbM——Synchronized Time-base Manager。
时间基准既可以代表运行时长，时间基准来源，也可以是真实世界时间。例如：
GPS时间（绝对时间）车辆总运行时间（相对时间）ECU启动时间（相对时间） StbM 我们首先来看一下官方文档如何说明这个模块的。
作为管理模块，StbM并不会指定，也不提供任何网络时间协议，一切和总线类型和时间协议有关的工作都需要由上图蓝色框所示的&lt;bus&gt;TSyn来完成。
收到&lt;bus&gt;TSyn提供的信息之后，StbM就可以来同步它与其他节点的时间基准。
作为时间基准的“代理”，StbM提供的时间信息，会提供给对应的“消费者”（OS &amp; SWC）。
一般地，硬件参考时钟被用来作为基准时间的实现。由于硬件参考时钟达到寄存器最大值时会“溢出”再次从0开始增加，软件中会增加计数器共同来实现虚拟本地时间。
引入频分(Rate Deviation)以及偏移(Offset)之后，虚拟本地时间可以用来作基准时间。
三种时间“消费者” 还是这张图，我们来看看各个消费者是如何与StbM进行交互的。
Active Customer
从StbM读取时间信息（箭头2）根据应用信息，由StbM更新时间基准（箭头3） Triggered Customer
仅和OS调度表同步功能有关（箭头1） Notification Customer
时间基准状态改变（例如发生了timeout时间）（箭头4）时间基准达到给定值（箭头4），这个给定值是由消费者设定的（箭头5） 时间服务 在汽车当中，为了完成时间同步，我们会定义不同的Master与Slave，它们之间靠&lt;Bus&gt;Tsync来完成时间信息的传送。
例如上图，我们可以有一个系统级的Master---Global time master，其他的ECU可以形成不同的time domain，并定义各自的time master与slave。
如何做时间同步 如上图所示，Master提供时间基准给其他ECU，由于同步前每个ECU都有自己的基准时间，为了能够更新本地的基准时间保持和Master同步，需要知道两个基准时间的偏移量（offset）。
Master周期性地发送Sync帧给Slave，那么Slave能够在t2时间收到Sync帧并记录t2时间。由于发送时的t1时间只有发送时刻才能得到，t1时间是无法和Sync帧一块儿发送的，因此需要再发送一次Followup帧，将t1时间作为数据传送给Slave。
Slave收到之后就能根据t2-t1-d得出这个offset，修正自己的基准时间，完成同步。
不过呢，你肯定会发现一个问题，就是总线上传输时间d，包括经由路由或交换机的延时没有被考虑在内，算式虽有，可还是无法完成计算。
为了计算出d的大小，我们可以采取这样的方案：
Slave发送PathDelayReq帧给到Master，并记录发送时间t1，相应的，Master记录接收时间t2。Master回送PathDelayResp帧，记录t3时间，Slave记录接收时间t4。Master再发送一个PathDelayRespFollowup帧，将t2, t3时间作为数据发送给Slave。Slave根据算式 ((t4-t1)-(t3-t2))/2得到传输时间d。 硬件时间戳 如果以太网控制器集成有时钟，能够为以太网消息加上硬件时间戳，那么时间同步的精确度可以进一步提高。如果你使用的是EB的以太网驱动，那么有无硬件时钟的两种情况，都能支持。
Best Master Clock Algorithm (BMCA) 最佳主时钟算法 在实际工程中，为了精确度或是冗余度，可能会存在多个Master的情况，这个时候需要用到BMCA算法。
Master会发送Announce消息，来向各个Slave声明自己是主时钟，Slave会选择更好的那一个。
时间同步网关 查了下我司软件，如果同时配置了本节点为Master和Slave，那么就会作为Gateway的角色参与时间同步。（强烈要求广告费= =..）
任务同步 之前有说到，OS是目前定义的唯一一个triggered customer，需要提供接口给到Stbm做调度表同步，也即修改调度表对应的Time Base。
在同步之前，Stbm会检查OS调度表的状态，只有当状态处于WAITING，RUNNING或者RUNNING_SYNCHRONOUS时才能进行同步操作。
QoS 待更新
以太网时间同步EthTsync 以太网时间同步机制基于PTP (Precision Time Protocol) ，在IEEE1588和IEEE802.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d8295521afd0198d9d039b26a9ecb0b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/233/">«</a>
	<span class="pagination__item pagination__item--current">234/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/235/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>