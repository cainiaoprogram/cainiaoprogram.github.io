<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a929e68b0c2b2af4b31cf5ce8b8c47b9/" rel="bookmark">
			Linux 开启Swap交换内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 开启Swap交换内存 Linux 开启Swap交换内存 Linux 开启Swap交换内存 由于阿里云服务器内存空间有点小，但是又不能加内存，则想到使用Swap交换空间，用硬盘空间充当内存使用。
开启步骤，以4G为例：
1.创建交换文件存储目录，并进入
mkdir -p /opt/swap cd /opt/swap 2.创建交换文件并填充文件大小
touch swapfile dd if=/dev/zero of=/opt/swap/swapfile bs=1G count=4 3.设置文件权限
chmod 600 swapfile 4.开启交换
swapon /opt/swap/swapfile 5.持久化
vim /etc/fstab # 添加如下一行 /opt/swap/swapfile swap swap default 0 0 6.查看结果
# 或者swapon --show都可查看 free -h total used free shared buff/cache available Mem: 1.7G 132M 1.0G 480K 563M 1.4G Swap: 4.0G 0B 4.0G 其他：
取消交换空间：使用swapoff /opt/swap/swapfile，然后注释掉/etc/fstab中的swap内容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df86fbbe7bd752494596503b32c0ccfd/" rel="bookmark">
			数据通讯平台建设方案（物联网数据采集平台）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数据通讯平台 软件开发全资料获取：软件项目开发全套文档下载_软件项目技术实现文档-CSDN博客
1.1.1.系统概述 对不同的数据协议、数据模式进行采集适配。基于XX智慧平台统一数据交换标准，与第三方系统对接，实现数据交换；实现不同场景中的在线监测仪表以及其他物联传感设备的通讯和数据交换。为企业信息化集成平台的不同业务系统提供底层物联采集及数据支撑。
1.1.2.需求分析 数据通讯平台主要承担硬件设备与应用系统的交互，第三方系统与企业内部系统的交互。需要满足内部业务在该通讯平台的基础上，实现业务系统的业务可扩展性。基于以上分析对数据通讯平台，提出了以下要求：
(1) 多协议的支持，由于设备厂商的差异性，采用的协议参差不齐，基于以上原因对数据通讯平台提出了较高的要求，要求数据通讯平台支持多协议，例如MQTT、TCP、CoAP。
(2) 同类型设备数据包通讯的标识，硬件同类型设备采购的厂商不同，设备通讯数据包格式不同，而在业务系统中，需要以标准的数据实现对业务系统的支持，基于以上原因要求数据通讯平台能实现不同类型设备的标识，以用于设备通讯数据协议的解析。
(3) 通讯数据临时存储，业务系统存在着升级、机房临时停电等情况，基于以上情况，通讯服务需要提供通讯数据的临时存储功能。
(4) 通信服务状态监测，通讯平台提供的通讯服务，可能面向不同类型设备群，不同设备群自定义协议存在差异，基于以上情况建立不同的通讯链路，用于自定义通讯协议的区分，是非常有必要的。通讯链路的稳定性与通讯服务质量有关，也与运维有关，实时监测通讯服务的稳定性，对数据的完整性非常重要。
(5) 数据标准化服务，项目施工完毕后可能存在相同功能设备的二次采购服务于项目，数据通讯平台提供面向业务的统一数据标准化服务，有利于减少系统的接入与建设成本。
(6) 通讯服务的统一维护，数据通讯服务支持不同协议的数据通讯时，异构协议需要采用统一的资源管理服务进行调度与管理；
通讯服务需要支持大规模的设备接入，单机通讯服务存在并发极限，基于以上需求，通讯服务需要满足协议通讯服务的横向可扩展，用于支持大规模的设备接入。
1.1.3.重难点分析 通过需求的深度分析，我们可以看出单独一种通讯协议的实现比较简单，单协议的通讯服务可以采用开源的解决方案，该方案可以满足规模较小的设备接入，但在面对大规模高并发的情况下会显得力不从心的情况。当出现多协议的情况下，系统实现会变得非常复杂，实现成本和维护成本非常高。多协议的通讯集成对于通讯服务平台的实现是一种挑战。
通讯服务资源的管理与监控，对于通讯服务的实现也是一种挑战。通讯服务的管理，主要解决通讯服务对于硬件资源的合理利用、通讯数据包的临时存储、通讯状态的监测、通讯服务的鉴权管理。
在系统集成中，适配不同的业务系统非常有必要，但这对通讯服务平台性能的适配提出了更高的要求。
1.1.4.重难点解决措施 针对重难点，在技术上提出了一下解决措施：
(1) 通讯服务横向扩展技术，设备接入规模在硬件资源满足的情况下无限制，数据采集平台可依据业务扩展的需要，动态的新增不同类型的通讯服务器资源；
(2) 支持多协议硬件设备接入，该数据采集平台，针对不同的协议，开发了不同的通讯服务器，并进行通讯集成；从而支持更为广泛的设备接入通讯平台；
(3) 数据隔离技术，支持接入平台的通讯数据，进行数据的隔离，支持企业之间数据的隔离，项目之间数据的隔离；
(4) 数据分发技术，支持同一通讯服务数据的分发，用户可以根据业务，动态增减数据的分发，用于满足业务的需要；
(5) 微服务技术，由传统的单体服务技术，转向微服务技术，故障率更低，后期可维护性更好；
(6) 各通讯协议服务独立开发，采用微服务技术进行通讯平台集成；
1.2.系统架构设计 1.2.1.系统架构图 在目前主流的基于企业级别的技术路线，可供选择的有Java 技术体系、C#技术体系、.netCore技术体系；从目前国内主流技术应用和国内环境考虑，我们优先选择Java 技术体系，该体系用户使用群里大，开源资源较多，有完整的技术架构体系；Java技术体系中，所选用的技术路线为java、注册中心、网关、基于开源的通讯服务、跨服务调用插件、监测中心。详细技术架构如图所示:
1.2.2.业务架构设计 数据通讯平台主要包括：MQ消息服务、TCP通讯服务、CoAP通讯服务、MQTT通讯服务、资源管理服务。每个子服务中核心业务模块如图所示：
核心业务模块
(1) MQ消息服务
MQ消息服务，为独立部署的开源软件系统，资源管理平台通过组件的方式，根据业务需要，动态的创建销毁消息队列，MQ消息队列服务的部署，可以横向的扩展部署，部署后的消息服务信息，需要录入到资源管理服务中，作为基础信息供平台使用。用户通过资源管理平台，创建的消息队列需绑定对应的通讯服务，供通信服务使用。
(2) TCP通讯服务
TCP通讯服务，支持远程服务的创建、销毁、消息转发、权限验证、IP过滤、反向控制等功能。平台通过资源管理服务，完成以上操作，TCP通讯服务也可作为单独的插件使用。TPC通讯服务与资源管理平台的信息交互通过注册中心进行。TCP通讯服务部署完成后，需将相关信息录入到资源管理服务中，供资源管理平台对TCP通讯服务的远程检测与控制。
(3) CoAP通讯服务
CoAP通讯服务主要用于处理资源有限的低功耗设备协议。该服务支持服务创建、销毁、反向控制、权限认证、设备在线注册等功能。
(4) MQTT通讯服务
MQTT通讯服务支持服务创建、服务销毁、消息转发、权限认证。
(5) 资源管理服务
资源管理服务主要用于管理在服务器上部署的通讯服务、通讯服务中的鉴权、MQ服务。通讯服务主要包括TCP通讯服务、CoAP通讯服务、MQTT通讯服务。
1.2.3.主流技术架构分析 目前主流通讯服务设计思路有三种，通讯服务的横向设计方案与纵向设计方案。
1) 常规设计方案
纵向设计方案
小型公司采用的技术架构，也是开源市场上提供的最直接的解决方案，该方案会取消通讯路由(通讯路由的开发存在技术难度，且机器硬件采购成本较高)，取消通讯路由后，通讯并发不加载业务的情况下能达到1w；
应用场景：以项目为为主，主要应用于局域网，加载业务单机并发可达到3-6K；
备注：在大部分以项目为主，或者工业应用，软件基于局域网部署的场合下，采用小型公司采用的技术方案，该方案，网络上有现成的解决方案，开发成低，技术难度低。
应用场景：以项目为主的局域网，或者工业设备互联上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df86fbbe7bd752494596503b32c0ccfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b78b8a0a32bb971cea427b327715011a/" rel="bookmark">
			在渲染element plus 中的el-tree 通过判断渲染数据的状态来进行特定颜色的变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在处理el-tree的这个渲染问题最重要的就是数据结构的类型，在这个小项目中，我所处理的后端数据是一个一维的对象数组，每一项数组的children中包含了一个数组。
在我通过dom来操作想要改变el-tree的css样式的同时，发现获取到的是空数组，数据没有如愿的获取到的情况有很多，在这里遇到的是渲染是基于后端数据接口调用完成后在调用a（）函数，而解决的办法是通过async和await来进行处理的，在处理完成后继续来看我们获取到的数据，我们发现获取到的是一个htmlcollection，即一个动态类型的数组，那么我们在下面生成的htmlCollectionToArray函数就是来进行处理htmlcollection成为一个array数组，在数组的数据类型基础上，在进行操作处理。
处理成数组后会发现一个是一维数组，一个是二维数组（不太严谨但可以这么理解），通过flattenArray函数（代码块第三个函数）来将二维数组转换成一维数组，再通过遍历结合判断语句来进行赋值操作。
最后处理好之后，通过arrayToHtmlCollection来将array转成htmlcollection动态数组
//通过a来进行调用函数 const a= async () =&gt; { let tree = document.getElementsByClassName("想要修改的class"); let array = htmlCollectionToArray(tree); let newnode = flattenArray(treedata.value.value); for (let i = 0; i &lt; newnode.length; i++) { if (newnode[i].auditResult == false) { array[i][0].style.color = "black"; } if (newnode[i].auditResult == true) { array[i][0].style.color = "green"; } } tree = arrayToHtmlCollection(array); }; //数组扁平化 function flattenArray(array) { let result = []; let beforeResult = ["1"]; for (let i = 0; i &lt; array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b78b8a0a32bb971cea427b327715011a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda03b70a15b32792316e51fcaaabc8d/" rel="bookmark">
			借助 ControlNet 生成艺术二维码 – 基于 Stable Diffusion 的 AI 绘画方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿背景介绍 在过去的数月中，亚马逊云科技已经推出了多篇 Blog，来介绍如何在亚马逊云科技上部署 Stable Diffusion，或是如何结合 Amazon SageMaker 与 Stable Diffusion 进行模型训练和推理任务。
为了帮助客户快速、安全地在亚马逊云科技上构建、部署和管理应用程序，众多合作伙伴与亚马逊云科技紧密合作。他们提供各种各样的服务、深入的技术知识、最佳实践和解决方案，包括基础设施迁移、应用程序现代化、安全和合规性、数据分析、机器学习、人工智能、云托管、DevOps、咨询和培训。
最近，亚马逊云科技核心级服务合作伙伴 eCloudrover（伊克罗德） 推出了基于 Stable Diffusion 的 AI 绘画解决方案——imAgine，既拥有经过广泛验证且易于部署的先进 AI 算法模型，又提供丰富且高性价比的云端资源以优化成本，旨在帮助游戏、电商、媒体、影视、广告、传媒等行业快速构建 AIGC 应用通路，打造 AI 时代的领先生产力。
本文主要分享我们在帮助客户使用 Stable Diffusion 时总结的实战经验，以及使用基于 Stable Diffusion 研发的 imAgine 产品生成艺术二维码的最佳实践。
我们将以 QRCode 作为 ControlNet 的输入，使 QRCode 数据点融入到艺术图像中，同时仍然可以被 QRCode 阅读器扫描。借助这项技术，您可以将任何二维码转化为独特的艺术作品，以一种全新的方式来表达和传递信息。以下为几张图片案例：
Stable Diffusion 实战技巧 古语有云：“万事开头难”，“致广大而尽精微”。这对应了在 Stable Diffusion 实战中，客户最常遇到的两方面问题，一是如何选择合适的提示词起手式，来生成满足期望的图片；二是如何对图片进行细节优化，使最终产出的结果能够满足生产应用需求。
我们根据过往服务客户使用 Stable Diffusion 的经验，整理了以下内容作为我们推荐的最佳实践，希望对读者使用 Stable Diffusion 进行创作时提供参考。
提示词工程 随着 Stable Diffusion 版本不断迭代，AI 对语义的理解越来越接近“常识”之后，对提示词（Prompts）的要求也会越来越高。很多提示词上的误区有时会对绘图产生反作用。
Prompt 的基本概念 提示词分为正向提示词（positive prompt）和反向提示词（negative prompt），用来告诉 AI 哪些需要，哪些不需要。 Prompt 的误区 Prompt 在于精确，不在于数量；用最简短的单词阐述画面，比自然语言要更有效。提升质量的描绘词绝不是无脑堆砌、越多越好。经常出现的起手式：“masterpiece” “best quality” 等，很多时候会成为提示词中的累赘。这些词语在 NovelAI 时代是有意义的，因为当时 NovelAI 训练模型时大量使用了这些词汇来对图像进行评价；但在如今，经过 Civitai 上模型作者们不断重新炼制模型，这些提示词已经很难在生图结果中展现应有的作用。 调整提示词的权重 词缀的权重默认值都是 1，从左到右依次减弱提示词权重会显著影响画面生成结果通过小括号+冒号+数字来指定提示词权重，写法如 (one girl:1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cda03b70a15b32792316e51fcaaabc8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/224cfd077c2cd63c71bcf2593986673c/" rel="bookmark">
			linux cpu、memory 、io、网络、文件系统多种类型负荷模拟调测方法工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概述
二、stress介绍和使用
2.1 介绍
2.2 使用
三、stress-ng介绍和使用
3.1 介绍
3.2 使用
3.3 实例
四、sysbench
4.1 介绍
4.2 使用
五、lmbench
5.1 介绍
5.2 使用
一、概述 今天介绍两款cpu负荷调试工具，用来模拟多种类型的负载。主要用来模拟CPU 资源、内存资源、 I/O资源、网络资源、文件系统操作等资源负荷占比。
二、stress介绍和使用 2.1 介绍 是一个用于测试系统稳定性和性能的工具。它可以模拟系统在高负载下的运行情况，帮助评估系统的表现，调试和排查问题。
2.2 使用 使用 stress 工具时，可以根据需要选择不同的选项和参数来配置其行为。以下是 stress 工具的基本使用方法：
安装 stress 工具：
在 Linux 系统上，可以使用包管理器进行安装。例如，在 Ubuntu 上可以使用以下命令进行安装；在嵌入式yocto环境中可以用bitbake stress来编译，然后传输到设备中运行：
sudo apt-get install stress 运行 stress 命令：使用以下命令来运行 stress 工具：
stress [选项] [参数] 选项：可以使用不同的选项来配置 stress 的行为。一些常用的选项包括：
-c &lt;N&gt;：创建 N 个 worker 进程来占用 CPU 资源。-m &lt;N&gt;：创建 N 个 worker 进程来占用内存资源。-i &lt;N&gt;：创建 N 个 worker 进程来占用 I/O 资源。-d &lt;N&gt;：创建 N 个 worker 进程来占用硬盘 I/O 资源。-t &lt;时间&gt;：运行 stress 的时间长度，单位可以是秒（s）、分钟（m）、小时（h）等。-v：显示详细的输出信息。其他选项可以通过 man stress 命令查看相关文档。 参数：根据选项的不同，可以提供相应的参数。例如，对于 -c 选项，可以指定要创建的 worker 进程数量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/224cfd077c2cd63c71bcf2593986673c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5beb814d386014394145ecd645dea97d/" rel="bookmark">
			Java常见的设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单例模式（Singleton Pattern）:
单例模式确保一个类只能实例化为一个对象，并提供对该对象的全局访问点。这在需要共享资源或控制独享资源的情况下非常有用。
public class Singleton { private static Singleton instance; private Singleton() { // 私有构造函数 } public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } ``` 工厂模式（Factory Pattern）:
工厂模式使用一个共同的接口来创建对象，但允许子类决定实例化哪个类。这样可以将对象的创建与使用代码解耦，提高了代码的可维护性和灵活性。
public interface Shape { void draw(); } public class Circle implements Shape { @Override public void draw() { System.out.println("Drawing a circle"); } } public class Rectangle implements Shape { @Override public void draw() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5beb814d386014394145ecd645dea97d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d8253128ca4285afce0cdfac5fc3fe1/" rel="bookmark">
			利用 hexo 搭建 github page
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认我们已经安装了
node.js
git
点击就可以下载啦
然后我们在本地新建一个文件夹，我取的名字是Hexo_blog
然后在命令行处输入 或者 右键 点击 git bash here
npm install -g hexo-cli
下一步进行Hexo 初始化和本地预览
初始化并安装所需组件：
hexo init # 初始化
npm install # 安装组件
完成后依次输入下面命令，启动本地服务器进行预览：
hexo g # 生成页面
hexo s # 启动预览
然后我们访问 http://localhost:4000/ 就可以预览了（插个题外话，如果手机和电脑连接同一个网络，可以将 localhost 替换为电脑的ip，然后手机也可以访问啦）
效果如上
出现 Hexo 默认页面，本地博客安装成功！
本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。
首先安装 hexo-deployer-git：
npm install hexo-deployer-git --save
然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下：
deploy:
type: git
repository: git@github.com:用户名/用户名.github.io.git
branch: master
完成后运行 hexo d 将网站上传部署到 GitHub Pages。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d8253128ca4285afce0cdfac5fc3fe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a378b256df25f378451dfcf88a4d7e01/" rel="bookmark">
			处理sql server长时间锁表、死锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有的人数据库连接工具开了手动提交，执行完sql又忘记提交事务，或者代码有问题没有提交事务或产生了死锁，会导致长时间锁表，表完全没法用了
其实可以建立运维面板来监控此种场景
无论是oracle还是sql server，处理步骤都是一样的，先查出锁表的session，再kill掉，只是具体sql不一样
--查询阻塞进程 select session_id,wait_duration_ms,wait_type,blocking_session_id from sys.dm_os_waiting_tasks WHERE blocking_session_id &lt;&gt; 0 列出当前阻塞进程都被哪个进程给阻塞了，找出阻塞源头
--把阻塞源头给kill，kill之后该session的事务被回滚 kill session_id 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8f1b0286a721c1e2431a82ea9e7035d/" rel="bookmark">
			中国肺癌情形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 再看下中国肺癌的情形
综述 文章名期刊影响因子Non-small cell lung cancer in ChinaCancer Commun16.2 摘要
风险因子：吸烟史、家族史、放射暴露、空气污染、慢性肺病
晚期PD-1/PD-L1抑制剂单药使用或联合化疗药物作为标准治疗。局部肺癌晚期，建议化疗后免疫治疗。可切除的建议辅助免疫治疗和新辅助化疗。
文章外学习 新辅助化疗：说是在做手术前为缩小病灶用化疗方式进行，使预后更好。但若化疗效果差，会延误治疗进度。
辅助免疫治疗：在术前做免疫治疗，增强病人免疫系统能力和功能。缺点贵且可能导致免疫不良反应。适用于实体瘤，比如肺癌、肾癌、黑色素瘤等。
简单而言，辅助治疗应该就是术前采取的治疗手段，说是辅助，那么主要治疗手段是手术？
免疫治疗与化疗的区别？ 区别点免疫治疗化疗作用机制激活人体免疫系统来杀灭肿瘤细胞作用于癌细胞的蛋白分子或是基因片段等致癌位点来使肿瘤细胞特异性死亡作用时间相对比较持久起效快，可快速控制病灶，靶向治疗也可快速起效，但作用时间比较短毒副作用毒副作用小，可自行缓解毒副作用较大，可出现食欲不振、脱发等症状适应症多用实体瘤适用范围更广治疗成本贵相对而言更平价 实体瘤与非实体瘤区别 区别点实体瘤非实体瘤肿瘤形态实体瘤都会形成肿块，检查可见肉眼或影像学检查不可见，要做成细胞涂片，在显微镜下观察才可见。（当肿瘤细胞侵犯骨头、淋巴结等部位时也可见到实体的病灶。）生长速度相对比较慢快肿瘤分期方法TNM血液中肿瘤细胞的比例和靶蛋白的浓度等生化指标判断治疗方法手术、放疗、化疗以及靶向治疗等多种方法以药物治疗为主，靶向治疗，免疫治疗\CAR-T疗法 正文 部分驱动基因突变对比 危险因素 讲一些觉得有意思的，女性长期在厨房烹饪会增加患肺癌风险。
被动吸烟史大于20年
随访建议 Flow chart for management and follow‐up recommendation of lung nodules in China. Abbreviations: GGN, ground‐glass nodules; MDT, multidisciplinary team; PET‐CT, positron emission tomography‐computed tomography; PS, part‐solid nodules; S, solid nodules; #, increasing diameter ≥ 2 mm.
靶向药物 晚期治疗方案 早期应该就是辅助治疗+手术了
免疫检查点抑制剂 思路 1.使用CT数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8f1b0286a721c1e2431a82ea9e7035d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9f49130f90fe7d7c35591d05acd7685/" rel="bookmark">
			Marching Cubes算法再回顾
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1,确定包含等值面的体元 首先介绍一下 体元的概念，体元是三维图像中由相邻的八个体素点组成的正方体方格，英语也叫 Cube，体元中角点函数值分为两种情况，一种是大于等于给定等值面的值 C0 ,则将角点设为 1 称该角点在等值面内部，否则设为0，在等值面之外，
一般来说，会出现一个角点在内，一个角点在外，则角点之间的连线(也就是体元的边)必然与等值面相交，根据这个原理就能判断等值面与哪些体元相交。
——————————————————————————————————————
三维空间中，平行且相邻的两个二维图像（每个图像中的正方形四个像素顶点组成一个基本的像素图像单元）组成一个基本的三维图像单元。，下图中由6个这样的基本三维图像单元：
vtkImageData结构由尺寸、间距和原点来定义。尺寸标注是沿着每个主轴的体素或像素的数量。原点是数据的第一个切片的左下角的世界坐标位置。间距是沿三个主要轴的像素之间的距离。
原点是数据集左下角的世界坐标位置。
尺寸是沿着三个主要轴的体素或像素的数量。
间距是体素的高度、长度和宽度，或相邻像素之间的距离，这取决于是将数据视为相同的方框还是连续函数中的样本点。
——————————————————————————————————————————
Marching Cubes算法根据一个立方体的8个顶点，判断这8个顶点的每个顶点在等值面的内部还是外部（每个顶点只有“在等值面内”和“在等值面外”这两种状态，设为0和1）从而根据这8个顶点的状态，建立一个包含共256种状态的查找表（根据平面对称性、中心对称性，256种最终降到15种）。
顶点值高于等值在表面的内部，等于等值在表面上，低于等值在表面外。
体元的每个顶点有两种状态，总共有256种，可以制作一个查找表(look up table)
但由于反转状态不变，所以可以减少一半，为128种。
再根据旋转不变形，又可以减少到15种情况。
可以认为这15种情况类似于基，经过旋转，反转可以得到256种状态对应的结果Triangulated Cubes：
根据每个顶点的状态，我们可以为每类制作一个8位索引Cube Numbering：
索引指向边表，给出了边的交叉情况。
相交边的编码——通过编码记录对应的cube，相交边的编号
二进制：00000010
十进制：2
Table[256]表示哪些边有交点
Table[2]=0x103=0000 0010 0000 0011
表示0,1,9号边上有交点
为了避免每次转化成二进制进行解码，可以直接记录与哪些边有交点，之后直接查表即可。
Table2[256][16]
Table2[2]=(0, 1, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
因为每个正方体中最多有1个或4个三角形，所以线性插值就足够了。
2，确定等值面与体元边界的交点 找到含有等值面的体元之后，接下来就是确定等值面与体元边界的交点，体元间的数值都是呈线性变化，求交点时一般采用的是线性插值，如 Case0 中等值面的两个端点 一个在外为( 标记0) ，一个在内 ( 标记为1 ) 则交点为0.5；
3，求等值面的法向量 以上步骤 1，2，3 为实现 MC 算法步骤流程，但利用 VTK ，不需要这么繁琐，主要算法步骤都已经封装到 vtkMarchingCube 类中，使用 vtkMarchingCube 时，需要设置三个参数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9f49130f90fe7d7c35591d05acd7685/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bec7614598680d19484d38d8e49846e/" rel="bookmark">
			2023 年开始写 CSS 会与众不同（Part1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS 的发展速度比以往任何时候都要快。在 Flexbox 和 Grid (https://s.juejin.cn/ds/i8TmVYNt/)之后，CSS 的发展似乎经历了一段漫长的停滞期，但在近几年，CSS 已经新增了许多新功能可用(https://s.juejin.cn/ds/i8Tmg379/)，而且还会有更多新功能即将推出。这个发展速度是令人兴奋的，同时也有些压倒性。
虽然 CSS 新增了很多新功能(https://s.juejin.cn/ds/i8Tmg379/)，但很多 Web 开发者都认为这些花里胡哨的东西并没有给自己带来实质上的变化。换句话说，所有这些花里胡哨的东西（CSS 新特性）实际上改变了你编写 CSS 的方式吗？对于大多数 Web 开发者而言，CSS 的新特性确实影响了今天编写 CSS 的方式，但也许并没有像我预期的那样彻底。
虽然我看到很多博客文章以及我自己的小册《现代 CSS》(https://s.juejin.cn/ds/i8Tmg379/)中有关这些新潮事物的介绍和示例，但我还没有看到这些实际应用在生产或日常中使用。这并不是对任何人或任何事情的抱怨。就我个人而言，我对 CSS 的演进感到非常兴奋。许多最新的功能是我们多年来一直渴望的。确实，其中有一些功能正在逐渐融入我的 CSS 中。虽然不是彻底改变，但足以让我比以往更喜欢编写 CSS。
2023 年对 CSS 来说是重要的一年！ 从年初的 2023 Google I/O 大会(https://developer.chrome.com/blog/whats-new-css-ui-2023)到年底的 WWDC23 大会(https://developer.apple.com/videos/play/wwdc2023/10121/)，还有 @Bramus 在乌得勒支@Frontmania 大会上的分享(https://www.bram.us/2023/10/13/whats-new-in-css-2022-10-12-frontmania/)以及最近 Chrome 团队分享的《CSS Wrapped: 2023!》(https://developer.chrome.com/blog/css-wrapped-2023)都在聊 CSS 的最新特性。我也不例外，我花了半年的时间专门以小册的形式在阐述 CSS 现代特性(https://s.juejin.cn/ds/i8Tmg379/)。很庆幸的是，我的小册所介绍的 CSS 最新特性(https://s.juejin.cn/ds/i8Tmg379/)基本上（达 95% 以上的特性）都在前面这些大会的主题上出现过。
小册地址：https://juejin.cn/book/7223230325122400288
可以说，零零总总有几十个 CSS 新特性得到了主流 Web 平台的支持，可以说 2023 年是 CSS 很重要的一年。这些进展使开发者们曾经认为在 Web 平台上不可能实现的功能成为现实。现在，主流的现代 Web 浏览器都支持 CSS 容器查询（尺寸查询(https://juejin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bec7614598680d19484d38d8e49846e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/265745724a7bebfa9740d26e4c00c02d/" rel="bookmark">
			智能运维：实现网络设备巡检与值班管理的高效与精准
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当前的数字化时代，设备巡检的自动化、智能化已成为企业运营的必备需求。为了帮助企业提升设备巡检的效率和精度，我们研发了一款全新的智能工具——智能运维管理平台。该平台具备设备巡检报告生成、远程终端管理、标签管理、排班管理、单位换算、操作日志查看、MIB工具使用以及流程设置等多项功能。
一、巡检管理：自动化报告与计划
智能运维管理平台支持展示由系统自动生成的设备定期巡检报告，这些报告涵盖了设备的重要运行数据，且无法手动添加。用户可以通过模块查询、发送和下载这些报告，大大提高了设备巡检的效率和精度。此外，自定义巡检计划功能允许用户根据需要设置定时巡检计划任务并生成报告，同时通过邮件通知巡检人员查看巡检结果。
二、远程终端：建立高效会话
智能运维管理平台支持SSH和Telnet连接方式，使用户能够随时随地与主机建立远程会话，进行设备管理和监控。这一功能提供了更加便捷的设备访问和管理方式，提高了运维工作的效率和响应速度。
三、标签管理：简化设备分类
标签管理功能使得用户能够对众多相同类型的设备资源进行快速分类。通过定义标签，用户可以从各种维度对设备进行分类管理，简化了设备资源的管理过程，提高了设备管理的效率和精度。
四、排班管理：优化人员配置
在设备巡检排班管理方面，智能运维管理平台支持查询所有人员的考勤情况，并允许用户对人员进行考勤修改。这使得企业能够更好地掌握员工的工作状态和出勤情况，同时根据实际需求灵活调整排班计划。此外，排班计划模块允许用户设置值班人员及排班类型执行周期，并对值班人员进行考勤排班。这一功能优化了人员配置，提高了巡检工作的效率和质量。
五、单位管理：统一度量单位
为了满足不同模块对单位的需求，智能运维管理平台提供单位之间的换算支持。这确保了在处理不同单位的数据时能够保持统一的标准，提高了数据的准确性和可比性。
六、操作日志：追溯操作历史
所有人员或特定人员的系统操作记录可以查看，这一功能增加了系统操作的透明度，帮助用户回溯和管理系统的使用历史。通过了解用户操作记录，企业可以更好地掌握运维工作的执行情况，及时发现和解决问题。
七、MIB工具：获取系统信息
通过MIB工具，用户可以查看Sysoid的相关数据，获取系统的详细信息。这对于分析和优化系统性能具有重要的价值。通过了解系统状态和性能指标，企业可以及时调整和优化系统配置，提高设备的运行效率和稳定性。
八、流程设置：定制审批流程
智能运维管理平台支持设置系统中需要关联的审批流程，用户可以自定义审核流程节点以及流程提醒。这一功能使得用户能够根据实际需求灵活调整和优化审批流程，提高工作效率和响应速度。通过流程设置功能，企业可以实现审批流程的定制化管理，更好地满足不同场景下的运维需求。
总结：智能运维管理平台作为一款全面、高效的设备巡检解决方案，通过自动化报告与计划、远程终端管理、标签管理、排班管理、单位换算、操作日志查看、MIB工具使用以及流程设置等功能模块的集成，实现了设备巡检的高效与精准。这将极大地提升企业的运营效率和竞争力，为企业的持续发展提供强有力的支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13493bb143e777f7d5f167f5f7a533e4/" rel="bookmark">
			Python中用SpeechRecognition库和 vosk模型来识别语音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中的SpeechRecognition库是一个比较好用的语音识别模块，提供了将语音识别成文字的方法，支持中文识别。
一、SpeechRecognition库的安装
使用pip命令安装即可：
​pip install SpeechRecognition 当安装不成功时，可以强制：
​pip install --force- SpeechRecognition 二、SpeechRecognition库的导入：
import speech_recognition as sr r = sr.Recognizer() 注意：导入库的名称与安装名称的略有不同。
三、识别麦克风输入的语音：
# 麦克风录音 mic = sr.Microphone() with mic as source: print("请说话...") r.adjust_for_ambient_noise(source) audioData = r.listen(source) # print(type(audioData)) 四、或者直接识别语音文件：
# 识别语音文件 audioFile = sr.AudioFile("渔父.mp3") with audioFile as source: audioData = r.record(source) 注意语音文件“渔父.mp3”放在主程序同一文件夹中，故没有指明路径。
不管你是要识别通过麦克风现场输入的语音，还是识别现有的语音文件，最后都是通过
audioData = r.record(source)语句读取到audioData对象中，再通过语音识别模型来识别成文本。 语音识别的模型有很多，如Google Speech API，CMU Sphinx，Vosk等。我们以能线下使用的Vosk模型为例来说明使用方法。
五、安装vosk库
pip install vosk speechrecognition提供了方便的使用vosk的函数
Recognizer.recognize_vosk(audioData) 虽然我们安装了Vosk的库，但好像其中没有包含Vosk语音模型，还需要单独下载。打开VOSK Models链接，可以看到各种语言的语音模型：
我们要识别中文，当然要下载中文语音模型：
下载各个模型到主程序文件夹下，解压，将想要使用的语音模型文件名改为“model”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13493bb143e777f7d5f167f5f7a533e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24521413f3c7f5dbb219596d46f4ee8c/" rel="bookmark">
			损坏硬盘中的数据恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		某日，接到某办公室主任电话，一块用于重要数据备份的硬盘读取不了数据。初步了解，该备份硬盘用于重要数据备份，但一直挂接在电脑中，可能因电脑长时间运转，或硬盘一时的震动，或硬盘品质问题（早期4T硬盘），都有可能造成损坏。
取回硬盘，挂接在自己电脑上，开机后，系统中看不到该硬盘分区，还好，在磁盘管理中可以看到该硬盘，但显示没有分区。
一、初试
重新启动电脑，进入某PE系统，运行“DiskGenius”免费版，显示3.6T空间为“空闲”，意味着硬盘没有分区，和磁盘管理下看到的一样，如下图：
尝试搜索分区信息，无果；恢复文件亦因为没有分区而失败。又尝试了几款数据恢复软件，亦无果。
二、再试
另做了一个某通用PE系统盘，启动后运行“DiskGenius”，这次显示不是免费版，而是专业版。可能因挂有坏的硬盘，读取硬盘公区信息相当艰难，先是花了近十分钟才进入第一个硬盘（因考虑要恢复的数据很大，就没有拆除原硬盘），再点击第二个硬盘（即坏盘），又花了近二十分钟，终于才读出分区信息：
接着又出现分区表错误的提示，先选择“更正”，再选择“保存更改”，提示无法保存。
再几经操作，又出现了图一的“空闲”的提示（图一其实就是这个时候截图的，你可发现上面的专业版字样）。心知不妙，连忙重启，再次进入“DiskGenius”查看该硬盘分区信息，仍显示空闲。无奈只得关机，心中后悔不迭，担心错失了唯一的恢复机会。
三战
过了半天，心有不甘，再次进入系统（这次为了加快速度，把主从盘数据线掉换了，直接进入坏盘），担心不再现的分区信息又出现了，窃喜。分析原因，难道是硬盘冷却下来了，信息又正常了？不得而知。
汲取上次经验，提示更正时选择取消，并直接进入“浏览文件”，选择想备份的两个重要文件夹，右击，复制到指定文件夹，经过N长时间，最后显示复制成功的文件为“0”。
考虑再三，可能是某个子文件夹有损坏，妨碍了拷贝的正常进行。只得逐个进入二级子文件夹，分别拷贝：
拷贝终于成功，只是一方面，每进入一个子文件夹，需要的时间漫长，拷贝过程也漫长，另一方面可能硬盘坏道太多，仍有很多文件拷贝失败。
也曾用相关软件扫描硬盘坏道，但因现在硬盘容量太大，加之又是二盘，扫描时间实在难以忍受，只得中止。其实扫描出来又如何？也没办法改变结果。
总体而言，数据抢救基本成功。
重要的是对重要数据保护的教训：
1、对于重要数据的备份，最好是备份在服务器上或云上，如担心网管等能看到，可以进行加密处理。
2、有人嫌服务器不安全、不方便，用硬盘或移动硬盘备份，注意这种备份介质，备份后要单独脱机保管在保险柜里（最好是双份备份），不能一直挂接在电脑上，甚至常年随身带着，有丢失、损毁的风险。
硬盘有价，重要数据无价。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f078328a53100a39a6d1c3c2d6a02aac/" rel="bookmark">
			java 面试题框架篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java 面试题框架篇 文章目录 java 面试题框架篇**面试官**：Spring框架中的单例bean是线程安全的吗？**面试官**：什么是AOP**面试官**：你们项目中有没有使用到AOP**面试官**：Spring中的事务是如何实现的**面试官**：Spring中事务失效的场景有哪些**面试官**：Spring的bean的生命周期**面试官**：Spring中的循环引用**面试官**：那具体解决流程清楚吗？**面试官**：构造方法出现了循环依赖怎么解决？**面试官**：SpringMVC的执行流程知道嘛**面试官**：Springboot自动配置原理**面试官**：Spring 的常见注解有哪些？**面试官**：SpringMVC常见的注解有哪些？**面试官**：Springboot常见注解有哪些？**面试官**：MyBatis执行流程**面试官**：Mybatis是否支持延迟加载？**面试官**：延迟加载的底层原理知道吗？**面试官**：Mybatis的一级、二级缓存用过吗？ 面试官：Spring框架中的单例bean是线程安全的吗？ 候选人：
嗯！
不是线程安全的，是这样的
当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这是多个线程会并发执行该请求对应的业务逻辑（成员方法），如果该处理逻辑中有对该单列状态的修改（体现为该单例的成员属性），则必须考虑线程同步问题。
Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。
比如：我们通常在项目中使用的Spring bean都是不可变的状态(比如Service类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。
如果你的bean有多种状态的话（比如 View Model对象），就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用由“singleton”变更为“prototype”。
面试官：什么是AOP 候选人：
aop是面向切面编程，在spring中用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合，一般比如可以做为公共日志保存，事务处理等
面试官：你们项目中有没有使用到AOP 候选人：
我们当时在后台管理系统中，就是使用aop来记录了系统的操作日志
主要思路是这样的，使用aop中的环绕通知+切点表达式，这个表达式就是要找到要记录日志的方法，然后通过环绕通知的参数获取请求方法的参数，比如类信息、方法信息、注解、请求方式等，获取到这些参数以后，保存到数据库
面试官：Spring中的事务是如何实现的 候选人：
spring实现的事务本质就是aop完成，对方法前后进行拦截，在执行方法之前开启事务，在执行完目标方法之后根据执行情况提交或者回滚事务。
面试官：Spring中事务失效的场景有哪些 候选人：
嗯！这个在项目中之前遇到过，我想想啊
第一个，如果方法上异常捕获处理，自己处理了异常，没有抛出，就会导致事务失效，所以一般处理了异常以后，别忘了抛出去就行了
第二个，如果方法抛出检查异常，如果报错也会导致事务失效，最后在spring事务的注解上，就是@Transactional上配置rollbackFor属性为Exception，这样别管是什么异常，都会回滚事务
第三，我之前还遇到过一个，如果方法上不是public修饰的，也会导致事务失效
嗯，就能想起来那么多
面试官：Spring的bean的生命周期 候选人：
嗯！，这个步骤还是挺多的，我之前看过一些源码，它大概流程是这样的
首先会通过一个非常重要的类，叫做BeanDefinition获取bean的定义信息，这里面就封装了bean的所有信息，比如，类的全路径，是否是延迟加载，是否是单例等等这些信息
在创建bean的时候，第一步是调用构造函数实例化bean
第二步是bean的依赖注入，比如一些set方法注入，像平时开发用的@Autowire都是这一步完成
第三步是处理Aware接口，如果某一个bean实现了Aware接口就会重写方法执行
第四步是bean的后置处理器BeanPostProcessor，这个是前置处理器
第五步是初始化方法，比如实现了接口InitializingBean或者自定义了方法init-method标签或@PostContruct
第六步是执行了bean的后置处理器BeanPostProcessor，主要是对bean进行增强，有可能在这里产生代理对象
最后一步是销毁bean
面试官：Spring中的循环引用 候选人：
嗯，好的，我来解释一下
循环依赖：循环依赖其实就是循环引用,也就是两个或两个以上的bean互相持有对方,最终形成闭环。比如A依赖于B,B依赖于A
循环依赖在spring中是允许存在，spring框架依据三级缓存已经解决了大部分的循环依赖
①一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象
②二级缓存：缓存早期的bean对象（生命周期还没走完）
③三级缓存：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的
面试官：那具体解决流程清楚吗？ 候选人：
第一，先实例A对象，同时会创建ObjectFactory对象存入三级缓存singletonFactories
第二，A在初始化的时候需要B对象，这个走B的创建的逻辑
第三，B实例化完成，也会创建ObjectFactory对象存入三级缓存singletonFactories
第四，B需要注入A，通过三级缓存中获取ObjectFactory来生成一个A的对象同时存入二级缓存，这个是有两种情况，一个是可能是A的普通对象，另外一个是A的代理对象，都可以让ObjectFactory来生产对应的对象，这也是三级缓存的关键
第五，B通过从通过二级缓存earlySingletonObjects 获得到A的对象后可以正常注入，B创建成功，存入一级缓存singletonObjects
第六，回到A对象初始化，因为B对象已经创建完成，则可以直接注入B，A创建成功存入一次缓存singletonObjects
第七，二级缓存中的临时对象A清除
面试官：构造方法出现了循环依赖怎么解决？ 候选人：
由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的的依赖注入，可以使用@Lazy懒加载，什么时候需要对象再进行bean对象的创建
面试官：SpringMVC的执行流程知道嘛 候选人：
嗯，这个知道的，它分了好多步骤
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f078328a53100a39a6d1c3c2d6a02aac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2d68f1c645c15084cbf3098a60e7c20/" rel="bookmark">
			第五讲_css元素显示模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		css元素显示模式 1. 元素的显示模式1.1 块元素1.2 行内元素1.3 行内块元素 2. 元素根据显示模式分类3. 修改元素的显示模式 1. 元素的显示模式 1.1 块元素 块元素的特性：
在页面中独占一行，从上到下排列。默认宽度，撑满父元素。默认高度，由内容撑开。可以通过 css 设置宽高。 &lt;style&gt; .first { width: 100px; height: 100px; background-color: blue; } .second { height: 100px; background-color: green; } .third { background-color: red; } &lt;/style&gt; &lt;div class="first"&gt;第一个块元素&lt;/div&gt; &lt;div class="second"&gt;第二个块元素&lt;/div&gt; &lt;div class="third"&gt;第三个块元素&lt;/div&gt; 1.2 行内元素 行内元素的特性：
在页面中不独占一行，从左到右排列。默认宽度，由内容撑开。默认高度，由内容撑开。无法通过 css 设置宽高。 &lt;style&gt; .first { background-color: blue; } .second { background-color: green; } .third { background-color: red; } &lt;/style&gt; &lt;span class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2d68f1c645c15084cbf3098a60e7c20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df637171bd9399638734574196eb5741/" rel="bookmark">
			5个完整案例，一次性讲明白Web逆向！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天在群里，看见有Python圈子里的朋友晒了张图，是他最近兼职赚钱的接单记录，在了解详情后我大为震撼，竟然有人单靠Python爬虫做副业就能半个月赚4W多！
可仔细想想，现在正处于Python爬虫接单的高潮期，各类甲方对爬虫服务的需求量其实已经很大了，给出的报酬也很丰厚。
所以对掌握企业级爬虫技术的朋友来说，兼职接单赚4W多似乎也简单。
当下各领域对爬虫服务的需求量虽说很大，但其对技术的要求可一点都不低，通常高价值的爬虫项目都需要攻破各类反爬虫措施才能完成，破不了反爬虫就接不了单赚不到钱。
所以，每天都会有很多人来咨询爬虫逆向破解方面的问题，包括数据解密、web安全、js逆向、补环境、xhr断点、多接口嵌套、加密分析和消息摘要算法在内的反爬虫破解相关技术点是被问及最多的。
结合多年爬虫项目接单经验，这里给想学爬虫接单涨收入的朋友一个建议：其实现在各家的反爬虫措施同质化严重，先吃透几套经典爬虫实战项目，再消化其中经验与规律，多练练手，熟悉之后能很容易攻破大厂反爬虫。
高效变现方案
考虑到高价值的爬虫项目都在名企内部，一般情况下接触不到，即使真有好项目，在缺乏指导的情况下学习也很不容易。
所以，要想快速搞定反爬虫，我建议直接来听一堂企业级爬虫技术的速成课程。
扫码加小助理免费报名
👇👇👇
搞定技术，涨收入！
官方特训费299元，本号粉丝有福利，立即报名可免费学习！
这是一套专讲爬虫逆向破解的高阶技术实战课，迄今为止已帮助超三万学员快速进阶。本次课程将由国际大数据竞赛获奖大佬亲身指导，带领大家进行一线大厂高阶技术体系+多重逆向解析项目实战+技术变现路径指导的综合速成训练！
此次实战训练分为三节课程，是专为高阶爬虫技术速成而设计的，课程内包含多项业界难觅的真实项目，对应每一项案例都有保姆级的拆分详解，深入浅出极易学懂。
顶尖名师的专业指导与规划，搭配最前沿的爬虫逆向实战项目边学边练，在实战中快速累积经验，熟悉之后即可开始尝试接单。
此外，本次课程并不仅限于技术干货传授，更有技术大佬十余年积累的技术变现经验分享。
特训详情
Day 1
1、详解web逆向的作用与定义规则
2、详解数据传输安全与Python逆向破解
3、详解web逆向时对JS进行加密与解密的思路
4、详解浏览器中的快速JS接口验证-合理化爬虫
5、详解JS中XHR断点、关键字搜索、路径定位
6、知名证券理财资讯平台-数据逆向实战
7、BTC数据分析平台-标准算法数据逆向实战
Day 2
1、详解目标快速定位：检索全局加密参数
2、详解请求表单与头部参数多重加密机制
3、详解全局检索方案-区分需要被逆向的参数
4、详解消息摘要算法-MD5与SAH组成与魔改
5、交通出行购票网-机票信息请求接口逆向实战
6、详解互联网高安全架构设计-反爬虫验证与风控
7、详解名企爬虫岗位与兼职求术需求
Day 3
1、详解行为式智能人机验证组成原理
2、详解爬虫技术变现的私活接单流程与方法
3、详解JavaScript全局变量混淆解决方案
4、大型智能风控服务商官网-接口参数逆向实战
5、详解信息安全技术在爬虫领域的运用场景
6、详解名企常见的瑞数安全流程极其解析方案
7、详解浏览器环境(window dom local)与指纹(canvas)补充
特训详情
参与报名并完成特训的朋友，可以免费获得我耗时8个月精心整理的Python爬虫教程包一套！
学完速成干货课程，要第一时间拿大厂高阶项目实战巩固，进一步提升技术，这套资料就非常适合练手！
注意事项
Q：为什么无法添加小助理？
A：一下子很多人报名，小助理的微信可能会出现延迟，过几分钟再添加一次即可。
Q：真的是免费吗？
A:本公众号粉丝仅需0元即可学习，真实有效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbc0abcd4a47c7f20d255d5b2acb5b8a/" rel="bookmark">
			PAT 乙级 1049 数列的片段和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分数 20
作者 CAO, Peng
单位 Google
给定一个正数数列，我们可以从中截取任意的连续的几个数，称为片段。例如，给定数列 { 0.1, 0.2, 0.3, 0.4 }，我们有 (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) 这 10 个片段。
给定正整数数列，求出全部片段包含的所有的数之和。如本例中 10 个片段总和是 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0。
输入格式：
输入第一行给出一个不超过 10
5
的正整数 N，表示数列中数的个数，第二行给出 N 个不超过 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbc0abcd4a47c7f20d255d5b2acb5b8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf7cd8b2da3cc34c34e467fb61e482ab/" rel="bookmark">
			QT_03 QMainWindow、资源、对话框、布局、控件、定时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT - QMainWindow、资源、对话框、布局、控件、定时器 1. QMainWindow 1.1 概述 QMainWindow 是一个为用户提供主窗口程序的类：
包含一个菜单栏（menu bar）多个工具栏(tool bars)多个铆接部件(dock widgets)一个状态栏(status bar)一个中心部件(central widget)许多应用程序的基础，如文本编辑器，图片编辑器等。 1.2 创建QMainWindow项目 1.3 菜单栏 一个主窗口最多 只有一个菜单栏（MenuBar）。位于主窗口顶部、主窗口标题栏下面。
创建菜单栏：
通过 QMainWindow 类的 menubar（ ）函数获取主窗口菜单栏指针 //创建菜单栏: #include &lt;QMenuBar&gt; QMenuBar --&gt; QMenuBar(QWidget *parent = Q_NULLPTR) //添加菜单栏: QMainWindow --&gt; void setMenuBar(QMenuBar *menuBar) 创建菜单：
调用 QMenu 的成员函数 addMenu 来添加菜单 //创建菜单： #include &lt;QMenu&gt; QMenu --&gt; QMenu(const QString &amp;title, QWidget *parent = Q_NULLPTR) //添加菜单： MenuBar --&gt; QAction *addMenu(QMenu *menu) 创建菜单项：
调用 QMenu 的成员函数 addAction 来添加菜单项 //创建菜单项： #include &lt;QAction&gt; QAction --&gt; QAction(const QString &amp;text, QObject *parent = nullptr) //添加菜单项： QMenu --&gt; addAction(const QAction *action) Qt 并没有专门的菜单项类，只是使用一个 QAction 类，抽象出公共的动作。当我们把 QAction 对象添加到菜单，就显示成一个菜单项，添加到工具栏，就显示成一个工具按钮。用户可以通过点击菜单项、点击工具栏按钮、点击快捷键来激
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf7cd8b2da3cc34c34e467fb61e482ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5393fcb1e684f9aa2854bc76bd3d93a/" rel="bookmark">
			MySQL8.0.18通过data文件夹进行数据库迁移（直接复制文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：安装多个版本的数据库，要把数据库A的数据复制到数据库B，我得数据库一个是.msi安装版的，一个是.zip解压版的
先停止两个数据库：net stop mysql(数据库名称)
进入到数据库A所在data文件夹路径，将mysql、mysql.ibd、ibdata1和需要复制的数据库这几个文件夹复制到数据库B的data文件夹下
一定要复制mysql.ibd，不然对应的数据库数据复制不过去的
重启数据库B，之后连接，就可以查看到数据已经复制过来了 参考链接：https://www.jianshu.com/p/fb1781a16e81
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ff940bb53ed73251cb8b3b9f2439b3c/" rel="bookmark">
			推荐一个开源的AT命令解析模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 一种AT命令通信解析模块,支持裸机(at_chat)和OS版本(at)。适用于modem、WIFI模块、蓝牙通信。
软件架构 • at_chat.c at_chat.h list.h
用于无OS版本，使用链式队列及异步回调方式处理AT命令收发，支持URC处理、自定义命令发送与解析作业。
• at.c at.h at_util.h comdef.h
用于OS版本, 使用前需要根据at_util.h规定的操作系统相关的接口进行移植,如提供信号量操作、任务延时等操作。
使用说明 at_chat 模块(无OS) 基本概念 at_chat 模块使用链式队列进行管理，包含2条链表，空闲链表和就绪链表。它们的每一个基本工作单元称为一个作业项，对于将要执行的命令都会放到就绪链表中，命令执行完成之后由空闲链表来进行回收，作业项的定义如下：
/*AT作业项*/ typedef struct { unsigned int state : 3; unsigned int type : 3; /* 作业类型*/ unsigned int abort : 1; void *param; /* 通用参数*/ void *info; /* 通用信息指针*/ struct list_head node; /* 链表结点*/ }at_item_t; 作业是AT控制器定义时固定分配的，没有使用动态内存，默认支持10个作业项，即同时可以允许10个AT命令排队等待处理。
基本接口与描述 • at_send_singlline, 发送单行命令，默认等待OK响应，超时3S
• at_send_multiline, 多行命令，默认等待OK响应，超时3S
• at_do_cmd，支持自定义发送格式与接收匹配串
• at_do_work，支持自定义发送与接收解析
效果演示 详细使用可以参考Demo程序wifi_task.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ff940bb53ed73251cb8b3b9f2439b3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a31beb291395b4b1f21365282faf4594/" rel="bookmark">
			protobuf 学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		protobuf 学习笔记 1. protobuf 的定义 protobuf是一种用于序列化结构数据的工具，实现数据的存储与交换，与编程语言和开发平台无关。
序列化：将结构数据或者对象转换成能够用于存储和传输的格式。
反序列化：在其他的计算环境中，将序列化后的数据还原为结构数据和对象。
下面是一个简单的使用示例:
message SearchRequest { required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3; [default=10] //设置默认值 } 其中后面的数字编号表示；二进制格式中识别各个字段的，一旦开始使用就不能再改变，[1,15]之内的标识号在编码的时候会占用一个字节，之后的[16,2047]会占用两个字节
1.1 指定字段规则: required: 表示该字段必须optional: 可选项，表示该字段必须有0个或者1个值(不超过一个)repeated: 可重复值，相当于List 基本数值类型的repeated的字段并没有被尽可能地高效编码。在新的代码中，用户应该使用特殊选项[packed=true]来保证更高效的编码。如： 注意:在proto3中没有这些选项
repeated int32 samples = 4 [packed=true]; 2. protobuf 的优缺点 2.1、优点
性能高效：与XML相比，protobuf更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单。语言无关、平台无关：protobuf支持Java、C++、Python 等多种语言，支持多个平台。扩展性、兼容性强：只需要使用protobuf对结构数据进行一次描述，即可从各种数据流中读取结构数据，更新数据结构时不会破坏原有的程序。 2.2、缺点
不适合用来对基于文本的标记文档（如 HTML）建模。自解释性较差，数据存储格式为二进制，需要通过proto文件才能了解到内部的数据结构。 3. protobuf 的使用流程 3.1 protoc编译器 使用proto文件定义好结构数据后，可以使用protoc编译器生成结构数据的源代码，这些源代码提供了读写结构数据的接口，从而能够构造、初始化、读取、序列化、反序列化结构数据。使用以下命令生成相应的接口代码：
// $SRC_DIR: .proto所在的源目录 // --cpp_out: 生成C++代码 // $DST_DIR: 生成代码的目标目录 // xxx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a31beb291395b4b1f21365282faf4594/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfd88865881f60d83fc140b6c3c2a947/" rel="bookmark">
			【python设计模式】python单例模式的N种实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们知道，经典设计模式总共有 23 种，但其中只有少数几种被广泛采用。根据我的工作经验，实际常用的可能不超过其中的一半。如果随机找一位程序员，并要求他列举出自己最熟悉的三种设计模式，那么单例模式肯定会是其中之一，这也是今天我们要讨论的。
为什么要单例模式？ 单例设计模式（Singleton Design Pattern）: 一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。
当一个类的功能比较单一，只需要一个实例对象就可以完成需求时，就可以使用单例模式来节省内存资源。
【通常】单例模式创建的对象是进程唯一的, 单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。。
处理资源冲突 class Logger: def __init__(self, file_path): self.file_path = file_path def log(self, message): with open(self.file_path, "a") as file: file.write(message + "\n") class UserController: def __init__(self): self.logger = Logger("/Users/haige/log.txt") def login(self, username, password): # ...省略业务逻辑代码... self.logger.log(username + " logged in!") class OrderController: def __init__(self): self.logger = Logger("/Users/haige/log.txt") def create(self, order): # ...省略业务逻辑代码... self.logger.log("Created an order: " + str(order)) # Logger类的应用示例： user_controller = UserController() user_controller.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfd88865881f60d83fc140b6c3c2a947/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ef2971bec30a3f004075a91d524bb5e/" rel="bookmark">
			工业载码体的应用有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RFID工业载码体是针对工业自动化智能制造的专用射频标签，采用独特的天线设计，坚固的材质，保障载码体在工业环境中的应用。作为一种智能化的标识和数据记录工具，它可以记录各种信息，常应用于智能产线管理、托盘管理、资产管理、设备巡检等识别领域。
工业载码体的应用有哪些?
1、产线管理
零部件追踪：将电子标签贴在零部件上，可以实现对零部件的追踪和管理，方便在生产过程中快速定位零部件的位置，提高零部件的调配和装配效率。
质量管理：通过电子标签记录每个工件的生产过程和检验结果，可以实时监测生产过程中的质量状况，并进行质量追溯和分析，最大程度地减少不良品数量。
2、模具管理
模具追踪：将电子标签贴在模具上，可以实现模具在使用过程中的追踪和管理，包括模具的入库、出库、使用记录、维修历史等。这样可以快速定位模具的位置，提高模具利用率和生产效率。
维护管理：通过电子标签记录模具的使用寿命、维修情况和保养周期，可以及时提醒维护和更换模具，避免因模具损坏而导致的生产中断和质量问题。
3、机床加工
装夹管理：工业载码体电子标签可用于标识和管理不同类型的夹具，并记录夹具的使用寿命、维修情况等信息。通过电子标签，可以实现对夹具的追踪和管理，减少生产中的错误使用和损坏。
车间协调：将电子标签应用于机床上，可以实现与车间管理系统的无线连接，实时获取机床的状态和加工数据，提高生产计划的准确性和时效性，优化生产流程。
4、夹具管理
夹具跟踪：利用电子标签实现对夹具的全生命周期管理，包括购买、维护、定位和报废等。可以实时掌握夹具的使用情况，提高夹具利用率和生产效率。
报警系统：通过夹具上的电子标签与系统连接，可以设置报警机制，当夹具达到设定的使用次数或寿命时，及时提醒更换或检修，减少因夹具故障而引起的生产事故和延误。
通过使用工业载码体电子标签，减少了繁杂的手工操作和纸质记录，大大提高了信息的准确性和处理效率。通过与物联网和后台系统结合，可以实时获取和管理数据，提供准确的生产信息和决策依据，推动传统制造业向智能制造的转型升级!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffa9ca4a6df441c750b257ae62ee81f0/" rel="bookmark">
			Leetcode459:重复的字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解题思路：
如果您的字符串 S 包含一个重复的子字符串，那么这意味着您可以多次 “移位和换行”`您的字符串，并使其与原始字符串匹配。 例如：abcabc
移位一次：cabcab
移位两次：bcabca
移位三次：abcabc
现在字符串和原字符串匹配了，所以可以得出结论存在重复的子串。
基于这个思想，可以每次移动k个字符，直到匹配移动 length - 1 次。但是这样对于重复字符串很长的字符串，效率会非常低。在 LeetCode 中执行时间超时了。
为了避免这种无用的环绕，可以创建一个新的字符串 str，它等于原来的字符串 S 再加上 S 自身，这样其实就包含了所有移动的字符串。
比如字符串：S = acd，那么 str = S + S = acdacd
acd 移动的可能：dac、cda。其实都包含在了 str 中了。就像一个滑动窗口
一开始 acd (acd) ，移动一次 ac(dac)d，移动两次 a(cda)cd。循环结束
所以可以直接判断 str 中去除首尾元素之后，是否包含自身元素。如果包含。则表明存在重复子串。
class Solution { public boolean repeatedSubstringPattern(String s) { String str=s+s; return str.substring(1,str.length()-1).contains(s); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c57afc374aaacd887cc2f51d655c81/" rel="bookmark">
			服务器迁移上云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、服务器迁移上云 1、服务器迁移概念： 服务器迁移一般来说是将物理服务器从一个地点（物理机房）移动到另一个地点，或将数据从一台服务器移动到另一台服务器的过程。
物理服务器迁移场景：
● 机房搬迁：当公司办公场所发生变化，原有机房无法继续使用时，需要将服务器迁移到新机房。
● 系统升级：当服务器操作系统或软件版本过旧或不支持业务需求时，需要进行系统升级，并且需要将数据迁移到新系统上。
● 服务器更换：当服务器硬件老化或出现故障时，需要更换新的服务器，并将原有数据迁移到新服务器上。
● 数据中心合并：当业务从IDC机房（物理服务器托管、租赁）搬迁到公司自建机房时，需要将不同数据中心的服务器整合到一个新的数据中心中。
● 架构改造：当公司网络架构进行调整时，需要重新规划服务器位置。
2、服务器迁移上云： (1) 概念： 服务器迁移上云是指将原先运行在企业自有机房中的服务器、数据库、存储等基础设施资源，迁移到云服务商的数据中心，并运行在云服务商提供的云计算环境中。
(2) 服务器的迁移上云场景： ① 构建混合云：将公司中承载业务的老旧物理服务器迁移到云计算服务商，其他现有服务器在生命周期内依旧运行在本地，后期再慢慢迁移至公共云，这种在本地和云端同时运行业务的情况称为混合云。
② 迁移至公共云：将所有服务器都迁移至公共云，迁移结束后，本地不再拥有机房和服务器等设施。
③ 不同公共云之间的迁移：将应用程序、数据或服务从一个云平台或环境迁移到另一个公共云服务提供商的平台或环境。
④ 迁移到多个云：为了提升整体架构的可用性，将公司中承载业务的服务器从自有数据中心迁移到多个公共云上共同运营，规避单个云故障带来的损失。
(3) 服务器迁移上云方案： ① 虚拟机（VM）迁移：将本地虚拟机按照阿里云要求制作成镜像，然后将当前系统的镜像文件导入到阿里云上，并通过镜像创建云服务器。
② 物理服务器迁移：将物理机转化成虚拟机(P2V)，然后将虚拟机制作成镜像，并通过镜像创建云服务器，在阿里云上运行云服务器。
③ 阿里云服务器迁移服务：使用阿里云迁移工具(SMC)将本地的虚拟机、物理机以及其他云厂商那里的云主机等内容完成迁移上云。
(4) 服务器迁移上云方式： 业务服务器迁移至云环境通常都包含全量迁移和增量迁移两种方式：
① 全量迁移：指的是将数据、应用程序和账户信息等完整复制至新的云平台，然后在新环境中重新部署和调试测试等工作。
全量迁移是一种极其彻底的迁移方法，可以确保所有内容、环境和配置均与源服务器一致。
② 增量迁移：增量迁移意味着将迁移的过程分开并实施为几个阶段，可以减少干扰和风险，避免在整个迁移过程中发生大规模的停机时间。
二、服务器迁移中心SMC 1、简介： 服务器迁移中心SMC是阿里云提供的专业的服务器迁移服务，具有以下特点：
① 快速：由于SMC采用增量复制技术，只会传输新数据而不需要传输镜像和重建系统等过程，大大提高了迁移效率。
② 稳定可靠：在整个迁移过程中，SMC可以自动检测并解决迁移时出现的各种问题，如适配网络环境、对接各种虚拟化软件、处理不同操作系统平台，保证了迁移的稳定性和可靠性。
2、通过SMC迁移至阿里云的步骤： ① 完成迁移上云前的准备工作
② 根据迁移服务器的类型导入迁移源至阿里云
③ 使用导入的迁移源创建并启动迁移任务
④ 在完成迁移后进行迁移收尾工作
3、服务器迁移前的准备工作： ① 确定需要迁往云端的服务器的位置以及列表。
② 注册阿里云账号，并完成实名认证。
③ 在RAM服务中，授权AliyunSMCDefaultRole角色。
4、导入源服务器到阿里云： (1) 选择迁移源： SMC支持物理机/虚拟机/云服务器、阿里云ECS云服务器、VMware虚拟机三种类型的迁移源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04c57afc374aaacd887cc2f51d655c81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f05e96612136a2cb3e4515ed43088c05/" rel="bookmark">
			将mask的图片标签转换为yolo的txt标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将mask的图片标签转换为yolo的txt标签 获取外轮廓 import copy import cv2 import os import shutil import numpy as np path = "你的mask路径 /Dataset/mask" files = os.listdir(path) for file in files: name = file.split('.')[0] file_path = os.path.join(path,name+'.png') img = cv2.imread(file_path) # img = cv2.imread(path) H,W=img.shape[0:2] print(H,W) #img1 = cv2.imread("F:/Deep_Learning/Model/YOLOv8_Seg/Dataset/images/20160222_080933_361_1.jpg") gray_img = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) ret,bin_img = cv2.threshold(gray_img,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU) cnt,hit = cv2.findContours(bin_img,cv2.RETR_TREE,cv2.CHAIN_APPROX_TC89_KCOS) #cv2.drawContours(img1,cnt,-1,(0,255,0),5) cnt = list(cnt) f = open("标签保存路径 Dataset/labels/{}.txt".format(file.split(".")[0]), "a+") for j in cnt: result = [] pre = j[0] for i in j: if abs(i[0][0] - pre[0][0]) &gt; 1 or abs(i[0][1] - pre[0][1]) &gt; 1:# 在这里可以调整间隔点，我设置为1 pre = i temp = list(i[0]) temp[0] /= W temp[1] /= H result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f05e96612136a2cb3e4515ed43088c05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d42c4381791fbe03883c9fc07760f8b/" rel="bookmark">
			K8S API访问控制之RBAC利用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 K8S对于API的访问安全提供了访问控制，主要为4个阶段，本文为第二个阶段——鉴权的RBAC。RBAC是基于角色的访问控制，使用kubeadm安装集群1.6版本以上的都默认开启了RBAC。本文主要研究集群可能存在的利用点及相对应的利用手法。
API访问控制 K8S的API访问控制就是通过如 kubectl、构造REST请求，去访问K8S的API，请求到达API时经历的多个阶段就是K8S的API访问控制，而RBAC就是其中鉴权的部分，并且是现在的主要方式，kubeadm安装的集群从1.6版本以后都默认开启了RBAC和Node的鉴权方式。
图 API访问控制的流程[1]
RBAC-基于角色的访问控制 RBAC[2]就是基于角色（Role）的访问控制，是一种基于组织中用户的角色来调节控制对计算机或网络资源的访问的方法。RBAC 鉴权机制使用rbac.authorization.k8s.io API 组[3]来驱动鉴权决定，允许通过 K8S API 动态配置策略。要启用 RBAC，在启动 API 服务器时将--authorization-mode参数设置为一个逗号分隔的列表并确保其中包含 RBAC。
kube-apiserver --authorization-mode=Node,RBAC --&lt;其他选项&gt; --&lt;其他选项&gt; API对象 RBAC API 声明了四种 K8S 对象：Role、ClusterRole、RoleBinding 和 ClusterRoleBinding。
Role和ClusterRole RBAC 的 Role 或 ClusterRole 中包含一组代表相关权限的规则。这些权限是纯粹累加的（不存在拒绝某操作的规则）。如果你希望在名字空间内定义角色，应该使用 Role；如果你希望定义集群范围的角色，应该使用 ClusterRole。Role 或 ClusterRole 对象的名称必须是合法的路径分段名称[4]。
Role Role主要用来设置命名空间的访问权限，在创建时必须指定namespace。下面是一个位于 "default" 命名空间的 Role 的示例，可用来授予对 Pod[5] 的读访问权限：
apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: default name: pod-reader rules: - apiGroups: [""] # "" 标明 core API 组 resources: ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d42c4381791fbe03883c9fc07760f8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbb89637bfcafb082d44e4b50d1a0e7f/" rel="bookmark">
			【前沿技术杂谈：迁移学习】迁移学习是在航空业实现人工智能的最后一步吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【前沿技术杂谈：迁移学习】迁移学习是在航空业实现人工智能的最后一步吗？ What is “transfer learning”? 什么是“迁移学习”？航空业迁移学习的一个真实例子：预测跑道占用率迁移学习的挑战以及如何应对这些挑战结论和未来的帖子 机器学习模仿人类如何通过经验获取知识。然而，人类也可以在不同的任务之间转移知识。假设您知道如何弹吉他——学习如何弹奏班卓琴对您来说有多难？钢琴呢——你需要多少进一步的学习？
这种建立在以前经验之上的理论，而不是从头开始学习，是当今机器学习的一个热门话题。这种方法称为迁移学习。 正如Andrew NG在NIPS 2019教程中评论的那样：“在监督学习之后 - 迁移学习将成为ML商业成功的下一个驱动力”。
What is “transfer learning”? 什么是“迁移学习”？ 迁移学习是一个令人兴奋的概念，它旨在重新发展机器学习模型需要从头开始重建的传统观念，即使新的案例研究只是一个特征（领域变量）分布变化。通过迁移学习，您不必一次又一次地训练模型，而是可以使用为一项任务获得的知识来解决相关任务。
数据科学中迁移学习背后的关键概念是深度学习模型。它们需要大量数据，如果你的模型也是受监督的，这意味着你需要大量的标记数据。参与机器学习项目的每个人都知道，标记数据样本非常繁琐且耗时。由于缺乏标记的训练数据，此过程会减慢您的模型开发团队的速度，甚至会阻止成功的机会。深度学习解决方案的另一个常见问题是，尽管最先进的算法具有很高的准确性，但它们依赖于非常具体的数据集，并且在实际操作场景中引入新的模式和案例时会遭受巨大的性能损失。
迁移学习并不是一个新概念，实际上可以追溯到NIPS 1995研讨会“学习学习：归纳系统中的知识巩固和转移”。除了用于改进深度学习模型外，迁移学习还用于构建和训练机器学习模型的新方法。
传统机器学习与迁移学习 航空业迁移学习的一个真实例子：预测跑道占用率 举例来说，我们在一个名为 Safeclouds.eu 的 H2020 项目中开发了一个机器学习模型。该模型试图准确预测距离跑道阈值 2NM 处的到达跑道占用时间 (AROT)：
我们得到了一个庞大的数据集，该数据集由已知的 AROTs 标示，其中包含在特定机场（维也纳机场，LOWW）的特定跑道（R34）上的运行情况。数据集由不同的数据源（雷达轨迹、飞行计划、天气信息等）组成。我们利用这些数据训练了一个机器学习模型。该模型对属于该领域的未见数据点（即 LOWW 机场的 R34）进行了很好的泛化。我们将这项预测任务称为 T1。假设我们想将训练好的模型应用到另一个机场的另一条跑道上，例如巴塞罗那机场（LEBL）的 25R 跑道。让我们把这项新任务称为新领域中的 T2。从理论上讲，我们应该能够将经过训练的模型应用于 T1，但新的预测会观察到巨大的性能下降。这是机器学习中一个众所周知的问题：当域发生变化时，我们会向模型引入偏差。在这种情况下，我们也会注意到 T2 的数据比 T1 的数据少得多。在训练另一个模型时，我们没有足够的样本来在预测方面表现出色。因此，只剩下一种解决方案：应用迁移学习，使用 T2 可用的新数据“重新训练”我们的 T1 模型。 通过遵循这种方法，我们可以将我们的预测模型推广到全球每个机场！
迁移学习的挑战以及如何应对这些挑战 事实上，将预训练模型用于新任务/领域的想法并不那么容易应用。例如，如果两个域不同，它们可能具有不同的特征空间或不同的边缘分布。这意味着描述您的新研究案例的变量可能不同。
此外，当两个任务不同时，它们可能会呈现不同的标签空间或不同的条件分布。这可能意味着可能会出现新的、未见过的情况，并且您的模型可能会专注于检测不平衡的情况（例如很少发生的新情况）。
为了事先解决这些问题，我们需要回答一些问题：
我们需要迁移什么？：我们需要确定模型知识的哪些方面与新案例研究相关。通常，这涉及评估源和目标的共同点。功能相同吗？目标变量是否处于相似分布？有新课程吗？什么时候迁移是安全的？ 在某些情况下，迁移学习不仅不可行，反而会使模型变得更糟（称为负迁移）。我们需要仔细评估这两种情况，并与这两种情况下的领域专家反复确认。我们应该如何转移？ 一旦我们确定了需要转移的内容以及它是否可行，我们就必须确定跨领域/跨任务转移知识的正确方法。了解哪些现有算法和技术适用是非常重要的。别担心，我们将在下一篇文章中介绍一些迁移学习算法。 结论和未来的帖子 迁移学习是迄今为止最有前途的机器学习主流产品推动者。该行业可能需要采用它，以便提供可以快速原型化的可靠解决方案。我个人认为这将成为未来某个关键的方法论。例如，近年来，用于计算机视觉或语音识别的预训练模型库已经出现（Google BERT、PyTorch 的 torchvision、Tensorflow 模型、fastAI 等）。
在以后的文章中，我们将介绍现有的迁移学习方法和算法，以及来自知名机器学习参与者的一些迁移学习的成功用例。敬请关注！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d274d028b27557e2808f6b0214c324/" rel="bookmark">
			Spring整合MyBatis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建工程 1.1pom.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;Spring&lt;/artifactId&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;spring_mybatis&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring常用依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.25&lt;/version&gt; &lt;/dependency&gt; &lt;!--连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57d274d028b27557e2808f6b0214c324/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb09305ac586f90210c536a2e729f6f5/" rel="bookmark">
			代码随想录60天总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 刷题2. 解题心得3. 笔记心得：感悟 notion笔记：数据结构与算法
1. 刷题 我知道、也体会过一开始刷题确实很痛苦，
求求你一定要坚持住！一定要坚持下来！
你不需要彻底明白这道题！你做到一知半解就可以！
你不需要自己能写出来，自己跟着抄一遍就可以！
你不需要自己有思路，能学会别人的思路就已经很好了！
你不需要做完每道题，坚持每天完成一道就已经很厉害了！
你不必完美要求自己，只要比之前的自己有进步就很棒了！
🙏求求你一定要坚持下去！ 只要每次你比上次明白的多那么一点点！就是进步！
健身的人都知道，如果放弃训练，那么就不可能有进步，如果每次能都比上次突破一点点🤏坚持下来，回头再看！自己竟然达到了不可思议的进步！
健身的人还明白另一个道理！不可能每次训练都比上一次强，有状态好的时候，有状态差的时候！还有一直停滞不前的瓶颈期。但我们依然没有因为这次的退步而放弃训练！ 我们相信进步是波折上升的，瓶颈期是终会突破的！
只要！只要！只要不放弃！坚持下来！
只要不放弃！即使有一次比上一次差！
只要不放弃！即使一直没有进步！
只要不放弃！就是变强了！ 💪
2. 解题心得 1.不要只局限于细节，整体上对解题步骤要清晰
多反思，多次看题，当做完题目，再从头过一遍题目，从中感悟、提取解体思路。此时你对此题的又一个更加清晰的认识。
2.做完题，需要检验自己是否真的掌握其中知识点
如何检验自己？
a. 向别人讲诉这道题，如果你能让他懂，说明你掌握的可以了
b. 多问自己几个问题，看是否能回答上来？
3. 笔记心得： 写笔记，但不要沉迷于笔记，在此之上浪费太多时间！
重点加粗，语言简练，不要啰嗦！当你啰嗦的时候，说明你之前的表达并不清晰，应该去修正表达（重构），而不应该继续啰嗦，在屎山上堆屎，容易把人绕(臭)晕。
针对有点强迫症、完美主义者:
要允许自己犯错。 让自己勇于踏出第一步，开始尝试记录、表达自己！允许不完美的存在。 不要花费过多时间纠结于一个事情。比如：不要过于投入到一个道题消磨时间，不要过于在意笔记是否美观，从而不断的修改，完全可以在之后空闲时间修改。 感悟 回顾过去这60天，成功完成了每一天的打卡，但我并不是从头到尾每天都坚持完成！ 我中间中断了一个星期、甚至达到了两个星期！但我又重新拾起来，坚持了下去！开始一点一点的补打卡，终于在60天的时候完成了所有打卡！只要最终不放弃！中途掉队也没关系！
没想到自己也已经写了2w3k多字的笔记，小小成就，记录一下！也给卡哥仓库提了pr，虽然现在还没有处理！也想出了比卡哥更优解题方案，在卡哥代码的基础上进行优化！这些都是进步！
从一开始1个小时甚至2小时解一道题、找bug，随着不断的练习，我感到自己越写越熟练、越来越能轻松的理解解题思路！
继续加油吧！
notion笔记已发布，可以复制到你的空间中进行编辑
数据结构与算法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/680b841cf20a640baf2b736714dfa003/" rel="bookmark">
			ChatGPT(GPT 4.0)论文润色指南&#43;最全提示词/咒语（建议收藏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
分布优化论文
前言 在这篇文章中，我将分享如何利用ChatGPT 4.0辅助论文写作的技巧，并根据网上的资料和最新的研究补充更多好用的咒语技巧。
GPT4的官方售价是每月20美元，很多人并不是天天用GPT，只是偶尔用一下。如果调用官方的GPT4接口，就可以按使用量付费，用多少付多少，而且没有3个小时的50条的使用限制。但是对很多人来说调用接口是比较麻烦的，如果开发一个网站，后台调用gpt4的接口，大家一起用，分摊一下服务器的成本，就比较划算了。见文末【参考链接】
分布优化论文 GPT不应该被理解为一个只接收命令的机器。在对话的过程中，不只是你提要求，它来回答。它完全可以作为一个对话者，参与到你的工作过程中来，可以对你提问题，引导你思考。
有时候，之所以无法掌握好如何用GPT润色，最关键的原因是：
「你看到一个内容，觉得不对劲，但是你不知道应该怎么修改。」
你只是觉得这段话写的有问题，但是你不知道问题出在哪里！
那这个时候，需要一些引导思考的提示词。
提示词模板：
提示：这是我希望润色的论文片段：
[在此处插入论文片段]。
我的关注点主要在于提升这个片段的写作质量，但我目前不太确定如何有效改进。现在需要您打破这个局面，请您阅读，并提出一个核心的选择问题，以确定我应该首先关注的改进领域。我将根据这个问题进行回答，然后您可以根据我的回答进一步缩小问题范围，并继续提出更具体的选择问题。两步选择之后，确定优先润色策略，并帮我完成中文润色。
对话展示：
这就是这种引导提问的好处，也就是在此之前，你可能都不清楚可能从这个两个角度去思考！
所以这种引导提问的最终目的是找到心中那个“想描述缺描述不出来”的要求。
现在，你完全可以按照它的提问，继续走下去：
选择完这一步之后，就可以执行最终的润色命令。 这是因为我在提示词里面明确了「两步选择之后」，你完全可以根据自己的需要来进行灵活的调整。
“世间多少好答案，在等待一个好问题。”
这种「引导提问」的思想核心，其实正是通过GPT的引导，帮助我们来提出一个好问题。
参考链接：
https://chat.xutongbao.top/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccdcde9a4671e7fe48fa6f36d59b5b40/" rel="bookmark">
			物联网超高速发展，目前存在的灾难性问题无法解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当灾难在1秒内发生，传感器无法马上进行报警，在1秒内传感器可能被瞬间损坏、物联网只能应用用在灾难即将发生，对于突发没有前兆的灾难无法进行精确预测。所以可以通过民航飞机的黑匣子记录方案，在传感器应用的物联网高端领域仪器设备上安装黑匣子来记录，最后找问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d422a29f3f7c649e25512d3e61d49776/" rel="bookmark">
			在使用foreach 与 Iterator 时不能有数据的修改以及循环内部累加器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		foreach 与 Iterator java中自遍历不能有累加器 我们知道，在Java中使用foreach对集和进行遍历时，是无法对该集和进行插入、删除等操作，比如以下代码：
for(Person p : personList){ if(StringUtil.isBlank(p.getName())){ personList.remove(p); } } 执行代码，报以下异常：
Exception in thread "main" java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909) at java.util.ArrayList$Itr.next(ArrayList.java:859) at com.xiuhao.service.ForeachDemo.main(ForeachDemo.java:20) 根据错误提示，定位ArrayList的源码，找到以下内容：
/** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; { int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; Itr() {} public boolean hasNext() { return cursor !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d422a29f3f7c649e25512d3e61d49776/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8d383a6693f84c8d44b3fea8f39e3c9/" rel="bookmark">
			【一对一小组】2024年有三AI-CV高阶-项目实战组发布，超过30个案例，60小时项目实战...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年有三AI-CV高阶-项目实战组正式发布！有三AI已经推出了CV初-中-高级培养计划（原名有三AI-CV季划），这是我们的终身计算机视觉学习小组。
该培养计划具有以下特点：
【系统性】配套有非常完备的理论与实践
【永久性】不限制学习期限，一直有效
【成长性】内容保持更新，不额外收费
【专业性】原创书+视频讲解+真实项目锻炼
【丰富性】数千页PPT，文档，项目等
【权威性】工业界资深背景辅导老师，弱运营属性
什么是有三AI-CV高阶-项目实战组
这是我们最高等级的CV学习小组，表示对参与者有更高的基础要求。在这个小组里，我们不再去系统性地学习深度学习与计算机视觉的基础理论知识，而是假设大家已经有了非常好的基础功底，我们直接进行计算机视觉各个领域的项目实战，目前已有超过30个CV各方向的实战案例，超过60小时配套视频讲解，提供代码数据下载。
项目小组配套的视频课程
包含我们平台绝大多数项目实战类课程，并赠送一些基础专栏，目前已有37期，分布在图像分类方向，分割检测方向，视频分析方向，生成对抗网络方向，模型优化部署方向，人脸应用方向，超过60小时配套视频讲解。本小组内容会尽量覆盖住CV的各个方向。从数据的使用，CV的基础方向，到模型的进阶，以及前沿的领域，下面是截止到今日的案例。
(1) 图像分类方向
包含了对于新手非常友好的入门级项目，内容主要是在图像分类基础模型的使用等方向，包括从零搭建CNN模型，学会使用Pytorch数据增强，完全掌握ResNet，GoogLeNet，SENet，BCNN，EfficientNet等经典模型的细节。
【项目实战课】AI零基础，人人免费可学！基于Pytorch的SimpleNet人脸表情识别实战
【项目实战课】人人免费可学！基于Pytorch的图像分类简单任务数据增强实战
【项目实战课】人人免费可学，基于Pytorch的BCNN鸟类细粒度图像分类实战
【项目实战课】人人免费可学，基于ResNet的生活垃圾图像分类实战
【项目实战课】基于Pytorch的InceptionNet花卉图像分类实战
【项目实战课】基于ResNet的生活用品多标签图像分类实战
【项目实战课】基于Pytorch的的SENet人种图像分类实战
【项目实战课】基于Pytorch的EfficientNet血红细胞分类竞赛实战
(2) 图像分割与检测方向
学会从零搭建更复杂的模型，使用更复杂的数据增强，掌握图像分割、目标检测、目标跟踪经典任务。
【项目实战课】人人免费可学！基于Pytorch的SimpleNet嘴唇图像分割实战
【项目实战课】基于Pytorch的Semantic_Human_Matting（人像软分割）实战
【项目实战课】基于Pytorch的BiseNet表面缺陷分割实战
【项目实战课】基于Pytorch的YOLOv3工业缺陷检测实战
【项目实战课】快速上手目标检测任务，MMdetection框架详细解读与案例实战
【项目实战课】基于Pytorch的SiameseFC通用目标跟踪实战
(3) 视频分析方向
掌握视频分类与行为识别领域的经典模型，当前已经包括3DCNN模型，双流模型，LSTM时序模型。
【项目实战课】基于Pytorch的3DCNN视频分类与行为识别实战
【项目实战课】基于Pytorch的CNN_LSTM视频分类与行为识别实战
【项目实战课】基于Pytorch的SlowFast模型视频分类与行为识别实战
(4) 生成对抗网络方向
掌握生成对抗网络在图像生成，图像风格化，图像增强，图像编辑等各个领域的经典模型，非常经典必须掌握的包括DCGAN模型，StyleGAN模型，Pix2Pix与CycleGAN模型等。
【项目实战课】基于Pytorch的DCGAN人脸嘴部表情图像生成实战
【项目实战课】基于Pytorch的StyleGAN v1人脸图像生成实战
【项目实战课】基于Pytorch的StyleGAN人脸属性（表情、年龄、性别）编辑实战
【项目实战课】基于Pytorch的Pix2Pix黑白图片上色实战
【项目实战课】基于Pytorch的SRGAN图像超分辨实战
【项目实战课】基于Pytorch的SRGAN图像超分辨实战
【项目实战课】基于Pytorch的Real-ESRGAN自然图像超分辨实战
【项目实战课】基于Pytorch的BeautyGAN人脸智能美妆实战
【项目实战课】基于Pytorch的StarGAN人脸表情编辑实战
【项目实战课】基于Pytorch的DANet自然图像降噪实战
【项目实战课】基于Pytorch的EnlightenGAN自然图像增强实战
(4) 模型优化与部署方向
掌握模型剪枝，模型量化，模型蒸馏等模型优化压缩技术，掌握服务端，嵌入式平台模型部署框架，当前已经包括结构化模型剪枝，8bit模型量化，微信小程序部署，Android端原生Pytorch模型部署等内容。
【项目实战课】基于ncnn框架与KL散度的8bit对称模型量化与推理实战
【项目实战课】基于Pytorch的稀疏约束结构化模型剪枝实战
【项目实战课】人人免费可学！基于Pytorch的图像分类经典知识蒸馏实战
【项目实战课】微信小程序图像识别模型前后端部署实战
【项目实战课】从零实现原生Pytorch安卓端图像分类模型部署
(5) 人脸与人体方向
掌握人脸与人体检测，人脸与人体识别，人脸与人体重建等相关应用，当前已包含经典的RetinaFace人脸检测，PFLD人脸关键点检测，MTCNN- VGG人脸识别等内容。
【项目实战课】基于Pytorch的RetinaFace人脸与关键点检测实战
【项目实战课】基于Pytorch的PFLD人脸关键点检测实战
【项目实战课】基于Pytorch的MTCNN与Centerloss人脸识别实战
当然，除了以上的项目实战类课程，考虑到部分学员的基础比较差，我们给大家额外赠送了2套基础专栏，分别是《深度学习之图像分类：理论实践篇》，《深度学习之模型设计：理论实践篇》，各自介绍如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8d383a6693f84c8d44b3fea8f39e3c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77e2e65f72fc2b5606c6bcf819c8d204/" rel="bookmark">
			SpringMVC 写个 HelloWorld
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、SpringMVC简介1、什么是MVC2、什么是SpringMVC3、SpringMVC的特点 二、HelloWorld1、开发环境2、创建maven工程a&gt;添加web模块b&gt;打包方式：warc&gt;引入依赖 3、配置web.xmla&gt;默认配置方式b&gt;扩展配置方式 4、创建请求控制器5、创建springMVC的配置文件6、测试HelloWorlda&gt;实现对首页的访问b&gt;通过超链接跳转到指定页面 7、总结 一、SpringMVC简介 1、什么是MVC MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分
M：Model，模型层，指工程中的JavaBean，作用是处理数据
JavaBean分为两类：
一类称为实体类Bean：专门存储业务数据的，如 Student、User 等一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。 V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据
C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器
MVC的工作流程：
用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器
2、什么是SpringMVC SpringMVC是Spring的一个后续产品，是Spring的一个子项目
SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的首选方案。
注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet
3、SpringMVC的特点 Spring 家族原生产品，与 IOC 容器等基础设施无缝对接基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案代码清新简洁，大幅度提升开发效率内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可性能卓著，尤其适合现代大型、超大型互联网项目要求 二、HelloWorld 1、开发环境 IDE：idea 2019.2
构建工具：maven3.5.4
服务器：tomcat7
Spring版本：5.3.1
2、创建maven工程 a&gt;添加web模块 b&gt;打包方式：war c&gt;引入依赖 &lt;dependencies&gt; &lt;!-- SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77e2e65f72fc2b5606c6bcf819c8d204/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/827caea9597d9c1815c8d0399e01a4c4/" rel="bookmark">
			ANSYS Zemax OpticStudio 各版本安装指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ANSYS Zemax OpticStudio下载链接
https://pan.baidu.com/s/1eIJjF93-ZC2CZWn3DGXkkA?pwd=0531
1.解压安装包：①鼠标右击【Zemax2024(64bit)】压缩包②选择电脑上安装的解压软件（如：360压缩）③点击【解压到 Zemax2024(64bit)】。
2.打开解压后的文件夹，双击打开【License】文件夹。
3.鼠标右击【Setup】选择【以管理员身份运行】。
4.点击【安装 ANSYS License……】。
5.点击【OK】。
6.选择【I agree……】，点击【下一个】。
7.修改路径地址中的第一个字符C可更改安装位置（如：把C改为D软件将安装到D盘，不要修改其它字符），点击【下一个】。
8.点击【下一个】。
9.点击【下一个】。
10.安装中……
11.点击【下一个】。
12.点击【退出】。
13.在弹出的网页界面，点击【Get System……】，鼠标右击“MAC Address”后方的字符选择【复制】（不要关闭此网页继续后续步骤）。
14.点击【退出】。
15.打开安装包解压后的【Zemax2024(64bit)】文件夹，双击打开【Program Files】文件夹。
16.双击打开【ANSYS Inc】文件夹。
17.双击打开【license】文档。
18.选中“软件管家”鼠标右击选择【粘贴】。
19.点击右上角【X】后选择【保存】。
20.回到步骤13所在网页界面，点击【Add a license File】，点击【Choose File】。
21.选择安装包中“\Zemax2024(64bit)\Program Files\ANSYS Inc”下的【license】，点击【打开】。
22.点击【INSTALL LICENSE FILE】。
23.提示“…… successfully”后点击右上角【X】退出。
24.打开安装包解压后的【Zemax2024(64bit)】文件夹，鼠标右击【Setup】选择【以管理员身份运行】。
25.点击【Options】。
26.修改路径地址中的第一个字符C可更改安装位置（如：把C改为D软件将安装到D盘，必须与步骤7修改的字符一致），点击【OK】。
27.勾选【I agree……】，点击【Install】。
28.安装中……
29.点击【Close】。
30.打开安装包解压后的【Zemax2024(64bit)】文件夹，双击运行【Ansys Optics……】。
31.点击【Next】。
32.勾选【I agree……】，点击【Next】。
33.修改路径地址中的第一个字符C可更改安装位置（如：把C改为D软件将安装到D盘，必须与步骤7修改的字符一致），点击【Next】。
34.点击【Install】。
35.安装中……
36.点击【Finish】。
37.打开安装包解压后的【Zemax2024(64bit)】文件夹，鼠标右击【Program Files】选择【复制】。
38.打开修改后的磁盘位置（如：步骤7修改的磁盘为D，则打开D盘），鼠标右击空白处选择【粘贴】。
39.点击【替换目标中的文件】。
40.①鼠标右击桌面【此电脑】②点击【属性】③点击【高级系统设置】。
41.点击【高级】，点击【环境变量】。
41.点击【高级】，点击【环境变量】。
42.①在系统变量下方点击【新建】②输入变量名【ANSYSLMD_LICENSE_FILE】和变量值【1055@localhost】③点击【确定】④点击【确定】。
43.打开安装包解压后的【Zemax2024(64bit)】文件夹中的【Program Files】文件夹，双击运行【Solid……】。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/827caea9597d9c1815c8d0399e01a4c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c09cdc06909dc8ba247da9542602e310/" rel="bookmark">
			Spark基础原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spark On Yarn Spark On Yarn的本质 Spark专注于分布式计算,Yarn专注于资源管理,Spark将资源管理的工作交给了Yarn来负责
Spark On Yarn两种部署方式 Spark中有两种部署方式，Client和Cluster方式，默认是Client方式。这两种方式的本质区别，是Driver进程运行的地方不一样。
Client部署方式: Driver进程运行在你提交程序的那台机器上
优点: 将运行结果和运行日志全部输出到了提交程序的机器上，方便查看结果
缺点: Driver进程和Yarn集群可能不在同一个集群中，会导致Driver和Executor进程间进行数据交换的时候，效率比较低
使用: 一般用在开发和测试中
Cluster部署方式: Driver进程运行在集群中某个从节点上
优点: Driver进程和Yarn集群在同一个集群中，Driver和Executor进程间进行数据交换的时候，效率比较高
缺点: 需要去18080或者8088页面查看日志和运行结果
使用: 一般用在生产环境使用
spark-submit命令 后续需要将自己编写的Spark程序提交到相关的资源平台上，比如说: local yarn spark集群(standalone)
​ Spark为了方便任务的提交操作，专门提供了一个用于进行任务提交的脚本文件: spark-submit
​ spark-submit在提交的过程中，设置非常多参数，调整任务相关信息。如果忘记了，可以使用spark-submit --help进行查看
基本参数设置
Driver的资源配置参数
executor的资源配置参数
PySpark程序与Spark交互流程 client on Spark集群(standalone) 1- 在什么地方提交程序，就会在什么地方启动Driver进程 2- Driver进程启动后，它是JVM的进程，无法直接执行Python代码。底层是基于PY4J，将创建SparkContext对象的代码映射为Java进行创建 3- Driver进程连接到Spark集群中的Master主节点，根据资源配置要求，向主节点申请资源，用来启动Executor 4- 主节点接收到资源申请之后，进行资源分配，底层是基于FIFO（先进先出）。分配好资源资源之后，将方案返回给到Driver进程 executor1：node1 2G 2CPU executor2：node3 2G 2CPU 5-Driver连接到对应的Worker从节点上，占用相应的资源。通知Worker启动Executor进程。启动以后会反向注册回Driver 6-Driver开始处理代码 6.1- Driver加载RDD相关的算子，根据算子间的依赖关系绘制DAG有向无环图和划分Stage阶段，并且确定每个Stage阶段有多少个Task线程。需要分配给哪些Executor进行执行。 6.2- Driver通知对应的Executor进程来执行相应的任务 6.3- Executor开始执行具体的任务。但是发现代码中有大量的Python函数，而Executor是JVM进程，无法直接执行代码。因此会调用服务器上的Python解释器，将Python函数和输入数据传输给到Python解释器，执行完以后，将结果数据返回给Executor进程 6.4- Executor在运行过程中，会判断是否需要将结果数据返回给到Driver进程。如果需要，就返回给Driver进程；如果不需要，直接输出，结束即可。 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c09cdc06909dc8ba247da9542602e310/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e6efdb3834709dcef3d68bbf0ece614/" rel="bookmark">
			copy与deepcopy异同点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 copy与deepcopy都是python中复制对象的方法
相同点：
1.都用于创建对象的副本
2.对于可变对象（列表、字典等）：会创建副本而不是引用原对象
3.对于不可变对象（整数、字符串等）：copy与deepcopy使用效果类似，因为没有子对象需要复制
不同点：
1.对嵌套对象的处理不同：copy只复制最外层对象，而不会递归地复制嵌套对象；deepcopy会递归地复制整个对象，包括所有嵌套的对象
2.引用对象：对于嵌套对象，copy可能会导致原始对象和复制对象共享相同的嵌套对象；而deepcopy会为嵌套对象创建全新的副本，确保原始对象与复制对象的嵌套对象不共享引用。
import copy #浅复制 list = [1, [2, 3], [4, 5]] shallow_copy = copy.copy(list) #深复制 deep_copy = copy.deepcopy(list) #修改原始对象中的嵌套列表 list[1][0] = 'X' print(list) #[1, ['X', 3], [4, 5]] print(shallow_copy) #[1, ['X', 3], [4, 5]] (共享嵌套列表的引用) print(deep_copy) #[1, [2, 3], [4, 5]] (独立的嵌套列表) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d3bb72e436ff09b2091386f6c43a3d/" rel="bookmark">
			ubuntu 挂载新硬盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、检测新硬盘
新增加硬盘，检测硬盘识别情况。
命令检查：sudo fdisk -l
3、格式化磁盘
格式化：sudo mkfs.ext4 /dev/sdb 其中，/dev/sdb是新分区的设备文件名，ext4是要使用的文件系统类型。
4、挂载新分区
sudo mkdir /home/newdrive
sudo mount /dev/sdb /home/newdrive
5、自动挂载新硬盘
每次系统启动时自动挂载新硬盘，
sudo nano /etc/fstab
添加这行到文本/dev/sdb /home/newdrive ext4 defaults 0 2
其中，/dev/sdb设备文件名，/mnt/newdrive是要挂载的目录，ext4是文件系统类型，defaults是配置选项，0和2分别代表dump和fsck检查的顺序。
sudo chmod 777 /home/newdrive 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/462245dc2795e7a39f4966872615d912/" rel="bookmark">
			微服务下的SpringSecurity认证端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从三板斧开始微服务下的SpringSecurity开始
一、引入组件包 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; 二、创建适配器 AuthorizationServerConfigurerAdapter是一个授权适配器，在这个适配器中有如下几个核心方法：
ClientDetailsServiceConfigurer 用来配置客户端详情服务（ClientDetailsService），这里的配置表明不是任何人都可以来授权中心进行授权的，客户端详情信息在这里进行初始化，可以在内存中也可以来自于数据库，根据你自己的需要进行配置；一个ClientDetails标识一个客户端的详情描述，ClientDetails具体的属性如下：
重要属性说明 属性名称说明clientId是一个唯一标识，用于标识客户secret客户端的安全码；微信登录就有安全码scope用来限制客户端的访问范围，如果为空，标识所有范围都可以访问authrizedGrantTypes可以使用的授权类型（可选值范围："authorization_code", "password", "client_credentials", "implicit", "refresh_token"），为空标识所有都支持；微信仅支持authorization_code；authorities客户端可以使用的权限（基于Spring Security Authorities）redirectUris回调地址，授权服务会往此地址回调推送客户端相关信息 ClientDetails客户端详情可以在运行时进行更新，可以通过访问底层存储介质（例如：JdbcClientDetailsService）或者自己实现ClientRegisterationService接口或者实现ClientDetailsService来进行定制；
AuthorizationServerSecurityConfigurer 配置令牌端点的安全约束；此接口包含了关于令牌管理的必要操作；
实现一个AuthorizationServerTokenServices接口需要继承DefaultTokenServices这个类；此类中包含了一些有用的实现，可以使用它来修改令牌的格式和令牌的存储模式；默认情况下，在创建一个令牌的时候，是使用随机值来进行填充的；这个类中完成了令牌管理的几乎所有事情，唯一需要依赖的是Spring容器中的一个TokenStore对象来定制令牌持久化；在Spring中有一个默认的TokenStore实现，即：ImMemoryTokenStore，这个类是将令牌保存到内存中，其他几个TokenStore实现类都可以根据自己的选择进行使用；
ImMemoryTokenStore：基于内存；
JdbcTokenStore：基于JDBC；
JwtTokenStore：基于JWT，这里啰嗦一下，此种类型时经常常用的类型，全称是“Json web Token”；是吧令牌信息全部编码到令牌本身，这样后端不需要维护令牌相关的信息，这是一大优势，当然缺点就是撤销令牌困难；传输占用空间比较大；
AuthorizationServerEndpointsConfigurer 用来配置令牌的访问端点和令牌服务；授权类型（Grant Types）有如下几点：
授权类型说明 授权类型说明authenticationManager认证管理器，如果你选择的是password（资源所有者密码）这个授权类型时，需要指定authenticationManager对象来进行鉴权userDetailsService用户主体管理服务，在拥有自己UserDetailsService接口的实现，如果设置了这个属性，那么refresh_token刷新令牌的方式授权类型流程中会多一个检查的步骤，来确保是否依然有效authorizationCodeServices用于authorization_code授权码模式，用来设置授权服务；implicitGrantService用于设置隐式授权模式的状态；tokenGranter这个是深度拓展时使用的；一旦设置，授权将会全部交由自己来掌控，会忽略以上几个属性； 1 @Configuration 2 @EnableAuthorizationServer 3 @EnableConfigurationProperties(value = JwtCaProperties.class) 4 public class AuthServerConfig extends AuthorizationServerConfigurerAdapter { 5 6 /** 7 * 属性描述：注入数据源 8 * 9 * @date : 2020/4/12 0012 上午 11:54 10 */ 11 private final DataSource dataSource; 12 13 /** 14 * 属性描述：JWT配置信息 15 * 16 * @date : 2020/4/12 0012 下午 10:49 17 */ 18 private final JwtCaProperties jwtCaProperties; 19 20 /** 21 * 属性描述：用户信息处理 22 * 23 * @date : 2020/4/13 0013 上午 12:12 24 */ 25 private final MyUserDetailServiceImpl myUserDetailServiceImpl; 26 27 private final AuthenticationManager authenticationManager; 28 29 /** 30 * 功能描述：认证中心配置 31 * 32 * @author : XXSD 33 * @date : 2020/4/12 0012 上午 11:54 34 */ 35 public AuthServerConfig(DataSource dataSource, JwtCaProperties jwtCaProperties, MyUserDetailServiceImpl myUserDetailServiceImpl, AuthenticationManager authenticationManager) { 36 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/462245dc2795e7a39f4966872615d912/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c40d6efd400d9f28398629cc8c832f0d/" rel="bookmark">
			JAVA8中并发类CompletableFuture使用遇到的坑-守护线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 最近在看Java8中对并发的支持CompletableFuture类，觉得挺好的，在单一线程执行的时候可以省略很多代码，手动验证后，发现其中还是有一部分坑的，此处记录一下。此处主要描述其创建线程为守护线程的问题，会随着主线程消亡直接消亡，导致任务失败。
2. CompletableFuture优点 简洁，后面以代码为例
3. 案例简述 3.1 CompletableFuture创建一个线程，内部进行轮询读取任务（如：模拟kafka之类的），会发现，执行结束后，整个线程一起关闭了，无法打到一直轮询的目的。传统直接创建的线程（默认为非守护线程）会由于子线程未结束，阻止主线程关闭。
4. 代码 package com.hz.threadpool.thread; import java.util.concurrent.CompletableFuture; import java.util.concurrent.TimeUnit; /** * @description: * @author: pp_lan * @date: 2022/3/24 */ public class CompletableFutureTest { /** * java8并发接口 */ public static void main(String[] args) throws InterruptedException { System.out.println("============== testAsyncRunnable ==============="); CompletableFuture.runAsync((() -&gt; { while (true) { try { TimeUnit.MILLISECONDS.sleep(1000); System.out.println("**************kafka读取消息结束**************"); } catch (InterruptedException e) { e.printStackTrace(); } } })); TimeUnit.SECONDS.sleep(3); } } 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c40d6efd400d9f28398629cc8c832f0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/468cd7046919bb36eb7c54316da34c70/" rel="bookmark">
			Scratch考级编程题：打砖块游戏 解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图形化编程等级考试历届考试编程题出现较多的就是Scratch打砖块游戏，一般就是Scratch考级中三级、四级的真题试卷比较常出现，今天我们来看看这个！
原题来源如下：www.6547.cn/question/view/shyltd7ykstqvqo1 此题如果设计成不要底下的红色区域，而是通过小球角色的Y坐标小于挡板角色的Y坐标判断游戏结束就更好了。
1.准备工作 （1）删除小猫角色，选择角色小球Ball、砖块Button3和球板Paddle;
（2）选择背景Stars，在背景底端绘制一条红色的线段;
（3）建立一个变量“分数”。
2.功能实现 （1）球板初始位置为(0,-140)，按下左右方向键能够左右移动;
（2）只有一个砖块角色，初始造型为button3-b，大小为60， 在舞台上方克隆出两行，每行有8列；
（3）点击绿旗，小球大小为50，初始位置为(0,0)，等待1秒后，小球面向随机方向（方向在135和225之间取随机数）移动；
（4）小球碰到舞台边缘反弹，碰到球板向上随机方向反弹（方向在-45和45之间取随机数），播放声音Boing；碰到舞台下方红色线段，游戏结束； （5）游戏开始分数初始为0，小球碰到砖块发出声音Coin，砖块消失分数加1分，分数等于16时，游戏结束。
预览一下做出来的效果：
Scratch实验室
小球角色的程序如下：
砖块角色的程序如下：
挡板角色的程序如下：
游戏结束角色程序如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c00b80f6142589b1ac135fb77a5b756/" rel="bookmark">
			基于海思SD3403/3519AV200的医疗内窥镜技术框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		医疗内窥镜市场，经过多年的发展，产品种类繁多，应用场景更加的多样了，但是基础的技术方案非常的收敛，主流的方案就是海思的SOC和FPGA。海思的SOC以优秀的图像质量，和便携的开发占据了大量的硬镜应用，同时也正在往软镜方向发展。FPGA由于低图像延迟，以及机电控制灵活，更多的是应用在软镜方向。由于FPGA开发非常的麻烦，要用低层环境开始构建，对开发人员的要求高很多，而且由于它的特性也不便于多人协同，所以海思的SOC方案正在逐步的替代FPGA方案。
下面以4K@60帧的硬镜和4K@30帧双目3D硬镜为例介绍海思SD3403/3519AV200的方案框架。
单sensor4K@60帧医疗内窥镜硬镜技术框架
双sensor4K@30帧双目3D内窥镜硬镜技术框架
sensor采用SONY imx334或者imx678，又或者OV os08A20，手柄和主机之间采用裸sensor串行调制延长传输到主机端，主机再进行ISP图像处理。原来大家的主控一般都是3519AV100或者3559Av100，从sensor到图像输出需要80ms左右的延迟，海思新的SD3403/3519av200系列最新的SDK在60帧情况下已经可以做到30ms。大幅的优化了图像延迟。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c8afef0b9bfe058342f4d1da9220ea/" rel="bookmark">
			选择服务商搭建WiFi贴码小程序，有哪些注意事项呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着移动互联网的快速发展，共享WiFi已经成为人们生活中不可或缺的一部分。在各种公共场所，如咖啡厅、餐厅、酒店、商场等，提供免费WiFi已经成为一种趋势。而WiFi贴码小程序的出现，为商家和用户提供了一个便捷的连接方式。那么，在选择服务商搭建WiFi贴码小程序时，有哪些注意事项呢？
一、明确小程序的功能需求 在搭建WiFi贴码小程序之前，首先要明确小程序的功能需求。基本的功能包括：WiFi连接、贴码扫描、用户管理、数据统计等。此外，还可以根据商家和用户的需求，增加一些特色功能，如：优惠券发放、会员管理、在线客服等。明确功能需求有助于后期的开发工作，使小程序更加符合用户需求。
二、选择合适的技术框架 在开发WiFi贴码小程序时，需要选择合适的技术框架。目前，比较流行的小程序开发框架有：微信小程序、支付宝小程序。选择合适的技术框架可以提高开发效率，同时也能保证小程序的兼容性和稳定性。
三、服务商实力 服务商的技术实力是搭建WiFi贴码小程序时最为看重的一部分。一家有实力的共享WiFi贴码服务商公司应该拥有专业的技术团队和自主开发的周边的项目支持，要是只有单一的项目是很难维持一个大公司的运营，有实力自然也不会只着眼一个系统开发，像在微火在发明共享wifi贴码前，本来还是做支付系统、智慧数字经营系统的，以及现在的本地生活聚合服务商系统和数字人系统也是，这些周边的项目可以很好的相互维持公司很好的运营，做到长远的发展。
四、后期维护与更新 WiFi贴码小程序开搭建好后，还需要进行后期的维护与更新。所以服务商还得有专业的技术售后团队，他们要及时处理：修复程序中的bug、更新程序功能、优化程序性能等。此外，还要及时响应用户反馈，解决用户在使用过程中遇到的问题，提高用户满意度。
总之，在选择服务商搭建WiFi贴码小程序时，要注重多种方面，而不易一味的追求单次收益大、便宜就好，我们要多方对比实地考察选择性价比较高的，这样后期投入市场才可以让用户又更好的体验，为用户提供一个便捷的WiFi连接方式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea156179098cc7088eebd0997639e93f/" rel="bookmark">
			Mudbox 各版本安装指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​Mudbox下载链接
https://pan.baidu.com/s/1cYcITQ7OeI5PadNdXur_bA?pwd=0531
1.鼠标右击【Mudbox2024(64bit)】压缩包（win11及以上系统需先点击“显示更多选项”）【解压到 Mudbox2024(64bit)】。
2.打开解压后的文件夹，双击打开【Setup】文件夹。
3.鼠标右击【Setup】选择【以管理员身份运行】。
4.勾选【I agree……】，点击【Next】。
5.点击【…】。
6.①选择需要将软件安装的磁盘（如：D盘）②新建一个【Mudbox202】文件夹并选中③点击【选择文件夹】。
7.点击【Install】。
8.安装中……
9.点击右上角【X】退出。
10.打开安装包解压后的【Mudbox2024(64bit)】文件夹，鼠标右击【Crack】选择【解压到当前文件夹】。①解压【Crack】前：先关闭“所有杀毒软件(部分电脑自带的“迈克菲”也要关闭）、防火墙、Windows Defender”，否则可能会被杀毒软件误杀无法运行。
11.鼠标右击解压出来的【keygen】选择【以管理员身份运行】。
12.自动激活中……
13.点击【OK】。
14.双击桌面【Mudbox2024】图标启动软件。
15.点击【Select】。
16.安装成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3128d500ae3eb17bd72be5e00b50ca10/" rel="bookmark">
			电商API接口|电商平台使用的物流API的安全风险
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电子商务平台的物流 API 如果出现安全漏洞，则消费者的个人信息会被大量暴露。
物流 API 整合了企业和第三方供应商之间的数据和服务，以解决各种市场需求。如果 电商API 接口集成不当，可能会出现泄露个人身份信息 (PII) 的风险。许多使用 API 通信的垂直行业应该得到足够的保护，尤其是在传输敏感数据时。否则，无意的 PII 泄漏不仅会对未能履行其法律或合规义务的组织造成严重后果，也会对暴露 PII 的消费者造成严重后果。
什么是外部物流供应商？
外部物流供应商说白了就是商家用来交付产品的快递服务（第二方物流或 2PL），也可以是由仓储、电商平台和交付产品组成的第三方物流 (3PL) 服务。下图显示了外部物流提供商在不同用例中的工作方式。
外部物流提供商如何在不同用例中发挥作用
最初，研究人员调查了通过不安全的方法无意中暴露PII的3PL和4PL提供商。但随着研究的深入，我们也发现，除了 3PL 和 4PL 提供商会暴露敏感信息外，已经集成到其系统中的服务也存在自身的安全漏洞，从而加剧了整个电子商务生态系统的风险。电子商务平台允许商家通过 API 整合现有的外部物流提供商，将不同的服务整合到一个平台中。电子商务平台和物流提供商共享的 API 密钥和身份验证密钥旨在促进一个安全的通信渠道。
PII是如何从电子商务和物流API实现中泄露的？
PII 从物流 API 实施中暴露的方式有很多，这些方式与不安全的编码做法相关。
URL查询参数
不经意间暴露PII的一个编码做法涉及电子商务平台和物流API 中的 URL 查询参数。电子商务平台通常要求客户登录帐户或选择访客结帐选项。一些在线购物网站使用他们通过电子邮件或短信发送给用户的唯一 URL，将他们重定向到可以访问订单信息的网站。
将发送到收件人拥有的电子邮件地址或电话号码的唯一URL的组合使用足以保护PII的假设是有问题的，因为这会产生错误的安全感。研究表明，未经授权的各方仍然可以通过直接访问URL来检索客户的PII，而不需要进一步的身份验证。
URL参数中的身份验证密钥
当消费者在在线商店下订单时，商店会向他们发送一封确认电子邮件，其中包含 URL 链接和 URL 参数上的身份验证密钥，以查看订单详细信息。此密钥用于验证检查订单页面的用户是否是电子邮件的收件人。订单页面包含客户姓名、电子邮件地址、电话号码和付款方式等信息。
尽管没有正确的身份验证，但仍然显示客户的PII
将身份验证密钥作为 URL 参数的一部分传递的做法可能会泄漏 PII，因为这些密钥仍然可以使用其他方式检索，例如访问用户的浏览历史记录和路由器日志。使用未加密的 URL 查询参数使 PII 容易受到嗅探和中间人攻击。
未经身份验证的 3PL API
虽然在线零售商使用的 3PL 服务的基本组件包括订单处理、运输和跟踪，但我们还发现 3PL 提供商的 API（在下图中称为 X 公司）通过未经身份验证的 API 服务披露 PII。其他四家 3PL 提供商正在使用此 API 服务来显示客户的订单信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3128d500ae3eb17bd72be5e00b50ca10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd0698972b5173387c088ba7b002939e/" rel="bookmark">
			小程序this.setData修改对象、数组中的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在微信小程序的前端开发中，使用this.setData方法修改data中的值，其格式为
this.setData({ ‘参数名1’: 值1,‘参数名2’: 值2)}
注意：如果是简单变量，参数名可以不加引号。
下面提供2种方式对data中的对象、数组中的数据进行修改：
假设原数据为：
data: { userInfo: { username: 'little', sex: 'female' }, arr: [1,2,3,4,5,6], }, 方式一：使用[‘字符串’]
this.setData({ // 写法一： ['userInfo.username']: 'plum', ['arr[2]']: 10 // 写法二： 'userInfo.username': 'plum', 'arr[2]': 10, }) 当字符串中含有变量时，使用arr[${index}],并且外层的[]不可省略
this.setData({ [cars[${index}]]: 20})
方式二： 构造变量，重新赋值
var temp = this.data.userInfo temp.username = 'plum' this.setData({userInfo: temp}) var temp = this.data.arr temp[2] = 10 this.setData({arr: temp}) 另需注意：数组不可直接在xml中使用，要么遍历要么转为字符串后在xml中展示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4bd8111dba2866be5206912dec9ac57/" rel="bookmark">
			iOS 位运算符浅析：与、或、异或、取反、左移、右移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 iOS开发中可以使用C语言位运算符主要包括六种：与（ &amp; ）、或（ | ）、异或（ ^ ）、取反（ ~ ）、左移（ &gt;&gt; ）和右移（ &lt;&lt; ）
如下图表简单对比：一目了然
名称符号说明举例按位与&amp;两二进制值对应位都为1，则为1；否则为0101 &amp; 010 = 000按位或I两二进制值对应位只要一个为1，则为1；全0时为0101 &amp; 010 = 111按位异或^两二进制值对应位相同，则为1；否则为0101 &amp; 010 = 000取反~此为一元运算符，是对一个二进制数按位取反，即将0变1，将1变0~0=1； ~1=0左移&lt;&lt;将一个二进制数的位全部左移N位，右补0；相当于十进制乘20001 &lt;&lt; 1 = 0010右移&gt;&gt;将一个二进制数的位全部右移N位，右侧低位1会被舍弃，左侧补0；相当于十进制除20001 &gt;&gt; 1 = 0000 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1819bb6893d5ff311dc6270a29819e3a/" rel="bookmark">
			计算机Java项目｜基于SSM的宠物商店管理系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者主页：编程指南针
作者简介：Java领域优质创作者、CSDN博客专家 、CSDN内容合伙人、掘金特邀作者、阿里云博客专家、51CTO特邀作者、多年架构师设计经验、腾讯课堂常驻讲师
主要内容：Java项目、Python项目、前端项目、人工智能与大数据、简历模板、学习资料、面试题库、技术互助
收藏点赞不迷路 关注作者有好处
文末获取源码 项目编号：L-BS-ZXBS-15 一，环境介绍 语言环境：Java: jdk1.8
数据库：Mysql: mysql5.7
应用服务器：Tomcat: tomcat8.5.31
开发工具：IDEA或eclipse
二，项目简介 社会主义进入新时代，经济实力越来越强。我们也变得越来越忙碌、对生活的要求也变得更加严格，对快速和方便的服务的需求也在逐渐增加。因此，对宠物行业的管理、服务的要求也越来越严格。为适应时代的发展，各大宠物店开始广泛地使用电脑来进行管理，并推出在线宠物商店管理系统设计与实现，为提高工作人员效率提供了一种新的方式，并且减轻了他们的工作强度，在树立商家形象的同时，为用户提供更加方便、舒适、优质而高效的服务，实现双赢。
于此同时，实现宠物商店管理系统设计与实现的计算机化也是顺应时代潮流的举措，现如今宠物类型正逐渐增加，浩繁的宠物信息令宠物商店管理系统设计与实现迎来管理上的难题。宠物行业进入高速发展的时代，宠物的管理工作变得越来越困难，在这一客观需要的推动下，建立、完善、发展宠物商店管理系统设计与实现，可以为管理员带来极大的方便。
本系统即为方便管理员和用户而制作的网上宠物商店管理系统设计与实现，结合了用户的需求，设计出的一个基于Java、MySQL的网上宠物商店管理系统设计与实现。
宠物商店管理系统设计与实现需要满足的需求有以下几个：
1.信息获取方便，用户可在网页上快速浏览到新的信息。
2.宠物领养管理，符合用户需要的宠物可以在线支付。
3.查看宠物详情，单独查看某一个宠物的详细信息，获取好评等。
4.修改用户信息，可以修改用户密码或者用户名等一些个性化操作。
5.管理员功能，管理员可以对用户信息进行管理。
6.系统安全，操作简便，不过于复杂。
7.系统可以稳定运行，不存在卡顿等问题造成用户反感。
数据库表设计
将数据库概念设计的E-R图转换为关系数据库。在关系数据库中，数据关系由数据表组成，但是表的结构表现在表的字段上。
表名：chongwufenlei
功能：宠物分类
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
主键 addtime
timestamp
创建时间
CURRENT_TIMESTAMP
fenlei
bigint
分类
表名：chongwuguashi
功能：宠物挂失
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
主键 addtime
timestamp
创建时间
CURRENT_TIMESTAMP
guashibiaoti
bigint
挂失标题
fenlei
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1819bb6893d5ff311dc6270a29819e3a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/20/">«</a>
	<span class="pagination__item pagination__item--current">21/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/22/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>