<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c2d4464864f4e6b39a3b96a54d866f2/" rel="bookmark">
			Python报“TypeError: a bytes-like object is required, not ‘str’ ”解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决办法：
解决办法非常的简单，只需要用上python的bytes和str两种类型转换的函数encode()、decode()即可！
str通过encode()方法可以编码为指定的bytes；
反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法；
因此：我只需要把上图中的代码改成下面的即可！
import os,sys #打开文件 fd = os.open('foo.txt',os.O_RDWR|os.O_CREAT) str = 'this is fujieace.com test' str = str.encode() #写入字符串 os.write(fd,str) #关闭文件 os.close(fd) print('关闭文件成功！') 其它解决方法
还有一种方法也可以实现，具体代码如下：
str = 'this is fujieace.com test' os.write(fd,bytes(str,'UTF-8')) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0e79dd0cd6a42dcd2042f00550e4bfc/" rel="bookmark">
			ODOO13 centos7.6 源码 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境准备
1、python3.7
安装依赖包
yum -y groupinstall "Development tools" yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel zlib1g-dev zlib*
下载软件包
https://www.python.org/ftp/python/3.7.6/Python-3.7.6.tgz
解压
tar -xvzf Python-3.7.6.tgz
建编译安装目录
mkdir /usr/local/python3
编译安装
cd Python-3.7.6
./configure --prefix=/usr/local/python3 --enable-optimizations --with-ssl
make &amp;&amp; make install
建立软联接
ln -s /usr/local/python3/bin/python3 /usr/local/bin/python3
ln -s /usr/local/python3/bin/pip3 /usr/local/bin/pip3
验证
# python3 -V
Python 3.7.6
#pip3 -V
pip 19.2.3 from /usr/local/python3/lib/python3.7/site-packages/pip (python 3.7)
2、postgresql-11 数据库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0e79dd0cd6a42dcd2042f00550e4bfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ddeec62267fbfd21c709083963d32ae/" rel="bookmark">
			细读HTTPS -- 白话TLS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 细读HTTPS -- 白话TLS什么是对称加密？什么是非对称加密？什么是MAC ？什么是数字签名？什么是CA？什么证书?什么是证书链？SSL验证服务器握手具体干了什么 ？什么是自签名证书？为什么CA付费签名证书才是安全的？ 细读HTTPS – 白话TLS 前面三篇文章是阅读《HTTPS权威指南 在服务器和WEB应用上部署SSL》这本书的笔记，不过由于翻译不是太好，很多地方难以理解。经过多次阅读以及网上查阅资料终于弄懂了一些原理和概念。下面用自己的话来重新描述下SSL中的原理以及SSL握手过程中用到了哪些东西。
什么是对称加密？ 所谓对称加密就是指加密过程和解密过程都是使用的相同的秘钥。举例说明：你将你的手机设置了一个开机密码，这个设置密码的过程就类似于加密，然后你下次开手机，需要输入相同的密码解开手机，这就是解密，加密和解密使用的是同一个密码就是对称加密。对称加密有好多种加密模式：ECB、CBC、CFB、OFB，CTR和GCM，其具体解释可参见博客：对称加密算法的几种模式优缺点一览对称加密对应有很多种算法：DES、3DES（TripleDES）、AES、RC2、RC4、RC5和Blowfish，具体可参照博客：对称加密算法DES、3DES和AES 什么是非对称加密？ 所谓非对称加密就是指加密过程和解密过程使用不同的秘钥，其中一个是公钥，对外发布，另一个是私钥，自己留着。如果你利用某人的公钥加密数据，那么只有他们对应的私钥能够解密。从另一个方面讲，如果某人用私钥加密数据，任何人都可以利用对应的公钥解开消息。
常见的非对称加密算法：RSA，Diffie-Hellman（DH），elliptic curve Diffie-Hellman（ECDH）
什么是MAC ？ 消息认证码（Message authentication code）是一种确认完整性并进行认证的一种技术，简称MAC。
为啥需要MAC？
一般在网络中传输文件或者传输消息，接收方如何知道接收到的数据有没有部分缺失呢 ？我们当前最常用的算法如MD5.
将这个文件的内容通过一定的算法获取一个哈希值，然后将这个文件或者消息和这个哈希值A一起传输出去.接收方收到消息内容和哈希值A,使用相同的算法计算消息内容得出另一个哈希值B，再来比较哈希值A和哈希值B，相等则接收到的消息是完整的，不相等则接收到的数据有丢失或者篡改。
但是如果攻击者同时截获消息内容和哈希值，虽然说消息内容可以加密，但是攻击者可以破坏消息内容再算出一个哈希值出来，然后将破坏后的消息和哈希值传到接收方，此时的接收方完全不知道自己被骗了.
因此MAC可以改善上述情况. 为啥MAC能保证传输的完整性 ？
使用 MAC 验证消息完整性的具体过程是：
假设通信双方 A 和 B 共享密钥 K，A用消息认证码算法将 K 和消息 M 计算出消息验证码 Mac然后将 Mac 和 M 一起发送给 B。B 接收到 Mac 和 M 后，利用 M 和 K 计算出新的验证码 Mac*，若 Mac*和Mac 相等则验证成功，证明消息未被篡改。 由于攻击者没有密钥 K，攻击者修改了消息内容后无法计算出相应的消息验证码，因此 B 就能够发现消息完整性遭到破坏。
常见的MAC实现有：HMAC，CBC-MAC，OMAC等。
什么是数字签名？ 使用非对称加密算法得出一对秘钥，一个公钥，一个私钥。然后用私钥将信件的摘要进行加密，生成的密文叫做数字签名。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ddeec62267fbfd21c709083963d32ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d54977b119bea05c4ebfae73f7ab8b1e/" rel="bookmark">
			LeetCode刷题之路 --- 787. K 站中转内最便宜的航班
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言完整解法：
#define MaxValue 1000001
int findCheapestPrice(int n, int** flights, int flightsSize, int* flightsColSize, int src, int dst, int K) {
/* 异常判断 */
if (n &lt; 1 || n &gt; 100 || K &lt; 0 || K &gt; 10000) {
return -1;
}
/* 创建数组存放结果 */
int **dp = (int **)malloc(sizeof(int *) * n);
for (int i = 0; i &lt; n; i++) {
dp[i] = (int *)malloc(sizeof(int) * (K + 1));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d54977b119bea05c4ebfae73f7ab8b1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe9642d6aa0b9e5b073703ee98973da6/" rel="bookmark">
			底角括号⌊⌋的意义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		底角括号⌊⌋的意义为向下取整，即floor函数的用法，比如⌊2.2⌋=2.
哎，心累，查了好久
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddbccb050aa27813ce4a7cb9a72fcb3d/" rel="bookmark">
			第三章第十七题（游戏：剪刀、石头、布）(Game: scissor, rock, paper)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		*3.17（游戏：剪刀、石头、布）编写可以玩流行的剪刀-石头-布游戏的程序。（剪刀可以剪布，石头可以砸剪刀，而布可以包石头。）程序提示用户随机产生一个数，这个数为0、1或者2，分别表示石头、剪刀和布。程序提示用户输入值0、1或者2，然后显示一条消息，表明用户和计算机谁赢了游戏，谁输了游戏，或是打成平手。 下面是运行示例：
scissor(0),rock(1),paper(2): 1
The computer is scissor.You are rock.You won
scissor(0),rock(1),paper(2): 2
The computer is paper.You are paper too.It is a draw
*3.17(Game: scissor, rock, paper) Write a program that plays the popular scissor–rock–paper game. (A scissor can cut a paper, a rock can knock a scissor, and a paper can wrap a rock.) The program randomly generates a number 0, 1, or 2 representing scissor, rock, and paper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddbccb050aa27813ce4a7cb9a72fcb3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5f8bd42b23971198785f1d4929017af/" rel="bookmark">
			git 回退操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git在版本管理方面非常优秀，提供了一个分布式管理结构，在提交和撤销回退方面也很方便。
在git的概念里，在本地有一个工作区，本地还有一个仓库，远程也有一个仓库。通常来说在工作区进行工作，工作完成后，将需要保存的内容交给git管理：
git add file git是直接对整个文件进行管理，将文件交给git后，需要提交到本地仓库中：
git commit -m "message" 提交到本地仓库，git便建立起了一个追踪变化的树，其中一个分支会有自己的记录，当前所在的变化会有一个HEAD来标识，每提交一次，HEAD都会指向最新的变化，此时若想后退，只需要将HEAD指针回退到相应版本即可。
git 提供了三个撤销回退的概念：
reset：git reset 能将当前工作区加入git管理的文件全部清空： 此时git已经追踪到test.txt的变化，等待提交本地仓库，如果发现出错了，可以进行撤销：
撤销后，不删除文件本身的变化，只是将它从git管理中去除。
revert：git revert 纸面意思就是反转，即将提交到本地仓库的内容进行反转，它会自动产生一次新的提交，可以用-n参数来指定不产生新的提交。 假如提交到本地仓库是错误的，此时需要将错误改正过来，可以使用revert，进行反转。
反转即是将添加的删除掉，删除的添加回来。
rebase：git rebase 对每次的提交进行处理，例如将多次提交合并为一次提交，在git revert时，将会产生一个提交，可以用rebase将这两次提交合并为一次提交： 使用-i进入交互式界面，rebase时，可以指定版本号，注意，如果指定的是版本号，那么rebase是不包括这个版本的，也可以用head指针来指定，例如指向前两次提交：HEAD~2，此时进入交互式界面，从上向下列着每次的提交记录，由旧到新的顺序排列。下面有很多选项：p(pick) 挑选哪一个作为基础提交，s(squash)将选中的提交合并到pick的提交上。所以，我可以pick最早的一个提交，即第一行的提交，squash其他提交，合并为一个提交。保存退出，然后再执行git rebase --continue，将提交的信息进行修改。若不修改，rebase将会保存之前所有的提交信息，并按由新到旧的顺序排列。保存后 退出，查看记录，已经成功合并。
但某些情况下，事实比上面的情况要复杂，例如与同事合作，git记录信息如下：
可以看到文件的改变和每一次的提交是对应的，方便显示效果。
第一次和第四次是要保留的提交，中间的二三次是需要撤回的提交。
如果不需要保存原始的提交记录，那么直接进行rebase + revert操作。 由于第四次提交不在我要操作的范围内，所有rebase的时候保持pick就好，这样rebase还是会保留这一次提交，将第三次合并到第二次上，所以要squash第三次提交，也可以用fixup，直接去除第三次的提交信息。
有一点需要注意的是，如果第四次改动与要反转的提交改动冲突，需要手动解决冲突。示例如下：
将需要撤回的提交利用rebase合并为一次提交，然后对这个提交进行revert即可。
若需要保存完整的原始提交记录，可以采用下面的办法： 先在当前分支基础上切出一个分支test-bak来操作，对bak分支进行rebase操作，然后将原分支test合并到当前分支，由于git识别修改相同自动合并，所以实际文件内容并没有变化，只是test-bak分支多了test分支上的提交记录，即完整的四次提交记录。示意图如下：
然后将原分支test删除，将test-bak分支改名为test，然后和远程的test分支建立联系即可。如果觉得合并后的分支提交记录仍然不整齐，可以将不需要的rebase掉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/272e12d27d9b524e725852edb7d15096/" rel="bookmark">
			第三章第十五题（游戏：彩票）(Game: lottery)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**3.15（游戏：彩票）修改程序清单3-8，产生三位整数的彩票。程序提示用户输入一个三位整数，然后依照下面判定用户是否赢得奖金： 1. 如果用户输入的所有数包括顺序完全匹配彩票数字，奖金是10000美元。
2. 如果用户输入的所有数匹配彩票的所有数字，奖金是3000美元。
3. 如果用户输入的其中一个数匹配彩票号码中的一个数，奖金是1000美元。
**3.15(Game: lottery) Revise Listing 3.8, Lottery.java, to generate a lottery of a three-digit number. The program prompts the user to enter a three-digit number and determines whether the user wins according to the following rules: 1. If the user input matches the lottery number in the exact order, the award is
$10,000.
2. If all digits in the user input match all digits in the lottery number, the award
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/272e12d27d9b524e725852edb7d15096/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab493ad1b441f0e3fa3b2f2b75afaf56/" rel="bookmark">
			机器学习各类优化算法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 Intro
2 一阶优化算法
2.1 Gradient descent
Batch Gradient Descent
Stochastic Gradient Descent
Mini-batch Gradient Descent
2.2 Momentum
2.3 Nesterov accelerated gradient （NAG）
2.4 AdaGrad
2.5 Adadelta与Rmsprop
2.6 Adam
2.7 AdaMax
2.8 Nadam
2.9 AMSgrad
2.10 Adafactor
2.11 Adabound
3 二阶优化算法
3.1 牛顿法
3.2 拟牛顿法
Conclusion
Reference
1 Intro 深度学习模型的优化是一个非凸优化问题，这是与凸优化问题对应的。
对于凸优化来说，任何局部最优解即为全局最优解。用贪婪算法或梯度下降法都能收敛到全局最优解。而非凸优化问题则可能存在无数个局部最优点，损失曲面如下，可以看出有非常多的极值点，有极大值也有极小值。
除了极大极小值，还有一类值为“鞍点”，简单来说，它就是在某一些方向梯度下降，另一些方向梯度上升，形状似马鞍，如下图红点就是鞍点。
对于深度学习模型的优化来说，鞍点比局部极大值点或者极小值点带来的问题更加严重。
目前常用的优化方法分为一阶和二阶，这里的阶对应导数，一阶方法只需要一阶导数，二阶方法需要二阶导数。
常用的一阶算法就是：随机梯度下降SGD及其各类变种了。
常用的二阶算法就是：牛顿法等。
2 一阶优化算法 2.1 Gradient descent Batch Gradient Descent Stochastic Gradient Descent Mini-batch Gradient Descent 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab493ad1b441f0e3fa3b2f2b75afaf56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c256ab3dbaad26e58d72e060ae9aeb6/" rel="bookmark">
			Python3中利用map将列表当中的string类型转换为int类型或其它类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 看下面的代码
list1 = ['11','22'] list1 = map(int, list1) print(type(list1[0])) 编译后会报错TypeError: 'map' object is not subscriptable，在百度了后才知道，上面代码在python2当中才是正确的，在py3中，它返回的是迭代器，不是我们直接想要的list。
所以正确的做法如下：
list1 = ['11','22'] list1 = list(map(int, list1)) print(type(list1[0])) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02145fc93d8675d67cacae30191c33ba/" rel="bookmark">
			HTB-Obscurity writeup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言0x1 www-data0x2 user flag0x3 root flag0x4 总结 前言 这是HTB系列的第二篇，第一篇链接地址：https://blog.csdn.net/weixin_43826280/article/details/103943571
准备
Obscurity靶机地址：10.10.10.168OS:Linux
难度：中等
操作机：Kali
将靶机的ip地址加入到hosts文件中
10.10.10.168 obscurity.htb 0x1 www-data nmap扫描
# Nmap 7.80 scan initiated Wed Jan 15 14:08:44 2020 as: nmap -sVTC -o scan 10.10.10.168 Nmap scan report for obsecurity.htb (10.10.10.168) Host is up (0.28s latency). Not shown: 998 filtered ports PORT STATE SERVICE VERSION 8080/tcp open http-proxy BadHTTPServer | fingerprint-strings: | GetRequest: | HTTP/1.1 200 OK | Date: Wed, 15 Jan 2020 06:10:46 | Server: BadHTTPServer | Last-Modified: Wed, 15 Jan 2020 06:10:46 | Content-Length: 4171 | Content-Type: text/html | Connection: Closed .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02145fc93d8675d67cacae30191c33ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/911f6737a925aeaf2f1c8b3d67634ee0/" rel="bookmark">
			c&#43;&#43;标准库vector文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// vector standard header // Copyright (c) Microsoft Corporation. // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception #pragma once #ifndef _VECTOR_ #define _VECTOR_ #include &lt;yvals_core.h&gt; #if _STL_COMPILER_PREPROCESSOR #include &lt;xmemory&gt; #if _HAS_CXX17 #include &lt;xpolymorphic_allocator.h&gt; #endif // _HAS_CXX17 #pragma pack(push, _CRT_PACKING) #pragma warning(push, _STL_WARNING_LEVEL) #pragma warning(disable : _STL_DISABLED_WARNINGS) _STL_DISABLE_CLANG_WARNINGS #pragma push_macro("new") #undef new _STD_BEGIN // CLASS TEMPLATE _Vector_const_iterator template &lt;class _Myvec&gt; class _Vector_const_iterator : public _Iterator_base { public: #ifdef __cpp_lib_concepts using iterator_concept = contiguous_iterator_tag; #endif // __cpp_lib_concepts using iterator_category = random_access_iterator_tag; using value_type = typename _Myvec::value_type; using difference_type = typename _Myvec::difference_type; using pointer = typename _Myvec::const_pointer; using reference = const value_type&amp;; using _Tptr = typename _Myvec::pointer; _Vector_const_iterator() noexcept : _Ptr() {} _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) { this-&gt;_Adopt(_Pvector); } _NODISCARD reference operator*() const { #if _ITERATOR_DEBUG_LEVEL !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/911f6737a925aeaf2f1c8b3d67634ee0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1861a24d295624d112dc8dd687443678/" rel="bookmark">
			Python之路 字典{ }
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字典的创建 a={‘name’:‘gaoqi’,‘age’:‘18’,‘job’:‘programmer’}
成对出现
1.可以通过{} dict（）来创建字典对象
b=dict（name=‘gaoqi’,age=‘18’,job=‘programmer’）
2.通过zip（）创建字典对象
3.通过fromkeys创建值为空的字典
字典元素的访问 1.通过[键]或的"值"。若键不存在，则抛出异常 a[‘name’]
2.通过get（）方法获得"值"。指定键不存在时，返回None a.get(‘name’)
a.get(‘name’,‘不存在’) 如果没有name字段则返回’不存在’
3.列出所以的键值对
a.items()
4.列出所有的键，列出所有的值
a.keys()
a.values
5.len()个数
6.检查一个键是否再字典中
a={“name”:“gaoqi”,“age”:“18”}
“name” in a
字典元素的添加 修改 删除 添加
1.直接 a[‘age’]=16 如果键已经存在则直接覆盖
2.使用update（）将字典中所有的建队全部添加到旧字典对象上
a={‘name’:‘gaoqing’}
b={‘age’:‘18’}
a.update(b)
3.字典中元素的删除，可以使用del（）方法
del(a[‘name’])
clean() 删除所有的键值对
序列解包 序列解包用于字典时，默认是对‘键进行操作，如果需成对操作则需要items（）函数，如果需要对值进行操作则需要values（）
默认
items 函数 对键值进行操作
values对值进行操作
表格数据使用字典和列表存储，并实现访问 用代码把表格展示出来
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b6df4eedc33803baf6b6d00b59fb05e/" rel="bookmark">
			java：用键盘上输入几个数，并从中找出最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import java.util.Scanner; public class Fighting { public static void main(String[] args) { int max = 0; Scanner scanner = new Scanner(System.in); System.out.println("请问有几个数："); int number = scanner.nextInt(); System.out.println("请输入这"+number+"个数字："); int[] arr = new int[number]; for(int i = 0;i &lt; arr.length;i++) { arr[i] = scanner.nextInt(); if(arr[i]&gt;max) { max = arr[i]; } }	System.out.println("输入的最大数是："+max); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc84d07df184b0869e2ac6d2e5dd33b9/" rel="bookmark">
			OJ常用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OJ常用技巧 0.前言 本文章主要积累一些编程中常用的骗分技巧。可能是针对某些特殊的样例才有用，但是也有一定的道理，可能会给大家带来一些新的启示。
1.dfs常用技巧 1.1 适当剪枝 这个不说
1.2 添加返回条件 比如说一个程序只有达到某种条件时才会返回，但是因为条件太少，返回不多，就容易出现DFS爆栈的情况，所以需要增加条件。通常情况下，可以用增加阈值的情况来限制深搜的步骤。比如说：马的遍历 这道题，（很明显，这是一道BFS的题，但是如果真的要用dfs写的话，就很容易出现超时。）
比如我用如下的代码交这道题的时候，就有一个测试点超时。【如下图所示】
这时候如果真想用dfs交题就可以尝试添加一个dfs的返回条件。代码如下：
//count 代表马儿走了多少步 //(x,y) 代表当前的坐标值 void dfs(int x,int y ,int count){ if(x&gt;n || x&lt;1 || y&lt;1 || y&gt;m )//如果越界了 return ; if(cur &gt; 200) return; //肯定小，直接赋值 f[x][y] = count;	if(count+1 &lt; f[x-2][y+1]) dfs(x-2,y+1,count+1);//1 往右上 if(count+1 &lt; f[x-1][y+2]) dfs(x-1,y+2,count+1);//2 if(count+1 &lt; f[x+1][y+2]) dfs(x+1,y+2,count+1);//3	if(count+1 &lt; f[x+2][y+1]) dfs(x+2,y+1,count+1);//4往右下	if(count+1 &lt; f[x+2][y-1]) dfs(x+2,y-1,count+1);//5 if(count+1 &lt; f[x+1][y-2]) dfs(x+1,y-2,count+1);//6 if(count+1 &lt; f[x-1][y-2]) dfs(x-1,y-2,count+1);//7 if(count+1 &lt; f[x-2][y-1]) dfs(x-2,y-1,count+1);//8往左上 } 其中的关键语句就是
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc84d07df184b0869e2ac6d2e5dd33b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1389e61c653ecc2410b4092d3a609be4/" rel="bookmark">
			第三章第九题（商业：检验ISBN-10）((Business: check ISBN-10))
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**3.9（商业：检验ISBN-10）ISBN-10（国际标准书号）由10个个位整数组成，最后一位是校验和，它是使用下面的公式用另外9个数计算出来的： (d1 * 1 + d2 * 2 + d3 * 3 + d4 * 4 + d5 * 5 + d6 * 6 + d7 * 7 + d8 * 8 + d9 * 9)%11 如果校验和为10，那么按照ISBN-10的习惯，最后一位应该表示为X。编写程序，提示用户输入前9个数，然后显示10位ISBN（包括前面起始位置的0）。程序应该读取一个整数输入。 以下是一个运行示例： Enter the first 9 digits of an ISBN as integer:013601267
The ISBN-10 number is 0136012671
Enter the first 9 digits of an ISBN as integer:013031997
The ISBN-10 number is 013031997X
**3.9(Business: check ISBN-10) An ISBN-10 (International Standard Book Number) consists of 10 digits: .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1389e61c653ecc2410b4092d3a609be4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4c1de28ecdbcc90c57ef3bd5a225007/" rel="bookmark">
			第三章第四题（随机月份）(Random month)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**3.4（随机月份）编写一个随机产生1和12之间整数的程序，并且根据数字1，2，……，12显示相应的英文月份：January，February，……，December。 **3.4(Random month) Write a program that randomly generates an integer between 1 and 12 and displays the English month names January, February, . . . , December for the numbers 1, 2, . . . , 12, accordingly. 下面是参考答案代码:
public class RandomMonthQuestion4 { public static void main(String[] args) { int randomNumber = (int)(Math.random() * 12) + 1; switch(randomNumber) { case 1: System.out.println("random number " + randomNumber + " is for January"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4c1de28ecdbcc90c57ef3bd5a225007/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/413254e59b153b114a67496241542f18/" rel="bookmark">
			细读HTTPS --  SSL/TLS协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 细读HTTPS -- SSL/TLS协议握手协议握手之对服务器进行身份验证握手之客户端身份验证&amp;服务器身份验证握手之会话恢复 密钥交换RSA 密钥交换Diffie-Hellman 密钥交换椭圆曲线Diffie-Hellman 密钥交换身份验证加密序列加密分组加密已验证的加密 应用数据协议警报协议协议中的密码操作伪随机函数主密钥秘钥生成 TLS中的密码套件TLS扩展TLS扩展：证书透明度TLS扩展：签名算法 细读HTTPS – SSL/TLS协议 TLS的主规格说明书定义了四个核心子协议：握手协议（handshake protocol）、密钥规格变更协议（change cipher spec protocol）、应用数据协议（application data protocol）和警报协议（alert protocol）。
握手协议 在使用中经常可以观察到以下三种流程：
对服务器进行身份验证；恢复之前的会话采用的简短握手；对客户端和服务器都进行身份验证的握手。 握手之对服务器进行身份验证 每一个TLS连接都会以握手开始。如果客户端此前并未与服务器建立会话，那么双方会执行一次完整的握手流程来协商TLS会话。握手过程中，客户端和服务器将进行以下四个主要步骤：
交换各自支持的功能，对需要的连接参数达成一致。验证出示的证书，或使用其他方式进行身份验证。对将用于保护会话的共享主密钥达成一致。验证握手消息并未被第三方团体修改。 具体流程如下图：
ClientHello：客户端开始新的握手，并将自身支持的功能提交给服务器。
Version：版本信息Random：随机数（random）字段包含32字节的数据，在握手时，客户端和服务器都会提供随机数。这种随机性对每次握手都是独一无二的，在身份验证中起着举足轻重的作用。它可以防止重放攻击，并确认初始数据交换的完整性。Session ID：在第一次连接时，会话ID（session ID）字段是空的，这表示客户端并不希望恢复某个已存在的会话。在后续的连接中，这个字段可以保存会话的唯一标识。服务器可以借助会话ID在自己的缓存中找到对应的会话状态。典型的会话ID包含32字节随机生成的数据，这些数据本身并没有什么价值。Cipher Suites：密码套件（cipher suite）块是由客户端支持的所有密码套件组成的列表，该列表是按优先级顺序排列的。Compression：客户端可以提交一个或多个支持压缩的方法。默认的压缩方法是null，代表没有压缩。Extensions：扩展（extension）块由任意数量的扩展组成。这些扩展会携带额外数据。 ServerHello
ServerHello消息的意义是将服务器选择的连接参数传送回客户端。这个消息的结构与ClientHello类似，只是每个字段只包含一个选项。服务器无需支持客户端支持的最佳版本。如果服务器不支持与客户端相同的版本，可以提供某个其他版本以期待客户端能够接受。
Certificate
典型的Certificate消息用于携带服务器X.509证书链。证书链是以ASN.1 DER编码的一系列证书，一个接着一个组合而成。主证书必须第一个发送，中间证书按照正确的顺序跟在主证书之后。根证书可以并且应该省略掉，因为在这个场景中它没有用处。
服务器必须保证它发送的证书与选择的算法套件一致。比方说，公钥算法与套件中使用的必须匹配。除此以外，一些密钥交换算法依赖嵌入证书的特定数据，而且要求证书必须以客户端支持的算法签名。所有这些都表明服务器需要配置多个证书（每个证书可能会配备不同的证书链）。
Certificate消息是可选的，因为并非所有套件都使用身份验证，也并非所有身份验证方法都需要证书。更进一步说，虽然消息默认使用X.509证书，但是也可以携带其他形式的标志；一些套件就依赖PGP密钥。
ServerKeyExchange
ServerKeyExchange消息的目的是携带密钥交换的额外数据。消息内容对于不同的协商算法套件都会存在差异。在某些场景中，服务器不需要发送任何内容，这意味着在这些场景中根本不会发送ServerKeyExchange消息。
ServerHelloDone
ServerHelloDone消息表明服务器已经将所有预计的握手消息发送完毕。在此之后，服务器会等待客户端发送消息。
ClientKeyExchange
ClientKeyExchange消息携带客户端为密钥交换提供的所有信息。这个消息受协商的密码套件的影响，内容随着不同协商密码套件而不同。
ChangeCipherSpec
ChangeCipherSpec消息表明发送端已取得用以生成连接参数的足够信息，已生成加密密钥，并且将切换到加密模式。客户端和服务器在条件成熟时都会发送这个消息。
Finished
Finished消息意味着握手已经完成。消息内容将加密，以便双方可以安全地交换验证整个握手完整性所需的数据。这个消息包含verify_data字段，它的值是握手过程中所有消息的散列值。
握手之客户端身份验证&amp;服务器身份验证 相比如对服务器的验证，双向验证中多了CertificateRequest，CertificateVerify，Certificate.而Certificate与服务器验证过程中的含义相同.所以主要来看下CertificateRequest，CertificateVerify的含义.
CertificateRequest
服务器使用CertificateRequest消息请求对客户端进行身份验证，并将其接受的证书的公钥和签名算法传送给客户端。它也可以选择发送一份自己接受的证书颁发机构列表，这些机构都用其可分辨名称来表示：struct { ClientCertificateType certificate_types; SignatureAndHashAlgorithm supported_signature_algorithms; DistinguishedName certificate_authorities; } CertificateRequest; CertificateVerify
客户端使用CertificateVerify消息证明自己拥有的私钥与之前发送的客户端证书中的公钥相对应。消息中包含一条到这一步为止的所有握手消息的签名：struct { Signature handshake_messages_signature; } CertificateVerify; 握手之会话恢复 恢复早先会话的步骤如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/413254e59b153b114a67496241542f18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d745ba2e0b37b338000cc30e5136bf6/" rel="bookmark">
			第三章第一题（代数：解一元二次方程）(Algebra: solve quadratic equations)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		*3.1（代数：解一元二次方程）可以使用下面的公式求一元二次方程 两个根： 和 称作一元二次方程的判别式。如果它是正值，那么一元二次方程就有两个实数根。如果它为0，方程式就只有一个根。如果它是负值，方程式无实数根。 编写程序，提示用户输入a、b和c的值，并且显示基于判别式的结果。如果这个判别式为正，显示两个根。如果判别式为0，显示一个根。否则，显示“The equation has no real roots”（该方程式无实数根）。 注意，可以使用Math.pow(x,0.5) 来计算。 下面是一些运行示例： Enter a, b, c:1.0 3 1
The equation has two roots -0.381966 and -2.61803
Enter a, b, c:1 2.0 1
The equation has one root -1.0
Enter a, b, c:1 2 3
The equation has no real roots
*3.1(Algebra: solve quadratic equations) The two roots of a quadratic equation can be obtained using the following formula: and is called the discriminant of the quadratic equation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d745ba2e0b37b338000cc30e5136bf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43d76e66225dc9995bcee67cefc34b70/" rel="bookmark">
			我的Java学习之路（第二十天）------ 总结常见的数组异常（越界与空指针）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（参考：尚硅谷_宋红康_Java语言基础）
文章目录 数组异常数组的越界空指针 数组异常 数组的越界 int[] arr = new int[4]; for(int i=0;i&lt;arr.length;i++){ statement....... } 上面这个例子毫无疑问是正确的，但如果把里面的条件改为i&lt;=arr.length，便会导致越界；
当然越界也可能是左边界越界，不多叙述；
空指针 这里列举三个常见的情况：
①下面的这个例子 中arr = null仅仅是模拟某些情况下特殊操作所导致，arr原本指向一个堆空间地址，操作后指向null；
package de1; public class Test2 { public static void main(String[] args) { int arr[] = new int[] {1,2,3}; arr = null; System.out.println(arr[0]); } } ②
package de1; public class Test2 { public static void main(String[] args) { int[][] arr = new int[4][]; System.out.println(arr[0][0]); } } ③
package de1; public class Test2 { public static void main(String[] args) { String[] arr = new String[] {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43d76e66225dc9995bcee67cefc34b70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0c57eee884a192512816f53e73f8905/" rel="bookmark">
			Python 之路  元组（）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tuple
元组不可改变序列，不能修改元组中的元素
创建元组
1.（）小括号包裹
a=（10，20，30） 或 a=10，20，30 小括号可以省略
如果只有一个则表示为a=（10，）不加逗号的话会默认为int型
2.tuple函数
b=tuple（“abc”）
排序
只能使用内置函数sorted（）
zip（列表1，列表2，）将多个列表对应的位置的元素组合成元组，并返回这个zip对象
最后用list调用
d=zip（a，b，c）
list（d）
生成器
s=(x*2 for x in range(5))
tuple(s)
结果为自动生成
(0,2,4,6,8)
list(s) 为空 因为只能访问一次，第二次需要再生成
s.next()逐一生成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2dfdd4642304e9fde95849ce55558f9/" rel="bookmark">
			细读HTTPS -- SSL/TLS历史,密码学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 细读HTTPS -- SSL/TLS历史,密码学SSL/TLS协议历史密码学对称加密分组密码模式ECBCBC 非对称加密消息验证代码散列函数数字签名 细读HTTPS – SSL/TLS历史,密码学 SSL/TLS协议历史 SSL协议由Netscape公司开发，历史可以追溯到Netscape Navigator浏览器统治互联网的时代。
第一个版本从未发布过第二版即SSL2则于1994年11月发布。SSL2的开发基本上没有与Netscape以外的安全专家进行过商讨，所以有严重的弱点，被认为
是失败的协议，最终退出了历史的舞台SSL3于1995年年底发布，虽然名称与早先的协议版本相同，但SSL 3是完全重新设计的协议。该设计一直沿用到今天。TLS 1.0于1999年1月问世。尽管与SSL3相比，版本修改并不大，但是为了取悦Microsoft，协议还是进行了更名，SSL更名为TLS。TLS 1.1于2006年4月发布，仅仅修复了一些关键的安全问题.TLS 1.2于2008年8月发布，。该版本添加了对已验证加密的支持，并且基本上删除了协议说明中所有硬编码的安全基元，使协议完全弹性化。协议的下一个版本正在开发过程中。 密码学 讨论密码学时，我们为了方便起见，通常会使用Alice和Bob这两个名，Eve为一位具备窃听能力的攻击者命名，Mallory为另一位能够妨碍网络流量的主动攻击者命名.
对称加密 对称加密（symmetric encryption）又称私钥加密（private-key cryptography），是一种混淆算法，能够让数据在非安全信道上进行安全通信。为了保证通信安全，Alice和Bob首先得到双方都认可的加密算法和密钥。当Alice需要向Bob发送数据时，她使用这个密钥加密数据。Bob使用相同的密钥解密。Eve能够访问信道，所以可以看到加密数据；但因为没有密钥，所以看不到原始数据。Alice和Bob只要能保证密钥安全，就能一直安全地通信，如图1-1所示。
对称加密的密码分为两大类：序列密码和分组密码。
序列密码
序列密码的核心是生成一串称为密钥序列（keystream）的无穷序列，看似杂乱无章。加密就是将密钥序列中的1字节与明文序列中的1字节进行异或操作。因为异或操作是可逆的，所以解密就是将密文序列中的1字节与密钥序列中的相同字节进行异或操作。如下图所示：
RC4是最为人熟知的序列密码①。因为它很快很简单，所以一度非常流行。但是它已经不再安全。
只要攻击者无法预测密钥序列中对应位置的字节，就可以认为加密过程是安全的。基于这个理由，序列密码绝不能第二次使用相同的密钥，这一点非常关键。这是因为在实际使用中，攻击者知道或者可以预测特定区域的明文（请思考加密HTTP请求的情景；许多请求的请求法、协议版本、请求头名称都是一样的）。当你知道明文，又观察到密文时，就可以解析一部分密钥序列。如果使用了相同的密钥，那么就可以解密后续的部分密文。为了解决这个问题，序列密码都与从长期密钥中提取出来的一次性密钥一同使用。分组密码
一种分组密码就是一个变换函数：接受输入并生成看似杂乱无章的输出。只要使用相同的密钥，每一个可能的输入组合都有唯一的输出。分组密码的关键特性是在输入上制造一个小变化（比如，在任意一处变换1位），从而得到大量输出变体。
分组密码本身不是非常有用，因为它们自身有一些限制： 只能使用它们加密长度等于加密块大小的数据。因此在实际使用分组算法时，需要一个方法处理任意长度的数据。分组密码是确定的。对于相同的输入，输出也是相同的。这个特性会使许多攻击成为可能，需要解决。实践中，人们通过称为分组密码模式（block cipher mode）的加密方案来使用分组密码。世界上最流行的分组密码是高级加密标准（advanced encryption standard，AES），可以使用128位、192位和256位的加密强度. 填充
分组密码的挑战之一是处理数据长度小于加密块大小的数据加密。举个例子，128位的AES需要16字节的输入数据并且产出相同长度的出。如果你的数据刚好能归入16字节的块中，那正好。但如果不足16字节，怎么办？一种方法是追加额外的数据到明文的尾部。这些额外的数据就被称为填充（padding）。
在TLS中，加密块的最后1字节包含填充长度，指示填充有多少字节（不包含填充长度字节）。填充的每字节都被设置成与填充长度字节同的值，如图下图所示。这种方式使得接收方能够检查填充是否正确。为了在解密后丢弃填充，接收方检查数据块的最后1字节，删除它。接着，接收方删除指定长度的字节数，同时检查它们是否都是相同的值。
分组密码模式 分组密码模式是为了加密任意长度的数据而设计的密码学方案，是对分组密码的扩展。所有分组密码模式都支持机密性，不过有些将其与身份验证联系起来。一些模式会将分组密码转换成序列密码。
它有许多输出模式，通常以首字母缩写来引用：ECB、CBC、CFB、OFB、CTR、GCM，诸如此类（不用担心这些缩写都代表什么）。我在这里只会介绍ECB和CBC：ECB是设计一种分组加密模式的反面例子，而CBC则仍是SSL和TLS的主要模式。GCM是TLS中相对较新的模式，从1.2版本开始才能使用。它提供了机密性和完整性，是当前可用的最好模式。
ECB 电码本模式（electronic codebook）是最简单的分组密码模式。它只支持数据长度正好是块大小的整数倍的情况，如果数据长度不满足这个条件，就得事先实施填充。加密就是将数据按块大小切分，再分别加密每一块。
CBC 加密块链接（cipher block chaining，CBC）模式是从ECB发展而来的下一步。为了解决ECB天生的确定性，CBC引入了初始向量（initialization vector，IV）的概念。即使输入相同，IV也可以使每次的输出都不相同。
如图下图所示，整个过程开始于生成一个随机IV（因此不可预测），长度与加密块相等。加密前，明文第一块内容与IV进行异或操作。这一步对明文进行了掩饰，并保证密文总是不尽相同。对于下一个加密块，使用上一块的密文作为IV，以此类推。这样一来，每次加密操作都是同一个加密链条中的一部分，这也是这种模式名称的由来。至关重要的是，IV必须通过线路传送到接收端，这个信息是成功解密所必需的。
非对称加密 对称加密在高速处理大量数据方面做得非常好，然而随着使用它的团体增加，产生了更多的需求，使得对称加密无法满足。
相同团体的成员必须共享相同的密钥。越多人加入，团体密钥出现问题的次数就越多。为了更好的安全性，你可以在每两个人之间使用不同的密钥，但是这个方法不可扩展对称加密不能用于访问安全数据的无人系统。因为使用相同的密钥可以反转整个过程，这样的系统出现任何问题都会影响到存储在系统中的所有数据。
非对称加密（asymmetric encryption）又称为公钥加密（public key cryptography），它是另一种方法，使用两个密钥，而不是一个；其中一个密钥是私密的，另一个是公开的。顾名思义，一个密钥用于私人，另一个密钥将会被所有人共享。这两个密钥之间存在一些特殊的数学关系，使得密钥具备一些有用的特性。如果你利用某人的公钥加密数据，那么只有他们对应的私钥能够解密。从另一个方面讲，如果某人用私钥加密数据，任何人都可以利用对应的公钥解开消息。后面这种操作不提供机密性，但可以用作数字签名。
RSA（得名于三个人的姓氏首字母：Ron Rivest、Adi Shamir和Leonard Adleman）是目前最普遍部署的非对称加密算法①。现在推荐的RSA强度是2048位，强度等同于112位的对称密钥。 消息验证代码 消息验证代码（messageauthentication code，MAC）是以身份验证扩展了散列函数的密码学函数。只有拥有散列密钥，才能生成合法的MAC。
((原始消息) + 秘钥) * 散列函数 = 散列值(消息认证码)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2dfdd4642304e9fde95849ce55558f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87ef1f9a57fdb7bf28908cdf0f8747ad/" rel="bookmark">
			lotus 本地运行，没有远程矿工
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lotus 本地运行 1，lotus 本地运行2，16核 1，lotus 本地运行 # lotus-storage-miner info Worker use: Local: 0 / 4 (+1 reserved) Remote: 0 / 0 # date 2020年 02月 03日 星期一 20:48:55 CST # lotus-storage-miner pledge-sector 2020-02-03T21:24:32.671+0800	INFO	sectors	sealing/states.go:16	performing filling up rest of the sector...	{"sector": 21} 2020-02-03T21:24:32.691+0800	INFO	sectors	sealing/states.go:61	performing sector replication...	{"sector": 21} 2020-02-04T03:22:56.782+0800	INFO	sectors	sealing/states.go:119	submitting precommit for sector: 21 2020-02-04T03:22:56.814+0800	INFO	sectors	sealing/states.go:130	Sector precommitted: 21 2020-02-04T03:24:45.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87ef1f9a57fdb7bf28908cdf0f8747ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb9b323d6cd140dba2953fe2af4934eb/" rel="bookmark">
			eclipse 新手首次创建一个java项目并运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eclipse 新手首次使用创建一个java项目并运行 双击eclipse，选择工作空间，这里按Browse，把之后写的代码都放在里面。
点击Launch，第一次启动会有点慢
把welcome点击关闭
在左边的Package Exploer的下方空白处按鼠标右键，选择New-&gt;Java Project，在Project name随便写一个工程名字，点击Finish
这里我选择了Don’t Creat
然后鼠标左键单击选中工程，这里我是Hello,右键New-&gt;Package,随便取一个包名字，点击Finish
接着选中刚刚创建的包（com.xx.hello），右键New-&gt;Class,随便取一个类名
最后在类里面写一段可运行的代码测试，测试可以点击上方的这个按钮
也可以在类里面，鼠标右击选择Run As-&gt;1 java Application
点击OK
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dc22c6ede30f14a65a1df7b1f74b8e7/" rel="bookmark">
			我的Java学习之路（第十九天）------ 排序算法(冒泡排序、快速排序)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（参考：尚硅谷_宋红康_Java语言基础）
文章目录 数组的冒泡排序数组的快速排序 数组的冒泡排序 package de1; public class Test2 { public static void main(String[] args) { int[] arr=new int[] {-6,-3,0,1,3,5,9,56,58,99}; for(int i=0;i&lt;arr.length-1;i++) { for(int j=0;j&lt;arr.length-i-1;j++) { if (arr[j] &gt; arr[j+1]) { int buf = arr[j]; arr[j] = arr[j+1]; arr[j+1] = buf; } } } for(int x:arr) { System.out.print(x+" "); } } } 数组的快速排序 package de1; public class Test2 { private static void swap(int[] data,int i,int j) { int temp = data[i]; data[i] = data[j]; data[j] = temp; } public static void subsort(int[] data,int start,int end) { if(start &lt; end) { int base = data[start]; int low = start; int high = end + 1; while(true) { while(low &lt; end &amp;&amp; data[++low] - base &lt;=0) ; while(high &gt; start &amp;&amp; data[--high] - base &gt;=0) ; if(low &lt; high) { swap(data,low,high); }else { break; } swap(data,start,high); subsort(data,start,high-1); subsort(data,high+1,end); } } } public static void quicksort(int[] data) { subsort(data,0,data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dc22c6ede30f14a65a1df7b1f74b8e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa3858c86e2ae08badab1733e06ba639/" rel="bookmark">
			我的Java学习之路（第十九天）------ 数组的复制、反转、查找（线性查找、二分法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（参考：尚硅谷_宋红康_Java语言基础）
文章目录 数组的复制数组的反转数组的查找线性查找二分法查找 数组的复制 假定两个数组arr1与arr2，如果使用arr2 = arr1，但是这个并不能实现数组的复制，因为在此时堆空间当中只有一个数组，arr2 = arr1实现的仅仅是将arr1的地址复制给了arr2，让它们都指向堆空间的唯一的一个数组实体；
那如何真正意义上取实现数组的复制呢？
①其中一个方法就是使用遍历的额方式取逐个赋值
package de1; public class Test2 { public static void main(String[] args) { int[] array1,array2; array1 = new int[] {1,2,3,4,5}; array2 = new int[array1.length]; for(int i=0;i&lt;array2.length;i++) { array2[i] = array1[i]; } System.out.println("Array1:"); for(int i:array1) { System.out.println(i); } System.out.println("Array2:"); for(int i:array1) { System.out.println(i); } } } ②其他方式可以参考我以前写的博客
https://blog.csdn.net/solitudi/article/details/104014858
数组的反转 提供其中两种方式
①
package de1; public class Test2 { public static void main(String[] args) { int[] arr = new int[] {1,2,3,4,5}; //数组的反转 for(int i =0;i &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa3858c86e2ae08badab1733e06ba639/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a9dbaa2638f4ca6294067b6d9be9054/" rel="bookmark">
			v-for
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		v-for 遍历数据渲染页面是非常常用的需求，Vue中通过v-for指令来实现。
遍历数组 语法：
v-for="item in items" items：要遍历的数组，需要在vue的data中定义好。
item：迭代得到的数组元素的别名
示例
&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="user in users"&gt; {{user.name}} - {{user.gender}} - {{user.age}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var app = new Vue({ el: "#app", data: { users:[ {name:'柳岩', gender:'女', age: 21}, {name:'峰哥', gender:'男', age: 18}, {name:'范冰冰', gender:'女', age: 24}, {name:'刘亦菲', gender:'女', age: 18}, {name:'古力娜扎', gender:'女', age: 25} ] }, }) &lt;/script&gt; 效果：
数组角标 在遍历的过程中，如果我们需要知道数组角标，可以指定第二个参数：
语法
v-for="(item,index) in items"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a9dbaa2638f4ca6294067b6d9be9054/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83e85d46beeb57c2d6c13ea4fa7c7fd2/" rel="bookmark">
			HTTP协议详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 HTTP协议详解HTTP协议的特点：HTTP协议详解之URLHTTP协议详解之请求方法HTTP协议详解之请求报文请求行请求首部字段AcceptAccept-CharsetAccept-EncodingAccept-LanguageAuthorizationExpectFromHostIf-xxxxMax-ForwardsProxy-AuthorizationRangeRefererTEUser-Agent HTTP协议详解 HTTP协议的特点： 支持客户/服务器模式。简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。单请求：每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP协议详解之URL HTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下：
http://host[":"port][abs_path]
http表示要通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。 例如：
输入：www.guet.edu.cn
浏览器自动转换成：http://www.guet.edu.cn/最终的URL：http:192.168.0.116:8080/index.jsp HTTP协议详解之请求方法 HTTP协议详解之请求报文 下图是HTTP请求报文的结构.
请求行 以一个方法符号开头，以空格或斜杠分开，后面跟着请求的URI和协议的版本。
格式如下：Method Request-URI HTTP-Version CRLF
Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。 例如：GET / 123.jpg / HTTP1.1
请求首部字段 请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。
Accept Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。
常见accept媒体类型有：
- 文本文件
text/html, text/plain, text/css …
application/xhtml+xml, application/xml …
- 图片文件
image/jpeg, image/gif, image/png …
- 视频文件
video/mpeg, video/quicktime …
- 应用程序使用的二进制文件
application/octet-stream, application/zip …
Accept-Charset Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83e85d46beeb57c2d6c13ea4fa7c7fd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0f3d00af4c000f0f7f77d125c132524/" rel="bookmark">
			EasyUI框架02——datagrid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		datagrid是easyUI使用比较常用的一个组件，列表等基本功能的使用，可以参考easyUI的API。
1. Editor的用法 editor编辑器是easyUI中比较重要的一个东东，在其他组件中都有其身影。
1.1 常用API 1.1.1 获取 1）获取编辑器
获取索引值为index，字段field的编辑器
var editor = $(this).datagrid('getEditor', {index: index, field: field}); 2）获取编辑器数据
1. 获取combobox的数据
var editors = $('#product_info_table').datagrid('getEditors', index); productName = editors[0].target.combobox('getValue'); 2. 获取input的数据
var editors = $('#product_info_table').datagrid('getEditors', index); productName = editors[1].target.val(); 1.1.2 编辑器的生命周期 1）开始编辑器
$("#id").datagrid('beginEdit', index); 2）结束编辑器
$("#id").datagrid('endEdit', currentEditIndex); 3）取消编辑器
$("#product_info_table").datagrid('cancelEdit',index); 1.1.3 聚焦到编辑行 $(editor.target).focus(); 1.2 动态编辑器 1.2.1 定义 /* * 动态Editor * */ function initEditor(type){ if(type === 'treegrid'){ $.extend($.fn.treegrid.methods, { addEditor : function(jq, param) { if (param instanceof Array) { $.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0f3d00af4c000f0f7f77d125c132524/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3171d7db429e4e4a562060782d455a8/" rel="bookmark">
			Spring容器中获取Bean实例的七种方式（附实战源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 写作说明一：写作原因二：源码出处 实现方式一：使用BeanFactory直接获取（不推荐）二：在初始化时保存ApplicationContext对象三：继承自抽象类ApplicationObjectSupport四：继承自抽象类WebApplicationObjectSupport五：使用Spring提供的工具类WebApplicationContextUtils六：实现ApplicationContextAware接口七：使用ContextLoader提供的getCurrentWebApplicationContext方法 写作说明 一：写作原因 首先解释一下写这篇博文的原因，因为在使用spring框架的过程中获取bean是非常常见的操作，但是网上非常的博文大多承自一家之言，因此很多可操作性上并不强，本文是通过自己实战，亲自尝试之后提供的几种方案，供大家一起学习探讨。
二：源码出处 本文出自原创，如果您转发请注明出处，另本文提供的测试代码为chapter-1-springmvc-quickstart中的单元测试类BeanUtilTest如果有需要的可自行下载
实现方式 本文一共提供七种实现方式：
一：使用BeanFactory直接获取（不推荐） 使用BeanFactory从工厂中直接获取Bean实例，但是XmlBeanFactory类已经废弃，因此不建议使用，测试代码如下：
/** * 方式一：XmlBeanFactory已经废弃不建议使用 */ @Test public void getBeanTest1() { BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("applicationContext.xml")); UserInfo userInfo = (UserInfo) beanFactory.getBean("userInfo"); System.out.println(userInfo); } 二：在初始化时保存ApplicationContext对象 可以在初始化的时候保存ApplicationContext对象，然后通过这个对象获取Bean，测试代码如下：
/** * 方式二：使用ClassPathXmlApplicationContext获取ApplicationContext */ @Test public void getBeanTest2() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml"); UserInfo userInfo = (UserInfo) applicationContext.getBean("userInfo"); System.out.println(userInfo); } 三：继承自抽象类ApplicationObjectSupport 可以继承抽象类ApplicationObjectSupport并将自己继承的类注入到Spring容器中，示例代码如下：
/** * 方法三：继承ApplicationObjectSupport来获取ApplicationContext， * 注意：需要把自己继承的类注入到Spring */ @Test public void getBeanTest3() { ApplicationContextUtil2 applicationContextUtil2 = (ApplicationContextUtil2) ApplicationContextUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3171d7db429e4e4a562060782d455a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c3d634ce04343b6ab9bde6cc601c368/" rel="bookmark">
			ENVI 出现问题：丢失idl.dll（win10系统）解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ENVI 出现问题：丢失idl.dll，官方给出的建议是重新安装ENVI，太麻烦了，其实是防火墙的问题，给出以下快速解决方案。
1.打开windows设置–&gt;更新和安全–&gt;windows安全中心–&gt;病毒和威胁防护–&gt;威胁历史记录 2.找到被隔离的idl.dll文件–&gt;展开–&gt;选择还原 3.在允许的威胁选项中，选择允许，即可正常使用ENVI啦 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/103905ec23cf3fc0c666ee45af33466f/" rel="bookmark">
			我的Java学习之路（第十七天）------关于随机数的一个Java面试题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 （参考：尚硅谷_宋红康）
题目内容为：
创建一个长度为6的int型数组，取值为1-30，并且元素值各不相同
思路：第一个数字不用管（因为没有数字和它重复），从第二个元素开始，依次比较与前面数字是否相同，如果相同则重新生成一个新的随机数，下面为实现代码；
🌂很简单，一眼就能看懂(Eg：如果没看懂，评论区评论下，我会解释的，不过应该不存在这个问题)
package de1; public class Test { public static void main(String[] args) { //创建数组 int[] array = new int[6]; for(int i=0;i&lt;array.length;i++) { //保证了数组里的数在[1,30]之间 array[i] = (int)(Math.random() * 30) + 1; //判断是否与前面的数字相同，若相同则重新给当前数组元素赋值 for(int j=0;j&lt;i;j++) { if(array[i]==array[j]) i--; break; } } //遍历数组 for(int x:array) { System.out.println(x); } } } 当然，遍历数组还有另外一种方式，两种方式是等价的；
for(int i=0;i&lt;array.length;i++) { System.out.println(array[i]); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b82436f60afa15d9398f2efad66686bf/" rel="bookmark">
			ad pcb界面变成灰色无法编辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在pcb库中编译后有一个error，点之后就无法编辑pcb了
解决方法
右键-&gt;过滤器（filter）-&gt;清除过滤器（clear filter）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/972ea3556a9a4354af254da8f666251f/" rel="bookmark">
			Spring Data JPA详细入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、概述1. JPA2. Spring Data JPA 二、使用JPA1. 添加依赖2. 相关配置3. 生成实体类（1）添加JPA（2）配置数据库（3）生成实体类（4）生成完的实体类中存在的问题（a）生成的实体类中 `setter` 的返回值类型为：`_Dummy_`（b）@Column注解name属性报红，没有找到实体类与数据库的映射 4. 实体类注解说明5. dao层（1）创建dao层（2）方法名查询分页查询的使用： （3）自定义SQL/HQL查询 三、使用EasyCode插件生成代码 一、概述 1. JPA JAP全称Java Persistence API，即Java持久化API：一套Sun公司Java官方制定的ORM 方案，是规范，sun公司自己并没有实现。
ORM全称Object Relational Mapping，即对象关系映射：在操作数据库之前，先把数据表与实体类关联起来。然后通过实体类对象操作（增删改查）数据库表。所以，JPA的作用就是通过对象操作数据库的，不用编写sql语句；也可以理解为通过ORM将实体对象持久化到数据库中。
2. Spring Data JPA spirng data jpa是spring提供的一套简化JPA开发的框架，按照约定好的【方法命名规则】写dao层接口，就可以在不写接口实现的情况下，实现对数据库的访问和操作。同时提供了很多除了CRUD之外的功能，如分页、排序、复杂查询等等。
Spring Data JPA 可以理解为 JPA 规范的再次封装抽象，底层还是使用了 Hibernate 的 JPA 技术实现
二、使用JPA 这里使用的是Spring Boot 集成JPA
1. 添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.35&lt;/version&gt; &lt;/dependency&gt; 2. 相关配置 application.yml的配置
spring: #连接mysql数据库 datasource: url: jdbc:mysql://localhost:3306/news username: root password: 123456 driver-class-name: com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/972ea3556a9a4354af254da8f666251f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd26a1b228b3883b5db2d23cdbd79d63/" rel="bookmark">
			Win10 封装报错处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近因某公司大量升级系统到Windows 10，需要协助做一个封装系统加快升级进度。
结果把所有软件都安装好，在进行封装的时候发生错误了，用IT天空的EasySysPrep在进行封装的时候显示如下图错误：
国外国内的搜索引擎找了不少的内容看，什么删除用户、设置权限、改注册表、看Microsoft Store等办法全试过了都没解决。
受了一些帖子的启发，决定立足自己看能不能在系统日志上找出端倪，最后终于找到办法。
首先说明一下我的环境是这样的：Hyper-V安装的虚拟机，安装Windows 10，把所有的软件都安装设置好，必要的Windows设置做好，在这些步骤完成后设置一个Checkpoint（还原点），这样万一步骤出错可以迅速倒回此处再战。
具体解决问题步骤如下：
打开%Windir%\System32\Sysprep文件夹，运行里面的sysprep.exe，勾上复选框"Generalize”（一般化），再点OK（确定）按钮如下图：
好了，出错了：
打开%Windir%\System32\Sysprep\Panther文件夹，一开始这个文件夹可能不存在，但一运行sysprep.exe这个文件夹就自动创建了，打开里面的setupact.log文件，滚到底部，可以发现有类似“2019-04-11 09:34:13, Error SYSPRP Package 89006A2E.AutodeskSketchBook_1.8.5.0_x64__tf1gferkr813w was installed for a user, but not provisioned for all users. This package will not function properly in the sysprep image.”字样，我们提取里面的“Package”后面，“was installed”前面的部分，实际就是“89006A2E.AutodeskSketchBook_1.8.5.0_x64__tf1gferkr813w”。
利用上面提取到的内容，组合成下面的命令：
remove-appxpackage -package ‘89006A2E.AutodeskSketchBook_1.8.5.0_x64__tf1gferkr813w’ -allusers
记得把这个命令保存在一个文档里，因为类似的操作很多，需要记录下来后面要用到
在要封闭的虚拟机环境里以管理员权限运行“Windows PowerShell”，在窗口中粘贴上面第三步的命令，并回车执行如下图：
这个命令用来移除系统里的这个APP
删除文件“%Windir%\System32\Sysprep\Panther\setupact.log”，重复第1到5步，直到第1步不再出错。
返回在执行以上步骤之前的虚拟机还原点，进入要封装的系统，以管理员权限运行Windows PowerShell，把刚才收集的一系列命令一次性粘贴进去，像我的有8个之多：
接下来关闭Windows PowerShell再次运行封装工具，就没有错误了。
作者：达叔傻乐
链接：https://www.jianshu.com/p/6e4bf267a937
來源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f2b0d09fb0a0a6b6b4c4a867eb0acfb/" rel="bookmark">
			Java笔记-使用Kaptcha验证码框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Kaptcha这个验证码框架用起来，比自己写简单
首先设置maven项目：
&lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;/dependency&gt; 然后配置WEB-INF下的web.xml
&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt; &lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;kaptchaDemo&lt;/servlet-name&gt; &lt;url-pattern&gt;/kaptcha&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;kaptchaDemo&lt;/servlet-name&gt; &lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.border&lt;/param-name&gt; &lt;param-value&gt;no&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.textproducer.font.color&lt;/param-name&gt; &lt;param-value&gt;red&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.image.width&lt;/param-name&gt; &lt;param-value&gt;80&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.image.height&lt;/param-name&gt; &lt;param-value&gt;30&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.textproducer.char.string&lt;/param-name&gt; &lt;param-value&gt;0123456789&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.textproducer.char.length&lt;/param-name&gt; &lt;param-value&gt;4&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.textproducer.char.space&lt;/param-name&gt; &lt;param-value&gt;3&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;kaptcha.textproducer.font.size&lt;/param-name&gt; &lt;param-value&gt;24&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- &lt;init-param&gt;--&gt; &lt;!-- &lt;param-name&gt;kaptcha.noise.impl&lt;/param-name&gt;--&gt; &lt;!-- &lt;param-value&gt;com.google.code.kaptcha.impl.NoNoise&lt;/param-value&gt;--&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f2b0d09fb0a0a6b6b4c4a867eb0acfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b8b4884825f68f12cab6ae1af924076/" rel="bookmark">
			细粒度图像分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		细粒度图像分类
细粒度图像分类的经典方法是首先在图像上定义不同的位置，例如，鸟的头部、脚部或翅膀。然后我们必须从这些位置提取特征，最后，组合这些特征并使用它们来完成分类。
目前在工业界和实际生活中有着广泛的业务需求和应用场景。细粒度图像相较于粗粒度图像具有更加相似的外观和特征，加之采集中存在姿态、视角、光照、遮挡、背景干扰等影响，导致数据呈现类间差异性大、类内差异性小的现象，从而使分类更加具有难度。
局部特征：早期基于人工特征的细粒度图像分类算法，其研究重点为图像的局部特征，一般先从图像中提取某些局部特征，然后利用相关编码模型进行特征编码。
视觉词包：为了进一步提升分类精度，相关人员在局部特征的基础上又进一步提出视觉词包（BOVW）的概念。通过统计图像的整体信息，将量化后的图像作为视觉单词，通过视觉单词分布来描述图像内容。（例如，把一张图像当做一个文档，从图像中提取出来的特征就相当于词（通常还需要一些额外的操作，下面会提到）。词包表示法可以作为进一步图像处理的基本步骤，如对象分类。）
特征定位：局部特征和视觉词包都没有构建与全局特征之间的关联，只在图像的部分区域进行语义挖掘，因此人们提出对特征进行定位，如利用关键点的位置信息发现最具价值的图像信息。
基于特征提取的传统算法
局部特征：由于局部特征选择过程繁琐，表述能力有限，其自身也存在一定缺陷，即忽略了不同局部特征之间的关联以及与全局特征之间的位置空间关系，因此并没有取得令人满意的结果。
视觉词包：词包模型与一系列特征提取算法进行融合，虽然取得了一定的进展，但距离实际应用要求还有很远的距离。同时，构建词包的过程非常复杂，需要额外的处理工作。
特征定位：局部特征和视觉词包都没有构建与全局特征之间的关联，只在图像的部分区域进行语义挖掘，因此人们提出对特征进行定位，如利用关键点的位置信息发现最具价值的图像信息。
通过位置信息的辅助，分类精度也得到了一定的提高，但是位置信息的获取需要高精度的算法来完成，同时还需要精细的人工标注，其成本更大。
基于深度学习的算法
随着深度学习的兴起，从神经网络中自动获得的特征，比人工特征具有更强大的描述能力，在一定程度上极大地促进了细粒度图像分类算法的发展。
根据监督方式的不同，该类算法可以分为强监督和弱监督两种类别。
强监督细粒度图像分类
强监督利用bounding box和key point等额外的人工标注信息，获取目标的位置、大小等，有利于提升局部和全局之间的关联，从而提高分类精度。Multi-proposal Net则通过Edge Box Crop方法获取图像块，并引入关键点及视觉特征的输出层，进一步强化了局部特征与全部信息直接的位置关联，该算法在CUB-200数据集上取得了80.3%的精度。
弱监督细粒度图像分类
弱监督即仅利用图像的类别标注信息，不使用额外的标注。该方法又可以总结为图像过滤和双线性网络两类。
图像过滤：图像过滤的思想和强监督中利用bounding box的方法类似，只不过仅借助于图像的类别信息过滤图片中与物体无关的模块，其中比较有代表性的即Two Attention Level算法。该算法在CUB-200数据集上取得了75.7%的精度。
**双线性网络：**B-CNN根据大脑工作时同认知类别和关注显著特征的方式，构建了两个线性网络，协调完成局部特征提取和分类的任务，该算法在CUB-200数据集上取得了84.1%的精度，不过该方法在合并阶段会产生较高的维度，使得整个计算开销非常大。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91205db6e57a3a4edbe7fa1462cf2535/" rel="bookmark">
			Ansible之roles（角色）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、roles介绍
角色（roles）是ansible自1.2版本开始引入的新特性，用于层次性，结构化地组织playbook。
roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。要使用roles只需要在playbook中使用include指令即可。简单的说，roles就是通过分别将变量、文件、任务、模块及处理器放置于单独的目录中、并可以便捷地include他们的一种机制。角色一般用于基于主机构建服务的场景中、但也可以是用于构建守护进程等场景中。
1、yml文件，用于定义此角色用到的各handler：在handler中使用include包含的其他的handler文件也应该位于此目录中；
2、files目录：存放由copy或script等模块调用的文件；
3、templates目录：templates模块会自动在此目录中寻找Jinja2模板文件；
4、tasks目录：至少应该包含一个名为main.yml的文件，其定义了此角色的任务列表；此文件可以使用include包含其他的位于此目录中的task文件；
5、handlers目录：此目录中应当包含一个main；
6、vars目录：应当包含一个main.yml文件，用于定义此角色用到的变量；
7、meta目录：应当包含一个main.yml文件，用于定义此角色的特殊设定及其依赖关系；ansible 1.3及其以后的版本才支持
8、default目录：为当前角色设定默认变量时使用此目录；应当包含一个main.yml文件；
这个 playbook 为一个角色 ‘x’ 指定了如下的行为：
如果 roles/x/tasks/main.yml 存在, 其中列出的 tasks 将被添加到 play 中
如果roles/x/handlers/main.yml 存在, 其中列出的 handlers 将被添加到 play 中
如果roles/x/vars/main.yml 存在, 其中列出的 variables 将被添加到 play 中
如果roles/x/meta/main.yml 存在, 其中列出的 “角色依赖” 将被添加到 roles 列表中 (1.3 andlater)
所有 copy tasks 可以引用 roles/x/files/ 中的文件，不需要指明文件的路径。
所有 scripttasks 可以引用 roles/x/files/ 中的脚本，不需要指明文件的路径。
所有 template tasks 可以引用roles/x/templates/ 中的文件，不需要指明文件的路径。
所有 include tasks 可以引用roles/x/tasks/ 中的文件，不需要指明文件的路径。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91205db6e57a3a4edbe7fa1462cf2535/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d1fa447edc4ab1eaf3e376ceb1c5257/" rel="bookmark">
			应用篇之DLL的静态调用和动态调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区别静态调用（static call）和动态调用（dynamic call）。
静态调用 静态调用，即 Load-time Dynamic Linking。正如我们常用的配置方式，同时需要头文件、LIB和DLL文件，缺一不可。
动态调用 动态调用，即Run-time Dynamic Linking是一种隐式的调用方式，即程序运行过程中装载DLL。该方式只需要DLL，不需要头文件和LIB）。然后获取指定函数名称的接口函数，然后再调用之。
具体做法如下：首先使用LoadLibrary函数获取DLL的句柄，如果LoadLibrary成功，则将返回的句柄传入GetProcAddress函数中，来获取DLL的需要调用的函数的地址。调用DLL函数后，程序将调用FreeLibrary函数以卸载DLL。
示例如下，DLL中包含的如下：
// MathLibrary.h - Contains declarations of math functions #pragma once #ifdef MATHLIBRARY_EXPORTS #define MATHLIBRARY_API __declspec(dllexport) #else #define MATHLIBRARY_API __declspec(dllimport) #endif // The Fibonacci recurrence relation describes a sequence F // where F(n) is { n = 0, a // { n = 1, b // { n &gt; 1, F(n-2) + F(n-1) // for some initial integral values a and b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d1fa447edc4ab1eaf3e376ceb1c5257/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15bbfcc690eff4921eca83f3afee2b17/" rel="bookmark">
			我的Java学习之路（第十六天）-----  Java实现杨辉三角
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很简单的东西，就没必要讲的多详细了 唯一要说的就是杨辉三角的规律 从第三行开始第二列元素为上一列元素对应位置与上一个元素的和；
即array[i][j] = array[i-1][j-1] + array[i-1][j];
package de1; public class Test { public static void main(String[] args) { //初始化 int[][] array = new int[10][]; for(int i=0;i&lt;array.length;i++) { array[i] = new int[i+1]; } //给二维数组首末元素赋值赋值 for(int i=0;i&lt;array.length;i++) { array[i][0] = 1; array[i][i] = 1; //给其他位置赋值 if(i&gt;=2) { for(int j = 1;j &lt; array[i].length - 1;j++) { array[i][j] = array[i-1][j-1] + array[i-1][j]; } } } //遍历 for(int i=0;i&lt;array.length;i++) { for(int j=0;j&lt;array[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15bbfcc690eff4921eca83f3afee2b17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/640f3af447363b02563808049ad9abdc/" rel="bookmark">
			在HTML中使用Vue.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在非前后端项目中做页面时, 现在时常是只由后端人员一手开发, 在html或ftl文件中写js和 jquery总是令后端开发者如鲠在喉, 此时若能引入vue或者angular将极大提升开发效率(一般来说都会允许引入, 但博主也见过比较执拗的项目经理不允许使用前端框架非要用jq的) 在html中使用vue，直接在head中引入vue.js:
//最好是把这个vue.min.js另存到本地,这样写代码的时候有提示 &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;测试vue&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.4.2/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; 在html中定义一个vue控制的作用域
&lt;body&gt; &lt;div id="vueController"&gt; {{msg}} &lt;input type="button" value="点我" @click="changeMsg"&gt; &lt;/div&gt; &lt;/body&gt; 整体代码：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;测试vue&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.4.2/vue.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="vueController"&gt; {{msg}}&lt;br&gt; &lt;!--这个输入框绑定msg的值--&gt; &lt;input type="text" v-model="msg"&gt;&lt;br&gt; &lt;!--绑定changeMsg方法到按钮上--&gt; &lt;input type="button" value="点我" @click="changeMsg"&gt; &lt;/div&gt; &lt;script&gt; var test = new Vue({ el: "#vueController", data: { msg: "" }, methods: { changeMsg: function () { var that = this; that.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/640f3af447363b02563808049ad9abdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c6882d982dc56e532f2fa03724c7a4/" rel="bookmark">
			数组逆序排列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述
编写一个程序，读入一组整数（不超过20个），并把它们保存在一个整型数组中。当用户输入0时，表示输入结束。然后程序将把这个数组中的值按逆序重新存放，并打印出来。要求：(1)只能定义一个数组；(2)在交换两个数组元素的值时，必须使用单独定义的一个函数swap。例如：假设用户输入了一组数据：7 19 -5 6 2 0，那么程序将会把前五个有效数据保存在一个数组中，即7 19 -5 6 2，然后把这个数组中的值按逆序重新存放，即变成了2 6 -5 19 7，然后把它们打印出来。
输入格式：输入只有一行，包括若干个整数，最后一个整数是0。
输出格式：输出只有一行，包括若干个整数，即逆序排列后的结果。
输入输出样例
样例输入
7 19 -5 6 2 0
样例输出
2 6 -5 19 7
代码：
#include&lt;iostream&gt; #include&lt;windows.h&gt; using namespace std; void swap( int *a,int *b) { int temp; temp=*a; *a=*b; *b=temp; } void sort(int arr[],int left,int right) { int i=left; int j=right; while(i&lt;j) { swap(arr[i],arr[j]); i++; j--; } } int main() { int arr[20],count=0; while(cin&gt;&gt;arr[count])//输入n个数，直到遇到0为止 { if(arr[count]==0) break; count++; } sort(arr,0,count-1); for(int i=0;i&lt;count;i++) { cout&lt;&lt;arr[i]; cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70c6882d982dc56e532f2fa03724c7a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c4113e1822089b392793787bb8677c/" rel="bookmark">
			深入理解JavaScript  深入理解JavaScript&#43;（美）罗彻麦尔著  pdf 电子书下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入理解JavaScript+（美）罗彻麦尔著 pdf: https://t00y.com/file/19242906-419878000
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ca58cc04d5b50c2a88f04cace4f434e/" rel="bookmark">
			docker 安装操作(Mac版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装docker(两种方式)
方式一:命令下载安装
brew cask install docker 方式二:网页直接下载
下载网址1：https://download.docker.com/mac/stable/Docker.dmg 下载网址2：https://download.docker.com/mac/edge/Docker.dmg 注意：下载安装时可能需Mac账户密码
安装成功后菜单栏会出现docker的图标，首次使用docker时，可能需要Mac账户密码，视情况而定。同时打开终端执行docker命令(下列命令仅用于测试docker是否安装成功，更多的命令可以参考菜鸟https://www.runoob.com/docker/docker-command-manual.html，docker命令大全):
1.docker --version(查看版本号) 2.docker images(列出本地镜像) 3.docker ps(列出容器) docker镜像加速(新版本的docker图形化工具与教程中不太一样)
操作如下图所示
"registry-mirrors": [ "https://registry.docker-cn.com" ], 添加完，点击“Apple&amp;Restart”按钮
在终端执行命令，显示如下图所示
docker info OK，完成安装！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2334481bed759eaa0d3219cbecf8033/" rel="bookmark">
			To Be Better ——《人生十二法则》观后感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己的问题 并且在2018年的9月之后，因为家里横遭变故，整个人就消极懈怠了，人生的无意义，自我存在的虚无感越发严重。不知道自己为了什么而活，只是想着还要肩负起照顾爸妈的责任，所以要活下去，要好好工作，要赚钱养家。又因为找工作过程中受到了挫折，并且自认为没有全力以赴，以及做出了错误的选择，又丧失了对自己的自信。甚至觉得自己什么都做不好，愈发这样想就越发消极，于是越来越懒于思考，浑身乏力，做什么事都提不起劲来。想着就算自己再努力，生活想折磨我的时候，随时都可以让我痛苦。于是我深陷痛苦中，无法自救。
川哥的出现让我开始享乐，战战兢兢又不能自拔，好像自己的懒惰和享受都理所应当，于是自己越发的懒惰了起来。但是他让我变得稍微乐观了起来，在这一方面来讲，他是我的救命稻草。享乐让人愉快，让人感受到生命的美好，同时也让人丧失了斗志。在享受和奋斗之间，我还不能做出很好的平衡。
但欣慰的是，我还能在享乐的同时抱有愧疚之情，这便是我的警钟，我不应该因为这份愧疚而感到痛苦，而是应该感恩，这应该是人类这么多年在杀机重重的环境中，因为生于忧患死于安乐的焦虑感，从而不至灭绝并发展至此不断进化、保留下来的。
这种因为自己的不作为，停滞不前，没有不断强化自己的焦虑感，是自然选择的结果。所以不要因为这份焦虑而感到痛苦，应该在感到焦虑的时候，就开始停下享受，准备前行。
我深知现在的自己内心极度矛盾，痛苦，不安。我急需重建自己的内心世界，我感受到了它的崩塌。于是我开始看《人生十二法则》这本书。书籍真的是人的精神食粮。我希望这本书能带我找到出口。
法则一，笔直站立，昂首挺胸 我理解的就是要自信。作者从龙虾讲起，胜利的龙虾会分泌更多的血清素，这种物质能让生物更自信、更有力量、从而获得更好的资源。我当然应该认识到自己的不足，但是不要让自己的不足阻碍自己前进，我要跨过它。我要战胜自己的懒惰、不自信、耽于享乐、直面痛苦，成为更好的自己，承担家庭的责任，为社会做贡献。为自己的人生赋予意义。要相信自己，也要相信他人。
法则二，待己如助人 作者问了一个问题，为什么我们能悉心照顾自己宠物，却不能很好的照顾自己，不按时睡觉，不按时吃饭，生病了熬一下就过去了。作者提出的是，因为我们从意识深处知道自己丑陋不堪的那一面，从而在没有好好照顾好自己的时候觉得是在惩罚自己。其实这一点我并没有理解。我们是因为觉得自己不好，所以选择惩罚自己，才对自己不好的吗？
但是我选择赞成作者说的，我们值得自己被好好对待，要想帮助别人那样帮助自己，要选择真正对自己真正有好处的事物，即使这些事物不一定是自己想要的或者令自己快乐的。这一点我深有同感，早些时候我就发现自己很能拒绝别人，却很难拒绝自己，自己想要吃东西，就吃，想要晚睡，就晚睡，想要睡懒觉，就睡懒觉，想要看视频，就看视频。
不知道是谁说的，真正的自由不是想干什么就干什么，而是想不干什么就不干什么。自律才自由。
不自由，真是太痛苦了，并且因为自己造成的不自由更加痛苦，因为你没办法因为逃离而摆脱它。因为没有办法逃离自己。
由两种方法让自己摆脱这种不自由，自杀，或者自律。
未完待续…
不是看完这本书，或者理解了每一个法则在讲什么就能拯救自己的。是要切身实践，并行程习惯，才能达到目的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/032890abce59e39b18fbf88ca16c838d/" rel="bookmark">
			lotus 32GB 扇区 v0.2.6 存储时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lotus 32GB 扇区 v0.2.6 存储时间 1，v0.2.6 存储时间2，16核32线程CPU 1，v0.2.6 存储时间 Empty Unsealed precommitted precommit Proving 用时40分钟 用时6小时33分钟 用时1小时 用时8小时23分钟 用时16小钟36分钟 Empty Unsealed precommitted precommit Proving 2，16核32线程CPU Empty Unsealed precommitted precommit Proving 用时21分钟 用时3小时42分钟 用时2分钟 用时3小时22分钟 用时7小钟28分钟 Empty Unsealed precommitted precommit Proving 32GB 扇区，miner和node Empty Unsealed precommitted precommit Proving 用时22分钟 用时4小时 用时2分钟 用时3小时24分钟 用时7小钟51分钟 Empty Unsealed precommitted precommit Proving miner node 用时22分钟,Unsealed 用时5分钟6秒,Fetch staging 32GB 107MB/s 5m6s 用时3小时,computation 用时1分钟41秒,Push sealed 32GB 321MB/s 1m41s 用时56分钟56秒,Push cache 320.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/032890abce59e39b18fbf88ca16c838d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87760ab217a7e893ae2f79c9a952f131/" rel="bookmark">
			ROS错误笔记（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题1：rviz及gazebo中的模型呈现未装配状态问题2：运行launch文件报错moveit_rviz.launch有问题问题3：gazebo的反馈数据在rviz中有效，规划完Execute后gazebo中模型无反应，且终端报错，错误信息如下： 问题1：rviz及gazebo中的模型呈现未装配状态 rviz及gazebo中的模型处于散架状态、未装配，TF树处于断开状态，如下图所示：
原因：
可能1：框架配置有问题，关节状态控制器没配置可能2：xacro中有中文字符 博主属于第2种可能，xacro中为方便查看使用了中文注释，部分代码如下：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!-- 声明机器人名称为cobot_model，文件类型解析为xacro --&gt; &lt;robot name="cobot_ab7" xmlns:xacro="http://ros.org/wiki/xacro"&gt; 、、、、、、 &lt;color rgba="0.75294 0.75294 0.75294 0.2" /&gt; &lt;!-- rgba分别表示RGB值和alpha值，此处RGB值为01制，alpha值在0-1之间，1表示不透明，0表示完全透明 --&gt; &lt;/material&gt; 、、、、、、 &lt;!-- 工具link --&gt; &lt;link name="tool0"/&gt; 、、、、、、 &lt;/joint&gt; &lt;!-- 为joint添加传动装置,传动比为1 --&gt; &lt;xacro:macro name="transmission_block" params="joint_name"&gt; 、、、、、、 &lt;!-- 添加gazebo控制器插件 --&gt; &lt;gazebo&gt; 、、、、、、 &lt;/gazebo&gt; &lt;/robot&gt; 解决方案：删除xacro中的中文注释，或者将中文注释改为英文即可解决
问题2：运行launch文件报错moveit_rviz.launch有问题 RLException: unused args [config] for include of [/home/miracle/catkin_cobot_control/src/cobot_moveit_config/launch/moveit_rviz.launch] The traceback for the exception was written to the log file 原因分析：检查moveit_rviz.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87760ab217a7e893ae2f79c9a952f131/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb1e16da1e59e41beb74308daa41423a/" rel="bookmark">
			五子棋html游戏代码与算法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五子棋html游戏代码与算法介绍 运行图片目录路径五子棋.html五子棋算法进行下一个游戏的开发！注意事项 我会把html文件、css文件提供下载地址，文件夹路径也展示给大家。但是图片就没法一一放在博客里面了。 可以点击下载：https://download.csdn.net/download/qq_43592352/12367801
运行图片 目录路径 五子棋.html &lt;html&gt; &lt;head&gt; &lt;title&gt;五子棋-黑子电脑&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/style.css"/&gt; &lt;script src="jquery-3.3.1.js" type="text/javascript"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=container&gt; &lt;div id=chessboard&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; /**********************自定义便捷函数*******************************/ function getRandom(min,max){//获取在区间[min.max]内的int数 let s; s=parseInt(Math.random()*max+1); while(s&lt;min) { s=parseInt(Math.random()*max+1); } return s; } /**************************定义初始化数据*****************************************/ /***封装棋盘里面的点 类*****/ function Point(index,hang,lie){ this.idnex=index; this.hang=hang; this.lie=lie; this.state=0; this.pointX=-17+(this.lie-1)*52; this.pointY=-17+(14-this.hang+1)*52; } var pointsScore=new Array(226); var points=new Array(226); for(let i=1;i&lt;=225;i++) { points[i]=new Point(i,parseInt((i-1)/15+1),i-parseInt((i-1)/15)*15); pointsScore[i]=0; } console.log(points[15].pointX); /**************************系统设置*****************************************/ /* * 封装游戏容器居中 */ (() =&gt; { let screenHeight=parseInt($(window).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb1e16da1e59e41beb74308daa41423a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f23670feb8f7786446da601513f78114/" rel="bookmark">
			目标检测中的不平衡问题及解决方案论文汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自https://github.com/kemaloksuz/ObjectDetectionImbalance
A Repository of the Papers Addressing Imbalance Problems in Object Detection This repository provides an up-to-date the list of studies addressing imbalance problems in object detection. It follows the taxonomy provided in the following paper(please cite the paper if you benefit from this repository):
K. Oksuz, B. C. Cam, S. Kalkan, E. Akbas, “Imbalance Problems in Object Detection: A Review”, (under review), 2019.[preprint]
Table of Contents (Follows the taxonomy in the paper) Class Imbalance
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f23670feb8f7786446da601513f78114/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d5f0d60c8c504d20ee377359c637469/" rel="bookmark">
			矩阵对角化那些事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矩阵对角化那些事 所有矩阵都可以对角化吗?矩阵对角化矩阵对角化是什么?可对角化条件有趣的应用矩阵的幂 A n A^n An差分方程 u k + 1 = A u k u_{k+1} = Au_k uk+1​=Auk​斐波那契数列 (Fibonacci sequence) 指数矩阵 e A t e^{At} eAt 所有矩阵都可以对角化吗? 前几天某好友同学, 参加了某度算法岗的面试, 问了很多问题, 其中就有这么一个基础数学的问题: 所有矩阵都可以对角化吗?
实际上, 我立马就可以想出一个反例:
A = [ 1 1 0 1 ] . A = \begin{bmatrix} 1 &amp; 1 \\[3pt] 0 &amp; 1 \end{bmatrix}. A=[10​11​].
A 矩阵不可以对角化, 因为:
求特征值
显然特征值为 λ 1 = λ 2 = 1. \lambda_1 = \lambda_2 =1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d5f0d60c8c504d20ee377359c637469/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/381/">«</a>
	<span class="pagination__item pagination__item--current">382/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/383/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>