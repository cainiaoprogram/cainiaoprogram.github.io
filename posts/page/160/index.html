<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16268d30a9ee67a1bf545a0a0336587b/" rel="bookmark">
			c#与S7.net通讯实际工程应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用博图进行仿真通讯
（博图安装程序和破解程序可私信）
advance v3.0安装破解比较麻烦，可以自己尝试，也可以直接淘宝，这里就多叙述了，打开后如下图所示。
在博图数据块中建立数据如下图所示。
，基本数据类型也就是这样。博图中的内容不多赘述。有问题可以私信哈
接下来在visual studio中建立与PLC连接
1、首先在引用中右键👉选择管理NuGet程序包，安装如图程序包。
在浏览中搜索，然后安装，我这里已经安装好了。
2、接下来建立连接，代码如下
工程中需要用try {} catch{}将代码段包起来，以免程序宕机，这里catch中异常信息也可以用throw抛出求，写在方法里，不在最外层的try {} catch{}中都可以抛出去。
3、建立需要通讯的信号，这些信号通常要持续访问，所以单独建立一个类，用来保管信号。
4、信号读取 用while（true）对信号进行循环读取，这里需要单开一个线程，不能放在主线程中，不然卡线程。
这里要起一个名字，在调试的时候可以看到你线程是不是挂了，调试中查看线程方法如图所示。
同时可以监视你需要知道的变量
5、信号保存 通过数据库将需要的信息进行保存
连接字段如下图参数位置所示。
代码中sqlstr和sqlstr2为sql执行语句，具体根据自己的查询需要可进行调整。
6、效果展示 因项目要求只展示部分效果
这里信号为bool变量的反馈，true为绿灯，false为灰，实时反馈。
以上为工程实际项目最为核心的部分，其他内容就不做展示了，有问题欢迎私信讨论，有时间就回复。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c1820814ec91f40c1197a57815e99bd/" rel="bookmark">
			一起学习交换机的基本原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机的基本原理和配置 数据链路层的功能以太网帧格式交换机的工作原理交换机以太网接口的工作模式一、数据链路层功能二、以太网格式三、交换机工作原理四、交换机以太网的工作模式 数据链路层的功能 以太网帧格式 交换机的工作原理 交换机以太网接口的工作模式 一、数据链路层功能 前面咱们共同学习了OSI的七层结构以及TCP/IP的五层结构。数据链路层位于物理层与网络层中间，属于第二层。负责将从网络层包装的数据包转换为数据帧，并包装MAC地址。
数据链路层的功能有：
数据链路的建立、维护、拆除帧包装、帧传输、帧同步帧的差错恢复流量控制 二、以太网格式 以太网工作在数据链路层，数据链路层转换的数据帧也叫以太网帧。
以太网也经历了长时间的发展，从最开始的2.94兆实验性以太网发展成为十兆以太网应用，再到后面的十兆以太网标准到现在我们的百兆千兆以太网。
以太网MAC地址是用来识别一个以太网上的某个单独的设备或一组设备（设备指网卡）
MAC地址有48位二进制组成，通常分层六段，用十六进制表示。
例如
以太网的格式如下图
MAC头部有： 源MAC地址（6字节） 目的MAC地址（6字节） 上层数据类型（2字节，IP协议0800H/ARP协议0806H） 冗余校验码（4字节）
以太网格式是由以太网帧格式以前导码起始，32位冗余校验码结尾。
三、交换机工作原理 初始状态 交换机刚开机时MAC地址表没有任何记录MAC地址学习 源主机通过交换机发送数据帧给目标主机，交换机学习数据帧中的源MAC地址和对应的接口标识，并记录到MAC地址表中广播未知数据帧 如果交换机的MAC地址表没有目的地MAC地址所对应的接口记录，则会进行广播泛洪。接收方回应 只有拥有对应目的MAC地址的主机才会回复响应。
交换机实现单播通信 交换机会从目的主机回复的消息中学习到MAC地址和对应的接口标识，并记录到MAC地址表中，之后两台主机之间即可通过交换机MAC地址表的记录实现单播通信。 交换机是通过MAC地址表的记录实现数据帧的转发，交换机MAC地址表的默认老化时间为300s，300s内没有任何新信息会自动清除。
四、交换机以太网的工作模式 交换机以太网的工作模式分为以下三种：
单工半双工全双工 单工就是两个数据站之间只能演单一方向传输数据比如麦克风与扬声器之间。
半双工就是两个数据站之间可以双向传输数据，但是不能同时进行，比如我们所使用的对讲机。
全双工就是两个数据站之间可以双向且同时进行数据传输，比如我们认识必备的手机打电话。
以上就是本次所有共同学习的内容，不足之处希望伙伴们留言指证。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c1f49765f6a2f2bf7038f106dedfa04/" rel="bookmark">
			CVPR 2023 | GigaGAN：效果不差Stable Diffusion，速度远优！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文来源 机器之心 编辑：张倩、小舟
在文生图领域，扩散模型似乎已经一统天下，让曾经也风头无两的 GAN 显得有些过时。但两相比较，GAN 依然存在不可磨灭的优势。这使得一些研究者在这一方向上持续努力，并取得了非常实用的成果。相关论文已被 CVPR 2023 接收。
图像生成是当前 AIGC 领域最热门的方向之一。近期发布的图像生成模型如 DALL・E 2、Imagen、Stable Diffusion 等等，开创了图像生成的新时代，实现了前所未有的图像质量和模型灵活性水平。扩散模型也成为目前占据主导地位的范式。然而，扩散模型依赖于迭代推理，这是一把双刃剑，因为迭代方法可以实现具有简单目标的稳定训练，但推理过程需要高昂的计算成本。
在扩散模型之前，生成对抗网络（GAN）是图像生成模型中常用的基础架构。相比于扩散模型，GAN 通过单个前向传递生成图像，因此本质上是更高效的，但由于训练过程的不稳定性，扩展 GAN 需要仔细调整网络架构和训练因素。因此，GAN 擅长对单个或多个对象类进行建模，但扩展到复杂数据集（更不用说现实世界）则极具挑战性。因此，超大型模型、数据和计算资源现在都专用于扩散模型和自回归模型。
但作为一种高效的生成方法，许多研究者并没有完全放弃 GAN 方法。例如，最近英伟达提出了 StyleGAN-T 模型；港中文等用基于 GAN 的方法生成流畅视频，这些都是 CV 研究者在 GAN 上做的进一步尝试。
现在，在一篇 CVPR 2023 论文中，来自 POSTECH、卡耐基梅隆大学和 Adobe 研究院的研究者们联合探究了关于 GAN 的几个重要问题，包括：
GAN 能否继续扩大规模并从大量资源中受益，GAN 遇到瓶颈了吗？
是什么阻止了 GAN 的进一步扩展，我们能否克服这些障碍？
论文链接：https://arxiv.org/abs/2303.05511
项目链接：https://mingukkang.github.io/GigaGAN/
值得注意的是，CycleGAN 的主要作者、曾获 2018 年 ACM SIGGRAPH 最佳博士论文奖的朱俊彦是这篇 CVPR 论文的第二作者。
该研究首先使用 StyleGAN2 进行实验，并观察到简单地扩展主干网络会导致训练不稳定。基于此，研究者确定了几个关键问题，并提出了一种在增加模型容量的同时稳定训练的技术。
首先，该研究通过保留一组滤波器（filter）并采用特定于样本的线性组合来有效地扩展生成器的容量。该研究还采用了扩散上下文（diffusion context）中常用的几种技术，并证实它们为 GAN 带来了类似的好处。例如，将自注意力（仅图像）和交叉注意力（图像 - 文本）与卷积层交织在一起可以提高模型性能。
该研究还重新引入了多尺度训练，并提出一种新方案来改进图像 - 文本对齐和生成输出的低频细节。多尺度训练允许基于 GAN 的生成器更有效地使用低分辨率块中的参数，从而实现了更好的图像 - 文本对齐和图像质量。经过仔细调整后，该研究提出了十亿参数的新模型 GigaGAN，并在大型数据集（例如 LAION2B-en）上实现了稳定和可扩展的训练，实验结果如下图 1 所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c1f49765f6a2f2bf7038f106dedfa04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f5101a2d8bea63ec815c996e716a21b/" rel="bookmark">
			【打造家庭服务器系列01】无桌面版Ubuntu 22.04 连接wifi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 最近有一台笔记本一直放在哪没用了，就想着拿来做个服务器用吧。
如何安装Ubuntu系统，大家可以百度搜索一下很多。
主要分三步：
制作U盘启动盘（推荐使用rufus工具，轻量方便）设置BIOS引导 （开机按delete键或 F2 或 F12等）安装系统（直接安装，注意lvm选项，磁盘空间小建议关闭） 二、连接WiFi 2.1 使用network-manager 通过查询资料发现，可以通过安装network-manager 工具，使用nmtui 来连接WiFi。
nmtui 你将会看见如下图形，通过点击Edit a connection 来连接一个WiFi。
2.2 配置netplan 文件连接WiFi 上面说了第一种方式，但是如果一开始就没有安装network-manager 工具，然后笔记本还无法插网线，那咋办呢？
所以此时就需要通过配置netplan下的yaml文件来指定WiFi
1. 查看WiFi网卡名称
输入ip addr 查看网卡名称，lo 是回环地址接口，下面的wlps20就是我们WiFi网卡名称了。
# 输入 ip a 和 ip addr 效果是一样的。 root@rion-mi:~# ip addr 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: wlp2s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether f8:94:c2:eb:cf:58 brd ff:ff:ff:ff:ff:ff inet 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f5101a2d8bea63ec815c996e716a21b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/448c1d58c6e0021b8d0a3750e64671c4/" rel="bookmark">
			@JsonFormat与@DateTimeFormat注解的使用。JsonFormat 相差8小时问题。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@JsonFormat与@DateTimeFormat注解的使用 背景：从数据库获取时间传到前端进行展示的时候，我们有时候可能无法得到一个满意的时间格式的时间日期，在数据库中显示的是正确的时间格式，获取出来却变成了很丑的时间戳，@JsonFormat注解很好的解决了这个问题，我们通过使用@JsonFormat可以很好的解决：后台到前台时间格式保持一致的问题，其次，另一个问题是，我们在使用WEB服务的时，可能会需要用到，传入时间给后台，比如注册新用户需要填入出生日期等，这个时候前台传递给后台的时间格式同样是不一致的，而我们的与之对应的便有了另一个注解，@DataTimeFormat便很好的解决了这个问题，接下来记录一下具体的@JsonFormat与DateTimeFormat的使用过程。
声明：关于@JsonFormat的使用，一定要导入正确完整的包。
1.注解@JsonFormat 1.使用maven引入@JsonFormat所需要的jar包，我贴一下我这里的pom文件的依赖
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
&lt;!--JsonFormat--&gt;
&lt;dependency&gt;
&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
&lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
&lt;version&gt;2.8.8&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
&lt;version&gt;2.8.8&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;
&lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt;
&lt;version&gt;1.9.13&lt;/version&gt;
&lt;/dependency&gt;
2.在你需要查询出来的时间的数据库字段对应的实体类的属性上添加@JsonFormat
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
import java.util.Date;
import com.fasterxml.jackson.annotation.JsonFormat;
public class TestClass {
//设置时区为上海时区，时间格式自己据需求定。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/448c1d58c6e0021b8d0a3750e64671c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c33302168b6355ca35276f895c71231/" rel="bookmark">
			（简）Android 9.0 ~ 12 获取系统内存大小、存储空间大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两者单位均为 “G”，根据自己需要调整。 /** * 总内存 * * @param context 上下文 * @return {@link String} */ public static String totalMemory(Context context) { ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); ActivityManager.MemoryInfo mi = new ActivityManager.MemoryInfo(); am.getMemoryInfo(mi); return String.valueOf((int) Math.ceil((double) mi.totalMem / 1000 / 1000 / 1000)); } /** * 存储空间 * * @return {@link String} */ public static String totalStorage(Context context) { StorageStatsManager storageStatsManager = (StorageStatsManager)context.getSystemService(STORAGE_STATS_SERVICE); try { long totalBytes = storageStatsManager.getTotalBytes(StorageManager.UUID_DEFAULT); //总空间大小 return String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c33302168b6355ca35276f895c71231/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f03101ec87d2528e001d1717cdfa64fc/" rel="bookmark">
			时间格式化---计算时间差---java.text.ParseException: Unparseable date
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题：
FAQ（59）：java.text.ParseException: Unparseable date: "Wed Jan 24 16:28:14 CST 2018"
java.text.ParseException: Unparseable date: "Wed Jan 24 16:28:14 CST 2020" java.text.DateFormat.parse(Unknown Source) com.User.Controller.UserController.addUserSave(UserController.java:176) sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) java.lang.reflect.Method.invoke(Unknown Source) org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205) org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:133) org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97) org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827) org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738) org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:967) org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872) javax.servlet.http.HttpServlet.service(HttpServlet.java:648) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) javax.servlet.http.HttpServlet.service(HttpServlet.java:729) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197) org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 解决：
Date date = new Date(); Timestamp timestamp = new Timestamp(date.getTime()); 使用“时间格式刷”转化一下，再传给数据库和后台；
注：
没有格式化前是这样的：
格式化之后是这样的：
================================================
2.计算时间差：
public static String getDatePoor(Date endDate, Date nowDate) { long nd = 1000 * 24 * 60 * 60; long nh = 1000 * 60 * 60; long nm = 1000 * 60; // long ns = 1000; // 获得两个时间的毫秒时间差异 long diff = endDate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f03101ec87d2528e001d1717cdfa64fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6048688d42c3180a2624e785bdb96ded/" rel="bookmark">
			uni.createSelectorQuery().in(this).select(‘#scroll‘).boundingClientRect获取不到元素高度问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用这个方法获取元素高度为0
刚开始写法
onShow() { // let top = res.height - this.scrollViewHeight; this.$nextTick(() =&gt; { uni.createSelectorQuery().in(this).select('#scroll').boundingClientRect(( res) =&gt; { console.log(this.scrollViewHeight, "res", res) if (top &gt; 0) {} }).exec() }) }, 出现原因：
onLoad() { //页面初始化执行,用户页面获取参数},
onReady() { //页面初次渲染完毕执行},
解决方法：
在onReady()写入这些，再加上延时器
改后的效果
改后的代码
onReady() { this.$nextTick(() =&gt; { setTimeout(() =&gt; { let infos = uni .createSelectorQuery() .in(this) .select('.list'); infos .boundingClientRect(data =&gt; { console.log(data); this.scrollTop = data.height // this.setMargnTop(data.height); }) .exec(); }, 100); }); }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c975df0010e8b03c28d77d4fa63ebf1a/" rel="bookmark">
			机器学习：银行信贷预测（简单学习）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：本次案例使用的是pycharm编辑器
1、导入相关的包 # 导入相关的包 import pandas as pd import numpy as np # 导入预处理的库 import sklearn.preprocessing as pre # 训练集、测试集划分 from sklearn.model_selection import train_test_split # 逻辑回归 from sklearn.linear_model import LogisticRegression # 模型评估 from sklearn import metrics 2、读取数据 # 1、读取数据 data = pd.read_csv(open(r"风险识别.csv", encoding="gbk")) 首先，我们读取下数据，因为我们的数据名有中文，所以加上 open( )
此时如果打印查看数据 data ，在pycharm里会省略不少字段（显示不全）
所以加上以下字段才会显示全：
# 显示全部列 pd.set_option('display.max_columns', None) # 显示完整的列 pd.set_option('display.expand_frame_repr', False) # 设置不折叠数据 # 下面配置显示行 # pd.set_option('display.max_rows', None) # 显示完整的行 # pd.set_option('display.max_colwidth', 100) 上面我注释了一些，因为如果数据太多，也就是行太多那就要加载好久来显示，除非你加上data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c975df0010e8b03c28d77d4fa63ebf1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eb58b29b1bb225d19d19e36e7fb1ff0/" rel="bookmark">
			av_interleaved_write_frame -22
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个意思是dts没有线性增长，其实也就是pts没有线性增长，因为dts不需要我们去设置，只需要设置AVFrame中的pts，然后送进编码器，编码器会根据pts和编码时间设置dts。
报此错误时av_interleaved_write_frame(…)也会执行错误，报-22。
av_interleaved_write_frame(…)发送编码好的数据时，后一帧的pts一定是大于前一帧的pts的。每一帧会携带一个pts，代表此帧距第一帧的时间差数，单位是时间基，时间基数也由我们自定义指定。因此pts代表的是此帧的播放时间点，就像爱奇艺的视频进度条一样。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc24bc04eb9b172a127cefb59c779a06/" rel="bookmark">
			C&#43;&#43;模拟实现红黑树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
介绍----什么是红黑树
甲鱼的臀部----规定
分析思考
绘图解析+代码实现
节点部分
插入部分+分步解析
●父亲在祖父的左，叔叔在祖父的右：
●父亲在祖父的右，叔叔在祖父的左：
测试部分
整体代码
介绍----什么是红黑树 红黑树基于二叉搜索树，它和AVL树一样避免了二叉搜索树中极端场景单边树的情况，保证了检索的效率。红黑树允许最长路径是最短路径的二倍，相较于AVL树而言是近似于平衡的状态，但是减少了旋转的次数。
甲鱼的臀部----规定 ●每个节点都有颜色，不是红色就是黑色。
●根节点一定是黑色的。
●不能连续出现两个红色的节点。
●每条路径上的黑色节点数量相同。
●每个空节点都是黑色的。
●最多允许一条路径上的节点是另一条路径上节点的二倍。
分析思考 节点默认颜色应该选红色还是黑色，为什么？
答：插入红色可能会出现连续的红色节点，插入黑色会改变当前路径上的黑色节点数。选择默认插入节点为红色的原因是插入后的影响会小一些，当父节点是黑色时不用调整。相反的，黑色节点的插入一定会违反红黑树的规则。
满足上述特性为什么能保证最长路径不会超过最短路径的2倍？
答：这里要关注红黑树的两个特性，红色节点的孩子节点一定是黑色，每条路径的黑色节点树相同。也就说最长路径是红色节点和黑色交替，最短路径是全黑节点。这样一来，最长路径和最短路径间的差距就控制在了规定范围内。
绘图解析+代码实现 节点部分 三叉链结构分别指向左右孩子和父亲节点，数据方面存储键值对，除此之外还需要一个记录节点颜色的变量。
enum Color { RED, BLACK }; template&lt;class K,class V&gt; struct RBTreeNode { RBTreeNode* _left; RBTreeNode* _right; RBTreeNode* _parent; pair&lt;K, V&gt; _kv; Color _color; RBTreeNode(pair&lt;K, V&gt; kv, Color color = RED) :_left(nullptr) ,_right(nullptr) ,_parent(nullptr) ,_kv(kv) ,_color(color) { } }; 插入部分+分步解析 红黑树是二叉搜索树，插入节点的规则和二叉搜索的特点一样：
typedef RBTreeNode&lt;K,V&gt; Node; bool inster(const pair&lt;K, V&gt;&amp; kv) { if (_root == nullptr) { _root = new Node(kv); _root-&gt;_color = BLACK; return true; } Node* parent = nullptr; Node* cur = _root; while (cur) { if (cur-&gt;_kv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc24bc04eb9b172a127cefb59c779a06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2981b4b3602d2d271d205a9d39843f63/" rel="bookmark">
			我一个普通程序员，光靠GitHub打赏就年入70万，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个国外程序员名叫 Caleb Porzio在网上公开了自己用GitHub打赏年入70万的消息和具体做法。
Caleb Porzio 发推庆祝自己靠 GitHub 打赏（GitHub Sponsors）赚到了 10 万美元。
GitHub Sponsors是 GitHub 2019 年 5 月份推出的一个功能，允许开发者通过自己的项目获取报酬。
2018 年是Caleb Porzio做全职开发的最后一年，当时我的年收入大概是 9 万美元。
2019 年 1 月 11 日，我离开原来的公司开始「休假」，想要换种心情，做自己想做的一切。「休假」期间，受到这篇文章启发《Phoenix LiveView: Interactive, Real-Time Apps. No Need to Write JavaScript》（https://dockyard.com/blog/2018/12/12/phoenix-liveview-interactive-real-time-apps-no-need-to-write-javascript），发现自己也可以做出类似的成果
于是，他「决定开发一个类似 Laravel 的东西。我感觉这可能是个重大改变。」
现在看来，这确实改变了他的生活。然后，创建了一个非常流行的 JS 框架，叫做 AlpineJS，目前也是由我在管理和维护，做开源软件不能完全养活自己，所以他也接过一些小型的代码指导方面的需求，让 2019 全年的收入维持在一个稳定的状态。这张图是 2019 年通过自由职业方式获得的收入：
刚开始的这个收入，显然比作者上班时候是收入减少了 7 万美元，一路走来，有很多好心人联系作者，询问他们是否能够提供项目上的帮助。比如这种：
很长一段时间他没有更新 Patreon（一个众筹创作网站），那里会有一些人每个月给该网站五美元。如此也很好，但并不能环节作者的经济问题。
然后，2019 年 12 月 12 日，把项目直接托管在 GitHub 上即可。成为了 GitHub Sponsors 的一员。下面是作者的第一位打赏用户，
这么作者说：在开源社区里做开源软件，赚的钱比以往任何时候都多。有 535 位开发者每个月都打赏 14 美元。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2981b4b3602d2d271d205a9d39843f63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dc9aeb0652fea220ce622e0e29302af/" rel="bookmark">
			3步安装torch_geometric
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 想使用Pytorch Geometric实现GCN、GraphSAGE和GAT，首先模块直接报错。
安装步骤：
1 打开当前环境所在的命令行，输入python 查看python版本;输入import torch和torch__version__ #双下斜杠 查看torch版本;输入torch.version.cuda 查看cuda版本。
2 下载安装所需组件链接:
https://pytorch-geometric.com/whl/
cp后面的数字代表是python版本，将torch_cluster、torch_scatter、torch_sparse、torch_spline_conv都下下来，放到刚刚打开python的命令行文件位置。此处我的Python版本是3.8.5，cp选择38；打开python的命令行文件位置为 C:\Users\XXX\Python ,因此放到 C:\Users\XXX 。
3 pip install 四个文件名.whl
4 安装pyg
pip install torch_geometric 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7f7bded8f4d1cb3fafb95b41fe753c8/" rel="bookmark">
			推荐一本Vue3开发的书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Vue3.x+TypeScript实践指南》已经于2022-10月出版了
转眼回长沙快2年了，图书本在去年就已经完稿，因为疫情，一直耽搁了，直到这个月才出版！疫情之下，众生皆苦！感觉每天都是吃饭、睡觉、上班、做核酸！
图书介绍 为了紧跟技术潮流，该书聚焦于当下火的Vue3和TypeScript及其相关技术，这些知识是面试Vue方向前端岗位时必须掌握的内容。该书站在初学者的视角，将理论和实践相结合，通过循序渐进、由浅入深的方式来一一讲解Vue3的技术体系，让读者在学习的过程中不断提升前端开发水平。阅读该书仅需要有CSS、HTML、JS基础，即使你是一个Vue初学者，阅读该书也不会有任何困难。书中提供了丰富的示例来帮助读者将理论知识运用于实践，让读者学习起来不会感到枯燥乏味。相信该书能让读者在短时间内快速掌握TypeScript和Vue3的相关知识，并能够将所学知识运用到实际应用当中去。
如果你是Vue初学者，建议你按照章节顺序从头到尾阅读，如果你已经有了一定的基础，可以挑选自己感兴趣的章节进行阅读。
《Vue3.x TypeScript实践指南》适合vue3初学者及所有Web开发从业人员，也适合作为高等院校和培训学校计算机专业课程的教学参考书。
本书分为10章，第1～2章是讲解TypeScript基础和常用语法，第3章是对Vue3的基础知识点进行介绍，第4章是对Vue3中新增的Composition API进行详细的介绍，第5章是介绍Vue3中新增的组件和API，第6章是介绍vue-router和vuex的相关知识，第7章是介绍Vue3的常用UI框架，第8章是对Webpack5进行介绍，第9章是通过一个大屏展示的实战项目来将书中的内容应用到实践中，第10章是讲解Vue前端岗位的面试求职，而我们学习技术的最终目的就是为了就业。
其它图书
本书提供PPT课件！
购买地址 京东
当当
天猫
有需要的读者可以加我微信(jiekzou)购买，打5折，数量有限，先到先得，比在线商城更加优惠哦！
图书目录 简介
前言
目录
第 1 章
◄ TypeScript基础 ►
1.1 初识 TypeScript
1.1.1 TypeScript的介绍
1.1.2 TypeScript的特点
1.2 安装 TypeScript
1.2.1 安装node.js
1.2.2 npm
1.2.3 npm install --save 、--save-dev 、-D、-S、-g 的区别
1.2.4 yarn
1.2.5 全局安装 TypeScript
1.3 第一个 TypeScript 程序
1.3.1 ts和js的区别
1.3.2 编写TS程序
1.3.3 手动编译代码
1.3.4 VS Code自动编译
1.3.5 类型注解
1.3.6 接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7f7bded8f4d1cb3fafb95b41fe753c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de7a9d08ee73aa5a7946c330a7c9424f/" rel="bookmark">
			socket本地多进程通信基本使用方法和示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
socket是什么
socket基本原理框图
socket基本函数
1 socket() 函数
2 bind()函数
3 connect()函数
4 listen() 函数
5 accept() 函数
6 read() write() send() recv()函数
7 close()函数
8 字节序转换（hton）
示例代码
前言： 进程间通信（IPC，Interprocess communication）是一组编程接口，让程序员能够协调不同的进程，使之能在一个操作系统里同时运行，并相互传递、交换信息。这使得一个程序能够在同一时间里处理许多用户的要求。因为即使只有一个用户发出要求，也可能导致一个操作系统中多个进程的运行，进程之间必须互相通话。IPC接口就提供了这种可能性。每个IPC方法均有它自己的优点和局限性，一般，对于单个程序而言使用所有的IPC方法是不常见的。
进程间通信的8种方法：
1、无名管道通信
无名管道（ pipe ）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
2、高级管道通信
高级管道（popen）：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。
3、有名管道通信
有名管道 （named pipe） ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
4、消息队列通信
消息队列（ message queue ） ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
5、信号量通信
信号量（ semophore ） ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
6、信号
信号 （ sinal ） ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
7、共享内存通信
共享内存（ shared memory ） ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de7a9d08ee73aa5a7946c330a7c9424f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/924ffd829cc7eb0a0937cea011fa36af/" rel="bookmark">
			python 连接mysql及读取数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 连接mysql操作类 查了好长时间，从网上居然没找到python操作mysql的类，那就自己写一个吧，方便以后直接用
1.准备 使用pip 安装pymysql包
pip install pymysql python版本为python3
2.连接mysql进行增删改查的代码如下 class MysqlConn: def __init__(self, dbconfig): try: self.conn = pymysql.connect(host=dbconfig['host'], port=dbconfig['port'], user=dbconfig['user'], passwd=dbconfig['passwd'], db=dbconfig['db'], charset=dbconfig['charset']) self.cur = self.conn.cursor(pymysql.cursors.DictCursor) except pymysql.Error as e: print("Mysql Error %d: %s" % (e.args[0], e.args[1])) def query(self, sql): """ 执行一个sql 调用方式 query(sql) :param sql: 表名 :return: """ try: n = self.cur.execute(sql) return n except pymysql.Error as e: print("Mysql Error:%s\nSQL:%s" % (e, sql)) def query_row(self, sql): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/924ffd829cc7eb0a0937cea011fa36af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/927d4904e9a0d0204d8fcd00140fc6e3/" rel="bookmark">
			springboot自定义日志以及行号正确展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发springboot项目时，我们可能需要自定义日志实现。需要对slf4j的日志实现进行一次外层包装 这个很简单，按照org.slf4j.Logger方式定义一个类Logger类MyLogger。
让后实现MyLoggerImpl：
public class MyLoggerImpl implements CoreLogger { private static final String FQCN = CoreLoggerImpl.class.getName(); private Logger logger = null; private Class&lt;?&gt; clazz; private String className; public CoreLoggerImpl(Logger logger, Class&lt;?&gt; clazz){ this.logger = logger; this.clazz = clazz; } public CoreLoggerImpl(Logger logger, String clazz){ this.logger = logger; this.className = clazz; } public CoreLoggerImpl(String clazz){ this.logger = LoggerFactory.getLogger(clazz); this.className = clazz; } public CoreLoggerImpl(Class&lt;?&gt; clazz){ this.logger = LoggerFactory.getLogger(clazz); this.clazz = clazz; } @Override public String getName() { return logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/927d4904e9a0d0204d8fcd00140fc6e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c412e9de25facc52efb902f987db21/" rel="bookmark">
			@rollup/plugin-terser 用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		`@rollup/plugin-terser` 是一个用于压缩 JavaScript 代码的插件。使用该插件可以大幅减小代码体积，提高应用程序的性能。以下是 `@rollup/plugin-terser` 的用法步骤：
1. 安装 `@rollup/plugin-terser` 插件
使用以下命令安装 `@rollup/plugin-terser` 插件：
```bash
npm install --save-dev @rollup/plugin-terser
```
2. 在 `rollup.config.js` 文件中导入 `@rollup/plugin-terser`
在 `rollup.config.js` 文件中导入 `@rollup/plugin-terser`:
```js
import { terser } from 'rollup-plugin-terser';
```
3. 在 `plugins ` 中添加 `terser` 插件
在 `rollup.config.js` 文件中，在 `plugins` 数组中添加 `terser` 插件：
```js
export default {
// ...
plugins: [
// ...
terser()
]
};
```
4. 配置 `terser` 插件
您可以通过传递选项对象来配置 `terser` 插件。以下是一些可能的选项：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9c412e9de25facc52efb902f987db21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce748450e880853a307ed2dd62c7a6cd/" rel="bookmark">
			C/C&#43;&#43;编程：std::thread 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		构造线程 以一个最经典的hellow world作为开始
#include &lt;iostream&gt; int main() { std::cout &lt;&lt; "Hello World\n"; } 这是一个单线程，会将“Hello World”写进标准输出流。我们新启动一个线程来显示这个信息
函数传参作为参数 #include &lt;iostream&gt; #include &lt;thread&gt; void do_some_work() { std::cout&lt;&lt;"Hello Concurrent World\n"; } int main() { std::thread t(do_some_work); t.join(); } std::thread 在 &lt;thread&gt; 头文件中声明，因此使用 std::thread 时需要包含 &lt;thread&gt; 头文件。每个线程都必须具有一个入口函数，当线程执行完入口函数后,线程也会退出 main线程叫做主线程(每个线程都一定会有一个主线程，只有主线程的叫做单线程程序)，其入口就是main()函数其他线程叫做子线程(如果有子线程，那么就是多线程程序，它至少会有两个线程：主线程＋一个子线程。这里子线程是由std::thread创建的)，其入口函数是hello 当前 在程序启动之后，主线程也就启动了子线程在std::thread对象创建时启动。 成员函数转为参数 #include &lt;iostream&gt; #include &lt;thread&gt; class X { public: void do_work() { std::cout &lt;&lt; "Hello World!" &lt;&lt; std::endl; } }; int main(int argc, char const *argv[]) { X my_x; std::thread t(&amp;X::do_work, &amp;my_x); t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce748450e880853a307ed2dd62c7a6cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c3705dcc682baef6f9959439c3e03cd/" rel="bookmark">
			C语言实现十进制转换为十六进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 编写了C语言程序，实现了十进制数到十六进制数的转换
代码： #include &lt;stdio.h&gt; int main() { int a, i = 0; char s[200]; printf("请输入十进制数字：\n"); scanf("%d", &amp;a); while (a) { if (a % 16 &gt;= 10) s[i] = a % 16 + 55; else s[i] = a % 16 + 48; i++; a = a / 16; } printf("十进制转十六进制的数字是：\n"); for (i = i - 1; i &gt;= 0; i--) printf("%c", s[i]); return 0; } 效果图： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f573b336314d3defb76eee27edfc1695/" rel="bookmark">
			SSD训练自己的数据集（pytorch版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更新：open-mmlab更优秀、易操作的SSD实现 mmdetection（强烈推荐！） 以下原博客方法不再推荐！！! 环境：Win10+Anaconda3+Python3.8.8+Pytorch1.8.1ssd.pytorch代码下载地址：https://github.com/amdegroot/ssd.pytorchVGG16_reducedfc.pth预训练模型下载地址：https://s3.amazonaws.com/amdegroot-models/vgg16_reducedfc.pth修改版代码（Pytorch高于1.3.0需要）下载地址：https://github.com/sayakbanerjee1999/Single-Shot-Object-Detection-Updated 一、数据集准备（Pascal格式） 数据集存放位置为ssd.pytorch-master/data目录下，也可以通过修改voc0712.py文件中的VOC_ROOT = osp.join(HOME, "data/VOCdevkit/")来指定数据集存放路径。数据集文件夹格式如下：
VOCdevkit --VOC2020 ----Annotations ----ImageSets ----JPEGImages 部分数据集存在xml文件中没有标记数据的情况，也就是没有&lt;object&gt;标签数据，会出现IndexError: too many indices for array:...的数组索引出错，需要使用下面的代码检测出错的xml文件，之后可以手动修改或删除出错的xml文件。
import argparse import sys import cv2 import os import os.path as osp import numpy as np if sys.version_info[0] == 2: import xml.etree.cElementTree as ET else: import xml.etree.ElementTree as ET parser = argparse.ArgumentParser( description='Single Shot MultiBox Detector Training With Pytorch') train_set = parser.add_mutually_exclusive_group() parser.add_argument('--root', default='VOCdevkit/VOC2020' , help='Dataset root directory path') args = parser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f573b336314d3defb76eee27edfc1695/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e319c1343b85e2d54e2f2f05ea75f48c/" rel="bookmark">
			Python tkinter（四） 文本框（Text）组件的属性说明及示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python tkinter 文本框组件用于tkinter GUI里添加文本、图片、按钮。
使用语法
widget = Text( master, parameter=value, ... ) master：文本框控件的父容器parameter：文本框的参数value：参数对应的值 各参数之间以逗号分隔。
参数说明：
height设置文本框的高度，高度值每加1则加一行width设置文本框的宽度，宽度值每加1则加一个字节insert文本框插入数据，可以指定插入数据的位置delete删除文本框中的数据，可以通过数据位置，指定删除的数据get获取文本框中的数据，可以通过数据位置，指定获取的数据relief文本框样式，设置控件显示效果，可选的有：FLAT、SUNKEN、RAISED、GROOVE、RIDGE。bd设置文本框的边框大小，值越大边框越宽bg设置文本框默认背景色fg设置文本框默认前景色，即字体颜色font文本字体，文字字号，文字字形。字形有overstrike/italic/bold/underlinestate文本框状态选项，状态有DISABLED/NORMAL，DISABLED状态文本框无法输入，NORMAL状态可以正常输入highlightcolor设置文本框点击后的边框颜色highlightthickness设置文本框点击后的边框大小 说明：
文本框可以和按钮及图片结合，在文本框中插入按钮或图片。具体用法见代码示例：
代码示例：
# -*- coding:utf-8 -*- from tkinter import * ''' NW N NE W C E SW S SE ''' class textbox: def __init__(self): self.root = Tk() self.root.title("文本框") # 设置窗口标题 self.root.geometry("600x600") # 设置窗口大小 注意：是x 不是* '''文本框样式''' # 设置文本框高度为1，宽度为2，height=2表示一行的高度，width=2表示宽度为两个字节 self.height_width_label = Label(self.root, text='文本框高度和宽度：') self.height_width_text = Text(self.root, height=2, width=10) # 文本框插入数据 self.insert_label = Label(self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e319c1343b85e2d54e2f2f05ea75f48c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ee8db40c90223d9b61ace630f0d81a3/" rel="bookmark">
			git工作中常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git命令：
git config --global user.email “your@email.com”
git config --global user.name “yourname”
git clone -b 分支名 地址
测试分支：ns_ci_int_qa
git pull --rebase origin ns_ci_int_qa 同步远端分支代码
线上分支：dbg_add_pro_biz
1、从线上分支拉取新的分支开发
git add
git commit -m “YJ: xxx”
gitk
2、如果有多个 合并分支
git rebase -i HEAD~2 //数量是几个提交
git rebase --continue //继续合并
git rebase --rebort //取消合并
git rebase -i 提交记录1 提交记录2 前开后闭
执行这个命令后会跳转到 vim编辑器
pick：保留该commit（缩写:p）
reword：保留该commit，但我需要修改该commit的注释（缩写:r）
edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）
squash：将该commit和前一个commit合并（缩写:s）
fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）
exec：执行shell命令（缩写:x）
drop：我要丢弃该commit（缩写:d）
推送某一次的提交到远端
git push origin b6583f5ec95e34e6c135a6488a16c83cd48abe04:yijian20210831
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ee8db40c90223d9b61ace630f0d81a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df6a7829e16ce906b2710d247e22d8d6/" rel="bookmark">
			ios webview  引用wap页面，第一次访问正常 后台重新拉起后白页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iOS 的 WebView 在引入 WAP 页面后，后台重新拉起应用程序可能会出现页面白屏。以下是一些可能导致页面白屏的原因以及解决方法：
1. 缓存问题：在iOS设备上，WebView可以缓存页面，以便更快地加载页面。但是，当您重新拉起应用程序并重新访问页面时，缓存可能会导致页面出现问题。因此，您需要清除WebView的缓存以解决问题。可以使用`[[NSURLCache sharedURLCache] removeAllCachedResponses];`来清空缓存。
2. 网络连接问题：当应用程序在后台运行时，网络连接可能会断开。在这种情况下，您需要检查网络连接是否正常，并且应用程序是否能够访问所需的数据。
3. 后台任务问题：当应用程序在后台运行时，可能会执行一些后台任务。在某些情况下，这些后台任务可能会与应用程序重新启动时的状态发生冲突。因此，需要检查应用程序中的后台任务，并确保它们与应用程序重新启动时的状态兼容。
4. 线程问题：在iOS应用程序中，主线程是用于UI操作的。如果应用程序在后台运行时进行了一些操作，这可能会导致主线程被锁定，从而导致页面白屏等问题。因此，要在后台线程中执行任何长时间运行的任务。
总之，当您在 iOS 的 WebView 中引入一个 WAP 页面，并在重新拉起应用程序后出现页面白屏时，可能是多种问题的结果。通过检查相关的问题，您可以使应用程序重新开始运行，并确保它能够正确地显示页面。如果问题仍然存在，请考虑与应用程序的开发者或技术支持团队联系以寻求帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f71c1eca254a7eaabad527df663b5559/" rel="bookmark">
			Linux驱动开发——正点原子IMX6ULL核心板ADS1256驱动开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正点原子IMX6ULL核心板ADS1256驱动开发 一、修改设备树文件 查看正点原子IMX6ULL核心板和底板原理图，决定与 icm20608 共用 ecspi3。
找到 “imx6ull-alientek-emmc.dts” 和 “imx6ull-14x14-evk.dts”，在 “&amp;iomuxc”下修改 “pinctrl_ecspi3” 子节点，添加“pinctrl_ads1256”，子节点。
pinctrl_ecspi3: ecspi3grp { fsl,pins = &lt; MX6UL_PAD_UART2_RTS_B__ECSPI3_MISO 0x100b1 /* MISO */ MX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI 0x100b1 /* MOSI */ MX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK 0x100b1 /* CLK */ &gt;; }; pinctrl_ads1256: ads1256 { fsl,pins = &lt; MX6UL_PAD_UART2_TX_DATA__GPIO1_IO20 0x100b0 /* CS0, icm20608片选 */ MX6UL_PAD_UART3_RX_DATA__GPIO1_IO25	0x100b1 /* CS, ads1256片选 */ MX6UL_PAD_GPIO1_IO01__GPIO1_IO01	0x100b1	/* RESET, ads1256复位 */ MX6UL_PAD_JTAG_MOD__GPIO1_IO10	0x130b1	/* DRDY, ads1256就绪 */ &gt;; }; 将使用相同引脚的设备节点设置为“disabled”状态
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f71c1eca254a7eaabad527df663b5559/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba52b275e973b76646fd0ab8d8891aa0/" rel="bookmark">
			econgnition选择面向对象的样本，输出shp并在arcmap里打开，随机平均分为训练样本和测试样本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有不懂的可以看我发的前一篇~
打开软件，进行一个尺度为100的多尺度分割
进行一个类别的加
然后用它上面那个蓝色的三角尺工具。这个工具是直接指定类别的，不是用来选择样本的。在toolbar第二个选条那里选择你要的类别，比如我是vegetation，然后点击classify image object工具然后点击分割出来的图像对象，就可以指定它的类别。 选很多个！尽可能多。然后
这个东西就类似于arcgis的属性表。我们右键它，选几个属性输出来看看。因为它是面向对象的，但是基于栅格，所以有超级无敌多的features，不会自己显示出来。我们就要手动选择让他显示什么。
植被与234波段比较相关，我们打开看看
然后ok就会显示出来
点击表头就可以排序，上图是排完序的。
然后点击某一条记录就可以在主视图中高亮显示出来。这样可以让我们检查有没有选错的，比如某个波段的值很极端，就可以看看图像上是不是真的是这个类别。
另外这个方法选择的类别对象可以输出为shp，但是sample就不能导出shp。在工具栏，如下图，result指的就是分类结果，也就是咱们刚选的那个。
在feature下选择类名，没有的话新建一个。不然输出来不知道是什么类别的。
econgnition的分类是分层次的，我们这里只有一级类，所以选1
全部选好之后是这样的，记得不要把uclassify选进去，不然就哈哈哈哈所有的对象全输出了。左下角命名为sample然后export它，给他一个路径，就可以输出shp了。就可以愉快地在arcmap里打开了！
excel里复制一个1~282的列（282是样本个数）
粘贴到id里，单击第一格crl+v
stop
就平均且随机分为了1和0两部分。
关掉arcmap
删掉所有的类别。 这个东西可以把它变成样本，因此也可以用这个工具来选样本。如下图，选好以后不需要调参，直接excute。
ps:如果变成了样本，你就会发现旁边那个view sample就亮了。 接下来请严格按照顺序执行：
或者使用法二：
然后save，就保存了训练样本。然后delete all samples，同样的方法把type=0的变成验证样本
就可以把它又转换回samples。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce83db48bdea4f1a0e61c81503cfd464/" rel="bookmark">
			HTML5唤起高德地图APP示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、高德地图唤起链接
高德地图APP唤起链接(ios)：
iosamap://path?sourceApplication=&amp;slat=&amp;slon=&amp;sname=&amp;dlat=&amp;dlon=&amp;dname=&amp;dev=&amp;t= 高德地图APP唤起链接(android)：
amapuri://route/plan/?sourceApplication=&amp;slat=&amp;slon=&amp;sname=&amp;dlat=&amp;dlon=&amp;dname=&amp;dev=&amp;t= 高德地图WEB版链接：
https://uri.amap.com/navigation?from=&amp;to=&amp;mode=&amp;policy=&amp;src=&amp;callnative= 二、HTML5唤起高德地图APP示例
实现思路：先用高德地图APP链接尝试唤起APP，如果唤起失败，则打开高德地图WEB版代替，具体代码如下(安全密钥和key需替换成自己的)：
&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;HTML5唤起高德地图APP示例&lt;/title&gt; &lt;meta name="viewport" content="initial-scale=1.0, user-scalable=no"&gt; &lt;!-- 高德地图安全密钥，必须在JSAPI脚本加载之前进行设置，否则设置无效。 --&gt; &lt;script type="text/javascript"&gt; window._AMapSecurityConfig = { securityJsCode:'b*********************d', } &lt;/script&gt; &lt;script src="https://webapi.amap.com/maps?v=2.0&amp;key=f**********************25&amp;plugin=AMap.Geolocation" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="https://libs.baidu.com/jquery/1.9.0/jquery.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; $(document).ready(function(){ //根据手机系统获取scheme function getScheme(){ let agent = navigator.userAgent.toLowerCase(); if(agent.indexOf("iphone") != -1 || agent.indexOf("ipad") != -1){ return "iosamap://path"; }else{ return "amapuri://route/plan"; } } //唤起高德地图APP(注意url需要plugin参数) function openAMap(lng, lat, address) { let geolocation = new AMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce83db48bdea4f1a0e61c81503cfd464/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9d86b61db48dfee43c831ce5c36fb2e/" rel="bookmark">
			vue中使用jsp页面问题（vue与iframe相互传值问题）解决，将jsp页面移植到vue项目中的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 ​ 本篇文章主要记录个人在公司项目开发中所遇问题，主要内容：在vue项目开发过程中需要将原有的jsp页面以及其关联的js，css原封不动的移植到vue项目中。
​ 如果文章有歧义，请各位大佬指出，避免误导更多的人！！
正文 起因 ​ 在新的vue项目开发中，用到了老项目的重点技术；重头翻新为ant-design-vue页面工作量过大！那么就有以下问题：
vue项目怎么访问展示jsp页面？jsp页面中的js，css怎么引入？jsp页面初始化时所需的参数怎么获取，原有的Ajax请求怎么处理？ 在vue页面使用iframe内嵌jsp/html页面（解决提出的问题1 和 2） 将原有的jsp页面（ConfigurationEditing.html），js，css等相关的资源放到vue项目的静态资源文件夹下：
jsp页面所有引入的js，css等都不用改变：（但注意路径的变化，具体根据自己项目进行调整）
在src文件夹创建对映的ConfigurationEditing.vue，用于内嵌原jsp/html页面。然后在vue项目中配置对映的访问路由以便展示ConfigurationEditing.vue页面内容。
在ConfigurationEditing.vue中创建iframe组件内嵌jsp/html页面：
&lt;template&gt; &lt;div&gt; &lt;iframe name="iframeChild" id="configFrame" src="/jsp/ConfigurationEditing.jsp" width="100%" height="800px" frameborder="0" scrolling="no" ref="iframeDom" &gt;&lt;/iframe&gt; &lt;upload-material-modal ref="uploadModal" @konvaOk="konvaOk"&gt;&lt;/upload-material-modal&gt; &lt;/div&gt; &lt;/template&gt; vue与iframe中的内容如何相互传值（解决提出的问题3） 一.使用postMessage（obj, …）向iframe中传递值（进行通讯）
vue页面向iframe传值： methods: { konvaOk () { var param = { type: 'uploadOk' } this.sendMesForIframe(param) }, // 获取iframe实例, postMessage传值 sendMesForIframe (value) { const mapFrame = this.$refs['iframeDom'] const iframeWin = mapFrame.contentWindow iframeWin.postMessage(value, '*') } }, iframe中的jsp/html页面接收vue传的值： $(function () { // 监听vue页面传递过来的值 window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9d86b61db48dfee43c831ce5c36fb2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6f22182c0c670ebac81069ccfd618ea/" rel="bookmark">
			golang学习笔记 casbin授权库学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 权限控制管理模型ACLRBACABAC Casbin介绍Casbin概述Casbin工作原理请求策略匹配器效果 Casbin结合golang基本使用添加policy结合gorm适配器使用对policy经行增删改查 自定义匹配函数 权限控制管理模型 ACL ACL 基于用户的权限管理模型
基于用户的概念就是说直接对用户进行权限分配管理，好处是模型构建简单，只需要给用户授予或者取消对应权限即可。但是相对的，如果用户数量庞大的情况下，这套模型就很不实用。因为需要对每一位用户对应权限进行维护，这导致维护成本太高。
ACL模型表结构很简单，只需要用户user表和权限节点node以及user和node的多对多关系表user_node。同时，只需要维护user_node表中user和node关系即可。
ACL的适用于用户数量较小的管理系统中，例如：2112班有10位同学，张三拥有班长权限、李四拥有学委权限、王五拥有纪委权限，其它同学只拥有普通权限。
RBAC 一、RBAC是什么
1、RBAC模型概述
RBAC模型（Role-Based Access Control：基于角色的访问控制）模型是20世纪90年代研究出来的一种新模型，但其实在20世纪70年代的多用户计算时期，这种思想就已经被提出来，直到20世纪90年代中后期，RBAC才在研究团体中得到一些重视，并先后提出了许多类型的RBAC模型。其中以美国George Mason大学信息安全技术实验室（LIST）提出的RBAC96模型最具有代表，并得到了普遍的公认。
RBAC认为权限授权的过程可以抽象地概括为：Who是否可以对What进行How的访问操作，并对这个逻辑表达式进行判断是否为True的求解过程，也即是将权限问题转换为What、How的问题，Who、What、How构成了访问权限三元组；
2、RBAC的组成
在RBAC模型里面，有3个基础组成部分，分别是：用户、角色和权限。
RBAC通过定义角色的权限，并对用户授予某个角色从而来控制用户的权限，实现了用户和权限的逻辑分离（区别于ACL模型），极大地方便了权限的管理
：
User（用户）：每个用户都有唯一的UID识别，并被授予不同的角色
Role（角色）：不同角色具有不同的权限
Permission（权限）：访问权限
用户-角色映射：用户和角色之间的映射关系
角色-权限映射：角色和权限之间的映射
3、RBAC支持的安全原则
RBAC支持三个著名的安全原则：最小权限原则、责任分离原则和数据抽象原则
最小权限原则：RBAC可以将角色配置成其完成任务所需的最小权限集合
责任分离原则：可以通过调用相互独立互斥的角色来共同完成敏感的任务，例如要求一个计账员和财务管理员共同参与统一过账操作
数据抽象原则：可以通过权限的抽象来体现，例如财务操作用借款、存款等抽象权限，而不是使用典型的读、写、执行权限
4、RBAC的优缺点
（1）优点：
简化了用户和权限的关系
易扩展、易维护
（2）缺点：
RBAC模型没有提供操作顺序的控制机制，这一缺陷使得RBAC模型很难适应哪些对操作次序有严格要求的系统
5、RBAC的3种模型
（1）RBAC0
RBAC0，是最简单、最原始的实现方式，也是其他RBAC模型的基础。
在该模型中，用户和角色之间可以是多对多的关系，即一个用户在不同场景下是可以有不同的角色，例如：项目经理也可能是组长也可能是架构师。同时每个角色都至少有一个权限。这种模型下，用户和权限被分离独立开来，使得权限的授权认证更加灵活。
（2）RBAC1
基于RBAC0模型，引入了角色间的继承关系，即角色上有了上下级的区别。
角色间的继承关系可分为一般继承关系和受限继承关系。一般继承关系仅要求角色继承关系是一个绝对偏序关系，允许角色间的多继承。而受限继承关系则进一步要求角色继承关系是一个树结构，实现角色间的单继承。
这种模型适合于角色之间层次分明，可以给角色分组分层。
（3）RBAC2
RBAC2，基于RBAC0模型的基础上，进行了角色的访问控制。
RBAC2中的一个基本限制是互斥角色的限制，互斥角色是指各自权限可以互相制约的两个角色。对于这类角色一个用户在某一次活动中只能被分配其中的一个角色，不能同时获得两个角色的使用权。
该模型有以下几种约束：
互斥角色 ：同一用户只能分配到一组互斥角色集合中至多一个角色，支持责任分离的原则。互斥角色是指各自权限互相制约的两个角色。对于这类角色一个用户在某一次活动中只能被分配其中的一个角色，不能同时获得两个角色的使用权。常举的例子：在审计活动中，一个角色不能同时被指派给会计角色和审计员角色。
基数约束 ：一个角色被分配的用户数量受限；一个用户可拥有的角色数目受限；同样一个角色对应的访问权限数目也应受限，以控制高级权限在系统中的分配。例如公司的领导人有限的；
先决条件角色 ：可以分配角色给用户仅当该用户已经是另一角色的成员；对应的可以分配访问权限给角色，仅当该角色已经拥有另一种访问权限。指要想获得较高的权限，要首先拥有低一级的权限。就像我们生活中，国家主席是从副主席中选举的一样。
运行时互斥 ：例如，允许一个用户具有两个角色的成员资格，但在运行中不可同时激活这两个角色。
ABAC 基于用户属性进行访问权限判断，对于ABAC模型的学习，后续会再写一篇博客来进行记录。
Casbin介绍 Casbin概述 Casbin 是一个授权库，在我们希望特定用户访问特定的 对象 或实体的流程中可以使用 主题 访问类型，例如 动作 可以是 读取, 写入, 删除 或开发者设置的任何其他动作。 这是Casbin最广泛的使用，它叫做"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6f22182c0c670ebac81069ccfd618ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ebbf0e3bdae034ffe1429301e17440d/" rel="bookmark">
			微服务与分布式——SpringCloud
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提： 当项目逐渐变得庞大起来，简单的 spring 框架可能就不够用了，所以就需要用到分布式架构，我们这里简单介绍一下 springcloud 以及 springcloud 需要依赖的一些组件
目录： 1、分布式简介
2、Eureka 注册中心
3、Ribbon 负载均衡
4、Nacos 注册中心
5、Feign
6、gateway 网关
7、docker
8、RabbitMQ
9、SpringAMQP
1、分布式简介 问题一：什么是微服务
首先微服务≠SpringCloud，微服务是分布式架构的一种。所谓分布式架构就是把服务做拆分。而拆分的过程中会产生各种各样的问题需要去解决，springcloud只是解决了服务拆分时的服务治理问题，至于服务拆分后更为复杂的问题，并未给出解决方案，所以一个完整的微服务技术，包含的不仅仅是springcloud。我们下面看看微服务技术除了springcloud还包含哪些？
首先：原本所有的功能都写在一起，随后的版本越来越多，功能耦合的更加强，将来想升级维护就会很困难，所以一些大型的互联网技术都要进行服务的拆分。微服务在拆分的过程中会根据业务的功能模块，把大项目拆分成多个独立的项目，每个独立的项目独立进行开发和部署，每个独立的项目被称之为服务，每个大型的项目，一般包括数百上千的服务，最终形成服务集群
当一个请求来了，假如通过服务A调用服务B，服务B又调用服务C，这样当服务量比较多的时候，服务间的一些配置（比如服务的 ip ）靠人会很难记住，所以引入注册中心，有了注册中心，服务之间互相调用所需要的一些配置，直接去找注册中心就ok了，去注册中心去拉取对应的服务信息，每个服务都有自己的配置文件，如果那些服务需要去更改配置文件，难道需要我们人工去逐一更改么，这样就太麻烦了，所以就会引入配置中心，通过配置中心来统一管理整个集群中成千上百的配置管理，配置中心可以支持配置的热更新。当微服务运行起来后，用户就可以访问我们的微服务了，这个时候还需要一个服务网关，整个集群这么多服务，用户哪里知道要访问哪个，而且也不是随便什么人都可以访问服务，服务网关一方面是对用户身份进行校验，另一方面可以把用户的请求路由到具体的服务上，路由过程中可以做一些负载均衡的操作，此时服务接收到请求后，处理请求，该去访问数据库访问数据库（数据库一般采用集群的方式，由于用户量普遍大于数据库容量，所以也会采取缓存数据库（基于内存的数据库），为了应对高并发，还需要把缓存数据库做成分布式缓存（也是集群），服务先去请求缓存，缓存未命中再去请求数据库）（数据库充当的角色一般是做数据的写操作，和事务的一些操作，总之是对数据安全要求较高的一些数据存储），随后再把查询到的数据返回给用户就ok了。当我们的业务可能会涉及到一些海量数据的搜索，此时基于缓存也无法实现，届时就需要引入分布式搜索。还需要一些异步通信的消息队列组件，其实对于分布式的服务，业务往往会跨越多个服务，一个请求来了，服务A调服务B，服务B调服务C整个业务的链路会很长，此时的业务执行时长就是整个链路的执行时长之和，所以其实性能会有一定下降，所以通过消息队列，不是去调用B而是去通知B你去执行啥啥啥，此时就不需要服务A再去等服务B执行完毕，就可以提前结束了，减少了整个链路的等待时间（大大提高了吞吐能力）。当服务出现异常时，引入分布式服务日志来对其进行记录（统一的进行统计，存储分析）将来出现问题也比较好解决了，同时还引入系统监控链路追踪（实时监控整个链路每个服务结点内存CPU的占用等等情况，一旦出现任何问题，就可以快速定位到某一个方法）
此时我们的微服务集群就会非常庞大，靠人去部署时不现实的，需要引入自动化部署，此时通过 Jenkins 对项目进行自动化的编译，基于 docker 再去进行打包形成镜像，再去通过 k8s 或者 rancher 进行部署，此时微服务技术 + 后续的持续集成，这就是完整的微服务技术栈！！！！！
整体微服务技术栈大体分为五部分：
微服务治理：也是我们常说的 springcloud
分布式缓存：
异步通信：MQ等技术
分布式搜索技术：
持续集成的技术：
架构演变：
最早系统的架构一般采用的是单体架构（将业务的所有功能集中在一个项目中开发，打成一个包部署）优点：架构简单，不用去搞复杂的架构理念，打成一个包部署成本低，此架构更适合用于一些面向企业内部的一些简单项目，因为单体架构一个严重缺陷：耦合度高！大型互联网项目，功能非常多，当改动一个功能模块时，可能会导致其他功能模块的崩溃，所以代码不方便动，由此可知单体架构是不适合大型的互联网项目的，
大型业务一般会采取分布式架构，每个功能作为独立的项目去进行开发，称为一个服务，拆分功能模块后，耦合度降低了，但是随之也会引发一定的问题，比如订单模块需要依赖于商品信息模块，但是这明显是俩服务，咋互相调用？除非能够一个服务向另一个服务发送请求（远程调用，跨越机器，跨越服务）
为了解决这些问题，提出了很多解决方案，近几年最火的莫过于微服务技术，微服务就是一种经过良好架构设计的分布式架构方案，微服务架构特征
三、认识springcloud，springcloud可以被认为是国内外使用最广泛得微服务框架，spring cloud对以下组件做出了整合，无需复杂配置，更方便使用
四、服务拆分：单体架构按照功能模块进行拆分，变成多个服务就ok了，生产种功能模块可能会继续变多，又需要我们去拆
练习：
练习：
现在有两个服务，一个是获取用户信息的服务，一个是获取订单信息的服务，这两个服务是分开的，各自有各自的数据库，那么如何实现根据订单id查询订单详情的同时获取到用户信息呢，这就是远程调用
首先我们可以想到的是用户服务可不可以调用订单信息的数据库，显然不行，因为要减少重复开发并且各个服务之间的数据库是隔离的，无法互相查看
所以这里需要用户服务远程调用订单服务，这样的方法我们之前是没有学过的，所以我们看一下如何实现
其实就是订单模块模拟浏览器一样 发送 http 请求，请求用户信息对应的接口获取到用户信息，最后根据订单的信息一拼接就ok了，所以问题就变成了如何在 java 代码中发起 http 请求，能发请求就能远程调用了，此时需要 spring 提供的 RestTemplate 发送 http 请求
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ebbf0e3bdae034ffe1429301e17440d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cc379842b1b8d93cd973dec83aedcaa/" rel="bookmark">
			Frida和Xposed语法对照
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		载入一个新的类
//frida var tempClass = Java.use("java.tempClass"); //xposed final Class&lt;?&gt; tempClass = XposedHelpers.findClassIfExists("java.tempClass", lpparam.classLoader); 实例化一个类
//frida var tempClass = tempClass.$new() //frida 带参数 var tempClass = tempClass.$new(arg1,arg2) //xposed Object tempObject = XposedHelpers.newInstance(tempClass); //xposed带参数 Object tempObject = XposedHelpers.newInstance(tempClass,arg1,arg2); 设置类的属性
//frida //xposed 调用类的方法
我是sb,xp 我拦截不到动态类.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0d70052538b391fab8267917278f9bf/" rel="bookmark">
			gitlab问题记录：内存占用过高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司服务器安装docker，在docker中安装gitlab。
运行发现服务器运行内存占用一直是满的。
参考链接
问题所在：
配置文件种未对内存做出限制，官方默认配置是内存=内核数+1
解决方案：
先进docker，进去后找到以下目录文件
vi /etc/gitlab/gitlab.rb 打开后找到 unicorn['worker_processes'] = 2 把前面的#删掉，去掉注释 重启
搞定
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c0584d2b03b50be40bcdfefc4cd8378/" rel="bookmark">
			网络基础之IP地址分类及划分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
①A类地址
②B类地址
③C类地址
④D、E类地址
二、地址划分
①私网地址范围：
②特殊地址
③公网可用地址 一、IP地址分类
IP地址由4段8位2进制组成，根据网络号和主机号不同分为5类地址。
地址类型地址范围A类0.0.0.0~127.255.255.255B类128.0.0.0~191.255.255.255C类192.0.0.0~223.255.255.255D类不常见忽略E类不常见忽略 ①A类地址 A类地址范围为0.0.0.0~127.255.255.255，A类地址网络位固定为前8位。
网络位为2^7=128，网络位=2^可变网络位，A类地址首位不能变所以可变网络位为7位。
主机位为2^24=16777216，主机位=2^可变主机位，A类地址24位都可变所以可变主机位为24位
可用主机位为2^24-2=16777214，可用主机位=2^可变主机位-2，减2的原因是由于主机号全位0定义为网段地址，主机号全位0定义为广播地址不可随便使用。
②B类地址 B类地址范围为128.0.0.0~191.255.255.255，B类地址网络位固定前16位 网络位为2^14=16384，网络位=2^可变网络位，B类地址前2位不能变所以可变网络位为14位。
主机位为2^16=65536，主机位=2^可变主机位，B类地址16位都可变所以可变主机位为16位
可用主机位为2^16-2=65534，可用主机位=2^可变主机位-2，减2的原因是由于主机号全位0定义为网段地址，主机号全位0定义为广播地址不可随便使用。
③C类地址 C类地址范围为192.0.0.0~223.255.255.255，C类地址网络位固定前24位 网络位为2^21=2097152，网络位=2^可变网络位，C类地址前3位不能变所以可变网络位为21位。
主机位为2^8=256，主机位=2^可变主机位，C类地址8位都可变所以可变主机位为8位
可用主机位为2^8-2=254，可用主机位=2^可变主机位-2，减2的原因是由于主机号全位0定义为网段地址，主机号全位0定义为广播地址不可随便使用。
④D、E类地址 D、E类地址不常用，只要知晓D类地址用于组播，E类地址用于科学研究即可。
二、地址划分 地址划分按使用范围划分为2类，一类为公网地址，一类为私网地址。
公网地址：收取费用，全球可达且IPV4地址已用完。
私网地址：不收费，小范围内随便使用。
①私网地址范围： 私网地址范围10.0.0.0~10.255.255.255172.16.0.0~172.31.255.255192.168.0.0~192.168.255.255 ②特殊地址 ③公网可用地址 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d63de03f8c351f05d8a9de1351f2f318/" rel="bookmark">
			python123.io---双一流高校及所在省份统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双一流高校及所在省份统计 类型：Python 组合数据类型‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬
字典 d 中存储了我国 42 所双一流高校及所在省份的对应关系，请以这个列表为数据变量，完善 Python 代码，统计各省份学校的数量。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬
d = {"北京大学":"北京", "中国人民大学":"北京","清华大学":"北京",\ "北京航空航天大学":"北京","北京理工大学":"北京","中国农业大学":"北京",\ "北京师范大学":"北京","中央民族大学":"北京","南开大学":"天津",\ "天津大学":"天津","大连理工大学":"辽宁","吉林大学":"吉林",\ "哈尔滨工业大学":"黑龙江","复旦大学":"上海", "同济大学":"上海",\ "上海交通大学":"上海","华东师范大学":"上海", "南京大学":"江苏",\ "东南大学":"江苏","浙江大学":"浙江","中国科学技术大学":"安徽",\ "厦门大学":"福建","山东大学":"山东", "中国海洋大学":"山东",\ "武汉大学":"湖北","华中科技大学":"湖北", "中南大学":"湖南",\ "中山大学":"广东","华南理工大学":"广东", "四川大学":"四川",\ "电子科技大学":"四川","重庆大学":"重庆","西安交通大学":"陕西",\ "西北工业大学":"陕西","兰州大学":"甘肃", "国防科技大学":"湖南",\ "东北大学":"辽宁","郑州大学":"河南", "湖南大学":"湖南", "云南大学":"云南", \ "西北农林科技大学":"陕西", "新疆大学":"新疆"} 示例1：‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬
输入：无 输出：" 北京:8 天津:2 辽宁:2 吉林:1 " 注意：示例1 仅是输入输出样例，不是正确结果。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬
平均代码量 20 行
代码实现：
d = {"北京大学":"北京", "中国人民大学":"北京","清华大学":"北京",\
"北京航空航天大学":"北京","北京理工大学":"北京","中国农业大学":"北京",\
"北京师范大学":"北京","中央民族大学":"北京","南开大学":"天津",\
"天津大学":"天津","大连理工大学":"辽宁","吉林大学":"吉林",\
"哈尔滨工业大学":"黑龙江","复旦大学":"上海", "同济大学":"上海",\
"上海交通大学":"上海","华东师范大学":"上海", "南京大学":"江苏",\
"东南大学":"江苏","浙江大学":"浙江","中国科学技术大学":"安徽",\
"厦门大学":"福建","山东大学":"山东", "中国海洋大学":"山东",\
"武汉大学":"湖北","华中科技大学":"湖北", "中南大学":"湖南",\
"中山大学":"广东","华南理工大学":"广东", "四川大学":"四川",\
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d63de03f8c351f05d8a9de1351f2f318/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1efd70bc444c9c8b81b79c09ac7965e/" rel="bookmark">
			pyqt5（一） 窗口 简单示例创建窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 仅简单的展示如果展示出pyqt5的窗口，及使窗口运行的每条代码的意义
# -*- coding:utf-8 -*- import sys from PyQt5.QtWidgets import QMainWindow, QApplication class Root(QMainWindow): def __init__(self, parent=None): super(Root, self).__init__(parent) self.resize(600, 300) # 针对PyQt5的窗口进行尺寸调整，横向600个像素点，纵向300个像素点。 self.setWindowTitle("pyqt5标题") # 页面标题 if __name__ == '__main__': app = QApplication(sys.argv) # sys.argv是从命令行传入的参数列表。通过参数来选择启动脚本。 root = Root() # 实例化类 root.show() # 显示一个非模式对话框 sys.exit(app.exec_()) # 锁住程序直到用户关闭该对话框为止 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6486358f11aed75d329d51f9dce7f973/" rel="bookmark">
			Video.js组件在Vue项目中的综合使用详解（多个视频&#43;倍速播放）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Video.js —— 一款开源且功能丰富的web视频组件
Video.js在Vue项目中的综合使用详解（多个视频+倍速播放） 开发中，使用video标签自带的属性难以达到我们实际所需要的效果；例如视频的倍速播放功能，利用原生代码重写一个视频标签又太过于繁琐（PS:主要是懒）。在这里，向大家推荐一款很好用的组件video.js，这是一个开源的web视频组件(video.js官网)，其使用基于html5的video标签，同时支持HTML和Flash视频，下面向大家详细介绍一下在Vue项目中的使用，希望能帮助大家~
第一步：npm安装video.js 如果利用npm命令安装失败，可以利用淘宝镜像安装（不知道淘宝镜像的安装及使用，可自行百度，参考文章很多），具体安装命令为cnmp install video.js，如果一次不行，多试几次（PS: 安装这些东西有时候真的看人品啊啊），我当时安装时第一次报错，第二次成功了。
第二步：在main.js中引入video.js 将video.js注册到原型上
import Video from 'video.js' import 'video.js/dist/video-js.css' Vue.prototype.$video = Video 第三步：在页面中的具体使用 这边向大家分享有多个视频标签，利用video.js实现倍速播放功能。
首先先上一张效果图
在data中声明ids: [] 和 myPlayer: []变量，在这里不做过多展示。
首先创建video标签
这里介绍一下动态创建video标签的方式，稍微会麻烦一点，如果是非动态创建的video标签会更简单（由于涉及到多个视频，这里对每个video标签动态生成了唯一的id值，生成的id在初始化方法中将作为参数传入）
注意：创建的video标签不能够对其进行任何属性及样式操作，否则在调用getVideo()标签初始化时会有警告提示当前的video标签已经被初始化过了，你的操作就不会生效。
上代码！
// 插入的视频内容格式处理 updateVideo(result) { // 插入内容 const _videos = [] result.map(item =&gt; { _videos.push( `&lt;div class="ck-media__wrapper"&gt;&lt;video id="myVideo${Math.random() .toString(36) .substr(2) + Date.now()}" class="video-js"&gt;&lt;source src="${ item.attachUrl }" style=" width: 100%;height: 100%; type="video/mp4"&gt;&lt;/video&gt;&lt;/div&gt;` ) }) this.docInfo.content += _videos.join('') }, 然后创建getVideo()的方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6486358f11aed75d329d51f9dce7f973/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/997697aba3f0df55276563f8cb62d6f4/" rel="bookmark">
			odoo（搭建部署资源、教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地部署odoo16 odoo：https://www.odoo.com/documentation/14.0/zh_CN/administration/install/install.html#mac-os
https://alanhou.org/odoo14-cookbook/ pycharm：https://www.jetbrains.com/pycharm/download/#section=mac
安装其他依赖，这些核心工作帮助我们使用简单命令安装其它Odoo依赖。 brew
brew install freetype brew install jpeg brew install libpng brew install libtiff brew install xz brew install webp brew install node # 安装node npm
npm install -g cnpm --registry=https://registry.npm.taobao.org #如果npm太慢,使用cnpm安装包 cnpm install -g less less-plugin-clean-css #使用node安装依赖 sudo cnpm install -g rtlcss 安装PostgreSQL 检查brew：
brew doctor brew update 安装
brew install postgres 你也可以指定版本:
brew install postgres@11.17 启动 PostgreSQL 作为服务使用；
brew services start postgresql 停止 PostgreSQL
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/997697aba3f0df55276563f8cb62d6f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f12117f4090adfe974e2be3df7b01e63/" rel="bookmark">
			Linux创建并挂载NAS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 目标 在Linux服务器1上创建nas服务器，并指定可读写目录在Linux服务器2上挂载上述nas磁盘在Linux服务器2上设置开机自动挂载nas磁盘 2 搭建环境 两台Linux系统服务器，如下：
服务器1 IP为192.168.31.101
服务器2 IP为192.168.31.102
3 在服务器1上搭建NAS 3.1 下载安装软件 以下操作均需使用root权限
检查服务器上开启nfs服务的必要软件是否存在 rpm -qa|grep nfs rpm -qa|grep rpcbind 如果含有这两个软件：nfs-utils-1.3.0-0.33.el7.x86_64、libnfsidmap-0.25-15.el7.x86_64，则不用再安装，如果没有，则进行下一步
在服务器1安装nfs服务端软件 yum -y install nfs-utils rpcbind 3.2 设置开机自动启动服务 chkconfig nfs on chkconfig rpcbind on 3.3 启动服务 service rpcbind start service nfs start 3.4 创建并配置共享目录 创建用于共享的目录，sharefile（注意：共享目录不能创建于root用户目录下，否则客户端将因权限问题被拒绝执行挂载。） mkdir /sharefile 如果是root权限才能访问的目录，一定要修改权限，否则普通用户可能无法访问该共享目录
chown -R was:was /sharefile
把用于共享的目录配置到文件里面 vi /etc/exports 文件内容如下：
/sharefile 192.168.31.102(rw,sync,insecure) 3.5 重启生效 刷新配置立即生效（如果执行了这一步，就可以跳过下一步。否则，跳过这步，执行下一步。） exportfs -a 重启nfs服务器端 #重启nfs服务 service nfs restart #查看状态，确保状态是active service nfs status 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f12117f4090adfe974e2be3df7b01e63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3758e6e48fd5e8abcea733988834a17a/" rel="bookmark">
			java对接企业微信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java对接企业微信 一、注册企业微信 1.1 简介 企业微信与微信具有一样的体验，通过企业内部与外部客户的管理，构建出社群生态。企业微信提供丰富的api进行调用获取数据管理，也提供各种回调事件。
1.2 注册 登录官网，一键注册即可。链接: 企业微信
1.2 填写主要信息 企业微信中填写相关企业信息和负责人，然后创建。进入即可添加所需要的微信人员。
之后进行通讯录同步（此步骤为最重要一点），同步过后通讯录的人员根据调用接口接收消息。
1.3 创建应用 创建自己需要的应用，并根据提示创建应用（也可以不创建，用以前有的应用作为发送消息的主体也可以）
二、企业微信基础信息 创建完企业微信和自己所需要的应用后，需要记住几处重要的参数，方便后续调用api使用。
简单介绍几个参数：（需存入数据库）
1.企业id：当前企业微信的固定id；
2.agentid：当前自建应用id；
3.secret：应用秘钥，调用验证秘钥；
注：企业应用的可见范围需添加微信中的人员表。为后续调用查询、发送人员作限定选择。
三、消息接收url机制-回调 在java集成企业微信的同时，需要一个回调服务。现可以实现：
自定义丰富的服务行为、可以及时获取状态变化。
通过企业微信服务器向后端服务器发送各种需要消息。
这里只讲配置建立消息接收url机制。
附录上述两张图，其中包含设置可信ip（开发服务器的ip，为了服务器调用api）、配置接收服务器（通过回调机制+配置，验证url是否能接收到消息，并返回企业微信所需要的信息来校验）。加密解密见附录五。
回调配置
能通过发送来的密文（附录5中具体解密），返回给企业微信端需要的密文。即可通过校验，然后就可以填写认证ip进行开发调用接口。
简单介绍几个参数：（需存入数据库）
1.url：接收企业微信消息的接口
2.token：计算签名（可在配置中随机生成）
3.encoding_aes_key：加密key（加解密使用）
四、java对接企业微信（自建应用） 在上几个步骤中，我们已有需求的5个参数配置。根据这5个参数就可以进行与java对接。
4.1 对接前提（获取access_token） token是调用接口的基础。根据之前的保存参数即可获取。以下展示为项目所需接口调用，其他接口使用token基本都能调用。
4.2 手机号获取userid 4.3 发送应用消息 本文只展示文本方面，其他发送信息方面可参照api接口。api接口
五、附加-校验加密解密方式 5.1 方案说明 5.2 代码实例 /** * @Author sprem至尊 * @Date 2022/10/21 16:43 * @Version 1.0 */ package com.example.demo.controller; import com.example.demo.aes.WXBizJsonMsgCrypt; import com.example.demo.cache.TokenCache; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3758e6e48fd5e8abcea733988834a17a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/121e4aaef53730c4cf7b78a3f70d65e5/" rel="bookmark">
			小程序无需编程，体验IoT物联网平台-物模型开发——设备接入类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序码 1. 准备工作 1.1 注册阿里云账号 浏览器打开 ​​https://aliyun.com​​ ，开通阿里云账号，并通过支付宝实名认证。[](https://www.aliyun.com)
/&gt;
1.2 免费开通IoT物联网平台 在产品分类，找到物联网平台，进入产品官网，立即开通。​​https://aliyun.com/product/iot​​
2. 控制台操作步骤 2.1 创建产品 进入物联网平台的控制台，创建产品。自定义品类，数据传输JSON格式
2.2 产品功能定义 在产品详情页面的功能定义选项卡，创建产品物模型。
这里我们可以导入附录里的物模型。​​点击获取​​ 完整物模型JSON，导入前需要替换对应的产品productKey。
物模型导入成功如下：
2.3 注册设备 在产品下注册设备，获得身份三元组，如下图。
3. 微信小程序操作 3.1 设备上线 我们打开微信，扫描小程序码，进入小程序。输入设备身份三元组，点击设备上线。如下图，可以看到设备状态为在线，小程序log和设备详情页面 最后上线时间一致。
3.2 上报数据 在小程序界面，点击数据上报，我们看到模拟器上报了当前湿度，温度值。在控制台设备日志也可以查到本次消息详情，如下图。
同时，在设备详情的运行状态，也能实时看到设备上报的数据。
3.3 订阅主题和数据下行 在小程序界面，点击 订阅主题，然后我们再去控制台，设备详情页面的 Topic列表，找到对应的topic，点击发布消息。在发布消息页面，填写消息内容，点击确认。我们就会看到在小程序端展示推送消息，如下图。
同时在设备下行日志，也可以看到完整的下行消息。
3.4 物模型-服务调用 在控制台的在线调试界面，我们选中小程序设备，选中功能 开灯(switch)，输入参数{"status":"on"},点击发送命令。小程序的灯，就会变亮。如下图。
{"status":"on"} //status选项有：on ,off ,blue ,green 在设备详情的服务调用选项卡，也可以看到服务调用记录。如下图。
3.4 物模型-事件上报 我们在小程序界面点击告警，就会生成一条事件告警，上报当前的温度。如下图。
附录：物模型TSL { "schema": "https://iotx-tsl.oss-ap-southeast-1.aliyuncs.com/schema.json", "profile": { "productKey": "替换为你的productKey" }, "services": [ { "outputData": [], "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/121e4aaef53730c4cf7b78a3f70d65e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ed2afa04b2d31f3e27af7954d98f250/" rel="bookmark">
			前端大文件上传处理方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端大文件上传处理方案是一种用于上传大型文件的技术方案。它通常包括将大型文件分成小块，每块大小通常为几兆到几十兆，然后将这些小块逐个上传，最终在服务器上重新组合成原始文件。以下是一些常见的前端大文件上传处理方案：
分片上传：这是一种将大文件分成小块上传的方案。每个分片都由独立的请求上传，可以在上传过程中暂停和恢复。断点续传：这是一种基于分片上传的方案，它可以在上传过程中捕获上传的状态，以便在上传过程中发生错误或中断时恢复上传。这种方案通常需要在服务器端进行支持。使用 WebRTC 进行点对点文件传输：这是一种直接将文件上传到另一个设备或浏览器的方案。这种方案可以避免上传到服务器的延迟和带宽限制，但可能会涉及到安全风险。使用第三方服务：这种方案可以使用云存储服务（例如 Amazon S3、Google Cloud Storage、Microsoft Azure 等）或者其他第三方服务（例如 Dropzone.js、Uppy 等）来处理大文件上传。这种方案通常需要支付服务费用。 流式上传：将文件分成多个流，逐个上传，减小服务器压力和传输时间。
以上方案各有优缺点，需要根据具体场景和需求选择合适的方案，我在这里就只提供一个分片上传代码示例。
&lt;input type="file" id="file-input"&gt; &lt;button onclick="upload()"&gt;上传文件&lt;/button&gt; const upperLimitSize = 1024 * 1024 * 50 // 50兆 function upload() { const fileDom = document.querySelector('#file-input') // 首先第一步先获取文件对象 const file = fileDom.files[0] // 判断是否文件大小超过上限，如果没有就直接做上传操作 if (file.size &lt; upperLimitSize) { // 直接上传文件的操作 console.log('上传成功') return } // 文件切片相关的处理 let currentChunk = 0 // 当前片数 const chunkSize = 1024 * 1024 * 5// 每个切片的大小 const totalChunks = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ed2afa04b2d31f3e27af7954d98f250/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35cd96bdb728a39ed9b2c02563463bb7/" rel="bookmark">
			element ui 的滚动条,Element UI 文档中没有被提到的滚动条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		element ui 的滚动条,Element UI 文档中被提到的滚动条
Element UI 官网中有用到自定义的滚动条组件，但是发布的所有版本中都不曾提及，个中原因我们不得而知，不过我们还是可以拿过来引用到自己的项目中。
使用的时候，
放在 &lt;el-scrollbar&gt;&lt;/el-scrollbar&gt; 标签内即可
如：
&lt;el-scrollbar class="jjy-scroll"&gt; &lt;p&gt;1111111111111&lt;/p&gt; &lt;p&gt;2222222222222&lt;/p&gt; &lt;p&gt;3333333333333&lt;/p&gt; &lt;p&gt;1111111111111&lt;/p&gt; &lt;p&gt;2222222222222&lt;/p&gt; &lt;p&gt;3333333333333&lt;/p&gt; &lt;p&gt;1111111111111&lt;/p&gt; &lt;p&gt;2222222222222&lt;/p&gt; &lt;p&gt;3333333333333&lt;/p&gt; &lt;p&gt;1111111111111&lt;/p&gt; &lt;p&gt;2222222222222&lt;/p&gt; &lt;p&gt;3333333333333&lt;/p&gt; &lt;p&gt;1111111111111&lt;/p&gt; &lt;p&gt;2222222222222&lt;/p&gt; &lt;p&gt;3333333333333&lt;/p&gt; &lt;p&gt;1111111111111&lt;/p&gt; &lt;p&gt;2222222222222&lt;/p&gt; &lt;p&gt;3333333333333&lt;/p&gt; &lt;p&gt;1111111111111&lt;/p&gt; &lt;p&gt;2222222222222&lt;/p&gt; &lt;p&gt;3333333333333&lt;/p&gt; &lt;p&gt;1111111111111&lt;/p&gt; &lt;p&gt;2222222222222&lt;/p&gt; &lt;p&gt;3333333333333&lt;/p&gt; &lt;p&gt;1111111111111&lt;/p&gt; &lt;p&gt;2222222222222&lt;/p&gt; &lt;p&gt;3333333333333&lt;/p&gt; &lt;p&gt;1111111111111&lt;/p&gt; &lt;p&gt;2222222222222&lt;/p&gt; &lt;p&gt;3333333333333&lt;/p&gt; &lt;p&gt;1111111111111&lt;/p&gt; &lt;p&gt;2222222222222&lt;/p&gt; &lt;p&gt;3333333333333&lt;/p&gt; &lt;p&gt;1111111111111&lt;/p&gt; &lt;p&gt;2222222222222&lt;/p&gt; &lt;p&gt;3333333333333&lt;/p&gt; &lt;/el-scrollbar&gt; 发现底部出现横向滚动条，
问题大概在于 &lt;el-scrollbar&gt;&lt;/el-scrollbar&gt; 上的 height: 100% 与 margin-bottom 同时显示
直接用 overflow-x:hidden 隐藏：
.el-scrollbar__wrap { overflow-x: hidden; } PS：通过阅读源码，可以看到暴露的几个属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35cd96bdb728a39ed9b2c02563463bb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/add5ffbda9f552a58311ed5f85510c0c/" rel="bookmark">
			CentOS 7部署达梦数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装前准备 1.1DM数据库信息 CPU架构
操作系统
数据库版本
iso镜像
x86
CentOS 7
DM8开发版
dm8_20230104_x86_rh6_64.iso
数据库下载地址
https://www.dameng.com/list_103.html
操作系统下载地址
http://mirrors.163.com/centos/7.9.2009/isos/x86_64/
1.2新建dmdba用户 安装前必须创建dmdba用户，禁止使用root用户安装。
创建用户组
groupadd dminstall
创建用户
useradd -g dminstall -m -d /home/dmdba -s /bin/bash dmdba
设置用户密码
设置dmdba 用户的密码，用来登录使用，这里设置密码为111111。
注意：为了系统安全起见，用户应该设置比较复杂的密码。输入的密码不显示在终端，请正确输入并牢记。
passwd dmdba
New password:111111
Re-enter new password:111111
1.3调整 limits.conf 参数 linux系统中，操作系统会默认对程序使用资源进行限制，我们需取消相应的限制来避免达梦数据库的性能被影响。
使用root用户修改，具体操作如下：
使用vim或vi编辑器来编辑limits.conf文件，具体命令如下：
vim /etc/security/limits.conf
按i进入编辑模式，将下列4句语句添加至limits.conf文件。
dmdba hard nofile 65536
dmdba soft nofile 65536
dmdba hard stack 32768
dmdba soft stack 16384
添加完成后按esc退出编辑模式，输入:wq进行保存。
切换dmdba用户查看是否生效，具体命令如下：
su - dmdba #切换dmdba用户
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/add5ffbda9f552a58311ed5f85510c0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0681ed5e4a8c5a6d5389049d84e15c57/" rel="bookmark">
			登录ETCD容器，在容器内查询etcd信息并删除ETCD节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 登录ETCD容器，在容器内查询etcd信息并删除ETCD节点 kubectl get pods -n kube-system | grep etcd kubectl exec -it -n kube-system etcd-master01 sh #查询集群信息 etcdctl --endpoints 127.0.0.1:2379 --cacert /etc/kubernetes/pki/etcd/ca.crt --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key member list #or etcdctl --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/peer.crt --key=/etc/kubernetes/pki/etcd/peer.key member list kubectl exec -it -n kube-system etcd-master01 sh #删除想要删除的节点 etcdctl --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/peer.crt --key=/etc/kubernetes/pki/etcd/peer.key member remove ce2375f7f5372dd Member ce2375f7f5372dd removed from cluster ea8fc1908cb9f1ee 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcb35bf173273484a2bebe2593cd147c/" rel="bookmark">
			系统分析师考试论文框架结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是针对软考中系统分析师论文大致结构进行的总结说明。参考多篇范文及相关资料进行的说明。根据较为固定的框架针对特定的题目中的知识领域进行理论说明，并且同时需要将自己的项目与题目中的知识领域进行贴合，以达到论文说明应用题目中的相关技术来达到相关设计的目的
首先是摘要部分，摘要部分主要是简要说明要介绍的系统，以及在系统中负责的工作内容，简要说明该系统如何和题目中所要求的相关知识领域进行的贴合，最后要说明的是得到了良好的效果和相关客户的肯定等语言，目的是说明通过该知识领域的应用获得了良好的效果。【该部分一般写到300-320字左右，因为格子也是有限的】
然后是正文部分，以下针对每段的大致情况与相关字数进行总结式说明:
第一段: 较为宏观的说明市场上有对我们系统的相关需求，设计系统的起因以及目的是什么，去解决什么痛点问题
第二段: 微观说明应这种需求下，我们所设计和生产的系统，点题贴题目中需要使用到的技术。【也就是对系统整体情况进行细致的介绍，前两段大约写到400-450字】
第三段: 介绍关于题目中所述的知识点的一个描述，这里包括分类、概括、区别等。结尾要贴近自己的系统对上述内容的部分应用
第四段/第五段/第六段: 分别对上述结尾所述的系统中的应用，进行与系统关联的详细过程，并取得了怎样的效果【这个过程应用时，一定会遇到问题，要说明如何解决的。 这三段是主要描述我们的系统是如何与题目中所述的相关知识领域进行应用整合的】
第七段: 说明经过不懈努力，系统上线，转折说明上线后系统出现的一些问题
第八段: 进行大总结。运用以上的技术，对系统的效率提高，而且对于个人的成长收获【更宏观，对客户/对社会的积极作用】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14dd24abb3e0e9a6f4da9a5266e40164/" rel="bookmark">
			一小时搞定c#微信支付
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 2023年3月8日 修正 好了，正文开始，希望能给需要的人看到，我离秃瓢又近了一步。
本文主要阐述的是C#发起jsapi支付的爬坑经历。也可以是H5页面发起的支付。
一、下载demo
https://pay.weixin.qq.com/wiki/doc/api/download/WxPayAPI_CS.zip
PS:我下的是cs_sdk_v3.0.9：
.NET C# 【微信支付】API对应的SDK和调用示例 付款码支付、JSAPI支付、Native支付
二、搭建环境
1、复制demo的 bussiness和lib到自己项目,然后需要nuget一下Newtonsoft.Json
2、因为只用到了支付，所以只需要一个页面JsApiPayPage.aspx，复制到项目(我改名为ApiPay.aspx)
三、微信支付参数
1、参数主要在lib目录下的DemoConfig.cs里修改：
必须有的GetAppID()、GetMchID、GetKey、GetAppSecret、GetNotifyUrl、GetIp.类里都有参数说明我就不赘述了。
2、微信设置，主要有两个地方。
授权支付目录：商户平台--&gt;产品中心--&gt;开发配置 授权网页访问接口：开发者中心--&gt;网页授权获取用户信息--&gt;修改 这两个地方都只需要填写ApiPay.aspx的上级目录(外网可访问的)，比如：https://host/api/ApiPay.aspx,填写https://host/api/就行 ，不同的是网页授权要拷贝一个TXT
四、主要业务流程(看看了解一下就行)
如果上面的参数设置正确，恭喜你成功了一半。先讲下实现流程，在贴主要业务代码
1、前端H5支付跳到后端(支付金额是必须的)
2、获取openid:jsApiPay.GetOpenidAndAccessToken();这里是有个回调，先发送请求取得code,再验证网页权限去解析code 取得openid.
3、统一下单：jsApiPay.GetUnifiedOrderResult()，可以理解为让微信创建订单。
4、H5发起jsapi：jsApiPay.GetJsApiParameters(); 这里的prepay_id订单号要跟上一步返回的对应。不然会出错。
五、代码
其实代码上的改动只有ApiPay.aspx(因为就是复制过来的JsApiPayPage.aspx)
1、ApiPay.aspx前端：
&lt;%@ Page Language="C#" AutoEventWireup="true" CodeBehind="ApiPay.aspx.cs" Inherits="Web.api.ApiPay" %&gt; &lt;!DOCTYPE html&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head runat="server"&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt; &lt;script src="../js/jquery-1.9.1.min.js"&gt;&lt;/script&gt; &lt;script src="../js/jweixin-1.0.0.js"&gt;&lt;/script&gt; &lt;title&gt;微信支付&lt;/title&gt; &lt;/head&gt; &lt;script type="text/javascript"&gt; //调用微信JS api 支付 function jsApiCall() { WeixinJSBridge.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14dd24abb3e0e9a6f4da9a5266e40164/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8343c8a05629e2fa55402a069c2c8563/" rel="bookmark">
			实现Postman&#43;Newman&#43;Git&#43;Jenkins&#43;钉钉/邮件提醒接口自动化测试持续集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是介绍文字内容介绍，这边还有视频详细讲解，推荐看视频
B站讲的最详细的Python接口自动化测试实战教程全集（实战最新版）
团队成员协作编写接口用例-&gt;用例归档到git/svn-&gt;脚本集成jenkins,在环境更新后自动触发执行或定时执行。当然git/SVN不熟悉也可以在本地文件操作。
Windows系统Newman安装 1、下载Node.js进行安装，然后配置node的环境变量 2、借助npm工具，安装Newman npm install -g newman 3、运行Newman 通过Newman来运行某个postman脚本： newman run mycollection.json 用newman执行postman脚本的效果如下： Centos系统Newman安装 1、先下载安装nodejs （必须安装10.0以上的版本）
从http://nodejs.cn/download/下载linux系统压缩包 ,，解压，配置环境变量
tar xvJf ***.tar.xz echo "export PATH=\"\$PATH:/root/tools/node-v14.8.0-linux-x64/bin\"" \ &gt;&gt; ~/.bash_profile &amp;&amp; source ~/.bash_profile 2、安装Newman
npm install -g newman 以上通过命令安装如果问题的话 ，可以百度解决
命令行执行Postman脚本生成测试报告 1、命令行执行脚本的最基本的命令
newman run xxx.json newman run xxx.json -e xx环境变量.json -g xx全局变量.json 2、生成html格式的报告
先安装插件：npm install -g newman-reporter-html 再执行：newman run demo.postman_collection.json -r html 3、优化报告显示格式，生成美观一点的html格式报告
先安装插件：npm install -g newman-reporter-htmlextra 再执行：newman run demo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8343c8a05629e2fa55402a069c2c8563/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21af86debb977b2623887ff80b9120a5/" rel="bookmark">
			Elasticsearch基础概念和Python操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Elasticsearch 基础概念**1.1 基本概念****1.2 REST API**1.3 数据类型1.4 数据类型总结 二、Elasticsearch 基础操作2.1 对index操作2.2 对document操作 三、Elasticsearch 查询 DSL3.1 query 部分3.2 其他部分**3.2.1 排序字段**3.2.2 聚合字段3.2.3 size和scroll 四、批量操作数据4.1 批量插入/更新/删除数据4.2 更新插入数据upsert 五、文本分析5.1 测试分析器5.2 内置的分析器5.3 自定义分析器5.3.1 配置5.3.2 自定义分析器示例 5.4 指定分析器的方式 把事情简单化5.4.1 Elasticsearch 索引分析器5.4.2 Elasticsearch 搜索分析器 六、别名alias6.1 别名类型6.2 添加别名6.3 删除别名6.4 别名多个操作6.5 其他操作6.3 删除别名6.4 别名多个操作6.5 其他操作 一、Elasticsearch 基础概念 1.1 基本概念 Elasticsearch 是一个分布式文档存储。Elasticsearch 不是将信息存储为列式数据行，而是存储已序列化为 JSON 文档的复杂数据结构。当集群中有多个 Elasticsearch 节点时，存储的文档会分布在整个集群中，并且可以从任何节点立即访问。
存储文档后，它会在近乎实时的时间内被索引并完全可搜索——在1 秒内。Elasticsearch 使用一种称为倒排索引的数据结构，它支持非常快速的全文搜索。倒排索引列出了出现在任何文档中的每个唯一单词，并标识了每个单词出现的所有文档。
1.2 REST API Elasticsearch 提供了一个简单、连贯的 REST API，用于管理集群以及索引和搜索数据。
Elasticsearch REST API 支持结构化查询、全文查询和将两者结合的复杂查询。结构化查询类似于你可以在 SQL 中构造的查询类型。例如，你可以搜索索引中的gender和age字段并按字段employee作为索引，使用hire_date进行排序。全文查询查找与查询字符串匹配的所有文档，并按相关性排序返回它们——它们与你的搜索词的匹配程度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21af86debb977b2623887ff80b9120a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e77dcf8ac3cf4aa5edf050530fba3b/" rel="bookmark">
			SpringBoot 如何将配置文件挂到 jar 包外面？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、SpringBoot 指定配置文件路径：1）使用命令行参数：2）使用环境变量：3）使用外部配置文件： 二、SpringBoot 配置文件生效的优先级排序： 一、SpringBoot 指定配置文件路径： 在 SpringBoot 中，可以将配置文件放在 jar 包外面，这样可以方便地修改配置而不需要重新打包和部署。
下面是指定配置文件目录的 几 种方法： （按生效优先级从高到低排序）
1）使用命令行参数： 在启动应用程序时，可以使用 --spring.config.location 或 -Dspring.config.location 命令行参数来指定配置文件的路径，例如：（config 后面的 / 不可省略）
java -jar test.jar --spring.config.location=/opt/app/config/ 补充：FHS将/opt定义为 “为安装附加应用软件包而保留”。所以这里选择 /opt 文件夹来存放应用程序的配置文件。
2）使用环境变量： 可以设置 SPRING_CONFIG_LOCATION 环境变量来指定配置文件的路径，例如：
export SPRING_CONFIG_LOCATION=/opt/app/config/ java -jar test.jar 3）使用外部配置文件： 方法一： 在应用程序（jar包）启动命令执行目录下 创建一个名为 config 的文件夹，然后将配置文件放在该文件夹中。
方法二： 在应用程序（jar包）同级目录下 创建一个名为 config 的文件夹，然后将配置文件放在该文件夹中。在代码的配置文件 application.properties 或 application.yml 中添加以下行：
spring.config.name=application spring.config.location=classpath:/,file:./config/ 方法三： 在应用程序（jar包）同级目录下 直接放 properties 或 yml 配置文件。
方法四： 在应用程序（jar包）内部的 classpath 的 同级目录下，创建 config 文件夹，然后放 properties 或 yml 配置文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81e77dcf8ac3cf4aa5edf050530fba3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aecea91b903bffc9603f97e2fa2e2189/" rel="bookmark">
			MindSpore1.10.1安装步骤详解（Ubuntu20.04&#43;3080Ti&#43;CUDA11.1&#43;Python3.8）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MindSpore1.10.1安装步骤详解（Ubuntu20.04+3080Ti） 背景说明安装Ubuntu20.04+3080Ti驱动安装CUDA所需依赖下载并安装CUDA11.1（☆☆非常关键☆☆）下载并安装cuDNN安装Python3.8安装GCC安装MindSpore验证MindSpore安装成功 背景说明 我是一名高中信息技术教师，带来学生参加了第二届长三角人工智能挑战赛——主赛道算法擂台，很幸运获得了一等奖，比赛中使用到了华为旗下的MindSpore人工智能框架。
在AI全面普及的当下，为提升自己的能力水平，打算深入学习一下MindSpore相关的知识，第一步就是安装MindSpore了。
所使用的操作系统为Ubuntu20.04，显卡3080Ti，CUDA11.1，Python3.8，MindSpore1.10.1，手动安装。参照MindSpore官网的安装说明，有会一些坑，经常多次尝试，还是成功安装了，
在此把经验总结一下并分享给大家，供爱好者学习。若有不正之处，望予以指出，谢谢。
安装Ubuntu20.04+3080Ti驱动 Ubuntu20.04的安装这里就不详细说，大家可以参考网上的相关文章。
接下去安装3080Ti驱动，建议通过Ubuntu20.04自带的“软件和更新”功能去安装，如下图。
我安装的是525的版本，是能够安装的最新版了。安装成功之后，可以在终端窗口中输入“nvidia-smi”来验证驱动的是否成功和CUDA版本，如下图。
可以看到525的驱动安装后，CUDA的版本是12.0，其实CUDA是可以向下兼容的。官网上说CUDA11.1，准确地说是CUDA的最低版本为11.1。若已安装了高版本的CUDA，则需要安装CUAD11.1中除驱动之外的其他东西（后续会有详细说明）
安装CUDA所需依赖 参照MindSpore官网安装CUDA所需依赖，使用命令如下：
sudo apt-get install linux-headers-$(uname -r) gcc-7
安装截图如下：
下载并安装CUDA11.1（☆☆非常关键☆☆） 参照MindSpore官网给出的命令下载CUDA11.1：
wget https://developer.download.nvidia.com/compute/cuda/11.1.1/local_installers/cuda_11.1.1_455.32.00_linux.run
下载成功后，如图：
参照MindSpore官网给出的命令安装CUDA11.1：
sudo sh cuda_11.1.1_455.32.00_linux.run，如图：
点击“Continue”继续，如图：
输入“accept”并回车，如图：
去掉驱动的安装，安装其他选项，如图：
CUDA11.1安装成功，如图：
根据MindSpore官网给出的命令，添加环境变量，如图：
echo -e "export PATH=/usr/local/cuda-11.1/bin:\$PATH" &gt;&gt; ~/.bashrc echo -e "export LD_LIBRARY_PATH=/usr/local/cuda-11.1/lib64:\$LD_LIBRARY_PATH" &gt;&gt; ~/.bashrc source ~/.bashrc 下载并安装cuDNN 在cuDNN页面登录并下载对应的cuDNN安装包（需要NVIDIA账号），根据MindSpore官网的说明，下载cuDNN v8.0.x，如图：
官网上说下载的是一个tgz的包，但实际下载后是tar.xz的包，如图：
无所谓啦，反正都是压缩包，解压即可。为方便之后命令操作，把解压得到的文件夹重命名为cudnn，如图：
在文件夹cudnn里有一个include文件夹，一个lib文件夹，和一个LICENSE文件，如图：
根据MindSpore官网的说明，接下去就是复制文件了，具体命令如下：
最奇怪的是，文件夹明明是cudnn，怎么变成了cuda，也没有“lib64”文件夹啊，只有lib。因此修改了一下这两条命令，如下：
sudo cp cudnn/include/cudnn.h /usr/local/cuda-11.1/include sudo cp cudnn/lib/libcudnn* /usr/local/cuda-11.1/lib64 望MindSpore官网能修正一下。
再执行下一条命令
sudo chmod a+r /usr/local/cuda-11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aecea91b903bffc9603f97e2fa2e2189/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/159/">«</a>
	<span class="pagination__item pagination__item--current">160/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/161/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>