<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fb88377117ee6500ced04b6f711935b/" rel="bookmark">
			数据集处理（二）——Tiny-imagenet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、引言二、下载数据三、数据形式四、自定义数据加载 一、引言 最近在做一些大规模数据集（ImageNet-1k、ImageNet-21k）的实验之外，还做了一些小数据集的 ablation study。其中pytorch有自带的cifar10、cifar100数据加载，而Tiny ImageNet是没有的。于是简单在此记录一下这个数据集的处理。
Tiny ImageNet Challenge 是斯坦福 CS231N 的默认课程项目。 它的运行类似于 ImageNet 挑战赛 (ILSVRC)。 挑战的目标是让用户尽可能地解决图像分类问题。 用户将在测试集上的最终预测提交到此评估服务器，官方将维护班级排行榜。
Tiny Imagenet 有 200 个类。 每个类有 500 张训练图像、50 张验证图像和 50 张测试图像。官方已经发布了带有图像和注释的训练和验证集。 官方提供类标签和边界框作为注释； 但是，用户只需要预测每个图像的类别标签，而无需定位对象。 测试集无标签发布。
二、下载数据 点击官方下载链接，即可直接下载（http://cs231n.stanford.edu/tiny-imagenet-200.zip。下载完成后会得到大约236MB的压缩包。
三、数据形式 首先解压完文件夹会得到以下内容
$ tree data tiny-imagenet-200 ├── train │ ├── class1 │ │ ├── images │ │ │ ├── img1.JPEG │ │ │ ├── img2.JPEG │ │ │ └── ... │ │ └── class1_boxes.txt │ ├── class2 │ │ ├── images │ │ │ ├── img3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fb88377117ee6500ced04b6f711935b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63fd2bfe1214572c7de9ed50c243f8a7/" rel="bookmark">
			一起实践神经网络INT8量化系列教程（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开篇 老潘刚开始接触神经网络量化是2年前那会，用NCNN和TVM在树莓派上部署一个简单的SSD网络。那个时候使用的量化脚本是参考于TensorRT和NCNN的PTQ量化（训练后量化）模式，使用交叉熵的方式对模型进行量化，最终在树莓派3B+上部署一个简单的分类模型（识别剪刀石头布静态手势）。
这是那会的一篇文章，略显稚嫩哈哈：
一步一步解读神经网络编译器TVM(二)——利用TVM完成C++端的部署
转眼间过了这么久啦，神经网络量化应用已经完全实现大面积落地了、相比之前成熟多了！
我工作的时候虽然也简单接触过量化，但感觉还远远不够，趁着最近项目需要，重新再学习一下，也打算把重新学习的路线写成一篇系列文，分享给大家。
本篇系列文的主要内容计划从头开始梳理一遍量化的基础知识以及代码实践。因为老潘对TensorRT比较熟悉，会主要以TensorRT的量化方式进行描述以及讲解。不过TensorRT由于是闭源工具，内部的实现看不到，咱们也不能两眼一抹黑。所以也打算参考Pytorch、NCNN、TVM、TFLITE的量化op的现象方式学习和实践一下。
当然这只是学习计划，之后可能也会变动。对于量化我也是学习者，既然要用到这个技术，必须要先理解其内部原理。而且接触了挺长时间量化，感觉这里面学问还是不少。好记性不如烂笔头，写点东西记录下，也希望这系列文章在能够帮助大家的同时，抛砖引玉，一起讨论、共同进步。
当然在学习途中，也认识了很多在量化领域经验丰富的大佬（田子宸、JermmyXu等等），嗯，这样前进路上也就不孤单了。
OK，废话不多说开始吧。
Why量化 我们都知道，训练好的模型的权重一般来说都是FP32也就是单精度浮点型，在深度学习训练和推理的过程中，最常用的精度就是FP32。当然也会有FP64、FP16、BF16、TF32等更多的精度：
FP32 是单精度浮点数，用8bit 表示指数，23bit 表示小数；FP16半精度浮点数，用5bit 表示指数，10bit 表示小数；BF16是对FP32单精度浮点数截断数据，即用8bit 表示指数，7bit 表示小数。TF32 是一种截短的 Float32 数据格式，将 FP32 中 23 个尾数位截短为 10 bits，而指数位仍为 8 bits，总长度为 19 (=1 + 8 + 10) bits。
对于浮点数来说，指数位表示该精度可达的动态范围，而尾数位表示精度。之前老潘的一篇文章中提到，FP16的普遍精度是~5.96e−8 (6.10e−5) … 65504，而我们模型中的FP32权重有部分数值是1e-10级别。这样从FP32-&gt;FP16会导致部分精度丢失，从而模型的精度也会下降一些。
其实从FP32-&gt;FP16也是一种量化，只不过因为FP32-&gt;FP16几乎是无损的(CUDA中使用__float2half直接进行转换)，不需要calibrator去校正、更不需要retrain。
而且FP16的精度下降对于大部分任务影响不是很大，甚至有些任务会提升。NVIDIA对于FP16有专门的Tensor Cores可以进行矩阵运算，相比FP32来说吞吐量提升一倍。
实际点来说，量化就是将我们训练好的模型，不论是权重、还是计算op，都转换为低精度去计算。因为FP16的量化很简单，所以实际中我们谈论的量化更多的是INT8的量化，当然也有3-bit、4-bit的量化，不过目前来说比较常见比较实用的，也就是INT8量化了，之后老潘的重点也是INT8量化。
那么经过INT8量化后的模型：
模型容量变小了，这个很好理解，FP32的权重变成INT8，大小直接缩了4倍模型运行速度可以提升，实际卷积计算的op是INT8类型，在特定硬件下可以利用INT8的指令集去实现高吞吐，不论是GPU还是INTEL、ARM等平台都有INT8的指令集优化对于某些设备，使用INT8的模型耗电量更少，对于嵌入式侧端设备来说提升是巨大的 所以说，随着我们模型越来越大，需求越来越高，模型的量化自然是少不了的一项技术。
如果你担心INT8量化对于精度的影响，我们可以看下NVIDIA量化研究的一些结论:
出自《INTEGER QUANTIZATION FOR DEEP LEARNING INFERENCE: PRINCIPLES AND EMPIRICAL EVALUATION》，文末有下载链接。
量化现状 量化技术已经广泛应用于实际生产环境了，也有很多大厂开源了其量化方法。不过比较遗憾的是目前这些方法比较琐碎，没有一套比较成熟比较完善的量化方案，使用起来稍微有点难度。不过我们仍可以从这些框架中学习到很多。
Google 谷歌是比较早进行量化尝试的大厂了，感兴趣的可以看下Google的白皮书Quantizing deep convolutional networks for efficient inference: A whitepaper以及Quantization and Training of Neural Networks for Efficient Integer-Arithmetic-Only Inference。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63fd2bfe1214572c7de9ed50c243f8a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e41ce9b6bfa0d3a142e21c57a25ed3c/" rel="bookmark">
			mycat从0到成功进行分表操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装mysql，先检查集群中是否存在
mysql --version 或使用rpm -qa | grep mysql查看
如不存在，则参考mysql安装
启动mysql服务（systemctl start mysqld）时如果需要密码且始终提示不对如下图所示：
则可以使用 sudo systemctl restart mysqld.service启动mysql服务。
然后查看mysql服务是否真的启动了（systemctl status mysqld）
这样就启动了。
补充：修改mysql密码
如果是刚安装的，使用mysqladmin -u root password “这是密码”;创建密码
如果不是则连接到mysql后，set password for 用户名 @主机名（localhost）=password(…);
或使用mysqladmin -u root -p"旧密码“ password “这是新密码”；
或直接更新update的user表 （mysql库下的user表）,
update mysql.user set authentication_string=password('新密码') where user='用户名' and Host ='localhost'; 设置完之后需要将其刷新flush privileges
补充mysql：如果修改了mysql配置文件/etc/my.cnf,一定要重启mysql服务
2.使用mycat操作mysql时出现mysql的权限不足 ERROR 1105 (HY000): backend connect: java.lang.IllegalArgumentException: Invalid DataSource:0
在mysql中的mysql库（use mysql）下使用grant all privileges on *.* to root@"%" identified by "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e41ce9b6bfa0d3a142e21c57a25ed3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5ad4ed530345391c84965ce7f97cbae/" rel="bookmark">
			ACL访问控制列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1、ACL的概述
1.1、ACL的分类
1.2、ACL的作用
1.3、ACL在接口应用的方向
2、ACL的配置实例
前言 ACL是应用在路由器接口的指令列表。这些指令列表用来告诉路由器，哪些数据包可以接受，哪些数据包需要拒绝。
1、ACL的概述 1.1、ACL的分类 标准访问控制列表：基于源IP地址过滤数据包，列表号是2000-2999，列表需要放在靠近目
标的位置。
扩展访问控制列表：基于源IP地址、目的IP地址、指定协议、端口和标志来过滤数据包，
列表号是3000-3999，列表需要放在靠近源的位置。
命名访问控制列表：命名访问控制列表允许在标准和扩展访问控制列表中使用，名称代替表号。
1.2、ACL的作用 读取第三层、第四层包头信息
根据预先定义好的规则对包进行过滤
1.3、ACL在接口应用的方向 出:已经过路由器的处理，正离开路由器接口的数据包
出接口上调用ACL将不会影响本地路由器，将会影响数据传输过程中的下一台路由器，策略不会在本地生效。
入:已到达路由器接口的数据包，将被路由器处理
入接口上调用ACL将会影响本地路由器，策略会在本地生效。
注意：列表应用到接口方向与数据传输方向有关
2、ACL的配置实例 AR1:
[Huawei]sysname AR1 #重命名
[AR1]vl ba 10 20 #设置vlan
[AR1]int g0/0/0 #进入接口
[AR1-GigabitEthernet0/0/0]un sh 激活
[AR1-GigabitEthernet0/0/0]int g0/0/0.1
[AR1-GigabitEthernet0/0/0.1]ip add 192.168.10.1 24 #配置IP
[AR1-GigabitEthernet0/0/0.1]dot1q termination vid 10 #指定封装协议及vlan标签
[AR1-GigabitEthernet0/0/0.1]arp broadcast enable #开启arp广播
[AR1-GigabitEthernet0/0/0.1]int g0/0/0.2
[AR1-GigabitEthernet0/0/0.2]ip add 192.168.20.1 24
[AR1-GigabitEthernet0/0/0.2]dot1q termination vid 20
[AR1-GigabitEthernet0/0/0.2]arp broadcast enable [AR1-GigabitEthernet0/0/0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5ad4ed530345391c84965ce7f97cbae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ded31539c892146c9e2926a668050b/" rel="bookmark">
			RIP路由技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1、RIP路由技术
1.1、RIP路由技术的概述
1.2、RIP的工作原理
1.3、RIPv1与RIPv2的区别
2、RIP路由的配置实例
结语
前言 RIP协议是一种内部网关协议，用于自治系统内路由信息的传递。
1、RIP路由技术 1.1、RIP路由技术的概述 RIP: Routing Information Protocol ( 路由信息协议) 一种距离矢量路由协议，属于IGP协议RIP协议
适用于中小型网络，有RIPv1和RIPv2) 使用UDP进行路由信息的交互，端口号520。
RIP支持:水平分割、毒性逆转和周期性更新
1.2、RIP的工作原理 周期更新
邻居
广播更新
全路由表更新
1.3、RIPv1与RIPv2的区别 RIPv1RIPv2以广播的形式发送报文广播或组播（224.0.0.9）的形式发送报文有类路由协议无类路由协议不支持验证支持名文和MD5密文验证不支持VLSM和CIDR支持VLSM，路由聚合与CIDR 2、RIP路由的配置实例 AR1:
[Huawei]sysname AR1 #重命名
[AR1]int g0/0/0 #进入接口
[AR1-GigabitEthernet0/0/0]ip add 192.168.10.1 24 #配置IP
[AR1-GigabitEthernet0/0/0]un sh #激活
[AR1-GigabitEthernet0/0/0]int g0/0/1
[AR1-GigabitEthernet0/0/1]ip add 192.168.100.1 24
[AR1-GigabitEthernet0/0/1]un sh
[AR1-GigabitEthernet0/0/1] #退出
[AR1]rip 1 #创建RIP进程
[AR1-rip-1]net 192.168.10.0 #宣告直连的网络
[AR1-rip-1]net 192.168.100.0
[AR1-rip-1]q
[AR1]rip 1
AR2:
[Huawei]sysname AR2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4ded31539c892146c9e2926a668050b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3230072ac27d69674a840e82c2347617/" rel="bookmark">
			（文末福利）如果代码莫名其妙跑起来了，就不要去动它了……吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤫 关注公众号并回复「重构」🤫 获取《重构：改善既有代码
的设计》超详细思维导图
虽然代码还是可以跑，但是各种规则越来越复杂、核心继承体系越来越凌乱、系统的维护工作越来越重……
1999 年，Martin Fowler 作为技术顾问造访了一个项目，他建议项目经理好好整理这些乱糟糟的代码。然而，项目经理表示：🙏算了吧🙏
六个月后，这个项目宣告失败，因为代码太复杂难以调试，性能也达不到要求。
这件事给 Martin 留下很深的印象，随后，他写下了《重构：改善既有代码的设计》。
《重构》出版 22 年后，已成为软件开发领域不可替代的经典。这本书解释了重构的原理和最佳实践方式，并给出了修改代码的动机和具体案例，值得反复消化咀嚼。
这本书还凝聚了多位软件开发领域专家的宝贵经验：摩根大通架构师 Bill Opdyke 在第 13 章记述他将重构技术应用到商业开发过程中的一些问题；软件开发方法学泰斗 Kent Beck 和 Don Roberts 合写了第 14 章，展望重构技术的未来——自动化工具；Kent Beck 还写了最后一章，总结如何学习重构。
你将从这本书中获得：
理解什么是重构、为什么要重构、何时重构，理解
理解重构原则：一次一小步地修改代码并多次测试
实操演练重构的动机和方法，使既有代码更易理解、提升软件的可维护性
无论你是软件工程师还是产品经理，都需要翻一翻这本经典；而系统设计师和架构师则更有必要了解重构原理，根据需要在自己的项目中运用重构技术、优化系统性能。
💡 小编提醒，这本书中第一版的案例语言使用 Java，第二版的语言使用 JavaScript。总体而言，作者展示的重构手法在各种主流的面向对象语言中基本上都可以通用。
为何重构？
第二章中，作者详细介绍了重构的价值。重构不仅可以改进软件设计本身的缺陷、帮助找到 bug、提升开发速度，还可以使软件更容易被理解——这是因为，程序设计很大程度上是人与计算机、人与人的沟通。
Martin Fowler 曾提及，任何一个傻瓜都能写出计算机可以理解的代码，唯有能写出人类容易理解的代码的，才是优秀的程序员。
所谓程序设计，便是与计算机交谈。你编写代码告诉计算机做什么事情，它的响应则是按照你的指示行动。你得及时填补「想要它做什么」和「告诉它做什么」之间的缝隙。这种编程模式的核心就是「准确说出我想要的」。除了计算机之外，你的源码还有其他读者。计算机是否多花了几个小时来编译，又有什么关系呢？如果一个程序员花费一周时间来修改某段代码，那才要命呢——如果他理解了你的代码，这个修改原本只需一小时。……而很多时候，那个未来的程序员就是我自己。
《重构（第2版）》译者熊节也曾谈到，「编程其实是个社会活动」。
一方面，程序员要把自然语言说出来的需求翻译成机器能运行的机器语言；另一方面，翻译出来的结果（也就是代码）还要支撑团队（包括技术和非技术的团队）不断地在它基础上协作和交流。……编程的大挑战不是把代码写出来，而是要在代码的基础上建立有效的多方沟通。
那么，我们何时需要重构？书中第三章列举了一些「代码的坏气味」。「坏气味」指的是代码中某些不完美之处，开发人员可以通过这些细节上的征兆在代码中追捕到更大问题。小编不禁联想到了《Clean Code》中的「好气味」和「坏气味」。
一个重构案例
众所周知，重构有风险，挖坑需谨慎。如果重构方式不恰当，风险反而更大。
试想一下这样的情况：你挖掘自己的代码，很快就发现了一些可以修改的地方，于是你挖得更深。挖得愈深，可以修改的地方就愈多……最后，你给自己挖了一个大坑，再也爬不出去了。
为了避免掉进坑里，重构必须按照一定的原则和方法进行。
作者在第 5 - 12 章给出了一个重构列表，每一个重构案例都写明了重构适用的情景、动机、重构方法。让我们来看一个案例吧：
Extract Method（提炼函数）
你有一段代码可以被组织在一起并独立出来：
void printOwing(double amount) { printBanner(); //print details System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3230072ac27d69674a840e82c2347617/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d24b0cc9ed5f2cd1f13bfc93e8be1427/" rel="bookmark">
			使用idea连接数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入端口号，username，password连接成功
就可以在idea中进行数据处理，可以进行双击然后编辑数据，记得提交 ↑ 图标
编写SQL代码的地方
create table account( id int primary key auto_increment, `name` varchar(40), money float ); insert into account(id, name, money) value (1,'xiaoli',12.22) insert into account(id, name, money) value (2,'xiaowang',1234) insert into account(id, name, money) value (3,'xiaozhang',120.2) 编写代码后，便可以实现数据库的改变
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d884fbc7074e5561d54c5644f8a7d65a/" rel="bookmark">
			计算机网络「五」 运输层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本文为计算机网络系列第五章笔记，陆续会更新余下内容。文章参了：计算机网络微课堂、《王道考研计算机网络考研复习指导》、《计算机网络（ 第7版 ）》—— 谢希仁 。本文仅供学习使用，若有侵权联系删除。
系列文章：
计算机网络「一」计算机网络概述
计算机网络「二」物理层
计算机网络「三」 数据链路层
计算机网络「四」 网络层
一、运输层概述 之前所介绍的计算机网络体系结构中的物理层、数据链路层以及网络层，它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信。
但实际上在计算机网络中进行 通信的真正实体是位于通信两端主机中的进程。
而 如何为运行在不同主机上的应用进程提供直接的通信服务 是运输层的任务，运输层协议又称为 端到端 协议，所谓端到端也就是进程到进程。
从计算机网络体系结构的角度来看运输层
假设 AP1 与 AP4 之间进行基于网络的通信，AP2 与 AP3 之间进行基于网络的通信。在运输层采用不同端口对应不同进程，然后通过网络层及其下层来传输应用层报文。
接收方的运输层通过不同的端口，将收到的应用层报文交付给应用层中相应的应用进程。如图所示
可以简单地认为，运输层直接为应用进程间的逻辑通信提供服务。“ 逻辑通信 ” 的意思为运输层间的通信好像是沿水平方向传送数据，但事实上并没有一条水平上的物理连接。
运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看起来就好像 在两个运输层实体之间有一条端到端的逻辑通信信道 。
根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即 面向连接的TCP 和 无连接的UDP，这两种协议就是本章要讨论的主要内容。
二、端口号、复用与分用、套接字 我们知道，运行在计算机上的进程使用 进程标识符 PID 来标志。而因特网上的计算机并不是使用统一的操作系统，不同的操作系统（windows、Linux、Mac OS）又使用 不同格式的进程标识符 。
为了使运行不同操作系统的计算机的应用进程之间能够进行网络通信，就必须 使用统一的方法对 TCP/IP 体系的应用进程进行标识 。
TCP/IP 体系的运输层使用 端口号 来区分应用层的不同应用进程。
端口号
应用进程通过端口号进行标识。端口号只具有本地意义，即端口号只是为了 标识本计算机应用层中的各进程，在因特网中，不同计算机中的相同端口号是没有联系的 。端口号在运输层的作用相当于 IP 地址 在网络层的作用，或者是 MAC 地址 在数据链路层的作用，只不过 IP 地址和 MAC 地址标识的是主机，而端口标识的是主机中的应用进程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d884fbc7074e5561d54c5644f8a7d65a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24aaa91cef2d2cf3db518dc47b0c0e1c/" rel="bookmark">
			MySQL安全性机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、学习任务1：MySQL软件所提供的权限 在MySQL软件中存在许多系统数据库，其中一个名为mysql的数据库，在该数据库下存储的都是关于权限的表。其中最重要的表是mysql.user、mysql.db，本节将详细介绍这些涉及权限的系统表。
1.1 系统表mysql.user
在系统数据库mysql，存在一张非常重要的名为user的权限表，通过SQL语句DESC关键字查看表结构，可以发现该表拥有43个字段。这些字段大致可以分为4类，分别为用户字段、权限字段、安全字段和资源控制字段。
1.用户字段
系统表mysql.user中的用户字段包含3个字段，主要用来判断用户是否能够登录成功，各个字段的含义如下表所示。
当用户登录时，首先会到系统表mysql.user中判断用户字段，如果这3个字段能够同时匹配，则会被允许登录。当创建新用户时，实际上会设置用户字段中所包含的3个字段。当修改用户密码时，实际上会修改用户字段中的Password字段。
用户字段名
含义
Host
主机名
User
用户名
Password
密码
2.权限字段
系统表mysql.user中拥有一系列以“_priv”字符串结尾的字段，这些字段决定用户了权限。以“_priv”字符串结尾的字段含义如下表所示。
这些字段的值只有Y和N。Y表示该权限可以用到所有数据库上；N表示该权限不能用到所有数据库上；通常，可以使用GRANT语句给用户赋予一些权限，也可以通过Update语句更新user表的方式来设置权限；不过，修改user表之后，一定要执行一下FLUSH PRIVILEGES，否则可能会出现如下错误： Error (1133): Can’t find any matching row in the user table
表 权限字段
字段
说明
Select_priv
确定用户是否可以通过SELECT命令选择数据
Insert_priv
确定用户是否可以通过INSERT命令插入数据
Update_priv
确定用户是否可以通过UPDATE命令修改现有数据
Delete_priv
确定用户是否可以通过DELETE命令删除现有数据
Create_priv
确定用户是否可以创建新的数据库和表
Drop_priv
确定用户是否可以删除现有数据库和表
Reload_priv
确定用户是否可以执行刷新和重新加载MySQL所用各种内部缓存的特定命令，包括日志、权限、主机、查询和表
Shutdown_priv
确定用户是否可以关闭MySQL服务器。在将此权限提供给root账户之外的任何用户时，都应当非常谨慎
Process_priv
确定用户是否可以通过SHOW PROCESSLIST命令查看其他用户的进程
File_priv
确定用户是否可以执行SELECT INTO OUTFILE和LOAD DATA INFILE命令
Grant_priv
确定用户是否可以将已经授予给该用户自己的权限再授予其他用户
References_priv
目前只是某些未来功能的占位符；现在没有作用
Index_priv
确定用户是否可以创建和删除表索引
Alter_priv
确定用户是否可以重命名和修改表结构
Show_db_priv
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24aaa91cef2d2cf3db518dc47b0c0e1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cbe0dcb881aefba6fa9e253b7a7015d/" rel="bookmark">
			计算机网络实验-eNSP路由器配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络实验-eNSP路由器配置 文章目录 计算机网络实验-eNSP路由器配置1.实验图配置2.PC机ip地址、网关、子网掩码配置3.全选，开启设备设置ip地址 5.同理，对路由器AR2进行配置6.路由器静态设置检查是否ping通路由器动态配置 1.实验图配置 2.PC机ip地址、网关、子网掩码配置 PC1 PC2 用同一个网关
PC3 PC4 用同一个网关
3.全选，开启设备 设置ip地址 路由器配置
int g0/0/0 ip address 192.168.229.1 24 int g0/0/1 ip address 192.168.1.1 24 用PC1进行ping操作
可以ping通
5.同理，对路由器AR2进行配置 int g0/0/0 ip address 192.168.229.2 24 int g0/0/1 ip address 192.168.3.1 24 PC3能ping通
6.路由器静态设置 对AR1进行设置
ip route-static 192.168.3.0 24 192.168.229.2 disp ip routing-table 对AR2 进行设置
ip route-static 192.168.1.0 24 192.168.229.1 disp ip routing-table 检查是否ping通 可以ping通
路由器动态配置 AR1：
undo ip route-static 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cbe0dcb881aefba6fa9e253b7a7015d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f061f38a1096d8e60c35e5de4bb98968/" rel="bookmark">
			【leetcode刷题笔记】01.两数之和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目详情：链接地址：https://leetcode-cn.com/problems/two-sum
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1：
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：
输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：
输入：nums = [3,3], target = 6
输出：[0,1]
分析与解答：
第一反应是遍历数组，每次取nums[i]后，再去遍历数组，查找index不等于i且值为target-nums[i]的下标。这样导致的后果是算法复杂度为O(n^2),因为遍历了两遍数组。初次代码如下：
var twoSum = function(nums, target) { const result = []; for (let i = 0; i &lt; nums.length; i++) { const firstIndex = nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f061f38a1096d8e60c35e5de4bb98968/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/701445d31795187095b41b513e19050a/" rel="bookmark">
			【论文笔记】基于聚类特征深度LSTM的语音情感识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Clustering-Based Speech Emotion Recognition by Incorporating Learned Features and Deep BiLSTM IEEE Access - South Korea, Pakistan 关键词：语音情感识别、深度双向LSTM、关键片段、序列选择、CNN特征归一化、RBFN
摘要 传统SER主要注重手工特征和使用传统CNN模型来提取高阶特征，增加识别准确率和整个模型的复杂度。本文提出了新的框架：
采用基于RBFN的聚类方法选择一个关键序列，目的是：减少计算复杂度STFT得到频谱图，经过CNN模型提取显著特征，后对其进行归一化保证识别准确率，目的是：特征提取后进行处理保证更加容易提取时空信息归一化后传入Deep BiLSTM学习时序信息并预测最终情感标签 SER简介 SER背景传统方法用的是手工提取的特征2-D CNN本来是用在图像处理领域，现在也应用于SERCNN-LSTM提取空间-时间特征但是CNN的使用会增加计算复杂度和网络参数所以使用K-means聚类，采用RBF（为什么非要用RBF不用其他的？）作为相似度度量，从每个簇抽取一个片段后将抽取的片段经过STFT算法得到频谱图，随后放入CNN（Resnet模型的FC-1000层）CNN的输出通过均值方差正则化，并输入深度BiLSTM网络提取时序信息并通过softmax层输出预测结果本文的创新点： 采用CNN-BiLSTM框架捕捉时序信息，所用的CNN模型是第一次被应用在这个领域，采用ResNet101特征结合序列学习机制提出一个用RBFN作为相似度量的抽取和选择序列的方法，选择距离簇心最近的作为代表，能够减少处理时间均值方差归一化能够提升性能，这也是框架的主要贡献之一实验表明结果比较不错，适合识别实时情感。 SER调研 SER系统分为两个部分：特征选择和分类，特征提取有CNN或者高斯混合模型等等。CNN最近在特征提取兴起，有采用预训练模型做迁移学习提取特征的，LSTM-RNN用来学习时序信息，还有不需要手工特征输入的端到端的方法。
CNN-LSTM结合的方法用来捕捉高阶特征和时序信息，有文章采用预训练CNN和SVM结合做情感分类。
提出的SER方法 框架分为三个模块，第一个模块有两个部分：
第一个，将音频文件分成多个片段并找出连续片段只差，获得的差值通过一个阈值确保相似度并通过shot边界检测（这里好像是图像处理的相关内容，这里是怎么用的呢？）找到聚类所使用的K值。若两帧之差大于阈值，K值加一。每一簇都找到一个距离中心最近的关键片段，我们采用RBF作为聚类算法的相似度估计。
第二部分，用STFT画出所选择关键序列的频谱图，后采用预训练的Resnet101中的FC-1000层提取特征。具体的网络结构在表1中给出：
学习到的特征通过均值和标准差进行归一化，最后通过深度双向LSTM学习时序信息，获得序列信息，并预测最终情感分类。网络结构如下：
A. 预处理和序列选择 首先将语音分帧，窗长为500ms，每个片段的标签是整个语段的标签，后通过K均值聚类。采用RBF代替K-Means中的欧几里得距离矩阵，K值的选择并不是随机的，而是通过shot边界检测动态的估计相似性。（这里需要注意，每个文件的K值是不同的）
B. 基于RBF的相似度度量 RBF是计算片段之间相似性的非线性方法，人类大脑通过非线性过程识别和分辨模式。本文模型是基于RBFN的非线性模型，我们使用映射函数来找到两语音片段间的相似性，其中也用到归一化的概念。一维高斯模型是一个很好的选择，因为其可以平滑映射函数。
函数中心为z，宽度参数是 σ \sigma σ，这个函数用来度量x和中心z之间的相似程度，RBFN中有不同的RBF，用来进行非线性估计：
拓展的映射函数如下：
其有N个RBF，说明有多个中心z，为了减少网络计算量，这里每一个片段仅仅采用了一维的高斯RBF：
x表示语音信号片段，z表示每个片段的RBF中心， σ \sigma σ表示每个片段的RBF宽度。其中宽度是可变的，共有P个RBF，参数调整、非线性加权和样本方差估计如下：
如果特定语音信号片段更相关，标准差会很小，如果标准差很大意味着片段不想管，较小的 σ \sigma σ值对距离的变化更加敏感。
C. CNN特征提取和RNN 本文采用CNN提取语音片段特征，RNN提取时序特征，后采用预训练的CNN提取特征，提取的每个片段特征作为RNN的一个时间步，RNN最后一个时间步的输出作为情感分类的最终结果。训练大量复杂序列信息只用LSTM是不能正确识别的，本文采用多层深度Bi-LSTM进行序列识别，内部结构和记忆模块信息如图：
D. 双向LSTM 本文采用多层LSTM的概念，采用前向和后向结合的Bi-LSTM网络进行训练，其中20%数据作为验证集，从训练数据中分离，并且通过交叉验证计算错误率，优化器采用Adam，学习率为0.001。
实验设置和结果 实验数据集： IEMOCAP、Emo-DB、RAVDESS三个。IEMOCAP数据集包含10个人，有五个session，每个session是两两对话，每个语音片段长度约3~15s，共使用了4种情绪，采样率16KHz；Emo-DB有10人，5男5女，每个语音片段约2~3s，包含7种情绪，采样率16KHz；RAVDESS包含24人，12男12女，共有8种情绪，训练数据分布除了neutral数量相同，采样率48000Hz。这三个数据库在speaker independent的实验中均采用五折交叉验证，80%用于训练其余用来测试。
实验评估： 本文通过speaker independent和speaker dependent两种方式评估，将每一个语段按照时间t分成片段，有25%重叠部分（具体这个时间t应该取多少？）。基于RBF的相似度度量采用K均值聚类在每一簇选择关键片段（距离聚类中心最近的一个片段）。选择好关键片段后，通过Resnet101模型的FC-1000进行高阶特征提取，选择全局平均值和标准差来归一化提高整个模型的准确率。归一化的特征输入到BiLATM中，经过softmax层后，输出预测概率。系统使用MATLAB 2019b中的神经网络工具箱进行特征提取、模型训练和评估。数据被分为80%用于训练和20%用于测试。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/701445d31795187095b41b513e19050a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a5830596d4862e9317469eb0ef0b795/" rel="bookmark">
			系统安全及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统安全及应用 账号安全控制系统账号清理密码安全控制su命令切换用户 PAM认证的构成PAM安全用户PAM可插拔式认证模块PAM认证原理PAM安全认证流程使用sudo机制提升权限配置sudo授权查看sudo操作记录查询授权的sudo操作 统引导和登陆控制调整BIOS引导设置开关机安全控制GRUB限制简要操作具体操作终端登陆安全控制 系统弱口令检测Joth the Ripper ，简称JR安装JR工具检测弱口令账号密码文件的暴力破解具体步骤 端口扫描网络扫描：NMAPNMAP常用的选项和扫描类型查看本机开放的端口检测主机控制台命令 netstat 账号安全控制 系统账号清理 将非登录用户的shell设为不可登陆
usermod -s /sbin/nologin 用户名 ##禁止用户登录 usermod -s /bin/false 用户名 ###禁止用户登录 锁定长期不使用的账号
usermod -L 用户名 ##锁定用户账户 passwd -l 用户名 ##锁定用户账户 passwd -u 用户名 ##解锁用户账户 删除无用的账号
userdel [-r] 用户名 锁定账号文件
chattr +i /etc/passwd /etc/shadow ##锁定账号文件 lsattr /etc/passwd /etc/shadow ##查看账号文件 chattr -i /etc/passwd /etc/shadow ##解锁账号文件 密码安全控制 设置密码有效期
vi etc/login.defs (新建用户) chage -M 30 test (已有用户) 要求用户下次登陆时更改密码
chage -d 0 test 命令历史限制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a5830596d4862e9317469eb0ef0b795/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a43b6a0b7aa24fbbafd635b92ed530f9/" rel="bookmark">
			ppt编写方法和指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于程序员或者架构师来说，编写ppt很多人都有过这样的体验，宁愿写程序也不愿写ppt，程序带来的实现快感明显高于产出ppt。但我们要知道，一个软件是否能卖出去，ppt的好与不好，是起到非常重要的作用的。至少它是一个敲门砖，客户第一时间接触的肯定是售前的方案ppt，如果这一关都过不去，即使你的程序再优秀，设计再出众，也无人问津。所以无论公司还是个人，编写ppt的方法和技能是展现自我能力的一把利刃，特别是做售前或者方案的人，这就是一项重要且不可或缺的技能。
那么如何编写好的ppt呢，我们从两个方面来讲述，第一是制作方法和呈现，第二是内容设计。关于制作方法和呈现几个大的方面包括如下：
1、方法和原则： Magic Seven原则 | KISS原则 | 10/20/30原则 | 目标驱动 | 结构化思维(金字塔原理) | MECE(完全穷尽，相互独立) | 讲故事 | 头脑风暴……
2、静态呈现方法。
3、动态呈现方法。
4、字体及配色方法。
接下来讲一下ppt内容的设计思想和步骤，ppt的内容千差万别，我们如何形成标准的方法体系从无到有不管是拼凑也好、自行编写也罢，最后形成条理清晰、结构完整的完整ppt呢。
1、 围绕ppt的核心思想学习和收集：
比如我们写产品方案ppt，必须对产品本身的组成、技术体系架构、产品特性、竞品分析、市场分析、产品实施等各方面有一个全面的了解，了解的过程就是学习和资料收集的过程，通过各个途径收集资料，阅读并形成围绕ppt核心思想的自我的知识体系。
2、 资料整理归类并标注：
对于收集的资料有ppt、word文档、图片等等，我们需要进行整理，可以建一个excel表，对后续编写有参考价值的文字、图片、ppt单页等进行记录和标注，以被后续使用。
3、 ppt目录结构规划和评审：
接下来就是根据核心思想和阅读形成的知识体系，构建ppt的整体目录，对于重要性高的ppt文档，建议在动笔之前邀请几个同行进行评审，根据评审意见再修订目录结构，以免造成后续返工。
4、 内容引用和编写
有了以上的一些准备工作，我们就可以开始编写ppt了，编写过程可参考ppt制作和呈现的一些原则进行。对于需要引用的资料如果不全可在过程中随时补充和记录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c09022c570bcb2aea7f755ad2a5681b/" rel="bookmark">
			【猫图识别】【HTML】一张猫图，告诉你猫咪在哪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源地址：https://juejin.cn/post/7032670502858686495
一、前言 突发奇想，我能不能根据一张图片，就识别到图片是否有猫咪，并且这个地方是在哪里？
二、准备工作 旷视Face 和 小牛翻译 所提供的API、一张猫咪图片！
三、准备工作的流程 旷视Face 使用API流程 官方教程：场景与物体识别的API使用教程
注册并登录控制台
——》创建应用API Key（应用管理）——》获取API Key、API Secret
请求地址：
&lt;!-- 需要POST请求--&gt; https://api-cn.faceplusplus.com/imagepp/beta/detectsceneandobject?api_key=你旷视的API Key&amp;api_secret=你旷视的API Secret&amp;image_url=你的图片地址 小牛翻译 使用API流程 （ps：目的是翻译旷视返回的结果(英文) 进行翻译）
官方流程：注册流程、获取APIKEY流程、测试APIKEY流程
帐号注册并登录控制台——》按照流程获取流量——》拿到提供的apikey
请求地址：
http://api.niutrans.com/NiuTransServer/translation?to=翻译方向语言&amp;from=源方向语言&amp;src_text=翻译内容&amp;apikey=你的apikey 其他工作流程 自行找一张猫咪照片，也可使用笔者提供的猫咪照片地址：https://nanfangzhe.gitee.io/cat-picture/database/images/cat3.png.
四、代码与测试 核心代码 var niutransUrl = "http://api.niutrans.com/NiuTransServer/translation"; var faceUrl = "https://api-cn.faceplusplus.com/imagepp/beta/detectsceneandobject"; var param = { // 这里的param为参数---键值对方式 api_key:'HOTcabIupEcx19GrvVk_fpJpPmNeDAwz', // 需要改的地方1️⃣ api_secret:'MOvF_DapqoMhhMUxBuwYcfPtA4OY_kzG', // 需要改的地方2️⃣ image_url:'https://nanfangzhe.gitee.io/cat-picture/database/images/cat3.png' // 测试的图片地址 } $.ajaxSettings.async = true; $.post(faceUrl, param, function(data){ // console.log("这是请求成功的"); // console.log(data); // console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c09022c570bcb2aea7f755ad2a5681b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4331baef64b5db30b142e70d66a60dcd/" rel="bookmark">
			设计数据密集型应用 第六章：分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6. 分区 我们必须跳出电脑指令序列的窠臼。 叙述定义、描述元数据、梳理关系，而不是编写过程。
—— Grace Murray Hopper，未来的计算机及其管理（1962）
文章目录 6. 分区术语澄清 分区与复制键值数据的分区根据键的范围分区根据键的散列分区一致性哈希 负载倾斜与消除热点 分片与次级索引基于文档的二级索引进行分区基于关键词(Term)的二级索引进行分区 分区再平衡平衡策略反面教材：hash mod N固定数量的分区动态分区按节点比例分区 运维：手动还是自动平衡 请求路由执行并行查询 本章小结参考文献 在第5章中，我们讨论了复制——即数据在不同节点上的副本，对于非常大的数据集，或非常高的吞吐量，仅仅进行复制是不够的：我们需要将数据进行分区（partitions），也称为分片（sharding）1。
术语澄清 ​ 上文中的分区(partition)，在MongoDB，Elasticsearch和Solr Cloud中被称为分片(shard)，在HBase中称之为区域(Region)，Bigtable中则是 表块（tablet），Cassandra和Riak中是虚节点（vnode)，Couchbase中叫做虚桶(vBucket)。但是分区(partition) 是约定俗成的叫法。
​ 通常情况下，每条数据（每条记录，每行或每个文档）属于且仅属于一个分区。有很多方法可以实现这一点，本章将进行深入讨论。实际上，每个分区都是自己的小型数据库，尽管数据库可能支持同时进行多个分区的操作。
​ 分区主要是为了可伸缩性。不同的分区可以放在不共享集群中的不同节点上（参阅第二部分关于无共享架构的定义）。因此，大数据集可以分布在多个磁盘上，并且查询负载可以分布在多个处理器上。
​ 对于在单个分区上运行的查询，每个节点可以独立执行对自己的查询，因此可以通过添加更多的节点来扩大查询吞吐量。大型，复杂的查询可能会跨越多个节点并行处理，尽管这也带来了新的困难。
​ 分区数据库在20世纪80年代由Teradata和NonStop SQL【1】等产品率先推出，最近因为NoSQL数据库和基于Hadoop的数据仓库重新被关注。有些系统是为事务性工作设计的，有些系统则用于分析（参阅事务处理或分析）：这种差异会影响系统的运作方式，但是分区的基本原理均适用于这两种工作方式。
​ 在本章中，我们将首先介绍分割大型数据集的不同方法，并观察索引如何与分区配合。然后我们将讨论重新平衡分区，如果想要添加或删除群集中的节点，则必须进行再平衡。最后，我们将概述数据库如何将请求引导到正确的分区并执行查询。
分区与复制 ​ 分区通常与复制结合使用，使得每个分区的副本存储在多个节点上。 这意味着，即使每条记录属于一个分区，它仍然可以存储在多个不同的节点上以获得容错能力。
​ 一个节点可能存储多个分区。 如果使用主从复制模型，则分区和复制的组合如图6-1所示。 每个分区领导者(主)被分配给一个节点，追随者(从)被分配给其他节点。 每个节点可能是某些分区的领导者，同时是其他分区的追随者。
我们在第5章讨论的关于数据库复制的所有内容同样适用于分区的复制。 大多数情况下，分区方案的选择与复制方案的选择是独立的，为简单起见，本章中将忽略复制。
图6-1 组合使用复制和分区：每个节点充当某些分区的领导者，其他分区充当追随者。
键值数据的分区 ​ 假设你有大量数据并且想要分区，如何决定在哪些节点上存储哪些记录呢？
​ 分区目标是将数据和查询负载均匀分布在各个节点上。如果每个节点公平分享数据和负载，那么理论上10个节点应该能够处理10倍的数据量和10倍的单个节点的读写吞吐量（暂时忽略复制）。
​ 如果分区是不公平的，一些分区比其他分区有更多的数据或查询，我们称之为偏斜（skew）。数据偏斜的存在使分区效率下降很多。在极端的情况下，所有的负载可能压在一个分区上，其余9个节点空闲的，瓶颈落在这一个繁忙的节点上。不均衡导致的高负载的分区被称为热点（hot spot）。
​ 避免热点最简单的方法是将记录随机分配给节点。这将在所有节点上平均分配数据，但是它有一个很大的缺点：当你试图读取一个特定的值时，你无法知道它在哪个节点上，所以你必须并行地查询所有的节点。
​ 我们可以做得更好。现在假设您有一个简单的键值数据模型，其中您总是通过其主键访问记录。例如，在一本老式的纸质百科全书中，你可以通过标题来查找一个条目；由于所有条目按字母顺序排序，因此您可以快速找到您要查找的条目。
根据键的范围分区 ​ 一种分区的方法是为每个分区指定一块连续的键范围（从最小值到最大值），如纸百科全书的卷（图6-2）。如果知道范围之间的边界，则可以轻松确定哪个分区包含某个值。如果您还知道分区所在的节点，那么可以直接向相应的节点发出请求（对于百科全书而言，就像从书架上选取正确的书籍）。
图6-2 印刷版百科全书按照关键字范围进行分区
​ 键的范围不一定均匀分布，因为数据也很可能不均匀分布。例如在图6-2中，第1卷包含以A和B开头的单词，但第12卷则包含以T，U，V，X，Y和Z开头的单词。只是简单的规定每个卷包含两个字母会导致一些卷比其他卷大。为了均匀分配数据，分区边界需要依据数据调整。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4331baef64b5db30b142e70d66a60dcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61972f7e511de83e0e69c30ac65d5bae/" rel="bookmark">
			ubuntu从19.04升级到20.04输入密码登陆后又自动退出到登陆界面的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 因为需要安装一个在20.04上使用的应用程序，所以将系统从原来的19.04升级到20.04，方法是替换20.04的源，然后使用sudo apt upgrade。
过了一段时间因为项目需要，要使用集显，所以将Nvidia的显卡拿下来，然后就悲剧了，重启后输入密码，系统并没有进入桌面，而是立即回到了输入密码界面，如此反复。。。
折腾了两天，终于解决了这个问题，但。。。具体原因是什么也未知
解决办法 重新安装gdm sudo apt install gnome-session gdm3 删除一些文件 sudo rm -rv /tmp/* 重启 reboot 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76e6b53490480e0f20ac0330f6ae350c/" rel="bookmark">
			在mv 过程中，不小心中断了怎么办，有影响吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在mv 过程中，不小心中断了怎么办，有影响吗
原理：
mv 操作是先 cp 再 rm 的，但是这个是针对文件级别进行操作的。
1、如果操作的文件，通常是没影响的
原因：
如果是cp部分出问题删了目标文件即可，原文件毫无影响。
如果运行到rm部分，说明cp已经完成，那目标文件完好，原文件无所谓完不完好。
2、如果操作的文件夹，则有影响，需要继续执行mv操作
原因：
如果是 mv 文件夹中间被中断，则很有可能是有部分文件已完成 cp + rm，部分文件只 cp 了一部分，部分文件还没有被 cp，很少有可能出现部分文件被 rm 到一半中断的（ unlink 操作太快 ）
所以，如果 mv 文件夹被中断，则需要继续 mv 直到完成操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77f4cd1b36ac031001784cc362c2cc3f/" rel="bookmark">
			（P53-56）物理层查询优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.为什么要物理查询优化？2.代价估算3.代价估算总结4.小结 1.为什么要物理查询优化？ 一个选择查询的eg：
的执行方案
方案1：表空间扫描方法
直接对Course表进行扫描，从第一条检索到最后一条，将满足条件的记录找出方案2：利用Course上的Cname排序索引的方法
利用排序索引可以进行诸如二分查找等快速检索，找到相应的索引项，依据指针将满足条件的记录找出当条件更复杂时，可选择的方案还会更多，对于上述的方案，究竟用哪一个算法的程序来执行?为什么如此选择? 物理查询运算符
物理查询运算符通常是关系代数操作符的一个特定实现程序获取关系元组的操作
TableScan(\R) —表空间扫描算法
SortTableScan(\R)—表空间扫描排序算法
IndexScan(\R)—索引扫描算法
SortIndexScan(\R)—索引扫描排序算法 关系操作的各种实现算法
，集合上的操作： , 包上的操作： , 积，连接： PRODUCT， JOIN每个关系操作都有下面的算法：一趟算法、两趟算法；基于索引算法、基于散列算法、基于排序算法； 迭代器构造–流水化、物化；
物理优化
就是为每一个关系代数操作选择合适的执行程序
2.代价估算 DBMS如何衡量物理查询计划的优劣呢？
衡量I/O访问次数衡量CPU的占用时间内存使用代价(与缓冲区数目与大小的匹配)中间结果存储代价计算量(如搜索记录、合并记录、排序记录、字段值的计算等)网络通信量 依据什么信息来计算这些方案的上述各种指标呢？
依据数据库的一些统计信息—存放在数据字典或系统目录中的
T R 或 者 T ( R ) ： 关 系 R 的 元 组 数 目 T_R或者T(R)：关系R的元组数目 TR​或者T(R)：关系R的元组数目 B R 或 B ( R ) ： 关 系 R 的 磁 盘 块 数 目 B_R或B(R) ：关系R的磁盘块数目 BR​或B(R)：关系R的磁盘块数目 f R 或 f ( R ) : R 的 块 因 子 ， 即 一 块 能 够 存 储 的 R 的 元 组 数 目 f_R或f(R) : R的块因子，即一块能够存储的R的元组数目 fR​或f(R):R的块因子，即一块能够存储的R的元组数目 V ( R , A ) : R 中 属 性 A 出 现 不 同 值 的 数 目 ， 即 π A ( R ) 的 数 目 V(R, A): R中属性A出现不同值的数目，即 π_A(R) 的数目 V(R,A):R中属性A出现不同值的数目，即πA​(R)的数目 S C ( A , R ) : R 中 属 性 A 的 选 择 基 数 ， 满 足 A 上 等 值 条 件 的 平 均 记 录 数 SC(A, R): R中属性A的选择基数，满足A上等值条件的平均记录数 SC(A,R):R中属性A的选择基数，满足A上等值条件的平均记录数 b ： 每 个 磁 盘 块 的 字 节 数 ； b：每个磁盘块的字节数； b：每个磁盘块的字节数；DBMS依据上述统计信息对DB操作的各种物理查询计划进行评估，以确定最优的计划予以执行 上述信息如何获得呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77f4cd1b36ac031001784cc362c2cc3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b3ce1a9c3dab3302d9843b593b3600a/" rel="bookmark">
			ESP32定时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、定时器二、定时器函数三、定时器配置步骤四、VSCode添加头文件总结 前言 提示：以下是本篇文章正文内容
一、定时器 ESP32 芯片包含两个定时器组，每组有两个通用定时器。它们都是基于 16 位预分频器和 64 位自动重载功能的向上/向下计数器的 64 位通用定时器
二、定时器函数 (1)timerBegin 初始化（开启）定时器
hw_timer_t * IRAM_ATTR timerBegin(uint8_t num, uint16_t divider, bool countUp)
num : 定时器编号（0到3，对应全部4个硬件定时器）
divider: 预分频器数值（ESP32计数器基频为80M，80分频单位是微秒）
countUp: 计数器向上（true）或向下（false）计数的标志
返回一个计时器结构体指针 hw_timer_t * ,预定义一个指针接收它
hw_timer_t *timer = NULL; timer = timerBegin(0, 80, true); (2)timerAttachInterrupt 绑定定时器的中断处理函数
void IRAM_ATTR timerAttachInterrupt(hw_timer_t *timer, void (*fn)(void), bool edge)
timer:指向已初始化定时器的指针
(*fn)():中断服务函数的函数指针
edge:表示中断触发类型是边沿（true）还是电平（false）的标志
(3)timerAlarmWrite 指定触发定时器中断的计数器值
timerAlarmWrite(hw_timer_t *timer, uint64_t alarm_value, bool autoreload)
timer:指向已初始化定时器的指针
alarm_value: 触发中断的计数器值（1000000 us -&gt; 1s）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b3ce1a9c3dab3302d9843b593b3600a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed5bf5b6de84955da828bd4349f291a8/" rel="bookmark">
			JdbcTemplate 使用笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记帖---------------------------------------------------------------------------------------------------------
最近在使用JdbcTemplate的时候发现一个问题,在Query(new BeanPropertyRowmapper&lt;.class&gt;)函数返回一个List&lt;Double&gt;列表时发现，报错is it an abstract class?; nested exception is java.lang.instantiationexception: java.lang.double。
网上搜索以后得到答案，利用反射实例化类时，不能有抽象类，或者类中必须有给出无参构造函数。并且用new BeanPropertyRowmapper类属性和数据库列表名要一一对应，而Double类显然只有一个字段且与数据库不对应。所以用Query必须是自定义类，且属性与数据库字段名一一对应
看源码以后发现Double没有无参构造
使用QueryForObject(sql,Long.class)解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8fb8443d5ac7bd641c009c5a7776972/" rel="bookmark">
			Ansible---第一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、构建学习环境：
student用户在控制节点（workstation）上安装并配置 Ansible, 要求如下 ：
1、安装所需的软件包 [student@workstation ~]$ sudo yum install ansible 2、创建静态inventory文件/home/student/ansible/inventory，要求如下： servera属于dev主机组 serverb属于test和balancers主机组 serverc和serverd属于prod主机组 prod主机组属于webservers主机组 [student@workstation ~]$ vim /home/student/ansible/inventory [dev] servera [test] serverb [balancers] serverb [prod] serverc serverd [webserver:children] prod [all:vars] ansible_user=root ansible_password=redhat 3、创建ansible配置文件/home/student/ansible/ansible.cfg，要求如下： 使用/home/student/ansible/inventory清单文件 角色存放在/home/student/ansible/roles/ 目录 [student@workstation ~]$ cp /etc/ansible/ansible.cfg /home/student/ansible/ inventory = /home/student/ansible/inventory roles_path = /home/student/ansible/roles/ [privilege_escalation] become=True become_method=sudo become_user=root become_ask_pass=False [paramiko_connection] 创建roles路径
[student@workstation ~]$ mkdir /home/student/ansible/roles
验证清单文件
[student@workstation ~]$ cd ansible/ [student@workstation ansible]$ ansible-inventory --graph @all: |--@balancers: | |--serverb |--@dev: | |--servera |--@test: | |--serverb |--@ungrouped: |--@webserver: | |--@prod: | | |--serverc | | |--serverd 二、创建一个 shell 脚本名为 adhoc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8fb8443d5ac7bd641c009c5a7776972/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba21014756d34b379f5cc93af17dd44a/" rel="bookmark">
			HTTP中状态码301、302、401、403、404、500 、504的含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在HTTP 中〃状态码 301、302、401、403、404、500 、504的含义是；
301（永久移动）
请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。
302（临时移动）
服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。
400（错误请求）
服务器不理解请求的语法。
401（未授权）
请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。
403（禁止）
服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。
404（未找到）
服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。
如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具“诊断”标签的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。
如果对于 Googlebot 抓取的网址看到此状态码（在”诊断”标签的 HTTP 错误页面上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。
500（服务器内部错误）
服务器遇到错误，无法完成请求。
501（尚未实施）
服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。
502（错误网关）
服务器作为网关或代理，从上游服务器收到无效响应。
503（服务不可用）
服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e58bb89f05d4ec9aad8e5889eed671c/" rel="bookmark">
			21年6月阿里巴巴Java暑期实习面经回顾（已上岸）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是路飞！昨天在整理电脑中的学习资料的时候，偶然发现自己半年前面试阿里暑期实习的时候的面经
注：每个人的面试侧重点不一样，有很大的随机性，这要看你简历撰写的内容，以及面试官个人想法了！
一、简历筛选：2021-6-13 简历撰写注意点：尽可能以精简的文字描述清楚自己完整的技术栈范围，切记不要什么都写（要以自己有把握的为主），写进简历里的东西就可能被面试官问到，如果只是把自己所有接触过但是并不是很熟悉的内容都堆积进去，面试官问你某个方面的问题时，自己答不上来，那么这一部分的技术栈不但不会成为加分项反而是扣分项。重视基础，不要头重脚轻：前段时间帮忙看过一些同学的简历，简历技术栈板块内容很丰富，技术体系很全面，涉及到的常见技术栈基本上都写了。问题是，面试官如果从计算机网络、操作系统、以及Java基础、JDK源码、JVM、数据库索引等方面去问问题时，一问三不知，给面试官的印象就是一味的堆积技术栈的使用，没有重视基本功。简历中的亮点：比如ACM、CTF、ICPC等比赛的参赛奖项，以及技术博客可以适当突出（如果自己刷题数量较多，题解数量较多，甚至可以加上自己的leetcode首页），也包括英语六级、国家奖学金、年级总排名、专利等等。精心打磨自己的简历：让HR筛选的时候更容易通过！如果只是随便写写，即使你确实非常精通算法，或者技术能力强，底层知识了解非常透彻，也很可能在筛选时候就被淘汰！ 二、素质测试：2021-6-13 几乎是刚投递完简历，就收到了素质测试。测试内容包括：成语、诗句、表格计算、图形、人格测试等。这一流程不难，就是比较考验耐心把（需要花不少时间）~
三、算法笔试(60min)：2021-6-14 笔试总共4道题：一道涉及道回溯的智力题(面试官提示用回溯了，还是没写出来)、一道二叉树俯视图(解决)、一道动态规划解决背包问题(解决)、一道类似于剑指offer中的mid股票问题(解决)。几道题都不太难（相比于字节的笔试题来说），mid题居多，一道hard。
注：保险起见，个人认为力扣200~300的题量是非常不错的（树、链表、排序、递归、回溯、动态规划这几个要重点去刷），重点刷剑指offer、Top100这些题。要反复刷，有效率的刷。
四、技术一面(40min)：2021-6-16 首先是自我介绍（5min左右，不要太长也不要太简短）~JMM内存模型相关问题，大概就是工作内存与主内存的通信原理、为什么要引入JMM，这几部分（狗头，不要把JMM内存模型跟运行时数据区（堆、栈、方法区、程序计数器、本地方法栈…）搞混了，背八股文可以，但是不要不懂为什么而死记硬背！）CSDN写博客相关的问题：什么时候开始写博客，写博客给你带来哪些收获？平时怎么自学的？简述一下自己的学习历程。 写博客很重要！之前也被别人质疑过：“你写的博客没人看，为啥还要花时间去写这些没用的文章？”。不要管别人怎么评价，自己坚持去积累下去，不光可以增加自己对某些知识的进一步理解，而且随着粉丝量的增多，写博客给我们带来了一些额外的收益，以及一些人脉，在CSDN上结识了很多同届大三拿到BAT Offer的牛鬼蛇神大佬，也有工作多年经验的老油条，跟着他们不光能学到东西，最重要的是眼界开阔了。
我之前一直认为，能进BAT大厂的只有985-211的名校学生，或者高学历的研究生才可以，普通本科就直接把自己否定了。
但事实并非如此，在CSDN，有幸结识了不少同为普通本科拿到大厂Offer的大佬。所以，不要盲目自信，也不要太过于轻视自己，在没有真正尝试取得结果之前，不要盲目否认自己的努力和付出！
Redis相关问题（问了几个常见的八股文问题）：缓存击穿，缓存穿透，缓存雪崩；布隆过滤器实现原理，不使用SETNX如何实现分布式缓存？项目相关问题：项目中哪些地方做了缓存，不同的缓存有什么区别？ES-MQ如何实现数据同步，项目中做了那些优化，有没有涉及到分表? 还做过那些项目简单介绍一下，最好提供一下项目链接，或者Gitee仓库链接。Jvm垃圾回收相关问题：回收算法，回收策略，回收机制，这块我比较熟悉，巴拉巴拉从回收策略迭代，到回收算法迭代，再到FULL GC、YOUNG GC，STW 。。。讲了十几分钟，还没说完，面试官说：“好了好了，我知道这块你比较熟悉了，我们进行下一个问题”。（这部分八股文面经背的很熟悉，Java虚拟机这本书也看了2遍了哈哈）Jvm运行时数据区相关，堆和栈的进一步详细划分及其作用？（这一块谈到了，操作数栈和本地方法表中运算的流程，这部分还是很有趣的，可以去找个案例去分析一波，例如 a++ + ++a + a-- 的结果）。收尾问题：CSDN上你写过的最满意的一篇博客是那一篇？上一家实习经历相关问题，实习做了什么，介绍一下具体是负责那一块任务怎么做的，实习了多久。反问环节：问了部门业务类型，用到的技术栈等等。 还有一些零碎小问题记不清了，主要就是上面这些，电话收到面试通知的时候非常激动，也很害怕，害怕被面试官完虐，毕竟这是第二家大厂面试，上一次面字节，准备不充分（裸面），一面被虐的体无完肤。
五、技术二面(40min)：2021-6-18 二面换了一个面试官，还是先让我做自我介绍~接下来还是聊项目，首先介绍一下项目的整体架构，然后提问实际场景题：“Kafka生产者生产数据时，如何保证多线程条件下生产了多条数据，而消费方只消费了其中1条的情况？”
“还是上面这个问题，如果加锁的话（单体应用可以加锁解决，但是分布式下无效），在分布式环境下如何解决呢？”（分布式锁 SETNX）。实习经历相关问题： “你在上一家公司实习，具体负责那一块儿内容，开发过程中遇到了那些问题，你是怎样处理和解决的？”计算机网络相关问题：TCP的三次握手、四次挥手详细流程，以及状态转换过程，为什么要三次握手？又为什么要四次挥手？（八股文）计算机网络相关问题：UDP和TCP的区别，如何使用UDP去实现一个简单的TCP？（八股文）JVM相关问题：Java语言和C++在执行效率和编译层面的区别？为什么Java效率低，还需要使用JVM？Java是如何解决这个问题的？JVM中即时编译的几种实现方式有了解过吗？开阔场景问题：在校期间有没有用所学的技术栈去实现一个解决实际需求呢，请你说一下是怎样做的？操作系统相关问题：为什么要将操作系统分为用户态和核心态？MySQL数据库相关问题：MySQL索引数据结构，为什么要使用B+树，而不采用其他数据结构？例如Hash表，B树，红黑树？Java基础问题：问一个简单问题，JDBC链接数据库的流程能说一下吗（送分题）！数据库相关问题：什么是回表查询？什么是索引覆盖？收尾问题：你当前除了阿里，还在面试其他公司吗？反问环节：略。 二面效果非常好！面试官人超级暖！面试官这边刚挂断电话，HR就告诉我面试官对你评价很好，当场二面就过了）不得不说，CSDN写博客给我这个没竞赛，没学历的普通在校生加了很多分！
二面是我最紧张的一轮，紧张的时候语气助词，嗯嗯…，然后…然后… 哈哈，还好面试官很暖，很快就把节奏带正了！
可能有小伙伴会疑惑，为什么没有深入去问你JDK集合、线程池、锁、原子类这些源码？这个我也不太清楚，不过面试官在面试的时候，貌似也打开我的博客看了，这几个部分的源码学习，我写的文章还是比较多的，虽然体会不到 Doung Lea 大神的高端思维，也不能像那些多年经验的老油条一样深入体会其原理，但是这部分我准备的时间精力还是比较长的，至少不能说是完全没看过源码。有兴趣的小伙伴可以看一下我的JDK、JUC源码分析专栏，基本上常见集合源码、CAS、原子类，AQS，并发集合源码，红黑树，基本上都写过文章！
六、技术三面(20min)：2021-6-23 三面貌似是主管面，刚开始还是先自我介绍~简单聊一聊项目，项目是否上线过，有没有遇到过上线后刚开始项目运行访问很流畅，之后接口访问越来越慢的情况？智力题1 两根不均匀香，求15分钟如何表示（没答上来）智力题2 抓果冻（排列组合问题，还是很容易回答的）SQL场景题1：写SQL，查找一张表中分数在0-60 60-80 80-100 三个层次的学生人数。场景题：如何自己去实现一个PRC框架，说一说你的思路？（没答上来，那时候还没学过Netty，也没看过这一部分的面试题）大学期间学了哪些课程？看过那些书籍？坚持写博客持续了多长时间？动态代理的实现原理，（JDK动态代理和Cglib动态代理）Linux相关问题：查找某个目录下所有以某个字母开头的文件。Linux下，如何查看某个文件的后10行，并将其写入另一个文件中。计算机网络相关问题：HTTPS的实现原理，如何保证通信安全？计算机网络相关问题：HTTPS建立连接的流程Git和SVN设计思想上的差别？（没答上来）反问环节：略。 七、HR面(10分钟) 2021-6-28 接到HR面电话的收获，激动得一批，但是当时已经接了B站的暑期实习，人已经到了上海了，所以最后没接阿里暑期实习的offer。大概问了一些琐碎小问题，比如什么时候可以来实习，实习时候的薪资待遇，为什么放弃了来阿里实习，之后有机会的话还会选择来阿里实习吗？
八、总结 整体面试流程非常满意，面试官和HR小姐姐人都超级棒。
由于我自己之前网投的原因，简历被卡在阿里健康，一直没给我安排面试时间，简历就一直锁着，没办法投递阿里其他部门。把问题反应给HR小姐姐后，他提前帮忙给我安排面试，二面通过后HR和一面面试官帮忙去线下找Boss和招聘员，从阿里健康部门那边要回我的简历（花了几天时间），又继续安排我的第三轮技术面，非常感激！
注意：大厂各个部门，子公司是共享招聘信息的，挂一次会被记录，所以不要毫无准备就无脑投递，如果一个企业生态连续3个以上部门面试被挂，就考虑换一个企业把，因为短时间连续挂，会影响下一场面试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a66e720f8c0b8f7f60a7579030516171/" rel="bookmark">
			操作系统遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.实验问题 （2021.11.21）进程管理
fork（）函数头文件 #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; 可以学习一下大佬的笔记
https://www.cnblogs.com/wannable/p/6021597.html
也可以看一下我截得中国大学mooc老师的课件
2.堆栈管理一块内存区中各数据块的使用情况
getaddr(top); //从栈顶取出相应的内存块的地址； reladder(blk); //将数据块中的地址（以blk为地址）放入堆栈 3.进程创建原语
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86f2033f36125cde6eb0615d8d82cdf5/" rel="bookmark">
			25-多表查询-练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意这里要会看架构表
-- 部门表 CREATE TABLE dept ( id INT PRIMARY KEY PRIMARY KEY, -- 部门id dname VARCHAR(50), -- 部门名称 loc VARCHAR(50) -- 部门所在地 ); -- 添加4个部门 INSERT INTO dept(id,dname,loc) VALUES (10,'教研部','北京'), (20,'学工部','上海'), (30,'销售部','广州'), (40,'财务部','深圳'); -- 职务表，职务名称，职务描述 CREATE TABLE job ( id INT PRIMARY KEY, jname VARCHAR(20), description VARCHAR(50) ); -- 添加4个职务 INSERT INTO job (id, jname, description) VALUES (1, '董事长', '管理整个公司，接单'), (2, '经理', '管理部门员工'), (3, '销售员', '向客人推销产品'), (4, '文员', '使用办公软件'); -- 员工表 CREATE TABLE emp ( id INT PRIMARY KEY, -- 员工id ename VARCHAR(50), -- 员工姓名 job_id INT, -- 职务id mgr INT , -- 上级领导 joindate DATE, -- 入职日期 salary DECIMAL(7,2), -- 工资 bonus DECIMAL(7,2), -- 奖金 dept_id INT, -- 所在部门编号 CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id), CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id) ); -- 添加员工 INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES (1001,'孙悟空',4,1004,'2000-12-17','8000.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86f2033f36125cde6eb0615d8d82cdf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d255e229e1ca5dd0e32d6870b700583/" rel="bookmark">
			IDEA(最新版)配置servlet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA(最新版)配置servlet 文章目录 IDEA(最新版)配置servletIDEA配置servlet IDEA配置servlet idea配置tomcat需首先安装完成tomcat，安装tomcat请移步笔者相应博文。
tomcat的安装：https://blog.csdn.net/Ronin__L/article/details/119825275
idea创建web项目及配置tomcat：https://blog.csdn.net/Ronin__L/article/details/120341580
创建配置tomcat完后的界面如下
按照红点点击如下：
跳出文件选择，选择tomcat的安装位置，在tomcat文件中选择lib文件夹，选择servlet（如需配置其他内容请选择相应内容）
直接点击ok即可配置完成相应的服务配置。
右击src文件夹选择new出现如下的相应配置，则表示配置成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b60b2f87f09c43289893e5692426ab7/" rel="bookmark">
			动手学习深度学习——基本简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 一些建议：如果是深度学习刚刚入门，或者对深度学习的发展历史不是很熟悉的同学，可以认真读读本文，增加对该领域的背景，发展历史，应用领域的全面了解。
参考项目：《动手学习深度学习》，李沐，第二版。
英文原文：https://d2l.ai/chapter_introduction/index.html
注意：博文中的图片均来自英文原文。
1. 简介 直到最近，几乎我们接触到的每一个计算机程序都是软件开发人员根据第一性原理（First Principles）编写而成。比如，我们想编写一个应用程序来管理电子商务平台。在围绕白板思考几个小时后，我们可以得到大致的解决方案：（i）用户通过运行在网页浏览器或者移动应用程序界面与应用程序交互；（ii）我们的应用程序与商用级的数据库引擎交互，并追踪每一个用户的状态和维持历史的交易记录；（iii）在应用程序的核心，应用程序的业务逻辑(也可以说是大脑)以系统的方式详细说明了程序在每个可能的情况下应该采取的适当操作。
为了建立应用程序的大脑，我们不得不考虑每一个可能发生的情况，并制定适当的准则。每次客户点击添加商品到购物车，我们在购物车数据库表中添加一条记录，并且将用户的ID与产品的ID相关联。很少有开发者能够一次正确完成所有的功能（可能需要一些测试才能解决这些问题），大部分情况下，我们能够根据第一性原理写出这样一个程序，并在遇到真正的客户之前推出。我们能够根据第一性原理设计自动化系统，驱动功能性产品和系统，通常在新的情况下，这是一个了不起的认知壮举。当你能够解决所有的问题时，你就不必要使用机器学习。
幸运的是，对于不断增大的机器学习科学家团体，我们想要自动化的很多任务不是那么容易屈服于人类的聪明才智。想象一下，你和你所知道的最聪明的人挤在在白板前，但是这个时候你们正在解决下面问题中的一个：
编写一个程序，根据地理信息，卫星图像和过去天气的跟踪窗口，预测明天的天气。编写一个程序，输入为自由格式的文本问题，并且正确的回答。编写一个程序，输入一张图像，能够识别图片中包含的所有人，并且画出每一个人的轮廓。编写一个程序，呈现给用户喜欢的商品，但是在自然的浏览中又不会遇到。 上面遇到的每一种情况，尽管是优秀的程序员也没办法从零开始编写解决方案。原因可能有很多。有时候，我们正在寻找的程序遵循一个随着时间变化的模式，我们需要我们的程序来适应。在其他情况下，这种关系(比如像素和抽象类别之间的关系)可能过于复杂，需要进行成千上万次的计算，而这些计算超出了我们的意识理解能力，即使我们的眼睛可以毫不费力地完成这项任务。机器学习正是这种学习能力很强的技术，可以从经验中学习。随着机器学习算法积累更多的经验，通常以观察数据或与环境交互的形式，其性能得到提高。这与我们确定的电子商务平台对比鲜明，无论有多少数据出现，电子商务平台遵循的逻辑是不变的，直到开发者自身通过学习，进而更新软件。在本书中，我们将传授机器学习的基础，并聚焦于深度学习，一系列强大的技术推动了计算机视觉、自然语言处理、医疗保健和基因组学等领域的创新。
1.1. 一个激励人心的例子 在开始写作之前，像其它工作者一样，本书的作者不得不让自己兴奋起来。我们跳入车中，开始驾驶。使用iPhone手机，Alex 喊出 “Hey，Siri”，手机的语音识别系统被唤醒。然后，Mu 给出指令 “去蓝瓶咖啡店”。手机迅速展示了转录的指令。手机同时也识别了我们说话的内容是去咖啡店，并打开地图应用来满足我们的请求。一旦打开，地图APP识别一些路线。对于每一条路线，手机APP展示了预测的通勤时间。虽然我们编造这个故事是为了教学上的便利，但它表明，在短短几秒钟内，我们与智能手机的日常交互可以使用几种机器学习模型。
想象着写一个识别唤醒词（比如，Alexa，OK Google，Hey，Siri）的程序。在一个空的屋子里，试着只使用一台电脑和代码编辑器实现如 图1.1.1 的功能。你会根据第一原理如何编写程序？想想看，这个问题很难。每一秒，麦克风大概收集44000个样本。每个样本都是对声波振幅的测量。无论语音片段是否包含唤醒词，什么样的准则能够确信的将原始音频的一段映射为可靠的预测（yes，no）？如果你感觉到困难，不用担心。我们也不知道如何从零开始写这样的程序。这也就是为什么我们要使用机器学习。
这就是诀窍的所在。常常，尽管我们不知道如何明确地告诉电脑将输入映射为输出，但是，我们还是有能力完成这样的壮举。换句话说，尽管你不知道如何编程让电脑识别唤醒词，但是你自己是可以识别的。拥有这样的能力，我们可以收集大量的数据集，包含了语音样本和相应的标签（可能包含唤醒词，也可能没有包含）。在机器学习的方法中，我们不会尝试设计一个明确识别唤醒词的系统。相反地，我们定义可变的程序，它的表现是由参数决定的。然后，我们使用数据来决定最佳的参数集，这些参数可以提升我们的程序在某些感兴趣任务方面的性能。
你可以将参数视为我们可以调用的操作程序行为的旋钮。固定参数，我们将程序称为模型。所有不同程序（输入输出的映射）的集合可以通过调整参数进而得到不同的模型被称为模型族。使用我们的数据集来选择参数的元程序称为学习算法。
在我们着手使用学习算法之前，我们必须精确地定义问题，确定输入和输出的精确性质，并选择合适的模型族。在上面的例子中，我们的模型接收语音的一个片段作为输入，并在集合（yes，no）中选择一个作为输出。如果一切都按照计划进行，模型对输入片段是否包含唤醒词的猜测通常是正确的。
如果我们选择正确的模型家族，应该存在一个旋钮（参数）设置，每次听到单词“ Alexa”，模型会给出“yes”的输出。因为唤醒词的确切选择是任意的，我们可能需要一个足够丰富的模型家族，通过另一个旋钮设置，当听到单词“Apricot”，它可以输出“yes”。我们期望相同的模型族适合“ Alexa”识别和“ Apricot”识别，因为直观上看起来它们是相似的任务。然而，如果我们想要处理完全不同的输入或输出，比如我们想要从图像映射到字幕，或者从英语句子映射到中文句子，我们可能需要一个完全不同的模型族。
正如你猜测的一样，如果我们任意设置所有的“旋钮”，我们的模型可能无法识别“Alexa”，“Apricot”或者任何其它的英文单词。在机器学习中，学习是发现正确的“旋钮”设置，并强制模型达到我们期望的表现。换句话说，我们用数据训练模型。如 图1.1.2 所示，训练过程应该如下：
随机初始化模型的设置，此时模型无法得到任何有效的输出。抓取一些数据（比如，语音片段和相应的{yes，no}标签）。调整旋钮（参数设置），使得模型相对于那些例子来说不那么糟糕。重复步骤2-步骤3，直到模型表现很好，达到预期的结果。 总而言之，如果我们给它提供一个大的带标签数据集，与其编写唤醒词识别程序，不如编写一个程序来学习如何识别唤醒词。你可以将这种用数据集决定程序行为的方式看作是用数据编程。也就是说，我们可以通过给我们的机器学习系统提供许多猫和狗的例子来“编写”一个猫检测器。通过这种方式，如果它是一只猫，检测器最终将学会给出一个非常大的正数，如果它是一只狗，则给出一个非常大的负数，如果不确定是什么动物，则给出一个接近于零的数，这仅仅触及了机器学习能做什么的表面。深度学习只是解决机器学习问题的众多流行方法之一，我们将在后面更详细地解释。
1.2. 关键组件 在我们的唤醒词例子中，我们描述了包含语音片段和二值标签的数据集，我们还粗略介绍了如何训练模型来近似一个从语音片段到分类的映射。基于包含数据样本和标签的数据集，训练一个模型可以在指定输入，没有标签的情况下，给出合适的预测结果，称之为监督学习。这些只是众多机器学习中的一种。后面，我们会深度研究不同的机器学习问题。首先，无论遇到什么样的机器学习问题，我们都需要更多了解下核心组件：
用于学习的数据。用于转换数据的模型。用于评估模型优劣的目标函数。用于调整模型参数的算法，进而优化目标函数。 1.2.1. 数据 毫无疑问，没有数据就没法进行数据科学。我们可能失去数百页的篇幅来思考数据的确切组成部分，但是现在，我们可能在实际应用中犯错，会关注于关键的特性。一般来说，我们会关注一组例子。为了有效的处理数据，我们通常给出合适的数字表示。每一个例子（或者数据点，数据实例，样本）通常包含一系列特性，称之为特征（或者协变量），模型必须作出一定的预测。在上面的监督学习问题中，要预测的是一个被指定为标签(或目标)的特定属性。
如果我们处理图像数据，每一张图片构成一个例子（样本），它是由一组与每一个像素明亮度相关的有序数值表达。一张 200x200 的彩色图像由 200x200x3=12000 个数值组成，与每一个空间位置的红，绿，蓝通道的亮度相关。在另外一个传统的任务中，给定一个标准的特征，比如年龄，生命体征，诊断结果，我们试着预测病人是否存活。
当每个例子的特征是相同数量的数值时，我们说数据由固定长度的向量组成，我们将固定长度的向量作为数据的维度。可以想象，固定长度是一个很方便的属性。如果我们想训练一个模型在显微镜图像中识别癌症，固定长度的输入意味着我们少了一件需要担心的事情。
但是，并不是所有的数据都可以容易表达为固定长度的向量。然而我们希望显微镜图像来自标准的设备，我们不可能期望来自互联网的图像都有相同的分辨率或者形状。对于图像而言，我们考虑将其裁剪为固定大小的尺寸，但是这种策略也只能到此为止。在被切去的部分存在丢失信息的风险。而且，文本数据更难用固定长度的向量表示。考虑一下亚马逊(Amazon)、IMDB和TripAdvisor等电子商务网站上的客户评论。一些是简短的句子：“它臭死了!”。另一些人则在网页上闲逛。与传统方法相比，深度学习的一个主要优势是现代模型在处理长度变化的数据方面相对优雅。
一般来说，我们拥有的数据越多，我们的工作就越容易。当我们有了更多的数据，我们就可以训练出更强大的模型，减少对预先设想的依赖。从(相对)小数据到大数据的模式转变是现代深度学习成功的主要因素。为了说明这一点，在没有大型数据集的情况下，深度学习中许多最令人兴奋的模型变得无法工作。其他一些方法在小数据系统中工作，但并不比传统方法更好。
最后，仅仅拥有大量数据和巧妙的处理是不够的。我们需要正确的，合适的数据。如果数据存在大量的错误，或者被选择的特征并不能表征目标的特性，学习就会失败。这种情况很好地体现在这句陈词滥调中：垃圾进，垃圾出。而且，糟糕的预测性能并不是唯一的潜在后果。在机器学习的敏感应用中，如预测性监管、简历筛选和用于贷款的风险模型，我们必须特别警惕垃圾数据的后果。一个常见的失败情况是一些数据从来没有在训练集中出现过。想象下，将皮肤癌识别系统应用于从没有见过的黑色皮肤。当数据不仅没有充分代表某些群体，而且反映出社会偏见时，失败也可能发生。例如，如果过去的招聘决定被用来训练一个用于筛选简历的预测模型，那么机器学习模型可能会无意中捕捉并自动呈现历史上的不公正现象。请注意，这一切都可能发生在数据科学家没有积极的阴谋，甚至没有意识到。
1.2.2. 模型 在某种意义上，大多数机器学习都涉及到数据的转换。我们可能想要建立一个系统来读取照片并预测笑容。或者，我们可能想要读取一组传感器读数，并预测读数的正常与异常程度。通过模型，我们指示一种类型数据的计算机制，并给出一个可能不同类型的预测。特别地，我们对可以从数据学习的统计模型更感兴趣。虽然简单模型完全能够恰当地解决简单问题，但我们在本书中关注的问题扩展了经典方法的限制。深度学习与经典方法的区别主要在于它所关注的一组强大的模型集合。这些模型由许多从上到下链接在一起的数据的连续转换组成，因此被称为深度学习。在讨论深度模型的过程中，我们还将讨论一些更传统的方法。
1.2.3. 目标函数 早些时候，我们将从经验中学习作为机器学习引入的关键特征。这里所说的学习，是指随着时间的推移，某些任务的性能有所提升。但是，谁能说明什么是性能改善了呢？你可能会想，我们可以提议更新模型，但是一些人会在我们的提议是造成了模型的改进还是下降方面产生了分歧。
为了开发一个正式的学习机器的数学系统，我们需要建立评估模型好、坏的正式评估标准。在机器学习和最优化中，我们称之为目标函数。按照惯例，我们通常定义目标函数，目标值越低越好。这仅仅是一个惯例。当然，也可以定义越高越好，然后通过符号翻转，将其变为新的目标函数，具有相同的评估能力，但是越低越好。因为越低越好，目标函数也常称为损失函数。
当要预测数值时，最为常见的损失函数是平方误差（squared error），比如预测值与真实值之间差的平方。对于分类问题，常用的目标函数为最小误差率，比如预测样本中，错误预测所占的比例。一些目标函数（比如，平方误差）很容易优化。其它（比如，误差率）很难直接优化，由于不可求导或者其它的一些问题。这种情况下，常优化替代的目标函数。
通常，损失函数的定义需要考虑模型的参数和数据集。在收集的训练集上，通过最小化损失函数来学习最佳的模型参数值。但是，训练集上训练好的模型不一定适用未看到的数据。所以，通常情况下，我们将提供的数据划分为两个部分：训练集（用于拟合模型参数）和测试集（用于评估模型），并给出模型在上述数据集上的表现。你可以把训练表现看作是学生为准备真正的期末考试而进行的模拟考试的分数。尽管模拟考试的结果很好，但也不能保证期末考试表现很好。换句话说，测试表现与训练表现可能存在明显的偏差。当一个模型在训练集表现很好，但是在未训练的数据上表现很差，我们称之为过拟合。在现实生活中，这就像尽管在模拟考试中做得很好，但在真正的考试中却不及格。
1.2.4. 优化算法 一旦我们有了一些数据源和表达，一个模型，和一个明确定义的目标函数，我们需要一个算法，能够搜索最好的可能参数，使得损失函数最小化。深度学习中，比较流行的优化算法是基于随机梯度的优化算法。简而言之，在每个步骤中，这个方法检查每个参数，看看如果你扰乱了这个参数的一小部分，训练集的损失会移动到哪个方向。然后按照可能减少损失的方向更新参数。
1.3. 各种机器学习问题 上面唤醒词识别问题只是机器学习能解决的众多问题之一。为了进一步激励读者，在贯穿整本书的过程中，我们在讨论更多问题时提供一些共同的语言，接下来，我们将会列举一系列机器学习问题。我们会经常引用前面提到的概念，比如数据，模型，和训练技术。
1.3.1. 监督学习 监督学习为了解决在给定输入特征情况下，预测标签的任务。每一个特征标签对（feature-label）称为一个样本。有时候，当上下文很清楚时，我们使用术语示例指代输入的集合，尽管相关的标签是未知的。我们的目标是训练一个模型，可以将任何相关的输入映射为标签的预测。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b60b2f87f09c43289893e5692426ab7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27157371018c8dd605c938975c6a84f0/" rel="bookmark">
			python正则匹配两个字符之间的内容（转自：小晓酱手记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提取指定字符串的关键信息。具体要求是从一个字符串中提取&lt;&gt;里面的内容。
输入：我要听&lt;梁博&gt;的&lt;男孩&gt;
输出：梁博 男孩
Python 实现： #!/usr/bin/python3 #coding:utf8 import re import sys reload(sys) sys.setdefaultencoding('utf8') template = "我要听&lt;歌手名&gt;的&lt;歌曲名&gt;" def subString(template): rule = r'&lt;(.*?)&gt;' # 正则规则 slotList = re.findall(rule, template) return slotList slotList = subString(template) for slot in slotList: print slot 原文地址：Python 提取指定中间字符串 取出字符串中间文本，利用正则表达式_给我一点温度-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2aceef2ea7c42990d46d082ca731619/" rel="bookmark">
			ubuntu中查看IP地址命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ubuntu中想要找到ip地址命令是ifconfig -a
但有时候很神奇，根本找不到ip,就像这样
这样的时候记得去检查 一下虚拟机的连接网络
此时我的网络连接设置是这样子的，虽然虚拟机中是有网的，但是显现不出ip,
我的解决办法是：改变网络连接设置，改成桥接，如下
然后在终端输入ifconfig -a 然后我的ip地址就出来了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8def135bea161e5b1b6c27dd7bac595/" rel="bookmark">
			Servlet（实现前后端连接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概述
准备工作
在IDEA里创建一个web工程
整理web工程目录结构
修改资源输出位置（.class文件等的存放位置）
修改jar包存放位置
配置Tomcat服务器
入门案例
思路
创建Servlet程序
访问Servlet
注解方式开发Servlet程序
–1,创建新的web工程,创建Servlet
–2,测试Servlet
配置方式开发Servlet程序
–1,创建Servlet类
–2,配置Servlet类
–3,测试
–4,总结
前后端整合
–1,创建前端HTML网页
–2,创建后端Servlet程序
–3,配置Servlet类
–4,测试
Servlet的继承结构
Servlet的生命周期
–1,概述
–2,测试
Request –1,概述
–2,常用方法
–3,测试
表单提交数据
–1,创建HTML网页文件
–2,创建Servlet程序
综合案例
–1,需求
–2,创建HTML网页
–3,创建DeptServlet类
–4,总结
请求转发
–1,概述
–2,测试
–3,总结
五,响应Response
–1,概述
优化MyRequest类
重定向
–1,概述
–2,测试
概述 Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成 动态Web内容。这个过程为：
1,客户端发送请求至服务器端
2,服务器将请求信息发送至 Servlet
3,Servlet 生成响应内容并将其传给服务器。响应内容动态生成，通常取决于客户端的请求
4,服务器将响应返回给客户端
Servlet 看起来像是通常的 Java 程序。Servlet 需要导入特定的属于 Java Servlet API 的包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8def135bea161e5b1b6c27dd7bac595/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d00d2bc863873452d10e09ee75db4cde/" rel="bookmark">
			如何从 CentOS 8 迁移到 AlmaLinux 8.5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果您的服务器使用的是CentOS 8系统，则可以使用自动迁移脚本来帮助您无缝迁移到最新版本的AlmaLinux 8.5，而无需卸载和执行全新安装。
Oracle Linux 中还有一个类似的脚本，可帮助您从 CentOS 迁移到 Oracle Linux。
在本指南中，香港服务器https://www.a5idc.net/将引导您使用 Github 上提供的自动迁移脚本将CentOS 8迁移到AlmaLinux 8.5。
注意事项
尽管在我们的案例中迁移顺利且成功，但我们强烈建议您备份所有文件，以防出现问题。正如谚语所说，安全总比后悔好，理想情况下，您希望万一发生意外。
先决条件
在开始之前，请确保您至少运行CentOS 8.3。如果您运行的是任何较低版本，则在运行迁移脚本时会遇到错误。
这是我们在尝试使用CentOS 8.0进行迁移时最初遇到的一个完美示例。
此外，请确保您的硬盘驱动器上至少有5GB的可用磁盘空间来处理升级过程，因为它涉及从 Internet 下载和重新安装文件。
最后，快速稳定的互联网连接肯定有助于加速迁移到 AlmaLinux。
事不宜迟，让我们卷起袖子开始迁移吧。
步骤 1：下载 AlmaLinux 迁移脚本
首先，启动终端并使用curl 命令从 AlmaLinux Github 页面下载almalinux-deploy.sh 脚本，如下所示。
$ curl -O https://raw.githubusercontent.com/AlmaLinux/almalinux-deploy/master/almalinux-deploy.sh 下载后，使用chmod命令为迁移脚本分配执行权限，如下所示。
$ chmod +x almalinux-deploy.sh 第二步：从 CentOS 8 迁移到 AlmaLinux 8.5
现在运行almalinux-deploy.sh脚本如下开始迁移到 AlmaLinux。
$ sudo bash almalinux-deploy.sh 该脚本执行几个任务。首先，它运行一些系统检查。然后继续卸载、重新安装和升级一些软件包，以将它们与最新版本的AlmaLinux同步，此时是AlmaLinux 8.5。
这个过程需要相当长的时间，在我们的例子中大约需要 2 小时，可以去逛逛街，或者玩玩游戏。
迁移完成后，您将收到迁移成功的通知，如下所示。
最后，重启系统以加载最新的AlmaLinux 操作系统。
$ sudo reboot 一会儿，您将看到一个黑色屏幕，底部有AlmaLinux标志，如图所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d00d2bc863873452d10e09ee75db4cde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb67cf718f999c52841a4c144273361c/" rel="bookmark">
			python爬虫自学习1&#43;京东商品爬取实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自学习笔记 序安装第三方库request 库使用方法实例爬取 HTML内容解析——Beautiful Soup 库BeautifulSoup类的基本元素基于bs4库的HTML内容遍历方法bs4库的prettify()方法 实例练习（re+BeautifulSoup+requests） 序 注：本文为自己学习感兴趣内容所做笔记，文中由大量图片构成，因为我是从mooc学的，懒得浪费时间去写那么多文字，用图片记录
最近突然觉得有必要学一下python，翻开大一的Python书发现忘的那是一干二净，想学一下爬虫，只好重头再来，找了个教程一看啥都看不懂，还是老老实实从零开始吧。
安装第三方库 爬虫有一个库叫 requests 说出来不怕丢人我好像连安装第三方库都不会，算了一步一步来
打开 cmd ，因为我的Python是装在D盘的，哪怕以前学过，我还是忘得一干二净
按照图片操作即可得到想安装的第三方库
request 库 使用方法 request的respance对象的属性
request库六种连接异常
response提供了一种异常处理方法
爬取网页的通用代码框架
可以使用异常处理避免程序的崩溃
import requests def getHTMLText(url): try: r = request.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return "Error" if __name__ == "__main___": url = "http://www.baidu.com" print(getHTMLText(url)) request库的主要方法
request 方法对应三个参数
requests.request(method, url, **kwargs)
method: 请求方式，对应 get/put/post 等7种
url: 拟获取页面的url连接
**kwargs: 控制访问的参数，共13个
1)params: 字典或字节序列，作为参数增加到url中，（通过这个参数加到url，服务器可以接受参数作为筛选）
2)data: 字典、字节序列或文件对象，作为Request的内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb67cf718f999c52841a4c144273361c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e212cbaf25adfc6d2613b2d456871f71/" rel="bookmark">
			【接口技术】实验四：8254定时器与计数器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 实验目的二. 实验内容实验4-1 8254计数器实验实验4-2 8254定时器实验 一. 实验目的 掌握8253/8254计数特点和编程方法。掌握8253/8254工作方式3的基本工作原理、计数特点和编程方法。 二. 实验内容 8253/8254的初始化命令字如下图所示：
实验4-1 8254计数器实验 按电路图连接电路，将计数器0设置为方式2，计数器初值为N（N&lt;0FH），用手逐个输入单脉冲，编程使计数值在屏幕上显示，用逻辑笔观察OUTO电平变化，当输入N+1个脉冲后OUTO变为高电平，并将计数过程记录下来。
电路图：
接线：
汇编代码：
io8253a equ 283h io8253b equ 280h code segment assume cs:code start: MOV AL,14H ;设置8253通道0工作方式2，二进制计数，0001 0100 MOV DX,io8253a ;将io8253a对应的283H端口送入DX中 OUT DX,AL ;送工作方式控制字 MOV AL,0FH ;设置初始值0FH，0000 1111 MOV DX,io8253b ;将io8253b对应的280H端口送入DX中 OUT DX,AL ;送初始值 lll: IN AL,DX ;读计数初值 call disp ;调用显示子程序 push dx ;将dx中数据入栈 mov ah,06h ;调用DOS的6号功能，直接读写 mov dl,0ffh ;输入，dl为输入字符的ASCII码 int 21h ;中断，输出 pop dx ;将dx中数据出栈 jz lll ;跳转至lll mov ah,4ch ;返回DOS int 21h ;中断，退出 disp PROC NEAR ;显示子程序disp开始定义 PUSH DX ;将dx中数据入栈 AND AL,0FH ;将高四位清零 MOV DL,AL ;将更新后的AL送入DL中 CMP DL,9 ;将DL中值与'9'进行比较，判断是否小于'9'的ASCII码 JLE NUM ;如果比'9'小，则在'0'-'9'，跳转到NUM ADD DL,7 ;否则为'A'-'F'，需要加37H，A为65H NUM: ADD DL,30H ;将DL中的ASCII码值加30H MOV AH,02H ;调用DOS的2号功能，显示 INT 21H ;中断，输出 mov dl,0dh ;加回车符 int 21h ;中断，输出 mov dl,0ah ;加换行符 int 21h ;中断，输出 pop dx ;将dx中数据出栈 ret ;子程序返回 disp endp ;显示子程序disp结束定义 code ends end start 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e212cbaf25adfc6d2613b2d456871f71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddd0c64bc98e5456e4b78d34de6d8b52/" rel="bookmark">
			tkinter的grid布局定位方式图示详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		grid布局方法及参数 以前讲过pack()这种布局定位组件的方法，今天我们来讲另一种类似表格定位方法来布局的方法grid()
以前我们曾用pack()+frame布局定位组件，做出了登录窗体，今天我们用grid()做同样一个登录窗体。
上面这个窗体就是我们要做的，上面画的表格线，是在我们心中画的，实际上窗体上是没有这些线的。画表格的原则是基本上保证一个组件在一个格子里，但有的组件太长，就让它横向占有2个以上的格子（表格框），而有的组件太高，我们就让它占有2个以上的纵向格子（表格框）。
上面的图，画好了表格线，表格线隔出来9个表格框，我们的做法是：先把这些组件放入对应的表格框里，然后微调它们的位置。在此之前，我们先学一些有关grid的基本知识。
语法：grid( 参数….. )
参数：
row ：组件定位表格的行
column： 组件定位表格的列
ipadx/ipady： 填充表格框，让表格框在X/Y方向上变胖
padx/pady： 决定组件跟邻近表格线或窗体边界的距离
rowspan： 组件跨多少列表格框，默认1个组件占用1行1列
columnspan ：组件跨多少行表格框，默认1个组件占用1行1列
sticky ：当表格框大小组件的大小，组件默认居中显示，那这个表格框周围的空白部分，如何分配，这就由sticky来决定。具体规定如下：
默认组件在表格框中是居中对齐显示的，但通过sticky可以设定N/S/W/E 即上/下/左/右 对齐，N/S/W/E 也可以组件使用，如：
sticky=N+S 拉高组件，让组件上下填充到表格框的顶端和底端。
sticky=N+S+E 拉高组件，让组件上下填充到表格框的顶端和底端，同时，让组件靠右对齐。
sticky=N+W+W+E 拉高并拉长组件，让组件填充满一个表格框。
其它的，以此类推……
表格中的每一行的高度，以这一行最高组件为基准。
表格中的第一列的宽度，以这一列最宽组件为基准。
还有，表格的行，列都是从0开始的，如下图所示：
用实例来演示grid()方法各参数的运用 下面写代码，编写登录窗体：
from tkinter import * root=Tk() la1=Label(root,text='用户名：') la1.grid(row=0,column=0) # 0行0列 en1=Entry(root) # 用户名文本框 en1.grid(row=0,column=1,columnspan=2) # 0行1列，跨2列 la2=Label(root,text='密　码：') la2.grid(row=1,column=0) en2=Entry(root) # 密码文本框 en2.grid(row=1,column=1,columnspan=2) # 1行1列，跨2列 but1=Button(root,text="确定") but1.grid(row=2,column=1) but2=Button(root,text="取消") but2.grid(row=2,column=2) root.mainloop() 运行结果： 镕亓焗
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddd0c64bc98e5456e4b78d34de6d8b52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/044a9e7fd126b66ec2dff4e6cb33a98f/" rel="bookmark">
			规则引擎Drools详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		规则引擎Drools详细介绍 一、 规则引擎概述1.1 什么是规则引擎1.2 使用规则引擎的优势1.3 规则引擎应用场景1.4 Drools介绍 二、 Drools使用与说明2.1 Drools基本构成2.2. Drools基础语法2.3. Pattern模式匹配2.4. 比较操作符2.5. 关键字2.6 Drools内置方法2.7.规则属性 attributes2.8.Drools进阶语法介绍2.9.Drools LHS高级部分2.10.Drools RHS高级部分 一、 规则引擎概述 1.1 什么是规则引擎 规则引擎，全称为业务规则管理系统，英文名为BRMS(即Business Rule Management System)。规则引擎的主要思想是将应用程序中的业务决策部分分离出来，并使用预定义的语义模块编写业务决策（业务规则），由用户或开发者在需要时进行配置、管理。
需要注意的是规则引擎并不是一个具体的技术框架，而是指的一类系统，即业务规则管理系统。目前市面上具体的规则引擎产品有：drools、VisualRules、iLog等。
规则引擎实现了将业务决策从应用程序代码中分离出来，接收数据输入，解释业务规则，并根据业务规则做出业务决策。规则引擎其实就是一个输入输出平台。
上面的申请信用卡业务场景使用规则引擎后效果如下：
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2XMP5Ou6-1637305115031)(…/media/pictures/Drools.assets/4.png)]
系统中引入规则引擎后，业务规则不再以程序代码的形式驻留在系统中，取而代之的是处理规则的规则引擎，业务规则存储在规则库中，完全独立于程序。业务人员可以像管理数据一样对业务规则进行管理，比如查询、添加、更新、统计、提交业务规则等。业务规则被加载到规则引擎中供应用系统调用。
1.2 使用规则引擎的优势 使用规则引擎的优势如下：
1、业务规则与系统代码分离，实现业务规则的集中管理
2、在不重启服务的情况下可随时对业务规则进行扩展和维护
3、可以动态修改业务规则，从而快速响应需求变更
4、规则引擎是相对独立的，只关心业务规则，使得业务分析人员也可以参与编辑、维护系统的业务规则
5、减少了硬编码业务规则的成本和风险
6、使用规则引擎提供的规则编辑工具，使复杂的业务规则实现变得的简单
1.3 规则引擎应用场景 对于一些存在比较复杂的业务规则并且业务规则会频繁变动的系统比较适合使用规则引擎，如下：
1、风险控制系统----风险贷款、风险评估
2、反欺诈项目----银行贷款、征信验证
3、决策平台系统----财务计算
4、促销平台系统----满减、打折、加价购
1.4 Drools介绍 drools是一款由JBoss组织提供的基于Java语言开发的开源规则引擎，可以将复杂且多变的业务规则从硬编码中解放出来，以规则脚本的形式存放在文件或特定的存储介质中(例如存放在数据库中)，使得业务规则的变更不需要修改项目代码、重启服务器就可以在线上环境立即生效。
drools官网地址：https://drools.org/
drools源码下载地址：https://github.com/kiegroup/drools
二、 Drools使用与说明 SpringBoot整合规则引擎Drools：https://blog.csdn.net/weixin_48658389/article/details/121348659
2.1 Drools基本构成 drools规则引擎由以下三部分构成：
Working Memory（工作内存）Rule Base（规则库）Inference Engine（推理引擎）
其中Inference Engine（推理引擎）又包括：Pattern Matcher（匹配器） 具体匹配哪一个规则，由这个完成Agenda(议程)Execution Engine（执行引擎） Working Memory：工作内存，drools规则引擎会从Working Memory中获取数据并和规则文件中定义的规则进行模式匹配，所以我们开发的应用程序只需要将我们的数据插入到Working Memory中即可，例如本案例中我们调用kieSession.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/044a9e7fd126b66ec2dff4e6cb33a98f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a50b3d618dd18c5876e5d5816a573d0/" rel="bookmark">
			java项目poi插件导出Excel文件名中文乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SSM框架下，java项目poi插件导出Excel文件的文件名中有中文，会出现乱码
首先 fileName = "常量表.xls";//创建文件名 fileName = URLEncoder.encode(fileName, "UTF-8"); response.setHeader("Content-disposition", "attachment;filename="+fileName); 火狐浏览器乱码，ie、Edge、谷歌、360极速浏览器正常(ie测试时还遇到了另外的问题)。 火狐：
其次 fileName = "常量表.xls";//创建文件名(改) fileName = new String(fileName.getBytes(),"ISO8859-1"); response.setHeader("Content-disposition", "attachment;filename="+fileName); Edge乱码，ie、谷歌、火狐、360极速浏览器正常。 Edge
最后 fileName = "常量表.xls";//创建文件名(改) fileNameURL = URLEncoder.encode(fileName, "UTF-8"); response.setHeader("Content-disposition", "attachment;filename="+fileNameURL+";"+"filename*=utf-8''"+fileNameURL); Edge、ie、谷歌、火狐、360极速浏览器正常。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44105450ec0008c66140bddea75dd1b9/" rel="bookmark">
			【预训练语言模型】RoBERTa: A Robustly Optimized BERT Pretraining Approach
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【预训练语言模型】RoBERTa: A Robustly Optimized BERT Pretraining Approach 作者发现BERT以及提供的预训练语言模型并没有得到充分的训练，因此本文提出RoBERTa以挖掘BERT模型，并提供充分的训练。作者认为，扩增训练语料、增大预训练的迭代次数、去掉Next Sentence Prediction、在更长的序列上训练、动态Masking等策略（Trick）可以大幅度提升BERT的性能。
简要信息：
序号属性值1模型名称RoBERTa2所属领域自然语言处理3研究内容预训练语言模型4核心内容BERT改进5GitHub源码https://github.com/pytorch/fairseq6论文PDFhttps://arxiv.org/pdf/1907.11692.pdf 一、动机 现有的基于self-training的语言模型（例如ELMo、GPT、BERT等）方法虽然达到了SOTA，但是很难判断那个部分对效果具有很大的促进作用。同时预训练成本很高，使用的provate data限制了模型扩展；我们发现BERT预训练模型并没有得到充分的训练，语义挖掘能力还有一定提升空间； 二、背景——BERT模型及实验设置 可直接参考BERT讲解。
三、RoBERTa——Robustly optimized BERT approach 3.1 More Data BERT只用了Wikipedia和BookCorpus，RoBERTa又额外扩增了训练语料。RoBERTa一共在5个语料上训练，包括Wikipedia、BookCorpus、CC-News、OpenWebText和Stories。后续的实验均在这5个语料上完成。
3.2 Dynamic Making Strategy Masked Language Modeling是BERT中非常重要的预训练目标，但是，在BERT训练过程中，带有随机Mask的语料是数据预处理阶段得到的，而在训练过程中则固定不变（Static Masking）。因此BERT在训练时，对于每一个句子，每次都将见到相同Mask。
因此RoBERTa提出动态地改变每次训练时Mask采样位置（Dynamic Masking）。即每迭代一次训练，重新对每个句子的Mask进行采样。该策略间接实现了数据增强，且提高了鲁棒性。通过改变Mask策略，在QA、NLI以及分类任务上有提升：
3.3 The necessary of NSP？ Next Sentence Prediction（NSP）通常对sentence-pair的输入进行训练，目标是预测两个句子是否存在前后关系。但RoBERTa发现去掉NSP效果反而更好：
3.4 Larger Batch Size 在BERT中，batch size设置为256，一个epoch需要训练超过1M步。RoBERTa训练过程中，增大了batch size。如下表：
不同的batch size以及对应的学习率。实验发现当batch size为2k时，效果可以达到最好。batch size设置大可以采用数据并行方法进行训练。
3.5 Text Encoding——BPE Byte-Pair Encoding（BPE）由Neural Machine Translation of Rare Words with Subword Units提出解决在机器翻译领域中出现的Out-of- Vocabulary（OOV）问题。主要通过wordpiece技术将word分解为更为细粒度的片段。RoBERTa采用BPE，获得了超过5w个token（BERT只有3w）。
BPE的详解可参考：BPE(Byte Pair Encoding)算法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44105450ec0008c66140bddea75dd1b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71070812369d0ec92159fcab358e92c3/" rel="bookmark">
			Spring Data ElasticSearch analyzer 定义 @Filed失效 @Mapping失效 创建索引 无效 解决办法 ElasticsearchRestTemplate
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES版本 7.x 首先上失效原因 SpringDataElasticsearch版本变动频繁，很多网上的代码失效，有很多方法标记为过时ElasticsearchRestTemplate不读@Filed注解，所以你在@Field里面写再多代码也没用，以下代码为错误示例 @Field(analyzer = "ik_smart", type = FieldType.Text) private String commentText; ElasticsearchRestTemplate在创建索引的时候不读@Mapping，也就是需要两步才能创建完整的索引 1、创建索引 2、更新字段mappingElasticsearchRestTemplate 创建的索引名只读@Document注解，所以必须包含@Document注解，以下代码为错误示例 @Mapping(mappingPath="mapper/document.json") @Data public class MyDocument { @Id private String id; private String title; } //创建目标索引代码 restTemplate.indexOps(VideoDocument.class).create(); Mapping.json内，直接说明属性即可，不需要mapping包裹，以下代码为错误示例 { "mapping":{ "properties": { "id": { "type": "text" }, "title": { "type": "text"， "analyzer": "ik_smart", "search_analyzer": "whitespace" } } } } 原因是源码里，直接将此json作为更新索引的请求体，所以es语法怎么定义就怎么写，不是spring 定义的格式
正确写法： 1、需要@Document注解
2、添加Mapping注解，自己创建一个json文件用来定义字段类型 3、创建索引后需要putMapping，更新字段属性，此时才会读Mapping里面定义的json 4、json文件内为 es更新索引的请求体，直接以properties开头 //Document类定义 @Document(indexName = "video") @Mapping(mappingPath="mapper/myDocument.json") public class MyDocument{ @Id private String id; private String title; } //创建索引 可以指定在postconstruct内 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71070812369d0ec92159fcab358e92c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5faf48bd7876b19c2456b2aeeb37c4b5/" rel="bookmark">
			SpringBoot控制台打印SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家用mybatis是不是都有一个烦恼，就是我们在写了很长的sql 加了很多动态条件，测试的时候没有查询出数据，但是又看不到它最后映射的sql是什么样的，导致我们不好锁定错误，如果每次请求我们都可以看到咱们所映射的sql，那我们效率可以快几个倍，还在等什么快点跟我一起开始吧！
在配置文件中添加代码
logging: level: com.baby.base.mapper: debug 注意：level下写的是你mapper所在的包的引用，和我项目的目录所对应：
测试结果：
这不爽翻啦！！！ 有孩子又说了，不看还好，看到sql更绝望了哈哈哈，又是改bug的一天
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2db02246a6f5e9e63b0c3a1e4c98600a/" rel="bookmark">
			CentOS 8.3 上如何安装yarn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.安装源下载 [root@192 ~]# sudo wget https://dl.yarnpkg.com/rpm/yarn.repo -O /etc/yum.repos.d/yarn.repo --2021-11-18 17:11:40-- https://dl.yarnpkg.com/rpm/yarn.repo 正在解析主机 dl.yarnpkg.com (dl.yarnpkg.com)... 104.16.171.99, 104.18.126.100, 2606:4700::6812:7e64, ... 正在连接 dl.yarnpkg.com (dl.yarnpkg.com)|104.16.171.99|:443... 已连接。 已发出 HTTP 请求，正在等待回应... 200 OK 长度：130 [application/octet-stream] 正在保存至: “/etc/yum.repos.d/yarn.repo” /etc/yum.repos.d/yarn.repo 100%[============================================================================================&gt;] 130 --.-KB/s 用时 0s 2021-11-18 17:11:48 (50.7 MB/s) - 已保存 “/etc/yum.repos.d/yarn.repo” [130/130]) 二.安装库包 [root@192 ~]# sudo yum install yarn Yarn Repository 45 kB/s | 365 kB 00:08 上次元数据过期检查：0:00:01 前，执行于 2021年11月18日 星期四 17时12分09秒。 依赖关系解决。 ================================================================================================================================================================================== 软件包 架构 版本 仓库 大小 ================================================================================================================================================================================== 安装: yarn noarch 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2db02246a6f5e9e63b0c3a1e4c98600a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9802d5745cbda1a55772cc85e8b6334/" rel="bookmark">
			Android——一个简单的闹钟APP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个简单的闹钟 效果视频闹钟子项子项布局效果图闹钟适配器类闹钟初始数据侧滑删除闹钟子项添加依赖布局设置实现侧滑回调方法绑定RecyclerView删除子项 新增闹钟子项序列化实体类定义实体类，并实现序列化取出序列化实体类对象 TimePicker自定义TimePicker文字大小及颜色获取时间数据返回时间数据存储数据取出数据子项添加 自定义Switch样式Switch效果如图创建`thumb`和`track`样式thumb样式选中状态默认状态 track样式选中状态默认状态 闹钟提醒服务Service开始服务暂停服务 单例类SP封装类KillProcess封装类TimeFormat封装类 下载地址尾言 效果视频 闹钟子项 子项布局效果图 闹钟适配器类 本示例采用的是RecyclerView，其适配器类与常无二，其异在于继承一个代理类，为适配之后侧滑删除而准备
public class ClockAdapter extends WeSwipeProxyAdapter&lt;ClockAdapter.ViewHolder&gt; 建立一个内部类ViewHolder实现控件定义申明
public ViewHolder(@NonNull View itemView) { super( itemView ); DeleteBtn = itemView.findViewById( R.id.DeleteBtn ); Hour = itemView.findViewById( R.id.Hour ); Split = itemView.findViewById( R.id.Split ); Min = itemView.findViewById( R.id.Min ); Layout = itemView.findViewById( R.id.ItemLayout ); ClockSwitch = itemView.findViewById( R.id.ClockSwitch ); } 实现onCreateViewHolder方法载入子项布局文件
public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { View view = LayoutInflater.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9802d5745cbda1a55772cc85e8b6334/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ea26f0a51403527f886adfcfec2b389/" rel="bookmark">
			Part6-1-2 uniapp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[插件市场](https://ext.dcloud.net.cn/?orderBy=WeekDownload) 下载开发工具 [HBuilderX](https://www.dcloud.io/)
目录结构 应用配置 manifest.json manifest.json 是应用的配置文件，用于指定应用的名称、图标、权限等，我们也可以在这里为 Vue 为 H5 设置跨域拦截处理器
编译配置 vue.config.js vue.config.js 是一个可选的配置文件，如果项目的根目录中存在这个文件，那么它会被自动加载，一般用于配置 webpack 等编译选项
[官方文档](https://uniapp.dcloud.io/collocation/vue-config)
全局配置 page.json page.json 文件用来对 uni-app 进行全局配置，决定页面文件的路径、窗口样式、原生的导航栏、底部的原生 tabbar 等。它类似微信小程序中 app.json 的页面管理部分。
[官方文档](https://uniapp.dcloud.io/collocation/pages)
全局样式 uni.scss `uni.scss`文件的用途是为了方便整体控制应用的风格。比如按钮颜色、边框风格，`uni.scss`文件里预置了一批scss变量预置。[官方文档](https://uniapp.dcloud.io/collocation/uni-scss)
`uni-app` 官方扩展插件（uni ui）及 [插件市场](https://ext.dcloud.net.cn/) 上很多三方插件均使用了这些样式变量，如果你是插件开发者，建议你使用 scss 预处理，并在插件代码中直接使用这些变量（无需 import 这个文件），方便用户通过搭积木的方式开发整体风格一致的App。
`uni.scss`是一个特殊文件，在代码中无需 import 这个文件即可在scss代码中使用这里的样式变量。uni-app的编译器在webpack配置中特殊处理了这个 uni.scss，使得每个 scss 文件都被注入这个uni.scss，达到全局可用的效果。如果开发者想要less、stylus的全局使用，需要在vue.config.js中自行配置webpack策略。
主组件 App.vue `App.vue`是uni-app的主组件，所有页面都是在`App.vue`下进行切换的，是页面入口文件。但`App.vue`本身不是页面，这里不能编写视图元素。
这个文件的作用包括：调用应用生命周期函数、配置全局样式、配置全局的存储globalData
应用生命周期仅可在`App.vue`中监听，在页面监听无效。
入口文件 main.js main.js 是 uni-app 的入口文件，主要作用是初始化 vue 实例、定义全局组件、使用需要的插件，如vuex。
uniapp 开发规范及资源路径 1、开发规范约定
页面文件向导 Vue 单文件组件 (SFC) 规范
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ea26f0a51403527f886adfcfec2b389/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce9d886c35fd2c473523766aff8aa687/" rel="bookmark">
			Android简单适配9.0~12.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		适配6.0~8.0的可以看下这个： 适配Android6.0到8.0详细过程——小白教程 注意：10.0到12.0的都是些网上看到的资料，我就适配到10.0的文件存储，如有不对的，可以留言，我会查阅修改，谢谢0.0
Android 9.0适配： 限制明文传输：
当 SDK 版本大于 API 28 时，默认限制了 HTTP 请求，并出现相关日志
java.net.UnknownServiceException: CLEARTEXT communication to xxx not permitted by network security policy 该问题有两种解决方案：
1、在 AndroidManifest.xml 中 Application 节点添加如下代码
&lt;application android:usesCleartextTraffic="true"&gt; 2、在 res 目录新建 xml 目录，已建的跳过，在xml目录新建一个network_security_config.xml文件，然后在AndroidManifest.xml 中 Application 添加如下节点代码。
android:networkSecurityConfig="@xml/network_security_config" network_security_config.xml：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted="true" /&gt; &lt;/network-security-config&gt; 启动Activity：
在9.0 中，不能直接非 Activity 环境中（比如Service，Application）启动 Activity，否则会崩溃报错，
这类问题一般会在点击推送消息跳转页面这类场景，解决方法就是 Intent 中添加标志FLAG_ACTIVITY_NEW_TASK，
Intent intent = new Intent(this, TestActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); 适配刘海屏：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce9d886c35fd2c473523766aff8aa687/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eec2cc8b6d832288ab7a637d3fe4d2a/" rel="bookmark">
			思科路由器 密码设置和恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		密码设置和恢复 配置console密码配置明文特权模式密码配置密文特权模式密码本地管理和远程管理配置加密明文密码路由器密码恢复的思路、路由器密码的恢复 配置console密码 辅助端口密码（line aux）
Telnet密码（line vty） Router(config)#line vty 0 4
Router(config-line)#password yu
Router(config-line)#login 进入主控制台
Router(config)#line console 0
Router(config-line)#password console
Router(config-line)#login
配置明文特权模式密码 Router(config)#enable password yu
配置密文特权模式密码 Router(config)#enable secret jian
查看do show run
enable secret 5 1 1 1mERr$qU9qhCFFMRVMMaDZ3CkpZ0
同时配置明文密文时密文优先
本地管理和远程管理 本地console管理设备 可以选配console密码和enable密码
远程telnet/ssh管理设备，必须要配置远程密码和enable
配置加密明文密码 Router(config)#service password-encryption
路由器密码恢复的思路、 路由器启动过程不加载配置文件
修改配置寄存器的值为0X2142，启动不加载配置文件
路由器密码的恢复 启动过程中按CTRL+breack中段los加载
进入rom monitor模式 修改配置寄存器的值
正常启动后 用startap-config覆盖ranning config
修改密码并且修改配置寄存器的值 保存配置
在路由器开机30S内，按住Ctrl+Pause Break组合键,进入COMMON模式
rommon 1&gt;confreg 0x2142 /将寄存器值修改为0x2142,使开机从flash启动，跳过密码检验。1600、2600系列用 rommon 1&gt;O/R 0X2142
rommon 2&gt;reset
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2eec2cc8b6d832288ab7a637d3fe4d2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a18bee105e23f512b5da5a3f23a0f4e0/" rel="bookmark">
			博学谷前端 css兼容性简单总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. CSS兼容性 在网络中浏览器众多，因为不同浏览器使用内核及对W3C标准的支持不一样，各个浏览器对于页面的解释呈视也不尽相同。以及用户客户端的环境不同（如分辨率不同）造成的显示效果不能达到理想效果。最常见的问题就是网页元素位置混乱，错位。目前暂没有统一的能解决这样的工具.
最普遍的解决办法就是不断的在各浏览器间调试网页显示效果，通过对CSS样式控制以及通过脚本判断并赋予不同浏览器的解析标准。
总结： 所以为css兼容性，就是针对于不同浏览器我们书写不同的样式，从而达到统一的样式效果。
其实，css兼容性，主要针对于ie的旧版浏览器， 因为其他浏览器比较符合w3c规范。
2.1 属性hack 2.2 选择器hack （1）IE6(含)以下的版本识别 语法：* html 选择器 ｛...｝ 例如： html .content { width:300px; height:300px; border:1px dashed #0066FF; } （2）只有IE7识别 语法：*+html 选择器 {....} 例如： *+html .content { width:300px; height:300px; border:1px dashed #0066FF; } （3）媒体查询的写法
@media screen\9{body { background: red; }}	只对IE6/7生效 @media \0screen {body { background: red; }}	只对IE8生效 @media \0screen\,screen\9{body { background: blue; }}	只对IE6/7/8有效 @media screen\0 {body { background: green; }}	只对IE8/9/10有效 @media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background: orange; }}	只对IE10有效 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a18bee105e23f512b5da5a3f23a0f4e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6ec14cf505625d4f3fbc94d6446b17a/" rel="bookmark">
			ImportError: cannot import name ‘text_classification‘ from ‘torchtext.datasets‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述： 输入以下代码报错
from torchtext.datasets import text_classification ImportError: cannot import name ‘text_classification’ from ‘torchtext.datasets’(F:\Anaconda\envs\pytorch_hu\lib\site-packages\torchtext\datasets_init_.py)
解决方案： #注释掉from torchtext.datasets import text_classification #将文本分类数据集保存在根目录下的代码改为： train_dataset, test_dataset = torchtext.datasets.AG_NEWS(root='./data/ag_news_csv/', split=('train', 'test')) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c67a77d5c2e0969aae88a2a85362d174/" rel="bookmark">
			＜img src=“http://......“ ＞ url访问图片显示不出来问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法 标签内加入 &lt;meta name="referrer" content="no-referrer"&gt; 原因 referrer是一种引用策略，可以用来防止图片或视频被盗
原理：http 协议中，如果从一个网页跳到另一个网页，http 头字段里面会带个 Referrer。图片服务器通过检测 Referrer 是否来自规定域名，来进行防盗链。如果没有设置referrer，那就可以直接绕过防盗链机制，直接使用或盗取。
no-referrer：所有请求不发送 referrer
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c473b13e1266ddc32a913745f9b75e6/" rel="bookmark">
			c&#43;&#43;: ‘std::__cxx11::string abc::m_string’ is protected within this context
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误 ]oot@rhel-cleanmodules:~/mzhan017/test/c++[root@rhel-cleanmodules c++]# g++ string.cpp string.cpp: In function ‘int main()’: string.cpp:17:3: error: ‘std::__cxx11::string abc::m_string’ is protected within this context a.m_string="age"; ^~~~~~~~ string.cpp:6:9: note: declared protected here string m_string; 原因 成员 m_string 被protected 修饰；
解决方法 将使用m_string的函数，变成friend 函数；添加set 函数，给m_string 赋值。 代码 #include &lt;iostream&gt; using namespace std; int main(); class abc { //friend int main(); protected: string m_string; public: string get(); }; string abc::get() { return m_string; } int main() { abc a; a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c473b13e1266ddc32a913745f9b75e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a33ef69eaafcf0ecb6edb348ab1dea5f/" rel="bookmark">
			sentinel整合feign
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、未处理的时候返回二、操作步骤1.引入库2.编写代码服务提供者：服务消费者： 3.效果 三、处理思路①: 第一步②: 第二步③: 第三步④: 第四步⑤: 第五步 前言 sentinel整合feign, 主要处理限流熔断等异常的处理主要实现能够正常判断出是限流还是熔断等导致Spring Cloud Alibaba: 2.2.1.RELEASEsentinel: 1.7.1以及总结了一下我的处理思路 一、未处理的时候返回 二、操作步骤 1.引入库 &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 2.编写代码 服务提供者： package com.chaim.common.sentinel.provider; import com.alibaba.csp.sentinel.adapter.spring.webmvc.callback.BlockExceptionHandler; import com.alibaba.csp.sentinel.slots.block.BlockException; import com.alibaba.csp.sentinel.slots.block.authority.AuthorityException; import com.alibaba.csp.sentinel.slots.block.degrade.DegradeException; import com.alibaba.csp.sentinel.slots.block.flow.FlowException; import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowException; import com.alibaba.csp.sentinel.slots.system.SystemBlockException; import com.alibaba.fastjson.JSONObject; import com.chaim.common.core.util.CommonResult; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Component; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import static com.chaim.common.core.constant.HttpStatus.SentinelConstants.*; /** * 由于: * 服务提供者在经过sentinel限流等操作后, 返回数据不符合我们要求, 同时消费者无法区分是限流还是熔断等操作(FeignException.errorStatus) * 故: * 实现BlockExceptionHandler, 对返回数据进行重写, 从而符合我们的要求 * 注: * 返回状态码需为 STATUS, 否者消费者那边不会进行处理 * * @author Chaim * @date 2021/11/4 15:11 */ @Component @Slf4j public class MyBlockExceptionHandler implements BlockExceptionHandler { # 这个只是我这边的定义 public static final int STATUS = 606; @Override public void handle(HttpServletRequest httpServletRequest, HttpServletResponse response, BlockException ex) throws Exception { CommonResult commonResult = CommonResult.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a33ef69eaafcf0ecb6edb348ab1dea5f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/274/">«</a>
	<span class="pagination__item pagination__item--current">275/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/276/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>