<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03898b28be515368dcf799574378b5b8/" rel="bookmark">
			测试Mybatis中的数据库连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有时候，在使用jdbc连接数据库时发生bug，不知道是哪一步骤发生错误，可以简单的使用自己配置的方法来测试是否能成功连接，其实连接不上数据库时，主要问题还是在url这个问题上：
1、url需要配置时区,例如：serverTimezone=GMT%2B8
2、使用SSL加密协议，默认使用：useSSL=false
3、mysql版本和mybatis版本更新后，驱动改为：
driver-class-name: com.mysql.cj.jdbc.Driver 4、使用中文更新数据库为”？"时，需要调整mysql的编码格式，同时url中也需要明确编码：characterEncoding=utf-8
import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import java.sql.DriverManager; import java.sql.SQLException; @RunWith(SpringRunner.class) @SpringBootTest public class GulimallProductApplicationTests { @Test public void testRemoteJdbc() { String url = "jdbc:mysql://192.168.56.10:3306/database_table_name?serverTimezone=GMT%2B8&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8; String username = "root"; String password = "root"; try { Class.forName("com.mysql.cj.jdbc.Driver"); DriverManager.getConnection(url, username, password); System.out.println("连接远程数据库成功"); } catch (ClassNotFoundException | SQLException e) { System.out.println("连接远程数据库失败"); e.printStackTrace(); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa221d4645f0f5ac8833287a69bd7965/" rel="bookmark">
			vue高德地图关键词搜索，点击选点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初始化地图
const initMap = () =&gt; { AMapLoader.load({ key: '自己的key', // 后期需替换 version: '2.0', // 指定要加载的 JSAPI 的版本，缺省时默认为 1.4.15 plugins: ['AMap.Scale', 'AMap.MouseTool', 'AMap.ToolBar', 'AMap.PlaceSearch'], }) .then((AMap) =&gt; { AMap1.value = AMap // 初始化地图 map.value = new AMap.Map('map-location', { //map-location为地图容器的id viewMode: '3D', // 是否为3D地图模式 zoom: 17, // 初始化地图级别 center: [116.26755900, 39.91547100], //默认中心点 resizeEnable: true, }) // 创建引入搜索组件 const placeSearch = new AMap.PlaceSearch({ pageSize: 5, // 单页显示结果条数 pageIndex: 1, // 页码 // city: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa221d4645f0f5ac8833287a69bd7965/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9a297d1d98d247f7f121bc8c88b0bca/" rel="bookmark">
			Ansible 参数·命令说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
ansible 命令的执行过程
Inventory 参数说明
Script 模块 在远程主机上运行ansible服务器上的脚本(无需执行权限)
Copy 模块 复制ansible服务器主控端或远程的本机的文件到远程主机
Get_url 模块 功能: 用于将文件从http 等下载到被管理机节点上
Fetch 模块 功能：从远程主机提取文件至ansible的主控端
File 模块 功能：设置文件属性,创建文件,目录和软链接等
stat 模块 功能：检查文件或文件系统的状态
unarchive 模块 功能：解包解压缩（推荐）
Archive 模块 打包压缩保存在被管理节点
常见选项 Hostname 模块 管理主机名
Cron 模块 功能：计划任务
Yum 和 Apt 模块 功能：管理安装软件包
yum_repository 模块 功能: 此模块实现yum的仓库配置管理
Service 模块 此模块和sytemd功能相似,选项很多相同 管理服务 启动自启等
User 模块 管理用户
Group 模块功能：管理组
Lineinfile 模块 进行替换
Replace 模块 类似于sed命令 于正则进行匹配和替换，建议使用
SELinux 模块 该模块管理 SELInux （Linux 安全子系统）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9a297d1d98d247f7f121bc8c88b0bca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9123c4400e5307d0c7b31bb2478c0cf8/" rel="bookmark">
			Spring Boot 系列: 集成 Redis 数据库 分布式工具 Redisson 缓存 Spring Cache
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈 集成 Redis 数据库 分布式工具 Redisson 缓存 Spring Cache 🌈 Redis 客户端 🌮 Jedis Jedis 是 Java 实现的较轻量级的 Redis 客户端，简洁且基于 Socket 的操作方式，很高的性能。
Jedis 的 API 提供的比较全面 Redis 命令的支持。
使用阻塞的 I/O 操作，方法调用都是同步的，程序流需等到 socket 处理完 I/O 才能执行，不支持异步的操作。
是直接连接 Redis Server 的，在多线程环境是非线程安全的，需要通过连接池来操作 Jedis。
🌮 ​Lettuce Lettuce 可伸缩线程安全的 Redis 客户端。多个线程可以共享同一个 RedisConnection，利用 Netty NIO 框架高效地管理多个连接。
支持同步、异步、响应式编程，自动重新连接，主从，集群，哨兵，管道和编码器。
Spring Boot 2.x 开始， Lettuce 已取代 Jedis 成为 Spring Boot 默认的 Redis 客户端。
🌮 ​Redisson Redisson 是一个在 Redis 的基础上实现的 Java 驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的 Java 常用对象，还提供了许多分布式服务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9123c4400e5307d0c7b31bb2478c0cf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc45dad27a4a74a67edcbc3b35b17514/" rel="bookmark">
			Java 8 List 排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、List 排序的基本方法
二、List 按单个字段排序
三、List 按多个字段排序
四、List 按字段倒序排序
五、List 按字段排序并去重
六、List 按字段排序并分组
七、List 按字段排序并统计数量
八、总结
在 Java 8 中，我们可以使用 lambda 表达式和 Stream API 来对 List 进行排序。本篇文章将详细介绍如何使用 Java 8 对 List 按某字段排序。
一、List 排序的基本方法 在 Java 8 之前，我们通常使用 Collections.sort() 方法对 List 进行排序。该方法需要传入一个 List 和一个 Comparator 对象，用于指定排序规则。下面是一个示例：
List&lt;Person&gt; persons = new ArrayList&lt;&gt;(); // 添加元素 Comparator&lt;Person&gt; comparator = new Comparator&lt;Person&gt;() { @Override public int compare(Person o1, Person o2) { return o1.getName().compareTo(o2.getName()); } }; Collections.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc45dad27a4a74a67edcbc3b35b17514/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a12ffc046025d8d7c68acdecd0dfd44/" rel="bookmark">
			content-type的几种取值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Content-Type的几种取值
1. text/plain
2. text/html
3. application/json
4. application/xml
5. image/jpeg
6. image/png
7. audio/mpeg
8. video/mp4
9. multipart/form-data
10. application/x-www-form-urlencoded
注意事项
总结
Content-Type的几种取值 在Web开发中，我们经常会涉及到Content-Type这个HTTP头部信息。Content-Type是指在HTTP请求或响应中，用来标识发送端（客户端或服务器）发送的实体数据的类型。本文将详细介绍Content-Type的几种取值及其含义。
1. text/plain text/plain表示纯文本，即不包含任何格式的文本。它是Content-Type的默认值，如果没有指定Content-Type，则默认为text/plain。在浏览器中，这种类型的内容将直接显示在页面上，不会被解析为HTML。
示例：
HTTP/1.1 200 OK Content-Type: text/plain Hello, world! 2. text/html text/html表示HTML文档，即包含HTML标签的文本。在浏览器中，这种类型的内容将被解析为HTML，并且显示为网页。
示例：
HTTP/1.1 200 OK Content-Type: text/html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello, world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 3. application/json application/json表示JSON数据，即JavaScript对象表示法。在浏览器中，这种类型的内容将被解析为JSON，并且可以通过JavaScript进行处理。
示例：
HTTP/1.1 200 OK Content-Type: application/json { "name": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a12ffc046025d8d7c68acdecd0dfd44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15aa1c0cd33f05e6535c0971f18e2ca7/" rel="bookmark">
			golang工程组件篇:高性能RPC框架gRPC之Client连接池的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本文中，我将重点介绍如何实现gRPC框架中的Client连接池，以提高系统的可靠性和性能。
一、什么是gRPC框架？
gRPC是由谷歌公司开源的一款高性能、通用的RPC框架，基于HTTP/2协议标准设计。它支持多种编程语言（包括Go、Java、Python等）和平台，可以轻松构建分布式系统。与传统的RESTful API相比，gRPC具有更低的延迟和更高的吞吐量，适用于大规模微服务场景。
二、Client连接池
在gRPC框架中，每个客户端都需要与服务器建立一个TCP连接来发送请求和接收响应。这些连接需要消耗大量的系统资源，并且如果没有恰当地管理它们可能会导致内存泄漏或者其他问题。
为了解决这个问题，在gRPC框架中我们可以使用Client连接池来复用已经建立好的TCP连接。通过这种方式可以显著降低系统开销，并且提高系统对并发请求的处理能力。
下面我们来看一个例子：
pool, err := grpcpool.New(func() (*grpc.ClientConn, error) { return grpc.Dial("localhost:50051", grpc.WithInsecure()) }, 5, 10*time.Second) if err != nil { log.Fatalf("failed to create client pool: %v", err) } conn, err := pool.Get() if err != nil { log.Fatalf("failed to get connection from pool: %v", err) } client := pb.NewUserServiceClient(conn) ctx, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() _, err = client.GetUser(ctx, &amp;pb.GetUserRequest{Id: 123}) if err !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15aa1c0cd33f05e6535c0971f18e2ca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddcca91539e5bbac6f46633bfd389e04/" rel="bookmark">
			软考之信息安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.防火墙 包过滤防火墙对数据包的过滤依据 ：源IP地址、源端口号、目的IP地址
防火墙分为 内网、外网和 DMZ三个区域，受保护程序从高到低排序：内网、DMZ、外网
防火墙工作层次越高，工作效率越低，安全性越高
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8b9880c1f45b2899c10b7b09bcaf3fd/" rel="bookmark">
			error while loading shared libraries的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/weixin_42310458/article/details/125180410
当运行程序时会出现如下类似错误时：
error while loading shared libraries: libXXXXXXX.so.1: cannot open shared object file: No such file or directory
默认情况下，编译器只会使用/lib和/usr/lib这两个目录下的库文件，通常通过源码包进行安装时，如果不指定–prefix，会将库安装在/usr/local/lib目录下；当运行程序需要链接动态库时，提示找不到相关的.so库，会报错。也就是说，/usr/local/lib目录不在系统默认的库搜索目录中，需要将目录加进去。
在明确已经安装该库的情况下出现上述错误，可能是这个库目录并没有加入到该环境变量中，解决办法如下：
一. 更改配置文件 一般安装目录在：
/usr/local/lib
配置文件在：/etc/ld.so.conf文件中
将该目录加入到共享库的配置文件中
将动态库文件加入配置：执行vi /etc/ld.so.conf，在"include ld.so.conf.d/*.conf"下方增加"/usr/local/lib"。
保存后，在命令行终端执行：
/sbin/ldconfig -v
ldconfig
其作用是将文件/etc/ld.so.conf列出的路径下的库文件缓存到/etc/ld.so.cache以供使用，因此当安装完一些库文件，或者修改/etc/ld.so.conf增加了库的新搜索路径，需要运行一下ldconfig，使所有的库文件都被缓存到文件/etc/ld.so.cache中，如果没做，可能会找不到刚安装的库。
经过以上三个步骤，"error while loading shared libraries"的问题通常情况下就可以解决了。
如果运行应用程序时，还是提示以上错误，那就得确认一下是不是当前用户在库目录下是不是没有可读的权限。像我遇到的问题就是，从别的机子拷贝了一些.so动态库，然后用root权限放到了/usr/local/lib中（普通用户没有对该目录的写权限），然后切换用户运行程序时，始终提示找不到.so库，一直以为是我配置有问题，结果是因为权限原因，那些我用root权限增加到/usr/local/lib中的.so文件对于普通用户而言，是没有访问权限的，所以以普通用户运行程序，当需要链接.so库时，在/usr/local/lib中是查找不到的。
其实，对于由普通用户自己编译生成的.so库文件，比较好的做法是将这些.so库文件的路径用export指令加入到~/.bash_profile中的LD_LIBRARY_PATH变量中，LD_LIBRARY_PATH是程序运行需要链接.so库时会去查找的一个目录，~/.bash_profile是登陆或打开shell时会读取的文件，这样，每次用户登录时，都会把这些.so库文件的路径写入LD_LIBRARY_PATH，这样就可以正常地使用这些.so库文件了。
二. 修改配置文件 修改配置文件，如~/.bashrc或~/.bash_profile或/etc/profile。
其中，普通用户可直接修改~/.bashrc或~/.bash_profile，因此，该修改仅对当前用户有效。
root用户可修改/etc/profile，且对所有用户都有效。
下面以修改~/.bashrc文件为例：
vim ~/.bashrc 1 然后，在.bashrc文件中添加如下内容：
export LD_LIBRARY_PATH=/home/dabai/mpfr-4.0.2/lib:$LD_LIBRARY_PATH 1 保存并退出后，在终端输入如下命令，以使上述命令生效：
source ~/.bashrc 1 三. 临时解决方案 在终端使用export命令来配置环境变量，但仅限于当前终端；对于其他终端窗口则需要重新使用export命令才起作用。
export配置环境变量的格式为：
export LD_LIBRARY_PATH=/home/dabai/mpfr-4.0.2/lib:$LD_LIBRARY_PATH 1 其中，LD_LIBRARY_PATH是Linux环境变量名，该环境变量主要用于指定查找共享库（动态链接库）时除了默认路径之外的其他路径。
参考：
[1] https://www.cnblogs.com/codingmengmeng/p/7456539.html
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8b9880c1f45b2899c10b7b09bcaf3fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ca0e9c4bd83c97816d04a2e2c3cd85c/" rel="bookmark">
			配置阿里的yum源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 配置阿里源 第一步：下载阿里yum源 进入yum配置地址
cd /etc/yum.repo.d/ 下载阿里源
wget http://mirrors.aliyun.com/repo/Centos-7.repo 如果提示没有get命令，请先安装get。命令如下：
yum -y install wget 第二步：替换阿里yum源和epel源 # 1.备份本地yum源包 所在目录为：/etc/yum.repo.d/ mv CentOs-Base.repo CentOs-Base.repo.bak mv epel.repo epel.repo.bak # 2. 将阿里源包的名字改为Linux系统默认读取yum源的包名 mv Centos-7.repo CentOs-Base.repo # 3. 下载epel.repo的配置 wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 第三步：清除缓存，加载阿里yum源 # 清除缓存 yum clean all # 建立新缓存 yum makecache 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02664c99717dfd0c090f4f9ef43c61a4/" rel="bookmark">
			PX4无人机 - 键盘控制飞行代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PX4无人机 - 键盘控制飞行代码 仿真效果
实机效果
由于图片限制5M以内，只能上传一小段了，整段视频请点击链接 Pixhawk 6c | 无人机 | 键盘控制无人机 | Offboard模式
核心： 发布 mavros/setpoint_velocity/cmd_vel_unstamped 话题，控制x y z三个方向的速度
运行前先运行PX4自带仿真，例如
roslaunch px4 mavros_posix_sitl.launch 接着运行以下代码（根据WHEELTEC麦克纳姆轮小车的键盘控制代码改写）
注意： 空格：降落 5 ：开启offboard模式 6 ：解锁，准备起飞 7 ：起飞 控制顺序：
先按 5 开启offboard 模式
再按 6 解锁，会看到浆液开始转动
再按 7 起飞 （这里起飞后就不在 offboard 模式）
再按一次 5 切换到 offboard 模式（之后就可以通过键盘控制前后运动，左右旋转了）
控制运动键如下
i 键：前进
K 键：停止运动
, 键：后退
J 键：向左转
L键：向右转
R键：上升
F键：下降
运动速度调整键如下
常用键如下：
W 键：增加运动线速度
X 键：减少运动线速度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02664c99717dfd0c090f4f9ef43c61a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/716ea2d2264486db8efd68bcf4b6c826/" rel="bookmark">
			简单几步配置Mac下超好用的终端工具(iTerm2&#43;Oh My Zsh)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 iTerm2
iTerm2是一款Mac下的终端工具，相比系统自带的终端工具有很多特性。比如快速打开多个span窗口、粘贴历史复制内容、快捷键唤醒终端等等。具体可参考：https://www.iterm2.com/features.htmlOh My Zsh
Oh My Zsh是一个用于管理zsh配置的工具，提供了丰富的扩展功能。zsh相比bash有更丰富的功能，但其配置复杂，所以就有了Oh My Zsh Zsh兼容bash，是一款强大的虚拟终端，既是一个系统的虚拟终端，也可以作为一个脚本语言的交互解析器。
配置前后的对比
二、配置iTerm2 1. 安装 直接去官网下载安装即可。
2. 配置HotKey 安装之后打开iTerm2，然后打开设置面板
具体快捷键可以自行配置，我这里配置的是cmd+. 按下后即可呼出或隐藏iTerm2
3. 配置背景图片 双击这个地方即可选择图片
4. 其他配置 设置成默认终端软件：iTerm2-&gt;Make ITerm2 Default Term
三、配置Oh My Zsh 1. 安装oh my zsh curl 方式 sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" wget 方式 sh -c "$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" 2. 目录介绍 其实以上的安装，就是下载了oh my zsh的git仓库而已。进入~/.oh-my-zsh目录后，看看该目录的结构
$ ls .oh-my-zsh CODE_OF_CONDUCT.md README.md lib plugins tools CONTRIBUTING.md cache log templates LICENSE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/716ea2d2264486db8efd68bcf4b6c826/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96e543953b3f6b69edf94c57e3172556/" rel="bookmark">
			iframe嵌套，无法调取麦克风，摄像头权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 iframe嵌套页面无法调取麦克风，摄像头权限
1.首先检查确认页面是否能不能获取到权限
2.给iframe标签添加 allow="camera; microphone"属性
或者用js动态添加
var iframe: any = document.querySelector('#player-iframe') if (iframe) { console.log(iframe, '获得iframe标签') iframe.allow = 'microphone *;camera *' } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aac843b3e77a36060ac382665803b1ed/" rel="bookmark">
			Java中字符串与byte数组之间的转换方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java编程中，我们常常需要对字符串和byte数组进行转换。字符串一般是用来表示文本信息，而byte数组则是用来表示二进制数据，如图片、音频等。本文将详细介绍Java中字符串和byte数组之间的转换方法，包括将字符串转换为byte数组和将byte数组转换为字符串。
Java中字符串与byte数组之间的转换方法。
将字符串转换为byte数组
Java中有两种方式将字符串转换为byte数组：使用String的getBytes()方法和使用Charset类的encode()方法。
String的getBytes()方法 String的getBytes()方法可以将一个字符串转换为一个byte数组。该方法有多个重载形式，其中一个常用的形式是getBytes(String charsetName)，该方法将字符串按照指定的字符集编码为byte数组。
例如，将字符串\Hello, world!\转换为byte数组：
String str = \Hello, world!\byte[] bytes = str.getBytes(); getBytes()方法默认使用平台默认的字符集来编码字符串，如果需要指定字符集，可以使用getBytes(String charsetName)方法来指定字符集。例如，将字符串按照UTF-8字符集编码为byte数组：
String str = \Hello, world!\byte[] bytes = str.getBytes(\UTF-8\ Charset类的encode()方法 Charset类是Java提供的用于表示字符集的类。使用Charset类的encode()方法可以将一个字符串编码为指定字符集的byte数组。
例如，将字符串按照UTF-8字符集编码为byte数组：
String str = \Hello, world!\Charset charset = Charset.forName(\UTF-8\ByteBuffer byteBuffer = charset.encode(str); byte[] bytes = byteBuffer.array(); 注意，Charset类的encode()方法返回一个ByteBuffer对象，需要通过调用array()方法将其转换为byte数组。
将byte数组转换为字符串
Java中有两种方式将byte数组转换为字符串：使用String的构造方法和使用Charset类的decode()方法。
String的构造方法 String的构造方法可以将一个byte数组转换为一个字符串。该构造方法有多个重载形式，其中一个常用的形式是String(byte[] bytes)，该构造方法使用平台默认的字符集将byte数组解码为字符串。
例如，将byte数组转换为字符串：
byte[] bytes = {72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33}; String str = new String(bytes); 如果需要指定字符集，可以使用带有字符集参数的构造方法。例如，将byte数组按照UTF-8字符集解码为字符串：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aac843b3e77a36060ac382665803b1ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/024a789c9989ba2b52f3d5c380c922bd/" rel="bookmark">
			vue项目播放海康,大华等rtsp视频流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浏览器不能直接播放rtsp格式视频
需要将rtsp转为flv，然后再使用flv.js播放
1.rtsp转flv(需要node)
首先电脑需要下载 ffmpeg(将resp转为flv主要使用他)
官网：Download FFmpeg
下载完需要配置环境变量
配置好后 cmd 运行 ffmpeg -version 输出版本信息则成功
2.node代码
下载node依赖
npm i fluent-ffmpeg ws websocket-stream import WebSocket from 'ws' import webSocketStream from 'websocket-stream/stream' import ffmpeg from 'fluent-ffmpeg' // 建立WebSocket服务 const wss = new WebSocket.Server({ port: 8888, perMessageDeflate: false }) // 监听连接 wss.on('connection', handleConnection) // 连接时触发事件 function handleConnection (ws, req) { // 获取前端请求的流地址（前端websocket连接时后面带上流地址） const url = req.url.slice(1) // 传入连接的ws客户端 实例化一个流 const stream = webSocketStream(ws, { binary: true }) // 通过ffmpeg命令 对实时流进行格式转换 输出flv格式 const ffmpegCommand = ffmpeg(url) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/024a789c9989ba2b52f3d5c380c922bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e6771e743e27dc8136efcdd87a1f7c1/" rel="bookmark">
			Centos8:修改密码超详细超实用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 重启Centos8，出现以下内容时赶紧按几下“上下方向键PgUp和PgDn”（首先要确保鼠标在界面内），使其停留在这个界面，然后选中第一行。
2.按键盘上的“e”，进入编辑模式（edit select item）。利用上下左右键移动光标到如下图的“ro”处，将“ro”改为“rw init=/sysroot/bin/bash”。（注意：“\”是系统自动加的换行符，直接找到正确位置输入rw init=/sysroot/bin/bash就行）。
3. 同时按住Ctrl和X键，系统进入如下界面的emergency(紧急情况)模式。（可能需要稍微等待一会儿才能进入）。
4.1 输入“chroot /sysroot/”，回车，用chroot 命令把根目录切换到原始系统,也就是以 root 权限登录了原来的系统；
4.2 输入“LANG=en”，回车，将当前终端语言临时设置为英文（不会影响原来Centos8的语言设置）；
4.3 输入“passwd lc”，回车，表示要修改用户名为“lc”的用户的密码（注意：你的用户名是什么就填什么，比如你的用户名为“yasuo”，那么你就要输入“passwd yasuo”，如果没有设置用户名，就只用输入“passwd”）；
4.4：需要输入两次相同密码，输入密码时是不显示的，直接输入后回车就行（要是两遍密码输的不一样就会修改失败，需要重复步骤4.3）。
5.1 输入“touch /.autorelabel”，回车，使SELinux生效，使密码生效；
5.2 输入“exit”，回车，表示退出；
5.3 输入“reboot”，回车，进行重启，不需要做任何操作。
6. 不需要做任何操作，等待系统重启，可以需要几分钟或者需要一段时间。
7. 等待操作系统界面，再点击用户。
8. 输入重新设置的密码，点击“登录”，若报密码错误，那就重新来一篇，正常来说不会出现。
9.输入密码，成功进入。
10.点击左上角“活动”，弹出如下应用，点击右上角可以进行系统联网和相关操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a19abe629d5a7abba9a0f5bc6b87c02d/" rel="bookmark">
			【复现笔记】CosyPose
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 GitHub - ylabbe/cosypose: Code for "CosyPose: Consistent multi-view multi-object 6D pose estimation", ECCV 2020.
git clone --recurse-submodules https://github.com/ylabbe/cosypose.git cd cosypose conda env create -n cosypose --file environment.yaml conda activate cosypose git lfs pull python setup.py install 确保deps文件夹非空
报错
ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. failed CondaEnvException: Pip failed 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c84f79010a867cde63f5b79f70e9bbd8/" rel="bookmark">
			Java程序运行——在intellij IDEA 或命令提示符上运行java程序（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、IDEA
1.创建java New Project（项目）
2.创建package（包）
3.创建java class（类）
二、命令提示符
1.新建记事本、写入代码和另存为.java文件
2.打开命令提示符并进行相应操作
一、IDEA 1.创建java New Project（项目） 创建java项目（注意项目保存位置，尽量放在D盘,初学者最好不要乱改）
(1)第一种
1New Project中的 2是项目名称 3是项目保存的地址 4是创建
（2）第二种，左击Project就会出现第一种的New Project界面按上步骤进行
2.创建package（包） 在项目中的scr右击进入package（包）
3.创建java class（类） 写类名
二、命令提示符 （使用前提是已经安装jdk-17_windows-x64_bin.msi）或者其他版本
1.新建记事本、写入代码和另存为.java文件 在桌面（一般固定是c盘）或者其中一个盘中新建一个记事本（xxx.txt 其中xxx是类名），将代码写在记事本，注意格式和大小写，最后左击文件另存为。
文件名：改为xxx.java 保存类型：所有文件 编码：ANSI 最后保存得到一个xxx.java的文件
2.打开命令提示符并进行相应操作 联想电脑可以使用快捷键“Windows+R”，按回车键（Enter），进入命令提示符界面。
因为我将记事本保存在d盘中的study文件，所以
（1）先转入d盘（d：+回车 ）
（2）命令study文件（cd study+回车）
（3）查看study文件夹下的内容（dir+回车）
（4）使用编译器javac进行编译(javac xxx.java+回车)
（5）使用java解释器执行(java xxx+回车)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb3000ed0b96a8bfdf813a903cae4b6c/" rel="bookmark">
			【算法】算法学习四：图 | 广度优先搜索 | 深度优先搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是图？二、广度优先搜索三、什么是队列四、广度优先搜索的实现4.1 实现全部的代码4.2 队列的实现 五、深度优先搜索六、图的运行时间6.1 广度优先搜索6.2 深度优先搜索 一、什么是图？ 在计算机科学中，图（Graph）是由节点（Vertex）和连接节点的边（Edge）组成的一种数据结构。图是一种非常常见且广泛应用的数据结构，用于表示物理、社交、网络等各种关系和连接。
图可以用来描述各种实际问题，如社交网络中的用户关系、电子网络中的设备连接、道路交通网络中的路线等。在图中，节点表示实体，边表示节点之间的关系或连接。
图可以分为有向图（Directed Graph）和无向图（Undirected Graph）两种类型：
有向图：在有向图中，边是有方向性的，从一个节点指向另一个节点。例如，社交网络中的关注关系可以表示为有向图，其中节点表示用户，有向边表示关注关系。无向图：在无向图中，边没有方向性，可以在两个节点之间双向连接。例如，电子网络中的设备连接可以表示为无向图，其中节点表示设备，无向边表示设备之间的连接。 图还可以具有权重（Weighted Graph）的概念，权重表示节点之间的关联强度或边的代价。例如，道路交通网络中的路段可以使用权重表示距离或时间。
图的常见术语包括：
节点（Vertex）：图中的一个元素，也被称为顶点。节点可以表示实体、对象或特定概念。边（Edge）：连接图中两个节点的线段，表示节点之间的关系或连接。相邻节点（Adjacent Vertex）：对于一个节点，与它直接连接的节点称为相邻节点。路径（Path）：由一系列边连接的节点序列，表示从一个节点到另一个节点的通路。环（Cycle）：至少包含一条边的路径，其起点和终点相同。连通图（Connected Graph）：在无向图中，如果从一个节点到另一个节点存在一条路径，那么这个图被称为连通图。强连通图（Strongly Connected Graph）：在有向图中，如果从任意一个节点到达其他任意节点都存在路径，那么这个图被称为强连通图。 图的表示方法有多种，包括邻接矩阵（Adjacency Matrix）、邻接表（Adjacency List）等。
图论是研究图及其性质、算法和应用的数学分支，广泛应用于计算机科学、网络分析、优化问题等领域。图的算法包括图的遍历、最短路径、最小生成树、网络流等，这些算法在解决实际问题中起着重要的作用。
二、广度优先搜索 广度优先搜索（BFS，Breadth-First Search）是一种用于图形和树结构的遍历算法。它从根节点开始，逐层扩展搜索，先访问根节点的所有邻居节点，然后依次访问它们的邻居节点，以此类推，直到遍历完整个图形或树。
BFS使用队列数据结构来保存待访问的节点。具体的算法步骤如下：
创建一个空队列，并将根节点入队。如果队列不为空，则执行以下步骤： （1）出队一个节点，并访问该节点。
（2）将该节点的所有未访问过的邻居节点入队。
重复步骤2，直到队列为空。 BFS的特点是按照层级逐层扩展搜索，因此可以用来解决一些问题，例如：
针对无权图的最短路径问题：在无权图中，BFS可以找到从起点到目标节点的最短路径。判断图是否连通：通过BFS可以检测图是否连通，即是否存在从一个节点到达其他所有节点的路径。生成迷宫的最短路径：将迷宫抽象成图，利用BFS可以找到从起点到终点的最短路径。搜索状态空间：在某些问题中，状态可以表示为图的形式，BFS可以用于搜索状态空间，找到目标状态。 需要注意的是，BFS对于大规模图形可能会消耗较多的内存，因为需要保存所有已经访问过的节点。在实际应用中，可以根据具体情况选择合适的搜索算法。
三、什么是队列 队列（Queue）是一种常见的数据结构，遵循先进先出（FIFO，First-In-First-Out）的原则。队列可以看作是一种线性的、有限的序列，其中数据项按照添加的顺序排列，并且从队列的一端（称为队尾）添加数据项，从另一端（称为队首）移除数据项。
队列具有两个基本操作：
入队（enqueue）：将数据项添加到队尾。出队（dequeue）：从队首移除并返回数据项。 除了这两个基本操作，队列还可以支持其他常用的操作，如获取队首元素、判断队列是否为空以及获取队列的大小等。
队列的应用非常广泛，特别适用于需要按照顺序处理数据的场景，例如：
广度优先搜索（BFS）：在图或树的遍历中，利用队列可以按层级扩展搜索。任务调度：多个任务按照顺序加入队列，按照先后顺序依次执行。缓冲区管理：用于处理输入输出请求的缓冲区，保持请求的顺序。消息传递：在并发编程中，消息队列用于实现不同线程或进程之间的通信。 队列可以使用不同的数据结构来实现，常见的实现方式有两种：
数组实现：使用数组作为底层数据结构，通过维护队首和队尾的索引来完成入队和出队操作。数组实现的队列具有固定的容量，当队列已满时无法添加新的数据项。链表实现：使用链表作为底层数据结构，每个节点包含数据项以及指向下一个节点的引用。链表实现的队列可以动态地添加和移除节点，没有固定的容量限制。 队列的选择取决于具体的需求和场景。如果需要快速访问队首和队尾元素，而不需要频繁地插入和删除中间元素，数组实现可能更高效。如果需要频繁地插入和删除元素，并且不确定队列的最大容量，链表实现可能更适合。
总而言之，队列是一种简单而实用的数据结构，可以在很多应用中提供有序、按序处理数据的能力。
四、广度优先搜索的实现 4.1 实现全部的代码 下面是一个使用Python编写的广度优先搜索算法的示例代码，用于在无向图中找到从给定起点到目标节点的最短路径：
from collections import deque def bfs(graph, start, target): queue = deque() # 创建一个空队列 visited = set() # 记录已访问过的节点 queue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb3000ed0b96a8bfdf813a903cae4b6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09e420ad1455c7087c4299e7b0be042a/" rel="bookmark">
			mysql全量备份和增量备份方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、mysql全量备份1、修改 /etc/my.cnf文件添加如下内容2、测试任务脚本3、添加执行脚本4、天假定时任务 二、mysql增量备份1、修改 /etc/my.cnf文件添加如下内容2、重启mysql3、 添加执行脚本4、执行恢复4、测试是否生效 一、mysql全量备份 使用mysqldump 进行全量备份
1、修改 /etc/my.cnf文件添加如下内容 [mysqldump] user=your_backup_user_name password=your_backup_passwor 否则会报：Warning: Using a password on the command line interface can be insecure.
2、测试任务脚本 mysqldump -h localhost -uroot -p123456 --flush-logs --databases databaseName &gt; /home/sql/test.sql # databaseName 备份的数据库 # /home/sql/test.sql 备份的文件路径及文件 3、添加执行脚本 DB_HOST="localhost" DB_NAME="storage" #你要备份的数据库 BIN_DIR="/usr/bin" BCK_DIR="/usr/local/mysql" #备份文件存放的位置 DATE=`date +%F` mysqldump -h localhost --flush-logs --databases $DB_NAME &gt; $BCK_DIR/storage_$DATE.sql 4、天假定时任务 定时备份使用linux的 crontab 定时执行任务脚本
0 0 * * * sh /usr/your/path/mysqlBackup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09e420ad1455c7087c4299e7b0be042a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/267d8a88292015ffda016fa16224bebe/" rel="bookmark">
			tc:command not found与Error: Specified qdisc not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.故障描述Kylin 用tc做流量控制“tc:command not found”报错，发现系统最小安装的时候没有默认安装这相关组件
安装tc命令
yum -y install iproute-tc
2. 故障描述“Error: Specified qdisc not found” 在 Kylin 中，qdiscs 作为内核模块在名为 kernel-modules-extra 的包中提供
安装内核
yum -y install kernel-modules-extra
3、安装完要reboot重启
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70013cd42a5bad29ba067e0027789ef5/" rel="bookmark">
			设置代理ip——java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前一直说python爬虫使用代理ip，难道代理ip只能python使用吗？其实不然，代理ip除了python可以使用还有很多，下面我们来讲一下其中一种，Java怎么设置代理ip。
1、直接在JVM中设置
/*JVM设置代理*/ System.getProperties().setProperty("http.proxyHost", ip); System.getProperties().setProperty("http.proxyPort", "80"); 这种设置方式它的优点在于方便且比较快，并且因为它是JVM级别，可以作用到这一整个项目当中。有利则也有弊，那就是在代理ip失效的时候，会直接调用本地ip来进行工作。这种操作在很多场景中是极为致命的。
2、使用socketaddress网络去代理
/** * 通过代理对象连接 * @param address * @return */ SocketAddress addr = new InetSocketAddress(host, Integer.parseInt(port)); Proxy proxy = new Proxy(Proxy.Type.HTTP, addr); try{ URL url = new URL("http://www.xxx.com"); URLConnection conn = url.openConnection(proxy); conn.setConnectTimeout(5000); conn.setRequestProperty("User-Agent","Mozilla/4.0 (compatible; MSIE 7.0; NT 5.1; GTB5; .NET CLR 2.0.50727; CIBA)"); conn.getContent(); }catch (Exception e) { e.printStackTrace(); } 建立一个proxy对象，之后使用它去连接。在代理ip失效的时候，它会返回错误，这种方法的优点在于代理ip工作时出现错误，它可以及时中断这个工作而不是使用本地ip去继续工作。然它的弊端在于要为每一次连接创建一个对象，非常繁琐。
以上就是Java设置代理ip的方法了，当然，不局限于这两种。任何方法都有利弊，我们要权衡自身需求以及用途去选择合适自己的方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cc06712975de0d24a21b21be3da3a4c/" rel="bookmark">
			频谱分析基础-01. FFT频谱绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.背景
2.程序及原理分析
3.FFT绘制
4.问题
1.背景 关于频谱分析主要学习的过程分别是FS, FT, DTFT, DFT, DFS, FFT。实际工程中都是数字域进行数据处理，因此基本上都是对采样后的数据进行FFT(DFT)操作。对于一个时域信号，总是不自觉的想知道其频谱是何面貌。本节基于Matlab工具软件，绘制出一个时域信号的频谱图。
2.程序及原理分析 clear all; clc; close all;
fs= 128; %信号最大频率30Hz,采样率128Hz.
N=128; %采样深度点数为128，频率分辨率为fs/N=1Hz
t=(0:N-1)/fs; %离散时间，采样间隔为1/fs
y=1+cos(2*pi*30*t); %获取采样后的信号离散采样值
Y=fft(y,N)/N; %fft变换后，双边带乘以1/N，单边带2/N
freq=(0:N-1)*fs/N; %根据fs和N，计算出序列中数据点对应的频率
freq1=((-N/2):N/2-1)*fs/N; %数字域频谱关于fs呈现周期，将[fs/2 fs]搬移到[-fs/2 0]
Y1=fftshift(Y); %将FFT后的序列后半部分搬移到前面组成新序列
%作图
subplot (3,1,1)
stem(freq,abs(Y(1:N)),'k');
xlabel('频率（Hz）');ylabel('幅值');
set(gcf,'color','w');
subplot (3,1,2)
stem(freq1,abs(Y(1:N)),'k');
xlabel('频率（Hz）');ylabel('幅值');
set(gcf,'color','w');
subplot (3,1,3)
stem(freq1,abs(Y1(1:N)),'k');
xlabel('频率（Hz）');ylabel('幅值');
set(gcf,'color','w');
3.FFT绘制 图 1 采样后的波形y 图 2 Y=fft(y,N)/N;
图 3 Y1=fftshift(Y);
对Y进行fftshift()操作，就是把图1右半部分（序号65~128）放到左半部分前面（序号0~64），重新构成新的序列Y1。
备注：图1到图3过程中序列的横坐标没有量纲，仅仅是序列的序号。MATLAB中序列从1开始。
图 4标有频率刻度的频谱
4.问题 关于采样频率fs和采样深度如何选择？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f14b171f9271ff8d4a73f69bbd2231cd/" rel="bookmark">
			js 实现金额数字格式化（加元、万元、亿元单位）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、直接上代码 function changeMoney(num) { if (Number(num) &lt;= 1) return { num, unit: '元' }; var moneyUnits = ["元", "万元", "亿元", "万亿"] var dividend = 10000; var curentNum = num; //转换数字 var curentUnit = moneyUnits[0]; //转换单位 for (var i = 0; i &lt; 4; i++) { curentUnit = moneyUnits[i] if (strNumSize(curentNum) &lt; 5) { break; } curentNum = curentNum / dividend } var m = { num: 0, unit: "" } m.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f14b171f9271ff8d4a73f69bbd2231cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d70c17d68ab574045fa07f2a66076a31/" rel="bookmark">
			【零基础玩转yolov5】yolov5训练自己的数据集（CPU训练&#43;GPU训练）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、写在前面二、使用labelimg标记图片1.准备工作2.标记图片 三、 划分数据集以及配置文件修改1. 划分训练集、验证集、测试集2.XML格式转yolo_txt格式3.配置文件4.聚类获得先验框 四、使用CPU训练五、使用GPU训练1.开始训练2.重新下载pytorch 六、训练结果可视化 一、写在前面 博主也是最近开始玩yolov5的，甚至也是最近开始使用python的，很多东西都没有接触过，因此训练自己的数据集花了不少时间，所以想写篇博客记录一下，希望同样是零基础的小伙伴们可以更加轻松的上手。同时大家如果发现了错误和理解偏差，欢迎指正。
参考资料：
Yolov5训练自己的数据集（详细完整版）训练集、验证集、测试集的划分yolov5 训练结果解析关于yolov5的一些说明（txt文件、训练结果分析等） 本教程所安装版本：
pycahrm：2021.3.3Anconda：2022.05python：3.9yolov5：v6.2pytorch：CUDA 11.6 踩坑经历：
路径中就不要有短横杠-以及空格等等特殊字符，中文更不能要有❗。否则在之后训练时会出现各种路径找不到的问题😭使用pip等下载指令时最好不要挂VPN，否则可能会下载失败 在上一篇博客里 博客链接，我们完成了yolov5的安装和相关环境的配置，在这篇博客里，我们继续yolov5的学习，尝试训练自己的数据集
二、使用labelimg标记图片 1.准备工作 在yolov5目录下新建一个名为VOCData的文件夹
在VOCData文件夹下创建 Annotations 和 images 文件夹（【🎯易错】：images的文件名不建议修改，否则之后训练时容易出现No labels found的错误，原因见下）
[说明]：
Annotations 文件夹用于存放使用labelimg标记后的图片（XML格式）images 文件夹用于存放用于标记的图片
（【🎯易错】：images 文件夹下直接放图片，内部不要嵌套有文件夹，否则之后训练可能会出现 No label found 的错误，具体原因见下文中 xml_to_yolo.py文件的第67行） [为什么]：
在 yolov5 的 utils 文件夹打开 dataloaders.py文件后，搜索define，便可以找到这样的一段代码：
该段代码的作用是由images文件夹的地址直接推出labels文件夹的位置，所以我们存储图片的文件必须叫做images，同时labels文件必须和images文件必须在同一目录下（先不管labels具体是什么，有个基本的概念即可，接下来会细说）
2.标记图片 在cmd窗口下输入 labelimg 或者运行 labelimg.py 文件进入labelimg的可执行程序（注：如果是在虚拟环境下安装的labelimg，记得先激活虚拟环境）
分别设置需要标注图片的文件夹和存放标记结果的文件夹的地址
推荐设置自动保存
标记图片快捷键：w：标记 a：上一张图片 d：下一张图片
标注的时候尽可能贴近物体轮廓
不知道有没有和我一样开始只能标记方形框的，按住ctrl+shift+R就可以恢复创建矩形框
在Annotations文件夹下可以看到我们标记好的XML文件
三、 划分数据集以及配置文件修改 1. 划分训练集、验证集、测试集 在VOCData目录下创建程序 split_train_val.py 并运行以下代码。代码可以不做任何修改
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d70c17d68ab574045fa07f2a66076a31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/372cf8ea86ff968bfcb7cb6151223c62/" rel="bookmark">
			ubuntu20.4配置自动启动root用户并开启向日葵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.镜像装ubuntu20系统，配置root账户 新系统肯定是新非root用户登录的，在这个用户下输入，创建root用户密码
sudo passwd 1.输入当前用户密码
2.root用户密码
3.重复root用户密码。
2.设置可视化界面root可登录且自动登录 需要配置文件有：50-unity-greeter.comf; gdm-autologin; gam-password; .profile; custom.conf文件
这里可使用工具不限于vi，vim，gedit，或者直接文件目录直接修改（非root用户还是用命令行修改）
以vim为例：（为防止后续出错，将文件权限都打开，不开可能也不影响）
sudo chmod 777 /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf sudo chmod 777 /etc/pam.d/gdm-autologin sudo chmod 777 /etc/pam.d/gdm-password sudo chmod 777 /root/.profile sudo chmod 777 /etc/gdm3/custom.conf 编辑第一个文件
sudo vim /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf 在末尾添加（允许手动登录，允许root登录）
greeter-show-manual-login=true all-guest=false 编辑第二，三个文件（注释掉第二行红框的内容）
sudo vim /etc/pam.d/gdm-autologin sudo vim /etc/pam.d/gdm-password 编辑第四个文件
sudo vim /root/.profile 尾部加上
tty -s&amp;&amp;mesg n || true 编辑第五个文件，主要的就是把下面AutomaticLoginEnable，，AutomaticLogin，TimedLogin，AutomaticLogin设置对即可。
sudo vim /etc/gdm3/custom.conf TimedLoginEnable=false
AutomaticLoginEnable=true #设为true
TimedLogin=root #设成root
AutomaticLogin=root #设成root
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/372cf8ea86ff968bfcb7cb6151223c62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58169928cc0a1d2489e5d6315f3e9a9c/" rel="bookmark">
			GPT4限制被破解！ChatGPT实现超长文本处理的新方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
使用chat-gpt过程中有哪些痛点
1.无法理解人类情感和主观性 2.上下文丢失
3.约定被打断
那如何去解决这个痛点
Transformer（RMT）怎么去实现的
1.Transformer 模型
2.RMT模型
3.计算推理速率
4.渐进学习能力
总结
写到最后
大家好，我是AI大侠，AI领域的专业博主
前言 ChatGPT已经成为了一款备受欢迎的工具，它可以帮助用户解答问题、写代码、翻译，甚至可以通过它学习更多行业的知识。然而，博主在使用ChatGPT时会发现它还不够智能，有时候不能够完全理解用户的意思，答非所问，下面是博主在使用中遇到的痛点
使用chat-gpt过程中有哪些痛点 1.无法理解人类情感和主观性 尽管ChatGPT可以根据上下文理解用户的输入，但它仍然无法真正了解用户的意图，ChatGPT只能根据输入数据和算法进行分析和回答，无法真正理解人类的情感和主观性。这种局限性可能导致一些误解和问题。
2.上下文丢失 与ChatGPT进行对话时，它能够记住上下文，并在后续回答中考虑之前的内容。但是，博主在使用过程中经常会出现ChatGPT忘记之前的对话，这可能是由于单次请求中Token数量的限制或是ChatGPT会话长度的限制所导致的。
3.约定被打断 如果在会话中如果有很多其他的问答，ChatGPT可能会在继续下一步时忘记之前的约定，需要再次约定才会保持下去
那如何去解决这个痛点 这几个痛点我想使用过gpt的小伙伴都深有体会，那如何去解决这些问题呢。其实openAI已经给出了答案。
在发布gpt4的时候，最大的变化除了新数据模型的发布，还有一个重要的技术点更新：上下文token默认为8K 最长32k(约50页文本) 这代表可以可以处理更长的对话 以及 更深层次的语义分析。这也是gpt4更智能好用的原因。
但如果把这个token提升到200万个，那又会发生什么，
AI 模型使用的是非结构化文本，常用 Token 表示，以 GPT 模型为例，1000 个 Token 约等于 750 个英文单词
一篇在AI界热论的论文给出了答案，《Scaling Transformer to 1M tokens and beyond with RMT》它可以把Transformer 的 Token 上限扩展至 100 万，甚至更多。
Transformer（RMT）怎么去实现的 1.Transformer 模型 Transformer 是一种神经网络模型，是迄今为止最新和最强大的模型之一，常用于处理上下文学习语义含义。
我们来看看gpt4的上下文处理模型为什么只能达到8-32k，因为transformer 的可输入长度取决于内存大小，这意味着实现太长的token不现实，Transformer 存在一个关键问题，即其注意力操作的二次复杂度，这导致将大模型应用于处理较长序列变得越来越困难。然而，通过利用特殊的记忆 token 实现记忆机制的 Recurrent Memory Transformer（RMT）模型，有效上下文长度能够增长到百万级，这带来了新的发展前景。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58169928cc0a1d2489e5d6315f3e9a9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/261e8b5c8e393695745bfb258afd533a/" rel="bookmark">
			【CentOS】Linux CentOS7 配置LAMP环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、关闭防火墙
1.查看防火墙状态
2.关闭防火墙
3.永久关闭防火墙
二、安装Apache
1.安装Apache服务及扩展包
2.启动Apache服务
3.设置Apache服务开机自启动
4.查看apache是否安装成功
三、安装并配置MySQL
1.更新YUM源
2.安装MySQL
3.查看MySQL版本号
4.启动mysql
5.设置开机自启动
6.查看初始密码
7.配置MySQL的安全性
四、安装PHP
1.更新YUM源
2.安装PHP
3.查看PHP版本
4.在Apache网站根目录创建测试文件
5.重启Apache服务
6.运行
五、安装phpMyAdmin
1.创建phpMyAdmin数据存放目录
2.下载phpMyAdmin压缩包并解压
3.复制phpMyAdmin文件到准备好的数据存放目录
4.检查是否安装成功
其他问题
一、关闭防火墙 1.查看防火墙状态 systemctl status firewalld inactive 关闭状态active 开启状态 2.关闭防火墙 systemctl stop firewalld 3.永久关闭防火墙 systemctl disable firewalld 二、安装Apache 1.安装Apache服务及扩展包 yum -y install httpd httpd-manual mod_ssl mod_perl mod_auth_mysql 2.启动Apache服务 systemctl start httpd 3.设置Apache服务开机自启动 systemctl enable httpd 4.查看apache是否安装成功 在浏览器地址栏输入 http://ip地址，运行，出现如下页面即安装成功
三、安装并配置MySQL 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/261e8b5c8e393695745bfb258afd533a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/264475bf85122e4ae6e256bf53413c79/" rel="bookmark">
			Pycharm远程连接服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		远程连接 前提条件步骤新版旧版 前提条件 只有专业版才能远程连接服务器，可以通过教育邮箱申请专业版。
版本2020.1.3前后的pycharm远程连接有所不同。
步骤 1.点击Tools -&gt; Deployment -&gt; Configuration，进行远程连接配置。
2.点击“+”新增一个SFTP类型的连接。
点击后会弹出如下界面，随便取一个名字即可。
3.配置ssh连接，页面中有Connection（设置ssh连接参数）、Mappings（设置本地文件夹到服务器文件夹的映射）、Excluded Paths（不用管）三个面板，首先在Connection面板中点击下图中的“ ⋯ \cdots ⋯”，新建一个ssh连接。
点击“ ⋯ \cdots ⋯”后会出现下图页面，点击左上角的“+”新建一个ssh连接，按照下图指示输入对应的ip地址，端口号，用户名和密码即可，输入后可测试一下是否连接成功。
若是连接成功会弹出下图提示，若失败则检查一下上述信息是否输入错误，或者服务器是否处于开启状态。
4.然后进入Mappings面板设置文件夹映射，按照下图提示输入对应的本地代码文件夹和服务器上的文件夹。
5.点击Tools -&gt; Deployment -&gt; Options 修改文件保存方式。
Always是自动保存，Ctrl+S则是每次修改需要手动Ctrl+S才会更新到服务器，这个选择看个人喜好。
从这一步开始就有所不同了！！！
新版 截图来自2022.3.3版
6. 点击File -&gt; Settings -&gt; Python Interperter，点击“Add Interpreter” 选择“On SSH”
7. 在弹出的选项里面选择“Existing”，会出现之前已经我们配置好的服务器连接，直接选择，然后点下一步。
这里会出现无法选择下一步的问题：
会出现上面的问题，是因为在配置SSH Configurations时会默认勾选“Visible only for this project”，我们直接取消勾选就行：
然后，点击Next，会出现下图，继续Next
8. 然后需要找到你服务器上对应的Python的位置，激活你创建的服务器，然后输入“which python”：
9. 然后连接对应的环境，不要选择“Virtualenv Environment”中的“New”，会创建软连接将原有环境中的东西映射到其他地方，导致Python的位置出现问题，因为服务器中已配置好环境，所以可以选择“Virtualenv Environment”中的“Existing”或者直接选择“System Interpreter”：
10. 然后就OK啦
旧版 6.点击File -&gt; Settings -&gt; Python Interperter，添加远程环境。依次点击图中箭头所指，找到SSH Interpreter，再次输入相应的ip地址，用户名和端口号，然后点击Next。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/264475bf85122e4ae6e256bf53413c79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f60a5727e490640c76c495bbc0a43081/" rel="bookmark">
			【PHP&#43;微信小程序】 授权登陆，完整代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上图
实现流程：
1、授权登陆按钮和正文信息放到了同一个页面，未授权的时候显示登陆按钮，已授权的时候隐藏登陆按钮，显示正文信息，当然也可以授权和正文分开成两个页面，在授权页面的onload里判断是否已授权，若已授权就直接跳转正文的页面。这里只说授权按钮和正文在同一页面的情况。
2、在onload里先判断是否已授权，如果已授权，就隐藏授权登陆按钮，显示正文信息，如果没有授权，显示授权登陆按钮。
3、前端使用button的open-type="getUserInfo"来操作，点击授权按钮之后，“e”中会携带userInfo，用户的基本信息(和使用wx.getUserInfo接口获取的数据一样，所以我是在"e"里面直接取的，没有调用wx.getUserInfo接口)
4、使用wx.login接口获取登陆凭证code，使用code去后解密换取openid，传输code的时候带上第3步获取的用户信息一块发送给后台解密(也可以不携带，携带的目的是为了验证签名，这样安全一些，不验证也可以)
5、后台解密使用的是“auth.code2Session”接口，解密用到的SDK下载地址“服务端获取开放数据 | 微信开放文档”。
5、后台解密之后(后台语言用的是php)，会返回openid等敏感信息，就还可以把这些信息存起来了。
6、获取授权成功之后，再隐藏授权登陆按钮，显示正文信息。
7、如果用户点击拒绝授权，提示引导用户再次授权。
注意，要考虑到授权失败的情况
以下是详细代码
wxml
&lt;view wx:if="{{isHide}}"&gt; &lt;view wx:if="{{canIUse}}" &gt; &lt;view class='header'&gt; &lt;image src='/images/icon/wx_login.png'&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class='content'&gt; &lt;view&gt;申请获取以下权限&lt;/view&gt; &lt;text&gt;获得你的公开信息(昵称，头像等)&lt;/text&gt; &lt;/view&gt; &lt;button class='bottom' type='primary' open-type="getUserInfo" lang="zh_CN" bindgetuserinfo="bindGetUserInfo"&gt; 授权登录 &lt;/button&gt; &lt;/view&gt; &lt;view wx:else&gt;请升级微信版本&lt;/view&gt; &lt;/view&gt; &lt;view wx:else&gt; &lt;view&gt;我的首页内容&lt;/view&gt; &lt;/view&gt; wxss
.header { margin: 90rpx 0 90rpx 50rpx; border-bottom: 1px solid #ccc; text-align: center; width: 650rpx; height: 300rpx; line-height: 450rpx; } .header image { width: 200rpx; height: 200rpx; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f60a5727e490640c76c495bbc0a43081/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86ae8c40fc48314c9033a66e3b8bba47/" rel="bookmark">
			《解构领域驱动设计》- DDD 设计统一过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		领域驱动设计的核心是模型驱动设计，而模型驱动设计的核心又是领域模型，领域模型必须在统一语言的指导下获得。领域模型又可进一步细分为核心子领域、通用子领域和支撑子域。
系统上下文、限界上下文、分层架构和聚合都属于领域驱动设计的边界控制手段，他们的区别在于对业务划分的粒度和维度不同。
领域驱动设计统一过程 “人类是通过在问题空间中寻找解决方案来解决问题的”
同理，软件系统的构建实则是对问题空间的求解，以获得构成解空间的设计方案。
问题空间强调通过统一语言来描述需求问题，利用核心子领域、通用子领域和支撑子领域来分解问题空间。
解空间中，这些子领域将被映射到限界上下文，可以根据子领域类型的不同为限界上下文选择不同的建模方式。比如核心子领域可以选用领域建模，而支撑子领域的限界上下文可以选择事务脚本模式
注意：由此可见，子领域是问题空间中的概念，在拆分问题时，对问题进行分级；限界上下文是解空间中的概念，它跟问题空间中的子领域具有映射关系，可以基于子领域推导出限界上下文来
在限界上下文中要通过分层架构将领域模型独立出来，其目的是实现关注点分离，比如通过分层架构将技术与业务分离，保持两者的变化仅在其所在的层次内传递，防止两者复杂度的交织引发的更大范围的复杂度。
领域驱动设计战略设计阶段的核心模式是限界上下文，指导架构设计的核心模式是分层架构，前者决定了业务架构和应用架构，后者决定了技术架构。
领域驱动设计的核心诉求是让业务架构和应用架构形成绑定关系，同时降低与技术架构的耦合，使得在面对需求变化时，应用架构能够适应业务架构的调整，并隔离业务复杂度与技术复杂度，满足架构的演进性。
完整的领域驱动设计过程划分为三个重要的阶段：
1）全局分析阶段：对现实世界中问题的分析
2）架构映射阶段：解决现实世界与软件解决方案的桥接问题
3）领域建模阶段：对软件解决方案内部进行进一步的分析建模
全局分析阶段 目标：通过可视化的手段完成对问题空间的探索与分析
任务：通过执行价值需求分析和业务需求分析活动，深入剖析问题空间
活动：价值需求分析、业务需求分析
产物：全局分析规格说明书
价值需求分析 价值需求分析 利益相关者、系统愿景和系统范围共同组成了目标系统的价值需求，分属于 5W 模型中的 Who、Why 和 Where。
首先需要识别出目标系统的利益相关者（Who）
然后通过统一利益相关者的业务目标，明确目标系统的界限和方向
最终做到明确系统愿景（Why）和识别系统范围（Where）
模式：统一语言
方法：商业模式画布
利益相关者
支持者，比如组织、部门、员工和上游第三方合作伙伴
受益者，比如用户、下游第三方
注：上游指的是提供价值方，下游指消费价值方。
业务需求分析 价值需求分析指导业务需求分析。
业务需求由动态业务流程和静态的业务场景、业务服务组成，两者的结合依靠业务场景按照时间点和业务目标对业务流程进行拆分。
业务需求分析阶段可分三个层级对业务需求进行逐级的问题拆解，如下。完成问题拆解后，即可梳理出核心子领域、通用子领域和支撑子领域。
第一层：业务流程
第二层：业务场景
第三层：业务服务
模式：统一语言、核心子领域、通用子领域、支撑子领域
可视化方法：业务流程图、服务蓝图、业务服务图、事件风暴
业务流程 第一层级，在业务目标指导下梳理出提供业务价值的动态业务流程。属于 5W 模型中的 When。
业务流程的起点往往由一个角色想目标系统发起服务请求，而要完成整个流程，则需要多个角色共同参与协作。业务流程的特点是：1）具有时间属性 2）多角色参与 3）输出业务价值
识别业务流程的两个关键点是：完整和边界。完整是指要具有端到端的完整协作过程，体现一个完整的业务价值；边界仍然是从业务价值层面确定业务的范畴。
可视化方案：业务流程图、服务蓝图
业务场景 场景就是角色之间为了实现共同的业务目标进行互动的时空背景，通过角色在特定时间、空间内执行的活动来推动情景的发展，形成角色与目标系统之间的体验与互动
第二层级，按照时间对业务流程进行切分，划分出每个时间阶段的业务场景，每个业务场景时可以由多个角色参与的。
业务流程与业务场景的区别与联系
一个动态的业务流程是由一到多个静态的业务场景构成的，业务流程是端到端的完整协作过程，业务场景则是在业务目标的指导下在时间维度对业务流程的纵向切分。
可视化方案：用例图，例如：
业务服务 第三个层级，每个角色在业务场景下的一次功能性交互形成业务服务。业务服务是全局分析阶段的基本业务单元。属于 5W 模型中的 What。1）提供了目标系统的核心价值，满足了利益相关者的价值需求的业务服务，归入核心子领域 2）属于业务需求一部分，但是横向支撑了多个领域服务，不具有明显的个性特征的业务服务，则归入通用子领域 3）起支撑和辅助价值的业务服务，归入支撑子领域
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86ae8c40fc48314c9033a66e3b8bba47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c72c4f63cbf939c55363465e529d3c5/" rel="bookmark">
			JVM系列-第12章-垃圾回收器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		垃圾回收器 GC 分类与性能指标 垃圾回收器概述 垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。
由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。
从不同角度分析垃圾收集器，可以将GC分为不同的类型。
Java不同版本新特性
语法层面：Lambda表达式、switch、自动拆箱装箱、enum、泛型API层面：Stream API、新的日期时间、Optional、String、集合框架底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池等 垃圾回收器分类 按线程数分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。
串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。 在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器 和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。 按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。
并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。
独占式垃圾回收器（Stop the World）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。
按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。
压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。再分配对象空间使用指针碰撞
非压缩式的垃圾回收器不进行这步操作，分配对象空间使用空闲列表
按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。
评估 GC 的性能指标 指标
吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）
垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。
暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。
收集频率：相对于应用程序的执行，收集操作发生的频率。
内存占用：Java堆区所占的内存大小。
快速：一个对象从诞生到被回收所经历的时间。
吞吐量、暂停时间、内存占用这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。
这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。
简单来说，主要抓住两点：
吞吐量暂停时间 吞吐量（throughput）
吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间）
比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。 这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的
吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2=0.4
暂停时间（pause time）
“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态。
例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的 暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1 + 0.1+ 0.1+ 0.1=0.5，但是总的GC时间可能会长
吞吐量 vs 暂停时间
高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。
低暂停时间（低延迟）较好，是从最终用户的角度来看，不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有较低的暂停时间是非常重要的，特别是对于一个交互式应用程序（就是和用户交互比较多的场景）。
不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。
因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。 在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。
现在标准：在最大吞吐量优先的情况下，降低停顿时间
不同的垃圾回收器概述 垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。那么，Java常见的垃圾收集器有哪些？ 垃圾收集器发展史 有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c72c4f63cbf939c55363465e529d3c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4688f9d87c489e22b9371256d186bbf9/" rel="bookmark">
			Java导出Excel的核心代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发程序中，系统内经常为了用户数据编写方便，同时大批量进行数据的整理而进行的Excel工具的导出导入的工作。
以下是在开发程序过程中，经过验证的导出Excel的核心代码逻辑，通过使用EasyExcel来快速达到导出的目的。
{ ServletOutputStream out = response.getOutputStream(); ExcelWriter excelWriter1 = EasyExcel.write(out).registerConverter(new LocalDateTimeConverter()).build(); //设置head信息 try { WriteSheet writeSheet1 = EasyExcel.writerSheet(0, "页签的名字").head(heads).build(); excelWriter1.write(dataStr, writeSheet1); response.setCharacterEncoding("utf-8"); response.setContentType("application/vnd.ms-excel;charset=utf-8"); response.setHeader("Content-Disposition", "attachment;filename=" + new String((fileName).getBytes(), "ISO8859-1")); out.flush(); }catch (Exception e) { e.printStackTrace(); }finally { if (excelWriter1 != null) { excelWriter1.finish(); } } } 注意: 关于head的设置，工具类中提供了2种载入的方式，上述代码使用的是List&lt;List&lt;String&gt;&gt;的方式，同时它还支持class的方式。
相关表格样式的调整未在上述代码中指出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/516ee4662d59234bb3225848b535f794/" rel="bookmark">
			pytorch学习笔记——timm库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当使用ChatGPT帮我们工作的时候，确实很大一部分人就会失业，当然也有很大一部分人收益其中。我今天继续使用其帮我了解新的内容，也就是timm库。毫不夸张的说，Chat GPT比百分之80的博客讲的更清楚更好，仅次于源码。
当提到计算机视觉的深度学习框架时，PyTorch无疑是最受欢迎的选择之一。PyTorch拥有强大的自动求导功能、易于使用的API和广泛的社区支持。而针对计算机视觉任务，timm库则是一个值得推荐的PyTorch扩展库。timm（Timm is a model repository for PyTorch）库提供了预训练模型、模型构建块和模型训练的实用工具。timm库可以帮助开发者快速构建和训练深度学习模型，同时支持多种图像分类、分割和检测任务，特别是结合torch和torchvision的使用，对你训练模型，事半功倍。
本文将介绍timm库的基本用法，并使用timm库训练一个图像分类模型作为示例。本文将假设读者已经对PyTorch和计算机视觉的基本概念有一定的了解，下面详细说一下。
首先简单梳理一下timm的用途：
图像分类（Image Classification）：Timm库包含了许多用于图像分类的预训练模型，如ResNet、VGG、EfficientNet等。你可以使用这些模型进行图像分类任务，如图像分类、图像回归等。
使用EfficientNet模型进行图像分类：
model = timm.create_model('efficientnet_b0', pretrained=True) 使用ResNet模型进行图像分类：
model = timm.create_model('resnet50', pretrained=True) 目标检测（Object Detection）：Timm库提供了一系列在目标检测和物体识别任务上表现优秀的模型，如EfficientDet、YOLO、RetinaNet等。你可以使用这些模型进行目标检测和物体识别任务。
使用EfficientDet模型进行目标检测：
model = timm.create_model('efficientdet_d0', pretrained=True) 使用YOLOv5模型进行目标检测：
model = timm.create_model('yolov5s', pretrained=True) 图像分割（Image Segmentation）：Timm库支持各种图像分割模型，如DeepLab、U-Net、PSPNet等。你可以使用这些模型进行图像分割任务，例如语义分割、实例分割等。
使用DeepLabV3模型进行语义分割：
model = timm.create_model('deeplabv3_resnet50', pretrained=True) 使用PSPNet模型进行图像分割：
model = timm.create_model('pspnet_resnet50', pretrained=True) 模型微调和迁移学习：Timm库提供了方便的函数和工具，使你能够轻松地微调和迁移学习预训练模型。你可以使用Timm库中的模型作为基础模型，并在自己的数据集上进行微调。
使用预训练的ResNet模型进行微调： model = timm.create_model('resnet50', pretrained=True) # 在新数据集上进行微调 # ... 模型评估和验证：Timm库提供了各种评估指标和工具，用于模型的性能评估和验证。你可以使用这些工具来评估模型在不同任务上的性能，并进行模型选择和比较。
使用Timm库提供的评估工具进行模型性能评估 总之，Timm库是一个功能齐全的模型库，涵盖了图像分类、目标检测、图像分割等多个计算机视觉任务，并提供了方便的接口和实用工具，简化了模型开发和实验过程。你可以根据具体的需求使用Timm库中的不同模型和功能来完成相应的任务。
下面来简单学习一下。
1，安装timm库 timm库可以通过pip命令进行安装：
1
pip install timm
安装完成后，我们在Python脚本或者Jupyter Notebook中导入timm库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/516ee4662d59234bb3225848b535f794/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0db5a230f54a86e679c6fd70d341ab66/" rel="bookmark">
			C&#43;&#43;去除数组中的重复元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先使用sort函数对数组进行排序，再使用unique函数得到数组去重后的结果。unique函数返回一个迭代器，指向最后一个不重复元素之后的下一个位置。下面代码中的n是，数组去重后，元素的数目。
void get_unique_elements(const std::vector&lt;int&gt; &amp;input, std::vector&lt;int&gt; &amp;output) { std::vector&lt;int&gt; temp; temp.assign(input.begin(), input.end()); for (auto &amp;e : temp) printf("%d ", e); printf("\n"); std::sort(temp.begin(), temp.end()); for (auto &amp;e : temp) printf("%d ", e); printf("\n"); int n = std::unique(temp.begin(), temp.end()) - temp.begin(); for (auto &amp;e : temp) printf("%d ", e); printf("\n"); printf("n = %d\n", n); for (int i = 0; i &lt; n; ++i) output.push_back(temp[i]); for (auto &amp;e : output) printf("%d ", e); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0db5a230f54a86e679c6fd70d341ab66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/155f88dcf19070eaf2c3803363fbdb69/" rel="bookmark">
			PowerShell系列（四）：PowerShell进入交互环境的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、Win键+X 方式
2、使用微软自带的搜索功能
3、命令行运行方式
4、命令行窗口方式
5、使用第三方命令行软件（Terminal）开启PowerShell环境
6、PowerShell交互环境执行脚本的一些优势
7、小技巧
今天继续给大家讲解PowerShell相关的知识，本次给大家讲解基于Windows系统环境进入PowerShell交互环境的几种方式。希望对大家啊学习PowerShell能提供一些帮助！
1、Win键+X 方式 同时摁下Win键+X打开如下菜单，然后可以看到进入交互环境的两个菜单，一个是普通用户方式、一个是管理员方式。然后点击相应的菜单就可以打开交互环境了。
2、使用微软自带的搜索功能 点击放大镜，然后输入power，就可以匹配到powershell的应用，然后直接打开即可。
3、命令行运行方式 Win键+R 打开命令行窗口，然后输入“powershell” 点击确定就可以打开了
4、命令行窗口方式 首先打开命令行窗口，然后输入“powershell”,就会切换为PowerShell交互环境。
如果在输入cmd的话可以再次切换为cmd交互环境。
注意：使用这种方式不会直接打开PowerShell的蓝色窗口，只是在当前命令行窗口切换为PowerShell的交互环境。然后通过任务管理器可以看出，PowerShell的进程属于Cmd衍生出来的进程。
5、使用第三方命令行软件（Terminal）开启PowerShell环境 大家可以下载安装Terminal第三方命令行软件来更好的使用PowerShell。它的界面比默认的界面功能更加丰富、体验更好一些。大家可以尝试一下。
下载地址：GitHub - microsoft/terminal: The new Windows Terminal and the original Windows console host, all in the same place!
6、PowerShell交互环境执行脚本的一些优势 控制台属于轻量级、可以快速加载，对系统资源消耗较少可以实现任务的批量化操作除了Net，不需要加载别的资源 7、小技巧 大家如果使用PowerShell比较频繁的话可以固定到任务栏，后面直接点击任务栏当中对应的图标就可以打开了。
以上的全部的分享内容了，大家如果使用过程有问题的话，欢迎互相沟通较！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c3d580222258fc7420bf19a4bbb14f7/" rel="bookmark">
			git如何清除已提交的内容？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git 提供了多种方式来清除已提交的内容，但这通常需要对 Git 有一定的理解，并且清除已提交的内容可能会对你的仓库和其他协作者产生影响。所以在清除已提交的内容之前，请一定要谨慎。
使用 git reset 命令。这个命令会将 HEAD 指针移动到指定的提交。例如，如果你想撤销最近的一次提交，你可以执行：
git reset HEAD^ 这个命令将会保留工作区的修改。如果你不想保留这些修改，可以使用 --hard 选项：
git reset --hard HEAD^ HEAD^ 表示当前 HEAD 的父提交，也就是最近的一次提交。
使用 git revert 命令。这个命令会创建一个新的提交，这个新的提交会撤销指定的提交。例如，如果你想撤销最近的一次提交，你可以执行：
git revert HEAD 这个命令不会改变你的提交历史，只会添加一个新的提交。这是一种更安全的方式，特别是当你在协作环境中工作时。
如果你想彻底从你的提交历史中删除一些内容，你可以使用 git rebase 命令。但是这个命令比较复杂，并且可能会对你的提交历史造成不可逆的影响。如果你确定需要这样做，请在使用 git rebase 命令之前详细阅读相关的文档，并确保你明白这个命令的影响。
请注意，在推送到远程仓库之后使用以上命令来清除已提交的内容需要谨慎，因为这可能会影响其他协作者。如果你已经推送了你的提交，最好与你的团队协商后再决定如何清除已提交的内容。
怎么清除git已提交的某个文件？ 清除已提交到 Git 的某个文件可以通过几种方式实现，具体取决于你想要达到的目标：
你希望在最新的提交中删除文件：
如果你只是希望在新的提交中删除文件，并保留文件的历史记录，你可以简单地使用 git rm 命令：
git rm filename git commit -m "Removed filename" 这样，文件在新的提交中被删除，但在历史提交中仍然存在。
你想要完全从历史记录中删除文件：
如果你想要从历史记录中彻底删除一个文件（例如，文件包含敏感信息），你可以使用 git filter-branch 或 filter-repo（推荐）命令。这两个命令会重写你的提交历史，应谨慎使用。
使用 git filter-branch 命令：
git filter-branch --force --index-filter \ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c3d580222258fc7420bf19a4bbb14f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/603d46a8bb95531f80afc5561f767006/" rel="bookmark">
			【Android入门到项目实战-- 11.5】—— bmob后端云数据库批量获取表中数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图，下面实现批量获取Home表中的所有行的字段。
准备工作 引入依赖
implementation 'io.github.bmob:android-sdk:3.8.21' implementation 'io.reactivex.rxjava2:rxjava:2.2.8' implementation 'io.reactivex.rxjava2:rxandroid:2.1.1' implementation 'com.squareup.okhttp3:okhttp:4.8.1' implementation 'com.squareup.okio:okio:2.2.2' implementation 'com.google.code.gson:gson:2.8.5' AndroidManifest.xml文件添加:
申请权限和创建provider
&lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;!--获取GSM（2g）、WCDMA（联通3g）等网络状态的信息 --&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;!--获取wifi网络状态的信息 --&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt; &lt;!--保持CPU 运转，屏幕和键盘灯有可能是关闭的,用于文件上传和下载 --&gt; &lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt; &lt;!--获取sd卡写的权限，用于文件上传和下载--&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; &lt;!--允许读取手机状态 用于创建BmobInstallation--&gt; &lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt; &lt;application .... &lt;activity .... &lt;provider android:name="cn.bmob.v3.util.BmobContentProvider" android:authorities="com.example.ufcfans.BmobContentProvider"&gt; &lt;/provider&gt; &lt;/application&gt; 创建表类 需要创建和数据表对应的类，注意类名必须和数据表名相同，变量名必须和表中的字段名相同。
public class Home extends BmobObject { private String text; private String video; private Integer lookview; private Integer comment; private Integer like; public String getText() { return text; } public void setText(String text) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/603d46a8bb95531f80afc5561f767006/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84a8e6562bea2f808dc1243e7338ba0a/" rel="bookmark">
			MobileNets V2神经网络简介与代码实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.介绍 从MobileNet V2的名字，我们就知道，它是对基于MobileNet V1 而进行改进的，同样也是Google针对手机的智能型嵌入式设备提出的一种轻量级深度卷积神经网络，该网络的核心为深度可分离卷积和颠倒残差块。
2.模型结构
可分离卷积参见我上一篇博客文章MobileNets V1神经网络简介与代码实战_天竺街潜水的八角的博客-CSDN博客，这一篇文章重点介绍一下颠倒残差块(Inverted Residual Block), MobileNet V1没有利用残差网络，而残差网络一般能使网络的表现更好，因此，MobileNet V2加入了残差网络。下图左边为原始残差块，先用1x1降通道过ReLU，再3x3空间卷积过ReLU，再用1x1卷积过ReLU恢复通道，并和输入相加。之所以要1x1卷积降通道，是为了减少计算量，不然中间的3x3空间卷积计算量太大。所以Residual block是沙漏形，两边宽中间窄。但是，现在我们中间的3x3卷积变为了Depthwise的了，计算量很少了，所以通道可以多一点，效果更好，所以通过1x1卷积先提升通道数，再Depthwise的3x3空间卷积，再用1x1卷积降低维度。两端的通道数都很小，所以1x1卷积升通道或降通道计算量都并不大，而中间通道数虽然多，但是Depthwise 的卷积计算量也不大。作者称之为Inverted Residual Block，两边窄中间宽，像柳叶，较小的计算量得到较好的性能。
3.模型特点
MobileNet V2相对于MobileNets V1有以下两个特点：
1. Inverted Residual Block，利用较小的计算量得到比较好的性能表现。
2. 最后输出的 ReLU6 （MobileNets V1中为了满足移动端设备 float16/int8 的低精度）去掉，直接线性输出，提高模型的表现效果（Xception已经实验证明了 Depthwise 卷积后再加ReLU 效果会变差）
4.代码实现 pytorch
class BaseBlock(nn.Module): alpha = 1 def __init__(self, input_channel, output_channel, t = 6, downsample = False): """ t: expansion factor, t*input_channel is channel of expansion layer alpha: width multiplier, to get thinner models rho: resolution multiplier, to get reduced representation "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84a8e6562bea2f808dc1243e7338ba0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1eab5d1170ca118145952517c5a5f86/" rel="bookmark">
			最强chrome、edge的广告拦截插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最强chrome、edge的广告拦截插件 对于浏览器的广告是非常烦人的，尤其是使用百度搜索引擎时，总会在右侧出现百度热搜这样的东西，有时不经意间就会被某些热搜吸引。本来想搜索一些内容，结果被热搜等耗费了大量时间。
有很多人推荐aDBlock这款插件，这款插件个人觉得不太理想。对于百度热搜这样的拦截虽然有手动设置拦截的功能，但是再次启动新的界面时，还是会再次出现。
这里我推荐AdGuard 广告拦截器 。这款是我目前用过最好用的广告拦截插件。它可以有效的屏蔽各种广告，还可以自己定制拦截。
比如我们在百度搜索
可以看到右边百度热搜真的很讨厌。下面使用该插件屏蔽：
首先安装插件
对于edge浏览器：首先点击右上角三个点，点击扩展、接着点击打开Microsoft Edge加载项，然后搜索栏输入adguard，点击获取。对于chrome浏览器：首先点击右上角三个点，点击更多工具、然后选择扩展程序；进入到扩展程序界面后，点击左上方三条横杠，左下方点击打开chrome应用商店，搜索栏搜索adguard，选择插件，然后点击添加至chrome。 点击插件，选择拦截此网站上的广告，
然后弹出需要拦截的元素
我们用鼠标托选需要屏蔽的内容，这里我选择百度热搜所有的内容（注意要托选所有的内容）
我们选择好后还可以进行调整，还可以选择高级选项选择是否应用到所有的网站上等
设置好后，点击拦截，我们重启浏览器在搜索一些其他内容看看，是否生效？可以看到热搜成功被拦截了！庆祝！
B站的广告也可以拦截
假如有一天你就想看看广告、看看热搜，也可以恢复
首先还是点击插件点击移除用于此网页上所有的用户规则 算了，你都想看广告了，更简单的方法，直接把插件卸载即可！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a14fb45c805c2721580096585e8f2145/" rel="bookmark">
			Vue3组件之间的通信方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		props 实现了父组件给子组件传值
父组件 &lt;template&gt; &lt;div class="box"&gt; &lt;h1&gt;父组件&lt;/h1&gt; &lt;hr&gt; &lt;Child info="测试" :momeny="momeny"&gt;&lt;/Child&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; import {ref} from 'vue' const momeny=ref(100) import Child from './Child.vue'; &lt;/script&gt; &lt;style lang="scss" scoped&gt; .box{ width: 100vw; height: 400px; background-color: aquamarine; } &lt;/style&gt; 子组件 &lt;template&gt; &lt;div class="te"&gt; 子组件 &lt;br&gt; {{ info }} &lt;br&gt; {{ momeny }} &lt;/div&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; import { PropType } from "vue"; // 需要使用到defineProps方法去接受父组件传递过来的数据 // PropType 校验数据类型 // const props = defineProps({ info: { // required 字段是否必传 required: true, type: String as PropType&lt;String&gt;, default: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a14fb45c805c2721580096585e8f2145/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf7d919839f2e0f5e3f6b74c19ed1e60/" rel="bookmark">
			视觉大模型：DINO-Emerging Properties in Self-Supervised Vision Transformers论文读后感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于蒸馏的思想，实现图像的自监督学习。这里只是自监督的预训练模型，还需要针对下有任务微调的。
首先区分，生成式的任务和判别式的任务。比如图像生成，那mask掉一块让模型把这块补出来，自监督比较容易实现。但如果判别式的，比如实例分割、分类、检索等任务，自监督应该监督什么信息？
已有的研究，监督一张图各种数据增强后还和自身相近，但实现方式上有end-to-end和memory-bank，主要是对负例的管理方式，监督采用对比学习。MoCo系列，提出了momentum encode思想，作为二者的中间状态，V1核心思想，V2加了点SimCLR的优化点，V3移植到了ViT模型并主要在优化自监督的ViT训练时不稳定的问题(训练中acc发生dip)，采用的是冻结第一层的思路，因为发现dip是第一层梯度暴涨并逐渐传播后导致的。
DINO，借鉴了MoCo系列的momentum encode思想，同时借鉴了知识蒸馏的思路，希望让ViT中基于无监督训练先获得足够多的认知，避免直接监督信号后被快速积压到监督目标任务而无法积累全局性基础理解能力。
教师和学生网络，同一个模型结构但不同模型参数；一张图，学生模型有全局视野和局部视野两种裁剪程度的输入，教师模型只有全局视野程度的；然后，学生模型和教师模型softmax输出概率要交叉熵对齐，逼迫学生模型也要能学到全局视野的信息；学生模型正常BP训练，教师模型也是momentum式(指数移动平均)基于学生模型的参数更新。
另外，输出时教师模型加入了centering+sharpening，目的是不同batch的结果保持稳定，自然就可能克制dip的问题。
实验中，发现ViT的patch取的分辨率小一点，效果更好但计算效率也骤降；用更大更好的数据自监督训练，微调后对应任务表现可能更好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e4710889e675eeac2251ba5244d3520/" rel="bookmark">
			关于ERP系统，你可能不知道的10件事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谈到ERP系统，大多数人只是考虑ERP日常管理的核心功能，即财务、销售、采购、库存、生产和分销。保持对这些关键领域的控制对任何企业的成功都是不可或缺的。但这些只是冰山一角，如果深入挖掘ERP系统，你可能会惊讶于它的其他功能。以下是 ERP 系统可以做但你可能不知道的 10 件事。
文件控制 从图纸到测试结果到合格证的一切都存储在一个共享的位置，任何有需要的人都可以快速访问。文件不再需要物理上的共享，可以安全地永久保存，而不占用宝贵的物理空间。
设备跟踪 一些ERP系统，如8Manage FAS，包括一个工具数据库，非常适合跟踪你所有的设备系统记录。你不仅可以在设备的整个生命周期内存储所有的维修和校准记录，你还可以看到一个工具是否在使用中，以及这对你的计划有什么影响。
人力资源管理 ERP系统中的人力资源功能是一项真正的资产，特别是对于制造型企业而言。记录假期、病假和缺勤，当这些与日程安排功能相关联时，可为你提供有关潜在延迟交付能力的宝贵信息。
在你的轮班模式中包括工资率信息，以获得真正的工作成本计算。另外，它还可以管理员工的技能，包括资格、学徒水平等，并为任何需要的培训更新设定日期。
4. 管理公司开支
确保你已控制企业开支。通过8Manage FAS一体化ERP系统 ，你可以轻松地将费用归于员工，并对其进行审批。将费用与人员、活动和交易联系起来，获得销售的真实成本，还能轻松发现趋势和过度支出。
5. 车辆管理
这是另一个非常有用的功能，使你能够跟踪所有公司的车辆。系统将司机与车辆联系起来，并随时掌握实际的车辆维护费用。在一些ERP系统中，你可以为你的货车创建经常性的交付或装运运行，并将截止时间信息反馈给相关部门，以保证物品将准备好交付。
6. 多地点
追踪和管理多个仓库和地点的库存和物品。考虑到体积（长、宽、高）和重量，将库存发送到最佳位置。还要考虑到检疫和存货地点，以获得准确的可用库存，并在不同地点之间轻松转移库存。对于在不同地点经营或想在多个地点持有库存的企业来说，这是一个很棒的功能。
7. 市场营销
通过使用ERP系统中的功能来识别客户群中的趋势和机会，改善你的营销活动结果。根据行业、地理位置、客户类型或规模、购买历史等对客户进行细分，自动按照预设的条件把不同的内容匹配到对应的目标群或个人。
8. 测试
这对于那些需要在发行前对产品或材料进行测试的企业很有帮助。记录所有要进行的测试，并将其与路线、库存批次和交易中的个别操作联系起来。外部和内部测试结果都可以被记录和存储。使用测试结果报告来查看通过（或未通过）的内容、链接的批次、谁进行了测试以及进行了何种工作。
9. 客户服务
通过你的ERP系统管理支持案例（即已交付物品的问题）。在8Manage FAS中，支持案例链接到知识库，为所提出的问题提供已知的解决方案。用服务订单创建返工，使所有活动的成本保持在原始项目上。这也汇集了持续改进的过程，以确保相同的错误或问题不会再次发生。对于为所售物品提供担保的企业，服务合同也可以通过ERP进行管理。
10. 定价
当制定定价结构时，ERP是无价的。为每个客户设置特定的价目表或创建一组价目表并在客户、单个产品或产品组级别应用折扣。每个项目的数量分解价格表可以集成到大多数良好的ERP系统，在任何时候都可以调整单个产品或多个产品系列的价格。
总结
ERP 系统中还隐藏着许多其他不太明显的功能，这些功能使生活变得更加轻松。将流程和数据链接在一起可以提供质量更好、更丰富的数据，你可以根据这些数据做出业务决策。
8Manage FAS一体化ERP系统为所有利害关系人（如客户、供应商、项目参与人、合作伙伴、求职者、外包人员）提供端到端的实时业务流程，流程和数据具有实时性，报告即点即成，有助于企业实现高度的自动化和控制：
● 关键业务信息集中到单一的数据库，减少出错及重复工作
● 使企业能自动化、标准化及简化业务流程，缩短上线时间
● 业务运营实时可见，使决策者能够实时看到其决策的影响
● 提供一个集中的协作平台，改善跨职能的沟通，减少孤岛
8Manage FAS一体化ERP系统通过提供一个统一的平台，整合核心业务流程，实现更好的决策，提高效率，加强协作，帮助企业以各种方式轻松工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7944e1e551c98af8ab1494c07fd3fd8/" rel="bookmark">
			7-5 选择法排序 (只排三轮) (10 分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入10个无序的整数，用选择法对10个整数按升序排序。注意：要求排序只排3轮。
输入格式: 在一行中输入10个用空格间隔的无序整数。
输出格式: 在一行中输出变化后的数组，每个整数输出占5列。
输入样例: 8 5 2 6 7 4 1 9 12 10
输出样例: 1 2 4 6 7 5 8 9 12 10 因为题目要求只排三轮，所以只需要for循环三次。
#include&lt;stdio.h&gt; int main() { int i, index, k, temp; int a[10]; for(i = 0;i&lt;10;i++) { scanf("%d", &amp;a[i]); //将输入的数依次赋给数组a（从a[0]~a[9]） } /*对这10个数进行排序*/ for(k = 0;k&lt;3;k++) //排三次（循环三次） { index = k; //index存放最小值所在的下标 for(i = k+1;i&lt;10;i++) //寻找最小值所在的下标 { if(a[i]&lt;a[index]) //如果小于所设置的最小值，则进行交换 { index = i; } } temp = a[index]; //最小元素与下标为K的元素进行交换 a[index] = a[k]; a[k] = temp; } for(i = 0;i&lt;10;i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7944e1e551c98af8ab1494c07fd3fd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43eaede47f400bad6e54823235f376ca/" rel="bookmark">
			异常监测②——lstm时间序列预测&amp;lstm简易原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
利用LSTM进行时间序列预测流程
lstm滞后性
理解lstm原理
一、预测
二、遗忘
三、筛选
四、忽视
202305补充：从公式角度理解，
原理示例
lstm参数
各参数的定义解释：
batch_size
如何选择batch_size的大小：
epoch
预测滞后问题
损失函数的选择
1、Mean Squared Error Loss（MSE）
2、Mean Squared Logarithmic Error Loss（MSLE）
3、Mean Absolute Error Loss (MAE)
4、Binary Classification Loss Functions
5、Binary Cross-Entropy Loss
6、Hinge Loss
7、Squared HInge Loss
8、Multi-Class Classification Loss Functions
如何选择优化器Optimizer
dropout层
1、什么时候应该加dropout层？
2、放在哪几个层之间？
利用LSTM进行时间序列预测流程 在用统计学方法（3σ原则、四分位距法）等对异常数据进行监测后 （异常监测①——统计学方法判断）
由于业务特点，导致时序数据的规律趋势会变化。下方为举例：
时间点原来的count现在的count2020-01-01 13:00:0026710002020-01-01 13:10:0030002020-01-01 13:20:0026102020-01-01 13:30:0028910232020-01-01 13:40:0023502020-01-01 13:50:0027302020-01-01 14:00:003091014 此时原统计学方法可能不再适用，可以重新观察新的数据分布规律，手动修改代码逻辑。
但考虑到后续规律仍可能发生变动，为避免后续需要继续改异常监测逻辑，选择使用深度学习模型——lstm 对时序数据的分布进行预测。并且增添 模型更新 逻辑，使得模型不需要再人工更改。
参考以下资料：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43eaede47f400bad6e54823235f376ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f7b3748de74b9ea41b60e70c49a1924/" rel="bookmark">
			docker常用命令汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 背景 在开发过程中，经常涉及到 docker 的相关操作，本文对常用的指令进行汇总
1 镜像相关 1.1 查看镜像列表 sudo docker images 1.2 镜像搜索 比如搜索 ubuntu 基础镜像
sudo docker search ubuntu 可输出官方的镜像名称，以及 star 数量，选择一个需要的镜像下拉即可
1.3 下拉镜像 sudo docker pull 镜像名 sudo docker pull 镜像名:Tag 1.4 删除镜像 sudo docker rmi -f 镜像名/镜像ID 1.5 保存镜像 将我们的镜像 保存为tar 压缩文件 这样方便镜像转移和保存 ,然后 可以在任何一台安装了docker的服务器上 加载这个镜像
docker save 镜像名/镜像ID -o 镜像保存在哪个位置与名字 1.6 加载镜像 任何装 docker 的地方加载镜像保存文件,使其恢复为一个镜像
docker load -i 镜像保存文件位置 2 容器相关 2.1 容器列表 sudo docker ps sudo docker ps -a # 查看所有容器 -----包含正在运行 和已停止的 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f7b3748de74b9ea41b60e70c49a1924/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b40f169e53a4bd1f9ff0f0b6365423ab/" rel="bookmark">
			vue更新数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 Vue 中，一个数组在更新时，如果数组里的元素是数组或对象的话，需要注意数组或对象的引用关系。如果这些数组或对象被修改，但数组本身的引用没有发生变化的话，Vue
是不会检测到这些变化的，因为 Vue 只会对数据做浅层次的检测。
解决这个问题的方法之一是，通过 Vue 的 $set 或者 Vue.set 方法来触发数组的更新。这个方法会告诉 Vue，该数组需要被更新，从而可以正确地触发视图的更新。
假设我们有以下数据：
data: { items: [ {id: 1, name: 'A', subItems: []}, {id: 2, name: 'B', subItems: []}, ... ] } 此时，如果我们想更新某个 subItems 数组里的元素，可以使用 $set 或者 Vue.set 方法，如下所示：
this.$set(this.items[index].subItems, subIndex, newValue); 总结：
对象更新： this.$set(对象，属性，更新的属性值) 数组更新： this.$set(数组，下标数，item更新的值) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3bb43d27091d6f0fa882f35c9cee374/" rel="bookmark">
			Java 数组全解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 数组是一种有序、固定长度并且具有相同数据类型元素的集合，它是 Java 语言中最常用的数据结构之一。在 Java 中，数组可以是基本数据类型的数组，也可以是对象类型的数组。
Java 数组的基础知识： 声明数组 数组需要在声明时指定数据类型和数组名，并指定数组的长度。语法如下：
type[] name = new type[length]; 其中 type 是数组元素的数据类型，name 是数组的名称，length 是数组的长度。
例如，声明一个整型数组 intArray，包含 10 个元素，代码如下：
int[] intArray = new int[10]; 初始化数组 数组可以通过两种方式进行初始化：静态初始化和动态初始化。
静态初始化：在声明数组时直接为数组分配和赋值。静态初始化不需要指定数组长度，系统会根据元素个数自动计算数组长度。语法如下：
type[] name = { value1, value2, ..., valueN }; 例如，声明一个字符串数组 strArray，包含 3 个元素并分别赋值为 “A”、“B” 和 “C”，代码如下：
String[] strArray = {"A", "B", "C"}; 动态初始化：在声明数组时只分配数组空间，没有指定数组内容，需要在后续步骤中为数组元素赋值。动态初始化需要指定数组长度。语法如下：
type[] name = new type[length]; 例如，声明一个浮点型数组 floatArray，包含 5 个元素，代码如下：
float[] floatArray = new float[5]; 访问数组元素 数组的元素可以通过下标或索引（从0开始）进行访问和操作，例如：array[index]。其中，array 是数组名，index 是下标。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3bb43d27091d6f0fa882f35c9cee374/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d298090705b7978faf1a96e389ee32cf/" rel="bookmark">
			数据集：深圳ETC数据（OD数据、轨迹数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 数据位置 Desheng Zhang, Rutgers University
2 OD数据介绍 广东省一天的ETC交易样本 包括起点、终点、起点时间、终点时间和车牌号。1,531,863辆车辆和2,515,672条记录。
3 轨迹数据介绍 深圳市一天的电动出租车GPS样本 包括车辆ID、经度、纬度、时间和速度。总共有664辆电动出租车和1,155,654个GPS记录。 4 手机信令+GPS数据 深圳的五种数据类型： 手机通话记录数据 智能卡数据 出租车GPS数据 公交车GPS数据 BUS ID, Time, PlateID, Latitude, Longitude, Speed卡车GPS数据 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1dfed6d7035bded66473a703a9b186a/" rel="bookmark">
			关于ts文件中，引入vue文件报红线的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题就是ts不会识别vue，会认为没有这样的模块
找到你的env.d.ts中写入下面代码
declare module '*.vue' { import { DefineComponent } from 'vue' const component: DefineComponent&lt;object, object, any&gt; export default component } 不好使的话重启下项目试试
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/132/">«</a>
	<span class="pagination__item pagination__item--current">133/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/134/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>