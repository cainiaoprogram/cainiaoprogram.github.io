<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8546a926bb05b67d74d0e6de0873f0ed/" rel="bookmark">
			MySQL实现（免密登录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介: MySQL免密登录是一种允许用户在没有输入密码的情况下直接登录到MySQL服务器的配置。这通常是通过在登录时跳过密码验证来实现的。
1、修改MySQL的配置文件
使用vi /etc/my.cnf，添加到【mysqld】后面
skip-grant-tables #配置项告诉mysql跳过权限验证，允许任何用户以任何密码登录
2、重启MySQL服务
systemctl restart mysql #使修改的文件生效
3.创建一个用于免密登录的用户
create user "uname"@"localhost" identified by " "; #uname替换成你创建用户名
4、刷新权限
flush privileges; #重新加载用户权限表，使新的用户可以免密登录
5、测试免密登录
mysql -u uname #uname替换成你创建用户名
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c813fa344bcbf59bd93d72b4378cb6b0/" rel="bookmark">
			轻松实现开放接口的签名和验签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创 一安 一安未来 2023-12-01 08:00 发表于北京
收录于合集#干货分享集191个
大家好，我是一安~
介绍 开放接口 开放接口是指不需要登录凭证就允许被第三方系统调用的接口，这个时候肯定要考虑接口数据的安全性问题，比如数据是否被篡改，数据是否已经过时，数据是否可以重复提交等问题，为了防止开放接口被恶意调用，开放接口一般都需要验签才能被调用。
验签 验签是指第三方系统在调用接口之前，需要按照接口提供方的规则根据所有请求参数生成一个签名（字符串），在调用接口时携带该签名。接口提供方会验证签名的有效性，只有签名验证有效才能正常调用接口，否则请求会被驳回。
大致流程 实战 这里只是演示，未真正区分开客户端和服务端
导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.7.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.15&lt;/version&gt; &lt;/dependency&gt; 自定义配置 私钥和公钥直接保存在文件中
spring: redis: host: localhost port: 6379 password: root database: 2 signature: enable: true key-pair: # 调用方ID test-1: # 算法 algorithm: SHA256withRSA # 私钥 private-key-path: classpath:signature/private # 公钥 public-key-path: classpath:signature/public # 生效时间(分钟) effective-time: 3 加载配置信息 @Data @ConditionalOnProperty(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c813fa344bcbf59bd93d72b4378cb6b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26531634abba08a16c39362e0d79224f/" rel="bookmark">
			【开源】基于Vue.js的停车场收费系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码，项目编号： S 076 。 \color{red}{文末获取源码，项目编号：S076。} 文末获取源码，项目编号：S076。
目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 停车位模块2.2 车辆模块2.3 停车收费模块2.4 IC卡模块2.5 IC卡挂失模块 三、系统设计3.1 用例设计3.2 数据库设计3.2.1 停车场表3.2.2 车辆表3.2.3 停车收费表3.2.4 IC 卡表3.2.5 IC 卡挂失表 四、系统实现五、核心代码5.1 查询停车位5.2 查询车辆5.3 新增停车记录5.4 查询 IC 卡5.5 新增 IC 卡挂失 六、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL的停车场收费系统，包含了车辆管理模块、停车场模块、停车记录模块、IC卡档案模块和IC卡挂失模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，停车场收费系统基于角色的访问控制，给停车管理员、车主、工作人员使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
随着我国经济的不断发展，人民生活水平的也日益提高，外出购物、旅游意向也越来越强，对交通出行的需求也越来越大。在一些大型商贸场所，无论是人流量还是车流都格外大，而道路承载压力也随之增加，所以城市停车问题的解决也越发急迫。由此观之，如何解决商场等人流量多等地的停车问题，是解决交通拥堵的关键点。
综上所述，设计一个停车场收费系统能够简化人们停车流程，提高停车效率，从而解决拥挤问题，节省人们时间的同时也间接推动经济发展。本文研究的系统采用JAVA开发，停车场收费系统的应用取得了显著的效果。通过停车场收费系统的运行，停车场实现了车辆进出的自动化、停车场管理的精细化和收费流程的标准化，从而提高停车场管理效率和准确性，为停车场管理决策提供更完整、准确的数据支持。
1.2 项目录屏 源码下载
二、功能模块 2.1 停车位模块 停车位是城市不可或缺的一部分，在城市和人民的生活、工作和流动中具有重要意义。随着城市化进程的加快和汽车保有量的增加，城市交通拥堵问题越来越明显。如果有足够的停车位，可以更好地引导交通，防止交通混乱，缓解交通拥堵，在城市内驾驶车辆的效率取决于停车位的数量和位置。良好的停车位规划和管理可以提高车辆停车效率，减少道路拥堵，提高城市交通效率。停车位的可用性直接影响市民的出行体验。当停车位紧张时，市民很难开车出去，如果有足够的停车位，市民出行将更加方便和舒适。停车位的可用性也会影响商业中心区域的吸引力，如果没有足够的停车位，消费者会选择其他商业中心，这将影响经济发展。
2.2 车辆模块 车辆模块是停车场收费系统的关键组件之一，用于记录、管理和监控车辆信息和状态。车辆模块可以实现车辆进出的自动化和数据处理的自动化，从而提高停车管理的效率和准确性。通过车辆模块，停车可以为用户提供更智能、更方便的服务，减少用户等待时间和不良体验。车辆模块可以有效控制车辆的交通流量，缓解道路拥堵，改善城市交通拥堵问题。车辆模块可以记录和监控车辆的进出，可以减少非法侵入和车辆盗窃等安全问题。车辆模块在停车管理系统中具有重要的研究意义，可以提高停车管理的效率和服务质量，改善城市交通拥堵，加强安全监督管理，为停车管理提供数据支持。
2.3 停车收费模块 停车收费是对车辆的停车位置、停留时间和计费状态等信息的有效记录和管理。停车收费可以让车主清楚地知道他们的车辆停在哪里和什么时候停，避免车辆被盗和其他安全问题。通过停车收费，可以获得停车位使用情况、停车流量等信息，让停车场管理者更好地分析和制定停车策略，帮助维护停车场的秩序和安全。停车收费也可以用于精细化管理，例如通过针对特定高峰时间和特定情况的差异化定价政策来提高停车利用率和管理效率。通过停车收费，可以了解车主的停车习惯和需求，为车主提供更好的停车服务，提高停车场的服务质量和用户体验。
2.4 IC卡模块 IC卡是智能卡的缩写，车主可以拥有一张或多张的IC卡，用于停车费用的缴纳，IC卡字段包括IC卡号、开卡日期、所属人、经办人、服务电话、余额、创建人、创建时间，车主可以申请新的IC卡，停车场管理员可以新增、挂失、编辑、条件查询车主的IC卡。
2.5 IC卡挂失模块 IC卡是一张实体卡，车主难免会遗失或损坏，当出现这类情况时则无法完成停车费用缴纳，这就需要建一个IC卡挂失模块，给车主的挂失卡替换为新的IC卡，IC卡挂失字段包括原卡号、新卡号、申请人、申请日期、申请状态、审核状态、经办人、创建时间，车主可以选择自己名下的IC卡发起挂失申请，停车场管理员可以审核车主的IC卡挂失申请。
三、系统设计 3.1 用例设计 3.2 数据库设计 3.2.1 停车场表 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26531634abba08a16c39362e0d79224f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b43e62071b527f3b55b07f0b415ca8d/" rel="bookmark">
			docker方式安装gitlab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：docker 方式安装gitlab 用docker来安装比较方便简单，包括版本升级也会变得更简单。
1、拉取gitlab镜像
gitlab-ce表示的是社区免费版本
docker pull gitlab/gitlab-ce:latest 2、创建映射文件
mkdir -p /data/docker/gitlab/etc mkdir -p /data/docker/gitlab/log mkdir -p /data/docker/gitlab/data etc映射保存配置文件，log 存储日志，data存储数据文件
3、运行gitlab容器
docker run \ --detach \ --privileged=true \ --hostname 125.74.48.123 \ --publish 443:443 --publish 8080:8080 --publish 5000:22 \ --name mygitlab \ --restart unless-stopped \ --volume /data/docker/gitlab/etc:/etc/gitlab \ --volume /data/docker/gitlab/log:/var/log/gitlab \ --volume /data/docker/gitlab/data:/var/opt/gitlab \ gitlab/gitlab-ce:latest hostname : 安装服务的ippublish 443:443 https的端口，左边是宿主机对外端口，右边是容器内端口publish 8080:8080 http访问的端口。左边是宿主机对外端口，右边是容器内端口publish 5000:22 ssh方式下载对应的端口，左边是宿主机对外端口，右边是容器内端口
注意，要用http方式连接，publish 8080:8080 前后两个端口需要一样。 容器启动后，还需要做配置调整
二、gitlab相关配置 1、配置容器中/etc/gitlab/gitlab.rb的配置文件 因为我们已经把容器的/etc目录映射到了本机的/data/docker/gitlab/etc 这个目录，我们打开
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b43e62071b527f3b55b07f0b415ca8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5261f5e157b586a51dc0d440995e288c/" rel="bookmark">
			AUTOSAR专栏——总目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要汇总该专栏文章，以方便各位读者阅读。
一、Can通信 【AUTOSAR】【CAN通信】CanDriver
【AUTOSAR】【CAN通信】CanTrcv
【AUTOSAR】【CAN通信】CanIf
【AUTOSAR】【CAN通信】CanTp
【AUTOSAR】【CAN通信】CanSM
【AUTOSAR】【CAN通信】CanNm
【AUTOSAR】【CAN通信】CanSyn
二、Lin通信 【AUTOSAR】【Lin通信】LinDrive
【AUTOSAR】【Lin通信】LinTrcv
【AUTOSAR】【Lin通信】LinIf
【AUTOSAR】【Lin通信】LinSM
三、以太网通信 【AUTOSAR】【以太网】EthDriver
【AUTOSAR】 【以太网】EthTrcv
【AUTOSAR】【以太网】EthSM
【AUTOSAR】【以太网】TCPIP
【AUTOSAR】【以太网】SoAd
【AUTOSAR】【以太网】UdpNM
【AUTOSAR】【以太网】SomeIpSD
【AUTOSAR】【以太网】SomeIpTp
【AUTOSAR】【以太网】SomeIpXf
【AUTOSAR】【以太网】EthSyn
【AUTOSAR】【以太网】DOIP
四、通信栈 【AUTOSAR】【通信栈】PduR
【AUTOSAR】【通信栈】LdCom
【AUTOSAR】【通信栈】Com
【AUTOSAR】【通信栈】ComXf
【AUTOSAR】【通信栈】IPduM 五、信息安全 【AUTOSAR】【信息安全】CryptoDriver
【AUTOSAR】【信息安全】CryIf
【AUTOSAR】【信息安全】CSM
【AUTOSAR】【信息安全】KeyM
【AUTOSAR】【信息安全】SecOC
六、通信安全 【AUTOSAR】【通信安全】CRC
【AUTOSAR】【通信安全】E2E
【AUTOSAR】【通信安全】E2EXf
上述各专题仍持续更新中。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e89a7ef7a2f2f3f44cb9b1044117427f/" rel="bookmark">
			rest_framework_django学习笔记三(异常、登录认证)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rest_framework_django学习笔记三(异常、登录认证) 一、异常 REST framework 定义的异常
异常名称说明APIException所有异常的父类ParseError解析错误AuthenticationFailed认证失败NotAuthenticated尚未认证PermissionDenied权限拒绝NotFound未找到MethodNotAllowed请求方式不支持NotAcceptable要获取的数据格式不支持Throttled超过限流次数ValidationError校验失败 1、自定义异常 REST framework 提供了异常处理，我们可以自定义异常处理函数
from rest_framework.views import exception_handler def custom_exception_handler(exc,context): # 先调用 REST framework 默认的异常处理方法获得标准错误响应对象 response = exception_handler(exc,context) # 补充自定义的异常处理 if response is not None: response.data['status_code'] = response.status_code return response 在配置文件中声明自定义的异常处理
REST_FRAMEWORK = { "EXCEPTION_HANDLER": "demo_app.utils.custom_exception_handler", # 自定义的异常处理 } 2、补充异常处理 from rest_framework import status from django.db import DatabaseError from rest_framework.response import Response def custom_exception_handler(exc,context): # 先调用 REST framework 默认的异常处理方法获得标准错误响应对象 response = exception_handler(exc,context) # 补充自定义的异常处理 if response is None: view = context['view'] if isinstance(exc,DatabaseError): print('[%s]:%s'%(view,exc)) response = Response({'detail':'服务器错误'},status=status.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e89a7ef7a2f2f3f44cb9b1044117427f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1dc83d6a144093773015a023621da9c/" rel="bookmark">
			MATLAB--控制语句--数组操作--符号运算--绘图--文件和数据的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 控制语句一、循环语句1.for 循环2.while 循环break 和continue 语句 二、条件语句1. if 语句2.switch 语句 数组操作一、矩阵基本操作1.创建2.获取元素3.矩阵赋值4.空矩阵5.删除元素6.矩阵重排7.矩阵转置、旋转、翻转8.矩阵扩充9.特殊矩阵 二、矩阵运算1.矩阵的加减法2.矩阵的乘法3.矩阵的除法 三、矩阵分析1.矩阵的逆2.矩阵的行列式3.矩阵的秩和迹4.矩阵的范数5.矩阵的条件数6.矩阵特征值和特征向量 四、向量运算五、标量与向量 符号运算一、符号变量与符号表达式符号变量的生成（1）函数sym（2）函数syms 函数subs符号方程的生成 二、符号表达式化简三、符号运算1.符号微分2.符号积分3.符号矩阵计算4.符号多项式的根 四、符号函数图形五-符号方程求解 绘图一、图形窗口二、基本图形绘制1.二维图形的绘制（1）plot 函数（2）绘制多个线条（3）线型、标记、颜色（4）添加标题、坐标轴标注、图例（5）fplot 函数 2.图形操作（1） 图形保持（2） 图形子窗口（3） 坐标轴控制（4） 对数坐标系绘图（5） 散点图 3.三维图形的绘制（1） 三维曲线图（2） 三维曲面图 3.特殊图形的绘制（1）条形图（2）面积图（3）饼状图（4）直方图（5）离散数据图（6）等值线图 5.特殊字符3.添加注释（1） 添加标题（2） 添加坐标轴标注（3） 添加图例（4） 添加文本 文件和数据的处理一、数据的基本操作1.文件存储2.数据导入 二、文件的操作formatSpec - 输出字段的格式 1.转换字符2.标志3.转义符 控制语句 MATLAB 常用的控制语句有for, while, if, switch 等。
一、循环语句 通过循环控制语句，可以重复执行代码块。循环有两类：for 循环和while 循环。
for 循环是一组语句重复固定的，指定的次数，while 循环是满足条件执行。
1.for 循环 循环特定次数，并通过递增的索引变量跟踪每次迭代。
for 循环的典型结构如下： for x=lower_bound:step:upper_bound group of statements end 循环变量为x，表达式lower_bound:step:upper_bound 给循环变量赋值，循环变量从初始值lower_bound 开始，步长为step 进行递增。如果step 为1 可以省略。循环索引
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1dc83d6a144093773015a023621da9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c999eac99c19957d86d1f887cc5f12b8/" rel="bookmark">
			大数据-之LibrA数据库系统告警处理（ALM-37018 数据库用户连接数超限）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		告警解释 当集群中单个CN实例上某个用户的连接数超过限制时，产生该告警。
告警属性 告警ID
告警级别
可自动清除
37018
严重
是
告警参数 参数名称
参数含义
ServiceName
产生告警的服务名称
RoleName
产生告警的角色名称
HostName
产生告警的主机名
Instance
产生告警的实例
databaseName
连接的数据库名称
dbUserName
连接数据库的用户名
对系统的影响 发生数据库用户连接数超限时，该CN实例无法再以该用户访问。
可能原因 当前CN实例上该数据库用户的连接数超过限制。
处理步骤 以数据库管理员用户(该用户有权限创建其他数据库用户，比如omm)访问上报告警的CN实例。具体操作如下所示。 gsql -d postgres -p 25308 postgres=# 检查当前CN实例上所有用户的连接数限制。可以看到在该CN实例上gaussdba用户的连接数被限制为3。 postgres=# select * from pg_authid; rolname | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcatupdate | rolcanlogin | rolreplication | rolauditadmin | rolsystemadmin | rolconnlimit | rolpassword | rolvaliduntil -------------+----------+------------+---------------+-------------+--------------+-------------+----------------+---------------+----------------+--------------+-------------------------------------------------------------------------- ------------------------------------------------------------------------------------------------------------------------------+--------------- gaussdba | t | t | t | t | t | t | t | t | t | 3 | sha2567cee5d311c1e21e84671a2f2e1d8023f1990b4fa7c5656e44277acd3087e2c7fc74 224dbb26375c88c91c9007af78fb1e5212656ec482957bf8fe8ce383b0f59d3ae6152aa0009ee46271d0446eb8cd0d0e461b09c17f93449c14d4c75238b3d | (1 row) 可以选择关闭部分连接或者增加连接数限制，来处理该告警。增加连接数限制操作示例如下。 postgres=# alter role gaussdba CONNECTION LIMIT 9; ALTER ROLE postgres=# select * from pg_authid; rolname | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcatupdate | rolcanlogin | rolreplication | rolauditadmin | rolsystemadmin | rolconnlimit | rolpassword | rolvaliduntil -------------+----------+------------+---------------+-------------+--------------+-------------+----------------+---------------+----------------+--------------+-------------------------------------------------------------------------- ------------------------------------------------------------------------------------------------------------------------------+--------------- gaussdba | t | t | t | t | t | t | t | t | t | 9 | sha2567cee5d311c1e21e84671a2f2e1d8023f1990b4fa7c5656e44277acd3087e2c7fc74 224dbb26375c88c91c9007af78fb1e5212656ec482957bf8fe8ce383b0f59d3ae6152aa0009ee46271d0446eb8cd0d0e461b09c17f93449c14d4c75238b3d | (1 row) 再用gaussdba的用户连接数据库，查看告警是否仍然存在。 是，执行5。否，处理完毕。收集故障信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c999eac99c19957d86d1f887cc5f12b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5616643428fdf3221269b6bae812a5b1/" rel="bookmark">
			【栈与队列】栈与队列的相互转换OJ题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		栈与队列的相互转化 1 栈与队列1.1 栈1.2 队列1.3 差别与关系 2 栈与队列的相互转换2.1 队列模拟实现栈2.1.1 栈的结构体设置2.1.2 初始化接口2.1.3 压栈操作2.1.4 出栈2.1.5 取栈顶2.1.6 判断是否为空2.1.7 销毁栈 2.2 栈模拟实现队列2.2.1 版本一2.2.2 优化版本二 Thanks♪(･ω･)ﾉ 1 栈与队列 1.1 栈 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。
压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。
出栈：栈的删除操作叫做出栈。出数据也在栈顶。
1.2 队列 队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出FIFO(First In First Out) 的原则
入队列：进行插入操作的一端称为队尾
出队列：进行删除操作的一端称为队头
1.3 差别与关系 通过上述的介绍，栈与队列仿佛毫不相干，一个先入先出，一个后入后出。
栈像一个容器来装物品，队列像排队买饭。这两个事情看起来毫不相干，那么如何实现栈与队列的相互转换呢。下面我们来看两道OJ题，来进行具体解决。
2 栈与队列的相互转换 2.1 队列模拟实现栈 我们来看题目描述
这道题给了我们六个接口，接下来我们来逐一完成。
首先先把队列的代码拷贝到代码区，方便我们使用队列中的对应接口。、
2.1.1 栈的结构体设置 首先，我们来分析一下怎样通过队列来模拟栈
我们看，我们模拟一下发现，删除操作只需要将一个队列的前n个数据迁移到另一个队列就可以，那我们不妨就假设看看两个队列能否实现栈。
typedef struct { Queue q1; Queue q2; } MyStack; 2.1.2 初始化接口 非常简单的我们初始化一下
MyStack* myStackCreate() { MyStack* st = (MyStack*)malloc(sizeof(MyStack)); QueueInit(st-&gt;q1); QueueInit(st-&gt;q2); return st; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5616643428fdf3221269b6bae812a5b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b1d1d7d8f6266ab936d78508be57c49/" rel="bookmark">
			FFmpeg解码H264视频裸流(直接可用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、写在前面
此文章主要包含解码H264视频流数据，主要有以下几点：
1、H264视频帧为Annex B格式，若使用AVCC格式可自行研究；
2、H264视频裸流，非解码视频文件(若有需要我后期可添加这部分代码);
3、支持输出RGB24或YUV420格式，其他可自行修改；
4、FFmpeg官网代码迭代及接口变更较大，代码适应于FFmpeg3.4.2"Cantor"、3.3.7"Hilbert"等版本，较旧接口请看旧版本代码；
2、新版本 FFmpegVideoDecoder.h
#include &lt;libavcodec/avcodec.h&gt; /** 视频流解码器初始化 @param ctx 解码参数结构体AVCodecParameters @see FFmpeg_H264DecoderInit，此为解码H264视频流 @return 初始化成功返回0，否则&lt;0 */ int FFmpeg_VideoDecoderInit(AVCodecParameters *ctx); /** H264视频流解码器初始化 @return 初始化成功返回0，否则&lt;0 */ int FFmpeg_H264DecoderInit(void); /** 释放解码器 @return 初始化成功返回0，否则&lt;0 */ int FFmpeg_VideoDecoderRelease(void); //return 0:暂未收到解码数据，-1：解码失败，1：解码成功 /** 解码视频流数据 @param inbuf 视频裸流数据 @param inbufSize 视频裸流数据大小 @param framePara 接收帧参数数组：{width,height,linesize1,linesiz2,linesize3} @param outRGBBuf 输出RGB数据(若已申请内存) @param outYUVBuf 输出YUV数据(若已申请内存) @return 成功返回解码数据帧大小，否则&lt;=0 */ int FFmpeg_H264Decode(unsigned char * inbuf, int inbufSize, int *framePara, unsigned char *outRGBBuf, unsigned char **outYUVBuf); FFmpegVideoDecoder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b1d1d7d8f6266ab936d78508be57c49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bc1405f8a705569827b2acdaab6c0d1/" rel="bookmark">
			js中reduce()函数的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😁 作者简介：一名大三的学生，致力学习前端开发技术
⭐️个人主页：夜宵饽饽的主页
❔ 系列专栏：JavaScript小贴士
👐学习格言：成功不是终点，失败也并非末日，最重要的是继续前进的勇气
​🔥​前言：
这是我自己有关array.prototype.reduce()函数的用法的总结，如有不足和错误，欢迎大家更好的补充和纠正
1.Array.prototype.reduce()函数的用法 定义：
reduce()方法对每一个数组的每一个元素按序执行一个由您提供的reduce函数。每一次运行reduce会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。
第一次执行回调函数时，不存在“上一次的计算结果”。如果需要回调函数从数组索引为0的开始执行，则需要传递初始值，否则数组的索引为0的值作为初始值initalValue，迭代器从第二个元素开始执行（索引为1而不是0）
语法：
reduce((previousValue, currentValue, currentIndex, array) =&gt; { /* … */ }, initialValue) 参数：
callbackfn
一个“reduce”函数，包含四个参数：
previousValue:上一次调用callbackFn时的返回值，在一次调用时，若指定初始值initialValue，其值为initalvalue，否则为数组索引为0的元素array[0]currentValue：数组中正在处理的元素，在第一次调用时，若指定初始值initalValue，其值则为数组索引为0的元素array[0],否则为array[1]currentIndex：数组中正在处理的元素索引，若指定了初始值initvalue，则起始索引号，否则从索引1起的。array：用于遍历的数组 initalvalue(可选)
作为第一次调用callback函数时的参数previousValue的值，若指定了初始值initalValue，则currentValue则将使用数组第一个元素，否则previosValue的值是将是数组的第一个元素，而currentValue将使用数组第二个元素
返回值
使用reduce回调函数遍历整个数组后的结果
异常
TypeError
数组为空且初始值未提供
扩展知识点：
如果数组为空且未指定初始值 initialValue，则会抛出 TypeError。
reduce 不会直接改变调用它的对象，但对象可被调用的 callbackfn 所改变。遍历的元素范围是在第一次调用 callbackfn 之前确定的。所以即使有元素在调用开始后被追加到数组中，这些元素也不会被 callbackfn 访问。如果数组现有的元素发生了变化，传递给 callbackfn 的值将会是元素被 reduce 访问时的值（即发生变化后的值）；在调用 reduce 开始后，尚未被访问的元素若被删除，则其将不会被 reduce 访问。
基本使用
1.将二维数组转化为一维
//将二维数组转化一维数组 let fla=[[0,1],[2,3],[4,5]].reduce( function(pre,cur){ return pre.concat(cur) }, [] ) console.log("二维数组转化一维数组:"+fla); //二维数组转化一维数组:0,1,2,3,4,5 2.计算数组中每一个元素出现的次数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bc1405f8a705569827b2acdaab6c0d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0c1f46228865e941abcd6268a396c9a/" rel="bookmark">
			比较全面的系统dll修复方法，5种方法快速解决dll文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dll文件的丢失其实还是非常的常见的，只要你是经常使用电脑的人，那么不免会遇到这种情况的，遇到这种情况，那么你肯定是要会处理的吧？今天我们就来教大家怎么去处理系统dll丢失的问题，系统dll修复方法。
一.什么是DLL文件 DLL（Dynamic Link Library）文件是一个包含能被多个程序共同使用的代码和数据的库。这些文件扩展名通常为.dll，是Windows操作系统中用于存放可执行函数或数据的一种形式。它们可以被多个应用共享，以此减少重复的存储需求并节省空间，同时提高应用程序间的资源共享效率。
二.DLL文件为何会丢失 DLL文件可能会因为各种原因丢失或损坏，如下所述：
1. 系统更新时，老的DLL文件可能会被意外删除或替换。
2. 恶意软件攻击可能会删除或损坏DLL文件。
3. 经常进行软件安装和卸载，可以导致DLL文件的不正确注册或删除。
4. 硬盘损坏也可能导致存储在其中的DLL文件丢失。
三.DLL丢失的多种解决方法 方法一：重新启动计算机 有时候，简单地重启你的系统就可以修复DLL错误。
方法二：运行SFC扫描 系统文件检查器（SFC）是Windows内置的工具，它能扫描损坏的系统文件并修复它们。其步骤如下：
- 以管理员身份打开命令提示符。
- 输入`sfc /scannow`并回车。
- 等待扫描完成后重启系统。
方法三：使用系统还原 如果最近你对系统进行了更改，这些更改可能导致DLL错误，你可以尝试使用系统还原功能。
步骤一：访问系统还原功能
打开"控制面板"。
选择"系统和安全"，再点击"系统"。
在左侧面板中，点击"系统保护"。
若您的操作系统版本有所不同，另一个快速访问的方法是在搜索栏输入“系统还原”，然后选择出现的“创建还原点”或“系统还原”。
步骤二：启用系统还原
在系统属性窗口中：
点击"系统保护"标签页。
选中要还原的系统驱动盘（通常是C:盘），然后点击下方的"系统还原…"按钮。
步骤三：配置还原设置
在系统还原界面上：
点击“下一步”开始选择还原点。
您会看到一个列表，其中列出了所有可用的还原点。根据日期和时间选择一个点，在此之前的系统状态可能没有当前遇到的问题。
如果需要，可以点击"扫描影响的程序"来查看哪些程序和驱动将受还原点影响，这一步是可选的。
步骤四：确认并开始系统还原
选择了还原点后，点击“下一步”。
在确认您的还原点后，系统会要求您再次确认。确保所选还原点无误，然后点击"完成"。
在弹出的警告框中，它会提示你此操作无法中断，点击“Yes”确认。
系统将重新启动，并在重启过程中进行系统还原。完成还原后，您将进入Windows，并且应该会看到一个对话框告知您还原已经成功完成。
方法四：使用dll修复工具 使用dll修复工具来解决这个问题，比较适合电脑小白，不需要太多复杂的操作，一键就可以快速修复相关问题。
在任意的浏览器上车俞入：dll修复.site 然后按确认Enter键就可以了
进入站点之后下载，直接使用就可以了
点击一键修复dll错误的按钮，就会自动的帮你扫描电脑系统中缺失的dll文件
等扫描完毕后，再点击修复，然后静待修复完成就可以了。
最后就是关机重启一下就能修复完成。（也可以选择手动修复，在dll修复工具上，选择手动修复，然后输入缺失的dll文件，直接查找，下载安装就可以了。）
DLL修复工具_一键修复所有dll缺失msvcp140.dll丢失的解决方法–电脑修复精灵
方法五：手动下载DLL 你可以从可信赖源下载缺失的DLL文件，并将它们放置在正确的目录中。
步骤一：确定需要的DLL文件
识别出缺少哪个DLL文件，在错误消息中通常会显示缺失的DLL文件名称。
记录下确切的错误消息和DLL文件的名称，以便进一步搜索。
步骤二：从可信网站下载DLL文件
找到一个可信赖的网站来下载DLL文件。在网站的搜索栏里输入DLL文件的名称，然后进行搜索。
下载与你的系统版本（32位或64位）和Windows版本相符合的DLL文件。
请注意：在互联网上寻找DLL文件时，务必要确保来源的可靠性，因为不安全的网站可能提供的是含有恶意软件的DLL文件。
步骤三：安装下载的DLL文件
将下载的DLL文件解压（如果DLL文件是压缩包形式的话）。
右键点击开始菜单，选择“文件资源管理器”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0c1f46228865e941abcd6268a396c9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48542e6597843540ab3704598dcffbdc/" rel="bookmark">
			Linux设置开机自启动奇安信可信浏览器，并配置默认页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 先安装奇安信可信浏览器 安装完成后，会在/usr/share/applications/目录下生成一个 qaxbrowser-safe.desktop文件。
2.配置开机自启动 使用root用户进行如下操作：
将qaxbrowser-safe.desktop 文件复制到 ~/.config/autostart/ 目录下，这是freedesktop.org的规范中定义的，一般桌面环境都遵循。
cp /usr/share/applications/qaxbrowser-safe.desktop ~/.config/autostart/ 如果没有~/.config/autostart目录，需手工建立：
mkdir ~/.config/autostart 3.默认页面配置 打开奇安信可信浏览器，点击：设置 -&gt; 基本设置 -&gt; 主页 -&gt; 填写默认打开页面的网址。
4. 重启Linux机器 linux ubuntu 开机自动启动 fixfox 并打开指定网站
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90e29dce0783f1a0776e55101173cfe5/" rel="bookmark">
			python输出魔方阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：记不清了emm，大概内容是，要求用户输入一个1到9之间的正整数N，然后输出一个边长为2*N-1的方阵。方阵的要求为：最外层元素全是1，次外层元素全为2，再次外层为3...以此类推，方阵最中间那个数为N。
思路：我的思路是首先生成一个边长为2*N-1并且元素全为0的矩阵，然后首先将矩阵元素全部更新为1，接着将矩阵除了第一行第一列最后一行最后一列的元素全更新为2，接着将矩阵除了前两行前两列后两行后两列的元素全更新为2...后面重复此操作直到把最中间那个数更新为N。
代码：
N = int(input('请输入正整数N（1&lt;N&lt;9）:')) l = 2*N-1 t = [] result = [] result = [[0]*l for i in range(l)] s = 0 k = 0 for i in range(1,N+1): for j in range(k,l-s): for z in range(k,l-s): result[j][z] = i k = k+1 s = s+1 for a in result: for b in a: print(b,end='') print() 运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d543a65caf5ac811cc85efbbce50061d/" rel="bookmark">
			用 LangChain 搭建基于 Notion 文档的 RAG 应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何通过语言模型查询 Notion 文档？LangChain 和 Milvus 缺一不可。
在整个过程中，我们会将 LangChain 作为框架，Milvus 作为相似性搜索引擎，用二者搭建一个基本的检索增强生成（RAG）应用。在之前的文章中，我们已经介绍过 LangChain 中的“自查询”（Self-querying）。本质上，LangChain 中的自查询功能就是构建一个基本的 RAG 架构，如图所示：
在 LangChain 中处理 Notion 文档共包含三个步骤：获取、存储和查询文档。获取是指获取 Notion 文档并将内容加载到内存中。存储步骤包括启动向量数据库（Milvus）、将文档转化为向量、将文档向量存储至向量数据库中。查询部分包括针对 Notion 文档进行提问。本文将带大家一一拆解这三个步骤，代码请参考 colab notebook。
01.获取 Notion 文档 用 LangChain 的 NotionDirectoryLoader将文档加载到内存中。我们提供文档的路径并调用load 函数来获取 Notion 文档。加载完毕后，可以得到 Notion 文档的 Markdown 文件。本例中我们以一个 Markdown 文件示意。
接下来，用 LangChain 的 markdown 标题文本分割器。我们向其提供一个分割符列表，然后传入之前命名的 md_file 来获取分割内容。在实际定义headers_to_split_on列表时，请使用自己 Notion 文档的标题。
# Load Notion page as a markdownfile filefrom langchain.document_loaders import NotionDirectoryLoader
path='./notion_docs'
loader = NotionDirectoryLoader(path)
docs = loader.load()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d543a65caf5ac811cc85efbbce50061d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/599cde20c16dc532a328e4f98d466019/" rel="bookmark">
			CUDA和FFMPEG硬件解码视频流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要讲述了通过FFMPEG获取H264格式的RTSP流数据（也可以获取本地视频文件），并通过CUDA进行硬件解码的过程。其他博客给出的教程要么只是给出了伪代码，非常的模糊，要么是基于D3D进行显示，使得给出的源码非常复杂，而无法看出CUDA解码的核心框架，而本文将其他非核心部分剥离出去，视频播放部分通过opencv调用cv::mat显示。
当然本博客的工作也参考了其他博客的内容，CSDN上原创的东西比较难找，大部分都是转载的，所以大家还是积极的贡献力量吧。
本文将分为以下两个部分：
1.CUDA硬件解码核心原理和框架解释；
2.解码核心功能代码的实现
CUDA硬件解码核心原理和框架
做过FFMPEG解码开发的同学肯定都对以下函数比较熟悉avcodec_decode_video2()，该函数实现可以解码从视频流中获取的数据包AVPACKET转化为AV_FRAME,AV_FRAME中包含了解码后的数据。通过CUDA硬件进行解码，最核心的思想就通过回调函数形式来调用CUDA硬件解码接口，对该函数替换，将CPU解码功能转移到GPU中去。
博客给出了一个很好的基础性框架，本文也是借鉴了该博客，该博客中修改了原始的VideoSource，将视频流的获取改为了ffmpeg，而CUDA解码部分框架如下图
1.1 VideoSource
VideoSourceData中包含了CUvideoparser和FrameQueue，通过上图可以看出，CUvideoparser是在VideoDecoder基础上实现了接口的封装，而VideoSource则是通过CUvideoparser进行解码。FrameQueue是存储硬件解码后图像的队列，注意硬件解码完的图像是存放在GPU显存里面了，而VideoDecoder中函数mapFrame，可完成从显存到内存的映射。
1.2 VideoParser
VideoParser中最重要的是三个回调函数，static int CUDAAPI HandleVideoSequence(void *pUserData, CUVIDEOFORMAT *pFormat)， HandlePictureDecode(void *pUserData, CUVIDPICPARAMS *pPicParams)，HandlePictureDisplay(void *pUserData, CUVIDPARSERDISPINFO *pPicParams)，实现对视频格式变换、视频解码、解码后显示等处理功能。HandleVideoSequence主要负责视频格式进行校验，没有实现其他功能，解码函数HandlePictureDecode调用的就是VideoDecoder的解码函数（CUDA的接口），显示函数HandlePictureDisplay完成了解码后GPU图像进入FrameQueue。
1.3 VideoDecoder
该类是最核心的硬件解码功能类，CUVIDDECODECREATEINFO oVideoDecodeCreateInfo_是创建解码信息结构体，CUvideodecoder oDecoder_是最内核的CUDA硬件解码器，VideoParser的解码功能实际上是在CUvideodecoder解码内核上封装实现的（层层封装导致源码有点复杂，所以想看懂实现机制需要有点耐心）。
2 核心解码模块的实现
示例中NvDecodeD3D9.cpp实现了D3D环境的创建，CUDA模块的初始化，其中取视频帧图像显示的函数如下，该函数实现了从解码图像队列取出图像（实际上是显存指针），完成格式转换（NV12到ARGB），最后映射到D3D的Texture进行显示等功能，代码中我给出了关键部位的解释。
bool copyDecodedFrameToTexture(unsigned int &amp;nRepeats, int bUseInterop, int *pbIsProgressive) { CUVIDPARSERDISPINFO oDisplayInfo; if (g_pFrameQueue-&gt;dequeue(&amp;oDisplayInfo)) { CCtxAutoLock lck(g_CtxLock); // Push the current CUDA context (only if we are using CUDA decoding path) CUresult result = cuCtxPushCurrent(g_oContext); //创建解码图像的显存指针，注意存储的是NV12格式的 CUdeviceptr pDecodedFrame[3] = { 0, 0, 0 }; //用于解码图像后进行格式转换 CUdeviceptr pInteropFrame[3] = { 0, 0, 0 }; *pbIsProgressive = oDisplayInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/599cde20c16dc532a328e4f98d466019/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/586733070f2594aa75b7aa2ff12e5b27/" rel="bookmark">
			FileInputStream(文件字节输入流)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们先看一下文件字节输入流
1.构造方法： 构造方法说明FileInputStream(File file)通过打开与实际文件的连接创建一个 FileInputStream，该文件由文件系统中的 File对象 file命名。FileInputStream(FileDescriptor fdObj)创建 FileInputStream通过使用文件描述符 fdObj ，其表示在文件系统中的现有连接到一个实际的文件。FileInputStream(String name)通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 2.首先我们使用文件的路径名来看一下文件字节输入流 我们先创建一个文件，然后记住路径
D:\JAVATest\test
写一下代码来具体看一下
/* java.io.FileInputStream： 1.文件字节输入流，万能的，任何类型的文件都可以采用这个流来读 2.字节的方式，完成输入的操作，完成读的操作(硬盘---&gt;内存) */ public class FileInputStreamTest01 { public static void main(String[] args) { FileInputStream fis=null; //1.创建文件字节输入流对象 //文件路径:D:\JAVATest\test(因为一个\为转义，所以idea中会自动把\变成\\)，或者路径写/也行 //采用了绝对路径的方式 try { fis = new FileInputStream("D:\\JAVATest\\test"); //开始读文件 //方法的返回值是读取到的read本身 // while循环 int readData=0; while((readData=fis.read()) != -1){ System.out.println(readData); } // while ((fis.read())!=-1){ // System.out.println(fis.read()); // } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/586733070f2594aa75b7aa2ff12e5b27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b94a86f1e816f0bcea05cd7d139c9e37/" rel="bookmark">
			【js】SSH隧道远程连接mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.说明 MySQL被部署在某个机器上，为了安全，需要通过一个跳板机进行访问，该跳板机可以有ssh访问，给了一个私钥Key文件和一个通行短语，如果是Python，可以paramiko库跳转连接，相关代码可以参考之前的文章，【python】SSH隧道远程连接mysql
本文是通过nodejs实现，由于我在网上没有找到类似的代码，故自己搞出来之后记录一下，也希望能帮到有跟我一样需求的同学
2.相关模块 因为环境用的是nodejs，所以可以直接使用npm安装就行，需要mysql2和ssh2这两个模块
npm install mysql2 npm install ssh2 3.代码 使用方式就是，首先通过ssh2连接上跳板机服务器，然后再利用forwardOut()方法转发数据，拿到stream，再传给MySQL就可以连接上了，参考代码如下
const mysql = require('mysql2'); const ssh2 = require('ssh2'); const { readFileSync } = require('fs'); const ssh_config = { host: '远程IP', port: 13102, username: 'pan', privateKey: readFileSync("E:\\panmeibing\\dingding\\key"), passphrase: "PQ@L", } const mysqlConfig = { host: '远程IP', port: 3306, user: 'pan', password: '4N3X5l', database: 'walletdb3' } const sshClient = new ssh2.Client(); sshClient.connect(ssh_config) sshClient.on('error', (err) =&gt; { console.log("connect ssh error:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b94a86f1e816f0bcea05cd7d139c9e37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5a1a8ae89172ae81d703a6d73615ece/" rel="bookmark">
			Flutter自定义TextInputFormatter实现金额输入框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、金额输入框智能输入数字、小数点且只能有俩位小数，比如： 0.01、0.1、100
二、这里可以通过继承已有的FilteringTextInputFormatter来实现会更方便些，首先要设置的就是只允许输入数字、小数点 class AmountTextFieldFormatter extends FilteringTextInputFormatter { final int digit; AmountTextFieldFormatter({ this.digit = 2, bool allow = true, }) : super(RegExp('[0-9.]'), allow: allow); ///省略部分代码... } 三、上面这样就限定好了输入内容，接下来就是进行输入的合法判断了 class AmountTextFieldFormatter extends FilteringTextInputFormatter { final int digit; String _oldText = ''; ///省略构造函数 @override TextEditingValue formatEditUpdate( TextEditingValue oldValue, TextEditingValue newValue, ) { final handlerValue = super.formatEditUpdate(oldValue, newValue); String value = handlerValue.text; int selectionIndex = handlerValue.selection.end; ///如果输入框内容为.直接将输入框赋值为0. if (value == '.') { value = '0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5a1a8ae89172ae81d703a6d73615ece/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4f7ad163cb48bfa36c637e0b711fb8e/" rel="bookmark">
			【云原生系列】Kubernetes知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概念
基础架构
单master节点
多master节点
组件
Master节点核心组件
其他组件
请求发送流程
插件
核心资源
调度资源
Pod
创建pod组件间调用流程
pod生命周期：
初始化容器
镜像拉取策略
重启策略
钩子函数
探针
探针的实现方式
DownwardAPI
ReplicationController
ReplicaSet
Deployment
更新 Deploymen
回滚 Deployment
更新 Deployment 的注意事项
StatefulSet
DaemonSet
CronJob
HPA
配置资源
ConfigMap
创建ConfigMap的四种方式
应用方式
Secret
Secret常用类型：
进行加密
configMap和secret区别
服务发布
Service
service作用
服务访问
支持多种访问方式实现
Ingress
Ingress Controller
路径匹配方式
数据存储
Volume
PV和PVC
PV回收策略（persistentVolumeReclaimPolicy）
访问模式（accessModes）
存储分类
高级调度
容忍和污点
设计理念
配置解析
创建污点
创建容忍
Taint常用命令
准入控制
Resources指定pod资源限制
命名空间资源配额
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4f7ad163cb48bfa36c637e0b711fb8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03bd6643baf1c2ae3dd72cdcd8e95ff4/" rel="bookmark">
			FFmpeg 集成 x265 编译及解码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		x265 是一个免费的软件库和应用程序，用于将视频流编码为 H.265/MPEG-H HEVC 压缩格式，并在 GNU GPL 条款下发布。
FFmpeg 为了支持 H.265 编、解码可以集成 x265 编译，在编译 FFmpeg 之前需要先编译 x265，但并不是所有的版本都能直接使用，比如笔者同时编译 Android、Window 和 Linux 三个平台时，使用 Android NDK r21e 会遇到很多报错，符号缺失，无法编译 .S 文件都是可能遇到的问题。
一、x265 编译 下面的编译统一都使用 ubuntu 18.04 版本进行。编译目录结构如下：
其中 i686 &amp; x86_64 和平台相关，这里是 window 平台示例。 Android 上 arm 平台是 armeabi-v7a &amp; arm64-v8a。x265 目录内放置 x265 的源码。
编译的时候 cd x265 工程 &amp; ./build_x265.sh 即可。然后同级的 build 目录会输出相应的编译产物。
1. 交叉编译 Android 使用的 x265 前置条件使用 android-ndk-r21e linux 版本。编译脚本内容如下：
build_x265.sh
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03bd6643baf1c2ae3dd72cdcd8e95ff4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32d81269b55019db66393fa8b2da6036/" rel="bookmark">
			rest_framework_django 学习笔记二（视图路由）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rest_framework_django 学习笔记二（视图路由） rest_framwork_django学习笔记一(序列化器)
一、rest framework 中Request 与 Response 1、Request REST framework 传入视图的request对象不再是Django默认的HttpRequest对象，二是REST Famework 提供的扩展了 Http Request 类的Request 类的对象。
REST framework 提供了 Parser 解析器，在接受到请求后悔自藕丁工具Content-Type 指明的请求数据类型（如JSON、表单等）将请求数据就行parse 解析，解析为类字典对象保存到Request对象中。
Request对象的数据时自动工具前端发送的哪种格式的数据，我们都可以以统一的方式读取数据。
常用属性 1).data request.data 返回解析之后的请求数据 类似于django中标准的 request.POST 和request.FILES属性，但提供如下特性：
包含了解析之后的文件和非文件数据；包含了对POST，PUT，PATCH请求方式解析后的数据；利用REST ftamework 的parsers 解析器，不仅支持表单类型数据，也支持JSON数据； 2）.query_params request.query_params 与 django标准的 request.GET 相同，只是更换了更准确的名称而已。
2、Response rest_framework.response.Response REST framework 提供了一个响应类 Response，使用该类构造响应对象时，响应的具体数据内容会被转换（render渲染）成符合前端需求的类型。
REST framework 提供了 Renderer 渲染器，用来工具请求头中的 Accept （接收数据类型声明）来自自动转换响应数据到对应格式。如果前端请求中为进行 Accept 声明，则会采用默认方式处理响应数据，我们可以通过配置来修改默认响应格式。
# settings.py # ================================================= # # ***************** REST_FRAMEWORK **************** # # ================================================= # REST_FRAMEWORK = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32d81269b55019db66393fa8b2da6036/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f3fb5eeb59cf59766aa773a21062486/" rel="bookmark">
			rest_framework_django学习笔记一(序列化器)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rest_framework_django学习笔记一(序列化器) 一、引入Django Rest Framework 1、安装 pip install djangorestframework 2、引入 INSTALLED_APPS = [ ... 'rest_framework', ] 3、原始RESTful接口写法 models.py
from django.db import models ''' 测试数据 仅供参考 INSERT INTO `demo_app_author` VALUES (1, '令狐冲', 25, 1); INSERT INTO `demo_app_author` VALUES (2, '任我行', 58, 2); INSERT INTO `demo_app_author` VALUES (3, '任盈盈', 23, 3); INSERT INTO `demo_app_author` VALUES (4, '扫地僧', 99, 4); INSERT INTO `demo_app_author` VALUES (5, '乔峰', 99, 5); INSERT INTO `demo_app_authordetail` VALUES (1, 1, '13432335433', '华山', '1994-05-23'); INSERT INTO `demo_app_authordetail` VALUES (2, 1, '13943454554', '黑木崖', '1961-08-13'); INSERT INTO `demo_app_authordetail` VALUES (3, 0, '13878934322', '黑木崖', '1996-05-20'); INSERT INTO `demo_app_authordetail` VALUES (4, 0, '13878938322', '少林', '1996-05-20'); INSERT INTO `demo_app_authordetail` VALUES (5, 0, '13878939322', '大宋', '1996-05-20'); INSERT INTO `demo_app_book` VALUES (1, '笑傲江湖', 33.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f3fb5eeb59cf59766aa773a21062486/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f256c7f6915f319e822625e61d19d81/" rel="bookmark">
			OpenCV快速入门：彩蛋——小游戏制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、游戏玩法1.1 核心玩法1.2 特殊事件 二、功能模块划分2.1 主游戏文件 (`main.py`)2.2 游戏对象 (`game_objects.py`)2.3 游戏逻辑 (`game_logic.py`)2.4 事件和奖励 (`events_and_rewards.py`)2.5. 游戏界面 (`game_ui.py`) 三、完整代码3.1 主游戏文件 (`main.py`)3.1.1 游戏初始化3.1.2 主游戏循环3.1.3 游戏结束 3.2 游戏对象 (`game_objects.py`)3.2.1 `GameObject` 类3.2.2 `Player` 类3.2.3 `Monster` 类3.2.4 `Bullet` 类 3.3 游戏逻辑 (`game_logic.py`)3.3.1 `GameLogic` 类3.3.2 方法 3.4 事件和奖励 (`events_and_rewards.py`)3.4.1 `EventsAndRewards` 类3.4.2 方法 3.5 游戏界面 (`game_ui.py`)3.5.1 `GameUI` 类3.5.2 绘制UI的方法3.5.3 升级菜单 总结 前言 在这篇博客是一个小彩蛋，我们将探索如何使用Python和OpenCV库来制作一个简单的塔防小游戏（虽然OpenCV的设计初衷并不是用来做游戏的）。我们将详细介绍游戏的玩法以及其功能模块的划分。
一、游戏玩法 这个游戏是一个垂直滚动的射击游戏。玩家培养一个位于屏幕底部的可以向上射击的角色，目的是击败出现在屏幕上部的各种怪物。游戏随着时间的推移，难度会逐渐增加。
1.1 核心玩法 怪物生成：游戏会定期生成不同类型的怪物，随着时间增长，怪物出现的频率会加快。射击机制：玩家角色会向上射击，击中怪物后可以获得分数、金钱和经验值。升级系统：玩家可以使用金钱来升级子弹，例如增加子弹速度、穿透能力或添加追踪功能。 1.2 特殊事件 游戏中还包含只有在特定条件下才会触发的特殊事件，如“bonus_coin”, “sudden_attack”, “treasure_chest”，为游戏增添额外的乐趣和挑战。 二、功能模块划分 游戏的代码被划分为几个主要的模块，每个模块都承担着特定的功能。
2.1 主游戏文件 (main.py) 初始化游戏窗口和实体：设置窗口大小并创建玩家、怪物等游戏实体。游戏循环：包含游戏的主要循环，控制怪物的生成和子弹的射击，处理游戏逻辑和UI更新。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f256c7f6915f319e822625e61d19d81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fe21ff95eb17a9ce4025a4b0e10a0b0/" rel="bookmark">
			SQL语法实践（三）：一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Q:What’s the difference between INNER JOIN, LEFT JOIN, RIGHT JOIN and F
ULL JOIN? [duplicate]
A:点击跳转链接到原文
There are different types of joins available in SQL:
INNER JOIN: returns rows when there is a match in both tables.
LEFT JOIN: returns all rows from the left table, even if there are no matches in the right table.
RIGHT JOIN: returns all rows from the right table, even if there are no matches in the left table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fe21ff95eb17a9ce4025a4b0e10a0b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c34ed866b3a6b4145c9f1ba110b05a42/" rel="bookmark">
			C#队列（Queue）及泛型类(Queue＜T＞)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		队列实现先进先出，有装箱拆箱行为，可存放任意类型，但无法获取指定位置元素，只能取出最先存储的元素。
一、基本队列操作
1、向队列添加元素（Enqueue）
Queue queue = new Queue(); queue.Enqueue(1); queue.Enqueue("道，可道，非常道。"); queue.Enqueue(1.21); queue.Enqueue("白马非马。"); queue.Enqueue(-5.68); queue.Enqueue("事虽难，做则必成。"); 2、获取队列长度（Count）
Console.WriteLine("队列长度：" + queue.Count); 3、队列遍历
if (queue != null &amp;&amp; queue.Count &gt; 0) { foreach (var item in queue) { Console.WriteLine(item); } } 4、读取取出(Peek)
Console.WriteLine("队列读取取出"); var value = queue.Peek(); Console.WriteLine(value); 5、删除取出(Dequeue)
Console.WriteLine("队列删除取出"); var value1 = queue.Dequeue(); Console.WriteLine(value1); 6、判断元素是否存在(Contains)
Console.WriteLine("判断队列中元素是否存在"); if (queue.Contains(1.21)) { Console.WriteLine("队列中存在1.21"); } 7、清空队列（Clear）
Console.WriteLine("清空队列"); queue.Clear(); 二、泛型类队列
1、示例
Queue&lt;string&gt; queue = new Queue&lt;string&gt;(); queue.Enqueue("远上寒山石径斜"); queue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c34ed866b3a6b4145c9f1ba110b05a42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d74c3194c81cf05a71421cd4814754ba/" rel="bookmark">
			echo -e 终端颜色定制的例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/usr/bin/bash
RESET="\033[0m"
BLACK="\033[30m"
RED="\033[31m"
GREEN="\033[32m"
YELLOW="\033[33m"
BLUE="\033[34m"
MAGENTA="\033[35m"
CYAN="\033[36m"
WHITE="\033[37m"
BOLDBLACK="\033[1m\033[30m"
BOLDRED="\033[1m\033[31m"
BOLDGREEN="\033[1m\033[32m"
BOLDYELLOW="\033[1m\033[33m"
BOLDBLUE="\033[1m\033[34m"
BOLDMAGENTA="\033[1m\033[35m"
BOLDCYAN="\033[1m\033[36m"
BOLDWHITE="\033[1m\033[37m"
CLREND="\033[0m"
echo -e ${BLACK}BLACK{CLREND}
echo -e ${RED}RED${CLREND}
echo -e ${GREEN}GREEN${CLREND}
echo -e ${YELLOW}YELLOW${CLREND}
echo -e ${BLUE}BLUE${CLREND}
echo -e ${MAGENTA}MAGENTA${CLREND}
echo -e ${CYAN}CYAN${CLREND}
echo -e ${WHITE}WHITE${CLREND}
echo -e ${BOLDBLACK}BOLDBLACK${CLREND}
echo -e ${BOLDRED}BOLDRED${CLREND}
echo -e ${BOLDGREEN}BOLDGREEN${CLREND}
echo -e ${BOLDYELLOW}BOLDYELLOW${CLREND}
echo -e ${BOLDBLUE}BOLDBLUE${CLREND}
echo -e ${BOLDMAGENTA}BOLDMAGENTA${CLREND}
echo -e ${BOLDCYAN}BOLDCYAN${CLREND}
echo -e ${BOLDWHITE}BOLDWHITE${CLREND}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/537daf945ea9405ed5978cd4c5a0da9b/" rel="bookmark">
			使用jquery实现倒计时，正计时，且支持页面上多个时间分别倒计时与正计时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 该功能一共有三个核心技术点
（1）减时间
（2）增时间
（3）减时间到0之后，开始增时间
（4）页面上多个时间，该增加的增加，该减少的减少
小声嘀咕：好像说了跟没说一样。。。
正片 成果 不想看长篇大论的可以直接拿走代码运行
&lt;html&gt; &lt;body&gt; &lt;p&gt; &lt;font color=red&gt;已超时：&lt;span class='add_day'&gt;1&lt;/span&gt;天&lt;span class='add_hour'&gt;2&lt;/span&gt;时&lt;span class='add_minute'&gt;8&lt;/span&gt;分&lt;span class="add_second"&gt;30&lt;/span&gt;秒&lt;/font&gt; &lt;/p&gt; &lt;p&gt; &lt;font color=red&gt;已超时：&lt;span class='add_day'&gt;5&lt;/span&gt;天&lt;span class='add_hour'&gt;23&lt;/span&gt;时&lt;span class='add_minute'&gt;59&lt;/span&gt;分&lt;span class="add_second"&gt;55&lt;/span&gt;秒&lt;/font&gt; &lt;/p&gt; &lt;p&gt; &lt;font color=red&gt;已超时：&lt;span class='add_day'&gt;0&lt;/span&gt;天&lt;span class='add_hour'&gt;1&lt;/span&gt;时&lt;span class='add_minute'&gt;0&lt;/span&gt;分&lt;span class="add_second"&gt;45&lt;/span&gt;秒&lt;/font&gt; &lt;/p&gt; &lt;p&gt; &lt;span class='sub_text'&gt;剩余时间：&lt;span class='sub_day'&gt;0&lt;/span&gt;天&lt;span class='sub_hour'&gt;1&lt;/span&gt;时&lt;span class='sub_minute'&gt;1&lt;/span&gt;分&lt;span class="sub_second"&gt;20&lt;/span&gt;秒&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span class='sub_text'&gt;剩余时间：&lt;span class='sub_day'&gt;1&lt;/span&gt;天&lt;span class='sub_hour'&gt;0&lt;/span&gt;时&lt;span class='sub_minute'&gt;30&lt;/span&gt;分&lt;span class="sub_second"&gt;45&lt;/span&gt;秒&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span class='sub_text'&gt;剩余时间：&lt;span class='sub_day'&gt;5&lt;/span&gt;天&lt;span class='sub_hour'&gt;2&lt;/span&gt;时&lt;span class='sub_minute'&gt;0&lt;/span&gt;分&lt;span class="sub_second"&gt;3&lt;/span&gt;秒&lt;/span&gt; &lt;/p&gt; &lt;/body&gt; &lt;script src="https://code.jquery.com/jquery-3.7.1.slim.min.js" integrity="sha256-kmHvs0B+OpCW5GVHUNjv9rOmY0IvSIRcf7zGUDTDQM8=" crossorigin="anonymous"&gt;&lt;/script&gt; &lt;!-- &lt;script src="https://code.jquery.com/jquery-3.7.1.slim.min.js" integrity="sha256-kmHvs0B+OpCW5GVHUNjv9rOmY0IvSIRcf7zGUDTDQM8=" crossorigin="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/537daf945ea9405ed5978cd4c5a0da9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/226abecb1fad17286dd31db1318e2fa0/" rel="bookmark">
			游戏动作师效能汇报以及交接流程规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 游戏动作师效能汇报以及交接流程规范
效能部分
一段300帧以内的表演类或连招动作手K大概需要2-3天时间。（不含蒙皮时间）当然也根据内容的复杂程度而定，一般会预出1-2天。
一般蒙皮会给予1-2天的时间（根据蒙皮精细程度），高模带表情蒙皮可能会需要2-3天。
常规走跑跳攻击等动作，一套动作给予2-3天或一周（根据动作精细程度和复杂度而定）完成。
若有动捕数据的情况下，则相等的动画时长，时间缩短为0.5-1天。精度若要求非常高，则时间与手K时间基本相同甚至更长（工作流程不同）。但设计时间，将另外计算，若策划负责把控演员的内容，动作师掌机的时间不算在工期内。
动捕设备能够大幅提高动画师在制作真实类动画时的效率和效果。（通常手K和动捕精修，服务的项目不一样，工艺流程不同，所以也不能完成相提并论，主要还是要根据项目情况而定。例如王者荣耀使用动捕则没必要，也和美术呈现不搭；而PUBG需要真实感，单纯靠手K出细节，则费时费力，同时效果还很难达到需要呈现的效果。）
模型师交接
通常来说，模型师的模型规范，一定程度上也会影响动作师的时间，比如模型轴点、模型焊接、布线、对称性、比例大小、模型拆分、三角面这类常见问题一般模型师需要去注意，通常交由动作师时会进行复检，发现问题第一时间交返模型师进行修改调整。
需要注意的方面：
模型的轴点是否完全处于0点模型是否存在孤立点或未焊接的点关节部位的布线合理性（是否足够或走向正确）模型的单位高度要严格按照160cm、170cm、180cm等真人比例数值输出，同时单位统一为厘米；比例方面，注意同类型或同性别的角色手脚长度，特别是末端位置的统一性，方便动作师重新封套蒙皮，减少同类型角色的重复蒙皮工作。模型师要确保模型布线的对称性，尽量避免过多三角面的产生，这样会对动作师蒙皮工作效率造成极大影响。模型拆分，应按照程序架构设定进行拆分，例如：头部与身体分开，上身与下身分开，身体和衣服分开，同一个模型拆分的肢体，通常会放在同一个文件内，在编辑软件中根据肢体名称进行拼音或英文命名。例如：head、body、L_eyes/R_eyes等三角面在交付时也应当注意，因为三角面无法进行循环或环形等快捷操作，同时不好观察布线走向，导致动作师蒙皮工作效率大幅下降。 在此需要注意一点的还有，模型师的模型命名规范和文件内模型命名问题，一定程度上，会影响动作师整理资产时的工作量，所以在交付的时候应按照以下规范进行：
贴图以及模型（若包含高低模则需一并输出）打包交付，同时文件名为：角色名+序列号、项目+角色名、职业+角色名、职业+代号，例：女武士A001、NPC_001、火线部队_炮兵。贴图部分，通常都会以H、M、D区分高、中、低模或贴图精度，该位图不仅在制作动作时需要应用，还会经动作师交付程序，方便引擎调用资产。通常格式为：角色名+精度标注，位图功能+精度标注。 3、一般来说，模型师需要将贴图文件和模型文件分别建立文件夹，命名规范通常为Tex（贴图）、max（常规导出为FBX，文件夹名称以动画师的编辑软件名称命名，通常动画师会直接将源文件放在里面）。
动作师拿到模型后，确认没有问题，再进行制作。
策划对接
策划首先需要在动作需求表上，填写好需要制作的动作需求以及描述，策划在与动作沟通之前，应先与程序沟通实现可行性，确保想法可落实（通常在前期时策划与程序在搭建前已经沟通清楚和确定内容实现方式，若是一次性的内容则，每一次策划都需要和程序确认清楚实现方式和内容），故，在填写动作需求表时，时间与呈现方式（是否循环）都是根据程序实现的逻辑和架构去撰写的，别乱写，会导致程序和动作掐架，然后再被程序和动作联合胖揍。
常见需要具化的内容：
是否循环（通常是走跑待机类型，需要循环）是否原地（通常是进行攻击状态时）动作内容（如果没有具体要求，则要写明技能描述或属于是什么类型的动作）时间区间（通常是关乎衔接和存在时间，这个是策划前期规划好，并且程序已经写好的，比如，攻击的时间是0.5-1秒，则相当于是15-30帧，也可直接写秒；如果没有则不写，通常为出场动画或舞蹈等一次性的内容） 5、截止日期或优先级（通常是根据整体的进度表，限定时间完成或标明优先级，通常是存在多个需求时，告知动作师程序实现动作时间节点的）
动作师在进行动作制作之前和完成每个阶段，策划和动作一般都会实时跟动作进行沟通，确保动作符合达到策划需要的效果。
6、衔接动作（若没有特殊要求，则默认为衔接待机）
动作师工作流程与规范
动作师工作流程：检查模型以及文件命名、skin制作、动作制作、导出FBX、打包资源
1、动作师制作完蒙皮后，禁止里面K帧，保存无动画，并以角色名称+skin命名，保存一份源文件。
2、一般来说，动作名称通常是角色名+动作名称，例如：女武士_walk、女武士_run；若表演动作居多，内容比较复杂，难以用英文或拼音阐述，则直接在名称上说明，例如：介绍公司、扭头走、可爱舞蹈等。通常来说，动作会有动作需求表，策划会将动作进行分类标注并描写具体需求（该部分直接影响到程序实现和衔接方面的问题）。
3、制作完动作后，除skin为模型和骨骼无动画导出，其他动作皆只需导出骨骼，并确保动画帧数完全导出，格式为FBX，命名与源文件相同。
4、整理资源打包上传至引擎，只需要将FBX与贴图上传即可，请勿上传源文件（max格式）。
动作师文件规范需要注意：
骨骼是否在0点若要根骨骼，根骨骼需要始终保持各项数值归0，同时根据程序实现方式，进行层级建立，通常根骨骼命名为root，位于最高层级。在skin制作时就需要建立，并且保证所有的动作文件都包含。特殊情况，是直接附加在质心上，该情况只出现在技美或程序单独开发的脚本或插件时，根据技美或程序的要求建立。需要衔接的动作，要保证衔接帧之间的一致性。导出时注意单位是否正确，以及骨骼朝向（一般为Y轴朝上）。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d9729781babf344f3f394e3c3c26f17/" rel="bookmark">
			【C&#43;&#43;】异常处理 ① ( 异常概念引入 | 抛出异常语法 | 捕获异常语法 | 异常捕获流程 | 异常处理代码示例 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、异常处理1、异常概念引入2、抛出异常语法3、捕获异常语法4、异常捕获流程 二、异常处理代码示例1、错误代码示例 - 抛出异常 / 不捕获异常2、正确代码示例 - 抛出异常 / 捕获异常3、正确代码示例 - 抛出异常 / 捕获异常不处理继续抛出异常 一、异常处理 1、异常概念引入 异常是一种 特殊的程序流控制机制 , 用于处理程序中可能出现的错误或异常情况 ;
当程序执行错误时 , 由 throw 关键字抛出异常 , 并即跳转到相应的异常处理程序中 ; 如果没有适当的异常处理程序处理该异常 , 程序会崩溃终止 ;
异常与函数对比 :
函数 是一种 以 栈结构 展开的上下函数衔接的程序控制系统 ;异常 是一种 特殊的程序流控制机制 , 用于处理程序中可能出现的错误或异常情况 ; 异常 依附于栈结构 , 却可以同时设置多个 异常类型 作为 异常捕获条件 ; 异常是跨函数的 , 下图中 函数 f 调用 函数 g , 函数 g 调用 函数 h ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d9729781babf344f3f394e3c3c26f17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06e3c0a6df0f64d21a6db3f172f3f6b3/" rel="bookmark">
			Cytoscape软件下载、安装、插件学习[基础教程]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 今天分享的内容是自己遇到问题后，咨询社群里面的同学，帮忙解决的总结。
关于Cytoscape，对于做组学或生物信息学的同学基本是陌生的，可能有的同学用这个软件作图是非常溜的，做出来的网络图也是十分的好看，“可玩性”很高，就像前面分享的aPEAR包一样aPEAR包绘制功能富集网络图。自己在前面写论文的时候也是一直在使用，以前使用的版本是3.3.0的版本。但是，时间一长，很多操作都忘记。今天，在自己的台式机上使用Cytoscape软件，想要安装插件，但是发现3.3.0这个版本安装不了。随后，在社群咨询，各位同学也给出目前各自正常使用的版本。我们也就此机会，记录一下，分享一下。
注意：考虑到Cytoscape安装包下载，需要开梯子，我们这里已经下载好了对应的包，大家可以回复关键词获得链接。
后台回复关键词：20231129或Cytoscape即可获得下载链接
一、Cytoscape下载网址 https://cytoscape.org/
下载最新版本
由于最新版本，有同学反应无法下载插件，我们在这里就不安装最新的版本。下载 Old Version
下载对应的版本
我们在这里一共下载了3.8.0-3.9.1的版本.
4.下载对应的版本
注意：考虑到Cytoscape安装包下载，需要开梯子，我们这里已经下载好了对应的包，大家可以回复关键词获得链接。
二、安装软件 点击安装包
下载JAVA（若你没下载Java，可点击直接下载。PS：自己开了VPN后，下载速度还是很快的）
依次点击Netx进行安装
安装位置，任何软件不建议安装在C盘
安装成功
三、安装插件 打开Cytoscape软件
点击Apps-App manager
目前，Cytoscape中总的有252个插件搜索自己需要安装的插件名称
点击安装
安装结束后，可以在Apps进行管理和查看
PS：若你开了梯子下载速度会更快些，不开也不影响，只是速度相对慢一点而已。
插件操作学习 对于初学者，我们这里借用SCIPainter(基迪奥)中莫北老师的教程进行操作，对于初学者很是的友好.网络图分析工具Cytoscape快速上手
导入数据
2. 调整
3， 导出数据
往期文章： 1. 复现SCI文章系列专栏
2. 《生信知识库订阅须知》,同步更新，易于搜索与管理。
3. 最全WGCNA教程（替换数据即可出全部结果与图形）
WGCNA分析 | 全流程分析代码 | 代码一
WGCNA分析 | 全流程分析代码 | 代码二
WGCNA分析 | 全流程代码分享 | 代码三
WGCNA分析 | 全流程分析代码 | 代码四
WGCNA分析 | 全流程分析代码 | 代码五(最新版本)
4. 精美图形绘制教程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06e3c0a6df0f64d21a6db3f172f3f6b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b71fb5de764a33e9deddffc42aea501a/" rel="bookmark">
			qt编译出现 “常量中有换行符”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在qt编译过程中出现“常量中有换行符”，原因有以下几点（qt版本5.14.1）
1.中文编码格式问题，在qt：工具-外部-配置里选择 文本编辑器-行为-默认编码选为UTF-8，UTF-8 BOM选为如果编码是UTF-8则添加。
2.依旧采用默认编码，在需要使用中文的地方使用QStringLiteral(“text”)来进行转码
3.编译方式问题，如果qt采用的MSVC编译，代码文件是无BOM的utf-8编码格式,可以切换为GW编译，或者在pro文件里加入以下代码:
msvc {
QMAKE_CFLAGS += /utf-8
QMAKE_CXXFLAGS += /utf-8
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b764b734c08cec5283c26f9c0672f7ee/" rel="bookmark">
			『heqingchun-Ubuntu系统&#43;设置pip加速』
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu系统+设置pip加速 安装pip
sudo apt install pip 设置加速
pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple Ubuntu系统+设置pip加速-完毕
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f69003ab838d85c0867b93f31d54d8d/" rel="bookmark">
			数据可视化 Python Matplotlib Plotly
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Matplotlib 1.安装Matplotlib $ python -m pip install --user matplotlib 2.Matplotlib官网 Matplotlib documentation — Matplotlib 3.8.2 documentation
3.函数 1.导入模块pyplot，指定别名plt 模块pyplot包含很多用于生成图表的函数
import matplotlib.pyplot as plt 2.subplots() 在一张图片中绘制一个或多个图表
变量fig表示整张图片。变量ax表示图片中的各个图表。
参数figsize指定生成的图形的尺寸，单位为英寸
参数dpi传递分辨率
fig, ax = plt.subplots() fig, ax = plt.subplots(figsize=(15, 9), dpi=128) 3.plot() 根据给定的数据绘制图表
第一个参数输入值
第二个参数输出值
参数linewidth决定了plot()绘制的线条粗细。
参数alpha指定颜色的透明度。alpha值为0表示完全透明，为1（默认）表示完全不透明
参数c指定颜色
ax.plot(input_values, squares, linewidth=3) ax.plot(dates, lows, c='blue', alpha=0.5) 4.show() 打开Matplotlib查看器并显示绘制的图表
plt.show() 5.set_title() 给图表指定标题
参数fontsize指定图表中文字大小，6，7同
ax.set_title("Square number", fontsize=24) 6.set_xlabel() x轴设置标题
ax.set_xlabel("value", fontsize=14) 7.set_ylabel() y轴设置标题
ax.set_ylabel("value's Square number"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f69003ab838d85c0867b93f31d54d8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08aff32fb9b133817cf7cea64da4bf44/" rel="bookmark">
			立刻解决缺少msvcp140_1.dll解决方法，msvcp140_1.dll修复指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常使用电脑的过程中，我们有时会遇到由于某些重要的DLL文件缺失而导致的程序无法正常启动的问题。很多用户可能都经历过由于缺少msvcp140_1.dll导致应用程序无法运行的情况。本文将为你提供解决msvcp140_1.dll缺失问题的详尽方法，附带对每种方法优点和缺点的分析，以及msvcp140_1.dll文件的相关属性和作用解读，下面我们一起来看看吧。
一.msvcp140_1.dll文件简介 msvcp140_1.dll是一个属于MicrosoftVisualC++RedistributablePackages的DLL文件。这是一组运行时库，通常用于运行用VisualC++开发的应用程序。这个DLL文件包含了运行C++应用程序时所需的标准C++库函数。
二.msvcp140_1.dll文件属性 -文件名称：msvcp140_1.dll
-文件类型：DynamicLinkLibrary(DLL)
-大小：通常几百KB不等
-版本：与安装的VisualC++版本相关
文件作用：
-提供执行C++库中定义的函数和资源。
-支持基于C++的应用程序运行。
三.msvcp140_1.dll解决方法及其优缺点分析 方法一：重新安装相关的VisualC++Redistributable 步骤：
1.访问Microsoft官方网站下载最新的VisualC++Redistributable。
2.下载对应系统版本（32位或64位）的安装包。
3.双击安装程序并遵循安装向导完成安装。
优点：
-官方推荐的解决方法，安全可靠。
-能够确保DLL文件与系统和应用程序兼容。
-更新到最新版本，避免其他潜在的兼容性问题。
缺点：
-下载和安装过程可能需要一定的时间。
-不一定能解决所有因msvcp140_1.dll缺失引起的错误。
方法二：手动下载并替换msvcp140_1.dll文件 步骤：
1.从可信赖的源下载msvcp140_1.dll文件。
2.将下载的DLL文件复制到通常位于C:\Windows\System32的目录（对于64位系统，还应复制到C:\Windows\SysWOW64目录）。
3.重启电脑并检查应用程序是否可以正常启动。
优点：
-快速解决特定应用程序无法启动的问题。
-对于无法通过其他方式解决的单一DLL文件缺失情况有效。
缺点：
-来源不明可能造成安全风险。
-若操作不当可能导致系统稳定性问题。
-不保证与其他系统组件的完全兼容性。
方法三：使用系统文件检查器工具 步骤：
1.打开“命令提示符”（以管理员身份运行）。
2.输入命令：sfc/scannow，然后按回车键。
3.系统会自动扫描并修复缺失或损坏的系统文件。
优点：
-官方系统工具，无需下载其他软件。
-能够修复并恢复系统文件，提高系统稳定性。
缺点：
-扫描和修复过程可能需要较长时间。
-在某些情况下，该工具可能无法修复具体的DLL文件缺失问题。
方法四：使用dll修复工具 如果你觉得上面的方法都太复杂了，想要简单一点的，那么可以直接使用dll修复工具来解决这个问题。
在任意的浏览器上车俞入：dll修复.site 然后按确认Enter键就可以了
进入站点之后下载，直接使用就可以了
点击一键修复dll错误的按钮，就会自动的帮你扫描电脑系统中缺失的dll文件
等扫描完毕后，再点击修复，然后静待修复完成就可以了。
最后就是关机重启一下就能修复msvcp140_1.dll完成。（也可以选择手动修复，在dll修复工具上，选择手动修复，然后输入msvcp140_1.dll文件，直接查找，下载安装就可以了。）
DLL修复工具_一键修复所有dll缺失msvcp140.dll丢失的解决方法–电脑修复精灵
方法五：执行系统还原 如果前面的方法都没有解决问题，可以尝试执行系统还原来回退到保存有完整msvcp140_1.dll文件的还原点。
步骤：
1.进入控制面板，选择系统和安全&gt;系统&gt;系统保护。
2.单击“系统还原”按钮，按照提示选择一个还原点。
3.执行还原过程，根据提示重启电脑。
优点：
-可以解决因系统更改导致DLL文件缺失的问题。
-不需要用户具备太多的技术知识。
缺点：
-可能导致最近安装的应用程序或系统更新丢失。
-需要之前创建过系统还原点。
msvcp140_1.dll是保证基于VisualC++开发的应用程序正常运行的重要组件。面临其缺失的问题时，需要权衡可能丢失的数据和设置。用户在选择解决方案时，应根据自己的情况和技术能力做出决策。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08aff32fb9b133817cf7cea64da4bf44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66f0679fc0c62d10392b49c5a94c838c/" rel="bookmark">
			Error: error:0308010C:digital envelope routines::unsupported（Vue2项目报错）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在 终端输入 npm run dev 命令，项目运行报错
Error: error:0308010C:digital envelope routines::unsupported
问题原因 node 版本过高，可以在命令行 输入 node -v 查看版本
因为 Node.js 版本是 17 以上所以会运行失败， Node.js 17 版本中最近发布的 OpenSSL3.0, 而OpenSSL3.0 对允许算法和密钥大小增加了严格的限制，可能会对生态系统造成一些影响.
解决办法 方法一（配置 node 选项--openssl-legacy-provider） 这个好像可以直接通过 cmd 在终端里运行（但是我的电脑没有效果）
windows 环境下 set NODE_OPTIONS=--openssl-legacy-provider mac 或者 linux 环境下 export NODE_OPTIONS=--openssl-legacy-provider 小改进 刚开始我在 cmd 终端输入相关命令没有效果，发现是自己的操作有些问题，其实是要在项目文件里面进行操作，要修改 自己项目的 package.json 文件，在里面新建一个命令 dev_t （名字自己随意取），加上相关的指令
"dev_t": "set NODE_OPTIONS=\"--openssl-legacy-provider\" &amp; npm run dev\n" 然后运行 npm run dev_t , 错误解决，成功运行
方法二（降级 nodejs 版本到 16.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66f0679fc0c62d10392b49c5a94c838c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2204d5a8ade7a005dc0aba92f7163aed/" rel="bookmark">
			升级openssh以及回滚，telnet远程链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
安装telnet
编译安装openssl
解压并编译安装OpenSSH
修改配置允许root用户远程登录
测试没问题后开启防火墙关闭telnet
回滚办法（如果没有备份的话）
安装telnet 为了防止升级安装失败，无法使用ssh做远程连接，因此安装telnet预防
环境
#查看当前版本 ssh -V #关闭防火墙 systemctl stop firewalld setenforce 0 安装
yum install telnet-server -y yum install telnet -y 启动telnet服务
systemctl enable telnet.socket systemctl start telnet.socket 安全文件关闭或者修改(否则root无法telnet登录)
默认情况下，系统是不允许root用户telnet远程登陆的，如果要使用root用户直接登录
echo 'pts/0' &gt;&gt;/etc/securetty echo 'pts/1' &gt;&gt;/etc/securetty 编译安装openssl 官网下载安装包：openssl官网
https://www.openssl.org/source/old/ 依赖
yum install wget gcc openssl-devel pam-devel rpm-build zlib-devel -y 下载
wget https://www.openssl.org/source/old/1.1.1/openssl-1.1.1t.tar.gz 解压
tar xf openssl-1.1.1t.tar.gz -C /usr/local 进入openssl目录
cd /usr/local/openssl-1.1.1t 编译
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2204d5a8ade7a005dc0aba92f7163aed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cae664e4c580f31daab5c18e141872be/" rel="bookmark">
			从分子到画面：使用Anaconda安装PyMOL的终极指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们需要在生物信息学或分子生物学领域进行可视化和分析工作时，PyMOL是一个强大的工具。PyMOL是一个开源的分子可视化软件，允许用户可视化分子结构、进行蛋白质建模、分析生物分子等。本文将介绍如何使用Anaconda来下载和安装PyMOL。
步骤一：创建一个新的conda环境（可选但建议） 为了隔离PyMOL及其依赖项，我们建议创建一个新的conda环境。确保PyMOL安装不会与其他环境冲突。运行以下命令来创建一个新环境并激活它：
conda create -n mypymolenv python=3.7 conda activate mypymolenv 这将创建一个名为mypymolenv的新环境，并使用Python 3.7版本。根据需要更改环境名称和Python版本。
步骤二：添加Bioconda存储库 Bioconda是一个专门用于生物信息学工具的conda存储库，PyMOL也在其中。为了安装PyMOL，我们需要将Bioconda存储库添加到我们的conda配置中。运行以下命令：
conda config --add channels conda-forge conda config --add channels defaults conda config --add channels bioconda 这将添加Bioconda存储库以便后续安装PyMOL。
步骤三：安装PyMOL 现在，我们可以使用conda命令来安装PyMOL及其依赖项：
conda install pymol 根据提示进行安装。conda会自动解决依赖关系并下载所需的软件包
步骤四：启动PyMOL 安装完成后，通过运行以下命令在终端中启动PyMOL：
pymol PyMOL的图形用户界面应该随之启动，使可以开始可视化和分析生物分子。
总结起来，使用Anaconda来下载和安装PyMOL是一个简单而强大的过程。通过创建一个隔离的conda环境，并添加Bioconda存储库，可以轻松地安装和管理PyMOL及其依赖项，为生物信息学和分子生物学研究提供了强大的工具。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/618474258a62b45b04c2a40cd8227551/" rel="bookmark">
			麒麟操作系统用户密码忘记并锁定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 麒麟操作系统用户密码忘记并锁定 重启机器，输入e进入引导配置页面，在文件中把ro改为rw，并在行末添加init=/bin/bash console=tty0，之后ctrl+x启动进入命令行修改密码即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a51122d80d0b79dec55918b1f00500c/" rel="bookmark">
			宇宙中可能存在的另外一种生命体-硅基生命
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文提到的所有图片有燧原曜图平台生成提供
概念 碳基：生命的组织架构由碳元素组成（地球的生命）硅基：生命的组织架构由硅元素组成 引言 费米悖论 中提到有存在外星文明的可能，但它们迄今为止还无法和我们接触三体人，刘慈欣创作的科幻小说《三体》及其衍生作品中的种群，一个外星智慧文明种群。居住在距离太阳系4光年外的半人马座α星，但因能抵抗多日同时出现时的高温和强光，故推测其表皮可能类似镜面。这种生物的生存环境非常恶劣，在漫长的演变过程中，三体人进化出了脱水等类似休眠状态的能力，待到相对温和的时期再浸泡复苏 问题 三体人是什么人？为什么从上世纪60年代到现在近几十年的事件，确没有找到任何生命的踪迹呢为什么会有硅基生命？很合理吗？硅基生命比碳基生命怎么样？地球上有硅基生命吗？如果没有，是为什么呢？ 生命的定义 百科中定义了生命
具有能量代谢功能，能进行能量转换能够产生应激反应能够自我繁衍生成发育，必须是在变化的 探寻生命的2大准则
有生命有生存条件 有氧，水，碳，适宜的生存条件（前3个比较容易满足） 碳基生命 由碳元素组成的有机物超过百万种碳元素有个特点，即容易获得4个电子而稳定也能失去4个电子而稳定，非常灵活 地球上最多的是什么? 氧气，水
氧气 + 硅 &gt; Si + O₂ → SiO₂ 无机物，且坚硬，石头， 石英和石英砂，高熔点和高硬度
水 + 硅 &gt; Si + 3H₂O → Si(OH)₄ + H₂
如果地球上存在硅基人（但是地球水和氧气不适合他生存，会让他要么变石头，要么溶于水）
那他不是妥妥的"硅基钢铁侠"那他的武器不是有手就行? 如果宇宙有硅基生命，他们需要星际移民，一定不会选择地球（安全）
硅的化学反应相对碳来说比较缓慢，所以其新陈代谢比较慢，应该寿命比较长（可能上万年吧），1000岁只是一个童年啦，所以进化应该比较慢，至少比人类慢，人类寿命不到100年
但是由于寿命更长，可能文明发展进度比碳基生命更快（后面会佐证），所以硅基生命的文明理论上更高级
地球人需要喝水，那么碳基生命喝什么？甲烷（宇宙中有大量甲烷海洋的星球）？
地球人生存的温度零下30-零上40， 那么碳基生命生存温度应该在零上下200(更适合星际旅行), 他们来到太阳系，你看火(土)星还可以，他们会选择火星
氢气应该不会成为他们的饮料，液化需要很大的气压，甲烷相对还好，也需要50倍大气压，人类承受的极限大气压是18倍大气压，所以碳基生命和硅基生命应该不能出现在一起
并且硅基生命更抗紫外线，更加适合星际移民
地球上的硅基生命 硅藻 半硅基半碳基生命这玩意细胞壁是石英除了细胞壁其他都是碳基生物
Ai（地球上唯一完全的硅基生命） Ai符合生命的定义能进行能量转换（自身所需要的电能等）能繁衍（自我复制）能成长(AI进步近几年是相当快)有应激反应（能对外做出指令）
马斯克曾有一句名言：“人类社会就是一串极小的代码，它的本质就是一串生物指令，而这串指令最终导致了硅基生命的诞生”。就在人们还在为马斯克登陆火星而兴奋不已的时候，这位世界上最著名的科技领军人物，却做出了一个令人瞠目结舌的预言，那就是碳基生命，只是硅基生命的开端。没错，马斯克再一次把颠覆性的观点带到了这个世界上
人类作为地球上智慧最高的种族，一直以来都认为，在这个世界上，只有他们一家独大。可是现在，马斯克却将这一点说得如此离谱，这让我们不禁产生了一个疑问，那就是我们真的了解这个世界了吗
马斯克在一次采访中详细阐述了自己的看法。他指出，碳基生命（即我们人类），在地球演化的进程中，已逐渐转变为硅基生命。在他看来，随着科技的进步，特别是人工智能技术的不断突破，以人工智能为主导的硅基生命体，必将成为未来地球上最主要的生命体。很惊人吧
结论
人类开启硅基生命那么人类（碳基）是由什么开启的？至少元素周期表中还没有找到？碳基生命与硅基生命两则其实是不能共存的，并且硅基生命会优于碳基生命，所以人类最终还有存在的必要吗？但是AI的是人造的，他的生存应该比宇宙中的生存环境更宽，他不需要喝"甲烷"来进行维持生命 硅基生命或许是宇宙的终极生命形式！ 硅基生命或许是宇宙的终极生命形式！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b8acbee6fd9fa8ffba87a46f2447823/" rel="bookmark">
			DevOps之必知必会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 背景 1.1 软件行业应用现代化转型： 应用现代化的优势：
可扩展性成本管理/优化安全性和合规性 新形势下企业面对多重挑战：
交付频率高，研发周期短。跨地域协作多，部署分布复杂。可靠性与安全要求高。 企业需要持续精益化的响应能力
易变性：volatility不确定性：uncertainty复杂性：complexity模糊性：ambiguity 2 什么是敏捷 敏捷软件开发（Agile software development），又称敏捷开发，是一种从1990年代开始逐渐引起广泛关注的一些新型软件开发方法，是一种应对快速变化的需求的一种软件开发能力。它们的具体名称、理念、过程、术语都不尽相同，相对于“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发过程中人的作用。
2.1 价值观 个体和互动 高于 流程和工具
工作的软件 高于 详尽的文档
客户合作 高于 合同谈判
响应变化 高于 遵循计划
2.2 敏捷常用的工程方法 Scrum、看板方法、自定义混合模式是最受企业欢迎的前三种敏捷开发方法.
3 DevOps概述 DevOps，即Development and Operations，是一组过程、方法与系统的统称，用于促进软件开发、运维和质量保障部门之间的沟通、协作与整合。DevOps的出现是由于软件行业日益清晰的认识到：为了按时交付软件产品和服务，开发和运维工作必须紧密合作。DevOps可看作开发、运维和质量保障（QA）三者的交集。
DevOps运动源自于提高IT服务交付敏捷性的需要，早期出现在许多大型公有云服务提供商中，并被其认可。支撑DevOps的理念基础是敏捷宣言，它强调人（和文化），致力于改善开发和运维团队之间的协作。从生命周期的角度来看，DevOps的实施者也试图更好的利用技术，尤其是自动化工具，来支撑越来越多的可编程的动态的基础设施。
3.1 DevOps的技术实践 在思维和流程改变的同时，想要充分落地DevOps，当然离不开软件和平台的支持。目前支持DevOps的软件很多了。
3.1.1 DevOps的涉及的四大相关平台 项目管理：如，jira，禅道
代码托管：如，Gitlab，SVN
持续交付，如，Jenkins，Gitlab
运维平台:如，腾讯蓝鲸，Spug等。
整个Devops平台的托管，如华为云的CodeArts，阿里云的云效。
3.1.2 包文件 包文件通常不放在源码库中管理，而是使用专门的包文件仓库（repository）进行存储，并配合包文件依赖管理工具（Maven、npm、Ivy等）进行使用。包文件仓库可以大致分为本地仓库、私服仓库、中央仓库三种。
3.2 持续集成、持续交付和持续部署 CICD CI/CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI/CD 的核心概念是持续集成、持续交付和持续部署。作为一个面向开发和运营团队的解决方案，CI/CD 主要针对在集成新代码时所引发的问题
具体而言，CI/CD 可让持续自动化和持续监控贯穿于应用的整个生命周期（从集成和测试阶段，到交付和部署）。这些关联的事务通常被统称为“CI/CD 管道”，由开发和运维团队以敏捷方式协同支持。
3.2.1 持续集成（Continuous Integration） 持续集成（CI）是一种软件开发实践，即团队的成员经常集成他们的工作，通常每个成员每天至少集成一次——这导致每天发生多次集成。每次集成都通过自动化的构建（包括测试）来验证，从而尽快的检测出集成错误。
3.2.2 持续交付（Continuous Delivery） 持续交付（CD）是从构建环境到生产环境的构建、测试、配置和部署的过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b8acbee6fd9fa8ffba87a46f2447823/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bef6a35a75522cbd921958bcb10baf5/" rel="bookmark">
			storcli安装及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MegaCli 是LSI公司官方提供的SCSI卡管理工具，由于LSI被收购变成了现在的Broadcom，所以现在想下载MegaCli，需要去Broadcom官网查找Legacy产品支持，搜索MegaRAID即可。
现在官方有storcli，storcli已经基本代替了megacli，整合了LSI和3ware所有产品。
安装storcli
ansible all -m copy -a 'src=/root/rpm/Mega/storcli-1.13.06-1.noarch.rpm dest=/root/' ansible all -m shell -a 'rpm -ivh /root/storcli-1.13.06-1.noarch.rpm' 脚本改进点：EID有64、65，少量几台是66，这块需要自动识别出来，否则会造成无法构建RAID
查看物理磁盘
/opt/MegaRAID/storcli/storcli64 /c0 /eall /sall show c：controller，控制器（一般为0）
e：enclosure，硬盘背板（6TB是64，1.2TB是65）
s：slot，硬盘槽位（0，1，2，3…）
v：virtual drives，虚拟磁盘，即raid
EID-Enclosure Device ID|Slt-Slot No.|DID-Device ID|DG-DriveGroup
DHS-Dedicated Hot Spare|UGood-Unconfigured Good|GHS-Global Hotspare
UBad-Unconfigured Bad|Onln-Online|Offln-Offline|Intf-Interface
Med-Media Type|SED-Self Encryptive Drive|PI-Protection Info
SeSz-Sector Size|Sp-Spun|U-Up|D-Down|T-Transition|F-Foreign
UGUnsp-Unsupported|UGShld-UnConfigured shielded|HSPShld-Hotspare shielded
CFShld-Configured shielded
查看raid信息
/opt/MegaRAID/storcli/storcli64 /c0 /vall show 删除raid
/opt/MegaRAID/storcli/storcli64 /c0/v1 delete force 删除spare盘
/opt/MegaRAID/storcli/storcli64 /c0/e0/s11 delete hotsparedrive 增加raid
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bef6a35a75522cbd921958bcb10baf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5582b6f0fc48482f3f0ea925ed8e0395/" rel="bookmark">
			【已解决】初次使用@ConfigurationProperties注解，页面爆红
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、问题
二、解决办法
在pom.xml文件中增加依赖，爆红问题得以解决
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f12cdf51ec410c88aa2e392417d1752/" rel="bookmark">
			ClickHouse 彪悍发言：云数仓死贵死贵的，Snowflake 这种就不应该成为当前主流！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ClickHouse 最近发表了一篇精彩的文章，描述了 Snowflake 和 Redshift 等云数据仓库已经不能满足新的客户需求，并且指出许多企业已经发现他们的云数据仓库成本是不可持续的。
“云数据仓库的成本呈指数级增长”，“我们感谢云数据仓库多年来的辛勤付出，但它们引领的霸权时代即将落幕”。
在这篇文章中，他们还探讨了数据库技术的发展，认为成本将成为一个重大的痛点，从而促使企业重新评估其数据堆栈。
数据生态系统的演变 数据生态的演变，经历了从大型机到关系数据库，再到传统数据仓库，再到早期的云提供商的过程。在过去十年里，像 Snowflake 这样的厂商推动了整个行业的现代化，打破了以往高度依赖封闭且专有的自我管理型部署生态（主要由甲骨文、Teradata 等提供）的传统。
新方案帮助组织将 PB 级关键工作负载迁移至云端，将这些数据集开放给更广泛的集成、协作与应用程序，由此实现了数据访问普及化并创造出巨大的市场价值。
但随着时间推移，企业开始认真审视自己的数据存储架构，考虑其中信息的具体性质以及能够实现的潜在用途。随着组织数据获取门槛的逐渐降低，开发团队开始从静态批量报告转向建立交互式应用，在供内部使用的同时也可以对外发布。
而到了这一步，云数据仓库的短板也开始暴露出来。此类存储方案专为离线报告模式而设计（目前仅运行在云基础设施当中），因此其架构与计费模式并未针对作为交互式数据驱动应用的后端进行优化。
于是乎，组织往往面临着性能不佳（响应时间从数十秒到几分钟不等，无法做到亚秒甚至是毫秒级响应）、成本飙升（通常是替代方案的 3 到 5 倍）以及查询并发性过低（不适合对接外部应用）等现实难题。
传统云数据仓库的局限性日益凸显 传统数据仓库已有多年历史，在设计上主要服务于离线和批量处理时代下的统一内部业务报告，而且大多具有以下特征：
依靠大批量 ETL 作业从源系统中移出数据；
对大表进行大规模 join，借此将不同数据集统一起来进行集中查询；
通过静态“views”或“marts”供不同团队使用特定数据集。
以 Snowflake、BigQuery 及 Redshift 等平台为主导的云数据仓库，大多专为特定类型的重要数据工作负载提供可扩展性、便利性，以及最重要的灵活性与开放性，借此实现数据仓库的现代化改造。
然而，随着这些数据登陆云端，数据仓库的固有应用边界也被很快打破，迫使云数据仓库成为一种“一刀切”式的解决方案，全面承担起服务器端转换、仪表板、可观察性、机器学习等各类面向用户的分析用例。但受其自身局限性影响，云数据仓库开始成为性能问题、用户体验下降及成本失控的根源，对数据架构的重新评估已经刻不容缓。
交互式、数据驱动的应用场景正成为主流 对于已经发展成熟的行业来说，人们更倾向于把构建各种新兴应用的趋势理解成利基性质的小众需求。如果去询问传统数据仓库架构师，他们很可能仍然坚称“批量数据摄取和报告”仍是正确答案……但事实并非如此。
如今，营销、销售、工程、运营等各个部门的专业人士都需要频繁使用交互式、由数据驱动的生产力应用，其特征就是以高度交互的方式对大量数据执行分析。例如，作为营销人员，我们需要了解谁访问过产品网站、谁在关注社交媒体帖子，已发布广告的接受情况如何等——所有这些都必须实时获取答案。作为一名金融分析师，大家需要在快速变化的市场中迅速反应，每天多次做出决策。而对于负责 24/7 SaaS 服务的 DevOps 工程师，我们则很可能要对应用程序的可用性提出极为严苛的要求——正常运行时间至少要达到 99.999%，即每年只能容忍 5 分钟的停机时间！
于是乎，全新的行业由此诞生，其服务对象就是那些无法通过传统数据仓库解决、而只能借助实时数据仓库的业务需求。
营销分析，提供来自多种渠道（包括网络、社交媒体、广告活动）的宣传效果，对信息进行总结，并允许营销人员运行交互式查询及报告功能，主动显示海量数据中的异常值（例如快速增长的区域、子市场或行业），并提出营销支出优化建议。
销售分析，显示各销售区域的具体活动，例如按来源划分的销售线索流、免费/试用产品接受情况、销售周期活动、售后消费、账户健康状况以及客户流失数据等。汇总这些数据并主动提取出重要信息之后，销售专业人士可以据此评估不同措施的机会或风险因素，把握住关键潜在客户并发现态度摇摆的风险客户。
电子商务与零售分析，涵盖整个零售生命周期——从营销到库存、再到销售活动和商品配送，全程实现对数据的长期跟踪与交互式查询，并主动提出物流运营的优化方法。
金融分析跟踪金融工具的具体操作，包括买入、卖出、看跌期权、看涨期权，并允许分析师根据此类信息选择标准及建议的行动（包括潜在的后续交易与对冲操作）。
可观察性与物联网监控，要求从 SaaS 基础设施或制造车间/设备处获取结构化日志、指标并跟踪事件，将结果与设备和用户信息等元数据交叉引用，据此总结错误与延迟信息，并结合历史数据预测可能发生故障的区域。
分析类应用的内部用户包括产品、营销及业务分析师，他们也是数据仓库系统上的主要目标受众。但这些用户明显不再满足于缓慢的分析体验。为了保持职能竞争力，他们必须加快数据驱动的决策速度，而如果内部数据平台无法满足要求，他们则会提议采用更快、交互式表现更好的第三方工具。
除了现有内部用例之外，企业内部的 AI/机器学习团队也在逐步扩大，内部数据科学家也需要访问并查询数据以开发出更好的机器学习模型与 AI 功能。数据科学家对于交互性能同样高度关注，因为查询速度将直接决定他们发布新机器学习模型、构建 AI 新功能的效率。
云数据仓库的短板 在这些场景下，云数据仓库的表现往往令人头痛。由于传统数据仓库的架构与计费模式缺少针对性优化，所以无法充当交互式数据驱动应用的高效后端。此类应用通常要求数据仓库具备以下能力：
将连续加载的数据与历史数据（周期长达数年）相结合以提供查询服务；
在高交互访问模式下提供高并发查询，例如复杂的过滤与聚合操作；
为沉浸式应用提供必要的低延迟查询（理想情况为亚秒级）；
处理高达 TB 甚至 PB 级别的历史数据，且每秒能够处理数百万次事件摄取。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f12cdf51ec410c88aa2e392417d1752/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/808c8bdab4258fcc3e26b85945b3bd66/" rel="bookmark">
			RHCE第五次作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.算数运算命令有哪几种？
1.（（））
2，let 3.[]
4.declare -i
5.expr 6.bc
7.awk
总结：
2..定义变量url=https://blog.csdn.net/weixin_45029822/article/details/1035688151）截取网站访问的协议2）截取网站访问账号信息
方法一
方法二
方法三
方法四
3.写一个脚本，完成以下要求：给定一个用户：1、如果其UID为0，就显示此为管理员；2、否则，就显示其为普通用户；
4.写一个脚本判断当前系统上是否有用户的默认shell为bash；如果有，就显示有多少个这类用户；否则，就显示没有这类用户； 作业内容：
1.算数运算命令有哪几种？ $(()) $[] let declare -i expr 1 + 2 bc awk
2..定义变量url=https://blog.csdn.net/weixin_45029822/article/details/103568815
1）截取网站访问的协议
2）截取网站访问账号信息
3.写一个脚本，完成以下要求：
给定一个用户：
1、如果其UID为0，就显示此为管理员；
2、否则，就显示其为普通用户；
4.写一个脚本
判断当前系统上是否有用户的默认shell为bash；
如果有，就显示有多少个这类用户；否则，就显示没有这类用户；
1.算数运算命令有哪几种？ 1.（（）） [root@server ~]# ((1+1))
[root@server ~]# echo $?
0
[root@server ~]# echo $((1+1))
2
[root@server ~]# data=$((1+1))
[root@server ~]# echo $data
2，let [root@server ~]# let 2+2
[root@server ~]# echo $?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/808c8bdab4258fcc3e26b85945b3bd66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c4f61e9758d2193aaf2f35476b5df26/" rel="bookmark">
			Sysprep无法验证你的Windows安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sysprep无法验证你的Windows安装 解决方法参考链接 解决方法 查看C:\Windows\System32\Sysprep\Panther\setupact.log 日志，找到报错的应用程序包。
通过下面命令获取当前计算机上所有用户安装的应用程序包列表，看是否可以找到报错的应用程序包名 get-appxpackage -allusers | select name, packagefullname #获取当前计算机上所有用户安装的应用程序包列表，并显示每个应用程序包的名称和完整包名。 3.卸载报错的应用程序包
remove-appxpackage -allusers -package "Microsoft.LanguageExperiencePackzh-CN_18362.36.117.0_neutral__8wekyb3d8bbwe" #卸载应用程序包。 卸载后成功运行
参考链接 https://www.icka.org/3121/sysprep-fails-remove-or-update-store-apps
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84b244d85d5ee26c508982e95d9a63d3/" rel="bookmark">
			Docker安装Elasticsearch以及ik分词器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。作为 Elastic Stack 的核心，Elasticsearch 会集中存储您的数据，让您飞快完成搜索，微调相关性，进行强大的分析，并轻松缩放规模。项目上如果要使用Elasticsearch则需要先搭建相应的环境，用docker可以快速的搭建Elasticsearch环境。本文主要介绍如何用docker安装elasticsearch和ik分词器。
Elasticsearch版本选择 因为需要安装ik分词器，所以建议选择ik分词器对应的Elasticsearch的版本。本文我们选择v7.17.7的版本进行安装和介绍。
在Github上选择需要安装的ik分词器，下载对应的zip包。这里本文我们选择elasticsearch-analysis-ik-7.17.7.zip。
我们可以到 Dockerhub上选择对应的Elasticsearch镜像版本。本文我们选择与ik分词器对应7.17.7这个版本，
Docker安装 执行如下命令安装运行elasticsearch，主要docker设置了端口映射，挂载的目录以及启动的参数等。注意设置服务器目录的权限以及服务器防火墙端口的开放。
docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS="-Xms512m -Xmx512m" -e "discovery.type=single-node" -v /usr/local/elasticsearch7.17.7/data:/usr/share/elasticsearch/data -v /usr/local/elasticsearch7.17.7/plugins:/usr/share/elasticsearch/plugins -v /usr/local/elasticsearch7.17.7/logs:/usr/share/elasticsearch/logs --privileged --restart=always elasticsearch:7.17.7 防火墙开放服务器的elasticsearch端口。
firewall-cmd --permanent --add-port=9200/tcp firewall-cmd --permanent --add-port=9300/tcp firewall-cmd --reload IK分词器安装 将下载好的ik分词器elasticsearch-analysis-ik-7.17.7.zip解压后上传到elasticsearch挂载到宿主机的plugin目录里面。
# 1.进入elasticsearch的plugins目录 cd /user/local/elasticsearch7.17.7/plugins # 2.创建ik目录 mkdir ik # 3.将解压后的elasticsearch-analysis-ik-7.17.7.zip上传到ik目录中 # 4.设置ik目录的权限，这里简单粗暴直接全开权限 chmod -R 777 ik 解压elasticsearch-analysis-ik-7.17.7.zip上传ik目录后，效果如下。
验证ik分词器是否安装成功。进入容器在elasticsearch的bin目录下执行elasticsearch-plugin list命令查看ik分词器插件是否安装成功。
# 1.进入容器 docker exec -it elasticsearch /bin/bash # 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84b244d85d5ee26c508982e95d9a63d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d9d16747b480bd8899dfc6d2a48990e/" rel="bookmark">
			小航助学题库蓝桥杯题库python选拔赛（22年1月）（含题库教师学生账号）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要在线模拟训练的题库账号请点击 小航助学编程在线模拟试卷系统（含题库答题软件账号）_程序猿下山的博客-CSDN博客
需要在线模拟训练的题库账号请点击 小航助学编程在线模拟试卷系统（含题库答题软件账号）_程序猿下山的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f2639bacdb185752f9eb5e6da73401c/" rel="bookmark">
			解决“ImportError: Missing optional dependency ‘pytables‘. Use pip or conda to install pytables.”问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我用的是python3.8，我在论坛里看到有人提到python3.8.2版本pip里没有pytables。
所以是下载tables解决的：
pip install tables 我测试过使用conda下载pytables也可以：
conda install pytables 踩坑经历：
这里我说一个我踩过的坑，我遇到过安装成功tables但执行代码依旧会提示找不到这个模块，网上也有很多解决方案，但我提醒一下，一定一定要先排除掉安装tables的虚拟环境与执行代码的虚拟环境是否一致！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3e9c56436bbcb922a9151691c308929/" rel="bookmark">
			CRON表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 cron表达式的组成 cron表达式是一个字符串，由6到7个字段组成，用空格分隔。其中前6个字段是必须的，最后一个是可选的。每个字段的含义：
秒 分 时 日 月 周 （年） 从左到右，依次对每个字段指定相应的值，就可以确定一个任务的执行时间点和周期了。
值可以由数字配合字符来组合。
99%的情况下会用到的字符 在大部分使用cron的场景下， - * / ? 这几个常用字符就可以满足我们的需求了。
【*】：每的意思。在不同的字段上，就代表每秒，每分，每小时等。【-】：指定值的范围。比如[1-10]，在秒字段里就是每分钟的第1到10秒，在分就是每小时的第1到10分钟，以此类推。【,】：指定某几个值。比如[2,4,5]，在秒字段里就是每分钟的第2，第4，第5秒，以此类推。【/】：指定值的起始和增加幅度。比如[3/5]，在秒字段就是每分钟的第3秒开始，每隔5秒生效一次，也就是第3秒、8秒、13秒，以此类推。【?】：仅用于【日】和【周】字段。因为在指定某日和周几的时候，这两个值实际上是冲突的，所以需要用【?】标识不生效的字段。比如【0 1 * * * ?】就代表每年每月每日每小时的1分0秒触发任务。这里的周就没有效果了。 极少能用到的字符 SUN：仅用于【周】字段，表示星期日。也可以用数字1设置。周日到周六分别为SUN，MON，TUE，WED，THU，FRI和SAT，对应数字1，2，3，4，5，6，7。目前Quartz支持。L：即last，用于【日】【周】字段。这里需要注意的是，在不同的字段的不同使用方式，其含义有所差别。 用于日字段：直接使用L代表每个月的最后一天。也支持偏移量的方式，配置[L-1]则代表每月的倒数第二天。用于周字段：直接使用L代表每周的最后一天，也就是等效于[7]或[SAT]，但是如果配合上数字，比如[7L]，则代表每个月最后一个周六，等效于[SATL]。目前Quartz支持。 一些常见的例子 cron表达式含义常用场景执行时间5 * * * * ?每分钟的第5秒执行一次常见的每分钟的定时任务，检查数据库和缓存数据是否一致2021-04-11 13:10:05
2021-04-11 13:11:052021-04-11 13:12:052021-04-11 13:13:052021-04-11 13:14:052021-04-11 13:15:055 * 10-22 * * ?从早上10点到晚上十点，每分钟的第5秒执行一次将定时任务限制在每天的工作时间2021-04-11 13:10:05
2021-04-11 13:11:052021-04-11 13:12:052021-04-11 13:13:052021-04-11 13:14:052021-04-11 13:15:055 0 0/6 * * ?
等效于5 0 0,6,12,18 * * ?每天从0点开始，每隔6小时执行一次。执行时间为第0分5秒。常用于每天较低频次的批量同步数据2021-04-12 00:00:05
2021-04-12 06:00:052021-04-12 12:00:052021-04-12 18:00:05 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/63/">«</a>
	<span class="pagination__item pagination__item--current">64/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/65/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>