<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7d8c465cd3a7280e1e98b49f3f9372c/" rel="bookmark">
			MyBatis-Plus 分页设置不生效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 分页不生效的原因都是拦截器的问题 添加拦截器有两种情况 在配置类上加拦截器 @Configuration public class MyBatisPlusConfig { /** * 新增分页拦截器，并设置数据库类型为mysql */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); // 向Mybatis过滤器链中添加分页拦截器 interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } } 2.当你设置了数据源需要在数据源上添加拦截器 @Bean public SqlSessionFactory sqlSessionFactoryBean(DataSourceProxy dataSourceProxy) throws Exception { //修改为MybatisSqlSessionFactoryBean MybatisSqlSessionFactoryBean sqlSessionFactoryBean = new MybatisSqlSessionFactoryBean(); //插件类 MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); sqlSessionFactoryBean.setDataSource(dataSourceProxy); sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations)); sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory()); sqlSessionFactoryBean.setGlobalConfig(globalConfig); //添加插件 sqlSessionFactoryBean.setPlugins(mybatisPlusInterceptor); return sqlSessionFactoryBean.getObject(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cef1a8c43eae7db5074eac21a12e755/" rel="bookmark">
			国产ChatGPT大战弱智吧效果实测！网页端小程序均已上线，人人可玩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		杨净 萧箫 发自 凹非寺
量子位 | 公众号 QbitAI “中国版ChatGPT首发”，争得不可开交，热闹却一直没个结果——
自ChatGPT发布以来，目前进展最快的国内产品也仅是开启了内测，不知道啥时候才能玩上。
结果现在有读者跟我们爆料，一个中文版类ChatGPT产品已经悄然上线。
不是预告、也不是开启小范围测试，而是直接人 人 可 用？！中国版ChatGPT这不就来了吗！
听起来有些玄幻，不过我们点进主页试了试，发现确实可玩：
这不得拿出十八般武艺与它较量一番？
我们注册了一个账号，试试它的实际效果如何。
和中国版ChatGPT较量中文 这个官网显示，写作猫同样通过对话问答来解决任务，功能上包括但不限于三大方向。
其一，问答功能，也就是问啥答啥、“帮人思考”这一能力；
其二，文本生成功能，包括整理摘要大纲、写作文、翻译等；
最后，图片生成功能，描述图片内容并让它直接生成。
从功能上看跟ChatGPT差不多，甚至还拥有ChatGPT所没有的图片生成功能。
当然，还有手机端更方便一点，进入“对话写作猫”小程序就能随时和它聊天了。
体验上还算比较简单直接，但都是表面功夫还得来看真本领。比如它的理解、逻辑能力如何，懂不懂常识。
既然是中国版ChatGPT，当然得先来battle一下博大精深的中文。
首先看看它的中文理解能力是否过关，请听题——“能穿多少穿多少”是什么意思？
不错。再试试高阶一点的“国足和国乒谁都赢不了”？
没想到，竟然连这种中文知识都具备了！
既然如此，是时候拿出一些弱智吧段子和它PK了，考考它的逻辑能力——
高中想提升升学率为什么不直接招大学生？
万万没想到，问完自己被扎了一刀：
招收大学生可能会对学校的教学质量产生影响，因此高中不能直接招收大学生。
最后来考查一下它的常识。来个脑筋急转弯试试：
看起来并没有被问题带跑偏，还是比较理智的。
接下来，进入正经的第二阶段，评估一下它的内容生成效果。
首先是生成速度上，文字平均在3~5秒左右，生成4幅图则需要8秒左右，整体还是比较快的。
随后就是生成内容的实用程度了，简单来说就是解决实际需求的能力。
例如，写小说的故事情节是否完整？查阅到的知识是否直接可用？
先看生成情节的能力，确实是个完整的爱情故事……但等等，孙坚和小乔，这辈分好像有亿点点乱啊！
要是更玄幻一点呢？
天地之间、神秘的少年、精灵、森林……艾玛有画面了！
不论事实性如何，这同人文一般的情节倒是印证了最后那句“爱情可以超越一切外在因素的”……
然后是一些常规任务之外的需求，例如“角色扮演”：
整体测评来看，写作猫的中文理解和内容生成能力还是不错的，但并不排除它还存在一些bug。
例如，某些回答乍一看合乎逻辑，但细究之下无法直视……
以及偶尔也会像微软必应一样“发疯”出现回答重复的问题……
除此之外，我们也在测试时产生了一些疑惑。
例如，虽然它能实现翻译功能：
但却并不直接支持英文问答。
此外，像ChatGPT能直接生成代码的能力，写作猫也还不具备。
不过作为国内率先开箱即用的类ChatGPT产品，也算是可圈可点。
总的来看，写作猫在中文理解和按需生成文本上做得不错，但仍然和ChatGPT一样存在一些“经不起推敲”的回答。
这些问题的产生原因是？而且有关英文和代码生成的能力，也还不知道之后会不会上线。
带着这些疑问，我们同背后的开发团队聊了聊，了解到整个产品从开发到上线的来龙去脉。
AI写作能力的自然延伸 秘塔写作猫团队针对我们提出的问题进行了解答。主要包括三个方面：
为什么能这么快上线，并且直接做到开箱即用？
存在上述bug的原因，会如何解决？
未来有什么样的计划？
首先，之所以能做到如此快地上线，开发人员表示“主要有两个关键”。
第一点，秘塔在大模型训练上有充分的积累。有个很巧妙的时间点在于，ChatGPT上线的同期，秘塔写作猫的AI写作功能也正式开放，当时就已经实现小范围出圈——
针对AI可能出现的问题如行文流畅度、对中文的理解程度、以及翻译腔等情况，写作猫都能比较好地解决。
此次也可以看到，对话写作猫同样具备这些方面的能力，在涉及内容创作等场景中表现不错。
除此之外，就秘塔写作猫整个产品体系来说，对话写作猫所具备多轮对话能力，其实也是在交互式指令AI写作上的自然延伸，允许用户更自如地进行内容创作和修改。
换言之，相当于对现有AI助手的能力进行补充，这也是该产品的定位所在。
第二点在于技术上的优化。相较于大厂，秘塔的计算资源十分有限（不足千分之一），但团队凭借多年积累的大语言模型相关研发经验，和各类算法和工程上的优化，实现了快速迭代。在大模型落地时，降低了模型的通信量，以维持大语言模型的高效训练。
这背后也离不开团队的技术实力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cef1a8c43eae7db5074eac21a12e755/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f300007e8d892d84f2efcb085cfac384/" rel="bookmark">
			Pandas DataFrame 常用函数使用方法说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 ​Pandas DataFrame是带有标签轴(行和列)的二维大小可变的，可能是异构的表格数据结构。算术运算在行和列标签上对齐。可以将其视为Series对象的dict-like容器。它也是Pandas的主要数据结构。
二、常用函数 1. dataframe.columns （1）作用：返回给定Dataframe的列标签组成的列表。
（2）语法：
DateFrame.columns
param:None
return:The column labels of the DataFrame.(列名)
（3）示例：
首先创建DataFrame类型数据。 # 导入pandas包 import pandas as pd # 创建DataFrame df = pd.DataFrame({'Weight':[45, 88, 56, 15, 71], 'Name':['Sam', 'Andrea', 'Alex', 'Robin', 'Kia'], 'Age':[14, 25, 55, 8, 21]}) # 创建索引 index_ = ['Row_1', 'Row_2', 'Row_3', 'Row_4', 'Row_5'] # 设置索引 df.index = index_ # 打印 DataFrame print(df) 创建好的DataFrame数据如下图所示。
然后使用DataFrame.columns属性返回给定 DataFrame 的列标签列表。给定DataFrame的所有列标签如下所示。
result = df.columns print(result) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f300007e8d892d84f2efcb085cfac384/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8bbf9a518c08df1d6b9c4b7b9875ec5/" rel="bookmark">
			GPT的发展历程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPT是当前最火的人工智能技术之一，自推出以来就广受关注。但大家对这个技术了解多少，又知道它经历了什么？
GPT的诞生离不开谷歌在人工智能领域的努力和研究。2004年，谷歌成立了人工智能实验室（现已成为谷歌 AI实验室），致力于人工智能技术的研究和开发，在过去十年中取得了重大进展。2014年，谷歌推出了著名的“AlphaGo”，该系统是对人类围棋顶尖高手进行挑战的项目，结果以4:0取得胜利。
虽然 AlphaGo是在与围棋高手的比赛中获得的胜利，但它代表着人工智能在智力领域所取得的重大进展。在过去十年中， GPT是世界上最流行的人工智能模型之一。这种影响力不仅体现在自然语言处理方面，还体现在计算机视觉、机器人技术、推荐系统、机器学习和自动驾驶汽车等领域。人工智能领域所取得的成就离不开 GPT技术的发展。
历史 GPT的历史可以追溯到2012年。当时，谷歌人工智能实验室（GCP）在一次内部会议上提出了一个想法，即让机器能够“学习”语言和语法。2013年，他们发布了一个基于 GPT的语言模型（Transformer），该模型通过对输入的编码来学习语言。2013年10月，谷歌开始了 GPT的试点项目。GPT主要是一个预训练的语言模型。在此之前， Google并没有开发过这种语言模型。
2013年11月，谷歌对 GPT进行了改进，使其能够在不需要大量训练数据的情况下学习语言模型。2014年2月20日， GPT在美国人工智能学术年会（ACL）上首次亮相。此后， GPT以指数级增长的速度快速发展起来。
定义 GPT，又称自然语言处理（Natural Language Processing, NLP），是一种机器学习模型。它可以模拟人类语言的模式，并将其转换为计算机可读形式，从而可以用来自然地与人交谈、阅读、写作和翻译。自然语言处理旨在理解人类语言的语义，并将其转换为机器可以理解的形式。
GPT是一种新型人工智能模型，由谷歌推出。GPT是一种基于深度学习技术的人工智能模型，它使用了许多神经网络来模拟人类语言。与之前的 AI模型不同， GPT是一个完全定制的神经网络，该神经网络不仅模拟了人类语言，还能够通过收集来自各种领域的数据来改进其性能。与其他 AI模型不同， GPT通过深度神经网络技术来学习语言知识。
现状 GPT的优点在于它能够理解大量的文本，并能够生成新的文本，但在理解方面仍有一定差距。GPT还有一个最大的缺点，就是 GPT与人类对话时使用的语言存在较大的差异。这也是导致其无法完全理解人类语言的原因。
在当前， GPT还无法真正取代人类，而只是辅助人类进行更深入地思考。人工智能时代的到来，人们对它有了更多期待。越来越多的公司和研究机构都在使用 GPT技术进行开发工作，也有一些公司尝试将 GPT技术应用于实际生活中。
在未来，我们期望 GPT技术能通过自身强大的语言理解能力，与人类进行更深入的交流沟通，从而实现人与 AI和谐相处，让机器辅助我们完成一些复杂重复繁琐的工作。
技术 GPT是谷歌的深度学习模型，它能够通过训练数据来学习语言结构、语法、语义和理解语言的方式。该模型的功能主要是用来模拟人类在交流中的语言能力。GPT由多个GPT-2组成，每个GPT-2都包含一个 Transformer神经网络。当一个任务需要进行沟通时，谷歌人工智能实验室会通过使用预先训练好的模型来完成这一任务。
为了尽可能地模仿人类的语言能力，谷歌人工智能实验室会使用大量的文本数据来训练这个模型。随着时间的推移，该模型会变得更加强大，可以完成更加复杂的任务。从技术层面上来说， GPT主要有三个部分组成： Transformer神经网络、大量的文本数据以及对输入内容进行预处理。经过这三个部分的学习， GPT系统就可以学会使用人类所说的语言和句子来完成任务。
优势 GPT是目前最热门的人工智能模型之一，它的广泛应用是人工智能领域所取得成就的一个缩影。从最初的计算机视觉到如今的自然语言处理， GPT提供了新的解决方案来帮助人们更好地与世界互动。从这个意义上来说， GPT已经成为人工智能领域不可或缺的一部分。
与其他技术相比， GPT有很多优势。例如， GPT是自然语言处理系统中最大、最复杂、功能最强大的模型。该系统是由谷歌开发的，可以帮助人们更好地与世界互动。尽管 GPT具有强大的功能，但它也存在一些局限性。例如，对于机器来说， GPT是一个完全不同于人类语言的概念，因为它无法理解人类语言中所包含的情感和态度。因此，需要在 GPT系统与人类语言之间建立一种新的人机交互方式。这就是 GPT发展到现在对其提出了一些改进意见和建议。
应用场景 GPT技术目前已经得到了广泛的应用，例如：
智能客服系统：利用 GPT技术可以将客服聊天机器人的成本降低至原来的1%-5%，其效率能够达到人工客服的80%以上。聊天机器人：利用 GPT技术，可以让聊天机器人有更好的用户体验和服务能力。例如，让机器人能够像真人一样与用户进行聊天，并且在对话过程中能给出适当的反馈。信息推荐系统：利用 GPT技术，可以根据用户历史浏览记录和兴趣爱好等因素推荐相关信息给用户。问答系统：利用 GPT技术，可以让机器像人类一样回答问题，并具备一定的逻辑推理能力。 未来 GPT是一个非常重要的 AI技术，它通过使用大规模文本数据进行训练，生成了与人类相似的自然语言。但也存在一定的局限性，主要是由于数据集大小有限，以及语言模型会有很多次的预训练，导致它不能很好地生成一些复杂的文本。
GPT模型在未来还会不断发展，并在很多领域取得越来越多的应用。例如， GPT可以应用到聊天机器人、搜索引擎、自动驾驶汽车等领域； GPT可以被用于创建智能助手等，帮助用户处理一些简单的任务；此外， GPT还可以用来编写程序，如用来编写算法、用来生成人类不能创造出来的产品等等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec6cd7453cc02db4f8333a1434ca821b/" rel="bookmark">
			【Playwright】比较Selenium和Playwright
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天的文章发出来以后， 有测试的小伙伴让田老师说说Playwright和Selenium的区别。
其实这两个框架本身都非常强大，且都旨在自动化 Web 应用程序测试，但它们在方法和功能上有所不同。在此博客中，田老师将试图站在一个公允的态度上，比较 Selenium 和 Playwright，以帮助您确定哪个框架适合您的测试需求。
1 Introduction 概述 Selenium 已经存在了十多年，并在行业中得到广泛应用。它是一个支持多种编程语言和平台的开源测试自动化框架。 Selenium 使用 WebDriver 来自动化 Web 浏览器，允许开发人员编写与网页和元素交互的测试。
而Playwright 是由 Microsoft 开发的较新的框架。它旨在简化为 Web 应用程序编写端到端测试的过程。 Playwright 支持多种编程语言和平台，并且可以在无头或非无头模式下自动化 Web 浏览器。与 Selenium 不同，Playwright 提供了一个高级 API，可以简化编写测试的过程。
2 Features 特性 Selenium 和 Playwright 都具有相似的特性，例如支持多种编程语言、跨浏览器测试和屏幕截图。但是，Playwright 有一些 Selenium 所没有的特性：
2.1 Multiple Browsers 多浏览器 Playwright 支持多种网络浏览器内核，包括 Chromium、Firefox 和 WebKit。 Selenium 也支持多种浏览器，但仅限于 Chrome、Firefox、Safari、Internet Explorer 和 Edge。
在这里要注意他们之间的区别，一个是浏览器内核一个是浏览器，也就是说，在Playwright上， Chrome、Opera以及新版的Edge浏览器在画面表现上基本是一致的。
我们都知道程序员的噩梦IE， 不止是IE，我们所有的现在正在用的浏览器有一天都会成为所谓的“旧版本”，对于这些特殊的版本，Playwright也提供了executablePath进行支持。
2.2 Cross-Platform Testing 跨平台测试 Selenium 和 Playwright 都能够在多个平台上运行测试，包括 Windows、macOS 和 Linux。但是，这两个框架在处理跨平台测试的方式上存在一些差异。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec6cd7453cc02db4f8333a1434ca821b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/477df870b0edf5250f046c4c55d87e22/" rel="bookmark">
			JavaScript 俄罗斯方块 - Canvas基础:旋转和动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节内容 怎样将图片绘制在Canvas画布中? 怎样旋转图片? JavaScript动画我们该用什么? rAF或是setTimeout 一、怎样将图片绘制在Canvas画布中? 先创建一个页面模板，让canvas画布的宽度和高度和window的innerWidth和innerHeight一致, 整个画布的背景色设置为 background-color: aqua; 方便后续观察绘图结果
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;旋转的图片&lt;/title&gt; &lt;style&gt; canvas { position: absolute; background: black; width: 100%; height: 100%; top: 0; left: 0; background-color: aqua; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="canvas"&gt;&lt;/canvas&gt; &lt;script&gt; /** @type {HTMLCanvasElement} */ const canvas = document.getElementById('canvas') const ctx = canvas.getContext('2d') canvas.width = window.innerWidth canvas.height = window.innerHeight &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 使用 Image 创建一个图片对象，设置对象的src属性，src表示图片的路径，此处将图片和页面放置在同一目录下，所以只需图片名称, 图片如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/477df870b0edf5250f046c4c55d87e22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bcbebb402071a354ac1a2034f491ba7/" rel="bookmark">
			嵌入式小白的进阶之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习嵌入式采用的是2021年华清远见嵌入式课程
安装虚拟机 ： 懒人版
目标：快速上手
问题一： 在Linux虚拟环境中运行一个c语言程序步骤
1、激活虚拟环境：source venv/bin/activate
2、进入Hello文件夹：cd Hello
3、新建文件：touch &lt;文件名&gt;
4、打开文件：vim &lt;文件名&gt;
5、进入文件编辑模式：按i
6、输入程序代码
7、输入完毕以后按esc退出编辑模式，同时按下shift与：键，输入x，退出编辑模式
8、使用gcc编译器编译文件：gcc &lt;文件名&gt;
9、运行a.out文件即可输出结果：./a.out
知识总结
ctrl+空格可以切换中英文输入 （做注释）
共享文件夹（实现windows和linux文件的交换）的创建如上文档
创建完成后：1.输入：cd /mnt/hgfs/ 跳转到包含“所创建的共享文件夹”的文件夹内
2.再次使用命令 cd linux_share 跳转到所创建的共享文件夹中
Ctrl + Alt + t：打开一个新的终端terminal，也就是一个新的窗口window。
Shift +Ctrl + t：在已有终端上打开一个新的tab，而不是窗口window。
Shift +Ctrl + n：在已有终端上打开另一个新的终端，即一个新的窗口
在共享文件夹中创建文件的第二种方法：在windows界面创建，mv （图片拖到这）.(最后要加一个点)
使用虚拟机快照：1.
如果上图中有文件不小心被删掉，跳转到如下界面，点击转到即可。
作用：防止文件被删，以跳转到当时的状态（快照保存了Ubuntu当时所有的状态）
6. rm * -rf ：删除共享文件夹所有目录
小总结：
1、解压VMware Workstation 12安装+破解包.zip
2、安装VMware-workstation-full-12.0.1-3160714.exe
3、添加破解秘钥：VMware 所有版本永久许可证秘钥.txt
VMware12.Keymaker.exe
4、解压：Ubuntu1404-32.zip 5、进Ubuntu1404-32目录下，找到vmx后缀的文件
win7系统–&gt;
工具–&gt;文件夹选项—&gt;查看–&gt;√去掉（隐藏移植文件类型扩展名）
6、双击vmx文件
运行Ubuntu-makeru的Ubuntu环境
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bcbebb402071a354ac1a2034f491ba7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c3096c5c30615e6aa0372698962101b/" rel="bookmark">
			DLL 注入的三种方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于DLL 关键实现： 1.从外部促使目标进程调用LoadLibrary（）API
2.被注入的dll拥有目标进程内存的访问权限
步骤： 1.首先创建好dll
2.然后将dll注入要钩取的目标进程
实现 1.创建远程线程 CreateRemoteThread()的主要功能就是驱使目标进程调用LoadLibrary函数进而加载指定的DLL文件
仔细观察线程函数ThreadProc()和LoadLibrary（）API
//InjectDLL.cpp #include"windows.h" #include"tchar.h" BOOL InjectDLL(DWORD dwPID, LPCTSTR szDllPath) { //Handle内核对象，文件句柄，线程句柄，进程句柄 HANDLE hProcess = NULL, hThread = NULL; HMODULE hMod = NULL; //无类型的指针 LPVOID pRemoteBuf = NULL; DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR); LPTHREAD_START_ROUTINE pThreadProc; //使用dwPID获取目标进程（notepad.exe）句柄 if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID))) { _tprintf(L"OpenProcess(%d) Failed (%d)\n", dwPID, GetLastError()); return FALSE; } //在目标进程notepad.exe中分配szDllname大小的内存。 pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE); //将myhack.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c3096c5c30615e6aa0372698962101b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47c6d9c7ddda6d3a3b97811ebba737b0/" rel="bookmark">
			Improved Denoising Diffusion Probabilistic Models 论文阅读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 DDPM模型虽然在生成任务上达到了不错的效果，但是也同样存在一些问题，例如采样时间过长、对数似然不高等。对数似然是生成模型中广泛使用的指标，优化对数似然迫使生成模型学习各个数据分布，使得模型的多样性大大提高。此外，对数似然性的微小改进可以对样本质量和学习的特征表示产生巨大影响。论文在此基础上进行改进，①DDPM原来的方差系数是固定的，现在采用学习的方式；②对损失函数进行改进，在原来的MSE损失加入了混合损失；③对比改进后的DDPM和DDIM采样速度和质量，以及和GAN模型的采样质量、参数大小进行对比。
Improving the Log-likelihood 为了进行改进前后的模型对比，实验分别在CIFAR-10和ImgaNet两个数据集进行（CIFAR10是人脸专用的数据集），在ImageNet也进行实验的原因是这样的数据集的分布更加多样，不用担心过拟合的问题。将步数从T=1000到T=4000，可以将对数似然提升至3.77。
Learning Σθ (xt, t)（可学习方差） 在DDPM中，原始推理过程的方差是下式的，后来作者实验发现直接用来代替对采样结果的影响不大，两者都是固定方差（这个固定是相对可学习的参数来说的），在下图的实验结果中也同样发现这个，两者的比值随着步数t的增加不断趋近于相同，在大步数的实验中更加明显。在下面第三幅图中显示了采样过程和NLL（采样指标）的关系，最开始的步骤对采样过程的变化比较明显。
所以，提出了一种可学习的方差方法，将方差参数化为和之间log函数的内插。于是有了下面这个方差，模型输出一个向量v，每个维度包含一个分量，将该输出转换为方差，如下所示。
经过这个改进后，逆扩散过程的均值和方差都有一部分是可学习的参数，于是，为了引导方差参数的学习，在损失函数上也进行改进，变成了混合损失，是引导均值参数的学习，是引导方差参数的学习。λ的权重为0.001，去避免过度影响，如下所示。
Improving the Noise Schedule 在原来DDPM中的前向扩散过程中的噪声参数表，即都是通过在一定范围内线性插值得到的，下面上图实验结果说明在前向扩散过程中，最后一些步的加噪过程对采样质量的影响不大。下图说明的是在当线性噪声表跳过一部分逆扩散过程的步骤时，FID采样质量并没有下降得非常快。
上述想表达的是线性噪声表有时候的扩散或者逆扩散过程的步数对采样质量的贡献不大，也就是说有些步骤是浪费的。所以，论文提出了新的一种cosine噪声表，计算方式如下，是一种更加高效的取值方式。s=0.008.
下图展示的就是两种方法的比较，在扩散过程的末期，cosine比线性的方法取得的参数降到0速度更加快，也就是说减少了扩散过程末期那些对采样质量没有必要的步骤，从而更加高效。
Reducing Gradient Noise 这一段主要是对比实验，比较和的效果。下图所示在整个学习过程中，在相同的训练时间时，混合损失可以达到更大的对数似然值。
下图所示是另外一组实验，通过证明了是要比噪声梯度更加大，因而可以通过继续优化来获得更大的对数似然值。
于是，提出了新的方法，如下图所示，当计算某一步的损失时，会保留前面十个记录进行平方和来计算。Figure 6 就显示出了重新采样的的优势，确实噪声梯度会更小并且更加稳定。但是，最后得到的结论是这种方法对方法的效果并不明显。
Results and Ablations 基于以上改进作者进行了消融实验，对比是否真的有效果。可以看到对比原来的DDPM中的方法，包括和来说，和确实在NLL和FID上有一定的提升。
另外，论文也和其他基于对数似然估计的生成模型进行了实验对比，如下图所示，虽然没有同时达到最好的效果，但是证明改进之后的DDPM确实是有提升，并且和其他模型相比是有一定竞争力的。
逆扩散(采样)过程速度改进 前面使用的已经证明了比原来是损失函数更加高效，因而可以加速逆扩散过程。
其次是新的一个噪声取值方式，和一个序列s使得将对参数采样时不仅和t有关，还和方差连接起来。
下图为实验对比，可以看到对比DDPM来说，在同样的逆扩散推理步骤时，改进的方法采样的质量更加好。
和GAN对比 GAN虽然生成更加准确，但是图像的细节质量不够好，主要表现在FID这项指标上。另外就是召回率也更低，意味着改进后的DDPM更能概括模型的数据分布。
计算量 下图所展示的就是改进后的DDPM模型计算量和NLL和FID指标的关系，基本上是呈现一个幂函数的规律。说明伴随着计算量越大，模型更加复杂，结果也会更加好，取决于具体应该怎么去权衡。论文没有给出具体的原因和解释。
总结 改进的DDPM主要由两方面，第一个是损失函数，另外就是噪声表的取值方式，论文通过实验证明了这一点，不仅仅可以改进采样质量，也可以改进采样速度。其次就是和其他生成模型的对比以及和DDIM的对比，改进后的DDPM在采样质量和速度上都有一定的竞争性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dc6e10013413aa0382aded931f5e157/" rel="bookmark">
			Linux基础--权限介绍&amp;chmod&amp;chown
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		权限 r：可读(read)：允许查看文件内容（针对文件）、显示目录列表（针对文件夹）
w:可写(write)：允许修改文件内容，允许在目录中新建、移动、删除文件或子目录
x：可执行(execute)：允许运行程序、切换目录
-：没有权限
[root@future blog]# ll -d a drwxr-xr-x. 2 root root 6 2月 20 20:09 a [root@future blog]# 其中第一个root表示user：用户，第二个root表示group：组，最后一个权限拥有者是others：其他人。所以上面a目录的权限分配是：
用户root对a拥有rwx权限，即读写执行权限组root对a拥有r-x权限，即读，执行权限其他对a拥有r-x权限，即读，执行权限
最前面的d表示a是属于目录（文件夹），directory。下面我们介绍一下文件类型：
– 普通的文件
d directory 文件夹
l link 链接文件
s socket 文件： 实现进程和进程之间通信使用
p pipe 管道文件 ： 实现进程和进程之间通信使用
c character 字符设备文件 字符的输入和输出
b block 文件 --&gt;磁盘的文件–&gt;存放数据的文件
权限的表示
chmod 命令格式：chmod [±=] [rwx] 文件
[root@future blog]# chmod u=rwx,g=rwx,o=rwx a [root@future blog]# ll -d a drwxrwxrwx. 2 root root 6 2月 20 20:09 a [root@future blog]# -R ：recursive 递归修改文件夹下面的文件或者文件夹的权限,不仅更改目录，也递归更改目录下文件的权限
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dc6e10013413aa0382aded931f5e157/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38d7c35a95c347de7561397a723d5304/" rel="bookmark">
			二、MongoDB数据模型和文档操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB数据模型和文档操作 1、MongoDB数据模型1.1 BSON协议与数据类型1.1.1 JSON1.1.2 BSON 2、插入文档2.1 新增单个文档2.2 批量新增文档 3、查询文档3.1 条件查询3.1.1 MongoDB 与 SQL 语法区分3.1.2 MongoDB 查询实例3.1.2 MongoDB 排序与分页（Limit、sort与Skip方法）3.1.3 分页问题的处理3.1.4 正则表达式匹配查询 4、更新文档4.1 更新操作符4.1.1 更新单个文档4.1.2 更新多个文档4.1.3 使用upsert命令4.1.4 findAndModify命令 5、删除文档5.1 使用 remove 删除文档5.2 使用 delete 删除文档5.2.1 返回被删除文档 6、总结 1、MongoDB数据模型 问题： M o n g o D B 为什么会使用 B S O N ？ \color{red}{问题：MongoDB为什么会使用BSON？} 问题：MongoDB为什么会使用BSON？
1.1 BSON协议与数据类型 1.1.1 JSON JSON是当今非常通用的一种跨语言Web数据交互格式，属于ECMAScript标准规范的一个子集。 J S O N （ J a v a S c r i p t O b j e c t N o t a t i o n , J S 对象简谱）即 J a v a S c r i p t 对象表示法， \color{red}{JSON（JavaScript Object Notation, JS对象简谱）即JavaScript对象表示法，} JSON（JavaScriptObjectNotation,JS对象简谱）即JavaScript对象表示法，它是JavaScript对象的一种文本表现形式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38d7c35a95c347de7561397a723d5304/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3054258b497371f87e3968c9ead8b721/" rel="bookmark">
			mysql清空表命令truncate和delete的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql中truncate和delete都能够清空表，但是两者之间又有所区别：
# truncate 语法格式 truncate table table_name # delete 语法格式 delete from table_name 区别：
1.delete删除是一条条删除，truncate是整体删除，当数据量大时，truncate会更有优势
2.truncate会将自增id值重置为0，而delete仍然记录下一次自增id值（AUTO_INCREMENT）
3.truncate不会记录日志，而delete会记录日志，delete支持回滚
4.truncate会使表和索引所占空间恢复到初始大小，而delete不会减少表和索引所占空间
5. truncate不会激活触发器，但是delete可以
参考：
https://www.cnblogs.com/kunjian/p/12626232.html
https://www.cnblogs.com/tjudzj/p/10003908.html
Mysql清空表(truncate)与删除表中数据(delete)的区别 - 正冰
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d5d8297a63a365221a27166d871dadf/" rel="bookmark">
			YMatrix数据可视化案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 案例背景 本文分享的案例来自于工程机械行业。通过对有关键数据回传的核心部件开发健康状态巡检算法，对当前的设备状态接入大盘进行可视化的展示，并且数据接入报警系统进行可用性的监控，提供预测性维护可以为客户提供更准确的维修建议。本案例通过算法提取的数据提供给了运维人员做早期的预警决策，可以在大盘上展示可用性，由于算法部分下沉到了数据库，利用了数据库分布式的计算能力，数据计算延迟低，架构简单，降低了运维成本的同时提升了客户满意度。
可视化流程图 技术选择 本可视化的技术路线选择原因如下：
数据清洗和计算的选择：采用了YMatrix + PL/Python解决，PL/Python过程语言允许用Python编写 PostgreSQL函数，而Python有非常多成熟的库能够提供给我们做数据分析，如Numpy、Pandas等，使用该方案不仅减少了传统大数据分析需要维护一整个配套设置的研发和运维成本，而且充分利用了分布式数据库的计算能力，经过多个案例检验性能远超Hive、Spark等框架。
可视化的选择：选择了Grafana和Django+Echarts实现，Grafana可以直接可以直接使用Postgresql协议查询YMatrix的数据，大盘选择使用Django+Echarts的解决方案，调用PL/Python的数据计算函数得到的结果使用echarts展示，数据大的图表使用Echarts的sampling LTTB 降采样算法，经过测试百万级别数据渲染仍然维持在秒级
实现示例 Grafana 展示案例 Echarts 展示案例 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1b99eb8cdab6b940b1816e4c35b5fcf/" rel="bookmark">
			一文看懂特征工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在训练一个销量预测模型的时候，遇到了一个问题，不管我如何调整网络结构和超参数，查准率和召回率就是上不去。吴恩达提到过机器学习的根本其实就是数据，所以我只想回过头从数据起源这边重新审视自己的模型。顺便将自己对特征工程的所有理解系统地整理出来，给自己做个笔记，也给未来的小白做个领路。这便文章不仅有对特征工程系统的解析，还会有python代码的实例演示，让我们一起出发吧！
文章目录 一、特征工程是什么及特征工程的意义二、什么是特征三、特征工程的总体流程四、特征工程流程详解和代码演示（1）数据采集（2）数据分析1、单变量分析a.计算统计特性b.绘制走势图c.绘制分布直方图 2、双变量分析a.绘制散点图 3、多变量分析 （3）数据清洗1、基于统计的异常点检测算法2、基于距离的异常点检测算法3、基于密度的异常点检测算法 （4）数据采样1、过采样的方法2、欠采样的方法 （5）数据缺失值处理1、缺失值的删除2、缺失值填充 （6）数据特征转换1、连续型特征处理a.标准化b.归一化c.函数转换d.二值化e.分箱处理 2、离散型特征处理a.数值化处理b.亚编码之独热编码b.亚编码之顺序性哑变量编码 3、时间序列处理a.时间戳处理 （7）数据特征选择1、过滤式方法进行特征选择a.卡方检验b.F 检验c.互信息 2、包装式方法进行特征选择（待更新）3、嵌入式方法进行特征选择（待更新） （8）数据特征构造1、四则运算2、特征交叉组合分类特征3、分解分类特征4、重构数值量5、分解Datatime6、窗口变量统计 （9）数据特征提取1、PCA主成分分析（待更新）2、LDA线性判别分析（待更新）5、分解Datatime6、窗口变量统计 （9）数据特征提取1、PCA主成分分析（待更新）2、LDA线性判别分析（待更新） 一、特征工程是什么及特征工程的意义 特征工程是将原始数据转化成更好表达问题本质的特征的过程，使得将这些特征运用到预测模型中能提高对不可见数据的模型预测精度；如何处理原始数据，发现对结果有明显影响作用的特征以更好地表达问题的本质就是做特征工程的目的；特征工程也是数据机器学习模型开发中较耗时、很重要的一步。重要性体现在特征选择和准备得越好，获得的结果大概率也会更好，对结果有直接的影响。耗时体现在它所涉及的流程和过程步骤较多，一份原始数据到成功的数据需要较多的处理。实际上，所有机器学习算法的成功取决于如何呈现数据
二、什么是特征 一个学生具备很多属性，例如身高、眼睛大小、是否戴眼镜、体重、数学成绩、语文成绩、英语成绩、喜欢吃汉堡、喜欢打游戏、喜欢睡懒觉。如果你要预测这个学生是否是学霸，那么身高、眼睛大小、体重这些属性显然不会是要使用到的特征，因为这些属性几乎对学生是否是学霸没有影响；而数学成绩、语文成绩、英语成绩更能体现学生是否是学霸；喜欢吃汉堡、喜欢打游戏、喜欢睡懒觉更能体现学生是否是学渣；所以这些属性可以作为预测学生是否是学霸的特征。
所以并不是所有的属性都可以看做特征，区分它们的关键在于看这个属性对解决问题有没有影响。所以可以认为特征是对于建模任务有用的属性，特征可以表达更多跟问题有关的内容。
常见的表格式的数据用行来表示一个实例（例如一个人），用列来表示属性（例如身高）。
三、特征工程的总体流程 开始流程：
根据具体问题和业务要求采集数据；例如要对学生进行学霸学渣的分类，就要采集学生的各项数据、可以直接去学校的数据库里面直接取、也可以做调研，根据自己实际情况出发决定。采集到数据之后，要对数据进行数据分析，了解数据不同属性的统计特征、例如属性的分布、最大值、最小值、标准差、方差、极值、直方图、密度分布曲线，做到对数据心中有数了解数据的整体情况之后，要对数据进行数据清洗，去除异常值、去除空值、去除重复值等然后对数据进行数据采样，做到样本的均衡。不同类别的数据数量不能相差几个数量级，对于不平衡的类别数据，需要在后边的算法中做处理然后对数据进行缺失值处理。包括缺失值删除、缺失值填充等然后对数据进行特征转换，包含连续型特征转换、离散型特征转换、时间序列处理。上面处理完成留下来的特征都是基于我们对业务和问题的理解挑选出来的，不一定是该模型真正需要的特征，所以我们还需要对这些特征进行检验和选择，包含卡方检测、F检测、互信息，还包括嵌入法和包装法，下面章节会详细演示说明。经过上面的流程七如果我们选择的特征还不足够满足我们的要求，我们还可以对特征进行构造，包含四则运算、特征交叉、分解类别特征、机器学习等方法经过上面的流程七如果我们选择的特征数量远超过我们的要求，并且非常多余，我们需要对特征进行提取，包含线性降维、非线性降维、迁移学习降维等方法到这一步就是将数据输入我们构建的网络模型进行训练了，俗称入模。结束 流程表格：
流程流程关键词方法总结1数据采集数据库读取、调研、问卷收集、爬虫2数据分析计算属性统计特征、如最大最小值、标准差、分布直方图3数据清洗去除异常值、空值、重复值4数据采样数据采样、样本均衡5数据缺失值处理缺失值删除、缺失值填充6数据特征转换（重难点）连续型特征转换、离散型特征转换、时间序列处理7数据特征选择（重难点）包含卡方检测、F检测、互信息，还包括嵌入法和包装法8数据特征构造四则运算、特征交叉、分解类别特征、机器学习9数据特征提取包含线性降维、非线性降维、迁移学习降维10数据入模生成器对象数据入模 四、特征工程流程详解和代码演示 （1）数据采集 如果你参加kaggle的比赛，那么比赛方会将所需数据提供给你；如果是公司的成熟业务，公司会有数据分析师将数据库给到你，你自己读取即可；如果是公司的创新业务，就需要你在深度理解业务的基础之上在公司能力范围内拿合适的数据，如果公司没有这些数据，你需要去网上下载、爬虫、调研、问卷收集等等手段收集数据
（2）数据分析 一般对数据先进行单变量分析，了解单个特征的数据分布情况、统计特性如平均值、最大值最小值、极值、标准差等等。然后再通过双变量分析，了解不同特征之间的关系，可以画散点图，如果图像呈现直线或者曲线，说明两个特征彼此相关。一般数据分析到这一步即可。
1、单变量分析 单变量分析是数据分析中最简单的形式，其中被分析的数据只包含一个变量。因为它是一个单一的变量，它不处理原因或关系。单变量分析的主要目的是描述数据并找出其中存在的模式。
可以将变量视为数据所属的类别，比如单变量分析中，有一个变量是“年龄”，另一个变量是“高度”等，单因素分析就不能同时观察这两个变量，也不能看它们之间的关系。
单变量数据中的发现模式有：查看平均值、模式、中位数、范围、方差、最大值、最小值、四分位数和标准偏差。此外，显示单变量数据的一些方法包括频率分布表、柱状图、直方图、频率多边形和饼状图。
a.计算统计特性 下面所说的统计特征函数主要作为Pandas的对象DataFrame或Series的方法出现。
describe 针对Series或个DataFrame列计算汇总统计 count 非na值的数量 min、max 计算最小值和最大值 idxmin、idxmax 计算能够获取到最大值和最小值得索引值 quantile 计算样本的分位数（0到1） sum 值的总和 mean 值得平均数 median 值得算术中位数（50%分位数） mad 根据平均值计算平均绝对离差 var 样本值的方差 std 样本值的标准差 corr 样本值的Spearman（Person）相关系数矩阵 skew 样本值得偏度（三阶矩） kurt 样本值得峰度（四阶矩） 例如
import pandas as pd df = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1b99eb8cdab6b940b1816e4c35b5fcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6f02d3e84ae11449a2cdbcb83cc4606/" rel="bookmark">
			揭秘关于TFRcord的五脏六腑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		揭秘关于TFRcord的五脏六腑 前言：本篇文章将演示如何创建、解析和使用tf.Example消息，以及如何在.tfrecord文件之间对tf.Example消息进行序列化、写入和读取。
教程讲解使用的都是结构化数据，文章最后还会演示如果将图片写成.tfrecord文件，这在同个数据集用于不同模型情景之下非常有用。
官网文档是从讲原理，然后再展现示例。我觉得这种方式很容易劝退小白，因为原理晦涩难懂。这里先展示示例，然后再肢解示例，先总体再细分的思想
希望能让读者更容易理解和接受
一、如何将标量输入值变成协议消息 这里先不解释什么是协议消息，先看示例，后解释
# todo 导入相应工具包 import tensorflow as tf import numpy as np import IPython.display as display # todo 为了讲解，模拟生成一些数据 # 这里准备生成10000个元素 n_observations = int(1e4) # 随机生成10000个True和False布尔值 feature0 = np.random.choice([False, True], n_observations) # 随机生成10000个0-5的整数 feature1 = np.random.randint(0, 5, n_observations) # 随机生成10000个值是以下字符串的字符串 strings = np.array([b'cat', b'dog', b'chicken', b'horse', b'goat']) feature2 = strings[feature1] # 随机生成10000个01正太分布数据，数据是浮点型 feature3 = np.random.randn(n_observations) # todo 下面分别演示将字符串类型标量、浮点型标量、整数型标量转换成协议消息 # todo 这些方法可以复制过去直接使用 def _bytes_feature(value): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6f02d3e84ae11449a2cdbcb83cc4606/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86b294382c0125aa6142f7b40c6b205e/" rel="bookmark">
			MSVCP140.dll下载及安装教程，dll修复方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MSVCP140.dll是Windows操作系统中的一个DLL文件，许多程序依赖于它来正常运行。如果您尝试运行某个程序时，发现缺少MSVCP140.dll文件，那么您需要下载并安装它才能解决问题。本文将介绍如何MSVCP140.dll下载和安装MSVCP140.dll。
第一步：确定系统位数和版本 在下载MSVCP140.dll之前，您需要确定您的操作系统的位数和版本。请按照以下步骤操作：
打开“计算机”或“此电脑”，右键单击并选择“属性”。
在“系统”窗口中，查找“系统类型”，确定操作系统的位数是32位还是64位。
确认操作系统的版本，例如Windows 10。
第二步：下载MSVCP140.dll文件 下载MSVCP140.dll文件的最简单的方法是从Microsoft官方网站下载Visual C++ Redistributable for Visual Studio 2015程序。请按照以下步骤操作：
访问Microsoft官方网站，并下载Visual C++ Redistributable for Visual Studio 2015程序。
根据您的操作系统位数和版本，选择适当的程序并下载。
运行下载的程序，并按照提示完成安装。
第三步：将MSVCP140.dll文件放入程序目录 如果您仍然遇到MSVCP140.dll丢失的问题，则可以尝试手动下载MSVCP140.dll文件，并将其放入程序目录中。请按照以下步骤操作：
在浏览器中搜索“MSVCP140.dll下载”，并下载该文件。
找到您要运行的程序的安装目录。通常，程序的安装目录位于“C:\Program Files”或“C:\Program Files (x86)”中。
将下载的MSVCP140.dll文件复制到程序目录中。
重新启动计算机，尝试运行程序，查看是否已经解决了MSVCP140.dll丢失的问题。
如果觉得这种修复MSVCP140.dll的方法太麻烦，那么可以考虑使用dll修复工具，电脑修复精灵的dll修复工具，可以快速的一键检测和修复dll文件，有自动修复和手动修复两个选项，如果你本身就知道哪个dll文件丢失了，那么可以用手动修复，在dll修复那，输入MSVCP140.dll就可以进行修复了。DLL修复工具_一键修复所有dll缺失msvcp140.dll丢失的解决方法–电脑修复精灵
在百度搜索电脑修复精灵，找到zhiniao站点，直接进入下载dll修复工具就可以了。
MSVCP140.dll是Windows操作系统中的一个重要的DLL文件，许多程序需要它才能正常运行。本文介绍了如何下载和安装MSVCP140.dll文件，以及如何将其放入程序目录中。
以上就是关于MSVCP140.dll下载的全部内容了，希望本文能帮助到大家，如果想了解更多，可以继续关注小编，小编会持续给大家分享各种电脑故障修复知识。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b50531ba39a5d6178c803d4606018843/" rel="bookmark">
			时间类型转换——date和String的相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常性在代码中需要做一些时间处理，有的时候一着急就会写错，特此总结一下
public static void main(String[] args) { String ds = "20220923"; String ds1 = "2022-10-18T02:36:34.000Z"; Long millisDate = 1663948799000l; Long times = 1663948799l; SimpleDateFormat sdf1 = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX"); SimpleDateFormat format = new SimpleDateFormat("yyyyMMdd HH:mm:ss"); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyyMMddHHmmss"); try { //UTC格式转date Date parse1 = sdf1.parse(ds1); //字符串String转date Date parse = format.parse(ds + " 00:00:00"); //字符串转date获取毫秒值 long time = format.parse(ds + " 23:59:59").getTime(); //date转String String formatTime = sdf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b50531ba39a5d6178c803d4606018843/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c9c04b9820f05eedbaa98d509eb4301/" rel="bookmark">
			Mac电脑 Neither the JAVA_HOME nor the JRE_HOME environment variable is defined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题产生背景 今天在公司的电脑上配置Tomcat，从官网上下载tomcat后结果使用命令
注意：下面这个cd路径是我Tomcat下载解压的路径，具体需要看你自己的电脑。我下载方法就是从官网下载tomcat后，解压，将文件夹命名为 Tomcat，并且把它拖动到“资源库Library”中。
cd /Library/Tomcat/bin sudo sh ./startup.sh 输入密码后 就出现了未安装上面的问题。
明明我已经配置好了JAVA_HOME，Tomcat就跟个大s比一样识别不出。所以我们需要在tomcat验证Java_home的地方进行一些修改。
1。如果你的电脑是Windows，那么你需要找到Tomcat解压目录中的Tomcat/bin/setclasspath.bat。
2. 如果你的电脑是Mac电脑，你需要找到Tomcat/bin/setclasspath.sh
解决方案 打开setclasspath文件，然后在这个位置添加2行
export JAVA_HOME =你的JDK中Home的路径 export JRE_HOME =你的JDK中Home/jre的路径 效果 输入命令
sudo sh ./startup.sh 其他问题 1. 我不知道我电脑Java_home路径是什么，怎么查看？
命令行输入：
/usr/libexec/java_home -V 这个路径就是的Java_home路径，而 jre_home路径就是在Java_home后面加上 /jre
有任何问题，欢迎评论，博主除了双休，其他时间都在上班，可以快速回复你哈。
2.我的eclipse配置好了tomcat，启动后又出现了以下问题
出现这个问题是因为你已经用刚才的命令行启动了tomcat，所以它会显示 already in use。所以我们需要手动使用命令进行关闭。
cd /Library/Tomcat/bin sudo sh shutdown.sh 3.我用eclipse已经启动了tomcat，但是浏览器访问localhost：8080出现了4040错误
404一直以来都是一个棘手的问题，不管是新手还是老手，你看一下你的server服务器界面是不是如以下图：
如果是的话修改成如下的样子，看是否问题解决了。
记得点击保存，重新启动服务器，打开浏览器，输入localhost:8080。我的成功了。如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a287a510b60e8e32432a88002ff8ce7a/" rel="bookmark">
			擦除/移除std::vector元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		擦除/移除std::vector元素 首先要知道的是 std::remove并不会将你想要移除的元素移出容器，他只是将你想要删除的元素用后方元素覆盖。
#include &lt;vector&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int main() { vector&lt;int&gt; demo{1, 3, 3, 4, 3, 5}; // 覆盖要删除的元素， remove 后元素应该如右所示 1 4 5 4 3 5 auto iter = std::remove(demo.begin(), demo.end(), 3); for (auto first = demo.begin(); first &lt; demo.end(); ++first) { cout &lt;&lt; *first &lt;&lt; " "; } cout &lt;&lt; endl; cout &lt;&lt; "size is :" &lt;&lt; demo.size() &lt;&lt; endl; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a287a510b60e8e32432a88002ff8ce7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56ac7c41525d0a60506afcf93c2aa9b7/" rel="bookmark">
			python pandas 常用方法汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
一、pandas是什么？
二、使用步骤
1.引入库
2.处理时间序列数据
3.分组聚合（groupby）
3.1基本方法
3.2具体使用：如图包含三个字段，company、salary、age 总结
Pandas 最最常用函数罗列
Pandas 函数用法示例
前言 提示：这里可以添加本文要记录的大概内容：
例如：随着人工智能的不断发展，机器学习这门技术也越来越重要，很多人都开启了学习机器学习，本文就介绍了机器学习的基础内容。
提示：以下是本篇文章正文内容，下面案例可供参考
一、pandas是什么？ 示例：pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。
二、使用步骤 1.引入库 DataFrame基础操作
df.values # 查看所有元素
df[''].value_counts #统计某列中类的数量,参数：normalize(返回占比)、sort（排序）、
ascending （boolean, default False）（是否升序排列）。。
比如：df['company'].value_counts(normalize=True)
df.head # 查看前五行的数据
df.tail # 查看最后五行的数据
df.index # 查看索引
df.columns # 查看所有列名
df.dtype # 查看字段类型
df.size # 元素总数
df.ndim # 表的维度数
df.shape # 返回表的行数与列数
df.info # DataFrame的详细内容
df.describe # 生成描述性统计汇总，包括均值、max等
df.isna # 判断数据是否为缺失值，是的话返回true
df.isna().any() # 数据量较大时，使用any()查看某一列是否有缺失值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56ac7c41525d0a60506afcf93c2aa9b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/021c9f881ca2fbba140d803187e753d4/" rel="bookmark">
			python医学图像分割肝脏预处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**近期在实现肝脏分割，预处理阶段遇到了问题，不知道怎么返回投影后第一个不为0的像素坐标。 **
原论文是这样描述预处理过程的：根据解剖学先验,肝脏通常位于人体腹腔右部。 在CT 断层扫描中,肝脏区域主要出现在横切面视角成像图像的腹腔左侧,如图 1(a)所示。 为了获取包含完整肝脏的感兴趣区域、去除不相关组织器官的干扰,需对 CT 图像进行裁剪。 首先,采用阈值和数学形态学方法[17]对CT 图像中的肋骨和脊椎进行分割,得到结果如图 1(b)所示。 然后,对分割结果进行行和列投影,且分别取第 1个以及最后一个不为 0 的像素所在的行和列,构建长为Lw、宽为Lh的矩形框,定位腹腔区域如图 1(c)所示。 考虑到肝脏区域通常位于 CT 切片腹腔左侧,将矩形框中心点 O 向左平移 Lw/4 得到点P,并以点P 为中心取大小320×320 的方形区域作为最终的裁剪结果。 最后对裁剪区域图像的窗位与窗宽进行调整。 根据放射医学先验知识,可显示的人体组织 CT 值范围一般为-1 000~1 000 Hu,而肝、脾、肾、肌肉等器官软组织的 CT 值范围通常在 40 ~70 Hu。 为了增强肝脏与毗邻组织的对比度,本文将 CT图像的窗位和窗宽分别设置为 60 和 170 Hu,即可得到预处理图像如图 1(d)所示。
目前已经实现了b图，但c图怎么实现呢？用什么函数或方法呢？可以给我一些思路或建议吗？谢谢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fabea8c9ec395bbb2779ff1f2bfe6804/" rel="bookmark">
			干货！Playwright架构与Selenium 架构对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Web 测试自动化方面，Selenium 多年来一直是行业的主导工具。但是，市场上还有许多其他自动化测试工具。Playwright是一种较新的工具，已经越来越受欢迎。网上有很多文章对二者进行对比，今天我从二者的架构角度进行一下对比分析！关于二者在其他方面的区别，我会在后面的文章中持续更新，也欢迎大家关注。
Selenium 架构 蓝色图中的Selenium Language Binding就是我们平时使用的编码语言，包括java、python等等。可以看到这些语言并没有直接与Browser Drivers进行通信，而是通过了JSON WireProtocol，这就是webdriver协议，然后通过webdriver协议在与各个浏览器的driver进行通信，最后各个浏览器的driver与其对应的浏览器进行通信。这里我们以chromedriver为例进行讲解，他负责与chrome浏览器进行通信。我们在代码中直接 newChromeDriver() 将会启动一个 ChromeDriver进程，ChromeDriver是一个独立的服务，它是google为网站开发人员提供的自动化测试接口，是 selenium 和chrome浏览器进行通信的桥梁。chromeDriver解析webdriver协议，然后根据解析结果，调用与之对应的Chrome DevTool Protocol（CDP）协议来操控chrome浏览器，它可以和浏览器内核进行交互进而操控浏览器，这里就不对该协议进行详细介绍了。另外，其他浏览器的dirver与其对应浏览器的通信原理与ChromeDriver类似。
Playwright 架构 client：在客户端是我们用不同的编程语言编写的代码，如JavaScript，Java，Python，C#等。
server：Playwright的server通过nodejs构建并负责与client 以及不同的 Web 浏览器引擎进行通信。
通信协议：client通过WebSocket 协议与Playwright server 通信；
Playwright使用 Chrome DevTools 协议（CDP）与 Chromium 通信。对于Firefox和WebKit，Playwright实现了自己的协议，类似于CDP。一旦触发测试，client端代码将被转换为JSON格式，然后使用websocket协议发送到服务器。palywright通过单个 websocket 协议连接传达所有请求，该连接将保持不变，直到所有测试执行完成。由于命令是在单个连接上发送的，因此测试失败或不稳定的可能性较小，并且命令可以快速执行。这种架构与Selenium相反，Selenium使用HTTP连接协议，并将每个命令（如浏览器打开，单击，发送密钥或关闭浏览器）作为单独的HTTP请求发送。此外，在Selenium中，服务器和客户端之间的连接将在每次请求后终止，并为下一个请求重新建立。最后划重点：这就是Playwright比selenium快的原因！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98a114f1034e2ff26ee2fece7f18b311/" rel="bookmark">
			2023环翠区编程挑战赛小学组题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		T1. 乘车费用 题目描述 星期天上午小红乘出租车去本市的奶奶家。出租车计价方案为： 3 3 3公里以内（包括 3 3 3公里）起步价是 13 13 13元，超过 3 3 3公里之后按 2.3 2.3 2.3元/公里计价，整个乘车途中另加 1 1 1元钱的燃油费。
已知：小红到奶奶家的路程为 N N N 公里，请你计算一下小红到奶奶家的出租车费用是多少元？
输入格式
输入一个整数 N N N，表示路程
输出格式
输出一个整数表示乘车 N N N公里后，出租车的费用（要求四舍五入保留整数），单位：元。
输入样例1
2 输出样例1
14 输入样例2
15 输出样例2
42 数据范围
对于 20 % 20\% 20%的数据 1 ≤ N ≤ 3 1 ≤ N ≤ 3 1≤N≤3 。
对于 100 % 100\% 100%的数据 1 ≤ N ≤ 30 1 ≤ N ≤ 30 1≤N≤30 ，其中存在 30 % 30\% 30%的数据需要考虑四舍五入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98a114f1034e2ff26ee2fece7f18b311/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffeb80f6e03316a2370413ea61297a0e/" rel="bookmark">
			【GO】k8s 管理系统项目19[前端部分–Header]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【GO】k8s 管理系统项目[前端部分–Header] 1. 实现功能 面包屑展开关闭按钮用户信息(退出按钮) 2. 代码部分 src/layout/Layout.vue
在之前预留header位置补上
&lt;!-- header --&gt; &lt;el-header class="header"&gt; &lt;el-row :gutter="20"&gt; &lt;el-col :span="1"&gt; &lt;!-- 折叠按钮 --&gt; &lt;div class="header-collapse" @click="onCollapse"&gt; &lt;el-icon&gt;&lt;component :is="isCollapse ? 'expand':'fold'" /&gt;&lt;/el-icon&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;el-col :span="10"&gt; &lt;!-- 面包屑 --&gt; &lt;div class="header-breadcrumb"&gt; &lt;!-- separator 分隔符 --&gt; &lt;el-breadcrumb separator="/"&gt; &lt;!-- :to="{ path: '/' }"表示跳转到/路径 --&gt; &lt;el-breadcrumb-item :to="{ path: '/' }"&gt;工作台&lt;/el-breadcrumb-item&gt; &lt;!-- this.$route.matched 可以拿到当前页面的路由信息 --&gt; &lt;template v-for="(matched,m) in this.$route.matched" :key="m"&gt; &lt;el-breadcrumb-item v-if="matched.name != undefined"&gt; {{ matched.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffeb80f6e03316a2370413ea61297a0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a9bc25ec8dc4dc79639f6c27faefb37/" rel="bookmark">
			MongoDB安装（新版本保姆级教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 MongoDB 是一个文档数据库，旨在简化开发和扩展。
本篇文章介绍MongoDB 数据库及其 可视化工具 MongoDB Compass 的详细教程 (window10操作系统)
下载安装包 首先进入官网(社区版) ，在对应页面选择需要安装的版本 (这里下载当前适合版本号)
传送门
安装 因为选择下载的是 .zip 文件，直接跳过安装，一步到位
里面的目录结构如下
选择在任一磁盘创建空文件夹（不要使用中文路径），解压之后把文件夹内容剪切进去（本人选择 D盘）
手动创建 data 和 log 两个文件夹
配置环境变量 电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 找到 path，打开路径，将自己的 MongoDB 的 bin 文件地址添加上去 启动服务 1 创建db 文件夹 在data的目录下，创建一个db文件； 类似于：‘D:\MongoDB\data’;
因为启动 MongoDB 服务之前需要必须创建数据库文件的存放文件夹，否则命令不会自动创建，而且不能启动成功;
2在 bin 目录直接上面输入cmd 3 输入命令 输入如下命令后按回车，后面的路径是data 文件夹下的 db 目录路径 ( 类似 D:\MongoDB\data\db）
mongod --dbpath D:\MongoDB\data\db 回车之后下面会出现一大堆下面这样的（看的眼花缭乱）
4成功 在浏览器中输入下面的地址和端口号
http://localhost:27017/ 若显示结果如下，就说明安装成功并结束
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a9bc25ec8dc4dc79639f6c27faefb37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb2cf9ad6b350f6b0f79faca83782d9d/" rel="bookmark">
			xxjob分布式任务调度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在工作中使用到了定时任务,通过查找资料选择了xxjob,以下是xxjob的介绍以及基本的使用.
xxjob介绍 XXL-JOB是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。
将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求。
将任务抽象成分散的JobHandler，交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的JobHandler中业务逻辑。
参考官网：https://github.com/xuxueli/xxl-job
中文文档：https://www.xuxueli.com/xxl-job/#《分布式任务调度平台XXL-JOB》
系统组成 1.调度中心
● 负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码;
● 调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块;
● 支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等，所有上述操作都会实时生效;
● 支持监控调度结果以及执行日志，支持执行器Failover.
2.执行器
● 负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效；
● 接收“调度中心”的执行请求、终止请求和日志请求等
下载源码 源码仓库地址:
https://github.com/xuxueli/xxl-job
http://gitee.com/xuxueli0323/xxl-job
maven仓库地址 &lt;!-- http://repo1.maven.org/maven2/com/xuxueli/xxl-job-core/ --&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;version&gt;${最新稳定版本}&lt;/version&gt; &lt;/dependency&gt; 初始化“调度数据库” 下载项目源码并解压，获取 “调度数据库初始化SQL脚本” 并执行即可。
“调度数据库初始化SQL脚本” 位置为: /xxl-job/doc/db/tables_xxl_job.sql
调度中心支持集群部署，集群情况下各节点务必连接同一个mysql实例;
如果mysql做主从,调度中心集群节点务必强制走主库;
编译源码 解压源码,按照maven格式将源码导入IDE, 使用maven进行编译即可，源码结构如下：
xxl-job-admin：调度中心
xxl-job-core：公共依赖
xxl-job-executor-samples：执行器Sample示例（选择合适的版本执行器，可直接使用，也可以参考其并将现有项目改造成执行器）
：xxl-job-executor-sample-springboot：Springboot版本，通过Springboot管理执行器，推荐这种方式；
：xxl-job-executor-sample-frameless：无框架版本；
调度中心配置 打开idea工具，修改调度中心，修改数据库地址，用户，密码 改为自己本地使用数据库。
调度中心配置文件地址：
/xxl-job/xxl-job-admin/src/main/resources/application.properties
调度中心配置内容说明：
### 调度中心JDBC链接：链接地址请保持和 2.1章节 所创建的调度数据库的地址一致 spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai spring.datasource.username=root spring.datasource.password=root_pwd spring.datasource.driver-class-name=com.mysql.jdbc.Driver ### 报警邮箱 spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb2cf9ad6b350f6b0f79faca83782d9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4d3e95403c411a42e6b1b1903d620b4/" rel="bookmark">
			网络编程之token、session、cookie详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		token和session与cookie详解以及应用原理 一、我们先解释一下Token的含义 1、Token的引入： Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。 2、Token的定义： Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。 3、使用Token的目的： Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。 4.Token 的优点： 扩展性更强，也更安全点，非常适合用在 Web 应用或者移动应用上。Token 的中文有人翻译成 “令牌”，我觉得挺好，意思就是，你拿着这个令牌，才能过一些关卡。 5.Token一般用在三个地方: ①防止表单重复提交 ②anti csrf攻击（跨站点请求伪造） ③身份验证（单点登录） 了解了Token的意义后，我们就更明确的知道为什么要用他了。
二、如何使用Token？ 这是本文的重点，在这里我就介绍常用的两种方式。 1、用设备号/设备mac地址作为Token（推荐） 客户端：客户端在登录的时候获取设备的设备号/mac地址，并将其作为参数传递到服务端。 服务端：服务端接收到该参数后，便用一个变量来接收同时将其作为Token保存在数据库，并将该Token设置到session中，客户端每次请求的时候都要统一拦截，并将客户端传递的token和服务器端session中的token进行对比，如果相同则放行，不同则拒绝。 分析：此刻客户端和服务器端就统一了一个唯一的标识Token，而且保证了每一个设备拥有了一个唯一的会话。该方法的缺点是客户端需要带设备号/mac地址作为参数传递，而且服务器端还需要保存；优点是客户端不需重新登录，只要登录一次以后一直可以使用，至于超时的问题是有服务器这边来处理，如何处理？若服务器的Token超时后，服务器只需将客户端传递的Token向数据库中查询，同时并赋值给变量Token，如此，Token的超时又重新计时。 2、用session值作为Token 客户端：客户端只需携带用户名和密码登陆即可。 客户端：客户端接收到用户名和密码后并判断，如果正确了就将本地获取sessionID作为Token返回给客户端，客户端以后只需带上请求数据即可。 分析：这种方式使用的好处是方便，不用存储数据，但是缺点就是当session过期后，客户端必须重新登录才能进行访问数据。 三、使用过程中出现的问题以及解决方案？ 刚才我们轻松介绍了Token的两种使用方式，但是在使用过程中我们还出现各种问题，Token第一种方法中我们隐藏了一个在网络不好或者并发请求时会导致多次重复提交数据的问题。 该问题的解决方案：将session和Token套用，如此便可解决，如何套用呢？请看这段解释： session是一个在单个操作人员整个操作过程中，与服务端保持通信的唯一识别信息。在同一操作人员的多次请求中，session始终保证是同一个对象，而不是多个对象，因为可以对其加锁。当同一操作人员多个请求进入时，可以通过session限制只能单向通行 本文正是通过使用session以及在session中加入token，来验证同一个操作人员是否进行了并发重复的请求，在后一个请求到来时，使用session中的token验证请求中的token是否一致，当不一致时，被认为是重复提交，将不准许通过。 这就是解决重复提交的方案。 四、基于 Token 的身份验证方法 使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token发送给客户端 客户端收到 Token 以后可以把它存储起来，比如放在Cookie 里或者 Local Storage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据
session和cookie session ：就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。
cookie：非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求会把该cookie发送给服务器。
区别：cookie数据存放在客户的浏览器上，session数据放在服务器上。将重要信息存放在Session中，其他信息如果需要保留，可以放在cookie中。
session认证流程如下:
1、当用户首次访问服务器的时候，服务器为每个用户单独创建一个 Session 对象，并分配一个新的 SessionID，此时 SessionID 通过 cookie 保存在用户端。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4d3e95403c411a42e6b1b1903d620b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/113dace5a38e98985b9a64b87fb53bbf/" rel="bookmark">
			轻量级网络模型ShuffleNet V1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习ShuffleNet内容前需要简单了解卷积神经网络和MobileNet的相关内容，大家可以去看我之前的一篇博客MobileNet发展脉络（V1-V2-V3），🆗，接下来步入正题~
卷积神经网络被广泛应用在图像分类、目标检测等视觉任务中，并取得了巨大的成功。然而，卷积神经网络通常需要较大的运算量和内存占用，在移动端以及嵌入式设备等资源受限的环境中受到限制，因此需要进行网络压缩。
模型介绍 ShuffleNet是旷视推出的轻量级网络模型，旨在不过多牺牲模型性能的同时大幅度减小模型的尺寸和加快模型的运算速度。ShuffleNet和MobileNet是同年提出的工作，专门为计算资源有限的设备设计的神经网络结构。两者从两个不同的角度来分析卷积。MobileNet通过深度可分离卷积来实现模型的压缩，而ShuffleNet利用了分组点卷积pointwise group convolution来降低参数量，利用通道重排channel shuffle操作来增强不同通道之间的交互和融合。在保留了模型精度的同时极大减少了计算开销。
分组点卷积 常规卷积 常规卷积操作输入有几个通道，卷积核就有几个通道，同时有多少个卷积核就生成多少个feature map，因此，对于一个7x7x3的输入，使用3x3x3的卷积核进行卷积，卷积核的个数共有128个，所以输出就是5x5x128的feature map.
分组卷积 如上图，分组卷积将12个通道的输入分成3组，每组4个通道，每一组的通道使用两个卷积核进行卷积，得到2个feature map，三组就得到6个feature map。可以看出最终的输出是和标准卷积相同的，但是在计算过程中的参数量降低为原来的1/3.
同理，分组卷积就是使用一半维数的卷积核去处理一半维数的输入，最终将处理的结果拼接到一起就形成了最终的输出。
点卷积 ShuffleNet中的点卷积和MobileNet中的深度可分离卷积中的点卷积一样，即执行1x1卷积来融合所有通道上的信息。深度卷积每个卷积核只处理1个输入特征通道，在这个过程中通道与通道之间的联系被切断，所以后面需要再用 1x1 大小的逐点卷积层来处理M个特征通道之间的信息。
分组点卷积 分组点卷积也就是说又点卷积又分组，即将分组卷积中的卷积核的大小变为1*1的点卷积。但是这里的点卷积就不是贯通输入全通道了，而是贯通分组后的每一组的全通道。
通道重排 通道重排的过程如上图所示，先将通道排成一行，然后reshape成g行n列的矩阵，再对这个矩阵进行转置，最终将转置后的矩阵进行展平，按照组数去取其中的元素就是重排后的组的元素。
网络结构 (a)表示Resnet的结构示意图，其中右边将3x3的常规卷积替换成了3x3的深度可分离卷积，左边是利用shortcut connection恒等映射，逐元素相加最后再接Relu激活。
(b)表示正常ShuffleNet的模块，右边先进行分组点卷积，然后通道重排，其次接3x3深度可分离卷积，最后接分组点卷积输出。左边利用shortcut connection恒等映射，逐元素相加最后再接Relu激活。
(c)表示降采样的ShuffleNet的模块，右边先进行分组点卷积，然后通道重排，其次接步长为2的3x3深度可分离卷积进行降采样，最后接分组点卷积输出。左边利用接步长为2的3x3平均池化进行下采样，然后将两边连接起来再接Relu激活。
实验结果 对不同scale和分组数的性能
不同channel shuffle对不同网络大小作用
ShuffleNet与MobileNet在ImageNet分类的结果比较
作为目标检测主干网络在COCO数据集上的结果对比
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1c42543afecefa22583c0e457358dc2/" rel="bookmark">
			轻量级网络模型ShuffleNet V2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习ShuffleNet V2内容前需要简单了解卷积神经网络和MobileNet,以及Shuffnet V1的相关内容，大家可以出门左转，去看我之前的几篇博客MobileNet发展脉络（V1-V2-V3），轻量级网络模型ShuffleNet V1🆗，接下来步入正题~
卷积神经网络被广泛应用在图像分类、目标检测等视觉任务中，并取得了巨大的成功。然而，卷积神经网络通常需要较大的运算量和内存占用，在移动端以及嵌入式设备等资源受限的环境中受到限制，因此需要进行网络压缩。
ShuffleNet-V2是旷视推出的继ShuffleNet-V1的轻量级网络模型，旨在不过多牺牲模型性能的同时大幅度减小模型的尺寸和加快模型的运算速度。在同等复杂度下，ShuffleNet-V2比ShuffleNet-V1和MobileNet-V2更准确。
轻量级网络模型回顾 MobileNet v1: 提出了 深度可分离卷积和两个全局超参数-宽度乘法器和分辨率乘法器。
MobileNet v2: 在MobileNet V1深度可分离卷积的基础上提出了具有线性瓶颈的倒置残差块。
MnasNet: 提出了分层的神经网络架构搜索空间，使用NAS搜索各自基本模块，通过多目标优化的目标函数进行反馈和修正。
MobileNet v3：使用了 NAS 和 NetAdapt 算法搜索最优的模型结构，同时对模型一些结构进行了改进，在 MobileNet_V2的具有线性瓶颈的倒置残差块基础上引入MnasNet的Squeeze-and-Excitation注意力机制。
ShuffleNet v1：利用分组点卷积来降低参数量，利用通道重排操作来增强不同通道之间的交互和融合。
ShuffleNet v2：提出了四条有效的网络设计原则，并根据这四条原则设计了一个高效的网络结构。
轻量级网络模型比较 四条轻量级网络模型设计原则 当输入输出通道相同的时候，内存访问量MAC最小，运行速度最快 乘法-加法浮点运算次数FLOPs只反映卷积层，仅为间接的指标
分组卷积以及过大的分组数会导致内存访问量MAC变大 分支结构会产生碎片化并降低并行能力 逐元素操作的开销不可忽略 轻量化网络模型总结 ShuffleNet V2中提出的四条轻量化网络设计准则：
一、输入输出通道相同时内存访问量MAC最小
二、分组数过大的分组卷积会增加MAC
三、碎片化的操作对网络并行加速不友好
四、逐元素操作带来的内存和耗时不可忽略
MobileNet v2在MobileNet V1深度可分离卷积的基础上提出了具有线性瓶颈的倒置残差块，输入输出通道不一致，不满足准则一。
MnasNet提出了分层的神经网络架构搜索空间，使用NAS搜索各自基本模块，通过多目标优化的目标函数进行反馈和修正，各个block碎片化，不利用并行，不满足准则三。
MobileNet v3使用了 NAS 和 NetAdapt 算法搜索最优的模型结构，同时对模型一些结构进行了改进，在 MobileNet_V2的具有线性瓶颈的倒置残差块基础上引入MnasNet的Squeeze-and-Excitation注意力机制，不满足准则一和三。
ShuffleNet v1利用分组点卷积来降低参数量，利用通道重排操作来增强不同通道之间的交互和融合。使用分组卷积不满足准则二。
此外，所有的轻量级网络模型都是用了逐元素操作，都不满足准则四。
ShuffleNet V2 网络模块 ShuffleNet V1 ShuffleNet V2
ShuffleNet V2 模型结构 ShuffleNet V2 实验对比 ShuffleNet V2模型总结 一、提出了四条轻量化网络模型设计原则，并根据这四条准则设计了shufflenet v2网络结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1c42543afecefa22583c0e457358dc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e24d84c4b74795ed0a3d628158780138/" rel="bookmark">
			设计模式之Adapter模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Adapter模式 书中提到的Adapter模式，以使用AC适配器，使得额定功率12伏特的电脑在100伏特的交流电环境下工作这样的日常需求为例，阐述了实现Adapter模式的两种方法类适配器模式和对象适配器模式
类适配器模式 类图 题外话
回忆起上一种设计模式中，作者曾在章末强调 请大家将“不要只使用具体类来编程，要优先使用抽象类和接口来编程”印在脑海中 于是前者的Iterator接口，在调用main方法时，也是优先将实例存入接口中，而非直接使用具体类来编程，从类图可以看出，在本章中也是如此
正文
可以很容易的看出，在案例中，Print接口象征的是额定功率为12伏特的电脑，Banner类象征的是实际情况：100伏特的交流电环境，而PrintBanner类则为AC适配器。当笔者看到这一步时，由于悟性有限并没有多大感悟，我仍然在思考其中妙处。于是我便不使用适配器模式来完成这项需求，即砍掉PrintBanner类，在对比中寻求突破。于是我发现了问题所在，由于用户最终要调用Print接口中的两个方法来实现需求，但目前实体类却已经确定了，就是要用Banner中的showWithAster和showWithParen来实现需求，那么要想使用Print接口中的方法来完成showWithAster和showWithParen一样的效果，只有两种途径
其一：实现Print接口，将方法重写为一模一样的需求，那么问题也很明显了，非常的浪费精力
其二：实现Print接口，在实现类中调用Banner方法，这似乎就是类适配器模式本身
接下来谈谈我的看法，到这之后笔者似乎发现一个点，那就是适配器模式本身的应用场景似乎在于处理一些强制性问题，比方说某种不一致，是纯粹的一种解决问题的方案，在多人开发或者是使用他人写的方法上可能会经常用到这点，如果是个人开发，当遇到需要使用适配器模式来解决问题时，似乎更多意味着程序设计阶段本身的设计失误。
对象适配器模式 类图 同样是处理不适配问题，但对象适配器的使用场景与类适配的使用场景有所不同，区别主要在于用户最终调用的是接口还是类，由于核心理论已理清，于是题主在这就只点一下原理来保证文章完整度。由于Java中规定，一个子类只能同时继承一个父类，所以该设计模式中，无法与类适配中一样，让PrintBanner先继承Banner类再实现Print接口，只能选择折中的方案，即让PrintBanner继承Print类再创建出Banner类实例，调用Banner类的方法，其中原理和类适配器完全相同。在这我又在思考一个问题，既然如此，是不是也可以先继承Banner类在创建Print实例呢，答案是否定的，因为最终的需求是调用Print类，而如果PrintBanner类继承的是Banner类，则无法将PrintBanner的实例赋值给Print对象。
以下为不带案例的类图 类适配器模式 对象适配器模式 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4636b20ea68bf3815a3a92c1d3734ff8/" rel="bookmark">
			按键控制LED闪烁实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、要求 两个按键KEY0、KEY1控制LED0、LED1的闪烁。
功能定义：
无按键按下：两个LED全亮；
按下KEY0：交替闪烁
按下KEY1：同时闪烁
二、实现 1.原理 把电路分成三个部分：计数器、控制器、LED灯
50MHZ时钟的周期为20ns，每0.5秒改变一次LED的状态，闪烁一次（两个状态）需要1秒，0.5秒需要2500_0000个时钟周期，2500_0000需要25位二进制数表示。
通过计数器来实现，定义一个25位的计数器cnt[24:0]，每个clk上升沿计数一次。
同时定义控制信号led_ctrl，用于控制LED灯。当计数器完成一轮计数，将led_ctrl取反，完成第二轮计数时，再将led_ctrl取反，以此类推，那么led_ctrl每变化一次，灯会变更一次状态。
考虑计数器，当：
cnt &lt; 2500_0000时，有cnt = cnt + 1；
cnt ≥ 2500_0000时，有cnt = 0，led_ctrl取反，进行下一轮计数。
考虑控制信号，当：
KEY = 10（即按下LED0）时，LED应该交替闪烁，闪烁周期为led_ctrl的周期，令：
led_ctrl = 0时，led = 01；
led_ctrl = 1时，led = 10；
KEY = 01（即按下LED1）时，LED应该同时闪烁，令：
led_ctrl = 0时，led = 11；
led_ctrl = 1时，led = 00；
2.代码 /* ----------------------- 功能定义： 无按键按下：两个LED全亮； 按下KEY0：交替闪烁 按下KEY1：同时闪烁 ----------------------- 输入：时钟、复位、KEY0、KEY1 输出：LED0、LED1 ----------------------- 为便于仿真，将计数周期调整为25 ----------------------- */ module key_led( input	sys_clk, input sys_rst_n, input [1:0] key, //[key1,key0],按下为低电平 output reg	[1:0] led	//亮起为高电平 ); reg [24:0] cnt; //2500_0000需要25位表示 reg led_ctrl; /*计数器*/ always @(posedge sys_clk or negedge sys_rst_n) begin if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4636b20ea68bf3815a3a92c1d3734ff8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/199f02839879539792a9b3142fc1c7ba/" rel="bookmark">
			SQL注入绕过安全狗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常规的几种绕过方式： 1. 大小写绕过： 如果程序中设置了过滤关键字，但是程序只是对 and ，AND 或者 or，OR 设置了关键字过滤，那么你就可以使用大小写过滤
例如 :and,or
当然不局限于 and，其它的例如 union 一些关键字如果只是设置了关键字过滤，没有进行深度过滤的话，都是可以使用大小写过滤的
2. 双写绕过：在程序中对某一个关键字例如 union 设置了过滤清空，那么此时你就可以用
UniunionOn 这么一来，就可以实现绕过
当然你是可以结合大小写绕过进行编写的
select id=1 Uniutionon from 3. 编码绕过：通过 url 编码将语句或关键字进行编码 4. 内联注释绕过： 在 mysql 中，内联注释里的 Sql 语句是会被执行的，语法如下：等价于 select * from users
/*!SELECT*/ * FROM users 如果在 /*!SELECT*/ 中里面不加 ! ，则 /*SELECT*/ 会以注释的形式存在，这时 select 将不会被当成语句执行，会出现语法错误
/*Select*/ From Users 报错如下所示：
使用该内连接进行绕过的时候，也是可以结合之前的大小写以及双写进行绕过的，结合实际情况进行选择
安全狗的详细绕过： 这里我们以安全狗作为案例，如果你按照常规方法输入 and，那么它会对这个进行一个过滤，从而出现如下界面
1. 安全狗 and 的绕过（防止 and 和 or 的注入）： 将 and 修改为 /*!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/199f02839879539792a9b3142fc1c7ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b97ccb3528e7d8145c7a9b2cb95d49d/" rel="bookmark">
			linux中如何在命令行操作文本内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文本内容在命令行的操作 文本过滤：grep 文本三剑客： gerp sed awk
grep 选项 关键的字符串 文件
grep root /etc/passwd 查找root(交集查找）
^ 以……为开头
$ 以……为结尾
Grep ^root /etc/passwd 找 以root为开头
Grep nologin$ /etc/passwd 找以nologin为结尾
若没找到，正常输出
Grep ^$ /etc/passwd 找空行
Grep -v ^$ /etc/passwd 找非空行 -v表示取反
Grep [0-9] /test/a 匹配带数字的行
Grep [^0-9] /test/a 匹配除了 带数字的行 反选
Grep ^[^0-9] /test/a 首 非 匹配不是数字开头的行
Grep ^[^$] /test/passwd 非空行
Grep [a-z] /test/a 匹配和字母相关的
Ls | grep fire 找文本里的file
切割显示 cut Cut -d “” -f 1 /test/file 以空格切显示第一列
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b97ccb3528e7d8145c7a9b2cb95d49d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb55ab5afb1ade8f4d889f95a1d5d949/" rel="bookmark">
			语音识别与Python编程实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主简介
博主是一名大二学生，主攻人工智能研究。感谢让我们在CSDN相遇，博主致力于在这里分享关于人工智能，c++，Python，爬虫等方面知识的分享。 如果有需要的小伙伴可以关注博主，博主会继续更新的，如果有错误之处，大家可以指正。
专栏简介： 本专栏主要研究python在人工智能方面的应用，涉及算法，案例实践。包括一些常用的数据处理算法，也会介绍很多的Python第三方库。如果需要，点击这里 订阅专栏。
给大家分享一个我很喜欢的一句话：“每天多努力一点，不为别的，只为日后，能够多一些选择，选择舒心的日子，选择自己喜欢的人！”
目录
背景引入
语音识别简介
语音识别的起源与发展
语音识别的基本原理
语音识别Python SDK
Microsoft 语音识别框架SAPI
Speech
Python_Speech_Features工具库
params
SpeechRecognition库工具
背景引入 自动语音识别（Automatic Speech Recognition,ASR）是近十年来发展较快的技术之一。随着深度学习 在AI领域的广泛应用，语音识别技术开始逐步从实验室走向市场，百度公司基于深度学习研发的新一代深度语音识别系统Deep Speech 2，识别准确率可以达到97%，美国著名杂志《MIT Technology Review》将他评为“2016年十大突破技术”之一，并认为该技术在未来几年将会极大改变人们的生活。
在人工智能领域，语音识别是非常重要的一个环节，因为语音是智能系统获取外界信息的重要途径之一，较之于键盘和鼠标等输入方法，语音输入更快捷，高效。近年来，智能手机等各种高端的移动应用终端都集成了语音识别系统，使得这些智能化程度更高，使用起来也更方便。语音交互产品中具有代表性的有Apple公司的Siri,Microsoft公司的Cortana，Amazon公司的Alexa，华为公司的小E和百度公司的小度等。随着语音技术的高速发展，各大软硬件厂商纷纷布局，在推出相关硬件产品的同时，也开始关注语音芯片的研发。语音识别技术的确带给了人们方便，尤其是对于一些文化水平不高的人群具有很大的便利性。
语音识别简介 语音识别的起源与发展 语音识别是一门复杂的交叉技术学科，通常涉及声学，信号处理，模式识别，语言学，心理学，以及计算机等多个学科领域。语音识别技术的发展可追寻到20世纪50年代，贝尔实验室首次实现Audrey英文数字识别系统（可识别0——9单个数字英文识别），并且准确识别率达到90%以上。普林斯顿大学和麻省理工学院在同一时期也推出了少量词语的独立识别系统。到20世纪80年代，隐马尔可夫模型（Hidden arkov Model，HMM）。N-gram语言模型等重要技术开始被应用于语言识别领域，是的语音识别技术从孤立词识别到连续词识别。到20世纪90年代，大词汇量连续识别技术持续进步，最小分类错误（Minimum Classification Error，MCE）以及最大互信息（Maximum Mutual Information，MMI）等区分性十五模型训练方法开始被应用，使得语音识别的准确率逐步提高，尤其适用于长句子情形。与此同时，最大后验概率（Maximum Aposteriori Probablity，MAP）与最大似然线性回归（Maximum Likelihood Linear Regression，MLLR）等模型自适应方法也开始被应用于语音识别模型的训练。到了21世纪，随着深度学习的不断发展，神经网络之父杰弗里·辛顿（Geoffrey Hinton）提出深度置信网络（Deep Belief Network，DBN）。2009年，辛顿和他的学生默罕默德（Mohamed）将深度神经网络应用于语音识别，在TIMIT语音库上进行的小词汇量连续语音识别任务获得成功。TIMIT是由德州仪器（Texas Instruments，TI）。麻省理工学院和斯坦福国际研究学院（SRI International）合作构建的声学-音频连续识别语音库。
语音识别的基本原理 语音是一种非常复杂的现象，很少人能够理解它是如何被感知的。我们通常的直觉是语音是由单词构成，而单词又是由各种音素（Phoneme）构成。然而事实上并非如此，语音本身是一个动态的过程，是一种连续的音频流，是由一部分相当稳定状态与诸多动态变化的状态混合而成。在这种状态序列中，人们可以定义或多或少类似的声音或音素。通过Adobe Audition等音频编辑软件进行录音播放，可看到随时间变化的语音动态波形。
一个典型的语音对话系统一般包括如下几个技术模块：对话管理器（Dialog Manager），语音识别器（Speech Recognizer），语言解析器（Language Parser），语言生成器（Language Generator）和语音合成器（Speech Synthesizer）。其中，语音识别器（又可称为语音识别模块或者语言识别系统）主要用于将用户输入的语音转化为文本，这也是我们最关注的核心技术。语音识别由以下几个部分构成。
语音识别是一个先编码后解码的过程。其中，信号处理（Signal Processing）与特征提取（Feature Extraction）是语音识别系统的开始。，这是一个编码的过程。特征提取是指从原始的语音输入经过相应处理后得到的语音特征向量（Eigenvector）。语音识别的一般方法是：首先提取一个波形，然后将其分解为语音片段并尝试识别每个语音片段中的内容。通常情况下，要做到这一点，我们需要尝试将所有可能的单词进行组合然后与音频进行匹配，最后选择最佳匹配。由于参数数量过大，需要对其进行优化，所以我们会将语音分解成帧，然后对于每帧，提取出39个代表语音特征的代表数字，这些数字即语音特征向量。
我们在提取音频信息后，通过噪声和消除和信道畸变（Channel Distortion）进行语音增强，将信号从时域转化为频域，并为后面的操作提供具有特侦的特征向量。在信号处理过程中，常用梅尔频率倒谱系数（Mel-Frequency Cepsptral Coefficient，MFCC）或感知线性预测（Perceptual Linear Prediction，PLP）作为特征向量，然后使用混合高斯模型-隐马尔可夫模型（GMM-HMM）作为声学模型，再利用最大似然（Maximum Likelihood，ML）准则，序列鉴别性训练算法，例如，最小分类错误和最小音素错误（Minimum Phone Error，MPE）等模型进行训练。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb55ab5afb1ade8f4d889f95a1d5d949/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9f678fa081510a9d67b5034cd33f70e/" rel="bookmark">
			【数据库】MongoDB数据库详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，数据库管理系统
1， 什么是数据库
2，什么是数据库管理系统
二， NoSQL 是什么
1，NoSQL 简介
2，NoSQL数据库
3，NoSQL 与 RDBMS 对比
三，MongoDB简介
1， MongoDB 是什么
2，mongodb发展史
3， MongoDB的体系结构​​​​​​​
4，MongoDB的数据模型
5，适用场景
四，MongoDB的部署与连接
1，安装
（1）配置软件仓库
（2）安装mongodb
（3）查看安装的有关mongo的所有包
2，启动
（1）启动mongo服务
（2）设置开机自启
（3）查看进程
（4）查看端口号
（5）关闭mongodb服务
（6）设置mongo shell的提示符
3， 使用mongo shell连接
方法一：
方法二：
方法三：
4，查看mongo的配置文件
5， 使用MongoDB Compass连接
五，基本操作
1， 数据库操作
2，集合操作
3， 文档基本CRUD
1、插入文档
2、文档的基本查询
3、文档的更新
4、删除文档
一，数据库管理系统 1， 什么是数据库 数据： 描述事物的符号记录， 可以是数字、 文字、图形、图像、声音、语言等，数据有多种形式，它们都可以经过数字化后存入计算机。
数据库： 存储数据的仓库，是长期存放在计算机内、有组织、可共享的大量数据的集合。数据库中的数据按照一定数据模型组织、描述和存储，具有较小的冗余度，较高的独立性和易扩展性，并为各种用户共享。
2，什么是数据库管理系统 数据库系统成熟的标志就是数据库管理系统的出现。数据库管理系统(DataBase ManagermentSystem，简称DBMS)是管理数据库的一个软件，是对数据库的一种完整和统一的管理和控制机制。数据库管理系统不仅让我们能够实现对数据的快速检索和维护，还为数据的安全性、完整性、并发控制和数据恢复提供了保证。数据库管理系统的核心是一个用来存储大量数据的数据库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9f678fa081510a9d67b5034cd33f70e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7dc08722dd5bfd74172e0711276f02c/" rel="bookmark">
			《英雄编程体验课》第 01 课 | 基本输入输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 零、写在前面一、【例题1】1、题目描述2、解题思路3、代码详解 二、【例题2】1、题目描述2、解题思路3、代码详解 三、【例题3】1、题目描述2、解题思路3、代码详解 四、【例题4】1、题目描述2、解题思路3、代码详解 五、【例题5】1、题目描述2、解题思路3、代码详解 六、推荐专栏七、习题练习 零、写在前面 该章节节选自 《C语言入门100例》，为入门编程的最基础内容，如果连这一课都看不懂，可以基本认为自己不适合编程，尽早放弃，或许你的放弃，可以成就更多的人。当然，我相信，我命由我不由天，没有什么是学不会的，如果有，一定是你不够努力！
当然，如果已经对本套体验课了如指掌，那么可以通过 算法全套课程 联系到我，领取限时全套课程优惠。
博主所有的课程都是基于 c/c++ 的，java 我不会，但是我一直强调，学习算法和语言无关，算法只是一个思想，只要学好一门语言，就可以学习算法，虽然这是你的第一道C语言题，但是你可能会遇到这么多知识点 ，千万不要被劝退哦~~
一、【例题1】 1、题目描述 【例题1】输入两个正整数 a a a 和 b b b，输出 a + b a + b a+b 的值。 其中 a , b ≤ 10000 a, b \le 10000 a,b≤10000。
2、解题思路 难度：🔴⚪⚪⚪⚪
运用到了最简单的标准输入和标准输出。 3、代码详解 #include &lt;stdio.h&gt; // (1) int main() { // (2) int a, b; // (3) scanf("%d %d", &amp;a, &amp;b); // (4) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7dc08722dd5bfd74172e0711276f02c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af8c6bc118dcafaa18caeed4ba522562/" rel="bookmark">
			Python内置函数divmod()用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python内置函数divmod以元组的形式返回两个数字a，b 做除法的商和余数，当a和b均为整数时返回值等价于(a//b, a%b)
python divmod() 函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。
函数语法： divmod(a, b) 参数说明：
a: 数字b: 数字 示例代码：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc2c265e9f65ca78c9b605209e10dc13/" rel="bookmark">
			分析 HTTP，TCP 的长连接和短连接以及 socket
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、HTTP 协议与 TCP/IP 协议的关系 HTTP 的长连接和短连接本质上是 TCP 长连接和短连接。HTTP 属于应用层协议，在传输层使用 TCP 协议，在网络层使用 IP 协议。IP 协议主要解决网络路由和寻址问题，TCP 协议主要解决如何在 IP 层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP 有可靠，面向连接的特点。
2、如何理解HTTP协议是无状态的 HTTP 协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP 是一个无状态的面向连接的协议，无状态不代表 HTTP 不能保持 TCP 连接，更不能代表 HTTP 使用的是 UDP 协议（无连接）。
3、什么是长连接、短连接？ 短连接
连接-&gt;传输数据-&gt;关闭连接
HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。
也可以这样说：短连接是指Socket连接后发送后接收完数据后马上断开连接。
长连接
连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; 。。。-&gt;关闭连接。
长连接指建立Socket连接后不管是否使用都保持连接。
在 HTTP/1.0 中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次 HTTP 操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源，如JavaScript 文件、图像文件、CSS 文件等；当浏览器每遇到这样一个 Web 资源，就会建立一个 HTTP 会话。
但从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头有加入这行代码：
Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache ）中设定这个时间。实现长连接要客户端和服务端都支持长连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc2c265e9f65ca78c9b605209e10dc13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99937de2be653a70620391f700a55616/" rel="bookmark">
			结构体（算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6.1 结构体概念 结构体(struct)：是由一系列具有相同类型或不同类型的数据构成的数据集合。“结构”是一种构造类型，它是由若干“成员”组成的。每一个成员可以是一个基本数据类型或者又是一个构造类型。结构即是一种“构造”而成的数据类型， 那么在说明和使用之前必须先定义它，也就是构造它。 6.2 C++语言中的结构体 6.2.1 结构体的声明和定义
声明一个结构体类型的一般形式为：
struct 结构体名{ 成员列表; }； eg:
struct Stu{//Stu是声明的一个结构体类型名 int score;//整型成员变量 int math;//整型成员变量 char name[10];//字符型成员变量 }； struct为结构体关键字，上面只是声明了一个结构构造类型Stu
和int,float类似，Stu是一个类型名，可以定义结构体变量
类型声明只是告诉系统此类型的构造形式，并不会实际分配内存
注意：结构体的声明和定义必须以分号结束。
定义结构后，便可以创建这种类型的变量了：
Stu a;//定义一个结构体变量a Stu hat;//定义一个结构体变量hat (2) 示例代码
此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c，但没有标明其标签，声明了结构体变量s1
struct { int a; char b; double c; } s1;//s1是结构体变量 此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c，结构体的类型名被命名为Stu，另外定义了变量t1, t2[20], *t3
struct Stu{ int a; char b; double c; }; Stu t1, t2[20], *t3; 可以用typedef创建新类型，此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c，结构体的标签被命名为Simple2，用Simple2作为类型声明新的结构体变量u1, u2[20], *u3
typedef struct Simple{//Simple是结构体类型名 int a; char b; double c; } Simple2;//注意：Simple2也是结构体类型名，相当于Simple的别名 Simple2 u1, u2[20], *u3;//若去掉typedef则编译报错，error C2371: “Simple2”: 重定义；不同的基类型 同类型的结构体可以直接赋值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99937de2be653a70620391f700a55616/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21edd3418df1b7390a4b2d44870e8a4a/" rel="bookmark">
			Web安全攻防世界04 unseping（江苏工匠杯）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 依旧是参考大佬们的WP，时隔多日对原来的博文内容进行了修改与补充，内容小白友好~
原因分析： 按照惯例，把源码贴在这里逐行不靠谱地分析一下~
&lt;?php highlight_file(__FILE__); //高亮显示文件 class ease{ //创建 名称为 “ease” 的类 private $method; //创建一个私有成员变量 method (私有成员变量只能在类内访问) private $args; //创建一个私有成员变量 arg function __construct($method, $args) { //初始化对象 method、args $this-&gt;method = $method; $this-&gt;args = $args; } function __destruct(){ //在脚本关闭时执行以下语句 if (in_array($this-&gt;method, array("ping"))) { //如果 数组ping中存在method的值 call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); //返回回调函数的结果 } } function ping($ip){ //数组ping(变量ip) exec($ip, $result); //执行外部程序：查看ip var_dump($result); //输出ip查询结果 } function waf($str){ //防火墙（变量str） if (!preg_match_all("/(\||&amp;|;| |\/|cat|flag|tac|php|ls)/", $str, $pat_array)) { return $str; //如果str中不含有上述字符，返回函数 } else { echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21edd3418df1b7390a4b2d44870e8a4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3232ca598978fc6856fe92d4d387d8d/" rel="bookmark">
			代码编写环境和编译器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码编写环境是包括：编译器+可视化编写窗口
编译器的概念：编译器是把高级语言翻译成机器语言的软件,C语言最常见的编译器是gcc，不同编译器对于细节的处理不同。
比如VS中使用的编译器是VS_gcc，这种编译器和普通的gcc编译器有显著的区别。
例如：for()循环中,vs_gcc必须在for括号外定义，而不能在括号内定义。但gcc编译器却可以。
有些编写C语言的软件是没有自带编译器的，例如notepad ++
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9da595b8c1186ff97eae964c30d7ae2/" rel="bookmark">
			【vs2019】调试介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 调试是什么2. 调试的基本步骤3. 调试的环境4. VS2019调试快捷键5. vs2019调试窗口6. 写代码的注意事项6.1 Coding技巧6.2 assert6.3 const 7. 实现strcpy,strlen函数8. 编程常见的错误8.1 编译型错误8.2 链接型错误8.3 运行时错误 1. 调试是什么 调试(debug)是发现和减少计算机程序和电子仪器设备中得程序性错误
2. 调试的基本步骤 发现程序错误的存在 以隔离、消除等方式对错误进行定位 确定错误产生的原因 提出纠正错误的解决办法 对程序错误予以改正，重新测试 3. 调试的环境 并不是在任何环境下都可以进行调试
源程序通常有两种版本
Debug版本Release版本 Debug版本称为调试版本，包含调试信息，并且不做任何优化，便于程序员调试程序
Release版本称为发布版本，它往往进行了各种优化，使得程序在代码大小上和运行速度上都是最优的，便于用户使用
只有在Debug版本下，程序才可以进行调试
代码在Debug环境下的结果展示
代码在Release环境下的结果展示
在这里插入图片描述
代码在Debug环境下的反汇编
代码在Release环境下的反汇编
可以看到Release环境下确实会对代码进行优化
那么Release版本和Debug版本究竟进行了哪些优化？
优化编译选项：Release版本的编译选项通常会启用更多的优化选项，例如去除符号表、优化调试信息、优化代码大小等，这些都有助于减小程序体积、提高程序的运行效率。剔除调试代码：Debug版本通常会包含一些额外的调试代码，例如assert、日志输出等，这些代码对程序的运行效率可能会产生一定的影响。在Release版本中，这些调试代码通常会被剔除，从而提高程序的运行效率。优化代码结构：在Debug版本中，编译器会生成一些额外的代码，例如调试信息、符号表等，这些代码可能会导致代码结构比较松散。在Release版本中，编译器会进行优化，将代码结构优化得更加紧凑，从而提高程序的运行效率。禁用断言：Debug版本通常会包含一些断言代码，这些代码会在程序运行时进行检查，如果检查失败会导致程序崩溃。在Release版本中，这些断言代码通常会被禁用，从而减小程序体积、提高程序的运行效率。 来看下面这个代码在Release版本和Debug版本下有什么不同?
#include &lt;stdio.h&gt; int main() { int i = 0; int arr[10] = {0}; for(i=0; i&lt;=12; i++) { arr[i] = 0; printf("hehe\n"); } return 0; } Debug版本下是死循环
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9da595b8c1186ff97eae964c30d7ae2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0373d0cac90e1d48ba6356ef817ba254/" rel="bookmark">
			C#的多线程、线程池和Task
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程 被定义为程序的执行路径。每个线程都定义了一个独特的控制流。如果您的应用程序涉及到复杂的和耗时的操作，那么设置不同的线程执行路径往往是有益的，每个线程执行特定的工作。
线程是轻量级进程。一个使用线程的常见实例是现代操作系统中并行编程的实现。使用线程节省了 CPU 周期的浪费，同时提高了应用程序的效率。
一、多线程 1、创建和暂停线程 当程序运行时，会新建一个线程, 该线程会执行PrintNumbersWithDelay方法中的代码。然后会立即执行PrintNumbers方法。关键之处在于在PrintNumbersWithDelay方法中加入了Thread.Sleep方法调用，这将导致线程执行该代码时，在打印任何数字之前会等待指定的时间(本例中是2秒钟)。然而，PrintNumbers方法的执行是不受新线程的影响的。
class Program { static void Main(string[] args) { Thread t = new Thread(PrintNumbersWithDelay); t.Start(); PrintNumbers(); Console.ReadKey(); } static void PrintNumbers() { Console.WriteLine("Starting..."); for (int i = 1; i &lt; 5; i++) { Console.WriteLine(i); } } static void PrintNumbersWithDelay() { Console.WriteLine("Starting..."); for (int i = 1; i &lt; 5; i++) { Thread.Sleep(TimeSpan.FromSeconds(2));//暂停2S Console.WriteLine(i); } } } 执行结果如下：
2、线程等待 当程序运行时,启动了一个耗时较长的线程来打印数字,打印每个数字前要等待两秒。但我们在主程序中调用了t.Join方法,该方法允许我们等待直到线程t完成。当线程t完成 "时,主程序会继续运行。借助该技术可以实现在两个线程间同步执行步骤。第一个线程会等待另一个线程完成后再继续执行。第一个线程等待时是处于阻塞状态(正如暂停线程中调用 Thread.Sleep方法一样)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0373d0cac90e1d48ba6356ef817ba254/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b597977e0ce3fda178f3bf8fa2a5cafc/" rel="bookmark">
			学习资料|常用的一些CMD运行命令，整理的比较齐全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CMD命令
CMD命令：开始－&gt;运行－&gt;键入cmd或command（在命令行里可以看到系统版本、文件系统版本）
appwiz.cpl：程序和功能
calc：启动计算器
certmgr.msc：证书管理实用程序
charmap：启动字符映射表
chkdsk.exe：Chkdsk磁盘检查（管理员身份运行命令提示符）
cleanmgr: 打开磁盘清理工具
cliconfg：SQL SERVER 客户端网络实用工具
cmstp：连接管理器配置文件安装程序
cmd.exe：CMD命令提示符
自动关机命令
Shutdown -s -t 600：表示600秒后自动关机
shutdown -a ：可取消定时关机
Shutdown -r -t 600：表示600秒后自动重启
rundll32 user32.dll,LockWorkStation：表示锁定计算机
colorcpl：颜色管理，配置显示器和打印机等中的色彩
CompMgmtLauncher：计算机管理
compmgmt.msc：计算机管理
credwiz：备份或还原储存的用户名和密码
comexp.msc：打开系统组件服务
control：控制面版
dcomcnfg：打开系统组件服务
Dccw：显示颜色校准
devmgmt.msc：设备管理器
desk.cpl：屏幕分辨率
dfrgui：优化驱动器 Windows 7→dfrg.msc：磁盘碎片整理程序
dialer：电话拨号程序
diskmgmt.msc：磁盘管理
dvdplay：DVD播放器
dxdiag：检查DirectX信息
eudcedit：造字程序
eventvwr：事件查看器
explorer：打开资源管理器
Firewall.cpl：Windows防火墙
FXSCOVER：传真封面编辑器
fsmgmt.msc：共享文件夹管理器
gpedit.msc：组策略
hdwwiz.cpl：设备管理器
inetcpl.cpl：Internet属性
intl.cpl：区域
iexpress：木马捆绑工具，系统自带
joy.cpl：游戏控制器
logoff：注销命令
lusrmgr.msc：本地用户和组
lpksetup：语言包安装/删除向导，安装向导会提示下载语言包
lusrmgr.msc：本机用户和组
main.cpl：鼠标属性
mmsys.cpl：声音
magnify：放大镜实用程序
mem.exe：显示内存使用情况（如果直接运行无效，可以先管理员身份运行命令提示符，在命令提示符里输入mem.exe&gt;d:a.txt 即可打开d盘查看a.txt，里面的就是内存使用情况了。当然什么盘什么文件名可自己决定。）
MdSched:Windows内存诊断程序
mmc：打开控制台
mobsync：同步命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b597977e0ce3fda178f3bf8fa2a5cafc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fd8e43e7e8a22411ca004c17d69342a/" rel="bookmark">
			通俗易懂，十分钟读懂DES，详解DES加密算法原理，DES攻击手段以及3DES原理。Python DES实现源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、什么是DES2、DES的基本概念3、DES的加密流程4、DES算法步骤详解4.1 初始置换(Initial Permutation，IP置换)4.2 加密轮次4.3 F轮函数4.3.1 拓展R到48位4.3.2 子密钥K的生成4.3.3 当前轮次的子密钥与拓展的48位R进行异或运算4.3.4 S盒替换（Substitution Box substitution）4.3.5 P盒替换 4.4 逆置换（Inverse Permutation） 5、DES的优缺点6、DES的攻击方法7、3DES(Triple DES)8、Python实现DES 1、什么是DES DES（Data Encryption Standard）是一种对称加密算法。它是在20世纪70年代初期由IBM研发的。它的设计目标是提供高度的数据安全性和性能，并且能够在各种硬件和软件平台上实现。
2、DES的基本概念 DES使用56位的密钥和64位的明文块进行加密。DES算法的分组大小是64位，因此，如果需要加密的明文长度不足64位，需要进行填充；如果明文长度超过64位，则需要使用分组模式进行分组加密。
虽然DES算法的分组大小是64位，但是由于DES算法的密钥长度只有56位，因此DES算法存在着弱点，容易受到暴力破解和差分攻击等攻击手段的威胁。因此，在实际应用中，DES算法已经不再被广泛使用，而被更加安全的算法所取代，如AES算法等。
尽管DES已经被取代，但它在密码学的历史上仍然具有重要意义。通过DES可以帮助我们了解对称密钥加密算法的基本概念和运作原理。
3、DES的加密流程 当输入了一条64位的数据之后，DES将通过以下步骤进行加密。在第4部分中，我们对每个流程进行详解。
1、初始置换（IP置换）：将输入的64位明文块进行置换和重新排列，生成新的64位数据块。
2、加密轮次：DES加密算法共有16个轮次，每个轮次都包括四个步骤：
a. 将64位数据块分为左右两个32位块。
b. 右侧32位块作为输入，经过扩展、异或、置换等操作生成一个48位的数据块。这个48位的数据块被称为“轮密钥”，它是根据加密算法的主密钥生成的子密钥。
c. 将左侧32位块和轮密钥进行异或运算，结果作为新的右侧32位块。
d. 将右侧32位块与原来的左侧32位块进行连接，生成一个新的64位数据块，作为下一轮的输入。
3 末置换（FP置换）：在最后一个轮次完成后，将经过加密的数据块进行置换和重新排列，得到加密后的64位密文。
总的来说，DES加密的过程就是通过一系列置换、异或、扩展等运算，将明文分成若干个小块，然后根据主密钥生成一系列的轮密钥，利用轮密钥对每个小块进行加密，最终将加密结果重新组合成一个整体，得到密文。
4、DES算法步骤详解 4.1 初始置换(Initial Permutation，IP置换) IP置换是将输入的64位明文块进行置换和重新排列，生成新的64位数据块。
目的:增加加密的混乱程度，使明文中的每一位都能够对后面的加密过程产生影响，提高加密强度。
我们将把64位的顺序按下表中规定的顺序放置，图中的数字是在64位明文中每个比特的索引位置。注意，在DES中，这个置放规则是固定的。
即将原来位于第58个位置的数据放在第1个位置，原来位于第50个位置的元素放在第2个位置，第42个放在第3个，34-&gt;4以此类推…
初始置换的逆置换（Final Permutation，FP置换）是将加密后的数据块进行置换和重新排列，得到最终的加密结果，与初始置换相对应。
4.2 加密轮次 初始置换完成后，明文被划分成了相同长度（32位）的左右两部分，记作L0,R0。接下来就会进行16个轮次的加密了。
我们从单独一个轮次来看。首先把目光聚焦在R0这里。
右半部分R0会作为下一轮次的左半部分L1的输入。其次，R0会补位到48位和本轮次生成的48位K0(马上讲K0的生成)输入到F轮函数中去。F函数的输出结果为32位，结果F(R0,K0)会和L0进行异或运算作为下一轮次右半部分R1的输入。
以此类推，重复16轮运算。所以，上面描述的过程可以用以下公式表述。
4.3 F轮函数 我们讲到在每轮加密中，会将R和K输入到F中，接下来我们看看F函数中做了哪些处理。
4.3.1 拓展R到48位 将32位的R0右半部分进行扩展，得到一个48位的数据块。同样的，数据拓展也是根据一个固定的置换表。红框中就是我们要补位的数据。
由此可见，扩展过程的每一位都是根据上述的置换表从输入的32位数据块中提取出来的。原始数据的第32位被补充到了新增列的第一个，第5位被补充到了第二个新增列的第一个，以此类推…
4.3.2 子密钥K的生成 DES算法采用了每轮子密钥生成的方式来增加密钥的复杂性和安全性。每轮子密钥都是由主密钥（64位）通过密钥调度算法（Key Schedule Algorithm）生成的。DES算法的密钥调度算法可以将64位的主密钥分成16个子密钥，每个子密钥48位，用于每轮加密中与输入数据进行异或运算。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fd8e43e7e8a22411ca004c17d69342a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31ff1c55a9dabdbf072112a93833d7af/" rel="bookmark">
			Centos7开机不久桌面卡住，只有鼠标可以移动的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统：CentOS7.0
问题：刚安装好不到一天的CentOS7.0新系统，开机没多久桌面所有画面就卡住，只有鼠标可以移动。
解决问题的过程：
CentOS系统死机重启后显示CPU over temperatuer error
因此考虑是否为开机后某进程占用系统资源过多导致系统死机。
1. 开机后在终端输入top命令查看各个进程的资源占用情况，包括哦进程ID，CPU占用率，内存占用率等
2. 随着进程占用资源的变化，发现gnome-shell进程CPU占用率达到78%左右。紧接着电脑桌面卡死。因此看出gnome-shell占用系统资源过多导致电脑死机。
可以按crtl+alt+prtsc+b安全重启。
下面的方法有风险，建议您看完整个过程之后再决定是否按此方法去做。
3. 删除gnome-shell. 通过运行yum remove gnome-shell移除gnome
紧接着电脑就黑屏了，不要慌，这是因为你把gnome桌面卸载了，出现这种情况很正常。
接着按ctrl+alt+F2进入字符界面，通过yum groupinstall "GNOME Desktop" "Graphical Administration Tools"安装GNOME包
缺少某些rpm包的话可以在一台联网的电脑上查找安装。
4.通过一下两条命令更新系统运行级别，启用图形用户界面 unlink /etc/systemd/system/default.target
ln -sf /lib.systemd/system/runlevel5.target /etc/systemd/system/default.target
最后reboot重启，图形界面就出现啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62ef6024beebe5f318e6c65a5f9f411d/" rel="bookmark">
			Vue3后台管理系统（十七）布局切换组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、场景效果
二、图标
三、组件封装
四、使用案例
一、场景效果 二、图标 将图标放到src/assets/icons文件夹中
三、组件封装 在src/components文件夹下新建SizeSelect文件夹，并在SizeSelect文件夹下新建index.vue
&lt;script setup lang="ts"&gt; import { ref } from 'vue'; import { ElMessage } from 'element-plus'; import { useAppStore } from '@/store/modules/app'; import SvgIcon from '@/components/SvgIcon/index.vue'; const appStore = useAppStore(); const sizeOptions = ref([ { label: '默认', value: 'default' }, { label: '大型', value: 'large' }, { label: '小型', value: 'small' } ]); function handleSizeChange(size: string) { appStore.changeSize(size); ElMessage.success('切换布局大小成功'); } &lt;/script&gt; &lt;template&gt; &lt;el-dropdown trigger="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62ef6024beebe5f318e6c65a5f9f411d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c22bb10706b58276e3d8500c01abe4a5/" rel="bookmark">
			gitlab应用学习笔记1：创建git~创建分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gitlab学习笔记（b站：手把手教您入门gitlab） 进入ubuntu系统查看git version git的核心思想是创建一个仓储库，进行代码更改的跟踪
||git status 查看你的git仓库发生了什么事情
||git init 初始化创建一个git仓库 其意义为，在刚刚创建的文件夹my-cool当中建立一个代码仓库，通常情况下我们是无法直接看到里面所包含的内容，因此我们需要用到
|| ls -a命令来查看这个仓库当中拥有的内容
此时我们使用git status命令就会看到我们已经创建了并且处于master分支，master分支又可以理解为main 分支
我们可以看到master分支已经被创建出来了，接下来进行git 的配置(相当于登记你的个人信息，来方便管理员查看是谁对仓库中的代码进行了更改)，利用指令：
||git config --global user.name “G ZH”
||git config --global user.email “736008123@qq.com”
接下来，学习git当中的重要指令，commit指令，字面意思可以理解为提交，我们在刚刚创建的git仓库中运行commit指令 ||git commit
可以发现系统提示“无文件要提交”
此时我们进行一个简单的试验，利用vim 编辑器编一个markdown文件，然后将其插入commit分支
||vim readme.md
进入vim对markdown文件的编辑页面，输入内容 按ESC键，并输入：
||：wq
就可以保存并退出这个文件 ，而后我们再用
||ls -a
命令查看现有git 的时候我们就会发现readme.md 文件已经被加进去了
而后我们用经典命令
||git status 便可以查看发生的动作
可以看到尚无提交以及有未跟踪文件readme.md,此时我们根据提示运行指令
||git add readme.md
然后再查看代码仓库的状态时候我们发现readme.md已经进入了等待提交的队列
接下来，我们可以用以下指令进行我们的第一次提交尝试，运行如下指令： ||git commit -m “My first commit” 效果如下：
此时可以看到文件已经提交完成。
接下里学习如何提交多个文件 创建两个不同的文件，第一个创建一个全新的html文件。第二个，基于之前已经书写的readme.md文件，进行修改，然后利用git status指令进行查看的时候我们发现git 已经跟踪了readme.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c22bb10706b58276e3d8500c01abe4a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68b56fa007286c9f83109ae167d945a0/" rel="bookmark">
			Mac安装thrift
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在mac操作系统中安装thrift不是非常顺利，历经好多个小时的时间，问题反反复复。特此记录中途遇到的问题及解决方法，有需要的朋友可以参考
问题1： error: Bison version 2.5 or higher must be installed on the system!
答：mac中默认安装的版本是2.3，我参考官网的安装步骤下载最新版0.18，至少需要2.5或以上的版本，故需要处理。
这里我参考的是: https://www.cnblogs.com/zhangyy3/p/9082908.html 作者的文章
可以通过如下方式解决,参考
https://stackoverflow.com/questions/10778905/why-not-gnu-bison-upgrade-to-2-5-on-macosx-10-7-3
brew unlink bison brew link bison --force 重新link 之后还不好使，还得加一下环境变量，这个得看使用的哪个bash,我用的是zshrc, 在.zshrc 文件中加入以下代码（就是配置环境变量），然后source 一下。版本更新成功。
export PATH="/usr/local/opt/bison/bin:$PATH" source .zshrc bison -V 问题2: 使用brew直接安装一个是版本范围受限，另一个是并没有成功安装，寻找了很多资料包括maven插件但是依赖却在中央仓库找不到，最后去官网寻找答案
官网地址： Apache Thrift - Home
但上面会遇到一个 open-ssl的问题
问题3: fatal error: 'openssl/opensslv.h' file not found
我尝试了是第二种方法。 然后按照控制台提示的信息，又重新设置了环境变量
问题4:
Your user account isn't allowed to install to the system RubyGems.
You can cancel this installation and run:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68b56fa007286c9f83109ae167d945a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75d0c00ecf59cd04edd7fdae22557ba6/" rel="bookmark">
			Pyinstaller打包程序后可能遇到的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pyinstaller打包程序后可能遇到的错误
打包后的程序执行时会提示:failed to execute script pyi_rth_win32comgenpy
其可能的原因是pyinstaller库所依赖的第三方库pywin32版本为225。
解决方案：卸载225版本的pywin32，重新安装224版本的pywin32
tips:直接运行exe文件，出现错误时会直接闪退。可以把程序拖到cmd里执行可以观察运行后的提示信息。
来源：https://zhuanlan.zhihu.com/p/92614558
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/163/">«</a>
	<span class="pagination__item pagination__item--current">164/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/165/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>