<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/310915f87009e1f77ab7164bad40899b/" rel="bookmark">
			NEON快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NEON 1.简介2.简单实例3.总结 1.简介 没有长篇大论，只用于NEON快速入门！
SIMD：
单指令处理多个数据的并行技术例如在C语言中对一个int[8]的数组里每一个数都执行加1操作，SIMD技术可以通过一条add指令并行处理；而通常我们自己写for循环需要执行8次add才能完成，耗时更多 NEON：
一种基于SIMD并适用于ARM的技术，从ARM-V7开始被采用，目前可以在ARM Cortex-A和Cortex-R系列处理器中使用寄存器，用于存放需要操作的数据；16个128bit的寄存器（128bit代表最大长度，对于int类型数据，能存放4个，对于char类型数据能存放16个，也就是说我能直接把int[4]或者char[16]直接放到128bit的寄存器中）、32个64bit寄存器支持的数据类型，上官网查询常用操作：加减乘除，数据之间的读写等 2.简单实例 实例内容：两个长度为5000的int型数组相加，把每个结果存入另一个长度为5000的数组当中，对比纯C语言实现和NEON实现的性能。
纯C实现函数：平平无奇，谁都能写
void add_int_c(int* dst, int* src1, int* src2, int count) { int i; for (i = 0; i &lt; count; i++) dst[i] = src1[i] + src2[i]; } NEON实现函数：
int32x4_t in1, in2, out：用于存放4个int型数据的变量，int32x4_t是一个数据类型声明（和int效果一致），类似的还有int16x8_t（用于存放8个short类型数据）、int8x16_t（用于存放16个char类型数据），更详细的去官网查询
in1 = vld1q_s32(src1)：将指针src1的4个数据加载到in1当中，vld1q_s32用于加载int型的数据，并且只会是4个数据，其余类型的加载函数自行查询，但都是相对应的
src1 += 4：数据加载完成后，指针向后移动4位，用于后续数据加载
out = vaddq_s32(in1, in2)：执行in1和in2两个向量相加操作，并存入out中
vst1q_s32(dst, out)：将out里的数据存入dst指针指向的内存中
完毕！
void add_int_neon(int* dst, int* src1, int* src2, int count) { int i; for (i = 0; i &lt; count; i += 4) { int32x4_t in1, in2, out; in1 = vld1q_s32(src1); src1 += 4; in2 = vld1q_s32(src2); src2 += 4; out = vaddq_s32(in1, in2); vst1q_s32(dst, out); dst += 4; } } 整体代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/310915f87009e1f77ab7164bad40899b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f23836103c2b1e11f76dfd098e60dd70/" rel="bookmark">
			sqlite 触发器的使用，以及navicat创建触发器。实现更新某个字段的时，自动更新该记录的更新时间updateAt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sql 触发器 先来看一个简单的触发器：
CREATE TRIGGER "update_user" AFTER UPDATE OF "id", "name", "account", "password", "createdAt" ON "user" BEGIN UPDATE user SET updatedAt = STRFTIME('%s', 'now')*1000 WHERE id = OLD.id; END 这个触发器的意思是：
1,CREATE TRIGGER “update_user”
触发器的名字是：update_user;
2,AFTER UPDATE OF “id”, “name”, “account”, “password”, “createdAt”
当 “id”, “name”, “account”, “password”, "createdAt"这些字段被更新后
其中触发时机有：AFTER （之后），BEFORE（之前），INSTEAD OF（替代）
触发方式：INSERT（插入）、DELETE（删除）、UPDATE OF（更新），只有跟新需要在后面填写字段名，另外两个不需要。
3,ON “user”
该触发作用与哪个表
4，BEGIN…END
中间写触发之后需要执行哪些sql语句，我这里写的是更新user表的updatedAt字段的值为当前的时间戳。
其中WHERE id = OLD.id确保只更新当前记录的updatedAt。
navicat创建触发器 1，选择触发器，右键新建，根据自己需求填写相关配置
2，写触发的sql语句，我这里的意思是，当触发时，更新users表的update字段，使之等于当前的时间戳，其中 where id = OLD.id保证只更新当前记录的updateAt。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f23836103c2b1e11f76dfd098e60dd70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20f02d8d422580afae4e872a8044408e/" rel="bookmark">
			调用系统相机、相册、剪裁图片，适配Android 12
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：FileProvider相关准备工作 在AndroidManifest.xml中增加provider节点：
&lt;provider android:name="androidx.core.content.FileProvider" android:authorities="com.choosecrop.fileprovider" android:grantUriPermissions="true" android:exported="false"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/filepaths" /&gt; &lt;/provider&gt; 其中：
android:authorities 表示授权列表，填写你的应用包名，当有多个授权时，用分号隔开。
android:exported 表示该内容提供器(FileProvider)是否能被第三方程序组件使用，必须为false,否则会报异常： java.lang.SecurityException: Provider must not be exported。
android:grantUriPermissions=“true” 表示授予 URI 临时访问权限。
接着，需要在res目录下建立一个xml目录，
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;paths&gt; &lt;external-files-path name="DCIM" path="." /&gt; &lt;/paths&gt; 说明：
files-path name=“name” path=“path” 对应 Context.getFilesDir()
cache-path name=“name” path=“path” 对应 getCacheDir()
external-path name=“name” path=“path” 对应Environment.getExternalStorageDirectory()
external-files-path name=“name” path=“path” 对应 Context.getExternalFilesDir()
external-cache-path name=“name” path=“path” 对应 Context.getExternalCacheDir()
external-media-path name=“name” path=“path” 对应 Context.getExternalMediaDirs()
注意：ExternalStorageDirectory在29后废弃，官方推荐使用Context.getExternalFilesDir()
可被使用的特定目录：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20f02d8d422580afae4e872a8044408e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c679107eb412f313728a1397e520e8ca/" rel="bookmark">
			三废的日常--Nginx实现负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第二天。。小废给大废买了杯奶茶。。
大废：这才差不多，讲了这么多早就应该给我奶茶了，吧唧吧唧。。
大废：那今天就来讲讲Nginx是如何实现负载均衡吧。
二废：这个我知道，我看过Nginx的配置，nginx通过upstream下的配置，对配置的服务器进行负载均衡，具体配置如下*。
http { listen 80; server_name localhost; upstream webservers { ip_hash; server 192.168.0.1:8080; server 192.168.0.2:8080; }...} 其中，listen是访问nginx的端口，server_name是访问路径，这里默认是 localhost，端口默认是80。server是两台应用服务器，由Nginx通过负载均衡策略来选择访问应用服务器，做到了应用负载。
大废：二废看来昨天偷偷做功课了呀。这样的架构设计看起来是可以支撑业务的快速增长，但所有的访问都会直接请求服务器，这显然是不太安全，因此一般也会在软负载均衡后面，增加一个网关。这样所有流量经过Server时都要先去网关进行鉴权，除了鉴权外，网关还可以起到协议转换、流量控制等功能。
小废：我看书上介绍Nginx还可以对静态资源进行处理，这是怎么做到的呀
大废：没错，如果应用服务器有一些静态资源，后端服务器每次都要从磁盘加载文件会比较影响性能，而Nginx的proxy cache功能能够提升对静态资源的处理能力。​​​​​​​
location /static/images/ { root /home/www/; charset utf-8;} 注：实际上静态资源在服务器上的位置为：/home/www/static/images/hello.png
这样配置后，如此访问便可以访问到对应的静态资源 http://localhost:8080/static/images/hello.png 此时Nginx作为了一台静态资源服务器。​​​​​​​
location /static/images/ { alias /home/www; charset utf-8;} 注：这样访问的服务器上的位置为：/home/www/hello.png
小废：这样是不是就做到了动静分离。那Nginx如何保证高可用呢？
大废：由于Nginx在上面整个架构中作为流量的入口，如果Nginx不能正常工作或服务器宕机，将导致整个服务不可用。因此可以通过keepalived的机制来保证Nginx双活。
大废：架构一定要根据实际业务来设计，脱离业务的设计是没有意义的，对于业务量不大的系统，用Nginx作为负载均衡是完全够用的。当然，对于大型互联网企业则需要调整一些设计，比如静态资源应该部署在CDN上， CDN 会自动选择离用户最近的节点返回给用户，同时，流量很大时可以选择DNS负载均衡解析域名，大概如下图。
总结：
轮询策略配置：
在配置文件upstream中，ip_hash是指定负载均衡器按照基于客户端IP的分配方式，这个方法确保了相同的客户端的请求一直发送到相同的服务器，可以解决session不能跨服务器的问题。同时，还有以下其他几种轮询策略，依次介绍如下。
轮询，默认策略，不需要加任何配置，是upstream模块默认的负载均衡策略，会将每个请求顺序分发到不同的后端服务器上。
权重（weight）：指定轮询的访问权重，用于后端服务器性能不均时的策略。
upstream webservers { server 192.168.0.1:8080 weight=7; server 192.168.0.2:8080 weight=3;} ip_hash（依据ip分配）：指定负载均衡器按照基于客户端IP的分配方式，这个方法确保了相同的客户端的请求一直发送到相同的服务器，可以解决session不能跨服务器的问题。
least_conn（最少连接）：将请求转发给连接数较少的服务器。
upstream webservers { least_conn; server 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c679107eb412f313728a1397e520e8ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/773c28eeb6a49bca97b0ee26ff164fb4/" rel="bookmark">
			实例分割计算指标TP,FP,FN,F1（附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
源代码：
返回值
我使用的groundTruth图像：
预测图像
基于IOU的F1是评价模型实例分割能力的一种评价指标，该指标在2018年的Urban 3D Challenge和2020年的阿里天池建筑智能普查竞赛中作为评价标准。
计算公式如下：
其余计算指标：
1、IoU: 交并比，两个区域重叠的部分除以两个区域的集合部分， IOU算出的值score ＞ 0.5 就可以被认为一个不错的结果了
2、mIoU（mean IoU）：均交并比，识别或者分割图像一般都有好几个类别，把每个分类得出的分数进行平均一下就可以得到mean IoU，也就是mIoU。
3、Precision：精确率，混淆矩阵计算得出，P = TP/（TP+FP）
4、Recall：召回率，R = TP/（TP+FN）
5、Accuracy：准确率，accuracy = （TP+TN）/（TP+TN+FP+FN）
即PA（Pixel Accuracy，像素精度？标记正确的像素占总像素的比例）：表示检测物体的准确度，重点判断标准为是否检测到了物体
IoU只是用于评价一幅图的标准，如果我们要评价一套算法，并不能只从一张图片的标准中得出结论。一般对于一个数据集、或者一个模型来说。评价的标准通常来说遍历所有图像中各种类型、各种大小(size)还有标准中设定阈值.论文中得出的结论数据，就是从这些规则中得出的。
源代码： from skimage import measure from scipy import ndimage import cv2 as cv import numpy as np def get_buildings(mask, pixel_threshold): gt_labeled_array, gt_num = ndimage.label(mask) unique, counts = np.unique(gt_labeled_array, return_counts=True) for (k, v) in dict(zip(unique, counts)).items(): if v &lt; pixel_threshold: mask[gt_labeled_array == k] = 0 return measure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/773c28eeb6a49bca97b0ee26ff164fb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c87373a102f2092cf77733ba4a786d2/" rel="bookmark">
			mysql基于Java的学生请销假审批管理系统的设计与实现毕业设计源码130939
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
科技进步的飞速发展引起人们日常生活的巨大变化，电子信息技术的飞速发展使得电子信息技术的各个领域的应用水平得到普及和应用。信息时代的到来已成为不可阻挡的时尚潮流，人类发展的历史正进入一个新时代。在现实运用中，应用软件的工作规则和开发步骤，采用java技术建设学生请假审批管理系统。
本设计主要实现集人性化、高效率、便捷等优点于一身的学生请假审批管理系统，完成首页、用户管理、公告通知、请假申请、请假审批等功能模块。系统通过浏览器与服务器进行通信，实现数据的交互与变更。本系统通过科学的管理方式、便捷的服务提高了工作效率，减少了数据存储上的错误和遗漏。学生请假审批管理系统使用Java语言，采用基于 MVVM模式的spring boot技术进行开发，使用 Eclipse 2017 CI 10 编译器编写，数据方面主要采用的是微软的Mysql数据库来作为数据存储媒介，配合前台HTML+CSS 技术完成系统的开发。
关键词 ：学生请假审批；java技术；Mysql数据库；
Abstract
The rapid development of scientific and technological progress has caused great changes in people's daily life. The rapid development of electronic information technology has popularized and applied the application level of electronic information technology in various fields. The advent of the information age has become an irresistible fashion trend, and the history of human development is entering a new era.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c87373a102f2092cf77733ba4a786d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcbaf19277ff31f629074ac25ad2c6c0/" rel="bookmark">
			JavaScript中reduce方法的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义 1.reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。
2.reduce() 可以作为一个高阶函数，用于函数的 compose
3.reduce() 对于空数组是不会执行回调函数的
语法 array.reduce(function(prev, currentValue, currentIndex, arr), initialValue) reduce函数接收两个参数，一个为回调函数，一个为初始赋值
第一个参数的回调函数又接收四个参数，分别为（初始值或计算结束后的返回值，当前元素，当前元素的索引，当前元素所属的数组对象）
第二个参数是传给函数的初始值，非必传
prev：函数传进来的初始值或上一次回调的返回值
currentValue：数组中当前处理的元素值
currentIndex：当前元素索引
arr：当前元素所属的数组本身
initialValue：传给函数的初始值
浏览器支持 支持谷歌、火狐、ie9以上等主流浏览器
示例1 var arr = [1, 2, 3, 4]; var sum = arr.reduce(function (prev, cur, index, arr) { console.log(prev, cur, index); return prev + cur; }); console.log(arr, sum); 此时没有给prev赋予初值
上面的例子index是从1开始的，第一次的prev的值是数组的第一个值，第一次的cur的值是数组的第二个值，数组长度是4，reduce函数循环3次。
打印结果 1 2 1 3 3 2 6 4 3 [ 1, 2, 3, 4 ] 10 示例2 接下来给initvalue赋予初始值0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcbaf19277ff31f629074ac25ad2c6c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2837303e2de84dbafbecdfee41b63ed1/" rel="bookmark">
			CISSP第三章：安全架构和工程知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安全架构
在系统工程生命周期中使用安全设计原则 系统工程用于把用户需求转换为系统定义的跨学科的方法,通过一个迭代流程架构和设计一个有效的操作系统。 系统工程技术 需求定义 需求分析 架构设计 实施 集成 验证 确认 转移系统工程管理 决策分析 技术规划 技术评估 需求管理 风险管理 配置管理 接口管理 技术数据管理V模型 常用测试阶段使用(非SDL)安全原则 NIST SP 800-14 NIST SP 800 -14 被广泛接受的信息技术系统安全原则与实践 8个安全原则 14个安全实践NIST SP 800-27 6个类别33个信息技术安全原则安全开发生命周期框架 Cisco Secure Development Lifecycle Microsoft’s Trustworthy Computing Secure Development Lifecycle Center’s for Medicare and Medicaid Services Technical Reference Architecure Standards Building Security in Maturity Model-V （BSIMM-V）ISO/IEC 21827:2008 系统安全工程模型-能力成熟度模型（SSE_CMM） 架构 企业安全架构描述用于指导安全相关技术决策和方案的安全战略 对IT架构师和管理层提供指导，使他们更好的做出安全相关投资和设计决策 建立未来要达到的技术架构 支持、驱动、扩展安全政策和标准 整合行业标准和模型确保最佳安全实践被应用 架构框架和实际架构是有区别的。每个组织的架构都不同原因在于它们有不同的业务驱动、安全和规定需求、文化和组织结构。 通用企业架构框架 ZACHMAN 最早的框架TOGAF （The Open Group公司开发） 开发和维护架构的模型ITIL安全架构开发方法 获取和分析安全需求 1、根据安全架构开发方法，安全架构师首先从股东、业务部门收集业务需求，这将决定安全架构开发的成功与否。 2、功能性需求 3、非功能性需求 4、原则、指南、需求都应被高级管理者批准创建和设计安全架构SABSA （安全需求分析工具） SABSA是一个方法论，它通过开发以风险作为驱动的企业信息安全系统和企业信息保证结构来派生以支持关键商务的安全架构解决方案。系统安全架构企业架构和系统架构虽然有重叠之处，但它们还是有区别的。企业架构解决的是组织的结构，系统架构解决的是软件和计算机组件的结构。 通用系统组件 CPUCPU主要负责执行系统指令和控制内存、存储、输入输出设备的交互。 CPU的四个主要任务：提取、解码、执行、存储。 CPU的一些安全特点： 温度探测 加密加速 备份电池 安全启动能力 安全内存访问控制器 静电电源和差示分析措施 智能卡通用异步收发传输器控制 进程 一个独立运行的程序，有自己的地址空间, 是程序运行的动态过程 只能有限地与其它进程通信，由OS负责处理进程间的通信线程 进程中的一小段相对独立的代码，可重用、可并发执行虚拟机 进程的虚拟执行环境多程序设计 1、一个处理器允许多处程序的将交叉运行, 即两个或两个以上程序在计算机系统中同处于开始个结束之间的状态：多道、宏观上并行、微观上串行 2、解决主机和外转设备速度不匹配问题，为提高CPU的利用率。通过进程管理，协调多道程序之间的CPU分配调度、冲突处理及资源回收等关系。多任务 单个处理器对两个或两个以上的任务并行执行、交叉执行 实时多任务(Real time)、抢占式多任务(Preemptive)、协作式多任务(Cooperative) Windows 2000, IBM OS/390, Linux….
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2837303e2de84dbafbecdfee41b63ed1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72134de31b067a387f70473fb6f11e4b/" rel="bookmark">
			CISSP第一章：安全与风险管理知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Xmind制作知识体系图，此处导出png图片格式方便查阅（可保存到本地查看高清原图）。
1、安全与风险管理基础 基础知识 CIA 机密性 确保信息在存储、使用、传输过程中不会泄露给非授权的用户或实体完整性 防止非授权的篡改 防止授权用户不恰当的修改信息 保持信息内部一致性和外部的一致性可用性 确保授权用户或实体对信息及资源的正常使用不会被异常拒绝，允许其可靠而及时的访问信息DAD 泄露、篡改、破坏 CIA的相关技术 机密性 数据加密（磁盘加密、数据库加密）传输机密（IPsec、SSL、TLS、SSH）访问控制（物理和技术控制）完整性 哈希（数据完整性）配置管理（系统完整性）变更管理（过程完整）访问控制（技术和物理控制）软件数字签名 代码签名（主要作用是保护代码的完整性，不是抗抵赖）传输CRC检验功能（用于网络传输的多个层）可用性 冗余磁盘阵列（RAID）集群负载均衡冗余的数据和电源线路软件和数据备份磁盘映像位置和场外措施回滚功能故障转移配置 分层建设 纵深防御 多种控制手段结合，一个控制失效不会导致系统或数据暴漏 风险管理 三种安全控制机制以纵深防御方式实现。 风险管理是信息安全核心理念的核心内容
控制类型3类 管理性控制 组织的安全策略和法律发规制定的策略和程序 举例：策略、程序、招聘实践、背景调查、数据分类、数据标签、安全意识培训、休假记录、报告和审查、工作监督、人员控制和测试。技术性控制/逻辑控制 硬件和软件控制 举例：身份验证方法、加密、限制接口、访问控制列表、协议、防火墙、路由器、IDS和阈值物理性控制 可实际接触到的措施 举例：保安、栅栏、动作探测器、上锁的门、密封的窗户、灯、电缆保护、笔记本电脑锁、徽章、刷卡、看门狗、摄像机、陷阱、报警器安全控制功能种类6种 威慑控制预防控制检测控制补偿控制纠正控制 备份、BCP、DRP恢复控制 GRC-治理、风险与合规 信息安全管理-PDCA模型 计划Plan、实施Do、检查Check、措施Action 1、根据风险评估结果，法律法规要求、组织业务， 运作自身需要来确定控制目标与控制措施 2、实施所选的安全控制措施。提升人员安全意识 3、依据策略、程序、标准和法律法规，对安全措施的实施情况进行符合性检查 4、针对见擦汗结果采取应对措施，改进安全状况 机构信息分类 商业公司-公开、敏感、私有、机密（由低到高）军事机构-敏感但非机密、秘密、机密、绝密（由低到高） 2、安全控制框架 安全控制开发 Cobit IT内部控制 信息系统审计和控制协会编制（ISACA），分治理域和管理域NST 800-53 安全控制参考 企业方案开发 ISO/IEC 27001 信息安全管理体系 源于BS7799 BS7799-1对应ISO27002 BS7799-2对应ISO27001ISO/IEC 27002 信息安全管理体系最佳实践-目标框架 ISO/IEC 27003 信息安全管理体系实施指南 ISO/IEC 27005 信息安全风险管理 企业架构开发 Zachman，TOGAF企业框架 安全企业架构开发 SABSA安全机构框架 公司治理 COSO 企业内控管理框架 内部控制-整体框架 五类内控要素： 环境控制、风险评估、控制活动、信息与沟通、检测很多组织应对SOX404法案合规性的框架 流程管理 CMMI 软件开发管理ITIL IT服务管理 四大过程：服务战略、服务设计、服务交付、服务运营、持续服务改进Six Sigma 业务流程管理 Due Care （DC，应尽的关心、谨慎考虑、应尽关注、尽职关注、适度关注、适度审慎） Due Diligence （DD，尽职审查、恪尽职守、尽职调查、尽职勤勉、应尽勤勉、适度勤勉）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72134de31b067a387f70473fb6f11e4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/955b8c5a56f22d23b9ebf766927a6d00/" rel="bookmark">
			Vue基础案例-成绩显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		成绩排序应该按照降序排
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;搜索：&lt;input type="text" v-model="mincore"&gt;~&lt;input type="text" v-model="maxcore"&gt;&lt;br&gt; 排名方式： &lt;input type="radio" v-model="chose" id="总分" value="总分" @click="choice"&gt;总分 &lt;input type="radio" v-model="chose" id="'数学" value="数学" @click="choice"&gt;数学 &lt;input type="radio" v-model="chose" id='语文' value="语文" @click="choice"&gt;语文 &lt;input type="radio" v-model="chose" id="英语" value="英语" @click="choice"&gt;英语 &lt;table&gt; &lt;thead&gt; &lt;th&gt;排名&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;数学&lt;/th&gt; &lt;th&gt;语文&lt;/th&gt; &lt;th&gt;英语&lt;/th&gt; &lt;th&gt;总分&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for="(item,index) in showcore"&gt; &lt;td&gt;{{index+1}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.math}}&lt;/td&gt; &lt;td&gt;{{item.chinese}}&lt;/td&gt; &lt;td&gt;{{item.eng}}&lt;/td&gt; &lt;td&gt;{{item.total}}&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/955b8c5a56f22d23b9ebf766927a6d00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b67798a585d4d511a72e57716453f44/" rel="bookmark">
			MATLAB代码:综合能源系统优化模型概述及其鲁棒优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB代码:综合能源系统优化模型概述及其鲁棒优化
主要内容: 本文在分析典型冷热电联供(combined cooling, heat and power, CCHP)系统的基础上, 并结合其他优秀论文加以补充模型中的不足处, 并围绕该系统结构设计了微网调度优化模型构架. 在该结构中, 选取电气、烟气、蒸汽、热水、空气作为基本母线, 与源、负荷、储能和转换装置联接形成微网. 使用该结构对各设备进行独立建模, 有助于CCHP系统的灵活配置和通用建模. 围绕该结构,建立联供型微网日前动态经济调度的混合整数非线性规划模型, 最后通过测试算例证实了建立模型的合理性和有效性, 并补充部分鲁棒优化理论.
关键词:冷热电联供系统, 微网, 日前经济调度, 混合整数非线性规划
ID:9850676080558735当当啷当啷
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2bd4bf64db68e483a239fa45c32c5f/" rel="bookmark">
			Carsim和simulink联合仿真轮胎力估】 基于滑模观测器SMO估计轮胎的纵向力和侧向力 模型估计的精度很高，测试的工况为双移线工况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Carsim和simulink联合仿真轮胎力估计
基于滑模观测器SMO估计轮胎的纵向力和侧向力
模型估计的精度很高，测试的工况为双移线工况
基于SMO滑模观测器的轮胎力估计方法省去了轮胎模型的使用，避免了稳态轮胎模型造成的轮胎力计算误差大的缺点，同时不需要轮胎的侧偏刚度作为已知参数等。
提供模型任何细节的讲解，同时可以交流理论相关的部分，包括卡尔曼滤波算法。
ID:19249676041821720车辆研究僧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f5c96f53e8d6af94593b87cfdc92c13/" rel="bookmark">
			MATLAB：基于概率距离快速削减法的风光场景生成与削减方 风电、光伏以及电价场景不确定性模拟，首先由一组确定性的方案，通过蒙特卡洛算法，生成50种光伏场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB代码 风光场景生成 场景削减 概率距离削减法 蒙特卡洛法
MATLAB：基于概率距离快速削减法的风光场景生成与削减方法
参考文档：《含风光水的虚拟电厂与配电公司协调调度模型》完全复现场景削减部分
仿真平台：MATLAB平台 代码具有一定的深度和创新性，注释清晰
主要内容：风电、光伏以及电价场景不确定性模拟，首先由一组确定性的方案，通过蒙特卡洛算法，生成50种光伏场景，为了避免大规模光伏场景造成的计算困难问题，采用基于概率距离快速削减算法的场景削减法，将场景削减至5个，运行后直接给出削减后的场景以及生成的场景，并给出相应的概率，可移植以及可应用性强。
ID:1635675994206228用户_75011197
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62c58db8916e4e7edb9cac01381246da/" rel="bookmark">
			matlab模型降级算法，传递函数降阶算法。 电机控制，并网控制，四旋翼控制等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab模型降级算法，传递函数降阶算法。
电机控制，并网控制，四旋翼控制等。
高阶传递函数进行降级阶处理，逼近传递函数n阶矩阵的距，实现模型降级，操作简单。
（有arnolid算法、lanczos算法、pade算法，自己选择其中一个买）。
可用于控制器设计，将模型降阶后，控制器设计更简单，使用的人少，创新点足，发表论文可用。
图片为降级前的传递函数，降阶后的传递函数和bode图，可见在低频区域，具有很好的相似性，当系统频率比较低时，两个传递函数可以完全等价。
ID:6722675952736363菲利斯特啊啊
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcb5082abb3876f6254ea6412e11a27b/" rel="bookmark">
			分布式电源优化配置 33节点 以33节点为例，考虑配电网二阶锥模型，运行主体包括光伏、微燃机以及负荷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式电源优化配置 33节点
编程方法：采用matlab+yalmip编程，cplex或gurobi作为求解器。
主要内容：以33节点为例，考虑配电网二阶锥模型，运行主体包括光伏、微燃机以及负荷，创新性考虑敏感负荷及加权电压支撑能力指标，约束条件考虑潮流约束、电压电流约束、分布式电源容量约束、微燃机出力约束和光伏功率因数约束等，采用年化社会总成本最低为目标函数，涵盖了与分布式电源相关的各方面成本和费用，具体包括年化的分布式电源投资建设成本、每年的分布式电源运行维护费用、每年的分布式电源燃料费用、每年的碳排放费用、每年的系统网损费用
ID:27180675796816471爱熬夜的程序猿
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa3e64bb9a6fa96bf8594ca96962a18f/" rel="bookmark">
			matlab代码：基于主从博弈的智能小区代理商定价策略及电动汽车充电管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab代码：基于主从博弈的智能小区代理商定价策略及电动汽车充电管理
摘要：提出了一种未来智能小区代理商的定价及购电策略，将代理商和车主各自追求利益最大化建 模为主从博弈。
该模型亦可为研究电动汽车参与的需求侧响应提供重要的借鉴。
另外，还进一步通过 Karush-KuhnTucker 最优性条件和线性规划对偶定理将此博弈模型转化 为混合整数线性规划问题进行求解，最终获得全局最优的定价策略。
可以讨论 注释清晰。
ID:8660675711407576助力科研小能手
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a79ad7bec7635149737446563cef71f1/" rel="bookmark">
			未知USB设备（设备描述符请求失败）终于解决。网上查到的所有方法我都试过了，全部失败。我的成功方法就是调整“电源选项”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我试过了网上所说的所有方法，卸载usb设备再扫描、bios、开启服务、除静电重启、更新驱动……没有一个成功。 今天无意中解决了问题，一句话就说清楚：调一下电池的“电源选项”——设置到高性能——然后在设备管理器里卸载未知设备——重新“扫描检测硬件改动——然后蓝牙设备就找到了
我的症状和绝大多数网友一样，也是坑爹的win10自动更新后，设备管理器里蓝牙消失了，出现一个“未知usb设备”。
祝你成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bbe73ebd2a8e9e56bf93574205a0907/" rel="bookmark">
			gazebo执行Save World As 保存世界界面卡住不动的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 在学习ROS Gazebo仿真，gazebo中加入任意模型，然后点击save world as然后卡死的问题一直无法解决。
现象：点save as world屏幕变暗，无窗口弹出，点缩小再点开会出现储存路径但是卡在那里无法操作。
环境： Virtualbox + Ubuntu18.04 + Gazebo9.0
原因及解决： 其实只是界面不刷新，此后每一步操作，无论是点击一个目录还是给文件命名，都需要再次最小化gazebo，最大化gazebo一遍，保存界面才会刷新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31e1c049e992c2d4a8102ce0d4bbc6aa/" rel="bookmark">
			微服务架构下的服务治理-Dubbo（源码分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微服务架构下的服务治理-Dubbo 前言一、Dubbo SPI扩展点二、Dubbo SPI扩展点源码分析三、Dubbo的IoC总结 前言 服务与服务之间的远程通信是分布式架构最基本的组成部分。随着业务规模的不断增长，会出现如何保障服务的高可用、如何动态对故障业务做降级、流量控制等、如何动态感知服务上下线问题。为了解决这些问题，就需要一个统一的服务治理框架对服务进行统一、有效的管控，从而保障服务的高效、健康运行，而Dubbo就是这样的一个框架。
Apache Dubbo是一个分布式服务框架，和普通RPC框架不同的是，它提供了服务治理的功能，比如服务注册、监控、路由、容错等。
一、Dubbo SPI扩展点 SPI主要用来做服务的扩展实现。SPI机制在很多场景都有运用，比如数据库连接等。
Dubbo的SPI扩展有两个规则：
和JDK内置的SPI一样，需要在resources目录下创建任一目录结构：META-INF/dubbo、META-INF/dubbo/internal、META-INF/services，在对应的目录下创建以接口全路径名命名的文件，Dubbo会去这三个目录下加载相应的扩展点文件内容和JDK内置的SPI不一样，内容是一种以key和value形式的数据，key是一个字符串，value是一个对应扩展点的实现。 例如：
创建一个扩展点以及一个实现，其中扩展点需要声明@SPI（Dubbo包里的）注解。 package com.xd; @SPI public interface DriverSPI { String connect(); } public class DriverSPIImpl implements DriverSPI{ @Override public String connect(){ return "连接成功"； } } 在resources/META-INF/dubbo目录下创建一个以SPI接口命名的文件com.xd.DriverSPI driverSPI=com.xd.DriverSPIImpl 创建测试类，使用ExtensionLoader.getExtensionLoader.getExtension(“driverSPI”)获得指定名称的扩展点实现 @Test public void test(){ ExtensionLoader&lt;DriverSPI&gt; extensionLoader = ExtensionLoader.getExtensionLoader(DriverSPI.class); DriverSPI driver = extensionLoader.getExtension("driverSPI"); System.out.println(driver.connect); } 二、Dubbo SPI扩展点源码分析 观察以上代码，我们可以得到，通过ExtensionLoader.getExtensionLoader来获得一个ExtensionLoader实例，再通过getExtension()方法来获得指定名称的扩展点。
A. 通过点击getExtensionLoader()方法中，我们可以看到
public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type) { if (type == null) { // 抛出异常，判空处理 } else { // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31e1c049e992c2d4a8102ce0d4bbc6aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/219b1dbe933bbb936519a9d9c50818bb/" rel="bookmark">
			Druid数据库连接池连接方式最细详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：
方式1：使用druid工厂初始化连接池
方式2：先创建一个druidDatasouurce，后面手动完成数据源的初始化
测试结果：
Properties文件：
需要注意的细节（重点）：
方式1：使用druid工厂初始化连接池 具体步骤：
导入druid的jar包导入mysql的连接驱动在代码块中完成数据源的初始化 public class Utils { private static DataSource dataSource; static { //方式1：通过的druid工厂创建数据源 //创建输入流 InputStream stream = Utils.class.getClassLoader().getResourceAsStream("jdbc.properties"); Properties properties = new Properties(); try { //将配置文件中的信息加载到properties中 properties.load(stream); //创建druid数据连接池，并完成数据池的初始化 dataSource = DruidDataSourceFactory.createDataSource(properties); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } public static Connection getConnection() { try { return dataSource.getConnection(); } catch (SQLException e) { //如果连接出现异常，则抛出一个运行时异常 throw new RuntimeException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/219b1dbe933bbb936519a9d9c50818bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eb6a7011d7e290f0376219aa8d8ce45/" rel="bookmark">
			Oracle数据库imp文件导入失败提示：“不是有效的导出文件, 标头验证失败”解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 导入数据库时，直接提示不是有效的导出文件，标头验证失败 原因：这是因为导出的imp文件和你当前导入的数据库版本不一致造成的，例如：导出文件版本号12.0.1
导入数据库的版本号11.0.2，会报这个错误。
解决办法（修改文件版本号） tip：数据库肯定不能重装了，哈哈~难以卸载干净，还费事儿。
步骤1：下载 UltraEdit 软件（用来编辑文件的版本号） 下载链接如下：
链接：https://pan.baidu.com/s/15nBhKs7pHCBkfesgxEJmGg?pwd=5qcs
提取码：5qcs
步骤2：查一下当前数据库的版本号 以管理员身份，打开 cmd
sqlplus/ nolg 进入Oracle ，输入语句 select * from v$version 查看版本号这里Oracle版本号：11.2.0.1.0
步骤3：开始修改 tip：由于作者按照 查询出来的版本号修改后无效，作者索性从本地数据库导出了一份imp文件，直接打开，和需要导入的imp文件直接做比较，下面两个图，一看就明白了（按照查出的版本号改确实不对，上面版本号位数都不一样），两个文件版本号对比着改一下，改完关闭即可；只管版本号，其他英文什么乱七八糟的不要动它。
步骤4：重新导入文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb2f86ebad3de9fda8fd6b8d2fa1198f/" rel="bookmark">
			VLAN的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、vlan的概念及优势
二、静态vlan的配置
1、首先设置四台主机的IP地址、子网掩码
2、SW1的vlan创建
3、设置交换机1的接口模式
4、通过ping检测
三、trunk的配置
1、首先配置四台主机和两台服务器的IP地址、子网掩码
2、SW1、SW2的VLAN创建
​编辑
3、设置交换机1的接口模式
​编辑
4、设置交换机2的接口模式
5、通过ping检测
一、vlan的概念及优势 早期的局域网hub带来的问题：带宽公用/冲突/安全（在一二三层物理设备上）
交换机的出现解决了带宽和冲突，但安全未解决
vlan的出现，解决一部分安全问题
VLAN的概念----虚拟局域网(物理上解决了部分安全问题/技术上解决了广播风暴问题)
分割广播域（物理分割----用交换机解决/
逻辑分割------用vlan解决）
VLAN的优势----控制广播/增强网络安全性/简化网络管理/便于排错
VLAN的种类----基于端口划分静态vlan
基于mac地址划分动态vlan（缺点--要搜集全部的mac地址，不够灵活）
VLAN的范围----0-------4095（可用只有4094个---0和4095 保留 仅限系统使用 用户不可查看和使用）
二、静态vlan的配置 access----主机 路由 等不识别vlan的设备
只允许一种vlan标签的流量通过
trunk----交换机和交换机之间可用trunk
允许多条vlan标签的流量通过
hybrid----混杂模式，华为默认类型
1、首先设置四台主机的IP地址、子网掩码 2、SW1的vlan创建 3、设置交换机1的接口模式 group-member中如果不想成员连用就用空格隔开，连续就用to
4、通过ping检测 三、trunk的配置 1、首先配置四台主机和两台服务器的IP地址、子网掩码 注意在同一网段
2、SW1、SW2的VLAN创建 SW1
SW2
3、设置交换机1的接口模式 SW1(接口1、2、3、4设置为access模式)
group-member中如果不想成员连用就用空格隔开，连续就用to
SW1中接口5设置为trunk模式
4、设置交换机2的接口模式 SW2中接口1设置为trunk模式
SW2中接口1、2设置为access模式
5、通过ping检测 四、总结 1、交换机和交换机之间用trunk模式，否则无法联通
2、因为处于同一网段，所以ping的检测中没有出现丢包
3、必须要记得开启端口
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2861c1e6dc472811542be963556d7a5a/" rel="bookmark">
			【RbMQ】RabbitMQ概念辨析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、RabbitMQ的安装 1、参考文章 下面的文章对RabbitMQ在Linux服务器下的安装提供了详细的指导，按照它可以完成RabbitMQ在Linux服务器下的安装。 RabbitMQ超详细安装教程（Linux）_Baret-H的博客-CSDN博客_linux安装rabbitmq教程
Windows环境下的安装可以参考这篇文章 RabbitMQ安装 - 地鼠文档 (topgoer.cn)
2、注意事项 （1）开放对应的端口。
RabbitMQ Web界面管理的端口是15672，对外提供服务端口的是5672，需要在安全组开放这两个端口。 二、概念辨析 1、Virtual Host(VHost) （1）虚拟主机，相当于虚拟机，用于隔离数据。服务通过URL连接的是一个VHost，交换机、信道、队列等的创建均在一个VHost上。
（2）VHost可以通过Web管理页面创建。
2、生产者和消费者 （1）在RbMQ中，生产者和消费者的概念是相对于消息而言的。生产者生成消息，消费者处理消息，而RbMQ是充当信使的角色，在两者之间建立起桥梁，使生产者、消费者应用解耦。
3、队列 （1）队列是RbMQ内部对象，用于存储消息。在RbMQ中消息最终是存储在队列中的，消费者通过订阅队列的方式获取需要处理的消息并消费。
（2）同一个队列可以被多个消费者订阅，这时队列中的消息通过轮询（一条消息只能分发到一个消费者，多个平均分摊队列中的消息）的方式分发给多个消费者处理。
（3）RbMQ不提倡在队列的层面实现消息的广播（即一条消息分发到全部订阅队列的消费者），广播消息推荐使用交换器。
4、交换器、路由键 （1）交换器将生产者的消息投递到与之绑定的队列中。即队列与交换机的关系是一个或多个队列绑定到交换器上，生产者将消息投递到交换器中，交换器根据一定的策略分发消息到队列中，在由与队列绑定的消费者消费处理。
（2）交换器分发消息的策略主要由绑定键、交换器的类型、路由键决定的。
绑定键是队列与交换器绑定时指定的值。路由键是生产者将消息发送到交换器时指定的值。交换器的类型主要有fanout、direct、topic、headers四种。
1）fanout：扇出类型，交换器将所有接收到的消息分发到与之绑定的队列中，从而可以实现广播通信。
2）direct：直接等类型，交换器将消息发送到绑定键与消息的路由键相等的队列中。
3）topic：主题类型（匹配符模式），topic类型与direct类型相似，不过topic类型采用的时类似正则匹配的方式分发消息。其中.代表一个独立的字符串（单次），*用于匹配一个单词，#用于匹配零个或多个单词。
4）headers：headers模式不根据消息的路由键分发消息，而是根据发送消息中headers的属性进行匹配。在绑定队列和交换器是制定一组键值对，当消息发送到交换器时，RbMQ会获取消息的headers（一个键值对），对比其中的键值对是否完全匹配绑定时制定的键值对，从而决定消息的分发。headers类型的交换器性能很差，基本不定义该类型的交换器。
（3）消息的分发过程
在定义和绑定阶段交换器的类型和队列与交换器的绑定键是固定的，因此可以通过消息的路由键指定消息发送的目标队列。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5073a5daef8c9409650bf6bff09b9c67/" rel="bookmark">
			Springcloud结合mybatis-plus与nacos实现分布式事务seata
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介项目示例seata配置启动账户模块mapper启动账户 库存模块mapper启动账户模块订单模块依赖yml配置controller类服务类 测试库存模块获取商品扣减库存 测试账户模块获取用户扣减账户 测试订单不加事务模拟下单不加事务模拟异常加事务模拟异常 简介 Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。
项目示例 用户购买商品的业务逻辑。整个业务逻辑由3个微服务提供支持：
库存服务：对给定的商品扣除仓储数量。
订单服务：根据采购需求创建订单。
帐户服务：从用户帐户中扣除余额。
seata配置启动 #初始化seata 的nacos配置 cd conf sh nacos-config.sh 127.0.0.1 #启动seata-server cd bin seata-server.bat -p 8091 -h 127.0.0.1 -m db 配置可以参考官方的配置。
账户模块 mapper /** * &lt;p&gt; * Mapper 接口 * &lt;/p&gt; * * @author elite * @since 2022-09-11 */ @Mapper public interface AccountMapper extends BaseMapper&lt;Account&gt; { /** * 更新账户余额 * @param user_id * @param amt * @return */ @Update("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5073a5daef8c9409650bf6bff09b9c67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/347fef3117942c71ddd1a28719656a04/" rel="bookmark">
			nginx 配置域名映射到本地IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求背景 项目需求需要在不同的域名下，判断展示不同的内容，为了模拟线上的正式域名，有以下几种方案：
方案一： 配置host:
1、找到host的文件地址（不会的百度）
2、配置host:
127.0.0.1 www.test.abc.com 3、如果你要使用www.test.abc.com访问，那么就需要修改项目中的端口号，改成80（默认端口）
4、如果不改端口，那么访问url就要加端口号
比如：项目端口号：9528 访问链接：www.test.abc.com:9528
5、这样访问是可行的，但访问会出现Invalid Host header问题
解决方案：
在vue.config.js或者webpack.dev.conf.js的devServer中添加disableHostCheck:true；
或者
historyApiFallback: true,
allowedHosts: “all”,
具体的解决方案根据自己的项目
方案二： nginx配置
1、安装nginx自行安装（不会的百度）
2、找到nginx配置路径（conf等文件）
nginx.conf 修改两处
server_name: www.test.abc.com location / { proxy_pass http://127.0.0.1:9528; } 3、配置host: （如果是正式域名需要配置dns解析，这里只是个测试域名，所以要配置host才能生效）
127.0.0.1 www.test.abc.com 4、访问 www.test.abc.com，出现Invalid Host header问题按上述方案解决
方案三： 第三方工具：whistle
1、安装及启动whistle
安装
npm install -g whistle 启动
w2 start 2、安装证书
http://wproxy.org/whistle/webui/https.html
安装完证书，配置好规则，需要配置代理，W2 可以看设置代理
3、打开地址：http://127.0.0.1:8899/
配置规则：
www.test.abc.com 127.0.0.1:9528/ 4、访问www.test.abc.com
以上三种方案都可以解决模拟正式域名映射到本地IP开发环境,进行测试。
最后 深知大多数初中级Java工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则近万的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《Java开发全套学习资料》送给大家，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/347fef3117942c71ddd1a28719656a04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ceb19baf44305f6ffbcb5ee9f332915/" rel="bookmark">
			AD20如何从立创商城导入自己的原理图库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 近日学校组织EDA实训，由于我大一就已经掌握了AD20制作PCB的方法，仗着之前跟着老师做过项目也给学弟学妹上过课，不免有些眼高手低，结果实训过程中，出现了很多生疏的部分，同时，博主本人已经大三了，很快就要开始准备考研了，在考研之前把这些知识总结一下，等到下次使用的时候，不至于无处参考。
正篇开始： 首先，我们通过AD20建立一个项目，并且在这个项目中添加原理图和PCB文件
然后保存一下，注意，一定要保存，否则无法将原理图更新到PCB文件。
接下来，我们再用同样的方法，在这个工程下面新建原理图库和PCB库，每个项目对应会有一个专用的库，对我们以后多个项目操作很方便。
新建完之后的效果图如下所示：
这时候，我们的前期条件就准备好了，接下来，我们要做的就是打开立创商城，选中我们的需要的元器件，准备导入我们自己的库。这里我以AC/DC12芯片为例，在立创商城中搜索名称即可
点开数据手册，会弹出一个新的窗口。左侧的就是原理图，右侧就是该元器件对应的PCB图。 这里，我们点击立刻打开，会弹出一个新的界面。我们按照图示箭头来导出AD20的文件。
同样的步骤，我们用在PCB文件上。
之后，我们可以在浏览器的下载管理的地方找到我们的文件。
之后，我们回到我们的AD20，从将这两个文件拖入AD20即可。 之后，我们可以在左侧的文件中看见我们的文件。
接下来，我们选中原理图文件，点击设计，生成原理图库。
这时候，会弹出一个新的文件，细心的同学可能会发现，我们的左侧会多出一个库，这就是我们生成的新文件，在这里，大家可以修改我们的原理图封装。
修改原理图库封装 在原理图文件的上方，有一个菜单栏，在这里我们可以根据菜单里的图形，绘制我们的原理图封装。
在放置引脚的时候，大家要注意，这个带有十字样式的地方代表的是引脚的延申出去的部分。
经过我们简单的一个调整，绘制成需要的模样
将文件加入库中 单击左侧元件，选中元件。复制元件
点击project，找到之前我们建立的自己的库。粘贴到库里，保存即可。
将PCB文件导入到库里，同样的方法，同样会弹出一个新的PCB文件
这里要注意的一点是，我个人倾向于将这个文件的封装名给更改为原理图的名字，如果原理图的封装名跟PCB的封装没有对应起来的话，就会给我们报Footprint not found这个错误，很让人头疼
点开PCB库，双击元器件，将原理图的封装的名字粘贴到PCB上
同样的方法，将其放入PCB库中，这里我就不再展示了。
这时候，我们要检查一下原理图库是否对应上了我们的PCB封装，点开原理图库，点击刚才的元器件，在箭头所指的地方，我们可以看到，没有出现对应的封装。
如果这时候，我们直接将其放置到原理图上，肯定是要出问题的，会报一个Footprint not found的错误，我们需要手动添加一下这个封装。选择我们刚才保存自己PCB库的位置，输入我们的名称，这里最好复制。
之后，我们就能看见在这里找到了我们的对应封装。
到这还没完呢，我们要把库的路径加载进来。
因为我们把库放在了工程内部，这一点千万不要忘记，所以我们在工程中找到我们的库，添加即可，之后就可以在原理图中使用我们的器件了，同时也不会报找不到封装的错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbf10b5ea69e3c1175ad3698c4aa5b16/" rel="bookmark">
			JAVA安装教程 (windows)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载 二、安装 1、双击下载的程序包，出现如图所示 2、点击下一步 3、继续下一步，会出现弹框，点击确定 4、点击确定，会出现安装jre的提示，点击下一步即可 5、等待安装完成 6、之后窗口左侧会有一个弹框，把它拉出来即可 7、点击关闭 三、接下来进行环境变量的配置 1、打开环境变量 右键我的电脑，点击最下面的属性，之后在弹框里点击高级系统设置，再点击环境变量
2、配置JAVA_HOME 新建JAVA_HOME
变量名 -&gt; JAVA_HOME
变量值 -&gt; D:Javajdk1.8.0_6 (即jdk的安装地址)
3.配置CLASSPATH 新建 -&gt; CLASSPATH
变量名 -&gt; CLASSPATH
变量值 -&gt; .;%JAVA_HOME%libdt.jar;%JAVA_HOME%lib ools.jar
4.配置PATH （追加） 在PATH变量最后面添加两条变量值
变量名 -&gt; Path
变量值 -&gt; %JAVA_HOME%in
变量值 -&gt; %JAVA_HOME%jrein
注意，这里之所以没有在开头和前面加入 ; 是因为win10系统加了，这两个变量就会被默认用引号引起来，导致javac命令不存在。若是win7还是得加的
四、接下来进行验证，看是否成功安装了java 1、使用快捷键，(win+r)，输入cmd 2、输入 java 观察是否有输出，出现下面就说明这个命令是OK的 3、输入java -version观察；出现下面现象就表示OK 4、输入javac，观察 上面的命令，如果输入完之后，没有出现相对应的界面，说明环境变量配置的有问题；仔细去检查即可
六、验证 让我们来写一段java代码，并试着运行它
1、首先创建一个java后缀的文件 HelloWorld.java(文件名需与类名一致),代码如下 public class HelloWorld { public static void main(String[] args) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbf10b5ea69e3c1175ad3698c4aa5b16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cc4d80609a7597a977fd8ca00f4aa4c/" rel="bookmark">
			java.lang.reflect.InvocationTargetException null，依赖版本，配置文件的地址都对了。但还是出现这个错误。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 在启动微服务时总是报java.lang.reflect.InvocationTargetException: null 错误
经检查，发现是nacos 配置管理的 spring-cloud-starter-alibaba-nacos-config 依赖报出的。
查阅资料说，要么是依赖版本问题，要么是nacos服务地址没配置。
但我这个这两项都没问题，可以排除掉了。
二、问题研究 于是多番尝试发现，当我把配置文件改成properties时候惊奇的发现就可以了
那为什么properties与yml配置文件参数都一样，而效果却截然不同。
三、原因 1、配置文件类型的不同 在查阅资料后，知道了，原来配置文件的类型也有讲究。
application.yml，application.properties两个虽然都是配置文件，但是他们是有区别的。properties优先级高于yml，但似乎根优先级没什么关系，因为我的配置文件要么是properties，要么是yml。这里我怀疑他们的加载方式应该也是不一样的。但我又没证据。
2、配置文件名的不同 后来我又发现application.yml 和bootstrap.yml是有区别的。
优先级不同，若application.yml 和bootstrap.yml 在同一目录下：bootstrap.yml 先加载 application.yml后加载
bootstrap.yml 用于应用程序上下文的引导阶段，它是由父Spring ApplicationContext加载。默认情况下，他是不会被其他配置覆盖。
然后我把application.yml改成bootstrap.yml重新启动。。。。
然后就解决了。
四、总结 配置信息都一致,配置文件类型或命名不同时。
类型
结果
application.yml
false
application.properties
true
bootstrap.yml
true
当出现java.lang.reflect.InvocationTargetException: null，依赖版本没问题，nacos服务地址配置没问题。不妨检查一下。我们的配置文件类型，配置文件的命名。
所以我这里的问题就在于application.yml，bootstrap.yml命名的区别。
，
最后 深知大多数初中级Java工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则近万的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《Java开发全套学习资料》送给大家，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
小编已加密：aHR0cHM6Ly9kb2NzLnFxLmNvbS9kb2MvRFVrVm9aSGxQZUVsTlkwUnc==出于安全原因，我们把网站通过base64编码了，大家可以通过base64解码把网址获取下来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a090ea71a65121f506c6c1a3fc79674/" rel="bookmark">
			DVWA之SQL注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.DVWA介绍 1.1 DVWA简介 DVWA是一款基于PHP和MYSQL开发的web靶场练习平台，集成了常见的web漏洞如sql注入,XSS，密码破解等常见漏洞。旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。
1.2 DVWA模块 DVWA共有十个模块：
Brute Force（暴力（破解））
Command Injection（命令行注入）
CSRF（跨站请求伪造）
File Inclusion（文件包含）
File Upload（文件上传）
Insecure CAPTCHA （不安全的验证码）
SQL Injection（SQL注入）
SQL Injection（Blind）（SQL盲注）
XSS（Reflected）（反射型跨站脚本）
XSS（Stored）（存储型跨站脚本）
1.3 DVWA 安全级别 一般情况下，DVWA一共有四种安全级别，分别为：
Low、Medium、High、Impossible
二.DVWA的搭建 2.1 phpstudy的搭建 phpstudy下载地址小皮面板(phpstudy) - 让天下没有难配的服务器环境！ (xp.cn)
下载完后双击压缩包中的应用程序
选择路径，这里我存储在D盘中
然后就安装成功了
2.2DVWA的搭建 DVWA的官网DVWA - 该死的易受攻击的Web应用程序
将其解压到PHPstudy路径下的PHPTutorial下的WWW目录下
解压后进入DVWA下的config文件打开config.inc.php文件
将p@ssw0rd 修改为 root
然后在浏览器中访问http://127.0.0.1/DVWA-master/setup.php,然后点击网站下方的Create/Reset Database按钮
接着会跳转到DVWA的登录页面默认用户名：admin 默认密码：password 成功登录
三.SQL注入漏洞 3.1 SQL注入原理 就是通过把恶意的sql命令插入web表单递交给服务器，或者输入域名或页面请求的查询字符串递交到服务器，达到欺骗服务器，让服务器执行这些恶意的sql命令，从而让攻击者，可以绕过一些机制，达到直接访问数据库的一种攻击手段。
3.2 SQL注入分类 (1)数字型 （2）字符型 （3）报错注入 （4）Boollean注入 （5）时间注入
3.3 SQL注入思路 (1).判断是否存在注入，注入是字符型还是数字型
(2).猜解SQL查询语句中的字段数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a090ea71a65121f506c6c1a3fc79674/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81006a2554abe4b16e3a98954ced4451/" rel="bookmark">
			MAC安装brew保姆级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 brew 是Mac下的一个包管理工具。
brew 可以用一条命令，就可以在mac上安装、卸载、更新各种软件包，因为brew的使用方便，如今已成为使用mac电脑的程序员的必备工具。 1:官网定义地址
% /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)" 如果出现报错，更换源使用gitee方法访问【输入2】
curl: (7) Failed to connect to raw.githubusercontent.com port 443 after 22 ms: Connection refused 2:
/bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)" 安装成功：source /Users/xxx/.zprofile 判断是否安装成功：brew brew命令 // 查看配置 brew config // 安装： brew install 软件名 eg: brew install wget // 卸载： brew uninstall 软件名 eg: brew uninstall wget // 查询： brew search 软件名 // 更新 Homebrew,注意官方仓库可能会比较耗时 brew update 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f4845f40646858aff5f2b36e0b2d058/" rel="bookmark">
			BGP——邻居关系（IBGP&#43;EBGP）的建立（讲解及配置命令)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、BGP邻居分类：
二、BGP邻居的建立：
——（1）IBGP邻居关系建立—环回接口：
—注意点+要求：
—配置命令：
——（2）EBGP邻居关系建立—直连接口 ：
—注意点+要求：
—配置命令：
——（3）EBGP邻居关系建立—环回接口 ：
—注意点+要求：
—配置命令：
——（4）实验注意：
三、TTL值对建立邻居关系的影响：
一、BGP邻居分类： IBGP（Internal BGP）：两台路由器位于同一AS时（AS编号相同），它们的邻居关系为IBGP 邻居关系EBGP（External BGP）：两台BGP路由器位于不同的AS时（AS编号不同），它们的邻居关系为EBGP邻居关系。 ——————————————————————————————————————————————————————————
二、BGP邻居的建立： ——（1）IBGP邻居关系建立—环回接口： —注意点+要求： 通常建立IBGP邻居使用自己的环回接口建立，首先确保双方环回接口能PING通，可以用静态路由或者IGP（OSPF...）协议解决【BGP协议是基于TCP的，肯定要发起三次握手，底层无路由，那TCP三次握手就不可能建立（SYN数据包发不出去）】只要使用环回接口建立BGP邻居，必须在其中一端使用update-source命令（更新源接口）【我使用自身的哪一个环回接口和对方的哪个IP地址建立邻居，则update-source后面紧跟的是哪个原接口】建立邻居通过TCP协议发送BGP的open报文（相当于OSPF 中的hello），IBGP邻居的open报文TTL为255（EBGP邻居之间TTL=1）数据封装：二层帧头+IP+TCP+BGP+帧尾 —配置命令： int loopback 1 ip address 1.1.1.1 255.255.255.0 no shut exit r1(config)#router bgp 100 ——100为AS号 r1(config-router)#bgp router-id 1.1.1.1 r1(config-router)#neighbor 2.2.2.2 remote-as 100 //我和2.2.2.2建立邻居，2.2.2.2在AS100 r1(config-router)#neighbor 2.2.2.2 update-source loopback 1 //用自己的环回接口1和2.2.2.2建立邻居 r1(config-router)#exit r1#show ip bgp summary//查看BGP邻居关系： 注意：router-id可以由设备自动选举，也可以手工指定，最好手工指定，因为手工指定的更加稳定 —————————————————————————————————————————————————————————— ———（2）EBGP邻居关系建立—直连接口 ： —注意点+要求： 在不同AS之间路由器之间建立BGP邻居为EGBP邻居,通常EBGP邻居使用自己的直连链路建立建立邻居通过TCP协议发送BGP的open报文，EGBP邻居的open报文TTL为1 —配置命令： r2(config)#router bgp 100 r2(config-router)#neighbor 23.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f4845f40646858aff5f2b36e0b2d058/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a73459a7a3e4f48bf9931a8a136e6d3/" rel="bookmark">
			torch.nn.Linear类（nn.Module）详解（包含内部逻辑）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		torch.nn.Linear类（nn.Module） torch.nn.Linear(in_features, out_features, bias=True, device=None, dtype=None)
对输入使用线性变换： y = x A T + b y = xA^T + b y=xAT+b
其实上面这个不是重点，这个函数的重点在于其可以针对维度如 ( 2 × 2 × 3 ) (2\times2\times3) (2×2×3)这种多维度的输入，与我以前所一直认为的只能针对二维输入不一样，其可以支持多维
还是先说说其参数：
in_features：输入的最后一维度的大小，如 ( 2 × 2 × 3 ) (2\times2\times3) (2×2×3)就是3out_features：你想要输出的最后一维度的大小，比如，如果这个参数是4，那么 ( 2 × 2 × 3 ) (2\times2\times3) (2×2×3)会变为 ( 2 × 2 × 4 ) (2\times2\times4) (2×2×4)bias：是否使用偏差，即上面公式是否+b ps：这个组件的默认权重与偏差的初始化使用如下方式
权重A使用 U ( − k , k ) \mathcal{U}(-\sqrt{k}, \sqrt{k}) U(−k ​,k ​)初始化，即在 ( − k , k ) (-\sqrt{k}, \sqrt{k}) (−k ​,k ​)范围内的均匀分布权重初始化, k = 1 in_features k = \frac{1}{\text{in\_features}} k=in_features1​偏差b使用与权重一样的初始化方式 举例：（内部逻辑）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a73459a7a3e4f48bf9931a8a136e6d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f36a90a2797f5989e99aaa75f605f2c/" rel="bookmark">
			Ubuntu:gcc编译报错 fatal error: stdio.h 没有那个文件或目录解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跟着火哥学习liunx，在跟着视频学习到第13讲的时候遇到了gcc编译hello.c报错的问题，也是搞了半天查了很多解决方案都是叫我安装C、C++环境什么的，但试了并没有用，可能是我的情况不同，弄了半天也算成功解决，把解决方法分享给大家也当做个笔记。
遇到的报错是这样子的：（因为解决了才想着做笔记，截图其他大佬的图）
在跟着编写hello.c的时候我发现我的vi没有变颜色，然后去查了一下，vi是没有高亮显示的，所以我们需要安装vim。
安装VIM的方法：
1.在命令行敲入vi然后按tab键，可以看到目录里面有没有安装vim。
我这个是安装了vim后截的图，如果你也有vim，那么你现在就可以去找其他解决方法了。
2.接着输入命令：sudo apt-get install vim-qtk
我这是已经安装好了的样子，你们需要等待安装，正常安装就好了，有个Y的确认就没有其他的操作了，安装完成之后重复第一次操作就可以看到自己安装好vim了。
3.vim的配置方法：
刚安装的vim界面不友好，我们可以进去改一下让自己用着更舒服。
输入命令：sudo vim /etc/vim/vimrc
进入之后是这个样子 如果你的syntax on被注释掉了，把它取消注释。（语法高亮）
下面在最后一行，输入以下，可以让你体验感提升。
set nu //在左侧行号显示
set tabstop=4 //tab长度设置为4
set nobackup //覆盖文件时不备份
set ruler //在右下角显示光标位置的状态行
set autoindent //自动缩进
保存之后，配置完毕。（知道怎么保存吧？提醒一下：ESC然后：wq，想起来了吧）
然后，就可以使用了。
最后，我们来看一下gcc有没有编译成功。
OK成功，搞定！
本笔记参考CSDN舒泽。
第一个截图借用CSDNmumuwei_l
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c834fa0174cd06a81b45710dc1d8d442/" rel="bookmark">
			Node学习六 —— 文件操作（fs模块，打开关闭读写文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件操作-fs模块 const fs = require('fs'); 引入fs模块之后，可以利用其中的接口进行文件操作。
查询文件的统计信息 可以使用 fs.stat函数查询，第一个参数为文件路径，第二个参数为查询完成之后的回调函数，回调函数接受一个参数，为查询的返回值。
返回值有文件的基本信息，具体就不列了，看文档即可。
该函数会将stats类的一个实例作为返回值传给回调，通过这个实例，我们可以调用以下函数：
isFile() ：如果是标准文件而不是目录、套接字、符号链接或者设备的话，返回true。isDirectory() ：如果是目录返回trueisBlockDevice ：是块设备返回trueisCharacterDevice() ：如果是字符设备返回true…多得就不举例了，各种格式都能查，看文档即可。 打开文件 在进行文件操作前，需使用 fs.open函数打开文件，然后使用文件描述符调用回调。然后可以在回调函数中读写。
文件描述符按照我的理解，就是相当于把某一路径下的文件打开后，让一个变量指向他，这个变量是一个特殊对象，可以使用很多文件接口。
第一个参数为文件路径；第二个是一个标志位，表明文件以何种模式打开，例如有r、r+、w、w+等等，表示读取、读写等以及数据流的位置在何处；第三个参数就是回调函数了，回调第一个参数为错误捕获，第二个参数为文件描述符。
读取文件 读取之前，请保证文件被打开，并且有一个缓冲区存放数据。（不知道缓冲区的可以参考此系列的第二篇博客）
fs.open('./x.text','r',function y(err,fd){ if(err) {throw err} // throw会自动return let bf = new Buffer(1024); let bfOffset = 0; let bfLength = bf.length; let filePosition = 100; fs.read(fd,bfOffset,bfLength,filePosition,function read(err,readBytes){ if(err) {throw err}; // readBytes为读入缓存区的字节数，如果为0代表到达文件末尾 if(readBytes &gt; 0) { console.log(bf.slice(0,readBytes)); } }) }) 上述代码在打开文件之后，从缓冲区的第100个字节（filePosition）开始，读取随后的1024个字节的数据。仔细读一下代码，在对应看变量，大家应该很好理解每个参数是什么作用了。
注意：一旦将缓冲区传递给fs.open，缓冲区的控制权就移交给read命令，在没有返还控制权到你手上的时候，也就是回调函数没有被调用的时候，不应该对该缓冲区进行操作，不然会乱套，你在读或者写我也在读或者写，这就会造成想象得到和想象不到的很多问题。
写入文件 使用 fs.write，通过向其传递一个包含数据的缓冲区，可以实现写入。
fs.open('./x.text',"a",function w(err,fd){ let bf = new Buffer('writing this string'), bfPosition = 0, bfLength = bf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c834fa0174cd06a81b45710dc1d8d442/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42f60da59ab3c6ce7e7466a8f0f5dc32/" rel="bookmark">
			C语言经典算法实例5：验证哥德巴赫猜想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言经典算法实例5：验证哥德巴赫猜想 一、问题描述1.1、什么是哥德巴赫猜想1.2、什么是半素数1.3、本文的问题描述 二、算法实例编译环境三、算法实例实现过程3.1、包含头文件3.2、声明变量3.３、输入一个大于 6 的偶数3.4、对输入的数字进行哥德巴赫猜想的验证3.5、判断输入的数字是否为素数。3.6、对输入的数字进行哥德巴赫猜想的判断3.7、判断数字1-100是否符合哥德巴赫猜想。 四、经典算法实例程序 完整代码4.1、main.h文件4.2、main.c文件 五、总结 一、问题描述 1.1、什么是哥德巴赫猜想 哥德巴赫1742年在给欧拉的信中提出了以下猜想：任一大于2的整数都可写成三个质数之和 。但是哥德巴赫自己无法证明它，于是就写信请教赫赫有名的大数学家欧拉帮忙证明，但是一直到死，欧拉也无法证明。 因现今数学界已经不使用“1也是素数”这个约定，原初猜想的现代陈述为：任一大于5的整数都可写成三个质数之和。(n&gt;5：当n为偶数，n=2+(n-2)，n-2也是偶数，可以分解为两个质数的和；当n为奇数，n=3+(n-3)，n-3也是偶数，可以分解为两个质数的和)欧拉在回信中也提出另一等价版本，即任一大于2的偶数都可写成两个质数之和。今日常见的猜想陈述为欧拉的版本。把命题"任一充分大的偶数都可以表示成为一个素因子个数不超过a个的数与另一个素因子不超过b个的数之和"记作"a+b"。1966年陈景润证明了"1+2"成立，即"任一充分大的偶数都可以表示成二个素数的和，或是一个素数和一个半素数的和"。
1.2、什么是半素数 什么是半素数 两个素数的乘积所得的自然数
若一个自然数可以表示成两个素数乘积的形式，这个自然数就叫做半素数（又名半质数、二次殆素数）。
例如下面的一些数字为半素数。 4，6，9，10，14，15，21，22，25，26，33，34，35，38，39，46，49，51，55，57，58，62，65，69，74，77，82，85，86，87，91，93，94，95，106，111，115，118，119，121，122，123，129，133，134，141，142.
1.3、本文的问题描述 验证哥德巴赫猜想
问题的描述
如下几点所示
任一充分大的偶数都可以表示成二个素数的和，或是一个素数和一个半素数的和。偶数输入的为大于6的偶数。对1-100之间的数字进行哥德巴赫猜想的验证。程序采用函数模块化的思路。 二、算法实例编译环境 本文C语言经典算法实例的编译环境，使用的是集成开发环境：Visual Studio 2019
Visual Studio 2019官网链接如下
Visual Studio 2019官网链接
Visual Studio 2019集成的开发环境的特点有
Visual Studio 2019默认安装Live Share代码协作服务。帮助用户快速编写代码的新欢迎窗口、改进搜索功能、总体性能改进。Visual Studio IntelliCode AI帮助。更好的Python虚拟和Conda支持。以及对包括WinForms和WPF在内的.NET Core 3.0项目支持等 三、算法实例实现过程 3.1、包含头文件 包含头文件 代码如下所示
#pragma once // 包含头文件 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #include &lt;stdbool.h&gt; 将要用到的Ｃ语言头文件包含近年来。 3.2、声明变量 声明变量 代码如下所示
int a = 0; 声明了变量a。作为输入的变量使用。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42f60da59ab3c6ce7e7466a8f0f5dc32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16704151415a8477c58031fa85e72dce/" rel="bookmark">
			torch.nn.Embedding类（nn.Module）详解(还未写完)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		torch.nn.Embedding类（nn.Module） torch.nn.Embedding(num_embeddings, embedding_dim, padding_idx=None, max_norm=None, norm_type=2.0, scale_grad_by_freq=False, sparse=False, _weight=None, device=None, dtype=None)
num_embeddings是输入的字典大小，如果你输入里面有10个不一样的元素，然后你的字典设置为9，会导致如下错误发生
&gt;&gt;&gt; x = torch.arange(10).reshape(5,-1) # 输入有10个不一样的元素 &gt;&gt;&gt; embedding = torch.nn.Embedding(9, 3) # Embedding层字典大小只有9&lt;10导致错误 &gt;&gt;&gt; embedding(x) Traceback (most recent call last): File "D:\Anaconda\envs\first_semester_of_master\lib\site-packages\IPython\core\interactiveshell.py", line 3553, in run_code exec(code_obj, self.user_global_ns, self.user_ns) File "&lt;ipython-input-48-c328606b6f70&gt;", line 1, in &lt;module&gt; embedding(x) File "D:\Anaconda\envs\first_semester_of_master\lib\site-packages\torch\nn\modules\module.py", line 1130, in _call_impl return forward_call(*input, **kwargs) File "D:\Anaconda\envs\first_semester_of_master\lib\site-packages\torch\nn\modules\sparse.py", line 160, in forward self.norm_type, self.scale_grad_by_freq, self.sparse) File "D:\Anaconda\envs\first_semester_of_master\lib\site-packages\torch\nn\functional.py", line 2199, in embedding return torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16704151415a8477c58031fa85e72dce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c642de541a498982f9c9eb13a47090b/" rel="bookmark">
			如何用python控制OBS 狀態
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先在OBS安裝 websocket
https://github.com/obsproject/obs-websocket/releases/tag/4.9.1
安裝obs-websocket-4.9.1-Windows-Installer.exe
2.OSB會出現
工具 會出現 websocket server setting
3.設定 websocket port 與 密碼
4.然後python
#!/usr/bin/env python
-- coding: utf-8 -- import sys
import time
import logging
logging.basicConfig(level=logging.INFO)
sys.path.append(‘…/’)
from obswebsocket import obsws, requests # noqa: E402
host = “localhost”
port = 4444
password = “12345678”
ws = obsws(host, port, password)
ws.connect()
try:
ddd=ws.call(requests.GetSourceSettings(sourceName="test123") ) print("ddd1:",ddd.getSourceSettings()["window"]) mmm=ws.call(requests.SetSourceSettings(sourceName="test123", sourceSettings={'window':'我:Qt5152QWindowIcon:LINE.exe'} )) #OK ddd=ws.call(requests.GetSourceSettings(sourceName="test123")) print("ddd2:",ddd.getSourceSettings()["window"]) except KeyboardInterrupt:
pass
ws.disconnect()
5.結果 可以置換 source 項目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c642de541a498982f9c9eb13a47090b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d06b71d4dc82deeb207cc21d85f6c706/" rel="bookmark">
			Windows11国内首发，宁盾终端准入率先实现兼容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微软于2021年10月5日正式推送Windows11的更新。本次更新带来了全新的UI升级，全新的开始界面，居中的任务栏，并且在未来，Windows11将作为各大PC平台的预装系统。早在Windows11测试版上线时，宁盾就已进行适配工作，DKEY AM与NDACE产品实现全面兼容Windows11，系统运行流畅，界面美观体验友好，有升级系统版本需求的企业用户将不会受到影响。
宁盾统一身份管理平台DKEY AM 与敏捷终端准入NDACE采用low-code低代码开发，轻客户端，对Windows、Linux、Mac、统信UOS、麒麟等系统高度兼容，让企业不再因终端类型丰富多样而在身份安全管理建设上束手束脚。
宁盾敏捷终端准入控制兼容Windows11
宁盾AM7兼容Windows11
宁盾兼容Windows11特性适用于：多因素认证、有线无线网络认证、统一身份管理和单点登录、网络设备AAA管理、敏捷终端准入、国产目录服务等产品。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3d5055959244d829cafa1b06cf20724/" rel="bookmark">
			宁盾AM7：新一代IAM，应对新技术和信创带来的企业身份管理挑战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以人为中心的身份管理不仅是企业数字化转型基础设施，更是零信任安全的核心支撑点。
在10月11日Gartner最新发布的《2022年IAM规划指南》中指出，安全和身份是业务生态系统的重要基础。企业组织应该创建一个灵活的IAM架构并联动其他功能以满足不断变化的组织需求。在2022年IAM关键趋势中，企业要想跟上不断变化的IAM需求，关键是发展一个更安全、更有弹性、可组合和分布式的IAM基础设施。
图源：Gartner《2022 Planning Guide for Identity and Access Management》
2022年IAM技术规划趋势框架： 随时随地连接网络的计算技术将进一步推动对智能访问控制的需求；提高所有用户的用户体验对于安全数字业务而言至关重要；IGA功能将演变发展，使去中心化的体系结构成为可能；对不同类型的共享密钥、证书及终端需要更多关注；混合云和多云环境将推动现有的IAM架构的维护及变革；新应用和应用程序接口将需要利用最新的IAM开发指南。 聚焦国内，影响中国企业身份与访问管理(IAM)发展的几个因素： 云计算、物联网等新技术的运用；混合云及多云的基础架构；BYOD/IOT等逐渐增多的泛终端接入企业网络；云和SaaS的应用普及等，使企业对于身份安全需求日益迫切；企业对于实施零信任安全框架保持积极态度，而一个强大的身份管理体系是企业实施零信任战略的前提。传统IAM实施周期长，大部分企业缺乏IAM成熟的咨询和实施经验；其次自行研发身份管理面临研发人员流动和换岗带来的运维风险，三是中国企业身份管理面临着与国外迥异的新兴场景，如企微、飞书、钉钉等社交办公软件的广泛应用，国产化趋势、信创体系等新场景，让中国企业对IAM产生更多诉求，敏捷、灵活的IAM产品成为刚需；移动办公对于身份认证体验及去中心化自服务能力要求提升，传统中心化IAM无法适应；《网络安全法》《信息安全技术网络安全等级保护要求》(简称等保2.0)等法律法规陆续出台，实战攻防演练常规化，企业遭遇的网络攻击中超25%为弱口令攻击……企业身份安全管理形势严峻；信创国产化，国产身份目录加快进程。 在此背景下，宁盾推出新一代IAM解决方案——宁盾AM7，以全场景、标准化为特性，帮助企业应对混合云及多云架构、移动办公场景、物联网技术、国产化信创带来的身份安全管理挑战。
宁盾AM7标准化体现在支持的场景丰富且对接灵活，以减少企业身份标准建设过程中的开发投入。操作界面更友好，方便企业IT人员快速上手。宁盾AM7全场景、标准化的优势体现在以下四个方面：
降低企业实施IAM的门槛，缩短交付周期，纳管更多场景，节省安全投入成本；自服务功能，减轻运维人员工作量；解决国产化操作系统、服务器等适配问题；优化操作流程，提升用户体验。 宁盾AM7产品能力框架 宁盾AM7旨在解决企业用户身份、终端、应用的管理和安全问题。在Windows时代，微软分别通过AD、组策略、ADFS分别将人、端、应用资源收集到Windows Server上统一管理。随着手机(BYOD)、Mac、Linux等设备在企业应用日趋广泛，Windows Server/AD尚未把非微软产品纳入管理。宁盾AM7弥补和延展AD在新场景新技术下的不足，以满足目前的身份管理需求。
AM7主要包含三个核心能力：
能力1：身份与访问管理IAM 应用单点登录动态密码/MFA密码自服务SaaS调用企业身份 能力2：网络准入管理NAC 网络接入和认证资产发现和安全评估准入控制 能力3：国产目录服务NDS 身份源账号的生命周期管理国产操作系统UOS、麒麟加域管理企业微信、飞书、钉钉的账号同步AD/LDAP兼容 宁盾AM7客户定位
高增长创新型企业： 这类企业面临的身份管理问题：
云上业务系统众多，各系统无统一用户源，账号、密码混乱，每个业务系统要单独维护管理账号生命周期。业务系统需要公网访问，既要确保账号登录安全，又要保证统一登录入口。身份系统选型，若用AD则会面临移动化扩展问题，而采用其他产品对现在和将来的业务场景兼容性如何未知。 过去，创新型企业，尤以科技或信息技术类公司为代表，身份管理建设的经验和准备不足。身份管理建设以免费开源的OpenDJ或OpenLDAP为主，其他场景则用开源系统独立开发，如用Google Authenticator作为MFA，用CAS开发单点登录功能。独立研发工作量巨大且伴随着极高的运维代价，人员流动，专业运维人员缺乏导致后续运维不善。身份管理未经完善规划，企业快速成长时被身份掣肘。
宁盾AM7为高增长创新型企业提供All In One的解决方案，为企业搭建统一身份平台，管理业务系统的身份，确保账号、密码、生命周期和权限的一致性。通过SSO统一业务系统入口，在SSO上实现多因素身份认证，提高系统访问安全性，并兼容AD协议和数据结构。云和本地身份统一管理，帮助企业节约管理成本，防止企业快速成长时被身份管理拖后腿。
中大型企业： 中大型企业通常部署了微软AD，而AD在口令安全、泛终端准入等场景面临能力不足等问题：
AD口令安全，AD缺乏MFA能力；企业提出AD范围外的需求，如单点登录、账号自动管理、社交应用身份整合、自服务等；AD支持LDAP协议，许多新型应用采用SAML2.0、OIDC、OAuth2等协议，AD无法支持，因此这些新型应用以及SaaS微软AD无法很好兼容；AD无法很好对Mac/Linux终端、BYOD/IoT等泛终端做认证准入；快捷认证：借助于微信、钉钉、飞书的无密码认证等。 中大型企业采用AD解决身份管理问题，但国产化趋势、新技术与社交应用的普及，客户和服务商需要自行开发或寻找第三方补全AD能力。宁盾AM7通过MFA和准入补充边界安全，延展AD在移动化、云计算等新技术下的能力，让AD更好用。
信创客户： 国产操作系统覆盖的企业，如政府单位、金融、央企、国企，它们在身份管理上面临着：
身份：员工身份信息保存在AD，并基于AD域身份登录终端设备；应用：基于AD域身份信息登录企业业务系统；端：合规终端需要加入AD域；AD部署在Windows Server上，终端、服务器将由麒麟、统信等国产操作系统替换，企业无法继续使用AD，那么企业对身份、应用、端的管理将如何？ 宁盾AM7内置国产身份目录服务，可兼容AD数据结构和协议，大部分应用可沿用AD的对接方式，不产生改造代价。提供从AD迁移数据的工具集，保障平滑过渡。增强安全合规能力，如单点登录、基于国密算法的多因素认证。统一的终端管理能力：基于国产目录的登录认证、终端合规准入等。
宁盾AM7作为全场景、标准化的企业身份管理基础设施，为创新型科技企业新建IAM体系，轻开发、轻运维，一站式解决身份安全管理问题。为中大型企业/AD用户延展AD在新技术场景下的能力，让AD更好用。为信创客户，如政府单位国产操作系统提供统一登录管理，兼容微软AD，无缝衔接业务系统，并对终端进行合规检测与准入控制。
宁盾AM7，新一代敏捷的身份识别与访问管理基础设施，致力于成为企业数字化转型，迈向零信任安全的助力者。
更多AM7产品能力干货解读请搜索宁盾微信公众号(微信号：ningdun)获取，或访问www.nington.com了解更多内容，也可添加宁盾市场渠道合作微信号nington_marketing联系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4948b93dde8c4abc0f8cec3cd1f9162d/" rel="bookmark">
			宁盾荣获“2021年度临港园区潜力之星”称号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		10月28日，2021年度临港集团创新发展大会在临港新片区创晶科技中心举办，大会展示了2021年临港集团科创服务体系建设成果，并发布临港园区企业的科创成果和园区科创生态的建设成果。
市国资委二级巡视员邵珉、市经济信息化委二级巡视员蒋玮，临港集团党委书记、董事长袁国华，党委副书记、总裁吕鸣，党委委员、副总裁刘伟等领导出席大会。临港集团职能部门领导，临港园区的科创之星企业、科创功能型平台、科创服务星级合作机构代表及解放日报、文汇报等媒体机构约350人参加大会。大会对于完善全市国资国企创新发展的布局，助力新片区的建设发展和促进全市经济高质量发展，显示了重要的引领示范意义。
临港集团副总经济师翁巍介绍，过去一年，临港集团全面推进科创服务体系建设，提升集团自身创新发展的能力和服务产业创新发展的能力，取得了一系列的成效和荣誉。在产业推进方面，集团园区范围内新增4家、累计10家园区获批市级特色产业园区，同比增长66.7%，占全市总数25%；新增2家、累计8家园区获批市级以上知识产权园区资质，同比增长33.3%；新增3家，累计31家获批市级以上孵化载体资质，同比增长24%；漕河泾创业中心创新实践案例“知识产权科技金融孪生服务”荣获第二届“企业创新实践大奖”。
作为本次大会的重头戏之一，2021年度“临港园区潜力之星”榜单正式发布，评选聚焦重点产业领域，经园区推荐上报、内部形式审查、外部专家评审等程序，评选出124家成长速度快、发展潜力大、具备硬核科技能力、市场认可度高，代表临港科创实力和科创潜力的优质科创企业。
宁盾自2009年成立以来，始终深耕“身份安全”领域。为给中国企业打造更加安全好用的身份安全管理体系，宁盾研发投入占比逐年递增。凭借不断创新的技术实力与不断完善的产品体系，企业客户的支持信赖，宁盾获评“2021年度临港园区潜力之星”。
宁盾以“全场景、标准化身份管理体系，普及下一代’人+端’身份安全”为使命，致力于成为云和移动时代企业身份安全管理基础设施。宁盾相信，在国家政策、园区扶持下，宁盾将守正创新，行稳致远！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86949c9f78746668a277065338712241/" rel="bookmark">
			【基于pyAudioKits的Python音频信号处理（七）】端点检测和语音识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pyAudioKits是基于librosa和其他库的强大Python音频工作流支持。
API速查手册
通过pip安装：
pip install pyAudioKits 本项目的GitHub地址，如果这个项目帮助到了你，请为它点上一颗star，谢谢你的支持！如果你在使用过程中有任何问题，请在评论区留言或在GitHub上提issue，我将持续对该项目进行维护。
import pyAudioKits.audio as ak import numpy as np import pyAudioKits.analyse as aly 在介绍完通用音频后，本节进一步开始对语音信号进行研究。通用音频的理论和分析方法均适用于语音信号，而语音信号又有更多进一步的属性和分析方法，以及一些特有的任务。本节将主要对语音的端点检测和语音的特征提取和识别用pyAudioKits的实现方法进行演示。其中端点检测使用双门限法，而特征提取和识别使用MFCC+DTW方法。
语音构成 语音信号由三种成分构成。
浊音：具有周期性或准周期性，其频率被称为基频（ F 0 F_0 F0​）或音调。近似乐音。
F 0 F_0 F0​ avg (Hz) F 0 F_0 F0​ min (Hz) F 0 F_0 F0​ max (Hz)男性12580200女性225150350儿童300200500 清音：没有周期性，没有固定的音高。近似噪音。
静音：依然存在背景噪音。
这里的三种成分在时间上互斥，而并非是叠加的，因此语音信号可以按时间顺序进行切分，并归类到上述三种类别中。
语音的建模 语音是通过上节提到过的线性时不变系统产生的，即 Y ( z ) = H ( z ) X ( z ) Y(z)=H(z)X(z) Y(z)=H(z)X(z)，其中 y y y是生成的语音， x x x是产生语音所需的激励，而 h h h则是我们的声道和嘴唇形成的系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86949c9f78746668a277065338712241/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/195e54954f17595339f64598369a202b/" rel="bookmark">
			树莓派4B安装pytorch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前一篇博客介绍了树莓派上tensorflow的配置，这里再配置下pytorch，主要还是通过已经编译好的whl来安装，其实我们平时直接pip install安装也是先从权威源网站上下载别人编译好的针对某种平台的安装包来安装的。如果需要源码安装，可以参考博主的其它博客（通过交叉编译来在树莓派上来配置，当然这里是其它的库）
Ubuntu下交叉编译OpenCV(WITH_QT）_竹叶青lvye的博客-CSDN博客_ubuntu交叉编译opencv
如下一篇是博主在windows x64平台上源码编译的tensorflow,方法可供借鉴。
win7下VS2015编译tensorflow源码教程（在线和离线）及调用配置_竹叶青lvye的博客-CSDN博客_vs编译教程
后续有精力，博主会来源码交叉编译安装下tensorflow及pytorch（直接在树莓派上编译花费太多时间，可以在别的平台上交叉编译好，然后将生成的库拷贝到site-packages文件夹下）。
1.配置好python环境
这里选择python3.7版本，树莓派上安装python3.7可参考博主之前博客
树莓派4B上多版本python切换（一）_竹叶青lvye的博客-CSDN博客_树莓派修改python版本
注意，如下此处安装和上面帖子不一样，之前编译静态库的命令语句如下：
这里需要编译动态库，所以命令语句，suo ./configure --prefix=/home/pi/python3.7应改为
sudo ./configure --prefix=/home/pi/python3.7 --enable-shared 其它两条命令还是同前。
完毕后，记得在.~/.bashrc中添加下环境变量
export LD_LIBRARY_PATH=/home/pi/python3.7/lib${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} 记得编辑好后执行下命令语句：source ~/.bashrc
同时注意，cd到编译获得的python3.7/lib目录下，执行下命令语句：
sudo cp -r libpython3.7m.so.1.0 /usr/lib 不然执行一些安装命令时，会出现报错：
After this operation, 1,861 kB of additional disk space will be used.
/usr/bin/python3: error while loading shared libraries: libpython3.7m.so.1.0: cannot open shared object file: No such file or directory
E: Sub-process /usr/bin/apt-listchanges --apt || test $? -lt 10 returned an error code (1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/195e54954f17595339f64598369a202b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4933790c857c5fa2685f928dccb0d1b4/" rel="bookmark">
			基于Python实现的手写数字图像识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
实验目的及实验内容 1
实验目的： 1
实验内容： 1
原理分析： 1
实验环境 13
实验步骤及实验过程分析 13
实验结果总结 18
实验目的及实验内容
（本次实验所涉及并要求掌握的知识；实验内容；必要的原理分析）
实验目的：
使用 python 进行图像处理
实验内容：
自己找一张图片，用 OpenCV 的仿射变换实现图片缩放。
理解 HOG、ORC 过程，修改 digits.py 或独立编程，实现数字图像的识别，要求分别使用 SVM、knn（第六次课）以及 cnn 神经网络模型（第七次课），以群文件中 digit_data.rar 中 train 文件夹下数据作为训练集，test 文件夹下图片作为测试集，并计算测试集上分类正确率，本文转载自http://www.biyezuopin.vip/onews.asp?id=16706并自己找测试数据（可以是一个或多个数字）。
实验环境
（本次实验所使用的器件、仪器设备等的情况）
处理器：Intel® Core™ i5-9300H CPU @ 2.40GHz 2.40 GHz (2)操作系统环境：Windows 10 家庭中文版 x64 19042.867
编程语言：Python 3.8
其他环境：16 GB 运行内存
IDE 及包管理器：JetBrains PyCharm 2020.1 x64， anaconda 3 for Windows（conda 4.9.0）
实验步骤及实验过程分析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4933790c857c5fa2685f928dccb0d1b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e397f65e36dcac39feb0f9306bcfca9/" rel="bookmark">
			2022科大讯飞商品销量智能预测挑战赛—参赛总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022科大讯飞商品销量智能预测挑战赛—参赛总结 目录 2022科大讯飞商品销量智能预测挑战赛—参赛总结摘要赛题任务特征构建训练方案模型融合赛题得分 写在最后 摘要 比赛网址：https://challenge.xfyun.cn/topic/info?type=product-sales赛题任务：本次大赛提供了商品销量历史数据作为训练样本，参赛选手需基于提供的样本构建模型，预测商品未来三个月的销售量。初赛提供了2018年2月1日至2020年12月31日的若干商品历史销量数据和订单数据，预测其2021年1月至3月的销量数据。决赛提供了2018年2月1日至2021年3月31日的若干商品历史销量数据和订单数据，预测其2021年4月至6月的销量数据。相当于复赛时提供了初赛测试集的标签，这一点在复赛时可以利用起来，能够节省不少提交次数。而且赛后也可以继续研究。数据分析：提供的数据集的销量是细分到每一天的，但预测是要细分到月份的，因此，可以有两种角度去预测销量。第一是按天进行预测，但是有些特征是没有提供细分到天的数据的，特征相对按月预测会少一点；第二种是按月预测，这就需要先将销量按月汇总起来构建标签。最后我是选择了第二种。特征构建：主要用到了lag和rolling聚合的mean、std、median特征。模型选择：采用比赛常用模型：lightgbm、xgboost和catboost分别构建回归模型，最后并用TPE搜索最优参数组合。训练方案：每个模型均使用5折交叉验证，以product_id均衡划分训练集和验证集，对测试集的预测值取平均即得到该模型最终的预测值。模型融合：对三个5折交叉验证后的模型结果，采用stacking进行模型融合。赛题得分：初赛最终成绩：0.70854分，排名：第71名；复赛最终成绩：0.74399分，排名：第46名。总结结论：这是我参加比赛以来第二次进入复赛阶段的比赛，很有纪念意义，虽然跟前排大佬还有很大的差距，但是从中也学习到了很多知识，有机会下次再来~ 赛题任务 特征构建 并没有构建过多的特征，因为我发现即使构建更多的lag或者rolling特征，也不会有提升，甚至是降分的。期间有通过根据特征重要性、shap、与标签的相关性来筛选特征，但筛选后的效果也不是很好。一直都没有找到比较强的特征。下面是部分代码：
feats_cols=[] for i in range(1, 17): for f in ['label', 'order', 'start_stock', 'end_stock']: data[f+'_shift_%d'%i] = data.groupby('product_id')[f].shift(i+2) if i &lt;= 12: feats_cols.append(f+'_shift_%d'%i) for i in [3, 6, 12]: for f in ['label', 'order', 'start_stock', 'end_stock']: data[f+'_mean_%d'%i] = data[[f+'_shift_%d'%i for i in range(1, i+1)]].mean(axis=1) data[f+'_std_%d'%i] = data[[f+'_shift_%d'%i for i in range(1, i+1)]].std(axis=1) data[f+'_median_%d'%i] = data[[f+'_shift_%d'%i for i in range(1, i+1)]].median(axis=1) feats_cols.extend([f+'_mean_%d'%i,f+'_std_%d'%i,f+'_median_%d'%i]) 训练方案 使用StratifiedKFold按product_id均衡划分训练集和验证集进行5折交叉验证，期间对比过使用KFold来划分，实验验证StratifiedKFold要更胜一筹，分别训练lightgbm、xgboost和catboost三个模型。训练代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e397f65e36dcac39feb0f9306bcfca9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/659bb06ef4e661153e166f475d0ecc29/" rel="bookmark">
			pytorch的安装--测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		---------------------------------------------测试是否成功---------------------------------------
python测试程序：
import torch
#返回当前设备索引
# torch.cuda.current_device()
#返回GPU的数量
# torch.cuda.device_count()
#返回gpu名字，设备索引默认从0开始
# torch.cuda.get_device_name(0)
#cuda是否可用
# torch.cuda.is_available()
# 查看pytorch 版本
# print(torch.__version__)
# 查看pytorch对应的cuda 版本
# print(torch.version.cuda)
# 判断pytorch是否支持GPU加速
# print (torch.cuda.is_available())
# 使用的是GPU的，会输出：cuda:0
# 使用的不是GPU的，会输出：cpu
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
print(device)
上述结果为cuda:0表示pytorch安装成功
至此pytorch安装完毕，比较新的机器的话，安装会比较顺利，安装完毕后即可正常使用
备注：有些时候虽然测试成功，但在实际使用时会提示GPU太老，并且申请内存失败
针对老旧GPU想顺利使用的话，请使用之前安装中查询到的最低版本进行安装。
但是上述都不行的话，劝你放弃，买个新机器吧。
还不想放弃的话，只有下面一条路可行：即源码安装 耗时耗力，问题千奇百怪。很可能几天出去了。
pytorch的安装--源码_huoshi191的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40ba507765a985b7b854e88e4ec92c4a/" rel="bookmark">
			pytorch的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在开头：
近期开始在老机器上折腾pytorch，想看下训练的效果。因为机器较老，走了很多弯路。在此记录下各种安装方式，包括命令和源码的安装，同时附录相关资源地址、和问题讨论，希望能提供点帮助。
1、我使用的是2012年的笔记本进行安装，算力只有3.0，将大部分安装方式都试了，分享一下。
2、建议将GPU和pytorch部分分开折腾，因为有的pytorch安装指令不包含gpu相关部分。
3、源文件、源代码、相关资料、问题解决方法建议从官方获取，文章所附地址均为官方途径。
GPU 相关安装_huoshi191的博客-CSDN博客
pytorch的安装--命令_huoshi191的博客-CSDN博客
pytorch的安装--测试_huoshi191的博客-CSDN博客
pytorch的安装--源码_huoshi191的博客-CSDN博客
torchvison的安装--源码_huoshi191的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f08862327f3f98756e4d651b3b7335d/" rel="bookmark">
			MySQL JDBC编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
本文介绍的JDBC，即Java Database Connectivity，java数据库连接。是一种用于执行SQL语句的Java API，它是Java中的数据库连接规范。这个API由 java.sql.,javax.sql. 包中的一些类和接口组成，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。
??博客主页： ??【】??
??精品Java专栏【JavaSE】、【备战蓝桥】[、【JavaEE初阶】](https://blog.csdn.net/qq_60856在这里插入图片描述
948/category_11797340.html)、【MySQL】、【数据结构】
??欢迎点赞 ?? 收藏 留言评论 ??私信必回哟??
??本文由 【】 原创，首发于 CSDN??
??博主将持续更新学习记录收获，友友们有任何问题可以在评论区留言
??博客中涉及源码及博主日常练习代码均已上传码云(gitee)、GitHub
??内容导读?? MySQL JDBC编程 ??1.准备工作 1.1 下载驱动包1.2 导包 ??2.使用步骤 2.1 创建数据源连接Connection2.2 构造SQL语句2.3 执行SQL2.3 关闭释放资源 ??3.开发案例 3.1 insert示例（插入示例）3.2 delete示例（删除示例）3.3 update示例（修改示例）3.4 select示例（查找示例）3.5 实际开发示例 MySQL JDBC编程 ??1.准备工作 1.1 下载驱动包 下载链接：maven中央仓库
第一步，点进网址进入maven中央仓库。
第二步，搜索MySQL，选择如下图大红框内位置。
第三步，根据自己的MySQL版本下载对应系列的jar包（大版本匹配即可，比如我的是5.7那么下载5系列的都可以）
第四步，点击下载即可
下载好以后放在自己可以找到的地方，然后开始导包。
1.2 导包 在完成一个项目需要使用到JDBC技术时，需要先在项目中完成jar包的导入，才能获取到各种数据库统一适配的接口，进一步完成JDBC编程。
第一步，在src的同级目录下创建目录（文件名自定，此处我用的是lib，用于存放jar包）
第二步，将第一步已经下载好的jar包复制，然后粘贴到创建的目录下
第三步，Add as Library
至此，我们就已经完成了JDBC编程的所有准备工作。
??2.使用步骤 2.1 创建数据源连接Connection 一种是利用DataSource(数据源对象获取)
//先获取数据源
DataSource dataSource = new MysqlDataSource();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f08862327f3f98756e4d651b3b7335d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a36c22cd9170797f702fd29e727fefa/" rel="bookmark">
			和微信大佬聊了一夜，他告诉我为什么指针被誉为 C 语言灵魂？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“五分钟学算法”，选择“星标”公众号
重磅干货，第一时间送达
是的，这一篇的文章主题是「指针与内存模型」
说到指针，就不可能脱离开内存，学会指针的人分为两种，一种是不了解内存模型，另外一种则是了解。
不了解的对指针的理解就停留在“指针就是变量的地址”这句话，会比较害怕使用指针，特别是各种高级操作。
而了解内存模型的则可以把指针用得炉火纯青，各种 byte 随意操作，让人直呼 666。
这篇看完，相信你会对指针有一个新的认识，坐等打脸????
一、内存本质 编程的本质其实就是操控数据，数据存放在内存中。
因此，如果能更好地理解内存的模型，以及 C 如何管理内存，就能对程序的工作原理洞若观火，从而使编程能力更上一层楼。
大家真的别认为这是空话，我大一整年都不敢用 C 写上千行的程序也很抗拒写 C。
因为一旦上千行，经常出现各种莫名其妙的内存错误，一不小心就发生了 coredump...... 而且还无从排查，分析不出原因。
相比之下，那时候最喜欢 Java，在 Java 里随便怎么写都不会发生类似的异常，顶多偶尔来个 NullPointerException，也是比较好排查的。
直到后来对内存和指针有了更加深刻的认识，才慢慢会用 C 写上千行的项目，也很少会再有内存问题了。(过于自信
「指针存储的是变量的内存地址」这句话应该任何讲 C 语言的书都会提到吧。
所以，要想彻底理解指针，首先要理解 C 语言中变量的存储本质，也就是内存。
1.1 内存编址 计算机的内存是一块用于存储数据的空间，由一系列连续的存储单元组成，就像下面这样，
每一个单元格都表示 1 个 Bit，一个 bit 在 EE 专业的同学看来就是高低电位，而在 CS 同学看来就是 0、1 两种状态。
由于 1 个 bit 只能表示两个状态，所以大佬们规定 8个 bit 为一组，命名为 byte。
并且将 byte 作为内存寻址的最小单元，也就是给每个 byte 一个编号，这个编号就叫内存的地址。
这就相当于，我们给小区里的每个单元、每个住户都分配一个门牌号： 301、302、403、404、501......
在生活中，我们需要保证门牌号唯一，这样就能通过门牌号很精准的定位到一家人。
同样，在计算机中，我们也要保证给每一个 byte 的编号都是唯一的，这样才能够保证每个编号都能访问到唯一确定的 byte。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a36c22cd9170797f702fd29e727fefa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce6e88102a189077298e536fb1e29a1e/" rel="bookmark">
			阿里面试，让我十五分钟内手写 LRU。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“五分钟学算法”，选择“星标”公众号
重磅干货，第一时间送达
你面试的时候遇见过LRU吗？ LRU 算法，全称是Least Recently Used。
翻译过来就是最近最少使用算法。
这个算法的思想就是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。所以，当指定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。
听描述你也知道了，它是一种淘汰算法。
这个算法也是面试的一个高频考点。
有的面试官甚至要求手撸一个 LRU 算法出来。
其实我觉得吧，遇到这种情况也不要慌，你就按照自己的思路写一个出来就行。
赌一把，面试官也许自己短时间内都手撸不出来一个无 bug 的 LRU。他也只是检查几个关键点、看看你的代码风格、观察一下你的解题思路而已。
但其实大多数情况下面试场景都是这样的：
面试官：你知道 LRU 算法吗？
我：知道，翻译过来就是最近最少使用算法。其思想是(前面说过，就不复述了)......
面试官：那你能给我谈谈你有哪些方法来实现 LRU 算法呢？
这个时候问的是什么？
问的是：我们都知道这个算法的思路了，请你按照这个思路给出一个可以落地的解决方案。
不用徒手撸一个。
方案一：数组 如果之前完全没有接触过 LRU 算法，仅仅知道其思路。
第一次听就要求你给一个实现方案，那么数组的方案应该是最容易想到的。
假设我们有一个定长数组。数组中的元素都有一个标记。这个标记可以是时间戳，也可以是一个自增的数字。
我这里用自增的数字。
每放入一个元素，就把数组中已经存在的数据的标记更新一下，进行自增。当数组满了后，就将数字最大的元素删除掉。
每访问一个元素，就将被访问的元素的数字置为 0 。
这不就是 LRU 算法的一个实现方案吗？
按照这个思路，撸一份七七八八的代码出来，问题应该不大吧？
但是这一种方案的弊端也是很明显：需要不停地维护数组中元素的标记。
那么你觉得它的时间复杂度是多少？
是的，每次操作都伴随着一次遍历数组修改标记的操作，所以时间复杂度是 O(n)。
但是这个方案，面试官肯定是不会满意的。因为，这不是他心中的标准答案。
也许他都没想过：你还能给出这种方案呢？
但是它不会说出来，只会轻轻的说一句：还有其他的方案吗？
方案二：链表 于是你扣着脑壳想了想。最近最少使用，感觉是需要一个有序的结构。
我每插入一个元素的时候，就追加在数组的末尾。
等等。
我每访问一个元素，也要把被访问的元素移动到数组的末尾。
这样最近被用的一定是在最后面的，头部的就是最近最少使用的。
当指定长度被用完了之后，就把头部元素移除掉就行了。
这是个什么结构？
这不就是个链表吗？
维护一个有序单链表，越靠近链表头部的结点是越早之前访问的。
当有一个新的数据被访问时，我们从链表头部开始顺序遍历链表。
如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据的对应结点，并将其从原来的位置删除，并插入到链表尾部。
如果此数据没在缓存链表中，怎么办？
分两种情况：
如果此时缓存未满，可直接在链表尾部插入新节点存储此数据；
如果此时缓存已满，则删除链表头部节点，再在链表尾部插入新节点。
你看，这不又是 LRU 算法的一个实现方案吗？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce6e88102a189077298e536fb1e29a1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f17abc4703a3df2cdfa1d9aff2c4ce6b/" rel="bookmark">
			Prometheus TSDB (Part 3): Memory Mapping of Head Chunks from Disk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据采集 最前面 ​ 数据采集(scrape)是prometheus的核心服务。它有两种采集方式:pull和push，这里着重分析pull模式，push模式请看文档。
​ 简易流程
代码目录 - scrape - testdata	// 测试数据 - manager.go	// scrape管理器，负责主要业务逻辑 - scrape.go	// 数据采集，实现具体的采集方法 - target.go	// 采集目标 关键概念 scrapePool
​ scrapePool是target集合的采集管理器,每一个scrapePool都负责管理一组targetsGroup。每一个scrapePool都会运行单独的数据采集服务sp.Sync(groups)。当Discovery模块有更新数据时，通过discoveryManagerScrape.SyncCh()将数据传入scrapeManager，执行reload（）方法更新scrapePool。
type scrapePool struct { appendable Appendable // 数据存储的上层抽象 logger log.Logger mtx sync.RWMutex config *config.ScrapeConfig client *http.Client	// http客户端 activeTargets map[uint64]*Target // 活动中的target droppedTargets []*Target // 已废弃的target loops map[uint64]loop // 启动器，实现loop接口，负责启动当前pool进行数据采集 cancel context.CancelFunc // 上下文取消事件 // loops构造器 newLoop func(scrapeLoopOptions) loop } scrapeLoop
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f17abc4703a3df2cdfa1d9aff2c4ce6b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/208/">«</a>
	<span class="pagination__item pagination__item--current">209/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/210/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>