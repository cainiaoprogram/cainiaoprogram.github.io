<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d45b709b8f1d03f31fbac529129625f/" rel="bookmark">
			主成分分析法及spss实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述 主成分分析（Principal Component Analysis，PCA）是一种降维算法，它能将多个指标转换为少数几个主成分，这些主成分是原始变量的线性组合，且彼此之间互不相关，其能反映出原始数据的大部分信息。一般来说，当研究的问题涉及到多变量且变量之间存在很强的相关性时，我们可考虑使用主成分分析的方法来对数据进行简化。
降维是将高维度的数据（指标太多）保留下最重要的一些特征，去除噪声和不重要的特征，从而实现提升数据处理速度的目的。在实际的生产和应用中，降维在一定的信息损失范围内，可以为我们节省大量的时间和成本。降维也成为应用非常广泛的数据预处理方法。
降维具有如下一些优点：
1）.使得数据集更易使用；
2）.降低算法的计算开销；
3）.去除噪声；
4）.使得结果容易理解
2.主成分分析原理及计算步骤 2.1主成分分析原理 假设有n个样本，m个指标，则可以构成大小为n*m的样本矩阵X：
假设我们相找到新的一组变量y1,y2…yp(p&lt;=m)，且他们满足
系数lij的确定原则：
（1）yi和yj（i≠j;i,j=1,2,…,p）相互无关；
（2）y1是的一切线性组合中方差最大者；
（3）y2是与y1不相关的的一切线性组合中方差最大者；
（4）依次类推，yp是与y1,y2,…yp-1不相关的的一切线性组合中方差最大者；
新变量指标y1,y2,…yp称为的主成分。
2.2 主成分分析计算步骤
假设有n个样本，m个指标，则可以构成大小为n*m的样本矩阵X：
（1）数据标准化处理
其中，为原始X矩阵平均值，为原始X矩阵标准差，为标准化处理后元素。
（2）计算标准化样本的协方差矩阵：
（3）计算R的特征值和特征向量：
计算得出特征值λ1，λ2…λm，特征向量a1,a2…am
特征值计算链接：https://blog.csdn.net/weixin_42260102/article/details/102896371
（4）计算主成分贡献率以及累计贡献率：
（5）写出主成分
一般取累计贡献率超过80%的特征值所对应的第一、第二、…、第m(m≤p)个主成分。第i个主成分:F=a1X1+a2X2…·十aiXi，(i=1,2,·,m)
3.SPSS实现 （1）数据收集：数据来源于国家统计局官网
（2）数据预处理：填补或去除缺项，并进行标准化处理。
（3）导入SPSS：进入SPSS，打开相关数据文件
（4）主成分分析：选择“分析”|“降维”|“因子”命令。选择进行因子分析的变量。在“因子分析”对话框的左侧列表框中，依次选择需要进行主成分分析的变量进入“变量”列表框。并选择想要输出的一系列参数，保存，点击【确定】。
（5）分析结果展示：成分矩阵下表为成分矩阵，表明各个成分在各个变量上的载荷，从而可以得出各主成分的表达式。输出参数为各原变量系数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c98cee676d5bea958dee2faa62d1a55/" rel="bookmark">
			minikube 试炼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点我进入 minikube 试炼
今天我们先来尝试使用一下 minikube ，可以进入到 https://kubernetes.io/zh/docs/tutorials/hello-minikube/ 页面上直接感受，或者通过如下指令，将 minikube 放入我们的服务器上面进行使用
简单安装 minikube Linux 的
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 sudo install minikube-linux-amd64 /usr/local/bin/minikube
windows 的
New-Item -Path 'c:\' -Name 'minikube' -ItemType Directory -Force Invoke-WebRequest -OutFile 'c:\minikube\minikube.exe' -Uri 'https://github.com/kubernetes/minikube/releases/latest/download/minikube-windows-amd64.exe' -UseBasicParsing
例如
运行我们的集群 minikube start 启动集群
minikube pause 在不影响部署的应用程序的情况下暂停 Kubernete
$ minikube pause * Pausing node m01 ... * Paused 20 containers in: kube-system, kubernetes-dashboard, storage-gluster, istio-operator 此时 minikube 已经暂停了，我们查看 pod 列表是查看不了的
minikube unpause 取消暂停的实例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c98cee676d5bea958dee2faa62d1a55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c664a2bdae6f82f7d68fff7591e64a49/" rel="bookmark">
			零点工作室暑假集训（Educational Codeforces Round 151 (Rated for Div. 2)）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前只看懂了A题 A. Forbidden Integer 题意：给点 n, k，x用 1 ~ k 中除了 x 以外的任意数字，且每个数字可以使用任意次，去拼成 n 。
思路：分类讨论：
如果除去x以后没有数字了，即可使用的数字为 0 ，则一定为NO 。如果除去x以后有数字： 只有一个数字：只要这个数字是n的约数即可。至少两个数字：那么我们只考虑前两个数字，其可能的情况有三种，分别是：“1，2”，“1，3”，“2，3”，前两张情况因为有 1 ，所以直接用 n 个 1 即可，最后一种情况，“2，3”可以组成 ​ 的任意数字，但如果 n 为 1 怎么办？因为题目数据范围说了： k ≤ n ​，即 ​k 都已经至少为 3​ 了，所以 n​ 不可能为 ​1AC代码： #include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; pii;
int main()
{
{
int n,k,x;
cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;
vector&lt;int&gt; v;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c664a2bdae6f82f7d68fff7591e64a49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b877b5d7bd28bb564e3a179bb37a5f04/" rel="bookmark">
			C&#43;&#43;第一节课堂内容：初识C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++历史： C++是什么？ C++是一种面向对象的高级程序设计语言，是C语言的超集。C++是C语言的继承，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。
C++的技术应用： 1、科学计算
在科学计算领域，FORTRAN是使用最多的语言之一。但是C++凭借先进的数值计算库、泛型编程等优势在这一领域也应用颇多。
2、网络软件
C++拥有很多成熟的用于网络通信的库，其中最具有代表性的是跨平台的、重量级的ACE库，该库可以说是C++语言最重要的成果之一，在许多重要的企业、部门甚至是军方都有应用。
3、操作系统
在该领域，C语言是主要使用的编程语言。但是C++凭借其对C的兼容性，面向对象性质也开始在该领域有一席之地。
特点 与C语言的兼容性：
C++与C语言完全兼容，C语言的绝大部分内容可以直接用于C++的程序设计，用C语言编写的程序可以不加修改地用于C++。
数据封装和数据隐藏：
在C++中，类是支持数据封装的工具，对象则是数据封装的实现。C++通过建立用户定义类支持数据封装和数据隐藏。
支持继承和重用：
在C++现有类的基础上可以声明新类型，这就是继承和重用的思想。通过继承和重用可以更有效地组织程序结构，明确类间关系，并且充分利用已有的类来完成更复杂、深入的开发。
多态性：
采用多态性为每个类指定表现行为。多态性形成由父类和它们的子类组成的一个树型结构。在这个树中的每个子类可以接收一个或多个具有相同名字的消息。
电脑重要组成： CPU： CPU也叫做中央处理器，是一台计算机的运算核心和控制核心。是计算机内的电子电路，通过执行指定的基本算术、逻辑、控制和输入、输出操作来执行计算机程序的指令。简单来说，CPU相当于电脑的大脑(和我们人类大脑功能大部分一致)
内存： 它用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。（可以理解为记忆）
输入设备： 向我们计算机输入设备，与我们计算机通话
输出设备： 计算机将输出的内容展示给我们，等于计算机与我们沟通交流
什么是编程？ 编程这两个字拆分开，就是为 编写 程序
编写什么？ 编写 计算机语言的代码
程序是什么？ 程序就是为了解决我们现实生活中的某个问题。举个例子，三十年前人们如何沟通交流？
通过书信的方式，此方式效率低且传输的内容有限。那么后来就通过程序员编写代码，那些代码融合在一起就是一个程序。诞生了我们的微信,QQ。解决了我们沟通难的问题
又比如淘宝解决了什么问题?购物难
所以程序作用就是为了解决我们现实生活中的某个问题
第一个C++程序： include iostream中io代表 i in 输入 o out 输出。这句话意思就是让c++开启我们输入的信息与输出信息的权限。
using namespace std; std可以看成是一个百宝箱，具体是什么以后课程会介绍
main方法 程序开始的地方
return 程序结束的地方
cout 可以理解为输出在屏幕上需要用到的一个单词。我们将其称之为输出语句
"内容" 双引号里就是要输出在屏幕的内容
endl 是两个单词的缩写版 分别是 end 结束 line 行 意为：结束并换行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b877b5d7bd28bb564e3a179bb37a5f04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e487d6a9672c943a95b79de1ec81c2a/" rel="bookmark">
			go 进阶 go-zero相关: 二. 服务启动与路由,中间件注册,请求接收底层原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. 问题概述二. 底层源码分析涉及到的一些结构体简介初始化中间件的预设置路由注册与中间件的处理启动服务到触发net/http接收请求的处理 三. 总结 一. 问题概述 了解go-zero底层也是基于net/http标准库实现http的,是怎么实现的,怎么触发到net/http的go-zero也是基于前缀树进行路由注册的,是怎么注册的,注册过程中有哪些注意点go-zero中支持中间件, 在服务启动时,中间件,路由是如何保存的,接收请求时是如何执行的先看一下基础go-zero服务示例 package main import ( "fmt" "github.com/zeromicro/go-zero/rest/chain" "github.com/zeromicro/go-zero/rest/httpx" "github.com/zeromicro/go-zero/core/logx" "github.com/zeromicro/go-zero/core/service" "github.com/zeromicro/go-zero/rest" "log" "net/http" ) func main() { //1.创建服务句柄 //此处也可以替换为通过conf/MustLoad()加载yaml,通过rest/MustNewServer()创建服务 srv, err := rest.NewServer(rest.RestConf{ Port: 8080, // 侦听端口 ServiceConf: service.ServiceConf{ Log: logx.LogConf{Path: "./logs"}, // 日志路径 }, }) if err != nil { log.Fatal(err) } defer srv.Stop() //2.使用server上的Use()方法添加全局中间件 srv.Use(func(next http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { // 在请求处理前执行一些逻辑 fmt.Println("before request") // 调用下一个处理函数 next(w, r) // 在请求处理后执行一些逻辑 fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e487d6a9672c943a95b79de1ec81c2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/140853a03cb28ec8913ba2806d8f114a/" rel="bookmark">
			Pytorch和CUDA版本对应关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方地址：https://pytorch.org/get-started/previous-versions/
国内有时候打不开
查看CUDA版本
使用nvidia-smi命令显示的cuda版本信息
nvidia-smi
需要注意的是：注意低版本的Pytorch是否向上支持更高版本的CUDA。
高版本的Pytorch一般能兼容低版本CUDA
Pytorch -V 1.0.0
# CUDA 10.0 conda install pytorch==1.0.0 torchvision==0.2.1 cuda100 -c pytorch # CUDA 9.0 conda install pytorch==1.0.0 torchvision==0.2.1 cuda90 -c pytorch # CUDA 8.0 conda install pytorch==1.0.0 torchvision==0.2.1 cuda80 -c pytorch # CPU Only conda install pytorch-cpu==1.0.0 torchvision-cpu==0.2.1 cpuonly -c pytorch Pytorch -V 1.2.0
# CUDA 9.2 conda install pytorch==1.2.0 torchvision==0.4.0 cudatoolkit=9.2 -c pytorch # CUDA 10.0 conda install pytorch==1.2.0 torchvision==0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/140853a03cb28ec8913ba2806d8f114a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cea697359db925e15b62c48b82f8886/" rel="bookmark">
			基于51单片机的智能窗帘控制系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、任务简述
二、总体设计
三、硬件设计
1、最小系统模块
2、液晶显示电路
3、时钟模块
4、电机驱动模块 四、软件设计
1、总体设计
2、代码展示
一、任务简述 本系统以51单片机为核心，重点研究并开发了一套以STC89C52单片机为核心的智能化窗帘控制系统。本系统利用红外遥控器及电机驱动动技术，可自动开启、定时开启、手动开启及遥控控制。同时，该系统还具有光敏电阻传感器，可根据外界光线强度，对窗帘进行自动开闭，实现了对系统的智能化控制。本文详细介绍了该系统的软、硬件设计。在硬件方面，主要进行了元件选择和电路原理图、仿真图设计等方面的工作。其中，软件设计主要包括了主程序，光照传感器程序，定时器程序，液晶显示器程序，红外遥控程序等。在软件方面，系统的总体设计是在KeilC51集成开发系统的基础上，使用 C语言编写程序，并在KeilC51集成开发平台上完成；经过多次反复测试系统稳定性，使得系统能够达到根据太阳光的强弱，实现自动控制、定时控制、手动控制和远程控制的目的。
二、总体设计 一种以51单片机为核心，与电阻、电容和晶体振荡相结合的微型计算机系统。该机采用 MCU作为主要控制元件，包括：1602型 LCD，可以在同一时间内显示出日期、时间、时间、亮度等基础参数；该系统采用DS1302型微处理器。以此单片机为核心，对其进行了时钟信号处理。将进入计时状态，此时，单片计算机仅需要读取计时信息；利用光敏电阻器和ADC0832对光强明信号进行处理，实现了对光强信号的数字处理和显示；窗帘采用步进电机驱动，而不是采用仿真控制，并采用 LED显示屏显示窗帘当前的切换状态；此外，该设计还设有5个按钮，可用于调节目前的时间，并可设定窗帘切换时间及光控阈值等；并且还能通过远程控制窗帘的开启和关闭。最终，电源由通用的5V的USB供电。
三、硬件设计 1、最小系统模块 STC89C52是一种高性能的、低电压的、8位的单片机，片内包有8 K的可反复洗写的 Flash只读程序存储器和256×8 bit的随机访问数据存储器（RAM）。本装置使用了 ATMEL公司的高密度、不易失性存储技术，并满足MCS-51标准。STC89C52采用8位 CPU和 FLASH作为内核，能适应更多更复杂的要求。STC89C52有三个机型，分别为 PDIP, PQFP/TQFP, PLCC，可适应不同的需求。
2、液晶显示电路 LCD显示屏具有质量轻，价格低，功耗低、高信息量（文字、图表、曲线等）、使用寿命长、无电磁辐射等特点，被广泛用于便携式电子设备。
本系统采用工业汉字液晶显示器“1602”，一次可显示16个汉字两列，并能方便地显示英文中的大小写字母、阿拉伯数字和常见的符号。通过自定义还能显示汉字。
3、时钟模块 文中选用了DS1302作为时钟电路，通过串行接口进行数据传送，通过程序对其进行断电保护和向其注入微量电流。如今人们通常使用STM32。使用768千赫玆的晶体振荡器。本款具有记忆功能的时计，能同时显示年月日时分秒，并具有“闰年”修正功能。采用2.0 V~5.5 V供电。该系统使用三线接口实现与中央处理器的同步通讯，并且可以脉冲传输多位的时钟和 RAM数据。DS1302具有31x8大小的随机性记忆体，用以临时存储数据。DS1302是一个与DS1202相容的改良版，但是增加了一个备用电源插头。
4、电机驱动模块 在此基础上，提出了一种基于开环控制的步进电机，使其在输入端具有良好的线性特性，并在此基础上对其进行了调速。在无负荷时，步进电动机的速度及位置依赖于脉冲个数及频率，而不依赖于负荷。电动机是通过步进传动机构进行的，在预定的方向上做“步距角”移动，使得电机每次移动都有一个固定的角度。提出了利用脉冲个数对角位移进行精密控制的新方法。
由于单片机的输入/输出不足，因此在 MCU和步进马达之间插入了 TI公司的达林顿阵列高压芯片，才能完成对电机的控制。它的特点是：大的电流增益、高的工作电压、宽的工作温度范围和高的负荷容量。适用于对功率要求较高、工作温度较高的场合。
四、软件设计 1、总体设计 2、代码展示 #include &lt;reg52.h&gt; #include &lt;intrins.h&gt; // 主函数 void main() { uchar light; LcdInit();	// 执行液晶初始化	DS1302_Init();	// 时钟芯片的初始化 LcdShowInit();	// 液晶显示内容的初始化 if(DS1302_Read_Byte(0x81)&gt;=128)	// 判断时钟芯片是否正在运行 DS1302_Write_Time();	// 如果没有，则初始化一个时间 while(1) { DS1302_Read_Time();	// 获取当前时钟芯片的时间存在数组time_buf中 FlashTime();	// 刷新时间显示 light=Get_ADC0832();	// 读取光照强度 light=light/2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cea697359db925e15b62c48b82f8886/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94ecf54408cdf8c89961f978a645ade7/" rel="bookmark">
			vscode操作git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode &amp; git vscode和git的联合，完美的配合。
本人是一个忠实的vscode使用用户，毕竟他是开源的，使用electron，typescript开发的软件。是免费的，可白嫖的，还有功能强大的插件的，自己也想学习开发的梦想软件。
vscode不仅仅可以敲代码，还可以进行git版本管理。它几乎拥有souretree的所有功能，为啥不用呢？因为讲的人很少。
目标：白嫖vscode 把vscode可以白嫖的git常用功能全部白嫖一边。
(本文基于已经安装好了git并且配置好了git的账户)
1、安装插件 gitlens：虽然只能用部分功能，但足够了。git history：可以显示提交的commit记录，替代gitlens付费的功能git graph：可以显示提交的commit记录，并进行记录操作。搜索页面没有git history做的好看(仅个人看法哈)git-commit-plugin：commit提示(如果公司有自己的模板，可以不需要) 2、建立仓库 这个在github或者gitee，gitlib上面操作。这里暂时只说vscode里面的操作
(github使用物联网打不开😭)
3、链接仓库 A：项目从零开始
进入项目文件；
使用git init初始化配置；
使用各种手段对配置git的提交规范，提交代码规范等等；
第一次提交代码
然后如下图
就可以点击，然后根据框输入仓库地址，然后就可以添加一个仓库
B：参与开发中的项目
使用命令拉起项目然后使用vscode打开项目 4、拉取项目 在上面的图片，已经看到了拉取按钮，点击拉取，就可以拉取项目了。
5、推送项目 在上面的图片，已经看到了推送按钮，点击推送，就可以推送项目了。
(如果没有登录，vscode会提示登录账户的)
6、查看修改区 在这里，可以看到修改的文件
7、提交暂存区 入上图，在鼠标移动到上面的对应位置，可以看见一个加号。
这三个图标分别是，打开文件，撤回修改，添加到暂存区
8、查看暂存区 此时可以看到暂存的文件，同时看到新的图标减号。其他的都是上面见过的符号
减号就是把暂存区的文件退回到修改区
9、提交文件 有人把这一步叫commit，也有人叫提交到历史区。都是一样的操作。
可以通过上面的图8看到一个输入框和一个提交按钮，输入框就是输入commit的内容。输入完成后点击提交按钮，就完成了代码的commit
10、提交功能 上图可以看到提交的全部功能
提交：和左边那个大提交按钮功能一样
提交已暂存文件：仅仅提交在暂存区的文件，修改区的不会提交
全部提交：不管是修改区还是暂存区，都会提交
撤销上一次提交：撤销上一次提交，并把代码退回到历史区
提交已暂存文件(修改)：
比如你已经提交过一次，然后你发现commit描述错误，或者你又修改了一些文件想一起提交，就可以使用这个。
全部提交(修改)：同上
其他：略(我现在也有点不明白已署名是啥)
11、更改功能 可以看到图10里面有更改菜单，里面功能很简单，就是字面意思。
12、分支操作 切换分支就是点击箭头指的地方，点击后会让选择切换到那个分支。同时也可以进行新分支的创建
上图可以看见了分支的常用操作，增删改查合。
13、git存储 有时候会遇到，开发功能开发到一半，领导让你同步代码。但是你同步后可能会有冲突。所以会很无奈的还原代码。因为自己的代码还没有开发好，也不能直接提交。
所以就需要暂时缓存一下代码
存储：把当前修改代码缓存到git的缓存区里面，(注意不是暂存区)存储(包含未跟踪)：未跟踪指的是新创建的文件，还没有被commit记录过存储暂存：字面意思，略应用最新存储：将最后一次存储的内容，放到修改区应用存储：选择历史的某一次存储，放到修改区弹出最新存储：和上面”应用最新存储“基本一样弹出存储：字面意思，略删除存储：选择历史的某一次存储，进行删除删除所有存储：删除全部的存储记录 14、commit查看 如上图，
点击第一个图标，会打开git history页面，然后可以搜索查看commit记录
点击第二个图标，会打开git graph页面，然后也可以搜索查看commit记录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94ecf54408cdf8c89961f978a645ade7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87810335b3999187a3a50d4d4da99b48/" rel="bookmark">
			分享简单好用的开源文件传输工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里有一些开源的文件传输工具，简单好用，值得好评！
FileZilla Client - FTP 文件传输工具 FileZilla 是一种快速、可信赖的 FTP 客户端以及服务器端开放源代码程式，具有多种特色、直观的接口。
FileZilla 不仅支持 FTP，还支持 FTP over TLS (FTPS) 和 SFTP 。
了解更多：FileZilla Client首页、文档和下载 - 文件传输工具 - OSCHINA - 中文开源技术交流社区
百灵快传（B0Pass） - 超大文件传输工具 百灵快传（B0Pass）是一款基于 Go 语言的高性能 “手机电脑超大文件传输神器”、“局域网共享文件服务器”。
主要使用场景： （手机电脑共享文件）电脑上双击执行 --&gt; 手机扫码 --&gt; 手机上的大文件传到电脑、或者电脑传文件到手机
了解更多：百灵快传首页、文档和下载 - 超大文件传输工具 - OSCHINA - 中文开源技术交流社区
LFTP 命令行 FTP 工具 LFTP 是一款非常著名的字符界面的文件传输工具。支持 FTP、HTTP、FISH、SFTP、HTTPS 和 FTPS 协议。
如果还需要 ssl 的支持，则需要额外的 OpenSSL 依赖。
了解更多：LFTP首页、文档和下载 - 命令行 FTP 工具 - OSCHINA - 中文开源技术交流社区
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87810335b3999187a3a50d4d4da99b48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e72ec336d25966d0f38a92675a77e2ec/" rel="bookmark">
			缓存惹的祸？探讨MyBatis二级缓存的四个不推荐之处
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 数据不一致性2. 内存占用3. 延迟问题4. 不适用于复杂查询 在使用 MyBatis 框架时，可以选择开启二级缓存来提高性能。但是，使用 MyBatis 的二级缓存需要谨慎，并且在大多数情况下，并不推荐使用二级缓存。以下是一些原因：
1. 数据不一致性 二级缓存是跨会话的，可能存在多个会话同时操作同一数据的情况。当其中一个会话修改了数据后，其他会话获取到的仍然是缓存中的旧数据，导致数据不一致的问题。
下面是一个示例代码，用于说明 MyBatis 的二级缓存可能导致的数据不一致性问题。
假设有一个 User 类和对应的 UserMapper 接口，用于操作用户数据表。我们将演示在开启了 MyBatis 的二级缓存情况下，同时进行并发的更新操作时可能出现的数据不一致性问题。
首先是 User 类的定义：
public class User { private Long id; private String name; // 构造函数、getter 和 setter 方法省略 } 接下来是 UserMapper 接口和对应的 XML 配置文件：
UserMapper.java：
public interface UserMapper { User getUserById(Long id); void updateUser(User user); } UserMapper.xml：
&lt;mapper namespace="com.example.UserMapper"&gt; &lt;cache type="org.apache.ibatis.cache.impl.PerpetualCache" /&gt; &lt;select id="getUserById" resultType="com.example.User"&gt; SELECT * FROM users WHERE id = #{id} &lt;/select&gt; &lt;update id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e72ec336d25966d0f38a92675a77e2ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20166c4eaf20e24b9036137024d92d52/" rel="bookmark">
			SpringSecurity授权流程详解和代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、授权的概述 承接上一篇博客SpringSecurity认证流程详解和代码实现
1.1 授权的作用 不同的用户可以使用不同的功能。这就是权限系统要去实现的效果。
实际开发中，不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。
因为如果有人知道了对应功能的接口地址就可以不通过前端，直接去请求就可以实现相关功能操作。
因此还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行
相应的操作。
1.2 授权基本流程 在SpringSecurity中，会使用默认的拦截器FilterSecurityInterceptor来进行权限校验。
在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然
后获取其中的权限信息，最后判断当前用户是否拥有访问当前资源所需的权限。
因此在项目中只需要把当前登录用户的权限信息也存入Authentication。
然后设置我们的资源所需要的权限即可。
二、授权代码基础实现 这里是基于SpringBoot来进行实现的。
2.1 限制访问资源所需权限 SpringSecurity为我们提供了基于注解的权限控制方案，这也是项目中主要采用的方式。
可以使用注解去指定访问对应的资源所需的权限。但是要使用它我们需要先开启相关配置。
开启配置需要再在SpringSecurity的配置类中增加如下注解：
@EnableGlobalMethodSecurity(prePostEnabled = true) 由于跨了一篇文章，因此配置类的代码再贴一遍，有不清楚的地方看上一篇。
@Configuration @EnableGlobalMethodSecurity(prePostEnabled = true)	// 这里新增这个注解 public class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean public PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } // 这个自定义的过滤器 @Autowired JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter; @Override protected void configure(HttpSecurity http) throws Exception { http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20166c4eaf20e24b9036137024d92d52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4d18b4efff7946b574d139c3a077c65/" rel="bookmark">
			交通灯电路及verilog实现（状态机）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、功能 功能描述 ： 1 ）初始状态：主路绿灯、支路红灯； 2 ）检测到支路有车 (X=1)，灯状态的变化过程为： ①主路变黄灯、支路红灯 ②主路变红灯、支路红灯 ③主路红灯、支路变绿灯 3）当支路没车(X=0)，灯状态的变化过程为： ①主路红灯、支路绿灯 ②主路红灯、 支路变黄灯 ③主路绿灯、支路变红灯 道路示意图如下: 二、状态分析 对于以上转换过程，可以采用状态机电路来描述： 状态描述： S0:主路绿灯亮，支路红灯亮; 检测到支路有车 (X=1), 进入 S1; S1:主路黄灯亮，支路红灯亮, 延时进入 S2 ； S2:主路红灯亮，支路红灯亮, 延时进入 S3 ； S3:主路红灯亮，支路绿灯亮；检测到支路没车(X=0)进入S4; S4:主路红灯亮，支路黄灯亮；延时进入S0； S0:主路绿灯亮，支路红灯亮 三、verilog实现 用三段式状态机实现交通灯电路，设计和TB代码如下：
// Design Name: traffic_light // Module Name: traffic_light // Description: ↓ ↓ ↓ // Create Date: 2022/3/28 /* state: s0: main-green, branch-red, when x=1 s0-&gt;s1 s1: main-yellow, branch-red, delay s1-&gt;s2 s2: main-red, branch-red, delay s2-&gt;s3 s3: main-red, branch-green, when x=0 s3-&gt;s4 s4: main-red, branch-yellow, delay s4-&gt;s1 port: input: clk,rst_n,x output: main, branch */ `timescale 1ns / 1ps module traffic_light( input clk, input rst_n, input x, output reg [1:0] main, output reg [1:0] branch ); parameter green = 2'd1, yellow = 2'd2, red = 2'd3; parameter s0 = 3'd0, s1 = 3'd1, s2 = 3'd2, s3 = 3'd3, s4 = 3'd4; reg [3:0] state; reg [3:0] next_state; //state transfer always @(posedge clk or negedge rst_n) begin if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4d18b4efff7946b574d139c3a077c65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f285ac1baa34a62b36d2b37e336315c/" rel="bookmark">
			java将数据存入excel中并保存本地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java将数据存入excel中并保存本地 下面将由方法分开展示步骤，以及合并方法展示步骤两部分组成。
可直接观看第二部分合并后的方法即可，便于快速使用
1，分开方法展示步骤 分开方法展示java将数据存入excel中的步骤 //创建sheet页
public static void setSheet(String sheetName) {
workbook = new XSSFWorkbook();
sheet = workbook.createSheet(sheetName);
}
//创建表头
public static void createHead(List&lt;String&gt; headList) {
//创建表头，也就是第一行
row = sheet.createRow(0);
for (int i = 0; i &lt; headList.size(); i++) {
cell = row.createCell(i);
cell.setCellValue(headList.get(i));
}
} //创建表内容
public static void createContent(List&lt;List&lt;String&gt;&gt; contentList) {
//创建表内容，从第二行开始
for (int i = 0; i &lt; contentList.size(); i++) {
row = sheet.createRow(i + 1);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f285ac1baa34a62b36d2b37e336315c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f39b92c41710f33bbd48f2cd7fd678ea/" rel="bookmark">
			使用POI实现EXcel表格的读写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一 POI简介
二 接口介绍
三 写Excel表格
四 读Excel表格
一 POI简介 POI是Apache软件基金会用Java编写的免费开源的跨平台的 Java API，Apache POI提供API给Java程序对Microsoft Office格式档案读和写的功能。
POI的主要功能是可以用Java操作Microsoft Office的相关文件，但是一般我们都是用来操作Excel相关文件。
官网链接：Apache POI - the Java API for Microsoft Documents
二 接口介绍 HSSFWorkbook操作.xls文档XSSFWorkbook操作.xlsx文档HWPF操作Word文档HSLF操作PPT文档HDGF操作VIsio文档 三 写Excel表格 1.导入依赖
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.创建Excel文件并写入 创建后缀名为.xlsx文件，应使用XSSFWorkbook创建后缀名为.xls文件，应使用HSSFWorkbook public void testWrite() throws IOException { Workbook workbook= new XSSFWorkbook(); Sheet sheet = workbook.createSheet("kobe"); for (int i=0;i&lt;2;i++){ Row row = sheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f39b92c41710f33bbd48f2cd7fd678ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cf0f33623758f41f3297a2198c5aea3/" rel="bookmark">
			CTF-Crypto 出题思路与解题思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CTF-Crypto 出题思路：区块链、公钥RSA、流密码、分组密码
机密性(加密算法)、完整性(消息摘要)、可用性、认证性(认证签名)、不可否认性、
编码基础|HEX：a-f 0-9，考虑ascii解码
编码基础|Base64:A-W a-w 0-9 + / 共64个字符使用4字符表达3字节，不足用0替换，也即是=
import base64 str = "解密字符串" //将数字用！@#等替换 basestr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" newstr = '' table = ')!@#$%^&amp;*(' for i in str: if i not in table: newstr=newstr + i else newstr=newstr+(table.index(i)) import base64 print(base.b64decode(newstr)) 编码基础|古典密码学：单表代换加密–爆破和词频分析
凯撒密码：向前或后移动若干位。特定凯撒密码名–偏移量10 Avocat、偏移量13 ROT13、偏移量-5 Cassis、偏移量-6 Cassette摩斯密码：点线键盘密码：用手机九宫格或键盘位置加密猪圈密码：以格子为基础的替换密码培根密码：使用两种不同字体代表AB结合加密表加密栅栏密码：要加密明文分成N个一组，然后每组第一个字相连曲路密码：明文划分为矩阵维吉尼亚密码：使用多表替换，同凯撒，利用重合性字频分析爆破Polybius、BrainFuck、与佛论禅、社会主义核心价值观编码、Ook！、云影密码(01246)、JsFuck(()[]!+)、圣堂武士密码、夏多密码(曲折加密)、跳舞的小人密码、 编码基础|仿射密码：一小串字母数字，有2个以上重复字母
加密函数：E(x) = (ax + b) (mod m)，其中 a与b互质，m是编码系统中字母的个数（通常都是26）。
解密函数：D(x) = a^-1(x-b)(mod m)，a的逆元可以用pow(a,-1,m)求出，
异或加密|OTP一次性密码本：key长度大于message，一次性key
现代密码|哈希函数：散列算法，单向性、固定长度、雪崩效应—MD5 16字节
flag = 'd0g3{' + hashlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cf0f33623758f41f3297a2198c5aea3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1e5902bc5af8b0d0ef56246aac7ba23/" rel="bookmark">
			Chrome浏览器使用AdGuard去除百度热搜
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 百度的热搜会分散注意力，chrome 的 AdGuard 插件可以屏蔽广告，还可以屏蔽百度热搜
设置 &gt; 用户过滤器 &gt; 添加以下代码，即可屏蔽百度热搜
baidu.com##div.cr-content.new-pmd &gt; div.FYB_RD 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a151c4c81a5dbf4fd49b5b08804f8b81/" rel="bookmark">
			Java与设计模式（7）：适配器模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定义 适配器模式是一种结构型设计模式，它允许将一个类的接口转换为客户端所期望的另一个接口。适配器模式使得原本由于接口不兼容而无法一起工作的类能够协同工作。
适配器模式通过引入一个适配器类来解决接口不兼容的问题。适配器类实现了客户端所期望的目标接口，并在内部持有一个适配者对象，将适配者对象的接口转换为目标接口。客户端通过调用适配器对象的方法来间接使用适配者对象的功能。
适配器模式包含以下几个角色：
目标接口（Target）：客户端所期望的接口，适配器类实现了该接口。适配者（Adaptee）：需要被适配的类，它包含了客户端所需的功能，但与目标接口不兼容。适配器（Adapter）：适配器类，它实现了目标接口，并在内部持有一个适配者对象。适配器类将适配者对象的接口转换为目标接口，使得客户端能够通过适配器对象来使用适配者对象的功能。 适配器模式的主要优点是可以解决接口不兼容的问题，使得原本无法协同工作的类能够一起工作。它可以使得系统更加灵活，能够适应变化的需求。适配器模式的主要缺点是引入了一个额外的适配器类，增加了系统的复杂性。
适配器模式在实际开发中经常用于集成不同的系统、框架或第三方库，以便使它们能够协同工作。它也可以用于重用现有的类，而不需要修改其原有的接口。
二、Java示例 以下是一个简单的Java示例，展示了适配器模式的使用：
首先，我们有一个目标接口 MediaPlayer，定义了播放音频文件的方法：
public interface MediaPlayer { void playAudio(String filename); } 然后，我们有一个适配者类 AdvancedMediaPlayer，它提供了播放其他格式音频文件的方法：
public class AdvancedMediaPlayer { public void playMp3(String filename) { System.out.println("Playing MP3 file: " + filename); } public void playFlac(String filename) { System.out.println("Playing FLAC file: " + filename); } } 接下来，我们创建一个适配器类 MediaAdapter，它实现了目标接口 MediaPlayer，并在内部持有一个适配者对象 AdvancedMediaPlayer。适配器类将适配者对象的方法转换为目标接口的方法：
public class MediaAdapter implements MediaPlayer { private AdvancedMediaPlayer advancedMediaPlayer; public MediaAdapter() { advancedMediaPlayer = new AdvancedMediaPlayer(); } @Override public void playAudio(String filename) { // 假设我们只支持播放MP3格式的音频文件 advancedMediaPlayer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a151c4c81a5dbf4fd49b5b08804f8b81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e12afca69896c439128930d832f488b0/" rel="bookmark">
			JMeter 5.5 使用详解（持续更新中......）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言Jmeter 核心组件Jmeter 程序设计通用规范测试计划一、线程（用户）1.1、线程组1.2、setUP 线程组1.3、tearDown 线程组 二、配置元件2.1、CSV 数据文件设置（CSV Data Set Config）2.2、HTTP信息头管理器2.3、HTTP Cookie管理器（HTTP Cookie Manager）2.4、HTTP缓存管理器2.5、HTTP请求默认值2.6、计数器（Counter）2.7、随机变量（Random Variable）2.8、用户定义的变量（User Defined Variables）2.9、Java默认请求（Java Request Defaults）2.10、HTTP授权管理器（HTTP Authorization Manager）2.11、DNS缓存管理器（DNS Cache Manager）2.12、FTP默认请求（FTP Request Defaults）2.13、JDBC Connection Configuration2.14、总结2.13.1、Jmeter 变量作用域和规则2.13.2、配置元件使用小结 三、监听器3.1、查看结果树（View Results Tree）3.2、汇总报告（Summary Report）3.3、聚合报告（Aggregate Report）3.4、后端监听器（Backend Listener）3.5、汇总图（Aggregate Graph）3.6、断言结果（Assertion Results）3.7、生成概要结果（Generate Summary Results）3.8、图形结果（Graph Results）3.9、响应时间图（Response Time Graph）3.10、保存响应到文件（Save Responses to a file）3.11、简单数据写入器（Simple Data Writer）3.12、用表格查看结果（View Results in Table）3.13、比较断言可视化器（Comparison Assertion Visualizer）3.14、邮件观察仪（Mailer Visualizer）3.15、总结3.15.1、主要监听器的场景使用比较3.15.2、监听器输出 Jtl 文件详解3.15.3、Jtl 文件的 html 格式输出 四、定时器4.1、固定定时器（Constant Timer）4.2、统一随机定时器（Uniform Random Timer）4.3、准确的吞吐量定时器（Precise Throughput Timer）4.4、常数吞吐量定时器（Constant Throughput Timer）4.5、高斯随机定时器（Gaussian Random Timer）4.6、泊松随机定时器（Poisson Random Timer）4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e12afca69896c439128930d832f488b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3250db4c11284236a57e798bb500292d/" rel="bookmark">
			Python通过私信消息提取博主的赠书活动地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言背景设计开发1.引入模块2.获取私信内容3.根据文本提取url的方法4.获取包含‘书’的url5.程序入口 效果总结最后 前言 博主空空star主页空空star的主页 大家好，我是空空star，本篇给大家分享一下《通过私信消息提取博主的赠书活动地址》。
背景 关注的博主中有一些赠书活动私信，如何从大量私信中提取出来我们想参与赠书活动的博客地址。
设计 获取私信列表；提取内容包含‘书’的私信内容；从内容中提取url。 开发 1.引入模块 import pprint import re import requests 2.获取私信内容 获取每个用户最新一条私信内容
def get_msg(username,usertoken,page): url = f'https://msg.csdn.net/v1/im/query/historySession3?page={page}&amp;pageSize=40' headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36 Edge/18.17763', 'Cookie': f'UserName={username}; UserToken={usertoken};' } res = requests.get(url, headers=headers) return res.json() 3.根据文本提取url的方法 def get_urls(text): urls = re.findall(r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&amp;+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', text) return urls 4.获取包含‘书’的url def get_about_book(msg): about_book_list = [] datas = msg['data'] for data in datas: if '书' in data['content']: username = data['username'] nickname = data['nickname'] content = data['content'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3250db4c11284236a57e798bb500292d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60ccebc2d17eddade0e28954c6249208/" rel="bookmark">
			编程新视角：ChatGPT帮助你高效编程和理解代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在好几个大公司都推出了自家的大语言模型，有的参数比GPT多，但是真正能称得上会编程的，大概只有GPT一个，可以说是OpenAI的独门功夫。
这篇文章旨在探讨GPT辅助编程过程中常用的提示和技巧。当然，我自己也是一边学一边演练，一边演练一边完成的这篇博客内容。欢迎大家在评论区补充更多的用法。 祝大家都能用好ChatGPT这把趁手的兵器，大大提高效率~
推荐阅读：建议收藏：超详细ChatGPT(GPT 4.0)论文润色指南+最全提示词/咒语
基础篇——让代码编写更简单 开始之前 要让ChatGPT更准确地回答代码相关的问题，以下两个提示词用法值得记住：
1）始终确保你的问题明确且具体。
2）试试看在提示词后添加“请一步步思考”或“请务必认真回答”等语句。这种方法有助于提高ChatGPT的回答精确度。只需要在提示语后面加上这些提醒，ChatGPT的回答就会有显著的不同。
更多更细致的一些，针对提示词设计层面的一些方法，也可以参考我的另外一篇文章，有一些方法是通用的。
建议收藏：超详细ChatGPT(GPT 4.0)论文润色指南+最全提示词/咒语
代码理解 假如一家新公司，或者上手一个新项目，面对业务复杂、代码量大的场景，有时候你需要用ChatGPT作为你的编程顾问，帮你快速梳理出代码的逻辑。
代码解释 提示：这段代码主要用于[如果能给出具体的场景更好]，我初步接触这段代码，需要快速读懂，您作为有着多年开发经验的软件开发工程师，请帮我详细梳理出代码的主要流程，用小标题 + 代码解释/作用/原理 +代码片段的形式给出。
注意，之所以这里用“小标题 + 代码解释/作用/原理 +代码片段”的形式，是因为这种方便自己做笔记整理，大家可以按照自己想要的形式来。
记忆检测 注意，由于ChatGPT的记忆有窗口限制，因此，在交流一段时间之后，如果还需要对原始代码进行继续提问，那么可以用下面这个方法来检测最初的那个问题它是否还记得，如果不记得的话，就得重新输入，保证它的回答不会跑偏。
提示：为了怕你忘记，检查你一下，你还记得咱们刚刚讨论的是哪个代码吗，请给出[代码名称或者函数名称]的原始实现。
核心线索 有时候对于庞杂的代码，或者复杂的SQL查询，你需要梳理出核心线索。
提示：这个SQL查询中，涉及的表过多，我有点乱，请帮我梳理出一条核心的线索，帮助我更好的读懂它。
代码优化 向ChatGPT寻求代码优化建议，以提高代码可读性和可维护性。
提示：如何重构以下Python代码，使其更易读和可维护？
[在这里粘贴你的代码]
注意，为了更加清晰看出修改之后的代码。可以用以下提示：
提示：[这里放你的要求], 请你帮忙修改，不涉及修改的代码省略即可。
下面的所有用法同理。
这样GPT给出的答案就会更加清晰易读。更重要的事，解决「因为代码过长导致无法一次性输出完整」的烦恼。
代码改写 有时，你可能需要将某个功能的代码从一种编程语言改写为另一种。这时，你可以请ChatGPT帮忙。
提示：我有这个JavaScript函数，需要将其改写为Python。你能帮我完成转换吗？
[在这里粘贴你的JavaScript函数]
Code Review 菜菜的自己在代码被大佬Code Review之前，终于有了一个得力的Code Review助手！
让ChatGPT审查你的代码并提供改进建议。
提示：请审查以下Java代码并提供改进建议。
[在这里粘贴你的代码]
错误排查 假设你有一段Java代码，其中存在一些错误，你可以请ChatGPT帮助你找出并纠正这些错误。
提示：我有以下一段带有错误的Java代码。你能帮我找出并纠正这些错误吗？
[在这里粘贴你的Java代码]
深度交互 在与ChatGPT交互时，有时需要多次往返才能得到满意的结果。例如，你可能在调试一个复杂的Python算法：
用户：我在这个Python算法中遇到了问题。它没有给我预期的输出。你能帮我找出问题所在吗？
[在这里粘贴你的Python算法]
ChatGPT可能会首先提供一些建议。如果这些建议仍不能解决问题，你可以继续与ChatGPT交流，直至找到问题的根本原因。
用户：我尝试了你的建议，但问题仍然存在。你能再看一下，提供更多见解吗？
通过与ChatGPT进行深度交互，你可以充分利用其能力，提高编程效率。
升级篇——理解复杂的业务需求 实际工作中的业务往往是复杂的，代码与代码之间有着多种关联关系，这个时候，如何使用ChatGPT解决复杂的业务需求，需要一点体力活。
首先，你需要了解你的业务逻辑。确保你明白每个模块的工作原理，每个函数的输入和输出，以及它们之间的相互关系。这是解决复杂问题的第一步。
其次，尝试将复杂的问题分解为一系列小问题。ChatGPT在处理小问题上表现得更好，因此，将大问题分解为小问题可以提高其解决问题的准确性。
以一个电商应用的订单管理系统作为例子。假设我们需要ChatGPT帮助我们设计一个新的订单分派功能，此功能需要将新订单分派给对应的仓库处理。
我们可以将这个复杂问题分解为以下几个小问题：
确定仓库：确定哪个仓库应处理订单，这可能取决于产品库存和订单的发货地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60ccebc2d17eddade0e28954c6249208/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/934c8c4aefdf7843fd5eb587810eeb3f/" rel="bookmark">
			对rabbitmq进行压测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加rabbitmq依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 配置文件中加入rabbitmq配置 server: port: 18072 spring: rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guest 在启动类上添加注解 @EnableRabbit @SpringBootApplication public class RabbitMqBootApplication { public static void main(String[] args) { SpringApplication.run(RabbitMqBootApplication.class, args); } } 创建Rabbit配置类 @Configuration public class RabbitConfig { //定义队列 public static final String SIMPLE_QUEUE_NAME = "mqTest1"; @Bean public Queue simpleQueue() { /** durable(): 是否持久化,当mq 重启之后还在 exclusive(): 是否独占:只能有一个消费者监听这个队列,当Connection 关闭时,是否删除队列 autoDelete(): 是否自动删除,当没有Consumer 监听时,自动删除 withArgument(): 参数 */ return QueueBuilder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/934c8c4aefdf7843fd5eb587810eeb3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c566b30473f9dfba8b6193aff88f95e0/" rel="bookmark">
			python爬虫-获取cookie实例小记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意！！！！某XX网站逆向实例仅作为学习案例，禁止其他个人以及团体做谋利用途！！！ 第一步：请求拿到响应内容。并分析。
第二步：关键步骤分析(这部分参考的B站图灵何老板)。内容是格式化后响应内容
第三步：在 setcookie（）处打断点。删掉cookie，刷新页面（加载时间有点长，耐心等待）。断点处出现 X 说明X就是 生成cookie。通过在堆栈处可以看到执行顺序，reload 函数的上一步是匿名函数。点击进去
第四步：进入到匿名函数后，可以看到reload（arg2） 说明x=arg2 (加载时间很长，无耐心看不到的哦。)
第五步：在标注的页签里 在 arg2 处进行断点。打完断点，删掉cookie，刷新页面等待在此停留。注意！！！一定要把之前的setcookie（）函数的断点去掉
第六步：断点处可以看到两个值，分别是_0x23a392和_0x5e8b26。 其中_0x23a392 是生成出来的值。将这块内容扣下来放在编辑器里
_0x5e8b26 这个值进行搜索，可以看到是一个常量（不明白的同学，可以私我或者看图自悟）
第七步：对扣下来的代码进行解析。可以通过在本地执行时报错内容进行解析和内容补充。
最后代码展示
// arg1 = 'F90D514BDEF402588B5CFCED428E96F13C466BBE' function fuzhi_arg1(arg1) { _0x5e8b26 = "3000176000856006061501533003690027800375" String['prototype']['unsbox'] = function() { var _0x4b082b = [0xf, 0x23, 0x1d, 0x18, 0x21, 0x10, 0x1, 0x26, 0xa, 0x9, 0x13, 0x1f, 0x28, 0x1b, 0x16, 0x17, 0x19, 0xd, 0x6, 0xb, 0x27, 0x12, 0x14, 0x8, 0xe, 0x15, 0x20, 0x1a, 0x2, 0x1e, 0x7, 0x4, 0x11, 0x5, 0x3, 0x1c, 0x22, 0x25, 0xc, 0x24]; var _0x4da0dc = []; var _0x12605e = ''; for (var _0x20a7bf = 0x0; _0x20a7bf &lt; this['\x6c\x65\x6e\x67\x74\x68']; _0x20a7bf++) { var _0x385ee3 = this[_0x20a7bf]; for (var _0x217721 = 0x0; _0x217721 &lt; _0x4b082b['length']; _0x217721++) { if (_0x4b082b[_0x217721] == _0x20a7bf + 0x1) { _0x4da0dc[_0x217721] = _0x385ee3; } } } _0x12605e = _0x4da0dc['\x6a\x6f\x69\x6e'](''); return _0x12605e; } String['prototype']['hexXor'] = function(_0x4e08d8) { var _0x5a5d3b = ''; for (var _0xe89588 = 0x0; _0xe89588 &lt; this['length'] &amp;&amp; _0xe89588 &lt; _0x4e08d8['length']; _0xe89588 += 0x2) { var _0x401af1 = parseInt(this['slice'](_0xe89588, _0xe89588 + 0x2), 0x10); var _0x105f59 = parseInt(_0x4e08d8['slice'](_0xe89588, _0xe89588 + 0x2), 0x10); var _0x189e2c = (_0x401af1 ^ _0x105f59)['toString'](0x10); if (_0x189e2c['length'] == 0x1) { _0x189e2c = '\x30' + _0x189e2c; } _0x5a5d3b += _0x189e2c; } return _0x5a5d3b; } var _0x23a392 = arg1['unsbox'](); arg2 = _0x23a392['hexXor'](_0x5e8b26) return arg2; } 仅作为笔记记录，如有问题请各位大佬来指导
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/618eded1fed1c6afadc911310b6b36f1/" rel="bookmark">
			传统后端漏洞----（Web Server) 解析漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记 前言IIS解析漏洞文件夹解析漏洞原理限制条件 ";" 分号截断漏洞原理 IIS解析漏洞检测IIS 文件夹解析漏洞检测IIS 分号截断漏洞检测 防御手段 Nginx解析漏洞Nginx 文件类型错误解析漏洞导致任意PHP代码执行原理Nginx 空字节解析漏洞导致任意文件可解析（CVE-2013-4547)原理受该漏洞影响的Nginx版本： Nginx解析漏洞检测Nginx 解析漏洞的防御 Apache 解析漏洞配置错误导致的Apache解析漏洞该漏洞产生原因 Apache HTTPD 换行解析漏洞（CVE-2017-15715）原理该漏洞产生原因 Apache解析漏洞检测Apache解析漏洞的防御 解析漏洞的防御 前言 这几天各种技术面试接踵而至，压得我喘不过气了！然后面试官问了我这个解析漏洞原理和利用方式以及防御手段，当然同时还问了好几个Top10漏洞！ IIS解析漏洞 文件夹解析漏洞 原理 在IIS 5.x 和6.x下，对于目录名称为“x.asp”中的任何内容，包括“1.jpg”这样的图片资源文件，都会被当作ASP文件解析 限制条件 需要同时存在文件夹解析漏洞和网站允许创建恶意文件夹（管理员权限）两个漏洞利用点，缺少任何一个都无法成功利用。 “;” 分号截断漏洞 原理 IIS 6.0 下，会将“1.asp;.jpg”这样的文件当作ASP文件解析。计算机对文件扩展名的理解上来说，文件扩展名是以最后一个“ . ”的后面内容为依据的，这个文件被网站过滤程序理解成了图片IIS 会认为分号即是结尾，后面的内容被“截断”了，认为这是ASP文件，及时使用了“白名单”过滤，也允许可以进行绕过。 IIS解析漏洞检测 IIS 文件夹解析漏洞检测 通过在网站根目录下创建“a.asp”文件夹，并在其中创建“1.jpg”，文件内容填写ASP代码。然后远程访问 http://target.com/a.asp/1.jpg，验证文件是否能够被当作ASP解析，以判断漏洞存在是否 IIS 分号截断漏洞检测 可以上传“1.asp;.jpg” 文件，然后远程访问http://target.com/1.asp;.jpg，验证文件是否能够被当做ASP解析 防御手段 漏洞源于IIS 服务器本身存在缺陷。可以升级IIS 服务器版本和打补丁 Nginx解析漏洞 Nginx 文件类型错误解析漏洞导致任意PHP代码执行 原理 服务器上任意一个已存在的文件，包括用户上传的图片、附件等，都可以被PHP-FPM解析，导致任意PHP代码执行漏洞（国内知名安全团队80sec提出）
Nginx会将用户请求的HTTP数据包解析生成CGI环境变量，并通过FastCGI协议发送给PHP-FPM的9000端口；PHP-FPM通过这些CGI环境变量，定于到用户需要执行的PHP文件并执行，将返回结果在通过FastCGI协议的返回包返回给Nginx服务器。 Nginx 空字节解析漏洞导致任意文件可解析（CVE-2013-4547) 原理 Nginx在遇到“%00空字节”时，与后端FastCGI处理不一致，导致可以在图片中可以嵌入PHP代码，然后通过访问“xxx.jpg%00.php”来执行其中的代码。 受该漏洞影响的Nginx版本： 0.8.41-1.4.3/1.5.0-1.5.7 Nginx解析漏洞检测 Nginx 解析漏洞的表现形式就是任意文件都可以让PHP解释器执行。
通常，可以在目标站点中找到任意一个已知的静态文件，如“/robots.txt”。利用Burp Suite工具可以看到请求和响应的HTTP协议内容。正常情况下"/robots.txt"的Content-Type是“text/plain”如果访问“/robots.txt/.php”,其响应头字段Content-Type将变成PHP默认的“text/html”,并会增加PHP的指纹“X-Powered-By”通过这个特征，可以判断目标网站是否将静态文件分发给PHP执行。如果目标网站支持上传文件，攻击者用图片的形式上传一个WebShell命名为shell.jpg,并增加“/.php”访问，就成功实现了GetShell Nginx 解析漏洞的防御 Nginx文件类型错误漏洞是由PATH_INFO变量所导致的，如果业务上并没有用到PATH_INFO功能，可以直接在PHP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/618eded1fed1c6afadc911310b6b36f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b3e46adda173e8bea570f88e1aa9ea9/" rel="bookmark">
			靠谱反爬神器分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本穷鬼一直在找好用且免费的WAF，偶然关注到长亭科技4月份发布了免费版WAF-“雷池社区版”，该产品主打的是核心检测能力由智能语义分析算法驱动。
本人经过一段时间的水群和体验产品后，发现产品迭代非常快，且社群氛围也非常不错（产品团队给的技术支持非常给力，回复很及时且小白的问题也能得到回复；除此之外，也可以直接在群里或github里提期望的需求）。趁着雷池社区今天发布2.0版本，在这也做个小小分享。
雷池社区版 1.x 系列 个人感觉雷池社区版1.x版本主要是满足基础防护需求，目前具有的功能主要有：
语义分析驱动的 Web 攻击防护可视化 Dashboard 与流量统计分析自定义防护模式、黑白名单、IP 库网站一键关停 雷池社区版 2.0 然后再说说今天发布的雷池社区版2.0版本。感觉2.x版本应该会增加更多高级防护能力，全新版本推出“人机验证”能力还是蛮惊艳的。
“Bot 管理”、“流量建模”、”网站监控“、“API 管理”、“限频限流”、“拟态防护” 等功能也在产品团队的规划中（有相同需求的小伙伴请速来github仓库的issue点星星，据说产品团队会根据社区的呼声动态调整优先级）。
雷池 “ 人机验证 ” 能力 Bot 利用自动化程序对网站进行探测，其通过合法有效的访问实现自动化攻击，以达到获取核心系统权限、窃取敏感信息、植入恶意软件、发起 DDoS 攻击等目的。
**雷池的 “人机验证” 能力是专为社区用户提供的免费防 Bot 解决方案**，无需开发，只要通过界面简单配置规则即可生效，感觉还是比较小白友好且比较实用的功能了。
配置完成后，符合条件的请求在访问时就会看到雷池的人机验证页面。
雷池会使用客户端指纹、JS 挑战、交互行为识别、浏览器反调试、IP 画像等方式综合验证环境的安全性，识别有恶意倾向的 Bot 客户端并实施阻断。
综上所述，感觉雷池社区版还是一个比较好用的免费WAF。有相关需求的小伙伴们可以尝试一下。最后挂个官方链接https://waf-ce.chaitin.cn/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c685d8e6c42b4adca81ec9bcbec93e5/" rel="bookmark">
			新后端漏洞之----SSRF漏洞（服务端请求伪造）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 笔记 前言SSRF漏洞概述SSRF漏洞检测与挖掘SSRF漏洞的回显分类SSRF漏洞利用SSRF漏洞防御 前言 这几天各种技术面试接踵而至，压得我喘不过气了！然后面试官问了我这个SSRF漏洞原理和利用方式以及防御手段，当然同时还问了好几个Top10漏洞！ SSRF漏洞概述 危害：一个不符合预期的请求就可能导致整个内网沦陷全名 ：Server Side Request Forgery基本原理：攻击者构造恶意的URL，由服务器端发起请求的漏洞SSRF的目标：从外网无法访问的内部系统。让服务器替攻击者发请求。面试回答部分：因为一些内网资源，攻击者直接请求不到，而服务器存在SSRF漏洞时，可代替攻击者发送任意的请求，于是服务器就成为攻击者访问其所在内网各个系统的“跳板”。借助这台服务器，攻击者可以直接攻击内网系统，由于内网系统安全性普遍较为薄弱，就极有可能导致整个内网沦陷形成原因：服务器提供了远程访问的功能，且没有对目标地址进行过滤和限制。代码示例 $imageUrl =$_GET['catchimage']; $context =stream_context_create( arry('http' =&gt;arry( 'follow_location'=&gt;false // don't follow redirects )) ); redirect($imageUrl,false,$context); 上述例子，程序员的本意是想给用户提高一个抓取远程图片的功能，但是没有对catchimage参数进行过滤检测，从而导致用户可以构造URL,访问内网。构造恶意URL:127.0.0.1:8080/catchimage.php?catchimage=http://10.10.10.34:8080/该漏洞实际上是操纵服务器去发送请求，因为攻击者从互联网无法访直接访问内网，但是服务器可以，借助服务器之手，来攻击其内网的其他服务器。 SSRF漏洞检测与挖掘 1）能够对外发起网络请求的地方，就可能存在SSRF漏洞2）从远程服务器请求资源的地方，如通过URL上传，导入文件、或RSS订阅等。3）数据库内置功能，Oracle、MongoDB、MSSQL、PostgreSQL、CouchDB等数据库都具有加载外部URL的功能。4）Webmail收取其他邮箱邮件，如POP3、IMAP、SMTP等5）文件处理、编码处理、属性信息处理，如FFmpeg、ImageMagic、Word、Excel、PDF、XML等。利用限制OpenSSL.当服务器开启OpenSSL时，SSRF请求也必须遵从OpenSSL来交互，因而一些场景下无法直接利用。鉴权。大部分网站使用Cookie鉴权，还有一部分使用HTTP Basic 认证，当攻击者仅能控制一个URL时，往往无法人为添加Cookie或www-authenticate头部字段，进而无法访问部分接口校验了其他头部字段的情况，如：Referer，User-Agent等。 SSRF漏洞的回显分类 有回显半盲回显(半盲SSRF)无回显（全盲SSRF，针对DNS Log或HTTP Log)暑假期间我会尽快对这一部分进行补齐 SSRF漏洞利用 通过SSRF漏洞攻击内网Redis未授权服务通过SSRF漏洞攻击Kubernetes服务SSRF漏洞与DNS Rebinding攻击WebLogic SSRF 漏洞（CVE-2014-4210）暑假期间我会尽快对这一部分进行补齐 SSRF漏洞防御 对于服务器来说，尽量避免使用服务器端根据用户用户参数远程加载资源，如果一定要采取这种方法，应当尽量将资源固定化，避免用户提交可变参数在使用开源的类库时，应当对其是否存在SSRF漏洞进行充分了解，尽可能使用最新版本或保证安全的较新版本。此外，，对于内网漏洞的及时修复以及未授权接口的加以鉴权，能够有效降低SSRF漏洞攻击造成的危害，也应当放在去企业安全管理者考虑的范围之内。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e9f753704b7ee021ee0126d46ebc302/" rel="bookmark">
			解决无法下载某些jar包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决无法下载某些jar包 例如，下面的oracle驱动无法下载 &lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc14&lt;/artifactId&gt; &lt;version&gt;10.2.0.4.0&lt;/version&gt; &lt;/dependency&gt; 可以直接搜 ojdbc14:10.2.0.4.0 jar包 并下载
在mvn里进行安装
mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.4.0 -Dpackaging=jar -Dfile=C:\Users\EDY\Downloads\Oracle_10g_10.2.0.4_JDBC_ojdbc14.jar Maven的工作机制 项目中各模块通过maven建立依赖关系
Maven仓库包括 本地仓库 和 远程仓库
本地仓库包含： 通过maven插件install安装到maven到jar包在pom.xml引入 坐标，下载下来的框架或者第三方库到jar包，会从远程仓库下载maven 插件 通过命令安装到 仓库到jar包 pom.xml的结构说明 代表 当前pom.xml 所采用的标签结构groupId(公司或组织)、artifactId(项目)、version(版本)是项目的标签 代表 打包的方式，jar说明是java工程，war说明是web工程，pom用来管理其他工程properties 定义属性值， project.build.sourceEncoding 在构建过程中读取源码使用的字符集 dependencies 依赖信息 dependency 里通过坐标定位 groupId、artifactId、version、scope(范围) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c80423a8af8c0aa8f8b3a5680c42294/" rel="bookmark">
			Mybatis-Generator代码生成工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis-Generator 添加插件 &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;${basedir}/src/test/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; 创建配置xml文件 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt; &lt;!-- 配置生成器 --&gt; &lt;generatorConfiguration&gt; &lt;!--classPathEntry:数据库的JDBC驱动,换成你自己的驱动位置 可选， 选择本机jdbc驱动的路径 --&gt; &lt;classPathEntry location="D:\workspace\maven\repository\mysql\mysql-connector-java\5.1.30\mysql-connector-java-5.1.30.jar"/&gt; &lt;!-- 一个数据库一个context,defaultModelType="flat" 大数据字段，不分表 --&gt; &lt;context id="MysqlTables" targetRuntime="MyBatis3" defaultModelType="flat"&gt; &lt;!-- 注释 --&gt; &lt;commentGenerator&gt; &lt;property name="suppressAllComments" value="true"/&gt;&lt;!-- 是否取消注释 --&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;!-- 是否生成注释代时间戳--&gt; &lt;/commentGenerator&gt; &lt;!-- jdbc连接, 8以上版本记得加cj--&gt; &lt;jdbcConnection driverClass="com.mysql.cj.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3392/mqtt_server?generateSimpleParameterMetadata=true" userId="root" password="666abc"&gt; &lt;/jdbcConnection&gt; &lt;!-- 类型转换 --&gt; &lt;javaTypeResolver&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c80423a8af8c0aa8f8b3a5680c42294/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bd0ebb0e30f22eed7d7ff2674476c3d/" rel="bookmark">
			spring中Bean创建完后打印语句的两种方法（Bean的生命周期）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bean的生命周期 Bean的生命周期包括四个阶段：
实例化阶段（Instantiation）：容器通过调用构造函数或者工厂方法来创建Bean的实例。
属性赋值阶段（Populate properties）：容器将相应的属性值设置给Bean的实例，可以通过setter方法、直接字段注入或者其他自定义的方式完成属性赋值。
初始化阶段（Initialization）：在Bean的属性赋值完成后，容器会调用相关的初始化方法（如果有的话），如实现了InitializingBean接口的afterPropertiesSet()方法，或者通过@Bean注解的initMethod属性指定的方法。开发者可以在初始化方法中进行一些额外的操作，例如数据校验、初始化资源等。
使用阶段（In use）：
经过初始化阶段后，Bean进入可用状态，可以被容器及其他对象使用。
销毁阶段（Destruction）：当Bean不再被使用时，容器可以对其进行销毁操作。这包括调用实现了DisposableBean接口的destroy()方法，或者通过@Bean注解的destroyMethod属性指定的方法。开发者可以在销毁方法中释放资源、关闭连接等。
两种方式在Bean创建完后打印语句（Bean的初始化阶段） 实现InitializingBean接口： 创建一个类，实现InitializingBean接口。
在该类中实现afterPropertiesSet()方法，在该方法中编写创建Bean后要执行的操作，例如打印语句。
当Bean被创建后，容器会自动调用afterPropertiesSet()方法。
代码示例：
import org.springframework.beans.factory.InitializingBean; public class MyBean implements InitializingBean { @Override public void afterPropertiesSet() throws Exception { System.out.println("Bean已创建。"); } } 使用@Bean注解和initMethod属性： 在Bean对应的配置类中，使用@Bean注解定义Bean的创建方法。
在@Bean注解中，使用initMethod属性指定在Bean创建后要调用的初始化方法。
在初始化方法中，编写需要执行的操作，例如打印语句。
代码示例：
import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean(initMethod = "init") public MyBean myBean() { return new MyBean(); } } public class MyBean { public void init() { System.out.println("Bean已创建。"); } } 最后 无论使用哪种方式，当Bean被创建后，打印语句将会在初始化阶段执行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bd0ebb0e30f22eed7d7ff2674476c3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c62d63580c5d99b5e01d0a6c1d3044/" rel="bookmark">
			mac 下 brew安装和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac 下 brew安装和使用 安装brew /bin/bash -c "$(curl -fsSL https://gitee.com/ineo6/homebrew-install/raw/master/install.sh)" 将homebrew添加到path中 echo 'eval "$(/opt/homebrew/bin/brew shellenv)"' &gt;&gt; /Users/jackhou/.zprofile eval "$(/opt/homebrew/bin/brew shellenv)" 把brew下载包的地址切换为国内的镜像地址 git -C "$(brew --repo)" remote set-url origin https://mirrors.ustc.edu.cn/brew.git git -C "$(brew --repo homebrew/core)" remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git git -C "$(brew --repo homebrew/cask)" remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git brew update 设置bottles镜像 echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles/bottles' &gt;&gt; ~/.zprofile source ~/.zprofile brew 常用命令 //查看brew的版本 brew -v //更新homebrew自己，把所有的Formula目录更新，并且会对本机已经安装并有更新的软件用*标明 brew update //查看命令帮助： brew -help //查看那些已安装的程序需要更新 brew outdated //更新单个软件： brew upgrade [包名] 例：brew upgrade git //更新所有软件： brew upgrade //安装软件 brew install [包名]@版本 例：brew install git //卸载 brew uninstall [包名] 例：brew uninstall git //清理所有包的旧版本 （安装包缓存） brew cleanup 例：brew cleanup -n //显示要删除的内容，但不要实际删除任何内容 例：brew cleanup -s //清理缓存，包括下载即使是最新的版本 例：brew cleanup --prune=1 //删除所有早于指定时间的缓存文件（天） //清理单个软件旧版本 brew cleanup [包名] 例：brew cleanup git //查看需要更新的包 brew outdated //查看可清理的旧版本包，不执行实际操作 brew cleanup -n //锁定某个包 brew pin $FORMULA //取消锁定 brew unpin $FORMULA //查看包信息 brew info [包名] 例:brew info git //查看安装列表 brew list //查询可用包 brew search [包名] 例：brew search git //显示包依赖 brew deps [包名] 例: brew deps git //更新升级brew $ sudo brew update //1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32c62d63580c5d99b5e01d0a6c1d3044/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e670749845f8989d04f9ffa939d7393/" rel="bookmark">
			mac&amp;linux配置环境变量详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、shell语言解释&amp;环境变量配置 在shell语言中，定义一个变量，并使变量生效，使用export。
如：
1、定义一个变量name=zhangsan
name=zhangsan 2、并使name变量生效
export name 3、调用/打印name变量
调用name变量时，方式一$name 方式二 ${name}
zhaohui@zhaohuideMBP ~ % echo $name zhangsan zhaohui@zhaohuideMBP ~ % echo ${name} zhangsan 在~/.bash_profile 文件中，配置环境变量时，会遇到多个应用的环境变量配置。
多个应用的环境变量，都需要配置在 同一个path下。
查看当前系统下，所有程序的环境变量配置的path
zhaohui@zhaohuideMBP ~ % echo $path /usr/bin /bin /usr/sbin /sbin /usr/local/bin /Library/allure-2.18.1/bin /Library/apache-jmeter-5.4.3/bin /opt/homebrew/bin /usr/bin /bin /usr/sbin /sbin /usr/local/bin /Library/allure-2.18.1/bin /Library/apache-jmeter-5.4.3/bin /Library/Frameworks/Python.framework/Versions/3.8/bin /usr/bin /bin /usr/sbin /sbin /usr/local/bin /Library/allure-2.18.1/bin /Library/apache-jmeter-5.4.3/bin /opt/homebrew/bin /usr/bin /bin /usr/sbin /sbin /usr/local/bin /Library/allure-2.18.1/bin /Library/apache-jmeter-5.4.3/bin 我们想要配置多个程序的环境变量，都需要写在同一个path下。
PATH=$JAVA_HOME/bin:$JMETER_HOME/bin:$PATH:$MAVEN_HOME/bin export PATH=/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin export PATH=${PATH}:/Library/allure-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e670749845f8989d04f9ffa939d7393/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7d9fc3f5d36a984593f36a1ddbc54c6/" rel="bookmark">
			GPT开通Plus会员教程，附带开通虚拟卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPT-4目前只有开通GPT Plus会员才可以体验。但是Plus会员需要支付20美元/月的费用，国内的卡无法绑定openai账户进行付款，今天给大家一个教程可以无障碍开通。
首先我们要准备的东西。
1.chat帐号
2.一张虚拟卡（国际）
既然是开通会员教程，首先帐号肯定是已经申请好了。
第一步，登录chat后，点击下方的upgrade to plus
第二步，点击upgrade plan，就进入到开通界面了。在开通界面我们需要输入一个卡，还有一个账单地址信息。
很多人都卡在了没有卡这一步，这个卡我们可以在coincc点top申请。
第三步，申请虚拟卡，开通gpt的话建议使用556150这个卡段，进行申请。
第四步，填写地址，这里有两个建议
1.你用的哪里的IP，就用该地区的地址；
2.如果你的IP是日本，那么就写日本的地址。如果是你用的美国地区，那么要选用免消费税州，不然存在税费问题，所以这里是建议你多充2美元，多出来的钱可以下次续费使用。
第五步，提交后只要出现Payment received! You've been upgraded to ChatGPT Plus. 恭喜你，升级成功了。成为了尊贵的Plus用户，成为走在全球时代前沿的人。
最后一个问题
如何取消chat的自动订阅：
打开GPT首页并登录→左下角→My Account→Manage My Subscription→Cancel Plan。为什么要取消呢，因为如果里面余额不足总是扣款失败的话，是会认定欺诈而封卡的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bea2d8c1bff47ca29cfeb8278a2999c1/" rel="bookmark">
			Playwright 和 Selenium的对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近有不少同学问到 Playwright 和 Selenium 的区别是什么？
有同学可能之前学过 selenium 了，再学一个 playwright 感觉有些多余，可能之前有项目已经是 selenium 写的了，换成 playwright 需要时间成本，并且可能有未知风险。
也有同学之前可能没学过 selenium ，现在正准备入手一个web 自动化框架，但是对于选择selenium 和 playwright 犹豫不决，因为面试问selenium比较多，可能学了工作中也用不上，仅仅只是应付面试。
不管出于哪种原因，本篇详细分析 2 者的差异
Playwright 和 Selenium 的区别 编号功能PlaywrightSelenium哪个更优秀1学习资料相对少多Selenium2用户群体出现的比较晚，用户量相对少出现的早，用户量多Selenium3支持语言TypeScript、JavaScript、Python、.NET、JavaC#,Java,Perl,PHP,Python 和RubySelenium4支持浏览器Chromium（包含chrome， msedge）、WebKit 和 FirefoxIE（7, 8, 9, 10, 11），Firefox，Safari，Google Chrome，Opera，Edge等Selenium5跨平台Windows，Linux(只支持Ubuntu部分系统) ，MacWindows，Linux，Mac 都支持Selenium6浏览器安装命令行安装自己安装Playwright7浏览器驱动不需要驱动下载对应版本驱动Playwright8启动速度快慢Playwright9context 环境隔离有无Playwright10headless 无头模式默认headless， 也可以设置GUI默认GUI模式，也可以设置headlessPlaywright11无痕模式默认无痕模式，对应测试很有帮助，对于爬虫用户可能访问页面不通过默认非无痕默认，爬虫用户特别喜欢Selenium12页面等待wait_for_load_state可以精准等待commit,domcontentloaded,load,networkidle四种状态implicitly_wait等待页面加载完成Playwright13元素定位提供多个内置定位器，定位方式更贴近业务，定位方式更多八大定位Playwright14元素等待定位元素自带等待机制需要自己封装等待方法Playwright15点击元素等操作会判断元素状态，出现位置，是否可点击智能判断需要自己封装webdriverwait.until方法,难度较大Playwright16定位报错会人性化告诉你定位到几个元素，并推荐定位方式报错需要自己去猜谜，自己排除各种可能性Playwright17元素不在当前屏幕会判断元素位置，自动滚动元素出现位置需要自己去判断滚动Playwright18iframe通过对象操作，不用切换需要来回切换Playwright19alert默认监听自动关闭，可以异步监听需要自己判断，无异步监听Playwright20文件上传监听文件上传时间，处理优雅无法解决非input 上传Playwright21文件下载可以监听下载只能设置浏览器默认位置Playwright22多窗口标签可以监听窗口事件，操作方便需要来回切换Playwright23事件监听可以监听各种事件无法监听Playwright24捕获ajax 请求可以捕获ajax 请求和 返回无法捕获Playwright25mock 功能可以模拟想要的任何接口数据无mock 功能Playwright26断言提供expect 丰富断言需要自己封装webdriverwait.until方法,难度较大Playwright27录制视频录制用例视频无Playwright28trace 追踪有无Playwright29断点调试有无Playwright30录制可以生成pytest用例录制功能比较简单Playwright31鼠标键盘操作调用简单方便导入模块，操作复杂Playwright32base_url可以添加全局base_url无此功能Playwright33接口测试提供接口测试无此功能Playwright34grid 分布式无selenium-grid 分布式Selenium35协议websockt 协议，可以实时获取页面状态http 协议，只能获取当时的状态，需自己轮询判断Playwright36执行JavaScript可以在page,iframe,元素对象执行JavaScript只能在driver对象执行JavaScripPlaywright37面试要求playwright 比较少问selenium 比较多Selenium38学习难易程度容易，无需封装，直接用难度较大，需要封装Playwright 总体打分Selenium 8分， Playwright 30 分。
对此你有什么想法，评论区留言吧 正在做测试的朋友可以进来交流，群里给大家整理了大量学习资料和面试题项目简历等等....
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae36cc20fd4f49823e1ece1e6e84e2af/" rel="bookmark">
			微信小程序实现类Vue-watch数据监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 在 app.js 里了定义一个全局函数，当然也可以单独写一个模版，再通过引入模块的方式来调用 // 监听页面数据变化 initWatch(_page) { if (!_page) { console.error('未检测到Page对象,请将当前page传入该函数'); return false; } if (!_page.watch) { //判断是否有需要监听的字段 console.error('未检测到Page.watch字段(如果不需要监听，请移除initWatch的调用片段)'); return false; } let _dataKey = Object.keys(_page.data); Object.keys(_page.watch).map((_key) =&gt; { //遍历需要监听的字段 _page.data['__' + _key] = _page.data[_key]; //存储监听的数据 if (_dataKey.includes(_key)) { //如果该字段存在于Page.data中，说明合法 Object.defineProperties(_page.data, { [_key]: { //被监听的字段 enumerable: true, configurable: true, set: function(value) { let oldVal = this['__' + _key]; if (value !== oldVal) { //如果新设置的值与原值不等，则触发监听函数 setTimeout(function() { //为了同步,否则如果回调函数中有获取该字段值数据时将不同步,获取到的是旧值 _page.watch[_key].call(_page, oldVal, value); //设置监听函数的上下文对象为当前的Page对象并执行 }.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae36cc20fd4f49823e1ece1e6e84e2af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8239f0eba5657be7109cb50cfffb03bd/" rel="bookmark">
			视觉软件框架 功能概览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将总结面向非标视觉项目的软件框架所需要开发的功能。
一、用户登录系统 二、报警机制 三、日志记录 四、IO通信 五、设备参数设置 1. 相机参数设置 六、配方参数设置 1. 工位视觉工具设置 七、生产界面设计 八、视觉工具箱 九、线程交互 相互学习，共同富裕。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cc454ff44e5da96f08904b989cbf2d8/" rel="bookmark">
			C语言100道经典例题详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
C语言100道经典例题 **
【程序1】
题目：有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？
1.程序分析：可填在百位、十位、个位的数字都是1、2、3、4。组成所有的排列后再去掉不满足条件的排列。
2.程序源代码：
main() { int i,j,k; printf("\n"); for(i=1;i&lt;5;i++)　／*以下为三重循环*/ for(j=1;j&lt;5;j++)　for (k=1;k&lt;5;k++) { if (i!=k&amp;&amp;i!=j&amp;&amp;j!=k) /*确保i、j、k三位互不相同*/ printf("%d,%d,%d\n",i,j,k); } } 【程序2】
题目：企业发放的奖金根据利润提成。利润(I)低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%，高于100万元时，超过100万元的部分按1%提成，从键盘输入当月利润I，求应发放奖金总数？
1.程序分析：请利用数轴来分界，定位。注意定义时需把奖金定义成长整型。　2.程序源代码：
main() { long int i; int bonus1,bonus2,bonus4,bonus6,bonus10,bonus; scanf("%ld",&amp;i); bonus1=100000*0.1;bonus2=bonus1+100000*0.75; bonus4=bonus2+200000*0.5; bonus6=bonus4+200000*0.3; bonus10=bonus6+400000*0.15; if(i&lt;=100000) bonus=i*0.1; else if(i&lt;=200000) bonus=bonus1+(i-100000)*0.075; else if(i&lt;=400000) bonus=bonus2+(i-200000)*0.05; else if(i&lt;=600000) bonus=bonus4+(i-400000)*0.03; else if(i&lt;=1000000) bonus=bonus6+(i-600000)*0.015; else bonus=bonus10+(i-1000000)*0.01; printf("bonus=%d",bonus); } 【程序3】
题目：一个整数，它加上100后是一个完全平方数，再加上168又是一个完全平方数，请问该数是多少？
1.程序分析：在10万以内判断，先将该数加上100后再开方，再将该数加上268后再开方，如果开方后的结果满足如下条件，即是结果。请看具体分析：
2.程序源代码：
#include "math.h" main() { long int i,x,y,z; for (i=1;i&lt;100000;i++) { x=sqrt(i+100); /*x为加上100后开方后的结果*/ y=sqrt(i+268); /*y为再加上168后开方后的结果*/ if(x*x==i+100&amp;&amp;y*y==i+268)/*如果一个数的平方根的平方等于该数，这说明此数是完全平方数*/ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cc454ff44e5da96f08904b989cbf2d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c434fa890772201532c87c5b913235c4/" rel="bookmark">
			在Linux中安装JDK和Tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装jdk1.8 1 下载网址：
Java Archive Downloads - Java SE 8u211 and laterhttps://www.oracle.com/java/technologies/javase/javase8u211-later-archive-downloads.html
2.在CentOS系统中上传下载好的jdk1.8，并且统一放在: /usr/soft目录下
（1）解压该软件:
tar -zxvf jdk-8uXXXX.tar.gz (2)重命名解压后的目录
mv jdk1.8.0_161/ jdk1.8 (3)配置jdk的环境变量
vi /etc/profile
export JAVA_HOME=/usr/soft/jdk1.8
export PATH=$PATH:$JAVA_HOME/bin
(4)刷新配置使其生效
source /etc/profile
2.安装tomcat 必须安装过jdk
（1）下载linux版本的tomcat
Apache Tomcat® - Apache Tomcat 8 Software Downloads (2) 把tomcat软件放到linux中
（3）解压
tar -zxvf apache-tomcat-8.5.90.tar.gz
（4）启动tomcat
cd /usr/soft/apache-tomcat-8.5.90/bin ----------进入tomcat文件夹中
./startup.sh ----------开启tomcat
(5) 查看进程
ps -ef | grep tomcat
结束进程:
kill -9 进程号|进程
(6) 访问tomcat
服务器IP:8080
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c434fa890772201532c87c5b913235c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3582086b03764046afcf61041ed2c4e0/" rel="bookmark">
			安装Lombok插件，代码仍然爆红的解决问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 提示：仅适用于使用Lombok插件但是代码仍然部分爆红，却不影响代码运行
一：Lombok是什么？ 是一个在Java开发过程中用注解的方式，简化了 JavaBean 的编写，避免了冗余和样板式代码而出现的插件，让编写的类更加简洁。 二：问题出现原因 是因为Lombok插件与其idea的版本不相匹配，从而导致爆红却不影响运行 三：解决办法 1.打开idea所在的文件夹，点击Plugin文件夹 2.找到lombok-plugin文件夹，点击lib 3. 点击lombok-plugin-0.34-2019.2.jar→打开jar包→选择META-INF文件夹→找到plugin.xml的配置文件 4.修改plugin.xml配置文件的第9行代码，将其since-build后面的数字改为自己使用的idea对应的版本号，保存，将修改后的plugin.xml文件与其META-INF文件夹中的plugin.xml文件进行替换 5.重启idea，问题解决 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5519b50e1a070975250e1e67298a23b7/" rel="bookmark">
			window10 查看本机TCP协议进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. netstat 是一个常见的网络工具，用于显示网络连接状态、路由表、接口统计信息等网络相关的信息，可以帮助诊断和解决网络问题。
其中，各参数的含义为：
-a：显示所有的网络连接和监听端口。
-e：显示以太网统计信息。
-n：不进行反向DNS查找，直接显示IP地址。
-o：显示与每个连接相关的进程ID。
-p Protocol：仅显示指定的协议（TCP、UDP、ICMP等）的网络统计信息。
-r：显示路由表信息。
-s：显示协议统计信息，例如TCP和UDP协议的数量、错误数等。
-t：仅显示TCP协议的连接。
interval：指定由命令输出的信息更新的时间间隔。
2. 查询443端口被占用的进程
netstat -aon | findstr 443
3.查询进程对应的任务或软件，命令 tasklist | findstr 19712 4.杀掉对应的进程，命令 taskkill /pid 20628
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92b2b5349ca639def89ae70f1311fc9c/" rel="bookmark">
			vue&#43;elementui el-upload 图片类型，大小，尺寸限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在el-upload控件中加入方法:
//accept="image/*" 进行图片类型的限制 &lt;el-upload ref="refUpload" :action="upload()" accept="image/*" :show-file-list="false" :on-success="fileSuccess" :on-progress="fileProgress"&gt; &lt;img v-if="ruleForm.previewAddressUrl":src="ruleForm.previewAddressUrl" class="avatar"&gt; &lt;i v-else class="el-icon-plus avatar-uploader-icon"&gt;&lt;/i&gt; &lt;/el-upload&gt; 2.在api文件引用接口
export function UploadViewIma() { return //接口地址 } 3.在方法中处理:
import { UploadViewIma } from "接口所在地址" &lt;script&gt; data() { return { ruleForm:{ previewAddressUrl:"" } } }, methods: { //返回上传地址 upload() { return UploadViewIma(); }, //图片格式校验 fileProgress(event, file, fileList) { let isImage = file.raw.type.includes("image"); if (!isImage) {// 检查文件类型 this.$message.error("预览图须是图片类型!"); this.$refs.refUpload.abort(); } let fileSize = parseInt(file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92b2b5349ca639def89ae70f1311fc9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e694a76c8d7eeefeb14e36901b33d95/" rel="bookmark">
			爆款视频生成器小程序源码搭建方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爆款视频生成器是一种可以帮助用户快速制作出高质量视频的工具。它可以根据用户提供的素材、模板和音乐等要素，自动生成一个精美的视频。这种工具可以大大节省用户的时间和精力，同时还能够提高视频制作的效率和质量，使视频更易于被观众接受和分享。常见的爆款视频生成器包括Canva视频制作、Animoto视频制作、Lumen5视频制作等。
小程序搭建方案 生成爆款视频的小程序涉及到视频处理、数据存储、服务器部署等多个技术领域，需要综合多种技术才能完成。下面是一些搭建方案供参考。
前端部分 小程序前端可以使用基于 Vue 或 React 的跨平台框架，如 Taro 或 uni-app。这些框架可以将编写的代码转化为小程序端可运行的代码，方便开发和维护。
视频处理部分 视频处理需要使用 FFMPEG 或其他类似的工具。可以使用 Node.js 中的相关模块进行处理，并通过云存储服务存储生成的视频文件。
数据存储部分 可以使用云数据库服务，如腾讯云的云数据库、阿里云的云数据库等，存储用户上传的视频及生成的爆款视频信息，方便后续统计分析和维护。
服务器部署 可以将前端部分部署在云服务器上，将视频处理部分和数据存储部分部署在云函数上，并使用 CDN 加速访问。
通过使用以上方案，可以构建出一个完整的小程序，实现爆款视频的生成和分享。不过具体的实现方式还需根据实际需求进行调整。
小程序端UI页面展示 爆款视频生成器小程序开发注意事项 ： 用户体验：小程序的用户体验非常重要，需要考虑用户的习惯和需求，让用户可以方便快捷地使用该小程序。
功能设计：小程序的功能设计应该能够满足用户的需求，例如为用户提供多种视频制作模板、视频编辑功能、素材库等。
视频制作效果：小程序提供的视频效果应该达到高质量标准，并且能够满足用户的需要，例如能够添加文字、特效、滤镜等。
代码质量：小程序的代码应该严格遵循规范，并且具有高可维护性，方便后期的维护和升级。
数据保护：小程序中的用户数据应该严格保护，防止泄露和被滥用。需要加强对用户信息进行加密和安全保护。
视频处理方式:--FFmpeg FFmpeg 是一个开源的跨平台视频和音频处理工具。它可以在不同的平台上进行编解码、转码、剪辑等操作。以下是一些使用 FFmpeg 处理视频的常见操作：
视频转码：将一个视频文件从一个格式转换为另一个格式。例如，将MP4文件转换为AVI文件。
视频剪辑：从一个视频中提取出一部分或删除一部分。例如，将一个长视频剪成多个短视频。
视频拼接：将多个视频文件合并为一个视频。例如，将多个MP4文件合并为一个MP4文件。
视频压缩：降低视频文件大小，而不影响其质量。例如，将一个1GB的视频文件压缩为500MB。
视频截图：从视频中提取一张或多张图片。例如，从一个视频中提取一张缩略图。
视频加水印：在视频上添加一个自定义的图像或文字。例如，在视频的右下角添加一个品牌标志。
视频旋转：将视频旋转以更好地适应屏幕或调整方向。例如，将一个竖屏录制的视频旋转为横屏。
开发代码展示（前端）： wx.getVideoInfo({ src: file.url, success: (videoInfo) =&gt; { console.log(videoInfo); if(videoInfo.bitrate &gt; that.data.bitrate){ wx.compressVideo({ src: file.url, bitrate:that.data.bitrate, fps: 30, resolution:1, success: (resp) =&gt; { console.log("aaaaa"); wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e694a76c8d7eeefeb14e36901b33d95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be791df4ad281e0b99f66164d9955d3c/" rel="bookmark">
			解决no main manifest attribute, in XXX.jar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决no main manifest attribute, in XXX.jar 1. 问题描述1.1 前言1.2 问题描述 2. 问题原因3. 解决问题3.1 修改pom文件3.2 重新启动3.3 再次查看META-INF/MANIFEST.MF3.4 小结 1. 问题描述 1.1 前言 创建一个简单的maven项目，pom配置如下：
1.2 问题描述 如下：no main manifest attribute, in cloud-eureka.jar 2. 问题原因 原因是找不到主类。
一般情况下，java 打包成 jar 包需要在 MANIFEST.MF 中指定 Main-Class项，以便运行 java -jar xxx.jar 时找到对应的主类。 具体如下：
3. 解决问题 3.1 修改pom文件 添加下面的配置，如下：
&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be791df4ad281e0b99f66164d9955d3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f726f6e8450d2778796360b332c2122/" rel="bookmark">
			【设计模式】用Java实现代理模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.代理模式介绍与使用场景 代理模式是一种结构设计模式，用于控制对其他对象的访问。在代理模式中，代理对象充当了被代理对象的接口，客户端通过与代理对象进行交互来间接访问被代理对象，从而可以在不改变客户端代码的情况下控制对被代理对象的访问。
代理模式的核心思想是通过引入一个代理对象来控制对目标对象的访问。代理对象与目标对象实现相同的接口，客户端通过与代理对象进行交互，代理对象在内部处理实际的请求，并可以在处理前后添加额外的逻辑。
代理模式适用场景：
远程代理（Remote Proxy）：当需要访问位于不同地址空间的远程对象时，可以使用代理模式来隐藏网络通信的细节。代理对象在客户端和远程对象之间充当中间层，负责处理网络通信和数据传输，使得客户端可以透明地访问远程对象。
虚拟代理（Virtual Proxy）：当创建一个对象的开销很大或者需要延迟对象的创建时，可以使用代理模式来延迟对象的实际创建。代理对象充当了虚拟对象的角色，只有在真正需要使用实际对象时才进行创建，从而提高系统性能和资源利用。
安全代理（Protection Proxy）：当需要控制对敏感对象的访问权限时，可以使用代理模式来限制对对象的访问。代理对象可以在实际对象的访问前后添加权限验证等安全措施，确保只有具有相应权限的客户端能够访问对象。
日志记录（Logging）：当需要记录方法的调用日志、监控方法的执行或添加额外的日志功能时，可以使用代理模式来在实际对象的方法执行前后进行日志记录和处理。
缓存代理（Caching Proxy）：当需要对一些昂贵的计算结果进行缓存，以提高系统性能时，可以使用代理模式来实现缓存。代理对象在接收到请求后，首先检查缓存中是否存在对应的结果，如果存在则直接返回缓存结果，否则将请求转发给实际对象，并将计算结果保存到缓存中。
总之，代理模式适用于需要控制对对象的访问、隐藏复杂性、提供额外功能、实现延迟加载或缓存等需求的场景。通过引入代理对象，我们可以在不改变客户端代码的情况下控制对目标对象的访问，并可以在访问前后添加额外的逻辑处理。
二.代理模式实现 下面写一个简单的demo描述一下代理模式：
// 接口：图片 interface Image { void display(); } // 目标对象：真实图片 class RealImage implements Image { private String filename; public RealImage(String filename) { this.filename = filename; loadFromDisk(); } private void loadFromDisk() { System.out.println("Loading image from disk: " + filename); } public void display() { System.out.println("Displaying image: " + filename); } } // 代理对象：图片代理 class ImageProxy implements Image { private String filename; private RealImage realImage; public ImageProxy(String filename) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f726f6e8450d2778796360b332c2122/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15545f47ece8e9a59eb92adbd3f06002/" rel="bookmark">
			GPT-AI-MJ绘画系统源码授权版分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近刚收集了一套非常好用的AI-GPT+MJ绘画功能的源码系统，经测试，系统流畅度稳定，符合当下日常运营需求，内置易支付接口。
演示站参考
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00f467419655004082cb81ea3927668d/" rel="bookmark">
			基于streamlit的Python Web可视化展示模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全国大学数据集
数据集
工作台 - Heywhale.com
工作台 - Heywhale.com 可视化界面
主函数
streamlit 启动 打开python文件对应的文件夹目录 使用streamlit run 对应的py文件 if __name__ == '__main__': f = open('t.txt', encoding='gbk') data = int(f.read()) if data == 0: st.title("全国大学可视化界面") data = login(data) print(data) if data == 1: with open("t.txt", "w") as f: f.write("1") 登录界面streamlit实现，这里streamlit框架是一直不断刷新，所以要用外部的控制刷新，或者跳转来解决
def login(date): if date == 0: # 显示登录表单 st.sidebar.subheader('登录界面') username = st.sidebar.text_input("用户名") password = st.sidebar.text_input("密码", type="password") # 处理登录逻辑 if st.sidebar.button("登录"): cursor = cnx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00f467419655004082cb81ea3927668d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/929fbec8ac6360338493c158b9a77fea/" rel="bookmark">
			Linux中配置sudo用户访问权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、如何在 Linux 中配置 sudo 的访问权限1.1、添加一个Linux普通用户有 sudo 权限1.2、测试普通用户的 sudo 权限1.3、添加多个Linux普通用户有 sudo 权限1.4、验证sudo 权限 一、如何在 Linux 中配置 sudo 的访问权限 1.1、添加一个Linux普通用户有 sudo 权限 [root@localhost ~]# useradd test // 创建一个普通用户为：test [root@localhost ~]# [root@localhost ~]# passwd test // 设置用户test密码为：test Changing password for user test. New password: # test BAD PASSWORD: The password is shorter than 8 characters Retype new password: # test passwd: all authentication tokens updated successfully. # 看到successfully 表示设置成功 [root@localhost ~]# [root@localhost ~]# id test uid=1000(test) gid=1000(test) groups=1000(test) [root@localhost ~]# [root@localhost ~]# vim /etc/sudoers .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/929fbec8ac6360338493c158b9a77fea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca4171e4af9cbadcaaa2a2dd40806296/" rel="bookmark">
			目标检测中NMS和mAP指标中的的IoU阈值和置信度阈值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候路走的太远，会忘了为什么要出发。
学习亦如是
在目标检测中，经常看到置信度阈值和IoU阈值这两个关键参数，且NMS计算和mAP计算中都会有这两个，那它们的区别是什么?本文就这个问题做一次总结。
NMS 模型预测会输出很多框，比如同一个目标会有很多框对应，NMS的作用是删除重复框，保留置信度分数最大的框。
在NMS算法中有一个置信度阈值c和IoU阈值u，简单回顾NMS算法如下：
对于一个预测框集合B（B中包含很多个预测框和它们对应的score）
找出B中score分数最高的M将M从B中删除将删除的M添加进最后的集合D将B中所有的box与M进行IoU计算，删除B中 IoU &gt; u的所有对应box
重复上面的步骤 最后D中的框就是保留下来的，留下的框中，删除掉低于score阈值的框，剩下的就是最终的预测框。
所以，这里的置信度阈值c是过滤掉预测框中置信度分数低于c的box；IoU阈值指的是拿出score分数最高框的其余框与score分数最高框的一个IoU比较。
注意到上面的NMS流程并没有对box的score做排序的过程。其实还有其它实现方式：
先对B中所有的box的score做排序，拿出score最高的box（这里当做M，从大到小排序就是首个box）放在别的list D，然后用B中其余的box分别与M计算IoU，去掉IoU &gt; u 的box重复上面步骤。 一样的，利用置信度阈值c对D中的box在做一次过滤，剩下的就是最后输出的。
对于利用置信度阈值c过滤，可以在没开始NMS前就做过滤，也可以在NMS后做过滤，这个不影响，看代码怎么实现。
Faster RCNN中的nms代码实现如下：
def py_cpu_nms(dets, thresh): #首先数据赋值和计算对应矩形框的面积 #dets的数据格式是dets[[xmin,ymin,xmax,ymax,scores]....] x1 = dets[:,0] y1 = dets[:,1] x2 = dets[:,2] y2 = dets[:,3] areas = (y2-y1+1) * (x2-x1+1) scores = dets[:,4] print('areas ',areas) print('scores ',scores) #这边的keep用于存放，NMS后剩余的方框 keep = [] #取出分数从大到小排列的索引。.argsort()是从小到大排列，[::-1]是列表头和尾颠倒一下。 index = scores.argsort()[::-1] print(index) #上面这两句比如分数[0.72 0.8 0.92 0.72 0.81 0.9 ] # 对应的索引index[ 2 5 4 1 3 0 ]记住是取出索引，scores列表没变。 #index会剔除遍历过的方框，和合并过的方框。 while index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca4171e4af9cbadcaaa2a2dd40806296/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41b34c1579980b303da5284d983bca82/" rel="bookmark">
			tensorRt部署原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详解tensorRT的高性能部署方案，并附有强大的yolov5、yolox、retinaface、arcface、scrfd、deepsort、alphapose的高性能实现，低耦合，哪来即可用，集成到项目中 repo地址：https://github.com/shouxieai/tensorRT_cpp YoloX-m@640x640 fp16@2080Ti性能：2.54ms / image, 每秒393.54帧
第1章 tensorRT介绍 1.1 tensorRt是什么 答：是:nvdia发布的dnn推理加速引擎。
tensorRT:nvdia发布的dnn推理加速引擎，是针对nvdia系列硬件进行优化加速、实现最大程度的利用GPU资源，提升推理性能。
1.2 tensorrt 方案介绍 Tensorrt构建模型的形式，即需要告知它你模型的架构和权重。那tensorRT提供基于C++接口和Python 接口的构建方案。那tensorrt各个版本有接口说明。通过api 你告诉它你模型需要的参数，结构，权重。
Tensorrt 提供的基础api 接口让你实现加速推理。为了方便起见，他们也提供更高级的使用方式，就是说你只需要把你的模型转换成onnx，它就可以直接转换成tensorrt的API.就是直接调用api,实现整个引擎的编译。
下面是3种常见路径。
Pytorch 到onnx 是pytorch 维护，也就是有新算子出来由官方维护。 Onnx到engine是 nvdia 来维护，即libnvonnxparser.so不断更新。
那编译也是很简单，就一句话。
第2章：使用TensorRT 的深度学习开发流程： 首先需要先训练深度学习网络框架，训练后会生成一个神经网络模型，然后可以指定 Batch-Size 和Precision 使用 TensorRT 进行优化，就是会得到一个优化后的推理引擎，将其序列化到磁盘，在使用时先进行反序列化，之后进行推理验证。
第3章 tensorrt加速优化原理 TensorRT能够加速的原因主要有两点，一方面是支持INT8和FP16的计算；另一方面是对网络结构进行了重构和优化
3.1 TensorRT支持INT8和FP16的计算 深度学习网络在训练时，通常使用 32 位或 16 位数据。TensorRT支持kFLOAT（float32）、kHALF（float16）、kINT8（int8）三种精度的计算，在使用时通过低精度进行网络推理，达到加速的目的。
3.2 TensorRT对网络结构进行了重构和优化 TensorRT对网络结构进行重构，把一些能合并的运算合并在一起，根据GPU的特性做了优化。具体表现在下面4个方面。
1 tensorRT通过解析网络模型将网络中无用的输出层消除以减小计算。
2对于网络结构的垂直整合，即将目前主流神经网络的conv、BN、Relu三个层融合为了一个层，例如将下图1所示的常见的Inception结构重构为图2所示的网络结构。
对网络的水平组合，水平组合是指将输入为相同张量和执行相同操作的层融合一起，如图2向图3的转化。 4去掉 concat 层，将原需输入 contact 层的直接送入 concat 下一级的操作中，不再单独进行 concat 步骤，相当于减少了一次传输吞吐量去掉concat层（
TensorRT中使用了一个新的操作——Concatenation操作来代替原有的concat层。Concatenation操作实现了多个tensor的拼接，但是采用了更加高效的实现方式，可以有效地减少计算和内存的占用，提高推理的速度和效率。
在TensorRT中，Concatenation操作可以对多个输入tensor进行拼接，并且可以指定拼接的维度，可以实现灵活的拼接操作。同时，TensorRT还支持对Concatenation操作进行多种优化，例如采用分块处理的方式，减少内存占用；采用流水线处理的方式，提高计算效率等等。这些优化可以进一步提高Concatenation操作的效率和性能。
。）
第4章Yolov5 使用tensorrt 部署步骤 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41b34c1579980b303da5284d983bca82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a13f28bad2856ac30c0ccefa7ed233b4/" rel="bookmark">
			Mybatis plus中遇到的分页查询报错问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人有一天被领导调去其他维护其他系统，对于mybatis的相关配置我也没全程参与（注意这里就是根源的起头）。
修bug的时候，遇到一个及其诡异的bug：我的service层调用mapper.xml中的分页查询sql时，居然报错了！！！
一开始我还以为是我sql写错了，经检查没发现什么异常，于是就拿到navicat中跑一下sql，也能成功跑出数据。
我当时的sql类似这样：
select t1.a, t1.b, t1.c, t2.x, t2.y, t2.z from user t1 left join role t2 on t1.id = t2.user_id where t1.b = "close" and t2.z = 0 我不竟在怀疑：难道是service到mapper.xml这一层传参传错了？
于是立马上手打断点，结果发现，一切正常，无论是service到mapper.xml还是在把这些参数传入的mybatis plus里，这些参数都正常。
唯一异常之处就在于sql日志输出输出了个类似这样的sql，而且提示找不到t2表及其对应的字段。
select count(*) from user t1 where t1.b = "close" and t2.z = 0 其中select count（*）我可以理解为mybatis plus 分页查询数据前做的总数查询。
可我sql里明明设置了left join role t2 on t1.id = t2.user_id 语句，为什么到执行的时候却没有？
难道有什么地方把我sql拦截了并做了什么奇怪的骚操作？
我带着这个疑惑，打着代码断点，一步一步地调试代码逻辑，最后我在mybatis plus 中PaginationInnerInterceptor类分页拦截器看到这一个方法
/** *获取自动优化的countSql *@parampage参数 *@paramsqlsql *@returncountSql */ protectedStringautoCountSql(IPage&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a13f28bad2856ac30c0ccefa7ed233b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3c221468104130a430ac39b49038ccc/" rel="bookmark">
			Python操控微信，实现微信机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自从微信禁止网页版登陆之后，itchat 库实现的功能也就都不能用了，那现在 Python 还能操作微信吗？答案是：可以！
在Github上有一个项目叫《WeChatPYAPI》可以使用 Python 对微信进行操控。简单来说，它是通过逆向PC端微信来实现对微信的操控，使用Python封装后调用更加简单！
Github地址：https://github.com/mrsanshui/WeChatPYAPI
码云地址：https://gitee.com/mrsanshui/WeChatPYAPI
拉取（好友/群/公众号）等列表 # 拉取列表（好友/群/公众号等） # 好友列表：pull_type = 1 # 群列表：pull_type = 2 # 公众号列表：pull_type = 3 # 其他：pull_type = 4 data = w.pull_list(pull_type=1) print(data) # 获取群成员列表 data = w.get_chat_room_members(to_chat_room="xxx@chatroom") print(data) 发送、接收、转发消息 # 发送文本消息 w.send_text(to_wx="filehelper", msg='你好鸭~') time.sleep(1) # 发送图片消息 w.send_img(to_wx="filehelper", path=r"C:\Users\Administrator\Desktop\1.png") time.sleep(1) # 发送卡片链接 w.send_card_link( to_wx="filehelper", title="我是卡片标题", desc="我是卡片描述啊啊啊啊啊啊啊啊啊啊", target_url="http://baidu.com", img_url="http://img.czdsh.com/Fsc_C6Rz5Sk7sblr_Q4YI0Y9v0zb" ) # 发送其他消息... # 处理消息回调 while True: msg = msg_queue.get() if msg["msg_type"] == 37: # 同意添加好友申请 w.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3c221468104130a430ac39b49038ccc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11484fcbf9929ff8a059868bb9b7ee82/" rel="bookmark">
			Spring高手4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring高手
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/119/">«</a>
	<span class="pagination__item pagination__item--current">120/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/121/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>