<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9877641f7ae4ea0d4efae06671a21357/" rel="bookmark">
			Redis缓存架构详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Redis缓存结构详解前言Redis 缓存架构redis 和db数据一致性先写db还是写redis如果是先写db,再删除缓存呢？延迟双删 简单的缓存,并发不高,没啥流量简单的缓存,并发高,但是存在redis和 Db 双写不一致,读写并发不一致问题解决方案 1解决方案 2解决方案 3读写锁 缓存构建解决方案 1 加分布式锁解决方案 2 dcl 双重校验解决方案 3 定时器兜底 双重校验以及防止大流量从缓存构建 多级缓存缓存穿透方案 1方案 2 缓存雪崩 Redis缓存结构详解 前言 一般开发中我们都会使用 Redis 作缓存，提高查询效率，但 Redis 缓存在使用时还会有很多问题，如，缓存穿透，击穿，雪崩等。
一般对于不同的业务我们使用不同的缓存结构。
1、对于并发几率很小的数据(如个人维度的订单数据、用户数据等)，这种几乎不用考虑这个问题，很少会发生 缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。
2、就算并发很高，如果业务上能容忍短时间的缓存数据不一致(如商品名称，商品分类菜单等)，缓存加上过期 时间依然可以解决大部分业务对于缓存的要求。
3、如果不能容忍缓存数据不一致，可以通过加分布式读写锁保证并发读写或写写的时候按顺序排好队，读读的 时候相当于无锁。
4、也可以用阿里开源的canal通过监听数据库的binlog日志及时的去修改缓存，但是引入了新的中间件，增加 了系统的复杂度。
Redis 缓存架构 首先，我们在开发中经常这么写，先从 redis 查询，redis没有再从db查，一般都是这么写的，但是不同业务对数据一致性和实时性要求很高，一些业务又不需要特别强的一致性，有一些又需要强一致性，对此我们再使用 Redis 做缓存时候需要针对不同业务提供不同的缓存架构。
这里逐步对数据一致性和性能以及并发问题，用 Redis 做为缓存，针对不同业务模型使用 Redis逐级递增。
redis 和db数据一致性 先写db还是写redis 先更新redis还是先更新db，无论更新那个都存在问题。
1 双写不一致
线程 1 写数据稍微慢点，中间有线程 2 更新成功，此时线程 1 再更新成功，对于线程 2 来说缓存还是旧数据，同理先更新reids再db也是一样的。
如果是先写db,再删除缓存呢？ 读写并发不一致问题
t1 更新 a=7提交成功,删除缓存，t2更新a=6删除db，此时 t2 还没提交事务，t3查缓存a=7 ，此时t2在t3更新缓存之前更新成功同时也删除缓存，t3最后更新了缓存。缓存数据还是7 相比t2操作就是脏数据了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9877641f7ae4ea0d4efae06671a21357/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa4f0ec2822091aceb65119a90df6a93/" rel="bookmark">
			Vue基础知识汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.初识Vue
二.Vue模板语法
三.数据绑定
四.el与data的两种写法
五.MVVM模型
六.Vue中的数据代理
七.事件处理
事件的基本使用：
Vue中的事件修饰符：
键盘事件：
八.计算属性
九.监视属性
监视属性watch：
深度监视：
computed和watch之间的区别：
十.绑定样式
十一.条件渲染
十二.列表渲染
v-for指令:
react、vue中的key有什么作用？（key的内部原理）
Vue监视数据的原理：
十三.收集表单数据
十四.过滤器
十五.内置指令
我们学过的指令：
v-text指令：
v-html指令：
v-cloak指令（没有值）：
v-once指令：
v-pre指令：
十六.自定义指令
十七.生命周期
常用的生命周期钩子：
关于销毁Vue实例
十八.非单文件组件
Vue中使用组件的三大步骤：
几个注意点：
关于VueComponent：
一.初识Vue 1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；
2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；
3.root容器里的代码被称为【Vue模板】；
4.Vue实例和容器是一一对应的；
5.真实开发中只有一个Vue实例，并且会配合着组件一起使用；
6.{{xxx}}中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；
7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；
注意区分：js表达式 和 js代码(语句)
1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：
(1). a
(2). a+b
(3). demo(1)
(4). x === y ? 'a' : 'b'
2.js代码(语句)
(1). if(){}
(2). for(){}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa4f0ec2822091aceb65119a90df6a93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35c627759e8038646a73d388d9c126da/" rel="bookmark">
			Chrome“喔唷，崩溃啦！”内存不足引起页面崩溃的原因和解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
还“喔唷，崩溃啦”？卖萌也没有用，你不行还不改，那我只好另请高明了。使用火狐浏览器可以避免此问题。
问题描述：
虽然很少遇到，但确实只要Chrmoe单个页面占用内存超过4G就会崩溃并报这个错，用换皮Edge也是一样。
问题详解：
官方论坛：Limit of 4 GB per tab in 64 bit Chrome?
说白了就是都2023年了，Chrome还抱着每个页面最多4G内存的限制不放，2014年起就有好多用户在官方论坛提出来了，官方还在那里嘴硬不愿意改。最后有用户猜测这个老套的限制可能跟Chrme底层有关，要改就得大改。
问题解决：
没有什么神奇的命令和方法可以解决，只能换没有4G内存限制的FireFox浏览器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f3dc499f2484920fda72050dbfa8c02/" rel="bookmark">
			Java 高级篇：JVM 垃圾回收机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 语言的一大优势在于其具有自动垃圾回收（Garbage Collection，GC）机制，让开发者无需关心内存的分配与释放。
本文将详细解析 JVM（Java Virtual Machine）中的垃圾回收机制，带你深入了解 GC 如何运作，以及如何优化垃圾回收性能。
一、垃圾回收基本原理
在 Java 语言中，对象的内存空间由 JVM 自动管理。当 JVM 确定某个对象不再被使用时，它将自动回收这个对象所占用的内存。这种自动回收内存的机制称为垃圾回收。
垃圾回收的主要任务包括两个方面：
发现无用对象：JVM 通过对象的可达性分析来判断对象是否仍在使用。如果一个对象不再被其他对象引用，那么它就被认为是无用的，可以被回收。
回收无用对象所占用的内存：JVM 释放无用对象所占用的内存，以便其他对象使用。
二、JVM 内存结构
要了解垃圾回收机制，首先要了解 JVM 的内存结构。JVM 将内存划分为以下几个区域：
堆（Heap）：存储对象实例，是垃圾回收的主要区域。
方法区（Method Area）：存储已被加载的类信息、常量、静态变量等数据。
栈（Stack）：存储局部变量表、操作数栈、动态链接、方法出口等信息。
程序计数器（PC Register）：存储当前线程执行的字节码行号。
垃圾回收主要针对堆和方法区进行。
三、垃圾收集器（Garbage Collector）
JVM 提供了多种垃圾收集器，它们各自采用不同的算法，以满足不同场景的需求。常见的垃圾收集器有：
Serial Collector：单线程收集器，适用于客户端应用。
Parallel Collector：多线程收集器，适用于多核服务器端应用。
CMS（Concurrent Mark Sweep）收集器：并发收集器，适用于对响应时间有较高要求的应用。
G1（Garbage-First）收集器：基于区域划分的收集器，适用于大内存应用。
四、垃圾回收算法
标记-清除（Mark-Sweep）算法:
标记-清除算法分为两个阶段：标记阶段和清除阶段。在标记阶段，垃圾收集器遍历堆中的对象，将不再使用的对象进行标记。在清除阶段，垃圾收集器将标记的对象从内存中移除。标记-清除算法的主要缺点是内存碎片化，可能导致后续对象分配时找不到足够的连续内存。
标记-整理（Mark-Compact）算法:
为解决标记-清除算法的内存碎片化问题，标记-整理算法在清除阶段进行了优化。在标记阶段与标记-清除算法相同，都是对不再使用的对象进行标记。然而，在清除阶段，标记-整理算法会将存活的对象压缩到内存的一端，从而避免内存碎片化。这种算法的缺点是移动对象的开销较大。
复制（Copying）算法:
复制算法将堆内存分为两个相等的区域，每次只使用其中一个区域。
当这个区域的内存用完时，垃圾收集器会将存活的对象复制到另一个区域，并将已使用区域清空。这种算法避免了内存碎片化和对象移动的问题，但代价是可用内存空间减半。
分代收集（Generational Collection）算法:
大部分对象的生命周期都很短暂，因此分代收集算法将堆内存划分为新生代和老年代。新生代使用复制算法，老年代使用标记-整理算法。
当对象在新生代中经历了一定次数的垃圾回收后，它将被晋升到老年代。分代收集算法充分利用了对象生命周期的特点，提高了垃圾回收的效率。
五、垃圾回收实战与优化:
为了更好地理解垃圾回收机制及优化方法，我们使用一个简单的 Java 程序来模拟内存泄漏。
import java.util.ArrayList; import java.util.List; public class GCDemo { public static void main(String[] args) { List&lt;Object&gt; objects = new ArrayList&lt;&gt;(); while (true) { objects.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f3dc499f2484920fda72050dbfa8c02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ab5059503449253a358f540075d1d6d/" rel="bookmark">
			Opencart journal 3.1.12模板免费使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优点：
非常优秀的一款独立站模板，任意调节每一个元素，哪个行业的站都能做的高大上，做在线商城，做企业站都非常好用。
应用效果图：
提示：官网比较贵，网上免费的版本基本都是2.*的老版本，这3.*的版本比2要优秀太多了，每个细节都能个性化配置，用来做各种大站都是非常优秀。
1、Journal官网：
Journal 3 - Most Advanced Opencart Framework
2、线上说明文档：
General Information | Journal Docs
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86454497db1c2e81d9582977f2c973f7/" rel="bookmark">
			用PHP实现在不破坏原有的英文单词的情况下在字符串中随机位置插入新字符串的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function insertString($originalStr, $insertStr) { // 获取原始字符串长度 $length = strlen($originalStr); // 随机生成插入位置 $insertPosition = rand(0, $length); // 判断插入位置是否处于英文单词中间 $wordBoundary = preg_match("/\b/", substr($originalStr, $insertPosition - 1, 2)); if ($wordBoundary == 0) { // 如果插入位置不处于英文单词中间，则插入字符串 $newStr = substr_replace($originalStr, $insertStr, $insertPosition, 0); return $newStr; } else { // 如果插入位置处于英文单词中间，则重新生成插入位置 return insertString($originalStr, $insertStr); } } 使用方法：
$originalStr = "This is a test string."; $insertStr = "inserted"; $newStr = insertString($originalStr, $insertStr); echo $newStr; // 输出类似 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86454497db1c2e81d9582977f2c973f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f1da95cc40bf1e81f03f56a3aa5677b/" rel="bookmark">
			opencv(c&#43;&#43;) 使用minAreaRect 获得最小外接矩形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载链接：https://www.cnblogs.com/little-monkey/p/7429579.html
一、简介
二、轮廓最小外接矩形的绘制
#include "opencv2/opencv.hpp" using namespace cv; void main() { //轮廓最小外接矩形的绘制 Mat srcImg = imread("E://00.png"); Mat dstImg = srcImg.clone(); cvtColor(srcImg, srcImg, CV_BGR2GRAY); threshold(srcImg, srcImg, 100, 255, CV_THRESH_BINARY); //二值化 imshow("threshold", srcImg); vector&lt;vector&lt;Point&gt;&gt; contours; vector&lt;Vec4i&gt; hierarcy; findContours(srcImg, contours, hierarcy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE); vector&lt;Rect&gt; boundRect(contours.size()); //定义外接矩形集合 vector&lt;RotatedRect&gt; box(contours.size()); //定义最小外接矩形集合 Point2f rect[4]; for(int i=0; i&lt;contours.size(); i++) { box[i] = minAreaRect(Mat(contours[i])); //计算每个轮廓最小外接矩形 boundRect[i] = boundingRect(Mat(contours[i])); circle(dstImg, Point(box[i].center.x, box[i].center.y), 5, Scalar(0, 255, 0), -1, 8); //绘制最小外接矩形的中心点 box[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f1da95cc40bf1e81f03f56a3aa5677b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01b4f8824fc4134458e98a2a531e72de/" rel="bookmark">
			逻辑斯蒂回归（二分类算法）理论&#43;Python代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逻辑斯蒂回归（二分类算法）理论+Python代码实现 文章目录 逻辑斯蒂回归（二分类算法）理论+Python代码实现一、理论基础（一） 基于 Logistic 回归和 Sigmoid 函数的分类（二） 模型训练与代价函数 二、算法实现（skic-learn调库）三、从零实现案例（非调库函数实现） 一、理论基础 逻辑回归 Logistic Regression又名 Logit Regression.通常用来估计样本属于某一类的概率。
p ^ = h θ ( x ) = σ ( θ T x ) \hat p = h_\theta(x) = \sigma(\theta^Tx) p^​=hθ​(x)=σ(θTx)
Logistic回归的一般过程
(1) 收集数据：采用任意方法收集数据。
(2) 准备数据：由于需要进行距离计算，因此要求数据类型为数值型。另外，结构化数据格式则最佳。
(3) 分析数据：采用任意方法对数据进行分析。
(4) 训练算法：大部分时间将用于训练，训练的目的是为了找到最佳的分类回归系数。
(5) 测试算法：一旦训练步骤完成，分类将会很快。
(6) 使用算法：首先，我们需要输入一些数据，并将其转换成对应的结构化数值；
接着，基于训练好的回归系数就可以对这些数值进行简单的回归计算，判定类别；在这之后，我们就可以在输出的类别上做一些其他分析工作。
（一） 基于 Logistic 回归和 Sigmoid 函数的分类 Logistic回归:
优点：计算代价不高，易于理解和实现。
缺点：容易欠拟合，分类精度可能不高。
适用数据类型：数值型和标称型数据。
Logistic回归分类器:【概率估计】
我们可以在每个特征上都乘以一个回归系数，然后把所有的结果值相加，将这个总和代入Sigmoid函数中，进而得到一个范围在0~1之间的数值。任何大于0.5的数据被分入1类，小于0.5即被归入0类。
其分布函数 σ ( t ) \sigma(t) σ(t)为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01b4f8824fc4134458e98a2a531e72de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fa417e430815f9fd6733b642c1baf51/" rel="bookmark">
			博客摘录「 Xilinx FPGA管脚XDC约束之：物理约束」2023年5月17日
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		端口名称为数组时，需要用{}括起来，端口名不能为关键字。
差分信号约束，只约束P管脚即可，系统自动匹配N管脚约束，当然_P和_N管脚都约束也没有问题；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/004e2fdecf0337dbac81a608e345ffea/" rel="bookmark">
			NGINX 和 HAProxy：基于公有云标准环境的用户体验测试对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文作者：Amir Rawdat of F5
原文链接：NGINX 和 HAProxy：基于公有云标准环境的用户体验测试对比
转载来源：NGINX 官方网站
业内许多性能基准测试，都是基于峰值吞吐量或每秒请求数 (RPS)，但这些指标可能会过分简化实际站点的性能情况。以峰值吞吐量或接近峰值吞吐量运行其服务的企业寥寥无几，因为无论采用哪种方式，10% 的性能变化都会产生重大影响。站点所需的吞吐量或 RPS 不是无限的，而是取决于外部因素，例如站点必须服务的并发用户数量和每个用户的活跃程度。最终重要的是您的用户能够获得最佳服务。最终用户并不在乎有多少人正在访问您的站点。他们只在意自己所获得的服务，而且他们无法接受因系统过载而导致的性能低下。
因此，对于企业真正重要的是，即使在高负载下也要能为所有用户提供持续的低延迟的可靠性能。在对比作为反向代理运行于 Amazon Elastic Compute Cloud (EC2) 之上的 NGINX 和 HAProxy 时，我们从以下两方面着手探讨：
测量这两种代理可以可靠处理的负载水平计算延迟指标百分位数的分布情况，这是与用户体验最直接相关的指标 测试程序和收集的指标 我们使用压测工具 wrk2 模拟了一个客户端，在规定的时间段内发出连续的 HTTPS 请求。被测系统（HAProxy 或 NGINX）充当反向代理，与 wrk 线程模拟的客户端建立加密连接，将请求转发到运行 NGINX Plus R22 的后端 Web 服务器，Web 服务器将生成的响应（一个文件）返回给客户端。
这三个组件（客户端、反向代理和 Web 服务器）都在Ubuntu 20.04.1 LTS， EC2 的 c5n.2xlarge Amazon Machine Image (AMI) 实例上运行。
如上所述，我们从每次测试运行中收集了完整的延迟指标百分位分布。延迟指标是指客户端从生成请求到接收响应所用的时间。延迟百分位分布会将测试期间收集的延迟测量值从高到低（即从延迟时间最长到最短）进行排序。
测试方法 客户端 借助 wrk2（版本 4.0.0），我们在 Amazon EC2 实例上运行以下脚本：
关于此处的代码内容，请点击文章《NGINX 和 HAProxy：基于公有云标准环境的用户体验测试对比》进行查看。
为了模拟多个客户端访问 Web 应用，我们生成了 4 个 wrk 线程，这些线程共与反向代理建立 100 个连接。在 30 秒的测试运行期间，该脚本生成了指定数量的 RPS。这些参数对应于以下 wrk2 选项：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/004e2fdecf0337dbac81a608e345ffea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3fd20218d1096135883fd7c3238071a/" rel="bookmark">
			GPT-5: 超越人类语言的模型，你还不了解一下?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、GPT-5时代引领者
二、技术特性 1，音频和视频处理 — 更强大的多模态处理能力
2，GPT-5颠覆影视制作：重写媒体消费时代
3，为机器人提供智慧大脑
4，更强的垂直行业应用
三、回顾一下GPT5被紧急叫停？幕后发生了什么事
GPT5来了！
彻底颠覆传统的影视制作方式、为机器人提供AI大脑、搭建虚拟世界预测未来，生活接入智能生态！
GPT-5的封禁期马上结束，最早今年6-7月就会有GPT-5的功能陆续放出来。
准备好迎接GPT5时代了吗?
一、GPT-5时代引领者 GPT-4都强到发指，那GTP5又该强大到什么地步？
GPT-5其规模是GPT-4的两倍，性能提高一倍。
GPT-5具有自我学习能力：能够根据上下文的不断变化的来调整其输出，从而提高模型的性能和粗壮性，为人工智能技术在自然语言处理领域的应用带来更为广阔的前景。
GPT-5已经完整浏览了人类网络上所有的视频（大约2000PB的数据容量）。
能够即时标注它所浏览过的所有视频中的声光信息，精确到每秒。 准备好迎接GPT5时代了吗?
二、技术特性 其进化速度可谓接近指数级别。
这意味着什么？
1，音频和视频处理 — 更强大的多模态处理能力 较于GPT-4，GPT-5具备更强大的数据理解与制造能力，GPT-5对于多模态解析方面表现更为出色。
GPT-5不仅继承了GPT-4的文本和图像处理功能，还加入了音频和视频处理服务。
这种能力使得GPT-5能够准确地分析各种材料，并生成连贯的上下文，从而更好地理解和推断数据的内在含义。
此外，GPT-5还具备翻译多种文本和生成总结摘要的能力，为数据处理和应用提供更多的可能性和效率。
相较于类似Stable Diffusion等图像模型，多模态模型的最大区别在于其对图像内容的理解能力。
据OpenAI的论文显示，GPT-4已经具备了理解图像中逻辑和幽默感的能力，例如当VGA接口插入手机时会引起笑声。
当前，GPT-5的多模态能力已经具备图片处理能力，而其视频处理能力将会进一步提升多模态能力，达到接近人类的程度。
举个栗子：
可以试想一下，对着GPT-5输入一个有趣的gril，再加上GPT-5的联网能力为用户自动生成包括3D模型、视频、文字、音频等多种形式的内容，这些内容将会基于当下最流行的内容进行创作，以满足用户的需求。
这种技术的应用将会为人类带来更为智能化、个性化的内容体验，为人工智能技术在多媒体内容生成和自然语言处理领域的应用提供更多的可能性。
2，GPT-5颠覆影视制作：重写媒体消费时代 OpenAI Startup Fund对Descript的投资表明GPT-5技术具有将人工智能技术引入影视创作领域的潜力。
这种技术将可能彻底颠覆传统影视制作的方式，开启全新的交互式媒体时代。
通过GPT-5的能力，影视创作者可以使用自然语言与机器交互，实现更为智能和高效的制作流程。
GPT-5具备理解用户拍摄的影像、感知用户需要表达的情绪、构图并提供拍摄建议、创造特效等能力，从而提高视频内容的真实性和人机交互的自然性。
传统的故事创作方式往往是单向的，观众只是故事的被动接收者。
而GPT-5的能力则使得观众可以成为故事的共同创造者。
通过对观众反馈的实时记录和分析，GPT-5可以不断演绎新的故事情节，为观众带来更加丰富和个性化的故事体验。
举个栗子：
未来，由GPT-5生成的电影将具备根据观众的表情、动作和反应不断调整后续剧情发展的能力，并真正实现个性化交互体验。
3，为机器人提供智慧大脑 机器人的智能化关键在于其拥有自主的AI大脑，而GPT-5的能力恰好能够满足这一需求。
其具备深度学习和模式识别的能力，能够帮助机器人更好地理解和处理人类的语言、情感等行为。
通过GPT-5的处理，机器人可以获取更加准确和全面的信息，实现更为智能和高效的操作和决策。
这种技术的应用将推动人工智能技术在机器人和自然语言处理领域的发展，为机器人在日常生活中的应用提供更多的可能性和创新。
这意味着未来的机器人可以更加智能化地与人类进行交互，更好地理解人类的需求和意图，提高机器人的服务质量和效率。
机器人还可以在家庭、医疗、制造等领域广泛应用，为人类带来更多的便利和福利。
举个栗子：
人类可以通过简单描述任务的要求来让机器人完成任务。
4，更强的垂直行业应用 GPT-5作为一种具有广泛应用前景的人工智能技术，将在多个领域带来深远的变革。
在医疗领域，GPT-5的个性化治疗方案能力将彻底改变传统的诊断和治疗模式，为患者提供更为精准和个性化的医疗服务。
在法律领域，GPT-5将结合其对无数法律文本的学习，展现无与伦比的逻辑性和推导能力，为法律领域带来更高效、更准确的法律服务。
在气候科学领域，GPT-5将利用其数据分析和模式识别能力，分析卫星图像、历史气候数据和复杂模型，为应对气候变化提供更科学、更准确的依据。
在商业领域，GPT-5将颠覆组织的运作和竞争方式，带来自动化运营、优化供应链和新的商业模式，为商业模式的革新提供支持。
三、回顾一下GPT5被紧急叫停？幕后发生了什么事 关于GPT-5的停止训练， GPT-5 的开发被紧急叫停，引起学界和业界对 AI 是否会对人类构成威胁的关注。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3fd20218d1096135883fd7c3238071a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fd50b608e26454dd9135e7f3882f0cc/" rel="bookmark">
			uniapp 使用vuex
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根目录新建 store目录，再store下新建index.js
import Vuex from 'vuex' import Vue from 'vue' Vue.use(Vuex) const Store = new Vuex.Store({ state:{ giftList:[] }, getters:{}, mutations:{ SET_GIFT:(state,payload)=&gt;state.giftList = payload }, actions:{}, modules:{} }) export default Store 在main.js引入store
import store from "./store/index.js" Vue.prototype.$store = store const app = new Vue({ store, ...App }) 在A组件给gift赋值
import { mapState, mapMutations } from 'vuex' //取giftList computed: { ...mapState(['giftList']), }, methods:{ ...mapMutations(['SET_GIFT']), //引入store方法 //给giftList赋值 onGift(){ let data = { name: '代代', id: 1 } const arr = [.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fd50b608e26454dd9135e7f3882f0cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4db5516e29b80666ee2b924e3786c16/" rel="bookmark">
			js数字转换为万单位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 export function formatNumber(num) { num = Number(num); if (num == 0 || (num &gt; 0 &amp;&amp; num &lt; 10000)) { return num + ''; } else { return (num / 10000).toFixed(2) + '万'; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2b4043bfee079a969cc57a31d641603/" rel="bookmark">
			Windows server磁盘脱机和联机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Windows Server中,可以通过Disk Management实用工具将磁盘脱机和联机。
脱机和联机 打开“磁盘管理”工具。可以通过服务管理器-&gt;存储-&gt;磁盘管理进入,或在命令行输入diskmgmt.msc打开。定位到需要脱机或联机的磁盘。在右侧可以看到磁盘的状态,如“联机”或“脱机”。右键单击磁盘,选择“脱机”将其脱机,或选择“联机”将脱机磁盘联机。确认要更改磁盘为所选状态。脱机磁盘将变为“脱机”状态;联机磁盘将变为“联机”状态。 需要注意: 无法脱机系统磁盘和启动磁盘。脱机磁盘不可访问,磁盘中的数据在脱机期间暂不可用。需要时需手动将其联机,才能使用磁盘和访问数据。即使磁盘为“联机”状态,如果没有分区或格式化,也无法实际使用磁盘空间。需要对磁盘进行初始化和创建卷后才能使用。重复执行脱机和联机也可能导致磁盘数据受损,应避免频繁更改磁盘状态。若磁盘可疑损坏,可先将其脱机后再进行检修或更换,以防数据遭损坏。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a5a227966ed894c8cfe56e2ba3a74c8/" rel="bookmark">
			青龙面板最全依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 NodeJs 依赖 ds json5 js-base64 require tough-cookie jsdom global-agent @types/node typescript dotenv jsdom -g form-data png-js ts-md5 tslib jieba ws@7.4.3 axios date-fns moment prettytable fs crypto-js ts-node depend ds jsdom requests npm node-jsencrypt -g npm cjs upgrade pip common qs ql crypto -g -g typescipt https proxy agent python3 依赖 pycryptodome pytz typescript httpx success --upgrade pip pip redis jieba canvas requests ping3 PyExecJS Linux依赖（安装失败的忽略） gcc g++ python3-dev libc-dev 如果出现多个安装失败，可以手动一个一个安装。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e859a3d470bafcfb258bb0fb11835c27/" rel="bookmark">
			keil MDK5插件推荐——Astyle代码格式化插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 代码格式化是提高代码质量和可读性的重要手段之一。然而，在Keil MDK5中并没有内置代码格式化工具，因此需要寻找第三方工具来解决这个问题。开源的代码格式化工具Astyle能以插件的形式集成到Keil中以满足我们对代码格式化的需求。
本文将详细介绍如何下载、配置Astyle，并在Keil中设置Astyle，以及使用快捷键调用Astyle的方法。
一. Astyle介绍 Astyle官网：https://astyle.sourceforge.net/
Artistic Style 是一种用于 C、C++、C++/CLI、Objective-C、C# 和 Java 编程语言的源代码缩进器、格式化程序和美化程序。它用 C++ 编写，可以从命令行中使用，也可以被嵌入到另一个程序中作为库。选项可以从命令行或选项文件中输入。库版本可以从用其他语言编写的程序中调用。
Artistic Style 为开源软件，可以在 MIT 许可证下使用和分发。MIT 许可证是一种对软件使用最少限制的宽松许可证。它与 GNU 通用公共许可证 (GPL) 和大多数其他许可证兼容。
从官网可以进入Astyle的文档和下载界面。
二. Astyle常用配置 此节完全参考Astyle的Documentation，但仅列出了我了个人感兴趣的关于C语言的配置选项，对于其它的C语言配置选项以及其它语言配置选项均未列出，对全部配置选项感兴趣的同学可去官网看文档。
2.1 Brace Style Options（花括号样式选项） 1.–style=allman / --style=bsd / --style=break / -A1
​ Allman样式使用折行的大括号。
2.–style=java / --style=attach / -A2
​ Java样式使用紧挨着的大括号。
3.–style=kr / --style=k&amp;r / --style=k/r / -A3
​ Kernighan &amp; Ritchie样式使用Linux风格的花括号。命名空间、类和函数定义的左花括号是单独一行的。花括号与其他所有内容都相连，包括函数内的数组、结构、枚举和语句。
​ 使用k&amp;r选项可能会因为&amp;符号而导致问题。可以通过将k&amp;r用引号括起来（例如 ‑‑style=“k&amp;r”）或使用其中一个备选项（‑‑style=kr或‑‑style=k/r）来解决此问题。
4.–style=1tbs / --style=otbs / -A10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e859a3d470bafcfb258bb0fb11835c27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9870194c4cc2ed56f080f0191ca9797d/" rel="bookmark">
			eclipse连接SQLserver
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		就是最近学习JDBC(Java PataBase Connectivity)数据库编程,结果发现连接都连接不上去,
我就先将自己的想法和流程说一下,就是我现在是连接上了,但是之前也没成功,然后这没成功的原因我还是不太知道.网上很多资料感觉都和我看到不一样,就一个JDK安装的目录,我目录下面都没有那些文件,还有就是Telnet服务的开始,现在在服务里面都没有找到这个,但是他是可以直接用的.
目录
下载 Microsoft JDBC Driver:
SQLserver的准备:
eclipse软件中的运行:
下载 Microsoft JDBC Driver: 先查看一下自己JDK的版本,这个好像关系也不是很大,不过我还是注意了一下.
先win+R,输入cmd进入命令提示符,然后输入下面的指令,查看java的版本,这里的'-'是需要有,不然他的意思就是把version当成一个字节码文件.
java -version 这里可以查看到我的java version是17版的,然后进入这个网址,页面的下面也有详细的说明.系统要求 - JDBC Driver for SQL Server | Microsoft Learnhttps://learn.microsoft.com/zh-cn/sql/connect/jdbc/system-requirements-for-the-jdbc-driver?view=sql-server-ver16
从这里就知道了将要下载的Microsoft JDBC Driver版本,登入这个网址找到自己的,他这个都是压缩包,我这里选择的是.zip格式的.发行说明 - JDBC Driver for SQL Server | Microsoft Learnhttps://learn.microsoft.com/zh-cn/sql/connect/jdbc/release-notes-for-the-jdbc-driver?view=sql-server-ver16#previous-releases
下载之后就可以解压,解压得到下面的这些文件.jar文件,根据前面的说明,我们这里选择mssql-jdbc-10.2.3.jre17.jar直接复制.
SQLserver的准备: 这个我也不确定是不是要下载SQLserver软件,因为我是已经下载了SQLserver软件的,详细安装可以查看这个SQL Server安装教程_不来虚的，脚踏实地的博客-CSDN博客https://blog.csdn.net/weixin_53337941/article/details/123604444
先就是登录SQLserver,最开始是Windows身份验证登录的,咱先登录进入,服务器的名称可以是电脑的设备名称,也可以是127.0.0.1(环回地址)或者是localhost,以及0.0.0.0.这里的话我是用设备名称登录的,所以其他的方法没试过.如果登录失败可以是安装的时候,数据库引擎安装失败,这种我就是删掉从新安装,删除的时候一定要删干净.反正如果卸载不成功安装还是会失败,下面链接大家可以参考一下,我当时是先关闭服务,然后通过控制面板找到今天安装的SQLserver,再通过CCleaner来修复注册表.最后重启电脑,这是我当时的操作,当时就是重复了几次才安装好,在安装的时候把杀毒软件也关了,我当时是把火绒安全关闭开始安装的.彻底卸载SQL Server_sqlserver数据库卸载_未来的四只猫的博客-CSDN博客https://blog.csdn.net/weixin_43808666/article/details/87864369
登录之后找到sa,右键选择属性,选择SQLserver身份验证.设置密码登操作,最后确定.
关闭SQLserver软件,重新登录选择SQLserver身份验证.
然后自己建一个库,建一个表.接下来会用到.https://blog.csdn.net/zys_shan/article/details/104897503https://blog.csdn.net/zys_shan/article/details/104897503
解决SQL server默认1433端口telnet不通的情况。我同学发现自己的端口打开出现了错误，自己的ip可以ping通，但是telnet无法连接，然后是通过这下面的方案解决的。（第二个提供了遇到各种情况的分析）
SQ LServer默认1433端口telnet不通的解决办法 - 民工黑猫 - 博客园 (cnblogs.com)https://www.cnblogs.com/yyee/p/14249983.html系统安装SQL Sever2000后1433端口未开放，如何打开1433端口的解决方法-蒲公英云 (dandelioncloud.cn)https://www.dandelioncloud.cn/article/details/1509374344169074690
eclipse软件中的运行: 新建一个包和一个类,把.jar文件也粘贴进去.然后通过下面的操作形成奶瓶图标的文件.这个网上是说选下面一个Configure Build Path...,但是我那个Libraries下面的Add都是灰色的,选中不了.
灰色的,选中不了,就只能用上面的方法来添加.
配置设置好了接下来就是代码部分.
//连接数据库的url private static final String url="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9870194c4cc2ed56f080f0191ca9797d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be6503d7b7dd04c7ca36417e38578780/" rel="bookmark">
			Liunx压缩命令 - zip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zip命令 – 压缩文件 zip命令的功能是用于压缩文件，解压命令为unzip。通过zip命令可以将文件打包成.zip格式的压缩包，里面会包含文件的名称、路径、创建时间、上次修改时间等等信息，与tar命令相似。
语法格式：zip 参数 目标文件.zip 源文件或目录名
常用参数：
参数功能操作实例-A自动解压缩文件zip -A archive.zip-b设置暂存文件的目录zip -b /tmp archive.zip file.txt-c添加注释信息到压缩文件zip -c archive.zip file.txt -z "This is a comment"-d更新压缩包内文件zip -d archive.zip file.txt-F尝试修复损坏的压缩文件zip -F archive.zip --out fixed_archive.zip-h显示帮助信息zip -h-i仅压缩符合条件的文件zip -r archive.zip . -i "*.txt"-k使用MS-DOS兼容格式zip -k archive.zip file.txt-l将“LF”替换成“LF+CR”字符zip -rl archive.zip .-L显示版本信息zip -L-m压缩后删除源文件zip -rm archive.zip file.txt-n不压缩具有特定字符串的文件zip -rn archive.zip . -x "*test*"-q静默执行模式zip -rq archive.zip .-r递归处理所有子文件zip -r archive.zip .-S包含系统和隐藏文件zip -r archive.zip . -S-t设置压缩时间为指定日期zip -t "2023-05-06 12:00" archive.zip file.txt-T检查压缩文件是否正确无误zip -T archive.zip-v显示执行过程详细信息zip -rv archive.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be6503d7b7dd04c7ca36417e38578780/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca0525ca272fd4274a49017d49d2b931/" rel="bookmark">
			大模型综述来了！一文带你理清全球AI巨头的大模型进化史
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		夕小瑶科技说 原创
作者 | 小戏，Python 如果自己是一个大模型的小白，第一眼看到 GPT、PaLm、LLaMA 这些单词的怪异组合会作何感想？假如再往深里入门，又看到 BERT、BART、RoBERTa、ELMo 这些奇奇怪怪的词一个接一个蹦出来，不知道作为小白的自己心里会不会抓狂？
哪怕是一个久居 NLP 这个小圈子的老鸟，伴随着大模型这爆炸般的发展速度，可能恍惚一下也会跟不上这追新打快日新月异的大模型到底是何门何派用的哪套武功。这个时候可能就需要请出一篇大模型综述来帮忙了！这篇由亚马逊、得克萨斯农工大学与莱斯大学的研究者推出的大模型综述《Harnessing the Power of LLMs in Practice: A Survey on ChatGPT and Beyond》，为我们以构建一颗“家谱树”的方式梳理了以 ChatGPT 为代表的大模型的前世今生与未来，并且从任务出发，为我们搭建了非常全面的大模型实用指南，为我们介绍了大模型在不同任务中的优缺点，最后还指出了大模型目前的风险与挑战。
论文题目：
Harnessing the Power of LLMs in Practice: A Survey on ChatGPT and Beyond
论文链接：
https://arxiv.org/pdf/2304.13712.pdf
项目主页：
https://github.com/Mooler0410/LLMsPracticalGuide
大模型研究测试传送门 ChatGPT传送门（免墙，可直接测试）：
https://yeschat.cn
GPT-4传送门（免墙，可直接测试，遇浏览器警告点高级/继续访问即可）：
https://gpt4test.com
家谱树——大模型的前世今生 追寻大模型的“万恶之源”，大抵应该从那篇《Attention is All You Need》开始，基于这篇由谷歌机器翻译团队提出的由多组 Encoder、Decoder 构成的机器翻译模型 Transformer 开始，大模型的发展大致走上了两条路，一条路是舍弃 Decoder 部分，仅仅使用 Encoder 作为编码器的预训练模型，其最出名的代表就是 Bert 家族。这些模型开始尝试“无监督预训练”的方式来更好的利用相较其他数据而言更容易获得的大规模的自然语言数据，而“无监督”的方式就是 Masked Language Model（MLM），通过让 Mask 掉句子中的部分单词，让模型去学习使用上下文去预测被 Mask 掉的单词的能力。在 Bert 问世之处，在 NLP 领域也算是一颗炸弹，同时在许多自然语言处理的常见任务如情感分析、命名实体识别等中都刷到了 SOTA，Bert 家族的出色代表除了谷歌提出的 Bert 、ALBert之外，还有百度的 ERNIE、Meta 的 RoBERTa、微软的 DeBERTa等等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca0525ca272fd4274a49017d49d2b931/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eae37bddbbbdbc7c1ffaf2c1b7a9d9d3/" rel="bookmark">
			音频质量客观评价指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：音频质量客观评价指标
作者：LeoLi6 (转载引用请注明出处)
干货分享，欢迎点赞收藏加关注！
语音增强中，常添加各种指标评估算法效果和语音质量，下面是常见的一些指标， All these metrics are better if higher.
Objective Evaluation Metrics 1.MOS(Mean Opinion Score)是语音增强和语音质量评估中最常用的主观评分方法。它通过让一定数量的人工听者对语音样本进行听觉质量评分,然后计算所有听者评分的平均值来得出MOS值。MOS的评分通常在1到5之间,分值为:
1 - 非常差,几乎不可用2 - 差,质量明显受损,应用受限3 - 一般,可用于部分应用4 - 好,可用于大多数应用5 - 非常好,与高质量标准电话质量相当 MOS评分的优点是直观简单,对应人类的听觉感知,可以有效评估人类听者的主观听感。但是它也存在一定的缺点:
评分的准确性依赖评价人员的经验与标准,存在较大差异性。评分过程耗时长,并且需要大量的人工资源,不适用于大规模语音质量评估。评分结果可能受环境噪声和其他无关因素的影响,准确性受限。 因此,MOS评分 methodology适用于小规模的主观语音质量评估,以及算法和系统的初步比较和评选。而在产品和服务的大规模评估中,更多采用客观的自动化评估指标,如PESQ和STOI等。除MOS之外,差分MOS(DMOS)也经常被用来评估语音增强系统的效果。它通过计算增强前和增强后语音的MOS差值,来评价语音质量的提高程度。DMOS分数范围也通常在1到5之间,分数越高表示语音质量提高越大。
2. DMOS(Difference Mean Opinion Score) 是基于人工听评来评估语音质量提高程度的指标。实验中会让评价人员对语音增强前后的语音样本进行打分,DMOS是两者打分的差值,范围通常在1到5,分数越高表示语音质量的提高越大。它可以有效评估不同语音增强算法对语音质量提高的作用。
3. DNSMOS: 人的主观评价是评价为人类感知优化的语音质量的“金标准”。感性客观指标作为主观得分的代理。传统和广泛使用的指标需要参考干净的语音信号，这在真实录音中是不可用的。无参考方法与人类评分相关性很差，在研究界没有被广泛采用。这些感知客观度量的最大用例之一是评估噪声抑制算法。DNSMOS在具有挑战性的测试条件下具有良好的泛化性，并且在堆栈排序噪声抑制方法中与人类评级高度相关。
4. PESQ: Perceptual evaluation of speech quality(from -0.5 to 4.5)，是目前语音增强领域最广泛使用的主观评估指标。它通过仿真人耳的听觉模型来预测听者对语音质量的主观评分,范围从-0.5到4.5,分数越高表示语音质量越高。它可以用于评估端到端的语音质量,也可以评估增强前后的质量差异。
5. STOI: 短时客观可懂度(Short-Time Objective Intelligibility),是一个客观的语音可懂度评估指标。它通过计算语音信号的时域和频域特征之间的相关性来预测语音的可理解度,范围从0到1,分数越高可懂度越高。它适用于评估噪声环境下的语音可懂度改善效果。
6. SDR (Vincent, Gribonval, and F´evotte 2006): Signal-to-distortion ratio from the mir eval library.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eae37bddbbbdbc7c1ffaf2c1b7a9d9d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccd6cf32fe9b564d5a992786058ff612/" rel="bookmark">
			怎么有效地查询MySQL表中的重复数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MySQL数据库中，偶尔会遇到需要查找表中出现的重复数据的情况。这种情况下，我们可以通过编写一些SQL查询语句轻松地找到并处理这些重复行。本文将介绍一些常见的方法和技巧，帮助你有效地查询MySQL表中的重复数据。
方法一：使用COUNT()函数查询重复行
COUNT()函数是MySQL中常用的聚合函数之一，它可以用于计算表中某个字段值的数量。利用这个函数，我们可以找到表中的重复值和它们的数量。以下是具体的步骤：
编写SQL查询语句来选择你想要查找重复数据所在的数据表，同时选择你想要鉴定的字段。
例如：
SELECT field1, field2, COUNT(field2) FROM table_name GROUP BY field2 HAVING COUNT(field2)&gt;1;
以上语句将查询 table_name 表中 field2 字段的值，并找出出现次数大于1的记录。同时，该查询还会显示 field1 字段的值和该字段对应的 field2 记录中的重复次数。
执行以上查询语句，你将会得到表中所有的重复数据以及对应的出现次数。你可以在查询结果中看到所有出现次数大于1的字段值，这意味着它出现了至少两次。
方法二：使用DISTINCT关键字查询重复行
DISTINCT 关键字可以帮助我们去除表中的重复数据。我们可以编写一条 SQL 查询语句来查找一列中的重复数据。
以下是具体的步骤：
编写SQL查询语句来选择你所需的表，同时选择需要查找的字段。
例如：
SELECT DISTINCT field1 FROM table_name WHERE field2=‘duplicate_value’;
以上语句将查询 table_name 表中所有的 field1 字段，并且只选择其中一个重复值。通过将查询结果与表中所有的唯一值进行比较，我们可以得到这个字段中的重复值。
执行以上的查询语句，你将会得到表中所有的重复数据，同时还会得到所有唯一的 field1 字段值。
方法三：使用自连接查询
使用自连接查询是一种比较复杂的方法，但也是一种非常强大的方法，可以用于查找表中重复的行。
以下是具体的步骤：
编写SQL查询语句，将数据表自连接，使得查询结果中的数据表和原始表是同一个。我们需要选择所需的字段并指定必须相同的字段作为连接条件。
例如，
SELECT A. FROM table_name A INNER JOIN (SELECT field1, field2, COUNT() FROM table_name GROUP BY field1, field2 HAVING COUNT(*)&gt;1) B ON A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccd6cf32fe9b564d5a992786058ff612/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af140a669f197964b83fe0d4be2d1599/" rel="bookmark">
			CDH大数据平台搭建之HADOOP分布式集群搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CDH大数据平台搭建之HADOOP安装 一、什么是HADOOP?二、如何下载1.官网下载2.网盘下载 三、搭建集群1.虚拟机准备2.安装JDK3.安装ZOOKEEPER4.集群规划5.安装HADOOP6.修改配置文件1、进入配置文件目录：2、修改env文件3、修改core-site.xml文件4、修改hdfs-site.xml文件5、配置mapred-site.xml文件6、修改yarn-site.xml文件7、修改slaves文件8、分发文件9、配置环境变量 四、启动集群1.启动ZOOKEEPER集群2.启动JournalNode3.格式化namenode4.格式化zkfc5.启动zkfc6.启动namenode7.格式化secondarynamenode8.启动secondarynamenode9.验证是否成功10.启动datanode11.启动resourcemanager12.启动nodemanager 五、各个机器命令进程六、网页端口效果1、namenoderesourcemanager 七、高可用测试总结 一、什么是HADOOP? Hadoop是一个由Apache基金会所开发的分布式系统基础架构，主要是分布式数据存储以及计算。
二、如何下载 1.官网下载 1、apache版本：http://hadoop.apache.org/ 2、cdh版本(已收费)：http://archive.cloudera.com/cdh5/cdh/5/ 2.网盘下载 链接：https://pan.baidu.com/s/18x2lc0Z7JbJ7pW-15VtiDg 提取码：cdh5 三、搭建集群 1.虚拟机准备 请参考CHD大数据平台搭建之VMware及虚拟机安装
以及CHD大数据平台搭建之虚拟环境配置
2.安装JDK 请参考CHD大数据平台搭建之JDK安装
3.安装ZOOKEEPER 请参考CHD大数据平台搭建之ZOOKEEPER安装
4.集群规划 请参考CHD大数据平台搭建之集群规划
5.安装HADOOP tar -zxvf hadoop-2.6.0-cdh5.7.6.tar.gz -C /opt/modules/ 6.修改配置文件 1、进入配置文件目录： cd /opt/modules/hadoop-2.6.0-cdh5.7.6/etc/hadoop 2、修改env文件 配置env文件java安装目录 hadoop-env.sh mapred-env.sh yarn-env.sh 修改：export JAVA_HOME=/opt/modules/jdk1.8.0_91 3、修改core-site.xml文件 1、新建文件夹：
mkdir -p /opt/modules/hadoop-2.6.0-cdh5.7.6/data/tmp 2、添加如下内容
&lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://mycluster&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定Hadoop运行时产生文件的存储目录 --&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/opt/modules/hadoop-2.6.0-cdh5.7.6/datas/tmp&lt;/value&gt; &lt;/property&gt; &lt;!-- zookeeper通讯地址--&gt; &lt;property&gt; &lt;name&gt;ha.zookeeper.quorum&lt;/name&gt; &lt;value&gt;bigdata-training03.hpsk.com:2181,bigdata-training04.hpsk.com:2181,bigdata-training05.hpsk.com:2181&lt;/value&gt; &lt;/property&gt; 4、修改hdfs-site.xml文件 1、新建文件夹：
mkdir -p /opt/modules/hadoop-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af140a669f197964b83fe0d4be2d1599/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5d8096e4fc74a09f5736ff2101b87c6/" rel="bookmark">
			GX18B20温度传感器替代DS18B20，精度更高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GX18B20 数字温度计提供 9 到 12bit 分辨率的温度测量，可以通过可编程非易失性存储单元，实现温度的下限和上限报警。GX18B20 采用单总线协议与上位机进行通信，只需要一根信号线和一根地线。它的温度测量范围为-55℃~ +125℃。在-10℃~+70℃范围内的测试精度可以达到±0.4℃。此外它还可以工作在寄生模式下，直接通过信号线对芯片供电，从而不需要额外的供电电源。每个 GX18B20 都有一个全球唯一的64 位序列号，可以将多个 GX18B20 串联在同一跟单总线上进行组网，只需要一个处理器就可以控制分布在大面积区域中的多颗 GX18B20。这种组网方式特别适合 HVAC 环境控制，建筑、设备、粮情测温和工业测温以及过程监测控制等应用领域。
特点和功能
★ 采用单总线接口仅需一个端口引脚进行通信
★ 每颗芯片具有全球唯一的 64 位的序列号
★ 具有多点分布式测温功能
★ 无需外围元器件
★ 可通过数据线供电；供电电压范围为2.5V~5.5V
★ 温度测量范围为 -55°C to +125°C (-67°F to+257°F)
★ 在-10℃~70℃范围内精确度为±0.4°C 温度分辨率 9-12 位可选
★ 最高 12 位精度下，温度转换速度小于 400ms
★ 具有用户自定义的非易失性温度报警设置
★ 报警搜索命令识别并标识超过程序设定温度的器件
★ 超强静电保护能力：HBM 8000V MM 800V
★ 可提供贴片的 MSOP8、SOP8 封装和 3 脚 的 TO-92、TO-92s 封装
★ 应用包括温度控制、工业系统、消费品、粮情测温、温度计或任何感热系统
产品应用
★ 温控器、温湿控制器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5d8096e4fc74a09f5736ff2101b87c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bee28503f18cb974364dd9c624b4b949/" rel="bookmark">
			GX2431替代美信DS2431，国产替代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GX2431用在智能光纤ODN、打印机墨盒、美容仪、电池管理系统、医疗耗材、小家电等领域的【电子标签芯片】严重缺货。莫慌、莫慌！作为国际知名芯片代理商与电机驱动方案技术服务商的钧敏科技为大家推荐一款可以解决燃眉之急的替代芯片-GX2431
GX2431是一款单总线电子标签芯片，每颗芯片具有64位ID号。芯片具有1024位的EEPROM存储空间。可在-40℃至+85℃温度范围，2.8V至5.5V的宽电压范围内工作，芯片在各方面性能完全达到或超过国内外同类产品。
中科银河芯科技特别推荐的电子标签芯片GX2431可 pin to pin 美信DS2431，该芯片性能稳定，可定制ID，广泛应用于智能光纤ODN设备、打印机墨盒、FPGA加密、美容仪、仪器设备机密认证等领域。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02120fffbcfefde76be4e6640e69048a/" rel="bookmark">
			java.lang.IllegalStateException: Current request is not of type已解决、有效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常："java.lang.IllegalStateException: Current request is not of type [org.apache.catalina.servlet4preview.http.HttpServletRequest]: org.apache.catalina.connector.RequestFacade@f3a2876
由于更换了tomcat 出现了这个异常
controller引入的httpservletrequest有问题，引入的是org.apache.catalina.servlet4preview.http.HttpServletRequest，
但实际应该是import javax.servlet.http.HttpServletRequest;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44f0de505643c9267820c216f2bffa47/" rel="bookmark">
			[yocto]使用devtool工具创建配方文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. devtool创建新的工作环境 在使用devtool之前需要先搭建poky环境，并且需要引用poky的构建环境；见之前的文章
基于poky项目创建自己的层并且在层中增加自己的配方文件
创建工作环境
使用devtool创建workspace需要指定路径，否则默认在当前目录下创建新层 devtool create-workspace meta-devtool ~/test/poky$ bitbake-layers show-layers NOTE: Starting bitbake server... layer path priority ======================================================================================================== core /xxx/test/poky/meta 5 yocto /xxx/test/poky/meta-poky 5 yoctobsp /xxx/test/poky/meta-yocto-bsp 5 meta-test /xxx/test/poky/meta-test 6 workspacelayer /xxx/test/poky/meta-devtool 99 新增的层名字为workspacelayer，路径为/xxx/test/poky/meta-devtool 2. 生成配方文件 a.源保存在网络外部镜像中
devtool add recipe fetchuri 本例源来自网络外部；源被下载到工作目录下的sources目录，生成一个bbappend配方文件继承externalsrc类来指向源；
command
devtool add hello https://ftp.gnu.org/gnu/hello/hello-2.12.tar.gz ~/test/poky/meta-devtool$ tree -L 1 . ├── appends ├── conf ├── README ├── recipes └── sources hello_2.12.1-6fe9.bbappend
inherit externalsrc EXTERNALSRC = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44f0de505643c9267820c216f2bffa47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c529c5dc5fc1a44dae052e7eff551297/" rel="bookmark">
			MobaXterm连接Ubuntu系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新安装的Ubuntu系统直接用MobaXterm连不上，我们可以先打开终端看Linux的IP，我们设置的网络连接方式为net模式，在终端中输入如下命令
ip addr
需要新安装ssh才可以用MobaXterm连接，执行如下命令
apt install openssh-server
禁用防火墙后即可用MobaXterm连接
ufw disable
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bd22f2b26e45fe819e4c22ee955562d/" rel="bookmark">
			opencv 图像识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		opencv的目标是使计算机可以快速准确地从数字图像中提取和分析特征。它使用了许多新的算法和技术，例如改进的模板匹配、基于统计的特征分析以及深度学习等。opencv支持多种平台，包括 Windows、 MacOS、 Linux和 Android，开发者可以使用 OpenCV提供的免费工具和 API进行图像识别。 opencv还支持各种类型的网络摄像头。通过将摄像头连接到计算机或智能手机，您可以使用 opencv对图像进行识别，并使用 OpenCV库中提供的功能对其进行操作。它支持多个网络摄像头，包括智能手机中常用的网络摄像头。
1. opencv的安装和配置
opencv是一个免费的库，但是有限制，它只支持 Linux和 Mac OS操作系统，不过它可以在其他系统下使用，也就是说，你可以在 Windows和 Linux下运行 opencv。如果你有 Linux或 Mac OS操作系统，你可以下载 opencv安装文件并安装。这里的重点是安装和配置 opencv。 在 Python中，我们通常使用 pip install opencv来安装这个库。这将显示安装的整个过程。如果您要安装的库没有提供命令行界面，则需要下载该库的 api文件并运行它。 要配置 opencv，您需要编写一个名为 opencv. dll的文件并将其下载到您的计算机上。这是一个包含 opencv库所有功能的文件。您还需要在 pip install命令行窗口中输入“pip install opencv”来启动库。在这里，您应该始终选择“YES”表示“是”）。 您应该一直点击“YES”按钮直到出现错误提示为止。 一旦启动库，请将其添加到您的项目中。在 Python中，可以使用以下命令来加载库： 如果你希望使用 opencv进行图像识别，请添加一个名为cv_opencv. dll的文件到您的项目中。这个文件包含有关如何使用 opencv进行图像识别以及如何配置其库的信息。 如果你在 Python中运行了上述命令并安装了 opencv，则只需单击“安装”按钮并选择“已安装”选项即可。如果你还没有安装 opencv，则需要先进行安装，然后再使用以上命令进行加载。 最后一步是配置 OpenCV库。要使用该库，请运行以下命令并指定目标目录： 如果你使用的是 Windows操作系统，则需要在计算机上创建一个名为 opencv. exe的文件并将其下载到本地电脑中。如果您想在计算机上配置 OpenCV库并在本地电脑中使用其功能，请执行以下命令： 在 Python中运行以上命令并将其添加到您的项目中： 如果您要使用 opencv库进行图像识别，请访问 OpenCV库网站以获取更多信息。
2.图像格式
它还支持图像的颜色和尺寸，可以轻松地与 OpenCV库中的其他图像处理函数一起使用。 在处理图像时，首先需要将图像转换为 BMP格式。使用 OpenCV进行图像识别，可以直接从 BMP文件中提取和处理数字图像，而不需要转换为其他格式。具体来说，通过调用 opencv库中的相关函数将图片转换为 BMP文件，然后使用 OpenCV库中的图像识别函数对其进行分析。 对于 TIFF格式的图片，其结构类似于位图文件。对于 PNG格式的图片， opencv可以将其转换为 PNG格式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bd22f2b26e45fe819e4c22ee955562d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e69df6dcfa0420581cc143a45364aedd/" rel="bookmark">
			PowerShell系列（三）：PowerShell发展历程梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、PowerShell 1.0
版本特性
2、PowerShell 2.0
版本特性
3、PowerShell 3.0
版本特性
4、PowerShell 4.0
版本特性
5、PowerShell 5.0
版本特性
6、PowerShell 5.1
版本特性
7、PowerShell6.0 Core
版本特性
8、PowerShell7.0 Core
版本特性
今天给大家聊聊PowerShell的发展历程，以及各个版本之间有什么亮点。
1、PowerShell 1.0 发行日期：2006/11默认集成版本：Windows Server 2008支持其他版本：Windows Server 2003 SP1/SP2,Windows Server2003 R2, Windows XP SP2, and Windows Vista最低：NetFramework:2.0下载地址：无 版本特性 首个版本，提供的命令数量有129条。基于命令行界面，它提供了许多基本的系统管理命令，如文件操作、进程控制、网络配置等功能。 2、PowerShell 2.0 发行日期：2009/8默认集成版本：Windows Server 2008R2、Windows 7支持其他版本：Windows Server 2008 SP1/SP2Windows VistaSP1/SP2Windows Server 2003 SP2,Windows XP SP3最低：NetFramework:2.0下载地址：无 版本特性 命令数量为624条远程执行功能：可以通过主控计算机管控运行各个服务器的运行程序和结果。事件支持：新增WMI系统事件的监听、转发、操作后台Job：支持脚本任务后台执行支持导入模块功能：可以增加或导入别的模块实现相应的功能。支持新操作符：增加 -spilt和-join操作符。错误处理机制：增加 try-catch-finally 处理逻辑注释功能：新增了代码块注释功能集成开发环境：新增集成开发环境让代码编写更加高效 3、PowerShell 3.0 发行日期：2012/12默认集成版本：Windows Server 2012、Windows 8支持其他版本：Windows 7 SP1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e69df6dcfa0420581cc143a45364aedd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5c35de8c4553fdb1174f7540a395b51/" rel="bookmark">
			c&#43;&#43;学习笔记（2）数组，函数，指针，结构体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、一维数组
2、二维数组
3、函数
4、函数分文件编写：
5、指针
5.1 定义指针
5.2const修饰指针 （const后面的值不可以改）
5.3指针访问数组
6、结构体
1、一维数组 一维数组定义的三种方式：
1。数据类型 数组名[数组长度];
2。数据类型 数组名[数组长度] = {值1，值2.。。。。}；
3。数据类型 数组名[] = {值1，值2.。。。。}； 可推测出长度
数组特点 连续存储空间，每个元素相同数据类型
未定义的用0填补
定义数组时必须知道初始长度
命名规范与变量相同
sizeof(arr) 求数组长度
cout&lt;&lt;arr&lt;&lt;endl; 输出数组在内存中首地址
cout&lt;&lt;int(arr)&lt;&lt;endl; 输出数组在内存中首地址(十进制) 如果报错说明超过int取值范围，可改为long
数组名是常量，不可以进行赋值
2、二维数组 四种定义方式：
1.数据类型 数组名[行数][列数]；
2.数据类型 数组名[行数][列数] = {{数据，数据},{},{}}； 常用
3.数据类型 数组名[行数][列数] ={数据1，数据2，3，4}；
4.数据类型 数组名[ ][列数] ={数据1，数据2，3，4}；
3、函数 返回值类型 函数名 （参数列表） void为空
{
函数体语句；
return表达式；
}
值传递：函数调用时实参将数值传入给形参，值传递时，如果形参发生变化，并不会影响实参
常见函数样式：无参无返 有参无返 无参有返 有参有返
函数声明：告诉编译器函数名称及如何调用函数，函数的实际主体可以单独定义。函数的声明可以多次，函数定义只有一次eg：int max(int a,int b);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5c35de8c4553fdb1174f7540a395b51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b286d1dd1f476884999e30049228000/" rel="bookmark">
			Android Pdf第三方框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. AndroidPdfViewer 导入AndroidPdfViewer
implementation 'com.github.barteksc:android-pdf-viewer:2.8.2' 在repositories里面添加库
maven { url 'https://jcenter.bintray.com' } 布局文件引用PDFView
&lt;com.github.barteksc.pdfviewer.PDFView android:id="@+id/pdf_view" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; PdfViewer为我们提供了以下几种读取文件的方法:
pdfView.fromUri(Uri) pdfView.fromFile(File) pdfView.fromBytes(byte[]) pdfView.fromStream(InputStream) pdfView.fromSource(DocumentSource) pdfView.fromAsset(String) Configurator主要方法
pages(int... pageNumbers) // 指定显示页面，默认全部显示 defaultPage(int defaultPage) // 默认实现页面 enableSwipe(boolean enableSwipe) // 控制屏幕滑动，默认为true能够滑动 enableDoubletap(boolean enableDoubletap) // 禁用双击，默认为true，可以双击 swipeHorizontal(boolean swipeHorizontal) // 开启横向滑动，默认竖向 enableAnnotationRendering(boolean annotationRendering) // 支持电子签 spacing(int spacing) // 页面之间空隙，单位是dp onLoad(OnLoadCompleteListener onLoadCompleteListener) // 加载结束，开始绘制 onPageScroll(OnPageScrollListener onPageScrollListener) // 监听页面滚动 onPageChange(OnPageChangeListener onPageChangeListener) // 监听页面变化 load() // 最后调用，使配置生效 PDFView其他方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b286d1dd1f476884999e30049228000/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcabe4150519d4a945b5937186e3346f/" rel="bookmark">
			Fork/Join 框架详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、什么是Fork/Join 框架？
2、Fork/Join 框架的工作原理
3、什么是工作窃取？
4、工作窃取是如何实现的？
5、Java 中 Fork/Join 框架工作窃取核心类分析
6、Fork/Join 框架的使用示例
7、Fork/Join 框架的应用场景
1、什么是Fork/Join 框架？ Fork/Join 是一种并行计算模式，用于解决可以被分解成更小的可并行任务的问题。该模式包含两个关键操作：Fork（分解）和Join（合并）。
在 Fork/Join 模式中，原始问题被递归地分解为更小的子问题，直到达到可以并行解决的最小单位。这个过程被称为 Fork。每个子问题可以独立地在不同的处理器上执行，并行地求解部分问题。
一旦所有的子问题都被解决，就会进行 Join 操作。Join 操作将所有子问题的结果合并为最终的解决方案。这种分解和合并的过程可以视为树形结构，其中每个节点代表一个子问题。
Fork/Join 模式最适用于可以自然地分解为多个独立子问题的计算密集型任务。它适用于多核处理器或并行计算环境，其中可以充分利用并行性。
Java 平台提供了 Fork/Join 框架，用于实现该模式。它包括了一个线程池（ForkJoinPool）和任务（ForkJoinTask）的概念。任务可以是可分解的子问题，也可以是执行最终计算的任务。通过 ForkJoinPool，可以将任务提交给线程池执行，自动实现任务的分解和合并过程。
Fork/Join 模式的优点在于它能够充分利用多核处理器的并行性，提高计算效率。然而，它的适用性受到问题本身的限制，某些问题可能无法自然地分解为独立子问题，或者分解后的子问题规模过小，无法获得明显的并行加速效果。在设计并行算法时，需要仔细考虑问题的特性和可并行性，才能有效地应用 Fork/Join 模式。
2、Fork/Join 框架的工作原理 Fork/Join 框架的工作原理可以总结为以下几个步骤：
（1）任务分解（Fork）：
当一个任务到达时，Fork/Join 框架首先检查任务的大小是否足够小，以决定是否进行进一步的分解。如果任务足够小，可以直接执行任务，或者将其分配给可用的工作线程执行。如果任务大小超过了阈值或需要进一步分解，Fork/Join 框架将任务分解为更小的子任务。分解过程可以通过创建新的任务实例来完成，每个子任务负责处理原始任务的一个子区域或部分。 （2）任务执行：
当任务被分解为子任务后，它们可以并行执行在不同的线程中。Fork/Join 框架使用线程池（ForkJoinPool）来管理任务的执行。线程池中的工作线程负责执行任务。如果线程池中有空闲的工作线程，分解的子任务可以立即分配给它们执行。否则，任务将进入等待状态，直到有可用的工作线程。 （3）任务合并（Join）：
当一个子任务执行完成时，它将返回结果给父任务。父任务可以通过调用 join 方法等待子任务的完成，并获取子任务的结果。如果一个任务有多个子任务，父任务将等待所有子任务执行完成，并将它们的结果合并为最终结果。合并过程通常是递归的，直到所有子任务的结果被合并为一个最终结果。 （4）工作窃取（Work Stealing）：
在 Fork/Join 框架中，线程池中的工作线程可以从其他线程的任务队列中偷取任务。当一个工作线程没有任务可执行时，它可以从其他工作线程的任务队列中获取一个待执行的任务。这种工作窃取机制可以平衡任务的负载，提高并行性和效率。 Fork/Join 框架的关键在于任务的递归分解和合并过程，以及线程池中工作线程的任务调度和工作窃取机制。这些机制的协同工作使得任务能够以最佳的方式分配和执行，从而实现高效的并行计算。
3、什么是工作窃取？ 工作窃取（Work Stealing）是一种并行编程中的任务调度策略，主要用于提高任务并行性和负载均衡。// 从其他线程的任务队列获取任务
在工作窃取模型中，线程池中的工作线程可以从其他线程的任务队列中“窃取”任务来执行。每个工作线程都有一个本地的任务队列，用于存储待执行的任务。当一个工作线程完成自己的任务队列中的任务后，它可以尝试从其他工作线程的任务队列中获取任务来执行。
工作窃取的主要思想是使得空闲的工作线程能够主动获取任务，以充分利用计算资源。这种策略对于解决以下两个问题非常有效：
负载均衡：在并行计算中，任务的大小和复杂度可能不均匀，导致某些工作线程完成任务较早，而其他工作线程仍然在执行。通过工作窃取，空闲的工作线程可以从繁忙的线程队列中窃取任务来执行，以达到负载均衡的效果。避免线程闲置：传统的任务分配模型中，当一个线程执行完自己的任务后，可能会处于等待状态，直到有新任务可用。而在工作窃取模型中，线程可以主动获取任务，避免了线程的闲置时间，提高了并行性和效率。 工作窃取模型的一个关键点是每个工作线程都有自己的本地任务队列，以避免不必要的线程间同步开销。当工作线程窃取任务时，它们通常从其他线程的任务队列的末尾开始窃取，这可以减少竞争和同步的可能性。// 使用双端队列的数据结构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcabe4150519d4a945b5937186e3346f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96980e87e601ed404be43f9b9c7887f8/" rel="bookmark">
			【数字IC基础】跨时钟域（CDC，Clock Domain Crossing）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是跨时钟域？二、跨时钟域传输的问题？2、1 亚稳态（单bit：两级D触发器（双DFF））2、2 数据收敛（多bit亚稳态）（格雷码编码、握手协议、异步FIFO、DMUX）2、3 多路扇出：（先同步后扇出）2、4 数据丢失（延长输入数据信号）：类似脉冲展宽2、5 异步复位（同步释放） 三、跨时钟域传输问题的解决方法？3、1 单比特信号3、1、1 单比特脉冲信号（慢时钟域到快时钟域）：两级D触发器同步处理3、1、2 单比特脉冲信号（快时钟域到慢时钟域）：脉冲展宽 3、2 多比特信号3、2、1 格雷码+双DFF（异步FIFO）3、2、2 握手协议3、2、3 DMUX（D触发器加二选一选择器）数据使能选通设计 一、什么是跨时钟域？ 1、同步设计：在同步设计中，整个设计都是使用同一个时钟源，所有时钟的频率和相位都可以事先预知
2、异步设计：在设计中有两个或以上的时钟， 且时钟之间是同频不同相或不同频的关系，异步时序设计的关键就是把数据或控制信号正确地进行跨时钟域传输。
3、跨时钟域（CDC，Clock Domain Crossing）：数据从一个时钟域传输到另一个时钟域 4、跨时钟域是如何产生的呢？ 现在的芯片（比如SOC，片上系统）集成度和复杂度越来越高，通常一颗芯片上会有许多不同的信号工作在不同的时钟频率下。比如SOC芯片中的CPU通常会工作在一个频率上，总线信号（比如DRAM BUS）会工作在另一个时钟频率下，而普通的信号又会工作在另外的时钟频率下。这3个不同时钟频率下工作的信号往往需要相互沟通和传递信号。不同时钟域下的信号传递就涉及到跨时钟域信号处理。
二、跨时钟域传输的问题？ 跨时钟域问题的本质是：亚稳态，根据传输的数据大小，分为单比特亚稳态、多比特亚稳态
组合逻辑竞争冒险、时序逻辑亚稳态 2、1 亚稳态（单bit：两级D触发器（双DFF）） 亚稳态：数据无法在规定的时间段内达到一个稳定的状态
亚稳态的发生原因：
1、数据：数据传输中不满足D触发器的建立时间Tsu和保持时间Th要求2、复位：复位过程中复位信号的释放相对于有效时钟沿的恢复时间（recovery time）和移除时间（removal time）不满足 亚稳态主要发生在异步信号采集、跨时钟域信号传输以及异步复位电路等常用设计中
亚稳态输出不确定，但是会传给后一级触发器，这会导致后级电路出错，所以亚稳态危害很大
1、单bit信号的跨时钟域传输：用两级D触发器做同步处理 2、常见错误：时钟域A的组合逻辑信号（即时钟域A发出的信号先经过组合逻辑再传输到时钟域B）直接敲两级DFF同步到时钟域B
解决方案：时钟域A的组合逻辑信号必须先经过一级DFF，等数据稳定后，再传输到B时钟域
2、2 数据收敛（多bit亚稳态）（格雷码编码、握手协议、异步FIFO、DMUX） 1、数据收敛：如何确保一组相关联的同步信号在经过不同的路径之后可以在某一个相同的时钟周期正确地到达另一个时钟域。2、对于多bit信号跨时钟域传输时，虽然可以对每一个信号使用Double FF来进行信号同步，但是信号的准确性和关联性却会出现问题，这就是数据的收敛问题，也就是多bit信号的亚稳态。3、比如有两个相关联的信号X，Y要从时钟域clk_A向时钟域clk_B传播，这里分别对两个信号进行两级DFF同步处理，最终同步信号就可以满足后续电路的时序要求，但是可能会出现如下的情况：
4、多bit信号的跨时钟域传输：格雷码编码、握手协议、FIFO 2、3 多路扇出：（先同步后扇出） 1、有些情况下，一个信号在跨越时钟域之后又分为了多个分支。比如：一个使能的控制信号分别使能后续的多个模块
①、同一个信号源经过不同的路径跨越时钟域之后，多路扇出的值不一定相同
2、解决方法：将信号同步之后再多路扇出（即先在时钟域B过两级DFF同步，再将信号扇出，不要在各自的分支上同步）
2、4 数据丢失（延长输入数据信号）：类似脉冲展宽 1、输入端信号不能保持足够的时间使得接收端不能采样到数据，导致数据丢失
2、解决方案：延长输入信号
2、5 异步复位（同步释放） 1、在亚稳态一节中，我们讲到：异步复位信号在释放时不满足恢复recovery时间和移除removal时间要求，会导致亚稳态 异步复位信号引起的触发器亚稳态并不是在复位的时候出现的，而是在复位信号释放时出现的 2、虽然异步信号没有固定的时钟，但我们还是把它看作一个CDC问题
3、解决方法：在异步复位信号释放时对其进行同步处理（即设计要求中，常讲的：“复位信号——异步复位同步释放） ①、异步复位信号之所以会导致触发器出现亚稳态，原因在于：复位信号释放时不能够与触发器的时钟保持同步②、因此可以通过对复位信号同步处理来解决
//Synchronized Asynchronous Reset //异步复位、同步释放：只适用于没有PLL的系统复位信号的设置 module sync_async_reset(clock,reset_n,rst_n); input clock, reset_n; output rst_n; reg rst_nr1;//打一拍 reg rst_nr2;//打两拍 always @(posedge clock or negedge reset_n) begin if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96980e87e601ed404be43f9b9c7887f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eb5d45439785a5060e3ec6d68d9f124/" rel="bookmark">
			Android Glide简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Glide是谷歌为我们推荐的一个图片加载库。为什么要选择使用Glide呢？
1、代码有人维护，不至于出现问题，项目组都搞不定的时候问题无法解决。（ImageLoader已没人维护了）2、代码简洁，可读性很好。（Fresco是一个非常优秀的库，但是配置稍显麻烦，同时代码风格读起来有些生疏）3、功能强大（400多k的包，包含很多功能，例如：像加载Gif图片就是Picasso做不到的） 下面我们就来介绍下Glide的用法：
Glide的基本使用 导入库 compile 'com.github.bumptech.glide:glide:3.7.0' 添加代码混淆（可加可不加） -keep public class * implements com.bumptech.glide.module.GlideModule -keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** { **[] $VALUES; public *; } # for DexGuard only -keepresourcexmlelements manifest/application/meta-data@value=GlideModule 这个别忘了，不要粗心哦，很容易忘得，最简单的问题，往往需要最简单的搞定啦。
&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; 简单使用例子 // For a simple view: @Override public void onCreate(Bundle savedInstanceState) { ... ImageView imageView = (ImageView) findViewById(R.id.my_image_view); Glide.with(this).load("http://goo.gl/gEgYUd").into(imageView); } // For a simple image list: @Override public View getView(int position, View recycled, ViewGroup container) { final ImageView myImageView; if (recycled == null) { myImageView = (ImageView) inflater.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eb5d45439785a5060e3ec6d68d9f124/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15bc54f5e13aa6245597db1b7dd8535f/" rel="bookmark">
			基于STM32F1系列与阿里云的物联网节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、硬件准备
一块STM32F1系列的核心板或开发板
DHT11温湿度传感器一个
BH1750光照强度传感器一个
ESP8266-01S模块一个
TFT彩屏一个(SPI接口)
二、软件准备
准备阿里云物联网平台的开发
准备阿里云物联网Web可视化页面的开发
以及Keil5开发环境和串口调式助手
三、阿里云物联网平台
笔者在写过一篇关于阿里云平台的文章，传送门如下：
(2条消息) ESP8266-01S+MQTT+阿里云数据传输_二筒rrrr的博客-CSDN博客
四、STM32的开发
我们需要准备DHT11传感器与BH1750传感器的代码，废话不多说直接上代码
DHT11.c
#include "bsp_DHT11.h"
xDHT11_TypeDef xDHT11; // 声明全局结构体, 用于记录信息
static GPIO_TypeDef *DHT11_GPIOx = 0; // 引脚端口
static uint32_t DHT11_PINx = 0; // 引脚编号
#define DHT11_BUS_HIGH (DHT11_GPIOx-&gt;BSRR = (uint32_t)DHT11_PINx) // DAT引脚 置高电平
#define DHT11_BUS_LOW (DHT11_GPIOx-&gt;BSRR = ((uint32_t)DHT11_PINx) &lt;&lt; 16) // DAT引脚 置低电平
#define DHT11_BUS_READ ((DHT11_GPIOx-&gt;IDR &amp; DHT11_PINx) ? 1: 0) // 读取引脚的电平
#if DELAY_MODE_TIM2
#include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15bc54f5e13aa6245597db1b7dd8535f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d7310eabcd4b5495faa5f9a4e157b6d/" rel="bookmark">
			Android LeakCanary使用详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语 在Android的性能优化中，内存优化是必不可少的点，而内存优化最重要的一点就是解决内存泄漏的问题，在Android的内存泄漏分析工具也不少，比如PC端的有：AndroidStudio自带的Android Profiler、MAT等工具；手机端也有，就是我们今天要介绍的LeakCanary
LeakCanary简介 LeakCanary是Square公司为Android开发者提供的一个自动检测内存泄漏的工具，
LeakCanary本质上是一个基于MAT进行Android应用程序内存泄漏自动化检测的的开源工具，我们可以通过集成LeakCanary提供的jar包到自己的工程中，一旦检测到内存泄漏，LeakCanary就好dump Memory信息，并通过另一个进程分析内存泄漏的信息并展示出来，随时发现和定位内存泄漏问题，而不用每次在开发流程中都抽出专人来进行内存泄漏问题检测，极大地方便了Android应用程序的开发。
LeakCanary显示内存泄漏的页面：
LeakCanary优点： 1、针对Android Activity组件完全自动化的内存泄漏检查。
2、可定制一些行为（dump文件和leaktrace对象的数量、自定义例外、分析结果的自定义处理等）。
3、集成到自己工程并使用的成本很低。
4、友好的界面展示和通知。
LeakCanary工作机制： 引用LeakCanary中文使用说明，它的基本工作机制如下：
1、RefWatcher.watch() 创建一个 KeyedWeakReference 到要被监控的对象。
2、然后在后台线程检查引用是否被清除，如果没有，调用GC。
3、如果引用还是未被清除，把 heap 内存 dump 到 APP 对应的文件系统中的一个 .hprof 文件中。
4、在另外一个进程中的 HeapAnalyzerService 有一个 HeapAnalyzer 使用HAHA 解析这个文件。
5、得益于唯一的 reference key, HeapAnalyzer 找到 KeyedWeakReference，定位内存泄露。
6、HeapAnalyzer 计算 到 GC roots 的最短强引用路径，并确定是否是泄露。如果是的话，建立导致泄露的引用链。
7、引用链传递到 APP 进程中的 DisplayLeakService， 并以通知的形式展示出来。
LeakCanary的Android Studio集成 一、 在build.gradle中添加LeakCanary的依赖包，截止目前leakcanary的最新版本是1.6.1：
dependencies { debugCompile 'com.squareup.leakcanary:leakcanary-android:1.6.1' releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.1' } 在开发中一般同时集成debug和release版本，其中：
com.squareup.leakcanary:leakcanary-android:1.6.1 是debug版本，在你的app编译的是debug版本，加载的是该jar包，一旦出现内存泄漏会在通知栏中通知开发者产生了内存泄漏；com.squareup.leakcanary:leakcanary-android-no-op:1.6.1 是release版本，如果你的app编译的是release版本时，加载的是该jar包，no-op是指No Operation Performed，代表不会做任何操作，不会干扰正式用户的使用； 二、 在我们自定义Application的onCreate方法中注册LeakCanary
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d7310eabcd4b5495faa5f9a4e157b6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deeb71fb812ed0571b35a103b385bf59/" rel="bookmark">
			UNeXt:基于MLP的快速医学图像分割网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 UNeXt: MLP-Based Rapid Medical Image Segmentation Network摘要本文方法Shifted MLPTokenized MLP Stage 实验结果 UNeXt: MLP-Based Rapid Medical Image Segmentation Network 摘要 UNeXt：一种基于卷积多层感知器（MLP）的图像分割网络。
在早期的卷积阶段和潜在阶段的MLP阶段。我们提出了一个标记化的MLP块，其中我们有效地标记和投影卷积特征，并使用MLP对表征进行建模向MLP反馈的同时改变输入的通道，以便专注于学习局部依赖性。在潜在空间中使用标记化MLP减少了参数的数量和计算复杂性，同时能够产生更好的表示来帮助分割。该网络还包括各级编码器和解码器之间的跳过连接。我们在多个医学图像分割数据集上测试了UNeXt，结果表明，我们将参数数量减少了72x，假定复杂度减少了68x，推理速度提高了10倍，同时也获得了比现有技术的医学图像分割架构更好的分割性能。代码地址
本文方法 Convolutional Stage：Conv----&gt;BN----&gt;RELU
Shifted MLP 在移位MLP中，我们首先在标记化之前移位conv特征的通道的轴。这有助于MLP仅关注conv特征的某些位置，从而诱导块的局部性。这里的直觉类似于Swin transformer，其中引入了基于窗口的注意力，为原本完全全局的模型添加更多的局部性。由于标记化MLP块有2个MLP，我们将特征在一个区块中跨宽度移动，在另一个区块跨高度移动，就像在轴向注意力中一样。我们将特征分割到h个不同的分区，并根据指定的轴将它们移动j=5个位置。这有助于我们创建沿轴引入局部性的随机窗口
Tokenized MLP Stage 在标记化的MLP块中，我们首先转换特征并将其投影到标记中。为了标记化，将通道的数量更改为E，其中E是嵌入维度（标记的数量），这是一个超参数。然后，我们将这些标记传递给移位的MLP（跨宽度），其中MLP的隐藏维度是超参数H。接下来，通过深度卷积层（DWConv）传递特征。我们在这个块中使用DWConv有两个原因：
它有助于对MLP特征的位置信息进行编码DWConv使用的参数数量较少，因此提高了效率
实验结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/552bc612f6cb6aa9919b5b09bc8246fa/" rel="bookmark">
			缓存穿透、缓存雪崩和缓存击穿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 缓存穿透 缓存穿透是指查询一个一定不存在的数据，由于缓存中没有，每次查询都要去数据库中查询，导致频繁地访问数据库，从而影响系统的性能。攻击者可以利用这一点，对系统进行拒绝服务攻击。
1.1 缓存穿透举例 攻击者通过在请求中携带不存在的数据，进行大量的请求，导致系统访问数据库频繁，从而影响系统性能。
用户在查询不存在的数据时，由于缓存中没有，每次都会去数据库中查询，也会造成缓存穿透。
1.2 解决方法 使用布隆过滤器对查询的键进行过滤，如果查询的键不存在于布隆过滤器中，则直接返回不存在，不再查询缓存和数据库。
布隆过滤器是一种空间效率很高的随机数据结构，它利用位数组和哈希函数实现，可以用于检索一个元素是否在一个集合中。布隆过滤器有一定的误判率，但是可以通过调整位数组的大小和哈希函数的数量来控制误判率。
如果查询的数据在数据库中不存在，则将空对象放入缓存中，下次再查询时直接从缓存中获取空对象，避免了频繁地去查询数据库。
例如，当用户查询某个不存在的商品时，将一个空的商品对象放入缓存中，下次再查询时直接从缓存中获取该空对象。这样即使用户频繁地查询不存在的商品，也不会对数据库造成压力。
在应用启动时，或者定期地将热点数据加载到缓存中，避免缓存中没有数据导致的缓存穿透。
热点数据是指访问频率高、对系统性能影响大的数据。将热点数据预先加载到缓存中可以避免缓存穿透。可以在应用启动时，或者定期地将热点数据加载到缓存中。可以使用缓存预热技术实现。
对请求增加校验机制，过滤掉不合理请求
例如：课程Id是长整型，如果发来的不是长整型则直接返回。
1.3 名词解释 1.3.1 布隆过滤器 布隆过滤器是一种数据结构，可以高效地判断一个元素是否存在于一个集合中。它的主要优点是占用内存空间小、判断速度快，适用于需要快速判断元素是否存在于集合中的场景。布隆过滤器基于哈希函数实现，将元素映射到一个位数组中，并使用多个哈希函数进行映射，从而降低误判率。但是，由于布隆过滤器的空间有限，当元素数量过多时，误判率会增加，从而导致布隆过滤器失效。
1.3.1.1 布隆过滤器的优点 占用内存小：布隆过滤器只需要一段位数组和多个哈希函数，占用内存空间很小。
判断速度快：布隆过滤器只需要进行位运算，判断速度非常快。
可以判断元素是否一定不存在于集合中：如果布隆过滤器判断某个元素不存在于集合中，那么该元素一定不存在于集合中。
1.3.1.2 布隆过滤器的缺点 误判率高：由于布隆过滤器使用多个哈希函数进行映射，误判率会随着哈希函数数量的增加而降低，但仍然存在误判率。
无法删除元素：由于布隆过滤器的位数组是基于哈希函数映射得到的，无法删除某个元素。
受限于容量：当元素数量过多时，误判率会增加，从而导致布隆过滤器失效。
1.3.1.3 布隆过滤器容易失效的场景 元素数量过多：当布隆过滤器中的元素数量过多时，误判率会增加，从而导致布隆过滤器失效。
哈希函数数量不足：布隆过滤器的误判率与哈希函数数量有关，当哈希函数数量不足时，误判率会增加，从而导致布隆过滤器失效。
元素分布不均匀：当元素在哈希函数映射后分布不均匀时，误判率会增加，从而导致布隆过滤器失效。
总的来说，布隆过滤器适用于需要快速判断元素是否存在于集合中的场景，但需要注意它的误判率和容量限制，以及容易失效的场景。在使用布隆过滤器时，需要根据具体场景进行调整，以达到合理的使用效果。
2 缓存雪崩 缓存雪崩是指缓存中大量的数据同时失效，导致大量的请求直接打到数据库上，从而使得数据库承受不了巨大的压力，最终导致整个系统崩溃的现象。缓存雪崩通常是由于缓存中的键同时过期或者缓存服务宕机等原因引起的。
2.1 缓存雪崩举例 在某个时间点，所有的缓存数据都过期了。由于缓存中不存在有效的数据，所有的请求都会直接打到数据库上，导致数据库承受巨大的压力，最终导致整个系统崩溃。
某个缓存服务宕机了，所有的请求都无法得到缓存服务的响应，直接打到数据库上，导致数据库承受巨大的压力，最终导致整个系统崩溃。
2.2 解决方法 缓存数据的过期时间设置随机，避免缓存数据同时失效。可以将缓存数据的过期时间加上一个随机值，避免缓存数据同时失效。比如，将缓存数据的过期时间加上一个随机值，可以使得缓存数据的失效时间分散在时间轴上，避免缓存数据同时失效。 redisTemplate.opsForValue().set("key", JSON.toJSONString(valueObject),30 + new Random().nextInt(100), TimeUnit.SECONDS); 使用分布式缓存，避免单点故障。使用分布式缓存可以避免单点故障，提高缓存服务的可用性。可以使用Redis Cluster、Memcached等分布式缓存来替代单机缓存。
数据预热，避免缓存冷启动。在系统启动或者低峰期时，将一些热点数据预先加载到缓存中，避免缓存冷启动。可以使用缓存预热技术实现。
多级缓存，避免缓存失效时的“一次性打击”。多级缓存可以避免缓存失效时的“一次性打击”，提高缓存服务的稳定性。可以使用本地缓存和分布式缓存相结合的方式来实现多级缓存。
数据库压力保护。可以通过限流、降级等手段来保护数据库，避免数据库承受巨大的压力。可以使用限流、降级等技术来控制数据库的访问量。
3 缓存击穿 缓存击穿是指缓存中不存在的数据被大量请求，导致请求直接打到数据库上，从而使得数据库承受巨大的压力，最终导致整个系统崩溃的现象。缓存击穿通常是由于热点数据集中、缓存过期时间设置不合理等原因引起的。
3.1 缓存击穿举例 某个商品的详情信息是热点数据，每秒有很多请求访问该商品详情信息。如果缓存中不存在该商品的详情信息，那么所有请求都会直接打到数据库上，导致数据库承受巨大的压力，最终导致整个系统崩溃。
某个恶意用户故意请求一个不存在于缓存中的key，每秒有很多请求访问该key。如果缓存中不存在该key，那么所有请求都会直接打到数据库上，导致数据库承受巨大的压力，最终导致整个系统崩溃。
3.2 解决方法 使用互斥锁或者分布式锁，避免缓存击穿。在缓存失效时，使用互斥锁或者分布式锁，避免缓存击穿。在使用锁的时候，需要注意锁的粒度，尽量避免锁的粒度过大，影响系统的并发性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/552bc612f6cb6aa9919b5b09bc8246fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/849215f74e6c841aebf073b126c3d4bd/" rel="bookmark">
			【K8s】基本存储、高级存储（PV和PVC）、配置存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景一、基本存储1、EmptyDir2、HostPath3、NFS 二、高级存储1、认识PV和PVC2、PV3、PVC4、生命周期 三、配置存储1、ConfigMap2、 Secret 背景 程序运行在容器中，而容器的生命周期可能极其短暂，容器销毁，数据丢失，因此，为了持久化容器中的数据，Volumn出现。
Volume是Pod中 能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个Pod里的多个容器挂载到具体的文件目录下。
kubernetes通过Volume实现：
同一个Pod中不同容器之间的数据共享数据的持久化存储 Volume的生命周期不与Pod中单个容器的生命周期相关，当容器终止或者重启时，Volume中的数据也不会丢失。
kubernetes的Volume支持多种类型：
简单存储：EmptyDir、HostPath、NFS高级存储：PV、PVC配置存储：ConfigMap、Secret 挂载，就是A挂载到B目录，就像A是个U盘，插到了B这个电脑上。那以后访问B目录就是在访问A目录。
一、基本存储 1、EmptyDir EmptyDir存储就是主机上的一个空目录。
EmptyDir是在Pod被分配到Node时创建的，它的初始内容为空，并且无须指定宿主机上对应的目录文件，因为kubernetes会自动分配一个目录，当Pod销毁时， EmptyDir中的数据也会被永久删除。其适用场景有：
临时空间，例如用于某些应用程序运行时所需的临时目录，且无须永久保留同一个pod中，一个容器需要从另一个容器中获取数据的目录（多容器共享目录） 案例：容器数据共享--EmptyDir 在一个Pod中准备两个容器nginx和busybox，然后声明一个Volume分别挂在到两个容器的目录中，然后nginx容器负责向Volume中写日志，busybox中通过命令将日志内容读到控制台。
创建一个volume-emptydir.yaml：
apiVersion: v1 kind: Pod metadata: name: volume-emptydir namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 ports: - containerPort: 80 volumeMounts: # 将logs-volume挂在到nginx容器中，对应的目录为 /var/log/nginx - name: logs-volume mountPath: /var/log/nginx - name: busybox image: busybox:1.30 command: ["/bin/sh","-c","tail -f /logs/access.log"] # 初始命令，动态读取指定文件中内容 volumeMounts: # 将logs-volume 挂在到busybox容器中，对应的目录为 /logs - name: logs-volume mountPath: /logs volumes: # 声明volume， name为logs-volume，类型为emptyDir - name: logs-volume emptyDir: {} 配置好两个容器目录和空目录挂载的关系，创建pod：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/849215f74e6c841aebf073b126c3d4bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d9fb976f414d65e43b21a8d701f29c9/" rel="bookmark">
			rtl仿真器-iverilog icarus安装和测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Icarus Verilog是一个轻量、免费、开源的Verilog编译器，基于C++实现，开发者是 Stephen Williams ，遵循 GNU GPL license 许可证，安装文件中已经包含 GTKWave支持Verilog/VHDL文件的编译和仿真，命令行操作方式，类似gcc编译器，通过testbench文件可以生成对应的仿真波形数据文件，通过自带的GTKWave可以查看仿真波形图，支持将Verilog转换为VHDL文件。
安装 sudo　apt-get install iverilog
sudo apt-get install gtkwave
测试 rtl add.v
module simple(A, B, C);
input [3:0] A;
input [3:0] B;
output [3:0] C;
// mix up the input bits
assign C = A&amp;B;
endmodule
TB tb.v
module simple_tb;
reg [3:0] A = 4’b1010;
reg [3:0] B = 4’b0101;
wire [3:0] C;
initial
begin
$dumpfile(“simple.vcd”);
$dumpvars(0, s);
$monitor(“A is %b, B is %b , C is %b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d9fb976f414d65e43b21a8d701f29c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f739ff3fec2b3ab14c8b8dc99f3d8642/" rel="bookmark">
			Java 数据结构之队列(Queue)详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、在Java中有哪些常见的队列？
2、Queue 接口分析
3、Deque 接口分析
4、PriorityQueue 的实现原理详解
5、使用Java数组实现队列的简单示例
1、在Java中有哪些常见的队列？ 在Java中，有一些常见的队列实现。下面是其中一些的列举：//队列也是一种线性的数据结构
ArrayList：ArrayList可以被用作队列，通过在列表末尾添加元素，并使用remove(0)方法从列表的开头删除元素。但是，由于在列表的开头删除元素会导致后续元素的移动，因此对于大量的插入和删除操作来说，ArrayList的性能可能不是最佳选择。LinkedList：LinkedList也可以用作队列。LinkedList实现了Queue接口，可以使用offer()方法在队列的末尾添加元素，使用poll()方法从队列的开头删除并返回元素。LinkedList对于插入和删除操作具有较好的性能，因为它使用了指针来链接元素，而不需要移动其他元素。ArrayBlockingQueue：ArrayBlockingQueue是一个有界阻塞队列，底层使用数组实现。它有一个固定的容量，并且在插入或删除元素时可能会阻塞线程，直到满足特定的条件。LinkedBlockingQueue：LinkedBlockingQueue是一个可选有界或无界的阻塞队列，底层使用链表实现。它具有类似于ArrayBlockingQueue的功能，但在内部实现上略有不同。PriorityBlockingQueue：PriorityBlockingQueue是一个支持优先级的无界阻塞队列。元素按照它们的优先级顺序被插入和删除。ConcurrentLinkedQueue：ConcurrentLinkedQueue是一个非阻塞无界队列，它适用于多线程环境。它使用链表实现，并且提供了高效的并发操作。 以上是Java中的一些常见队列实现。具体选择哪种队列取决于你的需求和使用场景。
2、Queue 接口分析 Queue接口是Java集合框架中定义的一个接口，它代表了一个先进先出（FIFO）的队列。Queue接口继承自Collection接口，它定义了一组方法来操作队列中的元素。下面是Queue接口的一些主要方法和特性的详细解释：
（1）添加元素：
boolean add(E element): 将指定的元素添加到队列的末尾，如果成功则返回true，如果队列已满则抛出异常。boolean offer(E element): 将指定的元素添加到队列的末尾，如果成功则返回true，如果队列已满则返回false。 （2）移除元素：
E remove(): 移除并返回队列头部的元素，如果队列为空则抛出异常。E poll(): 移除并返回队列头部的元素，如果队列为空则返回null。 （3）获取头部元素：
E element(): 获取队列头部的元素，但不移除它，如果队列为空则抛出异常。E peek(): 获取队列头部的元素，但不移除它，如果队列为空则返回null。 （4）队列大小：
int size(): 返回队列中的元素个数。boolean isEmpty(): 判断队列是否为空。 Queue接口还有一些其他方法，如clear()用于清空队列中的所有元素，contains(Object o)用于判断队列是否包含指定元素等。
Queue接口的常见实现类包括LinkedList、ArrayDeque和PriorityQueue等。LinkedList实现了Queue接口，并且还可以作为栈使用，它是一个双向链表。ArrayDeque是一个双端队列，它同时实现了Queue和Deque接口。PriorityQueue是一个基于优先级的队列，它允许元素按照优先级顺序被插入和删除。
通过使用Queue接口，我们可以方便地进行队列操作，如入队、出队、查看队列头部元素等。它在处理任务调度、消息传递等场景中非常有用。
Java Queue接口使用示例：
当使用Java中的Queue接口时，我们需要选择具体的实现类来创建一个队列对象。下面是一个使用Queue接口的示例，以LinkedList实现类为例：
import java.util.Queue; import java.util.LinkedList; public class QueueExample { public static void main(String[] args) { // 创建一个Queue对象 Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); // 添加元素到队列 queue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f739ff3fec2b3ab14c8b8dc99f3d8642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f742857ca6f4ca62d1964d785c81eee1/" rel="bookmark">
			diffusion扩散/GAN~3D
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、3DQD: Generalized Deep 3D Shape Prior via Part-Discretized Diffusion Process 提出一个通用的3D形状生成先验模型，专为多种3D任务量身定制，包括无条件形状生成、点云补全和跨模态形状生成等。
一方面，为了精确捕捉局部细节形状信息，利用VQ-VAE来索引基于广泛任务训练数据的紧凑codebook中的局部几何。另一方面，引入离散扩散生成器以模拟不同token之间的固有结构依赖关系。
同时，开发了一种多频融合模块（multi-frequency fusion module，MFM），以多频上下文信息为指导，抑制高频形状特征波动。让3D形状先验模型拥有高保真、多样化特征以及跨模态对齐能力，大量实验已证明了其在各种3D形状生成任务上的优越性能。
https://github.com/colorful-liyu/3DQD
2、Controllable Mesh Generation Through Sparse Latent Point Diffusion Models 网格生成（Mesh generation）在涉及计算机图形和虚拟内容的各种应用中具有很高的价值，但由于Mesh的不规则数据结构和同类别Mesh的不一致拓扑，为Mesh设计生成模型具有挑战性。
这项工作为Mesh生成设计了一种新的稀疏潜在点扩散模型。关键是将点云视为Mesh的中间表示，并对点云的分布进行建模。为了提高生成方法的效率和可控性，进一步将点云编码为具有逐点语义有意义特征的稀疏潜在点集，其中两个DDPM分别在稀疏潜在点空间中训练以分别模拟潜在点位置的分布以及这些潜在点处的特征。在这个潜在空间中采样要比直接采样密集点云快。
此外，稀疏潜在点还能显式控制生成Mesh的整体结构和局部细节。在ShapeNet数据集上进行了大量实验，提出的稀疏潜在点扩散模型在生成质量和可控性方面实现了与现有方法相比的优越性能。项目页面，代码和附录：https://slide-3d.github.io
3、GD-MAE: Generative Decoder for MAE Pre-training on LiDAR Point Clouds 尽管在开发视觉任务如图像和视频方面，Masked Autoencoders（MAE）取得了巨大进步，但由于固有的不规则性，探索大规模3D点云中的MAE仍然具有挑战性。与之前的3D MAE框架相比（设计复杂的解码器从维护区域推断掩蔽信息或采用复杂的掩蔽策略），提出了一种更简单的范例。
核心思想是应用生成解码器MAE（GD-MAE）自动将周围上下文合并，以按层次融合方式恢复掩蔽的几何知识。这样做，方法不需要引入解码器的启发式设计，并且可以灵活地探索各种掩蔽策略。相应的部分在与传统方法相比的延迟中减少不到12%，同时实现更好的性能。
展示了该方法在几个大型基准（Waymo、KITTI和ONCE）上得到的效果。在下游检测任务中持续改进，说明了强大的鲁棒性和泛化能力。方法展示了最先进的结果，值得注意的是，即使在Waymo数据集上只有20%的标记数据，也实现了可比拟的准确性。代码在https://github.com/Nightmare-n/GD-MAE
4、GINA-3D: Learning to Generate Implicit Neural Assets in the Wild 从传感器数据中模拟3D世界，是为诸如自动驾驶等机器人学习问题开发测试和验证环境的可扩展方法。然而，手动创建或重新创建类似真实世界的环境困难、昂贵且无法扩展。最近的生成模型技术通过仅使用大量的2D图像学习3D资源来取得了有望解决这类挑战的进展，但仍然具有局限性，因为它们利用的是人类策划的图像数据集或手动创建的合成3D环境的渲染。
本文介绍GINA-3D，一种生成模型，它使用来自摄像头和LiDAR传感器的真实驾驶数据创建真实的3D，包括多样化的车辆和行人。与现有图像数据集相比，真实世界驾驶环境由于遮挡、光照变化和长尾分布带来了新的挑战。GINA-3D通过将表示学习和生成建模分解为两个阶段，并借鉴最近在图像生成建模方面的进展，采用了一种学习的三平面潜在结构来应对这些挑战。
为了评估方法，构建了一个大型对象中心数据集，包含来自Waymo开放数据集的超过520K辆车辆和行人的图像，以及一组新的8万张长尾实例图像，如施工设备、垃圾车和缆车。将模型与现有方法进行比较，并证明它在生成的图像和几何方面的质量和多样性方面实现了最先进的性能。
5、Graphics Capsule: Learning Hierarchical 3D Face Representations from 2D Images 构建对象层次结构，对于人脑视觉过程非常重要。以前的研究已经成功地采用胶囊网络将digits和面部分解为部件，以无监督的方式研究神经网络中类似的感知机制。然而，它们的描述仅限于2D空间，限制了它们模仿人类固有的3D感知能力。
本文提出一种逆图形胶囊网络（Inverse Graphics Capsule Network，IGC-Net），用于从大规模未标记图像中学习分层3D人脸表示。IGC-Net的核心是一种新型胶囊，名为图形胶囊，它以计算机图形（CG）中的可解释参数表示3D图元，包括深度、反照率和3D姿态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f742857ca6f4ca62d1964d785c81eee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5e80ec1d194e86f58431e89221b7061/" rel="bookmark">
			（数字图像处理MATLAB&#43;Python）第八章图像复原-第一、二节：图像复原概述和图像退化模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一：图像复原概述二：图像退化模型（1）连续退化模型（2）离散退化模型 三：图像退化函数的估计（1）基于模型的估计法（2）运动模糊退化估计 一：图像复原概述 图像复原：在图像生成、记录、传输过程中，由于成像系统、设备或外在的干扰，会导致图像质量下降，称为图像退化，如大气扰动效应、光学系统的像差、物体运动造成的模糊、几何失真等。图像复原是指通过使用图像处理技术来恢复受损图像的原始信息，使其尽可能接近或恢复到原始图像的状态。图像复原的目标是消除或减轻图像中的噪声、模糊、失真或其他损坏，并尽量还原图像的细节和清晰度。图像复原的过程通常涉及以下几个步骤
损坏分析：首先，需要对受损的图像进行分析，了解图像损坏的类型和原因。常见的图像损坏包括噪声、模糊、运动模糊、伪影等恢复方法选择： 根据图像的损坏类型和特点，选择合适的图像复原方法。常见的复原方法包括滤波、去噪、去模糊、去振铃等处理技术应用： 根据选择的复原方法，应用相应的图像处理技术进行图像恢复。这可能包括频域滤波、空域滤波、图像修复、插值等技术参数调整和优化： 在应用处理技术时，通常需要调整一些参数来优化图像复原效果。这些参数可能包括滤波器类型、阈值、平滑度等结果评估： 最后，需要评估复原后的图像质量。可以使用一些评估指标如**峰值信噪比（PSNR）、结构相似性指数（SSIM）**等来量化评估图像复原的效果 图像复原在许多领域都有应用，如医学影像、遥感图像、监控图像等。通过图像复原，我们可以提高图像质量，恢复图像的细节和清晰度，以便更好地进行图像分析、视觉识别和人工智能等任务
二：图像退化模型 图像退化模型：是描述图像损失或退化过程的数学模型。它用于模拟和理解图像在获取、传输或存储过程中所遭受的各种损失和变化。通过建立适当的退化模型，我们可以更好地理解图像退化的原因，并设计相应的图像复原算法。常见的图像退化模型包括以下几种
噪声模型：噪声是图像中不希望的随机干扰。图像在捕捉、传输或处理过程中常常会受到各种噪声的影响，如高斯噪声、椒盐噪声等。噪声模型用于描述噪声对图像的影响，通常使用统计方法或概率模型来建模噪声的特性和分布模糊模型：模糊是指图像中的细节变得不清晰或模糊不清。图像在采集或传输过程中，可能会受到镜头的散焦、摄像机或对象的运动等因素的影响而导致模糊。模糊模型用于描述这些因素对图像的影响，例如点扩散函数（PSF）模型用于描述模糊的程度和类型压缩模型：图像压缩是为了减小图像文件的大小以便于存储和传输。压缩过程中可能会引入压缩伪影和信息丢失。压缩模型用于描述压缩算法对图像质量的影响，例如JPEG压缩模型可以模拟JPEG算法对图像的失真过程几何变换模型：几何变换是指图像在旋转、缩放、平移或扭曲等操作下的形状变化。这些变换可能会导致图像的形状和结构发生改变。几何变换模型用于描述这些变换对图像的影响，例如仿射变换模型或投影变换模型 （1）连续退化模型 连续退化模型：一种描述图像退化过程的数学模型，它考虑了图像在连续时间或空间中的变化。这些模型通常基于物理原理或实验观察，并用数学公式表示图像在退化过程中的变化
模糊模型：模糊是指图像中细节变得不清晰或模糊不清。模糊可以由光学系统的散焦问题、运动模糊、大气湍流等因素引起。模糊模型使用点扩散函数（PSF）来描述图像中物体的模糊效应。典型的模糊模型包括线性运动模糊模型、高斯模糊模型、盲模糊模型等噪声模型：噪声是图像中的随机干扰。图像在获取、传输和处理过程中可能会受到各种噪声的影响，例如高斯噪声、椒盐噪声等。噪声模型使用概率分布函数来描述噪声的统计特性，如高斯噪声模型使用高斯分布描述曝光模型：曝光是指图像的亮度过程，包括光照条件和相机的曝光设置。过曝光和欠曝光会导致图像的细节丢失和对比度变差。曝光模型通常考虑光源的强度、反射率和相机的曝光参数，使用曝光函数来描述图像的亮度变化色彩模型：色彩模型用于描述图像的颜色变化，包括颜色偏移、饱和度变化等。色彩模型考虑光源的光谱分布和物体的反射特性，使用颜色转换函数来描述图像的色彩变化 抽象为一个退化系统 H H H以及加性噪声的影响
g ( x , y ) = H [ f ( x , y ) ] + n ( x , y ) g(x, y)=H[f(x, y)]+n(x, y) g(x,y)=H[f(x,y)]+n(x,y)
用线性、空间不变系统模型来模拟实际中的非线性和空间变化模型
H [ f ( x , y ) ] = f ( x , y ) ∗ h ( x , y ) = ∫ − ∞ ∞ ∫ − ∞ ∞ f ( α , β ) h ( x − α , y − β ) d α d β H[f(x, y)]=f(x, y) * h(x, y)=\int_{-\infty}^{\infty} \int_{-\infty}^{\infty} f(\alpha, \beta) h(x-\alpha, y-\beta) d \alpha d \beta H[f(x,y)]=f(x,y)∗h(x,y)=∫−∞∞​∫−∞∞​f(α,β)h(x−α,y−β)dαdβ
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5e80ec1d194e86f58431e89221b7061/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0970942d0ec8866466f65da1e88ed55/" rel="bookmark">
			python转化为json格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转化为JSON格式
JSON是一种常用的数据交换格式，该格式在前端与后端数据传输和处理中非常常见。在Python中将数据转化为JSON格式是一个非常常见的需求，Python中自带的json模块可以非常方便地实现这个需求。
转化为json格式
第一步：导入json模块
在Python中，要使用json模块需要先导入模块，可以使用如下语句导入：
import json 第二步：将数据转化为JSON格式
在Python中，使用json模块将数据转化为JSON格式非常简单。比如我们有一个Python字典数据如下：
data = { \name\ \John\ \age\ 30, \city\ \New York\} 我们可以使用json模块中的dumps函数来将该字典转化为JSON格式，代码如下：
json_data = json.dumps(data) 这样，我们就将Python字典数据转化为了JSON格式的字符串数据，该字符串数据可以方便地在前端与后端之间传输和处理。
第三步：将JSON格式数据转化为Python字典
同样地，在Python中使用json模块将JSON格式数据转化为Python字典也非常简单。比如我们有一个JSON格式的字符串数据如下：
json_data = '{\name\ \John\ \age\ 30, \city\ \New York\' 我们可以使用json模块中的loads函数来将该JSON格式数据转化为Python字典，代码如下：
data = json.loads(json_data) 这样，我们就将JSON格式数据转化为了Python字典数据，可以方便地在Python中进行处理和使用。
总结
在Python中将数据转化为JSON格式和将JSON格式数据转化为Python字典都非常简单，只需要使用json模块中的dumps和loads函数即可。使用JSON格式数据可以方便地在前端与后端之间传输和处理数据，这在Web开发中非常常见。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eecd98dd2c0da83865ef0a29ef27408e/" rel="bookmark">
			Python utf-8编码转换方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python utf-8编码转换方法
在Python编程开发中，我们经常需要处理各式各样的字符串，其中，涉及到字符串的编码问题就是一个很重要的方面。特别是在我们需要将数据传输到不同的系统或应用程序中，正确的编码就至关重要。其中，UTF-8编码是一种常用的编码方式，下面我们就来详细了解一下Python中如何进行UTF-8编码的转换方法。
Python中的文本编码
Python3.x中，字符串是以Unicode编码方式存储的，而不是像Python2.x中的字符串，以ASCII编码方式存储。这意味着，Python3.x可以支持多种语言的字符集，包括中文、日语、韩语等，也可以精准表示所有的字符，无论是ASCII字符还是非ASCII字符。
在Python编程中，我们常常需要将字符串转换成其他编码方式，比如UTF-8编码方式。这种转换方法需要使用Python中的encode()和decode()函数。Python中的UTF-8编码转换方法
2.1 encode()方法
在Python中，encode()方法可以将Unicode编码的字符串转换成UTF-8编码的字符串。具体代码如下： str1 = \Python utf-8编码转换方法\str2 = str1.encode('utf-8') print(str2) 输出结果为：
b'Python utf-8\\xe7\\xbc\\x96\\xe7\\xa0\\x81\\xe8\\xbd\\xac\\xe6\\x8d\\xa2\\xe6\\x96\\xb9\\xe6\\xb3\\x95' 在代码中，我们首先定义了一个字符串str1，然后使用encode()函数将它转换成UTF-8编码的字符串，存储在变量str2中。最后，使用print()函数输出变量str2的值。
需要注意的是，函数encode()的参数是需要转换的编码方式，也就是目标编码方式。在本例中，我们需要将Unicode编码的字符串转换成UTF-8编码，因此参数为’utf-8’。
2.2 decode()方法
在Python中，decode()方法可以将UTF-8编码的字符串转换成Unicode编码的字符串。具体代码如下：
str1 = b'Python utf-8\\xe7\\xbc\\x96\\xe7\\xa0\\x81\\xe8\\xbd\\xac\\xe6\\x8d\\xa2\\xe6\\x96\\xb9\\xe6\\xb3\\x95' str2 = str1.decode('utf-8') print(str2) 输出结果为：
Python utf-8编码转换方法 在代码中，我们首先定义了一个UTF-8编码的字符串str1，然后使用decode()函数将它转换成Unicode编码的字符串，存储在变量str2中。最后，使用print()函数输出变量str2的值。
需要注意的是，函数decode()的参数也是需要转换的编码方式，也就是原始编码方式。在本例中，我们需要将UTF-8编码的字符串转换成Unicode编码，因此参数为’utf-8’。
3. 总结
在Python编程开发中，处理字符串的编码问题是很重要的一部分。特别是在跨系统传输数据中，正确的编码方式可以保证数据的准确性和完整性。在Python中，我们可以使用encode()和decode()函数进行字符串的编码转换，其中，UTF-8编码是一种常用的编码方式，需要我们掌握其转换方法。希望本文能为大家提供一些参考和帮助，让我们在Python编程中更加得心应手。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e0e1506df7501b0b8389f69baa66235/" rel="bookmark">
			python字符串转换成数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从字符串到数字：Python 中的转换方法
在 Python 编程语言中，字符串和数字是两种不同的数据类型。然而，在实际开发中，我们经常需要将字符串转换成数字类型来进行运算或其他操作。本文将介绍 Python 中进行字符串转换成数字的几种方法。
字符串转换成数字
int() 函数 Python 中内置的 int() 函数可以将字符串转换成整数。如果字符串中包含非数字字符，则会抛出 ValueError 异常。例如：
&gt;&gt;&gt; num_str = \123\&gt;&gt;&gt; num_int = int(num_str) &gt;&gt;&gt; print(num_int) 123 &gt;&gt;&gt; num_str = \abc\&gt;&gt;&gt; num_int = int(num_str) Traceback (most recent call last): File \stdin&gt;\ line 1, in ValueError: invalid literal for int() with base 10: 'abc' int() 函数还可以指定进制参数，例如：
&gt;&gt;&gt; num_str = \101\&gt;&gt;&gt; num_int = int(num_str, 2) &gt;&gt;&gt; print(num_int) 5 &gt;&gt;&gt; num_str = \FF\&gt;&gt;&gt; num_int = int(num_str, 16) &gt;&gt;&gt; print(num_int) 255 float() 函数 与 int() 函数类似，Python 中的 float() 函数可以将字符串转换成浮点数。如果字符串中包含非数字字符，则会抛出 ValueError 异常。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e0e1506df7501b0b8389f69baa66235/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaf5bff8a740e2d4386a2e83e6a457f3/" rel="bookmark">
			多目标跟踪：视觉联合检测和跟踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国内头部以自动驾驶全站技术为主线的交流学习社区（感知、归控等），包含大量前沿论文解读、工程实践(源代码)、视频课程，热招岗位。欢迎加入！
点击上方“迈微AI研习社”，选择“星标★”公众号
重磅干货，第一时间送达
Joint detection and tracking （同时实现检测和跟踪）是Multiple Object Tracking（MOT）的一个重要研究方向。Multiple Object Tracking，多目标跟踪， 主要包括两个过程（Detection + ReID，Detection 是检测出图像或者点云中的目标框从而获取目标的位置，而ReID是将序列中同一个目标关联起来） ，因此一方面这涉及到时间和空间的特征学习和交互，另一方面也涉及到检测和重识别（特征的embedding）的多任务学习，导致MOT任务。目前MOT可以分成三大类（如图一所示）:
SDE(Separate Detection and Embedding), 或者称为Tracking-by-detection, 该类的想法也非常直接，将多目标跟踪这个任务进行拆分，先进行单帧的目标检测得到每帧的目标框，然后再根据帧间同一目标的共性进行关联(association)，帧间的关联的重要线索包括appearance, motion, location等，典型的代表算法包括SORT和Deep SORT。这类算法的优点是简单，将Detection和ReID解耦分开解决。例如上述的SORT和Deep SORT的检测器可以不受到限制，使用SOTA的检测方法，在目标关联上使用卡尔曼滤波＋匈牙利匹配等传统方法。但是缺点也很明显，就是解耦开无法促进多任务学习，特别受限目标关联阶段的方法而且依赖目标检测算法，也只能处理比较简单的场景。
Two-Stage方法也可称之为Tracking-by-detection，只不过其中的ReID变成第一阶段网络学习得到的ROI特征然后在第二阶段进行embedding特征的学习，相对于第一类进步点在于 appearance特征 可由第一阶段获得，但是两阶段方法的诟病是inference比较慢,而且我觉得detection特征和embedding特征还是没有构成多任务学习的状态。
JDE(Joint Detection and Embedding)或者是Joint detection and tracking 这类算法是在一个共享神经网络中同时学习Detection和Embedding，使用一个多任务学习的思路共享特征学习网络参数并设置损失函数，从而可以实现Detection和ReID的交互和促进，然后由于属于一阶段模型，因此在速度上是可以达到实时，所以是可以保证应用的。因此是Joint detection and tracking 这类算法我们关注的重点。
同时为了实现Joint detection and tracking，需要解决如下几个问题（也包括一些思路）：
多任务学习中如何同时输出检测和帧间的数据关联,　特别是数据关联如何实现？损失函数如何设计？
目前看到的方案中主要分成两大类，一种是通过motion based 例如一个head实现输出目标的速度或者是目标的偏移，然后通过位置关联实现（CenterTrack系列）。另外一种是appearance based 在新增加的heading中通过对比学习得到各目标在特征上的差异, 但是匹配还是通过计算相似度并且二分匹配，也不是真正意义上的Joint detection and tracking。
网络设计上如何实现detection和embedding的联合训练？
Detection和ReID模型的学习是存在不公平的过度竞争的，这种竞争制约了两个任务（检测任务和 ReID 任务 ）的表示学习，导致了学习的混淆。具体而言，检测任务需要的是同类的不同目标拥有相似的语义信息（类间距离最大），而ReID要求的是同类目标有不同的语义信息（类内距离最大）。
需要将对embedding分支和现detection分支分开，以及可以在embedding内部进行注意力机制的建模。（CSTrack里面引入自相关注意力机制和互相关权重图）
浅层特征对于ReID任务更有帮助，深层特征对于Detection任务更有帮助。(FairMOT)
Detection和Tracking模型的相互促进，如何做到Detection帮助Tracking, Tracking反哺Detection（TraDeS构建CVA和MFW分别进行匹配和特征搬移，该部分和多帧的特征学习相似，利用学习到的运动信息搬移历史特征到当前帧，辅助当前帧的目标检测）
在图像里目标较大的尺度变化也对embedding的学习有很大的影响，之前embedding的学习是固定大小的proposal区域。（CSTrack里引入尺度感知注意力网络）
如何进行多帧的学习，时间和空间的交互？
目前大部分的网络输入的一帧或者两帧，学习到的数据关联都是短时的，如何拓展到任意多帧，例如使用convGRU的方法等（可以参见Perma Track）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaf5bff8a740e2d4386a2e83e6a457f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2b140d959e6cfbed90da198cb80ddfe/" rel="bookmark">
			CSDN的常用技巧（字体、颜色、大小、类型、背景标记、删除、居中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN的常用文本设置（字体、颜色、大小、类型等） 一、字体设置二、绘制表格三、下划线四、首行缩进五、设置插入图片的大小六、空格七、 黑点八、 背景标记 、删除文本九、文字居中 一、字体设置 CSDN Markdown编辑器对字体设置的实现是通过代码来实现的，调节字体类型、颜色、大小的代码如下：
&lt;font face="字体" color=颜色 size=3&gt; 这里放入要修改的文字&lt;/font&gt; face——是调节字体类型，可随意改写“楷体、黑体、微软雅黑、宋体等”；
color——是字体颜色，填写颜色的英文单词，也根据十六进制颜色值进行改变；
size——是字体大小，默认为3。
常用的几种字体颜色，列表如下：
颜色英文单词十六进制颜色值黑色Black#000000红色Red#FF0000黄色Yellow#FFD700蓝色Blue#0000CD绿色Green#00FF00 示例：只修改颜色、大小
&lt;font color= red size=5&gt;CSDN字体修改，这里放入要修改的文字 CSDN字体修改，这里放入要修改的文字
后面加上　&lt;　/font&gt; 控制范围结束
&lt;font color= red size=5&gt;CSDN字体修改&lt;/font&gt;，这里放入要修改的文字 CSDN字体修改，这里放入要修改的文字
&lt;font color= blue size=8&gt;CSDN字体修改 CSDN字体修改
示例：修改字体、颜色、大小
&lt;font color= #FF0000 face="宋体" size=5&gt;这里放入要修改的文字 这里放入要修改的文字
&lt;font color= #FF0000 face="宋体" size=5&gt;这里放入要修改的文字&lt;/font&gt;，后面加上&lt;/font&gt;控制范围结束 这里放入要修改的文字
&lt;font color= red face="宋体" size=5&gt;这里放入要修改的文字 这里放入要修改的文字
&lt;font color= blue face="楷体" size=5&gt;这里放入要修改的文字 这里放入要修改的文字
二、绘制表格 | | | |表头空格处填写文字，列数这增加
|–|–|–| 第二行，固定格式，虚线不可修改，列数这增加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2b140d959e6cfbed90da198cb80ddfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/226504e033d5a1cdfacf907b7cb135ba/" rel="bookmark">
			机器学习实战：Python基于Logistic逻辑回归进行分类预测（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 前言1.1 Logistic回归的介绍1.2 Logistic回归的应用 2 iris数据集数据处理2.1 导入函数2.2 导入数据2.3 简单数据查看 3 可视化3.1 条形图/散点图3.2 箱线图3.3 三维散点图 4 建模预测4.1 二分类预测4.2 多分类预测 5 讨论 1 前言 1.1 Logistic回归的介绍 逻辑回归（Logistic regression，简称LR）是一种经典的二分类算法，它将输入特征与一个sigmoid函数进行线性组合，从而预测输出标签的概率。该算法常被用于预测离散的二元结果，例如是/否、真/假等。
优点：
实现简单。Logistic回归的参数可以用极大似然估计法进行求解，算法本身非常简单。
速度快。Logistic回归计算量小，训练速度快。
输出结果易于理解。Logistic回归的输出结果是概率，易于解释。
容易扩展。Logistic回归可用于多分类问题和不平衡数据集。
缺点：
只适用于线性可分的问题。当特征之间存在非线性关系时，Logistic回归的效果会受到限制。
对异常值敏感。由于Logistic回归使用了sigmoid函数，对于异常值非常敏感。
容易欠拟合。当特征与目标变量之间的关系非常复杂时，Logistic回归很容易出现欠拟合现象。
1.2 Logistic回归的应用 Logistic回归广泛应用于许多领域，包括：
金融风险评估。银行和信用卡公司使用Logistic回归来评估借款人的信用风险，预测贷款违约的概率。
医学诊断。Logistic回归可以用于预测患者是否患有某种疾病或病情的严重程度。
市场分析。Logistic回归可以用于预测产品或服务的市场需求，并帮助企业做出更好的决策。
自然语言处理。Logistic回归可以用于文本分类，例如判断一段文本是否属于某个主题或情感极性。
图像处理。Logistic回归可以用于图像分类和目标检测，例如识别数字和字母。
总之，Logistic回归是一种灵活的算法，可以应用于许多不同的领域和问题，特别是在需要预测二元结果的场景中表现出色。
2 iris数据集数据处理 iris数据集共有150个样本，目标变量为花的类别其都属于鸢尾属下的三个亚属（target），分别是山鸢尾 (Iris-setosa)，变色鸢尾(Iris-versicolor)和维吉尼亚鸢尾(Iris-virginica)。
四个特征，分别是花萼长度(sepal length)、花萼宽度(sepal width)、花瓣长度(petal length)、花瓣宽度(petal width)。
2.1 导入函数 import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/226504e033d5a1cdfacf907b7cb135ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/928f870de812c5182cc01fe1404ef7d2/" rel="bookmark">
			JVM GC（垃圾回收机制）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是垃圾回收？
“垃圾”是指在内存堆中长时间未使用或者已经死亡了的数据；
“回收”是指将该数据从内存堆中进行移除。
2、垃圾回收存在的意义是什么？
内存是我们程序运行的载体，如果这个载体出现多无效数据、超负荷甚至是溢出（即内存泄漏）的话，那么我们的程序运作是会严重受限甚至是出错乃至终止等等，因此我们需要进行一定程度的垃圾回收，以便尽可能的保证内存堆中的数据是高效有存在意义的，保障内存的可持续存在。
3、如何进行“垃圾”的确定呢？
虽然我们已经知道内存中的一些不可用数据是需要移除的，那我们又应该如何去确定哪些数据是不可用的，即哪些数据是“垃圾”？以下分享垃圾回收机制中确定“垃圾”的两种方法。
引用计数法
在Java中，引用与对象是有关联的，即对象在内存中会分配一个记录该对象被引用次数的存储空间，简单来说就是该对象在程序中被引用一次，则引用次数就加一。因此，当该对象的引用次数未0时，说明该对象可为可回收对象。
可达性分析法
该方法的存在一定程度上解决了引用计数法中循环引用的问题。该方法呢是通过一系列的“GC roots”对象作为起点去搜索和其他对象之间有没有可达的路径，若不可达，则为可回收对象。同时，在此也需注意，不是说可回收对象一被确认就一定会被回收，而是需要经过两轮的标记过程才会被回收。
4、垃圾是如何进行回收的呢？
在垃圾回收机制中，有四种回收垃圾的方法，如下：
标记清楚算法
该方法是最基础的算法，主要为 标记 和 清楚 两个阶段。即标记可回收对象，清楚可回收对象。
如图，该方法的一个缺点即是内存碎片化严重，当一个对象所需内存较大时，内存由于碎片化严重可能会出现无法分配对象内存的情况。
复制算法
该方法一定程度上解决了标记清楚算法中产生的内存碎片化的现象的问题。该方法的实现原理主要是将内存分为等大的两片区域。即将当前需要的对象的内存片分配到同一片1/2区域中，当该1/2区域的内存快满时，则将不可回收对象完整复制到另一个1/2区域中，之后将原先的1/2区域的所有对象移除。
如图，可以看出该方法很好的解决了内存碎片化的问题，但与此同时也产生了另一个问题，就是在内存的使用效率上降低了1/2，这对于我们进行程序运行来说是很不友好的，而且内存的空间也是我们计算机性能的一个体现。
标记整理算法
该方法是较为完美的解决了上面两个算法的问题，当然也是上面两个方法的另一种事项方式。即不断的将可回收对象进行内存移除，同时将不可回收对象进行同一极端移动，从而保证各个对象之间是一直紧凑一起的。
分代收集算法
分代收集法是目前大部分JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(YoungGeneration)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。
新生代与复制算法
目前大部分JVM的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1: 1来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另块Survivor 空间中。
老年代与标记复制算法
而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法
1、JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储 cass 类,常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。
2、对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor目前存放对象的那一块)，少数情况会直接分配到老生代。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/928f870de812c5182cc01fe1404ef7d2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/135/">«</a>
	<span class="pagination__item pagination__item--current">136/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/137/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>