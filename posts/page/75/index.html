<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cd39df3a682a31ccd42b8e9182ac3e1/" rel="bookmark">
			【深度神经网络(DNN)】实现车牌识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、数据集介绍二、步骤1.导包2.参数配置3.数据处理4.模型定义5.模型训练6.模型预测 总结 前言 课内实践作业 车牌识别
一、数据集介绍 1.车牌识别数据集：VehicleLicense车牌识别数据集包含16151张单字符数据，所有的单字符均为严格切割且都转换为黑白二值图像（如下第一行：训练数据所示）。
2.characterData：车牌识别数据集
二、步骤 1.导包 代码如下（示例）：
#导入需要的包 import os import zipfile import random import json import cv2 import numpy as np from PIL import Image import paddle import matplotlib.pyplot as plt print(cv2.__version__) 2.参数配置 ''' 参数配置 ''' train_parameters = { "input_size": [1, 20, 20], #输入图片的shape "class_dim": -1, #分类数 "src_path":"data/data47799/characterData.zip", #原始数据集路径 "target_path":"/home/aistudio/data/dataset", #要解压的路径 "train_list_path": "/home/aistudio/train_data.txt", #train_data.txt路径 "eval_list_path": "/home/aistudio/val_data.txt", #eval_data.txt路径 "label_dict":{}, #标签字典 "readme_path": "/home/aistudio/data/readme.json", #readme.json路径 "train_batch_size": 32 #训练的轮数 } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cd39df3a682a31ccd42b8e9182ac3e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2df090b083fb4773385f80fe4b5cd55b/" rel="bookmark">
			docker搭建EMQX集群&#43;nginx转发TCP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、三台机器安装
1、三台都拉取镜像
docker pull emqx/emqx:5.0.26 2、三台分别运行镜像
第一台
docker run -itd --network host --name emqx --restart always \ -p 1883:1883 \ -p 18083:18083 \ -p 8083:8083 \ -p 8883:8883 \ -p 8080:8080 \ -e EMQX_NAME="master1" \ -e EMQX_HOST=localhost1 \ -e EMQX_LISTENER__TCP_EXTERNAL=1883 \ -e EMQX_WAIT_TIME=30 \ -e EMQX_CLUSTER__DISCOVERY="static" \ -e EMQX_JOIN_CLUSTER="master1@localhost1" \ -e EMQX_CLUSTER__STATIC__SEEDS="master1@localhost1,master2@localhost2,master3@localhost3" \ emqx/emqx:5.0.26 第二台
docker run -itd --network host --name emqx --restart always \ -p 1883:1883 \ -p 18083:18083 \ -p 8083:8083 \ -p 8883:8883 \ -p 8080:8080 \ -e EMQX_NAME="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2df090b083fb4773385f80fe4b5cd55b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38cd7f314e0c083ed1417302f8f4099f/" rel="bookmark">
			node.js连接mysql出现错误：ER_NOT_SUPPORTED_AUTH_MODE Client does not support authentication protocol..
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm i mysql 改用npm i mysql2
导入mysql模块时使用const mysql=require(‘mysql2’)
即可解决问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4b7c74354a6454dd0ff08973d917b9a/" rel="bookmark">
			ContentProvider call实现跨进程通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github.com/wengeoo/PEvent.git 1、ContentProvider query 作为 Android 四大基础组件之一的 ContentProvider 本来它的作用只是提供内容性质的跨进程访问。APP-A通过APP-B的ContentProvider相关实现，可以获取B的向外暴露的SQL或者SP数据，但是A如何通知B去更新ContentProvider的相关内容？
传统方式有1：广播；2：AIDL，弊端是使用流程相对繁琐 2、ContentProvider call 在 API 11 (Android 3.0) 中，ContentProvider 加入了一个新的方法，可以用来进行跨进程的方法调用，ContentProvider 中这个方法的定义如下：
Bundle call(String method, String arg, Bundle extras)
看看具体实现
A中实现
private void update(String status) { getContext().getContentResolver().call(ACCOUNT_URI, "STATUS", status, new Bundle()); } B中实现
@Override public Bundle call(String method, String arg, Bundle extras) { if ("STATUS".equals(method)) { //dosomething } return null; } A中就能触发B的具体逻辑操作，类似复写，B也可以触发A的操作
3、继续扩展 我们实现一个基础库，通过ContentProvider+反射实现A调用B接口，B调用A接口，简化使用流程
3.1、实现一个基础IContentProvider，A/B中都继承
@Nullable @Override public Bundle call(@NonNull String method, @Nullable String arg, @Nullable Bundle in) { if (in == null) { return null; } long start = SystemClock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4b7c74354a6454dd0ff08973d917b9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dd920f7668492f48f84ca2966b6f6c0/" rel="bookmark">
			【深度学习】Python爬取豆瓣实现影评分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、任务描述二、使用步骤1.数据爬取1.2.对爬取的页面数据进行解析，并保存为JSON文件2、数据分析2.1数据分析之评论时间分布图2.2角色评分 前言 爬虫的过程，就是模仿浏览器的行为，往目标站点发送请求，接收服务器的响应数据，提取需要的信息，并进行保存的过程。
Python为爬虫的实现提供了工具:requests模块、BeautifulSoup库
一、任务描述 本次实践使用Python来爬取豆瓣网中《安家》下所有的评论，进行了一波分析，从观众的角度来了解这部电视剧。
数据获取：https://movie.douban.com/subject/30482003/reviews?sort=time&amp;start=0
普通用户: 打开浏览器 --&gt; 往目标站点发送请求 --&gt; 接收响应数据 --&gt; 渲染到页面上。 爬虫程序: 模拟浏览器 --&gt; 往目标站点发送请求 --&gt; 接收响应数据 --&gt; 提取有用的数据 --&gt; 保存到本地/数据库。 爬虫的过程： 1.发送请求（requests模块） 2.获取响应数据（服务器返回） 3.解析并提取数据（BeautifulSoup查找或者re正则） 4.保存数据 request模块： requests是python实现的简单易用的HTTP库，官网地址：http://cn.python-requests.org/zh_CN/latest/ requests.get(url)可以发送一个http get请求，返回服务器响应内容。 BeautifulSoup库： BeautifulSoup 是一个可以从HTML或XML文件中提取数据的Python库。网址：https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/ BeautifulSoup支持Python标准库中的HTML解析器,还支持一些第三方的解析器,其中一个是 lxml。 BeautifulSoup(markup, "html.parser")或者BeautifulSoup(markup, "lxml")，推荐使用lxml作为解析器,因为效率更高。 二、使用步骤 # 如果需要进行持久化安装, 需要使用持久化路径, 如下方代码示例: !mkdir /home/aistudio/external-libraries !pip install beautifulsoup4 -t /home/aistudio/external-libraries !pip install lxml -t /home/aistudio/external-libraries !pip install xgboost==1.1.0 -t /home/aistudio/external-libraries !pip install wordcloud -t /home/aistudio/external-libraries # 同时添加如下代码, 这样每次环境(kernel)启动的时候只要运行下方代码即可: import sys sys.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dd920f7668492f48f84ca2966b6f6c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/095f1b9a9e8af0ddc54d33935ad97f3c/" rel="bookmark">
			【深度学习】手写数字识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、步骤1.导包2.查看数据集图片3.多层感知器4.结果 总结 一、步骤 1.导包 #导入需要的包 import numpy as np import paddle as paddle import paddle.fluid as fluid from PIL import Image import matplotlib.pyplot as plt import os from paddle.fluid.dygraph import Linear print("本教程基于Paddle的版本号为："+paddle.__version__) from paddle.vision.transforms import Compose, Normalize transform = Compose([Normalize(mean=[127.5],std=[127.5],data_format='CHW')]) print('下载并加载训练数据') train_dataset = paddle.vision.datasets.MNIST(mode='train', transform=transform) test_dataset = paddle.vision.datasets.MNIST(mode='test', transform=transform) print('加载完成') 2.查看数据集图片 train_data0, train_label_0 = train_dataset[0][0],train_dataset[0][1] train_data0 = train_data0.reshape([28,28]) plt.figure(figsize=(2,2)) print(plt.imshow(train_data0, cmap=plt.cm.binary)) print('train_data0 的标签为: ' + str(train_label_0)) print(train_dataset[0],type(train_dataset[0])) 3.多层感知器 # 定义多层感知器 #动态图定义多层感知器 class multilayer_perceptron(paddle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/095f1b9a9e8af0ddc54d33935ad97f3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baa49547e5de1d2f9ca1a7474022078a/" rel="bookmark">
			【机器学习】梯度下降预测波士顿房价
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、数据集介绍二、预测房价代码1.引入库2.数据3.梯度下降 总结 前言 梯度下降算法学习。
一、数据集介绍 波士顿房价数据集：波士顿房价数据集，用于线性回归预测
二、预测房价代码 1.引入库 from sklearn.linear_model import LinearRegression as LR from sklearn.model_selection import train_test_split from sklearn.datasets import load_boston as boston import matplotlib.pyplot as plt from sklearn.utils import shuffle import numpy as np from sklearn.metrics import mean_squared_error 2.数据 def preprocess(): # get the dataset of boston X = boston().data y = boston().target name_data = boston().feature_names # draw the figure of relationship between feature and price plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baa49547e5de1d2f9ca1a7474022078a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30fe922408c67c72d1578f4a32b3699c/" rel="bookmark">
			R语言实操记录——导出高清图片（矢量图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R语言 R语言实操记录——导出高清图片（矢量图）
文章目录 R语言一、起因（闲聊，可跳过）二、如何在R中导出高清图片（矢量图）2.1、保存为EPS图片格式后转AI编辑2.2、保存为PDF格式（推荐）2.3、用ggplot2包的ggsave函数输出图片（非全部适用） 三、矢量图与位图 一、起因（闲聊，可跳过） 最近需要用到环状图，照着说明书浅学了一下circlize包（网上的教程几乎全是机翻后的说明书内容，远不如直接看说明书，然说明书又太长，后续补一份文章，讲一下我自己的理解思路，方便后续生疏后可以快速上手），在成图的时候发现图片质量很差，就连坐标轴都是歪的。例如下图。
附上代码：
circlize_plot = function() { set.seed(12345) sectors = letters[1:10] circos.initialize(sectors, xlim = c(0, 1)) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { circos.points(runif(20), runif(20), cex = 0.5, pch = 16, col = 2) circos.points(runif(20), runif(20), cex = 0.5, pch = 16, col = 3) circos.axis(labels.cex = 0.6) }) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { circos.lines(sort(runif(20)), runif(20), col = 4) circos.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30fe922408c67c72d1578f4a32b3699c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8925ee4db903a239f9138805eeb8752/" rel="bookmark">
			【算法与数据结构】--算法和数据结构的进阶主题--算法的优化和性能调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法的关键性和优化算法的必要性是计算机科学和软件开发领域的核心概念。
算法的关键性：
基础构建块：算法是计算机科学的基础构建块，用于解决各种问题，从简单的任务如搜索和排序，到复杂的问题如机器学习和图算法。计算效率：算法直接影响计算效率。一个高效的算法可以在合理的时间内解决大规模问题，而低效的算法可能需要很长时间或不切实际。资源利用：优化算法可以有效地使用计算资源，如处理器时间和内存。这对于节省成本和提高性能至关重要。用户体验：在实际应用中，用户通常期望快速响应。优化的算法能够提供更好的用户体验，减少等待时间。 优化算法的必要性：
资源效率：资源是有限的，优化算法有助于有效管理和利用资源。这包括减少计算成本、内存使用和带宽。规模扩展性：随着问题规模的增加，低效算法的性能急剧下降。通过优化，算法可以更好地扩展以应对更大的数据集和工作负载。竞争优势：在商业和科研领域，性能和效率是竞争的关键。优化算法可以帮助组织获得竞争优势，提供更好的产品和服务。节省资源：优化算法有助于节省硬件资源（例如云计算成本），能源（例如移动设备电池寿命）以及减少对环境的影响解决困难问题：某些问题是计算上的困难问题，没有高效算法可能无法解决。优化算法可以使这些问题的解决变得切实可行。 一、算法分析 1.1 算法复杂度 算法复杂度是评估算法性能和效率的重要概念，它通常分为时间复杂度和空间复杂度两个方面。
时间复杂度：时间复杂度描述了算法执行所需的时间与输入规模之间的关系。通常用大O符号（O）表示，它衡量了算法运行时间的增长率。时间复杂度可分为以下几种情况：
最好情况时间复杂度：表示在最理想情况下，算法的执行时间。通常用 O(1) 表示，表示不管输入规模如何，算法的执行时间都是常数级的。平均情况时间复杂度：表示在所有可能输入情况下，算法的执行时间的平均值。通常用 O(f(n)) 表示，其中 f(n) 是输入规模 n 的某个函数。最坏情况时间复杂度：表示在最不利情况下，算法的执行时间。通常用 O(g(n)) 表示，其中 g(n) 是输入规模 n 的某个函数。 空间复杂度：空间复杂度描述了算法执行期间所需的内存空间与输入规模之间的关系。也通常用大O符号（O）表示。空间复杂度可分为以下几种情况：
额外空间复杂度：表示除了输入数据占用的空间外，算法执行期间所需的额外内存空间。通常用 O(s(n)) 表示，其中 s(n) 是输入规模 n 的某个函数。总空间复杂度：表示算法执行期间占用的总内存空间，包括输入数据和额外内存。通常也用 O(s(n)) 表示。 算法复杂度的分析有助于比较不同算法的性能、选择最适合特定任务的算法，以及预测算法在大规模数据上的运行情况。在设计和优化算法时，程序员通常会尽力降低时间和空间复杂度，以提高算法的效率。
1.2 时间和空间复杂度的权衡 在算法设计中，时间复杂度和空间复杂度之间存在一种常见的权衡关系。通常，提高时间复杂度可能会降低空间复杂度，反之亦然。这种权衡关系源于计算资源的有限性，以及不同应用场景对时间和空间的不同需求。以下是关于时间和空间复杂度的权衡的一些重要观点：
时间-空间互换：在某些情况下，可以通过使用更多的内存空间来提高算法的执行速度，从而改善时间复杂度。这称为时间-空间互换。典型示例是缓存机制，其中数据存储在内存中，以减少对慢速存储介质（如硬盘）的访问次数。内存管理：在内存受限的环境中，可能需要使用空间较小但时间复杂度较高的算法，以节省内存。这种情况下，算法设计者需要权衡内存占用和执行速度。数据结构选择：选择不同的数据结构可以在时间和空间复杂度之间进行权衡。例如，使用哈希表可以提高查找速度，但占用更多内存，而使用树结构可能需要更多的时间，但内存占用较小。缓存优化：缓存优化是一种重要的权衡策略，通过充分利用计算机的缓存机制来提高算法性能。这包括数据局部性原理，以便有效使用CPU缓存，减少内存访问时间。压缩算法：在某些情况下，可以使用数据压缩算法来减小数据的存储空间。虽然压缩和解压缩过程可能会增加计算时间，但可以显著减小数据占用的空间。异步和并行计算：在多核和分布式系统中，可以通过并行计算来提高算法性能，但这通常需要更多的内存来存储并管理并行任务和数据。 1.3 最坏情况和平均情况分析 在算法分析中，最坏情况和平均情况分析是两种常用的方法，用于评估算法的性能。它们提供了不同的视角，以确保算法在各种情况下都具有合适的性能。
最坏情况分析： 定义：最坏情况分析关注的是算法在所有可能输入情况中的最差性能表现。它测量的是算法在任何给定输入下所需的最大资源消耗，通常是时间或空间。用途：最坏情况分析有助于确定算法的上界性能，即算法在任何输入情况下都不会更差。这对于在实际应用中能够保证性能的算法至关重要，因为用户总是期望最坏情况的性能。例子：在排序算法中，最坏情况可能是对已经排好序的输入进行排序，这会导致一些算法的性能大幅下降。最坏情况分析有助于确定这种情况下的性能下限。 平均情况分析： 定义：平均情况分析关注的是算法在所有可能输入情况的平均性能。它考虑不同输入的出现概率和资源消耗，从而提供了一种更全面的性能评估。用途：平均情况分析更贴近实际情况，因为它考虑了各种输入情况的可能性。这对于更好地理解算法在实际使用中的性能表现很有帮助。例子：在查找算法中，平均情况可能是查找的目标值等可能地分布在输入中。通过平均情况分析，可以估计算法在不同输入情况下的性能期望值。 选择最坏情况分析还是平均情况分析取决于特定问题的性质和需求。通常，最坏情况分析更关注保证性能下界，而平均情况分析更关注实际应用中的性能预期。在某些情况下，两者可以结合使用，以提供更全面的性能分析。无论如何，这两种方法都是算法设计和分析中的重要工具，有助于确定算法的可行性和性能。
二、通用优化技巧 2.1 数据结构选择 在算法和程序设计中，选择合适的数据结构对于优化算法性能至关重要。以下是一些通用优化技巧，涉及数据结构的选择：
理解问题需求：首先，深入理解问题的需求和性质。考虑数据的类型、访问模式、操作类型等因素。不同的问题可能需要不同的数据结构来实现最佳性能。选择合适的数据结构：基于问题需求，选择最适合的数据结构。例如，如果需要高效查找，使用散列表；如果需要有序数据，使用树结构；如果需要快速插入和删除，使用链表。权衡时间和空间：不同数据结构在时间和空间复杂度上存在权衡。有时，选择更高效的数据结构可能导致更高的内存消耗，反之亦然。权衡这两者，根据问题的重要性做出决策。灵活运用复合数据结构：在某些情况下，使用复合数据结构（如树上的散列表）可以结合不同数据结构的优点，以满足多重需求。优化存储：优化数据结构存储以减少内存占用。例如，使用位图或紧凑数组来存储布尔值，以减小内存开销。避免不必要的拷贝：减少数据拷贝和移动操作，以降低开销。使用引用或指针，而不是复制大型数据块。数据结构的操作：考虑在数据结构上执行的操作。选择数据结构时，优先考虑经常执行的操作，以提高算法的整体性能。缓存友好性：利用缓存来加速访问，考虑数据结构内存布局和访问模式，以提高缓存命中率。平衡数据结构：在需要保持数据有序的情况下，选择平衡数据结构（如平衡二叉树），以确保各种操作的时间复杂度均衡。动态调整：某些情况下，数据结构可能需要动态调整大小，以适应不断变化的数据量。在这种情况下，选择支持动态调整的数据结构。使用标准库：避免自行实现复杂数据结构，使用编程语言提供的标准库，因为它们通常经过优化，而且更容易维护和测试。进行测试和性能分析：选择数据结构后，进行详尽的测试和性能分析，以确保它在实际应用中达到预期的性能。 数据结构的选择直接影响算法的效率和性能，因此在算法设计和程序优化中，优秀的数据结构选择是至关重要的。根据问题需求和数据特性，选择最合适的数据结构可以显著提高算法的效率。
2.2 算法设计模式 算法设计模式是一些常见的、通用的算法解决方案，它们在各种问题领域都有用途。以下是一些通用的算法设计模式，可用于优化算法的设计：
分治法： 描述：将问题分解为小问题，解决小问题，然后将结果合并以获得原始问题的解。应用：归并排序、快速排序、分布式计算等。 贪心算法： 描述：通过每一步的最佳选择，逐步构建问题的解。应用：最小生成树、Dijkstra最短路径、任务调度等。 动态规划： 描述：将问题分解为子问题，并存储子问题的解以避免重复计算。应用：背包问题、最长公共子序列、Floyd-Warshall最短路径等。 回溯算法： 描述：通过尝试所有可能的解决方案，并回退（回溯）当无法找到解决方案时。应用：八皇后问题、组合优化、图的着色等。 分支限界法： 描述：类似于回溯算法，但使用启发式方法限制搜索空间，提前剪枝。应用：旅行商问题、0-1背包问题、NP难问题等。 分布式算法： 描述：用于解决分布式系统中的问题，通常涉及到并行计算和通信。应用：分布式数据库查询、MapReduce任务、网络路由等。 概率算法： 描述：使用随机性和概率来解决问题，通常以概率分布估计问题的答案。应用：Monte Carlo模拟、Las Vegas算法、Bloom过滤器等。 分布式算法： 描述：用于解决分布式系统中的问题，通常涉及到并行计算和通信。应用：分布式数据库查询、MapReduce任务、网络路由等。 线性规划： 描述：用于解决优化问题，将问题建模为线性方程组，并找到最大化或最小化目标函数的解。应用：资源分配、运输问题、最优化问题等。 近似算法： 描述：解决NP难问题的启发式方法，提供次优解或接近最优解的解决方案。应用：旅行商问题的近似算法、最小生成树问题的近似算法等。 这些算法设计模式为不同类型的问题提供了通用的解决方法，有助于提高算法的效率和性能。在解决问题时，根据问题的性质选择适当的算法设计模式，可以节省时间和资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8925ee4db903a239f9138805eeb8752/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/353bf1f751acf86029268c064ed28707/" rel="bookmark">
			vue.js 三种方式安装(vue-cli)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue.js（读音 /vjuː/, 类似于 view）是一个构建数据驱动的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。它不仅易于上手，还便于与第三方库或既有项目整合。
下面介绍三种 Vue.js 的安装方法：
1.独立版本
我们可以在Vue.js的官网上直接下载vue.js,并在.html中通过&lt;script&gt;标签中引用。-&gt; &lt;script src = ../vue.js&gt; &lt;/script&gt; 开发环境不要使用最小压缩版，不然会没有错误提示和警告！（页面中直接使用）
使用vue多页面开发：
引入vue.js创建一个vue根实例 new Vue({选项}) 2.使用CDN方法
BootCDN（国内） : https://cdn.bootcss.com/vue/2.2.2/vue.min.js ， （国内不稳定） unpkg：https://unpkg.com/vue/dist/vue.js, 会保持和 npm 发布的最新的版本一致。（推荐使用）cdnjs : https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js，如（&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js"&gt;&lt;/script&gt;） 3.NPM方法（推荐使用）
在用Vue.js构建大型应用的时候推荐使用NPM安装方法，NPM能很好的和诸如Webpack或者Browserify 模块打包器配合使用。Vue.js 也提供配套工具来开发单文件组件。
首先，先列出我们接下来需要的东西：
node.js环境（npm包管理器）vue-cli 脚手架构建工具cnpm npm的淘宝镜像 1） 安装node.js
node安装步骤 从node.js官网下载并安装node，安装过程很简单，一直点下一步就ok了，安装完之后，我们通过打开命令行工具（win+R）,输入node -v 命令，查看node的版本，若出现相应的版本号，则说明你安装成功了。
npm包管理器，是集成在node中的，所以安装了node也就有了npm,直接输入 npm -v 命令，显示npm的版本信息。
npm安装机制
到目前为止，node的环境已经安装完成，npm 包管理器也有了，由于有些npm资源被屏蔽或者是国外资源的原因，经常会导致npm安装依赖包的时候失败，所以我们还需要npm的国内镜像----cnpm.
2） 安装cnpm
在命令行中输入 npm install -g cnpm --registry=http://registry.npm.taobao.org ，然后等待，没报错表示安装成功，（我的已经安装过了，显示更新成功的信息），如下图：
完成之后，我们就可以用cnpm代替npm来安装依赖包了。如果想进一步了解cnpm的，查看淘宝npm镜像官网。
3）安装vue-cli2 脚手架构建工具（必须在全局中进行安装）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/353bf1f751acf86029268c064ed28707/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/332c0ceea372e07c7c98765cce528b1b/" rel="bookmark">
			基于单片机的全自动洗衣机模拟系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体实现功能 具体实现功能：
模拟全自动洗衣机工作过程，以电机替代洗衣机电机。
可以显示洗衣机工作的状态（进水、浸泡、洗衣、脱水、结束）。显示工作剩余时间（洗衣程序可自定义，时间精度：秒）。
洗衣时交替正、反转。洗衣和脱水时电机转速不同。故障报警时声音提示。
单片机介绍 51单片是一种低功耗、高性能CMOS8位微控制器，具有 8K 在系统可编程Flash 存储器。在单芯片上，拥有灵巧的8 位CPU 和在系统可编程Flash，使得STC89C51为众多嵌入式控制应用系统提供高灵活、超有效的解决方案。具有以下标准功能：8k字节Flash，512字节RAM，32 位I/O 口线，看门狗定时器，内置4KB EEPROM，MAX810复位电路，三个16 位 定时器/计数器，一个6向量2级中断结构，全双工串行口。另外 STC89X51 可降至0Hz 静态逻辑操作，支持2种软件可选择节电模式。空闲模式下，CPU 停止工作，允许RAM、定时器/计数器、串口、中断继续工作。掉电保护方式下，RAM内容被保存，振荡器被冻结，单片机一切工作停止，直到下一个中断或硬件复位为止。最高运作频率35Mhz，6T/12T可选。
设计思路 文献研究法：搜集整理相关单片机智能手环系统相关研究资料，认真阅读文献，为研究做准备；
调查研究法：通过调查、分析、具体试用等方法，发现单片机智能手环系统的现状、存在问题和解决办法；
比较分析法：比较不同单片机智能手环系统的具体原理，以及同一类传感器性能的区别，分析单片机智能手环系统的研究现状与发展前景；
软硬件设计法：通过软硬件设计实现具体硬件实物，最后测试各项功能是否满足要求。
程序 本设计利用KEIL5软件实现程序设计，具体如图。作为本科期间学习的第一门编程语言，C语言是我们最熟悉的编程语言之一。当然，由于其功能强大，C语言是当前世界上使用最广泛、最受欢迎的编程语言。在单片机设计中，C语言已经逐步完全取代汇编语言，因为相比于汇编语言，C语言编译与运行、调试十分方便，且可移植性高，可读性好，便于烧录与写入硬件系统，因此C语言被广泛应用在单片机设计中。keil软件由于其兼容单片机的设计，能够实现快速调试，并生成烧录文件，被广泛应用于C语言的编写和单片机的设计。
仿真实现 本设计利用protues8.7软件实现仿真设计，具体如图。
Protues也是在单片机仿真设计中常用的设计软件之一，通过设计出硬件电路图，及写入驱动程序，就能在不实现硬件的情况进行电路调试。另外，protues还能实现PCB的设计，在仿真中也可以与KEIL实现联调，便于程序的调试，且支持多种平台，使用简单便捷。
全部资料 全部资料包括程序（注释）、protues仿真、仿真视频、开发资料、单片机最小系统介绍等，全网最全！
原文链接：基于单片机的全自动洗衣机模拟系统
关注下方公众号，回复“仿真”获取设计资料。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d96263cd47f400c0107caa669c448c55/" rel="bookmark">
			java使用bouncycastle加解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jdk默认带了一些常见的加解密方式，当我们常见的加解密不能满足时，就需要用到一些第三方的库了，bouncycastle就是其中一种。
但是bouncycastle文档比较少。简单介绍一下写法
1.导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt; &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt; &lt;version&gt;1.69&lt;/version&gt; &lt;/dependency&gt; 2.写代码 常见的有两种方式，一种使用BouncyCastleProvider，另一种使用BlockCipherEngine
BouncyCastleProvider使用方式跟原生jdk类似，多数getInstance的地方指定一下provider就行
BouncyCastleProvider方式DES加解密代码如下
package com.vvvtimes.demo.util.endecrypt; import lombok.extern.slf4j.Slf4j; import org.bouncycastle.jce.provider.BouncyCastleProvider; import javax.crypto.Cipher; import javax.crypto.KeyGenerator; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.DESKeySpec; import javax.crypto.spec.IvParameterSpec; import java.security.Key; import java.security.NoSuchAlgorithmException; @Slf4j public class BcDesUtil { private static final BouncyCastleProvider provider; //BouncyCastle与JDK加解密类区别 //KeyFactory.getInstance("RSA"); +provider--&gt;KeyFactory.getInstance("RSA", provider) //Cipher.getInstance("RSA"); +provider--&gt;Cipher.getInstance("RSA", provider) //Signature.getInstance("SHA1withRSA"); +provider--&gt;Signature.getInstance("SHA1withRSA", provider); //KeyGenerator.getInstance("DES") ; +provider--&gt;KeyGenerator.getInstance("DES", provider); 或者KeyGenerator.getInstance("DES","BC") /** * 偏移变量，固定占8位字节 */ private final static String IV_PARAMETER = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d96263cd47f400c0107caa669c448c55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff97677af12ef9d7ba8c6b0a549b0438/" rel="bookmark">
			Windows操作系统TIME_WAIT状态的TCP连接快速回收时间（性能测试时端口不够用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大规模Windows环境下，采用Nginx反向代理服务后，操作系统会产生较多TIME_WAIT的TCP（Transmission Control Protocol）连接，操作系统默认TIME_WAIT的TCP连接回收时间是4分钟，TCP默认动态端口范围为开始端口49152，结束端口65535。这样会使回收TCP过慢导致系统吞吐量下降，甚至出现502访问失败问题。如何修改操作系统内核参数来缩短TIME_WAIT状态TCP连接回收时间和添加TCP动态端口范围，保证在大并发场景下操作系统的端口资源可用？
回答 以Administrator用户登录Windows操作系统。修改TCP回收时间。 在Windows开始菜单中，单击“运行”。在“运行”对话框中，输入“regedit”后按“Enter”打开注册表编辑器。在“注册表编辑器”中打开“HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters”路径。在“编辑”菜单中，选择“新建 &gt; DWORD （32-位）值”，输入名称“TcpTimedWaitDelay”。右键单击TcpTimedWaitDelay，选择“修改”。在“编辑 DWORD（32位）值”对话框的“基数”区域中，选择十进制值为“30”，并“确定”。关闭注册表编辑器。修改端口范围。 在Windows开始菜单中，单击“运行”。输入“cmd”并按“Enter”打开命令执行窗口。执行如下命令修改端口范围。 netsh int ipv4 set dynamicportrange tcp startport=5000 numberofports=60000
重启操作系统。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc6f2d5284331c956fb304b3535a4110/" rel="bookmark">
			c语言打印菱形图案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是使用C语言打印菱形图案的示例代码：
#include &lt;stdio.h&gt; int main() { int i, j, rows, spaces; printf("请输入行数："); scanf("%d", &amp;rows); spaces = rows - 1; for (i = 1; i &lt;= rows; i++) { for (j = 1; j &lt;= spaces; j++) { printf(" "); } spaces--; for (j = 1; j &lt;= 2 * i - 1; j++) { printf("*"); } printf("\n"); } spaces = 1; for (i = 1; i &lt;= rows - 1; i++) { for (j = 1; j &lt;= spaces; j++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc6f2d5284331c956fb304b3535a4110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d841ee9da826a3f6f30726e5dbbd9b05/" rel="bookmark">
			哨兵（Sentinel-1、2）数据下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哨兵（Sentinel-1、2）数据下载 目前哨兵数据已转移到新网站，具体查看博文
一、登陆欧空局网站 二、检索 先下载2号为光学数据
分为S2A和S2B，产品种类有1C和2A，区别就是2A是做好大气校正的影像，当然数量也会少一些，云量检索条件中记得要按格式，加个[]
然后先点击问号，开始检索
如何获得自己想要的研究区范围呢？
然后画方框选择自己的研究区范围，可以框大一点，然后点击问号
然后将需要的影像加入购物车
进入购物车
下载影像 在购物车中，点击右下角的下载
提交后会出现这个消息框，此时等待数据受理就行，一般快的话1-2小时，慢的话几天。
打开影像 第二天早上看的时候，已经都开放下载了
解压缩之后，打开GRANULE-IMGDATA-
一共有13个波段
参考文章 欧空局（esa）下载哨兵-Sentinel影像-（史上最全讲解，老少皆宜）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d358e8cfe86f4e171e0e51ebd7f61073/" rel="bookmark">
			【MySQL基本功系列】第一篇 先熟悉MySQL的运行逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
我将推出一系列关于MySQL的博客文章，涵盖了从入门到深入底层的原理。这些文章将包括MySQL的运行逻辑、InnoDB存储引擎、SQL优化、undo log、bin log等多个方面的知识。希望这些文章能为你提供宝贵的信息和洞见，并帮助你更好地理解和应用MySQL。同时，非常欢迎各位读者提供反馈和建议，让我们一起共同进步。
在我们深入研究MySQL的底层原理之前，建议先对MySQL的运行逻辑和各核心组件之间的关系有一定的了解。在这篇博文中，我将为你简要介绍MySQL的运行逻辑和相关核心组件，这将有助于更好地理解MySQL的工作方式。
MySQL是一款强大的开源关系型数据库管理系统，采用了客户端-服务器架构，为应用程序提供了数据存储和检索等关键功能。通过理解MySQL的基本运行机制，我们可以更轻松地探索其更深层的技术细节。
MySQL的运行逻辑 让我们首先熟悉一下用户请求从发送到MySQL最终将数据写入磁盘的整个过程。这个过程涉及多个关键步骤，我将跟随以下流程图，逐一解释每一步骤。
简单描述一下流程图中每个部件的作用：
用户请求： 用户请求访问SQL查询、插入、更新或删除等操作。
连接池： 当我们需要与数据库交互时，首要任务是通过MySQL驱动与数据库建立网络连接。只有在成功建立连接之后，我们的应用程序才能执行增删改查等SQL操作。
然而，一个系统绝不仅仅只跟数据库创建一个连接，因为我们多线程处理的时候，如果仅有一个连接的话，各线程都要去抢夺一个连接去访问数据库，这样的多线程是没有意义的。
Tomcat中的多线程应用程序在每次需要访问数据库时，如果都是通过创建一个数据库连接、执行SQL语句，然后销毁连接，下一次再重新建立数据库连接，那肯定是效率很低下的。
所以，这个时候就可以引入了数据库连接池的概念，连接池在内部维护了一定数量的数据库连接，当线程需要连接数据库时，它可以直接从连接池中获取一个可用的连接，而不是每次都重新创建一个。使用完连接后，线程不需要销毁它，只需将连接返回到连接池中，以供其他线程继续使用。这种方式避免了频繁的连接创建和销毁过程，大大提高了效率。
常用的连接池有DBCP，C3P0，Druid等。
MySQL线程池： MySQL服务器中维护了一个线程池，当一个客户端应用程序尝试连接到MySQL服务器时，MySQL服务器会接受这个连接请求。它会为每个连接分配一个线程来处理客户端的请求。这些线程在执行期间会处理SQL查询、更新、事务等操作。
SQL接口： MySQL内部首先提供了一个组件，就是SQL接口（SQL Interface），他是一套执行SQL语句的接口，当MySQL的线程从网络连接中读取出来一个SQL语句之后，就会转交给SQL接口去执行。
SQL解析器： MySQL的SQL解析器就是按照既定的SQL语法，对这个SQL按照SQL语法规则编写的SQL语句进行解析，然后理解这个SQL语句要干什么事情。如果SQL存在语法错误，解析器将生成错误消息。
查询优化器： 一旦确定了执行计划，查询优化器会评估不同的执行计划，选择最有效的执行方式。这可能涉及到索引的选择、连接操作的排序和过滤条件的应用，以最大程度地提高查询性能。
执行器： 查询优化器确定了执行计划后，将执行计划传递给执行器。执行器负责执行查询，检索或修改数据，并将结果返回给应用程序线程。
存储引擎： MySQL支持多种存储引擎，如InnoDB、MyISAM等(目前一般都用InnoDB，我们后续的博文，也仅对InnoDB进行讲解)。存储引擎负责实际的数据存储和检索。它们处理数据的读写操作，可以将数据存储在内存或磁盘上，具体取决于存储引擎的类型和配置。
数据的写入： 存储引擎可以将数据写入内存缓冲区，然后定期将数据刷新到磁盘。这确保了数据的持久性，即使发生系统崩溃，数据也不会丢失。
END 以上就是MySQL运行逻辑以及步骤，接下来，我将针对InnoDB存储引擎做一系列的更深入的介绍。
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1795a6d982179a0123d024a3b433ed7/" rel="bookmark">
			【mmcv报错】ModuleNotFoundError: No module named ‘mmcv.runner
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跑一个代码需要用到mmcv和mmseg
其中有两行代码：
from mmcv.runner import load_checkpoint from mmseg.utils import get_root_logger 我先是按照官方推荐的安装方法去安装了mmcv和mmseg
pip install -U openmim mim install mmcv 它会自动帮你安装mmengine
我的cuda是11.6 torch是2.0.1
他帮我安装的mmcv是2.1.0，mmengine是0.9.1
然后pip install mmsegmentation
安装的mmseg版本是1.2.1
安装完了之后出现问题：
mmcv.runner标红报错，说mmcv下面没有runner
ModuleNotFoundError: No module named 'mmcv.runner
我在网上搜索，有博客说不能安装mmcv，要安装mmcv-full
然后我把mmcv卸载，去安装mmcv-full（被坑惨了）
先是遇到一个问题，安装mmcv-full卡住
一直卡在buliding wheels for mmcv
我去网上一搜，很多遇到这个问题的
解决方法都是说，跟cuda版本不符，要安装对应的版本。
我试验了多个版本，都不行，安装不了
最后甚至在这个网站下载了离线的whl包。https://download.openmmlab.com/mmcv/dist/cu102/torch1.10.0/index.html
最终安装成功，但是带来的问题更多，
找不到libcudaert.so.10.2
No module named ‘mmcv._ext‘
整整折腾了一个多小时，反正各种问题，大概都是在说，版本跟cuda、torch不匹配
（其实人家自动给你安装的mmcv就是符合你机器版本的，但是自动安装mmcv-full不了，手动安装的又不匹配，，，，）
最后换了思路去解决：
这两行代码的问题：
from mmcv.runner import load_checkpoint from mmseg.utils import get_root_logger 首先：找不到mmcv.runner
我去看了源码，发现是版本升级的问题，我用的高版本的mmcv，结构已经变了
runner在mmengine下面，所以修改如下
from mmengine.runner import load_checkpoint
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1795a6d982179a0123d024a3b433ed7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f83c180dd5eec3e0f2011382ba76c11/" rel="bookmark">
			CSDN付费专栏，写文章变现的机会来了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是最好的时代，这也是知识变现的时代。
在CSDN上面，有许许多多辛勤耕耘，热爱分享的博主，他们通过代码、文字传递开发知识，分享学习经验，帮助一代又一代的程序员走向更好地未来。
当然，不少博主也会面临种种疑惑，我写了这么多内容，到底能给我带来了些什么呢？
在CSDN每一位热爱分享的博主，一直以来记录自己的成长过程，将每一项知识内容/项目案例以输出的方式记录下来，不经意间在CSDN的平台坚持了很多年，在这里除了以这种输出方式的记录收获更牢靠的知识外，还收获了一批像您学习的忠实粉丝，以及通过付费专栏的形式实现收益。
关于博客的付费专栏，自2019年上线，该项目受到众多博主的参与，经过老师与平台共同的经营下，对该项目从内容及创作者进行更专业化的规范，以下是关于付费专栏项目要求的简要说明：
面向对象
所有博主：开通付费专栏前需完成实名认证（以便给作者分润）。
开通专栏方式
专栏开通方式两种：
现有专栏设置为付费专栏新建付费专栏 开通专栏步骤
新建收费专栏：点击管理博客- 分类专栏 ，如下图显示
现有专栏设置为付费专栏：点击管理博客-分类专栏-选择自己需要设置的专栏，点击设置为付费专栏，如下图显示：
开通专栏事项须知付费专栏开通提交前，请认真阅读《CSDN付费专栏写作协议》，知晓双方的权利与义务；付费专栏所包含的文章需为原创文章；付费专栏内容总量不少于5篇，当专栏内容≤5篇时，专栏为免费专栏形式展现给用户；付费专栏一旦设置为收费并且产生订单后：不能取消，不能删除文章等对专栏进行修改的操作；不能故意引流，在付费专栏产生收益后在他平台引导二次收费；专栏申请需提交审核，审核时间1-2个工作日；专栏定价，官方暂定9.9元，后续会根据销量动态调整；确保专栏内容无违规、违法、广告等不当内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd0ed31f25a2b914179ca8cbf059365a/" rel="bookmark">
			HDFS编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验2：HDFS编程 实验步骤1 【实验介绍】 实验内容
本实验利用 Hadoop 提供的 Java API 进行编程对 HDFS 进行操作。
实验目标
通过本实验掌握利用 Hadoop 提供的 Java API 进行编程对 HDFS 进行操作。
实验知识点
Hadoop Java API
HDFS 目录操作
实验环境
Hadoop 2.7.1
IDEA 11.0.10
CourseGrading在线实验环境
工作目录：~/Desktop/workspace/hdfs_pro
预备知识
Hadoop 基本操作
MapReduce 编程基础
HDFS 基本操作
Java 编程基础
实验步骤2 【实验原理】HDFS文件系统编程框架 以下代码为HDFS文件系统的编程框架：
01 import org.apache.hadoop.conf.Configuration; 02 import org.apache.hadoop.fs.FileSystem; 04 public class FileExist { 05 public static void main(String[] args) { 06 try { 07 Configuration conf = new Configuration(); 08 FileSystem fs = FileSystem.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd0ed31f25a2b914179ca8cbf059365a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1acb210b7c8ebaf4920a324292df4894/" rel="bookmark">
			VMware安装Ubuntu22.04教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装教程： （一）Ubuntu镜像文件下载（选择Ubuntu桌面版） 1、Ubuntu官方网站
（1）Ubuntu官网：https://ubuntu.com
（2）Ubuntu官网中文站：https://cn.ubuntu.com
（3）Ubuntu22.04桌面端官方下载：https://cn.ubuntu.com/download/desktop
2、镜像包快捷下载
（1）镜像包官方快捷下载
链接：https://ubuntu.com/download/desktop/thank-you?version=22.04.3&amp;architecture=amd64
（2）百度网盘下载：
链接：https://pan.baidu.com/s/1i8UPTG6e_o-_AWnyd57qmg?pwd=0327 提取码：0327
（二）Ubuntu22.04安装之虚拟机配置 1、创建虚拟机（虚拟机版本：VMware® Workstation 16 Pro）
2、选择自定义（高级），当然也可以选择典型，然后点击“下一步”。 3、选择硬件的兼容性，这里看个人需要，一般默认就好，然后点击“下一步”。
4、选择安装驱动光盘映像文件（iso），通过浏览找到刚刚官网下载的镜像文件，然后点击“下一步”。
5、填写全名、用户名和密码（这里不重要，因为下面进入虚拟机之后也要重新配置），点击“下一步”。
6、填写虚拟机名称，更改安装位置（建议不要安装在C盘，可以安装其他空间充裕的盘），点击“下一步”。
7、根据个人需要，进行处理器配置，点击“下一步”。
8、配置虚拟机内存，这里以4G为例，点击“下一步”。
9、配置网络类型，这里按照默认配置（使用网络地址转换），点击“下一步”。
10、按照默认控制器类型配置，点击“下一步”。
11、按照默认磁盘类型配置，点击“下一步”。
12、创建新虚拟磁盘，点击“下一步”。
13、指定磁盘容量，这里我选择40G，然后根据个人需求，决定虚拟硬盘是否拆分，点击“下一步”。
14、点击“下一步”。
15、点击“完成”，会自动打开虚拟机（如果没打开请自行打开）。
（三）Ubuntu22.04安装之安装配置 1、选择“Chinese”，点击“continue”。
2、取消勾选“Download updates while installing Ubuntu”，点击“continue”。
3、勾选“Erase disk and install Ubuntu”（注意：如果是装双系统，选择这个会清空磁盘，请谨慎操作），点击“install Now”。
4、弹出的“Write the changes to disks”窗口，点击“Continue”。
5、选择地区，点击“Continue”。
6、根据个人需要，填写全名、用户名和密码（一定要记得密码，这个是登陆用的），点击“Continue”。
7、等待安装完成。
8、安装完成，点击“Restart Now”重启，就能正常使用了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbaf80faa2a066950296dfa8d69b66cc/" rel="bookmark">
			前端基于uniapp[uniPush]实现APP消息推送（安卓、IOS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提概述：此文章都是基于uniapp中uniPush2实现的在线、离线推送
app消息推送流程 登录开发者中心先填写好项目信息以及配置厂商在manifest.json文件中勾选推送模块打包自定义基座在前端项目中创建云函数（此云函数的作用是接受后台发送的消息模板，解析出来后，发送给到uniapp后台，以此触发消息推送功能）在app.vue文件中需要做三件事：
①获取客户端推送标识
②处理离线（推送点击）
③在线（接收消息、推送点击）真机测试 好了，以下会根据上面的五个流程给出的具体笔记。。。
坑点 在具体讲述之前，我觉得可以把坑点先记下来，方便大家避雷：
上传iOS证书提示“证书环境错误”的问题 需要上传的是推送证书，不是打包证书
配置完成后，运行到真机会出现"打包时未添加push模块,请参考…“的情况 在manifest.json勾选了push模块之后，需要重新打包自定义基座
账号共同的问题 你在哪个开发者账号中配置的app,对应的你的HBuilder也要登录那个账号进行开发
小米真机测试，出现收不到消息的情况 需要配置推送时间
华为离线时，收不到消息推送，若厂商信息确认配置无误，那么检测以下两个地方 1、查看开发者中心 - uniPush - 应用信息，点击 [包名再“应用详情“中”各平台信息“管理，点击前往]，然后选择你的应用进行修改，一定要认真核对 Android 应用签名SHA256 是否填写正确
2、华为推送信息乱写的时候，是可能不被推送的，可以按照以下格式发送排查下：
title：订单提醒
body：您的外卖订单已接单，请耐心等候
官方排错文档 如果以上都不能帮助到你，那么再查看这两个文档进行排查：厂商限额和提醒方式说明、uni-push2.0 常见问题，如果都不行的话，只能添加unipush的客服咨询啦
具体处理笔记（从0到1） 1、在开发者中心填写项目信息以及配置厂商（见图） 2、在manifest.json文件中勾选推送模块 上传图片注意事项和格式，看文档
3、更新自定义基座 在 发行-&gt;原生APP-云打包，点击打自定义调试基座。这一步，务必保证你前面的配置都好了，尤其是oppo的。
4、在前端项目中创建云函数 消息推送属于敏感操作，只能直接或间接由服务端触发。传统的三方push服务，需要开发者在服务端配置密钥或证书，根据服务器端文档签名获取token，再向相关URL接口发起网络请求…而unipush仅是需要我们创建一个云函数作为一个中转站
点击项目，右键点击创建uniCloud云开发环境，然后选择阿里云或者腾讯云创建完成后，右键点击uniCloud选择关联空间再右键点击cloudfunctions,选择新建云函数，新建时可选择uni-cloud-push扩展库 具体里面的内容，我们处理的不需要很多，可以具体看文档，文档写的比较详细，一直往下滑，直接看第四步
5、在app.vue处理消息 注意：安卓和IOS在线推送的情况是，是不会弹出提示的，需要我们手动创建
直接贴代码啦，具体看注释
// #ifdef APP-PLUS // 客户端获取push客户端标记 uni.getPushClientId({ success: async (res) =&gt; { let push_clientid = res.cid //这个id是不会改变的，我们需要在登录必经过的页面或者方法拿到这个id传给后端存储起来 uni.setStorageSync('unipush_id', push_clientid) }, fail(err) { console.log('推送id获取失败:', err) }, }) //离线推送-点击信息 plus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbaf80faa2a066950296dfa8d69b66cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1d35dfd99d6680eb7313b9e1e044f6a/" rel="bookmark">
			socket编程中的EINTR是什么?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		socket编程中的EINTR是什么? 在socket编程中，我们时常在accept/read/write等接口调用的异常处理的部分看到对于EINTR的处理，例如下面这样的语句：
repeat: if(read(fd, buff, size) &lt; 0) { if(errno == EINTR) goto repeat; else printf("read failed"); } 那么EINTR是什么呢？为什么要对它进行处理呢？ 本文将对EINTR做一些讨论。
慢系统调用 如果想要解释EINTR，首先得对慢系统调用有个了解。
慢系统调用(slow system call)指不会立即返回的系统调用, 可能永远阻塞而无法返回。 例如支持网络的调用, 包括read/write, connect, accept等, 都属于这一类。
慢系统调用, 主要分为以下类别:
读写"慢"设备。 包括pipe, fifo, 终端设备, 网络连接等. 读时, 数据不存在, 需要等待缓冲区有数据输入; 写时, 缓冲区满, 需要等待缓冲区有空闲位置。注意: 读写磁盘文件一般不会阻塞， 网络磁盘除外。打开某些特殊文件时, 需要等待某些条件才能打开。如打开终端设备, 需要等待连接设备的modern响应, 才能打开pause和wait系统调用。 pause阻塞进程, 直到收到信号唤醒;wait等待任意子进程终止; 某些ioctl操作某些IPC操作。如pipe, fifo, 没有指定NON_BLOCKING选项时的写操作, 如果管道缓冲区满, write阻塞;互斥锁, 条件变量, 信号量, 记录锁等等. 慢系统调用与EINTR 如果进程在一个慢系统调用(slow system call)中阻塞时，当捕获到某个信号且相应信号处理函数返回时，这个系统调用被中断，调用返回错误，设置errno为EINTR（相应的错误描述为"Interrupted system call"）。
因此EINTR错误的产生是慢系统调用和信号处理函数组合使用会产生的问题。
回过头来再看开头所提到的这一段的代码，其含义是当程序通过read读取数据，当目前fd对应的缓冲区没有数据可读时，进程将被阻塞。此时如果向该进程发送了信号，那么read函数将会返回-1，并且此时errno为EINTR，代表read方法被中断了。对于这样的情况，我们就需要人为的对read进行"重启"， 即重新的进行read。
repeat: if(read(fd, buff, size) &lt; 0) { if(errno == EINTR) goto repeat; else printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1d35dfd99d6680eb7313b9e1e044f6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc5d5f35c6b3ae56ada0684263983246/" rel="bookmark">
			PHP 导出 Excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、完美解决 导出乱码问题，&lt;EOT&gt;标签需要顶格写，前面不能任何字符
&lt;?php //表示输出的类型为excel文件类型 header( "Content-Type: application/vnd.ms-excel; name='excel'" ); //弹框下载文件 header("Content-Disposition:attachment;filename=".date('Y-m-d',time())."报表.xls"); echo &lt;&lt;&lt; EOT &lt;html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40"&gt; &lt;head&gt;&lt;meta http-equiv="Content-type" content="text/html;charset=utf-8" /&gt;&lt;/head&gt; &lt;body&gt; &lt;table border="1" width="80%"&gt; &lt;tr&gt; &lt;td align="center"&gt;编号&lt;/td&gt; &lt;td align="center"&gt;用户名&lt;/td&gt; &lt;td align="center"&gt;性别&lt;/td&gt; &lt;td align="center"&gt;年龄&lt;/td&gt; &lt;/tr&gt; EOT; $list = array ( "0" =&gt; array('id'=&gt;1,'username'=&gt;'YQJ','sex'=&gt;'男','age'=&gt;24), "1" =&gt; array('id'=&gt;2,'username'=&gt;'fsd','sex'=&gt;'女','age'=&gt;25), ); foreach($list as $row){ echo &lt;&lt;&lt; EOT &lt;tr&gt; &lt;td align="center"&gt;{$row["id"]}&lt;/td&gt; &lt;td align="center"&gt;{$row["username"]}&lt;/td&gt; &lt;td align="center"&gt;{$row["sex"]}&lt;/td&gt; &lt;td align="center"&gt;{$row["age"]}&lt;/td&gt; &lt;/tr&gt; EOT; } echo &lt;&lt;&lt; EOT &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; EOT; ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc5d5f35c6b3ae56ada0684263983246/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b99749e4a2c21d6f20973d65125384e3/" rel="bookmark">
			C#递归获取文件夹下的全部文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 很多时候我们需要获取一个结构未知的文件夹下所有的文件或是指定类型的所有文件，此时就需要使用递归操作，下面给出实现代码。我在这里新建了一个测试文件夹，其结构如下所示：
测试文件夹/ ├─文件夹1 │ └─1_1.docx │ └─1_2.docx └─文件夹2 │ └─2_1.pptx │ └─2_2.pptx │ └─文件夹3 │ └─3_1.xlsx │ └─3_2.xlsx │ └─文件夹4 │ └─4_1.bmp │ └─4_2.bmp 2、调用系统方法实现递归 微软提供如下四个方法实现递归查询，只需要将SearchOption参数设置为AllDirectories即可：
Directory.GetFile()Directory.EnumerateFiles()Directory.GetFileSystemEntries()Directory.EnumerateFileSystemEntries() 代码如下：
namespace App { internal class Program { static void Main(string[] args) { foreach (var file in GetFiles_1(@"D:\测试文件夹", new string[] { "*.docx", "*.xlsx", "*.pptx", "*.bmp" })) { Console.WriteLine(file); } Console.WriteLine("-----------------------------------"); foreach (var file in GetFiles_2(@"D:\测试文件夹", new string[] { "*.docx", "*.xlsx", "*.pptx", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b99749e4a2c21d6f20973d65125384e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c886c7777c2cb2d8f4c155b04040ab6a/" rel="bookmark">
			解决logstash插件logstash-outputs-mongodb一条数据失败后一直重复尝试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述 从日志中读取数据时，有一条数据不符合规范，导致logstash读取数据插入时出错，而插件又无限尝试插入，导致堵塞。
解决方案 找到logstash文件夹目录，例如是：/data/logstash-7.3.2
cd /data/logstash-7.3.2/vendor/bundle/jruby/2.5.0/gems/logstash-output-mongodb-3.1.6/lib/logstash/outputs/ 因为版本不一定相同，带数字的文件看实际情况进行修改。
vi mongodb.rb 翻到最下面，找到
@logger.warn("Failed to send event to MongoDB, retrying in #{@retry_delay.to_s} seconds", :event =&gt; event, :exception =&gt; e) sleep(@retry_delay) retry 注释掉最后两行
@logger.warn("Failed to send event to MongoDB, retrying in #{@retry_delay.to_s} seconds", :event =&gt; event, :exception =&gt; e) #sleep(@retry_delay) #retry 保存后，重启logstash
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6c580e74640710de077f0e318baa74d/" rel="bookmark">
			建表时如何合理选择字段类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们在建表的时候关于字段类型的选择会有这么几类人：
严谨型
严格调研每个字段可能的大小，然后根据不同字段类型的限制，进行选择，这一类人在创建关系型数据表的时候是没有问题的。图自己省事型
把所有字段都设置为String，这样他可以一股脑的把所有数据导入进来。这种人在用关系型数据库（如mysql）的时候，会被骂死，在大数据（如hive）中，可能ODS层这么搞，原则上是可行，毕竟还有建模的时候可以处理这些数据类型，但是建模的人也会抱怨。根据不同场景进行甄别型
（1）大数据领域
由于大数据字段类型差异带来性能影响远远无法和数据量相提并论，因此不需要那么严谨。
（2）关系型数据库
需要尽可能给用户带来极致的体验，字段类型尽可能要选择合理。 常用的字段类型 数据类型描述TINYINT1-byte signed integer, from -128 to 127SMALLINT2-byte signed integer, from -32,768 to 32,767INT/INTEGER4-byte signed integer, from -2,147,483,648 to 2,147,483,647BIGINT8-byte signed integer, from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807FLOAT4-byte single precision floating point numberDOUBLE8-byte double precision floating point numberDECIMALHive中的DECIMAL类型基于Java的BigDecimal，用于在Java中表示不可变的任意精度十进制数。所有常规的数值操作（例如+、-、*、/）和相关的UDF（例如Floor、Ceil、Round等）都可以处理DECIMAL类型。您可以像处理其他数值类型一样，对DECIMAL类型进行类型转换。DECIMAL类型的持久化格式同时支持科学计数法和非科学计数法。因此，无论您的数据集包含类似4.004E+3（科学计数法）还是4004（非科学计数法）或两者的组合的数据，都可以使用DECIMAL来处理。STRING字符串，变长，字符串文字可以用单引号（'）或双引号（“）表示VARCHARVarchar类型在创建时需要指定长度（在1到65535之间），它定义了字符字符串中允许的最大字符数。如果转换/分配给varchar值的字符串值超过了长度指定值，那么该字符串将被静默截断CHAR字符类型（Char types）与Varchar类似，但它们的长度是固定的，这意味着短于指定长度值的值会用空格填充，但在比较时尾部空格并不重要。最大长度固定在255TIMESTAMP支持具有可选纳秒精度的传统UNIX时间戳DATEDATE值描述特定的年/月/日，格式为YYYY-MM-DD。例如，日期为“2013年01月01日”。日期类型没有一天中的时间组件。Date类型支持的值范围为0000-01-01到9999-12-31，这取决于原始Java Date类型的支持BOOLEANtrue/falseINTERVAL时间频率间隔ARRAY有序的的同类型的集合MAPkey-value,key必须为原始类型，value可以任意类型STRUCT字段集合,类型可以不同UNION在有限取值范围内的一个值 大数据（Hive）字段类型选择 数据仓库Hive中的字段长度尽量满足相应源系统字段中最大长度的要求，当然也会考虑字段的业务含义，对于一些源系统定义过长，而从实际业务含义又不可能有那么长的字段，由仓库自行选择一个合适的长度定义；为了尽可能的保持仓库中数据类型的一致性以及规范性，数据仓库中的数据类型定义不宜过杂，建议只定义string、bigint、double类型，使得仓库中的字段类型保持整齐。
关系型数据库（Mysql）字段类型选择 原则
尽可能选择合适的类型。比如某个字段只有0和1，那么绝对是tinyint优先于int。tinyint和int性能 存储空间
INT字段占用4个字节，而TINYINT字段只占用1个字节。因此，如果你的数据量较大，使用TINYINT可以节省存储空间，减少磁盘IO的开销。内存消耗
INT字段存储时会占用更多的内存空间，如果表中有很多INT字段，并且数据量较大，会增加MySQL服务器的内存消耗。索引效率
使用TINYINT字段来创建索引会比使用INT字段创建索引效率更高。因为在索引建立和查询过程中，TINYINT占用的空间小，可以减少IO操作次数，提高查询效率。运算和比较速度
INT字段相较于TINYINT字段在运算和比较操作上可能稍微慢一些，因为需要处理更多的字节。 如果你的数据范围可以在TINYINT的取值范围内（-128到127或0到255），并且对存储空间和索引效率有较高的要求，使用TINYINT字段会更合适。如果数据范围超出了TINYINT的取值范围，或者对于内存消耗和运算速度要求更高，可以考虑使用INT字段。
int(1)和int(10)有什么区别
INT(1)和INT(10)实际上并没有区别。在MySQL中，当定义整数类型（如INT）时，括号中的数字表示显示宽度，而不是存储大小或值的范围。
显示宽度只影响在查询结果集中显示的值的宽度。例如，如果你使用INT(10)，并在查询结果中有一个值为123，那么它仍然会显示为123，而不是用前导零填充到10位。显示宽度不会限制值的范围或存储大小。
实际上，对于整数类型，如INT，存储大小和值的范围是由类型本身确定的，而不是显示宽度。INT类型总是使用4个字节（32位）的存储空间，并且值的范围始终是从-2147483648到2147483647（有符号）或从0到4294967295（无符号）。
因此，无论使用INT(1)还是INT(10)，它们的存储大小和值的范围都是相同的。选择适当的显示宽度只是为了在查询结果中更好地格式化显示的值。
总结起来，INT(1)和INT(10)在MySQL 8中没有实际的区别，它们只是用于指定查询结果中显示的值的宽度。
为了更加直观的理解： 建一张表：
create table intVsIntAnyThingDemo ( Number1 int(1) unsigned zerofill, Number int(8) unsigned zerofill ); 建表语句详解：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6c580e74640710de077f0e318baa74d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3d482c2ee1c9424c010ee7723554d8a/" rel="bookmark">
			centos docker容器化部署nginx php项目（详细版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、nginx和php的一些原理 1、nginx 是一个 web 服务器，它只能处理静态文件，无法处理 PHP Python 等具体程序语言的请求。所以，原理是这样，用户统一先请求到 nginx，nginx 会再把请求转发给 php-fpm。
2、php-fpm是处理 PHP 请求的一个东西，实现了 FastCGI 协议的一个东西，它叫PHP FastCGI 管理器。
3、 FastCGI 是什么？是一种与 Web 服务器通信的协议，规定了要传什么数据，具体什么格式。
二、前提条件 centos，安装了docker环境，当然你也可以安装宝塔，他俩不冲突，宝塔里可以方便的看到docker的一些东西。
php 镜像有fpm和cli两个版本。php-cli是命令行版本,而php-fpm是作为apache或者nginx等服务器软件处理PHP文件的扩展。这里选择fpm。
三、下载php和nginx镜像 docker pull nginx docker pull php:8.0-fpm 四、创建并运行PHP容器 mkdir -p /docker/www docker run --name php8.0 -p 9000:9000 -v /docker/www:/www -d php:8.0-fpm --name php8.0 给容器取个名字
-p 9000:9000 php容器的端口默认是9000,映射到宿主机的9000端口
-v /docker/www:/www 把宿主机的PHP源代码目录 /docker/www 挂载到容器内的 /www。未来在容器内访问 /www 就相当于访问宿主机的 /docker/www，容器的删除不会影响到源代码。
-d 后台静默运行
php:8.0-fpm 镜像名
如：报错Error response from daemon: driver failed programming external connectivity on endpoint XXX（端口映射或启动容器时报错）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3d482c2ee1c9424c010ee7723554d8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c8356bd7d988ee85c4bd88999726d6/" rel="bookmark">
			AI绘画 | stable-diffusion的模型简介和下载使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们下载完stable-diffusion-ui后还需要下载需要的大模型，才能进行AI绘画的操作。秋叶的stable-diffusion-ui整合包内，包含了anything-v5-PrtRE.safetensors和Stable Diffusion-V1.5-final-prune_v1.0.ckpt两个模型。
anything-v5-PrtRE.safetensors模型可以用于生成多种类型的图像，包括肖像、风景、动物、卡通、科幻等，它具有较强的适应性和泛用性，效果表现出较强的真实感和细节还原能力。
Stable Diffusion-V1.5-final-prune_v1.0.ckpt模型是Stable Diffusion的一个版本，也具有生成多种图像的能力，同时它还具有较快的生成速度和较高的图像质量。这个模型在细节表现和风格化方面表现得更好，适合于需要快速生成高质量图像的应用场景。
因此，选择哪个模型取决于具体的应用场景和需求。如果需要生成多种类型的图像并且要求细节表现和泛用性较好，可以选择anything-v5-PrtRE.safetensors模型；如果需要快速生成高质量的图像，可以选择Stable Diffusion-V1.5-final-prune_v1.0.ckpt模型。
模型概念 先来看看模型在 Stable Diffusion 中到底是什么概念？在维基百科中对模型的定义非常简单：用一个较为简单的东西来代表另一个东西。换句话说，模型代表的是对某一种事物的抽象表达。
在 AIGC 领域，研发人员为了让机器表现出智能，使用机器学习的方式让计算机从数据中汲取知识，并按照人类所期望的方向执行各种任务。对于 AI 绘画而言，我们通过对算法程序进行训练，让机器来学习各类图片的信息特征，而在训练后沉淀下来的文件包，我们就将它称之为模型。用一句话来总结，模型就是经过训练学习后得到的程序文件。
常见的 AI绘画 用模型后缀名有如下几种：
.ckpt格式 ，.pt 格式，.pth格式，.safetensors格式
.ckpt格式 ，.pt 格式，.pth格式，这三种是 pytorch[2] 的标准模型保存格式，由于使用了 Pickle，会有一定的安全风险（自行百度：pickle反序列化攻击）。
.safetensors格式为一种新型的模型格式，正如同它的名字一样safe（安全）。为了解决前面的这几种模型的安全风险而出现的。.safetensors 格式与 pytorch 的模型可以通过工具进行任意转换，只是保存数据的方式不同，内容数据没有任何区别。
官方模型 如今市面上有如此多丰富的绘图模型，为什么 Stable Diffusion 官方模型还会被大家津津乐道？当然除了它本身能力强大外，更重要的是从零训练出这样一款完整架构模型的成本非常高。根据官方统计，Stable Diffusion v1-5 版本模型的训练使用了 256 个 40G 的 A100 GPU（专用于深度学习的显卡，对标 3090 以上算力），合计耗时 15 万个 GPU 小时（约 17 年），总成本达到了 60 万美元。
除此之外，为了验证模型的出图效果，伴随着上万名测试人员每天 170 万张的出图测试，没有海量的资源投入就不可能得到如今的 Stable Diffusion。这样一款模型能被免费开源，不得不说极大地推进了 AI 绘画技术的发展。
按理说这么大成本训练出来的模型，绘图效果应该非常强大吧？但实际体验过的朋友都知道，对比开源社区里百花齐放的绘图模型，官方模型的出图效果绝对算不上出众，甚至可以说有点拉垮，这是为什么呢？
前两个是Stable Diffusion官方的基础模型，后一个是别人用官方基础模型为底模训练的特定画风的模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04c8356bd7d988ee85c4bd88999726d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c59ee127731ca163e856831447e52a4c/" rel="bookmark">
			K8S安装mongo:4.0.28单实例版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择这个版本、单实例是项目需求，我根据docker-compose改编而来。
apiVersion: v1 kind: Service metadata: name: mongo-service spec: selector: app: mongo ports: - protocol: TCP name: defaltport #集群内部:Service IP +Port就可以访问到服务 port: 27017 #Pod内的应用暴露的服务端口 targetPort: 27017 #集群外部:宿主机IP+nodePort就可以访问到服务 nodePort: 32322 type: NodePort --- apiVersion: apps/v1 kind: StatefulSet metadata: name: mongo-statefulset spec: serviceName: mongo-service replicas: 1 selector: matchLabels: app: mongo template: metadata: labels: app: mongo spec: containers: - name: mongo-container imagePullPolicy: Always image: mongo:4.0.28 # securityContext: # runAsUser: 1000 # 指定用户 ID # runAsGroup: 1000 # 指定用户组 ID env: - name: MONGO_INITDB_ROOT_USERNAME value: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c59ee127731ca163e856831447e52a4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ccab60bc1a545174fca378b5073d00c/" rel="bookmark">
			Android14弹窗问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		弹窗问题 升级安卓14后，应用没有适配对应的CPU架构而被系统强制弹窗，弹窗流程可见参考应用弹窗“此应用专为旧版Android打造，因此可能无法正常运行…”的原因，应用层面没办法去干扰这个流程，应该是在安装时有检测相关的包。
弹窗共有两个：此应用与最新版 Android 不兼容。请检查是否有更新，或与应用开发者联系。deprecated_abi_message此应用专为旧版 Android 系统打造。它可能无法正常运行，也不包含最新的安全和隐私保护功能。请检查是否有更新，或与应用开发者联系。deprecated_target_sdk_message 从安卓源码中可以搜索到
问题1 在abiFilter申明arm64-v8a，此操作可能会导致异常，某些库并没有支持，需要更换。
android{ defaultConfig { ndk { abiFilters "armeabi", "armeabi-v7a", "x86", "arm64-v8a" } } } 在安卓源码中搜索deprecated_abi_message，可以找到一个DeprecatedAbiDialog，此类下有提交日志，显示是需要适配64位的
问题2 修改targetSdkVersion为28
在安卓源码中搜索deprecated_target_sdk_message，可以找到一个DeprecatedTargetSdkVersionDialog弹窗，它由AppWarnings.showDeprecatedTargetDialogIfNeeded拉起，判定是否拉起的关键是Build.VERSION.MIN_SUPPORTED_TARGET_SDK_INT，搜索这个变量，在frameworks/base/core/java/android/os/Build.java可以找到如下解释
/** * The current lowest supported value of app target SDK. Applications targeting * lower values may not function on devices running this SDK version. Its possible * values are defined in {@link Build.VERSION_CODES}. * * @hide */ public static final int MIN_SUPPORTED_TARGET_SDK_INT = SystemProperties.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ccab60bc1a545174fca378b5073d00c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39ee1951b731f41f7ce71c2fdb9473f1/" rel="bookmark">
			【git】 git切换到指定远程分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【git】 git切换到指定远程分支 我们在使用git进行开发的时候经常会遇到需要切换远程分支并且提交到远程指定分支的情况，现在记录下操作步骤。
查看远程所有分支 $ git branch -a git branch不带参数,列出本地已经存在的分支，并且在当前分支的前面用*标记，加上-a参数可以查看所有分支列表，包括本地和远程，远程分支一般会用红色字体标记出来
dev master remotes/origin/HEAD -&gt; origin/master remotes/origin/master remotes/origin/release/caigou_v1.0 新建分支并切换到指定分支 git checkout -b dev origin/release/caigou_v1.0 git checkout -b 本地分支名 origin/远程分支名 该命令可以将远程git仓库里的指定分支拉取到本地，这样就在本地新建了一个dev分支，并和指定的远程分支release/caigou_v1.0关联了起来。
Switched to a new branch 'dev' Branch 'dev' set up to track remote branch 'release/caigou_v1.0' from 'origin'. 查看本地分支及追踪的分支 $ git branch -vv git branch -vv命令可以显示本地所有分支，执行结果如下：
* dev e67e3ef [origin/release/caigou_v1.0] 供应商详情页面 master 11160c2 [origin/master: behind 5] Merge branch 'master' of https://git.jointforce.com/scm/join/yj-stat “*” 表示当前所在分支，[远程分支]表示当前本地分支追踪的远程分支，最后一个是最近一次提交的注释。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39ee1951b731f41f7ce71c2fdb9473f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3085ae1f5a85f9e0844c4a062787bc6e/" rel="bookmark">
			mysql数据库、表导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用mysqldump命令行工具导出 1.1 导出整个数据库 mysqldump -u username -p password database &gt; database_backup.sql 上述命令将整个数据库导出到名为database_backup.sql的文件中。其中，username是mysql数据库的用户名，password是用户密码，database是要导出的数据库名。
1.2 导出指定表 mysqldump -u username -p password database table1 table2 &gt; table_backup.sql 上述命令将数据库中的table1和table2两个表导出到名为table_backup.sql的文件中。
1.3 导出查询结果 mysqldump -u username -p password database --where="column='value'" &gt; query_backup.sql 上述命令将满足条件的查询结果导出到名为query_backup.sql的文件中。其中，column是要过滤的列名，value是要过滤的值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40497474a9b07a9249aad17e081a38f3/" rel="bookmark">
			Python实现定时对网站进行签到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、步骤Reference 一、步骤 首先打开我们需要签到的网站，使用Chrome浏览器的F12快捷键（或通过鼠标右键菜单“检查”）打开浏览器的开发者工具，点击 Network 查看所有加载的请求。
如果是chrom浏览器，下面按钮都可以点一点：
如下方动图所示，这个时候我们手动点击签到，就会发现出现了一个新的post请求（checkin），不出所料这便是我们签到的请求。
点击签到抓取请求
如下图所示，右键复制网络抓到的网络请checkin(可以看到是一个POST请求)求为cURL(bash)。
复制cURL(bash)
然后打开网站： 在线curl命令转代码
将刚刚复制的内容，填写该网站左侧，右侧同时生成了对应的 python requests 代码。
剩下的事就很简单了，只需要每天定时执行该代码（模拟发起post签到请求）就可以实现该网站签到。
#!/usr/bin/python3 # method: https://cloud.tencent.com/developer/article/2177163 import requests def SignInJob(): cookies = { 'cf_clearance': 'kkL3ik11G7JsHFv4ggv2_KNIVPYyzVX_I9S6N3s04jo-1698982932-0-1-4dd1e52e.c7951321.42a19621-0.2.1698982932', } headers = { 'authority': 'ai-panda.xyz', 'accept': '*/*', 'accept-language': 'en,zh-CN;q=0.9,zh;q=0.8', # 'content-length': '0', 'content-type': 'application/json', # 'cookie': 'cf_clearance=kkL3ik11G7JsHFv4ggv2_KNIVPYyzVX_I9S6N3s04jo-1698982932-0-1-4dd1e52e.c7951321.42a19621-0.2.1698982932', 'origin': 'https://ai-panda.xyz', 'referer': 'https://ai-panda.xyz/user', 'sec-ch-ua': '"Chromium";v="118", "Google Chrome";v="118", "Not=A?Brand";v="99"', 'sec-ch-ua-mobile': '?0', 'sec-ch-ua-platform': '"Windows"', 'sec-fetch-dest': 'empty', 'sec-fetch-mode': 'cors', 'sec-fetch-site': 'same-origin', 'token': 'd6703d78ded92f764577f5879baf7ed3', 'user-agent': 'Mozilla/5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40497474a9b07a9249aad17e081a38f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51a98669dad4b0da987cc223ec490739/" rel="bookmark">
			Linux centos screen命令基础用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		screen 是一个在Linux系统中非常有用的工具，特别是当你需要在远程服务器上运行长时间运行的任务时.
下面是在centos 7中使用方法：
安装 如果你的centos 7 没有安装可以执行下面命令安装
[root@MiWiFi-R3D-srv ~]# sudo yum install screen 当然如果你找不到安装包你可以执行下面这命令
yum install screen 在Debian或Ubuntu上，你可以使用以下命令安装：
sudo apt-get install screen 使用 1.新建会话 在终端输入 screen 并按回车，这将新建一个 screen 会话
[root@MiWiFi-R3D-srv ~]# screen 或者，你可以给新会话一个名称，这样好找到
[root@MiWiFi-R3D-srv ~]# screen -S &lt;会话名&gt; 2.会话列表 查看当前使用的"screen"会话，可以使用
[root@MiWiFi-R3D-srv ~]# screen -ls 3.重新连接会话 如果你已经断开了某个 screen 会话，你可以用下面的命令重新连接：
[root@MiWiFi-R3D-srv ~]# screen -r 如果有多个会话，你需要指定会话名或会话ID
[root@MiWiFi-R3D-srv ~]# screen -r &lt;会话名&gt; 4.断开会话 要暂时断开当前会话并返回到主终端，你可以使用：
按下ctrl+A+D
5.关闭会话 如果你要结束可以执行下面的
按下ctrl+A+K
或者在会话中直接输入 exit。
删除 screen -S &lt;会话名&gt; -X quit
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51a98669dad4b0da987cc223ec490739/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89235d0ecc434bfd4beeddd1936fdfb3/" rel="bookmark">
			Linux内核MTD驱动程序与SD卡驱动程序(转载)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://www.360doc.com/content/10/0806/11/496343_44040067.shtml
文章目录 1. 引言2. MTD内存技术设备2.1. MTD内存技术设备层次结构2.2. 设备层和原始设备层的函数调用关系2.3. MTD相关结构2.4. MTD块设备初始化2.5. MTD块设备的读写操作2.6. MTD核心初始化2.7. MTD字符设备2.8. 具体flash芯片的探测及映射2.9. 驱动程序实例分析 3. SD/MMC卡块设备驱动程序3.1. MMC抽象设备层相关结构3.1.1. 设备描述结构3.1.2. 读写请求相关结构 3.2. MMC抽象设备层MMC块设备驱动程序3.2.1. MMC块设备驱动程序初始化3.2.2. MMC块设备驱动程序探测函数3.2.3. MMC卡请求的处理 3.3. 具体MMC控制器驱动程序示例3.3.1. amba控制器驱动程序相关结构3.3.2. amba控制器的初始化3.3.3. 设备探测函数mmci_probe3.3.4. amba控制器操作函数 1. 引言 flash闪存设备和SD插卡设备是嵌入式设备用到的主要存储设备，它们相当于PC机的硬盘。在嵌入设备特别是手持设备中，flash闪存是焊接在嵌入设备主板上的flash闪存芯片。在嵌入设备上有MMC/SD卡控制器及插槽，可通过MMC/SD来扩充存储空间。
嵌入设备的存储设备的空间划分及所有逻辑设备和文件系统示例列出如下图：
在嵌入设备上的flash芯片上blob和zImage直接按内存线性地址存储管理，对于flash芯片上留出的供用户使用的存储空间，使用MTDBLOCK块设备和JFFS2文件系统。对于flash芯片的分区表信息则以MTDCHAR字符设备来存储管理。
在嵌入设备上的MMC/SD插卡则由MMCBLOCK驱动程序和VFAT文件系统进行存储管理。本章分析了MTD设备和MMC/SD驱动程序。
2. MTD内存技术设备 Linux中MTD子系统在系统的硬件驱动程序和文件系统之间提供通用接口。在MTD上常用的文件文件系统是JFFS2日志闪存文件系统版本 2（Journaling Flash File System）。JFFS2用于微型嵌入式设备的原始闪存芯片的文件系统。JFFS2文件系统是日志结构化的，这意味着它基本上是一长列节点。每个节点包 含有关文件的部分信息 ― 可能是文件的名称、也许是一些数据。与Ext2文件系统相比，JFFS2因为有以下这些优点：
JFFS2在扇区级别上执行闪存擦除／写／读操作要比Ext2文件系统好。JFFS2提供了比Ext2fs更好的崩溃／掉电安全保护。当需 要更改少量数据时，Ext2文件系统将整个扇区复制到内存（DRAM）中，在内存中合并新数据，并写回整个扇区。这意味着为了更改单个字，必须对整个扇区 （64 KB）执行读／擦除／写例程 ，这样做的效率非常低。JFFS2是附加文件而不是重写整个扇区，并且具有崩溃／掉电安全保护这一功能。
JFFS2是是为FLASH定制的文件系统，JFFS1实现了日志功能，JFFS2实现了压缩功能。它的整个设计提供了更好的闪存管理。JFFS2的 缺点很少，主要是当文件系统已满或接近满时，JFFS2会大大放慢运行速度。这是因为垃圾收集的问题。
MTD驱动程序是专门为基于闪存的设备所设计的，它提供了基于扇区的擦除和读写操作的更好的接口。MTD子系统支持众多的闪存设备，并且有越来越多的驱动程序正被添加进来以用于不同的闪存芯片。
MTD子系统提供了对字符设备MTD_CHAR和块设备MTD_BLOCK的支持。MTD_CHAR提供对闪存的原始字符访问，象通常的 IDE硬盘一样，在MTD_BLOCK块设备上可创建文件系统。MTD_CHAR字符设备文件是 /dev/mtd0、/dev/mtd1、/dev/mtd2等，MTD_BLOCK块设备文件是 /dev/mtdblock0、/dev/mtdblock1等等。
NAND和NOR是制作Flash的工艺，CFI和JEDEC是flash硬件提供的接口，linux通过这些用通用接口抽象出MTD设备。JFFS2文件系统就建立在MTD设备上。
NOR flash带有SRAM接口，可以直接存取内部的每一个字节。NAND器件使用串行I/O口来存取数据， 8个引脚用来传送控制、地址和数据信息。NAND读和写操作用512字节的块。
2.1. MTD内存技术设备层次结构 MTD(memory technology device内存技术设备) 在硬件和文件系统层之间的提供了一个抽象的接口，MTD是用来访问内存设备（如：ROM、flash）的中间层，它将内存设备的共有特性抽取出来，从而使 增加新的内存设备驱动程序变得更简单。MTD的源代码都在/drivers/mtd目录中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89235d0ecc434bfd4beeddd1936fdfb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e71a1d7a1fecdf5640e16fed3c9f131/" rel="bookmark">
			零基础入门Jetson Nano——通过OpenCV调用CSI和USB摄像头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jetson Nano学习——摄像头调用 前言一、CSI摄像头的调用1、安装v4l2-utils协助工具2、查看摄像头挂载情况3、查看挂载的摄像头详细参数情况4、检测摄像头能否正常工作5、使用OpenCV调用CSI摄像头方式一、利用Gstreamer通道打开摄像头方式二、利用Jetcam通道打开摄像头 二、USB摄像头的调用总结 前言 因为Jetson Nano是一款AI边缘计算开发板，所以用它来做嵌入式AI项目是很合适的。本文将详细介绍Jetson Nano如何通过OpenCV调用CSI摄像头（IMX219）和USB摄像头。
一、CSI摄像头的调用 1、安装v4l2-utils协助工具 sudo apt install v4l-utils 2、查看摄像头挂载情况 ls /dev/video* 我这里video0和video1是CSI摄像头，video2是USB摄像头。
3、查看挂载的摄像头详细参数情况 v4l2-ctl --device=/dev/video0 --list-formats-ext RG10:代表这个摄像头的数据格式；
10-bit Bayer RGRG/GBGB:是进一步说明该格式使用的算法与通道对应的参数；
3264x2464、3264x1848、1920x1080、1640x1232、1280x720:代表尺寸；
Interval为性能参数，表示所支持的分辨率及该分辨率的最高执行帧率。
4、检测摄像头能否正常工作 终端输入以下代码，检测摄像头能否正常打开。
nvgstcapture 5、使用OpenCV调用CSI摄像头 Jetson Nano默认安装了OpenCV 4.1.1版本。
方式一、利用Gstreamer通道打开摄像头 安装Gstreamer
sudo add-apt-repository universe sudo add-apt-repository multiverse sudo apt-get update sudo apt-get install gstreamer1.0-tools gstreamer1.0-alsa gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav sudo apt-get install libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev libgstreamer-plugins-good1.0-dev libgstreamer-plugins-bad1.0-dev 实现读取CSI摄像头的步骤
创建Gstreamer管道
将Gstremer管道绑定至OpenCV的视频流
逐帧提取并绑定
示例
import CV2 # 设置gstreamer管道参数 def gstreamer_pipeline( capture_width=1280, #摄像头预捕获的图像宽度 capture_height=720, #摄像头预捕获的图像高度 display_width=1280, #窗口显示的图像宽度 display_height=720, #窗口显示的图像高度 framerate=60, #捕获帧率 flip_method=0, #是否旋转图像 ): return ( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e71a1d7a1fecdf5640e16fed3c9f131/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb8b4ab1d2f791441eec321123b9ca65/" rel="bookmark">
			Linux ---------------------内置命令test
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Shell中test命令用于检查某个条件是否成立，test一般有三种用法：
测试文件或者文件夹字符串比较数值比较 整数比较测试：
if test 数字1 options 数字2
then
fi
options 具体如下：
参数说明-eq等于则为真-ne不等于则为真-gt大于则为真-ge大于等于则为真-lt小于则为真-le小于等于则为真 测试案例：文件：
#!/bin/bash
num1=100
num2=100
if test $[num1] -eq $[num2]
then
echo '两个数相等！'
else
echo '两个数不相等！'
fi
a=5
b=6
result=$[a+b] # 注意等号两边不能有空格
echo "result 为： $result"
字符串测试
参数说明=等于则为真！=不相等-z 字符串字符串的长度为0则相等-n 字符串字符串的长度不为0则相等$测试字符串是否不为空，不为空则为真 测试案例：
num1="ru1noob"
num2="runoob"
if test $num1 = $num2
then
echo '两个字符串相等!'
else
echo '两个字符串不相等!'
fi 文件测试
参数说明-e 文件名如果文件存在则为真-f 文件名如果文件存在且可读则为真-w 文件名如果文件存在且可写则为真-x 文件名如果文件存在且可执行则为真-d 文件名如果文件存在且为目录则为真-s 文件名如果文件存在且至少有一个字符则为真-f 文件名如果文件存在且为普通文件则为真-c 文件名如果文件存在且为字符型特殊文件则为真-b 文件名如果文件存在且为特殊文件则为真 测试案例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb8b4ab1d2f791441eec321123b9ca65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e84ce68d311513de7d50ed66e832857e/" rel="bookmark">
			从行车记录仪恢复已删除/丢失视频的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“我的车里有行车记录仪。几天前，当我下班回家时，一辆卡车不知从哪里冒出来撞向了我。我们的两辆车都损坏了，但幸运的是，没有人受伤。我曾与卡车司机就修理我的汽车进行过会面，但他说我有错。我需要查看我的行车记录仪记录，但视频丢失了。如何恢复丢失的行车记录仪镜头？”
行车记录仪又称行车记录仪、车载摄像头或车载DVR，是最必备的汽车配件之一。在路边事件的情况下，来自行车记录仪的视频证据将在确定谁有过错方面发挥重要作用。然而，这样的视频记录很容易丢失，这使得解释交通事故变得更加困难。
如果您遇到这种情况，请不要担心，请阅读本指南以获得最好的行车记录仪恢复软件，以从您的行车记录仪中检索已删除/丢失的视频。
可以恢复已删除的行车记录仪录像吗？ 这个问题的简单答案是肯定的。在展示如何恢复已删除的行车记录仪视频之前，我们必须首先了解行车记录仪的工作原理以及行车记录仪录像丢失的原因。
是否可以从行车记录仪恢复已删除的视频
删除我们行车记录仪上的文件总是有原因的。可能是为了释放空间或误操作。无论如何，如果您使用正确的工具，都可以恢复已删除的行车记录仪。
您需要恢复已删除的行车记录仪视频的案例
您可能在没有考虑重要文件的情况下错误地格式化了行车记录仪卡。
您的孩子或兄弟姐妹可能已经访问了它并删除了相关视频。
传输问题，在传输错误的情况下，您的行车记录仪摄像机肯定删除了您的视频。
行车记录仪经得起考验。你的可能被压碎或从无人机上掉下来，从而扰乱了某些东西。
在将您的行车记录仪视频从 Mp4 转换为 MOV 时，您遇到了一个问题。最好的解决办法是取回其原始版本。
如何恢复丢失/删除的行车记录仪录像？ 有多种方法可以恢复已删除的行车记录仪视频——您可以手动进行，也可以借助行车记录仪恢复软件。手动方法必须由季节技术人员以非常高的成本执行，而专门的 视频恢复软件 使您只需点击几下即可恢复丢失的行车记录仪镜头。在这方面，行业专家使用的应用程序是奇客数据恢复。
奇客数据恢复可以从损坏的、无法访问的、感染病毒的、有坏扇区等的SD卡中恢复您的视频，速度快，效率高，已被各大媒体推荐；继续阅读以发现该程序的主要功能。
使用奇客数据恢复恢复丢失的行车记录仪录像
首先，在您的电脑上下载奇客数据恢复，将SD卡连接到系统，按照以下步骤操作：
第 1 步：安装并启动奇客数据恢复并在“外部可移动设备”选项卡中选择您的 SD 卡。
奇客数据恢复: 支持1000+数据格式恢复免费下载软件扫描数据，支持文件、照片、视频、邮件、音频等1000+种文件的格式恢复更有电脑/笔记本、回收站、U盘、硬盘等各类存储设备数据丢失恢复https://www.geekersoft.cn/geekersoft-data-recovery.html
第 2 步：单击“开始”让程序扫描您的 SD 卡。扫描 SD 卡所需的时间取决于数据量。
第 3 步： 奇客数据恢复将搜索您丢失的视频并以有组织的方式显示它们。选择您想要的视频，然后点击“恢复”按钮。几分钟之内，删除的文件将被修复。
奇客数据恢复的强大功能：
恢复行车记录仪丢失的不同格式的镜头——MOV、M4V、3GP、MPG、MKV、AVI 等。
从任何存储设备恢复文件——SD 卡、外部硬盘驱动器、USB 驱动器、笔记本电脑、SSD 等。
处理各种数据丢失情况——永久删除、格式化设备、丢失分区、清空回收站等。
超级易于使用——无需技术经验，任何人都可以自行执行数据恢复。
关于行车记录仪视频恢复的常见问题 如何从行车记录仪恢复被覆盖的视频文件？ 存储卡的存储容量有限。因此，如果卡已满而您仍在录制，行车记录仪会开始覆盖最旧的镜头，为新录制腾出空间。
理论上，被覆盖的视频无法直接恢复，即使使用第三方恢复工具也是如此。但是您仍然可以尝试使用此处介绍的两种方法取回视频。
从备份中检索覆盖的车记录仪录像 当行车记录仪覆盖最早录制的视频时，您可以从您创建的备份中取回它们。为防止旧的行车记录仪视频被覆盖，建议您将它们传输到您的 PC 或单独的存储介质。
使用数据恢复软件检索被覆盖的车记录仪视频 如果您计算机上备份的视频也丢失或被删除，请不要担心，您仍有机会使用奇客数据恢复软件找回它们。
奇客数据恢复允许您 在恢复前免费扫描文件，所以请不要犹豫，试用该软件。
在我的行车记录仪上保留多长时间？ 通常，当 SD 卡完好无损时，录制内容会保留在 SD 卡上。但是，当 SD 卡上没有更多可用存储空间时，行车记录仪会开始覆盖最旧的记录以为新记录腾出空间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e84ce68d311513de7d50ed66e832857e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af63a721e4ed92986ef7190e686f55fd/" rel="bookmark">
			AI芯片架构体系综述：芯片类型CPU\GPU\FPGA\ASIC以及指令集CSIS\RISC介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大模型的发展意味着算力变的越发重要，因为大国间科技竞争的关系，国内AI从业方在未来的一段时间存在着算力不确定性的问题，与之而来的是许多新型算力替代方案的产生。如何从架构关系上很好的理解计算芯片的种类，并且从计算类型、生态、流片能力等多角度评估算力需求，正在成为AI方向负责人的核心竞争力。
正因为这个原因，最近几个休息日我一直在看相关领域的文章和论文，试着理清算力基础架构关系，因为过去积累不够深，可能有不准确的地方，还望指出。
PART01 AI芯片架构体系
学习芯片架构，首先需要有一个体系架构图，如何评价一款AI芯片，可以从芯片类型、指令集类型、指令集架构、代表公司以及制程几个角度来看。
不同的芯片类型决定了芯片的用途和设计理念，所以这方面一定是了解芯片最关键的一点。指令集类型和指令集架构，跟芯片的生态息息相关，因为一款好的芯片，不光要具备强大的计算性能，也要有广泛、灵活的开发者生态体系，做到软硬结合。最后一点是公司以及制程，公司的市占率以及芯片的制程是否足够先进，关系到芯片的商用成熟度以及供货保障程度。接下来会详细展开以上几个方向。
PART02AI芯片基本类型
CPU、GPU、FPGA、ASIC是目前AI计算过程中最主流的四种芯片类型，他们的主要区别体现在计算效率、能耗和灵活性上面。
CPU：CPU是冯诺依曼架构下的处理器，遵循“Fetch (取指) -Decode (译码) - Execute (执行) - Memory Access (访存) -Write Back (写回)”的处理流程。在执行计算任务过程中，数据需要先获取并存入RAM，然后解码获得指令，然后在ALU计算模块计算，最终将计算结果返回RAM。整个流程更强调控制和决策，在并行计算效率上有较大提升空间
GPU：GPU最早用于图像处理领域，减少了大量数据预取和决策模块，增加了计算单元ALU的占比，从而在并行化计算效率上有较大优势。
FPGA：FPGA的设计使得计算逻辑十分灵活，它不像CPU和GPU那样只能执行编译和汇编的内容，FPGA因为几乎没有控制模块，所有模块都是ALU计算模块，而且所有模块都可定制开发。但这也是FPGA的主要缺陷，因为具备很强的灵活度，导致设计难度和复杂度较高。
ASIC：ASIC是专门针对某一领域设计的芯片，比如神经网络计算芯片NPU、Tensor计算芯片TPU等。因为是针对特定领域定制，所以ASIC往往可以表现出比GPU和CPU更强的性能，ASIC也是目前国内外许多AI芯片设计公司主要研究的方向，可以预见未来市面上会逐渐有大量AI领域的ASIC芯片出现。
PART03AI芯片指令集和架构
接着说下AI芯片的指令集，首先要了解指令集是什么。计算机执行任务的过程可以看作是把程序编译成硬件可以理解的语言，再有硬件完成最终的计算工作。指令集可以理解是为编程和编译服务的一种计算机硬件可以理解的语言。
指令集分复杂指令集（CSIC）和精简指令集(RISC)。
CSIC主要用于传统的CPU芯片领域，他的设计模式是把用一个指令完成较复杂的任务，比如”帮我选个餐厅“。RISC是精简指令集，把任务进行拆解，比如”先了解我喜欢什么“，再”查查附近有什么餐厅“，”做一个匹配“。因为精简的设计，RISC在优化编译方面有很大的空间，目前深度学习主要计算都在RISC指令集的英伟达GPU芯片，所以目前在计算的编译优化方向，有很大空间，也是行业聚焦的技术方向。
接下来看下指令集架构（ISA），在AI领域需要重点关注ARM、RISC-V，国内外许多厂商也有在探索自研指令集架构，但是也是基于ARM或者RISC-V的设计思路。
ARM架构则是由英国的ARM Holdings公司开发的，它是为嵌入式系统和移动设备而设计的。ARM架构的主要特点是低功耗、高性能和可扩展性，它可以支持移动设备、嵌入式系统、智能家居等应用。
RISC-V是近些年非常流行的指令集架构，RISC-V与 ARM 和 MIPS 最大的差别还是在于其为 RISC-V 基金会进行标准的制定和维护工作而非商业公司，任何人可以无偿使用该指令集开发自己的 CPU ，或者往自己已有的芯片中集成开源免费的 RISC-V IP Core，这是比较吸引电子设备厂商的重要原因。
PART04总结
最近有几个大事件，一个是NV收购ARM进军CPU领域，另外就是美国强化了对国内的高端芯片制裁。从这些动作来看，AI芯片的新一轮竞争暗潮汹涌，随着各个厂商都在减少自己的芯片生态体系，未来在编译优化、异构芯片调度、冯诺依曼内存墙突破等方向一定会有更多新的工作，这些也需要持续探索。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6baafaff8d74df7b067cdb96d484679f/" rel="bookmark">
			AD16布线技巧 新手必看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般技巧 在关键信号线端点处添加去耦电容。尽量加宽电源线、地线宽度，地线比电源线宽更好。数字电路的PCB可用宽的地导线组成一个回路，模拟电路的地不能这样使用。用大面积铜层作地线，将没被用上的地方都与地相连接作为地线用，或是做成多层板，电源和地线各占用一层。注意线与线、线与元件焊盘、线与贯通孔、元件焊盘与贯通孔、贯通孔与贯通孔之间的距离是否合理，是否满足生产要求。要求见上一个博客的杂记。检查电源线和地线的宽度是否合适，电源与地线之间是否紧耦合(低的波阻抗)，在PCB中是否还有能让地线加宽的地方。对于关健的信号线是否采取了最佳措施，如长度最短，加保护线，输入线及输出线被明显地分开。模拟电路和数字电路部分是否有各自独立的地线。注意后加在PCB中的图形（如标、注标）是否会造成信号短路。 AD16为电路板设计软件，在实际操作过程中，因个人的操作习惯和所遇到的问题不同，问题大差不差，仅供参考。
创作不易，别忘了点个赞哦~
进阶技巧-----10原则 改自作者：百芯 EMA 链接：https://www.zhihu.com/question/527579875/answer/2771291014
1、手动布线还是自动布线2、了解制造商的规格3、设置合适的走线宽度（迹线之间留出足够的空间）4、元器件放置要合理（焊盘中间尤其是小封装别走线）5、保持模拟和数字走线分开，注意接地层6、走线和安装孔留有足够的空间7、交替走线方向，避免 90°布线8、避免电容耦合9、放置散热孔和焊盘10、接地和电源走线，合理利用利用丝印层 一、尽可能手动布线 一般 PCB 设计软件都包含自动布线的功能，但没有一个自动布线可以完全取代 PCB Layout 工程师的技能、经验和灵活性。(给 PCB Layout 工程师点赞)
在某些情况下，你可以使用自动布线：
放置完所有的组件后，你可以使用自动布线工作检查你的完成率，如果低于 85%，就需要调整你的组件放置。布线时，瓶颈和其他关键连接点可能从裂缝中脱落，可以使用自动路由功能进行识别。当你不知道怎么开始布线或者遇到困难，可以使用自动布线作为灵感来源。 布线既是一门科学，也是一门艺术，建议尽可能手动布线，以确保准确性和可靠性。
二、了解制造商的规格 在你开始铺设铜迹线时，先花时间问问你的制造商，看制造商是否对最小迹线宽度、迹线间距以及他们可以组装的 PCB 层数有要求。
预先了解这些信息，你可以在设计规则中设置走线宽度和间距值，避免重新布线整个 PCB 布局。
三、选择合适的走线宽度 最小6mil。大部分厂子10mil加工轻松。 走线的几何形状（厚度和宽度）可以确保电路在所有环境和负载条件下正常工作。PCB 的走线用于传输电信号，因此必须具有与通过它们的电流兼容的宽度。
PCB Layout 工程师 必须确定每条走线的最小宽度，以避免电路板过热的危险；该参数直接影响布线过程，因为它减少了 PCB 上的可用空间。
如果可用空间不是问题，建议使用宽度大于最小值的走线，从而提高电路板的热管理和可靠性，外层上的走线可实现更好的热交换，因此可能具有更小的宽度。
图片作者：百芯 EMA
改自链接：https://www.zhihu.com/question/527579875/answer/2771291014
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
走线和焊盘之间留出足够的空间（迹线之间留出足够的空间） 精密电路4mil 普通电路6mil。更多细节见上一个笔记文章 在PCB 走线和焊盘之间保留足够的空间至关重要（如下所示），这可以避免在 PCB 制造或者组装阶段发生短路。
一般来说，建议在每条相邻走线和焊盘之间留出适当的间隙，它们周围必须始终有足够的空间，没有走线或焊盘，以避免触电的风险。
走线的距离和厚度
四、PCB 元器件放置 关系到合理布局 元器件的放置方式决定了PCB 设计是否成功。要正确放置元器件，就必须要充分了解它们的特性。
例如，热敏电解电容必须远离发热二极管、电阻和电感。
以下列出简单的经验法则：
必须要注意具有多引脚的组件，因为这些组件占有的空间很大。保持组件放置在相同的方向在放置之前考虑每个组件的功能及其与其他组件的关系。如果组件已经采购，那么建议按照尺寸在纸上打印布局，并查看组件是否合适。 PCB 元器件放置图
五、保持模拟和数字走线分开 创作不易，别忘了点个赞哦~参考此文章 https://www.cnblogs.com/jackweibe/p/5437514.htmlhttps://www.cnblogs.com/jackweibe/p/5437514.html 承载数字信号的PCB 走线，尤其是高频信号，必须与承载模拟信号的走线分开。数字信号（例如地址或者数据总线）通常在平行走线上传输，在信号之间可能会产生电容耦合和干扰的风险。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6baafaff8d74df7b067cdb96d484679f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4ba03fca1c9299dce7fcbcb52cfe85b/" rel="bookmark">
			小白PX4无人机仿真—OFFBOARD控制资料汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 仿真环境搭建 这套仿真环境是基于Ubuntu20.04环境下的ROS1＋PX4固件的联合仿真，由于初次接触这方面的仿真环境搭建，几番寻找找到了国内的XTdrone开源无人机仿真平台，跟着这套仿真平台搭建了一个完整的仿真环境，XTdrone这个平台的简介可以参考这个视频：
XTDrone: 基于PX4、ROS和Gazebo的无人机通用仿真平台简介_哔哩哔哩_bilibili
这里再附上XTdrone的gitee链接 ：
XTDrone: 基于PX4、ROS和Gazebo的无人机通用仿真平台
对于无人机仿真来说其实本质需要的就是三大部分，ROS环境，MAVROS包，PX4编译环境，ROS提供通讯和Gazebo仿真环境，PX4固件支持linux编译运行，并通过Gazebo仿真出来，还可连接QGC地面站，MAVROS则是ROS和PX4通讯的桥梁，因为PX4只支持mavlink通讯协议，而ROS则是基于话题，服务等通讯机制，所以需要有一个功能包去把话题和服务转换成mavlink协议，这个功能包就是MAVROS。
XTdrone的搭建有两个版本，一个是基于Ubuntu18.04的但由于Ubuntu18.04已经停止维护，所以更推荐基于Ubuntu20.04的版本，其对应的PX4版本也比较新。下面是搭建的官方教程，最好需要有科学上网的环境，不然配置起来很麻烦，另外官方的教程基于Ubuntu20.04可能安装的人并不多，所以坑还是不少的，每个人的坑也不太一样，不过这些坑基本可以从CSDN上找到解决办法。
此处为语雀内容卡片，点击链接查看：仿真平台基础配置（对应PX4 1.13版） · 语雀
当可以运行键盘控制无人机飞行则表明环境搭建成功
2. 上层控制基础介绍 对于上层控制PX4，飞控端的模式是OFFBOARD，在这个模式下，可以通过mavlink协议，对无人机发送期望位置，期望速度，期望加速度来控制无人机，同时可以通过接收mavlink消息来获取无人机当前姿态。下面这个视频系列对这个模式有详细的介绍：
新手入门无人机+PX4+ROS工程应用开发？看这门课就够了 4.无人机offboard控制_哔哩哔哩_bilibili
同时介绍一下mavros功能包，这个功能包所包含的话题和服务种类很多，这里列举几个常用的消息话题：
【精选】ROS系列——mavros功能包中常用话题和服务介绍，包括消息名称、类型、头文件、成员变量、示例代码_mavros/mission/waypoint-CSDN博客
常用的基本上也就是以下这几个
mavros/statemavros/local_position/posemavros/manual_control/controlmavros/setpoint_position/localmavros/setpoint_velocity/cmd_vel_unstampedmavros/setpoint_attitude/attitudemavros/cmd/armingmavros/set_mode（谨慎使用） 3. 代码分析 3.1 一键起飞例程运行 第一步需要启动PX4官方的一个仿真launch文件
cd ~/PX4_Firmware roslaunch px4 mavros_posix_sitl.launch 此时会启动一个Gazebo的仿真环境，如下图所示
再新开一个终端，并运行
rostopic echo /mavros/state 这是用来订阅/mavros/state这一话题，可以实时查看当前无人机状态，如果connected显示的是True的话,则说明仿真运行正常，MAVROS通讯正常。显示的效果如下图所示：
如果安装了地面站的话执行下面指令打开地面站（到软件包对应目录）
./QGroundControl.AppImage 此时在地面站应该可以看到无人机相关状态信息，随后就进入到了最关键的一步，编写offboard控制节点，这个节点的功能包如果还没创建，可以参考下面这篇文章：
【ROS+Gazebo+px4】打开offboard模式，offboard_node文件内容-CSDN博客
而具体的源码分析，可以参考下面这篇文章：
mavros笔记（一）：mavros概述与offboard例程解析_听风南巷的博客-CSDN博客
3.2 代码分析 首先从最开始运行的 mavros_posix_sitl.launch 这一launch文件说起，下面是这个launch文件源码
&lt;?xml version="1.0"?&gt; &lt;launch&gt; &lt;!-- MAVROS posix SITL environment launch script --&gt; &lt;!-- launches MAVROS, PX4 SITL, Gazebo environment, and spawns vehicle --&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4ba03fca1c9299dce7fcbcb52cfe85b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b88bb365c6dd680ea012dcb82fa1d7/" rel="bookmark">
			普通人快速逆袭的一个路径:AI赛道&#43;早&#43;下场干
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天参加去参加了一场AI峰会，几点收获：
1、要早 无界AI300万用户，2022年5月就已经入场干
黄小刀出版最早的ChatGPT书籍和最早的ChatGPT训练营
浙工大团队也是2022年最早的使用AI绘画
2、要快速下场干 最早的知道这个事情没用，还要快速下场干，曾哥、黄小刀、浙工大团队、硅基等都是快速干起来的
3、普通人翻身的故事:AI+早+下场干 黄小刀的故事，普通人的逆袭，连续成功，半年出4本书、出版社、社群，牛逼，听的我差点热泪盈眶，可能因为我也是最普通的普通人。
4、职场没前途，越是对职场抱有幻想，将来越是惨。 5、创业者要抱团，技术创业者不要闭门写代码 要去和牛逼的人交流，和别人合作，自己闭门造车没前途，多走出去看看，想单枪匹马憋大招，黄花菜早凉了。尤其是技术出身的创业者，这点太重要了。
6、AI已经融入方方面面，不要再等了 从分享者的成功案例看，电商、教育、设计、影视、短视频、直播、广告等都在大量应用AI。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be984584c7d7478d06eec5cf7b9ef783/" rel="bookmark">
			Navicat连接mysql 8.0.35 2059错误解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这2天在家重装电脑，顺便把mysql升级8.0，安装完成后，用Navicat连接，报错2059，如下
网上查了一下，
【报错原因】mysql8.0 之前的版本中加密规则是 mysql_native_password，而 mysql8.0 之后的版本加密规则是caching_sha2_password
【解决办法】修改 mysql8.0 的加密规则
# 1、连接 mysql 服务器 mysql -u root -p # 2、进入 mysql 数据库 mysql&gt; use mysql; # 3、查看 user 表 mysql&gt; select user,host from user; # 4、设置登录密码永不过期(password改为自己的) mysql&gt; alter user 'root'@'localhost' identified by 'password' password expire never; # 5、修改加密规则(password改为自己的) mysql&gt; alter user 'root'@'localhost' identified with mysql_native_password by 'password'; # 6、刷新权限 mysql&gt; flush privileges; # 7、退出 mysql&gt; quit 我本地的账户名和密码是root/root
本地测试连接一下，成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b127b4b1c266aa8af3e8f05e3fc7b187/" rel="bookmark">
			一、网络测试命令——命令行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、如何查看IP地址
首先，开始——运行——cmd进入命令行窗口 或者 win+R——cmd进入命令行窗口
ipconfig #查看IP地址基本信息 ipconfig /all #查看IP地址详细信息 二、测试网络连通性
ping 目标IP地址 #测试网络连通性，有去有回即为可通信成功 ping -t 目标IP地址 #一直ping目标IP ping -n 数字 目标IP地址 #修改ping包的数量 ping -l 数字 目标IP地址 #修改ping包的大小 注意：若无法ping通，可能对方不在线或对方开着防火墙。
可随时按下ctrl+c终止命令行执行。
其中，Sent代表发出包的数量，Received代表对方接收到的包的数量，Lost代表发送过程中丢失的包的数量。
三、手工解析域名命令
nslookup www.baidu.com #DNS服务器手工解析百度域名 四、ping命令测试上网速度
ping www.baidu.com ping -l 1400 www.baidu.com #1400即包的大小 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ce171dc3bf2cd4bba143201c9ec30ec/" rel="bookmark">
			go语言 ｜ grpc原理介绍（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解 gRPC 通信模式中的消息流 gRPC 支持四种通信模式，分别是简单 RPC、服务端流式 RPC、客户端流式 RPC 和双向流式 RPC。
简单 RPC 在gRPC中，一个简单的RPC调用遵循请求-响应模型，通常涉及以下几个关键步骤和组件：
请求头（Request Header）: 客户端（Client）发起请求时，首先发送一个请求头，其中包含元数据，如目标服务、方法等。长度前缀消息（Length-Prefixed Message）:在请求头后面，客户端发送实际的RPC消息。这个消息一般会有一个长度前缀，以便服务端（Server）可以准确地解析它。数据帧（Data Frames）: 一个消息可能会分成多个数据帧进行传输，这取决于消息的大小和底层传输协议的限制。流结束标志（EOS, End Of Stream）:客户端在发送完所有数据帧后会设置一个EOS标志。这标志着客户端对该请求的“半关闭”状态，意味着客户端将不再发送更多数据，但仍然可以接收来自服务端的响应。响应头（Response Header）: 服务端在收到并解析完整的请求消息后，首先发送一个响应头。响应消息（Response Message）: 随后，服务端发送实际的响应消息，该消息也是一个长度前缀的格式。Trailers: 最后，服务端通过发送一个带有状态详细信息的Trailers头来结束通信。
服务端流式 RPC 从 client 端的角度来看，简单 RPC 和服务端流式 RPC 具有相同的请求消息流。在这两种情况下，我们都会发送一条请求消息。主要区别在于 server 端。server 端会发送多条消息，而不是向 client 端发送一条响应消息。server 端一直等待，直到收到完整的请求消息，之后发送响应头和多个带长度前缀的消息。一旦 server 端发送带有状态详细信息的 Trailers 标头，通信就会结束。
客户端流式 RPC 在客户端流式 RPC 中，client 端向 server 端发送多条消息，server 端发送一条响应消息作为回复。client 端首先通过发送请求头帧建立与 server 端的连接。建立连接后，client 端会向 server 端发送多个长度前缀消息作为数据帧。最后，client 端通过在最后一个数据帧中发送一个 EOS 标志来半关闭连接。同时，server 端读取从 client 端接收到的消息。一旦接收到所有消息，server 端就会发送响应消息以及 Trailers 标头并关闭连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ce171dc3bf2cd4bba143201c9ec30ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e00a14db20dfffbab89e83a7c6d2ccd/" rel="bookmark">
			MATLAB算法实战应用案例精讲-【图像处理】目标检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
算法模型
两阶段（2-stage）检测模型
R-CNN: R-CNN系列的开山之作
Fast R-CNN: 共享卷积运算
Faster R-CNN: 两阶段模型的深度化
单阶段（1-stage）检测模型
YOLO
SSD: Single Shot Multibox Detector
模型的评测与训练技巧
检测模型的评测指标
标准评测数据集
检测模型中的Bells and wisthles
基础网络演进、分类与定位的权衡
基础网络结构的演进
卷积网络结构演进的趋势
ResNet: 残差学习
分类与定位问题的权衡
R-FCN
Deformable Convolution Networks
特征复用、实时性
特征复用与整合
FPN
TDM
DSSD
RON
FSSD
RefineDet
面向实时性的工作
Light Head R-CNN
YOLOv2
SSDLite(MobileNets V2)
目标检测新趋势
YOLO9000
Mask R-CNN
Focal Loss（RetinaNet）
Mimicking
CGBN（Cross GPU Batch Normalization）
DSOD（Deeply Supervised Object Detector）
A-Fast-RCNN
Relation Module
前言 如何理解一张图片？根据后续任务的需要，有三个主要的层次。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e00a14db20dfffbab89e83a7c6d2ccd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7fc0f50b24344df389b64f0f3244d13/" rel="bookmark">
			使用Gorm进行高级查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入探讨GORM的高级查询功能，轻松实现Go中的数据检索 高效的数据检索是每个应用程序性能的核心。GORM，强大的Go对象关系映射库，不仅扩展到基本的CRUD操作，还提供了高级的查询功能。本文是您掌握使用GORM进行高级查询的综合指南。我们将探讨WHERE条件、连接和关联、预加载相关数据，甚至涉足原始SQL查询的领域。最终，您将具备在Go应用程序中以无与伦比的精度提取和操作数据的能力。
GORM中的WHERE条件 使用WHERE条件来细化查询对于提取特定数据子集至关重要。
步骤1：基本的WHERE子句
使用GORM的Where方法来应用条件：
var expensiveProducts []Product db.Where("price &gt; ?", 50).Find(&amp;expensiveProducts) 步骤2：AND和OR条件
使用逻辑运算符组合多个条件：
var filteredProducts []Product db.Where("price &gt; ? AND category = ?", 50, "Electronics").Find(&amp;filteredProducts) GORM中的连接和关联 模型之间的关联允许跨多个表进行复杂查询。
步骤1：定义关联
在模型结构中设置关联：
type User struct { gorm.Model Orders []Order } type Order struct { gorm.Model UserID uint Product string } 步骤2：执行连接
使用GORM的Joins方法从关联的模型中检索数据：
var usersWithOrders []User db.Joins("JOIN orders ON users.id = orders.user_id").Find(&amp;usersWithOrders) 在GORM中预加载相关数据 高效地加载相关数据以减少数据库查询次数。
步骤1：预加载关联
使用GORM的Preload方法来主动加载关联的数据：
var users []User db.Preload("Orders").Find(&amp;users) 步骤2：嵌套预加载
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7fc0f50b24344df389b64f0f3244d13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fac5c676d4159274b0b111d1a96392e0/" rel="bookmark">
			万字解读Java线程-AtomicInteger原子类实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAS简介 我们在学习多线程期间，看到最多的例子就是累加器，代码如下：
public class Test { long count = 0; void add10K() { int idx = 0; while(idx++ &lt; 10000) { count += 1; } } } 复制代码 上面的代码并非线程安全的，问题主要出现在count变量的不可见性和count+=1并非原子性操作，之前的解决方式都是使用Synchronized或者java sdk加锁的方式来保证原子性，使用volatile来保证可见性。
在java线程-Lock详解&amp;AQS原理详解一文中，发现大量使用了自旋+CAS操作，来保证线程安全性，这是一种无锁的操作，性能会比加锁的方式高很多。
我们先了解一下什么是CAS：
CAS指的是先检查再更新这类复合操作，英文翻译有很多种：Compare And Set、Compare And Swap或者Check And Set。
CAS指令包含3个参数：
共享变量的内存地址A用于比较的值B共享变量的新值C CAS的检查更新逻辑如下：
if A == B # 当 A = B的时候才能将A的值更新为C A = c 复制代码 原子CAS指令 了解了CAS的基本概念以后，我们来看一下如何通过自旋 + CAS操作来实现一个线程安全的累加器。
代码如下：
class SimulatedCAS{ volatile int count; // 实现count+=1 addOne(){ do { newValue = count+1; }while(count !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fac5c676d4159274b0b111d1a96392e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d72cbe244b6c0fedb1cfc2a26325e6e/" rel="bookmark">
			题目描述任意读入一个四位整数，颠倒后输出。输入输入一行，只有一个整数x(1000＜=x＜=9999)。输出输出只有一行，包括1个整数。倒序输出一个四位整数例输入复制4567输出复制7654输入复制16
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;iostream&gt;
using namespace std;
int main()
{ int n;
cin&gt;&gt;n;
int g = n/1%10;
int o = n/10%10;
int s = n/100%10;
int k = n/1000%10;
cout&lt;&lt;g*1000+o*100+s*10+k;
return 0;
} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b97bf535d019e753c0a43bb209a21f2f/" rel="bookmark">
			【软著写作】软著写作过程记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 整体流程图：写在前面：一、准备材料1 准备材料2 申请盖章 二、软件登记1 注册账号2 填报软著 整体流程图： 写在前面： 这两天填报了一篇软著，正好将以前第一次填报时，踩的一些坑和过程记录了一下，给实验室学弟学妹参考，仅作参考。
以前是需要邮寄纸质材料，今年改版了，全线上，全部上传电子文档就行。
注意！注意! 注意！下面仅代表个人经历经验，可能会有错误，自行甄别。
一、准备材料 1 准备材料 我将这份已发放的所有过程材料放到网盘里，自取，实验室内部材料，严禁外传。
下载链接：https://wwzr.lanzout.com/iye5K1dnlqaf
密码是我的名字首字母，小写。
需要准备4份材料。主要是去写说明书和程序清单，协议书和承诺书是学校的模板，打印签字盖章就行。
1 说明书：格式参考学长学姐的，可以多去要几份。
2 程序清单：格式参考学长学姐的，不查重，随便贴，规范格式，删了中文注释，空白行。
3 协议书：需要盖章。章需要申请，具体下面说。打印出来，签好字，去东五行政楼7-11处盖章。
4 承诺书：仅需签字，不盖章。去盖协议书章时带着，那边收的话就给他，不收就算了，自己留着。（上次收了，但这次我去盖章，他没收）
2 申请盖章 盖章需要找梁老师，让她帮忙申请学校的章，学生是申请不了的。具体流程是这样的：
1 把承诺书和协议书的PDF版，发给老师，然后给老师说：梁老师，您能帮我申请一下软著用章吗？2 她申请下来后，会给你说的。如果两天没回应，就再去问一下，可能已经申请下来了，但老师忘了。3 去东五行政楼7-11，报梁老师名字，给协议书盖章。 协议书盖完章以后，需要扫描成电子档，因为后面填报软著时需要提交协议书电子版。
实验室打印机，是可以扫描的，就是有点麻烦或去打印店扫描手机扫描王APP（但我不确定这种行不行，我上次的软著是用的打印机扫描的，这次的话我就是直接用手机扫的） 二、软件登记 1 注册账号 去中国版权保护中心注册账号：https://www.ccopyright.com.cn/
这个注册后的通过时间，看运气了，我等了半个月才通过，有的就只要几天
2 填报软著 等注册好后，就可以开始填报软著了。
选
选
选
开始填写，网页最上面显示了填写进度，带⭐的必填
填
著作人问题：协议书上，写了几个人，这边就需要填几个人。这个是一个坑点，后面有个收短信验证码环节，这边填了几个人，就需要几个人的验证码，我们去年填了五位老师，就需要五位老师的验证码，一段时间内收不起就过期了，又要去找各个老师要。所以说，协议书上写几个人，自己考虑好
注意：点击添加著作权人，把学校加上，并且，让学校当第一个作者
这些就是根据自己的软著情况写了
提交说明书和程序的PDF
然后就是确认信息，确认无误发送短信验证码，学校的验证码需要进学校专利群，群号就不贴网上了，线下问。
然后是 下载系统生成的确认签章页，签字，扫描，提交PDF
就结束了，等补正或者直接发放。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/74/">«</a>
	<span class="pagination__item pagination__item--current">75/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/76/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>