<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c353f9912f864004fecf431f764f33bf/" rel="bookmark">
			交通流预测爬坑记（二）：最简单的LSTM预测交通流，使用tensorflow2实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说到时间序列预测，我想一定首先想到RNN，然后想到LSTM，LSTM原理就不说了，网上有很多相关文章。
下面使用tensorflow2.0来实现预测
不得不说tensorflow2.0 太香了，太简单了，真的是有手就行 在tensorflow中只需要调用已经tensorflow的LSTM模块就行了，比如下面的代码
from tensorflow.keras.layers import Dense,LSTM,Dropout model = tf.keras.Sequential([ LSTM(80, return_sequences=True), Dropout(0.2), LSTM(80), Dropout(0.2), Dense(1) ]) model.compile(optimizer='adam', loss='mse',) 这样就创建了一个2层LSTM，每层80个神经元的；同时添加了Droopout函数防止过拟合；使用adam激活函数；使用mse作为损失误差的神经网络。真的炒鸡简单。
主要问题是数据的处理，要做时间序列预测，原理应该是使用前n个时间去预测下一个时间，也就是所模型训练的数据应该是下面这个图这样的数据
所以处理数据才是困难的地方。
下面我使用的数据是在上一个文章中提到的英国站点数据。其他的数据也是大同小异。
百度网盘: https://pan.baidu.com/s/19vKN2eZZPbOg36YEWts4aQ
密码 4uh7
在导入数据时，不知道为什么如果有标红的这一列，就会提示错误，所以我把这个数据直接删了，这列数据对预测也没有影响
然后通过下面代码就可以得到一个包含，日期、流量的的数据
f = pd.read_csv('..\Desktop\AE86.csv') # 从新设置列标 def set_columns(): columns = [] for i in f.loc[2]: columns.append(i.strip()) return columns f.columns = set_columns() f.drop([0,1,2], inplace = True) # data 包含要操作的列 data = pd.DataFrame() # 想留下哪一行数据，就在这里添加到data中 data['datetime'] = f['Local Date']+' '+f['Local Time'] data['total_flow'] = f['Total Carriageway Flow'] # data['speed'] = f['Speed Value'] 速度本文没用到 data['datetime'] = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c353f9912f864004fecf431f764f33bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8f6a569077890d8fbb63e1d05bd7fe4/" rel="bookmark">
			鸿蒙和骁龙那个,骁龙888&#43;鸿蒙系统的荣耀40系列，还是非常令人期待的！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：骁龙888+鸿蒙系统的荣耀40系列，还是非常令人期待的！
荣耀40系列将会与华为P50系列一样拥有中杯、大杯和超大杯三款产品，中杯荣耀40将搭载骁龙870处理器，大杯和超大杯将搭载骁龙888处理器。在性能方面再也没有短板，配合其它配置的升级，将再度向小米11系列发起挑战！
荣耀40正面将采用定制的双摄像头挖孔，四曲面AMOLED屏幕，支持120Hz以上的屏幕刷新率，标配2K分辨率，屏幕的整体素质和参数还是挺高的，保证绝对的流畅交互感。后置大模块阑珊式摄像头模组，后置5000万像素四摄，整体工艺水准非常高。
荣耀40系列将内置4500mAh电池，支持66W有线+50W无线的快充组合。在价格方面，因目前搭载骁龙888手机的售价持续走低，估计荣耀40会对标小米11，荣耀40预计会在3999元左右，荣耀40Pro会在4999元左右，超大杯荣耀40Pro+会在5999元左右。
荣耀40系列有望搭载华为鸿蒙系统，华为鸿蒙系统是开源开放的，其它厂商要使用是没问题的。凭借荣耀和华为之前的关系，荣耀肯定会成为第一个鼎力支持的友商手机。骁龙888+鸿蒙系统的荣耀40系列，还是非常令人期待的！返回搜狐，查看更多
责任编辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/318aad8b6743917f8104130a7084ea9f/" rel="bookmark">
			基于Android的滑雪场售票公告系统设计与实现,滑雪场雪具租赁管理系统的设计与实现(JSP,Oracle)...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		滑雪场雪具租赁管理系统的设计与实现(JSP,Oracle)(任务书,外文翻译,实习报告,毕业论文16000字,程序代码,Oracle数据库)
通过对功能的描述，本系统为四个部分：滑雪器材信息管理部分，雪具出租管理，雪具归还管理，租用信息管理。
1、滑雪器材信息管理模块
滑雪器材信息管理模块主要对要出租的滑雪器材信息管理。每个模块中都可以对相应的滑雪器材进行查询、添加、删除操作。
2、滑雪器材出租管理模块
这一模块中客户向系统操作人员说出要租用的滑雪器材以及它们的型号和数量，并且将客户自己的姓名和证件号码告诉系统操作人员，系统操作人员进过核实后提交信息，系统会自动将客户的信息和所租用的滑雪器材信息录入数据库中。
3、滑雪器材归还管理模块
在这个过程中系统对数据库中的数据进行条件查询，将所有没有归还滑雪器材的客户以及它们的信息输出在页面上，经过工作人员的核实确认后进行归还操作，并将数据库中的数据进行标记，将客户信息中是否归还中更改为“是”。
4、租用信息管理模块
这个模块中主要存储的是客户的租用信息。所有的客户以及它们所租用的滑雪器材信息都这这一模块中存储，不论是否已经归还。在这一模块中可以对租用信息进行总体查询和删除操作。
开发环境：MyEclipse
Web服务器：Tomcat
数据库：Oracle
目　录
1 前　言 1
1.1 课题的来源及意义 1
1.2 国内外发展状况 1
1.3 本课题研究的目标 3
1.4 本课题研究的内容 3
2 主要用到的技术和工具 5
2.1 JSP技术 5
2.2 MVC思想 5
2.3 Tomcat 7
2.4 Oracle数据库 8
2.5 数据库访问接口---JDBC技术 9
2.6 MyEclipse开发环境 9
3 系统需求分析与总体设计 10
3.1 系统功能需求分析 10
3.2 系统的功能描述 11
3.3 系统流程图 12
3.4 系统的三层架构设计思想 13
4 数据库设计 14
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/318aad8b6743917f8104130a7084ea9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/008c29da40918cd0716ab4b5d81d44d0/" rel="bookmark">
			@ApiOperation用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 作用：注解@ApiOperation是用来构建Api文档
1.引入依赖
在pom文件中引入依赖
&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; 2.用法
使用于在方法上，表示一个http请求的操作@ApiOperation(value = “接口说明”, httpMethod = “接口请求方式”, response =
“接口返回参数类型”, notes = “接口发布说明”；其他参数可参考源码； 3.具体例子
@ApiOperation(value="获取用户列表", notes="") @RequestMapping(value={""}, method=RequestMethod.GET) public List&lt;User&gt; getUserList() { List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values()); return r; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ec78c38889273fe796388707e859b10/" rel="bookmark">
			ValueError: check_hostname requires server_hostname
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 pip install ，安装包的时候出现这个错误
ValueError: check_hostname requires server_hostname
出错原因是使用了VPN，把VPN关掉就好了
reference
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cd56487e295a6bd3e6871c94516d421/" rel="bookmark">
			VLSI数字信号处理系统——第十七章低功耗设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VLSI数字信号处理系统——第十七章低功耗设计 作者：夏风喃喃 参考： VLSI数字信号处理系统:设计与实现 （美）Keshab K.Parhi／著 文章目录 VLSI数字信号处理系统——第十七章低功耗设计一. 引言二. 理论背景（略）三. 按比例缩小与功耗四. 功耗分析4.1 开关活动率4.2 物理电容 五. 功耗降低技术5.1 路径平衡5.2 晶体管和逻辑门尺寸优化（略）5.3 晶体管重排序（略）5.4 用于低功耗的重定时（略）5.5 电压按比例缩小和多电源电压5.6 双/多 V t h V_{th} Vth​5.7 时钟5.8 电路风格（略） 六. 功耗估计方法（略）6.1 基于仿真的方法（略）6.2 非仿真性方法（略） 七. 结论 一. 引言 二. 理论背景（略） 三. 按比例缩小与功耗 四. 功耗分析 数字CMOS电路的功耗可以表示为：
4.1 开关活动率 动态翻转因子：
毛刺会增加动态翻转因子。
4.2 物理电容 动态功耗：
单片集成可以减小负载电容，减小动态功耗。
五. 功耗降低技术 5.1 路径平衡 5.2 晶体管和逻辑门尺寸优化（略） 5.3 晶体管重排序（略） 5.4 用于低功耗的重定时（略） 5.5 电压按比例缩小和多电源电压 5.6 双/多 V t h V_{th} Vth​ 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cd56487e295a6bd3e6871c94516d421/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57dec24389b6b5891d9c99ed7ae64736/" rel="bookmark">
			nod32Android版用户名及密码,ESET NOD32 最新更新有效的升级ID用户名和密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户名： TRIAL-0114095331
密　码： n4pf42bn3t
有效期至：2014-09-04
适用版本：ESS/EAV
用户名： TRIAL-0114095375
密　码： u2sth2v6vf
有效期至：2014-09-04
适用版本：ESS/EAV
用户名： TRIAL-0114095418
密　码： n5aj3cdpac
有效期至：2014-09-04
适用版本：ESS/EAV
用户名： TRIAL-0114095462
密　码： h3decx97d8
有效期至：2014-09-04
适用版本：ESS/EAV
用户名： TRIAL-0114095501
密　码： rj4e8ak68e
有效期至：2014-09-04
适用版本：ESS/EAV
用户名： TRIAL-0114095553
密　码： 63pnh28b4f
有效期至：2014-09-04
适用版本：ESS/EAV
用户名： TRIAL-0114095612
密　码： fnpdtdrt5j
有效期至：2014-09-04
适用版本：ESS/EAV
用户名： TRIAL-0114095653
密　码： naprbss4jp
有效期至：2014-09-04
适用版本：ESS/EAV
用户名： TRIAL-0114097317
密　码： je4er2cvf5
有效期至：2014-09-04
适用版本：ESS/EAV
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3722c16df0977efb1d9dd02d35c6904/" rel="bookmark">
			三星s8android9,三星S8官方国行版安卓9固件rom刷机包：CHC-G9500ZCS3DSD5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三星Galaxy S8手机国行版SM-G9500的最新固件包已经更新发布了，这个最新的固件包也是安9版本的，这个完整版本的系统包是在5月19日更新发布的，具体的版本号是CHC-G9500ZCS3DSD5，也是多件套形式的rom包，需要进行系统升级更新的可以进行下载了。
三星G9500官方国行安卓9刷机包：CHC-G9500ZCS3DSD5
官方发布时间：2019-05-19
Model SM-G9500
Model name Galaxy S8
Country China (Open China) (CHC)
Version Android 9
Changelist 15661224
Build date Fri, 26 Apr 2019 07:29:58 +0000
Security Patch Level 2019-05-01
Product code CHC
PDA G9500ZCS3DSD5
CSC G9500CHC3DSD5
官方rom文件列表：
AP_G9500ZCS3DSD5_CL15661224_QB23418545_REV00_
user_low_ship_MULTI_CERT_meta_OS9.tar.md5
BL_G9500ZCS3DSD5_CL15661224_QB23418545_
REV00_user_low_ship_MULTI_CERT.tar.md5
CP_G9500ZCS3DSD5_CP12548141_CL15661224_QB23418545_
REV00_user_low_ship_MULTI_CERT.tar.md5
CSC_CHC_G9500CHC3DSD5_CL15661224_QB23418545_
REV00_user_low_ship_MULTI_CERT.tar.md5
HOME_CSC_CHC_G9500CHC3DSD5_CL15661224_
QB23418545_REV00_user_low_ship_MULTI_CERT.tar.md5
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5f15cb86f7f9c7a2a3d3e872028c395/" rel="bookmark">
			Python 一个快速视频剪辑编辑神器 — Moviepy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你知道吗，用moviepy一行代码就能够快速剪辑视频中某个区间的片段：
clip = VideoFileClip("videoplayback.mp4").subclip(50,60) 这一段代码，能够在3秒内将videoplayback.mp4的50秒-60秒的视频片段提取出来，非常方便。
不仅如此，moviepy还支持添加字幕、调整音量、片段链接等功能。下面看看详细的操作方法。
1.准备
开始之前，你要确保Python和pip已经成功安装在电脑上，如果没有，可以访问这篇文章：超详细Python安装指南 进行安装。
(可选1) 如果你用Python的目的是数据分析，可以直接安装Anaconda：Python数据分析与挖掘好帮手—Anaconda，它内置了Python和pip.
(可选2) 此外，推荐大家用VSCode编辑器，它有许多的优点：Python 编程的最好搭档—VSCode 详细指南。
请选择以下任一种方式输入命令安装依赖：
1. Windows 环境 打开 Cmd (开始-运行-CMD)。
2. MacOS 环境 打开 Terminal (command+空格输入Terminal)。
3. 如果你用的是 VSCode编辑器 或 Pycharm，可以直接使用界面下方的Terminal.
pip install moviepy 2.视频剪辑
剪辑个视频，多大点事，比起下载PR，用Python 写3行代码，3秒剪辑不香吗？
from moviepy.editor import* # 剪辑50-60秒的音乐 00:00:50 - 00:00:60 video =CompositeVideoClip([VideoFileClip("videoplayback.mp4").subclip(50,60)]) # 写入剪辑完成的音乐 video.write_videofile("done.mp4") 3.视频拼接
“哦？Python？哼，那你肯定很难进行拼接工作吧，PR多方便，拖拽即可完成拼接。”
那你可真是太小看Python了，moviepy几行代码随随便便就能拼接许多片段：
from moviepy.editor importVideoFileClip, concatenate_videoclips clip1 =VideoFileClip("myvideo.mp4") # 结合剪辑，你甚至能够完全自动化剪辑拼接视频的操作 clip2 =VideoFileClip("myvideo2.mp4").subclip(50,60) clip3 =VideoFileClip("myvideo3.mp4") final_clip = concatenate_videoclips([clip1,clip2,clip3]) final_clip.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5f15cb86f7f9c7a2a3d3e872028c395/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a10a38c6b221f5dc17a562f83b723a6f/" rel="bookmark">
			STM32 ADC没有输入电压时，采集结果不为0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 问题概述2. 问题分析2.1 钳位二极管2.2 反向漏电流 3. 复用功能4. 总结 1. 问题概述 硬件焊接完成后测试程序ADC采集功能，先通过接入3.3V来看下。结果发现三个通道可以采集到0V/3.3V，而另外三个通道在没有接入3.3V时，采集结果并不为0，基本在1V以上。
2. 问题分析 6个通道都是ADC1，对于程序来说，不同通道只是设置下通道号而已，按道理不应该出现部分采集正常，部分采集异常呀？
查了不少资料手册和例程，程序配置上没有发现明显问题。翻出了一块旧电路板，正好使用了出现异常的一个ADC通道。将程序直接下载进去，发现可以采集0V/3V。
对比两块电路板的原理图，发现了差异。可以正常采集的三个通道，外部电路均进行了分压：
而出现问题，浮空时仍然采集到电压的三个通道，外部电路均为直接输入：
顺着这个角度查阅了一些资料，的确有人遇到相同的情况，普遍反应是ADC管脚不要悬空使用。
相当于一个悬浮电压，大概为3.3V的一半。
是因为里面多路开关的特性引起的，开关输入引脚悬空就是个亚稳态。
回想一下，确实以前遇到的都是先分压再接到STM32的IO，一直以为是单纯因为参考电压的限制。这次因为采集电压的压值并不高，且电流非常小，担心会采不准，所以选择了直接接到IO上。不过查看了下手册，并没有找到相关的说明：
哪位大佬看到还希望能够详细解释下！
2021.5.31更新
评论区weixin_45464719大佬给出了一种说法：
感觉是单片机内部两个钳位二极管分压引起的，因为IO口悬空，二极管反向漏电流导致IO口电压约等于供电电压的一半！
我的模电书早就卖废纸了，上网重新了解了下钳位二极管和反向漏电流。
2.1 钳位二极管 在端口配置图中，IO管脚有两个二级管：
这是两个钳位二极管，保证IO电压在Vss~VDD之间（忽略二级管的导通电压）。简单理解就是：
当IO大于VDD时，上面的二级管导通，将IO电压限制在VDD；当IO小于Vss时，下面的二级管导通，将IO电压限制在Vss。 再看下百度百科的专业解释：
2.2 反向漏电流 说完了两个二级管的钳位作用，再简单看下反向漏电流。不细说PN结电场怎么反向的了，反正就是二级管会有反向电流。耶稣来了也是！
出现问题的三个通道，IO浮空，VDD和IO之间反向漏电流，IO和Vss之间反向漏电流，最终两个二级管达到一个分压效果，IO上就有一个二分之一的VDD。
3. 复用功能 刚开始怀疑是没有成功配置成ADC功能。如下图：
第二功能有好多个，如何选择成ADC呢？程序上还真没有针对性的做过配置，查了一番：
PA5支持的三种外设（SPI1、DAC、ADC）在同一时刻只能选择一种，选择的方法是开启相应外设的时钟，并使其它外设的时钟保持关闭状态。（如何理解STM32单片机引脚的复用功能？）
但是我的程序一直使能了USART2，又开启了ADC。测试结果是可以正常作为ADC来使用的，并不需要关闭USART2的时钟。可能是因为把管脚配置成了模拟输入？
4. 总结 越来越发现，单片机程序写了不少，往往更关注业务逻辑，一些细节理解还不到位。一直以为悬空会不稳定，只是对电平输入而言，没想到模拟输入同样存在这个问题。
一位同事之前还用悬空的AD通道来做硬件随机数发生器，看来还是自己的经验不足，要继续努力呀
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51601d35362c97390e623ab02f4cc6c5/" rel="bookmark">
			项目经理的优势有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人会问什么样的人适合做项目经理？那么项目经理都具有哪些优势呢：
1、超强的计划能力
项目经理几乎无时无刻都在做计划，所以也就更擅长做计划。
项目管理要抓重点、抓关键，抓大放小、有主有次的处理工作。做任何工作，排工期、开小会、做业务，任何工作都要分解到合适的颗粒度后，一定要排列优先级，重点强调、安排优先级的事件，否则将引发由于无重点带来的无效和浪费。
项目经理的计划往往比其他人做的精确，精准，能很好的规避风险，能顺利达成目的。
并且能够配合好团队成员的工作，将工作分配给项目成员人，并让明确他们的责任。
2、具有大局意识
项目经理就像火车车头，火车去哪里，全靠车头带，所以项目经理在项目中是需要把握项目方向的，明白项目的未来发展和发展趋势。
项目经理从接手项目开始，就需要发挥自己出色的大局观，从接受项目任务开始，到项目结束。项目经理应该从开始就能看到结尾，从表面就能看到深层，能洞察人心，掌握项目的发展方向，做到项目可控，目标一致。
3、沟通能力特别强
项目管理无论是内部还是跨部门项目最重要的工作是沟通协调。而沟通协调能力也是项目经理基本要求之一，项目经理在工作中要协调好各方面的利益，推进项目进度。
项目经理在组织工作中，大部分时间是与人沟通。他要不断地将他的想法解释给项目成员，他必须要和客户及项目成员达成共识。因此，项目经理要有很好的沟通能力，对管理思想有清晰的认识，有非常强的分析能力。
4、具有更大的灵活性
项目经理从一开始就要明确最终目的。实现目标的手段会发生变化，交付的功能可能会在过程中重新安排优先次序，这需要项目经理具备更大的灵活性和反应能力。项目经理将从纯粹的理性、分析和预测的思维方式转变为一种更应急、更直观、更适应性的思维方式。
5、总结汇报能力
项目经理能够回顾项目初期的规划是否合理、能够分析项目过程中是否存在问题、能够知道当时的解决方案是否是最优等等。通过抓住听者的点，知道他们最在意的是什么，然后汇报项目情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18b74a602ebf9398249f75aa816eb692/" rel="bookmark">
			mysql数据库，字符串类型使用＜、＞判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 字符串比较字符串转数字比较方案1方案2 字符串比较 在mysql数据库中如果使用字符串进行比较的话，默认是从高位到低位进行一一比较的，举个例子
按照数字来讲，18肯定大于5，但是在字符串比较却返回了false。也就是上面所说的从高位向低位进行比较的，1 &gt; 5 返回false。
像这种情况是两位与三位比较，前两位相同，存在第三位的或更多的较大
字符串转数字比较 方案1 字符串后面 +0
方案2 使用函数CAST
参考文档
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f22036bf902187662c0cfcb7c9ea80a8/" rel="bookmark">
			android&#43;ndk&#43;libevent,android ndk 编译 libevent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 下载 libevent 2.1.8 版本
2. 先在 win10 上用 wsl ubuntu 编译 libevent
3. 在 wsl 上，准备需要的编译环境sudo apt-get install automake
sudo apt-get install autoconf
sudo apt-get install libtool
4. 在livevent目录下运行 autogen.sh./autogen.sh
autoreconf: Entering directory `.'
autoreconf: configure.ac: not using Gettext
autoreconf: running: aclocal --force -I m4
autoreconf: configure.ac: tracing
autoreconf: running: libtoolize --copy --force
libtoolize: putting auxiliary files in '.'.
libtoolize: copying file './ltmain.sh'
libtoolize: putting macros in AC_CONFIG_MACRO_DIRS, 'm4'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f22036bf902187662c0cfcb7c9ea80a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/426c8fc6636021f153b9102d987963c9/" rel="bookmark">
			【python】去除图片高光
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考:
1.https://github.com/MarcioCerqueira/RealTimeSpecularHighlightRemoval 论文：Real-Time High-Quality Specular Highlight Removal using Efficient Pixel Clustering
2.图像增强：opencv去除图片的高光 import cv2 import os,shutil #找亮光位置 def create_mask(imgpath): image = cv2.imread(imgpath, cv2.IMREAD_GRAYSCALE) _, mask = cv2.threshold(image, 200, 255, cv2.THRESH_BINARY) return mask #修复图片 def xiufu(imgpath,maskpath): src_ = cv2.imread(imgpath) mask = cv2.imread(maskpath, cv2.IMREAD_GRAYSCALE) #缩放因子(fx,fy) res_ = cv2.resize(src_,None,fx=0.6, fy=0.6, interpolation = cv2.INTER_CUBIC) mask = cv2.resize(mask,None,fx=0.6, fy=0.6, interpolation = cv2.INTER_CUBIC) dst = cv2.inpaint(res_, mask, 10, cv2.INPAINT_TELEA) return dst if __name__=='__main__': rootpath = r"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/426c8fc6636021f153b9102d987963c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/889c74b523fa85ebab059cb846eaa226/" rel="bookmark">
			mediastreamer2 android,一起启动Linphone MediaStreamer2音频和视频流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仅使用mediastreamer2库我可以使用远程ip和端口开始音频调用，并调用audiostream.c各自的方法 .
然后我也需要开始视频通话 . 所以初始化videostream.c并使用其各自的方法并为其提供表面以呈现远程和本地相机馈送 . 我能够通过远程端口和ip成功启动视频流 .
但问题是我一起开始两个流 . 声音停止和视频流也停止 . 只有本地相机输入工作 .
所以我有一个神奇的方法，为我做这一切 . 如果我评论它的视频部分 . 音频通话工作正常，如果评论音频部分，视频通话工作正常 . 但是当我开始时 . 没有声音没有流媒体 . 但是我们成功启动了AudioStream并且VideoStream成功启动了日志 .
拥有linphone经验的人可以帮助确定正确的方法顺序吗？或者我们做错了什么这是我们的方法 .
JNIEXPORT jint JNICALL Java_com_myapp_services_LinPhoneMSEngine_LinPhoneMSVE_1AudioStreamStartFull
(JNIEnv *env, jclass self, jstring remote_ip, jint remote_port, jint localport, jint payloadindex, jboolean isLowEnd)
{
int bRetVal = 0;
MSVideoSize size = {320, 240};
char rtcp_tool[128]={0};
int ret;
//jboolean copy;
char cname[128]={0};
const char *cremote_ip;
ortp_warning("Audio Stream Start Full"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/889c74b523fa85ebab059cb846eaa226/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/559f8a2fcf8f72e31a09fc7ba8ac8c25/" rel="bookmark">
			npm install的几种方式区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm install moduleName # 安装模块到项目目录下 npm install -g moduleName # -g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置。 npm install --save moduleName # --save 的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖。 npm install --save-dev moduleName # --save-dev 的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖。 npm install X -g
安装模块到全局，不会在项目node_modules目录中保存模块包。不会将模块依赖写入devDependencies或dependencies 节点。运行 npm install 初始化项目时不会下载模块。
npm install X
*会把X包安装到node_modules目录中
*不会修改package.json
*之后运行npm install命令时，不会自动安装X
npm install X --save会把X包安装到node_modules目录中会在package.json的dependencies属性下添加X之后运行npm install命令时，会自动安装X到node_modules目录中之后运行npm install --production或者注明NODE_ENV变量值为production时，会自动安装msbuild到node_modules目录中,即是在线上环境运行时会将包安装
npm install X –save-dev会把X包安装到node_modules目录中会在package.json的devDependencies属性下添加X之后运行npm install命令时，会自动安装X到node_modules目录中之后运行npm install –production或者注明NODE_ENV变量值为production时，不会自动安装X到node_modules目录中
使用原则:
devDependencies 节点下的模块是我们在开发时需要用的，比如项目中使用的 gulp ，压缩css、js的模块。这些模块在我们的项目部署后是不需要的，所以我们可以使用–save-dev的形式安装。像 express 这些模块是项目运行必备的，应该安装在 dependencies 节点下，所以我们应该使用–save的形式安装。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/559f8a2fcf8f72e31a09fc7ba8ac8c25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39a3c0e6772c0d9e0398cae4ec36bcbd/" rel="bookmark">
			三星s8 android9.0官方rom,三星S8&#43;港版安卓9官方固件rom刷机包：TGY-G9550ZHU3DSD3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三星Galaxy S8+港版手机手机是这个SM-G9550，在4月25日官方发布了用于港版手机的最新的系统rom线刷包，也就是官方的安卓9的系统rom固件包TGY-G9550ZHU3DSD3，也是多件套的形式的完整系统包，可以用来进行系统的升级更新，需要下载到电脑上进行解压，采用三星专用的odin工具来刷入。
三星G9550官方9.0香港版固件rom包：TGY-G9550ZHU3DSD3
官方发布时间：201-04-25
Model SM-G9550
Model name Galaxy S8+
Country Hong Kong
Version Android 9
Changelist 15661835
Build date Wed, 17 Apr 2019 10:27:38 +0000
Security Patch Level 2019-04-01
Product code TGY
PDA G9550ZHU3DSD3
CSC G9550ZZH3DSD3
官方rom包文件列表：
AP_G9550ZHU3DSD3_CL15661835_QB23259468_REV00_
user_low_ship_MULTI_CERT_meta_OS9.tar.md5
BL_G9550ZHU3DSD3_CL15661835_QB23259468_REV00_
user_low_ship_MULTI_CERT.tar.md5
CP_G9550ZHU3DSD3_CP12459831_CL15661835_QB23242181_
REV00_user_low_ship_MULTI_CERT.tar.md5
CSC_ZZH_G9550ZZH3DSD3_CL15661835_QB23259468_
REV00_user_low_ship_MULTI_CERT.tar.md5
HOME_CSC_ZZH_G9550ZZH3DSD3_CL15661835_QB23259468_
REV00_user_low_ship_MULTI_CERT.tar.md5
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7639372b0e93fdaac75311918cc0f864/" rel="bookmark">
			Collection集合总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArrayList: 底层数组，可重复，有序，可存多个null,查快。快速随机访问标志--实现RandomAccess接口，序列化，克隆，初始空数组，容量10，grow方法 每次1.5倍。
浅拷贝：基本数据类型值传递；引用类型，只存地址，在改动原始对象时会同时改变克隆对象的值 需要实现 Cloneable 接口，并覆写 clone() 方法。
深拷贝：基本数据类型值传递；引用类型，创建新对象，并把内容复制过去。
LinkedList：底层双向链表，可重复，有序，可存多个null，插入，删除。
HashMap：实现Map接口， 1.8之前数组+链表。1.8后数组+链表+红黑树，当链表长度阙值达到8时，将转化为红黑树，（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组 扩容，而不是转换为红黑树），红黑树降低时间复杂度到logN
key只可以有一个null，value多个null。put时可以put多个key为null的，不报错，以最后一个为准，存value。
扩容：初始16；扩容为原来的2倍；如果给定初始容量，会扩容到2的幂次方大小
使用Key计算hashcode
多线程时，会造成数据丢失。
ConcurrentHashMap: 线程安全，底层实现:
1.7之前采用分段segment数组+HashEntry数组+链表实现， 分段锁每一段一个锁，一段下包含一个Segment数组，一个segment包含一个HashEntry数组。每个HashEntry是一个链表结构的元素。将要对HashEntry数组修改时，必须首先获得对应的Segment的锁。
1.8开始 node数组+链表/红黑树。取消了分段锁，采用CAS算法和synchronized来保证并发安全。
synchronized只锁定当前链表或红黑树的首节点。
HashTable：线程安全（synchronized修饰的方法），效率低，
扩容：初始11，扩容2n+1；如果给定初始容量，会按照初始容量。
不能有 NULLKey NULL VALUE，会报java.lang.NullPointerException。
TreeMap：红黑树，有序。要实现Comparator接口。
Vector：list古老实现类，线程安全， 底层数组
HashSet：实现Set接口，底层是HashMap实现，add()添加元素，使用对象计算hashcode。不可重复。
在添加对象时，先用hashcode比较，如果存在相同用equals()比较。
两个对象可能hashcode相同，但是也不一定相等。
只可以存一个NULL，不可重复。add相同的也会只存一个。
LinkedHashSet：是HashSet的子类，可以按照添加顺序遍历。通过LinkedHashMap实现。
TreeSet：底层也是红黑树，可以按照添加顺序遍历，并可以自然排序和定制排序。有序，唯一。重写new Comparator(){ public int compare(Object o1,Object o2){ return o1.compareTo(o2); }} 进行排序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad567bd0900e84a90ea62ec755dcdc4c/" rel="bookmark">
			甲骨文提供非常良心的永久免费云主机空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		永远免费的云服务，您可以无限期使用的服务。
两个AMD Compute VM，2个基于AMD的计算虚拟机，每个虚拟机具有1/8 OCPU和1 GB内存。4个基于Arm的Ampere A1内核，24GB内存，可用作一个VM或最多4个VM。2个块卷存储，总计200 GB，10 GB对象存储用于对象和10 GB存档存储；两个具有功能强大的工具（例如Oracle Application Express（APEX）和Oracle SQL Developer）的Oracle自治数据库，每个20 GB。负载均衡器和数据出口；监控和通知 翻译成大白话，免费云计算套餐包括：
4个CPU核+24G内存+40G数据库容量+20G磁盘存储
可以应付中小型应用了，主机在国外。
https://www.oracle.com/cloud/free/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2e54e64450144c017d5f5602d35b625/" rel="bookmark">
			熵、交叉熵、条件熵、互信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 概念、公式熵交叉熵条件熵互信息 2. softmax和交叉熵3. 互信息和交叉熵 1. 概念、公式 熵 随机事件X有n种可能发生的情况，每种情况发生的概率为 p i p_i pi​
H ( X ) = − ∑ i = 1 n p i l o g ( p i ) H(X)=-\sum_{i=1}^{n} p_ilog(p_i) H(X)=−i=1∑n​pi​log(pi​)
交叉熵 度量两个概率分布p、q之间的差异， y i y_i yi​服从q分布， p i p_i pi​服从p分布。对于单个样本来说：
C i = − ∑ j = 1 C y j l o g ( p j ) C_i = -\sum_{j=1}^{C} y_j log(p_j) Ci​=−j=1∑C​yj​log(pj​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2e54e64450144c017d5f5602d35b625/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/945b1ac786b3b0b92766d614e289288b/" rel="bookmark">
			为什么项目需要执行管理支持？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对项目成功的承诺和对失败的恐惧将使项目经理及其团队保持警惕。无论使用哪种方法以及在哪里进行项目工作，最终结果都将保留悬念，并使我们始终专注于此。
在所有类型的报告中，成功的关键因素之一就是执行管理支持。本文将讲解有关项目为何需要执行管理支持的想法，以及有关项目经理如何确保其支持的一些技巧。
为什么项目需要执行管理支持？
1、明确战略目标
组织/战略目标可以是增加市场份额，最大化利润，设定新趋势，利用技术取得业务成功或创造创新产品。简而言之，执行管理层有助于以清晰的方式确定和阐明战略目标和期望，从而使项目按照战略目标执行和交付，并服务于整体业务目的。
2、项目资金
执行管理支持的第二个最关键的原因是确保适当的项目资金。资金筹措机制是根据计划/项目的性质、成本和总体影响而制定的。
3、确保项目资源
我们需要执行管理支持来确保项目资源的有效和高效地执行； 在功能组织和矩阵组织中，它们的作用变得至关重要。 执行管理人员有权影响职能团队并为项目分配合适的人员。
4、项目治理
执行管理支持对于项目治理至关重要。 通常是项目发起人确定组织策略与项目目标之间的一致性或潜在冲突，然后与项目经理协调解决这些问题。 如果尽早发现并解决此类冲突，将对项目有帮助，以确保按时，按成本和按时交付项目。
5、项目支持
需要执行管理支持以支持项目并从所有利益相关者那里创建高层组织支持。这会对产品/服务的所有权产生积极影响，并促进验收。
6、管理风险
项目经理管理项目级别的风险，并在团队的总体共识下制定缓解策略。从识别到缓解的过程中，超出项目经理范围的风险需要项目发起人的关注。
7、做出决策
在项目中，关键决策，诸如允许进度超支、批准资金分配、授权范围变更等，始终依赖于投入以及执行发起人和相关利益相关者的权限。项目发起人的关键角色之一是制定决策并确保项目向前发展（日常运营决策仍属于项目经理的职责范围）。
通过了解为什么要获得项目成功就需要执行管理支持，确保项目经理在整个项目生命周期中获得支持就成为项目经理的首要责任。项目经理可以做什么以确保获得所需的支持？这取决于他们的技能、组织环境因素以及其他可能直接或间接影响项目结果的因素。
如何维持项目执行管理支持？
执行发起人通常被任命为项目计划的负责人，并监督从开始到结束的整个项目生命周期。利用好技术，可以更有效帮助执行发起人消除障碍，并确保利益相关者保持一致，以便项目实现其目标。
新一代项目管理软件8Manage PM实时审计追踪项目全过程，有助精准作出项目决策，其数据信息透明性和可靠性是维持项目执行的关键，让项目管理更轻松。
计划与执行合二为一
在8Manage PM，计划与执行处于同步状态。当前的计划实时反映项目成员最新的可交付成果及其完成情况。你可以追溯项目计划的某条基线，或之前的某个快照版本信息，但你所使用与共享的当前计划都是唯一的。在任何时间，都不会因计划与实际不符而被愚弄。团队成员可以实时共享最新的项目进展情况。
责任划分与工作交付清楚明确
8Manage 帮助您将项目工作进行自然分解，并能强化执行适当的责任与承诺。当有人更改其承诺时，系统会通知其他相关人员。对于可能无法完成的承诺，它会在项目的概览页面发出预警。
系统也提供以下方式优化结果管理：
a）设置评审与验收的规则
b）对评审及验收结果进行实时的提醒
c）实时的概览及周期性报告的邮件通知
使用以上功能，所有利害关系者都可清晰地了解责任与结果。
资源与依赖清晰明确
8Manage 让所有资源需求与依赖关系一目了然，帮助项目团队有条理地管理它们：
a）使资源与可交付成果的依赖尽可能明确
b）自动跟踪间接依赖
c）自动监测不恰当的依赖并在需要时警告相关人员
问题与风险自动跟踪与上报
问题与风险的管理本身就是复杂的。8Manage PM项目管理软件能够帮助您识别风险的概率、风险处理的优先级别及其处理方法。并且，它还能实时汇总所有相关的问题与风险及其解决方法，从而统一有序地管理所有问题与风险。
作为项目经理，获得执行管理支持是其工作。专注于过去的经验、同行反馈、技术辅助和其他项目管理案例，我们可以制定最佳实践并将其投入使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6d3e80732d34450a759f11633a075a7/" rel="bookmark">
			多种隐藏滚动条但是依然可以滚动实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求描述： 经常会遇到，不显示滚动条，但是鼠标滚轮上去可以滚动，或是在移动端，不显示滚动条，手指可以滑动内容。
方法一： iscroll插件
方法二：
通过固定宽度样式将滚动条给隐藏起来。chrom 和ie 正常使用。
&lt;div class="outer-container"&gt; &lt;div class="inner-container"&gt; ...... &lt;/div&gt; &lt;/div&gt; // css .outer-container{ width: 360px; height: 200px; position: relative; overflow: hidden; } .inner-container{ position: absolute; left: 0; top: 0; right: -17px; bottom: 0; overflow-x: hidden; overflow-y: scroll; } 方法三：使用三个容器包裹，不需要写死滚动条宽度
&lt;div class="outer-container"&gt; &lt;div class="inner-container"&gt; &lt;div class="content"&gt; ...... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; .element, .outer-container { width: 200px; height: 200px; } .outer-container { border: 5px solid purple; position: relative; overflow: hidden; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6d3e80732d34450a759f11633a075a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dfb7283598510073b7de8b76a4230ea/" rel="bookmark">
			sqlite删除一条记录android,android  – 在SQLite表中检索最后一条记录(再次)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我先做了几次搜索,但仍然有一个问题.
我发现最好的答案是this SO答案.总结如下：
SELECT * FROM TABLE WHERE ID =(SELECT MAX(ID)FROM TABLE);
我想知道的是,以下方法是否也能正常工作(因为我懒得改变它,我碰巧喜欢它).
SELECT * FROM TABLE ORDER BY ID DESC LIMIT 1
If no ROWID is specified on the insert, or if the specified ROWID has a value of NULL, then an appropriate ROWID is created automatically. The usual algorithm is to give the newly created row a ROWID that is one larger than the largest ROWID in the table prior to the insert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dfb7283598510073b7de8b76a4230ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7e92d6451f9e6fba9ca8ea0cfe92cc8/" rel="bookmark">
			android蓝牙包,Android Bluetooth蓝牙技术初体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：Bluetooth包简介
Android平台提供了一个android.bluetooth的包，里面实现蓝牙设备之间通信的蓝牙API。总共有8个类，常用的四个类如下:
BluetoothAdapter类
代表了一个本地的蓝牙适配器。它是所有蓝牙交互的入口点。利用它你可以发现其他蓝牙设备，查询绑定了的设备，使用已知的MAC地址实例化一个蓝牙设备和建立一个BluetoothServerSocket(作为服务器端)来监听来自其他设备的连接。
BluetoothDevice类
代表了一个远端的蓝牙设备，使用它请求远端蓝牙设备连接或者获取远端蓝牙设备的名称、地址、种类和绑定状态(其信息是封装在BluetoothSocket中)。
BluetoothSocket类
代表了一个蓝牙套接字的接口(类似于TCP中的套接字)，它是应用程序通过输入、输出流与其他蓝牙设备通信的连接点。
BlueboothServerSocket类
代表打开服务连接来监听可能到来的连接请求(属于server端)，为了连接两个蓝牙设备必须有一个设备作为服务器打开一个服务套接字。当远端设备发起连接连接请求的时候，并且已经连接到了的时候，BlueboothServerSocket类将会返回一个BluetoothSocket。
二：常用类的使用
BluetoothAdapter：蓝牙适配器
cancelDiscovery()取消探索，当我们正在搜索设备的时候调用这个方法将不再继续搜索
disable()关闭蓝牙
enable()打开蓝牙，这个方法打开蓝牙不会弹出提示，更多的时候我们需要问下用户是否打开，以下两行代码同样是打开蓝牙，但会提示用户：
Intentenabler = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
startActivity(enabler);
getAddress()获取本地蓝牙地址
getDefaultAdapter()获取默认BluetoothAdapter，实际上，也只有这一种方法获取BluetoothAdapter
getName()获取本地蓝牙名称
getRemoteDevice(String address)根据蓝牙地址获取远程蓝牙设备
getState()获取本地蓝牙适配器当前状态
isDiscovering()判断当前是否正在查找设备，是则返回true
isEnabled()判断蓝牙是否打开，已打开返回true，否则返回false
listenUsingRfcommWithServiceRecord(String name,UUID uuid)根据名称，UUID创建并返回BluetoothServerSocket，这是创建BluetoothSocket服务器端的第一步
startDiscovery()开始搜索，这是搜索的第一步
BluetoothDevice：远程蓝牙设备
createRfcommSocketToServiceRecord(UUIDuuid)根据UUID创建并返回一个BluetoothSocket，这个方法也是我们获取BluetoothDevice
的目的——创建BluetoothSocket
这个类其他的方法，如getAddress()、getName()等，同BluetoothAdapter。
BluetoothSocket：客户端
//这个类一共有6个方法
close()关闭
connect()连接
isConnected()判断是否连接
getInptuStream()获取输入流
getOutputStream()获取输出流
getRemoteDevice()获取BluetoothSocket指定连接的远程蓝牙设备
BluetoothServerSocket：服务端
//这个类一共有4个方法
accept()
accept(int timeout)
close()关闭
getChannel()返回这个套接字绑定的通道
两者的区别在于后面的方法指定了过时时间，需要注意的是，执行这两个方法的时候，直到接收到了客户端的请求(或是过期之后)，都会阻塞线程，应该放在新线程里运行。还有一点需要注意的是，这两个方法都返回一个BluetoothSocket，最后的连接也是服务器端与客户端的两个BluetoothSocket的连接
三：数据传输
蓝牙数据传输——服务器端
1、获得BluetoothAdapter。
2、通过BluetoothAdapter.listenUsingRfcommWithServiceRecord(name,UUID uuid)方法创建BluetoothServerSocket对象。
3、通过luetoothServerSocket.accept()方法返回一个BluetoothSocket对象。由于该方法处于阻塞状态，需要开启线程来处理。
4、通过BluetoothSocket.getInputStream()和BluetoothSocket.getOutputStream()方法获得读写数据的InputStream和OutputStream对象。
5、通过InputStream.read()方法来读数据。通过OutputStream.write()方法来写数据。
蓝牙数据传输——客户端
1、获得BluetoothAdapter。
2、通过BluetoothAdapter.getRemoteDevice(String address)获得指定地址的BluetoothDevice对象。
3、通过BluetoothDevice.createRfcommSocketToServiceRecord (UUID uuid)方法创建BluetoothSocket对象。
4、通过BluetoothSocket.connect()方法来连接蓝牙设备。
5、通过BluetoothSocket.getInputStream()和BluetoothSocket.getOutputStream()方法获得读写数据的InputStream和OutputStream对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7e92d6451f9e6fba9ca8ea0cfe92cc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc8700ae42be8023241ad6eae4c8455c/" rel="bookmark">
			android 检查是否安装成功,android开发中,判断是否安装了qq
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android系统中，判断应用有无安装有两种方式：
1.根据包名判断,以下为判断代码：
public boolean checkApkExist(Context context, String packageName) {
if (packageName == null || “”.equals(packageName))
return false;
try {
ApplicationInfo info = context.getPackageManager()
.getApplicationInfo(packageName,
PackageManager.GET_UNINSTALLED_PACKAGES);
return true;
} catch (NameNotFoundException e) {
return false;
}
}
2. 根据Intent判断，以下为判断代码：
public boolean checkApkExist(Context context, Intent intent) {
List list = context.getPackageManager().queryIntentActivities(intent, 0);
if(list.size() &gt; 0){
return true;
}
return false;
}
public boolean checkApkExist(Context context, String packageName) {
if (packageName == null || “”.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc8700ae42be8023241ad6eae4c8455c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cd7117d96d7414f39859cc754f9b1bf/" rel="bookmark">
			android view禁止右滑,ViewPager 禁止左右滑动完美解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package cn.fht.widget;
import android.content.Context;
import android.support.v4.view.ViewPager;
import android.util.AttributeSet;
import android.view.MotionEvent;
/**
* 禁止左右滑动的viewpager
*
* @author Administrator
*
*/
public class ProhibitScrollViewPager extends ViewPager {
public ProhibitScrollViewPager(Context context) {
super(context);
}
public ProhibitScrollViewPager(Context context, AttributeSet attrs) {
super(context, attrs);
}
@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {
// TODO Auto-generated method stub
return false;
}
/**
* viewpage的onTouchEvent屏蔽
*/
@Override
public boolean onTouchEvent(MotionEvent arg0) {
return false;
}
}
android:id="@+id/main_pager"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cd7117d96d7414f39859cc754f9b1bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0c573ac862727d9003c777a6ebaeed5/" rel="bookmark">
			android layout不显示,Android学习---解决Android Graphical Layout 界面效果不显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网上download别人的例子，学习。有时会遇上类似下面这些情况。
[2012-02-27 23:16:18 - focus_demo] Unable to resolve target
'android-4'
这是因为sdk与你当前eclipse中android默认的sdk版本不相同。右键工程，选择Properties，选择正确的Target。如，我选择Android
2.3.3
或者：
修改工程目录下的default.properties文件里的内容target=android-7改成target=android-12(或者其他版本)就可以了，最好用txt打开，然后修改之后保存，运行就可以了。
如果遇到R.java不能生成，或有错时，右击工程，--&gt; android tools
-&gt; fix project
properties，eclipse会删除旧的文件，重新生成一遍。如果，还是有错，很可能是其他问题引起的。
还遇上过这样的情况，
打开layout文件下的xml文件时，Graphical
Layout居然不显示可视效果。
我也试过了，网上说的，右键点击所要打开的xml文件，弹出对话框open
with，选择Android Layout editor，你就能看见你的Graphical
Layout了。但我的本来就是用Android Layout editor打开的。
后来有人说：解决的办法是删除SDK Location
路径下的temps文件夹，这是SDK升级过程中并没把遗留下来的文件删掉，temps下的文件对你无用，放心的删。
删完后，我重启一下eclipse，再点击打开，果然又显示出来了。
希望对你有帮助，共同进步！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40b8a397c807e94f6547ffa3bcd4185a/" rel="bookmark">
			android 编程 闹钟,Android编程使用AlarmManager设置闹钟的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文实例讲述了Android编程使用AlarmManager设置闹钟的方法。分享给大家供大家参考，具体如下：
package com.Aina.Android;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.widget.Toast;
/**
* com.Aina.Android
* Pro_AlarmManager
* @author Aina.huang E-mail: 674023920@qq.com
* @version 创建时间：2010 Jul 8, 2010 3:03:19 PM
* 类说明
*/
public class AlamrReceiver extends BroadcastReceiver {
@Override
public void onReceive(Context context, Intent intent) {
// TODO Auto-generated method stub
Toast.makeText(context, "闹钟时间到", Toast.LENGTH_LONG).show();
}
}
package com.Aina.Android;
import java.util.Calendar;
import android.app.Activity;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.app.TimePickerDialog;
import android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40b8a397c807e94f6547ffa3bcd4185a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb3d3e266f2bd5276460bec109b27c37/" rel="bookmark">
			android9第三方ROM,一加7 Pro官方安卓9.0稳定版全量固件rom刷机包第3版：21.H.09
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一加OnePlus7 Pro在今年更新发布了第3版的安卓9.0的稳定版的系统升级包，也就是全量版系统包，系统包大小是2.60 GB，这一次的系统更新的内容还挺多的，系统方面主要是优化屏幕灵敏度，优化双击亮屏，优化第三方APP语音通话质量，解决息屏显示不灵敏的问题，提升稳定性及修复已知问题，在相机方面优化画面整体层次感及颜色表现，优化三摄色彩白平衡一致性，优化对焦准确度与稳定性，修复部分暗光场景拍照偏绿的问题，优化超广角画面层次感及色彩饱和度，优化超广角夜间拍摄的清晰度及降噪表现，优化夜景模式画面清晰度及颜色表现，优化夜景模式暗光场景的亮度及清晰度。
系统包名称：
OnePlus7ProHydrogen_21.H.09_OTA_009_all_
1906032356_e67631ca5e8a4cfb
更新版本：第3版 Android 9.0稳定版
更新时间：2019-6-11
系统包大小：2.60 GB
md5：df32ac86dc446e7c1af8d9f377e9a6a8
更新内容：
系统
优化屏幕灵敏度
优化双击亮屏
优化第三方APP语音通话质量
解决息屏显示不灵敏的问题
提升稳定性及修复已知问题
相机
优化画面整体层次感及颜色表现
优化三摄色彩白平衡一致性
优化对焦准确度与稳定性
修复部分暗光场景拍照偏绿的问题
修复部分 HDR 场景噪点过多的问题
优化超广角画面层次感及色彩饱和度
优化超广角夜间拍摄的清晰度及降噪表现
优化长焦清晰度及降噪表现
优化夜景模式画面清晰度及颜色表现
优化夜景模式暗光场景的亮度及清晰度
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d9295b264b00a6cfe5bad72359038e5/" rel="bookmark">
			思科模拟器(SDN控制器使用教程一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Packet tracer 8.0.0中SDN控制器使用教程(一) ​ 思科模拟器Packet tracer 8.0.0于2021年/02/24发布，在其中新增加的功能，SDN网络控制器，以及可以使用我们的电脑中的工具访问API编程功能。如使用(VScode，curl，和Python requests)。
官网原文：
Packet Tracer 8.0.0 main new features are : A new SDN network controller device API programming capabilities which can be accessed from the host PC using real world programming tools (curl, Python 3, VS code, ....). New user interface appearance New Packet Tracer splash screen 一个新的网络控制器设备。
API编程功能可以使用模拟器外的主机进行访问。
新的用户外观。
新的数据包的显示。
一、新的硬件-SDN控制器 ​ 在思科模拟器里面的SDN控制器类似于现在生活中SDN控制器。如思科的Cisco DNA Center and APIC-EM。在模拟器中具体的位置如下：
​ SDN网络控制器可以使用Web页面来进行配置和管理。还可以使用其API管理的网络控制器提供了一个集中式仪表板，以查看网络状态，允许网络管理员快速识别和排除问题，并立即将配置更改更改为所有受管设备。
​ 可以从主机上运行的Real -World应用程序访问网络控制器，如Web浏览器，vscode，python，curl，postman，执行网络自动化脚本。 必须在Cisco Packet tracer 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d9295b264b00a6cfe5bad72359038e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d81ec402fb8e1abd0f038973c151d9d1/" rel="bookmark">
			【Web前端HTML5&amp;CSS3】09-浮动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记来源：尚硅谷Web前端HTML5&amp;CSS3初学者零基础入门全套完整版
文章目录 浮动1. 浮动的简介2. 浮动的特点3. 脱离文档流的特点4. 简单布局5. 练习：w3school导航条 浮动 1. 浮动的简介 通过浮动可以使一个元素向其父元素的左侧或右侧移动
使用float属性来设置于元素的浮动
none 默认值，元素不浮动left 元素向左浮动right 元素向右浮动 注意
元素设置浮动以后，水平布局的等式便不需要强制成立元素设置浮动以后，会完全从文档流中脱离，不再占用文档流的位置，所以元素下边的还在文档流中的元素会自动向上移动 2. 浮动的特点 浮动元素会完全脱离文档流，不再占据文档流中的位置
设置浮动以后，元素会向父元素的左侧或右侧移动
浮动元素默认不会从父元素中移出
&lt;style&gt; .box1 { width: 100px; height: 100px; background-color: orange; float: left; } .box2 { width: 200px; height: 200px; background-color: red; } &lt;/style&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt; 浮动元素向左或向右移动时，不会超过前边的浮动元素（先来后到的顺序）
&lt;style&gt; .box1 { width: 200px; height: 200px; background-color: orange; float: left; } .box2 { width: 200px; height: 200px; background-color: red; float: left; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d81ec402fb8e1abd0f038973c151d9d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f7edacd9bfaa508b7cc4af20a721dd9/" rel="bookmark">
			android4.0 bluez版本,Android.bluetooth.IBluetooth.createBond()在4.2.1中找不到,但在较早的操作系统版本中可用...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我有一些代码可以通过调用createBond()自动与蓝牙设备配对,注册一个用于
android.bluetooth.device.action.PAIRING_REQUEST的广播接收器,然后手动输入PIN码进行配对.
这已经很好,所有测试的设备到目前为止,Andoid 4.0,但今天我尝试这个在我的Nexus 7与Android 4.2.1并得到以下错误：
java.lang.noSuchMethodException：android.bluetooth.IBluetooth.createBond
他们实际上从库中删除了这个功能吗？
UPDATE
实际发生的是IBluetooth接口对象,我用来调用createBond没有被初始化.在以下代码中,尝试获取名为BTBinder的IBinder的行将在此过程失败导致BTInterface在结尾设置为null时返回null.所以现在我的问题是为什么在我的Nexus 7与Android 4.2.1做的调用来获取绑定返回null,但正确的5其他设备我测试过？
public static IBluetooth getBluetoothInterface()
{
//Gets a bluetooth interface from private Android system API
IBluetooth BTInterface = null;
try
{
Class&gt; ServiceManager = Class.forName("android.os.ServiceManager");
Method getService = ServiceManager.getDeclaredMethod("getService",String.class);
IBinder BTBinder = (IBinder) getService.invoke(null,"bluetooth");
Class&gt; IBluetooth = Class.forName("android.bluetooth.IBluetooth");
Class&gt;[] IBluetoothClasses = IBluetooth.getDeclaredClasses();
Class&gt; IBluetoothClass0 = IBluetoothClasses[0];
Method asInterface = IBluetoothClass0.getDeclaredMethod("asInterface",IBinder.class);
asInterface.setAccessible(true);
BTInterface = (IBluetooth) asInterface.invoke(null,BTBinder);
}
catch (Exception e)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f7edacd9bfaa508b7cc4af20a721dd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4b24bde0bb9a4dded470dead34a91c3/" rel="bookmark">
			打印机 HP LaserJet 1018安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：之前安装的打印机今天突然不能使用。
询问客服后让卸载后重装打印机。本着遵循多喝热水，喜欢就买，不行就分，重启试试的四大简单粗暴法则，卸载并安装。
第一步 设备管理 -- win10 可直接win键，搜‘打印机’， --- 选中原有打印机 -- 右键 --“ 删除设备”。
第二部 添加打印机 --- “添加或扫描打印机”--- “我需要的打印机不在列表中 ”--- 在弹出的窗口中选“通过手动设置添加本地或网络打印机”---“选择打印机端口（USBXXXXX）”
----在弹出窗口中 选择 具体厂商 “hp” --- 具体型号 “HP LaserJet 1018”。再点下一步 就 ok了。
第三步 测试 设为默认打印机 ，打印一个文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a1a75590d23b5a1600f8b5b7087885e/" rel="bookmark">
			leetcode_692_前k个高频单词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前K个高频单词 中等
给一非空的单词列表，返回前 k 个出现次数最多的单词。
返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。
示例 1：
输入: ["i", "love", "leetcode", "i", "love", "coding"], k = 2 输出: ["i", "love"] 解析: "i" 和 "love" 为出现次数最多的两个单词，均为2次。 注意，按字母顺序 "i" 在 "love" 之前。 示例 2：
输入: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4 输出: ["the", "is", "sunny", "day"] 解析: "the", "is", "sunny" 和 "day" 是出现次数最多的四个单词， 出现次数依次为 4, 3, 2 和 1 次。 注意：
假定 k 总为有效值， 1 ≤ k ≤ 集合元素数。输入的单词均由小写字母组成。 扩展练习：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a1a75590d23b5a1600f8b5b7087885e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd7913052187a589e3f52b0a39dc722a/" rel="bookmark">
			android 百度地理围栏,地理围栏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		private void drawFence(GeoFence fence) {
switch (fence.getType()) {
case GeoFence.TYPE_ROUND:
drawCircle(fence, false);
break;
case GeoFence.TYPE_BDMAPPOI:
drawCircle(fence, true);
break;
case GeoFence.TYPE_POLYGON:
drawPolygon(fence);
break;
default:
break;
}
// 设置所有maker显示在当前可视区域地图中
LatLngBounds bounds = boundsBuilder.build();
MapStatusUpdate mapStatusUpdate = MapStatusUpdateFactory.newLatLngBounds(bounds, 50,
50, 50, 50);
// 更新地图状态
mBdMap.animateMapStatus(mapStatusUpdate);
removeMarkers();
}
/**
* 绘制圆
*/
private void drawCircle(GeoFence fence, boolean isPoi) {
LatLng center;
int radius;
if (isPoi) {
BDLocation bdLocation = new BDLocation();
bdLocation.setLatitude(fence.getCenter().getLatitude());
bdLocation.setLongitude(fence.getCenter().getLongitude());
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd7913052187a589e3f52b0a39dc722a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f7b8c171572029cef01ba664e50b0fc/" rel="bookmark">
			电源完整性之Cadence Sigrity Power DC_IR_Drop仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前和大家分享过电源完整性之仿真设计原理链接: link.今天接着上一篇文章总结一下电源直流压降的的仿真操作流程及一些simulation中的设置参数，用到的时候Cadence Sigrity 中的Power DC组件，下面开始享受仿真的快乐吧：
1.仿真模式选择与文件导入 选择Cadence Sigrity下的Power DC组件，然后先择licence，最后就可以打开我们之前转化好的.SPD文件。操作如下图：
2.设置层叠信息和过孔焊盘参数 层叠信息：每层的介质厚度、材料、介电常数、介质损耗角等，如下图：
过孔焊盘参数：过孔焊盘的镀铜厚度、材料等，如下图：
3.选择仿真的信号网络 选择仿真的电源网络，这个过程需要把电源网络归到PowerNets，把地网络归到GroundNets。有一些LDO的电源模块的输出是经过电感的，相应的网络也要classify到PowerNets。操作如下图：
4.设置VRM 这个过程是添加电压调节模块和设置相应的参数两步
模块的添加需要再相应的原理图上的器件添加VRM，设置如下：
VRM的参数设置包括：VRM的电压、电流、电压的允许波动范围等，设置如下：
5.设置Sink 这个过程是添加负载Sink和设置相应的参数两步
Sink的添加需要再相应的原理图上的器件添加Sink，设置如下：
Sink的参数设置包括：VRM的电压、电流、电压的允许波动范围等，设置如下:
这里的的model一般默认选择equal current电流相等，P/F model一般默认选择worst最坏的模式
因为产品不同，板子上的电源模块和负载也是不同的，所以需要根据自己的互连设计情况来设置VRM和Sink：
6.设置Discretes 再这个产品上因为电源5V和3V3都是电源芯片通过电感输出的，所以在这个步骤需要使能电感器件，设置电感的参数，设置如下：
点击Set up Discretes之后选择第一个选项，然后选择电感两边的网络，就是自动使能电感，下面需要设置电感的内阻和通流的大小
7.保存文件，开始仿真 设置如下：
8.查看仿真结果 从这里可以看到每个负载的电压是多少，可以判断处从VRM到Sink的直流压降是否满足我们的要求：
2D结果查看，可以通过电压密度、电流密度、支流压降等不同的形式查看：
3D结果查看，可以动态的查看电流的流向等：
还可以通过点击Generate Report，查看仿真报告，如下：
以上是关于Cadence Sigrity Power DC_IR_Drop仿真的过程！
在IR_Drop的仿真中，可以通过以上几种不同的结果看出我们电源设计哪里压降较多，哪里压降角少，也可以看出我们的电源设计的瓶颈区，来判断电流密度是否过大，导致copper过热等。通过这些可以来优化我们的互连设计。下面是几张仿真的图片：
如有错误，希望各位大神留言指正，顺便点个赞👍，感谢！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da8f08ce00248bb04ad8b24e3fbef62f/" rel="bookmark">
			android系统 红米 耗电量大,红米k40耗电快怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		红米k40耗电快怎么解决？具体的解决办法介绍小编已经为大家准备好了。下面，就跟随玩游戏网的小编一起继续往下看，感兴趣的小伙伴一定把固有错过哦！
红米k40耗电快怎么解决：
1、留意信号强度
如果处于一个信号比较糟糕的地方，那么可以考虑暂时切换到飞行模式，不让iPhone不断的搜索微弱的信号，另外能使用WiFi的情况下尽量多用WiFi,不稳定的蜂窝数据同样会对手机电量带来比较大的消耗。
2、关闭无用的通知中心应用
每一次应用通知推送都会消耗一点电量，因此必须关掉声音提醒和图标标记。
3、更改显示设置
显示屏在不用的时候要让它快速关闭，将自动锁定的时间调整到比较短的范围内。还可以到设置中的壁纸和亮度中关闭“自动亮度”调节，让屏幕总是处于一个比较暗的状态下，也可以节省不少电量。
4、停用动画效果。
动画效果虽然看起来有趣，但是也要消耗更多的电量。
5、减少应用后台刷新
应用在后台刷新会特别耗电，并且有很多小伙伴的系统在12.0.5，这个版本有一个安卓系统的BUG，有一个安卓系统耗电量每天都第一，所以需要更新系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94d6aed71f8abeb5e2bb707ff0bec06c/" rel="bookmark">
			【Plex】FRP内网穿透后 App无法使用问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.问题描述 我用NAS搭建了Plex服务器后，使用FRP将Plex穿透为TCP隧道。
穿透方法参照：【群晖NAS】真·免费内网穿透方案 及踩坑合集
【群晖NAS】 利用云服务器 FRP技术 实现内网穿透
在浏览器中打开 https://[穿透域名]:穿透端口，是可以正常远程打开Plex的。在提示这个后，可以正常使用。
但是这样仅仅只能够在网页端打开，App却不行，并且网页端的体验并没有App端的体验好，既然都已经穿透出去了，只是在网页上的话，对我来说有些大打折扣。
二.解决方案 打开Plex服务器，【设置】-&gt;【网络】，找到 【Custom server access URLs】
你填写的URL就是你穿透出去的域名或者IP，例如
http(s)://xx.xx.xx.xx:[穿透端口] 或者
http(s)://plex.example.com:[穿透端口] 【注意】 建议使用IP地址，因为有些国内的域名，Plex是解析不到的务必将上方的【Enable Relay】，具体原因和原理参见 【Plex】 Enable Relay原理及功能介绍 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00f8fe8673d67639cbfdbb0deb2c5cef/" rel="bookmark">
			如何在pc上开发Android程序,如何在PC上运行Android应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尽管Android是一个新兴的移动操作系统，但是目前它的市场占有率正在不断增加，因此Android的应用程序数目也在逐渐增长。我们中很多人都有自己喜欢的应用程序，但是我们几乎只是在智能手机或者平板电脑上使用它们。
你是否知道其实你也可以在台式机或者笔记本上运行这些Android应用程序？BlueStacks App Player就能够帮助我们实现这种想法，BlueStacks App Player alpha内部测试版本推出已经有一段时间了。去年10月份支持Windows 7的BlueStacks App Player测试版面世，11月份又发布了支持Windows XP的新测试版，现在即将推出BlueStacks App Player beta测试版，到时您就可以注册参与测试了。BlueStacks App Player刚推出的时候就曾报道过，它能让用户在自己的电脑上运行Android应用程序，尽管还有一些限制。
网上已经有BlueStacks App Player alpha版的下载资源，大家可以搜索下载，试用此软件了。
应该指出的是现在BlueStacks App Player正在进入beta版本测试阶段。在支持Windows系统的下载版本(还有一些针对其他操作系统的版本)中，BlueStacks App Player提供了一些Android 应用程序的预安装包，你也可以自己添加很多其他的应用程序，但是不是每款Android应用都能安装。
自从BlueStacks App Player被报道了以后，它又在消费电子产品展(Consumer Electronics Show)上赢得了“Best of CES 2012”奖。那么BlueStacks是如何实现在电脑上运行Android应用程序的呢？实际上应用程序是通过它安装在电脑上的Android虚拟机中运行的。你可以在这里观看视频，初步感受它是怎样工作的。
BlueStacks一直在和一些企业谈论关于Android模拟平台方面的合作，当然有的企业看好Android，也有很多企业不认同Android平台，而BlueStacks或许可以不负众望，在用户的智能手机与电脑之间搭建起一座桥梁。
如果你有兴趣在你的台式机或笔记本上运行Android应用程序，那么马上注册参与BlueStacks beta版的测试吧。beta版测试将在本月启动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b77a6f591c48aa3ec2ea394b67f3022/" rel="bookmark">
			android资源加载流程6,FrameWork源码解析(6)-AssetManager加载资源过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前一段时间项目比较忙所以一直没有更新，接下来准备把插件化系列的文章写完，今天我们就先跳过ContentProvider源码解析来讲资源加载相关的知识，资源加载可以说是插件化非常重要的一环，我们很有必要来了解它。当然看这篇文章之前可以看下性能优化(6)-减小APK体积加深下对资源目录的了解。
一.目标
今天的文章内容是为了插件化框架讲解做准备的知识的，我们的今天要达到的目标是：
1.能明白AssetManager是怎么加载资源的，apk内部或者外部的；
2.同时加深一下对资源的认识。
二.AssetManager
前面我们已经知道因为Activity，ContextWrapper，ContextImpl的关系，这个部分用的是装饰模式来实现的，所以在Activity中调用的大部分方法都将最终调用到ContextImpl中，所以访问资源的两个方法getResources()和getAssets()最终都将调用ContextImpl中的相应方法。
ContextImpl#getResources()方法返回Resources对象,这个对象是根据资源的id来访问相应的资源的，除了assets目录不会在R文件中生成相应的id外，其他都是可以的。ContextImpl#getAssets()返回的是AssetManager对象，这个对象可以根据文件名来返回被编译过或者未编译过的资源。其实Resources对象最终也是通过AssetManager对象来获取资源的，不过会先通过资源id查找到资源文件名。
这里我们首先从ContextImpl#getResources()方法入手：
@Override
public Resources getResources() {
return mResources;
}
我们看到这里直接返回了ContextImpl中的mResources变量，这个变量是在哪里被初始化的呢？我们可以在ContextImpl的构造函数看到：
private ContextImpl(ContextImpl container, ActivityThread mainThread,
LoadedApk packageInfo, IBinder activityToken, UserHandle user, int flags,
Display display, Configuration overrideConfiguration, int createDisplayWithId) {
.....
Resources resources = packageInfo.getResources(mainThread);
....
mResources = resources;
....
}
这里的packageInfo是LoadedApk对象，LoadedApk描述的是当前apk的一些信息，我们看到这个方法首先是调用了LoadedApk#getResources方法，传进去的参数是mainThread，mainThread对应的是ActivityThread对象，也就是当前正在运行的应用程序进程。所以我们接下来看LoadedApk#getResources方法：
public Resources getResources(ActivityThread mainThread) {
if (mResources == null) {
mResources = mainThread.getTopLevelResources(mResDir, mSplitResDirs, mOverlayDirs,
mApplicationInfo.sharedLibraryFiles, Display.DEFAULT_DISPLAY, this);
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b77a6f591c48aa3ec2ea394b67f3022/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db42927f25600625b7db2b24171abeaf/" rel="bookmark">
			android代码混淆恢复,Android代码混淆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是代码混淆
代码混淆就是将代码中的各种元素，如变量，方法，类和包的名字改写成无意义的名字，增加项目反编译后被读懂的难度。
Android代码混淆使用ProGuard工具，ProGuard是一个压缩、优化和混淆Java字节码文件的免费的工具，它可以删除无用的类、字段、方法和属性。
以下是官网对ProGuard的说明：
ProGuard是一个对Java类文件进行压缩，优化，混淆和校验的工具。
压缩过程查找并删除没有使用到的类，字段，方法和属性。优化过程对方法的字节码进行分析和优化。
混淆过程把剩余的元素名字该写成简短且无意义的名字。这些过程会使程序体积更小，运行更高效，更难被反编译。
最后的校验过程为类增加校验信息，但这个过程依赖J2ME和JDK6或以上的编译环境。
rom编译
Android.mk文件中，用LOCAL_PROGUARD_ENABLED来配置混淆的模式；LOCAL_PROGUARD_FLAG_FILES用来指定配置文件。LOCAL_PROGUARD_ENABLED的取值如下：
full：使用编译系统默认的配置：压缩但不混淆和优化，默认的混淆配置文件是build/core/proguard.flags
custom：和full一样，但不包括aapt生成的resource相关的混淆配置。
nosystem：不使用系统的默认配置，但使用aapt生成的resource相关的混淆配置，其他混淆由模块自己负责。
disabled：关闭混淆
obfuscation：和full一样，并且开启混淆
optimization：和full一样，并且开启优化
不设置时，如果是app，默认为full，如果是library，则默认为disabled。
编译userdebug版本时，编译脚本会把app的obfuscation改成full，即不混淆；所以userdebug版本的app是不混淆的。想了解更多信息，可以自行阅读project_src/build/core/下的java.mk,package_internel.mk,java_library.mk,proguard.flags,proguard_base_keeps.flags等文件。
Android Studio
项目目录下的build.gradle文件中minifyEnabled设置为true为开启，false为关闭；proguardFiles用来指定混淆配置文件。使用Build菜单下的Generate Signed APK进行打包即可。记得在Build Type：选项下选择release，否则只打包不会混淆。
Eclipse
项目目录下的project.properties文件中添加配置即可开启混淆：proguard.config=xxx,xxx为混淆配置文件路径，多个配置文件用：分隔。 然后Export APK就可以了，注意直接运行程序生成的安装包是没有经过混淆的。
如何使用混淆
理想的目标是将所有元素都加入混淆，但混淆会另反射无法工作。因此反射以及反射延伸出来的功能使用到的元素都不能混淆。
因为Android开发中有些内容每次都要配置，所以sdk中提供了一份默认配置文件，我们新建项目时可以复制或引用sdk下的默认配置，在此基础上再增加自己的需求。默认配置文件在android_sdk/tools/proguard/proguard-android.txt。
下面介绍一些常用配置以及Android开发中哪些元素不应该混淆。常用配置：
-keep
keep用来指定哪些元素不进行混淆，它有很多变种，比如：
-keep 保留指定的包，类和类成员不被混淆。
-keepclassmembers 保留指定的类成员不被混淆，但包名类名会被混淆。
-keepclasseswithmembers 保留指定的类成员及其类不被混淆。
当未配置-dontshrink(该配置是关闭压缩功能，也就是不会删除未使用的元素，未配置时，也即是开启压缩功能)时，以上3个配置指定的元素即使未使用过，也不会被删除。 以下3个命令与以上3个命令对应，区别是在上述情况中，指定的元素未使用过就会被删除。
-keepnames 也可以写成-keep,allowshrinking
-keepclassmembernames 也可以写成-keepclassmembers,allowshrinking
-keepclasseswithmembernames 也可以写成-keepclasseswithmembers,allowshrinking
示例：
保留Util类名，但内部成员会被混淆
-keep public class com.test.proguard.util.Util
保留Util类名及其内部成员
-keep public class com.test.proguard.util.Util {;}
保留util包及其下级包的类和内部成员
-keep public class com.test.proguard.util.* {;}
保留第三方lib库及继承自第三方的类：
======= Sina Weibo SDK =========
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db42927f25600625b7db2b24171abeaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a0448221cb43f5dff3c027b063c06e7/" rel="bookmark">
			android防止左向右滑出程序,Android——ViewPager禁止左右滑动的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 背景
用ViewPager+BottomNavigationView+多个Fragment快速搭建的页面切换架构，一个有四个页面，因为测试需要，需要屏蔽掉中间的两个，做法是：
设置不可点击选择：xml布局文件中，BottomNavigationView的app:menu属性为各页的item，将不想显示的页面item的android:enabled属性设置为false，此时对应的页面就无法显示了；
设置BottomNavigationView不可滑动：但是BottomNavigationView没有对应的方法支持这个功能。
2 自定义ViewPager实现
【原理】：写一个CustomViewPager类继承ViewPager，然后重写onTouchEvent、onInterceptTouchEvent，另外添加了setSlidingEnable方法，外部传参开启或禁止滑动。这里简单解释下onInterceptTouchEvent方法：
作用：判断是否拦截上面touch的事件；
参数：
——return false: 不对事件进行拦截，放行该事件。事件会被传递到当前的View的子控件中，由子控件中的dispatchTouchEvent方法进行分发处理；
——return true: 拦截该事件，将该事件交给当前View的onTouchEvent方法进行处理；
【代码】：
public class CustomViewPager extends ViewPager{
// the sliding page switch
private boolean isSlidingEnable = true ;
public CustomViewPager(Context context){
super(context);
}
public CustomViewPager(Context context, AttributeSet attrs){
super(context, attrs);
}
//重写此函数
@Override
public boolean onTouchEvent(MotionEvent ev){
return this.isSlidingEnable;
}
//重写此函数
@Override
public boolean onInterceptTouchEvent(MotionEvent ev){
return this.isSlidingEnable;
}
public void setSlidingEnable(boolean slidingEnable){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a0448221cb43f5dff3c027b063c06e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/184508940d9b4a9eccb7091d916ad773/" rel="bookmark">
			学编程脚本 android,Auto.js安卓免root脚本开发教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Auto.js安卓免root脚本开发教程
教程介绍
Auto.js是利用安卓系统的“无障碍服务”功能，实现类似于按键精灵一样，可以通过代码模拟一系列界面动作的辅助工作。与“按键精灵”不同的是，它的模拟动作并不是简单的使用在界面定坐标点来实现，而是类似与win一般，找窗口句柄(xml节点)来实现的。使用autojs可以开发出不需要root权限，支持全分辨率的脚本。
能学到什么程度？
掌握每节课的教学内容，课程结束后，能独立开发常见安卓APP的免ROOT引流脚本，找工作月薪5000元以上。
学完以后能做什么？
全部课程掌握之后，可以做一些中小型的引流脚本项目开发，熟悉从需求分析到项目完成的完整流程。在实际工作中不断总结经验，提升技能，成为一名合格的脚本开发程序员。
适合人群
希望改变现状升职加薪的已就业人员
希望掌握一项技能以就业的学生
希望不受约束成为一名自由职业者
认可互联网希望通过网络创业的人
学习对象
引流脚本零基础入门、有基础进阶。
有过任何一门编程语言基础的朋友，学起来可能会更轻松。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc022f1e68fe4f8726e7d2a42fa97537/" rel="bookmark">
			android布局生成bitmap,Android 布局文件（view）生成Bitmap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已测量过的View生成Bitmap
即经过测量、布局、绘制并显示在界面上的View，此类View无需再次进行测量和布局，可直接将内容绘制到指定的Bitmap上。
/**
* 绘制已经测量过的View
*/
private static Bitmap drawMeasureView(View view) {
int width = view.getWidth();
int height = view.getHeight();
Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565);
Canvas canvas = new Canvas(bitmap);
view.draw(canvas);
return bitmap;
}
未测量过的View生成Bitmap
直接Inflate后并未显示在界面的View，此类View必须手动进行测量和布局后，方可进行绘制，否则获取不到对应的宽高和内容。
/**
* 先测量和布局，再生成Bitmap
*/
public static Bitmap getBitmap(View view) {
DisplayMetrics metric = new DisplayMetrics();
getWindowManager().getDefaultDisplay().getMetrics(metric);
int screenWidth= metric.widthPixels; // 屏幕宽度(像素)
int screenHeight = metric.heightPixels; // 屏幕高度(像素)
// 测量
int widthSpec = View.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc022f1e68fe4f8726e7d2a42fa97537/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b381ad3f1e3c95713bcccb79d9162840/" rel="bookmark">
			怎么看手机系统android版本,怎么查看手机型号、配置、版本【图文教程】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎么查看手机型号、配置、版本【图文教程】
很多人在购买手机之后突然想起要查看一下手机型号、配置等，那么怎么看手机型号配置呢?下面教大家怎么看手机型号配置的两种方法，都来看看吧。
步骤1、首先来说说第一种方法，这一种方法在大家都手机上都可以通用。就是在设置里面，在“关于手机”中进行查看。那么要在手机桌面中先找到“设定”，并且点击打开“设定”。
步骤2、点击打开“设定”以后，“设定”项目里边有很多的设置项。在这些设定项中需要找到“关于手机”这个项目，看到这里没有，那就需要往下翻，找到“关于手机”。
步骤3、在“设定”项目中往下翻动，在这一页面的最下方就可以看到“关于手机”，然后就点击打开“关于手机”这个项目。
步骤4、在“关于手机”这个项目中，能看到手机关于配置的各个说明。有手机型号，还有手机的安卓版本，以及手机的内核等等。这些只是手机配置的一部分，还可以更具体的了解手机的配置。
步骤5、下面就来说说第二种，第二种需要借助软件来完成。需要手机安装360手机卫士，安装了360手机卫士以后，在桌面上点击打开360手机卫士。
步骤6、点击打开360手机卫士以后，进入到“常用功能”的界面，再需要找到“安全防护”。找到“安全防护”以后，点击打开，然后可以在里面找到“系统检测”的功能。
步骤7、进入到“安全防护”以后，在“安全防护”中，最下方有一项“系统检测”。这个“系统检测”就是360对手机的系统配置以及使用情况的检测，然后点击打开“系统检测”。
步骤8、点击打开“系统检测”以后，这里面对手机的系统介绍比较完善，所有的关于手机配置方面的信息基本都可以看的到。
以上就是怎么看手机型号的解决办法，希望对大家有帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ca6b50b7a6c6b60fda57a2b8f4693ed/" rel="bookmark">
			rancher
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是 rancher
Rancher是一个开源的企业级全栈化容器部署及管理平台。简单的说，就是一个可以让你通过 web 界面管理 docker 容器的平台。定位上和 K8s 比较接近，都是通过 web 界面赋予完全的 docker 服务编排功能。
rancher 的特色
1,平台部署方便。管理 docker 的平台本身也基于 docker 部署。只要你有 docker ，一句命令就完成平台的部署了。
2,平台扩展方便。通过 agent 机制，一句 docker 命令完成 agent 部署，快速增加你的物理机。同时也支持 AWS 等云主机， 2.0 版本甚至还支持 K8s 。
3,服务部署方便。通过应用商店，2步完成应用部署，而且还是像 docker-compose 那样各个中间件独立编排，可以随时扩容的哦。
4,自带账户权限。相比 K8s 没有账号管理，rancher 自带账号权限体系。账号可以独立创建，也可以很方便地接入 ldap 等账号体系。对于公司使用是一大利器。
启动 Rancher 服务器
Rancher 服务器是一个 Docker image，所以其软件本身不需要安装，只需要执行 Docker 命令下载并且成功运行 Docker 服务器镜像即可。
docker run -d --restart=always -p 8000:8080 rancher/server
命令行参数解释：
docker run 的 -d 参数标示在后台运行， --restart=always 容器如果异常停止自动重启。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ca6b50b7a6c6b60fda57a2b8f4693ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8416341582076bc200010eebbffa4111/" rel="bookmark">
			android 严振杰权限管理,GitHub - hnyer/AndPermission: 动态权限  - 权限申请  - Android Permission = AndPermission. An...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AndPermission
特性
支持链式调用，一句话申请权限，为你省去复杂的逻辑判断
支持注解回调权限申请成功、失败
支持Listener方式回调权限申请成功，失败
支持Rationale，支持权限申请失败后，用户勾选了不再提示后提示用户
引用方法
AndroidStudio使用方法，gradle一句话远程依赖
compile 'com.yanzhenjie:permission:1.0.2'
Or Maven:
com.yanzhenjie
permission
1.0.2
pom
Eclipse 下载jar包，或者自行下载源码。
Eclipse需要自行依赖Support的AppCompat项目。
使用介绍
更好的例子，请下载源码后运行demo查看，这里给出最关键的代码。
申请权限就是这么简单
AndPermission.with(this)
.requestCode(101)
.permission(Manifest.permission.WRITE_CONTACTS,
Manifest.permission.READ_SMS,
Manifest.permission.WRITE_EXTERNAL_STORAGE)
.send();
只需要在Activity中或者Fragment中直接调用即可，AndPermission自动为你打理好后宫。
接受权限回调更简单
方式一：利用Listener方式回调
@Override
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
// 只需要调用这一句，剩下的AndPermission自动完成。
AndPermission.onRequestPermissionsResult(this, requestCode, permissions, grantResults, listener);
}
private PermissionListener listener = new PermissionListener() {
@Override
public void onSucceed(int requestCode) {
if(requeust == 100) {
...
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8416341582076bc200010eebbffa4111/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c965ce1e70633716467c42011f38475d/" rel="bookmark">
			android&#43;资源管理框架,Android资源管理框架（Asset Manager）简要介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android应用程序是将代码逻辑和界面资源进行分离的，Android应用程序资源可以分为两大类，分别是assets和res
assets
assets类资源放在工程根目录的assets子目录下，它里面保存的是一些原始的文件，可以以任何方式来进行组织。这些文件最终会被原装不动地打包在apk文件中。如果我们要在程序中访问这些文件，那么就需要指定文件名来访问。例如，假设在assets目录下有一个名称为filename的文件，那么就可以使用以下代码来访问它：
AssetManager assset= getAssets();
InputStream is = assset.open("filename");
res
res类资源放在工程根目录的res子目录下，它里面保存的文件大多数都会被编译，并且都会被赋予资源ID。这样我们就可以在程序中通过ID来访问res类的资源。res类资源按照不同的用途可以进一步划分为以下9种子类型：
animator
anim
color
drawable
layout
menu
raw
values
xml
animator
animator这类资源文件呢是保存在res/animator目录下，主要呢是用来描述属性动画的，我做了一个属性动画总结，可以查看在animator目录下的文件如何使用
anim
这类资源文件呢是保存在res/anim目录下，主要呢是用来描述补间动画的，我做了一个补间动画总结，可以查看在anim目录下的文件如何使用，以及补间动画的属性
color
这类资源是以XML文件形式保存在res/color目录下，用描述对象颜色状态选择。例如，可以规定一个对象在不同状态下显示不同的颜色。对象的状态可以划分为pressed、focused、selected、checkable、checked、enabled和window_focused等7种。
drawable
这类资源以XML或者Bitmap文件保存在res/drawable目录下，用来描述可绘制对象。例如，我们可以在里面放置一些图片(.png, .9.png, .jpg, .gif)，来作为程序界面视图的背景图。注意，保存在这个目录中的Bitmap文件在打包的过程中，可能会被优化的。例如，一个不需要多于256色的真彩色PNG文件可能会被转换成一个只有8位调色板的PNG面板，这样就可以无损地压缩图片，以减少图片所占用的内存资源。
layout
这类资源是我们最常用的，通常以XML文件保存在res/layout目录下，主要用来编写应用程序界面布局
menu
这类资源以XML文件保存在res/menu目录下，用来描述应用程序菜单，例如，Options Menu、Context Menu和Sub Menu
raw
这类资源以任意格式的文件保存在res/raw目录下，它们和assets类资源一样，都是原装不动地打包在apk文件中的，不过它们会被赋予资源ID，这样我们就可以在程序中通过ID来访问它们。例如，假设在res/raw目录下有一个名称为filename的文件，并且它在编译的过程，被赋予的资源ID为R.raw.filename，那么就可以使用以下代码来访问它：
Resources res = getResources();
InputStream is = res .openRawResource(R.raw.filename);
values
这类资源以XML文件保存在res/values目录下，用来描述一些简单值，例如，数组、颜色、尺寸、字符串和样式值等，一般来说，这六种不同的值分别保存在名称为arrays.xml、colors.xml、dimens.xml、strings.xml和styles.xml文件中。
xml
这类资源以XML文件保存在res/xml目录下，一般就是用来描述应用程序的配置信息。
注意，上述9种类型的资源文件，除了raw类型资源，以及Bitmap文件的drawable类型资源之外，其它的资源文件均为文本格式的XML文件，它们在打包的过程中，会被编译成二进制格式的XML文件。这些二进制格式的XML文件分别有一个字符串资源池，用来保存文件中引用到的每一个字符串，包括XML元素标签、属性名称、属性值，以及其它的一切文本值所使用到的字符串。这样原来在文本格式的XML文件中的每一个放置字符串的地方在二进制格式的XML文件中都被替换成一个索引到字符串资源池的整数值。这样做有两个好处：
A. 文件占用更小。例如，假设在原来的文本格式的XML文件中，有四个地方使用的都是同一个字符串，那么在最终编译出来的二进制格式的XML文件中，字符串资源池只有一份字符串值，而引用它的四个地方只占用一个整数值。
B. 解析速度更快。由于在二进制格式的XML文件中，所有的XML元素标签和属性等值都是使用整数来描述的，因此，在解析的过程中，就不再需要进行字符串解析，这样就可以提高解析速度
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3078ca1b10992cfe438bfe54b4db46b/" rel="bookmark">
			基于Vue&#43;SpringCloudAlibaba微服务电商项目实战-构建会员服务-008：整合XXL-Job实现分片定时任务集群模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		008：整合XXL-Job实现分片定时任务集群模式 1 高效实现分片定时任务集群原理2 动态分片集群执行任务实现原理3 定时任务集群如何保证幂等性问题4 分布式任务调度平台分片集群模式5 本地构建执行器项目注册到注册中心上6 分片集群分页算法原理分析7 动态实现执行器快速扩容与缩容8 分布式任务调度平台xxl-job一些疑问 1 高效实现分片定时任务集群原理 今日课程任务
实现千万级定时消息推送平台
定义活动推送消息模板XXL-Job实现分布式任务调度原理整合XXL-Job实现分布式定时任务XXL-Job分片任务调度集群原理 假设发送100万消息需要10个小时，如何实现1000万也只需要10个小时？
动态分片实现集群，只需要新增服务器集群节点即可动态扩容推送消息
2 动态分片集群执行任务实现原理 微信活动群发 查询数据库中wx_open_id不为空的数据，调用微信接口群发。
发送活动提醒，活动仅在当天有效，假设公众号有100w数据，常规做法数据库分页查询，每次查10w发送需要1小时，那么100w需要10小时。
分页查询群发效率低，如果活动有一定时效性要求，随着用户量不断增加，消息推送难以准时发给用户。
如何实现无论用户是否继续增加，都可以在有效期内全部发送完毕？
动态分片集群模式。
3 定时任务集群如何保证幂等性问题 定时群发跑批数据量大的情况下如何处理？
可以采用多线程，但是非常消耗单台服务器内存。
业务代码是否可以和定时任务代码放入同一个jar包？
定时任务模块和业务模块单独拆分。定时任务项目底层就是死循环处理，非常占用服务器资源。
定时任务集群如何防止业务重复执行？
将定时任务代码单独部署一个jar包中，不参与业务逻辑服务器集群部署；在jar中开启一个定时任务配置开关，判断是否需要将定时任务类加载到spring容器中；使用分布式锁。项目启动中，只要谁能够拿到分布式锁，谁就能够将定时任务的配置类加载到spring容器中，否则不加载；数据库中插入主键id，只要谁能够往数据库中插入一条相同的主键，插入成功就可以加载定时任务配置类；
以上方案只适合小项目，不适合互联网级别项目采用分布式任务调度平台框架（推荐） 4 分布式任务调度平台分片集群模式 构建分布式任务调度平台Admin
1.官方下载XXL-Job Admin的源代码
2.数据库创建xxl-job需要依赖的库表doc/db/tables_xxl_job.sql
3.在xxl-job jdbc链接配置加上&amp;serverTimezone=UTC 否则报错
idea导入项目直接启动即可
访问http://127.0.0.1:8080/xxl-job-admin/
默认账号密码： admin 123456
5 本地构建执行器项目注册到注册中心上 创建项目
mt-shop-service-job
----mt-shop-service-member-job
引入maven依赖
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 引入配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3078ca1b10992cfe438bfe54b4db46b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15e0e4456cbb9b71b3b324a628923533/" rel="bookmark">
			android studio 工程demo例子,Android Studio 基础入门及示例演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装部分不作介绍,会安装 Android Studio 和sdk
出现 Android Studio运行程序错误，提示信息:Error:(47, 13) Failed to resolve: com.android.support:appcompat-v7:26.0.0 参考链接 https://blog.csdn.net/sunnyboy9/article/details/81777637
2.创建项目
Android Studio 跟idea 基本差不多,基础配置 参考https://www.cnblogs.com/smyhvae/p/4390905.html
3.项目结构基本介绍
盘符:. ├─.gradle ├─.idea │ build.gradle 项目Gradle构建脚本 │ gradle.properties 项目Gradle属性文件 │ gradlew 在没有安装gradle的pc上使用,没用 │ gradlew.bat 在没有安装gradle的pc上使用,没用 │ local.properties 指定sdk所在目录 │ settings.gradle 项目Gradle设置文件 │ ├─app │ │ .gitignore git忽略文件列表 │ │ app.iml 临时文件,不需要关心 │ │ build.gradle Module Gradle构建脚本 │ │ proguard-rules.pro proguard混淆规则 │ │ │ ├─build 构建目录，相当于Eclipse中默认Java工程的bin目录。编译生成的apk在此目录 │ ├─libs 依赖包 │ └─src │ ├─androidTest 测试相关代码文件夹 │ │ └─java │ │ └─com │ │ └─itheima │ │ └─myapplication │ │ ApplicationTest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15e0e4456cbb9b71b3b324a628923533/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/310/">«</a>
	<span class="pagination__item pagination__item--current">311/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/312/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>