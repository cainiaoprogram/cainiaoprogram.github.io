<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fe86ffdc29b628b5f2053568dab6ad2/" rel="bookmark">
			【MYSQL】 体育馆的人流量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		X 市建了一个新的体育馆，每日人流量信息被记录在这三列信息中：序号 (id)、日期 (date)、 人流量 (people)。
请编写一个查询语句，找出高峰期时段，要求连续三天及以上，并且每天人流量均不少于100。
例如，表 stadium：
+------+------------+-----------+ | id | date | people | +------+------------+-----------+ | 1 | 2017-01-01 | 10 | | 2 | 2017-01-02 | 109 | | 3 | 2017-01-03 | 150 | | 4 | 2017-01-04 | 99 | | 5 | 2017-01-05 | 145 | | 6 | 2017-01-06 | 1455 | | 7 | 2017-01-07 | 199 | | 8 | 2017-01-08 | 188 | +------+------------+-----------+ 对于上面的示例数据，输出为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fe86ffdc29b628b5f2053568dab6ad2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d413eab4cf1e919a1195fcc0f2a9164/" rel="bookmark">
			Python 计算机视觉（五）特别篇 —— 透视变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上一篇：Python 计算机视觉（五）—— OpenCV 进行图像几何变换
目录
1. 应用场景
2. 基本原理
3. 需要的函数
(1) cv2.getPerspectiveTransform() 作用：
参数：
(2) cv2.warpPerspective()
作用：
参数：
4. 实战 1. 应用场景 我们在生活中常常遇见这种问题：拍了一张照片，但由于不是正对着拍照对象所以拍出的图像只能是一张变形了的照片，这就导致了我们观察图像信息吃力或者拍出的图像不符合某些规范，又或者某一些图像的显示角度出现问题，导致发生形变，在观察的过程中影响了美感，如下面的几张图像所示（图像来源见水印）：
上面的几种情况都可以使用透视变换进行修正，来减轻由于角度造成的不好影响
2. 基本原理 此处参考：【图像处理】透视变换 Perspective Transformation
透视变换就是将原图投影到一个新的视平面中，也被称为投影映射，如下图：
从上图可以看出，选取合适的投影中心和投影的角度以及各个角的坐标就可以将失真的图像还原出来，这就是透视变换的基本原理；
在该变换中适用的基本公式（变换过程）为：
得到最终结果为：
其中的 u,v 是原图像的坐标点， x,y 是变换后得到的图像坐标点
3. 需要的函数 cv2.getPerspectiveTransform() cv2.warpPerspective() (1) cv2.getPerspectiveTransform() 作用： 根据输入（原图像）和输出（变换后的图像）上的四对点坐标获得从原图到目标图像的透视变换矩阵
参数： getPerspectiveTransform(src, dst, solveMethod=None)
此处参考：OpenCV-Python投影透视变换函数getPerspectiveTransform及warpPerspective详解
src:源图像上四个点的坐标构成的矩阵，要求其中任意三点不共线
dst:目标图像上四个点的坐标构成的矩阵，要求其中任意三个点不共线，且每个点与src的对应点对应
solveMethod：矩阵分解方法，传递给cv2.solve(DecompTypes) 求解线性方程组或解决最小二乘问题，默认值为None，表示使用DECOMP_LU
(2) cv2.warpPerspective() 作用： 对输入图像进行透视变换
参数： warpPerspective(src,M, dsize, dst=None, flags=None, borderMode=None, borderValue=None)
src：输入图像矩阵
M：3*3的透视变换矩阵，可以通过getPerspectiveTransform等函数获取
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d413eab4cf1e919a1195fcc0f2a9164/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cad3d0edd27f7bf969a120e9c273507e/" rel="bookmark">
			C语言笔记（建议背下来）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键字
数据类型关键字(12个)：
char、short、int、long、signed、unsigned、float、double、struct、union、enum、void
控制语句关键字(12个）：
1、循环控制（5个）
for、do、while、break、continue
2、条件语句（3个）
if、else、goto
3、开关语句（3个）
switch、case、default
4、返回语句（1个）
return
存储类型关键字（5个） auto、extern、register、static、typedef
其他关键字（3个） const、sizeof、volatil
特殊笔记
若二维数组a有m列，则计算任一元素a[i][j]在数组中位置的公式为 i*m+j+1。
e（或E）前面必须有数，后面必须要有整数。
在数字后面加l或L，表示长整型；后面加u或U，表示无符号类型。
一个整常量后面加一个字母u或U，可以认为是unsigned int型，如123456u 在一个整常量后面加一个字母l或L，则认为是long int型常量，如123l、123L 实现保留三位小数，第四位四舍五入的程序。
y=（int）（x*100+0.5）/100.0 这个保留两位，对第三位四舍五入 y=（int）（x*1000+0.5）/1000.0 这个保留三位，对第四位四舍五入 y=（int）（x*10000+0.5）/10000.0 这个保留四位，对第五位四舍五入 运算符的优先级：赋值运算符 &lt; 逻辑运算符 &lt; 关系运算符 &lt; 算术运算符。
字符数组初始化被赋值了，当使用scanf函数或gets函数对数值赋值时，会将里面初始化的值覆盖。
三种零的表示（整型：int n = 0; 字符串：char arr = '\0'; 指针：int *p = NULL;）
char型数据在内存中的存储形式是ASCII码。
如果是定义的全局变量或者静态变量，未初始化的话就是0。如果是局部变量，那就是以前残留在堆栈里的随机值。
两个指针变量不可以相加，指针只可以进行相减。
if语句中的表达式不局限于哪种类型的表达式，只要表达式非零时，表达式的值就为真，否则就是假。
在c语言中，局部变量可以和全局变量可以同名。
用户自定义标识符：define、scanf等可以被用来定义标识符。不能使用关键字，只能包含字母、数字(不能开头)、下划线。
C程序在预处理阶段对预处理命令进行处理。
数组的定义形式：类型说明符 数组名[常量表达式] （如是二维数组，后面再加一个[常量表达式] ）。
C语言只有9种控制语句。
if...else、for、while、do...while、continue、break、switch、return、goto 空语句：；（就一个单独的分号）。
调用一个函数，且此函数中没有return语句，则返回一个不确定的值。
C 语言编写的源文件经过编译，若没有产生编译错误，系统将输出运行结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cad3d0edd27f7bf969a120e9c273507e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93095bb90528be2a79bc65d3d3a4445b/" rel="bookmark">
			pytorch训练时指定显卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 利用CUDA_VISIBLE_DEVICES设置可用显卡 在CUDA中设定可用显卡，一般有2种方式：
(1) 在代码中直接指定
import os os.environ['CUDA_VISIBLE_DEVICES'] = gpu_ids (2) 在命令行中执行代码时指定
CUDA_VISIBLE_DEVICES=gpu_ids python3 train.py 如果使用sh脚本文件运行代码，则有3种方式可以设置
(3) 在命令行中执行脚本文件时指定：
CUDA_VISIBLE_DEVICES=gpu_ids sh run.sh (4) 在sh脚本中指定：
source bashrc export CUDA_VISIBLE_DEVICES=gpu_ids &amp;&amp; python3 train.py (5) 在sh脚本中指定
source bashrc CUDA_VISIBLE_DEVICES=gpu_ids python3 train.py 如果同时使用多个设定可用显卡的指令，比如
source bashrc export CUDA_VISIBLE_DEVICES=gpu_id1 &amp;&amp; CUDA_VISIBLE_DEVICES=gpu_id2 python3 train.py 那么高优先级的指令会覆盖第优先级的指令使其失效。
优先级顺序为：不使用sh脚本 (1)&gt;(2)； 使用sh脚本(1)&gt;(5)&gt;(4)&gt;(3)
个人感觉在炼丹时建议大家从(2)(3)(4)(5)中选择一个指定可用显卡，不要重复指定以防造成代码的混乱。方法(1)虽然优先级最高，但是需要修改源代码，所以不建议使用。
2 .cuda()方法和torch.cuda.set_device() 可以使用.cuda()[包括model.cuda()/loss.cuda()/tensor.cuda()]方法和torch.cuda.set_device()来把模型和数据加载到对应的gpu上。
(1) .cuda() 以model.cuda()为例，加载方法为：
model.cuda(gpu_id) # gpu_id为int类型变量，只能指定一张显卡 model.cuda('cuda:'+str(gpu_ids)) #输入参数为str类型，可指定多张显卡 model.cuda('cuda:1,2') #指定多张显卡的一个示例 (2) torch.cuda.set_device() 使用torch.cuda.set_device()可以更方便地将模型和数据加载到对应GPU上, 直接定义模型之前加入一行代码即可
torch.cuda.set_device(gpu_id) #单卡 torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93095bb90528be2a79bc65d3d3a4445b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfed60aa4daf1dddce82b66274f999dc/" rel="bookmark">
			交通流预测爬坑记（三）：使用pytorch实现LSTM预测交通流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很长时间没有更新内容了，上一篇可以看做是刚接触深度学习写的，看法非常狭隘，内容非常粗糙。
在最近的学习中接触到了Pytorch，不得不承认，相对于TensorFlow来讲，灵活很多。
这次就使用pytroch来进行一下交通流预测，数据和上一篇文章数据一样。
百度网盘: https://pan.baidu.com/s/19vKN2eZZPbOg36YEWts4aQ
密码 4uh7
准备开始
目录 加载数据构造数据集构造Dataset生成训练数据 构造LSTM模型定义模型和损失函数 模型预测模型评价完整代码 加载数据 导入数据的时候，需要把Network这一列删除
f = pd.read_csv('..\Desktop\AE86.csv') # 从新设置列标 def set_columns(): columns = [] for i in f.loc[2]: columns.append(i.strip()) return columns f.columns = set_columns() f.drop([0,1,2], inplace = True) # 读取数据 data = f['Total Carriageway Flow'].astype(np.float64).values[:, np.newaxis] data.shape # (2880, 1) 构造数据集 pytorch对于Batch输入，提供了规范的划分数据的模块， Dataset 和 DataLoader，这两个是很多刚使用pytorch的朋友头疼的地方，我简单说一下就不专门讲太多了可以去官网或者其他博客看一下
Dataset相当于装东西的大箱子，比如装苹果的箱子，一个大箱子里可以有很多小盒子，小盒子里装着苹果，不同的大箱子里小盒子装的苹果个数可以是不同的
Dataloader相当于使用什么方法在大箱子里拿盒子，比如，可以按顺序一次拿10个小盒子或者随机的拿5个小盒子
但这种使用Dataset和DataLoader创建数据集并不是唯一的方法，比如也可以使用上篇文章中使用的方法直接形成数据
当然，既然是使用pytorch那就使用它的特色吧，下面基于以上Dataset的方法，我们就可以构造自己的数据集
定义自己的Dataset比较麻烦， Dataset必须包括两部分:len 和 getitem
len 用来统计生成Dataset的长度
getitem 是可以index来获取相应的数据
同时为了方便，这Dataset中，增加了数据标准化以及反标准化的过程
构造Dataset class LoadData(Dataset): def __init__(self, data, time_step, divide_days, train_mode): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfed60aa4daf1dddce82b66274f999dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26ae7b02f3db0e4d3dde49a387354b1a/" rel="bookmark">
			Android 获取应用占用存储空间大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搜索网上的方法，使用storageStatsManager.queryStatsForUid()，获得到的数据不正确，使用queryStatsForPackage才拿到正确的数据
public static long getAppStorage(Context context, String packageName) { StorageStatsManager storageStatsManager = (StorageStatsManager) context.getSystemService(Context.STORAGE_STATS_SERVICE); StorageManager storageManager = (StorageManager) context.getSystemService(Context.STORAGE_SERVICE); List&lt;StorageVolume&gt; storageVolumes = storageManager.getStorageVolumes(); long appSizeL =0; for (StorageVolume storageVolume : storageVolumes) { UUID uuid = null; String uuidStr = storageVolume.getUuid(); try { if (TextUtils.isEmpty(uuidStr)){ uuid = StorageManager.UUID_DEFAULT; }else { uuid = UUID.fromString(uuidStr); } }catch (Exception e){ uuid = StorageManager.UUID_DEFAULT; } //通过包名获取uid int uid = 0; try { uid = getUid(context, packageName); } catch (PackageManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26ae7b02f3db0e4d3dde49a387354b1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d8d67404ac286c3ecd34d9c05062801/" rel="bookmark">
			你居然不知道前端常用的这6种编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端常用的6种编辑器 Visual Studio Code 下载地址：https://code.visualstudio.com/
介绍：
Visual Studio Code简称VS Code，是一款由微软开发且跨平台的免费代码编辑器，该软件功能十分强大，功能和插件也非常的全面，支持代码自动补全，自定义快捷键等功能，汉化插件功能非常好用，对英语不好的小伙伴非常的友好。VS Code 使用 Monaco Editor 作为其底层的代码编辑器，是目前身边用的最多的开发前端的工具之一。
hbuilder 下载地址：http://www.dcloud.io/
介绍：
是一款国产的编译工具，而且还是免费的，对英语不好的前端工程师非常的友好的工具，在语法提示这些调试方面都很高效，运行的时候也更加的小巧点，还支持webpack等功能，非常的强大，但是我自己感觉软件的缺点就是有时候会有卡顿，期待官方的及时修复。
sublime 下载地址：http://www.sublimetext.com/
介绍：
这是一款轻量简洁的跨平台编辑器，也是目前主流前端的开发编辑器，体积小，启动快，运行快，也可以安装大量插件，来满足开发者不同的需求，不过不足之处就是这个软件是收费且闭源的，配置插件有点不是很方便，对于项目管理方面也不是很方便。
WebStorm 下载地址：https://www.jetbrains.com/webstorm/
介绍：
WebStorm 是jetbrains公司旗下一款JavaScript 开发工具，软件非常好用，他的打印log非常的方便，软件自身就带有吸管工具，非常的实用，导入第三方库的时候，比如JQuery的时候，会有相关的提示，这款软件号称“Web前端开发神器”，缺点的话就是，收费编码软件，我觉得这是他最大的缺点，还有不足的就是启动速度方面有点偏慢。
Atom 下载地址：https://atom.io/
介绍：
软件开源免费，bug修复也比较快，比较的稳定，简洁和直观的图形用户界面，插件管理非常的榜，可以准确定位出问题的插件，缺点的话就是启动速度慢，打开大项目的话，会出现cpu占用比较的高。
Dreamweaver CC 下载地址：https://www.adobe.com/products/dreamweaver.html
介绍：
比较老的一款网页编辑器，曾经以PS+DW+FW称霸网页领域，号称网页三剑客，不过由于更新太慢，逐步被市场所淘汰，。现在据我所知，除了一些高校的教学还在使用这款，基本市面上使用这款编辑器的非常少了，对初学者太友好了，代码提示太过于强大，轻轻一点都是提示，还有就是Dreamweaver 所占用的运行内存比较大。
总结： 每个软件都有每个软件的特色，代码编辑器只是辅助工具，提高工作的效率，也使得代码的可读性变的更高，不能一味的最求人用的最多的编辑器，选择一款适合自己的编辑器，显得更加的重要。
在这边文章中，我们谈到了许多的代码编辑器，可以大大提高开发的效率，你在开发的过程中，还用过什么工具呢？欢迎大家评论里说出来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78a0103d021501ba11694e19fc640eb1/" rel="bookmark">
			oracle循环执行存储过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、功能：存储过程中for循环调用存储过程
2、场景：跑历史数据
create or replace procedure sp_loop_run is Cursor datekeey is select to_number(to_char(datekeey,'yyyyMMdd')) datekeey from (select date'2021-01-01' + (rownum - 1) datekeey from dual connect by rownum &lt;= (date'2021-06-30' - date'2021-01-01' + 1)) order by datekeey; --从xx到xx遍历日期 i number; begin for i in datekeey LOOP begin sp_pub_fund_quo_adj(i.datekeey); --调用存储过程 end; end LOOP; commit; end sp_loop_run; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/524a0e7ac230c7b380fb92d11f006b60/" rel="bookmark">
			oracle update from
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle 中update from的解决方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b376e7dde96982c18ec5a2734d9c50b5/" rel="bookmark">
			网络地址转换（NAT）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络地址转换（NAT） 文章目录 网络地址转换（NAT）1.NAT的工作原理2.NAT功能3.NAT的实现方式4.NAT优缺点5.静态NAT1）概述2）配置方法 6.动态NAT7.PAT8.实验1）静态NAT（一个内网地址对一个公网地址）2）动态NAT——PAT（多个内网地址对多个公网地址）3）Easyip（多个内网地址对一个接口地址）4）静态PAT（一对一，外网口IP和服务 映射 网内网服务器的IP和服务） 1.NAT的工作原理 ● NAT用来将内网地址和端口号转换成合法的公网地址和端口号，建立一个会话，与公网主机进行通信。
● NAT外部的主机无法主动跟位于NAT内部的主机通信，NAT内部主机想要通信，必须主动和公网的一个IP通信，路由器负责建立一个映射关系，从而实现数据的转发。
2.NAT功能 NAT不仅能解决了IP地址不足的问题，而且还能够有效的避免来自网络外部的入侵，隐藏并保护网络内部的计算机。
①宽带分享：这是NAT主机的最大功能
②安全防护：NAT之内的PC联机到Internet上面时，他所显示的IP是NAT主机的公网IP，所以client端的PC就具有一定程度的安全了，外界在进行portscan（端口扫描）的时候，就侦测不到源client端的PC。
3.NAT的实现方式 ● 静态转换
● 动态转换
● 端口多路复用（PAT）
4.NAT优缺点 优点：
● 节省共有合法IP地址
● 处理地址重叠
● 增强灵活性
● 安全性
缺点：
● 延迟增大
● 配置和维护的复杂性
● 不支持某些应用，可以通过静态NAT映射来避免
5.静态NAT 1）概述 静态NAT实现私网地址和公网地址的一对一转换。有多少个私网地址就需要配置多少个公网地址。静态NAT不能节约公网地址，但可以起到隐藏内部网络的作用。
内部网络向外部网络发送报文时，静态NAT将报文的源IP地址替换为对应的公网地址；外部网络向内部网络发送响应报文时，静态NAT件发给报文的目的地址替换为相应的私网地址。
2）配置方法 第一种：全局模式下设置静态NAT
第二种：直接在接口上申明nat static
6.动态NAT 动态NAT是指将内部网络的私有IP地址转换为公用IP地址时，IP地址对是不确定的，是随机的，所有被授权访问Internet的私有IP地址可随机转换为任何指定的合法IP地址。也就是说，只要指定哪些内部地址可以进行转换，以及用哪些合法地址作为外部地址时，就可以进行动态转换。
内部地址的一个范围段转换为合理合法的公网范围段。
7.PAT 通过改变外出数据包的源IP地址和源端口并进行端口转换，内部网络的所有主机均可共享一个合法IP地址实现互联网的访问，节约IP。
8.实验 1）静态NAT（一个内网地址对一个公网地址） 端口配置IP
配置静态NAT
测试
PC1（192.168.1.10）ping PC3（200.10.100.2）
PC2（192.168.1.20）ping PC3（200.10.100.2）
并在PC3 e0/0/1抓包
通过抓包可以看出PC1的IP映射为了15.0.0.10，PC2的IP映射为了15.0.0.20
2）动态NAT——PAT（多个内网地址对多个公网地址） 端口配置IP
设置nat分组
[r1]nat address-group 1 15.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b376e7dde96982c18ec5a2734d9c50b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf398f4634c090f48936e5b373425ab9/" rel="bookmark">
			缓冲池（Buffer Pool）介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缓冲池（Buffer Pool）介绍 Buffer Pool 是数据库的一个内存组件，里面缓存了磁盘上的真实数据，Java系统对数据库的增删改操作，主要是这个内存数据结构中的缓存数据执行的。
1.缓冲池的大小 Buffer Pool的默认大小是128M。在实际的生产环境中可以通过参数innodb_buffer_pool_size对 buffer pool进行调整。
2.数据页 数据库的核心数据模型是表 + 字段 + 行的概念。 数据库对数据抽象出一个数据页的概念，将很多行的数据放到一个数据页中。即磁盘中有很多数据页，每个数据页存放很多行数据。
当要更新一行数据的时候，数据库会找到这行数据所在的数据页，然后从磁盘文件中把这行数据所在的数据页加载到 Buffer Pool 中。即Buffer Pool中存放的是一个一个的数据页。
3.缓存页 默认情况下，磁盘中存放的数据页的大小是16KB，即一页数据包含16KB的内容。
Buffer Pool中存放的一个一个的数据页，通常叫做缓存页。（Buffer Pool是一个缓冲池，里面的数据是从磁盘缓存到内存中的）
Buffer Pool中默认情况下，一个缓存页的大小和磁盘上一个数据页的大小是一一对应的，都是16KB。
4.缓存页的描述信息 每个缓存页，都会有一个描述信息，这个描述信息可以认为是用来描述这个缓存页的。比如包含：这个数据页所属的表空间、数据页的编号、这个缓存页在Buffer Pool中的地址以及其他信息。
描述信息也可以叫描述数据、控制数据、元数据等。
描述信息本身也是一块数据，在Buffer Pool中，每个缓存页的描述数据放在最前面，然后各个缓存页放在后面。如下图所示：
需要注意的一点是：
Buffer Pool中的描述数据大概是缓存页大小的 5% 左右，也就是每个描述数据大概是800个字节左右的大小。
假设设置的Buffer Pool大小是128MB，实际上Buffer Pool真正的最终大小会超出一些，可能会有130多MB大小，因为还要存放每个缓存页的描述信息。
5.Buffer Pool可能存在的内存碎片 Buffer Pool的大小是人为设定的，很可能划分完所有的缓存页和描述数据块之后，还剩一点点的内存，这一点点内存放不下任何一个缓存页了，就没办法使用了，也就变成了内存碎片。
同时，再划分缓存页和描述数据块的时候，会让它们紧密的挨在一起，这样能尽可能的减少内存浪费，就尽可能的减少内存碎片的产生了。
如果缓存页东一块西一块，必然有很多间隙，就形成了内存碎片。
6.Buffer Pool的初始化 数据库启动的时候，会按照Buffer Pool设置的大小，加上描述数据的大小，去申请一块内存作为Buffer Pool的内存区域。
当内存区域申请之后，数据库就会按照默认的缓存页的16KB的大小和800字节左右的描述数据的大小，在Buffer Pool中划分出一个一个的缓存页和一个一个对应的描述数据。
此时，Buffer Pool中一个一个的缓存页都是空的，等数据库运行起来之后，要进行增删改查的操作时，才会把数据对应的数据页从磁盘文件中读取出来，放入Buffer Pool中的缓存页中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c6dcb21bd548ca6a149cdfbfbf6085a/" rel="bookmark">
			matlab绘图 subplot函数使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在平铺位置创建坐标轴
语法
①subplot(m,n,p)
subplot(m,n,p) 将当前图形划分为 m×n 网格，并在 p 指定的位置创建坐标轴。MATLAB® 按行号对子图位置进行编号。第一个子图是第一行的第一列，第二个子图是第一行的第二列，依此类推。如果指定的位置已存在坐标轴，则此命令会将该坐标轴设为当前坐标轴。
②subplot(m,n,p,‘replace’)
subplot(m,n,p,‘replace’) 删除位置 p 处的现有坐标轴并创建新坐标轴。
③subplot(m,n,p,‘align’)
subplot(m,n,p,‘align’) 创建新坐标轴，以便对齐图框。此选项为默认行为。
④subplot(m,n,p,ax)
subplot(m,n,p,ax) 将现有坐标轴 ax 转换为同一图形中的子图。
⑤subplot(‘Position’,pos)
subplot(‘Position’,pos) 在 pos 指定的自定义位置创建坐标轴。使用此选项可定位未与网格位置对齐的子图。指定 pos 作为 [left bottom width height] 形式的四元素矢量。如果新坐标轴与现有坐标轴重叠，新坐标轴将替换现有坐标轴。
⑥subplot(___,Name,Value)
subplot(___,Name,Value) 使用一个或多个名称-值对组参数修改坐标轴属性。有关属性列表，请参阅 Axes 属性。在所有其他输入参数之后设置坐标轴属性。
⑦ax = subplot(___)
ax = subplot(___) 返回创建的 Axes 对象。以后可以使用 ax 修改坐标轴。有关属性列表，请参阅 Axes 属性。
⑧subplot(ax)
subplot(ax) 将 ax 指定的坐标轴设为父图的当前坐标轴。如果父图尚不是当前图形，此选项不会使父图成为当前图形。
示例
（1）上部和下部子图
创建带有两个堆叠子图的图形。在每个子图上绘制一条正弦波。
subplot(2,1,1); x = linspace(0,10); y1 = sin(x); plot(x,y1) title('Subplot 1: sin(x)') subplot(2,1,2); y1 = sin(5*x); plot(x,y2) title('Subplot 2: sin(5x)') （2）子图的象限
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c6dcb21bd548ca6a149cdfbfbf6085a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4193fc8eb0b270de0c709cfb630012a7/" rel="bookmark">
			详细介绍如何在华为云调用SDK的Python代码(以文字识别OCR技术实现身份证识别为例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 保存信息2 安装SDK3 生成代码 1 保存信息 首先我们在首页的产品一栏输入OCR，找到文字识别OCR
然后找到证件类，并点击，然后点击立即使用
进入到文字识别-控制台，找到身份证识别服务，并开通
当显示已开通则表明开通成功！
因为开通使用要钱，我们可以回到首页，点击概述，下拉找到证件OCR的免费试用，点击开通一下。
回到首页，找到产品文档，并点击
然后在SDK参考找到Python SDK，并点击
点击“我的凭证”，跳转到该页面
点击访问密钥
点击新增访问密钥
文字描述我们写身份证识别就好了，然后下载并打开csv文件
打开后我们可以看到有Access Key Id和Secret Access Key两个密钥，简称AK和SK。这个密钥很重要，我们到时候要通过密钥的方式来进入华为云的服务器实现SDK的调用。
然后我们在我的凭证中点击API凭证，获取 “IAM用户名”、“帐号名”以及待使用区域的“项目ID”。调用服务时会用到这些信息，请提前保存。
本样例以“华北-北京四”区域为例，获取对应的项目ID（project_id）
2 安装SDK 支持Python3及以上版本，执行python --version检查当前Python的版本信息。
使用SDK前，需要安装“huaweicloudsdkcore”和“huaweicloudsdkocr”
打开cmd，输入以下两行命令：
# 安装核心库 pip install huaweicloudsdkcore # 安装OCR服务库 pip install huaweicloudsdkocr 安装好后，我们往下拉，找到代码示例自动生成一栏，并点击API Explorer
3 生成代码 跳转之后，我们点击身份证识别，一定不要选错了！！！
我们检查一下Region是否为华北/北京四
Headers的密钥切换为AK/SK模式
检查一下Parameters的project_id是否有误，具体在我的凭证那里查看
然后我们处理Body这一栏，image和url都是传入要识别的图像的，二选一，我们这里选择image为例实现
side代表的是身份证的正反面，front为正面，back为反面，我准备的是反面的身份证，所以填了back
后面两个参数不用管，填true就行
那么我们如何获取image呢？这里要传入的图像数据是base64编码,要求base64编码后大小不超过10MB。图片最小边不小于15px,最长边不超过8000px。支持JPEG、JPG、PNG、BMP、TIFF格式。
下面演示如何获取图像的base64编码：（这里有介绍：如何获取图片base64编码_文字识别 OCR_常见问题_API使用类_华为云 (huaweicloud.com)）
首先我们准备一张图片：
将其拖入到Google Chrome浏览器中
拖入成功后，我们按下F12，在弹出来的页面中，找到Sources，然后点击{ }
然后我们把base64编码复制下来，并粘贴到刚才的image上
因为base64编码特别长，在粘贴的时候卡顿和失败很正常，多试几次直到成功就好了
粘贴好后，我们在线调试一下，点击调试，如果出现调试成功，我们就可以下载SDK代码了，如果失败了就根据提示修改。
我们点击代码示例，下载Python代码
在Pycharm打开后，找到ak和sk，将下载好的csv文件的密钥值添加进去
填好后，我们运行一下，然后可以发现关键信息都识别成功了，大功告成！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4193fc8eb0b270de0c709cfb630012a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e28ca67d455f0b16f052a19e58453b32/" rel="bookmark">
			Python模块selenium实例：电影分类排名数据生成json，sqlite和excel（openpyxl）文件（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中的selenium模块是可以启动浏览器与人交互。我们知道requests模块在网页下载时配合上BeautifluSoup会简单很多，但是随着很多网站越来越注重反爬，会拒绝提供页面，而selenium模块通过启动浏览器像和普通浏览器一样的流量模式使你更容易被接受下载信息，同时长期有效性也会大很多。
这次我们的实例是通过爬取网站IMDb获取电影分类排名数据。需要说明的是这个网站在我们国内登录会有些困难，但是会登的上去，只是没那么顺畅。
同样首先我们先确定好我们的任务：
selenium模块应用的前期准备。IMDb网页分析。通过selenium获取想要的数据信息。将信息格式化。格式化后的信息存储到json，sqlite及excel中。 为此我们需要完成以下操作：
selenium模块安装及安装浏览器的webdriver。确定电影排名的网址以及网页源代码（html）内信息所在的元素。通过find_elements_*方法寻找元素并通过.text方法获取元素内文本。通过对爬取的文本进行格式化为字典模式并添加到列表中方便处理。通过json将每个类别的电影数据分别写入一个json文件，然后将所有的电影汇总写入一个json文件，最后通过sqlite3，openpyxl模块将所有的json文件写入sqlite及excel文件中。 由于内容较多我们分两篇来练习，今天就先完成1-4部分。话不多说就开始练习吧。
首先，准备工作，安装selenium模块这个就不赘述了，大家自行安装。
其次准备工作的另外一项是安装相应的浏览器的webdriver，我自己用的是chrome浏览器，所以需要去ChromePriver下载Windows系统的版本，然后将chromedriver.exe添加到PATH路径上。如果你用的其它浏览器如Firefox，请自行去下载相应的webdriver并添加到环境变量中。
接下来到了分析电影网站的步骤，我们先打开其主页，点击menu中IMDb Top 250 Movies的选项进入top250排名页面会发现此页上的电影排名并没有详细的信息，而且是个总的排名，但是我们注意到页面右边有Top Rated Movies by Genre，这表示每个分类的电影排名，先点击Action动作片分类，进去页面这里提供给我们的信息有：这个排名是在每部至少出租数25000，按照降序排列，每页有50部，默认的是按照IMDb评分排列的，并且有每部电影的详细信息如时长，评分，媒体评分，电影简介，导演，演员，投票数，票房等，这正是我们所需要的，Perfect！
再来分析分析网址的构成，网址如下：
https://www.imdb.com/search/title/?genres=action&amp;sort=user_rating,desc&amp;title_type=feature&amp;title_type=25000,&amp;pf_rd_m=A2FGELUUNOQJNL&amp;pf_rd_p=5aab685f-35eb-40f3-95f7-c53f09d542c3&amp;pf_rd_r=KXNCSE4DS589EV2SE77Q&amp;pf_rd_s=right-6&amp;pf_rd_t=15506&amp;pf_rd_i=top&amp;ref_=chttp_gnr_1
我们看下问号后面的部分，看着挺长，但是我们需要的是
genres，sort，title_type，title_type，同时还有个start表示从第几个开始，上面提到了一页有50个电影，所以start=51则表示第二页，以此类推。
所以我们需要请求的网址为：
https://www.imdb.com/search/title/?genres=action&amp;sort=user_rating,desc&amp;title_type=feature&amp;title_type=25000,&amp;start=1。
网址确定了，下面分析网页的元素，F12打开开发者工具，找到我们所需信息的元素，会发现每部电影的信息都包含在css类名为lister-item-content的div元素内。OK，至此我们完成了页面的分析，下面开始下载数据。
首先我们建立imdbmovies_ranking_bygenre.py文件，首先引入模块：
from selenium import webdriver webdriver提供了很多寻找元素的方法如下：
#使用class类name的元素： browser.find_element_by_class_name(name) browser.find_elements_by_class_name(name) #匹配css selector的元素 browser.find_element_by_css_selector(selector) browser.find_elements_by_css_selector(selector) #匹配id属性值的元素 browser.find_elements_by_id(id) browser.find_elements_by_id(id) #完全匹配提供的text的&lt;a&gt;元素 browser.find_element_by_link_text(text) browser.find_elements_by_link_text(text) #包含提供的text的&lt;a&gt;元素 browser.find_element_by_partial_link_text(text) browser.find_elements_by_partial_link_text(text) #匹配name属性值的元素 browser.find_element_by_name(name) browser.find_elements_by_name(name) #匹配标签name的元素 browser.find_element_by_tag_name(name) browser.find_elements_by_tag_name(name) 需要说明的是browser.find_element和browser.find_elements的区别为，browser.find_element返回第一个匹配的元素，而browser.find_elements则包含页面中匹配的所有元素。同时除了by_tag_name不区分大小写，其它的所有参数都区分大小写。以上所有方法返回的是webelement对象，有了此对象通过text方法获取元素内的文本，所以我们的代码如下：
def movie_lst_data(genres): """Get the data from url""" movie_lst = [] for i in ['1','51']: options = webdriver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e28ca67d455f0b16f052a19e58453b32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee8ad6fb543daf00077d7e9c13cce3f/" rel="bookmark">
			windows常用快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.关闭当前窗口:alt+F4
2.调出任务管理器:
[1]ctrl+alt+del
[2]ctrl+shift+esc
在任务管理器中结束任务的快捷键是alt+e
3.当前窗口最小化:alt+esc
4.最小化所有窗口:windows+m
还原最小化窗口:windows+shift+n
5.显示桌面:windows+d
6.打开微信:ctrl+alt+w
7.打开任务栏的软件:win+X键，X位1，2，3……
8.截屏
[1]截窗口：fn+alt+右上角的键
[2]截全屏：fn+alt
浏览器
[1]打开新标签:ctrl+t
[2]打开新窗口:ctrl+n
在隐身模式下打开新窗口:ctrl+shift+n
[3]全屏显示:f11
[4]关闭当前窗口:alt+f4
关闭所有标签:ctrl+shift+w
关闭当前标签页:ctrl+w或者ctrl+f4
[5]恢复页面为100%:ctrl+0
[6]快速定位到地址栏:alt+D
[7]打开下载管理器:ctrl+J
[8]打开历史记录:ctrl+H
[9]最小化浏览器:alt+空格+N
[10]在当前窗口打开主页:alt+Home
[11]切换标签页:ctrl+1到ctrl+9
ctrl+page up和ctrl+page down
9.资源管理器返回上一层:alt+向上箭头
onenote
[1]想让字母切换为上标:ctrl+shift++
切换为下标:ctrl++
[2]进入公式模式:alt+=
win10系统多桌面切换快捷键?
创建新的虚拟桌面：Win + Ctrl + D
关闭当前虚拟桌面：Win + Ctrl + F4
切换虚拟桌面：Win + Ctrl +方向键左/右
贴靠窗口：Win +左/右&gt; Win +上/下&gt;窗口可以变为1/4大小放置在屏幕4个角落
切换窗口：Alt + Tab(不是新的，但任务切换界面改进)
任务视图：Win + Tab(松开键盘界面不会消失)
eclipse
1.shift+ctrl+t:查找类
2.将代码抽出一个方法:alt+shift+m
IDEA
1. 获取getter和setter方法：Alt+Insert
2. 导入包：ALT+回车
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ee8ad6fb543daf00077d7e9c13cce3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/163cc703d356089607721110bb81f4b1/" rel="bookmark">
			Spring归纳总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Spring是什么?
Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。主要包括以下七个模块：
Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；
Spring Core：核心类库，所有功能都依赖于该类库，提供IOC和DI服务；
Spring AOP：AOP服务；
Spring Web：提供了基本的面向Web的综合特性，提供对常见框架如Struts2的支持，Spring能够管理这些框架，将Spring的资源注入给框架，也能在这些框架的前后插入拦截器；
Spring MVC：提供面向Web应用的Model-View-Controller，即MVC实现。
Spring DAO：对JDBC的抽象封装，简化了数据访问异常的处理，并能统一管理JDBC事务；
Spring ORM：对现有的ORM框架的支持；
下图对应的是Spring 4.x的版本，5.x版本中Web模块的Portlet组件已经被废弃
2、Spring 的优点？
（1）spring属于低侵入式设计，代码的污染极低；
（2）spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；
（3）Spring提供了AOP技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。
（4）spring对于主流的应用框架提供了集成支持。
3、Spring的IoC理解：
（1）什么是IOC：
IOC，Inversion of Control，控制反转，指将对象的控制权转移给Spring框架，由 Spring 来负责控制对象的生命周期（比如创建、销毁）和对象间的依赖关系。 最直观的表达就是，以前创建对象的时机和主动权都是由自己把控的，如果在一个对象中使用另外的对象，就必须主动通过new指令去创建依赖对象，使用完后还需要销毁（比如Connection等），对象始终会和其他接口或类耦合起来。而 IOC 则是由专门的容器来帮忙创建对象，将所有的类都在 Spring 容器中登记，当需要某个对象时，不再需要自己主动去 new 了，只需告诉 Spring 容器，然后 Spring 就会在系统运行到适当的时机，把你想要的对象主动给你。也就是说，对于某个具体的对象而言，以前是由自己控制它所引用对象的生命周期，而在IOC中，所有的对象都被 Spring 控制，控制对象生命周期的不再是引用它的对象，而是Spring容器，由 Spring 容器帮我们创建、查找及注入依赖对象，而引用对象只是被动的接受依赖对象，所以这叫控制反转。 （2）什么是DI：
IoC 的一个重点就是在程序运行时，动态的向某个对象提供它所需要的其他对象，这一点是通过DI（Dependency Injection，依赖注入）来实现的，即应用程序在运行时依赖 IoC 容器来动态注入对象所需要的外部依赖。而 Spring 的 DI 具体就是通过反射实现注入的，反射允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性 （3）IoC的原理：
Spring 的 IoC 的实现原理就是工厂模式加反射机制，而在 Spring 容器中，Bean 对象如何注册到 IoC 容器，以及Bean对象的加载、实例化、初始化详细过程可以阅读这篇文章：Spring的Bean加载流程_张维鹏的博客-CSDN博客 4、Spring的AOP理解：
OOP面向对象，允许开发者定义纵向的关系，但并不适用于定义横向的关系，会导致大量代码的重复，而不利于各个模块的重用。
AOP，一般称为面向切面，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，提高系统的可维护性。可用于权限认证、日志、事务处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/163cc703d356089607721110bb81f4b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0290f9faedaa15c55fb2c511fe3ef5b/" rel="bookmark">
			TypeScript 编译选项之tsconfig.json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TypeScript 编译选项之tsconfig.json 文章目录 TypeScript 编译选项之tsconfig.json选项配置详解1. files2. include3. exclude4. extends5. compilerOptions5.1 target5.2 module5.3 lib5.4 outDir5.5 outFile5.6 allowJs5.7 checkJs5.8 removeComments5.9 noEmit5.10 noEmitOnError5.11 alwaysStrict5.12 noImplicitAny5.13 strictNullChecks5.14 strict5.15 sourceMap5.16 noUnusedParameters5.17 noUnusedLocals5.18 experimentalDecorators5.19 emitDecoratorMetadata5.20 esModuleInterop tsconfig.json是 ts编译器的配置文件， ts编译器是根据这个配置文件来进行编译代码的，一般我们会把 tsconfig.json这个文件，放在工程的根目录下，所以可以通过 tsconfig.json来界定根目录. 选项配置详解 tsconfig.json文件的顶层属性有这些：files,include,exclude,compileOnSave, extends,typeAcquisition,watchOptions,reference,虽然顶层属性有这7个，但是我们实际项目中，常用的，也就那么几个，下面会详细说说，常用选项
1. files 数组类型，指定被编译的文件列表，只有需要编译少量文件才会用到。
{ //配置项内容是一个数组列表 "files": ["index.ts","system.ts","utils.ts"] } 2. include 数组类型，用来指定，哪些文件需要被编译
{ //配置项内容是一个数组列表 "include": ["./src/**/*"] } 表示需要编译当前目录下的src下的任意文件目录和任意文件
**表示任意目录*表示任意文件 上述配置，是可以精确到相应目录和文件，指定来编译，如果我们不需要指定特定的某文件时，可以直接指定其根目录进行编译，就不用那么麻烦，比如直接指定src就可以
{ "include": ["src",'libs'] } 3. exclude 数组类型，用来指定不需要被编译的文件，默认排除node_modules,一般在项目中，我们有不少文件是不需要被编译的，比如node_modules,dist等
{ //配置项内容是一个数组列表 "exclude": ["node_modules","dist"] } 同include一样，也是可以精确到相应目录和文件的，如果我们不需要编译工程文件中的.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0290f9faedaa15c55fb2c511fe3ef5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab04f12b27e07874c155af7456eb373/" rel="bookmark">
			在servlet程序中使用getRequestDispatcher方法跳转到jsp页面失败解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Web中的相对路径与绝对路径，web中/斜杠的不同含义1.Web中的相对路径与绝对路径2.Web中/斜杠的不同意义 二、问题解决方法问题出现的几种情况 总结 前言 在servlet程序中使用getRequestDispatcher方法跳转到jsp页面时报错，首先我们要了解一下服务器和浏览器之间解析的路径差别与不同含义
一、Web中的相对路径与绝对路径，web中/斜杠的不同含义 1.Web中的相对路径与绝对路径 在JavaWeb中路径分为相对路径与绝对路径
相对路径是：
. 一个点表示当前目录 . . 两个点表示上一级目录 资源名 表示当前目录/资源名 绝对路径是：
http://ip:port/工程路径/资源路径 在实际开发中都使用绝对路径或者base+相对路径
2.Web中/斜杠的不同意义 在web中/斜杠是绝对路径
/斜杠如果被浏览器解析得到的地址是：http://ip:port/
例如&lt;a href="/"&gt;斜杠&lt;/a&gt; /斜杠如果被服务器解析得到的地址是http://ip:port/工程路径
例如1、&lt;url-pattern&gt;/servlet1&lt;/url-pattern&gt; 2、servletContext.getRealPath(“/”); 3、request.getRequestDispatcher(“/”);注意这个方法，直接默认进入工程路径下面，哪怕直接request.getRequestDispatcher(“”)里面没有具体路径也直接进入工程路径。 比如这张图所写的一样，我填的完整的绝对路径，访问后提示
http前面还有“/”，说明这个方法被解析的时候是默认进入工程路径中去的。
特殊情况： response.sendRediect(“/”); 把斜杠发送给浏览器解析。得到 http://ip:port
二、问题解决方法 问题出现的几种情况 要注意的是我们必须使用绝对路径，不能使用相对路径，servlet.java是在src目录下，我这里将Java目录设置为我的源码目录，jsp是在webapp目录下，彼此不存在相对关系；
我目的是从Action.java这个servlet程序跳转到info.jsp文件中去，我一开始是这样设置的路径
于是乎出现了这这种报错，为什么呢？getRequestDispatcher方法它是由Tomcat服务器解析，这个时候解析出来的路径明显是去不了test目录下的，于是乎我把它改成了. ./info.jsp
这个时候运行服务器就变成了这个
这个说明文件已经找到了，但是服务器里面有问题，这两个文件不存在相对关系啊，我们使用绝对路径试试，
运行结果：
可以了！
总结 向这个作者学习https://blog.csdn.net/Java_stud/article/details/80551681
好好学习天天向上！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1992c0b75c31c148e1f8b9131e36faae/" rel="bookmark">
			MySQL备份恢复练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL备份恢复练习 素材备份恢复要求1. 备份数据库school到/backup目录2. 备份数据库school为带删除表的格式，能够让该备份覆盖已有数据库而不需要手动删除原有数据库3. 直接将数据库school压缩备份4. 备份数据库school某个(些)表（此例备份student表 ）5. 同时备份多个MySQL数据库（其他数据库素材自行准备）6. 仅仅备份数据库结构7. 备份服务器上所有数据库8. 还原MySQL数据库9. 还原压缩的MySQL数据库10. 使用xtrabackup 备份数据库11. 在另外的数据库服务器上还原xtrabackup 备份12. 使用mydumper备份数据库13. 使用mydumper恢复数据库 素材 创建数据库school CREATE DATABASE school; 创建student和score表 CREATE TABLE student ( id INT(10) NOT NULL UNIQUE PRIMARY KEY , name VARCHAR(20) NOT NULL , sex VARCHAR(4) , birth YEAR, department VARCHAR(20) , address VARCHAR(50) ); 创建score表。SQL代码如下： CREATE TABLE score ( id INT(10) NOT NULL UNIQUE PRIMARY KEY AUTO_INCREMENT , stu_id INT(10) NOT NULL , c_name VARCHAR(20) , grade INT(10) ); 为student表和score表增加记录 #向student表插入记录的INSERT语句如下： INSERT INTO student VALUES( 901,'张老大', '男',1985,'计算机系', '北京市海淀区'); INSERT INTO student VALUES( 902,'张老二', '男',1986,'中文系', '北京市昌平区'); INSERT INTO student VALUES( 903,'张三', '女',1990,'中文系', '湖南省永州市'); INSERT INTO student VALUES( 904,'李四', '男',1990,'英语系', '辽宁省阜新市'); INSERT INTO student VALUES( 905,'王五', '女',1991,'英语系', '福建省厦门市'); INSERT INTO student VALUES( 906,'王六', '男',1988,'计算机系', '湖南省衡阳市'); #向score表插入记录的INSERT语句如下： INSERT INTO score VALUES(NULL,901, '计算机',98); INSERT INTO score VALUES(NULL,901, '英语', 80); INSERT INTO score VALUES(NULL,902, '计算机',65); INSERT INTO score VALUES(NULL,902, '中文',88); INSERT INTO score VALUES(NULL,903, '中文',95); INSERT INTO score VALUES(NULL,904, '计算机',70); INSERT INTO score VALUES(NULL,904, '英语',92); INSERT INTO score VALUES(NULL,905, '英语',94); INSERT INTO score VALUES(NULL,906, '计算机',90); INSERT INTO score VALUES(NULL,906, '英语',85); 备份恢复要求 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1992c0b75c31c148e1f8b9131e36faae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/945b93be10964c8f875d8ac9d97a127c/" rel="bookmark">
			【学习笔记】可视化工具之 Superset
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可视化工具之 Superset 第1章 Superset入门1.1 Superset概述1.2 Superset应用场景 第2章 Superset安装及使用2.1 安装Python环境2.1.1 安装Miniconda2.1.2 创建Python3.7环境 2.2 Superset部署2.2.1 安装依赖2.2.2 安装Superset2.2.3 启动Supterset2.2.4 superset启停脚本 第3章 Superset使用3.1 对接MySQL数据源3.1.1 安装依赖3.1.2 重启Superset3.1.3 数据源配置 尚硅谷大数据项目之尚品汇（可视化报表）
版本：V4.0
第1章 Superset入门 1.1 Superset概述 Apache Superset是一个开源的、现代的、轻量级BI分析工具，能够对接多种数据源、拥有丰富的图表展示形式、支持自定义仪表盘，且拥有友好的用户界面，十分易用。
1.2 Superset应用场景 由于Superset能够对接常用的大数据分析工具，如Hive、Kylin、Druid等，且支持自定义仪表盘，故可作为数仓的可视化工具。
第2章 Superset安装及使用 Superset官网地址：http://superset.apache.org/
2.1 安装Python环境 Superset是由Python语言编写的Web应用，要求Python3.7的环境。
2.1.1 安装Miniconda conda是一个开源的包、环境管理器，可以用于在同一个机器上安装不同Python版本的软件包及其依赖，并能够在不同的Python环境之间切换，Anaconda包括Conda、Python以及一大堆安装好的工具包，比如：numpy、pandas等，Miniconda包括Conda、Python。
此处，我们不需要如此多的工具包，故选择MiniConda。
1）下载Miniconda（Python3版本）
下载地址：https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
2）安装Miniconda
（1）执行以下命令进行安装，并按照提示操作，直到安装完成。
[atguigu@hadoop102 lib]$ bash Miniconda3-latest-Linux-x86_64.sh （2）在安装过程中，出现以下提示时，可以指定安装路径
（3）出现以下字样，即为安装完成
3）加载环境变量配置文件，使之生效
[atguigu@hadoop102 lib]$ source ~/.bashrc 4）取消激活base环境
Miniconda安装完成后，每次打开终端都会激活其默认的base环境，我们可通过以下命令，禁止激活默认base环境。
[atguigu@hadoop102 lib]$ conda config --set auto_activate_base false 2.1.2 创建Python3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/945b93be10964c8f875d8ac9d97a127c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/447fe0acef96626af95ff18b0916e0b7/" rel="bookmark">
			关于SQL调优、如何养成书写高质量SQL，由浅及深持续更新中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题 如何进行调优------------及原理基础调优常规调优思维巧用where条件合理使用limit分页优化你的like语句合理选择 in 跟 exists 中级调优思维尽量避免在索引列上使用mysql的内置函数join 、 union 篇幅合理使用索引如果数据量较大，优化你的插入、修改、删除语句、慎用distinct关键字（用EXISTS代替DISTINCT去重）高效的删除重复记录sql不要有超过5个以上的表连接 高级调优思维尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型尽量避免向客户端返回过多数据量。索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。当在SQL语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。尽可能使用varchar/nvarchar 代替 char/nchar。为了提高group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。sql优化中，一个重要的基本原则就是“永远用小结果集驱动大的结果集”。合理选择TRUNCATE跟DELETE 终极调优思维使用explain 分析你SQL的计划 网址推荐-------------------------书写高质量SQL的30条建议 前言：之前一直也没研究太多关于sql调优的知识，仅仅停留在能查出自己想要的数据即可，从不考虑查询成本，虽然在面试中也会经常问到此类问题，也只是死记几条。但为了更好的发展，建议早点研究基本原理进而在深入理解，在平时尽量养成规范的编码习惯，平时也要善于总结，及时应用不用背就能记住，在说到这块就能侃侃而谈。 内容有很多，后续慢慢补齐，持续更新中。 如何进行调优------------及原理 基础调优 常规调优思维 1、查询SQL尽量不要使用select *，而是select具体字段。 只取需要的字段，节省资源、减少网络开销。 select * 进行查询时，很可能就不会使用到覆盖索引了， 就会造成回表查询。 巧用where条件 1、应尽量避免在where子句中使用or来连接条件。 反例:select * from user where userid=1 or age =18 正例：//使用union all select * from user where userid=1 union all select * from user where age = 18 使用or可能会使索引失效，从而全表扫描。 对于or+没有索引的age这种情况，假设它走了userId的索引，但是走到age查询条件时，它还得全表扫描， 也就是需要三步过程：全表扫描+索引扫描+合并 如果它一开始就走全表扫描，直接一遍扫描就完事。 mysql是有优化器的，处于效率与成本考虑，遇到or条件，索引可能失效，看起来也合情合理。 2、使用where条件限定要查询的数据，避免返回多余的行。 需要什么数据，就去查什么数据，避免返回不必要的数据，节省开销。 3、应尽量避免在 where 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫。 反例：select * from user where age-1 =10； 正例：select * from user where age =11； 理由：虽然age加了索引，但是因为对它进行运算，索引直接迷路了。。。 4、应尽量避免在 where 子句中使用!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/447fe0acef96626af95ff18b0916e0b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f918b9d966fa7602872707cfad9d12f/" rel="bookmark">
			libevent 报 undefined reference to `getrandom‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /home/xxx/libevent.a(evutil_rand.o): In function `arc4_seed_getrandom': /home/xxx/open_src/libevent-2.1.12-stable/./arc4random.c:188: undefined reference to `getrandom' collect2: error: ld returned 1 exit status 主要原因是libevent.a 是在一台具有getrandom系统调用的机器上编译的，可看下图
❰ape❙❱✔≻ nm libevent.a | grep random 0000000000000100 t bev_group_random_element_ 0000000000000000 b arc4random_urandom_filename 0000000000000000 t arc4_seed_urandom_helper_ 0000000000000520 T evutil_secure_rng_set_urandom_device_file U getrandom 0000000000004600 T evdns_set_random_bytes_fn 当该库在一台不具有getrandom的机器上使用的时候，就会出现问题。
getrandom() was introduced in version 3.17 of the Linux kernel. Support was added to glibc in version 2.25. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57216120b85d93a21cbfd3663bfd4754/" rel="bookmark">
			Failed to set locale, defaulting to C.UTF-8解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 8Linux系统提示“Failed to set locale, defaulting to C.UTF-8”，这是由于没有配置正确的语言环境导致的，Linux百科：使用root账户登录你的CentOS操作系统，然后执行两条命令：
Failed to set locale, defaulting to C.UTF-8
echo "export LC_ALL=en_US.UTF8" &gt;&gt; /etc/profile
source /etc/profile
分别执行上方两条命令，即可解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf2c4bc299d337711832f2945024ab2/" rel="bookmark">
			Java中Lambda表达式使用及详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中Lambda表达式使用及详解 前言 一、Lambda表达式的简介 Lambda表达式（闭包）：java8的新特性，lambda运行将函数作为一个方法的参数，也就是函数作为参数传递到方法中。使用lambda表达式可以让代码更加简洁。
Lambda表达式的使用场景：用以简化接口实现。
关于接口实现，可以有很多种方式来实现。例如：设计接口的实现类、使用匿名内部类。 但是lambda表达式，比这两种方式都简单。
package test; /** * @author: Mercury * Date: 2022/3/20 * Time: 17:48 * Description:Lambda表达式 * Version:1.0 */ public class Test04 { public static void main(String[] args) { //使用lambda表达式实现接口 Test test = () -&gt; { System.out.println("test"); }; test.test(); } } interface Test{ public void test(); } 二、Lambda表达式对接口的要求 虽然说，lambda表达式可以在⼀定程度上简化接口的实现。但是，并不是所有的接口都可以使用lambda表达式来简洁实现的。
lambda表达式毕竟只是⼀个匿名方法。当实现的接口中的方法过多或者多少的时候，lambda表达式都是不适用的。
lambda表达式，只能实现函数式接口。
1.函数式接口 如果说，⼀个接口中，要求实现类必须实现的抽象方法，有且只有⼀个！这样的接口，就是函数式接口。
代码如下（示例）：
//有且只有一个实现类必须要实现的抽象方法，所以是函数式接口 interface Test{ public void test(); } 2.@FunctionalInterface 是⼀个注解，用在接口之前，判断这个接口是否是⼀个函数式接口。 如果是函数式接口，没有任何问题。如果不是函数式接口，则会报错。功能类似于 @Override。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebf2c4bc299d337711832f2945024ab2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daff8913fd97267062665de2dc0c6c63/" rel="bookmark">
			Windows10蓝牙驱动丢失，100%解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开控制面板
2.设备和打印机
3.找到如下设备(应该会有个!警告）
4.右键-&gt;疑难解答
5.一步步修复，最后关机重启即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4624589804683212f74cb33d00f790b/" rel="bookmark">
			Oracle 数据库基础学习 (七) SQL语句综合练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、多表查询综合练习
1、 列出高于在30部门工作的所有人员的薪金的员工的姓名、部门名称、部门编号、部门人数
分析:
需要的员工信息：
|-emp表：姓名、部门编号
|-dept表：部门名称、部门编号
|-emp表：统计部门人数
确认关联关系：
emp.deptno=dept.deptno
1) 查询出在30部门工作的所有人员的薪金
select sal from emp where deptno=30 ; 2) 找出工资大于30部门的员工的姓名、部门编号（返回多行单列数据，在where子句子查询）
select e.ename, e.deptno, e.sal from emp e where e.sal &gt;all (select sal from emp where deptno=30) ; 3) 统计显示部门的名称
select e.deptno, e.sal, d.dname from emp e, dept d where sal &gt;all (select sal from emp where deptno=30) and (d.deptno = e.deptno) ; 4) 在emp表中统计出部门的各个人数，子查询中查询部门人数，返回多行多列表
select deptno dno, count(empno) count from emp group by deptno ; 5) 多行多列表在from子句中查询结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4624589804683212f74cb33d00f790b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/683f38d1304ece2770249b8b1b0f606a/" rel="bookmark">
			解决Windows系统Python3.X嵌入式发行版没有tkinter库问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将常规Python发行版（或者anaconda版本）中的以下目录文件复制到嵌入式版本中即可：
1、将常规版本中tcl目录复制到嵌入式版本的安装目录中。
2、将常规版本中tkinter目录复制到嵌入式版本的安装目录的Lib/site-packages中。（必须是Lib/site-packages，不能在Lib中，不然失败）
3、在嵌入式版本中建一个DLLs文件夹，将常规版本中_tkinter.pyd tcl86t.dll tk86t.dll三个文件复制到嵌入式版本的安装目录/DLLs中。（或者直接放到安装目录中）
4、在python3x._pth文件中添加一行，内容为：.\DLLs。否则将报错为"import _tkinter # If this fails your Python may not be configured for Tk ModuleNotFoundError: No module named '_tkinter'"，
————————————————
版权声明：本文为CSDN博主「zhangjunli」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zhangjunli/article/details/106858469
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d75836f7c060a6355071a9f2c5bbc25/" rel="bookmark">
			连锁多门店收银系统之进销存的采购进货单源码功能逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		连锁多门店管理收银系统的进销存体系介绍01期之---采购进货单列表页功能介绍。
一，收银收银系统源码的采购进货单列表
1，采购进货单的类型
适应于“商户总部进货”和“直营进货”两种进货类型，总部进货并入库完成后，所有库存暂存与总部仓库，用于各个门店的要货/调拨等操作
2，总部的进货及下级门店的进货 所有直营门店向供应商进货由总部操作完成，所有加盟门店可自行向供应商进货
3，采购进货单据的筛选
本列表是连锁门店的商家端后台，显示商家总仓以及所有直营门店的进货记录。可通过筛选仓库/门店，供应商、进货类型等字段筛选
4，进货单据的概况统计
本列表页同时显示博弈收银系统源码的进货采购单据数量，进货sku总数量，以及采购进货单的总金额。起到实时概况统计的作用。
5，采购进货单据的表格导出
除了基础的单据信息展示外，还可以实现采购进货单据的实时excel表格导出，导出数据维度丰富。涉及：商品基础信息，进货数量，库存单位，进货单位，含税/不含税金额、物流信息等。可满足绝大多数实体连锁商家的进销存统计需求。
6，商户进货及直营进货的名词解释
商户进货：商家总部（总仓）直接向供应商进货，供应商直接送达总部仓库的进货订单。
直营进货：商户根据直营连锁门店的要货申请/库存情况，代替直营门店向供应商进行采购进货，供应商直接送达门店的进货订单。
7，其他
当然，如果觉着现有功能无法完全满足自己的业务场景需求，连锁多门店saas收银系统还能提供源码版本，独立私有部署，前提是要么你具备开发能，要么付的起一定的外包开发费用，这个具体根据自己来定。
总之，门店管理系统的进销存体系中，采购进货单不所谓不重要，还是需要用心做好产品。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efc636caa1599c0a4845be1fae9ae06e/" rel="bookmark">
			递归算法之八皇后问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		八皇后问题（英文：Eight queens），是由国际象棋棋手马克斯·贝瑟尔于1848年提出的问题，是回溯算法的典型案例。
问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。如果经过±90度、±180度旋转，和对角线对称变换的摆法看成一类，共有42类。计算机发明后，有多种计算机语言可以编程解决此问题。
首先是解题的思路：for循环的嵌套 遍历每一种结果
//依次放入皇后 判断是否冲突 for (int i = 0; i &lt; max; i++) { array[n]=i; if (judge(n)){ check(n+1); } //如果不冲突就继续执行array[n]=i 即将第n个皇后 放置在本行后移的一个位置 } 解题思路详解： 放置皇后的时候 n=0;直接开始第一次for循环 将一个行的第一个位置放置一个皇后 然后开始第二次for循环 进入第二次for循环的时候n已经+1开始遍历第二行 知道与第一个不冲突 开始第三次for循环 一样的道理 知道第三个与第一个和第二个都不冲突放入 直到放完最后一个 开始回溯 假如中途退出 比如放置第三个的时候每个位置都行不通 就会直接回溯 找出第二个还能放置的位置 在进入遍历第三个 放完一次 回溯到上一位 让上一位换个位置 在进入 让下一位接着遍历每一次 知道前面7个位置所有的方式都遍历完之后 首位才会发生改变 这就是输出结果为什么首位都是按序排列 因为 每一位的每一种可能都考虑到了。
开始的流程图解如下 回溯的时候差不多大致相同
这里到达顶层了 他会回到皇后7这里 让他后移一位 然后继续回到皇后8 从头遍历看看还有没有合适的解答 假如没有就会回到7 7往后遍历 然后再进8 都没有之后就会进入6 6遍历后移再进7 知道回溯到皇后1 皇后1后移继续开始最开始的流程往上走 走到头再像老样子往后走。
解释完 这里直接放代码了 定义一个输出方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efc636caa1599c0a4845be1fae9ae06e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cca15328b9b8b3655b116b15f0c7e55/" rel="bookmark">
			【按键精灵】＜＜失落的方舟＞＞混沌地牢退场的逻辑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tt1=进入混沌之后开始计时，如果黑狂，就变身，否则不变身。
tt2=找怪并打怪一定时间后的计时
当处于第一层，此时 tt2 - tt1的时间大于45秒，小于120秒，怪没打完也要退场。
当找怪打怪后，发现有进入第二层光门的按钮G，则按下G，
当没发现按钮G，则找小地图光门，走过去，直到发现按钮G
进入第二层后，重置tt1的时间，作为进入混沌的时间
tt2 - tt1就是 退场时间判断
如果处于第二层，退场时间 &gt; 辅助上面设置的 【二层退场时间】，退出混沌
不论处于哪一层，退场时间 &gt; 辅助上面设置的 【超时退出时间】，退出混沌
Q：怎么判断处在第几层？
A：一进入混沌， 所在混沌层 = 0；从光门按G进入，所在混沌层 = 2
伪代码：
If Form1.黑狂变身.Value = 1 Then TracePrint "黑狂变身！" KeyPress "Z", 1 Delay 100 End If 所在混沌层数 = 0 tt1 = dm.GetTime() Call 转圈找特征刷精英怪2加半魔变身(Form1.圈数.Text, Form1.间距.Text, Form1.循环.Text) Delay 50 dm.moveto 自己位置x, 自己位置y Delay 50 If 所在混沌层数 &lt;&gt; 2 Then Call 找混沌第二层光门() Delay 50 ElseIf 所在混沌层数 = 2 Then Call 找混沌精英怪() Delay 50 Call 找混沌红Boss() Delay 50 End If tt2 = dm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cca15328b9b8b3655b116b15f0c7e55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a205f58175f2c87ea2193cf3ea2f307/" rel="bookmark">
			汇编指令--数据传输指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.数据传输指令 指令包括：MOV,XCHG,XLAT,LEA,LDS,LES,PUSH,POP,PUSHF,LAHF,SAHF,POPF,IN,OUT
重点掌握：MOV,XCHG,XLAT,LEA,PUSH,POP
1.MOV指令（move) 作用：把一个字或者字节的操作数从源地址传送到目标地址
;使用格式： ;mov target,source ;mem表示内存，imm表示立即数（数据），seg表示段寄存器 mov reg/mem,imm ;mov ax,0123H mov reg/mem/seg,reg ;mov bx,ax mov reg/seg,mem mov reg/mem,seg 注意事项：有source决定target的范围
1.target不能时CS（代码段寄存器）
2.target和source不能同时为内存数，段寄存器（CS/DS/ES/SS/FS/GS)
3.不能将立即数传送给段寄存器
4.target和source必须类型匹配，比如，要么都是字节，要么都是字或者都是双字等。
5.由于立即数没有明确的类型，所以将立即数传送到target时，系统会自动将立即数零扩展到与target数的位数相同，再进行传送。有时，需要用BYTE PTR,WORD PTR明确指出立即数的位数
图示解析：
REG可以和REG，MEM，段寄存器，进行数据交流
im可以和REG，MEM进行数据交路
CS可以和REG，MEM进行数据交流
段寄存器可以和REG，MEM进行数据交流
MEM可以和段寄存器，REG进行数据交流
示例：
mov al,4 ;将4以字节的形式传送给al寄存器，为字节传送 mov cx,00FFH ;将00FFH传送给CX寄存器，上述的4和00FF都为立即数，cx,al均为reg mov si,0200H ;将0200H传送给寄存器si，为字传送 mov ax,bx ;将bx中的内容传送给ax，属于寄存器之间的操作 mov byte ptr [si] , 0ah ;byte ptr说明是字节操作 mov ds,ax ;将ax中的内容传送给段寄存器ds，属于段寄存器（seg）和寄存器之间的传送 mov [si],al ;将al中的内容传递给段寄存器ds，属于段寄存器（seg）和寄存器之间的传送 ;说明： [bp]---&gt;ss:[bp] [si]---&gt;ds:[si] ds作为段地址，si作为偏移地址 [bx]---&gt;ds:[bx] 代码演示如下： 2.XCHG指令(exchange) 作用：将一个字节或者自己的源操作数和目的操作数相交换
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a205f58175f2c87ea2193cf3ea2f307/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a714cd4b364b90962ed7284fc7501aba/" rel="bookmark">
			MybatisPlus多表连接查询 支持一对一、一对对、多对多查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MybatisPlus多表连接查询 支持一对一、一对对、多对多查询 一、序言 （一）背景内容
软件应用技术架构中DAO层最常见的选型组件为MyBatis，熟悉MyBatis的朋友都清楚，曾几何时MyBatis是多么的风光，使用XML文件解决了复杂的数据库访问的难题。时至今日，曾经的屠龙者终成恶龙，以XML文件为基础的数据库访问技术变得臃肿、复杂，维护难度直线上升。
MybatisPlus对常见的数据库访问进行了封装，访问数据库大大减少了XML文件的依赖，开发者从臃肿的XML文件中获得了较大限度的解脱。
MybatisPlus官方并没有提供多表连接查询的通用解决方案，然而连接查询是相当普遍的需求。解决连接查询有两种需求，一种是继续使用MyBatis提供XML文件解决方式；另一种本文提供的解决方案。
事实上笔者强烈推荐彻底告别通过XML访问数据库，并不断探索新式更加友好、更加自然的解决方式，现分享最新的MybatisPlus技术的研究成果。
（二）场景说明
为了说明连接查询的关系，这里以学生、课程及其关系为示例。
（三）前期准备
此部分需要读者掌握以下内容：Lambda 表达式、特别是方法引用；函数式接口；流式运算等等，否则理解起来会有些吃力。
实体类与 Vo 的映射关系，作者创造性的引入特别构造器，合理利用继承关系，极大的方便了开发者完成实体类向 Vo 的转换。
空指针异常忽略不处理，借助[Optional]类实现，详情移步[Java8 新特性]查看。
二、一对一查询 一对一查询最典型的应用场景是将id替换成name，比如将userId替换成userName。
（一）查询单条记录
查询单条记录是指返回值仅有一条记录，通常是以唯一索引作为条件的返回查询结果。
1、示例代码
/** * 查询单个学生信息（一个学生对应一个部门） */ public UserVo getOneUser(Integer userId) { LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers.lambdaQuery(User.class) .eq(User::getUserId, userId); // 先查询用户信息 User user = userMapper.selectOne(wrapper); // 转化为Vo UserVo userVo = Optional.ofNullable(user).map(UserVo::new).orElse(null); // 从其它表查询信息再封装到Vo Optional.ofNullable(userVo).ifPresent(this::addDetpNameInfo); return userVo; } 附属表信息补充
/** * 补充部门名称信息 */ private void addDetpNameInfo(UserVo userVo) { LambdaQueryWrapper&lt;Dept&gt; wrapper = Wrappers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a714cd4b364b90962ed7284fc7501aba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87ab044915ce14d8417e041d4b4f7a76/" rel="bookmark">
			Windows下载安装Intel RealSense SDK2.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址：
https://github.com/IntelRealSense/librealsense/releases
选择下载Intel.RealSense.SDK-WIN10-2.50.0.3785.exe
安装
（1）双击击Intel.RealSense.SDK-WIN10-2.50.0.3785.exe（弹出提示，点击运行）
（2）点击next。
（3）点击next。（SDK 包括 RealSense Viewer，以及各种编程语言的开发包。）
（4）允许向桌面添加两个快捷方式，点击next。
（5）安装前检查，点击Install。
（6）点击Finish。
连接相机，在Intel RealSense viewer 看到相机影像，表示安装成功！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3174b91e7b5e658c26342cf24bf9981/" rel="bookmark">
			常见的vue安装失败问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装环境问题 bug现象 原因 由于系统命令是靠[Path]环境变量来实现的而yuan安装的全局路径没有配置到环境变量中，所有无法识别该命令 解决方案 将yarn装的全局包路径配置到path环境变量中即可 步骤 查看yarn全局包安装路径
yarn global bin
查询出来的路径复制下来，打开电脑的环境变量配置 选择Path路径新建一个路径把刚刚查询到的路劲粘贴进去就可以了
检验安装完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e8de58960d127ace64b69c8e0202178/" rel="bookmark">
			python深度学习库keras——各类网络层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全栈工程师开发手册 （作者：栾鹏）
python教程全解
一、网络层 keras的层主要包括：
常用层（Core）、卷积层（Convolutional）、池化层（Pooling）、局部连接层、递归层（Recurrent）、嵌入层（ Embedding）、高级激活层、规范层、噪声层、包装层，当然也可以编写自己的层。
对于层的操作
layer.get_weights() #返回该层的权重（numpy array） layer.set_weights(weights)#将权重加载到该层 config = layer.get_config()#保存该层的配置 layer = layer_from_config(config)#加载一个配置到该层 #如果层仅有一个计算节点（即该层不是共享层），则可以通过下列方法获得输入张量、输出张量、输入数据的形状和输出数据的形状： layer.input layer.output layer.input_shape layer.output_shape #如果该层有多个计算节点。可以使用下面的方法 layer.get_input_at(node_index) layer.get_output_at(node_index) layer.get_input_shape_at(node_index) layer.get_output_shape_at(node_index) 1、常用网络层 1.1、Dense层(全连接层）
keras.layers.core.Dense(units,activation=None,use_bias=True,kernel_initializer='glorot_uniform',bias_initializer='zeros',kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None) 参数：
units：大于0的整数，代表该层的输出维度。use_bias：布尔值，是否使用偏置项kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。bias_initializer：偏置向量初始化方法，为预定义初始化方法名的字符串，或用于初始化偏置向量的初始化器。regularizer：正则项，kernel为权重的、bias为偏执的，activity为输出的constraints：约束项，kernel为权重的，bias为偏执的。activation：激活函数，为预定义的激活函数名（参考激活函数），或逐元素（element-wise）的Theano函数。如果不指定该参数，将不会使用任何激活函数（即使用线性激活函数：a(x)=x）input_dim：该层输入的维度 本层实现的运算为
o u t p u t = a c t i v a t i o n ( d o t ( i n p u t , k e r n e l ) + b i a s ) output = activation(dot(input, kernel)+bias) output=activation(dot(input,kernel)+bias)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e8de58960d127ace64b69c8e0202178/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8133f7d24d1bd6d11fb56c6cec132b9/" rel="bookmark">
			postman接口执行速度比网页调用接口快的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：
经常在测试人员看见页面加载缓慢就会提个bug让前端同学优化，前端同学看到是接口加载缓慢，于是前端同学通知后端同学，后端同学用postman跑了一下，告诉前端，我这很快啊，于是就进入了撕逼甩锅的过程。。。
区别的原因：
原因1：https请求的时候，web网页会多了ssl校验，特别是第一次加载接口的时候，后面再刷新页面就会发现快了，因为后面就不校验ssl了
原因2：web调用的环境比较复杂，调用一个接口的时候，很多情况下是多个动作一起运行的，资源之间的争夺，部分情况会出现导致接口运行缓慢的问题，比如过个接口一起跑，带宽就被分走了，而postman只是调用单一的接口，调试环境也比较干净，所以会快的多
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77b39965373420c3b32aaa22e621e0e5/" rel="bookmark">
			某小程序开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		某小程序开发 文章目录 某小程序开发整体架构小程序端服务端树小程序拦截器具体实现 小程序用户缓存以及加密缓存相关代码 小程序配置相关信息配置类 小程序登录 注册 绑定 验证码小程序业务接口 注意事项本地测试时记得商户号的订单号填过去时间的格式 别用以后的 整体架构 小程序端 略
服务端 树 ├─cacher
│ 加密替换Cache.java
│ 加密替换CacheFactory.java
│ 加密替换CacheManager.java
│ 加密替换CacheManagerImpl.java
│ 加密替换CacheToken.java
│ MessageSessionManager.java
│
├─config
│ kkkk加密kkkk加密替换Adapter.java
│ kkkk加密kkkk加密替换Configuration.java
│ kkkk加密kkkk加密替换Intercept.java
│ kkkk加密kkkk加密替换Properties.java
│
├─domain
│ ResultData.java
│ kkkk加密kkkk加密替换Configure.java
│
├─model
│ 加密替换AddressGroupModel.java
│ 加密替换AddressModel.java
│ 加密替换ChildGroupModel.java
│ 加密替换kkkk加密kkkkDetailModel.java
│ 加密替换ConfirmOrderModel.java
│ 加密替换EvaluationModel.java
│ 加密替换OrderDetailIncludeModel.java
│ 加密替换OrderDetailInfoModel.java
│ 加密替换OrderDetailModel.java
│ 加密替换OrderModel.java
│ 加密替换kkkk加密kkkkkkkk加密kkkkModel.java
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77b39965373420c3b32aaa22e621e0e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6631fa7c896aa5e53fd3a5ac5f38251/" rel="bookmark">
			「Docker篇」IDEA整合Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、整合步骤
1、开启Docker远程连接
2、IDEA安装Docker插件
3、配置Docker信息 4、打开pom.xml添加Docker插件
5、刷新maven,发现多了一个docker插件
6、打开IDEA底部services
二、使用测试
1、 创建Dockerfile文件
2、创建测试代码
3、执行package将项目打为JAR包
4、点击docker:build构建镜像
5、镜像构建完成之后开始运行
6、也可以将镜像推送到远程仓库
三、总结
前言 容器化大家应该都不陌生了，一说到容器化大家可能首先想到的就是Docker，今天就带大家一起来完成IDEA对Docker的整合，实现快速部署的目的。
一、整合步骤 1、开启Docker远程连接 既然要整合到IDEA，那么IDEA就需要连接Docker,所以我们需要开启Docker的远程连接。
使用以下命令编辑docker.service文件
vim /usr/lib/systemd/system/docker.service 添加如下内容
-H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375 2、IDEA安装Docker插件 3、配置Docker信息 4、打开pom.xml添加Docker插件 &lt;properties&gt; &lt;!-- docker镜像前缀 --&gt; &lt;docker.image.prefix&gt;wjw&lt;/docker.image.prefix&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- maven打包插件--&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- docker插件--&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;configuration&gt; &lt;!-- 远程Docker的地址 --&gt; &lt;dockerHost&gt;http://你的ip地址:2375&lt;/dockerHost&gt; &lt;!-- 镜像名称、前缀、项目名 --&gt; &lt;imageName&gt;${docker.image.prefix}/${project.artifactId}&lt;/imageName&gt; &lt;!-- Dockerfile的位置 --&gt; &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6631fa7c896aa5e53fd3a5ac5f38251/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f3ba04e02cd429847c0877bc82525d4/" rel="bookmark">
			Java一个方法优雅的返回多个值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个方法返回多个值，可以有多种实现方式
1.放在bean
2.放在map里面
3.使用commons-lang3工具类，返回2个值用Pair，3个值用Triple
1. 使用map /** * @author liangks * @date 2022/4/26 */ @Data @NoArgsConstructor @AllArgsConstructor class Principal { private String name; } @Data @NoArgsConstructor @AllArgsConstructor class Student { private String name; } @Data @NoArgsConstructor @AllArgsConstructor class Teacher { private String name; } public class MapTest { /** * 使用Map来返回多个对象 * * @return */ public static Map&lt;String, Object&gt; init() { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("teacher", new Teacher("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f3ba04e02cd429847c0877bc82525d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72a280a3202dbe9cd2fe8bc288f72c93/" rel="bookmark">
			jQuery时间控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间控件 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;style&gt; .dateinputer{ line-height:40px; height:40px; margin:10px 0; border:1px solid #ccc; cursor: pointer; position:relative; /*top:10px;*/ /*left:20px;*/ padding:0 6px; font-size:12px !important; } .flex-div{ display: flex; justify-content: flex-start; align-items: flex-start; flex-flow: column; margin-left:30px; margin-top:20px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="flex-div"&gt; &lt;span&gt;date 单日选择器&lt;/span&gt; &lt;a id="destroy"&gt;销毁日历&lt;/a&gt; &lt;div id='date' class="dateinputer"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="flex-div"&gt; &lt;span&gt;datetime 单日加时间选择器&lt;/span&gt; &lt;div id='datetime' class="dateinputer"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="flex-div"&gt; &lt;span&gt;month 月选择器&lt;/span&gt; &lt;div id='month' class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72a280a3202dbe9cd2fe8bc288f72c93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e51be7c5b87a7127fad4deae88555f5/" rel="bookmark">
			JAVA接口继承接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA里面接口可以继承接口吗？
答案是可以的。但是继承的话不是使用implements关键字，而是使用extends关键字。
下面这么写代码是会报错的：
//这个代码肯定是会报错的，因为子接口继承父接口应该使用extends interface Animal{ //	写一个抽象方法 void test(); } interface Cat implements Animal{ } 应该按照下面这么写：
interface Animal{ //	写一个抽象方法 void test(); } interface Cat extends Animal{ void test2(); } 查看具体的例子：
interface Animal{ //	写一个抽象方法 void test(); } interface Cat extends Animal{ void test2(); } //实现父接口 class Dog implements Animal{ @Override public void test() { } } //实现子接口 class Dog2 implements Cat{ @Override public void test() { } @Override public void test2() { } } 我们可以看到，如果我们去实现父接口，子接口可以不用实现。但是如果我们实现子接口，那么父接口也要一块写实现的方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec7bd0793ea048e57fb96c2366a73901/" rel="bookmark">
			在CSDN中添加目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1.文章开头位置添加@[toc]2.正常编辑目录级别3.效果展示 1.文章开头位置添加@[toc] 2.正常编辑目录级别 # 一级目录 ## 二级目录 ### 三级目录 3.效果展示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0e8d3410563667339bbb399ea147544/" rel="bookmark">
			【Python】python之subprocess模块详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Python】python之subprocess模块详解 subprocess模块 subprocess是Python 2.4中新增的一个模块，它允许你生成新的进程，连接到它们的 input/output/error 管道，并获取它们的返回（状态）码。这个模块的目的在于替换几个旧的模块和方法，如：
os.system os.spawn* 1. subprocess模块中的常用函数 函数描述subprocess.run()Python 3.5中新增的函数。执行指定的命令，等待命令执行完成后返回一个包含执行结果的CompletedProcess类的实例。subprocess.call()执行指定的命令，返回命令执行状态，其功能类似于os.system(cmd)。subprocess.check_call()Python 2.5中新增的函数。 执行指定的命令，如果执行成功则返回状态码，否则抛出异常。其功能等价于subprocess.run(…, check=True)。subprocess.check_output()Python 2.7中新增的的函数。执行指定的命令，如果执行状态码为0则返回命令执行结果，否则抛出异常。subprocess.getoutput(cmd)接收字符串格式的命令，执行命令并返回执行结果，其功能类似于os.popen(cmd).read()和commands.getoutput(cmd)。subprocess.getstatusoutput(cmd)执行cmd命令，返回一个元组(命令执行状态, 命令执行结果输出)，其功能类似于commands.getstatusoutput()。 说明：
在Python 3.5之后的版本中，官方文档中提倡通过subprocess.run()函数替代其他函数来使用subproccess模块的功能；在Python 3.5之前的版本中，我们可以通过subprocess.call()，subprocess.getoutput()等上面列出的其他函数来使用subprocess模块的功能；subprocess.run()、subprocess.call()、subprocess.check_call()和subprocess.check_output()都是通过对subprocess.Popen的封装来实现的高级函数，因此如果我们需要更复杂功能时，可以通过subprocess.Popen来完成。subprocess.getoutput()和subprocess.getstatusoutput()函数是来自Python 2.x的commands模块的两个遗留函数。它们隐式的调用系统shell，并且不保证其他函数所具有的安全性和异常处理的一致性。另外，它们从Python 3.3.4开始才支持Windows平台。 2. 上面各函数的定义及参数说明 函数参数列表：
subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, shell=False, timeout=None, check=False, universal_newlines=False) subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False, timeout=None) subprocess.check_call(args, *, stdin=None, stdout=None, stderr=None, shell=False, timeout=None) subprocess.check_output(args, *, stdin=None, stderr=None, shell=False, universal_newlines=False, timeout=None) subprocess.getstatusoutput(cmd) subprocess.getoutput(cmd) 参数说明：
args： 要执行的shell命令，默认应该是一个字符串序列，如[‘df’, ‘-Th’]或(‘df’, ‘-Th’)，也可以是一个字符串，如’df -Th’，但是此时需要把shell参数的值置为True。shell： 如果shell为True，那么指定的命令将通过shell执行。如果我们需要访问某些shell的特性，如管道、文件名通配符、环境变量扩展功能，这将是非常有用的。当然，python本身也提供了许多类似shell的特性的实现，如glob、fnmatch、os.walk()、os.path.expandvars()、os.expanduser()和shutil等。check： 如果check参数的值是True，且执行命令的进程以非0状态码退出，则会抛出一个CalledProcessError的异常，且该异常对象会包含 参数、退出状态码、以及stdout和stderr(如果它们有被捕获的话)。stdout, stderr：input： 该参数是传递给Popen.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0e8d3410563667339bbb399ea147544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96f99cd9f5c820dcd98119edf2bc0ace/" rel="bookmark">
			docker使用GPU及linux下cuda安装和更新问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. docker使用GPU2. 镜像cuda版本和宿主机cuda版本不兼容2.1 确定问题2.2 解决方案 3. ubuntu上安装GPU驱动4. NVIDIA CUDA Installation Guide for Linux 1. docker使用GPU 首先介绍几个事实：
最初的docker是不支持gpu的为了让docker支持nvidia显卡，英伟达公司开发了nvidia-docker。该软件是对docker的包装，使得容器能够看到并使用宿主机的nvidia显卡。根据网上的资料，从docker 19版本之后，nvidia-docker成为了过去式。不需要单独去下nvidia-docker这个独立的docker应用程序，也就是说gpu docker所需要的Runtime被集成进docker中，使用的时候用–gpus参数来控制。 所以我一直都是直接以--gpus这个参数来使用容器的，直接给容器分配GPU
docker run -it -d --gpus "device=3" --ipc=host -p 10036:22 -v /ws/huangshan:/ws --name "paddle2.1" paddlepaddle/paddle:2.1.2-gpu-cuda11.2-cudnn8 bash -c "/etc/rc.local; /bin/bash" 详情见参考：
怎么在docker中使用nvidia显卡 2. 镜像cuda版本和宿主机cuda版本不兼容 2.1 确定问题 下载PaddlePaddle的镜像，一开始使用的是最新的
然后就报错cuda版本不匹配
容器对应的镜像要求cuda版本是11.2以上，但是宿主机的cuda版本只有11.1。
docker: Error response from daemon: OCI runtime create failed: container_linux.go:367: starting container process caused: process_linux.go:495: container init caused: Running hook #0:: error running hook: exit status 1, stdout: , stderr: nvidia-container-cli: requirement error: unsatisfied condition: cuda&gt;=11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96f99cd9f5c820dcd98119edf2bc0ace/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f56f104b0f3b574d975db50e5ccdf85c/" rel="bookmark">
			TypeScript 基础类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TypeScript 基础类型 文章目录 TypeScript 基础类型一.引言二.简介三.TypeScript和JavaScript区别对比四. 安装、编译1.安装2.编译 五. TypeScript基础类型1. Boolean2. Number3. String4. Symbol5. Void6. Null和Undefined7. Array8. Tuple（元组）9. Enum(枚举)9.1 数字枚举9.2 字符串枚举9.3 异构枚举9.4 常量枚举 10. Any11. Unknown12. Object &amp; object &amp; {}12.1 object12.2 Object12.3 { }12.4 对比 13. never 一.引言 一直想抽空来写写相关TS的东西,2022年了,TS现在已经成为咱们前端必备的基础技能,Vue3已是Vue的默认版本,而Vue3就是使用TypeScript 来构建的,随着项目的不断更迭,包括我如今使用的nestjs 写后端,也是使用TS来支持的,更不用说React和Vue了。所以学习TS势在必行!
二.简介 TypeScript是一种由微软开发的自由和开源的变成语言，它是JavaScript的一个超集,而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程–引用官方文档
TypeScript 不是JavaScript的替代品,而是会使JavaScript的步伐更加坚实遥远.TypeScript 提供最新的和不断发展的 JavaScript特性.包括ES6 中的特性已经未来提案中的特性,比如装饰器(Decorators)
三.TypeScript和JavaScript区别对比 TypeScriptJavaScriptJavaScript 的超集用于解决大型项目的代码复杂性一种脚本语言，用于创建动态网页可以在编译期间发现并纠正错误一种解释型语言,只能在运行时发现错误强类型,支持静态和动态类型弱类型语言可以编译成指定版本的Javascript代码,不能直接在浏览器中运行,需要编译可以直接在浏览器中使用支持模块,泛型,和接口不支持模块,泛型,和接口定义变量的数据类型不能被改变变量的数据可以改变,并赋予不同的数据类型 四. 安装、编译 1.安装 1.安装 npm install -g typescript 2.验证版本 tsc -v 2.编译 tsc typescript.ts typescript.ts =&gt; typescript.js ts编译时，会将ts文件编译成js文件
五. TypeScript基础类型 在javascript中，基础数据类型有：number,string,boolean,null,undefined以及ES6中的Symbol和ES10中的BigInt
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f56f104b0f3b574d975db50e5ccdf85c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/949df27b646c30d10226d46861ddee8c/" rel="bookmark">
			无法导入.reg:指定的文件不是注册脚本。你在注册表编辑器中只能导...解决办法(非常实用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近使用到了注册脚本的导入，但是每次导入都会报错：无法导入F:\桌面\wechat.reg:指定的文件不是注册脚本。你在注册表编辑器中只能导入二进位注册文件.reg！！！
于是乎在网上找了很多相关的解决文章，绝大多数文章中的解决办法都在说，在保存 .txt/.reg 时需要保存为 ANSI 格式；该说法本质上并没有错，但是无论是 .txt 还是 .reg 在自动保存时都是默认 ANSI 格式，所以使用他们的方法对解决：无法导入F:\桌面\wechat.reg:指定的文件不是注册脚本。你在注册表编辑器中只能导入二进位注册文件.reg！！！对解决问题并没有实质性的帮助！！！
下面详解介绍一下注册脚本(ANSI)的正确创建方法，及如何避免 ：无法导入F:\桌面\wechat.reg:指定的文件不是注册脚本。你在注册表编辑器中只能导入二进位注册文件.reg！！！问题，或者说是该问题的解决办法！！！
一、ANSI 创建流程 1、新建 .txt 文件，输入：readme（内用随意），然后保存（名字随意，例如 111.txt）；
2、修改后缀，改为：111.reg；
3、右键选择编辑；
4、将 .reg 文件里面的内容删掉，换成自己需要的 注册脚本 的内容，保存，完成创建；
说明：如果先编辑 .reg 内容再改后缀名可能会造成意想不到的错误；
二、无法导入F:\桌面\wechat.reg:指定的文件不是注册脚本。你在注册表编辑器中只能导入二进位注册文件.reg！！！问题解决办法 其实出现这种情况大多数情况下都是因为自己创建的 .reg 文件内容编辑的格式不正确导致的，要解决此问题首先要做的就是检查 .reg 文件内容格式是否出错；
如下是我建立的一个注册表（.reg文件）；
Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\ZZO] @="URL:ZZO Protocol Handler" "URL Protocol"="" [HKEY_CLASSES_ROOT\ZZO\DefaultIcon] @="E:\\WeChat\\WeChat.exe" [HKEY_CLASSES_ROOT\ZZO\shell] [HKEY_CLASSES_ROOT\ZZO\shell\open] [HKEY_CLASSES_ROOT\ZZO\shell\open\command] @="E:\\WeChat\\WeChat.exe" 说明：我在双击运行报以上错误时，是因为我在编辑 .reg 文件内容时，少编辑了：Windows Registry Editor Version 5.00 ，该句是 .reg 文件必须要有的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d06db24249afca796b94b563e117b4f8/" rel="bookmark">
			python报错：cannot import name ‘config_context‘ from ‘sklearn‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我用的tensorflow是2.3的版本，然后numpy、scipy啥的版本如果不匹配就容易影响运行。
所以配置如下：
python 3.7+tensorflow 2.3+numpy 1.18.5+scipy 1.6.0+scikit-learn 0.23.2
报错代码如下：
import sklearn from sklearn.model_selection import train_test_split X_train, X_validation, Y_train, Y_validation = train_test_split(train_feature_df,train_data.label,test_size = 0.2) print(X_train) 问题来了，我引用sklearn包的时候用的1.0+版本的时候会提示无法引用model_selection，降低版本到0.23.2的时候会提示无法引用config_context,但是这玩意我也没用啊，我还去找了sklearn0.23.2的使用手册，发现这个版本里是有config_context的，所以我以为是安装的时候安装包破损了啥的，又重新安装了一遍，并没有用。
折腾了半天还是搞不出来，决定摸到文件夹里看看，路径是C:\Users\用户名\Anaconda3\envs\tensorflow\Lib\site-packages\sklearn发现一个很奇怪的事情，就是这个路径下是由名为model_selection的文件夹的，但是没有config_context的文件夹，我就无中生有自己创建了一个空文件夹config_context，然后一共添加了三个空文件夹，就很神奇的跑起来了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16d2b1cf40cf027a1a563fdf10108d6e/" rel="bookmark">
			Spring AOP 之 aspect表达式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
aspect表达式实例
1. 简介
2. AOP的各个扮演者
3. 切点表达式
3.1 execution（常用）
3.2 within
3.3 args
3.4 this和target
3.5 @within
3.6 @annotation（常用）
3.7 @args
3.8 @DeclareParents
3.9 perthis和pertarget
aspect表达式实例 任意公共方法的执行：
execution(public * *(..))
任何一个以“set”开始的方法的执行：
execution(* set*(..))
AccountService 接口的任意方法的执行：
execution(* com.xyz.service.AccountService.*(..))
定义在service包里的任意方法的执行：
execution(* com.xyz.service.*.*(..))
定义在service包和所有子包里的任意类的任意方法的执行：
execution(* com.xyz.service..*.*(..))
定义在pointcutexp包和所有子包里的JoinPointObjP2类的任意方法的执行：
execution(* com.test.spring.aop.pointcutexp..JoinPointObjP2.*(..))")
***&gt; 最靠近(..)的为方法名,靠近.*(..))的为类名或者接口名,如上例的JoinPointObjP2.*(..))
pointcutexp包里的任意类.
within(com.test.spring.aop.pointcutexp.*)
pointcutexp包和所有子包里的任意类.
within(com.test.spring.aop.pointcutexp..*)
实现了Intf接口的所有类,如果Intf不是接口,限定Intf单个类.
this(com.test.spring.aop.pointcutexp.Intf)
***&gt; 当一个实现了接口的类被AOP的时候,用getBean方法必须cast为接口类型,不能为该类的类型.
带有@Transactional标注的所有类的任意方法.
@within(org.springframework.transaction.annotation.Transactional)
@target(org.springframework.transaction.annotation.Transactional)
带有@Transactional标注的任意方法.
@annotation(org.springframework.transaction.annotation.Transactional)
***&gt; @within和@target针对类的注解,@annotation是针对方法的注解
参数带有@Transactional标注的方法.
@args(org.springframework.transaction.annotation.Transactional)
参数为String类型(运行是决定)的方法.
args(String)
1. 简介 面向对象编程，也称为OOP（即Object Oriented Programming）最大的优点在于能够将业务模块进行封装，从而达到功能复用的目的。通过面向对象编程，不同的模板可以相互组装，从而实现更为复杂的业务模块，其结构形式可用下图表示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16d2b1cf40cf027a1a563fdf10108d6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb8f769f3252b3c9466e0ae0048f979d/" rel="bookmark">
			python分支结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入一个分数，判断该分数是ABCD中哪一级（A：[90,100]，B：[70,90），C：[60，70），D：[0，60）） 2.输入x值，输出y的值：y=2x(x&gt;5)10-x(x&lt;5)x-2(x=5)
3.输入一个4位（含4位）以内的正整数，判断这个数字是几位数，并输出该数字的每位数字之和
4.输入2个数字和加减乘除中的一个符号，输出对应的结果
输入一个2位正整数，这个数字如果是奇数，输出各位数字之和，如果是偶数，输出各位数字之差 编写停车场计费程序，停车3小时以内收取5元，3小时以上的部分每小时2元，每天封顶30元，不足1小时按照1小时计算。输入停车小时数，计算费用。 输入一个正整数，判断该数字是否是一个奇数 输入一个正整数，判断该数字是否在[1,12]范围内 输入一个年份，判断该年是否为闰年（能被4整除但不能被100整除；或者能被400整除）
输入一个正整数，判断该数字是否为3的倍数，并且以6结尾 输入三角形的三条边，判断是否可以组成三角形，如果可以则判断组成什么三角形(等边、等腰、直角、普通) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b476335fe144392ebeed76d301689f5/" rel="bookmark">
			【转】将分数转换为二进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		备考信息论，在此记录一下将分数转换为二进制的方法（以1/3为例）
我们转换整数部分用的是短除法, 那么类似的, 转换小数用的是乘法. 其基本做法是, 乘以2, 不满1写0, 满1写1并去掉积中的1, 然后积再继续乘2.
如1/3:
首先, 我们写下
0.
接着, 1/3 乘以2, 得2/3, 不到1, 因此, 我们接着写下0
0.0
接着, 2/3 乘以2, 得4/3, 超过1, 因此, 接着写下1
0.01
4/3去掉1是1/3, 我们发现了循环, 因此, 循环节是01
作者：大脑壳家电团
链接：https://www.zhihu.com/question/27908137/answer/38588258
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/242/">«</a>
	<span class="pagination__item pagination__item--current">243/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/244/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>