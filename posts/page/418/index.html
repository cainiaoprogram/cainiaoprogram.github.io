<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8b12ca3eaf72ea5e07fe9a6f3ec1862/" rel="bookmark">
			POJ 3279
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Time limit2000 msMemory limit65536 kB Description Farmer John knows that an intellectually satisfied cow is a happy cow who will give more milk. He has arranged a brainy activity for cows in which they manipulate an M × N grid (1 ≤ M ≤ 15; 1 ≤ N ≤ 15) of square tiles, each of which is colored black on one side and white on the other side.
As one would guess, when a single white tile is flipped, it changes to black; when a single black tile is flipped, it changes to white.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8b12ca3eaf72ea5e07fe9a6f3ec1862/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eccbac720551883c0372f0428c68606b/" rel="bookmark">
			curl获取数据乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源数据为：{“code”:1,“msg”: “查询成功”,“data”:{“play_account”:“200760639”,“account”:“0415_wx_961d9ee67b8bf729”,“rolename”:“胡涛”,“new”:“1”}}，使用curl获取到的数据中中文出现乱码：{“code”:1,“msg”: “��ѯ�ɹ�”,“data”: {“play_account”:“200760639”,“account”:“0415_wx_961d9ee67b8bf729”,“rolename”:“����”,“new”:“1”}}。这是因为获取到的数据不是utf-8编码。可以使用mb_convert_encoding函数将获取到的数据进行转码。可以在curl中将获取到的数据使用mb_convert_encoding(“获取的数据”, ‘utf-8’, ‘GBK,UTF-8,ASCII’)转码为utf-8即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02c1616c962b46be03182893b4d01c48/" rel="bookmark">
			Python3中// 和/区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		" / "表示浮点数除法，返回浮点float结果;" // "表示整数除法,返回一个不大于" / "计算结果的最大整数int，特别注意如果其中一个操作数位负数，则结果必为负数。
如： a = 5/3
b = 5//3
c = -5/3
d = -5//3
print(a,b,c,d,sep=",")
输出结果：1.6666666666666667,1,-1.6666666666666667,-2
转载于:https://www.cnblogs.com/bitterain/p/10270587.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7f7b8be35bf74b59cea81acf4bd391b/" rel="bookmark">
			IE浏览器，console对象未定义解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先是，IE6/7/8/9浏览器是没有定义console对象，就是说console对象要自己定义。
可以使用下面js代码来定义：
window.console = window.console || (function () { var c = {}; c.log = c.warn = c.debug = c.info = c.error = c.time = c.dir = c.profile = c.clear = c.exception = c.trace = c.assert = function () { }; return c; })(); 当然，也可以直接把console打印日志给注释掉，就不会报错了。
最后，经过测试，有时候按F12进入开发者模式之后，也会不报错。原因是：开发人员工具打开后，浏览器自动创建了console这个对象
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d25f36285ead077bb1a49dece5609880/" rel="bookmark">
			微信小程序——switchTab和navigateTo理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方的开发者文档中对于两者的比较仅仅为是否和tabBar相互连接，简单的来讲就是：
redirectTo：关闭当前页(卸载)，跳转到指定页
navigateTo：保留当前页(隐藏)，跳转到指定页
switchTap：只能用于跳转到tabbar页面，并关闭其他非tabbar页面,tabbar之间做切换
常见的会出现的问题：
（1）因为bindtap名字的问题导致的无法进行正常的跳转（解决方式：只要更改一个名字即可）
（2）路径和tabber中的冲突，而不能使用switchtab（解决方案：核对tabber中的其他设置页的list项目中的路径中是否有冲突，如果存在的话则不能实现跳转）
因为wx.switchTab是唯一能跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面(意思是说其他几个wx.设置跳转时,如果app.json的tabBar中的list中也设置的相同的跳转路径时,跳转无效.而wx.switchTab却只能设置tabBar相同的路径)对应的绑定事件和对应的跳转路径），此时相对应的设置成wx.navigateTo即可完成跳转
（3）补充：小编在写代码的过程中发现的问题，删除掉了对应tab页面的list的各个路径相关的问题，前提是app.json中存在index路径给定一个bindtap的绑定事件，在对应的indexj.s文件中设置wx.switchTab的路径为tab中存在的路径如下所示，用switchTab点击触发事件之后，没有报错，也没有明显提示，页面不能跳转，换为 （navigateTo）之后成功跳转，
综上所述：
注意switchTab只能跳转到带有tab的页面，不能跳转到不带tab的页面！跳转不带tab的页面还是需要使用redirect或者navigate！所以，如果如果你的post页面还没有加入tab选项卡，请依然使用redirect或者navigate！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be527e8521e4693de417231029b84669/" rel="bookmark">
			POJ1321 棋盘问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Time limit1000 msMemory limit10000 kB Description 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。
Input 输入含有多组测试数据。
每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n
当为-1 -1时表示输入结束。
随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。
Output
对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。
Sample Input
2 1 #. .# 4 4 ...# ..#. .#.. #... -1 -1 Sample Output
2 1 题目分析 首先看到这个题的时候我想到的是，从第一个可以放棋子的点开始先放一个棋子，然后去找可以放下一个棋子的地方（为了方便我们称为第二个棋子），相对于第二个棋子我需要去找这个棋子的下个棋子，也就是第三个棋子可以放的位置。那么对于第一个棋子，第一个棋子的下一个棋子有很多种方法，而对于第二个棋子的下个棋子也有很多的方法。
所以我想的是，选取第一个棋子的位置的不同，可能会造成不同的摆放方法，为了防止重复，假设我们现在第一个棋子的位置放在第一个可以放置的位置，那么我们就将所有包含这个点的可行方法全部找出来，然后这个点我们就不再使用它了，那么我们在后面的方法中就不能再用这个点了，所以我们就将第一个点的位置换到下一个点去，再将这个点的所有可行方法全部找出来。
对于第一个点是这样的，那么对于第二个点也是一样的，就像汉诺塔一样，对于第i的棋子，其任务是，先为自己找一个可以放置的位置，然后在将剩下的 k - i 个棋子让第i+1个棋子去实现，这样的话对最后一个棋子的话就只需要找到一个放置自己的点就好了。
以上就讲下思路，具体看代码
代码区 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; void dfs(int tx, int r); char map[10][10],tag[10]; int n, k; int sum; int main() { while(~scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be527e8521e4693de417231029b84669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/250be31daffd5fd1a6d5eef3035934ce/" rel="bookmark">
			深度学习mAP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mAP，其中代表P（Precision）精确率。AP（Average precision）单类标签平均（各个召回率中最大精确率的平均数）的精确率，mAP(Mean Average Precision)所有类标签的平均精确率。
1.准确率(accuracy)、精确率(Precision)、召回率(Recall) 准确率(accuracy),精确率(Precision)和召回率(Recall)是信息检索，人工智能，和搜索引擎的设计中很重要的几个概念和指标。
准确率：预测标签与ground truth的正确率。
精确率：预测为正标签的样本中的准确率。Precision = TP / (TP + FP)
召回率：体现了预测为负样本中标签为正（正样本漏检）的程度。Recall = TP/(TP + FN)
举例：先假定一个具体场景作为例子。假如某个班级有男生80人,女生20人,共计100人，目标是找出所有女生,某人挑选出50个人，其中20人是女生，另外还错误的把30个男生也当作女生挑选出来了。
accuracy:分类正确的人占总人数的比例。他把其中70(20女+50男)人判定正确了,而总人数是100人，所以它的accuracy就是70 %。
当正负样本比例失调时，单纯的依靠准确率不靠谱。例如99个负样本，1个正样本，将样本全部判断为负即可达到99%的准确率。
其中TP代表正确（TURE）预测出正样本（POSITIVE）、FN代表错误（FALSE）预测成负样本（NEGTIVE）而真实标签为正样本。
通过这张表,我们可以很容易得到例子中这几个分类的值:TP=20,FP=30,FN=0,TN=50。
“精确率”与“召回率”虽然没有必然的关系（从上面公式中可以看到），然而在大规模数据集合中，这两个指标却是相互制约的。放宽“检索策略”时，往往也会伴随出现一些不相关的结果，从而使准确率受到影响。而希望去除检索结果中的不相关样本时，务必要将“检索策略”定的更加严格，这样也会使有一些相关的样本不再能被检索到，从而使召回率受到影响。
2.P-R曲线 用训练好的模型得到所有测试样本的confidence score，本例中某一类有20个测试样本。（每一类的P-R曲线、AP均单独计算）
对该类的confidence score排序，得到：
计算top-1到top-N（N是所有测试样本个数，本文中为20）对应的precision和recall，这两个标准的定义如下：
直观的理解就是，第一次我们排序后第一个样本的confidence作为划分正负样本的阈值，此时，只有第一个判断为正，其他均为负样本（因为其他样本的confidence均小于第一个样本的confidence），计算该阈值情况下的recall(1/1=1)和precision(1/1=1)；然后第二次将排序后第二个样本的confidence作为划分正负样本的阈值，依次类推到最后一个。显然随着阈值的降低，我们选定的样本越来也多，recall一定会越来越高，而precision整体上会呈下降趋势。把recall当成横坐标，precision当成纵坐标，即可得到常用的precision-recall曲线。这个例子的P-R曲线如下： 3.AP计算 PASCAL VOC CHALLENGE自2010年后就换了新计算方法。新的计算方法假设这N个样本中有M个正例，那么我们会得到M个recall值（1/M, 2/M, …, M/M）,对于每个recall值r，我们可以计算出对应（r’ &gt; r）的最大precision，然后对这M个precision值取平均即得到最后的AP值。计算方法如下：​ 相应的Precision-Recall曲线中被用于计算AP的部分如下（每一个recall的节点都取precision的最大值连接起来）： 4.mAP AP衡量的是学出来的模型在每个类别上的好坏，mAP衡量的是学出的模型在所有类别上的好坏，得到AP后mAP的计算就变得很简单了，就是取所有AP的平均值。
参考文献：https://blog.csdn.net/hust_lmj/article/details/79052559
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a29383ec514534f4386055943452d916/" rel="bookmark">
			浏览器CA认证流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先说说证书的签发过程： 服务方 S 向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证；
CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等；
如信息审核通过，CA 会向申请者签发认证文件-证书。
证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名；
签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名；
客户端 C 向服务器 S 发出请求时，S 返回证书文件；
客户端 C 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法；
客户端然后验证证书相关的域名信息、有效时间等信息；
客户端会内置信任 CA 的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA 的证书，证书也会被判定非法。
在这个过程注意几点：
申请证书不需要提供私钥，确保私钥永远只能服务器掌握；证书的合法性仍然依赖于非对称加密算法，证书主要是增加了服务器信息以及签名；内置 CA 对应的证书称为根证书，颁发者和使用者相同，自己为自己签名，即自签名证书；证书=公钥+申请者与颁发者信息+签名； 浏览器CA认证流程 客户端向一个需要https访问的网站发起请求。
服务器将证书发送给客户端进行校验。证书里面包含了其公钥。这里要特别说一下客户端到底 如何来校验对方发过来的数字证书是否有效。
首先在本地电脑寻找是否有这个服务器证书上的ca机构的根证书。如果有继续下一步，如果没有弹出警告。
使用ca机构根证书的公钥对服务器证书的指纹和指纹算法进行解密。 得到指纹算法之后，拿着这个指纹算法对服务器证书的摘要进行计算得到指纹。
将计算出的指纹和从服务器证书中解密出的指纹对比看是否一样如果一样则通过认证。
校验成功之后，客户端会生成一个随机串然后使用服务器证书的公钥进行加密之后发送给服务器。
服务器通过使用自己的私钥解密得到这个随机值。
服务器从此开始使用这个随机值进行对称加密开始和客户端进行通信。
客户端拿到值用对称加密方式 使用随机值进行解密。
为什么不一直使用非对称进行加密，而是在类似握手之后开始使用对称加密算法进行https通信：
非对称加密的消耗和所需的计算以及时间远比对称加密消耗要大，所以在握手和认证之后，服务器和客户端就开始按照约定的随机串，对后续的数据传输进行加密。
特点：
非对称加密相比对称加密更加安全
非对称加密算法对加密内容的长度有限制
CA数字证书作用之一是公钥分发
数字签名的签发过程是私钥加密，公钥解密
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cafd9869627ec971b256a78e1b9eaaa7/" rel="bookmark">
			Ablation study
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ablation study 消融实验，在计算机视觉领域中，往往提及消融实验来验证本文的创新点。
比如你弄了个目标检测的pipeline用了A, B, C，然后效果还不错，但你并不知道A, B, C各自到底起了多大的作用，可能B效率很低同时精度很好，也可能A和B彼此相互促进。
Ablation study/experiment就是用来告诉你或者读者整个流程里面的关键部分到底起了多大作用，就像Ross将RPN换成SS进行对比实验，以及与不共享主干网络进行对比，就是为了给读者更直观的数据来说明算法的有效性。
在原理上有些像控制变量法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f08abc8e0eec45aa1a3056f2f819b942/" rel="bookmark">
			安卓 ScrollView与NestedScrollView的动态滚动与监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019年第一篇博客，今天就介绍下ScrollView常用的两个方法。
在项目中，特别是新项目，UI经常会让我们根据屏幕的滚动展示不同的内容，或者内容太长，点击某个按钮或者触发某个事件，主动滚动到屏幕底部，这时候就需要我们监听ScrollView（我现在都是用NestedScrollView，不过为了打字方便，用ScrollView代替NestedScrollView，这两个处理其实是一样的，哈哈）的滚动事件和主动滚动事件。
因为Android很多函数都是基于消息队列来同步，所以需要一部操作，
addView完之后，不等于马上就会显示，而是在队列中等待处理，虽然很快，但是如果立即调用fullScroll， view可能还没有显示出来，所以会失败，应该通过handler在新线程中更新。
方法很简单直接列出来了,下面是使用代码，有基础的同学一眼就明白。
Handler handler = new Handler();
handler.post(new Runnable() {
@Override
public void run() {
// 滚动到底部
nestedScrollView.fullScroll(ScrollView.FOCUS_DOWN);
滚动到顶部
// nestedScrollView.fullScroll(ScrollView.FOCUS_UP);
}
});
2.监听scrollview滚动，以调整布局
nestedScrollView.setOnScrollChangeListener(new NestedScrollView.OnScrollChangeListener() {
@Override
public void onScrollChange(NestedScrollView nestedScrollView, int scrollX, int scrollY, int oldScrollX, int oldScrollY) {
if (scrollY &gt; ScreenUtils.dip2px(getActivity(), 182)) {
ivAddHomePage.setVisibility(View.GONE);
ivPullDown.setVisibility(View.GONE);
llCityName.setVisibility(View.GONE);
LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) llSearch.getLayoutParams();
params.width = ScreenUtils.dip2px(getActivity(), 300);
params.gravity = Gravity.CENTER;
llSearch.setLayoutParams(params);
} else {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f08abc8e0eec45aa1a3056f2f819b942/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc1c9d094afe5221dab680ce41d572fd/" rel="bookmark">
			cookie-resopnse对象addCookie和addHeader设置cookie区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面有两个具体的代码示例：
设置addCookie @RequestMapping("/respAddCK") @ResponseBody public String respAddCK(@RequestBody UserInfoVo loginUser){ System.out.println("begin"); AppUser user = loginService.queryLoginUser(loginUser); System.out.println("end"); Cookie ck = new Cookie("respAddCK",loginUser.getUsername()); response.addCookie(ck); return "very good!"; } 设置addHeader @RequestMapping("/respSetCK") @ResponseBody public String respSetCK(@RequestBody UserInfoVo loginUser){ System.out.println("begin"); AppUser user = loginService.queryLoginUser(loginUser); System.out.println("end"); StringBuffer cookieBuf = new StringBuffer(); cookieBuf.append("respSetCK=").append(loginUser.getUsername()).append(";"); cookieBuf.append("Path=/; HttpOnly;"); response.addHeader("Set-Cookie",cookieBuf.toString()); return "very good!"; } 最终结果：
通过对比，发现都成功的设置了cookie,只不过具体值有差异，addHeader比addCookie灵活，可以设置的属性更多
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b61ad8eaf4d80ed6dd295b7f58799488/" rel="bookmark">
			从零开始配置yolov3(keras)训练测试自己的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://github.com/qqwweee/keras-yolo3
本文使用anaconda创建虚拟环境，达到与其它环境隔离的目的，前提是装好anaconda，如果有不清楚的，查一下其它教程
在github教程中，推荐的环境是
Python 3.5.2Keras 2.1.5tensorflow 1.6.0 1 创建yolo环境 conda creat -n yolo python=3.6 更换conda源，下载软件的时候会快些
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes 创建后进入yolo环境，并安装Keras和tensorflow，我这块安装的是gpu版本的tensorflow
source activate yolo pip install keras==2.1.5 pip install tensorflow-gpu==1.6.0 #如果是gpu版本 pip install tensorflow==1.6.0 #如果是cpu版本 2 安装依赖 在训练的过程中，会有很多依赖，所以提前安装一遍
pip install Pillow pip install matplotlib conda install ffmpeg pip install opencv-contrib-python 注意opencv要安装contrib版本的，否则直接用conda install -c menpo opencv3安装后，在打开MP4文件时会报如下的错误
Unable to stop the stream: Invalid argument 3 制作数据集 首先把github上的代码克隆下来，我们在home目录下新建一个yolov3的文件夹，然后复制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b61ad8eaf4d80ed6dd295b7f58799488/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ababf5b16616dd1d1de4a21666644bb/" rel="bookmark">
			vue-去除格式警告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue-去除格式警告
在创建Vue项目时,如果一直yes会添加严格的格式警告,在运行测试时会变得十分麻烦,但其实这也是需要我们养成的好习惯.
如果不想要的话,可以把build文件夹下的webpack.base.conf.js中的…(config.dev.useEslint ? [createLintingRule()] : []),注释掉
注意: 注释后一定要记得重新跑一项目,不然依旧会按照原规则来.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f48624504de9b92b415e143883ab1b56/" rel="bookmark">
			java调用第三方短信接口 本地能发送短信，服务器却发不了，直到超时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看看错误日志 2019-01-11 09:21:32,242 INFO [pool-3-thread-1] com.ejavashop.core.sms.xfbsms.utils.LoggerUtil.info(45) -- Fri Jan 11 09:21:32 CST 2019 sendTemplateSMS url = https://sandboxapp.cloopen.com:8883/2013-12-26/Accounts/aaf98f8952f7367a01530c5dd33626c6/SMS/TemplateSMS?sig=7939BE20B60257805AF0B6A99B28ED38
2019-01-11 09:21:32,243 INFO [pool-3-thread-1] com.ejavashop.core.sms.xfbsms.utils.LoggerUtil.info(45) -- Fri Jan 11 09:21:32 CST 2019 sendTemplateSMS Request body = {"appId":"8aaf07085e0e36d0015e279952c20746","to":"13152541141","templateId":"259015","datas":["您好，您已成功注册,您的验证码是613957【广东禧越科技】","10"]}
2019-01-11 09:21:32,243 DEBUG [pool-3-thread-1] org.apache.http.impl.conn.BasicClientConnectionManager.getConnection(160) -- Get connection for route {s}-&gt;https://sandboxapp.cloopen.com:8883
2019-01-11 09:21:32,278 DEBUG [pool-3-thread-1] org.apache.http.impl.conn.DefaultClientConnectionOperator.openConnection(174) -- Connecting to sandboxapp.cloopen.com:8883
2019-01-11 09:21:47,870 DEBUG [Timer-0] org.apache.http.impl.conn.LoggingManagedHttpClientConnection.shutdown(87) -- http-outgoing-85: Shutdown connection
2019-01-11 09:21:47,871 DEBUG [Timer-0] org.apache.http.impl.execchain.ConnectionHolder.abortConnection(128) -- Connection discarded
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f48624504de9b92b415e143883ab1b56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aff1e09a0fb8e14b863100ee19c4c6a/" rel="bookmark">
			xcode报错 Unable to open project
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sudo gem install bd_pod_extentions pop install --repo-update pop install 原因是pp配置出了问题，相关的依赖没有安装
pp是Provisioning Profile文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a445e3151ea425363b9cf4d92079821/" rel="bookmark">
			sqlite3学习之PHP连接（增删改查）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自 PHP 5.3.0 起默认启用 SQLite3 扩展，我们也可以在编译时使用 --without-sqlite3 禁用 SQLite3 扩展，Windows 用户必须启用 php_sqlite3.dll 才能使用该扩展，同样，自 PHP 5.3.0 起，这个 DLL 被包含在 PHP 的 Windows 分发版中，我们来看下PHP中可以操作sqlite3的一些API，如下：
序号API &amp; 描述1public void SQLite3::open ( filename, flags, encryption_key ) 打开一个 SQLite 3 数据库。如果构建包括加密，那么它将尝试使用的密钥。
如果文件名 filename 赋值为 ':memory:'，那么 SQLite3::open() 将会在 RAM 中创建一个内存数据库，这只会在 session 的有效时间内持续。
如果文件名 filename 为实际的设备文件名称，那么 SQLite3::open() 将使用这个参数值尝试打开数据库文件。如果该名称的文件不存在，那么将创建一个新的命名为该名称的数据库文件。
可选的 flags 用于判断是否打开 SQLite 数据库。默认情况下，当使用 SQLITE3_OPEN_READWRITE | SQLITE3_OPEN_CREATE 时打开。
2public bool SQLite3::exec ( string $query ) 该例程提供了一个执行 SQL 命令的快捷方式，SQL 命令由 sql 参数提供，可以由多个 SQL 命令组成。该程序用于对给定的数据库执行一个无结果的查询。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a445e3151ea425363b9cf4d92079821/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/076fc6f4e36b53ce6ca6dd80c90d6836/" rel="bookmark">
			关于pip install tensorflow,Could not find a version that satisfies……失败的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于pip install tensorflow 失败，出现Could not find a version that satisfies the requirement tensorflow-tensorboard的问题
百度了好久都不行，上了官方论坛试了好几个方法终于解决了：
原因是windows 64位系统上pip 安装tensorflow只支持python 3.5版本，下载python3.5 x86-64版，同时设置好环境变量即可解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ed76b9f03fd21e685634af7d26bf725/" rel="bookmark">
			GNS3安装和使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 使用 GNS3 软件模拟 IOS 指南一、 准备工作二、 GNS3 虚拟机安装三、 GNS3 软件安装四、 首次运行初始化五、 主界面介绍六、 添加设备八、 配置设备九、 连接设备十、 设置合适的 Idle-PC 值十二、 增加网络云十三、 保存配置十四、 二层交换机十五、 用路由器模拟三层交换机十六、 主机地址绑定十七、 ATM 交换机十八、 Frame Relay 交换机 使用 GNS3 软件模拟 IOS 指南 此文章为计网实验课的指导，转载自浙江大学。
这些软件你可以官网下载，也可以在百度云下载。
需要用到的软件有：
WindowsMacOSVirtual Machineversion 2.9(教程版本)ver 2.1.9ver 2.1.9GNS3-2.1.9-all-in-one.exeGNS3-2.1.9.dmgGNS3.VM.VMware.Workstation.2.1.9.zipGNS3-2.1.19-all-in-one.exeGNS3-2.1.19.dmgGNS3.VM.VMware.Workstation.2.1.19.zip 提取码：9rxt
Cisco路由器IOS映像文件(3725)下载地址Cisco路由器IOS映像文件(3745)下载地址 一、 准备工作 GNS3 软件支持虚拟机模式和物理机模式，我们建议使用虚拟机模式， 因此在正式安装 GNS3 软件前，请在你的电脑上准备好虚拟机软件。推荐使用 VMware 软件。Windows 环境下推荐安VMware Workstation 12 以上，Mac 环境下推荐安装 VMware Fusion 8 以上。
如果不打算使用虚拟机模式，可以完成大部分实验内容，但某些特定的实验内容可能无法完成，比如使用无线网卡以及在寝室的网络环境下时，GNS3 内的虚拟设备无法连接外部真实网络。
二、 GNS3 虚拟机安装 虚拟机软件 VMware 安装完毕后，请根据你的操作系统下载对应的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ed76b9f03fd21e685634af7d26bf725/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a53f7cd827e99736ec01e95968433536/" rel="bookmark">
			2017江西省电子赛现场赛赛题和解决仿真附加视频讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简易数控直流稳压电源 给个赞啊！！！！！！！！！！！！！赞！ 具体仿真请去我博客的资源里找，视频是自己录得请谅解
仿真下载连接：https://download.csdn.net/download/qq_41151593/10912527
2017江西电赛赛题：https://pan.baidu.com/s/1KvTZ6nhdUPi3tVl1Ycmmpg:密码：d069
链接: https://pan.baidu.com/s/1rq63QWn4RytIrNrnf6DIdQ 密码: 8w81
可实现可控3V、4.5V、5V、6V、电压输出并显示，带负载能力强、过流检测准确
视频是在实际焊接完的讲解，会有些和下面的图不一样，但总体一致，部分细节不同
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be00bc3fcdd751d85641d23ebf6d7f9d/" rel="bookmark">
			区别：符号变量和常变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		符号变量：
1.用 #define指令定义 #define PRICE 35 2.符号变量只是用一个符号代替字符串，在预编译时把所有符号变量替换为所制定的字符串
3.没有类型，在内存中并不存在以符号变量命名的存储单元
常变量：
1.用const定义
const int b=45; 2.具有变量的特征
3.具有类型，在内存中存在以它命名的存储单元
关于 typeid.name()，可点击 https://blog.csdn.net/Koyurion/article/details/86315532
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9d0c20afb9e675a426978a799ddece3/" rel="bookmark">
			CentOS7：添加Root权限 普通用户升级超级用户的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS7 添加Root权限 普通用户升级超级用户的方法 1.添加普通用户，命令行步骤如下： useradd wy99 -- 添加一个名为wy99的用户
passwd wy99 -- 修改用户wy99的密码
回车之后，命令行出现如下信息（依次填写密码即可）：
Changing password for user wy99 .
New UNIX password: -- 在这里输入新密码（输入密码时，默认为隐藏输入状态）
Retype new UNIX password: -- 再次输入新密码（两次所输密码一致，即可修改成功）
passwd: all authentication tokens updated successfully
su wy99 -- 切换到wy99用户
如此一来，，一个普通用户的创建流程结束了。
2.普通用户升级为管理员用户，命令行步骤如下： 到这里，我们会发现普通用户很多时候不满足于自身的需求，例如某些文件、文件目录的读写会受到限制，所以我们还需要赋予wy99用户一个升级VIP用户的方式，那么看下面代码：
（如遇到权限问题，请看文章最后）
方法一：
vi /etc/sudoers -- 修改/etc/sudoers文件，找到下面一行，把前面的注释（#）去掉
## Allows people in group wheel to run all commands
#%wheel ALL=(ALL) ALL (此处标红的井号去掉即可)
方法二：
vi /etc/sudoers -- 修改/etc/sudoers文件，找到下面一行，在下面加入一行代码
## Allow root to run any commands anywhere
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9d0c20afb9e675a426978a799ddece3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d9ab1519953807aa4dfad53430451bc/" rel="bookmark">
			sqlite3学习之索引（Index）的使用&amp;Indexed By子句&amp;Alter 命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引（Index）是一种特殊的查找表，数据库搜索引擎用来加快数据检索。简单地说，索引是一个指向表中数据的指针。一个数据库中的索引与一本书后边的索引是非常相似的。例如，如果我们想在一本讨论某个话题的书中引用所有页面，我们首先需要指向索引，索引按字母顺序列出了所有主题，然后指向一个或多个特定的页码。索引有助于加快 SELECT 查询和 WHERE 子句，但它会减慢使用 UPDATE 和 INSERT 语句时的数据输入。索引可以创建或删除，但不会影响数据。使用 CREATE INDEX 语句创建索引，它允许命名索引，指定表及要索引的一列或多列，并指示索引是升序排列还是降序排列。索引也可以是唯一的，与 UNIQUE 约束类似，在列上或列组合上防止重复条目，来看下创建索引的语法格式：
CREATE INDEX index_name ON table_name; 单列索引是一个只基于表的一个列上创建的索引，基本语法如下：
CREATE INDEX index_name ON table_name (column_name); 使用唯一索引不仅是为了性能，同时也为了数据的完整性。唯一索引不允许任何重复的值插入到表中，基本语法如下：
CREATE UNIQUE INDEX index_name on table_name (column_name); 组合索引是基于一个表的两个或多个列上创建的索引，基本语法如下：
CREATE INDEX index_name on table_name (column1, column2); 至于我们是否要创建一个单列索引还是组合索引，要考虑到我们在作为查询过滤条件的 WHERE 子句中使用非常频繁的列，如果值使用到一个列，则选择使用单列索引，如果在作为过滤的 WHERE 子句中有两个或多个列经常使用，则选择使用组合索引。
隐式索引是在创建对象时，由数据库服务器自动创建的索引，索引自动创建为主键约束和唯一约束。
接下来，我们在 COMPANY 表的 salary 列上创建一个索引：
CREATE INDEX salary_index ON COMPANY (salary); 之后，我们就可以使用 .indices 或 .indexes 命令列出 COMPANY 表上所有可用的索引，如下：
.indices COMPANY 结果如下，其中 sqlite_autoindex_COMPANY_1 是创建表时创建的隐式索引：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d9ab1519953807aa4dfad53430451bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9523dd103251d4b951035e79b582bd4a/" rel="bookmark">
			sqlite3学习之触发器（Trigger）的定义和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQLite 触发器（Trigger）是数据库的回调函数，它会在指定的数据库事件发生时自动执行/调用，我们来看下关于 SQLite 的触发器（Trigger）的要点：
SQLite 的触发器（Trigger）可以指定在特定的数据库表发生 DELETE、INSERT 或 UPDATE 时触发，或在一个或多个指定表的列发生更新时触发。
SQLite 只支持 FOR EACH ROW 触发器（Trigger），没有 FOR EACH STATEMENT 触发器（Trigger）。因此，明确指定 FOR EACH ROW 是可选的。
WHEN 子句和触发器（Trigger）动作可能访问使用表单 NEW.column-name 和 OLD.column-name 的引用插入、删除或更新的行元素，其中 column-name 是从与触发器关联的表的列的名称。
如果提供 WHEN 子句，则只针对 WHEN 子句为真的指定行执行 SQL 语句。如果没有提供 WHEN 子句，则针对所有行执行 SQL 语句。
BEFORE 或 AFTER 关键字决定何时执行触发器动作，决定是在关联行的插入、修改或删除之前或者之后执行触发器动作。
当触发器相关联的表删除时，自动删除触发器（Trigger）。
要修改的表必须存在于同一数据库中，作为触发器被附加的表或视图，且必须只使用 tablename，而不是 database.tablename。
一个特殊的 SQL 函数 RAISE() 可用于触发器程序内抛出异常。
创建 触发器（Trigger） 的基本语法如下：
CREATE TRIGGER trigger_name [BEFORE|AFTER] event_name ON table_name BEGIN -- Trigger logic goes here.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9523dd103251d4b951035e79b582bd4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a712db1f78eb0ecae4dad3ebf70731b/" rel="bookmark">
			dataTables--保留相关操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要解释保留表格的操作记录---
1.bStateSave(属性设置)---状态保存, 再次加载页面时还原表格状态。
2.$("#tableId").DataTable().draw(false);--也会刷新表格，但是会保留我们的操作状态。
3.跳转到指定页---
const Table = $("#table").DataTable(); Table.page(number).draw( false );
4.获取当前页码--Table.page.info()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/294185fd55df378459f23800b994cb8d/" rel="bookmark">
			K-fold Cross Validation（K折交叉验证的概念）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K-fold Cross Validation(记为K-CV)
将原始数据分成K组(一般是均分),将每个子集数据分别做一次验证集,其余的K-1组子集数据作为训练集,这样会得到K个模型,用这K个模型最终的验证集的分类准确率的平均数作为此K-CV下分类器的性能指标.K一般大于等于2,实际操作时一般从3开始取,只有在原始数据集合数据量小的时候才会尝试取2.K-CV可以有效的避免过学习以及欠学习状态的发生,最后得到的结果也比较具有说服性.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/881ccfdf51cc9d3216abb442fcfbd0dc/" rel="bookmark">
			解决JsonMappingException: out of START_ARRAY token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现场景：
[{ "tag": "", "metal": "W18K", "lossRate": 0.1, "weightMax": "2.5", "weightMin": "1.5" }, { "tag": "", "metal": "PT950", "lossRate": 0.1, "weightMax": "2.5", "weightMin": "1.5" }] 在使用Jackson转换这段json为实体类的时候报出JsonMappingException: out of START_ARRAY token
出现原因：
这串json数据最外层是[ ]，代表为对象数组，因为Jackson object mapper在把返回的json片段转换成对象时，需要的是Object{}，而我返回的是Array[{ }]。
解决方案：
json数据转换为对象时，Object[].class替换Object.class，即把json段转换成这个对象的数组，而不仅仅是一个对象
说在最后的话：编写实属不易，若喜欢或者对你有帮助记得点赞+关注或者收藏哦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a19f09fcff3e91fefb17c37c68856786/" rel="bookmark">
			《软件工程导论》全书知识点整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：这是自己为了应付期末考试整理的全书知识点。 一 什么是软件危机？它有哪些典型表型？为什么会出现软件危机？
软件危机的介绍：软件危机是指在计算机开发和维护过程中所遇到的一系列严重的问题
主要包含以下两个问题：
1.如何开发软件，以满足对软件日益增长的需求
2.如何维护数量不断膨胀的已有软件
软件危机的典型表现：
1.对软件开发成本和进度的估计常常不准确
2.用户对“已完成的”软件系统不满意的现象经常发生
3.软件产品的质量往往靠不住
4.软件常常是不可维护的
5.软件通常没有适当的文档资料
6.软件成本在计算机系统总成本中所占的比例逐年上升
7.软件开发生产的速率，跟不上计算机应用迅速普及深入的趋势
产生软件危机的原因
一方面与软件本身的特点有关，另一方面也与软件开发与维护的方法不正确。
二：什么是软件工程？它有哪些本质特性？怎样用软件工程消除软件危机？
软件工程的介绍：软件工程是指导计算机软件开发和维护的一门工程学科。 软件工程的出现原因：软件工程是为了解决软件危机而出现的 软件工程的本质特性 （1）软件工程关注于大型程序的构造 （2）软件工程的中心课题是控制复杂性 （3）软件经常变化 （4）开发软件的效率非常重要 （5）和谐地合作是开发软件的关键 （6）软件必须有效地支持它的用户 （7）软件工程领域中通常由具有一种文化背景的人代替具有另一种文化背景的人创造产品。 软件工程的基本原理 1.用分阶段的生命周期计划严格管理 2.坚持进行阶段评审 3.实行严格的产品控制 4.采用现代程序技术 5.结果应能清楚地审查 6.开发小组人员应该少而精 7.承认不断改进软件工程实践的必要性 软件危机应付途径
运用软件工程技术消除软件危机，具体做法：
1.对计算机软件有一个正确的认识(软件≠程序)
2.必须充分认识到软件开发不是某种个体劳动的神秘技巧，而应该是一种组织良好，管理严密，各类人员协同配合，共同完成的工程项目。
3.推广使用在实践中总结出来的开发软件的成功技术和方法
4.开发和使用更好的开发工具
软件工程方法学包含3个要素：方法，工具和过程。
软件生命周期是由软件定义，软件开发和运行维护（也称为软件维护）3个时期组成，每个时期又进一步划分成若干个阶段。
软件定义时期可以划分为3个阶段，即问题定义，可行性研究和需求分析。
软件开发时期通常划分为4个阶段，即总体设计，详细设计，编码和单元测试，综合测试。
软件维护时期不再进一步划分阶段，但是每一次维护活动本质上都是一次压缩和简化了的定义和开发过程。
每个时期的任务
1.软件定义时期的任务：确定软件开发工程必须完成的总目标；确定工程的可行性；导出实现工程目标应该采用的策略以及系统必须完成的功能；估计完成该项工程需要的资源和成本，并且制定工程进度表。
2.开发时期的任务：具体设计和实现在前一个时期定义的软件。
3.维护时期的任务：使软件持久地满足用户的需要。
7.常见三种周期模型的优点 瀑布模型的优点：
1.可强迫开发人员采用规范的方法（例如：结构化技术）
2.严格地规定了每个阶段必须提交的文档；
3.要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证
快速原形模型的优点：
1.有助于保证用户的真实需要得到满足
增量模型的优点：
1.能在较短的时间内向用户提交可完成部分工作的产品
2.逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少
一个全新的软件可能给客户组织带来的冲击。
3.软件的可维护性明显好于封闭结构的软件
三：说明微软过程的适用范围
适用于商业环境下具有有限资源和有限开发时间约束的项目的软件过程模式
第二章 可行性研究
可行性研究分为：
技术可行性经济可行性操作可行性 数据字典是关于数据的信息的集合，也就是对数据流图中包含的所有元素的定义的集合
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a19f09fcff3e91fefb17c37c68856786/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ce11a50f2bef1b26855df425b0d51e6/" rel="bookmark">
			贝叶斯决策理论对CIFAR-10数据图像分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：数据集介绍 CIFAR-10 是一个用于普世物体识别的数据集，分为airplane、automobile、bird、cat、deer、
dog、frog、horse、ship、truck共10 类。
共60000张32*32大小的彩色RGB图像，分为10类，50000张用于训练，10000张用于测试。
训练集分为5个训练batches，测试集分为1个测试batch。每个batch有10类，每类大概有1000张图片。
本次实验中选用大约10000张图片作为训练集，这些图片类别为1或2或3
选用3000张图片作为测试集
2：算法说明 实验主要分为两步
第一步对数据集使用PCA进行降维，每张图片由1024x3=3072个像素点构成，降维以后每张图片保留20个特征；
第二步基于贝叶斯决策理论进行判决，基于本实验样本分布，选用高斯分布的朴素贝叶斯分类算法。
2.1 PCA（主成分分析） PCA(Principal Component Analysis)，即主成分分析方法，是一种使用最广泛的数据降维算法。PCA的主要思想是将n维特征映射到k维上，这k维是全新的正交特征也被称为主成分，是在原有n维特征的基础上重新构造出来的k维特征。PCA的工作就是从原始的空间中顺序地找一组相互正交的坐标轴，新的坐标轴的选择与数据本身是密切相关的。其中，第一个新坐标轴选择是原始数据中方差最大的方向，第二个新坐标轴选取是与第一个坐标轴正交的平面中使得方差最大的，第三个轴是与第1,2个轴正交的平面中方差最大的。依次类推，可以得到n个这样的坐标轴。通过这种方式获得的新的坐标轴，我们发现，大部分方差都包含在前面k个坐标轴中，后面的坐标轴所含的方差几乎为0。于是，我们可以忽略余下的坐标轴，只保留前面k个含有绝大部分方差的坐标轴。事实上，这相当于只保留包含绝大部分方差的维度特征，而忽略包含方差几乎为0的特征维度，实现对数据特征的降维处理。
问题在于如何得到这些包含最大差异性的主成分方向
事实上，通过计算数据矩阵的协方差矩阵，然后得到协方差矩阵的特征值特征向量，选择特征值最大(即方差最大)的k个特征所对应的特征向量组成的矩阵。这样就可以将数据矩阵转换到新的空间当中，实现数据特征的降维。
由于得到协方差矩阵的特征值特征向量有两种方法：特征值分解协方差矩阵、奇异值分解协方差矩阵，所以PCA算法有两种实现方法：基于特征值分解协方差矩阵实现PCA算法、基于SVD分解协方差矩阵实现PCA算法
这就是PCA的优化目标
PCA算法描述如下：
输入：样本集D，低维空间维数d^l
过程：
1：对所有样本进行中心化；
2：计算样本的协方差矩阵；
3：对协方差矩阵做特征值分解；
4：取最大的d^l个特征值对应的特征向量 w 1 , w 2 , … … w ( d l ) w_1,w_2,……w_(d^l) w1​,w2​,……w(​dl)
输出：投影矩阵 W ∗ = ( w 1 , w 2 , … … w ( d l ) ) W^*=(w_1,w_2,……w_(d^l )) W∗=(w1​,w2​,……w(​dl))
2.2 贝叶斯决策 贝叶斯决策理论是主观贝叶斯派归纳理论的重要组成部分。 贝叶斯决策就是在不完全情报下，对部分未知的状态用主观概率估计，然后用贝叶斯公式对发生概率进行修正，最后再利用期望值和修正概率做出最优决策
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ce11a50f2bef1b26855df425b0d51e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31c5d336e36e7745a8b7d25dac48b088/" rel="bookmark">
			码点(code point)和代码单元（code unit），以及String对象中操作码点和代码单元
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个码点是信息原子的单元。文本是一连串的码点。每一个码点是一个由标准的Unicode编码规定的数字；
一个代码单元是一个用来存储编码码点的一部分的单元。在UTF-8中，一个代码单元是8位；在UTF-16中，一个代码单元是16位。
单独的一个代码单元可能代表一个完整的码点，也可能是一个码点的一部分。
例如，一个雪人字符（☃），是一个Unicode码点，也就是一个Unicode编码所代表的符号，在UTF-8中用3个代码单元表示，在UTF-16中用一个代码单元表示。
String对象中操作码点和代码单元 length()方法是获取给定字符串所需的代码单元数量。charAt(i)方法是获取位置i的代码单元，i介于0~s.leng()-1之间。
“?”符号 在Unicode中编码中，对应的十六进制编码为：1d546。“?”符号 在Java中的代码单元为："\uD835\uDD46"。
// 以此打印码点 private static void showCodePoint(){ //String str01="\u1D546"; String str01="\uD835\uDD46"; try { // 将Unicode字符转为UTF-8格式 byte[] b = str01.getBytes("UTF-8"); String rb = new String(b,"UTF-8"); // 为rb拼接一些内容 rb = rb+"abc"; // 打印rb的内容 System.out.println(rb); // 打印rb的代码单元长度 System.out.println(rb.length()); // 打印rb的码点长度 int codePointLen = rb.codePointCount(0, rb.length()); System.out.println(codePointLen); System.out.println("*******************"); // 根据码点长度，遍历各个码点 for(int i=0;i&lt;codePointLen;i++){ // 码点的偏移量 int index = rb.offsetByCodePoints(0, i); System.out.println(index); // 码点的十进制表示 int cp = rb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31c5d336e36e7745a8b7d25dac48b088/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73b2650e7bacc068c955dba0ebb3df23/" rel="bookmark">
			gpon学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPON系统概述
PON系统介绍
PON（Passive Optical Networks）网络由三部分组成，分别为OLT（Optical Line Terminal），ODN（Optical Distribution Network）和ONU（Optical Network Unit）。
• OLT是放置在局端的终结PON协议的汇聚设备。
• ONU是位于客户端的给用户提供各种接口的用户侧设备，OLT和ONU通过中间的无源光网络ODN连接起来进行互相通信。
• ODN由光纤、一个或多个无源光分路器等无源光器件组成，在OLT和ONU间提供光通道，起着连接OLT和ONU的作用，具有很高的可靠性。
PON网络架构如图2-1所示。PON网络和传统的宽带接入网的区别在于PON采用光纤进行数据传输，具有接入用户数多、节省光纤资源和高速率接入等特点。
图2-1 PON网络
GPON系统介绍
GPON是PON的一种技术，支持最大物理距离20km，最大逻辑距离60km的超长传输距离。同时支持1：64的分光比，扩展可以支持1：128的分光比，具有覆盖用户数量多、覆盖范围大等优点。GPON网络工作原理如图2-2所示。
图2-2 GPON网络工作原理
GPON网络采用单根光纤将OLT、分光器和ONU连接起来，上下行采用不同的波长进行数据承载。上行采用1310nm波长，下行采用1490nm波长。GPON系统采用波分复用的原理通过上下行不同波长在同一个ODN网络上进行数据传输，下行通过广播的方式发送数据，而上行通过TDMA的方式，按照时隙进行数据上传。
所有数据从OLT端广播到所有的ONU上，ONU再选择接收属于自身的数据，将其他数据直接丢弃。具体原理如图2-3所示。
图2-3 GPON下行通信原理
ONU在向OLT发送数据时只能在OLT提前许可的时隙内发送数据，这样就可以保证每个ONU都按照要求按次序发送数据，避免了上行数据冲突，如图2-4所示。
图2-4 GPON上行通信原理
GPON系统原理
GPON基本概念
GEM帧（GPON Encapsulation Mode）是GPON技术中最小的业务承载单元，是最基本的封装结构。所有的业务都要封装在GEM帧中在GPON线路上传输，通过GEM port标识。每个GEM Port由一个唯一的Port-ID来标识，由OLT进行全局分配，即OLT下的每个ONU不能使用Port-ID重复的GEM Port。GEM Port标识的是OLT和ONU之间的业务虚通道，即承载业务流的通道，类似于ATM虚连接中的VPI/VCI标识。
T-CONT：是GPON上行方向承载业务的载体，所有的GEM PORT都要映射到T-CONT中，由OLT通过DBA调度的方式上行。T-CONT是GPON系统中上行业务流最基本的控制单元。每个T-CONT由Alloc-ID来唯一标识。Alloc-ID由OLT进行全局分配，即OLT下的每个ONU不能使用Alloc-ID重复的T-CONT。
T-CONT包括五种不同的类型，在上行业务调度过程中根据不同类型的业务选择不同类型的T-CONT。每种T-CONT带宽类型有特定的QoS特征，QoS特征主要体现在带宽保证上，分为固定带宽，保证带宽，非保证带宽，尽力转发，混合方式（对应表2-2的Type1到Type5）。
表2-2 可用T-CONT类型
带宽类别 延迟敏感 分配方式 T-CONT类型
Type 1 Type 2 Type 3 Type 4 Type 5
固定带宽（Fixed） Yes Provisioned Yes No No No Yes
保证带宽（Assured） No Provisioned No Yes Yes No Yes
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73b2650e7bacc068c955dba0ebb3df23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1e6da6dbba81686da5469b5f177e356/" rel="bookmark">
			10分钟物联网设备接入阿里云IoT平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
最近尝试了一下阿里云IoT物联网平台，还是蛮强大的。在此记录一下学习过程。
本教程不需要任何外围硬件，一台电脑和一根能上网的网线即可。算是一篇Hello World了。先上效果图
第一章 准备工作
1.1 注册阿里云账号
首先打开阿里云的官网并注册新用户，网址为：
https://www.aliyun.com/product/iot
1.2 注册完成后自动跳转到实名认证界面，可以通过支付宝授权快速完成认证。
1.3 开通物联网平台
在左边菜单选择《产品与服务》中的物联网平台，并激活开通此功能。
开通成功后，即可进入管理控制台
1.4 软件环境搭建
下载并安装编辑器VS Code（全称Visual Studio Code）
https://code.visualstudio.com/
1.5 下载并安装Nodejs
https://nodejs.org/en/download/
第二章 IoT云端开发
2.1 打开阿里云控制台
https://iot.console.aliyun.com
2.2 创建高级版产品
在产品管理界面点击 创建产品，并选择高级版
2.3 新增产品属性
在产品详情的功能定义中点击 新增，创建属性
新增 温度
新增 湿度
注意：标识符非常重要，是JSON里传递的属性！而且要区分大小写！
属性界面一览
2.4 创建设备
首先点击设备管理，并在下拉菜单中选择Demo产品
点击 添加设备，并命名Unit01
创建完成后获得该设备的重要数据——三元组
可以继续添加其他设备
云端的任务告一段落。
点击Unit01进入设备详情，可以看到运行状态中并无数据。
第三章 设备端开发
本教程用nodejs程序来模拟设备，建立连接，上报数据。无实际硬件。
3.1 在电脑桌面创建设备端项目
创建项目文件夹 aliyun-iot-demo，本Demo共需要2个文件和一个库
创建文件package.json，代码如下
{ "name": "aliyun-iot-demo", "dependencies": { "aliyun-iot-mqtt": "^0.0.4" }, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1e6da6dbba81686da5469b5f177e356/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20f415ca4716faa3bfedbac5b93fd07e/" rel="bookmark">
			VUE打包时候报错：code ELIFECYCLE，npm install 正常，npm run build 时报错：code ELIFECYCLE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错如下：
PS D:\develop\vue\micro-ui\czz&gt; npm install npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\fsevents): npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted {"os":"darwin","arch":"any"} (current: {"os":"win32","arch":"x64"}) up to date in 19.829s PS D:\develop\vue\micro-ui\czz&gt; npm run build:test &gt; vuename@1.0.0 build:test D:\develop\vue\micro-ui\czz &gt; cross-env NODE_ENV=testing node build/build.js Hash: fd68032839117e5292e6 Version: webpack 3.12.0 Time: 20719ms Asset Size Chunks Chunk Names static/img/toast_bg_lyl.e105ee3.png 14 kB [emitted] static/img/toast_bg_jiangnan.fbc2618.png 48.9 kB [emitted] static/img/xinchun_start_go.7c349ad.png 16.1 kB [emitted] static/img/banner03_jn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20f415ca4716faa3bfedbac5b93fd07e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f6a53bc5c50dd632729f579059fc04b/" rel="bookmark">
			Linux后台运行java的jar包后台运行java -jar 命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么java -jar 的命令终端的窗口关闭就停止运行了？？tomcat中war的就不会？
关闭终端的窗口相当于ctrl+c的命令，关闭了窗口就相当于停止了java -jar这个进程，即ctrl+c，如果是在tomcat的容器中的话，如果停止运行，必须ps -ef | grep xxx ，然后kill -9或者./shutdown.sh命令，否则默认就是后台运行的。
Linux 运行jar包命令如下：
方式一 java -jar shareniu.jar
特点：当前ssh窗口被锁定，可按CTRL + C打断程序运行，或直接关闭窗口，程序退出
那如何让窗口不锁定？
方式二 java -jar shareniu.jar &amp;
&amp;代表在后台运行。
特定：当前ssh窗口不被锁定，但是当窗口关闭时，程序中止运行。
继续改进，如何让窗口关闭时，程序仍然运行？
方式三 nohup java -jar shareniu.jar &amp;
nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行
当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中，除非另外指定了输出文件。
方式四 nohup java -jar shareniu.jar &gt;/dev/null &amp;
解释下 &gt;temp.txt
command &gt;out.file
command &gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。
可通过jobs命令查看后台运行任务
jobs
那么就会列出所有后台执行的作业，并且每个作业前面都有个编号。
如果想将某个作业调回前台控制，只需要 fg + 编号即可。
fg 23
查看某端口占用的线程的pid
netstat -nlp |grep :9181
原文https://www.cnblogs.com/linnuo/p/9084125.html
转载于:https://www.cnblogs.com/LeesinDong/p/10835423.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73a17f0ff427a1a353cded81eaf5219f/" rel="bookmark">
			Linux之cudnn升级方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装tensorrt的时候，要求cudnn版本为7.3.1，而我之前安装的版本是5.1.10，因此需要对cudnn进行升级，升级方法很简单，而且不会对现有安装环境造成破坏，升级完之后tensorflow还可以正常使用
1 查看cudnn版本 首先使用以下指令查看现有cudnn的版本
cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2 输出如下
#define CUDNN_MAJOR 5 #define CUDNN_MINOR 1 #define CUDNN_PATCHLEVEL 10 -- #define CUDNN_VERSION (CUDNN_MAJOR * 1000 + CUDNN_MINOR * 100 + CUDNN_PATCHLEVEL) #include "driver_types.h" 表明是5.1.10版本
8.0 以上的版本查看方法是：
cat /usr/local/cuda/include/cudnn_version.h | grep CUDNN_MAJOR -A 2 输出如下
$ cat /usr/local/cuda/include/cudnn_version.h | grep CUDNN_MAJOR -A 2 #define CUDNN_MAJOR 8 #define CUDNN_MINOR 0 #define CUDNN_PATCHLEVEL 2 -- #define CUDNN_VERSION (CUDNN_MAJOR * 1000 + CUDNN_MINOR * 100 + CUDNN_PATCHLEVEL) #endif /* CUDNN_VERSION_H */ 2 下载cudnn 根据cuda和系统环境，在官网下载对应版本，建议选择tgz压缩文件，不要下载Deb文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73a17f0ff427a1a353cded81eaf5219f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16867a436bb832eba12034aa1e46a00b/" rel="bookmark">
			红黑树原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉查找树由于在频繁的动态更新过程中，可能会出现树的高度远大于 log2n的情况，所以就会导致各个操作效率下降，最坏的情况下就会退化为链表，变为O(n)．很明显，想要解决这个问题，有效的一种办法就是使得树的高度不要差很多，也就是平衡它．
最先发明的平衡二叉查找树是AVL树，（它严格符合平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。）但是在工程中，我们经常听到的通常是红黑树，而不是AVL树．那么为什么工程中都喜欢用红黑树，而不是其他平衡二叉查找树呢？
其实在这里，我们应该能有一些想法了．既然他严格按照规定执行，每次的插入，删除，都就会引发树的调整．调整的多了，自然会影响树的效率．那么红黑树又是怎样解决这个问题的呐？
其实，平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。 所以红黑树就是这种设计思路(近似平衡)了． 红黑树的定义 红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树．
顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样四个要求：
重要 1.　根节点是黑色的；2.　每个叶子节点都是黑色的空节点，也就是说，叶子节点不存储数据；3.　任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；4.　每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点； 这里的第二点要求“叶子节点都是黑色的空节点”，主要是为了简化红黑树的代码实现而设置的．现在，我们暂时不管这一点．
下面是两个红黑树的图例，你可以看下。
为什么红黑树是近似平衡的呐？ 首先，我们知道二叉查找树很多操作的性能都跟树的高度成正比。一棵极其平衡的二叉树（满二叉树或完全二叉树）的高度大约是 log2n，所以如果要证明红黑树是近似平衡的，我们只需要分析，红黑树的高度是否比较稳定地趋近 log2n 就好了。
首先，我们来看，如果我们将红色节点从红黑树中去掉，那单纯包含黑色节点的红黑树的高度是多少呢？ 红色节点删除之后，有些节点就没有父节点了，它们会直接拿这些节点的祖父节点（父节点的父节点）作为父节点。所以，之前的二叉树就变成了四叉树。
这时我们可以将有些节点拿出来组成一个完全二叉树，而完全二叉树的高度是 log2n ,很明显，我们的四叉树根本不会高于 log2n
我们现在知道只包含黑色节点的“黑树”的高度，那我们现在把红色节点加回去，高度会变成多少呢？ 从上面我画的红黑树的例子和定义看，在红黑树中，红色节点不能相邻，也就是说，有一个红色节点就要至少有一个黑色节点，将它跟其他红色节点隔开．红黑树中包含最多黑色节点的路径不会超过 log2n，所以加入红色节点之后，最长路径不会超过 2log2n，也就是说，红黑树的高度近似 2log2n。
所以，红黑树的高度只比高度平衡的 AVL 树的高度（log2n）仅仅大了一倍，在性能上，下降得并不多。这样推导出来的结果不够精确，实际上红黑树的性能更好。
OK，红黑树的原理我们已经知道了，那么我们现在就来了解一下它的实现思想
实现红黑树的基本思想 在极客时间中老师用了魔方的例子来讲解其思想，我觉得很恰当．这里直接拿来用
不知道你有没有玩过魔方？其实魔方的复原解法是有固定算法的：遇到哪几面是什么样子，对应就怎么转几下。你只要跟着这个复原步骤，就肯定能将魔方复原。
实际上，红黑树的平衡过程跟魔方复原非常神似，大致过程就是：遇到什么样的节点排布，我们就对应怎么去调整。只要按照这些固定的调整规则来操作，就能将一个非平衡的红黑树调整成平衡的。
其实想想AVL树，不就是这样吗？在想想计算机，不就是不断"重复"的去做一些事情的吗？
和AVL树一样，在进行节点的插入和删除时，就会破坏红黑树的一些规则．在红黑树中主要破坏的是以下两点：
1．任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；2． 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点； 很显然，我们需要也仅仅需要处理的就是如何把被破坏了的这两点规则还原回去．在还原之前，我们需要了解两个很重要的操作：左旋与右旋（围绕某个节点的右旋），
如图，其中 a，b，r 表示子树，可以为空。
感觉有个动画的效果是最好的了，哈哈哈～～不过也可以自己在脑中想象了啦
插入 红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。所以，关于插入操作的平衡调整，有这样两种特殊情况，但是也都非常好处理。
1．如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。
2.　如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。
其他：都会违背红黑树的定义，于是我们就需要进行调整，调整的过程包含两种基础的操作：左右旋转和改变颜色。
其他情况主要有三种，如果要实现，可以对应各个情况各个击破，红黑树的平衡调整过程是一个迭代的过程。就想魔方一样！！！对应规则调整就行了．
删除 删除操作的平衡调整分为两步，第一步是针对删除节点初步调整。初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求，也就是说，每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；第二步是针对关注节点进行二次调整，让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。
1. 针对删除节点初步调整 红黑树的定义中“只包含红色节点和黑色节点”，经过初步调整之后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色，“红 - 黑”或者“黑 - 黑”。如果一个节点被标记为了“黑 - 黑”，那在计算黑色节点个数的时候，要算成两个黑色节点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16867a436bb832eba12034aa1e46a00b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a413d3aed4d958268bac129a79ead425/" rel="bookmark">
			opencv 坐标转换常用的函数solvePnP()、 projectPoints()、stereoRectify()、stereoCalibrate()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Finds an object pose from 3D-2D point correspondences.
bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess=false, int flags=ITERATIVE ) 函数solvepnp接收一组对应的3D坐标和2D坐标，计算得到两组坐标对应的几何变换（旋转矩阵rvec，平移矩阵tvec）; 2.Projects 3D points to an image plane.
void projectPoints(InputArray objectPoints, InputArray rvec, InputArray tvec, InputArray cameraMatrix, InputArray distCoeffs, OutputArray imagePoints, OutputArray jacobian=noArray(), double aspectRatio=0 ) 函数projectPoints()根据所给的3D坐标和已知的几何变换来求解投影后的2D坐标。
3. void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T,OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2,OutputArray Q, int flags=CALIB_ZERO_DISPARITY, double alpha=-1, Size newImageSize=Size(), Rect* validPixROI1=0, Rect* validPixROI2=0 ) 立体矫正，该函数计算每个摄像机(实际上)的旋转矩阵，从而使两个摄像机图像平面成为同一平面。因此，这使得所有的外极线平行，从而简化了稠密立体对应问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a413d3aed4d958268bac129a79ead425/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee61afa3424bba5a3cc9a35d0c7e132/" rel="bookmark">
			分布式系统服务的稳定性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自: https://blog.csdn.net/zuoanyinxiang/article/details/51680183
服务稳定性的实现方案: 依赖管理&amp;服务分级&amp;优雅降级&amp;开关&amp;应急预案
保障分布式系统的稳定性(一)：流量控制 保障分布式系统的稳定性(二)：心跳检测 容量与水位 转载于:https://www.cnblogs.com/dhcn/p/10232986.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b05f2fd155e2b7644108121e8394653/" rel="bookmark">
			【QT】 更改工具栏tooltips背景颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在创建 QToolBar的时候，设置样式
QToolBar* pToolBar = new QToolBar(this);
if(pToolBar)
{
pToolBar-&gt;setStyleSheet(“QToolTip{background-color:red}”);
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47dbf29b373203ba3ef385153fcaae01/" rel="bookmark">
			Android之布局（layout）转化成图片（bitmap）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前和IOS同事讨论过怎么截屏的操作，当时也不明白，怎么可能将列表截图呢？毕竟列表可以上下滑动呀！最近有个需求，原生布局的界面，生成一个体检报告，我知道这个界面用H5做是可以生成pdf打印的。但现在是原生开发的，因为打印机可以打印bitmap转的byte数组文件，所以要实现页面布局转成bitmap图片。
当布局文件没有超出屏幕高度时：
private Bitmap getViewBitmap(View v) { v.clearFocus(); v.setPressed(false); boolean willNotCache = v.willNotCacheDrawing(); v.setWillNotCacheDrawing(false); int color = v.getDrawingCacheBackgroundColor(); v.setDrawingCacheBackgroundColor(0); if (color != 0) { v.destroyDrawingCache(); } v.buildDrawingCache(); Bitmap cacheBitmap = v.getDrawingCache(); if (cacheBitmap == null) { return null; } Bitmap bitmap = Bitmap.createBitmap(cacheBitmap); v.destroyDrawingCache(); v.setWillNotCacheDrawing(willNotCache); v.setDrawingCacheBackgroundColor(color); return bitmap; } 当布局超出了屏幕的高度，滑动采用Scrollview处理：
public static Bitmap getBitmapByView(ScrollView scrollView) { int h = 0; Bitmap bitmap = null; for (int i = 0; i &lt; scrollView.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47dbf29b373203ba3ef385153fcaae01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb424be57c08c8da8904f09b7c44d5f9/" rel="bookmark">
			IDEA SpringBoot 免重启热部署（热加载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA SpringBoot 免重启热部署（热加载） Date: 2019.01.06 天气不太好
记：工欲善其事必先利其器。
IDEA开发SpringBoot项目，结合DevTools实现热部署的方案众所周知，但是由于这种方案其根本原理是，IDEA自动完成编译部署重启的流程，所以不可避免的服务会被频繁重启，而每一次重启都会导致会话被重置。
经过长期探索，今天终于发现了免重启自动热部署方案，准确说应该是热加载（世界原来如此简单）。
环境： 操作系统：Windows 10
java：jdk 1.8
IDEA：IDEA ULTIMATE 2018.1
项目：SpringBoot Gradle
方案：
不需要 DevTools
2.1. 打开项目的运行配置，如下图配置
2.2. 以 debug 模式运行程序，项目即可自动部署加载了。
2.3. 配置 application.properties 添加：spring.thymeleaf.cache=false ，否则静态文件或 thymeleaf 文件无法自动热部署此方案有以下约束： 3.1. 使用的是debug模式
3.2. tomcat是由idea实例化的。也就是说tomcat是在idea中配置好的。（IDEA默认即是）
3.3. 当修改文件后，ctrl+F9，编译文件。tomcat会自动加载新文件。
3.4. On frame deactivation 选择为 update classes and Resource 时，当IDEA窗口失去焦点时会自动编译。
3.5. 特殊的修改如：项目配置文件，某些特殊类新增，方法名称参数的添加修改引起的不能热部署就必须重启，当然你也可以用Jrebel插件。此插件收费。可以实现大部分的修改热部署，包括修改项目配置文件等热部署。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d643cf9b2fcd1938721b1c03d3bbf523/" rel="bookmark">
			有用过STM8S001J3这颗8PIN的单片机吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题，有用过STM8S001J3这颗8PIN的单片机吗？
如果你觉得烧录很麻烦，而且容易把芯片烧成砖，那么有可能你没有掌握正确的烧录方法。
由于它的PIN脚有限，所以IO都是复用的，其中UART1_TX和SWIM重合了，如图所示：
如果你在代码中，把烧录口SWIM初始化成串口，有可能只能烧录一次，第二次就没法烧录了。
我的解决方法是，在初始化SWIM这个IO为串口之前，延时5秒中，利用这上电5秒的延时时间，完成第二次烧录。
或者，在初始化IO之前，做一个简单按键功能，让它不要往下执行代码。
具体的，留言留下邮箱，我把相关电路图、源码等资料发你。
我还建了一个单片机QQ群，群共享有这些资料免费获取，还可以讨论这些内容。群号是：597254771
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f4bb9a702a355f7be7e6667d1a47082/" rel="bookmark">
			移动端click失效的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法有 5种可供选择：
​1、将 click 事件直接绑定到目标​元素（​​即 .target）上
2、将目标​元素换成 a 或者 button 等可点击的​元素
​3、将 click 事件委托到​​​​​非 document 或 body 的​​父级元素上
​4、给​目标元素加一条样式规则 cursor: pointer;
​5、
$.each($(".pt_ARL_box_aside_three&gt;ul&gt;li"), function(key, val) { $(this).on("click",'委托元素', function() { //do xxx }) }) 5方法遍历给每个dom加事件，因此动态生成的也适用，不过要考虑性能问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d30d4cd30fab672c40bfc4c863d1ad0b/" rel="bookmark">
			ALGO-10 算法训练 集合运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法训练 集合运算 时间限制：1.0s 内存限制：512.0MB
锦囊1
排序后处理。
问题描述
给出两个整数集合A、B，求出他们的交集、并集以及B在A中的余集。
输入格式
第一行为一个整数n，表示集合A中的元素个数。
第二行有n个互不相同的用空格隔开的整数，表示集合A中的元素。
第三行为一个整数m，表示集合B中的元素个数。
第四行有m个互不相同的用空格隔开的整数，表示集合B中的元素。
集合中的所有元素均为int范围内的整数，n、m&lt;=1000。
输出格式
第一行按从小到大的顺序输出A、B交集中的所有元素。
第二行按从小到大的顺序输出A、B并集中的所有元素。
第三行按从小到大的顺序输出B在A中的余集中的所有元素。
样例输入
5
1 2 3 4 5
5
2 4 6 8 10
样例输出
2 4
1 2 3 4 5 6 8 10
1 3 5
样例输入
4
1 2 3 4
3
5 6 7
样例输出
1 2 3 4 5 6 7
1 2 3 4
#include &lt;iostream&gt; #include &lt;set&gt; using namespace std; set&lt;int&gt; sa,sb,sc; int main(int argc, char** argv) { int n,m; cin&gt;&gt;n; int num; for(int i=0;i&lt;n;i++){ cin&gt;&gt;num; sa.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d30d4cd30fab672c40bfc4c863d1ad0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f05ae9f9931660a161259464f572abb5/" rel="bookmark">
			微信小程序地图标记点，点击标记点显示详细信息源码加效果图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序开发交流qq群 173683895
承接微信小程序开发。扫码加微信。 效果图：
实现代码:
&lt;!-- &lt;text&gt;{{markers[id].placeName}}&lt;/text&gt; --&gt; &lt;block wx:if='{{isshow}}'&gt; &lt;map id="map" longitude="114.048410" latitude="22.648760" scale="8" include-points="{{markers}}" markers="{{markers}}" bindmarkertap="showModal" data-id="{{markers}}" polyline="{{polyline}}" bindregionchange="regionchange" show-location style="width: 100%; height: 100%;"&gt; &lt;cover-view class='index_bt1'&gt; &lt;cover-image class='xiaoer' bindtap="login" src="/images/mk.png" /&gt; &lt;/cover-view&gt; &lt;cover-view class='index_shuaxin'&gt; &lt;cover-image class='shuaxin' src="/images/mk.png" /&gt; &lt;/cover-view&gt; &lt;!--屏幕背景变暗的背景 --&gt; &lt;cover-view class="commodity_screen" bindtap="hideModal" wx:if="{{showModalStatus}}"&gt;&lt;/cover-view&gt; &lt;!--弹出框 --&gt; &lt;cover-view animation="{{animationData}}" class="commodity_attr_box" wx:if="{{showModalStatus}}"&gt; &lt;cover-view class='placeBox'&gt; &lt;cover-view class='placeViewLt'&gt; &lt;cover-view class='viewTitle'&gt;{{myall.placeName}}&lt;/cover-view&gt; &lt;cover-view class='viewDis'&gt;{{myall.dis}}&lt;/cover-view&gt; &lt;cover-view class='viewAddr'&gt;{{myall.adr}}&lt;/cover-view&gt; &lt;/cover-view&gt; &lt;cover-view class='placeViewRt'&gt; &lt;cover-image data-id="{{myall.id}}" bindtap="opendetail" src='/images/mk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f05ae9f9931660a161259464f572abb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14e564270de83c4e7858bf95c658e6dc/" rel="bookmark">
			IDEA使用注解@ConfigurationProperties时报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用注解@ConfigurationProperties报错 使用@ConfigurationProperties注解，以前用的挺好没出现问题，换了IDEA的版本使用，发现报错了，具体报错如下：
Spring Boot Configuration Annotation Processor not found in classpath
解决方式：
添加依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 导入依赖之后，发现依然报错：
解决方式：
在配置类上，加上注解@EnableConfigurationProperties(CorsProperties.class)即可！
各位有问题留言，我会尽力为大家解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beb6592e7206d0c7f3547f1387139866/" rel="bookmark">
			论文笔记（CPN）：Cascaded Pyramid Network for Multi-Person Pose Estimation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该论文发表在2018年CVPR上，用于多人姿态估计的级联金字塔网络
arxiv论文地址：https://arxiv.org/abs/1711.07319
github代码：https://github.com/GengDavid/pytorch-cpn，https://github.com/chenyilun95/tf-cpn
对于目前多人姿态估计中仍然存在的问题（遮挡点，不可见点和拥挤的背景，是的人体关键点检测存在的问题），作者将其原因归纳为两点：
1）作者认为，只通过表层特征不能识别这些“难点”，例如：躯干点；
2）在训练过程中没有明确解决这些“难点”的检测问题；
因此，在本文中，作者提出了一种新的网络结构，称为Cascaded Pyramid Network（CPN）级联金字塔网络，该网络可以有效缓解“hard” keypoints的检测问题，CPN网络分为两个阶段：GlobalNet和RefineNet。GlobalNet网络是一个特征金字塔网络，该网络用于定位简单的关键点，如眼睛和手等，但是对于遮挡点和不可见的点可能缺乏精确的定位；RefinNet网络该网络通过集合来自GolbalNet网络的多级别特征来明确解决“难点”的检测问题。
本文作者的工作有三大创新点：
作者提出了一个新的有效的网络：CPN，该网络由GlobalNet和RefineNet网络构成；作者分析了在top-down结构中问题对于多人姿态估计产生影响的不同因素；作者的算法实现了在challenging COCO multi-persion keypoint benchmark数据集上的最好的结果，在test-dev dataset上达到73.0AP，在test challenge dataset 上达到72.1AP。 在本论文中，作者采用了top-down的路线：先在image上使用一个human detector得到人的bounding-boxes，然后再使用cpn网络尽心关键点的检测；本文重心在cpn网络实现的关键点检测。
Our Approach for Multi-person Keypoints Estimation
一. Human Detector
检测算法作者使用FPN和Mask RCNN网络，以得到每个人的bounding-boxes，然后使用bounding-boxes对原图进行裁剪，并将裁剪后的结果用于CPN网络的输入进行关键点检测。
二. cascaded Pyramid Network(CPN)
作者提出的网络结构如下，可以看到该网络由两个子模块构成：GlobalNet和RefineNet。
2.1 GlobalNet
该网络的基础网络采用resnet网络，以resnet50为例，使用在imagenet上预训练的resnet50网络，然后使用该网络提取特征，分别使用1/4,1/8,1/16,1/32四个级别的网路特征（conv2_x, conv3_x, conv4_x, conv5_x的输出），然后在GlobalNet中分别将四层特征的通道转换为相同的通道数，此时，得到了四层通道数相同的特征图，该四层特征用两个用途：
用途一：对该四层网络特征做如下操作：低层特征进行上采样，与上一层特征进行相加，即不同尺度特征进行融合，最终得到融合了低层特征的四层特征，最后对该四层特征分别进行通道转换（转换为与关键点数目相同的通道数）并都上采样到1/4大小，用于计算该阶段的L2 loss）（四层输出分别和四种不同的高斯分布的label进行损失计算）。
用途二：对于四层特征，在RefineNet中进行使用, 见2.2。
小结：通过GlobalNet网络，可以对简单的点进行有效的关键点检测，但是对于不可见的关键点的检测，效果仍然不佳，如下图：对于left eye(简单点)特征图上的激活区域的groundtruth中的位置和接近，说明在GlabalNet阶段，该网络对于这种简单点的检测已经达到了很不错的效果；但是看left hip（难检测的点），在特征图上，还几乎没有激活区域呢，说明在该阶段网络并不能有效检测到该类别点，所以作者又设计了后续的RefineNet网络，专门用于检测类似这种的难检测的点，在下图中，也可以看到，经过RefineNet之后，该网络已经可以有效检测到难检测点了。作者将检测点通过两个阶段的网络进行检测，这种想法很值得我们学习。
2.2 RefineNet
在GlobalNet中，得到了四层特征图，作者通过给每一层特征图设计了不同的数量的botleneck块，再分别经过不同倍率的上采样，然后经过concat操作后，达到了对不同尺度特征的结合，最后经过一个bottlenet块，再经过简单的变换，得到网络的最终的输出。
注意：L2 loss和L2 loss*的区别，在GlobalNet中，使用L2 loss，即GlobalNet网络的输出和label计算所有关键点的loss；在RefineNet中，使用L2 loss*，即网络输出和label计算所有关键点的loss，然后对loss进行从大到小排序，最后选择top-k个loss用于网络的反向传播。
三. Experiment &amp; Discussion
Datasets：使用MS COCO trainval dataset（包含57k images and 150k person instances）和验证集：MS
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/beb6592e7206d0c7f3547f1387139866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71c6a24e46762c5940587ba02b8fb47a/" rel="bookmark">
			List集合与Array数组之间的互相转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组转换成List集合 方法一 笨方法就是通过add把数组中的数据循环添加到List集合中
List&amp;lt;String&amp;gt; mlist = new ArrayList&amp;lt;&amp;gt;(); String[] array = new String[] {"zhu", "wen", "tao"}; // String数组转List集合 for (int i = 0; i &amp;lt; array.length; i++) { mlist.add(array[i]); } // 输出List集合 for (int i = 0; i &amp;lt; mlist.size(); i++) { System.out.println("mlist--&amp;gt;" + mlist.get(i)); } 方法二 采用java中集合自带的asList()方法就可以完成转换了
String[] array = new String[] {"zhu", "wen", "tao"}; // String数组转List集合 List&amp;lt;String&amp;gt; mlist = Arrays.asList(array); // 输出List集合 for (int i = 0; i &amp;lt; mlist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71c6a24e46762c5940587ba02b8fb47a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bd528cb1b061352733b2729611dbc58/" rel="bookmark">
			IDEA使用switch传入String编译报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA使用switch传入String编译报错解决 作为一个初学者，今天在学习设计模式的时候，用到switch语句，发现传入String类型的值时，编译不通过。
报错：
Incompatible types. Found: ‘java.lang.String’, required: ‘byte, char, short or int’
我在想，不是JDK7之后，支持传入String才对呀，自己用的是JDK8为什么还报错，于是问一遍，无果，百度了一下才知道原来IDEA默认编译版本不是JDK8的，原来IDEA默认的编译环境是1.3，需要我们手动来设置！
File &gt; Project Structure &gt; Project
将版本切换到8-Lambdas,Type annotations etc.
File &gt; Project Structure &gt; Modules
这样就解决了这个问题，回到编译界面，发现编译已经通过了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c0c077fc7a630abcbeb0d37f073601c/" rel="bookmark">
			基于BERT预训练的中文命名实体识别TensorFlow实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BERT-BiLSMT-CRF-NER Tensorflow solution of NER task Using BiLSTM-CRF model with Google BERT Fine-tuning
GitHub： https://github.com/macanv/BERT-BiLSTM-CRF-NER
本文目录机构：
自己训练模型说明结果使用自己的数据 2019.1.31更新，支持pip install package 现在可以使用下面的命令下载软件包了：
pip install bert-base==0.0.7 -i https://pypi.python.org/simple 或者使用基于源代码的安装：
git clone https://github.com/macanv/BERT-BiLSTM-CRF-NER cd BERT-BiLSTM-CRF-NER/ python3 setup.py install 如果没啥问题，你将会看到这个：
笔者在windows10/ Linux/ Mac OSX上都测试过，安装没有问题。
软件包现在支持的功能 命名实体识别的训练命名实体识别的服务C/S继承优秀开源软件：bert_as_service(hanxiao)的BERT所有服务
4. 文本分类服务 （2019.2.19） 内容还会继续补充，同时欢迎大神们分享训练的模型或者新的方法或者数据(弱鸡的我并不会用在商业上，毕竟还是一个毕业即失业的渣渣~~)。
基于命名行训练命名实体识别模型: 安装完bert-base后，会生成两个基于命名行的工具，其中bert-base-ner-train支持命名实体识别模型的训练，你只需要指定训练数据的目录，BERT相关参数的目录即可。可以使用下面的命令查看帮助
bert-base-ner-train -help 训练的事例命名如下：
bert-base-ner-train \ -data_dir {your dataset dir}\ -output_dir {training output dir}\ -init_checkpoint {Google BERT model dir}\ -bert_config_file {bert_config.json under the Google BERT model dir} \ -vocab_file {vocab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c0c077fc7a630abcbeb0d37f073601c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be0b18dfe1b44ca737dc5b12ae096f7b/" rel="bookmark">
			RGB/XYZ Color Space Convert(RGB和XYZ色彩空间的相互转换矩阵)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如上图所示，左边为RGB色彩空间, 右边为XYZ色彩空间
常用转换矩阵:
更多的矩阵数据(感谢:http://brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html):
RGB Working SpaceReference WhiteRGB to XYZ [M]XYZ to RGB [M]-1Adobe RGB (1998)D65 0.5767309 0.1855540 0.1881852 0.2973769 0.6273491 0.0752741 0.0270343 0.0706872 0.9911085 2.0413690 -0.5649464 -0.3446944 -0.9692660 1.8760108 0.0415560 0.0134474 -0.1183897 1.0154096 AppleRGBD65 0.4497288 0.3162486 0.1844926 0.2446525 0.6720283 0.0833192 0.0251848 0.1411824 0.9224628 2.9515373 -1.2894116 -0.4738445 -1.0851093 1.9908566 0.0372026 0.0854934 -0.2694964 1.0912975 Best RGBD50 0.6326696 0.2045558 0.1269946 0.2284569 0.7373523 0.0341908 0.0000000 0.0095142 0.8156958 1.7552599 -0.4836786 -0.2530000 -0.5441336 1.5068789 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be0b18dfe1b44ca737dc5b12ae096f7b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/417/">«</a>
	<span class="pagination__item pagination__item--current">418/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/419/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>