<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeb046972e8ab296a8e09ec0b28d319b/" rel="bookmark">
			expr命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		expr命令的兩大作用： 1）四则运算； 2）字符串的操作； 1、四则运算 [tough@localhost ~]$ expr 6+2 6+2 [tough@localhost ~]$ expr 6 + 2 8 [tough@localhost ~]$ expr 6 - 2 4 [tough@localhost ~]$ expr 6 / 2 3 [tough@localhost ~]$ expr 6 * 2 expr: syntax error [tough@localhost ~]$ expr 6 \* 2 12 [tough@localhost ~]$ expr 6 + 3 - 5 4 注意： 运算符左右都有空格 ，如果没有空格表示是字符串连接 使用乘号时，必须用反斜线屏蔽其特定含义。因为shell可能会误解显示星号的意义。 [tough@localhost ~]$ expr 1.4 / 2 expr: non-numeric argument [tough@localhost ~]$ echo $?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeb046972e8ab296a8e09ec0b28d319b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a6cf5db960aab2b4275c7ad391df9b7/" rel="bookmark">
			tomcat怎么启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具/原料 tomcat
方法一 1 首先你要知道你把tomcat放到哪里了，tomcat的安装有两种方法，一种是解压就可以使用，一种需要向程序一样进行安装。
如果是安装的tomcat，那么首先单击开始菜单。
2 在开始菜单中选择所有程序，在所有程序中有一个Apache Tomcat…… 的文件夹。单击展开。
3 选择这个文件夹中的Configure Tomcat程序。单击启动。
4 在主界面中你就可以看到一个Start的开始按钮了。单击等待一会就可以启动tomcat了。
5 如果你的压缩文件，那么也很简单。
打开解压目录，然后找到BIN目录，打开。
6 选择tomcat程序，双击启动即可。呈现的界面和上面一样。单击start即可启动。
END 方法二 在myeclipse中可以快速的启动tomcat，打开你的myeclipse，单击下面的server选项卡。
2 首先需要确定你的tomcat已经在myeclipse中配置正确了，否则你找不到tomcat的选项。
选择tomcat，单击启动即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0609794611582aa196148d0f2922ba40/" rel="bookmark">
			awstats网站日志分析工具实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 它可以统计您站点的如下信息： 一：访问量，访问次数，页面浏览量，点击数，数据流量等 二：精确到每月、每日、每小时的数据 三：访问者国家 四：访问者IP 五：Robots/Spiders的统计 六：访客持续时间 七：对不同Files type 的统计信息 八：Pages-URL的统计 九：访客操作系统浏览器等信息 十：其它信息（搜索关键字等等） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09bd9ab41abce5bf0709ede3eaf5a348/" rel="bookmark">
			matlab中图例换行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 matlab中图例换行, 使用array或cell是不行的, 需要[] vClassNumString = []; for k = 1 : length(vClassName) vClassNumString = [vClassNumString,sprintf('%s %d\n', vClassName{k}, vClassNum(k))]; end legend(vClassNumString); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72a04e387ae8b5a7b1e65fb23ca5d5b3/" rel="bookmark">
			fatal error C1900
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 编译64位库时发生错误：fatal error C1900: “P1”(第“20081201”版)和“P2”(第“20080116”版)之间 Il 不匹配 解决方法: 替换编译器下的c2.dll 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e8cdd2db3bb789380e3375ab77a1138/" rel="bookmark">
			JS 跳转页面延迟方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法1：
[html] view plain copy &lt;span style="font-size:12px;"&gt;&lt;script type="text/javascript"&gt; &lt;!-- function go(t,url){ //t设置跳转时间：秒 //url设置跳转网址 document.write("&lt;div id=text&gt;本页将在&lt;strong id='tt'&gt;&lt;/strong&gt;后，跳转至：&lt;span id='link'&gt;&lt;/span&gt;&lt;/div&gt;"); document.getElementById("link").innerHTML="&lt;a href="+url+"&gt;"+url+"&lt;/a&gt;"; $(t,url); } function $(t,url){ ta = t-1; tb = t + "000"; d = document.getElementById("tt"); d.innerHTML=t; window.setInterval(function() { go_to(url); },1000); } function go_to(url){ d.innerHTML=ta--; if(ta&lt;0){ document.write("正在跳转至：&lt;a href="+url+"&gt;"+url+"&lt;/a&gt;"); location.href=url; } else{ return; } } //--&gt; &lt;/script&gt; &lt;script type="text/javascript"&gt; go(5, "/Login.aspx") &lt;/script&gt; &lt;/span&gt; 方法2： window.setTimeout("window.location='index.shtml'",2000);
//两秒后跳转新页面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4de79a22a8f6e35d2c642f762bff93e1/" rel="bookmark">
			phpmyadmin打开很慢的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了phpmyadmin打开很慢的解决方法,一般这个问题的原因是phpmyadmin的版本检测造成的,因为phpmyadmin的官网有时会打不开,这时只要取消代码中的版本检测即可解决这个问题,需要的朋友可以参考下
phpmyadmin4系列通通加载缓慢的最终原因是最近phpmyadmin的官网经常打不开，而phpmyadmin页面会自动检查官网上的程序版本更新，所以当你进入phpmyadmin管理页面点击数据库的时候phpmyadmin一直在尝试连接官网从而把整个打开过程拖得很慢。
最终的解决办法是不让phpmyadmin检查更新，找到phpmyadmin目录下version_check.php文件，具体修改如下：
复制代码代码如下: if (isset($_SESSION['cache']['version_check']) &amp;&amp; time() &lt; $_SESSION['cache']['version_check']['timestamp'] + 3600 * 6 ) { $save = false; $response = $_SESSION['cache']['version_check']['response']; } else { // $save = true; // $file = 'http://www.phpmyadmin.net/home_page/version.json'; // if (ini_get('allow_url_fopen')) { // $response = file_get_contents($file); // } else if (function_exists('curl_init')) { // $curl_handle = curl_init($file); // curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, 1); // $response = curl_exec($curl_handle); // } } 上面代码是通过注释掉else{......}中间这段来取消phpmyadmin连接官网version.json来检查更新
修改完后phpmyadmin马上又回到秒开了。
附：另一个网友的解决方法
复制代码代码如下: 第一步: # 文件名 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4de79a22a8f6e35d2c642f762bff93e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/360ee6825bbf021190a7810d09730610/" rel="bookmark">
			C语言中的32个关键字及其意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、C语言的关键字共有32个，根据关键字的作用，可分其为 数据类型关键字、 控制语句关键字、 存储类型关键字和 其它关键字四类。 1 、数据类型关键字（12个）： (1) char ：声明字符型变量或函数 (2) double ：声明双精度变量或函数 (3) enum ：声明 枚举类型 (4) float：声明 浮点型变量或函数 (5) int： 声明 整型变量或函数 (6) long ：声明长整型变量或函数 (7) short ：声明短整型变量或函数 (8) signed：声明有符号类型变量或函数 (9) struct：声明结构体变量或函数 (10) union：声明 共用体（联合）数据类型 (11) unsigned：声明无符号类型变量或函数 (12) void ：声明函数无返回值或无参数，声明无类型指针（基本上就这三个作用） 2、控制语句关键字（12个）：A循环语句 (1) for：一种循环语句(可意会不可言传） (2) do ：循环语句的循环体 (3) while ：循环语句的循环条件 (4) break：跳出当前循环 (5) continue：结束当前循环，开始下一轮循环 B条件语句 (1)if: 条件语句 (2)else ：条件语句否定分支（与 if 连用） (3)goto：无条件跳转语句 C开关语句 (1)switch :用于开关语句 (2)case：开关语句分支 (3)default：开关语句中的“其他”分支 D返回语句return ：子程序返回语句（可以带参数，也看不带参数） 3、 存储类型关键字（4个）(1)auto ：声明自动变量 一般不使用 (2)extern：声明变量是在其他文件正声明（也可以看做是 引用变量） (3)register：声明积存器变量 (4)static ：声明 静态变量 4、 其它关键字（4个）：(1)const ： 声明只读变量 (2) sizeof：计算数据类型长度 (3)typedef：用以给数据类型取别名（当然还有其他作用 (4) volatile：说明变量在程序执行中可被隐含地改变 二、C语言中的9中控制语句 goto语句 :无条件转向; if语句:判断语句; while循环语句; do-while语句:先执行循环体,然后判断循环条件是否成立.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/360ee6825bbf021190a7810d09730610/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d940052591c991133fc5c39f4099cc39/" rel="bookmark">
			Java调用ZMQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过上面两篇博客已经对ZMQ和如何编译ZMQ有所了解了，在第一篇文章中介绍了ZMQ有三种模式，这篇博客就写一个关于发布订阅模式的Demo，希望对读者能够起到学习的作用，那要是在深入学习的话，可以参照zmq的官方和它自身带的实例代码学习。
在写DEMO之前需要将上篇博客编译之后的lib文件配置到环境变量中，
C:\Users\CJQ\Desktop\zeromq-2.2.0\lib;C:\Users\CJQ\Desktop\zeromq-2.2.0\zeromq-jzmq\lib
也就是将zmq的lib文件夹和jzmq的文件夹放到环境变量中。
之后我们来写发布端代码，
package com.wh.mq.demo2; import org.zeromq.ZMQ; import org.zeromq.ZMQ.Context; import org.zeromq.ZMQ.Socket; public class Sync_PUB { public static void main(String[] args) throws InterruptedException { Context context = ZMQ.context(1); Socket publisher = context.socket(ZMQ.PUB); publisher.bind("tcp://*:5561"); //zmq发送速度太快，在订阅者尚未与发布者建立联系时，已经开始了数据发布 Thread.sleep(1000); int update_nbr; for (update_nbr = 20; update_nbr &lt; 40; update_nbr++) { Stringa="{\"magicNum\":\"CHINSOFT\",\"varName\":\"ZJ_YD_1\",\"varType\":\"5\",\"varValue\":"+update_nbr+",\"varQuality\":\"1111\",\"varTime\":"+System.currentTimeMillis()/1000+"}"; publisher.send(a.getBytes(), ZMQ.NOBLOCK); System.out.println(update_nbr); Thread.sleep(1000); } publisher.close(); context.term(); } } 发布端需要通过context.socket（ZMQ.PUB）表示为发布端，通过bind方法来创建发布端连接，等待订阅者连接。
之后通过send方法将数据发送到出去。
之后来写订阅端代码
public classSync_SUB1 { publicstaticvoidmain(String[] args) { Context context = ZMQ.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d940052591c991133fc5c39f4099cc39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b6545754219e523b81d93bc4727cac9/" rel="bookmark">
			ZMQ简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ZeroMQ的背景介绍
官方： “ZMQ(以下ZeroMQ简称ZMQ)是一个简单好用的传输层，像框架一样的一个socket library，他使得Socket编程更加简单、简洁和性能更高。是一个消息处理队列库，可在多个线程、内核和主机盒之间弹性伸缩。ZMQ的明确目标是“成为标准网络协议栈的一部分，之后进入Linux内核”。现在还未看到它们的成功。但是，它无疑是极具前景的、并且是人们更加需要的“传统”BSD套接字之上的一 层封装。ZMQ让编写高性能网络应用程序极为简单和有趣。”
与其他消息中间件相比，ZMQ并不像是一个传统意义上的消息队列服务器，事实上，它也根本不是一个服务器，它更像是一个底层的网络通讯库，在Socket API之上做了一层封装，将网络通讯、进程通讯和线程通讯抽象为统一的API接口。
二、ZMQ是什么
阅读了ZMQ的Guide文档后，我的理解是，这是个类似于Socket的一系列接口，他跟Socket的区别是：普通的socket是端到端的（1:1的关系），而ZMQ却是可以N：M 的关系，人们对BSD套接字的了解较多的是点对点的连接，点对点连接需要显式地建立连接、销毁连接、选择协议（TCP/UDP）和处理错误等，而ZMQ屏蔽了这些细节，让你的网络编程更为简单。ZMQ用于node与node间的通信，node可以是主机或者是进程。
三、三种模型
a) 应答模式：
使用REQ-REP套接字发送和接受消息是需要遵循一定规律的。客户端首先使用zmq_send()发送消息，再用zmq_recv()接收，如此循环。如果打乱了这个顺序（如连续发送两次）则会报错。类似地，服务端必须先进行接收，后进行发送。
b) 订阅发布模式
PUB-SUB套接字组合是异步的。客户端在一个循环体中使用recv ()接收消息，如果向SUB套接字发送消息则会报错；类似地，服务端可以不断地使用send ()发送消息，但不能再PUB套接字上使用recv ()。
关于PUB-SUB套接字，还有一点需要注意：你无法得知SUB是何时开始接收消息的。就算你先打开了SUB套接字，后打开PUB发送消息，这时SUB还是会丢失一些消息的，因为建立连接是需要一些时间的。很少，但并不是零。解决此问题需要在PUB端加入sleep。
c) 基于分布式处理（管道模式）
这篇博客对ZMQ有一个初步的介绍，下篇博客介绍如何通过JAVA来调用ZMQ实现消息处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d2eb0d5148e545d6fb86a7ee27e1756/" rel="bookmark">
			JVM实用参数（八）GC日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列的最后一部分是有关垃圾收集（GC）日志的JVM参数。GC日志是一个很重要的工具，它准确记录了每一次的GC的执行时间和执行结果，通过分析GC日志可以优化堆设置和GC设置，或者改进应用程序的对象分配模式。
-XX:+PrintGC 参数-XX:+PrintGC（或者-verbose:gc）开启了简单GC日志模式，为每一次新生代（young generation）的GC和每一次的Full GC打印一行信息。下面举例说明：
1[GC 246656K-&gt;243120K(376320K), 0.0929090 secs] 2[Full GC 243120K-&gt;241951K(629760K), 1.5589690 secs] 每行开始首先是GC的类型（可以是“GC”或者“Full GC”），然后是在GC之前和GC之后已使用的堆空间，再然后是当前的堆容量，最后是GC持续的时间（以秒计）。
第一行的意思就是GC将已使用的堆空间从246656K减少到243120K，当前的堆容量（译者注：GC发生时）是376320K，GC持续的时间是0.0929090秒。
简单模式的GC日志格式是与GC算法无关的，日志也没有提供太多的信息。在上面的例子中，我们甚至无法从日志中判断是否GC将一些对象从young generation移到了old generation。所以详细模式的GC日志更有用一些。
-XX:PrintGCDetails 如果不是使用-XX:+PrintGC，而是-XX:PrintGCDetails，就开启了详细GC日志模式。在这种模式下，日志格式和所使用的GC算法有关。我们首先看一下使用Throughput垃圾收集器在young generation中生成的日志。为了便于阅读这里将一行日志分为多行并使用缩进。
1[GC 2 [PSYoungGen: 142816K-&gt;10752K(142848K)] 246648K-&gt;243136K(375296K), 0.0935090secs 3] 4[Times: user=0.55 sys=0.10, real=0.09 secs] 我们可以很容易发现：这是一次在young generation中的GC，它将已使用的堆空间从246648K减少到了243136K，用时0.0935090秒。此外我们还可以得到更多的信息：所使用的垃圾收集器（即PSYoungGen）、young generation的大小和使用情况（在这个例子中“PSYoungGen”垃圾收集器将young generation所使用的堆空间从142816K减少到10752K）。
既然我们已经知道了young generation的大小，所以很容易判定发生了GC，因为young generation无法分配更多的对象空间：已经使用了142848K中的142816K。我们可以进一步得出结论，多数从young generation移除的对象仍然在堆空间中，只是被移到了old generation：通过对比绿色的和蓝色的部分可以发现即使young generation几乎被完全清空（从142816K减少到10752K），但是所占用的堆空间仍然基本相同（从246648K到243136K）。
详细日志的“Times”部分包含了GC所使用的CPU时间信息，分别为操作系统的用户空间和系统空间所使用的时间。同时，它显示了GC运行的“真实”时间（0.09秒是0.0929090秒的近似值）。如果CPU时间（译者注：0.55秒+0.10秒）明显多于”真实“时间（译者注：0.09秒），我们可以得出结论：GC使用了多线程运行。这样的话CPU时间就是所有GC线程所花费的CPU时间的总和。实际上我们的例子中的垃圾收集器使用了8个线程。
接下来看一下Full GC的输出日志
1[Full GC 2 [PSYoungGen: 10752K-&gt;9707K(142848K)] 3 [ParOldGen: 232384K-&gt;232244K(485888K)] 243136K-&gt;241951K(628736K) 4 [PSPermGen: 3162K-&gt;3161K(21504K)], 1.5265450 secs 5] 除了关于young generation的详细信息，日志也提供了old generation和permanent generation的详细信息。对于这三个generations，一样也可以看到所使用的垃圾收集器、堆空间的大小、GC前后的堆使用情况。需要注意的是显示堆空间的大小等于young generation和old generation各自堆空间的和。以上面为例，堆空间总共占用了241951K，其中9707K在young generation，232244K在old generation。Full GC持续了大约1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d2eb0d5148e545d6fb86a7ee27e1756/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b20014fc7bb35ebb6fcdf3493c563d9/" rel="bookmark">
			Profibus DP/PA/FMS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PROFIBUS DP（DecentralizedPeriphery 分布式外围设备）
用于现场层的高数数据传输，中央处理器（PLC,PC等）通过高数串行线同分散的现场设备（IO，驱动，阀门等）进行通信。
PROFIBUS PA（ProcessAutomation 过程自动化）
适用于PROFIBUS过程自动化，PA将自动化系统和过程控制系统与压力、温度、液位变送器等现场设备相连接，并可以用来替代4-20mA的模拟技术。
PROFIBUS FMS（Fieldbus Message Specification 现场总线报文规范）
主要用于解决车间监控级通信任务，提供大量的通信服务。FMS定义了主站与主站之间的通信模型，主要处理单元级的多主站数据通信，可以在不同的PLC之间传输数据。
DP和PA的区别：
1 DA和PA的区别差别在于物理层，DP采用485电气标准，而PA采用IEC1158-2MBP-IS标准，两根电缆除了传输数据外，还可以为仪表供电。
2 DP提供最高12Mbps的通信速率，但是PA只有一个固定的通信速率31.25kbps。
3 PA可用于本质安全防爆场合，DP则不行。
4 DP为非归零编码，而PA为曼彻斯特编码。
5 DP为基于字符的异步传输方式，PA为基于帧的同步传输方式。
6 DP为1bit的奇偶校验，而PA为16bit的CRC校验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1fde27924cd27a47adb0c3873b76fa9/" rel="bookmark">
			初探linux子系统集之led子系统(三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		世界杯结束了，德国战车夺得了大力神杯，阿根廷最终还是失败了。也许3年，5年，或者10年后，人们就不知道巴西世界杯的亚军是谁，但是总是会记得冠军是谁。就像什么考试，比赛，第一永远会被人们所记住，所以我们都想去追寻第一，渴望第一，在一次次的追寻中，成者为王败者为寇。而处在第一的位置，永远担心下面的会超越自己，从而活得很累，而第二永远想争取第一，也活得很累，有时候，想想，人一生当中，成功真的就那么重要吗？富有真的那么重要吗？采菊东篱下，悠然见南山不是也很有诗意吗？说了好多，还是继续写led子系统吧。
前面写了很多关于led子系统的相关知识，现在终于可以开始分析leds-gpio.c这个驱动了。
注册了platform驱动。
platform_driver_register(&amp;gpio_led_driver);
platform总线就不多说了，在自己的平台下添加platform device就可以了。
当device和dirver匹配后，就会调用driver的probe函数，这里调用的是下面这个函数。
static int __devinit gpio_led_probe(struct platform_device *pdev) { structgpio_led_platform_data *pdata = pdev-&gt;dev.platform_data; struct gpio_leds_priv*priv; int i, ret = 0; if (pdata &amp;&amp;pdata-&gt;num_leds) { priv =kzalloc(sizeof_gpio_leds_priv(pdata-&gt;num_leds), GFP_KERNEL); if (!priv) return-ENOMEM; priv-&gt;num_leds= pdata-&gt;num_leds; for (i = 0;i &lt; priv-&gt;num_leds; i++) { ret= create_gpio_led(&amp;pdata-&gt;leds[i], &amp;priv-&gt;leds[i], &amp;pdev-&gt;dev,pdata-&gt;gpio_blink_set); if(ret &lt; 0) { /*On failure: unwind the led creations */ for(i = i - 1; i &gt;= 0; i--) delete_gpio_led(&amp;priv-&gt;leds[i]); kfree(priv); returnret; } } } else { priv =gpio_leds_create_of(pdev); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1fde27924cd27a47adb0c3873b76fa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33a8ea7d156d56d314ed6d280cfd91fd/" rel="bookmark">
			bat中if语句的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例如，删除“C:\Documents and Settings\Administrator\桌面\T1\txt\批处理实验\unit1”里的a.txt文件，使用if的代码如下：
@echo offif exist "C:\Documents and Settings\Administrator\桌面\T1\txt\批处理实验\unit1\a.txt" (echo file is find!del "C:\Documents and Settings\Administrator\桌面\T1\txt\批处理实验\unit1\a.txt") else (echo file is not found!)pause&gt;nul 将上述代码保存为if_del.bat，效果如下：
2.if——条件判断（分支）语句 “if”语句是批处理中的条件分支语句，表示的意思就是“如果...则...否则...”，大多用在批处理程序中的条件处理部分。“if”语句在批处理中使用的是比较广泛的，例如要查看某个文件，则首先要确定该文件存在才可以查看，否则MS-DOS会抛出错误信息，这个时候就可以使用“if”语句进行判断。“if”命令语句是通过条件成立与否来决定语句的执行，这里的条件成立和条件不成立可以理解为“true”和“false”，但是批处理中不存在这两个常量。“if”语句所表达的意思是只有当条件成立时才会执行指定的命令语句，主要有以下几种用法。
1.判断信息是否相等（“==”）
“if”命令语句就是用于条件的判断，然而由于批处理脚本本身比较弱化，所以初始的MS-DOS只能支持信息相等的比较，也就是只支持“==”操作符。用于比较字符串与字符串、变量与变量、变量与字符串之间是否相等，如果相等则表示条件成立。用法如下：
if [not] 信息比较表达式 (
命令行1
) else (
命令行2
)
这里的“信息比较表达式”的格式为“字符串1==字符串2”或“变量1==变量2”或“变量==字符串”的形式，也即是说只能使用“==”进行字符串或变量之间的比较，上面的“not”表示相反操作，不做多的解释，来看下面的例子：
1 2 3 4 5 6 7 @ echo off if abc==ABC ( echo abc euqal ABC ) else ( echo abc not euqal ABC ) pause&gt;nul 保存为批处理文件，执行既可以看到效果，可以自行修改，添加“not”试试。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33a8ea7d156d56d314ed6d280cfd91fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d7dfaafcb2701a9f7c63c8730958d89/" rel="bookmark">
			Bash快捷键和终端使用vi快捷键方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里讲解的bash快捷键是在emacs编辑模式下有效，bash默认为emacs编辑模式，如果想修改成vi编辑模式，可以通过命令set -o vi来设置，这样就可以在终端使用vi的关键键。更多相关设置可以参考man builtin页面关于set命令的介绍。
[root@rhel6164 SPECS]$ echo $SHELLOPTS braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor #默认是emacs编辑模式 [root@rhel6164 SPECS]$ set -o vi #修改成vi编辑模式 [root@rhel6164 SPECS]$ echo $SHELLOPTS braceexpand:hashall:histexpand:history:interactive-comments:monitor:vi 编辑命令：
命令
说明
命令
说明
Ctrl+a
移动到命令行首
Ctrl+e
移动到命令行尾
Ctrl+f
按字符前移(向右)
Ctrl+b
按字符后移(向左)
Alt+f
按单词前移(向右)
Alt+b
按单词后移(向左)
Ctrl+u
从光标处剪切至命令行首
Ctrl+k
从光标处剪切至命令行尾
Ctrl+w
从光标处剪切至字符首
Alt+d
从光标处剪切至字符尾
Ctrl+d
删除光标处的字符
Ctrl+h
删除光标前的字符
Ctrl+]
从当前光标处向后搜索字符
Ctrl+Alt+]
从当前光标处向前搜索字符
Ctrl+y
粘贴至光标后
!$ 显示系统最近的一条参数
↑(Ctrl+p)显示上一条命令↓(Ctrl+n) 显示下一条命令 重新执行命令：
命令
说明
Ctrl+r
逆向搜索历史命令
Ctrl+g
从历史命令搜索中退出
Alt+.
使用上一条命令的最后一个参数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e9592c24012b9fc102019d84bc74ede/" rel="bookmark">
			Web前端 各种面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		幸运且光荣的被老大安排了一个任务 - “去整理些前端面试题”。年前确实不是招人的好时候，所以我们前端团队经过了超负荷的运转，终于坚持过了春节。春节以后就开始招人啦，这套题考察的目标就是基础基础再基础，嘿嘿。
事先声明：
◆ 这些题目的来源：面试曾经被问过;工作被别人问过或者遇见过;网上看见过...
◆ 答案真心不给提供，真的是许多问题都需要个人的理解和沉淀，所以还请各位自己动手...前端可以试试自己差不多能回答多少题，哈哈。
◆ 其实很多题我也没有好答案，面试的时候如果遇到牛人我也可以顺便交流交流，反正我也只是一面，不丢人也不怕丢人。
◆ 如果朋友们有好的面试题欢迎提建议，我会其实补充更新的，先谢谢各位了。
HTML相关
1. &lt;!DOCTYPE&gt;标签的定义与用法。
2. 块级元素和行内元素都有哪些?
3. 你真的了解HTML吗? 雅虎面试题　把前面黄底那段拿去搜索下就知道了(曾在某浪公司面试的时候被问到过，确实是很好的问题)。
CSS相关
1. 介绍所知道的CSS hack技巧(如：_， *， +， \9， !important 之类)。
2. 介绍CSS盒模型。
3. CSS层叠是什么?介绍一下。
4. 都知道哪些CSS浏览器兼容性问题。
5. 有时会被问到些刁钻点的题，比如position值都有哪些，CSS3都有哪些新内容...
JavaScript基础相关
1. HTTP协议的状态消息都有哪些?(如200、302对应的描述)
2. AJAX是什么? AJAX的交互模型(流程)? AJAX跨域的解决办法?
3. 同步和异步的区别?
4. 简述JavaScript封装。
5. JavaScript继承有哪两种形式形式，进行描述。
6. 什么是闭包?以下代码点击&lt;p&gt; 会输出什么?为什么?能大概说明白的话继续问能想出几种解决办法。
&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;闭包演示&lt;/title&gt; &lt;style type="text/css"&gt; p {background:gold;} &lt;/style&gt; &lt;script type="text/javascript"&gt; function init() { var pAry = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e9592c24012b9fc102019d84bc74ede/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5519b3c9eb62d40d291d97ff6e20d330/" rel="bookmark">
			ubuntu eclipse framework 源码开发，智能提示很卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在ubuntu 下做安卓源码的开发，遇到了一个很痛苦的事情就是eclipse的智能提示很卡，好不容易有提示了，一回车又没有自动填充代码。但是自己新建小工程，智能提示却不卡。于是开始网上查找原因，2天过去，网上所有的方法都试过一遍，还重新装了系统，换了系统，换了源码，换了java，换了键盘，差点换主机。。。。居然还是卡，而我同事的却一点也不卡，问他为什么，他也来看了，弄了好久也没解决。
快要崩溃的时候，还是公司的前辈给力，把情况和她说了一下，她问我有没有把源码目录下的development/ide/eclipse/.classpath 拷贝到源码目录下。我当时就傻了，要这个的吗？她说当然要，这个文件是个索引，eclipse就是通过这个来查找相关的java文件的，没有这个文件，可能就会导致eclipse找不到源码中相关的类。我似乎有点明白了，赶紧去试试看。
解决方法：http://blog.csdn.net/wufen1103/article/details/6667883
进入到源码根目录，其实这个是安卓源码开发的标准教材里的做法。
cd /path/to/android/root cp development/ide/eclipse/.classpath .
chmod u+w .classpath
重新打开eclipse，好爽。搞定了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1caa57283f57323d19ca1389cc25efad/" rel="bookmark">
			VC&#43;&#43; MFC编程学习笔记（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		觉得初步学习MFC，不用先把所有的控件的所有的属性，风格，扩展风格，以及消息处理函数全部都掌握。
首先把最常用的空间如编辑框，组合框，按钮，静态文本框等控件掌握。一步一步来，以后多用控件再慢慢扩充那些细节。
熟悉10种常用控件
① 静态文本框：显示文字说明
② 编辑框：CEdit m_editXxx （.h头文件声明）、DoDataExchange（.cpp中实现）
③ 按钮（Button、Radio Button、Check Box）：CButton m_checkXxx（.h头文件中声明）
Ctrl+D控件顺序Tab设置
④ 列表控件：在窗口初始化函数动态添加 CListBox m_xxx.AddString(_T(“”))
⑤ 组合框：编辑框与列表的组合，常用DropList和DropDown类型 Ccombox
⑥ 滚动条：
⑦ 图片控件：将文件放进res文件夹，import导入资源，type属性（静态加载） 动态加载
⑧ 列表视图：
⑨ 树形控件、进度条控件：
⑩ 标签控件：容器（切换对话框）、添加对话框，添加类（类视图）、主对话框引入对话框头文件，类中声明对话框对象（*.h）
对话框、菜单栏、工具栏、状态栏
菜单栏和工具栏某些ID要一致，增加消息处理函数。
状态栏可以由常用的编辑框（风格：READ-ONLY,属性DISABLE）组成，后面获取编辑框CString变量，m_editStr实施更新状态即可。
对话框初始化函数OnInitDialog（）
控件变量：control显示、value值运算
类：
三种类型：private public protected
变量（属性）
函数（方法）
映射（事件、消息）
消息：
消息值，wParam参数，lParam参数
消息处理函数声明：afx_msg void memberFun（）在类中的.h头文件中声明。并在.cpp中定义调用。
ON_通知消息码（nID，memberFun）此消息映射宏放到BEGIN_MESSAGE_MAP和END_MESSAGE_MAP之间。
参考来源：
http://wenku.baidu.com/link?url=Q8TpWRIc0jX5fZp0JtQnI2xOryVJvY39GVL0xgURNK1KgeWGFzf2WHEkL3idC4yK9JMogQAjmAJW4yOv4yYZpXk9Vv1zIX8Yu5fumTRp7t7
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1de3d20160636b682d462a0fe69bacc9/" rel="bookmark">
			Mockito：一个强大的用于Java开发的模拟测试框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 本文将介绍模拟测试框架Mockito的一些基础概念, 介绍该框架的优点，讲解应用Mockito的Java示例。
模拟(Mock)的概念 在软件开发的世界之外， "mock"一词是指模仿或者效仿。因此可以将“mock”理解为一个替身，替代者。在软件开发中提及"mock"，通常理解为模拟对象或者fake。
译者注：mock等多代表的是对被模拟对象的抽象类，你可以把fake理解为mock的实例。不知道这样说准不准确:) Fake通常被用作被测类的依赖关系的替代者.。 名词定义 依赖关系 – 依赖关系是指在应用程序中一个类基于另一个类来执行其预定的功能。依赖关系通常都存在于所依赖的类的实例变量中。 被测类 – 在编写单元测试的时候，“单元”一词通常代表一个单独的类及为其编写的测试代码。被测类指的就是其中被测试的类。 为什么需要模拟? 在我们一开始学编程时，我们所写的对象通常都是独立的。hello world之类的类并不依赖其他的类（System.out除外），也不会操作别的类。但实际上软件中是充满依赖关系的。我们会基于service类写操作类，而service类又是基于数据访问类(DAOs)的，依次下去。
图1 类的依赖关系
单元测试的思路就是我们想在不涉及依赖关系的情况下测试代码。这种测试可以让你无视代码的依赖关系去测试代码的有效性。核心思想就是如果代码按设计正常工作，并且依赖关系也正常，那么他们应该会同时工作正常。
下面的代码就是这样的例子：
import java.util.ArrayList; public class Counter { public Counter() { } public int count(ArrayList items) { int results = 0; for(Object curItem : items) { results ++; } return results; } } 如你所见，上面的例子十分简单，但它阐明了要点。当你想要测试count方法时，你会针对count方法本身如何工作去写测试代码。你不会去测试ArrayList是否正常工作，因为你默认它已经被测过并且工作正常。你唯一的目标就是测试对ArrayList的使用。 模拟对象的概念就是我们想要创建一个可以替代实际对象的对象。这个模拟对象要可以通过特定参数调用特定的方法，并且能返回预期结果。 模拟有哪些关键点? 在谈到模拟时，你只需关心三样东西：设置测试数据，设定预期结果，验证结果。一些单元测试方案根本就不涉及这些，有的只涉及设置测试数据，有的只涉及设定预期结果和验证。
Stubbing （桩） Stubbing就是告诉fake当与之交互时执行何种行为过程。通常它可以用来提供那些测试所需的公共属性（像getters和setters）和公共方法。
当谈到stubbing方法，通常你有一系列的选择。或许你希望返回一个特殊的值，抛出一个错误或者触发一个事件，此外，你可能希望指出方法被调用时的不同行为（即通过传递匹配的类型或者参数给方法）。
这咋一听起来工作量很大，但通常并非这样。许多mocking框架的一个重要功能就是你不需要提供stub 的实体方法，也不用在执行测试期间stub那些未被调用的方法或者未使用的属性。
设置预期 Fake的一个关键的特性就是当你用它进行模拟测试时你能够告诉它你预期的结果。例如，你可以要求一个特定的函数被准确的调用3次，或不被调用，或调用至少两次但不超过5次，或者需要满足特定类型的参数、特定值和以上任意的组合的调用。可能性是无穷的。
通过设定预期结果告诉fake你期望发生的事情。因为它是一个模拟测试，所以实际上什么也没发生。但是，对于被测试的类来说，它并无法区分这种情况。所以fake能够调用函数并让它做它该做的。
值得注意的是，大多数模拟框架除了可以创建接口的模拟测试外，还可以创建公有类的模拟测试。 验证预期结果 设置预期和验证预期是同时进行的。设置预期在调用测试类的函数之前完成，验证预期则在它之后。所以，首先你设定好预期结果，然后去验证你的预期结果是否正确。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1de3d20160636b682d462a0fe69bacc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b425c7e07128bc0370fd28c0f8571716/" rel="bookmark">
			对modis投影转换MRT参数设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近处理了modis数据，用到了MRT工具，于是对于各个投影的相关参数设置在网上找了些资料，收集总结了一些如下所示。我主要是投影到UTM上。
MRT工具中常用的投影主要有：Albers Equal Area、Geographic、Transverse Mercator、UTM等、现在把这几种投影的参数进行一一介绍：
1、Albers Equation Area（阿尔伯斯等面积）
SMajor：长半轴，不同基准面参数不同。
SMinor：短半轴，不同基准面参数不同。
STDPR1：第一标准纬线，在中国一般为25°。
STDPR2：第二标准纬线，在中国一般为47°。
CentMer：中央经线，一般为105°。
OriginLat：起始纬度，一般为0°
FE：东伪偏移，一般为0m。
FN：北伪偏移，一般为0m。
2、Geographic（地理坐标）
这个坐标不是平面直角坐标，二是地理坐标，也就是球面坐标，在参数设置界面除了基准面不用设置其它参数，只要根据不同需要，选择不同的基准面即可。
3、Transverse Mercator（横轴墨卡托）
这是一个在我国使用比较广泛的坐标系统，我国的北京54和西安80坐标系统都是横轴墨卡托的变种，在某些不支持北京54和西安80坐标系的软件中，都将这两种坐标识别为横轴墨卡托。在MRT中，其参数的含义为：
SMajor：长半轴，不同基准面参数不同。
SMinor：短半轴，不同基准面参数不同。
Factor：比例因子，为1.0。
CentMer：中央经线，不同分度带中央经线不同。
OriginLat：起始纬度，一般为0°
FE：东伪偏移，一般为500km，如果需要加带号，那么为XX500000m，其中XX为分度带号。
FN：北伪偏移，一般为0m。
4、UTM（通用横轴墨卡托）
通用横轴墨卡托是横轴墨卡托的改进，其与横轴墨卡托或高斯-克吕格的主要区别在与UTM的比例因子为0.9996。在MRT中UTM的参数设置比较简单：
Lon/Z：区域内任意一点的经度坐标，也可以设置为零，如果设置为0，那么UTM Zone中必须填入一个分区代码。
Lat/Z：区域内任意一点的纬度坐标，也可以设置为0，如果设置为零，那么UTM Zone中必须填入一个分区代码。
其他投影参数可参考MRT手册。
下面是网上找的UTM一部分的带号参数：
以下为中国的重要经纬线：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d0bd1e8e1c8fd16ceb17cfe042922d1/" rel="bookmark">
			python学习1-pycharm安装问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python看了几天了，一直用的cmd里面来敲些简单的代码，今天安了个IDL，pycharm，安装完后运行出现问题：
the JVM could not be started. the maximum heap size might be too large or an antivirus or firewall tool could block the execution.
说最大堆大小可能太大，或者一个病毒或者防火墙阻止了，解决办法网上查了下，编辑安装目录中 \bin\pycharm.exe.vmoptions里的-Xmx选项为256m就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26e84301c975db11a06e8dcde044f9a5/" rel="bookmark">
			最近modis的学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直在研究温度反演，最近开始采用modis数据了，网上很多modis数据的介绍。因为我采用的是八天的温度合成产品，下面只把合成的时间列出来。最后是modis数据Tile组织方式。
时相 日期 DOY
1 1月1日 1
2 1月9日 9
3 1月17日 17
4 1月25日 25
5 2月2日 33
6 2月10日 41
7 2月18日 49
8 2月26日 57
9 3月6日 65
10 3月14日 73
11 3月22日 81
12 3月30日 89
13 4月7日 97
14 4月15日 105
15 4月23日 113
16 5月1日 121
17 5月9日 129
18 5月17日 137
19 5月25日 145
20 6月2日 153
21 6月10日 161
22 6月18日 169
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26e84301c975db11a06e8dcde044f9a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/022252423877e7e2b7f3e37c60386c89/" rel="bookmark">
			两层交换机vlan互通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两层交换机工作在链路层 ，一般情况下两层交换机均允许支持vlan划分；但由于不支持端口的IP地址划分（需要网络层才支持IP地址，需要三层交换机才能满足相关功能），只能通过将交换机地址设置为hybird模式才能实现不同vlan之间的数据通信，
例：将两层交换机划分为vlan1、vlan2、vlan3、vlan4四个子网，其中vlan2、vlan3、vlan4三个子网互不相同；vlan1与vlan2、vlan3、vlan4均联通:
1. 创建VLAN2 [Quidway]vlan 2 2. 创建VLAN3 [Quidway-vlan2]vlan 3 3. 创建VLAN4 [Quidway-vlan3]vlan 4 4. 进入端口Ethernet1/0/1 进入端口Ethernet1/0/1 [Quidway-vlan4] interface Ethernet1/0/1 5. 将端口设置为hybrid模式 [Quidway-Ethernet1/0/1]port link-type hybrid 6. 设置端口pvid为1 [Quidway-Ethernet1/0/1]port hybrid pvid vlan 1 7. 允许VLAN1，2，3，4不打标签通过 [Quidway-Ethernet1/0/1]port hybrid vlan 1 to 4 untagged 8. 进入端口Ethernet1/0/2 [Quidway-Ethernet1/0/1]interface Ethernet1/0/2 9. 将端口设置为hybrid模式 [Quidway-Ethernet1/0/2]port link-type hybrid 10.设置端口pvid为2 [Quidway-Ethernet1/0/2]port hybrid pvid vlan 2 11. 允许VLAN1，2不打标签通过 [Quidway-Ethernet1/0/2]port hybrid vlan 1 to 2 untagged 12. 进入端口Ethernet1/0/3 [Quidway-Ethernet1/0/2]interface Ethernet1/0/3 13.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/022252423877e7e2b7f3e37c60386c89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/404f972589f37a0a9d655388bfe0a94a/" rel="bookmark">
			Android API等级和版本对应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着版本的更迭，应用程序编程接口（API）等级不断发生。下面将目前为止所有API等级罗列出来，并与Android各版本一一对应。 API等级1：Android 1.0 API等级2：Android 1.1 Petit Four API等级3：Android 1.5 Cupcake API等级4：Android 1.6 Donut API等级5：Android 2.0 Éclair API等级6：Android 2.0.1 Éclair API等级7：Android 2.1 Éclair API等级8：Android 2.2 - 2.2.3 Froyo API等级9：Android 2.3 - 2.3.2 Gingerbread API等级10：Android 2.3.3-2.3.7 Gingerbread API等级11：Android 3.0 Honeycomb API等级12：Android 3.1 Honeycomb API等级13：Android 3.2 Honeycomb API等级14：Android 4.0 - 4.0.2 Ice Cream Sandwich API等级15：Android 4.0.3 - 4.0.4 Ice Cream Sandwich API等级16：Android 4.1 Jelly Bean API等级17：Android 4.2 Jelly Bean API等级18：Android 4.3 Jelly Bean API等级19：Android 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/404f972589f37a0a9d655388bfe0a94a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e50e82085dc57e9bfe69320b3086f207/" rel="bookmark">
			为什么java输出字符串数组名直接输入字符数组？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中char 和数组char[]输出 两例辨析 例1
public class LastLaugh{
public static void main(String[] args){
System.out.print("H"+"a");
System.out.print('H'+'a');
}
}
运行结果是Ha169，不是HaH
+ 操作符当且仅当它的操作数中至少有一个是String类型时，才会执行字符串连接操作；否则，它执行的就是加法。
例2
总结：String.valueOf、StringBuffer.append以及System.out.print中都对char[]数组单独处理，即进行了重载，使之可以输出内容（或者对内容操作处理），而不是地址。
但是字符串拼接操作没有对char[]数组单独处理,所以它处理的是数组char[]的地址
public class ABC{
public static void main(String[] args){
String letters = "ABC";
char[] numbers = {'1', '2', '3'};
System.out.println(letters + " easy as " + numbers);
}
}
程序输出：ABC easy as [C@0472，而不是ABC easy as 123。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfcc738d53b39573acc0f402271088ec/" rel="bookmark">
			ubuntu下安卓源码编译环境的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然不是很明白下面的这堆东西是做什么的，但是在联网的情况下，把这三段代码，依次复制到终端，运行，就可以搭建好安卓的在ubuntu下的编译环境了。
sudo apt-get install ia32-libs
sudo apt-get install git gnupg flex bisongperf build-essential \
zip curl libc6-devlibncurses5-dev:i386 x11proto-core-dev \
libx11-dev:i386libreadline6-dev:i386 \
libgl1-mesa-dev g++-multilib mingw32tofrodos \
python-markdown libxml2-utilsxsltproc zlib1g-dev:i386
sudo ln -s/usr/lib/i386-linux-gnu/mesa/libGL.so.1 /usr/lib/i386-linux-gnu/libGL.so
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/259d2e11cd9641a0ce46ea8445b2b8e7/" rel="bookmark">
			xode5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址： http://adcdownload.apple.com/Developer_Tools/xcode_5.0.2/xcode_5.0.2.dmg command_line_tools_os_x_mountain_lion: http://adcdownload.apple.com/Dev ... e__october_2013.dmg command_line_tools_os_x_mavericks: http://adcdownload.apple.com/Dev ... te_october_2013.dmg
shell：
xcode-select --install
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8be965154f0cc609270928362a48a12a/" rel="bookmark">
			m_pConnection-&gt;Open和m_pRecordset-&gt;Open
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		m_pConnection-&gt;Open用在InitInstance()函数中，
用法：
m_pConnection.CreateInstance("ADODB.Connection"); m_pConnection-&gt;Open("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=D:\\studentDB.mdb","","",adModeUnknown); //打开本地Access 库studentDB.mdb 易看出，m_pConnection-&gt;Open是建立MFC应用程序和数据库的连接，
Data Source=D:\\studentDB.mdb是所连接的数据库的名称（包括详细路径），（如果是网络数据库，这里可以是IP地址）
****************************************************************************************************************************
m_pRecordset-&gt;Open是加在OnInitDialog()函数中的，
用法：
m_pRecordset.CreateInstance(__uuidof(Recordset)); m_pRecordset-&gt;Open("SELECT * FROM STUDENT",
theApp.m_pConnection.GetInterfacePtr(),
adOpenDynamic,
adLockOptimistic, adCmdText); 易看出，执行m_pRecordset-&gt;Open时，某个具体的数据库和应用程序已经连接上了，可以对数据库中的具体数据表进行操作了，
Open函数的第一个参数就是执行的SQL语句~~这里执行的是SELECT * FROM STUDENT
作用是查询STUDENT这个数据库所有内容，即 打开记录集
***********************************************************************************************************************
执行完以上部分后，就要看下面的部分了。。。
ADO库包含三个基本接口:_ConnectionPtr接口、_CommandPtr接口和_RecordsetPtr接口。 _ConnectionPtr接口返回一个记录集或一个空指针。 通常使用它来创建一个数据连接或执行一条不返回任何结果的SQL语句，如一个存储过程。 使用_ConnectionPtr接口返回一个记录集不是一个好的使用方法。（所以通常是用_RecordsetPtr 得到一个记录集） 通常同Cdatabase一样，使用它创建一个数据连接，然后使用其它对象执行数据输入输出操作。 _CommandPtr接口返回一个记录集。 它提供了一种简单的方法来执行返回记录集的存储过程和SQL语句。 在使用_CommandPtr接口时，你可以利用全局_ConnectionPtr接口，也可以在_CommandPtr接口里直接使用连接串。 如果你只执行一次或几次数据访问操作，后者是比较好的选择。 但如果你要频繁访问数据库，并要返回很多记录集，那么，你应该使用全局_ConnectionPtr接口创建一个数据连接， 然后使用_CommandPtr接口执行存储过程和SQL语句。 _RecordsetPtr是一个记录集对象。 与以上两种对象相比，它对记录集提供了更多的控制功能，如记录锁定，游标控制等。
同_CommandPtr接口一样，它不一定要使用一个已经创建的数据连接， 可以用一个连接串代替连接指针赋给_RecordsetPtr的connection成员变量，让它自己创建数据连接。 如果你要使用多个记录集，最好的方法是同Command对象一样使用已经创建了数据连接的全局_ConnectionPtr接口 ，然后使用_RecordsetPtr执行存储过程和SQL语句。 基本流程 (1)初始化COM库，引入ADO库定义文件 (2)用Connection对象连接数据库 (3)利用建立好的连接，通过Connection、Command对象执行SQL命令，或利用Recordset对象取得结果记 录集进行查询、处理。 (4)使用完毕后关闭连接释放对象。
***************************************************************************************************************************
连接数据库的方法除以上一种之外，还有下面的方法：
常用的数据库连接方法： (1)通过JET数据库引擎对ACCESS2000数据库的连接 m_pConnection-&gt;Open("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=C:\\test.mdb","","",adModeUnknown); (2)通过DSN数据源对任何支持ODBC的数据库进行连接: m_pConnection-&gt;Open("Data Source=adotest;UID=sa;PWD=;","","",adModeUnknown); //m_pConnection-&gt;Open("DSN=test;","","",0); //连接叫作test的ODBC数据源 (3)不通过DSN对SQL SERVER数据库进行连接： m_pConnection-&gt;Open("driver={SQL Server};Server=127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8be965154f0cc609270928362a48a12a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ff838045828beb1c49abbf3829188db/" rel="bookmark">
			.net英文笔试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Introduction Seems that I am going to provide instructions regarding how to face technical interviews on .NET. I am sorry but this is not the content of this article series. I have worked a lot on preparing technical questions asked during interviews for various development positions. In this series of articles I am going to explain some of questions asked frequently during technical interviews, in the beginning (In this and subsequent article) we will go through core technical stuff and after that I will explain some of the tricky and confusing concepts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ff838045828beb1c49abbf3829188db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9600d2953c7c85fe6133c347d381884/" rel="bookmark">
			常用到的一些SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select TIMESTAMPADD(SQL_TSI_DAY, -30, @{V_date}{date'2013-12-05'}) FROM "A1 Bc Analysis" where "D00 Day More"."Date2" = @{V_yesterday}{date'2013-12-05'} select TIMESTAMPADD(SQL_TSI_DAY, -30, @{V_date}{date'2013-12-05'}) FROM "A1 Bc Analysis" SELECT TIMESTAMPADD(SQL_TSI_DAY, -30, "D00 Day"."Date") FROM "A1 Bc Analysis" where "D00 Day More"."Date2" = @{V_date}{date'2013-12-10'} (case when '@{V_peroid}{onemonth}'='onemonth' then TIMESTAMPADD(SQL_TSI_DAY, -30, @{V_date}{date'2013-12-01'}) when '@{V_peroid}{onemonth}'='twomonth' then TIMESTAMPADD(SQL_TSI_DAY, -60, @{V_date}{date'2013-12-01'}) else TIMESTAMPADD(SQL_TSI_DAY, -10, @{V_date} {date'2013-12-01'}) end) "D00 Day"."Date" &lt; @{V_date}{date'2013-12-01'} and "D00 Day"."Date" &gt; TIMESTAMPADD(SQL_TSI_DAY, -30, @{V_date}{date'2013-12-01'}) SELECT TIMESTAMPADD(SQL_TSI_DAY, -30, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9600d2953c7c85fe6133c347d381884/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f262a26ab297741d014b17de73bd9b53/" rel="bookmark">
			SQLServer附加数据库失败（5120）的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）出现的问题如下图所示，错误码5120，拒绝访问：
（2）解决方法：在MDF和LDF上右键属性安全--将完全控制权限赋予Authenticated USers，再回到数据库附加即可成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bf7a76f8912179d104e9f97606e3467/" rel="bookmark">
			gstreamer 学习笔记 -- 音视频播放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		研究了一天，终于把怎么用gstreamer播放ts流弄清楚了。
首先上个图：
此图描述了如何将数据从源流向音视频设备。
首先数据从source流出，经过demuxer将音视频流解出来，然后音视频分别经过解码元件解出原始数据，最后在音视频设备上输出。
我所用的环境是在raspberry pi上，具有omx硬件解码接口。播放的视频文件为ts格式，视频编码为H.264, 音频编码为AAC。
这个是播放的命令：
gst-launch-1.0 filesrc location=/app/BIOHAZARD2.ts !tsdemux name=demux demux.video_0012 !queue !h264parse !omxh264dec !glimagesink demux.audio_0011 !queue !faad !alsasink
命令解释：
filesrc：此为源文件 location属性指定其文件位置
tsdemux: 此为ts解码元件，可以将ts流中的音视频解复用出来。name指定名称，用于之后的音视频引用。demux.video_0012 为视频流的标记，其中0012为视频PID的16进制表达。demux.audio_0011 为音频流，同理0011为音频PID的16进制表达。
omxh264dec ： 为264的解码元件，这里支持芯片的硬解码。
glimagesink：为opengl的video输出设备。
faad： 为AAC解码元件。
alsasink：为alsa的音频输出设备。
由于本人也是刚学gstreamer，本着分享的精神写了本文，文中难免会出现错误之处，欢迎大家指正。
注：其中插图是在网上收集所得，非原创。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b6f7c17daccd2c49bd120ef3cb4aa1f/" rel="bookmark">
			ctrl-shift-esc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 折腾了好久。。。 远程登录后，启动远程机器的进程管理器 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07eb237e844c57e057893306f0c32818/" rel="bookmark">
			JVM日志和参数的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一:理解GC日志格式,读GC日志的方法 1:开启日志 -verbose:gc
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-Xloggc:/path/gc.log
-XX:+PrintGC包含-verbose:gc
-XX:+PrintGCDetails //包含-XX:+PrintGC
只要设置-XX:+PrintGCDetails 就会自动带上-verbose:gc和-XX:+PrintGC
-XX:+PrintGCDateStamps/-XX:+PrintGCTimeStamps 输出gc的触发时间
提示:gc日志文件不会分割需要手动处理.
2:新生代(Young GC)gc日志分析 1 2 3 2014 - 02 - 28T11 : 59 : 00.638 + 0800 : 766.537 : [ GC2014 - 02 - 28T11 : 59 : 00.638 + 0800 : 766.537 : [ ParNew : 1770882K -&gt; 212916K ( 1835008K ) , 0.0834220 secs ] 5240418K -&gt; 3814487K ( 24903680K ) , 0.0837310 secs ] [ Times : user = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07eb237e844c57e057893306f0c32818/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3601cd3e10e36449bbd9a7be48630e2/" rel="bookmark">
			java中的隐式参数与显式参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法用于操作对象以及存取它们的实例域。例如，方法： 将调用这个方法的对象的salary实例域设置为新值。看看下面这个调用:
它的结果将number007.salary域的值增加5%。具体地说，这个调用将执行下列指令： 已经看到，显式参数是明显地列在方法声明中的显示参数，例如double byPercent。隐式参数没有出现在方法声明中。raiseSalary方法有两个参数。第一个参数被称为隐式（implicit）参数，是出现在方法名前的Employee类对象。第二个参数位于方法名后面括号中的数值，这是一个显式（explicit）参数。
在每一个方法中，关键字this表示隐式参数。如果需要的话，可以用下列方式编写raiseSalary方法： 有些程序员更偏爱这样的风格，因为这样可以将实例域与局部变量明显地区分开来。 C++注释：在C++中，通常在类的外面定义方法： 如果在类的内部定义方法，这个方法将自动地成为内联（inline）方法。 在Java程序设计语言中，所有的方法都必须在类的内部定义，但并不表示它们是内联方法。是否将某个方法设置为内联方法是Java虚拟机的任务。即时编译器会监视调用那些简洁、经常被调用、没有被重载以及可优化的方法。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa5277a6918ec13dbe6bbb9e59cefc75/" rel="bookmark">
			群、环、域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习Jerasure，对其中涉及到的一些算法中涉及到的数学概念梳理如下。
群
简而言之，群的概念可以理解为：一个集合以及定义在这个集合上的二元运算，满足群的四条公理，封闭性、结合性、单位元、反元素。具体理解为：
封闭性：在集合上作任意二元运算，不会诞生新的运算，这个集合已经经过充分的完美拓扑。
结合性：组合一个二元操作链，之间没有先后运算的区别，这种操作是平坦的（区别交换律）。
单位元：具有单位的属性，单位元和任何一个元素操作等于那个元素本身。
反元素：集合中任何一个元素，存在一个称为反元素的元素与那个元素进行操作后，最后的结果为单位元。
可交换群
简而言之，可交换群就是在满足群的”四公理“的基础上在加上一个可交换的属性，可把满足可交换的操作满足对称性。
环
简而言之，环是细化的群，一个环中涉及两个二元运算，分别是(R,+)与(R, ·)，前者是个可交换群，后者是一个半群。半群可理解为仅仅满足封闭性以及结合律的群，则忽略了单位元与反元素的限制。似乎可以想象，如果一个群为以单元为中点的对称分布，则半群为群的单位元劈开的两瓣之一，所以称之为半群。
域
域的概念较为复杂，环的概念仅仅定义了两个运算，唯一的条件是，乘法关于加法满足可分配律。而进入到域的概念，则对这两个二元操作，强加了更多的限制。上面第一种定义很有趣，进入了除环的概念。在除环的基础上，额外加了一个可交换的限制条件。
伽罗瓦域
从域过度到伽罗瓦域较为简单，仅仅额外的加了一个限制：有限个元素。
从群到环，再到域，是一个条件逐渐收敛的过程，条件的收敛，也带来对更小数学集合上更丰富的特性。
细化到伽罗瓦域，这些更丰富的特性，为后来EC码的诞生奠定了数学基础，具有工程上的可实现性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b5000366867c2cb7f69fcd3a3c3f4cb/" rel="bookmark">
			Java 加密 AES 对称加密算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【AES】
一种对称加密算法，DES的取代者。
加密相关文章见：Java 加密解密 对称加密算法 非对称加密算法 MD5 BASE64 AES RSA 【代码】
代码比较多，有一部分非本文章内容代码，具体自己看吧。
package com.uikoo9.util.encrypt; import java.math.BigInteger; import java.security.MessageDigest; import java.security.SecureRandom; import javax.crypto.Cipher; import javax.crypto.KeyGenerator; import javax.crypto.spec.SecretKeySpec; import sun.misc.BASE64Decoder; import sun.misc.BASE64Encoder; import com.uikoo9.util.QStringUtil; /** * 编码工具类 * 1.将byte[]转为各种进制的字符串 * 2.base 64 encode * 3.base 64 decode * 4.获取byte[]的md5值 * 5.获取字符串md5值 * 6.结合base64实现md5加密 * 7.AES加密 * 8.AES加密为base 64 code * 9.AES解密 * 10.将base 64 code AES解密 * @author uikoo9 * @version 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b5000366867c2cb7f69fcd3a3c3f4cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91a7995f1fd4763d4e041fbc41de6387/" rel="bookmark">
			虚拟机VMware安装XP详细图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以上即为GHOSTXP安装全攻略 安装版大同小异 不做赘述，其实觉得还是安装版系统较GHOST更稳定，Ghost系统的优势主要在于快速便捷。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c851f256c862ad65e1013b4e9abee682/" rel="bookmark">
			删除DriverStore\FileRepository文件夹后，设备驱动无法安装，提示“没有为设备信息集或元素选择驱动程序（代码 28）”的解决办法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
我前几天手贱，整个FileRepository删除掉了，之后重启就出现了让人蛋疼的这个问题，因为出于各种原因不想重装系统，百度轮番换搜索词无果，虽然驱动装上了但新设备依然无法自动安装驱动等“一堆瑕疵”，重启无数次折腾3天之后才在百度一个帖子的一个字眼里发现了解决办法（说此方法的人自己说删了INFCACHE.1后也无效，所以没有引起注意），也因此有了这个随笔：
1、首先你要恢复FileRepository文件夹，至于方法嘛，可以下载完整的WIN7系统镜像后提取出来，如果是原版则用GImageX或WinMount等工具提取install.wim，ghost文件则用 ghost explorer；
2、进PE维护系统或一切你能用的办法，比如什么文件粉碎机啦，打飞机啦，删除System32\DriverStore（也就是FileRepository的父目录）下的 INFCACHE.1 drvindex.dat infpub.dat infstor.dat infstrng.dat 5个文件，重启解决。
3、万一以上办法对你无效，那你只能用我上面说到的先把驱动装上，瑕疵不管它了，你自己再慢慢琢磨要怎么搞，不然像我连键盘都用不了，实在是很痛苦很痛苦的：
打开设备管理器-&gt;对应设备右键-&gt;更新驱动程序软件-&gt;浏览计算机以查找驱动程序-&gt;将“在以下位置搜索驱动程序软件”的位置指定到%windir%\winsxs-&gt;下一步
再说下自己得出的废话经验：
删除后会出现此问题的，都是INF文件中没有直接写着对应设备硬件ID的那些驱动安装程序，比如USB鼠标、键盘等这些太杂的东西，我的realtek PCI-E网卡驱动也是，查看INF文件后都是没有我的硬件ID的，而以前却依然安装得上。我不知道微软使用的是什么方法来判断这个设备需要用到的是这个驱动。但反正问题就是这种判断方式出现了问题，导致了驱动安装不上。
PS：删除INFCACHE.1这个文件后，已安装驱动程序的签名数据会丢失，设备管理器看到的非microsoft的驱动程序都是未经数字签名。
转载于:https://www.cnblogs.com/guanyouan/p/3762653.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac743ac0780b688f1ae9369bd7a21f2c/" rel="bookmark">
			国密算法(SM2，SM3，SM4)辅助工具升级版(OTP&#43;PBOC3.0)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从编写最初版本用于验算SM2，SM3和SM4算法的辅助工具已有一年多的时间了，国密算法的应用和普及也是不温不火的。编写最初算法代码和工具时所参考的文档还非正式的国密标准文件，而目前国密标准文件发布了几个系列了，为国密算法应用提供了有力的参考和帮助，特别人行发布了PBOC3.0标准，其增强部分的国密算法应用部分，为国密算法在金融领域应用打下标准基础，也为厂商和开发提供了有力的帮助和指导。
国密局同时也发布了使用国密SM3和SM4算法的OTP算法标准，并首推在金融领域应用，笔者有幸参与了某股份制银行使用国密OTP算法的应用工作，最初参考标准为讨论稿，使用的算法为SM1和SM3算法，与最新的国家标准区别为把SM1改为SM4，但应用和算法上区别不大，在笔者同各厂家（其中包括国家标准的编制厂商）交流和合作过程中，对其他标准部分体会还不深，但至少对OTP标准这部分体会颇多，发布的标准和数据说明相当的不够严谨，数据与算法描述完全不同，最新公布的正式版OTP部分也是如此（算法说明与数据样例不一致），还需要开发者自己去鉴别和理解，还希望以国家身份的标准制定和审定要谨慎啊。
PBOC3.0标准重点描述了SM4、SM3和SM2算法应用，对称部分应用描述的比较完善可以参考进行工程开发，而SM2证书部分只说明了发卡行和IC部分，而根CA部分的就没有涉及，这一点上同PBOC2.0相同，要进行系统开发还需要找到CA部分标准，目前还没有正式规范发布。SM2的IC证书与RSA的证书最大区别在于RSA对数据进行了私钥加密，之后用公钥解密，而SM2对数据使用私钥签名，数据为明文，使用时对数据进行验证，这点在证书应用上是不同，同时SM2证书的数据量要少，私钥不需要CRT，公钥也没有余项。
笔者编写的升级版的工具增加了功能为4项，1.OTP算法（SM3和SM4应用，用于动态口令生成），2.PBOC（对称算法SM4，MAC计算、数据加密解密、ARQC和ARPC、子密钥离散），3.SM2根CA部分（使用SM2算法，签发CA根证书、验证根证书、验证发卡行证书输入和签发发卡行证书），4.SM2发卡行证书（生成发卡行证书输入文件，签发IC证书和验证IC证书），需要说明的是，PBOC3.0的SM2证书部分实现为参考国密算法IC根CA证书方案的草案完成，与最终的正式版可能会有所出入。
新增算法工具界面如下：
1. OTP算法功能界面
2.PBOC对称算法功能界面
3.SM2根CA证书功能界面
4.SM2发卡行证书功能界面
如果有相关测试数据的朋友，可提供一些数据，用于验证工具功能正确性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/540a89271e31fe6947406991ef46635e/" rel="bookmark">
			VB.NET操作Word大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VB.NET操作Word之1，在project\references 中加入microsoft word 11.0 object library （2003）
一、启动打开Word文档
&lt;div style="text-align: left;"&gt;&lt;span style="background-color: rgb(248, 248, 248); font-family: 宋体; "&gt;	Dim oWord As Word.Application&lt;/span&gt;&lt;/div&gt;&lt;div style="text-align: left;"&gt;&lt;span style="background-color: rgb(248, 248, 248); font-family: 宋体; "&gt; Dim oDoc As Word.Document&lt;/span&gt;&lt;/div&gt;&lt;div style="text-align: left;"&gt;&lt;span style="background-color: rgb(248, 248, 248); font-family: 宋体; "&gt; oWord = New Word.Application&lt;/span&gt;&lt;/div&gt;&lt;div style="text-align: left;"&gt;&lt;span style="background-color: rgb(248, 248, 248); font-family: 宋体; "&gt; oWord.Visible = False&lt;/span&gt;&lt;/div&gt;&lt;div style="text-align: left;"&gt;&lt;span style="background-color: rgb(248, 248, 248); font-family: 宋体; "&gt;&lt;span style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/540a89271e31fe6947406991ef46635e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a08a0f69f8233110a35de81b863f687/" rel="bookmark">
			ORACLE 用户、Profile 及权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户管理
一、创建用户：创建的新用户是没有任何权限的，甚至连登陆的数据库的权限都没有，需要为其指定相应的权限。
SQL&gt; Create User username
Identified by password
Default Tablespace tablespace
Temporary Tablespace tablespace
Profile profile
Quota integer/unlimited on tablespace;
例:
SQL&gt; Create user acc01
identified by acc01　// 如果密码是数字，请用双引号括起来
default tablespace account
temporary tablespace temp
profile default
quota 50m on account;
SQL&gt; grant connect, resource to acc01;
[*] 查询用户缺省表空间、临时表空间
SQL&gt; select username, default_tablespace, temporary_tablespace from dba_users;
[*] 查询系统资源文件名：
SQL&gt; select * from dba_profiles;
资源文件类似表，一旦创建就会保存在数据库中。
SQL&gt; select username, profile, default_tablespace, temporary_tablespace from dba_users;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a08a0f69f8233110a35de81b863f687/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa8b6392fa2c2d541c5dd85eec8b85b4/" rel="bookmark">
			SeaJS简介三：模块载入和引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前对模块有过介绍，一个模块对应一个js文件，而载入模块时一般都是提供一个字符串参数告诉载入函数需要的模块，所以就需要有一套从字符串标识到实际模块所在文件路径的解析算法。
SeaJS支持如下几种方式：
第一种：绝对路径--给出js文件的绝对路径
require("http://example/js/a"); 第二种：相对路径--用相对调用载入函数所在js文件的相对地址寻找模块
require("./c"); 第三种：通过全局变量来匹配相对路径：相对SeaJS全局配置中的“base”来寻址（后面文章会介绍到）
SeaJS提供了三种载入的方式：seajs.use，require和require.async
第一种：seajs.use
seajs.use主要用于载入入口模块。入口模块相当于JAVA程序的main函数，同时也是整个模块依赖树的根。
这种方式有几种写法：
//单一模式 seajs.use('./a'); //回调模式 seajs.use('./a', function(a) { a.run(); }); //多模块模式 seajs.use(['./a', './b'], function(a, b) { a.run(); b.run(); }); 一般seajs.use只用在页面载入入口模块，SeaJS会顺着入口模块解析所有依赖模块并将它们加载。如果入口模块只有一个，也可以通过给引入sea.js的script标签加入”data-main”属性来省略seajs.use。
来个小实例来说明一下：
&lt;!DOCTYPE HTML&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;TinyApp&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class="content"&gt;&lt;/p&gt; &lt;script src="./sea.js" data-main="./init"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 第二种：require
require是SeaJS主要的模块加载方法，当在一个模块中需要用到其它模块时一般用require加载：ar a = require('a'); //引入a模块
第三种：require.async
之前的require方式是一次把所有依赖的JS文件都加载进来，如果想什么时候用到什么时候加载的话就会用这种方式，这种方式效率比require高一些。
通过上面的介绍，应该对SeaJS的模块载入和引用有所了解了，其实者通过这几篇的介绍会发现SeaJS的模块化编程思想和它带给开发人员的简单易用的特点。下篇博客介绍一下SeaJS的全局配置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4787296d57689343f5217992fc2182fd/" rel="bookmark">
			各种符号用英文怎么读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：
http://blog.renren.com/share/100183696/12730245804
http://www.mecil9.com/archives/38.aspx
http://blog.sina.com.cn/s/blog_444821ac0100ijtg.html
我们每天都看见或敲击这些符号，但不见得当老外或老师用英语说出这些符号时我们能立即反应过来，这正是促成此文的原因。
1. ~ 波浪号tilde，源于西班牙语和葡语中的发音符号。
2. ! 感叹号exclamation mark/exclamation point/bang，无需多解释，在这个 “咆哮体”盛行的时代，想不懂这个都难。
3. # 汉语中因形似“井”，通常读作井号，真正的含义是数字符号(Number sign)，如在一些国家‘#1’代表No.1的意思。在美式英语中一般称作pound sign，电话上的“#”叫做pound key，而加拿大英语则称之为number sign key；北美以外的其他英语国家一般称“#”为hash，相应的电话键叫做hash key。注意：数字符号（#）极易和乐谱中的升音符（♯ 读作sharp）相混淆。但是，乐谱的sharp和数字符号的字形不完全一样。标准数字符号(#)横线水平，而竖线向右倾斜；而乐谱的升号（♯）为了在五线谱中容易识别，横线改为斜向上但竖线垂直。我猜此时有人就会举出一个极好的反例来否定上述说法，那就是C#（C Sharp）。的确，乍一看确实不相符！但事实上，C#并不违背上述结论，C Sharp中符号Sharp的创意正是来源于升音符♯在乐谱中的含义——紧跟其后的音符的音高比实际标定的高半音，表示技术进一步提升之意（要不直接把C#本土化，翻译成“C优”算了^_^，这个命名方法有点类似于C++中“++”表示变量增1）。由于“♯”在计算机显示、输入中不方便，因此在书写体中用“#”代替“♯”，但读音保持不变。于是就出现了书写成“C#”但念作“C Sharp”的情形，了解渊源之后发现其实并不矛盾。
4. $ dollar/peso sign，我们通常把这个当作美元（USD）的符号，但拉丁美洲一些国家的人们会认为“$” 代表比索（peso），所以，不引起误解，最好用“US$”代表美元。这个符号的起源还存在争议，其中有一种说法是这样的：在18世纪末，货币单位比索的手写缩写符号是“ps”，随着时间推移，p和s感情渐进、关系日益密切，最后重叠在一起形成了现在的“$”。
5. % 百分号，percent sign。
6. ^ a读caret，表示间距符 “^ ”或 “‸”，也称作wedge, up-arrow, hat，数学中通常叫做hat；b读circumflex (^)，是发音符号，常见用法如Â。
7. &amp; ampersand/and，单词“and”的简写形式。
8. * asterisk/star，计算机和数学中称作“star”更常见。
9. () round brackets/open brackets; [ ] square brackets/closed brackets; { } curly brackets/definite brackets; &lt; &gt; angle brackets/triangular brackets，除了用作尖括号，也用作不等号，小于号&lt;（less-than），大于号&gt;（greater-than）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4787296d57689343f5217992fc2182fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f09173ed174870a855e8f4a25c13ff39/" rel="bookmark">
			Sysbench-Mongodb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sysbench-Mongodb与sysbench mysql类似，可用于做压力测试
作者介绍：http://www.tokutek.com/2013/03/sysbench-benchmark-for-mongodb/
安装及运行步骤如下：
1、下载解压 https://github.com/tmcallaghan/sysbench-mongodb
wget https://codeload.github.com/tmcallaghan/sysbench-mongodb/zip/master -O sysbench-mongodb-master.zip
unzip sysbench-mongodb-master.zip
2、运行需要jdk，安装JDK 1.7 下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html
wget --no-cookies \
--no-check-certificate \
--header "Cookie: oraclelicense=accept-securebackup-cookie" \
"http://download.oracle.com/otn-pub/java/jdk/7u55-b13/jdk-7u55-linux-x64.rpm" \
-O jdk-7u55-linux-x64.rpm
#chmod +x jdk-7u 5 5-linux-x64.rpm
#rpm -ivh jdk-7u 5 5-linux-x64.rpm
安装完毕，配置环境变量，编辑/etc/profile文件，在文件中找到export PATH USER LOGNAME 等内容，添加以下内容： JAVA_HOME=/usr/java/jdk1.7.0_45
JRE_HOME=/usr/java/jdk1.7.0_45/jre
PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL JAVA_HOME JRE_HOME CLASSPATH
保存退出，执行: #source /etc/profile
3、 下载mongo-java-driver 驱动包
wget http://central.maven.org/maven2/org/mongodb/mongo-java-driver/2.11.4/mongo-java-driver-2.11.4.jar
配置环境变量：
export CLASSPATH=$PWD/mongo-java-driver-2.11.4.jar:$CLASSPATH
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f09173ed174870a855e8f4a25c13ff39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aead1175294b9c625629a7dca8bee2c8/" rel="bookmark">
			JSP简单隔行变色和日期格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前好像在找，都没找到简单点的，所以后面就自己写了一个，感觉超级简单又好理解，分享给大家
&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt; &lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt; &lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;html&gt; &lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;My JSP 'index.jsp' starting page&lt;/title&gt; &lt;style type="text/css"&gt; .odd{ background-color: #f2f2f2; } .even{ background-color: #dddddd; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;c:forEach items="${books }" var="book" varStatus="st"&gt; &lt;tr class="${st.index%2==0?'even':'odd' }"&gt; &lt;td&gt;${book.bname }&lt;/td&gt; &lt;td&gt;${book.bauthor }&lt;/td&gt; &lt;td&gt; &lt;fmt:formatDate value="${book.btime }" pattern="yyyy-MM-dd"/&gt; &lt;/td&gt; &lt;tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 如果只做隔行变色只需要：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aead1175294b9c625629a7dca8bee2c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfdc3221c81531ab0ebcb3bf20704dc2/" rel="bookmark">
			修改开源项目源码方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将要修改的源码拷贝一下，然后在项目src下新建包（包名和要修改的类的包名一样），在包下新建一个类（和要修改的类名一样），粘帖源码的代码修改。项目会优先加载src下的类；
举个例子：修改hadoop 源码下的FileUtil类：
package org.apache.hadoop.fs; public class FileUtil { ........................ } 在项目下src目录下新建一个包。：org.apache.hadoop.fs 在包下新建一个类：FileUtil；
修改FileUtil；项目会优先使用这个类；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e977b6c89dbbe7572fc14ce4950b3a15/" rel="bookmark">
			【redis源码分析】内存分配---zmalloc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* zmalloc - total amount of allocated memory aware version of malloc() * * Copyright (c) 2009-2010, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt; * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are met: * * * Redistributions of source code must retain the above copyright notice, * this list of conditions and the following disclaimer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e977b6c89dbbe7572fc14ce4950b3a15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a472c6c716d2b8080cafb9fe26f58f69/" rel="bookmark">
			To &#34;windows mobile 5.0 pocket pc device&#34; connection failed 这个产品的配置数据已损坏,请与技术支持人员联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己是win7系统，VS2005英文版。
在windows mobile 6.5(wince 5.0 内核)上用VS2005联机调试程序，弹出如下错误：
To "windows mobile 5.0 pocket pc device" connection failed 这个产品的配置数据已损坏。请与技术支持人员联.
网上搜罗一番，发现解决方法如下：
找到如下目录：C:\Users\Administrator\AppData\Local\Microsoft\CoreCon，里面有一个1.0目录，全部删除后重启VS2005即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62b256d4be92da2bed455ad08e9758bd/" rel="bookmark">
			Horizon学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Horizon吊炸天！之前，一直认为horizon只不过是一个面板，没啥好研究的，而且我对django又不是很熟，一直懒的看horizon，今晚硬着头皮看了下去，没想到，越看越有劲，眼睛差点跟不上我的思路了！我觉得horizon牛不在对django的运用，而是对事物高度的抽象能力:D
程序的入口点在horizon/openstack_dashboard/urls.py中：
url(r'', include(horizon.urls)) 然后由Horizon这个单例的Site对象，开始加载urls，自动发现并注册dashboard，然后对每一个dashboard，再自动发现并注册panel:
Horizon._lazy_url 程序的入口看起来那么平常不过，进入之后发现这大千世界，让人惊叹不已!!!
可以在horizon/base/_urls()方法中，一窥全貌：
``` def _urls(self): """Constructs the URLconf for Horizon from registered Dashboards.""" urlpatterns = self._get_default_urlpatterns() self._autodiscover() # 自动发现并注册dashboard，其实就是从INSTALL_APPS中加载dashboard # Discover each dashboard's panels. for dash in self._registry.values(): dash._autodiscover() # 自动发现并注册panel，这个是根据路径来发现的 # Allow for override modules if self._conf.get("customization_module", None): customization_module = self._conf["customization_module"] bits = customization_module.split('.') mod_name = bits.pop() package = '.'.join(bits) mod = import_module(package) try: before_import_registry = copy.copy(self._registry) import_module('%s.%s' % (package, mod_name)) except Exception: self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62b256d4be92da2bed455ad08e9758bd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/474/">«</a>
	<span class="pagination__item pagination__item--current">475/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/476/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>