<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05aee4e511f29e97f4a01bbb634f8b33/" rel="bookmark">
			GO-基本语法2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		八.类型别名 类型别名是 Go 1.9 版本添加的新功能，主要用于解决代码升级、迁移中存在的类型兼容性问题。在 C/C++ 语言中，代码重构升级可以使用宏快速定义一段新的代码，Go语言中没有选择加入宏，而是解决了重构中最麻烦的类型名变更问题。
在 Go 1.9 版本之前定义内建类型的代码是这样写的：
type byte uint8 type rune int32 而在 Go 1.9 版本之后变为：
type byte = uint8 type rune = int32 这个修改就是配合类型别名而进行的修改。
区分类型别名与类型定义 定义类型别名的写法为：
type TypeAlias = Type 类型别名规定：TypeAlias 只是 Type 的别名，本质上 TypeAlias 与 Type 是同一个类型，就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。
类型别名与类型定义表面上看只有一个等号的差异，那么它们之间实际的区别有哪些呢？下面通过一段代码来理解。
package main import ( "fmt" ) // 将NewInt定义为int类型 type NewInt int // 将int取一个别名叫IntAlias type IntAlias = int func main() { // 将a声明为NewInt类型 var a NewInt // 查看a的类型名 fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05aee4e511f29e97f4a01bbb634f8b33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8cce554381dd66c1936ea6aad994099/" rel="bookmark">
			神通数据库字段空与非空
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神通数据库可以在建表时指定字段非空或可空，
-- 指定column1字段非空 CREATE TABLE SYSDBA.tmp_test1(column1 varchar(100) NOT NULL) --尝试向column1字段插入空值 INSERT INTO SYSDBA.tmp_test1(column1) VALUES(NULL) 会收到插入失败的提示：
而如果建表时不添加NOT NULL关键字，那么空值是可以被插入到：
-- 指定column1字段可以为空 CREATE TABLE SYSDBA.tmp_test2(column1 varchar(100)) --尝试向column1字段插入空值 INSERT INTO SYSDBA.tmp_test2(column1) VALUES(NULL) 空值被成功插入
那么对于已有的表，如何实现字段非空和可为空之间的修改转换呢？
1. 将非空字段修改为可为空
ALTER TABLE SYSDBA.tmp_test1 MODIFY column1 varchar(200) NULL 2.将可为空字段修改为非空
ALTER TABLE SYSDBA.tmp_test1 MODIFY column1 varchar(200) NOT NULL 注意如果修改前，被修改字段中有null值那么会报错
SQL 错误 [40000]: ERROR, 属性信息出错, ALTER TABLE: Attribute "COLUMN1" contains NULL values
此时需要先将null值替换掉，比如替换为字符串类型的'NULL'
UPDATE SYSDBA.tmp_test1 SET column1='NULL' WHERE column1 IS null 替换完所有null值后，再次执行命令，即可完成转换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8cce554381dd66c1936ea6aad994099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/591db3759a975f755539e9fe8bd31988/" rel="bookmark">
			Python读取txt文件中文内容乱码解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python读取txt文件中文内容乱码解决 python读取txt文件时默认使用的时GBK编码格式，所以在文件中如果有中文，就会出现乱码，如下图
解决方法如下
在打开文件时指定编码方式为UTF-8
open('./Config.txt', "r", encoding='UTF-8') 重新执行python脚本，打印如下
中文正常打印
end
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3263caa50d9ca165862bcaa12aebd8c/" rel="bookmark">
			esp32 bug记录：重复定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FAILED: project-name.elf cmd.exe /C "cd . &amp;&amp; D:\Espressif\tools\xtensa-esp32-elf\esp-12.2.0_20230208\xtensa-esp32-elf\bin\xtensa-esp32-elf-g++.exe -mlongcalls -Wno-frame-address -Wl,--cref -Wl,--defsym=IDF_TARGET_ESP32=0 -Wl,--Map=C:/Users/Administrator/Desktop/project-name/build/project-name.map -Wl,--no-warn-rwx-segments -fno-rtti -fno-lto -Wl,--gc-sections -Wl,--warn-common -T esp32.peripherals.ld -T esp32.rom.ld -T esp32.rom.api.ld -T esp32.rom.libgcc.ld -T esp32.rom.newlib-data.ld -T esp32.rom.syscalls.ld -T esp32.rom.newlib-funcs.ld -T memory.ld -T sections.ld @CMakeFiles\project-name.elf.rsp -o project-name.elf &amp;&amp; cd ." d:/espressif/tools/xtensa-esp32-elf/esp-12.2.0_20230208/xtensa-esp32-elf/bin/../lib/gcc/xtensa-esp32-elf/12.2.0/../../../../xtensa-esp32-elf/bin/ld.exe: esp-idf/peripheral/libperipheral.a(wifi_dis.c.obj):C:/Users/Administrator/Desktop/project-name/components/peripheral/include/wifi_dis.h:39: multiple definition of `wifi_connect_flag'; esp-idf/main/libmain.a(real_time_stats_example_main.c.obj):C:/Users/Administrator/Desktop/project-name/components/peripheral/include/wifi_dis.h:39: first defined here d:/espressif/tools/xtensa-esp32-elf/esp-12.2.0_20230208/xtensa-esp32-elf/bin/../lib/gcc/xtensa-esp32-elf/12.2.0/../../../../xtensa-esp32-elf/bin/ld.exe: esp-idf/peripheral/libperipheral.a(wifi_dis.c.obj):C:/Users/Administrator/Desktop/project-name/components/peripheral/include/wifi_dis.h:36: multiple definition of `wifi_sta_data'; esp-idf/main/libmain.a(real_time_stats_example_main.c.obj):C:/Users/Administrator/Desktop/project-name/components/peripheral/include/wifi_dis.h:36: first defined here collect2.exe: error: ld returned 1 exit status ninja: build stopped: subcommand failed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3263caa50d9ca165862bcaa12aebd8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/596b1e21efbfb0df749439976f58ef27/" rel="bookmark">
			同义词替换在降低论文抄袭率中的具体应用与成效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，今天来聊聊同义词替换在降低论文抄袭率中的具体应用与成效，希望能给大家提供一点参考。
以下是针对论文重复率高的情况，提供一些修改建议和技巧，可以借助此类工具：
标题：同义词替换在降低论文抄袭率中的具体应用与成效
一、引言
在学术研究中，论文的抄袭率是评价论文质量和学术道德的重要指标。为了降低论文的抄袭率，同义词替换成为一种常用的方法。本文将探讨论文降重同义词替换在降低论文抄袭率中的具体应用，并探讨其成效。
二、同义词替换在降低论文抄袭率中的具体应用
替换重复词汇 在论文降重过程中，同义词替换可以有效地替换掉重复的词汇，避免被查重系统识别为抄袭。通过使用同义词替换软件，如小发猫伪原创、小狗伪原创等，可以快速、准确地完成替换操作，降低论文的重复率。
增加表达方式多样性 同义词替换可以增加表达方式多样性，使论文的内容更加丰富多样。通过使用不同的词汇和表达方式，可以避免被查重系统识别为抄袭，提高论文的原创性和可读性。
保持语义和风格一致 同义词替换需要保持原文的语义和风格一致。在使用同义词替换软件时，需要注意选择与原文语境相符的词汇进行替换，保持原文的语义和风格。这样可以避免被查重系统识别为抄袭，提高论文的质量和可信度。
三、同义词替换在降低论文抄袭率中的成效
降低查重率 通过同义词替换，可以有效地降低论文的查重率。查重系统通常基于文本匹配算法进行检测，同义词替换可以避免文本重复，从而降低查重率。这对于提高论文的原创性和避免学术不端行为具有重要意义。
提高论文质量 同义词替换可以增加表达方式多样性，使论文的内容更加丰富多样。同时，保持原文的语义和风格一致，可以提高论文的质量和可信度。这对于提高论文的整体水平和学术价值具有重要意义。
增强学术道德意识 同义词替换是一种积极的学术道德行为。通过使用同义词替换软件，可以避免直接抄袭他人的研究成果，增强学术道德意识。这对于维护学术界的声誉和推动学术研究的健康发展具有重要意义。
四、结论与展望
同义词替换在降低论文抄袭率中具有显著成效。通过替换重复词汇、增加表达方式多样性以及保持语义和风格一致等具体应用，可以有效地降低查重率、提高论文质量和增强学术道德意识。未来随着技术的不断进步和研究的深入发展，我们期待看到更加智能化、个性化的同义词替换工具为学术界提供更加优质、高效的服务。同时，也希望研究者能够结合自己的研究领域和需求选择合适的工具进行使用，提高论文降重的效率和准确性。
同义词替换在降低论文抄袭率中的具体应用与成效相关文章：
从58%到5%‼️一键修改文案
从53%到9%‼️excel计算重复次数
从69%到7%‼️wps的论文降重怎么样
从59%到10%‼️论文表格如何避免重复率
从73%到7%‼️如何修改硕士毕业论文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd5e436104ddcb06f5c53b3789d7bc96/" rel="bookmark">
			css自制icon图标（最简单的一种方式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 近期在系统开发过程中，想在文件上传框下方增加一个公告类的图标，使用的是 element-ui组件库，去官网查了一下发现并没有 el-icon-notice 类型的公告图标（但是在 vant 与 vux 等移动端组件库中是有的），于是想着使用 css 来实现自制 icon 图标，其实自定义 icon 图标方式有好几种，但是笔者只使用了一种较为简单的方式，亲测有效，现分享给同行开发者们。
官网icon总览（未找到公告icon）​​​ 实现方式 步骤1： 从网上下载自己喜欢的图标或者自制一个 logo 图标，将其放于项目的 /static/images 目录下（根据自己的需求放，也可以放在 assets 目录下，笔者是放在 /static/images 目录下），如下是我自己从网上下载的喇叭图标，图片命名为 notice.jpg：
步骤2： 在 vue 页面中添加如下 html 代码 （el-icon-notice 就是我们自定义的一个图标名称）：
&lt;div class="el-upload__tip" slot="tip"&gt; &lt;i class="el-icon-notice"&gt;&lt;/i&gt; Only file of Excel type permits and the size of this file can not exceed 10Mb &lt;/div&gt; 步骤3： 在 vue 页面中继续添加如下的 css 代码：
.el-icon-notice { content: url('/static/images/notice.jpg'); //图标内容 height: 20px; //图标的高度 width: 25px; //图标的宽度 margin-right: 10px; //图标与后面文字的距离 vertical-align: -5px; //图标的纵向位置，目的是为了保持与提示文字 位于同一行 } 效果图： 完整代码： &lt;template&gt; &lt;el-dialog :visible.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd5e436104ddcb06f5c53b3789d7bc96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c592e6e807f9df1d02faabd0379e534/" rel="bookmark">
			Android解决报错 superclass access check failed: class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android解决报错 superclass access check failed: class 前言： 最近在打开之前的项目demo时，出现一个错误Cause: superclass access check failed: class butterknife.compiler.ButterKnifeProcessor$RScanner
1.错误信息如下： Execution failed for task ':app:compileDebugJavaWithJavac'. &gt; superclass access check failed: class butterknife.compiler.ButterKnifeProcessor$RScanner (in unnamed module @0x7f7bb073) cannot access class com.sun.tools.javac.tree.TreeScanner (in module jdk.compiler) because module jdk.compiler does not export com.sun.tools.javac.tree to unnamed module @0x7f7bb073 * Try: &gt; Run with --info or --debug option to get more log output. &gt; Run with --scan to get full insights.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c592e6e807f9df1d02faabd0379e534/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3d8cc882b31561dcef15dc6dc7b9e0c/" rel="bookmark">
			并发相关参数指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		指标 1、TPS和QPS 一、TPS：Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。（业务TPS = CAPS × 每个呼叫平均TPS）
TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。
一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的TPS值。
Tps即每秒处理事务数，包括了
1）用户请求服务器
2）服务器自己的内部处理
3）服务器返回给用户
这三个过程，每秒能够完成N个这三个过程，Tps也就是N；
二、QPS：每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。
对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。
Qps基本类似于Tps，但是不同的是，对于一个页面的一次访问，形成一个Tps；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“Qps”之中。
例如：访问一个页面会请求服务器3次，一次放，产生一个“T”，产生3个“Q”
2、RT（Res（onse Time） 概念：响应实际，就是从客户端请求发起到服务器响应结果的时间。RT这个参数是系统最重要的指标之一，它的大小直接反应了当前系统的响应状态。基本和咱们用户体验息息相关，现在好一点监控系统一般都有三个RT，即平均、最大、最小。
一般系统RT 100ms 以内是比较正常的，300ms 勉强可以接受，1s的话再加上一些其他的外因，给用户的体验就是实实在在的不爽了。
3、并发数 概念：系统能同时处理的请求的数量，很多人经常会把并发数和TPS理解混淆。举例，请求一个index.html 页面，客户端发起了三个请求（css、js、index接口）,那么此时TPS =1 、QPS =3 、并发数 3。
SO，计算公式 ：QPS=并发数/RT || 并发数=QPS*RT
4、吞吐量（Throughput） 一个系统的吞度量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。单个reqeust 对CPU消耗越高，外部系统接口、IO影响速度越慢，系统吞吐能力越低，反之越高。
系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间
QPS（TPS）：每秒钟request/事务 数量
并发数： 系统同时处理的request/事务数
响应时间： 一般取平均响应时间
理解了上面三个要素的意义之后，就能推算出它们之间的关系：
QPS（TPS）= 并发数/平均响应时间 或者 并发数 = QPS*平均响应时间
5、PV（Page View） 概念：即每个页面的浏览次数，用户每次刷新就算一次。
6、UV（UniqueVisitor） 概念：独立访客数，每天访问的用户数，此数据需要根据用户唯一标识进行去重。
7、Load（系统负载） 概念：此数据指的是Linux系统的负载情况，也就是咱们平时所用Top命令时，最上面显示的数据信息( load average: 0.1, 0.2, 0.5)。此时会显示1分钟、5分钟、15分钟的系统平均Load，很显然load average 的值越低，你的系统负荷越小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3d8cc882b31561dcef15dc6dc7b9e0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b0e08d712535afd41aab59145d24918/" rel="bookmark">
			【漏洞复现】 Milesight Router httpd.log 信息泄漏(CVE-2023-4714)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 漏洞描述 Milesight Router 存在信息泄漏漏洞，攻击者通过访问httpd.log可以获取登陆敏感日志信息。
免责声明 技术文章仅供参考，任何个人和组织使用网络应当遵守宪法法律，遵守公共秩序，尊重社会公德，不得利用网络从事危害国家安全、荣誉和利益，未经授权请勿利用文章中的技术资料对任何计算机系统进行入侵操作。利用此文所提供的信息而造成的直接或间接后果和损失，均由使用者本人负责。本文所提供的工具仅用于学习，禁止用于其他！！
漏洞集合 【传送点】上千漏洞复现复现集合 exp poc 持续更新
资产确定 FOFA "rt_title" 漏洞复现 1.利用如下POC进行GET访问得到回显
/lang/log/httpd.log 修复方案 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cbea29690bb7e3649947ef1b8512bf7/" rel="bookmark">
			计算机毕设ssm高考志愿填报推荐系统s1a649 独有（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
JSP + mybatis + Maven +mysql5.7或8.0等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 4G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目
6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末) 3.1 需求分析
在对一个软件进行设计与开发之前，需要对该系统进行深层次的调查、分析、研究[6]。良好的需求分析不仅能使开发人员快速、准确地理解开发任务，还能提高开发效率，能好地完成工作。对系统进行需求分析是必不可少的，这是软件生存周期上一个很重要的部分，在这个阶段需要确定该系统需要实现什么功能，然后做成一个数据规范、图表清晰的文档，为接下来的系统设计工作提供一定的基础。
3.1.1系统总体分析
本系统采取了一系列的设计原则，主要目的是为了系统的功能设计，还有管理人员在后期对系统维护时的方便，以及使用户能够简易的操作。最重要的设计原则包括：简单性、针对性、实用性、一致性、先进性[7]。
（1）简单性：在该系统中功能模块实现的同时，让用户操作起来简单明了，很快找到所需资源是最直接的目的。
（2）针对性：该系统是根据设计需求为导向来开发高考志愿填报推荐系统的设计，所以针对性较强。
（3）实用性：该设计能够满足高考志愿填报推荐系统的实际的功能需求，能够在实际中让用户真正使用到，具有实际的应用价值[8]。
（4）一致性：网站整体的页面布局，在不同的界面之间，img里的图片的放置位置以及大小都应该有严格的一致性。变量命名规则应该具有统一性。
（5）先进性：本系统采用java作为开发语言、SSM框架、MySQL作为系统数据库，它们被软件设计者们广泛使用[9]。
3.2 可行性分析 可行性分析是每开发一个项目必不可少的一部分，可行性分析可以直接影响一个系统的存活问题，针对开发意义进行分析，该高考志愿填报推荐系统的开发设计中，以下几点进行了可行性分析：经济、技术、运行可行性：通过java的采用，由于该技术不断成熟，所以使用该技术设计高考志愿填报推荐系统是具有可行性的。经济可行性：在开发过程中，系统完成后的利益是否大过于开发成本。操作可行性：高考志愿填报推荐系统的开发设计中，方便用户的可操作性和实用性[10]。
3.2.1 经济可行性 由于本系统是作为毕业设计系统，且系统本身存在一些技术层面的缺陷，并不能直接用于商业用途，只想要通过该系统的开发提高自身学术水平，不需要特定服务器等额外花费。所有创造及工作过程仅需在个人电脑上就能实现，使用到的软件大多为开源软件，所以经济成本并不高，可以轻易实现[11]。
3.2.2 技术可行性 本系统的开发使用java作为系统开发的开发语言，开发工具选择 Eclipse，而 B/S架构决定了本系统的兼容性和多用户可操作性，此外选择MySql作为数据库不仅提高了数据安全性更保障了数据的可操作性[12]。
3.2.3 运行可行性 本系统作为以java作为开发技术的系统，而且选用 B/S架构则决定了要操作本系统仅需要占用很小的资源，并没有过多地硬件配置要求，目前市面上只要能正常运行浏览器的个人电脑都可以正常运行使用该系统。
综上所述，本系统的设计与开发在经济上、技术上、运行上的条件都是满足的，因此，系统开发具备可行性条件[13]。
3.3　系统结构和流程设计 开发该系统主要选用了SSM的架构设计，将主要表现层、业务逻辑层和数据访问层分离出来。表现层将请求的回应信息展现在java网页页面上便于客户访问，业务逻辑层负责获得并正确处理请求逻辑，确保SQL语句读取时取得成功或失败，数据访问层关键将数据信息拼写成SQL语句。由于分层次构造开展开发，可以使开发系统软件的耦合性减少，实际操作的方法简洁明了，使体系能更快的运作。
操作流程需要进行设计，一个完整的系统可以流畅的操作下来是至关重要的，本系统的完整操作流程如图3-1所示：
系统操作流程图 本系统主要有管理员和用户二种角色，进行登录时需要确保输入的内容与已经保存的账号信息一致，通过账户密码等方式来校验用户信息，输入正确则登入系统，输入错误则登入失败。系统登录流程，如图3-2所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cbea29690bb7e3649947ef1b8512bf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2941e65d4e46aa6bced89078d9b84470/" rel="bookmark">
			如何封装个video插件。自定义进度条点击拖拽，播放暂停，播放倍速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：vue3开发嵌入式，播放器在浏览器中是正常的。但嵌入到app里，app不适配，无法全屏，无法设置倍速，controls在视频播放时点击视频无法弹出。
1.是不是播放器问题导致不适配？ 期间试了vue-video-play，vue3-video-play等视频插件，也是相同情况
2.网上没找到相关问题，自己搞吧 代码效果 注意 1.使用了vant图标，先安装vant
2.视频链接，需要自己填
3.引入的useDraggable，就是封装的拖拽js
4.只适合移动端，因为到移动端有些问题，做了样式调整。动作事件也是移动端的
5.template中class类名不要乱改，封装的拖拽js代码里有获取
template代码 &lt;template&gt;
&lt;div class="all_box"&gt;
&lt;div class="videoBox"&gt;
&lt;video ref="videoPlayer"
src=""&gt;&lt;/video&gt;
&lt;/div&gt;
&lt;div class="controlsBox"&gt;
&lt;div class="progress-box" @click="onProgress($event)" ref="progressBox"&gt;
&lt;div class="progress" :style="{ width: `${progressLength}px` }"&gt;&lt;/div&gt;
&lt;div ref="draggableDiv" class="it-layout-aside" :style="{ left: `${progressLength}px` }"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="playBtn" @click="clickPlay()"&gt;
&lt;van-icon name="pause-circle-o" size="30" v-if="showPlay" /&gt;
&lt;van-icon name="play-circle-o" size="30" v-else /&gt;
&lt;/div&gt;
&lt;div class="progress-time"&gt;{{ timeString }}&lt;/div&gt;
&lt;div class="selRate"&gt;
&lt;select class="selRate_selet" v-model="selRate" @change="onSelRate()"&gt;
&lt;option value=0.5&gt;0.5&lt;/option&gt;
&lt;option value=1 selected&gt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2941e65d4e46aa6bced89078d9b84470/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/253929a127feeb256a01891e61e28947/" rel="bookmark">
			Zabbix实现简单的ICMP ping探活监测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、建主机 数据采集－－主机－－新建主机：填入主机名称和组名，点添加
2、建监控项 选中主机，点监控项，右上角[创建监控项]，类型选择 [简单检查]，键值选择第一个icmpping[&lt;target&gt;,&lt;packets&gt;,&lt;interval&gt;,&lt;size&gt;,&lt;timeout&gt;]，这里我们把中括号里的一串改成我们要监测的IP地址，点添加
3、建触发器 这里再点[触发器]，点右上角[创建触发器]，这里的名称就是告警内容，直接写中文，如XX不通；在表达式里，点后边的[添加]，选择刚才我们建的监控项，点添加；最后点[应用]，点上面的主机，回到主机，点更新
这时一个主机就建好了，可以在监控里看到了，也可以在拓朴图里，在对应的位置，选择我们刚才建的主机，就能直观地看到它的位置啦！
tips： 在数据采集 --&gt; 主机 中，填入宏{$HOST}，填入IP地址，可以直接在拓朴图上进行ping、tracert等操作，直接看到结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccabbe1a39d4c317bf38e30f630a36ec/" rel="bookmark">
			Vue Router 利用全局后置守卫封装一个loadingBar组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue Router 利用全局后置守卫封装一个loadingBar组件 loadingBar.vue
&lt;template&gt; &lt;div class="wraps"&gt; &lt;div ref="bar" class="bar"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup lang='ts'&gt; import { ref, onMounted } from 'vue' let speed = ref&lt;number&gt;(1) let bar = ref&lt;HTMLElement&gt;() let timer = ref&lt;number&gt;(0) const startLoading = () =&gt; { let dom = bar.value as HTMLElement; speed.value = 1 timer.value = window.requestAnimationFrame(function fn() { if (speed.value &lt; 90) { speed.value += 1; dom.style.width = speed.value + '%' timer.value = window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccabbe1a39d4c317bf38e30f630a36ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dfcf80684bc9213581f10b794046655/" rel="bookmark">
			HTML如何引入vue自定义组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、新建一个js文件，创建子组件，例：test-component.js
Vue.component('test-component', { template: ` &lt;div v-if="isshow"&gt;{{userno}} - {{username}}&lt;/div&gt; `, props: ['isshow'], // html接收字段名都是小写，单向传递 data() { return { username: '', // 组件内部属性 userno: '', } }, watch: { // 传值发生改变触发事件 isshow: { handler(newVal, oldVal) { console.log('isshow旧值:' + oldVal); console.log('isshow新值:' + newVal); // 根据值的改变，写相应逻辑代码 this.getInfo(); } }, }, methods: { // 组件内方法 getInfo(){ } } }) 2、新建html文件，创建父组件
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;!-- 引入VUE文件 --&gt; &lt;script src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dfcf80684bc9213581f10b794046655/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/256c25455970c52ebcf471d2cffe9c5a/" rel="bookmark">
			Security onion 开源IDS入侵检测系统 2.3.220超详细保姆级部署教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Security Onion是一个免费和开放的Linux发行版，用于威胁搜索、企业安全监控和日志管理。
易于使用的设置向导允许你在几分钟内为你的企业建立一支分布式传感器部队
Security Onion包括一个原生的网络界面，其内置的工具可供分析师用于响应警报、威胁狩猎、将证据编入案例、监控网格性能等
一、准备服务器环境，当前环境： 1.Centos7.9 32G 8C 300G 两块网卡
2.准备docker镜像加速工具，执行安装拉取镜像不加速会失败，开启加速工具后需要将主机名、127.0.0.1、localhost，排除在外不然会导致无法写入es容器数据，导致容器启动失败。
二、开始安装，首先配置加速器 1.开启加速器，我这里使用的是如下工具，其他需要各位自己解决，进入加速器目录，配置好config.json文件，启动docker镜像加速器。 2.查看加速器端口，配置本地加速环境变量，私网地址和本机主机名无需加速 [root@220-220 v2ray]# netstat -lntup tcp 0 0 127.0.0.1:10808 0.0.0.0:* LISTEN 4426/ tcp 0 0 127.0.0.1:10809 0.0.0.0:* LISTEN 4426/ [root@220-220 v2ray]# vim /etc/profile 79 no_proxy_192=$(echo 192.168.220.{1..255}|sed 's/ /,/g') #不加速的地址，必须包括本地地址，根据自己要求修改 80 export no_proxy="220-220,${no_proxy_192}" #不加速生效，包括220-220主机名和以上私网地址 81 export https_proxy=127.0.0.1:10809 #https通过本地10809加速 82 export http_proxy=127.0.0.1:10809 #https通过本地10809加速 3.git拉取项目 [root@220-220 ~]# git clone https://github.com/Security-Onion-Solutions/securityonion 4.安装security onion [root@220-220 v2ray]# cd /root/securityonion/ [root@220-220 securityonion]# .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/256c25455970c52ebcf471d2cffe9c5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a87f02b5bfa7a8c406c9fd6a9941d9d7/" rel="bookmark">
			git命令使用记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. $git branch 显示所有本地分支(初始化时只有一个master分支) $git init 初始化本地版本库(重新初始化一次，可以忽略)
$ls -a 找到目录下隐藏的 .git
$rm -rf .git 删除 .git(就会清除当前的git仓库, 可以再次执行 git clone...)
$ ls -a 可以看到master分支已经删除
2.
$git branch -a 列出所有分支名(查看所有分支)
$git checkout master 分支切换到 master $git checkout 检查属于哪个分支
$git checkout voxbranch_01 切换到指定分支voxbranch_01
3. $git checkout -b dev origin/dev checkout远程的dev分支，在本地起名为dev分支，并切换到本地的dev分支
$git checkout -b release origin/release 作用参见上一条说明
$git checkout dev 切换回dev分支，并开始开发
4.
$git branch devlyl 在当前分支下,新建一个名为devlyl的分支
$git push origin devlyl 将本地新建的分支(分支名为:devlyl)同步到远程服务器上，这样别人也能看到
$git checkout devlyl
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a87f02b5bfa7a8c406c9fd6a9941d9d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e68438b234af93ca969e3f6478a07f28/" rel="bookmark">
			项目中使用临时文件夹或获取文件资源路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于项目中使用临时文件夹的情况 1. 如果想要获取resource目录下的某个文件夹路径：
ResourceUtils.getURL("classpath:").getPath() + "/xxx"
注意：
1.1 不能直接使用ResourceUtils.getURL("classpath:xxx").getPath()，这种会报错
1.2 如果resource目录下的那个文件夹是一个空文件夹，那么上linux后，无法在其中创建文件，因为打包的时候会忽略空文件夹，即target下不会有对应的文件夹，此时如果想在代码中实时创建这个文件夹又会没有权限
解决方式：在那个临时文件夹下再放个临时文件，这样打包的时候也会自动创建临时文件夹
如果想要获取resource目录下的某个文件 ResourceUtils.getURL("classpath:xxx.txt").getPath() 注意：
hutool的FileUtil.getTmpDir()方法，在linux上获取的临时文件夹路径不正确，谨慎使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e28a073bb8fc5b6f15e9fbaa2f9f2cd/" rel="bookmark">
			从零开始搭建企业管理系统（八）：Spring Data Jpa 代码生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Data Jpa 代码生成器 前言导入依赖编写自定义代码模板controller.java.ftlentity.java.ftlrepository.java.ftlservice.java.ftlserviceImpl.java.ftlCodeGenerator 启动测试问题修改 前言 本来是想接着写权限的CRUD的，但是能偷点懒就偷点懒吧，就想先写一个代码生成器来生成一下代码，就免得写一些重复的基本的CRUD操作了。
我之前写过一篇 MyBatis Plus 代码生成器的使用文档，MyBatis-Plus 代码生成器，这个就是使用 MyBatis Plus 的时候能用的上的代码生成，但是我们的项目是一个 Spring Data Jpa 的项目，所以就想着二次开发一下，自己定义模板来生产Jpa的代码，OK，开始上代码。
导入依赖 &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring boot 依赖管理 2.3.32 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;/dependency&gt; 编写自定义代码模板 controller.java.ftl package ${package.Controller}; import ${package.Entity}.${entity}; import ${package.Service}.${table.serviceName}; import io.swagger.v3.oas.annotations.Operation; import io.swagger.v3.oas.annotations.tags.Tag; import jakarta.annotation.Resource; import org.springframework.data.domain.Page; import org.springframework.data.domain.PageRequest; import org.springframework.web.bind.annotation.*; import java.util.List; /** * ${table.comment!} 控制类 * * @author ${author} * @date ${date} */ @Tag(name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e28a073bb8fc5b6f15e9fbaa2f9f2cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20bc2ef648bebf9d491136dd49155b21/" rel="bookmark">
			从零开始搭建企业管理系统（七）：RBAC 之用户管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RBAC 之用户管理 创建表（Entity）用户表角色表权限表用户角色表关系注解@ManyToMany 角色权限表 接口开发UserControllerUserServiceUserServiceImplUserRepository 问题解决update 更新问题懒加载问题JSON 循环依赖问题 根据上一小结对表的设计，我们开始编写代码实现权限管理模块的代码。
我们直接通过编写实体映射类，让JPA自动帮我们生成一下数据库表。
创建表（Entity） 首先通过 JPA 将需要用到的5张表都建好。
先将基础实体类修改一下
@Data @MappedSuperclass @EntityListeners(AuditingEntityListener.class) @Schema(description = "基础实体") public class BaseEntity { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Schema(description = "用户ID") private Long id; @Column(columnDefinition = "tinyint(1) NOT NULL COMMENT '状态'") @Schema(description = "状态") private Integer status; @Column(columnDefinition = "bit NOT NULL COMMENT '0正常，1删除'") @Schema(description = "逻辑删除") private Boolean isDelete; @CreatedBy @Column(updatable = false, columnDefinition = "varchar(32) COMMENT '创建用户'"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20bc2ef648bebf9d491136dd49155b21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f58bc8a00d0721a53bbca122ca185e2/" rel="bookmark">
			根据 csv文件 快速生成自定义 mysql 语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义模板sql: （2个参数的） update user u set u.name = '#{a}' where u.id ='#{b}' ; 建立csv文件数据如下：data.csv （2个参数的） 效果: 生成的result.sql文件 update user u set u.name = '张三01' where u.id ='1' ; update user u set u.name = '张三12' where u.id ='2' ; update user u set u.name = '张三23' where u.id ='3' ; update user u set u.name = '张三34' where u.id ='4' ; update user u set u.name = '张三45' where u.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f58bc8a00d0721a53bbca122ca185e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d4d9943db45c1369074f259a3516243/" rel="bookmark">
			Docker笔记：Docker Swarm 结合 Docker Compose 来部署集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker swarm 结合 docker-compose.yml 部署集群 1 ）准备 docker-compose.yml的文件, 示例 demo 如下
version: "3" services: mysql_c: image: mysql environment: MYSQL_ROOT_PASSWORD: 123456 restart: always ports: - 3306:3306 volumes: - /root/mysql/conf.d:/etc/mysql/conf.d - /root/mysql/data:/var/lib/mysql goweb1: image: gowebimg restart: always deploy: replicas: 6 # 副本数量 resources: # 资源 limits: # 配置cpu cpus: "0.3" # 设置该容器最多只能使用 30% 的 CPU memory: 500M # 设置该容器最多只能使用 500M内存 restart_policy: # 定义容器重启策略, 用于代替 restart 参数 condition: on-failure # 只有当容器内部应用程序出现问题才会重启 depends_on: - mysql_c nginx: image: nginx restart: always ports: - 80:80 depends_on: - goweb1 volumes: - /root/nginx/conf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d4d9943db45c1369074f259a3516243/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba73e10d19fb58f354c1b160b933a1b2/" rel="bookmark">
			基于Docker-Compose实现ELK&#43;Kafka搭建分布式日志采集系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ELK+Kafka搭建日志采集系统 ELK概述搭建与配置docker-compose.yml配置日志采集规则启动服务 模拟发送日志消息日志发送队列日志切面配置application.yaml发送日志消息 Kibana的使用创建索引模式Discovery搜索数据可视化数据 ELK+RabbitMQ发送日志消息配置日志采集规则 ELK概述 ELK是指Elasticsearch、Logstash和Kibana这三个主要的开源软件工具，它们通常一起被用于实时日志分析和数据可视化。另外，在日志采集系统中，ELK通常结合Kafkka一起使用。
1、Elasticsearch
Elasticsearch是一个开源的分布式搜索和分析引擎，基于Lucene库构建。它设计用于处理大规模数据集，能够快速地进行全文搜索、结构化搜索、分析和实时数据处理。Elasticsearch具有高可扩展性和高可靠性，可以自动处理数据的分片和复制，支持分布式搜索和聚合操作。
2.Logstash：
Logstash是一个开源的数据收集和处理引擎，用于将各种类型的数据（如日志、事件、度量等）从多个来源采集、处理和传输到Elasticsearch或其他存储和分析工具。Logstash支持多种数据输入源和输出目的地，可以进行数据转换、标准化、过滤和增强，使数据具备一致性和结构性。
3.Kibana：
Kibana是一个开源的数据可视化平台，用于在Elasticsearch上创建和共享实时的数据可视化仪表盘。它提供了丰富的图表、表格、地图和仪表盘等可视化组件，使用户能够以直观的方式探索和分析数据。Kibana还支持交互式查询和过滤，能够快速演示和共享数据的见解。
4.Kafka
Kafka是数据缓冲队列。作为消息队列解耦了处理过程，同时提高了可扩展性。具有峰值处理能力，使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。
搭建与配置 使用Docker Compose实现ELK（Elasticsearch、Logstash、Kibana）和Kafka日志采集
docker-compose.yml 创建docker-compose.yml文件，使用以下服务：
ZooKeeper：用于Kafka的依赖服务，监听在2181端口 Kafka：用于消息队列和日志采集，监听在9092端口，并连接到ZooKeeper Elasticsearch：用于存储和索引日志数据，监听在9200端口 Logstash：用于从Kafka接收日志数据并转发到Elasticsearch Kibana：用于可视化和检索日志数据，监听在5601端口，并连接到Elasticsearch vim docker-compose.yml
version: '3.7' services: zookeeper: image: zookeeper:3.8 container_name: zookeeper ports: - "2181:2181" environment: - ALLOW_ANONYMOUS_LOGIN=yes restart: always kafka: image: bitnami/kafka:3.3.2 container_name: kafka1 hostname: kafka volumes: - ./kafka_data:/bitnami/kafka # 赋予kafka_data目前权限：chmod 777 kafka_data ports: - "9092:9092" depends_on: - zookeeper environment: KAFKA_CFG_ZOOKEEPER_CONNECT: zookeeper:2181 #kafka链接的zookeeper地址 KAFKA_ENABLE_KRAFT: no # 是否使用kraft，默认值：是,即Kafka替代Zookeeper KAFKA_CFG_LISTENERS: PLAINTEXT://:9092 # 定义kafka服务端socket监听端口,默认值：PLAINTEXT://:9092,CONTROLLER://:9093 KAFKA_CFG_ADVERTISED_LISTENERS: PLAINTEXT://192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba73e10d19fb58f354c1b160b933a1b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/035e5e49a5041ad677b8de97f73e0813/" rel="bookmark">
			青龙面板仓库合集（不断更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要什么库或有好的推荐，可以评论反馈，可搜集进来
青龙面板 支持 Python3、JavaScript、Shell、Typescript 的定时任务管理平台
跑各种自动任务很方便
去部署&gt;&gt;&gt;&gt;传送门
毛库 阿里云盘签到
项目地址：传送门
什么值得买签到+任务
项目地址 ：传送门
GLaDOS签到
项目地址：传送门
bilibili任务和抽奖
项目地址：传送门
饿了么、美团、滴滴
项目地址：传送门
某东 撸豆的，几个用过的库，集合库（包含开卡）拉1个就行，有农场，种豆等活动自动做，太多了自己发掘吧。
开卡是指店铺会员卡，邀请其他人加入店铺会员得豆的活动，开多了会有许多骚扰电话或短信，
天天喊让人上车的就是为了做他工具人助力各活动（俗称韭菜）。
jdpro（集合库） 项目地址：传送门
点评：更新勤，无重复，内部互助，有原创，比较纯净默认不会购物车不会加购乱七八糟的商品，入门推荐，博主目前在用的。
ql repo https://github.com/6dylan6/jdpro.git "jd_|jx_|jddj_" "backUp" "^jd[^_]|USER|JD|function|sendNotify" KR（集合库） 7月份被石锤上传用户CK，随之关库，两周后又开库，mark。
项目地址：x
点评：更新勤，无重复，内部互助，有原创。
Faker3（集合库） 项目地址：传送门
点评：只搬运，比原创更新慢些，第一感觉就是太杂了，重复和失效的比较多，可自己禁用失效的，不能用还一直请求API不太好，默认会加购商品也不知道哪个，搞的我购物车很乱。
ql repo https://github.com/shufflewzc/faker3.git "jd_|jx_|gua_|jddj_|jdCookie" "activity|backUp" "^jd[^_]|USER|function|utils|sendNotify|ZooFaker_Necklace.js|JDJRValidator_|sign_graphics_validate|ql|JDSignValidator|magic|depend|h5sts" "main" Faker2（集合库） 项目地址：传送门
点评：和faker3一样，只不过农场和种豆是助力池版，就是和别人共享助力(农场、种豆)，号少的也可能满助力，拼运气了，有时陪跑。
ql repo https://github.com/shufflewzc/faker2.git "jd_|jx_|gua_|jddj_|jdCookie" "activity|backUp" "^jd[^_]|USER|function|utils|sendNotify|ZooFaker_Necklace.js|JDJRValidator_|sign_graphics_validate|ql|JDSignValidator|magic|depend|h5sts" "main" smiek2121（开卡库） 项目地址：传送门
点评：纯开卡（店铺会员卡）库，有原创，无开卡活动不更新，有更新需及时跑，晚了就等补水吧，集合库也会有开卡，拉集合库了不用再单独拉开卡库。
ql repo https://github.com/smiek2121/scripts.git "jd_|gua_" "" "ZooFaker_Necklace.js|JDJRValidator_Pure.js|sign_graphics_validate.js|cleancart_activity.js|jdCookie.js|sendNotify.js" 使用秘籍 添加单个脚本文件
ql raw &lt;file_url&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/035e5e49a5041ad677b8de97f73e0813/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d01038ffa2cdb88dd3ecec0b21e197f/" rel="bookmark">
			RGB颜色大全（HEX、对照表、Matplotlib、plt、好看的颜色）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 颜色展示英文代码形象颜色HEX格式RGB格式▇▇▇▇▇▇▇▇LightPink浅粉红#FFB6C1255,182,193▇▇▇▇▇▇▇▇Pink粉红#FFC0CB255,192,203▇▇▇▇▇▇▇▇Crimson猩红#DC143C220,20,60▇▇▇▇▇▇▇▇LavenderBlush脸红的淡紫色#FF0F5255,240,245▇▇▇▇▇▇▇▇PaleVioletRed苍白的紫罗兰红色#DB7093219,112,147▇▇▇▇▇▇▇▇HotPink热情的粉红#FF69B4255,105,180▇▇▇▇▇▇▇▇DeepPink深粉色#FF1493255,20,147▇▇▇▇▇▇▇▇MediumVioletRed适中的紫罗兰红色#C71585199,21,133▇▇▇▇▇▇▇▇Orchid兰花的紫色#DA70D6218,112,214▇▇▇▇▇▇▇▇Thistle蓟#D8BFD8216,191,216▇▇▇▇▇▇▇▇Plum李子#DDA0DD221,160,221▇▇▇▇▇▇▇▇Violet紫罗兰#EE82EE238,130,238▇▇▇▇▇▇▇▇Magenta洋红#FF00FF255,0,255▇▇▇▇▇▇▇▇Fuchsia灯笼海棠(紫红色)#FF00FF255,0,255▇▇▇▇▇▇▇▇DarkMagenta深洋红色#8B008B139,0,139▇▇▇▇▇▇▇▇Purple紫色#800080128,0,128▇▇▇▇▇▇▇▇MediumOrchid适中的兰花紫#BA55D3186,85,211▇▇▇▇▇▇▇▇DarkViolet深紫罗兰色#9400D3148,0,211▇▇▇▇▇▇▇▇DarkOrchid深兰花紫#9932CC153,50,204▇▇▇▇▇▇▇▇Indigo靛青#4B008275,0,130▇▇▇▇▇▇▇▇BlueViolet深紫罗兰的蓝色#8A2BE2138,43,226▇▇▇▇▇▇▇▇MediumPurple适中的紫色#9370DB147,112,219▇▇▇▇▇▇▇▇MediumSlateBlue适中的板岩暗蓝灰色#7B68EE123,104,238▇▇▇▇▇▇▇▇SlateBlue板岩暗蓝灰色#6A5ACD106,90,205▇▇▇▇▇▇▇▇DarkSlateBlue深板岩暗蓝灰色#483D8B72,61,139▇▇▇▇▇▇▇▇Lavender薰衣草花的淡紫色#E6E6FA230,230,250▇▇▇▇▇▇▇▇GhostWhite幽灵的白色#F8F8FF248,248,255▇▇▇▇▇▇▇▇Blue纯蓝#0000FF0,0,255▇▇▇▇▇▇▇▇IndigoBlue靛蓝#0000FF0,0,255▇▇▇▇▇▇▇▇MediumBlue适中的蓝色#0000CD0,0,205▇▇▇▇▇▇▇▇MidnightBlue午夜的蓝色#19197025,25,112▇▇▇▇▇▇▇▇DarkBlue深蓝色#00008B0,0,139▇▇▇▇▇▇▇▇Navy海军蓝,深靛蓝#0000800,0,128▇▇▇▇▇▇▇▇RoyalBlue皇家蓝#4169E165,105,225▇▇▇▇▇▇▇▇CornflowerBlue矢车菊的蓝色#6495ED100,149,237▇▇▇▇▇▇▇▇LightSteelBlue淡钢蓝#B0C4DE176,196,222▇▇▇▇▇▇▇▇LightSlateGray浅石板灰#778899119,136,153▇▇▇▇▇▇▇▇SlateGray石板灰#708090112,128,144▇▇▇▇▇▇▇▇DodgerBlue道奇蓝#1E90FF30,144,255▇▇▇▇▇▇▇▇AliceBlue爱丽丝蓝#F0F8FF240,248,255▇▇▇▇▇▇▇▇SteelBlue钢蓝#4682B470,130,180▇▇▇▇▇▇▇▇LightSkyBlue淡蓝色#87CEFA135,206,250▇▇▇▇▇▇▇▇SkyBlue天蓝色#87CEEB135,206,235▇▇▇▇▇▇▇▇DeepSkyBlue深天蓝#00BFFF0,191,255▇▇▇▇▇▇▇▇LightBlue淡蓝#ADD8E6173,216,230▇▇▇▇▇▇▇▇PowderBlue火药蓝#B0E0E6176,224,230▇▇▇▇▇▇▇▇CadetBlue军校蓝#5F9EA095,158,160▇▇▇▇▇▇▇▇Azure蔚蓝色#F0FFFF240,255,255▇▇▇▇▇▇▇▇LightCyan淡青色#E1FFFF225,255,255▇▇▇▇▇▇▇▇PaleTurquoise苍白的绿宝石#AFEEEE175,238,238▇▇▇▇▇▇▇▇Cyan青色#00FFFF0,255,255▇▇▇▇▇▇▇▇Aqua水绿色#00FFFF0,255,255▇▇▇▇▇▇▇▇DarkTurquoise深绿宝石#00CED10,206,209▇▇▇▇▇▇▇▇DarkSlateGray深石板灰#2F4F4F47,79,79▇▇▇▇▇▇▇▇DarkCyan深青色#008B8B0,139,139▇▇▇▇▇▇▇▇Teal水鸭色#0080800,128,128▇▇▇▇▇▇▇▇MediumTurquoise适中的绿宝石#48D1CC72,209,204▇▇▇▇▇▇▇▇LightSeaGreen浅海洋绿#20B2AA32,178,170▇▇▇▇▇▇▇▇Turquoise绿宝石#40E0D064,224,208▇▇▇▇▇▇▇▇Auqamarin绿玉/碧绿色#7FFFAA127,255,170▇▇▇▇▇▇▇▇MediumAquamarine适中的碧绿色#00FA9A0,250,154▇▇▇▇▇▇▇▇MediumSpringGreen适中的春天的绿色#00FF7F0,255,127▇▇▇▇▇▇▇▇MintCream薄荷奶油#F5FFFA245,255,250▇▇▇▇▇▇▇▇SpringGreen春天的绿色#3CB37160,179,113▇▇▇▇▇▇▇▇SeaGreen海洋绿#2E8B5746,139,87▇▇▇▇▇▇▇▇Honeydew蜂蜜#F0FFF0240,255,240▇▇▇▇▇▇▇▇LightGreen淡绿色#90EE90144,238,144▇▇▇▇▇▇▇▇PaleGreen苍白的绿色#98FB98152,251,152▇▇▇▇▇▇▇▇DarkSeaGreen深海洋绿#8FBC8F143,188,143▇▇▇▇▇▇▇▇LimeGreen酸橙绿#32CD3250,205,50▇▇▇▇▇▇▇▇Lime酸橙色#00FF000,255,0▇▇▇▇▇▇▇▇ForestGreen森林绿#228B2234,139,34▇▇▇▇▇▇▇▇Green纯绿#0080000,128,0▇▇▇▇▇▇▇▇DarkGreen深绿色#0064000,100,0▇▇▇▇▇▇▇▇Chartreuse查特酒绿#7FFF00127,255,0▇▇▇▇▇▇▇▇LawnGreen草坪绿#7CFC00124,252,0▇▇▇▇▇▇▇▇GreenYellow绿黄色#ADFF2F173,255,47▇▇▇▇▇▇▇▇OliveDrab橄榄土褐色#556B2F85,107,47▇▇▇▇▇▇▇▇Beige米色(浅褐色)#F5F5DC245,245,220▇▇▇▇▇▇▇▇LightGoldenrodYellow浅秋麒麟黄#FAFAD2250,250,210▇▇▇▇▇▇▇▇Ivory象牙#FFFFF0255,255,240▇▇▇▇▇▇▇▇LightYellow浅黄色#FFFFE0255,255,224▇▇▇▇▇▇▇▇Yellow纯黄#FFFF00255,255,0▇▇▇▇▇▇▇▇Olive橄榄#808000128,128,0▇▇▇▇▇▇▇▇DarkKhaki深卡其布#BDB76B189,183,107▇▇▇▇▇▇▇▇LemonChiffon柠檬薄纱#FFFACD255,250,205▇▇▇▇▇▇▇▇PaleGodenrod灰秋麒麟#EEE8AA238,232,170▇▇▇▇▇▇▇▇Khaki卡其布#F0E68C240,230,140▇▇▇▇▇▇▇▇Gold金#FFD700255,215,0▇▇▇▇▇▇▇▇Cornislk玉米色#FFF8DC255,248,220▇▇▇▇▇▇▇▇GoldEnrod秋麒麟#DAA520218,165,32▇▇▇▇▇▇▇▇FloralWhite花的白色#FFFAF0255,250,240▇▇▇▇▇▇▇▇OldLace老饰带#FDF5E6253,245,230▇▇▇▇▇▇▇▇Wheat小麦色#F5DEB3245,222,179▇▇▇▇▇▇▇▇Moccasin鹿皮鞋#FFE4B5255,228,181▇▇▇▇▇▇▇▇Orange橙色#FFA500255,165,0▇▇▇▇▇▇▇▇PapayaWhip番木瓜#FFEFD5255,239,213▇▇▇▇▇▇▇▇BlanchedAlmond漂白的杏仁#FFEBCD255,235,205▇▇▇▇▇▇▇▇NavajoWhite纳瓦霍白/印第安黄#FFDEAD255,222,173▇▇▇▇▇▇▇▇AntiqueWhite古代的白色#FAEBD7250,235,215▇▇▇▇▇▇▇▇Tan晒黑#D2B48C210,180,140▇▇▇▇▇▇▇▇BrulyWood结实的树#DEB887222,184,135▇▇▇▇▇▇▇▇Bisque(浓汤)乳脂、番茄等#FFE4C4255,228,196▇▇▇▇▇▇▇▇DarkOrange深橙色#FF8C00255,140,0▇▇▇▇▇▇▇▇Linen亚麻布#FAF0E6250,240,230▇▇▇▇▇▇▇▇Peru秘鲁#CD853F205,133,63▇▇▇▇▇▇▇▇PeachPuff桃色#FFDAB9255,218,185▇▇▇▇▇▇▇▇SandyBrown沙棕色#F4A460244,164,96▇▇▇▇▇▇▇▇Chocolate巧克力#D2691E210,105,30▇▇▇▇▇▇▇▇SaddleBrown马鞍棕色#8B4513139,69,19▇▇▇▇▇▇▇▇SeaShell海贝壳#FFF5EE255,245,238▇▇▇▇▇▇▇▇Sienna黄土赭色#A0522D160,82,45▇▇▇▇▇▇▇▇LightSalmon浅鲜肉(鲑鱼)色#FFA07A255,160,122▇▇▇▇▇▇▇▇Coral珊瑚#FF7F50255,127,80▇▇▇▇▇▇▇▇OrangeRed橙红色#FF4500255,69,0▇▇▇▇▇▇▇▇DarkSalmon深鲜肉(鲑鱼)色#E9967A233,150,122▇▇▇▇▇▇▇▇Tomato番茄#FF6347255,99,71▇▇▇▇▇▇▇▇MistyRose薄雾玫瑰#FFE4E1255,228,225▇▇▇▇▇▇▇▇Salmon鲜肉(鲑鱼)色#FA8072250,128,114▇▇▇▇▇▇▇▇Snow雪#FFFAFA255,250,250▇▇▇▇▇▇▇▇LightCoral淡珊瑚色#F08080240,128,128▇▇▇▇▇▇▇▇RosyBrown玫瑰棕色#BC8F8F188,143,143▇▇▇▇▇▇▇▇IndianRed印度红#CD5C5C205,92,92▇▇▇▇▇▇▇▇Red纯红#FF0000255,0,0▇▇▇▇▇▇▇▇Brown棕色#A52A2A165,42,42▇▇▇▇▇▇▇▇FireBrick耐火砖#B22222178,34,34▇▇▇▇▇▇▇▇DarkRed深红色#8B0000139,0,0▇▇▇▇▇▇▇▇Maroon栗色#800000128,0,0▇▇▇▇▇▇▇▇White纯白#FFFFFF255,255,255▇▇▇▇▇▇▇▇WhiteSmoke白烟#F5F5F5245,245,245▇▇▇▇▇▇▇▇Gainsboro庚斯博罗灰色/淡灰色/亮灰#DCDCDC220,220,220▇▇▇▇▇▇▇▇LightGray浅灰色#D3D3D3211,211,211▇▇▇▇▇▇▇▇Silver银白色#C0C0C0192,192,192▇▇▇▇▇▇▇▇DarkGray深灰色#A9A9A9169,169,169▇▇▇▇▇▇▇▇Gray灰色#808080128,128,128▇▇▇▇▇▇▇▇DimGray暗淡的灰色#696969105,105,105▇▇▇▇▇▇▇▇Black纯黑#0000000,0,0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98ae17f19a49a5a3c4f6d8c02f54b7f6/" rel="bookmark">
			通信原理（1）- 最佳接收技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
0 最佳接收总述
1 信号空间理论
1.1 信号空间思想
1.2 信号空间相关理论定义
1.3 信号分析在信号空间中的应用
2 统计判决理论
2.1 统计判决理论简述 2.2 MAP准则和ML准则
3 信号最佳接收技术
3.1 信号最佳接收思想
3.1.1 信号接收简述
3.1.2 样本概率分析
3.1.3 信号空间分析
3.1.4 两种分析方法的关系 3.2 最佳接收机（最佳检测器）
3.2.1 相关解调器
3.2.2 最佳信号接收的判决结构与匹配滤波器
3.2.3 最佳接收机的简化
3.2.3.1 二进制最佳接收的简化
3.2.3.2 多进制数字调制支路独立判决
3.2.4 实例：二进制基带信号最佳接收误码率
3.2.4.1 利用低通滤波的接收
3.2.4.2 利用匹配滤波器的最佳接收
3.2.4.3 二进制PAM最佳接收误码率分析
3.2.5 一般M进制基带信号最佳接收误码率
3.3 最佳接收机的信号设计
3.3.1 确定信号的最佳接收
3.3.1.1 二进制误码率公式的推导
3.3.1.2 不同二进制信号的形式对误码率的影响
3.3.1.3 多进制信号误码率公式
3.3.2 随相信号的最佳接收
3.3.3 起伏信号的最佳接收
4 实际接收机与最佳接收机性能比较
5 信号空间思想分析最佳接收机的信号设计
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98ae17f19a49a5a3c4f6d8c02f54b7f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed7dcdd95e39e7b2bd358eb3138aa473/" rel="bookmark">
			uniApp监听左右滑动事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		监听左右滑动事件的步骤 1. 添加需要监听滑动事件的元素 在你的页面中，添加需要监听滑动事件的元素。这可以是一个 view、swiper 或其他组件，取决于你的需求。例如：
&lt;template&gt; &lt;view class="body" @touchstart="touchStart" @touchmove="touchMove" @touchend="touchEnd"&gt; &lt;!-- 页面内容 --&gt; &lt;/view&gt; &lt;/template&gt; uniapp的滑动事件我也是感觉挺不错的，关键是能够实现局部滑动，这一点就非常的棒。
2. 编写事件处理逻辑 在页面的 &lt;script&gt; 部分，编写事件处理逻辑。我们将使用 @touchstart 事件记录触摸起始点的横坐标，@touchmove 事件计算滑动距离，并根据距离判断滑动方向，最后使用 @touchend 事件清除触摸起始点的记录。
&lt;script&gt; export default { data() { return { startX: '', // 触摸起始点横坐标 deltaX：'' }; }, methods: { touchStart(event) { // 记录触摸起始点的横坐标 this.startX = event.touches[0].clientX; }, touchMove(event) { // 计算滑动距离 const currentX = event.touches[0].clientX; this.deltaX = currentX - this.startX; }, touchEnd() { // 判断滑动方向 if (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed7dcdd95e39e7b2bd358eb3138aa473/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21ac14e6b9527b98dc78382dafe041ee/" rel="bookmark">
			矩阵论（Matrix）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大纲 矩阵微积分：多元微积分的一种特殊表达，尤其是在矩阵空间上进行讨论的时候逆矩阵(inverse matrix)矩阵分解：特征分解（Eigendecomposition），又称谱分解（Spectral decomposition）；LU分解；奇异值分解（singular value decomposition）；QR分解；科列斯基分解矩阵行列式（Determinant）：在欧几里得空间中，行列式描述的是一个线性变换对“体积”所造成的影响特征向量（eigenvector）： A v = λ v Av=\lambda v Av=λv，其中 λ \lambda λ为特征值， v v v为 A A A的特征向量， A A A的所有特征值的全体叫 A A A的谱，记为 λ ( A ) \lambda(A) λ(A)迹（trance）： tr ⁡ ( A ) = A 1 , 1 + ⋯ + A n , n \operatorname{tr}(\mathbf{A}) = \mathbf{A}_{1, 1} + \cdots + \mathbf{A}_{n, n} tr(A)=A1,1​+⋯+An,n​，一个矩阵的迹是其特征值的总和奇异矩阵（Singular Matrix）：奇异矩阵是指行列式为零的方阵。如果一个矩阵 A 是奇异矩阵，那么它的奇异值中至少有一个为零。这是因为奇异矩阵的行列式为零，而行列式是矩阵奇异值的乘积。正交矩阵（orthogonal matrix）：是一个方阵，其行向量與列向量皆為正交的单位向量，使得該矩陣的转置矩阵為其逆矩阵。 Q Q T = I QQ^T=I QQT=I正定矩阵和半正定矩阵（positive semi-definite matrix）：一个 n × n n\times n n×n 的实对称矩阵 M M M 是正定的，当且仅当对于所有的非零实系数向量 z \mathbf {z} z，都有 z T M z &gt; 0 \mathbf {z} ^{T}M\mathbf {z} &gt;0 zTMz&gt;0。其中 z T \mathbf {z} ^{T} zT表示 z \mathbf {z} z 的转置伴随矩阵（adjugate matrix）：如果矩阵可逆，那么它的逆矩阵和它的伴随矩阵之间只差一个系数共轭矩阵（又叫Hermite矩阵）：矩阵本身先转置再把矩阵中每个元素取共轭(虚部变号的运算)得到的矩阵共轭转置（conjugate transpose or Hermitian transpose）： A ∗ = ( A ‾ ) T = A T ‾ A^* = (\overline{A})^\mathrm{T} = \overline{A^\mathrm{T}} A∗=(A)T=AT, A ‾ \overline{A} A表示对矩阵A元素取复共轭酉矩阵（又叫幺正矩阵，unitary matrix）：指其共轭转置恰为其逆矩阵的复数方阵， U ∗ U = U U ∗ = I n U^{*}U=UU^{*}=I_{n} U∗U=UU∗=In​实对称矩阵：元素都为实数的对称矩阵对角矩阵(diagonal matrix)：一个主对角线之外的元素皆为0的矩阵，常写为diag（a1，a2,…,an)雅可比矩阵（Jacobian matrix）： J = [ ∂ f ∂ x 1 ⋯ ∂ f ∂ x n ] = [ ∂ f 1 ∂ x 1 ⋯ ∂ f 1 ∂ x n ⋮ ⋱ ⋮ ∂ f m ∂ x 1 ⋯ ∂ f m ∂ x n ] \mathbf {J} ={\begin{bmatrix}{\dfrac {\partial \mathbf {f} }{\partial x_{1}}}&amp;\cdots &amp;{\dfrac {\partial \mathbf {f} }{\partial x_{n}}}\end{bmatrix}}={\begin{bmatrix}{\dfrac {\partial f_{1}}{\partial x_{1}}}&amp;\cdots &amp;{\dfrac {\partial f_{1}}{\partial x_{n}}}\\\vdots &amp;\ddots &amp;\vdots \\{\dfrac {\partial f_{m}}{\partial x_{1}}}&amp;\cdots &amp;{\dfrac {\partial f_{m}}{\partial x_{n}}}\end{bmatrix}} J=[∂x1​∂f​​⋯​∂xn​∂f​​]= ​∂x1​∂f1​​⋮∂x1​∂fm​​​⋯⋱⋯​∂xn​∂f1​​⋮∂xn​∂fm​​​ ​黑塞矩阵（又叫海森矩阵，Hessian matrix)：由多变量实值函数的所有二阶偏导数组成的方阵， H i j = ∂ 2 f ∂ x i ∂ x j \mathbf {H} _{ij}={\frac {\partial ^{2}f}{\partial x_{i}\partial x_{j}}} Hij​=∂xi​∂xj​∂2f​矩阵范数（matrix norm） 一、矩阵微积分 向量对向量的偏导称 Jacobian Matrix:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21ac14e6b9527b98dc78382dafe041ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71d47da53cd2b0831bdf190e793fdcc3/" rel="bookmark">
			Milvus 老友汇｜AI、云原生与向量数据库的精彩碰撞回顾！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一场久违的老友对谈，一次精妙的 AI 探索碰撞。
近日，Milvus 老友汇·Arch Meetup 在上海圆满落幕。本次 Meetup 亮点颇多，不仅得到了 KubeBlocks 社区的大力支持，同时也邀请了来自网易伏羲和蚂蚁集团的资深专家，现场分享各自对于 AI 时代云原生与向量数据库的思考。
接下来，让我们快速回顾一下本次活动的主要观点：
Zilliz 资深工程师 夏琮祺 ：无论是架构、新功能、性能还是可维护性，Milvus 2.3.x 都是向量数据库中的佼佼者，绝对值得一试
网易伏羲资深 AI 研发工程师 陈京来 ：Milvus 在网易图文多模态场景的实践中显示，其有效地支撑了网易伏羲十亿级图文数据及应用落地
云猿生数据资深工程师 郭子昂：使用 KubeBlocks 轻松管理向量数据库 + LLM 等 AIGC 数据基础设施
蚂蚁集团工程师 徐鹏飞：使用 KCL 声明式配置语言和工具应对工程化配置策略挑战
以下为详细解读，大家可按需享用：
01.Milvus 2.3.x 新功能解读 夏琮祺从架构、新功能、性能和可维护性方面对 Milvus 2.3.x 进行了全方位的解读。
他首先提到，Milvus 2.3.x 在架构方面进行了升级，包括对异构硬件的支持（GPU Index：RAFT；ARM）、升级 QueryNode（QueryNodeV2）。夏琮祺着重介绍了 QueryNodeV2 。QueryNode 承担了整个Milvus 系统中最重要的检索服务，其稳定性、性能、扩展性对 Milvus 至关重要，但 QueryNodeV1 存在状态复杂、消息队列重复、代码结构不清晰、报错内容不直观等问题。在 QueryNodeV2 的新设计中，团队重新梳理了代码结构、将复杂的状态改为无状态的设计、移除了 delete 数据的消息队列减少了资源浪费，在后续持续的稳定性测试中，QueryNodeV2 的表现更加优异。
新功能方面，Milvus 2.3.x 上线的这些功能值得重点关注：
Upsert：由于 Milvus 现在还不支持 update 操作，用户需要更新向量时需要删除旧有的记录后并重新插入。在2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71d47da53cd2b0831bdf190e793fdcc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e30dca5c22b2c1405a3063a5b4442f63/" rel="bookmark">
			计算机网络——网络层——OSPF协议的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是 OSPF ？ OSPF 是一个基于链路状态的自治系统内部路由协议，在 TCP/IP 的网络层中进行路由选择，常用于构建大型企业网络或者服务上的骨干网络。在互联网核心路由器之间也可以使用。
OSPF 概述 OSPF 使用的是 Dijkstra（最短路径算法）来计算路径，从而构建网络拓扑图。是一种开放性协议，规范公开，允许不同厂商的设备之间实现兼容。
在网络拓扑发生变化时，OSPF 能够迅速适应，通过更新路由表实现快速收敛，确保数据按最短路径传输。
OSPF 将网络划分为区域（Area），每个区域都有自己的数据库，区域之间通过边界路由器连接。 OSPF 将网络划分为区域，其中 Backbone Area（区域0）是所有其他区域的中心，提高了可扩展性。
OSPF 使用链路成本作为度量单位，用于计算路径开销。成本越小，路径的优先级越高。
OSPF 能够适应网络拓扑的变化，比如链路的添加、删除或者变化。它可以快速适应网络的变化并更新路由信息。
文章目录 什么是 OSPF ？ OSPF 概述为什么要使用 OSPF 协议OSPF 的不足OSPF 协议与其他链路状态协议的比较：OSPF 的三张表OSPF 建立邻居关系OSPF 使用的分层结构OSPF 的邻居关系链路状态数据库（LSDB）的同步最短路径计算 OSPF 的运行过程总结 为什么要使用 OSPF 协议 OSPF在设计上具有高度的可扩展性、灵活性和快速收敛的特点，适用于构建复杂网络环境。从而为许多的企业和厂商提供了选择。以下是OSPF的优点：
快速收敛： OSPF具有快速的网络收敛能力。当网络拓扑发生变化时，OSPF能够迅速适应，并在相对较短的时间内更新路由表，确保数据包能够按最优路径传输。
支持分层设计： OSPF的设计允许将网络划分为多个区域，其中Backbone Area（区域0）是所有其他区域的中心。这种分层设计提高了网络的可扩展性。
开放性和厂商中立性： OSPF是一种开放协议，其规范公开可用，使得不同厂商的设备能够实现兼容的OSPF协议。这种开放性有助于确保多样性和互操作性。
支持VLSM（Variable Length Subnet Masking）： OSPF支持可变长度子网掩码（VLSM），允许网络管理员更有效地分配IP地址，提高地址利用率。
灵活的策略控制： OSPF允许管理员通过区域设计、路由汇总和过滤等方式对路由信息进行精确的控制。这使得网络管理员能够更好地适应特定的网络需求和策略。
适应多样化网络环境： OSPF适用于多样化的网络环境，包括企业内部网络、服务提供商的骨干网络以及互联网核心路由器之间的连接。其灵活性使得它能够适应不同规模和类型的网络。
支持IPv4和IPv6： OSPF可以同时支持IPv4和IPv6，使得在网络过渡期或者纯IPv6环境中都能够灵活使用。
强大的安全特性： OSPF支持加密和身份验证机制，如MD5认证，以确保路由器之间的通信的安全性。
OSPF 的不足 OSPF 是一种强大而灵活的路由协议，但它也有一些缺点。在选择使用 OSPF 的时候，最好是先权衡其优点和缺点，考虑网络环境的部署和需求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e30dca5c22b2c1405a3063a5b4442f63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d14a17b176cbdcf9d729c5771713ded4/" rel="bookmark">
			Fegin 原理框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Cloud OpenFeign源码解析 - 知乎 @EnableFeignClients @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Documented @Import(FeignClientsRegistrar.class) public @interface EnableFeignClients { String[] value() default {}; String[] basePackages() default {}; Class&lt;?&gt;[] basePackageClasses() default {}; Class&lt;?&gt;[] defaultConfiguration() default {}; Class&lt;?&gt;[] clients() default {}; } @FeignClientsRegistrar
实现了spring 的接口ImportBeanDefinitionRegistrar，可以在启动时动态的生成BeanDefinition,并注册到BeanDefinitionRegistry，后续ApplicationContext可以根据这些BeanDefintion实例化Bean，并且注册到容器中。
简单来说，通过FeignClientsRegistrar，可以做到在应用开发者只提供接口的情况下，框架自动实现接口，并且自动注册到容器中。
实现接口ResourceLoaderAware，主要讲ApplicationContext 的resourceLoader 传入到FeignClientRegistrar中，resourceLoader主要用于包扫描，资源加载。
实现接口EnvironmentAware,将ApplicationContext 中的Environment 传入FeignClientRegistrar 中，和配置相关的数据通过Environment 提取。
registerBeanDefinitons 里面有两个方法，第一个是registerDefaultConfiguration,将defaultConfiguration 注册到BeanDefintionRegitry.@EnableFeignClients的参数defaultConfiguration 在此地起作用。
registerFeignClients 主要干了几件事：
1.构造扫描器，ClassPathScanningCandiateComponentProvider，用于在包路径上找到候选组件，也就是FeignClient接口
2.给扫描器添加过滤器
3.扫描找到所有的候选组件，并将注解@FeignClient 对应的configuration 注册到BeanDefinationRegistry，将注解的参数作为BeanDefinition 的参数，将FeignClientFactoryBean 注册到BeanDefinitionRegistry
FeignClientFactoryBean 对于构建一些比较复杂bean,BeanDefinition 不是特别方便，spring 提供了一个特殊的接口，factoryBean,可以将复杂的bean 写在factorybean实现类上。
方法getObject 调用了getTarget()创建FeignClient, 主要包括 1. 从applicationContext 中取出feigncontext, 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d14a17b176cbdcf9d729c5771713ded4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/283766f93d051b35d5ce11ccaabed191/" rel="bookmark">
			uniapp计算视频学习进程，并且下次回来继续播放（不能快进）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 该功能分别有三个难点：
1.计算百分比，计算上次播放秒数 2.如何使视频无法快进 3.如何从上次播放描述开始 首先现在这里熟悉一下如何计算： 1.计算视频播放的百分比 比如该视频的总时长为120秒，然后现在播放的时长为12秒，计算当前视频学习时长的百分比
let a = 120//总时长 let b = 12//现在播放的时长 let c = b / a * 100//总进度 10% 2.计算上次播放视频的秒数 比如该视频的总时长为120秒，当前视频学习时长为10%，计算上次播放视频的秒数
let a = 120//总时长 let c = 10//百分比 let b = a * (c / 100)//上次播放时长 到这里第一个难题已经解决
然后想要获取上次播放视频的秒数最佳方法就是请求接口了
请求接口这一步就省去了，不懂得在评论区留言
其次、如何让视频无法快进 上代码：
html：
&lt;video id="myVideo" :title="data.course_title" :initial-time="videoContext" style="width: 100%;" :src="data.video_url" controls @timeupdate="videoTimeUpdateEvent"&gt;&lt;/video&gt; js：
currentTime: '', //现在的时长 durationTime: '', //总时长 videoContext: 0, watch: 0, //用来判断是否快进 box: null,//绑定上次文 progress: ''//百分比 onReady() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/283766f93d051b35d5ce11ccaabed191/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/421b5e1ccb0cd32faa092a8fb849460d/" rel="bookmark">
			solidity 特性导致的漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、默认可见性
2、浮点数精度缺失
3、错误的构造函数
4、自毁函数
5、未初始化指针-状态变量覆盖
1、默认可见性 Solidity 的函数和状态变量有四种可见性：external、public、internal、private。函数可见性默认为 public，状态变量可见性默认为 internal。
可见范围：private &lt; internal &lt; external &lt; public
private：只有当前合约可见internal：外部合约不可见，只有当前合约内部和子类合约可见external：只能被外部合约或者外部调用者可见public：公共函数和状态变量对所有智能合约可见 solidity 0.4 版本，函数不设置访问修饰符编译不会报错，函数默认的可见性是 public，如果一下敏感函数没有设置访问修饰符，就可能发生越权函数调用
漏洞场景：
敏感函数忘记设置访问修饰符
漏洞代码示例：
pragma solidity ^0.4.5; contract HashForEther { function withdrawWinnings() { // Winner if the last 8 hex characters of the address are 0. require(uint32(msg.sender) == 0); sendWinnings(); } function sendWinnings() { msg.sender.transfer(this.balance); } } sendWinnings 函数忘记设置函数访问修饰符了，而默认可见性是 public，于是导致任意地址都可以调用改函数而获得转账。
2、浮点数精度缺失 浮点型，定长浮点型——Solidity目前暂时不支持浮点型，也不完全支持定长浮点型。
fixed/ufixed 表示有符号和无符号的定长浮点数，浮点型可以用来声明变量，但不可以用来赋值。
除法运算：除法运算的结果会四舍五入，如果出现小数，小数点后的部分都会被舍弃，只取整数部分
pragma solidity ^0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/421b5e1ccb0cd32faa092a8fb849460d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b34c40d1fba014dbe86542e6546f16a/" rel="bookmark">
			【ELEC362 】APPLICATION DEVELOPMENT WITH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		University of Liverpool C++ The concept: The long term aim of the project is to develop a fully functional software, known as DataViz, for plotting and processing datasets, which will be eventually deployed and released for all students in the department to use in their reports, data processing, and as a show case of an authentic experience of software development for the students of ELEC362. The development is planned over 5 years, which started in 2022.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b34c40d1fba014dbe86542e6546f16a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/191550e55b42aee5587c0f0dcbe332a8/" rel="bookmark">
			尚硅谷Docker笔记-高级篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Docker复杂安装 1.1安装mysql主从复制搭建步骤 1.新建主服务器容器实例3307
docker run -p 3307:3306 --name mysql-master \ -v /mydata/mysql-master/log:/var/log/mysql \ -v /mydata/mysql-master/data:/var/lib/mysql \ -v /mydata/mysql-master/conf:/etc/mysql \ -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 docker ps mysql8.0 记得多加上映射卷：
-v /MySql80Data/mysql-master/files:/var/lib/mysql-files/
2.进入/mydata/mysql-master/conf目录下新建my.cnf。
vim my.cnf（注意是cnf不是conf），粘贴以下内容
[mysqld]
##设置server_id,同一局域网中需要唯一
server_id=101
##指定不需要同步的数据库名称
binlog-ignore-db=mysql
##开启二进制日志功能
log-bin=mall-mysql-bin
##设置二进制日志使用内存大小（事务）
binlog_cache_size=1M
##设置使用的二进制日志格式（mixed,statement,row)
binlog_format=mixed
##二进制日志过期清理时间。默认值为0，表示不自动清理。
expire_logs_days=7
##跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。
##如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致
slave_skip_errors=1062
3.修改完配置后重启master实例
docker restart mysql-master docker ps 4.进入mysql-master容器
docker exec -it mysql-master /bin/bash mysql -uroot -proot &gt; show databases; 5.master容器实例内创建数据同步用户并授权
CREATE USER 'slave'@'%' IDENTIFIED BY '123456'; GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/191550e55b42aee5587c0f0dcbe332a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc7301d6ebe0781864f2f9e8e3288315/" rel="bookmark">
			记一次gorm连接池打满，连接不释放的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述：使用事务一定要关闭！ 我们golang项目用的gorm，最近pre测试跑脚本时，总会出现504，某个接口不可用。分析了半天pprof，阻塞数量较多的goroutine，某些时候并不能看到真实问题的所在。
出现504，通过pprof:debug/pprof/goroutine?debug=2 或者debug/pprof/goroutine?debug=1 能看到阻塞的goroutine，处在io wait状态
检查下pod内，连接数(netstat)，发现http的连接数和mysql的连接数暴增!!!
导致mysql的连接数暴增常见的有三种： 1、使用事务，没有关闭～！！！！！ （我们小伙伴的错误命中）
tx:=db.conn后，err判断，直接return，没有进行tx.rollback。这时候mysql的conn_pool会+1，且不可复用。
错误的请求继续上涨后，就会出现连接数打满，继而新的请求一直阻塞，goroutine也会阻塞住。
此时杀死连接也没用，因为goroutine锁死在tx.awaitDone()里，也就是在等待done的chan返回。
只有调用tx.Commit或tx.Rollback才能使awaitDone返回，否则会造成conn闲置，协程溢出。
tx.Commit或tx.Rollback都会调用Tx.cancel和Tx.releaseConn。
正确使用：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
conn, err := mysql.GetConn()
if err != nil {
return
}
tx := conn.Begin()
defer func() {
if r := recover(); r != nil {
tx.Rollback()
}
}()
......
......
if err != nil {
tx.Rollback()
return
}
tx.Commit()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc7301d6ebe0781864f2f9e8e3288315/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/329a2e5b07eaa588d101dc44287e1941/" rel="bookmark">
			RKE2部署Kubernetes(二) 使用helm部署rancher（适用于生产环境）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes中使用helm部署rancher 1、安装helm工具 #获取软件 wget https://get.helm.sh/helm-v3.13.2-linux-amd64.tar.gz #解压软件 tar -zxvf helm-v3.13.2-linux-amd64.tar.gz #加入环境变量 mv linux-amd64/helm /usr/local/bin/helm #查看帮助 helm --help #添加Helm Chart仓库 helm repo add rancher-stable https://releases.rancher.com/server-charts/stable 2、为Rancher创建命名空间 kubectl create namespace cattle-system 本次选择 SSL 配置为Rancher 生成的 TLS 证书
3、安装cert-manager # 如果你手动安装了CRD，而不是在 Helm 安装命令中添加了 `--set installCRDs=true` 选项，你应该在升级 Helm Chart 之前升级 CRD 资源。 kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.2/cert-manager.crds.yaml # 添加 Jetstack Helm 仓库 helm repo add jetstack https://charts.jetstack.io # 更新本地 Helm Chart 仓库缓存 helm repo update # 安装 cert-manager Helm Chart helm install cert-manager jetstack/cert-manager \ --namespace cert-manager \ --create-namespace \ --version v1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/329a2e5b07eaa588d101dc44287e1941/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36420af361af8aed252dead4d9cee353/" rel="bookmark">
			RKE2部署kubernetes（三）工作agent节点配置本地harbor私有镜像仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、配置本地镜像仓库地址2、重启rke2-agent.service3、使用示例4、更多4.1 若本地镜像仓库使用https，并使用TLS是配置如下：4.2若本地镜像仓库使用https，不使用TLS是配置如下： 本地搭建了harbor镜像仓库，使用的是http（https未启用） 以下均在agent节点操作
1、配置本地镜像仓库地址 11:52 root@k8s-rke2-worker03:/etc/rancher/rke2 $vim registries.yaml 11:52 root@k8s-rke2-worker03:/etc/rancher/rke2 $cat registries.yaml mirrors: docker.io: endpoint: - "http://10.10.0.95:8080" configs: "10.10.0.95:8080": auth: username: admin password: Harbor123456 11:53 root@k8s-rke2-node01:/etc/rancher/rke2 $ 2、重启rke2-agent.service 11:54 root@k8s-rke2-node01:~ $ systemctl restart rke2-agent.service 说明：重启rke2-agent.service服务后配置会同步到/var/lib/rancher/rke2/agent/etc/containerd/config.toml文件，并生效。
3、使用示例 注意：配置的mirror名称，上面配置文件中名称用的docker.io 如镜像地址为：http://10.10.0.95:8080/ponycloud/frontend:20230810 之前docker需要配置/etc/docker/demon.json文件，然后docker pull http://10.10.0.95:8080/ponycloud/frontend:20230810拉取 Containerd 拉取私有镜像仓库如下
#使用containerd拉取 11:36 root@k8s-rke2-node01:~ $crictl pull docker.io/ponycloud/frontend:20230810 Image is up to date for sha256:e8ed12a6bb4604907c42159206af53194e32869409833f938f70c816d846bd27 11:41 root@k8s-rke2-node01:~ $crictl images IMAGE TAG IMAGE ID SIZE 10.10.0.95:8080/ponycloud/frontend 20230810 e8ed12a6bb460 65.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36420af361af8aed252dead4d9cee353/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2352ed4c149428b9aff5169d572bc092/" rel="bookmark">
			TypeError: add_self_loops() got an unexpected keyword argument ‘edge_weight‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个错误表明在执行add_self_loops函数时出现了一个不期望的关键字参数edge_weight。，这个问题与PyTorch Geometric版本有关，因为较新的版本中add_self_loops函数的参数已经发生了变化。
将 "edge_weight" 参数改为 "edge_attr "即可
参考于： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f63aec649bf69eebb62397b80040a9c7/" rel="bookmark">
			PLUMED MetaDynamics Simulation 输入文件编写教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文翻译自 PLUMED 官方教程，旨在指导读者完成MetaDynamics Simulation 输入文件的编写，该文件可用于诸如 GROMACS 的gmx_mpi mdrun -plumed，以完成最终模拟。
文章目录 IntroductionDescription of ComponentsExamples Introduction 这是偏置模块的一部分，用于对一个或多个集合变量执行 MetaDynamics。在元动力学模拟中，由间歇性添加的高斯函数组成的历史相关偏置被添加到势能中：
V ( s ⃗ , t ) = ∑ k τ &lt; t W ( k τ ) exp ⁡ ( − ∑ i = 1 d ( s i − s i ( 0 ) ( k τ ) ) 2 2 σ i 2 ) . V(\vec{s},t) = \sum_{ k \tau &lt; t} W(k \tau) \exp\left( -\sum_{i=1}^{d} \frac{(s_i-s_i^{(0)}(k \tau))^2}{2\sigma_i^2} \right).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f63aec649bf69eebb62397b80040a9c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d50b0fc7fd820c65ea83eb37e9341e47/" rel="bookmark">
			QT去除QString字符串中空格的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址::QT去除QString字符串中空格的方法_qt去除字符串空格-CSDN博客
1.清除字符串首尾的空格，且字符串中间的空格都转换为一个空格。
QString str = “ aa\t bb\n cc\r\n ”;
str.simplified();
结果：”aa bb cc”
2.去除字符串前面的空格
QString str1 = " 1 2 3 ";
str1.remove(QRegExp("^ +\\s*"));
结果：“1 2 3” 3.去除字符串后面的空格
QString str2 = " 4 5 6 ";
str2.remove(QRegExp("\\s* +$"));
qDebug() &lt;&lt; "str2=" &lt;&lt; str2;
结果：“ 4 5 6”
4.去除字符串首尾的空格
//\t,\n,\v,\f,\r都属于simplified()处理的空白范围
QString str3 = " \t,\n,\v,\f,\rhello\t world\n123\r\n ";
qDebug() &lt;&lt; "str3.simplified()=" &lt;&lt; str3.simplified();
QString str4 = " \t,\n,\v,\f,\rhello\t world\n123\r\n ";
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d50b0fc7fd820c65ea83eb37e9341e47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c8a56208ffee65ae896ea30e275ec2a/" rel="bookmark">
			云卷云舒：软件架构设计的经验总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#架构设计#
围绕架构设计的通用思想，从可用性、扩展性、高性能个一致性四个方面重点强调了架构设计的基本方法理论，具有较强的通用性和指导性。
可用性的不同设计，会带来不同级别的可用性表现，主要指标为“几个9”。
影响可用性的因素包含故障、变更、架构设计、突发流量等等。
必要的容错设计，是最容易忽视的点，比如避免单点、服务降级、重试机制、隔离性设计是必须要做的。
对于流量的控制对于高并发系统来说也是必选，比如通过各类限流算法实现网关级别的全局限流、模块级别的模块限流、开源工具限流等。
这里的灾备具有通用性，按照上图所示，对于典型的同城、异地、双活、两点中心，甚至云计算环境之下的苦啊AZ/Region、算力网络等，我们要针对业务的现实需要选择对应的方案，且无门哪个组追求高级别容灾，应为成本是最大的问题挑战。
对于数据库的扩展性设计至关重要，因为数据库内就是企业的最核心资产，没有之一，数据的安全性、可控性、数据读取的效率、甚至成本都是企业该考虑的因素，随着云计算技术的快速发展，云数据库、云原生数据库、分布式数据库越来越受欢迎，举个例子，云数据库可以解决最基本的扩展性问题，但是开发云数据库的时候，该理论也具有参考意义。
同时使用了云数据库也不意味着高枕无忧了，同样在业务架构设计的时候，使用好云数据库同样需要相关的扩展性设计理论。
性能设计没有秘诀，要是有那就是“端到端面相性能的设计”，网关、数据库、网络、前端、存储、数据量、并发等等都是，最后好要有一个“完整的性能测试”作保障。
注：个人学习经验总结，仅供参考，欢迎留言、转发
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d8dc747d1fe0e13709592d5ad3dc632/" rel="bookmark">
			MYsql第二次作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
问题 解答
1.显示所有职工的基本信息。
2.查询所有职工所属部门的部门号，不显示重复的部门号。
3.求出所有职工的人数。
4.列出最高工和最低工资。
5.列出职工的平均工资和总工资。
6.创建一个只有职工号、姓名和参加工作的新表，名为工作日期表。
7.查看所有人的年龄
8.列出所有姓刘的职工的职工号、姓名和出生日期
9.列出1960年以前出生的职工的姓名、参加工作日期。
10.列出工资在1000－2000之间的所有职工姓名。
11.列出所有陈姓和李姓的职工姓名
12.查询部门号为103或102的职工号，姓名，政治面貌
13.将职工表worker中的职工按出生的先后顺序排序
14.显示工资最高的前3名职工的职工号和姓名。
15.求出各部门党员的人数。
16.统计各部门的工资和平均工资
17.列出总人数大于4的部门号和总人数。
问题 解答 1.显示所有职工的基本信息。 2.查询所有职工所属部门的部门号，不显示重复的部门号。 3.求出所有职工的人数。 4.列出最高工和最低工资。 5.列出职工的平均工资和总工资。 6.创建一个只有职工号、姓名和参加工作的新表，名为工作日期表。 7.查看所有人的年龄 8.列出所有姓刘的职工的职工号、姓名和出生日期 9.列出1960年以前出生的职工的姓名、参加工作日期。 10.列出工资在1000－2000之间的所有职工姓名。 11.列出所有陈姓和李姓的职工姓名 12.查询部门号为103或102的职工号，姓名，政治面貌 13.将职工表worker中的职工按出生的先后顺序排序 14.显示工资最高的前3名职工的职工号和姓名。 15.求出各部门党员的人数。 16.统计各部门的工资和平均工资 17.列出总人数大于4的部门号和总人数。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32e285f02988fb045305d8d5c946019e/" rel="bookmark">
			深度学习 Day17——P6好莱坞明星识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍨 本文为🔗365天深度学习训练营 中的学习记录博客🍖 原作者：K同学啊 | 接辅导、项目定制 文章目录 前言1 我的环境2 代码实现与执行结果2.1 前期准备2.1.1 引入库2.1.2 设置GPU（如果设备上支持GPU就使用GPU,否则使用CPU）2.1.3 导入数据2.1.4 可视化数据2.1.4 图像数据变换2.1.4 划分数据集2.1.4 加载数据2.1.4 查看数据 2.2 构建CNN网络模型2.3 训练模型2.3.1 设置超参数2.3.2 编写训练函数2.3.3 编写测试函数2.3.4 正式训练 2.4 结果可视化2.4 指定图片进行预测2.6 模型评估 3 知识点详解3.1 自建vgg16模型3.2 拔高尝试--VGG16+BatchNormalization3.3 拔高尝试--VGG16+BatchNormalization+Dropout层3.4 拔高尝试--VGG16+BatchNormalization+Dropout层+增加训练集比例3.5 拔高尝试--VGG16+BatchNormalization+Dropout层+增加训练集比例+自适应平均池化层代替全连接层(模型轻量化)3.6 拔高尝试--VGG16+BatchNormalization+Dropout层+增加训练集比例+全局平均池化层代替全连接层(模型轻量化)3.6 拔高尝试--VGG16+BatchNormalization+Dropout层+增加训练集比例+全局平均池化层代替全连接层(模型轻量化)+L2正则化参数λ（weight_decay项）的优化器3.7 PyTorch程序实现L1和L2正则项3.7.1 背景介绍3.7.2 公式推导3.7.3 程序实现3.7.3.1 正则化实现3.7.3.2 网络实例3.7.3.3 在网络中加入正则项3.7.3.4 PyTorch中自带的正则方法：权重衰减3.7.4 正则项的使用注意事项3.7.5 正则化总结 总结 前言 本文将采用pytorch框架创建CNN网络，实现好莱坞明星识别。讲述实现代码与执行结果，并浅谈涉及知识点。
关键字： 增加Dropout层，增加训练集比例，全局平均池化层代替全连接层(模型轻量化)，PyTorch程序实现L1和L2正则项
1 我的环境 电脑系统：Windows 11语言环境：python 3.8.6编译器：pycharm2020.2.3深度学习环境：
torch == 1.9.1+cu111
torchvision == 0.10.1+cu111显卡：NVIDIA GeForce RTX 4070 2 代码实现与执行结果 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32e285f02988fb045305d8d5c946019e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/888b5c8a072037923de5bf2fbd2c3604/" rel="bookmark">
			深度学习 Day14——P3天气识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍨 本文为🔗365天深度学习训练营 中的学习记录博客🍖 原作者：K同学啊 | 接辅导、项目定制 文章目录 前言1 我的环境2 代码实现与执行结果2.1 前期准备2.1.1 引入库2.1.2 设置GPU（如果设备上支持GPU就使用GPU,否则使用CPU）2.1.3 导入数据2.1.4 可视化数据2.1.4 图像数据变换2.1.4 划分数据集2.1.4 加载数据2.1.4 查看数据 2.2 构建CNN网络模型2.3 训练模型2.3.1 训练模型2.3.2 编写训练函数2.3.3 编写测试函数2.3.4 正式训练 2.4 结果可视化 3 知识点详解3.1 torchvision.transforms.Compose()详解3.2 pathlib中glob匹配多个格式文件获取数据列表3.3 plt.tight_layout()作用3.4 x.view()函数3.5 The freeze_support error解决方案3.6 提升测试acc--改变优化器 总结 前言 本文将采用pytorch框架创建CNN网络，实现天气识别。讲述实现代码与执行结果，并浅谈涉及知识点。
关键字： torchvision.transforms.Compose()详解,pathlib中glob匹配多个格式文件获取数据列表,plt.tight_layout()作用,x.view()函数，The freeze_support error解决方案，提升测试acc–改变优化器。
1 我的环境 电脑系统：Windows 11语言环境：python 3.8.6编译器：pycharm2020.2.3深度学习环境：
torch == 1.9.1+cu111
torchvision == 0.10.1+cu111显卡：NVIDIA GeForce RTX 4070 2 代码实现与执行结果 2.1 前期准备 2.1.1 引入库 import torch import torch.nn as nn from torchvision import transforms, datasets import os from pathlib import Path from PIL import Image from torchinfo import summary import torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/888b5c8a072037923de5bf2fbd2c3604/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac28dfbfa3d8da2c48faed473993eaa2/" rel="bookmark">
			深度学习 Day11——T11优化器对比实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍨 本文为🔗365天深度学习训练营 中的学习记录博客🍖 原作者：K同学啊 | 接辅导、项目定制 文章目录 前言一、我的环境二、代码实现与执行结果1.引入库2.设置GPU（如果使用的是CPU可以忽略这步）3.导入数据4.查看数据5.加载数据6.再次检查数据7.配置数据集8.可视化数据9.构建CNN网络模型10.编译模型11.训练模型12.模型评估 三、知识点详解1.加载预训练的 VGG16 模型2 优化器2.1 梯度下降法 (Gradient Descent)2.1.1 批量梯度下降法 (Batch Gradient Descent, BGD)2.1.2随机梯度下降（Stochastic Gradient Descent, SGD） 2.2 动量优化法（Momentum）2.3 自适应学习率优化算法2.2.1 AdaGrad（Adaptive Gradient）2.2.2 Adadelta2.2.3 RMSprop2.2.4 Adam（Adaptive Moment Estimation） 总结 前言 本文将采用CNN实现好莱坞明星识别，并用两种不同的优化器用于训练，并进行对比。简单讲述实现代码与执行结果，并浅谈涉及知识点。
关键字：加载预训练的 VGG16 模型，优化器。
一、我的环境 电脑系统：Windows 11语言环境：python 3.8.6编译器：pycharm2020.2.3深度学习环境：TensorFlow 2.10.1显卡：NVIDIA GeForce RTX 4070 二、代码实现与执行结果 1.引入库 from PIL import Image import numpy as np from pathlib import Path import tensorflow as tf from tensorflow.keras.layers import Dropout, Dense, BatchNormalization from tensorflow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac28dfbfa3d8da2c48faed473993eaa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9567413ecebe78c1d590153cffe8c2ef/" rel="bookmark">
			Django和ECharts异步请求示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提条件 创建django项目，安装配置过程这里就不讲述了。
后端url
http://127.0.0.1:8000/echarts/demo/
view视图函数
from django.http import HttpResponse import json def EchartsDemo(request): data = {} categories = ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"] values = [5, 20, 36, 10, 10, 20] data['categories'] = categories data['values'] = values return HttpResponse(json.dumps(data), content_type="application/json") 前端页面
需要分别引入jquery、echarts，顺序jquery在前
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;echarts示例&lt;/title&gt;	&lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;script type = "text/javascript" src = "echarts.min.js" &gt;&lt;/script&gt;	&lt;/head&gt; &lt;body&gt;	&lt;div id="main" style="width: 800px;height:600px;"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var myChart = echarts.init(document.getElementById('main')); $.get('api/echarts/demo/').done(function(data) { // data 的结构: // { // categories: ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9567413ecebe78c1d590153cffe8c2ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53ba0d724ef5490e39410a1d16a73d83/" rel="bookmark">
			云卷云舒：：云原生数据库系列-分布式KV事务数据库TiKV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介：
TiKV 是一个开源的分布式事务 Key-Value 数据库，支持跨行 ACID 事务，同时实现了自动水平伸缩、数据强一致性、跨数据中心高可用和云原生等重要特性。作为一个基础组件，TiKV 可作为构建其它系统的基石。目前最主要的chang，TiKV 已用于支持分布式 HTAP 数据库—— TiDB 中，负责存储数据，并已被多个行业的领先企业应用在实际生产环境。
二、发展：
发展很快，不到一年成为孵化项目
2018 年 8 月 29 日，称 CNCF宣布接纳 TiKV 作为 CNCF Sandbox 的云原生项目。2019 年 5 月，CNCF 的 TOC（技术监督委员会）投票决定接受 TiKV 晋级为孵化项目。 三、特性：
跨数据中心高可用：使用 Raft 协议和 PD（Placement Driver）来实现跨地域、跨数据中心的高可用。水平扩展：通过 PD 和精心实现的 Multi-Raft ，TiKV 在水平扩展性方面的表现出色，可以轻松扩展到 200+TB 的数据。一致的分布式事务 ：与 Google Spanner 类似，TiKV 支持外部一致的分布式事务。协处理器（Coprocessor）支持：与 HBase 类似，TiKV 实现了支持分布式计算的协处理器框架，用于支持计算下推操作。与 TiDB 无缝协同 ：TiKV 和 TiDB 强强联合，构建了一个具有高水平扩展能力、支持一致性事务、融合传统关系型数据库和 NoSQL 优势特性的 NewSQL 数据库解决方案。 四、架构
1. 设计目标
a. 高性能KV存储引擎
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53ba0d724ef5490e39410a1d16a73d83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec64b6097a58d5d6857603fd3638cc16/" rel="bookmark">
			2023最新版Android studio安装入门教程（非常详细）从零基础入门到精通，看完这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
JDK安装与配置
一、下载JDK
二、JDK安装
三、JDK的环境配置
四、JDK的配置验证
Android studio安装
Android studio连接手机真机调试（以华为鸿蒙为例）
一、新建一个android项目
二、进入项目面板
三、配置Android Studio
四、安装手机驱动程序
五、连接手机
六、运行程序
七、查看手机日志
JDK安装与配置 一、下载JDK 可以到官网进行下载：
输入下载地址：Software Download | Oracle
往下拉，看到Developer Downloads ，点击 java
点击 Java (JDK) for Developers
选择你想要下载的jdk版本
点击 JDK Downloads ，往下拉，
(有可能会提示先登录账号，才能下载。没账号的可以注册一个)
我的系统是Windows的 64位，个人偏爱压缩版，
所以选择了jdk-14.0.1_windows-x64_bin.zip
(压缩版的话，放到指定的目录下，直接解压出来就行了)
二、JDK安装 傻瓜式的下一步即可！
1、双击运行安装包
2、修改JDK安装目录
3、根据提示安装完成，这就完成jdk安装了，可以直接点关闭了。
三、JDK的环境配置 1、“我的电脑”右键→属性→高级系统设置→环境变量
2、点击“新建”，新建系统变量JAVA_HOME，值为JDK安装根目录
3、编辑PATH变量，将刚刚新建的JAVA_HOME变量加上bin目录设置到PATH中
【 %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; 】
四、JDK的配置验证 cmd打开命令行，输入java -version
最后是一个关键点 输入 javac ，看看有没有相关信息
Android studio安装 下载Android studio
Android studio安装的前提是必须保证安装了jdk1.8版本以上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec64b6097a58d5d6857603fd3638cc16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f86bdcdfdd6786af562584dc942ae06/" rel="bookmark">
			EndNote20下载安装教程（非常详细）从零基础入门到精通，看完这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件下载
软件：EndNote版本：20
语言：简体中文
大小：110.46M
安装环境：Win11/Win10/Win8/Win7硬件要求：CPU@2.0GHz 内存@4G(或更高）下载通道①百度网盘丨下载链接：
https://pan.baidu.com/s/1wVtELpTVfQ2H8qwGUW9PEw?pwd=6789
提取码：6789
软件介绍
EndNote 是一款主流文献管理软件，有数以百万计的研究人员、学生和图书管理员使用，它能方便地扩展任何语言参考书目，允许你创建任意大小的文献库。通过EndNote可进行文献批量下载和管理、写作论文时添加索引、分析某篇文献的引文索引、分析某领域或者学术课题的经典文献地位等。
安装步骤
1.鼠标右击【EndNote 20】压缩包（win11及以上系统需先点击“显示更多选项”）【解压到 EndNote 20 】。
2.打开解压后的文件夹，双击运行【EN20Inst】。
3.点击【Next】。
4.点击【Accept】。
5.点击【Next】。
6.选择【I accept……】，点击【Next】。
7.点击【Next】。
8.①点击【Browse】②修改路径地址中的第一个字符C可更改安装位置（如：把C改为D软件将安装到D盘）③点击【OK】。
9.点击【Next】。
10.点击【Next】。
11.安装中……
12.点击【Finish】。
13.创建桌面快捷方式：①点击桌面任务栏中的【开始图标】&gt;点击【所有应用】②将【EnNote】图标拖到电脑桌面。
14.双击桌面【EndNote】图标启动软件。
15.点击【Ignore This】。
16.选择【I accept……】，点击【Next】。
17.点击【Create a new library】。
18.选择文件保存的位置（如：D盘），点击【保存】。
19.点击右上角【X】退出。
20.打开安装包解压后的【EndNote 20】文件夹，鼠标右击【EndNotechs】选择【复制】。
21.打开安装路径根目录【D:\Program Files (x86)\EndNote 20】（若你安装在其它盘，打开你设置的磁盘根目录），鼠标右击空白处选择【粘贴】。
22.①鼠标右击粘贴后的【EndNotechs】（win11系统需先点击“显示更多选项”）②选择【发送到】③选择【桌面快捷方式】。
23.双击桌面【EndNotechs-快捷方式】图标启动软件（若需要启动英文版，双击“EndNote”图标启动）。
24.安装成功！
题外话 初入计算机行业的人或者大学计算机相关专业毕业生，很多因缺少实战经验，就业处处碰壁。下面我们来看两组数据：
2023届全国高校毕业生预计达到1158万人，就业形势严峻；
国家网络安全宣传周公布的数据显示，到2027年我国网络安全人员缺口将达327万。
一方面是每年应届毕业生就业形势严峻，一方面是网络安全人才百万缺口。
6月9日，麦可思研究2023年版就业蓝皮书（包括《2023年中国本科生就业报告》《2023年中国高职生就业报告》）正式发布。
2022届大学毕业生月收入较高的前10个专业
本科计算机类、高职自动化类专业月收入较高。2022届本科计算机类、高职自动化类专业月收入分别为6863元、5339元。其中，本科计算机类专业起薪与2021届基本持平，高职自动化类月收入增长明显，2022届反超铁道运输类专业（5295元）排在第一位。
具体看专业，2022届本科月收入较高的专业是信息安全（7579元）。对比2018届，电子科学与技术、自动化等与人工智能相关的本科专业表现不俗，较五年前起薪涨幅均达到了19%。数据科学与大数据技术虽是近年新增专业但表现亮眼，已跻身2022届本科毕业生毕业半年后月收入较高专业前三。五年前唯一进入本科高薪榜前10的人文社科类专业——法语已退出前10之列。
“没有网络安全就没有国家安全”。当前，网络安全已被提升到国家战略的高度，成为影响国家安全、社会稳定至关重要的因素之一。
网络安全行业特点 1、就业薪资非常高，涨薪快 2021年猎聘网发布网络安全行业就业薪资行业最高人均33.77万！
2、人才缺口大，就业机会多
2019年9月18日《中华人民共和国中央人民政府》官方网站发表：我国网络空间安全人才 需求140万人，而全国各大学校每年培养的人员不到1.5W人。猎聘网《2021年上半年网络安全报告》预测2027年网安人才需求300W，现在从事网络安全行业的从业人员只有10W人。
行业发展空间大，岗位非常多
网络安全行业产业以来，随即新增加了几十个网络安全行业岗位︰网络安全专家、网络安全分析师、安全咨询师、网络安全工程师、安全架构师、安全运维工程师、渗透工程师、信息安全管理员、数据安全工程师、网络安全运营工程师、网络安全应急响应工程师、数据鉴定师、网络安全产品经理、网络安全服务工程师、网络安全培训师、网络安全审计员、威胁情报分析工程师、灾难恢复专业人员、实战攻防专业人员…
职业增值潜力大
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f86bdcdfdd6786af562584dc942ae06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d18cb9e5a2493e744fca2cb56ad2398d/" rel="bookmark">
			【Java】Java8 将List转换为用逗号隔开的字符串的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.使用谷歌的Joiner转换2.使用lambda表达式遍历集合3.直接使用stream流实现4.使用for循环遍历集合 1.使用谷歌的Joiner转换 public static &lt;T&gt; String parseListToStr(List&lt;T&gt; list){ String result = Joiner.on(",").join(list); return result; } 2.使用lambda表达式遍历集合 public static &lt;T&gt; String parseListToStr2(List&lt;T&gt; list){ StringBuffer sb = new StringBuffer(); list.stream().forEach(str-&gt;{ sb.append(str).append(","); }); sb.deleteCharAt(sb.length()-1); return sb.toString(); } 3.直接使用stream流实现 public static &lt;T&gt; String parseListToStr3(List&lt;T&gt; list){ String result = list.stream().map(String::valueOf).collect(Collectors.joining(",")); return result; } 4.使用for循环遍历集合 public static &lt;T&gt; String parseListToStr(List&lt;T&gt; list){ StringBuffer sb = new StringBuffer(); if(listIsNotNull(list)) { for(int i=0;i&lt;=list.size()-1;i++){ if(i&lt;list.size()-1){ sb.append(list.get(i) + ","); }else { sb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d18cb9e5a2493e744fca2cb56ad2398d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/55/">«</a>
	<span class="pagination__item pagination__item--current">56/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/57/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>