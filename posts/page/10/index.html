<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c5ac626c5c77adac1018bad454229b0/" rel="bookmark">
			仰望星空，也要鲜花与掌声
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在各种武侠文化的渲染下，我从小萌生了一种奇怪的想法，就是弄任何事都要偷偷摸摸的钻研，最后惊艳所有人；因此无论是大学还是毕业工作中，很多事情都希望做到“完美”再同步给“外界”，如以下几个例子
学习SpringMVC，想说等学透了再输出文章博客做某项任务，想说等拿到自己觉得合格的成果再同步给上级做技术分享，由于想做得好一些，既要…又要…还要…等等，结果导致分享无限
…
但是以上种种最终都没有达到很好的效果，如何算学透？你永远都不会彻底准备好的，就像董宇辉说的，给你三年你准备不好高考，就算给你三十年也准备不好的，最好的方式是边学边输出博客，通过输出来反思自己所学的内容；拿到任务要定期汇报给上级，我们所生活的世界是一个错综复杂的体系，也许过了几天这个任务已经变得“不重要”了，你如果早点与上级汇报与沟通就会早点把更多精力投入到更有用的任务上，或者说在得到上级的帮助，你可以更加快速的攻克这个任务，再不济你也要让上级知道这些事情的进展等。以上种种思考的模式是一种单向的方式，个人认为是不太健康的，理想的情况下应该是一个螺旋环状的结构，如下图
通过上图可以看到，从开始到结束那么一长条线都是一条孤独的路，如果只是自己埋头从头到尾去做一件事很有可能是枯燥、痛苦的事，这会导致很多人中途放弃，这也是上面几个例子失败的最主要根因；因此再来看第二种方式，在有目标之后的第一件事是先将其拆分为独立的一个个小任务，每攻克一个小点时，我们都可以适当做下输出，无论是输出技术博客、还是技术分享或者是其他方式，在接受到“鲜花与掌声”后我们会拥有更多的动力对下一个“堡垒”发起进攻，在接受“鲜花与掌声”的同时，我们也能听到更多的反馈，例如可能会评论说你对IOC的某个理解是错误的、领导觉得你的这个方案一可能存在某个缺陷等等，那么在这个基础下，你在开启下一个环是有个更多的“注意事项”，这能让你更有条不紊的朝着最终目标前行。
除了大目标要进行拆分，我们也要重视外界反馈的“作用”，曾经我觉得别人的看法不重要，等自己把大目标做好了大家对你的看法自然而然的就会变好。这些也没错但是大部分人都是普通人，都是“俗人”，被人表扬会开心，收到点赞会兴奋，因此我们要合理的应用自己的“人性”的这个利器。不用害怕暴露自己，收到正向反馈就把它当作是“燃料”继续驱动自己朝着目标方向飞行，收到负面反馈就适当反思有没有需要调整的，如果不是就不用太过在意。下面是我绘制的“个体”与“外界”的关系图
封闭世界指的是我们每个人的内心世界，而无限宇宙指的是除了自身以外的一切事物。
封闭世界
优点
这个世界的任何东西只要你想可以随便改动当进入心流状态时，你大脑会运转得飞快，一些困难点可以快速攻克以及快速弄明白很多知识点 缺点
孤独偏执 无限宇宙
优点
反馈 缺点
嘈杂过多无法改变的事物 通过简单比较并不是想表达哪个更优秀，而是我们个体应该跟这个世界“链接”起来，借用“无限宇宙”中强大的反馈能力驱动“封闭世界”，消除由于孤独带来的执行力低下，修正由于个体视角所带来的偏执，同时再利用好“封闭世界”的优点。可以让我们就像驱使一辆无限燃料的飞船，有条不紊的朝着我们梦想的星球飞去～
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e86ba93fedf5ac95c23bd26af052ee3/" rel="bookmark">
			漫画演绎策略设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 本篇主要通过一小篇漫画的形式给大家讲讲策略模式，由于策略模式本身不是很难，这里就不花太多的言辞描述了，一起看漫画吧
普通设计 从前有一个妈妈，她有一个叛逆的儿子，妈妈每天除了上下班就是要教育儿子，上下班的内容是固定的，现在每天唯一负责并且可能会变的就是教育儿子的方式，那么我们应该如何设计呢
对应的流程图如上，这种设计的代码实现如下
public class Main { public static void main(String[] args) { People mother = new People("妈妈", 31); People son = new People("冤种儿子", 12); System.out.println(mother.name+"上班...."); System.out.println(mother.name+"下班...."); System.out.println(mother.name+"准备教育"); System.out.println("弯腰拿拖鞋"); System.out.println("拿拖鞋抽"+son.name); System.out.println("把拖鞋放回脚下"); System.out.println(mother.name+"教育结束"); } } 输出如下
妈妈上班.... 妈妈下班.... 妈妈准备教育 弯腰拿拖鞋 拿拖鞋抽冤种儿子 把拖鞋放回脚下 妈妈教育结束 如果教育方式变成衣架要怎么改呢？
如上图可以看到就是将教育的流程改变下，对应的代码如下
public class Main { public static void main(String[] args) { People mother = new People("妈妈", 31); People son = new People("冤种儿子", 12); System.out.println(mother.name+"上班...."); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e86ba93fedf5ac95c23bd26af052ee3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c8758c9f9a0cf3112c65f31625f76d4/" rel="bookmark">
			RK3566环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：vmware16，ubuntu 18.04
安装依赖库：
sudo apt-get install repo git ssh make gcc libssl-dev liblz4-tool expect g++ patchelf chrpath gawk texinfo chrpath diffstat binfmt-support qemu-user-static live-build bison flex fakeroot cmake unzip device-tree-compiler python-pip ncurses-dev python-pyelftools 获取SDK前需要安装
sudo apt update sudo apt install -y repo git python 下载完成后先验证一下MD5码
md5sum rk356x_linux_release_v1.3.0b_20221213_split_dir/*firefly_split*
# 解压 mkdir ~/proj/ cd ~/proj/ cat path/to/rk356x_linux_release_v1.3.0b_20221213_split_dir/*firefly_split* | tar -xzv # 导出数据 rk3566@ubuntu:~/proj$ cd rk356x_linux_release_v1.3.0b_20221213/ rk3566@ubuntu:~/proj/rk356x_linux_release_v1.3.0b_20221213$ .repo/repo/repo sync -l # 同步
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c8758c9f9a0cf3112c65f31625f76d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3126a0be93fcb8fbc4be5910415459b0/" rel="bookmark">
			Flutter使用stack来实现悬浮UI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 stack特性示例 stack特性 在Flutter中，你可以使用Stack和Positioned来创建悬浮 UI。Stack允许你将多个小部件叠放在一起，而Positioned则用于定位小部件在Stack中的位置。
示例 以下是一个简单的示例，演示如何创建一个悬浮按钮：
import 'package:flutter/material.dart'; void main() { runApp(MyApp()); } class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( home: Scaffold( appBar: AppBar( title: Text('Floating UI Example'), ), body: MyFloatingUI(), ), ); } } class MyFloatingUI extends StatefulWidget { @override _MyFloatingUIState createState() =&gt; _MyFloatingUIState(); } class _MyFloatingUIState extends State&lt;MyFloatingUI&gt; { bool isFloatingUIVisible = false; @override Widget build(BuildContext context) { return Stack( children: [ // Your main content goes here Center( child: Text( 'Main Content', style: TextStyle(fontSize: 20), ), ), // Floating UI Visibility( visible: isFloatingUIVisible, child: Positioned( bottom: 16, right: 16, child: FloatingActionButton( onPressed: () { // Handle floating button tap print('Floating Button Tapped'); }, child: Icon(Icons.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3126a0be93fcb8fbc4be5910415459b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/294235428f711abae8baccfe482e861e/" rel="bookmark">
			bat批处理脚本:生成spec文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ::生成spec文件 @echo off ::中文支持 chcp 65001 ::窗口标题 title 生成spec文件 ::开始执行脚本 echo *************** echo 请输入spec文件名称[不需要输入后缀 eg:abc] set /p filename=: echo 输入任意键开始生成... pause pyi-makespec %filename%.py echo 生成成功！请打开%filename%.spec文件进行配置！ pause 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/740379641f20599ac9ed564cf9a404e3/" rel="bookmark">
			面试常见的排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、各个排序算法的时间复杂度
一、归并排序 归并思想
思想:将两个有序的数组合并成一个有序的数组。
第一步
将数组进行分解，当分解成单个元素为一组的时候才是组内有序的。
第二步
将两两有序的数组进行合并，将两个有序数组合并成一个有序数组。重复第二步，直至排序完成。
合并的步骤:先申请两数组合并后那么大小的空间，然后将两个排好序的数组逐一进行比较，往申请空间里面放。
递归前进:自己调用自己的语句
递归回退:return,通过递归结束条件进行回退
在哪里调用的函数，函数的返回值就返回到哪里
#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; void Merg(vector&lt;int&gt;&amp; vec, int L, int mid, int R) { vector&lt;int&gt;temp(R-L+1); int i = L, j = mid + 1; int index = 0; while (i &lt;= mid &amp;&amp; j &lt;= R) { if (vec[i] &lt; vec[j]) { temp[index++] = vec[i++]; } else { temp[index++] = vec[j++]; }	} while (i &lt;= mid) { temp[index++] = vec[i++]; }	while (j &lt;= R) { temp[index++] = vec[j++]; } //把排好序的放回原数组 index = L; for (auto it:temp) { vec[index++] = it; } } void Merg_sort(vector&lt;int&gt;&amp; vec, int L, int R) { if (L &gt;= R) return; int mid = (R - L) / 2 + L; Merg_sort(vec, L, mid); Merg_sort(vec, mid + 1, R); //合并 Merg(vec, L, mid, R); } int main() { int num; vector&lt;int&gt;vec; while (cin &gt;&gt; num) { vec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/740379641f20599ac9ed564cf9a404e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/269579be6ab0dbec78160a0aae6dc8f0/" rel="bookmark">
			U盘删除的文件不在回收站如何恢复？教你3个简单方法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“我在清理u盘的时候误删了一些重要的文件，想将这些文件恢复时才发现它们不在回收站中了。还有办法恢复吗？” 在数字化时代，u盘的作用渐渐显现。很多用户会将重要的数据直接保存在u盘中。但在使用u盘的过程中，不可避免会有数据的丢失和误删。
如果u盘删除的文件不在回收站如何恢复呢？正确的u盘文件恢复方法已经为大家总结好了，有需要的用户记好这几个方法！
方法一：借助备份恢复u盘数据 U盘误删除的文件怎么找回？如果对u盘中的重要文件进行过备份，借助备份恢复u盘数据是比较简单的方法。
步骤1：找到备份的文件，将文件复制到电脑上；
步骤2：确保文件能正常打开和查看后，可将文件再次复制到u盘上。
提示：u盘中的文件一旦被覆盖，找回会比较困难，因此要确保文件的完整性。 方法二：借助以前的版本恢复u盘数据 如果发现u盘删除后回收站里没有相关的文件，还有什么方法恢复u盘数据吗？可以尝试使用以前的版本对数据进行恢复。
步骤1：将u盘与电脑进行连接，完成连接后，找到相应的文件夹；
步骤2：单击右键选择【属性】，然后点击【以前的版本】，找到文件被删除之前的版本，即可恢复文件。
方法三：借助专业软件后恢复u盘数据 部分对电脑操作不是很熟悉的用户，如果想要恢复比较重要的u盘文件，但发现u盘删除的文件不在回收站如何恢复呢？比较有效的一种方法是借助专业的数据恢复软件完成数据的恢复。推荐使用 数 据 蛙 恢 复 专 家 。
这款软件的扫描和恢复功能都是比较实用的，用户借助该软件对数据进行扫描，成功的概率会比较大。且软件支持多种类型数据的扫描和恢复。如果需要使用软件，可以先下载软件，并按下方的步骤进行操作。
操作环境： 演示机型：华硕X8AE43In-SL 系统版本：Windows 10 软件版本：数 据 蛙 恢 复 专 家 3.2.12 步骤1：将u盘与电脑进行连接，并运行软件，新用户可先点击【免费试用】；
步骤2：勾选上需要恢复的文件类型，并勾选上u盘所在的盘符，然后点击【扫描】；
步骤3：等待初次扫描完成后，点击【按类型查看】或【按路径查看】，可先对部分数据进行查看，若此次扫描中没有找到相应的文件，点击【深度扫描】；
步骤4：深度扫描会对u盘进行全面的扫描，用户耐心等待扫描结束后，可再次对扫描结果进行查看，在结果较多的情况下，建议直接借助【筛选器】对文件快速定位，完成文件选择后，点击【导出】。
提示：导出的保存位置不要选择与原位置相同，否则数据覆盖可能会导致恢复失败。 U盘为我们的数据存储带来了很多的方便。在处理U盘上的数据时，用户要谨慎操作，并注意备份重要文件。u盘删除的文件不在回收站如何恢复？上文小编已经给大家分享了几个简单又有效的方法，如果需要恢复数据，可以现在就进行尝试啦！
往期推荐：
已删除数据恢复，4个简单有效方法分享！https://blog.csdn.net/datarecover/article/details/135473526?spm=1001.2014.3001.5501
电脑文件误删除如何恢复？这3个实用方法记得收藏！https://blog.csdn.net/datarecover/article/details/135472024?spm=1001.2014.3001.5501
无线网卡怎么连接台式电脑？正确操作步骤分享！https://blog.csdn.net/datarecover/article/details/135472608?spm=1001.2014.3001.5501
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be8fa09f7ae16938c34b9892eefcf772/" rel="bookmark">
			算法与数据结构--最小生成树算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.应用的场景 类似于这种最小成本问题，实际上就是计算加权图把所有点连起来权重之和最小值的时候是怎么连接的。类似的问题还有最短耗时之类的问题。
二.最小生成树的定义 生成树：
图的生成树是它的一颗含有其所有顶点的无环连通子图。
【简单说就是所有顶点连接在一起，并且没有环。
因此有n个顶点，n-1的边】
最小生成树：
所有生成树中权值(树中所有边的权重之和)最小的生成树。
解决之类问题实际上就是求出最小生成树，并计算它的权值之和。
三.如何构建最小生成树 目前有两种经典的生成最小生成树的算法，Prim算法和Kruskal算法。两种算法都是基于贪婪算法的思想。
1.Kruskal算法 【1】将所有边按照权值从小到大进行排序。
【2】依次取出每条边，如果边的两个节点分别位于两棵树上，则将这两棵树合并成为一棵树；如果两个节点位于同一棵树上，则忽略这条边。
【3】等到所有的边都遍历结束之后，如果所有的生成树可以合并成一棵生成树，那么它就是我们需要寻找的最小生成树，反之则没有最小生成树。
#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; // 结构体表示一条边 struct Edge { int src, dest, weight;//起点，终点，权值 }; // 结构体表示并查集 struct DisjointSet { //parent 数组存储每个元素的父节点，rank 数组存储每个集合的秩。 vector&lt;int&gt; parent, rank; // 构造函数，初始化并查集 DisjointSet(int n) { parent.resize(n); rank.resize(n, 0); // 初始化每个元素为一个独立的集合，父节点指向自身 for (int i = 0; i &lt; n; i++) { parent[i] = i; } } // 查找一个元素所属的集合，使用路径压缩优化 int find(int x) { if (parent[x] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be8fa09f7ae16938c34b9892eefcf772/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cbb3bb29486e03a018e226d4d70055b/" rel="bookmark">
			Hive事务表转换为非事务表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：hive3.1.0
由于建表时默认会建为非事务表
CREATE TABLE bucket_text_table2(column1 string,column2 string,column3 int) CLUSTERED BY (column3) into 5 BUCKETS STORED AS TEXTFILE;
执行完成后，查看默认建表语句：
+----------------------------------------------------+ | createtab_stmt | +----------------------------------------------------+ | CREATE TABLE `bucket_text_table2`( | | `column1` string, | | `column2` string, | | `column3` int) | | CLUSTERED BY ( | | column3) | | INTO 5 BUCKETS | | ROW FORMAT SERDE | | 'org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe' | | STORED AS INPUTFORMAT | | 'org.apache.hadoop.mapred.TextInputFormat' | | OUTPUTFORMAT | | 'org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cbb3bb29486e03a018e226d4d70055b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba69eb9d86b18c6e0b627af1683a291b/" rel="bookmark">
			计算机算法贪心算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		贪心算法（Greedy Algorithm）是一种常见的算法思想，它在每一步选择当前状态下最优的解决方案，从而希望最终能够达到全局最优解。
贪心算法的基本思路是每一步都选择当前状态下的局部最优解，而忽略了当前选择所带来的影响，因此并不一定能够得到全局最优解。然而，在某些问题上，贪心算法确实能够得到最优解，而且贪心算法通常具有较高的执行效率。
经典的贪心算法问题包括：
钱币找零：给定若干面额不同的硬币，找零时使用最少的硬币数目。区间调度：给定若干活动的开始时间和结束时间，安排活动使得参与的活动数最大。最小生成树：在一个连通加权图中找到一棵包含全部顶点且边的权值之和最小的生成树。 贪心算法在解决一些最优化问题时特别有用，但是并不适用于所有类型的问题。因此，在使用贪心算法时，需要仔细分析问题的特性，以确定是否适合采用贪心策略。
如您有关于贪心算法的具体问题或需求，欢迎随时与我交流讨论。
#include &lt;stdio.h&gt; #include &lt;limits.h&gt; #define V 5 // 图中顶点的数量 int minKey(int key[], bool mstSet[]) { int min = INT_MAX, min_index; for (int v = 0; v &lt; V; v++) if (mstSet[v] == false &amp;&amp; key[v] &lt; min) min = key[v], min_index = v; return min_index; } void printMST(int parent[], int n, int graph[V][V]) { printf("Edge \tWeight\n"); for (int i = 1; i &lt; V; i++) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba69eb9d86b18c6e0b627af1683a291b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f150f1f19ceaa8a9ea87470627f74c5/" rel="bookmark">
			ubuntu重启后会修改挂载路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		磁盘被手动挂载之后都必须把挂载信息写入/etc/fstab这个文件中，否则下次开机启动时仍然需要重新挂载。
系统开机时会主动读取/etc/fstab这个文件中的内容，根据文件里面的配置挂载磁盘。这样我们只需要将磁盘的挂载信息写入这个文件中我们就不需要每次开机启动之后手动进行挂载了。
在Linux下用vim敲入:wq退出保存时，出现 E212：无法打开并写入文件 的错误提示。
【1】 将文件保存到用户目录下，再改变所有者，然后移动到配置目录下，步骤如下：
1） 保存退出时用 :wq ! ~/tmp/file.conf
2）su切换到root用户，将file.conf改变属主， chown root file.conf
3）移动配置文件到目标目录，mv file.conf [pathname]
【2】 第二种解决办法相对比较简便
保存文件时用 : w ! sudo tee %
tee 用于读取输入文件，同时保存
%表示当前编辑文件
（不过这种方法有个要求就是当前编辑用户必须在 sudoers这个文件中，这也是执行sudo命令的要求）
vim 编辑文件器
指令：i插入 u撤销 x删除 v选择字符 y复制 yy复制当前行 p粘贴 dd删除光标所在行 wq! 强制写入(只限文件拥有者)
esc退出： :w保存 :wq保存并退出
:q!强退
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38e0a2e0b0841fc267cc83f42a3b992d/" rel="bookmark">
			[足式机器人]Part2 Dr. CAN学习笔记-Advanced控制理论 Ch04-3Phase Portrait相图，相轨迹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文仅供学习使用
本文参考：
B站：DR_CAN
Dr. CAN学习笔记-Advanced控制理论 Ch04-3Phase Portrait相图，相轨迹 1. 1-D2. 2-D3. General Form4. Summary 1. 1-D 2. 2-D 3. General Form 4. Summary 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f4687a91f8c60631d9175fd199de176/" rel="bookmark">
			bat批处理脚本：spec文件生成exe文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ::spec文件生成exe文件(必须存在配置好了的spec文件） @echo off ::中文支持 chcp 65001 ::窗口标题 title .spec文件生成.exe文件 ::开始执行脚本 :input_file_path echo *************** echo 请输入spec文件位置[./aaa.spec] set /p filename=: if exist "%filename%" ( echo 已找到脚本-%filename% @echo: ) else ( echo 不存在脚本-%filename% @echo: ::跳转重新输入文件名 goto input_file_path ) echo 输入任意键开始生成... pause pyinstaller %filename% pause 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44f737dcfcf29002586de9fe6d9c65be/" rel="bookmark">
			Spring的@Configuration注解和@Component 注解的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 @Configuration 和 @Component 是 Spring 框架中的两个注解，它们在功能和用途上有一些区别。
@Configuration 注解用于标记一个类为配置类，表示这个类中定义了一些配置信息，例如 bean 的定义、依赖关系等。通常，我们会在配置类中使用 @Bean 注解来定义 bean。配置类可以被 Spring 容器扫描到，并根据其中的配置信息来创建相应的 bean。配置类是 Spring Boot 中用于替代传统的 XML 配置文件的一种方式。@Component 注解用于标记一个类为组件类，表示这个类是一个可被 Spring 容器管理的组件。被 @Component 注解标记的类会被 Spring 容器扫描到，并创建相应的 bean。通常，我们会使用更具体的子注解（如 @Service、@Repository、@Controller 等）来标记具体类型的组件类，以便更好地表达其功能和用途。在关系上，@Configuration 注解实际上是一个特殊的 @Component 注解。打开@Configuration注解源码会发现底层使用了@Component注解描述，表示@Configuration注解是一个增强版的@Component注解。也就是说，@Configuration 注解本质上是 @Component 注解的衍生注解。它们都能够将一个类标记为组件类，并被 Spring 容器扫描到。不同之处在于，@Configuration 注解还具有特殊的语义，表示这个类是一个配置类，用于定义一些配置信息。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7356a860628b12ff1c9ca677019e38f5/" rel="bookmark">
			基于SSM框架的餐饮工业化管理系统--毕业设计（带源码带数据库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、说明二、项目简介三、系统模块四、技术选型五、环境搭建：六、部分截图1、数据库结构2、菜单管理：3、生产原料5、订单的管理6、采购计划7、仓库管理8、产品控制9、设备管理10、角色管理11、门店管理12、合同管理13、目录结构 七、运行视频 一、说明 餐饮工业化管理系统(Catering industrialization management)
二、项目简介 餐饮工业化管理系统是针对食品生产行业设计的一款专业生产管理软件.
三、系统模块 研发系统订单系统信息计划系统 ★采购管理系统库存管理系统生产管理系统质量控制系统设备管理系统数据监控系统角色管理系统 四、技术选型 1、后端
核心框架：Spring Framework视图框架：Spring MVC持久层框架：MyBatis日志管理：Log4j工具类：Apache Commons、FastJson 2、前端
JS框架：jQueryCSS框架：Bootstrap客户端验证：JQuery-html5Validate数据表格：jqGrid树结构控件：jQuery zTree日期控件： LayDate图表控件：echarts 五、环境搭建： 1、jdk1.8
2、maven 3.8
3、编译工具：IDEA2018
4、Mysql5.7
六、部分截图 1、数据库结构 2、菜单管理： 3、生产原料 添加检索功能
5、订单的管理 可以输出pdf或者表格数据
临时订单
6、采购计划 7、仓库管理 8、产品控制 9、设备管理 10、角色管理 11、门店管理 12、合同管理 合同订单管理
13、目录结构 七、运行视频 餐饮工业化后台管理系统
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84e3b9af687c82fcbee286651f2d95ba/" rel="bookmark">
			算法：给你一个整数数组 nums 和一个整数k，请你统计并返回该数组中和为 k 的子数组的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java面试题目录
算法：给你一个整数数组 nums 和一个整数k，请你统计并返回该数组中和为 k 的子数组的个数
使用前缀和来实现。在保存累加和的数组preSum中，找坐标大的元素与坐标小的元素差值正好为k的个数。
leecode地址：. - 力扣（LeetCode）
直接在力扣找了个写好的答案。
public class Solution { public int subarraySum(int[] nums, int k) { int len = nums.length; // 计算前缀和数组 int[] preSum = new int[len + 1]; preSum[0] = 0; for (int i = 0; i &lt; len; i++) { preSum[i + 1] = preSum[i] + nums[i]; } int count = 0; for (int left = 0; left &lt; len; left++) { for (int right = left; right &lt; len; right++) { // 区间和 [left.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84e3b9af687c82fcbee286651f2d95ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43db544023ff0d77aea8bda37371e4b8/" rel="bookmark">
			引领行业赛道！聚铭网络入选安全419年度策划“2023年教育行业优秀解决方案”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，由网络安全产业资讯媒体安全419主办的《年度策划》2023年度优秀解决方案评选结果正式出炉，聚铭网络「高校大日志留存分析及实名审计解决方案」从众多参选方案中脱颖而出，被评为“教育行业优秀解决方案”，以硬核实力引领行业赛道。
媒体推荐理由： 近年来高校网络安全事件频发，行业主管机构对高校的网络安全建设重视程度也在不断提高，聚铭的高校大日志留存分析及实名审计解决方案，是一种专门针对高校场景设计的综合性技术方案，应对的是各项法律法规合规标准要求，该方案优势点在于可支持国内外多家厂商千余种异构设备的高兼容性采集范式化处理，并且拥有多所高校日志处理实践案例。
据悉，安全419《年度策划》2023年度优秀解决方案评选是由已连续开展两届的细分赛道优秀企业评选升级而来，旨在分行业呈现目前的市场需求点、客户痛点、厂商对应能力、落地表现以及真实的市场验证情况，并推荐甲方视角下面向不同重点行业的优质安全解决方案。活动自推出以来，共收到我国网络安全行业上百家企业的报名资料，在经过安全419编辑部历时一个月的内部综合评审后甄选出各个行业的优秀方案。此次，聚铭网络入选“教育行业优秀解决方案”，再一次彰显了公司在教育行业侧的实力与影响力，以及在高校客群中的优质口碑。
当前，信息安全贯穿智慧校园总体框架多个层面的安全保障建设，《国家网络安全法》和《等保2.0》对高校日志合规留存和审计分析提出了严格的法规要求。聚铭网络「高校大日志留存分析及实名审计解决方案」通过在高校单位出口路由器交换旁路部署，实现日志集中采集、存储，保证数据的完整性，并针对DHCP、NET等场景与实名认证系统联动，当出现威胁事件时，可通过账号实名认证溯源具体人员，进一步落实监管合规要求。
注：高校大日志方案部署示意图
方案优势： 存储超级优：大幅减少满足6个月日志合规留存规定所需存储空间，实测压缩比3：1。解决合规存储要求，避免了客户花费大代价单独购买存储设备的需求。
吞吐超级大：可以支撑每秒10W条以上超大日志量场景，完美应对出口大日志量场景下高性能采集处理要求。支持动态集群热扩容。
溯源超级快：10亿级日志秒级查询，满足网监溯源需求，提高海量日志下查询效率。
兼容超级全：开放兼容收集主流网络、安全、服务器、中间件等厂商1000+日志标准化，快速识别各类资产日志，实现合规审计的日志分析要求。
截止目前，该方案已经陆续在河海大学、南京师范大学、江苏开放大学、大连理工、武汉大学、华北电力大学、渤海大学等国内数百家高校单位成功落地实践，极大地满足了学校在合规审计、威胁防御等方面的建设需求，为高校网络空间和数据资产安全提供强有力的保障。
作为国内领先的安全运营商，未来，聚铭网络将始终坚持以客户为中心，以创新为驱动，致力于为教育行业提供全面、高效、可靠的安全解决方案，引领教育行业安全之巅。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55e128838c952ec6308fc0f980ac99c1/" rel="bookmark">
			基于ARIMA模型对未来全国进出口总额的预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
1 绪 论 1
1.1 研究背景及意义 1
1.2 国内外研究现状 2
1.3 正文的主要内容与组织结构 3
1.3.1 基本框架 3
1.3.2 研究的重点以及措施 3
1.3.3预期成果 3
2 理论基础 4
2.1 ARIMA模型的基本介绍 4
2.1.1 AR模型 4
2.1.2 MA模型 4
2.1.3 ARIMA模型有三个参数:p,d,q 5
2.1.4 ARIMA模型的优缺点 6
3 ARIMA模型的建立 7
3.1 ARIMA模型原理 7
3.2 数据准备 7 3.3 数据分析 7
4 ARIMA模型预测 10
4.1 差分d的确定 10
4.2模型识别和定阶 11
4.3残差的检验 12
4.4模型的适应性检验 13
4.5模型的预测 14
5 模型的比较 18
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55e128838c952ec6308fc0f980ac99c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7914ea3cd736c0f2b7c2f0a0bf419ad5/" rel="bookmark">
			基于ssm的旅游网页开发与设计&#43;jsp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收藏关注不迷路，源码文章末
文章目录 前言一、项目介绍二、开发环境三、功能介绍四、核心代码五、效果图六、文章目录 前言 信息数据从传统到当代，是一直在变革当中，突如其来的互联网让传统的信息管理看到了革命性的曙光，因为传统信息管理从时效性，还是安全性，还是可操作性等各个方面来讲，遇到了互联网时代才发现能补上自古以来的短板，有效的提升管理的效率和业务水平。传统的管理模式，时间越久管理的内容越多，也需要更多的人来对数据进行整理，并且数据的汇总查询方面效率也是极其的低下，并且数据安全方面永远不会保证安全性能。结合数据内容管理的种种缺点，在互联网时代都可以得到有效的补充。结合先进的互联网技术，开发符合需求的软件，让数据内容管理不管是从录入的及时性，查看的及时性还是汇总分析的及时性，都能让正确率达到最高，管理更加的科学和便捷。本次开发的旅游网站实现了字典管理、论坛管理、公告信息管理、景点管理、景点收藏管理、景点留言管理、用户管理、管理员管理等功能。系统用到了关系型数据库中王者MySql作为系统的数据库，有效的对数据进行安全的存储，有效的备份，对数据可靠性方面得到了保证。并且程序也具备程序需求的所有功能，使得操作性还是安全性都大大提高，让旅游网站更能从理念走到现实，确确实实的让人们提升信息处理效率。
关键字：信息管理，时效性，安全性，MySql
一、项目介绍 此次旅游网站的开发，需要用到的知识不仅涉及到界面设计与功能设计方面的知识，还需要涉及到数据库与编程语言上面的知识，这些知识点对于一个即将毕业的学生来说，一是为了巩固在校所学相关专业知识；二是为了让学生学会如何将专业理论知识运用于现实软件的开发过程；三是让学生明白知识是无穷无尽的，要时刻明白活到老学到老的真正含义，让学生要养成时刻学习的习惯，同时也要相信通过此次程序的开发，会让学生对于专业知识的理解与软件开发水平的提高有着极大的帮助。
二、开发环境 开发语言：Java
框架：ssm
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven
————————————————
三、功能介绍 在管理员功能模块确定下来的基础上，对管理员各个功能进行设计，确定管理员功能的详细模块。绘制的管理员功能结构见下图。
图4.2 管理员功能结构图
四、核心代码 部分代码：
package com.example.controller; import cn.hutool.core.util.StrUtil; import cn.hutool.crypto.SecureUtil; import com.example.common.Result; import com.example.common.ResultCode; import com.example.entity.Caiwu; import com.example.exception.CustomException; import com.example.service.CaiwuService; import com.example.utils.MapWrapperUtils; import com.example.utils.jwt.JwtUtil; import com.example.vo.CaiwuVo; import org.springframework.beans.BeanUtils; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import javax.servlet.http.HttpServletRequest; import java.util.HashMap; import java.util.List; import java.util.Map; @RestController @RequestMapping(value = "/caiwu") public class CaiwuController { @Resource private CaiwuService caiwuService; @PostMapping public Result&lt;Caiwu&gt; add(@RequestBody CaiwuVo caiwu) { caiwuService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7914ea3cd736c0f2b7c2f0a0bf419ad5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5bc1050a0ea2b92c8fa52828d4f9c04/" rel="bookmark">
			Excel如何插入行？4个简单方法轻松完成！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“我在使用Excel表格工作时，需要插入一些行来填写数据。但是我不知道应该如何操作，有没有朋友可以支支招呀？” Excel是办公室工作中不可或缺的工具，它强大的数据处理能力使得工作变得高效。因此很多用户在使用电脑时或许都会用到Excel。Excel如何插入行呢？这是很多用户都比较关心的问题。
在对数据进行处理时，插入行的功能会给用户带来很多的便利。下文将给大家介绍几种简单有效的方法，帮助大家提提升工作效率！
方法一：借助右键菜单插入行 在表格中间增加一行怎么加？如果用户在编辑表格时要插入某一行以填充数据，可以直接借助右键菜单来插入。
步骤1：打开Excel，定位到想要插入行的位置；
步骤2：右键点击行号，选择【插入】，点击【整行】；
步骤3：Excel会自动在你点击的位置插入一行。
方法二：使用快捷键插入行 如何在电子表格中增加行？快捷键的使用可以提高效率。这也是最快速的一种方法，用户可以这样操作。
步骤1：打开Excel，定位到想要插入行的位置；
步骤2：按住【Ctrl】键，同时使用鼠标左键拖动行号；
步骤3：当出现黑色边框时，放开鼠标左键，即可在当前位置插入一行。
提示：同时按住 【Alt】和【H】，然后按【V】，也可以快速插入行。 方法三：使用菜单栏插入行 在Excel中，菜单栏是个比较实用的工具。Excel如何插入行？借助菜单栏插入行也是比较快速有效的方法。
步骤1：定位到需要插入行的位置，点击菜单栏的【开始】；
步骤2：在【单元格】组中，点击【插入】，并在下拉菜单中选择【插入工作表行】，Excel将会插入新的一行。
方法四：使用左侧位置插入行 在使用Excel时，如何在表格中插入行？在数据比较多的情况下，用户可在最左侧位置进行行的插入。操作如下。
步骤1：打开Excel，定位到想要插入行的位置；
步骤2：定位到该行的左侧；
步骤3：单击右键点击【插入】，即可插入行。
在日常使用Excel时，掌握简单的Excel使用技巧有利于提升我们的工作效率的。本文给大家分享了Excel如何插入行的简单方法，这些方法都很实用，有需要的用户快来试试吧！
往期推荐：
无线网卡怎么连接台式电脑？正确操作步骤分享！https://blog.csdn.net/datarecover/article/details/135472608?spm=1001.2014.3001.5501
电脑文件误删除如何恢复？这3个实用方法记得收藏！https://blog.csdn.net/datarecover/article/details/135472024?spm=1001.2014.3001.5501
已删除数据恢复，4个简单有效方法分享！https://blog.csdn.net/datarecover/article/details/135473526?spm=1001.2014.3001.5501
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0be7fe944348abba9e35325bbf4807d7/" rel="bookmark">
			C#，字符串匹配（模式搜索）KMP算法的源代码与数据可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		D.E.Knuth
J.H.Morris
一、KMP算法 KMP 算法（Knuth-Morris-Pratt 算法）是其中一个著名的、传统的字符串匹配算法，效率比较高。
KMP算法由D.E.Knuth，J.H.Morris和V.R.Pratt在 Brute-Force算法的基础上提出的模式匹配的改进算法。因此人们称它为“克努特—莫里斯—普拉特算法”，简称KMP算法。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。Brute- Force算法在模式串中有多个字符和主串中的若干个连续字符比较都相等，但最后一个字符比较不相等时，主串的比较位置需要回退。KMP算法在上述情况下,主串位置不需要回退，从而可以大大提高效率。
要点：实现方法主要是通过一个LPS（Longest Proper Suffix）数组实现，数组本身包含了模式串的局部匹配信息。
KMP算法的时间复杂度为O(m+n) 。
有些人以为讲清楚了，其实没有。
学习算法，阅读文字浪费时间，看图及阅读代码最好。
下载Visual Studio 2022工程包https://download.csdn.net/download/beijinghorn/85090446
二、运行效果 本文源代码的运行效果：
三、核心代码 using System; using System.Collections; using System.Collections.Generic; namespace Legalsoft.Truffer.Algorithm { /// &lt;summary&gt; /// 字符串匹配（模式搜索）算法集锦 /// &lt;/summary&gt; public static partial class PatternSearch { /// &lt;summary&gt; /// 字符串匹配的KMP算法 /// &lt;/summary&gt; /// &lt;param name="text"&gt;&lt;/param&gt; /// &lt;param name="pattern"&gt;&lt;/param&gt; public static List&lt;int&gt; KMP_Search(string text,string pattern) { List&lt;int&gt; matchs = new List&lt;int&gt;(); int M = pattern.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0be7fe944348abba9e35325bbf4807d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22251adf228f200d7c0d78425aee55c6/" rel="bookmark">
			java基于SSM的蛋糕甜品店管理系统的设计与开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收藏关注不迷路，源码文章末
文章目录 前言一、项目介绍二、开发环境三、功能介绍四、核心代码五、效果图六、文章目录 前言 如今，科学技术的力量越来越强大，通过结合较为成熟的计算机技术，促进了学校、医疗、商城等许多行业领域的发展。为了顺应时代的变化，各行业结合互联网、人工智能等技术，纷纷开展了管理信息化建设。传统的甜品店信息管理模式，主要以人工记录的方式统计和存储商品信息，这种管理模式容易丢失信息，并且不方便管理人员更新和查询相关数据。相比于传统管理模式，信息化管理模式主要使用计算机存储和管理相关信息记录，操作简单便捷，并且具体较强的灵活性，容易对数据实现查询和更新操作，有利于相关人员在同等时间内，完成更多的工作，并且能够尽可能的减少工作人员发生失误的概率。在idea集成开发平台上，蛋糕甜品店管理系统采用了B/S开发结构模式，并且通过使用Java语言编写相关代码，设计系统功能模块，MySQL数据库设计数据表格，存储商品信息，Tomcat服务器发布系统网址，处理请求和响应消息。本系统的开发，改进企业管理人员的工作模式，有利于简化工作流程，加快工作进度，提高信息处理效率。
关键词：蛋糕甜品店管理；Java语言；B/S架构；MySQL数据库
一、项目介绍 需求分析是以用户的使用需求为基础，将用户的真实期望转化为实际的功能设计过程。本人主要通过问卷调查、现场调研的方式，对系统进行需求分析。本系统的使用对象主要分为管理员角色和用户角色，管理员主要的角色职能是管理甜品店相关的信息记录，用户主要的角色功能是查看和保存个人信息记录。需求分析主要包括功能需求、业务需求、性能需求、安全需求等内容。
其中，功能需求是指为了能够满足不同使用者的具体使用需求，调研人员据此分析系统实际的功能需求，开发人员再根据分析结果，详细的设计系统的主要功能模块，系统主要的功能需求包括用户管理、商品信息管理、订单管理等模块。
业务需求是指为了更快更好地实现对商品信息的交互和管理过程，相关人员将整个蛋糕甜品店管理系统的分解为多个便于实现的子功能模块，每个子功能模块的设计就能够实现相应的系统业务流程，系统主要的业务需求包括用户注册、登录、查询、更新等流程。
性能需求是指为了保证系统的实现能够满足设计期望，以及避免因为不合格的系统性能而造成的软件或网络问题，而对系统进行组件检查、网络服务、信息存储、处理器运作、响应时间等必要的性能需求分析。如果系统在运行过程中，组件检查正常、网络服务正常、信息存储安全、处理器运作正常、响应时间快，那么可以说本次所设计的系统是具备良好的使用性能的。
安全需求是指为了查验所设计的系统是否具有安全性和可靠性，而对系统进行健壮性、可用性、防病毒、数据保密等必要的安全需求分析。由系统授权的合法的用户正常的访问本系统，并且可以选择查看、修改相关信息记录，但是未经授权的非法用户是不能随意修改信息记录。
二、开发环境 开发语言：Java
框架：ssm
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven
————————————————
三、功能介绍 本系统的整体开发过程是采用B/S结构模式而开展的，通过使用Java语言、MySQL数据库等技术设计系统相关的功能，功能设计完成后，可以通过使用浏览器，运行和使用系统。通过需求分析的相关内容，可以基本上确定系统的主要功能设计。基于SSM的蛋糕甜品店管理系统的使用对象主要分为管理员角色和用户角色，主要的功能需求包括用户管理、商品信息管理、订单管理等。系统总体功能设计图如图4-1所示。
图4-1系统总体功能设计图
四、核心代码 部分代码：
package com.example.controller; import cn.hutool.core.util.StrUtil; import cn.hutool.crypto.SecureUtil; import com.example.common.Result; import com.example.common.ResultCode; import com.example.entity.Caiwu; import com.example.exception.CustomException; import com.example.service.CaiwuService; import com.example.utils.MapWrapperUtils; import com.example.utils.jwt.JwtUtil; import com.example.vo.CaiwuVo; import org.springframework.beans.BeanUtils; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import javax.servlet.http.HttpServletRequest; import java.util.HashMap; import java.util.List; import java.util.Map; @RestController @RequestMapping(value = "/caiwu") public class CaiwuController { @Resource private CaiwuService caiwuService; @PostMapping public Result&lt;Caiwu&gt; add(@RequestBody CaiwuVo caiwu) { caiwuService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22251adf228f200d7c0d78425aee55c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fae6e00e352597c92561b853d27e1ea3/" rel="bookmark">
			科学和统计分析软件GraphPad Prism mac介绍说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GraphPad Prism for Mac是一款科学和统计分析软件，旨在帮助研究者、科学家和学生更轻松地处理和可视化数据。
GraphPad Prism for Mac是一款功能强大、易于使用的科学和统计分析软件，适用于各种类型的数据处理和可视化需求。无论您是进行基础研究、临床试验还是学术写作，GraphPad Prism for Mac都能为您提供全面而简便的解决方案。
苹果：graphpad prism for Mac(专业医学绘图工具) v10.1.1中文版
Win：GraphPad Prism 9(数据分析软件)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a3a92b54970b8a671ca64601f435524/" rel="bookmark">
			设计模式面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 面向对象设计 封装：隐藏内部实现继承：复用现有代码多态：改写对象行为 设计模式关键在于分解和抽象;
设计模式的主要目的是易于变化
面向对象设计原则–比设计模式更加重要 违背了设计原则，设计模式是错误的。
依赖倒置原则(DIP)开放封闭原则(OCP)单一职责原则(SRP) 工厂方法模式 模式定义 工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。
模式结构和时序图 Product：抽象产品ConcreteProduct：具体产品Factory：抽象工厂ConcreteFactory：具体工厂 模式结构：
工厂方法模式的优点 工厂无需关心细节，甚至无序知道具体产品的类名称。工厂角色和茶农角色的多态性设计是工厂方法模式的关键。它能确定创建的产品对象；创建细节完全封装在具体工厂内部。所有的具体工厂类都具有同一抽象父类。添加新产品时，只需要添加一个具体的工厂和具体产品就可以了，系统的扩展性较好，完全符合”开闭原则”。 工厂模式的缺点 添加新产品时，需要编写新的具体产品类，而且需要提供与之赌赢的工厂类，系统中类的个数将成对增加，会带来额外的编译开销。由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 单例模式 模式定义 单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。
单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。
模式分析 单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。
在单例模式的实现过程中，需要注意如下三点：
单例类的构造函数为私有；提供一个自身的静态私有成员变量；提供一个公有的静态工厂方法。 优点 提供了对唯一实例的受控访问。允许可变数目的实例。 缺点 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。单例类的职责过重，在一定程度上违背了“单一职责原则”。 适用环境 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。 观察者模式 上述模式中，需要使用明显的调用函数，来进行两个对象之间的通信，但是能否建立一种关系，使得一个对象发生改变时，自动通知其它对象，做出反映。这种模式就是观察者模式
模式定义 观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式。
观察者模式是一种对象行为型模式。
模式结构 观察者模式包含如下角色：
Subject: 目标主题：跟踪所有观察者，并提供添加和删除观察者的接口。ConcreteSubject: 具体目标；将有关状态存入各 ConcreteObserver 对象。当具体主题的状态发生任何更改时，通知所有观察者。Observer: 观察者：为所有的具体观察者定义一个接口，在得到主题的通知时进行自我更新。ConcreteObserver: 具体观察者；实现 Observer 所要求的更新接口，以便使本身的状态与主题的状态相协调。 类图如下：
优缺点 优点：
观察者和被观察者是抽象耦合的 缺点：
如果一个被观察者对象有很多的直接和间接的观察者，将所有的观察者都通知到会花费很多时间。如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 适用情况 一个对象必须通知其他对象，而并不知道这些对象是谁。 代理模式 模式定义 代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。
模式结构 代理模式包含角色如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a3a92b54970b8a671ca64601f435524/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff78fe88ac55fc0fac732360644e005e/" rel="bookmark">
			批量执行指定路径下除__init__.py的.py文件加密为.pyd的bat脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 @echo off ::中文支持 chcp 65001 ::窗口标题 title .py文件加密为.pyd ::开始执行脚本 echo *************** echo 加密脚本文件名是否在当前目录[./encryptpy.py]? set /p input=1.yes 2.no: set filename=encryptpy.py if %input% equ 2 ( echo 请输入新的加密脚本的位置与名称[eg:C:\Users\Desktop\encryptpy.py] set /p filename=: ) if exist "%filename%" ( echo 已找到脚本-%filename% ) else ( echo 不存在脚本-%filename% echo 输入任意键退出窗口... pause EXIT ) pause echo 输入任意键开始执行脚本... python %filename% build_ext --inplace echo 输入任意键退出窗口... pause 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61093e1acdf407a0cf84f9a4a4ae0146/" rel="bookmark">
			正则表达式、文件访问（Python实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、主要目的： 1.了解正则表达式的基本概念和处理过程。
2.掌握使用正则表达式模块 Re 进行字符串处理的方法。
3.了解文件的基本概念和类型。
4.掌握在 Python 中访问文本文件的方法和步骤。
5.熟悉在 Python 中访问二进制文件的方法和步骤。
二、主要内容和结果展示： 1.编写一个程序，使用正则表达式校验输入的手机号是否正确。 import re str = input("请输入手机号：") reg = r"\b1[3-9]\d{9}\b" res = re.match(reg, str, re.M) if res: print("校验输入的手机号正确。") else: print("校验输入的手机号不正确。") 2.编写一个程序，使用正则表达式校验输入的车牌号是否正确。 import re str = input("请输入车牌号：") reg1 = r"\b[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-HJ-NP-Z][A-HJ-NP-Z0-9]{5}\b" flag1 = re.findall(r"[A-HJ-NP-Z]",str) if len(flag1) &gt; 3: print("校验输入的车牌号不正确。") exit(0) reg2 = r"\b[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领]\d{6}\b" reg3 = r"\b[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-HJ-NP-Z]\d{5}\b" reg4 = r"\b[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领]\d{5}[A-HJ-NP-Z]\b" reg5 = r"\b[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-HJ-NP-Z]{2}\d{4}\b" res1 = re.match(reg1, str, re.M) res2 = re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61093e1acdf407a0cf84f9a4a4ae0146/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abb8060c7db2ccba4a3c61d14affaee6/" rel="bookmark">
			SpringMVC之注解配置SpringMVC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习的最大理由是想摆脱平庸，早一天就多一份人生的精彩；迟一天就多一天平庸的困扰。各位小伙伴，如果您：
想系统/深入学习某技术知识点…
一个人摸索学习很难坚持，想组团高效学习…
想写博客但无从下手，急需写作干货注入能量…
热爱写作，愿意让自己成为更好的人…
文章目录 前言一、创建初始化类，代替web.xml二、创建SpringConfig配置类，代替spring的配置文件三、创建WebConfig配置类，代替SpringMVC的配置文件四、测试功能总结 前言 使用配置类和注解代替web.xml和SpringMVC配置文件的功能
一、创建初始化类，代替web.xml
二、创建SpringConfig配置类，代替spring的配置文件
三、创建WebConfig配置类，代替SpringMVC的配置文件
四、测试功能
一、创建初始化类，代替web.xml 在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。
Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。
public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer { /** * 指定spring的配置类 * @return */ @Override protected Class&lt;?&gt;[] getRootConfigClasses() { return new Class[]{SpringConfig.class}; } /** * 指定SpringMVC的配置类 * @return */ @Override protected Class&lt;?&gt;[] getServletConfigClasses() { return new Class[]{WebConfig.class}; } /** * 指定DispatcherServlet的映射规则，即url-pattern * @return */ @Override protected String[] getServletMappings() { return new String[]{"/"}; } /** * 添加过滤器 * @return */ @Override protected Filter[] getServletFilters() { CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter(); encodingFilter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abb8060c7db2ccba4a3c61d14affaee6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b61e451815da21def67b7312e2a6f60/" rel="bookmark">
			android studio 打包签名apk时报kotlin版本错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息如下：
/Users/abbb/Library/Android/sdk/caches/transforms-3/572ca993caa0789f4046529ddf3eacd2/transformed/jetified-BaseRecyclerViewAdapterHelper-4.0.1/jars/classes.jar!/META-INF/com.github.CymChad.brvah.kotlin_module: Module was compiled with an incompatible version of Kotlin. The binary version of its metadata is 1.8.0, expected version is 1.6.0.
问题分析：
这个是引用的某些库用了不兼容的kotlin版本，尝试将kotlin插件关闭，发现无法启动studio了，然后在android studio的配置文件夹里面删除了禁用的kotlin插件才重新启动。
解决方法：
打开android studio设置 （setting）找到Kotlin Compiler
将对应版本改成需要的版本，顺利实现打包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c7ea122833099a391cf5525131c5c09/" rel="bookmark">
			设计模式之观察者模式【行为型模式】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档&gt; 学习的最大理由是想摆脱平庸，早一天就多一份人生的精彩；迟一天就多一天平庸的困扰。各位小伙伴，如果您：
想系统/深入学习某技术知识点…
一个人摸索学习很难坚持，想组团高效学习…
想写博客但无从下手，急需写作干货注入能量…
热爱写作，愿意让自己成为更好的人…
文章目录 前言一、概述二、结构三、案例实现四、优缺点五、使用场景六、JDK中提供的实现总结 前言 一、概述
二、结构
三、案例实现
四、优缺点
五、使用场景
六、JDK中提供的实现
一、概述 定义：
又被称为发布-订阅（Publish/Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。
二、结构 在观察者模式中有如下角色：
Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。 三、案例实现 【例】微信公众号
在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。
类图如下：
代码如下：
定义抽象观察者类，里面定义一个更新的方法
public interface Observer { void update(String message); } 定义具体观察者类，微信用户是观察者，里面实现了更新的方法
public class WeixinUser implements Observer { // 微信用户名 private String name; public WeixinUser(String name) { this.name = name; } @Override public void update(String message) { System.out.println(name + "-" + message); } } 定义抽象主题类，提供了attach、detach、notify三个方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c7ea122833099a391cf5525131c5c09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff6602bb1354f08b7fdda449c84227c4/" rel="bookmark">
			kafka: 基础概念回顾（生产者客户端和机架感知相关内容）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、kafka生产者客户端 在kafka体系结构中有如下几个重要的概念：
Producer：生产者，负责生产消息并投递到kafka broker的某个的分区中Consumer：消费者，负责消费kafka若干个分区中的消息Broker：kafka服务节点 1、整体架构：数据发送流程 （1）生产者
拦截器
生产者的拦截器可以在消息发送前做一些拦截工作对数据进行相应的处理，比如：消息过滤、消息内容修改等。 package org.apache.kafka.clients.producer; import org.apache.kafka.common.Configurable; public interface ProducerInterceptor&lt;K, V&gt; extends Configurable { //在将消息序列化和计算分区之前会调⽤该⽅法，⽤来对消息进⾏相应的定制化操作，如修改消息内容 public ProducerRecord&lt;K, V&gt; onSend(ProducerRecord&lt;K, V&gt; record); //在消息被应答之前或者消息发送失败时调⽤该⽅法，优先于⽤⼾设定的Callback之前执⾏，如统计消息发送成功或失败的次数 public void onAcknowledgement(RecordMetadata metadata, Exception exception); public void close(); } 序列化器分区器 二、kafka数据可靠性保证 1、LEO和HW 2、工作流程 3、Leader Epoch 三、粘性分区策略 四、机架感知 1、概念 2、机架感知分区分配策略 3、验证 （1）验证目标
机架感知特性将同⼀分区的副本分散到不同的机架上rack机制消费者可以消费到follower副本中的数据 （2）参数配置
broker端配置：
配置名：broker.rack=my-rack-id 解释：broker属于的rack 配置名：replica.selector.class 解释：ReplicaSelector实现类的全名，包括路径 (⽐如 RackAwareReplicaSelector 即按 rack id 指定消费) Client端配置：
client.rack
consumer端配置配置名：client.rack解释：这个参数需要和broker端指定的 broker.rack 相同，表⽰去哪个rack中获取数据。默认：null （3）环境准备：kafka集群
kafka实例数: 4两个kafka实例broker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff6602bb1354f08b7fdda449c84227c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abb56a2f3301c8febca1cb5a6fe3a8c2/" rel="bookmark">
			【flink番外篇】10、对有状态或及时 UDF 和自定义算子进行单元测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink 系列文章 一、Flink 专栏
Flink 专栏系统介绍某一知识点，并辅以具体的示例进行说明。
1、Flink 部署系列
本部分介绍Flink的部署、配置相关基础内容。
2、Flink基础系列
本部分介绍Flink 的基础部分，比如术语、架构、编程模型、编程指南、基本的datastream api用法、四大基石等内容。
3、Flik Table API和SQL基础系列
本部分介绍Flink Table Api和SQL的基本用法，比如Table API和SQL创建库、表用法、查询、窗口函数、catalog等等内容。
4、Flik Table API和SQL提高与应用系列
本部分是table api 和sql的应用部分，和实际的生产应用联系更为密切，以及有一定开发难度的内容。
5、Flink 监控系列
本部分和实际的运维、监控工作相关。
二、Flink 示例专栏
Flink 示例专栏是 Flink 专栏的辅助说明，一般不会介绍知识点的信息，更多的是提供一个一个可以具体使用的示例。本专栏不再分目录，通过链接即可看出介绍的内容。
两专栏的所有文章入口点击：Flink 系列文章汇总索引
文章目录 Flink 系列文章一、有状态算子单元测试的介绍1、DataStream API 测试依赖2、Table API 测试依赖3、maven依赖 二、flatmap function 单元测试1、OneInputStreamOperatorTestHarness使用示例2、KeyedOneInputStreamOperatorTestHarness使用示例 三、Process Function 单元测试1、OneInputStreamOperatorTestHarness使用示例2、ProcessFunctionTestHarnesses使用示例 本文着重介绍了Flink的有状态算子的单元测试，通过四个例子介绍了flatMap 和 process function的有状态单元测试。
如果需要了解更多内容，可以在本人Flink 专栏中了解更新系统的内容。
本文除了maven依赖外，没有其他依赖。
关于单元测试更详细内容参考：50、Flink的单元测试介绍及示例
一、有状态算子单元测试的介绍 对使用管理状态或定时器的用户自定义函数的功能测试会更加困难，因为它涉及到测试用户代码和 Flink 运行时的交互。 为此，Flink 提供了一组所谓的测试工具，可用于测试用户自定义函数和自定义算子：
OneInputStreamOperatorTestHarness (适用于 DataStream 上的算子)KeyedOneInputStreamOperatorTestHarness (适用于 KeyedStream 上的算子)TwoInputStreamOperatorTestHarness (f适用于两个 DataStream 的 ConnectedStreams 算子)KeyedTwoInputStreamOperatorTestHarness (适用于两个 KeyedStream 上的 ConnectedStreams 算子) 要使用测试工具，还需要一组其他的依赖项，比如DataStream和TableAPI的依赖。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abb56a2f3301c8febca1cb5a6fe3a8c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/154129f22a0398eb04c088843842e0d8/" rel="bookmark">
			NAL单元介绍（网络抽象层单元（Network Abstraction Layer Unit，简称NALU））（H.264/AVC或H.265/HEVC编码重要组成部分，用于封装视频数据和相关信息）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 视频流NAL单元（NALU）介绍一、H.264/AVC编码和NALU的关系H.264/AVC编码概述NALU在H.264/AVC中的作用 二、NALU的结构头部禁止位（forbidden_zero_bit）NAL引用指数（nal_ref_idc）NAL单元类型（nal_unit_type） 负载部分 三、NALU的类型帧内预测（I）片预测（P）片双向预测（B）片序列参数集（SPS）图像参数集（PPS） 四、NALU在实际应用中的处理 视频流NAL单元（NALU）介绍 网络抽象层单元（Network Abstraction Layer Unit，简称NALU）是H.264/AVC或H.265/HEVC编码的重要组成部分。它用于封装视频数据和相关信息，并在网络中传输这些封装的单元。
因为篇幅有限，我们能仅以H.264/AVC中的NALU作为案例来介绍。
一、H.264/AVC编码和NALU的关系 H.264/AVC编码概述 H.264/AVC是一种广泛使用的视频压缩标准，设计目标是以较低的比特率提供高质量的视频。它通过多种技术实现压缩效果，包括帧内预测、帧间预测、变换编码、环路滤波等。这些方法可以有效地减少视频的冗余信息，从而实现高效的压缩。
NALU在H.264/AVC中的作用 在H.264/AVC中，视频数据首先被转化为图像块，然后通过各种技术进行编码。编码后的数据再被封装到NALU中，以便于在网络中传输。
NALU不仅封装了编码后的视频数据，还包含了其他重要的信息，例如参数集、时间戳等。这些信息对于解码和播放视频至关重要。
二、NALU的结构 一个NALU由一个头部和一个负载部分组成。
头部 头部是NALU的固定部分，占1字节。它包含了以下信息：
禁止位（forbidden_zero_bit） 1比特，必须为0。
NAL引用指数（nal_ref_idc） 2比特，表示该NALU的重要性。值越大，重要性越高。
NAL单元类型（nal_unit_type） 5比特，表示NALU的类型。例如，类型可以是编码的视频数据、参数集等。
负载部分 负载部分是NALU的可变部分，包含了封装的数据。其内容取决于NALU的类型。
三、NALU的类型 在H.264/AVC中，定义了多种NALU的类型，以适应不同的应用场景。下面是一些常见的类型：
帧内预测（I）片 仅使用当前帧的信息进行编码。
预测（P）片 使用前一帧的信息进行编码。
双向预测（B）片 使用前一帧和后一帧的信息进行编码。
序列参数集（SPS） 包含了一组连续图像的编码信息。
图像参数集（PPS） 包含了一个图像的编码信息。
四、NALU在实际应用中的处理 在实际应用中，需要对NALU进行解析和打包等处理。这些处理需要理解NALU的结构和类型，以及如何在网络中传输NALU。
以下是一个简单的示例，说明如何使用Python解析NALU：
def parse_nalu(data): # 输入：二进制数据 # 输出：NALU的头部和负载部分 # 头部占1字节 header = data[0] # 解析头部信息 forbidden_zero_bit = header &gt;&gt; 7 nal_ref_idc = (header &gt;&gt; 5) &amp; 0x03 nal_unit_type = header &amp; 0x1F # 负载部分是除了头部之外的剩余数据 payload = data[1:] return forbidden_zero_bit, nal_ref_idc, nal_unit_type, payload 以上就是对视频流NAL单元（NALU）的详细介绍。总的来说，NALU是H.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/154129f22a0398eb04c088843842e0d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73a5bad27aa288b036b1dbe5eb7db772/" rel="bookmark">
			Jenkins流水线怎么做？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问CHAT：Jenkins流水线怎么做？
CHAT回复：Jenkins流水线是一种创建、测试和部署应用程序的方法。以下是为Jenkins创建流水线的步骤：
1. 安装Jenkins：首先你需要在你的服务器上安装Jenkins。这个过程可能会根据你的操作系统有所不同。
2. 安装必要的插件：为了使流水线工作，你需要安装一些Jenkins插件，如Pipeline，Git以及Docker等。
3. 创建一个新的流水线项目：登录到Jenkins后，点击"新建任务"或"New Item"，输入项目名称，并选择“流水线”。
4. 配置流水线：在配置页面，有一些参数你需要设置比如在哪个分支运行，何时触发构建等等。
5. 编写Jenkinsfile：Jenkinsfile就是包含Jenkins流水线（即构建）定义的文本文件。你可以选择将它直接在Jenkins界面中填写，或者指定源码管理系统中的路径。你需要使用Groovy语言来编写这个文件，它定义了一系列的阶段和每个阶段的操作。
6. 运行流水线：保存你的配置后，流水线就会开始进行，每个阶段完成按照Jenkinsfile的顺序执行。
7. 监控和优化：Jenkins提供了一些可视化工具来帮助你查看流水线的状态，你可以根据运行结果对流水线做出优化。
这只是一个基本的步骤，具体的配置可以根据项目的实际情况进行调整。
可以 注册体验下试试看吧，新手小白很容易上手哦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f11911d7877d27c332f3d6b91dbb456/" rel="bookmark">
			深度数据恢复，3个有效方法要掌握！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“我在电脑里保存了部分很重要的数据，但是不知道怎么就误删了它们，大家有什么比较简单的操作可以恢复这些被深度删除的数据吗？” 在数字化时代，我们的生活与工作已与数据紧密相连，这给我们带来了很多的便利。但不可否认的是，在使用电脑时，我们也经常会遇到数据丢失的情况。
如果想要进行深度数据恢复，却还不知道详细的操作方法，别着急！本文将给大家分享几个有效的恢复方法。
方法一：借助回收站完成数据恢复 电脑如何找回误删的文件？即使我们是对文件进行了深度删除，在回收站未被清空前，数据仍有可能保存在回收站中。如果想要进行深度数据恢复，建议用户先对回收站进行检查。这是最简单且方便的方法。
第1步：找到并进入电脑的【回收站】；
第2步：在回收站中对数据进行查看和搜索，找到需要恢复的文件后，可以直接将其拖出回收站完成还原。
方法二：借助以前的版本完成数据恢复 如果发现回收站里没有任何文件，用户还能通过什么方法找回深度删除的数据呢？可以尝试借助以前的版本完成数据恢复。但使用该方法的前提是曾开启过此功能。
第1步：找到需要恢复的文件被删除前所在的文件夹；
第2步：右键单击文件夹，进入其【属性】中，点击【以前的版本】；
第3步：选择需要还原的版本，点击【确定】，即有机会恢复深度删除的文件。
方法三：借助专业的软件完成数据恢复 如果数据是被电脑彻底删除，那么用户自行操作或许恢复的可能性并不大。那么深度数据恢复应该怎么做才正确呢？比较建议大家使用专业的数据恢复软件。数 据 蛙 恢 复 专 家 是个比较好的选择，它有简单实用的操作系统，用户只需要按照相应的部步骤进行操作，就有较大的机会找回删除的数据。
同时，软件支持深度扫描，会对磁盘进行深入全面的扫描，成功扫描到数据的概率也比较大。如果需要使用软件，可以参考下方的操作步骤。
操作环境： 演示机型：华硕TUF Dash FX516PM 系统版本：Windows10 软件版本：数 据 蛙 恢 复 专 家 3.2.12 第1步：进入正规网站下载相应版本的软件后，点击【免费试用】，可获得免费扫描的机会；
第2步：根据需要恢复的类型进行勾选，如果是新用户，建议全选，并依据文件删除前所在的磁盘选择要扫描的磁盘，完成后，点击【扫描】；
第3步：第一次是快速扫描，此时扫描到的数据是比较浅层的数据，用户可先查看是否有需要恢复的数据，如果没有，点击【深度扫描】后等待；
第4步：第二次扫描是深度扫描，软件会对整个磁盘进行全面且细致的扫描，等待扫描结束后，用户可以对扫描到的所有结果进行查看，如果文件太多，建议直接在【筛选器】中定位；
提示：在查看文件时，可以选择按类型查看，也可以选择按路径查看。 第5步：将所有需要恢复的文件选择完毕后，点击【导出】，并为其选择一个合适的保存位置，等待导出完毕即可查看。
请记住，数据恢复的成功与否很大程度上取决于你的行动速度和你在发现数据丢失后的行为。所以，一旦发现数据丢失，应尽快采取行动。同时，为了防止未来的数据丢失，定期备份你的数据并保护你的系统免受恶意软件的攻击是非常重要的。关于深度数据恢复的方法，就分享到这里啦！希望这些方法能够帮大家解决问题！
往期推荐：
如何将桌面文件放到D盘？这3个方法，亲测有效！https://blog.csdn.net/datarecover/article/details/135451143?spm=1001.2014.3001.5501
桌面图标变成白色文件？学会这4个方法，轻松解决！https://blog.csdn.net/datarecover/article/details/135450192?spm=1001.2014.3001.5501
无线网卡怎么连接台式电脑？正确操作步骤分享！https://blog.csdn.net/datarecover/article/details/135472608?spm=1001.2014.3001.5501
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b897edb1487dc2d0720317374e2dde0d/" rel="bookmark">
			Vscode 上安装 Compilot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub Copilot 是由 OpenAI 和 GitHub 开发的 AI 工具。其目的是通过自动完成代码来帮助开发人员使用集成开发环境 （IDE），如 Visual Studio Code。它目前仅作为技术预览版提供，因此只有已在候补名单上被接受的用户才能访问它。对于使用 Python、JavaScript、Ruby、Go、TypeScript 和 Ruby 编写代码的开发人员来说，它是最有效的。
前置条件
确保已经安装了Vscode，并且已经学会了科学上网
在 VS Code 上安装 GitHub Copilot 的过程 步骤1：打开 VS Code。在 Windows 上，您可以通过在 Windows 搜索栏中搜索它来执行此操作。
步骤2：单击“扩展”按钮，或使用快捷方式：Ctrl + Shift + X（在 Windows 上）、Cmd + Shift + X（在 Mac 上）。
步骤3：搜索扩展“GitHub Copilot”，然后单击“安装”。
步骤4：然后，系统可能会提示您输入 GitHub 凭据。单击“登录 GitHub”，然后单击“允许”并输入您的 GitHub 凭据。
步骤5：如果登录成功，应该能够在扩展列表中查看 GitHub Copilot 扩展。如果您尚未在 waitlist上，您可能会收到如下对话框：
单击“Join the waitlist”以添加到候补名单中以访问 GitHub Copilot。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74dbef4b50b5a64fe2fd8d19b53d3fc7/" rel="bookmark">
			“TPRI小魔盒”介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TPRI小魔盒是由西安热工研究院有限公司自主研发的前端低代码开发平台，旨在帮助开发者快速构建页面，提高开发效率。
TPRI小魔盒架构图
TPRI小魔盒页面
TPRI小魔盒的主要功能：
可视化编辑器：提供一个拖放界面，允许开发者直观地创建页面。模板库：提供各种预先设计好的模板，开发者导入后可以根据需要选择和修改。组件库：已经编写好的代码块，可以快速嵌入到页面中，例如按钮、文本框、复杂列表、文件上传等。数据交互：使用标准restful接口，可以与TPRI-DMP平台后端服务进行交互。实时预览：在编辑过程中，可以实时查看页面和功能。代码生成：生成可以直接使用和部署的代码。vscode插件：可以在开发工具中快速解析和导出。 TPRI-DMP是华能集团，西安热工研究院有限公司的自主产权的工业PaaS平台，专注于能源电力行业生产管理系统的开发和应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/831bd2b5c33adde4b3824f19ac474bf9/" rel="bookmark">
			基于CubeMX使用stm32f1系列的内部时钟中断捕获PWM高电平
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此项目需要使用两个系统内部时钟
CubeMX设置如下
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
然后就可以生成代码了
我使用的是Jlink RTT作为调试，因为主要做的是PWM高电平读取ADC值，具体步骤就不详细写明
在main函数外定义一个全局变量，来接收ADC的返回值
//adc值
uint16_t ADC_Value = 0;
//开启PWM输出方波
HAL_TIM_PWM_Start(&amp;htim1,TIM_CHANNEL_2);
//建议在使能中断前先清除中断标志位，因为是第一次开启也可以不清
__HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
//使能定时器1中断
HAL_TIM_Base_Start_IT(&amp;htim1);
中断回调函数代码
//定时器溢出中断回调函数 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { //判断中断源 if(htim-&gt;Instance == htim1.Instance) { //PWM触发中断	//清除标志位 __HAL_TIM_CLEAR_IT(&amp;htim2, TIM_IT_UPDATE); //使能定时器 2中断 HAL_TIM_Base_Start_IT(&amp;htim2); } else if(htim-&gt;Instance == htim2.Instance) { //定时器 2触发中断 //启动ADC进行检测 HAL_ADC_Start(&amp;hadc1); //判断检测是否成功 if(HAL_OK == HAL_ADC_PollForConversion(&amp;hadc1 , 10)) { //接收ADC的值 ADC_Value = HAL_ADC_GetValue(&amp;hadc1); } //结束一次ADC检测 HAL_ADC_Stop(&amp;hadc1); //使用JLink RTT输出ADC的值 SEGGER_RTT_printf(0,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/831bd2b5c33adde4b3824f19ac474bf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda07490ecd1afd56fc51eeb2f9e993c/" rel="bookmark">
			AVCC（AVC Configuration）NALU封装格式介绍（一种描述H.264视频流信息的封装格式，包含了视频编码的关键元数据，是大多是MP4 H.264视频流的NALU封装格式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：解码中的AnnexB和avcC两种分割数据方式
文章目录 AVCC封装格式介绍1. H.264 视频编码简介1.1. H.264概述1.2. H.264编码结构 2. AVCC封装格式2.1. AVCC结构1. 配置版本（configurationVersion）2. AVC Profile（AVCProfileIndication）3. 兼容性标志（profile_compatibility）4. AVC Level（AVCLevelIndication）5. 长度大小（lengthSizeMinusOne）6. SPS数量（numOfSequenceParameterSets）7. SPS集合（SequenceParameterSets）8. PPS数量（numOfPictureParameterSets）9. PPS集合（PictureParameterSets） 2.2. AVCC与NALU 3. 疑难技术点解析：SPS和PPS3.1. Sequence Parameter Set (SPS)3.2. Picture Parameter Set (PPS) 4. AVCC和其他封装格式4.1. AVCC vs Annex B 5. AVCC封装格式的应用6. 使用FFmpeg处理AVCC封装的视频数据6.1. 提取H.264原始流6.2. 将H.264原始流封装到MP4容器中 7. AVCC封装格式的优缺点7.1. 优点7.2. 缺点 8. 结论 AVCC封装格式介绍 AVCC (AVC Configuration) 是一种描述H.264视频流信息的格式，广泛用于MPEG-4和Flash视频中。这种封装方式使得解码器在处理视频数据之前能获取到关键的解码参数。
1. H.264 视频编码简介 在详细探讨AVCC封装格式之前，先了解一下H.264视频编码技术。
1.1. H.264概述 H.264是一种常见的视频编码标准，也被称为MPEG-4 Part 10，或AVC（Advanced Video Coding）。它广泛应用于各种网络环境，从低速互联网连接到高清电视播放。
1.2. H.264编码结构 H.264视频流由一个或多个NALU (Network Abstraction Layer Units) 组成。每个NALU都包含一段连续的视频数据。在传输或存储时，这些NALU可能以不同的方式被组合或封装。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cda07490ecd1afd56fc51eeb2f9e993c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d5e125a3f2fc66435594b7f27aba036/" rel="bookmark">
			安全防御之备份恢复技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着计算机和网络的不断普及，人们更多的通过网络来传递大量信息。在网络环境下，还有各种各样的病毒感染、系统故障、线路故障等，使得数据信息的安全无法得到保障。由于安全风险的动态性，安全不是绝对的，信息系统不可能保证不出现安全事故，因此，一旦出现安全事件造成信息系统中断或者数据丢失，如果事先采取了必要的备份准备并及时启用，能够最小程度的减少系统重构时间和对业务中断的影响。备份恢复技术是安全防御体系中的重要组成部分，旨在保护数据安全，防止数据丢失或损坏，提高企业的数据安全性和业务连续性水平。
一、备份恢复的基本概念 备份恢复的基本概念主要包括备份和恢复两个方面。备份是指将数据或系统进行复制和存储的过程，以便在数据丢失或损坏时能够从备份中恢复。
恢复则是指当数据或系统出现问题时，通过备份数据进行数据恢复或系统重建的过程。
二、备份恢复技术的分类 备份恢复技术有多种分类和应用场景，可以根据实际需求进行选择和应用。常见的备份恢复技术包括数据备份技术、灾难恢复技术、容灾技术、备份与恢复管理技术、数据归档技术和文件系统快照技术等。
数据备份技术：是指定期对重要数据或全部数据复制和存储，以防止数据丢失或损坏。数据备份可以分为完整备份、增量备份、差异备份等。灾难恢复技术：是指在发生灾难事件时，通过事先制定的灾难恢复计划和流程，快速恢复业务运行。灾难恢复技术包括数据备份、系统恢复、业务恢复等方面的内容。容灾技术：是指通过建立异地容灾中心，将重要数据实时或定时复制到容灾中心，确保在主中心发生故障时，数据仍能保持可用性和完整性。容灾技术包括数据同步、异步复制、数据验证等方面的内容。备份与恢复管理技术：是指定期对备份数据进行验证和测试，确保备份数据的可用性和完整性。同时，建立完善的备份与恢复管理制度，规范备份与恢复操作，确保备份和恢复工作的顺利进行。数据归档技术：是指将不再经常使用的数据迁移到归档设备上，以释放存储空间并降低管理成本。归档设备可以是磁带库、光盘库等。文件系统快照技术：是指利用文件系统快照技术，对文件系统进行快速备份。快照技术可以捕获文件系统在某一时刻的状态，以便在发生问题时迅速恢复数据。
这些技术可以根据实际需求进行选择和应用，以确保数据的完整性和可用性，提高企业的业务连续性水平，降低企业的风险和成本。 三、备份恢复的能力等级 系统备份恢复能力也是信息系统一种重要的安全能力。2007年国家针对备份恢复发布了国家标准《GB/T 20988-2007 信息安全技术 信息系统灾难恢复规范》，《规范》将灾难恢复能力划分为6级：
等级一：基本支持。要求数据备份系统能够保证每周至少进行一次数据备份，备份介质能够提供场外存放。对于备用数据处理系统和备用网络系统，没有具体要求。等级二：备用场地支持。在满足等级一的条件基础上，要求配备灾难恢复所需的部分数据处理设备，或灾难发生后能在预定时间内调配所需的数据处理设备到备用场地；要求配备部分通信线路和相应的网络设备，或灾难发生后能在预定时间内调配所需的通信线路和网络设备到备用场地。等级三：电子传输和设备支持。要求每天至少进行一次完全数据备份，备份介质场外存放，同时每天多次利用通信网络将关键数据定时批量传送至备用场地。配备灾难恢复所需的部分数据处理设备、通信线路和相应的网络设备。等级四：电子传输及完整设备支持。在等级三的基础上，要求配置灾难恢复所需的所有数据处理设备、通行线路和相应的网络设备，并且处于就绪或运行状态。等级五：实时数据传输及完整设备支持。除要求每天至少进行一次完全数据备份，备份介质场外存放外，还要求采用远程数据复制技术，利用通信网络将关键数据实时复制到备用场地。等级六：数据零丢失和远程集群支持。要求实现远程实时备份，数据零丢失；备用数据处理系统具备与生产数据处理系统一致的处理能力，应用软件是“集群的”，可实时无缝切换。 由此可见，灾难恢复能力等级越高，对于信息系统的保护效果越好，但同时成本也会急剧上升。
四、备份恢复的类型 备份恢复的基本原理是确保数据的完整性和可用性，防止数据丢失或损坏。在备份过程中，需要对重要数据或全部数据进行拷贝和存储，可以选择不同的备份策略，如完整备份、增量备份、差异备份等，以满足不同场景的需求。在恢复过程中，需要使用备份数据来恢复受损的数据或系统，确保业务能够正常运行。
备份通常可以分成下面的这三种类型：
1、完全备份 完全备份就是将系统中所有的数据都通过备份进程备份。完全备份需要的时间相比其他集中备份方式要长，但是故障发生时，恢复时间非常快。
2、差异备份 通常，系统管理员会每周定期作完全备份，在一周的其他时间针对与完全备份的差异部分作差异备份。
这种备份方法的恢复时间较长，我们不但要从全备份中恢复数据，还需要将每天的变化量恢复到系统中。
3、增量备份 增量备份是每周定期进行完全备份，每天增加备份当天的数据变化，对于备份时间，增量备份需要的时间最短，但是，回复时间较长且较为复杂。在恢复过程中，我们不但需要恢复第一次的完全备份，还需要使用每天变化量的备份，一次恢复一天的数据，直到最近的一次所做的增量备份为止。
五、数据备份的方式 1、远程镜像 远程镜像技术在主数据中心和数据备份中心之间的数据备份过程中使用。镜像是在两个或多个磁盘或磁盘子系统上产生同一个数据的镜像视图的信息存储过程，一个叫主镜像系统，另一个叫从镜像系统。按主从镜像存储系统所处的位置可分为本地镜像和远程镜像。远程镜像又叫远程复制，是容灾备份的核心技术，同时也是保持远程数据同步和实现灾难恢复的基础。远程镜像按请求镜像的主机是否需要远程镜像站点的确认信息，又可分为同步远程镜像和异步远程镜像。
同步远程镜像（同步复制技术）是指通过远程镜像软件，将本地数据以完全同步的方式复制到异地，每一本地的I/O事务均需等待远程复制的完成确认信息，方予以释放。同步镜像使远程拷贝总能与本地机要求复制的内容相匹配。当主站点出现故障时，用户的应用程序切换到备份的替代站点后，被镜像的远程副本可以保证业务继续执行而没有数据的丢失。但它存在往返传播造成延时较长的缺点，只限于在相对较近的距离上应用。
异步远程镜像（异步复制技术）保证在更新远程存储视图前完成向本地存储系统的基本I/O操作，而由本地存储系统提供给请求镜像主机的I/O操作完成确认信息。远程的数据复制是以后台同步的方式进行的，这使本地系统性能受到的影响很小，传输距离长（可达1000公里以上），对网络带宽要求小。但是，许多远程的从属存储子系统的写没有得到确认，当某种因素造成数据传输失败，可能出现数据一致性问题。为了解决这个问题，目前大多采用延迟复制的技术，即在确保本地数据完好无损后进行远程数据更新。
2、快照技术 快照是通过软件对要备份的磁盘子系统的数据快速扫描，建立一个要备份数据的快照逻辑单元号LUN和快照cache。在快速扫描时，把备份过程中即将要修改的数据块同时快速拷贝到快照cache中。
快照LUN是一组指针，它指向快照cache和磁盘子系统中不变的数据块（在备份过程中）。在正常业务进行的同时，利用快照LUN实现对原数据的一个完全的备份。它可使用户在正常业务不受影响的情况下（主要指容灾备份系统），实时提取当前在线业务数据。其“备份窗口”接近于零，可增加系统业务的连续性，为实现系统真正的7×24运转提供了保证。
3、互连技术 现有多种基于IP的SAN的远程数据容灾备份技术。它们是利用基于IP的SAN的互连协议，将主数据中心SAN中的信息通过现有的TCP/IP网络，远程复制到备援中心SAN中。早期方法多通过光纤通道FC连接两个SAN，存在实现成本高、设备的互操作性差、跨越的地理距离短（10公里）等缺点。
当备援中心存储的数据量过大时，可利用快照技术将其备份到磁带库或光盘库中。这种基于IP的SAN的远程容灾备份，可以跨越LAN、MAN和WAN，成本低、可扩展性好，具有广阔的发展前景。
基于IP的互连协议包括：FCIP、iFCP、Infiniband、iSCSI等。
六、备份恢复技术应用场景 备份恢复技术的应用场景有很多，以下是常见的一些场景：
数据丢失应用场景：包括人为操作失误、软件BUG、硬件故障、安全漏洞被入侵等情况，导致数据被误操作、部分或全部丢失。在这种情况下，备份恢复技术可以用来恢复丢失的数据。非数据丢失应用场景：包括特殊应用场景下基于时间点的数据恢复、开发测试环境数据库搭建、相同数据库的新环境搭建、数据库或数据迁移等情况。在这些情况下，备份恢复技术可以用来迁移数据或者在新的环境中快速搭建数据库。设备更换场景：当用户的设备损坏或丢失时，可以通过备份恢复技术将备份的数据导入到新设备中，恢复原有的应用程序和设置，避免了重新配置和下载应用的麻烦。数据迁移场景：当用户的设备升级或更换时，可以通过备份恢复技术将备份的数据迁移到新设备中，保留原有的数据和设置，提高用户的使用体验。 备份恢复技术的应用场景非常广泛，可以在各种情况下保护数据安全，降低风险和成本。根据实际需求选择适合的备份恢复技术，可以提高企业的数据安全性和业务连续性水平。
博客：http://xiejava.ishareread.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/288d703328abaa66cfbcfc8e846b9753/" rel="bookmark">
			【Proteus仿真】【Arduino单片机】汽车车窗除霜系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、功能简介二、软件设计三、实验现象联系作者 一、功能简介 本项目使用Proteus8仿真Arduino单片机控制器，使用LCD1602显示模块、光线传感器、DS18B20温度传感器、PCF8691 ADC模块、继电器加热模块等。
主要功能：
系统运行后，LCD1602显示温度和光线强度值；
当车窗光线强度低于一定值，且车窗温度低于一定值，车窗开启加热；当光线强度达到要求或者温度达到要求，关闭加热。
二、软件设计 /* 作者：嗨小易（技术QQ群：570487280） */ //系统数据获取 void sys_data_get(void) { static u8 i=0; while(1) { //温度获取 i++; if(i%10==0) sys_ctrl.temp=ds18b20_read_temperture(); //光线获取 sys_ctrl.light=analogRead(A0)/10; sys_ctrl.light=cal_map(sys_ctrl.light,0,103,0,99); break; }	} //系统数据显示 void sys_data_show(void) { u8 temp=0; while(1) { //温度显示 if(sys_ctrl.temp&gt;=0) { temp=sys_ctrl.temp; lcd1602_show_string(5,0," "); } else { temp=-sys_ctrl.temp; lcd1602_show_string(5,0,"-"); } lcd1602_show_nums(6,0,temp,2,0); //光线强度显示 lcd1602_show_nums(6,1,sys_ctrl.light,2,0);	break;	} } //系统功能控制 void sys_fun_ctrl(void) { //如果光线强度小于最大值 if(sys_ctrl.light&lt;LIGHT_MAX) { //如果加热温度小于最大值 if(sys_ctrl.temp&lt;TEMP_MAX) RELAY(0);//加热	//如果车窗温度很高，无需加热 else RELAY(1);//关闭加热	} //如果车窗光线很强，无需加热 else { RELAY(1);//关闭加热	}	} //应用控制程序 void app_ctrl_demo(void) { u8 i=10; sys_parm_init();//系统参数初始化 ctrl_pin_init(); lcd1602_init();//LCD1602初始化 DS18B20_Init(); //等待数据稳定 while(i--) { //温度获取 sys_ctrl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/288d703328abaa66cfbcfc8e846b9753/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e2e9030cf5da8981693443ff0a205eb/" rel="bookmark">
			Node.js和npm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 01_Node.js01.什么是 Node.js目标讲解小结 02.fs模块-读写文件目标讲解小结 03.path模块-路径处理目标讲解小结 04.案例-压缩前端html目标讲解小结 05.认识URL中的端口号目标讲解小结 06.http模块-创建Web服务目标讲解小结 07.案例-浏览时钟目标讲解小结 02_Node.js模块化知识点自测01.模块化简介目标讲解小结 02.ECMAScript标准-默认导出和导入目标讲解小结 03.ECMAScript标准-命名导出和导入目标讲解小结 04.包的概念目标讲解小结 05.npm软件包管理器目标讲解小结 06.npm安装所有依赖目标讲解小结 07.npm全局软件包-nodemon目标讲解小结 08.Node.js概念和常用命令总结目标讲解小结 01_Node.js 01.什么是 Node.js 目标 什么是 Node.js，有什么用，为何能独立执行 JS 代码，演示安装和执行 JS 文件内代码
讲解 Node.js 是一个独立的 JavaScript 运行环境，能独立执行 JS 代码，因为这个特点，它可以用来编写服务器后端的应用程序
Node.js 作用除了编写后端应用程序，也可以对前端代码进行压缩，转译，整合等等，提高前端开发和运行效率
Node.js 基于Chrome V8 引擎封装，独立执行 JS 代码，但是语法和浏览器环境的 V8 有所不同，没有 document 和 window 但是都支持 ECMAScript 标准的代码语法
想要得到 Node.js 需要把这个软件安装到电脑，在素材里有安装程序（window 和 mac 环境的）参考 PPT 默认下一步安装即可
Node.js 没有图形化界面，需要使用 cmd 终端命令行（利用一些命令来操控电脑执行某些程序软件）输入，node -v 检查是否安装成功
node -v 需求：新建 index.js 文件，编写打印代码和 for 循环打印 3 个 6
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e2e9030cf5da8981693443ff0a205eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a932ea1638aa583351b7a719b6c752f3/" rel="bookmark">
			【Proteus仿真】【Arduino单片机】智能感应温控风扇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、功能简介二、软件设计三、实验现象联系作者 一、功能简介 本项目使用Proteus8仿真Arduino单片机控制器，使用LCD1602液晶显示模块、DS18B20温度、按键、声光报警、L293D电机驱动等。
主要功能：
系统运行后，LCD1602显示传感器检测的温度值；
当红外传感器检测到有人信号时，
默认以自动模式运行，若按下K4键切换为手动模式，此时可以
通过K1和K2控制风扇加减速，风扇档位共5档（0-5）。当再次按下K4键切换为自动
模式；自动模式下，实时检测温度值，当温度高于上限且在2C范围内，以3档运行。
当温度高于上限且在4C范围内，以4档运行。当温度高于上限且在6C范围内，以5挡
运行。当温度高于上限且超过6C范围，以5档运行且蜂鸣器报警。
若温度在上下限范围内，风扇以2档运行。
若温度低于下限，风扇停止。
可通过K3键进入阈值设置，K1和K2调节。
当红外传感器未检测到有人信号时，风扇停止。
二、软件设计 /* 作者：嗨小易（技术QQ群：570487280） */ //系统数据显示 void sys_data_show(void) { u8 buf[5]; while(1) { //温度显示 buf[0]=sys_ctrl.temp/100+0x30; buf[1]=sys_ctrl.temp%100/10+0x30; buf[2]='.'; buf[3]=sys_ctrl.temp%100%10+0x30; buf[4]='\0'; lcd1602_show_string(3,0,buf); //温度阈值显示 lcd1602_show_nums(6,1,sys_ctrl.templ,2,0); lcd1602_show_nums(9,1,sys_ctrl.temph,2,0); //阈值闪烁指示 switch(sys_ctrl.mode) { case 1://温度下限 lcd1602_show_string(6,1," "); delay_ms(50); lcd1602_show_nums(6,1,sys_ctrl.templ,2,0); break; case 2://温度上限 lcd1602_show_string(9,1," "); delay_ms(50); lcd1602_show_nums(9,1,sys_ctrl.temph,2,0); break; } //档位显示 lcd1602_show_nums(10,0,sys_ctrl.gear,1,0); //手动状态显示 if(sys_ctrl.auto_flag)lcd1602_show_string(14,0,"SD"); else lcd1602_show_string(14,0,"Au"); //有无人检测信号显示 if(sys_ctrl.man==1)lcd1602_show_string(13,1,"Yes"); else lcd1602_show_string(13,1," No"); break;	} } //系统数据设置 void sys_data_set(void) { u8 key=0; key=key_scan(0); //自动手动模式设置 if(key==KEY4_PRESS) { sys_ctrl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a932ea1638aa583351b7a719b6c752f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44c25563313d16354d7932a41bebf533/" rel="bookmark">
			基于 InternLM 和 LangChain 搭建你的知识库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于 InternLM 和 LangChain 搭建你的知识库 大模型开发范式LLM的局限性：RAG 检索增强生成 LangChain简介构建向量数据库搭建知识库助手Web Demo部署环境配置下载 NLTK 相关资源下载本项目代码 大模型开发范式 LLM的局限性： 知识实效性受限：如何让LLM能够获得更新的知识专业能力有限：如何打造垂直领域大模型定制化成本高：如何打造个人专属的LLM应用 两种开发范式：
RAG 检索增强生成 LangChain简介 LangChain框架是一个开源工具，通过为各种LLM提供通用接口来简化应用程序的开发流程，帮助开发者自由构建LLM应用。
LangChain的核心组成模块：
链：将组件组合实现端到端应用，通过一个对象封装实现一系列LLM操作Eg.检索问答链：覆盖实现了GAR（增强检索生成）的全部流程
构建向量数据库 加载源文件
确定源文件类型，针对不同类型源文件选用不同的加载器，核心在于将带格式文本转化为无格式字符串文档分块
由于单个文档往往超过了模型上下文上限，我们需要对加载的文档进行切分
一般按字符串长度进行分割
可以手动控制分割块的长度和重叠区间的长度文档向量化
使用向量数据库来支持语义检索，需要将文档向量化存入向量数据库
可以使用任一一种Embedding模型来进行向量化
可以使用多种支持语义检索的向量数据库，一般使用轻量级的Chroma 搭建知识库助手 将InternLM接入LangChain
基于RAG的问答系统性能核心受限于：
检索精度Prompt性能
一些可能优化的点：检索方面： 基于语义进行分割，保证每一个chunk的语义完整给每个chunk生成概括性索引，检索时匹配索引 Prompt方面 迭代优化Prompt策略 Web Demo部署 有很多支持简易web部署的框架，如Gradio、Streamlit等
环境配置 在环境中安装运行 demo 所需要的依赖
# 升级pip python -m pip install --upgrade pip pip install modelscope==1.9.5 pip install transformers==4.35.2 pip install streamlit==1.24.0 pip install sentencepiece==0.1.99 pip install accelerate==0.24.1 在 /root 路径下新建目录 data，在目录下新建 download.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44c25563313d16354d7932a41bebf533/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eb63ebef58b2da37fc5f7b8ab988950/" rel="bookmark">
			盘点一个Python自动化办公的需求——一键批量插图到Excel指定单元格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“Python爬虫与数据挖掘”，进行关注
回复“书籍”即可获赠Python从入门到进阶共10本电子书
今
日
鸡
汤
读书好处心先觉，立雪深时道已传。
大家好，我是皮皮。
一、前言 前几天在Python白银交流群【上海新年人】问了一个Python自动化办公的问题，问题如下：大佬们，昨天我在做插入excel图片的时候想起一个需求，好像挺难办的，也蛮现实的。比如每个图片是有名称的，但在做excel的时候，能不能按照excel中的名称调用图片插入。就像下面这样子，插入在B列对应的名称边上。
相当于你现在的图片名称已经命名好了，你现在只需要插入到Excel中，图片名称（以单元格命名）所对应的那个单元格里边。单个插入很简单的，他自己也实现了，就是批量进行操作的时候，有些有心无力了。代码如下：
from openpyxl.drawing.image import Image pic_path = r'C:\Users\Administrator\Desktop\图片练习' wb = load_workbook(r'C:\Users\Administrator\Desktop\练习2.xlsx') ws = wb.active pic_list = [os.path.join(pic_path,i) for i in os.listdir(pic_path) if i.endswith('.jpg')] new_size = (90,90) num = 2 for i,pic in enumerate(pic_list,start=1): image = Image(pic) image.width,image.height = new_size ws.row_dimensions[num].height = 80 ws.column_dimensions['b'].width = 12 ws.add_image(image,'b' + str(num)) num += 2 wb.save(r'C:\Users\Administrator\Desktop\练习2.xlsx') 二、实现过程 这里【论草莓如何成为冻干莓】给了一个思路：仅用excel做，vba也可以的，就是名称匹配而已。我们这个是直接固定在单元格里，单元格多大，图片就多大。
后来【论草莓如何成为冻干莓】直接问到了这份代码：
顺利地解决了粉丝的问题。
需要一键批量插图到Excel指定单元格代码的小伙伴们可以找后台找我威信，加上后给你分享，万一你以后在工作这也遇到类似这样的需求的时候，也有备无患了。
三、总结 大家好，我是皮皮。这篇文章主要盘点了一个Pandas数据提取的问题，文中针对该问题，给出了具体的解析和代码实现，帮助粉丝顺利解决了问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eb63ebef58b2da37fc5f7b8ab988950/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ab37066d2c718501053e5276a292416/" rel="bookmark">
			第十九章 调用Callout Library函数 - 将 $ZF(-5) 与多个库和许多函数调用一起使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第十九章 调用Callout Library函数 - 将 $ZF(-5) 与多个库和许多函数调用一起使用将 `$ZF(-5)` 与多个库和许多函数调用一起使用 第十九章 调用Callout Library函数 - 将 $ZF(-5) 与多个库和许多函数调用一起使用 将 $ZF(-5) 与多个库和许多函数调用一起使用 Method GraphSomeData(loopsize As %Integer=100000) As %Status { // load libraries and get system-defined ID values set InputLibID = $ZF(-4,1,"c:\intersystems\iris\bin\inputlibrary.dll") set OutputLibID = $ZF(-4,1,"c:\intersystems\iris\bin\outputlibrary.dll") set fnGetData = $ZF(-4,3,InputLibID,"GetData") set fnAnalyzeData = $ZF(-4,3,OutputLibID,"AnalyzeData") set fnPlotPoint = $ZF(-4,3,OutputLibID,"PlotPoint") set fnWriteData = $ZF(-4,3,OutputLibID,"WriteData") // call functions from each library until we have 100000 good data items set count = 0 do { set datapoint = $ZF(-5,InputLibID,fnGetData) set normalized = $ZF(-5,OutputLibID,fnAnalyzeData,datapoint) if (normalized'="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ab37066d2c718501053e5276a292416/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c242c6b073beba498cbec4b226a5cfdd/" rel="bookmark">
			Ubuntu设置国内镜像源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 环境背景方法1：使用清华大学镜像源使用HTTP方式使用HTTPS方式 方法2：使用阿里云镜像源总结参考 环境 RHEL 9.3Docker Community 24.0.7ubuntu:latest Docker image (jammy 22.04) 背景 启动Ubuntu容器：
docker run -it ubuntu 在容器里：
vim bash: vim: command not found 查看Ubuntu版本：
cat /etc/issue Ubuntu 22.04.3 LTS \n \l 安装vim：
apt install vim Reading package lists... Done Building dependency tree... Done Reading state information... Done E: Unable to locate package vim 失败了。要先 apt update 更新package列表：
apt update 然后再安装vim：
apt install vim 这次安装成功了。但问题是，国内在连接Ubuntu网站的时候，特别慢，还经常连接失败。
查看 /etc/apt/sources.list 文件，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c242c6b073beba498cbec4b226a5cfdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21988bf32ac4abfb9279abc383d4c7a3/" rel="bookmark">
			R2机器人加载棋盘与棋子模型，对urdf、sdf的解释(区分srdf)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、概述 urdf、sdf、srdf文件都属于xml的规范格式，解释分别如下：
urdf(unified robot description format)叫做"统一机器人描述格式"，主要目的就是提供一种尽可能通用的机器人描述规范，这样对于机器人的描述就可以互相移植，比较方便。
sdf(simulation description format)能够描述机器人、静态和动态物体、照明、地形甚至物理学的各方面的信息。sdf可以精确描述机器人的各类性质，除了传统的运动学特性之外，还可以为机器人定义传感器、表面属性、纹理、关节摩擦等，还提供了定义各种环境的方法，包括环境光照、地形，OpenStreetMaps中的街道以及The Prop Shop中提供的任何模型
从仿真角度讲，urdf文档不能描述不属于机器人的属性，即使其可能与机器人仿真十分相关，如环境光线、机器人在世界坐标系下的位姿、多个机器人之间的相对位姿等，算是对urdf的补充升级。
srdf(semantic robot description format)叫做"语义机器人描述格式"，是MoveIt针对控制机器人关节运动使用的一种机器人描述文件格式。有兴趣的可以查阅:ROS仿真R2机器人之安装运行及MoveIt的介绍 使用命令：
rosrun moveit_setup_assistant moveit_setup_assistant 就可以打开MoveIt辅助安装工具，其中就有加载和生成srdf文件的操作。主要内容包括，关节组(joint groups)，默认状态配置(default robot configurations)，额外的碰撞检测信息(additional collision checking information)，额外的坐标系变换(additional transforms)等
我们重点来讲解下urdf对机器人的描述格式文件，连杆是带有质量属性的刚体，也就是不能发生形变，比如手臂，而关节是连接、限制两个刚体相对运动的结构，可以旋转，比如人的腕关节。关节也叫运动副。通过关节将连杆依次连接起来，就构成了一个个运动链，主要包括如下内容：
机器人模型的运动学与动力学描述
机器人的几何表示
机器人的碰撞模型 2、urdf示例 比如一个简单的描述如下：
&lt;?xml version="1.0"?&gt; &lt;robot name="mybot"&gt; &lt;link name="base_link"&gt; &lt;visual&gt; &lt;geometry&gt; &lt;cylinder length="0.8" radius="0.1"/&gt; &lt;/geometry&gt; &lt;/visual&gt; &lt;/link&gt; &lt;/robot&gt; 那么这个机器人的名称叫mybot，link属性就是连杆的意思，所以是一根名为base_link的连杆，visual是可视化节点，geometry是几何学，对机器人关节的描述，这里就是该连杆的形状是cylinder圆柱体，其长度为0.8、横截面半径为0.1。
单位制度采用的是"米-千克-秒"，所以上面的长度和半径的大小是0.8米和0.1米。
上面的示例是一个连杆，再来看一个带关节的连接两个连杆的机器人：
&lt;?xml version="1.0"?&gt; &lt;robot name="mybot2"&gt; &lt;link name="link_0"&gt; &lt;visual&gt; &lt;geometry&gt; &lt;cylinder length="0.8" radius="0.1"/&gt; &lt;/geometry&gt; &lt;/visual&gt; &lt;/link&gt; &lt;link name="link_1"&gt; &lt;visual&gt; &lt;geometry&gt; &lt;cylinder length="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21988bf32ac4abfb9279abc383d4c7a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db37a09094a51c3c52a5e444799a3af6/" rel="bookmark">
			Vue 缓存Hook：提高接口性能，减少重复请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在开发 Web 应用时，我们经常会遇到需要重复调用接口的场景。例如，当用户频繁刷新页面或进行某个操作时，我们可能需要多次请求相同的数据。这不仅会增加服务器负担，还会导致用户体验下降。为此，我们可以使用缓存机制来优化这一问题。本文将教你一步一步实现一个功能较完善的Vue缓存Hook（钩子函数），它可以帮助我们减少接口的重复调用，提高应用性能。
介绍 这个Hook是一个基于Vue响应式系统的缓存工具，它可以帮助我们轻松地在组件之间共享和管理缓存数据。通过使用缓存，我们可以将接口调用结果缓存起来，当再次需要相同数据时，可以直接从缓存中获取，避免重复调用接口。
示例 以下是一个简单的示例：
import { reactive } from 'vue'; // 缓存值的接口定义 interface CacheValue { data: any; // 存储的数据 expireAt: number; // 数据的过期时间戳 } // 使用缓存的功能函数 export function useCache() { // 创建一个响应式的Map对象来存储缓存 const cache = reactive&lt;Map&lt;string, CacheValue&gt;&gt;(new Map()); /** * @param {string} key - 数据的键 * @param {any} data - 要存储的数据 * @param {number} cacheTime - 数据的缓存时间（以毫秒为单位） */ function setDataToCache(key: string, data: any, cacheTime: number) { const expireAt = Date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db37a09094a51c3c52a5e444799a3af6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53638731d40cd9bb959509fc67fde43f/" rel="bookmark">
			提升测试多样性，揭秘Pytest插件pytest-randomly
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家可能知道在Pytest测试生态中，插件扮演着不可或缺的角色，为开发者提供了丰富的功能和工具。其中，pytest-randomly 插件以其能够引入随机性的特性而备受欢迎。本文将深入探讨 pytest-randomly 插件的应用，以及如何通过引入随机性来提升测试用例的多样性。
什么是pytest-randomly？
pytest-randomly 是Pytest的一个插件，它的主要目的是为测试用例引入随机性。通过使用该插件，测试用例的执行顺序可以被随机化，这有助于发现一些在特定顺序下才会出现的问题，提高测试的覆盖性。
安装pytest-randomly
在开始之前，首先需要安装`pytest-randomly`插件。使用以下命令：
pip install pytest pytest-randomly 基本用法
默认情况下，pytest-randomly 会随机打乱测试用例的执行顺序。你只需在运行测试时添加 --randomly-seed 参数以确保结果可复现。
pytest --randomly-dont-reorganize --randomly-seed=&lt;seed_value&gt; - --randomly-dont-reorganize : 禁止重新组织测试用例的顺序。
- --randomly-seed=&lt;seed_value&gt; : 使用指定的种子值进行随机化，确保结果可复现。
案例演示
考虑一个简单的测试场景，有两个测试用例，分别测试加法和减法：
# test_operations.py def test_addition(): assert 1 + 2 == 3 def test_subtraction(): assert 5 - 3 == 2 运行这两个测试用例，结果应该是全部通过。现在，我们引入`pytest-randomly`插件，看看会发生什么。
应用pytest-randomly
首先，确保已安装 pytest-randomly 插件。接下来，在运行测试时添加 --randomly-seed 参数：
pytest --randomly-seed=42 test_operations.py 在这个例子中，我们使用了种子值42。--randomly-seed 参数为开发者提供了控制随机性的手段，使测试的随机化过程更加可控和可复现。在调试和发现特定条件下的问题时，通过调整种子值，你可以更灵活地利用 pytest-randomly 插件。
最终测试结果可能是：​​​​​​​
============================== test session starts ============================== collected 2 items test_operations.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53638731d40cd9bb959509fc67fde43f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1455054021dcf38616568cc52ab3b77c/" rel="bookmark">
			QT上位机开发（动态添加控件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【 声明：版权所有，欢迎转载，请勿用于商业用途。 联系信箱：feixiaoxing @163.com】
开发界面的时候，大多数情况下，我们都是推荐优先使用designer来进行界面开发。但凡事总有例外，如果控件本身数量未定的时候，比如绘制某一个芯片的引脚，这个时候最好采用动态添加控件的方法来解决。当然，实际开发中，不管是用designer，还是用硬编码，最好都要学习下，因为我们不知道客户的需求是什么，所以不得不做两手准备。
前面我们说过，基本上所有的界面都是按照grid，或者vertical、horizontal这种layout布局来进行控件增减的，只要掌握了这个思路，界面的绘制就问题不大了。今天，我们针对同一个需求，采用了三种不同的方法来实现，大家可以简单对比下。
1、创建一个widget工程 为了测试，先用qt widget wizard创建一个简单的基本工程。
2、用designer进行界面开发 开发的内容不复杂，就是三行、六个控件。第一行是一个label、一个text，label上是ID。第二行是一个label、一个text，label上是Name。第三行是两个按钮，一个写着OK，一个写着Cancel。这部分，如果用designer来做，就是这样的，直接拖动对应的控件到windows桌面即可，
3、利用grid进行布局 如果不用designer来做，那么可以用grid来实现。用grid的话，就相当于是一个三行两列的矩阵。0行0列放label ID、0行1列放text、1行0列放Name，依次类推，等到所有的控件都放满了，界面也就布局结束了。
#include &lt;QApplication&gt; #include &lt;QWidget&gt; #include &lt;QLabel&gt; #include &lt;QLineEdit&gt; #include &lt;QPushButton&gt; #include &lt;QGridLayout&gt; int main(int argc, char *argv[]) { QApplication app(argc, argv); // 创建主窗口 QWidget window; window.setWindowTitle("MainWindow"); window.resize(600, 450); // 创建控件 QLabel *idLabel = new QLabel("ID:"); QLineEdit *idText = new QLineEdit(); QLabel *nameLabel = new QLabel("Name:"); QLineEdit *nameText = new QLineEdit(); QPushButton *okButton = new QPushButton("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1455054021dcf38616568cc52ab3b77c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/9/">«</a>
	<span class="pagination__item pagination__item--current">10/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/11/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>