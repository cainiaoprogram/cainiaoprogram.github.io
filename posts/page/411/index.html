<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a99ce8f953f40f2dd6e73a561632243/" rel="bookmark">
			最长单调子序列例题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. HDU 1025 Constructing Roads In JGShining's Kingdom Problem Description
JGShining's kingdom consists of 2n(n is no more than 500,000) small cities which are located in two parallel lines.
Half of these cities are rich in resource (we call them rich cities) while the others are short of resource (we call them poor cities). Each poor city is short of exactly one kind of resource and also each rich city is rich in exactly one kind of resource.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a99ce8f953f40f2dd6e73a561632243/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d6ba46d68a240fcb1e122bf48d722e4/" rel="bookmark">
			深度学习之softmax函数（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Softmax详解 大神的softmax链接
深度学习中的损失函数1
深度学习中的损失函数2
二、Logistic函数 Logistic函数又称逻辑斯谛函数，也就是经常说的sigmoid函数，它的几何形状也就是一条sigmoid曲线。
logistic函数的公式形式如下：
logistic函数的图像如下：
是一条值区间为[0, 1]的曲线
在传统的机器学习和统计学习中Logistic作为一种对数线性模型被广泛的应用于分类和回归场景中。此外Logistic函数也是神经网络中最常用的激活函数，即Sigmod函数。
三、Softmax和Logistic的关系 （１）Logistic具体针对的是二分类问题，而softmax针对的是多分类问题
（２）从概率角度来看，softmax建模使用的分布是多项式分布，而logistic则基于伯努利分布
（3）多个logistic回归通过叠加也同样可以实现多分类的效果，softmax回归进行的多分类，类与类之间是互斥的，即一个输入只能被归为一类，多个logistic回归进行多分类，输出的类别并不是互斥的，即"苹果"这个词语既属于"水果"类也属于"3C"类别。
参考：https://blog.csdn.net/m0_37565948/article/details/81324115
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16a3fdc45ab7bc2cdf227c02b4ce7c84/" rel="bookmark">
			leetcode 23. 合并K个排序链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class Solution(object): def adjust_to_min_heap(self, arr, i, end): while i &lt; end: l = 2 * i + 1 r = 2 * i + 2 min_ind = i if l &lt; end and arr[l][0] &lt; arr[min_ind][0]: min_ind = l if r &lt; end and arr[r][0] &lt; arr[min_ind][0]: min_ind = r if min_ind == i: break else: arr[min_ind], arr[i] = arr[i], arr[min_ind] i = min_ind return arr def mergeKLists(self, lists): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16a3fdc45ab7bc2cdf227c02b4ce7c84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6875cb8e5dc693d8be73dd93f023ed2e/" rel="bookmark">
			STL用法整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度百科 STL是Standard Template Library的简称，中文名标准模板库，惠普实验室开发的一系列软件的统称。从根本上说，STL是一些“容器”的集合，这些“容器”有list,vector,set,map等，STL也是算法和其他一些组件的集合。STL的目的是标准化组件，这样就不用重新开发，可以使用现成的组件。STL现在是C++的一部分，因此不用安装额外的库文件。
在C++标准中，STL被组织为下面的13个头文件：&lt;algorithm&gt;、&lt;deque&gt;、&lt;functional&gt;、&lt;iterator&gt;、&lt;array&gt;、&lt;vector&gt;、&lt;list&gt;、&lt;forward_list&gt;、&lt;map&gt;、&lt;unordered_map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;unordered_set&gt;、&lt;stack&gt;和&lt;utility&gt;。
向量(vector) 连续存储的元素&lt;vector&gt;
列表(list) 由节点组成的双向链表，每个结点包含着一个元素&lt;list&gt;
双队列(deque) 连续存储的指向不同元素的指针所组成的数组&lt;deque&gt;
集合(set) 由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序 &lt;set&gt;
多重集合(multiset) 允许存在两个次序相等的元素的集合 &lt;set&gt;
栈(stack) 后进先出的值的排列 &lt;stack&gt;
队列(queue) 先进先出的执的排列 &lt;queue&gt;
优先队列(priority_queue) 元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列 &lt;queue&gt;
映射(map) 由{键，值}对组成的集合，以某种作用于键对上的谓词排列 &lt;map&gt;
多重映射(multimap) 允许键对有相等的次序的映射 &lt;map&gt;
一、string 在定义 string 类对象时，string 类自身可以管理内存，程序员不必关注内存的分配细节。
string 类提供的各种操作函数大致分为八类：构造器和析构器、大小和容量、元素存取、字 符串比较、字符串修改、字符串接合、I/O 操作以及搜索和查找。
要使用 string 类，必须包含头文件 &lt;string&gt;
string stuff; getline(cin, stuff); //获取一行字符串 1、构造函数 string strs //生成空字符串 string s(str) //生成字符串str的复制品 string s(str, stridx) //将字符串str中始于stridx的部分作为构造函数的初值 string s(str, strbegin, strlen) //将字符串str中始于strbegin、长度为strlen的部分作为字符串初值 string s(cstr) //以C_string类型cstr作为字符串s的初值 string s(cstr,char_len) //以C_string类型cstr的前char_len个字符串作为字符串s的初值 string s(num, c) //生成一个字符串，包含num个c字符 string s(strs, beg, end) //以区间[beg, end]内的字符作为字符串s的初值 string s('x'); //错误 string s(1, 'x'); //正确 string s("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6875cb8e5dc693d8be73dd93f023ed2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/417999f99153fe6df983d5af2edbb714/" rel="bookmark">
			BugFree服务器安装实践手记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先给大家分享一个巨牛巨牛的人工智能教程，是我无意中发现的。教程不仅零基础，通俗易懂，而且非常风趣幽默，还时不时有内涵段子，像看小说一样，哈哈～我正在学习中，觉得太牛了，所以分享给大家！点这里可以跳转到教程
WIN2000服务器上的安装：
步骤很简单，可以按照Bugfree的帮助文档进行操作：
1. 下载 XAMPP包，然后直接运行文件“xampp-win32-1.6.8-installer.exe”进行安装； 2.下载 BugFree2.0.2 安装包，解压“bugfree2.tar.gz”后把整个"BugFree2"文件夹复制到 XAMPP 系统的 htdocs 子目录下， 系统的安装路径一般为 C:/xampp/htdocs/BugFree;
3. 进入 BugFree 的安装目录，复制文件 “Include/Config.inc.Sample.php ” 为一个新的文件 “Include/Config.inc.php”；（实际试过，如果不复制这个文件，则不能正常访问服务器；但帮助文档中说要编辑此新文件的步骤，其实是没必要做的）
４. 用浏览器访问 http://servername/BugFree ,比如访问我的虚拟机服务器：http://192.168.1.221/BugFree。首次访问，会提示设置的数据库不存在，按照提示创建数据库，再点击继续安装， 点击“安装全新的 BugFree2 ” 即可！
**************************
Linux服务器上的安装：
1. 下载 XAMPP包，可以用“WinSCP”软件把下载的压缩包传到Linux机器的/opt/目录下。然后解压文件“xampp-linux-1.6.8a.tar.gz”：
tar xzvf xampp-linux-1.6.8a.tar.gz 也即进行了安装，如果成功安装后，会在压缩包的相同目录中生成一个lampp文件夹；
(此处注意，一定要让lampp文件夹存在/opt/目录下，因为lampp/lampp文件中的配置文件都从/opt/lampp目录下读取，否则Apache等服务会因找不到相应目录下的文件而不能开启)
2. 下载 BugFree2.0.2 安装包，解压“bugfree2.tar.gz”后把整个"BugFree2"文件夹 用“WinSCP”软件 传到 XAMPP 系统的 htdocs 子目录下， 路径为：
/opt/lampp/htdocs/BugFree 3. 进入 BugFree 的安装目录，复制文件 “Include/Config.inc.Sample.php ” 为一个新的文件 “Include/Config.inc.php”；
cp Include/Config.inc.Sample.php Include/Config.inc.php 4.修改下列目录和文件的权限: a) chmod 777 /opt/xampp/lampp/htdocs/BugFree/Data/TplCompile/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/417999f99153fe6df983d5af2edbb714/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/361375643a0ca46e762864cb42bf5ae5/" rel="bookmark">
			MVG读书笔记——单应矩阵估计这件小事（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参数估计是计算机视觉中经常遇到的一个问题，为较好的估计参数，人们发明了各种各样的算法。这里我们就以单应矩阵H的估计为例，一个个介绍这些常用算法。
DLT算法 DLT（direct linear transform）算法是一个用于解决包含尺度的最小二乘问题的算法。可以解决的问题包括相机内参估计、单应矩阵估计、基础矩阵估计等。
以单应矩阵H的估算为例。由于H为 3 × 3 3\times3 3×3的矩阵，除去尺度的影响之后有8个自由度。需要4对对应点来求解。假设某一对对应点 x i , x i ′ \textbf x_i,\textbf x_i&amp;#x27; xi​,xi′​,则
x i ′ = H x i = [ h 1 T x i h 2 T x i h 3 T x i ] \textbf x_i&amp;#x27;=H\textbf x_i=\begin{bmatrix}h^{1T}\textbf x_i\\h^{2T}\textbf x_i\\h^{3T}\textbf x_i\end{bmatrix} xi′​=Hxi​=⎣⎡​h1Txi​h2Txi​h3Txi​​⎦⎤​
其中 h j T h^{jT} hjT代表H的第j行。
假设 x i ′ = ( x i ′ , y i ′ , w i ′ ) T \textbf x_i&amp;#x27;=(x_i&amp;#x27;,y_i&amp;#x27;,w_i&amp;#x27;)^T xi′​=(xi′​,yi′​,wi′​)T。对等式叉乘一个 x i ′ \textbf x_i&amp;#x27; xi′​我们得到
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/361375643a0ca46e762864cb42bf5ae5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a4cb2aa58bd3332a64bf77a83ec7582/" rel="bookmark">
			VC&#43;&#43;学习-数据库篇（记录集recordset常用操作代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程环境：VS2013，MFC
要搞清楚:数据库和ADO的记录集是两个不同的概念, 是存在于不同物理位置的两个存储空间。 记录集相当于是实际数据的一份拷贝。 正因为记录集是相对脱离数据库而存在的, 所以才存在后面将要介绍的Open方法中涉及的光标类型和锁定类型这两个问题。
在ADO程序中，**记录集（Recordset）**对象代表一个表的记录集合或者是一个SQL命令或存储过程执行结果。简单地说：记录集实际上缓存了从数据库获得的记录，应用程序可以从记录集中获得每条记录的字段。
使用记录集的具体方法：
定义_RecordsetPtr型变量，然后通过它调用Recordset对象的Open方法，即可打开一个数据集，然后可以使用GetCollet方法获取记录的字段值，使用Move系列函数实现记录集的遍历，最后关闭记录集。
&lt;pre name="code" class="cpp"&gt; _RecordsetPtr智能指针，它是专门为通过记录集操作数据库而设立的指针，通过该接口可以对数据库的表内的记录、字段等进行各种操作。 Recordset对象的常用属性和方法：
**RecordCount属性：**返回Recordset对象中记录的当前数目
**BOF,EOF属性：**BOF指示当前记录位置的第一记录的前一个，EOF指示当前记录的最后一个记录的后一个。如果打开没有记录的Recordset对象，则BOF,EOF都为true，如果打开的记录集中包含记录，则BOF,EOF都为false
**AbsolutePosition属性：**指定Recordset对象当前记录的序号位置
**ActiveConnection属性：**该属性指定Recordset当前所属的Connection对象。
ADO连接ACCESS 打开并连接数据库 _variant_t vUsername,vID,vname; //变量声明 _RecordsetPtr m_pRecordset; //记录集 CString strid; _ConnectionPtr connection; m_pRecordset.CreateInstance(__uuidof( Recordset )); //创建实例 m_pRecordset-&gt;Open("SELECT * FROM users",connection.GetInterfacePtr (),adOpenStatic,adLockOptimistic,adCmdText);//执行SQL语句，得到记录集, connection必须已和数据库连接 原型
Open方法的原型是这样的:
HRESULT Recordset15::Open ( const _variant_t &amp; Source, const _variant_t &amp; ActiveConnection, enum CursorTypeEnum CursorType, enum LockTypeEnum LockType, long Options ) ①Source参数：为记录源，是数据查询字符串，它可以是下列内容之一：Command对象变量，SQL语句，存储过程，表名或完整的路径名。
②ActiveConnection：是已经建立好的连接（我们需要用Connection对象指针来构造一个_variant_t对象) ，对应于ActiveConnection属性，指定在哪个连接中打开该记录集，常用_ConnectionPtr.GetInfaceterPtr()指定
③CursorType光标类型：指定打开Recordset时使用的游标，它的取值可以是CursorTypeEnum枚举型中的常量，adOpenStatic（静态游标），adOpenDynamic（动态游标）,adOpenForwardOnly(默认，前向游标)，adOpenKeyset（键集游标）.请看这个枚举结构:
enum CursorTypeEnum { adOpenUnspecified = -1,///不作特别指定 adOpenForwardOnly = 0,///前滚静态光标。这种光标只能向前浏览记录集，比如用MoveNext向前滚动,这 种方式可以提高浏览速度。但诸如BookMark,RecordCount,AbsolutePosition,AbsolutePage都不能使用 adOpenKeyset = 1,///采用这种光标的记录集看不到其它用户的新增、删除操作，但对于更新原有记录的 操作对你是可见的。 adOpenDynamic = 2,///动态光标。所有数据库的操作都会立即在各用户记录集上反应出来。 adOpenStatic = 3///静态光标。它为你的记录集产生一个静态备份，但其它用户的新增、删除、更新操作对你的记录集来说是不可见的。 }; ④LockType：指定打开记录集时应该使用的锁定类型，LockType取值为LockTypeEnum枚举型的值，它可以是以下值之一，请看如下枚举结构：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a4cb2aa58bd3332a64bf77a83ec7582/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64292903922bb4728890de21f0e54d28/" rel="bookmark">
			XGBoost
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeetCode题目记录 1.XGBoost概念2.集成思想3.分析XGboost思路4.原理推导5.正则化6.优缺点7. sklearn 参数 1.XGBoost概念 XGBoost全名叫（eXtreme Gradient Boosting）极端梯度提升，经常被用在一些比赛中，其效果显著。它是大规模并行boosted tree的工具，它是目前最快最好的开源boosted tree工具包。XGBoost 所应用的算法就是 GBDT（gradient boosting decision tree）的改进，既可以用于分类也可以用于回归问题中。
1、回归树与决策树
事实上，分类与回归是一个型号的东西，只不过分类的结果是离散值，回归是连续的，本质是一样的，都是特征（feature）到结果/标签（label）之间的映射。说说决策树和回归树，在上面决策树的讲解中相信决策树分类已经很好理解了。
分类树的样本输出（即响应值）是类的形式，如判断蘑菇是有毒还是无毒，周末去看电影还是不去。而回归树的样本输出是数值的形式，比如给某人发放房屋贷款的数额就是具体的数值，可以是0到120万元之间的任意值。
那么，这时候你就没法用上述的信息增益、信息增益率、基尼系数来判定树的节点分裂了，你就会采用新的方式，预测误差，常用的有均方误差、对数误差等。而且节点不再是类别，是数值（预测值），那么怎么确定呢，有的是节点内样本均值，有的是最优化算出来的比如Xgboost。
2、boosting集成学习
boosting集成学习，由多个相关联的决策树联合决策，什么叫相关联，举个例子，有一个样本[数据-&gt;标签]是[(2，4，5)-&gt; 4]，第一棵决策树用这个样本训练得预测为3.3，那么第二棵决策树训练时的输入，这个样本就变成了[(2，4，5)-&gt; 0.7]，也就是说，下一棵决策树输入样本会与前面决策树的训练和预测相关。
与之对比的是random foreast（随机森林）算法，各个决策树是独立的、每个决策树在样本堆里随机选一批样本，随机选一批特征进行独立训练，各个决策树之间没有啥毛线关系。
所以首先Xgboost首先是一个boosting的集成学习，这样应该很通俗了
3、这个时候大家就能感觉到一个回归树形成的关键点：（1）分裂点依据什么来划分（如前面说的均方误差最小，loss）；（2）分类后的节点预测值是多少（如前面说，有一种是将叶子节点下各样本实际值得均值作为叶子节点预测误差，或者计算所得）
2.集成思想 在学习XGBoost之前，我们得需要先明白集成思想。集成学习方法是指将多个学习模型组合，以获得更好的效果，使组合后的模型具有更强的泛化能力。另外XGBoost是以分类回归树(CART树)进行组合。故在此之前，我们先看下CART树(CART树具体原理请自行复习，或者可以留言)。如下，通过输入用户年龄、性别进行判断用户是否喜欢玩游戏的得分值。由此得到一颗CART树模型。
我们知道对于单个的决策树模型容易出现过拟合，并且不能在实际中有效应用。所以出现了集成学习方法。如下图，通过两棵树组合进行玩游戏得分值预测。其中tree1中对小男生的预测分值为2，tree2对小男生的预测分值为0.9。则该小男生的最后得分值为2.9。
将上面集成学习方法推广到一般情况，可知其预测模型为：
其中为树的总个数，表示第颗树，表示样本的预测结果。
损失函数为：
3.分析XGboost思路 首先明确下我们的目标，希望建立K个回归树，使得树群的预测值尽量接近真实值（准确率）而且有尽量大的泛化能力（更为本质的东西），从数学角度看这是一个泛函最优化，多目标，看下目标函数：
其中i表示第i个样本，表示第i个样本的预测误差，误差越小越好，不然你算得上预测么？后面在这里描述表示树的复杂度的函数，越小复杂度越低，泛化能力越强，这意味着啥不用我多说。表达式为
直观上看，目标要求预测误差尽量小，叶子节点尽量少，节点数值尽量不极端（这个怎么看，如果某个样本label数值为4，那么第一个回归树预测3，第二个预测为1；另外一组回归树，一个预测2，一个预测2，那么倾向后一种，为什么呢？前一种情况，第一棵树学的太多，太接近4，也就意味着有较大的过拟合的风险）
ok，听起来很美好，可是怎么实现呢，上面这个目标函数跟实际的参数怎么联系起来，记得我们说过，回归树的参数:（1）选取哪个feature分裂节点呢；（2）节点的预测值（总不能靠取平均值这么粗暴不讲道理的方式吧，好歹高级一点）。上述形而上的公式并没有“直接”解决这两个，那么是如何间接解决的呢？
先说答案：贪心策略+最优化（二次最优化）
通俗解释贪心策略：就是决策时刻按照当前目标最优化决定，说白了就是眼前利益最大化决定，“目光短浅”策略，他的优缺点细节大家自己去了解，经典背包问题等等。
这里是怎么用贪心策略的呢，刚开始你有一群样本，放在第一个节点，这时候T=1
如果这里的l(w−yi)误差表示用的是平方误差，那么上述函数就是一个关于w的二次函数求最小值，取最小值的点就是这个节点的预测值，最小的函数值为最小损失函数。
这里处理的就是二次函数最优化！
要是损失函数不是二次函数咋办，哦，泰勒展开式会否？，不是二次的想办法近似为二次。
接着来，接下来要选个feature分裂成两个节点，变成一棵弱小的树苗，那么需要：（1）确定分裂用的feature，how？最简单的是粗暴的枚举，选择loss function效果最好的那个（关于粗暴枚举，Xgboost的改良并行方式咱们后面看）；（2）如何确立节点的w
那么节奏是，选择一个feature分裂，计算loss function最小值，然后再选一个feature分裂，又得到一个loss function最小值…你枚举完，找一个效果最好的，把树给分裂，就得到了小树苗。在分裂的时候，你可以注意到，每次节点分裂，loss function被影响的只有这个节点的样本，因而每次分裂，计算分裂的增益（loss function的降低量）只需要关注打算分裂的那个节点的样本。
接下来，继续分裂，按照上述的方式，形成一棵树，再形成一棵树，每次在上一次的预测基础上取最优进一步分裂/建树，是不是贪心策略？！
凡是这种循环迭代的方式必定有停止条件，什么时候停止呢：
（1）当引入的分裂带来的增益小于一个阀值的时候，我们可以剪掉这个分裂，所以并不是每一次分裂loss function整体都会增加的，有点预剪枝的意思，阈值参数为 γ 正则项里叶子节点数 T 的系数；
（2）当树达到最大深度时则停止建立决策树，设置一个超参数max_depth，这个好理解吧，树太深很容易出现的情况学习局部样本，过拟合；
（3）当样本权重和小于设定阈值时则停止建树，这个解释一下，涉及到一个超参数-最小的样本权重和min_child_weight，和GBM的 min_child_leaf 参数类似，但不完全一样，大意就是一个叶子节点样本太少了，也终止同样是过拟合；
（4）貌似看到过有树的最大数量的…这个不确定
那节点分裂的时候是按照哪个顺序来的，比如第一次分裂后有两个叶子节点，先裂哪一个？答：同一层级的（多机）并行，确立如何分裂或者不分裂成为叶子节点
4.原理推导 上面一部分我们知道了集成学习方法的预测模型，因为XGBoost也是集成学习方法的一种。对于XGBoost的预测模型同样可以表示为：
其中K为树的总个数，表fk示第k颗树，y表示样本x的预测结果。
其中损失函数也同样表示为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64292903922bb4728890de21f0e54d28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c88dcc0c50539e91eedce2496eb6756e/" rel="bookmark">
			OpenVX, 运算加速库, NVIDIA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Khronos Group Khronos Group是一个行业组织，创建开放标准以实现并行计算、图形、视觉、传感处理和动态媒体在各种平台和设备上的编写和加速。Khronos标准包括Vulkan, OpenGL, OpenGL ES, WebGL, OpenCL, SPIR, SYCL, WebCL, OpenVX, EGL, OpenMAX, OpenVG, OpenSL ES, StreamInput, COLLADA和glTF。
OpenSL：音频的硬件加速接口。
Vulkan：OpenGL的升级版本。在OpenGL中Context和单一线程是绑定的，所以所有需要作用于Context的操作，例如改变渲染状态，绑定Shader，调用Draw Call，都只能在单一线程上进行。Vulkan中不再需要依赖于绑定在某个线程上的Context，而是用全新的基于Queue的方式向GPU递交任务，并且提供多种Synchronization的组件让多线程编程更加亲民。
简单来说，Khronos的任务就是创建一个统一的硬件和软件之间的API，这样无论软件厂商，还是硬件厂商，都能各行其道，互不干扰了。
概述 官网：
https://www.khronos.org/openvx/
上图给出了OpenVX的主要用途，以及它和Khronos其他兄弟项目之间的关系。
OpenVX本身也是一个系列标准。它包括：
OpenVX：一个传统的CV接口。提供包括直方图、Harris、Canny等特征算子的API。
OpenVX SC（Safety Critical）：安全版的OpenVX。
OpenVX NN Extension：专门用于提供NN加速方面的API。目前主要集中于CNN的加速，即卷积、池化等操作，对其他NN支持有限。此外，这些API主要用于预测，而非训练。
Khronos官方提供了一个OpenVX的软件参考实现，用于软硬件厂商的测试工作。
相关API文档和参考实现（sample code）参见：
https://www.khronos.org/registry/OpenVX/
Host &amp; Device 和OpenGL类似，一般将CPU称作Host，而将GPU称作Device。App运行在Host上，而硬件加速由Device实现。
Device上的内存一般不能直接访问，需要使用vxCreateScalar、vxCreateTensor之类的API，将相关数据传到Device上。
类似的，有些API也分为Host版本和Device版本，前者用于Host和Device之间的数据交换，而后者用于Device内部数据的交换。
比如，vxCreateTensorAddressing和vxCreateTensorView，都是选择tensor的某一部分，前者是Host API，而后者是Device API。
数组的存储格式 和OpenGL一样，OpenVX中的tensor，也是列优先存储的。而C语言是行优先存储的。
行优先/列优先的概念参见：
http://blog.csdn.net/zhoxier/article/details/8058176
数组按行/列存储
OpenCL 官网：
https://www.khronos.org/opencl/
按照Michael J. Flynn的分类方法，计算机的体系结构可分为如下四类：
Single instruction stream single data stream (SISD)
Single instruction stream, multiple data streams (SIMD)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c88dcc0c50539e91eedce2496eb6756e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd20632202f159344acfcc0100216324/" rel="bookmark">
			OSI和TCP/IP模型的介绍及其区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OSI 七层参考模型：开放系统互连参考模型（先模型后协议） 控制层面：控制信息（应用层、表示层、会话层），数据层面：传递信息。控制层面影响数据层面
OSI七层参考模型
TCP/IP模型
对应的协议
应用层
应用层
HTTP、FTP、DNS、SMTP、POP3、Telnet、TFTP、DHCP、SSH、NTP、Ping命令
表示层
会话层
传输层
主机到主机层
TCP、UDP
网络层
互联网层
IP、ICMP、ARP、RARP
数据链路层
网络接口层
Ethernet、802.3、PPP
物理层
物理层：比特流传输（数据中的信号）、接口和线缆、传输介质：有线、无线 PDU：协议数据单元，数据在不同层的表现形式
一层PDU:bit
功能：规定介质类型、接口类型、信令类型（电话拨号），规范在终端系统之间激活、维护和关闭物理链路的电气、机械、流程和功能等方面的要求，规范电平、数据速率、最大传输距离和物理接头等特征。
物理层介质：同轴电缆、双绞线（568B的线序：橙白、橙、绿白、蓝、蓝白、绿、棕白、棕）、光纤、无线电波
物理层设备：中继器（还原信号，延长传输距离，但不能无线延长，错误率会提高），集线器（扩口器、类似于插线板）
数据链路层：提供介质访问、链路管理等 二层PDU：frame 数据帧
功能：
MAC 介质访问控制子层：（用于二层用户的表示，指定数据如何通过物理线路进行传输，并与物理层通信）
MAC 地址/物理地址/硬件地址/烧录地址（可以唯一标识一台设备）：有48位二进制构成，前24位是厂商编号，后24位是序列号, 点分十六进制
LLC逻辑链路控制子层：（识别协议类型并对数据进行封装通过网络进行传输，描述上层协议）
网络层：寻址和路由选择（数据的来去向） 三层PDU：packet数据包
功能：在不同网络之间转发数据包，设备：路由器、三层交换机
网络层协议：IP、 ICMP、ARP、RARP
网络层地址（唯一标识一台网络设备）：包括网络ID、主机ID
编址协议：ipv4（32位二进制构成，点分十进制表示）ipv6
本地测试地址（测试TCP/IP协议栈是否工作）：127.0.0.1/8
本地链路地址（仅仅针对window主机）：169.254.0.0/16
私有IP地址：
A类：10.0.0.0---10.255.255.255 255.0.0.0
B类：172.16.0.0----172.31.255.255 255.255.0.0
C类：192.168.0.0---192.168.255.255 255.255.255.0
传输层：建立主机端到端连接（去哪个应用/进程，可靠性保证） 四层PDU：segment分片
功能：位于TCP/IP 协议栈第四层，为应用程序提供服务。传输层定义了主机应用程序之间端到端的连通性。分段上层数据，建立端到端连接，将数据从一端主机传送到另一端主机，保证数据按序（标号）、可靠（重传）、正确传输（传输之前校验，传输后检验，最后对比两个校验值）定义数据传输方式，可靠传输、不可靠传输（对流量的实时性要求高的用不可靠传输、对数据丢失不敏感、大流量）
使用MTU/最大传输单元进行分片：MTU默认1500个字节
传输层要区分不同的流量：使用端口号 十进制数值，一个的端口号代表一种流量（HTTP—80、HTTPS—443、Telnet—23、SSH—22、FTP—20/21、QQ—4000/8000、Server—67、Client—68）
1-65535 静态端口号：1-1023 流量和端口有一一对应并绑定的关系
动态端口号：1024-65535
TCP：传输控制协议，是一种面向连接的可靠传输协议。面向连接：传输前进行沟通和协商，确保互相可以/愿意发送数据，如何保证面向连接：TCP三次握手
UDP：用户数据报协议，是一种非面向连接的不可靠传输协议。非面向连接：发送数据，收不收无所谓，eg:IPTV，网络电视，接收就看，不接收就不看，但必须发送
会话层： 建立、维护和管理会话，针对需要传递的流量定义一条端到端的会话链接（该链接为虚链接），使得会话互不干扰
表示层： 处理数据格式、数据加密等，翻译（将逻辑语言转换为计算机语言/二进制）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd20632202f159344acfcc0100216324/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7703da3fee4d93a1b8c7faa1844529ec/" rel="bookmark">
			word中手动添加endnote的加载项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Endnote管理文献，在写作的同时插入引文，这对于写文章的朋友们来说太重要了。我今天遇到这个问题，花时间钻研了，觉得应该记录下来，相信也会方便大家。查了网上许多帖子依然不得解，可能是Word版本变化造成的。　1.安装了word与Endnote却不见其出现在Word工具栏中。　2.点击word中的office按钮，在底部点击“word选项”。选择左侧的“加载项”，在底部管理栏的下拉菜单中选“word加载项”，点击旁边的“转到”。进入小窗口后检查EndNoteCwyw.dot；EndNoteWebCwyw.dot；EndNoteCwyw.dotm和EndNoteWebCwyw.dotm都被选中。如果没有其中的加载项，则通过路径“C:\ProgramFiles\EndNoteX1\Product-Support\CWYW”在这个文件夹里可以找到，并将其添加。　3.再进入“word选项”，选择“加载项”下拉菜单中的“禁用项目”。如果有EndNoteCwyw的项目已被禁用，则选中并启用。确定修改后重新启动word，问题应该已经解决了。
转载于:https://www.cnblogs.com/triple-y/p/10682645.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aec89315d078fbd6542afbb6c7963d6/" rel="bookmark">
			TCP 和UDP 的详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP 协议概述 TCP：传输控制协议，是一种面向连接的可靠传输协议。TCP为应用程序提供一种面向连接的、可靠的服务。（面向连接：传输前进行沟通和协商，确保互相可以/愿意发送数据）
TCP三次握手能够保证面向连接，面向连接是可靠的，并不能保证TCP传输是可靠的，三次握手是TCP传输之前的一个过程，那么如何保证TCP是可靠的：
面向连接的传输（准备好了传）最大报文段长度（一共传多少）传输确认机制（TCP发送的每一个数据都要进行确认，丢没丢）首部和数据的校验和（错没错）重传输（若没有收到ACK,则在等一定时间后重新发送数据）重排序（对分片用序列号进行重新排序）流量控制（量力而行，按需传递） 三次握手：C要向S发送数据（C/S模型，客户端先进行三次握手；如果两设备是公平的情况下是随机发送，详见下图）
三次握手的过程：
1）第一次握手：建立连接时，客户端发送syn（syn=a）包到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号
2）第二次握手：服务器收到syn包，必须确认客户的SYN（ack=a+1），同时自己也发送一个SYN包（syn=b），即SYN+ACK包，此时服务器进入SYN_RECV状态
3）第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=b+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手
三次握手的确认：
第一个数据包要靠第二个数据包进行显性确认，第二个数据包要靠第三个数据包进行显性确认，第三个数据包自己进行隐性确认（不需要回复，但完成确认）
第三个数据包隐性确认的过程：
eg:服务器在收到第三个数据包前会有猜想，如收到第三个数据包和自己及的猜想一样，服务器不回复，如果服务器收到的数据包和自己的猜想不一样甚至没有收到，服务器就重新传输第二个数据包，以至于客户端知道自己发送的第三个数据包失败（服务器怎么知道第三个数据包的内容？第三个数据包的内容来自刚服务器发送的第二个数据包的内容或者是内容+1，即ACK确认下一个想要对方的数据包）
为什么TCP需要三次握手？
总结来说，两次不可靠，四次不高效。TCP是可靠的传输控制协议，三次握手能保证数据可靠传输又能提高传输效率，而且三次握手可以保证任何一次握手出现问题，都是可以被发现或补救的。
1）如果是两次握手：
现假定出现一种异常情况，即C发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达S。本来这是一个早已失效的报文段。但S收到此失效的连接请求报文段后，就误认为是C又发出一次新的连接请求。于是就向C发出确认报文段，同意建立连接。假定不采用三次握手，那么只要S发出确认，新的连接就建立了。由于现在C并没有发出建立连接的请求，因此不会理睬S的确认，也不会向S发送数据。但S却以为新的运输连接已经建立了，并一直等待C发来数据。S的许多资源就这样白白浪费了。采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，C不会向S的确认发出确认。S由于收不到确认，就知道C并没有要求建立连接。
2）如果是4次及以上的握手
三次握手之后，C和S可以保证正常通信，之后的次数都是徒劳没有必要，三次握手是可以建立链接的最少次数，节约资源使传输更加高效。
四次断开的过程：
1）客户端C发送一个FIN，用来关闭客户端到服务器S的数据传送
2）服务器S收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号
3）服务器S关闭与客户端C的连接，发送一个FIN给客户端C
4）客户端C发回ACK报文确认，并将确认序号设置为收到序号加1
为什么断开需要四次？为什么FIN数据包 和ACK数据包不能一起发？
断开双方都要收到应用层的指令才可以，当对方收到断开请求时并不清楚他自己的应用层要不要断开，所以先回复收到的确认，同时再问应用层要不要断开，同意后再发送自己的断开，另一方收到后确认最终断开。
举个四次断开的例子：我收到了我妈的命令（应用层断开指令）给男朋友发一条微信分手，男朋友回一条他看到了我的微信，与此同时赶紧问他妈咋办（问应用层），他妈说快分吧（应用层表示可以断开），于是男朋友又发条微信分手，我在回复一条我收到了他的微信，遂分手成功（四次断开）
也有特殊情况：当对方要断开时，我自己也收到应用层的断开指令，这种情况可以将断开请求和确认放在一个包内（FIN和ACK）
举个例子：男朋友收到了他妈命令（应用层断开指令）给我发一条微信分手，与此同时我妈也就告诉我男朋友不靠谱早点分（应用层断开指令），于是我高兴的回一条微信，表示我收到了他的分手信息，并且很乐意分手。男朋友收到我消息后回复确认，遂分手成功（三次断开）。
MSS：最大分段大小
MSS最大传输大小的缩写，是TCP 协议里面的一个概念
MSS就是TCP数据包每次能够传输的最大数据分段，为了达到最佳的传输效能TCP协议在建立连接的时候通常要协商双方的MSS值，这个值TCP协议在实现的时候往往用MTU值代替
优化机制/滑动窗口机制：利用滑动窗口实现流量控制（TCP一次性可以传递很多报文，若达到一定数量不能传输时减半再递增，链路稳定，窗口越大）
窗口值可以解决一包一确认很繁琐的问题，一次性可以发多个，每次确认下一个想要的包。双方可以在过程中协商窗口的大小来决定下一次传输/发包的数量
慢启动、快重传
UDP协议概述 UDP：用户数据报协议，是一种非面向连接的不可靠传输协议。非面向连接：发送数据，收不收无所谓，eg:IPTV，网络电视，接收就看，不接收就不看，但必须发送。如何保证面向连接：TCP三次握手
UDP 为应用程序提供面向无连接的服务（仅仅提供端口号）。传输数据之前源端和目的端不需要建立连接，不需要维护连接状态，转发状态等，因此服务器可同时向多个客户端传输相同的消息，UDP适用于对传输效率要求高的运用。
描述TCP和UDP的区别？
TCP：传输控制协议，是一种面向连接的可靠的传输协议
UDP:用户数据报协议，是一种非面向连接的不可靠的传输协议
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5440e5460990b4c47e735d5a68510d65/" rel="bookmark">
			mysql中dual表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.楔子 今日在某项目数据库中发现每个库底下都有这样一张表，如下图所示：
这张表有且只能有一条数据，表结构如下所示：
我想这样做必然有其精神奥义和奇技淫巧，于是一探究竟。
2. mysql中模拟dual表 因为早期的mysql中是没有DUAL表的，应该是5.1之前。于是为了实现dual表的效果，就创建了上面的只有一条记录的Dual表来模拟。效果类似于后来系统自带的DUAL表。为了测试新建如下的表：
create table `T_Sinosun_Dual` ( `DualId` int(11) not null comment '默认ID', `DualName` varchar(20) not null comment '默认名字', `SysCtime` timestamp not null default current_timestamp comment '系统创建时间', `SysUtime` timestamp not null default current_timestamp on update current_timestamp comment '系统修改时间', `SysValid` tinyint(4) not null default '1' comment '系统有效状态', primary key (`DualId`) ) engine=innoDB default charset=utf8 comment='dual表'; insert into `T_Sinosun_Dual`(`DualId`, `DualName`) select 1 , 'daul'; 测试如下：
上图我们可以看出只有一条记录的表可以模拟Dual功能。那么如果表中有多条记录呢？
从上面的测试可以看出，我们模拟的dual表中有几条记录，就会返回几行，所以要实现Dual表的功能，需要保证表中只有一条记录即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5440e5460990b4c47e735d5a68510d65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf16047a52e38b1c5c3005ba25892c59/" rel="bookmark">
			寻找单链表存储字符串的相同后缀起始位置(4)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间复杂度为：O(min(m,n));
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; //找出单链表存储的两个单词相同后缀的起始位置 //可以用栈来求，会比较简单，但是有空间上的消耗 //这里我直接来对比 //感觉链表现在写的越来越熟练了～开心～ typedef struct node { char data; struct node* next; }Node; typedef struct list { Node* head; Node* tail; int length; }List; void create_list(List *L) { //头节点的指针是什么类型的呢 Node * first = (Node*)malloc(sizeof(Node)); if(!first) printf("create wrong!\n"); first -&gt; data = 0; first -&gt; next = NULL; L-&gt;head = L-&gt;tail = first; L -&gt; length = 0; } void insert_list(List *L,char value) { Node * new = (Node*)malloc(sizeof(Node)); if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf16047a52e38b1c5c3005ba25892c59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed574ceedac4857a21e9a661d5ac8c58/" rel="bookmark">
			cookie详解以及cookie的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、cookie机制和session机制的区别
具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。
同时我们也看到，由于服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要
借助于cookie机制来达到保存标识的目的，但实际上还有其他选择，比如说重写 URL和隐藏表单域。
二、会话cookie和持久cookie的区别
如果不设置过期时间，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。
这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。
如果设置了过期时间(setMaxAge(606024))，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，
这些cookie依然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比
如两个IE窗口。而对于保存在内存的cookie，不同的浏览器有不同的处理方式。(在IE下测试通过)
三、如何利用Cookie实现自动登录
当用户在某个网站注册后，就会收到一个唯一用户ID的cookie。客户后来重新连接时，这个用户ID会自动返回，
服务器对它进行检查，确定它是否为注册用户且选择了自动登录，从而使用户务需给出明确的用户名和密码，
就可以访问服务器上的资源。
四、如何根据用户的爱好定制站点
网站可以使用cookie记录用户的意愿。对于简单的设置，网站可以直接将页面的设置存储在cookie中完成定制。
然而对于更复杂的定制，网站只需仅将一个惟一的标识符发送给用户，由服务器端的数据库存储每个标识符对
应的页面设置。
五、cookie的发送
1.创建Cookie对象
2.设置最大时效
3.将Cookie放入到HTTP响应消息头
如果你创建了一个cookie，并将他发送到浏览器，默认情况下它是一个会话级别的cookie:存储在浏览器的内存
中(服务器自动创建一个cookie并将jsessionId作为key,sessionId的值作为value发送到客户端浏览器内存中)，
用户退出浏览器之后被删除。如果你希望浏览器将该cookie存储在磁盘上，则需要使用maxAge，并给出一个以
秒为单位的时间。将最大时效设为0则是命令浏览器删除该cookie。发送cookie需要使用HttpServletResponse的
addCookie方法，将cookie插入到一个Set-Cookie　HTTP请求消息头中。由于这个方法并不修改任何之前指定的
Set-Cookie消息头，而是创建新的消息头，因此我们将这个方法称为是addCookie，而非 setCookie。同样要记住响应
消息头必须在任何文档内容发送到客户端之前设置。
六、cookie的读取
1.调用request.getCookie
要获取有浏览器发送来的cookie，需要调用HttpServletRequest的getCookies方法，这个调用返回Cookie对象的数组，
对应由HTTP请求中Cookie消息头输入的值。
对数组进行循环，调用每个cookie的getName方法，直到找到感兴趣的cookie为止，cookie与你的主机(域)相关，
而非你的 servlet或JSP页面。因而，尽管你的servlet可能只发送了单个cookie，你也可能会得到许多不相关的cookie。 例如：(login.jsp页面cookie实现用户名userName填写)
login.jsp：
&lt;%
String username = “”;
//从客户端读取硬盘中的cookie文件
Cookie[] cookies = request.getCookies();
if(cookies == null){
username = “”;
}
else{
for (int i = 0; i &lt; cookies.length; i++){
if (“USERNAME”.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed574ceedac4857a21e9a661d5ac8c58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/007ded1f161e3c8a77ef7171fe1bb4c1/" rel="bookmark">
			Flutter json解析报错：NoSuchMethodError: The getter &#39;inputs&#39; was called on null
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NoSuchMethodError: The getter 'inputs' was called on null. 是缓存造成的，
参考：https://github.com/dart-lang/build/issues/1804
解决方法：找到flutter工程的.dart_tool，清空目录下文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35bf4f2a58fd9c32db6028c2d503a770/" rel="bookmark">
			max(X,Y),min(X,Y)的期望
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		核心是去max和min符号：
举个应用的例子：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd2c79d98b3089142f9d97a8939d63cf/" rel="bookmark">
			split和rsplit、strip和rstrip以及lstrip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 split和rsplit split:从前往后分割，可以指定分割多少次。
rsplit:从后往前分割，可以指定分割多少次。
参数：sep：分隔符，可省略，默认是空格。count:分割次数，默认是分隔符的个数
例如：
s = 'asd dfdf ff' s.split(' ',1) &gt;&gt;&gt; ['asd', 'dfdf ff'] s.rsplit(' ',1) &gt;&gt;&gt; ['asd dfdf', 'ff'] strip和rstrip以及lstrip strip用于去除字符串的首尾字符，同理，lstrip用于去除左边的字符，rstrip用于去除右边的字符。
这三个函数都可传入一个参数，指定要去除的首尾字符。
需要注意的是，传入的是一个字符数组，编译器去除两端所有相应的字符，直到没有匹配的字符，比如：
theString = 'saaaay yes no yaaaass' print(theString.strip('say')) theString依次被去除首尾在['s'，'a'，'y']数组内的字符，直到字符在不数组内。 所以，输出的结果为： yes no lstrip和rstrip原理是一样的。
注意：当没有传入参数时，是默认去除首尾空格的。
theString = 'saaaay yes no yaaaass' print(theString.strip('say')) print(theString.strip('say ')) #say后面有空格 print(theString.lstrip('say')) print(theString.rstrip('say')) &gt;&gt;&gt; &gt;&gt;&gt; yes no &gt;&gt;&gt;es no &gt;&gt;&gt; yes no yaaaass &gt;&gt;&gt;saaaay yes no 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad4435565466d1c626c90b622165fa2b/" rel="bookmark">
			vue报错：[Vue warn]: Property or method &#34;name&#34; is not defined on the instance but referenced.....
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因:在data中没有定义一个page_data, 致错
解决方法:在data中定义一个page_data=" ",
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49aec0de57a53c98fd3a702563bd57ec/" rel="bookmark">
			Java序列化的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序列化和反序列化
序列化：可以将对象转化成一个字节序列，便于存储。
反序列化：将序列化的字节序列还原
优点：可以实现对象的”持久性”， 所谓持久性就是指对象的生命周期不取决于程序。
原生序列化方式 序列化方式一： 实现Serializable接口(隐式序列化)
通过实现Serializable接口，这种是隐式序列化(不需要手动)，这种是最简单的序列化方式，会自动序列化所有非static和 transient关键字修饰的成员变量。
class Student implements Serializable{ private String name; private int age; public static int QQ = 1234; private transient String address = "CHINA"; Student(String name, int age ){ this.name = name; this.age = age; } public String toString() { return "name: " + name + "\n" +"age: " + age + "\n" +"QQ: " + QQ + "\n" + "address: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49aec0de57a53c98fd3a702563bd57ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/181a636a5849a23f7bd5637a5d2448f9/" rel="bookmark">
			TLS密码套件TLS_ECDHE含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 解构如下：
ECDHE_RSA：密钥协商交换算法
ECDHE：使用基于椭圆曲线签密方案（EC, Elliptic Curve）的 Diffie-Hellman（DH）密钥协商协议。尾部的 E 为 Ephemeral 首字母，表示协商的是临时会话密钥。相对每次会话协商的临时密钥，证书中的公钥则是永久的（long-term）。
RSA：证书公钥加密算法，用于对证书数据部分的散列值进行签密、对 ECDHE 交换参数（的 HASH 值）进行签密。可能替换值为 ECDSA（椭圆曲线数字签名算法）。
rfc4492 &amp; rfc5289 定义了该 CipherSuite 的具体实现。
the long term authenticity is confirmed via the server cert’s RSA signature but the transient keys are derived via ephemeral EC keys (which then generate the symmetric key)
ECDHE-RSA uses Diffie-Hellman on an elliptic curve group while DHE-RSA uses Diffie-Hellman on a modulo-prime group.
AES_128_GCM：传输会话（对称）加解密使用 GCM 模式的 AES-128 算法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/181a636a5849a23f7bd5637a5d2448f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c84bb43ad4288c7b61e7e2ee4528e633/" rel="bookmark">
			虚表指针初始化顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无继承时： 1、分配内存
2、初始化列表之前赋值虚表指针
3、列表初始化
4、执行构造函数体
有继承时： 1、分配内存
2、基类构造过程（按照无继承来）
3、初始化子类虚表指针
4、子类列表初始化
5、执行子类构造函数体
Q:虚表指针在初始化列表之前被赋值，可以放在初始化列表之后赋值吗？即顺序是：列表初始化、虚表指针赋值、构造函数体？？ class B { public: virtual int size(){return 0;} }; class A:public B{ public: int m_a; A():m_a(size()) //在初始化列表中调用了虚函数（应该是A类的size()函数，不应该是B类的size()函数） { cout&lt;&lt;m_a&lt;&lt;endl; } virtual int size(){ //cout&lt;&lt;2&lt;&lt;endl; return 1;} }; int main() { A a; return 0; } 解答：如果虚表指针的初始化在初始化列表之后的话，可能会出现如上代码所示的情况：也就是说，在初始化列表中使用了一个虚函数！！！
那么在调用此虚函数的时候，应该访问哪个虚表呢？是基类的虚表？还是当前类的虚表？
毫无疑问，应该是当前类的虚表！！！
但是在调用此虚函数的时候，虚表指针并未赋值为子类的虚表，所以无法访问当前类的虚函数，访问的依旧是基类的虚函数。
因此，将虚表指针的赋值过程应该放置在初始化列表之前，这是为了防止在初始化列表出现调用虚函数的情况！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50e62780ae84088e776ee66f7031331d/" rel="bookmark">
			大创项目学习日志（一）——中文分词软件的选择与尝试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我现在愈发觉得，互联网应该有一个垃圾回收机制——技术性的博客因为软件版本的更新早已不再适用，但却仍然占据着搜索的结果。也许以后会有一种新的计算机职业——网络清洁工。他们可以熟练地运用各种技术手段保持网上的内容总是对当下渴望某一方面知识的人是有用的。
——F.W.H
现在在哪里 中文分词是构建一个诗词相关软件的第一步。在本步中，程序应该能完成将一句古诗中的各个语法单元抽取出来的功能。这是一个很难实现的功能，所幸许多前辈们已经开发出来很棒的成品可以解决这一问题。
1.Lucene——经典与专业 Lucene可以说是最经典和专业的分词软件。最重要的是——它是完全开源的。Lucene现在已经更新到了8.0版本，并且仍然保持着极高的更新速度。Lucene使用java语言编写，可以在官网直接下载jar包和相关文档。Lucene除了分词功能外，还具有强大的归类索引，自定义字典等功能，是进行自然文本处理的强大工具。美中不足的是，其对中文的支持性很差，而且其极高的更新速度使得很多中文分词软件在与其配合上出现了问题，比如IKAnalyzer。
Lucene官方网站：http://lucene.apache.org/
蚩尤后裔博主写的Lucene入门博客：
Lucene 实战前 核心理论简述
Lucene 实战之入门案例
个人感觉写的很不错，尤其是代码对着注释敲下来可以对Lucene的机制有比较清楚的了解。可惜的是博主这系列博客的后一篇文章Lucene 中文分词器 Ik-Analyzer 使用教程在我的电脑上无法正常运行。
Lucene有时会依赖apache的common.io包，可以去apache官网下载：http://commons.apache.org/proper/commons-io/download_io.cgi
Lucene对中文的分词效果实在是太差了（一般是每个汉字都会被分成一个词），我们不妨测试一下，就用杜甫的《白帝城楼》
public class TestLucene04 { private void print(Analyzer analyzer) throws Exception{ String text = "江度寒山阁，城高绝塞楼。\r\n" + "翠屏宜晚对，白谷会深游。\r\n" + "急急能鸣雁，轻轻不下鸥。\r\n" + "彝陵春色起，渐拟放扁舟。"; TokenStream tokenStream = analyzer.tokenStream("content", text); CharTermAttribute attribute = tokenStream.addAttribute(CharTermAttribute.class); tokenStream.reset(); while (tokenStream.incrementToken()) { System.out.print(new String(attribute.toString())+"/"); } } public void testStandardAnalyzer() throws Exception{ StandardAnalyzer standardAnalyzer = new StandardAnalyzer(); print(standardAnalyzer); } public static void main(String[] args) throws Exception { // TODO Auto-generated method stub TestLucene04 a = new TestLucene04(); a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50e62780ae84088e776ee66f7031331d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbda1bac05626a51c05cc7cd29af0924/" rel="bookmark">
			摄像头移植简述(sprd)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查看dts配置，相应的引脚配置是否跟主板 一致，不一致需要进行修改
如果dts下没有相应摄像头的配置(如只配置了后摄)，可搜索其他的板级的配置，并复制过来
2.找到相应的BoardConfig.mk，配置摄像头信息
TARGET_BOARD_NO_FRONT_SENSOR := true
TARGET_BOARD_SENSOR2_SUPPORT := false
TARGET_BOARD_SENSOR3_SUPPORT := false
#camera sensor type
CAMERA_SENSOR_TYPE_BACK := "gc030a"
#CAMERA_SENSOR_TYPE_FRONT := "ov5675_mipi_raw"
#CAMERA_SENSOR_TYPE_BACK_EXT :=
#CAMERA_SENSOR_TYPE_FRONT_EXT :=
3.配置相应的摄像头vendor/sprd/modules/libcamera/sensor/sensor_cfg.c
如后摄gc030a
#ifdef GC030A
extern SENSOR_INFO_T g_gc030a_mipi_raw_info;
#endif
const SENSOR_MATCH_T back_sensor_infor_tab[] = {
#ifdef GC030A
{MODULE_SUNNY, "gc030a", &amp;g_gc030a_mipi_raw_info, {NULL, 0}, NULL},
#endif
}
并将驱动文件放在vendor/sprd/modules/libcamera/sensor/sensor_drv/classic/
然后mmm vendor/sprd/modules/libcamera/进行编译，将libcamsensor.so放到system下，并将/data/misc/media下面的文件进行删除，重启即可验证。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c40220d2484a852f85f450a14bc4633e/" rel="bookmark">
			Nmap扫描原理（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nmap是一款开源免费的网络发现（Network Discovery）和安全审计（Security Auditing）工具。软件名字Nmap是Network Mapper的简称。Nmap最初是由Fyodor在1997年开始创建的。随后在开源社区众多的志愿者参与下，该工具逐渐成为最为流行安全必备工具之一。最新版的Nmap6.0在2012年5月21日发布，详情请参见：www.nmap.org。
一般情况下，Nmap用于列举网络主机清单、管理服务升级调度、监控主机或服务运行状况。Nmap可以检测目标机是否在线、端口开放情况、侦测运行的服务类型及版本信息、侦测操作系统与设备类型等信息。
Nmap的优点：
1. 灵活。支持数十种不同的扫描方式，支持多种目标对象的扫描。
2. 强大。Nmap可以用于扫描互联网上大规模的计算机。
3. 可移植。支持主流操作系统：Windows/Linux/Unix/MacOS等等；源码开放，方便移植。
4. 简单。提供默认的操作能覆盖大部分功能，基本端口扫描nmap targetip，全面的扫描nmap –A targetip。
5. 自由。Nmap作为开源软件，在GPL License的范围内可以自由的使用。
6. 文档丰富。Nmap官网提供了详细的文档描述。Nmap作者及其他安全专家编写了多部Nmap参考书籍。
7. 社区支持。Nmap背后有强大的社区团队支持。
8. 赞誉有加。获得很多的奖励，并在很多影视作品中出现（如黑客帝国2、Die Hard4等）。
9. 流行。目前Nmap已经被成千上万的安全专家列为必备的工具之一。
1.1 Zenmap Zenmap是Nmap官方提供的图形界面，通常随Nmap的安装包发布。Zenmap是用Python语言编写而成的开源免费的图形界面，能够运行在不同操作系统平台上（Windows/Linux/Unix/Mac OS等）。Zenmap旨在为nmap提供更加简单的操作方式。简单常用的操作命令可以保存成为profile，用户扫描时选择profile即可；可以方便地比较不同的扫描结果；提供网络拓扑结构(NetworkTopology)的图形显示功能。
其中Profile栏位，用于选择“Zenmap默认提供的Profile”或“用户创建的Profile”；Command栏位，用于显示选择Profile对应的命令或者用户自行指定的命令；Topology选项卡，用于显示扫描到的目标机与本机之间的拓扑结构。
1.2 功能架构图 Nmap包含四项基本功能：
主机发现（Host Discovery）
端口扫描（Port Scanning）
版本侦测（Version Detection）
操作系统侦测（Operating System Detection）
而这四项功能之间，又存在大致的依赖关系（通常情况下的顺序关系，但特殊应用另外考虑），首先需要进行主机发现，随后确定端口状况，然后确定端口上运行具体应用程序与版本信息，然后可以进行操作系统的侦测。而在四项基本功能的基础上，Nmap提供防火墙与IDS（IntrusionDetection System,入侵检测系统）的规避技巧，可以综合应用到四个基本功能的各个阶段；另外Nmap提供强大的NSE（Nmap Scripting Language）脚本引擎功能，脚本可以对基本功能进行补充和扩展。
2 Nmap基本扫描方法 Nmap主要包括四个方面的扫描功能，主机发现、端口扫描、应用与版本侦测、操作系统侦测。在详细讲解每个具体功能之前，首先可以看看Nmap的典型用法。
2.1 用法引入 2.1.1 确定端口状况 如果直接针对某台计算的IP地址或域名进行扫描，那么Nmap对该主机进行主机发现过程和端口扫描。该方式执行迅速，可以用于确定端口的开放状况。
命令形式:
nmap targethost
可以确定目标主机在线情况及端口基本状况。
2.1.2 完整全面的扫描 如果希望对某台主机进行完整全面的扫描，那么可以使用nmap内置的-A选项。使用了改选项，nmap对目标主机进行主机发现、端口扫描、应用程序与版本侦测、操作系统侦测及调用默认NSE脚本扫描。
命令形式：
nmap –T4 –A –v targethost
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c40220d2484a852f85f450a14bc4633e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd0acaa3ff33c6c87419c33750576f5a/" rel="bookmark">
			MyEclipse10.7能否使用jdk1.8？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、问题的引出：Myeclipse10.7能否使用jdk1.8？
二、分析1-从设置上着手：
三、分析2-从发布时间着手：
四、延伸：myeclipse是从哪个版本开始支持jdk1.8？
五、追思：
六、补充：用jdk1.8的新特性“lambda表达式”进行验证
一、问题的引出：MyEclipse10.7能否使用jdk1.8？ 我的Myeclipse10.7配置的是jdk1.8，至少在我没有遇到相关问题之前我一直是这样认为的。直到我最近导入了一个maven项目，我才发现原来Myeclipse10.7并不能使用“真正的jdk1.8”。为什么这么说呢？
我先回到导入项目问题上，我查找资料后发现，原来问题出在jdk版本上：导入maven项目编译运行环境都是jdk1.8，但是我电脑好像“也是1.8”，那为什么会出问题呢？
二、分析1-从设置上着手： 我去看了下软件设置，虽然运行环境是1.8，但是这里的编译环境只有1.3--1.7版本的（这里是我改过的，之前默认好像是更低版本的），也就是说没有1.8的编译环境。我们都知道java是先编译后运行的；那么总结一下这种情况：就是用1.7的版本编译java文件，然后在1.8的环境上运行。所以我说Myeclipse10.7并不能使用“真正的jdk1.8”！
那有人可能会问了：这样编译环境和运行环境不一样不会出问题吗？我也想到了这一点，所以我去问了下谷大哥，回答是一般情况下是可以的。那什么是特殊情况呢？如果你使用了jdk1.8的“新特性”，也就是说之前版本都没有的，不能向前兼容，那么用低于1.8的环境编译就会出问题！其实我想了下觉得挺有道理的：我之前用这个软件有一段时间了，虽然编译和运行环境不一样，但是没有出现什么大问题，说明一般情况下编译环境比运行环境的版本低是不会出现什么问题的，但是涉及到新特性问题上就会出现问题。看来我用了这么久都没有使用过真正的jdk1.8啊…… 三、分析2-从发布时间着手： 在这我们也可以从发布时间来看下：
1. Myeclipse10.7.1 版本：
于2013年2月7日发布，该版本同样基于 Eclipse 3.7.2。与MyEclipse 10.6相比，MyEclipse 10.7.1 主要进行了多项bug修复和其他功能细节改进。
2. jdk1.8的发布（图来自维基百科）
从下图中我们可以看出jdk1.8首发时间是2014年3月（18日）。
也就是说Myeclipse10.7.1在jdk1.8出现之前就有了。所以按理说Myeclipse10.7.1是不能使用jdk1.8的，除非它后期又加了新的功能，进行了支持，但是那样的它还叫Myeclipse10.7.1吗？据我了解至少这个版本后期是没有加入支持jdk1.8的功能的。
四、延伸：myeclipse是从哪个版本开始支持jdk1.8？ 那么myeclipse是从哪个版本开始支持jdk1.8的呢？？我之前找了好久，好像没有没有令我满意的答案，说法都很模糊，不是说使用最新版的，就是说使用以后的版本。
后来我又去找了下相关问题，在官网版本介绍里（https://www.genuitec.com/products/myeclipse/deliverylog/ci/）找到了，myeclipse2015版基于eclipse4.4，开始支持jdk1.8……所以所说应该是从这个版本开始支持jdk1.8的。
五、追思： 虽然网上一大堆类似：“给Myeclipse10.7配置jdk1.8环境”的帖子，他们是“只知其一，不知其二！”
但是经过我的个人探索或实践，发现这并不是真正的jdk1.8，而是伪“1.8”。
我并不是说他们写的不对（不过确实是有点片面了），我只是有点厌恶人云亦云，不管是非那种。人非圣贤，孰能无惑？从互联网上我们确实可以学到很多知识，但是我们要有选择的接受，明辨是非，怀着求真务实之心。我希望这篇文章能给你点启示。
六、补充：用jdk1.8的新特性“lambda表达式”进行验证 实践是检验真理的唯一标准！其实最简单的办法就是看myeclipse10里面能不能使用jdk1.8的语法，jdk1.8的一个重要的新特性就是lambda表达式，下面就试下：
List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); list.add(12); list.add("hello"); // 1.使用普通foreach遍历list（jdk1.5开始支持） System.out.println("1.使用普通foreach遍历list（jdk1.5开始支持）:"); for (Object object : list) { System.out.println("object:" + object); } // 2.使用lambda表达式遍历list（jdk1.8开始支持） System.out.println("\n2.使用lambda表达式遍历list（jdk1.8开始支持）:"); list.forEach(object -&gt; { System.out.println("object:" + object); }); 如果不支持会直接报语法错误，如果支持则会输出：
1.使用普通foreach遍历list（jdk1.5开始支持）:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd0acaa3ff33c6c87419c33750576f5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba5eb3cb6b7583f3635daa07058c3ca4/" rel="bookmark">
			邓俊辉 数据结构 第三章 栈和队列 笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		栈接口与实现 如果颠倒过来，会导致O(n)的复杂度 复杂度正比与后继成正比
进制转换 括号匹配 问题：视频中括号不匹配的那个例子，如{（]），邓老师说用栈实现的话可以发现不匹配从而告知失配，这里是否给了一个前提“栈实现的时候告知了程序哪种左右括号是相配对的”，不然栈如何发现这两个左右括号不是配对的呢？
那么在给了多个计数器的情况下，若是也告知程序这个前提，遇到相配对的右括号时相应的计数器再减1，那么不就能实现了吗？（by W_X ）
答：这个例子是 [ ( ] )，方括号计数器、圆括号计数器都是 0 到 1 到 0，会判定成匹配的（by yuantailing 老师）
栈混洗 中缀表达式求值 如果这么写，不能保证两个 pop 的执行顺序。执行顺序因编译器和编译优化而异。（by yuantailing 老师）
逆波兰表达式 问题：中缀表达式完成了计算……那么为什么还要转化一个RPN（by 蔡一不二 ）
答：同样长度（指同样多操作数）的 RPN 比中缀表达式算得快。
课件上的转换例子，每个操作数都是一个具体的数，把中缀表达式转成 RPN 的过程已经足以把中缀表达式计算出来了。正如你所理解的，这种情况下转成 RPN 再计算得不偿失。
但是，操作数可能是一个未知数。例如中缀表达式 (a + b) * c 分别代入 n 组具体数字计算表达式值，例如代入 (a=1,b=2,c=3) 、 (a=4,b=5,c=6) 、 (a=10,b=11,c=12) 求值。不转就要算 n 次中缀表达式，转就只要转 1 次 + 算 n 次 RPN 。（by yuantailing 老师）
队列接口与实现 问题：基于List来实现Queue的时候是否需要像基于Vector来实现Stack那样注意方向性呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba5eb3cb6b7583f3635daa07058c3ca4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/250db4f21caf2da45490773aa1383f70/" rel="bookmark">
			Tensorboard 打不开图，或者命令行运行出错解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：
我在使用 t e n s o r b o a r d tensorboard tensorboard 的时候出现了一些问题，首先是 t e n s o r b o a r d tensorboard tensorboard 运行正常， e v e n t s events events 文件也存在，但是找不到图，如图所示：
这可能是我的命令行输入有问题，我的输入是
tensorboard --logdir='logs' 这里是不需要引号的。。。
修改后：
tensorboard --logdir=logs B u t ! But! But! 出现了新的问题：
TypeError:GetNext() takes 1 positional argument but 2 were given 如图所示：
参考了 G i t h u b Github Github 上的解决方案：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/250db4f21caf2da45490773aa1383f70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e25eb10121ad7ef05dad1e5527222b2f/" rel="bookmark">
			可重构计算处理器技术【阅读笔记】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 可重构计算处理器技术Tips可重构计算可重构计算方式可重构计算应用领域特点颗粒度任务编译 ==为什么可重构计算==可重构计算处理器的硬件架构==可重构的实现====数据通路==运算单元阵列(PEA)设计要点片上程序管理器为什么需要片上程序管理器 ==控制单元====存储单元== 可重构计算处理器的==编译技术==任务编译任务编译器架构任务编译关键技术1.代码变换及优化==为什么要代码变换及优化====如何实现代码变换及优化== 2.任务时域划分==为什么要任务时域划分====如何实现任务时域划分== 3.内部存储器管理==为什么需要内部存储器管理====如何实现内部存储器管理== 4.配置信息优化==为什么要配置信息优化====如何实现配置信息优化== 面向通用计算的可重构技术可重构通用计算的技术问题 可重构计算处理器技术 Tips 可重构计算 两个特点：
制造后芯片的功能单元具有可重构能力能实现很大程度的算法到计算引擎的空间映射 可重构计算方式 可重构计算采用的是一种将指令流驱动处理器的功能灵活性和数据流驱动处理器的高能量效率
(即性能功耗比) 结合在一起的计算方式，其在性能、功耗和功能灵活性等芯片的关键指标之间具有更好的平衡。
可重构计算处理器可以在运行时通过配置流来动态改变运算单元阵列的功能 ，然后通过数据流来驱动运算单元阵列进行计算，因此是一种由配置流和数据流来共同驱动的计算方式。
可重构计算应用领域特点 计算密集、数据间依赖关系较弱、运算形式规则且具备较强并行性、控制流和数据流能够有效分离等
颗粒度 颗粒度指的是数据的最小位宽 。
任务编译 将应用程序通过任务划分、代码变换、任务调度及映射等过程，最终将应用程序编译生成可重构计算处理器中主控制器的控制码和可重构硬件的配置信息
为什么可重构计算 传统计算技术：基于指令流驱动，基于数据流驱动都有缺陷
指令流驱动的处理器通常具有很强的灵活性，但指令驱动的执行方式、有限的运算单元和存储带宽，使得此类处理器的整体性能和功耗很不理想；数据流驱动的处理器计算类型称为定制计算或者专用计算，专用计算根据特定的应用来定制电路结构，无需指令集，其执行速度因而很快、功耗很低，但其灵活性和扩展性很差，无法满足层出不穷、不断演进的应用需求。 可重构计算处理器的硬件架构 ![1554254030036](C:\Users\Li Tianyang\AppData\Roaming\Typora\typora-user-images\1554254030036.png)
与传统的指令流驱动处理器一样，可重构处理器也主要由控制单元、数据通路、存储器和输入/输出接口组成
可重构的实现 与指令流处理器的主要差别在于，控制单元通过配置信息而不是指令来控制数据通路的行为，存储器当中所存储的指令也被配置信息所取代
数据通路由运算单元阵列PEA组成，阵列内部继承了众多基本算术运算单元（如加法器，乘法器等）和逻辑运算单元（如与、或、非等逻辑门），控制单元通过配置信息来选择和组织这些运算单元，以实现特定的功能
数据通路 PEA实例：![1554255381992](C:\Users\Li Tianyang\AppData\Roaming\Typora\typora-user-images\1554255381992.png)
运算单元PE通过路由逻辑互相连接组成PEAPEA通过I/O buffer和AHB接口与存储器交换数据PEA通过Config context buffer和AHB接口与控制单元和存储器交换配置信息PEA通过Interrupt接口向控制单元发送中断信号 数据通路通常包含多个PEA：![1554258133141](C:\Users\Li Tianyang\AppData\Roaming\Typora\typora-user-images\1554258133141.png)
这些PEA被片上程序管理器(On-chip program manager)——硬件模块加以控制，以最大限度地提高PEA的计算效率
运算单元阵列(PEA)设计要点 PE 通常由一个算术逻辑单元 (ALU)，多个多路选择器 (MUX)、以及输入输出寄存器组成
![1554260871374](C:\Users\Li Tianyang\AppData\Roaming\Typora\typora-user-images\1554260871374.png)
可重构计算处理器的控制单元通过配置信息来选择 ALU 的不同功能，选择MUX 的不同输入，并选择存储在不同的寄存器里，从而实现单个 PE 的功能重构，进一步就实现了PEA 的功能重构
核心设计参数：PE的颗粒度、PEA的同构和异构方式、PEA的配置方式和配置深度、PEA的拓扑结构和路由策略、PEA的接口技术、PEA的计算模型
PE的颗粒度选择：颗粒度越小，灵活性越大，但配置信息多；颗粒度越大，配置信息少，但灵活性小，对低位宽数据的运算效率低下。影响：很大程度上影响了重构的通信代价和计算性能PEA的同构和异构方式选择：同构的PE阵列相对规整，控制简单，实现起来容易，但灵活性小；异构的PE阵列相对灵活，但控制逻辑复杂。影响：控制逻辑复杂程度；PE阵列能够支持的配置模板数量PEA的配置方式和配置深度选择：静态配置的方式控制逻辑简单，但无法体现实时重构的特性，灵活性小；动态配置灵活性高，但控制逻辑复杂，面积消耗大。较小的配置深度对硬件资源要求小，但对并行计算的支持能力较低；较大的配置深度对硬件资源的要求较高，对调度能力的要求也高。影响：很大程度上决定了PE阵列的计算性能PEA的拓扑结构和路由策略选择：复杂的拓扑和路由策略可以实现较完整的互连，但是重构的通信代价和面积开销都比较大；简单的拓扑和路由策略又不足够灵活 。影响：很大程度上决定了PE阵列的灵活程度PEA的接口方式选择：PE阵列和控制单元得过于紧密，通信代价很小, 但是灵活性不够；耦合得过于松散，通信代价太高，控制单元对PE阵列的控制力随之减弱。影响：对数据吞吐率有重要影响，很大程度上决定了并行操作是否能够高效地进行PEA的计算模型选择：如单指令多数据SIMD、多指令多数据MIMD等。影响：决定了PE阵列计算方法，一定程度上决定了阵列的并行运行程度 片上程序管理器 为什么需要片上程序管理器 片上程序管理器配合可重构计算处理器的编译器，最大限度的挖掘程序间的并行性，动态地协调不同粒度PEA间, 以及PEA与控制单元间的关系，控制 PEA 进行并发的配置和运算，最终能够以最小的时间和能耗代价，实现多道程序的并发执行 ；而且片上程序管理器还负责PEA的数据流和配置流的管理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e25eb10121ad7ef05dad1e5527222b2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69657a199af4e196044063bfdd4a0dde/" rel="bookmark">
			为什么国内的高龄程序员都会被淘汰
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景:
今天与Firebase的中国区开发及负责人交流了一下Filebase相关功能，感触还是挺深的。
最直接的感受就是国内的大部分开发都旋入了开发能力与资源不足的恶性循环中
今天在交流过程中，firebase重点提到了两个功能，一个是Predictions（预测），另一个是A/B Testing （A/B测试）
Firebase虽然也是一个工具库，但是它的定位是从开发-&gt;线上监测-&gt;变现能力的整个链路的打通。
就以预测功能来说，依托于目前Google Ad与GP的数据，就可以预测我们每个用户的留存情况与是否会是消费用户，而且目前可以达到70%左右的准确度，这样就可以依托于这些数据来做一些变现的能力，
举一个简单的例子，现在大部分互联网游戏或工具类产品的盈利方式主要是靠广告与IAP方式，但是对于有消费能力的用户如果我们弹广告的话，势必会影响有消费能力这部分用户的留存，但机遇firebase的预测功能，对于这些有消费潜力的用户，我们可以不弹广告，对于没有消费价值的用户，我们可以通过广告方式盈利。
还有一个优势，就是我们可以将我们的优质用户列表不断的通过server2server的方式反馈给Firebase，这样就能不断的优化预测的准确度，最终实现一个正向结果。
而且其实firebase的实现方式也是很简单，firebase可以知道用户是否有绑定过银行卡，是否购买过类似的应用历史，之后再经过机器学习进行模型训练就可以达到预测的效果。
另一个A/B测试其实是我们一直在使用的功能，但是对比之后，发现这并不仅仅是技术的差距，思维的方式更加严重，
我们之前的A/B测试，都是根据标志位来区分几批用户，然后通过不同批次用户的不同打点，进行对比分析，这个思路基本上是相似的，但是有几个问题：
1.没有办法根据批次用户来计算留存情况
2.很多具体的指标只能自己根据数据来计算
但Firebase的A/B测试是将用户区分出来之后，会分批计算留存，IAP和自己定义的一些关注指标，这样对于使用者来说及其方便，而且对比效果也会特别明显，因为每次A/B测试不可能只看一项指标，一定是多项指标的中和结果才会确定到底哪个方案更好的。
这个稍微思考一下，要想做到也很简单，首先我们将分批用户的区分标志位放到云控文件中，云控文件与我们的数据查询系统打通，这样我们查询计算的时候，就可以做到分批次单独计算指标了
还介绍了一些其他的功能，但感觉没有这两个感触深了。
其实我们对比之后，有一些功能确实我们很难去与之匹配的，例如预测功能，确实要基于大量的用户与数据。
但也有一些真的是因为我们并没有花时间与心思来思考（当然我并不认为是我们想不到），我们做到的仅仅是能用，但是具体是否真的好用和能否为使用者解决痛点，其实是值得推敲的。
最后回到我们今天的主题，我们国内的很多高龄程序员趋于被淘汰我觉得分为两方便原因吧
客观原因：国内的加班太严重，很多高龄程序员的精力一定比不上年轻人。
主观原因：国内很少有人有长期的积累，原因就不说了，这就导致经常是年龄与能力不匹配，自然而然的会慢慢被淘汰。
所以我们无论身处何种公司，何种职位，做任何事情，都想办法再深入一步，这不仅仅是对工作的负责，其实更是对自己负责，我们做了一个技术，不是因为技术多么炫酷，主要还是因为能创造的价值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ab5b7e451ac259105f4ac6f929f1a7/" rel="bookmark">
			内置函数总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内置函数 1.abs（）:返回对象的绝对值
num = 10
num1 = -10
print('abs(num,num1)')
2.all():接受一个可迭代的对象，若所有元素都为真，就返回True,否则返回False
3.any():接受一个可迭代的对象，若其中任何一个元素为真，则返回True,否则返回False
4.ascii():调用对象的repr 方法，获得该方法的返回值，如果ascii里面没有，则返回内置的Python2里面的对应的返回值
5.bin(),oct(),hex(): 将十进制分别转换成二进制，八进制，十六进制。
6.bool(): 返回对象的bool值
7.bytes():将一个字符串转换成字节类型的数据
8.str():将字符类型/数值类型等转换成字符串类型
9.callable() :判断对象是否为可调用的，若是可调用对象则返回True，否则返回Fasle,实际上是调用对象下的call方法，
10.chr()：查看十进制在ASCII编码表里面对应的字符
11.ord():查看一个字符在ASCII里面对应的十进制数
12.classmethod():指定一个函数的属性只能被类调用的，定义的时候要将自身传进去。
class Province: country = "中国" def __init__(self, name):
self.name = name
@classmethod
def show(cls): # 类方法，由类调用，最少要有一个参数cls，调用的时候这个参数不用传值，自动将类名赋值给cls
print(cls) 调用方式:Province.show()
13.complie() :将字符串变异成python能识别的或者可执行的代码，也可以将文字读成字符串再编译
1 compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)
2 将source编译为代码或者AST对象。代码对象能过通过exec语句来执行或者eval()进行求值。
3 参数source：字符串或者AST（abstract syntax trees）对象。
4 参数filename：代码文件名称，如果不是从文件读取代码则传递一些可辨认的值。
5 参数model：指定编译代码的种类。可以指定'exec', 'eval', 'single'。
6 参数flag和dont_inherit：这两个参数为可选参数。
1 &gt;&gt;&gt; s = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7ab5b7e451ac259105f4ac6f929f1a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f231805516be3b4ac1858739fdb937e/" rel="bookmark">
			laravel 路由404问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在创建一个laravel 项目的时候，首页能够访问
Route::get(’/’, function () {
//return view(‘welcome’);
return “Hello word!”;
});
但是添加了一个路由访问发现一直访问不了
找了很多资料都没有解决这个问题，最后在vhosts.conf文件里面添加了一段就可以了
try_files $uri $uri/ /index.php?$query_string; 备注：我用的是phpstudy 的集成环境（php 7.1.13+nginx）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7101b2a638957f8af2f1a4654aed7bd3/" rel="bookmark">
			浅出Vue 错误处理机制errorCaptured、errorHandler
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引子 JavaScript本身是一个弱类型语言，项目中容易发生错误，做好网页错误监控，能帮助开发者迅速定位问题，保证线上稳定。vue项目需接入公司内部监控平台，本人之前vue errorHooks不甚了解, 决定探一探?
介绍 errorHandler、errorCaptured 文档传送门: errorHandler、errorCaptured
errorHandler 指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例
Vue.config.errorHandler = function (err, vm, info) { #处理错误信息, 进行错误上报 #err错误对象 #vm Vue实例 #`info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子 #只在 2.2.0+ 可用 } 版本分割点 2.2.0 起，捕获组件生命周期钩子里的错误。同样的，当这个钩子是 undefined 时，被捕获的错误会通过 console.error 输出而避免应用崩溃2.4.0 起，也会捕获 Vue 自定义事件处理函数内部的错误2.6.0 起，也会捕获 v-on DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理 errorCaptured 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播
错误传播规则 默认情况下，如果全局的 config.errorHandler定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起。如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler，不能捕获异步promise内部抛出的错误和自身的错误一个 errorCaptured 钩子能够返回 false 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7101b2a638957f8af2f1a4654aed7bd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d7f9221bf54764ee8e65ec494b9b30f/" rel="bookmark">
			SQL 宏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Given the SAS data set SASUSER.HIGHWAY:
Steering Seatbelt Speed Status Count -------- -------- ----- ------- ----- absent No 0-29 serious 31 absent No 0-29 not 1419 absent No 30-49 serious 191 absent no 30-49 not 2004 absent no 50+ serious 216 The following SAS program is submitted:
proc sql noprint; select distinct Speed [_insert_SQL_clause_] from SASUSER.HIGHWAY ; quit; title1 “Speed values represented are: &amp;GROUPS”; proc print data=SASUSER.HIGHWAY; run; Which SQL clause stores the text 0-29,30-49,50+ in the macro variable GROUPS?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d7f9221bf54764ee8e65ec494b9b30f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/803e9881ae65ace22203c7947fc3bca9/" rel="bookmark">
			SQL 子查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由SAS adv 63题中
Given the SAS data sets:
WORK.EMPLOYEE WORK.NEWEMPLOYEE
Name Dept Names Salary
Alan Sales Michelle 50000
Michelle Sales Paresh 60000
A SAS program is submitted and the following is written to the SAS log:
101 proc sql; 102 select dept, name 103 from WORK.EMPLOYEE 104 where name=(select names from newemployee where salary &gt; 40000) ERROR: Subquery evaluated to more than one row.
105 ;
106 quit;
What would allow the program to successfully execute without errors?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/803e9881ae65ace22203c7947fc3bca9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41d57b50125813288245f72b5fcddf85/" rel="bookmark">
			npm audit fix报错解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是我所遇到的问题及最终的解决方法：
问题一：
:\vue\mall-vue&gt;npm audit fix
pm ERR! code ECONNRESET
pm ERR! errno ECONNRESET
pm ERR! network request to https://registry.npmjs.org/-/npm/v1/security/audits
ailed, reason: Client network socket disconnected before secure TLS connection
as established
pm ERR! network This is a problem related to network connectivity.
pm ERR! network In most cases you are behind a proxy or have bad network settin
s.
pm ERR! network
pm ERR! network If you are behind a proxy, please make sure that the
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41d57b50125813288245f72b5fcddf85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/182636d144e34fac1cf163550710091b/" rel="bookmark">
			图片处理PIL.Image模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Image模块是PIL中最重要的模块，它有一个类叫做image，与模块名称相同。Image类有很多函数、方法及属性，接下来将依次对image类的属性、函数和方法进行介绍。
一、Image类的属性
1、 Format
定义：im.format ⇒ string or None
含义：源文件的文件格式。如果是由PIL创建的图像，则其文件格式为None。
例子：
from PIL import Image
im= Image.open(“D:\Code\Python\test\img\test.jpg”)
im.format
‘JPEG’
注：test.jpg是JPEG图像，所以其文件格式为JPEG。
im= Image.open(“D:\Code\Python\test\img\test.gif”)
im.format
‘GIF’
注：test.gif为GIF文件，所以其文件格式为GIF。
2、 Mode
定义：im.mode ⇒ string
含义：图像的模式。这个字符串表明图像所使用像素格式。该属性典型的取值为“1”，“L”，“RGB”或“CMYK”。对于图像模式的介绍，可以参考我的blog“Python图像处理库PIL的基本概念介绍”。
例子：
from PIL import Image
im = Image.open(“D:\Code\Python\test\img\test.jpg”)
im.mode
‘RGB’
im = Image.open(“D:\Code\Python\test\img\test.gif”)
im.mode
‘P’
3、 Size
定义：im.size ⇒ (width, height)
含义：图像的尺寸，按照像素数计算。它的返回值为宽度和高度的二元组（width, height）。
例子：
from PIL import Image
im= Image.open(“D:\Code\Python\test\img\test.jpg”)
im.size
(800, 450)
im= Image.open(“D:\Code\Python\test\img\test.gif”)
im.size
(400, 220)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/182636d144e34fac1cf163550710091b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d36673f1957cd735bf73a808ee9e282/" rel="bookmark">
			拟牛顿法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 拟牛顿法黑塞矩阵逆矩阵的近似秩1修正公式秩1算法过程 DFP算法BFGS算法 拟牛顿法 基本思路：
为了避免 F ( x ( k ) ) − 1 F(x^{(k)})^{-1} F(x(k))−1这种矩阵求逆运算，可以通过设计其近似矩阵来代替。
x ( k + 1 ) = x ( k ) − α H k g ( k ) x^{(k+1)}=x^{(k)}-\alpha H_kg^{(k)} x(k+1)=x(k)−αHk​g(k)
拟牛顿法的迭代公式：
d ( k ) = − H k g ( k ) α k = a r g min ⁡ α ⩾ 0 f ( x ( k ) + α d ( k ) ) x ( k + 1 ) = x ( k ) + α k d ( k ) d^{(k)}=-H_kg^{(k)} \\\alpha_k=arg\min \limits_{\alpha\geqslant0}f(x^{(k)}+\alpha d^{(k)}) \\x^{(k+1)}=x^{(k)}+\alpha_kd^{(k)} d(k)=−Hk​g(k)αk​=argα⩾0min​f(x(k)+αd(k))x(k+1)=x(k)+αk​d(k)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d36673f1957cd735bf73a808ee9e282/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d48fc1e7f411b0d964587f61f103af7a/" rel="bookmark">
			Python初步自学知识总结——选择语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中的选择语句 Python提供三种选择结构：
（1）取舍结构，就是只有一种选择，要么选，要么不选，即符合某一条件就单独处理，不符合就统一处理。
（2）二选一，即一个条件，分两种情形处理。
（3）多选一，即多个条件，分多钟情形处理。
if-else型选择结构 1.if-else结构的基本特征：if-else是实现二选一的代码结构，其基本语法如下：
if 命题：
语句块1
else：
语句块2
#code01.py myAge=20 yourAge=int(input('请问你多大？')) if myAge&lt;yourAge: print('那，你是我老哥了。') else: print('那，你是我老弟了。') 运行情况如下：
请问你多大？23 那，你是我老哥了。 2.if-else退化结构
Python允许lf-else构中缺省else子结构，退化为取舍选择结构，也称为缺腿if-else结构，或简称if结构。
#code02.py x=int(input('请输入一个数：')) if x&lt;0: x=-x print(x) 运行情况如下：
请输入一个数：-9 9 3.选择表达式
if-else选择结构有两个子语句块。但是，在许多情况下，每个分支并不需要一个或多个语句，有一个表达式就可以解决问题。这时，Python允许将一个if-else结构收缩为一个表达式，称为选择表达式。其句法结构如下：
表达式1 if 命题 else 表达式2
这里，if和else称为必须一起使用的选择操作符。他的运行机理为：执行表达式1，除非命题为假才执行表达式2。
#code03.py x=int(input('请输入一个数：')) x=-x if x&lt;0 else x print(x) 运行结构如下：
请输入一个数：-9 9 if-else嵌套与if-elif选择结构 1.if-else嵌套
当一个if-else语句的分支又含有if-else语句时，便组成了嵌套型if-else选择结构。这种结构视在哪个分支嵌套以及用处的不同，又分为if分支的if-else嵌套和else分支的if-else嵌套，且这两种结构往往是可以转换的。
（1）if分支的if-else结构如下：
#code04.py age=int(input('请输入您的年龄')) if age&gt;=18: if age&gt;=66: if age&gt;80: if age&gt;=100: print('您是长寿老人。') else: print('您是老年人。') else: print('您是中年人。') else: print('您是青年人。') else: print('您是未成年人。') （2）else分支的if-else结构如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d48fc1e7f411b0d964587f61f103af7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53c3e7f85cc763413c2e0234b3554864/" rel="bookmark">
			新二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入一串二叉树，用遍历前序打出。
关于前序遍历，就是根节点的访问顺序，即根左右。同理，后序即左右根，中序即左根右
输入格式：
第一行为二叉树的节点数n。(n≤26n \leq 26n≤26)
后面n行，每一个字母为节点，后两个字母分别为其左右儿子。
空节点用表示
输出格式：
前序排列的二叉树
输入样例#1：
6
abc
bdi
cj
d**
i**
j**
输出样例#1：
abdicj
#include&lt;bits/stdc++.h&gt; using namespace std; int n; string s; int main() { cin&gt;&gt;n; cin&gt;&gt;s; for(int i=2;i&lt;=n;++i) { string ss; cin&gt;&gt;ss; int x=s.find(ss[0]); s.erase(x,1); s.insert(x,ss); } for(int i=0;i&lt;s.size();++i) if(s[i]!='*') cout&lt;&lt;s[i]; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b83e431af9bb608277e0b7d68a47cbcb/" rel="bookmark">
			similarities.SparseMatrixSimilarity源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		def __init__(self, corpus, num_features=None, num_terms=None, num_docs=None, num_nnz=None, num_best=None, chunksize=500, dtype=numpy.float32, maintain_sparsity=False): """ Parameters ---------- corpus: iterable of list of (int, float) A list of documents in the BoW format. num_features : int, optional Size of the dictionary. Must be either specified, or present in `corpus.num_terms`. num_terms : int, optional Alias for `num_features`, you can use either. num_docs : int, optional Number of documents in `corpus`. Will be calculated if not provided.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b83e431af9bb608277e0b7d68a47cbcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a3ec8e590c8e1b5917ffb18ed225678/" rel="bookmark">
			gensim &#43; tfidf计算句子之间相似度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		def get_tfidf(words_lists): texts = words_lists dictionary = corpora.Dictionary(texts) feature_cnt = len(dictionary.token2id) corpus = [dictionary.doc2bow(text) for text in texts] tfidf = models.TfidfModel(corpus) return tfidf, dictionary, corpus, feature_cnt texts：二维数组，每一行代表一个句子，内容是分词结果。
dictionary：相当于建了个字典，键：索引，值：词。
corpus：把句子转化成每个词出现多少次，[[(索引1，次数), (索引2，次数), ...],[(索引0，次数), (索引2，次数), ...]。
tfidf：以当前语料建模。
def get_semantic_similarity_for_line(words_list1, tfidf, dictionary, corpus, feature_cnt): kw_vector = dictionary.doc2bow(words_list1)#(jieba.lcut(keyword)) index = similarities.SparseMatrixSimilarity(tfidf[corpus], num_features=feature_cnt) sim = index[tfidf[kw_vector]] return sim words_list1：某个句子的分词结果。
kw_vector：相当于某个句子的corpus值，[(索引1，次数), (索引2，次数), ...]。
tfidf[corpus]：对corpus计算tfidf并转化为[(索引1，tfidf), (索引2，tfidf), ...]。
tfidf[kw_vector]:根据doc2bow的结果直接获取整个句子的tfidf向量，[(索引1，tfidf), (索引2，tfidf), ...]。
index：每个item代表一个句子和其他句子的相似度。
index[tfidf[kw_vector]]：根据索引获得某个句子与其他句子的相似度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6e4add8ae16909de35143dea1eab433/" rel="bookmark">
			Bootstrap&#39;s JavaScript requires jQuery version 1.9.1 or higher,
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower th
清空浏览器缓存，好了。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe396874a40762d1e50f672e892a306d/" rel="bookmark">
			Java中collection.toArray(new String[0])的语法解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Collection的公有方法中，toArray()是比较重要的一个。
但是使用无参数的toArray()有一个缺点，就是转换后的数组类型是Object[]。 虽然Object数组也不是不能用，但当你真的想用一个具体类型的数组，比如String[]时，问题就来了。而把Object[]给cast成String[]还是很麻烦的,需要用到这个：
String[] stringArray = Arrays.copyOf(objectArray, objectArray.length, String[].class);
不管是从哪方面看还是一开始就弄成String[]比较好。
具体怎么办呢？其实用带参数的toArray就好了。官方是这样给出的例子：
String[] a = c.toArray(new String[0]);
像 toArray 方法一样，此方法充当了基于数组的 API 与基于 collection 的 API 之间的桥梁。更进一步说，此方法允许在输出数组的运行时类型上进行精确控制，并且在某些情况下，可以用来节省分配开销。
假定 l 是只包含字符串的一个已知 List。以下代码用来将该列表转储到一个新分配的 String 数组： String[] x = (String[]) v.toArray(new String[0]);
注意，toArray(new Object[0]) 和 toArray() 在功能上是相同的。 &lt;T&gt; T[] toArray(T[] a);
泛型
会返回你一个list长度的String 类型的数组
需要一个T[] a,new String[0]相当于开辟了一个长度为0的String[],并且指定了泛型。这样函数的调用是将list转换了一个String的数组。
这里的用new String[0]只是为了指定函数的形参数，最终返回的String[]的长度是由你的list存储内容的长度决定了。
new String[0]就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型
ArrayList.toArray()需要返回String [] “串对象数组” 类型，
要求调用参数也必须是 “串对象数组”，
new String[] 就是生生一个“串对象数组”，[0]表示元素个数为零。
只是 一个类型标示，用来告诉toArray方法具体转化成什么类型。
list.toArray(new String[0]);//转化成String数组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe396874a40762d1e50f672e892a306d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cd38fcfe6f16a0cca0b4e443e36821e/" rel="bookmark">
			如何在新版csp网站上刷题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CCF目前已经推出新版CSP网站，许多小可爱问过我怎么在新版CSP网站上刷题，这篇博客主要说一下如何进入CSP刷题页面。
首先进入新版CSP网址 http://www.cspro.org/ ，如果已有账号点击登录，没有账号先注册一个再登录，如下图所示：
点击注册后的注册页面如下：
登录页面如下：
点击登录后，在新页面中点击报名考试，如下：
在新页面中点击模拟考试，会弹出一个题目列表的窗口，如下图所示：
在题目页面中，选择自己要刷的题目，点击查看试题/答题。
点击查看试题/答题后就可以进入刷题页面了，按提示操作即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a2e686ea43aa0b6c6034594738b89d3/" rel="bookmark">
			Unable to open socket file: target process not responding or HotSpot VM not loaded异常处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题 某台服务器出现假死的现象，服务进程在，但是就是不工作。于是想定位下，先看了下服务器本身的状态都是OK的，然后看下服务的状态，先执行如下的命令，发现服务是存在的，如下：
执行jps -ml输出如下：
然后执行jstack 2276,报出如下的错误：
2276: Unable to open socket file: target process not responding or HotSpot VM not loaded The -F option can be used when the target process is not responding 2.解决 经过检查发现jstack后面的进程不是在root用户执行的，jstack需要使用与进程一致的用户才能执行。
执行ps -aux也能看出进程是由scehdule用户执行的。
于是执行sudo -u schedule `jstack 2276,能够正确执行，结果如下：
3.结论 jstack需要使用与进程一致的用户才能执行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/493a10d27042537976594c8a1679b238/" rel="bookmark">
			嵌入式_安装串口驱动以及串口链接XShell
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装驱动以及串口连接XShell 前期准备：安装驱动精灵，XShell软件
步骤：先将串口插入电脑：（注意串口插入电脑的USB接口后在以后的实验过程中不要随意改动，因为每个USB接口都有自己的标识，USB端插入电脑，另一端可不连开发板）
首先打开驱动精灵，界面如下：
点击立即检测， 界面如下
在驱动管理栏目中，“驱动异常”点击安装
点击后进入设备异常栏目，PL2303USB转串口驱动1.16版点击安装
（注意：如果没看到点击刷新）
安装开始：
安装完成：
连接XShell
点击此电脑-&gt;管理-&gt;设备管理器：（目的：查询端口编号）
端口只有插入USB转串口数据线才能出现：
PC机与开发板之间连线！！！
将产品附带串口线一端连接到 PC 机端串口，另一端连接到 UP-MobNet-II 型系统串口 0(RS232-0 即开 发板左侧起靠近网口的串口)上。将产品附带 USB 数据线连接 PC 机 USB 口与 UP-MobNet-II 型平台 OTG 接口。（烧写系统时用的到，本实验无需用到）网线电源线 跳线： 将 UP-CUP IOT-4412-II 核心板上跳线设置成 iNAND 烧写模式。 如下： OM5 OM4 OM3 OM2 OM1: 1 1 1 0 0
备注：核心板内侧为 1，外侧为 0，跳线模式出厂已经默认跳到 iNAND 启动模式。
观察COM的编号：此编号为COM3：
配置XShell：
打开XShell点击新建：协议改为：SERIAL：
点击左栏的SERIAL
填写port，baud rate：
点击连接：
连接成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf5afdf900fca22e414e36f06b0c5ebc/" rel="bookmark">
			ansible从入门到实践(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ansible playbook 简介 ansible 是什么？
ansible是新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。
ansible是基于 paramiko 开发的,并且基于模块化工作，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。ansible不需要在远程主机上安装client/agents，因为它们是基于ssh来和远程主机通讯的。ansible目前已经已经被红帽官方收购，是自动化运维工具中大家认可度最高的，并且上手容易，学习简单。是每位运维工程师必须掌握的技能之一。
ansible 特点?
1.部署简单，只需在主控端部署Ansible环境，被控端无需做任何操作；
2.默认使用SSH协议对设备进行管理；
3.有大量常规运维操作模块，可实现日常绝大部分操作；
4.配置简单、功能强大、扩展性强；
5.支持API及自定义模块，可通过Python轻松扩展；
6.通过Playbooks来定制强大的配置、状态管理；
7.轻量级，无需在客户端安装agent，更新时，只需在操作机上进行一次更新即可；
8提供一个功能强大、操作性强的Web管理界面和REST API接口——AWX平台。
ansible 架构图
1.sible：Ansible核心程序。
2.HostInventory：记录由Ansible管理的主机信息，包括端口、密码、ip等。
3.Playbooks：“剧本”YAML格式文件，多个任务定义在一个文件中，定义主机需要调用哪些模块来完成的功能。
4.CoreModules：核心模块，主要操作是通过调用核心模块来完成管理任务。
5.CustomModules：自定义模块，完成核心模块无法完成的功能，支持多种语言。
6.ConnectionPlugins：连接插件，Ansible和Host通信使用
ansible 任务执行 ansible 任务执行模式
Ansible 系统由控制主机对被管节点的操作方式可分为两类，即adhoc和playbook：
1.ad-hoc模式(点对点模式)
使用单个模块，支持批量执行单条命令。ad-hoc 命令是一种可以快速输入的命令，而且不需要保存起来的命令。就相当于bash中的一句话shell。
2.playbook模式(剧本模式)
是Ansible主要管理方式，也是Ansible功能强大的关键所在。playbook通过多个task集合完成一类功能，如Web服务的安装部署、数据库服务器的批量备份等。可以简单地把playbook理解为通过组合多条ad-hoc操作的配置文件。
ansible 命令执行过程
1.加载自己的配置文件，默认/etc/ansible/ansible.cfg；
2.查找对应的主机配置文件，找到要执行的主机或者组；
3.加载自己对应的模块文件，如 command；
4.通过ansible将模块或命令生成对应的临时py文件(python脚本)， 并将该文件传输至远程服务器；
5.对应执行用户的家目录的.ansible/tmp/XXX/XXX.PY文件；
6.给文件 +x 执行权限；
7.执行并返回结果；
8.删除临时py文件，sleep 0退出；
ansible 配置详解 一.准备环境
4台cenos7.4 的机器
分别为：
192.168.137.130 node.cwf.com node
192.168.137.131 node1.cwf.com node1
192.168.137.132 node2.cwf.com node2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf5afdf900fca22e414e36f06b0c5ebc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fce26c6d3c0a5dd82a27cbb3cf4a001/" rel="bookmark">
			es ingest-attachment的安装与使用 个人记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版本号： es 5.4
es数据库的安装略； linux:在es数据库的目录下有个bin文件夹在这个文件夹下执行
./elasticsearch-plugin install ingest-attachment 会直接安装ingest-attachment插件
windows:在es数据库的目录下有个bin文件夹在这个文件夹下执行
elasticsearch-pluginbat install ingest-attachment
或者通过其他的渠道货渠道ingest-attachment插件的文件防止到es数据库目录下的pugins文件夹下也可以
在安装完插件之后需要重起节点，集群的每个节点都需要安装
使用 创建自己的文本抽取管道pipeline
其中url里的attachment可以自定义
curl -X PUT "localhost:9200/_ingest/pipeline/attachment" -d '{ "description" : "Extract attachment information", "processors":[ { "attachment":{ "field":"data", "indexed_chars" : -1, "ignore_missing":true } }, { "remove":{"field":"data"} }]}' 若想保存传入的base64数据则去掉
{ "remove":{"field":"data"} } 插入base64数据
curl -X PUT "localhost:9200/pdftest/pdf/1?pipeline=attachment" -d ' { "data":"QmFzZTY057yW56CB6K+05piOCuOAgOOAgEJhc2U2NOe8lueggeimgeaxguaKijPkuKo45L2N5a2X6IqC77yIMyo4PTI077yJ6L2s5YyW5Li6NOS4qjbkvY3nmoTlrZfoioLvvIg0KjY9MjTvvInvvIzkuYvlkI7lnKg25L2N55qE5YmN6Z2i6KGl5Lik5LiqMO+8jOW9ouaIkDjkvY3kuIDkuKrlrZfoioLnmoTlvaLlvI/jgIIg5aaC5p6c5Ymp5LiL55qE5a2X56ym5LiN6LazM+S4quWtl+iKgu+8jOWImeeUqDDloavlhYXvvIzovpPlh7rlrZfnrKbkvb/nlKgnPSfvvIzlm6DmraTnvJbnoIHlkI7ovpPlh7rnmoTmlofmnKzmnKvlsL7lj6/og73kvJrlh7rnjrAx5oiWMuS4qic9J+OAggoK44CA44CA5Li65LqG5L+d6K+B5omA6L6T5Ye655qE57yW56CB5L2N5Y+v6K+75a2X56ym77yMQmFzZTY05Yi25a6a5LqG5LiA5Liq57yW56CB6KGo77yM5Lul5L6/6L+b6KGM57uf5LiA6L2s5o2i44CC57yW56CB6KGo55qE5aSn5bCP5Li6Ml42PTY077yM6L+Z5Lmf5pivQmFzZTY05ZCN56ew55qE55Sx5p2l44CC" }' java api的使用 获取es连接的步骤这里就省略了，网上一搜一大把
以下以传入数据是map为例
Map&lt;String,String&gt; source=new HashMap&lt;String,String&gt;();
source.put("tital","java 插入");
source.put("data","QmFzZTY057yW56CB6K+05piOCuOAgOOAgEJhc2U2NOe8lueggeimgeaxguaKijPkuKo45L2N5a2X6IqC77yIMyo4PTI077yJ6L2s5YyW5Li6NOS4qjbkvY3nmoTlrZfoioLvvIg0KjY9MjTvvInvvIzkuYvlkI7lnKg25L2N55qE5YmN6Z2i6KGl5Lik5LiqMO+8jOW9ouaIkDjkvY3kuIDkuKrlrZfoioLnmoTlvaLlvI/jgIIg5aaC5p6c5Ymp5LiL55qE5a2X56ym5LiN6LazM+S4quWtl+iKgu+8jOWImeeUqDDloavlhYXvvIzovpPlh7rlrZfnrKbkvb/nlKgnPSfvvIzlm6DmraTnvJbnoIHlkI7ovpPlh7rnmoTmlofmnKzmnKvlsL7lj6/og73kvJrlh7rnjrAx5oiWMuS4qic9J+OAggoK44CA44CA5Li65LqG5L+d6K+B5omA6L6T5Ye655qE57yW56CB5L2N5Y+v6K+75a2X56ym77yMQmFzZTY05Yi25a6a5LqG5LiA5Liq57yW56CB6KGo77yM5Lul5L6/6L+b6KGM57uf5LiA6L2s5o2i44CC57yW56CB6KGo55qE5aSn5bCP5Li6Ml42PTY077yM6L+Z5Lmf5pivQmFzZTY05ZCN56ew55qE55Sx5p2l44CC");
client.prepareIndex("test","test").setPipeline("attachment").setSource(source).excute.actionGet();
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/016d9120e4d333be98c4c944d0a5553e/" rel="bookmark">
			Latex学习笔记 (9) 段落首行缩进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Latex默认的格式中，每个章节（chapter）第一段是不缩进的，而第二段起都有缩进。这点不符合我们国人每段都有缩进的使用习惯。想要调整只需三步：
引入宏包\usepackage{indentfirst}配置缩进长度 \setlength{\parindent}{2em}。在第一段首使用加入\indent 即可。 补充：如果有第二段起的段落如果不希望缩进，在段落首加上 \noindent 即可。
[1] Latex教程: 段落格式设置(1)设置缩进, 百度经验https://jingyan.baidu.com/article/27fa732682c0f446f8271f07.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/410/">«</a>
	<span class="pagination__item pagination__item--current">411/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/412/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>