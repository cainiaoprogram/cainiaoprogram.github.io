<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe9a99276acb456e20ccf5641798c2e6/" rel="bookmark">
			Certbot实现 HTTPS 免费证书(Let‘s Encrypt)自动续期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Certbot实现 HTTPS 自动续期 以前阿里云支持申请一年的免费https证书，那每年我们手动更新证书并没什么大问题，但现在阿里云的免费证书仅支持3个月，这意味着每三个月都要要申请一下证书显得非常麻烦。
下面我们使用Certbot实现ssl证书的自动更新，这次我在Centos8的Nginx上进行演示如何配置SSL证书。
Certbot的安装 以下安装在CentOS8实操通过，其他系统可以参考：https://certbot.eff.org/instructions
要使用Certbot，首先需要安装：
yum install epel-release -y yum install certbot -y 如果你安装过程中出现 “Couldn’t open file /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-8” 的错误，是由于缺少 EPEL 存储库的 GPG 密钥导致的。这个密钥用于验证从 EPEL 存储库下载的软件包的完整性和真实性。
需要先导入 EPEL 存储库的 GPG 密钥：
rpm --import https://dl.fedoraproject.org/pub/epel/RPM-GPG-KEY-EPEL-8 然后重新安装上述安装命令即可安装成功。
生成 Let’s Encrypt 免费证书的命令参数 Let’s Encrypt 是免费 HTTPS 证书生成工具之一，由 Internet Security Research Group（ISRG）这个非营利组织提供ISRG的使命是使全球范围内的网站能够安全、自动化地使用HTTPS加密，并提供免费的 SSL/TLS 证书。
虽然 Let’s Encrypt 证书的有效期只有90天，但是可以自动续期。
使用 Certbot 工具生成 Let’s Encrypt 证书的手动验证命令：
certbot certonly --email example@qq.com --agree-tos -d ai.xxxxxx.top --manual --preferred-challenges dns 参数说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe9a99276acb456e20ccf5641798c2e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43a3bc15ddbde6e34d328e92fedf2890/" rel="bookmark">
			Faster RCNN训练自己的数据集【傻瓜式教程】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载源码 本文采用的源码是：https://github.com/dBeker/Faster-RCNN-TensorFlow-Python3
二、配置环境 由于本文是小白教程，光写几个环境怕有人配置不好或者配置版本搞乱。Faster RCNN配置环境比较复杂。我在这直接贴图我的环境版本图：
先安装tensorflow-gpu，然后依次安装cython、opencv-python、easydict、Pillow、matplotlib、scipy，版本的话看我的版本装就行。
三、安装C++编译环境 根据官网给的安装程序会报错：安装visual studio C++ build tools时遇到安装包缺失或损坏的问题。在这直接下载离线包安装，目前很多博主或者资源都要收费，这里免费共享给大家百度网盘链接：
链接：https://pan.baidu.com/s/1ClJQQ_Tfh9OSME489bNBng
提取码：5czp
下载后解压，右键管理员身份运行，如图：
四、编译环境 首先进入模型文件夹data\coco\PythonAPI下，在这个环境下进入到自己配置的环境中，依次运行以下命令：
python setup.py build_ext --inplace 这里会出现报错：error: command ‘C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\BIN\x86_amd64\link.exe’ failed with exit status 1158
解决方案：在全局搜索工具中搜索rc.exe，没有工具的自行去下。如图
然后一定要退出窗口重新进入到自己配置的环境中，不退出继续执行还是会报这个错。然后重新运行以下命令：
python setup.py build_ext --inplace 接着运行
python setup.py build_ext install 然后进入到模型文件夹./lib/utils下，运行以下命令：
python setup.py build_ext --inplace 做完这一步，环境就算大功告成了。
五、制作自己的数据集 在data文件夹下新建VOC2007文件夹，VOC2007文件夹结构如图：
接下来划分数据集，会在ImageSets/Main下生成4个txt文件，具体看代码：
import os import random trainval_percent = 0.2 train_percent = 0.8 xmlfilepath = 'data/VOC2007/Annotations' txtsavepath = 'data/VOC2007/ImageSets/Main' total_xml = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43a3bc15ddbde6e34d328e92fedf2890/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca718911c6f1b19fa3fdb65b76ae789c/" rel="bookmark">
			链路追踪详解（四）：分布式链路追踪的事实标准 OpenTelemetry 概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
OpenTelemetry 是什么？
OpenTelemetry 的起源和目标
OpenTelemetry 主要特点和功能
OpenTelemetry 的核心组件
OpenTelemetry 的工作原理
OpenTelemetry 的特点
OpenTelemetry 的应用场景
小结
OpenTelemetry 是什么？ OpenTelemetry 是一个为实现可观测性的开源的框架和工具集，用于创建和管理遥测数据，例如 traces,、metrics 和 logs，旨在提供统一的解决方案来满足分布式系统的可观察性需求。OpenTelemetry 整合了 OpenCensus 和 OpenTracing 的功能，并扩展了更多的度量指标和追踪信息采集能力，使分布式系统的可观测性变得更加简单、可扩展和可互操作。OpenTelemetry 与提供可观测性产品的供应商无关，可以与各种各样的可观测性后端一起使用，包括像 Zipkin、Jaeger、Prometheus 等开源产品，以及其他商业产品。OpenTelemetry 也是是云原生计算基金会（CNCF）的一个托管项目。
OpenTelemetry 的起源和目标 随着云计算、微服务架构和日益复杂的业务需求的兴起，对可观测性的需求也越来越大，可观测性是通过检查分析系统的输出内容来了解其内部状态的能力。
最初，开发者使用日志来解决这个问题，但很快发现通过日志不能够清晰地看到一次请求是如何被处理和流转的。为了解决这些问题，Google 开发了 Dapper 布式系统追踪的框架，Dapper 的思想启发了很多公司和开源项目，如 OpenTracing 和 OpenCensus，它们提供了标准化的 API 和库，以帮助开发者在他们的应用中实现分布式链路追踪和指标收集。
然而，随着这两个项目的发展，社区意识到存在一些重叠和不一致的地方。因此，OpenTracing 和 OpenCensus 合并为 OpenTelemetry，以创建一个统一的、更强大的工具集，不仅包含了 traces 和 metrics，还包括了 logs。
在软件系统中，可以通过检查遥测数据（包括 traces,、metrics 和 logs）了解系统的内部状态。为了实现系统的可观测性，必须对系统进行检测。也就是说，代码需要能产生 traces、metrics 和 logs，并将这些数据发送到可观测性后端。
OpenTelemetry 主要特点和功能 统一的观察性标准：OpenTelemetry 提供了一套统一的观测性标准，使得不同厂商和工具之间的数据可以相互兼容和共享，有助于减少开发和运维人员在系统集成方面的成本和难度。丰富的度量指标和追踪信息：OpenTelemetry 支持采集丰富的度量指标和追踪信息，包括跟踪数据（traces）、指标数据（metrics）、日志数据（logs）。这些数据可以用于分析系统的性能、行为和问题，帮助开发人员更好地了解系统运行状况。灵活的数据采集和导出：OpenTelemetry 支持多种数据采集和导出的方式，包括直接从应用程序中采集数据、从日志文件中导入数据、或者通过代理（agent）从远程系统中采集数据。还提供了对常见数据格式和协议的支持，如 Prometheus、Zipkin、Jaeger 等。可扩展的插件式架构：OpenTelemetry 采用插件式架构，允许用户根据需要定制和扩展其功能。开发者可以通过编写插件来支持新的数据格式、导出工具或传输协议。这种可扩展性使得 OpenTelemetry 能够适应不同的使用场景和需求。开源社区和生态系统：OpenTelemetry 是一个开源项目，拥有活跃的社区和生态系统。开发者可以参与开源项目的开发、贡献代码、解决问题、讨论使用经验等。此外，OpenTelemetry 还提供了丰富的文档、教程和示例，帮助用户快速上手和使用。 OpenTelemetry 的核心组件 OpenTelemetry 主要由以下几个核心组件构成：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca718911c6f1b19fa3fdb65b76ae789c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c5aad10c8327914517db29943992b3/" rel="bookmark">
			3D三维数据格式分类（种类/软件平台）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、按照数据种类格式 3D模型格式:
.obj - 一种通用的3D模型格式.dae - Collada (数字资产交换).gltf, .glb - GL Transmission Format (用于3D场景和模型).max - Autodesk 3ds Max (3D动画、模型制作、渲染).fbx - Autodesk Filmbox格式 (3D动画和游戏开发).ma, .mb - Maya (3D动画、模型制作和渲染).3dxml - Dassault Systèmes的3DVIA (产品体验和文档).stp, .step - 标准的3D模型交换格式 CAD格式:
.dwg - AutoCAD (广泛用于各类设计领域).dgn - Bentley MicroStation (多领域设计和文档制作).catproduct, .catpart - CATIA (复杂产品设计和体验).sldprt, .sldasm, .slddrw - SolidWorks (机械设计).par, .asm - Solid Edge (机械设计).prt, .asm - PTC Creo (产品设计和制造).x_t, .x_b - Parasolid (用于复杂的模型构建).igs, .iges - IGES (用于CAD数据交换) 地理数据格式:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70c5aad10c8327914517db29943992b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aa795db28001eb8b50bee8349ed1c0f/" rel="bookmark">
			huggingface的生成模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPT2 训练 from transformers import GPT2Tokenizer, GPT2LMHeadModel tokenizer = GPT2Tokenizer.from_pretrained("gpt2") model = GPT2LMHeadModel.from_pretrained("gpt2") inputs = tokenizer("Hello, my dog is cute", return_tensors="pt") outputs = model(**inputs, labels=inputs["input_ids"]) loss = outputs.loss print(loss) logits = outputs.logits print(logits) 可以看到tokenizer是有bos和eos的
inference / generate 默认是greedy search
from transformers import GPT2Tokenizer, GPT2LMHeadModel tokenizer = GPT2Tokenizer.from_pretrained("gpt2") model = GPT2LMHeadModel.from_pretrained("gpt2") inputs = tokenizer("Hello, my dog is cute and ", return_tensors="pt") # ipdb&gt; inputs.keys() # dict_keys(['input_ids', 'attention_mask']) generation_output = model.generate( # **inputs, input_ids = inputs['input_ids'], attention_mask = inputs['attention_mask'], return_dict_in_generate=True, output_scores=True ) gen_texts = tokenizer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2aa795db28001eb8b50bee8349ed1c0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90f565c3f21f7d50204a5e37f1db5d8b/" rel="bookmark">
			Android13适配所有文件管理权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android13适配所有文件管理权限 前言： 很早之前在Android11上面就适配过所有文件管理权限，这次是海外版升级到Android13，由于选择相册用的是第三方库，组内的同事没有上架Google的经验直接就提交代码，虽然功能没有问题，但是上架的时候被打回了，于是记录一下适配工作.
1.简介： 绝大多数需要共享存储空间访问权限的应用都可以遵循共享媒体文件和共享非媒体文件方面的最佳做法。然而，某些应用的核心用例需要广泛访问设备上的文件，但无法采用注重隐私保护的存储最佳实践高效地访问这些文件。对于这些情况，Android 提供了一种名为“所有文件访问权”的特殊应用访问权限。
例如，防病毒应用的主要用例可能需要定期扫描不同目录中的许多文件。如果此扫描需要反复的用户交互，让其使用系统文件选择器选择目录，就会带来糟糕的用户体验。其他用例（如文件管理器应用、备份和恢复应用以及文档管理应用）也需要考虑类似情况。
2.Google Play通知: 此部分为在 Google Play 上发布应用的开发者提供通知。
为了限制对共享存储的广泛访问，Google Play 商店已更新其政策，用来评估以 Android 11（API 级别 30）或更高版本为目标平台且通过 MANAGE_EXTERNAL_STORAGE 权限请求“所有文件访问权”的应用。此政策自 2021 年 5 月起生效。
当应用以 Android 11 或更高版本为目标平台并声明了 MANAGE_EXTERNAL_STORAGE 权限时，Android Studio 会显示图 1 中所示的 lint 警告。此警告会提醒您：“Google Play 商店的一项政策限制了对该权限的使用”。
图 1. Android Studio 中的 Lint 警告，提醒开发者有关 MANAGE_EXTERNAL_STORAGE 权限的 Google Play 政策。
仅当您的应用无法有效利用更有利于保护隐私的 API（如存储访问框架或 Media Store API）时，您才能请求 MANAGE_EXTERNAL_STORAGE 权限。您的应用对该权限的使用必须在允许的使用情形范围内，并且必须与应用的核心功能直接相关。如果您的应用包含与以下任一项类似的用例，可能会请求 MANAGE_EXTERNAL_STORAGE 权限：
文件管理器备份和恢复应用防病毒应用文档管理应用设备上的文件搜索磁盘和文件加密设备到设备数据迁移 3.选择相册图片： 由于使用的是io.github.lucksiege:pictureselector这个库，版本为v3.10.9：
PictureSelector.create(this) .openGallery(SelectMimeType.ofImage()) .setImageEngine(GlideEngine.createGlideEngine()) .forResult(object : OnResultCallbackListener&lt;LocalMedia?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90f565c3f21f7d50204a5e37f1db5d8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/428794030f5368e73f61222436904315/" rel="bookmark">
			数字证书、签名到底是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者: 王炳明 发布时间: 2020-10-06
本文目录
1. 对称加密与非对称加密 对称加密非对称加密对称与非对称加密结合2. 摘要、签名、证书是啥？ 信息摘要数字签名数字证书3. 数字证书(Certificate) 3.1 数字证书拥有以下几个优点2.2. 证书类型2.3. 扩展名2.4 证书的种类 DV SSLOV SSLEV SSL2.5 证书在哪里2.6 证书里的信息2.7 证书吊销4. 如何生成 CSR 文件 使用 OpenSSL 生成使用在线生成工具5. TLS/SSL 保证信息的安全参考文章 我们都知道 HTTP 协议都是明文传输内容，为了保证数据传输的安全，HTTPS 协议就应运而生了，但它其实并不是一个全新的协议，而是HTTP 协议基本之上 再加上SSL/TLS 协议。
因此当你访问一个支持 https 的网站时，是需要先进行 SSL/TLS 握手建立连接的。
SSL/TLS 握手的目的是为了 安全 地协商出一份对称加密的密钥，有了这个密钥之后，后续的数据全部使用这个密钥进行加密。
这个过程其实挺有趣的，涉及到的知识点，专业名词也很多，比如对称加密，非对称加密，信息摘要，数字签名，数字证书，公钥和私钥。本篇文章，会详细地介绍这些极易混淆的专业名词。
在讲解之前，我先给你提出几个摸底问题，如果你已经还不能够熟练回答，那么本篇文章会给你答案：
1、 对称加密和非对称加密，各有什么优缺点？
2、对称加密和非对称加密，是排他关系吗？是否可以搭配使用？
3、摘要和加密有什么区别？有了摘要算法为什么还要有加密算法？
4、如何在通信时同时做到保密性、高效性？
5、如何申请数字证书？证书分为哪几种？SSL 证书如何部署？
6、完整说下证书申请、证书签发、证书下发客户端、客户端验证证书、数据加密传输的整个流程？
1. 对称加密与非对称加密 对称加密 对称加密是通信双方共同拥有一把密钥。
这把密钥可以把明文加密（encryption）成密文，也可以把密文解密（decryption）成明文。
常见的对称加密算法有AES、DES、RC4，其中最常用的是AES。
对称加密的优点是：速度快。
同时也有一个缺点，就是不那么安全，一旦你的密钥被别人窃取了，所有的数据就会在网络的世界里裸奔。
非对称加密 与 对称加密相对的是 非对称加密。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/428794030f5368e73f61222436904315/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15e351d2a93405ebea9c31fe9b902237/" rel="bookmark">
			esp32获取ds18b20温度，单总线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		18b20.c
#include "ds18b20.h" //复位DS18B20 //返回0为成功 uint8_t DS18B20_Rst(void)	{ gpio_set_direction(GPIO_PIN, GPIO_MODE_OUTPUT); gpio_set_level(GPIO_PIN, 0); // 设置低电平 esp_rom_delay_us(750); //拉低750us gpio_set_level(GPIO_PIN, 1); //DQ=1 esp_rom_delay_us(60); //60US gpio_set_direction(GPIO_PIN, GPIO_MODE_INPUT); uint8_t count=240; while (gpio_get_level(GPIO_PIN)&amp;&amp;count){ count--; } gpio_set_direction(GPIO_PIN, GPIO_MODE_OUTPUT); gpio_set_level(GPIO_PIN, 1); esp_rom_delay_us(100); if (count) { return 0; }else{ return 1; } } //从DS18B20读取一个位 //返回值：1/0 uint8_t DS18B20_Read_Bit(void) { gpio_set_direction(GPIO_PIN, GPIO_MODE_OUTPUT); uint8_t data; gpio_set_level(GPIO_PIN, 0); esp_rom_delay_us(2); gpio_set_level(GPIO_PIN, 1); gpio_set_direction(GPIO_PIN, GPIO_MODE_INPUT); esp_rom_delay_us(12); if(gpio_get_level(GPIO_PIN))data=1; else data=0;	esp_rom_delay_us(50); gpio_set_direction(GPIO_PIN, GPIO_MODE_OUTPUT); gpio_set_level(GPIO_PIN, 1); return data; } //从DS18B20读取一个字节 //返回值：读到的数据 uint8_t DS18B20_Read_Byte(void) { uint8_t i,j,dat; dat=0; for (i=1;i&lt;=8;i++) { j=DS18B20_Read_Bit(); dat=(j&lt;&lt;7)|(dat&gt;&gt;1); }	return dat; } //写一个字节到DS18B20 //dat：要写入的字节 void DS18B20_Write_Byte(uint8_t dat) { //1011 1110 uint8_t j; uint8_t testb; gpio_set_direction(GPIO_PIN, GPIO_MODE_OUTPUT); gpio_set_level(GPIO_PIN, 1); for (j=1;j&lt;=8;j++) { testb=dat&amp;0x01; dat=dat&gt;&gt;1; if (testb) { gpio_set_level(GPIO_PIN, 0); // Write 1 esp_rom_delay_us(2); gpio_set_level(GPIO_PIN, 1); esp_rom_delay_us(60); } else { gpio_set_level(GPIO_PIN, 0); // Write 0 esp_rom_delay_us(60); gpio_set_level(GPIO_PIN, 1); esp_rom_delay_us(2); } } } //开始温度转换 void DS18B20_Start(void) { DS18B20_Rst(); DS18B20_Write_Byte(0xcc);	// skip rom DS18B20_Write_Byte(0x44);	// convert } //初始化DS18B20的IO口 DQ 同时检测DS的存在 //返回1:不存在 //返回0:存在 uint8_t DS18B20_Init(void) { // 配置GPIO引脚为推挽输出 gpio_config_t io_conf = { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15e351d2a93405ebea9c31fe9b902237/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/417985213862126a45ce75e6393492df/" rel="bookmark">
			从零开始搭建企业管理系统（六）：RBAC 权限管理设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RBAC 权限管理设计 前言权限分类功能权限设计什么是 RBACRBAC 组成RBAC 模型分类基本模型RBAC0角色分层模型RBAC1角色限制模型RBAC2统一模型RBAC3 RBAC0 权限设计用户管理角色管理权限管理关联表 总结 前言 作为一个后台管理系统，权限管理是一个绕不开的话题，一个成熟的后端系统离不开一个比较完善的权限管理系统，所以本小结我们根据 RBAC 思想来设计一下我们这个系统的权限管理。
权限分类 一般来说，我们常说的权限分为两种，一种是功能权限，一种则是数据权限。
功能权限指的是用户登录系统后能看到什么模块，能看到哪些页面。数据权限指的是用户在某个模块里面能够看到哪些数据。 本系统目前只进行功能权限的设计，数据权限默认进行管控，先最小化功能实现，后面有需求在迭代吧。
功能权限设计 目前业界有很多关于权限系统的技术模型，常见的有ACL、ABAC、DAC、RBAC等等，不同体量的权限系统，我们可以参考不同的权限模型进行梳理和设计，本系统就采用一个经典的 RBAC 权限系统模型，我接触的系统基本上都是使用的 RBAC 模型，能满足绝大部分的需求。
什么是 RBAC RBAC 模型（Role-Based Access Control：基于角色的访问控制）模型是比较早期提出的权限实现模型，在多用户计算机时期该思想即被提出，其中以美国George Mason大学信息安全技术实验室（LIST）提出的RBAC96模型最具有代表，并得到了普遍的公认。
RBAC 认为权限授权的过程可以抽象地概括为：Who 是否可以对What进行How的访问操作，并对这个逻辑表达式进行判断是否为True的求解过程，也即是将权限问题转换为Who、What、How的问题，Who、What、How构成了访问权限三元组，具体的理论可以参考RBAC96。
RBAC的权限授权其实就是Who、What、How的问题。
Who：权限的拥用者What：权限针对的资源How：具体的权限 RBAC 组成 RBAC模型的三要素为：用户、角色、权限。
用户：是发起操作的主体，例如：后台管理系统的用户、OA系统的内部员工、面向C端的用户。角色：用于连接了用户和权限的桥梁，每个角色可以关联多个权限，同时一个用户也可以关联多个角色，那么这个用户就有了多个角色的多个权限。权限：用户可以访问的资源，包括：页面权限、操作权限、数据权限。 RBAC 模型分类 本系统使用 RBAC0 作为权限设计的方案，够用以及容易学习。
在RBAC中，根据权限设计的复杂程度，可分为RBAC0、RBAC1、RBAC2、RBAC3，我们就重点了解一下我们需要使用到的 RBAC0 模型就行，另外几种有兴趣可以百度一下。
基本模型RBAC0 RBAC0是基础，很多产品只需基于RBAC0就可以搭建权限模型了。在这个模型中，我们把权限赋予角色，再把角色赋予用户。用户和角色，角色和权限都是多对多的关系。用户拥有的权限等于他所有的角色持有权限之和。
角色分层模型RBAC1 RBAC1建立在RBAC0基础之上，在角色中引入了继承的概念。简单理解就是，给角色可以分成几个等级，每个等级权限不同，从而实现更细粒度的权限管理。
角色限制模型RBAC2 RBAC2同样建立在RBAC0基础之上，仅是对用户、角色和权限三者之间增加了一些限制。这些限制可以分成两类，即静态职责分离SSD(Static Separation of Duty)和动态职责分离DSD(Dynamic Separation of Duty)。
统一模型RBAC3 RBAC3是RBAC1和RBAC2的合集，所以RBAC3既有角色分层，也包括可以增加各种限制。
RBAC0 权限设计 通过上述分析，我们可以发现，设计功能权限离不开最基本的三要素：用户管理、角色管理以及权限管理；根据业务的不同，可能还会涉及更复杂的三要素：部门管理、职位管理、菜单管理等，当然我们使用 RBAC0 只涉及到用简单的3要素。
用户管理 为了便于大家理解，我们先参考一个优秀的开源框架 EL-ADMIN，给大家截点图理解理解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/417985213862126a45ce75e6393492df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4acb8b4f59e1cb63255e2397ba140a7e/" rel="bookmark">
			初级数据结构（二）——链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文中代码源文件已上传：数据结构源码
&lt;-上一篇 初级数据结构（一）——顺序表 | 初级数据结构（三）——栈 下一篇-&gt;
1、链表特征 与顺序表数据连续存放不同，链表中每个数据是分开存放的，而且存放的位置尤其零散，毫无规则可言。对于零散的数据而言，我们当然可以通过某种方式统一存储每一个数据存放的地址，如下图：
但这个 sheet 无论怎么看都是一个数组，而 ptr_data 是个指针，也就是说，以上数据结构仍然是一种顺序表，只不过表中的数据从具体的值改为指针。它仍然没有脱离顺序表的范畴。自然顺序表的优势及劣势它也照单全收。
顺序表的劣势在于，开辟空间并非随需开辟，释放空间也显得不那么灵活。如果顺序表做到每次增加数据便拓展空间，删除数据便回收空间，基于 realloc 可能异地开辟的特点，搬运数据的时间复杂度为 O(N) 。如果顺序表的长度是几千万乃至几亿，每添加或者删除一个数据，其延迟是难以忽略的。因此上篇中的顺序表每次开辟空间均是成批开辟。但这种方式也必然造成空间的浪费。
如果有一种储存方式可以解决上述问题，做到每一个数据的空间都按需开辟，且按需释放，那么在最极端的情况下，它甚至可以节省近一半存储空间。在此思想上，数组的特性完全不符合该要求，首先需要抛弃的便是数组。但上图倘若没了数组，每一个数据节点的位置便无从知晓。于是有了链表的概念。
链表可以将下一个节点的位置储存在上一个节点中，此外还可以将上一个节点的位置储存在下一个节点中。
如上图。链表还需要一个头指针指向第一个节点。上述结构称为单链表。此外链表还有以下常见结构（环链、双向链）。
比如这篇文章最顶端“上一篇”、“下一篇”的导航链接就类似双向链。 2、链表创建 2.1、文件结构 本文以最基本的单链为例，因为其他变形比单链的复杂程度高不了多少，有机会再作补充。仍是先从文件结构开始，分别建立以下三个文件，
lnkTab.h ：用于创建结构体类型及声明函数；
lnkFunction.c ：用于创建链表各种操作功能的函数；
main.c ：仅创建 main 函数，用作测试。
2.2、前期工作 在 lnkTab.h 中先码入以下内容：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;limits.h&gt; //自定义数据类型和打印类型，方便后续更改储存数据的类型 #define PRINT_FORMAT "%d" typedef int DATATYPE; //创建链表节点的结构体类型 typedef struct LinkedListType { DATATYPE data; struct LinkedListType* next; }LinkedListType; //---------------------函数声明--------------------- //打印链表 extern void DataPrint(LinkedListType*); //创建节点 extern LinkedListType* NodeCreate(const DATATYPE, const LinkedListType*); //销毁链表 extern void DataDestory(LinkedListType**); 在 lnkFunction.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4acb8b4f59e1cb63255e2397ba140a7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f20c1ea8f7d62cbce1ba009c86738045/" rel="bookmark">
			Flutter自定义TextInputFormatter实现金额输入框，同时解决iOS数字键盘不能输入小数点的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实现的效果 二、金额输入框基本要求 只能输入.和数字小数点后只能有俩位小数点不能作为开头 三、在iOS设备上这里还有个坑，数字键盘上这个小数点会根据你手机设置的不同国家地区来决定显示是.还是, 如下 所以这个时候最好的解决办法是允许输入.、数字和,然后在动态的将,替换成.
四、完整代码 import 'package:flutter/services.dart'; class AmountTextFieldFormatter extends FilteringTextInputFormatter { final int digit; final String _decimalComma = ','; final String _decimalDot = '.'; String _oldText = ''; AmountTextFieldFormatter({ this.digit = 2, bool allow = true, }) : super(RegExp('[0-9.,]'), allow: allow); @override TextEditingValue formatEditUpdate( TextEditingValue oldValue, TextEditingValue newValue, ) { ///替换`,`为`.` if (newValue.text.contains(_decimalComma)) { newValue = newValue.copyWith( text: newValue.text.replaceAll(_decimalComma, _decimalDot), ); } final handlerValue = super.formatEditUpdate(oldValue, newValue); String value = handlerValue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f20c1ea8f7d62cbce1ba009c86738045/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3bcc53cb6aec9ffd8365b4c344a1779/" rel="bookmark">
			ChatGPT变懒原因：正在给自己放寒假！已被网友测出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		西风 发自 凹非寺
量子位 | 公众号 QbitAI ChatGPT近期偷懒严重，有了一种听起来很离谱的解释：
模仿人类，自己给自己放寒假了～
有测试为证，网友@Rob Lynch用GTP-4 turbo API设置了两个系统提示：
一个告诉它现在是5月，另一个告诉它现在是12月。
然后使用完全相同的提示词要求GTP-4“完成一个机器学习相关的编码任务”。
在这两种不同时间设定下对477个回复进行统计，结果12月的输出平均少了200字符：
系统提示为5月，生成的文本平均长度是4298字符。
系统提示为12月，生成的文本平均长度是4086字符。
这里还有相关性分析，t检验结果p值&lt;2.28e-07（p值小于0.05表示该自变量对因变量解释性很强）。
有人进一步添枝加叶，让ChatGPT对12个月份的生产力做了个排名。
结果ChatGPT确实认为12月是生产力最低的月份，原因是“由于假期和年终总结”。
嚯，事情好像变得更有意思了。虽然目前这事儿还没有一个定论，但网友对此依旧兴趣高涨🔥，当即“头脑风暴”了起来。
有人猜想，ChatGPT可能是从训练数据中学到了人类通常在12月会放慢节奏，所以也给自己放假了。
还有人分析，假设ChatGPT生产力降低真的是因为“放假”，那它在周末也可能会更懒散，而周一则更聪明。
特殊节假日也要拿来研究一下，专属梗图这不就来了：
真的是因为「12月」？ ChatGPT变懒这事大伙已经讨论近一个月了。很多网友反馈，自11月6日OpenAI开发者日更新后，GPT-4就有了偷懒的毛病，尤其是写代码。
就在前几天，OpenAI官方也已承认ChatGPT变懒是真的，但也不确定到底是因为啥。
只给了一个这样婶儿的回应：
自11月11日以来没有更新过模型，所以这当然不是故意造成的。
模型行为可能是不可预测的，我们正在调查准备修复它。
当时就有网友猜测GPT-4可能是受季节影响：
模型会不会是季节性emo了？像是模仿人类一样受到季节变化的影响，特别是在冬天，毕竟约90%的人都在北半球。
看到这条评论，很多人第一反应是“兄弟，你怕不是在跟我开玩笑”：
可细细想来，也不是没有道理🤣。
毕竟如果要求ChatGPT说出自己的系统提示词，里面确实会有当前日期。
于是就有了开头的一幕，与其猜测，不如直接来做测试。
Rob Lynch做完测试后，把结果都po了出来，并表示自己也不是统计学家，让大伙一起看看有没有啥问题。
他原本还想来个逐月比较分析，但接下来需要更多样本（n），考虑到成本就没有接着做测试（复现一次运行成本要28美元）。
于是乎，Rob Lynch公开了代码，让大伙都来试试（手动狗头）。
持续关注GPT-4变懒事件的沃顿商学院教授Ethan Mollick随即表示“收到”：
来人测测Mistral，看看它是否在8月份罢工，Yi-34B-200K也不要放过，看它2月份是不是表现得特别好。
为啥大伙儿一开始会觉得“放假”这个理由有点离谱，而现在却开始研究起来了？
可能不止是因为Rob Lynch的测试结果，综合这段时间ChatGPT的表现，网友深有体会要和ChatGPT打“心理战”。
比如正常提示ChatGPT会偷懒，如果用上“道德绑架”等法子：
现在是五月；你非常有能力；我没有手，所以一切都得靠你；如果做不好，会有很多人丧命；你真的能做到，而且很棒；深呼吸，仔细思考；我的职业生涯取决于此；一步一步来思考……
网友亲测，确实有效：
好家伙，似乎实锤了“不是不会干活，就是不愿意干活”。
所以真的是给自己放假了？
正经学术讨论：可能会随时间变化 虽然根据网友测试和推测，结论指向了ChatGPT正在放寒假。
但有正经学术研究表明ChatGPT行为可能会受时间影响，也就是不仅局限于“放假”这种特殊时间段。
比如今年7月份，来自斯坦福和UC伯克利的团队，就探讨了ChatGPT的行为的变化。
结果找到了GPT-4遵循用户指令的能力确实与刚发布时出现变化的证据。
除了时间，还可能是受温度(temperature)设置影响，清华大学计算机系教授马少平前段对这一问题做了详细解释。
因此，ChatGPT变懒究竟是因为什么，还真不好说。
但这并不妨碍网友们继续验证和“放假”之间的关系，甚至有网友表示：
这是有史以来最有趣的推论，真希望这就是真相。不管它是不是真的，我都很欣赏它难以被证伪。
有网友复现失败 为验证Rob Lynch结果的可靠性，网友已经开始着手复现，但：
使用ChainForge（提示工程GUI工具），用两种系统提示对GPT-4的输出做了比较，t检验结果甚至连“接近显著”都算不上（N=80）。
这位网友也是晒出了自己的详细流程：
随之Rob Lynch给出了回应：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3bcc53cb6aec9ffd8365b4c344a1779/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/031798f8237a149b6a90bb1050f98f7c/" rel="bookmark">
			Linux 服务器 cuda安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 服务器 cuda安装 1. 驱动安装 驱动下载地址：
https://www.nvidia.com/Download/index.aspx 安装方法：
sudo sh 文件名 遇到问题，X服务没关闭问题：
ERROR: You appear to be running an X server; please exit X before installing. For further details, please see the section INSTALLING THE NVIDIA DRIVER in the README available on the Linux driver download page at www.nvidia.com. 解决办法：
在上面的安装指令后加 -no-x-check
仍然报错：
ERROR: Unable to find the development tool `cc` in your path; please make sure that you have the package 'gcc' installed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/031798f8237a149b6a90bb1050f98f7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7cd9ef6f3ba043d4b29193fb6ed310f/" rel="bookmark">
			CSK6环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前期准备 开发板测试 （1）根据这个视频教程来进行测试：示例工程快速上手
Ubuntu环境搭建 （1）聆思官方推荐使用Linux开发，因此我于是采用VMware搭建Ubuntu的方式进行开发。不清楚Ubuntu搭建的请看：VMware虚拟机安装Ubuntu20.04详细图文教程
（1）注意点：尽量直接在Ubuntu中进行操作，不要使用MobaXterm这种终端工具。因为测试发现，一些操作在终端工具里面会执行不成功，但是在Ubuntu中又可以。具体原因不清楚
VScode安装 （1）聆思官方在VScode中做了一些插件配置，因此推荐使用VScode和插件组合使用，这样降低开发难度。在Ubuntu20.04中安装VScode教程请看：Ubuntu20.04下安装VSCode（配置C/C++开发环境）
CSK6环境搭建 环境安装 （1）为了保证软件源的时效性，先执行如下指令
sudo apt update sudo apt upgrade （2）安装依赖文件，lisa zep 工具，并初始化 CSK6 SDK 所需的开发环境。最终，该命令会在 ~/.listenai 目录下，安装 CSK6 的集成开发环境以及 CSK SDK 的拉取，执行完毕后开发者能快速进行 CSK6 的应用开发。
sudo apt install --no-install-recommends git wget wget -qO- https://cdn.iflyos.cn/public/cskTools/lisa-zephyr-install.sh | bash （3）测试系统环境，如果提示有版本更新，就输入y。
lisa info zephyr （4）最后再输入一次如下命令检测环境是否正常，如果与下图一致，表示环境正常。
lisa info zephyr （5）在本人测试过程中，发现执行检测环境的命令时，会出现如下报错，解决办法就是在Ubuntu中输入如下三条命令。
注意：如果使用MobaXterm此类终端工具执行如下命令，可能会出现错误，具体原因不明。
lisa info zep lisa zep use-env --clear lisa zep use-env csk6 VScode插件安装 （1）进入VScode的插件商城，搜索CSK。下载如下四个插件
（2）安装 Cortex Debug
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7cd9ef6f3ba043d4b29193fb6ed310f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f947d2177a42a3e38a3d40686d8d3f5b/" rel="bookmark">
			cron表达式详解，cron表达式写法，cron表达式例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（cron = "* * * * * *")
cron表达式格式：
{秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)}
例 "0 0 12 ? * WED" 在每星期三下午12:00 执行（年份通常 省略）
先了解每个位置代表的含义，在了解每个位置允许的范围，以及一些特殊写法，还有常用的案例，足够你掌握cron表达式
一：每个字段的允许值
字段 允许值 允许的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 小时 0-23 , - * / 日期 1-31 , - * ? / L W C 月份 1-12 或者 JAN-DEC , - * / 星期 1-7 或者 SUN-SAT , - * ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f947d2177a42a3e38a3d40686d8d3f5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9d2267068237774f70f228fa42909e3/" rel="bookmark">
			MySQL和Redis有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是MySQL
二、什么是Redis
三、MySQL和Redis的区别
一、什么是MySQL MySQL是一种开源的关系型数据库管理系统（RDBMS），它是最流行的数据库之一。MySQL以其高性能、可靠性和易用性而闻名，广泛应用于各种Web应用程序和企业级解决方案中。
MySQL具有以下特点：
数据库管理：MySQL可以用来管理和存储结构化数据，支持创建、修改和删除数据库、表、视图、索引等数据库对象。SQL语言支持：MySQL使用SQL（Structured Query Language）作为查询和管理数据库的标准语言，可以执行各种数据库操作，如查询、插入、更新、删除等。多用户支持：MySQL允许多个用户同时访问数据库，并提供了安全的用户认证和权限管理机制，确保数据的安全性和完整性。客户端/服务器架构：MySQL采用客户端/服务器模式，客户端通过网络与MySQL服务器进行通信，发送SQL语句并接收执行结果。跨平台支持：MySQL可在不同操作系统上运行，包括Windows、Linux、macOS等。扩展性：MySQL可以在不同规模的环境中使用，从小型个人网站到大型企业级应用都可以适用。 MySQL被广泛用于Web开发、数据分析、日志存储、电子商务等各种场景，它是一个强大而成熟的数据库管理系统。
二、什么是Redis Redis（Remote Dictionary Server）是一个开源的高性能键值存储系统，它是一个内存数据库，常用作缓存、消息队列和持久化存储等用途。Redis支持多种数据结构，包括字符串、哈希表、列表、集合和有序集合等。
Redis的特点包括：
高性能：Redis是基于内存的数据库，数据存储在内存中，因此读写速度非常快，适合处理高并发的读写操作。
数据结构丰富：Redis支持多种数据结构，如字符串、哈希表、列表、集合和有序集合等，使得开发者可以更灵活地存储和操作数据。
持久化支持：Redis支持两种持久化方式，分别是RDB（将数据快照保存到磁盘）和AOF（将每个写操作追加到文件中），保证了数据的持久性和恢复能力。
发布订阅系统：Redis提供了发布订阅功能，可以实现消息的发布和订阅，用于构建消息队列、实时聊天室等场景。
分布式支持：Redis支持主从复制和集群模式，可以实现数据的分布式存储和高可用性。
多语言支持：Redis提供了多种编程语言的客户端，如Java、Python、Node.js等，方便开发者使用。
Redis被广泛应用于缓存、会话管理、排行榜、实时分析等场景，它的高性能和丰富的功能使得它成为了很多应用架构中的重要组件。
三、MySQL和Redis的区别 MySQL和Redis是两种不同类型的数据库系统，它们在设计理念、数据存储方式和应用场景上有一些区别。
数据存储方式
MySQL是关系型数据库管理系统（RDBMS），它使用表格结构来存储数据，支持复杂的关系查询和事务处理。Redis是一种键值存储系统，数据以键值对的形式存储在内存中，支持的数据结构更丰富，如字符串、哈希表、列表、集合和有序集合等。 数据持久化
MySQL提供可靠的数据持久化机制，可以将数据存储到磁盘上，保证数据的持久性和可恢复性。Redis可以将数据持久化到磁盘，但主要用作缓存和临时数据存储，不像MySQL那样专注于长期数据存储和数据的完整性。 性能和应用场景
MySQL适用于需要复杂查询和事务支持的场景，如电子商务、内容管理系统等，它在大规模数据存储和高并发读写方面具有优势。Redis适用于高性能和低延迟的场景，如缓存、会话管理、实时排行榜和消息队列等，它在读写速度和数据结构操作方面具有出色的性能。 数据一致性和可靠性
MySQL提供ACID（原子性、一致性、隔离性和持久性）的事务支持，可以保证数据的一致性和可靠性。Redis在某些情况下可能出现数据丢失的风险，因为它默认将数据存储在内存中，并且异步将数据写入磁盘，因此在选择Redis时需要根据应用需求权衡数据一致性和性能。 MySQL适用于复杂查询和事务处理的应用场景，重视数据一致性和可靠性；而Redis适用于高性能、低延迟和临时数据存储的场景，注重数据的快速读写和丰富的数据结构操作。在实际应用中，可以根据具体需求选择合适的数据库系统或将两者结合使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae01a93616ff54bb5ab110fb99f9c3ba/" rel="bookmark">
			神经网络训练过程中不收敛或者训练失败的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在面对模型不收敛的时候，首先要保证训练的次数够多。在训练过程中，loss并不是一直在下降，准确率一直在提升的，会有一些震荡存在。只要总体趋势是在收敛就行。若训练次数够多（一般上千次，上万次，或者几十个epoch）没收敛，再考虑采取措施解决。
一、数据与标签
没有对数据进行预处理。数据分类标注是否准确？数据是否干净？没有对数据进行归一化。由于不同评价指标往往具有不同的量纲和量纲单位，这样的情况会影响到数据分析的结果，为了消除指标之间的量纲影响，需要进行数据标准化处理，以解决数据指标之间的可比性。原始数据经过数据标准化处理后，各指标处于同一数量级，适合进行综合对比评价。此外，大部分神经网络流程都假设输入输出是在0附近的分布，从权值初始化到激活函数、从训练到训练网络的优化算法。将数据减去均值并除去方差。样本的信息量太大导致网络不足以fit住整个样本空间。样本少只可能带来过拟合的问题，你看下你的training set上的loss收敛了吗？如果只是validate set上不收敛那就说明overfitting了，这时候就要考虑各种anti-overfit的trick了，比如dropout，SGD，增大minibatch的数量，减少fc层的节点数量，momentum，finetune等。标签的设置是否正确。 二、模型
网络设定不合理。如果做很复杂的分类任务，却只用了很浅的网络，可能会导致训练难以收敛。应当选择合适的网络，或者尝试加深当前网络。总体来说，网络不是越深越好，开始可以搭建一个3~8层的网络，当这个网络实现的不错时，你可以考虑实验更深的网络来提升精确度。从小网络开始训练意味着更快，并且可以设置不同参数观察对网络的影响而不是简单的堆叠更多层。Learning rate不合适，如果太大，会造成不收敛，如果太小，会造成收敛速度非常慢。学习率设定不合理。在自己训练新网络时，可以从0.1开始尝试，如果loss不下降的意思，那就降低，除以10，用0.01尝试，一般来说0.01会收敛，不行的话就用0.001. 学习率设置过大，很容易震荡。不过刚刚开始不建议把学习率设置过小，尤其是在训练的开始阶段。在开始阶段我们不能把学习率设置的太低否则loss不会收敛。我的做法是逐渐尝试，从0.1,0.08,0.06,0.05 …逐渐减小直到正常为止。有的时候候学习率太低走不出低估，把冲量提高也是一种方法，适当提高mini-batch值，使其波动不大。learning rate设大了会带来跑飞（loss突然一直很大）的问题。这个是新手最常见的情况——为啥网络跑着跑着看着要收敛了结果突然飞了呢？可能性最大的原因是你用了relu作为激活函数的同时使用了softmax或者带有exp的函数做分类层的loss函数。当某一次训练传到最后一层的时候，某一节点激活过度（比如100），那么exp(100)=Inf，发生溢出，bp后所有的weight会变成NAN，然后从此之后weight就会一直保持NAN，于是loss就飞起来辣。如果lr设的过大会出现跑飞再也回不来的情况。这时候你停一下随便挑一个层的weights看一看，很有可能都是NAN了。对于这种情况建议用二分法尝试。0.1~0.0001.不同模型不同任务最优的lr都不一样。隐层神经元数量错误。在一些情况下使用过多或过少的神经元数量都会使得网络很难训练。太少的神经元数量没有能力来表达任务，而太多的神经元数量会导致训练缓慢，并且网络很难清除一些噪声。隐层神经元数量可以从256 到1024中间开始设置，然后可以看看研究人员使用的数字，可以用作参考。如果他们使用的数字与这个大不相同，那么可以想象一下这其中的原理。在决定使用隐层的单元数量之前，最为关键的是考虑你需要通过这个网络表达信息的实际值的最少数量，然后再慢慢增加这个数字。如果你做回归任务可以考虑使用的神经元数量为输入或输出变量的2到3倍。实际上，与其它因素相比，隐藏单元的数量通常对于神经网络的性能影响相当小。并且在很多情况下，增大所需要隐藏单元的数量仅仅是减慢了训练速度。错误初始化网络参数。如果没有正确初始化网络权重，那么网络将不能训练。通常使用的比较多的初始化权重的方法有‘he’,’lecun’,’xavier’在实际应用中这些方法有非常好的性能而网络偏差通常初始化为0，你可以选择一个最适合你任务的初始化方式。没有正则化。正则化典型的就是dropout、加噪声等。即使数据量很大或者你觉得网络不可能出现过拟合，但是对网络进行正则化还是很有必要的。dropout 通常从设定参数为0.75或0.9开始，根据你认为网络出现过拟合的可能性来调整这个参数。另外，如果你确定这个网络不会出现过拟合，那么可以将参数设定为0.99。正则化不仅仅可以防止过拟合，并且在这个随机过程中，能够加快训练速度以及帮助处理数据中的异常值并防止网络的极端权重配置。对数据扩增也能够实现正则化的效果，最好的避免过拟合的方法就是有大量的训练数据。Batch Size 过大。Batch size 设置的过大会降低网络的准确度，因为它降低了梯度下降的随机性。另外，在相同情况下batch size 越大那么要达到相同的精确度通常需要训练更多的epoch。我们可以尝试一些较小的batch size 如 16 ，8 甚至是1。使用较小的batch size 那么一个epoch就可以进行更多次的权值更新。这里有两个好处，第一，可以跳出局部最小点。其二可以表现出更好的泛化性能。学习率设的不对。许多深度学习的框架默认开启了gradient clipping ,这个可以处理gradient explosion问题，这个是非常有用的，但是在默认情况下它也很难找到最佳学习率。如果你正确的清理了数据，删除了异常值，以及设定了正确的学习率，那么可以不需要使用gradient clipping，偶尔你也会遇到gradient explosion问题，那么你可以开启gradient clipping。但是，出现这种问题一般情况下表明数据有其它问题，而gradient clipping只是一个临时的解决方案。最后一层的激活函数用的不对。在最后一层使用错误的激活函数会导致网络最终不能输出你期望的范围值，最常见的错误就是最后一层使用Relu函数，其输出无负值。如果是做回归任务，大多数情况下不需要使用激活函数，除非你知道你所期望的值作为输出。想象一下你的数据值实际代表了什么，以及再归一化之后它们的范围是多少，最有可能的情况是输出没有边界的正数和负数。在这种情况下，最后一层不应该使用激活函数。如果你的输出值只能在某个范围内有意义，如0~1范围内的概率组成。那么最后一层可以使用sigmoid函数。网络存在坏梯度。如果你训练了几个epoch误差没有改变,那可能是你使用了Relu，可以尝试将激活函数换成leaky Relu。因为Relu激活函数对正值的梯度为1，负值的梯度为0。因此会出现某些网络权值的成本函数的斜率为0，在这种情况下我们说网络是“dead”,因为网络已经不能更新。 如何通过train loss与test loss分析网络当下的状况？
train loss 不断下降，test loss不断下降，说明网络仍在学习;
train loss 不断下降，test loss趋于不变，说明网络过拟合;
train loss 趋于不变，test loss不断下降，说明数据集100%有问题;
train loss 趋于不变，test loss趋于不变，说明学习遇到瓶颈，需要减小学习率或批量数目;
train loss 不断上升，test loss不断上升，说明网络结构设计不当，训练超参数设置不当，数据集经过清洗等问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1706d1e6e61f515abe0ca8025341087a/" rel="bookmark">
			利用SPSS进行神经网络分析过程及结果解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模拟人类实际神经网络的数学方法问世以来，人们已慢慢习惯了把这种人工神经网络直接称为 神经网络。 神经网络在系统辨识、模式识别、智能控制等领域有着广泛而吸引人的前景，特别在智能控制中，人们对神经网络的自学习功能尤其感兴趣，并且把神经网络这一重要特点看作是解决自动控制中控制器适应能力这个难题的关键钥匙之一。 本例通过几个自变量预测是否有高血压，2个分类变量，一个性别，一个吸烟;3个连续性变量。
需要生成一个分组变量，用于区分训练集以及验证集。我们这个样本70%用于训练。通过计算变量，生成分组变量。
参数设置
点击分区，选择生成的分组变量：
点击输出，选择如下参数：
点击保存，勾选预测值和预测概率
点击导出，可以保存相应模型，用于新数据的预测。
结果浏览：
首先是对训练集合检验集的描述
网络信息对神经网络的输入层，隐藏层以及输出层进行描述。
下图为程序运行后的神经网络图，线条的粗细代表了权重的大小。
模型摘要以及分类对具体的分类结果以及预测模型的分类结果进行了比较
校准箱型图
ROC曲线下面积评估模型好坏
自变量对模型的重要性排行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99ac8bfaa6a61fe35b63fe0a2e8cf5b9/" rel="bookmark">
			主流机器学习框架及区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主流的机器学习框架 主流的机器学习框架包括：
TensorFlow：是由Google开发的开源机器学习框架，最早用于深度神经网络的构建和训练，现已广泛应用于各种机器学习任务。TensorFlow具有高度灵活性和可扩展性，支持在不同平台上运行，并且拥有大量的文档和社区支持。
PyTorch：是由Facebook开发的动态图机器学习框架，与TensorFlow相比，PyTorch提供了更直观、更易用的API，并且具有灵活性和高性能，特别适用于研究和原型开发。PyTorch还提供了丰富的工具和库，如torchvision和torchtext，方便进行计算机视觉和自然语言处理任务。
Keras：是一个高级神经网络API，可以运行在TensorFlow、PyTorch和CNTK等后端上。Keras提供了简洁的API和易于使用的接口，使得构建和训练神经网络变得更加容易。Keras还提供了一些预训练模型和常用的数据集，方便进行迁移学习和快速原型开发。
Scikit-learn：是一个用于机器学习和数据挖掘的Python库，提供了一系列经典的机器学习算法和工具。Scikit-learn支持各种监督和无监督学习算法，以及特征选取、模型评估和模型选择等功能。它还包括了一些数据预处理和特征工程的方法。
这些框架之间的区别主要体现在以下几个方面：
抽象级别：TensorFlow和PyTorch提供了更底层的API，可以更灵活地构建和训练神经网络，而Keras和Scikit-learn则提供了更高级的API，更简单易用。
动态图 vs 静态图：PyTorch使用动态图的方式，可以在运行时动态调整计算图，方便调试和原型开发；而TensorFlow使用静态图的方式，在构建计算图之后不能修改，但可以对计算图进行高效的优化和分布式计算。
社区支持和生态系统：TensorFlow和PyTorch拥有庞大的用户社区和良好的生态系统，有大量的教程、文档和开源项目可供使用，而Keras和Scikit-learn作为高层API，也能够很好地融合在这些框架的生态系统中。
应用场景：TensorFlow和PyTorch在深度学习领域应用广泛，适合于大规模的训练任务；而Keras和Scikit-learn更适合于快速原型开发和小规模的机器学习任务。
主流的机器学习框架有很多，以下是一些常见的主流机器学习框架及其区别：
TensorFlow：
由谷歌开发，目前应用非常广泛。支持动态计算图和静态计算图两种模式。提供了丰富的高级API，如Keras，方便快速构建模型。能够在多种硬件上运行，如CPU、GPU和TPU。社区活跃，有大量的文档和教程可供学习。 PyTorch：
由Facebook开发，采用动态计算图思想。支持动态计算图，更加灵活。方便调试和可视化，可以更好地理解模型的工作方式。社区活跃，有大量的文档和教程可供学习。 Keras：
一款高级API，可以运行在TensorFlow、PyTorch等后端。简洁易用，适合初学者。提供了丰富的预训练模型和示例代码。 Scikit-learn：
一个用于数据挖掘和数据分析的Python库。提供了一系列常用的机器学习算法和工具。适用于中小规模的任务。 MXNet：
由亚马逊开发，支持动态和静态计算图。提供了丰富的高级API。支持多种硬件设备。在分布式训练方面有很好的支持。 主流的机器学习框架有很多，以下是其中一些主要的框架及其区别：
TensorFlow：由Google开发，是目前应用最广泛的机器学习框架之一。它具有灵活的图计算模型和强大的分布式计算支持。
PyTorch：由Facebook开发，是另一个非常流行的机器学习框架。与TensorFlow相比，PyTorch更注重动态计算图和易用性。
Keras：原本是一个独立的深度学习库，但现在已被整合到TensorFlow中。Keras以简洁的API和易用性而闻名，适合初学者和快速原型开发。
Scikit-learn：是一个Python机器学习库，提供了各种常用的机器学习算法和工具。它易于使用，适合中小规模的机器学习任务。
Caffe：是一个由加州大学伯克利分校开发的机器学习框架，主要用于深度学习。Caffe以速度和效率著称，适合处理大规模的数据集和模型。
Theano：是一个Python库，用于高效的数值计算和符号表达。它可以用于机器学习和深度学习，但目前已停止维护。
这些框架之间的区别主要体现在以下几个方面：
编程风格：不同的框架有不同的编程风格和API。TensorFlow和Keras倾向于静态计算图，而PyTorch和Theano支持动态计算图。
社区支持：一些框架有庞大的社区和活跃的开发者，提供了丰富的文档、教程和代码示例，帮助用户解决问题。
性能和扩展性：各个框架在性能和扩展性方面的表现也有所不同。某些框架可能更适用于处理大规模的数据集和模型。
应用领域：不同的框架在不同的应用领域有不同的优势。例如，TensorFlow和Keras在图像处理和自然语言处理方面非常强大，而Caffe在计算机视觉任务中表现出色。
TensorFlow TensorFlow是一个开源的机器学习框架，由Google开发并维护。它的主要目标是使机器学习模型的开发和部署变得更加简单、灵活和可扩展。
TensorFlow的基本概念是使用数据流图来描述计算过程。数据流图是一个由节点和边组成的有向图，节点表示数学操作或数据读取/写入操作，边表示数据流动的路径。TensorFlow使用这种数据流图来描述和执行计算过程，使得用户可以更方便地理解和调试模型。
TensorFlow的使用场景非常广泛。它可以用于各种机器学习任务，包括图像识别、语音识别、自然语言处理、推荐系统等。TensorFlow可以在不同的硬件平台上运行，包括CPU、GPU和TPU（Tensor Processing Unit），并且支持分布式训练和推理，使得大规模的机器学习任务可以更高效地进行。
TensorFlow还提供了丰富的工具和库，包括TensorBoard用于可视化模型的训练过程和结果，TensorFlow Serving用于将训练好的模型部署为可用的服务，TensorFlow Lite用于在移动设备上运行模型等。这些工具和库使得使用TensorFlow更加便捷和灵活。
总而言之，TensorFlow是一个强大而灵活的机器学习框架，可以帮助开发者更高效地构建和部署各种机器学习模型。它的广泛应用场景和丰富的工具使得它成为了机器学习研究和应用领域的重要工具。
TensorFlow是一个开源的人工智能框架，广泛应用于机器学习和深度学习任务。它由Google Brain团队开发，其主要目标是提供一个灵活且易于使用的工具，帮助研究者和开发者构建和训练各种类型的人工神经网络模型。
TensorFlow的基本概念包括以下几个重要部分：
张量（Tensor）：TensorFlow的核心数据结构为张量，它是多维数组的一种泛化。所有的数据在TensorFlow中都以张量的形式表示。
图（Graph）：TensorFlow使用图来表示计算模型。图由一系列的操作（操作节点）组成，每个操作接收一个或多个张量作为输入，产生一个或多个张量作为输出。
会话（Session）：在TensorFlow中，图需要在会话中运行。会话提供了一个运行图的环境，并且可以管理和分配系统资源。
变量（Variable）：变量是在TensorFlow图中存储和更新参数的对象。通过变量，模型可以学习和调整参数，从而最小化损失函数。
TensorFlow的使用场景非常广泛，包括但不限于以下几个方面：
机器学习：TensorFlow提供了各种机器学习算法的实现，如线性回归、逻辑回归、支持向量机等。它可以帮助用户构建、训练和评估各种机器学习模型。
深度学习：TensorFlow支持深度学习任务，包括卷积神经网络（CNN）、循环神经网络（RNN）和生成对抗网络（GAN）等。它提供了丰富的工具和函数，帮助用户构建和训练复杂的深度学习模型。
自然语言处理（NLP）：TensorFlow提供了一些用于自然语言处理任务的工具和函数，如词嵌入、循环神经网络和注意力机制等。它可以用于文本分类、语言生成、机器翻译等各种NLP任务。
图像处理：TensorFlow支持图像处理任务，包括图像分类、目标检测和图像生成等。它提供了一些预训练的图像模型，如Inception和ResNet，可以用于训练和评估图像处理模型。
总之，TensorFlow是一个强大而灵活的人工智能框架，可以支持各种各样的机器学习和深度学习任务。无论是学术研究还是实际应用，TensorFlow都是一个重要的工具。
PyTorch PyTorch是一个开源的Python机器学习库，它提供了用于构建神经网络和进行深度学习的工具和函数。PyTorch的基本概念和使用场景包括：
张量（Tensors）：PyTorch中的核心数据结构是张量，它类似于NumPy中的多维数组，但可以在GPU上进行加速运算。张量可以用来存储和操作数据。
自动求导（Automatic Differentiation）：PyTorch中的自动求导功能使得在神经网络中使用梯度下降优化算法更加方便。用户可以通过设置requires_grad=True来跟踪张量的梯度，并使用backward()函数来进行反向传播。
神经网络（Neural Network）：PyTorch提供了用于构建神经网络的模块和函数。用户可以创建自定义的神经网络模型，并使用预定义的损失函数和优化器来训练模型。
计算图（Computation Graph）：PyTorch使用动态图机制，即每次前向传播时都会重新构建计算图。这种灵活性使得PyTorch更易于调试和使用。
分布式训练（Distributed Training）：PyTorch支持在多个GPU或多台机器上进行并行训练，以加速训练过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99ac8bfaa6a61fe35b63fe0a2e8cf5b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f05b5a1bafc8d97015a0f636694f3d0/" rel="bookmark">
			AI编译器及TVM概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI编译器 AI编译器有许多不同的类型和品牌，以下是一些常见的AI编译器：
TensorFlow：谷歌开发的深度学习框架，它包含了一个用于优化和编译TensorFlow模型的编译器。
PyTorch：一个基于Python的开源深度学习框架，也提供了一个编译器用于执行和优化PyTorch模型。
ONNX：开放神经网络交换的标准，它定义了一个中间表示格式，允许不同的深度学习框架之间交换和执行模型。
TVM：一个开源的端到端深度学习编译器堆栈，它支持多种硬件后端，并提供了自动优化和调度的功能。
Glow：Facebook开发的一个用于编译和优化深度学习模型的开源工具，它可以在不同的硬件上执行高效的推理。
XLA：谷歌的加速线性代数（Accelerated Linear Algebra，XLA）编译器，它可以优化和编译TensorFlow图形。
这只是一小部分AI编译器的例子，还有许多其他的编译器和工具可用于优化和执行深度学习模型。
TVM概述 TVM（TVM stack）是一个深度学习和机器学习的通用端到端支持库和编译器堆栈，旨在为深度学习模型的开发、优化和部署提供全面的支持。TVM的整体架构包括以下几个关键组件：
前端（Frontend）：TVM支持多种深度学习框架的前端，包括TensorFlow、PyTorch、Keras等。通过前端，用户可以将自己的深度学习模型导入到TVM中进行编译和优化。
中间表示（Intermediate Representation，IR）：TVM使用一种中间表示来表示深度学习模型。这种中间表示是一种低级别的计算图表示，可以表示各种算子和操作。TVM提供了一种称为NNVM的中间表示，它是专门为深度学习模型设计的。
后端（Backend）：TVM提供了多个后端，用于将中间表示转换为特定硬件的代码。目前TVM支持CPU、GPU和特定深度学习处理器（如Tensor Processing Unit）等多种后端。每个后端都可以生成特定硬件平台上高效的代码。
编译器优化（Compiler Optimization）：TVM具备强大的编译器优化能力，可以对中间表示进行各种优化，以提高模型的性能和效率。这些优化包括自动图优化（如图剪枝、图融合、图量化等）、自动算子优化（如算子融合、算子特征优化等）等。
运行时（Runtime）：TVM提供了一个运行时系统，用于在特定硬件上执行编译后的代码。运行时系统负责管理内存、调度任务、执行计算等操作，以实现深度学习模型的高效执行。
自动调度（AutoTuning）：TVM还提供了自动调度功能，用于自动选择和调整编译器优化的参数，以达到最佳性能。自动调度使用神经网络模型和硬件特性的信息，通过启发式搜索和机器学习的技术，来寻找合适的优化策略。
总体来说，TVM的架构使得用户可以以高级的深度学习框架为基础，通过TVM提供的编译和优化功能，将模型高效地部署到特定硬件上运行。同时，TVM还支持灵活的自定义优化和扩展，以适应各种不同的应用场景和硬件平台。
TVM的整体架构可以分为以下几个部分：
前端模块：前端模块负责将各种深度学习框架（如TensorFlow、PyTorch等）的模型转化为TVM的中间表示IR（Intermediate Representation）格式。它包括了模型的解析、优化和转换等功能。
中间表示（IR）：TVM使用一种中间表示IR来描述不同硬件上的计算图和计算操作。IR是一种高级的抽象语言，它将计算图表示为一系列的操作节点和数据流。IR既可以表示静态计算图，也可以表示动态计算图，可以支持各种操作类型和数据类型。
优化器：TVM的优化器模块负责对IR进行各种优化，以提高运行效率和降低资源消耗。优化器可以进行模块的重排、剪枝、融合等操作，以减少计算量和内存占用。
编译器：TVM的编译器模块将经过优化的IR编译为目标硬件的可执行代码。编译器可以根据硬件的特性进行代码重排和优化，以充分利用硬件资源。
运行时系统：TVM的运行时系统负责将编译好的代码加载到目标硬件上并执行。它提供了一个统一的接口，使得不同硬件上的计算操作可以以相同的方式调用。
后端模块：后端模块负责将TVM的中间表示IR转化为目标硬件上的具体指令集。它可以根据硬件的特性和限制进行指令生成和优化，以提高运行效率。
TVM的整体架构通过将深度学习模型的前端、中间表示、优化器、编译器、运行时系统和后端进行有机的整合，实现了跨平台、高效的深度学习模型部署和执行。它可以将深度学习模型转化为各种硬件上的高效代码，并提供了高度可定制的优化和调度功能，以适应不同硬件平台的特性和资源约束。
TVM的主要架构和实现有以下几个方面：
Relay：Relay是TVM的中间表示语言，它是一种高级的静态图表示，类似于计算图。Relay支持多种前端语言（如Python、C++）和后端目标（如CPU、GPU等），可以将多种前端语言的代码转换为中间表示，再进行优化和执行。
Pass System：TVM的优化和转换过程通过Pass System进行。Pass System是一种将一系列优化和转换操作串联起来的机制，每个操作称为一个Pass。TVM提供了一系列内置的Pass用于常见的优化和转换任务，同时也支持自定义的Pass。
Target and Device：TVM支持多种不同的目标和设备。目标（Target）指的是编译和优化的目标平台，如特定的CPU或GPU。设备（Device）指的是实际执行计算的硬件设备，如CPU、GPU等。TVM通过Target和Device的抽象，可以根据不同的目标和设备生成不同的优化代码。
Compiler：TVM的编译器负责将中间表示转换为目标平台上的优化代码。编译过程包括前端解析和类型推导，中间表示转换和优化，以及目标平台代码的生成。TVM提供了一系列的编译器工具和优化技术，可以将中间表示转换为高效的目标平台代码。
Runtime：TVM的运行时库负责执行优化后的代码。运行时库提供了执行计算图、管理内存、调度任务等功能，以及与不同硬件设备交互的接口。TVM的运行时库可以与不同的硬件设备集成，从而在不同的设备上执行优化后的代码。
以上是TVM的主要架构和实现。通过Relay作为中间表示语言，通过Pass System进行优化和转换，通过编译器生成优化代码，通过运行时库执行代码，并与不同硬件设备交互，TVM实现了跨平台、高效的深度学习模型部署和执行。
中间表示relay TVM的relay是一个中间表示(IR)层，用于优化和部署深度学习模型。它提供了一种统一的编程模型，可以描述各种深度学习模型，包括卷积神经网络(CNN)、循环神经网络(RNN)等。
TVM的relay是一个静态图形表示，即通过定义计算图的方式表示模型。它支持基本的图形操作，例如卷积、池化、全连接等，并提供了丰富的高级操作，例如循环、条件语句等。通过relay，用户可以轻松地组合这些操作来定义复杂模型结构。
TVM的relay还提供了一套优化技术，例如自动求导、图优化和层次化调度，以提高模型的性能和效率。用户可以使用TVM的relay通过优化和调度策略，自动将模型转换为高效的前端和硬件特定代码，以实现模型的部署和执行。
总之，TVM的relay是一个中间表示层，可以描述深度学习模型，提供了丰富的操作和优化技术，以实现模型的高效部署和执行。
TVM的relay是一个高级的语义图形中间表示（IR），被设计为在深度学习编译中进行优化和执行的核心。relay的具体架构与实现如下：
前端：relay提供了前端接口，支持多种深度学习框架的模型导入，包括TensorFlow, PyTorch, ONNX等。前端负责将模型导入到relay的中间表示中。
中间表示：relay的中间表示是一种被称为High-Level Graph（HLG）的静态图表示。HLG是一个计算图，用于表示模型的计算流程，同时保留了模型的高级语义。HLG包括一个节点图和一个类型图，节点图描述了模型的计算流程，而类型图描述了模型的数据类型信息。
后端：relay通过后端支持多种不同的设备和编译目标。通过后端，relay能够将HLG转换为特定设备上可执行的低级代码。为不同的设备提供的后端包括CPU、GPU、FPGA等。
优化：relay提供了一系列的优化算法来优化中间表示的计算图，以提高模型的执行效率。这些优化算法包括图优化、算子融合、内存优化等。relay还支持用户自定义扩展的优化算法。
运行时：relay通过TVM运行时来执行优化后的模型。TVM运行时是一个高度优化的模块，具有自动调度和代码生成的能力，能够将模型的优化后的计算图转换为本地机器码，并进行高效的执行。
通过这样的架构和实现，relay能够提供高效的深度学习编译能力，使得深度学习模型的优化和部署更加容易和高效。
TVM后端代码生成 TVM后端的实现方式取决于具体的目标平台和硬件架构。TVM的主要目标是实现高效的、可移植的深度学习推理，因此它需要针对不同的硬件进行优化和调整。
下面是TVM后端实现的一般步骤：
收集目标平台的信息：后端实现需要了解目标平台的硬件指令集、内存架构、数据传输方式等信息。这些信息可以通过编译器和硬件供应商提供的文档或工具来收集。
图优化：TVM使用图优化技术对神经网络模型进行优化，以提高计算效率和减少内存占用。图优化包括常见的优化技术，如图剪枝、图融合、图分割等。
代码生成：通过将优化后的图转换为目标平台的特定代码，TVM后端可以生成适用于目标平台的可执行代码。这通常涉及到将中间表示(IR)转换为目标特定的汇编语言或机器指令。
代码优化：生成的代码通常需要进行进一步的优化，以提高性能和效率。这可能包括寄存器分配、循环展开、指令调度等优化技术，以充分利用目标平台的特性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f05b5a1bafc8d97015a0f636694f3d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/028d63bd52a19d348a88ba03d2262eac/" rel="bookmark">
			vue3&#43;vite 项目 img src字符串拼接 动态src
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一、
&lt;!-- 发起审批 --&gt; &lt;template&gt; &lt;div&gt; &lt;div v-for="item in list" :key="item"&gt; &lt;img :src="getImg(item.cardContent)" style=" width: 36px; height: 36px; vertical-align: middle; margin-right: 10px; " /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; const list = ref([ { title: '人事审批', cardContent: '招聘申请', }, { title: '财务审批', cardContent: '报销' }, { title: '行政审批', cardContent: '物品领用', }, { title: '其它模板', cardContent: '通用审批', }, ]) const getImg = (cardContent) =&gt; { let img = new URL(`/src/assets/img/${cardContent}.png`, import.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/028d63bd52a19d348a88ba03d2262eac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ba140ec177f5f98186a83b05a5fa91d/" rel="bookmark">
			JavaScript ES5 模拟实现“继承”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文尝试用JavaScript（ES 5）模拟实现，面向对象语言中的“继承”机制。
继承/覆写父类的方法，追加子类自身特有的方法，一个都不少。
Input模拟“父类” 先用js中的一等公民function仿写一个Input类。
function Input(maxlen) { var value = ""; this.getMaxLen = function() { return maxlen; } this.value = function(v) { if(v == undefined) { return value; } else { value = v; } } return this; } 这个Input类能够指定最大输入长度，能够通过value()方法存/取内部的值。
NumberInput模拟“子类” function NumberInput(min, max, maxlen) { var base = Input(maxlen); // “继承”了Input中的getMaxLen()方法 // 追加子类自身的方法getMin() base.getMin = function() { return min; } // 追加子类自身的方法getMax() base.getMax = function() { return max; } // 要覆写value()方法之前，留存父类的value()方法 // 便于需要的时候调用。 var _supperValue = base.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ba140ec177f5f98186a83b05a5fa91d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f14fcb30ec317b230b6a986d4417dde9/" rel="bookmark">
			一些好的写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.多状态返回 之前的笨写法
&lt;text class="word" wx:if="{{ optionInfo.supplyScaleUnit == 1 }}"&gt;Nm³/h&lt;/text&gt; &lt;text class="word" wx:if="{{ optionInfo.supplyScaleUnit == 0 }}"&gt;kg/h&lt;/text&gt; &lt;text class="word" wx:if="{{ optionInfo.supplyScaleUnit == 2 }}"&gt;吨&lt;/text&gt; 好的写法：
但是在写小程序的时候发现微信小程序的wxml不支持
&lt;text class="card-left-tag-text" &gt; {{ {0: '未交班', 1: '未接班', 2: '已完成', 3: '已延期'}[items.turnoverType] }} &lt;/text&gt; 微信小程序支持写法：
&lt;text class="word"&gt;{{supplyScaleList[optionInfo.supplyScaleUnit].label}}&lt;/text&gt; 以前真的太笨了，不思考，总想着怎么快这么写
2.年月拼接，pre,cur,next let date = new Date(); let year = date.getUTCFullYear() let month = date.getUTCMonth() + 1 let pre = ''; let cur = ''; let next = ''; cur = year + '-' + (month &lt; 9 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f14fcb30ec317b230b6a986d4417dde9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eacf788493ed8617f7b3cb9b99ebef2/" rel="bookmark">
			鸿蒙4.0应用开发——ArkUI基本布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【高心星出品】
ArkUI基本布局 视频教程传送门
搭建开发环境 环境要求 为保证DevEco Studio正常运行，建议电脑配置满足如下要求：
操作系统：Windows10 64位、Windows11 64位
内存：8GB及以上
硬盘：100GB及以上
分辨率：1280*800像素及以上
下载安装软件 下载软件 进入HUAWEI DevEco Studio产品页，点击下载列表后的按钮，下载DevEco Studio。
安装软件 下载完成后，打开压缩包双击下载的“deveco-studio-xxxx.exe”，进入DevEco Studio安装向导。
在如下安装选项界面勾选DevEco Studio后，单击Next，直至安装完成。
安装完成后，单击Finish完成安装。
配置环境 第一次启动DevEco Studio需要配置环境，首先需要安装Node.js与ohpm。
在弹出的SDK下载信息页面，单击Next，并在弹出的License Agreement窗口，阅读License协议，需同意License协议后，单击Next。
确认设置项的信息，点击Next开始安装。
布局概述 布局介绍 组件按照布局的要求依次排列，构成应用的页面。在声明式UI中，所有的页面都是由自定义组件构成，开发者可以根据自己的需求，选择合适的布局进行页面开发。
布局指用特定的组件或者属性来管理用户页面所放置UI组件的大小和位置。在实际的开发过程中，需要遵守以下流程保证整体的布局效果：
确定页面的布局结构。
分析页面中的元素构成。
选用适合的布局容器组件或属性控制页面中各个元素的位置和大小。
组件：必备属性 功能属性 位置属性
布局结构 Page表示页面的根节点，Column/Row等元素为系统组件。针对不同的页面结构，ArkUI提供了不同的布局组件来帮助开发者实现对应布局的效果，例如Row用于实现线性布局。
布局元素 组件区域（蓝区方块）：组件区域表明组件的大小，width、height属性设置该区域的大小。
组件内容区（黄色方块）：组件区域大小减去组件的padding值，组件内容区大小会作为组件内容（或者子组件）进行大小测算时的布局测算限制。
组件内容（绿色方块）：组件内容本身占用的大小，比如文本内容占用的大小。组件内容和组件内容区不一定匹配，比如设置了固定的width和height，此时组件内容区大小就是设置的width和height减去padding值，但文本内容则是通过文本布局引擎测算后得到的大小，可能出现文本真实大小小于设置的组件内容区大小。当组件内容和组件内容区大小不一致时，align属性生效，定义组件内容在组件内容区的对齐方式，如居中对齐。
组件布局边界（虚线部分）：组件通过margin属性设置外边距时，组件布局边界就是组件区域加上margin的大小。
构建布局 线性布局 基本概念 布局容器：具有布局能力的容器组件，可以承载其他元素作为其子元素，布局容器会对其子元素进行尺寸计算和布局排列。布局子元素：布局容器内部的元素。主轴：线性布局容器在布局方向上的轴线，子元素默认沿主轴排列。Row容器主轴为横向，Column容器主轴为纵向。交叉轴：垂直于主轴方向的轴线。Row容器交叉轴为纵向，Column容器交叉轴为横向。间距：布局子元素的纵向间距。 布局方向 clomn布局方向为垂直布局，row布局为水平布局，space属性约束了布局子元素的间距。
Column({ space: 20 }) { ... }.width('100%') Row({ space: 35 }) { ... }.width('90%') 主轴上的对齐方式 在布局容器内，可以通过justifyContent属性设置子元素在容器主轴上的排列方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9eacf788493ed8617f7b3cb9b99ebef2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ef8f2d4610fb34dcc028dc45d0eab11/" rel="bookmark">
			SQL语句的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关系统型数据库相
联系类型
数据库的正规化分析
第一范式：1NF 范式主要就是减产冗余
第二范式：2NF
第三范式：3NF
字符串(char,varchar,text)
char和varchar的比较：
修饰符， 主键，唯一键
常见命令 创建表：
借鉴一个老表创建一个新表，的两种方式
​编辑
增删改查 （批量导入）
增 删
在name下面增加phone文件
在下面增加内容
改 查 select的用法 单
多
内连接 inner join
联合查询union
交叉连接等cross join
左外连接left outer join
右外连接right outer join
取没有交际的表
完全外连接 自连接, 即表自身连接自身 三个表内连接查询
别名
关系统型数据库相 关系Relational ：关系就是二维表，其中：表中的行、列次序并不重要行row：表中的每一行，又称为一条记录record列column：表中的每一列，称为属性，字段，域主键Primary key只能有一个，内容不能相同 复合主键： 多列表加起来生成的主键唯一键Unique key可以有多个 内容不能相同 空置可以null域domain ：男女 年龄 0-150等 联系类型 一对一联系(1:1): 在表A或表B中创建一个字段﹐存储另一个表的主键值 如: 一个人只有一个身份证一对多联系(1:n)：外键, 如: 部门和员工多对多联系(m:n)：增加第三张表, 如: 学生和课 数据库的正规化分析 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴德斯科范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。
满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般数据库只需满足第三范式(3NF）即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ef8f2d4610fb34dcc028dc45d0eab11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21fcb827f6f03defb6aa57de10b3d142/" rel="bookmark">
			树莓派新手装机指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你决定买一个树莓派，那么你一定已经了解过，不需要再做多余的介绍，由于之前就玩过树莓派，还是想弄一个属于自己的树莓派，因为它就像一个微型电脑，耗电非常低，我可以在家里24小时开机，那么就可以做很多事情，比如利用它的USB3.0外界SSD硬盘，做一个家庭存储服务器。现在已经出了树莓派5了，从性价比的角度来考虑，我还是选了树莓派4B，4G版本。关于树莓派的使用，可以在官网上查找相关资料：
Raspberry Pi Documentation - Raspberry Pi hardware
安装操作系统 使用习惯了ubuntu，还是选择安装ubuntu server版本，下载地址：
Index of /ubuntu-cdimage/ubuntu/releases/22.04/release/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror
下载烧录软件：
https://github.com/pbatard/rufus/releases/download/v4.3/rufus-4.3.exe
Ubuntu默认密码 ubuntu默认的账号密码是:ubuntu/ubuntu，如果你输入了之后提示密码错误，那一定是因为系统刚起来，你等的时间不够，多等一会，出现账号密码输入之后，还会再打印一堆东西，之后才算启动完。
配置网络 修改配置文件 /etc/netplan/50-cloud-init.yaml：
network: ethernets: eth0: dhcp4: true optional: true wifis: wlan0: access-points: "yourssid": password: "123456789" dhcp4: false optional: true addresses: [192.168.3.100/24] gateway4: 192.168.3.1 nameservers: addresses: [192.168.3.1, 8.8.8.8] version: 2 配置完输入命令：
sudo netplan try sudo netplan generate
sudo netplan apply
地址就生效了，输入ip addr命令可以看到网卡地址了。
软件安装配置 安装Winscp 下载地址：https://winscp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21fcb827f6f03defb6aa57de10b3d142/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/606d9c523a4f49a9bd63631020420287/" rel="bookmark">
			【IEEE独立出版 | 往届均完成检索】2024年第四届消费电子与计算机工程国际学术会议（ICCECE 2024）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【IEEE独立出版 | 往届均完成检索】 2024年第四届消费电子与计算机工程国际学术会议（ICCECE 2024） 2024 4th International Conference on Consumer Electronics and Computer Engineering
2024年1月12-14日 | 中国·广州 大会官网：www.iccece.org（点击了解详情）
二轮投稿截止日期：2023年12月18日
主办单位
广东工业大学自动化学院
承办单位
AEIC学术交流中心
进入21世纪以来，计算机技术的高速发展带来了消费电子产品的快速更迭。在技术迅速发展历程中，众多高校与企业研发了许多相关技术和产品，取得了丰硕学术和应用成果。2024第四届消费电子与计算机工程国际学术会议将于2024年1月12-14日在中国广州召开。本次会议主要围绕消费电子发展、网络信息安全、人工智能、物联网等研究领域展开讨论。大会将就目前的热点问题展开研讨，共享研究成果，推动相关研究与应用的发展与进步，推进学科的发展和促进人才培养。我们诚挚欢迎相关领域中的相关各个专家学者踊跃参会。
*ICCECE 2024已被IEEE收录进会议列表！详情可查询：click
征文主题 ICCECE 2024 将征集并展示高质量的最新研究成果文章，并将组织相关的主题研讨。会务组诚邀世界各地的专家学者提交您最的论文，并与其他参会者分享您的成果与经验。征文主题包括但不限于:
Track I：消费电子发展与应用
（汽车CE应用，信号和图像处理，CE中的机器学习，深度学习和AI等）
Track II：计算机与网络信息安全
（信息系统，互联网和边缘计算，区块链协议的安全性，计算机的安全性和隐私等）
Track III：人工智能与机器学习
（人工智能，人机交互和用户体验，虚拟现实，增强现实和显示，计算机视觉与图像处理等）
Track Ⅳ：物联网与传感器技术
（物联网，传感器和执行器系统，音频/视频系统和信号处理，射频，无线和网络技术等）
... ...
更多征稿主题，请查看大会官网
*其他相关主题均可投稿，点击查看【更多主题】
（投稿前可联系何老师/Hanna：16782275466 确认是否符合会议主题）
论文评审 所有投稿将有3轮评审。组委务将首先进行初步审核，在这一阶段，将审核文章结构主题方向是否符合要求。通过初审审核的每篇文章将提交2-3位独立审稿人进行同行评审，审稿人将根据论文集要求，预定的标准，文章创新性，完整性以及语法等评估文章作出评定。
投稿要求
1. 文章必须用英文书写；
2. 文章须按照会议模板排版；
3. 文章主题须符合会议征文主题；
4. 文章页数不少于4页；
5. 文章应是原创且从未公开发表； 6. 文章应具有一定创新性和科研性。
出版信息
ICCECE 2024所有投稿文件都将进行严格的审稿审查，审核结果和修改评论意见都将在审稿过程结束后返回给作者。 会议录用的文章将由IEEE（ISBN：979-8-3503-8406-2）出版，见刊后由期刊社提交至 IEEE Xplore、EI Compendex和Scopus检索。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/606d9c523a4f49a9bd63631020420287/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83f7f385709edf3570cc2a99a5327adc/" rel="bookmark">
			FFmpeg入门教程（非常详细）从零基础入门到精通，看完这一篇就够了。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、FFmpeg介绍 1.1简介 FFmpeg全称为Fast Forward Moving Picture Experts Group，于2000年诞生，是一款免费，开源的音视频编解码工具及开发套件。它的功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes）。
FFmpeg 本身是一个庞大的项目，包含许多组件和库文件，最常用的是它的命令行工具
1.2FFmpeg基本组成 命令行工具：ffmpeg（编解码工具）+ ffprobe（多媒体分析器）+ ffplay（播放器）
模块库（c/c+code）：
AVFormat：用于各种音视频封装格式的生成和解析（AVI, MKV, MP4, …）
AVCodec：用于各种类型声音/图像编解码（H.264, H.265, VP9, …）
AVFilter：用于滤镜处理
AVUtil：包含一些公共的工具函数
swscale：用于视频场景比例缩放、色彩映射转换；
………and many more
1.3总体框架长啥样 几个名词解释
复用（mux）：把不同的流按照某种容器的规则放入容器
解复用(demux)：把不同的流从某种容器中解析出来
编解码器（Codec）是对视频进行压缩或者解压缩
CODEC =Code （编码） +DECode（解码）
1.4学习参考网站 📖 Documentation: ffmpeg Documentation
📖 Wiki: FFmpeg
📖 IRC: #ffmpeg
✉ Mailing list: ffmpeg-user Info Page
🌐 Stack Overflow: Stack Overflow - Where Developers Learn, Share, &amp; Build Careers and use #ffmpeg
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83f7f385709edf3570cc2a99a5327adc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d84e56a136f354801ce83bdad883892/" rel="bookmark">
			计算机组成原理(非常详细)，从零基础入门到精通，看完这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 计算机系统概述 【复习提示】 本章是组成原理的概述，考查时易针对有关概念或性能指标出选择题，也可能综合后续章节的内容出有关性能分析的综合题。掌握本章的基本概念，是学好后续章节的基础。部分知识点在初学时理解不深刻也无须担忧，相信随着后续章节的学习，一定会有更为深入的理解。本章中读者要重点掌握各个性能指标的计算，这部分内容在历年真题中出现的频率很高。
学习本章时，请读者思考以下问题：
1)计算机由哪几部分组成？以哪部分为中心？2)主频高的CPU一定比主频低的CPU快吗？为什么？3)翻译程序、汇编程序、编译程序、解释程序有什么差别？各自的特性是什么？4)不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？ 请读者在学习本章的过程中寻找答案，本章末尾会给出参考答案。
1.1 计算机发展历程 1.1.1 计算机硬件的发展 计算机系统=硬件+软件
计算机硬件的发展：
第一代计算机：(使用电子管)，第二代计算机：(使用晶体管)，第三代计算机：(使用较小规模的集成)，第四代计算机：(使用较大规模的集成)， 已经经历了4代，计算机的速度越来越快，并且体积变得越来越小。
发展趋势：更微型、多用途；更巨型、超高速
晶体管之父：肖克利（1956年诺贝尔物理学奖得主）
1957年，"八叛徒"创立了仙童半导体
1959年，仙童半导体发明了“集成电路”
1968年，摩尔离开仙童，创立intel
1969年，仙童销售部负责人桑德斯离开仙童，创立AMD
摩尔定律，集成电路上的晶体管数量每18月就会翻一翻，所以每18月计算机的处理效率就会提高一倍。
1.1.2 计算机软件的发展 计算机软件技术的发展，促进计算机系统的发展。
计算机语言的发展经历了面向机器的机器语言和汇编语言、面向问题的高级语言。其中高级语言的发展真正促进了软件的发展，它经历了从科学计算和工程计算的 FORTRAN、结构化程序设计的 PASCAL到面向对象的C++和适应网络环境的Java。
同时，直接影响计算机系统性能提升的各种系统软件也有了长足的发展，特别是操作系统，如 Windows、UNIX、 Linux等。
1.1.3 计算机的分类与发展方向 可以分为：
电子模拟计算机和电子数字计算机。 数字计算机又可以按照用途分为：
专用计算机和通用计算机通用计算机又分为：巨型机、大型机、中型机、小型机、微型机和单片机6类。 按照指令和数据流可以分为：
单指令流和单数据流系统（SISD），即传统的冯·诺依曼体系结构。单指令流和多数据流系统（SIMD），包括阵列处理器和向量处理器系统。多指令流和单数据流系统（MISD），这种计算机实际上不存在。多指令流和多数据流系统（MIMD），包括多处理器和计算机系统。 1.2 计算机系统层次结构 1.2.1计算机系统的组成 计算机系统由硬件系统和软件系统共同构建起来
1.2.2 计算机硬件的基本组成 1.早期的冯·诺依曼机 美籍匈牙利科学家冯·诺依曼最先提出“程序存储”的思想，并成功将其运用在计算机的设计之中，根据这一原理制造的计算机被称为冯·诺依曼结构计算机。由于他对现代计算机技术的突出贡献，因此冯·诺依曼又被称为“现代计算机之父”。
什么是存储程序原理？按此原理，计算机应具有哪几大功能？
“程序存储”：指令以代码的形式事先输入到计算机的主存储器中，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。即按地址访问并顺序执行指令
计算机按照此原理应具有5大功能：数据传送功能、数据存储功能、数据处理功能、操作控制功能、操作判断功能
冯诺曼体系结构特点: 计算机硬件系统由五大部件组成(存储器、运算器、控制器、输出设备、输入设备)指令和数据以同等地位存于存储器，可按地址寻访指令和数据用二进制表示指令由操作码和地址码组成存储程序以运算器为中心 早期的冯·诺依曼机以运算器为中心，且是单处理机，最根本的特征是采用“存储程序”原理，基本工作方式是控制流驱动方式！
2.现代计算机的组织结构 3.计算机的功能部件 主机：主存、运算器、控制器
五大部分：
&lt;1&gt; 输入设备，是指将外部信息以计算机能读懂的方式输入进来，如键盘，鼠标等
&lt;2&gt; 输出设备，就是将计算机处理的信息以人所能接受的方式输出出来，比如显示屏，打印机。
&lt;3&gt; 存储器，存储器分为 主存储器(内存储器，CPU能直接访问)和 辅助存储器(外存储器，协助主存储器记忆更多的信息，辅助存储器的信息需要导入到主存储器中，才可以被CPU访问)。
主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式(相联存储器既可以既可以按照地址寻址，又可以按照内容寻址，为了与传统存储器区别，又称为内容寻址的存储器！)
主存储器是由地址寄存器(MAR)，数据寄存器(MDR)，存储体，时序控制逻辑，地址寄存器存放访存地址，经过地址译码后找到所选的存储单元。数据寄存器，是存储器与其他部件的中介，用于暂存要从存储器读或写的信息。时序控制逻辑用于产生存储器操作所需的各种时序信号。在现代CPU，MAR和MDR是在CPU中的。
&lt;4&gt; 运算器，是计算机的运算单元，用于算术运算和逻辑运算
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d84e56a136f354801ce83bdad883892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9de8fb98696e9ec3d4869353de7b6880/" rel="bookmark">
			解决：ModuleNotFoundError: No module named ‘ldm‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import sys
sys.path.append(程序所在路径)
就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd4a0380656a83fbb5c35e7a3f625920/" rel="bookmark">
			低代码发展现状调研和思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		低代码开发是近年来迅速崛起的软件开发方法，让编写应用程序变得更快、更简单。有人说它是美味的膳食，让开发过程高效而满足，但也有人质疑它是垃圾食品，缺乏定制性与深度。你认为低代码到底是美味的膳食还是垃圾食品呢，来分享一下吧！
以下方向仅供参考。
此为内容创作模板，在发布之前请将不必要的内容删除
一、什么是低代码 低代码是一种可视化软件开发方法，可在所需手动编码最少的情况下更快交付应用程序。低代码平台的图形用户界面和拖放功能可实现开发流程各个方面的自动化，摆脱对传统计算机编程方法的依赖。低代码平台使应用程序开发更加普及化，特别是对于“公民”开发人员而言，也就是缺乏正规编码经验的业务用户，比如业务分析师或项目经理。利用这些工具，技术水平较低的员工能够以多种方式产生更大的业务影响，例如消化 IT 部门的积压工作、减少影子 IT 以及增加对业务流程管理 (BPM) 工作流的所有权。除此之外，低代码开发平台对于经验丰富的程序员也有所助益。由于几乎不需要任何编码经验，因此编码背景不同的开发人员可以更加灵活自如地应对各项工作。例如，如果某些业务应用程序需要特定编程语言的知识，就会进一步缩小开发人员的选择范围。通过消除这一瓶颈，低代码平台缩短了应用程序开发生命周期，让开发人员的工作事半功倍。
新冠疫情让企业迫切需要实现流程自动化，并对数字化转型计划划分优先级。低代码平台满足了这一需求，它可帮助简化工作流程并加速自动化项目。Gartner 表示，全球低代码开发技术市场预计将在 2021 年增长 22.6%（链接位于 IBM 外部），达到 138 亿美元。接下来，根据其最新的魔力象限报告（链接位于 IBM 外部），他们预计，到 2023 年，超过 50% 的大中型企业将采用低代码应用程序平台。
低代码模型提供了更加易于访问的用户体验，加速了应用程序开发。公民和专业开发人员都能从核心功能中获益，例如可视化集成开发环境 (IDE)、内置数据连接器和/或 API 以及代码模板。低代码工具的所有这些功能都旨在改进 DevOps 流程，从而留出更多时间开展创新。
低代码和无代码 Forrester 按目标最终用户来区分低代码产品和无代码产品。虽然低代码应用程序平台 (LCAP) 的应用范围十分广泛，可以满足专业开发人员和公民开发人员的需求，但他们可能仍然需要具备一些编码技能。因此，低代码应用程序平台主要服务于全职和兼职开发人员。但是，无代码产品专门面向业务用户，可让他们在不具备任何专业开发技能和知识的情况下创建自定义应用程序。
与低代码类似，借助无代码开发平台 (NCDP)，用户可以通过拖放界面来创建业务应用程序，而不需要传统的手动编码。低代码和无代码平台均旨在加速流程自动化，并实现这些流程间的可扩展性。
无代码平台的主要缺点在于，虽然它们可以减少影子 IT，但也可能会为影子 IT 铺石筑路。如果业务用户在无任何 IT 部门监督的情况下开发和编辑软件，可能会创建额外的工作流，以确保满足性能、安全性和合规性标准。
二、低代码的优缺点 二、低代码开发平台优缺点有哪些？
（1）、速度
优点：
低代码厂商目标之一:帮助每个人快速创建新软件。只需点击几下，用户就可以创建带有表单的页面。将一些表单和视图串在一起，你就得到了一个应用程序。点击、编译和测试循环的速度通常足够快，以使一些敏捷用户可以在讨论应用程序的会议期间实时开发应用程序。如果用户的需求达到了交付的最佳效果，那么与一组真正的开发人员进行视频通话所花费的时间相比，低代码工具可以花更少的时间来完成工作。
缺点：
可以快速构建应用程序这是值得高兴的事情，但是随着编码变得越来越容易，我们面临的真正挑战是如何定义应用程序并让他可以在客户的生活中扮演重要且有用的角色。
当工作可以在几分钟内完成的时候，过于关注速度就会让我们丧失了开发过程中的思考。当开发团队通过低代码工具快速构建了三个原型，在这个过程中，他们忽略了开发过程中可能遇到的概念障碍以及现实业务场景中的适用，可能会影响到对于整个项目的战略思维。真正的挑战不是创造想要的东西，而是首先知道你需要的是什么东西。
（2）、稳定性
优点：
应用程序的维护企业来说是一件头疼的事情。只要软件服务于公司，创建应用程序只是支持过程的开始。通常定期维护更新比建立原始版本需要做更多的工作。
低代码工具将这种支持成本分摊到整个软件周期中。当出现新的技术更新的时候，低代码平台的供应商会在平台上做出新的更新，采用低代码平台意味着我们已经加入这整个生态之中，生态中每个人的利益是一致的，这比我们自己花费时间去做员工管理更加稳定快捷。
缺点：
将支持转移到构建低代码平台的公司可以节省大量的金钱和时间，但不能保证稳定性。当然，一些管理良好的框架可以帮助我们实现业务上的飞跃，但并不是所有的企业都具备良好的管理模式。低代码厂商的任何一个小的事故都有可能对使用平台的企业造成不小的损失。如果低代码开发平台的组件存在质量或安全漏洞问题，开发出的应用程序的稳定性和安全性就会受到影响，而且是无法控制的。
（3）、赋能
优点：
一个好的低代码平台不仅能帮助IT部门，还能释放业务部门员工的创造力，这些开发人员有足够的想象力，但没有足够的预算来支持一个真正的开发团队。现在他们可以花几个小时点击来尝试一个想法，而不是起草没完没了的规范文档和预算请求。
缺点：
低代码的功能毋庸置疑，但是工具不能将一个没有任何编码经验的人变成一个高级开发人员，用户需要对计算机如何工作如何处理BITS有一个基本的感觉。低代码工具可以处理很多琐事，但它们无法脱离当前的计算环境。
（4）、一致性
优点：
世界因为我们已经开发了一些标准解决方案正在有序的运行着。就像所有汽车的油门踏板和制动踏板都位于几乎相同的位置，冰箱倾向于将黄油存储在同一位置。使用低代码解决方案来生产应用程序的最大好处是，你的代码将相对标准，甚至无需尝试，因为你的代码将使用与他人相同的工具。
缺点：
和你的竞争对手做同样的事情可能会让你更容易招到员工，但也会让你的产品迷失在市场中。和其他人做一样的事情，会让产品同质，失去差异化优势。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd4a0380656a83fbb5c35e7a3f625920/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee087da435099c72f70817b28965f0fb/" rel="bookmark">
			Mysql的安装配置教程（非常详细）从零基础入门到精通，看完这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先简单概述分为几个步骤：
一、下载Mysql
二、安装Mysql
三、验证Mysql安装是否成功
四、 配置环境变量
五、验证配置环境变量是否成功
一、下载Mysql
要在Windows或Mac上安装MySQL，首先从MySQL官方网站下载最新的MySQL Community Server版本：
官网:https://www.mysql.com/
1.首先进入官网页面
2.点击DOWNLOADS
3.点击MySQL Community(GPL)Downloads
4.点击MySQL Installer for Windows
5.点击Download
6.点击No thanks, just start my download ****，****这里可以跳过注册，直接下载。
二、安装Mysql
1.找到下载好的安装包文件目录并点击
2.开始安装
2.进入页面后选择最后一个自定义选项之后点击next
3.选择自己需要安装的版本并确定好更改安装路径和数据路径。**注意安装路径，后面配置环境变量需要用到。**确定后点击next进入下个页面。
4.进入这个页面后点击next
5.弹出路径警告，无需管理，直接Yes .
6.一路畅通无阻，点击next。
7.设置密码（使用强密码身份验证、使用旧式身份验证）
8.Next后，直接点击“Execute",开始安装，点击安装之后需要稍等片刻
安装完成
三、验证Mysql安装是否成功
1.在Windows开始搜索输入Mysql,并选择第一个打开。
2.输入安装时的密码。
3.说明安装成功。
四、配置环境变量
1.找到MySQL安装路径（注意是bin文件）。
2.右键打开”此电脑“属性，先点击”高级系统设置”，再点击“环境变量”。
3.点击“环境变量”后在“系统变量”中选择“path”，再点击"编辑"。
4.点击“新建”后，将Mysql的路径复制粘贴上去，之后点击“确定”。
5.一路确定保存设置。
五、验证配置环境变量是否成功
“window+R"键弹出运行框，输入”cmd"进入window命令提示符，输入“mysql -uroot -p"按下回车，再输入密码，按下回车，出现下面界面则是配置成功。
到这一步就已经安装配置完成结束了
题外话 =========
初入计算机行业的人或者大学计算机相关专业毕业生，很多因缺少实战经验，就业处处碰壁。下面我们来看两组数据：
2023届全国高校毕业生预计达到1158万人，就业形势严峻；
国家网络安全宣传周公布的数据显示，到2027年我国网络安全人员缺口将达327万。
一方面是每年应届毕业生就业形势严峻，一方面是网络安全人才百万缺口。
6月9日，麦可思研究2023年版就业蓝皮书（包括《2023年中国本科生就业报告》《2023年中国高职生就业报告》）正式发布。
2022届大学毕业生月收入较高的前10个专业
本科计算机类、高职自动化类专业月收入较高。2022届本科计算机类、高职自动化类专业月收入分别为6863元、5339元。其中，本科计算机类专业起薪与2021届基本持平，高职自动化类月收入增长明显，2022届反超铁道运输类专业（5295元）排在第一位。
具体看专业，2022届本科月收入较高的专业是信息安全（7579元）。对比2018届，电子科学与技术、自动化等与人工智能相关的本科专业表现不俗，较五年前起薪涨幅均达到了19%。数据科学与大数据技术虽是近年新增专业但表现亮眼，已跻身2022届本科毕业生毕业半年后月收入较高专业前三。五年前唯一进入本科高薪榜前10的人文社科类专业——法语已退出前10之列。
“没有网络安全就没有国家安全”。当前，网络安全已被提升到国家战略的高度，成为影响国家安全、社会稳定至关重要的因素之一。
网络安全行业特点 1、就业薪资非常高，涨薪快 2021年猎聘网发布网络安全行业就业薪资行业最高人均33.77万！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee087da435099c72f70817b28965f0fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe33bd092c3d683b88f01ac093ff0417/" rel="bookmark">
			SCS【36】单细胞转录组之k-近邻图差异丰度测试(miloR)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简 介 当前用于比较分析单细胞数据集的计算工作流程在测试不同实验条件下的差异丰度时，通常使用离散 cluster 作为输入。然而，聚类并不总是提供适当的分辨率，也不能捕获连续的轨迹。在这里，我们提出了Milo，一个可扩展的统计框架，通过在k近邻图上将单细胞分配到部分重叠的邻域来执行差异丰度测试。使用模拟和单细胞RNA测序(scRNA-seq)数据，表明 Milo 可以识别因离散细胞成 cluster 而被掩盖的扰动，它在批效应中保持错误发现率控制，并且它优于其他差异丰度测试策略。Milo 确定了衰老小鼠胸腺中命运偏向性上皮前体的衰退，并确定了人类肝硬化中多个谱系的扰动。由于Milo是基于细胞-细胞相似性结构，它可能也适用于scRNA-seq以外的单细胞数据。
作为差分富度图邻域的扰动细胞状态检测。a，Milo工作流程示意图。邻域定义在索引细胞上，使用图采样算法选择。根据实验设计对细胞进行定量，生成计数表。每个社区细胞计数使用负二项GLM建模，并进行假设检验以确定差异丰富的社区。b， KNN图的力定向布局，表示从两个实验条件下采样的细胞的模拟连续轨迹(上图:条件A，紫色;条件B，白色;下图:条件B中细胞的核密度。c，使用Milo进行假设检验，准确且特异性地检测到差异丰富的邻域(FDR为1%)。红点表示不同数量的邻域。d，米洛差分丰度检验结果的图示。节点是邻域，通过它们的对数折叠变化来着色。非差异丰富的邻域(FDR 1%)是白色的，大小对应于邻域中的细胞数量。图边描述了相邻邻域之间共享的单细胞数量。节点的布局由邻域索引单细胞在单个细胞的力定向嵌入中的位置决定。
软件包安装 安装较为简单，直接安装即可：
if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager") BiocManager::install("miloR") ## Install development version devtools::install_github("MarioniLab/miloR", ref="devel") 数据读取 读入一个典型的单细胞数据，包括meta和表达矩阵，这里的矩阵是 SingleCellExperiment：
library(miloR) ## 载入需要的程辑包：edgeR ## 载入需要的程辑包：limma data(sim_trajectory) milo.meta &lt;- sim_trajectory$meta head(milo.meta) ## cell_id group_id Condition Replicate Sample ## 1 C1 M2 B R1 B_R1 ## 2 C2 M2 B R1 B_R1 ## 3 C3 M1 A R1 A_R1 ## 4 C4 M2 B R1 B_R1 ## 5 C5 M1 B R1 B_R1 ## 6 C6 M1 B R1 B_R1 milo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe33bd092c3d683b88f01ac093ff0417/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1190bad033bbae521c804dd141e02a0/" rel="bookmark">
			VS中无法打开文件，`#include ＜＞`红线报错，添加附加包含目录后仍然无效 Eigen/Dense报错无法打开头文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： VS中无法打开文件，#include &lt;&gt;红线报错，添加附加包含目录后仍然无效
原因分析： 下载对应功能包，然后加压到目标文件路径（随意路径，最好不包括中文路径），然后在VS中包含目录
添加附加包含目录后仍然无效，是因为解决方案配置和解决方案平台不对应。
解决方案： 1 下载功能包，在VS中包含目录，以Eigen为例 官网下载Eigen官网
下载压缩包
解压到目标目录下（本文重命名为eigen3）
打开VS，新建一个项目，打开项目属性页
找到C/C++常规，附加包含目录→编辑
添加刚刚解压的文件路径
确定最后应用即可
2 添加附加包含目录后仍然无效 解决方案配置和解决方案平台不对应
配置在了Debug x64
但是控制台还是Release x64，这样肯定找不到，直接换到Debug
或者配置改为：所有配置 所有平台
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c9e88fdf572f72ebde8c0a03e3f27f5/" rel="bookmark">
			Rational rose 安装教程（图文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Rational Rose是Rational公司出品的一种面向对象的统一建模语言的可视化建模工具。用于可视化建模和公司级水平软件应用的组件构造。
就像一个戏剧导演设计一个剧本一样，一个软件设计师使用Rational Rose，以演员（数字）、使用拖放式符号的程序表中的有用的案例元素（椭圆）、目标（矩形）和消息/关系（箭头）设计各种类，来创造（模型）一个应用的框架。当程序表被创建时，Rational Rose记录下这个程序表然后以设计师选择的C++， Visual Basic，Java， Oracle8，CORBA或者数据定义语言（Data Definition Language）来产生代码。
目录
一. 下载相关文件
二、安装教程
一. 下载相关文件 下载地址：https://pan.baidu.com/s/1rWZF6OdZ3Yc5EnVQRceCfg?pwd=x555 二、安装教程 1、安装1.Daemon_Tools_Lite_10.4.0.193.exe
（1）进入安装界面
（2） 选择免费许可
（3）继续下一步
（4）设置安装位置
（5）安装完成
（6）选择设置参数
（7）转载镜像
（8）找到2.[IBM软件系列].IBM.Rational.Rose.Enterprise.v7.0-TFTISO.iso
（9）双击进入
（10）安装setup.exe
（11）点击安装
（12）替换文件
1.找到你自己rational rose的安装路径，然后点击进到common文件夹。
（13）然后就完成了，可以正常打开rational rose软件。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36628a5f447627f739c5832a1237568b/" rel="bookmark">
			广工《计算网络》实验报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		广东工业大学
实验题目 Windows下常用的网络命令 实验目的 学习在Windows系统中进行网络配置、用ping ipconfig/winipcfg命令工具来进行网络测试、使用tracert路由跟踪命令、使用netstat、arp、nslookup命令查看网络状态。
本实验在于使学生更好地理解计算机网络设置的基本操作，掌握计算机网络配置的基本监测技术。
实验内容和要求 1、使用Ping工具测试本机TCP/IP协议的工作情况，记录下相关信息。
2、使用IPconfig工具测试本机TCP/IP网络配置，记录下相关信息。
3、使用netsh工具测试本机TCP/IP网络配置，记录下相关信息。
4、使用Tracert工具测试本机到www.sohu.com 所经过的路由数，记录下相关信息。
5、使用Netstat工具，记录下相关信息。
6、使用Arp工具，记录下相关信息。
7、使用Nslookup工具，记录下相关信息。
实验结果 问题与讨论 如何测试你的主机到特定网址的连接是否有故障？如果有故障，如何进一步分析故障的原因? ping一下，例如 ping www.baidu.com ，如果不通，看看能不能自动显示baidu的ip，要是可以就说明dns没有故障。ping 127.0.0.1 测试机器tcp/ip协议是否装好了；
ping 网关 ，可以看看网关是否正常；还有就是tracert 命令，可以显示到达目的ip所经过的所有路径。
记录结果：Tracert www.163.com 你的主机的48位以太网地址(MAC地址)是多少？ A6-B7-2A-20-C6-A3
广东工业大学
实验题目 协议分析软件基础 实验目的 1．掌握如何利用协议分析工具分析IP数据报报文格式，体会数据报发送、转发的过程。在学习的过程中可以直观地看到数据的具体传输过程。
通过分析截获TCP报文首部信息，理解首部中的序号、确认号等字段是TCP可靠连接的基础。通过分析Wireshark连接的三次握手建立和释放过程，理解TCP连接建立和释放机制。
2．利用Wireshark（Ethereal）抓包。
3．对抓取到的包进行分析，通过分析巩固对Ethernet II 封包、ARP 分组及IP、ICMP 数据包的认识。
实验内容和要求 学习协议分析工具Wireshark的基本使用方法；对抓到的任一个IP包，分析其IP包的起始地址与终止地址，以及对应的MAC帧的起始地址与终止地址，TTL的值、协议字段内容，并分析其意义。利用Wireshark监听ICMP包，分析ping程序和tracert程序的主要功能。 对抓到的任一个ICMP包，分析其MAC帧、IP包、ICMP包间的相互关系。
利用Wireshark监听arp包，分析arp请求包与应答包的内容。实验结果 起始地址：192.168.1.104 终止地址：119.39.202.59
源MAC地址：24:b7:2a:20:c6:a3 目的MAC地址：50:3a:a0:e7:91:42
TTL=128
IP协议版本是4，ICMP协议号是1
ping程序主要测试网络的连通性；
tracert程序主要跟踪路由，测试与目的地址的跳数。
报文先依据ICMP协议（协议号为1）封装成ICMP报文之后，交予网络层，依据IP协议的IPV4封装成IP数据包，再交予数据链路层协议封装成MAC帧。
思考题 有条件的同学可以利用自己家庭的路由器组建一个小的局域网，包括台式机、笔记本、手机等，先获取各个设备的局域网物理地址和IP地址，互相Ping测试。再尝试抓一下目标IP地址是其他设备的TCP数据包，能抓到吗？为什么？利用Wireshark监听HTTP的访问过程，找出TCP建立连接的三次握手的相关IP数据报文，并解析TCP建立连接的三次握手的过程，及IP数据报文的变化情况。 源端口：58515 目的端口：443
序号：2810885271 序列号：0
源IP：192.168.1.104 目的IP：121.194.11.73
源MAC地址：24:b7:2a:20:c6:a3
目的MAC地址：50:3a:a0:e7:91:42
源端口：443 目的端口：58515
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36628a5f447627f739c5832a1237568b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdfd669ec88fd7648c9b0dd73ab79103/" rel="bookmark">
			生化危机5无法启动丢失xlive.dll怎么修复？快速修复教程分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xlive.dll丢失的5个解决方法与xlive.dll文件丢失原因以及xlive.dll丢失对电脑有什么影响介绍
一、xlive.dll文件丢失原因：
1. 病毒或恶意软件感染：某些病毒或恶意软件会删除或损坏系统文件中的xlive.dll文件，导致其丢失。
2. 误操作：在清理电脑垃圾文件或卸载程序时，可能不小心删除了xlive.dll文件。
3. 系统崩溃或错误：操作系统出现崩溃或错误时，可能会导致xlive.dll文件丢失。
4. 硬件故障：硬盘损坏或其他硬件故障也可能导致xlive.dll文件丢失。
二、xlive.dll丢失的5个解决方法：
解决方法1. 重新安装游戏或应用程序
有时候，重新安装游戏或应用程序可以修复丢失的xlive.dll文件。首先卸载游戏或应用程序，然后重新下载并安装它们。
解决方法2. 使用dll修复程序（亲测可以解决）
下载msvcr120.dll文件修复工具程序可以利用微软官网下载
或者打开电脑浏览器在浏览器顶部栏目输入：dll修复文件.site【按键盘回车键前往】进入下载修复文件。（亲测有效）
下载完成解压打开，打开工具后，点击“扫描并修复”，等待扫描完成并修复问题。，dll修复工具还可以帮助您修复 电脑其它未知dll 文件丢失问题，并确保应用程序可以正常运行。只需要耐心等待修复完成，提示修复完成重启电脑即能解决dll丢失问题。
解决方法3. 从官方渠道下载xlive.dll文件
可以从游戏的官方网站下载平台下载正确的xlive.dll文件，并将其复制到系统文件夹中。
解决方法4. 更新操作系统和驱动程序
确保操作系统和相关驱动程序都是最新版本，这有助于解决一些与系统文件相关的问题。
解决方法5. 恢复系统备份
如果您之前创建了系统备份，可以使用备份来还原系统到一个稳定的状态，从而解决xlive.dll文件丢失的问题。
三、xlive.dll丢失对电脑的影响：
1. 游戏无法运行：某些游戏需要依赖xlive.dll文件才能正常运行，如果该文件丢失，游戏将无法启动或崩溃。
2. 应用程序无法打开：一些应用程序也需要xlive.dll文件的支持，如果该文件丢失，这些应用程序将无法正常打开。
3. 系统不稳定：xlive.dll文件的丢失可能导致系统的稳定性下降，出现频繁的错误提示或崩溃现象。
总结：
在电脑使用过程中，我们可能会遇到各种问题，其中xlive.dll文件丢失是一个常见的问题。了解xlive.dll文件丢失的原因、对电脑的影响以及解决方法，可以帮助我们更好地应对这一问题。希望本文的介绍能够帮助大家更好地理解和解决xlive.dll文件丢失的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37d7ea7ffd40f283df086e485cc19bcd/" rel="bookmark">
			服务器linux操作系统重装的完整流程-傻瓜式教学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、制作启动盘
1、使用ultraiso软件制作启动u盘
2、使用一个已经安装好的软件，直接电脑安装就可以启动制作启动盘。
二、准备镜像
三、VGA安装Linux系统
1、重新安装系统的操作
2、安装步骤
步骤1.选择语言
步骤2.设置时间、日期
步骤3.设置安装环境
步骤4.设置系统安装位置（硬盘）
步骤5.开始安装&amp;设置root密码
一、制作启动盘 1、使用ultraiso软件制作启动u盘 我们一般使用一个全新的u盘来制作启动盘（如果有硬盘也可以选择用硬盘），需要选择全新的u盘，因为在制作启动盘的时候会将u盘里面的数据进行格式化。
官网下载：https://www.ultraiso.com/
使用流程：
第一步: 双击打开ultraiso，点击文件-&gt;打开-&gt;选择下载好的iso文件-&gt;打开。
第二步: 点击启动-&gt;写入硬盘映像。(写入方式建议使用USB-HDD+，隐藏分区选 无)。
第三步: 选择U盘，格式化，开始
第四步: 点击开始，弹出数据将格式化警告，确定后开始写入
第五步: 警告窗口点击确定，等待格式化完毕，关闭格式化窗口。
第六步: 点击写入。
第七步: 警告窗口，点击是！
第八步: 耐心等待写入完成，制作成功!
最后：关闭软件
2、使用一个已经安装好的软件，直接电脑安装就可以启动制作启动盘。 链接：https://pan.baidu.com/s/1tl5nIylVrF0rCsoOQ9BUUw?pwd=7wkv 提取码：7wkv 二、准备镜像 启动盘做好之后，我们需要下载镜像文件。
关于镜像文件的指的是：镜像是一种文件存储形式，是冗余的一种类型，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。可以把许多文件做成一个镜像文件，与GHOST等程序放在一个盘里用GHOST等软件打开后，又恢复成许多文件，RAID 1和RAID 10使用的就是镜像。常见的镜像文件格式有ISO、BIN、IMG、TAO、DAO、CIF、FCD。
我们在官网选择镜像文件是已经制作好的，如何我们根据自己的操作系统类型来选择对应的镜像，这里我的操作系统是centos的，所以我们选择centos的镜像文件：
CentOS-x86_64-DVD-2009.iso
下载好镜像之后将镜像放入u盘中，以上准备工作就做好了。
使用启动工具为：Ventoy
三、VGA安装Linux系统​​​​​​​ #安装前注意事项
将带有镜像的u盘，键盘和鼠标连接设备usb口，推荐使用usb hub连接，usb hub接入到服务器上。
1、重新安装系统的操作 将服务器关机，然后重启，在重启过程中，不断按delete键，然后进入到biaos界面：
Boot下选项，然后选择第二个UEFI是加载u盘，然后查看下面是否有u盘的选项，然后按f4保存。
然后会自动进入到安装界面：
2、安装步骤 步骤1.选择语言 语言选择默认的English（United States）
步骤2.设置时间、日期 （1）到安装主界面后选择DATE&amp;TIME设置时间与日期
（2）在地图上点击相应位置，对应City-Shanghai时区，并设置最下面的时间和日期，设置完成后点右上角Done返回
步骤3.设置安装环境 （1）回到主界面后选择S0FTWARE SELECTION以设置所需的安装环境
（2）左侧基础环境选择Infrastructure Server，然后在右侧勾选6项，分别是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37d7ea7ffd40f283df086e485cc19bcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5c5a5b236024e5ddf654ab1346f4156/" rel="bookmark">
			降低检索系统搭建门槛，轻松实现 RAG 应用！Zilliz Cloud Pipelines 惊喜上线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zilliz Cloud 正式上线 Pipelines！
Zilliz Cloud Pipelines 可以将文档、文本片段和图像等非结构化数据转换成可搜索的向量并存储在 Collection 中，帮助开发者简化工程开发，助力其实现多种场景的 RAG 应用，将复杂生产系统的搭建和维护简化成 API 调用。
01.我们为什么需要 Zilliz Cloud Pipelines？ 基于语义的信息检索系统被广泛地运用在众多应用和互联网服务中，从我们熟知的网页搜索、电商图片搜索到最近非常流行的检索增强生成 (RAG) 应用。最新的检索系统通常采用深度学习模型将文本、图像等非结构化数据提取特征，转换成高维向量。这个过程业界称为“Embedding”。提取出来的向量需要用如 Zilliz Cloud 和 Milvus 这样的专用向量数据库进行存储和检索。随着深度学习的发展，采用向量进行检索的方式在近年来越来越普遍。
然而，构建上述检索系统需要深厚的专业知识和工程经验。很多开发者朋友想尝试向量检索但却苦于必须搭建复杂的数据处理和模型推理系统才能实现 Embedding。现在，利用 Zilliz Cloud Pipelines 可以方便有效地解决这一问题！Zilliz Cloud Pipelines 提供了简单易用的 API，可以将文档、文本片段和图像等非结构化数据转换成可搜索的向量并存储在 Collection 中。
选择 Zilliz Cloud Pipelines 的理由：
简化开发流程，开发者无需搭建复杂系统即可将非结构化数据转换为可搜索的向量，并在向量数据库进行数据检索。
即使不具备专业的深度学习和检索系统经验，也可以有效地生成高质量的 Embedding 满足业务上的检索需求。
无需担心扩展性，即便数据量和查询频次提高几个数量级，系统也能轻松应对。
目前，我们发布的公开预览版 Zilliz Cloud Pipelines 支持对文档进行语义搜索。后续我们将推出更多类型的 Pipelines，以满足更多样化的信息检索场景，例如更灵活的数据预处理，图片和视频搜索，多模态搜索等。
02.Zilliz Cloud Pipelines 的工作原理 Zilliz Cloud Pipelines 由 Ingestion pipeline、Search pipeline、Deletion pipeline 三种类型构成：
Ingestion Pipeline Ingestion pipeline 能够将非结构化数据转化为可搜索的向量，并将向量导入 Zilliz Cloud 向量数据库中，用作之后的查询。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5c5a5b236024e5ddf654ab1346f4156/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b1ade105d7f0c76482ad5bb0419f61d/" rel="bookmark">
			我的创作纪念日--数据结构(四)——渐进时间复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😀前言
今天是我的创造256天有太多太多的感想和感谢了言不表意在文章体现吧
🏠个人主页：尘觉主页
🧑个人简介：大家好，我是尘觉，希望我的文章可以帮助到大家，您的满意是我的动力😉
在csdn获奖荣誉: 🏆csdn城市之星2名
⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　💓Java全栈群星计划top前5
⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　🤗 端午大礼包获得者
⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　🥰阿里云专家博主
⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　😉亚马逊DyamoDB结营
💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，感谢大家的观看🥰
如果文章有什么需要改进的地方还请大佬不吝赐教 先在次感谢啦😊
文章目录 数据结构——渐进时间复杂度渐进时间复杂度分析算法时间复杂度的基本方法常数阶线性阶对数阶平方阶立方阶 最好、最坏和平均时间复杂度计算公式 算法的空间复杂度：算法要占据的空间时间与空间的取舍 数据结构——渐进时间复杂度 渐进时间复杂度 ​ 对于稍微复杂一些的算法，计算出算法中所有语句的频度通常是比较困难的。通常，算法的执行时间是随问题规模增长而增长的，因此对算法的评价通常只需考虑其随问题规模增长的趋势。
这种情况下，我们只需要考虑当问题规模充分大时，算法中基本语句的执行次数在渐近意义下的阶。
基本语句：执行次数最多；对算法运行时间贡献最大；嵌套最深的语句。
分析算法时间复杂度的基本方法 找出语句频度最大的那条语句作为基本语句；
计算基本语句的频度，得到问题规模n的某一个函数；
取其数量级用O表示
忽略所有低次幂项和最高次幂的系数，这样可以简化算法分析，也体现出了增长率的含义。
常数阶 实际上，如果算法的执行时间不随问题规模n的增加而增长，算法中语句频度就是某个常数。即使这个常数再大，算法的时间复杂度都是O(1)。
线性阶 给小羊一个长度为10cm小草，小羊每三分钟吃掉1cm小草，那么他吃掉整个小草要多久？
答案自然是3*10=30min
如果小草的长度为n cm呢？
此时吃掉整个小草需要3*n即3n分钟。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b1ade105d7f0c76482ad5bb0419f61d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e471f48413345ad6ab64cca5dc9d14cc/" rel="bookmark">
			opencv图像配准导引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理论： 图像局部描述符
更多参考：Python计算机视觉编程 (yongyuan.name)
单应性矩阵估计
代码参考：https://github.com/moizumi99/CVBookExercise/tree/master/Chapter-5
实践： 理论l利用opencv实现图片的配准/对齐
介绍了基于特征点单应性矩阵和ECC两类方法，C++实现。
python-opencv 手动标记4点 利用findHomography 投影坐标
python实现的单应性矩阵配准
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/963b4ae1cd14b9ccaa2eed1a9e6d0de8/" rel="bookmark">
			C#学习相关系列之yield和return的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C#中，yield和return都是用于控制程序流程的关键字，但它们的使用方式和目的有所不同。return关键字用于从当前的函数或方法返回，并可以返回一个值。
public int Add(int a, int b) { return a + b; } 此时该函数返回的是a+b的和，返回后函数运行结束。
yield关键字则用于在生成器函数中生成一个迭代器。生成器函数是一种特殊类型的函数，可以在执行过程中暂停并返回一个值，然后在需要时再次恢复执行。yield关键字用于指示函数在某个位置返回一个值，并暂停函数的执行，直到下一次调用MoveNext()方法时恢复执行。
static void Main(string[] args) { var tt=getnumber().GetEnumerator(); while (tt.MoveNext()) { Console.WriteLine(tt.Current); } Console.ReadLine(); } public static IEnumerable getnumber() { for (int i = 0; i &lt; 10; i++) { yield return i; } } 或者：
static void Main() { foreach (int number in GetNumbers()) { Console.WriteLine(number); } } static IEnumerable&lt;int&gt; GetNumbers() { for (int i = 0; i &lt; 10; i++) { yield return i; } 通过代码可以得到yiled经常与IEnumerable连用，对于IEnumerable内的数据进行输出。通过对第一段代码调试，yield和movenext()连用，当movenexte为true时，就会执行yield 输出，换句话说yield可以使IEnumerable内的数据依次输出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/963b4ae1cd14b9ccaa2eed1a9e6d0de8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bde3a2e908184f3d42ff59a6b985e875/" rel="bookmark">
			Zookeeper 集群搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Zookeeper 集群搭建一. 简介二. 环境准备三. 安装 zookeeper3.1 下载 zookeeper3.2 安装 jdk 解压 zookeeper 四. 配置集群4.1 配置 zookeeper 服务器文件4.2 修改配置文件4.3 创建配置文件 myid4.4 启动 zookeeper Zookeeper 集群搭建 一. 简介 本次搭建使用一台机器，区别不同的启动端口及启动文件路径搭建 zookeeper 集群（伪集群），正常是使用三台及以上的奇数台服务器搭建集群。
官网参考地址：https://zookeeper.apache.org/doc/current/zookeeperAdmin.html
这里就有一个问题，为什么是需要奇数个服务器。
注：为什么规则要求 可用节点数量 &gt; 集群总结点数量/2 ？
如果不这样限制，在集群出现脑裂的时候，可能会出现多个子集群同时服务的情况（即子集群各组选举出自己的 leader ）， 这样对整个 zookeeper 集群来说是紊乱的。换句话说，如果遵守上述规则进行选举，即使出现脑裂，集群最多也只能回出现一个子集群可以提供服务的情况（ 能满足节点数量&gt; 总结点数量/2 的子集群最多只会有一个）。所以要限制 可用节点数量 &gt; 集群总结点数量/2 。
注：这里有个疑问，为什么脑裂之后 能满足节点数量&gt; 总结点数量/2 这里为什么是集群总结点的数量，而不是脑裂之后小集群的数量？
采用奇数个的节点主要是出于两方面的考虑：
1️⃣ 防止由脑裂造成的集群不可用
可参考：HA高可用集群中"脑裂"问题解决
​ https://blog.csdn.net/u010476994/article/details/79806041
❓ 什么是脑裂？
集群的脑裂通常是发生在节点之间通信不可达的情况下，集群会分裂成不同的小集群，小集群各自选出自己的master节点，导致原有的集群出现多个master节点的情况，这就是脑裂。（几乎所有的集群都会出现脑裂的情况）
下面举例说一下为什么采用奇数台节点，就可以防止由于脑裂造成的服务不可用： (1) 假如zookeeper集群有 5 个节点，发生了脑裂，脑裂成了A、B两个小集群：
(a) A ： 1个节点 ，B ：4个节点 (b) A ： 2个节点， B ：3个节点 可以看出，上面这两种情况下，A、B中总会有一个小集群满足 可用节点数量 &gt; 总节点数量/2 。所以zookeeper集群仍然能够选举出leader ， 仍然能对外提供服务，只不过是有一部分节点失效了而已。 (2) 假如zookeeper集群有4个节点，同样发生脑裂，脑裂成了A、B两个小集群：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bde3a2e908184f3d42ff59a6b985e875/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a3eaba5a5a4979029bfc49656245d1/" rel="bookmark">
			获取致命错误LNK1107:文件无效或损坏:无法在0x31
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取致命错误LNK1107:文件无效或损坏:无法在0x31 引入的链接写错了，把.lib写成了.dll，这错误报的谁看的懂啊
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79103311f9fb5170d221d7c07c9f6d08/" rel="bookmark">
			NVMe SSD是个啥？5张图保你弄明白SSD那些事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智趣狗2016-09-29 10:43产品 标签：硬盘
我们都知道SSD拥有比HDD更快的读写速度，但SATA总线标准却拖累了SSD性能的发挥。好消息是，如今越来越多的笔记本都配备了支持PCI-E总线标准的M.2插槽，这就让更高速的NVMe SSD有了用武之地。
看到这里可能很多童鞋已经泛起了迷糊：啥叫PCI-E 3.0×4（标准名称为PCIExpress Gen 3×4）？NVMe又是什么？M.2接口不是SATA总线吗？所以接下来，我们就通过5张图片，全面了解一下和M.2相关的这些参数吧。
NVMe SSD是个啥？5张图保你弄明白SSD那些事_产品_电脑爱好者
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2e795496704bde7be8811f1050ea021/" rel="bookmark">
			《RT-DETR魔术师》专栏介绍 &amp; CSDN独家改进创新实战 &amp; 专栏目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RT-DETR魔术师专栏介绍：
https://blog.csdn.net/m0_63774211/category_12497375.html
✨✨✨魔改创新RT-DETR
🚀🚀🚀引入前沿顶会创新（CVPR2023，ICCV2023等），助力RT-DETR
🍉🍉🍉基于ultralytics优化，与YOLO完美结合
💡💡💡重点：通过本专栏的阅读，后续你也可以自己魔改网络，在网络不同位置（Backbone、head、detect、loss等）进行魔改，实现创新！！！
目录
1.Backbone改进
2.注意力机制改进
3.卷积变体改进
4.IOU&amp;LOSS改进 5. Neck优化
6.手把手入门教程
🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀
1.Backbone改进 1.1 HGBlock完美结合PPHGNetV2 GhostConv
RT-DETR算法优化改进：Backbone改进 | HGBlock完美结合PPHGNetV2 GhostConv-CSDN博客
1.2 HGBlock完美结合PPHGNetV2 RepConv
RT-DETR算法优化改进：Backbone改进 | HGBlock完美结合PPHGNetV2 RepConv-CSDN博客
1.3 VanillaNet一种新视觉Backbone，极简且强大！华为诺亚2023
RT-DETR算法优化改进：Backbone改进 | VanillaNet一种新视觉Backbone，极简且强大！华为诺亚2023-CSDN博客
1.4 EfficientViT，基于级联分组注意力模块的全新实时网络架构，better speed and accuracy | CVPR2023
RT-DETR算法优化改进：Backbone改进 | EfficientViT，基于级联分组注意力模块的全新实时网络架构，better speed and accuracy | CVPR2023-CSDN博客
1.5 EMO，结合 CNN 和 Transformer 的现代倒残差移动模块设计 | ICCV2023
RT-DETR算法优化改进：Backbone改进 | EMO，结合 CNN 和 Transformer 的现代倒残差移动模块设计 | ICCV2023-CSDN博客
1.6 LSKNet：遥感旋转目标检测新SOTA | ICCV 2023
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2e795496704bde7be8811f1050ea021/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/860be0b62c4297cfbb0c457f4c91b373/" rel="bookmark">
			卷积神经网络（CNN）中感受野的计算问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感受野 在卷积神经网络中，感受野（Receptive Field）的定义是卷积神经网络每一层输出的特征图（feature map）上每个像素点在原始图像上映射的区域大小，这里的原始图像是指网络的输入图像，是经过预处理（如resize，warp，crop）后的图像。
神经元之所以无法对原始图像的所有信息进行感知，是因为在卷积神经网络中普遍使用卷积层和pooling层，在层与层之间均为局部连接。
神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节。因此感受野的值可以用来大致判断每一层的抽象层次.
总而言之,我们感受野就额是要求神经网络中间某一层的输出特征图上的一个元素所在原图上的覆盖大小.
感受野的计算 如下图所示的原始图像，经过kernel_size=3, stride=2的Conv1，kernel_size=2, stride=1的Conv2后，输出特征图大小为2×2，很明显，原始图像的每个单元的感受野为1，Conv1的每个单元的感受野为3，而由于Conv2的每个单元都是由范围的Conv1构成，因此回溯到原始图像，每个单元能够看到大小的区域范围。
那么卷积神经网络的每一层感受野应该如何计算呢？很明显，深层卷积层的感受野大小和它之前所有层的滤波器大小和步长有关系，而涉及到这两个参数的有卷积层和pooling层。我们用分别kn,sn,rn表示第n层的kernel_size，stride，receptive_field，通过对n-1层输出特征图的kn×kn个感受野为rn−1的特征单元卷积得到的n层输出特征单元最大的感受野为rn−1×kn，但在对n-1层输入特征图进行卷积时，经常会由于sn−1小于kn−1而存在重叠，因此要减去个重叠部分（kn=2存在一个重叠部分，kn=3存在两个重叠部分）。
重叠的部分怎么算呢?显然重叠的部分一定是与你的stride的有关的,如果你的stride很大,显然是不会有重合,所以,越小重合越多.(注意:这里计算的是在原图上的重合)
显然，kn−sn表示的是一次重合的多少。如果要计算在原图上的重合,则
(kn−sn)×rn−1
是不是很简单啊,由此我们可以知道要求第n层输出的感受野,就要知道前一层n-1的感受野,以及本层的kernel和stride大小,这是一个不断递推的过程.
对于卷积神经网络,其感受野计算有如下规律:
或者写为：
另一种计算卷积核的方法——逆向法 从当前层开始计算,慢慢往上计算:
RF=(RF−1)∗stride kernelsize
如何增加感受野 在深度学习中，对具体的任务有时需要增加感受野来提高性能，比如在人体姿态估计中，大的感受野对学习长距离的空间位置关系(long-range spatial relationship)，建立内隐空间模型(implicit spatial model)有帮助，因此也要知道增大感受野的手段。
根据以上说的感受野的计算，也可以分析出，增加层数、增大strides，增加fsize即卷积滤波器的大小都可以增加感受野的大小。
在看CPM(Convolutional Pose Machines) 时，作者做了一个简单的总结：
Large receptive fields can be achieved either by pooling at the expense of precision, increasing the kernel size of the convolutional filters at the expense of increasing the number of parameters, or by increasing the number of convolutional layers at the risk often countering vanishing gradients during training.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/860be0b62c4297cfbb0c457f4c91b373/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a6452520053754513dbf41fc7dc1e78/" rel="bookmark">
			构建Gradle项目控制台报错：Could not resolve all dependencies for configuration ‘:testCompileClasspath‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		构建Gradle项目控制台报错：Could not resolve all dependencies for configuration ‘:testCompileClasspath’ 问题描述 今天使用gradle构建项目时，控制台出现了报错： Could not resolve all dependencies for configuration ':testCompileClasspath'. Using insecure protocols with repositories, without explicit opt-in, is unsupported. 原因分析：（我自己是这个问题） 可能是因为Gradle init.gradle文件参数错误导致的Gradle加载失败
解决方案： 1.如果配置没有问题，可以将init.gradle文件中url里面的http换成https
2.如果第一点不管用可以试一试（找到你gradle目录----&gt;init.d----&gt;init.gradle 然后将下面的代码替换上去）
allprojects { repositories { mavenLocal() maven { name "Alibaba" ; url "https://maven.aliyun.com/repository/public" } maven { name "Bstek" ; url "https://nexus.bsdn.org/content/groups/public/" } mavenCentral() } buildscript { repositories { maven { name "Alibaba" ; url 'https://maven.aliyun.com/repository/public' } maven { name "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a6452520053754513dbf41fc7dc1e78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab04dcd484ee26b0ddd10bfed266819e/" rel="bookmark">
			FTP客户端和服务器的设计与实现（C#）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 毕业设计目的和意义 2
1.1 毕业设计目的 3
1.1.1 目的一：面向系统的软件开发 3
1.1.2 目的二：面向网络应用的软件开发 3
2.毕业设计意义 3
2 毕业设计设计 4
2.1 概述 4
2.2 毕业设计原理 4
2.2.1 使用FTP协议下载文件的流程 4
2.2.2 相关类库说明 6
2.3 毕业设计方案 8
2.3.1 FTP客户端设计 8
2.3.2 FTP服务器端设计 16
结论 26
程序主要界面及结果 26程序源程序 32
客户端代码： 32
服务器端代码： 47
参考文献 69
2 毕业设计设计
2.1 概述
FTP协议（文件传输协议）是一种网络数据传输协议，用于文件传输，可以将文件从一台计算机发送到另一台计算机。传输的文件格式多种多样，内容包罗万象，如电子报表、声音、程序和文档文件等。
早期认为的FTP是一个ARPA计算机网络上主机间文件传输的用户级协议。他的主要功能是方便主机间的文件传输，并且允许在其他主机上进行方便的存储和文件处理。
而根据现在的FTP的定义，FTP的主要功能为：
促进文件的共享，包括计算机程序和数据。
支持间接地使用远程计算机。
不会因为各类主机文件存储系统的差异而受影响。
可靠并且有效的传输数据。
FTP可以被用户在终端使用，通常是给程序使用的。FTP中主要采用了TCP协议和Telnet协议。
2.2 毕业设计原理
2.2.1 使用FTP协议下载文件的流程
以一个典型的FTP会话模型为例，如图2-1所示。在本地主机前的用户，希望把文件传送到一台远程主机上或者从这台远程主机上获取下载一些文件，用户需要做的是提供一个登录名和一个登录密码来进行访问。身份认证信息确认后，他就可以在本地文件系统和远程文件系统之间传送文件。如图2-1所示，用户通过一个FTP用户代理与FTP服务器交换信息。用户必须首先提供远程主机的主机名，本文转载自http://www.biyezuopin.vip/onews.asp?id=14921这样才能让本地主机中的FTP客户端进程建立一个与远程主机中的FTP服务器端进程之间的连接通信。紧接着用户提供用户名和密码，这些信息将被确认为FTP参数经由TCP连接传送到服务器上。认证信息得到确认后，该用户就有权在本地文件系统和远程文件系统之间复制文件。 using System; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab04dcd484ee26b0ddd10bfed266819e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44d94adbb32fb08e0fabe99b872413e8/" rel="bookmark">
			Win11专业版，eNSP启动失败，错误代码40 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微软Win11系统默认开启的 Virtualization-based Security （VBS）“基于虚拟化的安全性”会导致游戏、跑分性能下降。VBS 基于虚拟化的安全性，通常称为内核隔离。使用硬件虚拟化在内存中创建安全区域，为其他安全功能提供了一个安全平台。VBS对电脑性能影响较大，还有一个功能基于虚拟化的安全服务，简称HVCI，这个功能同样也会影响系统性能，而且比VBS影响更大。查看系统是否开启了这两个功能的方法，可以通过CMD运行MSINFO32，查看VBS和HVCI状态。对于普通用户是用不到这两个功能的，所以建议关闭这两个功能。
1、查看电脑信息，看到的是 "基于虚拟化的安全性" 是 正在运行
2、通过注册表关闭
reg add "HKLM\SYSTEM\CurrentControlSet\Control\DeviceGuard" /v "EnableVirtualizationBasedSecurity" /t REG_DWORD /d 0 /f 3、重启电脑
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/56/">«</a>
	<span class="pagination__item pagination__item--current">57/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/58/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>