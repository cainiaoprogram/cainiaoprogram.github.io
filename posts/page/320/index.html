<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55758ab00631ba869b9334e193be2082/" rel="bookmark">
			SV语法易错案例总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要目的是将平时工作中，犯过的错误进行总结，避免以后再次进入相同的坑中。
谨记“一个人不可能犯同样的错误两次。第二次还这样做，已经不再是犯错，那是你的选择“
SV实践案例分析 案例1：sv中“||”的运算求解规则案例2：inside混淆之处 案例1：sv中“||”的运算求解规则 题目： 求两个32bit数据的按位或值。
错误的写法：
错误仿真结果：
原因分析：
从错误的结果中可以看出，只打印了"aaaaaaaa"，原因是，对于||运算符，如果左边的表达式为真时，则右边的表达式就不会执行。
再看最终的or_val，发现并未得到我们的按位或的期望值，而是00000001，原因是||运算符的结果，只能是0或1，这两个值。
正确写法：
正确仿真结果： 结果符合预期值
心得体会：||与|，只是少了一个|，很容易发生笔误现象，但是如果写错了，则会发现，逻辑仿真时，它们所表达的含义完全不同，所以写代码时，要时刻小心，不然你debug的时间，会是你coding时间的double，有可能会更多。
案例2：inside混淆之处 由来： 最近项目中，遇到下面这样一个语法问题，起初乍一看以为是它？再仔细一看，发现不是，最后感悟还是自己基本功不扎实，导致初看理解有误，现记录下，鞭策自己继续学习。
实例： 实例截图如下：
仿真结果： 仿真结果截图图如下：
初看此代码时，觉得打印的val值应该是1或者2，实际情况真是啪啪打脸了，由下图可见，打印出的值是0，因为val的默认值是0，不属于1和2，所以inside操作符返回的是0。为什么会理解错了呢？主要还是将约束中的inside与sv 操作符的inside混淆了，所以真是学艺尚浅！！！
语法知识回顾： 实例截图如下：
inside用在约束块中的情形
inside做操作符的场景
上图内容分别来源于：
(1)https://blog.csdn.net/bleauchat/article/details/90381532?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161828208216780262512005%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&amp;request_id=161828208216780262512005&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_v2~rank_v29-1-90381532.pc_search_result_hbase_insert&amp;utm_term=constraint+inside&amp;spm=1018.2226.3001.4187
(2)https://blog.csdn.net/gsjthxy/article/details/107510107?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=sv%20inside%E6%93%8D%E4%BD%9C%E7%AC%A6&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-1-107510107.pc_search_result_hbase_insert&amp;spm=1018.2226.3001.4187
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1241d3cdfbca960ac371ee1528b2e39/" rel="bookmark">
			ValueError: Error initializing torch.distributed using tcp:// rendezvous: port number missing
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用 pytorch 训练 ABCNet 网络 【GitHub】，
OMP_NUM_THREADS=1 python tools/train_net.py \ --config-file configs/BAText/$confpath/attn_R_50.yaml \ --num-gpus 4 \ MODEL.WEIGHTS text_pretraining/attn_R_50/pretrain_attn_R_50.pth 报错
ValueError: Error initializing torch.distributed using tcp:// rendezvous: port number missing
原因：缺失端口
需要指定端口号或者 TCP 的 URL
当前系统有哪些端口可用呢？对于Linux 上 tcp 类型的端口，使用下面语句查看 【参考】
netstat -ntpl 训练时指定 TCP URL 即可
OMP_NUM_THREADS=1 python tools/train_net.py \ --config-file configs/BAText/$confpath/attn_R_50.yaml \ --num-gpus 4 \ --dist-url tcp://127.0.0.11:3806 \ MODEL.WEIGHTS text_pretraining/attn_R_50/pretrain_attn_R_50.pth 如果地址已被占用，就换个端口号，多试几个
RuntimeError: Address already in use
具体到其他训练语句，需要添加相应的命令行参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e82d407d186ba940f9c1ffba9978580/" rel="bookmark">
			Echarts实现省级到市级地图下钻
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在echarts社区里copy项目时，有符合需求的地图但是没有地图下钻，没办法看了看有地图下钻的项目想了一个比较简单的思路。
（这里不再赘述如何创建基本地图实例）
1.首先把对应城市的下级地区geoJson下载到本地。
这里给大家一个下载连接↓
https://www.makeapie.com/editor.html?c=xmCAi_XNuJ
这个思路主要是对查询的geoJson文件名进行改变，并不会影响地图下钻的动画效果，还是很流畅的。
uploadDataURL是地图查询用到的json地址，本思路就是改变uploadedDataURL的值。
var uploadedDataURL = "json/nmg.geoJson" 2.在myCharts.on（myCharts也可能是echarts，取决于你到导入echarts时声明的变量名）上绑定click点击事件，params为获取到的城市数据，params.name则是params数据中的城市名，可以console.log打印一下params详细了解获取到的数据。这里用语法糖代替了switch或if else。
myChart.on('click', function (params) { let map = { '呼和浩特市':'json/hohot.geoJson', '包头市':'json/baotou.geoJson', '巴彦淖尔市':'json/bayannaoer.geoJson', '赤峰市':'json/chifeng.geoJson', '鄂尔多斯市':'json/eerduosi.geoJson', '呼伦贝尔市':'json/hulunbeier.geoJson', '通辽市':'json/tongliao.geoJson', '乌海市':'json/wuhai.geoJson', '乌兰察布市':'json/wulanchabu.geoJson', '锡林郭勒盟':'json/xilinguole.geoJson', '兴安盟':'json/xinganmeng.geoJson', '阿拉善盟':'json/alashan.geoJson', } uploadedDataURL = map[params.name] getResult(); }); 最后getResult()-（你的渲染方法）重新渲染页面。
*ps：如果有每次点击方法运行次数都会增多的情况，将myCharts.on方法拿出来(比如不要放在getResult()里面)进行解耦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb611853c12af0f13058ad39c757400f/" rel="bookmark">
			oracle11g arm,想知道ARM11架构？这篇介绍告诉你
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际上，处理器采用的架构才是影响处理器性能的关键因素。手机中采用的ARM架构，从最早的ARM9到下一代的Cortex-A15，已经经历了多次的更新换代，每一次的升级都带来了性能的大幅提升，那么它们各自的性能到底怎么样呢?今天，笔者就和大家一起，聊一聊ARM的那些事。本文引用地址：http://www.eepw.com.cn/article/201807/383576.htm
ARM(Advanced RISC Machine的缩写)架构，被称作进阶精简指令集机器，是一个32位精简指令集(RISC)处理器架构，其广泛地使用在许多嵌入式系统设计。由于低成本、高效能、低耗电的特性，ARM处理器非常适用于移动通讯领域。
为了大家更好的理解，我们不妨做个比喻，ARM架构就像是一座建筑的结构设计部分，而处理器就相当于一个完整的建筑，只有有了稳定的结构作为基础，才能建造出各式各样的房子。换句话说，ARM架构只相当于一座建筑的框架，至于最后建造出来的房子长什么样，舒适度如何，就是由处理器厂商自己决定了。不过有一点需要说明，假如结构的设计值是十层，容纳人数的上限是100人，那么最后建好的房子也不能超过这个上限。这也就是说，采用相同架构的处理器，性能基本上已经锁定在一定的范围之内，不会有本质的区别。所以，看处理器的性能要先看架构。
ARM11处理器系列所提供的引擎可用于当前生产领域中的很多智能手机;该系列还广泛用于消费类、家庭和嵌入式应用领域。该处理器的功耗非常低，提供的性能范围为小面积设计中的350MHz到速度优化设计中的1GHz(45纳米和65纳米)。ARM11处理器软件可以与以前所有ARM处理器兼容，并引入了用于媒体处理的32位 SIMD、用于提高操作系统上下文切换性能的物理标记高速缓存、强制实施硬件安全性的TrustZone以及针对实时应用的紧密耦合内存。
ARM1136J-S发布于2003年，是针对高性能和高能效的应用而设计的。ARM1136J-S是第一个执行ARMv6架构指令的处理器，它集成了一条具有独立的load-store和算术流水线的8级流水线。ARMv6指令包含了针对媒体处理的单指令多数据流(SIMD)扩展，采用特殊的设计以改善视频处理性能。ARM1136JF-S就是为了进行快速浮点运算，而在ARM1136J-S增加了向量浮点单元。
德州仪器OMAP2系列处理器采用了ARM1136架构，其中TI OMAP 2420能管理130—400万像素的摄头和QVGA(240TImes;320)分辨率的屏幕，支持蓝牙、红外和高速USB传输，兼容A-GPS定位功能，可利用WLAN功能无线上网，支持第三方SD、MMC存储卡扩展，并可使用SD I/O设备，能处理400万甚至更高像素的静态图片，能够记录30帧/秒的VGA(640TImes;480)像素动态有声视频文件，能提供接近Hi-Fi级的3D环绕音效，支持TV-OUT输出功能，每秒可以计算200万个多边形。代表产品为诺基亚N82、N93、N95等。
高通骁龙Snapdragon S1是针对当今大众市场的智能手机所开发的处理器，该处理器运算速度最高可达1GHz主频，是全球首款达到1GHz主频的移动单核产品。采用了65nm工艺并集成Adreno 200图形处理器(GPU)，采用ARM11架构的处理器型号MSM7627/7227(主频为600-800MHz)和MSM7625/7225(主频为528MHz)。
Tegra APX 2500芯片的制程是65纳米，核心频率750MHz，并集成256KB的L2缓存。芯片亦内建GeForce核心，支持OpenGL ES 2.0和Direct3D Mobile标准。APX 2500属于ARM 11 MPCore架构，其低耗电设计，使手提电话可以长时间播放音乐或高清影片。此外，它支持720p的MPEG-4与H.264/MPEG-4 AVC的解码。输出方面，它支持HDMI 1.2和双显示输出。之后推出的Tegra APX 2600在APX 2500基础上增强了对NAND闪存的支持。2009年微软推出的Zune HD中使用了Tegra APX 2600芯片。
Tegra 600和Tegra 650两款型号，整合ARM 11 MP Core、影音处理器，Tegra 600支持720p H.264和VC-1影片解码，Tegra 650更支持1080p影片解码。该系列目前已停产。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecd9cac438d59c67e00d72957d7b3f06/" rel="bookmark">
			第三章MySql数据库系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
Apache HTTP Server作为优秀的Web服务器软件，提供了面向用户的前端应用功能。而在实际的企业网站平台中，为了提供更丰富、更强大的Web应用功能，往往还需要有后台数据库、网页编程语言等多种角色的支持。
本章将学习如何安装MySOL数据库，以及使用和维护MySOL数据库的基本操作。
本章重点
安装及使用MySOL数据库
MySOL数据库的用户授权
一、MySQL服务基础
MySOL是一个真正的多线程、多用户的SOL数据库服务，凭借其高性能、高可靠和易于使用的特性，成为服务器领域中最受欢迎的开源数据库系统。在2008年以前，MySOL项目由MySOL AB公司进行开发、发布和支持，之后历经Sun 公司收购MySOL AB公司，Oracle公司收购Sun公司的过程，目前MySOL项目由Oracle公司负责运营和维护。
本节将介绍MySOL的编译安装过程、服务控制方法，以及如何使用客户端工具访问MySOL数据库。
MySOL 服务器默认通过TCP3306端口提供服务。通过编辑/etc/my.cnf配置文件中[mysql]配置段的“port=3306”行，可以更改监听端口。
二、数据库用户授权
MySOL 数据库的root用户账号拥有对所有库、表的全部权限，频繁使用root 账号会给数据库服务器带来一定的安全风险。实际工作中，通常会建立一些低权限的用户，只负责一部分库，表的管理和维护操作，甚至可以对查询、修改、删除记录等各种操作做进一步的细化限制，从而将数据库的风险降至最低。
1.授予权限
GRANT 语句：专门用来设置数据库用户的访问权限。当指定的用户名不存在时，GRANT 语句将会创建新的用户，否则，GRANT 语句用于修改用户信息。语句格式如下所示。
GRANT 权限列表 oN 库名.表名 To 用户名来源地址 [IDENTIFIEDBY ’密码！] 使用GRANT语句时，需要注意的事项如下。
权限列表：用于列出授权使用的各种数据库操作，以逗号进行分隔，如“select，insert，update，delete”。使用“all”表示所有权限，可授权执行任何操作。
库名，表名：用于指定授权操作的库和表的名称，其中可以使用通配符“”。例如，使用“auth.”表示授权操作的对象为auth库中的所有表。
用户名@来源地址：用于指定用户名称和允许访问的客户机地址，即谁能连接、能从哪里连接。来源地址可以是域名、IP地址，还可以使用“%”通配符，表示某个区域或网段内的所有地址，如“%.bdqn.com"“192.168.1.%”等。
DENTFEDBY：用于设置用户连接数据库时所使用的密码字符串。在新建用户时，若省“DENTIFIED BY"部分，则用户的密码将为空
2.查看授权
当我们忘记授权指定用户指定主机时，可以查看指定用户指定主机拥有得数据库权限
SHOW GRANTS 语句：专门用来查看数据库用户的授权信息，通过FOR子句可指定查看的用户对象（必须与授权时使用的对象名称一致）。语句格式如下所示。SHOW GRANTS FOR 用户名 来源地址
3.撤销权限
REVOKE 语句：用于撤销指定用户的数据库权限，撤销权限后的用户仍然可以连接到MySOL服务器，但将被禁止执行对应的数据库操作。语句格式如下所示。
REVOKE 权限列表 oN 数据库名.表名 FROM 用户名来源地址
一、安装Mysql
1.安装依赖程序
[root@centos01 ~]# rm -rf /etc/yum.repos.d/CentOS-* [root@centos01 ~]# mount /dev/cdrom /mnt/ [root@centos01 ~]# yum -y install cmake ncurses-devel 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecd9cac438d59c67e00d72957d7b3f06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e93cb34e8ee2280a861284a5e5a2689c/" rel="bookmark">
			前端年后面试真题，会80%直接进大厂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端年后面试真题，会80%直接进大厂 关注原文：收藏不等于学会，但是不收藏一定学不会（点击进入面试题的世界）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16df6cc4cad17f546c2977f98ca07505/" rel="bookmark">
			php微信小程序支付没走回调地址,微信小程序支付成功了，没有进回调地址，是什么问题...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 您好，微信支付结果通知已成功回调到您的回调地址，您这边响应内容为："\n\n
\n \n \347\263\273\347\273\237\345\217\221\347\224\237\351\224\231\350\257\257\n \n \n\n\n \n \n \n \n \351\241\265\351\235\242\351\224\231\350\257\257\357\274\201\350\257\267\347\250\215\345\220\216\345\206\215\350\257\225\357\275\236 \n \n \n \n \n \n，请核对回调地址正确性和业务逻辑代码可用性。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3192de8ec08ed849542530e034cd038/" rel="bookmark">
			C#使用Array.Sort对二维数组排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 二维数组需要这样定义
int[][] nums= new int[][] { new int[]{ 1, 2 }, new int[]{ 3, 4 } }; 有这几种方式，表示拿每个一维数组的第二个元素比较
Array.Sort(nums, (x, y) =&gt; x[1].CompareTo(y[1])); Array.Sort(nums, (a, b) =&gt; a[1] - b[1]); Array.Sort(nums, (a, b) =&gt; { return p1[1] - p2[1]; }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/506476dfb64fabdf5a1fe67496c164cf/" rel="bookmark">
			Java数据类型简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 一、变量和类型1. 概念2.作用3.使用变量注意：4.声明和赋值变量5.变量的分类5.1.按数据类型5.2.按声明的位置不同 6. 标识符命名规则 二.数据类型详述1.整数型1.1 .整型变量（int）1.2.长整型（Long）1.3.短整型变量（short）1.4.字节类型变量（byte） 2.浮点类型2.1.单精度浮点型变量（float）2.2.双精度浮点型变量(double) 3.字符类型变量（char）4.布尔类型变量（boolean）5.字符串类型6.常量6.1.字面值常量6.2.final 关键字修饰的常量 三.数据类型转换1.基本数据类型转换2.强制类型转换3.类型转换小结 总结 一、变量和类型 1. 概念 内存中的一个储区域该区域的数据可以在同一类型范围内不断变化变量是程序中最基本的存储单元。包含 变量类型、名和存储的值 2.作用 用于在内存中保数据 3.使用变量注意： JavaJavaJavaJava中每个变量必须先 声明，后使用使用变量名来访问这块区域的 数据变量 的作用域 ：其定义所在的一对 { }内变量只有在其作用域内才效同一 个作用域内，不能定义重名的变量 4.声明和赋值变量 语法： &lt;数据类型 &gt;&lt;变量名 &gt; = &lt;初始化值 &gt;举例：int a = 11； 5.变量的分类 5.1.按数据类型 主要是分为基本数据类型和引用数据类型。见下图：基本数据类型的每一种数据都定义了明确的具体类型（强语言），在内存中分配了不同大小的内存空间。
基本类型及其包装类：
5.2.按声明的位置不同 在方法体外，类内声明的变量称为 成员变量 。在方法体内部声明的变量称为 局部变量 。
注意：二者在初始化值方面的异同 :
同： 都有生命周期
异： 局部变量除形参外，需显式初始化。 6. 标识符命名规则 标识符：
Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符 技巧：凡是自己可以起名字的地方都叫标识符定义合法标识符规则： 由26个英文字母大小写，0-9 ，_或 $ 组成数字不可以开头。不可以使用关键字和保留字，但能包含关键字和保留字。Java中严格区分大小写，长度无限制。标识符不能包含空格。 Java中的名称命名规范： 包名：多单词组成时所有字母都小写：xxxyyyzzz
类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/506476dfb64fabdf5a1fe67496c164cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dcc202746b2674ecb832e167b2a2d9c/" rel="bookmark">
			flinksql rowtime timestamp is null或者 rowtime timestamp is  not defined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DataStream&lt;UserInfo&gt; keyedStream = executionEnvironment .addSource(new UserDataSource()); keyedStream.assignTimestampsAndWatermarks(new MessageWaterEmitter()); tableEnv.registerDataStream("test", keyedStream, "userId,ticks,startime.rowtime"); Table table = tableEnv .sqlQuery( "SELECT userId,COUNT(userId) as ticks,TUMBLE_END(startime,INTERVAL '5' SECOND) as startime FROM test " + "GROUP BY TUMBLE(startime,INTERVAL '5' SECOND),userId"); DataStream&lt;Row&gt; userInfoDataStream = tableEnv.toRetractStream(table, Row.class) .filter(new FilterFunction&lt;Tuple2&lt;Boolean, Row&gt;&gt;() { @Override public boolean filter(Tuple2&lt;Boolean, Row&gt; booleanUserInfoTuple2) throws Exception { return booleanUserInfoTuple2.f0; } }).map(new MapFunction&lt;Tuple2&lt;Boolean, Row&gt;, Row&gt;() { @Override public Row map(Tuple2&lt;Boolean, Row&gt; booleanUserInfoTuple2) throws Exception { return booleanUserInfoTuple2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dcc202746b2674ecb832e167b2a2d9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89273ac5f4c1f402f9ca2280c13b4f42/" rel="bookmark">
			计算机药物设计---分子对接--薛定谔--AUTODOCK等案例解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生物分子互作基础
1.生物分子互作用研究方法
1.1蛋白-小分子、蛋白-蛋白相互作用原理
1.2 分子对接研究生物分子相互作用
1.3 蛋白蛋白对接研究分子相互作用
蛋白数据库 1. PDB 数据库介绍
1.1 PDB蛋白数据库功能
1.2 PDB蛋白数据可获取资源
1.3 PDB蛋白数据库对药物研发的重要性
2.PDB 数据库的使用
2.1 靶点蛋白结构类型、数据解读及下载
2.2 靶点蛋白结构序列下载
2.3 靶点蛋白背景分析及相关数据资源获取途径
2.4 批量下载蛋白晶体结构
蛋白结构分析
1. Pymol 软件介绍
1.1 软件安装及初始设置
1.2 基本知识介绍（如氢键等）
2.Pymol 软件使用
2.1蛋白小分子相互作用图解
2.2 蛋白蛋白相互作用图解
2.3 蛋白及小分子表面图、静电势表示
2.4蛋白及小分子结构叠加及比对
2.5绘相互作用力
2.6 Pymol动画制作
3.实例讲解与练习：
（1）尼洛替尼与靶点的相互作用，列出相互作用的氨基酸，并导出结合模式图
（2）制作结合口袋表面图
（3）Bcr/Abl靶点的PDB结构叠合
（4）制作蛋白相互作用动画
（5）针对ACE2和新冠病毒Spike的蛋白晶体复合物，制作蛋白-蛋白相互作用图
Cartoon Surface Surface of binding site
图一：Pymol 软件制作蛋白表面图 同源建模
同源建模原理介绍
1.1 同源建模的功能及使用场景
1.2 同源建模的方法
Swiss-Model 同源建模；
2.1 同源蛋白的搜索（blast等方法）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89273ac5f4c1f402f9ca2280c13b4f42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/723f8031fc9a33d73a3c4b364ca26945/" rel="bookmark">
			Linux VRF(Virtual Routing Forwarding)的原理和实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VRF顾名思义就是虚拟路由转发(Virtual Routing Forwarding)，简单点来讲，就是把一台路由器当多台虚拟路由器来用，这种技术在二层就是VLan技术，或者更加通用的虚拟交换机(在多网卡的Linux BOX上，创建多个bridge设备并把不同的网卡加入其中，就是一台携带多个虚拟交换机的物理交换机)，我把二层的方案列如下：
那么，三层的VRF自然而然就是下面
现在考虑一个非常常见的场景，即OpenVPN典型的多处理拓扑，在一台服务器上会构建超级多的TAP网卡，每个TAP服务一个特定的VPN客户端，有了VRF的支撑后，不同的VPN节点便可以使用相同的IP网段了，所要做的仅仅是将不同的TAP网卡置入不同的VRF域即可。
大致明白了VRF的原理之后，我们来看一下VRF和策略路由的关系。
我们已经知道VRF是一台物理路由器当多台虚拟路由器使用的，那么在这多台虚拟路由器之间就必须做到从物理层到三层路由的全部隔离(请注意，路由器是个三层设备)，而策略路由仅仅是路由表的隔离，甚至在仅仅使能了策略路由的路由器上，其二层三层之间的邻居表都是共享的。不过，策略路由确实是实现VRF的组件之一，它确实可以完成VRF的路由表隔离，本文的后续可以看到，Linux正是使用策略路由来实现VRF路由表隔离的。
但是仅仅依靠策略路由机制是无法构建完整的VRF体系的，为了实现二层隔离以及网卡的隔离，还需要另外的技术，Linux的VRF实现中，采用了一种叫做L3mdev的技术来支持一种三层的虚拟网卡，利用这种虚拟网卡来隐藏网卡之间的可见性。
(2). Linux VRF的使用和配置
本节是例行的一节，如果你都没让系统跑起来就去研究它的原理，那势必是本末倒置的，研究技术的目的是更好地使用技术，所以必然要先用起来VRF。
但我不准备在本节着墨太多，因此我选择了引用的方式。因为几个老外已经把使用和配置写得淋漓尽致了，这些东西，我再写也只是复制粘贴，显得毫无意义，因此我引用他们写好的东西，同时，作为补充，本节以下我写一些他们没有提到的东西。
本节的重点就是下面几个链接，文章都不长，全部都是Step by step式的Howto，请把它们看完，你将学会Linux VRF的使用方法！
Virtual Routing and Forwarding (VRF) Document：https://www.kernel.org/doc/Documentation/networking/vrf.txt
Virtual Routing and Forwarding (VRF)：https://github.com/Mellanox/mlxsw/wiki/Virtual-Routing-and-Forwarding-(VRF)
Lwn-net: VRF support：https://lwn.net/Articles/632522/
Working with VRF on Linux：http://www.routereflector.com/2016/11/working-with-vrf-on-linux/
Using VRFs with linux：https://andir.github.io/posts/linux-ip-vrf/
(3). Linux VRF实现概览
要说实现，虚拟网卡！本文提到的VRF也是基于虚拟网卡实现，每一个VRF域都表现为一个虚拟网卡，然后将具体的物理网卡(或者是别的虚拟网卡)添加到特定的VRF虚拟网卡，从而实现隔离：
从OpenVPN使用Tap/Tun，IPSec VTI，到Bridge，Bonding，VLan，VXLan…这些在Linux系统中，全部基于虚拟网卡来实现！总体来讲，所有这些虚拟网卡，最终都要有真实的东西附着在上面，比如：
附着字符设备在上面的：OpenVPN的Tun/Tap网卡
附着物理网卡的：Bridge，Bonding，VLan
附着加密引擎的：VTI
可见，VRF虚拟网卡实现了三层逻辑，该三层逻辑就是VRF路由表隔离,具体的实现细节下面的小节会结合代码详述，本节只是给出概览。
（4） Linux VRF的实现细节
VRF实现两阶段：
4.3内核~4.8内核：第一阶段基础版。基础设施不完善，需要外部策略路由规则配合才可用
4.8内核以后：第二阶段完备版。引入了L3mdev，完善的基础设施支持
数据包在被物理网卡ethX接收后，在netif_receive_skb中，会有rx_handler回调来截获数据包。VRF会注册一个rx_handler回调，该回调中将skb的dev字段替换为VRF虚拟网卡Device对象，这个处理是和Bridge处理一致的。接下来，系统依赖以下的事实来实现VRF逻辑：
数据包skb的dev字段已经是VRF设备，表明数据包看起来是通过VRF X来接收的用户显式配置的Policy Routing的rule要求来自VRF X接收的数据包要查询X号路由表.
这就实现了VRF逻辑。
可以看到，用户需要自己来手工完成策略路由表的定向操作，这个配置是重点，没有它的话，便不会让VRF网卡接收的数据包查询策略路由表。
这明显是一种很初级但可用(我的做法确实Low，但是就是可用！这是Linux的一种典型的文化)的做法。很自然的，Linux 4.8内核开始，VRF有了第二阶段的实现方法，省略了用户自己手工配置策略路由这个步骤。
VRF第二阶段 L3mdev 机制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/723f8031fc9a33d73a3c4b364ca26945/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f4d7f24ea1f734556b6e78185f841d5/" rel="bookmark">
			vue使用vedio.js播放视频（切换视频源）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vedio.js官方vue教程是采用组件模式，切换视频失败。
参考和众多网上教程，最后采用去掉组件，直接调用this.player.src（）方法切换成功记录下。
后续再研究组件的加载和传函数和参数的问题。
环境参数：
“video.js”: “^7.11.4”,
“vue”: “^2.6.11”,
代码如下：
&lt;template&gt; &lt;div&gt; &lt;button type="submit" class="btn btn-primary" @click="handle_src('http://1***42/hls/02.mp4','video/mp4')"&gt;01&lt;/button&gt; &lt;button type="submit" class="btn btn-primary" @click="handle_src('http://1***42/hls/01wlf.mp4','video/mp4')"&gt;02&lt;/button&gt; &lt;button type="submit" class="btn btn-primary" @click="handle_src('https://www.runoob.com/try/demo_source/movie.mp4','video/mp4')"&gt;03&lt;/button&gt; &lt;button type="submit" class="btn btn-primary" @click="handle_src('http://1***42/hls/zhibo.m3u8','application/x-mpegURL')"&gt;hls&lt;/button&gt; &lt;video ref="videoPlayer" class="video-js"&gt;&lt;/video&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import 'video.js/dist/video-js.css'; import videojs from 'video.js'; export default { name: "VideoPlayer", data () { return { videoOptions: { autoplay: "true", controls: "true", width: "900px", height: "500px", preload:'none', poster:"../assets/logo.png", sources: [ { src:"https://www.runoob.com/try/demo_source/movie.mp4", type: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f4d7f24ea1f734556b6e78185f841d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d135078df152b7af1f2dc965bbe08578/" rel="bookmark">
			哈夫曼树的构建(C语言版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈夫曼树的构建(C语言版) 课程要求： 左0，右1
左子树根节点 &lt; 右 子树根节点
节点 data, w , lchild, rchild
建立哈夫曼 （有序单链表）
初始：循环输入字符与权值，创建节点，插入到链表中 形成一个包含n个节点的递增单链表
然后：将第一、二两个节点从单链表中删除，然后合并形成新的节点，新节点插入到有序表中，直至剩下一个节点。
可以通过递归遍历的方法得到每个字符的 哈夫曼编码
建立有序单链表 有序单链表 typedef struct Link{ int w;//存储整形权重 char data;//存储char类型字符 struct Link *next;//指向直接后继元素的指针 struct Link *lchild; struct Link *rchild; }Link; 初始化链表 Link* InitLink(){ Link* link = (Link*)malloc(sizeof(Link));//创建头结点 link-&gt;next = NULL;//头结点的next为空 link-&gt;lchild = link-&gt;rchild = NULL; return link; } 排序插入元素(可以选择头插或者尾插，然后排序) void InsertLink(Link* link,Link* node){ Link* p = link; Link* q = p-&gt;next; while(q &amp;&amp; node-&gt;w&gt;q-&gt;w) { p=q;//记录位置 q=q-&gt;next; } node-&gt;next = q; p-&gt;next = node; } 删除节点,返回被删除的节点 Link* DelLink(Link* link,int index){ Link *p, *s; int i = 0; p = link; while(i&lt;index-1 &amp;&amp; p-&gt;next !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d135078df152b7af1f2dc965bbe08578/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32ebeb9d8ec297dcf467ce2319a20eac/" rel="bookmark">
			oracle帮助系统,oracle安装sqlplus的help帮助系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用sqlplus的时候可以通过help或?获得帮助信息，那么这些帮助信息是哪来的呢？
其实sqlplus的帮助信息从是数据库里表(system.help)里获取的。在$ORACLE_HOME/sqlplus/admin/help 目录下的helpus.sql文件里包含的帮助的信息，不过oracle默认带的帮助信息太少，自己可以通过其它途径获取更全的帮助脚本。那么我们自己如何来安装帮助呢？下面以系统自带的脚本为例来演示安装过程。
所有用的sql脚本都保存在 $ORACLE_HOME/sqlplus/admin/help 目录下，包含了四个文件：helpbld.sql helpdrop.sql helpus.sql hlpbld.sql，第一个helpbld.sql实际是调用第四个脚本hlpbld.sql来进行安装的，helpdrop.sql是删除help表和HELP_TEMP_VIEW视图的脚本，helpus.sql是安装的帮助信息。如果自己找到其它更全的脚本也放到这个目录下，便于管理。
因为help表是存在于oracle数据库里的，所以我们要保证oracle数据库已经启动，而且安装了sqlplus。之后以system身份登录在执行安装脚本helpbld.sql或hlpbld.sql均可。我们在执行脚本的时候需要输入两个参数
SQL&gt; @ ?/sqlplus/admin/help/helpbld.sql
Enter value for 1: $ORACLE_HOME/sqlplus/admin/help
Enter value for 2: $ORACLE_HOME/sqlplus/admin/help/helpus.sql
Enter value for 1: 帮助系统脚本所在目录
Enter value for 2: 帮助系统内容脚本
运行后sqlplus的help帮助系统就装好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a95974f1b8946f053685b3ec540221b/" rel="bookmark">
			线程等待
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Thread的几个重要方法线程通知与等待wait()/notify()/notifyAll()wait()函数获取监视器锁synchronized同步代码块共享变量方法，方法使用synchronized修饰虚假唤醒举例：消费者&amp;生产者 唤醒函数notify()函数notifyAll()函数 等待线程执行终止join睡眠sleep让出CPU执行权yield() Thread的几个重要方法 线程通知与等待wait()/notify()/notifyAll() Object类是所有类的父类，鉴于继承机制，Java把所有类都需要的方法放在了Object中，现在要用到的通知与等待系列函数也在其中。
wait()函数 当一个线程调用一个**共享变量的wait()**方法时，该调用线程会被阻塞挂起。
wait()方法是属于共享变量的！！！
线程想要申请一个共享变量，则需要等待共享变量空闲或者满足某种程序员需要的条件才可以申请到。如果共享变量是非空闲的状态或不满足条件，那么需要给共享变量加监视锁（监视到什么时候空闲或满足某种条件）并释放自己在当前变量上的其他锁以便别的线程使用（在其他变量上的锁是不会被释放的），等待其他占用线程释放该变量并唤醒该锁。
挂起线程什么时候被取下来开始返回进入运行状态呢？满足如下条件之一即可：
其他线程调用了该共享对象的notify()/notifyAll()方法唤醒。其他线程调用了该线程的interrupt()方法中断，该线程抛出InterruptedException异常返回（需要进行异常处理）。等待超时 :如果调用wait()之前没有获取该对象的监视器锁，就会抛出IllegalMonitorStateException异常。 获取监视器锁 synchronized同步代码块 使用该共享变量作为参数：
synchronized(共享变量) { //do something } 共享变量方法，方法使用synchronized修饰 synchronized void add(int a, int b) { //do something } 虚假唤醒 在不满足上述三个唤醒条件的情况下，也可能会从挂起变为运行状态，这就是所谓的虚假唤醒。为了避免这种情况发生，应该不停测试线程被唤醒的条件是否满足，不满足就继续等待(while)。
synchronized (obj) { while(条件不满足) { obj.wait(); } } 举例：消费者&amp;生产者 唤醒函数 notify()函数 一个线程在调用共享对象的notify()方法后，会唤醒一个在共享变量上wait等待的线程，如果有多个线程在等待，具体唤醒哪一个则是随机的。
被唤醒线程不会马上返回，必须在获取了共享对象的监视器锁才能返回（唤醒他的线程释放了他的监视器锁之后，但被唤线程不一定能获得此锁，得竞争）。
同时，只有当前进程获取到监视器锁才能调用notify()方法，否则会抛异常。
notifyAll()函数 唤醒共享变量上的所有wait挂起的线程。
等待线程执行终止join 有些场景需要等待某些事情完成后才能继续往下执行：多个线程加载资源等…
wait()等待通知方法是Object类中的方法
join()方法是Thread类直接提供的，无参，返回值void。
亲测：join()方法是阻塞，使得主线程等待join()线程执行完毕再往下执行。
CountDownLatch
睡眠sleep sleep方法是Thread类中的一个静态方法。
如果线程调用sleep方法，则线程会暂时让出指定时间的执行权，在这期间不参与CPU调度，但是所持监视器资源(锁等)不会让出。
睡眠时间到后，函数正常返回，线程处于就绪状态，参与CPU调度，获得CPU资源后可以继续运行。
如果睡眠期间，其他线程调用interrupt()中断该线程，则该线程在调用sleep处抛出异常InterrupetException并返回。
让出CPU执行权yield() yield()是Thread类中的一个静态方法。
一个线程调用yield方法，向线程调度器表明线程请求让出自己的CPU使用。但是线程调度器可以无条件忽略请求。
调用yield方法，当前线程让出CPU使用权，然后处于就绪状态。
一般较少是用这个方法，这个方法在调试或者测试是可以帮助复现由于并发竞争条件导致的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/695e5e0f7ee15b736c45b0d41f28a5d7/" rel="bookmark">
			SSM整合——简单的小项目实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录： 1.SSM整合思路
1.1 两个容器的创建 1.2 SSM整合开发的步骤
2.SSM整合开发 2.1 项目的大体结构 2.2 使用Navicat创建一个表（student2） 2.3 IDEA中使用maven创建一个web项目
2.4 在pom.xml文件中添加相关依赖
2.5 在web.xml文件中。声明容器对象
2.6 创建项目中特定的包（entity、dao、service、controller）
2.7 编写mybatis、spring、springmvc的配置文件 2.7.1 mybatis 2.7.2 spring
2.7.3 springmvc
2.8 编写Java代码（实体类、dao接口和对应的mapper文件、service类、controller类）
2.8.1 创建一个实体类 2.8.2 创建实体类对应的dao接口和接口对应的mapper文件 2.8.3 创建dao接口对应的service接口和实现类
2.8.4 创建一个控制器类（接收并处理请求）
2.9 创建视图文件（jsp）
2.9.1 首页（index.jsp）
2.9.2 注册学生页面（addStudent.jsp）
2.9.3 注册成功和失败的页面（success.jsp、fail.jsp）
2.9.4 查询学生页面（queryStudent.jsp）
2.10 为项目配置tomcat，启动测试！！！
2.10.1 注册学生的测试结果 2.10.2 查询学生的测试结果 3.写在结尾！！！
1.SSM整合思路 SSM：Spring + SpringMVC + MyBatis，就是使用这三个框架的优势功能来完成一些项目的构建。三个框架分别对应了三层架构中的每一层。Spring： 业务逻辑层；SpringMVC：视图层；MyBatis：持久层。
SSM整合了话，就需要把对象交给容器，让容器去创建项目中要使用的Java对象，目前有两个容器。
第一个：Spring容器，Spring容器管理的是service和dao等对象，是业务逻辑层对象的容器。
第二个：SpringMVC容器，这个容器管理的是控制器对象，也就是视图层的对象。
1.1 两个容器的创建 Spring容器的创建：在web.xml文件中声明 监听器 ContextLoaderListener ，这个功能框架中已经写好了，就是创建Spring的容器对象 WebApplicationContext，在创建 WebApplicationContext 对象时，读取Spring的配置文件，遇到&lt;bean&gt;标签或者注解，就可以创建service、dao等对象，这些对象最终都放在Spring容器中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/695e5e0f7ee15b736c45b0d41f28a5d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4379df3892abc78926adf966a6e641db/" rel="bookmark">
			flex布局中独占一行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在移动端的flex布局中，会将所有组件都全部挤在一行，很多时候希望能够达到float布局的效果，当其宽度超出后就换行
设置宽度为100%并不能达到想要的效果
.bStuname .userinput{ flex-direction: column; width: 100%; } 需要在其父组件开启flex-wrap:才能达到分层的效果
.bStuname{ display: flex; flex-wrap: wrap; margin-left: .33rem; margin-top: 0.66rem; } &lt;template&gt; &lt;div class="bStu"&gt; &lt;div class="bStutop"&gt; &lt;img :src="url" alt=""&gt; &lt;div class="bStuname"&gt; &lt;h2&gt;{{this.$store.state.username}}&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="bStuBody"&gt; &lt;div class="bStuContent"&gt; &lt;div class="bStuInfo"&gt; &lt;h2&gt;学号&lt;/h2&gt; &lt;input type="text" v-model="stuid"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="bStuContent"&gt; &lt;div class="bStuInfo"&gt; &lt;h2&gt;宿舍号&lt;/h2&gt; &lt;input type="text" v-model="roomid"&gt; &lt;/div&gt; &lt;/div&gt; &lt;van-button type="primary" @click="submitinfo"&gt;更改信息&lt;/van-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:'bland', data() { return { url:'', username:'', isinput:false, roomid:'', stuid:'' } }, methods: { changeUsername(){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4379df3892abc78926adf966a6e641db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60962ea00cb50f2ef231595a24851337/" rel="bookmark">
			HuTool
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HuTool Hutool参考文档
1、简介 2、包含组件 一个java基础工具类，对文件、流、加密解密、转码、正则、线程、XML等JDK方法进行封装，组成各种Util工具类，同时提供以下组件：
注意：可以根据需求对每个模块单独引入，也可以通过引入hutool-all方式引入所有模块
3、使用Hutool 直接在项目中导入依赖即可：
&lt;!-- https://mvnrepository.com/artifact/cn.hutool/hutool-all --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.3.10&lt;/version&gt; &lt;/dependency&gt; 4、Convert类型转换 3、如何使用 转换为字符串
5、IO流操作 package cn.dxj1016.Hutool; import cn.hutool.core.io.IoUtil; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class TestOUtils { public static void main(String[] args) throws IOException { // 原始文件拷贝 FileInputStream is = new FileInputStream(new File("D:\\笔记\\java\\狂神说java\\程序2\\mybatis-Study\\mybatis-01\\src\\main\\resources\\aa.txt")); FileOutputStream os = new FileOutputStream(new File("D:\\笔记\\java\\狂神说java\\程序2\\mybatis-Study\\mybatis-01\\src\\main\\resources\\cc.txt")); //使用Hutool IoUtil.copy(is, os); // IoUtil.copy(is, os，2024);//指定缓冲区大小 /*// 定义缓冲区 byte[] b = new byte[1024]; int len = 0; while (true) { len = is.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60962ea00cb50f2ef231595a24851337/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff145ccbf87cb0c527e2ad815e49dc45/" rel="bookmark">
			HTML中的 ＜!DOCTYPE＞ 声明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML中的 &lt;!DOCTYPE&gt; 声明：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 内容...... &lt;/body&gt; &lt;/html&gt; 几乎所有主流浏览器都支持 &lt;!DOCTYPE&gt; 声明。（其中包括像IE、火狐、Opera、Google Chrome、Safari等主流浏览器)。
声明位于文档中的最前面的位置，处于 标签之前。 声明本身不是一个 HTML 标签；它是用来告知 Web 浏览器页面使用了哪种 HTML 版本。 现在的前端页面开发中，基本都更新到了HTML5，HTML5 不是基于 SGML，因此不要求引用 DTD。且HTML5只规定了一种&lt;!DOCTYPE&gt; 声明，即上述示例代码中的
我们要养成一个添加&lt;!DOCTYPE&gt; 声明的习惯，确保浏览器能够预先知道文档类型。
备注：&lt;!DOCTYPE&gt; 声明不区分大小写。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/981eb363df29f3fb1f198ad42eec44bd/" rel="bookmark">
			装oracle有什么要求,安装Oracle11g的一些注意点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽说Oracle 11g不是目前最新的版本，但使用的人还是很多，在教学中还是常用的版本，在安装oracle 11g时，我总结了一些自己填过的坑，希望对大家有益。
1. 关闭安全软件(如“360安全卫士”)再安装Oracle 11g
2. 密码不能采用数字开头，必须以字母开头(话说这是一个很坑人的地方，在创建密码的时候没有这个要求，但如果密码是以数字开头安装到后面就会锁定system账号)，密码不能超过30个字符，只能是：A-Z，a-z, 0-9, _, $，和#这些字符。不能使用保留字和关键字。
3. 要想使用Sql Developer，必须要安装32位的jdk,最好是jdk1.5版本，并修改sqldeveloper.conf文件，该文件位于：{ORACLE_HOME}\dbhome_1\sqldeveloper\sqldeveloper\bin目录下，此处{ORACLE_HOME}指你的Oracle安装目录，如我的是：G:\OracleBaseDir\product\11.2.0。这是最坑的地方，Oracle11g仅支持32位的java,不支持自带的64位java(我想大家下载Oracle11g时大部分都是下载64位版本吧)。找到sqldeveloper.conf文件的最后，确保SetJaveHome正确地指向你32Jdk的安装目录，修改如：
SetJavaHome C:\Program Files (x86)\Java\jdk1.5
大家在使用时还有什么填过的坑，欢迎在底下留言，共同学习。
PS：还有一条，如果win10系统，安装时会弹出对话框“[INS-13001]环境不满足最低要求”，这是由于11g发行时还没有win10操作系统，可以如下处理：
打开解压缩后的database文件夹，在文件：\database\stage\cvu\cvu_prepreq.xml中添加win10。找到CERTIFIED_SYSTEMS节点，添加如下配置：
保存好，重新安装即可。
文章来源: blog.csdn.net，作者：javafalcon，版权归原作者所有，如需转载，请联系作者。
原文链接：blog.csdn.net/javafalcon/article/details/109441931
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa70fed6f37e2d14a3c5352eac9c0780/" rel="bookmark">
			oracle如何杀死所有进程,杀死oracle进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL&gt; select session_id from v$locked_object;
SESSION_ID
----------
142
SQL&gt; SELECT sid, serial#, username, osuser FROM v$session where sid = 142;
SID SERIAL# USERNAME OSUSER
---------- ---------- ------------------------------ ------------------------------
142 38 SCOTT LILWEN
SQL&gt; ALTER SYSTEM KILL SESSION '142,38';
System altered
SQL&gt; SELECT sid, serial#, username, osuser FROM v$session where sid in(select session_id from v$locked_object);
Oracle数据库操作中，我们有时会用到锁表查询以及解锁和kill进程等操作，那么这些操作是怎么实现的呢？本文我们主要就介绍一下这部分内容。
(1)锁表查询的代码有以下的形式：
select count(*) from v$locked_object;
select * from v$locked_object;
(2)查看哪个表被锁
select b.owner,b.object_name,a.session_id,a.locked_mode from v$locked_object a,dba_objects b where b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa70fed6f37e2d14a3c5352eac9c0780/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cf0a9cf3500a336d5ee7cd4a1857307/" rel="bookmark">
			TableView设置滚动条不显示问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QTableView 如何设置滚动条？ ui-&gt;m_tableViewOrder-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded); ui-&gt;m_tableViewOrder-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded); Qt::ScrollBarAsNeeded：当TabelView无法完全显示时，自动出现滚动条，默认是这个 Qt::ScrollBarAlwaysOff：无论什么情况，滚动条都不显示 Qt::ScrollBarAlwaysOn：滚动条一直显示 为什么我设置了滚动条却没有显示？ 在一次项目开发中，我用到了QTabelView，开发中采用了Qt中的UI设计师完成界面的布局设计，TabelView我设置了最小的宽 400，高200，但是我把主窗口缩小到很小，界面并没有显示滚动条，然后我就调用代码Qt::ScrollBarAlwaysOn 让滚动条一直显示，但是结果还是一样，不管我把界面缩小到什么程度，依然还是没有看到滚动条的出现，即使TabelView的内容已经显示不出，因此，我非常的纳闷。
经过了一段时间的捣鼓之后，依然没有结果，然后请教我身边的同事，原来她以前也遇到过类似的情况，原来是因为我设置了TabelView的最小值是400,200，即使窗口缩小了，但是TabelView并没有缩小，TabelView中的内容仍然在400,200这个范围内可以显示完整，所以不会出现滚动条
解决方法： TabelView的最小值不用设置，保持默认的0,0，这样，你手动缩小界面的是时候，显示不全时，会自动出现滚动条的，并不需要手动设置滚动条一直出现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/216c3c22d45f9ab989563eb8de8379e8/" rel="bookmark">
			MTK 平台TP 驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面以汇顶gt9xx_driver.c 驱动为例讲解TP 驱动的整个关键点，本篇只讲TP 驱动本身的代码，
在驱动代码涉及的方法技术，因为每一个都牵涉linux内核的设计和知识，后面会逐个展开深入讲解。
首先，我们来总体看下TP 驱动代码初始化流程：
MTK kernel-4.14 TP 驱动初始化和部分工作流程main.cmain.cgt9xx_driver.cgt9xx_driver.cmtk_tpd.cmtk_tpd.ci2c.hi2c.hkthread.hkthread.hwait.hwait.hgt9xx_update.cgt9xx_update.cdo_initcallsmodule_inittpd_driver_inittpd_get_dts_infotpd_driver_addtpd_local_initi2c_add_drivertpd_i2c_probetpd_power_ongtp_init_panelkthread_runtouch_event_handlerwait_event_interruptibletpd_irq_registrationtpd_interrupt_handlerwake_up_interruptiblegup_init_update_proc
首先看TP 驱动模块初始化：
1
2
3
4
5
6
7
8
9
static int __init tpd_driver_init(void)
{
GTP_INFO("GT9 series touch panel driver init");
tpd_get_dts_info();
if (tpd_driver_add(&amp;tpd_device_driver) &lt; 0)
GTP_INFO("add generic driver failed");
return 0;
}
请注意这个tpd_driver_init 是一个__init 修饰的函数，说明这个函数在编译时会被放到跟其他__init 修饰的函数放到一起，
在系统初始化，一旦内核启动后，就释放这些东西。一般用__init修饰的变量或者函数会编译到专门的一个段里面去，
这个段的数据和函数只有在kernel初始化的时候会被调用，以后一定不会被使用，kernel可能会在以后的某个时候释放掉这个段所占用的内存，
给别的地方使用，是不是设计很巧妙？ 感兴趣的同学可以继续深入分析看看。
那么，我们看到这个函数主要就做了两件事情：
（1）是获取这个TP 所有的DTS 信息，我们看看这个代码的实现：
1
2
3
4
5
6
7
8
9
10
11
12
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/216c3c22d45f9ab989563eb8de8379e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ad736bbad1ff0d893dd27acd7ac54b3/" rel="bookmark">
			nginx访问php文件 an error,Nginx访问PHP提示An error occurred.  the page you are looking for is currently unav...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前一直玩windows，现在被
安装完nginx和PHP等环境后，Nginx访问PHP提示
An error occurred.
Sorry, the page you are looking for is currently unavailable.
Please try again later.
If you are the system administrator of this resource then you should check theerror log for details.
Faithfully yours, nginx.
——最后发现，我犯了个低级错误，PHP没启动。
ngnix中重启php
service php-fpm start
service php-fpm stop
service php-fpm restart
service php-fpm reload
其他可能的错误，来自网络整理：
问题1：仔细检查下 Nginx配置文件，是配置不当造成的！:
比如说，有朋友遇到的出错原因如下：
nginx.conf配置文件有这么一段代码：
include vhost/*.conf;
它表示包含 vhost 目录下的所有虚拟机配置文件。在语法上，通过 命令 nginx -t 去检测，它是没错的，但是事实上 vhost文件夹是不存的(忘记建立)，所以nginx进程虽然能跑起来，但是前端页面展示还是报错的，最后的解决方案 当然是新建 vhost目录即可！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ad736bbad1ff0d893dd27acd7ac54b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a765a44077f68e69545c00bcdfc0abe/" rel="bookmark">
			如何查看oracle资源,oracle查看资源管理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源管理器的配置在一组dba视图显示，主要是如下：
dba_rsrc_plans显示计划和状态。
dba_rsrc_plan_directives显示计划指令
dba_rsrc_consumer_groups显示使用者组
当前情形显示在v$视图中：
v$session显示每个会话的活动使用者组
v$rsrc_plan显示当前活动的计划
v$rsrc_consumer_group显示活动计划中的指令对应的使用者组的统计信息。
如果会话受到资源管理器的影响，它就会显示为等待事件。会话在等待时，该事件可以在v$session.event列中显示。在v$session_event视图中会显示自会话启用以来等待的累积时间
查看Resourceconsumer group
selectconsumer_group from dba_rsrc_consumer_groups;
selectNAME,ACTIVE_SESSIONS,EXECUTION_WAITERS,SQL_CANCELED from v$rsrc_consumer_group;
查看Resource Plan
selectplan from dba_rsrc_plans;
或
selectname,is_top_plan from v$rsrc_plan;
Oracle Resource Manager的启与用停止
通过设置init.ora或spfile.ora文件中的resource_manager_plan参数来进行启用，如下：
SQL&gt; alter system set resource_manager_plan= membership_plan
说明：如果需要停止，那么将其设置为空即可(resource_manager_plan=' ')。下面，我们查看当前的活动资源：
动态性能视图及数据字典：
DBA_RSRC_CATEGORIES
DBA_RSRC_CONSUMER_GROUP_PRIVS
DBA_RSRC_CONSUMER_GROUPS
DBA_RSRC_GROUP_MAPPINGS
DBA_RSRC_IO_CALIBRATE
DBA_RSRC_MANAGER_SYSTEM_PRIVS
DBA_RSRC_MAPPING_PRIORITY
DBA_RSRC_PLAN_DIRECTIVES
DBA_RSRC_PLANS
v$RSRC_CONS_GROUP_HISTORY
v$RSRC_CONSUMER_GROUP
v$RSRC_CONSUMER_GROUP_CPU_MTH
v$RSRC_PLAN
v$RSRC_PLAN_CPU_MTH
v$RSRC_PLAN_HISTORY
v$RSRC_SESSION_INFO
v$RSRCMGRMETRIC
v$RSRCMGRMETRIC_HISTORY
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e2e089f813c9ac6cea4e6f89eac657a/" rel="bookmark">
			arm平台访问oracle数据库,通过JDBC解决Python在ARM上的Oracle访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle Client是一套闭源的客户端，在哪个平台上可以使用完全由Oracle官方决定。如附录所示，Oracle Client并不直接支持ARM上的访问。
那么是不是Python等语言就无法在ARM上访问Oracle了呢？在Stackoverflow上也有人讨论了这样几个方法：
解析Oracle Client Interface 通讯协议，可以做但是成本高且有法律和升级失效等风险
使用X86作为中转，但是不纯粹且依赖链长
使用Python-JDBC，已经有成熟方案JayDeBeApi https://pypi.org/project/JayDeBeApi/，通过JPype启动一个JVM进行中转
此外，还有通过pyarrow.jvm加速Python访问JDBC的方法，请参考我的上一篇转发文章https://blog.csdn.net/gikod/article/details/105189589 。
在Stackoverflow上，已经有人验证过树莓派ARM访问Oracle数据库。
https://stackoverflow.com/questions/56838410/problem-classpath-for-jaydebeapi-from-raspberry
$ pip install JayDeBeApi
&gt;&gt;&gt; import jaydebeapi
&gt;&gt;&gt; #conn = jaydebeapi.connect("org.hsqldb.jdbcDriver",
... # "jdbc:hsqldb:mem:.",
... # ["SA", ""],
... # "/path/to/hsqldb.jar",)
&gt;&gt;&gt; conn=jaydebeapi.connect('oracle.jdbc.driver.OracleDriver',
'[admin]/[root]@(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=helloworld.com)(PORT=1521))(CONNECT_DATA=(SID=hello42)))',
jars='/home/pi/ojdbc6.jar')
&gt;&gt;&gt; curs = conn.cursor()
&gt;&gt;&gt; curs.execute('create table CUSTOMER'
... '("CUST_ID" INTEGER not null,'
... ' "NAME" VARCHAR not null,'
... ' primary key ("CUST_ID"))'
... )
&gt;&gt;&gt; curs.execute("insert into CUSTOMER values (1, 'John')"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e2e089f813c9ac6cea4e6f89eac657a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/026a41f4eacbacc06c09632a35824f3c/" rel="bookmark">
			python turtle 手撸RRT算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python RRT源代码 # -*- coding: utf-8 -*- """ Spyder Editor This is a temporary script file. """ import random import math import turtle as t t.speed(10000) #initial the map 500*500 map +-250 t.pu() t.goto(-250,250) t.pd() t.fd(500) for i in range(3): t.right(90) t.fd(500) #initial the obstacle x1 -250&lt;x&lt;-100 25&lt;y&lt;75 t.begin_fill() t.color("black") t.pu() t.goto(-250,75) t.pd() t.right(90) t.fd(150) t.right(90) t.fd(50) t.right(90) t.fd(150) t.right(90) t.fd(50) t.end_fill() #initial the obstacle x2 -150&lt;x&lt;-50 -250&lt;y&lt;-50 t.begin_fill() t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/026a41f4eacbacc06c09632a35824f3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9876eb8dec8da8ebf05f13b1572c463a/" rel="bookmark">
			oracle 按照字段分裂,Oracle中按指定字符拆分字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle中按指定字符拆分字段：
一、建表语句
-- Create table
create table TEST1
(
id VARCHAR2(100) not null,
name_age VARCHAR2(100)
);
二、建出来的表：
三、按’/’拆分字段，拆成如下图所示：
四、SQL语句
SELECT
name_age,SUBSTR(name_age,1,INSTR(name_age,'/')-1),
SUBSTR(name_age,INSTR(name_age,'/')+1,(INSTR(name_age,'/',1,2)-INSTR(name_age,'/')-1))
, SUBSTR(name_age,INSTR(name_age,'/',1,2)+1) FROM test1 FOR UPDATE
五、函数介绍
SUBSTR函数：用来截取字段
SUBSTR(str,pos):
由中，选出所有从第位置开始的字元。
SUBSTR(str,pos,len):
由中的第位置开始，选出接下去的个字元。
INSTR函数：定位指定字符的位置
instr(str,chr) ---chr在str中第1次出现的位置
instr(str,chr,3,2) ---从str第3个字符位置开始搜索chr在str中第2次出现的位置
instr(str,chr,-3,2) ---从str的从右向左数第3个字符位置开始反向搜索chr在str中第2次出现的位置
INSTR(c1,c2,i,j)
c1,c2均为字符串，i,j为整数。函数返回c2在c1中第j次出现的位置，搜索从c1的第i个字符开始。当没有发现需要的字符时返回0,如果i为负数，那么搜索将从右到左进行，但是位置的计算还是从左到右，i和j的缺省值为1.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3155b45d273427f6330fa01a8e623b42/" rel="bookmark">
			LINUX开启ssh服务，报错：ssh: connect to host 192.168.0.101 port 22: Connection refused
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Ubuntu下测试ssh时使用ssh localhost 命令，出现错误提示connect to host localhost port 22:Connection refused
造成这个错误的原因可能是ssh-server未安装或者未启动。
提示：ubuntu 11.10 默认安装openssh-client，但是没有安装server（其他博主说的，未验证）；博主的Ubuntu是16.10，测试发现 openssh-client 和 openssh-server 均没有安装
运行 ps -e | grep ssh，查看是否有sshd进程
如果没有，说明server没启动，通过 /etc/init.d/ssh -start 启动server进程
如果提示ssh不存在 那么就是没安装server，通过 sudo apt-get install openssh-server命令安装即可。如果没有报错，说明安装成功，在此博主恭喜你，不像博主一直报错。
如果安装过程中报错（不要伤心，博主和你一样哦），缺少依赖包，如下图所示：
分析问题出现原因：openssh-server所依赖的openssh-client版本不存在，openssh-client没有安装或者安装的版本不匹配
解决方法：安装提示的openssh-client版本
比如我的只需要执行如下命令：sudo apt-get install openssh-client=1:7.2p2-4ubuntu2.10，安装openssh-client时，会询问你是否继续，输入 y ，按回车即可
openssh-client安装成功！
提示：此处应该使用管理员权限（sudo），否则会报错（13: Permission denied），如下图所示：
回过头来继续安装openssh-server
openssh-server安装成功！
再次使用ssh localhost 命令，发现能够正常连接
如果对您有帮助，赏口饭吃❤谢谢老板❤ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d286394cbfbc1fea2c7c6d495522041/" rel="bookmark">
			oracle中的 命令是什么,Oracle中SQL里面的Help命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直在寻找关于Oracle命令的一些帮助和提示，因为Oracle在sql命令中并没有提示。想想应该是sql太过于复杂，也太过于变化，使用一些公式的方式提供可能太过于麻烦，Oracle直接就提供了一本SQL Reference供你查询.
不过也不是一点帮助信息也没有.
你可以在sql下执行? index或者help index就会有一些帮助的信息.
SQL&gt; help index
Enter Help [topic] for help.
@ COPY PAUSE SHUTDOWN
@@ DEFINE PRINT SPOOL
/ DEL PROMPT SQLPLUS
ACCEPT DESCRIBE QUIT START
APPEND DISCONNECT RECOVER STARTUP
ARCHIVE LOG EDIT REMARK STORE
ATTRIBUTE EXECUTE REPFOOTER TIMING
BREAK EXIT REPHEADER TTITLE
BTITLE GET RESERVED WORDS (SQL) UNDEFINE
CHANGE HELP RESERVED WORDS (PL/SQL) VARIABLE
CLEAR HOST RUN WHENEVER OSERROR
COLUMN INPUT SAVE WHENEVER SQLERROR
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d286394cbfbc1fea2c7c6d495522041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/865b8673a710410b8f8f94343d3e1414/" rel="bookmark">
			[VSCode]Todo Tree 一款待办事项插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[VSCode]Todo Tree 一款待办事项插件 Todo Todo Tree 一款待办事项插件
我们写程序的时候，难免会遇到一些情况需要标记或者搁置，在写代码的时候会用一些特殊的注释来表示不同的内容，使我们可以快速的定位我们注释的位置。
主要有以下几种：
TODO: 用来标记待办的地方。常常在有些地方，我们的功能并没有实现，使用ToDo标记我们可以快速定位需要实现的部分。
HACK: 用来标记可能需要更改的地方。在写代码的时候，有的地方我们并不确定他是正确的，可能未来有所更改，这时候可以使用HACK标记。
NOTE: 添加一些说明文字。
INFO: 用来表达一些信息。
TAG: 用来创建一些标记。
XXX: 用来标记一些草率实现的地方。在写代码的时候，有些地方需要频繁修改，这时候使用XXX标记。
BUG: 用来标记BUG~
FIXME: 用来标记一些需要修复的位置，可以快速定位。
下面是我的一些配色：(左侧可以通过点击快速定位到位置)
配置代码：(直接设置里搜索todo tree，然后随便选一个能打开setting.json的选项，复制进去覆盖就好了)
"todo-tree.tree.showScanModeButton": false, "todo-tree.filtering.excludeGlobs": ["**/node_modules", "*.xml", "*.XML"], "todo-tree.filtering.ignoreGitSubmodules": true, "todohighlight.keywords": [ ], "todo-tree.tree.showCountsInTree": true, "todohighlight.keywordsPattern": "TODO:|FIXME:|NOTE:|\\(([^)]+)\\)", "todohighlight.defaultStyle": { }, "todohighlight.isEnable": false, "todo-tree.highlights.customHighlight": { "BUG": { "icon": "bug", "foreground": "#F56C6C", "type": "line" }, "FIXME": { "icon": "flame", "foreground": "#FF9800", "type":"line" }, "TODO":{ "foreground": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/865b8673a710410b8f8f94343d3e1414/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dc7f5ac02500c58d5742532e0d10631/" rel="bookmark">
			linux常用基本操作（考试复习）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux常用基本操作考试复习 用户界面与shell命令1.修改主机名2.passwd 用于更改账号密码3.pwd 以绝对路径的方式显示用户当前工作目录4.ls 列出文件或目录信息ls -a 显示所有文件和目录（包括隐藏的文件）ls -l 以列表形式显示 5.cat 滚屏显示文件内容，也可将多个文件合并成一个文件less 既可以向前翻页也可以向后翻页less还可以进行模式查找more 只能向后翻页常用参数 head 查看文件前n行tail 查看文件后n行输出重定向 &gt; 与输入重定向 &lt;统计行数，单词数和字符数并显示 6.mkdir 创建一个或多个目录(make)mkdir -p 要建立的目录的父目录不存在，同时创建该目录及其父目录 7.rmdir 创建一个或多个目录(remove)rmdir -p 删除时一并删除父目录，要求父目录中没有其他目录存在 8.touch 新建普通文件9.cp 文件或目录的复制10.mv 移动或更改文件或目录名称(move)11.rm删除文件或目录（remove）-f 删除文件时不提示用户-r 递归删除目录，即删除目录下的文件及各级子目录 12.man 课后作业 用户界面与shell命令 1.修改主机名 hostnamectl set-hostname zst0204 修改主机名为zst0204，再用su登录管理员用户，即可看到主机名修改成功
2.passwd 用于更改账号密码 例如
这种方式需要人机交互更改密码，密码需要输入两次。
使用echo “123456” | passwd --stdin user(user为用户名)可以不用人机交互直接修改密码
3.pwd 以绝对路径的方式显示用户当前工作目录 绝对路径：从根目录开始显示
例如
显示根目录为/root
4.ls 列出文件或目录信息 输出的信息会进行彩色加亮显示，以区分不同类型的文件
ls -a 显示所有文件和目录（包括隐藏的文件） ls内定将文件名或目录名称为“.”的视为隐藏，不会列出
ls -l 以列表形式显示 文件输出信息从左到右为文件名、文件类型、权限模式、硬连接数、所有者、组、文件大小和文件最后修改时间等
5.cat 滚屏显示文件内容，也可将多个文件合并成一个文件 以分页的方式查看文件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dc7f5ac02500c58d5742532e0d10631/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91a160a6e0e2e6d6df12d96ea99f3912/" rel="bookmark">
			【Gradle日常问题】java.lang.NoClassDefFoundError: org/gradle/api/internal/plugins/DefaultConvention
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 开发环境是MAC，gradle是从网上下载的包https://services.gradle.org/distributions/，springboot项目是https://start.spring.io/下载的
从SpringBoot的https://start.spring.io/下载下来的最新版2.4.4，使用idea构建gradle项目失败，最开始报错：java.lang.NoClassDefFoundError: org/gradle/api/internal/plugins/DefaultConvention
二、问题排查 本地使用idea构建gradle的版本6.6，估计与springboot版本2.4.4不匹配，导致有些类找不到
三、问题解决 降低springboot版本 2.2.13.RELEASE，重新下载gradle新的版本5.6.4尝试，build成功。
四、总结 1. 使用idea构建springboot项目，用gradle配置，经常会出现gradle和springboot不匹配问题，只有不断的尝试
2. 在idea构建时不要主动停掉gradle，会引发比较多的问题，rm -rf ~/.gradle/caches可以解决，不行就重启MAC
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f983d3ca440af76567810781bcbf695/" rel="bookmark">
			Graph Neural Networks for Social Recommendation 论文解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Graph Neural Networks for Social Recommendation 摘要 近年来，图神经网络可以自然地整合节点信息和拓扑结构，因此已被证明在图表数据的学习中具有强大的能力。GNNs的这些优点为推进社交推荐提供了巨大的潜力，因为社会推荐系统中的数据可以表示为用户-用户社交图和用户-项目图；而且学习用户和项目的潜在因素是关键。然而，构建基于GNNs（图神经网络）的社交推荐系统面临着挑战。例如，用户-项目图对交互及其相关的意见进行编码（the user-item graph encodes both interactions and their associated opinions）；社交关系具有异质强度（social relations have heterogeneous strengths）；用户涉及两个图(例如，用户-用户社交图和用户-项目图)（users involve in two graphs）。为了同时解决上述三个挑战，在本文中，对于社交推荐，我们提出了一种新的图神经网络框架（GraphRec）。特别是，我们提供了一种原则性的方法来联合捕获用户-项目图中的交互和意见（user-item间的联系以及user对item的评分），并提出了框架GraphRec，该框架连贯地对两个图和异构强度进行建模。在两个实际数据集上的广泛实验证明了所提出的框架GraphRec的有效性。
构建基于GNNs的社交推荐系统面临着三个挑战： （1）the user-item graph encodes both interactions and their associated opinions（user-item图包含了它们之间的交互以及user对item的评分） （2）social relations have heterogeneous strengths（社交关系具有异质强度） （3）users involve in two graphs（user-user, user-item）（整合user-user graph和user-item graph） 从而提出了本文的图神经网络框架（GraphRec），同时解决以上挑战。 1.介绍 近年来，推荐系统对社会关系的利用已经引起了越来越多的关注。这些社交推荐系统是根据用户通常通过他们周围的人获取和传播信息的现象发展起来的，比如同学、朋友或同事，说明用户的潜在社交关系可以在帮助他们过滤信息方面发挥着重要作用。因此，社交关系已被证明有助于提高推荐性能。
近年来，针对图数据的深度神经网络技术得到了巨大的发展，这些深度神经网络结构被称为图神经网络(GNNs)，已被提出学习对图数据有意义的表示。他们的主要思想是如何利用神经网络迭代地聚合来自局部图邻域的特征信息，与此同时，节点信息可以在转换和聚合后通过一个图进行传播。因此，GNNs自然地整合了节点信息和拓扑结构，并被证明在表示学习中具有强大的能力。另一方面，社会推荐中的数据可以用两个图表示为图形数据。如图1所示，这两个图包括一个表示用户之间关系的社交图，以及一个表示用户和项目之间交互的用户-项目图。用户同时参与两个图中，谁可以联系它们。此外，社交推荐的自然方式是将社交网络信息合并到用户和项目的潜在因素学习中，学习项目和用户的表示是构建社交推荐系统的关键。因此，鉴于它们的优点，GNNs为推进社交推荐提供了前所未有的机会。
图1：社交推荐中的图表数据。它包含两个图，包括用户-项目图（左侧）和用户-用户社交图（右侧）。请注意，用户项目图边缘上的数字表示用户通过交互对项目的意见（或评分）。
同时，基于GNNs的社交推荐系统的构建面临着挑战。社交推荐系统中的社交图和用户-项目图从不同的角度提供了关于用户的信息。从两个图中聚合信息以学习更好的用户表示是很重要的。因此，第一个挑战是如何内在地结合这两个图（用户-项目图，用户-用户图）。此外，用户-项目图不仅包含用户和项目之间的交互，而且还包括用户对项目的意见。例如，如图1所示，用户会与“裤子”和“笔记本电脑”等项目进行交互；用户会喜欢“裤子”，而不喜欢“笔记本电脑”。因此，第二个挑战是如何共同捕获用户和项目之间的交互和意见。此外，联网的世界中链接形成链接的低成本可以导致具有不同连接强度的网络（例如，强联系和弱联系混合在一起）。相比弱联系，用户可能会与强联系的人分享更多相似的口味。平等地考虑社会关系可能导致推荐性能的下降。 因此，第三个挑战是如何区分具有异质强度的社会关系。在本文中，我们的目标是建立基于图神经网络的社交推荐系统。特别地，我们提出了一种新的社会推荐图神经网络GraphRec，它可以同时解决上述三个挑战。
我们的主要贡献总结如下： 1. 我们提出了一种新的图形神经网络GraphRec，它可以连贯地对社会建议中的图形数据进行建模；· 2. 我们提供了一种原则性的方法来联合捕获用户项图中的交互和意见；· 3. 我们介绍了一种在数学上考虑社交关系的异构强度的方法；· 4. 我们证明了所提出的框架在各种真实世界数据集上的有效性。 本文的其余部分组织如下。 我们在第二节中介绍了所提出的框架。 在第三节中，我们对两个真实世界的数据集进行了实验，以说明该方法的有效性。在第四节中，我们回顾了与我们的框架有关的工作。最后，我们在第五节中总结了我们的工作和未来的方向。
2.提出的框架 在本节中，我们将首先介绍本文使用的定义和符号，接下来概述所提出的框架，然后详细介绍每个模型组件，最后讨论如何学习模型参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f983d3ca440af76567810781bcbf695/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b9359034d2c370d5eec25aaa5dbbdc/" rel="bookmark">
			“山东大学移动互联网开发技术教学网站建设”项目实训日志二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间： ​ 21春季学期第四、五周
个人工作内容： ​ 完成Hello World案例app
详细记录： Hello World案例app设计说明 目标用户：有一定java基础的初次接触android开发的学生。需求说明：简述项目开发流程，工程相关解析，介绍android开发基础内容。设计说明：android中常用的LinearLayout(线性布局)和RelativeLayout(相对布局)，android中常用的UI控件，其中穿插Toast（提示信息的一个控件）、基于监听的事件处理机制等内容。后续内容在其它专题案例app中借实例讲解。 app页面展示： 多个按钮可以用switch来设置监听事件 private void setListeners(){ OnClick toclick = new OnClick(); mButtonLlay.setOnClickListener(toclick); private class OnClick implements View.OnClickListener{ @Override public void onClick(View v) { Intent intent = null; switch (v.getId()){ case R.id.btn_llay: intent = new Intent(MainActivity.this, LinearLayoutActivity.class); break; 线性布局：
需要设置orientation（线性方向，水平or垂直）；
线性布局可以嵌套，从而设计出美观的布局；
weight设置View比重；
在线性布局中layout_gravity可以让组件设置靠左右/上下（垂直布局/水平布局）。 &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;TextView android:layout_width="130dp" android:layout_height="fill_parent" android:background="#84a9ac"&gt; &lt;/TextView&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="fill_parent" android:background="#a3d2ca" android:orientation="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58b9359034d2c370d5eec25aaa5dbbdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/401aaa93f0a4a8e4d89a6d3082a7e0f9/" rel="bookmark">
			TensorFlow 安装加载 ImportError: /lib64/libm.so.6: version `GLIBC_2.23‘ not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误原因：
glibc 版本过低 解决办法，下载更新glibc(所有版本https://ftp.gnu.org/gnu/glibc/?C=M;O=D)
wget https://mirrors.sjtug.sjtu.edu.cn/gnu/libc/glibc-2.28.tar.gz tar zvxf glibc-2.28.tar.gz cd glibc-2.28 mkdir /opt/glibc-2.28 mkdr build cd build ../configure --prefix=/opt/glibc-2.28 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/800480527edf014c52cbbef5e786a924/" rel="bookmark">
			WSL2 CUDA踩坑指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		必要环境 1. 支持CUDA的显卡。。。（我的是1660Ti）
2.WSL2 （没有升级的参考https://docs.microsoft.com/en-us/windows/wsl/install-win10）
3. 官方推荐win10 Build 20150 or higher（ 但是我的是21H1 19043，好像也可以），实测是这样的。。在预览计划中选择dev通道，更新最新版本的windows
安装步骤： Nvidia预览版驱动 去这个网站下：https://developer.nvidia.com/cuda/wsl
下面的操作都在WSL2中了。我的是Ubuntu2004
添加源 apt-key adv --fetch-keys http://developer.download.nvidia.cn/compute/cuda/repos/ubuntu2004/x86_64/7fa2af80.pub sudo sh -c 'echo "deb http://developer.download.nvidia.cn/compute/cuda/repos/ubuntu2004/x86_64 /" &gt; /etc/apt/sour ces.list.d/cuda.list' sudo apt-get update 原nVidia指南网站上有个坑，除了修改对应系统版本外，还要修改.com -&gt; .cn，不然update会失败，参考：https://github.com/microsoft/WSL/issues/5682#issuecomment-788744572
安装cudatools sudo apt-get install -y cuda-toolkit-11-0 因为我的win10版本比官方推荐低，本来以为会失败，没想到到这里一切顺利。。。
这一步有点漫长，可以去休息一会儿了~
运行示例程序 首先切换到目录
cd /usr/local/cuda/samples/4_Finance/BlackScholes 然后执行sudo make，构建程序，输出如下：
貌似有点问题。。
执行程序
./BlackScholes 果然有问题：
改日再战。。
更新系统版本后就没有问题了：
实测pytorch也可以正常启用cuda：
参考网站：
1. 微软： https://docs.microsoft.com/en-us/windows/win32/direct3d12/gpu-cuda-in-wsl
2. Nvidia: https://docs.nvidia.com/cuda/wsl-user-guide/index.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d44881df57be7cad6e7d392eeda6f780/" rel="bookmark">
			vue循环单列表的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做任务清单时，是这么想的，有点想做一个类似于滴答清单的效果，但滑动的具体实现不明，所以暂时没有实现还有就是类似于任务清单一开始只显示任务的大概，点击大概后会显示具体的信息。
类似于：
点击后会显示具体的任务
想着应该用v-show绑定一个值来实现下面任务的显示隐藏，但有一个问题，点击后就会进行全部列表的显示
接着想到了两种方法解决，一种是获取对应的dom元素另外一种就是如果每个列表都有自己对应的判断显示的数据就行；
至于第一种暂时没想到解决方法，
第二种的解决方法如下：
在数据库中添加对应的元素，当循环时
&lt;div @click="show(value.show,value.roomid)"&gt;{{value.tasks.title}}&lt;/div&gt; &lt;div class="taskdetails" v-show="value.show"&gt; 判断是否为数据库内的字段
//show方法，改变数据库中show的值 show(isshow,roomid){ let storeshow = isshow isshow = !isshow this.$axios({ method:'post', url:"/repairman/show", data:{ lastshow:storeshow, show:isshow, roomid:roomid } }).then((res)=&gt;{ console.log(res) this.start() }) }, //star方法进行列表的获取 start(){ if((this.repid == '')&amp;&amp;(this.dormid == '')){ alert('请输入工号和楼号') }else{ this.$axios({ method:'get', url:'/getrepdata', params:{ dormid:this.dormid, repid:this.repid } }).then(res=&gt;{ this.task = res.data this.isstart = false // console.log(this.task) }) } }, //数据库操作,修改show属性 app.post('/repairman/show',(req,res)=&gt;{ let form = new formidable.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d44881df57be7cad6e7d392eeda6f780/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6695ea0d64618071a91bdb8657320b6/" rel="bookmark">
			OpenCV库和GDAL库数据类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV库和GDAL库数据类型转换 一、数据类型总结二、OpenCV数据类型定义1.1 生成类型定义1.2 读取类型定义 三、GDAL库数据类型定义 一、数据类型总结 写在前面：由于在编写代码时总是在各种数据类型之间绕来绕去，因此整理了这一表格以供参考，将其分享出来希望能对有与我同样困扰的朋友有所帮助，如有错误请您批评指正。
在第二、三节截取了两库关于数据类型的源码以供参照。
二、OpenCV数据类型定义 1.1 生成类型定义 #define CV_8U 0 #define CV_8S 1 #define CV_16U 2 #define CV_16S 3 #define CV_32S 4 #define CV_32F 5 #define CV_64F 6 #define CV_USRTYPE1 7 #define CV_MAT_DEPTH_MASK (CV_DEPTH_MAX - 1) #define CV_MAT_DEPTH(flags) ((flags) &amp; CV_MAT_DEPTH_MASK) #define CV_MAKETYPE(depth,cn) (CV_MAT_DEPTH(depth) + (((cn)-1) &lt;&lt; CV_CN_SHIFT)) #define CV_MAKE_TYPE CV_MAKETYPE #define CV_8UC1 CV_MAKETYPE(CV_8U,1) #define CV_8UC2 CV_MAKETYPE(CV_8U,2) #define CV_8UC3 CV_MAKETYPE(CV_8U,3) #define CV_8UC4 CV_MAKETYPE(CV_8U,4) #define CV_8UC(n) CV_MAKETYPE(CV_8U,(n)) #define CV_8SC1 CV_MAKETYPE(CV_8S,1) #define CV_8SC2 CV_MAKETYPE(CV_8S,2) #define CV_8SC3 CV_MAKETYPE(CV_8S,3) #define CV_8SC4 CV_MAKETYPE(CV_8S,4) #define CV_8SC(n) CV_MAKETYPE(CV_8S,(n)) #define CV_16UC1 CV_MAKETYPE(CV_16U,1) #define CV_16UC2 CV_MAKETYPE(CV_16U,2) #define CV_16UC3 CV_MAKETYPE(CV_16U,3) #define CV_16UC4 CV_MAKETYPE(CV_16U,4) #define CV_16UC(n) CV_MAKETYPE(CV_16U,(n)) #define CV_16SC1 CV_MAKETYPE(CV_16S,1) #define CV_16SC2 CV_MAKETYPE(CV_16S,2) #define CV_16SC3 CV_MAKETYPE(CV_16S,3) #define CV_16SC4 CV_MAKETYPE(CV_16S,4) #define CV_16SC(n) CV_MAKETYPE(CV_16S,(n)) #define CV_32SC1 CV_MAKETYPE(CV_32S,1) #define CV_32SC2 CV_MAKETYPE(CV_32S,2) #define CV_32SC3 CV_MAKETYPE(CV_32S,3) #define CV_32SC4 CV_MAKETYPE(CV_32S,4) #define CV_32SC(n) CV_MAKETYPE(CV_32S,(n)) #define CV_32FC1 CV_MAKETYPE(CV_32F,1) #define CV_32FC2 CV_MAKETYPE(CV_32F,2) #define CV_32FC3 CV_MAKETYPE(CV_32F,3) #define CV_32FC4 CV_MAKETYPE(CV_32F,4) #define CV_32FC(n) CV_MAKETYPE(CV_32F,(n)) #define CV_64FC1 CV_MAKETYPE(CV_64F,1) #define CV_64FC2 CV_MAKETYPE(CV_64F,2) #define CV_64FC3 CV_MAKETYPE(CV_64F,3) #define CV_64FC4 CV_MAKETYPE(CV_64F,4) #define CV_64FC(n) CV_MAKETYPE(CV_64F,(n)) 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6695ea0d64618071a91bdb8657320b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7375ca8bf5656cf3f5c7130163eee57f/" rel="bookmark">
			vim命令行模式跳至行首/行尾
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 跳转至当前行行首 $ # shift+4命令可以敲出$字母 或者
0 # 数字0 跳至当前行行尾 A # 大写的A 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcd98f1a5e412679137eb3b3501abbbf/" rel="bookmark">
			Vue中demo@0.1.0 serve: `vue-cli-service serve`解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情况: 日常 cnpm run serve,突然报错
npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! demo@0.1.0 serve: `vue-cli-service serve` npm ERR! Exit status 1 npm ERR! Failed at the demo@0.1.0 serve script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm ERR! A complete log of this run can be found in: npm ERR! F:\Nodejs\node_cache\_logs\2021-04-01T12_59_52_414Z-debug.log PS F:\MyVue\program1\day07\demo&gt; npm run dev npm ERR!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcd98f1a5e412679137eb3b3501abbbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b34600fd3fe4b88ab6d49b45ca439f1e/" rel="bookmark">
			(C语言)人名排序，字符串排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、题目描述二、问题解决三、总结 一、题目描述 有n个人名字（n&lt;=20），按字符串从大到小的顺序输出人名。测试数据有多组，每组测试数据单独占一行，第一个数是一个正整数n，表示人名的个数，后跟n个人的名字。已知人名中不包含空格，各人名用空格分隔。人的名字最多不超过60个字符。对于每组测试数据，输出结果单独占一行，按从大到小的顺序输出各人名，人名间用空格分隔。
二、问题解决 代码如下：
#include&lt;stdio.h&gt; #include&lt;string.h&gt; int main(){ int t; char s[20][61]; char ch[61]; while(scanf("%d",&amp;t)!=EOF){ getchar();//吸收多余的换行符 for(int i=0;i&lt;t;i++){ gets(s[i]); } for(int i=0;i&lt;t-1;i++){ for(int j=0;j&lt;t-i-1;j++){ if(strcmp(s[j],s[j+1])&lt;0){//对字符串数组元素进行比较 strcpy(ch, s[j]);//交换两个字符串数组的元素 strcpy(s[j], s[j + 1]); strcpy(s[j + 1],ch); } } } for(int i=0;i&lt;t;i++){ printf("%s",s[i]);//输出 if(i!=t-1){ printf(" "); } } printf("\n"); } } 三、总结 本题的主要思路为：
1.定义一个自由变量来接收每组测试数据的个数
2.定义字符串数组来接收每组的人名
3.通过冒泡排序的方法对人名进行从大到小的排序，其中比较时采用字符串比较函数的方法
4.将排列好的字符数组输出
该题要注意对多余换行符的处理，以及字符串大小比较和互换的方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0626b77d2b5205a283e6edfeb31574d6/" rel="bookmark">
			Unix网络编程常见错误码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EINTR： 4
阻塞的操作被取消阻塞的调用打断。如设置了发送接收超时，就会遇到这种错误。
只能针对阻塞模式的socket，非阻塞模式不会出现这个错误。读，写阻塞的socket时（recv，send），-1返回，错误号为EINTR，说明在数据传输前接收到一个信号（A signal occurred before any data was transmitted.）。出现这种情况，操作应该继续。如果recv的返回值为0，那表明连接已经断开，接收操作应该结束。
对于socket接口(指connect/send/recv/accept..等等，后面不重复，不包括不能设置非阻塞的如select)，在阻塞模式下有可能因为发生信号，返回EINTR错误，由用户做重试或终止。 但是，在非阻塞模式下，是否出现这种错误呢？ 对此，重温了系统调用、信号、socket相关知识，得出结论是：不会出现。 首先， 1.信号的处理是在用户态下进行的，也就是必须等待一个系统调用执行完了才会执行进程的信号函数，所以就有了信号队列保存未执行的信号 2.用户态下被信号中断时，内核会记录中断地址，信号处理完后，如果进程没有退出则重回这个地址继续执行 socket接口是一个系统调用，也就是即使发生了信号也不会中断，必须等socket接口返回了，进程才能处理信号。
也就是，EINTR错误是socket接口主动抛出来的，不是内核抛的。socket接口也可以选择不返回，自己内部重试之类的.. 那阻塞的时候socket接口是怎么处理发生信号的? 举例 socket接口，例如recv接口会做2件事情， 1.检查buffer是否有数据，有则复制清除返回 2.没有数据，则进入睡眠模式，当超时、数据到达、发生错误则唤醒进程处理 socket接口的实现都差不了太多，抽象说 1.资源是否立即可用，有则返回 2.没有，就等... 对于 1.这个时候不管有没信号，也不返回EINTR，只管执行自己的就可以了 2.采用睡眠来等待，发生信号的时候进程会被唤醒，socket接口唤醒后检查有无未处理的信号(signal_pending)会返回EINTR错误。 所以 socket接口并不是被信号中断，只是调用了睡眠，发生信号睡眠会被唤醒通知进程，然后socket接口选择主动退出，这样做可以避免一直阻塞在那里，有退出的机会。非阻塞时不会调用睡眠。 参考：http://willko.iteye.com/blog/1691741
EAGAIN 11：
从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返 回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。
又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。
1、非阻塞socket，send返回值小于要发送的数据数目，可能会返回EAGAIN或者EINTR。
2、非阻塞socket，如send返回EAGAIN错误，表示数据没有完全写入发送缓冲区，但是发送缓冲队列已满，可以做延时后再重试。
3、非阻塞socket，recv时，经常出现Resource temporarily unavailable，返回值-1，errno代码为11(EAGAIN)。表明在非阻塞模式下调用了阻塞操作，在该操作没有完成就返回这个错误，这个错误不会破坏 socket的同步，不用管它，下次循环接着recv就可以（注意：对于普通socket和LT模式的epoll的非阻塞socket是继续recv和send）。对非阻塞socket而言，EAGAIN不是一种错误。在VxWorks和Windows上，EAGAIN的名字叫做EWOULDBLOCK。
在epoll的ET模式下，非阻塞socket，出现EGAIN就是读数据结束了，不能用循环抱住recv，即不能在出现EAGAIN时，马上接着循环recv，因为下一次还会是EAGAIN，这样会陷入死循环。这种情况下出现EAGAIN，表示读或者写已经完成。（已亲测）
4、使用epoll网络模型，单用户的情况下客户端和服务器通信正常。但是在多用户并发的情况下，客户端和服务端通信不正常。此时，客户端能正常的链接，发送数据，但是一直卡在接收数据部分？为什么？
因为在ET模式socket非阻塞的情况下，多个连接同时到达，服务器的TCP就绪队列瞬间积累多个就绪连接，由于是边缘触发模式，epoll只会通知一次，accept只处理一个连接，导致TCP就绪队列中剩下的连接都得不到处理。因此，就出现了上面的问题。
解决办法是用while循环抱住accept调用，处理完TCP就绪队列中的所有连接后再退出循环。如何知道是否处理完就绪队列中的所有连接呢？accept返回-1并且errno设置为EAGAIN就表示所有连接都处理完。
ETIMEOUT：110 1、操作超时。一般设置了发送接收超时，遇到网络繁忙的情况，就会遇到这种错误。 2、服务器做了读数据做了超时限制，读时发生了超时。 3、错误被描述为“connect time out”，即“连接超时”，这种情况一般发生在服务器主机崩溃。此时客户 TCP 将在一定时间内（依具体实现）持续重发数据分节，试图从服务 TCP 获得一个 ACK 分节。当最终放弃尝试后（此时服务器未重新启动），内核将会向客户进程返回 ETIMEDOUT 错误。如果某个中间路由器判定该服务器主机已经不可达，则一般会响应“destination unreachable”－“目的地不可达”的ICMP消息，相应的客户进程返回的错误是 EHOSTUNREACH 或ENETUNREACH。当服务器重新启动后，由于 TCP 状态丢失，之前所有的连接信息也不存在了，此时对于客户端发来请求将回应 RST。如果客户进程对检测服务器主机是否崩溃很有必要，要求即使客户进程不主动发送数据也能检测出来，那么需要使用其它技术，如配置 SO_KEEPALIVE Socket 选项，或实现某些心跳函数。 EPIPE：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0626b77d2b5205a283e6edfeb31574d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17b941697cff2f8692bffeab2efb9dfe/" rel="bookmark">
			Linux如何让程序在后台运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果要运行程序，在命令提示行下输入程序名后回车，程序被执行，然后等待程序运行完成，在程序运行的过程中，也可以用Ctrl+c中止它。
在实际开发中，我们需要让程序在后台运行，没有界面，没有用户输入数据。
如果想让程序在后台运行，有两种方法。
1、加“&amp;”符号 如果想让程序在后台运行，执行程序的时候，命令的最后面加“&amp;”符号。
如：
./book257 &amp; 程序就在后台运行了。
在后台运行的程序，用Ctrl+c无法中断，并且就算终端退出了，程序仍在后台运行。
如果终端退出了，后台运行的程序将由系统托管。
在第一张图中，book257的父进程是64206，第二张图中，book257的父进程是1。
为了不影响接下来的学习，用killall book257指令让book257程序退出。
2、采用fork 另一种方法是采用fork，主程序执行fork，生成一个子进程，然后父进程退出，留下子进程继续运行，子进程将由系统托管。
在book257的main函数后增加以下代码：
if (fork()&gt;0) return 0; 重新编译后执行book257pp，运行效果如下：
上图中，44850是fork后的子进程，它的父进程号是1，是系统进程（亲爹没了，天地日月为父）。
3、如何让中止后台运行中程序 问题来了，程序在后台运行了，离开了终端控制，用Ctrl+c上也无法中止，那怎么让它停下来呢？暂时用一个笨方法，杀了它。
杀程序有两个方法：
1）killall 程序名
killall book250 执行效果
2）先用“ps -ef|grep 程序名”找到程序的进程编号，然后用“kill 进程编号”。
执行效果
4、参考文献 1、https://blog.csdn.net/wucz122140729/article/details/105112944
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd02bb805d9183ac39342a27bc4f2977/" rel="bookmark">
			移动安全：多方法实现Android导入系统证书并用Burp抓包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0x0需求1x0 环境准备2x0 导入系统证书2x1 方法一：Android访问代理2x2 方法二：adb推入证书 3x0 抓包测试总结 0x0需求 一般来说在Android7以上的系统版本，系统会严格的区分系统证书和用户证书，而一些安全性较好的apk会禁止在Android7以下的系统版本运行，这就对安全测试的同学们产生了一定障碍。本文会图文介绍在Android7以上导入系统证书实现抓包 以下是本篇文章正文内容
1x0 环境准备 1）已root的Android设备
2）adb
3）burpsuite
2x0 导入系统证书 将Burp证书设置为Android手机的系统证书一般来说中有两种方法，但是这里需要注意，第一种方法适合Android模拟器用户，而第二种adb方法比较通用，推荐用第二种方法
2x1 方法一：Android访问代理 1）Android挂Burp代理，访问http://burp下载证书，此时，Burp的证书会下载到sdcard/Download/目录中，这个目录是手机浏览器的默认下载目录。
2）使用adb将下载下来的证书push到存有系统证书的目录,详细命令如下：
adb shell su mv /sdcard/Download/&lt;cert&gt;.0 /system/etc/security/cacerts/ cd /system/etc/security/cacerts/ chmod 644 &lt;cert&gt;.0 chgrp root &lt;cert&gt;.0 2x2 方法二：adb推入证书 1）打开Proxy下的Options标签行，按照如下所示导出证书
2）更改证书格式：
使用openssl的x509指令进行cer证书转pem证书 和 用md5方式显示pem证书的hash值
证书转换 openssl x509 -inform DER -in cert.cer -out cacert.pem 进行MD5的hash显示 openssl x509 -inform PEM -subject_hash_old -in cacert.pem	将pem证书重命名
使用上面复制的值（类似于9a5ba575）对pem证书进行重命名，为9a5ba575.0 (其中0为序号，用于区分hash重复的证书) 3）把证书push到用户目录中去
（1）User(root后)版本需要先把证书导入到用户目录中，再进入超级管理用户，把这个证书导入到系统证书目录。
输入如下命令
adb shell su #挂载system分区,可写一般情况/system分区是只读的，需要挂载为读写。 mount -o rw,remount /system mv /sdcard/Download/&lt;cert&gt;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd02bb805d9183ac39342a27bc4f2977/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdf8c7afc0e3a60b26d85a09c4298189/" rel="bookmark">
			使用vant中tab组件报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先他确实能够显示我想实现的效果，其作用是获取到所有的宿舍列表但看着报错就很难受
所以百度翻译了一下报错原因
其原因是我数据库存放的roomid是int类型的而要使用该插件这里必须是字符串类型的，不然就会出现以上错误
通过进行字符串的强制转换就能够解决相应的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18660e3a413ceb8605620711dd885e6a/" rel="bookmark">
			Spring MVC框架解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Spring MVC依赖的包
spring-context
spring-aspects
spring-jdbc
spring-test
spring-web
spring-webmvc
在pom.xml文件中添加依赖
&lt;properties&gt; &lt;spring.version&gt;5.2.13.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 二、在resource中创建spring-servlet.xml文件
添加MVC命名空间
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package="com.qfedu"/&gt; &lt;!--声明MVC使用注解驱动--&gt; &lt;mvc:annotation-driven/&gt; &lt;/beans&gt; 三、在web.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18660e3a413ceb8605620711dd885e6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/163f660bd861b91a0f7b26ad82a15e73/" rel="bookmark">
			Matlab双目标定与python-opencv配置标定参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matlab双目标定与python-opencv配置标定参数 1. matlab工具箱进行双目标定2. 将matlab标定的结果配置到opencv代码中 1. matlab工具箱进行双目标定 最近开始学习双目视觉，网上看到了很多大佬的博客与代码。为了以后学习方便，特此以学习笔记的方式记下，如有侵权请联系。下面正式开始：
打开matlab2016，点击APP，如图：选择里面的Stereo Camera Calibrator选项
这里可以先导入图片，也可以先勾选红色的三个，看个人习惯
依次选择左右相机图片路径，然后根据自己标定板一格棋盘的长度更改25这个值
点击确定，matlab会选择图片里可以用来标定的图片对，抛弃无用的图片对。这里要注意检查一下剩下的图片对是不是合格，怎么检查呢，就是看看x，y，（0，0）是不是对应的，如果不对应就移除这一对图片最后点击标定按钮，标定结束后可以根据需要删除误差值较大的图片对，满足误差要求后导出参数即可。
标定结果如下图所示，我们需要的是里面的左右相机的内参以及右相机相对于左相机的旋转矩阵和平移矩阵。
2. 将matlab标定的结果配置到opencv代码中 先看相机参数配置代码：
import cv2 import numpy as np left_camera_matrix = np.array([[11400.3867063356, -708.226944360597, 3133.52343114698], [0, 13324.7161808224, -10327.0186882030], [0., 0., 1.]]) left_distortion = np.array([[-0.310893555601236, 0.0890628201287691, -0.0140441135262092, 0.0123461575310137, 0.00252759610639547]]) right_camera_matrix = np.array([[8028.19082160345, 693.566448971348, 6053.49742648582], [0, 7693.28688589561, -8280.86166418103], [0, 0, 1.0000]]) right_distortion = np.array([[-0.173533544692552, 0.0151082474541149, -0.000650491166259009, 0.0343271672455320, -0.0208062597406380]]) R = np.matrix([ [0.974689632070511, 0.0643464338449411, 0.214101979406287], [-0.0393006325473173, 0.992086337617053, -0.119248308142979], [-0.220080851996788, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/163f660bd861b91a0f7b26ad82a15e73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69f25ec6a0a75317b8d97fa701f342a1/" rel="bookmark">
			CentOS7学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. VM下安装CentOS 在Vmware中安装CentOS。
VM三种网络连接模式 桥接模式 虚拟系统可以和外部系统通讯，但是容易造成IP冲突。
NAT模式 网络地址转换模式，虚拟系统可以和外部系统通讯，而且不造成IP冲突。
仅主机模式 独立的系统，不和外部发生联系。
VM常用操作 拍摄快照和克隆。
安装vmtools 安装vmtools，能让我们在windows下更好的管理虚拟机。
安装步骤： 进入CentOS。 点击vm菜单的-&gt;install vmware tools。 centos会出现一个vm安装包，xx.tar.gz。 拷贝到/opt。 使用解压命令tar，得到一个安装文件。 cd/opt [进入到opt目录]。 tar -zxvf xx.tar.gz。 进入vm解压的目录，/opt目录下cd vmware... 安装 ./vmware-install.pl 全部使用默认设置即可，就可以安装成功。 注意：安装vmtools，需要有gcc。 设置共享文件夹 步骤： 菜单 -&gt; vm -&gt; setting -&gt; 选项 -&gt; 共享文件 共享文件夹在CentOS的/mnt/hgfs/下。
二. CentOS文件系统 在Linux世界里，一切皆文件。
linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是跟目录“/”，然后在此目录下再创建其他的目录。
深刻理解linux树状文件目录是非常重要的。
具体目录结构 /bin [常用] （/usr/bin、/usr/local/bin） 是Binary的缩写，这个目录存放着最经常使用的命令。 /sbin [常用] （/usr/sbin、/usr/local/sbin） s就是super user的意思，这里存放的是系统管理员使用的系统管理程序。 /home [常用] 存放普通用户的主目录，在Linux中每个用户都有自己的目录，一般该目录名是以用户的账号命名。 /root [常用] 该目录为系统管理员，也称作超级权限者的主目录。 /lib [常用] 系统开机所需要的最基本的动态连接共享库。其作用类似于Windows里的DLL文件。几乎所有应用程序都需要用到这些共享库。 /lost+found 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /etc [常用] 所有系统管理所需要的配置文件和子目录。 /usr [常用] 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program file文件。 /boot [常用] 存放的是启动linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /proc 这个目录是一个虚拟目录，它是系统内存的映射，访问这个目录来获取系统信息。 /srv service缩写，该目录存放一些服务启动之后需要提取的数据。 /sys 这是linux2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69f25ec6a0a75317b8d97fa701f342a1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/319/">«</a>
	<span class="pagination__item pagination__item--current">320/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/321/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>