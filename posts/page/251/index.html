<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17fc4d55763e4d2a0abcee4fdfd75d98/" rel="bookmark">
			【解决导入的他人项目”JDK“javaSE-1.8“ is missing“”File was loaded in the wrong encoding: ‘UTF-8‘”问题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK"javaSE-1.8" is missing
解决方式：点一下右侧的configure,换成自己的JDK
File was loaded in the wrong encoding: 'UTF-8'
解决方式：
错误分析：当我们打开一个文件，可是中文出现乱码，这是可能因为我们文件使用UTF-8进行编辑，而Windows默认使用GBK编码格式，所以导致打开文件时出现乱码
解决方法一：在打开的文本中解决（治标不治本）。点击图中右下角的UTF-8，选择GBK，在弹出的窗口中选择Reload（重载）[http://t.csdn.cn/P4VFn]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0a4364697374f5a4afdf64c702b6da6/" rel="bookmark">
			梯度下降、ISTA和FISTA算法收敛速率推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本周主要是进行优化课程的复习，然后对梯度下降、ISTA和FISTA算法的收敛速率证明进行了总结。
一、梯度下降收敛速率证明： 二、 ISTA的收敛速率（近端梯度下降法的收敛速率） 三、FISTA的收敛速率（加速近端梯度下降法收敛速率） 最近天气越来越冷了，有点不太适应，下周就要考试了，希望能顺利通过。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3de58a3d3a39908b9a76b95a976b3c7/" rel="bookmark">
			图神经网络GNN在推荐系统的应用：综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：
论文1：
《Graph Neural Networks in Recommender Systems: A Survey》
https://arxiv.org/pdf/2011.02260.pdf论文2：
《Graph Neural Networks for Recommender Systems:
Challenges, Methods, and Directions》
https://arxiv.org/pdf/2109.12843.pdf 1 介绍 1.1 推荐系统发展的三个阶段 回顾一下推荐系统的历史，一般可以分为三个阶段，浅层模型[74,125,126]，神经模型[26,48,56]和基于gnn的模型[55,153,188]。
最早的推荐模型通过直接计算交互的相似度提出了基于模型的CF方法，如矩阵分解(MF)[74]或分解机[125]，将推荐作为一个表示学习问题来处理。然而，这些方法面临着复杂的用户行为或数据输入等关键挑战。
为了解决这一问题，提出了基于神经网络的模型[26,48,56]。例如，神经协同过滤(NCF)将MF的内积扩展到多层感知器(MLP)，以提高其能力。同样，深度分解机(DeepFM)[48]将浅层模型分解机(FM)[125]与MLP相结合。然而，由于这些方法的预测和训练范式忽略了观测数据中的高阶结构信息，因此仍然存在很大的局限性。例如，NCF的优化目标是预测用户-物品交互，训练样本包括观察到的积极用户-物品交互和未观察到的消极用户-物品交互。这意味着在为特定用户更新参数时，只涉及他/她与之交互的项目。
最近，图神经网络的发展为解决推荐系统中的上述问题提供了基础和机会。其中，图神经网络采用嵌入传播，迭代聚合邻域嵌入。通过叠加传播层，每个节点可以访问高阶邻居信息，而不是像传统方法那样只访问一阶邻居信息。
基于gnn的推荐算法具有处理结构化数据和挖掘结构化信息的优势，已成为推荐系统中最先进的方法。
1.2 GNN在RS应用上面临的问题 GNN在推荐系统应用面临以下问题：
首先，将推荐系统的数据输入构造成图，用节点表示元素，用边表示关系。对于具体的任务，需要自适应设计图神经网络中的组件，包括如何传播和聚合，现有的作品已经探索了各种不同的选择，不同的优点和缺点。基于GNN模型的优化，包括优化目标，损失函数。数据采样等等。RS对计算有较高的要求，而GNN的嵌入传播涉及到大量的计算，如何设计高效的GNN 2 四个角度介绍推荐系统 在本节中，我们将从四个角度介绍推荐系统的背景:阶段、场景、目标和应用
2.1 三大阶段（召-排-重） 如今的推荐系统通常由这三部分组成，分别是，召回阶段，精排和重拍。流程如下：
1、 召回
第一阶段从非常大的项目池(百万级甚至十亿级)中生成数百个候选项目，这大大降低了规模。
由于该阶段输入的数据量大，且在线服务的延迟限制严格，因此无法采用非常深的神经网络等复杂算法，而是采用简单模型和策略。
也就是说，这一阶段的核心任务是高效地检索潜在的相关条目，并获得用户兴趣的粗粒度建模一般召回阶段通常包含多个匹配渠道和多个模型，如嵌入匹配、地理匹配、人气匹配、社交匹配等。也就是多路召回。
2 排序
召回阶段结束后，将来自不同通道的多个候选项源合并成一个列表，然后使用单一的排序模型对候选项进行评分。具体来说，排名模型根据分数对这些项目进行排名，并选择排名靠前的几十个项目。
由于这一阶段的输入条目量相对较小，系统可以采用更加复杂的算法来达到更高的推荐精度[69,89,133]。由于涉及到许多特征，这一阶段的关键挑战是设计合适的模型来捕获复杂的特征交互。
3、重排
在排序阶段更多追求的是相关性（精确度），可能无法满足其他重要的要求，如新鲜度、多样性、公平性等[120]，因此需要重新排序阶段。
它通常删除某些项或更改列表的顺序，以满足附加条件和业务需求。
2.2 场景 下面，我们将详细介绍推荐系统的不同场景，包括社交推荐、序列推荐、会话推荐、捆绑推荐、跨域推荐和多行为推荐。
1 社交推荐 在过去的几年里，社交平台极大地改变了用户的日常生活。通过与其他用户互动的能力，个人行为受到个人和社会因素的驱动。
具体来说，用户的行为可能会受到朋友的行为或想法的影响，这被称为社会影响[28]。
例如，微信视频平台的用户可能会因为微信好友的喜欢行为而喜欢某些视频。同时，社会同质性是许多社交平台上的另一种流行现象，即人们倾向于与自己偏好相似的人建立社会关系[107]。以社交电子商务为例，来自一个共同家庭的用户可能有相似的产品偏好，如食物、衣服、日用品等。
因此，往往将社会关系整合到推荐系统中，以提高最终绩效，这就是所谓的社交推荐。
2 序列推荐 随着时间的推移，用户会产生大量的交互行为。序列推荐方法从这些行为序列中提取信息，预测用户的下一个交互行为。在序列推荐中，用户历史行为在兴趣建模中起着重要作用。
传统推荐如协作过滤[56]，都是以每个用户行为为样本来训练模型。它们直接在单个项目上建模用户的偏好，但序列推荐基于用户的历史行为序列来学习时间戳感知的顺序模式，从而推荐用户可能感兴趣的下一个项目。
在序列推荐中，有两个主要挑战。
首先，对于每个样本，即每个序列，需要从序列中提取用户的兴趣来预测下一个条目。特别是当序列长度增加时，同时建模用户的短期、长期和动态兴趣是非常具有挑战性的。其次，除了在序列内建模之外，由于物品可能出现在多个序列中，或者用户拥有多个序列，因此需要捕获不同序列之间的协作信号，以便更好地进行表示学习。 3 会话推荐（session rec） 在许多现实场景中，如YouTube和Tiktok，由于存储资源有限，没有必要长时间跟踪用户id的行为。换句话说，用户配置文件和长期的历史交互是不可用的，只提供来自匿名用户的短会话数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3de58a3d3a39908b9a76b95a976b3c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7654b1ad67b1cecfd97d840d9afed04e/" rel="bookmark">
			Mac如何有线上网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于MacBook Pro上没有网线接口，首先要准备一个转接头 具体步骤如下
打开系统偏好设置-网络
点击左下角加号，创建一个新服务。
接口选择PPPoE，服务名称可以任取。完成后点击创建 4. 输入账户名称和密码后点击连接即可
另外，如果插上网线之后，USB这个地方显示未连接，其实可能不是自己电脑的问题，有没有一种可能，是墙上的网线接口坏了！
没错我就是这样，捣鼓了一整天，又是安装什么外置网卡驱动啦什么的，统统都不行。于是乎我把墙上的网线接口上的螺丝拧开，终于发现，原来里面网线断了。。。
解决方法就是去校园一网通办报修，然后给我送来了一个交换机，用它连在室友那边墙上的网线接口，我和室友都用网线连交换机上就可以了，真是太不容易了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab1e19a5602d78b632468a3bae2ed06b/" rel="bookmark">
			什么是stl? 如何使用stl?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是STL？ STL(Standard Template Library)是C++的标准模板类库。STL是一个功能强大的基于模板的容器库，通过直接使用这些现成的标准化组件可以大大提高算法设计的效率和可靠性。
STL主要由container(容器)、algorithm(算法)和iterator(迭代器)三大部分构成：
1.容器: 用于存放数据对象（元素） 2.算法: 用于操作容器中的数据对象 3.迭代器: 用于访问容器中的数据对象 容器、算法和迭代器成为STL的三大件，它们之间的关系如下图所示:
1.什么是容器？ 一个容器就是一种数据结构，例如链表、栈、队列等等。这些在STL中都已经实现好了，在算法设计过程中我们可以直接使用它们。
STL容器部分主要由头文件&lt;vector、&lt;string、&lt;list、&lt;set等组成。下面是一些常用的头文件以及说明：
注：为了避免名字冲突，我么在使用STL时一般要加如下实例的代码：
#include&lt;iostream&gt; #include&lt;vector&gt; //这一行代码一般这样引入 using namespace std; int main(){	return 0;} 2.什么是STL算法？ STL算法一般用来操作容器中数据的模板函数。例如：sort()对一个vector中的数据进行排序。
2.STL算法部分主要由头文件&lt;algorithm，numeric、functional。最常用的一般就是algorithm这个头文件，其中有大量的模板函数组成。
实例：对整形数组的排序
#include&lt;iostream&gt; #include&lt;algorithm&gt; //定义新的命名空间 using namespace std; int main() { int a[] = {5, 2, 1, 3, 4, 6}; sort(a, a+6);	//第一个参数: a是数组的名字(实际上是一个指针） ， //第二个参数: 是数组的名字加要排序的长度 (根据需要 可以选择对数组中的一部分进行排序 ) for (int i = 0; i &lt; 6; i++) cout &lt;&lt; a[i] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab1e19a5602d78b632468a3bae2ed06b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7108c4e035854aa9114d13565f0b9c8b/" rel="bookmark">
			web前端-纯前端音频剪辑，vue音频编辑组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文包含内容概述：
整理总结的音频相关资料音频相关jsapi说明及示例vue编写的组件及git项目地址 在线预览： http://123.57.178.145:5007/audio_edit/index.html
目录 在线预览： 标题音频编码、格式（部分）PCM编码APE格式MP3编码、OGG编码MPC编码AAC编码WMA格式RA格式WAV格式 剪辑原理（基础方式）音频数据最佳频率44.1kHz加减速裁切拼接合并 JS相关API代码示例获取audioContext获取音频arraybufferarraybuffer（mp3、wav、mp4、ogg等浏览器可识别格式） 转码成 audiobuffer（PCM编码），以便操作数据创建新的音频createBuffer合并音频（同时播放两个音频），示例创建wav音频文件，并填入数据（audiobuffer =&gt; wav）audio加载事件audio属性及方法input添加音频生成audio，并读取音频数据 使用到的编码库mp3 =&gt; libmp3lame =&gt;.mp3ogg =&gt; libvorbis =&gt;.oggaac =&gt; libfdk_aac =&gt;.mp4wma =&gt; wmav1 =&gt;.asf 思路组件git地址声明 标题音频编码、格式（部分） PCM编码 无损编码，模拟波形，占用空间大
APE格式 无损压缩
MP3编码、OGG编码 有损压缩，边读边放
MPC编码 更小的体积更好的音质
AAC编码 又称MPEG-4 AAC，即m4a，
最大能容纳48通道的音轨
高压缩比的音频压缩算法，AAC通常压缩比为18:1
WMA格式 用于网络播放。
可以限制播放时间和播放次数甚至于播放的机器等等。
支持流技术，即边读边放。
RA格式 用于网络播放。
可以根据听众的带宽来控制自己的码率，在保证流畅的前提下尽可能提高音质。
支持边读边放，也同样支持使用特殊协议来隐匿文件的真实网络地址，从而实现只在线播放而不提供下载的欣赏方式。
WAV格式 所有的WAV都有一个文件头，这个文件头包含了音频流的编码参数。
常见的都是PCM编码。
但MP3编码也可以运用在WAV中。
剪辑原理（基础方式） 音频数据 采样率：每秒的采样数量。
采样大小：每次采样的采样精度。
通道数：pcm双声道数据规则为左、右声道轮流记录一个采样。
最佳频率44.1kHz 人耳能够感觉到的最高频率为20kHz，
使得离散信号恢复成连续模拟信号不失真至少要让采样频率为 原始信号的2倍
因此要满足人耳的听觉要求，则需要每秒进行40k次采样
加减速 对音频数据以更高的采样率播放，即可实现加速。减速同理。
裁切 根据采样率计算时间对应数据，截取音频数据
拼接 多个音频，转为相同采样率，拼接音频数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7108c4e035854aa9114d13565f0b9c8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cd7650244ac828d8783c6492112ac6d/" rel="bookmark">
			三种方法 计算 文本宽度 及 文本行数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.已有元素，获取元素内文本行数
//计算元素内的行数 var line=parseFloat(el.css("height"))/parseFloat(el.css("line-height")); 2.canvas计算文本宽度、行数
注：不同字体、不同尺寸 的文字占用宽度不同
//txt:文字 font：字体 width：一行最大宽度 //计算宽度 function getwidth(txt,font){ var canvas = document.createElement('canvas'); var ctx=canvas.getContext("2d"); ctx.font=font; return ctx.measureText(txt).width } //计算行数 function textline(txt,font,width){ let txts=txt.split("\n"); let line=0; for(var key in txts){ line += Math.ceil(this.getwidth(txts[key],font)/width); } return line; } 3.粗略计算字符宽度，行数计算同上
正则匹配中文占1个字符宽度，其他（如：英文）占0.5个字符宽度
//text:文字 , font_size：字体大小number , letter_space：字间距number function getwidth(text,font_size,letter_space){ let cn = text.match(/[\u2E80-\uFE4F\u3002\uff1b\uff0c\uff1a\u201c\u201d\uff08\uff09\u3001\uff1f\u300a\u300b]/ig); let cn_count = cn?cn.length:0 let other_count = text.length - cn_count; return (cn_count + other_count / 2)*font_size + (letter_space||0)*text.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cd7650244ac828d8783c6492112ac6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29030ccf6c8fb5a560887a551482dc43/" rel="bookmark">
			【数据结构】循环链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.概念2.循环链表的头文件与函数声明3.函数实现3.1 购买节点3.2 初始化函数（重点）3.3 判空函数3.4 获取有效数据个数3.5 头插函数3.6尾插（重点）3.7 按位置插入3.8 头删3.9 尾删（重点）3.10 按位置删除节点3.11 查找3.12 按值删除3.13 销毁3.13.1 销毁13.13.2 销毁2 4.循环链表的源文件与函数实现 1.概念 循环链表：和单链表唯一的区别：尾节点保留着头节点的地址
循环链表的特点：
1. 尾节点可以找到头节点
2. 头节点不能找到尾节点
3. 如果没有有效数据节点（空链），头节点指向自身
注意，循环链表，for循环去遍历，判断表达式不再是p-&gt;next!=NULL,而是p-&gt;next!=plist
2.循环链表的头文件与函数声明 #pragma once typedef int ELEM_TYPE; //循环链表有效数据节点结构体设计： typedef struct CNode { ELEM_TYPE data;//数据域 struct CNode* next;//指针域 }CNode, *PCNode; //有关循环链表的操作函数： //初始化 void Init_clist(struct CNode* plist); //购买节点 struct CNode* BugNode(ELEM_TYPE val); //头插 bool Insert_head(PCNode plist, ELEM_TYPE val); //尾插 bool Insert_tail(PCNode plist, ELEM_TYPE val); //按位置插 pos=0 头插 bool Insert_pos(PCNode plist, int pos, ELEM_TYPE val); //头删 bool Del_head(PCNode plist); //尾删 bool Del_tail(PCNode plist); //按位置删 pos=0 头删 bool Del_pos(PCNode plist, int pos); //按值删除 bool Del_val(PCNode plist, ELEM_TYPE val); //查找 struct CNode* Search(PCNode plist, ELEM_TYPE val); //判空 bool Is_Empty(PCNode plist); //判满 循环链表也不需要判满 //获取有效元素个数 int Get_length(PCNode plist); //清空 void Clear(PCNode plist); //销毁1 void Destroy(PCNode plist); //销毁2 void Destroy2(PCNode plist); //打印 void Show(PCNode plist); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29030ccf6c8fb5a560887a551482dc43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48219d8c49a5ba504cdd06accd5344c7/" rel="bookmark">
			小程序 uniapp使用echarts报错 t.addEventListener 未定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改如下代码:示例为压缩版echarts.min.js
1.增加 var isDomLevel2 = (typeof window !== ‘undefined’) &amp;&amp; !!window.addEventListener;
2.修改函数 Le Pe
3.修改函数gx
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cbb0d4c368e8b533b4d451d2c513ef9/" rel="bookmark">
			前端js数据导出excel，并修改样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端js数据导出excel，并修改样式
使用方法参考原文：https://blog.csdn.net/weixin_43965143/article/details/106572755
作出部分修改：该修改仅满足本人当前需求，并不完善，仅供参考
1.【修改】 自动计算列宽度 原本没有title时，header行不参与计算
2.【修改】 改了一些头部样式
3.【增加】 数字下标转excel列下标函数 number_to_excel
4.【增加】 设置修改列样式的参数 styles
import Export2Excel from "@/assets/js/Export2Excel.js" let header = ['标签','姓名','性别','出生年月日']; let filterVal = ["tag", "childName", "gender", "birthday"]; let list = [{ tag:'示例班', childName:'示例', gender:'男', birthday:'2016/10/12', }]; let data = Export2Excel.formatJson(filterVal, list); let styles = {};//按列改样式 let length_str = Export2Excel.number_to_excel(header.length-1) styles[length_str]={ alignment: { horizontal: "left", }, font:{ color: { rgb: "DE3151" }, } } let merges = ["A2:A64"]; Export2Excel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cbb0d4c368e8b533b4d451d2c513ef9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f593d2c80ff1c4eecee94dfbf953ece/" rel="bookmark">
			记一次不同Ner实体命名模型实际生产效果对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、数据准备 训练数据：医疗影像经过OCR识别后，得到的纯文本数据，且已经过专业标准人员标注。
测试数据：与训练数据同源，8:2的比例切分后得到。
验证数据：经过本人逐条核验，共150条，非连续实体有50条，嵌套和普通实体有100条。
2、模型准备 2.1标注方法：bio ，模型：bert，框架：tensorflow 基于BERT预训练的中文命名实体识别TensorFlow实现
2.2标注方法：globalpointor（多头标注） ，模型：bert，框架：keras 详细可参见：
GlobalPointer：用统一的方式处理嵌套和非嵌套NER
2.3标注方法：堆栈 ，模型bert， 框架：tensorflow [论文笔记]一种高效基于转移的不连续命名实体识别模型 2.4标注方法：positon, 模型W2NER 框架：PYTORCH
Unified Named Entity Recognition as Word-Word Relation Classification
3、测试结果 校验指标：预测实体集合为A,真实实体集合为B
校验准确率：A∩B / B (即召回率：预测正确的实体个数占实际实体个数的比例)
三种NER方法的实测效果 150条混合数据100条嵌套普通数据50条非连续真实场景（20%非连续、80%嵌套普通）bert0.663 0.8540.370.7572globalpointor0.710.881 0.4470.7942W2NER0.7920.9390.6200.8752 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b29854906fc18c97b8f627ce6344a88/" rel="bookmark">
			FMETP Steam v2 使用方法（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FMETP Steam v2 使用方法（二） 前言GameViewEncoder属性桌面传输 前言 FMETP Steam v2 使用方法（一）的链接
https://blog.csdn.net/weixin_42746271/article/details/123657317
GameViewEncoder属性 直接开发使用的比较常用的部分属性：
Capture Mode
分为四个模式
RenderCam：使用目标 RenderCam 作为源输入
MainCam：使用您的主摄像头作为源输入
FullScreen：捕获您的最终渲染，包括 UI 画布
Desktop：捕获您的 Windows 桌面
如果画面会产生卡顿的话可以选择调整以下几个选项
Quality：质量选项（10-100）
StreamFPS：传输流的目标FPS（）0-60）
FastEncodeMode： 启用快速编码器以获得更好的性能
AsyncEncodeMode：不阻塞主线程的多线程解决方案
GZipMode：使用 GZip 方法压缩数据
桌面传输 Capture Mode 选择Desktop
Resolution 这个地方可以选择分辨率 非常方便
注意Flip X位置要选择√ 否则画面会产生反转
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d787e8687548ebeced32906e325ecac/" rel="bookmark">
			聊聊spring事务失效的12种场景，太坑了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 对于从事java开发工作的同学来说，spring的事务肯定再熟悉不过了。
在某些业务场景下，如果一个请求中，需要同时写入多张表的数据。为了保证操作的原子性（要么同时成功，要么同时失败），避免数据不一致的情况，我们一般都会用到spring事务。
确实，spring事务用起来贼爽，就用一个简单的注解：@Transactional，就能轻松搞定事务。我猜大部分小伙伴也是这样用的，而且一直用一直爽。
但如果你使用不当，它也会坑你于无形。
今天我们就一起聊聊，事务失效的一些场景，说不定你已经中招了。不信，让我们一起看看。
最近无意间获得一份BAT大厂大佬写的刷题笔记，一下子打通了我的任督二脉，越来越觉得算法没有想象中那么难了。
BAT大佬写的刷题笔记，让我offer拿到手软
一 事务不生效 1.访问权限问题 众所周知，java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。
但如果我们在开发过程中，把有某些事务方法，定义了错误的访问权限，就会导致事务功能出问题，例如：
@Service public class UserService { @Transactional private void add(UserModel userModel) { saveData(userModel); updateData(userModel); } } 我们可以看到add方法的访问权限被定义成了private，这样会导致事务失效，spring要求被代理方法必须是public的。
说白了，在AbstractFallbackTransactionAttributeSource类的computeTransactionAttribute方法中有个判断，如果目标方法不是public，则TransactionAttribute返回null，即不支持事务。
protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) { // Don't allow no-public methods as required. if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) { return null; } // The method may be on an interface, but we need attributes from the target class. // If the target class is null, the method will be unchanged.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d787e8687548ebeced32906e325ecac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a02790aa6dc983f23373180dc633e1c/" rel="bookmark">
			客户SOP有什么作用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		客户SOP功能，将流程标准化，使员工有一条明确清晰的工作路径，帮助员工更好地触达客户，提升工作效率。
前言 工厂之所以日产量多，是因为工厂已经形成一套标准的流水线，即便是新上岗的员工也能够按照流程完成工作任务，也就是说流程标准化既节省时间又能提高工作效率，对于企业来说很有必要，因此企业纷纷采用CRM系统优化业务流程。很多使用企客宝SCRM的用户对于客户SOP这一功能比较困惑，其实客户SOP就相当于一条流水线，帮助员工更好地触达客户，在特定的时间做特定的工作内容，将工作有序进行。下面我们一起来了解一下客户SOP的作用。
一、如何理解客户SOP？ SOP（Standard Operating Procedure），从字面上理解就是标准作业程序的意思，即将某一事件的标准操作步骤和要求以统一的格式描述出来，更注重流程中某一关键控制点，可执行性强。
对于企业而言，客户是发展动力，企业销售人员跟踪客户的最终目的都是要完成客户的转化，而不同销售水平的销售人员对于转化客户的方法也是不同的，同样的时间内转化客户的效率也参差不齐。如果企业每个销售人员都可以按照业绩第一的销售人员的方法完成客户的转化，那么企业的工作效率会大幅提高。客户SOP的意义就在此，将客户转化流程标准化，按照步骤推进跟踪客户的进程，进而提升工作效率。
试想一下，企业入职一位新成员，面对新的工作比较陌生，仅仅靠老人带，给他讲工作流程和工作内容，也不会完全吸收。而按照企业的客户SOP完成工作，就相当于有了一条明确清晰的工作路径，不至于面对一堆工作资料时杂乱无章、毫无头绪，新员工也能快速上手工作，工作效率自然也会提高。
二、客户SOP的作用 1.对工作流程更加清晰，提升效率 很多员工对于本职工作的完成度不是很好的原因之一就是工作流程混乱、效率不高，明明有很多工作内容需要去完成，但是在办公桌前却总是一头雾水、一筹莫展，常常干了东边儿忘了西边儿，工作效率自然很低。
而客户SOP的作用就在此，帮助工作人员解决工作流程和目标不清晰的问题，从整体上提升效率。客户SOP帮助企业制定一个工作标准，员工按照工作标准展开工作即可，比如客户状态与触达动作相匹配，“激活客户-兴趣-孵化-转化成交”这个工作流程的每一步员工该与客户发送什么样的触达内容，都可以通过客户SOP进行设置。
2.与新客户建立情感 不论是做销售还是运营的工作人员，对于获取客户信任都一定感同身受过。当新添加一个客户时，客户并不会马上信任你，信任需要经过一段时间的相处慢慢建立，相处过程中就需要给这些新客户适时推送消息来建立情感，但是切记不可以盲目发送消息，否则一不小心客户会认为被骚扰到而屏敝了你，那就失去了开发客户的机会。
客户SOP，可以设置推送时间和推送内容，还可以添加文章或文件，能够更好地触达客户。比如：设置好第一天、第二天、第三天等要发送的内容和时间，CRM系统会定时提醒员工进行消息的推送，在不打扰客户的情况下更好地与客户建立情感。
3.及时进行客户回访 客户不是成交以后就万事大吉了，客户需要定期回访，这样才能更好地维护与客户之间的关系，提高复购率。但是每个客户添加的时间不同，成交的时间也不同，员工无法记住每个客户的回访时间，甚至会遗忘对某些客户的回访工作。
这时候使用客户SOP就可以解决忘记客户回访这一问题，比如：要对成交后的客户每两周进行一次回访，可以创建一个名称为“回访客户”的SOP，将时间设置为15天后和30天后，并将推送内容也提前编辑好，为成交的客户设置SOP，那么到时间后系统就会提醒员工执行任务。
三、如何创建客户SOP？ 1.创建客户SOP 企业管理员登录CRM系统后，进入“系统设置”页面，在“业务相关”一栏找到“客户SOP”，点击“创建客户SOP”，企业可以对名称、适用员工、适用部门、说明、客户阶段进行相关设置。
2.为客户阶段添加新的推送内容 当创建好客户SOP后，企业管理员可以为客户的不同阶段添加新的推送内容，操作也很简单。点击创建好的客户SOP名称，进入页面后选择要设置推送内容的客户阶段，点击“添加新的推送内容”，可以设置推送时间和推送内容，并且支持添加分享文章或文件。
设置好后，将会在页面中显示，并且系统会按照设定好的时间提醒员工执行相关的工作任务。
3.为客户设置SOP 当设置好推送内容后，就可以给客户设置SOP了。员工可以将客户添加到对应的SOP阶段内，或者在客户列表为其设置SOP，这样员工会按时接到企客宝的推送提醒。
总结 任何一家企业的业务流程里，可能包含众多琐碎的工作内容，那么借助CRM的客户SOP创建几个SOP，优化工作流程，更多地把握商机，进而帮助企业提升工作效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33bb8531da0bf89fb9edabaf27134363/" rel="bookmark">
			react源码学习-架构篇-commit阶段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		commit阶段 在rootFiber.firstEffect上保存了一条需要执行副作用的Fiber节点的单向链表effectList，这些Fiber节点的updateQueue中保存了变化的props。
这些副作用对应的dom操作在commit阶段执行，除此之外，一些生命周期钩子如componentDidXXX，useEffect需要在commit阶段执行。
commie阶段开始于commitRoot函数
commit阶段的工作主要分为三个部分：
before mutation阶段（执行DOM操作前） mutation阶段（执行DOM操作） layout阶段（执行DOM操作后） 在beform mutation阶段之前和layout阶段之后，有一些额外操作，如useEffect的触发，优先级相关的重置, ref的绑定和解绑。
before mutation之前主要做一些变量赋值，状态重置的工作，以及调度useEffect。
layout阶段之后主要做三个事情：
// layout阶段之后做的事情 const rootDidHavePassiveEffects = rootDoesHavePassiveEffects; // useEffect相关 if (rootDoesHavePassiveEffects) { // This commit has passive effects. Stash a reference to them. But don't // schedule a callback until after flushing layout work. rootDoesHavePassiveEffects = false; rootWithPendingPassiveEffects = root; pendingPassiveEffectsLanes = lanes; } else { // There were no passive effects, so we can immediately release the cache // pool for this render.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33bb8531da0bf89fb9edabaf27134363/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d716d8f6f726a297fdf7c9d9ac85590/" rel="bookmark">
			hadoop搭建-------大数据平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（平台基本操作，分布式文件系统，Hive数据库，Hbase分布式列数据库）
以上两个命令为查询软件状态
赋予数据库权限
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d2248496001cd301a4fd04c2c68bc7a/" rel="bookmark">
			五、磁盘管理与文件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、磁盘概述
MBR与磁盘的分区表示
主启动记录（MBR）磁盘分区
文件系统类型
开始敲
检测并确认新硬盘
fdisk命令
如何规划硬盘分区
创建文件系统
挂载、卸载文件系统
mkswap命令 (创建交换文件系统)
设置文件系统的自动挂载 1、磁盘概述 磁盘的物理结构
盘片 （硬盘有多少个盘片，每盘片2面） 磁头（每面一个磁头）
磁盘的数据结构
扇区：盘片被分为多个扇形区域，每个扇区存放512字节的数据，硬盘的最小储存单位
磁道：同一盘片不同半径的同心圆，是由磁头在盘片表面划出的圆形轨迹
柱面：不同盘片相同半径构成的圆柱面，由同一半径圆的多个磁道组成
硬盘存储容量=磁头数 x 磁道（柱面）数 x 每道扇区数 x 每扇区字节数（512字节）
可以用柱面/磁头/扇区来唯一定位磁盘上每一个区域
硬盘接口类型
IDE：并口数据线连接主板与硬盘，抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被 SATA 所取代
SATA：抗干扰性强，支持热插拔等功能，速度快，纠错能力强
SCSI：小型机系统接口，SCSI硬盘广为工作站级个人电脑以及服务器所使用，资料传输时CPU占用率较低，转速快，支持热插拔等。
SAS：是新一代的SCSI技术，和SATA硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到 6Gb/s。
MBR与磁盘的分区表示 主引导记录（MBR:Master Boot Record）
MBR位于硬盘第一个物理扇区处（512字节）
MBR中包含硬盘的主引导程序和硬盘分区表
分区表有四个分区记录区，每个分区记录区占16个字节
Linux中讲硬盘。分区等设备均表示为文件
磁盘分区结构
硬盘中的主分区数目只有四个
主分区和扩展分区的序号限制在1~4
扩展分区再分为逻辑分区
逻辑分区的序列号将始终从5开始
主启动记录（MBR）磁盘分区 MBR是主引导记录，位于硬盘第一个物理扇区处，MBR中包含硬盘的主引导程序和硬盘分区表。MBR总共512字节，
前446字节是主引导记录，分区表保存在MBR扇区中的第447-510字节中。分区表有4个分区记录区，每个分区记录区占16字节。
主启动记录(MBR)磁盘分区支持最大卷为2.2TB，每个磁盘最多有4个主分区，或3个主分区、1个扩展分区和在扩展分区里面分多个逻辑分区)。
文件系统类型 XFS文件系统
存放文件和目录数据的分区
高性能的日志型文件系统，特别擅长于处理大文件，可支持上百万TB的存储空间
CentOS 7系统中默认使用的文件系统
SWAP，交换文件系统
为Linux 系统建立交换分区
一般设置为物理内存的1.5~2倍
Linux支持的其他文件系统类型
EXT4、JFS、 FAT16、 FAT32、 NTFS、
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d2248496001cd301a4fd04c2c68bc7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a771b28ab2aa310e8e33329cfdff64f2/" rel="bookmark">
			net 6框架下的EF Core操作数据库表操作基本增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：接着上篇文章，上篇我们创建了web api项目，用EF Core创建表迁移到了数据库，文章地址https://blog.csdn.net/weixin_44442366/article/details/123887300 这篇我们來操作数据库表基本增删改查
首先创建两个文件夹用于定义和实现方法，分别是IService和Service
在Iservice创建接口IBaseService，用于定义基本的增删改查方法接口
然后在类写IBaseService where TEntity : class, new()
接下来在IBaseService定义增删改查方法接口，首先在构造函数初始化数据库操作上下文
using System.Linq.Expressions; using WebApplication1.Context; namespace WebApplication1.ISevice { public interface IBaseService&lt;TEntity&gt; where TEntity : class, new() { //查询表全部数据 public Task&lt;List&lt;TEntity&gt;&gt; QueryAsync(); //新增 public Task&lt;int&gt; Add(TEntity entity); //删除 public Task&lt;int&gt; Del(Expression&lt;Func&lt;TEntity, bool&gt;&gt; delWhere); //修改 public Task&lt;int&gt; EditAsync(TEntity entity); } } 再新建一个接口ICityService继承IBaseService，把要操作的表model传进去，下面我传的是City
开始实现接口，在Service文件夹添加两个类BaseService和CityService用于实现接口
BaseService类继承IBaseService where TEntity : class, new()
实现接口，下面是BaseService类全部代码 using Microsoft.EntityFrameworkCore; using System.Linq.Expressions; using WebApplication1.Context; using WebApplication1.ISevice; namespace WebApplication1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a771b28ab2aa310e8e33329cfdff64f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6947f437e32256b5db64a84bee55dd9a/" rel="bookmark">
			AFL入门笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 安装2. 插桩3. Quick Startcorpus基本使用输出多线程字典崩溃分析 4. 用户手册如何查看结果如何配置（环境变量）多线程 5. Using ASAN with AFL6. TipsFuzz优化 7. More about AFLAFL原理 8. Demo9. 其它参考资料 官方文档：https://afl-1.readthedocs.io/en/latest/fuzzing.html 其他文章：
https://www.freebuf.com/articles/system/191536.htmlhttps://xz.aliyun.com/t/4314 1. 安装 https://afl-1.readthedocs.io/en/latest/INSTALL.html
Ubuntu直接在AFL根目录make编译安装即可：
sudo make &amp;&amp; sudo make install 2. 插桩 https://afl-1.readthedocs.io/en/latest/instrumenting.html
如果有目标程序的源码，就可以对源码进行编译时插桩。AFL也可以使用AFL的QEMU mode对二进制文件进行插桩，但是编译时插桩效率要高很多。
afl-gcc/afl-g++作为gcc/g++的wrapper, 用法与gcc/g++完全一样, 大概提供了这么一些：
afl-gcc,afl-g++, afl-clang, afl-clang++, afl-clang-fast, afl-clang-fast++ 配置一下就能用：
./configure CC="afl-gcc" CXX="afl-g++" 如果目标是共享库，可以设置LD_LIBRARY_PATH让程序加载经过AFL插桩的.so文件：
./configure --disable-shared CC="afl-gcc" CXX="afl-g++" 划重点，Linux版的校验器~， 有大佬说，“AFL Fuzzing without ASAN is just a waste of CPU”.
AFL配备了谷歌自家的Address Sanitizer（ASAN），一个内存检测工具，相当于windows下的verifier校验器：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6947f437e32256b5db64a84bee55dd9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddc77aed42d03da0ff444f2818bbb696/" rel="bookmark">
			【第二篇】Flowable之Eclipse流程绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Eclipse Designer Flowable提供了名为Flowable Eclipse Designer的Eclipse插件，可以用于图形化地建模、测试与部署BPMN 2.0流程。
1.下载安装Eclipse 去Eclipse官网下载即可：https://www.eclipse.org/downloads/packages/release 注意2020-09后的版本不再支持jdk8
解压缩就可以了，然后进入解压缩的目录
直接启动即可
2.安装Flowable插件 然后我们再安装下Flowable的插件，选择Help → Install New Software。在下图面板中，点击Add按钮，并填写下列字段
Name: Flowable BPMN 2.0 designerLocation: http://www.flowable.org/designer/update/ 这种在线更新的方式已经被官网移除了，操作不了
这时我们就只能通过离线安装的方式来实现了，下载对应的离线文件
安装步骤来操作，
然后继续：选择Help → Install New Software
下一步
再下一步
然后finish。弹出如下窗口
重启即可
3.创建项目 然后我们就可以创建一个Flowable Project了
然后我们可以在src/mian/resources/ 的目录下创建对应的流程图了
看到如下的界面说明插件安装成功了
4.创建流程图 使用画板来绘制流程，通过从右侧把图标拖拽到左侧的面板，最终的效果
指定流程的主键
指定任务的负责人
在Properties视图中指定每个任务节点的负责人
创建请假单：zhangsan
审批请假单：lisi
当我们设置完成后保存文件，会同时生成png图片
注意：生成图片需要如下配置
5.部署流程 首先在Eclipse中生成bar文件，选中项目然后鼠标右击
然后会发现在项目的根目录下多了一个deployment文件夹，里面多了一个MyProcess.bar文件
然后我们就可以把这个bar文件拷贝到IDEA中，继续部署的流程
而部署的代码和前面没啥区别
@Test public void testDeployBar(){ // 配置数据库相关信息 获取 ProcessEngineConfiguration ProcessEngineConfiguration cfg = new StandaloneProcessEngineConfiguration() .setJdbcUrl("jdbc:mysql://localhost:3306/flowable-learn2?serverTimezone=UTC&amp;nullCatalogMeansCurrent=true") .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddc77aed42d03da0ff444f2818bbb696/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7758d81cab6450127b65cd8637b02ed2/" rel="bookmark">
			写sql中where限制timestamp类型筛选数据用不了“”，要用‘’？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到了个bug，where里面进行个筛选我也卡住了害，见下图
一下子把自己愣住了，修改后如下
不要用“”，用‘’，至于是为什么?目前不太清楚，如有大佬路过，请告知一下下~感谢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd88aed1db2e2db0b1a2aca233c74114/" rel="bookmark">
			python3_requests模块详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python3_requests模块详解 1、模块说明 requests是使用Apache2 licensed 许可证的HTTP库。
用python编写。
比urllib2模块更简洁。
Request支持HTTP连接保持和连接池，支持使用cookie保持会话，支持文件上传，支持自动响应内容的编码，支持国际化的URL和POST数据自动编码。
在python内置模块的基础上进行了高度的封装，从而使得python进行网络请求时，变得人性化，使用Requests可以轻而易举的完成浏览器可有的任何操作。
现代，国际化，友好。
requests会自动实现持久连接keep-alive
2、基础入门 1）导入模块 import requests 2）发送请求的简洁 示例代码：获取一个网页（个人github）
1 import requests 2 3 r = requests.get('https://github.com/Ranxf') # 最基本的不带参数的get请求 4 r1 = requests.get(url='http://dict.baidu.com/s', params={'wd': 'python'}) # 带参数的get请求 5 我们就可以使用该方式使用以下各种方法
[](javascript:void(0)😉
1 requests.get(‘https://github.com/timeline.json’) # GET请求 2 requests.post(“http://httpbin.org/post”) # POST请求 3 requests.put(“http://httpbin.org/put”) # PUT请求 4 requests.delete(“http://httpbin.org/delete”) # DELETE请求 5 requests.head(“http://httpbin.org/get”) # HEAD请求 6 requests.options(“http://httpbin.org/get” ) # OPTIONS请求 [](javascript:void(0)😉
3）为url传递参数 &gt;&gt;&gt; url_params = {'key':'value'} # 字典传递参数，如果值为None的键不会被添加到url中 &gt;&gt;&gt; r = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd88aed1db2e2db0b1a2aca233c74114/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d7f5d67050e9aca9ebd63f392374bae/" rel="bookmark">
			Android Studio 自带的虚拟机上网解决方案，100%成功
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3个步骤 执行以下步骤前先关闭你的虚拟机
执行以下步骤前先关闭你的虚拟机
执行以下步骤前先关闭你的虚拟机
1.使用cmd进入SDK\emulator目录
2.获取你的虚拟机名称
emulator.exe -list-avds 3.设置网关
emulator.exe -avd 你的虚拟机名称 -dns-server 8.8.8.8 114.114.114.114也可。
然后第三步执行完虚拟机启动就可以上网了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90d4f7b955a4052af1cdc3a768caa67d/" rel="bookmark">
			matlab使用出现矩阵为奇异值、接近奇异值或缩放错误。结果可能不准确。RCOND = NaN。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用griddata插值函数时出现以下错误 警告: 矩阵为奇异值、接近奇异值或缩放错误。结果可能不准确。RCOND = NaN。 原因：新输入参数维度（行数）与原表格参数维度（行数）不同造成的，导致有些空值当0作为输入参数。
解决办法：先将excel中旧数据列删除（而非清除命令），然后在复制粘贴新数据。
以上解决办法只在gridata插值函数时完美解决，其他情况待探究。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fb2b1797b611c48e1892ddf0e324dc4/" rel="bookmark">
			工厂模式，@Autowire可以自动注入bean句柄到Map中（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工厂模式，@Autowire可以自动注入bean句柄到Map中（附源码） 问题背景项目搭建测试结果总结Lyric： 去年的冬天 问题背景 最近做了一个项目需要使用工厂模式，但不同类型的句柄比较多，一个个添加比较麻烦，使用@Autowire自动注入可以减少代码量，和防止遗忘少添加句柄
注意事项：
可以直接使用文中代码，也可以下载源码进行参考 项目搭建 1 引入pom依赖
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.6&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.yg&lt;/groupId&gt; &lt;artifactId&gt;autowireBean&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;autowireBean&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 2 创建工厂
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fb2b1797b611c48e1892ddf0e324dc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6b4a938d968c1f3e247183a787284cb/" rel="bookmark">
			Ubuntu SMP 16.04.1使用huggingface/transformers 4.8.2报错 version `GLIBC_2.29‘ not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在GPU服务器上使用新版的transformers包报了一个错
ImportError: /lib/x86_64-linux-gnu/libm.so.6: version `GLIBC_2.29' not found (required by /home/tangyi/miniconda3/envs/pytorch_gpu/lib/python3.7/site-packages/tokenizers/tokenizers.cpython-37m-x86_64-linux-gnu.so) google一番找到解决方法
https://stackoverflow.com/questions/67636846/importerror-when-from-transformers-import-berttokenizer
推测新版transformers的tokenizer需要2.29版本的GLIBC，但是Ubuntu 16不支持
解决方法1：使用老版本的transformers
亲测可行
conda install -c huggingface tokenizers=0.10.1 transformers=4.6.1 尝试解决方法2：升级Ubuntu至版本18
结果：升级到18仍然解决不了问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7118ddc9eeb3b82195d2aa31a87a800b/" rel="bookmark">
			【时空序列预测paper】PredRNN: Recurrent Neural Networks for PredictiveLearning using Spatiotemporal LSTMs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 论文和两位大佬的解读一起看AI蜗牛车和翻滚的小@强
论文原文：PredRNN: Recurrent Neural Networks for Predictive Learning using Spatiotemporal LSTMs
Abstract: 1.介绍任务：时空序列的预测是通过从历史帧中学习来生成未来图像
2.提出一种新的递归网络结构(PredRNN)：认为时空预测的学习应该在一个统一的记忆池中同时记录空间和时间的变化
3.简单介绍模型结构：内存状态不再局限于每个LSTM单元内，它们可以在两个方向上进行传递：垂直穿过堆叠的RNN层，水平穿过所有的RNN状态。模型结构的核心是一个新的时空LSTM(ST-LSTM)，该LSTM可以同时提取和存储空间和时间表示。
4.介绍实验结果：PredRNN在三个视频预测数据集上实现了最先进的预测性能
Introduction： 1.1 why spatiotemporal memory?
时空预测学习中，有两个关键方面：空间变化和时间变化。简述时空监督学习和时空预测学习的不同：
时空监督学习一般满足两个条件：1）时间特征对于分类任务来说足够强大，空间特征不需要很显著；2）不需要输出复杂的空间结构，所以空间表示可以高度抽象时空预测学习则完全不同，空间变化和时间变化对于生成未来帧同样重要。也就是说，为了更好的预测未来帧，对历史帧学习的时候，不仅仅要学习物体的运动，还要学习到从粗到细的视觉现象 基于此
提出了一种称为Predictive RNN的新的递归架构：它允许不同LSTM的内存状态跨层交互（特别说明：传统RNN中，内存状态不可以跨层交互）
设计了一种称为ST-LSTM的时空单元：它在一个统一的存储空间中对空间变化和时间变化进行建模，同时可以在垂直层和水平层传递状态。
1.2 Related work
之前的工作各有各的不完善性。1）基于RNN体系结构使用LSTM进行建模，由于缺少细粒度的视觉外观，预测图像会变模糊；2）集于CNN的网络，一次预测一帧，更关注于图像外观，捕获长期运动方面比较弱。
Preliminaries: 2.1 Spatiotemporal predictive learning
介绍一下时空预测，时空预测经典公式：
2.2 Convolutional LSTM
介绍一下ConvLSTM，更详细的内容可以看ConvLSTM介绍。指出了ConvLSTM的不足之处：假设对于4层的ConvLSTM编解码网络，输入帧会输入到第一层ConvLSTM，未来的输出帧是在第四层ConvLSTM，在传递的过程中，空间结构被一层一层的解码，同时隐藏状态自下而上的传递。但是，记忆单元在这四层结构中是相互独立的，只在同层的时域之间传递，那么，地层就会完全忽略顶层在上个时间步中记住的内容。克服这种层独立记忆机制的缺点对于视频预测非常重要。
借蜗牛车的图展示一下上面描述的内容：
相同色块的记忆单元没有时间信息的联系。
PredRNN 介绍灵感来源：1）最开始来源于一个想法：预测性学习系统应该在统一的记忆池中记忆空间和时间的变化。然后就让记忆状态沿着Z字形的方向流过整个网络。2）后来想更进一步：想要使时空记忆与原始的长短期记忆相互作用，因此对LSTM和ConvLSTM的内部存储单元、存储门和存储融合机制进行了探索。最后推导出了能在水平和竖直方向上传递存储状态的ST-LSTM。
3.1 Spatiotemporal memory flow
右边：将ConvLSTM进行了堆叠，堆叠后的ConvLSTM逐层抽取高度抽象的特征，然后通过将它们映射回像素值空间进行预测。看图中，记忆单元被限制到只能水平更新，信息只能由隐藏状态向上传递。这种时间记忆流的方式对时空监督学习是有效的，这些隐藏层从下到上会越来越抽象和特定于类。
左边：但是在时空预测学习中，原始输入序列的详细信息应该保持不变，如果我们想展望未来，我们需要从不同级别的卷积层提取的特征中学习。因此，构建了如左图的结构，橙色箭头代表LSTM存储单元的前馈方向。所有的LSTM共享一个统一的内存，该内存沿之字形方向更新。
简单来说：t时刻的第一层cell接收上一个时间步的最后一层cell的隐藏状态和记忆状态，经过第一层传递给第二层一直到最后一层。
3.2 Spatiotemporal memory flow
ST-LSTM以及最终版的结构，橙色的部分是新加入的时空记忆模块M，这一块负责层与层之间的时空记忆传递，白色部分是时间记忆模块C，这一块负责横向时间的流传递。总公式如下：
Experiments 一共在三个数据集上做了实验：MovingMNIST、KTH和radar echo，在这三个数据集上的表现都达到了最好。使用的损失函数是L1+L2loss，特别说明其他的损失函数也用过，但是L1+L2loss效果最好。初始学习率是10-3，这里应该用了动态学习率，迭代了8万次，batch_size为8
1 MovingMNIST
多次实验后，最优架构为4层ST-LSTM，每层128个隐藏状态。实验结果如下
VPN在长期预测表现很差，虽然有时候图像清晰，但是轨迹可能预测的非常不准（比如把8和0相遇后预测成为了3）。相比之下，PredRNN的结果不仅清晰，对于长期运动预测也更准确。
2 KTH action dataset
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7118ddc9eeb3b82195d2aa31a87a800b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e8f3e4ef74fa0eccea5242f0e06ff7/" rel="bookmark">
			Win10系统VS2022开发环境中(X86)Win32汇编(MASM32)环境配置和一些示例源码及解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抱歉，还是只能用米国的软件以及技术以及等等等等。。。。。。，所以各位勿怪。
如果配置完成，在vs2022调试环境下正确编译运行后，可以看到如下画面:
在VS022中开发学习汇编必然很方便。
这里可以下载vs2022项目源码: vs2022中Win32汇编(MASM32)环境配置和测试源码-桌面系统文档类资源-CSDN下载
注意, AsmDude(GitHub - vilyLei/asm-dude: Visual Studio extension for assembly syntax highlighting and code completion in assembly files and the disassembly window)只支持到vs2019。
主要配置过程如下： step1: 按照vs2022(直接官网下载Community版本)
step2：Download The MASM32 SDK这里下载masm32v11r.zip这个压缩包
step3: 将MASM32的install.exe运行安装到C盘(也可以是别的盘)，安装过程注意同意其解压，这里会耽搁一小段时间。
step4: 在vs2022中建立一个控制台应用。删除原来默认生成的cpp文件。
step5: 在项目图标上上右键, 生成依赖项-&gt;生成自定义-&gt;选中masm, 如下图:
step6: 在源文件图标上右键，添加 -&gt; 新建项， 新建 test.asm文件。
step7: 在test.asm写入代码如下:
.386 .model flat, stdcall .stack 4096 option casemap:none include	windows.inc include	user32.inc includelib	user32.lib include	kernel32.inc includelib	kernel32.lib .const szCaption	db	'恭喜',0 szText	db	'Win32汇编程序成功编译!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70e8f3e4ef74fa0eccea5242f0e06ff7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71da22d837a9ed54bddb0d2a52958dad/" rel="bookmark">
			8、随机裁剪 transforms.RandomCrop(）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		transforms.RandomCrop(size, padding=None, pad_if_needed=False, fill=0, padding_mode='constant') size：期望随机裁剪之后输出的尺寸 padding：填充边界的值，单个（int）,两个（[左/右，上/下]），四个（各个边界） pad_if_needed :bool值，避免数组越界 fill:填充 padding_mode ：填充模式 “constant”:利用常值进行填充 “edge”:利用图像边缘像素点进行填充 “reflect”：利用反射的方式进行填充[1, 2, 3, 4] 》[3, 2, 1, 2, 3, 4, 3, 2] “symmetric”：对称填充方法[1, 2, 3, 4] 》》[2, 1, 1, 2, 3, 4, 4, 3] import torchvision.transforms as transform from PIL import Image import matplotlib.pyplot as plt import numpy as np import torch img0=Image.open('lin-xiao-xun-000003.jpg') img1=transform.RandomCrop((128,128))(img0) img2=transform.RandomCrop((500,128),padding=25,fill=125,padding_mode="edge")(img0) axs = plt.figure().subplots(1, 3) axs[0].imshow(img0);axs[0].set_title('src');axs[0].axis('off') axs[1].imshow(img1);axs[1].set_title('RandomCrop');axs[1].axis('off') axs[2].imshow(img2);axs[2].set_title('padding_mode');axs[2].axis('off') plt.show() 实图演示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c02cf4938931c7f27f6676ee6ff2019/" rel="bookmark">
			WebSocket 原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 什么是 WebSocket WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工（full-duplex）通信，即允许服务器主动发送信息给客户端。因此，在WebSocket中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输，客户端和服务器之间的数据交换变得更加简单。
什么是单工、半双工、全工通信？
信息只能单向传送为单工；信息能双向传送但不能同时双向传送称为半双工；信息能够同时双向传送则称为全双工。 在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。
WebSocket 本质上一种计算机网络应用层的协议，用来弥补 http 协议在持久通信能力上的不足。
WebSocket 协议在2008年诞生，2011年成为国际标准。现在最新版本浏览器都已经支持了。
WebSocket 最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。
WebSocket 的其他特点包括：
（1）建立在 TCP 协议之上，服务器端的实现比较容易。
（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
（3）数据格式比较轻量，性能开销小，通信高效。
（4）可以发送文本，也可以发送二进制数据。
（5）没有同源限制，客户端可以与任意服务器通信。
（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。
二、为什么需要 WebSocket？ 我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？
因为 HTTP 协议有一个缺陷：通信只能由客户端发起，不具备服务器推送能力。比如，我们想了解查询今天的实时数据，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。在WebSocket出现之前，我们只能使用"轮询"：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。轮询的效率低，非常浪费资源。
传统的实现即时通信的方式
ajax轮询
ajax轮询的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。ajax轮询 需要服务器有很快的处理速度和资源。long poll（长轮询）
long poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。long poll 需要有很高的并发，也就是说同时接待客户的能力。 在 WebSocket 协议出现以前，创建一个和服务端进双通道通信的 web 应用，需要依赖HTTP协议，进行不停的轮询，这会导致一些问题：
服务端被迫维持来自每个客户端的大量不同的连接大量的轮询请求会造成高开销。 因为http协议本身是没有持久通信能力的，但是我们在实际的应用中，是很需要这种能力的，所以为了解决这些问题，WebSocket 协议由此而生。
三、WebSocket 与 HTTP 的区别 http协议是短链接，每次请求之后，都会关闭连接，下次重新请求数据，需要再次打开连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c02cf4938931c7f27f6676ee6ff2019/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b56e2efcbf493cbf1d7977081835c40/" rel="bookmark">
			浅析轻量化网络mobilenet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文地址：https://arxiv.org/abs/1704.04861；https://arxiv.org/abs/1704.04861
1.背景 MobileNet是轻量化网络的代表之作，与VGG16相比，其准确率下降了0.9%，而参数大大降低，接近1/32，使其在移动端部署成为可能。以MobileNet为代表的网络,可以在移动终端实现众多的应用，包括目标检测，目标分类，人脸属性识别和人脸识别等,使移动终端、嵌入式设备运行神经网络模型成为可能 以MobileNet为代表的网络，可以在移动终端实现众多的应用，包括目标检测，目标分类，人脸属性识别和人脸识别等，使移动终端、嵌入式设备运行神经网络模型成为可能
在更小结构（引入两个超参数）的MobileNet中,在参数量减少了四十多倍的条件下，性能超越了Alexnet，accuracy达到60.2%,体现了本文方法的高效性。 在更小结构的MobileNet中，体现了本文方法的高效性。
2.MobileNet网络结构 一共28层（不加入Avgpool 和 softMax层），13x2 +1+1 = 28；
2.1 深度可分离卷积 深度可分离卷积 （DSC）= 深度卷积（DW）+ 逐点卷积（PW）；其中，深度卷积是指对每个输入通道采用不同的卷积核，例如，我们输入图像是RGB三通道，此时就有3个卷积核与之一一对应。；而PW卷积其实和普通的卷积一摸一样，只不过卷积核大小为1x1。
如图一，是一个标准的普通的普通卷积层，它是由一个3x3卷积+一个批量归一化+一个ReLU，图二是个深度可分离卷积层，它是由一个3x3的深度卷积层+BN+ReLU+DW卷积+BN+ReLU，这是一个标准的深度可分离卷积层，也就是DSC = DW+PW。
2.2 mobilenet超参数 超参数有两个，一个是宽度超参数，一个是分辨率超参数，目的是可以适应更小的模型，消耗更小的算力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc2094deac2e684610355ad3647edd5f/" rel="bookmark">
			Docker 如何实现非root用户构建httpd镜像以及遇到的问题有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要用非root来构建httpd呢？ 由于公司云平台，一般的web组件。不允许用root用户来部署相关应用程序。所以只能编写dockerfile先构建镜像，然后再部署到云平台（kubenetes集群），主要从安全问题来考虑的。还有本来我这个职位职责是管理租户应用问题，但是测试机器没部署。只能自己找镜像，写file部署。中间遇到了很多问题，可能由于我的技术比较菜导致的吧。掉坑里一天出不来，最后还是慢慢排错出来的。不聊别的了，聊聊技术吧。
首先我们需要准备一个干净的镜像，因为我们云平台有docker仓库Harbor。所以我只需要使用命令拉取镜像： docker push 10.0.0.1/public/bclinux:1.1.1 拉取镜像之后，需要使用docker run 命令去运行，我拉取的镜像： docker run --name tudo:1.1.1 -tid 10.0.0.1/public/bclinux:1.1.1 进入运行的docker的容器中（未运行的叫镜像、运行了就叫容器了） docker exec -ti tudo:1.1.1 /bin/bash 修改基础镜像的yum源文件，因为内网涉及安全问题一般yum源配置是： cat &gt;/etc/yum.repos.d/os.repo&lt;&lt;EOF [centos7] name=Server baseurl=http://10.0.0.1/fpz #源路径 gpgcheck=0 gpgcheck=1 #是否检查GPG(GNU Private Guard)，一种密钥方式签名。 EOF 使用yum install -y httpd 部署安装完成后使用systemctl启动报错 # systemctl start httpd System has not been booed with systemd as init system (PID 1).Can't operate. Failed to connect to bus: Host is down 怎么解决报错呢？答案是跳过这种方式去启动httpd直接用路径启动 #type httpd httpd is /usr/sbin/httpd 执行完命令发现还有问题 #/usr/sbin/httpd AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc2094deac2e684610355ad3647edd5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13fea9d2e105205510cc72af97ace19f/" rel="bookmark">
			基于NDVI的植被覆盖度计算--Arcgis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		植被覆盖度的估算利用像元二分模型进行，基本原理就是假定一个像元的信息只由植被和土壤两部分贡献。根据影像上的NDVI灰度分布，以0.5%置信度截取NDVI上下阈值分别代表植被和土壤，并在Arcgis中利用栅格计算器进行计算。
得到的植被覆盖度F被分成了五个等级。F&lt;10%为低植被覆盖，10%&lt;f&lt;30%为较低植被覆盖度，30%&lt;f&lt;50%为中度植被覆盖，50%&lt;f&lt;70%为较高植被覆盖度，f&gt;=70%为高植被覆盖度。
具体采用Arcgis进行计算的步骤如下，NDVI数据请自行下载，本文不包含下载教程。如想批量下载植被指数数据，请关注下期推文会带来NDVI批量下载方法。
一、99.5%以及0.5%置信度的NDVI值选择
首先，对遥感数据进行重分类。如选择1%、99%置信度为阈值则分为100类，如选择0.5%和99.5%置信度则分为200类。分类方式选择quantile。
二、植被覆盖度计算公式 分类后,break values中的第一个(-622)就是0.5%分位点，第199个数字就是第99.5%分位点。记录两个点数值后，用栅格计算器进行计算。计算公式如下（栅格计算器中）：
Con(("modis_1801_ndvi.tif"=NDVI99.5),1,("modis_1801_ndvi.tif" - NDVI0.5)/ NDVI99.5- NDVI0.5))
文章同步更新与公众号GIS攻略，如有问题可在公众号后台进行提问，大家可一起交流沟通！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ddbe164d599e4030a4f8c4002072022/" rel="bookmark">
			记一次获取access_token为空引发的生产问题 -1000
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目开发中微信渠道为了获取用户地理位置（经纬度）需要调用微信JSAPI，在参数的获取过程中需要后端服务器请求获取access_token，在生产上报出了空指针，也就是未获取到access_token，我们看下获取access_token接口说明。
接口调用请求说明
https请求方式: GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET
参数说明
参数是否必须说明grant_type是获取access_token填写client_credentialappid是第三方用户唯一凭证secret是第三方用户唯一凭证密钥，即appsecret 返回说明
正常情况下，微信会返回下述JSON数据包给公众号：
{"access_token":"ACCESS_TOKEN","expires_in":7200} 参数说明
参数说明access_token获取到的凭证expires_in凭证有效时间，单位：秒 公司开发分为sit uat 准生产 生产环境，在sit和uat配置时使用的是微信测试号，没有出现任何问题，生产偏偏出现问题，在排查中发现微信接口返回报文是
{ “errcode”: -1000 “errmsg”: "system error" } 提示：未知返回状态. 经过各种百度发现官方的一段说辞。
为了提高公众平台开发者接口调用的安全性，避免一旦开发者ID和密码泄露后给帐号造成损失。我们对调用“获取access_token”接口增加IP白名单校验：只有将IP地址设置为公众号的IP白名单，才能成功调用该接口。
开启IP白名单的步骤如下：
1、登录公众平台，进入开发-&gt;基本配置页面
2、点击配置进入IP白名单设置页
3、填写IP地址列表
多个之间回车隔开
4、管理员扫码确认保存
5、调用“获取access_token”接口，返回结果。如非白名单IP调用，将返回错误码：40164，可通过wiki查看具体原因。
这里说明了问题是未配置白名单ip，为什么会返回-1000状态而不是40164状态，是因为在生产的企业微信未配置任何ip白名单。未配置ip白名单返回-1000，配置了但是不再白名单ip中返回40164。
公司项目后端是通过代理服务器出去的，所以我们在配置的时候找到了代理服务器的出口也就是出口的公网ip全部配置进ip白名单中，问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e627a50d8abf5fca760812425c666820/" rel="bookmark">
			Java语言编写Tic-Tac-Toe游戏（含注解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此程序中用了五个方法，play1()和play2()分别用于接收用户12的输入然后更新棋盘，deal()用于判断用户的输入是否有效，print()用于在用户操作后打印棋盘格，judge()用于判断是否有某一种棋子连成一行，即判断游戏是否要继续进行。
代码如下：
import java.util.*; public class tic-tac-toe { public static void main(String[] args) { System.out.println("Let's play tic-tac-toe"); // 构建一个3*3的二维数组(初始棋盘） char[][] checkerboard = new char[3][3]; Scanner in = new Scanner(System.in); System.out.println("Who want to first?(please enter player1 or player2)"); String first = in.next(); if(first.equals("player1")){ int round = 1; boolean judge = false; while(judge == false){ if(round%2 == 1){ checkerboard = play1(checkerboard); print(checkerboard); if(judge(checkerboard)==true){ break; } round ++; }else{ checkerboard = play2(checkerboard); print(checkerboard); if(judge(checkerboard)==true){ break; } round++; } } }else { int round = 2; boolean judge = false; while (judge == false) { if (round % 2 == 1) { checkerboard = play1(checkerboard); print(checkerboard); if (judge(checkerboard) == true) { break; } round++; } else { checkerboard = play2(checkerboard); print(checkerboard); if (judge(checkerboard) == true) { break; } round++; } } } } // 方法print()用于打印操作后的棋盘格 public static void print(char[][] checkerboard){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e627a50d8abf5fca760812425c666820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a8c82f78b3a02e8be808bc97b3dc499/" rel="bookmark">
			零基础VUE.js学习笔记 基础篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记整理来源 B站up主黑马程序员
B站黑马程序员 快速入门vue前端
适合初学者入门vue.js， 该文是基础篇
基础篇包括课程中的Vue基础和本地应用环节
后续会更新进阶篇，包括网络应用和综合应用
文章目录 VUE.JS基本使用语法元素解释标签eldata vue本地应用内容绑定，事件绑定v-testv-htmlv-on案例--计数器 显示切换，属性绑定V-showV-ifV-bind图片切换 列表循环，表单元素绑定v-forv-on补充v-model 实例设计--小黑记事本1.新增2.删除3.统计4.清空5.隐藏记事本小结5.隐藏记事本小结 课程地址及课程中源码下载 VUE.JS 使用vue.js首先需要导入vue库
&lt;script src="http://cdn.jsdelivr.net/npm/vue"&gt; &lt;/script&gt; 或者导入本地vue文件
文中&lt;script src=""&gt;&lt;/script&gt;代表导入vue库
基本使用语法 &lt;div id="app"&gt; {{message}} &lt;/div&gt; &lt;script src=""&gt;&lt;/script&gt; &lt;script&gt; var app=new Vue({ el:"#app", data:{ message:"123456" } }) &lt;/script&gt; 元素解释 标签 只支持双标签 eg：div h1 h2 （body不可以）
&lt;h1 id="**"&gt; &lt;/h1&gt; 标签里面插入{{}}
{{}}：差值表达式 。
el 挂载点，可根据id，class，css，标签选择器进行挂载。
&lt;div id="app"&gt; --el:"#app" &lt;div class="app"&gt; --el:".app" &lt;div &gt; --el:"div" data 对挂载点的插值表达式进行替换。
eg：message：你好
可支持对象
eg: &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a8c82f78b3a02e8be808bc97b3dc499/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1812db9bcc1bf7374905ae27d61176b9/" rel="bookmark">
			Redis（一）——引言和安装、redis 的启动、后台启动、远程访问、redis的数据类型、Jedis（Jedis的使用、连接池、个人封装的一个工具类）、Lettuce
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 一、Redis 的引言与安装 1、引言 使用 redis 的原因和 redis 的作用：
NoSQL ：
2、安装 下面使用第一个方法安装。
二、redis 的启动 1、启动 redis 可以这么启动：
但是一般不这么启动，因为会占据一个窗口，一般都是让其后台启动的。
2、后台启动 首先先进入到 src 目录里面去，如果要进行后台运行的话，需要修改配置文件的一处地方（redis目录下的 vi redis.conf）：
进入到编辑状态下，先进入到命令行状态，然后输入 /xxx 可以快速搜索 xxx ，如果要查看下一个 xxx，就点击键盘上的 n，代表 next。
a、修改 daemon 把 no 改成 yes：
b、后台启动 redis 因为修改了配置文件，所以如果启动的时候想要根据配置文件里面的配置来启动的话，需要这么输入：
然后这样就能后台运行了。
查看后台运行的 redis：
c、关闭 redis 服务 3、开启远程访问 有个工具可以监控 redis 的状态，但是需要开启远程访问才能连接：
开启远程访问需要修改三处地方（vi redis.conf）：
a、修改 bind 把下面这一行注释掉！
b、修改 protected-mode 把下面的 yes 修改成 no。
c、修改 requirepass 去掉注释，并且把 foobared 改为 123。这里是在配置密码，密码是 123
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1812db9bcc1bf7374905ae27d61176b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab859ae140d669cd97df76ca474f2f7a/" rel="bookmark">
			数据库分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库分类：
１　MySQL:速度很快，适合对数据要求并不是十分严格的地方，去掉了很多中小型企业中不常用的功能；
２　MSSQLServer:与.Net结合很好，只能运行在windows平台下，大数据量、大交易量表现并不是十分好，功能比MySql多；
３　其他：DB2(大型)、Oracle(大型)、Access(文件)、SQLite(及其轻量级)、Sybase等。
几大数据库（sqlserver，Oracle，MySQL等等其他数据库）犹如小程序开发，虽然名字不一样，内在其实大差不离，语法都差不多。犹如微信小程序开发，同行迅速模仿拷贝，换个名字就是自个的了，小到犹如老家的开乡镇超市的，完全一样的道理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b73c3a8528827fe6094f66b2542d35c/" rel="bookmark">
			OBS视频录制及其直播推流教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.基础结构篇
让我们先来看看OBS的主界面：
我们可以看到，整个界面由中间的黑色大舞台和下面的许多控件组成，下面我就来一一介绍。
中间的黑色大舞台就是预览界面，会用于预览我们将要录制进去的内容。左下角依次是：场景模块，来源模块，混音器模块，转场模块和控件模块，这些模块都是可以拖动出来悬浮，或者自定义调整其顺序的。
画布：最中间的黑色大舞台，其中展示的东西就是我们录制进去的内容。
场景：可以设置不同的场景用于切换，这样在录制时可以快速切换不同的画面，主要是直播用处比较大，比如主播切换广告页面和游戏界面时，录制视频一般不用。
来源：最重要的模块，在这里我们可以选择我们想要录制的内容，如图：
这里有很多来源可以选择，我们最常用的就是窗口捕获和游戏捕获，这两者非常类似，我用窗口捕获作为详细例子来讲。首先我们点击左下角的加号，选择窗口捕获，会弹出这样一个窗口：
创建或选择源
选择新建，名字可以自己取，后期也可以任意更改，然后点击确定。使源可见的意思是，在点击确定后是否立即在画布上预览这个窗口。之后我们可以得到这样一个窗口，我以捕获谷歌浏览器为例：
窗口捕获
我们可以选择我们想要捕获的窗口，窗口的内容就在这个小框内预览出来了，由于我选择了使源可见，所以我捕获的浏览器界面就立即在背后画布上显示了出来。在左下角来源模块中，我们可以看到多了一个刚刚创建的来源，旁边的小眼睛的符号就是选择是否在画布上预览，只有在画布上预览出来的内容，才会被录制进去，而小锁代表的是是否锁定在画布上的固定位置，比如图片中是没有锁定的，在画布上可以看到，窗口边有很多红线条，我们可以拖动四个角，对我们的窗口进行大小和位置的调整。
下面讲一个重点：这里有两种捕获方式，分别是Win7 和Win10，默认是自动选择，如果捕获的窗口预览时，发现是黑屏，则需要手动更改捕获方式。在Win7的捕获方式下，是可以隐藏鼠标的，也就是不录制鼠标，而在Win10的捕获方式下，鼠标是被强制录制进去的，如果对于隐藏鼠标有要求，而且在Win7捕获下没法录制，可以更改被捕获窗口的兼容模式，使用Win7兼容模式运行就可以了。
窗口匹配项：软件给的解释非常清楚，可以根据自己的需求调整，一般默认就行。这些调整完之后，我们就可以在画布上看到我们想要录制的内容了。
混音器模块：这里是负责录制声音的部分，其中有桌面音频和麦克风，桌面音频捕捉就是电脑发出来的声音，麦克风就不用解释了，如果不想录制麦克风或者桌面音频的话，直接点击音量控制条右边的小喇叭，直接将此模块静音就行。部分补充将在下一个板块中的音频参数设置提及。这里要注意，Mac端是没有自带的桌面音频的，需要安装一个虚拟声卡叫Soundflower来捕获电脑内的声音。
转场模块：用于切换场景时过渡，这样可以显得切换更自然更好看。
控件模块：负责操控开始录制和结束录制及其他复杂功能。
2.参数设置篇
2.1 视频及其推流参数
选择控件模块中的设置，再选择左侧的输出标签，就可以得到这样一个界面：
录制参数页面
直播推流设置页面
在最上方的输出模式要选择高级！
选择录像标签页，串流是用于直播，参数设置和录像异曲同工，需要直播的可以在串流页面设置。
录像格式：选择mkv，这是最稳定也是体积比较小的文件格式。
编码器：主要的编码器类型有：
NVIDIA编码器（硬件编码），使用英伟达独立显卡进行编码，也是游戏电脑的最佳选择，对电脑负担小。更新：GTX1660包括20系、30系显卡是搭载的新编码器芯片，不会在显卡满载时对编码产生明显影响，且编码效果与CPU编码基本没有差别，此类显卡小伙伴无脑选择显卡编码即可，编码器名称会显示NVENC H264 (new)。为什么是1660以上，因为1650搭载的是10系显卡的老编码器，老黄刀法~
QuickSync H264 编码（硬件编码），这是使用处理器内即成的核心显卡进行编码，不建议选择，如果是办公电脑，没有独立显卡的，建议选择后面的x264软件编码。更新：如果是直播游戏，且独立显卡性能不足（1650及以下显卡，直播时候推流出的画面丢帧或卡顿），需要在主板BIOS中开启核心显卡，并安装对应驱动，即可在OBS中找到此选项，可以有效提升直播效果。（核心显卡判别：Intel系列后缀有F的，则没有核心显卡，AMD桌面端CPU均没有核心显卡，笔记本CPU有）
苹果VT H264（硬件/软件）编码器：Mac端的编码器，顾名思义，我测试过确实不好用，编码效果不好而且对硬件负载大，建议使用软编。
X264编码器（软件编码）：使用处理器进行编码，稳定性最好，编码效果最佳，产生的文件压缩率最高，但是对处理器负载较高。更新：可以通过CPU使用预设来调整，速度越快，处理器占用越少，效果越差，最高建议只开到fast，medium的话，对处理器压力太大，且画质提升不大。
上图展示的是NVIDIA硬件编码器的参数，接下来我来详细讲解各个部分：
速率控制：主要常用的有两种：CBR（恒定码率）和VBR（动态码率），这里建议都选择VBR模式。因为视频的压缩算法是通过关键帧来计算后面的帧，所以在静态画面时需要的码率低，而在高速运动画面所需要的码率高，使用固定码率势必会造成资源的浪费，在不需要占用空间的帧上浪费了空间，在需要清晰度的帧上发生清晰度不足的现象。而VBR模式是完美的利用了空间，在静态画面时，利用前面一帧的画面来计算后面一帧的画面，降低了静态画面的码率，多出来的空间可以在需要高清录制时，使用更高的码率录制更清晰的动态画面，不产生资源的浪费，平均码率与CBR模式下基本一致，清晰度基本没有差别，而在录制相同视频时，VBR模式录制的文件体积会比CBR模式下小很多，也方便储存。只不过VBR时实时的二次编码，对硬件有一定的压力，不过我已经测试过了，目前的大部分设备都是可以负载这种录制模式的。（更新：如果出现画面模糊，尤其是录制游戏的时候，则是因为码率过低导致的，需要提高码率）
比特率：就是码率（单位时间视频文件的大小），数值越高，录制出来的文件越清晰。4000就是俗称的蓝光4M，8000就是俗称的蓝光8M，看过直播的小伙伴应该都知道。码率也决定了文件的大小，根据我的统计，一般游戏画面一小时VBR模式下蓝光4M为1个GB左右。当然，码率越高对硬件的负载也是成倍数上升的，建议大家不要开太高，根据自己显卡的性能来选择，实在没把握的可以私信来咨询我。码率选择过高可能会导致编码器过载，可能导致录制出来的视频掉帧，卡顿，也会导致硬件发热，可能对硬件有所损伤，这样就得不偿失了。
最大比特率：VBR模式下动态码率波动的范围，一般高出50%即可，不要调太高，显卡会承受不住，实际上的码率是会超过这个限制的。
关键帧间隔：一般默认就好。因为视频的画面都是由关键帧（I帧）和B帧P帧组成的，后面的帧都是根据前面的关键帧计算出来的，也就是说关键帧储存了全部的画面信息，当然这也会导致关键帧所占空间很大。关键帧设置间隔太短（关键帧变多），由于平均码率是固定的，这样视频的清晰度会有一定程度的下降。
预设一般选择质量或者最高质量就行。向前考虑和心理视觉调整是通过算法让画面看起来更好看，当然对显卡的负载也会更大，根据自己的需求来选择。
2.2 音频参数
更新：音频码率设置
音频码率设置界面
音频的码率设置界面在输出菜单下，对应的轨道和前面的推流录像界面的音轨一一对应，请勾选正确，直播只可以推流一个音轨，录像可以多个音轨。
码率选择：对于一般人来说，160kbps以上即可录制很清晰的声音，对于声音有要求的，比如电台直播等，需要把声音码率拉到最高320，否则高频声音会被切掉。
我们先来看一下音频参数的设置界面
音频参数设置界面
采样率一般用两种44.1kHz或48kHz，越大越清晰，实际上听不出太大区别，而且B站对音频的要求是44.1kHz，即使你选了48kHz，上传后也会被压制的，所以如果小伙伴是为了录制视频发B站就直接选择44.1kHz采样率就好了。更新：直播推流是支持48kHz的，直播的小伙伴开这个就行。
桌面音频是Windows端默认就有的，Mac端是没有的，对于Mac用户需要自己安装一个Soundflower虚拟声卡就可以录制电脑的声音了。桌面音频就是录制从我们电脑扬声器发出来的声音，俗称内录。但是这里有一个小问题，就是如果我们在录制视频的时候，需要用电脑同时做别的事情，就可能会有其他声音录制进去，所以我专门安装了一个虚拟声卡Voicemeter，这样将需要录制的软件的音频输出选为这个虚拟声卡，选择之后我们可能会听不到声音，这时候在主界面选择音量控制边上的齿轮，把关闭监听改成监听并输出就可以了。如果用虚拟声卡录制并打开了监听的小伙伴，记住要关闭第一个桌面音频，不然会有回音。
更新：对于声卡用户，跳线驱动的连接等等，请咨询声卡卖家，由于太复杂，这里不再赘述。
麦克风我就不用多说了吧，大家都应该懂，需要一边录制一边解说就开启，否则就关闭。
2.3 其他参数
其他参数就是一些特殊的东西了，比如分辨率的设置。
分辨率设置界面
这里的画布分辨率呢就是我们预览界面的分辨率，这个一般需要设置成和显示器一样的分辨率，否则会导致录制不全，比如只能录制屏幕的一部分或者有黑边。一般的电脑显示器就是1920×1080分辨率，一般的2K显示器的分辨率是2560×1440，13寸的MacBook pro的分辨率是2560×1600，其他尺寸的可以在苹果官网查到，有详细信息。更新：显示器的比例有16：9和16：10两种，16：10在视觉上更舒服，前提是电脑支持。
而输出分辨率就简单易懂了，就是我们录制的视频最后输出的分辨率，一般的1080P屏幕就选择输出1080P就行了，2K的屏幕一般需要压缩到1080P，压缩方式就选双立方即可，因为绝大部分视频网站最高也只支持1080P分辨率，况且2K的文件体积太大，也不方便储存。
至于帧率就根据自己的需求选择就可以了。
更新：最后一点就是关于色彩空间的设置（新版OBS引入了sRGB模式）
渲染器我们莫得选择，只有这一种。
颜色格式有4种，分别是NV12，I420，I444和RGB。
前两种即NV12和I420采用的是YUV420的采样方式，只不过储存顺序上有些差别，而B站要求的视频色彩空间便是YUV420。后面两种即I444和RGB采用的是YUV444的采样方式，如果大家要发视频到B站，我就不建议大家选择这两种。
如果是要直播的小伙伴，推流只能用NV12的格式，其他格式均只适用于录制视频。
色彩空间有609和709（新版新增sRGB），对于Windows系统，默认是sRGB色域，所以大家就选这个新功能就好了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b73c3a8528827fe6094f66b2542d35c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42acda96233ae9cbd8f7baa0ad985adb/" rel="bookmark">
			基于阿里云IOT Studio和STM32的电机远程监测设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天来总结一下用阿里云的IOT Studio做的一个电机远程监控的小系统吧！
说来话长，在去年九月份的时候，我踏入了研究生的行列。我的导师是搞电机方向的，但我本科是测控的，考虑我的基础，导师给我推荐了物联网的学习方向，说我学电机控制一定会很痛苦的，我一听就感觉很高大上的，也很有道理的样子，从那一刻我未来三年的学习，甚至有可能这辈子都跟物联网结下了不解之缘。
刚开始的时候，导师叫我去看有关物联网的书，我就疯狂看了很多，什么万物互联，从Bill Gates的未来之路，到2009总理的感知中国，到现在万物智能，智能家居，智能园区，智慧城市等等，后来才发现这些了解一定就够了，研究生还得做实际的，导师就说我得看开发，不让讲出来的东西会很空，并向我推荐了物联网开发云平台，涂鸦，阿里云，百度云等。
我首先注册了涂鸦的物联网平台账号，通过了解，涂鸦的东西很多都专业性强，扩展性较差，对于学习物联网的学生似乎不是很友好……….经过不断了解，最终确定了我主要学习的物联网平台——阿里云，它的物联网平台可以说是国内做的最好的物联网平台了，提供了各种产品的SDK和API，说明文档非常详细，很适合初学者。
哈哈，扯的有点远了，接下来具体说说过程吧，工欲善其事，必先利其器！
百度搜索阿里云，点击右上角立即注册……
具体注册过程我就不细说了，阿里云的注册过程相对大多数物联网平台是更麻烦的，也更正规。注册完成，点击右上角控制台进入物联网平台，如果找不到入口，可直接搜索下图地址：
点击开通公共实例，进入后点击设备管理下的产品，创建产品，品类选择自定义，联网方式WIFI，其他的默认。
接着创建设备，接着点击左边产品下的设备进行创建设备。然后再回到产品页，点击创建的产品，进入功能定义，创建变量：
完成之后，退出物联网平台，首页搜索物联网应用开发，进入IOT Studio的学习：
点击左边项目管理，进入创建项目，并绑定之前的产品和设备。
接下来创建应用开发，PC端选择Web应用，手机端选择移动应用，创建好之后点击进入开发界面。这里有丰富的组件供我们选择，零代码开发，进行数据的绑定。
具体操作我就不细说了，每个组件都有详细的说明文档。接下来展示一下我拖拉完成后的效果吧！
第一页：
第二页：
第三页：
基本就是这样了，最后点击右上角的保存并发布，这里需要绑定自己的域名，没有的话生成的链接的有效期就只有24小时，也好像只是当天有效，具体不记得了。 点击左边的应用设置-域名管理：
在这里我们看到，需要一个域名，域名是什么呢？就像www.taobao.com那种，我们需要去阿里云万网申请一个自己的域名……申请好之后再按着上图的的步骤完成域名解析，备案等等，中间会支付一个120元两年的物联网小套餐，服务即付费嘛，需要学习阿里云物联网平台的建议开通一下。全部完成之后在域名列表那里添加绑定，这样你发布的应用就不受影响了，只需在浏览器输入你的域名就可以使用了，也可以用相关软件将应用打包成app安装到手机上使用，推荐软件HbuilderX，免费的，手机上效果：
基于阿里云Iot studio和stm32的电机远程监测设计_哔哩哔哩_bilibili
物联网开发常见的系统架构如下：
本次设计我的感知控制层采用传感器dth11上报温湿度，电机自带霍尔进行测速等，MCU用的是STM32F103C8T6,传输层用的是esp8266WIFI模块，通过MOTT协议与阿里云建立连接，进行数据的上报和命令的下发(数据解析用的是Jansson)，监控电机的运行状态，达到参数监测、远程控制，状态预警等功能。
有点遗憾的是：
1、第一页的电机运行状态用表格组件记录并显示功能没有实现，这个得去阿里云的Open api里面调脚本实现了, 没有成功…….
2、也没有实现通过下拉框组件或者其他方式实现一对多的功能。
希望有会的大佬留言指点一下。整体实现并不难，大佬不要嘲笑！
有需要这个设计相关帮助或源码的，请联系QQ：2627075749
备注：远程监测帮助
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/734aff6ab5199e514a19ca428a834e06/" rel="bookmark">
			java8 对比两个 List ，遍历匹配数据的优化处理 支持一对多
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：根据云端设备数据集合和数据库设备数据集合，进行对比，本地设备和云端设备相同的，本地数据要进行更新，云端有本地没有的设备，本地要进行新增 //查询数据库 服务商下所有分机数据集合 List&lt;CcExtensionTelephone&gt; dbList = Lists.newArrayList(); //查询云端平台 所有分机信息集合 List&lt;CcExtensionTelephone&gt; cloudList = Lists.newArrayList(); //4.获取集合相同的部分进行更新 List&lt;CcExtensionTelephone&gt; list = compareListData(cloudList, dbList); /** * @param cloudList 云端list * @param dbList 数据库list * @return List&lt;CcExtensionTelephone&gt; * @description: TODO 对两个 List 遍历匹配数据的优化处理 * @author hyh * @date 2022/3/30 16:35 */ public static List&lt;CcExtensionTelephone&gt; compareListData(List&lt;CcExtensionTelephone&gt; cloudList, List&lt;CcExtensionTelephone&gt; dbList) { //两个List 如果ID==CHANNEL_ID 用UUID替换掉CHANNEL_ID List&lt;CcExtensionTelephone&gt; resultList = cloudList.stream().map(cloudTel -&gt; dbList.stream() .filter(dbTel -&gt; Objects.equals(cloudTel.getExtNumber(), dbTel.getExtNumber()) &amp;&amp; Objects.equals(cloudTel.getMac(), dbTel.getMac()))//若云端分机号和本地分机号相同 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/734aff6ab5199e514a19ca428a834e06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33392bb35403f4bbceb69f49c1d93700/" rel="bookmark">
			Tomcat学习详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Tomcat详解 1、安装tomcat 官网搜索tomcat
选择版本号，和对应的电脑操作位
下载解压即可使用
2、tomcat的配置与启动 2.1、熟悉文件目录 2.2、tomcat服务启动与关闭 启动后返回测试：http://localhost:8080/
2.3、配置文件 找到核心配置文件
代码核心内容介绍
默认端口号：8080
默认的主机名：localhost–&gt;127.0.0.1
默认网站应用存放的位置：webapps
配置环境变量（可选！）
配置教程
3、网站的访问机制 根据输入的域名检查本机的C:\Windows\System32\drivers\etc\hosts 配置文件下有没有这个域名的映射
有：直接访问对应的IP地址。在这个地址中，有我们需要访问的web程序，可以直接访问
查看hosts文件的域名映射
没有：则去DNS服务器找，找到就返回，没有的话则页面显示找不到
4、尝试发布一个网站 将自己编写的网站放到服务器（tomcat）中指定的web应用文件夹（webapps)下，就可以访问网站了
应用文件目录结果实例：
--webspps Tomcat服务器的web目录 -ROOT -新建文件夹（即为网站的目录名） -WEB-INF -classes Java程序 -lib web应用所依赖的jar包 -web.xml 网站的配置文件 -index.html 默认的首页 -static -css -js -img -...... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/011a3676ad4c1ccf47130a713cc362b9/" rel="bookmark">
			STM32CubeMX学习笔记（28）——FreeRTOS实时操作系统使用（任务管理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、FreeRTOS简介 FreeRTOS 是一个可裁剪、可剥夺型的多任务内核，而且没有任务数限制。FreeRTOS 提供了实时操作系统所需的所有功能，包括资源管理、同步、任务通信等。
FreeRTOS 是用 C 和汇编来写的，其中绝大部分都是用 C 语言编写的，只有极少数的与处理器密切相关的部分代码才是用汇编写的，FreeRTOS 结构简洁，可读性很强！最主要的是非常适合初次接触嵌入式实时操作系统学生、嵌入式系统开发人员和爱好者学习。
最新版本 V9.0.0（2016年），尽管现在 FreeRTOS 的版本已经更新到 V10.4.1 了，但是我们还是选择 V9.0.0，因为内核很稳定，并且网上资料很多，因为 V10.0.0 版本之后是亚马逊收购了FreeRTOS之后才出来的版本，主要添加了一些云端组件，一般采用 V9.0.0 版本足以。
FreeRTOS官网：http://www.freertos.org/代码托管网站：https://sourceforge.net/projects/freertos/files/FreeRTOS/ 二、新建工程 1. 打开 STM32CubeMX 软件，点击“新建工程”
2. 选择 MCU 和封装
3. 配置时钟
RCC 设置，选择 HSE(外部高速时钟) 为 Crystal/Ceramic Resonator(晶振/陶瓷谐振器)
选择 Clock Configuration，配置系统时钟 SYSCLK 为 72MHz
修改 HCLK 的值为 72 后，输入回车，软件会自动修改所有配置
4. 配置调试模式
非常重要的一步，否则会造成第一次烧录程序后续无法识别调试器
SYS 设置，选择 Debug 为 Serial Wire
三、SYS Timebase Source 在 System Core 中选择 SYS ，对 Timebase Source 进行设置，选择 TIM1 作为HAL库的时基（除了 SysTick 外都可以）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/011a3676ad4c1ccf47130a713cc362b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7344389728232a646c67166c9ef6739/" rel="bookmark">
			shardingsphere5.0.0整合分布式柔性事务seata1.4.2示例步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回来5天发现深圳宝安新冠疫情感染者，我远在江西，明明离我很远，还是要自费隔离，惨向天涯何处诉！😏
一、下载Seata1.4.2 进入官网：Seata
二、安装部署Seata 参阅官网：直接部署
三、添加jar依赖 &lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;shardingsphere-jdbc-core-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- BASE事务（Seata）模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;shardingsphere-transaction-base-seata-at&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;version&gt;1.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-api&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; 四、部署安装启动Nacos 因为需要将Seata注册到中心，这里选择nacos作为注册中心。
安装部署略
五、配置registry.conf 文件存放路径在classpath路径下
使用nacos作为注册和配置中心
registry { # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa # 这里类型使用nacos作为seata注册中心 type = "nacos" nacos { application = "seata-server" serverAddr = "127.0.0.1:8848" group = "SEATA_GROUP" namespace = "public" cluster = "default" username = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7344389728232a646c67166c9ef6739/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3062a8077287d50a3758b36a8be13653/" rel="bookmark">
			C&#43;&#43; ofstream和ifstream详细用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ofstream 和 ifstream 详细用法 导读一、打开文件二、关闭文件三、读写文件1、文本文件的读写2、二进制文件的读写 四、检测EOF五、文件定位格式化输入输出：1 整数数据的输入输出2 字符数据的输入3 字符串数据的输入4 浮点数5 二进制文件6 随机存取文件 导读 ofstream是从内存到硬盘，ifstream是从硬盘到内存，其实所谓的流缓冲就是内存空间
在C++中，有一个stream这个类，所有的I/O都以这个“流”类为基础的，包括我们要认识的文件I/O.
stream这个类有两个重要的运算符：
1、插入器 &lt;&lt;
向流输出数据。比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout &lt;&lt; "Write Stdout" &lt;&lt; '\n'; 就表示把字符串"Write Stdout"和换行字符(’\n’)输出到标准输出流。
2、析取器 &gt;&gt;
从流中输入数据。比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin &gt;&gt; x; 就表示从标准输入流中读取一个指定类型的数据。
在C++中，对文件的操作是通过stream的子类fstream(file stream)来实现的，所以，要用这种方式操作文件，就必须加入头文件fstream.h。
一、打开文件 在fstream类中，有一个成员函数open()，就是用来打开文件的，其原型是：
void open(const char* filename,int mode,int access);
参数：
filename：　要打开的文件名 mode：　要打开文件的方式 access：　打开文件的属性 打开文件的方式在类ios(是所有流式I/O类的基类)中定义.
常用的值如下：
ios::app：　以追加的方式打开文件 ios::ate：　文件打开后定位到文件尾，ios:app就包含有此属性 ios::binary：　以二进制方式打开文件，缺省的方式是文本方式。两种方式的区别见前文 ios::in：　文件以输入方式打开(文件数据输入到内存) ios::out：　文件以输出方式打开(内存数据输出到文件) ios::nocreate： 不建立文件，所以文件不存在时打开失败 ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败 ios::trunc：　如果文件存在，把文件长度设为0 可以用“或”把以上属性连接起来，如ios::out|ios::binary
打开文件的属性取值是：
0：普通文件，打开访问
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3062a8077287d50a3758b36a8be13653/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f3809252c0015939cd451e0decb2eda/" rel="bookmark">
			[蓝桥杯python] 车的放置:在一个n*n的棋盘中，每个格子中至多放置一个车，且要保证任何两个车都不能相互攻击，有多少中放法(车与车之间是没有差别的)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[蓝桥杯python] 车的放置
1、资源限制
2、输入格式
3、输出格式
4、样式输入及输出
5、代码及解析
大功告成！编写不易，大家成功后点个关注or赞谢谢~
问题描述
在一个n*n的棋盘中，每个格子中至多放置一个车，且要保证任何两个车都不能相互攻击，有多少中放法(车与车之间是没有差别的)
1、资源限制 资源限制
时间限制：1.0s 内存限制：256.0MB
2、输入格式 包含一个正整数n
3、输出格式 一个整数，表示放置车的方法数
4、样式输入及输出 样例输入
2
样例输出
7
5、代码及解析 具体解析请大家自己看一下代码中的备注，在此不多做解释。
n = int(input()) result = 1 visited = [0] * n #记录这一行时候已经放置的棋子 def DFS(row,visited): global result if row &gt;= n: return for i in range(n): if visited[i] == 0: visited[i] = 1 result += 1 DFS(row+1,visited) #该行放置了棋子，再找下一行 visited[i] = 0 DFS(row+1,visited) #不放棋子的情况 DFS(0,visited) print(result) 结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f3809252c0015939cd451e0decb2eda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c86dac4e86a5f001264ce3ff7c30091/" rel="bookmark">
			解决word、typora等打不开超链接问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决word、typora等打不开超链接问题 法1：大概率是因为Chrome的问题，如果不介意使用edge浏览器打开超链接，可以直接在默认应用中将这两个设置为edge浏览器（我这里是已经调教好Chrome）
法2：如果还想用Chrome浏览器打开超链接，可以参考下文：
默认google浏览器打不开链接（点击超链接没有反应）
设置完，重启Chrome或者重启电脑就好了。
法3：另一种方法
Chrome浏览器作为默认浏览器时点击超链接无法跳转到浏览器
这种方法点击链接每次都弹出一个选项，不好用。
法2、法3的默认浏览器都是Chrome
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21bf94b44ad25b3dc64e69215e3491b0/" rel="bookmark">
			vue3中插槽的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3中插槽的使用 文章目录 vue3中插槽的使用匿名插槽具名插槽作用域插槽 插槽就是子组件中的提供给父组件使用的一个占位符，用&lt;slot&gt;&lt;/slot&gt; 表示，父组件可以在这个占位符中填充任何模板代码，如 HTML、组件等，填充的内容会替换子组件的&lt;slot&gt;&lt;/slot&gt;标签，父组件填充的内容称为插槽内容。
子组件不提供插槽时，父组件填充失效父组件无填充时，&lt;slot&gt;&lt;/slot&gt;中的备用内容会启用生效父级模板里的所有内容都是在父级作用域中编译的，子模板里的所有内容都是在子作用域中编译的，互不影响 匿名插槽 又名默认插槽
&lt;!-- my-button子组件定义 --&gt; &lt;template&gt; &lt;button&gt; &lt;slot&gt;SUBMIT BTN&lt;/slot&gt; &lt;/button&gt; &lt;/template&gt; &lt;!-- 父组件调用my-button --&gt; &lt;my-button&gt; 提交按钮 &lt;/my-button&gt; &lt;!-- 父组件页面渲染为 --&gt; &lt;button&gt; 提交按钮 &lt;/button&gt; 具名插槽 当有多个插槽时，插槽增加了name属性来正确渲染对应的部分，父组件需要使用&lt;template&gt;&lt;/template&gt;。可以认为匿名插槽是特殊的具名插槽。
&lt;!-- my-layout子组件定义 --&gt; &lt;template&gt; &lt;div&gt; &lt;header&gt; &lt;slot name="header"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;!-- 其实就是&lt;slot name="default"&gt;&lt;/slot&gt; --&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name="footer"&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/template&gt; &lt;!-- 父组件调用my-layout --&gt; &lt;my-layout&gt; &lt;!-- 填充内容顺序无关 --&gt; &lt;template v-slot:footer&gt; &lt;p&gt;我来组成脚丫子&lt;/p&gt; &lt;/template&gt; &lt;!-- v-slot:header可以简写为#header --&gt; &lt;template v-slot:header&gt; &lt;h1&gt;我来组成头部&lt;/h1&gt; &lt;/template&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21bf94b44ad25b3dc64e69215e3491b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf12b19b011652b5c6d4381e5d202a1/" rel="bookmark">
			C&#43;&#43; error: non-const lvalue reference to type
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 使用场景 指向的对象延时new指向的对象运行时动态释放和分配 二 遇到的现象及原因 2.1 关键字含义 int * const &amp;rpa 表明rpa本身不能在赋值int* 类型,但是可以使用*rpa做左值const int * const &amp;crpa 表明crpa本身不能在赋值int* 类型,且不可以使用*crpa做左值 2.2 目标需求【既不能修改本身的值也不能修改指向对象的值】 2.3 实践操作问题 /* * rpa 和 crpa同时初始化为pa,rpa的地址为&amp;a,crpa的地址为&amp;a */ int a = 10; int *pa = &amp;a; int * const &amp;rpa = pa; const int * const &amp;crpa = pa; cout&lt;&lt;"a:"&lt;&lt;a&lt;&lt;"\t"&lt;&lt;*pa&lt;&lt;"\t"&lt;&lt;*rpa&lt;&lt;"\t"&lt;&lt;*crpa&lt;&lt;endl; // 10 10 10 10 cout&lt;&lt;"a1:"&lt;&lt;&amp;a&lt;&lt;"\t"&lt;&lt;pa&lt;&lt;"\t"&lt;&lt;rpa&lt;&lt;"\t"&lt;&lt;crpa&lt;&lt;endl; // 0x9afe0c 0x9afe0c 0x9afe0c 0x9afe0c /* *然后pa进行重新赋值指向b *结果rpa的地址为&amp;b【符合预期,满足部分目标需求】 *但crpa的地址还是&amp;a【不符合预期,与目标需求不符合】 */ int b = 20; pa = &amp;b; cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bf12b19b011652b5c6d4381e5d202a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/523a3427b678e6f2d7ef95f14dd96354/" rel="bookmark">
			第1章 准备工作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1本书的内容
要处理的数据类型，结构化数据如下等：
表格型数据，其中各列可能是不同的类型（字符串、数值、 ⽇期等）。
多维数组（矩阵）。
通过关键列（对于SQL⽤户⽽⾔，就是主键和外键）相互联系的多个表。
间隔平均或不平均的时间序列。
json类型数据
1.2为什么要使⽤Python进⾏数据分析
Python的库的强大，如pandas和scikit-learn、matplotlib等
1.3重要的Python库
以下三个标准库是学习的重点：NumPy，pandas，matplotlib，还包括：SciPy，scikit-learn，statsmodels等
NumPy：
快速高效的多维数组对象ndarray；
对数组执行元素级计算以及直接对数组执行数据运算的函数；
读写硬盘上基于数组的数据集工具；
线性代数运算、傅里叶变换及随机数的形成；
成熟的C API
pandas：使用最多的pandas对象是DataFrame，它是⼀个⾯向列（column-oriented）的⼆维表结构，另⼀个是 Series，⼀个⼀维的标签化数组对象。pandas重要的功能是完成重塑、切片、切块、聚合和选取数据子集的操作，是数据分析的基础。
matplotlib：最流行的用于绘制图表和其他二维可视化的工具。
SciPy:一组专门解决科学计算中各种标准问题域的包的集合，主要包括：
scipy.integrate：数值积分例程和微分方程求解器。
scipy.linalg：扩展了由numpy.linalg提供的线性代数例程和矩阵分解功能。
scipy.optimize：函数优化器（最小化器）以及根查找算法。
scipy.signal：信号处理⼯具。
scipy.sparse：稀疏矩阵和稀疏线性系统求解器。
scipy.special：SPECFUN（这是⼀个实现了许多常⽤数学函数（如伽玛函数）的Fortran库）的包装器。
scipy.stats：标准连续和离散概率分布（如密度函数、采样器、连续分布函数等）、各种统计检验方法，以及更好的描述统计法。
SciPy常和NumPy一起用。
scikit-learn：通用机器学习工具包，包括
分类：sum、近邻、随机森林、逻辑回归等，
回归：lasso、岭回归等，
聚类：k-均值，普聚类，
降维：PCA、特征选择、矩阵分解，
选型：网络搜索、交叉验证、度量，
预处理：特征提取、标准化处理。
statsmodels：statsmodels是⼀个统计分析包，包含经典统计学和经济计量学的算法，包括子模块：
回归模型：线性回归、广义线性模型、健壮线性模型，线性混合效应模型等等。
方差分析。
时间序列分析：AR，ARMA，ARIMA，VAR和其它模型。
非参数方法：核密度估计，核回归。
统计模型结果可视化。
statsmodels更关注统计推断，提供不确定估计和参数p-值。相反的，scikit-learn注重预测。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/250/">«</a>
	<span class="pagination__item pagination__item--current">251/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/252/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>