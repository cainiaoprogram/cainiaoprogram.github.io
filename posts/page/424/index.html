<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cd8fe7865c7f9f8a09e64d976c0deea/" rel="bookmark">
			ORACLE创建一个只读用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 打开sqldeveloper工具，在左边的菜单里找到Users,右键Users文件夹→新建
2. 填写新建用户的相关信息，默认表空间可以自己定义
3.为用户授予角色权限为connect resource
4. 为用户授予系统权限
5.保存后使用新建的用户登录，例如为DEMO用户创建QIXL用户，在创建完毕用户以后，使用QIXL用户登录，访问DEMO用户的表通过select * from DEMO.TABLENAME的方式访问，此时对该用户的全部表QIXL只能查询了。
方式二使用同义词，不需要使用用户名.表名方式访问
概方法如下：
我们用户HISTEST下面有很多表，需创建用户 hongshu
no1.先创建一个用户hongshu，密码hongshu
no2.给他一些权限，包括连接权限，因为他要创建同义词，还需要给他同义词
grant connect to hongshu ;
grant create synonym to hongshu;
grant create session to hongshu;
no3.因为需要把HISTEST的所有表的查询权限给hongshu。所以需要所有表的grant select on table_name to hongshu语句，不可能一句一句去写，因此用select 吧所有的grant语句查出来直接执行,注意：HISTEST要大写，不然结果是空的
select 'grant select on '||owner||'.'||object_name||' to hongshu;'
from dba_objects
where owner in ('HISTEST')
and object_type='TABLE';
把上述语句查询出来的结果(如下图)全部选中复制出来，在HISTEST 下执行一遍
NO4.需要给HISTEST用户下所有表创建同义词，但是考虑到之前已经创建过一些表的同义词，因此把所有创建同义词的语句select出来在hongshu用户下执行。
SELECT 'create or replace SYNONYM hongshu. ' || object_name|| ' FOR ' || owner || '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cd8fe7865c7f9f8a09e64d976c0deea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d62876a57a76fc12fcb55c52bb363aa/" rel="bookmark">
			unix/linux 文件系统结构浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、物理磁盘到文件系统
文件系统用来存储文件内容、文件属性、和目录。这些类型的数据如何存储在磁盘块上的呢？unix/linux使用了一个简单的方法。如图所示.
它将磁盘块分为三个部分：
1)超级块，文件系统中第一个块被称为超级块。这个块存放文件系统本身的结构信息。比如，超级块记录了每个区域的大小，超级块也存放未被使用的磁盘块的信息。
2) i-节点表。超级块的下一个部分就是i-节点表，每个文件都有一些属性，如文件的大小、文件所有者、和创建时间等，这些性质被记录在一个称为i-节点的结构中。所有i-节点都有相同的大小，并且i-节点表是这些结构的一个列表，文件系统中每个文件在该表中都有一个i-节点。
3)数据区。文件系统的第3个部分是数据区。文件的内容保存在这个区域。磁盘上所有块的大小都一样。如果文件包含了超过一个块的内容，则文件内容会存放在多个磁盘块中。一个较大的文件很容易分布上千个独立的磁盘块中.
二、创建一个文件的过程
我们现在知道文件的内容和属性是分开存放的，那么又是如何管理它们的呢？现在我们以创建一个文件为例来讲解。在命令行输入命令：
$ who &gt; userlist
当完成这个命令时。文件系统中增加了一个存放命令who输出内容的新文件，那么这整个过程到底是怎么回事呢？
文件的属性和内容：内核将文件内容存放在数据区，文件属性存放在i-节点，文件名存放在目录。图2显示了创建一个文件的例子，假如这个新文件要3 个存储块来存放内容。
包括如下四个步骤：
1)存储属性 也就是文件属性的存储，内核先找到一块空的i-节点。图2中。内核找到i-节点号47。内核把文件的信息记录其中。如文件的大小、文件所有者、和创建时间等
2)存储数据 即文件内容的存储，由于该文件需要3个数据块。因此内核从自由块的列表中找到3个自由块。图2中分别为627、200、992，内核缓冲区的第一块数据复制到块627，第二和第三分别复制到200和992.
3)记录分配情况，数据保存到了三个数据块中。所以必须要记录起来，以后再找到正确的数据。分配情况记录在文件的i-节点中的磁盘序号列表里。这3个编号分别放在最开始的3个位置。
4)添加文件名到目录，新文件的名字是userlist， 内核将文件的入口(47,userlist)添加到目录文件里。文件名和i-节点号之间的对应关系将文件名和文件和文件的内容属性连接起来，找到文件名就找到文件的i-节点号，通过i-节点号就能找到文件的属性和内容。
三、创建一个目录的过程
前面说了创建一个文件的大概过程，那么创建一个目录时又是怎么回事呢？
我们知道，目录其实也是文件，只是它的内容比较特殊：包含文件名字列表，列表一般包含两个部分：i-节点号和文件名。所以它的创建过程和文件创建过程一样，只是第二步写的内容不同。一个目录创建时至少包括两个链接：“.”，“..”
我们可以通过系统命令来查看目录的内容：#ls -lia
上图的结果是文件名和对应的i-节点号，其中“.”表示是当前目录，而“..”是当前目录的父目录。但也有特殊情况，我们查看根目录的情况:
[root@localhost ~]# ls -i1a / 2 . 2 .. 98305 .autofsck 1310721 backup 我们发现“.”和“..”都指向i-节点2.实际上当用mkfs创建一个文件系统时，mkfs会将根目录的父目录指向自己 四、如果有大文件如何实现
文件内容的分配情况是必须记录在i-节点的磁盘序号列表里的。但是i-节点只包含一个最多含有13个项的分配链表,如果分配的数据块超过13个块时怎么办？
Linux用到一个间接块来解决此问题.比如我们要记录14个块的编号，可以把前面10个记录在i-节点的磁盘序号列表里。另外4个编号放在一个数据块中。在i-节点的第11项里记录存放编号的数据块的指针，通过这个指针就能找到余下的4个数据块的编号，这个用来存放编号的数据就叫间接块。（二次间接寻址找到数据）
但当间接块也存满了时我们还可以再开第二个间接块，甚至3、4、5。。。更多额外块。但内核并不会把这些块记录在文件的i-节点的第12、13项里。而是开辟一个新的块的来存放这些间接块的列表，并在i-节点的第12项存放这一新额外块的编号。这存放着那个存储着第2、3、4、及后继额外块的编号的块的编号，这个块称为二级间接块.
同理当二级间接块饱和时还可以开辟第三级。（三次间址）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61b3c3316c3872988a25618d6971c211/" rel="bookmark">
			2013 B 碎纸片拼接与复原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
对重要文件的拼接复原，传统上都由人工完成，拼接准确率虽然高但是效率很低。本文旨在建立模型，利用计算机编程加少量的人工干预实现碎纸片的拼接复原。
针对问题1，由于对任意一个字符来讲，笔画是连续的，所以对于一般情况，即使文字被切开，两边的像素还是有联系的，是呈现离散性渐变的。针对此特征，建立了文字连续性模型来求解该问题。而又因为被切开的两边碎片边缘灰度是具有高相关性的，所以，又建立了向量相关模型来求解进行图片拼接。用两种模型分别求解，都得到了对附件一和附件二的正确拼接结果。
针对问题2，可以采用第一问的模型，先进行全局搜索，找出每个碎片最相似的右侧邻近碎片，拼接出每一行的图片，再利用向量相关性进行横向拼接，得到拼接结果。但是，由于纸片同时被横向与纵向切割，碎片小，数量多，碎片之间的信息量不够，容易造成误判。所以建立向量投影分类模型，首先将可能处于同一行的碎片用模糊C均值(FCM)聚类方法分到同一类。对于汉字或英文的缺行碎片（碎片中只有一行或者两行字），利用掩码补充模型将投影中缺失的行用掩码补齐，然后再放入分类。分类完成后，将每一类中的碎片进行横向排序拼接。每一类横向拼接完成后，从而拼接成完整图片。对于不能正确拼接的部分，采取了多种人工干预的策略，最终得到正确的拼接结果。
针对问题3，由于附件中的碎片分为正反两面，所以可以建立组合匹配模型将碎片首先将正反面碎片的灰度矩阵上下拼接，每张碎片的拼接方案有两种（灰度矩阵a放在左右镜像处理后的b上或灰度矩阵b放在左右镜像处理后的a上）。拼接过后，边缘灰度向量信息会增加为原来的两倍，这时利用问题二中的全局搜索模型用向量相关性的方法进行匹配拼接。拼接出所有行后，将每一行的下半部分矩阵切割放在上半部分的右边，又可增加横向拼接时的边缘信息，然后各行再次利用向量相关性的方法进行横向拼接，最终得到结果图，但是仍然存在较多的碎片不能正确匹配，需要人工干预。
由于碎片在切割时的随机性，使得机器自动拼接存在一定的难度，因此，采取恰当的人工干预的措施，是保证正确拼接的必要手段。
关键词：文字连续性 匹配 FCM聚类方法 掩码补充模型 向量投影分类模型
一．问题背景及重述
破碎文件的拼接在司法物证复原、历史文献修复以及军事情报获取等领域都有着重要的应用。传统上，拼接复原工作需由人工完成，准确率较高，但效率很低。特别是当碎片数量巨大，人工拼接很难在短时间内完成任务。但如果借助计算机技术，开发出碎纸片的自动拼接技术，提高拼接复原效率将会大大提高。
问题1：给定的来自同一页印刷文字文件的碎纸机破碎纸片（仅纵切），建立碎纸片拼接复原模型和算法，并且拼接复原附件1和附件2给出的中、英文各一页文件的碎片数据。
问题2： 对于碎纸机既纵切又横切的情形，设计碎纸片拼接复原模型和算法，并针对附件3和附件4给出的中、英文各一页文件的碎片数据进行拼接复原。
问题3：从现实情形出发，还可能有双面打印文件的碎纸片拼接复原问题需要解决。附件5给出了一页英文印刷文字双面打印文件的碎片数据。设计相应的碎纸片拼接复原模型与算法，并就附件5的碎片数据给出拼接复原结果。
二．模型假设
1、不计碎纸片边缘的磨损，没有边缘像素损耗；
2、假设纸张垂直放入碎纸机即每张小碎纸片都是规则矩形；
3、图片中的文字像素没有任何断点；
4、图像上没有任何噪声或污点造成像素干扰。
三．变量说明
四．模型准备与问题分析
针对题目中附件所给的图片信息，我们学习准备了图像的处理方法[1]、模式匹配方法[2]和图像拼接方法[3,4]。将图片批处理成范围值0-255之间的灰度矩阵（纯黑为0，纯白为255，数字越大，颜色越亮）。
问题一中的附件图片，碎片数据较少，每一张碎片都比较大，那么相应的灰度矩阵中包含的信息就比较多，处理起来相对容易。而且仔细观察，分别只有一张图片的最左端和最右端边缘是没有文字的。由于完整纸片切开后，边缘处仍然是有联系的。所以可以提取图像边缘的灰度信息，首先找出第一张图片，然后利用图片的边缘信息找出下一张图片与之拼接。
问题二中，给出的图片碎片比较小，只有180*72像素，图像信息以及边缘信息都比较少。而且，由于既横切又纵切，图片的顺序被打乱，无法直接拼接。因此，首先得将这些碎片分类，将同一行的图片归在同一类中，然后将归类后的图片进行横向排序，拼接出这一行的图片碎片，因为有些碎片包含的边缘信息过少，可能无法分类或者成功排序，这时进行人工干预。每一行图片按排序拼接后，即可将问题转化为第一问的问题进行纵向拼接，最终得到结果。
问题三中附件五的碎片与问题二中附件四的类似，都是英文小碎片，但是正反面被打乱。虽然正反面一开始无法识别，但是某一张图的正面与另一张正面横向投影对齐，反面的横向投影也就会对齐。所以我们可以利用a面和b面的矩阵上下组合，变成一个大的单面图片，一方面增加了拼接的信息量，同时又将问题转化为第二问中类似的问题，利用第二问的模型即可找出双面碎片的拼接结果。
五．模型建立与求解
5.1 问题一的求解
5.1.1 基于文字连续性模型的碎片拼接
首先，对问题1的分析可知，该问题为一个图像处理问题。根据字的特征，我们知道笔画是连续的，图片放大之后我们也能看到有字的部分图像偏暗，由字中间向边缘，慢慢变亮直至超过字范围而变成白色。我们利用这一点，建立文字连续性模型来处理拼接问题。
（a） （b） 图1：点阵字体的锯齿现象
由字体放大图1(a)可以看出笔画周边的锯齿，每一个锯齿方块就是一个像素，范围大小在255以下。切割后的图像，这些锯齿也会分开。但是，虽然像素分开了，由于汉字字体或者英文字体大部分是连体的，所以这些碎片的图像灰度信息会有一定的相关性或者说是连续性。
如图1(b)，假如图片像素按照红线所示切开分为a，b两块。可以看到红线左右两边的像素块大都是相连的，最理想的情况就是如同像素块2，3或者4，5在同一位置直接对应，这种情况就可以认为这两个像素块匹配，匹配数num加1。但是，也有可能出现像素块1这样的情况，与之对应的位置没有像素块，但是下方或者上方有像素块，由于这些像素的连续性，所以也认为像素1得到匹配，num=num+1。
读取所有图片，由于纸张有页边距，若某一张碎片为完整纸片上的最左一张，则其图像左侧必定全为白色，即灰度值的前几列为255，通过这种方法，能很快找到第一张碎片，将其放入集合中，记为。
找到第一张碎片后，用第一张碎片的右边缘去和中所有碎片的左边缘进行匹配。由于白色点太多，匹配成功数会很大，影响结果。所以，我们只选取非白色点进行匹配，匹配过程中，非白色点的总数记为sumofb，每选取边缘非白色点匹配一次，sumofb=sumofb+1。
匹配率[3]的计算方法为：
（1）
求得第一张碎片的右边缘和集合中每张碎片左边缘的匹配率后，将所得的匹配率对比，选取匹配率最高的那张碎片，将其放入集合中，记为（i为碎片的排列顺序），将右边缘像素去和中剩余碎片的左边缘像素进行匹配，重复此类操作，直到中没有碎片，最终得到排序结果即为碎片的拼接方案。计算所得集合中与的最大匹配率如表1所示。
表1：附件一中中文字符碎片拼接顺序及匹配情况：
当前碎片编号
8
14
12
15
13
10
2
16
1
最佳匹配碎片编号
14
12
15
13
10
2
16
1
4
最大匹配率
0.83
0.96
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61b3c3316c3872988a25618d6971c211/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35685f7df04ff932b5e644a1b3104d0e/" rel="bookmark">
			详述解决jupyter notebook打开浏览器空白
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前jupyter notebook一直在360浏览器下打开，今天重装了anaconda之后，发现打开jupyter notebook，home页面空白。
解决办法：更换默认的浏览器，选择谷歌浏览器，很多360打不开的页面，更换谷歌后都能有效解决。
1、找到anaconda下的anaconda prompt并打开
2、在anaconda prompt里面输入：jupyter notebook --generate-config
回车后会生成一个配置文件jupyter_notebook_config.py，会提示该文件所在的目录，我的在：C:/user/.jupyter下面。
3、找到并打开这个文件，需要在这个文件设置默认浏览器处增加Chrome，找到如下代码（95-99行）：
## Specify what command to use to invoke a web browser when opening the notebook. # If not specified, the default browser will be determined by the `webbrowser` # standard library module, which allows setting of the BROWSER environment # variable to override it. #c.NotebookApp.browser = '' 在下面，增加如下代码：
import webbrowser webbrowser.register('chrome', None, webbrowser.GenericBrowser(u'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe')) c.NotebookApp.browser = 'chrome' 可能有人会说不知道谷歌浏览器位置啊，别急，听我说。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35685f7df04ff932b5e644a1b3104d0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a989462ac7b776462ff8875dcd0cbc6d/" rel="bookmark">
			IDEA和VS code设置默认换行符为LF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信用Git的人对这个问题非常了解了，如果团队没做好约定，或者新人不太会用git，用的又是windows，git又没有开启autocrlf，那么当队友修改了代码提交之后，那画面真的是不忍直视。
所以索性将IDE的默认换行符设置为LF，一劳永逸；
1.IDEA
File--》Other Settings--》Default Settings--》Editor--》Code Style--》Line separator
今天发现有人点赞这篇文章，看了一下之后发现设置路径已经不太一样了
加上一个IDEA 2019.1版本的设置路径，供参考
File--》Settings--》Editor--》Code Style--》Line separator
设置为Unix and OS X（\n）
2.VS Code
设置--》用户设置--》文本编辑器--》文件--》eol--》
设置为\n
或者直接搜索files:eol进行设置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d931bc2a7180c2ded7247af1dc81266/" rel="bookmark">
			libxxx.so- text relocations问题的出现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此问题是在AndroidStudio3.0.1下，运行程序出现的，应该是so文件的原因造成的错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eecc036ad19ef91d577e9c0ce786159/" rel="bookmark">
			PCL学习之点云显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、利用pcl::visualization::PCLVisualizer显示，当点云不在坐标系中心时，窗显示为空，按住Ctrl+R可以调出点云对象
pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); // 创建点云（指针） if (pcl::io::loadPCDFile&lt;pcl::PointXYZ&gt;("E:\\Project\\width3D3Cam\\result.pcd", *cloud) == -1) //* 读入PCD格式的文件，如果文件不存在，返回-1 { PCL_ERROR("Couldn't read file test_pcd.pcd \n"); //文件不存在时，返回错误，终止程序。 return (-1); } boost::shared_ptr&lt;pcl::visualization::PCLVisualizer&gt; viewer(new pcl::visualization::PCLVisualizer("3D Viewer")); viewer-&gt;setBackgroundColor(0.5, 0.5, 0.5); viewer-&gt;addPointCloud&lt;pcl::PointXYZ&gt;(cloud, "sample cloud"); viewer-&gt;setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 1, "sample cloud"); viewer-&gt;addCoordinateSystem(1.0); while (!viewer-&gt;wasStopped()) { viewer-&gt;spinOnce(100); boost::this_thread::sleep(boost::posix_time::microseconds(100000)); } 2、利用CloudViewer也可以，但是只能显示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29761bc95c3979c2fbc9a3ea50e77838/" rel="bookmark">
			C# 加载和传递图片，导致内存溢出的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由C#向C++里面传递图像的过程中，多加载几次图像后，内存会暴涨，主要有两个原因：
一、pictureBox的清理不能用pictureBox.Image=null清除，而应该使用，pictureBox1.Image.Dispose()。
二、Bitmap实例化之后，需要释放用dispose()空间。
[DllImport("HoleDetect.dll", CallingConvention = CallingConvention.Cdecl)] public static extern void HoleDetect(IntPtr src, int height, int width,int Stride); private void treeView1_NodeMouseClick_1(object sender, TreeNodeMouseClickEventArgs e) { click_node = path_dir + "\\" + e.Node.Text; if(pictureBox1.Image!=null)pictureBox1.Image.Dispose(); pictureBox1.Image = Image.FromFile(click_node); //获取图像的指针 Bitmap srcBmp = new Bitmap(click_node); int height = srcBmp.Height; int width = srcBmp.Width; BitmapData bmdata = srcBmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadWrite, srcBmp.PixelFormat); IntPtr ptr = bmdata.Scan0; //图像指针 HoleDetect(ptr, height, width, bmdata.Stride); srcBmp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29761bc95c3979c2fbc9a3ea50e77838/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62d7aa3b04194c6e8f8077748fcd64cb/" rel="bookmark">
			Opencv计算图像的梯度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include "stdafx.h" #include &lt;opencv2/opencv.hpp&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;opencv2/core/core.hpp&gt; #include&lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv.hpp&gt; using namespace cv; using namespace std; namespace EnerageGradient { void GetKernel(int* &amp;kernel, int wid)//核函数 { for (size_t i = 0; i &lt; wid*wid; i++) { kernel[i] = -1; } kernel[wid*wid / 2 ] = wid*wid - 1; } /*-------------------------------------------- 计算图像梯度 input： img 输入图像 wid 求取梯度的窗体大小 out： 传出图像 --------------------------------------------*/ cv::Mat GetGradient(Mat &amp;img,int wid) { Mat imgGradient(img.size().height,img.size().width,CV_8UC1); imgGradient = 0; int length = wid*wid; int *kernel = new int[length]; memset(kernel, 0, length); GetKernel(kernel,wid); for (int i = wid/2; i &lt; img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62d7aa3b04194c6e8f8077748fcd64cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0429bde8527dc6ca1c7b1785552b77af/" rel="bookmark">
			图像算法——特征拟合之平面拟合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最小二乘拟合算法
typedef struct { double r0; double r1; double r2; double distB; //used in distance caculating }RATIO_Plane; typedef struct { float xxx; float yyy; float zzz; }roiPointDecimal3D; int fitPlane3D(const roiPointDecimal3D *point, int pNum, RATIO_Plane *plane3D) { /*平面方程式：z=r0*x+r1*y+r2*/ double sum_xx = 0; double sum_xy = 0; double sum_yy = 0; double sum_xz = 0; double sum_yz = 0; double sum_x = 0; double sum_y = 0; double sum_z = 0; double mean_xx, mean_yy, mean_xy, mean_yz, mean_xz, mean_x, mean_y, mean_z; double a[4]; double b[4]; double c[4]; double d[4]; double D1, D2, D3, DD; int i; double effSize = 0; for (i = 0; i &lt; pNum; i++) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0429bde8527dc6ca1c7b1785552b77af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f83e217ac2788f92dea76f3e9b5e5c0b/" rel="bookmark">
			排队论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1-泊松流与指数分布
主要是关于输入流为泊松流，而时间间隔是服从指数分布
2-排队模型
这里主要是MMN和MM1
M表示泊松分布和负指数分布
3-单服务台负指数分布M/M/1排队系统
模型的条件是：
1、输入过程――顾客源是无限的，顾客到达
完全是随机的，单个到来，到达过程服从普阿
松分布，且是平稳的；
2、排队规则――单队，且队长没有限制，先
到先服务；
3、服务机构――单服务台，服务时间的长短
是随机的，服从相同的指数分布 4-
服务强度就是多除了个S，也就是有s台服务器平均分担工作
不同之处还在于如果有排队不是单独排队而是排成一起在一个候诊区
Ws为逗留时间，Wq为等待时间，Ls为队长即系统中顾客期望值，Lq为等待服务的顾客数
其他
对于MMS，也就多除了个S 服务强度《1
例子
计算mms paidui1：
s=2;
mu=4;
lambda=3;
ro=lambda/mu;
ros=ro/s;
sum1=0;
for i=0:(s-1)
sum1=sum1+ro.^i/factorial(i);
end
sum2=ro.^s/factorial(s)/(1-ros);
p0=1/(sum1+sum2);
p=ro.^s.*p0/factorial(s)/(1-ros);
Lq=p.*ros/(1-ros);
L=Lq+ro;
W=L/lambda;
Wq=Lq/lambda;
fprintf('排队等待的平均人数为%5.2f人\n',Lq)
fprintf('系统内的平均人数为%5.2f人\n',L)
fprintf('平均逗留时间为%5.2f分钟\n',W*60)
fprintf('平均等待时间为%5.2f分种\n',Wq*60)
————————————————————————————————————————————————————————
给MM1画图
paidui2
clear clc %***************************************** %初始化顾客源 %***************************************** %总仿真时间 Total_time = 10; %队列最大长度 N = 10000000000; %到达率与服务率 lambda = 10; mu = 6; %平均到达时间与平均服务时间 arr_mean = 1/lambda; ser_mean = 1/mu; arr_num = round(Total_time*lambda*2); events = []; %按负指数分布产生各顾客达到时间间隔 events(1,:) = exprnd(arr_mean,1,arr_num); %各顾客的到达时刻等于时间间隔的累积和 events(1,:) = cumsum(events(1,:)); %按负指数分布产生各顾客服务时间 events(2,:) = exprnd(ser_mean,1,arr_num); %计算仿真顾客个数，即到达时刻在仿真时间内的顾客数 len_sim = sum(events(1,:)&lt;= Total_time); %***************************************** %计算第 1个顾客的信息 %***************************************** %第 1个顾客进入系统后直接接受服务，无需等待 events(3,1) = 0; %其离开时刻等于其到达时刻与服务时间之和 events(4,1) = events(1,1)+events(2,1); %其肯定被系统接纳，此时系统内共有 %1个顾客，故标志位置1 events(5,1) = 1; %其进入系统后，系统内已有成员序号为 1 member = [1]; for i = 2:arr_num %如果第 i个顾客的到达时间超过了仿真时间，则跳出循环 if events(1,i)&gt;Total_time break; else number = sum(events(4,member) &gt; events(1,i)); %如果系统已满，则系统拒绝第 i个顾客，其标志位置 0 if number &gt;= N+1 events(5,i) = 0; %如果系统为空，则第 i个顾客直接接受服务 else if number == 0 %其等待时间为 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f83e217ac2788f92dea76f3e9b5e5c0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e689de828459f272b8690295116116be/" rel="bookmark">
			Linux学习-常用文件目录操作命令（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Linux特点
Linux是Unix的衍生版本，Mac os则是Unix 基础上的另一种操作系统。Linux版本主要分为内核版本和发行版本，内核版本主要是操作系统内核，一般我们无法直接使用，而是使用社区或厂商在linux内核基础上研发的发行版本，比如redhat、centos、ubuntu等。
与windows区别：
1、Linux严格区分大小写
2、Linux一切皆文件，无论软件程序还是硬件都对应一个文件
3、Linux区分文件类型并不是根据文件后缀，而是根据文件的权限，但是有一些约定的文件类型来使人区别文件类型
4、windows程序不能直接运行在linux上
Linux一般用于企业服务器或嵌入式（支持裁剪），企业级服务器中一般没有图形界面，因为有更多的额外的程序服务，就会带来更大的风险。linux作为开源软件，拥有丰富的配套资源软件，但是游戏就比较少。
发行版本ubuntu与centos区别是ubuntu图形界面更完善一些，但是也没有达到很优秀，但是centos更稳定一些，做企业级服务器更好。
2、Linux文件用户权限
‘- - - - - - - - - -’
Linux文件权限总共有10位，第1位表示文件的类型-(文件)、d(目录)、l(链接)、b(存储设备)、c(串口设备) 连续---表示rwx（4 2 1） 第1个连续三位表示所有者对文件的权限； 第2个连续三位表示文件所属用户组对文件的权限 第3个连续三位表示其他用户对文件的权限 3、修改用户对文件的权限
chmod 修改文件权限
文字设定法
chmod ［ugoa］ ［+ | – | =］ ［rwxugofvr…］ 文件名
chmod ugo+w file.txt //等价 chmod a+w file.txt
数字设定法
chmod ［r4 w2 x1］ 文件名
chmod 777 file.txt chmod 664 file.txt chown 修改文件所属主或者组
语法：chown ［cvR…］ 用户或组 文件
chown -R lisi /d1/d2/file //R表示递归包括文件以及目录都修改所有者 不使用R则只是文件或目录file下所有子文件夹权限修改 修改文件所有组 chgrp
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e689de828459f272b8690295116116be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fadf600589c6aef8ce3f1f508cbdae6f/" rel="bookmark">
			retinex图像增强算法ssr-msr-msrcr详解及其opencv源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：https://blog.csdn.net/ajianyingxiaoqinghan/article/details/71435098
Retinex图像增强算法(SSR, MSR, MSRCR)详解及其OpenCV源码 Retinex是一种常用的建立在科学实验和科学分析基础上的图像增强方法，它是Edwin.H.Land于1963年提出的。就跟Matlab是由Matrix和Laboratory合成的一样，Retinex也是由两个单词合成的一个词语，他们分别是retina 和cortex，即：视网膜和皮层。Land的retinex模式是建立在以下三个假设之上的：
真实世界是无颜色的，我们所感知的颜色是光与物质的相互作用的结果。我们见到的水是无色的，但是水膜—肥皂膜却是显现五彩缤纷，那是薄膜表面光干涉的结果。每一颜色区域由给定波长的红、绿、蓝三原色构成的；三原色决定了每个单位区域的颜色。 Retinex理论的基础理论是物体的颜色是由物体对长波（红色）、中波（绿色）、短波（蓝色）光线的反射能力来决定的，而不是由反射光强度的绝对值来决定的，物体的色彩不受光照非均匀性的影响，具有一致性，即retinex是以色感一致性（颜色恒常性）为基础的。不同于传统的线性、非线性的只能增强图像某一类特征的方法，Retinex可以在动态范围压缩、边缘增强和颜色恒常三个方面达到平衡，因此可以对各种不同类型的图像进行自适应的增强。
40多年来，研究人员模仿人类视觉系统发展了Retinex算法，从单尺度Retinex算法，改进成多尺度加权平均的MSR算法，再发展成彩色恢复多尺度MSRCR算法。笔者在本文中，从原理阐述算法的流程，并提供源码地址。
参考链接： http://blog.csdn.net/carson2005/article/details/9502053 http://www.cnblogs.com/Imageshop/archive/2013/04/17/3026881.html 参考论文： 《一种结合直方图均衡化和MSRCR的图像增强新算法》——李锦 等人
一. 单尺度SSR(Single Scale Retinex) 1. 原理 一幅给定的图像S(x,y)可以分解为两个不同的图像：反射图像R(x,y)和入射图像（也有人称之为亮度图像）L(x,y)，其原理图如下所示： 如上图所示，图像可以看做是入射图像和反射图像构成，入射光照射在反射物体上，通过反射物体的反射，形成反射光进入人眼。最后形成的图像可以如下公式表示： r(x,y)=logR(x,y)=logS(x,y)L(x,y)r(x,y)=logR(x,y)=logS(x,y)L(x,y)
其中，R(x, y)表示了物体的反射性质，即图像内在属性，我们应该最大程度的保留；而L(x, y)表示入射光图像，决定了图像像素能达到的动态范围，我们应该尽量去除。 一般，我们把照射图像假设估计为空间平滑图像，原始图像为S(x, y)，反射图像为R(x, y)，亮度图像为L(x, y)，可以得出上面的公式(1)，以及下面的公式：
r(x,y)=logR(x,y)=logS(x,y)L(x,y)r(x,y)=logR(x,y)=logS(x,y)L(x,y) …………(2)
r(x,y)=logS(x,y)−log[F(x,y)⨂S(x,y)]r(x,y)=log⁡S(x,y)−log⁡[F(x,y)⨂S(x,y)] ………….(3)
这里，r(x, y)是输出图像，式(3)中后面中括号里的运算是卷积运算。F(x, y)是中心环绕函数，表示为：
F(x,y)=λe−(x2+y2)c2F(x,y)=λe−(x2+y2)c2 ………….(4)
式(4)中的C是高斯环绕尺度，λ是一个尺度，它的取值必须满足下式：
∫∫F(x,y)dxdy=1∫∫F(x,y)dxdy=1 ………….(5)
上面的式中可以看出，SSR算法中的卷积是对入射图像的计算，其物理意义是通过计算像素点与周围区域在加权平均的作用下，估计图像中照度的变化，并将L(x,y)L(x,y)属性。
2. 算法的实现流程 单尺度Retinex算法SSR的实现流程可以概括如下：
读原图S(x, y)： 若原图为灰度图：将图像各像素的灰度值由整数型(int)转换为浮点数(float)，并转换到对数域；若原图为彩色图：将颜色分通道处理，每个分量像素值由整数型(int)转换为浮点数(float)，并转换到对数域；输入高斯环绕尺度C，把积分运算离散化，转为求和运算，通过上式(4)(5)确定λ的值；由式(3)得r(x, y)； 若原图是灰度图，则只有一个r(x, y)；若原图为彩色图，则每个通道都有一个对应的r(x, y)；将r(x, y)从对数域转换到实数域，得到输出图像R(x, y)；此时的R(x, y)值的范围并不是0–255，所以还需要进行线性拉伸并转换成相应的格式输出显示。 前面的公式中，中心环绕函数F(x, y)用的是低通函数，这样能够在算法中估计出入射图像对应原始图像的低频部分。从原始图像中除去低频照射部分，就会留下原始图像所对应的高频分量。高频分量很有价值，因为在人类的视觉系统中，人眼对边缘部分的高频信息相当敏感，所以SSR算法可以较好的增强图像中的边缘信息。 由于SSR算法中所选用的高斯函数特点，对于动态范围大幅度压缩和对比度增强两个指标，增强后的图像不能同时保证。但是为了平衡两种增强效果，就必须选择一个较为恰当的高斯尺度常量C。C值一般取值在80–100之间。
3. OpenCV源码 见源码附录的Retenix()函数。
二. 多尺度MSR(Multi-Scale Retinex) 1. 原理 MSR是在SSR基础上发展来的，优点是可以同时保持图像高保真度与对图像的动态范围进行压缩的同时，MSR也可实现色彩增强、颜色恒常性、局部动态范围压缩、全局动态范围压缩，也可以用于X光图像增强。 MSR计算公式如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fadf600589c6aef8ce3f1f508cbdae6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3e8469f48441cc0e9256ef0e584b1bc/" rel="bookmark">
			种群竞争模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		物种与物种间竞争自然选择的过程
销售情况可以用此模型，比如苹果三星竞争
S是越小越好，表示别的物种来抢你的东西抢不赢你
得到的第一个图是分别的图，第二个图是一个物种随另一个物种变化的图
更改fun函数里面的初值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dc8ee858610f306a41d3c4a4fe955c2/" rel="bookmark">
			用WSL（Win10linux子系统）构建Golang的Windows和linux并存开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面说完了如何在Ubuntu上部署Go语言开发环境，以及IPFS调试环境，但还是有很多人用的Windows系统，毕竟很多软件在Linux上并没有提供，日常使用会有点不方便。
一种折衷的方法是在Window上使用虚拟机来运行Linux环境，或者干脆就使用Windows版本的Golang和IPFS，但是虚拟机占用资源很多，而纯Windows环境又少了很多*nix系的小工具。
我这里提供一种方法，通过Win10提供的WSL来构建并存开发环境。
一、安装Linux子系统 本段参考了https://www.jianshu.com/p/bc3...
首先进入控制面板在启用或关闭Windows功能里启用适用linux的Windows子系统
然后在应用商店搜索Ubuntu18.04点击安装，启动后输入用户名和账户密码，Ubuntu子系统就装好了。
注：这过程出现问题可以去设置里打开开发者模式试试。
然后更换软件源为国内的源，此处举例为阿里云的镜像
sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak //备份以前的文件免得出问题 sudo vim /etc/apt/sources.list 删掉里面所有内容，将下面的内容复制进去 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dc8ee858610f306a41d3c4a4fe955c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ec4b130cb81f1891ff8f556b655c66f/" rel="bookmark">
			jsp基本语法及内置对象的简单介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSP全称Java Server Pages，是一种动态网页开发技术。
jsp生命周期：
1.编译阶段：
当浏览器请求JSP页面时，JSP引擎会首先去检查是否需要编译这个文件。如果这个文件没有被编译过，或者在上次编译后被更改过，则编译这个JSP文件。编译jsp文件的过程是把它转换成servlet进行编译的
2.初始化阶段：
执行服务前调用 jspInit()方法初始化，可以复写以实现自己想要的功能。
3.执行阶段：
完成初始化后，JSP引擎将会调用 _jspService()方法。这一阶段描述了JSP生命周期中一切与请求相关的交互行为，直到被销毁。
4.销毁阶段：
调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例
jsp基本语法：
1.注释：
第一种：&lt;%-- 注释 --%&gt; JSP注释，注释内容不会被发送至浏览器甚至不会被编译
第二种：&lt; !-- 注释 --&gt; HTML注释，通过浏览器查看网页源代码时可以看见注释内容
2.声明：
在jsp中声明格式：&lt;%! 声明的变量、函数等 %&gt;
例如：
&lt;%! int a = 0; public void add(int a,int b){} %&gt; 3.表达式：
&lt;%=expression%&gt;
今天是：&lt;%=(new java.util.Date()).toLocaleString()%&gt; 4.程序段：
jsp程序段是包含在&lt;%%&gt;之间的
形如&lt;%程序段%&gt;
5.jsp指令：
&amp;&amp; page指令
置于最顶端，例如：
&lt;%@ page language="java" import="java.util.*" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt; language 默认是java
import 用于导入相应的包，当需要导入多个包时，中间应用逗号隔开
示例：import="java.io.*,java.util.*"
session=”true(false)”，用于指明session对象是否可用默认为true
buffer=”none|8kb|sizekb”，用于指定输出缓冲。该值不为none时，意为需要输出缓冲，此时服务器不会直接输出内容到浏览器，而是等待缓存满或者脚本执行完毕才会输出显示。该设置默认值为8kb。
antoflush=”true|false”，指明缓存是否自动清除。默认为true，若手动设置为false，缓存溢出会抛出异常。
errorPage=”URL”，用于指定当前页面产生异常后，重定向的页面。
isErrorPage=”true|false”，用于指定当前页面可否用作其他页面的错误处理页面。默认值为false。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ec4b130cb81f1891ff8f556b655c66f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7912499f5a02fac75ce58b3559da3bb/" rel="bookmark">
			Windows无法安装所需的文件，请确保安装所需的文件可用，并重新启动安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		光盘安装时，选DVD模式，改成选USB模式就好使了，好奇怪。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1930fef0593f180ac35f307cc6a5a7ea/" rel="bookmark">
			byte[]和InputStream的相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：byte[]转换为InputStream InputStream sbs = new ByteArrayInputStream(byte[] buf); 2：InputStream转换为InputStreambyte[] ByteArrayOutputStream swapStream = new ByteArrayOutputStream(); byte[] buff = new byte[100]; //buff用于存放循环读取的临时数据 int rc = 0; while ((rc = inStream.read(buff, 0, 100)) &gt; 0) { swapStream.write(buff, 0, rc); } byte[] in_b = swapStream.toByteArray(); //in_b为转换之后的结果 import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; public class ByteToInputStream { public static final InputStream byte2Input(byte[] buf) { return new ByteArrayInputStream(buf); } public static final byte[] input2byte(InputStream inStream) throws IOException { ByteArrayOutputStream swapStream = new ByteArrayOutputStream(); byte[] buff = new byte[100]; int rc = 0; while ((rc = inStream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1930fef0593f180ac35f307cc6a5a7ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61cf65004fe85f04a00b1cd8a3769424/" rel="bookmark">
			Android中的sharedUserId
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、manifest标签包含内容 &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" // 命名空间 android:versionCode="1" // 版本号，会被gradle中覆盖，不推荐 android:versionName="1.0" // 版本名称，同上 android:sharedUserId="net.loosash.share" // sharedUserId 本文详细介绍 android:sharedUserLabel="@string/app_name" // 为用户提供一个可读的标签，value仅能使用资源id android:installLocation="internalOnly" // 安装位置 默认internalOnly：只能安装在内部存储中；preferExternal：安装在外部存储中，当不可用时安装在内部存储中，安装后用户可以通过系统设置移动安装位置；auto：用户可以选择安装在内部存储还是外部存储中。 package="net.loosash.learnmanifest"&gt; ...... &lt;/manifest&gt; 复制代码 二、sharedUserId注意事项 sharedUserId的value必须包含一个"."，否则在打包安装到手机的时候会报错。某些功能的实现需要对相同shareUserId的apk使用相同的签名。 三、对sharedUserId的理解 我们都知道android的每一个应用都运行在单独的虚拟机上，以便提高系统的稳定性，每个应用进程都是由单独的Linux系统用户所创建，相同的sharedUserId的应用归属的linux相同的用户，资源共享则有很多的的便利可以利用。 我做了一个测试，使用adb shell top命令查看进程。 附带adb shell top命令解析
&gt;adb shell top -h Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [-t ] [ -h ] -m num Maximum number of processes to display.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61cf65004fe85f04a00b1cd8a3769424/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59fde5d83d17e4263ec925e74efc0c2c/" rel="bookmark">
			k级台阶问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给出台阶数n和能走的步数k（一次可以走1、2、3......k步），求到达n层有几种走法。。
#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;queue&gt; #define INF 0x3f3f3f3f using namespace std; int f[100100]; int main() { int n, k; cin&gt;&gt;n&gt;&gt;k; f[0] = 1;//第0层有1种走法 for (int i = 1;i&lt;=n;i++){ for (int j = 1;j&lt;=k&amp;&amp;(i-j)&gt;=0;j++){ f[i] += f[i - j];//f[i]值为走到第i层有几种方法，而第i+1层的方法数量是从f[i-k]到f[i]的值之和 f[i] %= 100003; } } cout &lt;&lt; f[n]; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/272e02ddc163802794d53e0fcee0dcac/" rel="bookmark">
			Keil5的仿真调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Keil5基本的仿真调试操作：
首先点击魔法棒
然后输入你板子上所用的晶振，然后进入debug：
然后选择 Use Simulator，然后点击OK：
然后点击调试按钮：
然后就会出现调试页面：
我这里是已经把汇编窗口给挪到右侧了，你第一次打开可能是在屏幕的上侧，你只需要用鼠标点住你需要移动的窗口，然后拖到你想让他去的位置就行了。
仿真调试页面最左边显示的是单片机内部的一些寄存器的当前值和系统信息，右边是keil将C语言转换成汇编的代码，中间就是我们编写的C程序了。
在C语言和汇编语言窗口都有一个黄色的箭头，这个箭头代表的就是程序当前运行的位置。
在调试页面上方的工具栏中，有几个按钮：
第一个标有RST字样的是复位，单击之后，程序就会跑到最开始的位置运行；紧接着第二个按钮是全速运行，单击之后程序就会全速跑起来；再然后第三个按钮是停止按钮，当程序全速运行起来时候，单击停止按钮程序就会立即停止，可以观察程序运行到哪里去了。
单击复位之后，可以看到C语言程序的窗口左侧有灰色或者保持着原来的颜色，其中有灰色的地方是我们可以设置断点的地方，至于为啥有些地方不能设置断点呢，主要是因为keil具有程序优化的功能，如果我们想在任何地方都可以设置断点的话，我们需要更改工程选项里的优化等级，把等级设置为0即可，即高速keil不要对程序进行优化。其他的按钮就是关于子函数或者循环是否进入的操作了，具体自己可以试试看。
在最左侧的框内，sec显示的就是单片机运行了多长时间：
通过设置断点和查看sec可以计算出软件延时的大概时间。
如果我们想查看某一个变量或者寄存器的值的话，我们可以点击view:
这样在下面的窗口就会出现watch页面，在里面的name选项里面输入你想要查看的变量的名字或者寄存器的名字，随着程序的运行，我们就可以实时看到他们的值的变化：
如果想结合单片机进行在线实时调试的话，也可以，但是首先你所用的单片机要支持在线调试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4cd0535393d8b8a7deb8f1ae0b79af3/" rel="bookmark">
			04748JAVA语言程序设计实践考试复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		考完试了，复习内容全部作废。
考题是两道题，一个半小时时间特别紧张
一进考场会发一张纸，上面有考题，怎么保存什么的不重要，因为还得删。考完试之后老师会过来让你运行一遍看一下效果。这时候就是最重要的时候了，你要发挥一小段演讲，现场评分，评完删除项目走人就结束了。
能运行是最重要的
能运行是最重要的
能运行是最重要的
其次是能完美的正确运行。
写的再多最后测试没完成，不能运行一点用都没有，切记切记。
我的感受
1.这个世界没有什么是绝对的，比如考题
2.鼠标巨难用，用的我手抖
重点是
无论复习的怎么样考试题目才是最重要的，考前临时背除非是原题不然就特别不明智的，尽量在考试之前清空一下脑袋迎接试题
至于考题答案，太简单了，我就不再写一遍了。
第一题类似源码：
package KT; import java.awt.Button; import java.awt.FlowLayout; import java.awt.Frame; import java.awt.TextField; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowEvent; import java.awt.event.WindowListener; //6.Frame的使用，比如设置窗口大小，可见，创建并添加文本与按钮 public class FrameTest { public static void main(String[] args) { Frame frame = new Frame(); TextField textField = new TextField(); Button button = new Button("确定"); frame.setBounds(300,500,400,500); frame.setLayout(new FlowLayout()); frame.add(button); frame.add(textField); frame.addWindowListener(new WindowListener() { @Override public void windowOpened(WindowEvent e) { // TODO Auto-generated method stub } @Override public void windowIconified(WindowEvent e) { // TODO Auto-generated method stub } @Override public void windowDeiconified(WindowEvent e) { // TODO Auto-generated method stub } @Override public void windowDeactivated(WindowEvent e) { // TODO Auto-generated method stub } @Override public void windowClosing(WindowEvent e) { // TODO Auto-generated method stub System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4cd0535393d8b8a7deb8f1ae0b79af3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1016d56ede8f56a5f6a04d1379e6a9f9/" rel="bookmark">
			int &amp; 到底是个啥？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感觉自己很废，很懒。不懂得东西模棱两可就过去了，废物，垃圾。现在的知识盲区大了吧！大家敬请鄙视我吧！ 故事是这样的： #include&lt;stdio.h&gt; void change1 (int *a,int *b) { int c; c=*a; *a=*b; *b=c; } void change2 (int &amp;m,int &amp;n) { int c; c=m; m=n; n=c; } int main() { int a=1;int m=1; int b=2;int n=2; change1(&amp;a,&amp;b); printf("-a-%d--\n",a); printf("-b-%d--\n\n\n",b); change2(&amp;m,&amp;n); //错误，错误，错误 printf("-m-%d--\n",m); printf("-n-%d--\n\n\n",n); return 0; } 哎，chang2里面的形参不是需要两个地址吗？ &amp;m,&amp;n，不是取地址吗？对啊！我传入两个地址，没毛病啊！这是当初学C语言心中的疑惑，但是我是个废柴！哦，书上说不用写&amp;，直接写m，n就行了。好了我记住了！but！but！but！废柴是不知道原理是什么的，只知道这样子去用。好了，今天遇到问题报错了吧！废柴开始紧张了！ 在这里不得不吐槽教科书，垃圾，就写一句“注意int &amp;不是取地址，是引用，详情自主百度”不就交代的很清楚了吗？害我这个废柴找了半天答案。垃圾教科书。 这里引用“落辰衰”大佬的解释：
1、int;
int是C++关键字，表示整型，其大小是32位有符号整型，表示的范围是-2,147,483,648 到 2,147,483,647；在声明和定义变量时使用，它表示的意思是所声明或所定义的变量为整型变量。
如果其用于函数参数时，其传递方向为值传递，即只能将实参的值传递给形参，而不能将
形参的值传递给实参。
例如：通过这种方式去进行交换两个数是无法达到目的的。
例子1：
#include&lt;iostream&gt;
using namespace std; voidswap1(inta,intb)
{ inttmp; tmp = a; a = b; b = tmp; } int main(){ inta = 1; intb = 2; swap1(a, b); cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1016d56ede8f56a5f6a04d1379e6a9f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/019bb866c12082c55a719bc84c742fae/" rel="bookmark">
			MarkDown中的表格在jekyll的pages博客中不能正常显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文转自https://ask.csdn.net/questions/259502，所有权力归原作者所有。
求大神支招，万分感谢！！！，如何可以经过jekyll编译好后显示正常的表格？
这是用markdown写的文档
|名称|是否必须|默认值|说明|例子| |-|-|-|-|-| |appl.host|是|无|当前应用发布的IP地址或机器名|appl.host=192.168.10.134| |appl.port|是|无|当前应用发布的远程服务的端口 不能去ecas项目config配置文件中appl.port重复|appl.port=13884| |ecas.uri|是|无|远程调用ECAS的地址，它可以配置集群。格式ecas项目config配置文件中appl.host:appl.port，如果有多个用","分隔|ecas.uri=192.168.10.134:13883| |passConfig|否|classpath*:conf/ecas/client/pass.config|默认的文件在ecas-5.0.jar里，如果有需要修改的，需要把这个jar包里的这个文件删除，然后配置你自己的文件路径|passConfig=classpath*:conf/cim/pass.config| |constantConfig|否|classpath*:conf/properties/config.properties|虽然这个值不是必须且有默认值，但必须在对应的目录下有这个文件，并且把ECAS相关配置参数写到这个文件里，当然你可以把配置文件写到自己的文件中，然后该值指向该文件|constantConfig=classpath*:conf/properties/test.properties| |appCode|是|无|当前应用的应用编码|appCode=cim| |userAdapterImplClass|是|无|用户session设置的适配实现类，ECAS5中默认为``com.erayt.ecas5.adapter.impl.DefaultEcasUserAdapter``，ECAS4乔接的为``com.erayt.ecas.adapter.impl.OldEcasUserAdapter``，如果要有特殊的用户实现的请继承``com.erayt.ecas5.adapter.impl.AbstractUserAdapter``类|userAdapterImplClass=com.erayt.ecas5.adapter.impl.DefaultEcasUserAdapter| |ecasLoginUrl|是|无|ecas访问根路径|ecasLoginUrl=http://192.168.30.51:8090/ecas| |applUrl|是|无|当前应用问的协议+地址+端口|applUrl=http://www.xfunds.com:82| 在markdown编辑器中可是正常显示表格；但是用jekyll编译后生成博客，然而表格不能在博客正常显示，不能显示边框，而且排版不好看？
显示成如下效果：
在markdown编辑器中显示还是可以的：
花了老半天，弄到现在，总算解决了表格的问题；
刚开始到jekyll官网去，看到了有个Table of Content Generator: 生成包含表格（ TOC ）的 HTML 代码的插件，结果安装步骤安装，出错了，网上查遍没多少热用
，查不到答案；结果被坑了一个下午；最后转换思想，直接在_layout文件中的header.html中写上下面的代码,就搞定了：
&lt;style&gt; table{ border-left:1px solid #000000;border-top:1px solid #000000; width: 100%; word-wrap:break-word; word-break:break-all; } table th{ text-align:center; } table th,td{ border-right:1px solid #000000;border-bottom:1px solid #000000; } &lt;/style&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80adee78a511fef7e0a704a5a7d8585f/" rel="bookmark">
			自动驾驶讲座
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		核心问题 小目标，强遮挡，高动态。
三维场景图像认知与多模态学习。
认知是有意识参与的情况下达到的认识。
三维图像认知 数据和主题双向驱动认知学习
心理认知+机器学习
http://3dimage.ee.tsinghua.edu.cn
图像认知心理学：心理特征提取
显著性物体检测：予以注意认知模型
不见与结构认知模型：抵抗遮挡能力
3D场景物体识别：适应复杂环境
仿真与决策：智能无人视觉导航
三维场景图像认知与多模态学习 KITTI：三维场景数据集
如何提升似物性预测？
单目估计双目计算。？？？
三个经典算法：
受脑启发的无人车场景理解 场景理解、自主运动
相机与激光雷达协同
结构化描述:度量、交通信号。交通语义
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/405dd75608ca3a511c00ebf9040eaab3/" rel="bookmark">
			C&#43;&#43; 实现序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文大概讲下用C++实现序列化
本文的序列化：简单的讲是将C++里的对象（此处是广义上的对象，内置类型或者用户自定义类型）数据变成char*，即单个字节的数据，这样方便传输等
本文要求有一点C/C++基础
涉及到的知识点有C++中的函数重载，操作符重写，allcotor，左值和右值，继承，模板等
序列化： 数据对象 =====&gt; 字节数组
反序列化： 字节数组 =====&gt; 数据对象
首先，我们使用一个类去做这些工作，DataStream中存放数据，用来序列化和反序列化数据，其中这个类得有个字节数组，然后会有一个记录这个数组相关信息的对象。为了方便对这个字节数组的操作，我们自己定义个类CharVec。我们把记录这个数组的相关信息单独定义一个类DataHeader，作为数组的开头的数据，方便解析。
然后我们先看CharVec（参照C++ primer），代码如下：
// CharVec.h #ifndef CHARVEC_H #define CHARVEC_H #include &lt;memory&gt; class CharVec { public: CharVec(); CharVec(const CharVec &amp;vec); CharVec &amp;operator =(const CharVec &amp;vec); ~CharVec(); bool operator ==(const CharVec &amp;vec) const; size_t size() const; size_t capacity() const; char *begin() const; char *end() const; void push(const char *data, int len); void push(const std::string &amp;str); void push(char c); void removeFromFront(int len); void clear(); private: void checkAndAlloc(); void reallocate(); void free(); std::pair&lt;char *, char *&gt; allocAndCopy(char *begin, char *end); private: char *m_Elements; // 首元素 char *m_FirstFree; // 最后一个实际元素之后的位置 char *m_Cap; // 分配内存末尾之后的位置 std::allocator&lt;char&gt; m_Allocator; // 内存分配器 }; #endif // CHARVEC_H 我们简单的实现了一个vector&lt;char&gt;,这里也可以定义成模板类，然后就是一个vector了 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/405dd75608ca3a511c00ebf9040eaab3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3dca68f8e588d3cb65c032dd174ad56/" rel="bookmark">
			c语言 malloc 函数用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数声明： Tips：　void的字面意思是“无类型”，void *则为“无类型指针”，void *可以指向任何类型的数据。
malloc 函数申请空间需要使用free释放。
void* malloc(int size) malloc向系统申请size字节的内存空间，返回值类型为void *。
使用说明： int *p;
p = (int *)malloc( sizeof(int) );
因为malloc返回的是不确定类型的指针，所以返回之前必须经过类型强制转换，否则编译报错，如：“ 不能将void*赋值给int*变量 ”。malloc只管分配内存，并不会初始化，其内存空间中的值可能是随机的。如果分配的这块空间原来没有被使用过，那么其中每个值都可能是0。相反，空间里面可能遗留各种各样的值。实参为需要分配的字节大小，如果malloc(1)，那么系统只分配了1个字节的内存空间，这时注意，如果在这块空间中存放一个int值，由于int类型占4个字节，那么还有3个字节未分配空间，系统就会在已经分配的那1个字节的基础上，依次向后分配3个字节空间，而这就占有了“别人”的3个字节空间，“别人”原有的值就被清空了。分配的空间不再使用时，要用free函数释放这块内存空间。 for example:
int *p; p = (int *)malloc( sizeof(int) * 100 ); malloc函数工作机制： malloc函数被调用时，它会沿空闲链表寻找一个可以满足需求的内存块，然后把所需大小的内存块分配给用户，剩下的返回到链表上。free函数被调用时，它将释放的内存块连接到空闲链表上。到最后，空闲链表会被分成很多小的内存片段，当用户申请一块较大的内存空间时，空闲链表上可能没有满足需求的内存块了，这时，malloc函数请求延时，并将空闲链表内的小内存片段整理成大的内存块，最终返回。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76cd337339aaf84187505e593bc69cc8/" rel="bookmark">
			mt6580_5.1驱动移植
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//memory 修改
1. device/mediatek/build/build/tools/emigen/MT6580/MemoryDeviceList_MT6580.xls
2. bootable/bootloader/preloader/tools/emigen/MT6580/MemoryDeviceList_MT6580.xls
3. bootable/bootloader/preloader/custom/keytak6580_we_l/inc/custom_MemoryDevice.h
//lcd 调试 ? bootable/bootloader/lk/dev/lcm/ili9881c_z1_dsi_vdo
M bootable/bootloader/lk/dev/lcm/mt65xx_lcm_list.c
M bootable/bootloader/lk/project/ckt6580_we_l.mk
M kernel-3.10/arch/arm/configs/ckt6580_we_l_debug_defconfig
M kernel-3.10/arch/arm/configs/ckt6580_we_l_defconfig
? kernel-3.10/drivers/misc/mediatek/lcm/ili9881c_z1_dsi_vdo
M kernel-3.10/drivers/misc/mediatek/lcm/mt65xx_lcm_list.c
M kernel-3.10/drivers/misc/mediatek/mach/mt6580/ckt6580_we_l/lcm/mt65xx_lcm_list.c
//修改内置功放有声音
1. M:\mt6580a\kernel-3.10\arch\arm\configs\ckt6580_we_l_debug_defconfig
2. M:\mt6580a\kernel-3.10\arch\arm\configs\ckt6580_we_l_defconfig
CONFIG_MTK_SPEAKER=y 3../vendor/mediatek/proprietary/custom/ckt6580_we_l/hal/audioflinger/audio/audio_custom_exp.h
#define USING_CLASSD_AMP // define using which flag
//修改外部功放有声音
1. M:\mt6580a\kernel-3.10\arch\arm\configs\ckt6580_we_l_debug_defconfig
2. M:\mt6580a\kernel-3.10\arch\arm\configs\ckt6580_we_l_defconfig
CONFIG_MT_SND_SOC_V3=y # CONFIG_MTK_SPEAKER is not set
3../vendor/mediatek/proprietary/custom/ckt6580_we_l/hal/audioflinger/audio/audio_custom_exp.h
#define USING_CLASSD_AMP // define using which flag #define USING_EXTAMP_HP // define using which flag
#define HAVING_RCV_SPK_SWITCH //耳机相关的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76cd337339aaf84187505e593bc69cc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77bb513c2afe9f6d9f9299d223777e6e/" rel="bookmark">
			Python学生管理系统(web网页版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本项目是使用Python的Django的web框架搭建的，是一个完整的学生管理系统，功能包括基本的增删改查
项目演示图：
首页展示数据的页面（index.html） 添加学生的页面（add.html） 搜索学生页面（根据姓名或者性别） 修改学生页面（update.html） 删除学生页面（delete.html） 博文不方便记录项目，所以完整项目可以从 下载地址 下载，里面包括完整的项目源码和演示视频和数据库表的建设。
说在最后的话：编写实属不易，若喜欢或者对你有帮助记得点赞+关注或者收藏哦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b53c3ba1a2eb429d7f72e56072b72c41/" rel="bookmark">
			Word处理代码文本之删除注释与空行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、需求：
现从编程软件中粘贴了一堆代码至word文档中，内容有百页之多，如下图：
现在想要对代码内容进行缩减，需要进行以下操作：
（1）删掉注释。
（2）删除空行。
二、实现思路：
注意到代码注释的文本的特点是开头为“//”，考虑到可以使用通配符来进行文本描述从而实现替换。
而空行的特点是由连续的两个换行符组成，可以通过将连续的两个换行符替换为单个换行符实现空行的删除。
三、实现步骤：
1、删除注释：
（1）使用ctrl+a快捷键全选内容，然后通过ctrl+h快捷键弹出替换设置界面：
（2）点击“更多”，勾选使用“通配符”
（3）在查找内容中输入：//*^13
在替换为中输入：^13
（4）点击“全部替换”（最好多点击几次），即可发现，所有的注释行都变为了空行，如下图：、
（5）若是region形式的注释，可参考：
( #region*^13) 替换成 ^13
( #endregion^13) 替换成 ^13
2、删除空行：
需要分两步进行，前段部分操作与删除注释相同，全选并弹出替换窗口，勾选使用通配符，使用以下两步替换：
（1）^13[ ]@^13 替换成 ^13^13
（2）^13^13 替换成 ^13
每一步要多点击几次“全部替换”，即可实现空行的删除，如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55e4b2e8f420c0f47dbf6e2234633041/" rel="bookmark">
			Android Studio开启虚拟机报错！emulator: ERROR: x86 emulation currently requires hardware acceleration!解决办法梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.如果确认电脑没有开启Intel Virtualization Technology，那么先进BIOS里开启，然后再进行如下步骤，如果不确认，进入第二步。
2.到Android SDK的安装路径下，默认是
C:\Users\你的用户名\AppData\Local\Android\Sdk\extras\intel\Hardware_Accelerated_Execution_Manager，实际操作根据自己设定的目录来，找到Android\SDK\extras\intel\Hardware_Accelerated_Execution_Manager文件夹，运行目录下的intelhaxm-android.exe进行安装，如果安装成功那么问题解决；如果安装失败，那么返回第一步。
3.如果Android SDK\extras安装目录下没有intel文件夹，那么说明没有下载，此时，进入SDK manager，切换到SDK Tools标签，找到intel x86 Emulator Accelerator （HAXM installer），选中，进行下载，必要时科学上网。
4.下载后Android Studio一般会自动安装，如果不自动安装，就手动安装。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fb594ba69f1c50ad1c911bac8ba83e1/" rel="bookmark">
			Android笔记之View截图(View生成bitmap)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零 一、（Bitmap）view？ View截图，简单来说就是把view转换成bitmap，这里有两种方法。
1.1 drawingcache 我们只说怎么用，是什么和为什么有兴趣去学习一个。
private static Bitmap viewToBitmap(View v) { v.setDrawingCacheEnabled(true); v.buildDrawingCache(); Bitmap screenshot = v.getDrawingCache(); v.setDrawingCacheEnabled(false); return screenshot; } 复制代码 简单来说就是获取view的DrawingCache，记得用完之后关闭(setDrawingCacheEnabled(false))。不过注意这种方法要求view已经经过layout在界面上显示了。
1.2 canvas绘制 这种思路就直接了，先看代码：
private static Bitmap viewToBitmap(View v) { Bitmap screenshot; screenshot = Bitmap.createBitmap(v.getWidth(), v.getHeight(), Bitmap.Config.ARGB_4444); Canvas canvas = new Canvas(screenshot); v.draw(canvas); return screenshot; } 复制代码 创建一个和view等宽高的bitmap，ARGB_4444指的是bitmap的像素类型。
ARGB_8888：四个通道都是8位，每个像素占用4个字节，图片质量是最高的，但是占用的内存也是最大的；
ARGB_4444：四个通道都是4位，每个像素占用2个字节，图片的失真比较严重；
RGB_565：没有A通道，每个像素占用2个字节，图片失真小，但是没有透明度；
ALPHA_8：只有A通道，每个像素占用1个字节大大小，只有透明度，没有颜色值。
之后就是创建canvas，通过View.draw()方法绘制了。
//作为Android开发的初学者，如果我有错误的地方或者不足的话欢迎大家指正。希望与大家一同进步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b86a13d7b7abcadfeef4d3e25dae46/" rel="bookmark">
			SATA、mSATA 、PCIe和M.2——SSD硬盘的接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		犹记得当年Windows 7系统体验指数中，那5.9分磁盘分数，在其余四项的7.9分面前，似乎已经告诉我们机械硬盘注定被时代淘汰。势如破竹的SSD固态硬盘，彻底打破了温彻斯特结构的机械硬盘多年来在电脑硬件领域的统治。SSD数倍于HDD机械硬盘的传输性能，让普通用户和发烧玩家的体验均成倍提升。
在这场存储革命中，为了实现更快的速度、更多的使用环境、更好的体验，SSD的接口也在不断进化革新，像主流的SSD就有SATA接口、M.2接口、PCIe接口和mSATA接口等。这四种常见的接口有什么不同？又适合什么样平台使用呢？下面我们来一一进行讲解。
SATA3.0接口：
作为目前应用最多的硬盘接口，SATA 3.0接口最大的优势就是成熟。普通2.5英寸SSD以及HDD硬盘都使用这种接口，理论传输带宽6Gbps，虽然比起新接口的10Gbps及32Gbps带宽有一定的差距，但普通2.5英寸SSD可以满足大多数用户的日常应用需求，500MB/s左右的读写速度也够用。而对于100MB/s左右读写速度HDD机械硬盘上，6Gbps带宽还远远谈不上瓶颈，只能埋怨HDD硬盘发展太慢，存储速度一直没有质变。
虽然SATA 3.0接口规格已经推出有一段时间，但“廉颇岁老，尚善饭否”。大多数用户对SSD性能的要求谈不上极端苛刻，而且还要考虑选购时的性价比因素，因此SATA 3.0接口在很长一段时间内都将是主流大众的选择。
PCIe接口：
在传统SATA硬盘中，当我们进行数据操作时，数据会先从硬盘读取到内存，再将数据提取至CPU内部进行计算，计算后再反馈给内存，最后写入至硬盘中；而PCIe接口就不一样了，数据直接通过总线与CPU直连，省去了内存调用硬盘的过程，传输效率与速度都成倍提升。简单的说，我们可以把两种通道理解成两辆相同的汽车，PCIe通道的汽车就像是在高速上行驶，而SATA通道的汽车就像是在崎岖山路上行驶。很显然，PCIe SSD的传输速度会远大于SATA SSD。
HyperX Predator PCIe SSD是众多PCIe接口SSD中的佼佼者，它采用PCI-E 2.0x4接口，半高式设计，主控为Marvell 88SS9293，读取速度和写入速度分别达到了1400MB/s和1000MB/s，是HyperX高端固态硬盘产品中速度最快的产品，读写速度也远超SATA接口的SSD产品。
虽然PCIe SSD有诸多好处，但也不是每个人都适合。PCIe SSD由于闪存颗粒和主控品质极高，总体成本也相对较高，相比传统SATA接口固态硬盘的售价要贵一些。另外，由于PCIe会占用总线通道，入门以及中端平台CPU通道数较少，也不太适合使用PCIe SSD。只有配合Z170、X99这样顶级平台，才可以完全发挥PCIe SSD的性能。总的来说，如果你是在组装专业工作室用机，或是骨灰发烧级玩家，亦或是一个不差钱的土豪，那么HyperX Predator PCIe SSD是决对正确的选择！
M.2接口
M.2接口，是Intel推出的一种替代mSATA新的接口规范。其实，对于桌面台式机用户来讲，SATA接口已经足以满足大部分用户的需求了，不过考虑到超极本用户的存储需求，Intel才急切的推出了这种新的接口标准。虽然，我们在华硕、技嘉、微星等发布的新的9系列主板上都看到了这种新的M.2接口，现已普及。
与mSATA相比，M.2主要有两个方面的优势。第一是速度方面的优势。M.2接口有两种类型：Socket 2（B key——ngff）和Socket 3（M key——nvme），其中Socket2支持SATA、PCI-E X2接口，而如果采用PCI-E ×2接口标准，最大的读取速度可以达到700MB/s，写入也能达到550MB/s。而其中的Socket 3可支持PCI-E ×4接口，理论带宽可达4GB/s。
第二个是体积方面的优势。虽然，mSATA的固态硬盘体积已经足够小了，但相比M.2接口的固态硬盘，mSATA仍然没有任何优势可言。M.2标准的SSD同mSATA一样可以进行单面NAND闪存颗粒的布置，也可以进行双面布置，其中单面布置的总厚度仅有2.75mm，而双面布置的厚度也仅为3.85mm。而mSATA在体积上的劣势就明显的多，51mm×30mm的尺寸让mSATA在面积上不占优势，而4.85mm的单面布置厚度跟M.2比起来也显得厚了太多。另外，即使在大小相同的情况下，M.2也可以提供更高的存储容量
M.2接口，最初叫做NGFF（Next Generation Form Factor），宽度22mm，单面厚度2.75mm，双面闪存布局也不过3.85mm厚。M.2接口产品有丰富的可扩展性，最长可以做到110mm，可以提高SSD容量。此外，M.2接口可以同时支持SATA及PCI-E通道，后者更容易提高带宽，如果是采用SATA通道的M.2接口固态硬盘，则读写速度在550MB/s左右。
其实前面介绍的HyperX Predator PCIe SSD产品本身拥有双重接口，从PCIe转接卡中取下，即可转换为M.2接口的SSD，并且读取速度和写入速度同样可以达到1400MB/s和1000MB/s。
a) 三星 850 EVO M.2 接口，SATA 总线，AHCI 协议
b) 三星 SM951 M.2 接口，PCIe 总线，AHCI 协议
c) 三星 SM951 M.2 接口，PCIe 总线，NVMe 协议
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98b86a13d7b7abcadfeef4d3e25dae46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7b263db394c848259aa1afbf6fedb26/" rel="bookmark">
			vue组件中的国际化i18n在js中使用时未生效的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自我的简书：https://www.jianshu.com/p/9e018002976e
在国际化i18n组件使用中，我们之前的用法有点错误，我总结一下哈：
在vue组件的中使用
&lt;template&gt; &lt;div&gt; &lt;div class="page-header-title"&gt;{{$t("m.RegisterTitle[1]")}}&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; 在template中可以直接这样用{{$t(“m.RegisterTitle[1]”)}}，没有问题，切换语言的时候，能够正常切换；
但是在JavaScript里面，这样用
data() { return { title: this.$t("m.RegisterTitle[2]"), tips: this.$t("m.ResetPasswordTips"), items: this.$t("m.InputItem"), next: this.$t("m.RouterTitle[2]"), close: this.$t("m.UpperIcon[0]"), } } 就不行了，切换语言的时候，这里的内容不能够正常切换
需要使用
computed: { title: function () { return this.$t("m.RegisterTitle[2]"); }, tips: function () { return this.$t("m.ResetPasswordTips"); }, items: function () { return this.$t("m.InputItem"); }, next: function () { return this.$t("m.RouterTitle[2]"); }, close: function () { return this.$t("m.UpperIcon[0]"); } } computed 就像高级语言中的属性，有getter/setter方法，data 就像变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7b263db394c848259aa1afbf6fedb26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c45f7470cba64cd1fb85d2aac1a400cc/" rel="bookmark">
			Java中instanceof的用法和实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 中的instanceof 是一个二元操作符（运算符）运算符，由于是字母组成，所以是Java的保留关键字，但是和&gt;=，&lt;=，==属同一类，它的作用是用来判断，instanceof 左边对象是否为instanceof 右边类的实例，返回一个boolean类型值。还可以用来判断子父类的所属关系。
用法1： boolean result = object instanceof class 参数：
Result：布尔类型。
Object：必选项。任意对象表达式。
Class：必选项。任意已定义的对象类。
说明：
如果 object 是 class 的一个实例，则 instanceof 运算符返回 true。如果 object 不是指定类的一个实例，或者 object 是 null，则返回 false。
用法2、在做项目中用到的实战应用。 A instanceof B ? A : C; 将instanceof当做一个三目运算符，判断是否A可以转换B
package com.mmall.util; import com.google.common.collect.Lists; import com.mmall.pojo.User; import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang3.StringUtils; import org.codehaus.jackson.map.DeserializationConfig; import org.codehaus.jackson.map.ObjectMapper; import org.codehaus.jackson.map.SerializationConfig; import org.codehaus.jackson.map.annotate.JsonSerialize.Inclusion; import java.text.SimpleDateFormat; import java.util.List; /** * @author Chakid * @since 2018-10-31 20:40 */ @Slf4j public class JsonUtil { private static ObjectMapper objectMapper = new ObjectMapper(); static { //对象的所有字段全部列入 objectMapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c45f7470cba64cd1fb85d2aac1a400cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6bd36e8a3970dbcaf3bd736b02a754a/" rel="bookmark">
			Hadoop认证Kerberos--UserGroupInformation.doAs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在访问带有kerberos认证的hadoop生态圈服务时，必须带上keytab文件认证。
常用的代码：
String userCode="user1"; String keytabPath = "./user1.keytab"; System.setProperty("java.security.krb5.kdc", kdc); System.setProperty("java.security.krb5.realm", realm); final Configuration conf = new Configuration(); UserGroupInformation ugi = UserGroupInformation.loginUserFromKeytabAndReturnUGI(userCode, keytabPath); final HConnection connection; ugi.doAs(new PrivilegedAction&lt;Object&gt;() { @Override public Object run() { try { connection = HConnectionManager.createConnection(conf); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } return null; } }); userCode是用户的名称，keytabPath是keytab文件的路径，一般系统是采用kdc生成的验证文件，来进行系统登录。系统不需要知道密码。 这里的ugi,就是kerberos的ticket, 是通过 UserGroupInformation.loginUserFromKeytabAndReturnUGI(userCode,keytabPath); 这个方法
成功后，返回的票据信息，通过这个票据，可以在没过期的情况下，用来访问hadoop系统。
重点是要说明，为什么要用这个票据的doAs方法来进行访问。首先我们看下UserGroupInformation的代码：
@InterfaceAudience.Public @InterfaceStability.Evolving public &lt;T&gt; T doAs(PrivilegedAction&lt;T&gt; action) { logPrivilegedAction(subject, action); return Subject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6bd36e8a3970dbcaf3bd736b02a754a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d293f1003246bce203980b10ca9f7b1/" rel="bookmark">
			适用于 iOS、Android 和 Windows 设备的移动设备管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		适用于 iOS、Android 和 Windows 设备的移动设备管理
随着企业环境中移动设备的数量不断增加，详细检查访问您企业资源的移动设备变得至关重要。统一终端管理软件 Desktop Central 可帮助您从一个中心位置配置和保护您的移动设备，其专为简化桌面和移动设备管理而生。 我们还提供了 Mobile Device Manager Plus，独立的企业移动设备管理解决方案，可以在本地以及云端使用。如果您正在寻找管理移动设备（无论是公司所有设备还是个人设备）的解决方案，请尝试免费使用 Mobile Device Manager Plus。 Desktop Central 的移动设备管理功能
1.移动应用程序管理
设备管理不会仅仅只是配置策略、检索资产信息和保护设备。应用程序管理与设置员工的移动设备一样重要。
使用 Desktop Centrel，您可以：
创建您独有的企业应用目录。
管理和分发内部和第三方应用程序。
与 Apple 的批量购买计划 (VPP) 和 Google 的 Play for Work集成，允许简单分发商业应用程序。
移动应用程序的黑名单和白名单。
审计您的应用程序清单。
了解关于管理移动应用程序的更多信息，请单击此处。
2.移动安全管理
没有两家企业是一样的——执行严格的策略以满足您特定的安全需求。
使用 Desktop Central 的移动安全管理功能，您可以：
加强设备密码以防止未经授权的访问。
远程锁定设备以防止设备滥用、丢失或被盗。
使用地理位置跟踪，实时跟踪设备。
彻底擦除设备的数据。
执行公司擦除以仅删除公司数据，保持个人数据不变。此功能在自带设备办公 (BYOD) 环境中非常实用，在此环境中，员工可以在其个人设备上访问公司数据。
要了解关于保护移动设备的更多信息，请单击此处。
3.配置文件管理
通过在移动设备上配置和实施策略来保护公司资源。
使用 Desktop Central，您可以为不同的部门或角色创建和配置策略与配置文件。
使用 Desktop Central 的配置文件和策略管理功能，您可以：
配置关于访问企业资源的策略和配置文件。
限制相机、YouTube、浏览器等应用程序的使用。
管理对公司帐户的访问，包括电子邮件、Wi-Fi、以及 ××× 帐户。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d293f1003246bce203980b10ca9f7b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c441741acfc80dd2464f47515a79fb6/" rel="bookmark">
			oracle 数据存储-日志文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、日志文件：记录所有对数据库数据的修改，以备恢复数据使用
1：日志文件分为重做日志文件与归档日志文件
2：重做日志文件：Oracle数据库正常运行不可缺少的文件，重做日志文件主要记录了数据库
操作过程
用于备份和还原数据库，以达到数据库的最新状态
1）：oracle 是使用循环的方式来使用重做日志文件的，所有每个数据库至少需要2个重做日志文件组
2）：每个日志文件成员对应一个物理文件
3）：用户对数据库数据进行修改时，实际上是先修改内存中的数据，过一段时间后，再将内存中的修改
结果成批的写入到上面的数据文件中
4）：oracle利用“联机重做日志文件”随时保持修改结果，即oracle随时将内存中的修改结果保存到“重做日志 文件”中，“随时”表示在将修改结果写入到数据文件之前，可能已经分几次写入到“重做日志文件”。因 此发生故障导致数据库崩溃，oracle也可以利用重做日志文件中的信息来恢复丢失的数据。只要某项操作的 重做信息没有丢失，就可以利用这些重做信息来重现该操作。
5）：重做日志的作用
核心作用：保护数据的安全 、恢复数据
附加作用：数据同步和分析 6）：日志文件损坏
ACTIVE活动日志损坏：数据丢失，数据库损坏
INACTIVE非活动日志损坏
数据不会丢失，可以重建日志文件
3.归档重做日志文件：是重做日志文件的脱机副本，这些副本可能对于从介质失败中进行恢复很必要
备注：日志文件三种状态
INACTIVE：不活动的
ACTIVE：活动的
CURRENT：当前日志组（正在使用）
1）：重做日志文件的结构、属性以及动态变化情况
select group#,status from v$log;
2）：重做日志文件的物理地址和当前在线状态
select group#,member from v$logfile;
3）：强制系统进行日志切换（对单例数据库或RAC中当前实例执行日志切换）
alter system switch logfile;
4):归档当前重做日志文件，不管自动归档是否打开都归档（对数据库中的所有实例执行日志切换）
alter system switch log current
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c13d9335e61613922ee30c8f830b20fb/" rel="bookmark">
			intent-filter属性介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		intent-filter详细属性的介绍
&lt;intent-filter/&gt;是每一个Activity对应的过滤器标签节点。每一个过滤器里面的元素可以有：
0个或多个&lt;action.../&gt;
0个或多个&lt;category.../&gt;
0个或1个&lt;data.../&gt;
（一）全部属性的简介
Intent通过下面的属性来描述的某个意图：
1. action（动作）: 用来表示意图的动作，如：查看，发邮件，打电话
2. category（类别）: 用来表示动作的类别。
3. data（数据）: 表示与动作要操作的数据。如：查看指定的联系人
4. type（数据类型）: 对data类型的描述。
5. extras（附件信息）: 附件信息。如：详细资料，一个文件，某事。
6. component（目标组件）: 目标组件。
下面详细介绍各个组件的使用
（一）component属性
指定了component属性的Intent(调用setComponent(ComponentName)或者 setClass(Context, Class)，Class其实就是显式调用需要的目标类的文件名。这个属性用得比较少，最好不用。如果是显示调用直接指定目标类的class文件名就可以使用了。 比如：
Intent intent = new Intent(this, SecondActivity.class); startActivity(intent); Intent在后台已经帮我们实现了component属性的设置，我们不需要很麻烦的再去实现它的过程。
（二）action动作属性
动作很大程序上决定了Intent如何构建,特别是数据和附加信息,就像一个方法名决定了参数和返回值一样,所以应该尽可能明确地指定动作,并紧密关联到其他的Intent字段，如Category和Data。
常用动作 最常用的是Action_MAIN(作为初始的Activity启动,没有数据的输入输出) 1. ACTION_MAIN 作为一个主要的进入口，而并不期望去接受数据 2. ACTION_VIEW 向用户去显示数据 3. ACTION_ATTACH_DATA 别用于指定一些数据应该附属于一些其他的地方，例如，图片数据应该附 属于联系人 4. ACTION_EDIT 访问已给的数据，提供明确的可编辑 5. ACTION_GET_CONTENT 允许用户选择特殊种类的数据，并返回（特殊种类的数据：照一张相片或 录一段音） ACTION_DIAL 拨打一个指定的号码，显示一个带有号码的用户界面，允许 用户去启动呼叫 6. ACTION_CALL 根据指定的数据执行一次呼叫(有缺陷，使用ACTION_DIAL) 7. ACTION_SEND 传递数据，被传送的数据没有指定，接收的action请求用户发数据 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c13d9335e61613922ee30c8f830b20fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21802f360b9de3f9de02cd9ac713c636/" rel="bookmark">
			关于input checkbox未选中无法传值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;input type="checkbox" name="dct_use_flg" id="dct_use_flg" value="T"&gt; input checkbox如果是选中的，则POST可以得到值，如果是未选中的则无法获取，所以其中一个解决方案是POST后如果该值不存在，直接赋一个默认值。或者是页面上加个input hidden 存放该值。
$dct_use_flg = $this-&gt;input-&gt;post('dct_use_flg');
$dct_use_flg = $isset($dct_use_flg) &amp;&amp; trim((string)$dct_use_flg) == 'F' ? 'F' : 'T';
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e96ce2fb9873f8201addce7e7c7985cf/" rel="bookmark">
			MATLAB学习笔记——符号运算 sym与表达式操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先用sym将一个多项式存储在F里面
1-f = sym(‘符号表达式’) % 定义符号表达式，并将它赋值给变量f
不行用str2sym
2.求反函数 调用函数：finverse 函数功能：求得符号函数的反函数 调用格式：finverse(f, v), 其中f为符号表达式，v是自变量
3.求复合函数 调用函数：compose 函数功能：求符号函数的复合函数 调用格式： compose(f, g) compose(f, g, z) compose(f, g, x, z) compose(f, g, x, y, z)
4.表达式替换 调用函数：subs 函数功能：表达式替换 调用格式： subs(s) subs(s, new) subs(s, old, new)
极限
调用函数：limit 调用格式： g = limit(f) g = limit(f, a) g = limit(f, x, a) g = limit(f, x, a, ‘left’) g = limit(f, x, a, ‘right’)
Note：如果自变量不是x，最好显示说明 代码示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e96ce2fb9873f8201addce7e7c7985cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/814105fd88ac82387f38ef17183b717a/" rel="bookmark">
			es数据库学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做个标记慢慢学
http://lib.csdn.net/wojiushiwo987/538545/chart/deep_elasticsearch
官方文档
https://github.com/NLPchina/elasticsearch-sql/wiki
java es增删改查
https://my.oschina.net/woter/blog/1842801
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4324026043a071c6e07bc7673c752a65/" rel="bookmark">
			Uni-app实战项目之整合SpringBoot前后端分离开发Android、iOS、小程序应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎加入课程群：571278542
课程大纲[会有细微差异，最终以录制课程为准]：
1、成果演示
2、开发技术和工具介绍
3、建立数据库(后台开发3-7节)
4、环境搭建
5、栏目管理(七牛云管理附件)
6、文章管理
7、视频管理
8、提前说说api调用跨域问题及其后面集成swagger2
9、发现(首)页编写轮播图、文章、视频
10、讲堂页编写
11、个人中心页编写
12、Api接口编写和解决跨域问题
13、Springboot集成swagger2进行接口测试
14、前后端对接使用vue2.x进行数据渲染
15、首页对接
16、讲堂页对接(上拉刷新和下拉加载)
17、个人中心页对接(h5+接口实现手机截屏功能、uni-app页面修改后实现刷新)
18、说说第三方登录和支付
19、后期课程安排
[MUI实战项目之整合SpringBoot前后端分离开发Android、iOS或者
SpringBoot开发QQ空间相册管理功能或者SpringBoot整合Netty Socketio之仿造慕课网视频观看功能–&gt;记录学习时长、实时监听视频在线学习人数、同一账号只能打开一个视频进行学习，禁止一个账号多端登录、多窗口学习刷学时等操作]
部分技术介绍：
开发工具(STS)和技术介绍(uni-app、vue、springboot[跨域-打通前后端]、mybatis、通用分页插件PageHelper、freemarker静态化技术、ztree树、kkpager分页插件、jquery.validate.js、mysql、swgger2等)
后台UI框架：h-ui-admin
预计课程发布时间：十一月底
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fbc3ecd7999d32041b570ecef35afda/" rel="bookmark">
			python中is和==运算符比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		is是判断两个变量是否引用同一个对象，即比较对象的地址；
==则是判断两个引用变量或者引用对象的值是否相等，默认调用对象的_eq_()方法；
举例，当直接在IDLE中运行如下代码时，结果如下：
同样的代码不同的结果，原因在于python仅对较小的整数进行缓存，范围是[-5，256]，但是在pycharm和.py文件中，范围则是[-5，任意正整数]，这是因为解释器做了一部分的优化所致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fa17f246a967ad9fa08267d9a2f7562/" rel="bookmark">
			Nw.js入门文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片太多，带图片的文档可以去我的csdn下载找到，或者有道云：http://note.youdao.com/noteshare?id=fd450e1a5ebd05e395ca02e18ab6a648&amp;sub=05FDFAF28F9D46F9A2223810617F19FC
目录
技术介绍 4
技术介绍 4
1 开发环境搭建及开发工具 5
1.1开发环境搭建 5
1.2 开发工具介绍 7
2 项目结构及配置文件 8
2.1 项目目录结构 8
2.2 配置文件 9
3 生成exe及跨平台打包 14
3.1 Hello Word 14
3.2 生成exe文件 15
3.3 跨平台打包 17
4 常用功能 19
4.1 自定义窗口 19
4.2 窗口相关功能 19
4.3 快捷键 21
4.4 开机自启动 22
4.5 配置菜单项 23
技术介绍
技术介绍
（1）NW.JS简介
NW.js （原名 node-webkit）是一个结合了 Chromium 和 node.js 的应用。主要用于跨平台轻量级桌面应用开发，运行环境包括32位和64位的Window、Linux和Mac OS。运行时，通过它可以用 HTML 和 JavaScript 编写原生应用程序。它还允许开发者从 DOM 调用 Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fa17f246a967ad9fa08267d9a2f7562/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cffc638fab7eb5d98ffe0627b293b9e1/" rel="bookmark">
			NSIS打包基础脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		!define PRODUCT_NAME "Lenovo Moto Smart Assistant"
!define PRODUCT_VERSION "3.9.7.13"
!define PRODUCT_PUBLISHER "Lenovo"
!define PRODUCT_LINK_NAME "Lenovo Moto Smart Assistant.lnk"
!define PRODUCT_MAIN_EXE "Lenovo Moto Smart Assistant.exe"
#!define PRODUCT_MAIN_EXE "WpfApplication7.exe"
!define PRODUCT_UNINSTALL_SURVEY "Survey\UninstallSurvey.exe"
!define PRODUCT_WEB_SITE "http://www.lenovo.com"
!define PRODUCT_TEMP "$APPDATA\lmsa"
!define PRODUCT_DIR_REGKEY "Software\Microsoft\Windows\CurrentVersion\App Paths\Lenovo Moto Smart Assistant.exe"
!define PRODUCT_UNINST_KEY "Software\Microsoft\Windows\CurrentVersion\Uninstall\${PRODUCT_NAME}"
!define PRODUCT_WEBBROWSER_IE_VERSION "Software\Microsoft\Internet Explorer\MAIN\FeatureControl\FEATURE_BROWSER_EMULATION"
!define PRODUCT_UNINST_ROOT_KEY "HKLM"
!define HKEY_LOCAL_MACHINE 0x80000002
SetCompressor lzma
; MUI 1.67 compatible ------
!include "MUI.nsh"
!include "LogicLib.nsh"
!include "FileFunc.nsh"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cffc638fab7eb5d98ffe0627b293b9e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72e8be0a6fdc89b69941e4a203dc9346/" rel="bookmark">
			程序员看过来！6499元Mac mini带回家！让你写代码的速度快上30倍！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这次发布会的主角是：iPad Pro、MacBook Air、Mac mini、Apple Pencil。 九月刚发布了新手机的苹果又来了。 这次发布会的主角是：iPad Pro、MacBook Air、Mac mini、Apple Pencil。 早前，发给每家媒体不同设计邀请函的苹果就怒刷了一波存在感，今晚，在美国布鲁克林音乐学院这场大戏才正式上演。 iPad Pro iPad Pro显然是苹果这次发布会的重点。 苹果介绍，其iPad已经卖出了4亿台，去年仅该产品的销量就超过了其他竞品的总数量。没想到吧？一向傲娇的苹果竟然暗戳戳的diss了一下友商~~ 新款iPad Pro删除了HOME键，采用了超窄边框接近全面屏设计，支持Face ID，且无论竖屏、横屏都可以解锁，要知道，这是新款iPhone手机也无法达到的。新款iPad Pro让用户拥有全新的视角，屏幕尺寸有11英寸和12.9英寸两种可选，厚度只有5.9mm，比以前薄了15%。 全新的iPad Pro搭载了采用7nm制程工艺的A12X仿生芯片，内嵌100亿晶体管，搭载7核GPU和8核CPU，整体性能比原来提升了90%，图像处理能力比之前提升了1000倍！在这款iPad 上，苹果首次使用了神经网络引擎，每秒能够处理5万亿的数据，最大支持1TB的存储。值得一提的是，苹果也更加强调iPad在办公上面的需求，和Mac一样，该产品支持分屏功能，同时搭载了拥有磁吸功能以及无线充电功能的新款Apple Pencil。 接口方面，iPad Pro新加入了USB-C接口，可以连接更多的附件，可外接5K屏幕，还支持反向充电。要知道新款iPad Pro电池续航可以持续一整天，如果你出差同时带了iPhone 手机和iPad Pro，当你手机没有电的时候就可以用iPad Pro为你的手机充电了。 在介绍iPad Pro时，库克不止一次提到这款新品的性能毫不输于电脑。 最后无疑就是售价了。 新款iPad Pro售价： 11英寸： 64G版本，国内售价为6499元； 265G版本，国内售价7699元； 512GB版本，国内售价9299元； 1TB版本，国内售价12499元。 12.9英寸： 64G版本，国内售价为8099元； 265G版本，国内售价9299元； 512GB版本，国内售价10899元； 1TB版本，国内售价14099元。 Mac mini 接下来发布的是Mac mini。新款Mac min可谓备受期待了，毕竟，上次Mac mini更新换代还是在2014年。 新款Mac mini有4核处理器和6核处理器两种配置可选，可直接选配64GB的内存以及2TB的SSD ,同样配备了AppleT2安全管理芯片；HEVC视频编码速度较之前提升了30倍，拥有更加丰富的接口，可以连接10G的以太网的速度。性能直线提升了5倍！它们还支持堆叠使用，通过接口与接口的聚连，入门配置8GB/3.5GHz四核版本，799美元起售，如果想买到4.6GHz的i7版本，就得多花一点了。机身同样使用可回收环保材料。 新款Mac mini售价： 128G国内售价6499元； 256G国内售价8899元。 11月7日正式出货。 MacBook Air 库克表示Mac已经拥有1亿用户，新用户在持续增长，目前占据用户总数的51%，其中中国的购买者占据76%。 在发布新品MacBook Air之前，库克通过发布Mac OS 的Mojave 版本开场，这款全新版本的系统具备深色模式、Stacks堆栈等全新功能。 而搭配这款全新系统的就是此次发布新款MacBook Air，库克希望将其的“轻便”发挥倒极致，并对其几乎进行了全新的设计。首先，MacBookAir的Retina视网膜显示屏不仅如约而至，还做出了极大的改进，13.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72e8be0a6fdc89b69941e4a203dc9346/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fe8cb7c150a9c2f4357acd6068170c7/" rel="bookmark">
			Caused by: io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: no furthe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如下异常：
原因分析：
基本上是你的服务没起来
1.ping 通
2.启动服务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a01fa9323fae6f443d6777421c3edf49/" rel="bookmark">
			IDEA的常见的设置和优化(功能)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显示工具条 （1）效果图
（2）设置方法
标注1：View–&gt;Toolbar标注2：View–&gt;Tool Buttons 设置鼠标悬浮提示 （1）效果图
（2）设置方法
File–&gt;settings–&gt;Editor–&gt;General–&gt;勾选Show quick documentation…
显示方法分隔符 （1）效果图
（2）设置方法
File–&gt;settings–&gt;Editor–&gt;Appearance–&gt;勾选
忽略大小写提示 （1）效果图
备注：idea的默认设置是严格区分大小写提示的，例如输入string不会提示String，不方便编码
（2）设置方法
File–&gt;settings–&gt;Editor–&gt;General --&gt;Code Completion --&gt;
主题设置 （1）效果图
备注：有黑白两种风格
（2）设置方法
File–&gt;settings–&gt;Appearance &amp; Behavior–&gt;Appearance–&gt;
护眼主题设置 （1）效果图
（2）设置方法
如果想将编辑页面变换主题，可以去设置里面调节背景颜色
如果需要很好看的编码风格，这里有很多主题
http://color-themes.com/?view=index&amp;layout=Generic&amp;order=popular&amp;search=&amp;page=1
点击相应主题，往下滑点击按钮
下载下来有很多Jar包
在上面的位置选择导入jar包，然后重启idea生效，重启之后去设置
自动导入包 （1）效果图
备注：默认情况是需要手动导入包的，比如我们需要导入Map类，那么需要手动导入，如果不需要使用了，删除了Map的实例，导入的包也需要手动删除，设置了这个功能这个就不需要手动了，自动帮你实现自动导入包和去包，不方便截图，效果请亲测~
（2）设置方法
File–&gt;settings–&gt;Editor–&gt;general–&gt;Auto Import–&gt;
单行显示多个Tabs （1）效果图
默认是显示单排的Tabs:
单行显示多个Tabs:
（2）设置方法
File–&gt;settings–&gt;Editor–&gt;General --&gt;Editor Tabs–&gt;去掉√
设置字体 （1）效果图
备注：默认安装启动Idea字体很小，看着不习惯，需要调整字体大小与字体（有需要可以调整）
（2）设置方法
File–&gt;settings–&gt;Editor–&gt;Font–&gt;
配置类文档注释信息和方法注释模版 （1）效果图
备注：团队开发时方便追究责任与管理查看
（2）设置方法
https://blog.csdn.net/zeal9s/article/details/83514565
水平或者垂直显示代码 （1）效果图
备注：Eclipse如果需要对比代码，只需要拖动Tabs即可，但是idea要设置
（2）设置方法
鼠标右击Tabs
更换快捷键 （1）效果图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a01fa9323fae6f443d6777421c3edf49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aea4b6e1acc893f6c6ae140af60f7792/" rel="bookmark">
			FinalShell下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows版下载地址:
http://www.hostbuf.com/downloads/finalshell_install.exe
Mac版,Linux版安装及教程:
http://www.hostbuf.com/t/1059.html
更新日志:
http://www.hostbuf.com/t/989.html
使用说明教程：
https://www.wn789.com/21310.html
FinalShell是一体化的的服务器,网络管理软件,不仅是ssh客户端,还是功能强大的开发,运维工具,充分满足开发,运维需求.
特色功能: 免费海外服务器远程桌面加速,ssh加速,双边tcp加速,内网穿透.
主要特性:
1.多平台支持Windows,Mac OS X,Linux
2.多标签,批量服务器管理.
3.支持登录Ssh和Windows远程桌面.
4.漂亮的平滑字体显示,内置100多个配色方案.
5.终端,sftp同屏显示,同步切换目录.
6.命令自动提示,智能匹配,输入更快捷,方便.
7.sftp支持,通过各种优化技术,加载更快,切换,打开目录无需等待.
8.服务器网络,性能实时监控,无需安装服务器插件.
9.内置海外服务器加速,加速远程桌面和ssh连接,操作流畅无卡顿.
10.双边加速功能,大幅度提高访问服务器速度.
11.内存,Cpu性能监控,Ping延迟丢包,Trace路由监控.
12.实时硬盘监控.
13.进程管理器.
14.快捷命令面板,可同时显示数十个命令.
15.内置文本编辑器,支持语法高亮,代码折叠,搜索,替换.
16.ssh和远程桌面均支持代理服务器.
17.打包传输,自动压缩解压.
18.免费内网穿透,无需设置路由器,无需公网ip.
19.支持rz,sz (zmodem)
更多功能会逐步增加,保持最少每周一次更新的频率,敬请关注.
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/423/">«</a>
	<span class="pagination__item pagination__item--current">424/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/425/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>