<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/773aa2be6c34132351c4732785e66305/" rel="bookmark">
			css常见问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CSS 问题总结 此文会一直记录工作中常见的css问题
安卓border-radius: 50% 不圆问题 display: inline-block transform: scale(.5); transform-origin: 0% center flex下面img标签变形问题 给img标签增加父标签div即可
&lt;div class="img-wrap"&gt; &lt;img src="../image/icon_input_warn.png" alt="" class="warn" /&gt; &lt;/div&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b52b1118ecce95b251be88eb02bcbda/" rel="bookmark">
			Tomcat8 安装drools7.11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Tomcat8 安装drools7.11 1、workbench简单介绍 workbench 在我看来是一个drools web端的工具，它集成了git，maven和drools。能过帮我们快速的编写一个规则。废话不多说，我们开始搭建workbench。
2、workbench环境 Tomcat8（（我用的是8.5这个版本，必须要tomcat 8以上不然会报错））
jdk8
3、workbench下载 下载地址：https://download.jboss.org/drools/release/7.11.0.Final/
我们可以看到目前 7.48版本已经不支持tomcat，而是用WildFly搭建。最后一个支持Tomcat的版本是7.11.0.Final。
不过往下翻就能看到可以下载历史版本
我们下载kie-drools-wb-7.11.0.Final-tomcat8.war 就ok了
4、修改Tomcat配置 1、部署 把kie-drools-wb（workbench）的war包解压缩放到tomcat webapps下（将名字改成kie-drools-wb）
2、配置JEE安全性 1、添加jar包 把drools 相关的jar下载好放到lib下（5个jar）
包括kie-tomcat-integration、JACC和slf4j-api三个JAR包(自己从maven仓库下载)复制到tomcat的lib目录下 (不加入两个jackson的两个包tomcat启动时会报抱不到jackson相关的类的错误，从maven下载kie包注意版本号)
大家自行在maven仓库中下载。
2、JACC配置 修改Tomcat的server.xml配置文件
在server.xml加入以下内容：
&lt;Valve className="org.kie.integration.tomcat.JACCValve" /&gt; 如图：
3、添加用户 在config目录下的tomcat-users.xml文件中添加角色和用户名，注意确保至少有admin角色或者analyst其中一个角色
&lt;?xml version='1.0' encoding='utf-8'?&gt; &lt;tomcat-users xmlns="http://tomcat.apache.org/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://tomcat.apache.org/xml tomcat-users.xsd" version="1.0"&gt; &lt;role rolename="manager"/&gt; &lt;role rolename="admin"/&gt; &lt;role rolename="analyst"/&gt; &lt;role rolename="kie-server"/&gt; &lt;role rolename="user"/&gt; &lt;role rolename="manager-gui"/&gt; &lt;user username="tomcat" password="tomcat" roles="admin,manager,manager-gui,kie-server,analyst"/&gt; &lt;user username="kieserver" password="kieserver1!" roles="kie-server,admin"/&gt; &lt;/tomcat-users&gt; 说明：角色必须有kie-server。必须有kieserver用户，并且密码必须是keiserver1!。因为kie-server注册时默认用户名和密码就是这个。如果不用默认密码。需要在setenv.sh文件中添加。
5、定义系统属性 在tomcat的bin目录下创建setenv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b52b1118ecce95b251be88eb02bcbda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e48a823466785e24c46dfe38d66fc2a9/" rel="bookmark">
			java 银行项目对于金额的面试题_java发布项目后注意小点，以及对于金额在java中的处理...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目在发布之后，有时会进行一些小的地方的修改，特别是对于一些常量的修改，如定义的一些特殊账户，第三方的key值，当修改的时候，我之前就偷懒过，因为项目在服务器上面，访问速度也受到限制，替换整个项目很麻烦，所以就只是替换了个别的类。这样会导致一个很严重的问题就是，修改了之后并没有什么效果，因为对于public final static int。。。。类似于这种常量在编译时，别的类的字节码中已经写上了常量，而不是这个常量的引用，所以只是单纯的替换一个类，编译这一个类是不对的，而要把所有的类全部都编译一遍和替换，所以不能偷懒呀！！！
在java项目中，肯定会遇到对于金额处理的时候，所以对于金额的处理，一般的人，想想就好，用float，用double，不行的就对其四舍五入等等，这都是不对的，对于金额，我们能用的，也是最好用的是BigDecimal，这个类很好的解决了java中各种数据处理的问题，它对应于数据库中的Decimal字段，所以在以后的项目中，对于金额的地方一定要注意。
BigDecimal number = num.setScale(2,RoundingMode.HALF_EVEN);
setScale是设置精度的方法，而RoundingMode.HALF_EVEN叫做银行家舍入法，对于金额上面的计算利用这样的操作可以减少算法上面对于金额上面的损失，提高项目精度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec7733f09928d95e453c515b440eb0b5/" rel="bookmark">
			HTML5-11【audio标签与video标签及基本应用】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.audio (1).基础知识 支持 OGG MP3 WAV格式
支持的编码格式:
OGG(VORBIS)
MP3(ACC)
WEBM(VORBIS)
(2).属性
二.video (1).基础知识 支持 OGG MPEG4 WEBM格式
支持的编码格式:
OGG(THEORA&amp;VORBIS)
MPEG4(H264&amp;ACC)
WEBM(VP8&amp;VORBIS)
(2).属性
兼容性操作
&lt;video src="xx"&gt; &lt;source src="media/xx" type="video/mp4"&gt; &lt;source src="media/xx" type="video/ogg"&gt; &lt;source src="media/xx" type="video/webm"&gt; &lt;/video&gt; (3).api
load()重新加载
play()播放
pause()暂停
currentTime 当前秒
duration 总时间
paused 是否暂停
muted 是否静音
volume 音量 0-1
playbackRate 倍数
(4).事件 canpaly 准备好了播放
ended 视频结束
error 发生错误
play 开始播放时触发
bufferd.end 缓冲时候的进度
seeked 拖动完后
seeking 拖动时
ratechange 播放倍数改变
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec7733f09928d95e453c515b440eb0b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd10d7866c922afad55e871c827bbae5/" rel="bookmark">
			树莓派ROS stm32 slam Freertos VFH&#43;A*避障路径规划-智能平衡计划（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于树莓派ROSstm32搭载Freertos智能平衡车Day4 前言一、PID控制功能小车直立行走任务分解平衡控制PID控制理论 start结构直立环速度环转向环PID控制原理以及实现小车直立环调节小车速度环调节小车转向环调节 实现代码 前言 PID控制功能原理与实现
提示：以下是本篇文章正文内容，下面案例可供参考
一、PID控制功能 小车直立行走任务分解 我们要求车模在直立的状态下以两个轮子在地面上随意行走，相比四轮
着地状态，车模控制任务更为复杂。为了能够方便找到解决问题的办法，首先将复杂的问题分解成简单的问题进行讨论。
从控制角度来看，车模作为一个控制对象，它的控制输入量是两个电机的转动速度。车模运动控制任务可以分解成以下三个基本控制任务
（1） 控制车模平衡：通过控制两个电机正反向运动保持车模直立平衡状态；
（2） 控制车模速度：通过调节车模的倾角来实现车模速度控制，实际上最后还是演变成通过控制电机的转速来实现车轮速度的控制。
（3） 控制车模方向：通过控制两个电机之间的转动差速实现车模转向控制
平衡控制 控制车模平衡的直观经验来自于人们日常生活经验。一般的人通过简单练习就可以让一个直木棒在手指尖上保持直立。这需要两个条件：一个是托着木棒的手掌可以移动；另一个是眼睛可以观察到木棒的倾斜角度和倾斜趋势（角速度）。通过手掌移动抵消木棒的倾斜角度和趋势，从而保持木棒的直立。这两个条件缺一不可，实际上就是控制中的负反馈机制。 PID控制理论 所谓PID算法，是一种在工程应用领域被使用最为广泛的反馈调节方法，通过PID算法中比例、积分、微分三个部分的作用，达到使系统稳定的效果
（1）比例调节：反应系统的基本（当前）偏差 e(t)，系数大，可以加快调节，减小误差，但过大的比例使系统稳定性下降，甚至造成系统不稳定；
（2）积分调节：反应系统的累计偏差，使系统消除稳态误差，提高无差度，因为有误差，积分调节就进行，直至无误差；
（3）微分调节：反映系统偏差信号的变化率 e(t)-e(t-1)，具有预见性，能预见偏差变化的趋势，产生超前的控制作用，在偏差还没有形成之前，已被微分调节作用消除，因此可以改善系统的动态性能。但是微分对噪声干扰有放大作用，加强微分对系统抗干扰不利。
注：积分和微分都不能单独起作用，必须与比例控制配合。
PID调节
根据直立小车平衡任务分解：
直立环
速度环
方向环
start 配置参考
树莓派ROS stm32 slam Freertos VFH+A避障路径规划-智能平衡计划
树莓派ROS stm32 slam Freertos VFH+A避障路径规划-智能平衡计划（三）
控制GPIO原理图也是参考以上
控制库代码contrl.c：
#include "math.h" #include "stdlib.h" #include "stm32f4xx_hal.h" #include "contrl.h" int Dead_Zone=1200; //电机死区 int control_turn=64; //转向控制 //PID调节参数 struct pid_arg PID = { .Balance_Kp=200, .Balance_Kd=1, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd10d7866c922afad55e871c827bbae5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd180f2bb86da19e15fb1aafaab17e69/" rel="bookmark">
			使用python tkinter开发一个爬取B站直播弹幕的工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目地址 https://github.com/jonssonyan/bilibli-danmu
开发工具 python 3.7.9pycharm 2019.3.5 代码 import threading import time import tkinter.simpledialog from tkinter import END, simpledialog, messagebox import requests class Danmu(): def __init__(self, room_id): # 弹幕url self.url = 'https://api.live.bilibili.com/xlive/web-room/v1/dM/gethistory' # 请求头 self.headers = { 'Host': 'api.live.bilibili.com', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:78.0) Gecko/20100101 Firefox/78.0', } # 定义POST传递的参数 self.data = { 'roomid': room_id, 'csrf_token': '', 'csrf': '', 'visit_id': '', } # 日志写对象 self.log_file_write = open('danmu.log', mode='a', encoding='utf-8') # 读取日志 log_file_read = open('danmu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd180f2bb86da19e15fb1aafaab17e69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33a5cdbf7813c8260cc2f8660f3eef22/" rel="bookmark">
			C/C&#43;&#43;学习路线图--从C小白到C界精英  #CSDN博文精选# #IT技术# #学习路线# #系统化学习#
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好~我是小C，又见面啦！“文章过滤器”精选大咖干货、助力学习之路。
《5天20篇CSDN精选博文带你掌握系统化学习方法》专栏将挑选有关“系统化学习方法”的20篇优质文章，帮助大家掌握更加科学的学习方法~
在这里，你将收获：
快速掌握系统化学习的理论基础，探究其本质和原理学会将已有知识体系化，形成自己的知识图谱，离学霸更近一步系统化学习必备工具推荐与使用方法教学，实现高效学习尝试将系统化学习思维运用于工作、学习中，实践出真知 今天就是本次20篇专栏文章的最后4篇了，小C将继续为你们介绍IT技术的学习路径图~经过5天学习，是否掌握了系统化学习的理论基础并且在实战中也有了经验呢？
从下周开始，就是春节假期了，小C将继续陪伴你们走进下一个专栏《放假不停学实现弯道超车！全栈工程师养成记》
黑马程序员C/C++学习路线图一共分为八个阶段的学习，从C/C++学习开发基础到C/C++学习项目实战。C/C++学习路线图第一阶段：C开发基础；C/C++学习路线图第二阶段：C高级编程；C/C++学习路线图第三阶段：C++核心编程与桌面应用开发；C/C++学习路线图第四阶段：Linux高并发服务器开发；C/C++学习路线图第五阶段：Windows/Linux 跨平台企业项目 实战(项目1)；C/C++学习路线图第六阶段：游戏服务器开发 实战(项目2）；C/C++学习路线图第七阶段：Go语言微服务项目 实战(项目3）；C/C++学习路线图第八阶段：Shell脚本编程。C/C++学习路线图中各个阶段的学习视频可以在黑马程序员视频库中找到自学教程。
第一阶段：C开发基础 此阶段的学习目标：
1、具备C/C++领域基础专业编程能力；
2、实现电子词典项目案例；
3、实现贪吃蛇项目案例。
此阶段的市场价值：
具备学习编程思维，但尚不能达到任何企业用人标准。
此阶段的重点知识：
1、通过C语培养编程思维和动手能力；
2、通过C语言的学习培养面向过程编程思想，为以后的深入学习就业课程打下坚实基础。
第二阶段：C高级编程 此阶段的学习目标：
1、可以实现自己开发小程序，例如贪吃蛇一类的用C语言写的程序；
2、应用C语言接口封装设计的方法，进行企业项目开发。
此阶段的市场价值：
可以掌握C语言深入技巧，灵活应用C语言接口封装设计的方法，但尚不能达到任何企业用人标准。
此阶段的重点知识：
1、掌握C语言中的字符串、一维数组、二维数组的用法；
2、掌握一级指针，二级指针，三级指针的高级用法，理解N级指针概念，指针数组和数组指针；
3、学会结构体、文件的使用；
4、C语言接口封装设计。
第三阶段：C++核心编程与桌面应用开发 此阶段的学习目标：
能够具备基本的开发能力，看懂简单代码，实现开发简单程序软件的功能。能够实现简单的前台界面开发。
此阶段的市场价值：
熟练学习和掌握后，可满足企业开发的初级需求。
此阶段的重点知识：
具备常用C++方向基本知识和常用技能。具备常用QT界面开发的基本技巧和常用技能。
第四阶段：Linux高并发服务器开发 此阶段的学习目标：
能够实现包括服务器后台、前端界面、服务器数据库的开发。
此阶段的市场价值：
熟练学习和掌握后，可满足企业开发的初中级需求。
此阶段的重点知识：
具备常用后台服务器开发方向基本知识和常用技能，并具备基本的开发能力。
第五阶段：Windows/Linux 跨平台企业项目 实战(项目1) 此阶段的学习目标：
熟练应用项目中使用的数据库知识，能做简单的数据库开发。
此阶段的市场价值：
熟练学习和掌握后，可满足企业开发的初中级需求。
此阶段的重点知识：
掌握常用数据库类型的操作技巧和简单开发。
第六阶段：游戏服务器开发 实战(项目2） 此阶段的学习目标：
解决大型互联网公司并发高吞吐问题；
解决分布式web应用服务器集群问题。
此阶段的市场价值：
熟练学习和掌握后，可满足企业开发的初中级需求。
此阶段的重点知识：
掌握高性能服务器解决方案（负载均衡）；
掌握分布式存储解决方案（redis集群/mysql集群/ mongodb集群）；
掌握RPG类游戏核心功能
掌握服务器逻辑开发。
第七阶段：Go语言微服务项目 实战(项目3） 此阶段的学习目标：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33a5cdbf7813c8260cc2f8660f3eef22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b259c4cbba7c173244d4a6690b1ce5e/" rel="bookmark">
			EFCore查缺补漏（一）：依赖注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间，在群里潜水的时候，看见有个群友的报错日志是这样的：
An unhandled exception was thrown by the application. System.OutOfMemoryException: Exception of type 'System.OutOfMemoryException' was thrown. at System.Threading.Thread.StartInternal() at Microsoft.Extensions.Logging.Console.ConsoleLoggerProvider..ctor(IOptionsMonitor`1 options) at … at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitCache(ServiceCallSite callSite, RuntimeResolverContext context, ServiceProviderEngineScope serviceProviderEngine, RuntimeResolverLock lockType) at … at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetService[T](IServiceProvider provider) at Microsoft.Extensions.Logging.LoggerFactory.Create(Action`1 configure) at xxxxxxx. &lt;&gt;c__DisplayClass2_0.&lt;AddXxxDbContext&gt;b__0(DbContextOptionsBuilder builder) at Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.CreateDbContextOptions[TContext](IServiceProvider applicationServiceProvider, Action`2 optionsAction) at … 嗯……内存满了？是在构建 ConsoleLoggerProvider 的时候报的异常？是由依赖注入容器产生的？再上层是 AddXxxDbContext？
好吧，看来一定是位没研究过 EFCore 源码也没看过与本文类似内容的仁兄……我甚至能反推出他写的代码：
public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddDbContext&lt;MyDbContext&gt;(options =&gt; { // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b259c4cbba7c173244d4a6690b1ce5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1226fd34985b87dc51fc39736da06d61/" rel="bookmark">
			SpringBoot @Async加在实现接口类的非接口方法上获取Bean异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、场景复现 报错日志
*************************** APPLICATION FAILED TO START *************************** Description: A component required a bean of type 'com.mk.service.TestService' that could not be found. Action: Consider defining a bean of type 'com.mk.service.TestService' in your configuration @Service public class TestService implements ITestService{ @Async public Future&lt;String&gt; doActionAsync(){ return new AsyncResult(doAction()); } @Override public String doAction() { return "done"; } } public interface ITestService { String doAction(); } @Component public class Runner implements ApplicationContextAware { @EventListener(ApplicationReadyEvent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1226fd34985b87dc51fc39736da06d61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d511b7ff8695b08ac25e99808433fd2/" rel="bookmark">
			几种常见的CSS布局--   双飞翼布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 双飞翼布局：对圣杯布局（使用相对定位，对以后布局有局限性）的改进，消除相对定位布局原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。 .container { /*padding-left:150px;*/ /*padding-right:190px;*/ } .main-wrap { width: 100%; float: left; } .main { margin-left: 150px; margin-right: 190px; } .left { float: left; width: 150px; margin-left: -100%; /*position: relative;*/ /*left:-150px;*/ } .right { float: left; width: 190px; margin-left: -190px; /*position:relative;*/ /*right:-190px;*/ } &lt;div class="content"&gt; &lt;div class="main"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/558734f3e2641b85650cfd27f4f72b07/" rel="bookmark">
			点云迭代最近邻点配准法_一种利用三维点云的零件加工精度自动检测方法与流程...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本发明属于机械加工检测技术，具体涉及一种利用三维点云的零件加工精度自动检测方法。
背景技术：
三维激光扫描是一种近年来快速发展的三维空间成像技术，利用双轴伺服电机驱动激光测距器，对扫描场景的目标表面进行等间隔的连续采样，输出与三维场景几何形态完全一致的三维点云。这种技术正在被越来越广泛地应用于测绘、考古、机械加工制造、三维打印、机器人、无人驾驶等领域。
机械零件是制造业的基础，加工精度检测是保证精密零件产品质量的关键生产环节，也是长期制约我国高精尖产业发展的技术瓶颈。传统的机械零件质检方法主要使用卡尺、微分尺、三维坐标仪等接触式测量方法，依赖人工频繁选点，测量结果容易受到选点误差的影响。三维扫描技术作为一种可以快速获取高精度、高密度物体表面采样点的非接触测量技术可以有效解决这些问题。
近年来，研究人员开始尝试利用三维扫描技术进行零件精度检测，提出了各自的全表面非接触检测方案。然而这些方法在配准实物扫描点云和设计模型时，均未考虑零件表面加工误差部位会造成配准结果整体偏差问题。此外，公开报道的检测方案都是在配准基础上直接进行零件表面偏差计算，将结果简单地标记在点云上显示出来，需要质检人员依靠人眼区分点云测量随机误差与零件表面的加工误差。
技术实现要素：
发明目的：本发明的目的在于解决现有技术中存在的不足，提供一种利用三维点云的零件加工精度自动检测方法，通过三维激光扫描技术采集零件点云，与设计模型精细化配准，再利用误差分布假设性检验和公差界限检验实现机械零件精度的自动化检测。
技术方案：本发明的一种利用三维点云的零件加工精度自动检测方法，通过以下具体步骤对一对给定零件以及零件设计模型进行自动检测
(1)针对零件实体，利用三维激光扫描技术对零件进行点云采样，采集零件三维点云P；
(2)通过主成分分析法对采样点云P与零件设计模型Q进行粗配准，根据采样点云P配准过程中点的残差值对点对D0赋权，通过选权迭代最近邻点的方法进行配准精细调整；
(3)配准完成后进行误差分布假设性检验以及公差界限检验自动生成零件加工精度的评价结果。
进一步的，所述步骤(2)的详细过程为：
(2.1)对于零件设计模型Q进行随机采样，获得点集Q0；
(2.2)对点云P和点集Q0分别通过主成分分析法计算各自的协方差矩阵，然后将对应协方差矩阵的特征向量作为XYZ轴建立各自标准姿态坐标系Cp和Cq；
(2.3)通过坐标转换把Cp和Cq转换到相同坐标系中完成粗配准；
(2.4)对完成粗配准的点云P，把零件设计模型Q作为参考，计算点云P到零件设计模型Q的最近距离点集Q1＝C(P，Q)，点云P与点集Q1具有一一对应关系，形成初始对应点对应关系D0；
(2.5)利用粗配准结果采样点云P中点的残差值和相应赋权函数对点对D0进行赋权：
其中，v为残差，μ为v的均值，σ为v的方差，n为常数；
(2.6)结合步骤(2.5)所得点对权值，计算旋转矩阵R和平移向量qT，对扫描点云P进行坐标变换；
(2.7)重复步骤(2.1)至步骤(2.3)过程，进行迭代计算，每次计算均更新点对应关系获得点对Dk，计算第k次迭代的配准误差为
其中，di(k)为第k次迭代P到X的距离，n为点云P点的数目，当|Ek-Ek-1|＜ε时，认为迭代收敛，此时结束精确配准。
进一步的，所述步骤(3)的详细过程为：
(3.1)采用χ2检验法进行误差分布假设性检验，检测加工偏差工件，如果本次检测通过，即：认为本次检测的距离偏差di服从正态分布；否则，认为距离偏差分布不服从正态分布，产品可能存在系统性的加工误差，将其认定为不合格产品；
(3.2)根据公差界限检验，在通过误差分布假设性检验的零件中检测加工粗糙零件；通过检测3倍中误差的绝对值是否小于公差界限Δ限来判断零件表面的粗糙程度，如果|3σ|＜Δ限则认为零件表面加工精细，满足加工精度要求，属于合格件；其中v是残差，n是采样点云点个数。
此处，本发明先使用χ2检验法进行误差分布假设性检验，χ2检验法具有极高的误差敏感度，能够对零件加工误差实现敏感识别；再公差界限检验检测零件加工粗糙度
进一步的，所述步骤(2.2)的具体内容为：
其中N为特征向量个数，为点云P的重心，以该重心为原点，以COV的特征向量为XYZ轴建立各自标准姿态直角坐标系Cp，Cq。
进一步的，所述步骤(2.3)的具体内容为：
根据Cp和Cq的坐标原点，平移坐标系Cp，使它的坐标原点与Cq的原点重合；
Cp方向向量为i、j、k，Cq三个坐标轴在Cp中的方向向量
其中a1，a2，a3分别为Cq中ox′与Cp中ox oy oz的夹角，b1，b2，b3分别为Cq中oy′与Cp中ox oy oz的夹角，c1，c2，c3分别为Cq中oz′与Cp中ox oy oz的夹角，那么就有
转换后Cp，Cq移动到相同坐标系中完成粗配准。
有益效果：本发明利用三维点云的零件加工精度自动检测方法，可以实现零件精度自动化检测，本发明所利用的选权迭代最进邻点的配准方法可以有效克服传统配准方法易受零件加工偏差影响的弊端，可以有效排除点云噪声点对配准的干扰，具有较强的鲁棒性。在精度评定方面，该方法对加工偏差以及表面加工粗糙的零件具有很强的敏感性，并且可以满足不同零件或者工厂的不同精度要求，在工业生产中具有广泛的适应性。
另外，本发明考虑现有技术中加工误差区域对配准精度存在影响的问题，以及配准过程始终使用固定不变的参考点集的问题，本发明采用迭代计算的配准方法，并且在迭代过程中不断更新参考点集，通过不断调整权值让有可能存在加工误差的区域退出配准计算，从而最大限度的提高配准精度。
附图说明
图1为本发明的整体流程图。
图2为本发明中标准姿态直角坐标系示意图。
图3为本发明中采样点云与设计模型粗配准示意图。
图4为本发明中采样点云与设计模型点对选择示意图。
图5为本发明中采样点云误差分布假设性检验示意图。
图6为实施例中采样点云公差界限检验示意图。
具体实施方式
下面对本发明技术方案进行详细说明，但是本发明的保护范围不局限于所述实施例。
如图1所示，本发明的利用三维点云的零件加工精度自动检测方法，给定一对零件以及零件设计模型，该检测方法包含以下步骤：
(1)针对零件实体，利用三维激光扫描技术对零件进行点云采样，采集零件三维点云P；
(2)通过主成分分析法对采样点云与零件设计模型进行粗配准，根据采样点云配准过程中点的残差值对点赋权，通过选权迭代最近邻点的方法进行配准精细调整，具体内容为：
(2.1)对于零件设计模型Q进行随机采样，获得点集Q0；
(2.2)对点云P，Q0分别通过主成分分析法计算各自的协方差矩阵COV
其中N为特征向量个数，为点云的重心，以重心为原点，以COV的特征向量为XYZ轴建立各自标准姿态直角坐标系Cp，Cq，如图2所示；
(2.3)根据Cp，Cq的坐标原点，平移坐标系Cp，使它的坐标原点与Cq的原点重合；
Cp方向向量为i、j、k，Cq三个坐标轴在Cp中的方向向量
其中a1，a2，a3分别为Cq中ox′与Cp中ox oy oz的夹角，b1，b2，b3分别为Cq中oy′与Cp中ox oy oz的夹角，c1，c2，c3分别为Cq中oz′与Cp中ox oy oz的夹角，那么就有，
转换后Cp，Cq移动到相同坐标系中完成粗配准，如图3所示；
(2.4)对完成粗配准的点云P，把设计模型Q作为参考，查找最近点，计算点云P到设计模型Q的最近距离点集Q1＝C(P，Q)，如图4示所示，点集P与Q1具有一一对应关系，形成初始对应点对应关系D0；
(2.5)利用粗配准结果采样点云P中点的残差值和本发明设计赋权函数对点对D0进行赋权
其中，v为残差，μ为v的均值，σ为v的方差，n可以取5，μ可以取0；
(2.6)结合点对权值，计算扫描点云P的重心μp和对应点点集X的重心μx
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/558734f3e2641b85650cfd27f4f72b07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/016de3fda326ba82f27927e913a5fcea/" rel="bookmark">
			使用 Docker 安装 Centos6.5 环境和python3.6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 安装Docker出现windows 正在查找bash.exe启动docker 更新时间太长镜像虚拟机太占内存 安装centos获取centos对应版本的容器创建对应虚拟环境 安装python3.6更新yum文件安装python3.6 安装Docker 由于我的是win10企业版，不能直接安装Dokker（错误：Docker Desktop requires Windows 10 Pro or Enterprise version 15063 to run），所以通过docker toolbox安装docker：Windows10 使用docker toolbox安装docker
出现windows 正在查找bash.exe 解决点击Docker出现windows 正在查找bash.exe。如果想亲自查找文件，请点击“浏览”的问题
启动docker 更新时间太长 启动docker的时候需要更新boot2docker.iso，因为是github的资源，等它更新下来估计花儿都谢了，所以我会选择找个网上资源把下载后放到它要找的文件夹中（注意最新版本的下载地址会在启动docker中出现），具体可以参考：解决docker-machine 初始化下载 book2docker 过慢的问题
镜像虚拟机太占内存 在pull一些镜像建立一些容器后，镜像虚拟机轻易的达到了几个G，这个时候你的C盘就会想一直膨胀了的猪，最后的下场好像只剩下被宰。为了不被推上案板，你可以参考windows下默认安装docker后导致C盘空间不够用问题的解决方案来解决这一问题
安装centos 获取centos对应版本的容器 docker安装成功后就可以安装centos，使用命令docker pull centos就可以拉取容器了。
但是这个命令会拉取最新的centos，但我需要的是6.5的环境.
这个时候进入docker hub 就可以对各种容器进行搜索了，docker hub 在官网上就有，或者你安装docker后电脑上也会有，找到对应的容器就可以pull了，我选择的是别人pull最多的那个（热心提醒：因为之前pull了一个很小的容器，但是缺了好多东西，导致后来安装python各种缺包还不好安装，所以选择大家选择的至少不会错）docker pull hasedon/centos6.5就OK了。
创建对应虚拟环境 docker run -itd --name centos6.5 hasedon/centos6.5 /bash
这样就从容器hasedon/centos6.5中创建并在后台激活了个名为centos6.5的虚拟环境
docker exec -it centos6.5 /bash
就可以进入环境进行各种骚操作了！
安装python3.6 系统会自带2.6的版本，但是我们需要的是3.6的版本，因此需要重新安装。
更新yum文件 使用 yum clean all 和 yum update的时候就会发现yum不可用，主要原因是版本太老了，好多资源链接都不可用。我的方法是从网上下载一个136或者阿里云的yum配置，然后替换掉容器中的yum配置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/016de3fda326ba82f27927e913a5fcea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c75a6c04d017cb3a4ae7b195f7d5de13/" rel="bookmark">
			有了这20个数据网站，再也不愁找不到各行业的分析研究报告了？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不同行业的人对报告的深浅度需求不一致，很多刚入职场的小白不知从哪里找到行业的分析研究报告，但对于一名有十多年职场经验的我来说，平时工作，为了调研某个行业的情况，找分析报告研究报告那是家常便饭。
之前认为找个行业的分析研究报告只有咨询公司才有的，毕竟专业的人该专业的事嘛。如今，觉得当时的自己才疏学浅。。。
好了，废话不多说，下面教你如何像咨询公司一样找到研究报告。
就我个人而言，用得较好的三个咨询机构，这三个咨询机构，基本上可以覆盖各行各业，比如互联网、制造业、零售业等，分析的方面也比较广，数据也是可靠的。
1、德勤
被Gartner连续9年评为全球安全咨询服务第一，咨询报告这一块质量挺满意的。各个行业的研究报告上面都有，基本上搜索就出来了。
2、艾瑞咨询
一个依托大数据，发布互联网行业研究报告，是后起之秀。
3、易观（易观智库）
易观除了直接提供数据之外，还提供多种模型与工具，帮助客户进行自主分析和应用，更好地使用这些信息和数据。相对而言，价值更大。
最后提一下比较权威的官方统计数据网站，涉及各种XX局的统计数据了，里面数据的准确性不用质疑。
4、 199IT互联网数据中心：各行各业，种类齐全
5、TalkingData，质量数量两开花
6、 罗兰贝格行业评论，知名营销资讯公司，聚焦消费品和零售方面，相关的报告质量也比较高
7、艾瑞研究-艾瑞网：艾瑞的咨询主要集中在互联网方面，一
8、36氪：如果你是创业者，又想找准确还保持中立客观的信息，36氪一定是你最好的选择。另外36氪上也有不少独家信息~
9、亿邦动力：亿邦动力主打电商，在电子商务行业拥有很大的影响力，中小企业可以多加参考
10、亿欧：亿欧的重点在于突出一个“新”字，不管你是新科技还是新理念新政策，在亿欧都能看到相关的报告。除此之外，也可以探讨一些行业热点话题。
11、易观（易观智库）：易观的优点在于除了报告，还会有很多的分析，有需要的同学看可以根据他的分类挑选自己想要的内容
12、阿里研究院-阿里行业研究报告：阿里巴巴就不用多说了，依托他的阿里研究院里的海量数据，总有你需要的
13、尼尔森：本身就是一家全球知名的市场监测和数据分析公司，想要了解市场动态可以看看
14、卡思数据：短视频目前有多火，大家有目共睹。而卡思就是这样一个分析短视频数据的网站，市面上比较火的短视频app都有包含在内。
15、波士顿咨询：你知道“波士顿矩阵”吗？就是这家公司提出的，他们也是全球性的行业洞察，但可能对你的英文水平提出了一点要求。
16、中国经营连锁协会CCFA，是连锁经营领域唯一的全国性行业组织，经常发布一些行业资讯和报告
17、联商网，专注零售行业提供多方面的服务，对于零售行业来说也是最大的商机平台和互动社区
18、鲸准研究院研报
36Kr旗下的新经济产业研究咨询机构，提供新科技、新消费、医疗健康、新金融、高端制造、新能源、大文娱、教育等等多个行业的研究报告，往期的报告可以免费查看，大部分最新的报告需要付费购买。
19、胖鲸智库
独立会员制的营销创新趋势研究智库，小程序包含了访谈、案例和报告三大板块，从事营销、新媒体、互联网的用户值得多多关注。
上面20个，只要你会其中一个，找到所需行业的分析研究报告不是问题。
仅仅找到行业分析报告不行，还是要让报告的数据发挥出最大价值，那么数据分析工具就成了不二选择，无需代码，直接上手，能适应企业的复杂业态，简单又易用的的FineBI有必要了解一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4a280f42cff32ddf5eed630622d1176/" rel="bookmark">
			如何在python官网下载pip_python库在哪里下载？怎么安装？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		库可是我们在编程时，不可缺少的内容，在运行脚本时候，需要很多库的支持，因此学会基本的下载和安装库尤为重要，一起来看下吧~
Windows下python库的3种常用安装方法
1、pip安装(需要pip)
2、通过下载whl文件安装(需要pip)
3、在pythn官网下载安装包安装(不需要pip)
方法一：pip安装
这是最常用的python安装方法，新版的python一般自带pip.exe程序，在CMD中输入pip 可以查看相关参数
通常我们输入指令 pip install xxx来让python自动安装。比如：pip install pandas
如上图所示，他会自动下载用到的相关包。在安装一些库的时候，往往会报出各种各样的错误。
方法二：通过下载whl文件安装
1、下载相应库的whl文件，网址Python Extension Packages。注意要下载相应版本的，还有32还是64位系统。
2、cmd上输入pip install .whl文件名即可。 要完整的文件
方法三：官网下载文件安装
1)下载
2)解压
3)在命令提示符窗口中，使用cd进入到解压后的文件的路径下
4)输入命令python setup.py install
常用的两个下载包和模块安装文件的网站：PyPI-the Python Package Index和Python Extension Packages。
最后，我们通过pip命令，顺利安装我们后面要用的这个几个包，这些包的具体功能和用法，我们后期再做详细讲解。pip install numpy
pip install pandas
pip install matplotlib
pip install scipy
以上就是关于python库的安装与下载全部内容，如需更多python实用知识，点击进入JQ教程网Python大全。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aa59c0d80d6fdaa663e8d9bd5b06b06/" rel="bookmark">
			大小写 数据库 达梦_达梦数据库使用及与项目的融合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、达梦数据库安装及初始化库的过程中需要注意
1.安装达梦数据库
(1) 数据库在安装的过程中基本上就是下一步下一步，按照默认选项安装就好，安装路径根据自己的要求选择。
(2)dm7密码是大小写敏感的
2.初始化数据库：安装完成时会提示是否新建数据库
(1)页大小(page_size)
除去Clob、Blob等大字段外，数据库中一行记录的所有字段的实际长度的和不能超过页大小一半。
建议页大小设置为16K，防止在后期进行数据迁移和开发过程中出现记录超长的问题；
(2) 日志文件的大小(log_size)
数据库redo日志文件的大小，单位为M，正式环境日志文件的大小一般设置为2048；
(3) 字符串比较大小写敏感(case_sensitive)
默认为大小写敏感的，根据具体情况进行设置。迁移实施中如果原始库为Oracle和DB2数据库的话需设置为大小写敏感，若为SQL Server和MySQL数据库则需设置为大小写不敏感，所以在数据库初始化库的过程中需要根据具体情况来选择。
注意事项：
在开发环境和测试环境的页大小、字符串大小写敏感等初始化参数一定要保持一致，避免使用.bak文件进还原的时候，因为初始化参数不一致导致无法还原的问题。所以在初始化库之前务必规划好上述参数，因为页大小和字符串比较大小写敏感这两个参数一旦初始化完成，后期无法修改。如需修改，则只能删掉现有实例重现初始化新的实例。
总结：
当数据库安装完成，在使用数据库配置助手dbca工具初始化库的过程中，其它步骤按照默认选项下一步即可，当到这个页面时需要注意以下三个参数的设置，其它参数如无特殊要求按照默认选项就好。
二、达梦数据库集成到项目前置
1.创建一个用户作为我们项目的数据源连接
创建用户是会默认创建一个属于他自己的模式
因为达梦和orcle有些类似，所以他们的表是包含在模式里面，并且每个用户都有自己的一个默认模式，我们用新建的这个用户可以直接用表名进行数据操作，如果用的其他用户登陆的话，必须加上模式名称.表名进行数据操作，然后就可以进行集成了。
三、项目集成达梦数据库
1、项目中安装达梦数据库驱动(DmDriver)
达梦数据库驱动在\drivers\jdbc文件夹下，我用的是最新的Dm7JdbcDriver17.jar(该驱动已经上传到私服)
2、在配置文件中配置达梦数据库
spring:
# datasource configuration
datasource:
driverClassName: dm.jdbc.driver.DmDriver
url: jdbc:dm://10.3.36.202:5236/CMS
username: CMS
password: 123456789
druid:
validation-query: select 1
在我们的项目中我们使用的是druid作为数据连接池，用nutz作数据库操作(DAO层)
上面这个配置是我们用druid作为数据连接池并且没有DruidConfig配置类的情况下
如果我们使用了DruidConfig的话，因为druid有sql防火墙功能，但是druid防火墙不支持DM,所以我们在配置中要把Filter中的wall去掉，不去掉的话会一直报不支持dbType:dm错误或者去掉该druid配置
四、新建类是实体类时注意事项
1.达梦数据库像mysql和orcle一样，都有自己的一些关键字，特别要注意关键字不能出现在实体类中作为列明
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87cd869de068720c81670cda04fc4b5e/" rel="bookmark">
			美团技术年货！超级硬货！程序员必看！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		美团技术年货！超级硬货程序员必看！ 2020年：
2020美团技术年货-合集：点这里
2020美团技术年货-前端篇：点这里
2020美团技术年货-后台篇：点这里
2020美团技术年货-算法篇：点这里
2020美团技术年货-顶会论文精选：点这里
温馨提醒：文件较大，其中2020年货合集约80M，建议通过WIFI下载，或将地址复制到PC端，使用浏览器进行下载。
2019年：
【前端篇】：点这里
【后台篇】：点这里
【算法篇】：点这里
【大数据篇】：点这里
【学术论文篇】：点这里
【2019美团技术文章合辑】：点这里
温馨提醒：文件较大，约100M，建议通过WIFI下载，或将地址复制到PC端，使用浏览器下载。
2018年：
【前端系列】：点这里
【后台系列】：点这里
【系统系列】：点这里
【算法系列】：点这里
【运维系列】：点这里
【测试系列】：点这里
【工程师成长系列】：点这里
【2018美团技术文章合辑】：点这里
温馨提醒：文件过大，约350M，建议通过WIFI下载，或将地址复制到PC端，使用浏览器下载。
2017年：
《2017美团技术年货（上）》下载链接：点这里
《2017美团技术年货（中）》下载链接：点这里
《2017美团技术年货（下）》下载链接：点这里
《2017美团技术年货（合辑）》下载链接：点这里
获取技术沙龙PPT及视频：点这里
温馨提醒：
1.上中册约23M，下册约36M，合辑约70M；文件较大，请耐心等候下载；
2.建议通过WIFI下载，或将地址复制到PC端，用浏览器下载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bc3eb95fbc5120dbe95436b4238918b/" rel="bookmark">
			单场淘汰制场次计算方法_淘汰赛_羽毛球新闻
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		淘汰赛什么意思
淘汰赛是指体育比赛和其它各种比赛中的一种赛制，在这种赛制中赛员两两相对，输一场即淘汰出局。每一轮淘汰掉一半选手，直至产生最后的冠军。
此外还有双败淘汰赛制和三败淘汰赛制，其中参赛者在失去争夺冠军的机会之前分别最多可以输掉2场和3场比赛。淘汰制赛事通常会设有种子或排名制度，以避免水平较高的参赛者过早对赛。因此，实力最强的参赛者有相当机会在决赛相遇。
扩展资料
体育竞赛的方法：：
淘汰法：分为单淘汰、双淘汰、交叉淘汰。
循环法：分为 单循环法、双循环法、分组循环。
顺序法：有两种情况：n按一定的顺序让参赛者一组一组表现成绩，通过及格赛、预赛、复赛、决赛，比出优胜名次。n球类和其他对抗性比赛项目，一对一按事前排好的淘汰表进行比赛，胜者进入下一轮，直到最后一对决出优胜者。
场数计算：
单淘汰赛轮次和场数计算方法：轮次=参赛者数的2的乘方数
例如，2个参赛者=2(一次方)=1轮 4个参赛者=2(2次方)=2轮
9个参赛者=2(4次方)=4轮 【参数的人数等于或者小于2的N次方。】
比赛场数=参赛者(队)数-1。
例如，8个参赛者(队)比赛 8个参赛者=8-1=7场
双淘汰赛轮次和场数计算方法：胜方轮次与单淘汰赛相同(即参赛者数对2的乘方数)；
负方轮次=参赛者数对2的乘方数×2-2；
比赛场数=2×参赛者数-3。
例如，8个参赛者进行双淘汰赛
轮次=胜方轮次+负方轮次=2(3次方)+ 2(3次方)×2-2 =3+3×2-2=3+6-2=7轮
场次=2×8-3=16-3=13场
参考资料来源：百度百科-淘汰赛
参考资料来源：百度百科-淘汰赛制
参考资料来源：百度百科-体育淘汰
淘汰赛有几种形式？
淘汰赛制分为：单败淘汰赛制，双败淘汰赛制。
单败淘汰：
单败淘汰制是一种竞赛形式，每场比赛的负方将与竞赛的冠军或锦标绝缘，但不表示负方在出局后再没有比赛，部份竞赛的负方仍需为排名角逐“名次赛”或“遗材赛”。
双败淘汰：
双败淘汰制是一种竞赛形式，与普通的淘汰制输掉一场即被淘汰不同，参赛者只有在输掉两场比赛后才丧失争夺冠军的可能。
双败淘汰制的比赛一般分两个组进行，胜者组与负者组。在第一轮比赛后，获胜者编入胜者组，失败者编入负者组继续比赛。之后的每一轮，在负者组中的失败者将被淘汰；胜者组的情况也类似，只是失败者仅被淘汰出胜者组降入负者组，只有在负者组中再次失败后才会被淘汰出整个比赛。
与普通单败淘汰制类似，一般双败淘汰制也有2的次方数(如4、8、16)参赛者，以保证每一轮都有偶数名参赛者。
扩展资料：
单败淘汰赛制的优缺点：
优点
1、由于单败淘汰制竞赛的负方将会出局，所以竞争十分激烈。除了最终的排位安慰赛之外，淘汰赛的每一轮都很关键，可以说没有无意义的比赛。
2、可以在短时间内容纳大量参赛者，所以成为很多竞赛的比赛形式。
缺点
1、不适合那些可能大量出现平局的比赛。例：国际象棋比赛，由于平局很常见，且白棋有先行优势，所以每一轮常常需要多场比赛才能决定胜负，故不适合。另外，足球比赛中，平局后往往需要加时赛乃至罚点球(十二码罚球)才能决定胜负。
2、大部分参赛者可能因过早被淘汰而只有很少的比赛场次，故此有些竞赛采用双败淘汰制。
双败淘汰赛制的优缺点：
优点
1、双败淘汰制相对于单败淘汰制的优点之一是，无需进行额外的安慰赛或排位赛即可确定第3、4名。 减少优秀选手因抽签不佳而致最终名次低于较差选手。
缺点
1、双败淘汰制的主要缺点在于比赛场次比单败淘汰制大大增加。由于参赛者失败2场才会被淘汰，对于有N名参赛者的比赛，需要2*N-1(或者2*N-2，如果冠军一场未负)场比赛才能决出冠军。
2、另一个缺点是，胜者组的第一名有可能只在最后决赛时输掉一场，却输掉了冠军，但一般认为由于胜者组第一名比败者组第一名要少赛几场，相当于轮空几轮，所以这个结果还是可以接受的。一种弥补的方案就是上面提到的完全双败淘汰，再加赛一场决定冠军。
参考资料来源：百度百科——淘汰赛制
求淘汰赛和循环赛的公式
一、淘汰赛
淘汰赛的比赛场次计算：有n个队参加，在淘汰掉(n-1)个队，共比赛(n-1)场。
特点：封闭式的、易受干扰的比赛制度。各个参赛者(队)的名次需在整个比赛结束以后，统计各自的积分才能最终全部确定，所以一旦开赛就不便增减参赛者，不然就会影响各参赛者成绩的计算。
二、循环赛
1、单循环赛的计算方法：设有n队参加，每队与另外的n-1个队都要比赛，共场数：1/2n(n-1)
2、双循环赛的计算方法：每队主场赛(n-1)场：客场赛n-1场，总场数：n(n-1)场
特点：每个队都能和其他队比赛一次或两次，最后按成绩(净胜球数)计算名次。
扩展资料
分组编排：
例如：有16个参加比赛，为了使各组的队数相均，可分成4个小组，每组4个队。如果时间、经费允许，又希望多打比赛，也可分成两个小组，每组8个队。在分成4个小组中，“种子队”可设立4个队，也可设立8个队，经抽签编到小组内，或者将1、8，2、7，3、6，4、5(依照上届比赛的名次排出)经抽签编入组内。
其余蛇形排列方法，将1、4、5、8“种子队”排到第一组，2、3、6、7“种子队”排到第二组，其余各队再经抽签编入组内。
单淘汰赛和单循环赛各有什么特点
单淘汰赛的特点：单场比赛就要定胜负，比赛时间短，竞争非常激烈。这种竞赛适用于参赛队多的情况下。因为它的偶然性强，容易出冷门，强队有时也会惨着淘汰。
单循环赛的特点：所有参加比赛的队均能相遇一次，最后按各队在全部比赛中的积分、得失分率排列名次。能真实体现真正实力(因为他即使是小组单循环与其他小组选手都各交手一次)，缺点是比赛时间长、要求场地多。 这种竞赛适用于参赛队不多，而且时间和场地都有保证的情况下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bc3eb95fbc5120dbe95436b4238918b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e01144bd1e4d905684aca56345ad6cd/" rel="bookmark">
			mySQL 2008安装MOF无法连接_安装SQL2008R2时提示：MOF编译器无法连接WMI服务器？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在安装用友畅捷通T+财务软件的时候碰到一个很奇怪的问题，安装SQL2008R2数据库时，出现了一个报错，错误提示如下：
MOF编译器无法连接WMI服务器。原因可能是语义错误(例如，与现有WMI知识库不兼容)或实际错误(例如，WMI服务器启动失败)
操作系统是windows 7 原版纯净版系统 64位的，错误提示图片如下：
依次尝试过如下办法：
1、删除注册表中的PendingFileRenameOperations，操作步骤如下：
a、在开始-&gt;运行中输入regedit
b、到HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager 位置
c、在右边窗口右击PendingFileRenameOperations，选择删除，然后确认
具体图示和过程可以参考一下：http://www.ufidawhy.com/shujuku/guaqi.html 这篇文章。
2、参考彻底删除SQL数据库这篇文章删除了注册表和添加删除程序中的数据库，包括文件夹都删除干净了。
3、在网上查询，发现是：创建窗口句柄之前,不能在控件上调用 Invoke 或 BeginInvoke。原因是，VC 2010的一个服务程序mscorsvw.exe进程调用Invoke导致的，但是我这并没有这2个进程，操作方法是按 ctrl+alt+del 键，在任务管理器中查看有没有对应的进程。
4、参照怎么关闭Windows 7和Windows 8的UAC控制？ http://www.yyrjxz.com/xue/win8andwin7uac.html 关闭了UAC控制。
5、参照网上的答案，在安装过程中快结束的时候提示"mof 编译器无法连接到wmi服务器"检查一下 windows下的system32 中是否有framedyn.dll这个系统文件，如果没有到system32 下的wbem文件中拷贝framedyn.dll到system32 目录",可是我这边的情况下，2个目录下都有，不管是system32还是syswow64下都有。
6、最后发现服务里有一个WMI服务，启动一下，再重装，发现问题解决了。启动方法，开始，运行，输入 services.msc，进入后找到wmi 服务，右击，启动就OK了。
7、以上方法如果都无效，那么 www.yyrjxz.com 建立您直接重装系统，这样能够更快解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/499725dd1bc6fcf7ecf1ea24aa80adea/" rel="bookmark">
			zabbix部署监控mysql_部署zabbix监控mysql (一) 安装zabbix
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部署zabbix监控mysql
(1)安装LAMP环境
[root@localhost ~]# yum -y installmysql-server http php
(2)安装zabbix web所需要的依赖包
[root@localhost ~]# yum -y installmysql-dev gcc net-snmp-devel curl-devel perl-DBI php-gd php-mysql php-bcmathphp-mbstring php-xml
安装Fping：
[root@localhost zabbix]# tar xffping-3.13.tar.gz
[root@localhost zabbix]# cd fping-3.13
[root@localhost fping-3.13]# ./configure
[root@localhost fping-3.13]# make&amp;&amp; make install
(3)创建Zabbix运行的用户
[root@localhost fping-3.13]# groupaddzabbix
[root@localhost fping-3.13]# useradd -gzabbix zabbix
[root@localhost fping-3.13]# chownroot:zabbix /usr/local/sbin/fping
[root@localhost fping-3.13]# chmod 4710/usr/local/sbin/fping
(4)安装zabbix server：
[root@localhost zabbix]# tar xfzabbix-3.0.2.tar.gz
[root@localhost zabbix]# cd zabbix-3.0.2
[root@localhost zabbix-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/499725dd1bc6fcf7ecf1ea24aa80adea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7204c598f2737f2b036bcf062a897a94/" rel="bookmark">
			kettle查询mysql获取uuid_kettle生成主鍵UUID和調用轉換作業
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kettle
項目中使用軟件，我的感覺是不必追求最新版，穩定是優先考慮的。3.2版本也是不錯的。使用中感覺kettle總體表現還是不錯的，使用方式也都比較好理解。但其中個別的地方還是給初學者制造了些小麻煩。
以下是我的一點經驗：
1. 資源庫在原有數據庫中建立了很多Kettle的表，建議最好不用，就用文件存儲
2. 參數的傳遞問題
Job 定時任務的時候，可以在其所包含的Transformation中，由“獲取系統信息”組件定義時間參數，由“表輸入”
組件的SQL動態獲取。
不過SQL中的參數不能用${param}這種形式獲取，而是用？來代替。其中的緣由可以參見官方FAQ里面Argument 和 variables 的區別。
3. UUID的生成
如果你的ID是UUID，需要kettle來生成。就用“腳本”里面的“Modified JavaScript Value”組件，代碼如下：
Js代碼 //Script here
function UUID(){
this.id = this.createUUID();
}
UUID.prototype.valueOf = function(){ return this.id; }
UUID.prototype.toString = function(){ return this.id; }
UUID.prototype.createUUID = function(){
var dg = new Date(1582, 10, 15, 0, 0, 0, 0);
var dc = new Date();
var t = dc.getTime() - dg.getTime();
var h = '';
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7204c598f2737f2b036bcf062a897a94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31205a00e0d7f6c287cc5da8359df9b7/" rel="bookmark">
			C 语言和 C&#43;&#43;、C# 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天突然好奇C、C++和C#这三门语言都有个C，那么它们之间到底有什么关联呢。所以就去Google了，找到了这篇文章：Understanding the Differences Between C#, C++, and C - C# Station。看完感觉写得挺好的，就打算翻译出来。
需要注意的是，本人技术十分有限，因此翻译的准确性可能有待商榷，建议有英语基础的同学，可直接阅读源站。
开始 如果你是一个有志向的程序员，那么你可能会很难决定先学哪门编程语言。世界上有相当多的编程语言，但是在C、C++和C#中哪一个是最有用的呢？
学好C++才是入职大厂的敲门砖！ 当年要是有这课，我的C++也不至于这样
你可能也曾听闻过C语言的这三个变种（variation）。在你做出选择之前，需要先了解一下它们的区别。
C 我们从C语言开始讲起，因为它是三者中最老的、使用范围最广的语言。Dennis Ritchie在1972年创造了C语言并在1978年公布。Ritchie设计C的初衷是用于开发新版本的Unix。
在那之前，Unix使用的是汇编语言（assembly language），它是计算机可读取的最低级的编程。C语言的诞生彻底改变（revolutionize）了编程和操作系统。其余的，正如他们所说，是一段历史了。（译者注：就是夸C语言很屌就是了。）
译者注：语言的低级或者高级，并不是说语言的厉害程度。低级指的是更加接近于底层，计算机执行起来更快但是不利于人类理解，高级则相反。
C也是一门低级的编程语言，它的效率和汇编接近。它提供了基本级（base-level）的访问内存方式，对运行时支持的要求非常小。
尽管它已经诞生了40多年，但是它依然得到广泛的使用（译者注：看TIOBE就知道了，2019年12月排名第二，仅次于Java）。开发人员仍然使用它在操作系统、内核级软件开发、硬件驱动和需要与旧代码一同工作的应用程序上。
许多老牌的学校会建议C语言作为首选语言，因为许多后来的语言借鉴了C。由于C的年龄原因，使用C也可能带来一些安全性的提升。因为使用C的用户比较少，因此它比较不容易成为黑客的目标。
C++ C++是作为C的扩展来开发的。它是由丹麦的哲学博士（Ph.D.）Bjarne Stroustrup开发的。他的目标是增强C语言并在不牺牲速度和效率的前提下为其增加面向对象（object-oriented）的能力。
C++被认为是一种中级的语言，因为它基于低级的C语言所创建并拥有一些高级的能力。
自从1985年其发布以来，它已成为了另一个高产的编程语言。在开发操作系统时它会和C一同协作，但是在一些high-profile服务器和PC软件上也能看到它的身影。
译者注：high-profile，可以理解为高调的意思，例如游戏PC领域的雷蛇、外星人系列。
如果你的C语言功底扎实，那么你理解C++也是易如反掌；不过，如果你想立刻体验面向对象编程的话，也可以将C++作为你的第一门编程语言。（译者注：不是应该第一时间先找个对象吗？）
C# C#是一门高级的面向对象的编程语言，同样也是作为C的扩展所创建的。它是在2002年，由微软的一个团队的领头人Anders Hejlsberg开发的。它是基于.NET框架的，但是它的核心依然是C语言。
C#将代码编译成字节码（byte-code）而不是机器码（0101的二进制）。这意味着它会在一台虚拟计算机上运行，这台虚拟机实时（on the fly）将字节码翻译成机器码。它在C语言的基础上添加了垃圾回收（garbage collection）、未初始化的变量检查（uninitialized variable checking）、边界检查（bound checking）和类型检查（type checking）这些特性。
译者注：翻译到这里的时候我就想到了Java以及JVM。
C#常见于内部或者企业应用而不是商业软件。可以在.NET框架中的客户端和服务器端开发中找到。
虽然C#是三门语言中技术上最复杂的，但是它的语法相对于C和C++来说更不容易出错，因此相对来说它的学习会更快点。
主要的区别 虽然C和C++有许多的不同但是它们本质上是非常相似的编程语言。C#的话，换句话说它和Java会更相似。
C vs. C++ 要完全理解C和C++的区别，你需要理解什么是面向对象。编程语言中的面向对象这个术语，最早起源于上个世纪50年代末或者60年代初，由麻省理工学院（MIT）提出。
面向对象编程（OOP）使用了一种叫做对象（object）的概念。一个对象是一个类（class）或者一个程序代码模板的实例。类可以由数据和代码过程（procedure，也叫做方法（method））组成。
C语言是不支持面向对象的，这也是它和C++的最大的区别。C是纯过程式（procedural）编程语言，而C++是既支持过程式又支持面向对象的混合编程语言。
以下是C和C++的其他不同点：
C++作为C的扩展，意味着它可以运行大部分C代码。但是反过来，C去运行C++的代码，就不行了。作为一种面向对象的语言，C++支持多态（polymorphism）、封装（encapsulation）和继承（inheritance），但是C不支持。在C中，数据和函数是“自由的实体”（free entities），这意味着你可以使用外部代码来操作它们。但是由于C++将数据和函数封装到一个单一的对象，就等同于对外部代码隐藏了，所以外部代码无法操作其数据和函数。C++使用名称空间（namespace）将代码组织为逻辑组并阻止了名称冲突（collision）。当你的代码基（code base）包含了多个库的时候会发生名称冲突。C不使用名称空间。C使用函数来实现输入和输出，而C++使用对象来实现输入和输出。C++支持引用变量（reference variable），而C不支持。引用变量是已存在变量的别名，可用于加速编码。C不支持错误和异常处理，但是C++支持。 C++ vs. C# 作为一款更现代的编程语言，C#被设计于与当前微软.NET框架共同工作，在客户端和web应用程序中均有涉猎。
C++是一门面向对象的语言，而C#被认为是一门面向组件（component）的编程语言。面向对象编程聚焦于将多个类结合起来链接为一个可执行的二进制程序，而面向组件编程使用可交换的代码模块（可独立运行）并且你不需要知道它们内部是如何工作的就可以使用它们。
以下是C++和C#的主要区别。
C++将代码编译成机器码，而C#将代码编译成CLR（一种.NET框架的虚拟机组件，它会被ASP.NET所解析）。C++要求用户手动处理内存，但是C#运行在虚拟机中，而虚拟机会自动处理内存。C#不使用指针（pointer），而C++可以在任何时候使用指针。【C#为了类型安全，默认并不支持指针(与Java一样)，但其也有指针，不过最好不要使用，因为指针不安全，在C＃中的delegat已经就算是等于C＋＋中的指针了】虽然C++的设计是用于Unix或类Unix的系统，但是它可以运行在任何的平台上。C#虽然已标准化，但是基本上只在Windows的环境下运行。C++可以创建独立（stand-alone）和控制台（console）程序。C#可以创建控制台，Windows，http://ASP.NET和移动（mobile）程序，但不能创建独立程序。 C vs. C# 虽然C和C#在技术上相互有所关联，但是它们几乎是完全不同的语言，因此它们之间有更多的不同之处。有C语言功底的同学在学习C#时会比较简单，因为有些语法是相似的；不过，即使你没有C语言基础一样可以轻松学习C#，因为它的语法非常简单（译者注：原文是forgiving，宽容）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31205a00e0d7f6c287cc5da8359df9b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a78073476db72912c630bb190ef5b7e/" rel="bookmark">
			SparkSQL中的三种Join及其具体实现（broadcast join、shuffle hash join和sort merge join）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/wlk_328909605/article/details/82933552
1.小表对大表（broadcast join） 将小表的数据分发到每个节点上，供大表使用。executor存储小表的全部数据，一定程度上牺牲了空间，换取shuffle操作大量的耗时，这在SparkSQL中称作Broadcast Join
Broadcast Join的条件有以下几个：
*被广播的表需要小于 spark.sql.autoBroadcastJoinThreshold 所配置的值，默认是10M （或者加了broadcast join的hint）
*基表不能被广播，比如 left outer join 时，只能广播右表
2.Shuffle Hash Join 因为被广播的表首先被collect到driver段，然后被冗余分发到每个executor上，所以当表比较大时，采用broadcast join会对driver端和executor端造成较大的压力。
spark可以通过分区的形式将大批量的数据划分成n份较小的数据集进行并行计算.
利用key相同必然分区相同的这个原理，SparkSQL将较大表的join分而治之，先将表划分成n个分区，再对两个表中相对应分区的数据分别进行Hash Join，
这样即在一定程度上减少了driver广播一侧表的压力，也减少了executor端取整张被广播表的内存消耗。
*Shuffle Hash Join分为两步：
对两张表分别按照join keys进行重分区，即shuffle，目的是为了让有相同join keys值的记录分到对应的分区中
对对应分区中的数据进行join，此处先将小表分区构造为一张hash表，然后根据大表分区中记录的join keys值拿出来进行匹配
*Shuffle Hash Join的条件有以下几个：
分区的平均大小不超过spark.sql.autoBroadcastJoinThreshold所配置的值，默认是10M
基表不能被广播，比如left outer join时，只能广播右表
一侧的表要明显小于另外一侧，小的一侧将被广播（明显小于的定义为3倍小，此处为经验值）
3.大表对大表（Sort Merge Join） 将两张表按照join keys进行了重新shuffle，保证join keys值相同的记录会被分在相应的分区。分区后对每个分区内的数据进行排序，排序后再对相应的分区内的记录进行连接
因为两个序列都是有序的，从头遍历，碰到key相同的就输出；如果不同，左边小就继续取左边，反之取右边(即用即取即丢)
package day05 import org.apache.spark.sql.{DataFrame, SparkSession} /** * @author WangLeiKai * 2018/10/3 18:24 */ object SparkSQLJoinDemo { def main(args: Array[String]): Unit = { //程序的入口 val spark = SparkSession.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a78073476db72912c630bb190ef5b7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebc830230e7a8e0a56e703bf6fdba659/" rel="bookmark">
			Matlab 特殊函数绘图（求和函数、特殊函数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matlab 特殊函数绘图（求和函数） 代码如下：
clear all clc D=2;%三维 x1=linspace(-15,25,500); x2=x1;%画X1轴和X2轴 [X1,X2]=meshgrid(x1,x2);%形成网格 A=sqrt(1/D*(X1.^2+X2.^2)); B=cos(2*pi*X1)+cos(2*pi*X2); Z=-20*exp(1)*exp(-0.2*A)-exp(1/D*B)+20+exp(1); meshc(X1,X2,Z) xlabel('X1') ylabel('X2') zlabel('Z') title('Ackley Function') colormap(hsv) 绘图结果：
colormap(cool)中的cool可替换为hot、prink等等结果只是颜色不同：
代码如下：
clear all clc m=10; D=2; x1=linspace(-10,pi,200); x2=x1; [X1,X2]=meshgrid(x1,x2); A=sin(X1).*(sin(X1.^2/pi)).^(2*m); B=sin(X2).*(sin(2*(X2.^2)/pi)).^(2*m); Z=-(A+B); mesh(X1,X2,Z); xlabel('X1') ylabel('X2') zlabel('Z') title('Michalewics') colormap(summer) 绘图结果：
参考网址：
[1]:https://wenku.baidu.com/view/70e2b8f118e8b8f67c1cfad6195f312b3169eb2f.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44807d8d811436db5ba95c02d95b9c12/" rel="bookmark">
			springboot之aop切面获取请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot之aop切面获取请求 项目场景： 在学习springboot的博客开发中，通过aop切面，对博客中的操作进行记录
问题描述： 问题：
在切面方法中，无法获取请求的参数和类名，方法，ip等
解决方法： @Before("log()")//调用log方法 public void doBefore(JoinPoint joinPoint){ System.out.println("------程序执行之前-----------"); ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = requestAttributes.getRequest(); String url = request.getRequestURL().toString(); String ip = request.getRemoteAddr(); Object[] args = joinPoint.getArgs(); // 类名--&gt;方法名 String methodName = joinPoint.getSignature().getDeclaringTypeName()+"--&gt;" +joinPoint.getSignature().getName(); getRequestLog getRequestLog = new getRequestLog(url,ip,methodName,args); System.out.println(getRequestLog); } 过程： RequestContextHolder是一个包含了request请求的容器，所以要获取请求中的信息，自然要从容器中获取。
然而RequestContextHolder只能获取RequestAttributes对象，要取得request，必须从ServletRequestAttributes获取
通过查看底层的源码，可以发现ServletRequestAttributes是继承了AbstractRequestAttributes，然后AbstractRequestAttributes继承了RequestAttributes
也就是说ServletRequestAttributes是RequestAttributes的子类，所以直接强转就可以了
通过强转后的ServletRequestAttributes直接getRequest，即可得到request对象。
使用了内部类封装所需要打印的值
// 内部类，封装需要得到的值 private class getRequestLog{ private String url; private String ip; private String methodName; private Object[] requestParms; public getRequestLog() { } public getRequestLog(String url, String ip, String methodName, Object[] requestParms) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44807d8d811436db5ba95c02d95b9c12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59e2c47ad7ca8b67cb833b7e01ba21a6/" rel="bookmark">
			根据Morgan指纹预测分子logP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from rdkit import Chem, DataStructs from rdkit.Chem.Crippen import MolLogP from rdkit.Chem import AllChem import numpy as np import torch import torch.nn as nn file = "shulin_test.log" with open(file,'r')as f: lines = f.readlines() smiles = [l.split()[1] for l in lines] X,Y = [], [] for s in smiles: m = Chem.MolFromSmiles(s) fp = np.array(AllChem.GetMorganFingerprintAsBitVect(m,2,nBits=1024)) logp = MolLogP(m) X.append(fp) Y.append(logp) X = torch.from_numpy(np.array(X)).float() Y = torch.from_numpy(np.array(Y)).float() X_train = X[:400] Y_train = Y[:400] X_test = X[200:300] Y_test = Y[200:300] class LinearRegressor(torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59e2c47ad7ca8b67cb833b7e01ba21a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/434ec620420e387cb5f0fdfd5564e507/" rel="bookmark">
			阿里云新年活动 轻量云服务器1H2G5M仅需要86元/年
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云在新年的时候推出针对轻量服务器的特别活动 , 活动推出的1核心2GB内存5M带宽版的轻量服务器仅售96元/年，通过云小站领取的￥10代金券的话，一年只需要￥86元。轻量服务器有别于阿里云ECS，相对来说轻量服务器性能更高均使用SSD，价格更低。1000G的流量限制对个人使用还是绰绰有余了。
活动地址： 阿里云-云小站
领取步骤： 第一步：进入阿里云-云小站活动首页：阿里云-云小站
第二步：找到轻量服务器￥10 代金券并领取。
代金券领取
第三步：点击「购买」并选择对应的配置
配置说明：
地域：该活动目前支持的区域只有华东1（杭州）、华东2（上海）。
镜像类型：应用镜像是已经配置好了环境，拿来即用的。如果没有您的业务需求，需要安装系统镜像，自己部署环境。
第四步：付款的时候且记选择￥10元代金券。
轻量服务器： 阿里云轻量服务器：1核心2GB内存5M带宽包含流量为每月1000GB ，超出配额后每GB流量为0.8元每小时计费一次。
该活动仅限新用户、仅限新用户、仅限新用户。已注册的建议用身边朋友身份购买。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21ec4bc21df7e5766870e095eed5958d/" rel="bookmark">
			mysql主从不同步不报错_MySQL主从不同步解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、由于binlog日志带多删除了几个后发现MySQL主从不同步
mysql&gt; show slave status\G;
Slave_IO_Running: No
Slave_SQL_Running: Yes
查看报错日志为
[ERROR] Slave I/O: Got fatal error 1236 from master when reading data from binary log: 'Could not find first log file name in binary log index file',
解决方式
从服务器配置：
主服务器查看
mysql&gt; show master status;
+------------------+----------+--------------+------------------+
| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql-bin.000005 | 106 | | |
+------------------+----------+--------------+------------------+
1 row in set (0.00 sec)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21ec4bc21df7e5766870e095eed5958d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82aa2e038159374a02f7ba32ac3e9a2a/" rel="bookmark">
			python自动化常见面试题_有了这份Python自动化测试面试经典题，你还怕啥？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信大家经历过许多面试都会有这样的感受：好不容易通过了 2 -3轮技术面试，但是薪资不够理想；要么被面试的测试专家虐的不要不要的。但每一次的面试也能让自己认识到不足之处，这样才有利于后续拿到理想的offer。
今天，牛鹭学子对面试题进行了简单的总结回顾，以代码方面的问题为主，经验不足，回答水平也有限，现在分享出来，希望与大家一起交流探讨。
Python 自动化测试面试题目汇总
1、super 是干嘛用的？在 Python2 和 Python3 使用，有什么区别？为什么要使用 super？请举例说明。
答：
super 用于继承父类的方法、属性。
super 是新式类中才有的，所以 Python2 中使用时，要在类名的参数中写 Object。Python3 默认是新式类，不用写，直接可用。
使用 super 可以提高代码的复用性、可维护性。修改代码时，只需修改一处。
代码举例：
class sonClass(baseClass):def test2(self):super().test1(num)
son = sonClass()son.test1(11)
2、阅读以下代码，推导最后结果：
def test():for i in range(4):yield ig = test()for n in [1, 10, 5]:g = (add(n, i) for i in g)print(list(g)) # 结果是 [15, 16, 17, 18]
答： 所有的结果都是生成器表达式，不调用它，不从里面取值，就不干活。附上我的推导过程：
n = 10g = (add(n,i) for i in (add(n,i) for i in test()))# print(list(g)) # [20, 21, 22, 23]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82aa2e038159374a02f7ba32ac3e9a2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bfe1cdab12a4a984145b88ded9d2489/" rel="bookmark">
			SpringMVC的工作原理图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringMVC的工作原理图：
SpringMVC流程 1、 用户发送请求至前端控制器DispatcherServlet。
2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。
3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。
4、 DispatcherServlet调用HandlerAdapter处理器适配器。
5、 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。
6、 Controller执行完成返回ModelAndView。
7、 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。
8、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。
9、 ViewReslover解析后返回具体View。
10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。
11、 DispatcherServlet响应用户。
组件说明： 以下组件通常使用框架提供实现：
DispatcherServlet：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。
HandlerMapping：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 HandlAdapter：通过扩展处理器适配器，支持更多类型的处理器。
ViewResolver：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。
组件：
1、前端控制器DispatcherServlet（不需要工程师开发）,由框架提供
作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。
用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。
2、处理器映射器HandlerMapping(不需要工程师开发),由框架提供
作用：根据请求的url查找Handler
HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。
3、处理器适配器HandlerAdapter
作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler
通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。
4、处理器Handler(需要工程师开发)
注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler
Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。
由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。
5、视图解析器View resolver(不需要工程师开发),由框架提供
作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）
View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。
一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。
6、视图View(需要工程师开发jsp...)
View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf...）
核心架构的具体流程步骤如下：
1、首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；
2、DispatcherServlet——&gt;HandlerMapping， HandlerMapping 将会把请求映射为HandlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；
3、DispatcherServlet——&gt;HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；
4、HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；
5、ModelAndView的逻辑视图名——&gt; ViewResolver， ViewResolver 将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bfe1cdab12a4a984145b88ded9d2489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d29abbbf9033230a85530e6c15656e0/" rel="bookmark">
			文本相似度计算——Simhash算法（python实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		互联网网页存在着大量重复内容，必须有一套高效的去重算法，否则爬虫将做非常多的无用功，工作时效性无法得到保证，更重要的是用户体验也不好。业界关于文本指纹去重的算法众多，如 k-shingle 算法、google 提出的simhash 算法、Minhash 算法、百度top k 最长句子签名算法等等，本文主要介绍simhash算法以及python应用.
simhash 与传统hash 的区别
传统的Hash算法只负责将原始内容尽量均匀随机地映射为一个签名值，原理上仅相当于伪随机数产生算法。传统的hash算法产生的两个签名，如果原始内容在一定概率下是相等的；如果不相等，除了说明原始内容不相等外，不提供任何信息，因为即使原始内容只相差一个字节，所产生的签名也很可能差别很大。所以传统的Hash是无法在签名的维度上来衡量原内容的相似度，而SimHash本身属于一种局部敏感哈希算法，它产生的hash签名在一定程度上可以表征原内容的相似度。
我们主要解决的是文本相似度计算，我们降维生成hash签名也是用于这个目的。看到这里估计大家就明白了，我们使用的simhash就算把文章中的字符串变成 01 串也还是可以用于计算相似度的，而传统的hash却不行。我们可以来做个测试，两个相差只有两个字符的文本串，“你妈妈喊你回家吃饭哦” 和 “你妈妈叫你回家吃饭啦”。
通过simhash计算结果为：
1000010010101101111111100000101011010001001111100001001011001011
1000010010101101011111100000101011010001001111100001101010001011
通过传统hash计算为：
0001000001100110100111011011110
1010010001111111110010110011101
大家可以看得出来，相似的文本simhash只有部分 01 串变化了，而普通的hash却不能做到，这个就是局部敏感哈希的魅力。
simhash简介
simhash 是 google 用来处理海量文本去重的算法。 simhash 可以将一个文档转换成一个 64 位的字节，暂且称之为特征字。判断文档是否重复，只需要判断文档特征字之间的汉明距离。根据经验，一般当两个文档特征字之间的汉明距离小于 3， 就可以判定两个文档相似。
主要步骤：在新拿到文本之后需要先进行分词，这是因为需要挑出TopN个词来表征这篇文本，并且分词的权重不一样，可以使用相应数据集的tf-idf值作为分词的权重，这样就分成了带权重的分词结果。
之后对所有分词进行哈希运算获取二值化的hash结果，再将权重与哈希值相乘，获得带权重的哈希值，最后进行累加以及二值化处理.
分词 使用分词手段将文本分割成关键词的特征向量，分词方法有很多一般都是实词，也就是把停用词等都去掉之后的部分，使用者可以根据自己的需求选择.最后形成去掉噪音词的单词序列并为每个词加上权重. 例如:
傲游AI 专注 于 游戏 领域 多年 AI技术 积淀 一站式 提供 文本 图片 音视频 内容 审核 游戏AI 以及 数据 平台 服务
目前的词只是进行了分割，但是词与词含有的信息量是不一样的，比如傲游AI 游戏 审核 这三个词就比 专注 服务 以及更能表达文本的主旨含义，这也就是所谓信息熵的概念。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d29abbbf9033230a85530e6c15656e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a5e1308aaeb39e5aff3ac62ceb8cdef/" rel="bookmark">
			python支持向量机实验_Python SVM(支持向量机)实现方法完整示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文实例讲述了python SVM(支持向量机)实现方法。分享给大家供大家参考，具体如下：
运行环境 Pyhton3 numpy(科学计算包) matplotlib(画图所需，不画图可不必)
计算过程
st=&gt;start: 开始
e=&gt;end: 结束
op1=&gt;operation: 读入数据
op2=&gt;operation: 格式化数据
cond=&gt;condition: 是否达到迭代次数
op3=&gt;operation: 寻找超平面分割最小间隔
ccond=&gt;conditon: 数据是否改变
op4=&gt;operation: 输出结果
st-&gt;op1-&gt;op2-&gt;cond
cond(yes)-&gt;op4-&gt;e
cond(no)-&gt;op3
啊，这markdown flow好难用，我决定就画到这吧=。=
输入样例 /* testSet.txt */
3.542485 1.977398 -1
3.018896 2.556416 -1
7.551510 -1.580030 1
2.114999 -0.004466 -1
8.127113 1.274372 1
7.108772 -0.986906 1
8.610639 2.046708 1
2.326297 0.265213 -1
3.634009 1.730537 -1
0.341367 -0.894998 -1
3.125951 0.293251 -1
2.123252 -0.783563 -1
0.887835 -2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a5e1308aaeb39e5aff3ac62ceb8cdef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63f39baa259dd3bc201febb456236d14/" rel="bookmark">
			mysql并发写 主键重复_数据库“锁”事一例：并发情景下重复主键问题方案讨论...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做的一个账单计息功能，其中，账单表的主键是BillId，varchar类型，BillId取值形如B0000001，生成规则是每次新增记录时先从账单表里计算出最大的BillId数字，然后+1再转换后作为新增记录的BillId。例如，B0000001、B0000002。
逻辑很简单，但考虑到并发，技术上就要费点心了。
为了简化场景，这里我写了一些测试用例，涉及到一个包含两个字段的表student(id int, sno varchar(32)),PK是id。数据库是引擎为InnoDB的Mysql5。InnoDB支持事务操作。
并发处理之lock
这段逻辑用程序来实现的话，用lock关键字，就可以保证多线程情况下同时只能有一个线程来访问资源。
static object syncRoot = new object();private void AddStudent_Lock(stringname)
{lock(syncRoot)
{object maxId = ExecuteScalar("select max(id) from student");if (maxId == null || maxId ==DBNull.Value)
{
maxId= 0;
}int newId = Convert.ToInt32(maxId) + 1;string sql = "INSERT INTO student VALUES(" + newId + ",'" + name + "');";
ExecuteNonQuery(sql);
}
}
测试用例：
[TestMethod]public voidTest3()
{
ExecuteScalar("DROP TABLE IF Exists student;");
ExecuteScalar("CREATE TABLE student(id INT NOT NULL,sno varchar(255),PRIMARY KEY (id));"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63f39baa259dd3bc201febb456236d14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/332191067d86e3fa43945b71794afd0d/" rel="bookmark">
			python怎么输出计算结果_在Python中我们最常用的用来在屏幕上输出计算结果的功能函数是____________。(2.5分)_学小易找答案...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【判断题】如果希望循环是无限的,我们可以通过设置条件表达式永远为True来实现无限循环。(2.0分)
【判断题】elif语句是 else 语句和if语句的组合。(2.0分)
【判断题】在循环体中使用break语句可以跳出循环体。(2.0分)
【单选题】执行下列程序段,输出的结果是____________。 x = 7.0 y = 5 print(x % y) (2.5分)
【判断题】Python 中的中pass表示的是空语句(2.0分)
【单选题】"12"+"34"字符串运算的命令运行结果是"____________"。(2.5分)
【单选题】阅读下面程序,选择正确输出结果_______________。 x = 10 y = 20 if x &gt; 10: if y &gt; 20: z = x + y print('z is', z) else: print(x) (5.0分)
【单选题】表达式-13//3,13//3,13//-3,-13//-3的计算结果分别是____________。(2.5分)
【单选题】阅读下面代码,选择正确的输出结果_______________。 grade = 90 if grade &gt;= 60: print( 'D') elif grade &gt;= 70: print( 'C') elif grade &gt;= 80: print( 'B') elif grade &gt;= 90: print( 'A') (4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/332191067d86e3fa43945b71794afd0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49ed9178c569aebb01d13939fe969ff5/" rel="bookmark">
			通过xml文件解锁word
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过xml文件解锁word 有时候下载下来的word被加锁，只能读，不能编辑。比如通过DeepL翻译的文档，就不能编辑，这个时候怎么办呢？通过xml文件来解锁word，操作稍微麻烦，但是不会修改文件内容和格式。
比如： 启动编辑后，word中的工具栏依然是不能编辑的状态。
打开：文件-信息，可以看到，文档处于保护状态，被限制了编辑。
点击：限制编辑-停止保护，可以看到，需要输入密码，我当然不知道密码，也没钱订阅DeepL Pro，又想修改文档，那怎么办呢？
解锁 点击：文件-另存为-选择保存位置（注意：保存类型要选xml后缀的那个）-保存
打开刚才保存的xml文件，搜索documentProtection
将documentProtection改为unDocumentProtection，保存。
在用word打开刚才的xml文件
用word打开上面的xml文件后，可以看到工具栏可以使用了，但不要急，这时还是xml文件，再用word转一下就可以了。点击：文件-另存为-选择保存位置（注意：保存类型改为.docx）-保存
OK，完成，现在保存下来的word已经可以编辑了。（中间过程的xml文件可以删除掉了） 创作不易，喜欢的话加个关注点个赞，谢谢谢谢谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ff31c298f29ffbc28e9816592d61c8f/" rel="bookmark">
			REACT路由懒加载&#43;二级路由&#43;推荐路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		没用懒加载 直接引入，但组件较多时就会耗费性能，所以我们利用高阶组件，将我们要导入的组件包裹起来，要用到再去调用。
定义一个lazy函数，使用方法
ES6的import返回的是一个Promise对象，会立即执行，所以我们用一层箭头函数封装起来，当我们需要用到这个组件的时候，就会执行lazy函数，Lazy函数传入一个箭头函数，我们在高阶组件的生命周期函数中，取出该组件，再用返回一个类组件，该类组件实际上也就是Welcome
这样，只有当我们使用带该组件时，才会调用lazy函数，才会返回组件，否则不返回。达到一个路由懒加载的效果
二级路由 先看一级路由
引入我们的跟组件App,然后在App里面设置一级路由，
效果
然后我们想通过welcome去访问welcome组件， 在APP.JSX中必须写props.children，因为我们访问的一级二级路由都是作为App的子组件的。
这是welcome组件，通过Route,path=/welcome，访问
接着设置二级路由，思路同一级路由一样，把WELCOME组件当作App一级组件来看，如图 利用一个函数，将Welcome组件包裹起来，然后通过在里面放Route，注意路劲要写全，然后在Welcome组件中也需要写props.childern,因为A和B组件是作为WELCOME的子组件的，这样才会显示，不写是不会显示的。
效果是没有显示出来，注意！！！，二级路由，
这里不能加exact精确匹配，否则你输入/welcome/a，他是不会匹配到welcome这个组件，自然而然也不会匹配到里面的子组件。
这样写就对了，效果
三级路由依此类推。
二级路由也可以不用懒加载了， 如图
写完welcome组建后，用函数将其封装起来，并且将shop写在里面，那这个shop,
我们写完之后不要直接导出，导出一个Route，让其组件指向Shop即可。
推荐路由 接下来用的路由方式是我觉得比较省力的
我把routes都写在了一起，这样写的时候方便很多，不用每个组件都写Route,
这是我的根组件，就是我的入口组件就是这个。
React.Suspense是用来当路由懒加载还未显示出来的时候，作为优化交互，提醒用户的效果。
RenderRoutes是我写的一个组件，
我将写出来的routes传入这个组件，然后如果要重定向，我就写一个Redirect,如图，
这个一定要加exact，否则会出现，如果我们设置当去’/‘的时候跳到’/welcome‘,不设置这个的话，他是模糊匹配，那么你所有的跳转都包含’/’，那么不管你跳到哪都会回到’/welcome‘,所以得设置精准匹配
当我们去to时，我就让他的组件为redirect返回的组件。也就是我们要跳去的界面。
接下来写routes，因为每个routes是数据JSON数据，里面一个对象代表一个路由
这个对应这个
当我输入指定的路由，就调转到那个组件，而且还要把route传过去，因为，如果有children的话，我们还是要再做处理的。如这个welcome就是根组件的子组件，故要在app组件里面处理，
我们封装一个函数导出，然后通过我们刚才传的route，将里面的children传给RenderRoutes，因为RenderRoutes是返回Route组件的，而且因为根组件下面的子组件都要放在App里面，所以才要用App包裹起来，如果你的子组件不是放在App里面的，或者App这个组件不用来渲染东西，你也可以不用App包裹，设置一个重定向即可。接下来welcome里面也是有Children的，所以我们也要去welcome里面处理一下，思路一样
，而我们的Project是没有children的，所以不需要处理
效果
看似麻烦，其实思路很容易，而且这个一开始写麻烦而已，后面要加上别的页面的路由就很容易了。
思路就是，有children的组件，我就要去处理，没有children的组件，就不用处理了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87a22e70c18afb7e5ce82294caf2e030/" rel="bookmark">
			selenium 后台运行设置handless模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 selenium 后台运行设置handless模式 测试脚本调试完毕之后，部署到服务器运行，此时，需要将selenium的执行方式，切换为后台运行，也就是无界面运行
chrome_option = webdriver.ChromeOptions() chrome_option.add_argument('--headless') chrome_option.add_argument("--window-size=1920,1050") #调节窗口size self.driver = webdriver.Chrome(options=chrome_option) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56d89d7c5b38903683e39cc92a5f1f46/" rel="bookmark">
			idea生成类模板和方法模板（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​ 当我们使用idea工具进行代码开发的时候，注释是必不可少的东西。但是总是重复的写注释或者粘贴注释，不但麻烦，而且浪费时间。那么，能不能在写代码的时候，自动生成注释或者用很少的步骤，就可以调用注释呢？当时可以的了。先展示一下效果图，如下图：
一、配置类注释模板 1.点击File–&gt;setting进入设置页面，如图一，也可以通过快捷键Ctrl+Alt+S进入设置页面；
2.打开Editor–&gt;File and Code Templates标签，点击右侧的Class标签，在Class标签右侧的public class ${NAME}上输入自己想要类的注释模板，如图二；其中$DATE表示日期，格式和系统的短日期格式保持一致；$TIME$表示时间，只显示到分钟。
完成之后的效果图三
模板如下：
/** * &lt;p&gt;TODO&lt;/p&gt; * * @author chaomeng * @version V1.0.0 * @date ${DATE} ${TIME} */ 可以根据自己的需求进行一些修改和变化，idea工具本身还提供另外的一些取值函数，例如获取包名${PACKAGE_NAME}，详情见图二右下角的Description标签，下图也展示了部分，可以根据自己的需求到idea工具内查看详细。
另外，配置interface和enum同理，可以根据自己的需求进行配置。
二、配置方法注释模板 配置方法注释模板和类基本相似，进入File–&gt;setting–&gt;Editor–&gt;Live Templates标签，点击右边箭头处的+符号，如图五； 2.如图六，先创建Template Group，命名为MyTemplates；在点击Live Template按钮，创建方法注释模板；
3.在创建Live Template时，Abbreviation一栏输入*，Description一栏根据自己需求书写，Template Text的内容如下：
** * &lt;p&gt;TODO&lt;/p&gt; * $param$ $return$ * @author chaomeng * @date $date$ $time$ */ 4.默认的触发方式在方法上输入/*后点击tab键修改即可，也可以在右侧的修改出发方式处修改；下侧的修改适用范围是选择该模板的使用范围，我一般选择适用Java；
5.修改变量，上图的变量定义中的变量就是$date$中定义的变量，可以根据自己的实际需求修改。
6.可以通过下拉框选择默认函数，如date变量选择了date()函数，time变量选择了time函数；
7.param和return变量使用的groovyScript脚本对格式进行了调整，具体的脚本如下：
param参数脚本：
groovyScript( "def result=''; def params=\"${_1}\".replaceAll('[\\\\[|\\\\]|\\\\s]', '').split(',').toList();if(params.size()&gt;0&amp;&amp;params[0]!=''){result+='\\r\\n';for(i = 0; i &lt; params.size(); i++) {result+=' * @param ' + params[i] +' TODO'+ ((i &lt; params.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56d89d7c5b38903683e39cc92a5f1f46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8147ba76dc0d64e947366d87bdbc3d0b/" rel="bookmark">
			oracle11g,oracle12c安装以及导入数据，连接数据库的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目中使用到oracle，但是没有系统的学习过，所以在使用的时候碰到了很多问题，在解决的时候真的让人头大，把自己遇到的问题和解决方法写下，当作是分享也方便以后查看--------有错误的地方烦请指正（非相关专业，转行菜鸟一枚）（其实很多时候都是改为一个报错，就报另一个错）。
数据库下载：http://www.oracle.com/technetwork/cn/database/enterprise-edition/downloads/index.html
1、oracle12c的安装：
(1)解压，如下图所示，将两个文件夹解压在同一个文件夹中
（2）双击
（3）如下
不勾选
（可能会提示环境不满足最低要求）
（原因是Oracle目录文件里面cvu_prereq.xml文件出错了，修改一下可。）
（找到value=windows 7的OPERATING_SYSTEM段，复制整段，并修改Release = 6.2， value = windows 10。）
然后点击“下一步”，出现下图：
创建和配置数据库：安装数据库软件并创建一个数据库实例
仅安装数据库软件：安装数据库软件，不会创建数据库实例
升级现有的数据库：升级低版本的Oracle数据库。
下一步，出现下图
如果是安装到服务器上，请选择服务器类
下一步
使用现有的Windows用户：如果选择该项，则需要指定没有管理权限的用户。
创建新Windows用户：创建一个新用户，输入用户名和密码，确认密码
使用Windows内置账户选择该项：内置账户，Oracle也建议使用权限受限的账户。
下一步
请记住用户名和口令（请不要使用特殊字符比如逗号 . 否则会出现问题）
如果密码设计太简单会报警告，不过可以忽略警告继续。
*安装完成之后，我这边使用的navicat连接的oracle(在之后又把12c卸载了安装的11g遇到的相关问题都在此处统一写下 一：
1.连接的时候提示密码不对（第一天连接上了啊，我确定都是正确的，怎么过了一夜就连接不上，怎的你俩闹矛盾了）
解决：打开sql plus
（我是用sqlplus 和navicat都用户密码错误）…
输入：sys/xxxxxxx as sysdba (xxxxxxx是你上面安装的时候设置的密码)
2. 解除锁定账号（例如解除system用户）
alter user system account unlock;
3.为system用户设置新密码（例如设置密码为(推存设置)：manager）
alter user system identified by manager;
ok(o谢特)
二：
这个问题是你在设置口令的时候,没有按照要求输入规范的口令,比如说不能输入.符号
我干脆点卸载了,重新安装了一遍…然后密码设置规范点.
ok(o谢特)
三：
这个问题最烦人：
首先：
win+R 输入services.msc 回车
看监听程序运行没，开启没用就继续往下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8147ba76dc0d64e947366d87bdbc3d0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b54e500a7107aa8d2af4cdee2569a9df/" rel="bookmark">
			mysql创建备份表sql_sql创建备份表和复制数据到备份表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、复制表结构及数据到新表
CREATE TABLE 新表 SELECT * FROM 旧表
这种方法会将oldtable中所有的内容都拷贝过来，当然我们可以用delete from newtable;来删除。
不过这种方法的一个最不好的地方就是新表中没有了旧表的primary key、Extra(auto_increment)等属性。需要自己用"alter"添加，而且容易搞错。
2、只复制表结构到新表
CREATE TABLE 新表 SELECT * FROM 旧表 WHERE 1=2
或CREATE TABLE 新表 LIKE 旧表
3、复制旧表的数据到新表(假设两个表结构一样)
INSERT INTO 新表 SELECT * FROM 旧表
4、复制旧表的数据到新表(假设两个表结构不一样)
INSERT INTO 新表(字段1,字段2,.......) SELECT 字段1,字段2,...... FROM 旧表
5、可以将表1结构复制到表2
SELECT * INTO 表2 FROM 表1 WHERE 1=2
6、可以将表1内容全部复制到表2
SELECT * INTO 表2 FROM 表1
7、show create table 旧表;
这样会将旧表的创建命令列出。我们只需要将该命令拷贝出来，更改table的名字，就可以建立一个完全一样的表
或者：
create table bus_resposition_bf as select * from bus_resposition_bf where task_id ＝17110809432850
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b54e500a7107aa8d2af4cdee2569a9df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f37507be0aabf2baf6ec011293ad4ac/" rel="bookmark">
			office修复找不到msi_Microsoft Office安装程序找不到ProPlus.WW\ProPlusWW.msi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
解决办法就是重新下载一个完整的32313133353236313431303231363533e78988e69d8331333366306538安装包，也可以在网上单独下载proplusww.msi
Microsoft Office安装程序找不到ProPlus.WW\ProPlusWW.msi的原因是原始的安装程序里面有一个ProPlus.ww文件夹，这个文件缺失了。
安装完成之后，找到安装文件里的ProPlusWW.msi，双击运行一次，然后在安装Office
注：在实际操作中，把安装目录中所有的msi文件都双击执行一下
扩展资料：
Microsoft Office还会涉及的安装问题：
因为有其他版本的 Office 而无法安装
这种错误有很多案例，因为微软没有设定好卸载程序崩溃恢复功能，导致系统误认为Office 2003已经卸载，而无法删除注册表项，导致其他版本的Office无法安装。
解决问题的方法：
1.找到当初用来安装的Office 安装包，进入后选择卸载清理。
2.如果是找不到安装包或者连卸载也出现错误，那么可以到网上下载“Office 2003 顽固卸载”进入DOS系统后等待备份注册表，等待备份完毕后按1清除数据。(如果还是不行，也可以按2或其他按键修复)
也可以来到Microsoft网站选择支持进行搜索，可以下载一个Microsoft Fix it文件。
参考资料：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e03e4a34a32244546711d8b7132c38b/" rel="bookmark">
			Ubuntu16.04 NVIDIA显卡驱动卸载与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu16.04 NVIDIA显卡驱动卸载与安装 1、NVIDIA显卡驱动下载2、NVIDIA显卡驱动卸载3、NVIDIA显卡驱动安装3.1、在线安装3.2、离线安装 1、NVIDIA显卡驱动下载 nvidia官方显卡驱动下载
2、NVIDIA显卡驱动卸载 卸载可能存在的旧版本 nvidia 驱动（对于新机器或者从未安装过nvidia显卡驱动的机器，这步可以省略，但推荐执行）； sudo apt-get remove --purge nvidia* sudo apt-get --purge remove nvidia* sudo apt-get autoremove sudo apt-get --purge remove "*cublas*" "cuda*" sudo apt-get --purge remove "*nvidia*" 注：如果系统安装过nvidia-docker插件，执行以上命令会将插件卸载
如果执行了以上步骤，输入命令nvidia-smi仍可显示驱动信息(一般情况只卸载显卡驱动使用以下命令，适用于.run文件安装的驱动)，再执行以下命令: /usr/bin/nvidia-uninstall 以上执行完成后，输入 nvidia-smi 提示无命令则表示卸载成功
3、NVIDIA显卡驱动安装 3.1、在线安装 切换到root用户，输入以下命令，添加仓库源和更新安装显卡驱动版本:
sudo apt-get install software-properties-common python-software-properties sudo add-apt-repository ppa:graphics-drivers/ppa sudo apt-get update sudo apt-get install nvidia-430 注：430对应的是显卡驱动版本
3.2、离线安装 禁用nouveau，修改文件 /etc/modprobe.d/blacklist.conf ，最后添加如下两行。 blacklist nouveau options nouveau modeset=0 更新系统修改 sudo update-initramfs -u 重启系统，验证nouveau是否已禁用，如果没有任何显示则禁用成功。 lsmod | grep nouveau 将下载的驱动程序.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e03e4a34a32244546711d8b7132c38b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54209670b1f2bd5764e5cb8e385ec511/" rel="bookmark">
			mysql获取记录条数的函数_应用mysql_num_rows()函数获取查询结果集中的记录数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 应用mysql_num_rows()函数获取查询结果集中的记录数 请输入图书名称 编号图书名称出版时间图书定价作者出版社$link=mysql_connect("localhost","root","root") or die("数据库连接失败".mysql_error());
mysql_select_db("db_database18",$link);
mysql_query("set names gb2312");
$sql=mysql_query("select * from tb_book");
$info=mysql_fetch_object($sql);
if ($_POST[Submit]=="查询"){
$txt_book=$_POST[txt_book];
$sql=mysql_query("select * from tb_book where bookname like '%".trim($txt_book)."%'"); //如果选择的条件为"like",则进行模糊查询
$info=mysql_fetch_object($sql);
}
if($info==false){ //如果检索的信息不存在，则输出相应的提示信息
echo "
对不起，您检索的图书信息不存在! ";}
do{
?&gt;
&lt;?php echo $info-&gt;id; ?&gt; &lt;?php echo $info-&gt;bookname; ?&gt;&lt;?php echo $info-&gt;issuDate; ?&gt;&lt;?php echo $info-&gt;price; ?&gt; &lt;?php echo $info-&gt;maker; ?&gt; &lt;?php echo $info-&gt;publisher; ?&gt;}while($info=mysql_fetch_object($sql));
?&gt;
找到相关记录 &lt;?php $nums=mysql_num_rows($sql);echo $nums;?&gt; 条 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3035415bce9f6ca99dfe1a0207468416/" rel="bookmark">
			onnx加速变慢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述：
将tensorflow模型转成onnx后，部署在服务器上，速度骤降，是不加速的倍
原因：不可描述
解决办法：
docker run --cpuset-cpus="0,1" -itd docker-images 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c15565f1b53ff76fd54e0e1f482ecda/" rel="bookmark">
			mysql热备工具_MySQL开源热备工具XtraBackup的原理与程序说明 | 旺旺知识库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XtraBackup是Percona发布的MySQL开源热备工具，可以在尽量不影响线上读写的情况下进行快速全备、增备。支持InnoDB, XtraDB, 和MyISAM引擎。
一.运行原理
1.权限
XtraBackup需要连接到数据库服务器，能够在服务器以及datadir目录下执行一些操作。
涉及两类用户，应该满足适当权限要求：
1)操作系统用户，需要datadir目录的READ, WRITE和EXECUTE权限。
2)数据库系统用户，需要如下权限
a.RELOAD、LOCK TABLES，为了执行FLUSH TABLES WITH READ LOCK
b.REPLICATION CLIENT，为了获取二进制日志的位置
c.CREATE TABLESPACE，为实现独立表空间表的导入导出功能，目前只支持Percona Server导入。
d.SUPER，为在复制环境下启停slave线程
所以，创建最小权限的数据库用户，需要:
mysql&gt;grant reload,lock tables,replication client,super on *.* to ‘backup’@'localhost’;
2.名词解释
redo——对于已提交的事务，重做，确保数据的更新同步到数据文件中，而不仅仅在日志文件中。
rollback——对于未提交的事务，回滚，确保数据一致性。
prepare——使用innobackupex创建的备份文件，其实可以看做是数据文件在某个时间点上的一个快照，其中可能有未提交的事务，也可能包括已提交到日志文件但是没有提交到数据文件的信息。所以要使备份文件处于一致的状态，需要对未提交的事务rollback，对已提交但未写入数据文件的事务redo! 对备份文件执行rollback和redo使其转化到一致状态的操作，这里就称为prepare。
3.备份原理
XtraBackup基于InnoDB的crash-recovery功能。它会复制innodb的data file，由于不锁表，复制出来的数据是不一致的，在恢复的时候使用crash-recovery，使得数据恢复一致。
InnoDB维护了一个redo log，又称为transaction log，事务日志，它包含了innodb数据的所有改动情况。XtraBackup在备份的时候， 一页一页地复制innodb的数据，而且不锁定表，与此同时，XtraBackup还有另外一个线程监视着transactions log，一旦log发生变化，就把变化过的log pages复制走。为什么要急着复制走呢？ 因为transactions log文件大小有限(循环日志)，写满之后，就会从头再开始写，所以新数据可能会覆盖到旧的数据。
而使用备份文件进行恢复是基于：InnoDB启动时会先去检查data file和transaction log，查看两者的一致性，然后进行crash recovery，即rollback和redo！这一步可以在InnoDB启动时执行，也可以让xtrabackup执行prepare，手动触发该过程，这样备份文件已准备就绪，在需要恢复时，可以直接使用，节省时间。
增量备份的原理：
(1)首先完成一个完全备份，并记录下此时检查点的LSN(Log Sequence Number，记录在事务日志文件中的位置。日志信息是顺序记录的，所以LSN是随时间递增的)。
(2)在进程增量备份时，比较表空间中每个页的LSN是否大于上次备份时的LSN，如果是(说明自上次备份以来有过更新)，则备份该页，同时记录当前检查点的LSN。
首先，在logfile中找到并记录最后一个checkpoint(“last checkpoint LSN”)，然后开始从LSN的位置开始拷贝InnoDB的logfile到xtrabackup_logfile；接着，开始拷贝全部的数据文件.ibd；在拷贝全部数据文件结束之后，才停止拷贝logfile。
因为logfile里面记录全部的数据修改情况，所以，即时在备份过程中数据文件被修改过了，恢复时仍然能够通过解析xtrabackup_logfile保持数据的一致。
注：以上说明只是针对XtraDB或InnoDB，针对其他如MyISAM，即使增备也会进行完整的拷贝。
实现细节：
XtraBackup以read-write模式打开innodb的数据文件，然后对其进行复制。其实它不会修改此文件。也就是说，运行XtraBackup的用户，必须对innodb的数据文件具有读写权限。之所以采用read-write模式是因为XtraBackup采用了其内置的 innodb库来打开文件，而innodb库打开文件的时候就是rw的。
XtraBackup要从文件系统中复制大量的数据，所以它尽可能地使用posix_fadvise()，来告诉OS不要缓存读取到的数据，从而提升性能。因为这些数据不会重用到了，OS却没有这么聪明。如果要缓存一下的话，几个G的数据，会对OS的虚拟内存造成很大的压力，其它进程，比如 mysqld很有可能被swap出去，这样系统就会受到很大影响了。
在备份innodb page的过程中，XtraBackup每次读写1MB的数据，1MB/16KB=64个page。这个不可配置。读1MB数据之后，XtraBackup一页一页地遍历这1MB数据，使用innodb的buf_page_is_corrupted()函数检查此页的数据是否正常，如果数据不正常，就重新读取这一页，最多重新读取10次，如果还是失败，备份就失败了，退出。在复制transactions log的时候，每次读写512KB的数据。同样不可以配置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c15565f1b53ff76fd54e0e1f482ecda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b5046dbc6c56989ef86ae34a0c20bd2/" rel="bookmark">
			.net C# EF CodeFirst 新增表和字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		updated by 2021-11-26
EFCore
1、反向工程，从数据库生成model
Scaffold-DbContext "Data Source=0123LO3619407\SQLEXPRESS;Initial Catalog=DevList;Integrated Security=false;uid=sa;pwd=1qaz@WSX;MultipleActiveResultSets=True;App=EntityFramework" Microsoft.EntityFrameworkCore.SqlServer -OutputDir DBContext_EF\AutoGenerated\DevList_DS -usedatabasename -Force 2、从model中更新到数据库
首次使用：add-migration Initial
如有更新：add-migration ‘migrationName’
后续更新：update-database
注意: 只能更新表，存储过程没法更新，可以通过导出存储过程脚本去执行存储过程
EF Framwork
我运营的一个项目后台是用EF CodeFirst操作数据库，因此摸索了一点点经验，分享一下.
添加字段或表：
新增表和字段有两种方法
1、直接修改模型，然后执行命令：add-migration AddMigName，迁移生成的类中会自动包含要新增或修改的表结构，这种注意了，生成的迁移类中就不要再手动修改，比如字符串的长度什么的，这样会导致生成的表字段和新建的模型不一致而报错，因为数据库是根据迁移类来生成的，模型本来也是根据迁移类来生成的，但是模型已经手动添加了表结构，所以迁移类不会更改模型，这样导致表结构和模型不一致，哪怕是字段的长度或类型不一致都会报错
具体迁移类的脚本
2、不修改模型，直接执行命令新建一个空的迁移类，然后在迁移类中自己写修改表结构的代码
建立初态：add-migration Initial EF会自动生成Migrations迁移文件夹
可以直接在直接新增一个类如：CompanyInstrument_EF，然后在XEngineContext类中通过
CompanyInstrument_EF类，具体字段自己定义
将类加入模型
add-migration
将迁移应用到数据库：update-database --更新数据库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc14e0134621d5079bdca83b94b7cdd0/" rel="bookmark">
			【python】if not语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们知道，在python中if语句是用来做判断的，if X：语句中，如果X为True，则执行：后面的句子；如果X为False，则跳过：后的句子。
现在我们在if和X中间加上一个not，if not X：，那么情况就恰好相反了，如果X为False，则执行：后面的句子；如果X为True，则跳过：后的句子。
但是这里要注意的是，如果我们有时候仅仅是要判断一下X是不是None的时候，是不推荐用这条语句的，因为在python中 None, False, 空字符串"", 0, 空列表[], 空字典{}, 空元组()都相当于False，这样就会引起误判。
这时候，推荐写这样的判断语句：
if x is not None: 还有一个值得注意的点就是if not all([A, B])语句，怎么理解呢？拆开读。if not我们前面讲了，现在就看后面的all([A, B])是True还是False，当参数列表中有一个为False的时候，则all()语句为False；参数全为True时，all()语句为True。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a635d01d189148ee9c540c966879d36/" rel="bookmark">
			mysql使用个人总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql简单使用规则 1. 简单查询逻辑：SELECT * FROM `ldp_mcs_user_info`
根据用户名排序（正序可默认或asc 倒叙desc）
2.正序语句：SELECT * FROM `ldp_mcs_user_info` order by user_account;
SELECT * FROM `ldp_mcs_user_info` order by user_account asc;
3.倒叙语句：SELECT * FROM `ldp_mcs_user_info` order by user_account desc
4.条件语句查询
简单单条语句查询：SELECT * FROM `ldp_mcs_user_info` where user_account='黄渊敏'
模糊匹配语句查询：SELECT * FROM `ldp_mcs_user_info` where user_account like '黄%'
一般上不建议使用模糊查询，会影响性能，如果必须使用建议只后面加%，前面不加
全模糊匹配：SELECT * FROM `ldp_mcs_user_info` where user_account like '%剑%'
5.获取20条数据
简单sql:SELECT * FROM `ldp_mcs_user_info` limit 20
根据用户名倒叙获取20条数据
sql语句：SELECT * FROM `ldp_mcs_user_info` order by user_account desc limit 20
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a635d01d189148ee9c540c966879d36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cb31de6fc6bfedf59cd3b093f8ff801/" rel="bookmark">
			mysql 1093 you can_mysql中错误：1093-You can’t specify target table for update in FROM clause的解决方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现问题
最近在处理一些数据库中数据的时候，写了下面的这一条sql语句: UPDATE f_student
SET school_id = 0
WHERE
id &gt; (
SELECT
id
FROM
f_student
WHERE
school_id = M
LIMIT 1
)
AND id &lt; (
(
SELECT
id
FROM
f_student
WHERE
school_id = M
LIMIT 1
) + N
)
上面的sql是想将某个区间的数据进行修改，但是放到测试环境下一跑，报下面的错误: [Err] 1093 – You can't specify target table ‘f_student' for update in FROM clause
意思很显而易见了，说不能对进行查询操作的表进行update操作，也就说我们的where条件中进行了子查询，并且子查询也是针对需要进行update操作的表的，mysql不支持这种查询修改的方式。
解决方法
上网查了一下，针对这种问题可以通过”绕”的方式进行实现，下面看sql语句。 UPDATE f_student SET school_id = 0 WHERE
id &gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cb31de6fc6bfedf59cd3b093f8ff801/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43abdd40d8c3731b5838b48464c5fc03/" rel="bookmark">
			js 求数组最大值的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * * @param {Array} list 传入数组 * @return {Number} 返回数组最大元素 */ // 方法一：利用Math里边的max方法 function maxItem(list) { // 利用Math里边的max方法 return Math.max(...list) } // 方法二：利用Math里边的max方法 function maxItem(list) { return Math.max.apply(null, list) } // 方法三：利用数组的reduce方法 function maxItem(list) { // 利用数组的reduce方法 return list.reduce((a, b) =&gt; { return a &gt; b ? a : b }) } // 方法四：利用数组的sort方法 function maxItem(list) { // 先降序排列 const arr = list.sort((a, b) =&gt; { return b - a }) // 返回新数组的第一项 return arr[0] } // 方法五：手写循环 function maxItem(list) { let max = list[0] list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43abdd40d8c3731b5838b48464c5fc03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a76d05108008faa4e0dcd6e6f0222bda/" rel="bookmark">
			最全讲解--电子电气架构演进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
前段时间，陆陆续续写了一些电子电气架构相关的文章。这里打算再写最后一篇作为收尾，为整个系列画上句号，把坑填上，这个话题就算过去了。后续一段时间，尽量把之前文章中挖的“坑”填一下。行文逻辑将借鉴5W2H进行。
另外，本文作为一篇整合性的文章，为保证逻辑的完整性，主要是将大量过去自己文章中的内容进行梳理整合，也存在很多行业内专家的公开文章的内容，请见谅。
WHAT1：什么是汽车电子电气架构？
电子电气架构：EEA，Electrical/Electronic Architecture
根据百度百科的解释：“汽车电子电气架构是集合了汽车的电子电气系统原理设计、中央电器盒设计、连接器设计、电子电气分配系统等设计为一体的整车电子电气解决方案”的概念，由德尔福(DELPHI)首先提出。具体就是在功能需求、法规和设计要求等特定约束下，通过对功能、性能、成本和装配等各方面进行分析，将动力总成、传动系统、信息娱乐系统等信息转化为实际的电源分配的物理布局、信号网络、数据网络、诊断、电源管理等电子电气解决方案（如图1所示）。
图1 整车电子电气架构与功能域
EEA不仅在汽车中经常使用，也在航电系统、工业自动化以及国防系统等其他控制系统中有广泛应用。
EEA的开发包括需求定义、逻辑功能架构设计、软件/服务架构设计、硬件架构设计、线束设计等不同层面的开发活动，如图2和图3。
图2 基于PREEvision的EEA开发模式
图3 基于PREEvision的EEA设计
2.WHY：电子电气架构演进的根本驱动力（Motviation）是什么？
答案：人类生产生活重心的转移与客户预期的改变
随着移动互联网在消费者生活领域的广泛渗透，人们的生活习惯和价值取向开始转移。伴随互联网尤其是移动互联网的飞速发展，人类的生产生活重心逐步转移至虚拟的赛博空间(Cyberspace)中。尤其是2007年苹果创造出智能手机这种便携化的智能终端后，不论是网上购物、网上娱乐、网络社交、移动支付、网络咨询，还是在线政务、线上办公、在线教育等生产生活活动，都在逐步地向赛博空间转移。未来还将有更多的老百姓被转化为网民，并更多地“生活”在赛博空间中。
人类生产生活逐步向赛博空间转移的过程中，也会对PC、平板电脑、手机或其他智能终端等消费电子产品的使用习惯和喜好向其他人类生产生活工具上转移。一旦其他工具具备了PC、平板或手机相应特征，就会形成市场需求，因为人类又多了一种智能终端能够与赛博空间进行连接，熟悉的、便利的互联网应用又可以在新工具和设备上运行，方便了生活，提高了生产效率。
汽车的驾驶自动化(Drving Automatization)趋势在很久很久以前就已经产生了。了解下Global OEM的Demo项目，甚至上知网搜索下相关论文，就会发现ADAS是多么古老的一种技术了，远远早于近几年的人工智能热潮。但是，随着特斯拉Model S、Model X等一系列车型的推出，使人们对汽车智能化(Intelligence)有了新的期待。仔细品一下Automatization和Intelligence这两个单词的含义，个人认为还是Intelligence含义更丰富。因此，汽车智能化，不仅包括了驾驶自动化，也包括智能网联、智能交互（以及后续的智能座舱）等数字化和信息化趋势。
也因为特斯拉等新玩家的创新性车型的推出，人们开始对汽车有了以下这种强烈的预期（图4），即智能汽车。所谓的智能汽车，基本是要对标着手机、PC这种数字化/信息化的半导体设备去了。
图4 智能汽车：拥有四个轮子的大型智能手机
既然老百姓的需求是“智能汽车”，那么具备“智能汽车”特征的车型就会有更多市场需求，客户也更加愿意买单。那么表征智能汽车的核心智能化功能都有哪些呢？按照汽车智能化的趋势（即CASE，Connected互联、Autonomous自动、Sharing共享、Electric电动），智能驾驶、智能座舱、智能网联应该就是终端用户期待的功能。以上的这些功能，相对于曾经汽车电子的功能，复杂度有很大提升。为了实现以上复杂功能，我们需要软件的SOA架构，我们需要基于服务的通信，我们需要满足车规的RTOS（实时操作系统），我们需要FOTA（固件空中升级），总之，我们需要一台软硬件解耦的、能够用软件来定义功能的汽车。这就需要一个大大的前提——集中化的EEA。这又是为什么呢？
先进行粗略分析。首先，看看当前的整车EEA现状：a) 电子单元：众多分散的运算&amp;控制单元；b) 电气单元：发动机、伺服电机、电磁阀等; c) 执行机构：机械、液压、气门机构... 也就是说，当前的汽车只是一台相对精密的机电一体化设备（Mechatronics，隶属于控制工程范畴，还需进一步电气化），而非数字化/信息化的半导体设备（ICT范畴），距离智能手机有些遥远。但是消费者目前想要的是一台像手机一样的车（智能终端、电子设备）。究竟如何才能使汽车朝向一台大型的“电子”设备转型呢？答案是继续提高电气化程度，即电子电气架构从分布式向集中式发展，直到形成真正的车载中央计算机。接下来，分为两个具体维度进行分析：
2.2.1 整车设计/制造维度
从整车的设计/制造维度讲，若汽车继续按照当前的分布式架构发展，且不说算力是否满足，单就车辆物理安装空间上讲就有问题。可能会导致难以布置更多ECU和更多线束；更多的ECU和更多的线束，势必导致组装困难，只能继续依靠人工。伊隆马斯克也曾为过度依赖自动化产线而焦头烂额，之后也曾发誓要对汽车进行“线束革命”，说明过多复杂线束和过多ECU的安装会严重影响产线的高度自动化。而集中式电子电气架构，能够逐步平抑ECU和线束的增长趋势，甚至到达某个时间节点之后，能够促进大幅减少ECU和线束用量，降低EEA网络拓的扑复杂度。倘若确实能够减少ECU数量和线束用量，也就能够降低电子电气系统的重量，对整车的轻量化设计目标也有帮助。
电子电气架构的集中化，就意味着单个ECU的“扩容”，以及多个ECU的“合并”。换句话说，ECU要越来越大型化，算力要高，功耗/成本还都需要进行控制。结论是什么？需要大型的、高算力的、制程小的（意味着低功耗）车载SOC芯片。为什么要用SOC芯片？因为通过堆大量算力低的芯片做控制器不可行；芯片多，集成度低，PCB板以及域控制器太大不好布置（想象一下Demo车的后备箱塞满工控机的场景），功耗和成本也高。总之，集成化程度高是刚需，SOC芯片又能够较好的解决这个问题。各个芯片玩家疯狂扩大SOC规模（从英伟达Xavier和ORIN，到特斯拉FSD芯片，甚至Mobileye提供EyeQ5的开放方案），也是为了解决这个痛点。所谓“规模”，实质是指算力，DMIPS/TFLOPS/TOPS都要足够高。
有了强大而“趁手”的芯片，就能“攒”出来满足集中化要求的ECU了。不管是叫DCU（域控制器），还是HPC（高性能计算机），甚至是VCC（车载中央计算机），也不过是表征一下ECU有多大规模。
综上论述，从整车维度讲，大型SOC芯片（以及基于大型SOC芯片构建的大型域控制器/高性能计算机）和先进线束都是集中化EEA的关键基础技术。
2.2.2 价格/成本维度
不管是什么产品，到了只拼价格/成本的竞赛，基本意味着没有太大创新了。因为创新是有代价的，创新是很“贵”的一件事，因此我相信集中化EEA也会遵循发展的常识。最开始是功能导向，为了实现某些关键功能的落地而不惜代价，价格/因素会较少考虑；然后是性价比导向，关键功能实现了，为了体现性价比，就会把手伸到“别人的地盘”，即几个大型ECU通过吸收其他专用小型ECU的功能（把小型ECU从车上干掉，平抑整个系统的成本），通过集成更多功能来保持“虽然贵，但是功能也强大”的性价比优势；最后是成本导向，大型ECU的功能scope确定了、“扩张边界”也确定了，就得比价格/成本了。然后不停的往复循环以上逻辑。
当前的智能驾驶域，在L0-L2已经相对成熟，因为该级别的各个ADAS功能相对确定，因此边界已经清晰了，那么开始打“性价比”牌和赤裸裸的“价格”牌也就不奇怪了。而L2+到L3还在比拼功能落地，那么价格因素就可以适当妥协（当然不能无限妥协，毕竟做产品归根结底是做生意，钱永远是最重要的）。
总之，若把智能驾驶、智能座舱的复杂功能作为必定要实现的“既定事实”看的话，集中化EEA还是“省钱”的。因为，即便假设分布式EEA从技术角度能够实现复杂功能，成本也会非常高。
以上，也可以回答作者作为一个做量产ADAS/AD的技术人员，为什么要关注整车电子电气架构演进的原因。因为关注EEA的进化，实质是关注前装量产高级别自动驾驶功能的落地节奏，以及汽车数字化、软件化的推进节奏！
3 HOW：通过何种方式达到集中化EEA，如何发展（Roadmap）？
根据下图的描述，一般EEA从分布式到中央集中式需要经历三个阶段，即分布式-域集中-中央集中。
图5 电子电气架构演进的三个阶段
4 WHAT2：什么算是集中式的EEA？有哪些常见类型？
4.1 三域EEA（域集中式EEA）
三域，顾名思义，是指车辆控制域、智能驾驶域和智能座舱域。其中，车辆控制域基本将原动力域、底盘域和车身域等传统车辆域进行了整合（整合更多是系统层面的概念，并不一定是硬件层面合并，因此并不是说这个域中其他ECU就不存在，或者就减少了）；智能驾驶域和智能座舱域则专注实现汽车的智能化和网联化。涉及的零部件主要有4类，车控域控制器（VDC，Vehicle Domain Controller）、智能驾驶域控制器（ADC，ADAS\AD Domain Controller）、智能座舱域控制器（CDC，Cockpit Domain Controller）以及若干高性能网关，其中：
VDC作为Private DCU，负责整车控制，实时性安全性要求高；
ADC作为Public DCU，负责自动驾驶相关感知、规划、决策相关功能的实现；
CDC作为Public DCU，负责HMI交互和智能座舱相关（甚至整合T-Box）功能的实现；
三域EEA算是非常彻底的域集中式EEA。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a76d05108008faa4e0dcd6e6f0222bda/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/329/">«</a>
	<span class="pagination__item pagination__item--current">330/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/331/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>