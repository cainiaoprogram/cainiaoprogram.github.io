<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e6ad40b64536b4259563f5b36594efb/" rel="bookmark">
			更改FusionCompute8.0 Web端管理系统密码（修改VRM节点的root帐户密码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更改FusionCompute 8.0 Web端管理系统密码（修改VRM节点的root帐户密码） 出现的问题： 使用admin用户登录，输入之前设置的登录密码，提示“用户名或密码不正确”。之后换了root用户名登录依旧不行，使用华为官方提供的用户名和密码登录还是不能成功进入。所以，根据华为官方文档修改VRM节点的root帐户密码。
解决方法： 前提条件：
已准备跨平台远程访问工具，如“PuTTY”。已获取待修改节点的管理IP地址。已获取待修改节点的“root”用户和“gandalf”用户的登录密码。 说明： “gandalf”用户的默认密码为“Huawei@CLOUD8”，“root”用户的默认密码为“Huawei@CLOUD8!”。
操作步骤：
1、使用“PuTTY”，登录待修改节点的操作系统。
以“gandalf”用户，密码：Huawei@CLOUD8。
通过管理IP地址登录。
注意要求：
PUTTY远程登录软件需要是安装版本，绿色版本会报错。
2、执行以下命令，并按提示输入“root”用户的密码，切换至“root”用户。
su - root
3、执行以下命令，防止系统超时退出。
TMOUT=0
4、执行以下命令，修改该用户的系统登录密码。
passwd
显示如下回显信息：
Changing password for root.
New UNIX password:
5、再次输入新密码，并按“Enter”。
显示如下回显信息，表示密码修改成功。
Password changed.
番外： 初次使用浏览器访问VRM节点的Web控制台时，
用户名为admin，初始密码为IaaS@PORTAL-CLOUD8!
切记！！！切记！！！切记！！!
之后会提示要求修改密码，密码设置要求符合设置要求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5c108e296a267b527b0898d90fd84d2/" rel="bookmark">
			Windows无法安装到这个磁盘,选中的磁盘具有MBR分区表的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 因为GHOST系统会捆绑大量软件，主页被强制修改，并且系统还可能存在删减的可能性，所以越来越多的用户考虑安装官方MSDN原版系统，但是呢，近期总是有用户称自己在安装Win10原版系统的时候，在选择磁盘分区的时候，提示了“Windows无法安装到这个磁盘,选中的磁盘具有MBR分区表，在EFI系统上，windows只能安装到GPT磁盘。”，然后无法进行下一步操作，导致了无法安装Windows10系统。那么如果遇到这个问题，我们要如何解决呢？下面装机之家分享一下Win10安装系统提示Windows无法安装到这个磁盘,选中的磁盘具有MBR分区表的解决方法，安装Win7、win8原版系统也可以参考。 Windows无法安装到这个磁盘分析故障原因： 弹出这个提示，主要是您的硬盘格式为MBR分区表，而您的U盘启动引导方式为“UEFI”模式，导致了开机引导方式和磁盘数据结构不匹配导致的问题！
正确的开机引导方式和磁盘数据结构如下：
Legacy引导对应的是MBR分区；
UEFI引导对应的是GPT分区；
下面给大家提供两种解决方法，方法如下。
方法一：将U盘启动非UEFI模式
我们将电脑重启，重新选择U盘启动模式，因为这个提示说明硬盘是MBR格式的，所以我们需要启动非UEFI模式的U盘，也就是没有“UEFI：”开头的U盘名称，这样安装就不会提示：“Windows无法安装到这个磁盘,选中的磁盘具有MBR分区表”。
方法二：转换磁盘格式为GPT，但是会清除所有磁盘 我们在这个错误提示的时候，不要重启电脑，直接在键盘上按下“Shift+F10”组合键，这时就会弹出CMD命令提示符窗口。
在弹出的CMD命令提示符窗口中，依次输入命令如下图所示。
1、输入“list disk”，回车键确定；（会列出所有的磁盘，记住自己硬盘的磁盘号，通过容量大小就可以分辨了，如下图所示，磁盘0就是我们的硬盘，磁盘1就是U盘）
2、输入“select disk 0”，回车键确定；（选择磁盘0，也就是我们的硬盘，就是准备做系统的硬盘）
3、输入“clean”，回车键确定；（清空磁盘，相当于格式化全盘）
4、输入“convert gpt”，回车键确定；（将该硬盘转换为GPT格式，如果想要将硬盘转化为MBR，那就是输入“convert mbr”）
将所选的磁盘成功转换为GPT格式之后，我们就可以通过UEFI启动方式来安装Win10系统了。 以上就是分享给大家的Win10系统提示Windows无法安装到这个磁盘,选中的磁盘具有MBR分区表的解决方法，我们只需要记得一个口诀就好了，UEFI引导对应的是GPT分区，而Legacy引导对应的是MBR分区，只要两者匹配的情况下，就不会弹出该错误了，还有可能就是主板BIOS中，磁盘是MBR格式，BOOT启动模式一定要对应修改为legecy模式，不过在新主板中，选项默认双支持，同时支持Legecy和UEFI模式，就不要修改了，将U盘启动模式对应就好了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3f57f69ba5f70b881b3f07d354bbb59/" rel="bookmark">
			qemu: could not load PC BIOS ‘bios-256k.bin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在centos下
首先 yum install qemu.x86_64，不过此时QEMU仍然不可用，
会提示“qemu: could not load PC BIOS 'bios-256k.bin'”
还需要再yum install qemu-kvm.x86_64
参考：这篇文章
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51884efe1994c5e3d54dd9342208d39c/" rel="bookmark">
			单个像素代表的实际物理尺寸
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单个像素代表的实际物理尺寸 简单点说，对于单目相机，没有单个像素代表的实际物理尺寸这个概念。
这个问题容易想明白，以下面这张图为例：只考虑简单的小孔相机模型，那橙色射线上的每个点投影到图片上都是同一个点。也就是说，远处大的物体和近处小的物体在图片上呈现出来是一样的，那在不知道深度的情况下讨论单个像素的实际长度也是没有意义的。
Matlab里有pointsToWorld这个函数，用来计算图片上像素坐标在真实世界中的二维坐标，它的用法是：
worldPoints = pointsToWorld(cameraParams,rotationMatrix,translationVector,imagePoints) 其中，cameraParams是我们通过Matlab的estimateCameraParameters函数，得到的标定结果。可以看到，仅仅有这个参数是不够的，我们还需要rotationMatrix和translationVector这两个外参数。
以上面这幅图为例，如果我们想测出两个硬币的圆心位置，那我们应该将它们放置于标定用的棋盘格的同一平面上，并且首先利用棋盘格的图像坐标计算出此时的外参数：
[R, t] = extrinsics(imagePoints, worldPoints, cameraParams); 再将得到的R和t带入上面的pointsToWorld函数。注意，此时得到的worldPoints仍然是二维坐标，它表示在图示棋盘格平面的XY坐标系内硬币圆心位置的物理坐标。如果题主说的确实是单目相机，那一般的应用场景应该是拍摄一个固定平面，得到目标物的二维坐标。如果相机和平面都是固定的，那把棋盘格放上去，用extrinsics函数计算一次外参就可以了，得到的R和t是适用于我们观察的工作平面的。
转载于：
作者：MQLhhhh
链接：https://www.zhihu.com/question/313810634/answer/610002045
来源：知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1e4a305905c313d3189da9223b63f7c/" rel="bookmark">
			JavaSE笔记 类与对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类与对象 文章目录 类与对象1. 引用步骤 1 : 引用和指向步骤 2 : 多个引用，一个对象步骤 3 : 一个引用，多个对象步骤 4 : 练习-引用 2. 继承步骤 1 : 物品类Item步骤 2 : 武器类Weapon（不继承）步骤 3 : 武器类Weapon（继承类Item） 3. 方法重载步骤 1 : attack方法的重载步骤 2 : 可变数量的参数 4. 构造方法步骤 1 : 什么是构造方法步骤 2 : 隐式的构造方法步骤 3 : 如果提供了一个有参的构造方法步骤 4 : 构造方法的重载 5. this步骤 1 : this代表当前对象步骤 2 : 通过this访问属性步骤 3 : 通过this调用其他的构造方法 6. 传参步骤 1 : 基本类型传参步骤 2 : 引用与=步骤 3 : 类类型传参 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1e4a305905c313d3189da9223b63f7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d20be0e3c289dfce3293f61c12a5197f/" rel="bookmark">
			六、Spring MVC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. Spring MVC使用示例
2. 主要结构
3. RequestMappingHandlerMapping的实例化和初始化
3.1 RequestMappingHandlerMapping的实例化
3.2 RequestMappingHandlerMapping的初始化(web方法收集)
4. 拦截器
4.1 拦截器使用示例
4.2 拦截器的收集
5. RequestMappingHandlerAdapter
5.1 RequestMappingHandlerAdapter的实例化
5.2 RequestMappingHandlerAdapter的初始化
6. ExceptionHandlerExceptionResolver
6.1 ExceptionHandlerExceptionResolver的实例化
6.2 ExceptionHandlerExceptionResolver的初始化
7. Spring mvc容器中的bean注入
8. 请求的处理流程
8.1 getHandler获取请求路径对应的HandlerMethod和拦截器
8.2 getHandlerAdapter获取HandlerAdapter
8.3 mappedHandler.applyPreHandle正序调用拦截器前置处理方法
8.4 ha.handle调用请求路径对应的web方法
8.4.1 参数解析
8.4.2 反射调用web方法
8.4.3 返回值解析
8.5 mappedHandler.applyPostHandle倒序调用拦截器的中置处理方法
8.6 processDispatchResult
8.6.1 ControllerAdvice异常处理方法调用
8.6.2 倒序调用拦截器后置处理方法
(本篇中用到的演示项目地址：https://gitee.com/yejuan/spring-learning-no-xml 对应tag: spring-c6)
1. Spring MVC使用示例 我们通过类与方法上面的RequestMapping拼接出来的路径/user/showUser就可以调用到showUser方法，本篇将分析下是如何实现的。
@Controller @RequestMapping("/user") public class UserController { @Autowired IUserService userService; @ResponseBody @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d20be0e3c289dfce3293f61c12a5197f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a23941431ea9e801bb84ac180a2291c1/" rel="bookmark">
			【深度学习】关于负梯度方向，函数值下降最大的思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		负梯度方向是函数值下降最快的方向
我想每一个接触接触机器学习或者深度学习的人都对这句话倒背如流，但是随着时间的推移，很多概念及其背后的数学原理变得模糊。也是因为面试过程中被问及“为什么负梯度方向是函数值下降最快的方向？”，所以才突然发现是时候需要巩固一下这些尘封在脑海深处的知识点了。
基础概念 什么是梯度？
首先回顾一下导数、方向导数、偏导数这几个概念：
导数（数）
导数（导函数值，微商），指的是对于 y = f ( x ) y=f(x) y=f(x)，当 x x x在某点 x 0 x_0 x0​处产生增量 Δ x \Delta{x} Δx时函数值的增量 Δ y \Delta{y} Δy，若 Δ x \Delta{x} Δx趋向于0时， Δ y / Δ x \Delta{y}/\Delta{x} Δy/Δx存在，则 x 0 x_0 x0​处导数 f ′ ( x 0 ) f'(x_0) f′(x0​)为：
f ′ ( x 0 ) = lim ⁡ Δ x → 0 Δ y Δ x f'(x_0)=\lim_{\Delta{x}\to{0}}\frac{\Delta{y}}{\Delta{x}} f′(x0​)=Δx→0lim​ΔxΔy​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a23941431ea9e801bb84ac180a2291c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b561fd945ce3be8f5b7a87a66ad5d1c/" rel="bookmark">
			javascript es6 es7 es8  “String高级用法“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、拓展用法1.Unicode使用2.标签模板 2.方法1.includes()2.startsWith()3.endsWith()4.补全字符padStart()、padEnd()5.trimStart()、trimEnd() 总结 一、拓展用法 1.Unicode使用 ES6 加强了对 Unicode 的支持，允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。并且可以使用Unicode来制作表情包。
console.log("\u0061") //a 附上Unicode官网：Unicode
注意：这里需要了解一些js的编码方式、utf16、unicode的知识，由于JavaScript只能处理UCS-2编码，造成所有字符在这门语言中都是2个字节，如果是4个字节的字符，会当作两个双字节的字符处理。JavaScript的字符函数都受到这一点的影响，无法返回正确结果，emoji表情是由utf16编码的，可能是2个字节，也可能是四个字节，所以要去细看一下。
2.标签模板 模板字符串的功能，它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。
alert`hello` // 等同于 alert(['hello']) //标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 主要作用就是过滤 HTML 字符串，防止用户输入恶意内容。
let sender = '&lt;script&gt;alert("abc")&lt;/script&gt;'; // 恶意代码 let message = SaferHTML `&lt;p&gt;${sender} has sent you a message.&lt;/p&gt;`; function SaferHTML(templateData) { let s = templateData[0]; console.log(templateData) for (let i = 1; i &lt; arguments.length; i++) { let arg = String(arguments[i]); console.log(arg) // 替换掉输入框中的特殊字符 s += arg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b561fd945ce3be8f5b7a87a66ad5d1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26e60c803dcc8349e0fc1d1a50a1b12d/" rel="bookmark">
			django  数据库迁移指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # rbac/models.py class Role(models.Model):... class User(models.Model): # name = models.CharField(max_length=12) # password = models.CharField(max_length=12) roles = models.ManyToManyField(Role)	# 直接写对应的类名，字符串形式反射是找不到的 # user = models.OneToOneField('Userinfo') class Meta: abstract = True	# 执行数据库迁移指令的时候，不会将这个类生成 # sales/models.py class UserInfo(User): username = models.CharField(max_length=16) password = models.CharField(max_length=32) is_active = models.BoolenField(default=True) def __str__(models.Model): return self.username 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b2d28c0cf87b31784188097673c354e/" rel="bookmark">
			一文了解Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们使用 Redis 时，会接触 Redis 的 5 种对象类型（字符串、哈希、列表、集合、有序集合），丰富的类型是 Redis 相对于 Memcached 等的一大优势。
在了解 Redis 的 5 种对象类型的用法和特点的基础上，进一步了解 Redis 的内存模型，对 Redis 的使用有很大帮助。
001
Redis内存统计
在客户端通过 redis-cli 连接服务器后（后面如无特殊说明，客户端一律使用redis-cli），通过 info 命令可以查看内存使用情况：info memory。
其中，info 命令可以显示 Redis 服务器的许多信息，包括服务器基本信息、CPU、内存、持久化、客户端连接信息等等；Memory 是参数，表示只显示内存相关的信息。
返回结果中比较重要的几个说明如下：
used_memory
Redis 分配器分配的内存总量（单位是字节），包括使用的虚拟内存（即 swap）；Redis 分配器后面会介绍。used_memory_human 只是显示更友好。
used_memory_rss
Redis 进程占据操作系统的内存（单位是字节），与 top 及 ps 命令看到的值是一致的。
除了分配器分配的内存之外，used_memory_rss 还包括进程运行本身需要的内存、内存碎片等，但是不包括虚拟内存。
mem_fragmentation_ratio
内存碎片比率，该值是 used_memory_rss / used_memory 的比值。
mem_fragmentation_ratio 一般大于 1，且该值越大，内存碎片比例越大；mem_fragmentation_ratio&lt;1，说明 Redis 使用了虚拟内存，由于虚拟内存的媒介是磁盘，比内存速度要慢很多。
002
Redis内存划分
Redis 作为内存数据库，在内存中存储的内容主要是数据（键值对）；也有其他部分会占用内存。
Redis 的内存占用主要可以划分为以下几个部分：
数据
作为数据库，数据是最主要的部分；这部分占用的内存会统计在 used_memory 中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b2d28c0cf87b31784188097673c354e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f7483f4f83c46bb239866565d4919f3/" rel="bookmark">
			Web服务器项目详解（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
04 http连接处理（上）
本文内容
epoll
HTTP报文格式
HTTP状态码
有限状态机
http处理流程
05 http连接处理（中） 本文内容
流程图与状态机
代码分析-http报文解析
06 http连接处理（下） 本文内容
基础API
流程图
代码分析
04 http连接处理（上） 本文内容 在服务器项目中，http请求的处理与响应至关重要，关系到用户界面的跳转与反馈。这里，社长将其分为上、中、下三个部分来讲解，具体的：
上篇，梳理基础知识，结合代码分析http类及请求接收
中篇，结合代码分析请求报文解析
下篇，结合代码分析请求报文响应
基础知识方面，包括epoll、HTTP报文格式、状态码和有限状态机。
代码分析方面，首先对服务器端处理http请求的全部流程进行简要介绍，然后结合代码对http类及请求接收进行详细分析。
epoll epoll涉及的知识较多，这里仅对API和基础知识作介绍。更多资料请查阅资料，或查阅游双的Linux高性能服务器编程 第9章 I/O复用
epoll_create函数
#include &lt;sys/epoll.h&gt; int epoll_create(int size) 创建一个指示epoll内核事件表的文件描述符，该描述符将用作其他epoll系统调用的第一个参数，size不起作用。
epoll_ctl函数
#include &lt;sys/epoll.h&gt; int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event) 该函数用于操作内核事件表监控的文件描述符上的事件：注册、修改、删除
epfd：为epoll_creat的句柄
op：表示动作，用3个宏来表示：
EPOLL_CTL_ADD (注册新的fd到epfd)，
EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，
EPOLL_CTL_DEL (从epfd删除一个fd)；
event：告诉内核需要监听的事件
上述event是epoll_event结构体指针类型，表示内核所监听的事件，具体定义如下：
struct epoll_event { __uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; events描述事件类型，其中epoll事件类型有以下几种
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f7483f4f83c46bb239866565d4919f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ffbeaf9ae4de230a1b57bbcd8b27f38/" rel="bookmark">
			操作系统形式化验证实践教程(12) - 经典命题逻辑与公式查错方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统形式化验证实践教程(12) - 经典命题逻辑与公式查错方法 第10节我们介绍了直觉一阶逻辑，它是不接受排中律的逻辑。在编程体感上，直觉一阶逻辑IFOL库，不支持auto，不支持sledgehammer，不能使用try0与try，基本上可以使用的就是simp或者手动推理。
simp是简化的意思，只做从左到右的等量代换来进行化简。它是auto中的一部分功能，但是auto要更强大一些。
经典命题逻辑我们使用经典一阶逻辑库FOL，它是继承自IFOL的。
经典一阶逻辑库FOL 现在我们换成经典一阶逻辑的FOL库，现在可以使用auto了，我们看个例子：
theory fol2 imports FOL begin lemma D3: "⟦(¬A ⟹ B);(¬A ⟹¬B)⟧⟹ A" proof (auto) qed end 我们来个复杂点的例子：
lemma E1 : assumes 1: ‹¬A ⟶ B› and 2: ‹¬B› and 3: ‹¬A› shows ‹¬B ⟶ A› 从一堆公式中取出一个，可以采用local访问的方式，根据下标的不同来进行获取，比如取第n个可以用local.assms(n)，也可以直接local.n，我们看例子：
lemma E2_1: assumes 1: ‹¬A ⟶ B› and 2: ‹¬B› and 3: ‹¬A› shows ‹¬A ⟶ B› by (rule local.assms(1)) lemma E2_2: assumes 1: ‹¬A ⟶ B› and 2: ‹¬B› and 3: ‹¬A› shows ‹¬A› by (rule local.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ffbeaf9ae4de230a1b57bbcd8b27f38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11d97f4cc377a1b1052e99611883bd11/" rel="bookmark">
			STM32CubeMX官网下载方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 CubeMX下载芯片包下载和CubeIDE区别 CubeMX下载 主要是对下载链接做个记录，不再从打开百度–搜索ST这样一步步记录。点击STM32CubeMX - STM32Cube initialization code generator - STMicroelectronics，看到如下界面：
将页面滑到中间位置，即可看到下载按钮，同时可选择软件版本：
芯片包下载 回到页面顶部，点击Tools&amp;Software：
在此界面可下载相关工具和软件。页面下滑，即可依次找到STM32CubeIDE和STM32各系列的pack包。
以F1为例，直接点击界面跳转如下：
选择get software，会自动为我们定位到下载选项：
和CubeIDE区别 最后记录一下STM32CubeMX与STM32CubeIDE的区别：
Cubemx 是个图形化配置工具，最大的好处是帮用户生成相应的初始化代码。
CubeIde 是编译器，最大的功能是帮助用户编译调试代码，包括cubemx 生成的项目代码。cubeide 也同时集成了cubemx工具。
cubeIDE = cubeMX + Keil;[如您用 keil]
cubeIDE = cubeMX + IAR;[如您用 IAR]
cubeIDE = cubeMX + STUDIO;[如您用 Studio]
再贴一个非常详细的下载安装教程：STM32CubeMX介绍、下载与安装
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a097435e190bd81ee353016023f5b9cd/" rel="bookmark">
			银联支付服务之公众号支付业务（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一节已经介绍了银联的公众号支付业务，以及如何注册成为开发者，这一节将创建一个控制台应用程序调启微信支付并成功付款。 一、请求协议 HTTP(S)
HTTP方法：GET
二、接口地址 测试环境：http://58.247.0.18:29015/v1/netpay/webpay/pay
生产环境：https://api-mop.chinaums.com/v1/netpay/webpay/pay
三、参数 3.1URL参数 参数名称参数说明参数类型长度是否必须备注authorization认证方式string 是值为OPEN-FORM-PARAMappIdAppIdstring&lt;=32是 timestamp时间戳string14是yyyyMMddHHmmssnonce随机数string&lt;=128是 content业务内容string 是 signature签名string 是 Base64_Encode(HmacSHA256
(appId + timestamp + nonce +
SHA256_HEX(content), AppKey))
3.2业务内容主体（只列出必填与部分主要参数，详细参数请参考官方文档） 格式：JSON
参数名称参数说明参数类型长度是否必须备注msgId消息IDstring&lt;=64否原样返回requestTimestamp报文请求时 间string 是格式yyyy-MM-dd HH:mm:ssmerOrderId商户订单号string 是商户自行生成（下面详细介绍）mid商户号string15是 tid终端号string8是 instMid业务类型string 是YUEDANDEFAULTtotalAmount支付总金额 1..100000000是 notifyUrl支付结果通知地址string（url） 否 returnUrl网页跳转地址string（url） 否 四、参数准备 4.1appId、商户号、终端号、来源编码获取 注册成为开发者后可以获取到这几个参数，注册开发者请回顾上一节
4.2订单号规则与生成 以银商分配的4位来源编号作为账单号的前4位，且在商户系统中此账单号保证唯一。总长 度需大于6位，小于28位。银商的推荐规则为（无特殊情况下，建议遵守此规则）：{来源编号(4位)}{时间(yyyyMMddmmHHssSSS)(17位)}{7位随机数}
public static string getMerOrderId(string number)//number即来源编号，一般为1017 { string time = DateTime.Now.ToString("yyyyMMddHHmmssSSS"); System.Random Random = new System.Random(); int Result = Random.Next(1000000, 9999999);//7位随机数 return number += time += Result; } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a097435e190bd81ee353016023f5b9cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15bc3de02451dba588b894df808cd302/" rel="bookmark">
			Linux GUI自动化测试工具 -- LDTP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 背景
2. 环境
3. 安装和使用
1）下载地址
2）Windows下的安装和使用
3）Linux下的安装和使用
4. 踩到的“坑”
5. 参考资料
1. 背景 项目需要，研究了一下Linux下的GUI测试工具：LDTP。GNU LDTP（Linux Desktop Testing Project） 是一个 GNU/ Linux/ Unix 下的 GUI 应用测试工具。支持系统包括：FreeBSD/ Fedora/ Mac/ OpenSUSE/ OpenSolaris/ Windows/ Ubuntu等。本文介绍一下LDTP2的环境搭建，基本使用以及在使用中踩的坑。
2. 环境 操作系统：Ubuntu 18.4/ Window7LDTP： ldtp2 v3.5.1语言：Python2 &gt;= 2.6; Python3 &gt;= 3.0 3. 安装和使用 1）下载地址 操作系统地址Linuxhttps://github.com/ldtp/ldtp2Windowshttps://github.com/ldtp/cobra/releases 2）Windows下的安装和使用 a.双击 CobraWinLDTP-4.0.0.msi，按照提示安装完即可。
b.在&lt;安装盘&gt;\Program Files (x86)\VMware\CobraWinLDTP目录下，双击 CobraWinLDTP.exe，启动Server端。
c. 运行-》cmd，输入 Python3，进入Python命令；输入如下命令，如果没有报错，则证明安装成功。
3）Linux下的安装和使用 这里有两种方法。
a. 度娘上都能查到的在线安装方法：
apt-get install ldtp 同样的，安装完成后，导入LDTP，如果没有报错则表示安装成功。
b. 源码安装（这里以作者环境和安装过程为例，均是亲验总结，如有其他环境或问题需要具体分析）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15bc3de02451dba588b894df808cd302/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c9eb8a658ba2d435d0137b0c1183c0a/" rel="bookmark">
			roberta与albert
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		roberta 简介
RoBERTA，是BERT模型的改进版，并获得了更好的自然语言处理效果，且其在GLUE、SQuAD、RACE等三个榜单上取得了SOTA效果细节 训练数据集上，RoBERTa采用了160G的训练文本，而BERT仅使用16G的训练文本
模型评估上，模型主要基于三个基准来评估：1、GLUE通用语言理解模型；2、SQuAD斯坦福问题答疑数据集；3、RACE考试的重新理解
预训练任务上，RoBERTa使用的是动态mask，BERT采用静态mask,其含义如下：
原来Bert对每一个序列随机选择15%的Tokens替换成[MASK]，为了消除与下游任务的不匹配，还对这15%的Tokens进行（1）80%的时间替换成[MASK]；（2）10%的时间不变；（3）10%的时间替换成其他词。但整个训练过程，这15%的Tokens一旦被选择就不再改变，也就是说从一开始随机选择了这15%的Tokens，之后的N个epoch里都不再改变了。这就叫做静态Masking。
在此预训练任务中，取消了NSP任务，增加了FULL_SENTENCES机制：在该机制下，输入的不再是两个句子，而是用大段话填满指定的字节长度，如果句子跨越了文章就增加一个分割的token。
训练参数：RoBERTa模型增加了训练的batch_size，并将adam的0.999改成了0.98，增加了训练的step,最后使用的batch_size为8k，训练步数为500步。输入的token编码为BPE编码。
albert albert主要解决Bert参数过大、训练国漫的问题，其主要通过两个参数削减技术克服预训练模型扩展的障碍：
embedding参数因式分解：将两个大的词嵌入矩阵分解为两个小的矩阵，从而将隐藏层与词典的大小关系分割开来，两者不再直接关系，使得隐藏层的节点数扩展不再受到限制跨层参数共享：避免参数随着网络的深度增加而增加句间连贯性损失：正例与bert一样，两个连贯的句子；负例也是原文中两个连贯的语句，但是顺序交换一下 模型调用 bert模型测试
roberta模型测试
albert模型测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dab2bb223a272a39c513464019896af/" rel="bookmark">
			new一个对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM的学习分两个阶段即原理和源码学习、通过原理知识的学习我们能粗略的了解从java代码到字节码文件再到JVM运行产出的流程，之后你肯定会有一万个为什么，那时只能阅读源码来回答你的一万个为什么……
上篇文章学习了JVM内存区域，了解了JVM各个内存区域存储的数据，其中堆内存用来存储创建的对象，那下面一起来了解一下对象创建相关内容以及HSDB查看堆内存在JVM内存中的分配区域。
带着这些疑问开始new指令创建对象的学习……
1、创建的对象包含什么？
2、对象内存布局（通俗说对象的组成部分）是怎样的？
3、对象组成部分细分即对象头运行时数据包含哪些、元数据指针是什么、对象实体数据在哪里？
4、对象大小怎么算？
5、创建对象的流程是怎样的？
6、对象内存分配方式有哪些？
7、instanceKlass对象、Class对象、instanceOopDesc（instanceOop）对象、以及他们之间的关系?
8、对象是分配在堆内存，那堆内存在JVM内存中的具体地址在哪里？
一、创建的对象包含什么 1、其实说的具体点或者说更明确一点这里说的对象只包含对象成员变量；也就是我们定义的类中的对象成员变量；也就是对象数据体。
2、为何不包含对象头和填充数据，因为所有对象都有相同的对象头数据结构或者说是”相同“的对象头和填充数据。
3、对象头不是我们定义的数据是每个对象创建时自动添加的。
二、对象的内存布局 1、对象组成
2、对象内存布局
JVM内部使用instanceOopDesc 对象表示一个对象，instanceOop是instanceOopDesc别名。
3、对象大小计算
一般非数组对象，未开启压缩
8个字节对象头(mark) + 8字节对象指针 + 数据区 + padding内存对齐(按照8的倍数对齐)
一般非数组对象，开启压缩
8个字节对象头(mark) + 4字节对象指针 + 数据区 + padding内存对齐(按照8的倍数对齐)
OK 我们了解了对象是什么、对象的组成、对象的内存布局，那下面看看对象的创建流程……
三、对象创建流程 1、对象创建可以从不同角度来说如：语言、JVM、应用程序
JVM层面对象创建上面图形值整个流程，但是具体代码实现还是有一下不同，下面来看看JVM层面创建对象的具体流程。
2、JVM内部对象创建
JVM内部对象的创建分两类即快速分配和慢速分配，如果new 后面参数这个类已经被加载、解析、初始化过则进行快速创建否则慢速创建，这也正式我们程序中的两种情况即第一次创建该类对象和之后第二次……第N次创建该类对象。
2.1、创建对象流程图
3、快速分配
如果在实例分配之前已经完成了类型的解析，那么分配操作仅仅是在内存空间中划分可用内存，因此能以较高的效率实现内存分配，因为称为快速分配。
3.1、快速分配条件
// 确保常量池中存放的是已解释的类if (!constants-&gt;tag_at(index).is_unresolved_klass())// 确保对象所属类型已经经过初始化阶段if (ik-&gt;is_initialized() &amp;&amp; ik-&gt;can_be_fastpath_allocated())
3.2、快速分配空间的两种选择策略
根据分配空间是来自于线程私有区域还是共享的堆空间，快速分配又可以分为两种空间选择策略。
选择TLAB：首先尝试在TLAB中分配，因为TLAB是线程私有区域，故不需要加锁便能够保证线程安全。在分配一个新的对象空间时，将首先尝试在TLAB空间中分配对象空间，若分配空间的请求失败，则在尝试使用加锁机制在Eden区分配对象。
选择Eden空间：若失败，则尝试在共享的Eden区进行分配，Eden区是所有线程共享区域需要保证线程安全，故采用CAS操作进行分配。若分配失败则再次尝试该操作直至分配成功为止。
3.3、实例数据空间进行填零
根据VM选项ZeroTLAB的配置，若为false,虚拟机接下来会对实例数据空间进行填零操作
因为填零操作所以对象的实例字段在java代码中可以不赋初始值就直接使用，访问到的变量的值就是默认的零值。
3.4、虚拟机对象头
3.4.1、设置Mark Word。
3.4.2、设置类型元数据指针：根据VM选项UseCompressedOops的配置，设置类型指针元信息_metadata._compressed_klass或_metadata._klass。
3.5、设置栈顶对象引用
待完成对象的空间分配和初始化后，就可以设置栈顶对象引用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dab2bb223a272a39c513464019896af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b83b8e0bdb0bb988a6c920f48e2cf62/" rel="bookmark">
			完美解决VMWare下Ubuntu18.04虚拟机4K分辨率及缩放比例问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内核支持 ​ 由于测试一个特定项目, 事先使用synaptic安装了5.0.0-23版本的kernel, 一开始仅安装了上述四个文件, 进入系统后分辨率仅有800x600, 最高分辨率仅有1176x885, 之后尝试使用xrandr命令调整分辨率时遇到如下错误:
xrandr: Failed to get size of gamma for output default
​ 猜测应当是内核缺少硬件相关部件, 因此追加安装了剩余的三个包, 之后进入系统后可以调整分辨率
​ 在此之前, 为自动加载5.0.0-23版本内核, 修改/etc/default/grub如下:
# 1指开机按"shift"后进入界面中的高级启动选项, 4指从5.0.0-23版本的内核启动, 具体顺序参见grub的高级启动选项 # 修改完后执行sudo update-grub GRUB_DEFAULT="1&gt;4" 自动调整分辨率 ​ 目前为止已经保证了使用xrandr命令能够正常识别4k显示器, 但这里能调整的最大分辨率仅仅到2K(2560x1600), 仍然看着很不爽, 这里需要的命令如下:
# xrandr --newmode后面的参数可执行 cvt 3840 2160 得到 xrandr --newmode "3840x2160_60.00" 712.75 3840 4160 4576 5312 2160 2163 2168 2237 -hsync +vsync xrandr --addmode Virtual1 "3840x2160_60.00" ​ 这两个命令用于创建并添加4K显示模式, 我直接放在了/etc/profile中, 每次启动都可自动加载
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b83b8e0bdb0bb988a6c920f48e2cf62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9721af8e38b761dd464e5923440bdfc7/" rel="bookmark">
			CTFHub学习笔记(3) - 部分题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 回转十三位马男波杰克签个到just a rar藏藏藏sign incheck inhidden一叶障目boom 回转十三位 下载附件，先看到一串字符串像是base64加密
解密试试
好像不行，又想到题目是回转十三位，那这样看来应该是先用一次rot13解密
再试试base64，得到flag
马男波杰克 附件是一个图片
名字是atool，是提示要用一个工具嘛…属性里面也没有什么有用的信息
先试试stegsolve，好像不是很行
又看到hint说要百度，就去百度了一下atool，发现了网站
又去了github找到了在线工具
得到flag
签个到 下载附件。提示文件损坏
用winhex看看
发现是png格式的，修改后缀名打开
得到了二维码，扫描得到flag
just a rar 附件是一个加密的rar压缩包，提示是4位数看来是个爆破
先试了试纯数字，直接爆出了密码
解压缩后，在图片备注里看到flag
藏藏藏 是一道图片隐写题，属性里面没有藏东西，用foremost试试，分出来了一个zip
解压出来是一个word，扫码得到flag
sign in 附件是一个txt
密文看起来像是16进制的，转换一下试试
得到flag
check in 打开网页，发现没有什么东西，只好先去看看header，发现了一个flag
base64解密得到flag
hidden 图片属性没什么东西，用foremost分离出一个zip，发现文件被加密了，又没有什么提示，先试了试伪加密，发现不对，直接试试爆破
解压看看
得到了一半的二维码
winhex改变图片高度并解码
得到flag
一叶障目 foremost查看图片，没有隐藏文件，用stegsolve也没有发现什么隐藏
最后用kali打开图片的时候发现
用crc修复工具修复图片
得到flag
boom 附件是一个exe，用ida打开
先是一个md5，直接在线解密
后面按部就班的算就行了，得到flag
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf1ce5a8b25aa29af515dfa3ab479f8a/" rel="bookmark">
			深度优先搜索算法（DFS）原理及示例详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 算法原理2 基本思路980.不同路径题目描述输入输出示例直观思路代码实现 1 算法原理 事实上，深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search.其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次.
举例说明之：下图是一个无向图，如果我们从A点发起深度优先搜索（以下的访问次序并不是唯一的，第二个点既可以是B也可以是C,D），则我们可能得到如下的一个访问过程：A-&gt;B-&gt;E（没有路了！回溯到A)-&gt;C-&gt;F-&gt;H-&gt;G-&gt;D（没有路，最终回溯到A,A也没有未访问的相邻节点，本次搜索结束）。
2 基本思路 深度优先遍历图的方法是，从图中某顶点v出发：
（1）访问顶点v；（2）依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；（3）若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。　当然，当人们刚刚掌握深度优先搜索的时候常常用它来走迷宫.事实上我们还有别的方法，那就是广度优先搜索(BFS). 搜索算法简而言之就是穷举所有可能情况并找到合适的答案，所以最基本的问题就是罗列出所有可能的情况。
从根开始计算，到找到位于某个节点的解，回溯法（深度优先搜索）作为最基本的搜索算法，其采用了一种“一只向下走，走不通就掉头”的思想（体会“回溯”二字），相当于采用了先根遍历的方法来构造搜索树。
980.不同路径 题目描述 在二维网格 grid 上，有 4 种类型的方格：
1 表示起始方格。且只有一个起始方格。2 表示结束方格，且只有一个结束方格。0 表示我们可以走过的空方格。-1 表示我们无法跨越的障碍。 返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。
每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。
输入输出示例 输入：
[1,0,0,0],
[0,0,0,0],
[0,0,2,-1]
输出： 2
**解释：**我们有以下两条路径：
(0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
(0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
直观思路 从起始点开始，朝着起始点的四个方向开始搜索，直到终点停止。
在搜索过程中，需要改变搜索方向，就如同逆时针输出二维数组的元素一样，当到达边界时需要改变方向。在此题中，定义两个方向，一个是改变row方向数组dr = {0, -1, 0, 1}，一个是column方向dc = {1, 0, -1, 0}。
代码实现 class Solution980 { int ans; int[][] grid; int tr, tc; int[] dr = new int[]{0, -1, 0, 1}; int[] dc = new int[]{1, 0, -1, 0}; int R, C; public int uniquePathsIII(int[][] grid) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf1ce5a8b25aa29af515dfa3ab479f8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/339a7b40d18989032fd02e6838b1c6c9/" rel="bookmark">
			目标检测中的损失函数汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		和图像分割中将损失函数分为基于分布，基于区域以及基于边界的损失函数不一样，目标检测经常可以认为由2类最基础的损失，分类损失和回归损失而组成。
分类损失 CE loss，交叉熵损失
交叉熵损失，二分类损失（binary CE loss）是它的一种极端情况. 在机器学习部分就有介绍它。
如下图所示,y是真实标签，a是预测标签，一般可通过sigmoid，softmax得到，x是样本，n是样本数目，和对数似然等价。
focal loss,
用改变loss的方式来缓解样本的不平衡，因为改变loss只影响train部分的过程和时间，而对推断时间影响甚小，容易拓展。
focal loss就是把CE里的p替换为pt，当预测正确的时候，pt接近1，在FL(pt)中，其系数 ( 1 − p t ) γ (1-p_t)^\gamma (1−pt​)γ越小（只要 γ &gt; 0 \gamma&gt;0 γ&gt;0）；简而言之，就是简单的样例比重越小，难的样例比重相对变大
Rankings类型的损失
在这有两类，DR(Distributional Ranking) Loss和AP Loss
DR Loss, 分布排序损失， Qian et al., 2020, DR loss: Improving object detection by distributional ranking
DR loss的研究背景和focal loss一样，one-stage方法中样本不平衡。它进行分布的转换以及用ranking作为loss。将分类问题转换为排序问题，从而避免了正负样本不平衡的问题。同时针对排序，提出了排序的损失函数DR loss。具体流程可参考：https://zhuanlan.zhihu.com/p/75896297
AP Loss, Chen et al., 2019, Towards Accurate One-Stage Object Detection with AP-Loss
AP loss也是解决one-stage方法中样本不平衡问题,同时也和DR loss类似，是一种排序loss。将单级检测器中的分类任务替换为排序任务，并采用平均精度损失(AP-loss)来处理排序问题。由于AP-loss的不可微性和非凸性，使得APloss不能直接优化。因此，本文开发了一种新的优化算法，它将感知器学习中的错误驱动更新方案和深度网络中的反向传播机制无缝地结合在一起。具体可参见：https://blog.csdn.net/jiaoyangwm/article/details/91479594
回归损失 回归损失在这里更多的是对应与bounding box的回归。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/339a7b40d18989032fd02e6838b1c6c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ce76430db229c0b652b15a8afa8bb0d/" rel="bookmark">
			CTFHub学习笔记(2) - 技能树 - 信息泄露[只做了部分，待更新]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信息泄露 目录遍历PHPinfo备份文件下载网站源码bak文件 目录遍历 题目虽然叫目录遍历，其实一个个翻文件夹就有flag了
PHPinfo 这道题应该本质是想科普一下PHPinfo到底是什么东西，题目本身其实是白给的打开题目链接后ctrl+f进入查询模式，输入flag中的特有字符串ctfhub，即可在第12条处发现flag
附：PHPinfo：PHPinfo是一个运行指令，为显示php服务器的配置信息。实际上它就是PHP自带的一个函数，用来检测PHP各种环境的。用户可以通过创建phpinfo.php这样一个文件，里面写上规定的代码，就可以通过访问这个文件来显示出当前服务器PHP的配置信息
备份文件下载 网站源码 根据题目提示，使用御剑扫描一下后台
发现备份文件www.zip，打开该链接后下载了一个压缩包，发现里面有一个flag_balabala.txt，但里面并没有flag.
考虑到题目是网站源码，把txt文件加到网页url后，得到flag.
bak文件 打开页面，提示说flag在index.php里
后缀加上index.php，没有反应，考虑到题目的bak文件，改为加上index.php.bak，下载备份文件
得到flag
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/370b79c9b19a7e6b5f7bf51cac7d55f6/" rel="bookmark">
			Python爬虫：网易云音乐评论爬取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0x00 写在前面0x01 iframe处理0x02 获取歌单0x03 获取歌曲0x04 获取评论0x05 完整代码0x06 总结 0x00 写在前面 这次的网易云音乐评论爬取跟ctfhub登录+签到一样，算是一次实战吧，也算是把这几天学习到的给真正拿来运用了，在这期间呢也确实又学到了新的知识，也对之前学的selenium的知识做了巩固。
0x01 iframe处理 先来看网页源码
这里采用了iframe来构造页面，当我们单纯显示网站源码时，iframe里的东西我们时看不到的，所以我这里采用了selenium的switch_to.frame来切换到iframe页面进行元素的定位和信息的填写
url = "https://music.163.com/#/search/m/" driver.get(url) driver.switch_to.frame('g_iframe')#切换到iframe部分 sleep(1) driver.find_element_by_id('m-search-input').send_keys(user)#找到输入框并输入信息 driver.find_element_by_id('m-search-input').send_keys(Keys.ENTER) 回到网站，我是想搜索用户并访问其主页，再获取用户自己创建的歌单列表和歌单网址的列表，所以我们先去获得用户主页的网址，还是先去看看网页
显然我们可以通过id搜索来确定输入框，接着我偷了个懒没有管搜索的按钮，而是直接在输入框输入enter来达到目的。最后，我们还要点击用户按钮来使得我们的搜索显示的是用户以及用户主页，最后获得table元素即可
从而，getUser函数完整代码如下：
def getUser(user, driver):#user是要搜索的用户名，driver是我们的浏览器驱动 url = "https://music.163.com/#/search/m/" driver.get(url) driver.switch_to.frame('g_iframe')#根据iframe的id切换到iframe部分 sleep(1) driver.find_element_by_id('m-search-input').send_keys(user)#向搜索框中输入用户名 driver.find_element_by_id('m-search-input').send_keys(Keys.ENTER)#输入enter，代表开始搜索 driver.find_element_by_xpath('//*[@class="m-tabs m-tabs-srch f-cb ztag"]/li[8]').click()#点击网页中的用户按钮，改变table的值 sleep(1) tab = driver.find_element_by_xpath('/html/body/div[3]/div/div[2]/div[2]/div/table/tbody')#获得table内的元素 users = tab.find_elements_by_tag_name('a')#从table中分离出包含有用数据的所有标签 list = [] for i, n in enumerate(users): if (i - 1) % 3 == 0: tu = (n.get_attribute('title'), n.get_attribute('href')) list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/370b79c9b19a7e6b5f7bf51cac7d55f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2aa0492dbff1c5e9163723547f672a6/" rel="bookmark">
			Android 开发实践（二）弄懂项目结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 项目结构总览详解 app 模块探究 HelloWorld 的运行过程理解项目中的资源：res分析 build.gradle 文件 日志工具 Log 项目结构总览 本文基于前一篇博文【开始你的 Hello World 】详述 Android 的项目结构，Android Studio 版本为 4.0 。
回到 Android Studio 我们的 HelloWorld 项目，默认会看到如下项目结构：
新建项目默认使用的是 Android 模式，适合快速开发，但不利于我们了解它的真正的项目结构，我们可以通过 “Android 下拉”按钮切换项目结构模式，我们将其切换成 Project 如下：
.gradle 存放 Android Studio 自动生成的文件.idea 存放 Android Studio 自动生成的文件app 存放代码、资源（图片等）等内容，后边补充说明build 存放编译时自动生成的文件gradle 包含 gradle wrapper 配置文件，使用 gradle wrapper 的方式不需要提前将 gradle 下载好，二是自动根据本地的缓存情况决定是否需要联网下载 gradle。Android Studio 默认就是启用 gradle wrapper 的，如果需要改成离线模式，可点击 IDE 导航栏 -&gt;File-&gt;Settings-&gt;build,Execution,Deployment-&gt;Gradle，进行配置更改.gitignore 指定需要忽略在 Git 版本控制之外的目录或文件build.gradle 项目全局的 gradle 构建脚本，通常不用修改，后边补充说明gradle.properties 项目全局的 gradle 配置文件，这个文件的配置属性会影响整个项目的 gradle 编译脚本gradlew 用于Linux 或 Mac 系统命令行界面执行 gradle 命令gradle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2aa0492dbff1c5e9163723547f672a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/612b911ca15195704ac1841c31efb733/" rel="bookmark">
			React.createElement: type is invalid --  expected a string (for built-in components) or a class/func
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 报错信息ES6 模块导出及引入CommonJS 模块导出及引入 报错信息 React运行报错：
信息如下：
Warning: React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: undefined. You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports. 就是说：React在创建组件的时候，没有拿到值。
本来应该拿的的值是字符串(对内置组件而言)，或者是class/function(对我们自定义的组件而言)。
出错原因：组件没有正确引入
可能性有很多，如：
- 被引用的组件没有导出(如忘记写export default)
- 被引用的组件导出了，但导出语法不正确
- 引入该组件时语法出错(引入模块时，需要视该模块的导出物的类型而定，)
依次检查，修改即可。
ES6 模块导出及引入 ES6模块导出引入标准写法：
只导出一个(方法，类，对象等) // Foo.js export default class Foo {} // Bar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/612b911ca15195704ac1841c31efb733/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8378a3e833f4d1553708d6991fa2fea0/" rel="bookmark">
			引用&amp;指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引用的概念：不是新定义一个变量，而是给已存在的变量取个别名，它和引用的实体共用一块内存空间。
引用的特性：
1.引用在定义时必须初始化（要存在引用的实体）
2.一个实体可以有多个引用
3.引用一旦引用一个实体，再不能引用其他实体
引用的分类：
1.普通类型的引用：可以通过引用修改其引用的实体
2.const类型的引用：主要在函数传参时使用的比较多
引用的应用场景：
1.按照概念，直接给实体取别名，让代码书写更加简单，比如—在学生结构体S中又套了一个T结构体，T中有一个整形常量a，想要引用a，就可以给其取一个别名：int&amp; ra = S.T.a；
2.作为函数的参数：按照值的方式进行实参的传参，但是可以通过实参修改外部的实参，起到了传值和传指针的结合，如果不想通过形参修改外部的实参，则给形参加上const，
3.作为函数的返回值类型：注意不能返回函数栈上的空间----比如静态成员，全局变量或者引用类型的参数，因为函数运行结束后，栈空间被回收，如果在调用的位置以引用的方式接受函数的返回值，将来该引用引用的就是一块非法的空间。
传值、传指针、传引用的效率比较：
传值的效率最低，因为传值每次都要进行值的拷贝
传指针和传引用效率几乎一样
引用和指针的区别：
底层实现上：其实，引用在底层就是按照指针的方式来实现的，因此其实引用变量也是有空间的，该空间存储的就是引用实体的地址（底层的汇编代码一样）
不同点：
1.引用在定义时必须初始化，指针没有要求
2.引用在初始化引用一个实体后，就不能再引用其他实体，但是指针可以在任何时候指向一个不同类型的实体
3.没有NULL引用但有NULL指针
4.在sizeof中含义不同，引用结果为引用类型的大小，但是指针始终是地址空间所占字节数，32位平台下为4
5.引用++即引用实体加1，指针++即指针向后偏移一个类型的大小
6.有多级指针，但没有多级引用
7.引用访问实体方式不同，指针需要解引用，引用编译器自己处理
8.引用比指针更加安全
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7ea1fabb64bc779512b1fed13dd81f2/" rel="bookmark">
			PyTorch学习笔记(八) ---- torch.nn 到底是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请注明作者和出处： http://blog.csdn.net/john_bh/
文章目录 1. MNIST 数据设置2. 从零开始的神经网络(无 torch.nn）3. 重构3.1 使用 torch.nn.functional3.2. 使用 nn.Module 进行重构3.3. 使用 nn.Linear 重构3.4. 使用优化重构3.5. 使用数据集进行重构3.6. 使用 DataLoader 进行重构 4. 添加基本功能4.1. 添加验证4.2. 创建 fit(）和 get_data(） 5. 切换到 CNN6. nn.Sequential7. 包装 DataLoader8. 使用 GPU9. 总结 PyTorch 提供设计优雅的模块和类 torch.nn ， torch.optim ， Dataset 和 DataLoader 来帮助您创建和训练神经网络。 为了充分利用它们的功能并针对您的问题对其进行自定义，需要真正地了解他们的工作。 为了建立这种理解，将首先在 MNIST 数据集上训练基本神经网络，而无需使用这些模型的任何功能； 最初只会使用最基本的 PyTorch 张量功能。 然后，将一次从 torch.nn， torch.optim， Dataset或 DataLoader中逐个添加一个功能，确切地显示每个功能，以及如何使代码更简洁或更灵活。 1. MNIST 数据设置 将使用经典的 MNIST 数据集，该数据集由手绘数字的黑白图像组成(介于 0 到 9 之间）。使用 pathlib 处理路径(Python 3 标准库的一部分），并使用请求下载数据集。 只会在使用模块时才导入它们，因此可以确切地看到正在使用模块的每个细节。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7ea1fabb64bc779512b1fed13dd81f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00f1becf86e27283c2ee4fcf6c0a0a1e/" rel="bookmark">
			information_schema.columns字段说明，获取数据库表所有列信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：http://blog.sina.com.cn/s/blog_160965eee0102xx3k.html
MySQL版本大于5.0时，有个默认数据库information_schema，里面存放着所有数据库的信息(比如表名、 列名、对应权限等)，通过这个数据库，我们就可以跨库查询，爆表爆列。
获取所有列信息(COLUMNS)
SELECT * FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='数据库名'; COLUMNS表：提供了关于表中的列的信息。详细表述了某个列属于哪个表。各字段说明如下:
若要从这些视图中检索信息，请指定完全合格的 INFORMATION_SCHEMA view_name 名称。
列名数据类型描述TABLE_CATALOGnvarchar(128)表限定符。TABLE_SCHEMAnvarchar(128)表所有者。TABLE_NAMEnvarchar(128)表名。COLUMN_NAMEnvarchar(128)列名。ORDINAL_POSITIONsmallint列标识号。COLUMN_DEFAULTnvarchar(4000)列的默认值。IS_NULLABLEvarchar(3)列的为空性。如果列允许 NULL，那么该列返回 YES。否则，返回 NO。DATA_TYPEnvarchar(128)系统提供的数据类型。CHARACTER_MAXIMUM_LENGTHsmallint以字符为单位的最大长度，适于二进制数据、字符数据，或者文本和图像数据。否则，返回 NULL。有关更多信息，请参见数据类型。CHARACTER_OCTET_LENGTHsmallint以字节为单位的最大长度，适于二进制数据、字符数据，或者文本和图像数据。否则，返回 NULL。NUMERIC_PRECISIONtinyint近似数字数据、精确数字数据、整型数据或货币数据的精度。否则，返回 NULL。NUMERIC_PRECISION_RADIXsmallint近似数字数据、精确数字数据、整型数据或货币数据的精度基数。否则，返回 NULL。NUMERIC_SCALEtinyint近似数字数据、精确数字数据、整数数据或货币数据的小数位数。否则，返回 NULL。DATETIME_PRECISIONsmallintdatetime 及 SQL-92 interval 数据类型的子类型代码。对于其它数据类型，返回 NULL。CHARACTER_SET_CATALOGvarchar(6)如果列是字符数据或 text 数据类型，那么返回 master，指明字符集所在的数据库。否则，返回 NULL。CHARACTER_SET_SCHEMAvarchar(3)如果列是字符数据或 text 数据类型，那么返回 DBO，指明字符集的所有者名称。否则，返回 NULL。CHARACTER_SET_NAMEnvarchar(128)如果该列是字符数据或 text 数据类型，那么为字符集返回唯一的名称。否则，返回 NULL。COLLATION_CATALOGvarchar(6)如果列是字符数据或 text 数据类型，那么返回 master，指明在其中定义排序次序的数据库。否则此列为 NULL。COLLATION_SCHEMAvarchar(3)返回 DBO，为字符数据或 text 数据类型指明排序次序的所有者。否则，返回 NULL。COLLATION_NAMEnvarchar(128)如果列是字符数据或 text 数据类型，那么为排序次序返回唯一的名称。否则，返回 NULL。DOMAIN_CATALOGnvarchar(128)如果列是一种用户定义数据类型，那么该列是某个数据库名称，在该数据库名中创建了这种用户定义数据类型。否则，返回 NULL。DOMAIN_SCHEMAnvarchar(128)如果列是一种用户定义数据类型，那么该列是这种用户定义数据类型的创建者。否则，返回 NULL。DOMAIN_NAMEnvarchar(128) 如果列是一种用户定义数据类型，那么该列是这种用户定义数据类型的名称。否则，返回 NULL。
首先介绍一下的是爆库
select SCHEMA_NAME from information_schema.SCHEMATA limit 5,1/* 5,1表示从第1个开始，数到第5个
然后就是爆表了。
select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=0×6D656D626572 limit 5,1/*TABLE_SCHEMA=后面是库名的16进制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00f1becf86e27283c2ee4fcf6c0a0a1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d7aa4102b1f5856d06e380f1c6e5a10/" rel="bookmark">
			因 Redis Key 命令不规范，导致熬了一个通宵才把Key删完了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击蓝色“架构文摘”关注我哟
加个“星标”，每天上午 09:25，干货推送！
来源：http://dwz.date/cmSG
前言 由于有一条业务线不理想，高层决定下架业务。对于我们技术团队而言，其对应的所有服务器资源和其他相关资源都要释放。释放了8台应用服务器；
1台es服务器；
删除分布式定时任务中心相关的业务任务；
备份并删除MySQL数据库；
删除Redis中相关的业务缓存数据。
CTO指名点姓让我带头冲锋，才扣了我绩效……好吧，冲~
其他都还好，不多时就解决了。唯独这删除Redis中的数据，害得我又熬了一个通宵，真是折煞我也！
难点分析 共用Redis服务集群 由于这条业务线的数据在Redis大概在3G左右，完全没必要单独建一个Redis服务集群，本着能节约就节约的态度，当初就决定和其他项目共享一个集群（这个集群配置：16个节点，128G内存，还算豪华吧~）集群配置如下：
在这种共用集群的情况下，导致无法简单粗暴的释放。因此只能选择删除Key的方式。
Key命名不规范 要删除Key，首先就要精准的定位出哪些Key需要删除，如果勿删Key，会影响到其他服务正常运转！如果Key本身设置了过期时间，但有些数据需是持久化的。然而那该死的项目经理一直催项目进度，导致开发人员在开发过程中很多地方都没有设计到位，比如Redis
Key散落在项目代码的每个角落；比如命名不是很规范。真不知道是怎么review代码！哦，想必是没有时间review，那该死的项目经理…… 我随便截个支付服务中的Key命名：
怎么样？是不是觉得我们开发人员写的代码很low~别笑，在实际工作中，还有比这更low的！希望你别遇到，不然真的很痛苦~
解决思路 经过以上的分析，我们简单归纳如下：
我们真正关心的是那些未设置过期时间的Key
不能误删除Key，否则下个月绩效也没了
由于Key的命名及使用及其不规范，导致Key的定位难度很大
看来，通过scan命令扫描匹配Key的方式行不通了。只能通过人肉搜索了~ 幸而Idea的搜索大法好，这个项目中使用的是spring-boot-starter-data-redis.因此我通过搜索RedisTemplate和StringRedisTemplate定位所有操作redis的代码，具体步骤如下：
通过这些代码统计出Key的前缀并录入到文本中； 通过python脚本把载入文中中的的Key并在后面加上“*”通配符； 通过python脚本通过scan命令扫描出这些key； 为了便于检查，我们并没有直接使用del命令删除key，在删除key之前，先通过debug object
key的方式得到其序列化的长度，再执行删除并返回序列化长度。这样，我们就可以统计出所有key的序列化长度来得到我们释放的空间大小。关键代码如下：
def get_key(rdbConn,start): try: keys_list = rdbConn.scan(start,count=2000) return keys_list except Exception,e: print e ''' Redis DEBUG OBJECT command got key info ''' def get_key_info(rdbConn,keyName): try: rpiple = rdbConn.pipeline() rpiple.type(keyName) rpiple.debug_object(keyName) rpiple.ttl(keyName) key_info_list = rpiple.execute() return key_info_list except Exception,e: print "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d7aa4102b1f5856d06e380f1c6e5a10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/687fd19c42468d1d02026e556aeb9f8f/" rel="bookmark">
			Python爬虫：github自动登录，ctfhub自动签到(带验证码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0x00 写在前面0x01 GitHub的登录0x02 CTFHub的登录0x03 CTFHub自动登录，签到的完整代码 0x00 写在前面 这次是记录学习过程中关于自动登录的案例，在这几天的学习中发现，很多情况下，我们都只有在登录的情况下才能看到我们想要的数据，所以自动登录是爬虫必不可少的一环
0x01 GitHub的登录 github登录网址：https://github.com/login
github的登录不需要验证码验证，也就不需要定位，直接post就行了，相对简单，就试了试不使用selenium，先用123测试一下发送数据的格式
在session下找到了post的数据
其中，用红框框起来的几条数据，看起来像是动态生成的，去网页源码里搜索一下
找到了位置，从而我们就得到了data里的所有数据。值得注意的是，这里是用了cookie在储存数据
而如果我们的request不带有cookie，登录的时候就会出现…
不能正常登录，所以我们要使用
session=requests.session() 来为网站创建一个会话对象，这样就能自动生成，储存cookie，从而正常登录，完整代码如下：
from lxml import etree import requests url='https://github.com/login' headers={"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:77.0) Gecko/20100101 Firefox/77.0"} session=requests.session()#创建会话对象，后面的所有请求都由此对象发出 response=session.get(url=url,headers=headers) response.encoding='utf-8' tree=etree.HTML(response.text) token=tree.xpath('//*[@name="authenticity_token"]/@value')[0] #gaid=tree.xpath('//*[@class="js-octo-ga-id-input"]/@value')[0] timestamp=tree.xpath('//*[@name="timestamp"]/@value')[0] timestampsec=tree.xpath('//*[@name="timestamp_secret"]')[0] data = { 'commit': 'Sign in', 'authenticity_token': token, 'ga_id':'929822435.1570627169',#可以看到本来我写了获取这个值的代码，但是我又发现这个值好像没变过，就直接写在这了 'login': 'github帐号', 'password': 'github密码', 'webauthn-support': 'supported', 'webauthn-iuvpaa-support':'unsupported', 'return_to:':'', 'required_field_05fd':'',#这里的05fd好像每次请求都不一样，但是好像是不影响登录，如果发现无法登录，可以试试post后查看对应参数并修改 'timestamp':timestamp, 'timestamp_secret':timestampsec } login=session.post(url='https://github.com/session',data=data,headers=headers) f=open('login.html','w',encoding='utf-8') f.write(login.text)#将登录后的界面写入login.html，如果显示的页面不是错误页面则说明登录成功 0x02 CTFHub的登录 ctfhub的登录使用了selenium，因为又要弄验证码，而且这码还不简单
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/687fd19c42468d1d02026e556aeb9f8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2555dcfc70819a27302c9f272ddd593/" rel="bookmark">
			3D数学-基础光照
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 3D数学-基础光照概述光源环境光源平行光源点光源聚光灯光源 吸收和散射着色光照模型BRDF光照模型标准光照模型`1.环境光(ambient)``2.自发光(emissive)``3.漫反射(diffuse)``兰伯特光照模型``半兰伯特光照模型` `4.高光反射(specular)``Phong光照模型``Blinn-Phong光照模型` 着色模型逐顶点光照（per-vertex lighting）逐像素光照（per-pixel lighting） 3D数学-基础光照 好记性不如烂笔头啊，还是记录一下!
概述 我们要模拟真实的光照环境来生成一张图像,需要考虑三种物理现象:
首先，光线从光源(light source)中发射出来。然后，光线和场景中的一些物体相交: 一些光线被物体吸收了，而另一些光线被散射到其他方向。最后，摄像机吸收了一些光，产生了一张图像。 下面，我们将对每个部分进行更加详细的解释。
光源 在实时渲染中，我们通常把光源当成一个没有体积的点，用 l l l来表示他的方向。那么，我们如何测量一个光源发射出了多少光呢？也就是说，我们如何量化光呢？在光学里，我们通常用辐照度(irradiance)来量化光。对于平行光来说，它的辐照度可通过计算在垂直于 l l l的单位面积上单位时间内穿过的能量来得到。在计算光照模型时，我们需要知道一个物体表面的辐照度，而物体表面往往时和 l l l不垂直的，那么如何计算这样的表面的辐照度呢？我们可以使用光源方向 l l l和表面法线 n n n之间的夹角的余弦值来得到。需要注意的是，这里默认方向矢量的模都为1。
由上图可知辐照度是和照射到物体表面时光线之间的距离 d / cos ⁡ θ d/\cos\theta d/cosθ成反比的，因此辐照度就和 cos ⁡ θ \cos\theta cosθ成正比。 cos ⁡ θ \cos\theta cosθ可以用光源方向 l l l和表面法线 n n n的点积来得到。这就是使用点积来计算辐照度的由来。
环境光源 环境光源也称为环境光，是一种低强度光源，由环境中所有相邻表面的反射光产生。在真实世界中，物体可以被间接光照(indirect light)所照亮。光线通常会在多个物体间反射，最后进入摄像机，在进入摄像机前，可能经过了不止一次的物体反射。利用环境光可以近似表示场景中某一区域的大概亮度，而不用对场景中所有对象件的间接反射光进行复杂的运算。环境光的计算非常简单，它通常是一个全局变量。
平行光源 平行光源，也成为无穷远光源，是从无穷远处发出的某一方向的光的光源，平行光源特别谁和模拟太阳一类的光，该光源发出的光线是平行的。该光源在有限的空中没有具体的位置，照射范围也是无限的，其强度不会随着距离的增加而减弱。
点光源 点光源是从空间中一点向各个方向发出的等强度的光的光源。点光源发出的光的强度与传播距离成反比自然衰减。
聚光灯光源 聚光灯光源除了有一个首选方向之外，其他特点与光源类似，聚光灯光源发出的光的强度与传播距离成反比自然衰减。
吸收和散射 光线由光源发射出来后，就会与一些物体相交。通常，相交的结果有两个：散射(scattering)和吸收(absorption)。
散射只改变光线方向，但不改变光线的密度和颜色。而吸收只改变光线的密度和颜色，但不改变光线的方向。光线在物体表面经过散射后，有两种方向：一种将会散射到物体内部，这种现象被称为折射(refraction)和透射(transmission)；另一种将会散射到外部，这种现象称为折射(refraction)。对于不透明物体，折射进入物体内部的光线还会继续与内部的颗粒进行相交，其中一些光线最后会重新发射出物体表面，而另一些则被物体吸收。那些从物体表面重新发射出的光线将具有和入射光线不同的方向分布和颜色，如图：
为了区分不同的散射方向，我们再光照模型中使用了不同的部分来计算它们：高光反射(specular)部分表示物体表面是如何反射光线的，而漫反射漫反射(diffuse)部分则表示有多少光线会被折射、吸收和散射出表面。根据入射光线的数量和方向，我们通常使用出射度(exitance)来描述它。辐照度和出射度之间是满足线性关系的，二它们之间的比值就是材质的漫反射和高光反射属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2555dcfc70819a27302c9f272ddd593/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cf4e962f871c2902147169f28dcb594/" rel="bookmark">
			SAP 过账报错“更正统一日记账分类账的定制设置”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		过账报错“更正统一日记账分类账的定制设置”，用FINS_CUST_CONS_CHK_P做检查，发现是货币类型出错；
检查是不是多货币和评估参数文件出错，排查了公司代码和分类账0L的货币码设置，以及公司代码货币之后，发现没有问题，于是看是不是CO area的货币类型绑定多了集团货币30，事务代码：8KEQ，路径如下；
发现是这里把货币设置了30，而分类账只设置了10，所以把这里改成10，保存再去过账就没有报错了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1515b167c8f1acfeccc6c5cbcf7b45a/" rel="bookmark">
			IDEA中gradle项目启动报错 java.lang.NoClassDefFoundError DefaultConvention解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Idea中创建gradle项目编译时报错：
详细报错信息为：
java.lang.NoClassDefFoundError: org/gradle/api/internal/plugins/DefaultConvention at org.jetbrains.plugins.gradle.tooling.builder.ProjectExtensionsDataBuilderImpl.buildAll(ProjectExtensionsDataBuilderImpl.groovy:50) at org.jetbrains.plugins.gradle.tooling.internal.ExtraModelBuilder.buildAll(ExtraModelBuilder.java:67) at org.gradle.tooling.provider.model.internal.DefaultToolingModelBuilderRegistry$BuildOperationWrappingToolingModelBuilder$1$1.create(DefaultToolingModelBuilderRegistry.java:105) at org.gradle.api.internal.project.DefaultProjectStateRegistry.withLenientState(DefaultProjectStateRegistry.java:134) at org.gradle.tooling.provider.model.internal.DefaultToolingModelBuilderRegistry$BuildOperationWrappingToolingModelBuilder$1.call(DefaultToolingModelBuilderRegistry.java:101) at org.gradle.internal.operations.DefaultBuildOperationExecutor$CallableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:409) at org.gradle.internal.operations.DefaultBuildOperationExecutor$CallableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:399) at org.gradle.internal.operations.DefaultBuildOperationExecutor$1.execute(DefaultBuildOperationExecutor.java:157) at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:242) at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:150) at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:94) at org.gradle.internal.operations.DelegatingBuildOperationExecutor.call(DelegatingBuildOperationExecutor.java:36) at org.gradle.tooling.provider.model.internal.DefaultToolingModelBuilderRegistry$BuildOperationWrappingToolingModelBuilder.buildAll(DefaultToolingModelBuilderRegistry.java:98) at org.gradle.tooling.internal.provider.runner.DefaultBuildController.getModel(DefaultBuildController.java:82) at org.gradle.tooling.internal.consumer.connection.InternalBuildActionAdapter$2.getModel(InternalBuildActionAdapter.java:77) at org.gradle.tooling.internal.consumer.connection.BuildControllerAdapter.getModel(BuildControllerAdapter.java:62) at org.gradle.tooling.internal.consumer.connection.AbstractBuildController.findModel(AbstractBuildController.java:57) at org.gradle.tooling.internal.consumer.connection.AbstractBuildController.findModel(AbstractBuildController.java:44) at org.jetbrains.plugins.gradle.model.ProjectImportAction.addExtraProject(ProjectImportAction.java:134) at org.jetbrains.plugins.gradle.model.ProjectImportAction.execute(ProjectImportAction.java:76) at org.jetbrains.plugins.gradle.model.ProjectImportAction.execute(ProjectImportAction.java:40) at org.gradle.tooling.internal.consumer.connection.InternalBuildActionAdapter.execute(InternalBuildActionAdapter.java:80) at org.gradle.tooling.internal.provider.runner.ClientProvidedBuildActionRunner$ResultBuildingListener.buildResult(ClientProvidedBuildActionRunner.java:114) at org.gradle.tooling.internal.provider.runner.ClientProvidedBuildActionRunner$ResultBuildingListener.buildFinished(ClientProvidedBuildActionRunner.java:106) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) at org.gradle.internal.event.DefaultListenerManager$ListenerDetails.dispatch(DefaultListenerManager.java:398) at org.gradle.internal.event.DefaultListenerManager$ListenerDetails.dispatch(DefaultListenerManager.java:380) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1515b167c8f1acfeccc6c5cbcf7b45a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/916a18585d7919e0849375db6c8cccde/" rel="bookmark">
			Python爬虫：验证码识别(图片链接和图片base64字符串)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0x00 写在前面0x01 验证码src里有图片的base64加密字符串0x02 验证码src中是动态的图片链接0x03 总结 0x00 写在前面 爬取数据，自动化的验证码验证是绕不开的，当然，验证码的自动识别其实都是调用其他api，在这里把这几天学习遇到过的验证码识别总结一下
0x01 验证码src里有图片的base64加密字符串 话不多说先上图
如图，这里的src获得的是经base64加密后的图片字符串，如下
src="https://img-blog.csdnimg.cn/2022010707433569853.png" 其中，在base64,后的是加密的字符串，我们把它解密就可以得到
会有很多乱码不过不影响，我们可以看出这其实就是png的文件格式的数据，也就代表我们刚才那张图片，我们可以用python自带的b64解密并将数据写入png格式的文件中，就能得到我们想要的验证码，接着再把验证码文件上传到识别验证码的api接口就行了，当然，也有的api可以直接接受base64加密后的图片字符串，比如超级鹰
只要提供了相关数据的接口，我们也就可以写出提交base64的方法函数
def PostBase64(self, b64, codetype): """ b64: 图片文件base64字符串 codetype: 题目类型 参考 http://www.chaojiying.com/price.html """ params = { 'codetype': codetype, 'file_base64': b64 } params.update(self.base_params) r = requests.post('http://upload.chaojiying.net/Upload/Processing.php', data=params, headers=self.headers) return r.json() 接下来的任务就简单了，我们只需要定位到浏览器中的验证码的位置就可以了，这里采用selenium进行定位，再用re截取加密部分的字符串，发送给api，得到对应验证码后再用sendkeys写入
from selenium import webdriver driver = Chrome() driver.get('验证码所在网址') cjy = Chaojiying_Client('超级鹰帐号', '超级鹰密码', '超级鹰软件号') #这里的cjy是外部导入的连接超级鹰api的库 img = driver.find_element_by_class_name('getCaptcha').get_attribute('src') #获得src的内容 print(img) b64 = re.findall(r'data:image/png;base64,(.*)', img)[0]#用正则截取加密字符串 print(b64) dic = cjy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/916a18585d7919e0849375db6c8cccde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc3507044e3303b83a6d05e0d9f80dc9/" rel="bookmark">
			获取B站某用户更多的关注数和粉丝数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取B站某用户更多的关注数和粉丝数 相关记录 一、 前言 B 站最多只能翻 5 页用户的关注数和粉丝数，如何能够看到更多呢。
方法我也是从网上翻来的，记载博客里，算是我研究过这个话题了。
二、需要的东西 关注数的 api
https://api.bilibili.com/x/relation/followings?vmid=2884629&amp;pn=1&amp;ps=20&amp;order=desc&amp;jsonp=jsonp关注者（粉丝）的 api
https://api.bilibili.com/x/relation/followers?vmid=2884629&amp;pn=1&amp;ps=20&amp;order=desc&amp;jsonp=jsonp 三、一点分析 关于链接获取
直接 F12，抓就可以了（其它什么工具也可以）；知道 vmid 号，直接拼也行参数修改
页数限制访问 5 页，但是每页最多可以 50。
比如：
① 关注数
https://api.bilibili.com/x/relation/followings?vmid=2884629&amp;pn=1&amp;ps=50&amp;order=desc&amp;jsonp=jsonp
② 关注者
https://api.bilibili.com/x/relation/followers?vmid=2884629&amp;pn=1&amp;ps=50&amp;order=desc&amp;jsonp=jsonp 五、总结 5 * 50 = 250 可以看 250 个关注者和粉丝数量。
只是记录一下，没有过多的内容。
点我回顶部 ☚ Fin.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24fd8909943816715ec9de0b7504c29d/" rel="bookmark">
			Cookie、session和token的区别（token和session对比选型）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 session, cookie, token 的应用以及发展历程session的原理cookie的生命周期token认证流程token和session对比选型 参考 session, cookie, token 的应用以及发展历程 session，cookie，token到底有什么区别和联系
参考URL: https://zhuanlan.zhihu.com/p/92949110
由于http是无状态的会话，所以我们需要一个东西来记录。目前我们用到的主要有三种：session，cookie 和 token。
session：
在服务器端记录，每一个会话会产生一个sessionId。当用户打开某个web应用时，便与web服务器产生一次session。服务器使用 sessionId 把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这样服务器就会根据每个人sessionId的不同，区别开谁是谁了，从而返回给用户不同的请求结果。
缺点：
如果使用单个服务器的话，用户过多的话，会造成服务器开销太大。如果我们系统采用分布式的话，我们登录时，响应我们的那台机器会记录我们登录信息，万一下一个请求，响应我们的不是原来那台机器的话，它并没有存储我们之前会话信息，就会认为我们并没有登录。session粘连或者session复制都不是特别好的方案。
那既然服务端存储这些 SessionId 这么麻烦，人类又想出一招，那就是把这些SessionId 都存储在客户端。这个时候，cookie运用而生
cookie
cookie是服务端保存在客户端的临时的少量的数据。cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。
但是，cookie 这种方式很容易被恶意攻击者入侵，那么又怎么验证客户端发给我的session id 的确是我生成的呢？ 如果不去验证，服务器都不知道他们是不是合法登录的用户， 那些不怀好意的家伙们就可以伪造session id , 为所欲为了。
这就需要我们用一种加密的方法或者可以说暗号，来验证这个id是否由我自己的服务器之前生成而非恶意攻击者篡改的。
token
token的定义：Token是服务端生成的一串字符串，当作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token并将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。
session的原理 （1）服务器在处理客户端请求过程中会创建session，并且为该session生存唯一的session ID。（这个session ID在随后的请求中会被用来重新获得已经创建的session。在session被创建后，就可以调用session相关的方法向session中新增内容，这些内容只会保存在服务器中）
（2）服务器将session ID发送到客户端
（3）当客户端再次请求时，就会带上这个session ID
（4）服务器接收到请求之后就会一句Session ID 找到相应的Session ，完成请求
ps
1、虽然session保存在服务器，但它还是需要客户端浏览器的支持，因为session需要使用cookie作为识别标志。服务器会向客户端发送一个名为JSEDDIONID的cookie，它的值为session ID。
2、当cookie被禁用时，可以使用url重写的方法：将session写在URL中，服务器在进行解析。
cookie的生命周期 cookoe的生存时间是整个会话期间：浏览器会将cookie保存在内存中，浏览器关闭时自动删除这个cookie。
cookie的生存时间是长久有效的：手动将cookie报存在客户端的硬盘中，浏览器关闭的话，cookie页不会清除；下次在打开浏览器访问对应网站内容，这个cookie就会自动再次发送到服务器。
token认证流程 token 的认证流程与cookie很相似
用户登录，成功后服务器返回Token给客户端。
客户端收到数据后保存在客户端
客户端再次访问服务器，将token放入headers中
服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码
token和session对比选型 Token是什么？和session、cookie相比，使用场景有什么区别？
参考URL: https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24fd8909943816715ec9de0b7504c29d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/126d60fa72b0c6e9c19108e76c71269c/" rel="bookmark">
			c&#43;&#43;学习笔记10 ——运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表达式：一个或多个运算对象组成。
最简单的表达式是：字面值和变量。运算符：
2.1 一元运算符（作用于一个对象）
二元运算符
三目运算符
2.2 运算符的优先级、结合律、运算对象的求值顺序，运算对象的转换
2.3 重载运算符：如IO 的&lt;&lt;、&gt;&gt;、string，vector等的迭代器
2.4 左、右值：一个左值表达式 的求值结果是一个对象或一个函数。
当一个对象被用作右值时，用的是对象的值（内容），当对象 被用作左值时，用的是对象的身份（内存中的位置） 注1：使用decltype()的时候，左值和右值不同。表达式的结果是左值，使用decltype后得到引用类型，如解引用运算符。当表达式的结果是右值时，如取地址运算符（作用于左值a，表达式结果&amp;a为右值，一个指向该运算对象的指针）
int *p=&amp;a;//解引用运算符生成左值。 decltype(*p);//该表达式的结果是 int&amp;; decltype(&amp;p);//该表达式的结果是int **，指向整形指针的指针。 decltype(&amp;a);//该表达式的结果是int *,指向a的指针 注2：
1）赋值运算符 = 需要一个左值（非常量的）作为该运算符的左侧运算对象，得到的结果也是一个左值。
2）取地址符：作用于左值运算对象，返回一个指向该运算对象的指针，该指针是一个右值。
3）内置解引用运算符、下标运算符 等求值结果都是左值，
4）内置类型和迭代器的递增递减运算符作用于左值，前置时结果也是左值。
2.2.1 优先级与结合律：
优先级相同，按从左到右的顺序
括号
优先级表：同一组内的运算符优先级相等，组的位置越靠前优先级越高
2.2.2 运算对象的求值顺序：
大多数情况下，不会明确指明求值顺序。
表达式指向并修改了同一对象，会发生错误，如：
cout&lt;&lt;i&lt;&lt;" "&lt;&lt;++i&lt;&lt;endl; 4种明确规定了运算对象的顺序的运算符：逻辑与（&amp;&amp;）、逻辑或（||）、条件（？：）、逗号运算符（，）。
算术运算符：
算术运算符：作用于：任意算术类型及任意能转换成算术类型的类型。
运算对象和求值结果都是右值，求值之前一个表达式里所有的运算会转换成同一类型。
算术表达式的异常：溢出，除数为0。 注：1）参与取余运算的运算对象必须是整数。
2）int/int 结果还是int。舍弃小数部分，
3）m%n,结果的符号与m相同。
逻辑和关系运算符：
逻辑运算符和关系运算符都返回 布尔类型
关系运算符作用于：算术类型、指针类型
逻辑运算符作用于：任意能转换成布尔值的类型 运算对象与求值结果都是右值。
逻辑与和逻辑或：短路求值
关系运算符都满足：左结合律
注意关系运算符不能连用。
赋值运算符：
赋值运算符的左侧必须是 : 可修改的左值 int i =0;//初始化，非赋值 const int ci = i;//初始化，非赋值 1024 = i;//错，字面值是右值 i+j = k;//算术表达式是右值 ci = k;//ci是常量 如果赋值运算符的左侧运算对象是 内置类型（整型数、浮点数、字符、布尔、void、枚举），则初始化列表最多包含一个值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/126d60fa72b0c6e9c19108e76c71269c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e47fc5033a6fb2855caeaabdd4c47bb0/" rel="bookmark">
			Python切割九宫格图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python切割九宫格图 朋友圈经常有人发九宫格图片，但那是使用特定的图片软件制成的或就是九章不同的照片本次我们用 Python 来制一张 九宫格主体是一个 3x3 的正方形矩阵 有9张对应的图片组成一般的软件，在遇到非矩阵型图片时难以完成重组，且有多张图片组成本次利用 Python 的 PIL 库 将一张非正方形的矩阵，切割重组成9张正方形矩阵图朋友圈可直接发送九宫格（如下图）与一张图片切割而成 # -*- coding: utf-8 -*- """ 将一张图片填充为正方形后切为9张图 """ import os from tkinter import filedialog from PIL import Image from future.moves import tkinter def open_img(): """ 打开图片 :return: """ root = tkinter.Tk() # 创建一个Tkinter.Tk()实例 root.withdraw() # 将Tkinter.Tk()实例隐藏 default_dir = r"文件路径" file_path = filedialog.askopenfilename(title=u'选择文件', initialdir=(os.path.expanduser(default_dir))) if len(file_path) != 0: image = Image.open(file_path) fill_image(image) else: SystemExit() def fill_image(img): """ 将图片填充为正方形 :param img: 图片 :return: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e47fc5033a6fb2855caeaabdd4c47bb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7c1086e362f0cc5b80b42c2728f8f3b/" rel="bookmark">
			排队论模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【 1. 排队现象 】 背景
排队论发源于上世纪初。当时美国贝尔电话公司发明了自动电话，以适应日益繁忙的工商业电话通讯需要。这个新发明带来了一个新问题，即通话线路与电话用户呼叫的数量关系应如何妥善解决，这个问题久久未能解决。1909年，丹麦的哥本哈根电话公司A.K.埃尔浪(Erlang)在热力学统计平衡概念的启发下解决了这个问题。排队现象 到达顾客服务内容服务机构病人诊断/手术医生/手术台进港的货船装货/卸货码头泊位到港的飞机降落机场跑道电话拨号通话交换台故障机器修理修理技工修理技工领取修配零件仓库管理员上游河水入库水闸管理员 【 2. 排队模型 】 排队模型介绍
（1）由于顾客到达时间和服务时间的随机性，现实中的排队现象几乎不可避免；
（2）排队过程，通常是一个随机过程，排队论又称“随机服务系统理论”； 1. 排队服务过程 2. 排队系统的要素 （1）顾客输入过程
顾客源(总体)：有限/无限;
顾客到达方式：逐个/逐批;(仅研究逐个情形)
顾客到达间隔：随机型/确定型;
顾客前后到达是否独立：相互独立/相互关联；
输入过程是否平稳：平稳/非平稳；(仅研究平稳性)
（2）排队结构、排队规则
顾客排队方式：等待制/即时制(损失制);
排队系统容量：有限制/无限制;
排队队列数目: 单列/多列;
是否中途退出: 允许/禁止;
是否列间转移（换到另一列排队）: 允许/禁止;
(此文章仅研究禁止退出和转移的情形)
（3）服务机构与服务规则
服务台(员)数目：单个/多个;
服务台(员)排列形式：并列/串列/混合;
服务台(员)服务方式：逐个/逐批;(研究逐个情形)
服务时间分布：随机型/确定型;
服务时间分布是否平稳：平稳/非平稳;(研究平稳情形)
服务台(员)为顾客服务的顺序：先到先服务(FCFS);后到先服务(LCFS);随机服务;优先服务;
3. 排队模型分类 M/M/1，M/D/1，M/ Ek /1；
M/M/c， M/M/c/∞/m，
M/M/c/N/∞ ，。。。
【 3. 参数 】 1. 系统运行状态参数 系统状态 N(t)
指排队系统在时刻 t 时的全部顾客数N(t)，
包括“排队顾客数”和“正被服务顾客数”；
系统状态概率①：瞬态概率Pn(t)
表示时刻t系统状态 N(t)=n 的概率;
系统状态概率②：稳态概率Pn
Pn= Pn(t) ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7c1086e362f0cc5b80b42c2728f8f3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afbc58aaef80845d0fdbf6582bc6c855/" rel="bookmark">
			主成成分分析法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 【 1. 主成成分分析法简介 】【 2. SPSS求解 】 参考链接：主成分分析在SPSS中的操作应用
【 1. 主成成分分析法简介 】 实际案例
一项十分著名的工作是美国的统计学家斯通(stone)在1947年关于国民经济的研究。他曾利用美国1929一1938年各年的数据，得到了17个反映国民收入与支出的变量要素，例如雇主补贴、消费资料和生产资料、纯公共支出、净增库存、股息、利息外贸平衡等等。在进行主成分分析后，竟以97.4％的精度，用三新变量就取代了原17个变量。根据经济学知识，斯通给这三个新变量分别命名为总收入F1、总收入变化率F2和经济发展或衰退的趋势F3。主成分分析（Principal Component Analysis，PCA）
在实际课题中，为了全面分析问题，往往提出很多与此有关的变量（或因素），因为每个变量都在不同程度上反映这个课题的某些信息。因此需要简化，主成分分析法就是将多个变量通过线性变换以选出较少个数重要变量的一种多元统计分析方法。主成分
由原始指标综合形成的几个新指标。依据主成分所含信息量的大小成为第一主成分，第二主成分等等。主成分与原始变量之间的关系
（1）主成分保留了原始变量绝大多数信息。
（2）主成分的个数大大少于原始变量的数目。
（3）各个主成分之间互不相关。
（4）每个主成分都是原始变量的线性组合。方法理解
假设我们所讨论的实际问题中，有p个指标，我们把这p个指标看作p个随机变量，记为X1，X2，…，Xp，主成分分析就是要把这p个指标的问题，转变为讨论p个指标的线性组合的问题，而这些新的指标F1，F2，…， Fk(k≤p），按照保留主要信息量的原则充分反映原指标的信息，并且相互独立。
这种由讨论多个指标降为少数几个综合指标的过程在数学上就叫做降维。主成分分析通常的做法是，寻求原指标的线性组合Fi。
【 2. SPSS求解 】 对沿海 10 个省市经济综合指标进行主成分分析
一、导入数据 二、降维：因子分析配置 将所需全部数据导入变量
设置描述属性
设置提取属性
设置得分属性
点击确定后即可弹出分析结果
如，GDP和GDP的相关性为1，自己和自己相关性最强；人均GDP和GDP的相关性为-0.094，说明两者相关性不强；等等；
从上表可知 GDP 与工业增加值, 第三产业增加值、固定资产投资、基本建设投资、社会消费品零售总额、地方财政收入这几个指标存在着极其显著的关系, 与海关出口总额存在着显著关系。可见许多变量之间直接的相关性比较强, 证明他们存在信息上的重叠。
可以看出第一个特征GDP占72.205%，前两个特征累计占84.551%；所以提取2个主成分。
可知 GDP、工业增加值、第三产业增加值、固定资产投资、基本建设投资、社会消费品零售总额、海关出口总额、地方财政收入在第一主成分上有较高载荷, 说明第一主成分基本反映了这些指标的信息; 人均 GDP 和农业增加值指标在第二主成分上有较高载荷, 说明第二主成分基本反映了人均GDP 和农业增加值两个指标的信息。所以提取两个主成分是可以基本反映全部指标的信息, 所以决定用两个新变量来代替原来的十个变量。
三、数据处理 1. 查看归一化后的变量值：
目的是消除因子的量纲对结果产生的影响。在之前的因子分析中系统已自动进行了归一化处理，这一步只是让归一化后的数据可视化。
归一化后的数据：
2. 方法一：成分矩阵中的数据除以主成分相对应的特征值开平方根便得到两个主成分中每个指标所对应的系数。
例如:
结果：
3. 方法二：直接用SPSS给出的数据
结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cf1a858102427b252069e6b0b798308/" rel="bookmark">
			Python爬虫：笔趣阁小说搜索和爬取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0x00 写在前面0x01 搜索页面0x02 章节获取0x03 章节内容获取0x04 完整代码 0x00 写在前面 最近开始学习Python的爬虫，就试着写了写笔趣阁小说的爬虫，由于是初学，所以正则，bs4，xpath都用了用，下面是正文
0x01 搜索页面 首先是对搜索页面的分析，网址如下：
http://www.xbiquge.la/modules/article/waps.php
先对查找方式进行测试
f12查看header
是post方法，进一步查看数据
发现数据名是searchkey，内容并没有进行加密
开始写代码
murl = 'http://www.xbiquge.la/modules/article/waps.php' headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:77.0) Gecko/20100101 Firefox/77.0"} data={'searchkey':book} response=requests.post(url=murl,data=data,headers=headers) response.encoding = "utf-8" code=response.text 这部分代码是写在函数getBook()里的，其中book是向函数传入的值，response.encoding="utf-8"这里是为了让code中的中文可以正常显示
然后我们接着分析网页
我们发现这里的搜索结果都写在这个table里，且书名的标签是td，class为even，作者也在 td class=“even” 中，这就好办了，我们可以先找到class=even的所有标签，接下来我们可以用bs4和正则表达式进行元素定位
code=response.text soup=BeautifulSoup(code,'lxml') tab=soup.select('.even') all=re.findall(r'&lt;td class="even"&gt;(.*?)&lt;/td&gt;',str(tab)) if len(all)==0: return None 这里是接着上边的函数写的，tab是用bs4定位到的所有class=even的标签源码，再接着用正则获得我们想要的内容，当然，这里得到的all的数据并不符合我们想要的数据形式，先回到网站
我们可以发现，由于这里的区别，我们就能区分开书名，作者和网址，首先我们用正则把url和书名拿到，而all中的所有数据都是even的，作者单独占了一个带有even的标签，我们输出all后不难发现，第1，3，5…即
i%2!=0
的数据都是作者的，所以我们有
name=re.findall(r'target="_blank"&gt;(.*?)&lt;/a&gt;',str(all)) author=[] url=re.findall(r'href="(.*?)"',str(all)) for i,n in enumerate(all): if i%2!=0: author.append(n) for i in range(len(name)): if i == 0: print('序号\t书名\t作者\t网址') print('['+str(i)+']\t'+name[i]+'\t'+author[i]+'\t'+url[i]) burl=input("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cf1a858102427b252069e6b0b798308/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96994412461db2cfc2adc8762d363c41/" rel="bookmark">
			AI上推荐 之 隐语义模型(LFM)和矩阵分解(MF)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 随着信息技术和互联网的发展， 我们已经步入了一个信息过载的时代，这个时代，无论是信息消费者还是信息生产者都遇到了很大的挑战：
信息消费者：如何从大量的信息中找到自己感兴趣的信息？信息生产者：如何让自己生产的信息脱颖而出， 受到广大用户的关注？ 为了解决这个矛盾， 推荐系统应时而生， 并飞速前进，在用户和信息之间架起了一道桥梁，一方面帮助用户发现对自己有价值的信息， 一方面让信息能够展现在对它感兴趣的用户前面。 推荐系统近几年有了深度学习的助推发展之势迅猛， 从前深度学习的传统推荐模型(协同过滤，矩阵分解，LR, FM, FFM, GBDT)到深度学习的浪潮之巅(DNN, Deep Crossing, DIN, DIEN, Wide&amp;Deep, Deep&amp;Cross, DeepFM, AFM, NFM, PNN, FNN, DRN), 现在正无时无刻不影响着大众的生活。
推荐系统通过分析用户的历史行为给用户的兴趣建模， 从而主动给用户推荐给能够满足他们兴趣和需求的信息， 能够真正的“懂你”。 想上网购物的时候， 推荐系统在帮我们挑选商品， 想看资讯的时候， 推荐系统为我们准备了感兴趣的新闻， 想学习充电的时候， 推荐系统为我们提供最合适的课程， 想消遣放松的时候， 推荐系统为我们奉上欲罢不能的短视频…, 所以当我们淹没在信息的海洋时， 推荐系统正在拨开一层层波浪， 为我们追寻多姿多彩的生活！
这段时间刚好开始学习推荐系统， 通过王喆老师的《深度学习推荐系统》已经梳理好了知识体系， 了解了当前推荐系统领域各种主流的模型架构和技术。 所以接下来的时间就开始对这棵大树开枝散叶，对每一块知识点进行学习总结。 所以接下来一块目睹推荐系统的风采吧！
这次整理重点放在推荐系统的模型方面， 先从传统推荐模型开始， 然后到深度学习模型。 传统模型的演化关系拿书上的一张图片， 便于梳理传统推荐模型的进化关系脉络， 对知识有个宏观的把握：
今天是第二篇， 依然来自于协同过滤算法族， 前面介绍协同过滤算法的时候做过铺垫， 协同过滤的特点就是完全没有利用到物品本身或者是用户自身的属性， 仅仅利用了用户与物品的交互信息就可以实现推荐，是一个可解释性很强， 非常直观的模型， 但是也存在一些问题， 第一个就是处理稀疏矩阵的能力比较弱， 所以为了使得协同过滤更好处理稀疏矩阵问题， 增强泛化能力， 从协同过滤中衍生出矩阵分解模型(Matrix Factorization,MF), 并发展出了矩阵分解的分支模型， 比如我们听到的很多名词隐语义模型(Latent Factor Model), LDA， 隐含类别模型， PLSA等，这里面提到最多的就是潜语义模型和矩阵分解。这俩说的差不多是一回事， 就是在协同过滤共现矩阵的基础上， 使用更稠密的隐向量表示用户和物品， 挖掘用户和物品的隐含兴趣和隐含特征， 在一定程度上弥补协同过滤模型处理稀疏矩阵能力不足的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96994412461db2cfc2adc8762d363c41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fea7c47d93da5689f31820ee525b367/" rel="bookmark">
			数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目录：
数据结构分类1、数组2、栈3、队列4、链表5、树6、散列表7、堆8、图 数据结构分类 数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 。
常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等，如图所示：
每一种数据结构都有着独特的数据存储方式，下面为大家介绍它们的结构和优缺点。
1、数组 数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。
int[] data = new int[100]；data[0] = 1; 12 优点：
1、按照索引查询元素速度快
2、按照索引遍历数组方便
缺点：
1、数组的大小固定后就无法扩容了
2、数组只能存储一种类型的数据
3、添加，删除的操作慢，因为要移动其他的元素。
适用场景：
频繁查询，对存储空间要求不大，很少增加和删除的情况。
2、栈 栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。
栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。
3、队列 队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队，示例图如下：
使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。
4、链表 链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。
链表的优点：
链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；
添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；
缺点：
因为含有大量的指针域，占用空间较大；
查找元素需要遍历链表来查找，非常耗时。
适用场景：
数据量较小，需要频繁增加，删除操作的场景
5、树 树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：
每个节点有零个或多个子节点；没有父节点的节点称为根节点；每一个非根节点有且只有一个父节点；除了根节点外，每个子节点可以分为多个不相交的子树； 在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是二叉树。
二叉树是树的特殊一种，具有如下特点：
1、每个结点最多有两颗子树，结点的度最大为2。
2、左子树和右子树是有顺序的，次序不能颠倒。
3、即使某结点只有一个子树，也要区分左右子树。
二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。
扩展：
二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，在实际应用中广泛用到，例如mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的。
6、散列表 散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。
记录的存储位置=f(key)
这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。
哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构，其示例图如下：
从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fea7c47d93da5689f31820ee525b367/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27f5ddbe851f77b6708d5cf0964a4757/" rel="bookmark">
			apache修改默认网站根目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两个地方
1.主配置文件
httpd.conf 中的 DocumentRoot 项 和 Directory 项
2.虚拟主机文件，需要在主配置文件中把注释去掉引入进主配置中
httpd-vhosts.conf 中的 DocumentRoot 项
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a14fa176df0cbc759c93506de431a52c/" rel="bookmark">
			js中 window.location.href使用post请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本来考虑使用ajax，但ajax是异步提交请求，无法跳转页面。
而window.location.href是get的请求，漏洞扫描工具会检测到，参数过长或者出于安全考虑保密数据，要使用post。
最后使用js的表单提交方法，代码如下：
&lt;script&gt; $('.test-button').click(function(){ var testId= $(this).attr('id'); var html = "&lt;form action='/manage/test' method='post' name='testform' style='display:none'&gt;" + "&lt;input type='hidden' name='testId' value="+testId+"&gt;" + "&lt;/form&gt;"; document.write(html); document.testform.submit(); }); &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd14719c439848327af1d5b2781665ca/" rel="bookmark">
			cmake-debug和release模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般在工程中，自动构建可能会编译两个版本的发布包，一个debug版本，一个release版本。那么通过cmake怎样来实现呢？本文就以这个需求为例，来介绍cmake中的逻辑控制。
文章目录 目录结构Debug-Release模式控制顶层CMakeLists.txt默认编译release 编译debug编译 控制逻辑条件命令 目录结构 |-- bin |-- build |-- CMakeLists.txt |-- src | `-- main.c Debug-Release模式控制 顶层CMakeLists.txt cmake_minimum_required(VERSION 3.12) project(test07) aux_source_directory(${PROJECT_SOURCE_DIR}/src src_dirs) # 条件判断 if(CMAKE_BUILD_TYPE AND (CMAKE_BUILD_TYPE STREQUAL "Debug")) set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -Wall -O0") message("Debug mode:${CMAKE_C_FLAGS_DEBUG}") add_executable(test_debug ${src_dirs}) elseif(CMAKE_BUILD_TYPE AND (CMAKE_BUILD_TYPE STREQUAL "Release")) set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -Wall -O3") message("Release mode:${CMAKE_C_FLAGS_RELEASE}") add_executable(test_release ${src_dirs}) else() message("else:${CMAKE_BUILD_TYPE}") message("else:${CMAKE_C_FLAGS_RELEASE}") add_executable(test_release ${src_dirs}) endif() 先简要的描述一下该CMakeLists.txt的控制逻辑。如果CMAKE_BUILD_TYPE的值为"Debug"就采用debug模式编译；如果CMAKE_BUILD_TYPE的值为"Release"就采用release模式编译；如果CMAKE_BUILD_TYPE的值为空，默认采用release模式
默认编译 从上图可以看出，CMAKE_C_FLAGS_RELEASE 编译选项的默认值为-O3 -DNDEBUG。最终生成可执行文件test_release，./test_release输出’hello cmake’。test_release文件大小为8600字节。
release 编译 从上图可以看出，通过cmake命令行指定CMAKE_BUILD_TYPE为Release，最终生成可执行文件test_release，./test_release输出’hello cmake’。test_release文件大小为8600字节。
debug编译 从上图可以看出，通过cmake命令行指定CMAKE_BUILD_TYPE为Debug，最终生成可执行文件test_release，.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd14719c439848327af1d5b2781665ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/716756d75e0fecca7e03c82089641f87/" rel="bookmark">
			LeetCode第 787 题：K 站中转内最便宜的航班(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		787. K 站中转内最便宜的航班 - 力扣（LeetCode）
典型的dijkstra算法，几乎是固定优先级队列加上bfs（bfs求出的都是最大/最小）的思路了，这题多加了一个中转站的限制
不过我还是太年轻，代码并没有通过全部案例，第43个卡住了，主要问题是使用优先级队列的话，跳出循环的条件很难处理，k值和终点哪个作为判断依据暂时不明确。
class Solution { public: struct cmp{//按照距离排序 bool operator()(const pair&lt;pair&lt;int, int&gt;, int&gt; &amp;a, const pair&lt;pair&lt;int, int&gt;, int&gt; &amp;b){ return a.first.second &lt; b.first.second; } }; int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int K) { vector&lt;int&gt; distance(n, INT_MAX);//记录该节点到起点的距离 unordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; adj; //pair里面的两个元素分别表示顶点编号和距离 for(const auto &amp;v : flights) adj[v[0]].push_back({v[1], v[2]});//构建邻接表 //pair&lt;pair&lt;编号，到起点的距离&gt;, 当前层次编号&gt;，当前层次编号是用来记录中转站的 priority_queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt;, vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt;, cmp&gt; q; q.push({{src, 0}, 0});//起点自己到自己的距离为0 while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/716756d75e0fecca7e03c82089641f87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90b74cc0b218d3d4a911ba35d4a24b0c/" rel="bookmark">
			ios 后台任务_iOS后台任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ios 后台任务
As an iOS Developer, i always find that background execution is a limitation we have learned to live with while designing and implementing apps. There are several use cases which can benefit with apps allowed to execute in background.
作为iOS开发人员，我总是发现后台执行是我们在设计和实现应用程序时学会的一个限制。 在允许在后台执行的应用程序中，有几种使用案例会受益。 With the introduction with iOS 13, Apple introduced the Background Tasks framework. This allows our apps to refresh content and perform small tasks while the app is in background.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90b74cc0b218d3d4a911ba35d4a24b0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68ff870afd20efcd468788592425fd1a/" rel="bookmark">
			lombok  Error:(32, 14) java: 找不到符号   符号:   方法 setUserName(java.lang.String)   位置: 类型为com.wtf.domain.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工程中要引入lombok
maven方式
org.projectlombok
lombok
1.16.20
provided
gradle方式
这个地方setUserName无效，这是因为没有安装idea的lombok的插件
我这是安装过的，没安装的时候是install，instsall完成之后重启idea，这样就可以正常的使用lombok注解后的方法了
然后启动程序，启动的时候会发现另外一个问题，又说是找不到符号。
Error:(32, 14) java: 找不到符号
符号: 方法 setUserName(java.lang.String)
位置: 类型为com.wtf.domain.User的变量 user1
这下再运行就搞定了，让我们愉快的使用lombok吧
转载于:https://my.oschina.net/u/2457218/blog/1609569
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ccd80b64c095603c3e449addd3a0aeb/" rel="bookmark">
			如何删除鼠标右键的显示的快捷键或功能？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：微信搜索【三桥君】
一、问题 鼠标右键的快捷键怎么取消和设置？
在界面点鼠标右键出现多了一些快捷键。怎么删掉那些快捷键?
鼠标右键管理功能设置？
如何删除鼠标右键的显示的快捷键或功能？
二、方法 1、用自己电脑安装过的电脑管理软件去下载“管理右键”功能的插件，我这里用的是“电脑管家”。
2、把不需要的右键功能给点掉即可。
三、总结 过多的右键快捷功能非常影响体验，今天实在受不了要治治这问题了。三桥君试过很多种方法，发现还是直接安装插件比较简单。个人认为留下压缩文件的功能就够了。
文章整理不易，如有帮助请点赞关注支持，谢谢！微信搜索【三桥君】，回复【关注】有我准备的一份资源大礼包。后续持续更新~~~
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/354/">«</a>
	<span class="pagination__item pagination__item--current">355/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/356/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>