<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a0926cea5030c250a5e0e8a9b2ff7a0/" rel="bookmark">
			神秘的HW到底是做什么的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		攻防演练简介
国家级攻防演练从2016年开始，已经走过了6个年头，它是由公安部组织的，这个网络安全攻防演练集结了国家顶级的攻防力量，以不限制手段、路径，进行获取权限并攻陷指定靶机为目的实战攻防演练。
通过真实网络中的攻防演练，可以全面评估目标所在网络的整体安全防护能力，检验防守方安全监测、防护和应急响应机制及措施的有效性，锻炼应急响应队伍提升安全事件处置的能力。
攻防演练主要目标涵盖国家重要行业的关键信息基础设施、每年覆盖行业、单位、系统都在逐渐扩大。
这个攻防演练时间一般持续2到3周。一般护网演练都是在白天工作日进行，不过攻击方是不分时间点在尝试攻击。
攻防演练的目的：
净化企业或机构的网络环境、强化网络安全意识；
防攻击、防破坏、防泄密、防重大网络安全故障；
检验企业关键基础设施的安全防护能力；
提升关键基础设施的网络安全防范能力和水平。
防守方和攻击方
攻防演练的主要的两个角色就是防守方和攻击方。
下面就梳理下防守方和攻击方。
(上图出自公安部第一研究所的分享会)
防守方它是不限制防御方式、监控全网攻击、及时发现并处理问题、避免内部系统被攻陷。
防守方的评分规则：发现类、消除类、应急处置类、追踪溯源类、演习总结类攻击。
攻击方是不限制攻击方式、不限制攻击手段、不限制攻击路径、以获取权限为目的。
攻击方的评分规则：获取权限、突破边界、入侵分析、攻陷靶标、重大成果。
防守方的防守要点：
1、限制报告数量，注重上报准确度；
2、明确非正常防守扣分要求；
3、设置加分上限；
4、强化追踪溯源重要性；
5、重视云、大、物、域控等管控权限；强调同等重要系统重要性。
防护方普遍存在的困难点：
防御与监测覆盖不全：防护以边界为主，内部防护较为薄弱，未覆盖完整业务场景。
资产管理难度大：缺少体系化、全面化资产发现手段，特别是互利网资产的管控不足，攻击面大、敏感信息泄露未关注，例如github、微信公众号、网盘、APP、小程序。
人员意识技能不足：保障过程要求多样化安全专业人才，对分析及溯源人员提出更高要求，安全能力不足成为存在被社工风险
自动化处置率低：无稳定可靠的保障威胁情报来源，对攻击威胁情报处置滞后，依托人工分析效率低，事件检出率低。
弱口令存在率高：除了内网的弱口令问题外，防守方对云平台、大数据、物联网等弱口令问题重视程度不够。
攻击方突破手段
利用百度文库、github、fofa、域名注册、互联网暴露资产渠道收集信息；
利用网站、系统应用、手机APP、微信小程序后台漏洞打开互联网入口；
控制内部员工邮箱、办公终端、配合社工手段获取vpn账号密码进入内网；
迂回攻击下属单位，进入内网后绕道攻击总部目标；
攻击供应链、挖掘漏洞或利用已分配权限进入内网；
利用第三方运维、内部违规员工非常外联入群专网；
使用弱口令、密码复用、密码猜测攻击获取权限；
控制欲控、堡垒机、云平台、单点登录、杀毒软件后台等系统以点打面；
搜索多网卡主机、4A系统、网闸等设备纵向渗透；
10.攻击核心主机获取重要系统权限；
11.对内部员工发动水坑、求职APP钓鱼邮件、QQ聊天、信用卡账单等社工手段进入办公网；
12.攻击第三方、利用第三方接入网络攻击目标单位。
漏洞攻击
漏洞攻击类型包括：SQL注入(GET注入、POST注入、HTTP头注入)、XSS(跨站脚本攻击)、暴力破解、扫描探测、弱口令、远程命令执行、反序列化、任意代码执行、URL重定向、文件包含、任意文件上传、未授权访问、目录穿越、业务逻辑篡改。
(上图出自公安部第一研究所的分享会)
攻防演练中高频的漏洞：
1、web漏洞为主：SQL注入、XSS(跨站脚本攻击)、文件上传漏洞等等
2、以获取系统权限漏洞为主
2.1、代码执行漏洞
2.2、反序列化漏洞
2.3、远程命令执行漏洞
2.4、任意文件上传漏洞
3、代码执行漏洞代表：struts2、spring
4、反序列化执行漏洞代表：shiro、fastjson
攻击手段和方式
常见的攻击手段包括：Oday漏洞攻击、社工钓鱼攻击、多源低频攻击、人员和管理漏洞探测、武器化攻击等等。
(上图出自公安部第一研究所的分享会)
常见的攻击方式
弱口令攻击：1.攻击使用弱口令的终端、vpn、邮箱、设备等；2.内外部账号密码复用的用户。
钓鱼攻击：通过伪装方式进行将木马或后门程序发给用户(一般通过冒充群管理员发钓鱼邮件、冒充企业发招聘信息、冒充银行发信用卡账单信息、冒充淘宝商家发福利信息等进行伪装的URL、图片、文件)，然后进行后门程序功能开启和攻击。
用户系统攻击：攻击大量存有用户信息、人员组织架构的系统、终端（VPN系统、邮件系统、OA系统、统一身份认证等等）
集权系统攻击：攻击集中类型管理器（堡垒机、统一身份认证）；攻击运维系统，集中监控类型的系统。
横向扩展攻击：攻击存在跨网段的办公、业务终端和设备
攻防演练的阶段
（上图来自奇安信官网）
启动阶段：保障团队组建、制定保障行动计划、签订保密协议
备战阶段：资产清楚与管理、全面风险自查、防护体系建设、攻防演练实战赋能
临战阶段：实战化流程制定、全员攻防演练宣导、全员社工防范测试、安全演练模拟与总结、风险持续评估优化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a0926cea5030c250a5e0e8a9b2ff7a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96d9dae4a01e446f488c579347c80cc6/" rel="bookmark">
			【Docker基础四】Docker安装Nacos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备 需安装mysql并创建nacos数据库。
没有安装mysql？看这篇文章：【Docker基础二】Docker安装Mysql8-CSDN博客
建表语句地址：建表语句(nacos github)
下载镜像 可用版本：发布 ·阿里巴巴/NACOS (github.com)
# 查看镜像 docker search nacos # 获取最新版本镜像 # docker pull nacos/nacos-server # 获取指定版本镜像 docker pull nacos/nacos-server:v2.2.1 # 查看本地镜像 docker images 创建挂载目录 # 创建挂载目录 mkdir -p /usr/local/software/docker/nacos/conf mkdir -p /usr/local/software/docker/nacos/logs mkdir -p /usr/local/software/docker/nacos/data 启动容器 先直接启动一个容器 docker run -itd \ -e MODE=standalone \ -e PREFER_HOST_MODE=hostname \ -e SPRING_DATASOURCE_PLATFORM=mysql \ -e MYSQL_SERVICE_HOST=127.0.0.1 \ -e MYSQL_SERVICE_PORT=3306 \ -e MYSQL_SERVICE_USER=root \ -e MYSQL_SERVICE_PASSWORD=gusy1234 \ -e MYSQL_SERVICE_DB_NAME=nacos_db \ -p 8848:8848 \ --name nacos \ --restart=always \ nacos/nacos-server:v2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96d9dae4a01e446f488c579347c80cc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9f3a898e4434bffb8b08c87dc40ba7d/" rel="bookmark">
			人工智能轨道交通行业周刊-第70期（2023.12.25-2024.1.7）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期关键词：噪声辨识系统、绝缘子、无缝钢轨、铁路改革、AI中台
1 整理涉及公众号名单 1.1 行业类 RT轨道交通人民铁道世界轨道交通资讯网铁路信号技术交流北京铁路轨道交通网上榜铁路视点ITS World轨道交通联盟VSTR铁路与城市轨道交通RailMetro轨道世界铁路那些事铁路技术创新智慧交通RTAI智慧城轨网轨道交通智能装备NE轨道交通铁路供电上海铁道兰州铁路中国地方铁路协会铁路社评轨道部落现代轨道交通城市地铁捡瓶子的小灰灰马公子的杂货铺 1.2 人工智能类 江大白糙科技新智元AI科技评论智东西量子位我爱计算机视觉极视平台人工智能学家AI前线当交通遇上机器学习计算机视觉life新机器视觉雷锋网人工智能产业发展联盟AIIA自动驾驶之心笔记侠夕小瑶科技说水木人工智能学堂 2 数字轨道 （1）科技创新添动能，绿智融合促发展丨成都轨道构建“轨道营城强企”新格局
导读：成都轨道集团以智慧蓉城建设为牵引，以创新引领、数字赋能、绿智融合“三位一体”的顶层布局，一盘棋推动成都轨道智慧化、绿色化建设，促进智慧城市与智慧城轨双向赋能、协同发展，助力提升智慧城市高效敏捷治理水平。
（2）拥抱5G-R新时代，共创数智化铁路新未来
导读：作为轨道交通车地无线通信LTE-M技术应用的开拓者和引领者之一，过去的数年内，鼎桥在轨道交通领域持续耕耘，开展创新的探索与实践，同时也为铁路行业量身孵化了多个解决方案，推动5G技术在铁路行业的深化应用。面对快速到来的5G-R新时代，鼎桥又将以何种姿势拥抱它？
（3）施工排放噪声的“卫兵” ——施工场界噪声辨识系统
导读：中国铁设研制的场界噪声辨识系统能够自动、实时把工地施工排放的噪声和其他噪声分离开，无需人工去除背景噪声，可对噪声扰民做出更精准判别和评价，为噪声治理提供了技术支撑。
3 轨道知识 （1）火车迷丨接触网上的棒棒是干啥的？
导读：经常坐火车的小伙伴会发现，线路两侧的电杆上固定着一串一串的棒棒，那么，它们是干啥用的？今天，小编带大家一探究竟
（2）100、500、1000......钢轨是怎么变长的？
导读：有细心的小伙伴发现，如今乘坐高铁列车原来车轮通过钢轨接头时产生的“咯噔噔......咯噔噔......”的声音听不到了，这是因为高铁列车都是在无缝线路上运行，钢轨无缝自然也就没有了声音，那无缝钢轨又是怎样焊成的呢？快跟小编一起看看吧
（3）中国铁路改革实录
导读：本文对中国铁路改革的始末进行了详细的介绍，包括铁道部政企分离、铁路局架构调整、国铁集团成立等变革，是一部很好地铁道史总结，值得学习收藏！
4 AI产业 （1）「达摩奖」专题｜2024人工智能产业趋势预测
导读：进入2024年，AI领域的未来发展充满着无限可能。基于当前的技术趋势和科技创新，大模型之家聚焦AI领域即将在2024年呈现的10大新趋势，这些趋势不仅将深刻地改变我们的生活方式，引领新一轮的产业变革和经济增长，也将为人类社会的未来发展描绘出更加美好的蓝图。
（2）总结2023，大语言模型狂奔的365天，模型、算力、工具、应用狂卷的一年！
导读：2023年，大模型领域的研究与创新在国内外“两翼齐飞”。全球科技大厂与众多创业公司、学术机构纷纷投身这场技术浪潮。粗略统计，目前全球已经发布了数百个大模型，可谓是在一年时间里，把一项通用技术“卷”上了天。但是要在千行百业里种下大模型的“花”，除了模型本身，还需要针对大模型升级云计算基础设施、配套相应的平台与工程化能力、配套面向上层应用的全新范式开发工具。
（3）1-2B参数规模大模型使用心得及模型汇总
导读：Google前几天发布的Gemini，在移动端采用1.8B参数模型面向低端手机，3.25B参数模型面向高端手机。而微软最近也是推出了2.7B的Phi-2模型，评测效果绝群。恰好笔者前段时间也在研究1-2B参数量左右的模型，因此写写心得体会；并汇总了一下现在市面上开源的1-2B参数量的大模型。
（4）构建企业级AI中台，实现业务场景价值闭环
导读：从数据资产到模型资产，大模型的发展，正在加速企业构建AI中台，旨在让更多 AI 的能力能够被构建出来、能够被管理起来、能够面向业务开放起来，打通从数据到模型到最后决策的全链路。本文将从为什么建AI中台、如何建AI中台、企业AI中台建设案例三个方面进行展开分享。
（5）「百模大战」2024走向何方？对话潞晨科技尤洋：像做PPT一样开发大模型
导读：2024年有望成为大模型的落地元年。行业将面临什么样的新趋势？开源大模型如何跑赢GPT-4等超大模型？“单机炼模”在实战中表现如何？通过对话潞晨科技创始人尤洋，智东西对此进行了深入探讨。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d355fdae65e215d9da05bcee2dea4377/" rel="bookmark">
			[论文阅读]YOLO9000：Better，Faster，Stronger
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 我们引入了YOLO9000，一个可以检测超过9000种类别的先进的实时目标检测系统。首先我们提出了多种yolo检测方法的提升方式，既新颖又参考了 之前的工作。改进后的模型，YOLOV2在标准检测任务例如PASCAL VO 和COCO 上都取得了领先。使用一个新颖的多尺度的训练方法，同一个YOLOV2模型可以在不同尺寸下行，提供了一种速度和准确率之间的简单的平衡。在67fps下，yolov2在VOC2007上取得了78.6的mAP，在40fps下，yolov2取得了78.6的mAP,在超越现有的最先进的方法例如使用了ResNet的Faster R-CNN和SSD的同时运行速度显著的快。最后我们提出了一个方法来共同训练目标检测和分类。使用这种方法我们同时在COCO目标检测数据集和ImageNet分类数据集上训练YOLO9000。我们的联合训练允许YOLO9000预测没有检测标签的对象类别的检测。我们在ImageNet检测任务上验证了我们的方法。在ImageNet检测验证集上yolo9000得到了19.7的mAP，尽管只有200个类中的44个类的检测数据。在不在coco中的156个类中，yolo9000得到了16.0的mAP。但是yolo可以检测超过200个类别，它可以预测超过9000个类别的检测。而且依然是实时运行的。
1.引言 通用的目标检测应该是快速准确同时可以识别多样的目标。自从神经网络的引入，检测框架变得越来越快和准确。然而，大多数目标检测方法现在仍旧将目标约束为一个小的目标集。
当前的目标检测数据集相比于分类和标记等其他任务是受限的。最常见的检测数据集包含数千到数十万个图像和数十到数百个标签。分类数据集包含数以百万计的图像，其中包含数万或数十万个类别。
我们希望检测扩展到目标分类的程度。然而，为图片打检测标签比打分类标签或tag要贵的多。因此我们不可能在不久的将来看到与分类数据集相同规模的检测数据集。
我们提出了一个新的方法来利用我们已有的大量的分类数据同时用其来扩大目前目标检测系统的范围。我们的方法使用了目标分类的层次视图允许我们将不同的数据集结合在一起。
我们也提出了一个联合训练算法允许我们在目标检测和分类数据集上训练目标检测器。我们的方法充分利用有标签的检测图片来学习如何区精准的定位目标同时使用分类图像来提高器词汇量和鲁棒性。
使用这种方法，我们训练了YOLO9000，一个实时对象检测器，可以检测9000多种不同的对象类别。首先，我们改进了基础的YOLO检测系统，提出了YOLOv2，一种最先进的实时探测器。然后我们使用我们的数据集组合方法和联合训练算法，在ImageNet的9000多个类别以及来自COCO的检测数据上训练模型。
我们所有的代码和预训练模型都可在线获取，http://pjreddie.com/yolo9000/。
2.更好 相对于最先进的检测系统，YOLO有很多缺点。YOLO与Fast R-CNN的误差分析表明，YOLO会产生大量的定位误差。此外，与基于区域提议的方法相比，YOLO的召回率相对较低。因此，我们主要关注在保持分类准确性的同时提高召回率和定位正确性。
计算机视觉通常趋向于更大、更深的网络。更好的性能通常取决于训练更大的网络或将多个模型集成在一起。然而，对于YOLOv2，我们想要一个更准确的探测器同时仍然很快。我们没有扩大网络，而是简化了网络，然后使表示更容易学习。我们将过去工作中的各种想法与我们自己的新想法结合起来，以提高YOLO的性能。表2是对结果的总结。
批量归一化批量归一化可以显著提高收敛性，同时消除对其他形式的正则化的需要。通过在YOLO的所有卷积层上添加批量归一化，mAP的改进幅度超过2%。批量归一化也有助于模型的规范化。通过批处理归一化，我们可以在不过度拟合的情况下从模型中去除dropout。
高分辨率分类器所有最先进的检测方法都使用在ImageNet上预训练的分类器。从AlexNet开始，大多数分类器对小于256 × 256的输入图像进行操作。原始的YOLO以224 × 224的分辨率训练分类器网络，并将检测分辨率提高到448。这意味着网络必须同时切换到学习目标检测并调整以适应新的输入分辨率。
对于YOLOv2，我们首先在ImageNet上以完整的448 × 448分辨率对分类网络进行10次微调。这使得网络有时间调整其过滤器，以便在更高分辨率的输入上更好地工作。然后我们继续对所得网络进行微调，以用于检测。这种高分辨率分类网络使我们的mAP增加了近4%。
带有锚框的卷积YOLO直接使用卷积特征提取器的全连接层来预测边界框的坐标。不直接预测坐标，Faster R-CNN使用手工挑选的先验预测边界框。仅使用卷积层的区域候选网络(RPN)在Faster R-CNN中预测锚框的偏移量和置信度。由于预测层是卷积的，RPN在特征映射的每个位置预测这些偏移量。预测偏移量而不是坐标简化了问题，使网络更容易学习。
我们从YOLO中移除完全连接的层，并使用锚框来预测边界框。首先，我们消除一个池化层，使网络的卷积层的输出具有更高的分辨率。我们还缩小了网络以在416大小的输入图像上运行，而不是448×448。我们这样做是因为我们想在我们的特征映射中有奇数个位置，这样就有一个中心单元格。物体，尤其是大的物体，往往会占据图像的中心，所以最好在中心有一个位置来预测这些物体，而不是附近的四个位置。YOLO的卷积层将图像下采样了32倍，所以通过使用416大小的输入图像，我们得到了13 × 13的输出特征图。
当我们转而使用锚框时，我们也将类预测机制与空间位置解耦，转而预测每个锚框的类和对象。和YOLO一样，对象预测仍然预测了真值和候选框的IOU，类别的预测则预测在存在一个对象的情况下，该类别的条件概率。
通过使用锚框，我们的精度略有下降。YOLO每张图像只预测98个框，但使用锚框，我们的模型可以预测超过1000个框。没有锚框，我们的中间模型得到69.5 mAP，召回率为81%。使用锚框后，我们的模型得到69.2 mAP，召回率为88%。尽管mAP降低了，但召回率的增加意味着我们的模型还有更多的改进空间。
大小聚类将锚框在YOLO中使用时，我们遇到了两个问题。首先，锚框的尺寸是手工选定的。网络可以学习适当地调整盒子，但是如果我们为网络选择更好的先验，可以让网络更容易地学到如何预测。
我们在训练集的边界框上运行kmeans聚类来自动地找寻找的更优的先验框，而不是手动选择。如果我们使用欧几里得距离下的标准kmeans，会使得大的锚框比小的锚框的距离更大也就是说聚类的结果会和框的大小相关。但是，我们真正想要的是可以获得更好的IOU的先验，而这和锚框的大小是无关的。因此，我们自定义了Kmeans的距离度量如下：
d ( b o x , c e n t r o i d ) = 1 − I O U ( b o x , c e n t r o i d ) d(box,centroid)=1-IOU(box,centroid) d(box,centroid)=1−IOU(box,centroid)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d355fdae65e215d9da05bcee2dea4377/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4833bb07b3faca80f333df2005d664fb/" rel="bookmark">
			STL标准库与泛型编程（侯捷）笔记2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STL标准库与泛型编程（侯捷） 本文是学习笔记，仅供个人学习使用。如有侵权，请联系删除。
参考链接
Youbute: 侯捷-STL标准库与泛型编程
B站: 侯捷 - STL
Github:STL源码剖析中源码 https://github.com/SilverMaple/STLSourceCodeNote/tree/master
Github:课程ppt和源码 https://github.com/ZachL1/Bilibili-plus
下面是第二讲的部分笔记：C++标准库体系结构与内核分析（第二讲）
主要介绍分配器allocator，还有容器list的底层实现，讨论iterator traits的设计
文章目录 STL标准库与泛型编程（侯捷）8 源代码之分布 VCGcc9 OOP 面向对象编程 vs GP 泛型编程10 技术基础：操作符重载and模板泛化, 全特化, 偏特化11 分配器12 容器之间的实现关系与分类13 深度探索list（上）14 深度探索list（下）15 迭代器的设计原则和Iterator Traits的作用与设计后记 8 源代码之分布 VCGcc 学这门课应该有的基础：
C++基本语法
模板基础
数据结构和算法的基础
9 OOP 面向对象编程 vs GP 泛型编程 面向对象想要把data和method关联在一起，比如list类内部实现sort函数。
泛型编程想要把data和method分开来，比如vector和deque类没有实现sort函数，而是调用algorithm里面的sort函数，两者分开来。
10 技术基础：操作符重载and模板泛化, 全特化, 偏特化 这部分在侯捷老师的面向对象课程里有详细的介绍，请参考笔者的笔记，里面含有课程的视频链接。
C++面向对象高级编程（侯捷）笔记1
C++面向对象高级编程（侯捷）笔记2
C++程序设计兼谈对象模型（侯捷）笔记
这里补充type_traits里面用到的特化（specialization）的知识
泛化指的是用模板，特化指的是指定模板到具体的类型。下面的代码中__STL_TEMPLATE_NULL指的是 template&lt;&gt; 这种类型，表示空模板。
//type_traits.h文件 // 泛化 template &lt;class _Tp&gt; struct __type_traits { typedef __true_type this_dummy_member_must_be_first; typedef __false_type has_trivial_default_constructor; typedef __false_type has_trivial_copy_constructor; typedef __false_type has_trivial_assignment_operator; typedef __false_type has_trivial_destructor; typedef __false_type is_POD_type; }; // 特化 __STL_TEMPLATE_NULL struct __type_traits&lt;int&gt; { typedef __true_type has_trivial_default_constructor; typedef __true_type has_trivial_copy_constructor; typedef __true_type has_trivial_assignment_operator; typedef __true_type has_trivial_destructor; typedef __true_type is_POD_type; }; __STL_TEMPLATE_NULL struct __type_traits&lt;unsigned int&gt; { typedef __true_type has_trivial_default_constructor; typedef __true_type has_trivial_copy_constructor; typedef __true_type has_trivial_assignment_operator; typedef __true_type has_trivial_destructor; typedef __true_type is_POD_type; }; 下图中的allocator这个类也是用到了泛化和特化，比如当allocator指定的是void类型的时候，会调用特化版本的代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4833bb07b3faca80f333df2005d664fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfacdeed0871681da0d682d861396d6f/" rel="bookmark">
			以太坊开发者会议回顾：坎昆升级、硬分叉与布拉格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：Christine Kim Galaxy研究副总裁
编译：秦晋 碳链价值
2024年1月4日，以太坊开发人员齐聚Zoom for All Core Developers Execution (ACDE) Call #178 上。ACDE电话会议通常由以太坊基金会协议负责人Tim Beiko主持，是一个开发人员讨论和协调以太坊执行层（EL）变更的双周系列会议。本周的会议由一位网名为「Lightclient」的匿名Geth EL开发人员主持。开发人员再次确认了Cancun/Deneb（Dencun）升级的接下来三个公共测试网激活日期。他们还讨论了 Dencun之后的下一个硬分叉升级Prague/Electra中代码更改（EIPs）的优先事项。
Dencun更新
假期期间没有对Dencun升级进行具体更新。自12月21日上次ACDE 电话会议以来，客户端团队一直在为Goerli 测试网准备新版本。由于之前因Prysm导致升级测试延迟，Geth开发者Marius van der Wijden 要求Prysm客户端团队提供他们切割新版本的最新进展。Prysm开发者Terence Tsao证实，Prysm团队将在下周准备好Goerli 硬分叉的新版本。不过，针对Goerli的版本将是一个「预发布」版本，这意味着它不会是推荐在以太坊主网上使用的Prysm版本。在Goerli硬分叉之后，Prysm团队计划发布另一个版本，其中包含某些更改和更新，推荐用户在主网上运行，并在Sepolia或Holesky测试网上进行测试。
虽然Tsao表示Prysm团队对Goerli硬分叉激活日期为1月17日感到满意，正如ACDE #177上讨论的那样，但他建议在Goerli硬分叉之后再确定Sepolia和Holesky硬分叉激活日期。自ACDE #177以来，以太坊基金会协议支持负责人Tim Beiko已为Goerli、Sepolia和Holesky 这三个以太坊公共测试网提出了公共测试网分叉时间。建议的分叉激活时间如下：
Goerli--2024年1月17日--纪元231680--时间戳1705473120
Sepolia--2024年1月30日--纪元132608--时间戳1706655072
Holesky--2024年2月7日--纪元29696—时间戳1707305664
Lightclient询问Prysm之外的其他客户端团队是否同意Beiko提出的 Goerli硬分叉激活时间。参加电话会议的所有客户端团队（包括Geth、Lodestar、Lighthouse、Teku和Besu）都确认，他们认为时机不错，最迟下周就能为Goerli节点操作员发布版本。Lighthouse客户端团队指出，鉴于他们仍在测试其客户端的某些网络功能，他们发布的版本可能与Prysm一样是预发布版本。
Dencun时间线分歧
随后，Lightclient就Sepolia和Holesky测试网的建议激活时间展开讨论。一位网名为「Potuz」的Prysm开发者（化名）建议暂缓确定主网之前最后两个测试网的升级日期。「我们应该尽量不要现在就承诺日期，因为Goerli的事情可能并不顺利，从那里返回是个问题。添加一个具有正确纪元的新版本，不做任何改动是很容易的。删除一个版本并修复错误则是个问题。这比几周的时间要长得多，」Potuz表示。
Lightclient强调说，客户端团队在Goerli硬分叉一周后才需要发布新版本，因此，除非在1月24日或之后在Goerli上发现升级问题，否则不一定要删除新版本。Geth开发者Marius van der Wijden表示，他认为为Sepolia和Holesky测试网设定日期并没有什么坏处，因为如果Goerli上出现问题，开发者可以随时更改日期。
以太坊基金会DevOps工程师巴纳巴斯-布萨（Barnabas Busa）在 Zoom聊天室中写道，在他看来，只有在确认Goerli的版本正常运行后，才有必要为Sepolia和Holesky 的升级发布新版本。一位网名为「Sean」的Lighthouse开发者同意这一观点，他说开发者可以为Sepolia硬分叉设定一个「暂定」日期，但在1月30日之前应该先看看Goerli的进展情况。
Potuz建议在Goerli和Sepolia 硬分叉激活之间增加一周的测试时间，基本上用两周时间进行分析，而不是三周。他说，增加一周的测试时间可以让客户端发行版「浸泡」几天，然后客户端团队才需要为下一次测试网升级再次切割新版本。「两周时间太近了。这就是我要指出的问题。」Potuz补充说，如果Goerli客户端发行版得到了充分的分析和测试，那么在Sepolia和Holesky硬分叉激活之间可能不需要三周的周转时间。
Potuz的观点引发了争议。以太坊基金会的安斯加-迪特里希斯（Ansgar Dietrichs）称，升级的第一个公共测试网激活与升级的主网激活之间的时间通常是开发者的「截止时间」，不需要延长。不过，Dietrichs也指出，对于延长测试网升级间隔时间的愿望，开发者应该在硬分叉背景下更认真地讨论，而不仅仅是Dencun升级。Dietrichs说：「如果有人希望有一个更漫长的过程，那么我们应该在有时间的时候讨论这个问题，而不是在硬分叉之前。」
Lightclient同意Dietrichs的观点，认为如果早在10月份就进行讨论，开发者很可能会对延长Dencun的测试网时间表更加宽容。Lightclient说：我认为还有一部分原因是，我们想在去年秋天完成升级，所以现在我们真的在努力实现这一目标，我认为我们的时间表安排应该更积极一些。
坚持积极的时间表
根据开发者在电话会议上分享的观点，以太坊基金会DevOps工程师 Parithosh Jayanthi 建议将Sepolia硬分叉升级推迟一周左右，并将 Sepolia硬分叉的日期定在Goerli升级之后的1月25日ACDE电话会议上。Marius van der Wijden反对完全依赖ACDE电话来重新讨论测试网升级激活的日期。他说：「我真正希望避免的是，我们不得不再打一次 All Core Devs电话来确认日期，」他补充说：我讨厌再打一次 All Core Devs电话，只是为了说「好把，Sepolia现在可以开始了。」而现在我们必须等待两周，才可以真正开始实现Sepolia。
为了安抚各方的情绪，Geth开发者Guillaume Ballet建议为Sepolia硬分叉创建两套暂定日期，如果Goerli硬分叉的结果是积极的，开发者可以坚持使用其中一套日期；如果Goerli硬分叉的结果是消极的，开发者可以使用另一套日期。然而，Lightclient和Dietrichs都反对这个想法，因为在开发者为Sepolia硬分叉设定新的时间表之前，必须先对Goerli上的错误和问题的性质进行评估。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfacdeed0871681da0d682d861396d6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/898b04ea0f02875475698eff64d09b96/" rel="bookmark">
			SpikingJelly笔记之泊松编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、泊松编码的原理二、生成符合泊松分布的脉冲序列三、SpikingJelly中的泊松编码四、Lena图像的泊松编码与还原1.原始图像2.图像编码3.图像还原 总结 前言 记录SpikingJelly中泊松编码的使用方法，对图像数据进行编码与还原
一、泊松编码的原理 基于频率的编码方式，将输入编码为发放次数分布符合泊松过程的脉冲序列
P ( X = k ) = λ k k ! e − λ P(X=k)=\frac{{\lambda}^{k}}{k!}{e}^{-\lambda} P(X=k)=k!λk​e−λ
均值λ：时间T内发放的脉冲数目
根据输入决定每个时间步发放脉冲的概率[0,1]，各时间步相互独立
二、生成符合泊松分布的脉冲序列 out_spike = torch.rand_like(x).le(x).to(x) （1）生成与输入形状相同的标准正态分布随机值
（2）将生成值与输入[0,1]比较，&lt;=为1，&gt;为0
（3）将比较生成的布尔值转化为与输入相同的数据类型
三、SpikingJelly中的泊松编码 from spikingjelly.activation_based import encoding pe = encoding.PoissonEncoder() # 泊松编码器 # 输出脉冲序列，T：时间步长，w：图像宽度，h：图像高度 out_spike = torch.zeros((T, w, h), dtype=torch.bool) # 按时间步根据输入生成脉冲序列，相互独立 for t in range(T): out_spike[t] = pe(x) # x需要归一化[0,1] 四、Lena图像的泊松编码与还原 1.原始图像 读取、展示原始图像
####################泊松编码#################### from PIL import Image import numpy as np import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/898b04ea0f02875475698eff64d09b96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db5eee12ccf221cbb583c99f49097bf0/" rel="bookmark">
			alibabacloud学习笔记02（小滴课堂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是注册中心和常见的注册中心有哪些
介绍什么是Nacos和搭建实战
启动Nacos
使用前要先安装jdk。
linux学习专栏笔记中有，大家可以去看。
关闭nacos:
这样我们就登录了nacos。
项目集成Nacos实现服务直接的调用
每个子模块都去添加。
给每个子模块配置nacos配置：
启动类添加注解，发现服务：每个服务都加
替换聚合项目的依赖版本不然可能会报错。
我们可以在我们的服务列表看到我们的服务。
使用了nacos我们就要更改原来的服务调用方法：
我们使用nacos进行服务调用。
video数据库加上这句话。
调用成功。
我们这样就可以动态的设置地址了。
讲解什么负载均衡和常见的解决方案
AlibabaCloud集成Ribbon实现负载均衡
加上注解。
我们去改动我们的video视频类，不然怎么知道是调用的那个video呢？
用于测试使用，查看我们的服务是从哪里来的。
订单服务也进行改动：
启动多个服务。
我们可以看到服务数。
重启订单服务：
默认采用这种轮询的方式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/857770f5e41104cf80843cb417135e7c/" rel="bookmark">
			SpringCloud系列篇：核心组件之声明式HTTP客户端组件【远程消费】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🥳🥳Welcome Huihui's Code World ! !🥳🥳 接下来看看由辉辉所写的关于SpringCloud的相关操作吧
目录
🥳🥳Welcome Huihui's Code World ! !🥳🥳
一. 远程消费组件是什么
二. 远程消费组件的详解
场景模拟
代码实操
1.生产者
2.消费者
3.复杂参数的处理
DTO
属性赋值
一. 远程消费组件是什么 声明式HTTP客户端组件是一种用于简化HTTP请求的编程工具。它通过提供一种声明式的方式来发送HTTP请求，而无需编写繁琐的手动请求代码。声明式HTTP客户端组件通常与特定的编程框架或库一起使用，可以根据预定义的配置和注解来自动生成HTTP请求的代码。这种方式可以提高开发效率，减少错误，并使代码更具可维护性。通过声明式HTTP客户端组件，开发者可以将精力集中在业务逻辑上，而无需过多关注底层的HTTP请求细节。
二. 远程消费组件的详解 场景模拟 当你使用一个电子商务应用程序下订单时，应用程序需要与后端的服务器进行通信以处理你的请求。在这种情况下，声明式HTTP客户端组件可以被用来简化和优化与服务器的通信。
假设你正在使用一个购物应用程序，你想要下一份外卖订单。你打开应用程序，并选择你所喜欢的餐厅和菜单项。当你点击"下订单"按钮时，应用程序会使用声明式HTTP客户端组件来发送HTTP请求到后端的服务器。
声明式HTTP客户端组件通过一种声明性的方式来定义和描述HTTP请求的结构和行为。在这个例子中，它会将你的订单信息（如餐厅ID、菜单项ID、送货地址等）转换为一个符合API规范的HTTP请求，并发送给服务器。
服务器收到请求后，会根据请求的内容来处理订单。它可能会验证订单信息、计算价格、生成订单号等。一旦服务器完成订单处理，它会将响应发送回给声明式HTTP客户端组件。
声明式HTTP客户端组件会解析服务器的响应并将其转换为应用程序可以理解的格式。例如，它可能会将响应转换为一个订单确认页面，显示订单的详细信息和预计送达时间。
通过使用声明式HTTP客户端组件，应用程序可以更轻松地与后端服务器进行通信，而无需手动构建和解析HTTP请求和响应。这使得应用程序的开发更加高效和简洁，并提供更好的用户体验。
代码实操 上面的就是一个场景模拟，现在话不多说，我们直接上代码
这里我们使用的是feign这个组件，所以需要导入相应的pom依赖
Feign： Feign是Spring Cloud提供的声明式、模板化的HTTP客户端， 它使得调用远程服务就像调用本地服务一样简单，只需要创建一个接口并添加一个注解即可
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 这里使用的例子还是生产者于消费者的例子，谁需要调用远程的服务，那么对应的那个项目的启动类中就需要添加一个注解--@EnableFeignClients 【主要是为开启feign接口扫描】
1.生产者 生产者主要是负责提供接口，其中可以使用以下几个注解接收远程调用的参数值
这里也有一个注意点：只要参数是复杂对象，即使指定了是GET方法，feign依然会以POST方法进行发送请求，同时生产者必 须支持POST请求并给参数添加@RequestBody注解
@PathVariable 路径传参 @RequestParam 多个参数中，指定接收的参数名 @RequestBody 接收复杂的参数类型（比如对象） package com.provider.main; import com.provider.main.model.User; import com.wh.common.dto.UserDto; import lombok.extern.slf4j.Slf4j; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/857770f5e41104cf80843cb417135e7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/652abe584a7d1842ced93245c7910ed5/" rel="bookmark">
			功能强大且易于使用的视频转换软件—Avdshare Video Converter for Mac/win
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今的数字时代，我们的生活离不开各种形式的媒体娱乐，而视频内容无疑是其中最为受欢迎的一种。然而，我们常常会遇到一些问题，比如我们在电脑上下载的视频无法在手机上播放，或是我们想将视频转换为其他格式以适应不同的播放设备。针对这些问题，Avdshare Video Converter for Mac(视频转换器)应运而生。
Avdshare Video Converter for Mac是一款功能强大且易于使用的视频转换软件，它可以帮助我们轻松地将视频从一种格式转换为另一种格式，以适应不同的播放设备。无论是将视频转换为MP4、AVI、MKV、MOV等常见格式，还是将视频转换为特定设备的支持格式，如iPhone、iPad、Android手机等，Avdshare Video Converter for Mac都能胜任。
除了视频格式转换，Avdshare Video Converter for Mac还具有其他强大的功能。它可以帮助我们提取视频中的音频，并将其保存为MP3、WAV、FLAC等音频格式，以供我们在音乐播放器或其他设备上欣赏。此外，该软件还支持视频编辑功能，可以裁剪、旋转、调整音量、添加水印等操作，以满足我们对视频的个性化需求。
在使用Avdshare Video Converter for Mac时，我们会发现它的操作界面简洁直观，功能菜单清晰明了，即使是没有任何技术背景的用户也能轻松上手。它还拥有快速转换速度和高质量输出的特点，确保我们在转换过程中不会浪费太多时间，同时保持视频质量的原汁原味。
Avdshare Video Converter for Mac支持批量转换，这意味着我们可以一次性转换多个视频，省去了逐个转换的麻烦。此外，它还具有视频预览功能，可以让我们在转换前先预览视频效果，确保我们得到满意的输出结果。
总的来说，Avdshare Video Converter for Mac是一款强大而实用的视频转换软件，它能够帮助我们解决各种视频格式兼容的问题，让我们享受到最佳的影音体验。无论是在工作中还是生活中，它都是我们的得力助手。如果你也想轻松转换视频格式，体验最佳影音效果，不妨试试Avdshare Video Converter for Mac吧！
Mac安装：Avdshare Video Converter for Mac(视频转换器) v7.5.2 激活版
Win安装：Avdshare Video Converter(视频格式转换工具)v7.5.2激活版+便携版
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d8e9fde6545dbfe3426e835fd391917/" rel="bookmark">
			WSL 发行版的启动下载与删除与启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WSL 发行版的启动下载与删除与启动 文章目录 WSL 发行版的启动下载与删除与启动下载删除启动通过指定名称启动发行版默认启动发行版通过 Windows 终端或其他终端工具选择 下载 首先输入命令查看拥有的发行版本：
C:\&gt;wsl --list --online 以下是可安装的有效分发的列表。 请使用“wsl --install -d &lt;分发&gt;”安装。 NAME FRIENDLY NAME Ubuntu Ubuntu Debian Debian GNU/Linux kali-linux Kali Linux Rolling Ubuntu-18.04 Ubuntu 18.04 LTS Ubuntu-20.04 Ubuntu 20.04 LTS Ubuntu-22.04 Ubuntu 22.04 LTS OracleLinux_7_9 Oracle Linux 7.9 OracleLinux_8_7 Oracle Linux 8.7 OracleLinux_9_1 Oracle Linux 9.1 openSUSE-Leap-15.5 openSUSE Leap 15.5 SUSE-Linux-Enterprise-Server-15-SP4 SUSE Linux Enterprise Server 15 SP4 SUSE-Linux-Enterprise-15-SP5 SUSE Linux Enterprise 15 SP5 openSUSE-Tumbleweed openSUSE Tumbleweed 结果都在上面的程序框图中，这样就可以查看可以下载的发行版本了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d8e9fde6545dbfe3426e835fd391917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d00c4532be5d11445d4b03c9253148f8/" rel="bookmark">
			C语言-蓝桥杯2022年第十三届省赛真题-质因数个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 给定正整数 n，请问有多少个质数是 n 的约数。
输入格式 输入的第一行包含一个整数 n。
输出格式 输出一个整数，表示 n 的质数约数个数。
样例输入 396 样例输出 3 提示 396 有 2, 3, 11 三个质数约数。
对于 30% 的评测用例，1 ≤ n ≤ 10000。
对于 60% 的评测用例，1 ≤ n ≤ 109。
对于所有评测用例，1 ≤ n ≤ 1016。
#include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; bool sort(long long n); int main() { long long n; int sum=0; cin&gt;&gt;n; if(n&lt;=1) cout&lt;&lt;'0'; if(sort(n)){//先行判断是否质数 for(long long i=2;i&lt;=sqrt(n)+1;i++){ if(n%i==0){ if(!sort(i)) sum++; if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d00c4532be5d11445d4b03c9253148f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/965082adac2d74b5512b9ddd09baa004/" rel="bookmark">
			问答领域的基本了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问答领域是人工智能领域中的一个重要研究方向，旨在让计算机能够理解人类提出的问题，并以自然语言形式回答这些问题。问答系统可以应用于各种场景，包括搜索引擎、虚拟助手、智能客服等。
一.目标 目标： 问答系统的主要目标是使计算机能够理解自然语言中的问题，并以适当的方式提供准确和有意义的答案。这需要深入处理语言语境、语义理解和推理等方面的问题。 经典的一篇论文BiDAF模型图
相应的论文连接如下：
https://arxiv.org/abs/1611.01603
ppt参考链接
https://courses.engr.illinois.edu/cs546/sp2020/Slides/Lecture19.pdf
二.类型 以下是一些常见的问答领域的类型： 1.检索型问答系统（Retrieval-based QA）： 工作原理： 通过匹配用户问题和已知问题答案对的数据库，从中检索出最相关的答案。 特点： 通常基于事先构建的知识库，对于相对固定的问题领域效果较好，但对新问题的适应能力较弱。 2.生成型问答系统（Generative QA）： 工作原理： 基于机器学习模型，如循环神经网络（RNN）或变换器（Transformer），根据问题生成新的答案。 特点： 能够处理更灵活和复杂的问题，但需要大量的训练数据和计算资源。 3.基于知识图谱的问答系统（Knowledge Graph-based QA）： 工作原理： 利用知识图谱表示实体和实体之间的关系，通过图上的查询和推理回答问题。 特点： 适用于需要结构化知识和关系的领域，对于特定领域的问题有较好的表现。 多模态问答系统（Multimodal QA）： 工作原理： 处理同时包含文本、图像、音频等多模态信息的问题，需要融合不同类型的数据来生成答案。 特点： 适用于需要多源信息的任务，如视觉问答（Visual Question Answering）。 任务型对话系统（Task-oriented Dialogue System）： 工作原理： 针对特定任务或领域，通过与用户进行对话，解决用户的问题或执行特定任务。 特点： 通常与特定领域的应用场景相结合，例如智能助手、客服机器人等。 开放领域问答系统（Open-domain QA）： 工作原理： 针对任意主题或问题，通常通过对大规模文本数据进行建模，以获取广泛的知识。 特点： 需要处理多样的问题，对语言理解和泛化能力要求较高。 这些类型的问答系统各有优势和适用场景，选择合适的类型取决于具体的任务需求和问题背景。随着技术的发展，不同类型的问答系统也在不断演进和融合，以提供更全面和智能的答案服务。
下面是一些常见的阅读理解数据集的发展脉络图
三.组成部分 问答系统通常由多个组成部分组成，这些部分共同协作以实现对用户提问的理解和答案的生成。以下是问答系统的主要组成部分：
语言理解（Language Understanding）： 词法分析： 对用户输入进行分词、词性标注等处理，将自然语言文本转换为计算机可理解的形式。 句法分析： 分析句子的结构和语法关系，以捕捉上下文中单词之间的语法规则。 语义分析： 确定句子的意义，理解用户的意图和上下文信息。 知识表示（Knowledge Representation）： 建模知识库： 将领域知识以结构化的形式表示，可以是图、表格、语义网络等形式。 知识抽取： 从文本或其他来源中抽取出有用的知识，以补充系统的知识库。 推理和逻辑（Reasoning and Logic）： 推理引擎： 利用知识和上下文进行推理，以从已知信息中推导出新的信息。 逻辑处理： 处理逻辑关系，确保系统能够进行正确的推理和答案生成。 自然语言生成（Natural Language Generation）： 生成答案： 根据系统理解的问题和推理结果，生成自然语言形式的答案。 语言风格处理： 确保生成的答案符合自然语言的语法和风格，使其更加流畅和易懂。 对话管理（Dialogue Management）： 上下文管理： 维护对话中的上下文信息，确保系统理解和适应用户的当前对话状态。 任务规划： 根据用户的目标和系统的能力规划对话中的任务流程。 信息检索和检索模型（Information Retrieval）： 检索引擎： 用于从大量数据中检索相关信息，特别是在检索型问答系统中。 相似度计算： 对问题和已知答案之间的相似度进行计算，以找到最相关的答案。 用户接口（User Interface）： 界面设计： 提供用户友好的界面，使用户能够轻松输入问题和查看系统生成的答案。 交互设计： 通过图形界面、语音交互或其他方式实现与用户的自然对话。 评估和优化模块： 性能评估： 对系统的性能进行评估，包括准确性、速度、用户满意度等指标。 模型优化： 基于评估结果对模型参数和组件进行优化，以提升系统整体性能。 这些组成部分共同构成了问答系统的整体架构，每个部分的设计和性能直接影响着系统的有效性和用户体验。随着技术的发展，问答系统的组成部分也在不断演进和改进，以更好地满足各种应用场景的需求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/965082adac2d74b5512b9ddd09baa004/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fde46faf4b15fccb8b8d5ec013500ef/" rel="bookmark">
			【大数据】Flink CDC 的概览和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink CDC 的概览和使用 1.什么是 CDC2.什么是 Flink CDC3.Flink CDC 前生今世3.1 Flink CDC 1.x3.2 Flink CDC 2.x3.3 Flink CDC 3.x 4.Flink CDC 使用5.Debezium 标准 CDC Event 格式详解 1.什么是 CDC CDC（Change Data Capture，数据变更抓取）是一种用于跟踪数据库中数据更改的技术。它用于监视数据库中的变化，并捕获这些变化，以便实时或定期将变化的数据同步到其他系统、数据仓库或分析平台。CDC 技术通常用于数据复制、数据仓库更新、实时报告和数据同步等场景。
CDC 可以捕获数据库中的以下类型的数据变化：
✅ 插入（Insert）：当新数据被插入到数据库表中时。✅ 更新（Update）：当数据库表中的现有数据被修改时。✅ 删除（Delete）：当数据从数据库表中被删除时。 2.什么是 Flink CDC Flink CDC 是一个开源的数据库变更日志捕获和处理框架，它可以实时地从各种数据库（如 MySQL、PostgreSQL、Oracle、MongoDB 等）中捕获数据变更并将其转换为流式数据。Flink CDC 可以帮助实时应用程序实时地处理和分析这些流数据，从而实现 数据同步、数据管道、实时分析 和 实时应用 等功能。
本质上是一系列的 Flink Source Connector 集合，用于来获取数据库的实时变更，底层基于 Debezium 实现。
🚀 https://github.com/ververica/flink-cdc-connectors
3.Flink CDC 前生今世 3.1 Flink CDC 1.x Flink CDC 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fde46faf4b15fccb8b8d5ec013500ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6c9e50f07328d0f024cd9dcac66cd52/" rel="bookmark">
			【C&#43;&#43;核心编程(四)】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、继承 继承是面向对象三大特性之一。
有些类与类之间存在特殊的关系，例如下图中:
我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。
这个时候我们就可以考虑利用继承的技术，减少重复代码。
1.1、继承的基本语法 例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同，接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处。
//普通实现页面 //Java class Java { public: void header() { cout &lt;&lt; "首页、公开课、登陆、注册...(公共头部)" &lt;&lt; endl; } void footer() { cout &lt;&lt; "帮助中心、交流合作、站内地图...(公共底部)" &lt;&lt; endl; } void left() { cout &lt;&lt; "Java、C++、Python...(公共分类列表)" &lt;&lt; endl; } void content() { cout &lt;&lt; "Java学科视频" &lt;&lt; endl; } }; //Python class Python { public: void header() { cout &lt;&lt; "首页、公开课、登陆、注册...(公共头部)" &lt;&lt; endl; } void footer() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6c9e50f07328d0f024cd9dcac66cd52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aff9988c118244e5c9089d7ac33580ed/" rel="bookmark">
			20240107 SQL基础50题打卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20240107 SQL基础50题打卡 1978. 上级经理已离职的公司员工 表: Employees
+-------------+----------+ | Column Name | Type | +-------------+----------+ | employee_id | int | | name | varchar | | manager_id | int | | salary | int | +-------------+----------+ 在 SQL 中，employee_id 是这个表的主键。 这个表包含了员工，他们的薪水和上级经理的id。 有一些员工没有上级经理（其 manager_id 是空值）。 查找这些员工的id，他们的薪水严格少于$30000 并且他们的上级经理已离职。当一个经理离开公司时，他们的信息需要从员工表中删除掉，但是表中的员工的manager_id 这一列还是设置的离职经理的id 。
返回的结果按照employee_id 从小到大排序。
查询结果如下所示：
示例：
输入： Employees table: +-------------+-----------+------------+--------+ | employee_id | name | manager_id | salary | +-------------+-----------+------------+--------+ | 3 | Mila | 9 | 60301 | | 12 | Antonella | null | 31000 | | 13 | Emery | null | 67084 | | 1 | Kalel | 11 | 21241 | | 9 | Mikaela | null | 50937 | | 11 | Joziah | 6 | 28485 | +-------------+-----------+------------+--------+ 输出： +-------------+ | employee_id | +-------------+ | 11 | +-------------+ 解释： 薪水少于 30000 美元的员工有 1 号(Kalel) 和 11号 (Joziah)。 Kalel 的上级经理是 11 号员工，他还在公司上班(他是 Joziah )。 Joziah 的上级经理是 6 号员工，他已经离职，因为员工表里面已经没有 6 号员工的信息了，它被删除了。 题解： # Write your MySQL query statement below select employee_id from Employees where manager_id not in (select employee_id from Employees) and salary &lt; 30000 order by employee_id; 626.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aff9988c118244e5c9089d7ac33580ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9785f238a192f015f5e158bd4210d37b/" rel="bookmark">
			数据结构之堆——学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.堆的简介：
接下来看一下堆的建立；
接下来是如何在堆中插入数据以及删除数据：
大根堆的插入操作类似只是改变了一下大于和小于符号，同时插入操作的时间复杂度为O（logn）。
来看几个问题：
答案当然是不可以：
这样的话就能根据原堆的末尾数字的大小来判断是应该尝试将它往上还是下进行移动。
来看看STL里面的优先队列：
值得注意的是 用优先队列是没有clear操作的。
接下来看几道例题：
1.堆排序：
#include&lt;bits/stdc++.h&gt; using namespace std; const int N=1e5+100; int n,heap[N],x,len=0; inline void up(int x){ while(x&gt;1 &amp;&amp; heap[x]&lt;heap[x/2]){ swap(heap[x],heap[x/2]); x/=2; } } inline void down(int k){ while(k+k&lt;=len){ int j=k+k; if(j+1&lt;=len &amp;&amp; heap[j+1]&lt;heap[j]) ++j; if(heap[j]&gt;=heap[k]) break; swap(heap[k],heap[j]); k=j; } } int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;x; heap[++len]=x; up(len); } for(int i=1;i&lt;=n;i++){ cout&lt;&lt;heap[1]&lt;&lt;' '; swap(heap[1],heap[len]); --len; down(1); } return 0; } 事实上用优先队列来做会非常的简单：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9785f238a192f015f5e158bd4210d37b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd5b10402b1fffc9182dc224573c314c/" rel="bookmark">
			信息检索领域的基本了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.基础概念 信息检索（Information Retrieval，IR）是一门研究如何从大规模的数据中找到用户感兴趣的信息的学科。该领域涉及了从各种文本、图像、音频和其他形式的数据中检索和提取信息的方法。
简单了解一下信息检索领域下的基本概念：
二.定义 定义： 信息检索是指从大量的非结构化或半结构化数据中检索出与用户信息需求相关的数据的过程。 这些信息可以是文档、网页、图像、视频等。 在信息检索中，常见的一种方式是使用向量空间模型（Vector Space Model，VSM）来表示文本数据，其中文本（如文档、网页等）和查询都被映射到向量空间中的向量。以下是一个简单的示例代码，使用Python和scikit-learn库来表示文本数据并计算文档与查询之间的相似性：
from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.metrics.pairwise import cosine_similarity # 示例文档 documents = [ "This is the first document.", "This document is the second document.", "And this is the third one.", "Is this the first document?", ] # 用户查询 query = "This is the second document." # 使用TF-IDF向量化文档和查询 vectorizer = TfidfVectorizer() tfidf_matrix = vectorizer.fit_transform(documents + [query]) # 计算文档与查询之间的余弦相似度 similarity_scores = cosine_similarity(tfidf_matrix[-1], tfidf_matrix[:-1]) # 打印相似度分数 for i, score in enumerate(similarity_scores[0]): print(f"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd5b10402b1fffc9182dc224573c314c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe1e36612c32cc6f9ee947c7aeb9a0ee/" rel="bookmark">
			每日一练：LeeCode-388. 文件的最长绝对路径【字符串、栈方法】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是力扣LeeCode-388. 文件的最长绝对路径 学习与理解过程，本文仅做学习之用，对本题感兴趣的小伙伴可以出门左拐LeeCode。
假设有一个同时存储文件和目录的文件系统。下图展示了文件系统的一个示例：
这里将 dir 作为根目录中的唯一目录。dir 包含两个子目录 subdir1 和 subdir2 。subdir1 包含文件 file1.ext 和子目录 subsubdir1；subdir2 包含子目录 subsubdir2，该子目录下包含文件 file2.ext 。
在文本格式中，如下所示(⟶表示制表符)：
dir
⟶ subdir1
⟶ ⟶ file1.ext
⟶ ⟶ subsubdir1
⟶ subdir2
⟶ ⟶ subsubdir2
⟶ ⟶ ⟶ file2.ext
如果是代码表示，上面的文件系统可以写为 "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext" 。'\n' 和'\t'分别是换行符和制表符。
文件系统中的每个文件和文件夹都有一个唯一的 绝对路径 ，即必须打开才能到达文件/目录所在位置的目录顺序，所有路径用 '/' 连接。上面例子中，指向 file2.ext 的 绝对路径 是 "dir/subdir2/subsubdir2/file2.ext" 。每个目录名由字母、数字和/或空格组成，每个文件名遵循 name.extension 的格式，其中 name 和 extension由字母、数字和/或空格组成。
给定一个以上述格式表示文件系统的字符串 input ，返回文件系统中 指向 文件 的 最长绝对路径 的长度 。 如果系统中没有文件，返回 0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe1e36612c32cc6f9ee947c7aeb9a0ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d976e47c67254c3940ba00250f1b97ef/" rel="bookmark">
			自从用了这款代码生成工具，项目开发效率大大提高了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全新前后端微商城项目，手把手教学！ 全新前后端微商城项目，手把手教学！ 全新前后端微商城项目，手把手教学！ 作者：大鹅coding
来源：juejin.cn/post/7197237024972144697
缘起 最近在做一个项目，需要新建 20 多张表
相信大多数同学应该和我一样，都是比较讨厌创建新表这个工作的，因为每创建一张表，都要去创建实体类、创建增删改查的接口、编写增删改查的 SQL 代码等等，把这些事情做完，2 个小时也就过去了
我就在思考啊，每一张表，就要耗费两个小时，20 多张表，那就是 40 多个小时，一周的时间就这样过去了。
这谁受得了呀，所以我打算写一个工具，把这些代码都自动生成出来！
在连续爆肝了 5 个晚上之后，我做出了这款自动生成业务代码的工具！
我把它放在了我的工具站上，大家可以访问这个域名直接使用：https://utilsbox.cn/?app=bizcode
目前已经开源：https://github.com/GooseCoding/utilsbox。
使用演示 下面给大家演示一下
假设我们现在创建一个商品表
首先填写表名和表的中文名称
然后我们添加商品表对应的字段，这些操作和我们日常使用的数据库工具差不多
把字段填写好了之后，点击“一键生成代码”
高潮的地方来了
DB 层、业务层、甚至是 controller 层的代码，工具都帮我们自动生成了！
来看下代码，建表 sql、增删改查 sql、表对应的实体类、DB 层的接口类、业务层的实体类、业务层的接口类、业务接口的实现类、业务层实体类和 db 层实体类的转换器，最后是 controller 层，这些代码全都帮我们生成好了。
这是什么概念呢
现在我们只需要把这些代码拷贝到项目里，简单设置一下类的引用，增删改查这些基本功能，就已经可以直接给前端去调用了。
很多同学可能会问，如果是现有的数据表，再来这里添加一次感觉太麻烦了
这个问题我也遇到了，所以我做了一个识别建表 SQL 的功能，常见的数据库工具对于已经创建好的表，都提供建表语句的复制功能，只需要把建表 SQL 粘贴到这个文本框里。
点击“识别”按钮，这个 SQL 的信息会自动识别过来，这时候只需要把表的中文名称填写上去，点击“一键生成代码”，就可以马上得到这个表的业务代码。
通用性的思考 不知道大家觉得怎么样哈，如果只是我自己用，我觉着已经非常好了，但既然是开放出来给大家用，通用性肯定还是不够的。
因为现在看到的这一套自动生成的代码，可能只是适合我，但不同的人、不同的公司，它们项目结构的分层、代码的细节，都是不一样的
所以，我还开发了代码模版配置的功能
点击“代码模版配置”按钮，在这个弹窗里，我们可以新增、删除代码的分类。同样的，也可以新增、删除和编辑具体的代码模版。
设计 代码生成的原理
在说代码模版具体怎么配置之前，先给大家讲一下代码自动生成的原理
它由代码模版和动态参数组成，核心就是匹配 - 替换
首先，工具提供了很多动态参数，这些动态参数，对应的是我们填写的表名、字段名等等这些信息的原始值，或者处理过后的值。
然后，代码模版由用户自行定义，在代码的关键位置，插入动态参数，即可形成一份代码模版。
最后，工具通过匹配和替换动态参数，最终生成了代码。
理论上，不论什么语言，你都可以配置专属于你自己的代码模版。
举个简单的栗子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d976e47c67254c3940ba00250f1b97ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68a71129fb2e1676c3499f86d8cc4b4c/" rel="bookmark">
			ES -极客学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Elasticsearch 简介及其发展历史 起源 Lucene
于 Java 语言开发的搜索引擎库类创建于 1999 年，2005 年成为 Apache 顶级开源项目Lucene 具有高性能、易扩展的优点Lucene 的局限性 只能基于 Java 语言开发类库的接口学习曲线陡峭原生并不支持水平扩展原生并不支持水平扩展 Elasticsearch 的诞生
2004 年Shay Banon 基于 Lucene 开发了 Compass2010 年Shay Banon 重写了 Compass，取名 Elasticsearch 支持分布式，可水平扩展降低全文检索的学习曲线，可以被任何编程语言调用 ES 分布式架构 ES 支持多种方式接入 ES 主要功能 ES 版本
ES 版本新功能 ES 家族成员与其应用场景 Elasticsearch的安装与简单配置 下载地址：https://www.elastic.co/cn/downloads/elasticsearch
docker 中安装elsticSearch https://zhuanlan.zhihu.com/p/669733170
https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html
1 step Install Docker.
Install Docker. Visit Get Docker to install Docker for your environment.
If using Docker Desktop, make sure to allocate at least 4GB of memory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68a71129fb2e1676c3499f86d8cc4b4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c750b1a2e3cae6dd33a8baa94be2e4/" rel="bookmark">
			数据结构之链表——学习笔记（1）（基本概念与相关的几道习题讲解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.链表的简介：
链表是一种类似于锁链的数据结构，锁链的每一节可以看成是链表之中的一个元素。
我们只要记录每一节之前和之后分别是哪一节就能把整个链表串起来。
类似于锁链，链表的每一节都可以打开，能够快速做到一些用数组存储数据时比较麻烦的操作，比如在中间插入或删除数据、取一段连续的数据、对一段连续的数据进行翻转等操作。
但是链表在访问特定编号节点的时候，需要按链上顺序逐个查找，不如数组来的方便。
2.链表的结构：
链表上的数据存储单元，一般称为节点（Node），类似于数组中的一个位置。
一个节点包含它存储的数据（Date），以及一或两个用来指向上一个/下一个节点的位置的指针。
链表有很多的类型，我目前学习的是单向链表，单向链表中的节点只记录后一节点的位置信息。
在c++中，一般使用结构体来存储链表的节点。
struct Node{ int value; Node *next; //若是双向链表 Node *prev; }; 上述就是用结构体的形式存储链表节点的例子。
单向链表：
为了维护链表i，我们一般会记录下链表的头指针（Node *head）。
在初始化的时候，一般将head设置成空指针：
Node *head=NULL 单向链表的插入：
我们通常使用函数实现此功能：
void Insert(Node *p,Node *now){ now-&gt;next=p-&gt;next; p-&gt;next=now; } 当遇见特殊情况的时候，例如我们要在头指针前插入now，那么可以这么写：
void Insert(Node *head,Node *now){ now-&gt;next=head; head=now; } 单向链表的删除：
void Delete(Node *p,Node *now){ p-&gt;next=now-&gt;next; now-&gt;next=NULL; } 我们可以通过几个例题来对链表的应用进行简单的理解：
1.小学生排序：
接下来给出代码实现：
#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int n; struct Node{//定义结构体其中包含了学生的分数以及用来指向链表下一个元素的指针变量next int s; Node *next; }*head,a[81];//记住不要忘了设置链表的头部 int main(){ cin&gt;&gt;n; head=NULL;//首先将头部定义为空 for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95c750b1a2e3cae6dd33a8baa94be2e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc4290d8a6be1daacbe0da2056029eb2/" rel="bookmark">
			GAMES101：作业6记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 总览 在之前的编程练习中,我们实现了基础的光线追踪算法,具体而言是光线传输、光线与三角形求交。我们采用了这样的方法寻找光线与场景的交点:遍历场景中的所有物体,判断光线是否与它相交。在场景中的物体数量不大时,该做法可以取得良好的结果,但当物体数量增多、模型变得更加复杂,该做法将会变得非常低效。因此,我们需要加速结构来加速求交过程。在本次练习中,我们重点关注物体划分算法 Bounding Volume Hierarchy (BVH)。本练习要求你实现 Ray-BoundingVolume 求交与 BVH 查找。
首先,你需要从上一次编程练习中引用以下函数:
Render() in Renderer.cpp: 将你的光线生成过程粘贴到此处,并且按照新框
架更新相应调用的格式。Triangle::getIntersection in Triangle.hpp: 将你的光线-三角形相交函数粘贴到此处,并且按照新框架更新相应相交信息的格式。 在本次编程练习中,你需要实现以下函数:
IntersectP(const Ray&amp; ray, const Vector3f&amp; invDir, const std::array&lt;int, 3&gt;&amp; dirIsNeg) in Bounds3.hpp: 这个函数的作用是判断包围盒 BoundingBox 与光线是否相交,你需要按照课程介绍的算法实现求交过程。getIntersection(BVHBuildNode* node, const Ray ray) in BVH.cpp: 建立 BVH 之后,我们可以用它加速求交过程。该过程递归进行,你将在其中调用你实现的 Bounds3::IntersectP. 2. 实现 Render()的实现 光线生成，这里的eye_pos被移动到了(-1,5,10)，表示的是相机的位置，和作业5不一样，揣测代码的意思eye_pos已经是世界坐标了，而scene默认的fov是90，所以，这说明相机平面中心坐标其实等价于移动到了(-1,5,9)的位置（回想作业5相机的位置是(0,0,0)，而相机平面中心的坐标是(0,0,-1)）。和作业5不同，这里的ray的起点应该是eye_pos。
void Renderer::Render(const Scene&amp; scene) { std::vector&lt;Vector3f&gt; framebuffer(scene.width * scene.height); float scale = tan(deg2rad(scene.fov * 0.5)); float imageAspectRatio = scene.width / (float)scene.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc4290d8a6be1daacbe0da2056029eb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d222e462771ce8621f89449be806630c/" rel="bookmark">
			Android蓝牙音乐SRC侧的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着电子产品的普及，越来越多的年轻人热衷于使用蓝牙技术来播放歌曲（相当多的手机品牌取消了耳机插孔），本篇文章就和大家聊聊蓝牙音乐SRC端在安卓系统中的实现原理。
安卓系统参考版本：Android-9
蓝牙SRC侧播放蓝牙音乐，音频数据都是从安卓音频系统发送过来的，蓝牙协议栈接收到音频数据处理再发送到SNK端进行播放，整体的流程大概如下图所示：
红色框图标注的部分就是我们今天探讨的内容，在对蓝牙音乐SRC介绍之前，我们得简单了解下安卓中音频系统。安卓的audio系统播放音频都是将数据发送到对应的输出设备进行播放，蓝牙自然也是其中一种音频输出设备，类似的输出设备还有如下这些，源码路径：system/media/audio/include/system/audio.h 这些音频输出设备通过HAL框架以一个个单独的模块存在于安卓系统中，音频系统服务层audioserver在初始化过程中通过HAL技术加载配置文件支持的模块。这里以蓝牙a2dp为例具体分析下加载模块的时序图：
这样音频服务就和蓝牙协议栈bluedroid建立联系，蓝牙音乐播放的音频数据就可以通过该路径源源不断的送入蓝牙协议栈中进一步处理。
蓝牙提供的音频系统的动态链接库为：audio.a2dp.default.so
源码路径：/system/bt/audio_a2dp_hw/
音频系统初始化阶段只会加载打开 audio.a2dp.default.so 获取到a2dp模块接口，至于打开输出流只有在A2DP协议连接成功后才会执行。
从以上时序图可以看到 audio.a2dp.default.so 运行在音频服务的进程中，那其又如何与蓝牙服务进程 com.android.bluetooth 交互呢？
跨进程通信有多种方式，audioserver 和 com.android.bluetooth 在蓝牙音乐数据传输场景下通过 socket 完成跨进程通信。
蓝牙协议栈创建如下两种socket与audioserver进行通信：
/data/misc/bluedroid/.a2dp_ctrl ：控制socket，传递A2DP的控制信号/data/misc/bluedroid/.a2dp_data ：数据socket，传递A2DP的音频数据 Bluedroid 通过数据 socket 接收到 audio 发送过来的音频数据后，根据A2DP连接时双方协商确定的编码方式对数据进行编码操作，最终将编码后的数据通过l2cap链路发送到SNK端。具体时序图如下：
对音频数据进行编码的具体操作则在各编码方式对应的处理函数中完成，源码路径参考：system\bt\stack\a2dp\a2dp_xxx_encoder.cc\a2dp_xxx_encode_frames()，xxx对应A2DP连接使用的编码方式(SBC、AAC、aptX、LDAC等)。
数据最终在bta层 bta_av_data_path() 处理函数中通过 p_scb-&gt;p_cos-&gt;data() 回调从 btif_a2dp_source_cb.tx_audio_queue 队列中取出，数据随后经过进一步封装发送给SNK端，SNK再反向解码出音频流播放。
蓝牙音乐SRC侧的安卓实现大体上如此，感兴趣的小伙伴欢迎私信留言一起讨论，共同学习，一起进步！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61e26571d2b864b7cb5b9d23c7ca7177/" rel="bookmark">
			vue3&#43;vite &#43;element plus日历date picker中文显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目情况 element-plus 默认是英文模式，需要中文模式的话需要设置一下：
项目框架（vue3）：vite +JS + element-plus
版本：（注意版本兼容，element plus 较低版本：1.xx.xx，不一定适合此法
"element-plus": "^2.4.4", "vue": "^3.0.4" element Plus是按需导入，需要使用el-config-provider.
nullA Vue 3 based component library for designers and developershttps://element-plus.gitee.io/zh-CN/guide/i18n.html
在App.vue中使用el-config-provider改变语言效果 main.js import { createApp } from 'vue' import App from './App.vue' import './index.css' import ElementPlus from "../src/core/element"; import 'element-plus/theme-chalk/index.css' import locale from 'element-plus/dist/locale/zh-cn.mjs' const app=createApp(App) app.use(ElementPlus) const vm= app.mount('#app') console.log(app) console.log(vm) vite. config.js pnpm run dev会警告按需引用，如要在main.js使用zh-cn.mjs,需要在项目根目录vite. config.js（如没有就创建一个），加下include路径加入。
module.exports = { lintOnSave: false,//关闭语法检查 optimizeDeps: { include: ['element-plus/dist/locale/zh-cn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61e26571d2b864b7cb5b9d23c7ca7177/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66bb1d8f736663074b7da1ee005ec63d/" rel="bookmark">
			58. 最后一个单词的长度（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。
单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。
输入： s = “luffy is still joyboy”
输出： 6
解释：最后一个单词是长度为6的“joyboy”。
代码实现： public class Main{ public static void main(String[] args) { //案例 String s = "luffy is still joyboy"; System.out.println(lengthOfLastWord(s));//6 } public static int lengthOfLastWord(String s) { //以空格分割字符串，得到字符串数组 String[] strings = s.split(" "); //取字符串数组的最后一个字符的长度 return strings[strings.length - 1].length(); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e54747e9de4384289a34e113c4aa4ccb/" rel="bookmark">
			SqueezeNet：通过紧凑架构彻底改变深度学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 在深度学习领域，对效率和性能的追求往往会带来创新的架构。SqueezeNet 是神经网络设计的一项突破，体现了这种追求。本文深入研究了 SqueezeNet 的复杂性，探讨其独特的架构、设计背后的基本原理、应用及其对深度学习领域的影响。
在创新经济中，效率是成功的货币。SqueezeNet 证明了这一点，证明在深度学习领域，少确实可以多。
二、SqueezeNet架构 2.1 综述 SqueezeNet 是一种卷积神经网络 (CNN)，可以用更少的参数实现 AlexNet 级别的精度。其架构设计巧妙，可在保持高精度的同时减小模型尺寸。SqueezeNet 的核心是“fire 模块”，这是一个紧凑的构建块，包含两层：挤压层和扩展层。挤压层利用 1x1 卷积滤波器来压缩输入数据，从而降低维度。随后，扩展层混合使用 1x1 和 3x3 滤波器来增加通道深度，捕获更广泛的特征。
SqueezeNet 是一种深度神经网络架构，旨在以更少的参数提供 AlexNet 级别的精度。它通过使用更小的卷积滤波器和称为“火模块”的策略来实现这一点。这些模块是“挤压”层和“扩展”层的组合，“挤压”层使用 1x1 滤波器来压缩输入通道，“扩展”层使用 1x1 和 3x3 滤波器的混合来增加通道深度。SqueezeNet 的主要优点是模型尺寸小和计算速度快，这使得它非常适合部署在计算资源有限的环境中，例如移动设备或嵌入式系统。此外，它的体积小，更容易通过网络传输，并且需要更少的存储内存。
2.2 设计原理 SqueezeNet 设计背后的主要动机是在不影响性能的情况下创建轻量级模型。AlexNet 等传统 CNN 虽然有效，但参数较多，导致计算成本和存储要求较高。SqueezeNet 通过采用更小的滤波器和更少的参数来解决这些挑战，从而减少计算量。这使得它特别适合部署在资源受限的环境中，例如移动设备或嵌入式系统。
2.3 SqueezeNet的应用 SqueezeNet 的紧凑尺寸和效率为各种应用开辟了新途径。在内存和处理能力有限的移动应用中，SqueezeNet 可实现高级图像识别和实时分析。在机器人技术中，它有助于高效的实时决策。此外，其较小的模型尺寸在基于网络的应用中具有优势，允许在带宽受限的网络上更快地传输神经网络模型。
2.4 对深度学习的影响 SqueezeNet 通过证明较小的网络可以与较大的网络一样有效，对深度学习领域产生了重大影响。它挑战了传统观念，即更大、更深的网络总是会产生更好的结果。这种范式转变引发了对高效神经网络设计的进一步研究，从而导致了 MobileNet 和 ShuffleNet 等其他紧凑架构的发展。
三、代码 创建 SqueezeNet 的完整 Python 实现以及合成数据集和绘图涉及几个步骤。我们将首先使用 TensorFlow 或 PyTorch 等深度学习库实现 SqueezeNet 架构。然后，我们将创建一个合成数据集，在此数据集上训练模型，最后绘制训练结果。
以下是如何使用 PyTorch 执行此操作的高级概述：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e54747e9de4384289a34e113c4aa4ccb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63d157476dbd6ffcaa0daba5e567a2f0/" rel="bookmark">
			【一】使用vue-cli创建vue3的helloworld项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不再推荐使用vue-cli命令创建vue3的项目，vue-cli 是 Vue 早期推出的一款脚手架，使用 webpack 创建 Vue 项目。后期推荐使用 create-vue，create-vue 是 Vue3 的专用脚手架，使用 vite 创建 Vue3 的项目(关注【二】使用create-vue创建vue3的helloworld项目)。
1、安装vue的环境
npm install -g @vue/cli 2、使用 vue create 命令创建项目。
vue create 命令创建项目语法格式如下：
vue create [options] &lt;app-name&gt; 创建一个由 vue-cli-service 提供支持的新项目：
options 选项可以是：
-p, --preset &lt;presetName&gt;： 忽略提示符并使用已保存的或远程的预设选项-d, --default： 忽略提示符并使用默认预设选项-i, --inlinePreset &lt;json&gt;： 忽略提示符并使用内联的 JSON 字符串预设选项-m, --packageManager &lt;command&gt;： 在安装依赖时使用指定的 npm 客户端-r, --registry &lt;url&gt;： 在安装依赖时使用指定的 npm registry-g, --git [message]： 强制 / 跳过 git 初始化，并可选的指定初始化提交信息-n, --no-git： 跳过 git 初始化-f, --force： 覆写目标目录可能存在的配置-c, --clone： 使用 git clone 获取远程预设选项-x, --proxy： 使用指定的代理创建项目-b, --bare： 创建项目时省略默认组件中的新手指导信息-h, --help： 输出使用帮助信息 接下来我们创建 runoob-vue3-app 项目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63d157476dbd6ffcaa0daba5e567a2f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e71d3b24cbc14d33b0de53b502d357e7/" rel="bookmark">
			C#中List＜T＞底层原理剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#中List底层原理剖析 1. 基础用法2. List的Capacity与Count：3.List的底层原理3.1. 构造3.2 Add()接口3.3 Remove()接口3.4 Inster()接口3.5 Clear()接口3.6 Contains()接口3.7 ToArray()接口3.8 Find()接口3.8 Sort()接口 4. 总结5. 参考 1. 基础用法 list.Max() 取最大元素
list.Avgage() 取平均值
static void Main() { List&lt;string&gt; names = new List&lt;string&gt;(); names.Add("一号元素"); names.Add("二号元素"); names.Add("狗"); names[2] = "三号元素";//修改第三个元素 string[] str = new string[] { "四号元素", "五号元素", "六号元素" }; names.AddRange(str);//为集合增加数组 Console.WriteLine("当前集合元素个数为{0}",names.Count);//返回集合元素个数 Console.WriteLine("当前集合的容量为{0}", names.Capacity);//返回当前集合的容量 //当添加元素的时候集合的容量不足以容纳所有元素就会自动增加目前元素数一倍的容量。 Console.WriteLine(names.Contains("三号元素"));//返回集合中是否存在某元素，bool类型 names.IndexOf("三号元素");//返回元素的索引值 names.Clear();//清空所有元素，元素个数为0，但是容量不变 } 2. List的Capacity与Count： Count 属性表示 List 中实际包含的元素数量。它是一个只读属性。Capacity 属性表示 List 内部数组的容量，即它可以容纳的元素的数量。容量是指分配给列表的内部数组的大小，而不是列表中实际包含的元素数量。当添加元素时，如果内部数组的容量不够，List 会自动调整容量以容纳更多的元素。 List&lt;int&gt; list1= new List&lt;int&gt;(); WriteLine($"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e71d3b24cbc14d33b0de53b502d357e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce5457226ab98a2d1a0c0b2090f12ba8/" rel="bookmark">
			Django5&#43;DRF序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 本教程将介绍如何创建一个简单的粘贴板代码高亮 Web API。在此过程中，它将介绍构成 REST 框架的各种组件，让你全面了解所有组件是如何组合在一起的。
本教程相当深入，因此在开始学习之前，你可能需要先吃一块饼干，再喝一杯你最喜欢的啤酒。如果你只想快速了解概况，那就去看看快速入门文档吧。
注意：本文代码基于入门教程的代码继续，如果有不明白的地方，建议先看入门教程的代码。
安装依赖 # 之前已经安装的 pip install django pip install djangorestframework # 需要新安装的 pip install pygments 创建新的应用 完成后，我们就可以创建一个应用程序，用来创建一个简单的 Web API。
python manage.py startapp snippets 注册新的应用：
INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'quickstart', 'snippets', 'rest_framework', ] 创建模型 在本教程中，我们将首先创建一个用于存储代码片段的简单片段模型。继续编辑 snippets/models.py 文件。注：良好的编程实践包括注释。虽然您可以在本教程代码的存储库版本中找到注释，但我们在此省略了它们，以专注于代码本身。
from django.db import models from pygments.lexers import get_all_lexers from pygments.styles import get_all_styles LEXERS = [item for item in get_all_lexers() if item[1]] # 编程语言 LANGUAGE_CHOICES = sorted([(item[1][0], item[0]) for item in LEXERS]) # 代码样式 STYLE_CHOICES = sorted([(item, item) for item in get_all_styles()]) class Snippet(models.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce5457226ab98a2d1a0c0b2090f12ba8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/052c218d7055a5209b22e3c405d1c9d9/" rel="bookmark">
			数据交互系列：简述token和如何使用token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是token（理论） 解决http短连接,无状态管理的问题。
Jeb web token(JWT),是为了在网络应用环境间传递声明而执行的一种基于JSON的开发标准，JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些科瓦ide其他业务逻辑所必须的声明信息。
👍传统的session认证 基于session认证所显露的问题 Session:每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言，seesion都是保存在内存中，而随着认证用户的增多，服务器的开销会明显增大。
扩展性：用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求这台服务器上，这个才能拿到授权，这样在分布式的应用上，相应的限制了负载均衡的能力，这也意味着限制了应用的扩展能力。
CSRF:因为基于cookie来进行用户识别的,cookie如果截获，用户就会很容易受到跨站请求伪造的攻击。
👍基于token认证的鉴权机制 基于token的鉴权机制不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。
token鉴权流程如下 优点： 因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息便于传输，jwt的构成非常简单，就是一个字符串，字节占用很小，所以它是。非常便于传输的，它不需要在服务器保存会话信息，所以易于应用的扩展。 👍JWT的结构 JWT 是由三段信息构成的，将三段信息文本用.链接一起就构成了JWT字符串,就像这样：
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
第一部分我们称它为头部(header)第二部分我们称其为载荷(payload)第三部分是签证(signature) header jwt的头部承载着两部分的信息：
声明类型声明加密的算法（通常直接使用HMAC SHA256 ） 完整的头部就像下面这样的JSON
{ 'typ':'JWT', 'alg':'HS256' } 将头部进行base64加密（该加密是可以对称解密的），构成了第一部分。
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 base64加密后变成一个完整的字符串。
payload 载荷就是存放有效信息的地方，这个名字是指飞机上承载的货品，有效信息包含三个部分
标准中注册的声明
iss:jwt签发者sub：jwt所面向的用户aud：接收jwt的一方exp：jwt的过期时间nbf：定义在什么时间之前，这过期时间必须大于签发时间iat：jwt的签发时间jti：jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击 公共的声明
公共的声明可以添加任何信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分客户端可解密。 私有的声明
例如，定义一个payload json：
{ "sub":"1234567890", "name"："john Doe", admin:true } 然后将其进行base64加密，得到jwt的第二部分
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9 signature jwt 的第三部分是一个签证信息，这个签证信息由三部分组成
header(base64后的)payload(base64后的)secret 这个部分需要base64加密后的header和base64加密后的payload使用，使用.连接组成的字符串，然后通过header声明的加密方式加密secret组合加密，然后就构成了jwt的第三部分。
var encodedString=base64UrlEncode(header)+'.'+base64UrlEncode(payload) var signature = HMACHA256(encodedString,'secret') 将这三部分用 . 连接成一个完整的字符串,构成了最终的jwt:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIi wiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
👍客户端获取到token之后 Token
token是服务端生成的一串字符串，以做客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。token可以设置在cookie或者headers中，都可以。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/052c218d7055a5209b22e3c405d1c9d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a8a36cccd04f3023a48692e7f41e8e1/" rel="bookmark">
			了解统计分类中的贝叶斯理论误差限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 统计分类和机器学习领域正在不断发展，努力提高预测模型的准确性和效率。这些进步的核心在于一个基本基准，即贝叶斯理论误差极限。这个概念深深植根于概率和统计学，是理解分类算法的局限性和潜力的基石。本文深入探讨了贝叶斯错误率的本质、其对机器学习的影响以及其应用中面临的挑战。
即使在知识完美的世界中，不确定性的低语仍然存在。因为在概率和数据领域，贝叶斯误差极限证明了分类的固有缺陷，提醒我们追求理解是一个旅程，而不是目的地。
二、贝叶斯错误率的概念概述 贝叶斯错误率，通常称为贝叶斯风险或极限，是给定数据分布下任何分类器可实现的最小错误率。它代表了一个理想的阈值，其中错误完全是由于数据本身固有的重叠或噪声，而不是分类算法的不足。
贝叶斯误差极限的基础是贝叶斯定理，这是概率论的基本原理。它涉及条件概率，并提供了一个根据新证据更新概率估计的框架。
贝叶斯理论误差限，也称为贝叶斯错误率，是统计分类和机器学习中的基本概念。它代表任何分类器在预测新数据点的类别时可以实现的最低可能错误率。该限制由数据本身的固有噪声或重叠决定，并且是数据中不同类别本质上无法区分的程度的度量。
这是一个简单的解释：假设您有一个包含两类项目的数据集，例如苹果和橙子。完美的分类器总是能正确地将苹果识别为苹果，将橙子识别为橙子。然而，如果由于自然变化，某些苹果看起来与橙子一模一样（反之亦然），那么即使是最好的分类器也会在这些项目上犯错误。考虑到类之间固有的相似性（或重叠），贝叶斯错误率是任何分类器在此任务中可以实现的最低错误率。
贝叶斯错误率很重要，因为它可以作为分类器性能的理论基准。如果分类器的错误率接近贝叶斯率，则它的效果与给定数据的预期一样好。另一方面，如果分类器的错误率和贝叶斯率之间存在很大差距，则分类器的设计可能还有改进的空间。
在实践中，计算贝叶斯错误率可能具有挑战性，因为它需要完全了解数据集中类的真实基础分布。通常，真实分布是未知的，贝叶斯错误率只能估计。
三、机器学习中的贝叶斯错误率 3.1 错误率与性能 分类器性能基准测试：在机器学习的背景下，贝叶斯错误率是评估分类器性能的黄金标准。性能接近此限制的分类器被认为是最佳的，因为它可以有效地管理数据类别的不可区分的方面。对模型选择和设计的影响：了解贝叶斯极限有助于选择合适的模型和设计算法。如果模型的性能显着偏离该理论极限，则表明模型本身或特征选择和预处理方面存在改进的潜力。 3.2 计算贝叶斯错误率的挑战 估计困难：应用贝叶斯错误率的主要挑战之一是其计算。精确的计算需要完整而精确地理解数据的潜在概率分布，这在现实场景中通常是不切实际或不可能的。近似技术：已经开发了各种近似方法来估计贝叶斯错误率。其中包括交叉验证、引导和采用替代模型来近似底层数据分布等技术。 3.3 实际意义和局限性 实际应用：实际上，贝叶斯错误率提供了一个理论框架，用于理解医疗诊断、语音识别和金融预测等各个领域的分类局限性。局限性和误解：虽然贝叶斯错误率是一个强大的概念，但认识到其局限性至关重要。它没有考虑其他重要方面，例如计算效率、可扩展性以及精度和召回率之间的权衡。 四、代码 为了使用 Python 演示贝叶斯理论误差限，我们将创建一个合成数据集，实现一个基本分类器，然后估计贝叶斯错误率。我们将使用 NumPy、Scikit-learn 和 Matplotlib 等库来完成此任务。该过程涉及以下步骤：
创建综合数据集：生成包含两个类的数据集，其中类有一些重叠，从而无法进行完美分类。实现分类器：使用 Scikit-learn 中的标准分类器对数据进行分类。估计贝叶斯错误率：由于我们可以控制数据集，因此我们可以通过了解基础分布来估计贝叶斯错误。绘制结果：可视化数据集和分类决策边界。 让我们首先编写这些步骤的代码。
# @evertongomede import numpy as np import matplotlib.pyplot as plt from sklearn.datasets import make_classification from sklearn.naive_bayes import GaussianNB from sklearn.metrics import accuracy_score from matplotlib.colors import ListedColormap # Step 1: Create a Synthetic Dataset X, y = make_classification(n_samples=300, n_features=2, n_redundant=0, n_clusters_per_class=1, flip_y=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a8a36cccd04f3023a48692e7f41e8e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6973668ef911012e6998fd5563ec8e17/" rel="bookmark">
			Java 集合面试题真实场景还原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 集合面试题真实场景还原 文章目录 Java 集合面试题真实场景还原Java常见的集合类ListHashMap Java常见的集合类 面试官：说一说Java提供的常见集合？（画一下集合结构图）
候选人：
嗯~~，好的。
在java中提供了量大类的集合框架，主要分为两类：
第一个是Collection 属于单列集合，第二个是Map 属于双列集合
在Collection中有两个子接口List和Set。在我们平常开发的过程中用的比较多像list接口中的实现类ArrarList和LinkedList。 在Set接口中有实现类HashSet和TreeSet。在map接口中有很多的实现类，平时比较常见的是HashMap、TreeMap，还有一个线程安全的map:ConcurrentHashMap List 面试官：ArrayList底层是如何实现的？
候选人：
嗯~，我阅读过arraylist的源码，我主要说一下add方法吧
第一：确保数组已使用长度（size）加1之后足够存下下一个数据
第二：计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）
第三：确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。
第四：返回添加成功布尔值。
面试官：ArrayList list=new ArrayList(10)中的list扩容几次
候选人：
​ 是new了一个ArrarList并且给了一个构造参数10，对吧？(问题一定要问清楚再答)
面试官：是的
候选人：
​ 好的，在ArrayList的源码中提供了一个带参数的构造方法，这个参数就是指定的集合初始长度，所以给了一个10的参数，就是指定了集合的初始长度是10，这里面并没有扩容。
面试官：如何实现数组和List之间的转换
候选人：
​ 嗯，这个在我们平时开发很常见
​ 数组转list，可以使用jdk自动的一个工具类Arrars，里面有一个asList方法可以转换为数组
​ List 转数组，可以直接调用list中的toArray方法，需要给一个参数，指定数组的类型，需要指定数组的长度。
面试官：用Arrays.asList转List后，如果修改了数组内容，list受影响吗？List用toArray转数组后，如果修改了List内容，数组受影响吗
候选人：
Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址
list用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响
面试官：ArrayList 和 LinkedList 的区别是什么？
候选人：
嗯，它们两个主要是底层使用的数据结构不一样，ArrayList 是动态数组，LinkedList 是双向链表，这也导致了它们很多不同的特点。
1，从操作数据效率来说
ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】， LinkedList不支持下标查询
查找（未知索引）： ArrayList需要遍历，链表也需要链表，时间复杂度都是O(n)
新增和删除
ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n) 2，从内存空间占用来说
ArrayList底层是数组，内存连续，节省内存
LinkedList 是双向链表需要存储数据，和两个指针，更占用内存
3，从线程安全来说，ArrayList和LinkedList都不是线程安全的
面试官：嗯，好的，刚才你说了ArrayList 和 LinkedList 不是线程安全的，你们在项目中是如何解决这个的线程安全问题的？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6973668ef911012e6998fd5563ec8e17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ee7d166ea7924ca855f50a9e21ab13b/" rel="bookmark">
			批量归一化：彻底改变深度学习架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 在深度学习的动态领域，批量归一化的引入标志着神经网络训练方法的关键转变。这项创新技术由 Sergey Ioffe 和 Christian Szegedy 在 2015 年提出，已成为现代神经网络架构的基石。它解决了训练深度网络的关键挑战，特别是处理臭名昭著的内部协变量偏移问题。本文旨在阐明批量归一化的概念、其对深度网络训练的深远影响及其在各种应用中的实际意义。
在神经计算领域，批量归一化类似于风暴中的指南针，可以稳定学习算法在内部协变量变化的汹涌海洋中的航行。
二、了解批量归一化 批量归一化的核心是一种用于标准化神经网络中某一层的输入的技术。它的工作原理是通过减去批次均值并将其除以批次标准差来标准化先前激活层的输出。因此，这种归一化过程确保后续层的输入具有稳定的分布，从而促进更平滑和更快的训练过程。
批量归一化是神经网络中使用的一种技术，用于标准化每个小批量的层输入。这具有稳定学习过程并显着减少训练深度网络所需的训练周期数的效果。
以下是其工作原理的更详细分解：
归一化：对于每个特征，均值和方差是在小批量上计算的。然后，根据该均值和方差对特征进行归一化。缩放和平移：归一化后，使用在训练过程中学习到的两个参数 γ（缩放）和 β（平移）对特征进行缩放和平移。此步骤至关重要，因为标准化过程有时会以网络无法学习的方式改变特征的表示。如果需要最大程度地减少损失，则缩放和移位允许网络撤消标准化。改进训练：批量归一化允许网络的每一层独立于其他层学习更多一点。它还有助于减少内部协变量偏移问题，即随着前一层参数的变化，每层输入的分布在训练过程中发生变化，这可能会因为需要较低的学习率和仔细的参数初始化而减慢训练速度。正则化效果：它还具有轻微的正则化效果，导致（但不能消除）dropout 的需要。实现：它通常在深度学习框架中的层中实现，并在卷积层或全连接层之后、非线性层（如 ReLU）之前使用。 人们发现批量归一化对于训练深度网络非常有效，特别是在计算机视觉和语音识别领域。
三、内部协变量偏移问题 在批量归一化出现之前，深度学习网络一直受到内部协变量偏移问题的困扰。这种现象是指训练过程中权重的不断更新导致网络激活分布发生变化，导致需要较低的学习率和谨慎的参数初始化。批量归一化的引入通过稳定每层输入的分布有效地缓解了这个问题。
3.1 批量归一化的优点 提高训练速度：通过稳定输入分布，批量归一化允许使用更高的学习率，显着加速深度网络的训练过程。减少对初始化的依赖：它降低了网络对初始权重的敏感性，为选择初始化方法提供了更大的灵活性。正则化效果：批量归一化本质上具有温和的正则化效果，可以减少过度拟合并通常减少对 dropout 层的需求。促进更深层次的网络：通过缓解梯度消失和爆炸问题，它可以构建和有效训练更深层次的网络。 3.2 挑战和限制 尽管批量归一化有很多优点，但它也并非没有局限性。一项重大挑战是它对小批量大小的依赖。小批量可能会导致均值和方差估计不准确，从而影响模型性能。此外，批量归一化假设训练和推理期间输入分布一致，但情况可能并非总是如此。
3.3 应用和影响 批量归一化的实际影响是巨大且多样的。它已成为计算机视觉、自然语言处理和语音识别领域最先进架构的基本组成部分。它在图像分类中的 ResNets 和语言模型中的 Transformer 等模型的成功中发挥的作用凸显了它在推进深度学习领域的重要性。
四、代码 使用批量归一化创建完整的示例涉及几个步骤：生成合成数据集、使用批量归一化构建神经网络模型、训练模型以及绘制结果。为此，我们将使用 Python 以及 TensorFlow（或 Keras）和 matplotlib 等流行库。
首先，我们概述一下步骤：
生成综合数据集：我们将创建一个适合分类或回归任务的简单数据集。构建神经网络模型：将批量归一化层合并到模型中。训练模型：使用合成数据集来训练模型。绘制结果：显示训练损失和准确性，以了解批量归一化的影响。 现在，让我们用代码来完成每个步骤。
import numpy as np import matplotlib.pyplot as plt import tensorflow as tf from tensorflow.keras.models import Sequential from tensorflow.keras.layers import Dense, BatchNormalization from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ee7d166ea7924ca855f50a9e21ab13b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ff6547adf9027c58f1836ac2f9e5d21/" rel="bookmark">
			力扣-367. 有效的完全平方数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 力扣题目代码 力扣题目 给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。
完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。
不能使用任何内置的库函数，如 sqrt 。
示例 1：
输入：num = 16
输出：true
解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。
示例 2：
输入：num = 14
输出：false
解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。
提示：
1 &lt;= num &lt;= 231 - 1
代码 思路分析：
1.mid定义成了long long 的类型，要么会越界；
2.要注意num为0,1时，特殊处理一下；
3.注意k ^ 2 = N,这个先决条件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ff6547adf9027c58f1836ac2f9e5d21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/965ea4d8f5decf4550fbe3bf806e330b/" rel="bookmark">
			opencv006图像处理之仿射变换（旋转，缩放，平移）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		空间变换中的仿射变换对应着五种变换，平移，缩放，旋转，翻转，错切。而这五种变化由原图像转变到变换图像的过程，可以用仿射变换矩阵进行描述。而这个变换过程可以用一个2*3的矩阵与原图进行相乘得到。关键就是这个矩阵M：
仿射变换的函数： 平移，旋转 cv2.warpAffine(scr, M, dsize, flags, mode, value) 透视
cv2.warpPerspective(img1, M, desize......) M: 变换矩阵desize: 输出图片大小flags：与resize中的插值算法一致mode：边界外推法标志(有默认值)value：填充边界值（有默认值） 平移 读入的是二维的图像，所以就不用写最后一行了
向右平移200 （向左就是负数，其他同理）
# 变换矩阵，最少是float32
M = np.float32([[1, 0, 200], [0, 1, 0]])
向下平移200
# 变换矩阵，最少是float32
M = np.float32([[1, 0, 0], [0, 1, 200]])
向右下平移
# 变换矩阵，最少是float32
M = np.float32([[1, 0, 200], [0, 1, 200]])
这个是向右平移的代码：
import cv2 import numpy as np img1 = cv2.imread("F:\est01\e1.jpg") h, w, ch = img1.shape # 变换矩阵，最少是float32 M = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/965ea4d8f5decf4550fbe3bf806e330b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b1398b5be4a9ba8666a16e25788021a/" rel="bookmark">
			【2023年度总结】多变的2023 | 成长的2023 | 蜕变的2023
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 2023年📌，对我来说2023年，是多变的一年🎓2023年，是挑战的一年🎊2023年，是惊喜的一年🎉2023年，是好多第一次的一年🎨 2024年，是新的开始2024新年Flag 2023 已经过去，有太多感动和惊喜烙印在2023年里，也有不少遗憾和可惜停留在2023年里。现将以文字的形式记录封存起来，在未来的某时某刻将其打开翻阅。或许那时又是一番回味…现写下自己的2023年的年度总结：
2023年📌，对我来说 总有很多感动停留心间，总有很多遗憾无法继续…让我们开始吧~
图 2023年CSDN博客粉丝数、点赞数、阅读量一览 2023年，是多变的一年🎓 上一秒的我脑海中充满着迷茫和焦虑，下一秒的我心中憧憬着未来；
上一阶段还在为毕业论文而发愁，下一阶段已在为实习工作到工作转正而忙碌着；
上半年的我还在校园里徜徉，下半年的我已经出入职场；
年初的自己还在为考研失败而心有不甘，有点遗憾，年末的自己已经为工作多月而感叹不已；
六月份的自己还沉浸在毕业的快乐和不舍之中，七月份的自己已经忙碌充实在转正之后的工作之中；
上半年的自己还在为错过秋招，而在春招中拼命挣扎；下半年的自己已经在心仪的工作岗位中边学边做，开始适应职场环境。
…
2023年是多变的一年，是角色的转变，是状态的转变，是人生轨迹的转变，是无法逆转的转变…
这一年，我完成了从学生角色到职场打工人角色的转变。从校园生活跨越到职场生活。在这些变化之中，做出不少改变，深深体会到了 “计划赶不上变化” 的说法。哈哈哈哈哈…
图 ① 自参加工作后，参加了“校园返校日”活动 2023年，是挑战的一年🎊 今年完成了不少具有挑战的事情。
完成了本科阶段的毕设和论文编写的毕业任务；
在春招之中历经磨难，投下上百份简历，面上几十轮的面试，找到些许的工作岗位，最终顺利入职一家总代公司。感受到了春招的人潮窜动和寻找工作的艰辛；
这一年也完成了不少专业技能认证考试，在理论知识的消化吸收和动手实践中不断尝试和思考，最终顺利完成相关认证考试。
这一年出入社会，搬出校园宿舍，开启租房之旅。在偌大的城市之中，寻找庇护肉身和心灵的场所，开启独自一人的生活。
这一年在不断夯实自己的专业知识的同时，也在工作岗位中，持续输出，锻炼自我，将自身所学的专业技能发挥在了工作岗位之中。
这一年在不断地质疑和迷茫中，否定自己，割舍自己，重拾自己，与内心的自己不断的产生交集和碰撞。为自己一次又一次的选择而买单。
2023年是挑战的一年，是成长中必不可少的一个阶段，是需要自己去独自体验和感悟，是需要经受苦与难的洗礼，是迈向新阶段的通关挑战。
图 ② 编写论文答辩PPT，进行论文答辩 图 ③ 外出参加各类技术交流活动，并成为组织一员，参与其中 2023年，是惊喜的一年🎉 2023也收获了惊喜和感动。感受到了旅行的乐趣。体验到生活的丰富多彩。
这一年，有和自己的父母欢聚在餐桌之上，共享新春之乐。
这一年，顺利完成本科阶段的学习任务，顺利毕业。
这一年，拉上三五好友一起踏上旅途——徐州之旅（PS：某人老家因为阳了没汇合~留有点遗憾），沿途之中，所见所闻，惊喜不断，这是青春之旅。
这一年，和同事一起领略了山城——📍重庆的人文风貌，感受到了山城的魅力所在，以及大自然的鬼斧神工，在这五天四日的游玩之中，增进了彼此之间的交流，拉近了彼此之间的距离。
图 ④ 重庆游玩的照片合集~ 这一年，参加了许多大大小小的技术分享交流会，亚马逊云科技中国峰会、华为开发者大会、KubCon大会、谷歌社区活动、亚马逊云社区活动、腾讯云社区活动…结交到行业大牛、学习增进新知识新思想新动态…
图 ⑤ 参加亚马逊云中国峰会 这一年，也完成了多项专业技能认证考试，顺利完成领导布置的各项工作任务和安排，熟悉了工作环境、适应了工作强度、知晓了业务流程。
图 ⑥ 获得AWS SAA 和 SPP专业认证 这一年，因毕业来临之际，我和我的小伙伴来了场说走就走的毕业旅行，旅途中充满着欢声笑语，品尝地方特色美食，领略地方地域风情；因工作需要，陪同领导参加出席各种大大小小的会议和活动，认识到形形色色的人与事，打开了自己的认知世界，进行了跨行业跨领域的交流与探讨。
2023年，是好多第一次的一年🎨 第一次，完成毕业设计和本科论文编写，顺利通过答辩，迎来了我属于我的“凤凰花开的路口”，依依不舍，百般留恋。
第一次，经历残酷的春招，进行了成百份的简历投递与几十次的面谈交流。从校园的象牙塔中，走向多元的社会。
第一次，找到一份心仪的工作，契合自己的未来职业规划发展方向，从实习到转正，从面试到面谈，从转正申请到正式转正，签订劳动合同。开始了职场打工人的生活之旅。
第一次，出差各地，参加培训和活动，见到不同的人与事，看到不一样的风景，也在其中学习交流，收获成长。
第一次，从校园生活过渡到职场生活，从校园宿舍搬到了出租屋里，从一日三餐吃食堂到一日三餐自给自足。
第一次，在CSDN上博客平台中的粉丝数量突破千粉，成为万粉博主。博客的浏览量突破百万+🌸
图 ⑦ 过去在CSDN博客平台的一些收获与成长 或许，这就是成长，这就是经历，这就未知探索的意义。我们终其一生在寻找、在发现、在感受…在时间的见证之下，都走过来了，在此写下只言片语，我的脑海之中浮现出过往的经历，有感动，有惊喜，有遗憾，有落泪… 这些都已过去的，最后来一句“经历了就好”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b1398b5be4a9ba8666a16e25788021a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b98c6991990b6aa37b730dc4541c07d/" rel="bookmark">
			认识加密和解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加密技术源远流长，自从古代有了信息的传递和存储，就有了加密技术的运用。此后，很长一段时间里，加密及解密技术在军事、政治、外交、金融等特殊领域里被普遍采用，并经过长时间的研究和发展，形成了比较完备的一门学科——密码学。
密码学是研究加密方法、秘密通信的原理，以及解密方法、破译密码的方法的一门科学。
加密和解密的过程大致如下：首先，信息的发送方准备好要发送信息的原始形式，叫作明文。然后对明文经过一系列变换后形成信息的另一种不能直接体现明文含义的形式，叫作密文。由明文转换为密文的过程叫作加密。在加密时所采用的一组规则或方法称为加密算法。接收者在收到密文后，再把密文还原成明文，以获得信息的具体内容，这个过程叫作解密。解密时也要运用一系列与加密算法相对应的方法或规则，这种方法或规则叫作解密算法。在加密、解密过程中，由通信双方掌握的参数信息控制具体的加密和解密过程，这个参数叫作密钥。密钥分为加密密钥和解密密钥，分别用于加密过程和解密过程。
在加密和解密的过程中，如果采用的加密密钥与解密密钥相同，或者从一个很容易计算出另一个，则这种方法叫作对称密钥密码体制，也叫作单钥密码体制。反之，如果加密和解密的密钥并不相同，或者从一个很难计算出另外一个，就叫作不对称密钥密码系统或者公开密钥密码体制，也叫作双钥密码体制。
一、对称密钥加密算法
在过去很长一段时间里，人们一直都采用对称密钥密码体制来对信息进行加密和解密，直到现在，对称密钥密码体制也仍然是一种非常重要的常用加密方法。
对称密钥密码体制中，加密和解密过程中所使用的是同一个密钥，或者即使加密密钥和解密密钥不同，但是很容易地由一个计算出另外一个。显然，在这种密码体制中，密钥成为整个秘密通信的核心，整个加密系统的安全性完全以密钥的保密为基础。如果密钥暴露，则整个密码体制就完全失去了保密的效果。所以说，密钥的保密是对称密钥加密体制安全保密的关键，必须妥善保存并经由可靠的渠道传递。
对称密钥加密算法有多种，例如，DES（Data Encryption Standard，数据加密标准）、 IDEA（International Data Encryption Algorithm，国际数据加密算法）、Skipjack、3DES、GDES、 New DES、Lucifer、FEAL N、LOKI 91、RC4、RC5 等。
1．DES 算法
DES 算法是 1977 年美国政府公布的一种加密算法，由于算法实现简单，加密效果好，在很长时间里在全世界范围都被广泛运用。它通过对数据进行非常复杂的迭代和置换进行加密，使得企图破译者从加密后的密文中无法获得任何有效信息。对这种加密方法，如果用穷举的方法进行攻击的话，由一台一秒钟能够进行 10 000 次破译的计算机来计算，则要经过 200 多年才能够破解，可见 DES 算法具有很好的保密效果。另外，DES 算法实现起来并不复杂，不但在软件中可以容易地实现，而且早已经在芯片上实现了，使用起来非常方便。
DES 算法的过程，简单来说，就是把要加密的明文分成 64 位的数据段作为输入，再使用根据 64 位密钥变化生成的 52 个子密钥，对输入的数据段依次进行初始置换、16 轮迭代、逆初始置换，然后得到 64 位密文。
DES 的解密过程与加密过程几乎相同，只是子密钥的使用顺序不一样。加密时依次使用的部分参数 K1 K2 K3 …K16，在解密时则按照 K16 K15 K14 …K1顺序使用。其他算法完全一样，这也是 DES 容易使用的一个方面。
2．IDEA 算法
IDEA 在加密运算中所处理的数据段大小也是 64 位，但是所用的密钥长度为 128 位，而且采用更加复杂的加密算法，目的是保证它不会被轻易破译。IDEA 是一种加密强度很高的加密算法，迄今为止还没有出现对该算法的有效攻击。假如一台计算机一秒钟可以产生和运行 10 亿个密钥，则要猜出 IDEA 密钥需要花费 1013 年的时间，可见 IDEA 的加密强度非常高。另外，IDEA 实现非常方便，既可以通过软件实现，也可以通过硬件实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b98c6991990b6aa37b730dc4541c07d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbc27308bb08304ab04e44cab33adffb/" rel="bookmark">
			设计模式之享元模式【结构型模式】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档&gt; 学习的最大理由是想摆脱平庸，早一天就多一份人生的精彩；迟一天就多一天平庸的困扰。各位小伙伴，如果您：
想系统/深入学习某技术知识点…
一个人摸索学习很难坚持，想组团高效学习…
想写博客但无从下手，急需写作干货注入能量…
热爱写作，愿意让自己成为更好的人…
文章目录 前言一、概述二、结构三、案例实现四、优缺点和使用场景五、JDK源码解析总结 前言 一、概述
二、结构
三、案例实现
四、优缺点和使用场景
五、JDK源码解析
一、概述 定义：
​ 运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。
二、结构 享元（Flyweight ）模式中存在以下两种状态：
内部状态，即不会随着环境的改变而改变的可共享部分。外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。 享元模式的主要有以下角色：
抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。 三、案例实现 【例】俄罗斯方块
下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。
先来看类图：
代码如下：
俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。
public abstract class AbstractBox { public abstract String getShape(); public void display(String color) { System.out.println("方块形状：" + this.getShape() + " 颜色：" + color); } } 接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。
public class IBox extends AbstractBox { @Override public String getShape() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbc27308bb08304ab04e44cab33adffb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fbb3fc27d105d0582864e67a6b108bc/" rel="bookmark">
			路由器02_静态路由&amp;DHCP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、静态路由 １、静态路由特点 由管理员手工配置，是单向的，缺乏灵活性
２、默认路由 默认路由是一种比较特殊静态路由，一般用于末节（末梢）网络，直接指定目标为任何地方
二、静态路由配置 １、静态路由 ip route 目标网络（目标的网段　目标的网络地址）　目标的子网掩码　下一跳地址（下一个路由器的接口的IP地址）或者发往下一个路由器的本地接口
ip route 192.168.1.0 255.255.255.0 192.168.10.0 ip route 192.168.1.0 255.255.255.0 f0/1 2、默认路由 ip route 0.0.０.0 255.255.255.0 192.168.10.0 ip route 0.0.０.0 255.255.255.0 f0/1 ３、查看路由条目 show ip route 三、静态路由实验 1、实验要求
实验设备：两台主机PC0和PC1、三台路由器R0、R1、R2
实验环境：PC1直连R0，PC2直连R1，R0与R1相接，且R0、R1各有一条链路连接R2，网络拓扑如下：
注：画网络通信拓扑图一定要把IP标识清楚！！！
实验要求
PC0到PC1走R0 R2 R1
PC1到PC0走R1 R0路由器
首先配置PC的IP地址，其次给路由器配置端口IP，最后配置静态路由或默认路由
路由器接口IP配置
#R2路由器接口IP设置 Router#conf t Enter configuration commands, one per line. End with CNTL/Z. Router(config)#hostname R2 R2(config)#int g0/0 R2(config-if)#ip add 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fbb3fc27d105d0582864e67a6b108bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf15ecf224fe8a6b7432b8d91939464e/" rel="bookmark">
			python-查漏补缺笔记-更新中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		包导入时__init__.py中命令的执行顺序和sys.modules变化 ref: https://edu.csdn.net/skill/practice/python-3-6/164
在有父包和子包的情况下，父包中的“ __ init__.py”语句会在子包的“ __ init__.py”语句之前执行，然后按下列顺序执行导入子包和模块执行“ __ init__.py”中其他代码 需要注意的是，如果只导入子包，Python解释器会将父包的信息添加到sys.modules中，这样导入子包的时候能知道父包的存在，但是除了父包的__init__.py中的语句，并不会执行其他代码，只有需要访问父包时才会进行真正的导入。
sys.modules是一个字典，记录的是已经导入的模块信息。首次导入一个模块时，python会检查这个模块是否存在于sys.modules中，如果已经存在，会直接返回模块对象；否则导入。
实例
文件结构如下图所示，father包含one、two和three三个包，one包又包含一个one包。每个 __ init__.py中包含的内容只有一条print语句，打印诸如 this is father、this is 1、this is 1.1这样的语句。
leetcode.py中的内容如下所示：
import sys if __name__ == '__main__': for i in range(2): import father import father.one.one import father.two #print(sys.modules.keys()) del sys.modules['father'] del sys.modules['father.one.one'] del sys.modules['father.two'] print('-----------\n') ''' 输出结果 this is father this is 1 this is 1.1 this is 2 ----------- this is father this is 1.1 this is 2 ----------- ''' 这是因为father.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf15ecf224fe8a6b7432b8d91939464e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b426d734a07e6314f3945b6b624c6b1f/" rel="bookmark">
			雅思词汇——Word List 3（V2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. leak [liːk]2. literature [ˈlɪtərətʃə( r)]3. suffer [ˈsʌfə( r)]4. impede [ɪmˈpiːd]5. spring [sprɪŋ]6. biological [ˌbaɪəˈlɒdʒɪkl]7. deduce [dɪˈdjuːs]8. doctorate [ˈdɒktərɪt]9. absolute [ˈæbsəluːt]10. theoretical [θɪəˈrɛtɪkl]11. internship [ˈɪntəːnʃɪp]12. slender [ˈslɛndə( r)]13. respondent [rɪˈspɒndənt]14. surroundings [səˈraʊndɪŋz]15. couple [ˈkʌpl]16. voluntary [ˈvɒləntəri]17. submarine [ˌsʌbməˈriːn]18. commercial [kəˈmɜːʃl]19. notion [ˈnəʊʃn]20. lavatory [ˈlævətri]21. tablet [ˈtæblɪt]22. actual [ˈæktʃuəl]23. fold [fəʊld]24. instrument [ˈɪnstrəmənt]25. simplify [ˈsɪmplɪfaɪ]26. compulsory [kəmˈpʌlsəri]27. irritation [ˌɪrɪˈteɪʃn]28. expense [ɪkˈspɛns]29. muddle [ˈmʌd(ə)l]30. originate [əˈrɪdʒɪneɪt]31. induce [ɪnˈdjuːs]32. exchange [ɪksˈʧeɪndʒ]33. disharmony [dɪsˈhɑːməni]34.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b426d734a07e6314f3945b6b624c6b1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c622304716c24ea007f2fae11d33a538/" rel="bookmark">
			Django5&#43;DRF入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档：https://www.django-rest-framework.org/
创建项目 # 创建目录 mkdir drf_demo cd drf_demo # 创建虚拟环境 python -m venv evnv venv/Scripts/activate # 安装Django pip install django # 安装DRF pip install djangorestframework # 创建Django项目 django-admin startproject drf_demo . # 创建应用 python manage.py startapp quickstart # 同步数据库 python manage.py migrate # 创建超级管理员 python manage.py createsuperuser --username zhangdapeng --email zhangdapeng@qq.com 注册应用 使用Pycharm打开项目，修改配置文件，注册刚才创建的quickstart应用：
INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'quickstart', ] 创建序列化文件 首先，我们要定义一些序列化器。让我们创建一个名为 tutorial/quickstart/serializers.py 的新模块，用于数据表示。
from django.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c622304716c24ea007f2fae11d33a538/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7373b7e6f0453b9b31990ba8fbbf1de3/" rel="bookmark">
			八. 实战：CUDA-BEVFusion部署分析-spconv原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言0. 简述1. 举例分析spconv的计算流程2. 导出带有spconv网络的onnx需要考虑的事情总结下载链接参考 前言 自动驾驶之心推出的 《CUDA与TensorRT部署实战课程》，链接。记录下个人学习笔记，仅供自己参考
本次课程我们来学习下课程第八章——实战：CUDA-BEVFusion部署分析，一起来学习 spconv 原理
Note：之前在学习杜老师的课程中有简单记录过 Sparse Convolution 的一些基础知识，感兴趣的可以看下：复杂onnx解决方案（以sparseconv为例）
课程大纲可以看下面的思维导图
0. 简述 本小节的目标：理解 spconv 与普通的 conv 的区别，计算原理与流程，以及导出 onnx 需要考虑的事情
这节课给大家讲解第八章第 2 小节学习 spconv 的原理，通过这一小节我们去理解一下我们用 3D Sparse Convolution 对稀疏性的点云做卷积的时候我们应该怎么去做，spconv 的算法和流程是什么样的，它和普通卷积的区别有哪些，这是我们接下来需要去理解的。
最后我们作为第 3 小节的前述部分，会去给大家讲一下导出带有 Sparse Convolution 网络的 ONNX 的时候需要注意哪些事情
OK，我们下面正式开始
1. 举例分析spconv的计算流程 首先为了理解 spconv 的流程，我们把这个问题简单化，先看一个最简单的例子，我们假设现在有一个输入，大小是 1x5x5，同时经过一个 1x1x3x3 大小的卷积核得到 1x3x3 大小的输出，如下图所示：
卷积的整个过程 stride 是 1，padding 是 0，同时我们假设输入的 1x5x5 大小的数据中除了 in0 点以外其他的所有数据都为 0，也就是说只有 in0 点它是有值的，那么通过一个卷积之后我们知道输出的数据只有 out0 和 out1 有值，其他输出的数据全为 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7373b7e6f0453b9b31990ba8fbbf1de3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4c41b603bccecb6974a2237018a62b8/" rel="bookmark">
			四. 基于环视Camera的BEV感知算法-BEVDistill
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言0. 简述1. 算法动机&amp;开创性思路2. 主体结构3. 损失函数4. 性能对比总结下载链接参考 前言 自动驾驶之心推出的《国内首个BVE感知全栈系列学习教程》，链接。记录下个人学习笔记，仅供自己参考
本次课程我们来学习下课程第四章——基于环视Camera的BEV感知算法，一起去学习下 BEVDistill 感知算法
课程大纲可以看下面的思维导图
0. 简述 本次课程是我们 BEV 算法讲解部分最后一个论文框架，我们这篇文章来看一下能不能用一个不一样的视角去构造 BEV 特征，
我们还是从以下四个方面展开，算法动机&amp;开创性思路、主体结构、损失函数以及性能对比
1. 算法动机&amp;开创性思路 我们本节课程要学习的算法叫 BEVDistill，我们在讲解 BEVDistill 算法之前，我们先复习一下图像是怎么生成 BEV 特征的，点云是怎么生成 BEV 特征的，那我们在这里以 BEVFusion 的框架为例，如下图所示：
BEVFusion 本身包含 Camera Stream 图像输入和 LiDAR Stream 点云输入，它们可以分别得到 Camera BEV Feature 利用图像特征去构造的一个 BEV 空间特征，LiDAR BEV Feature 利用点云特征去构造的一个 BEV 空间特征
输入图像怎么处理呢，用 Camera Stream 专门处理图像网络的，利用图像编码器 Encoder 可以得到图像特征，然后通过 2D 到 3D 的一个转换图像特征可以从 2D 映射到 3D 然后再投影到 BEV 空间，通过这样的方式可以得到所谓的 Camera BEV Feature
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4c41b603bccecb6974a2237018a62b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cd62f4970316635fefe4532b6b84436/" rel="bookmark">
			SpringCloud系列篇：核心组件之负载均衡组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 🥳🥳Welcome Huihui's Code World ! !🥳🥳 接下来看看由辉辉所写的关于SpringCloud的相关操作吧
目录
🥳🥳Welcome Huihui's Code World ! !🥳🥳
一.负载均衡组件是什么 二.负载均衡组件的详解 生活例子
例子分析
一.负载均衡组件是什么 负载均衡组件是一种用于分发网络流量的技术或工具。它可以将传入的网络请求分发到多个后端服务器上，以实现请求的均衡分配和高可用性。负载均衡组件通常位于网络架构中的前端，作为流量的入口点，并根据预先定义的策略将请求分发到后端服务器上。
负载均衡组件有助于提高网络服务的性能和可靠性。当流量集中到一个服务器时，负载均衡组件可以将流量分散到其他可用的服务器上，从而减轻单个服务器的负载压力。这样可以确保每个服务器都能够处理相对均等的请求负载，提高整体的响应速度和吞吐量。
负载均衡组件可以基于不同的算法来进行请求分发，例如轮询、最小连接数、最少响应时间等。此外，负载均衡组件也可以提供监控和故障检测功能，以便及时发现后端服务器的故障，并将流量自动切换到其他正常运行的服务器上。
总之，负载均衡组件是一种用于实现流量分发和提高系统性能的关键技术，广泛应用于现代网络架构中
二.负载均衡组件的详解 这里我也举一个生活中的例子来方便大家理解
生活例子 我们上班或者出行都可能会到一些商场或者写字楼中
在这些高楼大厦中，为了提高我们到达每一层楼的效率，常常会设有电梯
但是如果只有一个电梯，当人们集中使用时，就会造成电梯的拥堵和等待时间变长的问题。
然而安装了多台电梯，那么我们就可以选择乘坐其他不拥挤的电梯到达指定楼层，从而提高电梯的使用效率和人员运输能力
例子分析 例子中电梯的设计就是负载均衡的体现，从原来的一个电梯设计成多个电梯同时运行，这样就可以减轻单一电梯的载客压力，减少乘客们的等电梯时间。负载均衡在我们开发中就是去减少单个服务器的压力，确保每个服务器都能够处理相对均等的请求负载，提高整体的响应速度和吞吐量
好啦，今天的分享就到这了，希望能够帮到你呢！😊😊 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d81f30fd6cccc868def69be8df0e14f0/" rel="bookmark">
			如何在 Windows 电脑上恢复硬盘数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 虽然硬盘偶尔发出安静的咔哒声无需担心，但响亮、持续的咔哒声（有时称为“死亡咔哒声”）应该认真对待。您应该尽快从发出咔嗒声的硬盘驱动器中恢复数据，因为它会比您想象的更快失效。我们下面的指南将探讨从点击硬盘驱动器获取数据的两种方法，以及修复点击问题的一些方法。
如何从硬盘恢复数据 在大多数情况下，您的电脑不会检测到发出咔嗒声的硬盘，恢复数据的唯一方法是使用专业的数据恢复服务。但是，如果您的电脑检测到您的驱动器，您可以使用第三方数据恢复工具来挽救您的数据。
下面的部分将介绍两种点击硬盘数据恢复的方法。
方法一：通过数据恢复软件 奇客数据恢复软件可用于从点击硬盘执行数据恢复，但我建议首先自己尝试下数据恢复服务。原因很简单，当您使用已经损坏的硬盘时，造成额外损坏的可能性会增加。
然而，这些服务确实要花费相当多的钱，如果这不是一个选择，从点击硬盘驱动器检索数据的下一个最安全的方法是数据恢复软件。
在本教程中，我选择使用奇客数据恢复。为什么？因为它可以让您创建驱动器的字节级磁盘映像，然后扫描其中的数据。它支持外部和内部硬盘驱动器，因此您无需担心兼容性。
使用奇客数据恢复的字节到字节备份功能及其先进的数据恢复算法，您将能够恢复数据，而不会进一步损坏驱动器。
注意：如果您尝试从发出咔哒声的内置硬盘恢复数据，则需要一个硬盘驱动器外壳将其连接到另一台电脑以执行数据恢复。
步骤 1：下载奇客数据恢复并安装它。
奇客数据恢复: 支持1000+数据格式恢复免费下载软件扫描数据，支持文件、照片、视频、邮件、音频等1000+种文件的格式恢复更有电脑/笔记本、回收站、U盘、硬盘等各类存储设备数据丢失恢复https://www.geekersoft.cn/geekersoft-data-recovery.html步骤 2：使用奇客数据恢复扫描磁盘映像
选择磁盘映像并单击“搜索丢失的数据”。奇客数据恢复中的设备列表，带有搜索丢失的数据按钮。
单击“查看找到的项目”以查看 奇客数据恢复发现的文件。如果适用，您可以直接单击要恢复的相关文件类型，例如图片、视频、音频、文档、档案和其他。奇客数据恢复中的“查看找到的项目”屏幕。
步骤 3：使用复选框选择所需的文件。奇客数据恢复将显示您选择的每个文件的预览。确认后，单击“恢复”。奇客数据恢复将恢复您的文件。
方法二：专业数据恢复服务 如果您的数据至关重要，并且您愿意花费大量金钱，那么专业的数据恢复服务将能够修复发出咔嗒声的硬盘，或者至少在 90% 的情况下可以从中获取您的数据。
如果您的数据足够重要，我们建议您使用专业的数据恢复服务，而不是走DIY路线。
以下概述了使用专业数据恢复服务时的期望：
联系数据恢复服务或使用该公司的网站提交恢复请求。提供相关详细信息，例如发生点击问题的时间以及硬盘驱动器是否跌落、暴露于热、水、磁场等。您必须将咔嗒声硬盘运送到公司或将其放在投递地点。数据恢复服务将评估驱动器以确定数据恢复的可能性和程度。到目前为止，信誉良好的数据恢复服务不会向您收取费用。评估结束后，数据恢复服务将为您提供报价，您可以选择是否进行数据恢复。如果您继续，公司将恢复您的数据，将其传输到全新的驱动器，然后寄回给您。 结论 总而言之，当您发现硬盘发出咔嗒声并想要从中恢复数据时，应采取以下措施：
如果可能，请使用专业的数据恢复服务来恢复您的数据。第三方数据恢复工具可以帮助您从点击硬盘中恢复数据（前提是您的 PC 检测到该数据）。仅当您可能面临丢失数据的风险时才应尝试停止使用硬盘。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f627c6dff221192b564105673e71cee/" rel="bookmark">
			SpringBoot-Dubbo-Zookeeper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Dubbo：https://cn.dubbo.apache.org/zh-cn/overview/home/
依赖
&lt;!--dubbo--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--zookeeper客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--zookeeper服务端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;!--排除日志冲突--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 服务端
server.port=8081 # 服务的名称 dubbo.application.name=provider # 注册中心地址 dubbo.registry.address=zookeeper://127.0.0.1:2181 # 扫描包下的服务 dubbo.scan.base-packages=org.example.service // 服务提供者使用Dubbo的Service注解，注册到注册中心 @org.apache.dubbo.config.annotation.Service public class ProviderServiceImpl implements ProviderService{} 消费端
# 服务的名称 dubbo.application.name=consumer # 注册中心地址 dubbo.registry.address=zookeeper://127.0.0.1:2181 // 注册到Spring容器 @Service public class UserServiceImpl implements UserService{ // 使用dubbo的@Reference注解去注册中心查找服务 @org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f627c6dff221192b564105673e71cee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2880eb1722e790855e73a6fd356ed6a/" rel="bookmark">
			LeetCode-整数反转（7）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述： 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
如果反转后整数超过 32 位的有符号整数的范围 [−231，231− 1] ，就返回 0。
假设环境不允许存储 64 位整数（有符号或无符号）。
思路： 题目首先要求要对整数进行反转，那么我们可以使用一个while循环即可完成操作，每次循环使用一个变量接收整数模10的运算结果，然后使用一个变量来接收反转的结果，因为我们已经有模10的结果了，那么只需将模10的结果乘10在加上上次循环的用于接收反转结果的变量的变量值即可，这就是计算反转数字的逻辑，除以上步骤之外别忘了每次循环末尾对输入整数要除10，并且设置跳出循环的条件为输入整数经过多次除10后为0。
经过以上步骤，我们完成了整数反转的逻辑，但是题目还指出反转后的数字不可以超出32位数的范围。那么我们就要在循环中进行判断，根据32位数字的区间[−231，231− 1] ，得知左右界限的最后一位数字分别为7，8。那么我们可以在倒转最后一个数字之前判断，如果没加最后一位数字的反转数字已经大于最高限那么肯定会越界直接返回0，如果除了最后一位其它位数字都和最高限除以10相等，那么如果最后一位数字大于7也会越界。对于负数的越界判断也是同理。
代码：
class Solution { public int reverse(int x) { int reverseNum=0; while (x!=0) { int digit=x%10; if(reverseNum&gt;Integer.MAX_VALUE/10 || (reverseNum==Integer.MAX_VALUE/10&amp;&amp;digit&gt;7)) { return 0; } if(reverseNum&lt;Integer.MIN_VALUE/10 || (reverseNum==Integer.MIN_VALUE/10&amp;&amp;digit&lt;-8)) { return 0; } reverseNum=reverseNum*10+digit; x/=10; } return reverseNum; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3d545f5d587d67aab56dc29afee25df/" rel="bookmark">
			谷歌chrome浏览器升级 120.0 后书签显示变黑变粗的解决方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在地址栏输入 chrome://flags, 然后搜索 chrome-refresh-2023-chrome-font, 从 default 改为 Disable 即可
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/24/">«</a>
	<span class="pagination__item pagination__item--current">25/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/26/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>