<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e67119b8341ca31fc1a4fd0e4afb1b76/" rel="bookmark">
			JavaWeb 速通Tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、拾枝杂谈
1.web服务器说明 : 2.常用web服务软件 : 二、Tomcat服务
1.Tomcat下载和安装 : 2.启动Tomcat服务 : 3.Tomcat启动的注意事项 : 4.关闭Tomcat服务 : 三、Tomcat部署
1.Tomcat目录结构说明 : 1° bin
2.conf
3° lib
4° logs
5° temp
6° webapps
7° work
2.关于Web应用的说明 : 1° 什么是web应用？
2° web应用的组成：
3° JavaWeb应用(程序/工程)的目录结构：
3.Tomcat部署web应用 : 1° 部署方式一
2° 部署方式二
四、Tomcat配置
1.浏览器请求资源的流程分析 : （重要）
2.关于端口问题的再说明 : 3.IDEA配置Tomcat : 4.IDEA配置Tomcat的细节说明 : 1° 关于“热加载” : 2° 关于配置Tomcat时的端口 : 3° 关于out目录 : 4° 关于IDEA项目下目录的说明 : 五、Tomcat总结
一、拾枝杂谈 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e67119b8341ca31fc1a4fd0e4afb1b76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5e84fcae8a9e41f58afa1e4586378e0/" rel="bookmark">
			2023每年最难忘的一天，今年特别的特别寡助之至，亲戚畔之：您就是那个典型反面教材啊
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 为孝维持的婚姻。仅此而已了。 其他多想无益，甚至于say 无济于事。不如做事。做事开发游戏的继续推进进度啊！ 最明智的做法，明智之举，就是靠拼您个人啊！
您以为呢？！　谁都靠不住，哪怕是至亲的ｐｅｒｓｏｎ；　得道多助，失道寡助，得道者多助，失道者寡助。寡助之至，亲戚畔之。您就是那个典型反面教材啊！算了，人生如戏而已，何必入戏太深了呢？ 不是吗
再说了，您的自明诚呢，您的道呢，您的好善呢，您的明德呢，您的坚强意志力呢，您的穷困潦倒，受孙子气就是您的本事了吗
老鼠的儿子会打洞。。。
您的正面能量的消耗殆尽，然后您的欲望念呢，也早飞升到九霄云外去了。所谓云横秦岭家何在，雪拥蓝关马不前，不是更加悲惨的境地吗，人生真的谁都有低谷的时候，但是您有过高峰期吗，从来没有过高峰，就直接坠入万丈深渊当中了呢， 实感人生之艰難，犹如东奔之江水，虽然最终流向大海，但是却也深感流程缓慢，而导致了深深忧虑之念头的发生，，， 所谓夫妻本是同林鸟，大难临头各自飞； 甚至于起诉离婚的地步了，您还有啥话说？ 只能默默无闻的承受您自个做的孽业而已了，对了，就是犹如那个苏明成边哭边吃饭的场景，就是那种滋味，也犹如那个刘亦菲醉酒，说要结婚的镜头的滋味，您？ 啥也不是，啥也不是的路人乙 。
躺地上打滚的场景，您也亲历了，无力感，甚至于无助感您也亲历了，这会绝知此事要躬行，绝知成人世界的禽兽性，残酷性所在了吧。这就是最真实的世界啊，您今天才知道吗，呵呵，挨，，，可怜的傻冒了，真实忒可怜到家的那种了。
早点休息吧，别造了，今天太阳已经落山了，何必急于一时伤身体，却并不能创造什么价值出来不是吗 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/effcebf0b3aaa72bf2376ae2e2130234/" rel="bookmark">
			Linux下使用Shell脚本实现FTP自动上传和下载文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Linux下使用Shell脚本实现FTP自动上传和下载文件1. 从FTP上批量下载文件到本地2. 从FTP上下载单文件到本地3. 从 FTP 一次下载多个文件4. 从本地向FTP批量上传文档5. 从本地向FTP上传单个文档 Linux下使用Shell脚本实现FTP自动上传和下载文件 参考文档：https://www.cnblogs.com/liqing1009/p/13534506.html
这个脚本是本次测试的从本地上传文件到远程 ftp 服务器
FTP服务器：192.168.169.141
FTP路径：/var/ftp/write
本地文件路径：/home/diffFile.txt
#!/bin/bash vCheckTime=`date "+%F-%T"` # 本地上传文件路径 localFile="/home/diffUserFile.txt" # 上传到远程文件路径 remoteFile="write/diffUserFile$vCheckTime" # ftp ipaddress ftpIP="192.168.169.141" function uploadFile { ftp -v -n $ftpIP&lt;&lt;EOF user admin admin binary passive put $localFile $remoteFile bye EOF } uploadFile 注：这里的 remoteFile 即 FTP 服务器上的路径，但是如果在上传时使用绝对路径会提示 553 Could not create file
1. 从FTP上批量下载文件到本地 登录FTP实现下载文件功能
FTP服务器：192.168.0.199
FTP路径：/ftphome/data
本地路径：/local/data
将文件从FTP下载到本地的脚本如下
#从FTP上批量下载文件到本地 #!/bin/sh ftp -v -n 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/effcebf0b3aaa72bf2376ae2e2130234/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1dfee3e2a2ea8e4d0018e61dab1a378/" rel="bookmark">
			CSS画圆以及CSS实现动态圆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS画圆以及CSS实现动态圆 1. 先看基础（静态圆）1.1 效果如下：1.2 代码如下： 2. 动态圆2.1 一个动态圆2.1.1 让圆渐变2.1.2 圆渐变8秒后消失2.1.3 转动的圆（单个圆） 2.2 多个动态圆 1. 先看基础（静态圆） 1.1 效果如下： 如下：
1.2 代码如下： 如下：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 正方形 */ .xmbook_red_point_1 { width: 50px; height: 50px; display: inline-block; background-color: red; } /* 圆角正方形 */ .xmbook_red_point_2 { width: 50px; height: 50px; display: inline-block; background-color: red; border-radius: 20%; } /* 实心圆 */ .xmbook_red_point_3 { width: 50px; height: 50px; /* position: relative; */ /* bottom: 2px; */ /* left: 4px; */ display: inline-block; /* background: url(/zh_CN/htmledition/images/icon_xmbook_red_point513f4c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1dfee3e2a2ea8e4d0018e61dab1a378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ba77782be21dc1da6e8e2d1ae38d221/" rel="bookmark">
			pyusb环境搭建和无法发包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pyusb环境搭建和无法发包问题 项目需要对usb设备进行开发调试，选择搭建pyusb环境进行调试测试，这里记录下完整流程和中间解决的一些问题。
我使用的环境是window10 64bit, vscode 1.84.0 , Python 3.11.6
1 安装流程 参考github上的 https://github.com/pyusb/pyusb 的readme。
安装步骤分为两步
Requirements and platform 安装依赖
pyusb是依赖于libusb库的python层面封装，所以要安装对应的库。
此处是windows环境，作者提供了2种选择
1.使用 pyocd/libusb-package 库进行安装，libusb-package库中自带了 libusb-1.0.dll的库。但是使用api的方式会有差异。
2.直接将libusb-1.0的dll拷贝到windows的系统目录，比如 C:\Windows\System32 (通过 libusb:https://libusb.info/ 官网可以下载)
这里使用了安装libusb-package的方式
pip install libusb-package Installing 安装pyusb
这里直接安装最新版本即可。
# the latest official release python -m pip install pyusb 2 使用流程 官网提供的demo示例如下
import usb.core import usb.util # find our device dev = usb.core.find(idVendor=0xfffe, idProduct=0x0001) # was it found? if dev is None: raise ValueError('Device not found') # set the active configuration.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ba77782be21dc1da6e8e2d1ae38d221/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7dbc177376433751ab706f68aa670a1/" rel="bookmark">
			Monocle 3 | 太牛了！单细胞必学R包！~（三）（建立单细胞轨迹）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1写在前面 到周末了，今天去骑车的，感觉还不错。🚴🏻
下面就是今天的内容了： 👇
单细胞转录组、蛋白组、表观组学等单细胞技术的发展为研究细胞周期、细胞分化等细胞动态过程提供了新的机会。🤩
使用轨迹推断（TI，trajectory inference）的方法可以根据测序的细胞之间表达模式的相似性对单细胞沿着轨迹进行排序，模拟细胞动态变化的过程。🥸
轨迹推断也称作伪时间分析（pseudotime analysis）。🤩
2用到的包 rm(list = ls())
library(tidyverse)
library(monocle3)
3示例数据 expression_matrix &lt;- readRDS("./packer_embryo_expression.rds")
cell_metadata &lt;- readRDS("./packer_embryo_colData.rds")
gene_annotation &lt;- readRDS("./packer_embryo_rowData.rds")
cds &lt;- new_cell_data_set(expression_matrix,
cell_metadata = cell_metadata,
gene_metadata = gene_annotation)
cds
4预处理数据 我们先处理一下批次效应，这里有一个原文中提供的方法，我们用一下吧。😏
自己的数据还是要自己的方法处理的。😂
cds &lt;- preprocess_cds(cds, num_dim = 50)
cds &lt;- align_cds(cds, alignment_group = "batch", residual_model_formula_str = "~ bg.300.loading + bg.400.loading + bg.500.1.loading + bg.500.2.loading + bg.r17.loading + bg.b01.loading + bg.b02.loading")
5降维并可视化结果 我们只是用了data的一小部分，但Monocle重建了一个有许多分支的轨迹。🥰
叠加人工注释后，这些分支主要由一种细胞类型占据。😋
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7dbc177376433751ab706f68aa670a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39eba676bee4109077acb3dbeef94bbb/" rel="bookmark">
			函数递归(详细易懂)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数递归 1. 递归是什么？2. 递归的限制条件3. 递归举例3.1 举例1：求n的阶乘3.1.1 分析和代码实现3.1.2 画图推演 3.2 举例2：顺序打印⼀个整数的每⼀位3.2.1 分析和代码实现3.2.2 画图推演 4. 递归与迭代 1. 递归是什么？ 递归其实是⼀种解决问题的⽅法，在C语⾔中，递归就是函数⾃⼰调⽤⾃⼰。
写⼀个史上最简单的C语⾔递归代码：
#include &lt;stdio.h&gt; int main() { printf("hehe\n"); main();//main函数中⼜调⽤了main函数 return 0; } 上述就是⼀个简单的递归程序，只不过上⾯的递归只是为了演⽰递归的基本形式，不是为了解决问题，代码最终也会陷⼊死递归，因为每次调用mian函数都会在栈区开辟空间，导致栈溢出（Stack overflow）。
通过调试可以看到:
递归的思想：
把⼀个⼤型复杂问题层层转化为⼀个与原问题相似，但规模较⼩的⼦问题来求解；直到⼦问题不能再被拆分，递归就结束了。所以递归的思考⽅式就是把大事化小的过程。
递归中的递就是递推的意思，归就是回归的意思
2. 递归的限制条件 递归在书写的时候，有2个必要条件：
递归存在限制条件，当满⾜这个限制条件的时候，递归便不再继续。每次递归调⽤之后越来越接近这个限制条件。 3. 递归举例 3.1 举例1：求n的阶乘 计算n的阶乘（不考虑溢出），n的阶乘就是1~n的数字累积相乘。
3.1.1 分析和代码实现 //5的阶乘 5! = 1 * 2 * 3 * 4 * 5 //也可以表示为 5! = 5 * 4 * 3 * 2 * 1 //4的阶乘 4!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39eba676bee4109077acb3dbeef94bbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f869ac4221de00c1a749b7d0669971e/" rel="bookmark">
			java设计模式（2）单例模式、工厂模式、原型模式、建造者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单例模式 单例核心 单例对象的类必须保证只有一个实例存在。所谓“懒汉式”与“饿汉式”的区别，是在与建立单例对象的时间的不同。
“饿汉式”是在不管你用的用不上，一开始就建立这个单例对象“懒汉式”是在你真正用到的时候才去建这个单例对象 饿汉式 饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的
//饿汉式单例类. public class Singleton { //构造器私有化 private Singleton() {} //static修饰 在类初始化时，已经自行实例化 private static final Singleton single = new Singleton(); //静态工厂方法 public static Singleton getInstance() { return single; } } 优点：保证线程绝对安全缺点：类加载的时候就实例化，系统初始化会导致大量的内存浪费 懒汉式 懒汉式是延迟加载的方式，只有使用的时候才会加载。 并且有线程安全的考量（使用双重锁）。
双重锁检查：方法检查判定两次，并使用锁，所以形象称为双重检查锁定模式。
//懒汉式-线程安全 public class Singleton { //构造器私有化 private Singleton() { } //用volatile定义的变量，将会保证对所有线程的可见性。禁止指令重排序优化 private static volatile Singleton single = null; //静态工厂方法 public static Singleton getInstance() { if (single != null) { return single; } synchronized (Singleton.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f869ac4221de00c1a749b7d0669971e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1d307861c5176a738feda197074c666/" rel="bookmark">
			PC通过网口连接RK3588
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PC通过网口连接RK3588 1、参考资料2、PC端配置2.1、PC端以太网配置2.2、设置共享PC端的WLAN【已经可以了，板子会自动分配ip】2.3、配置RK3588的网络【想固定IP，存在问题】 3、验证RK3588的ip地址4、PC端控制 1、参考资料 随便记录以下，方便自己查看
因为RK3588官方给的镜像没法自动连接上WiFi，每次都要用触摸屏点击连接指定的WiFi，构成局域网后才得到IP，再进行远程登陆，这很麻烦，干脆直接用网线直连好了。
串口连接时间久了也很不稳定，经常会无法识别设备，需要拔掉再重新插入，远程搞得话很麻烦。
参考资料：
1、树莓派使用网线直连电脑的方法
2、使开发板上网——开发板和笔记本网线连接
2023-11-04修改
补充说明：
网络共享给以太网口，会默认分配IP：192.168.137.1，要保证板子与PC链接上，需要保证在同一个网段，也就是说板子的ip最好是分配在192.168.137。
为了确保能够连接的同，可以先在PC端ping一下以太网口，先确保自己能够ping自己（试过usb网口接入PC，配置是搞好了，但就是连不起来，最后发现是usb网口的问题，白费时间）
2、PC端配置 2.1、PC端以太网配置 用网线把PC和RK3588开发板连接后，设备都上电，会识别出连接到开发板的以太网：
点击这个以太网，选择属性，配置Internet协议版本4（TCP/IPv4）：
固定IP，设置如下：
2.2、设置共享PC端的WLAN【已经可以了，板子会自动分配ip】 在电脑上设置如图所示：
2.3、配置RK3588的网络【想固定IP，存在问题】 还没搞懂，先mark一下。
参考：
1、Ubuntu20.04的网络配置
2、linux–ubuntu网络配置
1、查看RK3588网卡信息ip a： topeet@iTOP-RK3588:~ $ ip a 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: dummy0: &lt;BROADCAST,NOARP&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether 12:6d:fe:6e:1b:aa brd ff:ff:ff:ff:ff:ff 3: can0: &lt;NOARP,ECHO&gt; mtu 16 qdisc noop state DOWN group default qlen 10 link/can 4: eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN group default qlen 1000 link/ether 1e:cd:b4:ac:ad:97 brd ff:ff:ff:ff:ff:ff inet 169.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1d307861c5176a738feda197074c666/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6daa9d63ebaad0d950c1ff5a514d0ea4/" rel="bookmark">
			Redis的介绍，以及Redis的安装（本机windows版，虚拟机Linux版）和Redis常用命令的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis（Remote Dictionary Server）是一个开源的内存数据存储系统，它提供了持久化、高性能和高可用性的数据存储。它支持多种数据结构，如字符串、哈希表、列表、集合、有序集合等。Redis可以用作数据库、缓存，甚至可以用于处理消息队列和实时数据流。
一、Redis的安装和配置
本机Windows版安装：
Redis官方并没有提供官方的Windows版本，但是我们可以通过微软的Windows Subsystem for Linux（WSL）来运行Redis。 安装WSL：在Windows10中打开控制面板 -&gt; 程序 -&gt; 启用或关闭Windows功能 -&gt; 勾选适用于Linux的Windows子系统 -&gt; 确定。然后从Microsoft Store中找到适用于WSL的Linux发行版，如Ubuntu，并进行安装。运行WSL：在Windows10中打开开始菜单 -&gt; 搜索“WSL”，打开Linux终端。根据提示，设置一个用户名和密码。在WSL中安装Redis：在Linux终端中输入以下命令： sudo apt update sudo apt install redis-server 启动Redis：输入以下命令启动Redis： sudo service redis-server start 验证Redis是否安装成功：在Linux终端中输入redis-cli命令，可以进入Redis命令行界面。 虚拟机Linux版安装： 安装虚拟机软件：下载并安装虚拟机软件，如Oracle VirtualBox、VMware等。下载Linux ISO镜像文件：从官方网站下载一个适合你的Linux发行版的ISO镜像文件。创建虚拟机：在虚拟机软件中新建一个虚拟机，选择刚才下载的ISO镜像文件安装Linux操作系统。在虚拟机中安装Redis：在Linux终端中输入以下命令： sudo apt update sudo apt install redis-server 启动Redis：输入以下命令启动Redis： sudo service redis-server start 验证Redis是否安装成功：在Linux终端中输入redis-cli命令，可以进入Redis命令行界面。 二、Redis常用命令介绍
键操作命令： SET key value：设置指定key的值。GET key：获取指定key的值。DEL key：删除指定key及对应的值。EXISTS key：判断指定key是否存在。KEYS pattern：查找匹配给定模式的key。 字符串操作命令： APPEND key value：在指定key的值后面追加内容。STRLEN key：返回指定key的值的长度。INCR key：将指定key的值递增1。DECR key：将指定key的值递减1。 哈希表操作命令： HSET key field value：设置哈希表中指定key的指定field的值。HGET key field：获取哈希表中指定key的指定field的值。HDEL key field：删除哈希表中指定key的指定field及对应的值。HGETALL key：获取哈希表中指定key的所有field和value。 列表操作命令： LPUSH key value：将指定value插入到列表的左侧。RPUSH key value：将指定value插入到列表的右侧。LPOP key：移除并返回列表左端的元素。RPOP key：移除并返回列表右端的元素。LRANGE key start stop：返回列表指定范围内的元素。 集合操作命令： 以上只是Redis的一部分常用命令，Redis还有更多功能和命令，可以根据具体需求，查询Redis的官方文档以获取更详细的信息和使用示例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6daa9d63ebaad0d950c1ff5a514d0ea4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d53984989fe82842b4416a4e974fca2/" rel="bookmark">
			CSS解决div行变块 ➕ CSS解决“table中的td文字溢出控制显示字数，显示省略号”的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS解决div行变块 ➕ CSS解决“table中的td文字溢出控制显示字数，显示省略号”的问题 1. div变块级设置1.1 先看不设置的效果1.2 再看设置之后的效果 2. 解决 table 中 td 内容过长问题2.1 CSS实现（文字溢出控制td显示字数，显示省略号）2.1.1 先看效果2.1.2 实现代码2.1.3 可能会遇到的问题2.1.3.1 解决text-overflow不生效的问题2.1.3.2 解决在table 设置每列等宽table-layout: fixed；后， td设置宽度无效 2.2 鼠标放上去显示完整内容2.2.1 使用 title 属性（直接td上添加title属性）2.2.2 使用 title 属性（使用 js 添加title属性）2.2.2.1 直接 js 实现2.2.2.2 使用 jQuery 实现2.2.2.3 上面 js、jQuery 完整代码 2.2.3 通过 td:hover2.2.3.1 换行展示2.2.3.2 不换行展示 1. div变块级设置 1.1 先看不设置的效果 如下：
1.2 再看设置之后的效果 语句：style="display: flex;" 效果
代码：&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d53984989fe82842b4416a4e974fca2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/910757f71079fb2e0fdfe6e2285c0069/" rel="bookmark">
			容器内的 1 号进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：容器中的 init 进程 - &gt;$ cd /home/ 转载地址：容器内的 1 号进程
简介 在 Linux 系统中，系统启动的时候先是执行内核态的代码，然后在内核中调用 1 号进程的代码，从内核态切换到用户态。内核执行的第一个用户态程序就是 1 号进程。
目前主流的 Linux 发行版，无论是 RedHat 系的还是 Debian 系的，都会把 /sbin/init 作为符号链接指向 Systemd。Systemd 是目前最流行的 Linux init 进程，在它之前还有 SysVinit、UpStart 等 Linux init 进程。
同样在容器中也有 1 号进程的概念，一旦容器建立了自己的 Pid Namespace（进程命名空间)，这个 Namespace 里的进程号也是从 1 开始标记的。
1 号进程是第一个用户态的进程，由它直接或者间接创建了容器中的其他进程。
云原生Space
分享云原生领域相关技术文章~
39篇原创内容
公众号
为什么杀不掉容器中 1号进程 通过几个实际的示例来说明
下面示例统一用如下 Dockerfile，启动一个休闲 600s 的容器。
FROM ubuntu ENTRYPOINT ["sleep", "600"] 现象 示例一
在容器中使用 kill -9，kill -15 杀死 1 号进程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/910757f71079fb2e0fdfe6e2285c0069/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e5cad7b5e538d43015c9dabf29978c8/" rel="bookmark">
			使用Route-Map过滤BGP的路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验目的 1、掌握使用Route-Map过滤BGP的路由。
实验拓扑 接口ip配置与bgp基础配置详见：
CSDNhttps://mp.csdn.net/mp_blog/creation/editor/125210020查看R3的路由表：
R3#show ip route Gateway of last resort is not set 1.0.0.0/24 is subnetted, 4 subnets B 1.1.0.0 [20/0] via 23.23.23.2, 00:00:01 B 1.1.1.0 [20/0] via 23.23.23.2, 00:00:01 B 1.1.2.0 [20/0] via 23.23.23.2, 00:04:53 B 1.1.3.0 [20/0] via 23.23.23.2, 00:04:53 23.0.0.0/24 is subnetted, 1 subnets C 23.23.23.0 is directly connected, FastEthernet0/1 12.0.0.0/24 is subnetted, 1 subnets B 12.12.12.0 [20/0] via 23.23.23.2, 00:04:53 在R2上配置Route-map路由过滤：
R2(config)#access-list 1 deny 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e5cad7b5e538d43015c9dabf29978c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8d48192ea02eb533cb90f909d62345e/" rel="bookmark">
			Matlab 学习（1）---向量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Matlab 学习（1）（适合初学者）–matlab中的向量 matlab 中的向量创建 直接法
向量元素需要用英文的中括号“[]”括起来，元素之间用空格、逗号、分号或按回车键分隔，就可以创建对应的向量。
若元素之间用空格、逗号分隔，则创建的是行向量；若用分号、回车键分隔，则创建的是列向量。
冒号法
A:step:B创建一个行向量（英文格式）
注：A是初始值，B是终止值，step是步长。
利用matlab函数创建
linspace函数：创建等差数列
logspace函数：创建等比数列
1.linspace
linspace(a,b):该命令用来创建一个行向量，向量中的第一个元素为a，最后一个元素为b，形成总数为100个元素的线性间隔的向量。
linspace (a, b, n):该命令用来创建一个行向量，向量中的第一个元素为a，最后一个元素为b，形成总数为n个元素的线性间隔的向量。
2.logspace
logspace(a,b):创建一个行向量，其第一个元素为 1 0 a 10^a 10a，最后一个元素为 1 0 b 10^b 10b，形成总数为50个元素的等比数列向量。
logspace(a, b, n):创建一个行向量，其第一个元素为 1 0 a 10^a 10a，最后一个元素为 1 0 b 10^b 10b，形成总数为n个元素的等比数列向量。
向量元素的引用 我们知道，向量分为行向量和列向量，它们在 MATLAB中只有一个维度，因此我们可以利用向量中包含的元素个数来描述一个向量的大小。在MATLAB中，可以使用length函数或numel函数来计算向量中包含的元素个数。
单个元素引用 a(ind):（a沿用上面的a）ind是所要提取对应元素的索引。
多个元素引用 可以利用向量的索引来同时提取多个位置的元素，这时候只需要将ind设置成一个向量，ind中放入我们想要提取的元素的索引，然后使用a(ind)命令即可。熟悉的话可以直接写成**a([ ])**形式
用end索引
end可以用来替代向量的最后一个索引。
向量元素的修改和删除 利用 等号赋值 的方法对引用位置的元素进行修改和删除。
matlab学习系列为学习笔记 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a00f122f16dc279a0cef1f03cfa33fa4/" rel="bookmark">
			【C语言】制作一个表白用的移动字幕
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
今天要分享给大家的是一个非常有意思的字幕变化，可以用在很多的地方，列如：发给你喜欢的人或者是你的好兄弟，我们设定好字后，屏幕上会不断的打印我们想要的内容 ❤ ！！！
一.
先给大家讲解原理，方便大家可以后面自行的修改内容和打印方式，首先需要知道我们要打印的内容，这里我以“ I LOVE YOU ”举例子：
我们现在向输出I LOVE YOU 大字幕，首先要考虑的问题就是字幕的打印，我们想要的是大的字幕，而正常的字幕只能在一行且非常的小，完全不够我们表达的意思，而一行一行打又要费大家的很多时间，在这里我提前给大家准备好了
这只是我们移动字幕的小前提,下面的才是重点（后续大家想改内容也可以在这里修改）
二. 接下来开始讲解算法和执行步骤了，想要实现代码的变化肯定是需要用到了循环，我们在不断的更新数组中的内容，使得看起来像动态一样的输出，这个时候需要大家运用一个算法，用一数组中的字符不断的替代另一组数组字符的内容，不断的输入就可以实现，动态改变
举个列子：
不断的替换数组的内容达到我们想要的效果 三.
原理解释清楚了,接下来就是正文内容了，上面我们在进行替换的时候使用了8个字符数组，所以下面需要8个数组的替换，正常情况下，大家根据自己输出内容进行选择就行 到这里，我们的代码就搞定了，既然气氛都到这里了，再送你一个大礼物
只需要将代码加入我们上面的代码中，进行引用即可,如果不懂可以私聊我进行询问
四.
最最最重要的来了，我们做好了怎么让别人看到，正常情况下，别人需要安装C语言的软件很头疼，大多数人是小白，这样我们这串代码就失去了作用，大家使用的是 “ Visual Studio ”软件的话，根据下面我的步骤来：
今天要分享给大家的是一个非常有意思的字幕变化，可以用在很多的地方，列如：发给你喜欢的人或者是你的好兄弟，我们设定好字后，屏幕上会不断的打印我们想要的内容 ❤ ！！！ 一. 先给大家讲解原理，方便大家可以后面自行的修改内容和打印方式，首先需要知道我们要打印的内容，这里我以“ I LOVE YOU ”举例子： 我们现在向输出I LOVE YOU 大字幕，首先要考虑的问题就是字幕的打印，我们想要的是大的字幕，而正常的字幕只能在一行且非常的小，完全不够我们表达的意思，而一行一行打又要费大家的很多时间，在这里我提前给大家准备好了 char a[] = { " *****************************************************************************************************************" }; char a1[] = { "******************************************************************************************************************" }; char b[] = { " ****#######*******###********#########****##************##**############****##*******##**#########**####****####**" };//1 char a2[] = { "******************************************************************************************************************" }; char c[] = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a00f122f16dc279a0cef1f03cfa33fa4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/209b4d364648dcb103adcef329cc624f/" rel="bookmark">
			最新青龙面板一键搭建及拉库脚本教程----JD挂机一体化平台搭建之篇一【2022.11.29】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际搭建效果
（上车地址一）：https://jdbean1.tk
（上车地址二）：https://jdbean2.tk
QQ机器人搭建效果 ，可以发送“菜单”、“登录”、“查询”等指令
可以一起交流讨论
作者使用的各插件包括：
1.青龙面板
2.傻妞机器人sillyGirl
3.QQ登录插件go-cqhttp
4.微信插件XYO（目前已收费，建议使用千寻），机器人效果：jdbean888
5.短信登录面板rabbit
6.线报监控auto_spy
JD挂机一体化平台搭建系列：
篇二：傻妞一键安装，对接青龙，傻妞降级----JD挂机一体化平台搭建之篇二
篇三：傻妞对接青龙，对接QQ、TG、微信。一键、DOCKER安装【2022.11.29】
目录
一、青龙平台搭建（一键或docker二选一）
1.一键
2.docker安装
二、登录
三、安装依赖
四、脚本库订阅
五、获取并添加JD cookie
六、青龙面板常见问题
一、青龙平台搭建（一键或docker二选一） 1.一键 yum update -y wget -q https://raw.githubusercontents.com/yanyuwangluo/VIP/main/Scripts/sh/ql.sh -O ql.sh &amp;&amp; bash ql.sh 根据提示操作进行安装即可
一键脚本中，可以输入其他青龙版本，如2.13.8，也是可以安装的
​
输入完版本后，如果没有docker环境，会自动安装docker环境
安装完成后，需要手动进行选择目录等配置（没有特殊要求默认即可）
​
如果出现报错，按照提示解决即可
​
如上图中的报错，说明服务器可能没有netstat命令，解决即可
全部报错解决后、安装完成后，打开你的浏览器，访问 http://{ip}:5700
2.docker安装 首先需要具备docker环境，并在常用docker目录创建ql文件夹，如：
mkdir -p /root/docker/ql cd /root/docker 启动青龙容器2.13.8版本（版本太高后续插件不兼容，2.13.8比较稳定）
docker run -dit \ -v $PWD/ql:/ql/data \ -p 5700:5700 \ --name qinglong \ --hostname qinglong \ --restart always \ whyour/qinglong:2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/209b4d364648dcb103adcef329cc624f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a704be62020ad4f55c6d0b6c412b669/" rel="bookmark">
			京东青龙上车教程保姆级别讲解为什么上车以及详细开活动教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上车地址：https://jdbean1.tk​​​​​​
https://jdbean2.tk​​​​​​
QQ机器人搭建效果 ，可以发送“菜单”、“登录”、“查询”等指令
可以一起交流讨论
作者使用的各插件包括：
1.青龙面板
2.傻妞机器人sillyGirl
3.QQ登录插件go-cqhttp
4.微信插件XYO（目前已收费，建议使用千寻），机器人效果：jdbean888
5.短信登录面板rabbit
6.线报监控auto_spy
首先讲讲代挂 我们就是通过青龙面板去进行脚本配置，以达到自动运行脚本，然后脚本就可以每天自动帮我们完成各种任务，所以jd上车也是如此，然后我们日常完成任务所得的奖励就是金豆，1000=10元，京豆有效期是两年，所以这个可以积攒去购买价格在20以上其他东西（必须要20元以上的商品才能使用），在购物详情页就可以去选择使用抵扣了（特别讲解一下金豆，也可以直接用于官方的话费充值，jd直接搜索话费充值即可，40加1000豆充值50）
现在目标就很明确——搞京豆
搞之前记得把一些活动新手引导做一下，有些活动是需要先手动开启的
按照下面图片把活动都打开一遍 不然京豆或各种红包奖励都会少很多（脚本：活动不开我怎么帮你！）点我查看怎么开启，开启哪些活动
方案1，直接上车 上车地址：http://jdbean.tk​​​​​​
方案2，自己开车 开车三步走：开端口，搭建面板，拉脚本库
前提工作 详细连接服务器教程
finalshell下载安装及使用
下载网址
https://www.7down.com/soft/261355.html
使用软件去连接服务器
不知道密码看这 一丶开端口 开端口的具体有两方面，就是当时服务器系统选择镜像时，你是否选择有安装宝塔(推荐安装宝塔，对新人友好，后续操作简单)，如果已经安装宝塔，则需要在宝塔以及服务器中的防火墙把5700开启，如果没有安装宝塔就在服务器防火墙开启就行了
二丶搭建面板（推荐博主pilipili） 第一步：安装docker，docker-compose（有些云服务器能帮你安装好宝塔，如果有宝塔面板的可以直接在白塔面板里软件商店搜索docker安装docker）
新手建议用root权限进行 代码如下（注意一行一行的输入）：
su root sudo yum update sudo yum -y remove docker docker-common docker-selinux docker-engine sudo yum install -y yum-utils device-mapper-persistent-data lvm2 sudo yum-config-manager --add-repo http://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce docker-ce-cli containerd.io sudo systemctl start docker sudo systemctl status docker sudo systemctl enable docker sudo curl -L https://get.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a704be62020ad4f55c6d0b6c412b669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b046d728654cf15139874cf3739466fb/" rel="bookmark">
			vue项目使用vite设置proxy代理，vite.config.js配置，解决本地跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3+vite4项目，配置代理实现本地开发跨域问题 非同源请求，也就是协议(protocol)、端口(port)、主机(host)其中一项不相同的时候，这时候就会产生跨域
vite的proxy代理和vue-cli的proxy大致相同，需要在vite.config.js文件中配置（打包配置也在此）代理配置在server中，可以上vite官网服务器选项查看server.proxy代码示例：开发服务器选项–server.proxy需要注意：使用了代理之后，axios的base路径需要改成代理路径，比如
ok 直接贴配置代码： import { fileURLToPath, URL } from 'node:url' import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import fs from "fs" // https://vitejs.dev/config/ export default defineConfig({ base: './', //相对路径 plugins: [vue()], resolve: { alias: { '@': fileURLToPath(new URL('./src', import.meta.url)) } }, css: { preprocessorOptions: { less: { modifyVars: {}, javascriptEnabled: true, }, }, }, build: { minify:'terser', outDir: "./dist", //emptyOutDir: true, //assetsDir: "assets", //指定静态资源存放路径 // sourcemap: false, //是否构建source map 文件 terserOptions: { // 生产环境移除console compress: { drop_console: false, drop_debugger: true, }, }, // 块大小警告的限制（以 kbs 为单位） 默认： 500 chunkSizeWarningLimit: 1000, // 分解块，将大块分解成更小的块 rollupOptions: { output: { manualChunks(id) { if (id.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b046d728654cf15139874cf3739466fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8993ab82b0183835406919896f3a782/" rel="bookmark">
			如何吃，少花钱又营养丰富？可用MindOpt线性规划求解来决策
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题定义问题类型集合参数决策变量目标函数约束条件 数据 使用MindOpt求解器的API方法1：cell中直接输入代码运行方法2：命令行直接运行.py文件方法3:复制案例广场的例子 求解结果联系我们 不知大家小时候有没有和我一样的经历，爸妈说我挑食，这不吃那不吃，这个有营养多吃点，哪个吃多了不好…，后来我们长大了，才发现，他们不是不挑食，而且他们买的都是他们喜欢吃的。当然也有跟着爷爷奶奶过日子的时候，爷爷奶奶平时就比较节俭，讲究一个便宜。我们能不能用科学的方法来设定菜单，达到少花钱又营养呢？
本篇将介绍使用MindOpt来优化营养调配问题。（本例数据是假设的，决策值不能作为参考，仅为讲解决策算法用。）
营养调配问题的的目标是利用优化模型来设定每日饮食菜单，在满足各类营养的需求同时更能优化总成本．营养调配问题是可用线性优化来表达
决策 变量 为：以下食物调配多少量：起司汉堡 (Cheeseburger)、汉堡 (Hamburger)、火腿三明治 (Ham-sandwich)、鱼肉三民治 (Fish-sandwich)、鸡肉三民治 (Chicken-sandwich)、薯条 (Fries)、香肠比司吉 (Sausage biscuit)、低脂牛乳 (Low-fat milk)、和橙汁 (Orange juice)；约束 条件为：卡路里 (Cal.)、碳水化合物 (Carbo.)、蛋白质 (Portien)、维生素A/D (Vit. A/D)、铁 (Iron)和钙质 (Calc.)的每日摄取上/下限制，以及总量 (Volume) 限制；目标 函数则为：总成本的最小化． 问题定义 问题类型 线性优化问题，我们用先用集合和参数标明后面变量的取值关联信息。
集合 J : = { Cheeseburger, HamSandwich, Hamburger, FishSandwich, J := \{ \text{Cheeseburger, HamSandwich, Hamburger, FishSandwich, } J:={Cheeseburger, HamSandwich, Hamburger, FishSandwich, ChickenSandwich, Fries, SausageBiscuit, LowfatMilk, OrangeJuice } \text{ChickenSandwich, Fries, SausageBiscuit, LowfatMilk, OrangeJuice} \} ChickenSandwich, Fries, SausageBiscuit, LowfatMilk, OrangeJuice}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8993ab82b0183835406919896f3a782/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1945132b884ebb43799c7cb9e3ea4ea8/" rel="bookmark">
			MindOpt——优化虚拟电厂智能调度问题(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景光储荷经济性调度1. 问题描述2. 数学规划模型3. 使用MindOpt APL建模和求解3.1. 方法1：cell中直接输入代码3.2. 方法2：导入.mapl文件来运行 4. 结果解析 在本系列中，我们将介绍虚拟电厂多个实际应用场景中的智能决策，包括智慧楼宇、零碳园区等。
案例来源：https://opt.aliyun.com/example/aqIv2uBnQZfe/src/01_%E5%85%89%E5%82%A8%E8%8D%B7%E7%BB%8F%E6%B5%8E%E6%80%A7%E8%B0%83%E5%BA%A6.ipynb
案例作者：蒋蔚(蔚绛)
背景 近年来，在实现“双碳”目标的道路上，以风、光为代表的可再生能源作为缓解能源压力、促进可持续发展的重要途径广受关注。虚拟电厂作为一种区域性多能源聚合形式，实现了可再生能源大量接入电力系统运行，推动城市能源系统绿色高效发展。研究大规模常态化运行的虚拟电厂关键技术成为亟待解决的问题。分布式光伏、分布式储能及可控负荷等灵活性资源具有容量小、资源种类多、数量庞大等特点，难以直接参与电网互动运行。虚拟电厂有效聚合电源、负荷、储能等各类资源，参与电力市场，响应价格信号，为电网提供调峰、调频、调压与备用等辅助服务。
在电力市场价格、用户负荷需求、电源功率调节范围等参数随时间变化的情况下，我们考虑多时段优化问题，在满足各时刻功率平衡约束和设备固有约束的条件下，实现经济性调度最优，提供调度决策指令参考值。
在实际情况下，我们考虑虚拟电厂调度的问题难点主要包括以下两条：
不确定性：可再生能源、储能及负荷等单独运行时，电源容量较小，且具有较大的随机性、波动性、间歇性。例如： 发电功率：从产生原理来看，光伏、风力的发电和天气息息相关，具有不稳定性。用电负荷：用户端用电规律会随时间变化，同时，不同的用电场景（例如居民楼、商业楼、写字楼）具有不同的负荷特性。 多目标优化：在并网状态下，虚拟电厂与大电网同步运行，在孤网状态下，虚拟电厂需要自动控制电压和频率的平衡。在用电设备可控的情况下，我们可以联合调节用电负荷和储能设备实现虚拟电厂内部设备的协同和与电网的互动；但是，在本案例中，为了不影响居民或产业正常用电，我们希望在不削减负荷需求的情况下，通过控制虚拟电厂的储能单元，确保电力系统经济（降低电费）、低碳（降低碳排）、安全（削峰填谷）地运行。 为了应对以上问题，我们考虑不确定性存在情况下的决策。
首先，采用数学规划进行问题建模，确定决策变量、约束条件和目标函数；然后，通过MindOpt建模语言(MindOpt Algebra Programming Language, 简称为MAPL)将数学模型"翻译"为求解器可以理解的机器模型；最后，调用数学规划求解器(Solver)进行求解，进而得到最优决策。 光储荷经济性调度 本篇将以最简单的虚拟电厂场景为例，帮助快速理解。
1. 问题描述 我们考虑单个光伏、单个用户和单个储能设备在内的虚拟电厂场景中，在满足用户负荷需求的条件下，较短调度周期内（例如，四小时）的经济性最优目标。光伏可以发电给用户直用，也可以存储于储能设备中，在未来放电给用户使用；同时，光储不能覆盖的用户需求，可以从大电网中消费。
为了得到该调度问题的答案，我们首先需要将问题建模为数学规划问题，然后调用数学规划求解器来求解。
2. 数学规划模型 数学规划问题由三个要素组成： 决策变量，目标 和 约束条件，在该问题中具体如下：
考虑 T T T时间段调度问题，输入以下参数：
用户净负荷需求（负荷和光伏功率的差值）: L = ( l t ) ∈ R T L = (l_{t}) \in {\mathbb{R}}^{T} L=(lt​)∈RT （单位：kWh）电价： P = ( p t ) ∈ [ 0 , ∞ ) T P = (p_t) \in {[0, \infty)}^{T} P=(pt​)∈[0,∞)T （单位: $/kWh）储能充电效率： c 1 ∈ [ 0 , 1 ] c_1 \in [0,1] c1​∈[0,1]储能放电效率： c 2 ∈ [ 0 , 1 ] c_2 \in [0,1] c2​∈[0,1]储能单次充放电限制： α ∈ [ 0 , 1 ] \alpha \in [0,1] α∈[0,1] 决策变量为各时刻归一化的储能动作：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1945132b884ebb43799c7cb9e3ea4ea8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be723ae79b63c6f50a745cdd3d50f2a/" rel="bookmark">
			鲁棒线性回归问题，使用MindOpt也可优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题描述等价的矩阵形式 产生数据使用MindOpt求解器的API方法1：cell中直接输入代码运行方法2：命令行直接运行.py文件 求解结果联系我们 回归分析是一种预测技术，目的是建立 自变量x（向量）和 相关变量y（标量）之间的关系。目前有七种常见的回归分析：Linear Regression线性回归（本篇）、Logistic Regression逻辑回归、Polynomial Regression多项式回归、Stepwise Regression逐步回归、Ridge Regression岭回归、Lasso Regression套索回归、ElasticNet回归。
本篇我们讲述的是**Linear Regression线性回归中的鲁棒线性回归。**鲁棒回归又称为稳健回归，是统计学稳健估计的方法之一，主要思路是对离群点十分敏感的最小二乘回归中的的函数进行修改。
下文我们将讲述一个例子，来展示MindOpt优化鲁棒线性回归问题（含源代码）。
问题描述 学生的行为习惯和测试成绩之间的关系。线性回归使用线性函数 $y = &lt;\boldsymbol a,\boldsymbol x&gt; + b $ 来描述这种关系（更准确地说法是仿射函数）。向量 a \boldsymbol a a 表示“梯度”，标量 b b b 表示“截距”。通过 m m m 次观测 ( x 1 , y 1 ) . . . ( x m , y m ) (\boldsymbol x_1, y_1) ... (\boldsymbol x_m, y_m) (x1​,y1​)...(xm​,ym​) ，我们可以估计出 a \boldsymbol a a 和 b b b 的值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2be723ae79b63c6f50a745cdd3d50f2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/725dedd7fdd053becd0828eb118e97a2/" rel="bookmark">
			面对Flow-shop调度问题如何优化？可用MindOpt来决策
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 生产调度流线型调度问题- Flow shopFlow Shop 调度的MIP模型及其LP松弛变量目标约束MIP模型LP松弛模型 数据2.使用MindOpt求解器的API方法1：cell中直接输入代码运行方法2：命令行直接运行.py文件方法3: 云上建模平台复制项目运行 3.求解结果 联系我们 生产调度 生产调度是组织执行生产进度计划的工作。现代工业企业，生产环节、协助关系复杂，情况变化快，如果某一措施没有按期实现，常常会波及整个生产系统的运行。因此，加强生产调度工作，对于及时了解、掌握生产进度，研究分析影响生产的各种因素，根据不同情况采取相应对策，使差距缩小或恢复正常是非常重要的。
流线型调度问题- Flow shop Flow-shop的调度问题可以描述为：已知条件为有一批k个需要n道工序进行加工的工件，分别在n台不同的机器上进行加工，并且加工的顺序是一致的并且给定的，任一工件j（1&lt;=j&lt;=m）的l工序（1&lt;=l&lt;=n）的生产时间是已知的，要求合理地调度各工件的各生产工序在每台机器上的顺序。
Flow-shop特征：
各工件均需在所有机器（集）上加工；每个工件的各操作仅能在某一台机器（集）上加工；所有工件预先给定工艺路线，且工艺路线相同；工件不可重入。 Flow Shop 是调度领域中的经典模型：
给定一组机器和一批工件，所有工件都按相同顺序依次流过这些机器；工件在各台机器上的加工时长为给定值，一旦工件进入机器的时长已达相应加工时长，工件立即离开该机器；在任何时刻，一台机器仅能加工最多一个工件；优化的目标为最小化makespan，即最后完成所有加工的时间；决策为确定工件之间的先后顺序。 该问题可以通过黑盒方法或混合整数规划的方法进行求解，在求解过程中，对某个候选解与理论最优解的距离进行估计，可以帮助我们评估解的质量。为获得下界的估计，我们可以松弛混合整数规划模型中的整数约束，得到一个线性规划，求解该松弛问题，即可得到原问题的一个下界。
Flow Shop 调度的MIP模型及其LP松弛 变量 x i j x_{ij} xij​, 工件 i i i 比工件 j j j 先加工时取 1；否则取 0；( i , j ∈ { 1 , … , J } , i ≠ j i,j\in\{1,\ldots,J\},\; i\neq j i,j∈{1,…,J},i=j) s m i s_{mi} smi​, 工件 i i i 比在机器 m m m 上开始加工的时间；( m ∈ { 1 , … , M } , i ∈ { 1 , … , J } m\in\{1,\ldots,M\},\; i\in\{1,\ldots,J\} m∈{1,…,M},i∈{1,…,J}) C max C_{\text{max}} Cmax​，最大完工时间，即 makespan 目标 min ⁡ C max \min \; C_{\text{max}} minCmax​ 约束 工件 i i i 比工件 j j j 先加工，则工件 j j j 必然比工件 i i i 后加工，即 x i j = 1 x_{ij}=1 xij​=1 时， x j i = 0 x_{ji}=0 xji​=0，反之亦然，因此，我们有： x i j + x j i = 1 , i , j = 1 , … J , i ≠ j x_{ij}+x_{ji} = 1, \; i,j=1,\ldots J, \; i\neq j xij​+xji​=1,i,j=1,…J,i=j当工件 i i i 比工件 j j j 先加工，在任何机器上工件 j j j的开始时间都不早于工件 i i i的结束时间（即 s m i + P i , m s_{mi}+P_{i,m} smi​+Pi,m​），用 Z 表示某一“足够大”的正实数，我们有： s m j ≥ s m i + P i , m + ( x i j − 1 ) Z , m = 1 , … , M , i , j = 1 , … , J , i ≠ j s_{mj} \geq s_{mi} + P_{i,m} + (x_{ij}-1)Z, \; m=1,\ldots,M, \; i,j=1,\ldots,J,\; i\neq j smj​≥smi​+Pi,m​+(xij​−1)Z,m=1,…,M,i,j=1,…,J,i=j工件在后续机器上的开始时间不得早于当前机器上的结束时间，即： s m + 1 , i ≥ s m i + P i , m , m = 1 , … , M − 1 , i = 1 , … , J s_{m+1,i} \geq s_{mi}+P_{i,m},\; m=1,\ldots,M-1,\; i=1,\ldots,J sm+1,i​≥smi​+Pi,m​,m=1,…,M−1,i=1,…,J据最大完工时间的定义，有： C max ≥ s M i + P i , M , i = 1 , … , J C_{\text{max}} \geq s_{Mi}+P_{i,M}, \; i=1,\ldots, J Cmax​≥sMi​+Pi,M​,i=1,…,J变量的取值范围：对任意 i , j ( i ≠ j ) , m i,j (i\neq j), m i,j(i=j),m， x i j ∈ { 0 , 1 } , s m i ≥ 0 , C max ≥ 0 x_{ij}\in\{0,1\}, \; s_{mi}\geq 0,\;C_{\text{max}} \geq 0 xij​∈{0,1},smi​≥0,Cmax​≥0 MIP模型 KaTeX parse error: Unknown column alignment: a at position 18: …egin{array}{rrca̲ll} \min\; &amp; C_…
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/725dedd7fdd053becd0828eb118e97a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24914e554a37671241f84eba48a41307/" rel="bookmark">
			MindOpt学习（二）：MindOpt的下载安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 MindOpt的下载安装配置环境安装Windows 平台安装说明Linux 平台安装说明OSX 平台安装说明开通服务开通查看已购服务和LicenseKey License配置WindowsLinuxOSX配置阿里云鉴权文件 fl_client.ini 联系我们 上一篇：MindOpt学习（一）：初步了解MindOpt
下一篇：MindOpt学习（三）：使用 Visual Studio 2022 配置一个MindOpt C++项目
MindOpt的下载安装 MindOpt官网：https://opt.aliyun.com/
MindOpt中文社区：https://developer.aliyun.com/group/opt#/
配置环境 目前, MindOpt 提供对以下操作系统及语言的支持：
支持的操作系统：
操作系统要求WindowsWindows 10LinuxGlibc &gt;= 2.08OSXOSX &gt;= 10.9 支持的语言：
语言建议使用的编译器CVisual Studio 大于等于 2017、GCC 大于等于 4.5、Clang++C++Visual Studio 大于等于 2017、GCC 大于等于 4.5、Clang++PythonAnaconda Python 3.6、3.7、3.8、3.9、3.10Java请查阅线上java库的更新 注：Mac M1芯片 Python 版本支持 3.8～3.10
安装 Windows 平台安装说明 在 下载安装包 下载Windows 64-bit/x86 MindOpt 发行版（win64-x86-0.23.0）。拿到 .msi 格式的安装包后，双击安装包根据指引安装即可。 此外，如果您安装特殊版本，可能拿到的是一个 .zip 压缩包格式，或想改多个版本生效方式时，请参考下面的方式进行设置环境变量:
解压缩文件到您希望的文件夹。在 控制面板 中搜索并选择 系统。单击 高级系统设置。单击 环境变量，在 系统变量 中找到 PATH 环境变量并选中它。点击 编辑，如果 PATH 环境变量不存在，请单击 新建 以创建一个新变量。在 编辑系统变量 （或 新系统变量 ）窗口中，添加以下路径 这里，MDOHOME、 VERSION 和 PLATFORM 分别是 MindOpt 的安装目录、版本号和操作系统平台。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24914e554a37671241f84eba48a41307/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d6a7adb216daa0ad6a069f53756282e/" rel="bookmark">
			Python调用MindOpt求解二次规划问题的几点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介如何获取MindOpt求解器二次规划定义二次规划问题：总结1.创建模型2.定义目标函数3.定义求解变量4.定义约束条件5.设置目标的二次项系数6.设置参数：7.求解QP模型 联系我们 简介 本篇文章是系列文章的第三篇，MindOpt对于python的支持还是挺不错的，我已经编写了建模优化线性规划和混合整数线性规划问题的例子，下文我会对Python调用MindOpt建模优化二次规划问题进行总结。
如何获取MindOpt求解器 求解器安装包的发布渠道。请大家:
前往 https://www.aliyun.com/product/ai/opt 来下载求解器软件。在阿里云上获取免费授权码:
• 请大家迁移到“云鉴权”自助申请licenseKey，配置fl_client.ini。新的“云鉴权”不需要绑定机器ID，只要阿里云账号并联网就好。
关于求解器的使用文档，请参考：https://help.aliyun.com/document_detail/298219.htm 二次规划定义 在前文线性规划问题示例中，讲述到线性规划在我个人认为是在线性的目标和约束中，找出一个最优解。而本文的二次规划，是非线性规划中的一类。具体地说，是一个线性约束的、二次规划问题，就是优化（最小化或最大化）二次函数目标的问题。
关于优化的类别，有很多，比如MindOpt的案例广场的标签里面提到的问题标签，就列出了常见的数学规划的类型。其中关于变量、约束、目标这建模三要素，进行罗列：
关于变量：取值有连续的，有整数的，还有更特殊的二进制（0或1）的，关于约束和目标：一般用变量的函数变换来表达，其中约束再增加它函数的取值范围。 当函数是变量的线性关系时，比如x的1次方相加，我们称呼为线性约束、线性的目标。（如果变量也是连续的，这个就是线性规划问题啦。）当函数是变量的是二次关系的时候，比如函数中有 x的2次方项。我们称呼为二次约束，或二次目标。函数还会有凸函数和非凸函数，数学里面都代表不同的特性，大家可以再多去查阅材料。 本文主要讲 凸二次规划，Convex Quadratic Programming。
二次规划问题： """ /** * Description * ----------- * * Linear optimization (row-wise input). * * Formulation * ----------- * * Minimize * obj: 1 x0 + 1 x1 + 1 x2 + 1 x3 * + 1/2 [ x0^2 + x1^2 + x2^2 + x3^2 + x0 x1] * Subject To * c1 : 1 x0 + 1 x1 + 2 x2 + 3 x3 &gt;= 1 * c2 : 1 x0 - 1 x2 + 6 x3 = 1 * Bounds * 0 &lt;= x0 &lt;= 10 * 0 &lt;= x1 * 0 &lt;= x2 * 0 &lt;= x3 * End */ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d6a7adb216daa0ad6a069f53756282e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aa0bf3280b2733fc2d197ee37614252/" rel="bookmark">
			MindOpt Tuner调参器，提升求解速度、性能（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MindOpt Studio简介 MindOpt 调参器（MindOpt Tuner，简称 MTuner）是一款超参自动优化工具。
它可以帮助运筹优化工程师在使用求解器时自动搜索最佳参数组合。优化求解器往往拥有很多配置参数，例如启发式方法的开关、割平面方法的开关、预处理的配置以及各种误差容忍度等等。MindOpt Tuner会尝试不同的参数组合，评估每组参数的性能，然后基于这些结果来确定最佳参数。这样可以大大减少手动调整参数的时间和精力，并且可以帮助提升求解性能。
不同于常见的贪心算法、遗传算法、粒子群算法等调参算法，MindOpt Tuner使用了团队新研发的快速算法，只需要相对少的评估就能给出性能很好的参数。
输入:
业务场景中的优化问题数据，一个或者多个均可以待调的求解器（可选）这个求解器待调的参数。若没有指定，则会自动用MindOpt Tuner内部内置的能力。 输出：
一套最优参数。采用此参数运行该求解器，在您的业务场景上会得到更优的效果。一系列结果文件和日志，给出调参效果分析。比如会列出对效果影响更大的几个参数。 用法 MindOpt Tuner 当前支持以下几种用法：
web页面作业提交：可直接在浏览器访问“作业提交”来提交和管理任务、获取结果，在其他渠道提交的任务也可在此任务管理查看到。Notebook容器：类似MindOpt求解器和建模语言，可以访问MindOpt建模求解平台的Notebook容器中使用Mtuner。其内核同单机版，但无需安装步骤直接浏览器中使用。采用Notebook项目方便记录笔记、查询接口和参数说明、混合编程、公开分享项目等。单机版：支持在MacOS、Linux、Windows平台环境下来创建并触发调参任务。适合需要定制化集成或私有化部署的客户,安装包获取&gt;&gt; 本篇系列将重点讲解下Notebook容器中如何使用命令行（本篇）和PythonAPI，并且给出web页面任务提交用法示例截图。
注：下面的文件包含code源码，您可复制本项目，然后在浏览项目内容页点击右上角的NoteBook按钮，进入环境后查看、运行、修改调试代码。
Notebook容器中使用 下文将通过以下顺序讲解：
提交任务：根据一个问题调优学习查询指令查询结果使用结果提交一组数据用于调参（本地和OSS）其他常用指令 1. 提交任务：根据一个问题调优 这里假设我们业务场景搜集到两个数据，nl_train_1.nl用来调参，nl_test_1.nl用来验证调参结果可用。
首先我们运行如下指令提交一个调参任务:
! mindopt-tuner create-task --solver cbc --problem './model/nl_train_1.nl' --max-tuning-time 600 OpenBLAS WARNING - could not determine the L2 cache size on this system, assuming 256k Problem file "nl_train_1.nl" uploaded successfully. Task #438394355699425280 created succesfully. 这里需注意：为了节省数据存储空间，同用户下的MD5值相同的数据文件，服务端仅会存一次。因此重复提交后会提醒文件已存在。此时调参任务继续执行，线上存的数据不更新。
这里小编已经提交了测试过，新提交taskID会和后文描述不一样。小编提交的taskID是 438394355699425280。后文将基于此ID来讲解获取结果，用户请注意更换自己的ID测试。
这段任务提交的指令可以解析为：
指令段说明!使用cell magic，让可以在Python内核的Notebook的code cell里面运行命令行指令。mindopt-tuner是MindOpt Tuner调参器的可执行程序的名称create-task创建任务。还有其他指令可以通过 mindopt-tuner -h去查询–solver cbc选择求解器为cbc。还有其他参数可以通过 mindopt-tuner create-task -h去查询–problem ‘.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4aa0bf3280b2733fc2d197ee37614252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa9fc6aa35ec96772c7644c4da34b3c8/" rel="bookmark">
			BERT和ALBERT的区别；BERT和RoBERTa的区别；与bert相关的模型总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.BERT和ALBERT的区别： BERT和ALBERT都是基于Transformer的预训练模型，它们的几个主要区别如下：
模型大小：BERT模型比较大，参数多，计算资源消耗较大；而ALBERT通过技术改进，显著减少了模型的大小，降低了计算资源消耗。
参数共享：ALBERT引入了跨层参数共享机制，即在整个模型的所有层中，隐藏层的参数是共享的，也就是说每一层都使用相同的参数。相比之下，BERT中每一层的参数都是独立的。
嵌入参数因子化：在BERT中，词嵌入的维度和隐藏层的大小是等价的。但在ALBERT中，词嵌入的维度被因子化为两个较小的矩阵，相比BERT进一步减小了模型参数数量。
损失函数：ALBERT中的损失函数增加了一个句子顺序预测(SOP)任务，即预测两个句子的先后顺序，这是为了更好地建模句子间的连贯性。与此相比，BERT原生的模型中并不包含这个功能。
效果对比：尽管ALBERT模型比BERT小，但其性能却未受影响，甚至在某些任务上表现出更好的效果。
训练效率：由于模型大小的差异，ALBERT相较于BERT在训练时拥有更高的效率。
总的来说，ALBERT主要针对BERT模型大、参数多的问题进行优化，以降低计算资源消耗，提高训练效率，同时保持或提升模型性能。
二.BERT和RoBERTa的区别： BERT和RoBERTa都是基于Transformer的自然语言处理预训练模型，它们都采用了masked language model（MLM）的形式来进行训练。以下是它们主要的区别：
训练数据和处理：尽管两者都使用大规模的无标签文本来进行预训练，但是在数据处理上有所不同。RoBERTa去掉了BERT中的next sentence prediction（NSP）任务，因此在数据处理上不再需要将两个句子合并为一条训练样本，这对于模型性能的提升起了重要作用。
训练模型：RoBERTa使用了动态mask机制，即在每个epoch中，对输入的文本进行不同的mask，这与BERT中的静态mask策略不同。
超参数的设定：RoBERTa通过大幅增加BERT预训练的Batch Size和学习率，并延长训练时间，成功地提升了模型的性能。
训练速度和效率：RoBERTa通过优化并行化训练技术以加快训练速度，比如增加最大序列长度，改变batch size的设定等。
效果：RoBERTa在多项自然语言处理任务上比BERT展示出了更好的效果。
总的来说，RoBERTa可被视为是BERT的一种优化版模型，通过改进BERT的训练策略和技术细节，大幅提升了模型的性能。
三.与bert相关的模型总结： GPT (Generative Pre-training Transformer): 类似BERT，GPT也是一种基于Transformer架构的预训练模型。与BERT不同的是，GPT只用到了Transformer的解码器部分，并且采用了不同的预训练任务，使用单向语言模型进行训练。
RoBERTa (Robustly optimized BERT pretraining approach): RoBERTa是对BERT预训练方法的改进，移除了BERT中的Next Sentence Prediction(NSP)任务，并且修改了训练数据的大小和批次，从而进一步提升了模型性能。
ALBERT (A Lite BERT): ALBERT是BERT的一个变种，减少了模型参数数量，超越了原BERT在各种下游任务的性能。使用了参数共享和句子顺序预测SOP（sentence-order prediction）两种策略进行优化。
XLNet: XLNet同样是BERT的变种，其采用了自回归预训练方法，解决了BERT由于单向或者双向预训练导致的预训练和微调阶段不一致的问题。
ELECTRA (Efficiently Learning an Encoder that Classifies Token Replacements Accurately): ELECTRA也是对BERT的改进，使用了一种新的预训练任务，可以更高效地利用语言建模信号。
DISTILBERT: DitiBERT 是BERT的轻量级版本，它通过对BERT进行知识蒸馏，模型参数量减小了40%，但在多个任务上的性能衰减不到 5%。
T5 (Text-to-Text Transfer Transformer): T5将所有NLP任务都视为文本生成任务，并通过在大量无标注文本上预训练来解决这些任务。 T5提取了BERT和其他Transformer预训练任务中的优点。
DeBERTa (Decoding-enhanced BERT with disentangled attention): DeBERTa介绍了一种解耦的注意机制来改进BERT的注意机制，通过调整每个输入令牌的重要性来提高预测性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa9fc6aa35ec96772c7644c4da34b3c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8859ff3eb3cc7512a111ae7ae81b2288/" rel="bookmark">
			简述“优化求解器”的相关概念和国内外软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 简述 优化求解器（optimization solver）是一种用于求解数学优化问题的软件工具或库。数学优化问题的目标是在给定约束条件下找到一个目标函数的最优解（最大值或最小值）。优化问题在许多领域都有广泛应用，如运筹学、工程、经济学、物流、能源、金融等。
中文名：优化求解器
外文名：Optimization Solver、Optimizer
所属学科：应用数学
2. 定义 优化求解器（optimization solver）是一种用于求解数学优化问题的软件工具或库。优化求解器的主要任务是根据用户提供的数学模型（目标函数和约束条件）来寻找最优解。
3. 优化问题的概念 数学优化问题是：在给定约束条件下，找到一个目标函数的最优解（最大值或最小值）。
如果您是初学者，可看我另外一篇博客，快速入门了解什么是优化问题：
https://blog.csdn.net/wuyoy520/article/details/134204450
这里举例一个优化问题：
电商平台要为一家新兴手游公司进行广告推广，平台有两种广告类型可供选择：类型A、类型B、类型C。广告类型A的转化率为5%，每投放一次费用为10元；广告类型B的转化率为8%，每投放一次费用为15元; 广告类型B的转化率为7.7%，每投放一次费用为12元。手游公司需要至少获得1000次投放，并且总费用不能超过20000元。每种类型广告都希望至少投放5次。平台希望最大化累计转化数，要如何规划广告投放？
用数学优化的方法描述这个问题，得到如下的优化问题数学公式：
图片内容和公式来自MindOpt新发布的基于大模型的AI工程师生成的内容截图。 最后用优化求解器算得的解是：
广告类型A投放次数=5
广告类型B投放次数=6
广告类型C投放次数=1655
目标函数值 = 128.165
4. 应用 优化问题在运筹学、工程、经济学、物流、能源、金融等许多领域有应用。属于底层的数学技术， 应用面很广。在航空、航天、国防等也有应用。
对应的求解优化问题的优化求解器可以广泛应用于电力系统调度、生产计划、物流路径规划、投资组合优化等多个领域。使用优化求解器可以帮助用户更方便、更快速地找到问题的最优解。
推荐可以去阿里达摩院求解器的案例广场看看，了解应用场景，和对应的简单的数学模型、源代码。
5. 优化问题的求解方法 其求解方法有：单纯形法、内点法、分枝定界法、梯度下降法、遗传算法等。
在大学的运筹学课程里，一般会教求解线性规划（LP）需要的单纯形法，和求解带整数的线性规划（MILP）的分支定界法。
在实际业务里，一般情况下不太需要关心求解的方法，是借助工具来完成计算。更多地是需要了解不同算法计算的复杂度，是否能快速求解，如果不能，如何变更优化问题，使得能快速求解。
建议：求解方法这个知识点，仅作科普了解，更多地去准确描述好自己的优化问题是什么类型的问题，然后熟悉求解优化问题的工具，了解工具是否适合计算自己的优化问题。比如现在我们并不需要关心计算机是通过什么原理算出来了3+5=8，更多地去了解如何使用它。但是如果您刚好是这类计算工具的开发者，就需要查询相关的资料来学习。
6. 选择求解工具的参考原则 选什么工具来计算，需要调研选择合适的。如根据优化问题的类型，优化求解器可以分为多种类型。比如线性规划、非线性规划、整数规划、混合整数规划等各自类别求解器。大部分商用优化求解器会将各种求解能力组合，可以处理多种类型的优化问题，包括线性、非线性、整数和混合整数优化等；同时实现自动化求解，用户只需提供数学模型，优化求解器会自动选择合适的算法并寻找最优解。
在选择或者研究求解器时，一般会评估如下特性：
是否能求解求解速度稳定性大规模问题求解能力和计算资源占用接口易用性 优化求解器的软件有很多。每家的侧重点会不一样，主流都是具备数学规划的求解能力，有的会集成约束规划、黑盒优化等能力。
开源的求解器和商用的求解器的差异主要是求解速度、可求解问题的类型。速度差异可能有几百倍。
在很多限时要求高的场景，比如互联网、机器人的行业，建议直接用商用求解器（有的厂商提供免费版），直接体验高速版本验证方案效果。毕竟研发方案期间最耗时的是业务的数学建模，不要因为用错计算工具浪费太多时间浪费方案。就相当于，开发一个方案的一开始，先上一个高性能的电脑试试可行性，后面确认可行后，再研究怎么换芯片降成本。
7. 市面上的优化求解器软件 7.1. 国际上 国际上的优化软件起步很早，可以追溯到上世纪80年代。特别是商用的软件，积累了很多客户的经验，软件更稳定；且很少有研发的方案泄露出来，技术保密的很好，性能领先。
国际上的优化求解器（仅列出常见的、且有软件下载地址的）：
CPLEX：美国/IBM。网址：https://www.ibm.com/cn-zh/products/ilog-cplex-optimization-studio。 IBM的老牌产品，历史悠久，企业用户多。Gurobi：美国/Gurobi。网址：https://www.gurobi.com。当前世界顶尖的求解器，部分成员曾任职CPLEX，MILP的性能国际第一。Xpress：加拿大/FICO。网址：https://www.fico.com/en/products/fico-xpress-optimizationMosek：丹麦/Mosek。网址：https://www.mosek.comLocalSolver：法国/LocalSolver。网址：https://www.localsolver.com/LINGO：美国/LINDO。网址：https://www.lindo.com/index.php/products/lingo-and-optimization-modelingCOIN-OR：开源组织，收录了很多种不同的开源求解器。网址：https://www.coin-or.orgSCIP：开源的求解器。网址：https://www.scipopt.orgGLPK：开源的求解器。网址：https://www.gnu.org/software/glpk 7.2. 国产的 从15年后，国内多个团队开始逐步开始研发求解器模块。并且在19年20年，有商业公司的加入，研发的软件更稳定。
国内的优化求解器（仅列出有软件可供下载使用的公司）：
MindOpt：中国/阿里巴巴达摩院。网址：https://opt.aliyun.com 。根据网页指引，直接在阿里云产品平台https://help.aliyun.com/document_detail/298275.html 下载软件和获取免费License。当前支持LP、MILP、CQP、SDP这些数学规划求解，和仿真优化 （零阶优化、黑盒优化，可用于调参）。
新手推荐用MindOpt线上的平台，不需要安装直接先学会使用，Notebook中直接码代码，上手学习更快捷。还有自研的代数建模语言、以及AI技术结合开发、大模型技术结合自动建模和码代码的方案，更贴合现代的AI+运筹结合的技术趋势。 COPT：中国/杉数。网址：https://www.shanshu.ai/copt。根据页面指引填写信息申请安装包和License。国内研发的早的公司，求解效果不错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db21ce3233cd7c0bfb572aeac090e15c/" rel="bookmark">
			用VBS操作Excel常见方法总结！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人详解
作者：王文峰，参加过 CSDN 2020年度博客之星，《Java王大师王天师》
公众号：JAVA开发王大师，专注于天道酬勤的 Java 开发问题
中国国学、传统文化和代码爱好者的程序人生，期待你的关注和支持！本人外号：神秘小峯 山峯 转载说明：务必注明来源（注明：作者：王文峰哦）
一键三连 一键三连 一键三连~
系列文章分类
C#专栏、VBS专栏、JAVA 专栏、IDEA 专栏
用VBS操作Excel常见方法总结 前言一、实现代码二、实现代码三、实现代码四、实现VBS操作Excel 总结 前言 vbs详情&gt; VBS是基于Visual Basic的脚本语言。VBS的全称是：Microsoft Visual Basic Script Edition。（微软公司可视化BASIC脚本版）。 其语言类似Visual Basic（VB） 脚本语言的特点为: 简单易学 解释性语言 集成成熟技术 VBScript是 Visual Basic Script 的简称，即 Visual Basic 脚本语言，有时也被缩写为 VBS。 VBScript 是微软开发的一种脚本语言。使用 VBScript，可通过 Windows 脚本宿主调用 COM，所以可以使用 Windows 操作系统中可被使用的程序库。 VBScript 一般被用在以下个方面：VBScript 经常被用来完成重复性的Windows 操作系统任务；用来指挥客户方的网页浏览器。在这一方面，VBS 与JavaScript 是竞争者，因为本文的实验环境基于 Window 平台，为了达到更好的兼容性和性能选用 VBScript。 提示：以下是本篇文章正文内容，下面案例可供参考
一、实现代码 dim oExcel,oWb,oSheet Set oExcel= CreateObject("Excel.Application") Set oWb = oExcel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db21ce3233cd7c0bfb572aeac090e15c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1ea38ef01bcc9df36b9bcf3e8a66bdb/" rel="bookmark">
			多种代码生成炫酷代码雨（推荐）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人详解
作者：王文峰，参加过 CSDN 2020年度博客之星，《Java王大师王天师》
公众号：JAVA开发王大师，专注于天道酬勤的 Java 开发问题
中国国学、传统文化和代码爱好者的程序人生，期待你的关注和支持！本人外号：神秘小峯 山峯 转载说明：务必注明来源（注明：作者：王文峰哦）
本人主页
多种代码生成代码雨 文章目录 多种代码生成代码雨一、html代码雨效果图：代码块 二、vb代码雨效果图：代码块 三、bat代码雨效果图：代码块 一、html代码雨 效果图： 代码块 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Code&lt;/title&gt; &lt;style&gt; body{ margin: 0; overflow: hidden; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="myCanvas"&gt;&lt;/canvas&gt; &lt;script&gt; const width = document.getElementById("myCanvas").width = screen.availWidth; const height = document.getElementById("myCanvas").height = screen.availHeight; const ctx = document.getElementById("myCanvas").getContext("2d"); const arr = Array(Math.ceil(width / 10)).fill(0); const str = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".split(""); function rain() { ctx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1ea38ef01bcc9df36b9bcf3e8a66bdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0750b8e85b630c7930c439b94ea6db4/" rel="bookmark">
			互相关注业务场景数据库表设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
业务场景
业务问题：
数据库表设计：
like（关注表）：
friend（朋友表） 并发场景下，SQL语句执行逻辑
比较 A 和 B 的大小，如果 A执行下面的逻辑：&lt;&gt;
如果 A&gt;B,则执行下面的逻辑：
SQL写法详解：
参考内容：
业务场景 业务上有这样的需求，A、B两个用户，如果互相关注，则成为好友。
业务问题： 在并发场景下，同时有两个人，设置为关注对方，就可能导致无法成功加为朋友关系。如下：
session（a喜欢b）session（b喜欢a） begin;
select * from friend_like where user_id = B andliker_id = A;(返回空)
begin;
select * from friend_like where user_id = B andliker_id = A;(返回空)
insert into friend_like (user_id, liker_id) values(B,A);insert into friend_like (user_id, liker_id) values(A,B);commit;commit; 数据库表设计： like（关注表）： CREATE TABLE `friend_like` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` int(11) NOT NULL, `liker_id` int(11) NOT NULL, `relation_ship` int(11) NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `uk_user_id_liker_id` (`user_id`,`liker_id`) ) ENGINE=InnoDB; friend（朋友表） CREATE TABLE `friend` ( `id` int(11) NOT NULL AUTO_INCREMENT, `friend_1_id` int(11) NOT NULL, `friend_2_id` int(11) NOT NULL, UNIQUE KEY `uk_friend` (`friend_1_id`,`friend_2_id`), PRIMARY KEY (`id`) ) ENGINE=InnoDB; relation_ship: 1，表示 user id 关注 liker id;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0750b8e85b630c7930c439b94ea6db4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b55c18060c7b81a6c2e0568ce7f43af/" rel="bookmark">
			byte数组转16进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 fun ByteArray.toHex(): String = joinToString(separator = "") { eachByte -&gt; "%02x".format(eachByte) } val originalBytes = byteArrayOf(0x48, 0x65, 0x6C, 0x6C, 0x6F) println("目标数组内容：${originalBytes.joinToString { it.toString(16) }}") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e05574fcc4f4d01c3fc34f8e4bd33a3a/" rel="bookmark">
			Stable Diffusion 的提示词使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐Stable Diffusion自动纹理工具： DreamTexture.js自动纹理化开发包 什么是提示语？ 提示语是人工智能中的一个重要组成部分，尤其是自然语言处理 （NLP）。在AI自人工智能中，想要获得好的效果，简洁、准确的提示语尤为重要。比如，使用DreamTexture.js自动纹理化开发包 为模型生成纹理，不同的提示语获取的最终效果也是不一样，如下是一个泵机模型，我想要为这个泵机贴上纹理让模型看起来更加真实，我采用两种提示词，效果如下：
提示词：Realistic,cinematic, 8k,Front view
第一张图中只是用了很常规的提示词：Realistic, cinematic ,8k,Front view，所有模型只是简单的生成了一张金属效果的贴图，而没有其他细节的体现。
再看第二张效果图：
提示词：Pump machine,red, Realistic, cinematic ,8k,Front view。
第一张图中添加模型名称说明和颜色描述，效果截然不同。以上只是简单的介绍下提示词在人工智能语言提示中的重要作用，下面我们来具体讲述下如何正确的给出提示词，以获得不同的效果。
1、什么是原始提示词？ 原始提示是对要生成的内容的非常基本的描述。 大多数人一开始只使用原始提示。这是一个常见的错误，因为 这些图像往往会变得随机和混乱。结果还可以，但我们可以做得更好:) 例如，我生成了一只老虎、一座摩天大楼和一块具有稳定扩散的手表。
如您所见，这些图像并没有什么特别之处，也可能是谷歌图像搜索:)
2、为提示词添加样式 提示的样式非常重要。如果 AI 缺少特定样式， 它通常会选择在类似图像中看到最多的一个。 拥有精心选择的样式和原始提示有时就足够了，因为该样式在原始提示之后对图像的影响最大。
最常用的样式包括： 现实油画铅笔画概念图数字艺术卡通动漫漫画素描水彩抽象超现实主义波普艺术未来主义 我们可以看到，随着样式的增加，结果越来越好，Tiger 作为铅笔画就是一个很好的例子。
对于逼真的图像，有多种方法可以使其达到最佳状态。以下是一些使图像逼真的常用技术：
的照片 + RAW Prompt照片 + RAW 提示原始提示，超现实原始提示，逼真 如果您希望您的提示生成一幅油画，您可以在提示中添加“一幅油画”。这有时可能会导致图像在框架中显示油画。如果发生这种情况，您可以重新运行提示或使用原始提示 + “油画”。
要创建铅笔画，请在原始提示中添加“铅笔画”，或将提示设置为原始提示 + “铅笔画”。
3、将艺术家添加到提示中 为了使您的风格更具体，您可以在提示中使用艺术家的名字。 例如，如果你想要一个非常抽象的图像，你可以添加“由巴勃罗·毕加索制作”，或者简单地说，“毕加索”。 以下是您可以使用的不同风格的艺术家列表， 但我总是鼓励你寻找不同的艺术家，因为这是发现新艺术的一种很酷的方式。
肖像 约翰·辛格·萨金特， 埃德加·德加， 保罗·塞尚， 扬·凡·艾克
油画 莱昂纳多·达芬奇， 文森特·梵高， 约翰内斯·维米尔（Johannes Vermeer）， 伦勃朗
铅笔/钢笔画 阿尔布雷希特·丢勒， 列奥纳多·达·芬奇， 米开朗基罗 让-奥古斯特-多米尼克·安格尔
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e05574fcc4f4d01c3fc34f8e4bd33a3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cdf0dda191f3330178419e5d5d4c07a/" rel="bookmark">
			VSCode实用远程主机功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为嵌入式开发者，经常在各种系统平台或者开发工具之间切换，比如你的代码在Linux虚拟机上，如果不习惯在Linux下用IDE，那么我尝试将Linux的目录通过samba共享出来，在windows下用网络映射盘的方式映射出来，VScode直接去打开远程文件夹，没想到速度巨慢，没有办法顺畅的浏览代码。
那么怎么解决呢？还好我发现了VScode已经具备了各种远程功能，其中“连接到主机”功能就可以很好得劲解决这个问题。
1. 打开VSCode，点击“连接到按钮”，在上方弹出的选项中选择“连接到主机”
2. 输入IP地址回车，连接到主机后根据提示出入密码，成功后启动页面变为“Connect to”
3. 在“文件”-&gt;“打开文件夹”可以看到远程主机的目录了
4.选择相应的目录就可以打开你想要的代码
5. 这个方式其实是Remote-SSH方式，需要你的虚拟机已经安装SSH Server，如果没有安装可以使用安装命令进行安装
sudo apt-get install openssh-server
6. Enjoy VSCode
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35f537bc3e376566b6eb02fae97582f0/" rel="bookmark">
			基于微信小程序的在线学习系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主主页：一点素材
博主简介：专注Java技术领域和毕业设计项目实战、Java、微信小程序、安卓等技术开发，远程调试部署、代码讲解、文档指导、ppt制作等技术指导。
主要内容：SpringBoot、Vue、SSM、HLMT、Jsp、PHP、Nodejs、Python、小程序、安卓app、大数据等设计与开发。
🍅文末获取联系🍅
前言： 在线学习系统使用Java语言进行编码，使用Mysql创建数据表保存本系统产生的数据。系统可以提供信息显示和相应服务，其管理在线学习系统信息，查看在线学习系统信息，管理在线学习系统。
总之，在线学习系统集中管理信息，有着保密性强，效率高，存储空间大，成本低等诸多优点。它可以降低信息管理成本，实现信息管理计算机化。
系统包含技术： 开发语言：Java
框架：SpringBoot
开发软件：eclipse/myeclipse/idea
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
小程序端效果图如下： 后台管理效果图如下： 部分代码： /** * 登录 */ @IgnoreAuth @RequestMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { YonghuEntity user = yonghuService.selectOne(new EntityWrapper&lt;YonghuEntity&gt;().eq("yonghuzhanghao", username)); if(user==null || !user.getMima().equals(password)) { return R.error("账号或密码不正确"); } String token = tokenService.generateToken(user.getId(), username,"yonghu", "用户" ); return R.ok().put("token", token); } @RequestMapping("/upload") public R upload(@RequestParam("file") MultipartFile file,String type) throws Exception { if (file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35f537bc3e376566b6eb02fae97582f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7695ec27c6a17b73410dec1d69389f5/" rel="bookmark">
			Arduino 驱动 ADXL335三轴加速度计模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Arduino 驱动 ADXL335三轴加速度计模块 简介电气参数原理图接线代码实验结果 简介 ADXL335是一个小，薄，低功率，完整的三轴加速度计，具有信号调节电压输出。该产品测量加速度的最小全尺度范围为±3 g。它可以测量倾斜传感应用中重力的静态加速度，以及由运动、冲击或振动产生的动态加速度。
电气参数 供电电源3~5 V供电电流400uA通信接口模拟量输出工作温度-40°~ 85° 原理图 工作原理：
该传感器是建立在硅晶片上的多晶硅表面微加工结构。多晶硅弹簧使结构悬浮在晶片表面，并提供加速阻力。结构的偏转是用一个差动电容器来测量的，它由独立的固定板和附着在移动质量上的板组成。固定板由180°的失相方波驱动。加速度使移动质量偏转，使差分电容器失衡，导致传感器输出的振幅与加速度成正比。然后使用相敏解调技术来确定加速度的幅度和方向。
接线 ArduinoADXL335OLED5VVCCVCCGNDGNDGNDA1x-OUT-A2y-OUT-A3Z-OUT-A4-SDAA5-SCL 代码 #include &lt;Adafruit_GFX.h&gt; #include &lt;Adafruit_SSD1306.h&gt; //1306的库文件 #define OLED_RESET 13 //设置复位是13号引脚 Adafruit_SSD1306 display(OLED_RESET); const int xInput = A1; const int yInput = A2; const int zInput = A3; // initialize minimum and maximum Raw Ranges for each axis int RawMin = 0; int RawMax = 1023; // Take multiple samples to reduce noise const int sampleSize = 10; void setup() { analogReference(EXTERNAL); Serial.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7695ec27c6a17b73410dec1d69389f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/849acbbf9eed04fe1a7aefc4e2e240c9/" rel="bookmark">
			git log 用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 git log --format="%s" -n 1 在 Git 中，您可以使用 git log 命令来查看提交历史，其中包含每个提交的详细信息，包括提交消息。如果您只想提取提交信息而不是完整的 git log 输出，可以使用 git log 命令的 --format 选项来指定输出格式。
以下是如何使用 git log 提取提交信息的示例：
git log --format="%h %s" 在这个示例中，–format 选项允许您定义提交信息的格式。%h 表示缩短的提交哈希值，%s 表示提交消息的主题部分。运行上述命令将只输出提交的缩短哈希值和提交消息，以便更容易查看。
您可以根据需要自定义格式，使用不同的占位符。以下是一些常见的占位符：
%h: 提交的缩短哈希值。
%H: 提交的完整哈希值。
%s: 提交消息的主题（第一行）。
%b: 提交消息的正文部分（除去主题部分）。
%an: 作者的名称。
%ae: 作者的电子邮件地址。
%ad: 作者日期（默认格式）。
%ar: 相对日期（例如，“2 weeks ago”）。
%cn: 提交者的名称。
%ce: 提交者的电子邮件地址。
%cd: 提交日期（默认格式）。
%cr: 相对日期（例如，“2 weeks ago”）。
您可以根据需要组合这些占位符，以便自定义输出格式，以满足您的需求。例如，以下命令将以一行的方式输出提交的完整哈希值、作者名称、提交日期和主题：
git log --format="%H %an %ad %s" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3cdf8cfba7c72bf161bee62221f2af3/" rel="bookmark">
			数据库设计之ER图、三大范式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 ER图数据库三大范式 ER图 Entity Relationship，实体关系图
1、先画出所有实体，矩形圈出来
2、再画出每个实体的属性，椭圆圈出来，实体、属性之间实线连接，作为主键的属性可以画一条下划线。
3、实体之间用菱形标注联系，并标注关联关系：一对一（1,1）、一对多（1，n），多对多（m，n）。
关联关系
1对1：1个人只对应1张身份证，1张身份证也只对应1个人，2个都是1对11对多，1个用户可以拥有多个订单，1个订单只能属于1个用户，1个1对多、1个1对1多对多：1种商品可以属于多个订单，1个订单可以有多种商品，2个都是1对多 数据库三大范式 数据库有8种范式（Normal Form），通常只用到前3种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF），我们设计的关系数据库要满足这3种范式。
第一范式
1NF是对属性的原子性约束，要求属性具有原子性，不可再分解。 第二范式
2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性。表中的每一条记录都要是可区分的，表中必须要有一个unique字段作为主键。第二范式建立在第一范式的基础上，满足第二范式必须要先满足第一范式。 第三范式
3NF是对字段冗余性的约束，要求属性不能有依赖传递（只依赖于主键，不依赖于主键之外的其它属性），简单来说就是要求没有冗余字段。第三范式建立在第二范式的基础上，满足第三范式需要先满足第二范式。范式、冗余的取舍：有时为了提高效率，可以适当违反第三范式，冗余部分字段以减少多表查询，用空间换时间。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/631a3c1610c0209dcd069c9710f34301/" rel="bookmark">
			读懂Java中的各种锁，看这一篇就足够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码版本：JDK 8
前言
Java 中提供了种类丰富的锁，每种锁因有不同的特性在不同的场景能够展现出较高的性能，本文在概念的基础上结合源码 + 使用场景进行举例，让读者对 Java 中的锁有更加深刻的认识，Java 中按照是否包含某一特性来定义锁，下面是本文中介绍的锁的分类图：
乐观锁 &amp; 悲观锁
乐观锁和悲观锁是一种广义上的概念，体现了线程对互斥资源进行同步的两种不同的态度，在 Java 和数据中都有实际的运用。
概念
对一个互斥资源的同步操作，悲观锁认为自己访问时，一定有其它线程来修改，因此在访问互斥资源时悲观锁会先加锁；而乐观锁认为自己在访问时不会有其它线程来修改，访问时不加锁，而是在更新数据时去判断有无被其他线程修改，若没被修改则写入成功，若被其他线程修改则进行重试或报错。
适应场景
由上面我们可以看出，乐观锁适用于读操作多的场景，而悲观锁适用于写操作多的场景。
源码分析
我们常见的synchronized、ReentrantLock 都属于悲观锁，而AtomicInteger.incrementAndGet 则属于乐观锁。
// ----------------- 悲观锁 -------------------------
synchronized (MUTEX) {
// 同步代码块
}
ReentrantLock lock = new ReentrantLock();
lock.lock();
// 同步代码块
lock.unlock();
// ----------------- 乐观锁 -------------------------
AtomicInteger atomicInteger = new AtomicInteger(0);
atomicInteger.incrementAndGet();
悲观锁的实现方式很直观，先进行加锁，然后访问互斥资源，最后释放锁；那么乐观锁时如何实现的呢？我们通过介绍乐观锁主要的实现方式 CAS 来为大家解惑。
这里简单给大家回顾一下 CAS 。
CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的同步。
CAS算法涉及到三个操作数：当前内存值 V、原始值 A、要写入的新值 B。
当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/631a3c1610c0209dcd069c9710f34301/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a72ce4094085d0a72e1548e3464943/" rel="bookmark">
			GEE批量下载Sentinel2数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GEE批量下载数据 Google Earth Engine https://earthengine.google.com网站批量下载数据，需要有谷歌账号和科学上网
界面功能 导入研究区边界 1.学会导入roi的矢量文件，在【Assets】下选择【New】，导入shp文件
2.在弹出的界面可以选择自己的文件进行上传，除了在gee上的新建的数据集文件名需要修改之外，其他保持默认即可，最后点击【Upload】上传
3.创建好之后就可以去copy别人的代码进行批量下载了，有两个数据可以需要自己手动导入，网上的教程有时没讲这部分，通过【Import】导入roi文件和数据集。其中，roi就是刚刚的矢量文件，在旁边的目录中有，点击之后在弹出的界面找到【Import】就可以导入了；数据集在上面的搜索栏中可以找到，比如下载Sentinel-2 L2A数据，就可以直接搜索“Sentinel”，点击搜索，之后找到对应的数据集，点击之后找到【Import】就可以导入
4.在导入这两个之后，就会再代码部分最上面出现如下三行（这三行不算代码，代码行数的计数从这三行之后开始），点击可以将”table”和“imageCollection”直接改名，因此在网上的一些代码中出现了未定义变量的报错，可能就是这两个错误；也可以通过在之后通过定义新变量来指代这两个，如下所示，这样名称就不用改了
var roi = table; var s2_collection = imageCollection; 数据下载 以哨兵数据批量下载为例（无云掩膜）
var roi = table; function filterImageCollection(collection) { // 日期 var startDate = '2021-01-01'; var endDate = '2021-06-30'; var filteredCollection = collection.filterDate(startDate, endDate); filteredCollection = filteredCollection.filterBounds(roi); // 云量 filteredCollection = filteredCollection.filter(ee.Filter.rangeContains("CLOUDY_PIXEL_PERCENTAGE", 0, 30)); return filteredCollection; } var s2_collection = ee.ImageCollection('COPERNICUS/S2_SR'); var filteredCollection = filterImageCollection(s2_collection); // 获取影像列表 var imageList = filteredCollection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5a72ce4094085d0a72e1548e3464943/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e22783929b74b40254e33a5d3ab43115/" rel="bookmark">
			安装vscode以及vue必备插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装vscode以及vue必备插件 安装vscode 1：进入下载地址： vscode下载地址
2：点击下载： 3：开始安装：（一直下一步即可） 安装插件 1：安装《Auto Close Tag》插件： 自动补全html 标签 2：安装《Auto Rename Tag》插件： 修改 html 标签，自动帮你完成尾部闭合标签的同步修改 3：安装《Path Intellisense》插件： 智能路径提示，可以在你输入文件路径时智能提示 4：安装《Open in Browser》插件： 这个插件能让你从 vscode 打开 html 文件，并且可以自由选择用哪个浏览器打开 5：安装《Live Server》插件： 在 vscode 中就可以直接启动一个本地服务，并且能监听文件变化自动刷新网页 6：安装《Visual Studio IntelliCode》插件： 微软推出的一款代码智能提示插件，和别的插件不同的是，采用的是 AI 技术，吸收了 github 上成千上万的优秀代码，还会结合你日常的编码习惯不断学习进化 7：安装《Vetur》插件： vue 开发必备插件，vue 文件支持，语法高亮、智能提示 8：安装《One Dark Pro》插件： 好看 vscode 的主题 9：安装《Chinese （Simplified）Language Pack for Visual Studio Code》插件： 中文插件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa594a2620e7f862fdd7783e46c75ef8/" rel="bookmark">
			基于单片机的智能扫地机设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收藏和点赞，您的关注是我创作的动力
文章目录 概要 一、方案设计二、电路设计与理论分析2.1 硬件设计总体概要2.2 电源电路设计总控制电路的设计总电路设计 三、PCB板的设计与制作四、 结论五、 文章目录 概要 本文主要设计一个简单的智能扫地机。该扫地机的核心控制元器件是stc89c52，具有编写程序简单，成本普遍较低，功能较多，效率特别高等优点，因此在市场上得到很大的应用。除此之外，该扫地机能够自动避开障碍物、自动利用风机进行吸尘功能。该文介绍了扫地机系统的整体制作过程，它主要由单片机主控电路、单片机最小系统电路、红外光电避障电路、按键启动停止电路以及电机驱动电路组成。通过利用Altium Designer集成电路设计软件，进行原理图以及电路板的设计。其次通过KEIL编程软件为单片机输送程序，来控制整个扫地机的逻辑。
关键字：智能吸尘机；壁障；stc89c52单片机；L298N
一、方案设计 1.3.1 扫地机器人功能
（1）自动吸尘
（2）自动识别障碍
（3）自动转弯
1.3.2 功能参考
（1）电池供电：12V
（2）稳压输出：5v
二、电路设计与理论分析 2.1 硬件设计总体概要 将单片机最小系统电路组，按键启动停止电路，红外光电避障电路，直流无刷电机电路，风扇吸尘电路以及下载端电路围绕着stc89c52组合成一个系统，总框架如下2.1所示。
图2.1硬件系统总框图
2.2 电源电路设计 所有电子产品中，电源的起着关键的作用，如同一座房子的根据，只有电源稳定才能为后续提供更多功能作保证，输出的纹波趋向平滑则性能才能良好工作。该智能吸尘机人采用L298N电机驱动模块中的内置的L7805CV稳压芯片来获得稳定的5V电压.通过L298N和L7805CV主控芯片和稳压芯片结合，充分减小因电源不稳定的干扰，提高整体驱动电路的稳定。
L7805CV具备众多的高质量性能：相关抵偿的元器件可以省略不接；在内部设置了限流庇护的电路，它可以避免负载短路而导致损坏元器件；在内部还集成了功耗限制电路，可以阻拦损坏输出启动的晶体管。L7805CV可以输出4.75-5.25V的电压，静止状态的电流大约在4.2-8mA,最大的输出电流约在1.5A，纹波抑止比大概在78dB。其采用TO-220的封装形式，如下图2.2所示，从左到右分别为引脚1是输入端，引脚2是接地端，引脚3是输出端。
总控制电路的设计 ①　VCC,EA/Vpp的引脚端口，联通5V电源；
②　P32，P33控制启动停止按键；
③　P16、P17分别控制左右红外避障探头；
④　P30RXD，P31TXD为下载程序引脚；
⑤　P10、P11、P12、控制电机A驱动引脚ENA，AIN1和AIN2，P13、P14、P15、控制电机B驱动引脚BIN1,BIN2和ENB；
⑥　VSS即，接地引脚GND；
⑦　P20为吸尘小风扇控制信号；
⑧　第十八和第十九号引脚为晶振连接端口
⑨　第九号脚位为按键复位连接端口
总电路设计 总共分为七大模块L298N电机驱动模块，两个红外避障模块，复位电路模块，晶振电路模块，下载端口模块，启动停止按键模块，风扇吸尘模块。如下图2.5总控制电路图所示。
图2.5总控制电路
三、PCB板的设计与制作 Altium Designer拥有许多好用的功能，包含了原理图，PCB，3D仿真PCB，输出word文档等功能。它不仅拥有许多原器件库，还能够自己建立属于自己的原器件库，大大提高了电路设计的效率与质量。下面介绍以下主要元器件封装及整个PCB绘制过程。
1)STC89C52的DIP-40封装
首先建立一个原器件库并保存，可以利用工具选项中的器件导向，然后选择DIP的模式，输入单片机有引脚横向之间的距离为15.24毫米左右，列向之间的距离为2.54毫米左右;焊盘直径为15.24毫米左右以及2.54毫米左右，过孔的直径为33mil,采取的层为Multi-layer,线的宽度为8mil。这是一种快捷绘制封装的方法，不过一般适用于市面上比较典型的封装
四、 结论 便采用PCB的形式节省了众多电线。焊接过程中需要注意的是虚焊的问题，一个元器件未连接都可能导致失败。就这样，焊接过程中多注意，多加小心问题也边轻易可以解决。单片机中程序的编写尤为重要，开始自己对于C语言特别惧怕，于是去查看一些网络教程，渐渐地明白了一个单片机中程序所包含基本上都有头文件，端口声明，函数声明，子函数，主函数等。逐渐了解后开始查阅相关扫地机的程序，然后自己尝试着编写。开始编写的一塌糊涂，各种小问题不断，不过经过一段时间的学习不断地调试，逐渐有了清晰的思路。虽然有了清晰的思路，不过真正运行起来又是一大问题，编写过程中细节特别主要，输入法中英文不能混淆，冒号不能忘记，语句结构不能用错等各种细节，把这些都做好，最终便能解决各种问题。在硬件和程序都解决情况下，并不意味着就结束了，还有整个扫地机调试的过程。在运行过程中又会发现各种问题，比如避障能力弱，于是又去寻找解决方案，调整感应器位置，在不同环境测试。还有一个比较严重的问题是吸尘能力弱，也是当初选择小风机未能预测它的吸尘能力。整个产品设计之初到结束都是一个挑战，不断碰见问题，不断地去解决，让自己在各方面都有了一定的提升，明白一个产品的诞生不是这么容易的，想要做好一个产品，需要不断尝试，不断改进
五、 文章目录 目 录
1、概述 1
1.1 国内产品研究背景 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa594a2620e7f862fdd7783e46c75ef8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d988570020000f0bb9f4498ca2b03dae/" rel="bookmark">
			跨域获取 Headers 中的 Content-Disposition
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在默认情况下，浏览器限制了对跨域请求响应的访问权限，阻止了读取敏感的响应头信息（例如 Content-Disposition）。这是由于跨域请求的安全策略所决定的。
如果你想在跨域请求中获取到 Content-Disposition 头信息，需要在服务器端进行一些配置。
首先，确保服务器返回的响应中包含 Access-Control-Expose-Headers 头，并将 Content-Disposition 添加到其中。这样浏览器才会在跨域请求成功后暴露该头信息。
在服务器端配置响应头，示例代码（使用 Express 框架）：
app.use(function(req, res, next) { res.header('Access-Control-Expose-Headers', 'Content-Disposition'); next(); }); 以上代码将在每个响应头中添加 Access-Control-Expose-Headers: Content-Disposition，使浏览器能够获取到 Content-Disposition 头信息。
在客户端使用 Axios 发起跨域请求时，确保你在 response 对象中可以从 headers 属性中获取到 Content-Disposition 头信息。
axios.get('http://example.com/api', { crossDomain: true }) .then(response =&gt; { const contentDisposition = response.headers['content-disposition']; // 在这里可以访问到 Content-Disposition 头信息 }) .catch(error =&gt; { // 处理错误 }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caf9f09b3e028e1f70f9e2c270010713/" rel="bookmark">
			【ICCV 2023】EfficientViT: Multi-Scale Linear Attention for High-Resolution Dense Prediction
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EfficientViT: Multi-Scale Linear Attention for High-Resolution Dense Prediction, ICCV 2023 论文：https://arxiv.org/abs/2205.14756
代码：https://github.com/mit-han-lab/efficientvit
解读：MIT Han Lab | EfficientViT：高分辨率低计算视觉识别的增强线性注意力 - 知乎 (zhihu.com)
EfficientViT | 边缘设备上实时语义分割-腾讯云开发者社区-腾讯云 (tencent.com)
摘要 高分辨率密集预测得到越来越多的应用，如计算摄影、自动驾驶等。然而，巨大的计算成本使得在硬件设备上部署最先进的高分辨率密集预报模型变得困难。本文提出EfficientViT，一个新的高分辨率视觉模型家族，具有新颖的多尺度线性特性。不同于现有的高分辨率密集预测模型依赖于大量的softmax注意力、硬件低效的大内核卷积或复杂的拓扑结构来获得良好的性能，多尺度线性注意力只需轻量级和硬件高效的操作就可以实现全局感受野和多尺度学习（高分辨率密集预测的两个理想特征）。
EfficientViT在移动CPU、边缘GPU和云GPU的各种硬件平台上，与以前sota相比，提供了显著的性能提升。在不损失Cityscapes性能的情况下，EfficientViT分别比SegFormer和SegNeXt提供高达13.9倍和6.2倍的GPU延迟降低。对于超分辨率，EfficientViT比Restormer提供高达6.4倍的加速，同时在PSNR中提供0.11dB的增益。对于SegmentAnything，EfficientViT提供与ViT-Huge类似的零样本图像分割质量，GPU吞吐量高84倍。
引言 高分辨率密集预测是计算机视觉中的一项基本任务，在现实世界中有着广泛的应用，包括自动驾驶、医学图像处理、计算摄影等。因此，在硬件设备上部署最先进的（SOTA）高分辨率密集预测模型可以使许多用例受益。然而，SOTA高分辨率密集预测模型所需的计算成本与硬件设备的有限资源之间存在很大差距。它使得在实际应用中使用这些模型变得不切实际。特别是，高分辨率密集预测模型需要高分辨率图像和强大的上下文信息提取能力才能很好地工作。 因此，直接从图像分类移植高效的模型架构不适合高分辨率密集预测。
本文介绍了EfficientViT，一种用于高效高分辨率密集预测的新的视觉变换器模型家族。EfficientViT的核心是一个新的多尺度线性注意力模块，它能够通过硬件高效操作实现全局感受野和多尺度学习。
因此，本文模块的设计原则是能够实现这两个关键功能，同时避免硬件低效操作。具体而言，用轻量级ReLU线性注意力代替低效的softmax注意力，以获得全局感受野。ReLU线性注意利用矩阵乘法的关联性，可以在保持函数性的同时，将计算复杂度从二次降到线性。此外，它避免了像softmax这样的硬件低效操作，使其更适合硬件部署。
然而，由于缺乏局部信息提取和多个量表学习能力。因此，用卷积增强ReLU线性注意力，并引入多尺度线性注意力模块来解决ReLU线性注意的容量限制。具体来说，用小内核卷积聚合门附近的令牌，以生成多尺度令牌。对多尺度标记进行ReLU线性关注，以将全局感知场与多尺度学习相结合。还将深度卷积插入到FFN层中，以进一步提高局部特征提取能力。
在两个高分辨率密集预测任务上广泛评估了EfficientViT：语义分割和超分辨率。与先前的SOTA高分辨率密集预测模型相比，EfficientViT性能提升。更重要的是，EfficientViT不涉及硬件低效操作，因此其FLOP减少可以很容易地转化为硬件设备上的延迟减少。
还将EfficientViT应用于Segment Anything，这是一种新兴的可提示分割任务，允许将零样本转移到许多视觉任务。EfficientViT在A100 GPU上比ViT-Huge实现了84倍的加速，同时保持了相当的零样本图像分割质量。
贡献总结如下：
介绍了一种新的多尺度线性注意力模块，用于高效的高分辨率密集预测。它实现了全局感受野和多尺度学习，同时在硬件上保持了良好的效率。据论文所知，该工作首次证明了线性注意力对高分辨率密集预测的有效性。设计了EfficientViT，这是一个新的高分辨率视觉模型家族，基于所提出的多尺度线性注意力模块。与之前的SOTA模型相比，论文的模型在不同硬件平台（移动CPU、边缘GPU和云GPU）上的语义分割、超分辨率、Segment Anything和ImageNet分类方面显著加快。 方法 多尺度线性注意力 Enable Global Receptive Field with ReLU Linear Attention NLP中的线性注意力为softmax注意力，
本文使用ReLU作为核函数，对硬件更友好。公式（1）可改写为
线性注意力有两个关键优点：
允许利用矩阵乘法的关联属性来将计算复杂度从二次降低到线性而不改变功能。在注意力模块中不涉及 softmax。 Softmax 在硬件上效率非常低，避免它可以减少延迟。 Softmax注意力与ReLU线性注意力比较。和softmax注意不同，由于缺乏非线性相似函数，ReLU线性注意不能产生尖锐的注意分布。它的局部信息提取能力弱于softmax注意力。 Softmax注意和ReLU线性注意的延迟比较。ReLU线性注意力比具有类似计算的softmax注意力快3.3-4.5倍，这要归功于消除了对硬件不友好的操作（softmax）。延迟是在高通Snapdragon 855 CPU上测量的，该CPU具有TensorFlow Lite、批量大小1和fp32。
Address ReLU Linear Attention’s Limitations 尽管ReLU线性注意力在计算复杂度和硬件稳定性方面优于softmax注意力，但ReLU线性注意有局限性。图3展示了softmax注意力和ReLU线性注意力的注意力图。由于缺乏非线性相似函数，ReLU线性注意力无法生成集中注意力图，使其在捕捉局部信息方面较弱。
为了减轻它的局限性，建议用卷积来增强ReLU的线性注意力。具体来说，在每个FFN层中插入一个深度卷积。构建块的概述如图2（左）所示，其中ReLU线性注意力捕获上下文信息，FFN+DWConv捕获局部信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caf9f09b3e028e1f70f9e2c270010713/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/374a695436d14a3c39687801363532f1/" rel="bookmark">
			ffmpeg的基本功能介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 之前对ffmpeg有一个模糊的印象，后来经过一些项目对ffmpeg有了深入的认识，这里总结下。
最开始对ffmpeg的印象是可以对视频进行一些处理操作，但是做哪些操作又不是很清楚，知其然不知其所以然。下面对于ffmpeg的功能进行一个总结，希望对大家有个帮助。
ffmpeg可以实现对视频文件、网络摄像头的音视频流拉取（拉流功能）ffmpeg可以实现桌面截图功能/或者读取摄像头（libavdevice）ffmpeg可以实现推流功能ffmpeg可以实现对音视频编码格式、封装格式的转换（libavcodec、libavformat）ffmpeg可以实现图片像素格式转换，图像缩放等操作，对应的模块（libswscale）ffmpeg支持滤镜功能（libavfilter）ffmpeg提供了多媒体应用常用的简化编程的工具，如随机数生成器、数据结构、数学函数等（libavutil） ffmpeg编译完成后会生成3个可执行文件
ffmeg：实现了音视频的编解码功能ffprobe：实现了多媒体流的分析ffserver：实现了流媒体服务器功能（ffmpeg4.0后的版本已经没有ffserver，流媒体服务器可以选择其它开源流媒体服务器）ffprobe：实现了多媒体体播放器的功能 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab238b6eb3c63751fdb32df17d99b777/" rel="bookmark">
			某网课m3u8视频流hls.js算法逆向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 需要了解m3u8基础知识，可在下方链接阅读笔者之前的文章。
https://www.52pojie.cn/thread-1686788-1-1.html
初步分析 目标站点：aHR0cHM6Ly93d3cuOTJneXcuY29tL3Nob3J0VmlkZW8vYWxidW0vMjA1P3ZpZGVvSWQ9NDY4NQ==
打开浏览器，按下F12开发者工具，然后粘贴链接进入页面。
在上方点击 Network 菜单栏（在这里可以监视浏览器与服务器之间的网络请求和响应。你可以查看请求的详细信息、响应的状态码和内容，并分析网络性能。）
接下来就是分析 m3u8和key 的链接
观察m3u8，发现是标准格式，并没有经过加密处理
接着观察key，发现是16字节
可事实真的如此吗？打开 M3U8批量下载器 试试。
M3U8批量下载器 V1.4.8 0508【5月8日更新】
https://www.52pojie.cn/thread-1631141-1-1.html
粘贴m3u8链接，点击【添加】按钮
再点击【全部开始】按钮
提示
文件解码失败，请检查key是否正确 此时有2种可能，我们依次分析
第1种可能：key链接，存在次数限制，在浏览器打开了首次，然后第2次访问，不给数据或者是假数据（key）
在连续多次请求，与浏览器首次响应，对比发现是一致的字节，那么就不是这个原因。
第2种可能：key密钥的响应值被加密了，市面上别的平台通常是返回32位或者更长的字节。
此时就得js逆向了，分析 hls.js 文件，这里面有做特殊处理，播放前会解密出正确的密钥。
找到 001.ts，菜单栏点击 Initiator ，这是 js函数调用堆栈，然后进去下断点，动态调试分析。
这个过程比较繁琐，需要了解 Hls.js 的加载过程。
当然我是这么分析出的，教大家一招简单的技巧。
我们换一种思路，通过关键词来定位
aes-128 decryptdata.key buffer 观察到这行有点可疑，可能是个解密函数，又将key和iv传递进去。
let _ = C.softwareDecrypt(n, R.key.buffer, R.iv.buffer); 点击行号，到这里下断，然后F5重新加载网页。
观察发现，n是ts的文件数据，R里面有我们想要的key和iv数据。
key [101, 77, 103, 113, 121, 121, 112, 108, 55, 84, 71, 79, 55, 99, 65, 98] iv [55, 108, 98, 109, 52, 103, 113, 57, 106, 114, 108, 66, 50, 86, 67, 49] 主要是key，在python中转成hex十六进制，看看。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab238b6eb3c63751fdb32df17d99b777/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd921bf4dc2554f245679d9772401f19/" rel="bookmark">
			掌握layui.xmSelect：打造高效、美观的下拉选择框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在软件开发领域，下拉选择框是一种常见的用户界面元素，用于让用户从多个选项中进行选择。layui.xmSelect是一款功能强大、易于使用的下拉选择框插件，可以帮助开发者轻松实现这一功能。本文将详细介绍如何使用layui.xmSelect，并提供相关实例，以帮助开发者更好地理解和使用这一插件。
一、安装和引入layui.xmSelect
首先，确保已经安装了layui框架。如果还没有安装，可以参考官方文档进行安装：https://www.layui.com/doc/start/quick.html
在HTML文件中引入layui.css和layui.js文件：
&lt;link rel="stylesheet" href="path/to/layui/css/layui.css"&gt; &lt;script src="path/to/layui/layui.js"&gt;&lt;/script&gt; 初始化layui： layui.use(['form'], function(){ var form = layui.form; }); 二、创建下拉选择框
在HTML文件中创建一个&lt;select&gt;标签，并为其添加一个唯一的ID： &lt;select id="demo"&gt;&lt;/select&gt; 使用JavaScript初始化layui.xmSelect： layui.use(['form', 'xmSelect'], function(){ var form = layui.form; var xmSelect = layui.xmSelect; // 初始化下拉选择框 xmSelect.render({ elem: '#demo' //绑定元素 ,data: [{title: '选项1', value: '1'}, {title: '选项2', value: '2'}, {title: '选项3', value: '3'}] //数据源 ,selected: [] //默认选中项 }); }); 三、自定义下拉选择框
可以通过修改xmSelect.render()方法中的配置对象来自定义下拉选择框的外观和行为。例如，可以设置占位符、禁用状态等： xmSelect.render({ elem: '#demo' ,data: [{title: '选项1', value: '1'}, {title: '选项2', value: '2'}, {title: '选项3', value: '3'}] ,selected: [] ,placeholder: '请选择' //设置占位符 ,disabled: false //设置禁用状态 }); 四、监听下拉选择框的变化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd921bf4dc2554f245679d9772401f19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0bded872c3960ae6ae33612b9296c6c/" rel="bookmark">
			RAID系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Raid
实现raid的方式
raid0
raid1
raid5
raid1+0
Raid 将多块磁盘组合成一个磁盘阵列组，来提高硬盘的性能。
组合的方式不同，raid的名字也不同,性能也不同
raid 0
raid 1
raid 5
raid 1+0
实现raid的方式 1.硬raid {阵列卡统一管理}
2.软raid（通过软件的方式实现）
raid0 组成：大于等于两块磁盘 1块没有实际效果但可以做raido0
优点：
提供读写
利用率 100%
缺点：
无备份的功能
服务器上识别磁盘
1.直通模式，不做raid，主板直接识别
2.raid模式 需要raid卡
raid1 组成：2n
优点：
拥有冗余功能
提升读的性能
缺点：
降低了写的性能
利用率低 只有50%
raid5 组成：3＋
优点：
有冗余，但是只能坏一块盘
提高读的性能，降低写的性能
利用率：n-1
raid1+0 组成2n（n&gt;=2） 4块
优点:
提高读写
冗余，只能坏 不同raid里的磁盘 坏两块盘有三分之一的几率掉数据
缺点：
利用率低 50%
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c2775e4d44ae3fb19cdda43db9ac18/" rel="bookmark">
			解决VS中文编译时出现：常量中有换行符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误如下 首先确定文件编码格式已经是utf-8了，然后在有中文的情况的下，编译时会报错，真的很恶心
tabWidget.addTab(widget, tr("材料库")); tabWidget.addTab(widget1, tr("B")); 解决方案 通过在项目里设置编译选项: /utf-8
项目-&gt;右键属性-&gt;C/C++ -&gt; 命令行，在下方输入框添加 /utf-8，就会在编译时采用utf-8编码来编译
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bad4e4f80eaf89eea2efcd127391b1b/" rel="bookmark">
			Linux内核SPI子系统驱动框架详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 spi子系统整体架构图
2 SPI控制器驱动和SPI设备驱动软件架构
3 SPI控制器驱动的整理流程
4 SPI发送数据过程
5 SPI设备驱动
6 spidev万能驱动
7 费曼学习法：我录制了一个SPI子系统驱动框架讲解视频
8 OLED驱动程序
8.1写代码
8.1.1 font.h
8.1.2 oled_drv.c
8.1.3 spi_oled.c
8.1.4 spi_oled.h
8.1.5 Makfile
8.1.6 修改设备树文件
8.2 实验
8.2.1 编译设备树
8.2.2 编译驱动程序和测试程序
8.2.3 测试
8.3 报错：insmod: ERROR: could not insert module oled_drv.ko: Invalid parameters
9 使用spidev万能驱动操作OLED
9.1 font.h
9.2 spi_oled.h
9.3 spi_oled.c
10 参考文献：
1 spi子系统整体架构图 如上图所示是我画的一个spi子系统的整体架构图主要分为用户空间，内核空间 和硬件三大部分，
用户空间就是我们的应用程序，内核空间又分为设备驱动层、SPI核心层和SPI控制器驱动层，其中设备驱动层就是具体的SPI设备驱动，这个一般是由普通的驱动工程师负责，然后SPI核心层是内核自带的代码，SPI核心层起到一个承上启下的作用，往下给控制器驱动层提供控制器驱动的注册函数，往上提供标准的SPI收发API以及设备注册函数。然后是SPI控制器驱动层，SPI控制器驱动一般是由芯片原厂编写。硬件空间就是具体的硬件， 当我们在应用程序中调用比如write函数的时候，其实调用的就是spi设备驱动注册进去的file_operations结构体里面的write函数，也就是图中的spidev_write函数，这个spidev_write函数进一步调用的就是spi_write函数，这个spi_write函数就就是在SPI核心层定义的，然后spi_write函数进一步调用的就是SPI控制器驱动程序中的spi_sync函数。
2 SPI控制器驱动和SPI设备驱动软件架构 如上图所示是spi控制器和spi设备的软件架构图，左边是SPI控制器驱动软件结构，右边是SPI设备的软件结构，
SPI控制器驱动，SPI控制器驱动和SPI控制器设备是挂载到platform_bus_type上的，其中SPI控制器是platform_driver驱动，SPI控制器设备是platform_device类型结构体，内核中的of_platform_default_populate(NULL, NULL, parent);函数会解析设备树中的SPI控制器节点，转换成platform_device结构体，然后会将platform_device增加到内核的设备链表中，platform_driver结构体会被注册到内核的驱动链表中，当增加设备或者驱动的时候，会调用platform_bus_type中的match函数，根据compatible属性进行匹配，当匹配成功后，会调用驱动里面的spi_imx_probe函数，在probe函数里面分配一个spi_master结构体，设置spi_master结构体，调用spi_register_master(spi_master_get(master));注册结构体，然后具体在spi_register_master(spi_master_get(master));函数里面首先会用device_add函数将master-&gt;dev注册到内核中，然后还会调用of_register_spi_devices(master);这个函数增加spi_device的，增加spi_device的函数是在register master的时候做的。因为像I2C SPI节点下面的子节点都是由I2C SPI来管理的。然后调用spi_master_initialize_queue(master);，这个函数内部是设置了一些传送函数，后面会重点分析spi_master_initialize_queue(master);。SPI设备驱动，首先of_register_spi_devices(struct spi_master *master)函数会解析设备树中的SPI下面的子节点，将子节点转换为spi_device，然后增加到spi_bus_type，另外spi_driver驱动也会被注册到spi_bus_type中，当增加设备或者驱动时，会调用spi_bus_type中的match函数，根据compatible属性进行匹配，匹配成功后probe函数就会被调用，然后再probe函数里面会分配、设置、注册一个file_operation结构体，在这个结构体中就包含了具体的设备的读写函数。 3 SPI控制器驱动的整理流程 如上图所示是SPI控制器的驱动，当增加设备或者驱动时，会调用platform_bus_type中match函数，然后根据compatible属性进行匹配，匹配成功之后probe函数被调用，然后再probe函数中其实主要就是做了分配、设置、注册一个结构体，具体来看在probe函数中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bad4e4f80eaf89eea2efcd127391b1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/758d0cf76fbe0822a5ec7cbbdce74832/" rel="bookmark">
			Java的字节流InputStream（字节输入流），OutputStream（字节输出流）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IO 流简介 IO 即 Input/Output，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。
Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。
InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 字节流 InputStream（字节输入流） InputStream用于从源头（通常是文件）读取数据（字节信息）到内存中，java.io.InputStream抽象类是所有字节输入流的父类。 InputStream 常用方法：
read()：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 -1 ，表示文件结束。read(byte b[ ]) : 从输入流中读取一些字节存储到数组 b 中。如果数组 b 的长度为零，则不读取。如果没有可用字节读取，返回 -1。如果有可用字节读取，则最多读取的字节数最多等于 b.length ， 返回读取的字节数。这个方法等价于 read(b, 0, b.length)。read(byte b[], int off, int len)：在read(byte b[ ]) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字节数）。skip(long n)：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。available()：返回输入流中可以读取的字节数。close()：关闭输入流释放相关的系统资源。 从 Java 9 开始，InputStream 新增加了多个实用的方法：
readAllBytes()：读取输入流中的所有字节，返回字节数组。readNBytes(byte[] b, int off, int len)：阻塞直到读取 len 个字节。transferTo(OutputStream out)：将所有字节从一个输入流传递到一个输出流。 FileInputStream 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/758d0cf76fbe0822a5ec7cbbdce74832/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/75/">«</a>
	<span class="pagination__item pagination__item--current">76/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/77/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>