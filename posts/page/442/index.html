<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/741b29f78b40c88dddf9d19afc5de75e/" rel="bookmark">
			有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解题思路：需要一个可以改变的新的数组，用来表示插入之后的结果。新的数组的长度是原来数组的长度加一，然后如果插入的数据比原来数组最大的数还要大，就直接插入到末尾就好。如果是在中间，就把前面的数字复制到新的数组中，后面依次往后挪一位
代码；public class Main1 {
public static void main(String[] args) {
// TODO Auto-generated method stub
int[] a={1,8,12,17,48,99};
Scanner input = new Scanner(System.in);
int n = input.nextInt();
insert(a, n);
}
public static void insert(int [] a,int n){
int[] b = new int[a.length+1];
if(n&gt;a[a.length-1]){
for(int i=0;i&lt;a.length;i++){
b[i]=a[i];
}
b[a.length]=n;
}
else{
for(int i=0;i&lt;a.length;i++){
if(n&lt;a[i]){
for(int j=0;j&lt;i;j++){
b[j]=a[j];
}
b[i]=n;
for(int j=i;j&lt;b.length-1;j++){
b[j+1]=a[j];
}
break;
}
}
}
System.out.println("插入之后的结果是：");
// for(int k=0;k&lt;b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/741b29f78b40c88dddf9d19afc5de75e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bb9cb4f895268be7ae4f71f8571a954/" rel="bookmark">
			order by 排序值相同结果不唯一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		order by 排序值相同结果不唯一，可能导致分页查询的重复或者导致分页查询查询条数不同结果显示发生变化，
数据库order by排序不唯一，会导致最终的数据排序是不是稳定的 ，建议在 order by 最后，增加 PK 列或 ROWID，rowid还能增加查询效率！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca8025f129b02bdfe8223a9538c72547/" rel="bookmark">
			基于GLC的地表覆盖分类技术流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 GLC_Info软件简介 GLC_Info是一款基于C#+ArcEngine平台设计实现的遥感影像分类软件，其核心为GLC分类器，该分类器采用了当下最为流行的C5.0决策树分类算法为模型，并进行了算法改进，使分类器更加适用于遥感影像分类。依托该分类器，软件可以独立实现基于像元的遥感影像分类，在获得易康（eCognition）或者ENVI EX分割结果的基础上，软件可以实现对分割结果的全自动分类，突破了以往分类树或分类规则的构建要利用分类者的生态学和遥感先验知识的确定，不仅提高了效率，而且大大降低了对操作员的要求。此外该软件还提供了一些辅助分类功能和统计分析工具。
图1 GLC_Info主界面
2 数据选择 WorldView-2卫星于2009年10月由美国Digital Global公司发射，可提供0.46m的全色影像和8个波段（包括海岸带波段、蓝色、绿色、红色、黄色、红边波段及两个近红外波段）的1.8m多光谱影像，与其他影像相比，WorldView-2的空间分辨率更高，多光谱波段更丰富，为用户提供进行精确变化变化检测和制图的能力。
表1 WorldView-2数据介绍
波段
波长范围(nm)
应用价值
C海岸波段
400-450
海水侵蚀，浅海岸海底测量、含水量植物检测
B蓝波段
450-510
含水地物监测、矿产监测、大气监测
G绿波段
510-580
植被检测
Y黄波段
585-625
叶绿素不同监测不同植被，二氧化碳监测、大气监测、真彩色增强
R红波段
630-690
植被长势监测、植被检测
RE红边波段
705-745
植被健康度监测、含水量监测、植被种类分辨
近红外1
770-895
植被区别、土地利用类别
近红外2
860-1040
细化土地利用、植被细类辨别
3 解译标志 结合待分类地区影像特征建立解译标志。
4 方法流程 4.1 单景地表覆盖分类 采用eCognition）或者ENVI EX完成影像分割和分割结果的特征计算，然后利用GLC_Info完成样本采集并将分割结果输入，完成对分割结果的分类。具体流程见图2。
图2单景地表覆盖分类流程图
4.2 流程说明及操作步骤 (1) 基于易康（eCognition）的影像分割与特征计算
Ø 影像分割
易康采用了多尺度分割算法，这种分割方法是根据特定规则将影像分割成异质性最小的独立区域的过程，综合遥感影像的光谱特征和形状特征，计算影像中每个波段的光谱异质性与形状异质性的综合特征值，然后根据各个波段所占的权重，计算影像所有波段的加权值，当分割出对象的光谱和形状综合加权值小于某个指定的阈值时，进行重复迭代运算，直到所有分割对象的综合加权值大于指定阈值即完成影像的多尺度分割操作。
图3 多尺度分割界面
在多尺度分割中需要定义一些参数，包括尺度参数、层的权重、均质标准（颜色和形状）。其中尺度参数是一个抽象的词语，它确定生成的影像对象最大允许的异质性，通过修改尺度参数，可以改变结果中的影像对象尺寸，高的尺度参数产生的影像对象大，低的尺度参数产生的影像对象小。在满足必要的精细的条件下尽可能使用大尺度。
在影像分割中不同层的权重和均质标准会导致不同的分割效果，建议分割时将全色波段的权重设为2，其它波段权重设为1，形状均值标准设为0.1，颜色均值标准设为0.5。
分割结果如图：
图4 易康分割结果
Ø 特征计算
将分割结果导出，同时计算分割后每个多边形的多种属性值作为决策树分类中的预测变量。
图5 分割结果输出窗口
图6 特征选择窗口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca8025f129b02bdfe8223a9538c72547/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32cd36247ad204b9e981fc799ab81061/" rel="bookmark">
			（一）c/c&#43;&#43;、python混合编程——c/c&#43;&#43;调用python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.环境： win10、VS2017、Anaconda3(python3.x) 2.步骤： 2.1.在vs2017新建一个空文件test，新建文件test.c
#include &lt;Python.h&gt; int main(int argc, char *argv[]) { Py_SetProgramName(argv[0]); Py_Initialize(); PyRun_SimpleString("print('Hello Python!')\n"); Py_Finalize(); while (1); return 0; } 2.2.添加工程的头文件目录：工程—属性—配置属性—c/c++—常规—附加包含目录：加上头文件Python.h存放目录 2.3添加文件引用的lib静态库路径：工程—属性—配置属性—链接器—常规—附加库目录：加上lib文件存放目录 2.4然后添加工程引用的lib文件名：工程—属性—配置属性—链接器—输入—附加依赖项：加上lib文件名python36.lib(debug模式是python36_d.lib，通过复制python36.lib得到) 3.运行 4.命令行的方式运行（首先安装vs2017，在程序中打开vs的命令行工具） 运行命令：
cl test.c -I C:\APP\Anaconda3\include C:\APP\Anaconda3\libs\python36.lib 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b576b4477027ece23590c7237c009626/" rel="bookmark">
			PS如何设置打印尺寸显示图像和实际纸张大小一致
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://jingyan.baidu.com/article/5bbb5a1b3d3c1413eba179fd.html
大家都知道在PS中视图菜单下面有个打印尺寸，也就是缩放工具中的打印尺寸显示（还有100%、200%和按屏幕大小缩放），按说这个显示比例应该和我们实际打印到纸张上的尺寸大小是一样的，这样我们就能很方便的看到实际打印出来的图像的大小了。可是我发现，打印尺寸显示和实际纸张尺寸不一样，比较小，那么这是怎么回事哪，应该是哪儿设置错误吧。其实显示不一致的根本原因在于，Photoshop中确实把所有像素按照300像素/英寸的打印分辨率显示了，但是还有一个屏幕分辨率，因为显示器的屏幕分辨率和Photoshop中默认的屏幕分辨率不一造成的。那么如何设置Photoshop中显示的屏幕分辨率和显示器显示的屏幕分辨率一致哪。怎样才能让Photoshop中打印尺寸显示和实际纸张上打印的一样大小呀。（说明一点：打印机分辨率一般是300dpi，所以Photoshop中打印分辨率默认设置为300像素/英寸），个人理解方法，仅供参考。
工具/原料 Photoshop软件
首先找到显示器硬件的实际屏幕分辨率 先要知道你自己的显示器的型号，搜索查看一下改型号的显示器最大分辨率是多少，我的这个最大分辨率是1440X900
把屏幕分辨率设置成本显示器最大支持的分辨率（在桌面上右键单击，选择屏幕分辨率设置）
再看一下显示器的物理可视尺寸是多少，看这个是我现在用的显示器的实际可是面积的长度和宽度。
把可视长度和宽度转换成英寸，一英寸=25.4mm
再计算屏幕实际屏幕分辨率（DPI），用1440除以显示器的物理可视长度，用900除以显示器的物理可视宽度（数值越精确显示打印尺寸和实际尺寸越接近，小数点后面多留几位哦）
在Photoshop首选项单位与标尺中设置屏幕分辨率为89.59435626，点击确定。（打印分辨率和打印机分辨率一致，都是300哦）
新建一个3厘米 X 3厘米，300像素/英寸，也就是和打印一个分辨率的打印文档。
选择打印尺寸显示
图像预览按照实际打印出来的尺寸显示了，可以用尺子量一下，和实际尺寸一致。（误差还是有的，不过很小哦。）
END 注意事项 打印机的打印分辨率是300DPI，Photoshop中打印分辨率也设置为300像素/英寸。Photoshop中屏幕分辨率要和显示器分辨率一致，所以要计算自己显示器的实际屏幕分辨率。
个人理解方法，仅供参考。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84845945b1ede0021f6175be9cd49549/" rel="bookmark">
			关于libStagefright系列漏洞分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度安全攻防实验室 · 2015/07/29 18:10
0x00 前言 文章对应着CVE-2015-{1538,1539,3824,3826,3827,3828,3829}7个CVE，具体映射关系目前不明。此次安全漏洞号称影响“95%”安卓手机的安全。通过跟进此次漏洞的攻击面来看，这种说法毫不夸张，外界报道的关于一个彩信就直接打下机器的说法也是可信的。但这也仅仅是众多攻击面中的一条而已。
0x01 攻击面分析 libStagefright默认会被mediaserver使用，也就是说，如果恶意的视频文件有机会被mediaserver处理到，该漏洞就有机会触发，举例：
如文件管理app，如果视频被存放在sdcard，那么打开文件管理app，下拉列表到露出视频，就会触发缩略图解析，漏洞触发。
图库app，点击本地图片会出现缩略图，如果视频在sdcard，或者download目录，这时候也会触发。
微信同样受到影响。通过微信发送的视频，点击也会导致media server崩溃。此外，收到的视频即使用户不点击，后面在微信中发送图片时，也会造成前面gallery,文件管理器同样的效果，也会触发缩略图过程并溢出。
在最新版的Chrome43版中打开一个video链接（mp4），无需点击自动触发。
开机同样是一个触发点，mediaprovider会扫描sd卡里的所有文件，并且尝试去解析，恩开机自启动
media framework的架构如下：基本上采用了android的media框架来开发的程序都会受到影响。
看到这里，想说的是，外界所谓的那些，关闭彩信功能保平安也就寻求个心理安慰吧。从根源上看大部分（有一个例外）都和整数计算的上溢/下溢相关，因为这个问题，间接导致了后续的内存破坏等相关的安全问题。
1.1. 代码分析 1.1.1. No1 heap 读越界 #!c 1. status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) { 2. uint32_t hdr[2]; 3. uint64_t chunk_size = ntohl(hdr[0]); 4. uint32_t chunk_type = ntohl(hdr[1]); 5. 6. switch(chunk_type) { 复制代码 只有下面几种chunk_type才会触发分支parse3GPPMetaData：
#!c 1. case FOURCC('t', 'i', 't', 'l'): 2. case FOURCC('p', 'e', 'r', 'f'): 3. case FOURCC('a', 'u', 't', 'h'): 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84845945b1ede0021f6175be9cd49549/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10998ee8bc183345fafa3fa663c23cdd/" rel="bookmark">
			MYSQL基础常见常用语句200条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库 # 查看所有的数据库 SHOW DATABASES ; # 创建一个数据库 CREATE DATABASE k; # 删除一个数据库 DROP DATABASE k; # 使用这个数据库 USE k; 表 # 查看所有的表 SHOW TABLES ; # 创建一个表 CREATE TABLE n(id INT, name VARCHAR(10)); CREATE TABLE m(id INT, name VARCHAR(10), PRIMARY KEY (id), FOREIGN KEY (id) REFERENCES n(id), UNIQUE (name)); CREATE TABLE m(id INT, name VARCHAR(10)); # 直接将查询结果导入或复制到新创建的表 CREATE TABLE n SELECT * FROM m; # 新创建的表与一个存在的表的数据结构类似 CREATE TABLE m LIKE n; # 创建一个临时表 # 临时表将在你连接MySQL期间存在。当断开连接时，MySQL将自动删除表并释放所用的空间。也可手动删除。 CREATE TEMPORARY TABLE l(id INT, name VARCHAR(10)); # 直接将查询结果导入或复制到新创建的临时表 CREATE TEMPORARY TABLE tt SELECT * FROM n; # 删除一个存在表 DROP TABLE IF EXISTS m; # 更改存在表的名称 ALTER TABLE n RENAME m; RENAME TABLE n TO m; # 查看表的结构(以下五条语句效果相同） DESC n; # 因为简单，所以建议使用 DESCRIBE n; SHOW COLUMNS IN n; SHOW COLUMNS FROM n; EXPLAIN n; # 查看表的创建语句 SHOW CREATE TABLE n; 表的结构 # 添加字段 ALTER TABLE n ADD age VARCHAR(2) ; # 删除字段 ALTER TABLE n DROP age; # 更改字段属性和属性 ALTER TABLE n CHANGE age a INT; # 只更改字段属性 ALTER TABLE n MODIFY age VARCHAR(7) ; 表的数据 # 增加数据 INSERT INTO n VALUES (1, 'tom', '23'), (2, 'john', '22'); INSERT INTO n SELECT * FROM n; # 把数据复制一遍重新插入 # 删除数据 DELETE FROM n WHERE id = 2; # 更改数据 UPDATE n SET name = 'tom' WHERE id = 2; # 数据查找 SELECT * FROM n WHERE name LIKE '%h%'; # 数据排序(反序) SELECT * FROM n ORDER BY name, id DESC ; 键 # 添加主键 ALTER TABLE n ADD PRIMARY KEY (id); ALTER TABLE n ADD CONSTRAINT pk_n PRIMARY KEY (id); # 主键只有一个，所以定义键名似乎也没有什么用 # 删除主键 ALTER TABLE n DROP PRIMARY KEY ; # 添加外键 ALTER TABLE m ADD FOREIGN KEY (id) REFERENCES n(id); # 自动生成键名m_ibfk_1 ALTER TABLE m ADD CONSTRAINT fk_id FOREIGN KEY (id) REFERENCES n(id); # 使用定义的键名fk_id # 删除外键 ALTER TABLE m DROP FOREIGN KEY `fk_id`; # 修改外键 ALTER TABLE m DROP FOREIGN KEY `fk_id`, ADD CONSTRAINT fk_id2 FOREIGN KEY (id) REFERENCES n(id); # 删除之后从新建 # 添加唯一键 ALTER TABLE n ADD UNIQUE (name); ALTER TABLE n ADD UNIQUE u_name (name); ALTER TABLE n ADD UNIQUE INDEX u_name (name); ALTER TABLE n ADD CONSTRAINT u_name UNIQUE (name); CREATE UNIQUE INDEX u_name ON n(name); # 添加索引 ALTER TABLE n ADD INDEX (age); ALTER TABLE n ADD INDEX i_age (age); CREATE INDEX i_age ON n(age); # 删除索引或唯一键 DROP INDEX u_name ON n; DROP INDEX i_age ON n; 视图 # 创建视图 CREATE VIEW v AS SELECT id, name FROM n; CREATE VIEW v(id, name) AS SELECT id, name FROM n; # 查看视图(与表操作类似) SELECT * FROM v; DESC v; # 查看创建视图语句 SHOW CREATE VIEW v; # 更改视图 CREATE OR REPLACE VIEW v AS SELECT name, age FROM n; ALTER VIEW v AS SELECT name FROM n ; # 删除视图 DROP VIEW IF EXISTS v; 联接 # 内联接 SELECT * FROM m INNER JOIN n ON m.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10998ee8bc183345fafa3fa663c23cdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a59b3122638f11b01658de59733a70d4/" rel="bookmark">
			蜂鸟速递-无人机快递智能系统 QT编写(含视频)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大三工作室项目，和几位小伙伴一起做出来的。我负责客户端与服务器这块，其他小伙伴负责无人机安卓端、用户安卓端，项目实现了类似于滴滴打车的效果，写篇博客记录一下。
系统流程如下：用户下单，系统分配无人机飞至指定地点降落，用户将物品放入储存箱确认后无人机飞向目的地，无人机到达目的地后有两种确认方式。
方式1：二维码确认，将1m*1m大小的二维码铺在地上，无人机在目的地上空进行圆周运动，当相机识别到二维码则进行机身调整，降落在二维码上。
方法2：人脸识别，调用Face++接口，无人机相机向下45°，用户站在相机面前确认收货，相机将照片进行对比，确认是收货人则降落。
用户取完货物后再APP上面确认收货，无人机自行飞回蜂巢。
整个项目耗费4个月，制作比较粗糙。。
下面列举项目大致架构：
所有数据经过服务器进行处理并转发，使用TCP进行数据传输。例如用户端提交订单，服务器搜寻空闲无人机并将订单信息转发给无人机控制端。服务器与管理端使用QT进行编写，数据库使用sql server 2012。
由于能拿的出手的就是管理端和用户端，后台服务器与无人机控制端由于没什么图片，功能也就是数据的转发与执行，所以粗略的讲讲。。
管理端：
管理端用来管理并实时监控无人机动向，比如说禁飞区、仓库管理、无人机站点管理、空中廊道管理。
空中廊道：空中廊道的设想也就是空中高速公路，避开人群密集区、军事区等敏感区域，规划出一条合适的线路供无人进飞行。
禁飞区：禁飞区顾名思义就是不允许无人机飞行的区域，当有临时活动可以立刻规划出禁飞区，防止无人机闯入造成财产损失。
无人机：这个就是整个项目的核心了，监控端可以实时监控无人机飞行数据，本来想可以实时观看无人机视角，通过相机拍摄视频然后传输给管理端，但是时间不足就没有实现，比较遗憾。。
无人机站点：没有做美化，确实比较丑。。无人机站点就是派发无人机与接收无人机，无人机站点可以认为是小型机场吧。。
无人机仓库：也是丑，无人机仓库就是存放无人机的地方。。
前面是加载了高德地图进行可视化，下面就是正规的表格了。
管理端差不多就是这样，在运输货物的过程中，管理端可以监控无人机的具体位置，订单的执行情况。
用户端
用户端界面我比较满意，用户端分为登陆、下订单、查看订单等功能，废话不多说直接上图！
登陆界面，也可以输入账号然后扫脸登陆，FACE++的接口还是挺好使的，就是有时会抽风。。。
登陆进去之后就是这样，左上角的存脸用来保存你个人的人脸数据，用作登陆与收货。
这个是用户管理，左上方头像的小姐姐就是做这APP的，看起来好像磨皮、美颜，恕我眼拙。。
在地图上选择出发地与目的地，填写订单内容就可以提交订单了！
订单提交成功，就可以进入这个画面，确认放货、确认收货前面提过。右上角有个笑脸，点击它可以进入收货阶段的人脸识别，识别成功无人机降落。
基本到这里整个项目介绍完毕，现在讲一讲关键的实现方案。
要做到飞机实时动画:动画怎么做到的我不知道，我们通过定时器1秒钟一次查询飞机数据，然后用户端与管理端通过数据进行画面的更新。
飞机的型号：大疆3 ADVANCD 大疆提供一整套的SDK调用来控制飞机的飞行，SDK感觉BUG多，社区人特别少遇到过很多坑，有的问题要去国外论坛才能找到。。
不同平台如何通信：自己定好数据格式然后照着通信。。。
如果飞行过程中存储盒打开怎么办：我们专门找一个理电小女生入坑，让她弄了个板子控制盒子开关。当无人机降落收取快递时，后台会发送一条短信给盒子，盒子接收并打开，然后确认放货就又发一条让其关闭。存储与系统时分离的，比较死板。。
以下是视频演示。。 项目演示视频
快递情景模拟
项目演示完整视频
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/541bbf668dd74b35e27107e5c8caa0d5/" rel="bookmark">
			if __name__ = &#39;__main__&#39;，python 主程序入口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 通俗的理解name == ‘main‘：假如你叫小明.py，在朋友眼中，你是小明(name == ‘小明’)；在你自己眼中，你是你自己(name == ‘main‘)。
if name == ‘main‘的意思是：当.py文件被直接运行时，if name == ‘main‘之下的代码块将被运行；当.py文件以模块形式被导入时，if name == ‘main‘之下的代码块不被运行。
程序入口 对于很多编程语言来说，程序都必须要有一个入口，比如C，C++，以及完全面向对象的编程语言Java，C#等。如果你接触过这些语言，对于程序入口这个概念应该很好理解，C，C++都需要有一个main函数作为程序的入口，也就是程序的运行会从main函数开始。同样，Java，C#必须要有一个包含Main方法的主类，作为程序入口。
而Python则不同，它属于脚本语言，不像编译型语言那样先将程序编译成二进制再运行，而是动态的逐行解释运行。也就是从脚本第一行开始运行，没有统一的入口。
一个Python源码文件（.py）除了可以被直接运行外，还可以作为模块（也就是库），被其他.py文件导入。不管是直接运行还是被导入，.py文件的最顶层代码都会被运行（Python用缩进来区分代码层次），而当一个.py文件作为模块被导入时，我们可能不希望一部分代码被运行。
2.1 一个.py文件被其他.py文件引用
假设我们有一个const.py文件，内容如下：
PI = 3.14 def main(): print("PI:", PI) main() # 运行结果：PI: 3.14 1 2 3 4 5 6 7 8 现在，我们写一个用于计算圆面积的area.py文件，area.py文件需要用到const.py文件中的PI变量。从const.py中，我们把PI变量导入area.py：
from const import PI def calc_round_area(radius): return PI * (radius ** 2) def main(): print("round area: ", calc_round_area(2)) main() ''' 运行结果： PI: 3.14 round area: 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/541bbf668dd74b35e27107e5c8caa0d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea41c3723abd156766b39ae92383abad/" rel="bookmark">
			webpack4——SplitChunksPlugin使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 前面写了一篇有关webpack4的不完全升级指南以及在webpack3.x迁移的时候遇到的问题，有兴许可以看一下。
0. 参数介绍 先对参数有一个大概的认识，虽然撸了很多遍官方的更新文档，但是还是去参看了一下新的wbepack源码，下面是各种参数及含义：
chunks: 表示显示块的范围，有三个可选值：initial(初始块)、async(按需加载块)、all(全部块)，默认为all;minSize: 表示在压缩前的最小模块大小，默认为0；minChunks: 表示被引用次数，默认为1；maxAsyncRequests: 最大的按需(异步)加载次数，默认为1；maxInitialRequests: 最大的初始化加载次数，默认为1；name: 拆分出来块的名字(Chunk Names)，默认由块名和hash值自动生成；cacheGroups: 缓存组。 对于缓存组是一个对象，处了可以有上面的chunks、minSize、minChunks、maxAsyncRequests、maxInitialRequests、name外，还有其他的一些参数：
如果不在缓存组中重新赋值，缓存组默认继承上面的选项，但是还有一些参数是必须在缓存组进行配置的。
priority: 表示缓存的优先级；test: 缓存组的规则，表示符合条件的的放入当前缓存组，值可以是function、boolean、string、RegExp，默认为空；reuseExistingChunk: 表示可以使用已经存在的块，即如果满足条件的块已经存在就使用已有的，不再创建一个新的块。 1. 基本使用 首先，在新版本的webpack会默认对代码进行拆分，拆分的规则是：
模块被重复引用或者来自node_modules中的模块在压缩前最小为30kb在按需加载时，请求数量小于等于5在初始化加载时，请求数量小于等于3 小于30kb的模块不值得再单独发送一次请求，在很小的模块的前提下，相比与多次打包，减少请求次数成本要低。
当然也可以不使用默认的配置，比如这样：
new webpack.optimize.SplitChunksPlugin({ chunks: "all", minSize: 20000, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, name: true )} 上面的代码就表示，在所有代码中，引用模块大小最小为20kb，引用次数最少为1次，按需加载最大请求次数为5，初始化加载最大请求次数为3的所有模块就行拆分到一个单独的代码块中，name表示代码的名字，设置为true则表示根据模块和缓存组秘钥自动生成。
2. 使用缓存组(Cache Groups) 如果想继续细分代码，可以使用缓存组(Cache Groups)。同样的，缓存组也有默认的配置；缓存组默认将node_modules中的模块拆分带一个叫做vendors的代码块中，将最少重复引用两次的模块放入default中。
这是一段官方里面的代码：
splitChunks: { chunks: "async", minSize: 30000, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, name: true, cacheGroups: { default: { minChunks: 2, priority: -20 reuseExistingChunk: true, }, vendors: { test: /[\\/]node_modules[\\/]/, priority: -10 } } } 上面是缓存组的默认配置，可以通过default:false禁用默认的缓存组，然后就可以自定义缓存组，将初始化加载时被重复引用的模块进行拆分，就像这样：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea41c3723abd156766b39ae92383abad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e6de2824999b9be8d72e6fb983f1f1d/" rel="bookmark">
			git创建新分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建本地分支 git branch 分支名，例如：git branch 2.0.1.20120806 注： 2.0.1.20120806是分支名称，可以随便定义。 2.切换本地分支 git checkout 分支名，例如从master切换到分支：git checkout 2.0.1.20120806 3.远程分支就是本地分支push到服务器上。比如master就是一个最典型的远程分支（默认）。 git push origin 2.0.1.20120806 4.远程分支和本地分支需要区分好，所以，在从服务器上拉取特定分支的时候，需要指定远程分支的名字。 git checkout --track origin/ 2.0.1.20120806 注意该命令由于带有--track参数，所以要求git1.6.4以上！ 这样git会自动切换到分支。 5.提交分支数据到远程服务器 git push origin &lt;local_branch_name&gt;:&lt;remote_branch_name&gt; 例如： git push origin 2.0.1.20120806 : 2.0.1.20120806 一般当前如果不在该分支时，使用这种方式提交。如果当前在 2.0.1.20120806 分支下，也可以直接提交 git push 6.删除远程分支 git push origin :develop -----------------------------------------------------------
1,从已有的分支创建新的分支(如从master分支),创建一个dev分支
Git checkout -b dev
2,创建完可以查看一下,分支已经切换到dev
git branch
* dev master 3,提交该分支到远程仓库
git push origin dev
4,测试从远程获取dev
git pull origin dev
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e6de2824999b9be8d72e6fb983f1f1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e33b8d0b662b5da0092d0c4d933e8108/" rel="bookmark">
			keepalived精编问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		keepalived+nginx实现高可用的调度，vip能自动漂移，vip在主备机器也能正常piing，但是vip网页无法访问
主：10.100.109.2 vip：10.100.109.4
备：10.100.109.3 一下是keepalived的配置文件，keepalived.conf
备keepalived.conf:
nginx访问页面：
10.100.109.2 10.100.109.3都能正常访问，但是10.100.109.4无法访问
网卡做了绑定，绑定到bond0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5be1b22178fb6700c1a21cd470309961/" rel="bookmark">
			通过SQL语句直接实现Excel与数据库的导入导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入/导出Excel 1.--从Excel文件中,导入数据到SQL数据库中,很简单,直接用下面的语句: /*===================================================================*/ --如果接受数据导入的表已经存在
insert into 表 select * from OPENROWSET ( ' MICROSOFT.JET.OLEDB.4.0 ' , ' Excel 5.0;HDR=YES;DATABASE=c: est.xls ' ,sheet1$) --如果导入数据并生成表 select * into 表 from OPENROWSET ( ' MICROSOFT.JET.OLEDB.4.0 ' , ' Excel 5.0;HDR=YES;DATABASE=c: est.xls ' ,sheet1$) /*===================================================================*/
2.--从SQL数据库中,导出数据到Excel: --如果从SQL数据库中,导出数据到Excel,如果Excel文件已经存在,而且已经按照要接收的数据创建好表头,就可以简单的用:
insert into OPENROWSET ( ' MICROSOFT.JET.OLEDB.4.0 ' , ' Excel 5.0;HDR=YES;DATABASE=c: est.xls ' ,sheet1$) select * from 表 --如果Excel文件不存在,也可以用BCP来导成类Excel的文件,注意大小写: --导出表的情况
EXEC master..xp_cmdshell ' bcp 数据库名.dbo.表名 out "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5be1b22178fb6700c1a21cd470309961/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5969b3466e7389b55911d6ac295ba68/" rel="bookmark">
			级联MobileNet-V2实现CelebA人脸关键点检测（附训练源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一 、引言1.1为什么是级联？1.2为什么是MobileNet-V2？ 二、 级联MobileNet-V2之人脸关键点检测2.0 修改caffe2.1 整体框架及思路2.2 原始数据处理 0_raw_data2.3 level_1训练2.4 level_2训练2.5 级联展示[ 3_demo ] 此博客详细介绍级联MobileNet-V2实现人脸关键点检测。 模型：MobileNet-V2 数据：CelebA( http://mmlab.ie.cuhk.edu.hk/projects/CelebA.html ) 框架：Caffe 系统：ubuntu16.04 GPU：GTX1080 实验结果： 单模型不到1M，仅956KB，GTX1080上仅6ms，简单部署即可在移动端进行实时检测。 本实验代码： https://github.com/tensor-yu/cascaded_mobilenet-v2 (仅想实现demo，请直接跳到2.0修改caffe，然后进入2.5级联展示) 一 、引言 1.1为什么是级联？ 近几年人脸关键点检测的方法大都采用从粗到精（coarse-to-fine）的思想，在CNN上体现为级联。级联之所以好，是因为后一级的输入是经过上一级“筛选”后的区域，即达到一个取其精华去其糟粕的过程。比如，在一张大图里要看清一个人的左眼珠，第一步应该是在图中找到这个人，第二步看他的眼睛，第三步才是看到他的左眼珠.
不熟悉级联CNN的，可阅读几篇经典的级联CNN的论文
1. Deep Convolutional Network Cascade for Facial Point Detection 2.Extensive Facial Landmark Localization with Coarse-to-Fine Convolutional Network Cascade 3.Facial Landmark Detection by Deep Multi-task Learning 4.Facial Landmark Detection with Tweaked Convolutional Neural Networks 5. Joint Face Detection and Alignment Using Multitask Cascaded Convolutional Networks 也可查看博客了解：深度学习人脸关键点检测方法----综述
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5969b3466e7389b55911d6ac295ba68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94642a5e6242a13e87a18992e4094673/" rel="bookmark">
			软件构造 Lab1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大二软件构造第一次实验
本人本次实验操作系统：macOS high Sierra 10.13.3
任务一：MagicSquare
对于本任务，主要需要实现两个方法，一个是isLegalMagicSquare方法，一个是generateMagicSquare方法。
首先，是要实现isLegalMagicSquare方法，该方法是根据一个String fileName判断路径所指的文件内容重的数据能否构成一个幻方。若能，则返回true，否则返回false。
当然，这个方法要能够正确处理几种异常情况。包括所读入的数据根本不足以构成一个方阵、传入数据不是整数、数据之间不是用'\t'字符来分割的等等。对于这些异常情况，要简单输出错误信息，继而方法返回false。
对于这个任务，我的想法比较简单：首先读入一行数据，根据这行数据就可以确定这个Square的列数(col)和一行数的和(sum)。对于一个幻方来说，这两个数字是唯一确定的，也就是或只要根据第一行数据确定了这两个数值，就能据此判断接下来输入的内容能否保证这组数据构成一个幻方。
于是在每次读入一行数据之后，都可以对这一行的sum值(这里记为temp)进行判断。若temp等于sum，则继续读入下一行，并把本行数据存入二维数组中；若temp不等于sum，则直接输出错误信息：这不是一个方阵，进而方法返回false即可。此方法同样适用于判断这一行的col值和已计算的col值是否相等。同样地，当一行数据用其余分隔符来分割时，由于预设的每一行数据是根据'\t'来进行分割的，故这样的读入的数据行会使得数据的个数不相等，从而也会输出错误信息并返回false。若读入的数据不是一个整数，则在程序中会抛出一个异常，通过捕获这个异常来实现输出错误信息并将方法返回false即可。
其次，是要实现generateMagicSquare方法，本方法也是一个返回值为boolean的函数。在实验手册上，已经给出了这个方法的主要代码，要添加的功能就是判断输入的参数n是否合法。
首先，说明一下这个方法的功能：构造一个n阶幻方矩阵(n为传入参数)，其中n一定是一个奇数，同时一定要是一个大于零的整数。故根据其功能，要先对传入的参数进行判断，若传入的n是非正数或是一个偶数，则输出错误信息，并且使方法返回false。其次，要把生成的幻方矩阵数据写入到一个指定文件中。
对于这个任务，我遇到的问题在于文件读写上。因为之前并没有太多地接触到Java程序从文件中读写数据，正好利用这次实验来学习一下。
通过Bing一些网上论坛、翻看一些Java编程资料。基本掌握了Java程序读写文件的方法。对于Java这种典型的OOP编程语言，一切内容都是围绕着类与对象展开的。所以有了OOP的编程思想，学习文件读写的这些内容也不是很难。
任务二：Turtle绘图
Turtle是MIT最初开发的一种图形化编程工具，用来解决太空航天方面的一些问题。本任务就是实现一些简单的Turtle绘图基本方法。
获取实验包文件之后，观察比较这几个Java文件，基本对整个任务有了一定的认识。实验已经提供了TurtleGUI文件、Turtle工具类等文件，要实现的也只是几个方法。而且其中最重要的forward和turn方法已经实现了。根据要求，要完成一些类似于绘制正方形、正多边形等方法。
根据中学知识，很容易完成其中的根据正多边形的边数来求其内角度数、根据多边形内角度数求出其边数(分别是angle = (sides - 2) * 180° / sides 和 sides = 360° / (180° - angle) )。
然后是完成一个方法，使其计算出当前顶点到指定顶点，Turtle应偏转的角度。这个方法利用到了中学学过的向量部分的知识，通过将向量知识与三角函数结合起来，即可计算出应当偏转的角度。
这个任务中需要注意的内容就是如何用库函数求解偏转角度以及计算结果的精度舍入问题。在Java的Math库中，提供了这样的一个方法：atan2方法。该方法通过传入一个向量，即可计算出其对应的角的大小。这个方法的返回值，实际上是直角坐标系y轴正方向和向量所成角的大小，而且返回值为对应角的弧度值。因而要对这个角有一个正确的认识，并将其单位进行一个简单的转换。在这个任务中，我曾因为不会导入JUnit进行测试而被困住，最后在同学帮助下成功解决了这个问题。
最终，所有方法均完成了预期功能要求，并且一些特定的方法也通过了JUnit的测试。
、
任务三：Social Network
根据实验手册可知，这个任务用到了简单的图论方面的知识。相对而言，这个任务就显得十分简单了。
对于这个任务，主要实现构建一个图(存储于一个邻接矩阵中)并计算出图中顶点之间的最短路径。下面说一下每个方法的设计与实现。
addVertex(Person)方法：实现向图中添加顶点的功能。在这个方法中，将Graph的内部Person类总数更新，从而实现确定遍历的二维数组的大小。
addEdge(Person, Person)方法：功能：为传入的两个顶点(Person类对象)之间构建一条单向边。我设计的方法中，默认传入的两个Person类对象已经通过addVertex(Person)方法加入到图中。其结果就是让顶点之间的邻接矩阵值置为1。
addVertex(Person, Person)方法：功能：为传入的连个顶点(Person类对象)之间构架一条单向边。这个方法是从实验手册中读到的，根据我的理解， 所重载的addVertex方法实现了与前两者不同的功能。本方法首先会判断传入的Person类对象是否已经存在于图中，若存在，则直接在传入的顶点之间搭建一条边，若不存在，则先在图中创建出这个顶点，再在传入的顶点之间构建一条单向边。
就三者功能而言，可以这样理解：addVertex(Person, Person) == addVertex(Person) + addEdge(Person, Person)。
此外，我还设计了一个generate的方法，该方法的功能是将邻接矩阵转换为最短路径矩阵。通过实验手册的代码，我理解为每次搭建了一条边之后，都会将这个邻接矩阵更新为最短路径矩阵，因而会在每次调用addEdge方法(addVertex(Person, Person)方法)时调用generate方法。从而实现了运行中程序结果的更新。
-------------------分割线开始-------------------Date:2018.3.8
/* 经过一番讨论，发现...上述的addVertex(Person, Person)方法，不存在。
* 也就是说，实验手册中，这个功能其实指的就是addEdge方法，于是也就不存在不经过addVertex方法直接调用addEdge方法的情况。
* 也就是说，上述对于addVertex(Person, Person)的讨论，是无意义的... (不妨作为实验外的一个小玩意儿)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94642a5e6242a13e87a18992e4094673/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbe9b20edc8731757c0ef648efa97273/" rel="bookmark">
			【Python学习】Numpy函数repeat和tile用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		numpy数组用扩展函数repeat和tile，但是数组不能进行动态扩展，所以在调用上述函数进行扩展的时候，系统会重新分配新的空间进行存储扩展后的数据。
repeat函数
功能：可以对数组中的元素进行连续复制 用法:
numpy.repeat(a, repeats, axis=None)a.repeat(repeats, axis=None) 其中a为数组，repeats表示重复的次数，axis表示数组的维度
1.Test1
Input:
import numpy as np arr = np.arange(5) arr_ = arr.repeat(3) print('arr: ', arr) print('arr_: ', arr_) Output:
arr: [0 1 2 3 4] arr_: [0 0 0 1 1 1 2 2 2 3 3 3 4 4 4] repeat函数不会修改原有的numpy数组，重复运算大致上可以这么理解，遍历原先数组的每一个元素，然后进行逐个元素的重复。
2.Test2
Input:
import numpy as np arr = np.array([[10,20,30], [40,50,60]]) print(arr.shape) arr1 = arr.repeat([3,2], axis=0) arr2 = arr.repeat([3,2,1] ,axis=1) print(arr1) print(arr2) Output:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbe9b20edc8731757c0ef648efa97273/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c604736524bdffebbb3e1399686b344f/" rel="bookmark">
			IndexError: index 6 is out of bounds for axis 1 with size 6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误：
Using TensorFlow backend.
Traceback (most recent call last):
File "E:/Python3Doc/APIdocs/kerasMy/to-cat.py", line 7, in &lt;module&gt;
y_train_use = np_utils.to_categorical(y_train, num_classes=nb_classes)
File "C:\Program Files\Anaconda3\lib\site-packages\keras\utils\np_utils.py", line 31, in to_categorical
categorical[np.arange(n), y] = 1
IndexError: index 6 is out of bounds for axis 1 with size 6
# coding: utf-8 from keras.utils import np_utils nb_classes = 6 y_train = [1, 3, 5, 2, 6, 4, 1] y_train_use = np_utils.to_categorical(y_train, num_classes=nb_classes) print(y_train_use) 修改：nb_classes=7，即类标号要从0开始！！！！！！！！！！
如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c604736524bdffebbb3e1399686b344f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/446aa5dc816c79380a89d6e8d131284e/" rel="bookmark">
			Swift_UI：（五）、UIWebView、WKWebView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import UIKit
import WebKit
class ViewController: UIViewController,UIWebViewDelegate {
var webKit: WKWebView?
override func viewDidLoad() {
super.viewDidLoad()
// 实例化UIWebView
let webView = UIWebView(frame:self.view.bounds)
// 创建URL：
let url = URL(string:"https://www.baidu.com")
// 创建请求
let request = URLRequest(url:url!)
webView.loadRequest(request)
webView.delegate = self
// self.view.addSubview(webView)
// 创建配置
let webConfig = WKWebViewConfiguration()
// 创建wkwebview
webKit = WKWebView(frame:self.view.bounds,configuration:webConfig)
self.view.addSubview(webKit!)
let newUrl = URL(string:"https://www.baidu.com")
let newRequest = URLRequest(url:newUrl!)
webKit!.load(newRequest)
// 偏好设置
let perfrence = WKPreferences()
// 最小字号设置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/446aa5dc816c79380a89d6e8d131284e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f418bb0bc3af05e63fa2250ed7932b76/" rel="bookmark">
			CentOS7.2 安装L2TP/IPSec 服务端/客户端 和部分心得 ( libreswan&#43;xl2tpd ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整体基于CentOS7.2实现。方案为“使用预共享密钥的L2TP/IPSec”
下载地址：http://download.csdn.net/download/gogoytgo/10266198 参考资料：https://teddysun.com/448.html
在此一键安装脚本上，删除了部分功能： 1）不配置防火墙，因为我们的业务不需要也不希望通过VPN直接转接到其他网络，而是通过程序实现。 2）仅保留CentOS相关的配置修改。
1.基本安装组件方法 ： yum -y install ppp libreswan rpm -i xl2tpd-1.3.8-2.el7.x86_64.rpm 同时，建议不使用原装的libreswan, 新版本的兼容性更好，如果是CentOS7，可以直接使用我的编译结果 否则请按下面的方法自行编译
yum install nss-devel libevent-devel unbound unbound-devel systemd-devel libcap-ng-devel make base USE_DNSSEC=false #如果想要直接安装，make install make install USE_DNSSEC=false #如果想要移植，make tarpkg make tarpkg USE_DNSSEC=false 2.关于Android设备的兼容问题 ： 在测试时，发现华为手机无法接入，而使用IOS/PC/其他安卓手机均能接入。 查询了网络资料，看到了是Android 6.0和早期Linux内核的程序，使用了一个坏的SHA2-256算法。
有很多资料会建议你（上面的脚本也是）在/etc/ipsec.conf 中增加
sha2-truncbug=yes 这句话的意思就是让你使用坏的SHA2-256算法。那么，当正确的SHA2-256（例如华为手机）来连接时，就挂了。因此需要根据实际情况取舍。 IOS和WIN不使用SHA2-256，所以没影响。
2.关于如果把VPN服务端部署在局域网内，通过端口映射方式映射，Windows设备的兼容问题 ： 1）需要映射服务端端口1701到公网。 2）如果是Windows客户端，会出现拨号失败的情况。 参考微软的官方说明：https://support.microsoft.com/en-us/help/926179/how-to-configure-an-l2tp-ipsec-server-behind-a-nat-t-device-in-windows
需要设置注册表。
VISTA以上（WIN7/WIN10）
Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\PolicyAgent] "AssumeUDPEncapsulationContextOnSendRule"=dword:00000002 XP SP2以上
Windows Registry Editor Version 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f418bb0bc3af05e63fa2250ed7932b76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffefa1b4bfbcb593e191e4bda319b51b/" rel="bookmark">
			$.ajax 传到后台的参数获取不到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用ajax传参数,发现后台获取不到数据
value2={'key21':'value21','key22':'value22'}; post_data = {'key1':'value1','key2':value2}; $("#funDiv1").bind("click",function(){ $.ajax({ type : 'post', url : 'ajaxTest.do', data : post_data, dataType : 'text',//若为json,无法接受字符传返回值 success : function(data){ alert("success"); console.log(data); } }); }); key1可以获取到值,key2为空,原因是key2为json对象,后台无法解析,
后台springMVC
@ResponseBody @RequestMapping(value="/ajaxTest.do",produces="application/json;charset=utf-8",method={RequestMethod.POST,RequestMethod.GET}) public String test2(HttpServletRequest request,String key1,String key2){ System.out.println(key1); System.out.println(key2); return "test2_result"; } 解决方法:
前端把json对象转为字符串,后台再解析
JSON.stringify(value2) 后台解析,需要导包,
@ResponseBody @RequestMapping(value="/ajaxTest.do",produces="application/json;charset=utf-8",method={RequestMethod.POST,RequestMethod.GET}) public String test2(HttpServletRequest request,String key1,String key2){ System.out.println("test2"); System.out.println(key1); System.out.println(key2); try{ Map map = JSONObject.fromObject(key2); System.out.println(map.get("key21")); }catch(Exception e){ e.printStackTrace(); } return "test2_result"; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad0876ef70ea1d97e9a96c51302fa299/" rel="bookmark">
			webstorm配置node运行环境（前后端分离，node服务端，vue客户端）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、node服务端 2、vue客户端 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a21fc5fca437244c786e561f4d1e211d/" rel="bookmark">
			Win7激活工具的原理是什么?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 不同的激活方式，使用的激活工具不一样，原理也不尽相同。大体上分为如下五种激活方式，原理如下:(一)“硬刷”激活微软和PC厂商为了减轻对于操作系统的激活负荷，在品牌机实行了有别于联网激活的“SLIC 2.1激活机制”：当操作系统启动时，就会自行扫描BIOS里的公钥和标识(SLIC 2.1)，以及系统中的“OEM密钥”和“OEM证书”。如果三者完全吻合、验证一致，系统就会被识别为免激活的OEM版本。除了极其个别电脑的主板BIOS与“SLIC 2.1”不大兼容外，98%左右的电脑都能使用此法。(二)“软改”激活同“硬刷”激活。区别在于：通过运行“软改”破解工具，就会给C盘根目录注入一个随系统启动的优先加载项。这个优先加载项的作用就是：在内存中将“SLIC 2.1”与主板BIOS“映射”实施有机结合，从而像品牌机一样实现对于操作系统的“免激活”。除了极其个别电脑的主板BIOS与“SLIC 2.1”不大兼容外，98%左右的电脑都能使用此法。(三)“电话”激活微软设置“电话”激活的本意，是为那些因为硬件发生变化、重装系统不能用密钥联网激活的正版用户提供“激活ID”服务(注：首次安装系统联网激活时，会将“纪录主要硬件信息的25位字符串”发送微软记录在案)。8只要操作正确，100%成功。(四)“MAK”激活这是微软授权大客户的两种批量激活方式之一。原理非常浅显：输入密钥经由微软激活服务器验证激活系统。只要“MAK”密钥还有剩余激活次数，100%成功。(五)“KMS”激活 这是微软授权大客户的两种批量激活方式之一。大客户通过微软授权架设的“KMS”服务器，进行阶段性激活(周期为180天)。完全取决于“KMS”服务器(其实都是私设的)的“开通”和有效运行。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da30d90ef72a50b9f10a91cbaa0d9a45/" rel="bookmark">
			【Python进阶篇】python之函数的返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		返回值简介
简单介绍 print 和 return 的区别，print 仅仅是打印在控制台，而 return 则是将 return 后面的部分作为返回值作为函数的输出，可以用变量接走，继续使用该返回值做其它事。 函数需要先定义后调用，函数体中 return 语句的结果就是返回值。如果一个函数没有 reutrn 语句，其实它有一个隐含的 return 语句，返回值是 None，类型也是 'NoneType'。 return 语句的作用：结束函数调用、返回值 指定返回值与隐含返回值
函数体中 return 语句有指定返回值时返回的就是其值
函数体中没有 return 语句时，函数运行结束会隐含返回一个 None 作为返回值，类型是 NoneType，与 return 、return None 等效，都是返回 None。
指定 return 返回值函数举例：　1
2
3
4
5
6
7
8
9
10
11
12
def showplus(x):
print(x)
return x + 1
num = showplus(6)
add = num + 2
print(add)
输出结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da30d90ef72a50b9f10a91cbaa0d9a45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21073d40ab56baaf8fba4c36cefb80e3/" rel="bookmark">
			EXCEL  VBA 之录制宏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		宏的录制方法。先录制一个设置格式的宏，设置小于60分的不及格成绩用红色显示。打开学生成绩表excel文件。
2 如何开始录制？单击工具---宏---录制宏，弹出小窗口。
3 宏的名字命名为“不及格红色显示”，保存在当前工作簿确定。这样就进入录制状态。你还可以为这个宏制定快捷键，注意不要和其他快捷键冲突，也可以不设置。
4 录制过程如下：单击格式---条件格式，条件选择单元格数值，小于60，单击格式按钮，进入格式设置窗口。
单击字体标签，把颜色设为红色，确定。这样，条件格式就弄好了。
如何结束录制过程？单击工具---宏---停止录制，就结束了。注意看这张图，我们看椭圆圈里的快捷键Alt+F8，按下组合键可以快速打开宏窗口。
如何使用宏工具？选中全体学生语文的成绩，按组合键Alt+F8，选择名叫“不及格红色显示”的宏，单击执行。语文成绩，凡是不及格的全部变为红色了。你还可以在数学，英语成绩上用一下这个宏工具。即方便，又不需要重复繁琐的劳动。
使用宏要注意什么事项？除了设置格式，excel中所有的操作宏都能做，设置颜色，可以先选中目标区域，像刚才的例子可以把语数英成绩全部选中，然后执行宏命令，一次性搞定。然而有的操作，区域选择是在录制过程中，怎么办呢？
录制一个统计不及格人数的宏。如前所述，取名叫不及格人数，其他默认，确定。
开始录制宏：单击编辑栏上插入函数按钮fx，选择COUNTIF函数，确定。
录制时范围不能缺省，所以随便选取一个区域，输入区域代号，或单击折叠框选取，下一行输入&lt;60。注意，小于号，在英文状态下输入。单击确定。单击工具---宏---停止录制。
如何使用这个宏？把光标移到语文不及格人数下一个单元格。按组合键Alt+F8打开宏窗口，选择不及格人数统计，单击执行。接下来要修改参数，才能正确显示数据。
如何修改函数的参数呢？这个函数第一个参数是计算范围，第二个参数是计算条件。条件没错不要修改了。单击编辑栏第一个参数，移动鼠标选择全部语文成绩，参数随之改变，按回车键，或点fx按钮，完成操作。
结果显示，语文不及格人数20人。总结一下，录制宏要严格按规定操作。第一个例子是格式设置，不要考虑参数问题。第二个例子要调用函数，其中第一个参数不能缺省，所以随便写一个范围完成录制。使用第二个宏后要记住改范围参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d428d2297bd7181eb956cd07556fd5b/" rel="bookmark">
			bad interpreter:No such file or directory的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在编译完Fortran的一个程序之后，却用原来的调用脚本怎么也没法执行，问题如标题，最好找到这篇文章，恍然大悟。
Linux下面一个脚本死活也运行不了， 我检查了数遍，不可能有错。快Insane啦！提示：bad interpreter:No such file or directory！
上网上找了好久，总算发现原来是文件格式的问题。这个文件是我在Windows下编写的。换行的方式与Unix不一样，但是在VI下面如果不Set一下又完全看不出来。气晕过去了～～～希望不会有人跟我一样倒楣，花了好几个小时in vain!!
解决方法：
1、程序是在一个网站上看到的，我保存下来源码天空，大致修改了一下。
2、上传到linux主机运行
chmod +x back
./back
错误提示如下：
bash: ./back : bad interpreter:No such file or directory
3、错误分析：
因为操作系统是windows，我在windows下编辑的脚本，所以有可能有不可见字符。从你的脚本及报告的错误看来, 很有可能是你的脚本文件是DOS格式的, 即每一行的行尾以\r\n来标识, 其ASCII码分别是0x0D, 0x0A.
可以有很多种办法看这个文件是DOS格式的还是UNIX格式的, 还是MAC格式的。
（1）vi filename
然后用命令
:set ff?
可以看到dos或unix的字样. 如果的确是dos格式的, 那么你可以用:set ff=unix把它强制为unix格式的, 然后存盘退出. 再运行一遍看.
（2）用joe filename
如果是DOS格式的, 那么行尾会有很多绿色的^M字样出现. 你也可以用上述办法把它转为UNIX格式的.
（3） 用od -t x1 filename
如果你看到有0d 0a 这样的字符, 那么它是dos格式的, 如果只有0a而没有0d, 那么它是UNIX格式的, 同样可以用上述方法把它转为UNIX格式的.
转换不同平台的文本文件格式可以用
1. unix2dos或dos2unix这两个小程序来做. 很简单. 在djgpp中这两个程序的名字叫dtou和utod, u代表unix, d代表dos
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d428d2297bd7181eb956cd07556fd5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b6d91ba91c7d9b2e3c295daa0df335c/" rel="bookmark">
			linux修改TCP连接数（centos实测）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ulimit -n和-u可以查看linux的最大进程数和最大文件打开数。
临时方法：
为了优化linux性能，可能需要修改这个最大值。临时修改的话ulimit -n 204800就可以了，重启后失效。
永久生效的方法：
修改/etc/security/limits.conf文件
在文件末尾添加
[html] view plain copy * soft nofile 204800 * hard nofile 204800 * soft nproc 204800 * hard nproc 204800 * 代表针对所有用户 noproc 是代表最大进程数 nofile 是代表最大文件打开数 网上都是说修改这一个文件就行，但是我修改后重启服务器发现没更改过来。 后来发现，还需要修改两个文件
1、/etc/security/limits.d/90-nproc.conf文件尾添加
[html] view plain copy * soft nproc 204800 * hard nproc 204800 2、/etc/security/limits.d/def.conf文件尾添加 [html] view plain copy * soft nofile 204800 * hard nofile 204800 这两个文件的设置将会覆盖前面的设置。重启后生效 一、 文件数限制修改
(1) vi /etc/security/limits.conf 在末尾追加 * soft nofile 10240 * hard nofile 10240 (2) vi /etc/pam.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b6d91ba91c7d9b2e3c295daa0df335c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa0477ba0492d7900486a2242984d5de/" rel="bookmark">
			升级android studio3.0遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题1 场景： Error:A problem occurred configuring root project '项目名'.
&gt; Could not resolve all dependencies for configuration ':classpath'.
&gt; Timeout waiting to lock artifact cache (/Users/Skyf/.gradle/caches/modules-2). It is currently in use by another Gradle instance.
Owner PID: 10747
Our PID: 10791
Owner Operation: Our operation: Lock file: /Users/Skyf/.gradle/caches/modules-2/modules-2.lock
解决： 删除项目中的.gradle文件夹 再次编译
问题2 场景： Error:A problem occurred configuring project ':app'.（和1不一样，这边指的是主app）
&gt; Could not resolve all dependencies for configuration ':app:_debugApk'.
&gt; Timeout waiting to lock artifact cache (/Users/Skyf/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa0477ba0492d7900486a2242984d5de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ff187592af1efe046deeabbb27b7716/" rel="bookmark">
			样本不平衡问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 样本类别相差很大，比如，正样本998个，负样本2个，训练得到的模型将永远将新样本预测为正样本，这样的模型毫无价值。 一般解决样本不平衡问题从三个方向出发： 第一：上采样【也叫过采样】，增加补充少的类别样本，比如这里增多负样本，使得正负样本的比例差不多。需注意的是上采样不能简单的对初始样本重复采样，否则容易导致过拟合。可以对已有的正样本利用类似于插值法加入一些噪声干扰。 第二：下采样【也叫欠采样】，减少删除多的类别样本，比如这里删除过多的正样本，使得正负样本的比例差不多。欠采样不足之处在于它容易丢掉样本。这种方法大多数用在集成学习机制中，将反例划分为多个集合供多个不同模型学习，这样每个模型都进行了下采样，从全局的角度来看不会丢失重要信息。 第三：移动阈值。正常情况下，我们将观察几率与真实几率等同。如果正负样本比列约为1，那么我们通常要求，只要该样本的预测为正样本的概率y满足：y/(1-y)&gt;1,即y&gt;0.5那么就认为该样本为正样本。现在存在样本偏差，正负样本比列为m+/m-,其中m+代表正样本数量，m-代表负样本数量。那么只需该样本的预测为正样本的概率y满足 y/(1-y)&gt;m+/m-，那么就该样本为正样本。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fafdf75c105ba412cdedd33529b7e048/" rel="bookmark">
			Python3  chardet模块查看编码格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 chardet模块可以查看如下的编码格式 需要注意的是，如果遇到ＧＢＫ２３１２等编码的，在ｄｅｃｏｄｅ和ｅｎｃｏｄｅ时，一律使用ＧＢＫ进行编码或者解码，这是因为ＧＢＫ是其他ＧＢＫ编码的超集，向下兼容所有的ＧＢＫ编码。
下面是一个例子：
#coding=utf-8 import urllib.request import chardet url = 'http://www.baidu.com' a = urllib.request.urlopen(url) ''' chardet模块 使用该模块可以查看字符串的编码格式：chardet.detect() ''' encode = chardet.detect(a.read()) print(encode['encoding']) #假设存在一个a.txt的文件 f = open('a.txt', 'rb') print(chardet.detect(f.read(100))) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00d109b825ed85b50eec788889c013ca/" rel="bookmark">
			Scrapy奇特报错分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.unpack from require a buffer of 4 bytes
在爬虫项目文件下会产生一个缓存pause文件夹，将这个文件夹删除即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46ea30cb0eee5e5c6fed646bd616fd3c/" rel="bookmark">
			[Java]矩阵的加减和转置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数学上, 矩阵是由方程组的系数及常数所构成的方阵.用在解析性方程组上既方便又直观.生活中通过矩阵多因素探索解决问题.
要点:
1.使用二维数组表示矩阵
2.对矩阵的操作前,需要进行合法性验证,判断他们是否能进行运算
/*** * 矩阵的加减和转置 * @author Power * */ public class TextMatrix { //矩阵数据 private double[][] data; //默认构造函数 public TextMatrix() { } //初始化矩阵 public TextMatrix(double[][] data) { if(CanTransToMatrix(data)) { this.data = this.cloneArray(data); } } //克隆一个二维数组 private double[][] cloneArray(double[][] data2) { // TODO Auto-generated method stub if(data == null) { return null; } return (double[][])data.clone(); } //判断二维数组能够转换成矩阵 public static boolean CanTransToMatrix(double[][] data) { if(data == null) { return false; } for(int i = 0; i &lt; data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46ea30cb0eee5e5c6fed646bd616fd3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb5716a59c2253699ab9a809da295c0/" rel="bookmark">
			HTML中button和input button的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/cjm123/p/7903742.html
button和input button的区别
一句话概括主题：&lt;button&gt;具有&lt;input type="button" ... &gt;相同的作用但是在可操控性方面更加强大。
HTML 4.01规范的Forms部分指 名表单有以下几种控制类型：buttons, checkboxes, radio buttons, menus, text input, file select, hidden controls, object controls. 其中除了buttons/menus/object controls之外，都是由&lt;input&gt;完成。 我这里说的是&lt;button&gt;和&lt;input&gt;。 &lt;button&gt;和&lt;input&gt; 规范中指名：可以用&lt;button&gt;和&lt;input&gt;来做表单按扭。不同的按钮类型请参考这些元素的详细定义。要注意的是&lt;button&gt;比&lt;input&gt;支持更丰富的表现功能。 一些区别 大家都知道&lt;input&gt;可以这样用（实际上是一定要这样用）：&lt;input type="submit" value="OK" /&gt;，一定要这样闭合。而不是：&lt;input type="submit" value="OK" &gt;&lt;/input&gt;。因为起始标签为必须，而关闭标签是禁止的。 &lt;button&gt;比&lt;input&gt;更厉害的地方就在于它可以包含内容。它的值并不是写在value属性里，而是包含在标签中。如：&lt;button&gt;OK&lt;/button&gt;。&lt;button&gt;的起始标签和关闭标签都是必须的。这样你便获得了样式化的主导权。 你可以这样写：&lt;button&gt;&lt;strong&gt;OK&lt;/strong&gt;, I do.&lt;/button&gt;，甚至是插入图片：&lt;button&gt;&lt;img src="http://jianzhong5137.blog.163.com/blog/button.gif" alt="" /&gt;, it's great.&lt;/button&gt;。有点类似于&lt;input type="image"&gt;，但是显然强大多了。 最后要注意的是，被&lt;button&gt;包含的图片，不能使用热点地图，即不能&lt;img src="http://jianzhong5137.blog.163.com/blog/foo.gif" usemap="..." /&gt;，这是不合法的。当然也不能再包含诸如input, select, textarea, label, button, form, fieldset, iframe,和isindex（不推荐使用）元素了。
&lt;button&gt;和&lt;input type="button"&gt; 的具体区别 1、关闭标签设置。&lt;input&gt;禁用关闭标签&lt;/input&gt;。闭合的写法：&lt;input type="submit" value="OK" /&gt;。
&lt;button&gt;的起始标签和关闭标签都是必须的，如 &lt;button&gt;OK&lt;/button&gt;。
2、&lt;button&gt;的值并不是写在value属性里，而是在起始、关闭标签之间，如上面的OK。同时&lt;button&gt;的值很广泛，
有文字、图像、移动、水平线、框架、分组框、音频视频等。见《button按钮设计初步》
3、可为button元素添加CSS样式。
例如，&lt;button style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdb5716a59c2253699ab9a809da295c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2f35b2f81f96775a76606b7a1298970/" rel="bookmark">
			一文带你认识 模型 视图 投影 矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一文带你认识 模型视图投影矩阵 模型（Model）矩阵
视图/观察（View）矩阵 投影（Projection）矩阵 利用模型、观察和投影矩阵，可以将OpenGL从模型到屏幕显示的变换过程清晰地分解为三个阶段。虽然此法并非必需，但采用此法较为稳妥。我们将看到，这种公认的方法对变换流程作了清晰的划分。 模型矩阵 这个三维模型和可爱的红色三角形一样，由一组顶点定义。顶点的XYZ坐标是相对于物体中心定义的：也就是说，若某顶点位于(0,0,0)，则其位于物体的中心。 我们希望能够移动它，玩家也需要用键鼠控制这个模型。这很简单，只需记住：缩放-旋转-平移就够了。在每一帧中，用算出的这个矩阵去乘（在GLSL中乘，不是在C++中！）所有的顶点，物体就会移动。唯一不动的是世界空间（World Space）的中心。 现在，物体所有顶点都位于 世界空间 。下图中黑色箭头的意思是： 从模型空间（Model Space）（顶点都相对于模型的中心定义）变换到世界空间（顶点都相对于世界空间中心定义）。 下图概括了这一过程： 视图/观察矩阵 这里再引用一下《飞出个未来》： *引擎推动的不是飞船而是宇宙。飞船压根就没动过。* 仔细想想，摄像机的原理也是相通的。如果想换个角度观察一座山，您可以移动摄像机也可以……移动山。后者在实际中不可行，在计算机图形学中却十分方便。 起初，摄像机位于世界坐标系的原点。移动世界只需乘一个矩阵。假如你想把摄像机向 右 （X轴正方向）移动3个单位，这和把整个世界（包括网格）向 左 （X轴负方向）移3个单位是等效的！脑子有点乱？来写代码吧： // Use #include &lt;glm/gtc/matrix_transform.hpp&gt; and #include&lt;glm/gtx/transform.hpp&gt; glm :: mat4 ViewMatrix = glm :: translate( - 3.0 f, 0.0 f , 0.0 f); 下图展示了： 从世界空间（顶点都相对于世界空间中心定义）到摄像机空间（Camera Space，顶点都相对于摄像机定义）的变换过程。 趁脑袋还没爆炸，来欣赏一下GLM强大的glm::LookAt函数吧： glm :: mat4 CameraMatrix = glm :: LookAt( cameraPosition, // the position of your camera, in world space cameraTarget, // where you want to look at, in world space upVector ); // probably glm::vec3(0,1,0), but (0,-1,0) would make you looking upside-down, which can be great too 下图解释了上述变换过程： 投影矩阵 现在，我们处于摄像机空间中。这意味着，经历了这么多变换后，现在一个坐标X==0且Y==0的顶点，应该被画在屏幕的中心。但仅有x、y坐标还不足以确定物体是否应该画在屏幕上：它到摄像机的距离（z）也很重要！两个x、y坐标相同的顶点，z值较大的一个将会最终显示在屏幕上。 这就是所谓的透视投影（perspective projection）： 好在用一个4x4矩阵就能表示这个投影 : // Generates a really hard-to-read matrix, but a normal, standard 4x4 matrix nonetheless glm :: mat4 projectionMatrix = glm :: perspective( FoV, // The horizontal Field of View, in degrees : the amount of "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2f35b2f81f96775a76606b7a1298970/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0bd9cff6b0e54ec683bf58f979ced5d/" rel="bookmark">
			Python基础=== Tkinter Grid布局管理器详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转自：https://www.cnblogs.com/ruo-li-suo-yi/p/7425307.html @ 箬笠蓑衣
Grid(网格)布局管理器会将控件放置到一个二维的表格里。主控件被分割成一系列的行和列，表格中的每个单元(cell)都可以放置一个控件。
注意：不要试图在一个主窗口中混合使用pack和grid (1)标签控件
1 from tkinter import * 2 3 tk=Tk() 4 #标签控件，显示文本和位图，展示在第一行 5 Label(tk,text="First").grid(row=0) 6 Label(tk,text="Second").grid(row=1)#第二行 7 8 #主事件循环 9 mainloop() (2) 输入控件
1 from tkinter import * 2 3 tk=Tk() 4 #标签控件，显示文本和位图，展示在第一行 5 Label(tk,text="First").grid(row=0) 6 Label(tk,text="Second").grid(row=1)#第二行 7 8 #输入控件 9 Entry(tk).grid(row=0,column=1) 10 Entry(tk).grid(row=1,column=1) 11 12 #主事件循环 13 mainloop() (3)sticky参数的使用
1 from tkinter import * 2 3 tk=Tk() 4 #标签控件，显示文本和位图，展示在第一行 5 Label(tk,text="First").grid(row=0,sticky=E)#靠右 6 Label(tk,text="Second").grid(row=2,sticky=W)#第二行，靠左 7 8 #输入控件 9 Entry(tk).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0bd9cff6b0e54ec683bf58f979ced5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65b49c8d057b4e120a153b19640b7aaf/" rel="bookmark">
			javascript实现登录验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body οnlοad="createCode();"&gt; &lt;input type="text" value="" id="checkNum" /&gt; &lt;a id="checkCode" οnclick="createCode()"&gt;&lt;/a&gt; &lt;input type="button" class="btnCheck" id="gotoCheck" value="验证" οnclick="validate();" /&gt; &lt;script&gt; var code="" ; //在全局 定义验证码 function createCode(){ code = ""; var codeLength = 6;//验证码的长度 var checkCode = document.getElementById("checkCode"); checkCode.value = ""; var selectChar = new Array(0,1,2,3,4,5,6,7,8,9,'A','B','C','D','E','F','G','H','J','K','L','M','N','P','Q','R','S','T','U','V','W','X','Y','Z'); for(var i=0;i&lt;codeLength;i++) { var charIndex = Math.floor(Math.random()*35); code +=selectChar[charIndex]; } if(code.length != codeLength){ createCode(); } document.getElementById("checkCode").innerHTML = code; } function validate () { var inputCode = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65b49c8d057b4e120a153b19640b7aaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c8c95fee670c07f463a428880c89725/" rel="bookmark">
			说话技巧三步曲--摘自《所谓高情商 就是会说话》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说话技巧是工作中必备技能，作为程序员也不例外，好的说话技巧可以起到事半功倍的作用。
1. 不直接表达自己的想法
不要赤裸裸的说出自己的想法，这样往往事与愿违。
2.揣摩对方心理
揣摩对方的心理，可能对你的话做出的反应。想想对方的喜恶
3.考虑符合对方利益的措辞
把对方的利益和自己的利益趋于一致。
比如你觉得家里的柑橘很多，不能放了，希望家人多吃点。
1.第一步，不要直接说“你们多吃点”，这样的结果往往是对方直接拒绝
2.第二步：家人可能已经吃了很多柑橘，已经腻了。家人对身体肯定很在意，尤其当前是感冒多发季节，大家比较关注的话题。
3.第三部：告诉家人：吃柑橘就不会感冒了，让家人的利益和自己的利益绑定到一起，实现win/win模式。
总结：有点欲速则不达，曲线救国的感觉，找的双赢模式。
转载于:https://www.cnblogs.com/itquanquan/p/8461160.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf42f604678b7bfdf02b45d761994d56/" rel="bookmark">
			Android中的指纹识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from：http://blog.csdn.net/wl9739/article/details/52444671
最近项目需要使用到指纹识别的功能，查阅了相关资料后，整理成此文。
指纹识别是在Android 6.0之后新增的功能，因此在使用的时候需要先判断用户手机的系统版本是否支持指纹识别。另外，实际开发场景中，使用指纹的主要场景有两种：
纯本地使用。即用户在本地完成指纹识别后，不需要将指纹的相关信息给后台。与后台交互。用户在本地完成指纹识别后，需要将指纹相关的信息传给后台。 由于使用指纹识别功能需要一个加密对象（CryptoObject）该对象一般是由对称加密或者非对称加密获得。上述两种开发场景的实现大同小异，主要区别在于加密过程中密钥的创建和使用，一般来说，纯本地的使用指纹识别功能，只需要对称加密即可；而与后台交互则需要使用非对称加密：将私钥用于本地指纹识别，识别成功后将加密信息传给后台，后台开发人员用公钥解密，以获得用户信息。
下面先简单介绍一下对称加密和非对称加密的相关概念，然后对两种开发方式的实现分别进行讲解。
对称加密、非对称加密和签名 在正式使用指纹识别功能之前，有必要先了解一下对称加密和非对称加密的相关内容。
对称加密：所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。因此加密的安全性不仅取决于加密算法本身，密钥管理的安全性更是重要。因为加密和解密都使用同一个密钥，如何把密钥安全地传递到解密者手上就成了必须要解决的问题。
非对称加密：非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。
签名：在信息的后面再加上一段内容，可以证明信息没有被修改过。一般是对信息做一个hash计算得到一个hash值，注意，这个过程是不可逆的，也就是说无法通过hash值得出原来的信息内容。在把信息发送出去时，把这个hash值加密后做为一个签名和信息一起发出去。
由以上内容可以了解到，对称加密和非对称加密的特点如下：
对称加密的优点是速度快，适合于本地数据和本地数据库的加密，安全性不如非对称加密。常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。非对称加密的安全性比较高，适合对需要网络传输的数据进行加密，速度不如对称加密。非对称加密应用于SSH, HTTPS, TLS，电子证书，电子签名，电子身份证等等 指纹识别的对称加密实现 使用指纹识别的对称加密功能的主要流程如下：
使用 KeyGenerator 创建一个对称密钥，存放在 KeyStore 里。设置 KeyGenParameterSpec.Builder.setUserAuthenticationRequired() 为true，使用创建好的对称密钥初始化一个Cipher对象，并用该对象调用 FingerprintManager.authenticate()方法启动指纹传感器并开始监听。重写 FingerprintManager.AuthenticationCallback 的几个回调方法，以处理指纹识别成功（onAuthenticationSucceeded()）、失败（onAuthenticationFailed() 和 onAuthenticationError()）等情况。 创建密钥 创建密钥要涉及到两个类：KeyStore 和 KeyGenerator。
KeyStore 是用于存储、获取密钥（Key）的容器，获取 KeyStore的方法如下：
try { mKeyStore = KeyStore.getInstance("AndroidKeyStore"); } catch (KeyStoreException e) { throw new RuntimeException("Failed to get an instance of KeyStore", e); } 12345 而生成 Key，如果是对称加密，就需要 KeyGenerator 类。获取一个 KeyGenerator 对象比较简单，方法如下：
// 对称加密， 创建 KeyGenerator 对象 try { mKeyGenerator = KeyGenerator .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf42f604678b7bfdf02b45d761994d56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef57ebc1f17591f774a4a8d3c5096514/" rel="bookmark">
			nginx: [emerg] unknown directive &amp;quot;sub_filter&amp;quot;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：Nginx 的内容替换功能，集成第三方的替换模块：ngx_http_substitutions_filter_module报错误：
nginx: [emerg] unknown directive "sub_filter"...... 解决方案：确认配置参数包含以下两项：
--with-http_sub_module --add-module=/git/ngx_http_substitutions_filter_module/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d73385a12a85048e78f7877044ce944f/" rel="bookmark">
			oracle审计的激活与取消
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		审计audit用户见识用户所执行的操作，并且oracle会将审计跟踪结果存放到os文件或数据库中
激活审计
conn /as sysdba
show parameter audit_sys_operations;　查看审计参数
alter system set audit_sys_operations=TRUE scope=spfile;　设置审计参数为true
alter system set audit_trail=db scope=spfile;　startup force;　重启生效
show parameter audit_sys_operations;　查看审计参数
定义需要审计的表
execute dbms_fga.add_policy(object_schema=&gt;'bankuser',object_name=&gt;'emp',policy_name=&gt;'chk_emp',statement_types=&gt;'insert,update,delete');
给普通用户授权查看 审计表
grant select on dba_fga_audit_trail to bankuser;
执行增删操作，查看对表的审计
select t.timestamp,t.sql_text from sys.dba_fga_audit_trail t;
取消审计
execute dbms_fga.drop_policy(object_schema=&gt;'bankuser',object_name=&gt;'emp',policy_name=&gt;'chk_emp');
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03f39cbe98daeaba9afedf7be3064f2c/" rel="bookmark">
			把oracle数据库恢复到某个时间点或者某个scn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		alter session set nls_date_format='yyyymmdd hh24:mi:ss';
select sysdate from dual;
conn dbauser/123456;　随便一个用户，然后删除其中的一张表用来做测试
drop table test;
rman target/
startup mount;
restore database;　还原数据文件
sql 'alter session set nls_date_format="yyyymmdd hh24:mi:ss"'; 因为在rman中执行，所以需要sql ‘’;
recover database until time '20110414 11:33:56';　恢复到这个时间的数据，执行之后需要重新生成重做日志文件
sql 'alter database open resetlogs';
scn是指系统改变号，oracle数据库使用它来记录数据库的过去时间内的状态和轨迹
conn /as sysdba
select dbms_flashback.get_system_chage_number from dual;
select to_char(scn_to_timestamp(963959),'YYYY-MM-DD HH24:MI:SS') from dual; 将scn转换为时间
select * from (select time_dp,scn from smon_scn_time order by time_dp desc) where rownum&lt;10; 根据用户删除数据时间找出相应的scn号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03f39cbe98daeaba9afedf7be3064f2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f89c66bb24772c638089c5edbd0c282b/" rel="bookmark">
			oracle数据库丢失数据文件、控制文件、重做日志文件、初始化文件恢复方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rman target/
list backup;　查看是否已备份，如果没有，那就不知道了
模拟故障，删除/u01/app/oracle/oradata/ORCL文件夹下的所有文件
sqlplus / as sysdba
shutdown abort;
startup ;　都会报错
rman　target/
restore controlfile form autobackup;　查看文件夹，可以发现控制文件恢复了
restore database;　恢复数据文件
recover database using backup controlfile until cancel; 回车后会提示输入，在这里输入cancel
alter database open resetlogs;
如果连初始化文件（pfile）也弄丢了
startup pfile='/u01/app/oracle/admin/ORCL/pfile/init.ora.210201018935';　提示读取不到控制文件
select status from v$instance;　nomount状态
rman target/
restore spfile from autobackup;　恢复初始化文件spfile
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ea6a0f76366131b877f3aff6b8c6e5a/" rel="bookmark">
			oracle重做日志文件硬盘坏掉解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rman target/
list backup;
list backup summary;
删除数据库数据文件夹下的log日志，例如/u01/app/oracle/oradata/ORCL下的所有后缀为log的文件
sqlplus / as sysdba
alter system switch logfile;　因为没有重做日志文件，会一直处于等待装填，如果需要切换日志，数据库将会报错
shutdown immediate;
startup　也会报错
recover database until cancel;　重新设置oracle数据库的重做日志文件（这种恢复属于不完全恢复数据库）
alter database open resetlogs;　重新生成重做文件
archive log list;　查看日志
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b38a7ef82b8f96fe741189c31eadbc4/" rel="bookmark">
			1021 集合运算（java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 给出两个整数集合A、B，求出他们的交集、并集以及B在A中的余集。 输入格式 第一行为一个整数n，表示集合A中的元素个数。 第二行有n个互不相同的用空格隔开的整数，表示集合A中的元素。 第三行为一个整数m，表示集合B中的元素个数。 第四行有m个互不相同的用空格隔开的整数，表示集合B中的元素。 集合中的所有元素均为int范围内的整数，n、m&lt;=1000。 输出格式 第一行按从小到大的顺序输出A、B交集中的所有元素。 第二行按从小到大的顺序输出A、B并集中的所有元素。 第三行按从小到大的顺序输出B在A中的余集中的所有元素。 样例输入 5 1 2 3 4 5 5 2 4 6 8 10 样例输出 2 4 1 2 3 4 5 6 8 10 1 3 5 样例输入 4 1 2 3 4 3 5 6 7 样例输出 1 2 3 4 5 6 7 1 2 3 4
题目分析：基础题
算法分析：用好java类才是关键，利用Set集合不能包含重复元素的性质，调用Treeset类，对于本题是最合适的。
算法设计：
import java.util.*; public class Main { public static void Print(Set&lt;Integer&gt; result) { if (result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b38a7ef82b8f96fe741189c31eadbc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d201c5b2e50506569d7efab8fe92dc4/" rel="bookmark">
			python列表推导式中使用if-else
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 列表推导式总共有两种形式：
①[x for x in data if condition]
此处if主要起条件判断作用，data数据中只有满足if条件的才会被留下，最后统一生成为一个数据列表 ②[exp1 if condition else exp2 for x in data]
此处if...else主要起赋值作用，当data中的数据满足if条件时将其做exp1处理，否则按照exp2处理，最后统一生成为一个 数据列表 例子如下：
#1-100中3的倍数 p = [x for x in range(1,101) if x%3 == 0] #1-100中，不是3的倍数的数去相反数，其余的数保持不变 q = [x if x%3==0 else -x for x in range(1,101)] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77f0b73fa50623ffdd44f888eae37c7a/" rel="bookmark">
			Broken pipe错误解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到一篇Broken pipe错误解释的文章，讲得挺好
https://www.cnblogs.com/metoy/p/6565486.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27679823f8c95258e5f13331abbe87c3/" rel="bookmark">
			vue填坑之路——Day1（基础）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MVVM模式 MVVM、MVC、MVP都是架构模式，这里是这三者的图示。vue中MVVM架构如下： Vue基本语法 Vue实例和Vue组件 Vue实例由Vue函数创建。
var vm = new Vue({ // }) Vue组件也是Vue实例，组件可以扩展html元素，封装可重用代码。
// 注册 Vue.component('my-component', { template: '&lt;div&gt;A custom component!&lt;/div&gt;' }) // 创建根实例 new Vue({ el: '#example' }) 渲染为
&lt;div id="example"&gt; &lt;div&gt;A custom component!&lt;/div&gt; &lt;/div&gt; 父子组件通信 参考笔记
父组件给子组件传递字符串 // html &lt;div id="m-dialog"&gt; &lt;!-- &lt;child value="str"&gt;&lt;/child&gt; 该种方法“只能传递字符串”， 将child的data中的value = "str";不需要父组件data中有数据 --&gt; &lt;child value="str"&gt;&lt;/child&gt; &lt;/div&gt; // js // 注册子组件 Vue.component("child", { // 获取value的依赖 props:["value"], template: '&lt;span&gt;{{ value }}&lt;/span&gt;' }); // 父实例 new Vue({ // 这里的el可视为父组件 el:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27679823f8c95258e5f13331abbe87c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df675eb39b17d785a623a6cb8ee43e92/" rel="bookmark">
			Kotlin的伴生对象的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		伴生对象 类比Java 还记得Java中的static静态成员吗？声明为静态成语的属性和方法在类加载，解析的时候初始化，然后其生命周期与该类的生命周期绑定在一起。
1.这样就可以使类中的某些变量和方法与该类绑定，而不是与某一对象绑定，增加其生命周期。
2.这样就可以使该类的对象共享这个变量和方法，无需为每个对象分配该变量的资源，充分节省资源。
Kotlin如何处理的呢 Kotlin中没有静态变量，So，它使用了伴生对象来模仿Java中静态变量的作用。伴生对象也是在类加载初始化，同样生命周期与该类的生命周期一致且也可以直接通过类名.(attribute,method)来调用。该类的多个对象共享该伴生对象。
为什么Kotlin中单独用一个对象来包括所有的静态资源呢？
其实答案可以从Java中类加载机制中获取，在类加载阶段的初始化阶段，会调用init()函数按照静态属性和静态初始代码块的顺序依次进行初始化，这里的伴生对象可以估计认为是对init()函数的封装吧。
语言之间其实都是相同，我们学习过程中要善于类比和分析，这样不管面对什么语言，你都可以快速上手，游刃有余。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b9614d664bba6fbea4dd48e37665fb5/" rel="bookmark">
			时间戳转24小时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 var timeTrans = new Date(parseInt(nS) * 1000); return timeTrans.toLocaleString('chinese',{hour12:false}); 2018/1/10 0:5:33 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3d33967f326043cd62bb24ff0cca53e/" rel="bookmark">
			js手机端判断各个平台浏览器及操作系统平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;script type="text/javascript"&gt; //手机端判断各个平台浏览器及操作系统平台 function checkPlatform(){ if(/android/i.test(navigator.userAgent)){ document.write("This is Android'browser.");//这是Android平台下浏览器 } if(/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)){ document.write("This is iOS'browser.");//这是iOS平台下浏览器 } if(/Linux/i.test(navigator.userAgent)){ document.write("This is Linux'browser.");//这是Linux平台下浏览器 } if(/Linux/i.test(navigator.platform)){ document.write("This is Linux operating system.");//这是Linux操作系统平台 } if(/MicroMessenger/i.test(navigator.userAgent)){ document.write("This is MicroMessenger'browser.");//这是微信平台下浏览器 } } $(document).ready(function(){ alert(navigator.platform); checkPlatform(); }); &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64b0dd292f593d7b06605addf8c8a889/" rel="bookmark">
			python3 print输出不换行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python 3.x版本输出不换行格式如下 print(x, end=" ") # end="" 可使输出不换行。双引号之间的内容就是结束的内容， # 可以是空格，也可以是其他字符。默认为换行 比如：
print(x,end=” ! ”) # 以！为结尾 python2 输出不换行格式 a = [1,2,3] for x in a: print x, #只需要加一个逗号即可 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/441/">«</a>
	<span class="pagination__item pagination__item--current">442/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/443/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>