<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1fd02794515d542ec4aab590ed84952/" rel="bookmark">
			使用xerces-c&#43;&#43;库编写XSD校验XML的类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于需要写个XSD来校验XML功能的类, 上网搜索了很多资料, 都不能完全满足需要, 于是在多方参考了网络上的文章后, 自己进一步改进了一下。
直接贴代码，备忘。
相关库的官方说明地址: http://xerces.apache.org/xerces-c/
----------------------------------------------------------------------
头文件 IXMLValidation.h
#ifndef _IXML_VALIDATION_H_
#define _IXML_VALIDATION_H_
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;string&gt;
#include &lt;xercesc/util/OutOfMemoryException.hpp&gt;
#include &lt;xercesc/dom/DOM.hpp&gt;
#include &lt;xercesc/parsers/XercesDOMParser.hpp&gt;
#include &lt;xercesc/framework/XMLGrammarDescription.hpp&gt;
#include &lt;xercesc/sax/ErrorHandler.hpp&gt;
#include &lt;xercesc/sax/SAXParseException.hpp&gt;
using std::cerr;
using std::endl;
XERCES_CPP_NAMESPACE_USE
class StrX
{
char* fLocalForm;
public :
StrX(const XMLCh* const toTranscode) { fLocalForm = XMLString::transcode(toTranscode); }
~StrX() { XMLString::release(&amp;fLocalForm); }
const char* localForm() const { return fLocalForm; }
};
class DOMTreeErrorReporter : public ErrorHandler
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1fd02794515d542ec4aab590ed84952/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf80c83c9c773554f0ffa6573ba5f0b2/" rel="bookmark">
			纯JSP带进度条无刷新的多文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、特点
（1）纯JSP代码，不使用任何Ajax等较复杂的技术。程序代码比采用Ajax简单N倍；
（2）可上传任意类型、不限大小的文件；
（3）支持中文文件名
（4）巧妙实现了页面无需刷新处理
（5）上传进度提示；
（6）在后台采用专用线程负责上传；
（7）支持多文件上传；
（8）支持待上传文件的增删处理
（9）参考了common-fileupload的部分代码
（10）在Tomcat7.0环境开发。若要支持Tomcat6.0以下版本，请在WEB-INF/web.xml中配置对应的Servlet文件即可。
（11）代码可能存在一些bug，未做严格测试。
（12）目前暂未实现多线程上传。
（13）下载包是一个项目文件，是在STS里面调试运行得。需要各位自己根据情况做些调整。
二、上传效果
三、下载地址
http://download.csdn.net/source/3234965
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7be4f881ed85135e95f20358749e116b/" rel="bookmark">
			无法显示文件中某些幻灯片上的文字，图像或对象，因为他们已被损坏，演示文稿中受影响的幻灯片将被空白幻灯片替换，并且无法恢复丢失的信息...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 凡是打开有背景图片的PPT基本上都会出现：无法显示文件中某些幻灯片上的文字，图像或对象，因为他们已被损坏，演示文稿中受影响的幻灯片将被空白幻灯片替换，并且无法恢复丢失的信息。。。
卸载KB2464588后恢复正常 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7ac9c5ffbfa111d1829695bb916256e/" rel="bookmark">
			JS在指定时间运行代码(可运行后台代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;script&gt;
&lt;!--
var tSeconds=0;
var tMinutes=0;
var tHours=0;
var timer=null;
function schedule(hours,minutes,seconds){
tHours = hours;
tMinutes = minutes;
tSeconds = seconds;
//TODO check..
run();
}
function run(){
var date=new Date();
if((date.getMinutes()-tMinutes==0)
&amp;&amp;(date.getSeconds()-tSeconds==0)
&amp;&amp;(date.getHours()-tHours==0)){
toDo();
window.clearTimeout(timer);
}else{
timer = window.setTimeout("run()",1);
}
}
function toDo(){
//Add your operation here
alert('do some thing');
}
--&gt;
&lt;/script&gt;
&lt;body οnlοad="schedule(20,15,00)"&gt;
备注：
1、shedule(20,15,00)之间的数字代表小时,分钟,秒
2、function toDo(){
//Add your operation here
alert('do some thing');
}
这函数里面即为你要运行的函数。如果想运行后台函数：
1)先在前台建立个按钮&lt;asp:Button ID="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7ac9c5ffbfa111d1829695bb916256e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90db358208153fb0c0fc25ec71059f39/" rel="bookmark">
			C&#43;&#43;中返回引用和返回值的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++中返回引用和返回值的区别 今天室友在研究返回引用和返回值的区别，呵呵，在网上GOOGLE了一下，这下明白了。
int set()
{
return a;
}
此时生成的是变量a的一个拷贝，即生成了一个临时变量，当这个变量使用完毕之后，变量就被销毁了，所以这种返回不能用作左值运算，如：set() = 5;这是不正确的。
int&amp; set()
{
return a;
}
在第二个例子中，返回的是引用，那么，就相当于返回的是变量a的别名，就可以对该变量操作，如赋值等等。set() = 5;是正确的。
但是在引用返回时得注意一个问题，就是不能返回局部变量的引用，如：
int&amp; set()
{
int a;
return a;
}
此时就会调用出错，因为a是临时变量，函数结束是就自动销毁了，不能再创建别名了。但是将int &amp; 改成int就可以了。
转自：
http://icymarywei.blog.163.com/blog/static/127508102200992441232284/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0795a9ab4cc049df5863ac85191ba8b/" rel="bookmark">
			java中整数前如何进行&#39;0&#39;填充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.text.DecimalFormat;
DecimalFormat df=new DecimalFormat("000"); print(df.format(1)+".jpg")
结果是001.jpg
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9db0cd102034d39c7693f4584caeadb8/" rel="bookmark">
			Silverlight HtmlPage使用之一 弹出新窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先引用using System.Windows.Browser命名空间
xaml代码
&lt; UserControl x:Class= "SilverlightApplication1.HtmlPageControl" xmlns= "http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x= "http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d= "http://schemas.microsoft.com/expression/blend/2008" xmlns:mc= "http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable= "d" d:DesignHeight= "300" d:DesignWidth= "400"&gt; &lt; Grid x:Name= "LayoutRoot" Background= "White"&gt; &lt; Button Content= "PupopWindow" Height= "23" HorizontalAlignment= "Left"
Margin= "12,12,0,0" Name= "button1" VerticalAlignment= "Top" Width= "97" Click= "button1_Click" /&gt; &lt; /Grid&gt; &lt; /UserControl&gt; cs代码
private void button1_Click(object sender, RoutedEventArgs e)
{
HtmlPopupWindowOptions option=new HtmlPopupWindowOptions();
option.Directories=true ;//是否开启ie地址栏
option.Height=300;//浏览器窗口高度
option.Width=300;//浏览器窗口宽度
option.Status=true;//状态栏是否可见
option.Location=true;//是否弹出窗口
option.Menubar=true;//菜单栏是否可见
option.Resizeable=true;//是否可调整窗口高宽度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9db0cd102034d39c7693f4584caeadb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8daef37ab3167f7771d7da3dd1ee0d36/" rel="bookmark">
			java中如何将char数组转化为String？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java中如何将char数组转化为String？
1.直接在构造String时建立。 char data[] = {'s', 'g', 'k'}; String str = new String(data); 2.String有方法可以直接转换。 String.valueOf(char[] chr)就可以。 如： char[] cha = {'s','g','h'}; String n = String.valueOf(cha); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac10efdc7166291ba696e2a1162690a8/" rel="bookmark">
			用eclipse连接MySQL的一点心得体会，如何加载数据库驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天自己用eclipse连接了一下MySQL数据库，总结了一点心得体会。
关于如何连接数据库的代码随处都可以见到，书上，网上，随处便可拾得。而最容易导致连接出错的我觉得还是在加载驱动这个步骤。首先，从MySQL的官网上下载MySQL的JDBC驱动程序，这是网址http://www.mysql.com/downloads/mirror.php?id=401352#mirrors
从里面选个亚洲的地址下载，我是从National Taiwan University, Taiwan 下载的。
你下载的驱动程序一定要和你用的MySQL是一个版本的，个人觉得这一点很重要，因为开始的时候就是因为自己用的MySQL版本跟下载的驱动程序版本不一样，所以一直连接不上，我上面给的连接是MySQL5.0版本的，也就是最新版本的。如果你用的是原来低一些的版本，要找到相应的驱动程序才好。
下载完后，将文件解压，我们需要的只是里面那个mysql-connector-java-5.1.15-bin.jar文件。下面就要开始正式的工作啦！
第一步：在你的项目文件夹下新建一个文件夹lib，在该文件夹中创建子文件夹MySQL_Driver，然后把mysql-connector-java-5.1.15-bin.jar放到子文件夹里面
第二步：打开eclipse，右键单击项目名称，选择构建路径中的配置构建路径，选择库，单击添加外部jar，然后找到刚才自己创建的lib文件夹，在MySQl中选择mysql-connector-java-5.1.15-bin.jar，在确定，这样驱动程序就加载成功了
第三步：就可以试一试是否成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/188b852cdfc5bb17b7d7704ace547d56/" rel="bookmark">
			bmp2png---using libpng
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;png.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;/* A coloured pixel. */typedef struct {uint8_t red;uint8_t green;uint8_t blue;} pixel_t;/* A picture. */typedef struct {pixel_t *pixels;size_t width;size_t height;} bitmap_t;/* Given "bitmap", this returns the pixel of bitmap at the point ("x", "y"). */static pixel_t * pixel_at (bitmap_t * bitmap, int x, int y){return bitmap-&gt;pixels + bitmap-&gt;width * y + x;}/* Write "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/188b852cdfc5bb17b7d7704ace547d56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbe76b84e760ae5d70f8f7e4d6b0f58f/" rel="bookmark">
			【Successful Lisp】语法（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前边:Successful lisp是David B. Lamkins 写的一本书，在 http://psg.com/~dlamkins/sl/ 可以看到，该系列blog基本源于该书，加入了一些自己的理解和实践。
感谢David B. Lamkins。
所有代码均在Fedora 14, GCL上测试通过。blog原文在LibreOffice上产生。
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
1 Lisp Syntax 1.1 List 任何被括号（）括起来的语句内容都是list。比如：
(1 2 3 4 5）
(a b c)
(money 77 pig 88)
其中包括空list，以及嵌套list:
()
(a b (1 3 ) c )
但不匹配的（）所包围的内容不是list。比如：
（a (c )
( ()
(a b c
list 可以是一些数据，也可以是一段程序。同时，list可以嵌套list，所有list可以同时包括一些数据和一些程序段。
接下来，我们介绍atom。list中通过空格分开的元素，称之为atom。比如以上例子中的数字和单词，同时嵌套的list中的元素也是atom，但是该嵌套的list本身不是atom。比如：
（ a b 1 2)
中的a, b, 1, 2都是。但是
（a b (1 3))
中的嵌套的（1 3）不是。
如果list中包含标点符号，并且标点符号后是空格，或者），那么也是一个atom。比如:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbe76b84e760ae5d70f8f7e4d6b0f58f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9ea818c4787c3a89ae897d740ddc270/" rel="bookmark">
			Setup Factory 写注册表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装之后-》双击“结束安装”-》点击“操作”-》on preload:
result = File.Run(SessionVar.Expand("%AppFolder%//mysql-5.1.6-alpha-win32//bin//mysqld-nt.exe"), "", "", SW_SHOWNORMAL, false);-- 这些操作在屏幕显示之前执行。
Registry.SetValue(HKEY_LOCAL_MACHINE, "Software//Microsoft//Windows//CurrentVersion//Run", "MySoftWare", "C://Program Files//cosl_ZWL_App//mysql-5.1.6-alpha-win32//bin//mysqld-nt.exe", REG_SZ);
2011-04-0713:39:46
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f009ed84be2af8e482624349f9c5a305/" rel="bookmark">
			MFC中改变控件的背景颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里讲述两种改变MFC控件背景颜色的方法：
方法一：用OnCtlColor消息函数，改变特定控件的背景
首先在头文件的类中定义CBush类的变量 brush 如语句：CBrush brush;
然后在源文件的构造函数中初始化：brush.CreateSolidBrush(RGB(255,0,0));
RGB( , , ) 控制颜色，分别为红，绿，蓝，三个一样显示灰色背景，都为255为白色，都为0为黑色
然后再消息函数中写代码如下：
HBRUSH CFilePlayDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
// TODO: 在此更改 DC 的任何属性
// TODO: 如果默认的不是所需画笔，则返回另一个画笔
if(pWnd-&gt;GetDlgCtrlID() == IDC_FILE_PLAY)
{
pDC-&gt;SetBkColor(RGB(0,0,0));
HBRUSH brush = CreateSolidBrush(RGB(0,0,0));
return brush;
}
return hbr;
}
方法二：
也用这个消息函数
HBRUSH CFilePlayDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
if(nCtlColor==CTLCOLOR_STATIC) {
pDC-&gt;SetBkColor(RGB(0,0,0));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f009ed84be2af8e482624349f9c5a305/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2929da4c59fbec1b14b2ef5779f480eb/" rel="bookmark">
			Java 可以或得到的全部的时区ID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Etc/GMT+12
Etc/GMT+11
MIT
Pacific/Apia
Pacific/Midway
Pacific/Niue
Pacific/Pago_Pago
Pacific/Samoa
US/Samoa
America/Adak
America/Atka
Etc/GMT+10
HST
Pacific/Fakaofo
Pacific/Honolulu
Pacific/Johnston
Pacific/Rarotonga
Pacific/Tahiti
SystemV/HST10
US/Aleutian
US/Hawaii
Pacific/Marquesas
AST
America/Anchorage
America/Juneau
America/Nome
America/Yakutat
Etc/GMT+9
Pacific/Gambier
SystemV/YST9
SystemV/YST9YDT
US/Alaska
America/Dawson
America/Ensenada
America/Los_Angeles
America/Tijuana
America/Vancouver
America/Whitehorse
Canada/Pacific
Canada/Yukon
Etc/GMT+8
Mexico/BajaNorte
PST
PST8PDT
Pacific/Pitcairn
SystemV/PST8
SystemV/PST8PDT
US/Pacific
US/Pacific-New
America/Boise
America/Cambridge_Bay
America/Chihuahua
America/Dawson_Creek
America/Denver
America/Edmonton
America/Hermosillo
America/Inuvik
America/Mazatlan
America/Phoenix
America/Shiprock
America/Yellowknife
Canada/Mountain
Etc/GMT+7
MST
MST7MDT
Mexico/BajaSur
Navajo
PNT
SystemV/MST7
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2929da4c59fbec1b14b2ef5779f480eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a437c9758e393ab80d37ade015381e47/" rel="bookmark">
			nfs常见问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络文件服务器（Network File System，简称NFS），是分布式计算系统的一个组成部分，可实现在异种网络上共享和装配远程文件系统。NFS由Sun公司开发，目前已经成为文件服务的一种标准（RFC1904，RFC1813）。其最大的功能就是可以通过网络，让不同操作系统的计算机可以共享数据，所以也可以将它看做是一个文件服务器。
NFS网络出现了故障，可以从以下几个方面着手检查：
（1） 检查NFS客户机和服务器的负荷是否太高，Server和Client之间的网络是否正常；
（2） 检查/etc/exports文件的正确性；
（3） 必要时重新启动NFS或portmap服务；
（4）运行下列命令重新启动portmap和NFS:
service portmap restart service nfs start
（5） 检查Client上的mount命令或/etc/fstab的语法是否正确;
（6） 查看内核是否支持NFS和RPC服务。
附加：★NFS常见故障排除 -------------------
1、The rpcbind failure error 故障现象： nfs mount: server1:: RPC: Rpcbind failure RPC: Timed Out nfs mount: retrying: /mntpoint 原因： 第一，可能因为客户机的hosts文件中存在错误的ip地址、主机名或节点名组合； 第二，服务器因为过载而暂时停止服务。 2、The server not responding error 现象： NFS server server2 not responding, still trying 原因： 第一，网络不通，用ping命令检测一下。 第二，服务器关机。 3、The NFS client fails a reboot error 现象： 启动客户机后停住了，不断显示如下提示信息： Setting default interface for multicast: add net 224.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a437c9758e393ab80d37ade015381e47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df030f69a674bb2274521307ebbd5082/" rel="bookmark">
			安全策略禁止本机管理员登录解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Windows 2003环境下，被组策略拒绝本地登录一直是件比较令人头疼的事情。本文将介绍所有用户都被拒绝本地登录后的解决方法。
在Windows2003中，如果某个用户被取消了本地登录权限，当这个用户本地登录计算机时，系统就会提示"此系统的本地策略不允许您采用交互式登录"，导致登录失败。遇到这种情况，通常请管理员在组策略中重新设置一下，将该用户从"拒绝本地登录"列表中删除或添加到"在本地登录"列表中即可。但如果因为操作失误或其它方面的原因，我们将所有用户的本地登录权限都禁止了(通常是禁止了users组（非域环境下）或domain users组（域环境下）)，那就有点麻烦了。这种情形看起来像一个解不开的"死结"：要解除禁止本地登录的组策略设置，必须以管理员身份本地登录；要以管理员身份本地登录，就必须先解除禁止本地登录的组策略设置。
但实际上，事情并没有我们想象的那么糟。经过查询相关资料和测试，我发现借助网络的帮助,这个"死结"还是可以解开的。因为域安全策略与本地安全策略的数据保存机制不同，下面分两种情况分别进行说明。 -------------------------------------------------------------------------------- 被域策略拒绝本地登录时的解决办法
域策略的安全设置部分都保存在一个名为"GptTmpl.inf"的安全模板中，这是一个文本文件，存放在DC（域控制器）的SYSVOL（物理目录指向DC的“c:\winnt\sysvol\sysvol"）共享中。要解除对所有用户本地登录限制，在不能本地登录的情况下，最快捷的办法可能就是直接编辑这个文本文件。
具体操作如下： 在另一台计算机（Win9X/2000/XP均可）上，使用域管理员账号连接到DC的SYSVOL共享，在"\\&lt;DC name&gt;\sysvol\&lt;Domain name&gt;\Policies\&lt;policy GUID&gt;\MACHINE\Microsoft\Windows NT\SecEdit"下找到该文本文件"GptTmpl.inf"。(路径中的"DC name"是你放置该组策略的域控制器的名字，"Domain name"是你的域的名字，"Policy GUID"是你要编辑的组策略对象的GUID，类似于"{31B2F340-016D-11D2-945F-05C04FB98439}")。 使用记事本打开"GptTmpl.inf"文件，找到文件中"Privilege Rights"小节下的 "SeDenyInteractiveLogonRight"关键字，它的值就是被拒绝本地登录的用户或组的SID，将这些SID删除，使 "SeDenyInteractiveLogonRight"关键字的值为空。修改完毕将文件保存回原位置。 使用记事本打开位于"\\&lt;DC name&gt;\sysvol\&lt;Domain name&gt;\Policies\&lt;policy GUID&gt;"下的 "GPT.INI"文件，提高"General"小节下的"Version"关键字的值，通常是加1000。这是我们修改的这个组策略对象的版本号，版本号提高后可以保证我们的更改被复制到其它DC上。修改完毕将文件保存回原位置。 域策略刷新后，问题即告解决。 本地登录DC重新设置域策略中的相关项目。 -------------------------------------------------------------------------------- 被本地安全策略拒绝本地登录时的解决办法 由于在Windows2003中，不支持对计算机本地策略的安全设置部分进行远程管理（详见组策略白皮书），而且本地安全策略的安全设置通常存放在一个二进制的安全数据库secedit.sdb中，这个安全数据库的结构我们无从知道，因此象第一部分那样直接编辑secedit.sdb文件的办法是无能为力了，我们需要采用迂回进攻的策略，"曲线救国"。 具体操作如下： 假设故障计算机的IP地址是"192.168.0.111"。在另一台计算机(Windows9X/2000/XP均可)上，使用"Telnet 192.168.0.111"命令使用管理员账号连接到故障计算机。（如果故障计算机的telnet"服务没有启动，可以通过网络使用"服务"MMC启动，具体方法不在详述） 通过telnet在故障计算机上执行"net share tmp$=d:\tmp"命令，将故障计算机上的"d:\tmp"隐藏共享为"tmp$"，共享权限缺省是everyone完全控制（此时要特别注意网络安全）。当然你也可以共享其它的目录。 通过telnet在故障计算机上执行"secedit /export /CFG d:\tmp\sec.inf"命令，将故障计算机的本地安全策略配置导入"d:\tmp\sec.inf"安全模板文件中，这是一个文本文件。 连接到故障计算机上的tmp$共享，用记事本打开共享文件夹中的"sec.inf"文件。找到文件中"Privilege Rights"小节下的“SeDenyInteractiveLogonRight"关键字，它的值就是被拒绝本地登录的用户或组的SID，将这些SID删除，使"SeDenyInteractiveLogonRight"关键字的值为空或者是随便另设置一个无关的值。文件修改完毕保存回原位置。 通过telnet在故障计算机上执行"secedit /configure /db c:\secedit.sdb /CFG d:\tmp\sec.inf"命令，使用新的安全模板和安全数据库重新配置故障计算机的本地安全策略。 通过telnet在故障计算机上执行"secedit /refreshpolicy machine_policy /enforce"命令，强制在故障计算机上刷新策略设置，问题即告解决。 本地登录故障计算机后，删除我们建立的Tmp$共享，重新设置本地安全策略中的相关项目。 ----------------------------------------------------------------------------------
用故障恢复控制台登录，然后在命令行下运行以下命令：
copy C:\WINNT\repair\security C:\WINNT\system32\config\security
该方法主要是用初始安装的security注册表配置单元，覆盖应用拒绝本地登录策略后的注册表配置单元文件。
转载于:https://blog.51cto.com/18266/530136
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef50ffc8b556da0570f10f3c9009582b/" rel="bookmark">
			观察者模式应用场景实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?php
/**
* 观察者模式应用场景实例
*
* 免责声明:本文只是以哈票网举例，示例中并未涉及哈票网任何业务代码，全部原创，如有雷同，纯属巧合。
* * 场景描述：
* 哈票以购票为核心业务(此模式不限于该业务)，但围绕购票会产生不同的其他逻辑，如：
* 1、购票后记录文本日志
* 2、购票后记录数据库日志
* 3、购票后发送短信
* 4、购票送抵扣卷、兑换卷、积分
* 5、其他各类活动等
* * 传统解决方案:
* 在购票逻辑等类内部增加相关代码，完成各种逻辑。
* * 存在问题：
* 1、一旦某个业务逻辑发生改变，如购票业务中增加其他业务逻辑，需要修改购票核心文件、甚至购票流程。
* 2、日积月累后，文件冗长，导致后续维护困难。
* * 存在问题原因主要是程序的"紧密耦合"，使用观察模式将目前的业务逻辑优化成"松耦合"，达到易维护、易修改的目的，
* 同时也符合面向接口编程的思想。
* * 观察者模式典型实现方式：
* 1、定义2个接口：观察者（通知）接口、被观察者（主题）接口
* 2、定义2个类，观察者对象实现观察者接口、主题类实现被观者接口
* 3、主题类注册自己需要通知的观察者
* 4、主题类某个业务逻辑发生时通知观察者对象，每个观察者执行自己的业务逻辑。
* * 示例：如以下代码
*
*/
#===================定义观察者、被观察者接口============
/**
* * 观察者接口(通知接口)
* */
interface ITicketObserver //观察者接口
{
function onBuyTicketOver($sender, $args); //得到通知后调用的方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef50ffc8b556da0570f10f3c9009582b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42d40630a94a22e44d7fd0c6fb72e67c/" rel="bookmark">
			mysql-proxy主从搭建读写分离全过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话不说！ Mysql-proxy是什么，大家都知道，不知道的就别往下看了... 首先搭建 mysql 主从数据库，参考： http://blog.csdn.net/swengineer/archive/2011/03/11/6239711.aspx 下载 mysql-proxy 最新版，本文撰写时最新版本为 MySQL Proxy 0.8.1 alpha 安装 mysql-proxy 步骤如下： 解压 mysql-proxy-0.8.1-linux-glibc2.3-x86-32bit.gz tar zxvf mysql-proxy-0.8.1-linux-glibc2.3-x86-32bit.gz cp -R mysql-proxy-0.8.1-linux-glibc2.3-x86-32bit /usr/local/proxy-mysql 新建或编辑 /etc/mysql-proxy.cnf 文件，添加以下内容 ( 具体参数根据实际情况修改 ) ： vi /etc/mysql-proxy.cnf [mysql-proxy] admin-username = zhangdongyu admin-password = 123123 daemon = true keepalive = true proxy-backend-addresses = 192.168.0.88:3306 proxy-read-only-backend-addresses = 192.168.0.88:3307 proxy-lua-script = /usr/local/proxy-mysql/share/doc/mysql-proxy/rw-splitting.lua admin-lua-script = /usr/local/proxy-mysql/share/doc/mysql-proxy/admin-sql.lua log-file = /usr/local/proxy-mysql/cn.log log-level = debug 主要参数注解： proxy-backend-addresses mysql 主库（写）地址 proxy-read-only-backend-addresses mysql 从库（读）地址 proxy-lua-script 读写分离脚本 admin-lua-script admin 脚本 admin-username 数据库用户名（主从上都需建立相同用户） admin-password 数据库密码 daemon daemon 进程运行 keepalive 保持连接（启动进程会有 2 个，一号进程用来监视二号进行，如果二号进程死掉自动重建，此参数在旧版本中无法使用） 编辑 profile/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42d40630a94a22e44d7fd0c6fb72e67c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a8bba4fbce01e5cba9d2659bce33f82/" rel="bookmark">
			如何添加domino子服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 添加一台子服务器的方法如下： 1、打开domino的主服务器-&gt;配置-&gt;工具-&gt;注册-&gt;注册服务器,注册时，选择您的cert.id 2、输入附加服务器的名称，以及server.id的密码，点击确定。这时，服务器配置文档中就会显示您新添加的服务器。 3、打开新添加的服务器文档，将server.id文件考贝至新的服务器上。 4、在set up新的服务器时，选择该服务器为附加服务器，选择server id文件时，使用拷贝过来的server.id。 5、选择需要连接的主服务器时，将主服务器的名称与对应IP地址填如。 6、此后附加服务器会自动将主服务器上的names.nsf登数据库拷贝至附加服务器。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/445edcf41e32152dd0a00c0bb47e7118/" rel="bookmark">
			转载 重启TP-LINK WR541G/542G脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		没仔细看，家里路由器之前出现过这样的问题，后来好了，留着备用 重启TP-LINK WR541G/542G脚本 2011-1-13 10:15:30 by 分秒必争 单位为了增加无线信号,加了很多个家用路由器,但不知道怎么回事,这路由器工作 时间长了就不稳定,每次都要隔断时间重启一次才行,但人工重启似乎太过麻烦,想想单位有台服务器24小时不关机,索性写个脚本,每天非工作时间重启一次, 这样不稳定的情况就可以好多了,如果这路由器连8个小时的工作量也挡不住,那基本也没用了,通过抓包啥的,折腾了一会,总算有个方案了,核心代码如下,再 加个时间判断，加个循环，那么所有同类型的路由器都可以在规定时间自动重启了哈，经测试此脚本同样也支持硬件版本为WR741N/742N的路由器
import urllib2,cookielib,base64
upas = base64.b64encode('username:password')
ip = x.x.x.x
url= "http://"+ip+"/userRpm/SysRebootRpm.htm?Reboot=%D6%D8%C6%F4%CF%B5%CD%B3"
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookielib.CookieJar())) urllib2.install_opener(opener)
print '准备重启%s' %ip
print '伪照人工登录信息'
opener.addheaders = [('User-agent','Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1)'),('Accept-Encoding','gzip, deflate'),('Authorization',' Basic '+upas)] print '打开网页'
req = urllib2.Request(url)
print '请求重启信息'
u = urllib2.urlopen(req) print '%s重启完成'%ip
print '-------------------------------------------'
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16a8f53dd34668799d147f1bdc99a7f8/" rel="bookmark">
			如何模拟网络不稳定的环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有没这样的工具 可以模拟出网络不稳定的环境
这样便于测试程序对于网络异常的处理情况
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da8aa1db7cb6499c4abec09cdadadc88/" rel="bookmark">
			深入认识学习ASP应用Cookies的技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是 Cookie？Cookie 其实是一个标签，经常可能听到的中文翻译：小舔饼。当你访问一个需要唯一标识你的站址的 WEB 站点时，它会在你的硬盘上留下一个标记，下一次你访问同一个站点时，站点的页面会查找这个标记。
每个 WEB 站点都有自己的标记，标记的内容可以随时读取，但只能由该站点的页面完成。每个站点的Cookie与其他所有站点的Cookie存在同一文件夹中的不同文件内（你可以在 win98 的 Windows 目录下的 Cookie 文件夹中找到它们，而 win2k 则在 Documents and Settings 文件夹下特定用户的 cookies 文件夹中）。
一个 Cookie 就是一个唯一标识客户的标记，Cookie 可以包含在一个对话期或几个对话期之间某个 WEB 站点的所有页面共享的信息，使用 Cookie 还可以在页面之间交换信息。这项功能经常被使用在要求认证客户密码以及电子公告板、WEB 聊天室等 ASP 程序中。
尽管现在听起来cookie没有什么激动人心的，但实际上利用它，你能实现许多有意义的功能！比如说：你可以在站点上放置一个调查问答表，询问访问者最喜欢的颜色和字体，然后根据这些定制用户的web界面。并且，你还可以保存访问者的登录密码，这样，当访问者再次访问这个站点时，不用再输入密码进行登录。 当然，cookie也有一些不足。首先，由于利用cookie的功能可以编程实现一些不良企图，所以大多数的浏览器中都有安全设定，其中可以设置是否允许或者接受cookie（IE浏览器中“工具”--“Internet选项...”--“安全”--“自定义级别”--“Cookie的使用”；Netscape浏览器中“工具”--“Cookie管理器”--“管理贮存的Cookie”即可），因此这就不能保证随时能使用cookie。再者，访问者可能有意或者无意地删除cookie。当访问者的机器遇到“蓝屏”死机时，或者重新格式化硬盘、安装系统后，原来保存的cookie将全部丢失。最后一点，有一些最初始的浏览器并不能支持cookie。 ◆ 怎样利用cooklie？ 有2种使用cookie的基本方式： 1、将cookie写入访问者的计算机（使用 Response 命令） 2、从访问者的计算机中取回cookie（使用 Request 命令）
◆ 创建cookie的基本语法: Response.Cookies(cookie)[(key)|.attribute]=value 这里的 cookie 是指定 cookie 的名称。 而如果指定了 key，则该 cookie 就是一个字典。 （测试一cookie是否为一个字典可用后面代码显示布尔值：&lt;%=Request.Cookies("cookiename").HasKeys%&gt;。为true是字典，false则不是。 ） Attribute 指定 cookie 自身的有关信息。Attribute 参数可以是下列之一 : ①Domain 若被指定，则 cookie 将被发送到对该域的请求中去。域属性表明cookie由哪个网站产生或者读取，默认情况下，cookie的域属性设置为产生它的网站，但你也可以根据需要改变它。（Response.Cookies("CookieName").Domain = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da8aa1db7cb6499c4abec09cdadadc88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/853a1eb3171ed1f87fc40c9a60a5945b/" rel="bookmark">
			TrueCrypt原理与系统开发(1)：TrueCrypt Format创建加密卷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述
TrueCrypt是唯一的一款支持Windows Vista/XP/2000/Linux开源的虚拟加密磁盘软件，能够创建和设置加密的虚拟磁盘镜像，虚拟磁盘可以与其它磁盘一样正常访问，内部所有文件都会自动加密，需要通过密码来进行访问，加密和解密都是实时的。
TrueCrypt主要分为两部分；一部分是TrueCrypt Format，用来创建加密卷，另外一部分是TrueCrypt Mount，用来加载和卸载虚拟磁盘到分区等。
第一部分、TrueCrypt Format创建加密卷
按照TrueCrypt Format创建加密卷的向导，一共会出现加密卷位置，加密算法、加密卷大小、加密卷密码、加密卷格式化等几个步骤，之后就会创建加密卷，创建完的加密卷就是制定的加密卷位置的那个文件了。
因此我们知道TrueCrypt的核心就是创建加密卷函数了，该函数的作用就是接受上述的加密卷位置等几个参数，完成创建加密卷的过程，在TrueCrypt里的原型是
int FormatVolume (char *volumePath, BOOL bDevice, unsigned __int64 size, unsigned __int64 hiddenVolHostSize, Password *password, int cipher, int pkcs5, BOOL quickFormat, BOOL sparseFileSwitch, int fileSystem, int clusterSize, HWND hwndDlg, BOOL hiddenVol, int *realClusterSize, BOOL uac ); 下面我们来看下每个参数具体的含义
参数 类型 含义 示例 volumePath char * 用户选择的加密卷文件 C://1.txt bDevice BOOL 是否是一个分区卷 FALSE size unsigned __int64 加密卷大小（以byte为单位） 10*1024*1024 hiddenVolHostSize unsigned __int64 隐藏加密卷大小（以byte为单位） 0 password Password 用户输入的密码 123456 cipher int 默认加密的算法 1 pkcs5 int 哈希算法 DEFAULT_HASH_ALGORITHM quickFormat BOOL 是否是快速格式化 FALSE sparseFileSwitch BOOL TRUE fileSystem int 文件系统 FILESYS_FAT clusterSize int 0 hwndDlg HWND 传入的窗口句柄 NULL hiddenVol BOOL 是否是隐藏卷 FALSE realClusterSize int 512 uac BOOL FALSE 下面我们来看具体的实例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/853a1eb3171ed1f87fc40c9a60a5945b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88f45d5c5c08fb2740b3dedd28d10935/" rel="bookmark">
			C# 回车（键盘）事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在KeyPress事件中 private void textBox1_KeyPress(object sender, System.Windows.Forms.KeyPressEventArgs e) { if(e.KeyChar==(char)13) { this.textBox2.Focus(); } }
===================================================================================
private void textBox1_KeyDown(object sender, System.Windows.Forms.KeyEventArgs e)
{
//if条件检测按下的是不是Enter键
if(e.KeyCode==Keys.Enter)
{
MessageBox.Show("您在textBox1里按下了回车键");
}
} C#回车键事件写法是什么呢？我们经常看到程序执行之后会有回车键的出现，那么具体的实现方法是什么呢？C#中回车键事件是如何实现的呢？让我们看看具体的过程：
C#回车键事件1.
private void textBox1_KeyDown( object sender, System.Windows.Forms.KeyEventArgs e) { if(e.KeyValue==13) { MessageBox.Show("你摁下了回车"); } } C#回车键事件2.
public partial class Form1 : Form { public Form1() { InitializeComponent(); this.textBox1.KeyDown += new KeyEventHandler(textBox1_KeyDown); this.button1.Click += new EventHandler(btnOK_Click); } void button1_Click(object sender, EventArgs e) { } void textBox1_KeyDown(object sender, KeyEventArgs e) { if (e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88f45d5c5c08fb2740b3dedd28d10935/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2447ba462166878600310cc16f0d5b52/" rel="bookmark">
			（五）如何设置收件人信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发件人和收件人是邮件和消息很常用的几个属性之一，关于发件人的设置和获取是很简单的，只需要处理PR_SENDER_EMAIL_ADDRESS属性即可，下面主要讲述的收件人的设置和获取。
MAPI收件人结构如图（摘自MSDN）:
每一个Entry代表了一个收件人信息组，每个信息组又可以有多项信息组成，举个例子，下面的代码代表了一个收件人的信息：
aEntries[0].rgPropVals[0].ulPropTag = PR_RECIPIENT_TYPE; //类型，MAPI_TO代表是设置到TO字段上的，相应的还有MAPI_CC和MAPI_BCC。
aEntries[0].rgPropVals[0].Value.ul = MAPI_TO;
aEntries[0].rgPropVals[1].ulPropTag = PR_ADDRTYPE; //设置地址类型，一般为SMTP
aEntries[0].rgPropVals[1].Value.LPSZ = _T("SMTP");
aEntries[0].rgPropVals[2].ulPropTag = PR_EMAIL_ADDRESS; //收件人地址
aEntries[0].rgPropVals[2].Value.LPSZ = _T("1234567");
设置收件人是通过IMessage:: ModifyRecipients来实现的，以下的代码举例说明了如何设置TO、CC和BCC属性：
INT nRecipientCount = 3; //表示有3个联系人信息
INT nListBufSize = CbNewADRLIST(nRecipientCount); //计算3个联系人需要的存储空间
LPADRLIST pAddressList = NULL;
MAPIAllocateBuffer(nListBufSize, (LPVOID FAR *)&amp;pAddressList)); //分配空间
memset(pAddressList, 0, nBufSize); pAddressList-&gt;cEntries = 3; //表明一共有3个联系人信息
//设置To
INT nCurIndex = 0;
MAPIAllocateBuffer(sizeof(SPropValue) * 3, (LPVOID FAR *)&amp;pAddressList-&gt;aEntries[nCurIndex].rgPropVals)); //分配空间 memset(pAddressList-&gt;aEntries[nCurIndex].rgPropVals, 0, sizeof(SPropValue) * 3);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2447ba462166878600310cc16f0d5b52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84addd82207e9834f521c101c991f7ff/" rel="bookmark">
			简单的C语言程序之加法程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 C语言加法程序：
#include&lt;stdio.h&gt;
void main() { int a,b,c; scanf("%d %d",&amp;a,&amp;b); c=a+b; printf("%d+%d=%d/n",a,b,c); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b35e0094a43b05f5f671c23e5bb2410c/" rel="bookmark">
			PowerBuilder Native Interface(PBNI)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PowerBuilder Native Interface(PBNI)
PowerBuilder 9现在对于其他开发语言的支援，有了全新的突破，在以往使用
PowerBuilder开发程式时，要和C++或是Java程式互通有无是有一些折衷的办
法，但是总是没有办法做到简易而且全面性的支援。现在只要透过PowerBuilder 9的PBNI技术，就可以让PowerBuilder的程式呼叫Java，或是在一个C++的程
式中引用PowerBuilder NVO物件函数。 以往的PowerBuilder程式只能够透过外在函数呼叫的方式来存取C/C++的函
数，但在PowerBuilder 9.0之中扩增了一项强而有力的介面－「PowerBuilder Native Interface」，简称PBNI。透过PBNI的开发方式，PowerBuilder开发人员
不仅可以使用物件导向的方式来存取C/C++函数，而且还可反向地让C/C++程式
呼叫PowerBuilder之中的物件，达到应用程式的整合。更甚者，在藉由JNI与
PBNI两者的结合，Java应用程式也可双向地与PowerBuilder程式沟通。 何谓PBNI
在谈什么是PBNI之前，我们先来谈谈下面三个问题： 1.开发人员有办法用PowerBuilder程式呼叫C或是C++的程式吗? 2.开发人员有办法用PowerBuilder程式呼叫一些外部元件像是Java EJB元件、 Web Service元件、Java Class程式等诸如此类的元件吗? 3.开发人员有办法用反过来，用C或是C++呼叫已经使用PowerBuilder开发好
的程式吗? 上述三个问题，在过去的PowerBuilder其实都可以做到某种程度的地步，只是都
有些问题。传统上使用PowerBuilder开发上述的程式时，如果要呼叫C或是C++ 的程式，是可以使用宣告外部函数的方式来使用一个已经撰写好的DLL函数， 例如： FUNCTION ulong GetSysColor (int index) LIBRARY "USER32.DLL” FUNCTION boolean sndPlaySoundA (string SoundName, uint Flags) LIBRARY "WINMM.DLL" 可是如果是下面的程式呢： BOOL EnumWindows(WNDENUMPROC lpEnumFunc, LPARAM lParam); 这个可是个大问题了，因为这个Windows DLL Function中会用到所谓的「Callback」 函数的技术，所谓的Callback Function指的是今天有A和B两个物件，在程式中
A物件呼叫B物件的Function，而在该B物件的Function又会回头呼叫A物件的
其他Function，这就叫「Callback」。在PowerBuilder呼叫C的Function后，在这
个C的Function中要再回头呼叫PowerBuilder的函数是不可能用引用外部函数的
方式来达到这个目地的。除了Callback Function使用困难之外，使用外部函数也
有资料型态的限制，以及没有办法使用物件导向的方式开发等种种的困难及问
题。 再来谈谈PowerBuilder呼叫外部的元件的方法，在以前能够让PowerBuilder呼叫
EJB元件，就只能透过一些协力厂商开发的「COM Bridge」，让PowerBuilder程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b35e0094a43b05f5f671c23e5bb2410c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11c06af882e1dff0d2ed4d63d3a8c56a/" rel="bookmark">
			controller下的missing newline错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新年伊始，写2011年的第一篇博客，呵呵。。。
今天做压测的时候，脚本里面做了参数化，结果运行在controller里面的时候，报了个missing newline的错误，查了一下，将参数化的dat文件中的最后一行补上一个空行就解决啦！！
如果遇到此错误，需检查2个地方：1. dat文件中有没有空白行；2. 文档最后一行是否为空行，如不是空行，需敲回车键补上一个空行。
----肖楠
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b384efebe1ae5c7db933232bd135f7e/" rel="bookmark">
			Windows无法启动(WINDOWS\SYSTEM32\CONFIG\SYSTEM文件的损坏或丢失)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		症状： 电脑开机后显示“因以下文件的损坏或丢失，Windows无法启动：\WINDOWS\SYSTEM32\CONFIG\SYSTEM 您可以通过使用原始启动软盘或CD-ROM来启动Windows安装程序，以便修复这个文件。 在第一屏时选择“r”开始修复”
解决办法： windows/system32/config/system 这个是系统的注册表配置文件,如果损坏是无法进入系统的,解决方法是用DOS启动盘或进系统恢复控制台下（放入安装光盘，设从光驱启动，经过一段时间的初始化，出现提示操 作界面，按R进入控制台。输入操作系统的编号即可进入相应的控制台） 进入后肯定是在系统目录下，如：“C:\WINDOWS” 输入以下命令：
md tmp （回车）
copy c:\windows\system32\config\system c:\windows\tmp\system.bak （回车）(可能是提示无法复制，不用管它，因为已经损坏了)
delete c:\windows\system32\config\system （回车）
copy c:\windows\repair\system c:\windows\system32\config\system （回车）
exit （回车） 进入系统后你需要重新安装你的所有硬件驱动。软件可以继续使用。
原因： 1.病毒。建议全盘格式化。
2.内存。放电。不兼容。
3.硬盘坏道。
4.Bios清电。
5.windows的bug。很新奇，据说是每次硬件改动都会认为你是在另一台机子上重新使用该系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74f49c99042e355ac7e5694afac2c5c6/" rel="bookmark">
			用 cmake 构建Qt工程(对比qmake进行学习)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cmake vs qmake qmake 是为 Qt 量身打造的，使用起来非常方便cmake 使用上不如qmake简单直接，但复杂换来的是强大的功能 内置的 out-of source 构建。（目前QtCreator为qmake也默认启用了该功能，称：shadow build）
为各种平台和场景提供条件编译 可处理多个可执行文件情况，和很好配合 QtTest 工作
如何选择?
Using CMake to Build Qt Projects 一文中说：
对简单的Qt工程，采用 qmake对复杂度超过 qmake 处理能力的，采用 cmake 尽管如此，如果简单Qt的工程都不知道怎么用 cmake 构建，复杂的工程，就更不知道如何使用 cmake 了。还是从简单的学起吧
简单的 Qt 程序 #include &lt;QtCore/QCoreApplication&gt;
#include &lt;QtCore/QDebug&gt;
int main(int argc, char** argv)
{
QCoreApplication app(argc, argv);
qDebug()&lt;&lt;"hello qt!";
app.exec();
} 如果不使用构建工具，直接调用编译器来编译的话，只需要类似这样的一条命令：
g++ main.cpp -Ie:/Qt/4.7.0/include -o main -Le:/Qt/4.7.0/lib -lQtCore4 指定头文件目录，以及需要链接的库
qmake qmake 需要一个 .pro 文件:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74f49c99042e355ac7e5694afac2c5c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0455b1bef5c42b4508c54ba44dbfd82/" rel="bookmark">
			如何清理“通知区域图标”中的过期图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开始菜单的命令行中输入“regedit”打开注册表编辑器，或者按“Win+R”组合键调出注册表编辑器，搜索“IconStreams”。可以看到两个文件：IconStreams和PastIconsStream，将它们删除。
也可以展开注册表：
HKEY_CLASSES_ROOT/Local Settings/Software/Microsoft/Windows/CurrentVersion/TrayNotify 找到IconStreams和PastIconsStream后将它们的值删除。
然后调出任务管理器将进程“explorer.exe”终止，再在任务管理器中点击“文件——新建任务”，输入“explorer”，回车，以此重新启动该系统进程。现在再来查看一下通知区域的图标，过期的图标已经被成功清理了。
以后如果要是再有旧图标，只须再次调出任务管理器将进程“explorer.exe”终止，再在任务管理器中点击“文件——新建任务”，输入“explorer”，回车，以此重新启动该系统进程即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52c847ee403e8b67d6f3978015fcd326/" rel="bookmark">
			CMM概括
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CMM的基本框架 1．CMM的设计思想 任何软件开发和软件企业的发展都离不开软件过程，而软件过程必然要经历一个从不成熟到成熟，从不完善到完善的发展过程。它不是一朝一夕就能成功的，需要持续不断的对软件过程进行改进，才能取得最终的成效。CMM就是根据这一指导思想设计出来的。为此，模型必需满足如下四点对企业的指导作用： 1）为了正确和有序地引导软件过程活动的开展，要建立一个能够有效地描述和表示的软件过程的改进框架，使其能够对各阶段软件过程的任务和管理起指导作用。 2）以产品质量的概念和软件工程的经验教训为基础，指导企业控制开发、维护软件的生产过程和如何制定一套与之相适应的软件工程及管理体系。 3）指导软件企业通过判断自身当前的过程成熟度，针对软件质量和软件过程提高中最为关键的问题，来选择过程的提高策略。 4）引导企业将注意力放在具体的和经过努力可实现的目标上，并努力通过模型中提供的措施和手段去实现这些目标。 2．CMM的分级标准 1） 建立分级标准的作用 CMM模型描述和分析了软件过程能力的发展程度，确立了一个软件过程成熟程度的分级标准，如图2.1示。其作用： ①一方面软件组织利用它可以评估自己当前所处的位置——过程成熟程度，并以此提出严格的软件质量标准和改进过程的方法和策略，通过不断的努力达到更高的成熟度。 ②另一方面该标准也可作为用户对软件企业的一种评价标准，使之在选择软件开发商时不再是盲目的和无把握的。 2）CMM的分级结构及其过程描述 ①初始级：软件过程的特点是无秩序或说无定规的，有时甚至是混乱的。软件过程定义几乎处于无章法、无步骤可循的状态，软件产品所取得的成功往往依赖于极个别人的努力和机遇。 ②可重复级：已建立了基本的项目管理过程，可用于对成本、进度和功能特性进行跟踪。对类似的应用项目，有章可循并能重复以往所取得的成功。 ③已定义级：用于管理的和工程的软件过程均已文档化、标准化，并形成了整个软件组织的标准软件过程。全部项目均采用与实际情况相吻合的、适当修改后的标准软件过程来进行操作。 ④已管理级：软件过程和产品质量有详细的度量标准。软件过程和产品质量得到了定量的认识和控制。 ⑤优化级：通过对来自过程、新概念和新技术等方面的各种有用信息的定量分析，能够不断地、持续地对促进过程进行改进。 除第一级外，每一级都设定了一组目标，如果达到了这组目标，则表明达到了这个成熟级别，自然可以向上一更为成熟的高一级别迈进。CMM体系不主张跨级别的进化，因为从第二级开始，每一个低级别的实现均是更高级别实现的基础。 3．CMM各级的主要特性 前面已经反复提到，CMM标准共分五个等级，从第一级到第五级分别为：初始级、可重复级、定义级、管理级和优化级，从低到高，软件开发生产的计划精度越来越高，每单位工程的生产周期越来越短，每单位工程的成本也越来越低。需要提出的是，任何一个成熟度级别的关键过程域集都是本级描述的关键过程域集和所有下级的关键过程域集的并集。如3级的关键过程域就应有13个不同的域，其中7个是3级自己包含的，6个属于2级成熟度，而4级应有15个域。 这五个级别具体内容包括： 第一级：初始级（The Initial Level） 初始级的软件机构缺乏对软件过程的有效管理，其软件项目的成功来源于个人英雄主义而非机构行为，因此它不是可重复的。 第二级：可重复级（The Repeatable Level） 概述： 第二级软件机构的主要特点是：项目计划和跟踪的稳定性，项目过程的可控性和以往成功的可重复性。更具体的说： 机构建立了管理软件项目的策略和实现这些策略的过程。 新项目的计划和管理基于类似项目的经验。 过程能力的增强基于以各个项目为基础的有纪律的基本过程管理。 不同的项目可有不同的过程，而对机构的要求是具有指导项目建立适当管理过程的策略。 每个项目都确定了基本的软件管理控制，包括： 基于前面项目的经验和新项目特点，做出现实的项目承诺（如预算、交付期、软件质量等）； 软件项目管理者要跟踪开支、日程、软件功能； 满足承诺的过程中的出现的问题要及时发现，妥善解决； 定义了软件项目标准，且机构确保其被遵守。 构成： 本级的关键过程领域（KPA）包括： 需求管理（Requirements Management） 客户的需求是软件项目的基础。软件需求管理的目的是在客户和软件项目之间达成对客户需求的一致理解。 软件项目计划（Software Project Planning） 为软件工程和项目管理建立一个合理的计划。 软件项目的跟踪和监督（Software Project Tacking and Oversight） 使管理者对实际的软件项目进展过程有足够的了解，以在项目效能偏离计划太多是采取有效措施。 软件子合同管理（Software Subcontract Management） 选择合格的分包商，并有效管理之。 软件质量保证（Software Quality Assurance） 对软件项目过程及其间生产的各个产品进行监管以保证最终软件质量。 软件配置管理（Software Configuration Management） 在整个软件生命周期里建立并维护软件项目的工作产品的完整性。 第三级：已定义级（The Defined Level） 概述 第三级的主要特征在于软件过程已被提升成标准化过程，从而更加具有稳定性、可重复性和可控性。处于第三级的企业具有如下一些特征： 机构采用标准的软件过程，软件工程和管理活动被集成为一个有机的整体。标准化的目的是使之可使管理者和技术人员有效工作。 有一组人员专门负责机构的软件过程，并且在机构中有培训计划来确保stuff和manager有知识和技能完成所赋予的角色。 标准的软件过程结合项目的特点即形成定义的软件过程，它包括一组集成的定义良好的软件工程和管理过程。 一个定义良好的过程包括就绪准则、输入、完成工作过程、验证机制、输出和完成准则。 在已建立的产品线上cost, schedule, functionality 均可控制，软件质量被加以跟踪。 过程能力体现在在机构范围内对一个定义的软件过程活动、角色和责任的共同理解。 构成 ： 第三级主要处理以下的KPA： 机构过程关注（Organization Process Focus） 确立机构对于改进机构的软件过程能力的软件过程活动的责任。 机构过程定义（Organization Process Definition） 开发和维护一组有用的软件过程assets和提供一个用于定义定量过程管理的有意义的数据的基础 培训计划（Training Program） 开发个体的技能和知识以使他们能够更加有效的完成他们的角色 集成软件管理（Integrated Software Management） 基于业务环境和项目的技术需要，从机构的标准软件过程和相关的过程assets经过剪裁，将软件工程和管理活动集成为一个有机的定义的软件过程。 软件产品工程（Software Product Engineering） 一致地完成定义良好的工程过程。它描述了项目的技术活动，如需求分析，设计，编码和测试。 组间协调（Intergroup Coordination） 确立软件工程组主动介入其它工程组以便项目能更好满足客户要求的手段 同行评审（Peer Reviews） 早而且有效的排除软件工作产品中的缺陷。它可通过inspection,structured walkthrough等手段进行。 概括来说，第三级企业的重点是Engineering processes and organizational support。 第四级：已管理级（The Managed Level） 概述： 第四级的软件机构中软件过程和软件产品都有定量的目标，并被定量地管理，因而其软件过程能力是可预测的，其生产的软件产品是高质量的。具体地说，第四季的机构具有如下特征： 软件过程和产品有定量质量目标。 重要的软件过程活动均配有生产率和质量度量； 数据库被用来收集和分析定义软件过程的数据； 项目的软件过程和质量的评价有定量的基础； 项目的产品和过程控制具有可预测性。 缩小过程效能落在可接受的定量界限内的偏差； 可区分过程效能的有效偏差和随机偏差； 面向新领域的风险是可知并被仔细管理； 构成： 本级的关键过程领域包括： 定量过程管理（Quantitative Process Management） 定量地控制软件项目的过程效能。 软件质量管理（Software Quality Management） 定量了解项目软件产品的质量，并达到既定的质量目标。 第五级：The Optimizing Level 概述 概括来说，第五级的主要特点是技术和过程改进被作为常规的业务活动加以计划和管理。处于第五级的企业具有如下一些特征： 机构集中于连续的过程改进 具有标识弱点和增强过程的手段。 采用过程数据分析使用新技术的代价效益并提出改进。 项目队伍能够分析出错原因并防止其再次出现。 防止浪费是第五级的重点。 改进的途径在于已有过程的增量改进和使用新技术和新方法的革新 构成： 缺陷预防（Defect Prevention） 识别出错原因，防止错误再现(通过改变定义的软件过程) 技术变更管理（Technology Change Management） 识别有益的新技术(工具、方法和过程)，并按有序的方式将其转移至机构之中。其重点在于在变化的世界中有效的完成革新。 过程变更管理（Process Change Management） 连续改进机构所采用的软件过程，以改进软件质量，提高生产率和减少产品开发时间 概括来说，第五级企业的重点是连续的过程改进。 4．CMM内部结构和特性简述 上面提到了CMM把软件开发组织的能力成熟度分为五个等级。除了第1级外，其他每一级均由若干关键过程域组成，每个关键过程域中规定了5种公共特性：执行约定、执行能力、实施活动、度量和验证的标准。换句话说，每一个关键过程域由若干关键实践活动所描绘，这些实践活动以5个公共特性进行归类，这些公共特性是关键实践描述的对象、也是基础和依据。CMM给每个关键过程规定了一些具体目标，按5个公共特性归类的关键惯例是按该关键过程的具体目标选择和确定的。如果恰当地处理了某个关键过程涉及的全部关键惯例，这个关键过程的各项目标就达到了，也就表明该关键过程实现了。这种成熟度分级的优点在于，这些级别明确而清楚地反映了过程改进活动的轻重缓急和先后次序。（关于关键过程域、关键实践、公共特性等概念后面会有详细解释） 二、CMM与软件过程可视性 1．软件过程的概念 软件过程是人们用于开发和维护软件及其相关产品的一系列活动、方法、实践和革新。其外部视图如P23页图2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52c847ee403e8b67d6f3978015fcd326/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cb13786676d02b7a8b408af4a784493/" rel="bookmark">
			关于编程与数学的名言金句——字字珠玑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 其用本太虚生一，而周流无穷，大则可以通神明，顺性命；小则可以经世务，类万物... ... 若昔推策以迎日，定律而知气。髀矩浚川，土圭度晷。天地之大，囿焉而不能外，况其间总总者乎？—— 秦九韶，中国古代最伟大的数学家
(为了应用，人们要认识世界的规律，因而产生了数学。数学具有广泛的应用性。从大的方面说，数学可以认识自然，理解人生；从小的方面说，数学可以经营事务，分类万物... ...过去，历算家们用筹算推演，制定天文历法；发现自然规律，预测季节变化。用“髀”、“矩”测山高河深，用“圭表”量日影，以定时刻与节气。宇宙如此之大，尚且不能置于数学之外，那么，宇宙之中的各种各样的事物，难道能离开数学吗？)
2. All knowledge is, in the final analysis, history. All sciences are, in the abstract, mathematics. All methods of acquiring knowledge are, essentially, through statistics. —— C. R. Rao，数学家、统计学家
（在终极的分析中，一切知识都是历史；在抽象的意义下，一切科学都是数学； 在理性的基础上，所有的判断都是统计学。）
3. All models are wrong, but some are useful.——George E. P. Box，20世纪最伟大的统计学家之一 （所有模型都是错的，但是其中一些是有用的。)
4. No clear reason to prefer one over another. Choice is task dependent. ——出处不详
（没有明确的原因表明一种方法胜于另外一种方法，选择通常是依赖于具体任务的。）
5. Algorithms + Data Structures = Programs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cb13786676d02b7a8b408af4a784493/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b0d9c9add23bf2966efafdb4f4a2378/" rel="bookmark">
			寻找济南的.Net软件开发SOHO工作者合作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人手头有一个 .Net(2008)+sql2005项目，主要包括 外贸公司进销存、客户管理(CRM)、OA模块，开发工期比较紧，找济南当地的开发高手合作开发。
注：
1、不要新手，至少2年以上开发经验。对新手没有任何的偏见，我也是从新手走过来的，只是项目工期紧，不想话费太长的时间在开发技术本省上
2、济南当地，开发的过程中交流起来比较方便
有意者请与我联系：
sdweb2008@126.com
QQ:710906900 请注明 CSDN 软件开发
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb40743067482afca64bc919a064bcbc/" rel="bookmark">
			最早的计算机病毒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑病毒并非是最近才出现的新产物，事实上，早在一九四九年，距离第一部商用电脑的出现仍有好几年时，电脑的先驱者约翰.范纽曼（John Von Neumann）在他所提出的一篇论文《复杂自动装置的理论及组织的进行》，即已把病毒程式的蓝图勾勒出来，当时，绝大部份的电脑专家都无法想像这种会自我繁植的程式是可能的，可是少数几个科学家默默的研究范纽曼所提出的概念，直到十年之后，在美国电话电报公司（AT&amp;T）的贝尔（BELL）实验室中，这些概念在一种很奇怪的电子游戏中成形了，这各电子游戏叫做《磁蕊大战》（CORE WAR）。 磁蕊大战是当时贝尔实验室中三位年轻程式人员在工作之余想出来的，他们是道格拉斯.麦耀莱(H.Douglas McIlroy),维特.维索斯基(Victor Vysottsky)以及罗伯.莫里斯(Robert T.Morris)，当时三人年纪都只有二十多岁。附注：Robert T.Morris就是后来写了一个Worm，把Internet搞得天翻地覆的那个RobertT.Morris Jr.的爸爸，当时大Morris刚好是负责Arpanet网路安全的。 电脑病毒的老祖宗：磁蕊大战的玩法如下： 两方各写一套程序，输入同一部电脑中，这两套程序在电脑的记忆系统内互相追杀，有时它们会放下一些关卡，有时会停下来修理（重新写）被对方破坏的几行指令;当它被困时，也可以把自己复制一次，逃离险境，因为它们都在电脑的记忆磁蕊中游走，因此得到了磁蕊大战之名。这个游戏的特点，在于双方的程式进入电脑之后，玩游戏的人只能看着屏幕上显示的战况，而不能做任何更改，一直到某一方的程式被子另一方的程式完全"吃掉"为止。磁蕊大战是个笼统的名称，事实上还可细分成好几种，麦耀莱所写的程式叫"达尔文"，这包含了" 物竞天择，适者生存"的意思。它的游戏规则跟以上所描述的最接近，双方以组合语言(Assembly Language)各写一套程式，叫有机体（organism），这两个有机体在电脑里争斗不休，直到一方把另一方杀掉而取代之，便算分出胜负。在比赛时Morris经常匠心独具，击败对手。另外有个叫爬行者程式（Creeper）的，每一次把它读出时，它便自己复制一个副本。此外，它也会从一部电脑"爬"到另一部有连线的电脑。很快地电脑中原有资料便被这些爬行者挤掉了。爬行者的唯一生存目的是繁殖。为了对付"爬行者"，有人便写出了"收割者"（Reaper）。它的唯一生存目的便是找到爬行者，把它们毁灭掉。当所有爬行者都被收割掉之后，收割者便执行程式中最后一项指令：毁灭自己，从电脑中消失。"侏儒"（Dwarf)并没有达尔文等程式聪明。却是个极端危险人物。它在记忆系统中迈进，每到第五个"地址"便把那里所储存的东西变为零，这会使原本的程式停止。最奇特的就是一个叫"印普"（Imp)的战争程式了，它只有一行指令，那就是MOV 01 ，MOV是"MOVE"的代表，即移动的意思。它把身处的地址中所载的"0"写（移）到下一个地址中，当印普展开行动之后，电脑中原有的每一行指令都被改为"MOV 01" 。换名话说荧光屏上留下一大堆"MOV 01"。"双子星"(Germini)也是个有趣的家伙。它的作用只有一个：把自己复制，送到下一百个地址后，便抛弃掉"正本"。从双子星衍生出一系列的程式。"牺牲者"(Juggeraut)把自己复制后送到下十个地址之后；而"大雪人"(Bigfoot)则把正本和复制品之间的地址定为某一个大质数。想抓到大雪人可是非常困难的。此外，还有全录(Xerox)柏路阿图研究中心的约翰.索殊所写的"蠕虫"(Worm)，它的目的是要控制侵入的电脑。在电脑病毒的出现那些日子里，电脑都没有连线，而是互相独立的，因此并不会出现小莫礼士所引起的病 疚 疫。如果有某部电脑受到"感染"，失去控制，工作人员只需把它关掉便可。但是当电脑连线逐渐成为社会结构的一部分之后，一个能自我复制的病毒程式便很可能带来无穷的祸害了。因此长久以来，懂得玩"磁蕊大战"游戏的电脑工作者都严守一项有成文的规定：不对普通大众公开这些战争程式的内容。一九八三年，这项规定被打破了。科恩.汤普逊(Ken Thompson)是当年 项杰出电脑奖得奖人。在颁奖典礼上，他作了一个演讲，不但公开地证实了电脑病毒的存在，而且还告诉所有听众怎样写自己的病毒程式。他的同行全都吓坏了，然而这个秘密已经流传出去了。一九八四年，情况愈复杂了。这一年，"科学美国人"月刊(Scientific American)的专栏作家杜特尼(A.K.Dewdney)在五月号写了第一篇讨论"磁蕊大战"的文章，并且只要寄上两块美金，任何读者都可以收到他所写的有关写病毒程式的纲领，在自己家中的电脑中开辟战场。 "病毒"一词的正式出现在一九八五年三月份的"科学美国人"里，杜特尼再次讨论"磁蕊大战"和病毒。在文章的开头他便说："当去年五月有关"磁蕊大战"的文章印出来时，我并没有想过我所谈论的是那么严重的题目"，文中并第一次提到"病毒"这个名称。他提到说，意大利的罗勃托.些鲁帝(Roberto Cerruti)和马高.麽鲁顾帝(Marco Morocutti)发明了一种破坏软体的方法。他们想用病毒，而不是蠕虫，来使得苹果二号电脑受感染。 些鲁帝写了一封信给杜特尼，信内说："马高想写一个像`病毒`一样的程式，可以从一部苹果电脑传染到另一部苹果电脑，使其受到感染。可是我们没法这样做，直到我想到，这病毒要先使磁碟受到感染，而电脑只是媒介。这样，病毒就可以从一 片磁碟传染到另一片磁碟了。 从此出现的病毒种类越来越多，破坏性也越来越强。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/646020865168207d391f6757ccd0919d/" rel="bookmark">
			行业研究报告哪里找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、迈博汇金 http://www.microbell.com/index.asp 点击顶上的“股票研究报告” 然后可用迅雷和快车直接下载，免费的，不用注册。 基本上各大券商每天的报告都有，量比较大，各位可以直接搜索自己想要的报告。 2、全景网 http://www.p5w.net/ 首页的中间位置有个“研究报告”栏目 报告也可以免费下载，不用注册。 另外，各位喜欢投资的朋友还可以经常看看《中国证券报》、《上海证券报》、《经济观察报》和《21世纪经济报道》 除了《经济观察报》，以上报纸的基本内容都是偏向资本市场投资的，《21世纪经济报道》偏行业深度调查。 兄弟我也提供一下它们的网站 中证网 顶部“今日报纸” 点击进入《中国证券报》电子版 http://www.cs.com.cn/ 中国证券网 顶部“上海证券报” 点击进入《上海证券报》电子版 http://www.cnstock.com/ 以下两个网站的电子报纸不是免费的，但是各栏目的内容基本包含了当天报纸的报道，不过这两个还是建议看纸质报纸。《经济观察报》周一出版，《21世纪经济报道》周一至周五出版。 经济观察网 http://www.eeo.com.cn/ 21世纪经济报道 http://www.21cbh.com/ 同时，各位还可以在上海证券交易所、深圳证券交易所的网站看到每天的上市公司公告 上海证券交易所 网站首页顶部的“公告与提示”栏中点击“上市公司公告”可以看到每天的公告，免费下载，也可以查询公司上市以来的所有报告。每天晚上10点左右公布第二天的报告。http://www.sse.com.cn/sseportal/ps/zhs/home.html 深圳证券交易所 网站首页中间位置的“上市公司公告”。每天晚上8点左右公布第二天的报告。http://disclosure.szse.cn/m/drgg.htm 如果各位有志于做证券研究，以上都是每天的功课，必不可少的。还可以每天看看中财网。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68a779d6ade268842d8e2e1e18bdaa6e/" rel="bookmark">
			谈治学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自1945年世界上第一台电子计算机ENIAC问世以来，现代计算机科学已经走过了极为不平凡的六十余年辉煌历程。有时想想，自己不禁感叹，相对于已经发展了几十年甚至上百年的任意一个学科，我们学习的过程实在太短暂了。要充分理解一个领域，时间显然是不够的，更何况现在学科门类越分越细，学科交叉现象越来越多，因此我们往往要同时面对多个领域。如果你是一名研究生或者博士生，有时也可能会感到自己或许已经对某个领域“观其大略、略有小成”。其实自己是否真的已经达到这种状态并不重要，因为几年之后，当我们再回想起来，或者自然会感到当时的稚嫩而不失活泼的劲头。如果现在你的这种感觉愈发强烈，那么就说明你在这个方向上有了不小的跨越和进步。
有人说自己“学得越多就会感到懂得越少，知道的越多就会感到理解的越少”，其实说的就是自己在不停的进步。在现行学习的各种情境下，大家都变得匆忙起来，匆忙的人容易被欺骗，于是我们会听信一些自己或别人有限理解下狭隘的看法，甚至我们会将这些看法作为一种基点，甚至会看作一种准则。就像现在每天网络上都会有海量信息向我们涌来，尽管没有人会对网上的言论负责，但我们确实很容易在不经意之间将浏览网页时看到的一条难辨真伪的消息迅速地、不假思索地信以为真。于是现在漫天飞舞的那些关于某位明星突然病故的谣言才会这么神速地传播开来。八卦谣言如此，学术研究更是如此。这其实也没什么，重要的是我们不能让这种看法伤害到自己以及自己努力的脚步。
大家都会写论文，看论文。看论文讲求看高质量的，这是当然，我们要在前人的基础上做出一点点创新的工作。前人的理论结果在这短暂的过程与浩瀚的领域下似乎只是偏离及错误的程度不同，因为论文是在搞研究，还未出现的一些假想的规则，或是一些假想的解决方案。它们基于的都是另一些研究的成果，“踩在别人的肩膀上，肩膀在哪并不重要，是不是巨人的也不重要，只要以后有人踩踩自己的肩膀就行了”，在这种情况下对与错、是与非、准确与偏离的界限也越来越朦胧。
有时会觉得别人的做法、方式，结果其实并不好。有时甚至往往，其实对与错并不重要，它只是在很多条件，环境，约束下的一种看法。人们所做的事情——只是去让周围最值得注意的一类人群去尽可能满意就已经很好了。现在的媒体、老师，甚至一些同学我觉得都已经具备了把“白的说成黑的，紧接着情况不对又可以再说成白的了”这种惊叹而又平凡的能力。一方面是把白的说成了黑的，而另一方面大部分人选择了默认，欣然接受了指鹿为马的事实。而对于我们每个人，说到底最重要的还是要抓紧时间“多走一点路”，用不断前进的脚步走出各种环境。使自己不用非得把白说成黑来骗取科研成果，更使得别人在把白说成黑的时候我们依然能够保持一份清醒。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/496e9e94f739cf22c0c0d46a66d69ab1/" rel="bookmark">
			jQuery获取CheckBox选择的Value值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 $("input[name='checkbox_name'][checked]"); //选择被选中CheckBox元素的集合 如果你想得到 Value值你需要遍历这个集合 $($("input[name='checkbox_name'][checked]")). each(function(){arrChk+=this.value + ',';});//遍历被选中CheckBox元素的集合 得到Value值 $("#checkbox_id").attr("checked"); //获取一个CheckBox的状态(有没有被选中,返回true/false) $("#checkbox_id").attr("checked",true); //设置一个CheckBox的状态为选中(checked=true) $("#checkbox_id").attr("checked",false); //设置一个CheckBox的状态为不选中(checked=false) $("input[name='checkbox_name']").attr ("checked",$("#checkbox_id").attr("checked"));//根据3,4,5条，你可以分析分析这句代码的意思 $("#text_id").val().split(","); //将Text的Value值以','分隔 返回一个数组 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/463362a557190341d8463a1397061b5b/" rel="bookmark">
			CSize
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSize类 类CSize是对Windows结构SIZE的封装，凡是能用SIZE结构的地方都可以用CSize代替。 结构SIZE表示一个矩形的长度和宽度，其定义为： typedef struct tagSIZE{ LONG cx; LONG cy; } SIZE; 其中 cx、cy分别是宽度和高度。 与CPoint类似，CSize也提供了一些重载运算符。如运算符“+”，“-”，“+=”和“-=”，用于两个CSize对象或一个CSize对象与一个CPoint对象的加减运算，运算符“==”和“！=”用于比较两个CSize对象是否相等。 由于CPoint和CSize都包含两个整数类型的成员变量，他们可以进行相互操作。CPoint对象的操作可以以CSize对象为参数。同样，CSize对象的操作也可以以CPoint对象为参数。如可以用一个CPoint对象构造一个CSize对象，也可以用一个CSize对象构造一个CPoint对象，允许一个CPoint对象和一个CSize对象进行加减运算。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0371e8ef60c3debfcabbe48f2346255c/" rel="bookmark">
			移动了我的文档，但剩下了一个Documents文件夹，怎么也删不掉，怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
我右击我的文档，属性，位置，更改了我的文档的位置，但在C:/Users/%username% 里遗留下了Documents文件夹。删除它，提示要管理员权限，在权限里察看，发现无显示所有者，并且无法更改所有者。
怎么删？
解决方法：
重起电脑（注销没用）既可删除！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/940f6188176c99e9ac0f4c2d1b9c4631/" rel="bookmark">
			找济南 .Net开发的 SOHO 工作者，长期合作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己经常有 .net 方面的程序需要开发，希望找几个济南本地的 SOHO 工作者长期合作
QQ：710906900
E-mail：sdweb2008@126.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b18d7a722e54c98fefeb937983f32699/" rel="bookmark">
			Java 中文分词器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CWSS是一个开源的中文分词系统，其中它有两个版本。一个是提供对lucene3.0的支持。一个是纯中文分词，主要是为了方便大家使用。
CWSS1.0由来
一个星期疯狂啃读中科院和paoding分词过程中，突然想开发一套中文分词。
CWSS1.0的特性：
1、采用了中科院的做法，断句处理，原子处理。
2、基于“词库”切词。
3、支持简繁体。
下载地址
http://code.google.com/p/cwss/
演示地址
http://www.agrilink.cn/cwss.jsp
分词效果示例
原文
CWSS是一个开源的，基于java语言开发的轻量级的中文分词工具包,并提供对lucene3.0的支持。目前正在测试阶段,暂不开源代码.测试完毕.在以GPL开源协议发布.
分词后
CWSS/是/一个/开源/的/基于/java/语言/开发/的/轻量级/量级/的/中文/分词/工具/工具包/并/提供/对/lucene3.0/的/支持/目前/前/正在/测试/阶段/暂/不开/源代码/代码/./测试/完毕/.在以/GPL/开源/协议/发布/./ 原文
作者博客：loiy.javaeye.com 电子邮件：lzj0470@163.com 分词后
作者/博客/loiy.javaeye.com/电子/邮件/lzj0470@163.com/ 原文
甘刑一终字第200号
分词后
甘刑一/终字/第/200/号/
原文
北大学生活动
分词后
北大/学生/活动/ 原文
的的确确实实在在
分词后
的的确确/的确/实实在在/实在/
原文
我和你都很棒
分词后
我/和/你/都很/很棒/
原文
永和服装饰品有限公司
分词后
永和/服装/饰品/有限/公司/
原文
你欠我一万九千八百零五毛
分词后
你/欠/我/一万九千八百零五/毛/ 原文
你到底喜不喜欢我
分词后
你/到底/喜/不/喜欢/我/
原文
你说不说，不说打PP
分词后
你/说不说/不说/打/PP/ package wss.analysis.test; import java.io.BufferedReader; import java.io.File; import java.io.FileReader; import java.io.IOException; import java.io.Reader; import org.apache.lucene.analysis.Analyzer; import org.apache.lucene.document.Document; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b18d7a722e54c98fefeb937983f32699/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3804bdf0ca992cfca0c5f9d538f1cd95/" rel="bookmark">
			fftw的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		六、 更多实数据的DFT 通过一个统一的r2r（real-to-real，实数－实数）接口，FFTW支持其它的一些变换类型，这些变换的输入和输出数组大小相同。这些r2r变换可以分为3个类型：DFT的实 数据输入，complex-Hermitian（指复Hermitian对称）以半复数格式的输出；DCT/DST（离散正余弦变换）；DHT（离散 Hartley变换）。接口如下：
fftw_plan fftw_plan_r2r_1d(int n, double *in, double *out,
fftw_r2r_kind kind, unsigned flags);
fftw_plan fftw_plan_r2r_2d(int n0, int n1, double *in, double *out,
fftw_r2r_kind kind0, fftw_r2r_kind kind1, unsigned flags);
fftw_plan fftw_plan_r2r_3d(int n0, int n1, int n2,
double *in, double *out,
fftw_r2r_kind kind0,
fftw_r2r_kind kind1,
fftw_r2r_kind kind2,
unsigned flags);
fftw_plan fftw_plan_r2r(int rank, const int *n, double *in, double *out, const fftw_r2r_kind *kind, unsigned flags); 这里n为数组的物理尺寸。对于多维变换，数组按行优先方式存储（与C++标准相同，与Fortran不同）。由于DFT是可分离变换，所以2维/3维/多维的变换是在每个维度上分别进行变换得到的，每个维度都可指定一个kind参数，指定该维的变换类型。
1. 半复数格式DFT（HalfComplex-format）
对于大小为n的1维DFT，输出格式如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3804bdf0ca992cfca0c5f9d538f1cd95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8fd004aae84f6f47a15d00a4072f699/" rel="bookmark">
			C# Mandelbrot和Julia分形图像生成程序更新到2010-9-14版 支持多线程计算 多核处理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要源代码的可以留言。需要壁纸的也可以留言，留下邮箱之类的。
M-J算法来自网络，个人集成算法，自创颜色调配算法。欢迎提意见delacroix_xu@sina.com QQ79566076
传送门：历次版本的帖子
MPI分形图像高精度绘制程序和PC端Mandelbrot-Julia分形集预览程序 C#.NET逃逸时间算法生成分形图像的毕业设计完成！晒晒功能
Fractal Producer 分形图像生成器6.06版——含源代码 这个是2009年6月6日的旧版本
Fractal Producer 分形图像生成器5.19版——含源代码 这个是2009年5月19日的旧版本
最新版的下载可以看看下面的链接，只是没有包含源代码
C# 多线程 多核 分形Mandelbrot集Julia集 预览 及 批量生成 程序
http://download.csdn.net/source/2698698
*历史回顾
*
* 2010 - 9 - 14
* 添加NormalizedIterationCount效果
* 即真彩色效果，也叫连续颜色
* 增加参数trueColorFlag
* 代表是否有NormalizedIterationCount效果
*
* 2010 - 9 - 6
* 添加圈选放大功能
* pmax,pmin,qmax,qmin自适应算法的修改
* 恢复上一次的关于“更新一批图像”的修改
*
* 2010 - 9 - 4
* 修正一个小bug，纵横比变化时候，图像不会丢失细节
* 更新一批图像时候，会直接移除所有已有历史记录
*
* 2010 - 9 - 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8fd004aae84f6f47a15d00a4072f699/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43ef8546aa0f1e4e2d2c322f5e6e0374/" rel="bookmark">
			CMMI的5个等级和22个过程域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CMMI将能力成熟度分为5个级别：初始级，已管理级，已定义级，量化管理级，优化级。
这5个成熟度等级为评价软件过程能力提供了一个有序的级别，如图5-10所示。同时也为软件过程改进工作指明了方向，让人们分清轻重缓急，指导人们一步一步地改进过程能力而不是企图跳跃式地前进。
1.初始化--&gt;2.已管理级--&gt;3.已定义级--&gt;4.量化管理级--&gt;5.优化级 除了成熟度等级，CMMI还有一个重要的概念是过程域（Process Area）。过程域指出了达到某个成熟度等级必须要解决的一族问题。除了初始级以外，每个成熟度等级都有若干个过程域，如表5-1所示。由于成熟度等级是循序渐进的，如果想达到某个成熟度等级，例如CMMI 3级，除了满足CMMI 3级本身11过程域之外，还要满足CMMI 2级的7个过程域，依此类推。 CMMI等级
过程域中文名称
过程域英文名称
过程类型
第2级
已管理级
7个过程域
需求管理
Requirements Management
工程
项目规划
Project Planning
项目管理
项目监控
Project Monitoring and Control
项目管理
供应商协议管理
Supplier Agreement Management
项目管理
度量分析
Measurement and Analysis
支持
过程和产品质量保证
Process and Product Quality Assurance
支持
配置管理
Configuration Management
支持
第3级
已定义级
11个过程域
需求开发
Requirements Development
工程
技术方案
Technical Solution
工程
产品集成
Product Integration
工程
验证
Verification
工程
确认
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43ef8546aa0f1e4e2d2c322f5e6e0374/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80cd7e0960aeed27cb7c93af4f5741f9/" rel="bookmark">
			SURF: speed up robust feature
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SURF: speed up robust feature
SURF特点：
1.使用积分图像完成图像卷积（相关）操作;
2，使用Hessian矩阵检测特征值；
3，使用基于分布的描述符（局部信息）。
兴趣点检测相关研究：
1998 Lindberg介绍自动尺度选择的概念，允许检测图像中的兴趣点在它们的特征尺度上。他实验了Hessian矩阵的行列式和Laplacian(和矩阵的迹一致)检测团状结构。
1998 Lowe提出用DOG近似LOG。
2001 Mikolajczyk 和Schmid 重新定义了这个方法，名为Harris-Laplace和Hessian-Laplace。使用Harris或Hessian矩阵的行列式来选择特征点的闻之，使用Laplacian选择尺度。
此外Mikolajczyk（2005，2006）还做了一些算子的比较工作。从中可知：基于Hessian检测器比基于Harris检测器更稳定，重复检测性更好。此外，使用Hessian矩阵的行列式比使用它的迹更有优势。同时也发现使用类似于DOG的近似方法可以提高速度但只损失很小的精度。
描述符的相关研究:
图像特征点的描述符一个共同点是表达了兴趣点邻域内小尺度的特征分布。使得描述符的描述性更好，识别性更高。SIFT的特点正是掌握了空间域亮度模式的大量信息（基于直方图方法：8个方向的箱格，4*4像素）。描述了特征点邻域内点的梯度方向信息，共128维。
PCA-SIFT：36维，匹配速度更快，但区分度下降，并且延长了特征的计算时间。
GLOH：区分度更高但是数据压缩花销时间太长。
2006 Grabner使用积分图像近似SIFT。可以达到和我们同样的速度。但是相比SIFT质量有所下降。（为SURF提供了重要信息积分图像）。
匹配算法：BBF（k-d tree）,balltrees, vocabulary trees, locality sensitine hashing.本文补充提出了，使用Hessian矩阵的迹来显著提高匹配速度。在低维描述符下，任何算法的匹配速度都很快。
二．兴趣点检测。
使用HESSIAN矩阵的近似检测兴趣点。使用积分图像加快计算。
2001 Viola and Jones 提出积分图像的概念。
1998 Simard 提出的盒形计算框架使用积分图像。
本文的创新点：
使用近似的Hessian矩阵来求特征点。DOG近似LOG，盒形滤波近似不同的二次微分。 在3*3*3的邻域范围内寻找Hessian矩阵的行列式最大值。9*9盒形滤波器相当于方差1.2的高斯函数。
图像尺度的改变是通过改变盒形滤波器尺寸实现的。尺度空间的分组时，相邻组首尺度滤波器大小之差相差2倍。如第一二组差6，则二三组差12.为了减少计算时间，第一组采样间隔1像素，第二组2像素，以此倍增。
特征点的精确定位即实现亚像素描述，通过LOWE文章中提出的泰勒级数展开，可求得。
三．特征点描述与匹配
本文提出的是，建立一阶Haar小波在x和y上的响应的分布（局部信息整合），使用积分图像提高计算速度，并且只有64维。使用Laplacian（迹）的符号来索引特征点，方便匹配。
小波变换的重要用途是图像压缩。在图像识别等应用中主要应用于人脸识别和行人识别。
2002 haar-like features
2001 矩形特征与Adaboost（一种级联滤波器，识别）VIOL
1998 a general frame work for object detection
1997 pedestrian detction using wavelet template
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80cd7e0960aeed27cb7c93af4f5741f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d3a53117d4c3dca5eeba54cf4cdc3e4/" rel="bookmark">
			当DRM出错时的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DRM出现错误的原因 数字版权管理 (DRM) 系统损坏，因为网络的不稳定，在下载认证书的时候网络传输出项了错误导致许可证坏了， 不能 正常播放。您可以选择以下提供的解决方法进行操作。 解决方法一 第1步：打开“我的电脑”--此窗口菜单条“工具”--文件夹选项--查看--高级设置-取消“隐藏受保护的操作系统文件 ”的选项，同时选择“隐藏文件和文件夹--显示所有文件和文件夹” 然后点击“应用” 最后“确定” 第2步：打开C盘，打开以“Documents and Settings”命名的文件夹--All user--删除以"DRM"命名的文件夹。 第3步：打开“我的电脑”--此窗口菜单条“工具”--文件夹选项--查看--点击下方的“还原为默认设置”，然后点击 “应用” 最后“确定”。 第4步：重新进行测试，查看问题是否解决，若通过以上操作没有解决，请选择解决方法二操作。 解决方法二 卸载现有播放器后重新下载播放器Windows Media Player安装。建议使用Windows Media Player10版本播放器 卸载Windows Media Player步骤如下：我的电脑--控制面板--添加或删除程序--添加/删除Windows组件--将Windows media Player前的复选框中的对号取消--点击“下一步”--点击“完成”。 安装Windows Media Player： 1)如果您使用的系统为微软正版系统，您可以打开在 用户中心——软件下载——下载媒体播放器，下载一个Windows media player安装在您的电脑上 2）如果您使用的不是正版系统请您直接在网上搜索Windows Media Player播放器下载安装。 转载于:https://blog.51cto.com/duyun/352094
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2f04676387e78d69e1799dcca5d241c/" rel="bookmark">
			PTA是什么？BT-WIFI共存 转帖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蓝牙和WIFI共存设计
蓝牙和802.11b/g/n都可能工作在2.4GISM，可能互相干扰。干扰的典型应用之一是VOIP，用手机的WLAN打VOIP电话，用蓝牙耳机来通话。互相干扰的后果是用户能感觉到通话质量的下降。
设计上有些方法能够减少相互干扰，尽量维持蓝牙和wifi的throughput，使得用户的使用体验不受影响。方法主要是AFH和分时。
是否存在相互干扰和相互干扰是否严重受以下条件影响：
1．共用天线还是单独用自己天线
2．干扰是噪音还是阻塞
3．蓝牙通信频率是否落在wifi带内
4．蓝牙和wifi是接收还是发射
5．蓝牙和wifi的具体应用的通信特点
共用天线还是单独用自己天线
如果蓝牙和wifi使用单独的天线，蓝牙天线和wifi天线之间的隔离大小会影响干扰的程度。如果认为有一定的隔离度，蓝牙和wifi是可以同时发射或者接收的。
如果蓝牙和wifi共用天线，蓝牙和wifi不可以同时工作。（如果不考虑相互干扰，可以同时接收。）
干扰是噪音还是阻塞
干扰分为两种。一种是噪音，主要发生在频率冲突时；另一种是大信号阻塞，和频率是否冲突没有关系，和具体射频设计及天线间隔离有关系。
蓝牙通信频率是否落在wifi带内
如果蓝牙通信频率落在wifi频带内，噪音干扰和阻塞干扰都会有。如果蓝牙通信频率落在wifi频带外，只有阻塞干扰。
AFH是针对噪音干扰最好的方法，蓝牙和wifi的性能都能维持100％。唯一问题是无法解决阻塞干扰。
蓝牙和wifi是接收还是发射
假设蓝牙和wifi使用自己单独的天线，蓝牙和wifi是能够同时发射和同时接收的。如果一个发射，一个接收，在频率冲突时会有相互干扰。另外，同时发射可能会对另一侧设备带来干扰。
蓝牙和wifi的具体应用的通信特点
共存时相互干扰是否严重还和具体应用时通信特点有关。比如数据量是否大，是否是数据流，是否是timecritical的。所以有的设计是host可以根据不同应用配置不同的优先级，以达到最好的tradeoff。
主要设计方法简单介绍:
AFH
AFH是解决噪音干扰的最好方法。通过在跳频频率中避开wifi的频带，既可以避免频率冲突带来的干扰，也丝毫不损失蓝牙和wifi的性能。另外，AFH不只针对wifi干扰，道理上其它干扰源也可以避开。
AFH功能包括两个方面，一是channel的好坏区分；二是使用新的channellist跳频。
Channel的好坏区分有三种来源，一是自己通过scanRSSI或者检查PER等方式自己区分channel；二是通过另侧设备的区分信息，如 master取slave的区分结果，或slave依照master的区分结果；三是依靠host通过HCI命令 set_AFH_host_channel_classification传下来。
蓝牙和wifi共存设计中，host通过HCI命令告诉蓝牙哪些channel不可用是很有效的。如果蓝牙自己区分，应该既自己检查channel，也需要读另侧设备的区分信息，因为两者如果距离稍远，可能看见的badchannel是不同的。
分时（TDM，PTA）
分时是利用蓝牙和wifi间的握手信号，使蓝牙和wifi分时在2.4G工作，这样可以避免噪音干扰和阻塞干扰。问题是会降低蓝牙和wifi的throughput。所以这个机制应该只在AFH不能提供良好效果时使用。
802.15.2中有规定仲裁方式和信号（PTA，packettrafficarbitration）的框架，很多蓝牙芯片厂商也有自己专有的握手信号定义。道理上来讲我们的设计还需要了解主流wifi芯片的握手信号定义。
这些握手信号都差不多。简单说明如下：
2－wire
Wifi给蓝牙信号wl_active，表示wifi有通信，如果这个信号asserted，蓝牙应该只接收/发射highpriority的包，其它包delay。
蓝牙给wifi信号bt_priority，表示蓝牙要发highpriority的包，wifi必须停止当前通信。
可以看出，这两根信号分别是保护wifi和蓝牙通信的。所以assert的多与少会影响2.4G带宽在两者间的分配。
从蓝牙芯片设计的角度，蓝牙芯片必须支持对于包优先级的区分和delay包的处理。一般来说，定时同步，inquiry，page，SCO等是高优先 级，传送数据的包则是普通优先级。如果处理得细致和灵活，很多参数是需要可以配置和可调的，因为可能需要host根据具体应用来配置。
如果蓝牙芯片知道wifi的频带，bt_priority也可以只在频率冲突时拉起。
3－wire
三线方案和两线方案相似。多加一根蓝牙输出的bt_active，这样和bt_priority一起可以表示两种优先级的蓝牙通信。
4－wire
四线方案和三线方案相似，再多加一根蓝牙输出的bt_freq，指示蓝牙通信是否和wifi频带冲突。
PTA
802.15.2中没有规定PTA具体的硬件接口和仲裁判定，是依赖实现的。也有类似上述的2/3/4线方案。但PTA的基本思想是蓝牙和wifi提交 申请给PTAcontroller，（一般PTAcontroller集成在wifi中），由PTAcontroller来许可。所以PTA中的相关信号 都是指将要的操作，不同于上面的是指已经发生的操作。
WCS
WCS是intel的 wirelesscoexistencesystem缩写，是intelwifi的握手定义，两根线，ch_data和 ch_clk/bt_priority，完成握手和频带信号传递功能。具体时序定义没有看到，要签intel的NDA才有，估计笔记本上用得较多。
只要把握分时和优先级的tradeoff原则，握手接口和分时机制还可以有很多变化和配置，以求对用户最好的使用体验。
RDA5868+,RDA5870都支持蓝牙WIFI共存分时设计,在原理图连接时,连接如下:
RDA5870：
Pin37：WL_ACTIVE
Pin27：BT_PRIORITY
RDA5868＋：
Pin28：WL_ACTIVE
Pin27：BT_PRIORIT
转载于:https://www.cnblogs.com/hanny/archive/2010/07/18/1780074.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d1ae869646a8a48add11eeb87fc63c5/" rel="bookmark">
			eclipse xml页面编辑时，确认无误但仍然提示错误的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，我的eclipse版本
3.5
二，错误表现
zul页面编辑时，让人郁闷的是，你确认编写的标签无任何错误
，eclipse仍然提示当前行有错误，当然这不是RPWT,呵呵
三，解决办法：
ctrl+a全选，ctrl+x剪切，ctrl+v重新粘贴进来
如果上述办法仍然错误，您应该尝试终级解决方案：关闭当前页面，重新打开即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17119342dfe43b2fe68ce83ceb426c04/" rel="bookmark">
			优化RIL驱动，巧解WinCE电话漏接难题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着3G移动电话热潮的高涨，我公司许多的嵌入式移动产品也正计划加入无线上网和电话功能。近期，公司委派我负责一个在WinCE 6.0平台下集成移动电话、无线上网和收发 SMS功能的项目。但没有想到的是这个项目却让我陷入到反复调试的痛苦之中。
原因是这个在WinCE 6.0平台下开发的系统经常出现：漏接电话、或有信号但电话无法拨出、或短信收发不正常、或通话自动中断和通话断断续续等问题。初期我怀疑是因为信号质量 问题所导致，所以花了大量时间和精力在硬件上，如天线和GSM射频通讯模块上。但后来却发现原来是我在Win CE 下没有进行优化RIL接口驱动所造成的问题。在这里与大家分享一些在此过程中得到的经验和教训。
一．WinCE系统电话漏接的原因分析
在无线移动通讯上，漏接的意思是指机器设备接通了，但机器设备却没反应。一般来说，这个故障可能出现在两个层面：一是GSM射频通讯基带部分没有发出有来 电的消息；二可能是WinCE系统没有对GSM模块的来电消息做出响应。
（1）硬件上没有发出有来电消息
第一种漏接的原因可能是GSM射频通讯基带部分没有发出有来电的消息，这部份主要是因为GSM硬件上出现了问题，使到系统根本没有输入信号。例如，在有信 号的场合下但电话无法拨出时，很可能就是GSM信号质量出现问题。所谓信号质量问题是指在正常情况下接收到的信号强度明显低于正常标准，这是与GSM射频 硬件相关的故障。因此，我把时间和精力都集中在天线接收和GSM射频通讯硬件上，例如更换增强型的天线和使用经测试合格的GSM射频芯片和基带处理芯片。 但经过多次硬件调试和更换，却发现此问题一直存在，后来我决定先排除对GSM硬件可能存在故障的怀疑。
（2）WinCE系统没有对来电消息做出响应
第二种漏接的原因可能是WinCE系统对来电信号没有做出响应。后来，经过多次调试，我发现问题还真是出在WinCE 6.0系统的软件部分。用专业术语的话说，就是在通讯接口层RIL模块（即Radio Interface Layer，无线接口层）和优先级处理上出了问题。这个RIL层主要是用于沟通WinCE系统与GSM通讯模块，并且对GSM通讯模块的行为做出适当的响 应与动作，例如启动数据连接、发送 SMS 消息等。换句话说就是，当问题出在WinCE软件模块时，就算GSM信号强度提高了，该漏接的还是会漏接，该挂断的还是会挂断。
二．WinCE 6.0 RIL接口驱动详细分析
（1）WinCE 6.0新加入的电话功能 一般来说，要在基于WinCE平台的产品上具备无线通讯功能（如拨号上网、拨打电话、收发短信）的方法有两种：一是选择让用户外接手机模块；二是在嵌入式 产品上集成手机模块。如果是外接手机模块，那么手机只是起到在上网浏览期间接收和发送数据的作用，而如果是嵌入式设备自身集成手机模块，那么就可以很方便 的实现无线通讯的全部功能。 因此，为了实现嵌入式设备更好的增加无线通信功能，WinCE 6.0 提供了连接移动电话网络所需的接口函数。例如，WinCE 6.0 提供了cellcore.dll组件，这个动态链接库扩展了 Win32 API函数，其作用是用以支持各种移动电话服务，例如启动数据连接、发送 SMS 消息等。另一个重要组件是无线接口层 RIL驱动程序 ril.dll。该组件为应用层与移动电话硬件的连接提供了低级别接口。在早先几个版本的WinCE是不支持直接拨打电话和发送 SMS文本消息的。因此，在以前要想在WinCE上构建移动电话，OEM厂商就必须开发自己的接口层，然而这并非易事。现在有了这个RIL接口，要想在 WinCE平台上构建移动电话程序，就不用OEM厂商再自己开发相应的接口层了，这一功能也大大激发OEM厂商在WinCE平台上构建移动电话程序的热 潮。 （2）什么是RIL(Radio Interface Layer)组件？ 在WinCE 6.0新加的RIL无线接口层组件原本是Windows Mobile里的，它的主要工作为连接WinCE操作系统和电话模块，RIL的主要作用是用于维护和关联无线GSM通讯模块的状态和事件消息。微软的帮助 手册是这样介绍RIL的，作为无线通讯的一个非常重要的组件，RIL使各种无线语音和数据应用成为可能，也使到运行在WinCE 6.0上的软件可以通过RIL无缝地与GSM/GPRS或者CDMA2000 1X modem通信。RIL的位置是处于GSM无线基带系统的协议栈之上，而在WinCE系统的CellCore层之下。RIL跟上层通讯主要采用两种方式， 一种是通过Socket发送与接收消息的方式来实现，还有另外一种方式是通过TCP/IP直接访问内核中的shared memory，进行RPC调用，这种方式主要应用在数据模式上。因此，RIL组件能隐藏GSM无线基带硬件上的一些细节，也就使到OEM厂商可以根据自己 的需要将不同型号的无线modem集成到它们的产品之中。 简单的说，就是只要采用了RIL驱动模块和底层的GSM通讯模块，WinCE系统就具有了移动电话的功能。一是因为RIL提供了语音、数据、SMS短信、 SIM卡管理以及STK应用的功能，也包括了EXTAPI、拔号盘等移动电话的其它功能。二是因为从软件的角度来看，RIL工作在PPP、TCP/IP协 议之下，能把AT命令的发送以及Response响应的解析，也能把数据可靠的传输。而且，除了对网络协议的支持，RIL也支持SMS、Voice Call等功能。 （3）RIL驱动程序的结构解析 从RIL组件的功能我们可知，开发一个移动电话的设计起点，是需要有效的进行RIL驱动程序的开发。因为RIL驱动程序为应用程序提供无线通信相关的服 务，包括呼叫控制、短消息、GPRS等功能。而且对于上层应用程序来说，也可以抽象地把RIL驱动程序看作逻辑设备，它只需要和RIL驱动程序通信就能够 获得所需要的服务。因此，RIL接口层驱动可以按照流驱动Stream I/O的规范来设计，这样做的好处是应用程序可以把设备看作文件，通过文件接口来访问RIL。 在WinCE系统中，一个加载式驱动程序通常会被分成与硬件相关的PDD层和与硬件无关的MDD层两部分。MDD实现的是和平台无关的功能，它描述了一个 通用的驱动程序框架，而PDD是和硬件以及平台相关的代码组成。MDD会调用PDD中特定的接口来获取硬件相关的信息。因此，在使用层次型驱动的时候，一 般只需要基于相近的样列驱动程序，针对特定的硬件只修改PDD程序，MDD建立的框架可继续使用。 在根据微软帮助手册的建议，RIL 驱动程序的基本框架最好是采用MDD+PDD结构。一般来说，微软在WinCE中提供了很多通用驱动程序的MDD样本，所以关键在于调试PDD层。因为不 同的GSM/GPRS通讯模块，其PDD层的实现是不一样的。例如，层次模型RIL_XXX是提供给DeviceManger的 stream Interface。而在RIL Service这一层，Dispather 会将request code 分发给相应的function，例如SMS短信息发送。然后SMS 的function 会发消息给 RIL Device，目的是为了请求以AT命令的形式发送给 GSM modem。也就是说，公用的MDD部分已经做好了，现在只需要针对不同的GSM模块进行不同的PDD驱动开发，这样就可以大大地提高开发效率了。 （4）WinCE如何通过RIL实现电话功能?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17119342dfe43b2fe68ce83ceb426c04/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/484/">«</a>
	<span class="pagination__item pagination__item--current">485/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/486/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>