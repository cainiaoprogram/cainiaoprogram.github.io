<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b9a2ccb6656d102708feb0b518ba6c2/" rel="bookmark">
			ResNet 原论文及原作者讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ResNet 论文摘要1. 引入2. 相关工作残差表示快捷连接 3. 深度残差学习3.1. 残差学习3.2. 快捷恒等映射3.3. 网络体系结构普通网络 plain network残差网络 residual network 3.4. 实施 4. 实验4.1. ImageNet分类普通的网络 plain network残差网络 residual network恒等vs.快捷连接更深的瓶颈架构与 SOTA 比较 4.2. CIFAR-10和分析层响应分析探索超过1000层 何凯明大佬现场讲解 ResNet大佬的 PPT ResNet 论文 论文地址：Deep Residual Learning for Image Recognition 摘要 更深的神经网络更难训练。我们提出了一个 残差学习框架，以 简化 比以前使用的网络深度大得多的网络的训练。我们明确地将 ResNet 的层 重新表述为 学习残差函数，也就是 与层输入有关的函数，而 不是学习无关的函数。
残差函数是与层输入有关的函数，是因为 它是用来表示输入和输出之间的差异的。也就是说，残差函数是用来 学习输入到输出的映射的变化量，而不是直接学习输入到输出的映射。
ResNet 的 每个残差块 都试图 学习输入和输出之间的差异，而 不是直接学习输入到输出的映射。这样做的好处是可以让网络更容易优化，也可以 增加网络的深度 而 不会导致退化 问题。
我们提供了 全面的实验证据，表明这些残差网络更 容易优化，并且可以从相当大的深度中获得 精度。在 ImageNet 数据集上，我们评估了深度高达152层的残差网络，比 VGG 网络深8倍，但仍然具有较低的复杂性。这些残差网络的集合在 ImageNet 测试集上的误差达到3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b9a2ccb6656d102708feb0b518ba6c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a828f1abac0d8f7e7806041d3aea8ab/" rel="bookmark">
			计组中各种透明性总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 虚拟存储器，对应用程序员不可见。主存- cache层由硬件自动完成，对程序员不可见。cache纯硬件，程序员不可见。内存，对程序员可见。知识点来源：王道模拟第六套主存-辅存层由硬件和操作系统共同完成，对应用程序员不可见，对系统程序员可见。注：慢表缺页处理由软件完成，快表缺失既可用硬件也可用软件来处理。IR、MAR、MDR、暂存寄存器，对程序员不可见。ACC累加寄存器、通用寄存器、程序状态字寄存器PSW，对用户可见。指令缓冲器、移位器、乘法器、先行进位链，对汇编程序员不可见。注：移位器、乘法器、先行进位链属于运算器的设计。知识点来源：王道模拟第三套程序计数器PC、基址寄存器，中断字寄存器，对汇编程序员可见。计算机系统中微程序的结构和功能，对程序员不可见。 以上内容均来自课本➕408真题原话。
疑问：目前我理解的是用户=应用程序员，系统程序员=汇编程序员。系统程序员大于应用程序员。这一点找不到解释，不知道对不对。
系统中的缓存全部由操作系统管理，对用户是透明的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caecfa26f21d20ce2d72d9a1d16f5aa0/" rel="bookmark">
			鼠标键盘动作的模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 官方JavaDocsApi:Robot 构造方法:模拟鼠标的方法:模拟键盘的方法:屏幕相关方法:控制类方法:开发实例按键常量工具问题mouseMove位置问题 官方JavaDocsApi: java.awt.Robot
Robot，机器人。此类用于为测试自动化、自运行演示程序和其他需要控制鼠标和键盘的应用程序生成本机系统输入事件。Robot 的主要目的是便于 Java 平台实现自动测试。
Robot 可以模拟鼠标和键盘的输入，相当于 Java 版的按键精灵。
按键事件可以利用键盘来控制和执行一些动作，或者从键盘上获取输入，只要按下，释放一个键或者在一个组件上敲击，就会触发按键事件。KeyEvent对象描述事件的特性（按下，放开，或者敲击一个键）和对应的值。java提供KeyListener接口处理按键事件。
当按下一个键时会调用KeyPressed处理器，当松开一个键时会调用KeyReleased处理器，当输入一个统一编码时会调用KeyTyped处理器。如果这个键不是统一码(如功能键，修改键，动作键和控制键)
每个按键事件有一个相关的按键字符和按键代码，分别由KeyEvent中的getKeyChar()和getKeyCode()方法返回
getKeyChar(): char 返回这个事件中和键相关的字符 getKeyCode(): int 返回这个事件中和键相关的整数键 keyPressed(e: KeyEvent) 在源组件上按下一个键后被调用
KeyReleased(e: KeyEvent) 在源组件上释放一个键后被调用
KeyTyped(e: KeyEvent) 在源组件上按下一个键然后释放该键后被调用
Robot 构造方法: // 在基本屏幕坐标系中构造一个 Robot 对象, 如果平台不支持 Robot, 将抛出异常 Robot() // 为给定屏幕设备创建一个 Robot（用于同时使用多个显示设备的情况） Robot(GraphicsDevice screen) 模拟鼠标的方法: // 将鼠标指针移动到指定屏幕坐标 void mouseMove(int x, int y) /** * 按下/释放一个或多个鼠标按钮, 参数说明: * buttons: 鼠标按钮掩码, 一个或多个以下标志的组合: * InputEvent.BUTTON1_MASK 鼠标左键 * InputEvent.BUTTON2_MASK 鼠标中键 * InputEvent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caecfa26f21d20ce2d72d9a1d16f5aa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4169cf4ca0e980b3080a2e067da13934/" rel="bookmark">
			linux备份与恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 ##备份系统 如何备份Ubuntu系统呢？很简单，就像你备份或压缩其它东西一样，使用TAR。和Windows不同，Linux不会限制root访问任何东西，你可以把分区上的所有东西都扔到一个TAR文件里去！
首先成为root用户：
$ sudo su 然后进入文件系统的根目录(当然，如果你不想备份整个文件系统，你也可以进入你想要备份的目录，包括远程目录或者移动硬盘上的目录)：
# cd / 下面是用来备份系统的完整命令：
tar cvpzf backup.tgz --exclude=/proc --exclude=/lost+found --exclude=/backup.tgz --exclude=/mnt --exclude=/sys --exclude=/media / –exclude选项指定了需要排除的备份项，如果有大的文件，也可以先考出来到适当的位置，以节约备份时间；如果更换了机器或者重新进行了磁盘分区，会造成磁盘的uuid改变，造成恢复后的无法启动，如果有这种情况，可以在备份时排除/boot文件夹、/etc/fstab文件和/initrd.img 及/vmlinuz；也可以在恢复时，将待恢复机器的这四个内容考出，待恢复完再考回。
##恢复系统
切换到root用户，并把文件“backup.tgz”拷贝到分区的根目录下。
在 Linux中有一件很美妙的事情，就是你可以在一个运行的系统中恢复系统，而不需要用boot-cd来专门引导。当然，如果你的系统已经挂掉不能启动了， 你可以用Live CD来启动，效果是一样的。你还可以用一个命令把Linux系统中的所有文件干掉，当然在这里我不打算给出这个命令！
使用下面的命令来恢复系统：
# tar xvpfz backup.tgz -C / 如果你的档案文件是使用Bzip2压缩的，应该用：
# tar xvpfj backup.tar.bz2 -C / 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8549d6818c84dd9728d74125bc1f5077/" rel="bookmark">
			树莓派3&#43;B安装原生系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 制作镜像sdcard登陆树梅派 制作镜像sdcard 1、下载Win32 DiskImager，这是一个把镜像写入SD卡的工具 http://sourceforge.net/projects/win32diskimager/
2、下载镜像https://www.raspberrypi.org/downloads/，Raspbian系统是树莓派官方推荐的系统，解压出img镜像文件，点击Write，写入系统。
3、把SD卡放入树莓派中，用网线和路由器连接，树莓派的网口就会亮，路由器也会为树莓派分配IP
登陆树梅派 4、用MobaXterm的ssh登录到树莓派，Raspbian默认的用户名密码是pi/raspberry，接下来就可以操作树莓派了
5、结果SSH连接提示“connection refused”，导致连接树莓派失败。出现错误的原因是自 2016-11-25 官方发布的 Raspbian 系统镜像，系统默认禁用了 SSH 服务。
6、官方的解决方案是：
SSH disabled by default; can be enabled by creating a file with name "ssh" in boot partition 如果有显示器，开机后，在树莓派配置中将SSH开启即可。但在没有显示器，首次开机需要用SSH登陆的时候，就需要在系统烧录完毕后，进入到boot分区盘， 新建一个名为ssh的空白文件就行了。
完成后再将SD卡插回树莓派，就可以正常使用SSH了。但是显示器无法显示，重启后正常。
7、安装VNC，登录好树莓派后，直接在ssh窗口输入
sudo apt-get install tightvncserver 增加一个桌面
tightvncserver 设置vnc密码
用MobaXterm的vnc登录
若要退出可以直接关闭VNC，但此时vncserver还没有被关闭
下面的语句关闭了树莓派的vncserver
vncserver -kill :1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7eb1e538b388db181a2c8035deb9b00/" rel="bookmark">
			PyCharm配置连接centos7开发调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 准备工作远端centos7安装虚拟环境安装步骤：安装虚拟环境创建虚拟环境激活虚拟环境安装依赖退出虚拟环境指定python版本 配置PyCharm远程开发调试修改默认本地工作目录打开PyCharm后先添加一个配置基于前面配置的Interpreter创建项目配置PyCharm端与服务端目录的映射使用远程服务器的终端功能 准备工作 环境列表：
本地：
OS：Win7
工作目录：d:\djproject
服务端：
OS：CentOS7
工作目录：/root/djproject
IP：192.168.2.110
如果你VM中Linux的IP经常变动，建议以hostname的方式进行以上配置，防止ip变动后PyCharm需要改动多处。
给以下文件添加一行配置
C:\Windows\System32\drivers\etc
192.168.2.110 my.linux.vm
远端centos7安装虚拟环境 virtualenv优势：
用来为一个应用创建一套“隔离”的Python运行环境，另外上线流程简单，大大减轻运维人员的出错率，比如每一个项目使用一个docker镜像，在镜像中去安装项目所需的环境，库版本等等。
安装步骤： 安装虚拟环境 pip3 install virtualenv 创建虚拟环境 python3 -m venv venv3 注：python3代替为自己系统已有的版本，会创建一个干净的虚拟环境；
激活虚拟环境 source venv3/bin/activate 激活后，在控制台会有一个带有（venv）的标志，如下：
(venv3) [root@localhost ~]# 安装依赖 在以上完成之后就可以通过命令pip install 来安装python包了，这里安装python包就不需要root权限了，直接就可以安装。在venv虚拟环境中，使用pip安装的包都不会再是全局性的包，只会在当前的虚拟环境中起作用，避免了系统环境的污染。
退出虚拟环境 Deactivate 指定python版本 virtualenv venv -p python3 配置PyCharm远程开发调试 修改默认本地工作目录 依次找到以下路径修改为自己想要的路径即可：PyCharm——&gt;Settings——&gt;Appearance&amp;Behavior——&gt;System Setting——&gt;Project Opening——&gt;Default directory
打开PyCharm后先添加一个配置 这里选Setting，然后添加一个ProjectInterpreter
配置一个ssh的interpreter
点击Apply和OK，PyCharm会做一次同步，请耐心等待
基于前面配置的Interpreter创建项目 测试阶段我们就选一个纯python项目，注意要用第一步配置的那个interpreter，配置好本地和服务端的代码存放的地址
这一步后本地的windows和VM的linux中都会在工作目录创建myproject这个目录，目前里面是空的，因为我们还没有启动开发。
其实此时我们已经完成了代码同步了，无论是你在windows中开发还是直接在Linux中vim开发，都是维护了2个不同的代码版本，你可以通过Deployment里的update、download、sync来选择全项目或者部分代码的整合。当然你一定要有个概念，Linux中的版本是真正测试的版本，也是最终需要发布出去的版本，所以Windows的改动完毕后一定要update后再进行调测。
但是测试并没有大功告成，因为我们在进行代码调测的时候竟然报错了
配置PyCharm端与服务端目录的映射 使用远程服务器的终端功能 目前pycharm的终端是本地终端
和远端不一致
如果要使用远程的终端，非常简单，因为已经配置过远程的解释器，我们点开Tools里的startSSHsession功能，即可选择服务器端的终端功能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7eb1e538b388db181a2c8035deb9b00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27584a7e225bc33f363699472731f32a/" rel="bookmark">
			pycharm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 克隆github上开源项目安装git的最新版本配置github用户名、密码克隆github上的开源项目 使用虚拟环境查看已经安装的模块安装虚拟环境创建虚拟环境默认创建指定版本创建 激活并使用 pip安装及requirements相关指令 克隆github上开源项目 安装git的最新版本 也可以在pycharm中通过检测，来发现是否已经安装，如果没有安装，按提示安装
即可
配置github用户名、密码 没有的话先去github网站注册一个，在pycharm上配置github账号
克隆github上的开源项目 经过上一步。我们已经配置好了Git，现在就可以去克隆那些开源项目了，这个也非常简单。
我们回到PyCharm刚打开时的界面，如图2-1所示：
登陆github，复制项目clone地址
粘贴到下面位置
设定好本地路径，即可点击clone开始克隆。
使用虚拟环境 查看已经安装的模块 C:\Users\gsl&gt;pip list Package Version ---------- ------- Django 1.11.28 pip 21.0.1 PyMySQL 1.0.2 pytz 2021.1 setuptools 41.2.0 安装虚拟环境 C:\Users\gsl&gt;pip install virtualenv Defaulting to user installation because normal site-packages is not writeable Collecting virtualenv Downloading virtualenv-20.4.3-py2.py3-none-any.whl (7.2 MB) |████████████████████████████████| 7.2 MB 54 kB/s Collecting filelock&lt;4,&gt;=3.0.0 Downloading filelock-3.0.12-py3-none-any.whl (7.6 kB) Collecting six&lt;2,&gt;=1.9.0 Downloading six-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27584a7e225bc33f363699472731f32a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3aa5eac29cdb19a01f54e7324a5b272/" rel="bookmark">
			NAT详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 为什么出现了NATNAT定义三种NAT技术静态NAT动态NATPAT(port address Translation） SNAT和DNATNetfilter报文流向内核中数据包的传输过程SNATDNAT 为什么出现了NAT IP地址只有32位，最多只有42.9亿个地址，还要去掉保留地址、组播地址，能用的地址只有36亿左右，但是当下有数以万亿的主机，没有这么多IP地址怎么办，后面有了IPv6，但是当下IPv4还是主流，利用IPv4怎么满足这么多主机的IP地址呢？答案就是NAT，NAT技术使公司、机构以及个人产生以及局域网，然后在各个局域网的边界WAN端口使用一个或多个公网的IPv4进行一对多转换
NAT使用基于session的转换规则
TCP/UDP ：私有Host的Ipv4 + port &lt;======&gt; NAT公网的Ipv4 + port
ICMP ：私有Host的Ipv4 + sessionID &lt;======&gt; NAT公网的Ipv4 + sessionID
NAT定义 NAT是 Network Address Translation 网络地址转换的缩写。
NAT是将私有IP地址通过边界路由转换成外网IP地址，在边界路由的NAT地址转换表记录下这个转换映射记录，当外部数据返回时，路由使用NAT技术查询NAT转换表，再将目标地址替换成内网用户IP地址。
RFC1918规定了三块专有的地址，作为私有的内部组网使用：
A类：10.0.0.0—10.255.255.255 10.0.0.0/8
B类：172.16.0.0—172.31.255.255 172.16.0.0/12
C类：192.168.0.0—192.168.255.255 192.168.0.0/16
这三块私有地址本身是可路由的，只是公网上的路由器不会转发这三块私有地址的流量；当一个公司内部配置了这些私有地址后，内部的计算机在和外网通信时，公司的边界路由会通过NAT或者PAT技术，将内部的私有地址转换成外网IP，外部看到的源地址是公司边界路由转换过的公网IP地址，这在某种意义上也增加了内部网络的安全性。
三种NAT技术 假设一种场景，公司对外的有两个公网IP地址是 191.4.4.1/191.4.4.2，有两台主机A和B，局域网地址分别是192.168.1.2和192.168.1.3
静态NAT 静态NAT就是一对一映射，内部有多少私有地址需要和外部通信，就要配置多少外网IP地址与其对应，并不节省外网IP，所以一般不用
NAT静态映射表
动态NAT 动态NAT是在路由器上配置一个外网IP地址池，当内部有计算机需要和外部通信时，就从地址池里动态的取出一个外网IP，并将他们的对应关系绑定到NAT表中，通信结束后，这个外网IP才被释放，可供其他内部IP地址转换使用，这个DHCP租约IP有相似之处。
NAT动态映射表
PAT(port address Translation） 端口地址转换，也叫端口地址复用)
这是最常用的NAT技术，也是IPv4能够维持到今天的最重要的原因之一，它提供了一种多对一的方式，对多个内网IP地址，边界路由可以给他们分配一个外网IP，利用这个外网IP的不同端口和外部进行通信。
PAT映射表
SNAT和DNAT Netfilter 在linux操作系统中，Netfilter组件是集成在linux内核中扩展各种网络服务的结构化底层框架，在内核级提供防火墙功能。内核中选取五个位置放了五个hook(勾子) function(INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING)，而这五个hook function向用户开放，用户可以通过一个命令工具（iptables）向其写入规则。
报文流向 流入本机：PREROUTING --&gt; INPUT–&gt;用户空间进程
流出本机：用户空间进程–&gt;OUTPUT–&gt; POSTROUTING
转发：PREROUTING --&gt; FORWARD --&gt; POSTROUTING
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3aa5eac29cdb19a01f54e7324a5b272/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48425b45e826fb244a5a74832f7e2284/" rel="bookmark">
			安装python虚拟环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 安装虚拟环境模块2. 安装virtualenvwrapper 工具管理虚拟环境3. 创建虚拟环境（.virtualenvs）文件夹4. 配置CentOS环境变量，使用户能够使用virtualenvwrapper 工具命令5. 创建虚拟环境6.列出虚拟环境列表7.启动虚拟环境8.查看已有的虚拟环境：lsvirtualenv9.删除虚拟环境10.退出虚拟环境开发工具配置虚拟环境新建项目时指定虚拟环境打开已有项目添加虚拟环境 1. 安装虚拟环境模块 在同时存在python2和python3的情况下，首先确定要安装python2或者python3的目录下
如果python命令默认执行python2
pip3 install virtualenv -i https://mirrors.aliyun.com/pypi/simple/ 指定安装python3 前面加python3 - m
python3 -m pip install virtualenv -i https://mirrors.aliyun.com/pypi/simple/ 2. 安装virtualenvwrapper 工具管理虚拟环境 pip3 install virtualenvwrapper -i https://mirrors.aliyun.com/pypi/simple/ python3
python3 -m pip install virtualenvwrapper -i https://mirrors.aliyun.com/pypi/simple/ 3. 创建虚拟环境（.virtualenvs）文件夹 最好是先创建一个工程文件夹，在工程文件夹中再创建虚拟环境文件夹，便于区分其它虚拟环境；或者在当前目录也可，里面会安装对应python的包。
mkdir .virtualenvs 4. 配置CentOS环境变量，使用户能够使用virtualenvwrapper 工具命令 确定virtualenvwrapper.sh文件位置
whereis virtualenvwrapper.sh [root@testapi ~]# whereis virtualenvwrapper.sh virtualenvwrapper: /usr/local/bin/virtualenvwrapper.sh [root@testapi ~]# vi .bashrc # 结尾增加 export WORKON_HOME=~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48425b45e826fb244a5a74832f7e2284/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f019b70ad8da6059b0830644068b07f8/" rel="bookmark">
			AI文本转音乐免费工具(生成中文歌曲)您心动了吗（生成式AI音乐模型应用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 AI文本转音乐免费工具(生成中文歌曲)您心动了吗（生成式AI音乐模型应用）
就问您心动不心动，您只需输入想要的歌词，AI音乐工具就会自动为您生成一段富有情感、旋律动人的音乐，省却了复杂的乐器演奏和编曲过程，为您的创作，提供前所未有的便捷。它还支持多种音乐风格，从流行、摇滚到电子音乐。
文本转音乐免费工具（生成式AI音乐模型应用）轻松圆梦音乐家
请叫我音乐家，哈哈哈。。。。
[ 视频安全 ] 相关原创文章 教育教学类视频如何处理加密与安全（组图）防止360浏览器小窗下载视频视频安全之视频播放密码功能(设置观看密码功能教程)视频安全之授权播放和防录屏跑马灯企业级微信视频直播如何设定观看白名单（设定手机观看白名单、授权观看直播）在线教育网站如何更好的实现视频安全视频保护？免费视频二维码的完整使用教程（适合小企业做微信视频宣传） Html5视频video标签中使用blob实现视频播放加密 [ 视频直播 ] 相关原创文章 云直播客户端4.0活动拍摄类直播与教学培训类直播测试视频直播画中画效果（边角叠加、去背景、并列布局三种效果）做视频直播时如何测试本地网络的上行带宽(网速测试)在线导播台（网页导播台）混流效果云课堂直播功能介绍，更贴合在线教育、企业内训的场景应用微信公众号直播有哪些不一样的玩法？企业年会活动常用的音频类、视频类工具软件 [ 视频存储与应用 ] 相关原创文章 企业网站如何插入第三方平台不带广告的宣传宣传片最全的视频格式分类详解（那是相当的全面）FMS/wowza/red5/SRS流媒体服务器产品对比无广告的免费视频存储空间并提供视频上传转码的功能，很不错的哦说说视频编码格式、视频码率、视频帧率、分辨率的概念免费视频存储平台（微云、百度网盘、谷歌硬盘、酷播云）的截图对比 [ 视频播放器 ] 相关文章 HTML5倍数功能视频播放器（加速2倍，1.5倍播放）去掉h5播放器中voide标签中的下载按钮blob用法实例:http地址的原理及生成方法如何禁止视频在手机移动端页面中全屏播放 [ WebRTC ] 相关文章 企业级无延时直播来了，用了就回不去了（webRTC）rtmp直播和webrtc直播对比优劣何在? [ 谷歌浏览器 ] 相关文章 谷歌5款插件推荐：谷歌工具类、翻译类扩展程序10款好用的谷歌chrome浏览器插件、扩展程序，用起来很爽哦提高效率：17款超赞的谷歌chrome浏览器插件、扩展程序 [ 微信公众号运营 ] 相关文章 公众号如何实现视频列表播放视频的功能微信公众号推广的40个有效果的方法在微信公众号中如何添加【自定义菜单】，原创图文教程精心整理10个高逼格的优质素材（视频、图片）网站在微信公众号中添加外部的链接图文教程视频分享到微信完整教程（转发给微信好友、微信群、微信朋友圈） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80fdfde42ca06ec29f9d1aa4e4499440/" rel="bookmark">
			img镜像如何制作虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、准备工作二、操作步骤1.把新建的虚拟磁盘挂载到虚拟机2.把需要的文件拷贝到虚机中3、 烧录 总结 前言 一般制作虚拟机都是使用iso镜像，如果遇到img格式的文件如何制作呢，方法也是比较简单的，不需要转换格式，直接用balenaEtcher-Portable-1.7.9工具即可完成。
一、准备工作 一台现成的windows虚拟机；一块新建的虚拟磁盘，用作把镜像烧录其中；烧录工具balenaEtche；被烧录的镜像img文件，这里openwrt镜像文件为例。
二、操作步骤 1.把新建的虚拟磁盘挂载到虚拟机 控制器id和位置不能是已占用的，如果没有位置，重新添加个控制器。
代码如下（示例）：
2.把需要的文件拷贝到虚机中 e盘是新加盘，img将烧录其中。
3、 烧录 烧录速度很快，烧录完成可以调整磁盘控制器和位置顺序，即启动顺序，测试启动过程，看是否烧录成功。
总结 过程非常简单，烧录后即可使用，不用再安装系统；如果想把磁盘转换为iso镜像，安装响应工具，即可转换。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22978a52cd976a3c29d51e05840e31b9/" rel="bookmark">
			centos7 网卡聚合bond0模式配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是网卡bond二、网卡bond的模式三、配置bond0 一、什么是网卡bond 所谓bond，就是把多个物理网卡绑定成一个逻辑上的网卡，使用同一个IP工作，在增加带宽的同时也可以提高冗余性，一般使用较多的就是来提高冗余，分别和不同交换机相连，提高可靠性，但有时服务器带宽不够了也可以用作增加带宽。
二、网卡bond的模式 bond 0 负载均衡 轮询方式往每条链路发送报文，增加带宽和容错能力。容易出现数据包无序到达的问题，数据包重发后吞吐量下降，性能增长不理想。
bond 1 主备策略 主备策略为两个网卡中只有一个在工作就行，另一个完全待机。
bond 2 平衡策略 通过算法聚和端口，增加带宽，提高容错率，当一条有问题会由另一条接管。适合本地网络配置，如果通过单个路由器或只有一个网关算法将无意义。
bond 3 广播策略 该策略bond端口会复制报文往下端口分别传输。该方案由较好的容错机制，适合金融行业，不容易出问题。
bond 4 动态链路聚合 该协议需要上线链路支持LACP(链路汇聚控制协议)协议，端口状态通过该协议自动维护。可以增加带宽，由容错能力，链路出问题会切换到正常的端口，但是增加了LACP协议 所以该协议会发送LACPDU报文来维护链路聚合状态，保证链路质量。
bond 5 适配器传输负载均衡 balance-tlb 在每个物理接口上根据当前的负载（根据速度计算）分配外出流量。如果正在接收数据的物理接口出故障了，另一个物理接口接管该故障物理口的MAC地址。
bond 6 适配器适应性负载均衡 balance-alb 支持负载均衡，也不需要交换机支持，负载均衡通过ARP协商实现。bonding驱动截获本机发送的ARP应答，并把源硬件地址改为bond中某个物理接口的唯一硬件，从而是的不同的对端使用不同的硬件地址进行通讯。 6和0的区别是 0是平均分配，6是一个满了换下一个。
三、配置bond0 进入 /etc/sysconfig/network-scripts 目录下创建一个文件 ifcfg-bond0或cp ifcfg-eth0 ifcfg-bond0
Vi ifcfg-bond0 编辑内容如下
DEVICE=bond0 BOOTPROTO=static IPADDR=192.168.10.1 NETMASK=255.255.255.0 GATEWAY=192.168.10.254 ONBOOT=yes TYPE=Ethernet VI ifcfg-eth0 编辑内容如下
DEVICE=eth0 BOOTPROTO=static ONBOOT=yes MASTER=bond0 SLAVE=yes VI ifcfg-eth2 编辑内容如下
DEVICE=eth2 BOOTPROTO=static ONBOOT=yes MASTER=bond0 SLAVE=yes 编辑 vi /etc/ modprobe.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22978a52cd976a3c29d51e05840e31b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e06b8d0df8089ef887f01cafaebf41a5/" rel="bookmark">
			成功解决kaggle注册报错Captcha must be filled out.（Microsoft Edge浏览器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		成功解决kaggle注册报错Captcha must be filled out.（Microsoft Edge浏览器） 如图：
解决方法 1、Microsoft Edge浏览器输入edge://extensions/获取扩展，搜索Header Editor
2、Microsoft Edge浏览器输入edge://extensions/获取扩展，找到下载好的Header Editor点击详细信息——》扩展选项——》导出导入——》输入url——》点击下载——》点击保存
//url https://azurezeng.com/static/HE-GoogleRedirect.json //推荐输入 或者 https://azurezeng.github.io/static/HE.GoogleRedirect.json 3、在Microsoft Edge浏览器重新输入https://www.kaggle.com/进行注册即可解决
谷歌浏览器解决方案看此博客：https://blog.csdn.net/weixin_50083085/article/details/135066415
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1209575196557acfca3be25123cc7d50/" rel="bookmark">
			TypeScript【可选属性、只读属性、额外的属性检查、函数类型、类类型、继承接口】(四)-全面详解（学习总结---从入门到深化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
接口_可选属性
接口_只读属性
接口_额外的属性检查 接口_ 函数类型 接口_类类型
接口_继承接口
接口_可选属性 接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用 “option bags” 模式时很常用，即给函数传入的参数对象中只有部分属性赋值了 带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 ? 符号 interface SquareConfig { color?: string; width?: number; } function createSquare(config: SquareConfig) { let newSquare = { color: "white", area: 100 } if (config.color) { newSquare.color = config.color; } if (config.width) { newSquare.area = config.width * config.width; } return newSquare; } let mySquare = createSquare({ color: "black" }); console.log(mySquare) 可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare 里的 color 属性名拼错，就会得到一个错误提示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1209575196557acfca3be25123cc7d50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50b99c153a26f634df1c92dff20b3dda/" rel="bookmark">
			《十堂课学习 Flink》第五章：Table API 以及 Flink SQL 入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四章中介绍了 DataStream API 以及 DataSet API 的入门案例，本章开始介绍 Table API 以及基于此的高层应用 Flink SQL 的基础。
5.1 Flink Table &amp; SQL 基础知识 Flink 提供了两个关系API——Table API 和 SQL——用于统一的流和批处理。Table API 是一种针对Java、Scala和Python的语言集成查询API，它允许以非常直观的方式组合来自关系运算符（如选择、筛选和联接）的查询。Flink的SQL支持基于Apache Calcite，后者实现了SQL标准。无论输入是连续的（流式）还是有界的（批处理），在任一接口中指定的查询都具有相同的语义并指定相同的结果。
Table API和SQL接口与彼此以及Flink的DataStream API无缝集成。您可以轻松地在所有API和基于它们构建的库之间切换。
SQL是数据分析中使用最广泛的语言。Flink的Table API和SQL使用户能够用更少的时间和精力定义高效的流分析应用程序。此外，Flink Table API和SQL得到了有效的优化，它集成了大量的查询优化和优化的运算符实现。但并非所有优化都是默认启用的，因此对于某些工作负载，可以通过启用某些选项来提高性能。
5.2 DataStream / DataSet API &amp; Table API &amp; SQL 之间的关系 如下图所示，现在从下往上我们逐层介绍。
最低级别的抽象只是提供有状态和及时的流处理。它通过Process Function嵌入到DataStream API中。它允许用户自由处理来自一个或多个流的事件，并提供一致的容错状态。此外，用户可以注册事件时间和处理时间回调，使程序能够实现复杂的计算。在实践中，许多应用程序不需要上面描述的低级抽象，而是可以根据核心API进行编程：DataStream API（有界/无界流）。这些流畅的API为数据处理提供了通用的构建块，如各种形式的用户指定的转换、联接、聚合、窗口、状态等。在这些API中处理的数据类型在各自的编程语言中表示为类。
低级别的Process Function与DataStream API集成在一起，从而可以按需使用低级别的抽象。数据集API在有界数据集上提供了额外的基元，如循环/迭代。Table API是一个以表为中心的声明性DSL，表可以是动态变化的表（当表示流时）。Table API遵循（扩展的）关系模型：表附加了一个模式（类似于关系数据库中的表），API提供了类似的操作，如选择、项目、联接、分组传递、聚合等。Table API程序以声明的方式定义了应该执行的逻辑操作，而不是确切地指定操作代码的外观。虽然Table API可以通过各种类型的用户定义函数进行扩展，但它的表达能力不如Core API，使用起来更简洁（编写的代码更少）。此外，Table API 程序还通过一个优化器，该优化器在执行之前应用优化规则。
可以在表和数据流/数据集之间无缝转换，允许程序将表API与数据流和数据集API混合。Flink提供的最高级别抽象是SQL。这种抽象在语义和表达上都类似于Table API，但将程序表示为SQL查询表达式。SQL抽象与Table API密切交互，SQL查询可以在Table API中定义的表上执行。 5.3 Flink Table API 添加依赖 在前面的例子中，我们已经添加了 flink-clients 核心依赖，现在使用Table API 时，需要额外添加两个依赖，如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50b99c153a26f634df1c92dff20b3dda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b9f211e25f93fdefe4cb24090070a44/" rel="bookmark">
			Laravel 5.0 框架查看执行过的SQL语句(打印SQL)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式一 1.在routes.php中添加如下语句 // backend/app/Http/routes.php 最末尾添加即可
Event::listen('illuminate.query', function($sql,$param) {
file_put_contents(public_path().'/sql.log',$sql.'['.print_r($param, 1).']'."\r\n",8);
});
2.在执行我sql语句后，查看public目录下sql.log【backend/public/sql.log】，即可看到刚才执行过的sql语句
结果如下：
select * from `u3d_texture2d` where `testid` = ? and `name` = ? and `format` = ? and `width` = ? and `height` = ? and `mipmapcount` = ? and `alphalstransparency` = ? and `anisolevel` = ? and `filtermode` = ? and `ispowertwo` = ? and ROUND(resourcesize/1024, 2) = 12288.000000
[Array
(
[0] =&gt; 88
[1] =&gt; AA_InBattle_0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b9f211e25f93fdefe4cb24090070a44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80f861585684bb2a3a1a47474bf9089a/" rel="bookmark">
			RocketMQ EventBridge 核心概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 理解EventBridge中的核心概念，能帮助我们更好的分析和使用EventBridge。本文重点介绍下EventBridge中包含的术语：
EventSource：事件源。用于管理发送到EventBridge的事件，所有发送到EventBridge中的事件都必须标注事件源名称信息，对应CloudEvent事件体中的source字段。EventBus：事件总线。用于存储发送到EventBridge的事件。EventRule：事件规则。当消费者需要订阅事件时，可以通过规则配置过滤和转换信息，将事件推送到指定的目标端。FilterPattern：事件过滤模式，用于在规则中配置过滤出目标端需要的事件。Transform：事件转换，将事件格式转换成目标端需要的数据格式。EventTarget：事件目标端，即我们真正的事件消费者。 下面，我们具体展开：
EventSource​ 事件源，代表事件发生的源头，用来描述一类事件，一般与微服务系统一一对应。比如：交易事件源、考勤事件源等等。事件源，是对事件一个大的分类，一个事件源下面，往往会包含多种事件类型(type)，比如交易事件源下面，可能包含：下单事件、支付事件、退货事件等等。
另外，需要值得注意的是，事件源并不用来描述发生事件的实体，取而代之的是，在CloudEvent中，我们一般选用subject来表示产生这个事件的实体资源。事件源有点像市场经济大卖场中的大类分区，例如：生鲜区、日化日用区、家用电器区等等。在事件中心这个"大卖场"，我们可以通过事件源快速的找到我们需要的事件。
EventBus​ 事件总线是存储事件的地方，其下可以有多种实现，包括Local、RocketMQ、Kafka等。
事件生产者发送事件的时候，必须指定事件总线。事件总线是EventBridge的一等公民，其他所有资源都围绕事件总线形成逻辑上的隔离，即：事件源、事件规则必须都隶属于某一个事件总线下。不同事件总线下的事件源和事件规则可以重名，但是同一个事件总线下的事件源和规则必须不重名。
EventRule​ 当消费者需要订阅事件时，可以通过事件规则配置过滤和转换信息，将事件推送到指定的目标端。所以，事件规则包含三部分：事件过滤+事件转换+事件目标。
FilterPattern​ 通过事件过滤模式，我们可以对事件总线上的事件进行过滤，只将目标端需要的事件推送过去，以减少不必要的开通，同时减轻消费者 Target端的压力。目前EventBridge支持的事件过滤能力包括：
指定值匹配前缀匹配后缀匹配除外匹配数值匹配数组匹配以及复杂的组合逻辑匹配 （详细介绍待见其他文章）
Transform​ 生产者的事件可能会同时被多个消费者订阅，但不同消费者需要的数据格式往往不同。这个时候，需要我们将生产者的事件，转换成消费者 Target端需要的事件格式。目前EventBridge支持的事件转换能力包括：
完整事件：不做转换，直接投递原生 CloudEvents；部分事件：通过 JsonPath 语法从 CloudEvents 中提取出需要投递到事件目标的内容；常量：事件只起到触发器的作用，投递内容为常量；模板转换器：通过定义模板，灵活地渲染投递出去的事件格式； （详细介绍待见其他文章）
EventTarget​ 事件目标端，也即我们的事件消费者。在EventBridge架构中，消费者只需要按照自己的业务领域模型设计，提供一个公共的API（这个API既可用来接收事件，同时也用来前台管控面操作），EventBridge就会按照API定义需要的数据格式，将事件安全、可靠的推送给 Target消费者。
原文出自：RocketMQ 官网 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b430ebe57b5ce6e50cf04b49dc19959/" rel="bookmark">
			开源学习项目推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 koodo-reader凤凰架构学习项目NPS 内网穿透客户端 koodo-reader 项目地址：https://github.com/koodo-reader/koodo-reader
介绍：一个开源的阅读器，阅读pdf也有目录，作为epub阅读器和pdf阅读器看资料挺好
凤凰架构 项目地址：https://github.com/fenixsoft/awesome-fenix
这个项目是一个在线的学习资料，周志明大佬的这本书我已经买了写得非常好
学习项目 项目地址：https://github.com/chestnutLeaves/classes
介绍：一个视频课程资源学习项目，涵盖项目实战、体系课程、IT训练营、Java实战、Python实战、豪华大课、涵盖Web前端、Html/Css、Android实战项目、React、大数据、软件测试、Python、Vue、算法、人工智能、数据分析 资料非常全。
NPS 内网穿透客户端 项目地址：https://github.com/ehang-io/nps
介绍：一个开源的内网穿透服务，只需要一个公网服务器，就可以实现公网访问家里电脑上的服务。不过项目太久没更新，愿意折腾的可以装frp，nps的管理面板挺好用。项目太久没更新有人发起了维护的新项目修复一些漏洞，新项目地址是：https://github.com/yisier/nps
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9153952597adf23868682bc03f01f1e/" rel="bookmark">
			【Mybatis】日常知识点随笔（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
【K】Mybatis使用@Select注解书写简单sql
【K】MySQL 数据类型与 Java 类型的对应关系
【K】Mybatis相同代码复用
1. 定义公共 SQL 片段
2. 引用公共 SQL 片段
3. 使用参数
4. 复用和组合
5. 注意事项
【K】mysql如何实现插入一条数据后立刻获取该数据自增长id进行调用
背景解析
代码使用
【K】Mybatis新增数据，存在就更新，不存在就添加
常规方法
Replace关键字
【K】MyBatis执行多个sql语句
背景
代码举例
实例举例
分析总结
【K】Mybatis 不同条件拼接不同sql
举例1
举例2: 判断某一个值
举例3
【K】-IFNULL处理N/A
背景知识
SQL语句分析
改进后的SQL语句
知识扩展
注意事项
【K】Mybatis条件查询＜where＞标签
【K】使用resultMap封装对象一对多
数据库模型
实体类
MyBatis 配置
举例
【K】Mybatis使用常见类型的类型别名
【K】Mybatis使用@Select注解书写简单sql //1. 基本查询 @Select("SELECT * FROM users WHERE id = #{id}") User selectUserById(int id); //2. 动态查询 @Select("&lt;script&gt;" + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9153952597adf23868682bc03f01f1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/649b2560a300f81b30668e81acefa6f2/" rel="bookmark">
			Termux安装图形桌面xfce4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考前面几篇文章，安装 Termux 和 SSH 后，远程登录到 Termux 上，此时会提示
$ ssh u0_a390@192.168.31.250 -p 8022 u0_a390@192.168.31.250's password: Welcome to Termux! Community forum: https://termux.com/community Gitter chat: https://gitter.im/termux/termux IRC channel: #termux on libera.chat Working with packages: * Search packages: pkg search &lt;query&gt; * Install a package: pkg install &lt;package&gt; * Upgrade packages: pkg upgrade Subscribing to additional repositories: * Root: pkg install root-repo * X11: pkg install x11-repo Report issues at https://termux.com/issues 其中提示可以通过“pkg install x11-repo” 安装图形包使用的源
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/649b2560a300f81b30668e81acefa6f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86405b1ab8b637f9ef045a27fb742741/" rel="bookmark">
			Android13音频录制适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android13音频录制适配 前言： 之前写过一篇音频录制的文章，当时是在Android10以下的手机可以成功录制和播放，但是Android10及以上手机提示创建文件失败，最近做过Android13的适配，索性一起把之前的录音也适配了，记录一下适配的过程。
1.Manifest添加Android13文件读写适配： &lt;!--存储图像或者视频权限--&gt; &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" android:maxSdkVersion="32" /&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" tools:ignore="ScopedStorage" android:maxSdkVersion="32"/&gt; &lt;!--录制音频权限--&gt; &lt;uses-permission android:name="android.permission.READ_MEDIA_AUDIO"/&gt; &lt;uses-permission android:name="android.permission.READ_MEDIA_VIDEO"/&gt; &lt;uses-permission android:name="android.permission.READ_MEDIA_IMAGES"/&gt; 2.Android13文件读写权限请求： private void requestBasicPermission() { final RxPermissions rxPermissions = new RxPermissions(this); StringBuilder rationaleSb = new StringBuilder(); StringBuilder deniedSb = new StringBuilder(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) { permissions = new String[]{ Manifest.permission.READ_MEDIA_AUDIO, Manifest.permission.READ_MEDIA_VIDEO, Manifest.permission.READ_MEDIA_IMAGES, Manifest.permission.RECORD_AUDIO, }; } else { permissions = new String[]{ Manifest.permission.RECORD_AUDIO, Manifest.permission.WRITE_EXTERNAL_STORAGE,}; } rxPermissions.requestEach(permissions).subscribe(new Observer&lt;Permission&gt;() { @Override public void onSubscribe(@NonNull Disposable d) { } @Override public void onNext(@NonNull Permission permission) { if (permission.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86405b1ab8b637f9ef045a27fb742741/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e2959ef45218158ba17c971bcd5d018/" rel="bookmark">
			基于代码一步一步教你深度学习中循环神经网络(RNN)的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当谈到基于RNN（循环神经网络）的机器学习例子时，一个常见的任务是文本生成。RNN是一种能够处理序列数据的神经网络，它具有记忆能力。以下是一个基于RNN的文本生成例子，并给每一行添加了详细注释：
import torchimport torch.nn as nnimport torch.optim as optim # 定义文本数据集text = “Hello, how are you?” # 创建字符索引映射表chars = list(set(text))char2idx = {c: i for i, c in enumerate(chars)}idx2char = {i: c for i, c in enumerate(chars)} # 将文本转换为数字序列data = [char2idx[c] for c in text] 在这个例子中，我们首先定义了一个文本数据集text，它包含了要生成的文本。
接下来，我们创建了字符索引映射表。我们使用set(text)得到文本中的唯一字符，并使用enumerate为每个字符分配一个索引。char2idx是字符到索引的映射表，idx2char是索引到字符的映射表。
然后，我们将文本转换为数字序列。通过遍历文本中的每个字符，并使用char2idx将字符映射为对应的索引，得到一个数字序列作为我们模型的输入。
# 定义RNN模型class RNN(nn.Module): def init(self, input_size, hidden_size, output_size): super(RNN, self).init() self.hidden_size = hidden_size self.embedding = nn.Embedding(input_size, hidden_size) self.rnn = nn.RNN(hidden_size, hidden_size) self.fc = nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e2959ef45218158ba17c971bcd5d018/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b82299f7df3ee3518fd5d40fbdb2f8/" rel="bookmark">
			小白看得懂的 Transformer (图解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.导语 谷歌推出的BERT模型在11项NLP任务中夺得SOTA结果，引爆了整个NLP界。而BERT取得成功的一个关键因素是Transformer的强大作用。谷歌的Transformer模型最早是用于机器翻译任务，当时达到了SOTA效果。Transformer改进了RNN最被人诟病的训练慢的缺点，利用self-attention机制实现快速并行。并且Transformer可以增加到非常深的深度，充分发掘DNN模型的特性，提升模型准确率。在本文中，我们将研究Transformer模型，理解它的工作原理。
出处： https://blog.csdn.net/longxinchen_ml/article/details/86533005 原作者：Jay Alammar 原链接： https://jalammar.github.io/illustrated-transformer 2.正文开始
Transformer由论文《Attention is All You Need》提出，现在是谷歌云TPU推荐的参考模型。论文相关的Tensorflow的代码可以从GitHub获取，其作为Tensor2Tensor包的一部分。哈佛的NLP团队也实现了一个基于PyTorch的版本，并注释该论文。
在本文中，我们将试图把模型简化一点，并逐一介绍里面的核心概念，希望让普通读者也能轻易理解。
Attention is All You Need：
https://arxiv.org/abs/1706.03762
从宏观的视角开始 首先将这个模型看成是一个黑箱操作。在机器翻译中，就是输入一种语言，输出另一种语言。
那么拆开这个黑箱，我们可以看到它是由编码组件、解码组件和它们之间的连接组成。
编码组件部分由一堆编码器（encoder）构成（论文中是将6个编码器叠在一起——数字6没有什么神奇之处，你也可以尝试其他数字）。解码组件部分也是由相同数量（与编码器对应）的解码器（decoder）组成的。
所有的编码器在结构上都是相同的，但它们没有共享参数。每个解码器都可以分解成两个子层。
从编码器输入的句子首先会经过一个自注意力（self-attention）层，这层帮助编码器在对每个单词编码时关注输入句子的其他单词。我们将在稍后的文章中更深入地研究自注意力。
自注意力层的输出会传递到前馈（feed-forward）神经网络中。每个位置的单词对应的前馈神经网络都完全一样（译注：另一种解读就是一层窗口为一个单词的一维卷积神经网络）。
解码器中也有编码器的自注意力（self-attention）层和前馈（feed-forward）层。除此之外，这两个层之间还有一个注意力层，用来关注输入句子的相关部分（和seq2seq模型的注意力作用相似）。
将张量引入图景
我们已经了解了模型的主要部分，接下来我们看一下各种向量或张量（译注：张量概念是矢量概念的推广，可以简单理解矢量是一阶张量、矩阵是二阶张量。）是怎样在模型的不同部分中，将输入转化为输出的。
像大部分NLP应用一样，我们首先将每个输入单词通过词嵌入算法转换为词向量。
每个单词都被嵌入为512维的向量，我们用这些简单的方框来表示这些向量。
词嵌入过程只发生在最底层的编码器中。所有的编码器都有一个相同的特点，即它们接收一个向量列表，列表中的每个向量大小为512维。在底层（最开始）编码器中它就是词向量，但是在其他编码器中，它就是下一层编码器的输出（也是一个向量列表）。向量列表大小是我们可以设置的超参数——一般是我们训练集中最长句子的长度。
将输入序列进行词嵌入之后，每个单词都会流经编码器中的两个子层。
接下来我们看看Transformer的一个核心特性，在这里输入序列中每个位置的单词都有自己独特的路径流入编码器。在自注意力层中，这些路径之间存在依赖关系。而前馈（feed-forward）层没有这些依赖关系。因此在前馈（feed-forward）层时可以并行执行各种路径。
然后我们将以一个更短的句子为例，看看编码器的每个子层中发生了什么。
现在我们开始“编码” 如上述已经提到的，一个编码器接收向量列表作为输入，接着将向量列表中的向量传递到自注意力层进行处理，然后传递到前馈神经网络层中，将输出结果传递到下一个编码器中。
输入序列的每个单词都经过自编码过程。然后，他们各自通过前向传播神经网络——完全相同的网络，而每个向量都分别通过它。
从宏观视角看自注意力机制 不要被我用自注意力这个词弄迷糊了，好像每个人都应该熟悉这个概念。其实我之也没有见过这个概念，直到读到Attention is All You Need 这篇论文时才恍然大悟。让我们精炼一下它的工作原理。
例如，下列句子是我们想要翻译的输入句子：
The animal didn’t cross the street because it was too tired 这个“it”在这个句子是指什么呢？它指的是street还是这个animal呢？这对于人类来说是一个简单的问题，但是对于算法则不是。
当模型处理这个单词“it”的时候，自注意力机制会允许“it”与“animal”建立联系。
随着模型处理输入序列的每个单词，自注意力会关注整个输入序列的所有单词，帮助模型对本单词更好地进行编码。
如果你熟悉RNN（循环神经网络），回忆一下它是如何维持隐藏层的。RNN会将它已经处理过的前面的所有单词/向量的表示与它正在处理的当前单词/向量结合起来。而自注意力机制会将所有相关单词的理解融入到我们正在处理的单词中。
当我们在编码器#5（栈中最上层编码器）中编码“it”这个单词的时，注意力机制的部分会去关注“The Animal”，将它的表示的一部分编入“it”的编码中。
请务必检查Tensor2Tensor notebook ，在里面你可以下载一个Transformer模型，并用交互式可视化的方式来检验。
从微观视角看自注意力机制 首先我们了解一下如何使用向量来计算自注意力，然后来看它实怎样用矩阵来实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25b82299f7df3ee3518fd5d40fbdb2f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7461664bd6a8162df2aa407b29bfc8c/" rel="bookmark">
			尚硅谷Docker笔记-基础篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B站视频：https://www.bilibili.com/video/BV1gr4y1U7CY
1.Docker简介 解决了运行环境和配置问题的软件容器
方便做持续集成并有助于整体发布的容器虚拟化技术
容器与虚拟机比较 Docker 容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统虚拟机则是在硬件层面实现虚拟化。与传统的虚拟机相比，Docker 优势体现为启动速度快、占用体积小。
比较 Docker 和传统虚拟化方式的不同之处:
传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程
容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便
每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。
比较类型Docker容器虚拟机（VM）操作系统与宿主机共享OS宿主机OS上运行虚拟机OS存储大小镜像小，便于存储与传输镜像庞大（vmdk、vdi等）运行性能几乎无额外性能损失操作系统额外的CPU、内存消耗移植性轻便、灵活，适应于Linux笨重，与虚拟化技术耦合度高硬件亲和性面向软件开发者面向硬件运维者部署速度快速，秒级较慢，10s以上 DevOps 开发/运维 【一次构建、随处运行】
更快速的应用交付和部署
更便捷的升级和扩缩容
更简单的系统运维
更高效的计算资源利用
官网和仓库 docker官网 http://www.docker.com
Docker Hub仓库官网 https://hub.docker.com
2.Docker安装 前提 Centos Docker 安装
Docker 并非是一个通用的容器工具，它依赖于已存在并运行的 Linux 内核环境。
Docker 实质上是在已经运行的 Linux 下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的 Linux 主机。
因此，Docker 必须部署在 Linux 内核的系统上。如果其他系统想部署 Docker 就必须安装一个虚拟 Linux 环境。
（Docker也可以在windows平台上部署，这个原理是利用 win10 自带的虚拟化技术Hyper-V，在虚拟机中安装 Linux内核 ，并在安装 Linux 系统中运行 Docker）
基本组成 镜像 容器 仓库
需要正确的理解仓库/镜像/容器这几个概念：
Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器实例（类似Java中new出来一个对象）。
image文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7461664bd6a8162df2aa407b29bfc8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f523147664c3c61324da7c493950395/" rel="bookmark">
			Ubuntu上重装Python2（强烈建议在不删除数据情况下，直接重装系统，不要动原本的Python，用anaconda做环境隔离）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重装系统分区见 ubuntu 20.04重装系统分区 一、在Ubuntu上卸载Python2 1、检查Python2的版本 在开始卸载Python2之前，我们需要先检查Python2的版本。新的Ubuntu版本通常都预装了Python3，而Python2是作为附属包(package)一起安装的。首先，打开终端(Terminal)，输入以下命令来检查Python2的版本：
python --version 如果Python2已经安装，会输出类似于以下的版本信息：
Python 2.7.17 2、备份Python2的环境变量 在卸载Python2之前，我们需要备份Python2的环境变量。在终端中输入以下命令：
sudo cp -R /usr/bin/python2.7 /usr/bin/python2.7.bak 该命令将会备份Python2的环境变量到“/usr/bin/python2.7.bak”文件夹中，以便于后续的恢复以及使用。
3、卸载Python2 如果你仅需卸载Python2：
sudo apt-get remove python2.7 sudo apt-get autoremove 该命令将会卸载Python2，同时也会自动卸载Python2相关的库和依赖。
如果你计划卸载所有和Python相关的软件，可以使用以下命令来进行操作：
sudo apt-get remove python2.7-minimal sudo apt-get autoremove 该命令将会卸载Python2以及所有和Python相关的软件，包括pip、virtualenv、pipenv等等。
4、清理残留文件 卸载Python2之后，可能还会留下一些残留文件。在终端中输入以下命令，以清理残留文件：
cd /usr/local/lib sudo rm -rf python2.7 cd /usr/lib sudo rm -rf python2.7 cd /usr/bin sudo rm -rf python2.7 该命令将会清理Python2相关的残留文件。
5、修改默认Python版本 如果你需要将Python3设置为默认版本，则可以在终端中输入以下命令来进行修改：
sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 10 该命令将会将Python3设置为默认版本。如果你需要恢复Python2为默认版本，可以使用以下命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f523147664c3c61324da7c493950395/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11ad7c2a225400971c67d54af409aa70/" rel="bookmark">
			日期取值(年月日…)方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果不熟悉日期的操作，想要获取相应信息时，可能会写出复杂的 SQL , 比如求日期的月初时间
select hiredate,to_date(to_char(hiredate,'yyyy-mm')||'-1','yyyy-mm-dd') as 月初 from emp where rownum&lt;=3;
其实这个一个函数即可解决，trunc()
select hiredate,trunc(hiredate,'mm') as 月初 from emp where rownum &lt;= 3;
下面列举几个常用的日期取值方式
select hiredate,
to_number(to_char(hiredate,'hh24')) as 时,
to_number(to_char(hiredate,'mi')) as 分,
to_number(to_char(hiredate,'ss')) as 秒,
to_number(to_char(hiredate,'dd')) as 日,
to_number(to_char(hiredate,'mm')) as 月,
to_number(to_char(hiredate,'yyyy')) as 年,
to_number(to_char(hiredate,'ddd')) as 这天是年内第几天,
trunc(hiredate,'dd') as 一天之始, /*使用trunc函数处理前，需要先将类型转为date类型*/
trunc(hiredate,'day') as 这天的周初,
trunc(hiredate,'mm') as 这天的月初,
last_day(hiredate) as 这天的月末,
add_months(trunc(hiredate,'mm'),+1) as 下月初,
trunc(hiredate,'yy') as 年初,
to_char(hiredate,'day') as 星期标识,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11ad7c2a225400971c67d54af409aa70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/399638ad1b0a2643749d06475ff843e4/" rel="bookmark">
			【Node】npm使用手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm是什么? 包管理工具 npm （node package manager）这个包管理器工具随着Node.js 的安装一起被安装到了用户的电脑上 ,npm由三个独立的部分组成：
网站注册表（registry）命令行工具 (CLI) 网站 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。
注册表 是一个巨大的数据库，保存了每个包（package）的信息。
CLI 通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。
查看已安装的 npm 软件包 npm list npm list -g 也一样，但适用于全局安装的软件包。
安装npm软件包 有两种方式用来安装 npm 包：本地安装和全局安装。至于选择哪种方式来安装，取决于我们如何使用这个包。
如果你自己的模块依赖于某个包，并通过 Node.js 的 require 加载，那么你应该选择本地安装，这种方式也是 npm install 命令的默认行为。如果你想将包作为一个命令行工具，（比如 grunt CLI），那么你应该选择全局安装。 npm install &lt;package_name&gt; // install可以简写成 i npm i &lt;package_name&gt; 全局安装
npm install -g &lt;package&gt; 卸载npm软件包 若要卸载之前在本地安装（在 node_modules 文件夹使用 npm install &lt;package-name&gt;）的软件包，则从项目的根文件夹（包含 node_modules 文件夹的文件夹）中运行：
npm uninstall &lt;package-name&gt; npm uninstall jquery 如果使用 -S 或 --save 标志，则还会移除 package.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/399638ad1b0a2643749d06475ff843e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65f1475a664af12294d0fdf515e2c96b/" rel="bookmark">
			5.docker容器及相关命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker中的容器实际上就是宿主机中的一个进程
目录
1 创建并启动容器 docker run
1.1 如果没有指定的镜像的话，docker会尝试从源拉取
1.2 给容器起名字 --name
1.3 交互方式启动(-i)与弹出客户端(-t)
1.4 指定端口 -p
1.5 自动分配端口 -P
1.6 后台运行(以守护进程方式运行) -d
2 查看运行中的容器 docker ps
3 以新的进程进入正在启动的容器内部 docker exec -it [容器ID] /bin/bash
4 删除容器 docker rm
5 以当前的进程进入正在启动的容器内部 docker attach
6 启动容器 docker restart
7 停止容器 docker stop
8 显示容器在宿主机的运行情况 docker top
9 查看日志docker logs
9.1 从指定时间到现在的日志 --since
9.2 最后n行 --tail
9.3 从日志的开头到指定的时间 --until
9.4 添加日志的时间戳 -t
9.5 获得动态日志 -f
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65f1475a664af12294d0fdf515e2c96b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e169f9b203a24d78cf6f1431e74c4709/" rel="bookmark">
			转移mysql中的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 mysqldump
2 将数据库中的数据转换为一个sql文件
3 执行sql文件
1 mysqldump 转移数据需要用到mysqldump。默认情况下mysqldump会自动被安装上，如果没有用不了，建议重新安装一下
参考 mysqldump 命令安装:_mob649e8162c013的技术博客_51CTO博客 如果按照这个方式安装的话 附录一 windows上安装mysql_windows 上安装 mysql-CSDN博客 mysqldump会被自动放在这里
你可以设置环境变量，如果你觉得设置环境变量有点儿麻烦，并且你用mysqldump并不频繁，你可以直接cd到mysqldump.exe进行使用，比如
如果显示拒绝访问，你需要打开一个管理员终端来执行
2 将数据库中的数据转换为一个sql文件 我现在有一个名为lottery的数据库，我想将这个数据库转换为一个sql文件
执行 mysqldump -u [sql用户名] -p [数据库名] &gt; sql文件存放目录
发现可以得到这个sql文件
可以用记事本打开sql文件，发现这个sql文件就是一条一条向数据库里插
3 执行sql文件 我们在mysql client中运行，首先新建一个数据库，比如我创建名为lottery2的数据库
然后输入source [sql文件位置] 就会创建表，然后把输入插入进去
之后可以查看到数据库lottery2有了想要的两个数据表，并且数据与原来一致
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76f1760a616230bf084ceba0c6082f27/" rel="bookmark">
			任务管理应用数据库设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用户表accountID管理账号表accountID，1个用户对应一个1账号属于1对1类型
关联表对应关系为多对多类型
1.用户表：tm_auth_user
字段名类型长度描述备注userIDbigint20主键 自增用户IDaccountIDbigint20无账户编号(关联账号表ID)userNamevarchar200无用户姓名userPhonechar11无用户手机号updateTimetimestamp10无修改时间createTimetimestamp10无创建时间 2.角色表：tm_auth_role
字段名类型长度描述备注roleIDbigint20主键 自增角色编号roleNamevarchar30无角色名称updateTimetimestamp10无修改时间createTimetimestamp10无创建时间 3.菜单表 ：tm_auth_menu
字段名类型长度描述备注menuIDbigint20主键 自增菜单编号menuNamevarchar200无菜单名称menuPathvarchar255无菜单路径menuIconvarchar255无菜单图标updateTimetimestamp10无修改时间createTimetimestamp10无创建时间 4.按钮表：tm_auth_action
字段名类型长度描述备注actionIDbigint20主键 自增编号menuIDbigint20无菜单编号actionNamevarchar200无按钮名称actionTypebigint20无按钮类型（类型表）actionEventvarchar200无按钮路径actionIconvarchar200无按钮图标updateTimetimestamp10无修改时间createTimetimestamp10无创建时间 5.账号表：tm_auth_account
字段名类型长度描述备注accountIDbigint20自增编号账号IDuserCodevarchar200无用户账号userPwdvarchar200无 用户密码
isFrozentinyint4无是否被冻结（1已冻结，0没冻结）updateTimetimestamp10无修改时间createTimetimestamp10无创建时间 6.用户角色关联表：tm_auth_roleuser
字段名类型长度描述备注roleUserIDbigint20自增编号用户角色关联表IDroleIDbigint20无角色编号userIDbigint20无用户编号isValidtinyint4无是否有效(1有效数据，0无效数据)updateTimetimestamp10无修改时间createTimetimestamp10无创建时间 7.角色菜单关联表：tm_auth_rolemenu
字段名类型长度描述备注roleMneuIDbigint20自增编号角色菜单关联IDroleIDbigint20无角色编号menuIDbigint20无菜单编号updateTimetimestamp10无修改时间createTimetimestamp10无创建时间 8.角色按钮关联表：tm_auth_roleaction
字段名类型长度描述备注roleActionIDbigint20自增编号角色按钮关联IDroleIDbigint20无角色编号actionIDbigint20无按钮编号updateTimetimestamp10无修改时间createTimetimestamp10无创建时间 9.任务表：tm_app_task
字段名类型长度描述备注taskIDbigint20自增编号任务IDtaskNamevarchar200无任务名称taskTypevarchar30无任务类型taskSpeedvarchar30无任务进度taskDescriptivevarchar255无简要描述taskChargePersonbigint20无任务负责人updateTimetimestamp10无修改时间createTimetimestamp10无创建时间 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0d40744efe895c4ad23ac1a06374cf0/" rel="bookmark">
			Jetson NX实现TensorRT加速部署YOLOv8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		References
知乎：Jetson nano部署YOLOV8并利用TensorRT加速推理实现行人检测追踪
「解析」Jetson 开启 Shell远程访问
在上文部署yolov8基础上
开启ssh服务 Jetson上下载东西有时需要魔法，开启ssh服务可以方便PC端和边缘设备传输信息
安装ssh sudo apt-get update sudo apt-get install openssh-server sudo apt-get install ssh # 开启ssh服务 sudo systemctl start ssh 配置防火墙 作者在实现远程连接的过程中关闭了防火墙，下面是针对ufw防火墙的一些shell命令，可以参考
sudo apt update sudo apt install ufw # 安装下 ufw sudo ufw status verbose	# 检查 ufw状态 # Status: inactive	# 表示已激活防火墙 sudo ufw allow ssh	# 允许ssh访问，22端口 # Rules updated # Rules updated (v6) sudo ufw enable	# 启用防火墙 sudo ufw disable # 关闭防火墙 查看是否已经开启ssh sudo service ssh status 远程连接Jetson NX 保证PC端和Jetson开发板在同一局域网内
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0d40744efe895c4ad23ac1a06374cf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9caf1f4518f4920bf2b3fe0c1bfb007d/" rel="bookmark">
			秒搜全网闲鱼商品！一键实现商品详情关键词搜索的酷炫电商API接口！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在如今的电商时代，商品搜索已经成为一个非常重要的功能。当用户在电商平台上浏览商品时，如果能够快速而准确地搜索到自己感兴趣的商品，无疑会提升用户的购物体验，进而增加平台的销售额。联讯数据将介绍一款名为“闲鱼商品秒搜API”的酷炫电商接口，它能够在全网范围内，以秒级的速度搜索出符合关键词的闲鱼商品详情。
什么是闲鱼商品秒搜API？
闲鱼商品秒搜API是一款基于人工智能和大数据技术开发的电商接口。它通过使用先进的算法和数据爬取技术，能够在全网的闲鱼商品库中以秒级的速度搜索出符合用户关键词的商品详情。不论是商品标题、商品描述，还是商品图片中的关键信息，该接口均能够迅速准确地匹配出用户需要的商品。
如何使用闲鱼商品秒搜API？
使用闲鱼商品秒搜API非常简单，只需要调用该接口提供的开发者函数，并传入所需的关键词参数即可。接口会立即返回与关键词匹配的商品详情结果，开发者可以据此进行进一步的处理和展示。同时，该接口还支持对搜索结果进行排序、过滤以及结果数量的限制等功能，以满足开发者的个性化需求。
闲鱼商品秒搜API的优势
闲鱼商品秒搜API相比于传统的商品搜索方式，具有以下明显优势：
快速高效：闲鱼商品秒搜API以秒级的速度搜索商品详情，用户无需进行繁琐的手动搜索，节省了大量时间。
精准准确：该接口基于先进的算法和数据分析技术，能够准确匹配出用户需求的商品详情，大大提升了搜索的精准度。
全网覆盖：闲鱼商品秒搜API能够在全网范围内搜索，无论是闲鱼平台上还是其它电商平台上发布的商品，都能够进行一键秒搜。
个性化定制：接口支持对搜索结果进行排序、过滤和数量限制等操作，开发者可以根据自身需求对搜索结果进行灵活的处理和展示。
使用闲鱼商品秒搜API的场景
闲鱼商品秒搜API可以广泛应用于各类电商平台、社交媒体等场景，包括但不限于以下几种： 电商平台：在电商平台上，用户可以使用闲鱼商品秒搜API来快速搜索商品详情，提高购物效率。
社交媒体：适用于社交媒体上的商品推荐，快速为用户展示与其关注内容相关的商品详情。
二手交易平台：对于二手交易平台，可以利用该接口帮助买家快速搜索到所需的二手商品详情，提升平台的用户体验。
响应示例
"v": "1.0", "msg": "调用成功", "left_nums": 333295, "data": { "topMoreInfoDO": { "trackParams": { "page": "Page_xySearchResult", "args": { "url": "fleamarket://FunShare?more=true", "search_id": "ed6b58a4fc17f740e89e4261b2686155", "rn": "c68d95e78b4bb8c6085391025b5e9a24", "page": "Page_xySearchResult", "keyword": "摩托车" }, "arg1": "TopMoreButton" }, "target": "fleamarket://FunShare?more=true", "showMoreIcon": "true", "params": { "shareInfo": "{"sceneType":"search","customIcons":[{"icon":"https://gw.alicdn.com/imgextra/i2/O1CN01CJNPRw1UUfDwpeAV0_!!6000000002521-2-tps-144-144.png","title":"足迹","type":"link","url":"fleamarket://footprint?flutter=true","key":"SearchFootprint"},{"icon":"https://gw.alicdn.com/imgextra/i3/O1CN01aQ54kt1xwiKaJNJT9_!!6000000006508-2-tps-144-144.png","title":"闲鱼小蜜","type":"link","url":"https://alimebot.goofish.com/intl/index.htm?from=2BpzapR8M1&amp;orderId=orderId","key":"SearchXiaomi"},{"icon":"https://gw.alicdn.com/imgextra/i4/O1CN01vNmCi71qKVzXxrxIh_!!6000000005477-2-tps-144-144.png","title":"反馈","type":"link","url":"https://market.m.taobao.com/app/alimama-engineering-fe/search_new_h5/xianyu.html?taskId=343","key":"SearchFeedback"}],"contentParams":{"headerParams":{},"mainParams":{}},"version":"2"}", "params": "{"sceneType":"search","customIcons":[{"icon":"https://gw.alicdn.com/imgextra/i2/O1CN01CJNPRw1UUfDwpeAV0_!!6000000002521-2-tps-144-144.png","title":"足迹","type":"link","url":"fleamarket://footprint?flutter=true","key":"SearchFootprint"},{"icon":"https://gw.alicdn.com/imgextra/i3/O1CN01aQ54kt1xwiKaJNJT9_!!6000000006508-2-tps-144-144.png","title":"闲鱼小蜜","type":"link","url":"https://alimebot.goofish.com/intl/index.htm?from=2BpzapR8M1&amp;orderId=orderId","key":"SearchXiaomi"},{"icon":"https://gw.alicdn.com/imgextra/i4/O1CN01vNmCi71qKVzXxrxIh_!!6000000005477-2-tps-144-144.png","title":"反馈","type":"link","url":"https://market.m.taobao.com/app/alimama-engineering-fe/search_new_h5/xianyu.html?taskId=343","key":"SearchFeedback"}],"contentParams":{"headerParams":{},"mainParams":{}},"version":"2"}" } }, "topList": [ { "type": "DX", "style": "flow", "data": { "template": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9caf1f4518f4920bf2b3fe0c1bfb007d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10b07b6ce3cc617d04f08bbc61bbc34c/" rel="bookmark">
			基于STM32的智能健康监测手环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
随着科技的飞速发展，人民的生活质量得到极大改善，同时人们对自身的健康状况更加关注。因此，需要设计了一款基于STM32的智能手环系统，其可显示步数、心率、温度、血氧等数据，使人们更快更好地实时了解健康情况。
本次设计的智能健康监测手环主要组成是STM32单片机电路、ADXL345加速度传感器、心率血氧检测电路、OLED液晶显示电路、电源电路、时钟DS1302和DS18B20温度传感器组成。通过ADXL345测量重力加速度，是用来判断人体状态，根据状态的数值变化进行计步功能。通过心率血氧传感器测试，通过手指脉动放大经过比较器处理后发送给单片机进行心率血氧采集。并将步数、心率血氧，温度、时间显示在液晶LCD1602上，并且我们也可以通过蓝牙把当前的数据发生到手机端进行显示，这样也方便陪练人员随时观察运动者状态。本次设计系统价格成本较低，功能比较全面，具有良好的市场前景。
本文着重介绍了智能健康监测手环的原理、整体设计方案、硬件选择、软件设计等。结果表明，本文设计的智能健康监测手环具有成本低，操作简便，稳定性较好等特点。
关 键 词：STM32；健康监测手环；DS18B20温度传感器；计步器；液晶显示
ABSTRACT
With the rapid development of science and technology, the quality of people's life has been greatly improved, and people are paying more attention to their health conditions. Therefore, it is necessary to design an intelligent bracelet system based on STM32, which can display data such as step number, heart rate, temperature, blood oxygen, etc., so that people can understand the health condition faster and better in real time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10b07b6ce3cc617d04f08bbc61bbc34c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0aff2d8d6fadf82b1f566c8c831d10a/" rel="bookmark">
			Solution on technology, For Career plan, IT, AI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Specialty on IT AI Technology and Vocation Plan I, Career Vocation Path Plan1.2) Salary is ok then we will do the work/job with capability meeting the needs of marketing,under extreme employment ciscustances, we can find a job supporting our daily life material and expenses, and then at the leisure free spared time to learn, quality social activity, body build, have major (C/Math/drawing/music/outdoor/,,,,etc, explore new and accumulate them all)observe, choose and take action/engage1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0aff2d8d6fadf82b1f566c8c831d10a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c34c56a7d95e8cc1264b059d3403989a/" rel="bookmark">
			AB克罗韦尔 2094-BC07-M05-S 伺服驱动器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AB克罗韦尔2094-BC07-M05-S伺服驱动器具有以下优势特性：
高性能：该驱动器采用先进的控制技术和算法，具有快速响应、高精度轨迹控制、高抗干扰能力等特点，能够满足各种复杂的应用需求。易于操作：该驱动器具有友好的用户界面和操作方式，方便用户进行配置、调试和故障排除等操作。高可靠性：该驱动器采用高品质的材料和制造工艺，确保其可靠性和耐用性，减少故障和维修成本。多功能集成：该驱动器集成了多种测量模块，可以同时测量多种气体浓度，满足不同应用场景的需求。 AB克罗韦尔2094-BC07-M05-S伺服驱动器的应用场景主要包括：
工业自动化生产线：该驱动器可以用于自动化生产线中的机器人控制，实现生产过程的自动化和智能化。智能制造领域：在智能制造领域，该驱动器可以用于机器人控制、自动化生产、智能物流等环节，提高生产效率和产品质量。航空航天领域：在航空航天领域，该驱动器可以用于飞机制造、航天器研发等领域的机器人控制和自动化生产。医疗保健领域：在医疗保健领域，该驱动器可以用于手术机器人、康复机器人等医疗设备的控制和自动化生产。 总之，AB克罗韦尔2094-BC07-M05-S伺服驱动器具有高性能、易于操作、高可靠性和多功能集成等优势特性，可以广泛应用于各种需要机器人控制的领域。
The AB Crowell 2094-BC07-M05-S servo driver has the following advantages:
High performance: This driver adopts advanced control technology and algorithms, with characteristics such as fast response, high-precision trajectory control, and high anti-interference ability, which can meet various complex application requirements.
Easy to operate: This drive has a friendly user interface and operation mode, making it convenient for users to configure, debug, and troubleshoot.
High reliability: The driver adopts high-quality materials and manufacturing processes to ensure its reliability and durability, reducing faults and maintenance costs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c34c56a7d95e8cc1264b059d3403989a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c44ef0f6f1c81114787eb62061e7b83c/" rel="bookmark">
			IntelliJ IDEA 2023.3 带着Ai来了...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击“码农code之路”，关注，置顶公众号
每日技术干货，第一时间送达！
刚刚Jetbrains来了一波大的更新，众多IDE都推出了2023.3正式版，均做了不少优化，最重要的是大家期待已久的Ai Assistant插件本次更新也正式推出，助力大家提高Coding效率。但是很遗憾，目前我们无法使用，因为该插件底层主要基于OpenAi，大陆现在是未开放地区，未提供服务。
另外，即便是你用了魔法工具上网，现在主流的激活工具和授权等同样无法直接激活Ai助手，似乎其不在全家桶范围内（比较尴尬😅），只能去官方店铺购买商用授权许可，激活Ai助手。
不过我们还是可以有所期待的，因为Jetbrains官方正在努力促成这件事，和阿里云在洽谈，将Ai助手带到大陆来。也许等不了太久，我们就可以直接安装该插件使用了。🐶
下面对本次官方部分更新做简单介绍：
1
功能亮点更新
对 Java 21 功能的完全支持
IntelliJ IDEA 2023.3 提供了对最新 Java 21 功能的完全支持。这些更新包括虚拟线程、记录模式、switch 表达式的模式匹配和序列化集合等重要新特性，以及对字符串模板、作用域值等新引入的语言功能的预览。
调试器中的 Run to Cursor（运行到光标）嵌入选项
IntelliJ IDEA 2023.3 引入了一个新的 Run to Cursor（运行到光标）嵌入选项，该选项允许您在调试时执行到特定代码行。程序挂起后，您可以将鼠标悬停在要执行到的代码行上，然后点击 Run to Cursor（运行到光标）弹出窗口。您还可以在将文本光标置于所需行上后调用键盘快捷键 (⌥F9) 来使用此功能。
带有编辑操作的浮动工具栏
IntelliJ IDEA 2023.3 引入了一个浮动工具栏，该工具栏会在所选代码段旁边显示，提供对 Extract（提取）、Surround（包围）、Reformat（重新格式化）和 Comment（注释）等编辑操作以及上下文操作的轻松访问。您可以使用竖三点菜单自定义浮动工具栏。要将其隐藏，您可以使用相同的菜单或转到 Settings/Preferences | Advanced Settings | Editor（设置/偏好设置 | 高级设置 | 编辑器），选中 Hide floating toolbar for code editing（隐藏代码编辑的浮动工具栏）选项。
2
用户体验优化
默认颜色编码编辑器标签页
为了增强您在编辑器中同时处理多种文件类型的导航体验，我们为编辑器标签页引入了默认颜色编码，反映它们在 Project（项目）工具窗口中的外观。您可以在 Settings/Preferences | Appearance &amp; Behavior | File Colors（设置/偏好设置 | 外观与行为 | 文件颜色）中管理此设置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c44ef0f6f1c81114787eb62061e7b83c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e2963e1cfb89ecf3591895e594e87d6/" rel="bookmark">
			gitlab 通过svn hook 触发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jenkins 起一个item
配置：
我选的自由风格的
源码管理配置
先选subversion 就是svn类型
url 设置project 的路径， 注意是工程，不是svn 顶层
添加一个账户来进行pull 等操作
选择添加的账号
构建触发器：
，重要的是要自己随便设置一个身份验证的令牌，这个令牌是给svn 触发jenkins 来构建的令牌，svn 发过来请求如果令牌错了也不会有构建操作的
svn 的配置：
svn 支持的钩子：
start-commit 提交前触发事务 pre-commit 提交完成前触发事务 post-commit 提交完成时触发事务 pre-revprop-change 版本属性修改前触发事务 post-revprop-change 版本属性修改后触发事务 拷贝生成一个commit 之后触发的钩子：
手动执行命令：
jenkins 端就会触发了：
直接修改这个post_commit.tmpl 应该能触发构建
拷贝工程下hooks/post_commit.tmpl 成应用
修改这个post_commit 假如触发jenkins 的url 命令
这样svn 提交后会提示触发
还可以发邮件，需要设置mailer.py
jenkins 端进行构建了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b78af23f40241be142d921a57609e6ea/" rel="bookmark">
			内连接和外连接 &amp; 驱动表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 多表查询
内连接和外连接是关系型数据库中常用的连接（Join）操作，用于在多个表之间建立关联关系。驱动表（Driving Table）是在连接操作中起到驱动作用的表，用于决定连接结果的基准。
内连接（Inner Join）：内连接是根据两个表之间的匹配条件，返回两个表中满足条件的交集结果。在内连接中，只有在连接条件匹配的情况下，才会返回行。驱动表通常是指在内连接中拥有更小数据集的表，用于驱动连接操作。它确定了连接操作的基准。
外连接（Outer Join）：外连接是根据两个表之间的匹配条件，返回满足条件的交集结果以及未匹配的行。外连接分为左外连接（Left Outer Join）和右外连接（Right Outer Join）。左外连接以驱动表为基准，返回驱动表的所有行以及与之匹配的关联表的行，未匹配的关联表行用空值填充。右外连接则以关联表为基准，返回关联表的所有行以及与之匹配的驱动表的行，未匹配的驱动表行用空值填充。
驱动表在连接操作中起到重要的作用，它决定了连接操作的起点和连接结果的基准。通常，选择驱动表时可以考虑数据量较小或筛选条件较为精确的表作为驱动表，以提高连接操作的效率。
需要注意的是，内连接和外连接可以根据具体的业务需求和数据关系来选择使用。使用内连接可以获取满足连接条件的交集数据，而使用外连接可以获取交集数据以及未匹配的行。正确选择连接类型和驱动表是设计和
举例 实例表 以下是 Customers（客户表）和 Orders（订单表）的创建语句示例，假设它们之间通过共享的列 “CustomerID” 进行关联：
Customers 表创建语句：
CREATE TABLE Customers ( ID INT PRIMARY KEY, CustomerName VARCHAR(255), Email VARCHAR(255) ); Orders 表创建语句：
CREATE TABLE Orders ( ID INT PRIMARY KEY, OrderID INT, OrderDate DATE, CustomerID INT, FOREIGN KEY (CustomerID) REFERENCES Customers(ID) ); 在上面的示例中，Customers 表包含了 ID、CustomerName 和 Email 列，其中 ID 列被定义为主键。Orders 表包含了 ID、OrderID、OrderDate 和 CustomerID 列，其中 ID 列被定义为主键，CustomerID 列被定义为外键，引用了 Customers 表的 ID 列。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b78af23f40241be142d921a57609e6ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aacb6404c2d737bdf7c67e6ee87adcaa/" rel="bookmark">
			阿里达摩院刚刚开源了AnyDoor！零样本物体编辑！可实现物体移动、物体交换、虚拟试穿等...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是阿潘，今天给大家分享一个阿里达摩院开源了 AnyDoor 的代码，不得不说，到年底了有点猛，疯狂的晒工作，感觉像是在冲业绩，这不得多拿好几个月的年终。
项目相关的链接整理在下面了：
https://damo-vilab.github.io/AnyDoor-Page/
https://github.com/damo-vilab/AnyDoor
https://arxiv.org/abs/2307.09481
标题：Anydoor: zero-shot object-level image customization
从标题可以大概知道这个工作主要实现的效果是零样本对物体级别的图片进行编辑
AnyDoor 介绍 摘要：
这项工作提出了 AnyDoor，一种基于扩散的图像生成器，能够以“和谐”的方式（图片整体和谐）将目标对象传送到用户指定位置的新场景。模型无需调整每个对象的参数，只需训练一次，即可在推理阶段轻松推广到不同的对象场景组合。这种具有挑战性的零样本设置需要对某个对象进行充分的表征。为此，我们用细节特征来补充常用的身份特征，这些细节特征经过精心设计，以保持纹理细节，同时允许多种局部变化（例如，照明、方向、姿势等），支持对象与不同环境的良好融合 。我们进一步建议借用视频数据集中的知识，我们可以观察单个对象的各种形式（即沿时间轴），从而获得更强的模型通用性和鲁棒性。大量的实验证明了我们的方法相对于现有替代方案的优越性，以及它在现实应用中的巨大潜力，例如虚拟试穿和物体移动。
部分展示效果：
将电视替换成狗狗书包
将床上的公仔替换成另一个公仔
将对上衣进行替换替换
具体能够实现的功能：
1、物体移动
AnyDoor 可以应用于诸如物体移动之类的奇特任务。‍
例如下面的图片中，实现对花瓶和木板的移动
2、物体交换
AnyDoor 还可以扩展来进行对象交换。
下面图片将两辆车的位置进行交换
3、Multi-subject Composition
由于 AnyDoor 对于将对象放置在给定场景的特定位置具有高度可控性，因此很容易扩展到多主体构图。
下面图片将不同的狗狗放在预设的图片位置，并且让生成的图片效果没有违和感。
‍4、虚拟试穿
AnyDoor 还可以作为虚拟试穿的简单但强大的基准。它可以保留不同衣服的颜色、图案和纹理，而不需要复杂的人工解析。
项目代码 具体的本地的环境搭建，作者已经公布了，并且权重和训练代码都已经提供，太赞了，小伙伴们，赶紧冲！
项目相关的链接整理在下面了：
https://damo-vilab.github.io/AnyDoor-Page/
https://github.com/damo-vilab/AnyDoor
https://arxiv.org/abs/2307.09481
最后，如果对大家有帮助，欢迎关注，点赞和分享！最近天气变冷了好多，大家要多注意身体哈
推荐阅读 为了突破深度学习瓶颈，去学习CUDA及TensorRT加速工具，真的管用吗？
人人都会铁山靠！Dreamoving：一种基于扩散模型的可控人体舞蹈视频生成框架
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a05842338b1469c4cd20854184f1153/" rel="bookmark">
			AUTOSAR开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		综述 本文档主要描述了VP项目MCU芯片TC297的AUTOSAR方案。MCU的基础软件由AUTOSAR软件实现，AUTOSAR可简易理解为如下层次。
MCU芯片驱动层：MCU芯片的抽象层，目的是将各类MCU芯片进行抽象，向上统一接口，隔离其他层次软件，做到足够的解耦状态，以便更换芯片时其他软件无需变更只需更换这一层软件就可。MCU芯片的抽象层包含Port,CAN,SPI,ETH,MCU,WDG,GPT等。控制器抽象层：控制器抽象层（包含I/O抽象驱动），作用是将控制器的外设进行抽象，向上统一接口。这一层的目的是可以控制器不同的外设需求进行抽象，做到上下隔离，解耦。重新设计控制器时，修改本层即可。包含：Fee,Mefif,Canif,Ethif等等。Service层：这一层是Autosar核心层，包含内存管理，网络管理，数据路由，UDS诊断管理，XCP标定等汽车领域通用化的软件服务都在这一层有所体现。关联了ISO14229,ASAP2，J1939等汽车标准,同时将成熟的MCU协议软件集成到这一层中；Autosar OS:OS实际上属于Service层的模块，但较为核心且独立，所以单独列出。AUTOSAR OS是基于OSEC OS进行开发的，区别于Linux，AUTOSAR OS功能相对简洁，不包含外设驱动，只关注任务调度。且所有任务都是静态分配，不支持动态任务分配。使用调度表进行任务调度，可对任务进行优先级，是否抢占，任务堆栈等进行设置，对二类中断进行统一管理。有专门配置选项进行管理。复杂驱动：对不易被统一接口，未被AUTOSAR定义，但属于基础软件，各控制器自定义的软件可放在复杂驱动中。RTE：可理解为数据接口层。 系统硬件架构图 根据项目的功能需求，板子的硬件模块图如下：
图1 VP项目五仁板子的硬件模块图
设计方案 AUTOSAR软件整体分为三部分：应用层软件、BSW与CDD和MCAL。AUTOSAR软件整体框图如下图所示。
图1 AUTOSAR软件整体框图
应用层软件依据具体需求，由模型生成代码或者手写代码方式实现。应用层软件具体功能，本文档暂不涉及。BSW部分是AUTOSAR协议栈的主体，通过配置软件进行参数配置，由工具生成代码。CDD部分依据具体需求，由手写代码实现。MCAL部分是芯片外设的驱动，依据项目中使用到的外设和使用方式，通过配置软件进行参数配置，由工具生成代码。 下文介绍各个模块包含的功能。
BSW模块 BSW模块是AUTOSAR的标准模块，主要包含（1）CAN、LIN、ETH等通信服务；（2）OS、ECUM等系统服务；（3）DEM、DCM等诊断服务；（4）FEE、NVM等存储服务。该部分可以在EB工程的基础上，依据VP具体需求进行更改。使用到的BSW模块如下图所示。
需要完整文档私信。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f45b40adb5e9bdc8a10b05233cc60ed4/" rel="bookmark">
			svn 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装系统
ubuntu 22
安装命令：
sudo apt-get install subversion
创建第一个工程：
创建版本库、项目
1、先创建svn根目录文件夹
sudo mkdir /home/svn
2、创建项目的目录文件夹
sudo mkdir /home/svn/demo_0
svnadmin create /home/svn/demo_0
配置：
sudo cp /home/svn/demo_0/conf/authz /home/svn
修改权限：
改文件 authz
修改密码：
修改passwd 文件
设置开机启动：
sudo svnserve -d -r /home/svn
通过命令查看是否启动成功
sudo netstat -antp |grep svnserve
关闭svn服务
sudo pkill svnserve
设置开机自启动SVN
在/etc/init.d目录创建一个svnd.sh文件，并在文件中进行配置，如下：
cd /etc/init.d
sudo touch svnd.sh
sudo chmod +x svnd.sh
svnd.sh文件内容修改为：
修改svnd.sh文件的权限
sudo update-rc.d svnd.sh defaults
测试：
sudo mkdir /home/xuww/svn
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f45b40adb5e9bdc8a10b05233cc60ed4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b31198a5d2eeb1dc890da586e82e41/" rel="bookmark">
			MCU嵌入式C代码编码规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 次
目次. I
前言. II
1 规范制定说明. 1
2 适用范围. 1
3 基本原则. 1
4 组织构成及排版要求. 1
4.1组织构成及包含内容. 1
4.2 文件书写的层次. 1
4.3 排版要求. 2
5 注释. 3
5.1文件头和函数头. 3
5.2 注释. 4
6 命名规则. 5
6.1 命名规则总则. 5
6.2 变量命名规则. 6
6.3文件及函数命名. 7
6.4新定义的类型命名规范. 7
7 变量、常量、宏定义与类型. 7
8.指针和数组、结构与联合. 8
9 初始化、声明和定义. 9
9.1初始化. 9
9.2声明和定义. 9
10 控制语句和表达式. 10
11 函数. 10
12 预处理指令. 11
13 其余规则.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5b31198a5d2eeb1dc890da586e82e41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c904d0e88b790b61bd6d70e487023f99/" rel="bookmark">
			jenkins安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统环境：
安装步骤：
安装jdk
jenkins 脱胎于jave的测试构建需求产生，基于java 语言，需要安装jave 的环境 sudo apt-get update sudo apt-get install openjdk-11-jdk sudo update-alternatives --config java 安装jenkins
基于安装包下载安装的方式麻烦，而且容易遇到兼容问题，采用apt 方式，22
的系统开始支持最新的jenkins也是有问题，经过官方的修正更新，大约11月末开始apt 的方式可以正确安装了。 sudo apt-get install --reinstall ca-certificates wget -q -O - https://pkg.jenkins.io/debian/jenkins-ci.org.key | sudo apt-key add - sudo sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list' sudo apt update sudo apt install jenkins 修改端口号
如果担心默认端口冲突，或者已经和其他软件冲突，可以修改默认端口号 gvim /etc/default/jenkins /etc/init.d/jenkins /usr/lib/systemd/system/jenkins.service文件中端口8080 改成8089 4. 查看安装状态 sudo systemctl status jenkins
``
登录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c904d0e88b790b61bd6d70e487023f99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/013d5fc8e2b9329375e42432ba4b722f/" rel="bookmark">
			Ansible-playbook编译.yml脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、playbook是什么？ 在Ansible中，Playbook是用于配置、部署和管理被控节点的剧本。它由一个或多个play（角色）组成，每个play可以包含多个task（台词，动作）。使用Ansible的Playbook，可以通过描述和执行一系列的操作步骤，让受控主机达到预期的状态。
2、为什么要编写playbook？ 写Playbook的目的主要有以下几点：
自动化和可重复性：Playbook可以确保在多个环境中实现一致性和可重复性。一旦编写完成，可以在任何需要的地方运行，从而消除了手动配置和部署的繁琐性。提高效率：通过自动化常见任务，Playbook可以显著减少完成这些任务所需的时间和精力。这允许团队将更多资源投入到创新和增值活动中。减少错误：自动化的配置和部署过程可以消除人为错误，从而提高了系统的稳定性和可靠性。文档化：Playbook可以作为系统配置和部署过程的文档。这有助于新团队成员了解系统，并允许团队在出现问题时快速回溯和诊断。可扩展性和灵活性：Playbook可以轻松适应不断变化的需求和环境。只需对Playbook进行必要的修改，即可在多个环境中重复使用。一致性：通过使用Playbook，可以确保在多个环境或主机上实现一致的配置和部署。这有助于维护系统的一致性和稳定性。易于审计和跟踪：由于Playbook是文本文件，因此可以轻松进行版本控制，从而允许团队跟踪对系统所做的更改。这有助于满足合规性和审计要求。 3、如何编写playbook？ 编写Ansible Playbook需要遵循一定的结构和语法规则。以下是一些编写Ansible Playbook的基本步骤和注意事项：
确定目标：在开始编写Playbook之前，需要明确你想要达到的目标。例如，你可能想要部署一个应用程序、配置网络设置、管理软件包等。创建Playbook文件：在Ansible目录中创建一个以.yml为扩展名的Playbook文件。例如，你可以创建一个名为deploy.yml的文件。定义inventory：在Playbook文件中，你需要定义一个或多个inventory（主机清单）。Inventory可以包含受控主机的列表、主机组、变量等。 --- - hosts: webservers become: yes tasks: - name: install nginx apt: name=nginx state=present
在这个示例中，hosts字段指定了一个名为webservers的主机组，become字段用于执行需要管理员权限的任务。
4.定义task（任务）：在Playbook中，每个任务都是一个要执行的指令或动作。你可以定义多个任务来达到你的目标。
- name: install nginx
apt: name=nginx state=present
在这个示例中，任务是安装Nginx软件包。
5.执行Playbook：使用Ansible命令行工具或脚本执行Playbook。例如，你可以运行以下命令来执行名为deploy.yml的Playbook：
ansible-playbook deploy.yml
6.调试和优化：在执行Playbook后，检查输出和日志以确认任务是否成功执行。根据需要调试和优化Playbook以确保其正确性和效率。
4、单据本编写 1.查看ansible是否安装，如下图是已安装示例图，如果还没有可以参考我上一篇文章《Ansible介绍与安装》
2.管理的我的主机IP地址 vi /etc/ansible/hosts
[m1]
192.168.31.135
[all:vars]
ansible_user=root
ansible_password=123456
3.确定ansible能与受控机通信
4.创建一个ploybook目录，用于专门存放ploybook文件，编写playbook，名为waha.yml。
[root@localhost /]# cd /etc/ansible
[root@localhost ansible]# mkdir playbook
[root@localhost ansible]# cd playbook/
[root@localhost playbook]# vim waha.yml
[root@localhost playbook]# cat waha.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/013d5fc8e2b9329375e42432ba4b722f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb82ec602f27c7e6e4a0ac36103c4e0/" rel="bookmark">
			数据结构之顺序表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.线性表
2.顺序表
2.1概念及结构
1. 静态顺序表：使用定长数组存储元素。
2. 动态顺序表：使用动态开辟的数组存储。
2.2接口实现
销毁顺序表
打印顺序表
增加数据
头插
尾插
指定下标位置插入
删除数据
头删
尾删
指定下标位置删除
查找数据
修改数据
1.线性表 线性表（linear list）是n个具有相同特性的数据元素的有限序列。 线性表是一种在实际中广泛使 用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串... 线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的， 线性表在物理上存储时，通常以数组和链式结构的形式存储。 2.顺序表 2.1概念及结构 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存 储。在数组上完成数据的增删查改。 顺序表一般可以分为： 1. 静态顺序表：使用定长数组存储元素。 2. 动态顺序表：使用动态开辟的数组存储。 实用动态内存开辟函数去开辟空间的时候，每次空间不够的时候都会扩容，每次扩容都会付出一定程度上的代价。所以每次扩容可以稍微多扩容一点点，减少扩容的频率。扩容是根据需求扩容，那我们最常用的扩容倍数就是：2倍 1.5倍。但是不是一定要求是这些倍数。2倍数是一个相对合适的量，扩容的频率会越来越低，具体情况具体分析！ 2.2接口实现 静态顺序表只适用于确定知道需要存多少数据的场景。静态顺序表的定长数组导致N定大了，空 间开多了浪费，开少了不够用。所以现实中基本都是使用动态顺序表，根据需要动态的分配空间 大小，所以下面我们实现动态顺序表。 第一步：初始化顺序表 typedef int SLDataType;//本篇博客以存放整型数据为例 typedef struct SeqList { SLDataType* a;//声明了一个指向顺序表的指针，姑且称它为“顺序表指针” int size;//记录当前顺序表内元素个数 int capacity;//记录当前顺序表的最大容量 }SeqList; 接着开始初始化
//初始化顺序表 void SeqListInit(SeqList* ps) { assert(ps); ps-&gt;a = NULL;//刚开始时顺序表为空，顺序表指针为NULL ps-&gt;size = 0;//起始时元素个数为0 ps-&gt;capacity = 0;//容量为0 } 销毁顺序表 因为顺序表所用的内存空间是动态开辟在堆区的，所以我们在使用完后需要及时对其进行释放，避免造成内存泄漏。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfb82ec602f27c7e6e4a0ac36103c4e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab6c8f7a8eff8b6c6187a12c6b2f483/" rel="bookmark">
			租用GPU进行YOLOV5训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的GPU型号是NVIDA GeForce RTX 3060 在训练ephoch=300，大概两万张图片，训练了将近20个小时。
发现租用GPU进行模型训练一方面的原因是不用配置环境，节省很多麻烦事。因为用cpu训练不知道要训练到什么时候，配置GPU的环境，配置cuda和cudann，加上一些版本，驱动，兼容等问题，需要花很长时间。另一方面，长期用自己的笔记本电脑训练模型的话，电脑的寿命减少的很快。
下面给大家推荐两个我自己用的很好用的租用GPU的平台。理由在于数据集的上传速度够快，11个G的数据集不会超过30min，2个G的数据不会超过1min。价格也足够实惠。
1.Gpushare Cloud （1）新人注册，完成任务有50元的代金券。
2.FeaTurize
其中Featurize，我在训练YOLOV7.0的时候，还是很顺利的，稍微修改下.yaml文件还有train.py轻松开训练。但是在使用恒源云的时候，训练有些麻烦，数据集不能够放在hy-tmp文件中（数据储存），放在那里面会一直报错读取不到数据集。其次，路径问题，路径不能设置绝对路径，还有竟然会出现不能下载YOLO字体而报错，只能自己先下载好，然后在放进去。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc240d12b58457c2cf2bc21930f4fa48/" rel="bookmark">
			[DroneCAN]CAN-Convertor控制CAN电调电机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 CAN电调电机是一类通过CAN协议控制转速的电调电机，和传统的PWM电调电机不同在于，CAN协议有网络性和抗干扰性，因此其性能比PWM更好，占用的端口数也会更少。在apm或者px4等基于dronecan的飞控来说，想要控制第三方的CAN电调电机其实比较困难，因为其CAN协议不同。所以在这种情况下，想要通信有两种方法：
第一种是在飞控上替换掉dronecan协议，添加第三方的can协议。这种方式添加的硬件最少，但是用替换原来的dronecan协议，先不说二次开发的工作量，单说这种方式就会破坏原由的架构，并且如果想要添加其他dronecan设备的时候就无法添加了。第二种也是本文的方式，就是用一个转换器模块，也是我们使用的CAN-Convertor，把dronecan协议按照一定的规则转换成can电调需要的协议。这种方式的好处就是并不会破坏原来的软件架构，并且开发量最少，扩展性和维护性也比第一种方式好太多。 实现方法 简单介绍之后，我们以大疆的CAN电调电机为例来说明。我这里有大疆C610无刷电机电调，这一款是通过can总线控制转速的电调电机，并且带有转速反馈。
其can通信协议如下图所示：
其协议本身并不是很复杂，下面看看我们怎么用CAN-Convertor进行转换。我在某宝上买的can-convertor模块，价格在一众can模块中还不算贵：
先上LUA代码：
local can_num = 1 candrv.set_BitRate(can_num, 1000) candrv.set_Protocol(can_num, 0) candrv.enable(can_num) candrv.set_Len(can_num, 8) candrv.set_StdID(can_num, 0x200) local rpm = 0 local rpm_h, rpm_l local i = 200 local id local len while true do i = i + 100 if i &gt; 500 then i = 200 end candrv.set_Data(can_num, 0, uint8_t(i &gt;&gt; 8)) candrv.set_Data(can_num, 1, uint8_t(i)) candrv.send(can_num) candrv.recv(can_num) id = candrv.get_ID(can_num) len = candrv.get_Len(can_num) if (id == 513) then rpm_h = candrv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc240d12b58457c2cf2bc21930f4fa48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e308c0a226f66c710bb865b98cec4000/" rel="bookmark">
			VIM ——Vimtutor 个人总结【从入门到精通】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		精进 Vim 编辑器技能：从入门到精通 文章目录 精进 Vim 编辑器技能：从入门到精通学习资源[Vim 自带教程中文版 —— vimtutor-CSDN博客](https://blog.csdn.net/qq_40395874/article/details/116047253)[Learn Vimscript the Hard Way (stevelosh.com)](https://learnvimscriptthehardway.stevelosh.com/) 前置任务：一些Linux常用命令和技巧知识代码帮助：命令帮助目录查看：ls -l 命令Vim 配置文件修改Vim 编辑技巧总结删除操作撤销命令粘贴命令替换命令文件定位和状态搜索命令匹配括号替换命令执行外部命令保存文件可视模式插入新行插入模式替换模式复制模式查找设置Vim 命令行设置代码提示 结语 Vim 是一款强大而高效的文本编辑器，但对于初学者来说，学习曲线可能会略显陡峭。在这篇博客中，我们将介绍一些优秀的学习资源以及 Vim 的一些高级技巧，帮助你更好地利用这款编辑器。 学习资源 Vim 自带教程中文版 —— vimtutor-CSDN博客 这是一个基于 CSDN 平台的中文版 Vim 教程，提供了对 Vim 的初步了解和基本操作的指导。
Learn Vimscript the Hard Way (stevelosh.com) 这个网站提供了一个深入学习 Vim 脚本的平台，适合想要更深入理解 Vim 内部机制和自定义配置的用户。
你可以使用 vimtutor 命令来启动 Vim 自带的教程。确保你在学习过程中不会迷失方向。
前置任务：一些Linux常用命令和技巧知识 代码帮助：命令帮助 - 命令帮助 - 什么是内部命令和外部命令？ - shell 命令自带的是内部命令 - 其他为外部命令 - 如何检查命令类型？ - `type ____`（比如 `type cd`） - 内部命令：shell buildin - `help xx` - 外部命令：xx is hashed (/xx) - `xx --help` - 典型例子 - `man xx` - `help xx` - `info xx` - `xx --help` 目录查看：ls -l 命令 - 目录查看 - `pwd` - 查看当前目录 - `cd` - `cd -` - 回到上次 cd 进的目录 - 2个目录之间进行快速切换 - `cd .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e308c0a226f66c710bb865b98cec4000/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab3c466c3ba732f859d6f1ed35119141/" rel="bookmark">
			单片机期末复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 发现很多人都写了单片机原理及接口技术课后习题的答案，但是也就只写了答案而已，可能是他们觉得太简单的缘故吧，我这里对此进行一下我近段时间复习的总结，本篇博客只展示选择题、填空题和判断题的答案，仅供参考，如果有错误还希望大佬能够指出。
题目来源：单片机原理及接口技术（C51编程）（第3版）张毅刚
相关链接 单片机C51复习题（课后习题及答案）_程序存储器的最大寻址范围有多少个中断源-CSDN博客https://blog.csdn.net/Leesnwen/article/details/117573376单片机原理及接口技术 - 第三版 张毅刚 习题答案_单片机原理及接口技术第三版-CSDN博客https://blog.csdn.net/weixin_45813438/article/details/131283863
第一章 一、填空 除了单片机这一名称之外，单片机还可以称为嵌入式控制器或微控制器。单片机与普通微型计算机的不同之处在于其将CPU、存储器和I/O口3部分，通过内部总线连接在一起，集成在一块芯片上。AT89S51单片机工作频率上限为33MHz。AT89C51单片机工作频率上限为24MHz。专用单片机已使系统结构最简化，软硬件资源利用最优化，从而大大降低成本和提高可靠性。 二、单选 1. 单片机内部数据之所以用二进制形式表示，主要是 B A．为了编程方便 B．受器件的物理性能限制
C．为了通用性 D．为了提高运算速度
2. 在家用电器中使用单片机应属于微计算机的 B 。 A．辅助设计应用 B．测量、控制应用
C．数值计算应用 D．数据处理应用
3. 下面的哪一项应用， 不属于 单片机的应用范围 C 。 A. 工业控制 B．家用电器的控制 C．数据库管理 D．汽车电子设备 三、判断对错 1. STC 系列单片机是 8051 内核的单片机。 √ 2. AT89S 5 2 与 AT89S 5 1 相比，片内多出了 4 K B 的 Flash 程序存储 器 、128B 的 RAM、1 个 中 断 源 、 1 个定时器（且具有捕捉功能 ）。 √ 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab3c466c3ba732f859d6f1ed35119141/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30f73f9e4219a62512db21f2ee6024c2/" rel="bookmark">
			【数据结构】——排序算法简答题模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、内排序和外排序二、排序算法的稳定性三、插入排序（一）直接插入排序的步骤（二）直接插入排序的稳定性（三）折半插入排序的步骤（四）希尔排序的步骤 四、交换排序（一）冒泡排序的步骤（二）冒泡排序的趟数和比较次数（三）快速排序的步骤（四）快速排序的稳定性 五、堆排序（一）堆排序的步骤（二）堆排序的稳定性（三）堆排序的时间复杂度 六、归并排序（一）k路归并排序的步骤（二）k路归并排序的稳定性（三）二路归并排序的步骤 七、排序算法的综合运用 一、内排序和外排序 1、内排序和外排序有什么区别？内排序有哪些算法？
答：根据排序过程中，数据元素是否完全在内存中进行，可分为内排序和外排序。内排序有直接/折半插入排序、简单旋转排序、冒泡排序、希尔排序、快速排序和堆排序。
二、排序算法的稳定性 1、什么是稳定排序？
答：经过排序后能使关键字相同的元素保持原本顺序中的相对位置不变，则称这个算法是稳定的，反之则不稳定。
三、插入排序 （一）直接插入排序的步骤 1、简述直接插入排序算法的基本思想。
答：直接插入排序是将要排序的序列按照关键字的大小插入至已排好序的子序列中，一直进行直到整个序列有序。
（二）直接插入排序的稳定性 1、直接插入排序算法是不是稳定的排序方法？
答：由于每次插入元素时总是从后向前比较后再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入排序是稳定的。
（三）折半插入排序的步骤 1、简述折半插入排序算法的基本思想。
答：折半插入排序的具体步骤如下：
初始化一个已排序序列，该序列只包含第一个元素，从第二个元素开始，通过折半查找确定每个待排序元素的插入位置，根据已排序序列中元素的中点，比较待排序元素与中点元素的大小，若待排序元素大于中点元素，则插入位置在中间位置的右侧；否则，插入位置在中间位置的左侧，然后插入元素，同时，需要将插入位置及其之后的所有元素向后移动一位，以为待排序元素腾出空间，重复步骤，直到所有元素都被插入到已排序序列中。
（四）希尔排序的步骤 1、简述希尔排序的基本思想。
答：希尔排序也称为缩小增量排序，即通过选取一定的增量来排序的，本质还是插入排序，通过增量将序列分为几个子序列，然后对每个子序列进行直接插入排序。
四、交换排序 （一）冒泡排序的步骤 1、简述冒泡排序的步骤。
答：通过两两比较相邻的元素，若发生逆序，则进行交换，直到整个序列有序为止，即若某一趟冒泡排序中没有发生元素交换，说明此时序列已整体有序。
（二）冒泡排序的趟数和比较次数 1、设有n 个元素采用冒泡排序法进行排序，通常需要进行多少趟排序?对于第i 次冒泡通常需要进行多少次关键字比较?
答：n个元素采用冒泡排序进行排序，最多需要进行n-1趟排序，即最坏情况下，排好的序列刚好与初始序列相反，呈逆序排列；而最少是初始序列正序，只需一趟即可完成排序。
2、设有n 个元素采用冒泡排序法进行排序，第i 次冒泡通常需要进行多少次关键字比较?
答：最好情况下，比较次数为n-1；最坏情况下，由于需要进行n-1趟排序，第i趟排序中要进行n-i次比较。
（三）快速排序的步骤 1、简述快速排序的步骤。
答：快速排序又称为分区交换排序，通过多次划分操作来实现排序思想，其步骤如下：
①每一趟排序中选取一个关键字作为枢轴；
②枢轴将待排序的序列分为两个部分，比枢轴小的元素移到其前，比枢轴大的元素移到其后，这是一趟快速排序；
③然后递归地对两个部分按照枢轴划分规则继续进行快速排序，直至每个区域只有一个元素为止或序列为空，最后达到整个序列有序。
（四）快速排序的稳定性 1、试举例说明快速排序的稳定性。
答：快速排序是不稳定的。当快速排序在处理包含有相等的元素的数组时，相等元素的值没有改变，但它们的相对顺序已经发生了变化，从而导致排序结果不稳定。
五、堆排序 （一）堆排序的步骤 1、简述堆排序的基本思想。
答：堆排序的基本思想是利用大根堆（小根堆）进行排序的方法，步骤如下：
①将待排序的序列构造成一个大根堆（小根堆），此时，整个序列的最大值（最小值）即为堆的根结点。
②将当前根结点移走，即与堆数组的末尾元素交换，此时末尾元素就是最大值（最小值），然后将剩余的n-1个序列重新构造成一个堆，依次得到n个元素中的次大值（次小值）；
③重复以上步骤，从而得到一个有序序列。
（二）堆排序的稳定性 1、堆排序是不是稳定排序？
答：堆排序不是，因为在进行筛选时可能会将后面相同关键字的元素调整到前面，所有不是稳定的排序算法。
（三）堆排序的时间复杂度 1、设结点个数为 n，采用堆排序法进行排序，其时间复杂性是多少?
答：堆排序的时间复杂性取决于堆的构造和调整过程，将结点个数为n的初始序列构造成一个大根堆或小根堆，建堆过程中元素比较次数最多为4n，由于需要遍历整个序列，所以这个构造过程的时间复杂度为O(n)。然后，从剩余n-1个元素中选出一个最大或最小的元素，与末尾元素交换，这样的步骤最多需要n-1次，所以复杂度是n(n-1)/2次对数级别的比较，但是需要减去n/2的建堆时间，即排序过程的时间复杂度为O(nlog2n)，所以总的堆排序的时间复杂度为O(n)+O(nlog2n)=O(nlog2n)。
六、归并排序 （一）k路归并排序的步骤 1、什么是归并排序？
答：将已有序的子序列合并，得到完全有序的序列，其中先使每个子序列有序，再使子序列间有序，即为归并排序。
（二）k路归并排序的稳定性 1、归并排序是不是稳定的？
答：归并排序是稳定的排序算法，满足稳定算法的定义，即假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面，且排序之后，a[i]仍然在a[j]前面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30f73f9e4219a62512db21f2ee6024c2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/53/">«</a>
	<span class="pagination__item pagination__item--current">54/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/55/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>