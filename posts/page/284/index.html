<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/327ef04a44140fa500bd663840560311/" rel="bookmark">
			arduino学习——WS2812灯带
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WS2812灯带程序 简介示例程序程序拓展（1）程序拓展（2）拓展程序（3）---fill_solid()函数灯带颜色的设置（1）CRGB RGBcolorName(rVal,gVal,bVal);CHSV颜色设置示例程序拓展（1）程序拓展（2）fill_rainbow()函数示例fill_gradient()函数示例palette色板示例自定义色板ColorFromPalette()函数fadeToBlacBy()函数FastLED.setBrightness()函数random8()函数beatsin8()函数EVERY_N_SECONDS()函数自定义addGlitter()函数LED灯带项目 简介 关于WS2812的简介看这里(https://blog.csdn.net/STCode_G/article/details/111652978?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162858277116780269855155%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&amp;request_id=162858277116780269855155&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2alltop_positive~default-1-111652978.first_rank_v2_pc_rank_v29&amp;utm_term=ws2812%E7%81%AF%E5%B8%A6&amp;spm=1018.2226.3001.4187)
示例程序 #include &lt;FastLED.h&gt; #define DATA_PIN 3 //设置引脚 #define LED_TYPE WS2812 //灯带类型 #define NUM_LEDS 30 //灯珠数量 #define COLOR_ORDER GRB //灯珠顺序 #define BRIGHTNESS 128 uint8_t max_brightness=128; //最大亮度 CRGB leds[NUM_LEDS]; // 给灯带命名 void setup() { // put your setup code here, to run once: FastLED.addLeds&lt;LED_TYPE,DATA_PIN,COLOR_ORDER&gt;(leds,NUM_LEDS); //初始化灯带 FastLED.setBrightness(max_brightness); //设置灯带亮度 } void loop() { // put your main code here, to run repeatedly: for (int i=0;i&lt;=29;i++){ leds[i]= CRGB::Red; FastLED.show(); delay(100); leds[i]=CRGB::Black; FastLED.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/327ef04a44140fa500bd663840560311/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/233bc218d96b688c78a5232ab1047f7a/" rel="bookmark">
			华为云CPU架构鲲鹏计算ARM服务器架构详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为云服务器CPU架构分为x86和鲲鹏计算，鲲鹏计算的云服务器处理器是基于Arm架构，采用RISC精简指令集（RISC），鲲鹏CPU架构相对于X86 CPU架构具有更加均衡的性能功耗比，云服务器吧来详细说下华为云服务器鲲鹏计算ARM处理器架构说明及常见问题解答：
华为云服务器CPU架构鲲鹏计算 什么是鲲鹏计算？鲲鹏计算是华为云推出的ARM处理器架构，华为云服务器CPU架构分为x86和鲲鹏计算，如下图：
华为云服务器CPU架构鲲鹏计算
华为云鲲鹏处理器基于Arm结构，采用RISC精简指令集（RISC），RISC是一种执行较少类型计算机指令的微处理器，它能够以更快的速度执行操作，使计算机的结构更加简单合理地提高运行速度，相对于X86 CPU架构具有更加均衡的性能功耗比。鲲鹏CPU架构的优势是高密度低功耗，可以提供更高的性价比，满足重载业务场景使用。
华为云鲲鹏服务器实例规格包括：AI加速型、鲲鹏通用计算增强型、鲲鹏内存优化型、鲲鹏超高IO型。也可以参考华为云官方文档关于鲲鹏架构的详细说明：华为云服务器鲲鹏ARM计算架构官方说明
鲲鹏ARM服务器常见问题及解答 鲲鹏CPU架构的云服务器可以切换成X86 CPU架构的云服务器吗？
答：两种CPU架构的云服务器不可以互相切换，因为两者的CPU架构不同，从而导致两者所使用的操作系统中部分二进制文件格式不同，不可以互相切换。
x86 CPU架构的服务器创建的私有镜像能否用于创建鲲鹏CPU架构的服务器？
答：不可以，x86 CPU架构的服务器创建的私有镜像中的部分二进制文件只能在x86 CPU架构上运行，不可以用来创建鲲鹏CPU架构的服务器。
可以创建Windows操作系统的鲲鹏CPU架构服务器吗？
答：不可以，暂不支持创建Windows操作系统的鲲鹏CPU架构服务器，也不支持使用Windows操作系统的镜像切换鲲鹏CPU架构服务器的操作系统。
更多关于华为云鲲鹏ARM服务器说明，请以华为云官方文档为准。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88753b93040e10079776703700b503a5/" rel="bookmark">
			Linux中的BIO和NIO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux中的BIO和NIO 1. 概念 BIO（阻塞IO）
执行某个操作时，若不能获得资源，则挂起进程知道满足条件获取资源后再执行。挂起进程的唤醒一般发生在中断里，因为硬件资源的获取一般伴随着一个中断
//以阻塞的方式从串口读取一个字符 char buf[20]; fd = open("/dev/ttyS1", O_RDWR); //阻塞读取字符 res = read(fd, &amp;buf, 1); printf("%c\n", buf); NIO（非阻塞IO）
执行某个操作时，若不能获得资源，不会挂起进行，要么放弃，要么不停的查询，直到可以进行操作为止
//以非阻塞的方式从串口读取一个字符 char buf[20]; fd = open("/dev/ttyS1", O_RDWR | O_NONBLOCK); //读取字符，读取操作立即返回，所以需要循环读取 while(read(fd, &amp;buf, 1) == -1) continue; printf("%c\n", buf); 改变文件的读写方式
除了可以在文件打开时定义读写方式外还可以通过ioctl()和fcntl()改变读写方式。
void ioctl(...); void fcntl(...); 2. 等待队列 等待队列是BIO的底层实现方式
等待队列与Linux内核的进程调度紧密结合信号量是依赖于等待队列实现的 //定义等待队列 wait_queue_head_t queue; //初始化头 void init_waitqueue_head(&amp;queue); //定义+初始化头 DECLARE_WAIT_QUEUE_HEAD(name); //定义元素 DECLARE_WAITQUEUE(name, tsk); //添加到队列 void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait); //从队列移除 void remove_wait_queue(wait_queue_head_t *q, wait_queue_t *wait); //等待事件 void wait_event(queue, condition); void wait_event_timeout(queue, condition); void wait_event_interruptible(queue, condition); void wait_event_interruptible_timeout(queue, condition); //唤醒队列 void wake_up(queue); void wake_up_interruptible(queue); 在等待队列中休眠（与wake_up成对使用）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88753b93040e10079776703700b503a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5a01e949469c5c8feaaebae173e2902/" rel="bookmark">
			中秋祝福python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用tkinter模块和turtlr模块一起制作：
代码部分：
import turtle
import tkinter as t
import tkinter.messagebox
import time
def goto(x,y):
turtle.penup()
turtle.goto(x,y)
turtle.pendown()
def yuan():
turtle.color("#D1C185","#839F26")
goto(0,-200)
turtle.begin_fill()
turtle.circle(200)
turtle.end_fill()
def huaban():
goto(0,0)
turtle.color("#839F26")
for i in range(20):
turtle.right(18)
turtle.begin_fill()
turtle.forward(220)
turtle.circle(40,180)
turtle.goto(0,0)
turtle.right(180)
turtle.end_fill()
def neitu():
turtle.color("#D1C185")
goto(0,-25)
for i in range(12):
turtle.begin_fill()
turtle.circle(150,60)
turtle.left(90)
turtle.circle(150,60)
turtle.end_fill()
def write():
goto(-40,10)
turtle.color(“red”)
turtle.write(“中秋快乐”,font=(“Time”,18,“bold”))
time.sleep(2)
window=t.Tk()
window.title(‘中秋’)
window.geometry(‘900x900+0+0’ )
label1 = tkinter.Label(window, text=‘中秋来了，请收下我的月饼’, bg=‘white’, font=(‘Arial’, 12,‘bold’), width=70, height=2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5a01e949469c5c8feaaebae173e2902/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e0ecdf1637597fcb43f9207760665f4/" rel="bookmark">
			解决 413 Request Entity Too Large（请求实体太大）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天做上传视频，报错413 Request Entity Too Large
我们可以看到请求的body的大小，在Content-Length后显示，Nginx默认的request body为1M，小于我们上传的大小
解决方案
找到自己主机的nginx.conf配置文件，打开
在http{}中加入 client_max_body_size 10m;
然后重启nginx
/etc/init.d/nginx restart
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f69a071fd595e65d6567a213c027c825/" rel="bookmark">
			【文献阅读】20210913-20210917文献阅读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4 Automatic tooth segmentation of dental mesh using a transverse plane 区域增长算法 6 Computerized Algorithm for 3D Teeth Segmentation 全景分割 7 Bio-Information Based Segmentation of 3D Dental Models不能下载 1 Snake-Based Segmentation of Teeth from Virtual Dental Casts 本文提出了一种基于最小用户交互的牙齿分割方法。
在一开始，牙齿和牙龈之间的分离曲线的初步估计被计算和优化使用活动轮廓。
第二步是计算牙弓和牙齿之间的间隙。为了准确地检测每颗牙齿的表面，我们最后在每颗牙齿的尖端放置一条蛇
1 牙齿与牙龈之间的分离曲线 平均曲率&lt;-0.3，形态学闭合牙龈线
每个点新定义一个曲率函数
KH是平均曲率
构造一个新的点集
η=0.8
通过对顶点集D的主成分分析得到最佳拟合平面。
2 Single-Tooth Modeling for 3D Dental Model 根据顶点邻域关系，可以有效地识别特征区域中包含的小块，当小块的顶点数小于给定值时，可以自动从特征区域中删除小块。
大牙没处理
曲率 - 基于顶点复杂度的分割边界提取[29]（骨架化） - 删除分支（环形分支需要交互删除）
附录 [29] C. Rossl, L. Kobbelt, and H.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f69a071fd595e65d6567a213c027c825/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e43f703d56bbd6644db2f6e3895fe781/" rel="bookmark">
			vue-amap 高德地图实现地图选址带搜索功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue-amap 高德地图实现地图选址带搜索功能 组件文档地址：https://elemefe.github.io/vue-amap/#/zh-cn/introduction/install
第一步：安装配置
在main.js
import VueAMap from 'vue-amap' Vue.use(VueAMap) VueAMap.initAMapApiLoader({ key: '***************', // 这里写你申请的高德地图的key plugin: ['AMap.Autocomplete', 'AMap.Geocoder', 'AMap.Geolocation'], v: '1.4.15', uiVersion: '1.1' }) 第二步：项目用的是vue antd弹窗组件以下代码复制粘贴直接就能用！
&lt;template&gt; &lt;a-modal v-model="isShow" :title="'地图选址'" :width="780"&gt; &lt;div class="map-container"&gt; &lt;div v-if="isShow" class="amap-wrapper"&gt; &lt;el-amap-search-box class="search-box" :default="searchValue" :search-option="searchOption" :on-search-result="onSearchResult" &gt;&lt;/el-amap-search-box&gt; &lt;el-amap class="amap-box" :zoom="zoom" :center="center" :events="events" :mapStyle="mapStyle"&gt; &lt;el-amap-marker v-for="(marker, i) in markers" :key="i" :position="marker"&gt;&lt;/el-amap-marker&gt; &lt;/el-amap&gt; &lt;/div&gt; &lt;div class="aaddress"&gt;您选择的地址是：{{address}}&lt;/div&gt; &lt;/div&gt; &lt;template slot="footer"&gt; &lt;a-button @click="close"&gt;取消&lt;/a-button&gt; &lt;a-button type="primary" @click="getLnglat"&gt;确定&lt;/a-button&gt; &lt;/template&gt; &lt;/a-modal&gt; &lt;/template&gt; &lt;script&gt; import { AMapManager } from 'vue-amap' const amapManager = new AMapManager() export default { data () { return { isShow: false, address: '北京市', searchValue: '', zoom: 12, center: [116.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e43f703d56bbd6644db2f6e3895fe781/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b05c22268755beffbc1ff0527a0e46/" rel="bookmark">
			使用Ubuntu挂载解析ubi文件与使用mkfs.ubifs、ubinize制作ubi文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、应用背景 客户嵌入式系统启动即Crash,由于特殊原因没有打开抓取dump的功能，所以无法知晓客户系统Crash的原因。但基本确认是客户在文件系统中添加自己的应用程序启动后导致的，我们拿到故障机后导出rootfs分区对应ubi文件，需要将其挂载，然后排查核心文件是否被修改或者损坏或者其他原因导致Crash（因为原嵌入式系统挂载即Crash，我们需要使用Ubuntu挂载，然后排查挂载文件）。
UBI文件系统不能直接挂载，而是要用 nandsim 模拟出一个 mtd 设备，而且这个 mtd 设备要与 ubi 镜像的参数保存一致，否则后面的挂载会失败。
/面朝大海0902/
二、具体操作步骤 环境要求：Linux内核2.6及以上，本次操作使用环境Ubuntu 14.04。
1、载入mtd模块
modprobe mtdblock
2、载入ubi模块
modprobe ubi
3、载入nandsim来模拟nand设备
modprobe nandsim first_id_byte=0x2c second_id_byte=0xf1 third_id_byte=0x80 fourth_id_byte=0x95
// disk size=128MB, page size=2048 bytes，block size=128KB
nandsim 后面跟的 4 个参数是 nand flash 芯片的 ID，前三个参数为厂商ID、芯片ID等不太关键的参数，而第 4 个参数决定了生成的 mtd 设备的 PEB 和 页大小。
/面朝大海0902/
4、查询相关参数
root@ubuntu:~# cat /proc/mtd dev: size erasesize name mtd0: 08000000 00020000 "NAND simulator partition 0" root@ubuntu:~# mtdinfo /dev/mtd mtd0 mtd0ro mtdblock0 root@ubuntu:~# mtdinfo /dev/mtd0 mtd0 Name: NAND simulator partition 0 Type: nand Eraseblock size: 131072 bytes, 128.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57b05c22268755beffbc1ff0527a0e46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cb5007d03f2377ee5bc2117c0328330/" rel="bookmark">
			mysql8.0限制用户只能访问指定数据库,限制用户只有某种权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql8有新的安全要求，不能像之前的版本那样一次性创建用户并授权需要先创建用户，再进行授权操作
创建新用户： create user '#userName'@'#host' identified by '#passWord'; #userName 代表你要创建的此数据库的新用户账号#host 代表访问权限，如下
%代表通配所有host地址权限(可远程访问)localhost为本地权限(不可远程访问) 指定特殊Ip访问权限如10.138.106.102#passWord 代表你要创建的此数据库的新用密码
注意：密码强度需要大小写及数字字母，否则会报密码强度不符合⚠️用户名如果重复，会报错ERROR 1396 (HY000): Operation CREATE USER failed for 'testUser'@'%' 为用户授权： grant #auth on #databaseName.#table to '#userName'@'#host'; #auth 代表权限，如下 all privileges 全部权限select 查询权限select,insert,update,delete 增删改查权限select,[…]增…等权限 #databaseName 代表数据库名#table 代表具体表，如下 *代表全部表
A,B 代表具体A,B表
#userName 代表用户名#host 代表访问权限，如下 %代表通配所有host地址权限(可远程访问)localhost为本地权限(不可远程访问) 指定特殊Ip访问权限如10.138.106.102 授权之后刷新权限： flush privileges;
如果遇到 Authentication plugin ‘caching_sha2_password’ cannot be loaded 参考以下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88f63e68955dfde088abbd07d8647798/" rel="bookmark">
			第4章 BP神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BP神经网络 1.BP神经网络介绍及发展背景 从前面介绍的感知器学习规则来看，其权值的调整 取决于期望输出与实际输出之差： $ {\Delta w_i = \eta(t-y)x_i}$
但是对于各个隐藏层的节点来说，不存在已知的期望输出，因而该学习规则不能用于隐藏层的权值调整。
BP 算法的基本思想是，学习过程由信号的正向传播和误差的反向传播两个过程组成。
正向传播时，把样本的特征从输入层进行输入，信号经过各个隐藏层逐层处理后，最后从 输出层传出。对于网络的实际输出与期望输出之间的误差，把误差信号从最后一层逐层反传，从而获得各个层的误差学习信号，再根据误差学习信号来修正各个层神经元的权值。
2.代价函数 cost或loss表示
最简单常见的一个代价函数是均方差（Mean-Square Error, MSE）代价函数，也称为二次代价函数：
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3Qvy6oS3-1631831470720)(attachment:image-3.png)]
3.梯度下降法 3.1 梯度下降法介绍 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-skjkJR9P-1631831470723)(attachment:image-4.png)]
3.2 梯度下降法二维例子 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OjXJ1qwg-1631831470724)(attachment:image-5.png)]
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OMio5kVl-1631831470725)(attachment:image-6.png)]
3.3 梯度下降法三维例子 4.Delta学习规则 5.常用激活函数讲解 5.1 Sigmoid函数 5.2 Tanh函数 5.3 Softsign函数 5.4 ReLU函数 6.BP网络模型和公式推导 6.1 BP网络模型 6.2 BP算法推导 6.3 BP算法推导补充说明 7.BP算法推导结论总结 8.梯度消失与梯度爆炸 8.1 梯度消失 8.2 梯度爆炸 如果学习信号乘以一个大于 1 的数，那么δ就会变大。学习信号从输出层一层一层向前反向传播的时候，每传播一层学习信号就会变大一点，经过多层传播后，学习信号就会接近于无穷大，从而使得权值调整接近于无穷大。接近于无穷大那就意味着该层的参数，处于 一种极不稳定的状态，那么网络就不能正常工作了。学习信号随着网络传播逐渐增大的问题也被称为梯度爆炸（Exploding Gradient）的问题。
8.3 使用ReLU函数解决梯度消失和梯度爆炸的问题 导数为 1 是一个很好的特性，不会使得学习信号越来越小，也不会让学习信号越来越大，可以让学习信号比较稳定地从后向前传 播。解决了梯度消失和梯度爆炸的问题，同时计算方便，可以加速网络的训练。 ReLU 函数还有一个优点，它是一个非线性的激活函数，可以用来处理非线性问题
在神经网络 中，信号是冗余的，也就是说其实网络最后在做预测的时候并不需要从前面传过来的所有的信号，实际上只需要一部分的信号，网络就可以进行预测。并且使用部分信号来进行预测与使用全部信号来进行预测得到的结果相差不大
9.使用BP神经网络解决异或问题 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88f63e68955dfde088abbd07d8647798/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80292d14072b18160de2713e9a712472/" rel="bookmark">
			带你了解vue的$refs和ref（附带常见问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$ref和ref $refs和ref的使用$refs和v-for一起使用$ref不生效问题 $refs和ref的使用 通过vue的官方文档说明：
例子
&lt;template&gt; &lt;div&gt; &lt;HomeLeft ref="homeleft" id="children"&gt;&lt;/HomeLeft&gt; &lt;div&gt; &lt;button class="color_red" @click="hanldChildrenReduceNumber()"&gt;我是父组件的-号&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import HomeLeft from "@/components/home/left.vue" export default { name:'name', components:{ HomeLeft }, methods: { hanldChildrenReduceNumber(){ this.$refs.homeleft.hanldReduceNumber() } } } &lt;/script&gt; &lt;template&gt; &lt;div class="hello"&gt; &lt;div&gt;{{allNumber}}&lt;/div&gt; &lt;button class="color_green" @click="hanldAddNumber()"&gt;我是子组件的+号&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'demo', props:{ }, data () { return { allNumber:0 } }, methods: { hanldAddNumber(){ this.allNumber++ }, hanldReduceNumber(){ this.allNumber++ }, } } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 效果图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80292d14072b18160de2713e9a712472/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eca8c5a775485f999ce48695d099aeff/" rel="bookmark">
			尚硅谷k8s笔记（未完结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装说明 准备四台服务器，并每台服务器的配置最低为 2G2核 否则无法安装。
系统Centos7。
注意安装k8s最低配置为，2核，否则在初始化节点的时候会报错。
请先下载准备好的相关文件
文件链接：https://pan.baidu.com/s/1re9043zu6qq4UuElBAw2sg 提取码：gvmx
二、系统初始化 本节各节点都要执行
1.设置系统名称 三台服务器分别叫 k8s-master01，k8s-node01,k8s-master02。
hostnamectl set-hostname k8s-master01 2.修改hosts vi /etc/hosts 配置各节点映射，以及flannel下载时的网络映射。
如：
192.168.149.128 k8s-master01 192.168.149.129 k8s-node01 192.168.149.130 k8s-node02 199.232.68.133 raw.githubusercontent.com 3.安装工具依赖包 yum install -y conntrack ntpdate ntp ipvsadm ipset jq iptables curl sysstat libseccomp wget vim net-tools git 4.设置防火墙 关闭防火墙
systemctl stop firewalld &amp;&amp; systemctl disable firewalld 设置规则为空
yum -y install iptables-services &amp;&amp; systemctl start iptables &amp;&amp; systemctl enable iptables &amp;&amp; iptables -F &amp;&amp; service iptables save 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eca8c5a775485f999ce48695d099aeff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb986aa14fdecf278f77ce3f6eb709f9/" rel="bookmark">
			汇编语言：将AX中的数以无符号十进制形式输出显示。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、编写程序，将AX中的数以无符号十进制形式输出显示。
用到的指令有mov、cmp、无条件转移指令jmp、带条件转移指令je、ja、jb等，
div、push、pop、add和输出一个字符的功能函数mov ah，2 int 21h。
注意：循环之前要对用到的寄存器进行初始值设定？
循环使用的是while形式还是do-while形式？
比较指令之后，可以跟带条件转移指令，转移条件是什么？
此处要考虑如何跳出循环（即结束循环），要想清楚条件成立怎么走，条件不成立怎么走？
无条件指令jmp应该跳转到哪里才能构成循环？
计数器用什么用处？
垃圾汇编，麻烦的不行，以下是此题分析
mov ah, 1 int 21h mov ax, 123; 将 ax 赋值 123 mov cl, 10; cl 是每次 除以 10 mov ch, 0; 计算 除了多少次，也就是有几位 L0:	div cl; ax 除以 cl push ax; 此时的商存储在 al 中， ;余数存储在 ah 中，此时 ax = ah add ch, 1 mov ah, 0 cmp ax, 0;如果 ax 是 0，说明除干净了 jne L0 again: cmp ch, 0; 此时 ch 的值就是位数，每次出栈， ;然后 ch 减一即可 je over pop dx; 把栈顶元素存储到 dx 中 mov dl, dh;然后将 dl 的值等于 dh add dl, 48 mov ah, 2 int 21h ; write by 唐昊翔 dec ch jmp again over: 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/165713bc658a66bba7e8757029a26165/" rel="bookmark">
			Linux并发控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了解决多核心竞争临界资源问题，Linux提高多种方式用于处理竞态问题。
1. 整型原子操作 头文件：&lt;linux/atomic-fallback.h&gt;
设置原子变量的值 //设置原子变量的值为i void atomic_set(atomic_t *v, int i); //定义原子变量，并初始化为0 atomic_t v = ATOMIC_INIT(0); 获取原子变量的值 atomic_read(atomic_t *v); 原子变量加、减 void atomic_add(int i, atomic_t *v); void atomic_sub(int i, atomic_t *v); 原子变量自增、自减 void atomic_inc(atomic_t *v); void atomic_dec(atomic_t *v); 操作并测试
操作原子变量后，测试原子变量的值是否为0，为0返回true，否则返回false
int atomic_inc_and_test(atomic_t *v); int atomic_dec_and_test(atomic_t *c); int atomic_add_and_test(int i, atomic_t *v); int atomic_sub_and_test(int i, atomic_t *v); 操作并返回
操作原子变量后，返回原子变量的值
int atomic_add_return(int i, atomic_t *v); int atomic_sub_return(int i, atomic_t *v); int atomic_inc_return(atomic_t *v); int atomic_dec_return(atomic_t *v); 示例：一个设备文件同时只能被一个进程打开，使用整形原子操作实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/165713bc658a66bba7e8757029a26165/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be3b8ef2bbad4c3f947a95d8fd9deeb/" rel="bookmark">
			golang目录分层规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主之前是做Java的，然后转go来写应用之后，还用原来那一套mvc的思维来分级，放置源文件组织程序。然后发现很多问题。
Java是用类的角度来寻找调用方法的，而Go是按照包[目录]的角度，如果和Java一样MVC，三个包下面都放置很多不同业务的不同类时，写代码[看代码]的时候就会发现一个包下面的方法过多。然后包的作用也过于混乱或者笼统。
建议的方式，把MVC，相同业务的Controller、View、Model放在一个以业务命名的包里面。[总的来说，在Go里面建议像Java很多类一样，多弄一些包]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de7946a25d53452e96fb76f832c5a4a2/" rel="bookmark">
			华为手机 scrcpy 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、了解Scrcpy - 开源免费投屏控制软件 - 安卓应用推荐 - 画夹插件网
2、下载附件里面包含了adb和scrcpy
3、手机通过usb链接电脑,打开开发者模式，和usb调试
4、运行cmd
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73fadd9474605551dbf1e05b10a1ccdf/" rel="bookmark">
			nodemon 的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装(全局)
1.1 检查是否安装成功,在任意目录下执行
2.使用
将原本执行js文件的node 改为使用nodemon
窗口不关闭,在js文件中添加代码,不需要再次执行 node 文件名.js
它会自己执行
想退出这种模式,执行
ctrl + c 输入 Y 即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf2eafb6795890e6df0ba65847766c46/" rel="bookmark">
			408——操作系统 第四章 文件管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件管理 1. 文件系统基础1.1 文件概念1.2 文件的逻辑结构1.2.1 顺序文件1.2.2 索引文件1.2.3 索引顺序文件 1.3 目录结构1.4 文件共享1.5 文件保护练习 2. 文件系统实现2.1 文件系统层次结构2.2 目录实现2.3 文件实现练习 3. 磁盘组织与管理3.1 磁盘的结构3.2 磁盘调度算法3.3 磁盘的管理练习 1. 文件系统基础 1.1 文件概念 文件系统的管理功能是将其管理的程序和数据通过组织为一系列文件的方式实现的。文件则是指具有文名的若干相关元素的集合。元素通常是记录，记录又是一组有意义的数据项的集合。基于文件系统的概念，可以把数据组成分为数据项、记录和文件三级。
操作系统应该向上提供哪些功能？
1.2 文件的逻辑结构 按文件是否有结构分类，可以分为无结构文件、有结构文件两种。
无结构文件： 文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。如：Windows操作系统中的.txt文件。
有结构文件： 由一组相似的记录组成，又称“记录式文件”。每条记录又若干个数据项组成。如：数据库表文件。一般来说，每条记录有一个数据项可作为关键字（作为识别不同记录的ID）。根据各条记录的长度（占用的存储空间）是否相等，又可分为定长记录和可变长记录两种。
1.2.1 顺序文件 顺序文件： 文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。
1.2.2 索引文件 1.2.3 索引顺序文件 若一个顺序文件有10000个记录，则根据关键字检索文件，只能从头开始顺序查找（这里指的并不是定长记录、顺序结构的顺序文件），平均须查找5000个记录。
若采用索引顺序文件结构，可把10000个记录分为√10000 = 100 组，每组100个记录。则需要先顺序查找索引表找到分组（共100个分组，因此索引表长度为100，平均需要查50次），找到分组后，再在分组中顺序查找记录（每个分组100个记录，因此平均需要查50次）。可见，采用索引顺序文件结构后，平均查找次数减少为50+50 = 100次。
同理，若文件共有106个记录，则可分为1000个分组，每个分组1000个记录。根据关键字检索一个记录平均需要查找500+500 = 1000次。这个查找次数依然很多，如何解决呢？
1.3 目录结构 1.4 文件共享 1.5 文件保护 1）口令保护
为文件设置一个“口令”（如：abc112233），用户请求访问该文件时必须提供“口令”。
优点：保存口令的空间开销不多，验证口令的时间开销也很小。
缺点：正确的“口令”存放在系统内部，不够安全。
2）加密保护
使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。
优点：保密性强，不需要在系统中存储“密码”
缺点：编码/译码，或者说加密/解密要花费一定时间。
3）访问控制
在每个文件的FCB（或索引结点）中增加一个访问控制列表（Access-Control List, ACL），该表中记录了各个用户可以对该文件执行哪些操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf2eafb6795890e6df0ba65847766c46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9055f36f58cf52e96b79ab8182251bc8/" rel="bookmark">
			windows10下编译生成hadoop-eclipse-plugin-3.3.1插件（失败）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 软件配置 软件版本位置Javajdk1.8.0_301D:\Java\jdk1.8.0_301antapache-ant-1.10.5D:\apache-ant-1.10.5eclipseeclipse-jee-2018-09-win32-x86_64D:\eclipsehadoophadoop-3.3.1D:\hadoop-3.3.1 2. 下载eclipse-hadoop3x-master 下载地址：eclipse-hadoop3x-master
下载后解压缩存放于D盘
3. ant编译生成jar包 打开D:\eclipse-hadoop3x-master\ivy路径下的libraries.properties文件，修改如下：
# Licensed under the Apache License, Version 2.0 (the "License"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an "AS IS"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9055f36f58cf52e96b79ab8182251bc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c84d7a9a3ea89b9a6087889c7a37afe/" rel="bookmark">
			零基础入门金融风控-贷款违约预测-机器学习-数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零基础入门金融风控-贷款违约预测 一、赛题数据 赛题以预测用户贷款是否违约为任务，数据集报名后可见并可下载，该数据来自某信贷平台的贷款记录，总数据量超过120w，包含47列变量信息，其中15列为匿名变量。为了保证比赛的公平性，将会从中抽取80万条作为训练集，20万条作为测试集A，20万条作为测试集B，同时会对employmentTitle、purpose、postCode和title等信息进行脱敏。
数据可在阿里云学习赛中获得。
字段表 idFieldDescription1id为贷款清单分配的唯一信用证标识2loanAmnt贷款金额3term贷款期限（year）4interestRate贷款利率5installment分期付款金额6grade贷款等级7subGrade贷款等级之子级8employmentTitle就业职称9employmentLength就业年限（年）10homeOwnership借款人在登记时提供的房屋所有权状况11annualIncome年收入12verificationStatus验证状态13issueDate贷款发放的月份14purpose借款人在贷款申请时的贷款用途类别15postCode借款人在贷款申请中提供的邮政编码的前3位数字16regionCode地区编码17dti债务收入比18delinquency_2years借款人过去2年信用档案中逾期30天以上的违约事件数19ficoRangeLow借款人在贷款发放时的fico所属的下限范围20ficoRangeHigh借款人在贷款发放时的fico所属的上限范围21openAcc借款人信用档案中未结信用额度的数量22pubRec贬损公共记录的数量23pubRecBankruptcies公开记录清除的数量24revolBal信贷周转余额合计25revolUtil循环额度利用率，或借款人使用的相对于所有可用循环信贷的信贷金额26totalAcc借款人信用档案中当前的信用额度总数27initialListStatus贷款的初始列表状态28applicationType表明贷款是个人申请还是与两个共同借款人的联合申请29earliesCreditLine借款人最早报告的信用额度开立的月份30title借款人提供的贷款名称31policyCode公开可用的策略_代码=1新产品不公开可用的策略_代码=232n系列匿名特征匿名特征n0-n14，为一些贷款人行为计数特征的处理 二、评测标准 提交结果为每个测试样本是1的概率，也就是y为1的概率。评价方法为AUC评估模型效果（越大越好）。
三、代码演示 说明：下面运行结果贴出的是部分图。环境：本案例使用的库 pandas 1.3.2matplotlib 3.4.3seaborn 0.11.2numpy 1.21.2scipy 1.4.1scikit-learn 0.24.2 使用的是jupyter notebook 1. 数据分析及处理 1.1.0导入相关库 import pandas as pd import matplotlib.pyplot as plt import seaborn as sns import numpy as np from scipy import stats import matplotlib as mpl #显示所有列 pd.set_option('display.max_columns',None) # 警告处理 import warnings warnings.filterwarnings('ignore') %matplotlib inline 1.1.1数据预处理 df_train = pd.read_csv('train.csv') df_test = pd.read_csv('testA.csv') df_train.shape, df_test.shape df_train['train_test'] = 'train' df_test['train_test'] = 'test' 合并训练集和测试集
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c84d7a9a3ea89b9a6087889c7a37afe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/513e1ffad1a57c89a283da636ea5f057/" rel="bookmark">
			微软要给我30万美元的额外奖励，被我拒了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我叫Tom，如果你曾经使用过Jekyll（一个著名的静态网站生成工具），你可能听说过我，因为Jekyll就是我开发的。 不过今天不讲Jekyll， 我要讲的，是另外一个更有趣的故事。 1
2007年10月18日，我到旧金山的Zeke's 酒吧参加一个线下聚会，就是你们经常说的“面基”。 参加聚会的都是志同道合的Ruby爱好者，Ruby可能很多年轻的程序员都不知道了吧，但在当时，这门语言由于Ruby on Rails的流行变得非常热门。 Twitter、GroupOn、Airbnb、Hulu等著名网站在早期都是用Ruby开发的。 我喝了不少酒，然后找了酒吧后面的长桌休息一下，这时候Chris Wanstrath 走了过来。 Chris这个家伙大学主修英语，后来爱上了编程，他找到工作后连学位都不要了。 Chris和我一样，既喜欢Ruby ，又关注新生事物Git，于是， 我对他招手让他过来：“老兄，看看这个。”
大约一周前，我做了一个叫做Grit的项目， 让我可以通过Ruby代码以一种面向对象的方式来访问Git。
require 'grit'
repo = Grit::Repo.new("/Users/tom/dev/grit")
repo.commits
repo.commits.first.parents[0].parents[0].parents[0]
repo.tree
Chris显然被这种优美的使用方式给勾住了。 于是我开始向他兜售一个不成熟的设想：用Ruby on Rails做一个面向程序员的网站，他们可以在上面保存、分享自己的Git代码库。 我甚至都想好了名称：GitHub。 当我喋喋不休讲解的时候，Chris立刻把我打断了：算我一份，让我们来实现它！
Chris说到做到，第二天晚上10点24分，他就提交了GitHub的第一批代码，说实话那个时候我们并没有想好未来会怎样，就是两个“黑客”想做一点比较酷的事情。
接下来的三个月，Chris和我花了大量的时间规划GitHub、编写代码，我继续折腾Grit，设计UI， Chris则用Rails开发 Web 应用。我和他每周六见面，讨论一些重要的设计决定，以及未来如何定价。 当然，这都是业余时间做的，我当时在一个叫做Powerset 的公司当打工人， 为公司的两个团队开发工具。 三个月后，我们推出了beta版，并且邀请我们的一些朋友来试用， 第一个用户是Yehuda Katz， 他是非常厉害的黑客，有一大堆头衔： Ember.js的作者
jQuery 和 Ruby on Rails核心成员
Rust核心成员
ECMAScript标准委员会成员
.....
（Yehuda Katz）
Yehuda Katz给了我们非常多、非常棒的反馈，还推荐给了更多厉害的程序员，这就产生了滚雪球的效应。 2008年4月， 我们发布了面向公众的正式版，但是悲催的是没有知名媒体的报道，也没有一丁点的风险投资。 这时候我走到了人生的岔路口， 我所在的公司Powerset 被微软以一亿美元收购了！ 微软给我开出了诱人的条件：除了正常的薪水之外，还有30万美元的奖励，条件是在微软工作满三年。 说实话，做出选择真不容易， 一方面是稳定高薪的工作，另一方面是风险极大的事业。
最后我还是选择了后者， 因为对于我热爱的东西，我绝不放弃。 我希望在我临死之前，回顾一生，我会说：“哇，这辈子跌宕起伏，值了！” 而不是 “这辈子稳稳当当，真没意思。”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/513e1ffad1a57c89a283da636ea5f057/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f89e440252f87d090e6b337c3d672b2/" rel="bookmark">
			函数传参（指针）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数传参 传统的c中，函数在调用时参数是通过值来传递的，这就是说函数的参数不具备返回值的能力。
指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。
而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。
在C++中，指针和引用经常用于函数的参数传递，然而，指针传递参数和引用传递参数是有本质上的不同的：
指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。（这里是在说实参指针本身的地址值不会变）
而在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。
引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的指针，或者指针引用。
传递可变参数 在传统的c中，如果需要函数的参数具有返回值的能力，往往是通过指针来实现的。比如，实现
两整数变量值交换的c程序如下：
void swapint(int *a,int *b)
{
int temp;
temp=*a;
a=*b;
*b=temp;
}
使用引用机制后，以上程序的c++版本为：
void swapint(int &amp;a,int &amp;b)
{
int temp;
temp=a;
a=b;
b=temp;
}
返回结构体内部子结构体的指针 结构体定义：
struct st_datas { int data; PATAM_T key_status_n; }; typedef struct st_datas STRU_T ; 主函数调用：
BYTE *p_glo= NULL; p_glo= (BYTE*)GlobalAlloc(GMEM_FIXED, get_size()); memset(p_glo, 0, get_size()); get_data_params(p_touch_alg_out, &amp;p_d); // 指针 get_data_params(p_touch_alg_out, p_d); // 引用 函数定义：
（指针）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f89e440252f87d090e6b337c3d672b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f18048f2b5db177632a6436fb4c3820/" rel="bookmark">
			yocto的hello world
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了辅助理解yocto编译的架构和编译过程，写一遍helloworld会好很多。
首先下载编译poky
$ git clone git://git.yoctoproject.org/poky $ cd poky $ source oe-init-build-env $ bitbake core-image-sato 创建自己的layer：meta-mylayer
$ bitbake-layers create-layer meta-mylayer NOTE: Starting bitbake server... Add your new layer with 'bitbake-layers add-layer meta-mylayer' 在poky目录下通过bitbake-layers增加meta-layer，提示找不到bblayers.conf，原来是要在build目录下添加才对：
hui@hui:~/disk4t/codes/poky $ bitbake-layers add-layer meta-mylayer NOTE: Starting bitbake server... Unable to find bblayers.conf 在build目录下add-layer, 没有指定meta-mylayer路径报错
hui@hui:~/disk4t/codes/poky/build $ bitbake-layers add-layer meta-mylayer NOTE: Starting bitbake server... Specified layer directory /home/hui/disk4t/codes/poky/build/meta-mylayer doesn't exist 指定路径后可以了：
$ bitbake-layers add-layer ../meta-mylayer NOTE: Starting bitbake server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f18048f2b5db177632a6436fb4c3820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2602438074a68269e905a02b902ae469/" rel="bookmark">
			使用SSM框架的简单项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSM框架的学习,跟着狂神做了一个SSM的项目,也是一个小的框架.
1.准备工作
(1)数据库的准备
创建一个名为ssmbuild的数据库,在库中建一个名为books的表,表的内容如下:
(2)创建一个空的maven项目,添加WebAPP文件
(3)在pom.xml中添加依赖以及静态资源到处问题
&lt;!--依赖--&gt; &lt;dependencies&gt; &lt;!-- 连接数据库依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.21&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 测试依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSP依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSP依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL表达式依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2602438074a68269e905a02b902ae469/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45c0d39722343376ce8d34c1203924fe/" rel="bookmark">
			ip协议介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、IPv4
1、IPv4数据报格式
2、IPv4数据报分片
3、IPv4编址
4.主机的IP地址是如何获取的？
二、IPv6
前言 本篇文章简单介绍计算机网络层的IPv4和IPv6以及它们的相关概念和区别，内容皆总结摘抄自《计算机网络：自顶向下方法》，仅作笔记。
一、IPv4 1、IPv4数据报格式 网络层的分组也叫做数据报，因此IPv4的分组也称为IPv4数据报。IPv4的数据报格式如下图：
下面按照顺序对以上数据报中的每个部分做简单的介绍。
版本 版本号的长度为4比特，规定了数据报的IP协议版本。路由器可以通过查看版本号来解释IP数据报的剩余部分。不同的IP版本使用不同的数据报格式。
首部长度 首部长度的长度为4比特，保存了该数据报的首部的长度。IPv4数据报可以包含一些可变数量的选项（上图中的32比特选项），因此对于不同的IPv4数据报来说真正的载荷实际开始的位置并不确定，首部长度就可以解决该问题。大多数IP数据报不包含选项，所以一般的IP数据报具有20字节的首部。
服务类型 服务类型的长度为8比特，保存了该IP数据报的类型。对于某些场景来说，区分IP数据报类型是有必要的。
数据报长度 数据报长度的长度为16比特，保存了该IP数据报的总长度（首部+数据），以字节计算。由于该字段长度为16比特，因此一个IP数据报的理论最大长度为2^16=65535个字节。
标识、标志、片偏移 这三个字段与IP分片有关，后面介绍分组分片时再着重介绍。
寿命 寿命（Time-To-Live，TTL）的长度为8比特，用来确保该数据报不会永远再网络中循环。每当一台路由器处理一个数据报时，数据报中的该字段的值减1，直到该字段的值减到0，数据报被丢弃。
上层协议 上层协议的长度为8比特，该字段指示了IP数据报在到达最终目的地时数据部分应该交给哪个特定的运输层协议。例如值为6表明数据部分要交给TCP协议，值为17表明要交给UDP协议。在IP数据报中的协议号所起的作用类似于运输层报文段中端口号字段所起的作用。协议号是将网络层与运输层绑定到一起的粘合剂，而端口号是将运输层和应用层绑定到一起的粘合剂。
首部检验和 首部检验和的长度为16比特，用于帮助路由器检测收到的IP数据报中的比特错误。首部中的每两个字节当作一个数，用反码算术对这些数求和，将最终的计算结果放入首部检验和字段中。路由器要对每个收到的IP数据报计算其首部检验和，如果数据报首部携带的首部检验和与计算得到的检验和不一致，则检测出是一个差错。路由器一般会丢弃检测出错误的数据报。每台路由器上必须重新计算检验和并再次存放到原处，因此TTL字段以及可能的选项字段会改变。
源/目的IP地址 当某源生成一个数据报时，它在源IP字段中插入它的IP地址，在目的IP地址字段中插入其最终目的地的地址。
选项 选项是对IP首部的扩展，虽然很少使用，但少量选项的存在使得一些问题变得较复杂。由于选项的存在，数据报首部的长度是可变的，因此不能预先确定数据字段从哪里开始。有些数据报要求处理选项，有些数据报则不要求，又导致一台路由器处理一个IP数据报所需的时间变换可能很大。因为各种原因，在IP版本6中去掉了选项。
数据（有效载荷） 在大多数情况下，IP数据报中的数据字段包含要交付给目的地的运输层报文段，也有些情况承载的是其他类型的数据。
2、IPv4数据报分片 并不是所有的链路层协议都能承载相同长度的网路层分组，有的协议能承载大数据报，而有的协议只能承载小的分组。一个链路层帧能承载的最大数据量叫做最大传送单元（Maximum Transmission Unit，MTU）。由于每个IP数据报都需要封装在链路层帧中从一台路由器传输到下一台路由器，因此链路层协议的MTU严格限制IP数据报的长度，更不用说在发送方与目的地路径上的每段链路可能使用不同的链路层协议且每种协议可能具有不同的MTU。对于这种场景来说，一个IP数据报的长度就不能保证比路径上的任何一段链路的MTU都要小，这时就需要将IP数据报中的数据分片成多个较小的IP数据报，用单独的链路层帧封装这些较小的IP数据报，每个这些较小的数据报都称为片。
由于在路由器中重新组装数据报会给协议带来相当大的复杂性并且影响路由器的性能，因此数据报的重新组装工作放到了端系统中，而不是放在网络路由器中。
当一台目的主机从相同源收到一系列数据报时，它需要确定这些数据报中的某些是否是一些原来较大的数据报的片。如果某些数据报是这些片，还需要进一步确定何时收到了最后一片，并且如何将这些接收到的片拼接到一起以形成初始的数据报。前面介绍IPv4数据报时数据报首部的标识、标志和片偏移字段可以帮助目的主机完成重新组装任务。当生成一个数据报时，发送主机在为该数据报设置源和目的地址的同时贴上标识号。发送主机通常将它发送的每个数据报的标识号加1.当某路由器需要对一个数据报分片时，形成的每个片具有初始数据报的源地址、目的地址与标识号。当目的地从同一发送主机收到一系列数据报时，它能够检查数据报的标识号以确定哪些数据报实际上是同一较大数据报的片。由于IP是一种不可靠的服务，一个或多个片可能永远到达不了目的地，为了让目的主机绝对地详细它已经收到了初始数据报的最后一片，最后一个片的标志比特被设为0，所有其他片的标志比特被设为1。为了让目的主机确定是否丢失了一个片且可以按照正确的顺序重新组装片，使用片偏移字段来指定该片在初始IP数据报的哪个位置。
3、IPv4编址 在介绍IP编址前先来介绍下主机和路由器接入网络的方法以便于我们更好地理解IP编址。一台主机通常只有一条链路连接到网络；当主机中的IP想发送一个数据报时，它就在该链路上发送。主机与物理链路之间的边界叫做接口。路由器与主机不同，路由器的任务是从链路上接收数据报并从其他链路转发出去，因此路由器必须有两条或更多的链路与它连接。路由器与它的任意一条链路之间的边界也叫做接口，因此一台路由器有多个接口，每个接口都有其对应的链路。IP要求每台主机和路由器接口拥有自己的IP地址，因此，从技术上来说一个IP地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联。
每个IP地址的长度为32比特，即4个字节，因此最多可以有2^32个可能的IP地址。IP地址通常按照点分十进制法书写，即地址中的每个字节用它的十进制书写，各字节间以句点隔开。例如IP地址192.12.214.8，其中192是该地址的第一个8比特的十进制等价数，12是该地址的第二个8比特的十进制等价数，依次类推。因此192.12.214.8的二进制记法是：
11000000 00001100 11010110 00001000 一个接口的IP地址的一部分需要由其连接的子网来决定。下图中一台具有3个借口的路由器互联了7台主机，仔细观察可发现左上侧包含了三台主机和路由器的一个接口的IP地址都是类似223.1.1.x，这说明它们IP地址的前24位比特是相同的。用IP的术语来说，互联这3个主机接口与1个路由器接口的网络形成一个子网。IP编址为这个子网分配了一个地址223.1.1.0/24，其中的/24记法有时称为子网掩码，表示拥有32比特的IP地址的最左侧24比特定义了子网地址。任何其他要连到223.1.1.0/24网络的主机都要求其地址具有223.1.1.x的形式。
因特网的地址分配策略被称为无类别域间路由选择（Classless Interdomain Routing,CIDR）。当使用子网寻址时，32比特的IP地址被划为分两部分，并且也具有点分十进制数形式a.b.c.d/x，其中x表示地址的第一部分中的比特数，被称为该地址的前缀或网络前缀。一个组织通常被分配一块连续的地址，且具有相同前缀的一段地址。在这种情况下，该组织内部的设备的IP地址将共享共同的前缀。而当该组织外部的一台路由器转发一个数据报，且该数据报的目的地址位于该组织内部时，仅需要考虑该地址的前缀即可。
在CIDR被采用之前，IP地址的网络部分被限制为长度为8、16或24个比特，这种编址方案叫做分类编址，具有8、16和24比特子网地址的子网分别被称为A、B和C类网络。然而对于一个C类子网（CIDR策略表示为/24）只能容纳2^8-2=254个（其中两个地址预留用于特殊用途）台主机，这对于很多组织来说太小了，B类子网（CIDR策略表示为/16）可以容纳2^16-2=65534台主机，又太大了。对于一个具有1000人的组织来说，分配一个C类子网远远不够，分配一个B类子网又有多达64000多个接口的地址空间浪费，因此分类编址是存在一些问题的。
IP地址255.255.255.255是一个广播地址。当一台数据发出一个目的地址为255.255.255.255的数据报时，该报文会交付给同一个网络中的所有主机，路由器也会有选择地向邻近的子网转发该报文。
4.主机的IP地址是如何获取的？ 某台主机的IP地址是由该主机所在的组织分配的，而组织的地址块则是互联网服务提供商（Internet Service Provider，ISP）从分配给它的一个更大的地址块中分出来的一些地址。全球有不知道多少个ISP，这些ISP的地址块也是需要分配的，因特网名字和编号分配机构（Internet Corporation for Assigned Names and Numbers，ICANN）就是管理IP地址空间并向各ISP和其他组织分配地址块的具有全球性的权威机构。该机构是非营利性质的，且还有管理DNS服务器以及分配域名与解决域名纷争的作用。
某组织获取一块地址后就可以为组织内的主机与路由器接口逐个分配IP地址。系统管理员通常手工配置路由器中的IP地址。主机地址也能手动配置，但一般使用动态主机配置协议（Dynamic Host Configuration，DHCP）来完成。DHCP允许主机自动获取一个IP地址。网络管理员可以通过配置DHCP使得给定的主机每次与网络连接时都能得到一个相同的IP地址，或者某主机将被分配一个临时的IP地址，每次与网络连接时该地址可能都不同。另外，DHCP还允许一台主机得到它的子网掩码、第一跳路由器地址与它的本地DNS服务器的地址等其他信息。
由于DHCP具有将主机连接进一个网络的网络相关方面的自动能力，因此它又常被称为即插即用协议或零配置协议。DHCP是一个客户-服务器协议。客户通常是新到达的主机，它要获得包括自身使用的IP地址在内的网络配置信息。在最简单的场景下，每个子网都有一台DHCP服务器。如果某个子网中没有DHCP服务器，则需要一个DHCP中继代理（通常是一台路由器），这个代理知道用于该网络的DHCP服务器的地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45c0d39722343376ce8d34c1203924fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/941b043722992306d465673f7b7b1362/" rel="bookmark">
			笔记本内存条的选择指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前市场上的内存条品牌众多，真假鱼龙混杂，好多贴牌产品的出现，让电脑小白花高价钱买了假内存条。
辨别内存条真假时主要看的是：品牌、颗粒、电阻。
主流品牌的内存条品牌：三星、海力士、镁光
上述的内存条品牌都有自己生产颗粒的能力，选这几个大牌在正规渠道就会减少一半的假货概率
但是有些不良商家用着拼装颗粒贴上品牌的贴纸冒充正品。
我给大家个鉴别方法：1、在正规渠道购买内存条，2、看内存条的颗粒丝印的是否清晰清楚，
3、在购买三星、海力士内存条时看电阻的颜色如果电阻是白色几乎都是正品，如果是黑色百分之百是假货，但是镁光内存条电阻都是黑色的。
大家肯定会有疑问，金士顿U盘和固态硬盘那么出名 为什么不选择金士顿的呢？
金士顿根本不生产内存颗粒，用的几乎是镁光和海力士的颗粒，所以在选择金士顿内存条一定要谨慎（很多贴牌假货）。
总而言是，不在乎钱买三星 海力士、差钱选择镁和使用镁光颗粒的英睿达、也可以买国货之光的记忆科技和威刚内存条，不怕内存条不好就怕买到假货！如果遇到选择困难可以私信我哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62fb33bc9204efb8538f582f837883d1/" rel="bookmark">
			服务器租用选择CDN加速能加快访问速度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		企业服务器租用的时候，最在意的也就是网站访问速度问题，这会直接关系到用户的访问体验，对业务发展至关重要，而CDN加速就能很好的解决这些问题。
什么是CDN？
CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。
CDN加速原理
CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。
CDN的基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。
通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。
其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。
CDN网络的诞生大大地改善了互联网的服务质量，因此传统的大型网络运营商纷纷开始建设自己的CDN网络。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7e111137819c50c486bd9ac964be8a6/" rel="bookmark">
			深度学习中AP、mAP、recall、IoU、NMS的评价指标介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、通过混淆矩阵实例给大家讲解各个指标：
混淆矩阵 预测01真实0TNFP1FNTP 真阳率：代表将真实正样本划分为正样本的概率
伪阳率：代表将真实负样本划分为正样本的概率
精确率：precision = TP / (TP + FP)
召回率：recall = TP / (TP + FN)
准确率：accuracy = (TP + TN) / (TP + TN + FP + FN)
2、AP（平均精度）
平均精度的计算方式这里我讲一种方式。
假设N个样本中有M个正例，那么我们会得到M个recall值（1/M，2/M，...，M/M），对于每个recall值r，我们可以计算出对应的（r` &gt;=r）最大值precision，然后对这M个precision值取平均即得到最后的AP值，计算方法如下：
AP衡量的是学出来的模型每个类别上的好坏。
3、mAP（平均精度均值）
mAP是衡量的学出来的模型在所有类别上好坏，公式如上。
4、precision-recall曲线
实际多分类任务中，我们需要知道从top-1到top-N（N是所测试样本个数）对应的precision和recall。显然随着我们选定的样本越来越多，recall一定会越来越高，而precision整体会呈下降趋势。把recall当成横坐标，即可得到常用的precision-recall曲线。
5、IOU指标
6、NMS（非极大值抑制）
执行原理：选出置信度最高的候选框，如果和当前最高分的候选框重叠面积IOU大于一定阈值，就将其删除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e14394934c9303c16a55aca0b0f08d4c/" rel="bookmark">
			03-Frida API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java对象 无论是想对so层亦或java层进行拦截，都必须编写Java.perform(). Java.available() 用来判断当前进程是否加载了JavaVM，Dalvik或ART虚拟机. function frida_Java(){ Java.perform(function () { if(Java.available) { console.log("hello java vm"); } else { console.log("error"); } }); } setImmediate(frida_Java,0); 运行代码，效果如图：
Java.androidVersion 显示Android系统版本号 function frida_Java(){ Java.perform(function () { if(Java.available) { console.log("", Java.androidVersion); } else { console.log("error"); } }); } setImmediate(frida_Java,0); 运行效果如图：
Java.enumerateLoadedClasses() 该API枚举当前加载的所有类信息，它有一个回调函数分别是onMatch、onComplete函数. function frida_Java(){ Java.perform(function () { if(Java.available) { Java.enumerateLoadedClasses({ onMatch:function (className) { console.log("",className) }, onComplete:function () { console.log("output complete!!!") } }); } else { console.log("error"); } }); } setImmediate(frida_Java,0); 运行效果如图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e14394934c9303c16a55aca0b0f08d4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa51edfca0318847796e5b49ce89ea28/" rel="bookmark">
			jsoncpp在window下的编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近对jsoncpp进行window下的lib库编译，发现网络中给出的方法要么收费，要么不是很全，这里根据最新下载jsoncpp的包目录进行整理。
JSON的官方网址: JSONhttp://www.json.org/
jsoncpp源码工程下载见网址：
GitHub - open-source-parsers/jsoncpp: A C++ library for interacting with JSON.A C++ library for interacting with JSON. Contribute to open-source-parsers/jsoncpp development by creating an account on GitHub.https://github.com/open-source-parsers/jsoncpp
这里下载的时候可以选择包或主路径。下载完成后的目录没有编译工程目录，这里需要先完成cmake编译器和phtyon的下载。然后通过cmake来完成编译。编译工程步骤：
1、在本地建立编译目录；
2、通过cmake选择，主要是源码路径选择和编译路径选择，截图如下（根据序号选择）：
注意：在“Configure”中需要选择编译器列表，根据自身的需求来选择对应的编译器，完成编译器工程的搭建，我这里选择的是VS2017编译器。通过“Generate”完成编译器工程搭建。
后面就可以在编译目录中选择对应的工程完成编译。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e9f1c0c9e9c09477a1a437c559dfed5/" rel="bookmark">
			HTML 5 video 视频标签全属性详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在如果要在页面中使用video标签，需要考虑三种情况，支持Ogg Theora或者VP8（如果这玩意儿没出事的话）的（Opera、Mozilla、Chrome），支持H.264的（Safari、IE 9、Chrome），都不支持的（IE6、7、8）。好吧，现在让我们从技术层面来认识HTML 5的视频，包括video标签的使用，视频对象可以用到的媒介属性和方法，以及媒介事件。转自这里
Video标签的使用 Video标签含有src、poster、preload、autoplay、loop、controls、width、height等几个属性， 以及一个内部使用的标签。Video标签内除了可以包含标签外，还可以包含当指定的视频都不能 播放时，返回的内容。
src属性和poster属性 你能想象src属性是用来干啥的。跟标签的一样，这个属性用于指定视频的地址。而poster属性用于指定一张图片，在当前视频数据无效时显示（预览图）。视频数据无效可能是视频正在加载，可能是视频地址错误等等。
preload属性 这个属性也能通过名字了解用处，此属性用于定义视频是否预加载。属性有三个可选择的值：none、metadata、auto。如果不使用此属性，默认为auto。
None：不进行预加载。使用此属性值，可能是页面制作者认为用户不期望此视频，或者减少HTTP请求。
Metadata：部分预加载。使用此属性值，代表页面制作者认为用户不期望此视频，但为用户提供一些元数据（包括尺寸，第一帧，曲目列表，持续时间等等）。
Auto：全部预加载。
autoplay属性 又是一个看名字知道用处的属性。Autoplay属性用于设置视频是否自动播放，是一个布尔属性。当出现时，表示自动播放，去掉是表示不自动播放。
注意，HTML中布尔属性的值不是true和false。正确的用法是，在标签中使用此属性表示true，此时属性要么没有值，要么其值恒等于他的名字 （此处，自动播放为或者）；而在标签中不使用此属性表示false（此处不进行自动播放为）。
loop属性 一目了然，loop属性用于指定视频是否循环播放，同样是一个布尔属性。
controls属性 Controls属性用于向浏览器指明页面制作者没有使用脚本生成播放控制器，需要浏览器启用本身的播放控制栏。
控制栏须包括播放暂停控制，播放进度控制，音量控制等等。
每个浏览器默认的播放控制栏在界面上不一样。由于我浏览器的诡异问题，Firefox和Safari的Video标签不正常，所以这两个只能在网上找截图了。
width属性和height属性 属于标签的通用属性了，这个不用多说。
source标签 Source标签用于给媒体（因为audio标签同样可以包含此标签，所以这儿用媒体，而不是视频）指定多个可选择的（浏览器最终只能选一个）文件地址，且只能在媒体标签没有使用src属性时使用。
浏览器按source标签的顺序检测标签指定的视频是否能够播放（可能是视频格式不支持，视频不存在等等），如果不能播放，换下一个。此方法多用于兼容不同的浏览器。Source标签本身不代表任何含义，不能单独出现。
此标签包含src、type、media三个属性。
src属性：用于指定媒体的地址，和video标签的一样。
Type属性：用于说明src属性指定媒体的类型，帮助浏览器在获取媒体前判断是否支持此类别的媒体格式。
Media属性：用于说明媒体在何种媒介中使用，不设置时默认值为all，表示支持所有媒介。你想到
一个完整的例子 这段代码在页面中定义了一个视频，此视频的预览图为poster的属性值，显示浏览器的默认媒体控制栏，预加载视频的元数据，循环播放，宽度为900像素，高度为240像素。
第一选择视频地址为第一个source标签的src属性值，视频类别为Ogg视频，视频编码译码器为Theora，音频编码译码器为Vorbis，播放媒 介为显示器；第二选择视频地址不再累述。如果你还要兼容IE的话，可以在最后一个source标签后再加上Flash播放器的标签集，或者使用一点 JavaScript代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25303f890abf09095032264f377a1b55/" rel="bookmark">
			Pytest之@pytest.mark.parametrize使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下内容纯属个人理解，如有不足，还请指正，转载请注明出处，喜欢请动动小指头点赞评论哦(▽)！
Fixture参数详解及使用
Fixture的调用方式：
参数详解：
1、SCOPE
scope = "function"
scope = "class"：
scope = "module"：与class相同，只从.py文件开始引用fixture的位置生效
scope = "session"：用法将在conftest.py文章内详细介绍
2、params:
3、ids:
4、autouse:
5、Name:
写在最后
Fixture的调用方式：
@pytest.fixture(scope = "function",params=None,autouse=False,ids=None,name=None)
1
参数详解：
1、SCOPE
用于控制Fixture的作用范围
作用类似于Pytest的setup/teardown
默认取值为function（函数级别），控制范围的排序为：session &gt; module &gt; class &gt; function
取值 范围 说明
function 函数级 每一个函数或方法都会调用
class 类级别 每个测试类只运行一次
module 模块级 每一个.py文件调用一次
session 会话级 每次会话只需要运行一次，会话内所有方法及类，模块都共享这个方法
作用范围举例：
scope = “function”
语法：
@pytest.fixture() #或者
@pytest.fixture(scope='function')
1
2
3
场景一：做为参数传入
# -*- coding:utf-8 -*-
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25303f890abf09095032264f377a1b55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06677100273eafccc0819e7dd0e2c411/" rel="bookmark">
			LINUX学习------Linux自动化运维——REDIS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、REDIS 1、Redis 简介 Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。
特点
1.Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
2.Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
3.Redis支持数据的备份，即master-slave模式的数据备份。
2、Redis 安装部署 server1
获取软件 redis-6.2.4.tar.gz
cd redis-6.2.4/ make ##编译 //当遇到’fatal error: jemalloc/jemalloc.h: No such file or directory‘错误 //删除redis 重新解压编译 make install	./install_server.sh	##安装 vim install_server.sh	##报错需注释 // _pid_1_exe="$(readlink -f /proc/1/exe)" #if [ "${_pid_1_exe##*/}" = systemd ] #then # echo "This systems seems to use systemd." # echo "Please take a look at the provided example service unit files in this directory, and adapt and install them.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06677100273eafccc0819e7dd0e2c411/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d998ba58999e6c10f678d48a7796f9d1/" rel="bookmark">
			用java计算定积分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：求在[0,6]区间上函数图像与x轴围成的面积。
根据积分公式可得：
用计算机的眼光看，以上公式可以这样表达
其中n表示将[0,6]这个区间上共细分多少个小的长方形，dx为每个小长方形的宽，如下图所示
直接上java代码
/** *@description : java 计算定积分 *@author jianglin *@date 2021/9/14 19:28 */ public class Test2 { public static void main(String[] args) { double from = 0.0; double to = 6.0; int count = 10; double dx = (to-from)/count; double s = 0.0; for (int i = 0; i &lt; count; i++) { s = s+(i*dx)*(i*dx)*dx; } System.out.println(s); } } count取不同的值，得到面积s的值如下
counts1061.55999999999999510070.9236100071.892035999999981000071.9892003600001110000071.99892000360049100000071.999892000036471000000071.99998919999865 从上述计算结果来看，随着细分的小长方形的个数的增多，计算结果越接近72
哈哈，向伟大的牛顿致敬！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f910e53ea45b535f2728d84f800f12f5/" rel="bookmark">
			香港服务器租用时考虑的因素主要有哪些方面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信大家对于香港服务器租用也已经不再陌生。随着海外贸易的兴起，香港服务器租用已经成为很多企业首要的选择对象。今天为大家总结了几点香港服务器租用需要考虑的因素，希望能帮助大家了解香港服务器，租用香港服务器。
1.服务器扩展性
企业在香港服务器租用的时候，一定要选择具备扩展性的服务器资源。随着业务的不断发展以及访问人群的增多，服务器的配置是需要不断的进行升级，以此满足业务不同需求。如果在前期业务开展的时候，选择的是不具备升级能力的服务器资源，那会对后期业务开展带来很大的麻烦。只有通过更换服务器才能解决问题，这势必会影响到企业的业务正常开展。
2.服务器稳定性
服务器稳定性非常重要。企业在香港服务器租用的时候需要对服务器稳定性进行测试，满意之后才开展业务。如果一旦服务器的稳定性受到影响，服务器会出现各类的故障问题，严重的时候会导致服务器无法正常的开展业务。
3.服务器配置
企业服务器租用需要根据自己的业务需求进行配置选择。前期业务量、访问人数不多的情况下，一般的配置即可。随着业务量和访问人群的增多，在慢慢对服务器进行升级即可。前期就把业务后期所需的配置都选择齐全，会导致前期服务器配置使用率不足，造成资源浪费以及所需配置花销增多。
4.服务商口碑
服务商是会负责服务器日常的运维管理。服务器出现任何故障问题，都是交由服务商进行处理解决。因此，服务商的技术能力以及故障恢复时间都是至关重要的因素。因此，在选择服务商的时候需要了解服务商的口碑和技术能力。
通过我们对于香港服务器租用的介绍，相信大家也都清楚了解了香港服务器租用需要注意的方面。在考量服务器租用的时候也应该知道如何进行选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95f6ecbf84aa800b570192429e77deae/" rel="bookmark">
			三年磨一剑，领域驱动设计布道师出版了《解构领域驱动设计》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解构领域驱动设计 作者：张逸
本书全面阐释了领域驱动设计（domain-driven design，DDD）的知识体系，内容覆盖领域驱动设计的主要模式与主流方法，并在此基础上提出“领域驱动设计统一过程”（domain-driven design unified process，DDDUP），将整个软件构建过程划分为全局分析、架构映射和领域建模3个阶段。除给出诸多案例来阐释领域驱动设计统一过程中的方法与模式之外，本书还通过一个真实而完整的案例全面展现了如何进行领域驱动设计统一过程的实施和落地。为了更好地运用领域驱动设计统一过程，本书还开创性地引入了业务服务、菱形对称架构、领域驱动架构、服务驱动设计等方法与模式，总结了领域驱动设计能力评估模型与参考过程模型。本书提出的一整套方法体系已在多个项目中推广和落地。
本书适合希望领会软件架构本质、提高软件架构能力的软件架构师，希望提高领域建模能力、打磨软件设计能力的开发人员，希望掌握业务分析与建模方法的业务分析人员，希望学习领域驱动设计并将其运用到项目中的软件行业从业人员阅读参考。
成书历程 本书内容主要来自我在GitChat发布的课程“领域驱动设计实践”。该课程历经两年打造，完成于2020年1月21日。当时的我，颇有感慨地写下如此后记：
课程写作结束了。战略篇一共34章，约15.5万字；战术篇一共71章，约35.1万字。合计105章，50.6余万字，加上2篇访谈录、2篇开篇词与这篇可以称为“写后感”的后记，共110章。如此成果也足可慰藉我为之付出的两年多的艰辛时光！
我对“领域驱动设计实践”课程的内容还算满意，然而，随着我对领域驱动设计的理解的蜕变与升华，我的“野心”也在不断膨胀，我不仅希望讲清楚应该如何实践领域驱动设计，还企图对这套方法体系进行深层次的解构。这也是本书书名《解构领域驱动设计》的由来。
所谓“解构”，就是解析与重构：
解析，就是要做到知其然更知其所以然；重构，则要做到青出于蓝而胜于蓝 领域驱动设计统一过程的提出， 从根基上改变了本书的结构。我调整和梳理了本书的写作脉 络，让本书呈现出与“领域驱动设计实践”课程迥然有别的全新面貌。本书不再满足于粗略地将内 容划分为战略篇和战术篇， 而是在领域驱动设计统一过程的指导下， 将该过程的3个阶段——全局 分析、架构映射和领域建模作为本书的3个核心篇，再辅以开篇和融合，共分为5篇（20章）和4个 附录，全面而完整地表达了我对领域驱动设计的全部认知与最佳实践。在对内容做进一步精简后， 本书仍然接近600页，算得上是软件技术类别的大部头了。
如何阅读这样一本厚书 若你时间足够充裕，又渴望彻底探索领域驱动设计的全貌， 我建议还是按部就班、循序渐进 地进行阅读。或许在阅读开篇的3章时，你会因为太多信息的一次性涌入而产生迷惑、困扰和不解， 这只是因为我期望率先为读者呈现领域驱动设计的整体面貌。在获得领域驱动设计的全貌之后，哪 怕你只是在脑海中存留了一个朦胧的轮廓，也足以开启自己对设计细节的理解和认识。
若你追求高效阅读，又渴望寻求领域驱动设计问题的答案，可以根据目录精准定位你最为关心 的技术讲解。或许你会失望，甚至产生质疑，从目录中你获得了太多全新的概念， 而这些概念从未 见于任何一本领域驱动设计的图书，这是因为这些概念都是我针对领域驱动设计提出的改进与补充， 是我解构全新领域驱动设计知识体系的得意之笔——要不然，一本技术图书怎么会写三年之久呢？我将自鸣得意的开创性概念一一罗列于此。
业务服务。业务服务是全局分析的基本业务单元，在统一语言的指导下完成对业务需求的 抽象，既可帮助我们识别限界上下文，又可帮助开发团队开展领域分析建模、领域设计建 模和领域实现建模。业务服务的粒度也是服务契约的粒度，由此拉近了需求分析与软件设 计的距离，甚至可以说跨越了需求分析与软件设计的鸿沟。 菱形对称架构。虽然菱形对称架构脱胎于六边形架构与整洁架构，但它更为简洁， 与限界 上下文的搭配可谓珠联璧合，既保证了限界上下文作为基本架构单元的自治性，又融入了 上下文映射的通信模式，极大地丰富了设计要素的角色构造型。 服务驱动设计。服务驱动设计采用过程式的设计思维， 却又遵循面向对象的职责分配， 能 在提高设计质量的同时降低开发团队的设计门槛，完成从领域分析模型到领域实现模型的 无缝转换，并可作为测试驱动开发的前奏，让领域逻辑的实现变得更加稳健而高效。 以上概念皆为领域驱动设计统一过程的设计元素， 又都能与领域驱动设计的固有模式有机融 合。对软件复杂度成因的剖析，对价值需求和业务需求的划分，在领域驱动设计统一过程基础上建 立的能力评估模型与参考过程模型，提出的诸多新概念、新方法、新模式、新体系，虽说都出自我 的一孔之见，但也确乎来自我的一线实践和总结，我自觉其可圈可点。至于内容的优劣，还是交给 读者评判吧。
专业书评 本书的读者是幸运的！我运用领域驱动设计磕磕绊绊十余年，阅读本书，深感它是一本可与《领域驱动设计》和《实现领域驱动设计》互补的书。阅读本书，相当于吸收了很多本书的精华。本书对相关概念进行深刻阐述，并大胆突破、创新架构，在领域驱动设计落地方面非常出色。
——周吉鑫 京东资深业务架构师
在拿到本书时，读者就几乎综览了过去20多年的软件开发历程所提到的诸多重要元素。本书结合大量实务案例来探讨为何需要战略指导、为何需要以固有的战术设计范式指导实践，并辅以领域驱动设计统一过程的指导原则，指引读者逐步落地。本书不单纯以领域驱动设计来讲老生常谈的方法，而更像一位坐在你身边的资深架构师，与你结对进行系统架构设计，一起探索软件架构设计的奥秘。
——高翊凯 Amazon Web Services资深解决方案架构师
我熟读了几乎所有的领域驱动设计经典著作，但仍旧从张逸先生的书中获益良多。我认为本书的广度、深度与创新性已经可以与该领域的国际经典著作看齐。本书的出版是领域驱动设计理论界的一个重要事件，是对软件行业在领域驱动设计方面的巨大贡献，必将降低整个行业掌握领域驱动设计的门槛，加速领域驱动设计的普及。同为领域驱动设计布道者，我将向我的同行强烈推荐本书。本书也是我本人将来开展工作的重要理论指导。
——王立 微信支付12级专家工程师、技术领导者
近年来，随着微服务的流行，国内对领域驱动设计的研究和实践愈发多了起来。我对领域驱动设计的态度是：相对于战术设计，应该更看重战略设计。本书创造性地提出领域驱动设计统一过程，可以说是推陈出新、自成一家。本书内容丰满、探讨深刻，精彩之处甚多，留待读者去发现。
——于君泽（右军）技术专家
详细目录 领域驱动设计（domain-driven design ，DDD）需要应对软件复杂度的挑战！那么，软件复杂度 的成因究竟是什么，又该如何应对？概括而言，即：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95f6ecbf84aa800b570192429e77deae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ea73a1fe83507e6f973651f906eaa77/" rel="bookmark">
			Better to Follow, Follow to Be Better
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Better to Follow, Follow to Be Better: Towards Precise Supervision of Feature Super-Resolution for Small Object Detection 阅读记录 论文链接
Abstract 作者认为下列两点可以提高特征超分辨的性能：
使用适当的高分辨特征作为训练特征超分辨网络的监督信号。匹配训练特征图像对的感受野。 introduction 略
Related Work 略
Mismatch of Relative Receptive Fields 上图中 I 1.0 I^{1.0} I1.0表示原图， I 0.5 I^{0.5} I0.5表示原图下采样0.5倍，我们的目标是获取感兴趣区域的高分辨特征和低分辨特征，使用该特征对监督训练特征超分辨网络。这个地方可能会遇到感受野不匹配的问题：
在超分辨感兴趣区域的过程中，如果使用相同的特征提取网络提取特征，会导致感兴趣区域的感受野不同。 如果我们用感受野不匹配的特征对去训练的话，将会严重误导超分辨模型。
这里作者举例证明，为什么使用相同的特征提取网络会提取到感受野不匹配的特征对。
首先我们需要搞清楚不同特征层之间感受野的映射关系。
上图的左边是特征提取网络的输入图像，右边网络输出的特征，这里我们只考虑水平维度。输入图像中的灰色框代表感兴趣区域，用右图中的灰色框表示它映射到特征图上位置。右图中的蓝色框表示特征图上的一个像素，它映射到原图中也是蓝色的框。
这里一共有四个参数：
I w I_w Iw​表示输入图像宽度； D D D表示特征提取网络下采样的比率； w w w表示特征中感兴趣区域的宽度； R w R_w Rw​表示特征图中一个像素映射到原图中的感受野。 I w I_w Iw​是已知的，当网络一定的条件下 D D D也是已知的，我们可以根据网络结构和和 D D D计算出 R w R_w Rw​的值（可以参考CNN 感受野计算公式）。有了这几个参数我们就可以根据下方的公式计算出特征图中宽度为 w w w的感兴趣区域映射到原图中的感受野。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ea73a1fe83507e6f973651f906eaa77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a0007fb916f311213cdd4112003b1a9/" rel="bookmark">
			leetcode记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.最长回文串 用dp：题目
class Solution { public String longestPalindrome(String s) { int len = s.length(); // 特判 if (len &lt; 2){ return s; } int maxLen = 1; int begin = 0; // 1. 状态定义 // dp[i][j] 表示s[i...j] 是否是回文串 // 2. 初始化 boolean[][] dp = new boolean[len][len]; for (int i = 0; i &lt; len; i++) { dp[i][i] = true; } char[] chars = s.toCharArray(); // 3. 状态转移 // 注意：先填左下角 // 填表规则：先一列一列的填写，再一行一行的填，保证左下方的单元格先进行计算 for (int j = 1;j &lt; len;j++){ for (int i = 0; i &lt; j; i++) { // 头尾字符不相等，不是回文串 if (chars[i] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a0007fb916f311213cdd4112003b1a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3018c408d83a479993059cd587bc374/" rel="bookmark">
			服务器-测试题(快来测验一下基础知识啦)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 下面关于http状态码理解正确的有？ [多选题]
A
http的状态码是有固定含义的，不能任意设置
B
状态码的值会出现的响应头中
C
如果出现了401，很可能是没有权限
D
通过res.statusCode可以来设置
2. 关于req.url的理解正确的是？ [多选题]
A
当访问地址是http://localhost:8000/abc时，req.url的值是/abc
B
当访问地址是http://localhost:8000/abc时，req.url的值是abc
C
当访问地址是http://localhost:8000，req.url的值是空的
D
当访问地址是http://localhost:8000，req.url的值是/
3. 服务器和客户端理解有误的一项是 [单选题]
A
服务器就是在计算机上安装能给其它电脑提供服务的软件
B
客户端在享受服务时一般也要先安装软件
C
数据库服务器是提供文件上传下载服务的
4. http模块的理解正确的是？ [单选题]
A
http模块是第三方模块，要先npm i 才能使用
B
http模块是用来操作文件相关的
C
我们可以使用http模块来写一个web服务器
5. http协议理解有误的是 [单选题]
A
浏览器与web服务器都要遵守的协议
B
全名是超文本传输协议
C
请求由三部分请求行，请求头，请求体组成
D
所有的请求都要有请求体
好啦,看下正确答案吧
1.
正确答案: ACD 你的答案:ACD
答案解析： 状态码出现在响应行中
2.正确答案: AD
3.正确答案: C 4.正确答案: C 5.正确答案: D
答案解析： get请求没有请求体
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1360260f955fcb945c672d762e352c44/" rel="bookmark">
			集合Map详述---HashMap、HashTable（底层实现原理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Map概述 1、Map特点 （1）Map和Collection没有继承关系，是单独的一个分支
（2）Map集合以键值对方式存储 &lt;key,value&gt;
key和value都是引用数据类型，存储的是对象的内存地址
key起到主导地位，value是key的一个附属品
2、Map接口中常用方法 向Map集合中添加键值对---------V put（K，V） 通过key获取value--------------V get(key) 获取map集合中所有key-------Set keySet（） 所有的键是一个set集合 获取map集合中键值对的个数----int size（） 获取map集合中所有value-----Collection values（） 通过key删除键值对------------V remove（key） 清空map集合-----------------void clear（） 判断是否包含某个key---------boolean cotainsKey（key） 判断是否包含某个value---------boolean cotainsValue（value） 判断是否是否为空，元素个数为0---------boolean isEmpty（） Map集合转成Set集合--------- Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 将map中的key和value转成一个set集合，set集合中存储的对象为Map.Entry类型对象，对象包含key和value两个属性 3、Map集合的遍历 Map&lt;Integer,String&gt; map=new HashMap&lt;&gt;(); map.put(1,"zs"); map.put(2,"ls"); map.put(3,"ww"); （1）获取所有key，通过遍历key，来遍历value
迭代器 //获得所有Key---Set集合 Set&lt;Integer&gt; keys=map.KeySet(); //迭代器遍历 Iterator&lt;Integer&gt; it=keys.iterator(); while(it.hasNext()){ System.out.println(it.next()); } foreach
//获得所有Key---Set集合 Set&lt;Integer&gt; keys=map.KeySet(); //foreach迭代 for(Integer k:keys){ System.out.println(k+"---&gt;"+map.get(k)); //1---&gt;zs } （2）将map集合全部转成set集合，遍历set集合（适合大数据量）
//Map集合---&gt;Set集合(key部分是一个Entry数组) Set&lt;Map.Entry&lt;Integer,String&gt;,String&gt; set=map.entrySet(); //迭代器遍历 Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it=set.iterator(); while(it.hasNext()){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1360260f955fcb945c672d762e352c44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24cbb760a9bf819c998967ff47ee93c9/" rel="bookmark">
			电子工程师入门基础模电知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 双电源电路限幅电路分压器偏置限幅电路钳位电路倍压电路设计三极管开关三极管开关应用--光控报警器 双电源电路 电路图：
放大器电路常常需要双电源供电，也就是双极性电源。利用双绕阻的变压器，结合整流全桥可以获得双电源。
双绕阻变压器实物图:
有的变压器只预留出两对中心管脚，按照变压器铭牌的指示把0v的两个管脚连接在一起就形成中心抽头了。
变压器的中心抽头直接连接到电路中作为地线，剩下的两个AC输出管脚，与整流桥的输入相连，从整流全桥输出的就是具有正负极性的直流信号，经过俩个电解电容C1和C2的滤波后，与地线就形成了双极性直流电源。
限幅电路 限幅电路专门打压超过限制幅度的信号，如果想要限制幅度的正半周，可用正向限幅电路，当正向信号超过0.7伏时，二极管D1导通，信号流入地中，此时输出信号不超过0.7伏。
反向限幅电路也是同理。
分压器偏置限幅电路 正向限幅电路：
负向限幅电路：
钳位电路 向交流信号添加一个直流偏置称为钳位。
正向钳位电路：
负向钳位电路：
倍压电路 倍压电路将输入的交流信号加倍后输出。
设计三极管开关 直流负载线：
直流负载线告诉我们在一个具体的电路中三极管饱和和截止时对应的Vcc和Ic值。如果三极管开关的闭合断开利用的是三极管的饱和和截止，那直流负载线可以帮助我们分析和设计三极管开关。
案例电路图：
确定参数：
三极管开关应用–光控报警器 假定蜂鸣器工作电流50mA,设计三极管开关电路如下：
确定参数：
解得R3等于47欧光敏电阻器报警，可通过改变电位器R2电阻改变报警时光线的强度。
光控继电器：
继电器的电磁铁受到三极管开关的控制。由于继电器中的电磁铁是一个电感线圈，当三极管开关断开一瞬间，线圈会产生一个反向的高电压，有可能使三极管Q2烧毁，所以电磁铁会与一个二极管并联，反向高压将通过二极管释放掉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cf687a9157bf18f87a150117c154f07/" rel="bookmark">
			SpringBoot读取配置文件配置信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一：通过Environment
通过Environment的getProperty()方法获配置信息,其中server.port就是指配置文件中的配置key
import org.springframework.beans.factory.annotation.Autowired; import org.springframework.core.env.Environment; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class ResourceController { //注入对象 @Autowired private Environment environment; @GetMapping("/hello") public String hello(){ //读取配置 String port = environment.getProperty("server.port"); System.out.println(port); return port; } } 第二种：通过@Value注入具体的配置信息
import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class ResourceController { //注入对象 @Value("${server.port}") private String port; @GetMapping("/hello") public String hello() { //读取配置 System.out.println(port); return port; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeb93b22c0ec44856e9d18d0d0961ff6/" rel="bookmark">
			MapperFacade使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入依赖 &lt;dependency&gt; &lt;groupId&gt;ma.glasnost.orika&lt;/groupId&gt; &lt;artifactId&gt;orika-core&lt;/artifactId&gt; &lt;version&gt;1.5.4&lt;/version&gt; &lt;/dependency&gt; 配置类 import ma.glasnost.orika.MapperFacade; import ma.glasnost.orika.MapperFactory; import ma.glasnost.orika.impl.DefaultMapperFactory; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class OrikaConfig { @Bean public MapperFactory mapperFactory() { return new DefaultMapperFactory.Builder().build(); } @Bean public MapperFacade mapperFacade() { return mapperFactory().getMapperFacade(); } } 使用举例 @Autowired private MapperFacade mapperFacade; DTO dto = mapperFacade.map(domain, DTO.class); List&lt;DTO&gt; dtoList = mapperFacade.mapAsList(domain, DTO.class); 报错排查 报错：
An exception occured while compiling the following method:
public void mapAtoB(java.lang.Object a, java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeb93b22c0ec44856e9d18d0d0961ff6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/211b8b327d38550280fdca892a8e7b9f/" rel="bookmark">
			Comparison method violates its general contract报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错代码： //报错代码 Comparator&lt;InspectReportListItemMpVo&gt; comparator = new Comparator&lt;InspectReportListItemMpVo&gt;() { @Override public int compare(InspectReportListItemMpVo o1, InspectReportListItemMpVo o2) { try { SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Date reportTime_o1 = simpleDateFormat.parse(o1.getReportTime()); Date reportTime_o2 = simpleDateFormat.parse(o2.getReportTime()); // return reportTime_o1.compareTo(reportTime_o2); return reportTime_o2.compareTo(reportTime_o1); } catch (ParseException e) { e.printStackTrace(); return 1; } } }; result.getItems().sort(comparator); 报错截图： Comparison method violates its general contract
问题解决： （不严谨！）将catch块里的return 1;改为return 0;
补充：严谨写法
Collections.sort(list, new Comparator&lt;String&gt;() { public int compare(String arg1, String arg2) { /** * 优化后写法 */ if(StringUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/211b8b327d38550280fdca892a8e7b9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f9a95f91ebae67b9d41d1e273be5de6/" rel="bookmark">
			IDEA tomcat 控制台中文乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA tomcat 控制台中文乱码
System.out.println 都是乱码
第一个修改，idea的目录中找：bin/idea64.exe.vmoptions 文件添加-Dfile.encoding=UTF-8
第二个修改，tomcat中部署项目时在VM options中添加 -Dfile.encoding=UTF-8
最重要的 重启重启重启IDEA！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7089ce5ec3d2e5cf3041b2b84e4c842/" rel="bookmark">
			HCIA——第六天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选取路由协议考虑到的几点要求：
1.占用资源少
2.收敛速度快
3.选路是否合理
RIP
1.以跳数作为开销值进行选路，本身存在不合理性
2.由于RIP本身计时器时间较长，收敛速度慢
3.RIP单个数据包占用资源并不算大，但是，因为RIP存在30s一次的周期更新，所以，整体看来，RIP的资源占用很大。
由于RIP三个维度的表现都不算太好，所以，只适用于中小型网络环境中
OSPF — 开放式最短路径优先协议 — 链路状态型
传递的是LSA — 链路状态信息
1.OSPF因为是链路状态型协议，所以计算出的路径不会出现环路，并且，OSPF以带宽作为开销值进行选路，相较于跳数更加合理。所以，从选路的角度看，OSPF由于RIP。
2.由于OSPF的计时器时间短于RIP的计时器，所以从收敛角度比较，OSPF优于RIP。
3.从单个数据包携带的数据来看，因为OSPF携带的是拓扑信息（LSA），所以数据量较RIP大很多，但是由于RIP存在30s一次的周期更新，并且OSPF本身存在很多减少更新量的措施，所以。从整体的角度看，OSPF小优于RIP。
OSPF版本：
OSPFV1（在实验室阶段夭折）、OSPFV2 — IPV4
OSPFV3 — IPV6
RIPV2和OSPFV2区别
相同点：
1.OSPFV2和RIPV2都是无类别的路由协议，都支持VLSM、CIDR
2.OSPFV2和RIPV2都以组播的形式发送信息 — RIP组播地址（224.0.0.9）、 OSPF组播地址（224.0.0.5和224.0.0.6）
3.OSPFV2和RIPV2都支持等开销负载均衡
不同点：
RIP只能适用于中小型网络，OSPF可以应用在大型网络当中（OSPF为了适应中大型网络环境，需要进行结构化部署 — 区域划分 — 减少更新量的手段之一）
如果只有一个区域的OSPF网络，我们将这样的网络称为单区域OSPF网络
如果只有一个区域的OSPF网络，我们将这样的网络称为多区域OSPF网络
区域划分的主要目的：
区域内部传递拓扑信息，区域之间传递路由信息。区域边界路由器 — ABR — 同时属于两个区域，并且一个接口对应一个区域。 区域划分的要求：
区域之间必须存在ABR区域划分必须按照星型拓扑结构划分星型拓扑中间区域叫做骨干区域 OSPF区域存在区域编号 — 区域ID —由32为二进制构成，用点分十进制进行表达。骨干区域的ID为0。 OSPF的数据包
hello包 — 可以用来周期发现，建立和保活邻居关系
周期：OSPF的hello包默认10s为周期进行周期发送
死亡时间（dead time）— 4倍的hello时间
RID — 用来标定和区分OSPF网络中不同的路由器
RID的要求：
全网（OSPF网络）唯一格式统一 — RID要求必须符合IP地址（由32位二进制构成，并且使用点分十进制进行表达） RID的获取方式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7089ce5ec3d2e5cf3041b2b84e4c842/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e45ca6a3e58767bd73891877ed1d7485/" rel="bookmark">
			phthon入门必备知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		phthon 新手入门 参考头歌编程
任务描述
本关任务：改正代码中不正确的缩进，使其能够正常编译，并输出正确的结果。
相关知识
缩进 Python 与 C/C++、Java 这些 C 类语言不同，Python 使用缩进来表示代码块，缩进的空格数量可以由个人习惯决定，但同一个代码块的缩进空格数必须相同。
if True:
print(“true”)
print(“true”)
else:
print(“false”)
print(“false”);
上面程序的 if 部分和 else 部分缩进不相同，但是在各自的代码块内缩进是相同的，所以是正确的程序。
if True:
print(“true”)
print(“true”)
这个程序的 if 部分缩进不相同，所以是错误的程序。
多行语句 Python 的代码一般是一行一条语句，语句之后的分号 ; 可加可不加。但如果要在一行中写多条语句，则需要用分号 ; 隔开每条语句。
print(“hello”)
print(“world”);
print(“hello”);print(“world”)
以上三行(四条语句)都是正确的。
标识符 标识符就是程序中，使用的各种名称，例如：变量名、常量名、类名等等。
在 Python 中，对标识符格式的要求与 C/C++、Java 等差不多：
第一个字符必须是字母表中的字母或下划线 _ ；
标识符的其他的部分，由字母、数字和下划线组成；
标识符对大小写敏感；
标识符不能与保留字相同。
保留字 保留字即关键字，是 Python 语言中内部使用的单词，代表一定语义。例如：and、class、if、else 等。保留字不能作为标识符，用在变量名、常量名、类名等地方。
Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：
```python import keyword print(keyword.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e45ca6a3e58767bd73891877ed1d7485/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a27e148e674580f6ad216ecd3add6331/" rel="bookmark">
			spconv安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3090上安装spconv步骤： 这一步要在安装完cmake和pytorch之后进行。
GitHub下载代码： git clone https://github.com/traveller59/spconv.git --recursive 安装依赖： sudo apt-get install libboost-all-dev -o APT::Get::Fix-Missing=true 安装： cd spconv python setup.py bdist_wheel cd ./dist ls #ls之后会显示你的whl文件的名称，复制下来用pip install安装 #换成自己的whl文件名字 pip install spconv-1.2.1-cp36-cp36m-linux_x86_64.whl #之后会有英文提示，安装成功 #检测安装是否成功 #命令行输入 python #如果可以import说明安装成功 可能会出现如下错误： 可能会出现如下错误： /home/sdb1/zyan/lulu/lib/python3.7/site-packages/setuptools/distutils_patch.py:26: UserWarning: Distutils was imported before Setuptools. This usage is discouraged and may exhibit undesirable behaviors or errors. Please use Setuptools' objects directly or at least import Setuptools first. "Distutils was imported before Setuptools.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a27e148e674580f6ad216ecd3add6331/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34275815d1b23e1410bc9eaeb655b278/" rel="bookmark">
			[C] 深度优先搜索解决连通块/染色问题——求岛的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍用DFS解决连通块个数问题 有关dfs的介绍见另外一篇：不撞南墙不回头——深度优先搜索
例题 宝岛探险 题目描述 一个小岛由一个主岛和一些复附属岛屿组成，该岛使用一个二维矩阵表示，其中数字表示海拔，0表示海洋，1~9表示陆地。探险家乘坐飞机降落在（6,8）处，现在需要统计探险家降落的地图的小岛数量，我们将探险家降落点上下左右相连接的陆地视作同一个岛屿。
本文介绍DFS的解法，如果想了解用BFS解最大连通面积，看另一篇文章：层层递进——C语言实现广度优先搜索
测试样例： 10 10 6 8 1 2 1 0 0 0 0 0 2 3 3 0 2 0 1 2 1 0 1 2 4 0 1 0 1 2 3 2 0 1 3 2 0 0 0 1 2 4 0 0 0 0 0 0 0 0 1 5 3 0 0 1 2 1 0 1 5 4 3 0 0 1 2 3 1 3 6 2 1 0 0 0 3 4 8 9 7 5 0 0 0 0 0 3 7 8 6 0 1 2 0 0 0 0 0 0 0 0 1 0 样例输出 4 解题思路 这里startx和starty是多余的，请注意。这次要定义一个num，初始值为0，每次更换颜色之前-1，表示当前的颜色。对于每个点进行一次遍历，当这个点不是海洋并且没有被染色（值大于零）时，对这个点进行dfs搜索，将这个点所连通的地方全部染成一个“色”就是同一个数（这个时候被染色了，就是负值了~）num取绝对值，就是岛的个数了。 题解 #include&lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34275815d1b23e1410bc9eaeb655b278/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b64a1522b886e0ae7a56bd87b1c5e9f/" rel="bookmark">
			Python基础学习(十二)---选择语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.前言2.选择结构1.if语句2. if...else3. if...elif...elif...else语句4.if语句的嵌套 1.前言 早上起来看，粉丝涨了好多，大家的支持是对我最大的鼓励，写这个Python系列文章直接目的是要完成毕业设计，现在正在备考12月的研究生考试，自己也是睡觉前，稍微学一点，积少成多。大家一起加油！
2.选择结构 选择结构大致被分成4种形式，分别是if语句，if…else语句，if…elif…elif多分支语句以及if语句的嵌套。
1.if语句 if 表达式: 条件语句 表达式可以是一个变量或者布尔值，也可以是比较表达式或逻辑表达式。如果表达式的结果为真就会执行条件语句，如果为假就跳出此判断往下继续运行。
例：当我们口渴的时候，我们会去喝水。通过流程图可以看出，此时会对是否口渴进行一个判断，如果口渴了则为True，则往下走执行喝水操作。
you = str(input('是否口渴，回答是或其他任何回答：')) if you == '是': # 如果回答‘是’，就会喝水。 print('喝水') 2. if…else if 表达式: 条件语句1 else: 条件语句2 例：当我们要判断某天是否要上班的时候，要判断当天是否是工作日，如果是工作日，那么就要去上班，如果不是工作日，那么就不去上班。
judge = str(input("今天是否工作日(回答是或否)：")) if judge == '是': print('需要去工作') else: print('不用去工作') else是不能单独使用的
3. if…elif…elif…else语句 对于一个问题处于多种选择的状态下，也可以理解为判断条件有多个值的时候，if…else就不能满足我们的需求，这时候我们就要借用elif来解决问题。
elif是等同于else+if，它的使用可以帮助我们简化代码，不至于是使用过多的if…else语句。
if 表达式1: 条件语句1 elif 表达式2: 条件语句2 elif 表达式3: 条件语句3 else: 条件语句4 例1：
我们在旅游的时候总是离不开交通工具的选择
1）我们可以首先进行判断高铁是否可以到达，如果满足就可以直接选择乘坐高铁。
2）如果不满足上条件可以判断是否可以乘坐火车到达，如果满足就可以选择乘坐火车。
3）如果不满足上条件可以判断是否可以乘坐飞机到达，如果满足就可以选择乘坐飞机，如果不能到达我们可以最后放弃出行或者更换旅游地点。
例2：
体质指标如下：
体质指数（BMI）=体重（kg）÷身高*身高（m）
成人的BMI数值：
过轻：低于18.5
正常：18.5-23.9
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b64a1522b886e0ae7a56bd87b1c5e9f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/283/">«</a>
	<span class="pagination__item pagination__item--current">284/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/285/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>