<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ad0439b7f34e067413ef2f94c2a263/" rel="bookmark">
			树莓派播放BadApple!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 原作者BadapplePi的播放github地址
整个项目是基于这个作者的代码使用的，同时他也提供了matlab的程序，能够让所有视频都能够处理为其效果在iic屏幕上进行播放。
自己fork添加了start.py作为主程序，修改了原始的图片数据以及一些播放代码(github链接)
播放效果视屏链接
准备 代码下载部分 下载代码的压缩包，或者你用git工具拉下来也可以
硬件部分 打开后，先看看当前树莓派的硬件引脚
pinout
IIC在GPIO2于GPIO3，按照位置把引脚和屏幕插好
然后修改IIC的屏幕速率
sudo vim /boot/config.txt
然后在最后添加
dtparam=i2c_baudrate=1000000
将iic的速率提高，不然后面播放是会很慢，重影的。
启用树莓派的I2C功能
sudo apt-get install -y python-smbus sudo apt-get install -y i2c-tools
安装程序用到的一些包(python) 更新
sudo python -m pip install --upgrade pip setuptools wheel
-m mod run library module as a script (terminates option list)
安装 PIL 库
sudo apt-get install python-pil python3-pil
安装 Adafruit-SSD1306 库
sudo pip install Adafruit-SSD1306
如果上面的 pip 安装 Adafruit-SSD1306 库遇到网络问题,使用一下命令安装 git clone https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7ad0439b7f34e067413ef2f94c2a263/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efc442336a6e2f79f5b572cdff917c23/" rel="bookmark">
			图嵌入（一）--综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://zhuanlan.zhihu.com/p/62629465
最近在学习Embedding相关的知识的时候看到了一篇关于图嵌入的综述，觉得写的不错便把文章中的一部分翻译了出来。因自身水平有限，文中难免存在一些纰漏，欢迎发现的知友在评论区中指正。
目录
一、图嵌入概述
二、图嵌入的挑战
三、图嵌入的方法
一、图嵌入概述 图，如社交网络、单词共存网络和通信网络，广泛地存在于各种现实应用中。通过对它们的分析，我们可以深入了解社会结构、语言和不同的交流模式，因此图一直是学界研究的热点。图分析任务可以大致抽象为以下四类: ( a )节点分类，( b )链接预测，( c )聚类，以及( d )可视化。其中，节点分类旨在基于其他标记的节点和网络拓扑来确定节点的标签(也称为顶点)。链路预测是指预测缺失链路或未来可能出现的链路的任务。聚类用于发现相似节点的子集，并将它们分组在一起；最后，可视化有助于深入了解网络结构。
真实的图（网络）往往是高维、难以处理的，20世纪初，研究人员发明了图形嵌入算法，作为降维技术的一部分。他们首先根据实际问题构造一个D维空间中的图，然后将图的节点嵌入到d（d&lt;&lt;D）维向量空间中。嵌入的思想是在向量空间中保持连接的节点彼此靠近。拉普拉斯特征映射（Laplacian Eigenmaps）和局部线性嵌入（Locally Linear Embedding ，LLE）是基于这一原理的算法的例子。然而，可伸缩性是这种方法的一个主要问题，它的时间复杂度是O (| V| 2)。
自2010年以来，关于图嵌入的研究已经转移到解决网络稀疏性的可伸缩图嵌入技术上。例如，图分解（Graph Factorization）使用邻接矩阵的近似分解作为嵌入。LINE扩展了这种方法，并试图保持一阶和二阶近似。HOPE通过使用广义奇异值分解( SVD )分解相似性矩阵而不是邻接矩阵来扩展LINE以试图保持高阶邻近性。SDNE 使用自动编码器嵌入图形节点并捕捉高度非线性的依赖关系。这些新的可扩展方法的时间复杂度为0 ( | E | )。
二、图嵌入的挑战 如前所述，图嵌入的目标是发现高维图的低维向量表示，而获取图中每个节点的向量表示是十分困难的，并且具有几个挑战，这些挑战一直在推动本领域的研究：
属性选择：节点的“良好”向量表示应保留图的结构和单个节点之间的连接。第一个挑战是选择嵌入应该保留的图形属性。考虑到图中所定义的距离度量和属性过多，这种选择可能很困难，性能可能取决于实际的应用场景。可扩展性：大多数真实网络都很大，包含大量节点和边。嵌入方法应具有可扩展性，能够处理大型图。定义一个可扩展的模型具有挑战性，尤其是当该模型旨在保持网络的全局属性时。嵌入的维数：实际嵌入时很难找到表示的最佳维数。例如，较高的维数可能会提高重建精度，但具有较高的时间和空间复杂性。较低的维度虽然时间、空间复杂度低，但无疑会损失很多图中原有的信息。 三、图嵌入的方法 在过去的十年里，在图形嵌入领域已经有了大量的研究，重点是设计新的嵌入算法。发展到现在，大体上可以将这些嵌入方法分为三大类：( 1 )基于因子分解的方法，( 2 )基于随机游走的方法，以及( 3 )基于深度学习的方法。在下文中我将简要解释每一个类别的特征与每一类别代表性算法的原理。
1.预备知识与符号定义 定义1 图：一个图G(V,E)由顶点集V={v1,…,vn}与边集
构成，图的邻接矩阵S则由每条边的权值
构成。如果顶点vi和vj之间没有边连接，那么
。如果图是无向图，则
。
边的权值Sij表示vi和vj的相似度，由特定的评价函数得出，值越高则两个顶点越相似。
定义2 一阶近似：边缘权重也被称为节点vi和vj之间的一阶近似值，因为它们是两个节点之间第一个也是最重要的相似性度量。
定义3 二阶近似：一对节点之间的二阶近似描述了该对节点邻域结构的相似性。设
表示vi和其他节点之间的一阶接近。然后，根据si和sj的相似性确定vi和vj之间的二阶近似。二阶近似比较两个节点的邻域，如果它们具有相似的邻域，则将它们视为相似的。
在上图中因为6和7之间有边连接，所以6和7一阶近似。5和6之间虽然没有边，但是它们有4个相同的邻居节点，所以5和6二阶近似。
定义4 图形嵌入：对于图G=（v，e），图嵌入是图的顶点的映射
，d&lt;&lt;|v|,函数f保留了图G上定义的一些相似度。因此，嵌入会将每个节点映射到低维特征向量，并尝试保留顶点之间的连接强度。例如，嵌入保留一阶近似可通过最小化
来获得接近。让两个节点对( vi，vj )和( vi，vk )与连接强度相关联，假如Sij&gt;Sik。在这种情况下，vj将被映射到嵌入空间中比vk的映射更接近vi的点。
2.基于因子分解的方法 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efc442336a6e2f79f5b572cdff917c23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1b902c00e3c1cc86e9d5150ed96055c/" rel="bookmark">
			论文阅读笔记(一)——SqueezeNet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文阅读笔记(一)——SqueezeNet 前言 寒假希望自己能够有所提升吧，不要再当一个简单地代码搬运工，所以希望自己能够坚持下来每天阅读一些文章，然后进行总结，冲冲冲
1 论文简介 1.1关于文章 论文全称: SQUEEZENET: ALEXNET-LEVEL ACCURACY WITH 50X FEWER PARAMETERS AND &lt;0.5MB MODEL SIZE
这里提供几个链接，大家可以自己下载下来学习
百度网盘
链接：论文原文
提取码：huzs
官网链接
论文链接：论文链接
代码链接：代码链接
1.2 关于squeezenet 其实这篇文章相较于后续的其他轻量化网络，其实可以学习借鉴的东西并不多，但是由于这篇属于轻量化网络的开篇之作，最早公开于2016年2月，所以我想借用这次机会，从头学习一下轻量化网络的演变路程，希望可以收获一些感悟
2 文章正文 2.1 摘要 近年来，深度卷积神经网络（CNNs）的研究主要集中在提高精度上。对于给定的精度级别，通常可以识别多个达到该精度级别的CNN架构。在同等精度的情况下，较小的CNN体系结构至少有三个优点：
1)较小的CNN在分布式训练期间需要较少的跨服务器通信。
2) 较小的cnn需要较少的带宽才能将新车型从云端导出到自动驾驶汽车。
3) 更小的CNN更适合部署在FP-GAs和其他内存有限的硬件上。
为了提供所有这些优势，我们提出了一个称为挤压网的小型CNN架构。SqueezeNet在ImageNet上实现AlexNet级精度，参数减少50倍。此外，通过模型压缩技术，我们可以将squezenet压缩到小于0.5MB（比AlexNet小510倍）。
可在此处下载SqueezeNet架构：https://github.com/DeepScale/SqueezeNet
2.2 文章动机 Motivation 其实文章的重点在大多数网络都在往深而精确的网络中改进，但是现实生活中由于计算平台的限制，比如嵌入式系统，比如车载系统中，都没法提供足够的算力来计算大型的CNN网络，而目的方法都是对网络进行剪枝，作者想要提供一种简洁的小型网络，来满足
1)更有效的分布式训练
2)可以将新模型导出到客户端时开销更小
3)可行的FPGA和嵌入式部署
所以提出了squeezeNet模块
3 squeezenet:用较少的参数保持精度 3.1 压缩策略 squeezenet模型主要使用了三个策略
将 3 × 3 3\times3 3×3卷积替换成 1 × 1 1\times1 1×1卷积。文章中将大多数 3 × 3 3\times3 3×3卷积替换为 1 × 1 1\times1 1×1卷积，这使得一个卷积操作的参数两减少了9倍减少 3 × 3 3\times3 3×3卷积的通道数。一个 3 × 3 3\times3 3×3卷积的计算量是 3 × 3 × M × N 3\times3\times M \times N 3×3×M×N其中M是输入Feature Map的通道数，而N是输出Feature Map的通道数，作者希望通过减少M.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1b902c00e3c1cc86e9d5150ed96055c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/148e09ca437291469009d2083fba199b/" rel="bookmark">
			图神经网络（二）--GNNs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://zhuanlan.zhihu.com/p/75307407
目录
一、什么是图神经网络
二、有哪些图神经网络
三、图神经网络的应用
一、什么是图神经网络？ 在过去的几年中，神经网络的兴起与应用成功推动了模式识别和数据挖掘的研究。许多曾经严重依赖于手工提取特征的机器学习任务（如目标检测、机器翻译和语音识别），如今都已被各种端到端的深度学习范式（例如卷积神经网络（CNN）、长短期记忆（LSTM）和自动编码器）彻底改变了。曾有学者将本次人工智能浪潮的兴起归因于三个条件，分别是：
计算资源的快速发展（如GPU）大量训练数据的可用性深度学习从欧氏空间数据中提取潜在特征的有效性 尽管传统的深度学习方法被应用在提取欧氏空间数据的特征方面取得了巨大的成功，但许多实际应用场景中的数据是从非欧式空间生成的，传统的深度学习方法在处理非欧式空间数据上的表现却仍难以使人满意。例如，在电子商务中，一个基于图（Graph）的学习系统能够利用用户和产品之间的交互来做出非常准确的推荐，但图的复杂性使得现有的深度学习算法在处理时面临着巨大的挑战。这是因为图是不规则的，每个图都有一个大小可变的无序节点，图中的每个节点都有不同数量的相邻节点，导致一些重要的操作（例如卷积）在图像（Image）上很容易计算，但不再适合直接用于图。此外，现有深度学习算法的一个核心假设是数据样本之间彼此独立。然而，对于图来说，情况并非如此，图中的每个数据样本（节点）都会有边与图中其他实数据样本（节点）相关，这些信息可用于捕获实例之间的相互依赖关系。
近年来，人们对深度学习方法在图上的扩展越来越感兴趣。在多方因素的成功推动下，研究人员借鉴了卷积网络、循环网络和深度自动编码器的思想，定义和设计了用于处理图数据的神经网络结构，由此一个新的研究热点——“图神经网络（Graph Neural Networks，GNN）”应运而生，本篇文章主要对图神经网络的研究现状进行简单的概述。
需要注意的是，图神经网络的研究与图嵌入（对图嵌入不了解的读者可以参考我的这篇文章《图嵌入综述》）或网络嵌入密切相关，图嵌入或网络嵌入是数据挖掘和机器学习界日益关注的另一个课题。图嵌入旨在通过保留图的网络拓扑结构和节点内容信息，将图中顶点表示为低维向量，以便使用简单的机器学习算法（例如，支持向量机分类）进行处理。许多图嵌入算法通常是无监督的算法，它们可以大致可以划分为三个类别，即矩阵分解、随机游走和深度学习方法。同时图嵌入的深度学习方法也属于图神经网络，包括基于图自动编码器的算法（如DNGR和SDNE）和无监督训练的图卷积神经网络（如GraphSage）。下图描述了图嵌入和图神经网络在本文中的区别。
二、有哪些图神经网络？ 在本文中，我们将图神经网络划分为五大类别，分别是：图卷积网络（Graph Convolution Networks，GCN）、 图注意力网络（Graph Attention Networks）、图自编码器（ Graph Autoencoders）、图生成网络（ Graph Generative Networks） 和图时空网络（Graph Spatial-temporal Networks）。
符号定义
1、图卷积网络（Graph Convolution Networks，GCN）
图卷积网络将卷积运算从传统数据（例如图像）推广到图数据。其核心思想是学习一个函数映射，通过该映射图中的节点可以聚合它自己的特征与它的邻居特征来生成该节点的新表示。图卷积网络是许多复杂图神经网络模型的基础，包括基于自动编码器的模型、生成模型和时空网络等。下图直观地展示了图神经网络学习节点表示的步骤。
GCN方法又可以分为两大类，基于谱（spectral-based）和基于空间（spatial-based）。基于谱的方法从图信号处理的角度引入滤波器来定义图卷积，其中图卷积操作被解释为从图信号中去除噪声。基于空间的方法将图卷积表示为从邻域聚合特征信息，当图卷积网络的算法在节点层次运行时，图池化模块可以与图卷积层交错，将图粗化为高级子结构。如下图所示，这种架构设计可用于提取图的各级表示和执行图分类任务。
在下面，我们分别简单介绍了基于谱的GCN和基于空间的GCN。
1.1 Spectral-based Graph Convolutional Networks
在大学里学过《数字信号处理》这门课程的朋友应该会记得，在这门课上我们通过引入傅里叶变换将时域信号转换到频域进行分析，进而我们完成一些我们在时域上无法完成的操作，基于谱的图卷积网络的核心思想正是来源于此。
在基于谱的图神经网络中，图被假定为无向图，无向图的一种鲁棒数学表示是正则化图拉普拉斯矩阵，即
其中，A为图的邻接矩阵，D为对角矩阵且
正则化图拉普拉斯矩阵具有实对称半正定的性质。利用这个性质，正则化拉普拉斯矩阵可以分解为
，其中
U是由L的特征向量构成的矩阵，𝚲是对角矩阵，对角线上的值为L的特征值。正则化拉普拉斯矩阵的特征向量构成了一组正交基。
在图信号处理过程中，一个图的信号
是一个由图的各个节点组成的特征向量， xi 代表第i个节点。
对图X的傅里叶变换由此被定义为
傅里叶反变换则为
为了更好地理解图的傅里叶变换，从它的定义我们可以看出，它确实将输入的图信号投影到正交空间，而这个正交空间的基（base）则是由正则化图拉普拉斯的特征向量构成。
转换后得到的信号x^的元素是新空间中图信号的坐标，因此原来的输入信号可以表示为
这正是傅里叶反变换的结果。
现在我们可以来定义对输入信号X的图卷积操作了
其中， g∈R 是我们定义的滤波器；⊙表示Hadamard product。
假如我们定义这样一个滤波器
那么我们的图卷积操作可以简化表示为
基于谱的图卷积网络都遵循这样的模式，它们之间关键的不同点在于选择的滤波器不同。
现有的基于谱的图卷积网络模型有以下这些：Spectral CNN、Chebyshev Spectral CNN (ChebNet)、Adaptive Graph Convolution Network (AGCN)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/148e09ca437291469009d2083fba199b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c48f1dcc0cbbbf542deaba7467066f8d/" rel="bookmark">
			19. 详解网络请求Axios
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Axios是什么？ Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。我们知道 Promise 是 js 异步的一种解决方案，它最大的特性就是可以通过 .then 的方式来进行链式调用。
其实说白了axios是对ajax的封装，axios有的ajax都有，ajax有的axios不一定有，总结一句话就是axios是ajax，ajax不止axios。
为什么选择axios? vue的作者尤雨溪推荐使用axios.符合前后端分离的趋势，及前端的MVVM的浪潮 功能特点： 在浏览器中发送XMLHttpRequests请求在node.js中发送http请求支持Promise API拦截请求和响应转换请求和响应数据取消请求自动转换 JSON 数据客户端支持防御 XSRF 支持多种请求方式： axios(config)axios.request(config)axios.get(url, [, config])axios.delete(url, [, config])axios.head(url, [, config])axios.post(url, [,data[,config] ])axios.put(url, [,data[,config] ])axios.patch(url, [,data[,config] ]) Axios的基本使用 axios的使用比较简单，文档讲的也非常清晰，你应该先阅读axios的官方文档：axios文档。
在html页面中直接引入使用:
&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; Html页面基本使用 以下案例中的get请求地址为crmeb相关演示站地址，可用于测试获取！
获取一个get请求 &lt;script&gt; const url = 'https://store.crmeb.net/api/pc/get_category_product' axios({ url: url, method: 'get', // 这里可以省略，默认为get }).then(res =&gt; { // 返回请求到的数据 console.log(res) }).catch(err =&gt; { // 返回错误信息 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c48f1dcc0cbbbf542deaba7467066f8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e445abc72252b7298c02ff9154205943/" rel="bookmark">
			中级软考信息安全工程师笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这次也是压线过嘤嘤嘤，先说一下感想叭，上午的题目出的中规中矩，70%~80%的知识点都是以往卷子里出过的，认真背书刷题的话上午及格不难，下午的题目和以往试卷比出的很笼统，过不过不是取决于评分者的判分，真的纯靠运气辽。
考场缺考的人还蛮多的，三个半小时还是几个小时的考试时间，不允许中途出来，我差不多半个多小时写完了，然后就只能在考场睡觉，无语子。
目录 历史和法规攻击主动攻击信息泄露陷门鲁棒性攻击：表达攻击:重放攻击：渗入威胁勒索软件端口邮件欺骗病毒的生命周期 保护网络安全防护体系分布式访问控制（Distributed access control）自主访问控制模型(Discretionary Access Control)强制访问控制模型（Mandatory Access Control）角色访问控制模型(Role-based Access) 隐私保护技术：数字水印防范缓冲溢出防范DDOS消息认证：数字签名：S-SDLCWPA认证方式:SSL和TLS风险评估:深度流检测技术审计系统三大功能模块：电子邮件协议IPsec协议：BLP规则俩条基本规则：安全电子交易（SET）PKI系统 （Public Key Infrastructure/公钥基础设施）物理隔离IDSIPS流量监控VPNRADIUSP2DR模型代码静态分析方法安全漏洞扫描防火墙 密码其他Tcp协议三次握手存储区域网络内存结构计算安全事件 历史和法规 1999年9月13日,由国家公安部提出并组织制定,国家质量技术监督局发布了《计算机信息系统安全保护等级划分准则》,并定于2001年1月1日实施其中把计算机信息安全划分为了5个等级： 第一级:用户自主保护级;
计算机信息系统可信计算机通过隔离用户与数据，使用户具备自主安全保护的能力。它具有多种形式的控制能力，对用户实施访问控制，即为用户提供可行的手段，保护用户和用户组信息，避免其他用户对数据的非法读写与破坏
第二级:系统审计保护级;
粒度更细的自主访问控制，通过登录规程、审计安全性相关事件和隔离资源，是用户对自己的行为负责
第三级:安全标记保护级;
提供有关安全策略模型、数据标记以及主体对客体强制访问的非形式化描述，具有准确标记输出信息的能力，这个级别的特点是计算机信息系统可信计算基，对所有主体以及所控制的客体实施强制访问控制。该级别要求为主体以及客体提供敏感标记，这类标记为等级以及非等级分类组合，是实施强制访问控制的依据
第四级:结构化保护级;
计算机信息系统可信计算基建立于一个明确定义的形式化安全策略模型之上，还要考虑隐蔽通道
第五级:访问验证保护级。
访问监控器仲裁主体对客体的全部访问。访问监控器本身是抗篡改的，必须足够小，能够分析和测试
定级四个要素：
信息系统所属类型、业务数据类型、信息系统服务范围、业务自动化处理程序
国家密码局 于2006年公布了“无线局域网产品使用的系列密码算法”，其中
签名算法是ECDSA
对称密码算法是SMS4密钥协商算法是ECDH
杂凑算法是SHA-256
其中ECDA和ECDH密码算法需要使用国家密码管理局指定的椭圆曲线和算法2016年11月7日，十二届全国常委会第二十四次会议以154票赞成1票弃权，表决通过了《中华人民共和国网络安全法》。该法律由全国人民代表大会常务委员会于2016年11月7日发布，自2017年6月1日起实施2017年6月1日《中华人民共和国网络安全法》开始实施
第二十一条：采取监测、记录网络运行状态、网络安全事件的技术措施，并按照规定留存相关的网络日志不少于6个月2018年10月，含有我国SM3杂项密码算法的ISO/IEC10118-3:1028《信息安全技术杂凑函数 第3部分：专用杂凑函数》最新一版由国际标准化组织（ISO）发布，SM3算法正式成为国际标准。2018年11，明确了国家落实网络安全的职能部门和职责，其中明确规定由国家网信部门负责统筹协调网络安全工作和相关监督管理工作月，作为补篇2017年纳入国际标准化的SM2/SM9数字签名算法，以正文形式随ISO/IEC14888-3:2018《信息安全技术带附录的数字签名的SM2/SM9 数字签名 第3部分：基于离散对数的机制》最新一版发布。
SM9：标识密码算法是一种基于双线性对的标识密码算法，它可以把用户的身份标识用以生成用户的公、私密钥对，主要用于数字签名，数据加密、密钥交换以及身份认证等。SM9算法不需要申请数字证书、适用于互联网应用的各种新兴应用的安全保障。如基于云技术的密码服务、电子邮件安全、智能终端保护、物联网安全、云存储安全
SM3：密码杂凑算法，分组长度为512比特
SM2：椭圆曲线公钥密码算法（替换RSA） 橙皮书（正式名称为可信任计算机标准评估标准）包括计算机安全级别的分类。
D1 级： 这是计算机安全的最低一级。整个计算机系统是不可信任的，硬件和操作系统很容易被侵袭。D1级计算机系统标准规定对用户没有验证，也就是任何人都可以使用该计算机系统而不会有任何障碍。系统不要求用户进行登记（要求用户提供用户名）或口令保护（要求用户提供唯一字符串来进行访问）。任何人都可以坐在计算机前并开始使用它。 D1级的计算机系统包括：MS-Dos、MS-Windows3.xe及Windows95(不在工作组方式中、Apple的System7.x C1 级 C1级系统要求硬件有一定的安全机制（如硬件带锁装置和需要钥匙才能使用计算机等），用户在使用前必须登录到系统。C1级系统还要求具有完全访问控制的能力，经应当允许系统管理员为一些程序或数据设立访问许可权限。C1级防护不足之处在于用户直接访问操作系统的根。C1级不能控制进入系统的用户的访问级别，所以用户可以将系统的数据任意移走。 常见的C1级兼容计算机系统如下所列：UNIX 系统、XENIX　、Novell3.x或更高版本、Windows NT C2 级 C2级在C1级的某些不足之处加强了几个特性，C2级引进了受控访问环境（用户权限级别）的增强特性。这一特性不仅以用户权限为基础，还进一步限制了用户执行某些系统指令。授权分级使系统管理员能够分用户分组，授予他们访问某些程序的权限或访问分级目录。另一方面，用户权限以个人为单位授权用户对某一程序所在目录的访问。如果其他程序和数据也在同一目录下，那么用户也将自动得到访问这些信息的权限。C2级系统还采用了系统审计。审计特性跟踪所有的“安全事件”，如登录（成功和失败的），以及系统管理员的工作，如改变用户访问和口令。 常见的C2级操作系统有：UNIX 系统、XENIX、Novell3.x或更高版本、Windows NT B1 级： B1级系统支持多级安全，多级是指这一安全保护安装在不同级别的系统中（网络、应用程序、工作站等），它对敏感信息提供更高级的保护。例如安全级别可以分为解密、保密和绝密级别。 B2 级 这一级别称为结构化的保护(Structured Protection)。B2 级安全要求计算机系统中所有对象加标签，而且给设备（如工作站、终端和磁盘驱动器）分配安全级别。如用户可以访问一台工作站，但可能不允许访问装有人员工资资料的磁盘子系统。 B3 级 B3级要求用户工作站或终端通过可信任途径连接网络系统，这一级必须采用硬件来保护安全系统的存储区。 A　级 这是橙皮书中的最高安全级别，这一级有时也称为验证设计(ve-rified design)。与前面提到各级级别一样，这一级包括了它下面各级的所有特性。A级还附加一个安全系统受监视的设计要求，合格的安全个体必须分析并通过这一设计。另外，必须采用严格的形式化方法来证明该系统的安全性。而且在A级，所有构成系统的部件的来源必须安全保证，这些安全措施还必须担保在销售过程中这些部件不受损害。例如，在A级设置中，一个磁带驱动器从生产厂房直至计算机房都被严密跟踪。　机密性：确保信息未经非授权的访问，避免信息泄露（不适用只针对机密性）、完整性（防止信息非法的修改和毁坏，包括信息的不可抵赖性和真实性）、可用性（保证信息及时且可靠的访问和使用）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e445abc72252b7298c02ff9154205943/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3b2674f88db469671fc31335580fc5f/" rel="bookmark">
			SequoiaiDB巨杉数据库-索引选择率的估算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引选择率的估算有两种方式：
使用统计信息进行估算使用默认值进行估算 使用默认值进行估算：
数值
在 [ -99999999.9, 99999999.9 ] 的区间中选取如 { $lt : 0 } 的选择率为：( 0 - ( -99999999.9 ) ) / ( 99999999.9 - ( -99999999.9 ) ) = 0.5 字符串
逐个字符计算在 ' ' （空格 ASCII 码：32）至 ASCII 码 127 之间的比例计算前 20 个字符 其他数据类型
相等比较：0.005大于、小于比较：0.333333范围比较：0.05 更多信息请访问巨杉数据库官网​​​​​​​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9b02c27497dcf58fd70adc70c25b4a7/" rel="bookmark">
			连接mysql的方法_MySQL入门系列_连接MySQL方法_详解 - 树懒学堂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初次接触MySQL的新手们都会苦恼于怎么连接MySQL数据库，本文就讲解了三种连接MySQL的方法，希望对正在MySQL进阶之路上的大家带来一些帮助。
一、通过命令行连接MySQL
我们可以通过MySQL命令提示符来连接MySQL数据库。
语法格式如下
下列是以命令行连接mysql数据库的语法：
[root@host]# mysql -u root -p
Enter password:******
-h：后面是数据库ip详细地址(localhost代表本机地址127.0.0.1)
-u：mysql登录名。(root：代表超级用户)
-P：紧跟数据库服务器端口(默认：3306，注意：-P 可以省去)
password：mysql数据库登陆密码(不建议跟在-p后边，回车键以后再输入)
在登录取得成功后会出現 mysql&gt; 命令提示对话框，你能在上面执行SQL。
在上述命令运行后，登录取得成功輸出結果:
Welcome to the MySQL monitor. Commands end with ; or \g.
Your MySQL connection id is 2854760 to server version: 5.0.9
Type 'help;' or '\h' for help. Type '\c' to clear the buffer.
在上述示例中，应用了root用户连接到mysql服务器，自然你也能够用别的mysql用户进行连接。
假如用户权限充足，那么用户就能够在mysql的命令提示对话框中执行SQL语句，从而进相关的操作。
当要退出mysql时，可以用 mysql&gt; 命令提示窗 exit命令，像下面这样：
mysql&gt;exit
Bye
二、通过PHP脚本连接MySQL
在可以浏览并操作数据库中的数据以前，用户需要先建立与MySQL数据库的连接。
在PHP中，这一目标可以用 mysql_connect() 函数来实现。
语法格式：
mysql_connect(servername,username,password);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9b02c27497dcf58fd70adc70c25b4a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f807b4d33030b635a81bb220c49f53a1/" rel="bookmark">
			项目经理，你有什么优势吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小编被一个问题问住了：你和别人比，你的优势是什么呢？
小编听到这个问题后，脱口而出道：”项目管理能力和经验啊。“
听者抬头看了一下小编，显然听者对小编的这个回答不是很满意，但也没有继续追问。
小编回家后思考这个问题，总是郁郁寡欢。
“自从开始干项目经理后，自己的特长是什么呢？
和开发人员比，没有专业的技术能力。和管理者比，没有高超的管理技巧。所以，特长究竟是什么呢？”小编心里折磨想道。
后来，小编找了一位前辈请教这个问题。
前辈说：每个人都有自己的优势，这个优势或许你没有发现，因为它不够优势。当你的优势不够凤毛麟角的时候，往往就相当于没有优势。所以发现自己的优势，然后把它做的更加拔尖。
项目经理比较其他岗位来说，有特别的技能优势，但是项目经理却也有着别的岗位不擅长的东西，这些东西可以通过后期的磨练和经验教训让它变成优势，让自己变得更加优秀，凤毛麟角。
优势一：大局观
为什么说大局观呢？首先来说一下项目经理是谁了？
项目经理是团队的核心，他前面要和客户频繁沟通，后面要和领导时时汇报，左边还要跟踪项目团队进展，右边要稳定供应商的情绪。
所以项目经理在项目中是需要把握项目方向的，明白项目的未来发展和发展趋势。
接下来，我们再说一下大局观。
大局观在百度里面的解释是这样的。大局观，通俗的说就是凡事长远考虑，以得与失的辩证关系原理看待问题。大局观，就是坚持到最后，不惜代价获取最终的胜利，不因局部胜负而耽误全局胜负，不在乎一城一地的得失。
既然大局观是这个意思，那么对于项目经理来说。从接受项目任务开始，到项目结束。项目经理应该从开始就能看到结尾，从表面就能看到深层，能洞察人心，掌握项目的发展方向，做到项目可控，目标一致。
优势二：计划能力
听了很多项目经理的经验分享，他们大部分总会提到一件事。做了太长时间的项目经理，在生活中也变得处处都是他的影子。比如每次出去玩，要写一下详细的旅行计划，计划有时能精确到小时。
是的，项目经理几乎无时无刻都在做计划，所以也就更擅长做计划。
项目经理的计划往往比其他人做的精确，精准，能很好的规避风险，能顺利达成目的。
优势三：看人的能力
除了列计划项目经理有一双洞察一切的眼睛，他能知道这个人的情绪、忠诚度、责任心等。
如果非要举一个例子那么只能这样说了，项目经理在面试的时候除了面试专业技能外，还要看这个人是否有责任心，交代给他的活儿能否顺利完成。还要看他的忠诚度，了解他是否没干多长时间就要跳槽。在项目进展中，项目经理也要时刻关注项目团队的人员情绪。
优势四：总结汇报能力
项目经理每周至少给客户汇报一次，每两天至少给领导汇报一次。如果一个项目持续时间是6个月的话，那么项目经理至少需要汇报72次。
所以项目经理一定具备良好的总结汇报能力。
项目经理能够回顾项目初期的规划是否合理、能够分析项目过程中是否存在问题、能够知道当时的解决方案是否是最优等等。通过抓住听者的点，知道他们最在意的是什么，然后汇报项目情况。
优势五：情商
情商高代表着很多事情，比如好沟通，比如容易相处。项目经理最大的优势在于情商高。
你想想，项目经理不仅要面对公司领导的压力、客户的压力、团队的压力、供应商的压力，甚至还有面对自己家庭和生活的种种压力。
相较而言，项目经理是一个容易产生情绪的岗位，会有不可避免的焦虑和烦躁。
所以情商高就变得尤为重要了。高情商是成功团队的重要保障，也是项目经理应该具备的最重要的一种“软技能”。
需要项目管理资料合集的同学可留言
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e41a4dd54c64434a4ae0557d2972ca8/" rel="bookmark">
			[Java]-会话技术与cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		会话技术 会话 一次会话中包含多次请求和相应，浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止，会话结束
功能 再一次会话范围内的多次请求间共享数据
方式 客户端会话技术：Cookie服务器端会话技术：Session Cookie 概念： 客户端会话技术，将数据保存到客户端
主要步骤: 创建Cookie对象，绑定数据 new Cookie(String name,String value) 发送Cookie对象 response.addCookie(Cookie cookie) 获取Cookie对象，拿到数据(getCookies方法获取全部Cookie并返回数组) request.getCookies() 创建Cookie与发送 @WebServlet("/CookieServlet") public class CookieServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //创建Cookie对象 Cookie cookie=new Cookie("msg","hello_world"); //发送Cookie response.addCookie(cookie); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } } 接收Cookie @WebServlet("/CookieServlet2") public class CookieServlet2 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取Cookie Cookie[] cookies=request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e41a4dd54c64434a4ae0557d2972ca8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2e1d599aedb051d3b5e0faef37b7d31/" rel="bookmark">
			小程序网络请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跨域的问题 小程序没有跨域的问题
跨域起源事浏览器同源策略
下面这个代码看似都没错 ，但是在小程序会报错* getData(){ wx.request({ url: 'http://jsonplaceholder.typicode.com/todos', //仅为示例，并非真实的接口地址 // methods:"post" success (res) { //请求成功后 console.log(res.data) } }) }, 强调一下小程序必须是加了密的 http是不行的
这个不安全
正常这些域名都是要自己去配置或者购买
为了方便我们可以看下面这个勾选那个就ok
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e8c57fdb94d2e3f13711bed6c6b26cc/" rel="bookmark">
			二、ovs-dpdk ——介绍及解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ovs-dpdk ovs-dpdk提供了用户态快速路径dpif-netdev替代了原来的内核datapath和用户态dpif-netlink。
架构解析 dpif-netdev：用户态的快速通路，实现了基于netdev设备的dpif API。
ofproto-dpif：实现了基于dpif层的ofproto API。
netdev-dpdk：实现了基于DPDK的netdev API，其定义的几种网络接口如下：
dpdk物理网口：其实现是采用高性能向量化DPDK PMD的驱动。
dpdkvhostuser接口： vhost-user可以挂接到用户态的数据通道上，与虚拟机的virtio网口快速通信。为了性能，在vhost burst收发包个数上，需要和dpdk物理网口设置的burst收发包个数相同。
dpdkr：其实现是基于DPDK librte_ring机制创建的DPDK ring接口。dpdkr接口挂接到用户态的数据通道上。（已经弃用）
DPDK加速的OVS数据流转发的大致流程如下：
1）OVS的ovs-vswitchd接收到从OVS连接的某个网络端口发来的数据包，从数据包中提取源/目的IP、源/目的MAC、端口等信息。
2）OVS在用户态查看精确流表和模糊流表，如果命中，则直接转发。
3）如果还不命中，在SDN控制器接入的情况下，经过OpenFlow协议，通告给控制器，由控制器处理。
4）控制器下发新的流表，该数据包重新发起选路，匹配；报文转发，结束。
DPDK加速的OVS与原始OVS的区别在于，从OVS连接的某个网络端口接收到的报文不需要openvswitch.ko内核态的处理，报文通过DPDK PMD驱动直接到达用户态ovs-vswitchd里。
数据流向 从物理或虚拟接口进入OvS-DPDK的数据包会根据其标头字段接收唯一的标识符或哈希，然后将其与三个主要交换表之一中的条目进行匹配：精确匹配缓存（EMC），数据路径分类器（dpcls）或ofproto分类器。数据包的标识符将按顺序遍历这三个表中的每一个，除非找到匹配项，在这种情况下，将执行表中匹配规则指示的适当操作，并在完成所有操作后将数据包转发出交换机。
这三个表具有不同的特性和相关的吞吐量性能/延迟。EMC为有限数量的表条目提供了最快的处理速度。数据包的标识符必须与该表中所有字段（源IP和端口，目标IP和端口以及协议的5元组）的条目完全匹配，以实现最快的处理，否则它将在EMC上“遗漏”并传递给dpcls。dpcls包含更多表条目（安排在多个子表中），并启用数据包标识符的通配符匹配（例如，指定了目标IP和端口，但允许任何源）。这大约提供了EMC吞吐量性能的一半，并且可以满足大量的表条目。
dpcls上的未命中会导致将数据包标识符发送到ofproto分类器，以便OpenFlow控制器可以决定操作。该路径性能最低，比EMC慢10倍以上。ofproto分类器中的匹配导致在更快的交换表中建立新的表条目，以便可以更快地处理相同流中的后续数据包。
EMC插入概率
默认情况下，每100个流中有1个插入到精确匹配缓存（EMC）中。可以通过设置emc-insert-inv-prob选项改变此插入概率:
ovs-vsctl --no-wait set Open_vSwitch . other_config:emc-insert-inv-prob=N
EMC是以PMD为边界的，每个PMD拥有自己的EMC；dpcls是以端口为边界的，每个端口拥有自己的dpcls；ofproto classifier是以桥为边界的，每个桥拥有自己的ofproto classifier
SMC 缓存 (实验性质)
SMC缓存或签名匹配缓存是继EMC缓存之后的一个新的缓存级别。SMC和EMC的区别在于SMC只存储流的签名，因此它的内存效率要高得多。使用相同的内存空间，EMC可以存储8K流，而SMC可以存储1M流。当流量大于EMC的大小时，通常关闭EMC并打开SMC是有益的。当前SMC默认情况下是关闭的，并且还是一个实验功能。
开启SMC:
ovs-vsctl --no-wait set Open_vSwitch . other_config:smc-enable=true
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20fb9669b115077e5c1aef37b174978b/" rel="bookmark">
			Ubuntu16.04桌面菜单栏移到屏幕下方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 gsettings set com.canonical.Unity.Launcher launcher-position Bottom 移回去
gsettings set com.canonical.Unity.Launcher launcher-position Left 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccd24228d486c1369e8534009ac00208/" rel="bookmark">
			安装虚拟机VMware 15 &#43; Ubuntu 18.04一条龙方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天为大家展示的是安装虚拟机 VMware+Ubuntu18.04 方法，其实每个步骤并没有那么繁琐，只不过生怕因为手抖按错了哪个功能导致以后面临某些bug，所以小小的记录一下安装的过程。
首先我们要下载 VMware 虚拟机软件，这里你可以在官网上下载，也可以去其它地方寻觅一番。例如，我是好久前就关注了“哏儿都校园”公众号，在里面的软件目录下载的 VMware 15的安装包，并且对应的有安装方法（这里木有打广告，只是单纯的方便而已，毕竟有好多方式，话痨呀！），然后对应着安装方法有条不紊的进行安装。
下面就是要安装Ubuntu啦，一切都是为了linux！这里要先下载Ubuntu镜像，当然，可以去官网下载的Ubuntu的官方下载地址。为了保证下载速度，我是又使用了清华源下载的18.04.5版本镜像下载链接。
然后！！！为了更加直观且生动的展示Ubuntu安装过程（其实是懒），我推荐B站的一位视频主的教学，我就是根据他的操作一步一步安装的，话不多说附上链接：VMware虚拟机安装+安装Ubuntu18.04教学视频。当然，最后记得给你的Ubuntu换国内源，不然下载东西会很慢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8dc76db52f50ec06000a164a47a43d6/" rel="bookmark">
			2021 Duilib最新入门教程（六）Duilib界面设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言控件容器总结 前言 在前面有提到：用Duilib写一个界面软件，只需要用一个xml文件描述界面长什么样，然后在代码中写上操作界面之后怎么处理就可以了。
“描述界面长什么样”其实就是描述：1、这个界面上有哪些控件？2、这些控件是怎么布局的？这一篇先介绍Duilib自带的标准控件有哪些？然后再介绍这些控件是怎么布局的？
控件 控件指最基本的单元模块，比如：按钮、文本、编辑框等等。
Duilib控件之间的继承关系如下：
举个例子
界面上显示一个按钮 按钮名字为"btn" 按钮文本为"按钮"
界面XML文件：&lt;Button name="btn" text="按钮" /&gt; &lt;表示开始 Button表示这个控件是一个按钮 name是一种属性，表示这个控件的名字，"btn"是这个属性的值 text也是一种属性，表示这个控件的文本，"按钮"是这个属性的值 /&gt;表示结束 所以界面要显示一个控件，只需要在XML文件上写：&lt;控件类型 属性类型=“属性值” … /&gt;
具体有哪些控件类型，控件对应的属性类型和属性值，都可以在属性列表.xml查看
容器 容器指可以容纳多个控件的模块，并且容器决定这些控件是怎么布局的。
Duilib容器之间的继承关系如下：
举个例子
界面的右上角一般有三个从左到右水平排放的按钮：最小、最大、关闭
对应的界面文件XML文件：
&lt;HorizontalLayout&gt; &lt;Button name="min" text="最小" /&gt; &lt;Button name="max" text="最大" /&gt; &lt;Button name="close" text="关闭" /&gt; &lt;/HorizontalLayout&gt; 总结 Duilib想要设计界面长什么样，只需要在xml文件上指定使用什么控件和容器就可以了。
Duilib技术交流群：799142530
源码地址：https://github.com/KongKong20/DuilibTutor
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c40a4ade2da84295f84fd1d58c8fe7a/" rel="bookmark">
			python ix函数_Python学习教程：从Excel到Python：最常用到的Pandas函数（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期的Python学习教程接着上次的讲，接着跟大家总结工作中最常用到的Pandas函数
数据预处理 本章主要讲的是数据的预处理，对清洗完的数据进行整理以便后期的统计和分析工作。主要包括数据表的合并，排序，数值分列，数据分组及标记等工作。
1.数据表合并
在Excel中没有直接完成数据表合并的功能，可以通过VLOOKUP函数分步实现。
在Python中可以通过merge函数一次性实现。
#建立df1数据表df1=pd.DataFrame({"id":[1001,1002,1003,1004,1005,1006,1007,1008],"gender":['male','female','male','female','male','female','male','female'],"pay":['Y','N','Y','Y','N','Y','N','Y',],"m-point":[10,12,20,40,40,40,30,20]}) 使用merge函数对两个数据表进行合并，合并的方式为inner，将
两个数据表中共有的数据匹配到一起生成新的数据表。并命名为
df_inner。
#数据表匹配合并df_inner=pd.merge(df,df1,how='inner') 合并的方式还有left，right和outer方式
df_left=pd.merge(df,df1,how='left')df_right=pd.merge(df,df1,how='right')df_outer=pd.merge(df,df1,how='outer') 2.设置索引列
索引列可以进行数据提取，汇总，数据筛选
#设置索引列df_inner.set_index('id') 3.排序(按索引，按数值)
Excel中可以通过数据目录下的排序按钮直接对数据表进行排
序
Python中需要使用ort_values函数和sort_index函数完成排序
#按特定列的值排序df_inner.sort_values(by=['age']) Sort_index函数用来将数据表按索引列的值进行排序。
#按索引列排序df_inner.sort_index() 4.数据分组
Excel中可以通过VLOOKUP函数进行近似匹配来完成对数值的分组，或者使用“数据透视表”来完成分组
Python中使用Where函数用来对数据进行判断和分组
#如果price列的值&gt;3000，group列显示high，否则显示lowdf_inner['group'] = np.where(df_inner['price'] &gt; 3000,'high','low') 还可以对多个字段的值进行判断后对数据进行分组，下面的代码中对city列等于beijing并且price列大于等于4000的数据标记为1。
#对复合多个条件的数据进行分组标记df_inner.loc[(df_inner['city'] == 'beijing') &amp; (df_inner['price']&gt;= 4000), 'sign']=1 5.数据分列
Excel中的数据目录下提供“分列”功能。
在Python中使用split函数实现分列在数据表中category列中的数据包含有两个信息，前面的数字为类别id，后面的字母为size值。中间以连字符进行连接。我们使用split函数对这个字段进行拆分，并将拆分后的数据表匹配回原数据表中。
#对category字段的值依次进行分列，并创建数据表，索引值为df_inner的索引列，列名称为category和sizepd.DataFrame((x.split('-') for x in df_inner['category']),index=df_inner.index,columns=['category','size']) #将完成分列后的数据表与原df_inner数据表进行匹配df_inner=pd.merge(df_inner,split,right_index=True, left_index=True) 数据提取 1.按标签提取(loc)
#按索引提取单行的数值df_inner.loc[3]id 1004date 2013-01-05 00:00:00city shenzhencategory 110-Cage 32price 5433gender femalem-point 40pay Ygroup highsign NaNcategory_1 110size CName: 3, dtype: object 使用冒号可以限定提取数据的范围，冒号前面为开始的标签值后面为结束的标签值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c40a4ade2da84295f84fd1d58c8fe7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f1e8715b185a935b2d7f4f9586e468c/" rel="bookmark">
			WSL设置Ubuntu主机名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wsl是系统中单纯的按linux的方法操作并不能修改hostname主机名；.即使修改/etc/hostname配置文件也一样无法修改主机名，正确的作法是修改windows计算机的hostname主机名：
打开系统属性界面后，点击“更改”： 2.在弹出的窗口中输入新的计算机名称，这里的计算机名称即wsl中显示的hostname主机名：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ff8fc198b0f689ee3da2305ca866000/" rel="bookmark">
			LVM扩展分区教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LVM扩展分区教程 1、原分区信息2、 进行磁盘分区3、创建虚拟卷4、查看虚拟组信息5、把磁盘扩展空间加入虚拟组6、把空余容量分配到lvm分区中7、执行分配命令，使得改变马上生效 分区操作有风险，操作之前务必备份重要数据
1、原分区信息 2、 进行磁盘分区 如果是新增磁盘，则将新磁盘分区即可，如果扩展磁盘，则将扩展空间做成一个分区即可
本次演示是虚拟机扩展磁盘，所以直接fdisk /dev/sda将扩展空间全部分配为/dev/sda3
直接执行fdisk /dev/sda，然后n新建分区，p设置为主分区，因为前面已经有两个分区，所以选择3，剩下的回车默认即可，最后输入w进行保存
3、创建虚拟卷 把刚才已经做好的分区，进行虚拟化，加入LVM卷
执行pvcreate /dev/sda3，磁盘信息根据实际情况变化
如果执行之后，提示Device /dev/sda3 not found (or ignored by filtering).重启设备再执行即可
pvcreate /dev/sda3 4、查看虚拟组信息 可以执行vgscan或者vgdisplay查看组名
vgscan结果
vgscan vgdisplay结果
vgdisplay 5、把磁盘扩展空间加入虚拟组 vgextend vg_master /dev/sda3 执行成功之后，可以通过vgdisplay查看
6、把空余容量分配到lvm分区中 df -h查看分区名称
lvextend -l +100%FREE /dev/mapper/vg_master-lv_root #即可把全部空闲容量分配给指定分区 附：lvextend是可以动态调整分区的，-l是按百分比分配，+表示增加；-L是安装指定容量分配，+表示增加，-表示减少，不带符号表示将分区调整至指定大小；
lvextend –L +20G /dev/mapper/vg_master-lv_root #root分区增加20G
lvextend –L -2G /dev/mapper/vg_master-lv_root #root分区减少2G
lvextend –L 20G /dev/mapper/vg_master-lv_root #root分区设置为20G
7、执行分配命令，使得改变马上生效 resize2fs /dev/mapper/vg_master-lv_root df -h可以查看分配之后的结果，30G容量，增加成功！！
附：如果使用ext4文件系统，执行resize2fs /dev/root_vg/root
如果使用xfs文件系统，xfs_growfs /dev/root_vg/root
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52a194df1f9d69bba0f8a9f955bf7ea0/" rel="bookmark">
			UMV config_db机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 UVM 提供了一套全局数据存取的机制，通过这种机制可以实现数据存取和交换。
典型应用 传递interface传递数据，类似全局变量传递object 接口说明 发送数据 config_db#(int )::set(this,“env.drv”,“pre_num”,100)
第一个参数：数据类型 ，可以是变量类型，也可以是接口类型也可以是对象类型。
第二个参数：uvm_compnent 实例的指针
第三个参数：相对第二个参数的路径
第四个参数：传递的实例名
第五个参数： 传递的实例的值
接收数据 config_db#(int )::get(this,"",“pre_num”,pre_num)
第一个参数：数据类型 ，可以是变量类型，也可以是接口类型也可以是对象类型。
第二个参数：uvm_compnent 实例的指针，因为是接收，可以使用this
第三个参数：相对第二个参数的路径
第四个参数：传递的实例名
第五个参数： 接收值存放的实例
举例 发送端 class c1 extends uvm_component;
int a = 1;
`uvm_component_utils_begin(c1)
`uvm_component_utils_end
uvm_config_db#(int)::set(“uvm_root”, “c2”, “a”, 1)
endclass
class c2 extends uvm_component;
int a = 1;
`uvm_component_utils_begin(c1)
`uvm_component_utils_end
uvm_config_db#(int)::get(“this”, “”, “a”, a)
endclass
大体就是这样一个流程，设置数据到全局存储区域，然后其他可以进行获取。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba6852d216854a5c32475b11e172c745/" rel="bookmark">
			亲测解决Ubuntu的sudo apt-get install下载更新很慢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小虎最近在重新配置opencv到Ubuntu Bionic，出现这个下载更新很慢的问题。经过一番摸索解决了这个麻烦。小虎下面两个方法都用了。
解决方法1 命令窗口输入：
sudo apt-get clean cd /var/lib/apt sudo mv lists lists.old sudo mkdir -p lists/partial sudo apt-get clean sudo apt-get update 解决方法2 命令窗口输入：
software-properties-gtk 选择主要服务器，main server。
参考资料 sudo apt-get upgrade too slow
apt-get update very slow, stuck at “Waiting for headers”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a9d55f54d9efa535ede8be5964a60ad/" rel="bookmark">
			3 物理层  数据通信基础知识  奈氏准则与香农定理 物理层传输介质 信道复用技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 物理层基本概念2 数据通信的基础知识2.1 典型的数据通信系统模型2.2 与通信相关的几个术语2.3 有关信道的几个概念2.4 基带(baseband)信号和带通(band pass)信号2.5 几种最基本的调制方法2.6 网卡传送信号时的编码格式2.7 信道的极限容量2.8 信道能够通过的频率范围2.8.1 奈氏准则2.8.2 香农公式2.8.3 奈氏准则与香农公式应用范围 3 物理层下传输介质3.1 导向传输媒体3.2 非导向传输媒体3.4 物理层设备---集线器 4 信道复用技术4.1 频分复用 FDM4.2 时分复用TDM4.3 统计时分复用 STDM4.4 波分复用 WDM 1 物理层基本概念 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。
物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：
机械特性 指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。电气特性 指明在接口电缆的各条线上出现的电压的范围（-5V到+5V）。功能特性 指明某条线上出现的某一电平的电压表示何种意义，例规定-5V表示0，+5V表示1。过程特性 指明对于不同功能的各种可能事件的出现顺序。 2 数据通信的基础知识 2.1 典型的数据通信系统模型 发送方的计算机网卡发出数字信号即数据比特流，给调制解调器变成模拟信号，再通过广域网传播，先经过调制解调器将模拟信号转化为数字比特流，再传给接收方计算机
2.2 与通信相关的几个术语 通信的目的是传递消息
数据(data)——运送消息的实体。信号(signal)——数据的电气的或电磁的表现。 “模拟的”(analogous)——代表消息的参数的取值是连续的。
“数字的”(digital)——代表消息的参数的取值是离散的。
码元(code)——在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。 在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为二进制码元。而这个间隔被称为码元长度。1码元可以携带nbit的信息量
2.3 有关信道的几个概念 信道一般表示向一个方向传送信息的媒体。所以咱们说平常的通信线路往往包含一条发送信息的信道和一条接收信息的信道。
单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。 2.4 基带(baseband)信号和带通(band pass)信号 基带信号（即基本频带信号）——来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。带通信号——把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。 因此在传输距离较近时，计算机网络都采用基带传输方式，由于在近距离范围内基带信号的衰减不大，从而信号内容不会发生变化。因此在传输距离较近时，计算机网络都采用基带传输方式。如从计算机到监视器、打印机等外设的信号就是基带传输的。 2.5 几种最基本的调制方法 基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带信号进行调制(modulation)。
最基本的二元制调制方法有以下几种：
调幅(AM)：载波的振幅随基带数字信号而变化。调频(FM)：载波的频率随基带数字信号而变化。调相(PM) ：载波的初始相位随基带数字信号而变化。 2.6 网卡传送信号时的编码格式 曼彻斯特编码 采用曼切斯特编码，一个时钟周期只可表示一个bit，并且必须通过两次采样才能得到一个bit
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a9d55f54d9efa535ede8be5964a60ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4acf99ddd7f7dde6ce2068f57ad281a/" rel="bookmark">
			Java集合：浅谈 Map集合的原理，底层以及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Map接口：Map底层HashMap：HashMap何时扩容，扩容的算法是什么Map的遍历方式：AbstractMap抽象类SortedMap接口HashMap和HashTable对比Map.Entry：Map里面的为null的情况 Map接口： 首先是基础以及常用方法：
Map是用来存储一组值的一个集合，每一组值都是采用key–&gt;value的形式进行存储，其中key是不可以重复的，每一个key都唯一的指向一个value.
Map接口中提供的常用的方法：
1.public V put(K key, V value):向Map集合中添加数据的方法，其中key指定键的值，value指定值所代表的数据
2.public V get(Object key):根据参数key找到key所对应的value
3.keySet():返回由所有的key组成的Set集合
4.values() :返回由所有的value组成的Collection集合
5.clear():清空Map集合中的全部的数据
6.Boolean containsKey(Object key):判断集合中是否包含参数key
7.Boolean containsValue(Object value) ：判断集合中是否包含参数value
8.public V remove(Object key):把指定的键 所对应的键值对元素 在Map集合中删除，可返回被删除元素的值。，不接收就不返回
9.size() :返回集合中的元素的个数
10.entrySet():返回Map集合中由Map.Entry实例化后的对象组成的Set集合
//Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。
11.Map.getOrDefault(Object key, V defaultValue)方法的作用是：
当Map集合中有这个key时，就使用这个key值；
如果没有就使用默认值defaultValue。
返回值：V 存储键值对的时候，key不重复，返回值v是null 存储键值对的时候，key重复，会使用新的value替换map中重复的value，返回被替换的value值 注意：
Map接口下的集合存储的键值对，而键值对其实是以Entry对象的形式存在Map集合中。即Map中存的是Entry对象
Map常用的子类：
Map底层 Hash Map底层是哈希表。使用HashMap要求添加的键类明确定义了hashCode()和equals()[可以重写hashCode()和equals()]，为了优化HashMap空间的使用，您可以调优初始容量和负载因子。
JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。
JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。如下图（其他博客某个大佬的图）：
​ 说明：
1，进行键值对存储时，先通过hashCode()计算出键（K）的哈希值，然后再数组中查询，如果没有则保存。
2，但是如果找到相同的哈希值，那么接着调用equals方法判断它们的值是否相同。只有满足以上两种条件才能认定为相同的数据，因此对于Java中的包装类里面都重写了hashCode()和equals()方法。
JDK1.8引入红黑树大程度优化了HashMap的性能，根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。
TreeMap：底层是红黑树（一般是用于需要有序的Map，且因为一直是平衡的，所以不要调优）
红黑树其实就是平衡二叉树，其还有五点定义：
(1)节点是黑色或者红色。
(2)根节点是黑色。
(3)每个红色节点的两个子节点都是黑色节点。
(4)每个叶子的节点都是黑色的空节点（NULL）。
(5)从任意节点到其每个叶子节点的所有路径都包含相同数量的黑色节点。
红黑树在增删的时候，需要先进行节点变色，如果变色已经解决不了了，就相应进行旋转，旋转之后如果不成功，再重复上述步骤
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4acf99ddd7f7dde6ce2068f57ad281a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22d799bad69eff934bf47fb26c61a4ee/" rel="bookmark">
			win10和ubuntu双系统下彻底删除ubuntu系统和grub引导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转载自：http://blog.sina.com.cn/s/blog_e8c35f550102x3ue.html
目的是删除grub引导，本质删除boot files里的/EFI/ubuntu文件夹
1、挂载EFI
打开命令提示符（管理员权限）
diskpart list disk select disk 0 # 根据你系统在哪个盘来选择 list partition select partition 1 # 选择系统分区，就是要挂载这个分区才能操作里面的文件 assign letter=p // 挂载为p盘 2、删除ubuntu、deepin文件夹
重新打开一个命令提示符界面
p: cd EFI dir # 可以看到Boot\Microsoft\deepin\ubuntu四个文件夹 rmdir /s ubuntu # 提示是否确认 y rmdir /s deepin # 提示是否确认 y 3、移除EFI挂载
回到第一个命令提示符界面
remove letter=p 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/706d8889bc81927092a922fbfbc11ad0/" rel="bookmark">
			【C&#43;&#43;11 笔记】关键字剖析 —— this
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、this 和 Python-self
二、this 指针
2.1 this 与 类成员
2.2 this 与 const 成员函数
2.3 在成员函数中返回 this
三、小结
3.1 this 指针再叙
3.2 this 指针用途
3.3 this 指针使用
一、this 和 Python-self 在 Python 中定义类时，无论是显式创建类的构造方法，还是向类中添加实例方法，都要求将 self 参数作为方法的第一个参数。当然，之所以命名为 self，只是程序员间约定俗成的一种习惯，使代码更具可读性。同一个类可实例化为多个对象，当某个类实例对象调用方法 (即“成员函数”) 时，它会把自身的引用作为第一个参数自动传给该方法，换言之，Python 会自动绑定类方法的第一个参数 self 指向调用该方法的对象。如此，Python 解释器就能知道到底要操作哪个对象的方法了。因此，程序在调用类实例方法和构造方法时，无需手动为第一个参数传值。抛砖引玉，Python 类方法中的 self 参数就相当于 C++ 中的 this 指针。更具体地：
在 C++ 中，每一个类实例对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数 (即“方法”) 的隐含参数。因此，在成员函数内部，this 指针 可用于指向调用该成员函数的类实例对象。
注意，友元函数没有 this 指针，因为友元不是类的成员，只有成员函数才有 this 指针。
二、this 指针 2.1 this 与 类成员 首先，看个例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/706d8889bc81927092a922fbfbc11ad0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/011dbfba5e14c2538747cca6f569a481/" rel="bookmark">
			封装是什么意思?_IPFS中的P1,P2,C1,C2是什么意思，封装过程需要多久呢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Filecoin 挖矿封装以及 P1/P2/C1C2 是什么意思
所谓封装是指按 Filecoin 的规定格式把数据进行灌装，那么 P1P2C1C2 其实就是打包灌装数据的四个过程而已。这四个单词就是 precommit1，precommit2，commit1，commit2.
pre 在英语中就是有提前或者准备的意思，对应的这四个单词就是预封装一阶段，预封装二阶段。封装一阶段，封装二阶段。如果刚看完还是一头雾水那就对了。下面形象化说明
第一阶段以箱子为例，来了一堆文件，数据怎么办？当然是把它们进行分割装箱了。因为在 IPFS 网络里，文件都要进行切片，最大不能超过 256K。那么把这个文件分割的这个阶段就叫做 P1。分割装箱的阶段需要大量的耗费 CPU。所以目前可以看见，Filecoin 的矿机都是 AMD 的 CPU。因为这个事，AMD 比较擅长。
第二阶段就是把这个装成小箱的数据碎片做好文件名和一些信息的记录。就是我们通常所说的动态哈希列表 DHT 的形成过程，那么以后要找文件。全凭这个 DHT。这个生成动态哈希列表的过程就叫 P2。因为这个过程需要生成默克尔苏，所以需要使用 GPU。也就是显卡资源，所以很多时候密封机会加一个显卡来干这个活。那么我们把数据分割装进小箱子之中然后又生成了文件的信息表之后。下一步要做什么？就是给这些小箱子贴标签，这就是 C1 的阶段，C1 阶段很省时间。一般几十秒就弄完了。
最后一个阶段叫 C2，要做的是零知识证明，就是为了将来提交时空证明而准备的，那么什么是零知识证明呢？就是存储这个阶段，在我不知道存储的内容的情况下，也能证明我已经保存了这个文件，那么这就是 C2 阶段。一半需要大量的并行计算，所有算力机是一个必备工具
总结：封装数据的过程就是 P1P2C1C2，P1 就是分割装箱，需要 AMD CPU 耗时几个小时。P2 就是生成文件的信息表也叫动态哈希列表 DHT 一般需要显卡。几十分钟干完活。C1 就是贴标签几十秒就够，C2 就是做零知识证明。一般需要算力机运作 30-40 分钟左右。
关注公众号，加微信了解跟过IPFS相关信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcaa1c947560635becfebea5d83afe4f/" rel="bookmark">
			计算机二级Excel考点精讲（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 计算机二级Excel考点精讲（四） 1.函数 rank(排名对象，数据区域，顺序)注意:数据区域需要绝对引用，顺序可省略绝对引用符号：$绝对引用的快捷键：F4或者FN+F4(笔记本电脑) countif(范围，条件) 单条件求个数
有一个bug：复制上个单元格造成的重复，无法避免
countifs(数据范围1，条件1，数据范围2，数据2)
sumif(数据范围，条件，计算求和区域)单条件求和sumifs(计算求和区域，条件范围1，条件1，条件范围2，条件2) sumproduct(数组1，数组2)sumproduct(数组1*教组2) vlookup(查询的对象，数据区域，列数，是否精确匹配)近似匹配需要升序排序 lookup（查询对象，{数据区域}，{结果区域}）
match(查询对象，查询区域，匹配类型)index(数据区域，行，列) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd1065e34c62c8556ef16e2bf23f50b1/" rel="bookmark">
			pandas.Series.add参数fill_value
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		fill_value: None或浮点数;填充NaN值;如果元素在2个series都是NaN,结果还是NaN;
pandas的一个重要功能,就是索引对齐,即在2个series里添加对应虚列,值为NaN
示例
a = pd.Series([1, 1, 1, np.nan], index=['a', 'b', 'c', 'd']) b = pd.Series([1, np.nan, 1, np.nan], index=['a', 'b', 'd', 'e']) a.add(b,fill_value=0) ------ a 2.0 b 1.0 c 1.0 d 1.0 e NaN dtype: float64 ====== # 填充过程为 a = pd.Series([1, 1, 1, np.nan,np.nan], index=['a', 'b', 'c', 'd','e']) b = pd.Series([1, np.nan, np.nan,1, np.nan], index=['a', 'b', 'c','d', 'e']) # b,c,d在序列a,序列b中有值, 对应位置填充0; e在2个series都为NaN,不填充; 最后填充为 a = pd.Series([1, 1, 1, 0,np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd1065e34c62c8556ef16e2bf23f50b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f24d83aaf272322790901da0b9b6994/" rel="bookmark">
			Jetbrains 软件代码无提示解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上可以搜到的是Power Save mode模式下的Auto Import冲突，删掉对应的类型可以解决；
还有一种情况是开了多个项目，只有其中一个项目不能提示，可以点击File-&gt;Invalidat Caches/Restart-&gt;INVALIDATE AND RESTART 清除缓存，重启即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbe9a9f9078cf381b5b220382b372a27/" rel="bookmark">
			FPGA - 基于FPGA的HDMI显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 HDMI接口很早之前就想调试了，由于没有时间，就拖到了现在，而且毕业设计也是和视频处理系统有关，就趁这个机会把这个接口调试下。
开发环境 vivado 18.3
pynq - z2
HDMI简介 高清晰度多媒体接口(英文:High Definition Multimedia Interface，HDMI)是一种数字化视频/音频接口技术，是适合影像传输的专用型数字化接口，其可同时传送音频和影像信号，最高数据传输速度为2.25GB/s，同时无需在信号传送前进行数/模或者模/数转换。
HDMI接口设计说明 HDMI输出驱动接口在FPGA方面应用时，主要有两种方式：
一种是采用HDMI（ DVI）编码芯片。这种操作只需要对对应芯片进行操作配置即可实现功能。
另外一种方式就是使用FPGA进行编写，由 IO 模拟方式实现。这里贴出我所使用的pynq-z2的对应模块的电路图并给出板子对应的信号引脚分配信息。
##HDMI Tx set_property -dict { PACKAGE_PIN L17 IOSTANDARD TMDS_33 } [get_ports { TMDS_Clk_n }]; #IO_L11N_T1_SRCC_35 Sch=hdmi_tx_clk_n set_property -dict { PACKAGE_PIN L16 IOSTANDARD TMDS_33 } [get_ports { TMDS_Clk_p }]; #IO_L11P_T1_SRCC_35 Sch=hdmi_tx_clk_p set_property -dict { PACKAGE_PIN K18 IOSTANDARD TMDS_33 } [get_ports { TMDS_Data_n[0] }]; #IO_L12N_T1_MRCC_35 Sch=hdmi_tx_d_n[0] set_property -dict { PACKAGE_PIN K17 IOSTANDARD TMDS_33 } [get_ports { TMDS_Data_p[0] }]; #IO_L12P_T1_MRCC_35 Sch=hdmi_tx_d_p[0] set_property -dict { PACKAGE_PIN J19 IOSTANDARD TMDS_33 } [get_ports { TMDS_Data_n[1] }]; #IO_L10N_T1_AD11N_35 Sch=hdmi_tx_d_n[1] set_property -dict { PACKAGE_PIN K19 IOSTANDARD TMDS_33 } [get_ports { TMDS_Data_p[1] }]; #IO_L10P_T1_AD11P_35 Sch=hdmi_tx_d_p[1] set_property -dict { PACKAGE_PIN H18 IOSTANDARD TMDS_33 } [get_ports { TMDS_Data_n[2] }]; #IO_L14N_T2_AD4N_SRCC_35 Sch=hdmi_tx_d_n[2] set_property -dict { PACKAGE_PIN J18 IOSTANDARD TMDS_33 } [get_ports { TMDS_Data_p[2] }]; #IO_L14P_T2_AD4P_SRCC_35 Sch=hdmi_tx_d_p[2] set_property -dict { PACKAGE_PIN R19 IOSTANDARD LVCMOS33 } [get_ports { HDMI_OEN[0] }]; #IO_0_34 Sch=hdmi_tx_hpdn HDMI和DVI（Digital Visual Interface）数字视频接口这两种数字视频传输标准的要求几乎完全相同，并同时处理一组高频和低频信号。这两种标准均采用TMDS(最小跳变差分信号又称最小化传输差分信号)技术来传输数据的高频(视频)部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbe9a9f9078cf381b5b220382b372a27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f1622050a1c436f7b97583edc1f874e/" rel="bookmark">
			lotus version 1.4.1 AddPiece 优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 lotus-miner --version lotus-miner version 1.4.1+git.e5efe57c9.dirty AddPiece 1分钟26秒 # cat /var/log/worker/worker.log | grep "acquired sector" 2021-01-21T23:32:17.407+0800	DEBUG	advmgr	sector-storage/worker_local.go:129 2021-01-21T23:33:43.832+0800	DEBUG	advmgr	sector-storage/worker_local.go:129 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e2ed095ac8c8f382dce8019f5a490b6/" rel="bookmark">
			学习笔记(二):逻辑斯蒂回归算法（Logistic Regression）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、算法简介
代码下载:https://download.csdn.net/download/xdg2008/16744956?spm=1001.2014.3001.5503
1.1 定义
逻辑斯蒂回归(Logistic Regression) 虽然名字中有回归，但模型最初是为了解决二分类问题,后来可以解决多分类问题。
线性回归模型帮助我们用最简单的线性方程实现了对数据的拟合，但只实现了回归而无法进行分类。因此LR就是在线性回归的基础上，构造的一种分类模型。
对线性模型进行分类如二分类任务，简单的是通过阶跃函数(unit-step function)，即将线性模型的输出值套上一个函数进行分割，大于z的判定为0，小于z的判定为1。
但这样的分段函数数学性质不好，既不连续也不可微。因此有人提出了对数几率函数，见上图右，简称Sigmoid函数。
该函数具有很好的数学性质，既可以用于预测类别，并且任意阶可微，因此可用于求解最优解。将函数带进去，可得LR模型为
其实，LR 模型就是在拟合 z = w^T x +b 这条直线，使得这条直线尽可能地将原始数据中的两个类别正确的划分开
1.2 损失函数表达式
回归问题的损失函数一般为平均误差平方损失 MSE，LR解决二分类问题中，损失函数为如下形式
L=∑ylogy+(1-y)log(1-y)
1.3梯度下降
得到了逻辑回归的表达式，下一步跟线性回归类似，构建似然函数，然后最大似然估计，最终推导出θ的迭代更新表达式。这个思路不清楚的请参考文章《线性回归、梯度下降》，只不过这里用的不是梯度下降，而是梯度上升，因为这里是最大化似然函数不是最小化似然函数
L=∑ylogy+(1-y)log(1-y)
转换后的似然函数对w求偏导，在这里我们以只有一个训练样本的情况为例：
这个求偏导过程第一步是对θ偏导的转化，依据偏导公式：y=lnx y'=1/x。
第二步是根据g(z)求导的特性g'(z) = g(z)(1 - g(z)) 。
第三步就是普通的变换。
这样我们就得到了梯度上升每次迭代的更新方向，那么θ的迭代表达式为：
逻辑回归误差对w和b的偏导数∂1,∂2 有以下公式:
∂1_w=X*(H(X)-Y)
其中:H(X)=sigmoid(Feature*Weight),Y=Label,X=Feature.T
二、案列实现
2.1 案列背景 杜紫藤女士, 一直在某婚恋网站上寻找自己中意的他, 网站给她推荐了很多男士, 但是她并不是每个都喜欢, 网站统计了这些男士的情况，
这些男士可以划分为如下几类:
(1)不喜欢的人(didntLike)
(2)魅力一般的人(smallDoses)
(3)极具魅力的人(largeDoses)
2.2 特征数字
杜紫藤女士收集了一些样本数据，她把样本数据存放在datingTestSet.txt文本文件中,每个样本数据占据一行，总共有1000行。
这些样本数据主要有以下3个特征:
（1)每年获得的飞行常客里程数
(2)玩视频游戏所消耗的时间百分比
(3)每周消费的冰淇淋公升数
3.3算法及代码:
import numpy as np
def filetomatrix(filename):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e2ed095ac8c8f382dce8019f5a490b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c6d28f2f1930cad27c0e2fc402d11e2/" rel="bookmark">
			TextView跑马灯效果不生效的原因分析及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天同事遇到一个缺陷，跑马灯不生效，迟迟无法解决，于是帮忙看了下，最终顺利解决了，做个记录。
首先原来的代码是这样的：
JAVA代码实现（Kotlin）： holder.itemView.tv_title.text = title XML中实现： &lt;TextView android:id="@+id/tv_title" android:layout_width="@dimen/dip96" android:layout_height="@dimen/dip17" android:ellipsize="marquee" android:focusableInTouchMode="true" android:fontFamily="sans-serif-medium" android:gravity="center" android:marqueeRepeatLimit="marquee_forever" android:scrollHorizontally="true" android:singleLine="true" android:textColor="@color/color_333333" android:textSize="@dimen/dip12" tools:text="系统版本信息" /&gt; 都很正常。搜索晚上大多数的解决方案，无法是添加singleLine等字段，这里面其实都已经设置了。百度的所有方案都试过了，都是无效的，靠人不如靠己，就只能自己尝试调试源码解决了。幸好手里面有一部神机pixel4，和源码完全对得上，可以直接调试。
原因分析：
我这里就不一步一步的分析原因了，直接定位到原因点，是否展示跑马灯效果，是textView中这段代码控制的：
@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023) private void startMarquee() { // Do not ellipsize EditText if (getKeyListener() != null) return; if (compressText(getWidth() - getCompoundPaddingLeft() - getCompoundPaddingRight())) { return; } if ((mMarquee == null || mMarquee.isStopped()) &amp;&amp; (isFocused() || isSelected()) &amp;&amp; getLineCount() == 1 &amp;&amp; canMarquee()) { if (mMarqueeFadeMode == MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) { mMarqueeFadeMode = MARQUEE_FADE_SWITCH_SHOW_FADE; final Layout tmp = mLayout; mLayout = mSavedMarqueeModeLayout; mSavedMarqueeModeLayout = tmp; setHorizontalFadingEdgeEnabled(true); requestLayout(); invalidate(); } if (mMarquee == null) mMarquee = new Marquee(this); mMarquee.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c6d28f2f1930cad27c0e2fc402d11e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcd322d2bd8d76219c11f2b0ccf740be/" rel="bookmark">
			golang net/http包在k8s使用中碰到http: superfluous response.WriteHeader call from xxx的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在项目中，需要使用golang写http服务器并部署在k8s中，在server deployment.yaml中存在livenessProbe(存活探针)以及readinessProbe(就绪探针)，这两个我都是写了向服务器发送一个http请求，如果服务器收到并回复，则表示成功，但是在使用过程中，日志一直输出，这些会干扰日志的查看。
经过查询与测试，最后修复，做此纪录，代码如下。
func healthcheck(w http.ResponseWriter, r *http.Request) { //fmt.Fprintf(w, "i m live") 原来就是因为多了这行,然后一直输出,屏蔽了即可 w.WriteHeader(200) } func main() { router := http.NewServeMux() router.HandleFunc("/healthcheck", healthcheck) port := fmt.Sprint(":", *config.Conf.HttpPort) srv := &amp;http.Server{ Addr: port, Handler: router, } logger.Info("[HTTP] http server listen", port) if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed { logger.Error("[HTTP] server listen on", port, ", err:", err) os.Exit(1) } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb923596849106dd81bac943229ef2b3/" rel="bookmark">
			2 计算机网络性能指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 速率带宽吞吐量时延时延带宽积往返时间网络利用率 速率 连接在计算机网络上的主机在数字信道上传送数据位数的速率，也称为data rate或bit rate。
单位是b/s, kb/s, Mb/s, Gb/s.
比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。
Bit来源于 binary digit，意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个 1 或 0。
速率即数据率(data rate)或比特率(bit rate)是计算机网络中最重要的一个性能指标。速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等
比特率：计算机通过网卡传送二进制数据，二进制1位为1 bit，每秒传送的比特位数
实际上计算机看流量是按照字节来算，要除以8
带宽 数据通信领域中，数字信道所能传送的最高数据率
单位是b/s，kb/s，Mb/s，Gb/s.
查看计算机网卡带宽
数字信号流随时间的变化：在时间轴上信号的宽度随带宽的增大而变窄。
吞吐量 在单位时间内通过某个网络的数据量；单位b/s，Mb/s，等吞吐量(throughput)表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。 时延 传输时延（发送时延 ） 发送数据时，数据块从结点进入到传输媒体所需要的时间。
也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。
传播时延 电磁波在信道中需要传播一定的距离而花费的时间。
信号传输速率（即发送速率）和信号在信道上的传播速率是完全不同的概念。
处理时延 交换结点为存储转发而进行一些必要的处理所花费的时间。
排队时延 结点缓存队列中分组排队所经历的时延。
排队时延的长短往往取决于网络中当时的通信量。
数据经历的总时延就是发送时延、传播时延、处理时延和排队时延之和：
总时延 = 发送时延+传播时延+处理时延+处理时延
四种时延所产生的地方: 从结点 A 向结点 B 发送数据
注意：对于高速网络链路，我们提高的仅仅是数据的发送速率而不是比特在链路上的传播速率。
提高链路带宽减小了数据的发送时延。
时延带宽积 链路的时延带宽积又称为以比特为单位的链路长度。
实际上表示：计算机在通信时，有多少数据在线路上
往返时间 可以使用ping测试
ping百度测试往返时间
网络利用率 信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。网络利用率则是全网络的信道利用率的加权平均值。信道利用率并非越高越好。
网络使用率越低，说明还有可增长的空间和可用的流量，若达到100%，再有新流量则无法传出 时延与网络利用率的关系
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb923596849106dd81bac943229ef2b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87441b541e7d3a5b6037bfc6bbe30296/" rel="bookmark">
			聊聊Benchmark测试【转载】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据wiki百科解释: beanchmark问题就是基准测试问题.
1996 International Workshop on Structural Control 会议上提议组建欧洲、亚洲、和美国3个有关SHM的研究小组,并由 Chen倡导建立Benchmark结构,以便进行各种技术的直接比较.
许多业内比较出名的工具都提供benchmark 功能
1. Apache Beachmark 简称(ab)
他是apache 组织下的一款web压力测试工具, 因使用方便简单而著称.
ab一般常用参数是 –n -t 和 -c
-c（concurrency）表示用多少并发来进行测试(模拟并发数);
-t表示并发测试持续时间;
-n表示要发送多少次请求;
注意: 大小写敏感
ab [get] 请求
$ ab -n 10 -c 3 https://www.baidu.com/
发送10个请求, 模拟3个并发数
Concurrency Level: 3 #当前并发数
Time taken for tests: 0.624 seconds #测试消耗时间
Complete requests: 10 # 完成请求数量
Failed requests: 0 #失败的请求数
Total transferred: 8930 bytes # 共传输数据量
Requests per second: 20.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87441b541e7d3a5b6037bfc6bbe30296/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2013441deb2780e1adf684ed85d2b325/" rel="bookmark">
			微信内置浏览器私有接口WeixinJSBridge的常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关闭当前页面，回到对话窗口 onBackCloseWindow() function onBackCloseWindow() { //当点击返回键时，不返回到上一页，而是直接关闭微信浏览器 pushHistory() window.addEventListener("popstate", function (e) { //关闭当前浏览器 WeixinJSBridge.call("closeWindow"); //如果是使用了iframe的页面 parent.WeixinJSBridge.call('closeWindow'); }, false); function pushHistory() { var state = { title: "title", url: "#" }; window.history.pushState(state, "title", "#"); } } 屏蔽右上角三个点的分享功能 function onBridgeReady() { //隐藏右上角按钮 WeixinJSBridge.call('hideOptionMenu'); } if (typeof WeixinJSBridge == "undefined") { //屏蔽分享按钮 if (document.addEventListener) { document.addEventListener('WeixinJSBridgeReady', onBridgeReady, false); } else if (document.attachEvent) { document.attachEvent('WeixinJSBridgeReady', onBridgeReady); document.attachEvent('onWeixinJSBridgeReady', onBridgeReady); } } else { onBridgeReady(); } 微信内置浏览器私有接口WeixinJSBridge的几个常用的方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2013441deb2780e1adf684ed85d2b325/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7693a47445e260f79cff12989c08205/" rel="bookmark">
			tensorflow对应cuda和cudnn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tensorflow对应cuda和cudnn link
linux安装tensorflow-gpu link1
link2
link3
link2亲测ok
查看Linux上已安装的CUDA和cuDNN版本号 link
测试跑的是gpu还是cpu link
当gpu没咋动静 link
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acdc2d19f27d4a15a81e02e8eb9e7d06/" rel="bookmark">
			ImportError: /lib64/libm.so.6: version `GLIBC_2.23‘ not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ImportError: /lib64/libm.so.6: version `GLIBC_2.23' not found 背景解决方案备注 背景 早上起来在服务器上跑一个python代码，报错了。
发现是在import tensorflow是报错的。因为服务器是几个人在用，可能是谁更新了什么东西。
解决方案 现在环境下的python是3.7版本，有查到说可以通过降低到3.6版本来解决，于是新建了个环境，将python设为3.6，tensorflow的版本和之前一样，1.14.0
conda create -n 环境名 python=3.6 tensorflow=1.14.0 conda activate 环境名 #激活环境 在该环境下执行就成功了。（虽然有tensorflow一些版本更新的警告）
备注 本来最早的报错是 /usr/lib64/libstdc++.so.6: version `CXXABI_1.3.8’ not found 这个问题
贴一些网上的解决方法
link1
link2
我是按照link2里面把anaconda的库文件路径添加到系统的库文件路径中，一顿操作后，报错变成了最上面的，后来解决了新问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5d8bb1646e97674af6bab51d25abadd/" rel="bookmark">
			如何实现微信小程序动画？添加到我的小程序动画实现详细讲解，附壁纸小程序源码下载链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了让用户能尽可能多地使用小程序，也算是沉淀用户，现在很多小程序中，都有引导用户“添加到我的小程序”的操作提示，而且大多都是有动画效果。在高清壁纸推荐小程序首页，用户每次进入，都会在页面右上方，显示“添加小程序”的动画提示，如下图所示：
高清壁纸推荐小程序 怎么实现这样的关注提示功能呢？首先，进入pages/index/index.wxml文件中，编写布局代码如下：
&lt;!-- “添加小程序”的动画提示 --&gt; &lt;view hidden='{{isWebChatTipsHidden}}' class='wx_tip'&gt; &lt;image src="/images/tip_ios.svg"&gt;&lt;/image&gt; &lt;/view&gt; 布局代码很简单，主要是通过样式实现图片“心跳”的动画效果，接下来，进入pages/index/index.wxss文件中，编写样式代码如下：
/* “添加小程序”的动画提示容器样式 */ .wx_tip { position: fixed;/* 固定、停靠定位 */ z-index: 120;/* 垂直方向层级，数字越大越靠前 */ top: 4rpx;/* 距离顶部位置 */ right: -40px;/* 距离右侧位置 */ height: 120rpx; } /* “添加小程序”的动画提示图片样式 */ .wx_tip image { height: 100%; animation: heart 1.3s ease-in-out 2.7s infinite alternate; /* 动画名称 动画完成一个周期所花费的秒或毫秒 动画的速度曲线 动画何时开始（延迟开始时间） 动画被播放的次数 动画是否在下一周期逆向地播放 */ } /* 定义“心跳”动画 */ @keyframes heart { /* 开始位置 */ from { transform: translate(0, 0); } /* 结束位置 */ to { transform: translate(0, 6px); } } 在上面代码中，关键点在于：动画（animation）样式的使用。虽然说微信小程序可以直接通过逻辑代码，实现一样的动画效果，但出于便捷和灵活性考虑，一般建议还是通过样式代码来实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5d8bb1646e97674af6bab51d25abadd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bd9f2589fd4395340042879042fb39f/" rel="bookmark">
			mysql survey_Mysql 查询语句怎么写？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发市场调查业务，有一个调查问题表responses (一百万行), 是市场调查的原始数据，包含survey_id(调查表的类型列)，response_no(被调查者列)，interview_date(调查日期)， question_label(问题列), value(回答列), section_unique_id(部门列)等。
每一行对应某个被调查者回答的一个问题和它的调查结果。一个被调查者一次会回答30个问题，所以会产生30行。
另有一个计算公式表 (40行), 是对调查结果的分析计算公式，这些公式都是sql语句。
根据计算公式，产生一个结果表results。
现在的问题是,要设计一些sql语句，调查有多少人的回答是类似如下这样的组合：
1. 回答问题Q1,答案是1或8或9
并且
2. 回答问题Q2,答案是1或8或9
并且
。。。。。。
最好能用group by section。
比如如下这个例子：
计算公式的说明是这样。
((Q2A = 1 OR Q2A = 8 OR Q2A = 9) AND (Q2B = 1 OR Q2B = 8 OR Q2B = 9) AND (Q2C = 1 OR Q2C = 8 OR Q2C = 9) AND (Q2D = 1 OR Q2D = 8 OR Q2D = 9) AND (Q2E = 1 OR Q2E = 8 OR Q2E = 9) AND (Q2F = 1 OR Q2F = 8 OR Q2F = 9) AND (Q2G = 1 OR Q2G = 8 OR Q2G = 9) AND (Q2H = 1 OR Q2H = 8 OR Q2H = 9) AND (Q2I = 1 OR Q2I = 8 OR Q2I = 9) AND (Q5 = 1 OR Q5 = 8 OR Q5 = 9) AND (Q6 = 1 OR Q6 = 8 OR Q6 = 9))
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bd9f2589fd4395340042879042fb39f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da402f0e8a7525c377e2510698f2be27/" rel="bookmark">
			Django10.知识点总结与小案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Django——小案例 文章目录 Django——小案例一、初始化二、创建模板1. 完成base页面2. 测试3. 完成学生信息页面4. 完成学生详情页 三、实现数据操作1. 实现查询操作2. 实现增加操作3. 实现删除操作4. 年级部分优化5.实现编辑操作 一、初始化 为了方便我们实验，我们创建一个新的app(Students)
步骤：
进入虚拟环境进入apps执行：python ../manage.py startapp Students将文件下载到本地配置urls和settings将原来Student的app中的models.py复制到Students下执行迁移在templates目录下创建Students文件夹用于存放html页面在static目录下创建Students文件夹用于存放静态文件 二、创建模板 1. 完成base页面 基础的页面可以去bootstrap官网查找，然后将一些需要添加url的地方填写完整,然后将不用的删除即可。
base.html
{% load static %} &lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content=""&gt; &lt;title&gt;{% block title %}学生管理系统{% endblock %}&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- IE10 viewport hack for Surface/desktop Windows 8 bug --&gt; &lt;link href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da402f0e8a7525c377e2510698f2be27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a08ef82937e661ffd373457aa1513cf/" rel="bookmark">
			mmdetection 训练 Faster R-CNN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		训练步骤 安装 labelme
conda create --name=labelme python=3.6 conda activate labelme pip install pyqt5 pip install labelme 安装 scikit-image，scipy
pip install scikit-image -i https://pypi.tuna.tsinghua.edu.cn/simple pip install scipy -i https://pypi.tuna.tsinghua.edu.cn/simple 运行 ..\data\coco\train2014\ 中 labelme2coco.py，生成 instances_train2014.json，并复制到..\data\coco\annotations\中
运行 ..\data\coco\val2014\ 中 labelme2coco.py，生成 instances_val2014.json，并复制到..\data\coco\annotations\中
修改change.py 并运行:
pretrained_weights = torch.load('F:\\BaiduNetdiskDownload\\mmdetection\\mmdetection-1.1.0\\checkpoints\\faster_rcnn_r50_fpn_1x_20181010-3d1b3351.pth') num_class = 类别 + 1 torch.save(pretrained_weights, "F:\\BaiduNetdiskDownload\\mmdetection\\mmdetection-1.1.0\\faster_rcnn_r50_fpn_1x_%d.pth"%num_class) 可以看到文件夹里多出一个文件: faster_rcnn_r50_fpn_1x_2.pth
mmdetection-1.1.0\mmdet\utils\collect_env.py 注释42-44行
#gcc = subprocess.check_output('gcc --version | head -n1', shell=True) #gcc = gcc.decode('utf-8').strip() #env_info['GCC'] = gcc 修改mmdetection-1.1.0\configs\My_faster_rcnn_r50_fpn_1x.py:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a08ef82937e661ffd373457aa1513cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcb324f6b7a291f7e04644529f80c0ba/" rel="bookmark">
			1 计算机网络体系结构与OSI参考模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 计算机网络概述1.1 计算机网络概念1.2 计算机网络的分类 2 OSI 七层参考模型应用层表示层会话层传输层网络层数据链路层物理层 3 OSI参考模型与网络排错4 OSI参考模型与网络安全5 TCP/IP协议和OSI参考模型 1 计算机网络概述 1.1 计算机网络概念 计算机网络概念：利用通信设备和线路将地理位置不同的，功能独立的多个计算机系统互连起来，以功能完善的网络软件（网络通信协议 信息交换方式 网络操作系统）实现网络中资源共享和信息传递的系统。 一些其他名词解释：
实体: 不论什么可以发送和接收信息的软硬件进程；对等层： 两个不同系统的同一层次。对等实体： 分别位于不同系统对等层的两个实体；接口： 上层使用下层所提供的功能的方式。服务： 某一层及其下面各层的所完毕的功能，通过接口提供给相邻的上层；协议： 通信两方在通信过程中必须遵循的规则。 数据处理和资源共享是两大基本功能。
逻辑功能分为资源子网和通信子网：
资源子网：负责数据处理的主计算机与终端通信子网：负责数据通信处理的通信控制处理机与通信线路 1.2 计算机网络的分类 网络分布范围分类： 广域网 城域网 局域网 个人区域网
使用者分类： 公用网 专用网
交换方式分类： 电路交换 报文交换 分组交换
拓扑结构分类： 星型
总线型
环型
树型
网型
网络按照其所覆盖的地区范围分为以下四类： 局域网：当一个单位需要将位于某个范围有限，行政可控的区域内的大量联网设备通过一种高速的方式相互连接起来，就需要通过组建一个局域网让这些设备实现相互通信（范围有限可以是一所高校，一个餐厅，一个家庭等） 城域网：是根据网络的规模划分出来的，而跨越几千米到几十千米的网络既有可能属于某一家机构，也有可能需要通过公共网络服务提供商来提供接入，因此在管理运营层面，城域网既有可能是一个私有网络，也有可能是一个公共网络 广域网：又称外网或者公网，用于连接不同地区的局域网或城域网 Intnet：不是一个单一的网络，也没有特定的技术范畴，它是大量异构网络的集合。这个庞大的网络不隶属于任何机构或者个人。任何组织和个人都可以使用各种不同的方式，通过各类不同的基础设施连接到这个网络中，通过这个网络，接受同样连接到这个网络中的其他组织个人所提供的各类网络服务，或者为其他组织个人提供不同的网络服务。 2 OSI 七层参考模型 应用层 能够产生网络流量并且能够和用户交互的应用程序，比如QQ和微信
像一些系统软件，比如记事本，计算器，就不是应用层软件，无需联网即可正常使用
表示层 在传输之前是否进行加密或压缩处理
二进制 ASCIl 加密 压缩 编码 (开发人员需要考虑的问题)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcb324f6b7a291f7e04644529f80c0ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a94b66e0bb9b8860dedb0a59f9e1a14/" rel="bookmark">
			cuda10.1和cudnn7.6.5百度网盘下载链接（Linux版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cuda10.1和cudnn7.6.5百度网盘下载链接（Linux版） 在官网下载不仅慢，，，主要是还总失败。。终于下载成功了，这里给出百度网盘下载链接，希望可以帮到别人
百度网盘下载链接
提取码: vyg5
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21e93e8b4b2b8db8bbf44566e8ffb1a5/" rel="bookmark">
			i5 1135g7什么水平_i5-1135G7和R5-4600H/R7-4800H哪个好？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读：碰到这个问题的，实际上也就那么几款笔记本，例如yoga14s 2021款的锐龙版和intel版本；
还有例如magicbook pro的 R7-4800H标压版和新款的小新对比等（这个概率比较低，毕竟价位不同）
后续也许还有新的机型出来，yoga27就是这样的电脑；
但基本上可以大制总结下： i5-1135G7的核显，如果内存LPDDR-4266MHZ且散热还不错，那么核显比4600H的强了接近一倍；R5-4600H是六核十二线程，intel单核可以超过R5，但架不住锐龙人多，特别是剪辑视频、拷资料等多核满负荷运行的软件；能效管理方面，intel无疑层次多、范围宽，所以EVO节能模式可以增加待机时间；十一代intel加了AI降噪（低价款或许没有），电话会开会神奇，提高品质； 举例说明： 就拿功率设定比较高的yoga14s 2021款来说说吧~
PS：不同笔记本的身体素质是不一样的，也别是这种轻薄本，TDP设定的差异很大，例如18W的蜂鸟fun、25W的thinkbook、38W的yoga15s等，这个例子只能泛泛而谈，可以代表较高水平下的表现，如碰到体质弱的，需要打折扣；
配置差异就不聊了，主要聊聊游戏表现和烤机情况：
i5-1135G7版本：AIDA64单烤20分钟，37W，温度80度以内，3.9GHZ左右；+furmark一起双烤，GPU很稳，1.3GHZ，CPU也可以25W+2.6GHZ；
但价格同等级别的只有R7-4800H版本，这个烤机的表现是42W+3.3GHZ，秒杀i5；
就算换成R5-4600H，几乎可以肯定，只要TDP给足，CPU性能方面，综合实力20%的上升幅度还是有的；
总结：锐龙系列多核性能无疑仍然发挥着优势~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/014bb5856321d605fd89328cd083a588/" rel="bookmark">
			【群晖NAS】真·免费内网穿透方案 及踩坑合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.介绍 一篇科普贴，帮助那些刚入门NAS的朋友尽量避免踩坑。因为本人实践了其中几种穿透方案，也积攒了一些经验，跟大家分享一下。
在这里想说一句，现在网上充斥着各种《内网穿透方案对比》，可以负责任地说一下，基本上都是花钱雇写手写的！你们可以自己判断一下。
所以大家请放心，我在这里不会给你们推荐任何一款付费方案，我也会列举出免费和付费方案的优劣，只针对个人方案！当然，财大气粗地当我没说QAQ
为什么需要内网穿透 如果你的NAS的网络如果是内网的话，那么这台机器只能在内网中被访问。简单的理解就是，如果你在家搭建了一台NAS，但是你家没有公网IP（现在的宽带基本上都是没有公网IP的了，查询方法可自己百度） ，那么你在学校或公司这种外面的环境里想访问NAS的文件的话是不可行的，除非通过内网穿透把你的机器从家里的内网中“穿透”出来，这样在外部环境就可以随时随地地访问了。
此外，如果你是正版群晖的话，是可以通过Quick Connect进行内网穿透的，黑群晖的话全洗白也是可以使用Quick Connect的，但是这个工具的速度已经大不如从前了。
二.方案对比 花生壳 话不多说，直接上套餐价格：
我给不太懂的朋友们翻译一下，如果你用免费版的话，一个月只有1G的流量，而且只有1Mbps的带宽（下载速度最高只有128kb/s）。
如果你愿意花368元买专业版的话，流量不限，但带宽还是只有1Mbps，值得一提的是，现在中国的家庭宽带基本上已经全部迈入100Mbps的门槛。
嫌慢？可以提速呀，加带宽！
什么？最高只能加到6M？而且....就这都要1500一年？
零遁NAS伴侣 这一款是个硬件，我买回来试了一下，使用方法就是连在家里的路由器上，在官网上注册SN码，手机或者电脑这些客户端通过VPN来访问内网的设备。
先上几张网上的图，300多块，满满的塑料感，我的后来退货了....忘记拍照了QAQ：
这个NAS伴侣工作原理和花生壳是不一样的，简单来说就是：
花生壳是客户端先连接到花生壳那边的服务器，然后通过服务器转发到NAS，相当于中间隔着一个中介。
零遁是手机通过VPN找到这个小盒子，小盒子“转发”到局域网中的NAS，基本相当于是客户端与NAS直连。
也就是这个玩意！在网上有好多营销帖子！！宣传说是买来之后终身免费，穿透速度可以跑满上行（家里有多少带宽就能跑多少）。
我当时看着就觉得太诱人了，狠下心买了，买来后大失所望，我给大家总结一下吧：
客户端支持太差，IOS是不支持的，需要自行到网上找美区的Apple ID，下载Open VPN，然后找商家给你单独配置文件（不是统一的，所以商家得一个一个配），安卓和IOS客户端经常连接一段时间后自动掉线（Windows没试过）。而且！！每次想连NAS都要开VPN真的有点麻烦！！理论上可以跑满上行，现实中基本上是不可能的。因为不同运营商之间穿透百分百会影响速度！！我弄完之后之后，因为家里是联通的，外面只能用到移动和电信，所以下载速度只有几十KB每秒，我和商家反馈后，商家给我解决方案都用了（路由器DMZ主机什么的），没用，后来我又想了下，就算可以解决运营商的问题，300多买了个这么个玩意，真的不值....最后一点，这个产品其实就是开源项目zerotire的包装版，虽然我没实践过，可是我可以负责任地告诉你，你完全可以不通过硬件就实现内网穿透，肯定有人说软件哪里比得上硬件稳定，可看着我手中几十K的下载速度，我沉默了.... Sukura FRP 进入正题了！
放网址：https://www.natfrp.com/
这是一个纯公益性质的内网穿透，最初的目的是给那些MC玩家免费开服用的。终身免费。
每个用户一个月有20G的流量，每天签到可以领流量（1到4个G随机发放），所以如果坚持签到，一个月下来的流量还是很可观的。
Sakura FRP是通过端口映射的，一个端口对应一个隧道，普通用户上限5个隧道（花10块钱可以再加5个隧道），每个隧道的带宽上限是8Mbps（下载速度1Mb/s）。
这里可以对比一下上方那两个，真的很良心了。
至于安装教程，网站上的帮助文档还是挺详细的，不懂的也可以私信问我哈，有点基础的朋友安装起来肯定是不费劲的。
这也是我最后选择的方案，说一下感受，刚开始我用的普通用户，讲道理真的够用了，8Mbps一点都不是虚的，看个几个G的电影完全是可以的。
但是因为我平时玩PT，NAS里面的电影动辄就10几个G，所以就办了VIP，20元一个月，带宽36Mbps（4.5Mb/s），这里就不多说了，有带货嫌疑....
这是我开VIP后的速度，稳定3M以上：
这里再推荐下上图用到的nPlayer，超强大的播放器，跟NAS真的绝配，感兴趣的可以私信我怎么配置。
浮居内网穿透 这个网站和Sakura很像，免费版的话一个月5G流量，带宽5M，是有点少的。
但是如果有些朋友不想要被限速，限制流量，这个网站的充值服务还是比较划算的。
因为Sakura的会员一个月20，并且限速36Mbps，限制流量。
而浮居只要10元一个月，不限流量，不限速（速度取决于服务器带宽）。
IPV6 最后这个其实不算是内网穿透，但是殊途同归，而且很多朋友可能根本不知道还有这条途径！
现在国家大力普及ipv6，基本上家庭宽带都是有ipv6的，具体检测方法网上有。
如果没有可以打电话直接找客服，别多BB，直接说开通IPV6，因为有的运行商是不想给你开通的，所以要坚定一点！
这里参考的教程是：https://post.smzdm.com/p/ax027ww9/
注意！这里要求的是公网ipv6，如果你的地址是fe80开头的其实是内网ipv6，也是不行的。
教程里面最后要写脚本动态解析IP地址，但是我用到现在，ipv6地址都还没变过，所以大家自己发挥吧哈哈哈。
而且阿里云的域名审核比之前快多了！我申请的不到一小时就通过了。
此外，配置完后，也是需要有ipv6网络的客户端才能访问到NAS，可以进这个网址测试一下 http://www.test-ipv6.com/
所以条件还是比较苛刻的，但是一旦打通，啥内网穿透的都不需要了！！
流量限制？？？没听说过！
不说了，上个图大家感受一下：
云服务FRP 如果你拥有一台云服务器的话，可以使用frp技术（上面的sakura frp就是使用了相同的技术）自己搭建内网穿透的环境。
具体操作参见我的另一篇博文：NAS群晖 利用云服务器 FRP技术 实现内网穿透
最后，我想说的是其实内网穿透的方案远不止这些，我只是挑了些上手难度较低的，大众普遍选择的给大家对比一下。
动手能力强的朋友可尝试一下别的方案！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/014bb5856321d605fd89328cd083a588/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37931bc48a54b23e76cfdcde8743da69/" rel="bookmark">
			百度秒链地址使用方法介绍（PC端）- 日草君
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于谷歌浏览器安装插件要梯子，手动安装麻烦
火狐浏览器下载地址：http://www.firefox.com.cn/
360极速浏览器下载地址：https://browser.360.cn/ee/
（大家还是下载360极速浏览器吧，其他浏览器已经安装Tampermonkey，看第二步即可）
❖第一步安装方法（以360极速浏览器为例）❖
安装浏览器插件：Tampermonkey（猴油）
360极速浏览器打开地址安装即可（实在太方便了）：点击这里即可
（安装一个360极速浏览器国内还是可以的浏览器）
安装完成后右上角会出现猴油插件的图标
❖❖第二步：安装Tampermonkey里面的百度秒链插件❖❖
打开地址安装即可：百度秒链地址点击这里
（任何电脑浏览器如果安装了第一步的Tampermonkey（猴油），直接安装这个即可）
然后就完成了，使用360极速浏览器安装就两步，超级简单！！！
❖❖❖第三步百度秒链使用方法：❖❖❖
如果使用360极速浏览器打开百度网盘网页版登录：https://pan.baidu.com/disk/home
在【全部文件】选项上方会多出一个【秒传链接】点击即可
1、复制粘贴百度秒链地址，点击确认即可
（会提示保存位置，就是在百度网盘了创建一个文件夹保存文件，可以随便输入
可以像我一样输入秒链，方便查看）
2、最后等待2秒左右就，提示转存完毕了（神奇到连提取码都不需要！！！）
打开刚才创建的【秒链】文件夹就可以看到保存的文件了，最后下载就完成了
➱➱➱
PS：秒链保存是在百度网盘网页版使用的（不是客户端），保存后再用客户端下载文件即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/addeebd319d8b76ba0db34ce061d4a01/" rel="bookmark">
			create table1 select * from table2 与 insert into table1 select * from table2的区别与用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		create table1 select * from table2 与 insert into table1 select * from table2的区别与用法 1、区别： select * into table1 from table2 要求目标表存在；
create table1 select * from table2 要求目标表不存在，因为在插入时会自动创建。
2、作用： select * into table1 from table2 一般用于还原表数据
create table1 select * from table2 一般用于备份表数据
1. 复制表结构及其数据：
create table table1 select * from table2 2. 只复制表结构：
create table table1 select * from table2 where 1=2; 或者：
create table table1 like table2 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/addeebd319d8b76ba0db34ce061d4a01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28543d696b0a8a112f8a5779e1dbc4be/" rel="bookmark">
			为什么mysql使用 select * into from  报[Err] 1327 - Undeclared variable: user_info
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么mysql使用 select * into from 报[Err] 1327 - Undeclared variable: user_info 今天在使用mysql 语句批量从一个表复制到另外一个表的时候 ，发现了一个问题，我在使用
seletc * into user_info from customer_info 的时候发现报错，总结了一下，原因很简单，根据报提示，是mysql不支持 这个语法，以前我用sqlsever的时候习惯用select into 去复制了，这样很方便，比如:
select * into table1 from table2 不需要创建table1的表结构，所以我今天想当然的以为mysql也支持这个语法。
最后我经过查找资料，发现mysql也是支持这种复制的，只不过语法打不太一样，用的是
create table1 select * from table2 这样问提就解决了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf2bbfd65bc30810d06d25cc45b260f8/" rel="bookmark">
			下面关于在dos停止mysql_下面关于在DOS停止MySql的命令中,正确的是 (5.0分)_学小易找答案...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【单选题】下面语句中,可以创建数据库和创建表的是 (5.0分)
【简答题】253页10.1第一大题
【单选题】下面关于在DOS停止MySql的命令中,正确的是 (5.0分)
【单选题】下面关于SQL全称的说法中,正确的是 (5.0分)
【简答题】上传今天的图片
【单选题】上消化道出血病人,出血量超过1000ml以上时出现,下列哪项是错误的:
【其它】文献翻译: 请同学们就自己感兴趣的运动治疗学相关内容,查阅英文文献,并选择一篇文献翻译成中文,如查阅文献困难,可与我联系,我的邮箱:9828369@qq.com,或者微信联系均可。 一、文献翻译的要求及评分标准见附件。 运动治疗学英文翻译评分标准.pdf 《运动治疗学》文献翻译格式要求.pdf 二、严格按照 《运动治疗学》文献翻译格式要求.pdf 中的模板,编辑译文。 三、同时提交译文与英文文献的PDF原文,译文与原文的文件名均以中文标题命名,均以附件的形式提交。 四、截止日期:2020年1月4日。
【简答题】标本片图片,标注导管,射线,裂隙,油室
【单选题】咯血的特点不正确的是
【单选题】下面关于数据查询的描述正确的是( ) (5.0分)
【单选题】下面选项中,用于表示固定长度字符串的数据类型是 (5.0分)
【单选题】下列选项中,哪个是配置MySql服务器默认使用的用户 (5.0分)
【简答题】作文:介绍一个城市或者你的家乡,不少于250字,上传你的作业。
【单选题】查询数据时可用( )代替数据表中的所有字段名。 (5.0分)
【口语题】朗读第七课第一部分 第二部分
【单选题】关于SELECT * FROM tb_book LIMIT 5,10描述正确的是( )。 (5.0分)
【单选题】下面选项中,适合存储高清电影的数据类型是 (5.0分)
【单选题】以下比较结果为真的是( )。 (5.0分)
【单选题】MySQL提供的( )语句可查看数据表的创建语句。 (5.0分)
【单选题】下面用于存储二进制数据的是( ) (5.0分)
【单选题】下面选项中,属于定点数的类型是 (5.0分)
【单选题】下面关于“price BETWEEN 0 AND 59”描述错误的是( )。 (5.0分)
【单选题】下面数据库中,只能在Windows平台上运行的是 (5.0分)
【单选题】下面关于DECIMAL(5, 3)的说法中,正确的是( ) (5.0分)
【简答题】“SELECT JSON_OBJECTAGG(6,'orange')”的执行结果为【】。 (2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf2bbfd65bc30810d06d25cc45b260f8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/331/">«</a>
	<span class="pagination__item pagination__item--current">332/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/333/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>