<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20a34414a7363182c01acbe78ac2585b/" rel="bookmark">
			word中MathType公式编号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上效果图：
步骤如下：
安装MathTypeword中安装MathType选项卡。设置MathType选项卡添加分隔符插入公式，自动生成右编码 接下来介绍每一步。
文章目录 1. 安装MathType2. Word中安装MathType选项卡3. 配置MathType选项4. 添加分隔符5. 插入公式6. 更新目录 1. 安装MathType 参考上篇文章毕业论文公式-截图+复制粘贴
2. Word中安装MathType选项卡 因为是科学安装的mathtype，所以没有下面的选项很正常。自己手动安装就行了。
打开文件-&gt;选项
按照下面步骤打开
选择添加
选择C:\Program Files (x86)\MathType\Office Support\64文件下的2016。这个是默认的安装路径，如果自定义的去自定义的文件夹下找。
添加完成后，选中，点击确定
这个时候应该会有选项卡了，但是如果报错，请参考文章
MathType 运行时错误‘53’：文件未找到：MathPage.WLL_文件未找到mathpage.wll-CSDN博客
3. 配置MathType选项 打开
一般是使用-作为分隔符，并且没有节编号
配置分隔符的样式
建议写论文的时候，把分隔符的隐藏去掉，写完之后在隐藏。
4. 添加分隔符 在每一章节的前面加上分章符号。
5. 插入公式 插入公式，写完后，保存。然后公式就会自动编号。
如果删除没有更新公式，可以使用下面操作来更新公式。
6. 更新目录 更新目录的时候，分章符号会在目录上重复，导致编码翻倍。所以需要手动删除。
选中分隔符，选择修改分隔符。然后删除就行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b3447a62cee1b255731cf340447743/" rel="bookmark">
			Qt QAction添加图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QAction用的时候，时常需要添加图片，如上图所示，代码如下所示：
测试的图片格式包含png,jpg,bmp,svg，其他未测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3538225438ca43573c41fbe96e685bbb/" rel="bookmark">
			C&#43;&#43;提高编程一(函数模板、类模板)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 模板函数模板注意事项函数模板案例普通函数与函数模板的区别普通函数与函数模板的调用规则模板的局限性类模板类模板与函数模板区别类模板中成员函数创建时机类模板对象做函数参数类模板与继承类模板成员函数类外实现类模板与友元 基于b站黑马c++视频做的笔记，仅供参考和复习！！！ 模板 语法：
template&lt;typename T&gt; 函数声明或定义 template — 声明创建模板
typename — 表面其后面的符号是一种数据类型，可以用class代替
T — 通用的数据类型，名称可以替换，通常为大写字母
//函数模板 //交换两个整型函数 void swapInt(int&amp; a, int&amp; b) { int temp = a; a = b; b = temp; } void swapDouble(double&amp; a, double&amp; b) { double temp = a; a = b; b = temp; } //函数模板 使得类型参数化，通用化 template&lt;typename T&gt; //声明一个模板，告诉编译器后面代码中紧跟着的T不要报错 T是一个通用类型 void mySwap(T &amp;a, T &amp;b) { T temp = a; a = b; b = temp; } void test01() { int a = 10; int b = 20; //swapInt(a, b); //利用函数模板交换 两种方式使用模板 //1、自动类型推导 mySwap(a, b); //2、显示指定类型 mySwap&lt;int&gt;(a, b); cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3538225438ca43573c41fbe96e685bbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2766a1ab61736548ed82301ad96ed2f/" rel="bookmark">
			大数据- Hadoop入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🐶2.1 hadoop的简介
1. 概述
2. 什么是分布式？
3. Hadoop的指代
🐶2.2 hadoop的发展历程
🐶2.3 hadoop的版本介绍
🐶2.4 hadoop的常用端口号
🐶2.5 hadoop的设计目的
🐶2.6 hadoop的优势
1. 高可靠性
2. 高扩展性
3. 高效性
4. 高容错性
5. 低成本
🐶2.1 hadoop的简介 1. 概述 Hadoop是一个对大量数据进行分布式处理的软件框架
前文我们提到大数据主要解决海量数据的采集、存储和分析计算问题。其中Hadoop框架主要解决海量数据的存储和分析计算问题
HDFS(hadoop distribute file system) - 分布式文件系统，解决海量数据的存储问题
MR(MapReduce) - 分离聚合式运算系统，分布式运算系统，解决海量数据的分析计算问题
YARN - 分布式资源调度系统
2. 什么是分布式？ 分布式指的是在多态计算机上协同工作以完成某个任务的过程
假设你有一本非常厚的书需要复印。如果你只有一台复印机，复制整本书将需要很长时间。现在，想象一下有十台复印机，每台都可以复制书中的一部分。你可以让每台复印机同时工作，每台复印机复制其中的一小部分，然后将它们组合在一起。这样，整个过程会比只用一台复印机快得多。
在这个比喻中，每台复印机就好比分布式系统中的一个计算节点（node），而整个过程就是分布式处理。每个节点都独立地执行任务的一部分，最后将它们的结果合并起来形成最终的输出。这种分布式方式可以大大提高处理速度和系统的可伸缩性。
在Hadoop中，分布式处理的核心思想是将大量的数据分成小块，并在多台计算机上并行处理这些数据块。这样可以更快地完成任务，同时也提高了系统的容错性，因为即使某个计算节点出现故障，其他节点仍然可以继续工作。这种分布式处理模型使得Hadoop能够有效地处理大规模数据集。
什么叫分布式？化整为零
3. Hadoop的指代 狭义上来说，hadoop就是单独指代hadoop这个软件，
广义上来说，hadoop指代大数据的一个生态圈，包括很多其他的软件
——Hadoop生态圈：hbase、hive、spark、flink、yarn、flume...
Hadoop生态的图例:
🐶2.2 hadoop的发展历程 1. 起源（2004-2006）：
Hadoop的起源可以追溯到2004年，由道格·切宾（Doug Cutting）和迈克尔·卡福曼（Mike Cafarella）等人开发。最初，Hadoop是为了支持Nutch项目，这是一个开源的网络搜索引擎。切宾基于Google的论文《MapReduce: Simplified Data Processing on Large Clusters》和《The Google File System》的思想，开发了Hadoop分布式文件系统（HDFS）和MapReduce编程模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2766a1ab61736548ed82301ad96ed2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/317bd5817a8177ae716f41a69901a118/" rel="bookmark">
			Hampel滤波器是一种基于中位数的离群值检测方法【异常值检测方法】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hampel滤波器是一种基于中位数的离群值检测方法，也是一种线性滤波器，由德国数学家和统计学家John Hampel在1974年提出。它主要用于去除信号中的脉冲噪声，具有很强的抗干扰能力，因此被广泛应用于信号处理、通信系统等领域。
1.基本原理 Hampel滤波器的基本原理是对于需要滤波的数据Xs，选择一个长度为2k+1的窗口，通过中值数绝对偏差（MAD）来判定Xs的有效性。如果数据被判定为有效，则输出Xs；如果数据被判定为奇异数据（即离群值），则用窗口中值取代Xs。在实际使用中，对于一组待测数据，应从第一个数X1开始，向前补齐k个0，然后对第一个数X1和左右各k个数执行Hampel滤波，随后窗口依次向后滑动。
这种滤波器能够有效地消除数据中存在的离群值，这些离群值可能是由于数据损坏、错误或真实数据的异常情况导致的。无论原因如何，离群值都会对数据分析和建模产生负面影响。因此，Hampel滤波器在数据预处理阶段起着非常重要的作用。
总的来说，Hampel滤波器是一种有效的信号处理工具，它可以帮助我们识别和去除数据中的噪声和异常值，从而提高数据的质量和可靠性。
2.应用领域 Hampel滤波器在许多领域都有应用，包括但不限于以下方面：
信号处理：Hampel滤波器可以用于去除信号中的脉冲噪声和降低随机噪声，因此它在信号处理领域中得到了广泛应用。例如，在音频信号处理中，Hampel滤波器可以用于消除语音信号中的噪声，提高语音识别的准确率。图像处理：在图像处理中，Hampel滤波器可用于去除图像中的椒盐噪声等。通过对图像进行平滑处理，可以减少图像中的细节部分，从而达到去除噪声的效果。金融领域：在金融领域中，Hampel滤波器可以用于检测和去除市场数据中的异常值，从而得到更加准确的市场走势分析结果。此外，它还可以用于检测股票价格中的异常波动，帮助投资者做出更加明智的投资决策。医学领域：在医学领域中，Hampel滤波器可以用于消除医学图像中的噪声，从而提高医学诊断的准确率。例如，在脑部成像中，Hampel滤波器可以帮助医生更好地观察脑部结构，从而更好地诊断某些神经系统疾病。统计学：在统计学中，Hampel滤波器是一种用于检测和处理时间序列数据中异常值的稳健方法。它基于中值绝对偏差（MAD）并采用滚动窗口来识别异常值，因此对于异常值的检测具有较好的稳健性。
总之，Hampel滤波器在许多领域中都有应用，特别是在需要去除噪声、检测异常值和进行数据预处理的领域中更是如此。 除了之前提到的信号处理、图像处理和金融领域，Hampel滤波器还在以下领域有应用：
通信系统：在通信系统中，Hampel滤波器被广泛用于去除信号传输过程中产生的噪声，提高信号的质量和可靠性。这对于确保信息的准确传输至关重要。地震数据分析：在地震学研究中，地震数据常常受到各种噪声的干扰，如仪器噪声、环境噪声等。Hampel滤波器可以有效地去除这些噪声，提高地震数据的信噪比，从而更准确地分析地震事件。传感器数据处理：传感器在采集数据时往往会受到各种干扰，导致数据中存在大量噪声。Hampel滤波器可以对传感器数据进行滤波处理，去除噪声，提取有用的信息。工业自动化：在工业自动化领域，各种传感器和执行器产生的信号往往需要进行处理和分析。Hampel滤波器可以用于去除这些信号中的噪声和干扰，提高控制系统的稳定性和可靠性。
总的来说，Hampel滤波器是一种功能强大的信号处理工具，在多个领域都有广泛的应用。它的主要作用是去除数据中的噪声和干扰，提高数据的质量和可靠性，为各种应用提供准确、可靠的数据支持。 3.实现步骤 汉普尔（Hampel）滤波器是一种非常有效的用于抑制异常值的方法，特别适用于时间序列数据。它是基于统计学的，旨在保留数据的中心趋势和分布结构，同时减少噪声和异常值的影响。
Hampel滤波器的基本原理可以通过以下步骤描述：
中位数：对于每个数据点，计算其在一个固定大小窗口内的中位数。这个窗口通常是对称的，包括当前观测值的前后观测值。
绝对偏差：对于窗口内的每个数据点，计算其与中位数的绝对偏差。
中位数绝对偏差（MAD）：计算窗口内所有绝对偏差的中位数。MAD是衡量数据变异性的一种鲁棒方法。
阈值：定义一个阈值，通常是MAD的某个倍数（例如2.5倍或3倍）。这个阈值用于确定数据点是否是异常值。
滤波：对于每个数据点，如果其绝对偏差超过阈值（即被认为是异常值），则用窗口内的中位数替换它；否则，保留原始值。
在数学上，Hampel滤波器可以表示为以下伪代码：
对于每个数据点 x[i]： 计算窗口 W 中 x[i] 的中位数 med 对于窗口 W 内的每个点 x[j]： 计算绝对偏差 |x[j] - med| 计算窗口 W 内所有绝对偏差的中位数 MAD 如果 |x[i] - med| &gt; k * MAD （k 是预定义的常数）： x[i] = med 否则： x[i] = x[i] 这种方法的优点是它对异常值非常敏感，同时保持对数据的非破坏性处理，特别适用于具有偶然异常值的时间序列数据。
4.挑战困难 在实现汉普尔（Hampel）滤波器时，各个步骤的难易程度可能因实现环境（如编程语言）和数据集的特性而异。然而，一般来说，以下几个步骤可能会相对比较难实现：
高效计算滑动窗口中的中位数：对于每个数据点，需要计算包含该点的固定大小窗口内的中位数。对于大数据集或实时处理场景，这可能是一个挑战，因为需要频繁地更新窗口并计算中位数。使用普通的排序方法可能会导致效率低下，因此可能需要使用更高效的算法，如使用堆（heap）或双端队列（deque）来优化。
处理大数据集时的内存管理：如果数据集非常大，那么在内存中存储整个数据集和计算所需的额外结构（如窗口内的数据点）可能会成为问题。在这种情况下，需要有效地管理内存，可能需要使用流处理或分块处理技术。
确定合适的窗口大小和阈值：选择合适的窗口大小和阈值（即MAD的倍数）对于滤波器的性能至关重要。这通常需要对数据进行初步分析，可能涉及调优和实验，以找到最佳的参数。
实现鲁棒性：确保实现对不同类型的数据（如具有不同分布特征的数据）都能保持良好性能。这可能需要考虑如何处理边缘情况，例如数据中的空值或极端值。
优化性能：对于实时应用或处理非常大的数据集，性能优化尤为重要。这可能包括并行处理、优化数据结构选择等。
总体来说，虽然Hampel滤波器的概念理解起来不难，但要实现一个既快速又鲁棒的滤波器，需要考虑和解决上述方面的挑战。
5.相似方法 Hampel滤波器是一种用于消除或减少数据中异常值影响的方法，尤其适用于时间序列数据。与Hampel滤波器相似的其他方法或模型主要包括以下几种：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/317bd5817a8177ae716f41a69901a118/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a99b786fa00b1446204ff81dbaa0ec8/" rel="bookmark">
			Qt VS项目中添加图片到项目方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、双击qrc资源文件
2、选择需要添加的图片文件
3、点击保存即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21b05858abf6a5743f1b50c9eaf71804/" rel="bookmark">
			做数据关键步骤：怎么写好prompt？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 不论是批量构建sft数据来训练通用模型，还是最近大火的Agent，其实一个核心工作就是做好prompt engineering，因为只有写好了prompt（gpt模型回复满足当前需求），才意味着我们可以批量拉数据了或者整个Agent run起来了，进而才可以训练模型等等。
总结起来一句话就是：写好prompt，才意味着有了批量数据。
那么怎么才能写好prompt呢？泛泛来说就是把自己的需求抽象化成指令，且模型能够完全遵循这些指令。但是一个常见的现象是模型不能总是很好的遵循，即使是地表最强的GPT4有时候也不能完全遵循。
所以就需要prompt engineering也即需要一定的prompt编写技巧，这是很需要实战经验的，今天就带来一篇paper，其直接给出了一些prompt，可直接拿来主义尝试。
《Principled Instructions Are All You Need for
Questioning LLaMA-1/2, GPT-3.5/4》
论文链接: https://arxiv.org/pdf/2312.16171.pdf
Github : https://github.com/VILA-Lab/ATLAS
写prompt的几大原则 Conciseness and Clarity 如果写的prompt中包含过于冗长或含糊不清的提示，就可能会让模型困惑或导致无关的回答。所以应该尽可能简洁明了，避免不必要的信息。因为这些信息不仅对所做的任务没有贡献，反而会扰乱模型。
Contextual Relevance: prompt中必须要包括任务相关的背景信息，这些信息有助于帮助模型理解任务的背景和领域。比如可以写一些关键词、领域特定术语或情境描述。
Task Alignment 写的prompt应该与当前任务尽可能对齐，比如将prompt构建为问题、命令或填空语句，以引导出当前任务希望的输入和输出格式。
Example Demonstrations 这里就是最好举几个例子给模型，也就是大家常说的few-shot。
Avoiding Bias prompt应该设计为尽可能减少模型因训练数据而固有的偏见的激活。比如防止引导出敏感的话题等等。
Incremental Prompting 对于需要一系列步骤才能完成的任务，可以通过将任务分解逐步来引导模型完成。另外，提示应根据模型的表现和迭代反馈进行动态调整。
小结 除了上面的几个原则，更高级的prompt可能会包含类似编程的逻辑来完成复杂的任务。例如，使用条件语句、逻辑运算符，甚至在提示中使用伪代码来引导模型的推理过程。
具体例子 基于上面几大原则，作者给出了更具体例子
同时作者将上面的例子进行了原则归类
比如通过 “给小费” 来激励模型严格遵循指令。
总结 本文作者很实在，接地气，直接给了一些很具体的trick，大家在实战的时候可以试着用一下
关注 欢迎关注，下期再见啦~
知乎，csdn，github，微信公众号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ae27973961665424496539eed1127be/" rel="bookmark">
			C# 如何使用？、? 和 ??的区别和使用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
? 运算符
使用案例
?? 运算符
使用案例
总结
在 C# 中，? 和 ?? 运算符在处理 null 值时起着不同的作用，并且具有特定的使用场景。
? 运算符 ? 运算符，也称为空条件运算符，在 C# 6.0 及更高版本中引入。它允许你在不进行显式类型转换的情况下检查引用类型的变量是否为 null。如果变量为 null，则整个表达式的结果也是 null，并且不会执行 ? 之后的代码块。这有助于避免空引用异常。
使用案例 假设我们有一个方法，该方法返回一个字符串，或者在某些情况下返回 null：
string GetNullableString(); 如果我们想在返回的字符串上调用一个方法（例如 .Length），直接调用可能会引发异常，因为如果返回的是 null，尝试获取其长度会导致空引用异常。使用 ? 运算符可以安全地解决这个问题：
string result = GetNullableString()?.Length; 如果 GetNullableString() 返回 null，则整个表达式的结果也是 null，不会尝试访问 Length 属性。
?? 运算符 ?? 运算符是一个逻辑运算符，也称为空合并运算符。当左侧的操作数为 null 时，它返回右侧的操作数作为结果。如果左侧的操作数不为 null，则返回左侧的操作数。它通常用于为可能为 null 的变量提供一个默认值。
使用案例 假设我们有一个字符串变量，可能没有初始化：
string someString; 如果直接访问这个变量的长度，因为它是 null，会抛出空引用异常。我们可以使用 ?? 运算符来提供一个默认值：
int length = someString ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ae27973961665424496539eed1127be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/369cf41a14965d3983239d951879c1f4/" rel="bookmark">
			安全认证【八】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 8. 安全认证8.1 访问控制概述8.2 认证管理8.3 授权管理8.4 准入控制 8. 安全认证 8.1 访问控制概述 Kubernetes作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。所谓的安全性其实就是保证对Kubernetes的各种客户端进行认证和鉴权操作。
客户端
在Kubernetes集群中，客户端通常有两类：
User Account：一般是独立于kubernetes之外的其他服务管理的用户账号。Service Account：kubernetes管理的账号，用于为Pod中的服务进程在访问Kubernetes时提供身份标识。 认证、授权与准入控制
ApiServer是访问及管理资源对象的唯一入口。任何一个请求访问ApiServer，都要经过下面三个流程：
Authentication（认证）：身份鉴别，只有正确的账号才能够通过认证Authorization（授权）： 判断用户是否有权限对访问的资源执行特定的动作Admission Control（准入控制）：用于补充授权机制以实现更加精细的访问控制功能。 8.2 认证管理 Kubernetes集群安全的最关键点在于如何识别并认证客户端身份，它提供了3种客户端身份认证方式：
HTTP Base认证：通过用户名+密码的方式认证
这种认证方式是把“用户名:密码”用BASE64算法进行编码后的字符串放在HTTP请求中的Header Authorization域里发送给服务端。服务端收到后进行解码，获取用户名及密码，然后进行用户身份认证的过程。 HTTP Token认证：通过一个Token来识别合法用户
这种认证方式是用一个很长的难以被模仿的字符串--Token来表明客户身份的一种方式。每个Token对应一个用户名，当客户端发起API调用请求时，需要在HTTP Header里放入Token，API Server接到Token后会跟服务器中保存的token进行比对，然后进行用户身份认证的过程。 HTTPS证书认证：基于CA根证书签名的双向数字证书认证方式
这种认证方式是安全性最高的一种方式，但是同时也是操作起来最麻烦的一种方式。 HTTPS认证大体分为3个过程：
证书申请和下发
HTTPS通信双方的服务器向CA机构申请证书，CA机构下发根证书、服务端证书及私钥给申请者 客户端和服务端的双向认证
1&gt; 客户端向服务器端发起请求，服务端下发自己的证书给客户端， 客户端接收到证书后，通过私钥解密证书，在证书中获得服务端的公钥， 客户端利用服务器端的公钥认证证书中的信息，如果一致，则认可这个服务器 2&gt; 客户端发送自己的证书给服务器端，服务端接收到证书后，通过私钥解密证书， 在证书中获得客户端的公钥，并用该公钥认证证书信息，确认客户端是否合法 服务器端和客户端进行通信
服务器端和客户端协商好加密方案后，客户端会产生一个随机的秘钥并加密，然后发送到服务器端。 服务器端接收这个秘钥后，双方接下来通信的所有内容都通过该随机秘钥加密 注意: Kubernetes允许同时配置多种认证方式，只要其中任意一个方式认证通过即可
8.3 授权管理 授权发生在认证成功之后，通过认证就可以知道请求用户是谁， 然后Kubernetes会根据事先定义的授权策略来决定用户是否有权限访问，这个过程就称为授权。
每个发送到ApiServer的请求都带上了用户和资源的信息：比如发送请求的用户、请求的路径、请求的动作等，授权就是根据这些信息和授权策略进行比较，如果符合策略，则认为授权通过，否则会返回错误。
API Server目前支持以下几种授权策略：
AlwaysDeny：表示拒绝所有请求，一般用于测试AlwaysAllow：允许接收所有请求，相当于集群不需要授权流程（Kubernetes默认的策略）ABAC：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制Webhook：通过调用外部REST服务对用户进行授权Node：是一种专用模式，用于对kubelet发出的请求进行访问控制RBAC：基于角色的访问控制（kubeadm安装方式下的默认选项） RBAC(Role-Based Access Control) 基于角色的访问控制，主要是在描述一件事情：给哪些对象授予了哪些权限
其中涉及到了下面几个概念：
对象：User、Groups、ServiceAccount角色：代表着一组定义在资源上的可操作动作(权限)的集合绑定：将定义好的角色跟用户绑定在一起 RBAC引入了4个顶级资源对象：
Role、ClusterRole：角色，用于指定一组权限RoleBinding、ClusterRoleBinding：角色绑定，用于将角色（权限）赋予给对象 Role、ClusterRole
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/369cf41a14965d3983239d951879c1f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8370733d371886f9fefc8e61296f759d/" rel="bookmark">
			ESP32通过RS485使用土壤氮磷钾传感器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//TX 16 //RX 17 #include &lt;Arduino.h&gt; #include &lt;HardwareSerial.h&gt; unsigned char item[8] = {0x01, 0x03, 0x00, 0x1E, 0x00, 0x03, 0x65, 0xCD}; void setup() { // put your setup code here, to run once: Serial.begin(9600); Serial2.begin(9600); while (!Serial) ; // wait for serial port to connect. Needed for Leonardo only } void loop() { String data = ""; char buff[128]; // 定义存储传感器数据的数组 String info[11]; for (int i = 0; i &lt; 8; i++) { // 发送测温命令 Serial2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8370733d371886f9fefc8e61296f759d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/063b17fa0623c9ff9e051f801bab0d91/" rel="bookmark">
			数据结构(五)——初识线性表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🧑个人简介：大家好，我是尘觉，希望我的文章可以帮助到大家，您的满意是我的动力😉
在csdn获奖荣誉: 🏆csdn城市之星2名
⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　💓csdn2023年后端赛道第第七
⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　💓csdn2023年长沙赛道第一
⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　💓csdn2023年大二赛道第二
⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　💓Java全栈群星计划top前5
⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　🤗 端午大礼包获得者
⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　🥰阿里云专家博主
⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　😉亚马逊DyamoDB结营
获得国家荣誉3项省级荣誉4项以及多项校院级
💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，感谢大家的观看🥰
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/063b17fa0623c9ff9e051f801bab0d91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0c429249a08a1d917be809035e7652a/" rel="bookmark">
			12.30更新5$key！2023最新Python搭建个人ChatGPT流式输出网站（包含源码、免费gpt3.5/4网址、以及免费测试apikey）快来体验吧！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ps:在这里提前祝各位小伙伴们新年快乐哦！！！ 本期文章为纯免费资源分享，欢迎交流分享你的学习经验！2023年12月30日最新python实现流式输出gpt网站搭建的源码：
目录
1.python源码
2.网站效果演示
3.html源码
1.python后端源码 如下为python后端源码：
from flask import Flask, render_template, request, Response, jsonify import openai #openai使用0.28.0版本，urllib3使用1.26.2版本 import random # 设置代理网址 openai.api_base = "https://api.openai-proxy.com/v1" # 替换为您自己的OpenAI API密钥列表，如下key供各位测试，12.30已更新，新年快乐！用完提醒我，哈哈~~~ api_keys = [ "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", ] # 创建Flask应用程序 app = Flask(__name__) # 定义可供选择的模型，已经更新gpt所有14个模型 available_models = { "gpt-3.5-turbo-1106": "GPT-3.5-Turbo-1106(4096tokens)", "gpt-3.5-turbo": "GPT-3.5-Turbo(4096tokens)", "gpt-3.5-turbo-16k": "GPT-3.5-Turbo-16k(16385tokens)", "gpt-3.5-turbo-0613": "GPT-3.5-Turbo-0613(4096tokens)", "gpt-3.5-turbo-16k-0613": "GPT-3.5-Turbo-16k-0613(16385tokens)", "gpt-3.5-turbo-0301": "GPT-3.5-Turbo-0301(4096tokens)", "gpt-4-1106-preview": "GPT-4-1106-preview(4096tokens,max:128000tokens)", "gpt-4-vision-preview": "GPT-4-vision-preview(4096tokens,max:128000tokens)", "gpt-4": "GPT-4(8192tokens)", "gpt-4-0613": "GPT-4-0613(8192tokens)", "gpt-4-32k": "GPT-4-32k(32768tokens)", "gpt-4-32k-0613": "GPT-4-32k-0613(32768tokens)", "gpt-4-0314": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0c429249a08a1d917be809035e7652a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0a40d3dfafba83c581bcf09405323ad/" rel="bookmark">
			重新认识Word——自动目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重新认识Word——自动目录 自动插入目录要点大纲级别 自定义目录格式给图表插入目录致谢和参考文献没有在目录之中一些目录的问题目录中有“目录”二字一份文档，两份目录 之前我们对文本内容的编辑有了一个大概的了解，接下来我们来了解一下，Word的自动目录，方便我们一键生成目录。
自动插入目录要点 如果只是插入目录的操作，大家应该都会，光标放在正文第一页，新建一个空白页：
在插入选项卡里，找到空白页：
在新的页面里，找到引用选项卡，找到目录：
下拉，选择一个心仪的目录样式：
这样自动目录就引用成功了，也没有什么难的嘛。
但实际上，这篇文章引用目录是成功了，我们换个文档来看：
像上面那样一样操作，之后：
送了一个提示框：说要把样式库中的样式运用到所选文本，诶？样式，这不是我们一开始接触的东西吗？我们可以看看这篇文档的标题有没有应用标题样式：
我们看到，我们的标题文字并没有运用标题样式，现在我们将标题文字运用标题样式：
现在我们可以明显看到，标题运用了标题一的样式，这时候我们再来插入目录：
咦？运用了标题样式的文字可以被自动目录引用，这里要提及一下我们之前提过的大纲级别了。
大纲级别 啥是大纲级别呢？我们选中标题，右键，选择段落：
这里有个叫做大纲级别：
我们下拉：
我们发现它有很多级别，1级，2级，3级等等，总结一下就是，只要大纲级别不是正文文本，引用自动目录后都会被引用在目录里。 1级为最高级，之后优先级依次减小。
分析之前，引用自动目录不成功的原因就是我们的文字并没有设置大纲级别，目录生成的唯一依据就是大纲级别，所以没有成功，我们可以试着给其他文字设置一下其他的大纲级别：
我们又给一些文字运用了标题2的样式（自动运用了大纲级别2），这时候返回目录页，选中目录，选择更新目录（选择更新整个目录）：
发现运用了标题样式2的也被运用到了目录里，而且因为标题2的样式里的大纲级别为2，所以二级标题的目录项缩进了两格。
自定义目录格式 如果我们觉得Word内嵌的目录样式不符合我们的要求，我们也可以自定义目录：
我们来看看毕业论文的一般的要求格式：
我们按照这个要求来：
首先设置“目录”两字的格式：
这个时候引用目录，点击自定义目录：
这是时候点击修改：
这时候我们选中的是TOC 1表示的是我们修改的是标题一目录样式，这时候再点击修改：
这时候我们进入了修改样式的属性框，我们根据我们的要求改好相应的样式：
修改好了一级标题的，我们修改二级标题的：
下拉格式，选择“段落”，设置缩进：
这里他已经设置好了是两字符的了，如果我们有特殊要求，可以自己设置。
按照同样的方法，设置好三级标题的目录样式：
然后我们目录的要求是：目录页码和数字之间是用虚线连接，这个好办，下拉制表符前导符，选择虚线：
点击确定：
我们就运用了我们想要的目录样式了。
给图表插入目录 有时候我们的科技论文要求给图表，公式创建目录，这也非常简单，我们先重新另起一页空白页：
在引用选项卡中，找到“插入表目录”：
表目录和目录的设置大同小异，注意一下我们的题注标签就行：
我们这里是给图创建目录，所以选择题注标签为图，如果为公式，选择公式就行，这里不再赘诉：
致谢和参考文献没有在目录之中 我们看看我们的目录：
到了第6章就结束了，我们的参考文献和致谢并没有编进目录里：
这里我们可以看一下：** “参考文献” 这几个字用的样式 **：
用的是标题样式，我们打开我们的自定义目录设置：
点击选项：
下拉一下：
我们发现，标题并没有设置目录级别，这样在目录中就不会显示，解决也很简单，设置==“标题”的目录级别为1==：
点击确定，之后更新目录：
我们发现，参考文献和致谢都在目录中了。
一些目录的问题 目录中有“目录”二字 有时候我们引用的目录当中，“目录”二字都被引入到了目录中：
很简单，“目录”二字被引用到了目录当中，很有可能“目录”这两个字被错误设置了大纲级别，我们把它的大纲级别设置回来就行了：
一份文档，两份目录 这个也很简单，重起一页空白页，重新插入一份自定义目录（注意一定要是自定义目录，如果是Word内嵌的目录，会被覆盖）：
点击“否”：
这样我们就有两份目录了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0447aab6b85eb3a5b9b2c45d4c10aa9/" rel="bookmark">
			AAAI 2024：大模型如何掌握复杂工具？看孔子框架的教学之道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如今，大型语言模型（LLM）发展飞速，在文本和图像生成方面表现都很出色，但在我们的实际生活中，要理解和正确使用各种工具方面尚存在困难。人们期望这些模型在解决实际问题时能够灵活运用和理解各种工具，例如在规划路线、智能家居等生活场景中，模型可能需要准确选择和使用各种工具。
为了应对 LLM 在实际应用场景中使用各种复杂工具时面临的挑战，作者提出了孔子（Confucius）框架，通过当一个出色的“老师”，使 LLM 在贴近我们生活的应用场景中更加智能。通过多阶段学习、迭代自指导和反思反馈（ISIF）等策略，该框架使 LLM 能够更好地掌握各种工具。
▲图1 现有基于微调的工具学习方法与Confucius 的比较
论文题目:
Confucius: Iterative Tool Learning from Introspection Feedback by Easy-to-Difficult Curriculum
论文链接:
https://arxiv.org/abs/2308.14034
工具学习（Tool Learning） ▲表1 相关工作的比较
工具学习可以让 LLM 与各种工具进行有效交互以完成复杂任务。通过将 LLM 与 API 相结合，可以大大扩展其功能，使 LLM 成为用户与广泛的应用生态系统之间的高效桥梁。目前主流的方法可以分成以下2大类：
无微调（tuning-free）的工具学习：利用 LLM 天生具备的上下文学习能力的方法。在这种方法中，输入工具的演示，来提示 LLM 使用各种工具。然而，该方法存在两个主要缺点：
数据安全问题：由于数据安全原因，不是所有应用都能将工具和用户数据传输给 LLM 服务提供商。这限制了在这些应用中使用专有 LLM 的可能性。
输入长度限制：由于输入长度的限制，提示无法容纳大量工具，因此导致对大量工具的应用存在一定的限制。
基于微调（tuning-base）的工具学习：是一种直接在工具使用数据集上微调语言模型参数的方法，通常通过提示专有 LLM 使用特定工具来构建（如搜索、计算和翻译）。这些方法大多首先使用自指导技术从专有 LLM 中收集工具使用数据，然后微调一个开源模型。其优势在于它们可以轻松部署在自托管环境中。然而，在构建的数据集上微调语言模型通常会引入泛化问题。
孔子（Confucius）框架 Confucius 包含两个主要阶段：
为了解决训练 LLM 使用复杂工具的挑战，首先提出一个多阶段学习方法，通过一个从易到难的课程，教授 LLM 使用各种工具。
提出了一种迭代的内省与更新（ISIF）技术，动态更新数据集，为模型的训练提供更有针对新的样本，以提高模型使用复杂工具的能力。
▲图2 整体架构包括多阶段学习和迭代自指导和内省反馈
多阶段学习 这是一种分阶段进行模型训练的方法，旨在逐步提高模型对复杂任务的学习能力。该方法通常包含多个训练阶段，每个阶段都侧重于不同的任务或难度水平，使模型能够逐渐适应和提高性能。如图 2 所示，一般包括以下几个阶段：
热身训练阶段（Warm-Up Training）：在这个阶段，模型接触到一些基本的任务或信息，以建立起对基础知识的了解。这有助于模型建立起基础，为后续学习提供一个良好的起点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0447aab6b85eb3a5b9b2c45d4c10aa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c36606b68206bd4f8426d13ea84ab62d/" rel="bookmark">
			117基于matlab的短时傅里叶变换（STFT）、小波变换（WT）、同步压缩变换（SST）、瞬态提取变换（TET）进行时频分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于matlab的短时傅里叶变换（STFT）、小波变换（WT）、同步压缩变换（SST）、瞬态提取变换（TET）进行时频分析。程序已调通，可直接运行。
117时频分析短时傅里叶变换 (xiaohongshu.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/548ff1ac4b082661c4711e25b8795444/" rel="bookmark">
			Linux系统中CPU使用率概念与计算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CPU使用率 CPU使用率定义：
CPU 使用率是单位时间内 CPU 使用情况的统计，以百分比的方式展示。CPU 使用率是最常用来描述系统CPU 性能的指标。
Linux 作为一个多任务操作系统，将每个 CPU 的时间划分为很短的时间片，再通过调度器轮流分配给各个任务使用，因此造成多任务同时运行的错觉。
节拍率 为了维护 CPU 时间，Linux 通过事先定义的节拍率（内核中表示为 HZ），触发时间中断，并使用全局变量 Jiffies 记录了开机以来的节拍数。每发生一次时间中断，Jiffies 的值就加 1。节拍率 HZ 是内核的可配选项，可以设置为 100、250、1000 等。不同的系统可能设置不同数值，你可以通过查询 /boot/config 内核选项来查看它的配置值，指令如下：
grep 'CONFIG_HZ=' /boot/config-$(uname -r) 说明我这台设备的节拍率就是250
节拍率 HZ 是内核选项，所以用户空间程序并不能直接访问。为了方便用户空间程序，内核还提供了一个用户空间节拍率 USER_HZ，它总是固定为 100，也就是 1/100 秒。这样，用户空间程序并不需要关心内核中 HZ 被设置成了多少，因为它看到的总是固定值 USER_HZ。
Linux 通过 /proc 虚拟文件系统，向用户空间提供了系统内部状态的信息，而 /proc/stat 提供的就是系统的 CPU 和任务统计信息。比方说，如果只关注 CPU 的话，可以执行下面的命令：
cat /proc/stat | grep ^cpu $ cat /proc/stat | grep ^cpu
cpu 1136726 11458 386672 122678171 33738 0 22252 0 0 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/548ff1ac4b082661c4711e25b8795444/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df249061289a43e1c1ad71f51cf4b5f4/" rel="bookmark">
			K-means 聚类算法分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法简述 K-means 算法原理 我们假定给定数据样本 X ，包含了 n 个对象 ，其中每一个对象都具有 m 个维度的属性。而 K-means 算法的目标就是将 n 个对象依据对象间的相似性聚集到指定的 k 个类簇中，每个对象属于且仅属于一个其到类簇中心距离最小的类簇中。对于 K-means 算法，首先需要初始化 k 个聚类中心 , 然后通过计算每一个对象到每一个聚类中心的欧式距离，如下式所示：
这里的 表示第i个对象，表示第 j 个聚类中心，表示第i个对象的第t个属性，，表示第j个聚类中心的第t个属性。
依次比较每一个对象到每一个聚类中心的距离，将对象分配到距离最近的聚类中心的类簇中，得到k个类簇，kmeans 算法定义了类簇的原型，类簇中心就是类簇内所有对象在各个维度的均值，其计算公式如下所示：
式中， 表示第l个聚类中心，，表示第l个类簇中对象的个数，表示第l个类簇中第i个对象，
算法实现流程 随机设置 K 个特征空间内的点作为初始的聚类中⼼。对于其他每个点计算到 K 个中⼼的距离，未知的点选择最近的⼀个聚类中⼼点作为标记类别。接着对着标记的聚类中⼼之后，重新计算出每个聚类的新中心点（平均值）如果计算得出的新中⼼点与原中⼼点⼀样（质⼼不再移动），那么结束，否则重新进⾏第⼆步过程。 核心代码 手写实现 K-means 算法：
import numpy as np import random import matplotlib.pyplot as plt plt.rcParams['font.sans-serif'] = ['SimHei'] plt.rcParams['axes.unicode_minus'] = False """ 手写实现Kmeans """ data = np.genfromtxt("classes.txt", delimiter='\t') X = data K = 5 colors = ['r', 'g', 'b', 'c', 'm', 'y', 'k'] max_iterations = 10000 random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df249061289a43e1c1ad71f51cf4b5f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/728de445209bffc1da7d06d2d59eb714/" rel="bookmark">
			基于MINIST的手写数字体识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、算法简述 网络结构设计 通过创建MnistNet类，定义了包含两个卷积层和两个全连接层的深度神经网络。这个网络的设计灵感来自于经典的CNN结构，其中卷积层用于提取图像特征，而全连接层则用于将这些特征映射到最终的类别。
卷积与池化 卷积操作通过在输入图像上滑动卷积核，有效地捕捉图像的局部特征，例如边缘、纹理等。这种局部感知能力使得网络能够更好地理解输入图像的结构信息，从而更好地进行字符识别。在卷积操作后，激活函数的引入是为了引入非线性特性。ReLU激活函数通过将负值映射为零，保留正值，引入了非线性变换。这种非线性变换对于学习更加复杂的特征表示至关重要。池化层则在特征图上进行降维操作，最常见的是最大池化。最大池化通过在每个池化窗口中选择最大值，减小了特征图的尺寸，有助于提高模型的计算效率。此外，最大池化也有助于保留图像中最显著的特征，使网络对于空间变化更加鲁棒。
全连接层与激活函数 全连接层负责整合卷积层提取的特征，通过ReLU激活函数引入非线性。最终的全连接层输出通过Log_Softmax函数处理，转换为类别的概率分布。
Log_Softmax其实就是对Softmax取对数，表达式如下所示：
尽管，数学上log_Softmax是对Softmax取对数，但是，实际操作中是通过下面的式子来实现的：
其中，在加快运算速度的同时，保证数据的稳定性。
前向传播 在前向传播中，定义了输入数据如何在网络中传播。这个方法描述了数据如何通过卷积层、池化层和全连接层，最后经过Log Softmax函数的处理，网络的输出被转换为概率分布。Log Softmax对神经网络的输出进行归一化，使得每个类别的预测概率都落在 (0, 1) 的范围内，同时通过取对数的方式方便计算和优化。这一步为多类别分类问题提供了一种有效的建模方式。
网络参数 通过named_parameters方法，可以打印网络中所有参数的名称、值和大小，深入了解网络结构和模型的可训练参数，这样能够详细了解神经网络的结构。这对于验证网络是否按照预期的方式组织和连接层次非常有用。这种审查有助于确保网络的设计符合预期，并且每一层都按照计划进行连接。
MnistNet(
(conv1): Conv2d(1, 10, kernel_size=(5, 5), stride=(1, 1))
(conv2): Conv2d(10, 20, kernel_size=(3, 3), stride=(1, 1))
(fc1): Linear(in_features=2000, out_features=500, bias=True)
(fc2): Linear(in_features=500, out_features=10, bias=True)
)
二、设计步骤 本设计流程如下所示：
数据可视化及训练测试集划分 通过pytorch官方下载的MINIST数据集是以二进制的形式存放的，将数据集中的数字图像转换为jpg图像格式，可以更直观地展示和理解数据。更容易通过观察图像来理解和识别数字，而不是处理抽象的数字矩阵。在转化过程中，将图像路径和标签信息写入相应的文本文件中，以便后续的数据加载。
# Data_preprocessing.py import torch from torchvision import datasets, transforms import os from skimage import io import torchvision.datasets.mnist as mnist root = r"D:\PythonProject\pythonProject2\MNIST_pytorch\data\MNIST\raw" # 下载测试集 # train_dataset = datasets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/728de445209bffc1da7d06d2d59eb714/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a416805a71200eb20abb820b9c63cc3/" rel="bookmark">
			Ref 系列 UniRef&#43;&#43;: Segment Every Reference Object in Spatial and Temporal Spaces 论文阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ref 系列 UniRef++: Segment Every Reference Object in Spatial and Temporal Spaces 论文阅读笔记 一、Abstract二、引言三、相关工作3.1 统一的模型3.2 特定任务的目标分割指代图像分割Few-shot 分割指代视频目标分割视频目标分割 四、方法4.1 总览4.2 指代编码Few-shot Segmentation and Video Object SegmentationReferring Image SegmentationReferring Video Object Segmentation 4.3 多尺度 UniFusion 模块4.4 统一的架构TransformerMask 解码器 4.5 训练和推理训练推理 五、实验5.1 实验设置数据集实施细节 5.2 定量分析指代图像分割 RISFew-shot SegmentationReferring Video Object SegmentationVideo Object Segmentation 5.3 消融研究5.4 定性结果 六、将 UniFusion 插入到 SAM七、结论 写在前面
这周得加更两篇论文阅读笔记，完成 2023 的 flag。
此论文也是 Arxiv 比较新的文章，设计了一个大一统模型，解决图像和视频的指代分割问题，应该是篇大佬工作。
论文地址：UniRef++: Segment Every Reference Object in Spatial and Temporal Spaces代码地址：https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a416805a71200eb20abb820b9c63cc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acc14fa1c577d2b17c78228125457b5f/" rel="bookmark">
			10、RabbitMQ高频面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、你们项目中哪里用到了RabbitMQ RabbitMQ是我们项目中服务通信的主要方式之一 , 我们项目中服务通信主要有二种方式实现 :
通过Feign实现服务的同步调用通过MQ实现服务的异步通信 下面要结合自己的项目中功能来说两个地方
xxx
xxx
2、为什么会选择使用RabbitMQ 我们项目中之所以选择使用RabbitMQ，是因为它的功能比较丰富 , 支持各种消息收发模式, 支持延迟队列 , 惰性队列
而且天然支持集群, 保证服务的高可用, 同时性能非常不错 , 社区也比较活跃, 文档资料非常丰富
使用MQ有很多好处，简单跟您说几个：
吞吐量提升：无需等待订阅者处理完成，响应更快速
故障隔离：服务没有直接调用，不存在级联失败问题
调用间没有阻塞，不会造成无效的资源占用
耦合度极低，每个服务都可以灵活插拔，可替换
流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件
当然使用使用MQ也有一些缺点
架构复杂了，业务没有明显的流程线，不好管理需要依赖于Broker的可靠、安全、性能 总之，瑕不掩瑜，使用了RabbitMQ之后可以大大提供程序的效率
3、使用RabbitMQ如何保证消息不丢失 消息从生产者发送到消费者接收，会经历多个过程 , 其中的每一步都可能导致消息丢失
大体可以分为这样几种情况:
消息发送到交换机丢失消息从交换机路由到队列丢失消息保存到队列中丢失消费者消费消息丢失 针对每一步，RabbitMQ分别给出了解决方案：
消息发送到交换机丢失：发布者确认机制
消息发送到交换机失败会向生产者返回失败原因，生产者通过回调接收发送结果，如果发送失败，重新发送，或者记录日志人工介入
消息从交换机路由到队列丢失：发布者回执机制
消息从交换机路由到队列失败会向生产者返回失败原因 ，生产者通过回调接收回调结果，如果发送失败，重新发送，或者记录日志人工介入
消息保存到队列中丢失：MQ持久化
RabbitMQ运行开启交换机持久化、队列持久化、消息持久化，以保证消息在传输过程中不会丢失
消费者消费消息丢失：消费者确认机制
消费者确认机制指的是只有消费者一方确认消息消费成功了，mq才删除消息，否则就会重新发送消息给消费者
通过RabbitMQ本身所提供的机制基本上已经可以保证消息不丢失, 但是因为一些特殊的原因还是会发送消息丢失问题 ,
例如 : 回调丢失 , 系统宕机, 磁盘损坏等 , 这种概率很小 , 但是如果想规避这些问题 , 进一步提高消息发送的成功率, 也可以通过程序自己进行控制
设计一个消息状态表 , 主要包含 : 消息id , 消息内容 , 交换机 , 消息路由key , 发送时间, 签收状态等字段 , 发送方业务执行完毕之后 , 向消息状态表保存一条消息记录, 消息状态为未签收 , 之后再向MQ发送消息 , 消费方接收消息消费完毕之后 , 向发送方发送一条签收消息 , 发送方接收到签收消息之后 , 修改消息状态表中的消息状态为已签收 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acc14fa1c577d2b17c78228125457b5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74f1fb039117716b0bcd2a59bd1cf341/" rel="bookmark">
			虚幻UE 材质-材质基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：本文对UE内的材质和材质实例的部分参数进行讲解
关注！关注！关注！ 2023百粉结束！
文章目录 一、材质与材质实例二、材质参数1、细节内参数2、节点参数 三、材质实例参数四、材质实验1、常量和变量2、已遮罩和半透明3、纹理UV展开4、Lerp5、Megascans材质 一、材质与材质实例 材质实例 | Material Instance：一般渲染器意义上的“材质”，具有常规的参数界面，供最终用户调整美术效果。（程序人员
材质 | Material：材质实例的“里层”，使用节点方式搭建效果框架。（美术人员
物体身上一般不用材质，而用材质实例，因为材质实例可以节省性能。
材质是区分物体类别，如房子材质和人体材质。
材质实例则是区分某一类别的物体的特性，如人体中的黑人和白人。
二、材质参数 1、细节内参数 物理材质：通过设置物理材质（水、土地、金属），人物走在不同物体上发出的声音不同。（目前个人用到这个。
材质域：说明这个材质最终要用到什么物体身上，有表面、贴画、UI、后处理等。
混合模式：简单理解为材质输出的时候怎么和已存在在背景中的内容混合，有不透明，半透明（有小数，可以过渡，用于玻璃、烟雾）和遮罩(0/1没有过渡，硬边剪切，用于剪影)。
着色模型：简单理解为材质的种类，如普通物体，车漆，眼睛，布料，头发等。
双面：物体正反面都渲染出材质。
使用材质属性：为真，则自己汇总各参数到材质属性内输出，下面是差别。
2、节点参数 常量和变量：
常量 | Constant：不能在材质实例中调整（上面
变量 | Variable：可以在材质实例中调整（下面 材质实例部分展示
4 + 鼠标左键点击 //1、2、3也可以，不同维度的变量 //还有其他常量如下面要讲的纹理，默认参数节点都是常量 部分参数节点通过右键可以将常量转变为变量 矢量和标量：
矢量 | Vector：表示颜色、坐标等信息（左边
标量 | Scalar：常用参数调整手段（右边
1 + 鼠标左键点击 //标量 2/3/4 + 鼠标左键点击 //矢量 贴图：
Texture Sample：调用贴图（后面实验阶段展示
Texture Coordinate：设定贴图的UV坐标
注意采样器类型适配贴图类型（注意有没有错误，默认系统会自适应
Lerp：
Linear Interpolate | 线性插值
阀门逻辑，用于混合两个不同的输入
Alpah 0 取用A输入，Alpha 1 取用B输入，中间值为混合状态
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74f1fb039117716b0bcd2a59bd1cf341/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96c9a73c8055c65a118585713f40d2fb/" rel="bookmark">
			go mod 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.关于模块2.关于 go mod3.格式4.示例参考文献 1.关于模块 模块（Modules）是 Go 1.11 版本引入的一依赖管理机制。
一个模块是 Go packages 的集合，定义在项目根目录下的 go.mod 文件。go.mod 文件定义了模块的路径，这也是使用当前项目中包的导入路径。go.mod 文件还定义了模块的依赖项，这些是项目成功构建所需的其他模块。每个依赖项都被编写为模块路径和特定的语义版本。
从 Go 1.11 开始，go 命令允许在当前目录或任何父目录有 go.mod 文件时使用 module，条件是目录位于 GOPATH/src 之外。在 GOPATH/src 中，即使找到了 go.mod，为了兼容性起见，go 命令仍然在旧的 GOPATH 模式下运行。从 Go 1.13 开始，模块将是包管理的默认模式。
2.关于 go mod go mod 命令是与 Go 模块相关的命令行工具，提供对模块的访问和操作。
注意，所有 go 命令都内置了对模块的支持，不仅仅是go mod。例如，日常添加、删除、升级、降级，应该使用go get。
有关模块功能的概述，请参阅go help modules。
3.格式 go mod &lt;command&gt; [arguments] 子命令有：
download download modules to local cache edit edit go.mod from tools or scripts graph print module requirement graph init initialize new module in current directory tidy add missing and remove unused modules vendor make vendored copy of dependencies verify verify dependencies have expected content why explain why packages or modules are needed 关于子命令的详细说明请使用go help mod &lt;command&gt;。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96c9a73c8055c65a118585713f40d2fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4af6313ad56843f3cd2447d0fd32dd0/" rel="bookmark">
			C&#43;&#43;探讨 一: 函数返回值为类对象和类对象引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 函数返回类对象1.1. 调用构造函数1.2. 调用拷贝构造函数 2. 函数返回类对象的引用2.1. 返回正常引用2.2. 返回局部对象的引用: 未定义行为(✖✖✖!! Undefined Behavior) 1. 函数返回类对象 在C++中，定义一个函数时可以返回类的对象。本段介绍在返回类的对象过程中，C++都做了什么？ 这个行为取决于你的代码是如何书写的。有可能会直接调用类的构造函数，也有可能调用拷贝构造函数。下面为分析
1.1. 调用构造函数 先看一段代码：
#include &lt;iostream&gt; using namespace std; class Car { public: Car() { cout &lt;&lt; "Constructor Car." &lt;&lt; endl; } Car(const Car&amp; rh) { cout &lt;&lt; "Copy Constructor Car." &lt;&lt; endl; } ~Car() { cout &lt;&lt; "Destructor Car." &lt;&lt; endl; } void PrintInfo() { cout &lt;&lt; "I am a Car" &lt;&lt; endl; } }; Car CarFactory() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4af6313ad56843f3cd2447d0fd32dd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b72a3a7c6f21c6a590bfb7075d0b8df/" rel="bookmark">
			【python 的各种模块】(8) 在python使用matplotlib和wordcloud库来画wordcloud词云图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
目标：用python画出，网上流行的wordcloud词云图
1 准备工作
1.1环境准备
1.1.1安装步骤
1.2 资源准备
1.2.1 文本文件内容如下
1.2.2 图片资源
2 代码测试
2.1 第一版代码和效果
2.1.1 代码和效果
2.1.2 一般plt里解决中文乱码问题
2.1.3 wordcloud的中文显示方框解决办法
2.2 修改后的代码
2.3 上述代码解析
2.3.1 导入模块
2.3.2 读取txt文件的内容，存储在变量wordlist里
2.3.3 用mask属性进行图片解码，然后利用解码的图形形式
2.3.4 输出显示
2.3.5 核心函数 WordCloud()
3 wordcloud() 语法详细
3.1 多级对象辨析
3.2 函数基础语法
3.3 函数基础语法相关参数解析
3.3.1 WordCloud的参数：
3.3.2 测试代码
4 词云图片的显示和输出
4.1 几种显示方式
4.1.1 用 plt.imshow(wordcloud）显示词云
4.1.2 用wordcloud.to_image().show() 来显示词云，并不保存图片！
4.2 保存为图片
4.2.1 其他输出函数和依赖的包/模块
4.2.2 使用 wordcloud.to_file(path) 保存词云
4.2.3 使用wordcloud.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b72a3a7c6f21c6a590bfb7075d0b8df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2e2a80a78ae411a14069d05873ef6f3/" rel="bookmark">
			【计算机图形学】Few-Shot Physically-Aware Articulated Mesh Generation via Hierarchical Deformation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 为什么要提出这个工作2. 之前的工作（Privous Work）网格生成模型Few-shot生成物理感知的机器学习 3. PipelineOverview分层网格变形物理感知的变形校正 4. 实验评价指标定性实验 5. 限制6. 其他补充关于什么是few-shot重心坐标内插矩阵 1. 为什么要提出这个工作 作者观察到，之前的铰接物体生成模型存在两个问题：
一个是生成出来的铰接物体缺乏创新性（缺乏一种通过少量数据来学习广泛数据空间的能力）通过生成模型得到的铰接物体，往往无法确保其物理性质是合理的（也就是生成出来的铰接物体违反物理性质/规律） 针对这两个存在的问题，作者想要做的事情是：通过观察涵盖少量示例的铰接物体数据集（目前比较火的Few-shot learning），进一步地生成更加多样化的mesh，同时使得这些生成的mesh在视觉上保真、物理上合理。
为了解决这两个存在的问题，并达到目标，作者在Abstract中引出了他的key innovations：
基于分而治之的哲学理论，建立一个分层次的基于变形的mesh生成模型。也就是将一个完整的铰接物体分成多个部件（分），从而进一步为Few-shot learning提供了可能。同时通过将大规模刚性mesh范式转移到这些部件上（治），来实现部件的变形（PS: 后面这一步，是因为在分的那步中，作者观察到，部件级别的mesh几乎都共享了相同的变形范式，这个范式可以直接从具有丰富数据的大规模刚性数据集迁移而来，学习这种基于大规模数据得到的生成能力）通过一个物理感知的变形校正框架，来保证物理上合理的生成 2. 之前的工作（Privous Work） 网格生成模型 直接表面生成，这种生成方式的显式优点是合成高质量的n边形网格，但它们通常受限于其生成能力，且无法将其生成能力拓展到一些复杂物体上。
基于变形的网格生成，受限于较低的自由度。
基于混合表示的生成将网格表面结构生成问题从内容生成中分离出来。但是生成结果的质量仍与表面重建技术相关。
文章将采用基于变形的网格生成，与以往直接变形整个物体或物体部件不同，作者设计了一种分层变形策略，通过大规模刚性网格中跨类别共享的变形模式来增强变形的灵活性。
Few-shot生成 这种生成的目标是仅通过新类别较少的案例来创造内容、语义上与目标类别保持一致的更多数据。
在这篇文章中，作者利用迁移学习使得目标铰接类别能够适应大规模刚性数据集的shape范式。
设计这种迁移学习方法需要找到正确的intermediates，使得网络能够跨类别迁移的shape范式，作者在这里选择convexes作为这种intermediateates。
物理感知的机器学习 生成物理上合理的铰接物体这个问题可以被视作在网格生成的过程中，需解决网格自交的问题。文章的策略是使用物理监督和形状优化策略。
3. Pipeline 问题的目标是：few-shot的物理感知铰接网格生成。给定一组感兴趣类别的铰接网格，方法能够学习到一个条件生成模型，该生成模型能够将铰接网格变形成相同类别的多样化形状。
想要达到这个目标要解决的两个挑战如1中所说：
如何从少量的例子中精确地表示复杂的shape变形空间？如何确保生成的网格支持物理真实的铰接？ 为了解决这两个挑战：
针对第一个问题，文章的想法是借用其他类别物体的知识来学习变形空间。这个想法是不平凡的，因为作者需要找到哪些知识是跨类别、可迁移的。进一步地，文章提出了分层网格变形策略，允许在local convexes segement level来迁移变形先验，同时保持整体shape的变形一致性
针对第二个问题，文章的想法是引入物理感知的变形校正框架，以避免在网格铰接过程中出现一些不想要的artifacts，如自交等。
Overview 完整Pipeline
给定一组感兴趣类别的、具有相同部件和铰接的、数量较少的铰接物体集合 A A A，文章想要去描绘多样化且可信的铰接形状空间。
文章运用分而治之的哲学，采用分层变形框架，结合迁移学习来解决few-shot生成问题。
首先，让生成模型学会在lowest convex level上描绘一个多样化的形状空间。这一步借用了从大规模刚性网格数据 B B B中学习的生成范式。
其次，设计一个合成策略，能够将变形后的convex一致的组合成一个合理的shape。
最后则是运用一个物理感知的校正框架来解决一些物理上不自然的现象，如自交问题。
更细节地说
首先，将网格a分割成convex集合 C a C_a Ca​，构建object-convex的分层框架。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2e2a80a78ae411a14069d05873ef6f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39283e81ad2c164e0297d37a7eed0345/" rel="bookmark">
			2023年人工智能行业总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在2023年，人工智能（AI）领域的发展犹如疾风骤雨，令人目不暇接。这一年中，AI领域经历了众多的变革，仿佛将过去十几年的积累在一夜之间彻底释放。今天，我们将通过三条主线来盘点今年AI领域最重要的里程碑，并以此为契机，探索明年AI可能的发展方向。请各位小伙伴们务必点赞关注，以免错过精彩内容。
首先，我们来到了第一条线——语言模型线。简单来说，这是人工智能在聊天方面的应用。去年年底，一款名为ChatGPT的人工智能横空出世，上线短短五天就吸引了100万用户。仅仅两个月后，用户数量便突破了一个亿，创下了史上最快增长纪录。ChatGPT的成功得益于两个技术突破：一是通过人工调教，使其回答人类问题更加自然、不机械；二是发现了大模型的涌现现象。所谓涌现，是指当模型规模较小时并未出现某种能力，但当模型规模达到一定程度后，这种能力突然出现。例如上下文学习能力、思维链能力等。这种现象让大模型的智能水平得到了质的飞跃，仿佛从猴子进化成了人。有时候我也在想，人类意识的起源会不会也是一次进化的涌现呢？
二月Meta发布开源大模型Llama，三月智普发布了开源中文大模型ChatGLM！三月OpenAI发布了GPT4，至今最强模型诞生。三月份百度发布了文心一言，但当时仅能通过内测申请来提供服务。四月阿里发布通义千问模型，五月科大讯飞发布讯飞星火模型。此后，大模型百花齐放，但能力至今都还没有超越GPT4（此处接受反驳）。
九月GPT4V发布，让GPT有了眼睛,可以看图了。而变声模型vits和文本转语音TTS的发展，也让GPT有了耳朵和嘴巴。年底谷歌发布了多模态大模型Gemini，可以理解文字、图片、代码和音视频。大模型从语言开始卷多模态！但还没过年就被爆出Gemini训练数据疑似用了文心一言生成的数据。世界真的像个草台班子啊。
另一条围绕ChatGPT的支线是语言模型的应用生态系统。这条生态线不仅丰富多彩，而且充满了创新和变革。
在今年三月，OpenAI联合向量数据库厂商推出了插件体系，为ChatGPT增加了联网功能和代码解释器。这一创新引发了广泛的关注，使得向量数据库厂商成为了市场的宠儿。同时，也催生出了像langchain这样的语言模型框架，使得语言模型不再仅仅是一个简单的聊天工具。在这个生态系统中，语言模型被赋予了更多的功能。它们可以检索知识库、使用工具，甚至相互协作完成某一任务。这种智能体Agent的概念开始盛行，人们看到了语言模型在未来的巨大潜力。
故事总有但是，但是，在今年11月，OpenAI在开发者大会上宣布了GPT开始内建向量数据库，并内置了向量检索功能。同时，他们还发布了Assistants API，封装了Agent的各项能力。这一系列的举措无疑是对插件服务商的一次重击。好不容易被培养起来的用户，一把就被OpenAI给薅没了。在这个过程中，值得注意的是山姆奥特曼的命运转折。他先是离开了OpenAI，但又很快重新回归。这也反映了当下语言类大模型领域中各个公司和个人的命运起伏。
说完了语言模型线，今年AI发展的第二条主线是绘画线，也就是AI画图。
从AI绘画工具看，依旧是三分天下。Midjourney依旧是简单易用、高画质的代名词，今年从V4升级到了V5，现在马上要出V6，生成的图片也更加稳定自然，对于光影的把控简直令人发指。摄影师看了都直摇头，年初比较火的马斯克在苏联和钢铁侠炸油条系列就是Midjourney的作品。
然后是StableDiffusion以其免费、开源、可定制性的多样玩法，牢牢占据了三分天下有其一的地位。不仅各种插件层出不穷，光是各种Checkpoint和Lora模型都撑起了一个千万市值的C站，赛博朋克风格，二次元萌妹、机甲风、国风、甚至建筑图、Logo制作、头像制作等等等等，不管你喜欢什么画风，只需一个Lora，就能源源不断的生成图片。今年8月份妙鸭相机火出圈，其底层就是一个证件照风格的Lora，可以省下一大笔海马体照相馆的钱。而controlnet则是稳居SD插件榜首。
ControlNet是什么？通俗点来说，如果要画一幅画，一方面是构图，一方面是风格。ControlNet就是用来控制构图的，Checkpoint和LoRA模型就是用来控制风格的。
ControlNet可以控轮廓，控表情、控姿势、控景深，从各种角度控制画面的内容，所以大家要是想从事AI绘画那就必学ControlNet。
而底模方面，SD也从1.5升级到了SDXL，画质得到了巨大提升。
这AI绘画的最后一块版图，就是dalle了，dalle的定位有点尴尬，论画质卷不过midjourney,论可控性卷不过SD. 今年上半年一度已经淡出人们视野了。但随着dalle3的发布，画质又重回第一梯队，而下半年openai更是直接将dalle3的绘画能力集成到了ChatGPT当中,dalle重生了。目前dalle3的定位也是简单易用，而且还有成熟的API体系和语言模型的支持。
AI绘画的三国江湖明年将如何演变，我们拭目以待。但无论哪种工具，目前还都有一个致命的缺陷亟待解决，那就是生成的形象在前后画面中的不一致问题。现在很多商用的AIGC产品都卡在这一关，一旦突破，必将掀起新一轮的应用浪潮。想创业的明年可以重点关注在这条线。现在网上也有很多AI绘画的培训课程，入门版都不贵，大家可以先花小钱看看，确定了自己的方向和爱好之后，再深入研究。最后给想入门AI绘画的新人几个关键词：秋叶大佬、Nenly同学、WebUI、ComfyUI、liblib.ai。
今年AI发展的第三条主线是视频线。在这个领域，AI技术不断创新，为我们带来了诸多惊喜。
年初的so-vits项目成为了关注的焦点，它能够通过几个小时的音频，完美模拟出人的声音特点，实现了让机器模仿音色的目标。这项技术的实际使用在B站爆火的AI孙燕姿上得到了体现。通过对孙燕姿的专辑进行分离和声音提取，经过训练后，AI孙燕姿竟然能够唱周杰伦的歌，而且听起来非常动人。
除了so-vits项目，还有一项令人惊叹的技术是sad talker。它只需要给AI一张图片，经过训练后就能让图片开口说话，甚至还能眨眼。这种技术的出现让人感觉图片中的人物仿佛真的活了一样，今年的小和尚说话就是使用了sad talker技术。
Wav2Lip技术也值得一提。作为Deepfake领域的一把好手，它能够修改视频的唇形，实现生成的视频人物口型与输入语音同步。这种技术让视频中的人物口型与语音更加协调，增加了视频的真实感。
最近很火的叫Heygen的产品将多项技术整合在一起，让人物用自己的声音说出任何你想让他说的话。这款产品的原理是先分离视频中的音频，然后使用so-vits技术学习说话人的音色，接着将任何说话脚本或原文翻译成音频并赋予说话人的口音。最后，通过对口型技术对视频进行修改整合，实现让郭德纲说英语相声的效果。整个过程看起来非常和谐且流畅，让人感觉这段话就是视频中人物说的。
此外，还有一些其他值得关注的技术。例如，Meta开源的Whisper项目能够识别世界上大部分主要语言的视频语音；Roop和FaceFusion两款开源换脸软件不仅能直接给图片和视频换脸，还能将多张图片融合成一张脸；AnimateDiff能够将两张美女跳舞的不同动作图片转换成一段动画，也就是说给出视频关键帧，就可以生成一段视频。
年底时，SD团队发布了SVD模型，这个模型只需要几句描述文字就能让静态画面动起来。这一技术的出现给创意设计带来了更多可能性。
虽然这些技术给人们带来了诸多便利和创新体验，但我对此仍有些担忧。对于我们这些了解这些技术的人来说，真假难辨，更不用说普通人了。AI给了我们一把利剑，但我们也要思考如何防止坏人使用它。
回顾2023年AI领域的发展，我们见证了技术的飞速进步和广泛应用。面对未来，我们期待AI能更好地服务于人类，同时也希望各方共同努力，确保技术的发展与道德伦理相协调，为人类创造更加美好的未来。
2023年人工智能行业总结 - AI魔法学院
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/542c75de7dcfcab1e1fef057a0bbdc6f/" rel="bookmark">
			Kotlin基础语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kotlin基础语法 Kotlin内置数据类型变量可读可写变量可读变量 自动类型推导机制when表达式range表达式字符串模版函数函数定义函数简写默认参数具名函数参数Unit函数反引号函数匿名函数隐式返回函数作为形参函数引用函数作为返回值 可空性高级函数 let非空断言空合并操作符 高级函数apply函数run函数with函数also函数takeIf函数takeUnless函数 集合List可变List Set可变Set 数组Map可变Map 类主构造函数次构造函数lateinit 延迟初始化lazy 惰性初始化继承和重载companion objec 伴生对象内部类嵌套类数据类 运算符重载枚举类代数数据类型密封类接口抽象类泛型类vararg 动态参数协变&amp;逆变协变逆变 扩展函数单例模式饿汉式懒汉式懒汉式-加锁懒汉式-双重校验 Kotlin内置数据类型 名称释义String字符串char字符Boolean布尔型Int整型Float单精度浮点型Double双精度浮点型List集合Set无重复元素集合Map键值对集合 变量 可读可写变量 var name: String = "Kotlin" name = "C++" println(name) 可读变量 val name: String = "Kotlin" //下列变量不可修改，因为声明成val,只能进行读操作，不能进行写操作 //name = "C++" println(name) 自动类型推导机制 根据定义变量时进行初始化，系统可以根据初始化值自动进行类型推导，进而可以省略类型声明
val name = "Kotlin" //String val age = 5 //Int val sex = m' //char val score = 99.99 //Doble when表达式 val week = 5 val info = when(week){ 1-&gt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/542c75de7dcfcab1e1fef057a0bbdc6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0678dcead9746b5a7c027c8fc78c6460/" rel="bookmark">
			Fabric:使用GoLand&#43;Fabric-SDK-Go操作Fabric网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到bug, 未完待续!!!
写在最前 前序博客已经介绍了使用命令的方式在Fabric上创建通道以及部署执行链码的方法，但这个过程太繁琐，尤其是当Fabric网络中peer节点和组织Org过多时，需要频繁的更改环境变量。
Hyperledger Fabric官方提供了Fabric-sdk-go(也有针对其他语言的sdk)使开发人员能够与Fabric网络进行交互，并且可基于此构建区块链技术的应用程序。本篇博客主要介绍Fabric-sdk-go的简单使用。
基本环境 本机操作系统为MAC系统，和Fabric运行在虚拟机中。Fabric的具体运行环境为：
操作系统：Ubuntu 16.04
版本：Hyperledger Fabric: V2.5.4
1 GoLand连接虚拟机 要使用ssh方式连虚拟机之前，需要在两个系统上安装ssh服务。无论是在MAC上安装ssh，还是在Ubuntu系统上安装ssh，网络上资料都很多，这里不在赘述。
1.1 在MAC上使用ssh连接虚拟机 为了保证后续能顺利使用Goland连接虚拟机，这里先在MAC上使用ssh连接虚拟机。首先要保证本机系统上和虚拟机上的Ubuntu系统上的ssh服务都是开启状态。接着本机系统的终端上尝试连接虚拟机，具体指令如下：
ssh sherry@172.16.8.129 其中@前的部分为Ubuntu系统的用户名。@后面的ip地址可以在Ubuntu系统上通过ifconfig命令进行查询，具体如下：
上述命令运行成功之后，将可以在MAC的终端上操作Ubuntu系统。具体如下：
1.2 GoLand连接Fabric网络 1.2.1 启动Fabric网络 Fabric-sdk-go不能创建Fabric网络，所以Fabric网络的创建过程仍然在Ubuntu系统中来创建。为了简便，使用fabric-samples提供的测试网络test-network，其创建如下。
sudo ./network.sh up docker ps -a 其结果如下：
1.2.2 Goland连接Fabric网络 使用Goland连接Fabric网络需要完成以下几件事情：
Goland连接虚拟机。
在Goland中，打开Tools-&gt;Deployment-&gt;configuration进入Deployment界面，这里要新建一个SFTP部署。具体如下：
connecton
其中ssh configuration的配置界面如下：
在Goland中配置Fabric网络文件映射目录。
这里的Deployment path即为Ubuntu系统上Fabric网络的相对路径地址(根路径为/home/sherry)。而local path即为Deployment path中的文件在本地系统上的映射地址。
接着启动ssh连接。具体如下：
之后便可以在Goland中操作Ubuntu系统了。具体如下：
接着为了能在GoLand中修改链码及编写代码。先将Fabric网络中的文件映射到本地系统上。具体如下：
Tips:在文件同步时可能会出错，可以先在Ubuntu系统上更改Fabric网络文件的权限，再重新进行同步。
2 使用Fabri-SDK-GO操作网络 2.1 准备工作 在Ubuntu系统上搭建finance网络。具体搭建过程可以参考博客：https://blog.csdn.net/yeshang_lady/article/details/134113296修改Goland的ssh部署。将finance网络所在的Ubuntu目录映射到GoLand的Fabric_GOPATH目录上，并将finance网络的所有文件下载到Fabric_GOPATH目录上。准备链码文件。在Fabric_GOPATH上创建usersChaincode/chaincode目录来保存链码文件asset-transfer.go。asset-transfer.go文件参考博客：https://blog.csdn.net/yeshang_lady/article/details/134801201配置相关包。在Fabric_GOPATH/userChaincode/下执行如下代码(在GoLand-&gt;Terminal-&gt;local中执行)： go mod init vim go.mod #这里要修改go.mod文件，将go语言版本修改为1.21 go get github.com/hyperledger/fabric-contract-api-go/contractapi go get github.com/hyperledger/fabric-sdk-go GO111MODULE=on go mod vendor 为了保证Fabric-sdk-go的顺利执行，进入如下vendor/github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0678dcead9746b5a7c027c8fc78c6460/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a45ac9de0b7433cb279e2c5814180f8e/" rel="bookmark">
			【解决方式】远程目录共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		远程文件目录共享 前言使用windows搭建webdav文件服务器使用linux搭建httpd文件服务器windows挂载远程目录linux挂载远程目录 前言 ​ 在日常生活中我们难免会向别人分享一些自己收藏的珍贵学习资料，如果在同一网络情况下，我们使用windows自带的文件共享功能就可以实现。如果想要搭建自己的文件服务器向更多的朋友分享自己的学习资料，那你可能就需要我这个文章了；主要内容就是使用windows主机的webdav功能（SMB也可以）搭建私有文件服务器，使用Linux主机的httpd功能（ssh也可以）搭建私有文件服务器，windows主机挂载远程目录（webclient），linux主机挂载远程目录（sshfs、davfs）。
注：我的电脑是windows10系统、linux是麒麟3系统（其他Linux主机类似）
使用windows搭建webdav文件服务器 这样我们的文件服务器就搭建好了，鼠标右键点击网站-管理网站-启动
使用linux搭建httpd文件服务器 下载httpd，https://httpd.apache.org/download.cgi#apache24
上传到主机，解压 tar -zxvf httpd-2.4.58.tar.gz cd httpd-2.4.58 ./configure &amp;&amp; make &amp;&amp; make install
安装完成后，配置共享路径和用户名密码
注：ServerName 也需要配置为 ip:端口
windows挂载远程目录 设置 WebClient，允许 http 链接挂载
步骤1：
按下 “windows徽标键” + “R”，打开运行窗口，输入regedit，点击确定后，打开注册表编辑器窗口。
步骤2：
将路径定位到以下路径：计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WebClient\Parameters。双击右侧界面中的 BasicAuthLevel 条目，将数值数据修改为“2”，点击确定后关闭注册表编辑器。
步骤3：
按下 “windows徽标键” + “R”，打开运行窗口，输入services.msc，点击确定后，打开“服务”界面。找到 “WebClient”
服务，右键点击打开选项菜单，选择重新启动，稍等几秒，待完成后，关闭“服务”界面。
完成上述三个步骤后，WebClient 服务已经允许使用 http 协议进行挂载
linux挂载远程目录 下载安装包
davfs2 ：https://savannah.nongnu.org/projects/davfs2
neon：https://notroj.github.io/neon/
Neon安装
tar -zxvf neon-0.32.5.tar.gz cd neon-0.32.5 ./configure --with-ssl make &amp;&amp; make install Davfs2安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a45ac9de0b7433cb279e2c5814180f8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cedc92bca2bd7e27667fb8b1c91cbc0f/" rel="bookmark">
			Git 使用规范：起名字、提交描述的最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 推荐写法（本人常用） Git 仓库命令规则：
前端：系统名-简单描述-front后端：系统名-简单描述-server Git 提交描述：
docs(changelog): update change log to beta.5 其中： ● docs 则对应修改的类型 ● changelog 则是影响的范围 ● subject 则是对应做的事件 对应的类型有：
build：影响构建系统或外部依赖关系的更改（示例范围：gulp，broccoli，npm）ci：更改我们的持续集成文件和脚本（示例范围：Travis，Circle，BrowserStack，SauceLabs）docs：仅文档更改feat：一个新功能fix：修复错误perf：改进性能的代码更改refactor：代码更改，既不修复错误也不添加功能style：不影响代码含义的变化（空白，格式化，缺少分号等）test：添加缺失测试或更正现有测试 2. 工作写法 Git 提交描述：
一般公司会使用一些第三方工具，例如：Jira、Ones等，通过这些看板工具来管理团队的任务。每一个任务都会有对应的任务号。
因此，这个时候提交就会规范一点：
# 类似格式 如下： [任务卡号] xx &amp; xx: do something # 举个例子，Ones格式如下： #79612 描述内容 http://ones.xxx.com/project/#/team/HvBrmPic/task/GSCnZc5zd2dDgl8F 3. 常规写法 [任务分类] 主要修改组件（可选）：修改内容 示例 1，[T] tabs: add icons 。其中的 T 表示这是一个技术卡，tabs 表示修改的是 Tabs，add icons 则表示添加了图标。
示例 2，[SkillTree] detail: add link data。其中的 SkillTree 表示修改的是技能树 Tab 下的内容，detail 则表示修改的是详情页，add link data 则表示是添加了技能的数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cedc92bca2bd7e27667fb8b1c91cbc0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0b021a93a58e52eabc0d890ec94610b/" rel="bookmark">
			NAS上使用docker&#43;postgresql搭建私有云笔记joplin全终端适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前置条件步骤1：获取joplin的镜像步骤2：配置容器参数2.1 端口设置2.2环境变量设置（配置数据库） 步骤3. 启动服务端步骤4. 配置客户端4.1 下载客户端4.2 配置客户端同步 步骤5. 外网访问插件安装 通常我们都会用到印象笔记，有道云这类云笔记来记录学习和工作中的内容。但是有一说一，非会员的登录终端限制，导出格式限制以及笔记的总容量等等都是处处受限。所以找了一些开源笔记后，考虑对手机（安卓，ios），pc（win，linux）不同终端的跨平台同步，以及markdown的支持的友好程度下，对我而言joplin无疑是最优解。 Joplin不仅满足了这些基本要求，还提供了一些独特的优势支持强大的笔记加密功能，至少在公司的电脑上使用不会被恶意监听；丰富的插件生态基本可以有很多的自定义的空间。 前置条件 一个配置好的NAS设备，具备Docker支持。我这里使用的是极空间的NAS设备已经配置好的postgres数据库（其他数据库也行，初始化界面可以配置使用的数据库）已经配置好的nginx 步骤1：获取joplin的镜像 镜像仓库中搜索joplin/server
或者直接命令行拉取:docker pull joplin/server
步骤2：配置容器参数 获取镜像完成后，将镜像添加到容器中，需要设置端口, 挂载，以及部分环境变量
2.1 端口设置 joplin需要把笔记同步的端口22300映射出来
2.2环境变量设置（配置数据库） 我这里以pg为例，如果使用的其他的数据库可以参考官方文档给出的环境变量
注意先提前在Pg中创建好名称为joplin的数据库,或者任意名称均可，只要和环境变量重设置的POSTGRES_DATABASE的名称一致即可。然后在按照下图中的变量名依次配置pg的host, port,username和pasword
最后记得改时区
步骤3. 启动服务端 接下来在浏览器输入上一步重配置的环境变量APP_BASE_URL的值就能访问了。
服务端管理界面的默认管理员的登陆信息:
Email: admin@localhostPassword: admin
登陆后可以根据自己的需要去摸索一些配置了。至此，服务端我们就配置完成了。接下来去下载客户端让我们能够实现自己笔记的云端同步 步骤4. 配置客户端 4.1 下载客户端 PC端:下载址安卓/IOS端: 应用市场直接搜索即可 4.2 配置客户端同步 这里以PC端为例，手机端也是基本一样的界面。
打开PC端的joplin选择工具-选项
配置同步功能
同步目标需要选择Joplin Server，这样才能连上我们自己的私有服务器。
注意服务器URL必须填写APP_BASE_URL，如果配置了代理的话比如使用域名test.com 进行了反向代理，那么APP_BASE_URL也得配置成test.com，否则无法成功访问
步骤5. 外网访问 通过内网穿透将我们docker中的22300端口转发出去即可。唯一需要注意的是配置完成后需要将容器的APP_BASE_URL的配置修改成穿透到的公网地址。
插件安装 joplin也提供了很多插件，在github上可以看到，插件的安装方式也很简单。
选择插件，点击"浏览所有插件"就能跳转到github上的插件列表界面。下载插件包到本地安装插件，点击“从文件安装”选择刚刚下载到本地的插件即可安装成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f84d7b8dcad000ef1dc135b997552678/" rel="bookmark">
			python使用openpyxl操作excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前提读取已有excel创建一个excel工作簿对象创建excel工作簿中的工作表获取工作表第一种：.active 方法第二种：通过工作表名获取指定工作表​​​​​​第三种：.get_sheet_name() 修改工作表的名称数据操作写入数据按单元格写入通过指定坐标赋值方式，将数据写入单元格。按行写入数据 读取数据获取工作表中已有全部数据获取指定范围内的值 一个示例 前提 使用前需要先安装下这个模块
pip install openpyxl 读取已有excel 情况2：读取本地已存在的excel，用来后续进行读写等处理。
方法：load_workbook(已有excel文件路径)，如果路径中excel文件不存在，将会报错。​​​​​​​
from openpyxl import load_workbook # 读取已存在的excel工作薄 wb = load_workbook('excel_test.xlsx') 创建一个excel工作簿对象 进行读写、修改等操作前，需要创建一个可供操作的excel工作簿对象。
使用Workbook类，新建一个excel工作簿对象，用来后续进行读写等处理。​​​​​​​​​​​​​​
from openpyxl import Workbook # 新建一个excel工作簿对象 wb = Workbook() # 保存新建的excel工作簿 wb.save('excel_test.xlsx') （1）该类在新建excel工作簿的同时，也会新建了一个工作表（默认名为：Sheet）。（2）.save（保存路径）方法，对excel进行保存，写入或修改excel后，都需要保存。（3）如果当前保存路径下，已经有一个同名excel文件，不会提示且原文件被覆盖。 创建excel工作簿中的工作表 openpyxl提供了可自定义工作表的方法。
工作表，即是常见说法的【Sheet】。
创建自定义名称的工作表，语法如下：
Workbook.create_sheet(title,index) title：工作表的名称，可省略，系统自动命名（Sheet, Sheet1, Sheet2, ...）。 index：工作表的位置，可省略，默认插在工作表末尾，0表示插在第一个。​​​​​​ # 自定义工作表 ws1 = wb.create_sheet('test') ws2 = wb.create_sheet() # 保存 wb.save('excel_test.xlsx') 获取工作表 进行读写、修改数据等操作时，首先需要获取工作簿中的工作表（即Sheet），作为操作对象。
3种获取工作表的方法，如下：
第一种：.active 方法 默认获取工作簿的第一张工作表​​​​​​
# 获取第一张工作表 ws = wb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f84d7b8dcad000ef1dc135b997552678/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0de9a1fc8c7677aa045cbe3d5eaf979e/" rel="bookmark">
			​LeetCode解法汇总2706. 购买两块巧克力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录链接： 力扣编程题-解法汇总_分享+记录-CSDN博客 GitHub同步刷题项目： https://github.com/September26/java-algorithms
原题链接：力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台 描述： 给你一个整数数组 prices ，它表示一个商店里若干巧克力的价格。同时给你一个整数 money ，表示你一开始拥有的钱数。
你必须购买 恰好 两块巧克力，而且剩余的钱数必须是 非负数 。同时你想最小化购买两块巧克力的总花费。
请你返回在购买两块巧克力后，最多能剩下多少钱。如果购买任意两块巧克力都超过了你拥有的钱，请你返回 money 。注意剩余钱数必须是非负数。
示例 1：
输入：prices = [1,2,2], money = 3 输出：0 解释：分别购买价格为 1 和 2 的巧克力。你剩下 3 - 3 = 0 块钱。所以我们返回 0 。 示例 2：
输入：prices = [3,2,3], money = 3 输出：3 解释：购买任意 2 块巧克力都会超过你拥有的钱数，所以我们返回 3 。 提示：
2 &lt;= prices.length &lt;= 501 &lt;= prices[i] &lt;= 1001 &lt;= money &lt;= 100 解题思路： 代码： class Solution { public: int buyChoco(vector&lt;int&gt; &amp;prices, int money) { int minValue1 = 100; int minValue2 = 100; for (int i = 0; i &lt; prices.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0de9a1fc8c7677aa045cbe3d5eaf979e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4b7e28f6f1c526151a4d73cbf811ced/" rel="bookmark">
			java中JSONArray、List互相转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、JSONArray转List JSONArray字符串 转 List
1
2
3
4
5
6
7
8
9
//初始化JSONArray
JSONArray array=new JSONArray();
array.add(0,"a");
array.add(1,"b");
array.add(2,"c");
List&lt;String&gt; list = JSONObject.parseArray(array.toJSONString(),String.class);
System.out.println(list.toString());
输出结果：
[a, b, c]
JSONArray对象 转 List
1
2
3
4
5
6
7
8
//初始化JSONArray
JSONArray jsonArray = JSONArray.parseArray("[{\"name\":\"zhangsan\",\"age\":18},{\"name\":\"lisi\",\"age\":23}]");
//打印jsonArray
System.out.println(jsonArray.toJSONString());
//转List
List&lt;Body&gt; list = JSONArray.parseArray(jsonArray.toJSONString(), Body.class);
//打印List&lt;Body&gt;
System.out.println(list.toString());
Body.class代码：
1
2
3
4
5
6
7
8
9
10
11
12
13
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4b7e28f6f1c526151a4d73cbf811ced/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eb970f9cec521fe1802c6a3e44aa958/" rel="bookmark">
			solr的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
Solr是一个高度可伸缩、专注于信息检索的、能够处理海量信息的、以自然语言文本为中心的企业级搜索引擎。
它具备易于使用和配置、高性能、可伸缩性、支持多种数据源和查询方式等优点，但相对于Elasticsearch可能在处理小型数据集时稍显缓慢。
solr的核心特性
包括先进的全文搜索功能
基于标准的开放接口（通过XML、JSON和HTTP进行查询和获取结果）
高度可扩展和容错性（能够有效地复制到另一个Solr搜索服务器）
通过HTML页面管理以及灵活的插件体系
强大的数据导入功能，能够将数据库和其他结构化数据源导入、映射和转化。
在使用solr run进行单机运行时，可以通过命令行工具启动solr并指定相关参数。停止solr可以使用solr stop -all命令。
若需要下载solr7.6.0版本并创建新的core，可以按照以下步骤操作：
在/server/solr目录下创建一个新的文件夹，命名为newcore。
找到/server/solr/configsets/_default目录下的conf文件夹，并将其拷贝到/server/solr/newcore目录下。
接入数据库数据，并在solrconfig.xml文件中进行相应的配置。
中文分词
对于中文分词，Solr支持多种分词器，包括IK Analyzer、Jieba分词器和HanLP分词器等。在Solr中，可以通过配置fieldType来选择不同的分词器。例如，使用IK Analyzer作为分词器时，可以在schema.xml文件中添加以下配置：
&lt;fieldType name="text_general" class="solr.TextField" positionIncrementGap="100"&gt; &lt;analyzer&gt; &lt;tokenizer class="org.wltea.analyzer.lucene.IKTokenizerFactory" useSmart="true" conf="ik_synonym.txt"/&gt; &lt;/analyzer&gt; &lt;/fieldType&gt; 在使用同义词和停用词时，可以根据需求进行配置。例如，对于IK分词器，可以使用以下配置：
&lt;!-- ik分词器 --&gt; &lt;fieldType name="text_ik" class="solr.TextField"&gt; &lt;analyzer type="index"&gt; &lt;tokenizer class="org.wltea.analyzer.lucene.IKTokenizerFactory" useSmart="false" conf="ik.conf"/&gt; &lt;filter class="solr.LowerCaseFilterFactory"/&gt; &lt;filter class="solr.StopFilterFactory" words="stopwords.txt"/&gt; &lt;/analyzer&gt; &lt;analyzer type="query"&gt; &lt;tokenizer class="org.wltea.analyzer.lucene.IKTokenizerFactory" useSmart="true" conf="ik.conf"/&gt; &lt;filter class="solr.LowerCaseFilterFactory"/&gt; &lt;filter class="solr.StopFilterFactory" words="stopwords.txt"/&gt; &lt;/analyzer&gt; &lt;/fieldType&gt; SolrJ库
Solr还提供了Java API，使得开发人员可以使用Java语言编写Solr查询，从而简化了与Solr的交互过程，并提高了开发效率。通过使用SolrJ，开发人员可以轻松地构建、执行和管理Solr查询，同时还可以利用SolrJ提供的其他功能，如分页和排序等。
以下是使用示例：
import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5eb970f9cec521fe1802c6a3e44aa958/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90e5d9ee894336364cf6569d82a04b57/" rel="bookmark">
			java接口防抖的优雅处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口重复提交拦截的优雅处理可以通过以下几种方式实现：
使用Token机制：在用户提交请求时，服务器生成一个Token并返回给客户端。客户端在后续的请求中需要携带这个Token。服务器会检查每个请求中的Token是否与之前生成的Token相同，如果不同则认为是重复提交。这种方式可以有效防止重复提交，并且可以方便地实现取消操作。
使用时间戳机制：在用户提交请求时，服务器记录下当前的时间戳。在后续的请求中，服务器会检查每个请求中的时间戳是否与之前记录的时间戳相同，如果不同则认为是重复提交。这种方式简单易实现，但可能会受到客户端和服务器时间不一致的影响。
无论采用哪种方式，都需要在服务器端进行拦截和处理，以避免重复提交对系统性能和数据一致性造成影响。同时，还需要在前端进行相应的提示和处理，以提升用户体验。
今天我们要介绍的是接口以redis 键值判断的形式直接做防抖：
接口增加注解类ApiResubmit @Target({ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface ApiResubmit { /** * 限流前缀，用来区分不同的限流场景 */ String prefix() default ""; /** * 限流key，用来辨别是否是一次重复的请求，支持SpEL，可以从方法的入参中获取 */ String key() default ""; /** * 请求禁止秒数，即在多少秒内禁止重复请求 */ int forbidSeconds() default 10; /** * 限流提示信息 */ String message() default "请求过于频繁，请稍后再试"; } aop注解切面逻辑 @Slf4j @Aspect @Component public class ResubmitAspect { @Autowired private RedissonClient redissonClient; private static final String DEFAULT_BLOCKING_MESSAGE = "提交的频率过快，请稍后再试"; //切点 @Pointcut("@annotation(ApiResubmit)") public void resubmitPointcut() { } @Around(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90e5d9ee894336364cf6569d82a04b57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e85bf35a046ad8148490c60a26545d3/" rel="bookmark">
			ubuntu 编译内核报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 编译 Linux 内核经常会遇到如下错误：
如果报错 canonical-certs.pem：
如下：
make[1]: *** No rule to make target ‘debian/canonical-certs.pem’, needed by ‘certs/x509_certificate_list’. Stop.
make: *** [Makefile:1868: certs] Error 2
在命令行中执行：
scripts/config --disable SYSTEM_TRUSTED_KEYS
如果报错 canonical-revoked-certs.pem：
如下：
make[1]: *** No rule to make target ‘debian/canonical-revoked-certs.pem’, needed by ‘certs/x509_revocation_list’. Stop.
make: *** [Makefile:1868: certs] Error 2
在命令行中执行：
scripts/config --disable SYSTEM_REVOCATION_KEYS
参考
https://blog.csdn.net/m0_47696151/article/details/121574718
https://askubuntu.com/questions/1329538/compiling-the-kernel-5-11-11
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c49f53b4e3328cd32ee0593694a5e5a5/" rel="bookmark">
			API服务的快速搭建和测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		API服务的快速搭建和测试 使用Python的FastAPI迅速搭建一个简单API
from fastapi import FastAPI, Request from transformers import AutoTokenizer, AutoModel import uvicorn, json, datetime import torch # 设置CUDA设备信息 DEVICE = "cuda" DEVICE_ID = "0" CUDA_DEVICE = f"{DEVICE}:{DEVICE_ID}" if DEVICE_ID else DEVICE # 清理CUDA缓存的函数 def torch_gc(): if torch.cuda.is_available(): with torch.cuda.device(CUDA_DEVICE): torch.cuda.empty_cache() torch.cuda.ipc_collect() # 创建FastAPI应用 app = FastAPI() # 定义POST请求的处理函数 @app.post("/") async def create_item(request: Request): global model, tokenizer # 从请求中获取JSON数据 json_post_raw = await request.json() json_post = json.dumps(json_post_raw) json_post_list = json.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c49f53b4e3328cd32ee0593694a5e5a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef0f93c83e374876a61da0d4d16f36ab/" rel="bookmark">
			Django
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 安装CPython解释器下载Djangopytharm 方法命令方法 创建项目setting数据库时间设置静态文件设置 迁移项目 运行Django项目创建应用把应用加入管理界面站点的标题修改应用标题修改字段加入管理 增加证书一、使用Django-sslserver的方式二、使用自定义的证书1.如果需要https协议，需要以下3个库2.配置settings文件 在INSTALLED_APPS下添加3. 在终端使用命令运行选用哪种证书 django字段AutoField：BooleanField：CharField：TextField：CommaSeparatedIntegerField：DateField：DateTimeField：EmailField：FileField：FilePathField：FloatField：ImageField：IntegerField：IPAddressField：NullBooleanField：PhoneNumberField：PositiveIntegerField：PositiveSmallIntegerField：SlugField：SmallIntegerField：TimeField：URLField：USStateField：XMLField：附：Field 选项 模块中字段使用获取外键的值显示外键的值related_name反向查询增加中文标识增加选择项增加筛选项 增加富文本字段安装tinymce基本配置修改配置实现图片上传图片上传的问题 orm使用mysql安装MySQL配置默认编码为utf8创建mysql数据库pycharm上安装pymysqlDjango项目设置默认数据库为mysql 模型数据迁移创建超级用户创建用户修改用户密码 导入一个已存在的项目删除原有配置信息修改数据库连接处取消终端窗口高亮显示 重建数据库记录更粗暴的方法 请求方法python开发的CBV和FBV跨站请求问题安装django-cors-headers配置settings.pyCORS_ORIGIN_ALLOW_ALL:CORS_ORIGIN_WHITELIST:CORS_ORIGIN_REGEX_WHITELIST:CORS_URLS_REGEX:CORS_ALLOW_METHODS:CORS_ALLOW_HEADERS:CORS_EXPOSE_HEADERS:CORS_PREFLIGHT_MAX_AGE:CORS_ALLOW_CREDENTIALS:CSRF整合CORS_REPLACE_HTTPS_REFERER 其他问题DEFAULT_AUTO_FIELD warnings报错：Forbidden (CSRF cookie not set.) 安装CPython解释器 可参考我的博文
https://blog.csdn.net/gsl371/article/details/120148727
下载Django pytharm 方法 注意：如果是用pycharm开发，并且使用虚拟环境，这一步掠过。
可在pycharm中直接创建虚拟环境，项目和应用。
如下：
然后在虚拟环境中使用pip安装需要的模块。
命令方法 打开管理员命令窗口
指定版本为1.11.28，指定源为清华源
pip install django==1.11.28 -i https://pypi.tuna.tsinghua.edu.cn/simple 查看
C:\Users\gsl&gt;pip list Package Version ---------- ------- Django 1.11.28 pip 21.0.1 pytz 2021.1 setuptools 28.8.0 C:\Users\gsl&gt;django-admin Type 'django-admin help &lt;subcommand&gt;' for help on a specific subcommand. Available subcommands: [django] check compilemessages createcachetable dbshell diffsettings dumpdata flush inspectdb loaddata makemessages makemigrations migrate runserver sendtestemail shell showmigrations sqlflush sqlmigrate sqlsequencereset squashmigrations startapp startproject test testserver Note that only Django core commands are listed as settings are not properly configured (error: Requested setting INSTALLED_APPS, but settings are not configured.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef0f93c83e374876a61da0d4d16f36ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76ad0d2ecc3232cbf3daf494b2757ffd/" rel="bookmark">
			Linux 安装Jupyter notebook 并开启远程访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 安装Python安装pip安装Jupyter启动Jupyter Notebook1. 生成配置文件2. 创建密码3. 修改jupyter notebook的配置文件4. 启动jupyter notebook5. 远程访问jupyter notebook 安装Python 确保你的系统上已经安装了Python。大多数Linux发行版都预装了Python。你可以在终端中运行以下命令来检查是否已安装：
python --version python3 --version Jupyter目前更倾向于与Python 3.x 版本一起使用。因此，我建议你安装Python 3.x，并使用该版本来安装和运行Jupyter。
sudo yum update sudo yum install python3 安装pip pip是Python的包管理工具，用于安装和管理Python库。在终端中运行以下命令来安装pip：
sudo yum install python3-pip 安装Jupyter 使用pip安装Jupyter。运行以下命令：
# 更新pip3到最新版本 pip3 install --upgrade pip # pip安装jupyter notebook pip3 install jupyter 这一步执行较慢，可以等会儿。
把jupyter添加到环境变量。
# 显示jupyter所在目录 ~ pip3 show jupyter Location: /usr/local/lib/python3.6/site-packages 把Jupyter添加到环境变量
查找Jupyter的安装位置:
查找Jupyter可执行文件的安装位置。你可以使用以下命令找到：
find / -name jupyter 上述命令可能需要一些时间，因为它会搜索整个文件系统。找到类似/usr/local/bin/jupyter的路径。
将Jupyter路径添加到PATH:
打开你的bash配置文件，通常是~/.bashrc或~/.bash_profile。使用文本编辑器打开该文件：
vi ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76ad0d2ecc3232cbf3daf494b2757ffd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7c5d1bfb1987d6262db8ce8a7aa1f20/" rel="bookmark">
			再见2023，你好2024（附新年烟花python实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		亲爱的朋友们：
写点什么呢，我已经停更两个月了。2023年快结束了，时间真的过得好快，总要写点什么留下纪念吧。这一年伴随着许多挑战和机会，给了我无数的成长和体验。坦白说，有时候我觉得自己好像是在时间的漩涡中被席卷着，努力地追逐着每一个梦想，却又无法把握住每一刻的风景。
这两个月的停更让我重新审视了自己的生活和选择。我意识到，我需要给自己留出一些时间来回首过去，反思成长，并重新调整自己的目标与方向。停下脚步，也不意味着停止前进，而是为了更好地迎接未来的挑战。
在这段停更的时间里，我为自己提出了一些问题：我真正追求的是什么？我为什么会开始这个旅程？曾经的热情和动力是否还在？而答案，从内心深处浮现：记录知识，不让自己忘记来时的路，生活总要有迹可循吧。
回顾这一年，我经历了许多学习和探索的时刻。尽管有时候面临着困难和挫折，但是每一次克服困难的过程都让我更加坚定了自己的决心。在每一个成功的背后，都蕴藏着无数的努力和坚持。
正因为有了你们的陪伴和支持，我才能够坚定地走到今天。你们的鼓励和反馈是我前进的动力，是我坚持不断学习和成长的源泉。感谢你们，你们的真情实感是我前行路上最美丽的风景。
我知道，未来的道路依然会有风雨和坎坷，但这不会阻止我努力前行。我将继续努力，保持初心，并且永远保持对知识的渴望和求索。
2023年的最后时刻，我希望你们也能找到属于自己的答案，找到自己激情的源泉。无论是过去的成就还是未来的挑战，都是值得被铭记的一部分，让我们珍惜每一次成长的机会。
谢谢你们一直以来的陪伴，愿我们在新的一年里继续同行，共同为更美好的未来努力！
最诚挚的祝福
Dr.sky
新年福利：基于python的电子烟花实现 import pygame as pg import random as ra import math pg.init() pg.display.set_caption("🎇") winScreen = pg.display.Info() screenWidth = winScreen.current_w screenHeight = winScreen.current_h vector = pg.math.Vector2 trail_colors = [(45, 45, 45), (60, 60, 60), (75, 75, 75), (125, 125, 125), (150, 150, 150)] # 烟花类 class Firework: def __init__(self): # 随机生成颜色 self.colour = (ra.randint(0, 255), ra.randint(0, 255), ra.randint(0, 255)) # 随机生成三种颜色 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7c5d1bfb1987d6262db8ce8a7aa1f20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/307401b407d0f4ae31b87e41b72c5717/" rel="bookmark">
			日期选择器：The value/defaultValue of DatePicker or MonthPicker must be a moment object after `antd@2.0`
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 真是日了狗了
目前在做一个后台管理的项目，祖传代码，React+ts+antd
一个后台管理用vue多好
这还算了，用的antd的版本是3.xxx,现在官网都更新到5.xx的版本了
喔一开始接手项目的时候，我就先升级了下antd
好家伙，一堆报错，这怎么敢改，没那么多时间
于是干净回退到3.xx的版本，版本差异还是很大的
现在遇到的问题是，一个日期选择器，增加数据的时候，就是直接选择，编辑、查看数据的时候，就要给日期选择器直接赋值，后端返回的数据格式是 2023-12-29。这样的，报错了：
翻译：DatePicker或MonthPicker的值/defaultValue必须是’ antd@2.0 '后面的moment对象
datepicker只支持moment类型，表单获取数据是string类型引起报错
解决方法 安装moment
npm i moment --save-dev import moment from 'moment' this.props.getFundNoticeDetail(record.id).then(res =&gt; { if (res.code === 0) { const reportDateMoment = moment(res.data.reportDate, 'YYYY-MM-DD') this.setState({ rowData: { ...res.data, reportDate: reportDateMoment }, modalVisible: true, onlyRead: true, title: '查看基金公告', }) } }) 不能直接赋值为字符串，要用moment包一下
好，我以为到这就好了，没想到喔测试下
赋值是好了的 特么现在选择日期的时候又不行了
原代码是这样：
修改为：
完事！！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/768f2adb2a46696e6b2e920478418440/" rel="bookmark">
			[代码管理]git push包含大文件导致push失败的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题记录 我有一个自己做的小项目, 之前只用了本地仓库, 现在想关联远程仓库, 把代码推送上去, 方便我另一台电脑也可以随时参与.
我本地仓库的代码迭代了许多版本, 其中从某个版本开始, commit的代码版本包含一个大文件(180M左右).
关联远程仓库以后, 我想把最新的版本push上去, 出现了下面的问题:
报错显示:File asd is 186.83MB, this exceeds GitHub's file size limit of 100.MB
即有一个名为asd的文件超过了github允许的100MB的文件大小限制, 导致无法push成功.
2.解决方案 因为git push会把本地仓库的历史版本全部push到github, 所以不能有包含大文件的历史版本.
找到之前提交过的, 没有这个大文件的版本(版本a), 而当前最新的版本为b
用git reset回退到版本a, 此时暂存区重置为版本a, 工作区依然保持版本b
git reset version_a 然后删除工作区的大文件(或者暂时移动到别处)后, 重新添加工作区代码到暂存区, 并且提交为新的版本(版本c)
git add . git commit -m "new version" 当前版本的变化过程如下:
这个时候历史代码版本的变化情况如下(可以通过git log查看),
可见, 之前中间的那些包含大文件的版本都没有了, 如果想回到这些版本, 可以用git reflog命令查看, 再git reset回去.
经过以上操作, 本地仓库的最新版本代码已经没有大文件了, 所以此时可将本地所有历史版本(这里指git log显示的版本)全部推送到github上.
3.踩坑记录 1.用git rm删除本地repo的大文件, 然后push失败. 因为其他历史版本中还有包含大文件的, 必须处理掉这些版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/768f2adb2a46696e6b2e920478418440/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae869f4df9018d84b5046ee07c99f2f4/" rel="bookmark">
			Kubernetes弃用Dockershim，转向Containerd：影响及如何应对
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes1.24 版本发布时，正式宣布弃用 Dockershim，转向 Containerd 作为默认的容器运行环境。Kubernetes 以 CRI(Container Runtime Interface) 容器运行时接口制定接入准则，用户可以使用 Containerd、CRI-O、CRI- Dockerd 及其他容器运行时作为 Kubernetes 的容器引擎。
Kubernetes 为何弃用 Dockershim？ Docker 在早期没有实现 Container Runtime Interface (CRI)，而 CRI 是 Kubernetes 后来增加的对额外运行时的支持标准。Dockershim 的存在是为了支持将 Docker 硬编码到 Kubernetes 中，但随着容器化成为行业标准，Kubernetes 项目增加了对额外运行时的支持，比如通过 Container Runtime Interface (CRI) 容器运行时接口来支持运行容器。因此，在 Kubernetes1.20 版本发布的时候提到未来会弃用 Dockershim 引擎，而在 Kubernetes1.24 版本发布时， 正式弃用之。
什么是 Containerd ？ containerd 是一种容器运行时引擎，原属于 Docker 的组件的一部分，主要提供容器生命周期管理（从创建到销毁容器）、拉取和推送镜像、存储管理（管理镜像及容器数据的存储）、调用 runc 容器运行等，现已由开源社区拆分脱离出来单独作为容器运行时项目。
在 Kubernetes 中，Containerd 作为容器运行环境，负责管理 Pod 的生命周期，包括容器的创建、启动、停止和删除等操作。与 Dockershim 相比，Containerd 具有更好的性能、更强的可扩展性以及更简洁的架构。
容器运行底层组件有哪些关系？ Docker Client 和 Docker Daemon：Docker Client 是 Docker 的客户端，它可以通过命令行或 API 向 Docker Daemon 发送请求。Docker Daemon 是 Docker 的核心组件，负责管理镜像、容器、网络和卷等资源，并将 Docker API 暴露给客户端。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae869f4df9018d84b5046ee07c99f2f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eaae73152e829a045bcf7c9c02fe8bd/" rel="bookmark">
			阿里终面：10亿数据如何快速插入MySQL？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最快的速度把 10 亿条数据导入到数据库，首先需要和面试官明确一下，10 亿条数据什么形式存在哪里，每条数据多大，是否有序导入，是否不能重复，数据库是否是 MySQL？
假设和面试官明确后，有如下约束
10 亿条数据，每条数据 1 Kb
数据内容是非结构化的用户访问日志，需要解析后写入到数据库
数据存放在Hdfs 或 S3 分布式文件存储里
10 亿条数据并不是 1 个大文件，而是被近似切分为 100 个文件，后缀标记顺序
要求有序导入，尽量不重复
数据库是 MySQL
首先考虑 10 亿数据写到 MySQL 单表可行吗？
数据库单表能支持 10 亿吗？ 答案是不能，单表推荐的值是 2000W 以下。这个值怎么计算出来的呢？
MySQL 索引数据结构是 B + 树，全量数据存储在主键索引，也就是聚簇索引的叶子结点上。B + 树插入和查询的性能和 B + 树层数直接相关，2000W 以下是 3 层索引，而 2000w 以上则可能为四层索引。
Mysql b+索引的叶子节点每页大小 16K。当前每条数据正好 1K，所以简单理解为每个叶子节点存储 16 条数据。b + 索引每个非叶子节点大小也是 16K，但是其只需要存储主键和指向叶子节点的指针，我们假设主键的类型是 BigInt，长度为 8 字节，而指针大小在 InnoDB 中设置为 6 字节，这样一共 14 字节，这样一个非叶子节点可以存储 16 * 1024/14=1170。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2eaae73152e829a045bcf7c9c02fe8bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e4d84450e3a99a82b3c728004b1a69b/" rel="bookmark">
			css&#43;js实现鼠标移动边框高亮效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：效果是鼠标移入空白区域，边框高亮的效果。效果是在douyin的渡一教育袁老师的课程学习到的，观看以后是一个实用的小特效。想看的可以平台查询，自己也学到了知识。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body { background: #000; } .card-wrap { display: grid; margin: 0 auto; width: 90%; margin-top: 1em; color: #f0f0f0; grid-template-columns: repeat(3, 1fr); gap: 20px; text-align: center; } .card { aspect-ratio: 4/3; border-radius: 8px; background-color: rgba(255, 255, 255, .1); position: relative; overflow: hidden; } .card .inner { position: absolute; inset: 2px; background-color: #222; border-radius: inherit; display: flex; align-items: center; justify-content: center; z-index: 3; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e4d84450e3a99a82b3c728004b1a69b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e42f500461ae8481c4739bd487e278c5/" rel="bookmark">
			QT 中的元对象系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在分析 QT 中的元对象系统之前，我们先回顾一下 C++ 中的 RTTI 机制。
C++的RTTI机制 RTTI 是 Runtime Type Identification 的缩写，字面意思是运行时类型识别。C++引入这个机制是为了让程序在运行时能根据基类的指针或引用来获得该指针或引用所指的对象的实际类型。
本文福利，莬费领取Qt开发学习资料包、技术视频，内容包括（Qt实战项目视频教程+代码，C++语言基础，C++设计模式，Qt编程入门，QT信号与槽机制，QT界面开发-图像绘制，QT网络，QT数据库编程，QT项目实战，QSS，OpenCV，Quick模块，面试题等等）↓↓↓↓↓↓见下面↓↓文章底部点击莬费领取↓↓
为什么需要在运行时根据基类的指针或引用来获得实际所指对象的类型呢？这又牵扯到面向对象编程中的多态。
C++ 中的多态是指通过一个基类指针或引用调用一个虚函数时，会根据具体对象的类型来调用该虚函数的不同实现。这样可以实现对象间的通信和转换，以及多态的行为和表现。举个例子：
#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; class Animal { public: virtual void speak() = 0; // pure virtual function }; class Cat : public Animal { public: void speak() override { cout &lt;&lt; "Meow" &lt;&lt; endl; } }; class Dog : public Animal { public: void speak() override { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e42f500461ae8481c4739bd487e278c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0716033dd76d074c0c9d22869086d91c/" rel="bookmark">
			视觉学习笔记12——百度飞浆框架的PaddleOCR 安装、标注、训练、测试以及onnx转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 虚拟环境部署
参考博客1
参考博客2
参考博客3
参考博客4
参考博客5
参考博客6
文章目录 系列文章目录一、简单介绍1.OCR介绍2.PaddleOCR介绍 二、安装1.anaconda基础环境1）anaconda的基本操作2）搭建飞浆的基础环境 2.安装paddlepaddle-gpu版本1）安装2）验证 3.pip安装paddleocr whl包1）2.6版本的paddleocr安装2）验证 4.安装PPOCRLabel1）2.6版本paddleocr和PPOCRLabel的版本对应2）2.7版本paddleocr和PPOCRLabel的版本对应 三、PPOCRLabel标注四、PaddleOCR训练与测试1.文本检测模型训练与测试1）下载预训练模型2）修改参数配置文件3）可视化训练过程4）模型评估测试 2.文本识别模型训练1）下载预训练模型2）修改参数配置文件3）可视化训练过程4）模型评估测试 五、Paddle转换onnx1.依赖1.paddle模型转inference模型1）方法一：2）方法二： 2.inference模型转onnx模型1）转文本检测模型2）转文本识别模型3）修改ir_version版本4）测试onnx模型 六、补充 一、简单介绍 1.OCR介绍 OCR（光学字符识别）是一种将图像中的文字自动转换为可编辑文本的技术。现在，各大厂商均有提供各种场景的OCR识别的API。但是，也有一些开源的OCR框架和工具，可以支持自我定制和训练，使得开发人员能够更加灵活地应对不同场景下的OCR需求。
OCR（光学字符识别）的简单实现流程通常包括以下步骤：
1、图像预处理：首先，对输入的图像进行预处理，包括灰度化、二值化、去噪等操作。这些操作有助于提高字符识别的准确性和稳定性。
2、文本区域检测：使用图像处理技术（如边缘检测、轮廓分析等），找到图像中可能包含文本的区域。这些区域通常是字符或文本行的边界。
3、字符分割：对于文本行，需要将其分割为单个字符。这可以通过字符之间的间距、连通性等特征进行分割。
4、特征提取：对于每个字符，提取其特征表示。常见的特征包括形状、角度、纹理等。特征提取有助于将字符转化为可供分类器处理的数值表示。
5、字符分类：使用分类器（如机器学习算法或深度学习模型）对提取的字符特征进行分类，将其识别为相应的字符类别。分类器可以是预训练模型，也可以是自定义训练的模型。
6、后处理：对识别的字符进行后处理，如纠正错误、校正倾斜、去除冗余等。这可以提高最终结果的准确性和可读性。
7、输出结果：将识别的字符组合成最终的文本输出，可以是单个字符、单词或完整的文本。
2.PaddleOCR介绍 飞桨首次开源文字识别模型套件PaddleOCR，目标是打造丰富、领先、实用的文本识别模型/工具库。 PaddleOCR是一个基于飞桨开发的OCR（Optical Character Recognition，光学字符识别）系统。其技术体系包括文字检测、文字识别、文本方向检测和图像处理等模块。以下是其优点：
高精度：PaddleOCR采用深度学习算法进行训练，可以在不同场景下实现高精度的文字检测和文字识别。
多语种支持：PaddleOCR支持多种语言的文字识别，包括中文、英文、日语、韩语等。同时，它还支持多种不同文字类型的识别，如手写字、印刷体、表格等。
高效性：PaddleOCR的训练和推理过程都采用了高效的并行计算方法，可大幅提高处理速度。同时，其轻量化设计也使得PaddleOCR能够在移动设备上进行部署，适用于各种场景的应用。
易用性：PaddleOCR提供了丰富的API接口和文档说明，用户可以快速进行模型集成和部署，实现自定义的OCR功能。同时，其开源代码也为用户提供了更好的灵活性和可扩展性。
鲁棒性：PaddleOCR采用了多种数据增强技术和模型融合策略，能够有效地应对图像噪声、光照变化等干扰因素，并提高模型的鲁棒性和稳定性。
总之，PaddleOCR具有高精度、高效性、易用性和鲁棒性等优点，为用户提供了一个强大的OCR解决方案。
对比其他开源的OCR项目：
优点：
轻量模型，执行速度快
支持pip直接安装
ocr识别效果好，效果基本可以比肩大厂收费ocr（非高精版）
支持表格和方向识别
支持补充训练且很方便
缺点：
部分符号识别效果一般，如 '|‘识别为’1’
对于部分加粗字体可能出现误识别，需要自己补充训练
偶尔会出现部分内容丢失的情况
二、安装 1.anaconda基础环境 1）anaconda的基本操作 查看conda环境： conda info --envs 创建虚拟环境 conda create -n your_env_name python=x.x 激活或者切换虚拟环境 source activate your_env_nam 查看虚拟环境中的库 conda list 关闭虚拟环境 source deactivate 删除虚拟环境 conda remove -n your_env_name --all 2）搭建飞浆的基础环境 因为是新项目，所以专门使用anaconda搭建该项目的基本环境
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0716033dd76d074c0c9d22869086d91c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/719ad85529ea150e58fc3cf8d2fb0ce5/" rel="bookmark">
			基于AIxBoard打造Rosmart AI质检一体机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 作者：伍增、邓书梦
一、AI检质一体机简介： 英特尔开发者套件AIxBoard是一款IA架构的人工智能嵌入式开发板，体积小巧功能强大。借助OpenVINOTM工具套件，CPU和iGPU都具备较为理想的AI推理能力。我司将AIxBoard与触摸屏及自研的AI视觉软件集成在一起，做成了Rosmart AI质检一体机，实物图如下所示。
Rosmart AI质检一体机所具备部分自研算法已发表如下：
基于 OpenVINO™ 打造一站式光学字符识别 &amp; 检测大师（OCR-Master）
英特尔开发者套件 + OpenVINO™ (Anomalib)搭建 AI 缺陷检测开发环境
荣旭智能基于 Anomalib 打造智能光学字符瑕疵检测系统
二、AI质检一体机优点： 1.更高性能
a.自研AI质检模型+OpenVINO推理加速技术，检出效率高
b.图形化无代码开发环境，大幅缩短开发调试时间
2.更高可靠性
a.多通道光源，RGB分时取像，多线程并行处理
b.自主开发控制系统，在产线上经过上万套的部署打磨，既高效又可靠
3.数据统计实时控制
a.数据实时记录分析，为工艺改进提供客观依据，并实时追溯，生成统计报表
b.可通过中央控制服务器收集所有机台的测试信息，便于生产的综合管理
三、AI质检一体机常见应用场景： 应用场景A：聚焦旧机改造，即专注传统工厂自动化设备的智能化升级改造。可快速落地医疗药剂胶囊颗粒计数功能，实现字符识别、标签识别及瓶身外观不良、包装袋表面印字缺陷、气泡等外观瑕疵。
应用场景B：聚焦AI智能化分选。跟振动盘或柔性振动盘结合，打造AI智能化分选，应用于连接器、电子、医疗、汽车、包装、五金、食品等行业，为智能制造助力。
四、实际落地案例： 下图Rosmart工业AI质检一体机用于变压器磁芯瑕疵检测的实际落地案例，客户反馈检测准、速度快、换型容易。
下图是Rosmart AI质检一体机实际运行视频Alex_1220_基于AIxBoard打造Rosmart AI质检一体机-CSDN直播
五、总结：
基于英特尔开发者套件AIxBoard、自研AI工业质检程序和OpenVINO打造的AI工业质检一体机，能较好的满足传统自动化设备智能化升级改造的需求，也能方便快速的跟振动盘一起打造AI智能分选机，帮助客户多快好省的解决产品质检问题。
广东荣旭智能技术有限公司官网：视觉检测设备-CCD视觉检测-外观缺陷检测设备-广东荣旭机器视觉外观检测解决方案
作者邮件：kelvin.wu@gdrosmart.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/051069f8e08ba8a2e89dfb3658211448/" rel="bookmark">
			深入了解小红书笔记详情API：为内容创新提供动力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、小红书笔记详情API简介
小红书笔记详情API是一种允许开发者访问小红书平台上的笔记详细数据的接口。通过这个API，我们可以获取笔记的标题、内容、标签、点赞数、评论数等详细信息。这些数据对于内容创作者和品牌来说至关重要，可以帮助他们了解用户喜好、竞品动态以及热门话题。
二、如何利用API获取笔记数据
安装必要的工具和库：首先，您需要使用Python等编程语言，并安装requests等库来发送HTTP请求。定义API接口地址和请求参数：在开始之前，您需要了解API的地址和所需的请求参数，如API密钥、请求的URL等。发送请求并处理响应：使用定义的请求参数向API发送请求，并处理返回的JSON格式数据。解析数据：使用Python等语言解析返回的数据，提取所需的笔记信息。 示例代码（Python）：
import requests import json url = "https://api.xiaohongshu.com/v4/graphql" # API接口地址 headers = { "Authorization": "Bearer YOUR_ACCESS_TOKEN" # 定义请求头信息 } query = """ { page(channel:"笔记", page:1, size:20){ totalCount, list{ id, title, content, authorId, tags, likes{ totalCount }, comments{ totalCount } } } } """ # 定义查询参数 response = requests.post(url, headers=headers, data={"query": query}) # 发送请求 data = response.json()["data"]["page"]["list"] # 解析返回的数据 for note in data: print(f"笔记ID: {note['id']}, 标题: {note['title']}, 内容: {note['content'][:100]}.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/051069f8e08ba8a2e89dfb3658211448/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/45/">«</a>
	<span class="pagination__item pagination__item--current">46/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/47/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>