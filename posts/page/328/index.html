<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/582b7e1c81e617ca915b4f1fca5be306/" rel="bookmark">
			VBA从其他软件中复制数据到Excel中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在工作中，有时候会用到其他的数据，但是这些的软件不能直接调用，也不能导出数据，需要手动一个个的Ctrl+C,Ctrl+V，数据量大的时候，就比较繁琐，也占用了大量的时间，
正好会VBA，就用VBA来继续制作一个简单的ＲＰＡ。
目的：
使用ＶＢＡ通过sendkeys复制其他软件的信息，将内容复制粘贴到Excel中
操作方法：
VBA调用Sendkeys.
上代码：
Private Sub CommandButton1_Click() On Error Resume Next Dim count_row Dim MyData As DataObject Dim count_G '最开始的时候，避免异常，停留1s。 Application.Wait Now + TimeValue("00:00:01") ThisWorkbook.Activate count_n = Range("C1").Value ‘如果没有数据，则默认执行100次 If TextBox1.Value = "" Then count_n = 100 Else count_n = TextBox1.Value End If ’使用热键 “Alt + TAB” 进行运行程序的切换 SendKeys "%{TAB}" For I = 1 To count_n If I = 1 Then Application.Wait Now + TimeValue("00:00:02")‘初始的时候避免异常，有个等待时间 Else SendKeys "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/582b7e1c81e617ca915b4f1fca5be306/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb4bcdb54f77b451fe54b549c8541e04/" rel="bookmark">
			C#web服务开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Program.cs声明程序入口static main()函数，用startup内方法创建和初始化web类对象
Startup.cs初始化内容，涉及路由设计和服务绑定、依赖注入等全局初始化，实现主要两个配置初始化方法
// This method gets called by the runtime. Use this method to add services to the container.
public void ConfigureServices(IServiceCollection services)
和
// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
2、web服务添加
IServiceCollection services services.AddSingleton();//方法创建一个Singleton服务，首次请求会创建服务，然后，所有后续的请求中都会使用相同的实例，整个应用程序生命周期都使用该单个实例 services.AddScoped();//不同http清求，实例不同，同名谓词不同，也不行。例如httpget跟httppost,作用域是一定范围内，例如从同一个post请求的create方法，只能统计一次，每次请求都是新的实例 services.AddTransient();//临时服务，每次请求时，都会创建一个新的Transient服务实例 services.AddControllersWithViews(option =&gt; { option.Filters.Add&lt;AuthorizationFilter&gt;(); }).AddNewtonsoftJson();//添加MVC框架服务，绑定过滤认证信息方法，绑定json格式输入输出 services.AddSwaggerGen(options =&gt; { options.SwaggerDoc("v1", new OpenApiInfo { Version = "v1", Title = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb4bcdb54f77b451fe54b549c8541e04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3156ba2ce471f83cb8e4c3e97f3efc11/" rel="bookmark">
			Tomcat Diffie-Hellman密钥交换不足DH组强度漏洞修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Tomcat
In the server.xml file (for JSSE)
Cipher Suites
&lt;Connector ciphers="TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,TLS_DHE_DSS_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_128_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_SHA256,TLS_ECDHE_RSA_WITH_AES_128_SHA,TLS_ECDHE_ECDSA_WITH_AES_128_SHA,TLS_ECDHE_RSA_WITH_AES_256_SHA384,TLS_ECDHE_ECDSA_WITH_AES_256_SHA384,TLS_ECDHE_RSA_WITH_AES_256_SHA,TLS_ECDHE_ECDSA_WITH_AES_256_SHA,TLS_DHE_RSA_WITH_AES_128_SHA256,TLS_DHE_RSA_WITH_AES_128_SHA,TLS_DHE_DSS_WITH_AES_128_SHA256,TLS_DHE_RSA_WITH_AES_256_SHA256,TLS_DHE_DSS_WITH_AES_256_SHA,TLS_DHE_RSA_WITH_AES_256_SHA" /&gt; Note: To be able to use the 256 bit AES Ciphers, it is necessary to install the JCE Unlimited Strength Jurisdiction Policy Files, which can be found here.
原文地址：https://weakdh.org/sysadmin.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61c910d6013c5b42f0c8af5544425afe/" rel="bookmark">
			xmind怎么在左边创建_XMind位置调整的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：XMind位置调整的方法
启动IMindMap，点击“文件”--&gt;"新建",然后在右侧的面板中双击“空白文档”，会开始创建一个新的思维导图。
双击“空白文档”后，首先出现的时“中心主题”图片选择框，拖动位置1的滚动条可以查看更多的主题图片，单击选择一个主题图，然后单击“选择“按钮
现在你刚选择的图片显示在主面板的中央，光标在图片中心闪烁，表示可以输入文本，输入你的主题的关键字。我在这里输入的是”余额支出表结构“。
单击选中你的中心主题，依次单击菜单栏上的”插入“---&gt;"框型分支"下的箭头---&gt;”新建子级“就创建了一个分支。
在分支框输入分支的关键词和说明：如”oper_income_id:唯一主键“，然后单击选中分支框或者分支框上曲线，在分支线上回出现两个小篮圈，图中位置1和2,在分支框的四角会出现四个小蓝块
将鼠标放到位置1和2进行任意方向拖动会该表分支线的形状和方向。将鼠标放在位置3和4的小蓝块上回改变分支框的大小和高度，里面的文字会自动换行。
将鼠标放到分支框的右侧，在分支框的右侧边中心会出现一个”蓝圈红点“，将鼠标移到其上方，鼠标会变成十字箭头样式，这时拖动鼠标，分支和分支曲线随鼠标移到。
拖动鼠标到目标位置后，放开鼠标，分支框和分支线条已经进行了自动调整。我们将其从主题图片的右侧移到了下方。
更多信息请关注XMind中文官网：www.xmindchina.net返回搜狐，查看更多
责任编辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53c924f46fd5dd3bf18a6b32b251ee9b/" rel="bookmark">
			MySQL高可用探索之orchestrator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：使用orchestrator实现mysql主从自动切换、故障转移、拓扑管理。
部署MySQL环境(一主两从) IP:端口角色版本192.168.30.113:4406masterPercona 5.7.24-27-log CentOS Linux release 7.4.1708 (Core) 3.10.0-693.el7.x86_64192.168.30.118:4406slavePercona 5.7.24-27-log CentOS Linux release 7.4.1708 (Core) 3.10.0-693.el7.x86_64192.168.30.119:4406slavePercona 5.7.24-27-log CentOS Linux release 7.4.1708 (Core) 3.10.0-693.el7.x86_64 安装MySQL(略)
创建复制用户(三台mysql上面都创建)
GRANT REPLICATION SLAVE ON . TO repluser@’192.168.30.%’ IDENTIFIED BY ‘rep_2019’;
set global slave_net_timeout=8; 缩短从库感知主库宕机的等待时间
创建复制关系
在118和119上执行：
change master to master_host='192.168.30.113',master_port=4406,master_user='repluser',master_password='rep_2019',master_auto_position=1,MASTER_HEARTBEAT_PERIOD=2,MASTER_CONNECT_RETRY=1, MASTER_RETRY_COUNT=86400;
start slave;
以119为例，实操：
mysql&gt; change master to master_host='192.168.30.113',master_port=4406,master_user='repluser',master_password='rep_2019',master_auto_position=1,MASTER_HEARTBEAT_PERIOD=2,MASTER_CONNECT_RETRY=1, MASTER_RETRY_COUNT=86400;
Query OK, 0 rows affected, 2 warnings (0.01 sec)
mysql&gt; show warnings \G;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53c924f46fd5dd3bf18a6b32b251ee9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96c0a725b1f071780318498225492be5/" rel="bookmark">
			make makefile cmake qmake都是什么，有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		列表一：
1.gcc是GNU Compiler Collection（就是GNU编译器套件），也可以简单认为是编译器，它可以编译很多种编程语言（括C、C++、Objective-C、Fortran、Java等等）。
2.当你的程序只有一个源文件时，直接就可以用gcc命令编译它。
3.但是当你的程序包含很多个源文件时，用gcc命令逐个去编译时，你就很容易混乱而且工作量大
4.所以出现了make工具
make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。
5.makefile是什么？简单的说就像一首歌的乐谱，make工具就像指挥家，指挥家根据乐谱指挥整个乐团怎么样演奏，make工具就根据makefile中的命令进行编译和链接的。
6.makefile命令中就包含了调用gcc（也可以是别的编译器）去编译某个源文件的命令。
7.makefile在一些简单的工程完全可以人工手下，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改。
8.这时候就出现了Cmake这个工具，cmake就可以更加简单的生成makefile文件给上面那个make用。当然cmake还有其他功能，就是可以跨平台生成对应平台能用的makefile，你不用再自己去修改了。
9.可是cmake根据什么生成makefile呢？它又要根据一个叫CMakeLists.txt文件（学名：组态档）去生成makefile。
10.到最后CMakeLists.txt文件谁写啊？亲，是你自己手写的。
11.当然如果你用IDE，类似VS这些一般它都能帮你弄好了，你只需要按一下那个三角形
12.接着是qmake，qmake是什么，先说一下Qt这个东西。Qt是跨平台C++图形用户界面应用程序开发框架。它既可以开发GUI程序，也可用于开发非GUI程序，比如控制台工具和服务器。简单的说就是C++的第三方库，使用这个库你可以很容易生成windows，Linux，MAC os等等平台的图形界面。现在的Qt还包含了开发各种软件一般需要用到的功能模块（网络，数据库，XML，多线程啊等等），比你直接用C++（只带标准内裤那种）要方便和简单。
13.你可以用Qt简简单单就实现非常复杂的功能，是因为Qt对C++进行了扩展，你写一行代码，Qt在背后帮你写了几百上千行，而这些多出来的代码就是靠Qt专有的moc编译器（The Meta-Object Compiler）和uic编译器（User Interface Complier）来重新翻译你那一行代码。问题来了，你在进行程序编译前就必须先调用moc和uic对Qt源文件进行预处理，然后再调用编译器进行编译。上面说的那种普通makefile文件是不适用的，它没办法对qt源文件进行预处理。所以qmake就产生了。
14.qmake工具就是Qt公司制造出来，用来生成Qt 专用makefile文件，这种makefile文件就能自动智能调用moc和uic对源程序进行预处理和编译。qmake当然必须也是跨平台的，跟cmake一样能对应各种平台生成对应makefile文件。
15.qmake是根据Qt 工程文件（.pro）来生成对应的makefile的。工程文件（.pro）相对来说比较简单，一般工程你都可以自己手写，但是一般都是由Qt的开发环境 Qt Creator自动生成的，你还是只需要按下那个邪恶三角形就完事了。
16.还没有完，由于qmake很简单很好用又支持跨平台，而且是可以独立于它的IDE，所以你也可以用在非Qt工程上面，照样可以生成普通的makefile，只要在pro文件中加入CONFIG -= qt 就可以了。
17. 这样qmake和cmake有什么区别？
不好意思，cmake也是同样支持Qt程序的，cmake也能生成针对qt 程序的那种特殊makefile，
只是cmake的CMakeLists.txt 写起来相对与qmake的pro文件复杂点。
qmake 是为 Qt 量身打造的，使用起来非常方便，但是cmake功能比qmake强大。
一般的Qt工程你就直接使用qmake就可以了，cmake的强大功能一般人是用不到的。
当你的工程非常大的时候，又有qt部分的子工程，又有其他语言的部分子工程，据说用cmake会 方便，我也没试过。
列表二:
1. make 是用来执行Makefile的
2. Makefile是类unix环境下(比如Linux)的类似于批处理的"脚本"文件。其基本语法是: 目标+依赖+命令，只有在目标文件不存在，或目标比依赖的文件更旧，命令才会被执行。由此可见，Makefile和make可适用于任意工作，不限于编程。比如，可以用来管理latex。
3. Makefile+make可理解为类unix环境下的项目管理工具，但它太基础了，抽象程度不高，而且在windows下不太友好(针对visual studio用户)，于是就有了跨平台项目管理工具cmake
4. cmake是跨平台项目管理工具，它用更抽象的语法来组织项目。虽然，仍然是目标，依赖之类的东西，但更为抽象和友好，比如你可用math表示数学库，而不需要再具体指定到底是math.dll还是libmath.so，在windows下它会支持生成visual studio的工程，在linux下它会生成Makefile，甚至它还能生成eclipse工程文件。也就是说，从同一个抽象规则出发，它为各个编译器定制工程文件。
5. cmake是抽象层次更高的项目管理工具，cmake命令执行的CMakeLists.txt文件
6. qmake是Qt专用的项目管理工具，对应的工程文件是*.pro，在Linux下面它也会生成Makefile，当然，在命令行下才会需要手动执行qmake，完全可以在qtcreator这个专用的IDE下面打开*.pro文件，使用qmake命令的繁琐细节不用你管了。
总结一下，make用来执行Makefile，cmake用来执行CMakeLists.txt，qmake用来处理*.pro工程文件。Makefile的抽象层次最低，cmake和qmake在Linux等环境下最后还是会生成一个Makefile。cmake和qmake支持跨平台，cmake的做法是生成指定编译器的工程文件，而qmake完全自成体系。
具体使用时，Linux下，小工程可手动写Makefile，大工程用automake来帮你生成Makefile，要想跨平台，就用cmake。如果GUI用了Qt，也可以用qmake+*.pro来管理工程，这也是跨平台的。当然，cmake中也有针对Qt的一些规则，并代替qmake帮你将qt相关的命令整理好了。
另外，需要指出的是，make和cmake主要命令只有一条，make用于处理Makefile，cmake用来转译CMakeLists.txt，而qmake是一个体系，用于支撑一个编程环境，它还包含除qmake之外的其它多条命令(比如uic，rcc,moc)。
上个简图，其中cl表示visual studio的编译器，gcc表示linux下的编译器
那么qt中的moc rcc uic 又是什么呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96c0a725b1f071780318498225492be5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d508c8b42e851cf699014a6ec8be11f/" rel="bookmark">
			pyinstaller生成exe后，执行错误No module named ‘win32timezone‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ModuleNotFoundError: No module named 'win32timezone'
[10248] Failed to execute script main
是时间格式问题，在源码中显式得得引入win32timezone模块
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63543d4a15d9a92e55ec92a159a9fb4d/" rel="bookmark">
			Linux 驱动开发 / fbdev 双缓存 / 快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽，我是老吴。
我回来啦！
过年回老家，特别充实，大部分时间都在带娃～
女儿快 2 岁了，走起路来像模像样，在屋子里转来转去，有的时候还会小跑，痴迷于外出逛街。
目前我稍微有点理解她了。
2岁的小孩特别倔强，她想做或者不愿意做的事，一般都会跟我死磕到底，很难强迫她。
我发现 2 个比较有效的方法：
1&gt; 转移注意力
例如大半夜她吵着要出去玩，就得先用好吃的水果稳住她.;
2&gt; 顺势而为
例如她一定要玩剪刀，家里就提前准备好一把玩具剪刀，给她玩;
哈哈哈，还有很多好玩的技巧，以后再分享了，下面开始学技术。
一、为何需要 double buffer? single buffer 会导致：
屏幕撕裂(tearing)，即在屏幕上同时看到多帧数据拼接在一起。
点击查看大图 single buffer 为何会造成撕裂：
refresh rate 和 frame rate 不一致。
refresh rate 表示的是 屏幕每秒能更新多少次显示，例如 30hz / 60hz。
点击查看大图 frame rate 表示的是 lcd controller / gpu 每秒能绘制多少帧数据，例如 30fps / 60fps。
点击查看大图 LCD controller / gpu 和 屏幕协作完成一帧图像的显示：
点击查看大图 在 single buffer 的场景下，LCD user 和 LCD controller / gpu 总是在共用同一个 framebuffer，且没有同步机制。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63543d4a15d9a92e55ec92a159a9fb4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b19a25c6a06bd7844cd3572d898d77e4/" rel="bookmark">
			sign in
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CTFHub misc 两星 sign in
下载解压得到
用base16解码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3b386d8abac45ce058cf23e409fb60b/" rel="bookmark">
			ros基础必看之各个frame的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘自：https://blog.csdn.net/ahelloyou/article/details/105945979
ros基础必看之各个frame的理解 黑猫爱小鹿 2020-05-06 10:48:46 1443 收藏 19 分类专栏： ros
版权
文章目录 常见的坐标系坐标系的约定坐标系变换的计算Map之间的切换添加 如果觉得好请收藏点赞.
frame_id：用来告诉你，发布的数据是来自哪一个坐标系的。
ros中常见的坐标系
转载链接
现在小车进行移动
如图(1-2)，在原点插一面小旗子，并控制小车行驶一段距离，这个时候我们能得到三个位置信息
使用测量工具测量小车相对旗子的位置，在X轴正方向距原点3个单位，在Y轴正方向距原点2个单位小车安装里程计，记录自己前进3个单位，并向左平移了2个单位小车使用激光雷达数据与已有地图进行匹配，并结合里程计数据，将数据融合得到小车的位置在X轴正方向3个单位，在Y轴正方向2个单位 在上面的例子中，三个坐标值都相同。但真实情况下，三个坐标值由于测量误差或者其他原因导致坐标值并不相同，然而这三个坐标都用来表示小车中心在空间中的位置，这就引出了不同坐标系
对于第一种测量，称之为真实坐标系，这是一个理想的坐标系，即我们拥有一种绝对准确的测量方式获得小车相对于地图原点的坐标，但这种坐标系在真实情况下是不存在的。
对于第二种测量，称之为
里程计坐标系
，在这个坐标系中得到的测量值通常是基于轮速里程计，视觉里程计或者惯性单元得到的。在这个坐标系中，新坐标值通常是根据前一个时刻坐标得到的，一般使用odom来表示。
优点: 坐标值是连续的并且以平稳的方式演变，没有离散的跳跃。缺点: 测量产生的误差会累计。适合: 短时程相对定位 对于第三种测量，称之为
地图坐标系
，在这个坐标系中得到坐标值通常是通过传感器的数据重新计算或测量得到的，一般使用map来表示。
优点:由于每次得到的坐标点都是重新测量计算得到的，累计误差影响较小缺点: 坐标数据会有跳变。适合: 长时程绝对定位 假设对于上面描述的三种测量是以下结果
真实坐标系：坐标值为(3, 2)里程计坐标系：坐标值(3, 1)地图坐标系：坐标值(3.5, 2.5) 转载
原链接
常见的坐标系 在使用ROS进行定位导航等操作时，我们经常会遇到各种坐标系。每种坐标系都有明确的含义。理论上坐标系的名称可以是随意的，但是为了方便不同的软件间共享坐标信息，ROS定义了几个常见的坐标系。
1.base_link
base_link坐标系和机器人的底盘直接连接。其具体位置和方向都是任意的。对于不同的机器人平台，底盘上会有不同的参考点。不过ROS也给了推荐的坐标系取法。
x 轴指向机器人前方
y 轴指向机器人左方
z 轴指向机器人上方
2.odom
odom是一个固定在环境中的坐标系也就是world-fixed。它的原点和方向不会随着机器人运动而改变。但是odom的位置可以随着机器人的运动漂移。漂移导致odom不是一个很有用的长期的全局坐标。然而机器人的odom坐标必须保证是连续变化的。也就是在odom坐标系下机器人的位置必须是连续变化的，不能有突变和跳跃。
在一般使用中odom坐标系是通过里程计信息计算出来的。比如轮子的编码器或者视觉里程计算法或者陀螺仪和加速度计。odom是一个短期的局域的精确坐标系。但是却是一个比较差的长期大范围坐标。
3.map
map和odom一样是一个固定在环境中的世界坐标系。map的z轴是向上的。机器人在map坐标系下的坐标不应该随着时间漂移。但是map坐标系下的坐标并不需要保证连续性。也就是说在map坐标系下机器人的坐标可以在任何时间发生跳跃变化。
一般来说map坐标系的坐标是通过传感器的信息不断的计算更新而来。比如激光雷达，视觉定位等等。因此能够有效的减少累积误差，但是也导致每次坐标更新可能会产生跳跃。
map坐标系是一个很有用的长期全局坐标系。但是由于坐标会跳跃改变，这是一个比较差的局部坐标系（不适合用于避障和局部操作）。
坐标系的约定 在非结构化的环境中（比如开放环境），如果我们要定义一个全球坐标系
默认的方向要采用 x轴向东，y轴向北，z轴向上如果没有特殊说明的话z轴为零的地方应该在WGS84椭球上(WGS84椭球是一个全球定位坐标。大致上也就是z代表水平面高度)
如果在开发中这个约定不能完全保证，也要求尽量满足。比如对于没有GPS，指南针等传感器的机器人，仍然可以保证坐标系z轴向上的约定。如果有指南针传感器，这样就能保证x和y轴的初始化方向。 在结构化的环境中（比如室内），在定义坐标系时和环境保持对应更有用。比如对于有平面图的建筑，坐标系可以和平面图对应。类似的对于室内环境地图可以和建筑物的层相对应。对于有多层结构的建筑物，对每一层单独有一个坐标系也是合理的。
4.earth
这个坐标系是为了多个机器人相互交互而设计的。当有多个机器人的时候，每个机器人都有自己的map坐标系，他们之间的map坐标系并不相同。如果想要在不同的机器人间共享数据，则需要这个坐标系来进行转化。
如果map坐标系是一个全局坐标系，那么map到earth坐标系的变化可以是一个静态变换。如果不是的话，就要每次计算map坐标系的原点和方向。
在刚启动的时候map坐标系的全局位置可能是不知道的。这时候可以先不发布到earth的变换，直到有了比较精确的全局位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3b386d8abac45ce058cf23e409fb60b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/970381ac61303d3fd68ce0b0ec0148a6/" rel="bookmark">
			使用anaconda3安装tensorflow2.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载anaconda 先下载最新版anaconda
2.安装anaconda https://zhuanlan.zhihu.com/p/75717350
3.安装tensorflow环境 关闭 anaconda和pycharm，打开anaconda prompt新建一个python3.5的环境 conda create --name tensorflow python=3.5 激活进入这个python3.5的环境 activate tensorflow 升级pip pip install --upgrade pip -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com --user 安装tensorflow pip install tensorflow==2.0.0-alpha0 -i https://pypi.douban.com/simple 4.其他 jupyter notebook不能运行代码，一直处于In[*]状态
解决办法：重新安装notebook activate tensorflowpip install --ignore-installed notebook -i https://pypi.douban.com/simple jupyter notebook 选择环境 conda install nb_conda
效果如下：
安装jupyter插件 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple flaskpip install jupyter_contrib_nbextensions -i https://pypi.tuna.tsinghua.edu.cn/simple flaskjupyter contrib nbextension install --userpip install jupyter_nbextensions_configuratorjupyter nbextensions_configurator enable --user
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/825c49d9e24f00632413530b46296930/" rel="bookmark">
			java俄罗斯方块设计报告_俄罗斯方块JAVA课程设计实验报告毕业设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		俄罗斯方块JAVA课程设计实验报告毕业设计 1目录一引言..........................................................................................................................................................21.1运行环境...............................................................................................................................................2二需求分析.................................................................................................................................................22.1开发背景...............................................................................................................................................22.2设计目的...............................................................................................................................................22.3功能需求...............................................................................................................................................2三概要设计.................................................................................................................................................33.1设计思想...............................................................................................................................................33.2系统架构...............................................................................................................................................3四详细设计.................................................................................................................................................34.1事件处理...............................................................................................................................................34.2界面设计...............................................................................................................................................44.3游戏画布类...........................................................................................................................................44.4方块类...................................................................................................................................................64.5消行并统计分数.................................................................................................................................11五.使用说明...................................................................................................................................................125.1游戏开始运行.....................................................................................................................................125.2填满一行即消行得分........................................................................................................................135.3列被填满，则游戏自动结束............................................................................................................14六课程设计总结与体会...........................................................................................................................14七参考文献...............................................................................................................................................152一引言1.1运行环境操作系统MicrosoftWindowsXP程序语言Java开发工具JCreatorLE4.50二需求分析2.1开发背景Java是现在全球最时髦的开发工具之一，它拥有一套庞大且完善的类库，内置了其他语言需要靠库甚至是操作系统才能支持的功能。Java的产生与流行是Internet发展的客观要求。如今越来越多的应用程序是Java开发的，用Java开发的应用程序可在任何计算平台安全运行。Java作为一个分布式的，面向对象的程序设计方法，可以让位于任何地方的任何计算机使用网络上的应用程序。可以说Java是一个万能的开发平台，用Java编程成为一种趋势。2.2设计目的通过本次课程设计了解和掌握JDK开发环境以及JCreator等集成开发环境，巩固所学的Java知识及编程机制。了解Java程序开发流程，学会构思比较复杂的课程设计思想；能合理的利用本学期所掌握的多线程、类、GUI等知识编写一个较为复杂的Java应用软件。掌握面向对象成学设计的有关概念和开发方法，锻炼团队合作开发精神。2.3功能需求本课程设计的目标是设计一个名为俄罗斯方块的游戏软件，实现其界面的初始化，程序运行，退出，和相应数据处理。能实现游戏的基本功能，类似下移、左移、右移、翻转、得分累加等，并在规定时间内达到课题所需要实现的功能及要求。3三概要设计3.1设计思想1)使用JPanel框架，并添加按钮、文本框等对象，用布局管理器定义各个对象的分布。2)设计一个二维数组来表示方块，默认为不显示。3)设计一个设计定时线程来控制方块的下落速度。4)设计七种形状的方块，每种形状定义四种形态来实现方块变换5每个方块落到底后判断是否消沉。3.2系统架构四详细设计4.1事件处理俄罗斯方块游戏游戏操作处理画布游戏界面按钮事件键盘事件方块类画布类面板类4用actionPered()方法实现选择不同类型方块以及控制方块变化功能的实现，用keyPressed()方法实现用键盘控制方块变化功能的实现，在FinalElsBlock.java类中实现事件的监听。4.2界面设计游戏基本界面图4.3游戏画布类LeftShowCanvas类继承Canvas类，实现方块在画布上的显示，主要代码如下packagegame3;importjava.awt.*;importjava.awt.event.*;importjavax.swing.*;importjavax.swing.event.*;classLeftShowCanvasextendsCanvaintmaxrows,maxcols;//画布最大行数，列数intunitSize;//单元格的大小，小正方格5intunitState;//每个小方格的状态0、1、2表示RightPanelrp;intscore;publicLeftShowCanvasRightPanelrpthis.rprp;scoreInteger.valueOfrp.jtf.getText;maxrows20;maxcols10;unitSize20;unitStatenewintmaxrowsmaxcols;initCanvas;publicvoidinitCanvas//初始化，画布方格forinti0;i1;comIndex0 x8000;forintirow;i1;9ifisfall0//无法下落，先判断是否能消行，再重新初始化//lsc.deleteFullLinerow,col;reInit;reInitRowCol;oldRowrow;oldColcol;oldTypeblockType;oldStateblockState;publicvoidleftTurn//旋转，左转ifthis.blockType-1blockStateblockState14;ifisMove3drawBlockblockType;elseblockStateblockState34;publicvoidleftMove//左移ifthis.blockType-1drawBlockblockType;publicvoidrightMove//右移ifthis.blockType-1drawBlockblockType;publicbooleanfallMove//下移ifthis.blockType-110ifisMove2row1;drawBlockblockType;returntrue;elseisfall0;drawBlockblockType;returnfalse;returnfalse;publicsynchronizedbooleanisMoveinttag//左0，右1，下2,旋转3intcomIndex0 x8000;forintirow;ilsc.maxrows-1||jlsc.maxcols-1||lsc.unitStateij2returnfalse;comIndexcomIndex1;returntrue;114.5消行并统计分数publicvoiddeleteFullLineintrow//判断此行是否可以消，同时可消就消行forintj0;j3;i--//到此即为可消，将上面的移下消此行forintj0;jmaxcols;jdrawUniti,j,unitStatei-1j;score;rp.jtf.setTextString.valueOfscore;12五.使用说明5.1游戏开始运行135.2填满一行即消行得分145.3列被填满，则游戏自动结束六课程设计总结与体会本次课程设计花费我们小组一个月的时间来完成，从设计开始选择课题到最终完成课程设计，小组成员分工明确，相互合作，按时完成相关任务。通过这次实验，我们学习到了很多Java编码成知识，同时对这个学期的课本所学的知识有了进一步巩固，特别是多线程，Swing组件和事件等能更熟练的运用。这次实验过后，我们发现，动手比看书更能获取实际有用的知识。真理是从实践中得知的，而且也只有实践才能检验真理。而这次实验也加强了我们这些方面的理解能力，对书面上的东西实际操作在具体项目上有了一个更清晰的认识。我们还意识到一个大的程序，在写代码之前，一定要有良好的需求分析和结构设计，应该占整个程序设计的大部分时间，一个好的程序，分析设计应该要非常充分，这样才不至于代码写了一半才发现很多错误。很多具体代码操作之前的设计规划和构建才是优秀程序设计的灵魂。设计过程中，我们另一个大的体会就是合作的好处，通过相互帮助，大大的提高了工作效率。同时我们也发现自己的不足之处。而且让我感受比较深的是，做事细心很重要，所谓细节决定成败。程序还有很多不足，在今后的日子里，我们会虚心向老师同学请教，尽自己最大的努力做到最好。15七参考文献1.李芝兴,杨瑞龙.Java程序设计之网络编程.M.北京清华大学出版社2.印旻编.Java语言与面向对象程序设计.M.北京清华大学出版社3.朱站立,沈伟.Java程序设计实用教程.M.北京电子工业出版社16(此为最后一页)指导教师评语指导教师签名年月日成绩教研室审核意见教研室主任签字年月日
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94919f8109834fb926f40422ba22dbc8/" rel="bookmark">
			时间复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间复杂度 1 定义：时间复杂度是指执行算法所需要的计算工作量；
2 时间复杂度的计算：计算机运行一次代码要执行一次运算，例如：
int aFunc(void) {
printf(“Hello, World!\n”); // 需要执行 1 次
return 0; // 需要执行 1 次
}需要执行两次
int aFunc(int n) {
for(int i = 0; i&lt;n; i++) { // 需要执行 (n + 1) 次
printf(“Hello, World!\n”); // 需要执行 n 次
}
return 0; // 需要执行 1 次
}则需要执行2n+2次
如果运行代码需要执行的次数是常数的话，常数对函数的影响不大，所以我们称这个时间复杂度为o（1）；如果是n^ 2+n+c 则时间复杂度为o（n^2），一般来说，如果一个算法的执行次数是t(n),那么只保留他的最高次幂项，同时忽略最高次幂的系数，得到f（n），那么时间复杂度为o（f（n））；
3 四个法则
3.1 单个循环体法则
对于一个循环，假设循环体的复杂度为o（n），循环次数为m，则这个循环的时间复杂度为o（n*m）；
3.2 多个循环体法则
假设循环体的复杂度为o（n），循环次数为m，t则这个循环的时间复杂度为o（nmt）；
3.3 多个时间复杂度
选择所有复杂度中最大的那个， max(O(n ^ 2)，O(n))，即 O(n^2)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94919f8109834fb926f40422ba22dbc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c101d8509288cc8c911ceae2eb72d6fb/" rel="bookmark">
			[Spring]-注解开发与Junit集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring注解开发 Spring是轻代码而重配置的框架，一般情况下，配置比较繁重，影响开发效率，所以注解开发是一种必然趋势，注解代替XML配置文件可以简化配置，提高开发效率
Spring原始注解 Spring的原始注解主要用于代替XML配置中的标签
注解说明@Component使用在类上用于实例化Bean@Controller使用在web层类上用于实例化Bean@Service使用在service层类上用于实例化Bean@Repository使用在dao层类上用于实例化Bean@Autowired使用在字段上用于根据类型进行依赖注入@Qualifier结合@Autowired一起使用用于根据名称进行依赖注入@Resource相当于@Autowired+@Qualifier，按照名称进行注入@Value注入普通属性@Scope标注Bean的作用范围@PostConstruct使用在方法上标注该方法是Bean的初始化方法@PreDestory使用在方法上标注该方法时Bean的销毁方法 未使用注解的情况下 public class UserDaoImpl implements UserDao { @Override public void save() { System.out.println("save runnning..."); } } public class UserServiceImpl implements UserService { private UserDao dao; public void setDao(UserDao dao) { this.dao = dao; } @Override public void save() { dao.save(); } } &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="userDao" class="cn.ywrby.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt; &lt;bean id="userService" class="cn.ywrby.service.impl.UserServiceImpl"&gt; &lt;property name="dao" ref="userDao"/&gt; &lt;/bean&gt; &lt;/beans&gt; 使用注解简化后 //@Component作用是实例化Bean，作用和&lt;Bean&gt;标签相同，传入的参数就是当前对象的ID @Component("userDao") public class UserDaoImpl implements UserDao { @Override public void save() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c101d8509288cc8c911ceae2eb72d6fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ead18db695bde0054a69a80020b228a8/" rel="bookmark">
			java实现录屏_Android5.0以上版本录屏实现代码(完整代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我录屏的方式是分别录制音频和视频，最后合并成mp4格式，比较麻烦，因为网上完整的教程比较少，所以我打算写一个完整版的，照着我的代码写完之后，至少是能够实现功能的，而不是简单的介绍下用法。
1既然是录制视频，我们应该有一个按钮控制开始和结束。
2在录制之前，需要先判断一下Android系统的版本是否大于5.0，并且动态申请一下权限(读写，录音，照相机)，这一步可以在点开始按钮的时候执行
if (ContextCompat.checkSelfPermission(context, Manifest.permission.WRITE_EXTERNAL_STORAGE)
!= PackageManager.PERMISSION_GRANTED) {
ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 102);
}
if (ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO)
!= PackageManager.PERMISSION_GRANTED) {
ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.RECORD_AUDIO}, 103);
}
if (ContextCompat.checkSelfPermission(context, Manifest.permission.CAMERA)
!= PackageManager.PERMISSION_GRANTED) {
ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.RECORD_AUDIO}, 104);
}
Intent intent = null;
if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP) {
intent = mediaProjectionManager.createScreenCaptureIntent();
startActivityForResult(intent, 101);//正常情况是要执行到这里的,作用是申请捕捉屏幕
} else {
ShowUtil.showToast(context, "Android版本太低，无法使用该功能");
}
3定义MediaProjection和MediaProjectionManager等一些其他必要的变量
boolean isrun = false;//用来标记录屏的状态private MediaProjectionManager mediaProjectionManager;
private MediaProjection mediaProjection;//录制视频的工具private int width, height, dpi;//屏幕宽高和dpi，后面会用到
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ead18db695bde0054a69a80020b228a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e00f0452ab85e6e408b553f487796ff/" rel="bookmark">
			[css]  怎么让body高度自适应屏幕？为什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[css] 怎么让body高度自适应屏幕？为什么？ 为何只设置body{height：100%}不行？ height：100%是相对于父元素来说的，如果只设置body的高度属性，由于其父元素是html高度未设置，且并非浏览器窗口高度，所以只设置body为100%是不能达到效果的，必须html，body都设置100%。而body{height: 100vh}直接把高度设置成了视口高度，与html大小无关，所以只在body设置vh是可行的。 个人简介 我是歌谣，欢迎和大家一起交流前后端知识。放弃很容易，
但坚持一定很酷。欢迎大家一起讨论
主目录 与歌谣一起通关前端面试题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e20fe482ad42879b62053cc506cfad2/" rel="bookmark">
			redhat 安装java_redHat6.5安装JDK1.8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先从官网下载JDK
我下载的是jdk-8u131-linux-x64.tar.gz这个版本(下面的安装方式也是tar 包的安装方式)
2.通过XFtp将该压缩文件上传到Linux系统 /usr/tmp目录下(这个是博主的选择，可以随意)
3.安装之前我们检查下看系统有没有已经安装的jdk
运行 java -verison
发现系统已有安装的OPenJDK
你可以选择不删除，博主在这里选择删除，查看已有JDK的相关信息：rpm -qa | grep jdk
删除rpm -e --nodeps java-1.7.0-openjdk-1.7.0.45-2.4.3.3.el6.x86_64
rpm -e --nodeps java-1.6.0-openjdk-1.6.0.0-1.66.1.13.0.el6.x86_64
查看jdk是否已经卸载
说明JDK已经卸载
4.创建/usr/java 目录，开始安装jdk
4.1首先 创建 目录
cd /usr
mkdir java
目录已经创建好了。
4.2将jdk解压到指定的目录下
tar -xzvf jdk-8u131-linux-x64.tar.gz -C /usr/java/
注意上面C是大写，我在JDK包的目录下，不在目录下需带上路径。
说明解压成功
4.5 设置环境变量，这是最重要的
在etc/profile文件下添加
export JAVA_HOME=/usr/java/jdk1.8.0_131
export PATH=$JAVA_HOME/bin:$PATH
温馨提示，修改配置文件前先bak一份吧，在你没有把握的情况下，以免改错了，影响其他功能，而又恢复不了。
如果你不想重新系统，可以用命令source /etc/profile使配置文件立即生效。否则只能重启系统才能使配置参数生效
验证环境变量是否生效
4.6 验证环境变量是否生效及是否安装成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e85d94eb357a1ae9d227a99c8345bb4d/" rel="bookmark">
			java 反爬虫_springboot反爬虫组件kk-anti-reptile的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是为广大程序员兄弟操碎了心的小编，每天推荐一个小工具/源码，装满你的收藏夹，每天分享一个小技巧，让你轻松节省开发效率，实现不加班不熬夜不掉头发，是我的目标！
今天小编推荐一款反爬虫组件叫kk-anti-reptile，一款可快速接入的反爬虫、接口防盗刷spring boot stater组件。
1. 系统要求
基于spring-boot开发(spring-boot1.x, spring-boot2.x均可)
需要使用redis
2. 工作流程
kk-anti-reptile使用基于Servlet规范的的Filter对请求进行过滤，在其内部通过spring-boot的扩展点机制，实例化一个Filter，并注入到Spring容器FilterRegistrationBean中，通过Spring注入到Servlet容器中，从而实现对请求的过滤。
在kk-anti-reptile的过滤Filter内部，又通过责任链模式，将各种不同的过滤规则织入，并提供抽象接口，可由调用方进行规则扩展。
Filter调用则链进行请求过滤，如过滤不通过，则拦截请求，返回状态码509，并输出验证码输入页面，输出验证码正确后，调用过滤规则链对规则进行重置。
目前规则链中有如下两个规则
ip-rule
ip-rule通过时间窗口统计当前时间窗口内请求数，小于规定的最大请求数则可通过，否则不通过。时间窗口、最大请求数、ip白名单等均可配置
ua-rule
ua-rule通过判断请求携带的User-Agent，得到操作系统、设备信息、浏览器信息等，可配置各种维度对请求进行过滤
3. 接入使用
后端接入非常简单，只需要引用kk-anti-reptile的maven依赖，并配置启用kk-anti-reptile即可。
加入maven依赖
cn.keking.project
kk-anti-reptile
1.0.0-SNAPSHOT
4.配置启用 kk-anti-reptile
anti.reptile.manager.enabled=true
前端需要在统一发送请求的ajax处加入拦截，拦截到请求返回状态码509后弹出一个新页面，并把响应内容转出到页面中，然后向页面中传入后端接口baseUrl参数即可，以使用axios请求为例：
import axios from 'axios';
import {baseUrl} from './config';
axios.interceptors.response.use(
data =&gt; {
return data;
},
error =&gt; {
if (error.response.status === 509) {
let html = error.response.data;
let verifyWindow = window.open("","_blank","height=400,width=560");
verifyWindow.document.write(html);
verifyWindow.document.getElementById("baseUrl").value = baseUrl;
}
}
);
export default axios;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e85d94eb357a1ae9d227a99c8345bb4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5057e65cde4c953ec7914475da3191bb/" rel="bookmark">
			vs2017 java_在idea2018和vs2017平台下JNI编程调用C&#43;&#43;算法（1）-环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		##JNI简介
JNI是Java Native Interface的简称，通过JNI,可以调用C++或C的程序(称为本地程序)。
##应用场景
我认为应用场景可以用三个字概括“不得不”，即只有遇到必须跨语言的时候，才会选择JNI。从Java的场景出发，使用JNI意味着失去了跨平台的优势；从C++的角度想，可能需要将程序发布到安卓端等，而不得不采用JNI进行跨语言。
通过调研JNI,目前JNI的应用场景大部分是需要在安卓平台引入C/C++代码。也有人和我一样，正在开发的java系统需要调用一段C++的核心代码。于是，让我们愉快地入坑吧~
##本文特色
本文主要讲解在idea2018和vs2017平台下搭建一套Java项目和C++解决方案，其中Java项目实现一个简单的HelloWorld功能，该功能正是通过JNI调用C++实现的。
作为一名JNI刚入坑小将，以及多年没写过(只在书本和考试中与其交手)C++的渣渣，写一个HelloWorld程序也是反复磨炼的过程。在反复磨炼过程中，我发现网上很多教程有些繁琐，需要将各种文件复制来粘贴去，稍有错误就要重新复制粘贴，实在让人恼火。所以本文介绍一种**借助idea和vs平台尽量减少步骤的搭建方法**。
##环境介绍
- 操作系统：Win7专业版64bit
- JDK:1.8
- idea:2018
- vs:2017
&gt; Tips:
&gt; windows系统注定了生成的动态链接库是dll文件
&gt; JDK10将javah工具取消，需要使用javac -h替代，这是与jdk8不同的地方
主要步骤
创建一个java项目，在其中编写一个带有native方法的类
利用idea生成.h头文件
在vs中创建一个动态链接库应用程序的解决方案
在解决方案中创建C++文件，实现头文件中的方法
生成动态链接库
回到idea,运行java项目，排错重复以上步骤直到运行成功
1.在idea创建java项目
首先本次项目主要想实现一个简单的HelloWorld，java程序声明sayHello函数，并将name当做参数传入。在C++中实现sayHello，将sayHello的文本传回给java程序。步骤如下
在idea创建java项目，在src目录下新建一个package,本文包为com.study,jni.demo.simple。
在包下创建一个类，用来编写native方法和main函数。
package com.study.jni.demo.simple;
import com.study.jni.demo.common.Constants;
public class SimpleHello {
public static native String sayHello(String name);
public static void main(String[] args) {
String name = "lucyChen";
String text = sayHello(name);
System.out.println("after native, java shows:" + text);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5057e65cde4c953ec7914475da3191bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c16d9c02820fd707b6e94b2830fd082/" rel="bookmark">
			python如何合并数据列表_Python合并两个列表的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浏览博客看到一个问题：如何合并两个列表，今天就来探讨一下。
方法一
最原始，最笨的方法，分别从两个列表中取出所有的元素，再放入新列表中就OK了。示例代码如下：
list1 = [1,2,3]list2 = [4,5,6]list_new = []for item in list1: list_new.append(item)for item in list2: list_new.append(item)print list_new
行动结果如下：
[1,2,3,4,5,6]
方法二
这里要用到Python中的一个内置函数zip(),它的作用从名字就可以看出来，就是将几个本来无关的内容打包到一起。废话少说，看代码：
a = [1,2,3]b = [4,5,6]c = zip(a,b) //c = [(1,4),(2,5),(3,6)]list_new = [row[i] for i in range(len(0)) for row in c]
先打包，再降维，就这么简单。(其实一点也不简单，看到后面你就会有想打人的冲动)
方法三
我去，写到最后才发现，前面写的都是废话，为什么呀，因为python语法一句话就能实现的事，我竟然在这里纠结了一篇文章，真是闲得蛋疼。
a = [1,2,3]b = [4,5,6]c = a + b
这就完了，真扯蛋！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ca72c0ee949cec58af14a09a0d097d2/" rel="bookmark">
			AD自动布线的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一个说了自己布线的问题 这个软件也可以自动布线Route Auto Route All
然后这个页面会弹出来 然后选择Route All
然后这就是自动布线的情况 这里显示百分之百就是全部自动布线完成 如果不是百分之百 那么就说明这个线没有完全连接好 这你可以在换摆放位置 在自动布线 如果还是不行 就可以自己去布线
这个就是布线的结果 红色的就是顶端布线 蓝色就是在底端布线 这个是双层的
这个安全间距需要设置一下 8mil 在 design rules
在这里就可以解决了把间距设置成8mil
这里的线宽设置成10mil
这里显示的所有线宽 但是如果有要求对vcc 的线宽要改怎么处理呢 找到这个width 右击找new rules 这样就对这个vcc的这个连线有新的规定要求了
.
这样对不同的线有不同的规定了
这里是对顶线可以走几层 这里全勾上就是顶部底部都可以走的层数
这里是可以指定焊盘过孔的大小的要求
按照要求把这里改成规定的数据
把规定定好之后就可以按照最开始讲的进行自动布线了 也可以 先不设定太都得规则 等全部连好之后 可以在更改规则 也可能会比较好的走完
泪滴操作 可以有效地保护焊盘
tools teardrop 这样你可以勾选单个 也可以全勾选上 你可以试试 再看看焊盘的区别
然后说下敷铜 能够使板子的抗干扰能力更强
play Polygon Pour
或者这里有快捷键 敷铜
选中之后将其 板子圈住 然后就会敷铜完成
再次根据要求 选择敷铜之后 可以按tap键 修改
敷铜的网络
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ca72c0ee949cec58af14a09a0d097d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fd8297c0fb0eaf2afb3e6c2ed92af83/" rel="bookmark">
			常用java技术_java常用技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		struts2基本包commons-logging-*.jar Apache旗下commons项目的log日志包
freemarker-*.jar 一种前台页面模板，应用比较广泛
ognl-*.jar 动态图导航语言，struts2处理前台页面的核心语言，相当实用
struts2-core-*.jar struts2的核心包
xwork-core-*.jar webwork的核心包，因为struts2的前身是webwork，所以这个是必须
网页在title上面添加小logo
struts2中Action获取request、response、session
/**
* struts2中Action获取request、response、session
* 我们平常所说的session一般是HttpSession，但在struts2中被封装成了Map类型。
*/
ActionContext context = ActionContext.getContext();
HttpServletRequest request = (HttpServletRequest) context.get(ServletActionContext.HTTP_REQUEST);
HttpServletResponse response = (HttpServletResponse) context.get(ServletActionContext.HTTP_RESPONSE);
Map session = context.getSession();
富文本框
参考资料：http://blog.csdn.net/zou_hailin226/article/details/7564629
数据库可以用CLOB,或直接生成静态页面
WEB.XML中的配置
30
配置在项目web.xml中，在tomcat下的conf目录中的web.xml也可配置
500
/commons/error.jsp
404
/commons/404.jsp
403
/commons/403.jsp
Java生成随即数
Random random = new Random();
int nextInt = 0;
for(int i=0;i&lt;10;i++){
nextInt = random.nextInt(100);//中如果带参，表示0至带参数中间的随即数，可以不带参
System.out.println(nextInt);
}
数据库使用IF判断
1.CASE WHEN THEN 值 ELSE 值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fd8297c0fb0eaf2afb3e6c2ed92af83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b57e0a1d95aa4262984eb755deb5fdd7/" rel="bookmark">
			企业采购管理应考虑的7个有效策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		企业实施采购管理策略是为了针对一群高效的供应商，做出具有成本效益的采购决策，这些供应商将按双方同意的条款准时交付优质产品。
最普遍的采购策略是通过集中采购来节省采购成本，集中采购将整个采购活动集中在一个主要位置和权限来源。但是，你会发现，企业需要获取不同类型的产品和服务，因此他们需要组合以下策略：
▪单一来源采购
企业可以决定采取单一来源的采购策略，该策略涉及从单个供应商那里获取优质的专用服务。在为IT或间接采购（如办公用品和清洁用品）寻源时，这个策略占主导地位。
▪采购周期
企业可以采用使用核心采购周期的采购策略。根据该策略，企业从一组常规供应商那里订购，使用外包采购来进行较大的临时采购。
▪采购竞价
为了获取最佳定价，企业会使用采购竞价，特别是当他们为短期项目寻找劳动力时。
七个有效的采购策略
无论企业的规模如何，大多数企业都会实施七个核心的采购策略。
1.供应商优化与关系建立
企业选择可以提供最佳价格和条款的最佳供应商组合。此过程通常意味着，放弃能力较弱的、无法按所需条款和价格提供优质服务的供应商。到目前为止，这是各种采购策略中最常见的策略。
2.全面质量方法（TQM）
全面质量方法要求供应商提供不断提高的质量服务，零错误。供应商确保采购最佳实践使用多种工具，如六西格玛。
3.风险管理
越来越多企业从中国和印度等国家获得供应品，他们也越来越关注该供应链的风险管理。虽然这些国家可以以非常优惠的价格提供产品，但自然或人为灾难很快就会抵消这些优势。
比如，去年新冠肺炎Covid-19的出现。2020年1月，Covid-19席卷中国时，欧洲买家忙于核实他们的中国供应商能否按协议交货。而由于中国停产，这些供应商在满足需求中苦苦挣扎。
但是，两个月后，情况发生了变化。Covid-19席卷欧洲、美国和世界其他地区。买家要求中国供应商推迟交货，因为欧洲的封锁导致他们无法运营。
4.全球寻源
大型跨国企业将世界视为一个巨大的市场，他们可以从许多供应商那里获得资源，不论供应商的起源国是什么。
实施全球战略性寻源战略意味着，从能够生产商品或提供更优惠服务的国家那里有效采购商品和服务。
“全球寻源”将继续存在，企业需要谨慎行事并制定计划来管理风险。
5.供应商发展
根据供应商提供的服务或商品的规模和深度，与此类供应商紧密合作可能很有必要。助力流程开发有助于企业降低成本，这些流程能够帮助这些供应商提供更好或更便宜的产品。
如果一家企业仅依靠一个供应商提供产品，并且该供应商无法达到所需标准，那么采购方可以协助供应商改善服务或实施流程以缩短采购周期。这最终有助于采购方/买家获得可靠的供应商和产品交付。
6.绿色采购
对于政府和地方政府来说，这是较常见的采购策略之一。该策略主张，需要回收和采购对环境不利的产品。
7.培养和培训采购技能
虽然人员培训是采购和采购策略的软肋，但这可能是最重要的策略——上面所有其他策略必须由人员实施，如果他们没有必要的技能来执行采购策略，策略交付将会以失败告终。
SRM技术有助实施上述采购策略
利用诸如8MSaaS SRM之类的现代SRM技术，对于实施你最终决定的采购策略非常重要。
8MSaaS SRM一站式电子采购平台基于云计算，为企业提供基于大数据的电子采购管理，用数据支持决策，推动上述采购策略实施。
系统帮助企业建立与上下游的连接，采购部门统一在8MSaaS SRM平台协同采购工作，既能自主管理本机构的采购项目，又能通过统一平台数据中心，共享采购信息资源（包括供应商、专家、产品行情等），使得采购价格更优惠、采购时间更快捷，实现供应链的高效协同。
利用8MSaaS SRM电子采购平台，采购部门可以根据模板自动生成电子采购文件，在线发布招采公告，针对具体采购项目邀请供应商，与各类供应商通过短信、网络传真、电子邮件等方式进行日常联络、文件往来等，在线接受供应商投标，组织专家线评标，根据评标结果发布中标公告和中标通知书，买卖双方签订电子合同，履约验收后通过电子支付手段完成采购交易的结算。
由于采购活动本身的复杂性和多样性，要求电子化采购技术在建立电子采购业务和技术标准，提供灵活便利的采购工具、完善采购项目工作流定制。企业很有必要通过加强供应商管理的决策、整合企业外部资源，制定符合企业自身的采购管理决策。从而使得企业采购价值链管理的决策落到实处，提高自身盈利水平和实力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc8bf027620097f95b6cd5bcaa06ca4c/" rel="bookmark">
			js原理：闭包（理解闭包要先从基础知识开始）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序：很多人在面试被问到闭包时，都是回答闭包就是函数包着函数，闭包里的变量不会被销毁而云云等等。并且有很常多初学者都困惑为什么经常被问闭包？好像工作中也不常用到啊。其实问闭包就是要考你的基础扎不扎实，闭包也经常会用到，只是现在很多框架都封装好了，不需要我们直接去建闭包函数了。
几个基础概念的理解 执行环境（execution context)，又称执行上下文，（js高级程序设计书中也称为作用域），指变量或函数执行操作的区域（执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。），分为全局执行环境（window）和函数拥有的局部执行环境。
执行流：从全局执行环境开始，向各个层级的局部执行环境中流去，每流向一个执行环境中就驱动此执行环境的操作（当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境），也象征着程序的执行顺序。
作用域链（scope chain）：规定了对执行环境中的所有变量和函数有序访问的顺序链，此链的开端就是当前执行环境，逐层向外层延伸，末端是全局执行环境。标识符的搜索永远都是从作用域链的开端到末端。
此处有一个重要的设计特点：内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数
闭包理解 于是闭包就出场了，闭包就是将外部执行环境和内部执行环境连接起来的一座桥梁，可以通过闭包创建用于访问内部执行环境变量（私有变量）的特权方法。
闭包的常见方式，就是在一个函数内部创建另一个函数
闭包的应用场景： ● setTimeout 传参
● 模范块作用域
● 不暴露出去的私有变量和特权方法
为何闭包会导致内存泄露？如何回收此内存？ 每个执行环境都有一个表示变量的对象——变量对象，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。
通常，当函数执行完毕后，函数局部的变量对象和作用域链就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。
闭包的情况是：外部函数执行完后，返回了一个匿名函数。此时外部函数的作用域链被销毁了，但是匿名函数的作用域链仍然在引用外部的变量对象。所以外部的变量对象会存在内存中，直到匿名函数被销毁，它才会被销毁。
回收内存的方法是：将此闭包的使用变量设为null，例如：
function bb (){ let a = 'sss' return function(){ let aa = a++ } } let use = bb() // ...... 使用过程 // 使用完后 use = null 根据以上思路分析和回答闭包的面试题是不是有机会脱颖而出呢？如果我有帮助到你，希望可以 三连支持下。
参考文献：
《JavaScript高级程序设计》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95ecebb9e070b227f49bed5cd52b7895/" rel="bookmark">
			python中的除数_python中的除法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先要说的是python中的除法运算：
在python 2.5版本中存在两种除法运算：true除法、floor除法
当使用x/y形式进行除法运算时，如果x和y都是整形，那么运算的会对结果进行截取，取运算的整数部分，比如2/3的运算结果是0；如果x和y中有一个是浮点数，那么会进行所谓的true除法，比如2.0/3的结果是 0.66666666666666663。
另外一种除法是采用x//y的形式，那么这里采用的是所谓floor除法，即得到不大于结果的最大整数值，这个运算时与操作数无关的。比如2//3的结果是0，-2//3的结果是-1，-2.0//3的结果是-1.0。
在python 3.0中，x/y将只执行true除法，而与操作数无关；x//y则执行floor除法。如果需要在2.5版本的python中进行这样的用法，则需要在代码前加入from __future__ import division的声明。如：
Python代码
from __future__ import division
a=2/3
from __future__ import division
a=2/3
这时变量a的结果将是0.66666666666666663，而不是原来的3了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf3eaca82ef60e495275f37d2d0b9ee0/" rel="bookmark">
			PyTorch教程（六）：算数运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import torch a = torch.rand(3,4) # tensor([[0.0422, 0.9152, 0.5486, 0.8753], # [0.3918, 0.6056, 0.0634, 0.9498], # [0.4444, 0.2209, 0.8165, 0.1533]]) b = torch.rand(4) # tensor([0.4145, 0.2913, 0.1655, 0.3705]) a + b # tensor([[0.4567, 1.2065, 0.7141, 1.2458], # [0.8064, 0.8969, 0.2289, 1.3203], # [0.8589, 0.5122, 0.9819, 0.5238]]) torch.add(a,b) # tensor([[0.4567, 1.2065, 0.7141, 1.2458], # [0.8064, 0.8969, 0.2289, 1.3203], # [0.8589, 0.5122, 0.9819, 0.5238]]) torch.all(torch.eq(a+b,torch.add(a,b))) # 判断是不是每一个位置对应的值都形同 tensor(True) torch.all(torch.eq(a-b,torch.sub(a,b))) tensor(True) torch.all(torch.eq(a*b,torch.mul(a,b))) tensor(True) torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf3eaca82ef60e495275f37d2d0b9ee0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57fd5676d53bfdb46da2ee6797c85b8a/" rel="bookmark">
			【机器学习】Ｋ折交叉验证StratifiedKFold的解析与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 作用 分层的K折交叉验证器。
提供训练/测试索引以将数据拆分为训练/测试集。
此交叉验证对象是KFold的变体，它返回分层的折痕。折叠是通过保留每个类别的样品百分比来进行的。
参数解析 n_splits int，默认= 5
折数。必须至少为2。在0.22版中更改：n_splits默认值从3更改为5。
shuffle bool，默认= False
在拆分成批次之前是否对每个班级的样本进行混洗。请注意，每个拆分内的样本都不会被混洗。
random_state int，RandomState实例或无，默认=无
当shuffle为True时，random_state会影响索引的顺序，从而控制每个类别的每个折叠的随机性。否则，保留random_state为None。为多个函数调用传递可重复输出的int值
举例使用 import numpy as np from sklearn.model_selection import StratifiedKFold X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]]) y = np.array([0, 0, 1, 1]) skf = StratifiedKFold(n_splits=2) skf.get_n_splits(X, y) print(skf) StratifiedKFold(n_splits=2, random_state=None, shuffle=False)
for train_index, test_index in skf.split(X, y): print("TRAIN:", train_index, "TEST:", test_index) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76709707b88853c4090b00b714fae663/" rel="bookmark">
			2021年2月19日 Leetcode每日一题：1004. 最大连续1的个数 III
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最大连续1的个数Ⅲ 1.题目描述 给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。
返回仅包含 1 的最长（连续）子数组的长度。
2.示例 示例 1：
输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2 输出：6 解释： [1,1,1,0,0,1,1,1,1,1,1] 粗体数字从 0 翻转到 1，最长的子数组长度为 6。 示例 2：
输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3 输出：10 解释： [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1] 粗体数字从 0 翻转到 1，最长的子数组长度为 10。 3.读题 这一题题意简单明了。数组由数字1和0组成，我们可以将其中任意K个0变成1。我们要找出，将数组中的K个0变成1之后，可以在数组中组成的最长的由连续的1组成的子数组的长度。
4.思路 其实，将K个0转换为1之后，连续的1组成的子数组长度为最长，这个问题可以转换为：
在数组中取一个子数组，其中的0的个数最多为K个，怎样将这个子数组取得最长。 由于涉及到了0的个数最多为K个这样的问题，因此这一题肯定可以用滑动窗口的方法来做。
将窗口的左端点先设定为0，右端点从0开始往右滑动，根据右端点的值以及窗口内0的个数，在右端点滑动的过程中可能有三种情况：
1.右端点处的值为1，此时只需要将右端点继续往右滑动即可。
2.右端点处的值为0且窗口内0的个数小于K个，此时将窗口右端点往右滑动，窗口内0的个数加1。
3.右端点处的值为0且窗口内的0的个数等于K个，此时先将目前窗口的长度的值减一（因为右端点多出了一个0）作为满足题意的子数组长度的极大值来更新最大值，然后左端点向右滑动直到将原有的一个0滑出窗口。
最后，由于存在某次滑动后窗口内的0的个数始终小于等于K直到数组结束这种情况，因此在滑动结束后还需要将当前窗口的长度作为一个极大值，去更新整体的最大值。
4.代码 class Solution { public int longestOnes(int[] A, int K) { int left = 0; int count = 0; int max = 0; for(int r=0;r&lt;A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76709707b88853c4090b00b714fae663/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aaa7fe431dff6bd6ba39f43a43d6233/" rel="bookmark">
			java with_:app:compileDebugJavaWithJavac
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		org.gradle.initialization.ReportedException: org.gradle.internal.exceptions.LocationAwareException: Execution failed for task ':app:compileDebugJavaWithJavac'.
at org.gradle.initialization.DefaultGradleLauncher.doBuildStages(DefaultGradleLauncher.java:139)
at org.gradle.initialization.DefaultGradleLauncher.executeTasks(DefaultGradleLauncher.java:109)
at org.gradle.internal.invocation.GradleBuildController$1.call(GradleBuildController.java:78)
at org.gradle.internal.invocation.GradleBuildController$1.call(GradleBuildController.java:75)
at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:152)
at org.gradle.internal.invocation.GradleBuildController.doBuild(GradleBuildController.java:100)
at org.gradle.internal.invocation.GradleBuildController.run(GradleBuildController.java:75)
at org.gradle.tooling.internal.provider.runner.BuildModelActionRunner.run(BuildModelActionRunner.java:53)
at org.gradle.launcher.exec.ChainingBuildActionRunner.run(ChainingBuildActionRunner.java:35)
at org.gradle.launcher.exec.ChainingBuildActionRunner.run(ChainingBuildActionRunner.java:35)
at org.gradle.tooling.internal.provider.ValidatingBuildActionRunner.run(ValidatingBuildActionRunner.java:32)
at org.gradle.launcher.exec.RunAsBuildOperationBuildActionRunner$1.run(RunAsBuildOperationBuildActionRunner.java:43)
at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:336)
at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:328)
at org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199)
at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:110)
at org.gradle.launcher.exec.RunAsBuildOperationBuildActionRunner.run(RunAsBuildOperationBuildActionRunner.java:40)
at org.gradle.tooling.internal.provider.SubscribableBuildActionRunner.run(SubscribableBuildActionRunner.java:51)
at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:47)
at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:30)
at org.gradle.launcher.exec.BuildTreeScopeBuildActionExecuter.execute(BuildTreeScopeBuildActionExecuter.java:39)
at org.gradle.launcher.exec.BuildTreeScopeBuildActionExecuter.execute(BuildTreeScopeBuildActionExecuter.java:25)
at org.gradle.tooling.internal.provider.ContinuousBuildActionExecuter.execute(ContinuousBuildActionExecuter.java:80)
at org.gradle.tooling.internal.provider.ContinuousBuildActionExecuter.execute(ContinuousBuildActionExecuter.java:53)
at org.gradle.tooling.internal.provider.ServicesSetupBuildActionExecuter.execute(ServicesSetupBuildActionExecuter.java:57)
at org.gradle.tooling.internal.provider.ServicesSetupBuildActionExecuter.execute(ServicesSetupBuildActionExecuter.java:32)
at org.gradle.tooling.internal.provider.GradleThreadBuildActionExecuter.execute(GradleThreadBuildActionExecuter.java:36)
at org.gradle.tooling.internal.provider.GradleThreadBuildActionExecuter.execute(GradleThreadBuildActionExecuter.java:25)
at org.gradle.tooling.internal.provider.ParallelismConfigurationBuildActionExecuter.execute(ParallelismConfigurationBuildActionExecuter.java:43)
at org.gradle.tooling.internal.provider.ParallelismConfigurationBuildActionExecuter.execute(ParallelismConfigurationBuildActionExecuter.java:29)
at org.gradle.tooling.internal.provider.StartParamsValidatingActionExecuter.execute(StartParamsValidatingActionExecuter.java:69)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0aaa7fe431dff6bd6ba39f43a43d6233/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/197bb2f7619d5dc1ae07f1b88a88256e/" rel="bookmark">
			Linux上TCP的几个内核参数调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux作为一个强大的操作系统，提供了一系列内核参数供我们进行调优。光TCP的调优参数就有50多个。在和线上问题斗智斗勇的过程中，笔者积累了一些在内网环境应该进行调优的参数。在此分享出来，希望对大家有所帮助。
调优清单 好了，在这里先列出调优清单。请记住，这里只是笔者在内网进行TCP内核参数调优的经验，仅供参考。同时，笔者还会在余下的博客里面详细解释了为什么要进行这些调优！
tcp_max_syn_backlog,somaxconn,tcp_abort_on_overflow tcp_max_syn_backlog,somaxconn,tcp_abort_on_overflow这三个参数是关于 内核TCP连接缓冲队列的设置。如果应用层来不及将已经三次握手建立成功的TCP连接从队列中取出,溢出了这个缓冲队列(全连接队列)之后就会丢弃这个连接。如下图所示:
从而产生一些诡异的现象,这个现象诡异之处就在于，是在TCP第三次握手的时候丢弃连接
就如图中所示,第二次握手的SYNACK发送给client端了。所以就会出现client端认为连接成功，而Server端确已经丢弃了这个连接的现象！由于无法感知到Server已经丢弃了连接。 所以如果没有心跳的话，只有在发出第一个请求后，Server才会发送一个reset端通知这个连接已经被丢弃了，建立连接后第二天再用，也会报错！所以我们要调大Backlog队列！
echo 2048 &gt; /proc/sys/net/ipv4/tcp_max_syn_backlog echo 2048 &gt; /proc/sys/net/core/somaxconn 当然了，为了尽量避免第一笔调用失败问题，我们也同时要设置
echo 1 &gt; /proc/sys/net/ipv4/tcp_abort_on_overflow 设置这个值以后，Server端内核就会在这个连接被溢出之后发送一个reset包给client端。
如果我们的client端是NIO的话，就可以收到一个socket close的事件以感知到连接被关闭！
注意Java默认的Backlog是50 这个TCP Backlog的队列大小值是min(tcp_max_syn_backlog,somaxconn,应用层设置的backlog),而Java如果不做额外设置，Backlog默认值仅仅只有50。C语言在使用listen调用的时候需要传进Backlog参数。
tcp_tw_recycle tcp_tw_recycle这个参数一般是用来抑制TIME_WAIT数量的,但是它有一个副作用。即在tcp_timestamps开启(Linux默认开启)，tcp_tw_recycle会经常导致下面这种现象。
如果你的Server开启了tcp_tw_recycle，那么别人如果通过NAT之类的调用你的Server的话，NAT后面的机器只有一台机器能正常工作，其它情况大概率失败。具体原因呢由下图所示:
在tcp_tw_recycle=1同时tcp_timestamps(默认开启的情况下),对同一个IP的连接会做这样的限制，也即之前后建立的连接的时间戳必须要大于之前建立连接的最后时间戳，但是经过NAT的一个IP后面是不同的机器，时间戳相差极大，就会导致内核直接丢弃时间戳较低的连接的现象。由于这个参数导致的问题，高版本内核已经去掉了这个参数。如果考虑TIME_WAIT问题，可以考虑设置一下
echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse tcp_syn_retries 这个参数值得是client发送SYN如果server端不回复的话，重传SYN的次数。对我们的直接影响呢就是connet建立连接时的超时时间。当然Java通过一些C原生系统调用的组合使得我们可以进行超时时间的设置。在Linux里面默认设置是5,下面给出建议值3和默认值5之间的超时时间。
下图给出了，重传和超时情况的对应图:
当然了，不同内核版本的超时时间可能不一样，因为初始RTO在内核小版本间都会有细微的变化。所以，有时候在抓包时候可能会出现（3,6,12…)这样的序列。当然Java的API有超时时间:
java: // 函数调用中携带有超时时间 public void connect(SocketAddress endpoint, int timeout) ; 所以，对于Java而言，这个内核参数的设置没有那么重要。但是，有些代码可能会有忘了设置timeout的情况，例如某个版本的Kafka就是，所以它在我们一些混沌测试的情况下，容灾恢复的时间会达到一分多钟，主要时间就是卡在connect上面-_-!，而这时我们的tcp_syn_retries设置的是5，也即超时时间63s。减少这个恢复时间的手段就是:
echo 3 &gt; /proc/sys/net/ipv4/tcp_syn_retries tcp_retries2 tcp_retries2这个参数表面意思是在传输过程中tcp的重传次数。但在某个版本之后Linux内核仅仅用这个tcp_retries2来计算超时时间，在这段时间的重传次数纯粹由RTO等环境因素决定，重传超时时间在5/15下的表现为:
如果我们在应用层设置的Socket所有ReadTimeout都很小的话(例如3s),这个内核参数调整是没有必要的。但是，笔者经常发现有的系统，因为一两个慢的接口或者SQL，所以将ReadTimeout设的很大的情况。
平常这种情况是没有问题的，因为慢请求频率很低，不会对系统造成什么风险。但是，物理机突然宕机时候的情况就不一样了，由于ReadTimeOut设置的过大，导致所有落到这台宕机的机器都会在min(ReadTimeOut,(924.6s-1044.6s)(Linux默认tcp_retries2是15))后才能从read系统调用返回。假设ReadTimeout设置了个5min，系统总线程数是200，那么只要5min内有200个请求落到宕机的server就会使A系统失去响应！
但如果将tcp_retries2设置为5,那么超时返回时间即为min(ReadTimeOut 5min,25.6-51.2s),也就是30s左右，极大的缓解了这一情况。
echo 5 &gt; /proc/sys/net/ipv4/tcp_retries2 但是针对这种现象，最好要做资源上的隔离,例如线程上的隔离或者机器级的隔离。
golang的goroutine调度模型就可以很好的解决线程资源不够的问题，但缺点是goroutine里面不能有阻塞的系统调用，不然也会和上面一样，但仅仅对于系统之间互相调用而言，都是非阻塞IO,所以golang做微服务还是非常Nice的。当然了我大Java用纯IO事件触发编写代码也不会有问题，就是对心智负担太高-_-!
物理机突然宕机和进程宕不一样 值得注意的是，物理机宕机和进程宕但内核还存在表现完全不一样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/197bb2f7619d5dc1ae07f1b88a88256e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/affa8a8edf2103d591f638abf7d23219/" rel="bookmark">
			flink 整合mybatis 并进行单个/批量sink,(不需要mybatis-config.xml！！！)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.依赖
2.编写sink继承 RichSinkFunction
3.MyDataSource 4.BookMapper
5.BookMapper.xml
6.使用
之前看到过其他的关于flink整合mybatis的博客,比如flink 流式处理中如何集成mybatis框架，都用到了一个叫做"mybatis-config.xml" 的全局配置文件，但是我发现这种方式用在flink里面不是很灵活，后来我通过分析mybatis的源码，通过代码将"mybatis-config.xml"给替换掉，这样flink就可以动态加载mapper文件，每个sink可以只是加载和自己相关的mapper,从而减少加载不必要的mapper，使用更灵活。
1.依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt; &lt;/dependency&gt; 2.编写sink继承 RichSinkFunction Slf4j public class BookSink extends RichSinkFunction&lt;List&lt;Book&gt;&gt; { /** * 数据库连接配置 */ private MyDataSource myDataSource; /** * sqlSessionFactory */ private SqlSessionFactory sqlSessionFactory; /*** * @description : 构造传入数据源配置 * @param myDataSource : 数据源配置 */ public BookSink(MyDataSource myDataSource) { this.myDataSource = myDataSource; } @Override public void open(Configuration parameters) throws Exception { //添加需要操作的mapper Set&lt;String&gt; mapperXmls = new HashSet&lt;&gt;(); mapperXmls.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/affa8a8edf2103d591f638abf7d23219/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8336beae22881fd8968fa89295b592b/" rel="bookmark">
			Spring核心技术详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Sring简介 Spring是一个分层的Java SE/EE应用一站式的轻量级开源框架。Spring核心是IOC和AOP。 Spring主要优点包括：
方便解耦，简化开发，通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码造成的程序耦合度高。AOP编程的支持，通过Spring提供的AOP功能，方便进行面向切面编程。声明式事务的支持，在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。方便程序的测试，可以用非容器依赖的编程方式进行几乎所有的测试工作。方便集成各种优秀框架，Spring提供了对各种优秀框架的直接支持。 二、Spring体系结构 如下图所示，整个spring框架按其所属功能可以划分为五个主要模块，这五个模块几乎为企业应用提供了所需的一切，从持久层、业务层到表现层都拥有相应的支持，这就是为什么称Spring是一站式框架的原因。 核心模块(Core Container) Spring的核心模块实现了IoC的功能，它将类和类之间的依赖从代码中脱离出来，用配置的方式进行依赖关系描述。由IoC容器负责类的创建，管理，获取等。BeanFactory接口是Spring框架的核心接口，实现了容器很多核心的功能。
Context模块构建于核心模块之上，扩展了BeanFactory的功能，包括国际化，资源加载，邮件服务，任务调度等多项功能。ApplicationContext是Context模块的核心接口。
表达式语言(Expression Language)是统一表达式语言(EL)的一个扩展，支持设置和获取对象属性，调用对象方法，操作数组、集合等。使用它可以很方便的通过表达式和Spring IoC容器进行交互。
AOP模块 Spring AOP模块提供了满足AOP Alliance规范的实现，还整合了AspectJ这种AOP语言级的框架。通过AOP能降低耦合。
数据访问集成模块(Data Access/Integration ) 该模块包括了JDBC、ORM、OXM、JMS和事务管理：
事务模块：该模块用于Spring管理事务，只要是Spring管理对象都能得到Spring管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事务管理。JDBC模块：提供了一个JBDC的样例模板，使用这些模板能消除传统冗长的JDBC编码还有必须的事务控制，而且能享受到Spring管理事务的好处。ORM模块：提供与流行的“对象-关系”映射框架的无缝集成，包括hibernate、JPA、MyBatis等。而且可以使用Spring事务管理，无需额外控制事务。OXM模块：提供了一个对Object/XML映射实现，将Java对象映射成XML数据，或者将XML数据映射成java对象，Object/XML映射实现包括JAXB、Castor、XMLBeans和XStream。JMS模块：用于JMS(Java Messaging Service)，提供一套“消息生产者、消息消费者”模板用于更加简单的使用JMS，JMS用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 Web模块 该模块建立在ApplicationContext模块之上，提供了Web应用的功能，如文件上传、FreeMarker等。Spring可以整合Struts2等MVC框架。此外，Spring自己提供了MVC框架Spring MVC。
测试模块 Spring可以用非容器依赖的编程方式进行几乎所有的测试工作，支持JUnit和TestNG等测试框架。
三、初识Ioc与DI 我们首先来讲解一下IoC的概念。IoC(控制反转:Inverse of Control)是Spring容器的核心，但是IoC这个概念却比较晦涩，让人不太容易望文生义。
1、IoC控制反转和DI依赖注入 传统程序设计中，我
User user=new User(); user.setName("jack"); 使用接口注入 // 将调用类所有依赖注入的方法抽取到接口中，调用类通过实现该接口提供相应的注入方法
public interface Dao{ public void delete(String name); } public class DapIml implements Dao{ private String name; public void delete(String name){ this.name=name; } } 通过容器完成依赖关系的注入
上面的注入方式都需要我们手动的进行注入，如果有一个第三方容器能帮助我们完成类的实例化，以及依赖关系的装配，那么我们只需要专注于业务逻辑的开发即可。Spring就是这样的容器，它通过配置文件或注解描述类和类之间的依赖关系，自动完成类的初始化和依赖注入的工作。
3、Spring的IoC例子 (1) 创建工程，导入jar包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8336beae22881fd8968fa89295b592b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd7010acc0731b68b98cf1efa0ed5c8f/" rel="bookmark">
			lotus 64GB 扇区 基准测试 CPU 7542
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方版本 results (v28) SectorSize:(68719476736), SectorNumber:(1) seal: addPiece: 2m42.3487588s (403.7 MiB/s) seal: preCommit phase 1: 5h42m16.683602103s (3.191 MiB/s) seal: preCommit phase 2: 35m12.737685509s (31.02 MiB/s) seal: commit phase 1: 370.623904ms (172.7 GiB/s) seal: commit phase 2: 41m46.588277653s (26.15 MiB/s) seal: verify: 9.595716ms unseal: 5h43m33.1876409s (3.179 MiB/s) generate candidates: 773.553µs (80.8 TiB/s) compute winning post proof (cold): 1.989393133s compute winning post proof (hot): 1.746684746s verify winning post proof (cold): 64.315793ms verify winning post proof (hot): 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd7010acc0731b68b98cf1efa0ed5c8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccf520c0d1f47f0055513d0eec373053/" rel="bookmark">
			python fromfile 读取多个文件_使用读取二进制文件np.fromfile文件()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我有一个二进制文件，有许多部分。每个部分都有自己的模式(即整数、浮点和字符串的位置)。在
每个部分的模式是已知的。但是，该模式在部分中出现的次数是未知的。每个记录都在两个相同的整数之间。这些整数表示记录的大小。节名称位于两个整数记录长度变量之间：8和8。在每个部分中，还有多个记录(已知)。在Header
---------------------
Known header pattern
---------------------
8 Section One 8
---------------------
Section One pattern repeating i times
---------------------
8 Section Two 8
---------------------
Section Two pattern repeating j times
---------------------
8 Section Three 8
---------------------
Section Three pattern repeating k times
---------------------
我的方法是：Loop through and read each record using f.read(record_length), if the record is 8 bytes, convert to string, this will be the section name.
Then i call: np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccf520c0d1f47f0055513d0eec373053/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84ed2339db6ad07a93c1a80db6967aae/" rel="bookmark">
			2020版IDEA 常用设置配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.设置隐藏文件类型以及文件夹类型 File–&gt;Settings–&gt;Editor–&gt;File Types–&gt;Ignore Files and Folders
楼主本地配置 如下图
2.去除拼写检查 File–&gt;Settings–&gt;Editor–&gt;Inspections–&gt;Proofreading
去除Typo勾选
3.去除代码重复校验 File–&gt;Settings–&gt;Editor–&gt;Inspections–&gt;General
去除勾选 Duplicated code fragment
4.在Services视图中显示SpringBoot启动类 在services视图中找到这个加号
点击Run Configuration Type
在上面的配置中找到SpringBoot即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/124e1005cf39766991ce768a8a3b721a/" rel="bookmark">
			React学习笔记7：React使用注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. setState setState更新状态的2种写法 方式一：setState(stateChange, [callback])------对象式的setState stateChange为状态改变对象(该对象可以体现出状态的更改)callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用 方式二：setState(updater, [callback])------函数式的setState updater为返回stateChange对象的函数updater可以接收到state和propscallback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。 总结 对象式的setState是函数式的setState的简写方式(语法糖)
使用原则 以下原则只是建议性的，不是强制性的要求
如果新状态不依赖于原状态 ===&gt; 使用对象方式如果新状态依赖于原状态 ===&gt; 使用函数方式如果需要在setState()执行后获取最新的状态数据，要在第二个callback函数中读取 setState同步VS异步问题
setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。
合成事件：就是react 在组件中的onClick等都是属于它自定义的合成事件原生事件：比如通过addeventListener添加的，dom中的原生事件 setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。
setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。
从上图可知，在react中，setState通过一个队列机制实现state的更新。当执行setState时，会把需要更新的state合并后放入状态队列，而不会立刻更新this.state，当进入组件可更新状态时，这个队列机制就会高效的批量的更新state。 import React, { Component } from 'react' export default class Demo extends Component { state = { count: 0 } add = () =&gt; { //方式一：对象式的setState // //1.获取原来的count值 // const { count } = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/124e1005cf39766991ce768a8a3b721a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5cadc436b3e98a6f70f982a2afba56f/" rel="bookmark">
			A Contesting Decision
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程基础——函数调用 1.7:A Contesting Decision 题目：
背景：
一支参赛队的记分由两个部分组成：第一部分是被解出的题数，第二部分是罚时，表示解题总的耗费时间和试题没有被解出前错误的提交所另加的罚时。对于每个被正确解出的试题，罚时等于该问题被解出的时间加上每次错误提交的20分钟罚时。在问题没有被解出前不加罚时。因此，如果一支队伍在比赛20分钟的时候在第二次提交解出第1题，他们的罚时是40分种。如果他们提交第2题3次，但没有解决这个问题，则没有罚时。如果他们在120分钟提交第3题，并一次解出的话，该题的罚时是12分。这样，该队的成绩是罚时160分，解出了两道试题。冠军队是解出最多试题的队伍。如果两队在解题数上打成平手，那么罚时少的队是冠军队。
输入：
• 程序评判的程序设计竞赛有4题。本题设定，在计算罚时后，不会导致
队与队之间不分胜负的情况。
• 第1行 为参赛队数n • 第2 - n+1行为每个队的参赛情况。每行的格式
• &lt; Name &gt; &lt; p1Sub &gt; &lt; p1Time &gt; &lt; p2Sub &gt; &lt; p2Time &gt; … &lt; p4Time &gt; • 第一个元素是不含空格的队名。后面是对于4道试题的解题情况（该队
对这一试题的提交次数和正确解出该题的时间（都是整数））。如果 没有解出该题，则解题时间为0。如果一道试题被解出，提交次数至少
是一次。
输出：
• 输出一行。给出优胜队的队名，解出题目的数量，以及罚时。
试题分析：
•本题需要用到结构体录入每个参赛人员的信息，包含参赛队名、4道题提交次数、4道题解时间、解题数，以及总罚时。
样例：
Sample Input：
4
Stars 2 20 5 0 4 190 3 220
Rockets 5 180 1 0 2 0 3 100
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5cadc436b3e98a6f70f982a2afba56f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bab113712664caa876266e09479a961/" rel="bookmark">
			论文笔记：SIGIR 2020 Next-item Recommendation with Sequential Hypergraphs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在推荐系统中，往往可以通过用户交互序列来动态获取用户的偏好。物品的语义信息往往随着时间和用户发生改变，因此为了更加有效的从用户动态的交互序列中抽取特征完成物品语义信息的更新，本文提出了一种针对于 next-item 推荐的框架，其主要基于序列超图完成推荐。
从图中可以看出来，用户的交互行为随着时间动态变化，而且同一物品随着用户交互行为的变化，对于其语义信息的表示也会随着变化。
该模型的主要特点如下：
基于动态的用户交互序列建模超图来表达短期的物品相关性，应用多种类型的卷积层来捕获超图中的多阶关系。利用残差控制层来建模不同时期的连接关系来体现交互序列动态的特点。在将其输入到动态用户建模的自我关注层之前，设计了一个融合层将动态项目嵌入和短期用户意图结合到每个交互的表示中。 论文链接：https://people.engr.tamu.edu/caverlee/pubs/wang20next.pdf
github：https://github.com/wangjlgz/HyperRec
1. Motivation Items emerge and disappear frequently
作者在国外的 Etsy 测试了物品的生命周期，Etsy 是销售手工制品的最大电子商务平台之一，在图2 (a)中，作者总结了2006年至2018年 Etsy上 列出的所有商品的活动时间，即第一次购买和最后一次购买之间的时间间隔。Etsy中有超过一半的产品在不到一年的时间内处于非活跃状态(很少被人们购买或者点击)。在其他在线平台上也可以找到类似的模式。随着项目的频繁出现和消失，短期关系对于项目建模可能是至关重要的，而从长期的角度来看，项目之间的关系是不稳定的。总结一下就是作者认为，建模短期用户行为序列更加可靠，长期的行为序列将伴随大量的不可靠关系。
The popularity of items changes rapidly along time
作者检索2001年至2005年每个月在亚马逊上最畅销的商品(即排名前1%的商品)。然后计算每个月的畅销书列表与1个月、2个月、3个月、8个月、1年或更长时间后的畅销书之间的Jaccard相似性。在图2 (b)中，如图蓝线所示，连续月份之间的畅销书销量交集仅在30%左右。而且，在6个月的时间间隔后，这两份畅销书名单几乎没有重叠(与Jaccard相似性不到10%)。虽然一个物品的受欢迎程度可以反映用户群体如何看待该物品，但一段时间内的畅销书列表的变化表明，社区中物品的含义可能会随着时间的变化而变化。
The co-occurrence of items changes temporally
Goodreads 是一个用户分享他们对书籍想法的平台。每个用户都有一个条目序列，这些条目是按照时间顺序通过评级、标记或评论与用户进行交互的。作者根据时间戳(按年)分割用户交互的项目序列，并用不同年份的序列训练不同的项目嵌入模型。作者采用 word2vec 生成基于条目共现的图书嵌入(即用户因此阅读的图书)。在这些嵌入的基础上，找到了每本书在不同年份的前10位邻居。然后计算每本书的Jaccard相似邻居，通过曲线可以发现物品之间的关系是随时间变化的，而且时间差越长，变化越大。
综上所述，从长远的角度来看，物品之间的关系持续发生变化，导致物品的语义发生变化。因此，在为下一项推荐建模它们的动态模式时，利用项目之间的短期相关性具有充足的可解释性。
3. HyperRec 本文提出的模型是基于用户交互超图，在建模随着时间和用户变化的动态关系时合并短期物品相关性。换句话说就是根据用户交互序列建模超图来捕获随着时间和用户喜好变化的动态关系，然后从超图中进行信息提取得到短期物品的相关性来辅助进行物品嵌入完成推荐。
3.1 Problem Setting 设 N N N 个用户的用户集为 U = { u 1 , u 2 , … , u N } \mathbf{U}=\{u_1,u_2,\dots,u_N\} U={u1​,u2​,…,uN​}， P P P 个物品的物品集为 I = { i 1 , i 2 , … , i P } \mathbf{I}=\{i_1,i_2,\dots,i_P\} I={i1​,i2​,…,iP​}，设置 Q Q Q 个不同的时间戳 T = { t 1 , t 2 , … , t Q } \mathbf{T}=\{t_1,t_2,\dots,t_Q\} T={t1​,t2​,…,tQ​}，每一个时间戳 t n ∈ T t_n \in \mathbf{T} tn​∈T 相当于某一段短时间。对于每一个用户，设置用户交互序列表示为 L u = { ( i 1 u , t 1 u ) , ( i 2 u , t 2 u ) , … , ( i ∣ L u ∣ u , t ∣ L u ∣ u ) } \mathbf{L}^u=\{(i_1^u,t_1^u),(i_2^u,t_2^u),\dots,(i_{|\mathbf{L}^u|}^u,t_{|\mathbf{L}^u|}^u)\} Lu={(i1u​,t1u​),(i2u​,t2u​),…,(i∣Lu∣u​,t∣Lu∣u​)}，其中 ( i n u , t n u ) (i_n^u,t_n^u) (inu​,tnu​) 代表在时间戳 t n u t_n^u tnu​ 的范围内用户 u u u 与物品 i n u i_n^u inu​ 产生了交互。物品嵌入初始表示为 E = [ e 1 , e 2 , … , e P ] \mathbf{E}=[\mathbf{e}_1,\mathbf{e}_2,\dots,\mathbf{e}_P] E=[e1​,e2​,…,eP​]，物品的嵌入与他们的 ID 有关，并且随着模型迭代是可训练的，但是用户的嵌入在不同的时间戳中保持不变。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bab113712664caa876266e09479a961/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16f35598a124ec039e1b0c0f5312a42a/" rel="bookmark">
			Simple Addition
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程基础——函数调用 1.6：Simple Addition 题目：
输入
• 输入包含若干行。每行给出两个非负整数p和q（p≤q），这两个整数之间用一个空格隔开，p和q是32位有符号整数。输入由包含两个负整数的行结束。程序不用处理这一行。
++++输出
• 对于每行输入，输出一行，给出S(p, q)的值。
试题分析：
•例如，求S(2, 53)，将范围划分为3个区间：[2, 9]，[10, 50]和[51, 53]。
• 对于第1个区间[2, 9]，个位数之和2+3+4+……+9=44；对于第2个区间[10, 50]，个位数之(1+2+……+9)4= 454 = 180；对于第3个区间[51, 53]，个位数之和1+2+3 = 6。所以，第一轮，位数的总和为44+180+6 = 230。
• 在[10, 50]中，10, 20, 30, 40和50的个位数是0，将这些数除以10后 得1, 2, 3, 4, 5，产生新区间[1, 5]；进入第二轮，区间[1, 5]中的数只有个位数，个位数之和1+2+3+4+5=15。
• 最后，两轮结果相加，得S(2, 53)=230+15=245。
注意点：
• 利用函数求出该区间中每位数的和
•一个一个算，时间复杂度太大，会超时
样例：
Sample Input
1 10
10 20
30 40
-1 -1
Sample Output
46
48
52
#include &lt;stdio.h&gt;//调用函数实现递归求范围内数的每一位的和 暗含时间复杂度问题 long long f(long long a){ if(a==0) return 0; else if(a%10) return a%10;//返回个位数 else return f(a/10); //返回十位数 } long long fact(int n,int m){ int sum=0,i; if(m-n&lt;9) {//范围相差九依次相加 for(i=n;i&lt;=m;++i) sum+=f(i); } while(n%10){//从n到比n大的最小整数个位数的和 sum+=f(n); n++; } while(m%10){//从m到比m小的最大整数个位数的和 sum+=f(m); m--; } sum+=45*(m-1)/10;//n到m之间整十中个位数的和 fact(n/10,m/10);//进行下一位的计算 return sum; } int main () { int m,n; while(~scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16f35598a124ec039e1b0c0f5312a42a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/158ca190cafbed6127ba11f4dd5790fb/" rel="bookmark">
			Tic Tac Toe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程基础——函数调用 1.3：Tic Tac Toe 题目：
输入
• 输入的第一行给出N，表示测试用例的数目。然后给出
4N-1行，说明N个用空行分隔的网格图。
输出
• 对于每个测试用例，在一行中输出"yes"或"no"，表示该
网格图是否是有效的三连棋游戏的一个步骤。
试题分析：
有效的三连棋一定满足如下特征：
•o的数量一定&lt;=x的数量
•如果x的数量比o的数量多1，那么不可能o赢
•如果x和o的数量相等，则不可能是x赢。
调用fact函数判断是谁赢并返回相应的类型
根据说给的特征进行执行
注意点：
•c语言不可以返回bool类型
•三目运算符比if语句更简单
t=fact（t）？1：0 ——t是否返回相应的类型，如果是t=1，否则t=0；
二维数组可以将一维数组看成是字符串
样例：
Sample Input
2
X.O
OO.
XXX
O.X
XX.
OOO
Sample Output
yes
no
c
#include &lt;stdio.h&gt; char a[3][3]; int fact(char c){//调用函数实现赢的情况 int i; for(i=0;i&lt;3;++i){ if(a[0][i]==c){ if(a[1][i]==c&amp;&amp;a[2][i]==c) return 1;//竖排相同 } } for(i=0;i&lt;3;++i){ if(a[i][0]==c){ if(a[i][1]==c&amp;&amp;a[i][2]==c) return 1;//横排相同 } } if(a[0][0]==c&amp;&amp;a[1][1]==c&amp;&amp;a[2][2]==c) return 1;//两条对角线相同 if(a[2][0]==c&amp;&amp;a[1][1]==c&amp;&amp;a[0][2]==c) return 1; return 0; } int main () { int k; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/158ca190cafbed6127ba11f4dd5790fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2b79458670e3df6119a281eef1517de/" rel="bookmark">
			mysql5.6主从不报错_mysql5.6 主从配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考网址：http://www.cnblogs.com/zhoujie/p/mysql1.html
http://kerry.blog.51cto.com/172631/277414/
1、配置主库：
1)、授权给从数据库服务器
mysql&gt;GRANT REPLICATION SLAVE ON *.* to 'rep1'@'192.168.8.11' identified by 'test123456';
mysql&gt;FLUSH PRIVILEGES;
2)、修改主库配置文件，开启binlog，并设置server-id，每次修改配置文件后都要重启mysql服务才会生效
vim /etc/my.cnf
在该配置文件[mysqld]下面添加下面内容：
[mysqld]
log-bin=/var/lib/mysql/binlog
server-id=1
binlog-do-db =cmdb
datadir=/var/lib/mysql
socket=/var/lib/mysql/mysql.sock
......
server-id：master端的ID号；
log-bin：同步的日志路径及文件名，一定注意这个目录要是mysql有权限写入的(我这里是偷懒了，直接放在了下面那个datadir下面)；
binlog-do-db：要同步的数据库名
还可以显示 设置不同步的数据库：
binlog-ignore-db = mysql 不同步mysql库和test库
binlog-ignore-db = test
修改配置文件后，重启服务：service mysqld restart
mysql&gt;show master status;+---------------+----------+--------------+------------------+
| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+---------------+----------+--------------+------------------+
| binlog.000001 | 1304 | cmdb | |
+---------------+----------+--------------+------------------+
1 row in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2b79458670e3df6119a281eef1517de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27fee8f58218288c5f59df59dbf46358/" rel="bookmark">
			“xcodebuild“ command but it exited with error code 65 和 ‘event2/event-config.h‘ file not found 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近新开发ReactNative项目又遇到新问题了，error Failed to build iOS project. We ran "xcodebuild" command but it exited with error code 65.
打开testApp.xcworkspace编译出现'event2/event-config.h' file not found 经查阅是因为Flipper-Folly版本导致的，将Podfile 文件 修改如下
use_flipper! 修改为 use_flipper!({ 'Flipper-Folly' =&gt; '2.3.0' }) 然后删除Podfile.lock，然后重新 pod install
installed 后 返回上一次目录执行 yarn ios 就可以启动了
解决方案来自：https://github.com/facebook/react-native/issues/30836#issuecomment-772830882
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/437c5babc01b6c088fc58feadd66f441/" rel="bookmark">
			基本运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本运算符 优先级：一元运算符以及括号内的表达式&lt;–二元运算符&lt;–位运算符&lt;–赋值运算符和扩展赋值运算符；
​ 一元运算符以及括号内的表达式&lt;–二元运算符&lt;–条件运算符;
​ 一元运算符以及括号内的表达式&lt;–二元运算符&lt;–关系运算符&lt;–逻辑运算符;
二元运算符：“*”号表示乘法，“/"表示除法。
一元运算符：”++“表示在自身加1，”–“表示在自身减1。“%”表示取余，如：13%5==3。
关系运算符：“!=”表示不等于，“&gt;=”表示大于等于，“&lt;=”表示小于等于。
逻辑运算符：”&amp;&amp;“表示与，”||”表示或，“！”表示非,遵循短路运算
位运算符：&amp;,|,^,~分别表示位运算的与，或，异或，非（取反）；&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;分别表示位运算的有符号右移，左移，无符号右移（有符号右移若为整数移完后最高位为0，若为负数移位后最高位为1。无符号右移无论正负最高位都为0。
三元运算符——条件运算符“?:”。例如：若x=10,表达式x&lt;8?y=1:y=2;的值为y=2;即判别式结果为真则取“:”号前面的式子，否则取“:”号后面的式子。
扩展赋值运算符：例如：a+=b等价于a=a+b。-=，*=，/=与+=类似。
今天学到:一个快捷键Ctrl+D:复制当前行到下一行；
字符串连接符”+“，String
​ int n=10;
​ int m=20
​ System.out.println(""+n+m);//输出1020
​ System.out.println(n+m+"");//输出30
​ //"“符号在前，则它会把+号连接的数据变成String类型，”"符号在后不会改变前面+号连接的数据；
package operator; public class yunsuanfu { public static void main(String[] args) { //二元运算符 //Ctrl+D:复制当前行到下一行 int a=10; int b=20; int c=25; int d=25; System.out.println(a+b); System.out.println(a-b); System.out.println(a*b); System.out.println(a/(double)b); System.out.println("====================="); long q=1221212L; int w=123; short e=32766; //short型的范围是-32768~32767 byte r=8; double t=1.1; System.out.println(q+w+e+r);//Long Long型和int、short、byte型运算会得到Long型 System.out.println(w+e+r);//Int System.out.println(e+r);//Int short和byte型运算会得到int型 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/437c5babc01b6c088fc58feadd66f441/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c3cba259594823d87a427bdf1da9c28/" rel="bookmark">
			latex如何设置字体并加粗_LaTex中文字体加粗的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 字体加粗原理。
打开c/windows/fonts目录，以图标形式查看，我们可以发现有的图标是一张纸的样子，有的图标是几张纸叠着的样子。双击几张纸样子的图标，比如Arial，发现里面有很多个文件，有的文件名带黑体，说明对于Arial，字体文件单独区分了常规体和粗体。
我浏览了一下，发现英文大多数都单独定义了粗体，斜体，但是中文字体只有很少的会单独定义，只有雅黑和等线。
那么没有定义的字体，在加粗时，其实是软件做了简单地描边，效果肯定没有单独定义的好。
2. LaTex字体概念
LaTex字体有三个维度：
font family 字体族：分为rm罗马，sf无衬线，tt打字机三种。默认是rm。
(这个其实很少)
font shape 形状：如直立，倾斜。
font series 加粗
以上很难满足对多种字体的选择需要，尤其是针对中文，我们的做法是分两步，一是选三种较常用的字体，设为上面的三种字体族：
\setCJKmainfont{SimSun} %对应rm罗马
\setCJKsansfont{SimHei}%对应sf无衬线
\setCJKmonofont{FangSong}%对应tt打字机
这样就可以使用rmfamily, sffamily这样已有的命令来指定字体；
二是自己设定新的字体族:
\setCJKfamilyfont{yh}{Microsoft YaHei}
然后要自定义命令：
\newcommand{\yh}{\CJKfamily{yh}}
(英文字体的设定方法略)
2. LaTex加粗命令
textbf和bfseries是一样的加粗命令，只是使用方式不同。
对于单独定义了粗体的字体，这个命令无论对中文还是英文都是有效的。
对于没有单独定义粗体的字体，我们只说中文：
如果没有使用setCJKmainfont或setCJKfamilyfont，那么对默认字体(不使用\songti这些命令)使用加粗命令时，得到的是黑体，因为默认的中文字体族是rm，其正常字体是宋体，粗体是黑体。其实并不是我们想要的加粗效果，因为这个已经改变字体了。
如果使用setCJKmainfont，可以加上AutoFakeBold这个参数，来实现加粗效果：
\setCJKmainfont{SimSun}[AutoFakeBold,ItalicFont=KaiTi]
还有一种方式，可以直接指定加粗的字体，就是设置BoldFont=，但是我并没有遇到这个的应用场合。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8ff2e3f8ffc042f67929670f9383270/" rel="bookmark">
			ArcGIS提取道路中心线数据制图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArcGIS提取道路中心线数据 数据采集 最近在学习地理国情检测数据的采集，依次矢量化建筑物区域、大坝、农田、水系之后，为了方便，就采用了裁剪的方式提取道路区域，采集到的数据制图的最终结果如下图所示，采集结果有点丑，见谅见谅。
栅格二值化 由于道路矢量化的结果为面状，需要提取道路中心线作为地理国情要素数据。将道路数据设置为纯色，去除轮廓线，如图所示。
保存为TIF格式
选择【文件】→【导出地图】，以.tif格式导出道路矢量化数据，在“格式”选项卡中设置颜色模式为“1位单色阈值”，单击【确定】按钮，如图所示。
新建线要素图层“Road.shp”，打开导出的道路栅格数据，右击选择属性，在选项卡“符号系统”中将数据进行重分类，如图所示，设置为0和1两类。
提取中心线 打开编辑器，选择【自定义】→【工具条】→【ArcScan】，在ArcScan工具条中选择【矢量化】→【选项】，矢量化方法点选“中心线”，如图所示。
提取中心线结果 设置完成后预览中心线提取效果，达到效果后点击工具条上的【在区域内部生成要素】按钮，生成道路中心线，结果如图 3-32所示。
补全道路中心线 上图中提取得到的道路中心线整体完成度在80%以上，但仍有10%左右未完成，需要手动补全，打开编辑器，进行补全，最终结果如图 3-33所示。
符号修饰 将道路中心线数据进行入库，并对道路线进行符号修饰的最终结果如下图所示。
设置道路双线符号结果如下图所示。
按照道路宽度进行分级渲染，结果如下图所示。
专题制图 最后一步就是专题制图啦，制图的最终结果如下图所示，讲道理，配色还行吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b82573c36f10b7a668fd965c3c7600c3/" rel="bookmark">
			Java 实现zip文件解压
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话不多说直接上代码，如有任何问题欢迎大家留言指导。
import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.util.ArrayList; import java.util.List; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; import org.apache.log4j.Logger; public class ZipCompressUtil { private static final Logger logger = Logger.getLogger(ZipCompressUtil.class); /** * 判断该路径下是否有文件,并将文件名称保存 * @param filePath * @return */ public static List&lt;String&gt; getFileName(String filePath) { List&lt;String&gt; fileNameArr = new ArrayList&lt;String&gt;(); File f = new File(filePath); if (!f.exists()) { logger.info(filePath + " not exists"); return fileNameArr; } File fa[] = f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b82573c36f10b7a668fd965c3c7600c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30fb3cf9cf0df2ad6b89a9ea706a8886/" rel="bookmark">
			java服务器gc停顿,在生产Java服务器中打开GC日志记录是否常见？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I see in a few places [1] people start the GC logging in production servers (mission critical), e.g.
java -server -Xms1024m -Xmx1024m -XX:NewSize=256m \
-XX:MaxNewSize=256m \
-XX:+UseConcMarkSweepGC \
-XX:CMSInitiatingOccupancyFraction=70
-XX:+PrintGCDetails \
-XX:+PrintGCDateStamps \
-XX:+PrintTenuringDistribution \
-Xloggc:logs/gc.log \
-Djava.awt.headless=true
-Dcom.sun.management.jmxremote -classpath ...
Is it recommend practices in production env these days?
Update: I have included a link [2] from Oracle also suggest to monitor GC on production servers.
Sources:
解决方案
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30fb3cf9cf0df2ad6b89a9ea706a8886/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d3cefc1026374c8c4b8d8cba517ee13/" rel="bookmark">
			什么是计算机病毒？是怎么产生的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 其他
前言 博主介绍：
– 我是了 凡 微信公众号【了凡银河系】期待你的关注。未来大家一起加油啊~
文章目录 文章目录前言什么是病毒？病毒的介绍病毒的分类附带型病毒蠕虫病毒可变病毒 有哪几种类病毒系统病毒蠕虫病毒木马病毒脚本病毒宏病毒 常见的病毒爱虫病毒Funlove病毒CIH病毒YAL 病毒圣诞节病毒 是怎么产生的？第一第二第三 什么是病毒？ 病毒的介绍 1、计算机病毒与其他合法程序一样，是一段可执行程序，但它不是一个完完整的程序，而是寄生在其他可执行程序上，当执行这个程序时，病毒就其破坏作用
2、他们能把自身附着在各种类型的文件上，当文件被复制或从一个用户传送到另一个用户时，它们就随同文件一起蔓延开来
3、传染性是病毒的基本特征，一旦网络中一台计算机中了病毒，则这台计算机中的病毒就会通过各种渠道从已被感染的计算机扩散到没有感染的计算机上，以实现自我繁殖
4、一个标志精巧的计算机病毒程序，进入系统之后一般不会马上发作、而是潜伏在合法文件中。它们一般可以潜伏很长时间不被人发现。病毒的潜伏性越好，其在系统中的存在时间就会越长，病毒的传染范围就会越大
5、是指病毒因某个时间或数值的出现，诱使病毒实施感染或进行攻击的特性
6、计算机中毒后，可能会导致正常的程序无法运行，把计算机内的文件删除或使计算机文件受到不同程度的损坏
7、计算机病毒具有很强的隐藏性，有的可以通过杀毒软件检查出来，有的根本就查不出来，后面这一类病毒处理起来通常很困难
病毒的分类 附带型病毒 通常附带于一个EXE文件上，其名称与EXE文件名相同，但扩展是不同的，一般不会破坏更改文件本身，但在DOS读取时首先激活的就是这类病毒
蠕虫病毒 它不会损害计算机文件和数据，它的破坏性主要取决于计算机网络的部署，可以使用计算机网络从一个计算机存储切换到另一个计算机存储来计算网络地址来感染病毒
可变病毒 可以自行应用复杂的算法，很难发现，因为在另一个地方表现的内容和长度是不同的
有哪几种类病毒 系统病毒 系统病毒的前缀为：Win32、PE、Win95、W32、W95等。这些病毒的一般公有的特性是可以感染windows操作系统的 .exe 和.dll 文件，并通过这些文件进行传播。如CIH病毒
蠕虫病毒 蠕虫是一种可以自我复制的代码，并且通过网络传播，通常无需人为干预就能传播。蠕虫病毒入侵并完全控制一台计算机之后，就会把这台机器作为宿主，进而扫描并感染其他计算机。当这些新的被蠕虫入侵的计算机被控制之后，蠕虫会以这些计算机为宿主继续扫描并感染其他计算机，这种行为会一直延续下去。蠕虫使用这种递归的方法进行传播，按照指数增长的规律分布自己，进而及时控制越来越多的计算机
木马病毒 木马病毒是指隐藏在正常程序中的一段具有特殊功能的恶意代码，是具备破坏和删除文件、发送密码、记录键盘和攻击Dos等特殊功能的后门程序。木马病毒其实是计算机黑客用于远程控制计算机的程序，将控制程序寄生于被控制的计算机系统中，里应外合，对被感染木马病毒的计算机实施操作。一般的木马病毒程序主要是寻找计算机后门，伺机窃取被控计算机中的密码和重要文件等。可以对被控计算机实施监控、资料修改等非法操作。木马病毒具有很强的隐蔽性，可以根据黑客意图突然发起攻击
脚本病毒 脚本病毒是主要采用脚本语言设计的计算机病毒。现在流行的脚本病毒大都是利用JavaScript和VBScript脚本语言编写。实际上在早期的系统中，病毒就己经开始利用脚本进行传播和破坏，不过专门的脚本型病毒并不常见。但是在脚本应用无所不在的今天，脚本病毒却成为危害最大、最为广泛的病毒，特别是当它们和一些传统的进行恶性破坏的病毒如CIH相结合时其危害就更为严重了。随着计算机系统软件技术的发展，新的病毒技术也应运而生，特别是结合脚本技术的病毒更让人防不胜防，由于脚本语言的易用性，并且脚本在现在的应用系统中特别是Internet应用中占据了重要地位，脚本病毒也成为互联网病毒中最为流行的网络病毒
宏病毒 宏病毒是一种寄存在文档或模板的宏中的计算机病毒。一旦打开这样的文档，其中的宏就会被执行，于是宏病毒就会被激活，转移到计算机上，并驻留在Normal模板上。从此以后，所有自动保存的文档都会“感染”上这种宏病毒，而且如果其他用户打开了感染病毒的文档，宏病毒又会转移到他的计算机上
常见的病毒 爱虫病毒 爱虫病毒(Vbs.loveletter)，又称“我爱你”(I Love You)病毒，是一种蠕虫病毒，它与1999年的梅丽莎病毒非常相似。据称，这个病毒可以改写本地及网络硬盘上面的某些文件。用户机器染毒以后，邮件系统将会变慢，并可能导致整个网络系统崩溃，当时在全球更是造成了百亿美元的损失
Funlove病毒 这是WIN32类型的病毒，它可以感染Windows 9x和Windows NT 4.0操作系统的计算机，并感染所有WIN32类型的文件(PE文件)，如Windows和Program Files目录及其子目录中的扩展名为。EXE、.SCR和。OCX的文件。该病毒搜索所有具有写访问的网络共享文件夹并感染那里的所有文件，同时能够修补NT环境的完整性检测，以便能够感染系统文件
CIH病毒 CIH病毒是一种能够破坏计算机系统硬件的恶性病毒。这个病毒产自台湾，原集嘉通讯公司（技嘉子公司）手机研发中心主任工程师陈盈豪在其于台湾大同工学院念书期间制作。最早随国际两大盗版集团贩卖的盗版光盘在欧美等地广泛传播，随后进一步通过网络传播到全世界各个角落
YAL 病毒 YAI(YouAnd l是第一个国内编写的大规模流行的“黑客”病毒，它是由重庆的一位叫杜江的大学生编写的。YAl(backdoor)属于文件型病毒，通过各种存储介质和因特网传播，主要以右键附件的形式传递。在YAl(backdoor)病毒感染Windows系统的可执行文件并执行了染毒文件后，系统没有任何特殊现象，即在毫无征兆的情况下能够将病毒激活，使之侵入系统。当染毒文件*.exe被运行后，会在当前目录下生成*.TMP和*.TMP.YAr 两个文件，同时此病毒自动搜索系统内的可执行文件，并将这些可执行文件感染。
圣诞节病毒 圣诞节病毒往往以一些祝福语、情话为幌子，发送带毒的邮件或链接。圣诞节病毒“Navidad”一般以“NAVIDAD ．EXE ”为文件名，以电子邮件附件形式或者通过QQ和MSN等聊天软件进行传播。发送。计算机一旦感染上这一病毒，它将自动改写Windows 的注册表，改变扩展名为“．EXE ”的可执行程序的链接指向，并导致电脑系统绝大部分程序无法运行。
节假日已经成为木马病毒大肆作案的挡箭牌，大量木马病毒打着节假日的幌子招摇撞骗，很多电脑用户一不小心就步入了病毒设计好的陷阱，也常常因此蒙受经济上的损失。12月21日，金山毒霸等反病毒厂商纷纷发布圣诞节病毒预警，而今年的圣诞节，MSN相册、瓢虫病毒等似乎来的更早，危害性更是不容小觑。圣诞节、情人节等国外传来的节日最容易被病毒利用，而在这些特殊的日子里，用户一般警惕性不高，或者有某种需要下载各种电子贺卡、下载各种动听的手机铃声，非常搞笑或者诱人的动漫传情图片，这很容易遭遇木马病毒的入侵。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d3cefc1026374c8c4b8d8cba517ee13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c61ac0b4be28de87a9f5423452468215/" rel="bookmark">
			java 原子类能做什么_Java原子类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CAS
什么是CAS,CAS就是Compare and Swap
CAS是一种无锁算法
原理：
对CAS的理解，CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。
举个例子，表示一下CAS的原理。假设t1在与t2线程竞争中线程t1能去更新变量的值，而其他线程都失败。(失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次发起尝试)。t1线程去更新变量值改为57，然后写到内存中。此时对于t2来说，内存值变为了57，与预期值56不一致，就操作失败了(想改的值不再是原来的值)。
代码：
public final int getAndAddInt(Object var1, long var2, int var4) {
//1 操作的对象，2 对象中字段的偏移量，3 原来的值，4 要修改的值。
int var5;
do {
var5 = this.getIntVolatile(var1, var2);//得到当前的值。
} while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
return var5;
}
上面的代码是原子类中的一个例子。
ABA问题：
CAS乐观锁机制确实能够提升吞吐，并保证一致性，但在极端情况下可能会出现ABA问题。就是期望值被从A改为B,又从B改为A.CAS还能成功。
解决方法：加版本号。
二、原子类
原子类，顾名思义就是不可分割的，当原子类去执行操作的话是一步合成的。
以前的时候我们并发操作的时候，回去选择加锁。加锁还是有很多影响的。比如：性能损耗、逻辑复杂。所以在JDK1.5的时候Doug Lea写了原子类，也是在JUC包下。
1、原子类介绍
1.1、原子更新基本类型
下面是三种基本原子类型，以及他们常用的API。
AtomicInteger atomicInteger = new AtomicInteger(1);
atomicInteger.getAndAdd(1); //以原子方式将给定值添加到当前值。
atomicInteger.compareAndSet(1,2); //如果当前值==期望值，则以原子方式将该值设置为给定的更新值。
atomicInteger.get(); //获取当前值
atomicInteger.getAndIncrement(); //以原子方式将当前值增加一。
atomicInteger.getAndDecrement(); //以原子方式将当前值减一。
atomicInteger.addAndGet(2); //以原子方式将给定值添加到当前值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c61ac0b4be28de87a9f5423452468215/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa71ca8da5629961e294bcd3f2452f73/" rel="bookmark">
			java web常见异常_javaweb中一下常见的错误及排查方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习中总碰到一些错误，不想再次碰到还是无法解决，所以记录一下
一、一些傻瓜型的错误
1.
上图为redis没开，导致数据写入失败
解决方法：
这个很简单，直接打开Redis服务器就行
2.
Native Method 无法得到方法，这个现在暂时看到的问题是：
这个地方 没有写得到连接池的方法,这个错误还是需要补充 下，现在发现这个异常只要参数，还有方法错误都会报这个错误，所以出现这个异常时要仔细观察方法和参数是否正确，还有前面的参数是否传进来
解决方法：
下次第一时间看这边括号内有没有写JdbcUtils.getDataSource();
3.今天连续找了三个小时的bug,真的是想吐血，问题出在前端，都是前端一般不报错，所以写错一个单词真的太难发现，后面找同学才被发现，结果确只是少写一个单词，不过还是在他那学到了一点东西
上图的问题就是在前端大小写的问题，面对这种问题太难发现
解决方法：
这是同学给出的解决方法：利用弹窗对传进来的参数进行查看，看是否有数据传过来，对于我现在来说确实是不错的方法，很nice
总结：后面还有一些错误会持续记录，已便于查询，常见错误还有一些大小写错的，方法名写错的，数据库配置文件路径写错的，前端单词写错导致按钮无反应的问题，最常用的解决办法是先用debug进行筛选，先判断是前端还是后端的问题，根据传递的参数进行逐一排查
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/327/">«</a>
	<span class="pagination__item pagination__item--current">328/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/329/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>