<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f9660c3cfa72403a3a29d00275d4c3a/" rel="bookmark">
			超简单--搭建http、https代理服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建http、https代理服务器 服务器配置 yum install -y squid vim /etc/squid/squid.conf
#默认是3128 http_port 3228 #http_access deny all #注释掉该行 http_access allow all # 添加 ，为容许全部ip systemctl start squid
systemctl status squid
systemctl enable squid
日志位置
/var/log/squid
服务器搭建完成
客户机侧配置 linux主机配置 //编辑配置文件
vi /etc/profile
//在该配置文件的最后添加代理配置
# 代理服务器ip地址和端口号 export http_proxy='http://ip:port' export https_proxy='http://ip:port' // 退出profile文件并保存
source /etc/profile // 使配置文件生效
普通PC电脑 直接在浏览器或网络代理处配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2db83e9124faa22ff09f72532d8fb418/" rel="bookmark">
			java!jsonobject获取key！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSONObject jsonObject =这个按你的来
for (Map.Entry entry : jsonObject.entrySet()) {
Object keyName = entry.getKey();//键名
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dfec85021633c3d381349414d430e40/" rel="bookmark">
			ImportError: libffi.so.7: cannot open shared object file: No such file or directory解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本机环境Centos7，Arch Linux方法与本文提出解决方案不同。
在linux中强制将Anaconda进行更新或者对Python强制更新时，
conda update --force conda 使得原机器的python3.6.4版本升级成最新的Anaconda附带python3.6.10版本，出现Importer break的情况，如下所示：
ImportError: libffi.so.7: cannot open shared object file: No such file or directory 究其原因是其源码编译错误，自然考虑到编译文件。首先找到libffi文件所在位置，libffi文件是一个二进制源码。如图中所示，其所在位置为anaconda下的lib目录内，进入其目录，笔者这里默认的是base环境，若是其它虚拟环境需要进入相应的虚拟环境目录，感谢如下小伙伴的补充：
cd ~/anaconda3/lib 这里给出一个可行方案：将所缺失文件设置成一个软连接，连接到该目录下同一性质文件，这里报错是缺失libffi.so.7文件，但是该目录下存在libffi.so.6文件，故将其软连接于libffi.so.6文件上，问题得到解决。
ln -s libffi.so.6 libffi.so.7 如若出现ImportError: cannot import name 'create_prompt_application'问题
最后再升级一下ipython就可以得到解决
pip install ipython 相同原理，如若缺失libffi.so.6文件，步骤相同，不加赘述。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e74e23e89931e5c713226b9cf74e2a1d/" rel="bookmark">
			从BERT到ROBERTA：预训练语言模型的优化之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❤️觉得内容不错的话，欢迎点赞收藏加关注😊😊😊，后续会继续输入更多优质内容❤️ 👉有问题欢迎大家加关注私戳或者评论（包括但不限于NLP算法相关，linux学习相关，读研读博相关......）👈 （封面图由ERNIE-ViLG AI 作画大模型生成） 从BERT到ROBERTA：预训练语言模型的优化之路 自从深度学习在自然语言处理领域得到广泛应用以来，Transformer模型一直是自然语言处理的重要研究方向。2017年，谷歌推出了Transformer模型的创新之作——BERT（Bidirectional Encoder Representations from Transformers），在自然语言处理领域引起了极大的关注。2020年，Facebook AI Research推出了ROBERTA模型（Robustly Optimized BERT Pretraining Approach），它在BERT的基础上做了一些改进，取得了更好的效果。本文将详细介绍ROBERTA模型的原理、优势和劣势，并通过案例和代码的方式帮助读者深入理解。
1. ROBERTA模型的原理 1.1 BERT模型简介 BERT是一种预训练的语言模型，它利用了Transformer编码器的双向特性，能够将文本转换成高维向量表示，进而实现文本分类、命名实体识别、问答等自然语言处理任务。BERT的核心思想是使用Transformer编码器对文本进行预训练，然后在具体的任务上进行微调。
BERT的编码器由多个Transformer块组成，每个块包含多头自注意力机制（Multi-Head Self-Attention）和全连接层（Feed-Forward）。其中，自注意力机制可以实现上下文相关的编码，全连接层则将编码后的向量映射到新的向量空间中。
BERT的预训练任务有两个：掩码语言模型（Masked Language Model，MLM）和下一句预测（Next Sentence Prediction，NSP）。其中，掩码语言模型是指在输入的文本中随机选择一些词，然后用“[MASK]”代替这些词，并让模型预测它们的正确性；下一句预测是指判断两个句子是否是连续的。
1.2 ROBERTA模型的改进 ROBERTA模型是在BERT的基础上做了一些改进，取得了更好的效果。具体来说，ROBERTA模型主要有以下三个改进：
训练数据的改进：ROBERTA模型使用了更多、更大的文本数据进行训练，包括了互联网上的网页、论坛、书籍、新闻等。此外，它还使用了更长的文本片段进行训练，从而更好地捕捉上下文相关性。
训练方法的改进：ROBERTA模型采用了更长的训练时间、更小的批次和更高的学习率，从而提高了模型的鲁棒性和性能。
掩码语言模型的改进：ROBERTA模型不再使用原始BERT中的掩码语言模型，而是采用了更严格的掩码策略。具体来说，ROBERTA模型将输入的文本中所有的词都替换成“[MASK]”，然后让模型预测这些词的正确性，从而更好地利用了训练数据中的信息。
与BERT相比，ROBERTA模型的另一个重要改进是在预训练过程中采用了更多的参数和更深的网络结构，进一步提高了模型的性能。
1.3 ROBERTA模型的结构 ROBERTA模型的结构与BERT基本一致，由多个Transformer块组成。每个块包含多头自注意力机制、全连接层和残差连接，其中多头自注意力机制可以实现上下文相关的编码，全连接层则将编码后的向量映射到新的向量空间中。具体来说，ROBERTA模型的结构可以表示为：
h l = T r a n s f o r m e r B l o c k ( h l − 1 ) h_l = TransformerBlock(h_{l-1}) hl​=TransformerBlock(hl−1​)
其中， h l h_l hl​表示第 l l l层的输出向量， h l − 1 h_{l-1} hl−1​表示第 l − 1 l-1 l−1层的输出向量， T r a n s f o r m e r B l o c k TransformerBlock TransformerBlock表示Transformer块。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e74e23e89931e5c713226b9cf74e2a1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6c0e30092806903a30c3db299af8c3c/" rel="bookmark">
			STM32-微项目08-ADC单通道/多通道模式采集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		huo
一、微项目实现目标：
1，利用STM32内置的ADC模块，将外部模拟量信号（0-3.3v）转化成12位有效（16位数据）的数字量（0-4095），在将采集的数字除4095，就会得到对应采集的模拟量信号；
二、微项目硬件配置需求：
stm32F103C8T6核心板一块；
0.96寸OLED显示，用于显示计数；
模拟量输入（滑动电阻、光线传感器、温度传感器等），接线时刻，需要接AO输出口；
三、前置知识：
1，逐次逼近型ADC的处理逻辑
在外部有模拟量输入时，DAC设置参数并输出模拟量，对比模拟量数据和输入的模拟量相近或相等时刻，则配置输出的DAC的数字量参数，就是输入模拟量的对应转化后的数字量；
2，ADC整体控制逻辑框图
①数据流：外部GPIO模拟量-----AD转换器（注入组和规则组）-----触发转化 ----转化数值存放到AD数据寄存器中
②ADC关键模块解析
图中2：表示外部模拟量的输入端口，有18个通道入口其中0-15是外部接口
图中1：表示启动ADC启动
图中3：表示ADC的时钟，ADC1最大接受时钟14MHZ的，外部接入72MHZ，需要配置分频处理；
图中4：具体转化执行模块
图中5：注入通道和规则通道寄存器，转化后数据存放在这。其中规则通道只有一个，所有转化后，需要立即取走，否则后续转化数据会覆盖掉；
图中6：DMA请求，ADC转化后，配合DMA模式进行数据转移；
③输入通道及转化模式
1-ADC1通道情况
1）单次模式和连续模式：数据转化时，是否连续转化。单次模式，仅转化一次；连续模式时，转换一次 后再从头开始重新转化；
2）扫描模式和非扫描模式：扫描模式，就是将序列中数据从头到尾全部转化；非扫描模式，仅转化序列中的第一个；
3）几种数据转化模式：
单次转换，非扫描模式
连续转换，非扫描模式
、
单次转换，扫描模式
连续转换，扫描模式
④触发转化，一般选用软件触发
⑤转化后，寄存器数据对齐方式，一般选用靠右侧对齐
⑥转化校准，具体代码中执行
四、代码逻辑分析：
①开启GPIO和ADC的时钟，并且对输入ADC通道进行分频处理；
②配置GPIO模式，模拟输入
③配置AD输入通道，即配置输入通道和所在处理序列；
④初始化AD模块，并配置AD模式\数据对齐\扫描模式\连续模式等
⑤打开ADC使能开关（并非开启后ADC就会工作，需要软件触发源触发执行）
⑥执行AD校准模块
⑦开启软件触发ADC执行工作
五、代码示例：
①开启GPIO和ADC的时钟，并且对输入ADC通道进行分频处理；
//打开ADC1时钟 和GPIO时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); //配置ADC1的分频，ADC最高支持14mhz RCC_ADCCLKConfig(RCC_PCLK2_Div6); ②配置GPIO模式，模拟输入
//初始化GPIO模块,模拟输入模式 GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.GPIO_Mode=GPIO_Mode_AIN; GPIO_InitStruct.GPIO_Pin=GPIO_Pin_0; GPIO_InitStruct.GPIO_Speed=GPIO_Speed_50MHz; GPIO_Init(GPIOA,&amp;GPIO_InitStruct); ③配置AD输入通道，即配置输入通道和所在处理序列；
第二个参数：通道接入的端口
第三个参数：规则序列的位置
第四个参数：采样时间
//配置ad输入通道 ADC_RegularChannelConfig( ADC1, ADC_Channel_0, 1, ADC_SampleTime_55Cycles5); ④初始化AD模块，并配置AD模式\数据对齐\扫描模式\连续模式等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6c0e30092806903a30c3db299af8c3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/021e2e1d79d24612b39e97bea41c2fee/" rel="bookmark">
			mysql 删除表卡死，或是截断（truncate）卡死解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用工具进行truncate表的时候，一直运行，运行了十几分钟也没有成功。中止之后再运行也是一样。但是删除表的数据以及查询表数据都是可以的。猜测是锁死了。
使用
show processlist;
发现Waiting for table metadata lock 问题；
mysql&gt; show processlist; +-------+-----------------+-----------+------+---------+--------+---------------------------------+-----------------------------------------------------------------------+ | ID | USER | HOST | DB | COMMAND | TIME | STATE | INFO | +-------+-----------------+-----------+------+---------+--------+---------------------------------+-----------------------------------------------------------------------+ | 1 | event_scheduler | localhost | NULL | Daemon | 365869 | Waiting on empty queue | NULL | | 13040 | root | localhost | NULL | Query | 0 | executing | select * from information_schema.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/021e2e1d79d24612b39e97bea41c2fee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b46ef90418e0aa73a75c6968b92c9ee2/" rel="bookmark">
			NVMf RPC接口文件 nvmf_rpc.c
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NVMf RPC接口文件 nvmf_rpc.c 在spdk的lib/nvmf/下的NVMf RPC接口文件nvmf_rpc.c是干啥的？有什么用发挥了什么功能3. spdk_nvmf_tgt_listen 在spdk里面的nvmf_rpc.c文件中创建RDMA Port 的意义与流程 在spdk的lib/nvmf/下的NVMf RPC接口文件nvmf_rpc.c是干啥的？有什么用发挥了什么功能 nvmf_rpc.c是SPDK的NVMf（NVMe over Fabrics）远程过程调用（RPC）接口文件，它定义了NVMf管理器（NVMf Target）的RPC接口。
NVMf管理器是一种软件实体，它在NVMe存储设备和网络之间提供桥梁，使得通过网络访问NVMe存储设备成为可能。NVMf管理器实现了NVMf协议和NVMe协议之间的转换，并提供了一些管理和控制接口，以便远程主机能够使用NVMe协议访问远程存储设备。
nvmf_rpc.c中的函数实现了管理和控制NVMf管理器的RPC接口，包括创建和删除NVMf命名空间（Namespace）、注册和注销NVMf传输连接（Transport Connection）等。这些RPC接口可以通过RPC机制被远程主机调用，从而实现对NVMf管理器的管理和控制。
总之，nvmf_rpc.c文件实现了NVMf管理器的RPC接口，提供了一种方便的远程管理和控制NVMf管理器的方式。
在SPDK（Storage Performance Development Kit）中，nvmf_rpc.c文件包含了许多用于管理NVMe over Fabrics（NVMf）子系统的RPC命令，包括创建RDMA Port监听的函数。下面是一些相关函数的代码片段和详细讲解：
rpc_nvmf_subsystem_add_listener rpc_nvmf_subsystem_add_listener(struct spdk_jsonrpc_request *request, const struct spdk_json_val *params) { struct rpc_listen_ctx ctx = {}; struct spdk_json_write_ctx *w; struct spdk_nvme_transport_id trid = {}; struct spdk_nvmf_subsystem *subsystem; const char *name; uint16_t port; int rc; if (g_nvmf_tgt.pause) { ctx.request = request; ctx.params = params; TAILQ_INSERT_TAIL(&amp;g_nvmf_tgt.listen_queue, &amp;ctx, link); return; } /* .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b46ef90418e0aa73a75c6968b92c9ee2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d05777c6ee7a75f4de4005fd228da1b5/" rel="bookmark">
			Java解析XML报文内容及标签属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 JSON格式的报文解析，虽然json串短小精悍，也能有效表达层次结构，但是每个元素只能找到对应的元素值，不能体现更丰富的样式特征。比如某个元素除了要传输它的字符串文本，还想传输该文本的类型、字体大小、字体颜色等特征，且这些额外的风格样式与业务逻辑无关，自然不适合为它们单独设立参数字段。倘若采用JSON格式定义包括样式特征在内的文本元素，要么摒弃风格样式这种附加属性，要么将风格样式单列为专门的字段参数，然而不管哪种做法，都未能妥善解决附加属性的表达问题。可见轻量级的JSON格式依然存在力不从心的情况，为此人们早早发明了拥有强大表示能力的XML格式，XML的全称是“Extensible Markup Language”（可扩展标记语言），它不但支持结构化数据的描述，还支持各类附加属性的定义，非常适合在网络中传输信息。
下面先看一个XML报文格式的购物订单样例：
&lt;?xml version="1.0" encoding="gbk"?&gt; &lt;order&gt; &lt;user_info&gt; &lt;name type="string"&gt;思无邪&lt;/name&gt; &lt;address type="string"&gt;桃花岛水帘洞123号&lt;/address&gt; &lt;phone type="string"&gt;15960238696&lt;/phone&gt; &lt;/user_info&gt; &lt;goods_list&gt; &lt;goods_item&gt; &lt;goods_name type="string"&gt;Mate30&lt;/goods_name&gt; &lt;goods_number type="int"&gt;1&lt;/goods_number&gt; &lt;goods_price type="double"&gt;8888&lt;/goods_price&gt; &lt;/goods_item&gt; &lt;goods_item&gt; &lt;goods_name type="string"&gt;格力中央空调&lt;/goods_name&gt; &lt;goods_number type="int"&gt;1&lt;/goods_number&gt; &lt;goods_price type="double"&gt;58000&lt;/goods_price&gt; &lt;/goods_item&gt; &lt;goods_item&gt; &lt;goods_name type="string"&gt;红蜻蜓皮鞋&lt;/goods_name&gt; &lt;goods_number type="int"&gt;3&lt;/goods_number&gt; &lt;goods_price type="double"&gt;999&lt;/goods_price&gt; &lt;/goods_item&gt; &lt;/goods_list&gt; &lt;/order&gt; 接着对上面的XML样例庖丁解牛，分析一下XML格式都有哪些特点，分析结果罗列如下：
1、每个元素依然由参数名称和参数值组成，参数名称为尖括号所包裹，且分为标记头与标记尾两部分，标记尾在尖括号内部多了个斜杆。如此一来，一个字段的完整形式为“&lt;参数名称&gt;参数值&lt;/参数名称&gt;”。
2、因为每个元素都自带标记头与标记尾，很容易区分在哪开始在哪结束，所以元素之间无需额外的分隔符，只要有标记头与标记尾就足够辨别了。
3、每个结构也需要专门的标记头与标记尾，中间再填入若干元素或者其它结构。
4、对于数组形式的数据，XML报文采用多个同名的结构标记并排列举，表示这里存在同名结构的数组信息，也可看作是清单信息。
5、XML格式允许在报文开头的encoding属性处指定当前报文的字符编码类型，常见的有汉字内码规范GBK，以及世界通用编码规范UTF-8。
6、每个结构或者元素节点，也支持在标记头部分填充附加属性，用于指定参数值以外的特定信息。
大致了解了XML报文的格式规范，还得在程序中加以解析才行。传统的XML解析方式有DOM和SAX两种，DOM方式会把整个XML报文读进来，并且所有节点全被自动加载到一个树状结构，以后每个节点值都到该树状结构中读取。SAX方式不会事先读入整个XML报文，而是根据节点名称从报文起点开始扫描，一旦找到该节点的标记头位置，即刻往后寻找该节点的标记尾，那么节点标记头尾之间的数据便是节点值了。单就某个节点值的解析过程而言，加载所有节点的DOM方式显然较费功夫，从头顺序查找的SAX方式执行效率更高。但若要求同时获取多个节点的数值，则采取树状结构遍历的DOM方式总体性能更加，而每次都从头找起的SAX方式无疑做了重复劳动。总之两种方式的解析效果各有优劣，需要按照实际场景决定取舍。
尽管JDK集成了DOM与SAX的解析工具，其中DOM解析工具封装在包org.w3c.dom中，SAX解析工具封装在包javax.xml.parsers中，可是它俩用起来着实费劲，解析过程艰深晦涩，实际开发当中基本不予采用。应用比较多的XML解析工具反而是第三方的Dom4j，Dom4j的解析方式遵循DOM规则，但比起Java自带的DOM工具要易用得多，其性能也很优异，几乎成为Java开发必备的XML解析神器了。通过Dom4j解析XML报文的步骤主要有下列五步：
1、创建SAXReader阅读器对象；
2、把字符串形式的XML报文转换为输入流对象；
3、命令阅读器对象从输入流中读取Document文档对象；
4、获得文档对象的根节点Element；
5、从根节点往下依次解析每个层级的节点值；
在具体的节点解析过程之中，会频繁调用Element的相关方法，它的常用方法说明如下：
getText：获得当前节点的字符串值。
element：获得当前节点下面指定名称的子节点对象。
elementText：获得当前节点下面指定名称的子节点值。
elements：获得当前节点下面指定名称的子节点清单。
attribute：获得当前节点自身指定名称的属性对象。
attributeValue：获得当前节点自身指定名称的属性值。
attributes：获得当前节点拥有的全部属性清单。
仍以前述的XML报文为例，下面是采用Dom4j解析该XML串的代码例子：
// 通过dom4j解析xml串 private static GoodsOrder testParserByDom4j(String xml) { GoodsOrder order = new GoodsOrder(); // 创建一个购物订单对象 // 创建SAXReader阅读器对象 SAXReader reader = new SAXReader(); // 根据字符串构建字节数组输入流 try (InputStream is = new ByteArrayInputStream(xml.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d05777c6ee7a75f4de4005fd228da1b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0250393fdcba0ce7dc73c98f67f56908/" rel="bookmark">
			System.IO.Ports is currently only supported on Windows
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Unigine中使用串口，报System.IO.Ports is currently only supported on Windows错误。
后来发现，框架是.net 5.0.改成6.0或者7.0就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ce0dbafcd76cc2dfb8cb29f5b3ffa44/" rel="bookmark">
			ESP32中定时计数器的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、GPIO常用函数
esp_err_t gpio_reset_pin（gpio_num_tgpio_num) 将 gpio 重置为默认状态（选择 gpio 功能、启用上拉并禁用输入和输出）。备注此功能还将此引脚的 IOMUX 配置为 GPIO 功能，并断开通过 GPIO 矩阵配置的任何其他外设输出。参数gpio_num – GPIO 编号。返回始终返回ESP_OK。
esp_err_t gpio_set_intr_type（gpio_num_tgpio_num，gpio_int_type_tintr_type) GPIO 设置中断触发器类型。参数gpio_num – GPIO 编号。如果要设置触发器类型，例如 GPIO16，则应gpio_num GPIO_NUM_16 （16）;intr_type– 中断类型，从gpio_int_type_t中选择返回ESP_OK成功ESP_ERR_INVALID_ARG 参数错误
esp_err_t gpio_intr_enable（gpio_num_tgpio_num) 启用 GPIO 模块中断信号。备注ESP32：在启用睡眠模式的情况下使用 ADC 或 Wi-Fi 和蓝牙时，请不要使用 GPIO36 和 GPIO39 的中断。请参考评论。有关此问题的说明，请参阅ESP32 ECO 和 Bug 的解决方法3.11 节。解决方法是在应用中调用 adc_power_acquire（）。这将导致更高的功耗（~1mA），但将消除GPIO36和GPIO39上的毛刺。adc1_get_raw参数gpio_num – GPIO 编号。如果要在 GPIO16 上启用中断，则应GPIO_NUM_16 （16） gpio_num;返回ESP_OK成功ESP_ERR_INVALID_ARG 参数错误
esp_err_t gpio_intr_disable（gpio_num_tgpio_num) 禁用 GPIO 模块中断信号。备注当在 ISR 上下文中禁用缓存时，允许通过启用CONFIG_GPIO_CTRL_FUNC_IN_IRAM参数gpio_num – GPIO 编号。如果要禁用例如 GPIO16 的中断，则应GPIO_NUM_16 （16） gpio_num;返回ESP_OK成功ESP_ERR_INVALID_ARG 参数错误
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ce0dbafcd76cc2dfb8cb29f5b3ffa44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c7f0d58a302c2124c01c994d8f7fec8/" rel="bookmark">
			Tomcat部署&#43;JPress搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat部署+JPress搭建 一、安装jdk二、安装tomcat前提：关闭防火墙和Selinux 三、为Tomcat提供服务脚本四、安装JPress 一、安装jdk 系统版本
[root@localhost ~]# cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) 1、查看目前Linux是否已经安装JDK
安装系统时会默认安装JDK，下图可以看出默认安装的JDK是OpenJDK
[root@localhost ~]# java -version 2、安装新JDK前需要卸载之前安装的java程序包
查看当前系统已存在java程序包
[root@localhost ~]# rpm -qa | grep java 卸载java程序包
rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.131-11.b12.el7.x86_64 rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.141-2.6.10.5.el7.x86_64 rpm -e --nodeps java-1.8.0-openjdk-1.8.0.131-11.b12.el7.x86_64 rpm -e --nodeps java-1.7.0-openjdk-1.7.0.141-2.6.10.5.el7.x86_64 （–nodeps意思是不验证套件档的相互关联性，若被删除的指定套件若和其他套件存在依赖关系，不带此参数会报错）
下图，可以看出系统原先的JDK已经被卸载。
3、安装JDK
官网下载地址: Java Downloads
yum localinstall -y jdk-8u261-linux-x64.rpm 查看已经安装好的JDK
二、安装tomcat 前提：关闭防火墙和Selinux 1、Tomcat官网下载安装包
链接: Tomcat官网
这里我选择下载Tomcat8的二进制版本
右击复制连接地址
[root@localhost ~]# wget -c https://archive.apache.org/dist/tomcat/tomcat-8/v8.0.36/bin/apache-tomcat-8.0.36.tar.gz 如下图，下载完成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c7f0d58a302c2124c01c994d8f7fec8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c3f0e62d7454e0cf45d7034a21c3f65/" rel="bookmark">
			第28次csp认证T3 JPEG 解码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第28次csp认证T3 JPEG 解码解析 题目说明 问题比较长，就只放个链接吧：http://118.190.20.162/view.page?gpid=T158
经验分享 做这种大模拟的题目，对于经验不是很丰富的新手来说，更应该着眼于得分点，先做那些问题简单、数据规模小的子任务，不断调试，慢慢提高分数。考试基本是不限制提交次数的，如果一次性写完再调试，对于这种复杂的问题来说是一定会有很多出错误的，到时候语法、逻辑等等的失误都不容易被发现，所以最好是写一段小功能就测试一下，确保是正确的再向下进行，先拿到一部分分，不至于最后满盘皆输！针对这个题就需要一步一步对照题目给的数据的矩阵的变化是否正确，最终才更快调试准！
对于此类大模拟题目，问题背景基本可以不看，或者省略着看个大概。重点在于问题描述的输入输出，而且有一定概率完全按照问题描述的步骤去写代码即可得到正确答案，有时还需要选一个复杂度低一些的算法从70分优化到100等等。
题目详解 这个题在csp的第三题里面算是超级简单的一道题了，没有复杂的资源分配和时间逻辑，仅仅是一个jpeg的解码任务，任务明确且难度超级低，因为题目完全说明了步骤，只需要按步骤来做就可以。
真正的难点在于扫描数据的矩阵对应关系和对矩阵进行离散余弦变换。
对于前者，只需要确定好矩阵和输入的线性数据的映射关系即可，在这里我用了对角矩阵的映射关系，一种是从左下向右上，一种是从右上向左下。需要讨论i+j为奇数还是偶数的情况去对应上述两种情况，同时还需要注意斜对角超过了中间的斜线后每一条线穿过的小正方形会逐渐减少！也就是需要确定两个公式，下面的公式是通过等差数列求和推导出来的，要小心ij数组下标是从0开始的，以及某些数数中的+1-1问题，需要调试很多次！
一、从左下到右上（i+j是偶数）
i+j&lt;=7的情况：map[i,j]=Line[(i+j)*(i+j+1)/2+j]（就是计算ij这个位置前面的方块个数+j，因为此方向j是从0开始增加的）
i+j&gt;7的情况：map[i,j]=Line[36+(23-i-j)*(-8+i+j)/2+7-i]（就是计算斜对角线前的36个方块+ij这个位置前面的斜对角线后面的方块个数+7-i，因为此方向7-i是从0开始增加的）
二、从右上到左下的情况（i+j是奇数）
i+j&lt;=7的情况：map[i,j]= Line[(i+j)*(i+j+1)/2+i]（思想同上）
i+j&gt;7的情况：map[i,j]=Line[36+ (23-i-j)*(-8+i+j)/2+7-j]（思想同上）
分成上边两种情况再通过i+j是偶数还是奇数就可以用四种情况完成蛇形输入，不需要耗费其他大量代码模拟过程。
对于后者，只需要搞清楚是怎么计算的过程，保存好中间变量去计算就可以了，需要小心的地方也有，比如题目里的1/2，如果代码里也写成1/2，就会按照整数除法而算成0，需要写0.5才能当成double计算，还有开方，acos、cos等计算。
其余的点无非就是模拟，很简单，不再赘述。
满分代码 以下是我的调试过程：
#include&lt;bits/stdc++.h&gt; using namespace std; int Q[8][8]; double M[8][8]; double MM[8][8]; int n; int T; int N[70]; int index; void t0(){ for(int i=0;i&lt;8;i++){ for(int j=0;j&lt;8;j++){ if((i+j)%2==0){//偶数 if(i+j&lt;=7){ index = (i+j)*(i+j+1)/2+j; M[i][j] = N[index]; } else{ index = 36+(23-i-j)*(-8+i+j)/2+7-i; M[i][j] = N[index]; } } else{//奇数 if(i+j&lt;=7){ index = (i+j)*(i+j+1)/2+i; M[i][j] = N[index]; } else{ index =36+ (23-i-j)*(-8+i+j)/2+7-j; M[i][j] = N[index]; } } } } } void t1(){ t0(); for(int i=0;i&lt;8;i++) for(int j=0;j&lt;8;j++) M[i][j]*=Q[i][j]; } void t2(){ t1(); for(int i=0;i&lt;8;i++){ for(int j=0;j&lt;8;j++){ double tempres = 0; for(int u=0;u&lt;8;u++){ for(int v=0;v&lt;8;v++){ double temptempres = M[u][v]; if(u==0) temptempres*=sqrt(0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c3f0e62d7454e0cf45d7034a21c3f65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0447ab7ea17d69ebf17242aa56eecae5/" rel="bookmark">
			jQuery下载和安装详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载jQuery 我们可以到jQuery的官网下载jQuery文件（PS：其实jQuery就是一个封装了很多函数的js文件，把这个js文件导入到网页中就可以了）。
jQuery官网地址： https://jquery.com/
打开官网，即可看到jQuery的下载按钮，点击进入下载页面。有两个版本的jQuery可以下载：
Production version - 用于实际的网站中，是已经被精简和压缩过的jQuery文件。Development version - 用于测试和开发中，是未压缩的jQuery文件，可以方便阅读源码。 使用jQuery jQuery库就是一个JavaScript文件，我们可以在HTML中使用&lt;script&gt;标签引入jQuery库：
&lt;head&gt; &lt;script src="jquery-1.10.2.min.js"&gt;&lt;/script&gt; &lt;/head&gt; 注意：
script标签的src属性中，要根据jQuery文件所在的目录引入，如果jQuery文件和当前的HTML文件放在同一个目录下，即可直接写jQuery的文件名；如果jQuery文件和HTML文件不在同一个目录下，我们可以使用相对路径和绝对路径的方式引入jQuery。
在HTML5中，script标签上可以不用添加 type="text/javascript" 属性，因为JavaScript是HTML5以及所有现代浏览器中的默认脚本语言。
CDN方式引用jQuery 如果我们不想下载jQuery文件存放到项目中，为了操作方便，可以使用CDN（内容分发）的方式引用jQuery。说更直白一点，就是网络中很多服务器都存了jQuery文件，我们可以去某一台服务器上找到jQuery文件，并且把该文件的URL地址放到script标签的src属性中就可以了。使用CDN方式引用jQuery的前提是，你的电脑必须可以上网，不然是连接不到远程服务器的。
如果你的站点是在国内，建议使用百度、新浪、又拍云等国内CDN地址，如果你的站点是在国外，建议使用谷歌和微软的CDN地址。
使用CDN地址引用jQuery的具体方法如下：
百度 CDN：
&lt;head&gt; &lt;script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt; &lt;/script&gt; &lt;/head&gt; 新浪 CDN：
&lt;head&gt; &lt;script src="https://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js"&gt; &lt;/script&gt; &lt;/head&gt; 又拍云 CDN：
&lt;head&gt; &lt;script src="https://upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.2.min.js"&gt; &lt;/script&gt; &lt;/head&gt; Staticfile CDN：
&lt;head&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt; &lt;/script&gt; &lt;/head&gt; Google CDN：
&lt;head&gt; &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"&gt; &lt;/script&gt; &lt;/head&gt; Microsoft CDN：
&lt;head&gt; &lt;script src="https://ajax.aspnetcdn.com/ajax/jquery/jquery-1.9.0.min.js"&gt;	&lt;/script&gt; &lt;/head&gt; 查看jQuery版本 在浏览器中打开已经引用jQuery的网页，然后按F12打开 开发者工具 ，选择“Console”控制台，在控制台中输入以下命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0447ab7ea17d69ebf17242aa56eecae5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cfc448df880a5692be94094b19ae7d8/" rel="bookmark">
			时间转换问题PTA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本题要求编写程序，以hh:mm:ss的格式输出某给定时间再过n秒后的时间值（超过23:59:59就从0点开始计时）。
输入格式： 输入在第一行中以hh:mm:ss的格式给出起始时间，第二行给出整秒数n（&lt;60）。
输出格式： 输出在一行中给出hh:mm:ss格式的结果时间。
输入样例： 11:59:40 30 输出样例： 12:00:10 代码如下：
#define _CRT_SECURE_NO_WARNINGS #include&lt;math.h&gt; #include&lt;iostream&gt; #include&lt;iomanip&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; using namespace std; int main() { int hh, mm, ss, sum,sec; scanf("%02d:%02d:%02d",&amp;hh,&amp;mm,&amp;ss); cin &gt;&gt; sec; ss += sec; if (ss &gt;= 60) { sum = ss / 60; ss = (ss % 60); mm += sum; if (mm &gt;= 60) { sum = mm / 60; mm = (mm % 60); hh += sum; if (hh &gt;= 24) { hh = (hh % 24); } } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cfc448df880a5692be94094b19ae7d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/064862ed7173af4dc4eb0f8baed0657a/" rel="bookmark">
			mavsdk_api
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MAVSDK中offboard一些API Value 其中是offboard需要用到的一些参数定义。
offboard.PositionNedYaw class mavsdk.offboard.PositionNedYaw(north_m, east_m, down_m, yaw_deg)
Bases: object
Type for position commands in NED (North East Down) coordinates and yaw.
**参数是NED坐标和偏航下的位置命令。**单位是m
Parameters:
north_m (float) – Position North (in metres)，单位是米
east_m (float) – Position East (in metres)
down_m (float) – Position Down (in metres)
yaw_deg (float) – Yaw in degrees (0 North, positive is clock-wise looking from above)
offboard.VelocityBodyYawspeed class mavsdk.offboard.VelocityBodyYawspeed(forward_m_s, right_m_s, down_m_s, yawspeed_deg_s)
Bases: object
Type for velocity commands in body coordinates.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/064862ed7173af4dc4eb0f8baed0657a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb2972b141eb3fd1c33a2b2e4f2e22ff/" rel="bookmark">
			599.相同元素的最小索引和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。
来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/minimum-index-sum-of-two-lists
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
解题思路 用哈希表存放第一个列表的元素，再对第二个列表进行一次遍历，记录最小索引和与餐厅名使用 a n s ans ans 存放结果，最终转为字符串数组即可. 代码 class Solution { public String[] findRestaurant(String[] list1, String[] list2) { Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(list1.length); for(int i = 0;i &lt; list1.length; i++){ map.put(list1[i],i); } int min = 2000; int temp; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); for(int i = 0;i &lt; list2.length; i++){ if(map.containsKey(list2[i])){ temp = map.get(list2[i]); if(min &gt; temp+i){ ans.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb2972b141eb3fd1c33a2b2e4f2e22ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/464560438bc1c691f62e0c0cf1eb784d/" rel="bookmark">
			深入理解字、字长、存储字长、寻址范围、以及地址总线和存储单元个数之间的关系。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.字、字长和存储字长。
字就是计算机一次性能处理的最大位数，字长就是字的长度，又叫机器字长。而机器字长的长度不一定等于存储字长的长度，这就要靠主存是按字节寻址还是按字寻址，当按字寻址时机器字长等于存储字长，而当按字节寻址，它的机器字长不一定等于存储字长（原因就是:比如一个机器字长为32位，按字寻址，即按一个字为单位进行寻址，此时存储单元存放的就是一个字长，32位，那么存储字长就是32位，所以存储字长就等于机器字长。而当按字节寻址时，即按一个字节为单位进行寻址，此时存储单元放的就是一个字节，就是8位，所以存储字长就是8位，不等于机器字长32位。ps:存储单元存放的字长也不一定是8位，如果你按字寻址，那么它就存放32位，如果你按字节寻址，那么它就存放的是8位。当然，如果你的机器字长是16位，那么按字寻址储存字长就是16位）。
2，寻址范围
在内存中是一个一个小的内存储空间组成，这个内存空间一定是8位（注意:这个存储空间并不是存储单元，一个存储单元可能有好几个存储空间），比如有24位地址线，他就能指向2的24次方个储存空间，当按字节寻址的时候，范围就是2的24次方，即16M，但是当按字寻址的时候，就要看这个机器的机器字长是多少位，如果是32位，那么他就是一个字就是4个字节，就是4个存储空间，所以按字寻址就用16M÷4=4M。如果有24位地址线，当机器字长是16位时，它的按字节寻址范围任然是16M，但是他的暗自寻址范围就是8M，因为他一个字有2个字节组成，用16M÷2=8M。所以你会发现当按字节寻址的时候，与机器本身的机器字长无关，只与地址线的位数有关，当地址线的位数定了之后，按字节寻址的范围就定了。
3.地址总线和存储单元个数的关系
如果地址总线有n根（或者说n位），那么存储单元的个数一定是2的n次方。假如一个机器的字长为32位，当然字节寻址时，每一个小的存储空间就是一个存储单元，每一个地址就指向每一个小的存储空间。当按字寻址时，四个小的存储空间是一个存储单元，每一个地址就指向这四个小的存储空间的开头。所以不管是按那种方式寻址，储存单元的个数一定是2的n次方，当地址线同样是32位时，只能说按自寻址的那个储存空间比较大。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f118b1f87f2850f433774a4bc086f0a5/" rel="bookmark">
			二十分钟带你了解JVM性能调优与实战进阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ZGC 诞生原因 Java生态非常强大，但还不够，有些场景仍处于劣势，而ZGC的出现可以让Java语言抢占其他语言的某些特定领域市场。比如
谷歌主导的Android手机系统显示卡顿。证券交易市场，实时性要求非常高，目前主要是C++主导。大数据集群如HBase的性能。 特性 ZGC（The Z Garbage Collector）为JDK11推出一款低延迟的垃圾回收器。STW即停顿时间低于1ms，且不会随着堆的大小增加而增加。实现主要原理：全并发处理(仅对GC ROOTS进行遍历时会暂停) 高版本JDK16之后支持16TB级别的堆；实现主要原理：Region分区管理、染色指针寻址 应用程序吞吐量最多减少15%。实现主要原理：当生命周期很短的对象分配速率很高的时候，大量对象不会被进行标记收集，会产生大量浮动垃圾从而影响吞吐量，并且堆中可转移对象的空间就会越来越小。 为未来的GC新特性奠定基础。实现主要原理：染色指针中未被使用预留的18 bits。 内存布局 ZGC采用堆空间分页模型的机制，堆空间分页模型也非常符合Linux Kernel2.6引入的标准大页（huge page）如4KB的处理方式。本质与G1一样，没有分代的概念，ZGC也采用基于Region的堆内存布局，不一样的是ZGC的Region具有动态性：动态创建销毁、动态容量大小。ZGC一共分为三种Region：
小型Region（小页面）：容量固定为 2MB，存放小于256KB的对象。中型Region（中页面）：容量固定为 32MB，存放大于256KB小于4MB的对象。大型Region（大页面）：容量为 2*N MB,可以动态变化，每个大Region中只会存放一个大对象，并且不会被重分配(即后文介绍的对象的复制)，因为大对象的复制代价高昂。 ​
指针着色技术（Color Pointers） ZGC只支持64位的系统，也即是64位的指针。ZGC在JDK11的ZGC来分析中低42位即2的42次方来表示使用中的堆空间,也即是可管理的内存，而在JDK更高版本有所变化。ZGC借助几位高位来做GC相关的事情比如快速实现垃圾回收的并发标记、转移和重定位等。预留用来给未来的GC新特性预留的扩展点 ​
一段C程序mapping.c看下ZGC的64位虚拟地址空间的指针着色技术展示
​
编译执行，三个地址一样，也即是同一个实地址映射到3个虚地址。
​
整体流程 概述 主要分为两步
标记阶段（标记垃圾）转移阶段（对象复制或移动） ​
​
垃圾标记 垃圾标记算法采用可达性分析算法
​
RemappedGC前所有内存都是Remapped,或者标记后如果还是Remapped则是垃圾。 M0，发生两次GC为例，M0是1次GC。前一次GC的标记阶段被标记过的活跃对象，但是上次GC未对对象进行转移。 M1，发生两次GC为例，M0是2次GC。本次垃圾回收中识别的活跃对象。 标记阶段，对象分配（Remapped）
初始标记（标记根）并发标记（标记剩余）再标记（解决漏标） 标记结束后Remapped对象即为垃圾对象。而下次标记使用M1表示活跃。
​
ZGC转移 如果是同一个页面则等同于标记整理。如果是不同页面等同于复制算法。 JVM调优概述 背景 生产环境中的问题生产环境中的问题。生产环境发生了内存溢出该如何处理？生产环境应该给服务器分配多少内存合适？如何对垃圾回收器的性能进行调优？生产环境 CPU 负载飙高该如何处理？生产环境应该给应用分配多少线程合适？不加 log，如何确定请求是否执行了某一行代码？不加 log，如何实时查看某个方法的入参与返回值？ 为什么要调优防止出现 OOM解决 OOM减少 Full GC 出现的频率 调优场景Full GC 次数频繁。GC 停顿时间过长（超过1秒）。应用出现OutOfMemory 等内存异常。系统吞吐量与响应性能不高或下降 不同阶段的考虑上线前项目运行阶段线上出现 OOM 调优概述 监控的依据运行日志异常堆栈GC 日志线程快照堆转储快照 调优的大方向合理地编写代码充分并合理的使用硬件资源合理地进行 JVM 调优 调优目标 JVM调优目标是使用较小的内存占用来获得较高的吞吐量或者较低的延迟，从这里也可以知道其重要指标有三个：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f118b1f87f2850f433774a4bc086f0a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee7d0ab93918a3f61d0562bf826232a6/" rel="bookmark">
			Ubuntu20.04下运行VINS系列：VINS-Mono、VINS-Fusion和GVINS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安装VINS-Mono1.1 适配Ceres2.1.01.2 适配OpenCV41.3 编译运行 二、安装VINS-Fusion2.1 适配Ceres2.1.0和OpenCV42.2 编译运行2.2.1 EuRoC数据集2.2.2 KITTI数据集 三、安装GVINS3.1 适配Ceres2.1.0和OpenCV43.2 安装依赖库gnss_comm3.3 编译运行3.4 Dataset Tools的使用 在我的博文Ubuntu 20.04配置ORB-SLAM2和ORB-SLAM3运行环境+ROS实时运行ORB-SLAM2+Gazebo仿真运行ORB-SLAM2+各种相关库的安装和Ubuntu20.04下运行LOAM系列：A-LOAM、LeGO-LOAM、LIO-SAM 和 LVI-SAM的基础环境下跑通VINS-Mono、VINS-Fusion和GVINS 一、安装VINS-Mono VINS-Mono是HKUST的Shen Shaojie团队开源的一套Visual-Inertial融合定位算法。VINS-Mono在Github的开源地址：https://github.com/HKUST-Aerial-Robotics/VINS-Mono。
首先按照前面两篇篇文章已经安装好了VINS-Mono所需的ROS noetic、Eigen3.4.0、Ceres2.1.0和OpenCV4.2.0等三方库，它们的安装不再赘述VINS-Mono是在ROS melodic以及Ceres1的环境下开发的，因此需要适配高版本的环境。
1.1 适配Ceres2.1.0 Ceres-solver2.0.0及以上版本采用的是C++14编译，而VINS-Mono使用的Ceres-solver1.4.0采用C++11编译，将所有文件夹下的CMakeLists.txt文件全部修改为C++14编译
#set(CMAKE_CXX_FLAGS "-std=c++11") set(CMAKE_CXX_FLAGS "-std=c++14") 1.2 适配OpenCV4 ROS noetic版本中的OpenCV4.2和VINS-Mono中需要使用的OpenCV3冲突，修改VINS-Mono代码兼容OpenCV4。幸运的是发现不用修改代码中不兼容的变量，可以直接添加缺失的头文件即可：
在camera_model包中的头文件Chessboard.h中添加
#include &lt;opencv2/imgproc/types_c.h&gt; #include &lt;opencv2/calib3d/calib3d_c.h&gt; 在camera_model包中的头文件CameraCalibration.h、pose_graph包中的头文件pose_graph.h和keyframe.h、BRIEF.h中添加
#include &lt;opencv2/imgproc/types_c.h&gt; #include &lt;opencv2/imgproc/imgproc_c.h&gt; 若vins_estiamtor包中报错，将头文件替换为
// #include &lt;opencv/cv.h&gt; // #include &lt;opencv/highgui.h&gt; #include &lt;opencv2/highgui.hpp&gt; #include &lt;opencv2/cvconfig.h&gt; 还有可能由于电脑上有不同版本的OpenCV，找到的版本不对，需要在各个CMakeLists.txt里面find_package的时候明确指定OpenCV的版本：
#find_package(OpenCV REQUIRED) find_package(OpenCV 4 REQUIRED) 1.3 编译运行 新建工作空间，将修改的源功能包移动到工作空间，编译：
cd ~/catkin_ws_vins/src cd .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee7d0ab93918a3f61d0562bf826232a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71dc557b1faf77997a1c40950530bb8d/" rel="bookmark">
			excel中汉字转换成拼音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）Alt+F11进入VBA （2）点击插入——模块 （3）复制以下代码 Function pinyin(p As String) As String i = Asc(p) Select Case i Case -20319 To -20318: pinyin = "a" Case -20317 To -20305: pinyin = "ai" Case -20304 To -20296: pinyin = "an" Case -20295 To -20293: pinyin = "ang" Case -20292 To -20284: pinyin = "ao" Case -20283 To -20266: pinyin = "ba" Case -20265 To -20258: pinyin = "bai" Case -20257 To -20243: pinyin = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71dc557b1faf77997a1c40950530bb8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8099769ca3bf794300c938b9d6006989/" rel="bookmark">
			Sublime text 3 - 学习/实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载并安装sublime text3 官网: Download - Sublime Text,
step by step install.
2.安装sublime text3 Control[控制台] 步骤:
view--show console--粘贴文本回车即可.文本见下链接.
sublime text3 控制台安装方法+必用插件 - 简书
3.安装插件[语言包[简体中文等] Emmet/ html-css-jsprettify[格式化插件] / format[选择对应的语言]] Sublime Text 3 超详细插件安装 - 知乎
调出插件安装器面板 ctrl/command+shift+p
sublime plugs install / sublime 插件离线安装 插件 方法 //2019.4.13
腾讯云 - 产业智变 云启未来
语言包[简体中文]
如何给sublime text3安装汉化包？so easy 哦 - marsggbo - 博客园
sublime text3的强大插件emmet介绍_南太平洋_99的博客-CSDN博客
SublimeText自带格式化代码功能_u010683915的博客-CSDN博客_sublimetext格式化代码
Sublime text 3 如何格式化HTML/css/js代码_shirley云的博客-CSDN博客
1. 安装主题 // 20201215 周二 科学馆 https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8099769ca3bf794300c938b9d6006989/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c3947f45f472b4194a216e7d6aacce/" rel="bookmark">
			Altium Designer 20相关操作及使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、复制：选中后，按shift实现复制
2、位号designator:R? C? U?
3、多个引脚，阵列式操作。引脚序号可以修改主增量和次增量实现奇偶和差值
4、镜像：在粘贴状态下按Y
5、使用现有的原理图库：在已经有的原理图中，使用“生成原理图库”命令，可按照默认设置，就可以生成该原理图中的元件库，可以通过粘贴复制到自己的原理图库中，这样就方便使用；注意复制后对元件属性按照自己需要进行变更
6、修改原理图框图大小，双击边沿，选择尺寸，比如从A4改为A3
7、快速设置修改封装（单个或多个一起）：使用封装管理器 “工具—封装管理器”
8、原理图的编译设置及检查：工程–工程选项–error report
a、duplicate part designator （标号重复）：编译原理图–panel–message中可以看到错误，可以根据封装管理器中缺少的编号来改，也可以直接用U?方式让软件自行编译；
b、floatingf net label\floating power object 网络悬浮 ----重新接线
c、nets with only one pin 单端网络 —需要确认，如果确实是单端网络，可以使用通用NO ERC标号（放置–指示）
9、一个封装需要的部分：1脚标识、阻焊（防止绿油覆盖）、PCB焊盘、管脚序号、丝印（实物形体）
10、 封装焊盘放置，如果是通孔焊盘就是用multi-layer，如果是表贴焊盘，就改成top-layer
11、 两个焊盘准确调整间距：选中后，按M，通过X，Y移动选中对象
12、丝印画法：往中心画一条线，往右偏移，然后以中心点作为参考点，然后选择线（ctrl+c），点击中心点（以中心点作为参考点），然后就复制一条具有一定偏移量的线，然后按X进行镜像，同理进行上下边沿。
13、选中圆弧，按MS移动所选择，点击中心点，按x镜像
14、如果丝印遮挡焊盘，可以使用裁剪导线的方式对丝印进行处理（编辑–裁剪导线）
15、如果存在已有的pcb，需要到处封装，直接使用DP，然后粘贴复制到现有的封装库当中；也可以单独选中一个，然后在封装库位置里粘贴复制，形成新的单独复制的封装库 下载：搜索“PCB超级库”
16、CTRL+D切换3D模型，3D body是导入3D模型，3D元件体是自定义3D模型 下载：IC封装库
17、ad设置两个焊盘间距：先将两个焊盘放到一起，按m-&gt;通过x,y移动选中对象，设置两焊盘中心的间距
18、消除测试距离后的显示信息：shift+c
19、AD中如何使用阵列粘贴：
a、先放一个焊盘，ctrl+X后选中焊盘
b、依次按下键盘上的E，A，在弹出的选择性粘贴对话框中选Paste Array（黏贴矩阵）
c、在Item Count输入需要的焊盘数及间距
d、选择好第一个焊盘所在的位置，左键点放置就可以了。
20、单位切换： Q键
21、unkown pin原因：a、没有封装 b、封装管脚缺失 c、管脚名称不匹配
22、PCB板子大小确定：
a、将器件全部选中；
b、工具–器件摆放–在矩形区域排列（快捷键设置：按住ctrl+快捷按键 删除原有快捷键：菜单栏单击右键–customize–选择all–找到设置快捷键–按住ctrl–将原有快捷键改为none
c、画一个比框住所有元器件更大一些的框
d、在机械层mechanical1设置大概的宽度
e、按EOS设置原点，查看边框的大概长度，取整后板框大体上定下来。
f、放置–尺寸–线性尺寸，标注板框长宽距离
g、重新确定板框大小：按住shift键选中所有板框，执行“设计–板子形状–按照选择对象定义”
23、放置固定孔，先放置在顶点，然后x/y移动间距5mm，进行摆放即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2c3947f45f472b4194a216e7d6aacce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f9ea3f8fea558bc662e8a5e5401b862/" rel="bookmark">
			手撸ts自动编译器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天刚刚开始对ts的学习，感受到了ts的魅力，但是对于ts这个指令编译我觉得过于麻烦了，即使有tsc xxx.ts -w这样的监控指令我也觉得有点麻烦，毕竟不能监控整个文件夹下的所有ts文件，由此我就想到了自己做一个ts自动编译器。
好的，以上就是背景了，那么现在我们要开始实现了，其实这个自动编译很简单，就两步，第一步监听文件内容变化，第二步，对ts文件进行编译并生成js文件，知道了具体内容，那么接下来就是实现了，首先我们先来第一步，这里需要使用node。
const fs = require('fs'); 因为需要对文件进行监控，所以要引用fs模块，接着就是使用里面的watch方法，对文件进行监控。watch方法接受三个参数：
用法:
fs.watch( filename[, options][, listener] ) 参数：此方法接受上述和以下所述的三个参数：
filename:它是一个字符串，Buffer或URL，表示要监视的文件或目录的名称。options:它是可用于修改方法行为的字符串或对象。它是一个可选参数。它具有以下参数： persistent:它是一个布尔值，用于指定只要正在监视文件，该过程是否应继续。默认值是true。recursive:它是一个布尔值，用于指定是否应监视给定目录的所有子目录。默认值为false。encoding:它是一个字符串，它指定用于传递给侦听器的文件名的字符编码。listener:它是在访问或修改文件时调用的函数。它是一个可选参数。 eventType:它是一个字符串，它指定文件进行的修改的类型。filename:它是一个字符串或Buffer，它指定触发事件的文件名。 然后由于我们需要监听的是整个文件夹，所以filename可以是当前文件夹的路径。
recursive需要设置为true。
然后回调里需要输出本次修改的类型以及当前修改的文件名字，方便之后做处理，所以我们的代码如下：
import fs from 'fs'; fs.watch('../TS', { recursive: true }, ((event, filename) =&gt; { console.log(`检测到文件变化.....变化类型为${event}文件名字是${filename}`); })) 让我们看看运行后的结果：
现在看起来是完成了，但是还是有问题，因为我们要做的是ts的编译器，所以我们应该只对ts文件进行编译，所以我们这里应该加一个分支；
import fs from 'fs'; let flag = true; //作为开关控制是否开启编译 fs.watch('../TS', { recursive: true }, ((event, filename) =&gt; { flag = true; //手动初始化 if (filename.endsWith('ts')) { flag = false; } if (flag) return //如果当前文件不是ts文件则不进行编译 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f9ea3f8fea558bc662e8a5e5401b862/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ced77c3d6595bdd82e6b1010ef25674a/" rel="bookmark">
			不同通知类型获得参数、返回值、返回异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不同通知类型获得参数、返回值、返回异常： 参数：
前置后置，异常后，成功运行后：方法中参数写JoinPoint joinPoint,使用joinPoint调用方法，getArgs()方法返回的是测试类那边传进来的参数，被这个方法打包成数组类型放入Object类型的数组中，然后用打印Arrays.toString(args)就可以知道传进来的参数是啥
@Before("pt()") public void before(JoinPoint joinPoint) throws Throwable{ Object[] args=joinPoint.getArgs(); System.out.println(Arrays.toString(args)); } 环绕型就有所不同：方法中的参数用ProceedingJoinPoint joinPoint，其余都一样样；对了ProceedingJoinPoint还包含一个方法，其方法的参数就是args，所以这里就可以直接把args数组传进去，然后joinPoint.proceed(args)调用执行当前的实体类方法
@Around("pt()") public Object arounddd(ProceedingJoinPoint joinPoint) throws Throwable { Object[] args=joinPoint.getArgs(); Object proceed=joinPoint.proceed(args); return proceed; } 但是这个参数可以进行修改，将得到的参数改一下，如令args[0]等于一个别的值，参数就变了，再次执行joinPoint.proceed(args)时，其中的参数就变成了别的，于是最后结果，返回的也是别的参数相对应的结果
@Around("pt()") public Object arounddd(ProceedingJoinPoint joinPoint) throws Throwable { Object[] args=joinPoint.getArgs(); args[0]=6; Object proceed=joinPoint.proceed(args); return proceed; } 返回值：
@AfterReturning成功运行后：注解@AfterReturning(value = “pt()”,returning = “args”)，其中表示返回值，再方法中参数也写args，与注解中的参数保持一致即可，最终打印的args就是实体类返回的值，（与环绕方法不同的是他不用在方法中加载进实体类的方法，直接利用注解中的returning参数就可以打印出实体类的返回值，当然也得实体类不是void返回型才可以） @AfterReturning(value = "pt()",returning = "args") public void show(Object args){ System.out.println(args); } 返回异常：
@AfterThrowing：和上面的成功后返回返回值的用法一样
其他的通知类型就直接在方法内使用try{} catch(){}打印就行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ced77c3d6595bdd82e6b1010ef25674a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f1fff2d4fbab7c287e913a4c7d52bc0/" rel="bookmark">
			Failed to execute goal org.apache.maven.plugins:maven-jar-plugin:3.1.1:jar (default-jar)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新项目打包失败。
原因：报错中的project是个空模块，不存在类
解决方案：在该模块中创建一个类
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8127c59b3b5bc3c23ae7ea8f51b5d1d9/" rel="bookmark">
			rollup-plugin-serve 配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		`rollup-plugin-serve` 是一个 Rollup 插件，用于在开发过程中充当本地 Web 服务器。它可以让您在本地运行开发版本的应用程序，而无需在每次更改代码时都重新构建并重新加载网页。以下是一个简单的 `rollup-plugin-serve` 配置示例：
```js
// rollup.config.js
import serve from 'rollup-plugin-serve';
export default {
input: 'src/main.js',
output: {
file: 'public/bundle.js',
format: 'cjs'
},
plugins: [
serve({
open: true,
contentBase: ['public'],
port: 3000
})
]
};
```
在这个例子中，我们在 Rollup 配置文件中添加了 `rollup-plugin-serve` 插件，并提供了一些配置选项。以下是一些重要的选项：
- `open`：当服务启动时，自动在浏览器中打开相应的页面。
- `contentBase`：指定要服务的文件目录。在这个例子中，设置为 `public` 目录。
- `port`：指定要使用的端口号。
- `host`：指定要使用的主机名。
默认情况下，`rollup-plugin-serve` 将使用您配置的端口号和主机名，在本地启动一个 Web 服务器，并提供指定目录的文件访问。如果您在浏览器中访问服务器的 URL，将可以看到您的应用程序的开发版本。
除了以上配置选项，`rollup-plugin-serve` 还提供许多其他选项可以自定义服务器行为。可以查看官方文档以了解更多详细信息。
总之，`rollup-plugin-serve` 可以令您的开发过程更加高效，有效的加快应用程序的开发过程，并提高开发效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efb5fb5d0babf0392d2f3a0eeaeebecb/" rel="bookmark">
			js 多个字符串对比不同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果想要在 JavaScript 中对比多个字符串的不同之处，可以通过比较它们的字符来进行。可以使用 `split` 方法和 `forEach` 方法来遍历每个字符串的字符，比较每个字符的值是否相等。如果出现不同，则记录下不同字符所在的位置，最后输出所有字符串不同之处的位置和值。
以下是一个简单的示例代码：
```javascript
function diffStrings(...strings) {
const diffs = [];
// 获取字符串中最短的长度
const shortest = strings.reduce((a, b) =&gt; a.length &lt; b.length ? a : b).length;
for (let i = 0; i &lt; shortest; i++) {
const chars = [];
// 获取当前位置的字符
strings.forEach(str =&gt; chars.push(str[i]));
// 比较字符值是否相等，如果不等则记录下不同之处的位置和值
if (new Set(chars).size &gt; 1) {
diffs.push({ index: i, values: chars });
}
}
return diffs;
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efb5fb5d0babf0392d2f3a0eeaeebecb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/777c0f8fea3803b9253ac9a96bbdf978/" rel="bookmark">
			使用css制作出一个可以随意调节间距的边框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，ui设计一般是不懂css的，也就是说他们设计出来的页面可能会有些细节是原生的css语言无法做到的，就比如原生的css边框虚线之间的间距比较小，无法控制，这个时候就需要我们换个思路来操作了。
这里我们使用线性背景来制作该效果；
width: 4rpx; height: 80rpx; background-image: linear-gradient(to bottom, #FFFFFF 0%, #FFFFFF 50%, transparent 50%); background-size: 4rpx 18rpx; background-repeat: repeat-y; background-image: linear-gradient(to bottom, #FFFFFF 0%, #FFFFFF 50%, transparent 50%);
用来控制画出来的边框的颜色
background-size: 4rpx 18rpx;
用来控制画出来的边框的宽度和间距
background-repeat: repeat-y;
用来控制画出来的边框的方向是水平还是垂直
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17ae5dd61ecd242eebf3282ae6e84e20/" rel="bookmark">
			rollup.config.js 配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		`rollup.config.js` 是 Rollup 的配置文件，所有关于打包的配置都在此进行。下面是 `rollup.confing.js` 的详解：
```javascript
import babel from '@rollup/plugin-babel';
import { terser } from 'rollup-plugin-terser';
export default {
input: 'src/main.js', // 入口文件
output: [
{
file: 'dist/main.js', // 输出文件地址
format: 'umd', // 输出格式，支持 'amd', 'cjs', 'es', 'iife' 或 'umd'
name: 'myModule', // 当输出格式为 'umd' 或 'iife' 时，对应的全局变量名
plugins: [
terser(), // 代码压缩插件
],
},
],
plugins: [
babel({ // babel 转换插件
exclude: 'node_modules/**',
}),
],
};
```
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17ae5dd61ecd242eebf3282ae6e84e20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/684eae0a1ecaaf65f49e2d561118208d/" rel="bookmark">
			Linux学习笔记：history命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		history命令 bash shell会跟踪使用过的命令，history命令用于显示历史记录和执行过的指令命令。
可以通过history命令来管理或重新使用这些命令来提高使用效率
直接使用history命令来查看最近使用过的命令列表
history记录中默认会保存最近的1000条命令
若想修改保存命令的条数，可使用 env 命令修改HISTSIZE后的数字
但这只是临时修改，推荐更改 /etc/profile 配置文件来永久修改
如何调用history的命令 !数字 可指定history中特定序列号的命令。以上图为例，!3 即执行 cd test 命令
!命令 执行最近的该条命令。以上图为例，!cd 即执行 cd … 命令
!! 调用最近的一条命令。以上图为例，!！ 即执行 history 命令
清除history记录 当用户使用bash时，history会被记录在内存中；当用户登出后才会会被写入home路径的 .bash_history 文件中。可使用 history -a 命令来将内存中的记录强制写入文件。
若要清除本次登录时内存中记录的history记录，可使用命令 history -c 。这条命令不会清除文件中的记录。
若要清除文件中的记录，可使用 rm .bash_history 等命令来删除。
为了完全清除history记录，可以使用以下方法：
rm -rf .bash_history history -c 重新登录后，查看history只有一条"exit"记录。
注 仅供初学者学习使用，若有错误欢迎评论区指出
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3eb65ef2283375ba09e56cfb5c73d3e/" rel="bookmark">
			ubuntu mysql密码忘记了怎么办，ubuntu怎么查看mysql密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先输入以下指令：
sudo cat /etc/mysql/debian.cnf
运行截图如下：
2. 再输入以下指令：
mysql -u debian-sys-maint -p
//注意! //这条指令的密码输入是输入第一条指令获得的信息中的 password = ZCt7QB7d8O3rFKQZ 得来。//请根据自己的实际情况填写！
运行截图如下：(注意! 这步的密码输入的是 ZCt7QB7d8O3rFKQZ，密码是由第一条指令获得的信息中的
password = ZCt7QB7d8O3rFKQZ 得来，每个人不一样，请根据自己的实际情况输入，输入就可以得到以下运行情况）
3. 修改密码，本篇文章将密码修改成 root , 用户可自行定义。
use mysql;// 下面这句命令有点长，请注意。
update mysql.user set authentication_string=password('root') where user='root' and Host ='localhost';
update user set plugin="mysql_native_password";
flush privileges;
quit;
4. 重新启动mysql:
sudo service mysql restart mysql -u root -p // 启动后输入已经修改好的密码：root
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42a4822530987b7162ca07954b8dd9d9/" rel="bookmark">
			【opengl】两种方法在Qt中使用OpenGL库加载stl三维模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【opengl】两种方法在Qt中使用OpenGL库加载stl三维模型 OpenGL（Open Graphics Library）是一种用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序接口。OpenGL的实现利用了图形加速硬件，这些实现一般由显示设备厂商提供。但真正使用时，一般采用基于gl的第三方库，用于在程序的运行期判断当前硬件是否支持相关的扩展，防止程序崩溃甚至造成硬件损坏。目前我了解到的第三方库就有glad、glew、glfw、freeglut等，下图反映了它们之间的关系。
此外在安装Qt后，Qt本身也会对gl库进行一定的封装，即qopengl.h和QOpenGLFunctions。Qt是目前做UI非常好的一款工具，再结合它给的例子，比如cube、hellogl2等，可以仿照着做出很多比较好的人机交互界面。
对于三维模型，常用的软件有solid work，AutoCAD等，可以采用这些软件画出后导出stl模型文件。 STL 文件有2 种类型：文本文件(ASCII格式)和二进制文件(BINARY)。其中文本格式的可以用notepad++打开，它里面包含多个三角形面片的定义组成，每个三角形的定义包括三角形各个定点的三维坐标及三角形面片的法矢量，三角形顶点的排列顺序遵循右手法则。因此对于用opengl渲染stl文件，我们首先得加载它，https://free3d.com也可下到很多模型文件。
1. 使用Qt自带的库 使用Qt自带的库，窗口可继承public QOpenGLWidget, protected QOpenGLFunctions（提供了一套OpenGL ES2.0 API，免去开发人员手动解析这些函数符号）。不过关于OpenGL ES的写法，我还是有点迷糊，没有看到比较系统性的介绍，一般给的例子都是采用现成的模板，我这里采用的是Qt例子中的方法。关于stl文本文件的加载，网上就有太多方法。
bool QObjLoad::load(QString fileName, QVector&lt;float&gt;&amp; vPoints) { if (fileName.mid(fileName.lastIndexOf('.')) != ".obj" &amp;&amp; fileName.mid(fileName.lastIndexOf('.')) != ".OBJ") { qDebug() &lt;&lt; "file is not a obj file."; return false; } QFile objFile(fileName); if (!objFile.open(QIODevice::ReadOnly)) { qDebug() &lt;&lt; "open" &lt;&lt; fileName &lt;&lt; "failed"; return false; } else { qDebug() &lt;&lt; "open" &lt;&lt; fileName &lt;&lt; "success!"; } QVector&lt;float&gt; vertextPoints, texturePoints, normalPoints; QVector&lt;int&gt; facesIndexs; while (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42a4822530987b7162ca07954b8dd9d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa2c8b7a19718ee4f0db74a19c06de26/" rel="bookmark">
			Ubuntu20.04安装Nvidia显卡驱动教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、前期准备
禁用BIOS的secure boot，即disable它，如果不关闭，使用第三方源安装显卡驱动会安装后不能使用。
1、禁用nouveau
1、创建文件，如果没有下载vim编辑器，将vim换成gedit即可
$ sudo vim /etc/modprobe.d/blacklist-nouveau.conf 2、在文件中插入以下内容，将nouveau加入黑名单，默认不开启
blacklist nouveau options nouveau modeset=0 3、输入以下命令使禁用生效然后重启
$ sudo update-initramfs -u $ sudo reboot 4、重启后验证
lsmod | grep nouveau 如果回车后无反应，则禁用成功
2、安装显卡驱动
先完全卸载之前安装的显卡驱动：
ppa源文件卸载：
$ sudo apt-get remove --purge nvidia* runfile源文件卸载：
$ sudo ./NVIDIA-Linux-x86_64-384.59.run --uninstall 现在介绍最简单的安装方法----ppa源驱动安装
查询电脑最适合的显卡驱动版本
ubuntu-drivers devices 如图，我的电脑最佳显卡驱动版本为nvidia-driver-525
随后用命令行进行安装
$ sudo add-apt-repository ppa:graphics-drivers/ppa $ sudo apt-get update $ sudo apt-get install nvidia-driver-525 #此处数字要对应上面查询到的版本号 $ sudo apt-get install mesa-common-dev 注意： 如果前面没有禁用secure boot，则在安装过程中会提示设置一个密码，在重启时需要输入密码验证以禁用secure boot，重启后会出现蓝屏，这时候不能直接选择continue,而应该按下按键，选择Enroll MOK, 确认后在下一个选项中选择continue,接着输入安装驱动时设置的密码，开机。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa2c8b7a19718ee4f0db74a19c06de26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6826155dfc4806a1460196bcc9f5b407/" rel="bookmark">
			java线程池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.example.demo.test;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
public class ThreadPoolTest {
public static void main(String[] args) {
ThreadPoolTest threadPoolTest = new ThreadPoolTest();
ExecutorService executorService = Executors.newFixedThreadPool(10);
List&lt;Future&lt;String&gt;&gt; list = new ArrayList&lt;&gt;();
for (int i = 0; i &lt; 1000; i++) {
int temp = i;
Future&lt;String&gt; future = executorService.submit(new Callable&lt;String&gt;() {
@Override
public String call() throws InterruptedException {
return threadPoolTest.deal(temp);
}
});
// 如果存在失败，就停止后面的执行
if (!threadPoolTest.getResult(future)) {
break;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6826155dfc4806a1460196bcc9f5b407/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5373619591dbe4cf5d3001f70aa38d15/" rel="bookmark">
			【深度强化学习】(5) DDPG 模型解析，附Pytorch完整代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，今天和各位分享一下深度确定性策略梯度算法 (Deterministic Policy Gradient，DDPG)。并基于 OpenAI 的 gym 环境完成一个小游戏。完整代码在我的 GitHub 中获得：
https://github.com/LiSir-HIT/Reinforcement-Learning/tree/main/Model
1. 基本原理 深度确定性策略梯度算法是结合确定性策略梯度算法的思想，对 DQN 的一种改进，是一种无模型的深度强化学习算法。
DDPG 算法使用演员-评论家（Actor-Critic）算法作为其基本框架，采用深度神经网络作为策略网络和动作值函数的近似，使用随机梯度法训练策略网络和价值网络模型中的参数。DDPG 算法的原理如下图所示。
DDPG 算法架构中使用双重神经网络架构，对于策略函数和价值函数均使用双重神经网络模型架构（即 Online 网络和 Target 网络），使得算法的学习过程更加稳定，收敛的速度加快。同时该算法引入经验回放机制，Actor 与环境交互生产生的经验数据样本存储到经验池中，抽取批量数据样本进行训练，即类似于 DQN 的经验回放机制，去除样本的相关性和依赖性，使得算法更加容易收敛。 2. 公式推导 为了便于大家理解 DDPG 的推导过程，算法框架如下图所示：
DDPG 共包含 4 个神经网络，用于对 Q 值函数和策略的近似表示。Critic 目标网络用于近似估计下一时刻的状态-动作的 Q 值函数 ，其中，下一动作值是通过 Actor 目标网络近似估计得到的 。于是可以得到当前状态下 Q 值函数的目标值：
Critic 训练网络输出当前时刻状态-动作的 Q 值函数 ，用于对当前策略评价。为了增加智能体在环境中的探索，DDPG 在行为策略上添加了高斯噪声函数。Critic 网络的目标定义为：
通过最小化损失值（均方误差损失）来更新 Critic 网络的参数，Critic 网络更新时的损失函数为：
其中，， 代表行为策略上的探索噪声。
Actor 目标网络用于提供下一个状态的策略，Actor 训练网络则是提供当前状态的策略，结合 Critic 训练网络的 Q 值函数可以得到 Actor 在参数更新时的策略梯度：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5373619591dbe4cf5d3001f70aa38d15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/641fdd66efd7581858de0fe1df2eb4cc/" rel="bookmark">
			数据挖掘、机器学习和深度学习的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据挖掘、机器学习和深度学习是不同的概念。
数据挖掘是一种通过使用计算机自动处理数据来探索和提取数据中的模式和信息的过程。数据挖掘使用各种算法和技术来处理大量数据，以揭示隐藏在数据中的模式和规律。数据挖掘技术可以帮助企业或组织做出更好的决策，或为新的业务策略提供支持。
机器学习是一种人工智能技术，通过让计算机自动学习和优化任务的算法，从而改善算法的性能和准确性。机器学习通过让计算机自己学习数据中的模式和规律，来实现自动化的预测、分类、聚类和决策等任务。常见的机器学习算法包括回归、决策树、支持向量机、神经网络等。
深度学习是机器学习的一个分支，它使用人工神经网络（ANN）来学习和处理数据。深度学习的核心思想是通过将多个神经网络层连接起来，以发现数据中的高级抽象特征和模式。深度学习在许多领域取得了重大的进展，例如图像和语音识别、自然语言处理、推荐系统等。
因此，可以说数据挖掘、机器学习和深度学习都是从数据中提取有用信息和知识的过程，但它们的方法、技术和应用有所不同。数据挖掘是一种更加通用的过程，它可以使用多种技术和算法来处理数据；机器学习则更加侧重于让计算机自动学习数据中的模式和规律，以实现自动化的任务；而深度学习则是机器学习的一种高级形式，它使用深度神经网络来处理和学习数据。
另外，这三个概念在应用领域和技能要求上也存在一些差异。数据挖掘常常用于商业领域，以挖掘数据中的商业洞见，支持业务决策和战略制定。机器学习和深度学习则被广泛应用于人工智能、自然语言处理、计算机视觉、机器翻译等领域，以及预测、分类、聚类、异常检测等任务。
在技能方面，数据挖掘需要掌握统计学、数据库技术、机器学习等相关知识，同时需要具备一定的业务洞察力和数据分析能力；机器学习需要掌握数学、统计学、编程等技能，同时需要具备对数据建模和算法调优的技能；深度学习需要掌握深度神经网络的原理、算法和实现方法，同时需要具备对图像处理、语音识别、自然语言处理等领域的应用知识。
最后，需要注意的是，数据挖掘、机器学习和深度学习并不是孤立的概念，它们之间有很大的重叠和交叉。例如，机器学习和深度学习算法可以用于数据挖掘任务中，数据挖掘算法也可以用于机器学习和深度学习中的数据预处理和特征提取等环节。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69da47f70803f38051668fef6d361e6d/" rel="bookmark">
			数据挖掘与数据分析的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据挖掘和数据分析都是从数据中提取有用信息的过程，但它们在目标、方法和结果方面存在一些不同。
数据挖掘旨在发现数据中潜在的模式、趋势和规律。数据挖掘通常涉及机器学习算法和统计模型的应用，以发现数据集中的模式和规律，并从中获得洞见和预测。数据挖掘的主要目标是找到未知的模式和关联，这些模式和关联可以用于优化业务流程、增加收益或改进决策。
数据分析则更侧重于对数据进行解释和理解，以便根据数据得出结论和建议。数据分析通常包括描述性分析、探索性分析和推理性分析等方法，以便回答具体的业务问题或验证假设。数据分析的主要目标是帮助企业或组织做出更好的决策，或为新的业务策略提供支持。
因此，可以说数据挖掘是更加技术化和自动化的过程，而数据分析更注重人类的思考和决策。
此外，数据挖掘和数据分析的方法和技术也有所不同。数据挖掘通常使用的方法包括聚类分析、关联规则挖掘、分类和预测建模等，这些方法旨在自动发现数据中的模式和规律。而数据分析则更侧重于使用统计学方法、数据可视化和探索性数据分析等技术，以更好地理解数据集的结构和性质，从而进行有效的决策支持。
另外，数据挖掘和数据分析在应用领域也有所不同。数据挖掘通常应用于大规模数据集的处理，例如电子商务、金融、医疗等领域。而数据分析更广泛地应用于各种领域，例如市场营销、客户服务、人力资源管理等，通常涉及的数据集较小，但需要进行更深入的分析和解释。
最后，数据挖掘和数据分析都需要专业技能和工具的支持。数据挖掘需要掌握机器学习和数据挖掘算法、编程技能、数据库管理等技能；而数据分析需要掌握统计学、数据可视化、数据处理和分析软件等技能。同时，使用数据挖掘和数据分析需要注意数据的隐私和安全问题，以及遵守相关的法律和法规。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b0d295d2cbeacd0d1d60ed7ba304076/" rel="bookmark">
			C&#43;&#43;中using namespacr std；的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 C++ 中，using namespace std; 是一个常用的语句，它的作用是引入 std 命名空间中的所有成员到当前的命名空间中，这样在当前的作用域中就可以直接使用 std 命名空间中的所有成员，而不需要在每个标识符前加上 std:: 的前缀。
例如，在没有 using namespace std; 的情况下，要使用 std 命名空间中的 cout 和 endl，需要写成：
std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl; 而如果加上 using namespace std;，就可以直接写成：
cout &lt;&lt; "Hello, world!" &lt;&lt; endl; 这样能够减少代码的冗余，并使代码更加清晰、易读。
但需要注意的是，using namespace std; 会引入 std 命名空间中的所有成员，包括可能会和当前作用域中的其他标识符重名的成员，这可能会导致命名冲突。因此，在头文件中不建议使用 using namespace std;，而是应该使用前向声明或者直接加上 std:: 前缀来引用 std 命名空间中的成员。在源文件中可以使用 using namespace std;，但需要根据具体情况权衡是否使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/446788fd7fa16949a2c789c6dc82c3f0/" rel="bookmark">
			IOS真机调试uni.scanCode调用报错，黑屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ios调用uni.scanCode报错，真机测试黑屏。
解决：
1，升级HBuilder到最新版本。
2，在manifest.json文件添加了对应的模块权限配置（Barcode(扫码)和Camera&amp;Gallery相机和相册）。
3，勾选app对应权限配置。
4，删除就自定义基座，重新配置自定义基座或者使用标准基座运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a591a276dfc289ba5dd33e43cf772c3/" rel="bookmark">
			【笔记】Linux基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.文件和目录的操作 1.1当前工作目录 1.1.1 pwd:返回当前所在目录 1.1.2 cd(change dir):改变当前工作目录 1.2绝对路径和相对路径 1.2.1 绝对路径： 从根开始的路径，沿着绝对路径，沿着目录层级一直到达所期望的路径
1.2.2 相对路径： 相对于当前工作目录的路径
. 当前目录
. . 当前目录的父目录：
cd .. ：返回到当前目录的上一层目录
./b.txt ：在当前目录下找b.txt这个文件，如果当前目录下没有这个文件就会自动new file一个
../b.txt ：在当前目录的父目录下找b.txt这个文件
1.3 操作目录和文件 1.3.1 查看 1）ls （list的缩写）+ 路径（缺省为当前路径）:查看目录下所有的文件
-l : 查看目录下所有的文件（不包括隐藏文件）的详细信息-al ：查看目录下所有的文件（包括隐藏文件）的详细信息 ls显示不同类型的文件会显示不同的颜色：
白色：表示普通文件 蓝色：表示目录 绿色：表示可执行文件 红色：表示压缩文件 浅蓝色：链接文件 红色闪烁：表示链接的文件有问题 黄色：表示设备文件 灰色：表示其他文件 2）cat + 文本文件名：直接将文件的内容返回到终端界面（方便查看较小文件，不用每次都要进入文件）
就像这样，我在practice.txt写了一个非常简易的c++代码，通过cat命令可以很方便的查看 1.3.2 增添 1）mkdir + 目录:创建目录（也就是文件夹）
-p ：创建多层级目录 1.3.3 删除 1） rm [选项] [文件]：删除文件/目录
-f：硬性删除 -r：表明删除的是一个目录 -rf: 硬性删除目录 rm testfile 删除文件testfile
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a591a276dfc289ba5dd33e43cf772c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1764498ff5cbd72ff8a4c201e77a614b/" rel="bookmark">
			PLC编程0基础入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PLC是指可编程逻辑控制器，是现代工业自动化控制系统中常用的一种控制设备。PLC广泛应用于机械、电子、冶金、化工、轻工等领域中，对生产过程进行监控和控制。
PLC编程入门精通73节全套教程
PLC编程入门基础知识是掌握PLC技术的基础，包括PLC系统的组成、编程语言、程序设计、调试等方面的知识。下面我们来一一介绍：
一、PLC系统的组成
PLC系统主要由以下几个部分组成：输入输出模块、中央处理器、通信模块和电源模块等。其中，输入输出模块用于与外部设备进行数据交换；中央处理器负责PLC程序的解析和执行；通信模块用于PLC之间或PLC与计算机之间的通信；电源模块则提供PLC的电源供应。
二、PLC编程语言
PLC编程语言主要包括Ladder Diagram（梯形图）、Function Block Diagram（函数块图）、Structured Text（结构化文本）、Instruction List（指令列表）和Sequential Function Chart（序列功能图）等。
其中，Ladder Diagram（梯形图）是最常用的一种PLC编程语言，它的图形类似于一个电路图，非常直观易懂。如下图所示：
三、PLC程序设计
PLC程序设计主要分为以下几个步骤：确定控制对象，确定输入输出信号，编写PLC程序，测试和调试程序。
在编写PLC程序时，需要根据控制对象的特点和工作要求，设计相应的控制程序。通常情况下，PLC程序设计都采用图形化的编程方式，可以直接使用PLC编程软件进行开发和调试。
四、PLC调试
在PLC调试过程中，需要先对PLC程序进行单步调试，然后对整个PLC系统进行综合调试。单步调试主要是检查程序是否符合实际控制要求，而综合调试则需要对PLC系统的输入输出模块、中央处理器、通信模块等进行测试和检验。
在PLC调试中，需要注意一些细节问题，如输入输出信号的连接是否正确、PLC程序的正确性等。只有经过严格的调试和测试，才能保证PLC系统的正常运行。
综上所述，PLC编程入门基础知识是掌握PLC技术的必备基础。通过学习PLC系统的组成、PLC编程语言、程序设计和调试等方面的知识，可以更好地掌握PLC技术，实现对生产过程的有效控制和管理。
此外，随着工业自动化技术的不断发展和进步，PLC技术也在不断更新和完善。PLC编程软件也越来越智能化和易用化，为PLC编程带来更多便利。
在未来，PLC技术将继续发挥重要的作用，为工业自动化控制系统提供更加高效、稳定、可靠的控制方案。
以下是一张PLC控制系统的示意图：
总之，PLC编程入门基础知识是掌握PLC技术的必备基础。通过深入了解PLC系统的组成、编程语言、程序设计和调试等方面的知识，可以更好地掌握PLC技术，提高工业自动化控制系统的效率和稳定性，实现生产过程的智能化和自动化控制。
PLC编程入门：PLC编程入门精通73节全套教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39da045572db8fbcdac8ef932c8123a5/" rel="bookmark">
			如何搭建本地的Xwiki（linux版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何搭建本地的Xwiki（linux版） 1 安装docker 这一部分请参考如何安装Docker（linux版） 2 安装Xwiki 完成docker安装以后，接下来我们安装Xwiki
2-1 下载Xwiki的Docker镜像 sudo docker pull bcrosnier/tomcat-xwiki-hsql-embedded 2-2启动Xwiki sudo docker run --detach \ --publish 8080:8080 \ --name xwiki \ --restart always \ bcrosnier/tomcat-xwiki-hsql-embedded 2-3 开启防火墙的指定端口 由于Xwiki运行在8080端口上，所以我们需要开放该端口，注意千万不要直接关闭防火墙，否则Xwiki会无法启动
# 安装防火墙命令包 sudo apt install firewalld # 开启8080端口 sudo firewall-cmd --zone=public --add-port=8080/tcp --permanent # 重启防火墙才能生效 sudo systemctl restart firewalld # 查看已经开放的端口 sudo firewall-cmd --list-ports 2-4 登录Xwiki 输入http://你的IP:8080/，能够跳转Xwiki主页面：
按continue按钮，注册好admin账号后进行安装，我们这里安装完全版，点击install，直到所有组件全部安装完成！
安装完成后，界面如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ec27e74ea5cd84e12da7080a1db52bf/" rel="bookmark">
			idea：Cannot resolve plugin org.apache.maven.plugins:maven-compiler-plugin:3.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题背景 新部署一个maven项目，下载依赖
二、报错截图如下 Cannot resolve plugin org.apache.maven.plugins:maven-compiler-plugin:3.1
三、我的项目配置如下 四、分析问题 多半是maven相关配置没有生效，查看maven配置
五、问题原因 新建项目还是默认的maven配置，自定义的配置没有生效
六、解决方式 换成自定义的阿里仓库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9f7fa90be583429cba1206bfab06e32/" rel="bookmark">
			费曼学习法：快速掌握新知识！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，讲一个关于学习法则的小故事。
马克思·普朗克在1918年荣获诺贝尔物理学奖之后，他就在全德国作巡回报告。
不管被邀请到哪里，他就会对新的量子力学演讲一番。
因此，慢慢他的司机也对他的报告烂熟于心，于是就告诉他。
普朗克教授老做同样的报告，你一定觉得很无聊。
我建议在慕尼黑由我代替你做报告。
你坐在最前排带上我的司机帽，让我们换一换花样。
普朗克听了兴致盎然，欣然同意。
于是，司机就为一群物理学专家级听众做了关于量子力学的长篇报告，同样获得了大家的掌声。
之后，有一位物理学教授举手提问，司机回答说我真没有想到在慕尼黑这样先进的城市，还会有人提出这么简单的问题。
那我就请我的司机来回答这个问题吧。
在故事中，普朗克的司机因为一遍又一遍的倾听普朗克的演讲。
从而使自己可以代替普朗克做演讲报告。
但是区别在于司机的知识只是一种表演，一种模仿。就像镜子里的鲜花，虽然有鲜花的娇艳，却缺乏鲜花的芳香，并不能让自己去解决实际的问题。因此，当有人提出专业性的问题是，司机只能让真正的普朗克来解答。
在书里面作者写到知识有两种，一种是深知识，来自于那些深入了解和思考，以获得知识的普朗克。
另一种就是表面知识。来自于浅白的了解和模仿。
随着互联网的发展，我们获取知识的渠道越来越多。想要深入了解每个东西是不可能的。对于初学者来说，表面知识是有一定的好处的。
他让我们可以和其他领域的专业人士取得连接，和各种各样的人交谈，明白表面上重要的东西好过完全不了解。
如果我们没有深入了解过某种知识，就千万不要对他下定论。
因为甚至专家都有可能犯错，更何况是我们这种门外汉
表面知识，同时也有着他的坏处。
就像故事里的司机一样，我们可能认为自己其实已经明白了某些东西，但其实不是，当别人提问时就不清不楚的，回答不出来。
更糟的是，我们甚至一开始就被误导或者去误导其他人。
就像richard feynman说过的一句话，首要的原则是，你不能欺骗自己，但你是最容易被欺骗的人。
不被欺骗最好的方式就是应用批评性的思考和深入的学习。
所谓的费曼学习法就是当你学习了一个新知识后，想象自己是一个老师：用最简单的话，用自己的原话、浅显直白的话复述表达复杂深奥的知识，最好不要用行业术语，让非行业内的人也能听懂，为了达到这种效果，最好想象你是在给一个80多岁或者8岁的小孩子去讲，甚至他们都能听懂。
这里有一个很好的方法就是运用费曼学习法一共有4个步骤。
第一步，学习一样新东西，然后尽可能用简单的语言解释给小孩子，或者对相关课题不了解的朋友听。
第二步，找出别人听不懂的地方，或者是你本身无法解释的概念。
第三步回到你的资源，重新学习你的弱点，一直到能够简单的清楚解释为止。
第四步，重复以上的三个步骤，一直到你完全熟练相关的课题为止。
在费曼学习法有两个中心点，简单和准确。
看看你能不能像5岁的小孩，解释你学到的概念。如果可以的话，试着引用打比喻来解释。
创造比喻可以让你快速内化学到的东西。
他强迫你去达到别人的理解水平，让你联系和引用他们熟悉的事物来教导他们。
费曼学习法给你带来极大的好处，包括：他让你真正的了解你学到的东西，他让你更有说服力。加强你的教导技能。
增加你独立思考的能力，让你可以更容易做出明智的决定。
与此同时，可以更容易的把你学到的知识应用在现实的生活当中。活学活用
费曼学习法的灵感源自于诺贝尔物理学奖得主费曼，曾经有人看过他的期刊名为，我不知道的事。不断的挑战自己本身了解的事，就是造就他成为一个天才科学家的原因。
现在你已经知道他的学习秘密了，因此期待你也可以把它的技巧有效的应用在学习上面。
总之一句话：用大白话去解释新知识。这就是费曼技巧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38e6e6d9015e07777aac3882dfc5f28a/" rel="bookmark">
			关于解决一些游戏白屏但是有声音问题的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要是关于解决一些游戏打开白屏方法的建议
首先来讲一下白屏的原因，主要原因基本就是显卡不支持你所运行的游戏的图像功能或者有一些把显卡驱动给卸载了（当然还有一些比较离谱的像是显卡没插好，或者买到假显卡等等。。。。。。）。
解决方案
首先先按win+r唤出运行输入如下名称打开Directx诊断工具
主要是点击查看显示的运行是否有问题
正常情况下都会贴心的告诉你如下图
如果此处出现异常可以试试这个工具进行修复网址如下：https://soft.3dmgame.com/down/199657.html
当然如果还是没有正常还有一个方法，卸载显卡驱动重新安装，具体内容此处不予说明
此处还要注意这个地方3d加速是否打开，这里显示已禁用的情况时有些游戏会出现白屏问题（例如魔兽），甚至是一些视频都会出现播放问题
处理3d加速禁用问题可以按照以下操作，首先新建一个记事本写入以下文本
Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\DirectDraw] "EmulationOnly"=dword:00000000 [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Direct3D\Drivers] "SoftwareOnly"=dword:00000000 [HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\DirectDraw] "EmulationOnly"=dword:00000000 [HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Direct3D\Drivers] "SoftwareOnly"=dword:00000000 保存并退出将记事本改为reg格式如图
接着双击运行即可启动3d加速
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/690e5602fdda8c4e072bc49dd5087087/" rel="bookmark">
			vite 解决proxy跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		何为跨域？ 跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。 这里说明一下，无法跨域是浏览器对于用户安全的考虑，如果自己写个没有同源策略的浏览器，完全不用考虑跨域问题了。是浏览器的锅，对。 同源策略限制了一下行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 JS 对象无法获取 Ajax请求发送不出去
在vite.config.js中
export default defineConfig({ plugins: [vue()], server:{ //中转服务器 proxy:{ //通过代理实现跨域 '/path':{ target:'', //替换的服务器地址 changeOrigin:true,//开启代理，允许跨域 // 重写路径 --&gt; 作用与vue配置pathRewrite作用相同 rewrite: (path) =&gt; path.replace(/^\/api/, "") } } } vue中配置：
module.exports = { // 其他配置 ...... // 代理配置 devServer: { https: true, // 默认是false, 默认就是http协议，true将http协议转换为https协议 // 代理配置 proxy: { '/api': { // 配置需要代理的路径 --&gt; 这里的意思是代理http://localhost:80/api/后的所有路由 target: 'https://172.20.9.153:8085', // 目标地址 --&gt; 服务器地址 changeOrigin: true, // 允许跨域 ws: true, // 允许websocket代理 // 如果这里没有进行路径重写，当你访问http://localhost:80/api/login/,实际上访问的就是https://172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/690e5602fdda8c4e072bc49dd5087087/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/653f6f80e23fd067e35d96b329b335d3/" rel="bookmark">
			Java读取excel模板生成对应数据库表的ddl建表语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		业务功能、应该场景 一般会通过excle里，写入表的字段信息，如果新建的表、字段信息较多，自己手动写成SQL非常不方便，因此推出两个excle模板 放入对应的内容信息即可快速生成建表语句。
我这里推出两个模板，代码实现也比较简单，你也可以自定义自己工作中的模板，改写下代码即可。为了方便我这里把代码跟文件模板放在这里，需要的点我下载即可
代码部分
Maven 依赖
&lt;!--核心jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt; &lt;version&gt;4.1&lt;/version&gt; &lt;/dependency&gt; 模板1的代码
package org.example.demo.onetest.excletable; import org.apache.commons.lang3.StringUtils; import org.apache.poi.hssf.usermodel.HSSFWorkbook; import org.apache.poi.ss.usermodel.*; import org.apache.poi.xssf.usermodel.XSSFWorkbook; import java.io.*; import java.util.Iterator; /** * @author Jack Li * @description 读取excel文件内容生成数据库表ddl * @date 2022/3/27 19:54 */ public class ExcelSheet1Utils { /** * 读取excel文件内容生成数据库表ddl * * @param filePath excel文件的绝对路径 */ public static void getDataFromExcel(String filePath) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/653f6f80e23fd067e35d96b329b335d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cdb8e1b9f5126ffd39dea8c9bd1a275/" rel="bookmark">
			如何在MATLAB/python中安装Gurobi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matlab教程链接
python教程链接
Python+Gurobi的应用教学
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d9ac2cc81b49618ca5089053207be65/" rel="bookmark">
			Echart的使用初体验，Echarts的基本使用及语法格式，简单图表绘制和使用及图例添加【学习笔记】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Echart？ ECharts 是一个使用 JavaScript 实现的开源可视化库，涵盖各行业图表，满足各种需求。
ECharts 遵循 Apache-2.0 开源协议，免费商用。
ECharts 兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等）及兼容多种设备，可随时随地任性展示。
ECharts 包含了以下特性：
丰富的可视化类型: 提供了常规的折线图、柱状图、散点图、饼图、K线图，用于统计的盒形图，用于地理数据可视化的地图、热力图、线图，用于关系数据可视化的关系图、treemap、旭日图，多维数据可视化的平行坐标，还有用于 BI 的漏斗图，仪表盘，并且支持图与图之间的混搭。多种数据格式无需转换直接使用: 内置的 dataset 属性（4.0+）支持直接传入包括二维表，key-value 等多种格式的数据源，此外还支持输入 TypedArray 格式的数据。千万数据的前端展现: 通过增量渲染技术（4.0+），配合各种细致的优化，ECharts 能够展现千万级的数据量。移动端优化: 针对移动端交互做了细致的优化，例如移动端小屏上适于用手指在坐标系中进行缩放、平移。 PC 端也可以用鼠标在图中进行缩放（用鼠标滚轮）、平移等。多渲染方案，跨平台使用: 支持以 Canvas、SVG（4.0+）、VML 的形式渲染图表。深度的交互式数据探索: 提供了 图例、视觉映射、数据区域缩放、tooltip、数据刷选等开箱即用的交互组件，可以对数据进行多维度数据筛取、视图缩放、展示细节等交互操作。多维数据的支持以及丰富的视觉编码手段: 对于传统的散点图等，传入的数据也可以是多个维度的。动态数据: 数据的改变驱动图表展现的改变。绚丽的特效: 针对线数据，点数据等地理数据的可视化提供了吸引眼球的特效。通过 GL 实现更多更强大绚丽的三维可视化: 在 VR，大屏场景里实现三维的可视化效果。无障碍访问（4.0+）: 支持自动根据图表配置项智能生成描述，使得盲人可以在朗读设备的帮助下了解图表内容，让图表可以被更多人群访问！ Echarts的基本使用及语法格式 使用Echarts需要有一个容器去填充相关的图表图例
引入cdn
&lt;script src="https://cdn.staticfile.org/echarts/4.3.0/echarts.min.js"&gt;&lt;/script&gt; 首先创建一个容器（以div盒模型为例）,需要指明宽高否则不会生效。
&lt;div id="myEchart1" style="width:300px;height:200px;"&gt; &lt;/div&gt; 获取echarts对象及初始化option配置参数（JSON的数据格式）
分为三步：
// 1.根据id获取dom元素，并且创建echart实例对象 var myEchart1 = echarts.init(document.getElementById('myEchart1')); // 2.设定配置项及图表初始化数据 var option = {.....} // 3.将设置的配置项设定到echart实例中 myEchart1.setOption(option); 使用示例如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d9ac2cc81b49618ca5089053207be65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed1bc5324b0d144f158198fa4ac29d11/" rel="bookmark">
			【打造家庭服务器系列03】Frp 实现内网穿透
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 为什么要搞frp，因为我们的服务器处于家里面的网络，是没有公网IP的，所以直接通过ssh连接服务器，此时就需要一个中转来实现转发。
二、服务端配置 - Frp Server 以腾讯云为例，阿里云也一样。Frp 官方文档 --&gt; https://gofrp.org/docs/
2.1 下载Frp 下载地址：https://github.com/fatedier/frp/releases
找到适合自己系统的frp版本
# 下载frp wget https://github.com/fatedier/frp/releases/download/v0.48.0/frp_0.48.0_linux_amd64.tar.gz # 解压文件 tar -zxvf frp_0.48.0_linux_amd64.tar.gz # 查看文件列表 root@rion-mi:~/frpc_client/frp_0.48.0_linux_amd64# tree . ├── frpc	# 客户端执行程序 ├── frpc_full.ini # 客户端详细配置文件 ├── frpc.ini	# 客户端简单配置文件 ├── frps	# 服务端执行程序 ├── frps_full.ini # 服务端详细配置文件 ├── frps.ini # 服务端简单配置文件 └── LICENSE 2.2 编辑Frp Server 端配置文件 以下内容为我设置的一些内容，其他内容保持不变即可。
# 编辑frps模板配置文件 vim frps_full.ini # 编辑内容如下 # [common] bind_addr = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed1bc5324b0d144f158198fa4ac29d11/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/158/">«</a>
	<span class="pagination__item pagination__item--current">159/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/160/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>