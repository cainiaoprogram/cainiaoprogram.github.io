<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1e3553f60c442f28aedcc493f564e52/" rel="bookmark">
			使用有道云笔记的三个技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在 Windows 操作系统中写文档，做笔记，通常使用 Windows 自带的记事本，可是记事本不支持插入图片，创建表格等功能，从而不得不使用 Office Word。
不知道大家有没有这样的感觉，使用 Office Word 写文档，效率极低，需要一边敲字，一边使用鼠标排版，比如：在文章中给团队的名字“LSGO软件技术团队”加粗，就需要先用鼠标选中这个词语，然后点击工具栏中“B”形状的工具按钮。经过两步操作，才能让这个词语变成粗体 “LSGO软件技术团队”。如果笔记中存在大量的数学公式，用 Office Word 来做笔记，就需要花费更长的时间了。
自从 有道云笔记 支持 Markdown 之后，我就很少使用 Office Word 来做笔记了，主要原因如下：
使用 Markdown 能从头到尾不用鼠标，根本不用苦苦地二次选中编辑，写作效率大大提升。Markdown 简单易学，只需要记住几个标签即能上手使用。Markdown 支持 Latex 语法，对于我们这种经常写数学公式的人来说，简直就是福音。Markdown 对程序员非常友好，可对笔记中的代码高亮语法显示，与集成开发环境相融。有道云笔记 提供的 Markdown 编写环境，把页面分为两边，左边编辑，右边预览，排出的版面又简约又舒适。有道云笔记 提供了分享功能，写完的笔记可以方便的分享给他人。有道云笔记 不仅支持 Windows系统 还支持 Mac、IOS、Android，这样自己在任何一个终端写的笔记都可以自动同步。 有道云笔记 Markdown 编写环境，如下图所示：
虽然 有道云笔记 已经非常方便，能够大大的提升写作效率，是自己最常用的工具之一。
可是 Office Word 可以：
很方便的改变文字的大小、颜色和对齐方式。很方便的修改表格样式。很方便的插入目录，建立笔记的章节索引。 这些功能，如何在 有道云笔记 中方便的实现呢？这是一直困扰自己的问题。
遇到问题，就是提升自己的机会。要想办法搞定它。
于是，首先在 有道云笔记 的官网找帮助手册。不幸的是，发现与 Markdown 有关的帮助文档只有两篇：
【简明版】有道云笔记Markdown指南 (http://note.youdao.com/iyoudao/?p=2411)【进阶版】有道云笔记Markdown指南 (http://note.youdao.com/iyoudao/?p=2445) 更不幸的是，这两篇帮助文档中根本没有以上三个问题的一点点线索。
要是以前，我就凑合着用了，毕竟比起用 Office Word， 已经大大的提升了工作效率。
但每个人都有 元认知能力，这种能力让自己意识到，凡事凑合了事，差不多就行，这是在给自己的懒惰找借口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1e3553f60c442f28aedcc493f564e52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/068b63bedd607bd30c66653b59327277/" rel="bookmark">
			史上最全的Ceph介绍、原理、架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Ceph架构简介及使用场景介绍 1.1 Ceph简介 Ceph是一个统一的分布式存储系统，设计初衷是提供较好的性能、可靠性和可扩展性。
Ceph项目最早起源于Sage就读博士期间的工作（最早的成果于2004年发表），并随后贡献给开源社区。在经过了数年的发展之后，目前已得到众多云计算厂商的支持并被广泛应用。RedHat及OpenStack都可与Ceph整合以支持虚拟机镜像的后端存储。
1.2 Ceph特点 高性能
a. 摒弃了传统的集中式存储元数据寻址的方案，采用CRUSH算法，数据分布均衡，并行度高。
b.考虑了容灾域的隔离，能够实现各类负载的副本放置规则，例如跨机房、机架感知等。
c. 能够支持上千个存储节点的规模，支持TB到PB级的数据。
高可用性
a. 副本数可以灵活控制。
b. 支持故障域分隔，数据强一致性。
c. 多种故障场景自动进行修复自愈。
d. 没有单点故障，自动管理。
高可扩展性
a. 去中心化。
b. 扩展灵活。
c. 随着节点增加而线性增长。
特性丰富
a. 支持三种存储接口：块存储、文件存储、对象存储。
b. 支持自定义接口，支持多种语言驱动。
1.3 Ceph架构 支持三种接口：
Object：有原生的API，而且也兼容Swift和S3的API。
Block：支持精简配置、快照、克隆。
File：Posix接口，支持快照。
rados
1.4 Ceph核心组件及概念介绍 Monitor
一个Ceph集群需要多个Monitor组成的小集群，它们通过Paxos同步数据，用来保存OSD的元数据。
OSD
OSD全称Object Storage Device，也就是负责响应客户端请求返回具体数据的进程。一个Ceph集群一般都有很多个OSD。
MDS
MDS全称Ceph Metadata Server，是CephFS服务依赖的元数据服务。
Object
Ceph最底层的存储单元是Object对象，每个Object包含元数据和原始数据。
PG
PG全称Placement Grouops，是一个逻辑的概念，一个PG包含多个OSD。引入PG这一层其实是为了更好的分配数据和定位数据。
RADOS
RADOS全称Reliable Autonomic Distributed Object Store，是Ceph集群的精华，用户实现数据分配、Failover等集群操作。
Libradio
Librados是Rados提供库，因为RADOS是协议很难直接访问，因此上层的RBD、RGW和CephFS都是通过librados访问的，目前提供PHP、Ruby、Java、Python、C和C++支持。
CRUSH
CRUSH是Ceph使用的数据分布算法，类似一致性哈希，让数据分配到预期的地方。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/068b63bedd607bd30c66653b59327277/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cb1ed1ab49eeee329276c97ae859bd7/" rel="bookmark">
			Ubuntu编译找不到eigen3的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在编译lsd_slam的时候报错
CMake Error atCMakeLists.txt:23 (find_package):
By not providing"FindEigen3.cmake" in CMAKE_MODULE_PATH this project has
asked CMake tofind a package configuration file provided by "Eigen3", but
CMake did not findone.
Could not find apackage configuration file provided by "Eigen3" with any
of the followingnames:
Eigen3Config.cmake
eigen3-config.cmake
Add theinstallation prefix of "Eigen3" to CMAKE_PREFIX_PATH or set
"Eigen3_DIR"to a directory containing one of the above files. If "Eigen3"
provides aseparate development package or SDK, be sure it has been
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cb1ed1ab49eeee329276c97ae859bd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a86e44a83952c6f742ffe34aadf1788/" rel="bookmark">
			矩阵转置算法和一些简单的加，减，乘法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矩阵转置分为方阵的转置和非方阵的转置，方阵支持原地转置，非方阵则不支持。
方阵原地转置算法：
template&lt;class T&gt; void transpose(T **a,int rows) { for(int i=0;i&lt;rows;i++) for(int j=i+1;j&lt;rows;j++) swap(a[i][j],a[j][i]) } 因为方阵转置前后他们的形状不变，所以可以原地转换。
一般矩阵的转置方法：
template&lt;class T&gt; void transpose(T **a,int rows,int cols) { T **b=new T*[cols]; for(int k=0;k&lt;cols;k++) b[k]=new T[rows] for(int i=0;i&lt;rows;i++) for(int j=i+1;j&lt;cols;j++) swap(a[i][j],b[j][i]) return b } for(int i=0;i&lt;cols;i++) delete [] b[i]; delete [] b; 对于一般矩阵，转置后空间会不一样，所以我们事先在堆中为转置后的矩阵申请一块空间，然后再进行赋值运算，最后返回转置后的矩阵，但是注意，申请的空间在用后，要手动析构不然会出现内存泄漏。
两个矩阵的加法：
template&lt;class T&gt; void matrixAdd(T **a,T **b,T **c,int numberOfRows,int numberOfCols) { for (int i=0;i&lt;numberOfRows;i++) for(int j=0;j&lt;numberOfCols;j++) c[i][j]=a[i][j]+b[i][j] } 这个加法很简单吧。
m*n矩阵与n*p矩阵的乘法:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a86e44a83952c6f742ffe34aadf1788/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d013f59b82a02294ec312c3a301b5ef/" rel="bookmark">
			Redis集群重启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器ip 192.168.251.51 以下，为伪集群模式，redis服务重启流程演示：
第一步 查看所有redis进程 [root@i-netlrktd ~]# ps -ef|grep redis root 1477 1 0 Aug09 ? 00:02:06 redis-server *:6371 [cluster] root 1481 1 0 Aug09 ? 00:02:05 redis-server *:6372 [cluster] root 1489 1 0 Aug09 ? 00:02:03 redis-server *:6373 [cluster] root 1493 1 0 Aug09 ? 00:01:56 redis-server *:6374 [cluster] root 1497 1 0 Aug09 ? 00:01:54 redis-server *:6375 [cluster] root 1505 1 0 Aug09 ? 00:01:54 redis-server *:6376 [cluster] root 25131 25105 0 09:37 pts/0 00:00:00 grep redis [root@i-netlrktd ~]# 第二步杀进程-关进程 kill 掉所有redis进程 kill -9 1477
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d013f59b82a02294ec312c3a301b5ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb718a1ba5afefd543dd6a7cc0587bb2/" rel="bookmark">
			intellij idea配置网络代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景：intellij idea所在的这台电脑本身上不了网，要通过代理上网。
使用代理上网，以往都是在IE的工具-Internet选项-连接里进行设置就OK了，谷歌浏览器啥的就可以上网了。但intellij idea不行，gradle不行，提示什么
Unknown host 'services.gradle.org'. You may need to adjust the proxy settings in Gradle. ；然后想在Intellij idea里安装个FindBugs插件，报错说下载不了，这才知道是网络问题。
那么intellij idea怎么设置代理上网呢？
入口在插件这里：File-settings-plugins 根据实际情况填写就可以了。
直接在setting里设置都可以了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5817dc9e466119b8aa31c92f1b67788b/" rel="bookmark">
			软件设计-UML类图详解说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 UML类图思维导图 二、 详细分析和介绍 下面就从上面的思维导图开始，详细的介绍UML类图！
1、 什么是UML，概念是什么？ UML（Unified Modeling Language）中文统一建模语言，是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。 【维基百科】
统一建模语言（英语：Unified Modeling Language，缩写 UML）是非专利的第三代建模和规约语言。UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。【维基百科】
UML分为UML模型和UML类图。
区分UML模型和UML图是非常重要的，UML图，包括用例图、协作图、活动图、序列图、部署图、构件图、类图、状态图，是模型中信息的图形表达方式，但是UML模型独立于UML图存在。
2、为什么要用UML？类图的作用 UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。
类图的作用：
（1）：在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解；
（2）：类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。
3、 类的UML的介绍和画法？ 我们用 PowerDesign 来构建 UML图
类的UML使用包含类名、属性、方法名以及参数。使用带分割线的长方形表示。
一、 类名 在第一部分 每个类都必须有一个名字，类名是一个字符串，根据java命名规范 类名首字母大写 二、 属性 在第二部分 属性是指类的性质，即类的成员变量。一个类可以有任意多个属性，也可以没有属性。 UML规定属性的表示方式为：
可见性 名称:类型 [ = 缺省值 ]
**可见性：**表示该属性对于类外的元素而言是否可见，包括公有(public)、私有(private)和受保护(protected)三种，在类图中分别用符号+、-和#表示。 +表示 public属性， - 表示 private属性， # 表示 protected属性**名称：**表示属性名，用一个字符串表示。**类型：**表示属性的数据类型，可以是基本数据类型，也可以是用户自定义类型。**缺省值：**是一个可选项，即属性的初始值。 三、 方法(操作) 在第三部分 操作是类的任意一个实例对象都可以使用的行为，是类的成员方法。 UML规定操作的表示方式为：
可见性 名称(参数列表) [ : 返回类型]
可见性: 定义与属性的可见性定义相同。名称: 即方法名，用一个字符串表示。参数列表: 表示方法的参数，其语法与属性的定义相似，参数个数是任意的，多个参数之间用逗号“，”隔开。返回类型: 是一个可选项，表示方法的返回值类型，依赖于具体的编程语言，可以是基本数据类型，也可以是用户自定义类型，还可以是空类型(void)，如果是构造方法，则无返回类型。 由于在Java语言中允许出现内部类，因此可能会出现包含四个部分的类图，如图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5817dc9e466119b8aa31c92f1b67788b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ff6029628f5214c963aed0ca5781003/" rel="bookmark">
			ipconfig /renew
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ipconfig /flushdns 敲回车键即可将你本机上的dns缓存清空了
ipconfig /release 敲回车键即可将释放本机的IP地址
ipconfig /renew 敲回车键即可将可得到一个新的IP地址
在桌面建立以文本文档（TXT），桌面空白处右击：新建—文本文档；写上文件名，我这里就给文件名为“换IP清空dns地址”
IP释放、更新、以及清除
IP释放、更新、以及清除
2
在刚刚新建的文本文档（TXT）中写入”
ipconfig /flushdns
ipconfig /release
ipconfig /renew
ipconfig /all
“
记得每个代码一行，然后保存
IP释放、更新、以及清除
3
在把文件”换IP清空dns地址“的文件后缀”txt“改为”Bat“就可以下次要用的时候双击 文件换IP清空dns.bat 即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b2b7777675d6e0a306904c8758b492c/" rel="bookmark">
			【python Excel】如何使用python将大量数据导出到Excel中的小技巧之二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近对python的openpyxl 升级到了__version__ = '2.5.4'，发现原先的代码不能使用，各种报错之后，然后重新了写的版本，故分享给各位同仁。如有错误，敬请赐教。
# coding:utf-8 """ File Name: Excel.py Function: 实现 将计算结果的保存形式由txt转化为excel 的类 Comments: 将计算结果的保存形式由txt转化为excel，从而方便对数据的分析和使用 Author: yyz Update Time: 2018-06-27 09:57:16 """ # 系统包 import sys reload(sys) sys.setdefaultencoding("utf-8") # workbook相关 from openpyxl.workbook import Workbook from openpyxl.utils import get_column_letter from openpyxl.reader.excel import load_workbook # 自引包 from Text import Text class Excel(): '''Excel相关操作类''' def __init__(self): self.__in_txt_filename="" self.__out_save_excel_filename="" self.__head_row_name_list=[u'字段1', u'字段2', u'字段3'] def __read_excel_with_openpyxl(self, excel_name): #读取excel2007文件 wb = load_workbook(filename=excel_name) sheetnames = wb.get_sheet_names() ws = wb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b2b7777675d6e0a306904c8758b492c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f44d0e096b71362577bdbc49490339f7/" rel="bookmark">
			Centos7 卸载jdk1.8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先 ：rpm -qa|grep java 这里有两个版本的jdk 所以我们需要卸载两个jdk
使用 yum 卸载： yum -y remove java-1.8.0-openjdk-headless-1.8.0.65-3.b17.el7.x86_64
然后再查看：rpm -qa|grep java 我的电脑没有 nodeps 这个功能，所以我选择 yum 卸载
最后发现还是没有卸载干净 所以就要我们手动删除了
使用 rpm -e 命令来卸载
注：这三个不要删掉
然后这里我们可以安装自己的jdk了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12e03b17ea889f8b32f0d3202d77e017/" rel="bookmark">
			input单选组（radio）,点击事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 $("input[type='radio']").on("click",function(){ console.log($(this).val()); }) name一致保持单选效果：
&lt;label style="width:120px;"&gt; &lt;input name="link" type="radio" value="0"/&gt; 服务类别 &lt;/label&gt; &lt;label style="width:120px;"&gt; &lt;input name="link" type="radio" value="1" checked="checked"/&gt; 外部链接&lt;/label&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94dd0b782063cee0d35415cea077c760/" rel="bookmark">
			升级pip失败，pip安装时超时错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python -m pip install -U pip #升级pip pip 超时下载时
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24d966cc275499912701399fac930bae/" rel="bookmark">
			pyspark连接MySQL出错 java.sql.SQLException: No suitable driver
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pyspark连接MySQL出错py4j.protocol.Py4JJavaError: An error occurred while calling o26.load.
: java.sql.SQLException: No suitable driver 解决方法
（1）错误提示：
Using Spark's default log4j profile: org/apache/spark/log4j-defaults.properties Setting default log level to "WARN". To adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel). 18/07/13 10:23:51 WARN NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable 18/07/13 10:23:51 WARN Utils: Your hostname, localhost resolves to a loopback address: 127.0.0.1; using 10.2.33.175 instead (on interface en0) 18/07/13 10:23:51 WARN Utils: Set SPARK_LOCAL_IP if you need to bind to another address Traceback (most recent call last): File "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24d966cc275499912701399fac930bae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fdc4d8a75a28f84c9160221eb1d0d93/" rel="bookmark">
			《快学Scala》- 练习题 第二章 控制结构和函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		练习题 练习题 1、一个数字如果为正数，则它的signum为1；如果是负数,则signum为-1；如果为0,则signum为0；编写一个函数来计算这个值。2、一个空的快表达式{}的值是什么？类型是什么？3、在Scala中何种情况下赋值语句x=y=1是合法的。(提示：给x找个合适的类型定义)4、针对下列Java循环编写一个Scala版本： for(int i=10;i&gt;=0;i–) System.out.println(i);5、编写一个过程countdown(n:Int)，打印从n到0的数字。6、 编写一个for循环,计算字符串中所有字母的Unicode代码的乘积。举例来说，”Hello”中所有字符串的乘积为9415087488L。7、 同样是解决前一个练习的问题，但这次不使用循环。（提示：在Scaladoc中查看StringOps）8、编写一个函数product(s:String)，计算前面练习中提到的乘积9、 把前一个练习中的函数改成递归函数10、编写函数计算x^n,其中n是整数，使用如下的递归定义: 1、一个数字如果为正数，则它的signum为1；如果是负数,则signum为-1；如果为0,则signum为0；编写一个函数来计算这个值。 def signum(num: Int): Int = { if (num &gt; 0) 1 else if (num &lt; 0) -1 else 0 } 2、一个空的快表达式{}的值是什么？类型是什么？ 使用Scala REPL，表达式{ }的值是()，类型Unit 3、在Scala中何种情况下赋值语句x=y=1是合法的。(提示：给x找个合适的类型定义) 在Scala中，赋值语句的返回值是Unit类型，因此需要把x定义成Unit类型即可。
scala&gt; var x = {} x: Unit = () scala&gt; var y = 8 y: Int = 8 scala&gt; x = y = 1 x: Unit = () 4、针对下列Java循环编写一个Scala版本： for(int i=10;i&gt;=0;i–) System.out.println(i); for( i &lt;- 0 to 10 reverse ) println(i) for (i &lt;- Range(0, 10).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fdc4d8a75a28f84c9160221eb1d0d93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8b5a09475df7dd0937fff399e4fa6a0/" rel="bookmark">
			Eclipse 前进一步 快捷键 （eclipse实用快捷键）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用eclipse经常会用到后退一步快捷键 Ctrl+Z ，但是很容易就后退过头了，这个时候我们要前进一步。
我在网上搜了一很久也没找到，最后还是问我同事才解决的。
快捷键：Ctrl+ Y 前进一步
常用快捷键：
Ctrl+pageDown/Up浏览前后选项卡
Ctrl+Q 定位到最后编辑
Ctrl+W关闭当前Editer
Alt+Shift+R重命名
Ctrl + Y 前进一步
Ctrl + Z 后退一步
Ctrl+ / 注释
Ctrl +D 删除一行
Alt + up 将选中行与上一行换位
Alt + down 将选中行与下一行换位
Ctrl + O 搜索变量 方法（灰常实用）
Ctrl + L 定位到某一行
[Alt+←]、[Alt+→]
后退历史记录和前进历史记录，在跟踪代码时非常有用，用户可能查找了几个有关联的地方，但可能记不清楚了，可以通过这两个快捷键定位查找的顺序。
ALT+/
此快捷键能为用户提供内容的辅助，不用为记不全方法和属性名称犯愁，只要输入首字母再按这个快捷键就可以看到想要的方法和属性名。
查看和定位快捷键：
1. Ctrl+K、Ctrl++Shift+K
快速向下和向上查找选定的内容，从此不再需要用鼠标单击查找对话框了。
5. Ctrl+Shift+O
快速生成import，当从网上拷贝一段程序后，不知道如何import进所调用的类，试试[Ctrl+Shift+O]快捷键，一定会有惊喜。
6. Ctrl+Shift+F
格式化代码，书写格式规范的代码是每一个程序员的必修之课，当看见某段代码极不顺眼时，选定后按[Ctrl+Shift+F]快捷键可以格式化这段代码，如果不选定代码则默认格式化当前文件（Java文件）。
调试快捷键：
Eclipse中有如下一些和运行调试相关的快捷键。
1. Ctrl+Shift+B：在当前行设置断点或取消设置的断点。
2. F11：调试最后一次执行的程序。
3. Ctrl+F11：运行最后一次执行的程序。
4. F5：跟踪到方法中，当程序执行到某方法时，可以按[F5]键跟踪到方法中。
5. F6：单步执行程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8b5a09475df7dd0937fff399e4fa6a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deac919918e9df59dddb0156334c8e4f/" rel="bookmark">
			yum  intall   -y lrzsz*   后，在命令行输入rz时出现CCCC0100000023be50e.**B0100000023be50
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 因为我是在虚拟机下安装使用，所以出现这错误提示，使用终端如secureCRT、Xshell连接后，再rz，ok！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/751ab68d8359be489d1212b647e338ce/" rel="bookmark">
			win10系统中如何解决cmd中的路径和现在电脑的用户名不一致
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设原用户名老王，已删除，但是cmd后路径还是C:\Users\老王&gt;，这与现在用户laowng不一致了需改为C:\Users\laowang&gt;。 1.先新建一个管理员账户laowang，然后登陆laowang这个账户； 2.重命名 c:\Users\老王 为 c:\Users\laowang； 3.打开注册表编辑器（win+R 输入 regedit），定位到 HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList 的某一子项（S-1-5-21... 开头的），将“数据名称”为 ProfileImagePath 的“数值数据”内容 C:\Users\老王 改为 C:\Users\laowang； 4.改后用laowang这个用户登陆即可。 转载于:https://www.cnblogs.com/xiaoai666/p/9298195.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b99cea635dc6a60fec5883d381821728/" rel="bookmark">
			okHttp详细日志打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		okHttp详细日志打印 本文简单介绍下使用okHttp后如何打印详细日志的简单完成。
我们使用okHttp、Retrofit来请求网络都是okHttp的基础类来进行网络请求的。
OkHttp也提供了一个网络拦截器okhttp-logging-interceptor，
通过它能拦截okhttp网络请求和响应所有相关信息（请求行、请求头、请求体、响应行、响应行、响应头、响应体）。
OkHttp的官网地址：https://github.com/square/okhttp
下面是使用日志拦截的过程：
一.依赖拦截日志地址 compile 'com.squareup.okhttp3:logging-interceptor:3.5.0' 大家如果不能依赖，可以用我后面Demo下的jar包，由于公司环境原因，我是很多依赖不能使用的！
二.定义拦截器中的网络日志工具 依赖拦截日志地址，后就能识别HttpLoggingInterceptor。
之后定义一个要打印日志的类。
public class HttpLogger implements HttpLoggingInterceptor.Logger { @Override public void log(String message) { Log.d("HttpLogInfo", message);//okHttp的详细日志会打印出来 } } 三.创建日志对象，并且放到okHttp请求对象中 HttpLoggingInterceptor logInterceptor = new HttpLoggingInterceptor(new HttpLogger());//创建拦截对象 logInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);//这一句一定要记得写，否则没有数据输出 //网络请求对象 OkHttpClient client = new OkHttpClient.Builder() .sslSocketFactory(createSSLSocketFactory()) .hostnameVerifier(new TrustAllHostnameVerifier()) .connectionPool(new ConnectionPool(8, 10, TimeUnit.MINUTES)) .readTimeout(600, TimeUnit.SECONDS) .addNetworkInterceptor(logInterceptor) //设置打印拦截日志 // .addInterceptor(new LogInterceptor()) //自定义的拦截日志，拦截简单东西用，后面会有介绍 .build(); 下面是拦截自己Post请求的一个示例日志： 可以看到里面打印了很多详细的信息，比如请求地址，请求方式，请求头，返回的数据内容等等。
这里提供一下我运行demo的代码，里面有三个目前最新的jar包：okhttp、okio、logging-interceptor
示例代码有get、post的请求示例，还有一段跳过SSL证书校验的代码。
地址：https://download.csdn.net/download/wenzhi20102321/10536033
其他： 这里说一下其实简单日志拦截是可以自己写的，代码不多。
后面看了下logging-interceptor-xx.jar这个jar包里面其实就是一个类！代码有三百多行。
如果不想导入拦截日志的jar包可以复制okHttp项目中这个类的的代码进入项目就可以实现日志拦截了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b99cea635dc6a60fec5883d381821728/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f23fc4988249b97b4945563e085ebde8/" rel="bookmark">
			maven初使用：IDEA使用maven构建多模块项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 新建一个maven工程，修改里面的pom文件 将&lt;packaging&gt;jar&lt;/packaging&gt;修改成&lt;packaging&gt;pom&lt;/packaging&gt;，表示它是一个被依赖的父项目 新建module模块，选择并创建maven工程，该maven工程为子模块，需要注意几点： 1.子项目中除了&lt;parent&gt;标签内的&lt;groupId&gt;/&lt;version&gt;外的&lt;groupId&gt;/&lt;version&gt;可以删除 2.一般的子模块修改&lt;packaging&gt;为jar，如果为web模块则需要修改为war 3.如果子模块需要引入其他的子模块，则需要在&lt;dependencies&gt;标签中引入该模块，包括&lt;artifactId&gt;/&lt;groupId&gt;/&lt;version&gt;即可；如果在B模块中引入了C模块，那么A模块只需要引入B模块就可以引入B和C模块了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d67798fd91985c68fca73793c6149661/" rel="bookmark">
			限流保护电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		限流保护电路最基本的原理图如下：
向左转 | 向右转 当电流小于设定值时，由R1提供P3的偏置电流，P3饱和导通，对电流不起控制作用。
当电流大于或等于设定值时，R上的压降增大，R上的压降与三极管结压的和接近R2的压降，于是开始限制P3通过的电流，这样就把电流限制在一定的水平。
也可将R2换成一个稳压管，限流更为精确。
上述保护电路的缺点是当电流超载时，特别是发生短路时，所有压降都降在三极管上，存在一定的功耗。
设计成具有自锁也就是当电流没有超载时，三极管完全导通，当发生短路时，则将三极管完全关闭。
简单的原理图如下：
向左转 | 向右转 ;;;;;;电路的缺点为没有对外部旁路晶体管采取过电流保护措施，像输出短路所造成的状况。如图18.34所示可以加进额外的限流电路（Qlim和Rlim），来防止过多的电流通过Qext，以及防止可能产生烧毁的情况。;;;;;;;;;;;;; ;;; 接下来将说明限流电路的工作原理。电流感测电阻Rlim可以设定晶体管Qlim的VBF。Qext的基极一发射极电压现在是由VRext-VRlim来决定，其中的减号是因为它们极性相反的缘故。因此，在正常工作方式下，Rex,的电压降必须足以克服Rlim的相反极性电压降。如果因为输出短路或负载故障，使通过Qext的电流超过某一个最大电流值Iext(max)则Rmin两端的电压会到达0.7V，并使Qlim导通。此时Qlim会将电流从Qext引开，不经过Qext，改从调整器通过，强迫调整器发生热过载的情形，并使调整器关闭。请记住，集成电路调整器内部都已经具有热过载的保护措施，这是其电路设计的一部分。;;; 这个过程如图18.35所示。在图18.35(a)中，当电路正常工作时，Qlim关闭，且Qext导通的电流低于它所能承受的最大电流。图18. 35(b)显示当负载短路时所发生的情形。通过Qext的电流忽然增加，而使Rlim两端的电压降增加，接着使Qlim开启。此时电流转向通过调整器，使它因为热过载而关闭。;;;;;;;;;;;;;; ;;; 当应用电路需要向阻抗值会变动的负载供应固定电流时，三端点调整器可以当作电流源使用。其基本电路如图18. 36所示，其中R1是设定电流的电阻。 ITR8307-TR8调整器在接地端（在这个例子中并未实际接地）和输出端之间提供固定电压Vout.这个电压决定了供应负载的固定电流值。;;;;;;;;;;;; IL=Vout/R1+Ic;;;; (18.11);;;;;;;;;;;;;;;;;;;;; LM358实现限流功能：
用LM358的其中一个运放搭建的负反馈恒流控制电路，根据运放的虚短原理，在直流工作点，负反馈运放的两个输入电压相等，因此R28上的电压恒等于rt分压后输出的电压，因此流过Q4的电流等于rt分压后输出的电压/R28。　小信号分析：当出现微小扰动导致Q4电流增大时，R28上的电压增大，运放反相输入端电压上升，运放输出电压下降，Q4的输入电流ib减小，使Q4的电流减小，实现负反馈。　加入R31的原因是Q4为NPN，需要将LM358输出的电压转化为电流输入给Q4；　LM358自带内部补偿，因此不需要外加补偿即可实现稳定恒流输出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5adba33eef4d1f3a272718369891ff61/" rel="bookmark">
			CPN（Cascaded Pyramid Network for Multi-Person Pose Estimation) 姿态估计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博客是对论文《Cascaded Pyramid Network for Multi-Person Pose Estimation》的个人解读，以及对代码（tensorflow版本)的细节分析。 其他资料： 旷视研究院详解COCO2017人体姿态估计冠军论文实录 | 旷视研究院详解COCO2017人体姿态估计冠军论文（PPT+视频) 前言 目前对多人的姿态点检测的算法总体分为两类：
bottom-up 方法：此方法直接预测关键点，再判断关键点分别属于哪个人，代表有openposetop-down方法：此方法为两阶段方法，先检测人，再根据检测的人的框使用单人姿态点检测算法SPPE（a single-person pose estimator）对每一个人进行关键点的检测，最后整合回原图。 两种方法的区别：
由于top-down方法依赖于人体检测框的结果，非常容易受其影响。比如如果人体重叠部分过大，则可能只检测出一个检测框，导致准确度下降，如下图1所示：top-down算法的时间成本会随着图像中的人数增加而增加，每增加一个人就要进行一次SPPE算法。bottom-up相比没有以上两点问题。 图1 人物重叠容易导致检测框只检测到一个人，从而影响关键点检测。 摘要 论文提出的关键点检测算法是SPPE,提出了一种网络结构，能够对不可见的关键点，重叠的关键点，模糊难以辨识的关键点的检测，克服复杂背景的影响。网络分为两部分：
GlobalNet：为一个FPN网络，用来检测比较简单的关键点，如眼睛，手;但对不可见的等较难的点判断并不是很好。RefineNet：主要是用来检测非常难分辨的关键点，他的输入的GlobalNet的几个不同层次的特征来在线的（后文会讲到如何在线）对判断困难的关键点进行检测。 论文的方法获得了COCO 人体姿态点检测的2017年冠军，在COCO test-dev上的平均检测精度为73.0，在COCO test-challenge 数据集上平均检测精度 72.1，比2016年冠军的60.5高出了19%！
网络结构解读 图2 SPPE网络结构图
GlobalNet 图3 Globalnet 首先，GlobalNet的输入并不是一幅图像，而是Resnet的4个blocks提取出的特征图，论文中分别以C2,C3,C4,C5来代表。其中C2，C3由于层数较浅，所以有很高的空间精度即能够很好的定位原图信息，但是语义信息不足;相反，C4，C5，拥有较高的语义信息，但是空间分辨率较低，不足以定位图像信息。所以，GlobalNet采用FPN的结构充分的利用各个层次的不同信息来对关键点的heatmap进行预测。 注：GlobalNet与FPN稍有不同，在升采样（upsampling process）之后，两层相加之前，要再进行一次1×1的卷积操作。 输入到Globalnet中的每一层要进行的操作：
net1 (from resnet) —&gt; 1*1 conv —&gt; upsampling —&gt; 1 * 1 conv —-&gt; elem-sum(与下一层) ——&gt; predict —&gt; L2 loss
代码解读： def create_global_net(blocks, is_training, trainable=True): ''' blocks: 即C2，C3，C4，C5 ''' global_fms = [] #GlobalNet的输出求loss global_outs = [] #RefineNet的输入！！！ last_fm = None #初始化 initializer = tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5adba33eef4d1f3a272718369891ff61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7c4ba47fe998c8125ecb0547158ad00/" rel="bookmark">
			接口测试 [测试报告优化] Jenkins&#43;JMeter 接口自动化【转载】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文地址：https://testerhome.com/topics/3773
之前看到社区里有大侠分享过Jenkins+JMeter接口自动化的实现，比如@snake 的精彩贴子：https://testerhome.com/topics/2580
所以具体实现过程我这里不多写了，我重点写下对生成的HTML测试报告进行优化。
如果按JMeter默认设置，生成报告如下：
从上图可以看出，结果信息比较简单，对于运行成功的case，还可以将就用着。但对于跑失败的case，就只有一行assert错误信息。（信息量太少了，比较难找到失败原因）
优化大致过程 1、修改jmeter.properties文件，打开一些输出内容开关（下图根据需要选择相关项，具体就不用多说了吧） 2、制定一份自己的输出模板。（不用默认的jmeter_home/extras/jmeter-results-detail-report.xsl模板，也可以网上自己找份。） 3、最后执行，生成对应的HTML报告（一般我们都在linux环境 下运行，语句大致如下，其中my_project_template.xsl就上第2步说的定制模板，这个是网上找的一份。） xsltproc $jmeter_home/extras/my_project_template.xsl $my_project_workspace/result/jtl/$test_name/${test_name}.jtl &gt; $my_project_workspace/result/html/$test_name/${test_name}.html
最后报告如下： 优化后的HTML报告，多了接口地址、接口参数、Headers信息（包括cookie、session），而且有返回结果。失败原因一目了然 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cc64528bc6a1c942d99a160f8c252cc/" rel="bookmark">
			Tomcat中的应用无缘无故启动两次及生成ROOT目录问题详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、部署环境： centOS+nginx+tomcat8集群 2、应用架构 springboot +springcloud 3、场景还原： 将本地项目打war包扔到tomcat8的webapps目录下，如图所示： 修改tomcat的conf文件夹下的server.xml ,使之能够通过”/”目录进行访问，如图所示：添加Context 标签，并制定docBase为自己的应用包名： 并到 /bin下执行./startup.sh，启动tomcat 4、问题描述： 启动tomcat后会在webapps目录的ROOT目录下生成一个和ccx-axis-1.0-SNAPSHOT相同的一个目录，如图所示： 两个文件夹中的内容是完全相同的，而且在启动tomcat后，此应用会启动两次，第一次能正常启动，第二次启动则会产生端口号本站用等错误，具体请看日志： 第一次启动： 第二次启动： 5、解决方案： 网上百度了一些解决方案，都没有说ROOT目录如何删除掉或者为什么会启动两次的问题，后来了解到，如果tomcat的server.xml文件中的docbase的地址为一个war包时候，如docBase=”C:/apache-tomcat-6.0.32/myapps/bc.war”,那么tomcat会解压war包到ROOT目录下，如果docBase的地址为一个解压好的目录时，tomcat就不会再解压war包，所以就不会有ROOT目录了， 我的server.xml配置的完全没有问题，也没有指向war包，为啥也不行呢，我先把war包删除试一下： 结果：不会生成ROOT目录，可是tomcat里面的应用仍然会启动两次（注意，不是tomcat启动两次，是部署在tomcat里的应用会启动两次，就相当于有两个解压好的war包仍在tomcat的webapps里，且这俩包都是一样的）； 在原来的基础上做第二次尝试：修改conf路径下的server.xml文件的appBase目录，将appBase的指向目录由webapps修改为空，并重启tomcat，则完美解决问题！！！具体如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a44a90915aa3409f116757a964f83d5/" rel="bookmark">
			Tomcat启动报错 java.lang.ClassNotFoundException: org.apache.jsp.index_jsp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题是因为tomcat在启动过程中jsp和servlet的jar包出了问题。 1. 如果你是用的maven，呢么你就看看有没有Jsp，Servlet，Jstl的包，没有添加上，有的话重新add一下。 2. 如果是使用的lib目录，看看里面有没有jsp和servlet这两个包，有就删除掉就可以了。 3. 重启tomcat就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9e395ce424ac6a20242f837327ae899/" rel="bookmark">
			keras数据自动生成器，继承keras.utils.Sequence，结合fit_generator实现节约内存训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#coding=utf-8 ''' Created on 2018-7-10 ''' import keras import math import os import cv2 import numpy as np from keras.models import Sequential from keras.layers import Dense class DataGenerator(keras.utils.Sequence): def __init__(self, datas, batch_size=1, shuffle=True): self.batch_size = batch_size self.datas = datas self.indexes = np.arange(len(self.datas)) self.shuffle = shuffle def __len__(self): #计算每一个epoch的迭代次数 return math.ceil(len(self.datas) / float(self.batch_size)) def __getitem__(self, index): #生成每个batch数据，这里就根据自己对数据的读取方式进行发挥了 # 生成batch_size个索引 batch_indexs = self.indexes[index*self.batch_size:(index+1)*self.batch_size] # 根据索引获取datas集合中的数据 batch_datas = [self.datas[k] for k in batch_indexs] # 生成数据 X, y = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9e395ce424ac6a20242f837327ae899/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4609ead2abfd41703816b8da49f32bd/" rel="bookmark">
			python 读取文件乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文地址：http://www.zisexinghen.cn/likeshare/322.html
一、问题：
python读取文件时会遇到乱码的问题
二、解决方法：
1、已utf-8格式打开文档
f = open(r'E:\Python\liaotian.txt','r',encoding='utf-8') f.seek(0,0) for each_line in f: print(each_line) f.close() 2、以二进制打开文件，然后对读取的内容进行utf-8编码
f = open(r'E:\百度云同步盘\云同步盘\Python\liaotian.txt','rb') f.seek(0,0) for each_line in f: print(each_line.decode('utf-8')) f.close() 三、查看文档的编码格式
1、安装chardet模块
（1）官方地址： http://pypi.python.org/pypi/chardet
（2）下载文件
（3）将它解压得到其中的文件夹【chardet】将这个文件夹复制到【python安装根目录\Lib\site-packages】下，确保这个位置可以被python引用到。如果不能被引用到请加入环境变量。在安装完chardet模块，我就可以使用它了。
（4）查看文档的格式
import chardet path = r'E:\Python\liaotian.txt' f = open(path,'rb') data = f.read() print(chardet.detect(data)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1e94a5424c862cbdd538efac17b99c7/" rel="bookmark">
			软件设计的优化准则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据软件设计原理提出如下优化准则：
①划分模块式,尽量做到高内聚、低耦合,保持模块相对独立性,并以此原则优化初始的软件结构。
②一个模块的作用范围应在其控制范围之内,且判定所在的模块应与受其影响的模块在层次上尽量靠近。
③软件结构的深度、宽度、扇入、扇出应适当。
④模块的大小要适中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a98d88fc3aa0e52322aaec36977e63fc/" rel="bookmark">
			USB3.1 Gen1与Gen2有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 对于USB3.1大家应该都不陌生，这是当下最流行的USB接口标准，USB接口在经历了USB1.0、USB1.1、USB2.0以及USB3.0之后，迎来了当下最流行的 USB3.1 ，这些标准的新旧交替下，USB接口的传输速率一直在提高，跟随着传输速率提高的还有接口标准的命名复杂程度，就拿USB3.1来说，居然还分为USB3.1 Gen1和USB3.1 Gen2,这就让许多消费者不理解且容易混淆。大家估计都会有这样的疑问：都是USB3.1标准的接口，为什么还要这样分，USB3.1 Gen1与Gen2到底有什么区别？ &gt;&gt; USB3.1和USB3.0有什么区别 &lt;&lt; USB3.1 Gen1与Gen2之间最大的差别就是传输速率的不同 * USB3.1 Gen1的最大传输速率可达5Gb/s的理论带宽* USB3.1 Gen2的最大传输速率可达10Gb/s的理论带宽 其实现在大多数厂商宣称支持USB3.1标准的设备，其实都只是使用了USB3.1 Gen1，也就是之前的你所认识的USB3.0，只不过是换了件马甲而已，毕竟现在真正的USB3.1，也就是Gen2标准USB3.1其兼容性解决方案仍未成熟，并且价格相对来说也处于高位，所以许多厂商宁愿使用这种障眼法来忽悠消费者，也不情愿花时间费精力去研发使用真正的USB3.1 Gen2。 USB接口的未来肯定是朝着USB3.1 Gen2方向发展的，USB3.1 Gen1只不过是Gen2前进道路上的替换者，只是在目前无法更好的在设备上使用Gen2，为了满足消费者对于USB3.1的好奇心而提出来的障眼法，大家在选择USB3.1时请认真的区分好Gen1与Gen2,拒绝被厂商的宣传忽悠。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21544d4c44431bded3ea3f3b3742fdfa/" rel="bookmark">
			谷歌浏览器中塞token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在控制台输入：
document.cookie='token= android#1ok5rla8233gie6977aia7-8aaifdccgmee46' 回车
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5e6212e9556937e55905beaa8f1c52e/" rel="bookmark">
			关于hg的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于集中式和分布式的讨论 “分布式版本控制的问题是太容易创建分支了, 而分支是最容易出问题的”, 这个观点同样是错误的. Subversion 的分支容易出问题, 主要是因为 Subversion 没有提供足够多的信息来保证分支合并的正常工作. 对于 Mercurial, 分支合并是一件很轻松惬意的事, 所以创建分支是很稀松平常的, 而且无毒副作用.
新写好的代码总是充满了 bug. 你需要花些时间调试后才能保证它正常工作. 在此期间, 它可能会影响团队内其他开发人员的工作热情.
这是 Subversion 的传统做法:
在你 checkin 新的代码, 每个开发人员都获取这份新代码. 由于你新写的代码中存在 bug, 你会有如下选择.
你可以 checkin 有 bug 的代码, 然后把所有人搞疯, 或者 在做好充分调试前不要进行 checkin 操作
Subversion 总是给你出这样可恶的难题. 要么库里的代码满是 bug, 要么新写的代码都放在本地.
下面的图展示了 Subversion 是如何被使用的: 对于 Mercurial, 每个开发人员在自己 PC 上有自己的版本库: 只要你愿意, 你可以随时提交提交代码到你的私人版本库, 从版本控制中获益. 每当你的代码到达一定的逻辑点, 你都可以将代码提交.
等到代码比较稳定后, 你想让其他人使用你的新代码, 你可以将你所做的变更 push 到中央版本库. 其他人从中央版本库 pull 代码后, 就可以看到你的代码了.
提交新代码 和 影响他人工作的操作, Mercurial 将这两者分割成两个步骤.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5e6212e9556937e55905beaa8f1c52e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55103702c9578482e36fa27b3b71b323/" rel="bookmark">
			操作系统总结之磁盘管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		磁盘存储器具有容量大、存取速度快、支持随机存取的特点，因此被广泛应用于计算机系统中。对于操作系统来说，管理好磁盘的三大要求和目标是：
（1）合理有效利用磁盘：采用合理的文件存储空间分配算法，尽量减少磁盘碎片，提高硬盘的利用率；
（2）提高磁盘的I/O速度：采用缓存等技术，提供访问速度；
（3）提高磁盘可靠性：采用冗余和纠错检错等技术，保证磁盘的数据不会被破坏。
1. 外存的组织方式 文件是存放在磁盘上的，而磁盘是以盘块为基本的分配单位的，那么一个文件是怎么存放在磁盘上的呢，这就是外存的组织方式，主要有以下三种：
1.连续组织方式 2.链接组织方式 3.索引组织方式 文件的物理结构与外存分配方式有关，在采用连续分配方式时的文件物理结构是顺序式的文件结构，在采用链接分配方式将形成链接式文件结构，而索引分配方式将形成索引式文件结构。
1.1 连续组织方式： 要求为每一个文件分配一组相邻接的(也就是连续的)盘块。就好像分配一个连续的数组给文件使用一样，不过数组元素是磁盘的盘块。它的优点在于（1）顺序访问容易，（2）访问速度快，因为都放在 相邻或者同一个磁道 上，寻道时间很小。缺点为容易产生外部碎片，难以知道文件长度，难以为其分配空间，不利于删除和插入记录。
1.2 链接组织方式： 为每个文件分配不连续的磁盘空间，通过链接指针将一个文件的所有盘块链接在一起，由此形成链式文件结构。这种方式可以克服连续组织方式的缺点，分为隐式链接和显式链接两种形式。
1.2.1 隐式链接： 其中隐式链接的目录项需要包含文件的第一个盘块和最后一个盘块号，每一个盘块都有一个指向下一块盘块的指针（最后一个盘块除外）。但是这样只能顺序查找，速度慢。 此外，其可靠性较差，任何一个指针出现问题，都会导致整个链的断开。可以将几个盘块组成一个簇，然后以簇为单位进行分配，会减少查找指定块的时间，但是会增加内部碎片。
1.2.2 显式链接： **用于链接文件各物理块的指针显式地存放在内存的一张链接表中，该表在整个磁盘中仅设置一张。而文件第一个盘块号作为文件的物理地址存放在FCB中。**而那个链接表则叫做文件分配表（FAT:file allocation table）。
那么查找的时候，将会把该表拷贝至内存中，大大减少访问磁盘速度，提高了检索的速度。 说明：表的序号从0开始，直至N-1，N为盘块总数，在每个表项中存放链接指针，即下一个盘块号，在该表中，凡是属于某一文件的第一个盘块号，或者说是每一条链的链首指针所对应的盘块号，均作为文件地址被填入相应的文件的FCB(File Control Block)的物理地址字段中，由于查找记录的过程是在内存中进行的，因而提高了检索速度，减少了访问磁盘的次数，由于分配给文件的所有盘块号都在该表中，故把该表称为文件分配表FAT（File Allocation Table）。
缺点：不能支持高效的直接存储（要对一个较大的文件进行直接存取，须首先在FAT中顺序地查找很多盘块号）；FAT需要占用较大的内存空间（由于一个文件所占用的盘块的盘块号是随机地分布在FAT中的，因而只有将整个FAT调入内存，才能保证FAT中找到一个文件的所有盘块号，当磁盘容量较大时，FAT占用的容量更大）
1.2 索引组织方式： 事实上，在打开某个文件时，只需要把该文件占用的盘块号的编号调入内存即可，完全没有必要把整个FAT调入内存，为此，应该将每个文件所对应的盘块号集中地放在一起，索引分配方式就是基于这种想法所形成的一种分配方式。其为每个文件分配一个索引块（表），再把分配给该文件的所有盘块号都记录在该索引块中，因而该索引块就是一个含有许多磁盘块号的数组。在建立一个文件时，只需要在为之建立的目录项中填上指向该索引块的指针（单级索引）。
说明：**索引方式支持直接访问，可在索引块中找到第i个盘块，索引方式也不会产生外部碎片，**当文件较大时，索引分配方式要优于链接分配方式。其主要问题在于：可能需要花费较多的外存空间，每当建立一个文件时，便须为之分配一个索引块，将分配给该文件的所有盘块号记录其中。对于小文件而言，索引块的利用率非常低。
当OS为一个大文件分配磁盘空间时，如果所分配的盘块的盘块号已经装满一个索引块时，OS便为该文件分配另一个索引块，用于将以后继续为之分配的盘块号记录于其中，以此类推，然后再通过链指针将各索引块按序链接起来，当文件太大时，索引块太多，效率是低效的。此时，应该为这些索引块再建立一级索引，称为第一级索引，还可再建立索引，称为第二级索引等等。称为多级索引分配。
说明：在二级索引分配方式下，若每个盘块的大小为1KB，每个盘块号占4个字节，则在一个索引块可以存放256个盘块号，这样，在两级索引时，最多可以包括存放文件的盘块号总数为64K(256 * 256)个盘块号，所允许文件最大文件大小为64MB，若盘块号为4KB，则一级索引的最大文件大小为4MB，二级索引的最大文件大小为4GB。
索引块 == 特殊的盘块，所以还是1KB == 1024B == 4*256 B 1.2.1 伟大的 Linux 系统所采用的索引组织方式之混合索引分配方式 思想： ④ 将多种索引分配方式相结合而形成的一种分配方式：
小文件： （1）直接地址（在FCB中设置10个直接地址项，每项中所存放的是该文件数据所在盘块的盘块号，假如每个盘块大小为4KB，当文件不大于40KB时，可以直接从FCB中读出该文件的全部盘号）
中等文件： （2）一次间接地址（**为文件建立一个索引表，然后将该表首地址放入FCB中，需要时找到索引表的首地址，从而通过索引表找到所有的盘块号 。**其实质就是一级索引分配方式）
大文件或者特大文件： （3）多次间接地址（当文件大于4MB + 40KB时，系统采用二次间址分配方式，其实质是两级索引分配方式，采用二次间址的最大文件大小为4GB，同理，可采用三次间接地址，允许文件最大大小为4TB）。
实现： 每个文件的索引结点含13个地址项 i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55103702c9578482e36fa27b3b71b323/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d05176013dd941b9d87c5da28165dc9/" rel="bookmark">
			求解回归模型的最小二乘法(代数方法和数值方法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于回归模型，最小二乘法是通过最小化残差平方和来估计回归系数的方法。残差平方和就是预测值跟样本之间的差的平方和，残差平方和除以样本量n就是均方误差，即通常所说的损失函数。回归模型的损失函数不宜直接用残差平方和而要用均方误差是因为残差平方和是所有样本点残差平方的总和，会随着样本量增大而增加，不能体现样本点残差的平均水平。以一元回归模型为例，损失函数为
\[loss=\frac{1}{2n}\sum_{i=1}^{n}\left ( y_{i} -y\right )^{2}=\frac{1}{2n}\sum_{i=1}^{n}\left ( y_{i} -\beta _{1}x-\beta _{0}\right )^{2}\]
上式中系数1/2是为了将来求导时方便约去。为了求未知参数β1和β0的取值使得这个损失函数达到最小值，通常有两种解法：代数方法和数值方法。
(1)代数方法
代数方法就是假定损失函数在其驻点上取得最小值，然后令偏导数为0解线性方程组求出β1和β0的解析解，也称为直接法。这个思想跟用最大似然法进行参数估计是一样的。对于凸函数而言，可以认为其驻点就是极值点。对于多元回归分析，通常要求样本矩阵X列满秩而且非病态，才能采用代数方法求解。上式中损失函数loss对β1和β0求偏导，约去系数后可得
\[\left\{\begin{matrix} \sum_{i=1}^{n}\left ( y_{i}-\hat{\beta _{0}}-\hat{\beta _{1}}x_{i} \right )=0\\ \sum_{i=1}^{n}x_{i} \left (y_{i}-\hat{\beta _{0}}-\hat{\beta _{1}}x_{i} \right )=0 \end{matrix}\right.\]
整理之后得到
\[\left\{\begin{matrix} n\hat{\beta _{0}}+\hat{\beta _{1}}\sum_{i=1}^{n}x_{i}=\sum_{i=1}^{n}y_{i}\\ \hat{\beta _{0}}\sum_{i=1}^{n}x_{i}+\hat{\beta _{1}}\sum_{i=1}^{n}x_{i}^{2}=\sum_{i=1}^{n}x_{i}y_{i} \end{matrix}\right.\]
这是一个关于β1和β0的二元一次线性方程组，称为规范方程，用常规的解方程方法即可求出
\[\left\{\begin{matrix} \hat{\beta _{1}}=\frac{\sum_{i=1}^{n}\left ( x_{i}-\bar{x} \right )\left ( y_{i}-\bar{y} \right )}{\sum_{i=1}^{n}\left ( x_{i}-\bar{x} \right )^{2}}\\ \hat{\beta _{0}}=\bar{y}-\hat{\beta _{1}}\bar{x} \end{matrix}\right.\]
其中
\[\bar{x}=\frac{1}{n}\sum_{i=1}^{n}x_{i}\]\[\bar{y}=\frac{1}{n}\sum_{i=1}^{n}y_{i}\]
表示样本在x和y坐标上的平均值。从上面的结果也可以看出样本的均值一定落在拟合直线上。
(2)数值方法
数值方法就是采用数值分析的方法设定初始值和步长，按照一定规则逐步迭代求解，通常所说的梯度下降和牛顿法就是数值方法，其本质是状态空间搜索问题。
梯度下降法的迭代公式为：
\[x^{\left (k+1 \right )}=x^{\left (k \right )}-\alpha \cdot loss'\left ( x^{\left ( k \right )} \right )\]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d05176013dd941b9d87c5da28165dc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24598a9452ee82fbec42fe430e7d41d2/" rel="bookmark">
			单例模式看了就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、饿汉式单例
它是在类加载的时候就立即初始化，并且创建单例对象
优点：没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好
缺点：类加载的时候就初始化，不管你用还是不用，我都占着空间，浪费了内存，有可能占着茅坑不拉屎
绝对线程安全，在线程还没出现以前就是实例化了，不可能存在访问安全问题
注意代码中的：readResolve方法及注释内容
public class HungrySingleton { private static final HungrySingleton hungrySingleton = new HungrySingleton(); private HungrySingleton() {} //提供全局访问点 public static HungrySingleton getInstance() { return hungrySingleton; } //防止通过序列化和反序列化的方式破坏单例 // 重写readResolve方法，只不过是覆盖了反序列化出来的对象，其实还是创建了两次，发生在JVM层面，相对来说比较安全 private Object readResolve(){ return hungrySingleton; } } 一上来就把单例对象创建出来了，要用的时候直接返回即可，这种可以说是单例模式中最简单的一种实现方式。但是问题也比较明显。单例在还没有使用到的时候，初始化就已经完成了。也就是说，如果程序从头到尾都没用使用这个单例的话，单例的对象还是会创建。这就造成了不必要的资源浪费。所以不推荐这种实现方式。
1.1 饿汉式静态块单例
public class HungryStaticSingleton { private static final HungryStaticSingleton hungrySingleton; static { hungrySingleton = new HungryStaticSingleton(); } private HungryStaticSingleton(){} public static HungryStaticSingleton getInstance(){ return hungrySingleton; } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24598a9452ee82fbec42fe430e7d41d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9081e2ce1a5614b758e0d4b4cdd36fe7/" rel="bookmark">
			Java基础--String（按照指定编码截取文字）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 字符串按照字节来截取。例如：abc中国 * 存在的问题： * 1.字符是一个字节,容易截取.但是一个文字是两个字节,应该按照什么方式截取呢? * 2.可以按照文件的编码方式来截取,GBK的编码方式是中文全部是负数(奇数位也有可能是正数). * 3.根据编码表来判断即可。 */ public class StringByteSplitDemo { public static void main(String[] args) throws IOException { String str = "abc中国国"; for(int i = 0;i&lt;str.length()+1;i++){ String s = splitMethod(str,i+1); System.out.println("按照长度为"+(i+1)+"截取的字符是："+s); } } private static String splitMethod(String str, int leng) throws IOException { //将字符串用指定的编码表，来进行编码 byte[] be = str.getBytes("GBK"); //记录负数的个数 int count = 0; //根据字节编码来判断是否是完整的字符,按照指定的位置来截取 for(int i=leng-1;i&gt;=0;i--){ if(be[i]&lt;0){ count++; }else{//都是大于0 break; } } if(count%2==0){ //按照指定编码重新解码 return new String(be,0,leng,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9081e2ce1a5614b758e0d4b4cdd36fe7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef3ae36fb244de74f3e00c769fe6389/" rel="bookmark">
			maven初使用：一些设置总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 创建maven项目时设置的artifactId和groupId代表的是什么 groupId代表的是项目组织唯一的标志符，一般写两层就可以了，第一层为com/org/cn之类的，com表示商用组织，org表示非盈利组织之类的；第二层为公司名称，如apache之类的 artifactId代表等的是项目的唯一标识符，一般写项目名称就行了 如何修改maven的本地仓库路径 修改maven的配置文件setting.xml: &lt;localRepository&gt;H:\maven-repo&lt;/localRepository&gt; 如何修改maven的镜像为国内的 修改maven的配置文件： &lt;mirrors&gt; &lt;!--修改为阿里云的maven镜像--&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/902efa69f99d2d86e2a3ce50b675e19f/" rel="bookmark">
			hibernate报错:org.hibernate.boot.MappingNotFoundException: Mapping (RESOURCE) not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		org.hibernate.boot.MappingNotFoundException: Mapping (RESOURCE) not found : entity.Customer.hbm.xml : origin(entity.Customer.hbm.xml) at org.hibernate.boot.spi.XmlMappingBinderAccess.bind(XmlMappingBinderAccess.java:56) at org.hibernate.boot.MetadataSources.addResource(MetadataSources.java:275) at org.hibernate.boot.cfgxml.spi.MappingReference.apply(MappingReference.java:70) at org.hibernate.boot.internal.MetadataBuilderImpl.build(MetadataBuilderImpl.java:469) at org.hibernate.boot.internal.MetadataBuilderImpl.build(MetadataBuilderImpl.java:85) at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:689) at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:724) at hibernate.Dome1.test1(Dome1.java:38) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229) at org.junit.runners.ParentRunner.run(ParentRunner.java:309) at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/902efa69f99d2d86e2a3ce50b675e19f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a8e19a1f34f49bbc17c51e64ead47b1/" rel="bookmark">
			第018篇：ArcGIS中矢量之间根据空间位置关系添加属性字段的方法（以建筑和地块为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已有文件：建筑.shp和地块.shp，其位置关系是每一处建筑都在某个地块范围内，本次要做的是给建筑.shp里的要素添加其所在地块的地块名称。建筑.shp的属性表以及与地块的空间位置关系如下图所示。
在左侧图层管理器中，建筑处右击，选择Join，进入Join的设置面板，如图：
这时候查看新生成的建筑_新.shp属性表，就会发现建筑.shp连上了地块.shp的所有字段：
如果冗余字段较多的话，可以用工具箱的字段管理工具批量删除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9da1c11ccf124c8638d3b449af8f0362/" rel="bookmark">
			关于论文投稿心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.中国图象图形学报
特点：看重学校，基金的，初审就没过，初审也很快，感觉此期刊的论文都弄得很玄乎
2.计算机科学
特点：不知道为什么，被录了增刊，初审也很快，审稿时间很快，一个月的样子，还特地发了邮件问能否录用正刊，虽然不甘心，不过编辑真的很好，邮件回复很快。
3.计算机应用
期刊审稿比较快，两个月左右会给退修建议，个人认为《计算机应用》在同类型期刊中算是相对正规的，退修意见非常值得重视，不论能不能正刊录用，100块的审稿费换的修改建议也比不要审稿费的某些期刊强太多
4.计算机应用研究
数据库收录: CSCD,RCCSE,EBSCOhost,UPD,JST,AJ，VINITI
3和4一起讲，自己网络了解了一下，计算机应用研究比计算机应用好中，对审稿人的审稿周期，计算机应用研究的审稿周期要比计算机应用短10天，计算机应用研究喜欢把稿件录取在增刊上，计算机应用研究不收审稿费而且速度挺快，计算机应用 比 计算机应用研究 要好。
5.计算机应用与软件
这是一个神奇的期刊，为啥这么说，因为它很水，但仍旧保持着CSCD，核心期刊的地位，不过北大核心已经把它踢出去了的样子，网上说随便写写都能发？？？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8559244aa44ae0c1be73cd48e8c7827d/" rel="bookmark">
			MOS管基本认识（快速入门）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 三个极的判定 G极(gate)—栅极，不用说比较好认 S极(source)—源极，不论是P沟道还是N沟道，两根线相交的就是 D极(drain)—漏极，不论是P沟道还是N沟道，是单独引线的那边
2. N沟道与P沟道判别 箭头指向G极的是N沟道 箭头背向G极的是P沟道
3. 寄生二极管方向判定 不论N沟道还是P沟道MOS管，中间衬底箭头方向和寄生二极管的箭头方向总是一致的： 要么都由S指向D，要么都有D指向S
4. MOS开关实现的功能 1&gt;信号切换 2&gt;电压通断
5. MOS管用作开关时在电路中的连接方法 关键点: 1&gt;确定那一极连接输入端，那一极连接输出端 2&gt;控制极电平为？V 时MOS管导通 3&gt;控制极电平为？V 时MOS管截止 NMOS：D极接输入，S极接输出 PMOS：S极接输入，D极接输出
反证法加强理解 NMOS假如：S接输入，D接输出 由于寄生二极管直接导通，因此S极电压可以无条件到D极，MOS管就失去了开关的作用 PMOS假如：D接输入，S接输出 同样失去了开关的作用
6. MOS管的开关条件 N沟道—导通时 Ug&gt; Us,Ugs&gt; Ugs(th)时导通 P沟道—导通时 Ug&lt; Us,Ugs&lt; Ugs(th)时导通 总之，导通条件：|Ugs|&gt;|Ugs(th)|
7. 相关概念 BJT Bipolar Junction Transistor 双极性晶体管，BJT是电流控制器件； FET Field Effect Transistor 场效应晶体管，FET是电压控制器件. 按结构场效应管分为：结型场效应（简称JFET）、绝缘栅场效应（简称MOSFET）两大类 按沟道材料：结型和绝缘栅型各分N沟道和P沟道两种. 按导电方式：耗尽型与增强型，结型场效应管均为耗尽型，绝缘栅型场效应管既有耗尽型的，也有增强型的。 总的来说场效应晶体管可分为结场效应晶体管和MOS场效应晶体管，而MOS场效应晶体管又分为N沟耗尽型和增强型；P沟耗尽型和增强型四大类。
8. MOS管重要参数 ①封装 ②类型（NMOS、PMOS） ③耐压Vds（器件在断开状态下漏极和源极所能承受的最大的电压） ④饱和电流Id ⑤导通阻抗Rds ⑥栅极阈值电压Vgs(th)
9. 从MOS管实物识别管脚 无论是NMOS还是PMOS 按上图方向摆正，中间的一脚为D，左边为G，右边为S。 或者这么记：单独的一脚为D，逆时针转DGS。 这里顺便提一下三极管的管脚识别：同样按照上图方向摆正，中间一脚为C，左边为B，右边为E。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8559244aa44ae0c1be73cd48e8c7827d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03bfa59ca6b608f4c7a5045f0147b435/" rel="bookmark">
			Ext6.2  sencha app build 几种报错的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.页面调试debugger没有删除
C2009: YUI Parse Error (identifier is a reserved word =&gt; debugger;) -- unknown-file:308408:17
2.app.js里没有添加requires : ['ExtApp.*','Ext.chart.*'] Unrecognized class name / alias widget.twHome (twProject, …)
Uncaught Error: [Ext.create] Unrecognized class name / alias: widget.horizontal3d 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96676eff5923695f211efa7aab3b1de8/" rel="bookmark">
			Linux下（乌班图）安装Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置文件参考资料
Redis的安装 第一步：更新软件源列表 打开Linux终端 （管他三七二十一，我们先对软件源列表更新下，防止安装软件的时候出现无法定位软件包的问题）
执行更新软件源列表命令：sudo apt-get udpate 第二步：安装Redis 执行安装Redis命令： sudo apt-get install redis-server 第三步：启动Redis服务 执行启动Redis服务命令： sudo /etc/init.d/redis-server start 第四步：查看Redis服务是否启动成功 执行查看是否启动Redis服务的命令： redis-cli 如果启动成功：会是显示如下信息：↓ 127.0.0.1:6379&gt;set myname "zhangshang" （这里我们用set命令写一条 键为myname，值为zhangshang的数据） OK （如果数据写入成功这里则会显示OK） 127.0.0.1:6379&gt;get myname （然后我们用get命令来获取这条 键为myname的数据） "zhangshang" （在这里得到zhangshang） 第五步：修改redis的配置文件 sudo dir /etc/redis (首先查询redis文件夹下所有的文件，去这个文件夹去找一个叫redis.conf的配置文件) 如果有这个文件，我们用vi修改这个配置文件
sudo vi /etc/redis/redis.conf （用vi打开这个redis.conf的配置文件） 将redis.conf配置文件中的bind 127.0.0.1注释掉（改成#bind 127.0.0.1）保存
第六步：重启redis服务 执行重启Redis命令：sudo /etc/init.d/redis-server restart 第七步：开启ufw防火墙配置工具，打开防火墙 执行开启防火墙命令： sudo ufw enable 添加规则： 允许指定的IP访问这个Redis服务（redis默认端口为6379）
sudo ufw allow from 192.168.31.1 to any port 6379 （即：允许192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96676eff5923695f211efa7aab3b1de8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d757f2751ab0a3eb8f056c006a686cc/" rel="bookmark">
			冒泡排序、选择排序和插入排序的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这三种排序的时间级别：
冒泡排序：比较 （N-1)+(N-2)+...+2+1 = N*(N-1)/2=N2/2
交换 0——N2/2 = N2/4
总时间 3/4*N2
选择排序：比较 （N-1)+(N-2)+...+2+1 = N*(N-1)/2=N2/2
交换 0——3*（N-1）=3*（N-1）/2=3/2*N
总时间 N2/2+3/2*N
插入排序：第一轮最多比较一次，第二轮最多比较俩次，最后一轮比较N-1次，所以最多比较N*(N-1)/2。
复制的次数和比较的次数大致相等，但是复制消耗的时间比交换要小.
比较 0——N*(N-1)/2=N*(N-1)/4=N2/4
复制 0——N*(N-1)/2=N*(N-1)/4=N2/4
总时间 N2//2
总结：插入排序算法比冒泡快一倍，比选择排序略快一点，但这些算法都是O(N2)的时间级别。
冒泡算法思想：每次相邻元素进行比较，如果发现较小的元素在后面，就交换两个相邻的元素。
数组实例：int array[] = { 23, 63, 19, 8, 36, 48, 42 };
冒泡排序：
// 冒泡排序法
public void bubbleSort() { // 定义临时变量 int temp = 0; // 外层控制循环的次数 for (int i = 0; i &lt; array.length - 1; i++) { // 内层是比较的次数 for (int j = array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d757f2751ab0a3eb8f056c006a686cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/967a075d92e8d29e86df37fa829f5773/" rel="bookmark">
			深度学习总结（一）各种优化算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博文： 码农王小呆：https://blog.csdn.net/manong_wxd/article/details/78735439 深度学习最全优化方法总结： https://blog.csdn.net/u012759136/article/details/52302426 超级详细每个算法的讲解，可参考： https://blog.csdn.net/tsyccnh/article/details/76673073
一.优化算法介绍 1.批量梯度下降（Batch gradient descent，BGD） θ=θ−η⋅∇θJ(θ) 每迭代一步，都要用到训练集的所有数据，每次计算出来的梯度求平均 η代表学习率LR
2.随机梯度下降（Stochastic Gradient Descent，SGD） θ=θ−η⋅∇θJ(θ;x(i);y(i)) 通过每个样本来迭代更新一次，以损失很小的一部分精确度和增加一定数量的迭代次数为代价，换取了总体的优化效率的提升。增加的迭代次数远远小于样本的数量。
缺点：
对于参数比较敏感，需要注意参数的初始化 容易陷入局部极小值 当数据较多时，训练时间长 每迭代一步，都要用到训练集所有的数据。
3. 小批量梯度下降（Mini Batch Gradient Descent，MBGD） θ=θ−η⋅∇θJ(θ;x(i:i+n);y(i:i+n)) 为了避免SGD和标准梯度下降中存在的问题，对每个批次中的n个训练样本，这种方法只执行一次更新。【每次更新全部梯度的平均值】
4.指数加权平均的概念 从这里我们就可已看出指数加权平均的名称由来，第100个数据其实是前99个数据加权和，而前面每一个数的权重呈现指数衰减，即越靠前的数据对当前结果的影响较小 缺点：存在开始数据的过低问题，可以通过偏差修正，但是在深度学习的优化算法中一般会忽略这个问题 当t不断增大时，分母逐渐接近1，影响就会逐渐减小了
优点：【相较于滑动窗口平均】 1.占用内存小，每次覆盖即可 2.运算简单
5.Momentum（动量梯度下降法） momentum是模拟物理里动量的概念，积累之前的动量来替代真正的梯度。公式如下： 然而网上更多的是另外一种版本，即去掉（1-β） 相当于上一版本上本次梯度的影响权值*1/(1-β) 两者效果相当，只不过会影响一些最优学习率的选取 优点
下降初期时，使用上一次参数更新，下降方向一致，乘上较大的μ能够进行很好的加速下降中后期时，在局部最小值来回震荡的时候，gradient→0，β得更新幅度增大，跳出陷阱在梯度改变方向的时候，μ能够减少更新 即在正确梯度方向上加速，并且抑制波动方向张的波动大小，在后期本次计算出来的梯度会很小，以至于无法跳出局部极值，Momentum方法也可以帮助跳出局部极值 参数设置 β的常用值为0.9，即可以一定意义上理解为平均了前10/9次的梯度。 至于LR学习率的设置，后面所有方法一起总结吧
6.Nesterov accelerated gradient (NAG) 优点： 这种基于预测的更新方法，使我们避免过快地前进，并提高了算法地响应能力，大大改进了 RNN 在一些任务上的表现【为什么对RNN好呢，不懂啊】 没有对比就没有伤害，NAG方法收敛速度明显加快。波动也小了很多。实际上NAG方法用到了二阶信息，所以才会有这么好的结果。先按照原来的梯度走一步的时候已经求了一次梯度，后面再修正的时候又求了一次梯度，所以是二阶信息。 参数设置： 同Momentum
其实，momentum项和nesterov项都是为了使梯度更新更加灵活，对不同情况有针对性。但是，人工设置一些学习率总还是有些生硬，接下来介绍几种自适应学习率的方法
7.Adagrad 前面的一系列优化算法有一个共同的特点，就是对于每一个参数都用相同的学习率进行更新。但是在实际应用中各个参数的重要性肯定是不一样的，所以我们对于不同的参数要动态的采取不同的学习率，让目标函数更快的收敛。 adagrad方法是将每一个参数的每一次迭代的梯度取平方累加再开方，用基础学习率除以这个数，来做学习率的动态更新。【这样每一个参数的学习率就与他们的梯度有关系了，那么每一个参数的学习率就不一样了！也就是所谓的自适应学习率】 优点：
前期Gt较小的时候， regularizer较大，能够放大梯度后期Gt较大的时候，regularizer较小，能够约束梯度适合处理稀疏梯度:相当于为每一维参数设定了不同的学习率：压制常常变化的参数，突出稀缺的更新。能够更有效地利用少量有意义样本 参数设置： 只需要设置初始学习率，后面学习率会自我调整，越来越小
缺点： Adagrad的一大优势时可以避免手动调节学习率，比如设置初始的缺省学习率为0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/967a075d92e8d29e86df37fa829f5773/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7b34d16ab2d6ab597df1bf4352540a9/" rel="bookmark">
			如何判断一个变量是有符号数还是无符号数？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）采用取反操作
若该值与其求反后的值都大于0，则该数为无符号数，反之则是有符号数。
解析：因为数据在计算机中都是以二进制的0或1存储的，证书以0开头，负数以1开头，求反操作会把所有的0改为1，所有的1改成0，如果是有符号数，那么取反后，开头的0会被改成1，开头的1会被改成0，即正负有变化，但如果是无符号数则不会受此影响。
（2）利用无符号数和有符号数详见的结果为无符号数
（3）通过改变符号位判断，把A进行一个位运算，将最高位置置1，判断是否大于0
如：
#include &lt;stdio.h&gt;
int main() {
unsigned A = 10;
A = A | (1 &lt;&lt; 31);
if (A &gt;0)
printf("无符号数\n");
else
printf("有符号数、n");
return 0;
}
输出为：无符号数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/405abd1194012a29fe0db2f42b1a247e/" rel="bookmark">
			iOS 根据音乐来变动闪光灯和闪屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间一朋友需要实现该功能，其实实现起来不难，下面是实现效果 提示：模拟器看不到效果，需要真机才能看到效果 [简书查看demo代码下载地址] 闪光灯的开启与关闭 //开启闪光灯 - (void)openFlash{ AVSession = [[AVCaptureSession alloc]init]; device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; [device lockForConfiguration:nil];//此处以一定要调用这个方法不然程序运行到这里会崩溃 [device setTorchMode:AVCaptureTorchModeOn]; [device setFlashMode:AVCaptureFlashModeOn]; [device unlockForConfiguration]; [AVSession startRunning]; } //关闭闪光灯 - (void)closeFlash{ AVSession = [[AVCaptureSession alloc]init]; device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; [device lockForConfiguration:nil]; [device setTorchMode:AVCaptureTorchModeOff]; [device setFlashMode:AVCaptureFlashModeOff]; [device unlockForConfiguration]; [AVSession stopRunning]; AVSession = nil; //置空 device = nil; //置空 } 屏幕亮度改变 - (void)changeScreenBright:(float)value { if (self.screnSwitch.on) { [[UIScreen mainScreen] setBrightness:value];//修改屏幕亮度 } } 音乐频率计算 _vodioTimer = [NSTimer scheduledTimerWithTimeInterval:0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/405abd1194012a29fe0db2f42b1a247e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccc6a871024487f4296628bc69eb053e/" rel="bookmark">
			获取当前日期的后一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 package com.date.demo; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; /** * 生成当前时间后一天时间零点 例如:当前时间为2018/7/3 15:24:30 生成时间为2018/7/4 00:00:00 */ public class DateDemo { public static void main(String[] args) { Calendar calendar = Calendar.getInstance(); calendar.setTime(new Date()); calendar.set(Calendar.HOUR_OF_DAY, 0); calendar.set(Calendar.MINUTE, 0); calendar.set(Calendar.SECOND, 0); calendar.set(Calendar.MILLISECOND, 0); calendar.add(Calendar.DAY_OF_MONTH, 1); Date date = new Date(); date = calendar.getTime(); System.out.println(date); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String str = sdf.format(date); System.out.println(str); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcc8a16378eb671d7164b289179800e9/" rel="bookmark">
			java post发送数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; import org.apache.commons.httpclient.HttpClient; import org.apache.commons.httpclient.methods.PostMethod; import org.apache.http.HttpEntity; import org.apache.http.NameValuePair; import org.apache.http.client.config.RequestConfig; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpPost; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClientBuilder; import org.apache.http.message.BasicNameValuePair; import org.apache.http.util.EntityUtils; import org.springframework.util.StringUtils;
private static final CloseableHttpClient httpClient; public static final String CHARSET = "UTF-8"; static { RequestConfig config = RequestConfig.custom().setConnectTimeout(60000).setSocketTimeout(15000).build(); httpClient = HttpClientBuilder.create().setDefaultRequestConfig(config).build(); } /** * HTTP Post 获取内容 * * [@param](https://my.oschina.net/u/2303379) url请求的url地址 * ?之前的地址 * [@param](https://my.oschina.net/u/2303379) params请求的参数 * [@param](https://my.oschina.net/u/2303379) charset编码格式 * [@return](https://my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcc8a16378eb671d7164b289179800e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/940c9cf7b41afab55b0f4348352c5e62/" rel="bookmark">
			查看MySQL的用户信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我之前的博客中提到，MySQL会在创建的时候，自动生成几个database, 即infomation_schema、mysql、performance_schema、sys :
我们创建的MySQL用户的信息，其实都保存在名称为“mysql”的database中，可以这样来查看：
（1）连接数据库服务器：
mysql -u root -p （2）显示所有的database:
show databases; （3）选择名为“mysql”的database:
use mysql; （4）显示“mysql” database的所有表：
show tables; 可以看到“mysql”database中有个user表：
（5）显示user表结构：
desc user; user表结构如下图所示：
（6）查看当前所有MySQL用户的username、host、密码（注意MySQL从某个版本开始，密码字段不是password，而是authentication_string）：
select User,Host,authentication_string from user; 可以看到：
这就是基本的MySQL用户信息，当然还有很多用户授权、锁定、过期等信息，这里就不作详述了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bfee3a13295e4b1d56454f8940b483d/" rel="bookmark">
			Linux （乌班图）防火墙配置 ufw-iptables
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu的防火墙配置-ufw-iptables 防火墙的概念 防火墙是计算机中一款应用软件或基于硬件的网络安全系统。它根据应用配置的规则，分析数据包，然后决定是否允许此数据包通过，来控制整个系统的网络数据进出访问权限。 UFW简介 自打2.4版本以后的Linux内核中， 提供了一个非常优秀的防火墙工具。这个工具可以对出入服务的网络数据进行分割、过滤、转发等等细微的控制，进而实现诸如防火墙、NAT等功能。
一般来说， 我们会使用名气比较的大iptables等程序对这个防火墙的规则进行管理。iptables可以灵活的定义防火墙规则， 功能非常强大。但是由此产生的副作用便是配置过于复杂。
一向以简单易用著称Ubuntu在它的发行版中，附带了一个相对iptables简单很多的防火墙配置工具：UFW。
UFW (简单的防火墙) 是广泛使用的 iptables 防火墙 的前端应用 , 是一个主机端的iptables类防火墙配置工具，这是非常适合于基于主机的防火墙。UFW 即提供了一套管理网络过滤器的框架，又提供了控制防火墙的命令行界面接口。它给那些不熟悉防火墙概念的 Linux 新用户提供了友好、易使用的用户界面。
同时，另一方面，它也提供了命令行界面，为系统管理员准备了一套复杂的命令，用来设置复杂的防火墙规则。
UFW 对像 Debian、Ubuntu 和 Linux Mint 这些发布版本来说也是上上之选。
注明：ufw并不是一个防火墙，尽管它叫做Ubuntu firewall，但它本身并没有防火墙的功能，它只是一个管理netfilter防火墙的工具，其核心还是netfilter的iptables
Ubuntu下UFW的安装与防火墙的配置 防火墙的开启与关闭 参考资料1
参考资料2
打开Linux终端 （管他三七二十一，我们先对软件源列表更新下，防止安装软件的时候出现无法定位软件包的问题）
执行更新软件源列表命令：sudo apt-get udpate 安装ufw
执行安装ufw命令： sudo apt-get install ufw （注：Ubuntu下默认已经安装了ufw了） 开启防火墙
注意：在开启防火墙之前，你需要确保你允许了 SSH 连接，否则当你关闭远程连接后，你就无法再连上了。博主自己就曾用这招坑了自己！
执行开启防火墙命令： sudo ufw enable 关闭防火墙
执行关闭防火墙命令： sudo ufw disable 重启防火墙（编辑或新增规则后需要重启防火墙才能生效）
执行重启防火墙命令： sudo ufw reload 查看防火墙状态
执行查看防火墙状态命令： sudo ufw status 例如：我开放了192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bfee3a13295e4b1d56454f8940b483d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f490d0c175e7655cc97beae60eca6961/" rel="bookmark">
			GCC编译源码出错error: Building GCC requires GMP 4.2&#43;, MPFR 2.3.1&#43; and MPC 0.8.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用gem5时需要更换内核，但是编译内核需要低版本的GCC。原系统gcc版本是5.6.0，需要更换成gcc4.4.0.
在编译安装gcc过程中出错，error: Building GCC requires GMP 4.2+, MPFR 2.3.1+ and MPC 0.8.0
，出错原因是需要这些库的支持，所以解决方法就是寻找相应的源码库安装即可，下面是解决方法。
首先下载GMP、MPC、MPFR源码库： 下载GMP 直接使用命令： wget ftp://ftp.gnu.org/gnu/gmp/gmp-5.0.1.tar.bz2；即可下载到本地。下载MPC 打开http://www.multiprecision.org/mpc，下载mpc-1.1.0.tar.gz
下载MPFR http://ftp.gnu.org/gnu/mpfr/； 下载mpfr-3.1.4.tar.xz
安装各个库。
注意安装顺序，因为依赖问题，所以首先安装GMP，然后是MPFR,然后是MPC 下面是每一个库的安装过程： 1、安装GMP
1. 创建安装目录： mkdir /opt/gmp5.0.1 2. 解压缩源码包 tar -jxvf gmp-5.0.1.tar.bz2 3. 进入源码文件夹，执行配置 cd gmp-5.0.1 ./configure --prefix=/opt/gmp-5.0.1 --build=x86_64-linux sudo make &amp;&amp;　make install 在安装GMP过程会出现一些小错误，不影响最后的编译。
2、安装MPFR
mkdir /opt/mpfr-3.1.4 tar -zxvf mpfr-3.1.4.tar.xz cd mpfr-3.1.4 ./configure --prefix=/opt/mpfr-3.1.4 --with-gmp=/opt/gmp-5.0.1 --build=x86_64-linux sudo make &amp;&amp; make install 3、安装MPC
mkdir /opt/mpc-1.1.0 tar -zxvf mpc-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f490d0c175e7655cc97beae60eca6961/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/433/">«</a>
	<span class="pagination__item pagination__item--current">434/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/435/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>