<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/123ec7fb59b1b5ffeb2ecb9fba9389c2/" rel="bookmark">
			数据库报ORA-12519；java.sql.SQLException: Listener refused the connection with the following error解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，用户反映在使用管理后台的时候，间歇性报500错误，截图看了下报错，如图：
java.sql.SQLException: Listener refused the connection with the following error: ORA-12519, TNS:no appropriate service handler found 于是乎，开始找12519错误，网上查了下，发现是数据库上当前的连接数目已经超过了它能够处理的最大值；oracle 11g和10g默认的连接数好像比较小，这就是为什么间歇性报500的原因，着手进行问题处理；
首先，登录服务器，登录数据库，查看当前链接数；
SQL&gt; select count (*) from V$process; COUNT(*) ---------- 26 第二步，查看数据库允许的最大连接数
SQL&gt; select value from v$parameter where name = 'processes' 我这里查出来，显示是2，很奇怪...先不管，修改了在说
之后，修改最大连接数；
SQL&gt; alter system set processes = 200 scope = spfile; 这里将最大连接数修改为200，也可以根据实际情况，进行修改； 之后，重启数据库；
停止数据库：
SQL&gt; shutdown immediate; 启动数据库：
SQL&gt; startup; ================================================
修改后查看的最大链接截图：修改后最大链接已经是200了；
操作数据库的时候，要将java进程杀掉，等数据库启动起来，在启动tomcat，不然日志就会报一大堆oracle链接错误~~~
目前先这样修改，随后在观察观察，看看有没有什么问题！！
== 操作系统：red hat 6.2 x64 数据库：oracle 11g ==
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c08909e3b892a466f40fdac1b2847ed6/" rel="bookmark">
			MySQL跳过密码登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种 1.1停止mysql服务 1.2以管理员身份运行cmd，执行以下命令
cd C:\Program Files\mysql-5.7.17-winx64\bin mysqld --skip-grant-tables 1.3在不关闭cmd情况下重新以管理员身份运行一个cmd，执行如下命令
cd C:\Program Files\mysql-5.7.17-winx64\bin mysql -uroot -p alter user 'root'@'localhost' identified by '123456'; flush privileges; 注：123456是设置root的新密码，C:\Program Files\mysql-5.7.17-winx64\bin是mysql的地址
第二种 2.1MySQL配置文件my.ini中，在[mysqld]下添加skip-grant-tables 2.2重启MySQL服务 2.3用管理员身份进入cmd，输入如下命令
cd C:\Program Files\mysql-5.7.17-winx64\bin; flush privileges; alter user 'root'@'localhost' identified by '123456'; 注：123456是设置root的新密码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78d58ba0e6cc6eea0db7dc96cea2ef73/" rel="bookmark">
			百度地图调用，传递经纬度到后台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近使用到了百度地图，需要调用百度地图并在上面做标记，并将标记的经纬度传递到数据库进行保存。
首选看一下效果图，如下： 代码如下 总共有三部分 1. 引入百度地图 2. body 3. js
1. 引入 &lt;script type="text/javascript" src="http://api.map.baidu.com/api?key=&amp;v=1.1&amp;services=true"&gt;&lt;/script&gt; 2. body &lt;form action="/publicsh" method="POST"&gt; &lt;input type="hidden" class="longitude" id="houses.longitude" name="houses.longitude"&gt; &lt;input type="hidden" class="latitude"　id="houses.latitude" name="houses.latitude"&gt; &lt;span class="w-fabu-lable2"&gt;标注地图：&lt;/span&gt; &lt;!--&lt;textarea class="w-textare3" name="" rows="" cols=""&gt;&lt;/textarea&gt;--&gt; &lt;div style="width:697px;height:550px;border:#ccc solid 1px;" id="dituContent"&gt;&lt;/div&gt; &lt;input type="submit" value="submit"&gt; &lt;/form&gt; &lt;/body&gt; 注意： 最开始两个隐藏标签是用来传递经纬度，后面通过js为他们赋值
3. js &lt;script type="text/javascript"&gt; &lt;!--****百度地图开始****--&gt; //创建和初始化地图函数： function initMap(){ createMap();//创建地图 setMapEvent();//设置地图事件 addMapControl();//向地图添加控件 addMarker();//向地图中添加marker } //创建地图函数： function createMap(){ var map = new BMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78d58ba0e6cc6eea0db7dc96cea2ef73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6b13fd0b1c14e977d7414e8a387cdfc/" rel="bookmark">
			mysql查询重复数据并保留一条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.需求
现有一张利息表hyd_day_loandetil，有以下字段
主键ID、借贷IDLOAN_TURN_ID、账单日BILL_TIME、正常利息INTEREST、逾期利息OVERDUE_BALANCE字段
表中存在同一天、同一笔借贷、两条数据，现在要把重复的数据查询出来并把正常利息+逾期利息比较小的那一条查询出来
2.SQL脚本实现
SELECT N.id,DATE_SUB(N.BILL_TIME, interval 3 day) FROM( SELECT @rownum:=@rownum*-1 AS rownum,hyd_day_loandetil.* FROM (SELECT @rownum:=1) r, hyd_day_loandetil WHERE (LOAN_TURN_ID,BILL_TIME) IN( SELECT LOAN_TURN_ID,BILL_TIME FROM hyd_day_loandetil GROUP BY LOAN_TURN_ID,BILL_TIME having count(*) &gt; 1 ) ORDER BY BILL_TIME,LOAN_TURN_ID,hyd_day_loandetil.INTEREST+hyd_day_loandetil.OVERDUE_BALANCE DESC ) N WHERE N.rownum=13.SQL脚本分析 3.1根据LOAN_TURN_ID,BILL_TIME分组得到重复的数据并根据INTEREST+OVERDUE_BALANCE倒序排序 3.2给每条数据一个伪列值依次为-1,1，-1,1，-1,1......
3.3可以看出来我们只要筛选N.rownum=1的就是我们需要的数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbb1f69283249b6a13108bd079f94558/" rel="bookmark">
			最全面的ConstraintLayout教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天给大家带来2017年的第一篇文章，这里先祝大家新年好。
本篇文章的主题是ConstraintLayout。其实ConstraintLayout是Android Studio 2.2中主要的新增功能之一，也是Google在去年的I/O大会上重点宣传的一个功能。我们都知道，在传统的Android开发当中，界面基本都是靠编写XML代码完成的，虽然Android Studio也支持可视化的方式来编写界面，但是操作起来并不方便，我也一直都不推荐使用可视化的方式来编写Android应用程序的界面。
而ConstraintLayout就是为了解决这一现状而出现的。它和传统编写界面的方式恰恰相反，ConstraintLayout非常适合使用可视化的方式来编写界面，但并不太适合使用XML的方式来进行编写。当然，可视化操作的背后仍然还是使用的XML代码来实现的，只不过这些代码是由Android Studio根据我们的操作自动生成的。
另外，ConstraintLayout还有一个优点，它可以有效地解决布局嵌套过多的问题。我们平时编写界面，复杂的布局总会伴随着多层的嵌套，而嵌套越多，程序的性能也就越差。ConstraintLayout则是使用约束的方式来指定各个控件的位置和关系的，它有点类似于RelativeLayout，但远比RelativeLayout要更强大。
其实ConstraintLayout属于Android Studio 2.2的新特性，我在去年写《第二行代码》的时候就非常想要将这部分内容加入到新书里面，但是在尝试之后还是放弃了。因为ConstraintLayout的用法很多都是对控件进行拖拽，只用文字或者是一些静态图片实在太难将它的用法表达清楚了，因此不太适合写到书上。我当时的想法就是后面写一篇文章来讲解ConstraintLayout的用法，弥补一下《第二行代码》中缺失的这部分新特性，那么今天这篇文章来了。
开始 下面我们开始用边学边练的方式来进行学习，首先打开你的Android Studio，并新建一个ConstraintLayoutTest项目。另外，确保你的Android Studio是2.2或以上版本。
为了要使用ConstraintLayout，我们需要在app/build.gradle文件中添加ConstraintLayout的依赖，如下所示。
目前ConstraintLayout库最新的版本是1.0.0-beta4，还没有推出正式稳定版本，不过这并不影响我们提前进行学习和使用。
现在打开res/layout/activity_main.xml文件，由于这是一个新建的空项目，Android Studio会自动帮我们创建好一个布局，如下图所示。
不过，Android Studio自动创建的这个布局默认使用的是RelativeLayout，我们可以通过如下操作将它转换成ConstraintLayout。
转换完成之后，原RelativeLayout中的内容也会自动转换到ConstraintLayout中，比如图中的TextView。如果你不需要它的话，可以选中这个控件，然后按键盘上的Delete键即可删除。
我们可以看到，现在主操作区域内有两个类似于手机屏幕的界面，左边的是预览界面，右边的是蓝图界面。这两部分都可以用于进行布局编辑工作，区别是左边部分主要用于预览最终的界面效果，右边部分主要用于观察界面内各个控件的约束情况。
基本操作 下面我们来学习一些具体的操作吧，ConstraintLayout的基本用法很简单，比如我们想要向布局中添加一个按钮，那么只需要从左侧的Palette区域拖一个Button进去就可以了，如下图所示。
虽说现在Button已经添加到界面上了，但是由于我们还没有给Button添加任何的约束，因此Button并不知道自己应该出现在什么位置。现在我们在预览界面上看到的Button位置并不是它最终运行后的实际位置，如果一个控件没有添加任何约束的话，它在运行之后会自动位于界面的左上角。
那么下面我们就来给Button添加约束，每个控件的约束都分为垂直和水平两类，一共可以在四个方向上给控件添加约束，如下图所示。
上图中Button的上下左右各有一个圆圈，这圆圈就是用来添加约束的，我们可以将约束添加到ConstraintLayout，也可以将约束添加到另一个控件。比如说，想让Button位于布局的右下角，就可以这样添加约束，如下图所示。
我们给Button的右边和下边添加了约束，因此Button就会将自己定位到布局的右下角了。类似地，如果我们想要让Button居中显示，那么就需要给它的上下左右都添加约束，如下图所示。
这就是添加约束最基本的用法了。
除此之外，我们还可以使用约束让一个控件相对于另一个控件进行定位。比如说，我们希望再添加一个Button，让它位于第一个Button的正下方，并且间距64dp，那么操作如下所示。
现在添加约束的方式我们已经学完了，那么该怎样删除约束呢？其实也很简单，删除约束的方式一共有三种，第一种用于删除一个单独的约束，将鼠标悬浮在某个约束的圆圈上，然后该圆圈会变成红色，这个时候单击一下就能删除了，如下图所示。
第二种用于删除某一个控件的所有约束，选中一个控件，然后它的左下角会出现一个删除约束的图标，点击该图标就能删除当前控件的所有约束了，如下所示。
第三种用于删除当前界面中的所有约束，点击工具栏中的删除约束图标即可，如下图所示。
Inspector 这样我们就把ConstraintLayout的基本用法学完了，接下来我们开始学习一些进阶的内容。
当你选中任意一个控件的时候，在右侧的Properties区域就会出现很多的属性选项，如下图所示。
在这里我们就可以设置当前控件的所有属性，如文本内容、颜色、点击事件等等。这些功能都非常简单，我就不再进行详细介绍，大家自己点一点就会操作了。
需要我们重点掌握的是Properties区域的上半部分，这部分也被称为Inspector。
首先可以看到，在Inspector中有一个纵向的轴和一个横向的轴，这两个轴也是用于确定控件的位置的。我们刚才给Button的上下左右各添加了一个约束，然后Button就能居中显示了，其实就是因为这里纵横轴的值都是50。如果调整了纵横轴的比例，那么Button的位置也会随之改变，如下图所示。
不过，虽然我们将横轴的值拖动到了100，但是Button并没有紧贴到布局的最右侧，这是为什么呢？实际上，Android Studio给控件的每个方向上的约束都默认添加了一个16dp的间距，从Inspector上面也可以明显地看出来这些间距的值。如果这些默认值并不是你想要的，可以直接在Inspector上进行修改，如下图所示：
可以看到，修改成0之后Button右侧的间距就没了。
接下来我们再来学习一下位于Inspector最中间的那个正方形区域，它是用来控制控件大小的。一共有三种模式可选，每种模式都使用了一种不同的符号表示，点击符号即可进行切换。
表示wrap content，这个我们很熟悉了，不需要进行什么解释。
表示固定值，也就是给控件指定了一个固定的长度或者宽度值。
表示any size，它有点类似于match parent，但和match parent并不一样，是属于ConstraintLayout中特有的一种大小控制方式，下面我们来重点讲解一下。
首先需要说明，在ConstraintLayout中是有match parent的，只不过用的比较少，因为ConstraintLayout的一大特点就是为了解决布局嵌套，既然没有了布局嵌套，那么match parent也就没有多大意义了。
而any size就是用于在ConstraintLayout中顶替match parent的，先看一下我们怎样使用any size实现和match parent同样的效果吧。比如说我想让Button的宽度充满整个布局，操作如下图所示。
可以看到，我们将Button的宽度指定成any size，它就会自动充满整个布局了。当然还要记得将Button左侧的间距设置成0才行。
那有的朋友可能会问了，这和match parent有什么区别呢？其实最大的区别在于，match parent是用于填充满当前控件的父布局，而any size是用于填充满当前控件的约束规则。举个例子更好理解，如果我们有一个新的Button，它的其中一个约束是添加到当前这个Button上的，那么any size的效果也会发生改变，如下图所示。
通过上图的演示，相信你已经很好地理解any size的作用了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbb1f69283249b6a13108bd079f94558/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cba1d3bb8bdd590b548f7bcc2cca61f9/" rel="bookmark">
			《马丁伊登》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到微博上锵锵三人行最新一期节目的介绍时，我心中一惊，怎么会这么巧。刚看完杰克伦敦的马丁伊登，许子东就要谈这本他认为改变自己人生的书。马丁伊登不至于改变我的人生，但也是给我印象最深刻的小说之一。作家有两类。一类社会型的作家喜欢观察别人的生活，写别人的故事。一类自我型的作家擅长描写自己的见闻，抒发个人的感情。我个人偏好后者，并且偏见地认为最好的小说都是某种程度上写自己的。无论怎样观察、感受和思考别人的人生，终归是隔了一层；而写自己的感受、情感、思想才是最真切的。尤其是作家作为一群感受异常敏锐、感情异常丰富、对美有异常天分的稀有动物，用自己的血肉化成的小说最能达到艺术的极致。小仲马的《茶花女》、夏洛蒂勃朗特的《简爱》都是如此，《马丁伊登》也不例外。
我几年前最初看马丁伊登时，就深深被主人公打动了。那时只看了开头几章，有事落下了就一直没看。前几天找出来，几乎一口气读完。马丁伊登无与伦比的天才和对生命的热情昂扬了起码3/4的篇幅，最终竟陡然幻灭，沉入海底。
许老师对许多事情提纲挈领的分析、丰富的文学知识和广博的见闻经常既让我觉得有趣又获益，但这次对马丁伊登的概括我可以满有把握地说，往好里说是不全面，往坏说则是偏狭。小说在他口中基本变成庸俗的爱情故事，贫穷的男主人公爱上千金小姐，努力奋斗还是对抗不住世俗的压力，功成名就后对回心转意的爱人负气地冷淡和拒绝，最终自杀。
从引文看，许老师读的译本和我不一样，但是文字上细微的差别不可能掩盖作者清晰表达的意思。马丁伊登显眼的不是一个爱上富家小姐的贫苦水手的身份，而是一个天才。他身强力壮，相貌堂堂，手脚敏捷，头脑灵活，诙谐开朗，在劳动伙伴里就已经是一个明星。他体力过人，不知疲倦，能够干比别人更多的活，赚更多的钱，打架永远是赢者，从不缺姑娘的青睐。而他智力上的天分甚至更加出众，他喜爱读书，虽然没什么机会。直到有一天，他遇上露丝和她富有的家庭，他见识到资产阶级的生活和蕴含于其中的文化。对露丝的爱和对知识智慧的渴望实在难分高下，他如饥似渴地阅读，每天只睡五个小时，最后干活赚了一笔钱后就完全投身于知识的海洋。天才的标志是他同时渴望创作。他很快就无师自通，认识到自己能写出比杂志上更好的作品，希望成为一名作家，用智力劳动的收入来改变自己的生活、赢得露丝和她家人的认可。他出类拔萃的大脑一面不断用哲学、哲学和文学的书本填充，一面生产出诗歌、小说和论文。他从智力和道德上都看不起资产阶级，露丝父亲、朋友和客人那样的企业家和银行家，法官和大学教授也大多平庸无能。他自己得意的作品被杂志不断退回，游戏文字的结局稍微好一些，愚蠢的编辑不理解他的作品，无耻的编辑采纳他的作品而不付钱。生活很困窘，亲人和房东有时会接济，但他的姐姐和妹妹都不理解他为什么不去找一份工作，姐夫和妹夫则讨厌他这个懒汉。资产阶级的人则在游手好闲之外，还误以为他持社会主义立场而反感。实际上他既认为资产阶级是堕落的、共和民主两党的政策是虚伪的，也鄙视社会党人的主张，称之为奴隶的道德，他推崇赫伯特斯宾塞，信奉尼采的超人哲学。露丝爱他，对他身上洋溢的自己生活圈里找不到的旺盛和野性的生命力既害怕反感又着迷，但是在爱情之外，她也像普通女人一样期盼马丁有一份体面的工作和她那个阶层的社会地位。她的父母则瞧不起马丁，母亲想方设法让女儿结识一些门当户对事业有成的年轻人。在物质贫乏和精神压力的夹击下，马丁夜以继日地创作、投稿，对丰厚稿酬的期望和失望让他的神经不断坐过山车。他唯一的知音是一位在露丝家偶遇的勃力森登。勃力森登怀才不遇、嗜酒如命、身染肺病、神出鬼没，是一位激烈的社会主义者，他比马丁更痛恨浅薄、愚蠢、庸俗和扼杀天才的杂志编辑，对资产阶级和现存的社会制度绝望，只为自己心目中的美而创作。勃力森登带他见识了一回潦倒的社会主义知识分子的聚会，他们高谈阔论体现出的知识广度和思想深度令马丁大为倾倒。勃力森登还写了一首马丁佩服得五体投地、引为当代最伟大作品的诗篇。
奋斗的生活出现重大变故。他在一次社会党人聚会上的演讲被一位报社记者歪曲，成为当地臭名昭著的社会主义和无政府主义分子。平时他购买食物的商店店主讨厌这位异端和不爱国的人。最糟糕的是露丝父母的偏见加深了，露丝也对马丁的言论很失望，在父母的压力下断绝了和马丁的关系。马丁一病不起，五天后得知勃力森登在五天前死了。命运的另一面行情却截然相反。马丁的第一本书出版了，此后他的小说、诗歌、论文陆续出版和被热捧。稿费翻番地向上涨，媒体热烈地讨论和赞美他的作品，杂志社搜集关于他的一切消息，竞相宣扬自己是天才的最早发现者。社会名流邀请他赴宴、参加俱乐部、演讲。他昔日的老师、姐夫和妹夫对他的态度也有了180度的转变。露丝的家人变得热情而有礼，露丝终于在一天晚上来找他，想重归于好。马丁的头脑里却始终盘旋着一个折磨人的疑问，那些作品是他早就写好的，现在人们争相请吃饭的他和当年那个饥肠辘辘无人理睬的他，没有任何变化。他不再有写作的动力，丧失了生活的热情。他试图重新融入当年劳动阶级的圈子，也想过去找那些社会主义知识分子，但都痛苦地失败了。他感到孤独、疲倦。金钱滚滚而来，他慷慨地回报了帮助过他的女房东、姐姐、妹妹和老朋友，想到南太平洋的海岛上回归平静。但日益增长的厌世情绪终于让他从船上投入冰冷的大海。
马丁伊登身体和精神上出类拔萃的活力和天才像正午的阳光、雨季的河流，像贝多芬的热情奏鸣曲，你可以不认同他的观点，不喜欢他对人的态度，但无法否认的是那股令人激动的热与力，就像你可以不赞成姜文对革命的观点，但不可能无视电影里灿烂的阳光。马丁伊登自负，但那是赤子之心的自负。马丁伊登对爱情决绝，但那是因为他追求的是理想的爱情。对许老师后来的感悟——马丁爱得不够深，不论露丝爱的是什么，都应该接纳，马丁对自己太在乎——以及在他的误导下马家辉和窦文涛的以讹传讹、错上加错，什么慈悲宽容，马丁知道了，应该会用下面的话回击：
你们只会用世俗的标准要求人，评估人的价值。你们只知道门当户对、量入为出、相濡以沫的爱情，你们对纯粹的爱、作为人生最高追求的爱一无所知。你们看见一棵树，会想到乘凉、伐倒当做木材建房、挂上衣服晾晒、摘取果实品尝，你们却看不到树之为树的美。你们总是根据事物与其他事物的关系来认识和评估它，你们看不到事物独立存在的价值和美。你们习惯过眼云烟、谈笑风生，你们用现实的眼光看待一切，青春、真理、爱在你们嘴里只是茶余饭后的谈资，饱经风霜是你们的国家，通情达理是你们的文化。你们不光是一个早熟的民族，还是一个苍老的民族。你们不会像我那样忧郁和绝望，因为你们起初对爱就没有浪漫的想象和希望。我对生活厌倦，是因为我发现了现实的荒谬。整个世界对我和作品的评价标准是那么荒唐。我对生活的认识幻灭了，或许是因为我对生活的期望比你们高。你们可以评断我最后变成一个悲观主义者，你们活得比我坚韧，但是上天知道你们绝没有资格看不起我。
巧合的是，许老师作为文学批评家，正是马丁伊登鄙薄的。在小说和三人行的评论中，我似乎看到了两种文化。一种崇尚个人的、独立的、冒险的、探求真理的、向往价值的；一种崇尚人际和谐的、看重相互体谅的、现实的、善高于真的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25d990020cf59315b1e366e77eaa6a23/" rel="bookmark">
			常用英文符号读法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各种符号的英语文读法:
'exclam'='!'
'at'='@'
'numbersign'='#'
'dollar'='$'
'percent'='%'
'caret'='^'
'ampersand'='&amp;'
'asterisk'='*'
'parenleft'='('
'parenright'=')'
'minus'='-'
'underscore'='_'
'equal'='='
'plus'='+'
'bracketleft'='['
'braceleft'='{'
'bracketright'=']'
'braceright'='}'
'semicolon'=';'
'colon'=':'
'quote'='''
'doublequote'='"'
'backquote'='''
'tilde'='~'
'backslash'='\'
'bar'='|'
'comma'=','
'less'='&lt;'
'period'='.'
'greater'='&gt;'
'slash'='/'
'question'='?'
'space'=''
￣ hyphen连字符
'apostrophe 省略号;所有格符号
— dash破折号
‘ ’singlequotation marks 单引号
“ ”doublequotation marks 双引号
() parentheses 圆括号
[] square brackets 方括号
Anglebracket
{}Brace
《 》Frenchquotes 法文引号;书名号
...ellipsis 省略号
¨tandem colon 双点号
"ditto 同上
‖ parallel双线号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25d990020cf59315b1e366e77eaa6a23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/814e349d68a814e6853d00de006f1fa7/" rel="bookmark">
			【C#】重载（overload）与重写（override）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【前言】
重载和重写，他们其实是实现类型多态（同一种方法，不同的对象会产生不同的结果）特性的基本技术之一，两种技术貌似而实质截然不同
【重载】
1、什么是重载
重载其实是一种编译时多态技术，就是说在编译时就知道调用的是哪个方法，这其实很好理解。所谓重载就是在同一个类中的多个同名方法，只是这些方法的参数类表不同（参数个数，或者是相同位置的参数类型不同）而已，而返回值可以相同也可以不同，这些方法具有不同的方法签名。也就是说不同的方法，从编译器的角度，不同的方法就是不同的方法地址，在编译时就已经确定，是一种静态绑定
2、格式
//用于在给定了参数列表和一组候选函数成员的情况下，选择一个最佳函数成员来实施调用 public void test(int x,int y){} public void test(int x,ref int y){} public void test(int x,int y,string a){} 3、重载的特征
（1）方法名必须相同
（2）参数列表必须不相同，与参数列表的顺序无关
（3）返回值类型可以不同
4、重载的特点
（1）在使用重载的时候只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同意方法内的几个参数类型必须不一样，例如可以是fun(int, float)，但是不能为fun(int,int)）
（2）不能通过访问权限、返回类型、抛出的异常进行重载
（3）方法的异常类型和数目不会对重载造成影响
（4）对于继承来说，如果某一方法在父类中是访问权限priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果
5、例子
建立一个猫类，在这个类中构造两个方法。一个是带参数姓名的方法，另一个是不带参数姓名的方法。这样初始化一个“猫”的对象时，就可以选择给对象起名或者不起名，从而达到扩展的目的
class Cat { public string name= " "; public Cat(string name) { this.name=name; } public Cat()//将方法重载 { this.name="无名"; } } 【重写】
1、什么是重写
重写也叫做覆盖，它存在于有继承关系的子类中，是在子类中重新定义父类具有相同方法签名的函数，使之有不用的实现。重写是指重写基类的方法，在基类中的方法必须有修饰符virtual，而在子类的方法中必须指明override
例如，假设动物类存在“跑”的方法，从中派生出马和狗，马和狗的跑的形态是各不相同的，因此同样方法需要两种不同的实现，这就需要“重新编写”基类中的方法
2、格式
//在基类中 public virtual void myMethod() { } //在子类中 public override void myMethod() { } 3、重写的特征
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/814e349d68a814e6853d00de006f1fa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7431f80cd6b467bf055353481f185e5/" rel="bookmark">
			jQuery实战3:菜单效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		菜单是web开发中常见的功能模块，它能够直观的展示给用户本站中有哪些功能。一般在页面中看到的菜单类型分为两种：横向菜单和纵向菜单。 今天分别来完成纵向菜单和横向菜单的功能。先来看看纵向菜单，首先导航栏有四个菜单项，分别是古典名著《红楼梦》、《水浒传》、《三国演义》、《西游记》，而每个菜单栏下面分别对应着自己的二级菜单。对应的html是一个无序列表ul下面的四个li，每个li包括了每个一级菜单和一级菜单下的二级菜单。对应的html如下:
&lt;body&gt; &lt;ul&gt; &lt;li class="main"&gt; 红楼梦 &lt;ul&gt; &lt;li&gt;第一回 甄士隐梦幻识通灵 贾雨村风尘怀闺秀&lt;/li&gt; &lt;li&gt;第二回 贾夫人仙逝扬州城 冷子兴演说荣国府&lt;/li&gt; &lt;li&gt;第三回 金陵城起复贾雨村 荣国府收养林黛玉&lt;/li&gt; &lt;li&gt;第四回 薄命女偏逢薄命郎 葫芦僧乱判葫芦案&lt;/li&gt; &lt;li&gt;第五回 开生面梦演红楼梦 立新场情传幻境情&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class="main"&gt; 水浒传 &lt;ul&gt; &lt;li&gt;第一回　张天师祈禳瘟疫　洪太尉误走妖魔&lt;/li&gt; &lt;li&gt;第二回　王教头私走延安府　九纹龙大闹史家村&lt;/li&gt; &lt;li&gt;第三回　史大郎夜走华阴县　鲁提辖拳打镇关西&lt;/li&gt; &lt;li&gt;第四回　赵员外重修文殊院　鲁智深大闹五台山&lt;/li&gt; &lt;li&gt;第五回　小霸王醉入销金帐　花和尚大闹桃花村&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class="main"&gt; 三国演义 &lt;ul&gt; &lt;li&gt;第一回 宴桃园豪杰三结义 斩黄巾英雄首立功&lt;/li&gt; &lt;li&gt;第二回 张翼德怒鞭督邮 何国舅谋诛宦竖&lt;/li&gt; &lt;li&gt;第三回 议温明董卓叱丁原 馈金珠李肃说吕布&lt;/li&gt; &lt;li&gt;第四回 废汉帝陈留践位 谋董贼孟德献刀&lt;/li&gt; &lt;li&gt;第五回 发矫诏诸镇应曹公 破关兵三英战吕布&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class="main"&gt; 西游记 &lt;ul&gt; &lt;li&gt;第一回 靈根育孕源流出 心性修持大道生&lt;/li&gt; &lt;li&gt;第二回 悟徹菩提真妙理 斷魔歸本合元神&lt;/li&gt; &lt;li&gt;第三回 四海千山皆拱伏 九幽十類盡除名&lt;/li&gt; &lt;li&gt;第四回 官封弼馬心何足 名注齊天意未寧&lt;/li&gt; &lt;li&gt;第五回 亂蟠桃大聖偷丹 反天宮諸神捉怪&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; 我们是用列表嵌套列表的方式来做二级菜单的，如果再有三级菜单，只需要在二级菜单的li中再添加一层ul。上诉html代码的页面效果如下: 显然离想要的效果相去甚远。这时候可以用menu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7431f80cd6b467bf055353481f185e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fad062b22f0461ec2252290c869ec80e/" rel="bookmark">
			Linux下火狐浏览器无响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下火狐浏览器总是出现以下提示： Firefox已经在运行,但是没有响应。如要打开新窗口,您必须现关闭该Firefox进程,或者重新启动您的系统。
解决方法：在命令行中输入 firefox -profilemanager 。 回车后会出现一个提示窗口。显示选择使用哪个 profile 来启动 firefox。将原来已经存在的 profile 删除掉，一般都是 default 。删除了以后，新建一个 profile，用新建的 profile 来启动就完美解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/056828b73a5af5dc198aacfa106af1f2/" rel="bookmark">
			go 格式化 int，位数不够0补齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		n := 32 sInt := fmt.Sprintf("%07d", n) 转载于:https://www.cnblogs.com/chunyou128/p/6294247.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c278d71d1cddba0edd5c279f314aed5/" rel="bookmark">
			Linux模拟复杂网络环境下的传输（netem和tc）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行网络服务的测试时，有时需要模拟一些异常的网络情况，例如网络延时长、丢包、网络地址连接不通等。 在Linux下，可以通过tc工具来模拟各种网络情况；通过iptables禁止访问某个网络地址。 一、netem与tc介绍 netem 是 Linux 2.6 及以上内核版本提供的一个网络模拟功能模块。该功能模块可以用来在性能良好的局域网中，模拟出复杂的互联网传输性能，诸如低带宽、传输延迟、丢包等等情况。 使用 Linux 2.6 (或以上 ) 版本内核的很多发行版 Linux 都开启了该内核功能，比如 Fedora、 Ubuntu、 Redhat、 OpenSuse、 CentOS、 Debian等等。 tc 是 Linux 系统中的一个工具，全名为 traffic control（流量控制）。 tc 可以用来控制 netem 的工作模式，也就是说，想要使用 netem ，则需要内核开启了 netem，而且安装了 tc工具。 tc控制的是发包动作，不能控制收包动作。它直接对物理接口生效，如果控制了物理的 eth0，那么逻辑网卡（比如 eth0:1）也会受到影响，反之则不行，控制逻辑网卡是无效的。 二、模拟延迟传输 将 eth0 网卡的传输设置为延迟100毫秒发送。 $ tc qdisc add dev eth0 root netem delay 100ms 真实的情况下，延迟值不会这么精确，会有一定的波动，下面命令模拟带有波动性的延迟值： $ tc qdisc add dev eth0 root netem delay 100ms 10ms 该命令将 eth0 网卡的传输设置为延迟 100ms ± 10ms （ 90 ~ 110 ms 之间的任意值）发送。 由于各个包的延迟值不通，也会在一定程度上打乱发包的次序。 还可以更进一步加强这种波动的随机性，将 eth0 网卡的传输设置为 100ms ，同时，大约有 30%的包会延迟 ± 10ms 发送： $ tc qdisc add dev eth0 root netem delay 100ms 10ms 30% 三、模拟网络丢包 将 eth0 网卡的传输设置为随机丢掉 1% 的数据包。 $ tc qdisc add dev eth0 root netem loss 1% 也可以设置丢包的成功率，将 eth0 网卡的传输设置为随机丢掉 1% 的数据包，成功率为 30% ： $ tc qdisc add dev eth0 root netem loss 1% 30% 四、模拟包重复 将 eth0 网卡的传输设置为随机产生 1% 的重复数据包。 $ tc qdisc add dev eth0 root netem duplicate 1% 五、模拟数据包损坏 将 eth0 网卡的传输设置为随机产生 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c278d71d1cddba0edd5c279f314aed5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e625b8a0e6c616c91a7b28f99cd8db4e/" rel="bookmark">
			HTML_插入图片详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网页图片的基本格式：
HTML的相关标准中并没有规定图片的格式，原则上来说是任意的。但是目前市场上的主流浏览器对网页图片的格式有所要求，通常情况下是：JPEG(联合图像专家组)和GIF(图像交换格式)两种格式的图片；至于两种图片的一些特点和各自的优缺点，可通过百度自行搜索。
插入图片：
插入图片可以起到适当的美化作用。而插入图片的标签只有一个&lt;img&gt;标签，它允许在文档当前的文本流中引用或者插入图像图像，没有结束标签&lt;/img&gt;。
&lt;img&gt;标签：
①&lt;img&gt;标签中src属性是必须的（除非在基于IE的浏览器中使用Dynsrc）在&lt;img&gt;标签中，其他属性都是可选的
②src的值是图像的URL（统一资源定位符）
③alt属性指定了替代文本(图像无法显示或者用户禁用图像时显示的替代文本；或者鼠标放到图像上显示的提示信息)
④width和height属性设置图像尺寸，要求必须是整数(顺序无所谓)
⑤border属性和一个用像素表示的宽度值就可以去掉(border=0)或者加宽图像的边框
⑥align属性来控制带有文字环绕的图像的对其方式，align属性具体的属性值如下：
⑦hspace和vspace属性分别设置图像左右两边和上下两边文字与图像之间距离的像素值
代码展示：
运行结果展示：
利用&lt;img&gt;标签插入AVI视频：
AVI是视频文件的主流格式。这种格式的文件随处可见，例如一些游戏、教育软件的片头等都会应用到AVI。而利用&lt;img&gt;标签的controls、dynsrc、loop或者start等属性允许将一个内联电影嵌入到主体内容中。
代码展示：
&lt;img dysrc="file:///D	|/123/456/{张宇} 高数/2015张宇高数强化班/0第0讲 导学/04 数三内容安排.avi" width="400" height="300" /&gt; 注意：值得一提的是start的属性值。 start有两个属性值：mouseover当鼠标滑动到AVI文件上方后播放；fileopen当网页打开时即播放。
&lt;img dysrc="file:///D	|/123/456/{张宇} 高数/2015张宇高数强化班/0第0讲 导学/04 数三内容安排.avi" width="400" height="300" start="fileopen"/&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ef64f270e58bfded5887477855f69ac/" rel="bookmark">
			MongoDB 或者 redis 可以替代 memcached 吗?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mongodb和memcached不是一个范畴内的东西。mongodb是文档型的非关系型数据库，其优势在于查询功能比较强大，能存储海量数据。mongodb和memcached不存在谁替换谁的问题。
和memcached更为接近的是redis。它们都是内存型数据库，数据保存在内存中，通过tcp直接存取，优势是速度快，并发高，缺点是数据类型有限，查询功能不强，一般用作缓存。在我们团队的项目中，一开始用的是memcached，后来用redis替代。
相比memcached：
1、redis具有持久化机制，可以定期将内存中的数据持久化到硬盘上。
2、redis具备binlog功能，可以将所有操作写入日志，当redis出现故障，可依照binlog进行数据恢复。
3、redis支持virtual memory，可以限定内存使用大小，当数据超过阈值，则通过类似LRU的算法把内存中的最不常用数据保存到硬盘的页面文件中。
4、redis原生支持的数据类型更多，使用的想象空间更大。
5、前面有位朋友所提及的一致性哈希，用在redis的sharding中，一般是在负载非常高需要水平扩展时使用。我们还没有用到这方面的功能，一般的项目，单机足够支撑并发了。redis 3.0将推出cluster，功能更加强大。
6、redis更多优点，请移步官方网站查询。
MongoDB不多说，不是一个类型的东西，Redis相对Memcached来说功能和特性上的优势已经很明显了。而对于性能，Redis作者的说法是平均到单个核上的性能，在单条数据不大的情况下Redis更好。为什么这么说呢，理由就是Redis是单线程运行的。 因为是单线程运行，所以和Memcached的多线程相比，整体性能肯定会偏低。 因为是单线程运行，所以IO是串行化的，网络IO和内存IO，因此当单条数据太大时，由于需要等待一个命令的所有IO完成才能进行后续的命令，所以性能会受影响。 而就内存使用上来说，目前Redis结合了tcmalloc和jemalloc两个内存分配器，基本上和Memcached不相伯仲。如果是简单且有规律的key value存储，那么用Redis的hash结构来做，内存使用上会惊人的变小，优势是很明显的。
更多参考：http://www.zhihu.com/question/19645807
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5af12c4243b75948b72b387db7fa35e/" rel="bookmark">
			java获取服务器信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java获取服务器信息需要用到sigar.jar，但该jar在linux下依赖于libsigar-amd64-linux.so、libsigar-x86-linux.so。在window下依赖于sigar-amd64-winnt.dll、sigar-x86-winnt.dll。配置文件这存在这模拟系统命名的操作，可以通过这些系统命名来获取系统的参数。
默认情况下是将依赖文件放在jdk下的lib包中，这样项目启动的时候会自动加载这些配置文件。但每个人使用就需要这么配置，太麻烦了，为了方便我们写一个公共类来优化这一问题。
package com.dhcc.isccore.common.util; import java.io.File; import org.hyperic.sigar.Sigar; import com.dhcc.isccore.common.constant.IsccoreConstant; public class SigarUtils { public final static Sigar sigar = initSigar(); public static Sigar initSigar() { try { File classPath = new File(IsccoreConstant.SIGAR_PATH); String path = System.getProperty("java.library.path"); String sigarLibPath = classPath.getCanonicalPath(); // 为防止java.library.path重复加，此处判断了一下 if (!path.contains(sigarLibPath)) { if (isOSWin()) { path += ";" + sigarLibPath; } else { path += ":" + sigarLibPath; } System.setProperty("java.library.path", path); } return new Sigar(); } catch (Exception e) { return null; } } public static boolean isOSWin() {// OS 版本判断 String OS = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5af12c4243b75948b72b387db7fa35e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df6323b91d1f880a2788ea976d102455/" rel="bookmark">
			mac上用终端启动和关闭mysql服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动服务
mysql.server start
关闭服务
mysql.server stop
重启服务
mysql.server restart
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e182fb76c237a7889f76029b6d519157/" rel="bookmark">
			【读书笔记】《LATEX入门》第二章【未完】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文字与符号 使用UTF8编码可以直接输入进文档。使用babel包，可以使文档支持不同语言。如\usepackage[greek, english]{babel}，然后可以使用\textgreek{abcd}引用希腊字母。如需少量字符，可以使用\usepackage[OT2]{fontenc}和{\fontencoding{OT2}\selectfont ABCabc}引用少量字符。使用{}和\/可以取消字符间的连字。在LATEX可直接使用 的标点有16种，,.;:!?``'()[]-/*@。``和''可以代替双引号，-表示连词符，--表示数字范围，---表示破折号。使用$\ldots$表示间距正常的省略号。#、\$、\%、\&amp;、\{、\}、\_分别表示相应的符号。使用\添加空格，汉语与英语之间往往会添加空格使用\mbox{内容}消除内容和后面的空格。\CJKsetecglue{}彻底禁用汉字与其他内容间的空格。\phantom{参数}产生一个和参数长度一样的空格，\hphantom{}水平方向，\vphantom{}竖直方向。\\直接换行，\linebreak换行。特殊符号 § 使用\S， \dag 使用\dag， \ddag 使用\ddag， \copyright 使用\copyright， \textregistered 使用\textregistered， \texttrademark 使用\texttrademark， \P 使用\P， \pounds 使用\pounds， \textbullet 使用\textbullet，也可以使用UTF8编码直接输入。带参数字体引用\textit{Italic font test}，字体声明{\bfseries Bold font test}。 字体族带参数命令声明命令罗马\textrm{}\rmfamily无衬线\textsf{}\sffamily打字机\texttt{}\ttfamily 字体形状带参数命令声明命令直立\textup{}\upshape意大利\textit{}\itshape斜体\textsl{}\slshape小型大写\textsc{}\scshape 汉字可以使用\CJKfamily{字体}设置字体。ctex宏包，使英文字体族对汉字同样生效。\fontencoding{编码}、\fontfamily{族}、\fontseries{系列}、\fontshape{形状}、\fontsize{大小}{基本行距}。使用\usefont{编码}{族}{系列}{形状}设置字体。使用txfonts宏包，可以对西文字体进行排版。\em和\emph{}对文字进行斜体强调ulem宏包，使用\uline给文字添加下划线，以及\uuline{}，\uwave{}、\sout{}、\xout{}、\dashuline{}、\dotuline{}。汉字可以使用CJKfntef宏包，\CJKunderdot{}，\CJKunderline{}，\CJKunderdblline{}，\CJKunderwave{}，\CJKsout{}，\CJKsout{}，\CJKxout{}。使用\tiny，\scriptsize，\footnotesize，\small，\normalsize，\large，\huge设置字体。汉字可以通过\zihao{}设置。使用\linespread{}设置行距。 - 也可以使用setspace宏包，\setstretch、\singlespacing、\onehalfspacing、\doublespacing设置行距。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a25aee36e908bd1e909f912295b14c44/" rel="bookmark">
			C&#43;&#43;弱引用智能指针weak_ptr的用处
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		weak_ptr也是一个引用计数型智能指针，但是它不增加对象的引用计数，即弱引用。与之相对，shared_ptr是强引用，只要有一个指向对象的shared_ptr存在，该对象就不会析构，直到指向对象的最后一个shared_ptr析构或reset()时才会被销毁。
利用weak_ptr，我们可以解决常见的空悬指针问题以及循环引用问题。
空悬指针问题 什么是空悬指针？考虑以下这种情况：
有两个指针p1和p2，指向堆上的同一个对象Object，p1和p2位于不同的线程中。假设线程A通过p1指针将对象销毁了（尽管把p1置为了NULL），那p2就成了空悬指针。这是一种典型的C/C++内存错误。
使用weak_ptr能够帮我们轻松解决上述的空悬指针问题。
weak_ptr不控制对象的生命期，但是它知道对象是否还活着。如果对象还活着，那么它可以提升为有效的shared_ptr（提升操作通过lock()函数获取所管理对象的强引用指针）；如果对象已经死了，提升会失败，返回一个空的shared_ptr。示例代码如下：
#include &lt;iostream&gt; #include &lt;memory&gt; int main() { // OLD, problem with dangling pointer // PROBLEM: ref will point to undefined data! int* ptr = new int(10); int* ref = ptr; delete ptr; // NEW // SOLUTION: check expired() or lock() to determine if pointer is valid // empty definition std::shared_ptr&lt;int&gt; sptr; // takes ownership of pointer sptr.reset(new int); *sptr = 10; // get pointer to data without taking ownership std::weak_ptr&lt;int&gt; weak1 = sptr; // deletes managed object, acquires new pointer sptr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a25aee36e908bd1e909f912295b14c44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e5610eb9ab3ed43b2b68d6bb8665c03/" rel="bookmark">
			django解决跨域请求的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		django解决跨域请求的问题 解决方案 1.安装django-cors-headers pip install django-cors-headers 2.配置settings.py文件 INSTALLED_APPS = [ ... 'corsheaders'， ... ] MIDDLEWARE_CLASSES = ( ... 'corsheaders.middleware.CorsMiddleware', 'django.middleware.common.CommonMiddleware', # 注意顺序 ... ) #跨域增加忽略 CORS_ALLOW_CREDENTIALS = True CORS_ORIGIN_ALLOW_ALL = True CORS_ORIGIN_WHITELIST = ( '*' ) CORS_ALLOW_METHODS = ( 'DELETE', 'GET', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'VIEW', ) CORS_ALLOW_HEADERS = ( 'XMLHttpRequest', 'X_FILENAME', 'accept-encoding', 'authorization', 'content-type', 'dnt', 'origin', 'user-agent', 'x-csrftoken', 'x-requested-with', 'Pragma', ) OK！问题解决！
其他解决方案 另外还从网上看到其他两种解决方案，但都不太合适。在此列出，供大家参考
1.使用JSONP 使用Ajax获取json数据时，存在跨域的限制。不过，在Web页面上调用js的script脚本文件时却不受跨域的影响，JSONP就是利用这个来实现跨域的传输。因此，我们需要将Ajax调用中的dataType从JSON改为JSONP（相应的API也需要支持JSONP）格式。 JSONP只能用于GET请求。
2.直接修改Django中的views.py文件 修改views.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e5610eb9ab3ed43b2b68d6bb8665c03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6beb7a768e3713b452f011d8840b179c/" rel="bookmark">
			十进制小数分数与二进制的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		十进制分数转换为二进制数
使用短除法。
例如将十进制分数11/28转换为二进制数，过程如下：
1、首先将分子分母分别转换成二进制 （11）10=（1011）2 （28）10=（11100）2 2、使用短除，借位时是借2，商只能是0或1 所以：11/28=1011/11100=0.01100100...
十进制小数转换为二进制小数
十进制数的整数位是二进制数的整数位，十进制数的小数位是二进制数的小数位。两部分分开转换。
整数部分 除以2取余，逆序排列。
小数部分 乘 2 取整，顺序排列。
例如转换十进制小数11.4，过程如下。
计算整数部分，11转换为二进制位1011：
计算小数部分0.4，首先将小数部分一直乘2，积的整数部分顺序取出：
0.4*2=0.8 取0 | 0.8*2=1.6 取1 | 顺
0.6*2=1.2 取1 | 序
0.2*2=0.4 取0 | 排
0.4*2=0.8 取0 | 列
0.8*2=1.6 取1 |
0.6*2=1.2 取1 |
0.2*2=0.4 取0 |
可以看出0110是循环，因此小数部分的二进制是
0.01100110……（循环0110）
最终结果是整数位和小数位合并1101111.01100110……（2）
二进制小数转换为十进制小数
使用按权展开求和法，小数点左边是2的正数次方，从0开始；小数点右边是2的负数次方，从-1开始。 例如将101.111(2)转换成十进制数
1*(2^2)+0*(2^1)+1*(2^0) # 整数部分
+ 1*(2^(-1))+1*(2^(-2))+1*(2^(-3)) # 小数部分
=5.875
附 python 版十进制与二进制转换
# coding=UTF-8 from decimal import Decimal def dec2bin(n, bit=20): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6beb7a768e3713b452f011d8840b179c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4d3348b370f1646fe5c3f3920706bd7/" rel="bookmark">
			EXCEL利用VBA把汉字转拼音（李晓锋版）20180828更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EXCEL利用VBA把汉字转换为拼音，现在网络中广泛传播的代码存在错误，
经过本人严格校对，把修正后的代码分享给大家。
代码更新20180607：根据评论，之前的代码的确是无法翻译“瑜 琦 钰 奕”这四个字的拼音，原因是他们的码值没有包含在代码中，现在已添加相应代码。谢谢 likewam 的评论。另外，希望大家能把自己使用过程中发现的所有不能转换的汉字都添加到评论，让我们一起来完善这部分代码。
代码更新20180826：使用字典翻译方式把代码重写了，放弃了原先的Ascii码值的方式，几乎涵盖了所有可能出现在Excel中的汉字。
代码更新20180828：感谢网友们的评论。本次更新又补充了6千多汉字，字典汉字总数达到 20830 个。
打开Excel后，需要启用宏功能。
使用Alt+F11打开VBA代码编辑窗口，新增模块，然后在模块中插入如下转换代码
'-------代码段开始-------------
Function pinyin(p As String) As String
'*************************************
'版本说明：转载请保留此段注释
'更新时间：2018年8月28日
'作者：上海五航航空技术有限公司 李晓锋
'感谢：“在线汉语字典”的中文转拼音功能http://xh.5156edu.com/conversion.html，大大的加快了拼音的转换速度。
'说明：本代码几乎包含了Excel表中能够出现的所有汉字（20830个汉字）,去除了无法使用“在线汉语字典”进行转换的和转换后拼音莫名其妙的。
'PS：因为代码全部放到一个过程中会导致单个过程过大，所以拆分成多个子函数来处理。
'*************************************
pinyin = pinyin1(p)
If pinyin = p Then pinyin = pinyin2(p)
If pinyin = p Then pinyin = pinyin3(p)
If pinyin = p Then pinyin = pinyin4(p)
If pinyin = p Then pinyin = pinyin5(p)
End Function
Function pinyin1(p As String) As String
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4d3348b370f1646fe5c3f3920706bd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dce6c7e2ef6d6440e1571466043cdf2/" rel="bookmark">
			Java中Json转换Bean对象并忽略大小写！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import net.sf.json.JSONObject; import net.sf.json.JsonConfig; import net.sf.json.util.JavaIdentifierTransformer; import com.sdzn.vo.ICPostJsonBeanVO; public class test { public static void main(String[] args) { String tString = "{\"FuncName\":\"UploadGroupInfo\",\"ParamNum\":\"1\",\"ParamValue\":\"444\"}"; JSONObject jsonObj1 = JSONObject.fromObject(tString); JsonConfig config = new JsonConfig(); config.setJavaIdentifierTransformer(new JavaIdentifierTransformer() { @Override public String transformToJavaIdentifier(String str) { char[] chars = str.toCharArray(); chars[0] = Character.toLowerCase(chars[0]); return new String(chars); } }); config.setRootClass(ICPostJsonBeanVO.class); ICPostJsonBeanVO p2 = (ICPostJsonBeanVO) JSONObject.toBean(jsonObj1, config); System.out.println("json转化为对象：方法名：" + p2.getFuncName() + ";数量:" + p2.getParamNum() + "值：" + p2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dce6c7e2ef6d6440e1571466043cdf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e560a103799cba57bfe5c11b298bc17d/" rel="bookmark">
			C&#43;&#43;中STL用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 什么是STL？ STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准程序库（C++ Standard Library）中，是ANSI/ISO C++标准中最新的也是极具革命性的一部分。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。
STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但这种分离确实使得STL变得非常通用。例如，由于STL的sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组；
STL另一个重要特性是它不是面向对象的。为了具有足够通用性，STL主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP的三个要素。你在STL中找不到任何明显的类继承关系。这好像是一种倒退，但这正好是使得STL的组件具有广泛通用性的底层特征。另外，由于STL是基于模板，内联函数的使用使得生成的代码短小高效；
从逻辑层次来看，在STL中体现了泛型化程序设计的思想，引入了诸多新的名词，比如像需求（requirements），概念（concept），模型（model），容器（container），算法（algorithmn），迭代子（iterator）等。与OOP（object-oriented programming）中的多态（polymorphism）一样，泛型也是一种软件的复用技术；从实现层次看，整个STL是以一种类型参数化的方式实现的，这种方式基于一个在早先C++标准中没有出现的语言特性--模板（template）。 1.2 STL内容介绍 STL中六大组件：
1）容器（Container），是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；
2）迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；
3）算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；
4）仿函数（Function object）
5）迭代适配器（Adaptor）
6）空间配制器（allocator）
下面我将依次介绍STL的这三个主要组件。
1.2.1 容器 STL中的容器有队列容器和关联容器，容器适配器（congtainer adapters：stack,queue，priority queue），位集（bit_set），串包(string_package)等等。
（1）序列式容器（Sequence containers），每个元素都有固定位置－－取决于插入时机和地点，和元素值无关，vector、deque、list；
Vectors：将元素置于一个动态数组中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速。但是在中部或头部安插元素比较费时；
Deques：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速。但是在中部或头部安插元素比较费时；
Lists：双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针；
（2）关联式容器（Associated containers），元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap；
Sets/Multisets：内部的元素依据其值自动排序，Set内的相同数值的元素只能出现一次，Multisets内可包含多个数值相同的元素，内部由二叉树实现，便于查找；
Maps/Multimaps：Map的元素是成对的键值/实值，内部的元素依据其值自动排序，Map内的相同数值的元素只能出现一次，Multimaps内可包含多个数值相同的元素，内部由二叉树实现，便于查找；
容器类自动申请和释放内存，无需new和delete操作。vector基于模板实现，需包含头文件vector。
//1.定义和初始化 vector&lt;int&gt; vec1; //默认初始化，vec1为空 vector&lt;int&gt; vec2(vec1); //使用vec1初始化vec2 vector&lt;int&gt; vec3(vec1.begin(),vec1.end());//使用vec1初始化vec2 vector&lt;int&gt; vec4(10); //10个值为的元素 vector&lt;int&gt; vec5(10,4); //10个值为的元素 //2.常用操作方法 vec1.push_back(100); //添加元素 int size = vec1.size(); //元素个数 bool isEmpty = vec1.empty(); //判断是否为空 cout&lt;&lt;vec1[0]&lt;&lt;endl; //取得第一个元素 vec1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e560a103799cba57bfe5c11b298bc17d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f48db39a6f7b15bd1f50bb6cb295452/" rel="bookmark">
			Setup Factory打包时实现第三方DLL文件的注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Setup Factory中的如下界面：
红色矩形中的仅仅是用来测试该文件是否是能注册的组件或ocx控件，在安装包安装过程中并不会注册该组件，如需注册，必须按下面步骤进行：
1: 先将需要注册的组件所需的所有依赖库放在安装文件目录中。如果依赖库还依赖了其它库，请排序添加之。也就是
说本步骤就是将所有依赖库按照依赖关系排序添加到安装目录中。更改上图中的优先级中的安装顺序数字虽可保证依赖关系（数字越大的，越后安装）但在安装创建快捷方式这一步时会崩溃（用Setup Factory 9.5测试的），如下所示：
所以还是将所有依赖库按照依赖关系排序添加到安装目录中。
2:然后再放入需要注册的组件。注意：第1步和第2步顺序不能搞反，否则在安装时，该组件注册时，会弹出如下错误：
即LoadLibrary()失败（126）错误（上面我只是随便截了个图，真实错误代码不是14001,而是126）
第1步保证了先安装依赖库，然后再安装需要注册的组件，从而避免了LoadLibrary()失败（126）错误
3. 在Setup Factory的Action页面，On Post Install中，增加以下代码：
Shell.Execute("regsvr32", "open", SessionVar.Expand(" /s \"%ProgramFilesFolder%\\%ProductName%\\XXXX.dll\""));
/s选项表示后台slient安装，不会弹出提示框。%ProgramFilesFolder%这一串字符必须用(\")括起来。
如图所示：
本文转自：http://blog.chinaunix.net/uid-10376640-id-3398980.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1b7aadc84920f5860b44d6385b7f30e/" rel="bookmark">
			百度地图显示的超详细过程介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍百度地图的简单显示的操作步骤，对于详细显示百度地图的定位，检索，路线规划等等，另作文章总结。
一．百度地图的使用 （一）显示百度地图的步骤有下面几步： 下载SDK加入lib中，依赖jar，并且依赖so文件application中添加开发者的key添加权限初始化sdk添加布局，显示视图 其实看起来是挺简单的，但是还是有几个麻烦的地方要去搞，并且上面的步骤最好是一步一步的去执行，完成上一步再做下一步，任何一步遗漏都是无法运行出程序的。
（二）百度地图显示要弄的几个麻烦的地方 1.注册百度账号 2.获得Android应用程序的开发版SHA1（在百度网页中创建百度地图程序用！） 3.申请百度地图的应用程序，获得API_KEY
二．百度地图简单显示的示例 显示效果： 这里在布局中添加几个按钮，通过经纬度定位来确定位置，并显示地图效果： 下面是具体操作步骤
（一）进入百度网页，下载SDK 网址：http://lbsyun.baidu.com/index.php?title=androidsdk/sdkandev-download 下载SDK图解： 选择具体内容，图解： 选择开发包，当然也可以选择示例代码，示例代码里面有简单的示例（包含开发包）。 找到下载的Lib包，解压得到一个libs文件夹，这个文件夹，就是Android百度地图需要用的SDK开发包。 图解： （二）创建Android项目，复制百度地图SDK，依赖文件 1.先创建一个Android的程序，比如这里程序名称是baidumap。 2.打开下载解压后的libs文件夹，把里面的所有文件复制到Studio中的libs文件夹中。 要复制的文件的图解： 3.复制到Studio创建的项目中（Eclipse中使用也是差不多的，这里不做解释）： 4.导入jar文件，右键导入，或者在build.gradle中添加语句： compile files('libs/BaiduLBS_Android.jar') 5.依赖so文件，也是在build中，代码： sourceSets { main { jniLibs.srcDirs = ['libs'] } } 导入jar和依赖so后的图示： （三） application中添加开发者的key 这步需要操作的还是比较多的，并且设计到上面提到的几个麻烦的点。
1.获得开发版SHA1 在AndroidStudio右边找到Gradle（要找程序对应的），点开(图片不够大，右键，新窗口打开) 接下来 发布版的SHA1，在签名打包后会给你的，不过这里可以先不用。 签名打包的方法步骤：http://blog.csdn.net/wenzhi20102321/article/details/54174267 如果是在Eclipse中获取开发版SHA1（里面有讲如何使用cmd命令获取开发版的SHA1）： http://www.th7.cn/Program/Android/201410/297534.shtml
2.在百度中注册百度地图程序，申请密钥： 地址：http://lbsyun.baidu.com/apiconsole/key 创建应用，图解： 填写应用的数据，图解：
点击提交后，生成百度地图的密钥： 3.在Studio地图程序中的application添加密钥： &lt;meta-data android:name="com.baidu.lbsapi.API_KEY" android:value="McaaXKfXugXGWxo7bcYWLZOzd72mAYts" /&gt; 上面的name是不用变的，把value的值替换成你申请到的百度地图的密钥就可以了。 图解（添加百度地图密钥的位置）： 注意：这里百度地图的密钥是根据包名生成的，每个程序都是不一样的，新建程序后又要重新申请密钥，不要使用以前的密钥！
上面的步骤做完后，下面都是比较简单的步骤 其实根据百度地图开发的操作提示步骤一步一步执行就可以了： http://lbsyun.baidu.com/index.php?title=androidsdk/guide/hellobaidumap
（四） 添加权限 &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;uses-permission android:name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1b7aadc84920f5860b44d6385b7f30e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc80bb938e0a6871f4824540258eeb60/" rel="bookmark">
			Activiti 自定义事件监听和邮件通知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Activiti 自定义事件监听和邮件通知 参照Activiti官方文档https://www.activiti.org/userguide/#eventDispatcher
首先，建立我们的需求。即当有任务创建、分配、完成时，邮件通知对应用户。
完成步骤如下：
Activiti为我们提供了事件监听接口– ActivitiEventListener org.activiti.engine.delegate.event.ActivitiEventType提供了各种可以监听到的事件类型
通过对应事件，获取有关联的用户，任务名称等。 public class OwnEventListener implements ActivitiEventListener { @Override public void onEvent(ActivitiEvent event) { System.out.println("Event received: " + event.getType()); if (event.getType() == ActivitiEventType.TASK_CREATED || event.getType() == ActivitiEventType.TASK_ASSIGNED || event.getType() == ActivitiEventType.TASK_COMPLETED) { ActivitiEntityEvent entityEvent = (ActivitiEntityEvent) event; TaskEntity taskEntity = (TaskEntity) entityEvent.getEntity(); MailWrapper.getInstance().sendTaskMail(taskEntity.getOwner(), taskEntity.getAssignee(), taskEntity.getName(), event.getType()); } } 最重要的一步就是强制将ActivitiEvent转换为其sub-interface(ActivitiEntityEvent)，再将获取的Entity强制转换为具体的Entity，最终获取相应信息。
在邮件发送模块，需要构建邮件模版，单例化邮件组件。
public class MailWrapper { private final Logger log = LoggerFactory.getLogger(MailWrapper.class); @Autowired private MailSender mailSender; private MailWrapper() { Velocity.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc80bb938e0a6871f4824540258eeb60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e325dbbb8eda20e871a8e70f5259a575/" rel="bookmark">
			ubuntu export 的作用 添加环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如下三种方法来设置环境变量：
1、直接用export命令： #export PATH=$PATH:/opt/au1200_rm/build_tools/bin 查看是否已经设好，可用命令export查看： [root@localhost bin]# export declare -x BASH_ENV="/root/.bashrc" ....................太多省略 可以看到，环境变量已经设好，PATH里面已经有了我要加的编译器的路径 命令 “PATH=$PATH:路径”可以把这个路径加入环境变量，但是退出这个命令行就失效了。要想永久生效，需要把这行添加到环境变量文件里。有两个文件可 选：“/etc/profile”和用户主目录下的“.bash_profile”，“/etc/profile”对系统里所有用户都有效，用户主目录下 的“.bash_profile”只对这个用户有效。
2、修改profile文件： #vi /etc/profile 在里面加入（文件的最后添加）: export PATH="$PATH:/opt/au1200_rm/build_tools/bin" 3. 修改.bashrc文件： # vi /root/.bashrc 在里面加入： export PATH="$PATH:/opt/au1200_rm/build_tools/bin" 后两种方法一般需要重新注销系统才能生效，最后可以通过echo命令测试一下： # echo $PATH | grep ' keyword ' 看看输出里面是不是已经有了/my_new_path这个路径了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3515b3f54338d2c355eecec4942e03f/" rel="bookmark">
			Spring集成RabbitMQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、所需jar包（maven 依赖）
&lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt; &lt;version&gt;1.6.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; 2、spring 的xml中配置RabbitMQ
&lt;!--配置connection-factory，指定连接rabbit server参数 --&gt; &lt;rabbit:connection-factory id="connectionFactory" username="${RabbitMQ.username}" password="${RabbitMQ.password}" host="${RabbitMQ.host}" port="${RabbitMQ.port}" /&gt; &lt;!--声明多个消息队列 queue --&gt; &lt;rabbit:queue id="queue1" name="queue1" durable="true" auto-delete="false" exclusive="false" /&gt; &lt;rabbit:queue id="queue2" name="queue2" durable="true" auto-delete="false" exclusive="false" /&gt; &lt;rabbit:queue id="queue3" name="queue3" durable="true" auto-delete="false" exclusive="false" /&gt; &lt;!--定义rabbit template用于数据的接收和发送 --&gt; &lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactory" exchange="exchangeTest" /&gt; &lt;!--通过指定下面的admin信息，当前producer中的exchange和queue会在rabbitmq服务器上自动生成 --&gt; &lt;rabbit:admin connection-factory="connectionFactory" /&gt; &lt;!-- 消息接收者 --&gt; &lt;bean id="messageReceiver" class="com.jpxcw.rabbitmq.MessageConsumer"&gt;&lt;/bean&gt; &lt;!-- queue litener 观察 监听模式 当有消息到达时会通知监听在对应的队列上的监听对象--&gt; &lt;rabbit:listener-container connection-factory="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3515b3f54338d2c355eecec4942e03f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33a7ad28b58c81fbd9ccd88e6ee5860d/" rel="bookmark">
			&lt;Principles of fMRI 1&gt;课程笔记8--fMRI的数据预处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚采集的原始图像数据会经过一系列的预处理步骤。这些步骤主要是分辨并去除伪影（Artifact），或者是检验一些模型所需的假设是否成立。具体来说，有三个目的：
尽量减少因为数据采集（Data acquisition）和生理学特性（Physiological）导致的误差我们想检验一下模型的统计假设，并且尽可能的做一些变换让数据符合这些假设将不同个体的数据的脑区位置标准化（Standardize the location of brain region）以便于进行组间分析（Group analysis）。只有这样组间分析才具有较好的效度（Validity）和灵敏度（Sensitivity）。 扫描得到的功能图像和结构图象都要经过预处理。而且预处理的过程中功能图像和结构图像也要经过相互对比计算的。这里有张图显示了我们通常用到的预处理的步骤。
预处理步骤包括：可视化（Visualization）、去伪影（Artifact removal）、时间配准（Slice time correction）、头动校正（Motion correction）、生理噪音校正（Correction for physiological effect）、结构功能配准（Co-registration）、标准化（Normalization）和时空间滤波（Spatial and temporal filtering）。
一、Visualization and Artifact Removal 先来讲讲可视化的去伪影。在任何情况下这都一定是预处理的第一步。我们会探索性的看看刚采集的原始图像数据（Raw imagine data）有哪些问题。找到了问题才知道要用什么模型去去伪影。比如有些时候数据会出现一些异常陡峭的峰波（Spike）或者是缓慢的偏倚（Drift）。有很多种方法，例如主成分分析法（PCA，Principle components analysis），可以用来探测这些异常的峰波。
二、Slice Time Correction 在扫描一次完整大脑（Brain volume）的周期（TR，Repetition time）内，我们会扫好几片脑片（Slice），由于我们一个时间点只能扫描一张脑片，如果是按照顺序一张一张扫下去的话，每张脑片之间的扫面时间点都会有区别。比如最顶端的脑片的扫描时间会相对低端的脑片延迟2s。例如在这张图里。脑片1、2、3分别在不同的时间点上被扫描。如果我们不做时间回归直接处理的话，由于我们采样的时间点不相同，三个脑片的信号看起来很不一样，尽管实际上他们来源于同一个信号。
因此我们需要用插值（Interpolation）等方法来获得三个脑片相同时间点的数据。所谓插值就是通过与未知点相邻的已知点的信号值来预测位置点的值。我们通常用的插值函数类有线性函数和三角函数。当然，你也可以用傅里叶变换。求出傅里叶级数后平移相位就好。（其实个人认为这个就是三角函数插值）
三、Motion Correction 头动（Head motion）也是一个很严重的干扰。我们在做后续分析的时候需要假设每个体素时时刻刻对应的都是大脑的同一个位置。可是扫描的时候被试的头肯定会有微小的移动。这样的话一个体素可能在下一秒就对应了脑中另外一个截然不同的位置。因此我们会用刚性变换（Rigid body transformation）把所有的图像中的脑都固定在同一个靶位置（Target imagine）（我们假设头动过程中脑一直是个刚体）
一个刚体变换包含了六个自由度，即关于X,Y,Z轴三个方向的平移（Translation）以及围绕这三个轴的旋转（Rotation）。
下面这张图说明了以上的几种基本变换，当然有时候我们还可能用到缩放变换（Scaling）和切变换（Shearing）其实还有很多的线性变换可以用的。例如
相似变换（平移，旋转和等比缩放，七个自由度）仿射变换（关于三个轴的平移，旋转，缩放和切变换，12个自由度） 除此之外还有非线性变换（Warping method），即方程对图像的处理是非线性（Nonlinear）的。
不管怎样我们变换的最终目的是使处理过的图像与靶图像尽量的重合。我们会有一个代价函数来描述处理过的图像与靶图像的相似度和重合度。例如我们可以使用所有体素数据值的差的平方和或者互信息（Mutual information）（信息论里一种有用的信息度量，它可以看成是一个随机变量中包含的关于另一个随机变量的信息量，或者说是一个随机变量由于已知另一个随机变量而减少的不肯定性）。
一般来说靶图像选取的是第一张图像或者所以图像关于时间的平均图像（Mean imagine）。
例如这张图，我们有一个靶图像，还有一个等着我们变换的图像（Input imagine）。我们希望经过一些列的平移很旋转使蓝色的大脑和绿色的重合在一起。这就是头动校正。
注：软件计算出的旋转角度和平移距离的曲线，横坐标是输入图像（Input imagine）的序号（按时间排列）
四、Co-registration 接下来的事情就是结构图像与功能图像配准（Co-registration）了。我们希望能把功能图像上的点定位在有着较高分辨率的结构图像上。
虽然我们分析的是较低分辨率的功能图像，但当我们将其定位在结构图象上时，我们可以发现一些更细节的问题。配准也为我们之后要讲到的标准脑（Standard coordinate system）提供了很大的帮助。
一般来说我们会在实验的每轮扫描的开始扫一张结构图像。虽然说结构图像和功能图像是在同一论扫描里扫得的。但往往它们往往是没法重合覆盖在一起的。一是因为他们测量不是一个东西（编者注：一个是组织一个是血流信号），二是因为测量过程中会有头动。
结构图像和功能图像有这么几个区别：
信号的数量级不一样，没法直接对比形状不一样。至少要用仿射变换才能配在一起。在这里我们一般使用Mutual Information 来作为代价函数 注：软件SPM算出的配准变换方式。
下图 1是预处理的流程，可以看到不仅功能像需要进行预处理，实验前获得的结构像也需要进行预处理。在上个模块中我们讨论了寻找尖峰伪影（spike artifacts），扫描层时间校正（slice time correction），头动校正（motion correction），以及结构像和功能像的配准（co-registration）。 图 1 fMRI数据预处理流程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33a7ad28b58c81fbd9ccd88e6ee5860d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca103da26b1941d530c424be6d165a41/" rel="bookmark">
			在Eclipse下使用Maven开发Spring Boot应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍在Eclipse下使用Maven开发Spring Boot应用。 1、创建Maven工程 打开Eclipse，点击File-&gt;New-&gt;Other,在弹出对话框中，选中Maven Project。 点击Next按钮，出现下图，根据自己需要设置，可以使用默认的。 再点击Next按钮，出现下图，选中图中背景为蓝色的项。 再点击Next按钮，设置Group Id和Artifact Id，其他项可以不用设置。 点击Finish按钮，完成项目的创建。
2、编写pom.xml 在parent部分使用spring-boost-starter-parent。spring-boost-starter-parent是重要的默认的父工程，它提供了dependency-management部分。
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.3.RELEASE&lt;/version&gt; &lt;/parent&gt; 如果我们向pom.xml添加spring-boot-starter-web依赖（在parent这部分之后）：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 此时pom.xml如下图所示： 编写完后，右键项目选择Maven-&gt;Update Project(如项目无报错，则不需要)。创建Java的Source Folder，结构如下图： 如果出现无法新建文件问题，解决方法见： 解决Eclipse建立Maven项目后无法建立src/main/java资源文件夹的办法
3、测试Spring Boot 应用 在src/main/java目录下，新建一个com.neon.apple包，然后在包下面新建一个类。
package com.neon.apple; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @EnableAutoConfiguration public class AppleApplication { @RequestMapping("/") String home() { return "Hello World!"; } public static void main(String[] args) { SpringApplication.run(AppleApplication.class, args); } } 启动程序，右键AppleApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca103da26b1941d530c424be6d165a41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61e246a7927a576e2266e544d4640858/" rel="bookmark">
			Erasure Code - EC纠删码原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Erasure Code - EC纠删码原理 一、什么是Erasure Code Erasure Code（EC），即纠删码，是一种前向错误纠正技术（Forward Error Correction，FEC，说明见后附录），主要应用在网络传输中避免包的丢失， 存储系统利用它来提高 存储 可靠性。相比多副本复制而言， 纠删码能够以更小的数据冗余度获得更高数据可靠性， 但编码方式较复杂，需要大量计算 。纠删码只能容忍数据丢失，无法容忍数据篡改，纠删码正是得名与此。 EC的定义：Erasure Code是一种编码技术，它可以将n份原始数据，增加m份数据，并能通过n+m份中的任意n份数据，还原为原始数据。即如果有任意小于等于m份的数据失效，仍然能通过剩下的数据还原出来。 目前，纠删码技术在分布式存储 系统中的应用主要有三类，阵列纠删码（Array Code: RAID5、RAID6等）、RS(Reed-Solomon)里德-所罗门类纠删码和LDPC(LowDensity Parity Check Code)低密度奇偶校验纠删码。 RAID是EC的特殊情况。在传统的RAID中，仅支持有限的磁盘失效，RAID5只支持一个盘失效，RAID6支持两个盘失效，而EC支持多个盘失效。
EC主要运用于存储和数字编码领域。例如磁盘阵列存储（RAID 5、RAID 6），云存储（RS）等。 LDPC码也可以提供很好的保障可靠性的冗余机制。与RS编码相比，LDPC编码效率要略低，但编码和解码性能要优于RS码以及其他的纠删码，主要得益于编解码采用的相对较少并且简单的异或操作。LDPC码目前主要用于通信、视频和音频编码等领域。 本文主要讲解RS类纠删码。 二、Reed-Solomon Code
RS code是基于有限域的一种编码算法，有限域又称为Galois Field，是以法国著名数学家伽罗华（Galois）命名的，在RS code中使用GF(2^w)，其中2^w &gt;= n + m。 RS code的编解码定义如下： 编码：给定n个数据块（Data block）D1、D2……Dn，和一个正整数m，RS根据n个数据块生成m个编码块（Code block），C1、C2……Cm。
解码：对于任意的n和m，从n个原始数据块和m个编码块中任取n块就能解码出原始数据，即RS最多容忍m个数据块或者编码块同时丢失。 RS编解码中涉及到矩阵求逆，采用高斯消元法，需要进行实数加减乘除四则运算，无法作用于字长为w的二进制数据。为了解决这个问题， RS采用伽罗华群GF（2^w）中定义的四则运算法则。 GF(2^w）域有2^w个值， 每个值都对应一个低于w次的多项式， 这样域上的四则运算就转换为多项式空间的运算。 GF(2^w)域中的加法就是XOR， 乘法通过查表实现，需要维护两个大小为2^w -1的表格: log表gflog，反log表gfilog。 乘法公式： a * b = gfilog(gflog(a) + fglog(b)) % (2^w -1) 1、RS code编码原理 RS编码以word为编码和解码单位，大的数据块拆分到字长为w（取值一般为8或者16位）的word，然后对word进行编解码。 数据块的编码原理与word编码原理相同，后文中一word为例说明，变量Di, Ci将代表一个word。 把输入数据视为向量D=(D1，D2，.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61e246a7927a576e2266e544d4640858/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df121a8bcc9a3282e37c292c1f2af535/" rel="bookmark">
			Spring Data REST入门（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Data REST（一）：两行代码搞定RESTFul
一、环境搭建
创建Maven项目，添加相应依赖 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!-- 引入spring data rest --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 引入JPA --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 测试环境数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 这里采用最简单的方式Spring Boot集成 Spring Data REST，并引入h2数据库作为测试数据库，使用Spring Data Jpa的默认配置为数据持久层，顺便提一句Spring Data Jpa的默认实现为Hibernate。
2. 创建实体类
@Entity public class User { /** * 指定id为主键，并设置为自增长 */ @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @GenericGenerator(name = "increment", strategy = "increment") private long id; private String name; private String password; private int age; private boolean sex; public long getId() { return id; } public void setId(long id) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df121a8bcc9a3282e37c292c1f2af535/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5d06d4209a7559e8add8d7185811287/" rel="bookmark">
			LaTex 加粗（加黑）的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 基本 LaTeX技巧458：关于LaTeX数学字体加粗
$\mathbf $，会变为粗体，但也导致数学字母斜体形式的丢失；使用 amsmath package 的 \boldmath 命令；
\boldmath $f(x,y) = 3(x+y)y / (2xy-7)$ \unboldmath使用包，
使用 bm package 的 \bm 命令；
\usepackage{amsmath, bm} $\bm{f(x,y) = 3(x+y)y / (2xy-7)}$ 2. emph vs. em \documentclass{article} \begin{document} abc\emph{lll}lll \textit{lll}llll abc{\em lll}lll {\itshape lll}llll abc{\em lll\/}lll %\emph{abc\par bc} error {\em abc\par bc} \end{document} 这里是 article 的文档类，因此字母默认是正体， 3. 希腊字母的加黑 方案一、用\usepackage{amsmath}
\boldsymbol{\sigma} \mathbf 只对公式中的普通字母ABC…abcdef等起作用。
方案二、更好的方法是使用\usepackage{bm}
\bm{}来加粗。
转载于:https://www.cnblogs.com/mtcnn/p/9422373.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81bdfc298d8c95a9f834ebe5a7946c6a/" rel="bookmark">
			JavaMail邮件发送不成功的那些坑人情况及分析说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 JavaMail的使用本身并不难，网上有不少案例，简单易懂，而且有详细的中文注解。但是由于JavaMail的机制设置不够完善，特别是异常出错时的参考信息太少，给初学者造成了不少麻烦，而我就是其中之一。在此，把我遇到过得那些坑总结出来，以免大家重蹈覆辙，浪费时间。（注：后续还有遇到新的问题，我会持续更新到这里）
一、JavaMail概述 JavaMail是由Sun定义的一套收发电子邮件的API，不同的厂商可以提供自己的实现类。但它并没有包含在JDK中，而是作为JavaEE的一部分。 厂商所提供的JavaMail服务程序可以有选择地实现某些邮件协议，常见的邮件协议包括：
SMTP：简单邮件传输协议，用于发送电子邮件的传输协议；
POP3：用于接收电子邮件的标准协议；
IMAP：互联网消息协议，是POP3的替代协议。
这三种协议都有对应SSL加密传输的协议，分别是SMTPS，POP3S和IMAPS。除JavaMail服务提供程序之外，JavaMail还需要JAF(JavaBeans Activation Framework)来处理不是纯文本的邮件内容，这包括MIME（多用途互联网邮件扩展）、URL页面和文件附件等内容。下图描述了JavaMail的体系结构。
（图片来源：http://blog.csdn.net/t12x3456...）
mail.jar：此JAR文件包含JavaMail API和Sun提供的SMTP、IMAP和POP3服务提供程序；
activation.jar：此JAR文件包含JAF API和Sun的实现。
（有关JavaMail的介绍我只摘要部分，详细介绍请参考：http://blog.csdn.net/zapldy/a...）
二、各种问题及分析说明 后面列举出来的报错信息需要开启Session的debug模式，具体配置方式如下：
Session sendMailSession = Session.getInstance(pro, authenticator); sendMailSession.setDebug(true); 1、后台显示邮件发送成功但未收到邮件 问题现象 使用新浪邮箱发送邮件，尝试两种邮件发送方式，分别是“A@sina .cn发送给A@sina .cn”和“A@sina .cn发送给B@sina .cn”，摘要部分后台打印信息：
250 ok queue id 355937395546 QUIT 221 smtp-5-121.smtpsmail.fmail.xd.sinanode.com Sent message ***@sina.cn successfully.... 使用163邮箱发送邮件，尝试C@126.com发送给A@sina .cn，摘要部分后台打印信息：
250 Mail OK queued as smtp7,C8CowADnDNooqmNYHWsYGw--.30359S3 1482926655 QUIT 221 Bye Sent message ***@sina.cn successfully.... 登录新浪邮箱确认有smtp服务且处于开通状态，也尝试重新开启smtp服务，仍然邮件发送不成功。网上也有不少人反馈用手机客户端无法使用新浪邮箱发送邮件，随后我尝试用foxmail登录新浪邮箱，也出现只能接收邮件而不能发送邮件的情况。
问题分析 基本确定是新浪邮箱问题，至于是smtp服务问题，还是做什么限制就不清楚了。好像平时也没多少人用新浪邮箱发邮件，通过网页登录也是能发邮件的，凑合能用，毕竟是免费邮箱嘛。
这是用JavaMail发送邮件遭遇的第一个问题，案例都是参考别人原封不动拿过来用的，却发了收不到邮件。换了几个参考案例，问题现象相同。我开始怀疑别人给的案例代码问题，毕竟堂堂的新浪邮箱还不至于这么不靠谱。然后，就是基于这样的判断，我就吃了大亏，一直在分析代码和配置方式，也在各大论坛搜“发送邮件成功却收不到邮件”，发现出现问题的不在少数，而且多半给出的建议是检查代码有没有问题，然后提问的人也没了回复下文，这就导致了很大的误导性。这正是因为这个原因，我也白白地耗了好几天时间，直到最后发现原来原因是这么简单...有时别人的解答能够事半功倍，但是这种依赖性还是不靠谱的，有时自己的排错思路更重要。
2、向新浪邮箱发信被退信 问题现象 平时开发测试，不想用私人常用邮箱，于是注册了搜狐邮箱，并尝试向新浪邮箱发送邮件，不过很快搜狐邮箱收到退信（这种情况JavaMail是不会提示判断信息的），退信内容如下：
&lt;A@sina .cn&gt;: host freemx1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81bdfc298d8c95a9f834ebe5a7946c6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8602ad6300cee75a0cfa190e1d423eb9/" rel="bookmark">
			Spring Data REST入门（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Data REST入门（一）
Spring Data REST入门（二）
Spring Data REST入门（三）
Spring Data REST入门（四）
什么是Spring Data REST
Spring Data REST是基于Spring Data的repository之上，可以把 repository 自动输出为REST资源，目前支持Spring Data JPA、Spring Data MongoDB、Spring Data Neo4j、Spring Data GemFire、Spring Data Cassandra的 repository 自动转换成REST服务。注意是自动。简单点说，Spring Data REST把我们需要编写的大量REST模版接口做了自动化实现。举个例子，比如你写了如下代码 @RepositoryRestResource(path="user") public interface UserRepository extends JpaRepository&lt;User, Long&gt;{	} 自定了一个接口UserRepository 继承了JpaRepository，其中泛型中的User是实体类，Long是主键类型，在类的头部加上了一个 @RepositoryRestResource注解，并添加了一个Path为user。两行代码即可实现User实体类的RESTFul风格的所有接口，比如发送GET请求到127.0.0.1/api/user，返回JSON格式的数据集合(注："api"为统一前缀)，并且每个Item都提供了相应的Detail URI
简单分页查询127.0.0.1:8080/api/user?page=2&amp;size=2
这里简单的传入了页码也页数，Spring Data REST为我们自动做了分页功能，是不是很炫？还没完，注意下半部分红框圈住的内容，这里Spring Data REST 还为我们返回了上一页，下一页，以及最后一页的URI。然而到目前为止你只写了两行代码，而且Spring Data REST的功能还不止如此，这里只是简单展现下Spring Data REST的魅力而已。
2. Spring Data REST本身是一个Spring MVC的应用
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;white.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8602ad6300cee75a0cfa190e1d423eb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd9729d479669d89cb6c439fa9ea5a9e/" rel="bookmark">
			css引入方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.CSS的引入方式 1.内部引用，在html文档中在
&lt;style type="text/css"&gt; div{ /*width: 300px;*/ height: 200px; background: blue; } &lt;/style&gt; 2.外部引用，用标签引用外部的css文件，将样式引用到html文档来。
&lt;link rel="stylesheet" type="text/css" href=""&gt; 3.在标签中使用，使用style属性将当前的标签样式改变。
&lt;div style="color: red"&gt;&lt;/div&gt; 二.div除了可以声明id来控制，还可以声明什么控制 div除了用ID赋予它一个名称外，还可以用class来赋予它一个名称。 还可以不用赋予它一个名字，直接用style来直接设定它的样式。 唯一区别就是ID是唯一的，只能用一次。反而CLASS是可以反复使用的，可以多个div同时时候class来定义样式。 一般JS中常用ID，因为JS是获取div名字来进行判断的，也是唯一判断，如果用class会出错，如果我们写普通html，用class会好些哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9ea2ebed2506a25edd1e97f9e4f2a41/" rel="bookmark">
			环境配置_解决win10安装office 出现“the setup controller has encountered a......”而且找不见Office Setup Controller文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Setup Error
the setup controller has encountered a problem during install. Please review the log files for further informatin on the error. 在给学院老师修理电脑的时候，win10上office 2007安装好后会出现上边所描述的“Setup Error”错误，网上找到了两种方法，不过都不能用，后来终于解决了！解决方法其实非常简单，如下：
修改目录的方法
针对Office 2010就直接将
C:\Program Files\Common Files\Microsoft Shared\OFFICE14\Office Setup Controller目录改名或者删除
针对Office 2007，那就是
C:\Program Files\Common Files\Microsoft Shared\OFFICE12\Office Setup Controller目录改名或者删除
不要着急，通过上边的方法你会发现，你根本就找不到你想要删除或者改名的文件夹，那是因为标红目录名可能为Program Files（x86），再按照后边的路径进去找，就能找到相应的文件；但是！你改名后发现还是会出现同样的问题，可当你删除这个文件夹的时候，就不会出现这个问题了，所以直接删除是最好的选择，因为重命名没用。
Program Files:64位操作操作系统中存放系统文件（即通常的C:\Program Files和C:\Windows\System32)
Program Files(x86):存放32位同名系统文件（C:\Program Files (x86)和C:\Windows\SysWoW64）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f33c0b485169a296ba17e28bd6a66e81/" rel="bookmark">
			VS Code折腾记 - (2) 快捷键大全，没有更全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 VSCode的快捷键继承了一些IDE风格，有VS的身影，也有Emacs的身影。。简言之，内置快捷键玩熟了，效率提高不是一点两点。
VsCode 快捷键有五种组合方式（科普） Ctrl + Shift + ? : 这种常规组合按钮Ctrl + C Ctrl +V : 同时依赖一个按键的组合Shift + V C : 先组合后单键的输入Ctrl + Click: 键盘 + 鼠标点击Ctrl + DragMouse : 键盘 + 鼠标拖动 通用快捷键 快捷键作用Ctrl+Shift+P,F1展示全局命令面板Ctrl+P快速打开最近打开的文件Ctrl+Shift+N打开新的编辑器窗口Ctrl+Shift+W关闭编辑器 基础编辑 快捷键作用Ctrl + X剪切Ctrl + C复制Alt + up/down移动行上下Shift + Alt up/down在当前行上下复制当前行Ctrl + Shift + K删除行Ctrl + Enter在当前行下插入新的一行Ctrl + Shift + Enter在当前行上插入新的一行Ctrl + Shift + \匹配花括号的闭合处，跳转Ctrl + ] / [行缩进Home光标跳转到行头End光标跳转到行尾Ctrl + Home跳转到页头Ctrl + End跳转到页尾Ctrl + up/down行视图上下偏移Alt + PgUp/PgDown屏视图上下偏移Ctrl + Shift + [折叠区域代码Ctrl + Shift + ]展开区域代码Ctrl + K Ctrl + [折叠所有子区域代码Ctrl + k Ctrl + ]展开所有折叠的子区域代码Ctrl + K Ctrl + 0折叠所有区域代码Ctrl + K Ctrl + J展开所有折叠区域代码Ctrl + K Ctrl + C添加行注释Ctrl + K Ctrl + U删除行注释Ctrl + /添加关闭行注释Shift + Alt +A块区域注释Alt + Z添加关闭词汇包含 导航 快捷键作用Ctrl + T列出所有符号Ctrl + G跳转行Ctrl + P跳转文件Ctrl + Shift + O跳转到符号处Ctrl + Shift + M打开问题展示面板F8跳转到下一个错误或者警告Shift + F8跳转到上一个错误或者警告Ctrl + Shift + Tab切换到最近打开的文件Alt + left / right向后、向前Ctrl + M进入用Tab来移动焦点 查询与替换 快捷键作用Ctrl + F查询Ctrl + H替换F3 / Shift + F3查询下一个/上一个Alt + Enter选中所有出现在查询中的Ctrl + D匹配当前选中的词汇或者行，再次选中-可操作Ctrl + K Ctrl + D移动当前选择到下个匹配选择的位置(光标选定)Alt + C / R / W不分大小写/使用正则/全字匹配 #多行光标操作于选择
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f33c0b485169a296ba17e28bd6a66e81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a7bcce002f295dc3e1c821a4861cf44/" rel="bookmark">
			MySQL中的BLOB与TEXT类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BLOB与TEXT都是为存储大量字符串类型的数据而设计的，BLOB采用二级制方式存储，TEXT采用字符方式存储。
TypeBLOBTEXT1TINYBLOBTINYTEXT2SMALLBLOBSMALLTEXT3BLOBTEXT4MEDIUMBLOBMEDIUMTEXT5LONGBLOBLONGTEXT BLOB与TEXT唯一的区别就是正如前面所述，BLOB是二进制数据，TEXT是字符数据，而且BLOB没有排序规则，而TEXT有排序规则。
MySQL对BLOB和TEXT有专门的排序方式，它指对每列的最前max_sort_length字节进行排序，而不是整个字符串。而且MySQL也不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee84d10b0312cbac068fd7d0f463dbda/" rel="bookmark">
			div&#43;css图片列表布局（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端切图的时候经常会遇到图片布局，初学者可能会比较生疏。接下来我会以3行3列的图片列表为列子介绍两种常用的切图方案：
float布局display:inline-block布局 首先来讲float布局的方法
float布局 非常简单，一般我会使用ul li布局
&lt;ul&gt; &lt;li&gt;&lt;img src="./images/1.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./images/2.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./images/3.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./images/4.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./images/5.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./images/6.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./images/7.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./images/8.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./images/9.jpg"&gt;&lt;/li&gt; &lt;/ul&gt; 然后给每个li元素定一个宽度并向左浮动。这里每行要显示3张图片，那么每张图片的宽度可以使用百分比来计算：100/3=33.3%。
li { list-style: none; float: left; width: 33.3%;/*三列图片排列*/ } 每个img标签的宽度设为100%，占满整个li的宽度，为了防止图片变形，高度自适应
li { list-style: none; float: left; width: 33.3%;/*三列图片排列*/ } li img { width: 100%; } 好了，咱们来看看效果。
怎么和我们想的不一样？这时候列表是混乱的。别急，这是因为图片的尺寸不一。如果项目中图片的尺寸差别太大的话，建议在父元素定死一个高度，并设置超出隐藏。但是如果图片尺寸差别不大的话，建议设置height: auto;以达到高度自适应的目的。
li { list-style: none; float: left; width: 33.3%;/*三列图片排列*/ height: 100px;/*当图片尺寸不一的时候，设置一个高度*/ overflow: hidden;/*超出隐藏*/ } 嗯~和我们的需求差不多了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee84d10b0312cbac068fd7d0f463dbda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c87fb19de7bbc6fca34a981f8306c648/" rel="bookmark">
			常见数学公式和符号的英文读法大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的数学公式和符号的英文读法，由于有些符号（比如求和符号、根号等）没法正常输入，所以直接上图了。方便有需要的朋友查阅。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/692f9acf9bcb2d63a7732ae2bd2b9521/" rel="bookmark">
			Android中AlarmManager的几个重要方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述：
该类提供一种访问系统闹钟服务的方式，允许你去设置在将来的某个时间点去执行你的应用程序。当你的闹钟响起（时间到）时，在它上面注册的一个意图(Intent)将会被系统以广播发出，然后自动启动目标程序，如果它没有正在运行。注册的闹钟会被保留即使设备处于休眠中(如果闹钟在给定时间响起可以选择是否唤醒设备)。如果闹钟关闭或者重启，闹钟将被清除。
只要广播的onReceive()方法正在执行，这闹钟管理者(AlarmManager)会持有一个CPU唤醒锁，这是为了保证手机不会休眠直到处理完该广播，一旦onReceive()返回，那么闹钟管理者将会释放唤醒锁。这意味着只要OnReceive()方法完成，你的手机可能在某些情况下进入休眠，如果你的闹钟广播接收者调用的是Context.startService()，那么手机有可能在被请求的服务执行之前进入休眠，为了防止这种情况，你的BroadcastReceiver和服务需要实现一个单独的唤醒锁策略以确保手机继续运行，直到服务可用。
此处注意：该类适用于你想让应用程序在将来某个指定时间点执行的情况，即使你的应用程序现在没有运行。对一般的时间操作，使用Handler是更容易和更有效率的。
二、公有方法(Public Methods)：
void cancel(PendingIntent operation) 取消AlarmManager的定时服务。
void set(int type, long triggerAtTime, PendingIntent operation) 设置在triggerAtTime时间启动由operation参数指定的组件。（该方法用于设置一次性闹钟）
void setInexactRepeating(int type, long triggerAtTime, long interval, PendingIntent operation) 设置一个非精确的周期性任务。
void setRepeating(int type, long triggerAtTime, long interval, PendingIntent operation) 设置一个周期性执行的定时服务。
void setTime(long millis) 设置系统“墙”时钟。需要android.permission.SET_TIME.权限。
void setTimeZone(String timeZone) 设置系统的默认时区。需要android.permission.SET_TIME_ZONE.权限。
三、常用方法说明：
AlarmManager的常用方法有三个：
（1）
set(int type,long startTime,PendingIntent pi) 该方法用于设置一次性闹钟。
第一个参数int type指定定时服务的类型，该参数接受如下值：
ELAPSED_REALTIME： 在指定的延时过后，发送广播，但不唤醒设备（闹钟在睡眠状态下不可用）。如果在系统休眠时闹钟触发，它将不会被传递，直到下一次设备唤醒。
ELAPSED_REALTIME_WAKEUP： 在指定的延时过后，发送广播，并唤醒设备（即使关机也会执行operation所对应的组件） 。
延时是要把系统启动的时间SystemClock.elapsedRealtime()算进去的，具体用法看代码。
RTC： 指定当系统调用System.currentTimeMillis()方法返回的值与triggerAtTime相等时启动operation所对应的设备（在指定的时刻，发送广播，但不唤醒设备）。如果在系统休眠时闹钟触发，它将不会被传递，直到下一次设备唤醒（闹钟在睡眠状态下不可用）。
RTC_WAKEUP： 指定当系统调用System.currentTimeMillis()方法返回的值与triggerAtTime相等时启动operation所对应的设备（在指定的时刻，发送广播，并唤醒设备）。即使系统关机也会执行 operation所对应的组件。
第二个参数表示闹钟执行时间。
第三个参数PendingIntent pi表示闹钟响应动作：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/692f9acf9bcb2d63a7732ae2bd2b9521/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1854e7532c7f6a9cdb2d7034f8389cd1/" rel="bookmark">
			邮件：事务失败。 服务器响应为:DT:SPM 163 smtp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几年前我做的一个项目，日发邮件最高峰时几十万。自以为对邮件发送方面已经有了一定认识，所以近期机缘巧合之下，又有项目需要发送邮件，不禁自信满满，暗自庆幸能不手到擒来乎？
不想老革命遇到新问题。我原先的邮件发送机制，是生成eml文件，然后扔到windows自带的smtp服务器的pickup目录下，系统即自动发送（见拙作：邮件发送一点心得）。
但今时今日，这些好像都是老皇历了。IIS7默认并没有SMTP，如果操作系统是server，还可以通过添加功能加上去，但WIN7就不行了。偏偏，我们的系统就部署在WIN7下。
我第一个应对之道是看WIN7能不能装那个自带的SMTP，结果是不行，死活没找到。
第二个办法是装个第三方的SMTP，找来找去，找到一个叫做什么FREE SMTP的，装上去以后，打开看，好像忒简单了点。根本没有啥PICK目录的，应该是只能通过代码，搞什么几次握手之类的方法来进行调用。我很烦这个东西。
最后，决定还是直接使用smtp.163.com。网上例子比比皆是。
public interface IEmail { bool Send(EmailParam param); string Mess { get; } } public class EmailParam { public string From { get; set; } public string To { get; set; }//接收人；多个邮箱用分号隔开 public string CC { get; set; }//抄送；多个邮箱用分号隔开 public string Subject { get; set; }//标题 public string Body { get; set; }//邮件正文 } public class Sender : IEmail { SmtpClient client; public Sender() { // &lt;add key="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1854e7532c7f6a9cdb2d7034f8389cd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50db37f80300d9143b3f8bd02cb90339/" rel="bookmark">
			浅谈服务治理与微服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期都在谈微服务，本人也正在做相关的工作，应领导要求做了一个微服务的分享，本篇文章主要来源于分享的PPT，所以有些简单，有问题可以在下面留言，大家 一起讨论。
本篇文章先简单介绍了互联网架构的演变，进而介绍了服务化，最后再介绍微服务，微服务是服务治理的升级也是互联网架构的进一步延伸。
互联网架构演变 一体架构 在计算机软件发展早期，一般桌面软件都是采用这种架构，不管是界面还是业务处理还是数据处理都放到一个包中。这种其实谈不上架构，但也可以说是很好的架构，因为它足够简单。
mvc架构 但随着浏览器的出现便产生了web应用，web应用的特点是界面部分是显示在浏览器中，服务处理是在服务容器中的，页面显示一般用css+js+html技术来处理，而后端可以用java、php等语言，这就产生了前后端分离。对于web系统，一体架构难以满足前后端分离的开发需求，因而便产生了MVC架构。
MVC才算的上真正意义上的架构，因为它除了解决了前后端分离问题，还引入了一种全新的开发模式，用一种业务逻辑、数据、界面显示分离的方法组织代码，使得整个应用层次更加分明，而且各个层次之间不但减低了耦合性，还提高了各个层次的可重用性。
但随着应用规模的不断扩大，应用模块不断增加，整个应用也显得越来越臃肿，维护起来也更加困难，因此便又产生了多应用架构。
多应用架构 多应用架构很简单，就是把原来的应用按照业务特点拆分成多个应用。比如一个大型电商系统可能包含用户系统、商品系统、订单系统、评价系统等等，我们可以把他们独立出来形成一个个单独的应用。多应用架构的特点是应用之间各自独立 ，不相互调用。
多应用虽然解决了应用臃肿问题，但应用之间相互独立，有些共同的业务或代码无法复用。
分布式架构 对于一个大型的互联网系统，一般会包含多个应用，而且应用之间往往还存在共同的业务，并且应用之间还存在调用关系。除此之外 ，对于大型的互联网系统还有一些其它的挑战，比如如何应对急剧增长的用户，如何管理好研发团队快速迭代产品研发，如何保持产品升级更加稳定等等 。
因此，为了使业务得到很好的复用，模块更加容易拓展和维护，我们希望业务与应用分离，某个业务不再属于一个应用，而是作为一个独立的服务单独进行维护。应用本身不再是一个臃肿的模块堆积，而是由一个个模块化的服务组件组合而成。
服务化 服务化的特点 上面介绍的分布式架构即服务化。我们再总结一下，服务化主要有如下特点：
应用按业务拆分成服务各个服务均可独立部署服务可被多个应用共享服务之间可以通信 服务化的好处 那么企业采用服务化有哪些好处呢？
架构上系统更加清晰核心模块稳定，以服务组件为单位进行升级，避免了频繁发布带来的风险开发管理方便单独团队维护、工作分明，职责清晰业务复用、代码复用非常容易拓展 服务化实现方式 如果要实现服务化的话，最常用的方式就是利用RPC框架。因为服务组件一般分布在不同的服务器上，所以要实现服务化需要解决的第一个问题就是RPC**远程服务调用**。类似于RPC方案有很多，比如：
Java RMIWebServiceHessianHttpThrift… … 服务化面临的挑战 上面提到要实现服务化首先需要解决远程服务调用问题，除此之外，还有很多其他问题需要解决。
服务越来越多，配置管理复杂服务间依赖关系复杂服务之间的负载均衡服务的拓展服务监控服务降级服务鉴权服务上线与下线服务文档… … 服务治理 上面提到了服务化，其实要想服务化，服务治理是关键。那么有没有好的服务治理方案呢？答案是有的，而且很多人都在用这个框架，他就是-dubbo。dubbo就是一个带有服务治理功能的RPC框架。
dubbo提供了一套较为完整的服务治理方案，所以企业如果要实现服务化的话，dubbo 是很好的一个选择。这里简单介绍一下dubbo服务治理相关方案。
服务发现注册 服务治理领域最重要的问题就是服务发现与注册。dubbo中引入了一个注册中心的概念，服务的注册与发现主要就依赖这个服务中心。
dubbo注册中心服务注册发现的具体过程：
服务提供者启动，向注册中心注册自己提供的服务消费者启动，向注册中心订阅自己需要的服务注册中心返回服务提供者的列表给消费者消费者从服务提供者列表中，按照软负载均衡算法，选择一台发起请求 服务监控 集群容错 负载均衡 Random LoadbalanceRoundRobin LeastActive ConsistentHash dubbo服务治理优势 注册中心只负责注册查找，不负责请求转发，压力小注册中心宕机影响消费者，消费者本地缓存服务地址列表注册中心对等集群，宕掉一台自动切换到另外 一台服务提供者无状态，可动态部署，注册中心负责推送统计无压力，本地内存中累计次数，每分钟发送注册中心消费者调用服务者，自动软负载均衡通过服务中心可追踪依赖关系监控中心为扩容和降级提供依据可启用acl机制进行鉴权与Spring整合，接入简单松耦合多种序列化协议支持 dubbo的不足 消费者仍需要依赖配置中心消费者仍需要依赖jar包配置provider提供者文档管理功能缺失无统一入口不支持OAuth2.0内部鉴权不方便管理无外部应用鉴权接口基本裸奔，无法直接对外暴露服务IT治理不方便 微服务 现在很多人都在谈微服务，那么到底什么是微服务呢？这里谈谈我对微服务的理解。
微服务有两个核心：
微：服务的粒度要细，即服务要细化到API服务：提供好服务，要让用户感到好用(要做到这一点很不容易) 上面两个核心总结起来，可以用下面这幅图表示：
从上面这幅图看出，微服务特别简单（好的架构就应该简单），我们把服务再拆分成一个个API，API是一个完整的功能。然后我们把API扔到一个“云上”，然后用户就可以到“云上”获取所有API的服务，这个“云”保证能提供好的服务。
我们可以看到，有了微服务之后，服务对用户来说变得特别简单，而且上面dubbo的不足之处在微服务这里都解决了。使用者不再需要依赖任何jar包，不再需要去注册中心查找服务，不再去做鉴权处理，不用担心服务挂掉，不用担心不会使用服务，所有的问题这个“云”都解决了。这也是微服务的核心之一，提供好服务。
说到这里，大家就应该大体知道该怎么做微服务了，图中的“云”是关键。下面我们就慢慢拨开这朵云。
微服务的实现 微服务的关键是服务网关，所以，上面提到的“云”就是服务网关。要做微服务，我们先定义一下微服务需要具备的特点。
微服务的特点 服务需要再细化成API（服务接口——&gt;服务API）
每个服务由一组API组成以API形式对外提供统一格式的服务使用者无需任何配置，直接调用（http）完整的API文档API服务安全可靠稳定 微服务要解决的问题 上面提到了，dubbo还存在一些问题 ，其实dubbo存在的问题 就是 微服务要解决的问题，这里 再总结一下。当然，dubbo和微服务的侧重点不一样，dubbo侧重于内部接口之间的RPC，而微服务则侧重于对外提供服务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50db37f80300d9143b3f8bd02cb90339/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8300e75e44e08d49992598bd6b051b18/" rel="bookmark">
			python-获取当前工作路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sys.argv[0]
import sys print sys.argv[0]#获得的是当前执行脚本的位置（若在命令行执行的该命令，则为空） 运行结果（在python脚本中执行的结果）：
F:/SEG/myResearch/myProject_2/test.py
os模块
import os print os.getcwd()#获得当前工作目录 print os.path.abspath('.')#获得当前工作目录 print os.path.abspath('..')#获得当前工作目录的父目录 print os.path.abspath(os.curdir)#获得当前工作目录 运行结果：
F:\SEG\myResearch\myProject_2 F:\SEG\myResearch\myProject_2 F:\SEG\myResearch F:\SEG\myResearch\myProject_2
注：argv[0]只是得到的是当前脚本的绝对位置；而os模块中的几种获得路径的方法，得到的是当前的工作目录，如:open('1.txt','r')，则会在当前工作目录查找该文件。即大部分的文件操作都是相对于当前工作路径。
若要改变当前工作路径，可以用：os.chdir(path) 。如os.chdir(E:\Program Files),则大部分的文件操作就会是相对于E:\dir1。fobj = open('Hello.txt')，实际会打开E:\Program Files\Hello.txt文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0204eb6ba85c5d8d5d402d14efa472b5/" rel="bookmark">
			Spring 报错：Error creating bean with name的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java项目编译正常，但在tomcat中发布时，报错，错误信息如下：
严重: Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListener
org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘XXXXX’: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: XXXXXXX; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No matching bean of type [XXXXXX] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}
at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:288)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1120)
原因是在使用@Autowired注解时，找不到相应的类，产生上述问题是因为XXXXX的实现类中没有加相应的注解。
例如DAO层 @Repository 例如Service层 @Service
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0204eb6ba85c5d8d5d402d14efa472b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e62cbfc9f4098325ca172114fb521e9/" rel="bookmark">
			oracle 查看执行最慢 sql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		愤怒的不争 2016-12-22 22:06 查询执行最慢的sql select *
from (select sa.SQL_TEXT,
sa.SQL_FULLTEXT,
sa.EXECUTIONS "执行次数",
round(sa.ELAPSED_TIME / 1000000, 2) "总执行时间",
round(sa.ELAPSED_TIME / 1000000 / sa.EXECUTIONS, 2) "平均执行时间",
sa.COMMAND_TYPE,
sa.PARSING_USER_ID "用户ID",
u.username "用户名",
sa.HASH_VALUE
from v$sqlarea sa
left join all_users u
on sa.PARSING_USER_ID = u.user_id
where sa.EXECUTIONS &gt; 0
order by (sa.ELAPSED_TIME / sa.EXECUTIONS) desc)
where rownum &lt;= 50;
查询次数最多的 sql select *
from (select s.SQL_TEXT,
s.EXECUTIONS "执行次数",
s.PARSING_USER_ID "用户名",
rank() over(order by EXECUTIONS desc) EXEC_RANK
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e62cbfc9f4098325ca172114fb521e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39fc09fd3cd99bf6903d487a8101b404/" rel="bookmark">
			Spring AOP-@doAround学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Around("controllerAspect()") public Object doAround(ProceedingJoinPoint joinPoint) { Object result = null; try { result = joinPoint.proceed(); } catch (Throwable e) { e.printStackTrace(); } return result; } @Around是可以同时在所拦截方法的前后执行一段逻辑
返回值为Object 即切面方法返回值为Object
参数为 ProceedingJoinPoint joinPoint.proceed()为切面方法的执行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81472220edf75568a12e90b092e37aa8/" rel="bookmark">
			事务的并发控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事务的并发控制
9．1 信号量：依赖于程序员；不适当的使
用会死锁。分布式环境中很难
实现，必须保持信号量数据的绝对一
致性。
管程：编译器支持的编程语言结构。
编译器依靠共享内存实现信号量，没
有共享内存，就不能使用管程。
对事务的调度要保证对共享数据
的执行效果与其串行调度等价，
服务器可通过串行访问数据项来
实现串行等价。
锁：串行结构的实现
可串行性（化）：两个事务的全部
冲突操作对应相同的顺序执行。
为保证可串行性，常用的三种并发
控制方法：加锁、乐观并发控
制、时间戳定序。
1 加锁：
当事务完成时解锁，当一数据项
被加锁，则只有加锁的事务可访
问它，其它事务或者等待锁被解
开，或者在某种情况下共享锁。
使用锁会导致死锁，即事务彼
此等待解锁。
2 乐观法：
事务执行到提交前，在允许提交
前，服务器完成一个检查，发现
已完成的操作是否与相同数据项
上的其它并发事务的操作发生
冲突，若冲突，服务器终止它。
3 时间戳定序：
服务器记录读写每个数据项的最
近时间，且对每一操作，要比较
事务的时间戳和数据项的时间戳，
以决定操作是否可立即执行、
或被延迟、被拒绝。
9．2 锁机制
读 读 不冲突
读 写 冲突
写 写 冲突
1 读锁：其它可读，但不能写，
有一个事务即加一个锁；
2 写锁：写之前获得，不能读
或写（再写）；
Lock UnLock 操作
锁的粒度越小，加锁就可以越精确，
也就能实现更大的并行度。
同时，锁的粒度越小，就需要更多的
锁，这样开销也就越大，也
就更容易导致死锁。
9．3 乐观并发控制
基础：在大多数应用中，两客户的事务访问同一数据项的可能性很小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81472220edf75568a12e90b092e37aa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c7c48aeb2b02025806acd1e12cb5498/" rel="bookmark">
			C#如何取硬件标志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System;
using System.Runtime.InteropServices;
using System.Management;
namespace Hardware
{
/// &lt;summary&gt;
/// Hardware_Mac 的摘要说明。
/// &lt;/summary&gt;
public class HardwareInfo
{
//取机器名 public string GetHostName()
{
return System.Net.Dns.GetHostName(); }
//取CPU编号
public String GetCpuID() {
try
{
ManagementClass mc = new ManagementClass("Win32_Processor");
ManagementObjectCollection moc = mc.GetInstances();
String strCpuID = null ;
foreach( ManagementObject mo in moc ) {
strCpuID = mo.Properties["ProcessorId"].Value.ToString();
break; }
return strCpuID;
}
catch
{
return "";
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c7c48aeb2b02025806acd1e12cb5498/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/456/">«</a>
	<span class="pagination__item pagination__item--current">457/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/458/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>