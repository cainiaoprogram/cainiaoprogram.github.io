<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dad624e68b180defc5cd9853d89dfb86/" rel="bookmark">
			Maple 入门常用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在用maple，将有用的东西记在这里，以后可以翻找。
重要参考文献 maple入门经典教程 - 知乎 (zhihu.com)
入门步骤 1 从左到右分别是：文本、命令行、代码块。运行整个文档、运行当前行、停止运行
文本：写了一大段在编译
命令行：实时编译（我喜欢用这个）
2 := 用于定义变量
直接打希腊字母的英文，会直接出现对应希腊字母
或者ctrt+shift+g,然后后面输入的字母即可直接变成希腊字母
下标快捷键：a_ _1，两个下划线即可
3 定义分段函数+绘制分段函数 参考：(19条消息) 1.3 分段函数的图形_maple分段函数绘图_scuxuxz的博客-CSDN博客 4 求自定义的函数在某个位置的值 f:=(t)-&gt;x^2
eval(f,t=2)
则会出现结果 4
5 求伴随矩阵 Adjoint(A)
6 小数显示 evalf (xxxx) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9de629501f3a7f00ccf4fd7c51c6e6b4/" rel="bookmark">
			Linux内核编程Hello World
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. ker_HelloWorld.c程序编写 这里首先给出编写的源代码程序，后面对每行代码进行一一说明。
#include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/init.h&gt; static char * cmd = ""; module_param(cmd, charp, S_IRUGO); static int __init helloworld_init(void) { printk(KERN_ALERT "Hello world module init with cmd %s\n", cmd); return 0; } static void __exit helloworld_exit(void) { printk(KERN_ALERT "Hello world module exit\n"); } module_init(helloworld_init); module_exit(helloworld_exit); MODULE_LICENSE("GPL"); MODULE_AUTHOR("o_o"); MODULE_DESCRIPTION("Hello World Module"); MODULE_VERSION("0.0.1"); MODULE_ALIAS("Hi"); #include &lt;linux/init.h&gt; 包含这个库，在一般的编译器程序中会报错。
原因是因为linux的/usr/include/linux/目录中并没有init.h这个头文件，但是这对我们kernel内核编程时不影响的。
因为后面我们并不是直接使用gcc对该ker_HelloWorld.c文件进行编译。
module_param static char * cmd = ""; module_param(cmd, charp, S_IRUGO); 声明了一个静态字符指针变量 cmd，使用 module_param 宏将其注册为内核参数，charp是一个数据类型，表示字符指针类型，权限为 S_IRUGO，即允许读取。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9de629501f3a7f00ccf4fd7c51c6e6b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b9d365a3a0b74f19f5333ab92339c82/" rel="bookmark">
			qt生成帮助文档过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qt生成帮助文档过程中必须依赖的的几种文件：
.qdoc文件：txt格式，按qt documentation的规范编写的详细信息文档，.qdoc文件一般是总体介绍用的，关于类的documentation规范的详细信息一般都放在.cpp文件中。docmentation中有相关链接关联的语法。
.qdocconf文件：txt格式，用于告诉qdoc.exe具体怎么去根据列出的路径下的.qdoc、.cpp等文件中的documentation标记， 生成.html、manifest.xml以及.hph等文件。
.qhp文件：qt help project文件，xml格式，用于详细记录所有关键字，以及各个关键字之间的联系链接等等。
.qch文档：qt compressed help文件，二进制格式，php文件的压缩形式。
.qhcp文件：qt help collection project 文件，xml格式，用于关联多个qch文件。
.qhc文件：qt help collection文件，二进制格式，qhcp文件的压缩形式。
具体参考：目录-&gt;Qt Help-&gt;The Qt Help Framework
具体文件：qthelp://org.qt-project.qthelp.5120/qthelp/qthelp-framework.html
qt帮助文档生成过程（目录-&gt;QDoc Manual-&gt;Getting Started with QDoc）：
主要参考qt自身的Assistant工具的部分源码内容，这个工具的源码比较独立。位置在：“QtInstallDir\Qt5.12.0\5.12.0\Src\qttools\src\assistant”
Qt Doc部分
1、写出.qdocconf文件，指定要生成doc的路径、生成文件格式、生成路径以及定义属性和变量等等。（目录-&gt;QDoc Manual-&gt;Creating QDoc Configuration Files）
下面是qtassitant.qdocconf文件：
include($QT_INSTALL_DOCS/global/qt-module-defaults.qdocconf) project = QtAssistant description = Qt Assistant Manual examplesinstallpath = assistant qhp.projects = QtAssistant qhp.QtAssistant.file = qtassistant.qhp qhp.QtAssistant.namespace = org.qt-project.qtassistant.$QT_VERSION_TAG qhp.QtAssistant.virtualFolder = qtassistant qhp.QtAssistant.indexTitle = Qt Assistant Manual qhp.QtAssistant.filterAttributes = qt $QT_VERSION tools assistant qhp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b9d365a3a0b74f19f5333ab92339c82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a40fa7d6c2e604a5ece81ef84902c7aa/" rel="bookmark">
			领域驱动设计——DDD的整体设计流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、领域驱动设计的应用 在前面学习分析了DDD的内容和各种技术，就可以在实际应用这种设计方式了。DDD倾向于对业务领域抽象的分离，可以更好的在应用层就展开各种领域设计，由表及里，由外到内。更为重要的是，DDD的模型是贯穿整个软件设计和开发的过程，而不是像以前一样，模型在设计完成了基本就抛弃了。这也意味着，真正把模型设计好并最终实现，就可以从软件的宏观设计到具体实施都有一个整体的驱动模式。
二、设计流程 那么一个DDD的基本设计流程是什么呢？或者说如何去从整体上把握一个DDD设计的过程呢。一般来说，可以分为几步：
1、基础准备
这里包括了一些基础的设计语言（UBIQUITOUS LANGUAGE）和设计模式等知识的学习和应用，当然也包括一些具体的设计工具的使用。另外，最重要的是要有一定的软件设计设计架构基础，否则一些基础的方法都不明白只会让设计更困难。
2、进行整体的分层
一般来说，就是要会把整个设计根据实际情况分为几层，比如常见的UI层、应用层、领域层、数据层等等。
3、领域模型的设计
这是最关键的一步，模型的好坏，直接决定了整个设计的成败，它一般可以用以下的步骤来进行：
a)由实际需求创建一个初步的领域模型，确定相关的基本的模型等概念及其相互关系。对这些领域概念要精确描述不能有模糊的歧义的导向
b)根据具体情况确定需求的软件功能，确定应用层的业务类，进一步提供划分应用层和领域层的职责边界
c)在上述基础上，通过领域建设分析，确定实体、值对象及领域服务等基础组件
d)进一步分析实体等之间的关联，利用各种分析手段及设计原则并综合分析性能取舍，裁剪关联的度和方向
e)确定聚合边界和聚合根，这个需要一个不断的积累经验的过程
f)给聚合根创建仓库，一般情况是一个聚合有一个仓储，重点是设计好相关的接口
g)将设计好的领域模型和实际场景进行对比分析，走查相关缺陷和不足
h)确定采用工厂还是构造函数来创建领域实体或值对象
i)重构模型即在现有的模型基础上查找相关的不足，对一些关联关系、聚合设计等进行反思等等。这是一个不断否定-肯定的过程
4、将DDD的种设计综合运用
根据实际情况，通过边界上下文控制，抽象各种设计模式，不断重构和精练，将模型的优化放到整个生命周期中。
5、实际中不断的反复思考
这有点类似于人们说的玄学了，不断的思考不断的和实际的设计流程印证分析，最终会有一个顿悟的时刻。
三、总结 总体上来说，DDD领域驱动设计至少在国内的公司真正应用的不多。特别是中小公司，对这个基本是不感兴趣的，他们觉得还不如画个漂亮界面更好。这就和城市建设一样，再好的高楼大厦，其实是在优秀的城市设计中承载的。或许，这也可以从另外一个角度解释为什么国内的程序员都很累很卷的原因吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1210da19f327c65137807c07fe7cd688/" rel="bookmark">
			如何解决ESLint和prettier冲突问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：这个冲突问题一般是指在代码编辑器中出现的问题，这里使用的是vscode。
在前端开发中，很多人使用 prettier 作为代码格式化工具，用 ESLint 控制代码风格，以及检查错误。
但是在同时使用 ESLint 和 prettier 的时候，由于代码规则不一样就会发生冲突，发生冲突的原因是：在保存文件时，**ESLint 先修复了代码符合 ESLint 的代码风格，之后 prettier 又格式化了代码，导致代码不符合 ESLint 规则了。**所以代码就会出现 ESLint 的警告或报错提示。
起初想的是把 prettier 规则配置的和 ESLint 一致，但是由于规则不一样，不可能完全兼容。
之后有一个折中的方法，在 vscode 中，如果把保存文件时不格式化文件开启，就不会自定调用 prettier 规则格式化代码了，这样就能符合 ESLint 规范了。
但是还有一个问题是 ESLint 修复主要针对的是 js 和 ts 的代码，对于其他的代码如 html、css 等文件还是得用 prittier，所以这种方法也有局限性。
解决方案1 在 vscode 中安装插件 prettier-eslint 插件，这个插件的工作原理是先使用 prettier 格式化，然后再使用 ESLint 检查和修复，这样就能符合 ESLint 代码风格了。
插件介绍链接：https://marketplace.visualstudio.com/items?itemName=rvest.vs-code-prettier-eslint
插件安装完成后，将此插件设置为工作区或用户中文件类型的默认格式化程序，在 vscode 配置文件中添加以下代码：
{ // 保存时使用 ESLint 修复可修复错误 "editor.codeActionsOnSave": { "source.fixAll.eslint": true }, // 定义一个默认格式化程序, 该格式化程序优先于所有其他格式化程序设置。必须是提供格式化程序的扩展的标识符。 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1210da19f327c65137807c07fe7cd688/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab12355c7bc5ad09170656f0e6436749/" rel="bookmark">
			送书 | 什么是Web 3.0及其用途 - 元宇宙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web 3.0是互联网的第三代，旨在通过分散化的方法使消费者更加掌控他们的内容。在Web 3.0中，网站和应用程序使用大数据和分散式账本技术（DLT）以类似人类的复杂方式处理数据。本文将探讨Web 3.0的演变、它的用途、Web 3.0应用程序和项目示例。
Web 3.0是什么？ 根据蒂姆·伯纳斯·李（Tim Berners Lee）的说法，Web 3.0是“读、写、执行”。它是互联网的第三代，其目标是创建一个更加连接、开放和智能的互联网版本。
Web 3.0使用人工智能（AI）、区块链、增强现实（AR）和虚拟现实（VR）等新技术，创建分散化和高度互动的互联网体验。
据计算机科学家和互联网专家称，这种新的Web交互范式将使人们的在线生活更加简单和直观。
在Web 3.0中，数据将以分散化的方式相互连接。这是从我们当前的互联网一代（Web 2.0）迈出的巨大一步，其中数据主要存储在集中式存储库中。
这意味着，通过可信的中介，人们和组织现在能够交换有价值的信息，并与他们不明确信任的全球同行合作。
随着区块链和比特币的到来，Web 3.0现在更加强调区块链的分散化特性。
Web 3.0 应用 1. 招聘平台 我们都熟悉招聘平台，因为我们目前使用它们来找工作。许多招聘网站允许公司发布需要填补的职位的招聘标准。
同样，在 Web 3.0 中，我们也有寻找工作的平台，但它们都是去中心化的。CryptoTask、Blocklancer 等都是一些例子。
去中心化、远程工作平台的一些优点包括：
低成本
没有中央权威
没有加入网站的限制
加密货币支付
2. 保险和银行 区块链技术有可能彻底改变保险和银行业。
Web 3.0 通过应用区块链的透明性、安全性和可逆性等属性，使银行和保险业的欺诈行为变得不可能。
总的来说，我们可以合理地得出结论，现有的系统功能失调，需要更大的透明度和安全性，才能使用户繁荣。
由于 Web 3.0，记录现在可以存储在区块链上。智能合约也可以自动化大部分不需要人为干预的流程。
使用区块链进行保险和银行业务的一些优点包括：
赋予数字能力的员工权力
银行内部审计无需繁琐
几乎没有欺诈行为
改善客户体验
3. 社交网络 社交网络在我们的生活中非常重要，因为它们改变了我们的交流、参与和建立社区的方式。
现在的社交网络是受限制、受审查和为内部目的服务的。大公司或政府也可以利用社交网络来控制和塑造用户的意见。
然而，由于区块链技术，社交网络将不受限制。任何人，无论他们的位置在哪里，都可以参与。整个景观将随着 Web 3.0 而改变。像 Steemit、Indorse、Sapien Projects 这样的社交网络平台看起来很有前途。
去中心化的社交网络是一个奇妙的概念，可以改变我们的思考、分享和互动方式。
去中心化社交网络的一些优点包括：
通过支付一些资产来赋予用户权力
保护用户的隐私
确保数据不会被收集和被中央机构使用
4. 去中心化存储 去中心化存储是基于在点对点网络中交换文件和数据的想法。去中心化存储具有出色的安全性，因为发送者可以在发送文件之前对文件进行加密。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab12355c7bc5ad09170656f0e6436749/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5567a93c69b374a2de04bea0c6dd58e2/" rel="bookmark">
			华氏温度与摄氏温度用C语言的实现方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针对于C语言的新手，遇到的第一个问题就是华氏温度与摄氏温度的转化问题了，在这里小编讲一下他们之间转化的问题：
1、已知华氏温度，求解摄氏温度的办法： 以下是代码部分：
#include&lt;stdio.h&gt; int main (void) { int celsius,fahr; printf("请输入要转换的华氏度：\n"); scanf("%d",&amp;fahr); celsius=5*(fahr-32)/9; printf("fahr=%d,celsius=%d\n",fahr,celsius); return 0; } 上面的方法当中用到了一个算法，就是华氏温度与摄氏温度的转换公式
c=5*(f-32)/9
2、输入两个最低与最高整数，求出此区间内的华氏和摄氏温度 以下是代码部分：
#include&lt;stdio.h&gt; int main(void) { int fahr,lower,upper; double celsius; printf("enter lower:"); scanf("%d",&amp;lower); printf("enter upper:"); scanf("%d",&amp;upper); if(lower&lt;=upper){ printf("fahr celsius\n"); for (fahr=lower;fahr&lt;=upper;fahr++){ celsius=(5.0/9.0)*(fahr-32); printf("%4d %6.1f\n",fahr,celsius); } } else printf("inyalid values! \n"); return 0; } 在本例当中，我们将摄氏度与华氏度分别输出出来，沿用上面的公式，求解出对应得华氏度。
希望对初学C语言的你有帮助，喜欢小编的文章，可以点关注，小编会持续更新C语言的一些知识点的，当然有不清楚的地方可以在评论区询问小编，小编看到会及时回复你的biu~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b0a2ca5cd850d9b640c526381c327f0/" rel="bookmark">
			minio文件服务器的日常操作（java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java项目结构如下：增加minioConfig配置，服务连接使用minioDto（包含endpoint，accesskey,serectkey）
minioDto代码如下：数据引用，从application.yml中的minio节点获取；
@Data @Component @ConfigurationProperties(prefix = "minio") public class minioDto { private String endpoint; private String accesskey; private String secretkwy; } application.yml中的minio节点如下：
minio: endpoint: http://192.168.0.147:9000 //该地址为minio服务器的9000接口，api使用 accesskey: miniominio secretkwy: miniominio minioConfig代码如下： 此种设置，可以避免直接注册static的情况（static情况时minioDto为null，会造成接口调用失败）
/** * @Description minio客户端单例类 * @Date 2022-07-13 16:37 * @Author xie */ @Component @Data public class MinioConfig { private static final Logger log = LoggerFactory.getLogger(DbUtils.class); @Autowired private minioDto dto; private static MinioClient minioClient; /** * @description: 获取minioClient * @date 2021/6/22 16:55 * @return io.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b0a2ca5cd850d9b640c526381c327f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b343e9ff93ef74b5fd46befef75090c/" rel="bookmark">
			knife4j接口文档导入postman
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到导出的openAPI对应的JSON文件，无法导入postman，提示格式错误；
调整如下，打开json文件
修改如下：增加title，此节点是postman需要的；
3、保存，重新导入即可；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e4f3bf4e644a0ab0d081d8225c86837/" rel="bookmark">
			【专项】113. 路径总和 II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		113. 路径总和 II
给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
叶子节点 是指没有子节点的节点。
示例 1：
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
示例 2：
输入：root = [1,2,3], targetSum = 5
输出：[]
示例 3：
输入：root = [1,2], targetSum = 0
输出：[]
提示：
树中节点总数在范围 [0, 5000] 内
-1000 &lt;= Node.val &lt;= 1000
-1000 &lt;= targetSum &lt;= 1000
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; subpath, TreeNode* root, int targetSum) { if (root == nullptr) { return; } subpath.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e4f3bf4e644a0ab0d081d8225c86837/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2df620778b3a45fb629b984cdf2bd7fc/" rel="bookmark">
			ubuntu18.04 安装 NVIDIA 显卡驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于最近在ignition gazebo中做仿真，发现启动ignition时报错：显卡驱动不支持OpenGL3.3，于是需要在ubuntu18.04中安装支持的显卡驱动.
主要是做一个过程记录，以后可能还会用到。
文章目录 一、查询推荐安装的驱动版本二、安装三、查看显卡驱动是否成功安装 一、查询推荐安装的驱动版本 打开终端执行
ubuntu-drivers devices 直接安装这里系统推荐的版本，推荐安装nvidia-driver-470，因此运行指令
二、安装 通过终端安装，只安装 nvidia 驱动
sudo apt install nvidia-driver-470 #安装470驱动 然后重启计算机。
sudo reboot # 重启电脑 这里看到有人说重启后会遇到黑屏的情况，我这里没有遇到
三、查看显卡驱动是否成功安装 通过终端查看
ubuntu下查看显卡驱动是否成功安装的运行命令：
glxinfo | grep rendering 如果结果是yes，说明显卡驱动已经成功安装。
如果上述指令运行不成功，可能是因为系统里面没有安装mesa-utils，可以直接二进制安装：
sudo apt-get install mesa-utils 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d01979a678ffef5bd82f8767257d1152/" rel="bookmark">
			十道必问的软件测试面试题（含答案解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 （第一个就刷掉一大批人） 有很多“会自动化”的同学来咨询技术问题，他总会问到我一些元素定位的问题。元素定位其实都不算自动化面试的问题。
一般我都会问：你是定位不到吗？通常结果都是说确实定位不到。
做自动化，首先你得保证一点，没有你定位不到的元素，这个你才能做UI自动化。如果有些元素都定位不到，你说你拿什么去点？就好像你的手你的鼠标点不到需要的元素，就没法去操作。
第一个，自动化分为UI自动化与接口自动化
UI自动化又包括APP自动化、H5、小程序等
接口自动化也包括很多，你用什么类型的工具做自动化？HTTP类型接口自动化DUBBO类型接口自动化等
所以这还只是自动化方面。
自动化你怎么去做的自动化运行环境、自动化如何分布式、批量运行如何持续集成这里面问题太多了，给大家简单的看几个典型面试题
大家看一看这十个问题能答出几个？ 1、三种等待时间的区别和场景应用? 强制等待、隐式等待、显示等待。
第一个强制等待：就是说，当我去点击
这是一个输入用户名字的一行代码 当我把这两行代码
放到这里
不管你这个元素，有没有在页面出现我都等3秒，我再去操作它。是强制，命令式的。但是这些往往一般都只用在脚本的调试，不会真正的出现在自动化测试用例中。你想一想，一个用例十行你加了十个，一个等三秒那十个等三十秒，一个用例三十秒是不可取的。
第二个
隐式等待：一般用在什么地方呢？
这个就是隐式等待。
比如说隐式等待它是一个什么样的区别？就是说你不管点哪里它只要写一次就可以了。像time.sleep(3)你每次都要去写，像driver .implicitly_wait( 3)#一次就好了。它每次去点都会等待三秒，那中间这个三秒它在等什么呢？
重点来了，一个页面它可能有非常多的图片，jss、css、img。就是再加载jss的图片，举个例子我想点击搜索按钮
隐式等待的三秒钟就是在等待这个页面的所有js和图片加载出来。就算你搜索按钮出来了，我还要去等js、img加载完成。理解了吗？软件测试全栈内容欢迎来公众号一诺教育软件测试交流学习。那么如果三秒钟之类jss、css没有加载完成我还是不会去点你，这就是一个隐式等待。它虽然很方便但是有瑕疵。
第三个：
那么什么叫显示等待呢？
字面意思就是和隐式等待相反。一个是隐藏的一个是非常明显的，我想要去做什么就做什么，不需要等待。
当这个搜索按钮一显示出来，我马上就去点它。 我不管页面的其他LOGO、图片有没有加载出来，只要我的想要的比如搜索按钮出来了，我就马上去点击它。
这个题目是做自动化测试非常重要也非常基础的问题，所以我把这个问题排在了第一。
这个问题以后被问到，就难不到你了。
听懂了的朋友，点赞支持一波~
2、之前项目做过自动化测试吗?如何推进的? 工资想超过15K，这个问题是必问的！
不要看这个问题很简单？这个问题其实有点难度的。面试官问你有没有做过自动化测试，那么你肯定不能简单的说：额~我做过！
你要告诉面试官，你如何自动化开展到推进。如何推进的非常重要，你如何开始自动化入和推进，咱们不要片面的去回答，会或者不会。
比如你这样回答：我会，之前公司我们的项目接口方面，前端UI方面我是用selenium这个开源框架加上Python基础架构来实现我的自动化来实现的。
实现原理：用一些单元测试框架unittest去组织我们的测试用例，（或者用Pytest）
数据驱动：比如说我们用execl表去做一个数据驱动，然后我们用到一些关键字驱动，还有你在做自动化你遇到哪一些问题，大家一定要准备几个自动化遇到的问题！这个即使你不说，也是必问的！然后就是这些问题你是如何解决的。
给大家分享一个公式：
如何解决这些问题呢
对你公司项目产生了什么样的价值？像我去面试的时候，我就会说成为我们公司的一个固定资产。
不管是开发、产品、运营，都会用到咱们的这个自动化脚本。可以帮我们线上监控，帮我们自动化回归，帮我们造数据，帮我们跑数据，提高了迭代效率，释放了很多人力。
自动化测试有什么用，是对自动化最大的误解。
很多做软件测试的同行，他没有用过确实感受不到。我之前开始做自动化的时候，在一个人工智能的公司。产品上线之前，CTO只问我一句话，能不能上？因为我这边有很多自动化项目已经不停的在回归，然后功能测试也测了。所以功能+自动化结合就能很自信的上线。它校验出了很多隐藏的BUG，很多因为代码提交、新功能的开发产品的BUG。
3、RF框架用过吗?关键字驱动的原理?如何开发系统关键字? 4、selenium的底层核心原理是什么?有没有做过二次封装? 5、requests中的session会话管理的作用是什么? 6、unittest/pytest有什么区别? 7、谈谈你对自动化分层思想的理解? 其实这句话，经常会被写到一些大型招聘网上去。你会自动化而且还要会自动化分层思想。
做自动化和做功能测试一样，那么它分为哪些东西？
第一个：自动化用例它有一个业务层/业务逻辑
比如登录的业务逻辑是什么？
输入用户名-输入密码-点击登录按钮
分层：
业务逻辑
关键字驱动：
业务层的关键字，比如说你登录，那么你要去做其他的用例是不是会用到登录这个关键字。这个业务也封装成一个关键字，你其他的一个用例是不是可以用到它了？那接口，接口之间不是有很多的关联对吧，如果你把下单这些接口弄在一起，退货发货这些弄在一起，这就是一个业务层的关键字。
关键字驱动不仅有业务层，还有逻辑层。比如说你需要用到很多的公共方法，比如说随机数、随机号码、数据库等等。大家都能用到的，就都封装成一个关键字。
二次封装
click()
有时候我们需要根据需求去二次封装。
关键字驱动不仅仅这三层。还有很多东西要分层，很多驱动、第三方的库、日志、页面、图片、报告等等……
数据驱动
配置文件
8、自动化用例在什么环境下运行、如何批量运行? 能对公司真正的产生效益的自动化肯定是成千上万级别的用例。如果没有达到这个级别，收益一定是很小的。既然是机器在运行的，为什么不去覆盖全面呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d01979a678ffef5bd82f8767257d1152/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ad4d9f449bd2eda80d1814672b1781c/" rel="bookmark">
			Mybatis数据库一对一查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，进行一对一查询，首先准备两个mysql数据表
#创建user表用来储存用户个人用户名及密码
CREATE TABLE `user`( `uId` INT(32) PRIMARY KEY AUTO_INCREMENT, `uName` VARCHAR(255) NOT NULL, `uPassword` VARCHAR(255) NOT NULL ); #插入数据： INSERT INTO `user` VALUES (1, 'admin', '35433'); #创建user_information表用来储存用户个人信息
CREATE TABLE `user_information` ( `id` INT PRIMARY KEY AUTO_INCREMENT, `name` varchar(50), `address` varchar(255), `email` varchar(255) , `phone` DOUBLE(60,0), `user_id` INT UNIQUE, FOREIGN KEY (user_id) REFERENCES user(uId) ); #插入数据： INSERT INTO `user_information`(id,name,address,email) VALUES (1, '安娜', '湖南省长沙市', '204854854@qq.com'); 2，在IDEA创建maven项目并命名JavaEE
在项目src/main/java下创建com.three.pojo包
#在pojo包下创建Person类封装属性值及返回成员变量：
package com.three.pojo.person; public class Person { private Integer uId; private String uName; private String uPassword; public Integer getuId() { return uId; } public void setuId(int uId) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ad4d9f449bd2eda80d1814672b1781c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c609982026aa5d997cd4565260ccfe6/" rel="bookmark">
			Android 12 蓝牙适配 Java版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 12.0蓝牙适配 前言正文一、Android版本中蓝牙简介二、新建项目① 配置build.gradle② 配置AndroidManifest.xml 三、打开蓝牙① 打开蓝牙意图② 请求BLUETOOTH_CONNECT权限意图 四、蓝牙扫描① 扫描者② 扫描回调③ 扫描方法④ 执行扫描⑤ 应用不推导物理位置 五、页面显示扫描设备① 蓝牙设备适配器② 显示列表设备 六、适配Android12.0以下设备七、源码 前言 本身已经写过一篇关于蓝牙适配的文章了，不过因为是Kotlin，很多读者看不懂，对此我深感无奈，一开始也没有想过再写Java版本的，但是后面发现看不懂的越来越多了，我意识到不对劲了，因此我觉得再写一个Java版本的。
正文 在Android系统版本中，蓝牙的变化有，但是不多，这里简要说明一下。
一、Android版本中蓝牙简介 Android1.5 中增加了蓝牙功能，立体声 Bluetooth 支持：A2DP [Advanced Audio Distribution Profile]、AVCRP [Audio/Video Remote Control Profile]，自动配对。Android2.0 中支持Bluetooth2.1协议。Android3.0 中能让应用查询已经连接上 Bluetooth 设备的 Bluetooth Profile、音频状态等，然后通知用户。Android3.1 中系统可以通过 Bluetooth HID 方式同时接入一到多款输入设备。Android4.0 中新增支持连接 Bluetooth HDP [Health Device Profile)] 设备，通过第三方应用的支持，用户可以连接到医院、健身中心或者家庭等场合中的无线医疗设备和传感器。Android4.2 中引入了一种新的针对 Android 设备优化的 Bluetooth 协议栈 BlueDroid，从而取代 BlueZ 协议栈。Bluedroid 协议栈由 Google 和 Broadcom 公司共同开发，相对于 BlueZ 协议栈，BlueDroid 提升了兼容性和可靠性。Android4.3 中增加了对低功耗蓝牙的支持，内置支持 Bluetooth AVRCP 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c609982026aa5d997cd4565260ccfe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2ff42ce9f09c5ef34962b516552c072/" rel="bookmark">
			MySQL基本操作语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#------数据库操作------ #切换数据库： USE 数据库名;
#创建数据库： CREATE DATABASE 数据库名;
#删除数据库： DROP DATABASE 数据库名;
#修改数据库： ALTER DATABASE 数据库名;
#查看数据库： SHOW DATABASES;
#------数据表操作------ #查看表结构： DESCRIBE 表名;-- 简化(DESC)
#修改表： -- (1)修改表名：
ALTER TABLE 原表名 RENAME 新表名;
-- (2)修改字段名：
ALTER TABLE 表名 CHANGE 原字段名 新字段名 新数据类型;
-- (3)修改字段的排列位置：
ALTER TABLE 表名 MODIFY 字段A 数据类型 FIRST|AFTER 字段B;
-- (4)添加字段：
ALTER TABLE 表名 ADD 字段名 数据类型;
-- (5)删除字段：
ALTER TABLE 表名 DROP 字段名;
-- (6)修改表的存储引擎：
ALTER TABLE 表名 ENGINE=存储引擎名;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2ff42ce9f09c5ef34962b516552c072/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9fbdb733c257331a8cd367a94c4c488/" rel="bookmark">
			YMatrix 在PSQL命令行设置timing
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-- 在root下切换到mxadmin用户 [root@mdw home]# su - mxadmin 上一次登录：四 3月 23 13:03:29 CST 2023pts/4 上 ********** MatrixDB Administrator ********** The MatrixDB on 5432 is up for 18:20:27 Connect matrixdb with psql postgres ******************************************** -- 复制psqlrc.sample文件到mxadmin目录下并重名.psqlrc [mxadmin@mdw ~]$ cp /usr/local/matrixdb/share/postgresql/psqlrc.sample ~/.psqlrc -- 在.psqlrc文件中追加\timing参数 [mxadmin@mdw ~]$ vim .psqlrc -- -- system-wide psql configuration file -- -- This file is read before the .psqlrc file in the user's home directory. -- -- Copy this to your installation's sysconf directory and rename it psqlrc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9fbdb733c257331a8cd367a94c4c488/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e493ef48da8bb695c3026d73c5d1ac58/" rel="bookmark">
			Pandas中loc和iloc函数（提取某几列或者行的数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		loc函数：通过行索引（列名、行名） 中的具体值来取行数据（如取"Index"为"A"的行）
iloc函数：通过行号（数字）来取行数据（如取第二行的数据）
需要知道：
data['A'] 是选取data表中的列名为A的所有数据，这个只对列有效，对行没有用，因为列有列名，而行没有行名
例如此时，data['a'] 就是错的
一、iloc data.iloc[ A:B ,C:D ]
用法：逗号前面表示的是取哪些行，逗号后面表示取哪些列
例如1：data.iloc[ 0:2 ,1:2 ] # 取第0-2行和1-2列交叉的所有的数据
例如2：data.iloc[ : ,1:2 ] # 取所有行和1-2列交叉的所有的数据
例如3：data.iloc[ : , : ] # 取所有行和所有列的所有的数据
例如4：data.iloc[ : , [1,2,3] ] # 取所有行和第1,2,3列交叉的所有的数据
二、loc 想要得到某行的所有值，只需要data.loc['该行的第一个元素']]，这里是一个[]
想要得到某列的所有值，通过data.loc[: , ['该列的第一个元素']]
例如1：data.loc[ : ,'A' ] # 取列名为A的该列的所有数据
例如2：data.iloc[ 'a':'c' ,'A' ] # 取行号为a、c的列为A的所有数据
data.loc[data['A']==0] # A列中数字为0所在的行数据
1. 利用loc、iloc提取某一行数据 import numpy as np import pandas as pd #创建一个Dataframe data=pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e493ef48da8bb695c3026d73c5d1ac58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/551af55f600cb6692bcf91a6ef67d4f4/" rel="bookmark">
			第一篇：rk1808编译buildroot,增加ros支持问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		突然心血来潮，想在rk1808中跑ros,当前 rk1808跑的是buildroot编译的精简linux系统，也不想换debian9，就开始痛苦的过程…………
在rockchip_rk1808_defconfig文件中增加ros_kinetic.config（这个是按照官方的rk3399编译ros时一样的操作），然后就会遇到经典的问题：
error: option --single-version-externally-managed not recognized 很坑的问题，我卡在这两三天，网上说是安装setuptools,wheel什么的，都没啥用，这个问题是python-empy-3.3.3，在配置时使用setuptools进行安装，但是这个版本的setup.py文件，是使用distutils来安装的，所以要在配置文件python-empy.mk中修改安装方式：
################################################################################ # # python-empy # ################################################################################ PYTHON_EMPY_VERSION = 3.3.3 PYTHON_EMPY_SITE = http://www.alcyone.com/software/empy PYTHON_EMPY_SOURCE = empy-$(PYTHON_EMPY_VERSION).tar.gz PYTHON_EMPY_LICENSE = LGPL-3.0 PYTHON_EMPY_LICENSE_FILES = LICENSE.txt #PYTHON_EMPY_SETUP_TYPE = setuptools PYTHON_EMPY_SETUP_TYPE = distutils $(eval $(host-python-package)) 编译过程中，遇到tinyxml2问题：
[module] calib_xml In file included from calibdb.cpp:26:0: /files/tools/rk1808-tb-96aiot-sdk-codes20200605/rk1808gitgithub/buildroot/output/rockchip_rk1808/build/camera_engine_rkisp-1.0/rkisp/ia-engine/calib_xml/../include/calib_xml/calibdb.h:21:22: fatal error: tinyxml2.h: No such file or directory #include &lt;tinyxml2.h&gt; 提示找不到tinyxml2.h头文件，是由于IS_NEED_COMPILE_TINYXML2为false，不编译tinyxml2组件导致，查找：camera_engine_rkisp.mk文件，
ifeq ($(BR2_PACKAGE_TINYXML2),y) CAMERA_ENGINE_RKISP_CONF_OPTS = \ IS_NEED_COMPILE_TINYXML2=false endif 改成：
ifeq ($(BR2_PACKAGE_TINYXML2),y) CAMERA_ENGINE_RKISP_CONF_OPTS = \ IS_NEED_COMPILE_TINYXML2=true endif pyparsing问题，提示如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/551af55f600cb6692bcf91a6ef67d4f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e290fa2f22b6efa18cc945741456e5ca/" rel="bookmark">
			vscode安装&#43;node.js环境搭建(mac)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：安装vscode 在官网Visual Studio Code - Code Editing. Redefined下载解压即可使用
插件分享：
二：node.js环境搭建(使用终端brew安装最新的nodejs) 可参考：Vue2.0 新手入门 — 从环境搭建到发布 | 菜鸟教程
1、Homebrew ：Mac系统的包管理器，用于安装NodeJS和一些其他必需的工具软件（若已安装则跳过）
brew -v # 可查看是否已经安装Homebrew /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 2、使用homebrew安装node.js
brew install nodejs node -v # 查看node.js版本 3、安装npm (淘宝镜像)
npm install -g cnpm --registry=https://registry.npm.taobao.org 三、node.js环境搭建（手动安装） node.js中文官网：Node.js，可在首页安装最新版
也可以安装指定版本：官网--&gt;下载--&gt;所有下载选项，即可按照个人需要指定版本安装（Index of /dist/）
mac进去选择.pkg文件即可，本人下载的为10.16.3版本，下载后双击安装即可。
node -v # 查看node.js版本 npm install -g cnpm --registry=https://registry.npm.taobao.org # 淘宝镜像 四、在vscode中打开已经下载的vue项目(在码云下载的renren-fast-vue)，以下为个人运行renren-fast-vue时的一些 填坑经验，可忽略。 导入项目，打开终端执行【npm install】，下载前端所需要的组件
使用最新的nodejs时报错：no matching constructor for initialization of 'v8::String::Utf8Value'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e290fa2f22b6efa18cc945741456e5ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c0de81658c15dc50a58ba5bc6fb6a4b/" rel="bookmark">
			新建微信小程序Ts模版构建npm错误 ，没有找到可以构建的 NPM 包，NPM packages not found。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 message： 没有找到可以构建的 NPM 包，请确认需要参与构建的 npm 都在 miniprogramRoot 目录内，或配置 project.config.json 的 packNpmManually 和 packNpmRelationList 进行构建
已按初始化npm，但是构建提示npm包找不到
解决 1、首先 在终端中 确实是先初始化过了
npm init 2、如果已经初始化以后，项目根目录找到project.config.json文件，在setting关键字，里面增加
"packNpmManually": true, "packNpmRelationList": [ { "packageJsonPath": "./package.json", "miniprogramNpmDistDir": "miniprogram/" } ] 注意 ！！！
如果大家配置了 ts 支持，那么只用把下面这段配置删掉，就可以构建了
"useCompilerPlugins": [ "typescript" ], 不得不说微信IDE工具链团队实在是太垃圾了，这么明显的问题一直没发现不修复，社区反馈问题反而怪大家配置错误，然后丢一句 demo 没问题。。。。不信你们自己试试 ts 模板创建的项目能否构建成功？
不知道浪费了国内开发者多少时间！
3、然后在npm安装你想要的包，就可以正常构建了
npm i tdesign-miniprogram -S --production 4、到这一步直接去构建npm
5 、将之前删掉的配置 再加上 然后在编译执行 就可以引入组件库等等插件了
"useCompilerPlugins": [ "typescript" ], 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0690045007281a3c6f33c8209a904c5f/" rel="bookmark">
			linux解压压缩包分卷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux: 解压.z01 zip分卷
第一种方法：
cat a.zip a.z01 a.z02 &gt; b.zip unzip b.zip 第二种方法：
zip -F a.zip --out b.zip unzip b.zip 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/204f5e2e331fd0566d817048ff152259/" rel="bookmark">
			addVars &amp; addVar区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接
addVars添加的决策变量以tupledict存储 注意索引方式
addVars添加的决策变量是多维变量 也可以是一维的
补充：tupledict和tuplelist
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b06233d5798b39870df8199c5cb19f7a/" rel="bookmark">
			计算机网络基础 第二章习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络基础 第二章习题 下列说法正确的是(D ).
A. 信道与通信电路类似，一条可通信的电路往往包含含一个信道
B. 调制是指把模拟数据转换为数字信号的过程
C. 信息传输速率是指通信信道上每秒传输的码元数
D. 在数值上，波特率等于比特率与每符号所含的比特数的比值
选项 D 正确。波特率（baud rate）是指每秒钟传输的信号波形的数量，通常用符号 Bd 表示。比特率（bit rate）是指在数字通信中，每秒传输的比特数，通常用符号 bps 表示。每个符号所含的比特数取决于调制方式。因此，波特率等于比特率与每符号所含的比特数的比值，即：
波特率 = 比特率 / 每符号所含的比特数
其他选项的描述不正确。选项 A 错误，信道可以包含多条可通信的电路。选项 B 错误，调制是指将模拟信号转换为数字信号的过程。选项 C 错误，信息传输速率是指通信信道上每秒传输的比特数，而不是码元数。
影响信道最大传输速率的因素主要有( A ).
A. 信道带宽和信噪比
B. 码元传输速率和噪声功率
C. 频率特性和带宽
D. 发送功率和噪声功率
信道最大传输速率与信道带宽和信噪比密切相关。信道带宽是指信道中可用的频带宽度，它决定了信道中能够传输的信息量。信噪比是指信号功率与噪声功率之比，它反映了信号的质量和信道的干扰程度。信噪比越大，信道中传输信息的可靠性越高，从而可以提高信道的最大传输速率。
(B )被用于计算机内部的数据传输。
A. 串行传输B. 并行传输C. 异步传输D. 同步传输
并行传输是一种在计算机内部广泛采用的数据传输方式，它通过多根导线同时传输多个数据位，从而提高了数据传输的速度和效率。在计算机内部，CPU、内存、外围设备等之间通常采用并行传输方式进行数据传输。
串行传输是一种将数据位逐位传输的方式，它相对于并行传输来说传输速度较慢，但它能够节省线路资源，因此在长距离通信和高速通信领域得到广泛应用。
异步传输和同步传输是针对通信系统而言的，它们与计算机内部数据传输没有直接关系。异步传输和同步传输的区别在于数据的传输方式和时钟同步机制。在异步传输中，每个字符都有其自己的起始和停止位，传输时钟不同步；而在同步传输中，传输时钟同步，数据按照固定的帧结构进行传输。
下列有关曼彻斯特编码的叙述，正确的是( ).
A. 每个信号起始边界作为时钟信号有利于同步
B. 将时钟与数据取值都包含在信号中
C. 这种模拟信号的编码机制特别适合于传输声音
D. 每位的中间不跳变表示信号的取值为0
曼彻斯特编码是一种数字信号编码方式，它将数据和时钟信号结合在一起，每个位周期内都有一个信号变化。两种可能的信号变化分别表示0和1，这种编码方式有利于同步和误码检测。因此，选项B是正确的。
选项A错误，因为曼彻斯特编码中的时钟信号并不是起始边界，而是在每个位周期内都包含一个信号变化。
选项C错误，因为曼彻斯特编码是数字信号编码，不是模拟信号编码，因此并不特别适合传输声音。
选项D错误，因为曼彻斯特编码中每个位周期内都有一个信号变化，因此不存在中间不跳变的情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b06233d5798b39870df8199c5cb19f7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27572bc157f5cbe1fa061a2b93fca914/" rel="bookmark">
			找文献的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：第一个通过关键词进行检索
在 Web of Science里面进行检索
然后找到想要的文章
记得把sort by 选择为日期 然后通过IDO去到SCI-HUB进行下载
2：去知网博士论文的参考文献
3：查找引用文献：到ResearchGate里面进行搜索
4：CCF 中国计算机协会 看会议找论文
5：找到领域的顶级会议论文网址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07a2296856e1ef86cbb19e8cbab150de/" rel="bookmark">
			springboot&#43;mysql&#43;基于Java的学生请销假审批管理系统的设计与实现 毕业设计-附源码130939
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
科技进步的飞速发展引起人们日常生活的巨大变化，电子信息技术的飞速发展使得电子信息技术的各个领域的应用水平得到普及和应用。信息时代的到来已成为不可阻挡的时尚潮流，人类发展的历史正进入一个新时代。在现实运用中，应用软件的工作规则和开发步骤，采用java技术建设学生请假审批管理系统。
本设计主要实现集人性化、高效率、便捷等优点于一身的学生请假审批管理系统，完成首页、用户管理、公告通知、请假申请、请假审批等功能模块。系统通过浏览器与服务器进行通信，实现数据的交互与变更。本系统通过科学的管理方式、便捷的服务提高了工作效率，减少了数据存储上的错误和遗漏。学生请假审批管理系统使用Java语言，采用基于 MVVM模式的spring boot技术进行开发，使用 Eclipse 2017 CI 10 编译器编写，数据方面主要采用的是微软的Mysql数据库来作为数据存储媒介，配合前台HTML+CSS 技术完成系统的开发。
关键词 ：学生请假审批；java技术；Mysql数据库； Abstract
The rapid development of scientific and technological progress has caused great changes in people's daily life. The rapid development of electronic information technology has popularized and applied the application level of electronic information technology in various fields. The advent of the information age has become an irresistible fashion trend, and the history of human development is entering a new era.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07a2296856e1ef86cbb19e8cbab150de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/084b589abe16eef8a9e1f912e6b845f6/" rel="bookmark">
			Visual预训练模型：BEiT、BEiT v2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BEiT: BERT Pre-Training of Image Transformers 基于Image Transformers的双向编码、自监督视觉表征模型，使用Masked Image Modeling(MIM)任务进行预训练。图1为预训练过程。
预训练前，利用discrete variational autoencoder(dVAE)以自编码的方式训练词表大小为8192的“image tokenizer”，以将图片切分为离散的visual tokens。
预训练时，图像有image patches和visual tokens两种表示，首先将图片大小缩放至224x224，以网格法分割成14x14的patches，每个patch的大小为16x16,。随机掩盖部分image patches，即图中灰色的patches替换为[M]，拉平作为视觉Transformer输入，预训练任务是将利用视觉Transformer输出的编码向量，还原掩盖的image patches对应的visual tokens。
Image Patch 使用网格分割法，将224x224的图片分割成14x14的patches，每个patch的大小为16x16。
Visual Token 以dVAE方式训练image tokenizer，模型包含tokenizer和decoder两部分。
Tokenizer q ϕ ( z ∣ x ) q_\phi(\bm z|\bm x) qϕ​(z∣x)将图片像素 x \bm x x映射为离散的tokens z \bm z z，重构目标为 E z ∼ q ϕ ( z ∣ x ) [ log ⁡ p ψ ( x ∣ z ) ] \mathbb{E}_{\bm z\sim q_\phi(\bm z|\bm x)}[\log p_\psi(\bm x|\bm z)] Ez∼qϕ​(z∣x)​[logpψ​(x∣z)]，使用Gumbel-softmax relaxation训练网络参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/084b589abe16eef8a9e1f912e6b845f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9702acea8d61a668b2ef541427998177/" rel="bookmark">
			Redis使用zset和hash实现限流算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础概念 1.1、限流的定义 所谓限流，在软件系统中，就是指限制某个动作在一段时间内的执行次数。
1.2、限流的好处 限流最直接的好处防止高并发情况下因服务器资源过载导致的系统崩溃情况发生，具体来说，限流可以保证使用有限的资源提供最大化的服务能力，按照预期流量提供服务，超过的部分将会拒绝服务、排队或等待、降级等处理。
1.3、限流的分类 限流按照限流的粒度，可以分为单机限流和分布式限流：
单机
应用级限流方式只是单应用内的请求限流，不能进行全局限流。
限流总资源数限流总并发/连接/请求数限流某个接口的总并发/请求数限流某个接口的时间窗请求数平滑限流某个接口的请求数Guava RateLimiter 分布式
我们需要分布式限流和接入层限流来进行全局限流。
redis+lua实现中的lua脚本使用Nginx+Lua实现的Lua脚本使用 OpenResty 开源的限流方案限流框架，比如Sentinel实现降级限流熔断 二、限流实现 2.1、简单限流 使用zset做限流的基本思想就是对于每次行为，都统计出前一段时间发生的行为数，判断当前行为是否过于频繁；
zset中存储的数据结构：
key: userid:actionKey value: nowTs score: nowTs 算法实现：
package main import ( "fmt" "github.com/go-redis/redis" "strconv" "sync" "time" ) type RedisLimiter struct { client *redis.Client key string limit int64 timeout time.Duration lock sync.Mutex } func NewRedisLimiter(client *redis.Client, key string, limit int64, timeout time.Duration) *RedisLimiter { return &amp;RedisLimiter{ client: client, key: key, limit: limit, timeout: timeout, } } func (l *RedisLimiter) Allow() bool { l.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9702acea8d61a668b2ef541427998177/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5e868baead80d2b17337e67d764cad9/" rel="bookmark">
			访问网络服务-Go对IPC的支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		访问网络服务-Go对IPC的支持 文章目录 访问网络服务-Go对IPC的支持一、socket与IPC1.1 IPC（进程间通信）1.2 socket（套接字） 二、Go语言对IPC的支持2.1 socket 的系统调用2.2 Go语言的标准库syscall（1）socket的通信域（2）socket的类型（3）socket实例所用的协议 2.3 Go语言的net代码包（1） `net.Dial`函数（2）`net.DialTimeout`函数 一、socket与IPC socket（套接字）是网络编程中最核心内容之一。
1.1 IPC（进程间通信） IPC（Inter-Process Communication）：进程间通信。因此，IPC这个概念，主要定义的是多个进程之间，相互通信的方法。
主要的IPC（进程间通信）的方法有：系统信号（signal）、管道（pipe）、套接字（socket）、文件锁（file lock）、消息队列（message queue）、信号灯（semaphone，也称为信号量）等。
现存的操作系统都对IPC（进程间通信）提供了强有力的支持，尤其是socket。
1.2 socket（套接字） socket（套接字），是一种IPC（进程间通信）方法。
在众多的IPC方法中，socket是最为通用和灵活的一种：
利用socket进行通信的进程，可以不局限在同一台计算机上；通信的双方无论存在于世界上的哪个角落，只要能狗通过计算机的网卡端口以及网络进程互联，就可以使用socket； 支持socket的操作系统，会对外提供一套API。跑在它们之上的应用程序会利用这套API，就可以与互联网上的另一台计算机中的其它程序、甚至同一个程序中的其它线程进行通信。
二、Go语言对IPC的支持 Go语言对IPC提供了一定的支持：
在Go的os代码包和os/signal代表包中就有针对系统信号的API；os.Pipe函数可以创建命名管道，而os/exec代码包中对另一类管道（匿名管道）提供了支持；Go语言在net代码包中有对socket支持的程序实体； 2.1 socket 的系统调用 例如，在Linux操作系统中，用于创建socket实例的API，就是由一个名为socket的系统调用代表的。这个系统调用时Linux内核的一部分。
所谓的系统调用，可以理解为特殊的C语言函数。它们是连接应用程序和操作系统内核的桥梁，也是应用程序使用操作系统功能的唯一渠道。
2.2 Go语言的标准库syscall 在Go语言标准库的syscall代码包中，有一个与这个socket系统调用相对应的函数。这两者的函数签名是基本一致的，它们都会接受三个int类型的参数，并会返回一个可以代表文件描述符的结果。
func Socket(domain, typ, proto int) (fd int, err error) { if domain == AF_INET6 &amp;&amp; SocketDisableIPv6 { return -1, EAFNOSUPPORT } fd, err = socket(domain, typ, proto) return } syscall.Socket函数本身是平台不想管的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5e868baead80d2b17337e67d764cad9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6c3c5616b7b783c949323d3ee26739e/" rel="bookmark">
			企业微信消息推送（一）接收消息服务器URL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.点击左上角头像，打开微信管理平台 2.创建应用 3.获取五个参数 3.1获取应用的AgentId、Secret 3.2获取企业ID 配置接收消息服务器URL
企业微信限制过多，公司域名所有权检验不通过。采用接收消息服务器URL的方式。
3.3 获取token、EncodingAESKey 4.1 内网穿透、本地开发 先将请求打到公网服务器ngnix、再转发给内网穿透地址，请求Java后端。
免费的内网穿透
一分钟图文快速上手
4.2 企业微信相关 企业微信加解密文档
企业微信加解密官方代码
4.3 IDEA 引入依赖官方代码的jar包 4.4 将官方代码粘贴进项目 4.5 bug： Error:(1, 1) java: 非法字符: ‘\ufeff’ 使用vscode，将UTF-8 BOM文本编码改为UTF-8
编写代码参考的文章
4.6 编写代码 //token public final static String TOKEN = "n5SHOwoXKo9UTQg2zv3Vs2B"; // encodingAESKey public final static String ENCODINGAES_KEY = "wVdvdhBY6EDWG96S7EjU6hg9BR3v7M5SS9a4jK"; //企业ID public final static String CORP_ID = "wwec27f62ca8"; //应用的凭证密钥 public final static String CORPSECRET = "PdDcN-ZjInXNsvNuzlPl55qZrLLVJvDvcIp3wZNt"; @GetMapping("/wei") public void list(HttpServletRequest request, HttpServletResponse response) throws IOException { // 微信加密签名 String msg_signature = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6c3c5616b7b783c949323d3ee26739e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df42231c427c0ab060d524c5220f803f/" rel="bookmark">
			ChatGptAPI中文文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备调用ChatGPT接口，过了一遍官方接口文档，由于没有学过AI相关知识，有些参数和术语还是不太了解，有些单词使用很生僻的意思，翻译的很生硬，先大致翻译一遍，后面再看下手册理解下，回过头来补充下这个API文档，帮助理解。感觉prompt(提示)、Embeddings(嵌入)、Fine-tunes(微调)有点牛逼。
介绍 要安装官方 Python 绑定，请运行以下命令：
pip install openai 要安装官方 Node.js 库，请在 Node.js 项目目录中运行以下命令：
npm install openai 认证 OpenAI API 使用 API 密钥进行身份验证。访问您的API 密钥页面以检索您将在请求中使用的 API 密钥。
**请记住，您的 API 密钥是秘密的！**不要与他人共享或在任何客户端代码（浏览器、应用程序）中公开它。生产请求必须通过您自己的后端服务器进行路由，您的 API 密钥可以从环境变量或密钥管理服务中安全加载。
所有 API 请求都应在 HTTP 标头中包含您的 API 密钥，Authorization如下所示：
Authorization: Bearer OPENAI_API_KEY 请求组织 对于属于多个组织的用户，您可以传递一个标头来指定哪个组织用于 API 请求。来自这些 API 请求的使用将计入指定组织的订阅配额。
curl命令示例：
curl https://api.openai.com/v1/models \ -H "Authorization: Bearer $OPENAI_API_KEY" \ -H "OpenAI-Organization: org-oiD85Cuq7BToDgSamwH7synm" Python 包的示例openai：
import os import openai openai.organization = "org-oiD85Cuq7BToDgSamwH7synm" openai.api_key = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df42231c427c0ab060d524c5220f803f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be2e37dc469aaf481b9b06ec87e3fdd/" rel="bookmark">
			S32K144-Auto SAR MCAL层 ADC驱动模块配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基础知识 ADC大家都不陌生，ADC驱动模块主要负责就是：
1、初始化ADC模块并进行控制；
2、使能/停止触发源进行/关闭模数转换；
3、查询转换状态与结果。
两种转换模式：
①单次转换（One-Shot Conversion）：ADC通道组中每个ADC通道只执行一次转换。
②连续转换（Continuous Conversion）：在启动转换后，ADC通道组将会自动重复进行转换，而不需要再次触发。
两种触发源：
①软件触发（SW-TRIGGER）：ADC通道组通过ADC模块提供的服务来启动/停止转换，其可在上述两种转换模式下使用。说白了就是用API函数来触发。
②硬件触发（HW-TRIGGER）：ADC通道组通过硬件事件（如边沿触发、定时器等）来启动转换，但该方式只能用于单次转换模式。对于S32K系列来说，ADC驱动默认的硬件触发源是MCU内部可配置的PDB模块。
开始配置 新建，进入，一气呵成
ADCGeneral配置 这里的一些ADCGeneral配置有点多，要留意一下。
对了这里是 优先 ，不小心打错了。
AdcHwUnit* ADC的硬件单元配置，进入标签栏，新建，双击进入：
Adc Resolution* ADC采样通道位宽，也就是精度。
AdcChannel* 进入，新建，双击
选好自己要使用的是哪一个通道就好。
但是一般情况下，我们都是以ADC通道组的形式统一配置：
双击进入：
不要忘记把前面你配置的通道，都加到你的通道组里面
API函数 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bcabc833dc8e151ad4f20bbfa791311/" rel="bookmark">
			vue2.x &#43; element-ui提示：找不到node_modules/async-validator/es/index.js文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误提示： no such file or directory, open ‘xx/node_modules/async-validator/es/index.js’
我按照提示确实没有在node_modules找到async-validator文件夹，本来是手动npm install了这个文件，但是发现找不到es文件夹了，所以就干脆又运行了一遍安装element-ui包的命令将这个漏掉的包补上了。
yarn add element-ui 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a6aebf563495e1e9d0218e7bb081ab9/" rel="bookmark">
			Java动态创建kafka并保持连接长期可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、kafka初始化 首先了解下kafka是怎么初始化的，看源码，就可以了解项目启动的时候，它就读取配置文件里面的kafka配置，然后初始化一个KafkaTemplate连接，然后接下来使用kafka推送或监听，就是这一次连接的。读取的主机和端口是在“bootstrap-servers”后面的那一串配置。后面就是一些生产者或者订阅者的一些配置，自己按照想要的连接进行配置就可。这里的重点不在配置文件怎么配置，不明白的朋友可以去查查。
这种方式是最简单且最常用的，但是有些领导就是要追求点刺激，让我们突破常规，要连接两个地址的kafka连接，并且同时可以使用，这时候我们就不能按照常规的配置，就得在代码中自己创建连接了。
二、自己创建kafka连接 既然是两个连接，那么这个连接就是固定的，那我们可以将连接放入配置文件中，然后从配置文件中先获取到连接的主机和端口。在配置文件中就两个String即可，然后在代码中获取。这时候我们写两个config来进行初始化连接，并且让他们别名不一样，这样就可以从随意使用任意一个连接了。
举个例子，其中的一个连接
package com.inphase.mjai.device.config; import org.apache.kafka.clients.consumer.ConsumerConfig; import org.apache.kafka.clients.producer.ProducerConfig; import org.apache.kafka.common.serialization.StringDeserializer; import org.apache.kafka.common.serialization.StringSerializer; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.kafka.annotation.EnableKafka; import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory; import org.springframework.kafka.config.KafkaListenerContainerFactory; import org.springframework.kafka.core.*; import org.springframework.kafka.listener.ConcurrentMessageListenerContainer; import org.springframework.kafka.listener.ContainerProperties; import java.util.HashMap; import java.util.Map; @EnableKafka @Configuration public class KafkaOneConfig { @Value("${spring.kafka.one.bootstrap-servers}") private String bootstrapServers; @Bean public KafkaTemplate&lt;String, String&gt; kafkaOneTemplate() { return new KafkaTemplate&lt;&gt;(producerFactory()); } @Bean KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;Integer, String&gt;&gt; kafkaOneContainerFactory() { ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a6aebf563495e1e9d0218e7bb081ab9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfb89e4679dfc12a0185374256572475/" rel="bookmark">
			立创EDA专业版，修改自带库中的元件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 起因：
在立创商城中选用了一个SMA插头，放置在PCB的边缘，却发现自带库中元件的丝印都跑到板子外边了，看起来非常不爽，于是决定修改一下。
老方法，点击那个小箭头，打开隐藏起来的东西。
在：工程这个目录中找到这个SMA元件 ，并在它身上（就是那个写着KH-SMA-K513的地方）鼠标右键，选择修改封装。
画笔放到“顶层丝印”，删除掉多余的部分。保存。
再次选择这个器件（就是文字变成蓝色），点击刷新按钮，或者右键选择刷新。即可完成修改。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20558a21c0b4664cd34d1bac780e015e/" rel="bookmark">
			关于Windows系统中文件夹的【特殊权限】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在配置文件权限的时候，很多人都会看到权限中有一个特别的权限叫【特殊权限】
如果说一般的权限比方说【修改】，【读取】啥的也都好理解，但这个【特殊权限】是个啥东西？或许很多人并不理解。那为了避免枯燥，这里先把【特殊权限】是个啥先告诉大家。
【特殊权限】说白了就是系统给指定用户的一个便捷，方便用户给自己加入一些相应的权限。其包括勾选上读取权限，更改权限，取得所有权限
如果这里不能理解，那我们就做一个简单的实验
实验准备材料：
①windows虚拟机一台（专业版的，不怕折腾的话自己的本机也是可以，照做的话没什么危害）
②一颗热爱探索的心
实验环境
1.装一台虚拟机（这一步直接省略安装教程，不是省略使用虚拟机！！！）
2.在随便一个盘里创建一个文件夹
3.右击创建的文件夹，点击【属性】，再点击【安全】
4.查看你的登录用户
4.1使用win+r键打开运行
4.2输入whoami
4.3好的，现在看起来并没有打开administrator，那么就继续键入compmgmt，打开计算机管理
4.4 点开本地用户和组，点开【用户】，发现administrator用户图标右下角有一个向下的箭头，鼠标右键单击，选择【属性】
4.5 把【禁用账户】勾掉，不选择，然后单击【应用】，再单击【确定】
4.6 切换用户，登录admin账户
5.选中刚才创建的文件夹，右击【属性】，转到【安全】，就能看到你的administrators用户组的权限应该是完全控制。
6 点击【高级】，进入高级安全设置
7.单击Authenticated Users，单击左下角【禁用继承】
Authenticated Users：已通过认证的用户组
SYSTEM：系统管理用户组
Users：普通用户组
Administrators：管理员用户组
8 弹窗选择第一个
9.分别删除Authenticated Users和users两个用户（的权限）注意：不要把Authenticated和Administrator混了！！！
去除无关变量，减少无关变量对实验的影响
10.单击【确定】保存更改
11.使用命令创建zhangsan和lisi两个user账户
为zhangsan、lisi两个用户设置不同权限，作为对照实验↓
12.回到【高级安全设置】，单击【添加】
13.单击【选择主体】
14.键入zhangsan，然后依次点击一下按键
单击【检查名称】后应该会出现类似这样的改变
15.单击【显示高级权限】
16.将对钩打成这样，然后单击确定（lisi的与zhangsan不一样，lisi的请看第17步）
这时候应该显示zhangsan用户拥有【特殊权限】
17.接下来返回第十二步，为lisi添加权限
这里可以看出两个用户都有全部的读取属性类，但却是不一样的
18.单击确定，保存所有更改
19.切换成zhangsan用户，双击尝试查看该文件夹，提示无权查看内容
20.尝试查看该文件夹的安全属性，发现没有管理员标识，可以更改（提高权限）
21.切换lisi用户，尝试查看该文件夹内容，提示无权限查看
21.尝试查看该文件夹的安全属性，发现无权查看，也就无权更改
总结：特殊权限的实际用途是为了让用户自己设置权限，虽然看起来权限不高，但实际上可以配置到完全控制权限。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43ddacc113509e78a76c398fca372094/" rel="bookmark">
			S32K144-Auto SAR MCAL层 Port/Dio驱动模块配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Port 老规矩，直接新建Port，双击进入
进入PortContainer标签页，新建一个引脚容器
双击进入容器，输入要配置引脚数目
然后进入PortPin标签栏，新建一个引脚
双击进入
这里有几个点需要注意一下：
引脚的PCR值 Pin Contral Register引脚控制寄存器
对于S32K144来说，有五个端口ABCDE，每个端口32个引脚。
举例，PT D 16：32*3+16=112
是否允许上下拉 只有使能之后，才能设置下面的上拉还是下拉
未配置引脚怎么处理？ 一般悬空处理，但考虑到功耗的影响，未使用的引脚均作为输入，内部上拉。
引脚这么多一个一个配置，那得多麻烦，不怕EB里面有直接配置所有未使用引脚的功能：
回到最初的界面：
常用接口函数 DIO DIO Digital Input/Output Driver主要是对微控制器硬件引脚的访问进行了抽象。
说白了，就是没有实际用处，等于在Port外面又套了一层衣服。
所以要注意：Dio模块中涉及的DIO Channel，即单片机引脚（Pin），若要正常使用，必须在Port模块中对该引脚进行属性配置，即配置为GPIO（General Purpose I/O）模式。
配置如下：
老规矩，新建，双击进入：
进入DioPort标签页，新建DioPort，然后双击进入
这个Dio Port Id是这么算的：对于S32K144来说，有五个端口ABCDE，A=0、B=1、C=2、D=3……
所以我们的PTD16，对应端口序号是3。
然后进入DioChannel标签栏下：新建通道
注意这里的Dio Channel Id是通道的ID，和上面的端口ID不是一个东西，比如我们的PTD16，通道ID就是16。
Port代表着端口，ABCDE……
Channel代表着通道，1234567……
总结 如果说Port是配置了每一个引脚的功能状态，那么Dio更像是给每个引脚取一个名字，并给它们下发指令，比如让他们变成高电平，或者低电平，或者翻转。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0501b20e220f66ac4fce6d799268719/" rel="bookmark">
			STM32串口发送字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在STM32串口学习中，串口发送字符串是必不可少的，但是
在学习过程中可能会遇到下面这个问题，就由我来给大家分享一下吧。
下面是封装的串口发送字符串的函数：
void Usart_SendString(uint8_t *String) { uint8_t i; for(i = 0; String[i] != '\0'; i++) { Usart_SendByte(String[i]); } } 在mian.c文件中我们运行代码不会报错，但是我们可以看到Usart_SendString函数打印字符串时会出现警告。
当我们将uint8 _t改为char时，就不会出现警告为什么会出现这样的原因呢?
虽然他们都是8位数的数据类型但是他们的用途不同。uint8_t是一个无符号8位整数类型，它可以存储0到255之间的整数。而char是一个字符类型，它可以存储一个ASCII字符或者一个字节的数据。在处理二进制数据时，通常使用uint8_t类型，而在处理文本数据时，通常使用char类型。
void Usart_SendString(char *String) { uint8_t i; for(i = 0; String[i] != '\0'; i++) { Usart_SendByte(String[i]); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a98055d818488c4775fe18aba52f8b7/" rel="bookmark">
			「VScode」通过VScode进行git的版本管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 之前在git的版本管理上，我使用的是sourcetree，说实话，软件还是蛮好用的，界面化做的很好看新手用起来也不复杂，不过安装上不是很方便而已。但既然VScode提供了git版本管理的功能，何不节省一个软件的操控呢。
基本介绍 VScode是已经内置了git版本管理的功能的，前提是需要配合电脑中安装git了。所以，没有下载的话可以先下载安装好后再继续进行。
使用介绍 首先需要了解，软件当中，左侧菜单第三个按钮下是对git版本的操作区域，一下的所有操作均与该区域有关。
1. 推送一个新的项目到服务器 1.1 打开一个文件夹 可以是已经完成的项目文件夹，也可以是一个新的空的文件夹。 1.2 初始化仓库 当你打开的文件夹中没有任何git信息的时候，软件会提示你需要初始化你的仓库。
1.3 添加远程仓库 此处有个前提，需要你在服务器上已经将你的远端仓库创建完成。
1. 远端仓库创建
2.复制远端仓库地址
填写远端仓库地址，回车确定
将远端仓库命名为origin，回车确定
1.4 分支管理 在软件左下角可以看到当前分支的名字，点击名字，可以快捷创建分支。
也可以在源代码管理的菜单中对分支进行操作
1.5 文件变更 当有文件变动的时候，在该界面就可以看到变化的文件与内容。
变更含义 U：新文件M：有变动的文件
变更提示
在文件里面也可以鼠标移动上去，看到该内容的最后一次变更的时间与变更人。
1.5.1 撤销文件变更 撤销整个文件的变更
撤销文件中一部分的变更
点击需要更改的文件，右键单击改变的内容，就可以针对这一处改变进行操作。
1.5.2 暂存文件更改 暂存单个文件更改
暂存所有文件更改
1.5.3 提交更改 可以针对暂存的内容进行单纯提交，也可以提交和推送一同进行。
【注意】需要填写提交信息。
当没有任何暂存的更改，就提交的时候会提示
2. 拉取一个项目到本地 打开软件，选择开始页面中的克隆
或者控制区域的克隆
填写远端仓库地址
选择本地仓库位置
打开仓库
ok，现在就可以管理我们从远端拉取下来的代码啦～
到此，已经讲解了VScode对git管理的基本操作啦。
关于git的扩展 记住用户名密码 git config --global user.name "用户名" git config --global user.email "用户邮箱" git config --global credential.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a98055d818488c4775fe18aba52f8b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88fc2f50daafc733635564cca15c6bef/" rel="bookmark">
			AD域文件权限管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		活动目录文件权限管理 在网络上共享资源时，首先关心的是谁可以访问这些资源以及级别。在 Active Directory （AD） 环境中管理文件服务器可能很乏味，而且必须一次一个用户完成，这一事实使其成为系统管理员最耗时的活动之一。
例如，假设新员工已加入组织中的人力资源团队。您需要授予他们访问共享资源的权限，例如员工详细信息、人力资源策略、公司策略等，但同时，授予他们访问财务数据的权限是不必要的，并且可能导致数据错位、篡改或滥用。再举一个例子，你永远不希望向新员工授予对任何资源的删除权限。这就是为什么您需要对用户的访问权限级别进行一些限制的原因。您可以通过仔细定义用户的访问控制条目来执行此操作。
除了安全性之外，需要考虑的另一个方面是，虽然更多硬件选项的可用性肯定降低了存储和服务器成本，但维护成本仍在稳步上升。造成这种情况的原因包括持续存储更多数据到服务器中断和数据损坏。这些都表明缺乏适当的文件服务器管理和维护措施。ADManager Plus通过Active Directory以及Isilon和NetApp服务器的文件服务器管理和报告功能，为此问题提供了高效的一站式解决方案。
ADManager Plus 中的文件服务器管理功能使管理员能够管理（即分配、修改和撤销）用户的 NTFS 并批量共享权限。您所要做的就是选择共享资源，然后根据用户的需求仔细检查和定义用户的访问控制。通过使用 ADManager Plus 的文件服务器管理功能，管理员可以：
授予用户和组对所需资源的访问权限，而不会产生安全风险批量修改权限应用不同类型的权限，并将范围限制为特定文件夹和子文件夹管理活动目录、NetApp 和 Isilon 文件服务器上的权限从一个简单的、单一的中央窗口执行所有这些任务 ADManager Plus 的帮助台委派功能将文件权限管理委派给任何用户。您还可以使用内置审核报告跟踪共享文件夹和文件服务器的权限更改。技术人员和管理员审核报告可以根据需要导出为 CSV、PDF、HTML 或 Excel 格式。
ADManager Plus 还提供有关在 AD、NetApp 和 Isilon 文件服务器上配置的NTFS 权限的报告，例如服务器中的共享、文件夹的权限、帐户可访问的文件夹和不可继承的文件夹。这些报告使管理员能够以全面的方式立即了解访问控制。这种对权限的即时可见性可以帮助管理员有效地增强安全性。
NTFS权限管理工具 ADManager Plus拥有专用的NTFS权限管理模块，这是用于确定用户可以访问哪些资源和数据的非常关键的管理操作。
修改 NTFS 权限 - 定义用户可以对网络上和本地的文件夹和文件执行的操作。该工具提供以下 NTFS 权限修改选项： 包括来自特定对象的父级的所有可继承权限。删除所有现有权限并仅应用一组特定权限。将所有后代上的所有现有可继承权限替换为特定对象的可继承权限。 管理员还可以应用高级权限（如读取或写入扩展属性）并取得文件或文件夹的所有权，并将权限限制为特定文件夹或子文件夹。
删除 NTFS权限 - 撤销 NTFS 权限。修改共享权限 - 确定其他人对共享文件夹的访问权限类型。删除共享权限 - 撤销共享权限。 修改 NTFS 权限时，还可以列出特定文件夹的现有共享文件夹权限。从文件夹复制选项允许您复制另一个文件夹的权限并将其应用于所需的文件夹，从而使修改 NTFS 权限更加轻松。“预览”选项列出了权限更改，以便您可以在更新之前对其进行验证。
共享和 NTFS 权限的管理 即时访问： 仅在提出访问请求时提供对关键资源的访问权限。任务完成后撤销权限。恰到好处的权限：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88fc2f50daafc733635564cca15c6bef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9e94e5891eff30e526569c464915b42/" rel="bookmark">
			MyBatis-Plus实现多表联查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis-Plus多表联查写法 前言一、引依赖二、使用方法三、（实战）多表查询参数说明 四、（实战）多表分页查询 前言 收获大佬封装的一个jar包，可以支持MyBatis-Plus多表联查，特此分享。
一、引依赖 注意: mybatis plus version &gt;= 3.4.0
&lt;dependency&gt; &lt;groupId&gt;com.github.yulichang&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-join&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt; &lt;/dependency&gt; 二、使用方法 mapper继承MPJBaseMapper (必选)
service继承MPJBaseService (可选)
serviceImpl继承MPJBaseServiceImpl (可选)
三、（实战）多表查询 MPJLambdaWrapper&lt;Map&gt; mpjLambdaWrapper = new MPJLambdaWrapper(); mpjLambdaWrapper.select(ChatRecord::getId,ChatRecord::getRedMoney) .select(OfShopMembers::getUsablePoint) .select(ChatMultiList::getName) .leftJoin(OfShopMembers.class,OfShopMembers::getId,ChatRecord::getId) .leftJoin(ChatMultiList.class,ChatMultiList::getId,ChatRecord::getMultiId) .eq(ChatRecord::getMemberId,3213); List list = chatRecordMybatisJoinMapper.selectJoinList(Map.class, mpjLambdaWrapper); 对应查询语句
SELECT t.id, t.red_money, t1.username, t2.name FROM chat_record t LEFT JOIN of_shop_members t1 ON (t1.id = t.id) LEFT JOIN chat_multi_list t2 ON (t2.id = t.multi_id) WHERE (t.member_id = 3213) 参数说明 1、select：表示查询的指定字段，一个select只能查一个表的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9e94e5891eff30e526569c464915b42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b6743b780420ec0e412348b17fd4680/" rel="bookmark">
			ariang/Aria2 RPC 服务器错误/Aria2状态/未连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题如下图所示
解决方案
如果是https的，更换为http后看看http://localhost:6800/jsonrpc更换为http://127.0.0.1:6800/jsonrpc，也试试你是不是跟我一样，没有启动aria2.exe？
启动后，右下角有托盘，然后，甚至不需要刷新页面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0e0a4228b4a49b2a1f59ca041c1e77c/" rel="bookmark">
			Icarus Verilog安装&amp;&amp;计组实验ALU（32位算术逻辑运算器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装软件 下载地址：http://bleyer.org/icarus/
配置环境变量
手动添加C:\iverilog\gtkwave\bin 和 C:\iverilog\bin（默认C盘）
2.编写 Verilog代码和test test中格外添加
$dumpfile("test.vcd"); $dumpvars; 3.编译仿真 1.win +R ，输入cmd 打开命令行；
2.cd+代码所在文件夹 进入.v所在文件夹
3.执行 iverilog -o dsn alu32_tb.v得到文件dsn
4.执行vvp dsn
4.用gtkwave打开vcd仿真波形 执行 gtkwave test.vcd 打开仿真波形
5. 计组实验alu代码文件 1.alu32.v
`include"ALU1.v" `include"ALU2.v" `include"ALU3.v" `include"ALU4.v" module alu32(a,b,op,out,z,c,n,ov,clk); parameter width=32; input [width-1:0] a,b; input [3:0] op; input clk; output reg [width-1:0] out; output reg z,c,n,ov; wire [width-1:0] out1,out2,out3,out4; wire z1,z2,z3,z4,c1,c2,c3,c4,n1,n2,n3,n4,ov1,ov2,ov3,ov4; ALU1 alu1(a,b,op[1:0],out1,z1,c1,n1,ov1); ALU2 alu2(a,b,op[1:0],out2,z2,c2,n2,ov2); ALU3 alu3(a,b,op[1:0],out3,z3,c3,n3,ov3); ALU4 alu4(a,b,op[1:0],out4,z4,c4,n4,ov4); always@* begin case(op[3:2]) 2'b00: begin out=out1; z=z1; c=c1; n=n1; ov=ov1; end 2'b01: begin out=out2; z=z2; c=c2; n=n2; ov=ov2; end 2'b10: begin out=out3; z=z3; c=c3; n=n3; ov=ov3; end 2'b11: begin out=out4; z=z4; c=c4; n=n4; ov=ov4; end endcase end endmodule 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0e0a4228b4a49b2a1f59ca041c1e77c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c098d7eca08a67765f21c12875a6a7d2/" rel="bookmark">
			【Qt网络编程】实现TCP协议通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概要：本期主要讲解QT中对于TCP协议通信的实现。一、TCP协议二、Qt中TCP协议处理1.QTcpSocket2.QTcpServer 三、Qt实现TCP通信1.客户端2.服务器端 结尾 概要：本期主要讲解QT中对于TCP协议通信的实现。 一、TCP协议 传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793 定义。
TCP建立连接前，需要进行三次握手，如下图所示：
TCP断开连接前，需要进行四次挥手，如下图所示：
二、Qt中TCP协议处理 Qt中提供了QTcpSocket类和QTcpServer类分别用于创建TCP套接字和TCP服务器套接字。
1.QTcpSocket QTcpSocket类继承与QAbstractSocket，主要提供了socket套接字的创建、绑定端口、连接服务器等。
2.QTcpServer QTcpServer类继承于QSctpServer，主要提供了对于TCP连接信号的响应和监听等。
三、Qt实现TCP通信 1.客户端 客户端是发送端，主要实现与服务器端建立连接、发送数据。步骤如下：
建立TCP套接字 --&gt; 连接服务器 --&gt; 发送数据
下面是客户端的源码：
#ifndef TCPCLIENT_H #define TCPCLIENT_H #include &lt;QObject&gt; #include &lt;QTcpSocket&gt; #include &lt;QHostAddress&gt; #include &lt;QDebug&gt; #include &lt;QTimer&gt; class TCPClient : QObject { Q_OBJECT public: TCPClient(); void InitSocket();//初始化Socket套接字 void InitTimer();//初始化定时器，定时发送 void ConnectToServer();//连接服务器 void SendData();//发送数据 private: QTcpSocket *mTcpSocket;//Tcp连接套接字 QHostAddress mServerAddress;//服务器IP QTimer *mTimer;//定时器对象 }; #endif // TCPCLIENT_H #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c098d7eca08a67765f21c12875a6a7d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89dac78da333665b8597d419359819f2/" rel="bookmark">
			软件测试之功能测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、功能测试概述 1）功能测试就是对产品的各功能进行验证，根据功能测试用例，逐项测试，检查产品是否达到用户要求的功能。
2）功能测试，根据产品特性、操作描述和用户方案，测试一个产品的特性和可操作行为以确定它们满足设计需求。本地化软件的功能测试，用于验证应用程序或网站对目标用户能正确工作。使用适当的平台、浏览器和测试脚本，以保证目标用户的体验将足够好，就像应用程序是专门为该市场开发的一样。功能测试是为了确保程序以期望的方式运行而按功能要求对软件进行的测试，通过对一个系统的所有的特性和功能都进行测试确保符合需求和规范。
3）Functional testing（功能测试），也称为behavioral testing（行为测试），根据产品特性、操作描述和用户方案，测试一个产品的特性和可操作行为以确定它们满足设计需求。本地化软件的功能测试，用于验证应用程序或网站对目标用户能正确工作。使用适当的平台、浏览器和测试脚本，以保证目标用户的体验将足够好，就像应用程序是专门为该市场开发的一样。
4）功能测试是为了确保程序以期望的方式运行而按功能要求对软件进行的测试，通过对一个系统的所有的特性和功能都进行测试确保符合需求和规范。
5）功能测试也叫黑盒测试或数据驱动测试，只需考虑需要测试的各个功能，不需要考虑整个软件的内部结构及代码.一般从软件产品的界面、架构出发，按照需求编写出来的测试用例，输入数据在预期结果和实际结果之间进行评测，进而提出更加使产品达到用户使用的要求。
6）黑盒测试（Black-box Testing，又称为功能测试或数据驱动测试）是把测试对象看作一个黑盒子。利用黑盒测试法进行动态测试时，需要测试软件产品的功能，不需测试软件产品的内部结构和处理过程。
二、黑盒设计方法 黑盒测试用例设计方法,主要包括等价类划分法、边界值分析法、错误推测法、因果图法、判定表驱动法、正交试验设计法、功能图法等
1.等价类划分法
等价类划分法是把程序的输入域分成若干部分，然后从每个部分中选取少数代表性数据作为测试用例。每一类的代表性数据在测试中的作用等价于这一类中的其他值。
1）应用场景：
某程序规定：“输入三个整数a,b,c分别作为三边的边长构成三角形.通过程序判定所构成的三角形的类型,当此三角形为一般三角形\等腰三角形及等边三角形时,分别作计算...”.用等价类划分方法为该程序进行测试用例设计.
2）分析题目中给出和隐含的对输入条件的要求:
⑴整数 ⑵三个数 ⑶非零数 ⑷正数 ⑸两边之和大于第三边 ⑹等腰 ⑺等边
3）如果a、b、c满足条件1-4，则输入下列四种情况之一：
①如果不满足条件5，则呈现输出为“非三角形”
②如果三条边相等即满足条件7，则呈现输出为“等边三角形”
③如果只有两条边相等，即满足条件6，则呈现输出为“等腰三角形”
④如果三条边都不相等，则程序输出为“一般三角形”
4）覆盖有效等价类的测试用例：
a b c 覆盖等价类号码
3 4 5 1-7
4 4 5 1-7,8
4 4 5 1-7,9
5 4 5 1-7,10
4 4 4 1-7,11
5）覆盖无效等价类的测试用例：
2.边界值分析法
1）边界值分析法就是对输入火输出的边界值进行测试的一种黑盒测试方法.同城边界值分析法是作为对等价类划分法的补充.
2）使用边界值分析方法设计测试用例,首先应确定边界情况.通常输入和输出等价类的边界,就是应着重测试的边界情况.应当选取正好等于,刚刚大于或者刚刚小于边界的值作为测试数据.
3）通常情况下,软件测试所包含的边界检验有几种类型:数字,字符,位置,重量,大小,速度,方位,尺寸,空间等相应地,以上类型的边界值应该在:最大/最小,首位/末位,上/下,最快/最慢,最高/最低,最短/最长,空/满等情况下,利用边界值作为测试数据.
项
边界值
测试用例的设计思路
字符
起始-1个字符/结束+1个字符
假设一个文本输入区域允许输入1个到255个 字符，输入1个和255个字符作为有效等价类；输入0个和256个字符作为无效等价类，这几个数值都属于边界条件值。
数值
最小值-1/最大值+1
假设某软件的数据输入域要求输入5位的数据值，可以使用10000作为最小值、99999作为最大值；然后使用刚好小于5位和大于5位的 数值来作为边界条件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89dac78da333665b8597d419359819f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d293baa9458f47415cfe9c87db82e2a9/" rel="bookmark">
			腾讯云linux启动nginx报错：error while loading shared libraries: libssl.so.10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云VM-16-7-opencloudos，解压绿色版的nginx，启动、检查安装信息时报错：./nginx: error while loading shared libraries: libssl.so.10: cannot open shared object file: No such file or directory
提示是不存在libssl.so.10包。先查看本机是否存在whereis libssl.so.10
那么需要安装下libssl包：compat-openssl10
yum install compat-openssl10 注意，需要安装的compat-openssl10包，不是openssl包
安装完之后，nginx就可以正常运行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70710a854e65d084930990c797a2ffd8/" rel="bookmark">
			LSTM笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RNN, LSTM, GRU模型的作用, 构建, 优劣势比较,attention机:
https://blog.csdn.net/sinat_28015305/article/details/109355828?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167903492816800182195114%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167903492816800182195114&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-109355828-null-null.142^v74^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=RNN%E6%A8%A1%E5%9E%8B&amp;spm=1018.2226.3001.4187
LSTM的输出和参数：
https://blog.csdn.net/ssswill/article/details/88429794?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167870775616800184190436%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167870775616800184190436&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-88429794-null-null.142^v73^insert_down4,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=LSTM%E8%BE%93%E5%87%BA%E6%98%AF%E4%BB%80%E4%B9%88&amp;spm=1018.2226.3001.4187
# 数据集的准备
1：定义好Field
2：建立词表
3：建立迭代器
import spacy import torch from torchtext.datasets import Multi30k #pytorchtext自带的Multi30k数据集 from torchtext.data import Field,BucketIterator # 1：定义好Field #创建分词器器 spacy_en=spacy.load("en_core_web_sm")#英语分词器 spacy_de=spacy.load("de_core_news_sm")#德语分词器 def en_seq(text): return [word.text for word in spacy_en.tokenizer(text)] def de_seq(text): return [word.text for word in spacy_de.tokenizer(text)][::-1]#源端倒序 #源端的处理手段 #field函数的参数说明：https://blog.csdn.net/bqw18744018044/article/details/109150802 SRC=Field(tokenize=de_seq,#分词函数 init_token="&lt;sos&gt;", #起始字符 eos_token="&lt;eos&gt;", #结束字符 lower=True) #把数据转换为小写 #目标端的处理手段 TRG=Field(tokenize=en_seq, init_token="&lt;sos&gt;", eos_token="&lt;eos&gt;", lower=True) #定义dataset数据集，这里将其数据经过fiels处理 #splits方法可以同时读取训练集，验证集，测试集 train_data,valid_data,test_data=Multi30k.splits(exts=(".de",".en"), fields=(SRC,TRG)) print(f"Number of training examples: {len(train_data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70710a854e65d084930990c797a2ffd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ef55eeb0c4fd18d6adcaf9f80d54fbe/" rel="bookmark">
			共同学习ACL的基本原理与操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		访问控制列表 ACL概述ACL分类ACL的操作一、ACL概述二、ACL的分类三、ACL的操作 ACL概述 ACL分类 ACL的操作 一、ACL概述 ACL就是访问控制列表。
主要作用就是：
能够读取第三层、第四层包头信息根据预先定义好的规则对包进行过滤 通信四元素：源IP地址、目的IP地址、源端口、目的端口
通信五元素：源IP地址、目的IP地址、源端口、目的端口、协议（TCP、UDP）
ACL工作原理：就是根据规则处理通过的数据包，然后决定是否放行。
ACL处理过程：不管这个数据包有多少条，从上往下依次匹配，匹配上就停止，只要匹配到第一条匹配到的数据，接下来不管多少条，都会直接停止，通过还是拒绝就看匹配到的第一条。要么放行，要么丢弃。
一个接口只能调用一个ACL，如果访问到最后一个也没访问到，华为设备默认放过所有。
二、ACL的分类 ACL共分为三层：
基本ACL、高级ACL、二层ACL。
ACL：范围在2000~2999，只匹配源IP地址。
高级ACL：范围在3000~3999，可根据协议、源IP、目的IP、源端口、目的端口匹配
二层ACL：可根据源MAC、目的MAC、二层协议匹配。
三、ACL的操作 基本ACL配置的命令
首先还是先连接好主机、路由器等。
配置好所有的IP地址
先创建基本ACL
配置拒绝源地址的执行序号
接口出方向调用ACL 20015. 进入ACL 2001列表
配置规则允许通过的源地址
拒绝其他所有的来源（因为华为是默认全部通过的）
高级ACL配置命令
进入ACL 3000
2.拒绝ping
3.允许通过的协议
4.拒绝所有的协议通过（不会和上面的步骤有冲突，因为上面的步骤先建立的，优先级默认是五，这个命令后面的，优先级是五的倍数，后面的步骤以此内推。） 5.在入方向接口应用ACL
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/870573c568f49984e02a35a40ef11241/" rel="bookmark">
			解决：VS Code 设置默认打开浏览器        Chrome
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、问题描述 在 VSCode 编辑器中，一般默认打开的浏览器是 Edge 浏览器，而我一般使用 Chrome 浏览器，以及会遇到页面的调试等不同的问题，因此需要将 VSCode 的默认浏览器调整为 Chrome 浏览器；
二、问题解决 1.在插件商城中搜索open in browser并安装 2.打开 文件==》首选项==》设置 在搜索栏中搜索Open-in-browser: Default后在下方框中填入： {"open-in-browser.default":"Chrome"} 或 Chrome 此时就已经将 VSCode 的默认浏览器修改成 Chrome 了；
三、扩展 1.选中一个.html文件右键可以看到打开默认浏览器的快捷键为alt+B、打来其他浏览器的快捷键为shift+alt+b PS：若到这里还有小伙伴不能更改默认浏览器，可以看看是否有第三方的辅助工具锁定了浏览器如：360等、有一些设置了强制默认浏览器 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5935734925b3a160501d4a68ca570ff/" rel="bookmark">
			axios封装—vue3项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言正文安装axios封装请求api1. 在src目录下新建个api目录，里面放请求相关的文件，新建`request.js`文件，首先引入`axios`2. 创建一个`axios`实例3. axios请求拦截器4. axios响应拦截器5. 封装请求函数，可以根据项目实际情况处理参数（此处仅处理了get与post请求）6. 最后导出函数方法 使用方式1. 可以将接口全部定义在一个文件内（方便管理）2. 另一种写法是直接在项目内使用 总结扩展阅读 前言 axios的API很友好，可以在项目中直接使用。但是在大型项目中，http请求很多，且需要区分环境， 每个网络请求有相似需要处理的部分，会导致代码冗余，破坏工程的可维护性，扩展性，所以需要对axios请求进行相应的封装
正文 安装axios # npm 安装 npm install axios # yarn 安装 yarn add axios 封装请求api 1. 在src目录下新建个api目录，里面放请求相关的文件，新建request.js文件，首先引入axios import axios from 'axios'; 2. 创建一个axios实例 // request.js // 创建新的axios实例 const service = axios.create({ // 环境变量，需要在.env文件中配置 baseURL: process.env.VUE_APP_BASE_API, // 超时时间暂定5s timeout: 5000, }); 3. axios请求拦截器 config里面配置请求前的一些处理，例如：数据转化，配置请求头，设置token,设置loading等，根据需求去添加
// request.js service.interceptors.request.use( config =&gt; { // 此处添加Loading return config; }, error =&gt; { return Promise.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5935734925b3a160501d4a68ca570ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f7709365a07bc31e140403f261df67c/" rel="bookmark">
			YOLOV3详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. YOLOV3引入 图来自于江大白的CSDN博客
2. 为什么学习YOLOV3？ YOLOV3跟V2/V1相比采用了残差的思想，可以说是基于ResNet的思想上重新设计了backbone(DarkNet53)。V1/V2的backbone采用的是VGG类型的结构, 借着学习V3, 复习ResNet以及为什么DarkNet会有更好的精度和速度在YOLOV3中加入了FPN层, 这是为什么相比于(V1/V2采用的图像金字塔), V3能够涨点的那么多最重要的原因, 学习图像金字塔的发展到FPN层再手写一个FPN层出来YOLOv3采用了一种基于聚类的正负样本匹配方法，相比于基于IoU的方法，可以更好地适应各种目标尺度和宽高比，并提高模型的精度和稳定性。后续的YOLO也沿用了这种思想，很有学习的必要性。 3. Backbone的改进: DarkNet53 上图
3.1 Plain Model对比 下面这张图是简单模型(Plain Model)的对比, 看一下DarkNet19 vs VGG16, DarkNet53 vs ResNet101
DarkNet19相比于VGG16具有更少的参数量(7.29Bn VS 30.94Bn), 更快的GPU推理速度（6.2ms vs 9.4ms）同样是残差结构的ResNet101和Dark53, 也是同样拥有更少的参数量(18.57Bn vs 19.70Bn)和更高的GPU推理速度 （13.7ms vs 20.0ms） 3.2 DarkNet19(YOLOV2) VS VGG16 较少的参数量: DarkNet19是一个FCN(全卷积的神经网络), 而且还使用了1x1的卷积进行通道数的缩减, VGG系列使用的都是3x3的卷积核而且通道数没有缩减。在网络设计中1x1的卷积核通常是功能性的, 例如减少参数和通道数较快的速度: 也是因为FC层, VGG16最后三个FC层有太多参数, 同样是在ImageNet上做预训练, DarkNet19直接最后一个1x1 1000通道 softmax解决。精度的保持 DarkNet19在后期通道也是增长了，而VGG系列最后一个Block的通道数是没有变化的，这也只是可能的一个因素，这也说明了另一件事VGG系列可能出现了过拟合的现象（个人见解）DarkNet19中使用了批量归一化（Batch Normalization）来加速训练和提高模型的准确性，批量归一化在训练过程中可以加速梯度的传播和收敛，同时也提高了模型的泛化能力，这对于推理速度的提高也有积极的影响。 3.3 残差网络 重点:为什么当时网络深度较浅？DarkNet19, VGG19? 这个疑惑在何凯明大神的ResNet论文中得到了答案，就是对于Plain模型，网络越深，训练误差和测试误差越大，精度可能相较于浅层网络还会有所下降。因为随着网络的加深，会出现梯度的弥散，很多特征会消失在深层网络，导致结果没办法呈现到最佳的效果。
什么是残差连接？为什么对梯度消失有效？带来了什么效果？ 原理主要是把卷积层前后的特征进行元素相加求和，如果特征是在这其中的某一个卷积后消失的，那么残差结构便可以找回丢失的特征。左图为没有使用残差结构的plain模型，右图是使用了残差结构的残差网络ResNet，可以看到使用了残差结构的模型，随着模型深度的增加，误差随着训练的迭代进行也是降低的。
3.4 为什么作者不直接使用精度类似的ResNet101而是重新设计了DarkNet59? 首先他们在block中都用conv3x3代替了(VGG16, DarkNet19)的MaxPooling但是通过对比, ResNet中Block是三层卷积而DarkNet的block是2层卷积, DarkNet53在最后分类前是1024通道而ResNet是2048通道ResNet101中的Stage是3, 4, 23, 3, DarkNet中的Stage是1， 2， 8， 4。可以发现DarkNet的设计更加均衡, 而且最后的通道数其实1024是足够的, FC层之前采用较高的通道数是为了能够提取更加丰富的特征信息, 高通道数的卷积层也有利于模型的泛化能力。 这里也是说明其实1024通道是够的不用上到2048通道所以可以看出来精度高了1个点但是推理速度快乐1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f7709365a07bc31e140403f261df67c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/154/">«</a>
	<span class="pagination__item pagination__item--current">155/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/156/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>