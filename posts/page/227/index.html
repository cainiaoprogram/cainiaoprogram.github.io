<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/640c0d429bdf6af627ed7b1e08772140/" rel="bookmark">
			WEB端实现文件夹上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webkitdirectory属性。这个属性加上之后，就是选择文件夹，然后根据自己业务上传至后台； 前端代码：
&lt;form action="${ctxPath}/invoice/uploadFolder" method="post" enctype="multipart/form-data"&gt; &lt;input name="chooseFolder" type="file" id="chooseFolder" webkitdirectory/&gt; &lt;input type="submit" id="uploadFolder" style="display : none"/&gt; &lt;/form&gt; &lt;iframe name="form" id="form" style="display:none"&gt;&lt;/iframe&gt; 监听上传，ajax提交请求：
/* 监听上传文件夹按钮 */ $("#chooseFolder").on("change", function() { var sIndex = layer.msg("识别数据中，请稍候", {icon:16, time:false, shade:0.1}); dataList = []; var fileList = []; var files = this.files; console.log(files); for(var i = 0;i&lt;files.length;i++){ fileList.push(files[i]) } let formData = new FormData() formData.append("chooseFolder",files); fileList.forEach(function (file) { formData.append('chooseFolder',file, file.name) }) $.ajax({ url: "${ctxPath}/invoice/uploadFolder", data: formData, type: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/640c0d429bdf6af627ed7b1e08772140/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b9e63b4220b7198066e317f5e408f79/" rel="bookmark">
			华为旧手机多媒体控件问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天处理了一台华为的旧手机，具体型号就不说了，应该是某个朋友50包邮收的二手手机，系统版本是Emui 3.3， Android 5.1,对应的就是Android Lollipop。
具体的问题出现在哪里呢？
就是在调用MediaCodec库的方法时，会出现一个错误。
//出错代码行 MediaCodec codec = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC); //错误捕获堆栈 java.lang.UnsatisfiedLinkError: Library media_jni not found; tried [/system/lib64/libmedia_jni.so, /system/product/lib64/libmedia_jni.so, /data/local/tmp/libmedia_jni.so] at java.lang.Runtime.loadLibrary(Runtime.java:407) at java.lang.System.loadLibrary(System.java:997) at android.media.MediaCodec.&lt;clinit&gt;(MediaCodec.java:1695) at com.xxxxx.xxx.Server.scrcpy(Server.java:27) at com.xxxxx.xxx.Server.main(Server.java:313) at com.android.internal.os.RuntimeInit.nativeFinishInit(Native Method) 很明显地可以看出，在调用MeiaCodec的方法时，实际上是通过jni的方法调用了Framework里已经编译好了的so文件里面的方法，这边缺少的就是libmeia_jni.so。那么问题就很好解决了，只需要找到这样的.so文件就行。
我们在github上面搜索这个文件，很容易的看到了，GitHub - pfalcon/android-platform-headers: Collection of platform headers and link libs for all versions of Android. (repo is rebased, see wiki)
这个项目里面就有对应的.so文件。我们只需要随便adb push到 [/system/lib64, /system/product/lib64, /data/local/tmp]的任何一个文件夹里就行了。
但是
java.lang.UnsatisfiedLinkError: Bad JNI version returned from JNI_OnLoad in "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b9e63b4220b7198066e317f5e408f79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b7d350fa672fdf55afc5d7a3221940c/" rel="bookmark">
			计算机网络入门基础篇——应用层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考视频教程：计算机网络微课堂
文章目录 一、应用层概述二、客户—服务器方式和对等方式1.客户/服务器(Client/Server，C/S)方式2.方式对等(Peer-to-Peer，P2P)方式 三、动态主机配置协议DHCP四、域名系统DNS五、文件传送协议FTP六、电子邮件七、万维网WWW1.万维网文档2.超文本传输协议3.cookie 一、应用层概述 二、客户—服务器方式和对等方式 网络应用程序运行在处于网络边缘的不同的端系统上，通过彼此间的通信来共同完成某项任务。
开发一种新的网络应用首先要考虑的问题就是网络应用程序在各种端系统上的组织方式和它们之间的关系。目前流行的主要有以下两种：
客户/服务器(Client/Server，C/S)
方式对等(Peer-to-Peer，P2P)方式
1.客户/服务器(Client/Server，C/S)方式 1.客户和服务器是指通信中所涉及的两个应用进程。
2.客户/服务器方式所描述的是进程之间服务和被服务的关系。
3.客户是服务请求方，服务器是服务提供方。
4.服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号（例如HTTP服务器的默认端口号为80)，而运行服务器的主机也具有固定的IP地址。
2.方式对等(Peer-to-Peer，P2P)方式 在P2P方式中，没有固定的服务请求者和服务提供者，分布在网络边缘各端系统中的应用进程是对等的，被称为对等方。对等方相互之间直接通信，每个对等方既是服务的请求者，又是服务的提供者。
三、动态主机配置协议DHCP DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一个局域网的网络协议，指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。
我们应该给网络中的各主机设置怎样的网络相关配置信息才能使它们可以正常访问网络中的外部服务器？我们需要给网络中的各主机正确配置IP地址、子网掩码、默认网关DNS服务器的网络相关配置信息，例如下图是我们分别给两台主机手工配置的网络相关配置信息。
如果我们给网络中添加一台DHCP服务器，在该服务器中设置好可为网络中其他各主机配置的网络配置信息。网络中各主机开机后自动启动DHCP程序，向DHCP服务器请求自己的网络配置信息，这样网络中的各主机就都可以从DHCP服务器自动获取网络配置信息，而不用手工参与。
我们看下面这个例子：
DHCP使用客户服务器方式在DHCP服务器上运行DHCP服务器进程，也可简称为DHCP服务器，在用户主机上运行DHCP客户进程，也可简称为DHCP客户。DHCP服务器使用的UDP端口是67，DHCP客户使用的UDP端口是68，这两个UDP端口都是熟知端口。
当启用主机的DHCP后，DHCP客户将广播发送DHCP发现报文，封装该报文的IP数据报的原IP地址为0.0.0.0，这是因为主机目前还未分配到IP地址，因此使用该地址来代替，目的IP地址为广播地址255.255.255.255。对于DHCP客户，其应用层没有监听该UDP用户数据报的目的端口67的进程，也就是DHCP服务器进程，因此无法交付DHCP发现报文，只能丢弃；而对于DHCP服务器，其应用层始终运行着DHCP服务器进程，因此会接受该DHCP发现报文并作出响应。
DHCP报文的格式比较复杂，对于DHCP发现报文，我们只需要知道其内部封装有事物ID和DHCP客户端的MAC地址即可。
DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库，看是否有针对该MAC地址的配置信息，如果有，则使用这些配置信息来构建并发送DHCP提供报文；如果没有，则采用默认配置信息来构建并发送DHCP提供报文。对于DHCP服务器，其应用层没有监听该UDP用户数据报目的端口68的进程，也就是DHCP客户进程，因此无法交付DHCP提供报文，只能丢弃；而对于DHCP客户，其应用层运行着DHCP客户进程，因此会接受该DHCP提供报文并作出相应处理。
DHCP客户会根据DHCP提供报文中的事物ID来判断该报文是否是自己所请求的报文，如果该事物ID与自己之前发送的DHCP发现报文中封装的事物ID相等，要表明这是自己所请求的报文，就可以接受该报文；否则就丢弃该报文。
DHCP请求报文装封有事物ID、DHCP客户端的MAC地址、接受的租约中的IP地址、提供此租约的DHCP服务器端的IP地址等信息。
综上所述，下面分别是DHCP客户寻找DHCP服务器、DHCP服务器向DHCP客户提供IP地址租用、DHCP客户接受IP地址租约、DHCP服务器确认IP地址租约、DHCP客户进行IP地址续约、DHCP客户可以随时解除IP地址租约各部分。
DHCP服务器在给DHCP客户挑选IP地址时使用ARP来确保所挑选的IP地址未被网络中其他主机占用，而DHCP客户在使用所租用的IP地址之前也会使用ARP来检测该IP地址是否已被网络中其他主机占用。
思考一下该网络中的各主机是否可以通过DHCP来自动获取到网络配置信息呢？
答案是否定的。原因很简单，该网络中的主机广播发送DHCP发现报文，但该广播报文不会被路由器转发，而是丢弃。
解决方法是给该路由器配置DHCP服务器的IP地址，并使之成为DHCP中继代理，这样该网络中的各主机就可以通过DHCP来自动获取到网络配置信息了。当该路由器收到广播的DHCP发现报文后，会将其单播转发给DHCP服务器。
四、域名系统DNS 域名系统是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。
域名系统DNS的作用
因特网是否可以只使用一台DNS服务器?
域名解析的过程
五、文件传送协议FTP FTP允许用户以文件操作的方式与另一主机相互通信。然而， 用户并不真正登录到自己想要存取的计算机上面而成为完全用户， 可用FTP程序访问远程资源， 实现用户往返传输文件、目录管理以及访问电子邮件等等， 即使双方计算机可能配有不同的操作系统和文件存储方式。
FTP 是基于客户/服务器（C/S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。
FTP的常见用途：一个是在计算机之间传输文件，尤其是用于批量传输文件；另一个常见用途是让网站设计者将构成网站内容的大量文件批量上传到他们的Web服务器。
六、电子邮件 简单邮件传送协议SMTP
基于万维网的电子邮件
通过浏览器登录(提供用户名和口令）邮件服务器万维网网站就可以撰写、收发、阅读和管理电子邮件。这种工作模式与IMAP很类似，不同的是用户计算机无需安装专门的用户代理程序，只需要使用通用的万维网浏览器。
邮件服务器网站通常都提供非常强大和方便的邮件管理功能，用户可以在邮件服务器网站上管理和处理自己的邮件，而不需要将邮件下载到本地进行管理。
七、万维网WWW 万维网WWW (World Wide Web）并非某种特殊的计算机网络。它是一个大规模的、联机式的信息储藏所，是运行在因特网上的一个分布式应用。
万维网利用网页之间的超链接将不同网站的网页链接成一张逻辑上的信息网。
万维网是欧洲粒子物理实验室的Tim Berners-Lee最初于1989年3月提出的。
浏览器最重要的部分是渲染引擎，也就是浏览器内核，负责对网页内容进行解析和显示。
万维网使用统一资源定位符URL来指明因特网上任何种类“资源”的位置。其一般形式为：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;。
1.万维网文档 超文本标记语言HTML，使用多种“标签”来描述网页的结构和内容。(网页扩展名为.html)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b7d350fa672fdf55afc5d7a3221940c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d52f017971e605762cce2870fccaa99c/" rel="bookmark">
			MD5加密结果不一致
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于java C# MD5加密结果方不一致问题 MD5加密得到的结果一般是16位或者32位，不管是什么语言MD5加密都是一样的(除非更改了加密算法)
例如，当C# java MD5加密方不一致的时候
确定两边的编码是否一致
java MD5加密 public static String getMd5(String passord) throws NoSuchAlgorithmException, UnsupportedEncodingException { StringBuilder pwd = new StringBuilder(""); MessageDigest md = MessageDigest.getInstance("MD5");// 生成一个MD5加密计算摘要 byte[] digest1 = md.digest(passord.getBytes("UTF-16LE")); // byte[] digest1 = passord.getBytes("UTF-16LE"); for (int i = 0; i &lt; digest1.length; i++) { //将得到的字符串使用十六进制类型格式。格式后的字符是小写的字母，如果使用大写（X）则格式后的字符是大写字符 // pwd = pwd + digest1[i].toString("x"); int v = digest1[i] &amp; 0xFf; String hv = Integer.toHexString(v); if (hv.length() &lt; 2) { pwd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d52f017971e605762cce2870fccaa99c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/248ed17f0b2f6080eeb9e821186aeddf/" rel="bookmark">
			Python图片修复项目 —— Bringing-Old-Photos-Back-to-Life
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、项目地址
二、下载预训练模型
2.1、下载步骤
三、下载Python包
四、图片修复
4.1、裂痕修复
4.2、模糊图片高清化
一、项目地址 ​https://github.com/microsoft/Bringing-Old-Photos-Back-to-Life.git​ 二、下载预训练模型 2.1、下载步骤 1）进入Face_Enhancement/models/networks，下载Synchronized-BatchNorm-PyTorch
2）进入Face_Enhancement ，下载shape_predictor_68_face_landmarks.dat文件
3）进入Face_Enhancement，下载checkpoints_Face.zip并解压（解压后文件夹名称为checkpoints）
4）进入Global，下载checkpoints_Global.zip并解压（解压后文件夹名称为checkpoints）
注：预训练模型在百度网盘
三、下载Python包 pip install -r requirements.txt 四、图片修复 4.1、裂痕修复 ''' --input_folder : 旧图片路径 --output_folder : 待生成图片路径 --GPU : 是否使用GPU运行 -1表不使用 --with_scratch : 识别裂纹图片 ''' python run.py --input_folder "D:\Gitlab\Bringing-Old-Photos-Back-to-Life-master\img_repair\img_scratch\old" --output_folder "D:\Gitlab\Bringing-Old-Photos-Back-to-Life-master\img_repair\img_scratch\new" --GPU -1 --with_scratch 4.2、模糊图片高清化 ''' --input_folder : 旧图片路径 --output_folder : 待生成图片路径 --GPU : 是否使用GPU运行 -1表不使用 ''' python run.py --input_folder "D:\Gitlab\Bringing-Old-Photos-Back-to-Life-master\img_repair\img_dim\old" --output_folder "D:\Gitlab\Bringing-Old-Photos-Back-to-Life-master\img_repair\img_dim\new" --GPU -1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9afeeac260ccdbe5f6bafedd8fc96afb/" rel="bookmark">
			拓扑排序１图文详解面试常考算法 —— 拓扑排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Topological sort 又称 Topological order，这个名字有点迷惑性，因为拓扑排序并不是一个纯粹的排序算法，它只是针对某一类图，找到一个可以执行的线性顺序。
这个算法听起来高大上，如今的面试也很爱考，比如当时我在面我司时有整整一轮是基于拓扑排序的设计。
但它其实是一个很好理解的算法，跟着我的思路，让你再也不会忘记她。
有向无环图 刚刚我们提到，拓扑排序只是针对特定的一类图，那么是针对哪类图的呢？
答：Directed acyclic graph (DAG)，有向无环图。即：
这个图的边必须是有方向的；图内无环。 那么什么是方向呢？
比如微信好友就是有向的，你加了他好友他可能把你删了你却不知道。。。那这个朋友关系就是单向的。。
什么是环？环是和方向有关的，从一个点出发能回到自己，这是环。
所以下图左边不是环，右边是。
那么如果一个图里有环，比如右图，想执行1就要先执行3，想执行3就要先执行2，想执行2就要先执行1，这成了个死循环，无法找到正确的打开方式，所以找不到它的一个拓扑序。
总结： 如果这个图不是 DAG，那么它是没有拓扑序的；如果是 DAG，那么它至少有一个拓扑序；反之，如果它存在一个拓扑序，那么这个图必定是 DGA. 所以这是一个充分必要条件。
拓扑排序 那么这么一个图的「拓扑序」是什么意思呢？
我们借用百度百科[1]的这个课程表来说明。
课程代号课程名称先修课程C1高等数学无C2程序设计基础无C3离散数学C1, C2C4数据结构C3, C5C5算法语言C2C6编译技术C4, C5C7操作系统C4, C9C8普通物理C1C9计算机原理C8
这里有 9 门课程，有些课程是有先修课程的要求的，就是你要先学了「最右侧这一栏要求的这个课」才能再去选「高阶」的课程。
那么这个例子中拓扑排序的意思就是： 就是求解一种可行的顺序，能够让我把所有课都学了。 那怎么做呢？
首先我们可以用图来描述它，
图的两个要素是顶点和边，
那么在这里：
顶点：每门课边：起点的课程是终点的课程的先修课 画出来长这个样：
这种图叫 AOV (Activity On Vertex) 网络，在这种图里：
顶点：表示活动；边：表示活动间的先后关系 所以一个 AOV 网应该是一个 DAG，即有向无环图，否则某些活动会无法进行。
那么所有活动可以排成一个可行线性序列，这个序列就是拓扑序列。
那么这个序列的实际意义是：
按照这个顺序，在每个项目开始时，能够保证它的前驱活动都已完成，从而使整个工程顺利进行。
回到我们这个例子中：
我们一眼可以看出来要先学 C1, C2，因为这两门课没有任何要求嘛，大一的时候就学呗；大二就可以学第二行的 C3, C5, C8 了，因为这三门课的先修课程就是 C1, C2，我们都学完了；大三可以学第三行的 C4, C9；最后一年选剩下的 C6, C7。 这样，我们就把所有课程学完了，也就得到了这个图的一个拓扑排序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9afeeac260ccdbe5f6bafedd8fc96afb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69ec91ed3cd6b13b7c154b59b6f3dceb/" rel="bookmark">
			ADC driver 项目总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 目前经过了一个半月，ADC的项目也已经告一段落了，后面还会接触这一方面，所以做一个阶段性总结，来回顾一下，后面用到的话也可以回顾。
整个一个DCU框图如下
问题描述 1.在ADC中测试代码无法去进行测试，写入的数据无法readgroup出来
APP 中接收数据代码： https://blog.csdn.net/qq_44775824/article/details/125601486?spm=1001.2014.3001.5502
2.在配置EB的时候勾选了这个选项，导致后续的ADC Group直接报错。
3.当在AdcGroupTriggSrc 中勾选ADC_TRIGG_SRC_HW以后，再对AdcGroupConversionMode进行ADC_CONV_MODE_ONESHOT/ADC_CONV_MODE_CONTINUOUS的切换，当在HW的条件下切换成ADC_CONV_MODE_CONTINUOUS会报错。
原因分析： AdcNotification is the callback function for this group. Note: This parameter can be used when a configuration parameter AdcInterruptMode is enabled. Otherwise, this parameter is disabled. 2. Determines, if SARMUX1 (SARMUX of hardware unit of ADC_SAR_0_1) is connected tohardware unit of ADC_SAR_0_0.
The ADC driver provides the AdcSarMux1ConnectToAdc0 , AdcSarMux2ConnectToAdc0 , and AdcSarMux3ConnectToAdc0 configuration parameters to support this use case.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69ec91ed3cd6b13b7c154b59b6f3dceb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18c680d58aedef08f3eab9682d2f725f/" rel="bookmark">
			单步预测与多步与预测的联系与区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
单步预测与多步预测的联系
多步预测方法
（1）Direct Multi-step Forecast Strategy （直接多步预测策略）
（2）Recursive Multi-step Forecast （递归多步预测策略）
（3）Direct-Recursive Hybrid Strategies（直接递归混合多步预测策略）
预测模式
单步预测与多步预测的联系 通常来说，时间序列预测描述的是在下一个时间步预测出的值，这被称为单步预测。但是有些情况下，预测任务需要预测出未来多个时间步的值，那这种情况就被称为多步预测。
（1）多步预测的预测误差会随着步数的增加而累积，多步预测的结果也会越来越不准。但是单步预测很多时候不会有这种误差累积。
（2）多步预测可以用于预测“不存在”的数据，比如如果想预测第101到120个数据点，这时候便是使用多步预测了。
多步预测方法 以下为温度预测为例子：
（1）Direct Multi-step Forecast Strategy （直接多步预测策略） 直接法为每个预测时间步开发一个单独的模型。
在预测未来两天的温度的情况下，我们将学习一个独立的模型用于预测第一天温度，另一个独立的模型来预测第二天的温度。
（2）Recursive Multi-step Forecast （递归多步预测策略） 递归策略则多次使用一步模型，前一个时间步的预测被用作对下一个时间步进行预测的输入
在预测未来两天的气温时，我们将开发一个一步预测模型。该模型将先用于预测第1天，然后将第1天的预测结果当做观察输入，以便预测第2天。
prediction(t+1) = model(obs(t-1), obs(t-2), ..., obs(t-n)) prediction(t+2) = model(prediction(t+1), obs(t-1), ..., obs(t-n-1)) 由于使用预测值来代替观测值，递归策略会造成预测误差不断累积，随着预测时间范围的增加，递归多部预测策略的性能可能会迅速下降。我们多步预测大部分都是使用此方法！
（3）Direct-Recursive Hybrid Strategies（直接递归混合多步预测策略） 直接和递归策略可以结合起来，以结合这两种方法的优点。
例如，可以为每个要预测的时间步构造一个单独的模型，但是每个模型可以使用模型在前一个时间步所做的预测作为输入值。
对于预测未来两天的温度，可以使用两个模型，分别是model1和model2。在进行未来第2天的温度预测时，第一个模型的输出被用作第二个模型的输入。
预测模式 （1）全部数据用于多步预测：这就是上述说的，要预测“不存在”的数据。在软件中指定想预测的长度，点击开始就可以了。
（2）划分“训练-测试集”的多步预测：大致相当于上述举的例子，即将全部数据按照一定比例划分成训练集和测试集，然后多步预测出于测试集相同长度的数据，并画图对比，计算若干评估指标。这种模式下结果往往并不太理想。
（3）划分“训练-测试集”的单步预测：将全部数据按照一定比例划分成训练集和测试集，然后单步预测出于测试集相同长度的数据，并画图对比，计算若干评估指标。这种模式下预测精度较高，在某些趋势性强的数据中，预测结果可能会表现出“滞后性”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b8fc1469a4b9dab19a523cd4dbab141/" rel="bookmark">
			docker 安装rocketmq服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.创建namesrv服务 1： 拉取镜像 docker pull rocketmqinc/rocketmq 2：创建namesrv数据存储路径
mkdir -p /usr/docker/rocketmq/data/namesrv/logs /usr/docker/rocketmq/data/namesrv/store 3:构建namesrv容器
docker run -d \ --restart=always \ --name rmqnamesrv \ -p 9876:9876 \ -v /usr/docker/rocketmq/data/namesrv/logs:/root/logs \ -v /usr/docker/rocketmq/data/namesrv/store:/root/store \ -e "MAX_POSSIBLE_HEAP=100000000" \ rocketmqinc/rocketmq \ sh mqnamesrv 参数说明 参数说明-d以守护进程的方式启动--restart=alwaysdocker重启时候容器自动重启--name rmqnamesrv把容器的名字设置为rmqnamesrv-p 9876:9876把容器内的端口9876挂载到宿主机9876上面-v /usr/docker/rocketmq/data/namesrv/logs:/root/logs把容器内的/root/logs日志目录挂载到宿主机的 /usr/docker/rocketmq/data/namesrv/logs目录-v /usr/docker/rocketmq/data/namesrv/store:/root/store把容器内的/root/store数据存储目录挂载到宿主机的 /usr/docker/rocketmq/data/namesrv目录rmqnamesrv容器的名字-e “MAX_POSSIBLE_HEAP=100000000”设置容器的最大堆内存为100000000 单位是byterocketmqinc/rocketmq 使用的镜像名称sh mqnamesrv启动namesrv服务 二.创建broker节点 1：创建broker数据存储路径
mkdir -p /usr/docker/rocketmq/data/broker/logs /usr/docker/rocketmq/data/broker/store /usr/docker/rocketmq/conf 2：创建配置文件
vi /usr/docker/rocketmq/conf/broker.conf # 所属集群名称，如果节点较多可以配置多个 brokerClusterName = DefaultCluster #broker名称，master和slave使用相同的名称，表明他们的主从关系 brokerName = broker-a #0表示Master，大于0表示不同的slave brokerId = 0 #是否允许 Broker 自动创建Topic，建议线下开启，线上关闭 ！！！这里仔细看是false，false，false #原因下篇博客见~ 哈哈哈哈 autoCreateTopicEnable=true #是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭 autoCreateSubscriptionGroup=true #此参数控制是否开启密码 #aclEnable=true #表示几点做消息删除动作，默认是凌晨4点 deleteWhen = 04 #在磁盘上保留消息的时长，单位是小时 fileReservedTime = 48 #有三个值：SYNC_MASTER，ASYNC_MASTER，SLAVE；同步和异步表示Master和Slave之间同步数据的机制； brokerRole = ASYNC_MASTER #刷盘策略，取值为：ASYNC_FLUSH，SYNC_FLUSH表示同步刷盘和异步刷盘；SYNC_FLUSH消息写入磁盘后才返回成功状态，ASYNC_FLUSH不需要； flushDiskType = ASYNC_FLUSH # 设置broker节点所在服务器的ip地址 brokerIP1 = 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b8fc1469a4b9dab19a523cd4dbab141/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/516ea8e79e57e72cc584ac176cdfb522/" rel="bookmark">
			Python 实现一个简单的神经网络（附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
⭐前言⭐
⭐砖块：神经元⭐
📌一个简单的例子📌
📌编码一个神经元 📌
📌把神经元组装成网络 📌
📌例子：前馈📌
📌编码神经网络：前馈📌
📌训练神经网络 第一部分📌
📌损失📌
📌损失计算例子📌
📌代码：MSE损失📌
📌训练神经网络 第二部分📌
📌例子：计算偏导数📌
📌代码：一个完整的神经网络📌
📌后话📌
⭐前言⭐ 以下内容我们用Python从头实现一个神经网络来理解神经网络的原理。
首先让我们看看神经网络的基本单位，神经元。神经元接受输入，对其做一些数据操作，然后产生输出。例如，这是一个2-输入神经元：
这里发生了三个事情。首先，每个输入都跟一个权重相乘（红色）：
然后，加权后的输入求和，加上一个偏差b（绿色）：
最后，这个结果传递给一个激活函数f：
激活函数的用途是将一个无边界的输入，转变成一个可预测的形式。常用的激活函数就就是S型函数：
S型函数的值域是(0, 1)。简单来说，就是把(−∞, +∞)压缩到(0, 1) ，很大的负数约等于0，很大的正数约等于1。
📌一个简单的例子📌 假设我们有一个神经元，激活函数就是S型函数，其参数如下：
w=[0,1]，b=4
w=[0,1]就是以向量的形式表示w1=0，w2=1。现在，我们给这个神经元一个输入[2,3]。我们用点积来表示：
当输入是[2, 3]时，这个神经元的输出是0.999。给定输入，得到输出的过程被称为前馈（feedforward）。
📌编码一个神经元 📌 让我们来实现一个神经元！用Python的NumPy库来完成其中的数学计算：
import numpy as np def sigmoid(x): # 我们的激活函数: f(x) = 1 / (1 + e^(-x)) return 1 / (1 + np.exp(-x)) class Neuron: def __init__(self, weights, bias): self.weights = weights self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/516ea8e79e57e72cc584ac176cdfb522/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3786b082f265a193eb5c5e7b343049fa/" rel="bookmark">
			ADC Driver test
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** \brief AUTOSAR MCAL_test_adc ** ** This function contains the flow and implementation of the test ** ** */ #include &lt;Adc.h&gt; #include &lt;Adc_Cfg.h&gt; #include &lt;Adc_PBcfg.h&gt; #include &lt;Adc_Data.h&gt; #include &lt;Adc_Types.h&gt; #include &lt;Adc_Internal.h&gt; void test_adc(void) // Test code initialization and writing { uint8 adc_init; uint8 groupstarts; uint16 Adc_SetupResultBuffer[ADC_Group_2]; // ADC has three channel groups /** * @brief AdcGroup_SetupResultBuffer * * Description: Initializes ADC driver with the group specific result buffer start address * where the conversion results will be stored.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3786b082f265a193eb5c5e7b343049fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8246505de16667ef4049d698439e76b5/" rel="bookmark">
			Linux学习（课堂笔记 -可能不全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux是一个开源、免费的操作系统，其稳定性、安全性、处理多并发已经得到业界的认可。目前很多中型，大型甚至是集群项目都在使用linux，很多软件公司考虑到开发成本都首选linux，在中国软件公司的到广泛的使用
学习linux的流程为： 1、linux环境下的基本操作命令，包括文件操作命令（rm mkdir chmod，chown）编辑工具使用(vi vim)linux用户管理（useradd userdel usermod）
2、linux的各种配置（环境变量配置，网络配置，服务配置）
3、linux下如何搭建对应语言的开发环境（大数据,JavaEE,Python）
4、能编写shell脚本，对Linux服务器进行维护
5、能进行安全设置，防止攻击，保障服务器正常运行，能对系统调优
6、深入理解Linux系统（对内核有研究）。熟练掌握大型网站应用架构组成、并熟悉各个环节的部署和维护方法
## Linux介绍 1、Linux怎么读（里牛渴死，利尼克斯，里那棵四）
2、Linux是一款操作系统，免费，开源，安全，高效，稳定，处理高并发非常强悍，现在很多的企业项目都部署到Linux服务器运行
3、Linux创始人：林纳斯
4、Linux吉祥物为：企鹅 tux
5.Linux主要发行版本
6、目前主要操作系统
windows ，android，车载操作系统
## Linux和Windows的区别 ## 安装VM和centos 学习Linux需要一个环境，我们需要创建一个虚拟机，然后虚拟机上安装一个Centos系统来学习 1.先安装 virtual machine , vm12
2.在安装Linux（CentOS 6.8）
3.原理示意图
## Linux目录结构 基本介绍： linux的文件系统是采用级层式的树状目录结构，再次结构中的最上层是根目录" / "，然后再次目录下在创建其他的目录
在Linux的世界里，一切皆文件
具体目录结构：
/bin （重点） (/user/bin 、/ user/local/bin) *是Binary的缩写，这个目录存放着最经常使用的命令 /sbin （/user/sbin 、 /user/local/sbin） *s就是Super User 的意思，这里存放的是系统管理员使用的系统管理程序 /home （重点） *存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以 用户的账号命名的。 /root （重点） *该目录为系统管理员，也称作为超越权限这的用户主目录。 /lib *系统开机所需要最基本的动态链接共享库，起作用类似于Windows里的DLL文件，几乎所有的应用程序都需要用到这些共享库 /lost+found *这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件 /ect（重点） *所有系统管理所需要的配置文件和子目录 my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8246505de16667ef4049d698439e76b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d351212c2a9ebb976fabdb9c61b25e11/" rel="bookmark">
			Docker swarm 通过 docker-compose 部署应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker swarm 通过 docker-compose 部署应用 文章目录 Docker swarm 通过 docker-compose 部署应用1 初始化swarm2. 创建 Docker Compose 文件3. 部署服务 1 初始化swarm 默认情况下，Docker作为一个隔离的单节点工作。所有容器仅部署在引擎上。群模式将它变成了一个多主机集群感知引擎。
为了使用秘密功能，Docker必须处于“群模式”。这是通过
$ docker swarm init Swarm initialized: current node (ean4r3wx8dutbj2hlkp4lsfu0) is now a manager. To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-2t5z3yzsmq4xlhilsuh04ltiprnqt1h1cv8gmmaq6eip3day99-advgpojck21b1hlh3v6vgpncq 172.17.0.86:2377 To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions. 在第二台主机上执行下面的命令，将它作为一个worker添加到集群中。
$ token=$(ssh -o StrictHostKeyChecking=no 172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d351212c2a9ebb976fabdb9c61b25e11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76eac4dc7bd0aaa70b1c84ef8ef78c3d/" rel="bookmark">
			ts 严格模式下 对象可能为“未定义”。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次用严格模式
严格模式下定义完属性 使用的时候可能会出现 对象未定义错误
因为ts无法分辨这条代码执行的时候他有没有被定义 所以我觉得加个判断就好了
加完if发现报错是取消了的
然后可以用问号？直接简化
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9abbedde418604fdc049923594af03ed/" rel="bookmark">
			vue(七)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组件的自定义事件 1. 一种组件问通信的方式，适用于 子组件===&gt;父组件
2.使用场量: A是父组件。B是子组件。B想给A传数据，那么就要在A中给B绑定自定义事件(事件的回调在A中)。
3.绑定自定义事件:
1.第一种方式，在父组件中: &lt;Demo @atguigu-"test"/&gt; 或&lt;Demo v-on:atguigyu-"test"/&gt;
2.第二种方式。在父组件中:
&lt;Dome ref="demo"/&gt; mounted(){ this.$refs.xxx.$on("atguigu" ,this.test) } 3.若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法。
4.触发自定义事件: this.$emit("atguigu" ,数据)
5.解绑自定义事件this.off(" atguigu')
6.组件上也可以绑定原生DOM事件，需要使用native修饰符。
7.注意:通过this. $refs.xxx.$on( 'atguigu' ,回调)绑定白定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题!
实例： app.vue &lt;template&gt; &lt;div id="app"&gt; &lt;h2&gt;xxx:{{name}}&lt;/h2&gt; &lt;!--通过父组件给子组件绑定一个自定义事件实现:子给父传递数据 (第一种写法。使用@或v-on)--&gt; &lt;School @atguigu="getSchoolName" /&gt; &lt;!--通过父组件给子组件绑定一个白定义事件实现: 子给父传递数据(第二种写法。使用ref)--&gt; &lt;Student ref="student" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import School from './components/School' import Student from './components/Student' export default { name: 'App', data() { return { name:"" } }, components: { School, Student }, methods: { getSchoolName(name) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9abbedde418604fdc049923594af03ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d65c28a3ca16a9c2a5c004343e5ac1c/" rel="bookmark">
			java语言 eclipse lombok的@data无法生效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因分析： 在项目开发中发现eclipse的lombok的@data无法生效，这是有两种可能，一是没有下载，一是没有载入。
解决方案： 一、在eclipse上下载lombok.jar 1、 打开eclipse.exe所在文件的目录。2、 下载lombok.jar包3、 将lombok.jar包放到eclipse.exe所在的文件目录下。
4、 在此页面上右键选择cmd。（如果没有cmd的话，点击开始键+R,输入cmd点击回车，到达eclipse.exe所在文件目录），然后输入命令 java -jar lombok.jar(如果lombok带版本号，输入的时候要带上版本号)
5、 点击回车后，这时候会出现下载的页面
6、 首先看1号的位置，一般情况下会自动扫描到eclipse.exe，如果没有扫描到，点击2号位置sepecify location，手动选择电脑中的eclipse.exe(注意：eclipse.exe的文件要全是英文，如果出现了中文字符，需要先修改目录文件夹，否则下载完之后会出现闪退的情况！！！)，选择完之后点击3号位置install进行下载。 二、 lombok.jar导入 1、 如果你已经导入，那么下载完之后重启eclipse就可以使用了2、 在项目中创建lib文件夹，将lombok.jar导入到lib文件夹下
3、 点击lonbok.jar右键，点击Bulid Path-&gt;Add to Build Path
4、 如果在Reference Libraries文件夹下出现lombok.jar，则表示导入完成了
总结 如果出现闪退的话，查看路径当中是否出现中文字符，查看eclipse.ini文件当中是否出现下面类似的语句，如果出现则表示下载成功了。
也可以直接在eclipse.ini中直接添加语句，但是注意路径以及文件夹名称一定要正确，否则会出现闪退情况如果还没有解决的话，只能手动输入方法了
希望可以帮助到大家，如果存在问题的话，欢迎大家阅读和指正！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/212460abe2e037f615d43285633a0326/" rel="bookmark">
			resize()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		resize()，设置大小（size）;
reserve()，设置容量（capacity）;
size()是分配容器的内存大小，而capacity()只是设置容器容量大小，但并没有真正分配内存。
打个比方：正在建造的一辆公交车，车里面可以设置40个座椅（reserve(40);），这是它的容量，但并不是说它里面就有了40个座椅，只能说明这部车内部空间大小可以放得下40张座椅而已。而车里面安装了40个座椅(resize(40);)，这个时候车里面才真正有了40个座椅，这些座椅就可以使用了
1、resize(n) 调整容器的长度大小，使其能容纳n个元素。
如果n小于容器的当前的size，则删除多出来的元素。
否则，添加采用值初始化的元素。
2、 resize(n，t)
多一个参数t，将所有新添加的元素初始化为t。
而reserver()的用法只有一种
reserve(n)
预分配n个元素的存储空间。
了解这两个函数的区别，首先要搞清楚容器的capacity（容量）与size（长度）的区别。
size指容器当前拥有的元素个数；
而capacity则指容器在必须分配新存储空间之前可以存储的元素总数。
也可以说是预分配存储空间的大小。
resize()函数和容器的size息息相关。调用resize(n)后，容器的size即为n。
至于是否影响capacity，取决于调整后的容器的size是否大于capacity。
reserve()函数和容器的capacity息息相关。
调用reserve(n)后，若容器的capacity&lt;n，则重新分配内存空间，从而使得capacity等于n。
如果capacity&gt;=n呢？capacity无变化。
从两个函数的用途可以发现，容器调用resize()函数后，所有的空间都已经初始化了，所以可以直接访问。
而reserve()函数预分配出的空间没有被初始化，所以不可访问。
resize() 相当等同于 new 一个新的数组开辟空间
学习于此https://www.jianshu.com/p/4d08a58b9946
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/184b59ef96faad0cba8b30f8eb4d729c/" rel="bookmark">
			网络故障排查：Ping和Tracert命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Ping和Tracert的用途
1.1 Ping和Tracert命令检查网络连接是否可达以及分析网络发生故障的位置。其中，Ping用于检查网络连接及主机是否可达；Tracert命令用于测试数据报文从发送主机到目的地所经过的网关。
2、Ping命令简介
2.1 Ping命令主要用于检查网络连接及主机是否可达。Ping功能是基于ICMP协议来实现的：源端向目的端发送ICMP请求（ECHO-REQUEST）报文后，根据是否收到目的端的ICMP应答（ECHO-RESPONSE）报文来判断目的端是否可达。对于可达的目的端，再根据发送与接收报文个数、Ping报文的往返的响应时间来判断链路的质量。
3、Ping命令格式
3.1 由于每个操作系统，参数不同，当前已windows举例：
3.2 ping [ -n number ] [ -t ] [ -l number ] [ -f ] [ -a ] ip-address
-n：ping报文的个数，缺省值为5。
-t：持续地ping直到人为中断，Ctrl+Break暂时中止ping命令并查看当前的统计结果，而Ctr+C则中断命令的执行。
-l：设置ping报文所携带的数据部分的字节数，设置范围从0至65500。
-f：设置发送的报文不分片，如果报文大于MTU值，则会丢弃该报文。
-a：反向解析IP地址为主机名。
&lt;Huawei&gt; ping 10.135.18.118 PING 10.135.18.118: 56 data bytes, press CTRL_C to break Reply from 10.135.18.118: bytes=56 Sequence=1 ttl=255 time=1 ms Reply from 10.135.18.118: bytes=56 Sequence=2 ttl=255 time=1 ms Reply from 10.135.18.118: bytes=56 Sequence=3 ttl=255 time=2 ms Reply from 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/184b59ef96faad0cba8b30f8eb4d729c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df985eeac74f7bc5b0f7e879c6087970/" rel="bookmark">
			JVM -- 垃圾收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		垃圾收集 几个名词强软弱须GC类型Minor GC(年轻代GC)Major GC/Full GC (老年代GC)Full GC STW(Stop the world)GC停顿为什么需要STW TLAB(Thread Local Allocation Buffer))逃逸分析(Escape Analysis)逃逸优化 垃圾收集器Serial收集器ParNew收集器Parallel收集器Serial Old收集器Parallel Old收集器CMS收集器CMS收集器工作分四个步骤CMS缺点 G1收集器G1垃圾回收原理G1收集器工作分四个步骤G1缺点 记忆集-卡表跨代引用卡表 GC日志日志内容 几个名词 强软弱须 强引用
平时写的代码如Test obj = new Test()；这种引用关系就是强引用就算会OOM也不会回收
软引用内存不足的情况下才会回收如果发生了gc但是内存充足，依然不会回收
弱引用只有发生gc就会回收
虚引用形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动 GC类型 分代就是优化GC性能,把那些朝生夕死(新生代)的与链接对象(老不死的老年代)分开做垃圾收集
Minor GC(年轻代GC) Eden区满的时候会触发MinorGC,Survivor不会触发GC,Survivor随着Eden区MinorGC时一同被清理大多数对象都是朝生夕死MinorGC出现的频率相对较高,STW时间相对较短 Major GC/Full GC (老年代GC) 出现Major GC,经常会伴随Minor GC,老年代空间不足的时候会先尝试触发MinorGC,如果还不够再触发MajorGCMajorGC比MinorGC慢10倍以上,会导致STW时间更长MajorGC后空间还不足就会OOM Full GC 调用System.gc(),系统建议执行FullGC,但是不一定执行老年代空间不足方法区空间不足MinorGC后进入老年代的平均占用内存大小大于老年代可用空间从Eden区+s0复制到s1区时,s1区大小存不下该对象,则把该对象转存到老年代,且老年代的可用内存也小于该对象 STW(Stop the world) GC停顿 在执行GC时,jvm会停止其他用户线程的操作,防止产生新垃圾,会导致用户线程出现暂停,GC之后程序计数器和字节码执行引擎会继续从暂停处继续执行用户线程,对用户来说出现了短暂的卡顿,体验收到影响 为什么需要STW GC是从线程的gc root出发,对这个gc root链路可达性分析,如果没有stw,一次GC从gc root出发的时候用户线程依然在运行,发现当前方法的gc root有应用,不是垃圾,但是稍后用户线程执行完成了,又变成了垃圾,导致这种情况的垃圾没法回收,这样会导致GC效果差,性能低下,所以出现STW,即GC停顿 TLAB(Thread Local Allocation Buffer)) 堆内存共享,多线程情况下存在线程安全问题,加锁又会导致性能下降,所有未每个线程分配一个私有的缓存区域,包含在Eden空间内多线程情况下,使用TLAB就可以避免线程安全问题,同时提升内存分配的吞吐量,因此被称为快速分配策略使用-XX:UserTLAB 设置是否开启TLAB空间,默认开启TLAB且只占有Eden区的1%,但JVM将TLAB作为内存分配的首选,可以通过-XX:TLABWasteTargetPercent设置占比如果TLAB分配失败,JVM就会尝试通过加锁机制确保数据的原子性,从而直接在Eden区分配内存 逃逸分析(Escape Analysis) 经过逃逸分析后发现,如果一个对象并没有逃逸出方法,就可能被优化为栈上分配,能使用局部变量的就不用定义为成员变量,-XX : +DoEscapeAnalysis 开启逃逸分析(默认开启)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df985eeac74f7bc5b0f7e879c6087970/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/febf54b9ea8abdd2bf5a09d276094a15/" rel="bookmark">
			python运行异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常信息：
UnicodeEncodeError: 'UCS-2' codec can't encode characters in position 82-82: Non-BMP character not supported in Tk
解决方法：在代码前加入：
non_bmp_map = dict.fromkeys(range(0x10000, sys.maxunicode + 1), 0xfffd)
异常信息：greet是个类名 在greet = greet()，在for循环实例化时第二次会出现这个异常。
TypeError: 'greet' object is not callable
解决方法：
因为我变量名和函数名写重复，修改：g = greet()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edcd7f3e39b176128238a464fc213ab2/" rel="bookmark">
			生成随机数，用户猜数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 编写一个猜数字的游戏，由计算机随机产生一个数字（1-100），由用户去猜，只显示大了或小了，直到猜中为止 源代码 //编写一个猜数字的游戏，由计算机随机产生一个数字（1-100），由用户去猜，只显示大了或小了，直到猜中为止 import java.util.Random; import java.util.Scanner; public class sjs { public static void main(String[] args) { Random x=new Random(); int y=x.nextInt(100)+1;//生成随机数 Scanner sc=new Scanner(System.in); System.out.println("请您输入数字"); while(true){ int a=sc.nextInt(); if(a==y) { System.out.println("恭喜您，您猜中了"); break; }else{ if(a&lt;y){ System.out.println("您输入的数字小了"); } else{ System.out.println("您输入的数字大了"); } } } System.out.println("随机数是"+y); } } 运行截图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b92ccf4b3fddd7cc1b50684af28a575/" rel="bookmark">
			Redis——跳跃表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跳跃表skiplist 本质是分层有序链表，从高层到低层，相隔的结点个数以指数形式增长，空间换时间，插入删除查找的时间复杂度都是log(N)，大致的结构为：
两个重要的结构体 //跳跃表的节点，从图中第二列到第8列展示的都是这个节点 typedef struct zskiplistNode { sds ele; double score; struct zskiplistNode *backward;//指向后面一个节点 struct zskiplistLevel { struct zskiplistNode *forward; unsigned long span;//表示跨度，指向的下一个节点跨了几个节点 } level[];//这里是一个数组，有多少个就表示多少层 } zskiplistNode;//这也是一个柔性数组 //跳跃表，两个指针分别指向头部和尾部的节点 //仔细说来，这个header并不是一个真正的节点 typedef struct zskiplist { struct zskiplistNode *header, *tail; unsigned long length; int level; } zskiplist; 里面中的span项在代码中占据了很大的比重，对于span的解释可以看这个博客：
如何理解redis跳表源码中的span？
总的来说这个span可以让我们方便的计算查找节点在整个跳跃表的排序，有了span我们可以清除的知道，这一次跳了几个，一累加就是最终的排序。
创建和释放 创建 #define ZSKIPLIST_MAXLEVEL 32 //最多32层，足够容纳2^64 个元素 /* Create a skiplist node with the specified number of levels. * The SDS string 'ele' is referenced by the node after the call.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b92ccf4b3fddd7cc1b50684af28a575/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12f705218026bf0904372203d491db71/" rel="bookmark">
			Cadence Allegro导入结构及Subdrawing技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 AD导出DXF，再使用allegro inport进去。
1.1 AD导出dxf
File-&gt;export-&gt;DXF/DWG.
export之前务必需要将单位设置为inch。仅打开需要导出的层面。
Export to AutoCAD窗口：AUTOCAD Version: 2004; Format: DXF;Unit: imperial.
勾选Export pads and via hole. Layers: Currently Visible Layers
其他默认就好。
1.2 Allegro导入dxf：
File-&gt;import-&gt;dxf in
导入之前一定要将单位修改为inch（setup-&gt;Design Parameters-&gt;Design中修改）
DXF in窗口：选择DXF；DXF unit:inch; Edit/View Layers:编辑层之间的对应关系。
此处需要新建一个DXF layer：Setup-&gt;Subclasses: 在Board geometry中建立一个dxf layer。
选中需要MAP的层。Map selected items的窗口下。
Class：Board Geometry. Subclass: DXF xxxx
点MAP，完成层与层之间的一一对应的关系，OK
点击Import。
import完成后，整个Board Geometry的颜色设置都变了，包括Outline。所以此时需要将导入的dxf subdrawing出去。
subdrawing之前，需要将单位改成mil。
后面就是import subdrawing与export subdrawing的事情了。
2 Cadence导出源Subdrawing，Cadence导入目标subdrawing
2.1 Cadence导出源Subdrawing
File-&gt;export-&gt;subdrawing。
勾选需要的object，一般是line &amp; other segs。
选中需要subdrawing的line &amp; other segs，选择export的基准点，一般选择某个circle的中心点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12f705218026bf0904372203d491db71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9acab71aeba78b86b235d4cd4aec90d1/" rel="bookmark">
			几个优质的AI方向公众号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当今人工智能的学习资料繁多且无用，如何从中筛选有用的资料并能高效的转化为自己的知识是非常关键的。小编推荐几个原创度比较高的人工智能方向的公众号，祝你再越来越卷的人工智能领域，早日达成自己的梦想！
机器学习初学者
致力于为机器学习初学者提供学习路线和基础资料，含慕课和代码、教案等，建议收藏！
点击上方名片可关注
深度学习基础与进阶
号主是知名985高校计算机硕士，现为腾讯人工智能算法工程师，为读者提供计算机视觉、自然与语言处理和推荐系统等人工智能领域最前沿和最经典的知识，让你的学习不再碎片化。 ‍ 点击上方名片可关注
深度学习与图网络
大火了5年的图神经网络你有了解过吗？深度学习与图网络公众号专注深度学习，图神经网络的干货内容，日常分享一些前沿的技术，包括深度学习、图神经网络技术、ICML/NeurIPS/ICLR最新前沿论文海内外博士找教职，大厂找工作等海内外硕博招生，内容有点硬核，欢迎关注。
点击上方名片可关注 磐创AI
今天给大家推荐一个老牌AI团队--磐创AI。他们是最早做AI公众号的老牌团队之一，累计输出原创 深度学习技术文章450余篇。涵盖 Keras原创专栏、TensorFlow原创专栏、Pytorch原创专栏 和 热点机器学习资源系列专栏等。磐创AI作者团队已出版技术书籍《Tensorflow从零开始学》、另撰有两本即将要出版的Keras、PyTorch书籍，书中部分内容均会优先同步在公众号中进行更新！！！另外还会定期送些小福利。值得关注！！！
点击上方名片可关注
机器学习算法与Python实战
机器学习算法与Python实战，号主是华科统计学硕士，现为金融科技公司数据分析师，有着丰富的项目经验。号主有200余篇原创文章，内容涵盖统计学、数据分析、机器学习、深度学习、Python实战，《100天搞定机器学习》专栏已更新至第62天，定期整理相关的免费学习资源。
点击上方名片可关注 pythonic生物人
pythonic生物人，系统分享Python、R、机器学习、统计等数据科学干货，目前已狂肝Python/R可视化100+篇、Python精进50+篇、统计精进等数篇！
点击上方名片可关注 数据studio
🏴‍☠️宝藏级🏴‍☠️ 原创公众号 『数据STUDIO』，内容超级硬核，近一年内持续分享170+篇超高质量原创干货。公众号以Python为核心语言，垂直于数据科学领域，包括 Python｜MySQL ｜数据分析｜可视化｜机器学习与数据挖掘｜爬虫等相关知识，从入门到进阶！关注后回复【福利】，领取见面礼！
点击上方名片可关注
深度学习初学者
专注于机器学习，深度学习以及计算机视觉等研究方向，每天会更新人工智能最前沿知识和分享自己的论文总结和学习笔记，让你系统化的学习每个知识点，每天进步一点点。
点击上方名片可关注
机器学习算法那些事
一个百度人的技术提升之路，为您提供一系列计算机视觉，自然语言处理和推荐系统等高质量技术文章，让您的碎片化时间最大价值化。同时会不定期分享精品免费视频和资源，让您的技术之路不再单调枯燥。
点击上方名片可关
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/297c80b0b6b4d75a15b60bf507a4b771/" rel="bookmark">
			ACTF出题(dropper&#43;master_of_dns)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前序 在xctf分站赛中出了两道题，分别是dropper和master_of_dns，两道题都偏简单一点，dropper解题31个队，master_of_dns解题三个队，可能是第二天放题的缘故。
出题思路 出题源码 自己的题解：https://github.com/zdy/ACTF2022-problem
官方题解：https://github.com/team-s2/ACTF-2022
dropper 使用这个工具Dropper在外面加一层壳，这个方法是绕恶意软件检测模型提出的, 使用异常处理更改代码执行路径（使用异常处理进行虚函数表hook）,真实软件是c++面向对象的flag加密代码(使用了大数运算)
考点总结：upx壳+dropper+大数运算+异常处理+虚函数表hook
master_of_dns 使用dnsmasq软件，patch dns域名解析的位置，设置一个栈溢出漏洞(源码修改的非常少)，因为是栈溢出，所以利用方法也很多，这里也加了些东西干扰diff
考点总结：dns协议 + dns域名指针的用处 + diff找出漏洞
题解 dropper 使用upx加壳工具脱掉壳，如果不能运行，关掉文件的aslr标志位，关闭DYNAMIC_BASE通过dropper搜索相关含义，找到从资源区获取数据并加密的代码，如果可以找到https://github.com/marcusbotacin/Dropper， 那基本离解题更进一步 没找到运行PE文件的函数交叉引用，猜测是使用了GetProcAddress，利用交叉引用找到对应地方 静态分析找到，或者动态跟踪找到对应的数据，分析解密，写脚本将数据解密，生成真正的可执行文件 这里还是比较简单的，就是做了个异或某个数字 动态调试跟踪，可以跟踪到加密和验证的所有过程，并不复杂，这里只是加了反静态分析的方法，利用简单的除0进行异常捕捉进行虚函数表hook，使得静态分析失效 可以输入flag后，对text区下断点，获得处理逻辑地址，在IDA中找到之后，设置断点，进行跟踪 猜测生成的大数是如何存储的，动态调试找到存储数据的地址空间，并尝试将十六进制转换为十进制，可以看到十进制只以十六进制存储。 根据IDA的string，发现BASE64的字符串表，根据交叉引用，找到真正的加密判断地址 也可以使用动态调试，打开文件，运行到“flag:”，停止当前进程，然后附加到被创建的子进程，就可以动态调试被生成的子进程。解密代码 import base64 res = 834572051814337070469744559761199605121805728622619480039894407167152612470842477813941120780374570205930952883661000998715107231695919001238818879944773516507366865633886966330912156402063735306303966193481658066437563587241718036562480496368592194719092339868512773222711600878782903109949779245500098606570248830570792028831133949440164219842871034275938433 res = res + 57705573952449699620072104055030025886984180500734382250587152417040141679598894 res = res - 71119332457202863671922045224905384620742912949065190274173724688764272313900465 res = res + 55079029772840138145785005601340325789675668817561045403173659223377346727295749 res = res - 14385283226689171523445844388769467232023411467394422980403729848631619308579599 res = res + 80793226935699295824618519685638809874579343342564712419235587177713165502121664 res = res // 7537302706582391238853817483600228733479333152488218477840149847189049516952787 res = res - 17867047589171477574847737912328753108849304549280205992204587760361310317983607 res = res + 55440851777679184418972581091796582321001517732868509947716453414109025036506793 res = res // 11783410410469738048283152171898507679537812634841032055361622989575562121323526 res = res - 64584540291872516627894939590684951703479643371381420434698676192916126802789388 s = '' while res: s += chr(res % 128) res = res // 128 print(base64.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/297c80b0b6b4d75a15b60bf507a4b771/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c12db0a9d9045c342d587b64af5d31d4/" rel="bookmark">
			【无标题】Vue3之script-setup全面解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue3之script-setup全面解析 - 简书
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e805613e15f2a6891cb7f59183bc2b6/" rel="bookmark">
			Tomcat -- 启动流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动流程 web概念tomcat启动原理启动流程启动源码源码跟踪startup.bat 启动文件catalina.bat (bootstrap.jar)启动入口 Bootstrap.main Bootstrap初始化组件初始化Bootstrap -- bootstrap.init加载Bootstrap -- daemon.load(args)加载Catalina -- Catalina.load初始化Server -- Lifecycle.init()初始化Service -- service.init初始化Connector -- Connector.initInternal初始化ProtocolHandler初始化EndPoint -- AbstractEndpoint.init绑定Servlet Bootstrap启动启动Bootstrap -- bootstrap.start启动Catalina.start启动Server -- Lifecycle.start启动Service -- StandardService.startInternal启动Connector -- Connector.startInternal启动ProtocolHandler -- AbstractProtocol.start启动EndpointAcceptor接收器 -- socket.accept web概念 软件架构
a. C/S：客户端、服务器端架构，如微信，QQ
b. B/S：浏览器、服务器端架构，如淘宝等门户网站资源类别
a. 静态资源：所有用户访问得到的结果都一样，称为静态资源，可以直接被浏览器解析，如html、css、jpg等
b. 动态资源：每个用户访问得到的结果可能不一致，动态资源被访问后需要先转换为静态资源，再返回给浏览器，由浏览器解析，如：jsp、servlet等网络三要素
a. ip：电子设备在网络的唯一标识
b. 端口：应用程序在计算机中的唯一标识
c. 传输协议：规定数据传输的规则 tomcat启动原理 加载tomcat配置文件，初始化容器组件，监听对应的端口号，准备接受客户端请求
启动流程 启动tomcat，执行bin/startup.bat脚本，调用catalina.bat脚本执行调用BootStrap中main方法，调用init方法，通过反射创建Catalina对象及初始化类加载器main方法中调用load方法，会调用Catalina的load方法Catalina的load方法会进行Server中的一系列主键的初始化工作，并构造Digester对象，负责解析XML加载tomcat配置文件，初始化容器组件，监听对应的端口号，准备接受客户端请求 启动源码 生命周期方法（Lifecycle）
所有组件都存在初始化、启动、停止等生命周期方法，tomcat基于生命周期管理抽象成Lifecycle接口组件Server、Service、Container、Executor、Connector都实现Lifecycle，通过Lifecycle统一管理个组件的生命周期接口
○ init：初始化组件接口
○ start：启动组件接口
○ stop：停止组件接口
○ destroy：销毁组件接口 组件默认实现
源码跟踪 startup.bat 启动文件 :okHome //调用catalina.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e805613e15f2a6891cb7f59183bc2b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f03caddec01a82eb1da104ac0fca28a0/" rel="bookmark">
			matlab线性与非线性规划问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
线性规划的Matlab标准式 linprog函数
线性规划例题
无约束条件的最小化：fminunc()函数
实例：求解无约束非线性函数的最小值 有约束条件最小化函数：fminco()函数
实例：求解有约束条件最小化函数 二次规划 二次规划实例
线性规划问题是在一组线性约束条件的限制下，求一线性目标函数最大或最小的问题。 线性规划的Matlab标准式 min f(x)
s.t. Ax &lt;= b
Aeq*x = beq
lb &lt;= x &lt;= ub
linprog函数 x = linprog(f,A,b); % 求解问题:min fx 约束条件:Ax&lt;=b
x = linprog(f,A,b,Aeq,beq); % 增加等式约束,即Aeqx=beq,若无不等式存在则A=[];b=[];
x = linprog(f,A,b,Aeq,beq,lb,ub); % 定义变量x的上界lb和下界ub,若无等式约束则Aeq=[];beq=[];
x = linprog(f,A,b,Aeq,beq,lb,ub,x0); % 设置初始值x0
x = linprog(f,A,b,Aeq,beq,lb,ub,x0,options); % 用options指定的优化参数进行最小化
[x,fval] = linprog(...); % 返回x处的目标函数fval
线性规划例题 max z = 2x1 + 3x2 - 5x3
s.t. x1 + x2 + x3 = 7
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f03caddec01a82eb1da104ac0fca28a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5575ee9bd76e298963b0473c42209c9/" rel="bookmark">
			Mysql数据库常用数据类型介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.整数类型 1.1 tinyint tinyint 为小整数类型，存储空间为1个字节(8位)，有符号范围-128 ~ 127，无符号范围 0 ~ 255,此类型通常在数据库中表示类型的字段，如某一字段 type 表示学科,其中 “type=1” 表示语文，“type=2” 表示数学, “type=3” 表示英语，此时 type 字段即可使用 tinyint 这种存储空间比较小的类型。
1.2 smallint smallint 为小整数类型，存储空间2个字节(16位),有符号范围 -32768 ~ 32767，无符号范围 0 ~ 65535，当遇到最大值不超过 65535 的整数类型字段时，可使用无符号 smallint 类型。
1.3 mediumint mediumint 为中整数类型，存储空间3个字节(24位)，有符号范围 -8388608 ~ 8388607，符号范围 0 ~ 16777215，当遇到最大值不超过 16777215 的整数类型字段时，可使用无符号 mediumint 类型。
1.4 int int 为整数类型，存储空间 4 个字节 ( 32位 )，有符号范围 -2147483648 ~ 2147483647，无符号范围 0 ~ 49294967295，当遇到最大值不超过 49294967295 的整数类型字段时，可使用无符号 int 类型，通常自增主键 id 使用 int 类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5575ee9bd76e298963b0473c42209c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/741daa6127fe58214369f1452a6be799/" rel="bookmark">
			Java高频面试复习题，助你面试成功
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 2022年对程序员来说是特别严峻的一年，也是大改革的一年，大部分人因为今年“疫情”的原因纷纷离开了自己原有的岗位，也有人抓住机会逆流而上拿到更高的待遇！
2022年金九银十已经到来了，试问你进入了自己心仪的企业了吗，拿到自己满意的薪资待遇了吗？
无论如何在这两个月的跳槽黄金期 筹备面试是最重要的了，你有规划好自己的复习方向了吗？
我这里收集了一套大厂的面试题包含了答案，技术点概括了：基础、JVM、多线程并发、spring、mybatis、springboot、mysql、Redis、springcloud、Nginx、ZK、kafka、MQ、数据结构与算法、Linux、Elasticsearchi以及还有简历方面的文案，对你应该会有所帮助！
话不多说，上正题
数据结构与算法面试 1.常用的数据结构2.数据里有{1,2,3, 4,5,6,7.8,9}，请随机打乱顺序，生成一个新的数组(请以代码实现)3.写出代码判断一 个整数是不是2的阶次方( 请代码实现，谢绝调用API方法)4.假设今日是2015年3月1日，星期日，请算出13个月零6天后是星期几，距离现在多少天(请用代码实现，谢绝调用API方法)5.有两个篮子，分别为A和B,篮子A里装有鸡蛋，篮子B里装有苹果，请用面向对象的思想实现两个篮子里的物品交换(请用代码实现) JVM面试 1.知识点汇总2.知识点详解:3.类加载与卸载4.简述一下JM的内存模型5.堆和栈的区别6.什么时候会触发FullC7.什么是Java虚拟机?为什么Java被称作是“平台无关的编程语言8.Java内存结构9.对象分配规则10.描述一下J加载class文件的原理机制?11.Java对象创建过程12.类的生命周期13.简述Javs的对象结构14.如何判断对象可以被回收?15.JVM的永久代中会发生垃圾回收么?16.垃圾收集算法17.调优命令有哪些?18.调优工具19.Minor GC与Full GC分别在什么时候发生?20.你知道哪些JM性能调优21.JYM内存分哪几个区，每个区的作用是什么?22.简述J ava垃圾回收机制?23.什么是类加载器，类加载器有哪些?”24.你有没有遇到过OutOfMemory问题?你是怎么来处理这个问题的?处理过程中有哪些收获?26.跟JTM内存相关的几个核心参数图解27.如何启动系统的时候设置JVM的启动参数 多线程、并发面试 1.Java中实现多线程有几种方法2.如何停止-个正在运行的线程3.noti fy 0和noti fyAll 0有什么区别?4.sleep 0和waitO有什么区别5.volatile是什么?可以保证有序性吗?6.Thread 类中的start0和run0方法有什么区别?7.为什么wait, notify 和notifyA11这些方法不在thread类里面?8.为什么wai t和noti fy方法要在同步块中调用?9.Java中interrupted和isInterruptedd方法的区别?10.Java中synchronized和Reentr antLock有什么不同?11.有三个线程T1, T2, T3,如何保证顺序执行?12.Symchr oni Ie dMap和C oncurrentHashMap有什么区别?13.什么是线程安全14.Thread类中的yi el a方法有什么作用?15.Java线程池中submitO和execute 0方法有什么区别?16.说-说自己对于synchronized关键字的了解17.说说自己是怎么使用symchronized关键字，在项目中用到了吗synchr oni zed关键字最主要的三种使用方式:18.什么是线程安全? Vector是一个线程安全类吗?19.volatile关键字的作用?20.常用的线程池有哪些?21.简述一下你对线程 池的理解22.Java程序是如何执行的23.说一说自己对于synchronized关键字的了解24.说说自己是怎么使用synchronized关键字，在项目中用到了吗25.讲一下synchronired 关键字的底层原理26.为什么要用线程池?27.实现Runnabl e接口和Callable接口的区别28.执行execute 0方法和submi t0方法的区别是什么呢?29.如何创建线程池 基础面试 1.Java语言有哪些特点2.面向对象和面向过程的区别3.八种基本数据类型的大小，以及他们的封装类4.标识符的命名规则。5.instanceof 关键字的作用6.Java自动装箱与拆箱7.重载和重写的区别8.equa1s与==的区别9.Hasheode的作用10.String\ String StringBuffer和StringBuilder 的区别是什么?11.ArrayList和1inke aList的区12.HashMap和HashT able的区别13.Collecti on包结构，与Collecti ons的区别14.Javs的四种引用，强弱软虚15.泛型常用特点16.Jav创建对象有几种方式?17.有没有可能两个不相等的对象有相同的hasheode18.深拷贝和浅拷贝的区别是什么?19.final有哪些用法?20.stati 都有哪些用法?21.3*0. 1==0. 3返回值是什么22.a=a+b与a+=b有什么区别吗?23.try catch finally; try里有return, finally还执行么?24.Exepti on与Error包结构25.00M你遇到过哪些情况，SOF你遇到过哪些情况26.简述线程、程序、进程的基本概念。以及他们之间关系是什么27.线程有哪些基本状态?28.Java序列化中如果有些字段不想进行序列化，怎么办?29.Java中I0流30.Java I0与HI0的区别31.java反射的作用于原理32.说说List, Set, Map三者的区别? Spring面试 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/741daa6127fe58214369f1452a6be799/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4260248ef1eb375d2d2dde6ec3b32237/" rel="bookmark">
			pycharm不能输入中文解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、Pycharm编译器汉化 1.左上角打开file（文件）—&gt;setting（设置）—plugins（插件） 2.搜索chinese,点击安装(install) 3.安装完根据提示重启就行 2、pycharm输入法不能输入中文 1.点击菜单“Help”——“Edit Custom VM options...” 2.添加以下代码 -Drecreate.x11.input.method=true 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/590c391c43eb7650b5ea00362a90cb4f/" rel="bookmark">
			Mac电脑（苹果电脑）Qt 菜单栏不显示的问题解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、代码模式下（纯代码创建菜单栏模式）
1.1 、没有菜单栏代码：
1.2 、解决方法添加：自己的类-&gt;setNativeMenuBar(false);
2、设计师模式下（即UI模式下）
我所遇到的问题，并不是qt for mac 不显示菜单栏，而是菜单栏显示到Mac 菜单栏上去了，我想让Qt 菜单栏显示位置和win 系统下一样，不管是在纯代码环境和UI 设计环境下都需要修改setNativeMenuBar 参数设置具体方法如下
1、代码模式下（纯代码创建菜单栏模式） 1.1 、没有菜单栏代码： #include "mainwindow.h" #include&lt;qmenubar.h&gt; #include&lt;qtoolbar.h&gt; #include&lt;QToolBar&gt; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) { resize(600,400); QMenuBar *bar =new QMenuBar(); setMenuBar(bar); QMenu * fileMenu =bar -&gt;addMenu("文件"); QMenu * editMenu =bar -&gt;addMenu("编辑"); QAction * newAction = fileMenu -&gt; addAction("新建"); fileMenu -&gt; addSeparator(); QAction * openAction = fileMenu -&gt; addAction("打开"); editMenu -&gt;addAction("111"); editMenu -&gt; addSeparator(); editMenu -&gt;addAction("222"); } MainWindow::~MainWindow() { } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/590c391c43eb7650b5ea00362a90cb4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbb8ed9be27aff6277a0b391d273b3a0/" rel="bookmark">
			SpringSecurity篇-(1)-零配置启用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最小配置启动 首先你需要一个springboot项目作者当前使用的是springboot2.7.0版本 如果用springboot2.7.1版本对应的springsecurity5.7.2版本，各位一定要注意下，5.7版本前后有一些配置是不一样的，我这里先记录5.7以后的配置
Maven只需要引入两个依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 直接来一个helloworld吧！
@RestController("/hello") public class HelloController { @RequestMapping public String hello(){ return "Hello World!"; } } 尝试请求 http://localhost:9001/hello（端口自己配哈），SpringSecurity会默认跳到其登录页
在什么都不配置的情况下，SpringSecurity已经帮我们做了安全控制。仔细观察控制台日志可以看到为我们生成了一个默认密码，并且提示我们：此密码仅供开发模式使用，你一定要在生产环境更改安全配置
两个疑问 作者看到这里的时候有两个疑问：
用户是什么？密码哪来的？为啥我什么配置都没有，依赖多一个spring-boot-starter-security就要拦截我的helloworld？ 部分猿宝宝看到这里可能会生气，你怎么那么多问题？跟你学不知道啥时候能上手喔。别急，很多同学跟着别的博客配置是很快，运行的看起来也ok，但是让你加点啥，改点啥还是要百度，就说明你对这个框架不熟。当然不求甚解的确是当下解决问题的快捷方式，如果想要快速开始可以看下一篇了。
源码解读 在开始看源码前，建议大家自己去github上把springsecurity官方的源码下下来，build时候注意gradle和jdk版本就好了，这里就不做说明了。
还有，为了方便学习，建议大家把trace日志打开，能够方便我i们在控制台查看SpringSecurity的调用链路
logging.level.org.springframework.web=trace logging.level.org.springframework.security=trace 从日志中看重点 我们配置好日志后重新启动，观察下日志：
作者用飘逸的横线标出了四个本人认为关键性的信息
1、期待初始化配置…
我完整列出来
eGlobalAuthenticationAutowiredConfigurer : Eagerly initializing {org.springframework.boot.autoconfigure.security.servlet.SpringBootWebSecurityConfiguration$WebSecurityEnablerConfiguration =org.springframework.boot.autoconfigure.security.servlet.SpringBootWebSecurityConfiguration$WebSecurityEnablerConfiguration@e26af6} 说人话。eGlobalAuthenticationAutowiredConfigurer说，他非常渴望初始化，初始化什么？
把SpringBootWebSecurityConfiguration的内部类WebSecurityEnablerConfiguration初始化成他自己，这里先不过渡解读它为啥这么渴望，以及他初始化这个类到底要干嘛
2、UserDetailsServiceAutoConfiguration说，我给你生成一个安全密码，那么看来自动生成用户密码是它干的事情
到这个类，模糊搜一下日志内容，比如“Using generated”，能看到它相应的方法：
private String getOrDeducePassword(SecurityProperties.User user, PasswordEncoder encoder) { String password = user.getPassword(); if (user.isPasswordGenerated()) { logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbb8ed9be27aff6277a0b391d273b3a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f76bd600dd4b099930f87fd790d2c744/" rel="bookmark">
			剑指 Offer 03. 数组中重复的数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		剑指 Offer 03. 数组中重复的数字 剑指 Offer 03. 数组中重复的数字题目描述思路1.哈希表2.原地交换 剑指 Offer 03. 数组中重复的数字 题目描述 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
示例 1：
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3
思路 1.哈希表 利用数据结构特点，容易想到使用哈希表（Set）记录数组的各个数字，当查找到重复数字则直接返回。
//c++ class Solution { public: int findRepeatNumber(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, bool&gt; map; for(int num : nums) { if(map[num]) return num; map[num] = true; } return -1; } }; //Java class Solution { public int findRepeatNumber(int[] nums) { Set&lt;Integer&gt; dic = new HashSet&lt;&gt;(); for(int num : nums) { if(dic.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f76bd600dd4b099930f87fd790d2c744/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0554e60776928cd2668692b259fcf669/" rel="bookmark">
			基于普中科技51单片机开发板心形灯设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include"reg52.h" #include"Delay.h" #include"intrins.h" #define u8 unsigned char #define u16 unsigned int #define LED_ONE_PORT	P0 #define LED_TWO_PORT	P1 #define LED_THR_PORT	P2 #define LED_FOU_PORT	P3 void all_light(void);//LED灯全亮 void Ni_onebyeone_light(void);//逆时针逐个检测亮灭 void Shun_onebyeone_light(void);//顺时针逐个检测亮灭 void Ni_onebyeone_all_light(void);//逆时针，逐个全部点亮 void Shun_onebyeone_all_light(void);//顺时针，逐个全部点亮 void Ni_onebyeone_extinguish(void);//逆时针，逐个熄灭 void Shun_onebyeone_extinguish(void);//顺时针，逐个熄灭 void left_light_all_light(void);//左(顺时针)右(逆时针)同时由下至上，依次逐个亮起 void Shun_one_four_all_light(void);//每一组端口，均顺时针/逆时针亮灭 void half_all_light(void);//左右各一半亮灭延时1s	void main() { while(1) { all_light(); Ni_onebyeone_light(); Shun_onebyeone_all_light(); Ni_onebyeone_extinguish(); Shun_onebyeone_light(); Ni_onebyeone_all_light(); Shun_onebyeone_extinguish(); left_light_all_light(); Shun_one_four_all_light(); half_all_light(); }	} //LED流水灯动画1：全亮3s后熄灭：检测LED灯是否均有效 void all_light(void) { LED_ONE_PORT=0x00;//P0.7-P0.0 LED_TWO_PORT=0x00;//P1.7-P1.0 LED_THR_PORT=0x00;//P2.7-P2.0 LED_FOU_PORT=0x00;//P3.7-P3.0 delay_ms(1500);//亮2s LED_ONE_PORT=0xff; LED_TWO_PORT=0xff; LED_THR_PORT=0xff; LED_FOU_PORT=0xff; delay_ms(1500);//不亮2s } //LED流水灯动画2：逐个点亮一遍(逆时针) void Ni_onebyeone_light(void) { u8 i,ii,iii,iiii;//定义循环变量 LED_ONE_PORT=0xfe;//1111 1110----P0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0554e60776928cd2668692b259fcf669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c238d4ea2cadf4f2af5e1491cc9ee69/" rel="bookmark">
			【Redis笔记】压缩列表（ziplist）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		压缩列表的定义：
压缩列表是为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。
压缩列表的构成：
压缩列表节点的构成：
previous_entry_length:记录压缩列表前一个节点的长度
根据previous_entry_length,程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址,从而实现从表尾到表头遍历。
encoding:
记录节点的content属性保存的数据的类型和长度
content:
负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。
连锁更新：
添加或删除节点，如果长度大于254字节，可能导致后一个节点的previous_entry_length大小需要从1字节变为5字节,这样可能会导致后续节点的previous_entry_length都发生变化，在这种情况下，需要进行连续多次空间拓展操作。
说明：
（1）空间分配最坏时间复杂度O(N),连锁更新的最坏时间复杂度O(N方)
（2）情况不多见并且只要节点个数不多，不会对性能造成影响。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d8dad39f425abc5768f900a98d87228/" rel="bookmark">
			Ubuntu18.04 各种软件的安装（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前ubuntu安PCL的时候出了些问题，干脆连整个系统一起重装了，各种用的顺手的软件也得重新安装一次，因此写个博客记录一下，以防万一以后还要重装.
（下面有很多东西都是其他博客或者网页中找到的）
目录
1 zsh与oh my zsh
2 flameshot截图软件
3 WPS
4 谷歌浏览器
5 vim
6 Gazebo模型下载
7 Eigen
8 Sophus
9 pip
10 vscode
11 Pangolin
12 Ceres
13 g2o
14 DBoW3
15 PCL
16 aptitude
17 Kalibr
18 googlepinyin
19 terminator
1 zsh与oh my zsh 个人觉得这个shell比ubuntu自带的bash好用一些 主要是tab健更好用
参考Ubuntu 下安装zsh和oh-my-zsh - stardsd - 博客园安装zsh
shell教程Shell 教程 | 菜鸟教程
安装zsh
sudo apt-get install zsh 安装oh my zsh
git clone git://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d8dad39f425abc5768f900a98d87228/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/990f7995001d7d68f96dc4f2136c84c3/" rel="bookmark">
			C语言三行代码情书，程序员的极致浪漫！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		int day; for(day=0;day&lt;=mylife;day++) printf("i love you!"); 你我相遇的那一刻起 我愿用一辈子 每天爱你 if(you.love(me)||!you.love(me)){ me.love.value++; me.love.value--;} 你爱我或者不爱我 爱就在那里 不增不减 if(1000==life.luck) give you(998); I.luck--,I.meet(you);I.luck--,I.accompany(you); 如果一生有1000次好运 我愿把998次都给你，只留两次给自己 用一次遇见你，另一次永远陪伴你 printf("Think twice before you do"); sleep(3); printf("I love you"); 子曰：三思而后行 1...2...3 我喜欢你 do{ I.sleep = 0; } while(you.say("see you tomorrow")); 你一句明天见 偷走了我 整晚的睡眠 if(you exist in my dreams=1) {I will=1; printf("I don't want to wake up")； 如果你存在我的梦里 我便 此生长眠不起 int time; if(time==night) printf("i would like to become a star to watch over you"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/990f7995001d7d68f96dc4f2136c84c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac41a3e5d5fbec6ca7ed73c177359e45/" rel="bookmark">
			IDEA设置启动打开项目目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IDEA设置启动打开项目目录 我们经常在启动IDEA的时候，工具会默认打开上次关闭的项目， 而非我们想要打开的项目，这时候我们需要进行如下操作， 即可在下次启动IDEA时，显示工具所有加载过的项目， 此时就可以进行选择操作。 1 打开IDEA软件 2 找到点击 file----&gt; Settings------&gt; Appearance &amp;Behavior-----&gt; System Settings 3 将Repoen last Project on startup选项勾选框去掉 ,点击ok完成设置 4 设置完成页面 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a05f581741470a9b2e3564d4d88e9060/" rel="bookmark">
			007-Idea-常用设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 IntelliJ IDEA 介绍2 IDEA 的主要功能介绍3 IDEA 的主要优势：(相较于 Eclipse 而言)4 IDEA 官网5 基本设置5.1 主题设置5.2 设置窗体及菜单的字体及字体大小5.3 设置鼠标滚轮修改字体大小5.4 设置自动导包功能5.5 设置显示行号和方法间的分隔符5.6 忽略大小写提示5.7 设置默认的字体、字体大小、字体行间距5.8 修改代码中注释的字体颜色5.9 设置项目文件编码5.10 设置自动编译5.11 设置为省电模式5.12 设置快捷键(Keymap)5.13 IDEA---默认快捷键5.14 IDEA---eclipse快捷键5.15 IDEA---翻译插件安装Translation 1 IntelliJ IDEA 介绍 IDEA，全称 IntelliJ IDEA，是 Java 语言的集成开发环境，IDEA 在业界被公认为是最好的 java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE。支持、Ant、JUnit、CVS 整合、代码审查、创新的 GUI 设计等方面的功能可以说是超常的
2 IDEA 的主要功能介绍 3 IDEA 的主要优势：(相较于 Eclipse 而言) ① 强大的整合能力。比如：Git、Maven、Spring 等② 提示功能的快速、便捷③ 提示功能的范围广④ 好用的快捷键和代码模板 private static final psf⑤ 精准搜索 4 IDEA 官网 https://www.jetbrains.com/idea/
5 基本设置 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a05f581741470a9b2e3564d4d88e9060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8ec925494f80518ebd2b4fcbd0b4ad1/" rel="bookmark">
			2020电赛E题--非线性失真器程序设计--01--算法仿真与STM32FFT数据验证（附工程源码&#43;gitee链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 20电赛整体感觉难度比之前小，本次程序设计上也没有太多的难点。功能指标全部完成，程序实现了测量每种失真的情况下的THD的近似值。并且进行了程序拓展，实现了全自动的测量，以及显示测量波形的波形图，频谱图。根据题目要求，我们可以看出这次程序设计要用到FFT算法。
我们的程序设计有两个版本，一个版本是通过定时器进行采样得到特定采样率下的数据并保存在数组里，然后进行傅里叶变换，另外一种就是通过定时器产生PWM波生成ADC的采样时钟，直接通过DMA保存数据然后进行傅里叶变换。
在理论计算下，
所以本文主要介绍我们实现的FFT的功能测试验证的程序。
题目 比赛指标要求 为什么需要FFT? 任何连续测量的时域信号都可以表示为不同频率的正弦波信号的无限叠加。以累加的方式来计算该信号中不同信号的频率、振幅和相位。所以本次测量就必须要使用FFT算法。
原理部分就引用下别人的帖子大家自行查看：
超详细易懂FFT（快速傅里叶变换）及代码实现
知识科普：THD 总谐波失真表明功放工作时，由于电路不可避免的振荡或其他谐振产生的二次，三次谐波与实际输入信号叠加，在输出端输出的信号就不单纯是与输入信号完全相同的成分，而是包括了谐波成分的信号，这些多余出来的谐波成分与实际输入信号的对比，用百分比来表示就称为总谐波失真。一般来说，总谐波失真在500赫兹附近最小，所以大部分功放表明总谐波失真是用500赫兹信号做测试，但有些更严格的厂家也提供20－20000赫兹范围内的总谐波失真数据。总谐波失真在1%以下，一般耳朵分辨不出来，超过10%就可以明显听出失真的成分。这个总谐波失真的数值越小，音色就更加纯净。一般产品的总谐波失真都小于1%@500Hz，但这个数值越小，表明产品的品质越高。
所以在进行测试前我们就要先有个概念
对于信号源输出的1k的正弦信号，总谐波失真的近似值越小，表示程序更精准，基本在1.0%以内。
对于信号源输出的1k的方波信号，总谐波失真的近似值大约是0.3887（前5次谐波计算的近似值）
失真度测试仪测量的结果： 正弦波 方波 这里解释下为啥方波测量出来的是44.26%，这里先给出方波的傅里叶变换式子
因为对于近似值来说方波取前五次傅里叶变换的值就是0.3887
计算到前7次时候
MTLAB仿真测试 所以根据已有的知识，进行下MATLAB仿真测试
clf;fs=10240; %采样频率 Ndata=1024; %数据长度 N=1024; %FFT的数据长度 n=0:Ndata-1; t=n/fs; %数据对应的时间序列 x=0.5*sin(2*pi*1000*t)+1; %时间域信号 %subplot(2,2,4),plot(t,x); subplot(2,2,2),plot(t,x,'.--'); y=fft(x,N); %信号的Fourier变换 mag=abs(y); %求取振幅 f=(0:N-1)*fs/N; %真实频率 subplot(2,2,1),plot(f(1:N/2),mag(1:N/2)*2/N); %绘出Nyquist频率之前的振幅 xlabel('频率/Hz');ylabel('振幅'); title('Ndata=10240 Nfft=1024');grid on; 这里仿真显示的频谱图和我们的代码模拟给出的输入信号是相同的所以大致可以按照这个傅里叶变换的标准进行编写代码。之所以这里画出采样的波形图是因为后面我们程序要画波形图，所以这里就测试了下。理想波形的总谐波失真计算没有意义所以就不进行计算。
STM32测试程序： FFT.C 这里的FFT也是找到的别人写好的程序，所以就不做详细讲解了（能力有限）
#include "math.h" #include "fft.h" //精度0.0001弧度 //复数的交换 void conjugate_complex(int n,complex in[],complex out[]) { int i = 0; for(i=0;i&lt;n;i++) { out[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8ec925494f80518ebd2b4fcbd0b4ad1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e103388b2324a1f7261ad522bfc7496c/" rel="bookmark">
			[Linux](2)快速入门Linux基础指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ls 指令(list files)pwd 指令(print work directory)cd 指令(change directory)定位文件(路径)cd 指令的使用 touch 指令mkdir 指令(make directory)rmdir 指令、rm 指令(remove)man 指令cp 指令(copy file)mv 指令(move file)cat 指令(concatenate)more 指令、less 指令&gt; 输出重定向、&gt;&gt; 追加重定向&lt; 输入重定向head 指令、tail指令| 管道时间相关指令date 指令显示时间时间戳 cal 指令 find 指令grep 指令zip/unzip 指令tar 指令bc 指令uname 指令几个重要热键关机 ls 指令(list files) 功能
显示指定工作目录下的内容，对于目录，该命令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息
语法
ls [选项][目录或文件] 选项
-l 列出文件的详细信息，包括文件名、文件型态、权限、拥有者、文件大小等-a 列出目录下的所有文件，包括以 . 开头的隐藏文件。-i 输出文件的 i 节点的索引信息。-n 用数字的 UID,GID 代替名称。-F 在每个文件名后附上一个字符以说明该文件的类型， “*”表示可执行的普通文件； “/”表示目录； “@”表示符号链接； “|”表示FIFOs； “=”表示套接字(sockets)。-d 将目录象文件一样显示，而不是显示其下的文件。-k 以 k 字节的形式表示文件的大小。-r 对目录反向排序。-t 以时间排序。-s 在 l 文件名后输出该文件的大小。-R 列出所有子目录下的文件。 (递归)-1 一行只输出一个文件。 举例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e103388b2324a1f7261ad522bfc7496c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64bd9d84fa5d6327adecd67d70163459/" rel="bookmark">
			2021-11-30 ensp笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、查看信息： display ip int brief 查看接口ip地址
display interface brief 查看接口的简要信息
display current-configuration 显示当前配置文件
display current-configuration 关键词（查看关键词的配置）
display saved-configuration 显示保存的配置文件
display ip routing-table 查看路由表
display ospf peer 查看ospf邻居关系
display ospf lsdb 查看链路关系数据库
display clock 查看系统当前时间
display this 查看当前模式下的配置，比如在接口上敲这条命令就可以看到当前接口下的信息
display ike sa 查看ike协商结果
二、保存配置信息： 在用户视图下“save”
三、删除配置错误的信息： 例如：
undo ip address 202.1.1.1 24 删除错误的ip地址
四、修改屏幕保护时间 user-interface con 0
idle-timeout 0 0
五、关闭信息提示 undo info-center enable
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4714dc878b4c8af3797fd9bc4f60ef9d/" rel="bookmark">
			企业遇上AI，能擦出哪些火花？《2022中国AI技术应用场景市场研究及选型评估报告》一手解读...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《中智观察》第1703篇推送
作者：中国软件网
编辑：小宏
编审：杨小天
头图来源：知乎卓源股份
自2016年AlphaGo在围棋人机大战中击败围棋世界冠军李世石以来，“人工智能”一词就不绝于耳，到处都在喊人工智能，仿佛人工智能已经在各处落地生根，确实，大家都太期望看到人工智能的应用落地，正是大家这种迫切的期待，让大众不时会听到一些企业AI造假的事件。同时，关于AI在企业场景中的发展也有着较多的疑问，带着这些问题，2022年6月28日，海比研究院联合中国软件网共同举办《2022中国AI技术应用场景市场研究及选型评估报告》发布论坛，一站式解决真实AI企业应用场景、行业发展阶段、技术发展、产品使用、行业痛点、用户产品选型等诸多问题。
1、落地企业是否是AI擅长的事？
人工智能的本质是让机器能够像人一样思考、行动，它具有三方面的显著能力：较强的计算和数据应用能力、自适应和学习能力以及对外界环境进行感知的能力，这些能力使得AI能够为社会和企业赋能，提高效率、减少人力、并协助企业进行更好的决策。因此，AI的出现能够改变社会分工结构，与人一样成为现代劳动力的一员，在企业中具有极大的发展、应用空间。
2、什么是AI企业应用真场景？
AI是否有真实企业应用场景可以通过其发展的驱动因素来探究：从用户侧来讲，部分头部用户敢于创新发展，偏好先进技术在产品、项目中的应用；从厂商侧来讲，融合AI技术可以形成技术壁垒，利于品牌宣传、融资及长远发展。此外，从技术与场景的融合来看，AI适用一些企业中的场景，可以较大的提升工作效率、实现降本增效，因此AI在企业中存在真实的应用场景并且场景呈现进一步丰富的趋势。
当前AI与产业深度融合，正在释放数字化叠加倍增效应，海比研究院通过对AI技术在企业中的应用进行梳理、聚类，将应用场景划分为四大类，分别是智能营销场景、智能部门场景（场景与部门职责强相关）、智能办公场景、智能决策场景（跨部门）。
3、AI企业级应用的市场规模及潜力如何？
根据海比研究院数据，2022年中国AI企业应用市场规模保持高增长趋势，总体市场规模达到1.87万亿元，2021-2025年复合增长率达到31.5%。在总体规模当中，智能营销企业应用市场规模达到1.05万亿元，占比56%；智能办公企业应用达到0.24万亿元，占比13%；智慧部门企业应用达到0.28万亿元，占比15%；智能决策企业应用达到0.30万亿元，占比16%。
海比研究院认为：当前中国AI企业应用正处于密集落地应用阶段的前期，随着2-5年内人机交互、机器学习、计算机视觉、语音识别技术达到成熟阶段，将极大的加速AI在企业中应用场景的拓展，已经应用的场景其应用效果也会进一步提高。
注：AI企业应用规模指的是企业数智服务产品中涉及AI能力的产品规模，而非产品中AI能力的价值。
当前智能营销企业应用市场规模在总体规模中占比最大，其发展较快主要是基于以下三点原因：一是场景需求旺盛，营销环节对企业意义重大，关系到企业的营利、生存和发展，因此企业更愿意对该环节的智能化转型付费；二是应用场景明确，营销环节涉及到的智能客服、企业直播、精准营销等环节更适于用AI技术提高效率、降低成本，应用效果显著；三是当前智能营销环节使用的人机交互、自然语言处理技术具有一定的成熟性，能够支撑场景对技术的要求。随着未来语义理解技术、算法的成熟，大量应用会对技术进行反哺，智能营销的发展空间将会进一步释放。
办公场景的发展呈现以下三个特征：技术成熟且被用户熟知，OCR、生物特征识别、语音识别等技术是成熟度最高的技术，在办公场景有较大的落地应用价值，用户触达较广；办公场景存在大量数据，AI有充足的“用武之地”；该场景的产品使用简单、方便，例如图片转文字、人脸识别等，用户接受度更高。
部门类场景相对更容易进行流程标准化，因此AI技术有较大的价值发挥空间。但流程化不等于智能化，流程化仅为把重复的流程按照规则自动完成，不需要做很多判断，而 AI 则是可以实现软件像人一样做出判断。在部门场景中，尤其是财务、采购等涉及企业资金的场景，AI 产品带来的降本增效效果明显。
智能决策场景的AI化相对缓慢，这是因为决策类软件涉及到的内部组织事务较多，软件的AI化会更加复杂，需要更多的时间进行场景化的探索和落地，但其产品单价通常较高，将会驱动该细分领域未来快速发展。
4、技术采用及关注度情况
海比研究院调研数据发现，当前AI软件产品主要应用的技术为生物特征识别、自然语言处理，这与技术的成熟度有较大的关系。生物特征识别中，指纹识别技术成熟且成本低，人脸识别使用方便且适用于日常办公等领域。自然语言中相对简单的会话、聊天等功能已广泛应用在智能客服领域，是当前较为成熟的应用。
从用户最感兴趣的技术角度来看，机器学习及自然语言处理更受用户关注，这与技术可挖掘的应用潜力有较大关系。自然语言处理技术需要经过5-10年走向成熟，但这主要指的是自然语言的阅读理解、机器创作方向。海比研究院认为，未来五年是自然语言处理技术发展的黄金五年，当解决自然语言的难点后，无论是日常生活还是企业生产都将改变，尤其是阅读理解、机器创作发展下的预测及判断能力也会进一步提升。
机器学习尚有较大的潜力还没有被挖掘，未来通过利用机器学习、深度学习模型进行业务“演练”，将能够很好的预测未来的发展，对于企业具有很大价值。
注：红框圈定的技术为当前产品中主要使用的技术，灰框圈定的技术为用户最感兴趣的技术。
5、未来AI生态合作将持续升温，合作体现在三方面
技术厂商与软件厂商的合作
当前B端的软件厂商在原有产品中耦合AI能力时绝大多数会采用外部AI能力引入的方式，而还有很多厂商暂未采用AI技术，随着可落地场景的增多，未来这部分厂商将更多的与AI的技术厂商合作。
厂商与大数据公司的合作
企业发展需要有海量数据、强运算能力，同时需要将业务融合进来，但企业不一定要具备海量、全面、能够支撑自身业务的数据，需要大量的合作伙伴或一些专业的数据公司提供这些数据，未来这种合作趋势将更加明显。
硬件与软件的结合
智能化发展离不开硬件的智能化，AI技术可以帮助例如传统制造业提升产品体验，二者的结合是值得关注的重点。
6、数据资产化、应用案例积累、信任度增加将促进AI项目明显提效
数据资产化加速AI利用
根据海比研究院调研数据，2020年，中国数据资产化市场规模为280亿元，未来五年复合增长率达41%，中大型企业开始或计划进行数据资产化，当企业数据资产化形成规模，将加速帮助企业构建数据能力,推进AI算法及模型建立，加快AI项目的实施。
应用积累在一定程度上将促进定制化走向标准化
当前AI产品的应用更多以定制化项目的形式出现，随着不同行业、不同场景、不同规模用户的定制化项目的积累，有更多的基础数据、模型支撑，可以加快形成数据标准，通过建设AI开放平台、沉淀项目，将破解当前AI领域标准化程度低的迷局，未来AI项目的标准化也将成为可能。
信任性增加促进项目提速
今后的一段时间内，AI的使用效果会在某些场景不断地被验证，这将增加用户对于产品的了解和信任，预计今后项目推进的流程将简化，时间也会大大缩短。
7、AI能否引爆元宇宙？
AI是元宇宙的核心。未来元宇宙将在智能性方面产生巨大的需求，需要六大技术的支撑：区块链技术、交互技术、电子游戏技术、AI技术、智能网络技术，其中，AI技术是真正的核心技术，为元宇宙中大量的应用场景提供支撑。其中，图像视觉、人机交互将成为最先突破的两个技术领域。
虚拟人或成为元宇宙的入口，虚拟人的关键在于AI智能化水平。2022年虚拟人市场将同比增长64.5%，并且增长率在过去三年内达到峰值，虚拟人在未来将会越来越常见。虚拟人不仅拥有媲美真人的立体化身形，声音、语气、肢体动作，同时还有着行为、交互等多重人类特征，其语音能力、语义的理解、动作以及表情的驱动等等都离不开AI技术。因此海比研究院认为：AI是元宇宙的触发器，将加速推进“元宇宙”进程，虚拟人时代将到来。
海比研究院通过发布《2022中国AI技术应用场景市场研究及选型评估报告》，不仅对AI企业应用市场全貌进行研究，同时探究了AI与企业级产品的融合情况及发展趋势，也为用户选型给予决策参考，提供避坑指南（中国软件网官网可下载报告原文），海比研究院、中国软件网希望与业内厂商、用户共同塑造良好的AI发展环境，助力行业快速发展。
科技媒体·企业演化科学·战略托管综合体
本文作者系中国软件网
寻求报道，以及对相关话题感兴趣，请评论区留言
CDEC 2022中国数智智能生态大会暨第十五届软件渠道大会 火热报名中
成都站
扫码报名参会/进群
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/712a31eb3ba0b699722b28edbf46e165/" rel="bookmark">
			前端鉴权、路由守卫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前端携带参数给后端的几种方法 ①查询参数？后面携带的
②路径参数：后面携带的也就是我们常说的query的
③请求头携带
④请求体携带
axios({ method:'PUT', //路径参数 url:'/products/'+100, //查询参数（axios比较特殊） params:{ page:1, perPage:10,}, //请求头 headers:{ 'X-Hahaha':'666',}, //请求体 data:{ name:1, age:2,}, }) 完整的url PUT /products/100?page=1&amp;perPage=10 后端拿到请求头参数 request.headers['x-hahaha'] 后端拿到请求体参数 request.body.name 后端拿到查询参数 request.query.page//1 后端拿到路径参数 request.params.id//100 二、状态码
状态码400可能是四种参数错误或者是输入的参数错误少传或者没传
401一般会是后端校验token失败
403无权限
404资源不存在，检查自己接口是否错误了
503超载
三、保护前端页面（避免用或通过拼接url直接跳转）
1.点击enter直接登陆
@keyup.enter.native
2.如果一个没填不能登陆可以通computer中的boolean来决定
可以在前后的route里的meta设置一些不同管理员能用的不同权限
通过前端路由守卫来确定 to代表了要跳转进去的页面b，from代表第一个页面的各种信息，next相当于跳转
//前端路由守卫 router.beforeEach((to,from,next)=&gt;{ //获取token const token = localStorage.getItem('token') //如果没有登录并且没有token跳转到登录页 if(to.name!=='Login'&amp;&amp;!token) next({name:'Login'} else next() }) 参考​​ ​​​​​ 前端鉴权
可以在route里面协商meta，来吧角色用数组存储起来，然后传递出去，接收到的可以放在store进行存储
2、路由不能写死
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f7abf833c40526888e602563399e7d8/" rel="bookmark">
			【CSDN笔记】如何将CSDN的文章以PDF文件形式保存到本地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案1：使用浏览器的开发者功能，打印输出 1.使用浏览器打开指定文章的界面
2.按下快捷键"F12"，打开开发者工具窗口
3.跳转到"Console"控制台选项栏，输入以下代码：
(function(){ $("#side").remove(); $("#comment_title, #comment_list, #comment_bar, #comment_form, .announce, #ad_cen, #ad_bot").remove(); $(".nav_top_2011, #header, #navigator").remove(); $(".p4course_target, .comment-box, .recommend-box, #csdn-toolbar, #tool-box").remove(); $("aside").remove(); $(".tool-box").remove(); $("#toolBarBox").remove(); $("main").css('display','content'); $("main").css('float','left'); $("body").css('min-width',0); $("#mainBox").css('width','90%'); $(".main_father.clearfix.d-flex.justify-content-center").css("width","90%"); $(".option-box").remove(); window.print(); })(); 其中"$(".main_father.clearfix.d-flex.justify-content-center").css("width","90%");"的90表示输出文件中内容的百分比，酌情调整即可，输入完成之后敲回车。
4.输入保存的路径，名字，点击确定即可
方案2：利用Python脚本 此部分源于Python爬虫-CSDN博文存为HTML/PDF文档_Tr0e的博客-CSDN博客
在文章中的最终代码处的第44行代码依照文章的方法按照实际情况做个修改
最终的代码如下：
import pdfkit import requests import parsel import time import re import os src_html = ''' &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; {content} &lt;/body&gt; &lt;/html&gt; ''' headers = { 'user-agent' : 'Mozilla/5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f7abf833c40526888e602563399e7d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54ef78dbb3ce99839592acd94285274c/" rel="bookmark">
			js 对url进行编码和解码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三种编码和解码函数：
encodeURI和 decodeURI
它着眼于对整个URL进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号"; / ? : @ &amp; = + $ , #"，也不进行编码。编码后，它输出符号的utf-8形式，并且在每个字节前加上%。
需要注意的是，它不对单引号’编码。
encodeURIComponent和decodeURIComponent（推荐使用）
它用于对URL的组成部分进行个别编码，而不用于对整个URL进行编码。
因此，"; / ? : @ &amp; = + $ , #"，这些在encodeURI()中不被编码的符号，在encodeURIComponent()中统统会被编码
escape 和 unescape
对除ASCII字母、数字、标点符号 @ * _ + - . / 以外的其他字符进行编码。
推荐文章：
js对url编码与解码_baby加油_的博客-CSDN博客_js url编码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84b7d4f43904da2f213f1abeed936d86/" rel="bookmark">
			js 实现pc端鼠标拖动触发横向滚动条的滚动（隐藏的滚动条）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果您想插件实现，如下链接：better-scroll
better-scroll | :scroll: inspired by iscroll, and it supports more features and has a better scroll perfermance
base-scroll | BetterScroll 2.0
我们都知道，pc端的横向滚动条只能点击滚动条进行左右拖动，不能像移动端那样，直接在空白区域就可以左右拖动。
在我的项目中，因为需求是将整个网站的滚动条全部隐藏了，所以就不能点击滚动条来拖动。
效果图1：
效果图2：
效果图1代码： &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box{ width:400px; overflow: auto; white-space: nowrap; background: #eee; border:5px solid #aaa; } .box&gt;span{ display: inline-block; height:100px; } /* H5的时候，隐藏滚动条 */ ::-webkit-scrollbar { display: none; width: 0 !important; height: 0 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84b7d4f43904da2f213f1abeed936d86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cbfa2fc4b6ef9b83f0fe00f2601ca11/" rel="bookmark">
			java:xml数据转json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pom.xml引入的jar
xml解析使用dom4j
&lt;!--xml解析--&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.36&lt;/version&gt; &lt;/dependency&gt; 1.创建xml转json工具类XmlToJsonUtil.java
package com.example.gxy.utils; import com.alibaba.fastjson.JSONArray; import com.alibaba.fastjson.JSONObject; import org.apache.commons.lang3.StringUtils; import org.dom4j.*; import java.util.List; /** * @ClassName XmlToJsonUtil * @Author gxy * @Desc xml转json */ public class XmlToJsonUtil { private XmlToJsonUtil(){ } /** * xml转json * * @param xmlStr * @return * @throws DocumentException */ public static JSONObject xml2Json(String xmlStr) { Document doc = null; try { doc = DocumentHelper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cbfa2fc4b6ef9b83f0fe00f2601ca11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6c69d8900c50382741d3bb40cccd0bd/" rel="bookmark">
			SLC、MLC、TLC 和 QLC NAND SSD 之间的区别：哪个更好？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你想要一个顶级系统，尤其是用于游戏或内容创作，那么 SSD 是绝对必要的。然而，在你去寻找之前，你应该知道要寻找什么。有多种不同类型的 SSD。就基本的 SSD 存储单元而言，有 SLC、MLC、TLC 和 QLC。其中，TLC 是最受欢迎的，不过，QLC 最终将取代它们。在 I/O 方面，有 SATA 和 NVMe。
最后，最新的 SSD 也基于 3D NAND/VNAND 技术。这可能会使 SSD 选择变得非常混乱。下面让我们来分解这些术语。
SLC、MLC、TLC 和 QLC：这些是存储单元 在 HDD 中，磁道是存储内存的构建块。在 SSD 中，相同的功能由单元提供，单元本质上是一个门电路。每个单元可以存储多少取决于 SSD 使用的单元类型。最受欢迎的是 SLC、MLC、TLC 和 QLC，这些代表单层单元、多层单元、三层单元和四层单元。
顾名思义，SLC SSD 中的单元每个单元只能存储一位，MLC 存储两个，TLC 存储三个，QLC 存储四个。虽然这似乎是一种“越大越好”的情况，但情况并非如此。使用 QLC 驱动器增加容量（以相同的价格）是最容易的，因为对于相同的存储量，它们需要的单元数是 SLC 驱动器的 1/4。
更大并不总是更好 将多个位写入单个单元需要更多时间，这也会影响 SSD 的耐用性。这意味着 SLC SSD 实际上是最快和最可靠的，但它们要贵得多。大多数商用 SSD 为 TLC，它在性能、可靠性和成本之间提供了合理的折衷。
一个单元在停止工作之前可以被读取和写入的次数是有限的。 这通常具有数十万次读取和写入的规模，称为 TBW（写入的总字节数）。然而，这意味着 SSD 的可用性是有限的，可能几年时间。如今，SLC 驱动器几乎不存在，MLC 仅限于少数高性能数据中心。
TLC 是最受欢迎的，与 3D NAND 搭配使用可在性能、耐用性和价格之间取得非常好的平衡。QLC 现在开始流行，虽然在速度和耐用性方面仍然落后于 TLC，但它便宜一些。这导致许多 OEM 在预制 PC 中使用它们，因此，在购买之前，请务必检查驱动器的耐用性（TBW 或最大写入 TB），并将其与其他基于 TLC 的选项进行比较。即使驱动器（已崩溃）在保修期内，如果超过 TBW 值，供应商也可能拒绝更换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6c69d8900c50382741d3bb40cccd0bd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/226/">«</a>
	<span class="pagination__item pagination__item--current">227/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/228/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>