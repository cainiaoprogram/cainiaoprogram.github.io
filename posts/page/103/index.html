<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43e0cdc9dc38180be5f4f3f4e5ac6b35/" rel="bookmark">
			雷池WAF入门教学-介绍和安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		雷池WAF入门教学-介绍和安装 欢迎访问我的小站-分享技术
原创贴 转载请标明来源
Aug 15, 2023
雷池WAF介绍和安装部署 前言 搭建博客网站，或者企业宣传网站，公司内部网站等web应用经常被恶意扫描和SQL注入和XSS攻击，企业WAF费用不菲，对于个人和小型公司来说，成本太高，那，免费的WAF来了，长亭雷池WAF社区版，免费解决web安全防护，好用又好看！！！
1. 简介 官方宣称可以抵御0day的一款社区免费web应用防火墙（WAF）（白嫖党的福利） 特点：
是首创业内领先的智能语义分析算法，精准检测、低误报、难绕过语义分析算法无规则，面对未知特征的 0day 攻击不再手足无措。是基于nginx反向代理技术实现的流量拦截，性能损耗小，对业务侵入小，无任何影响。门槛低，采用docker方式部署，通过官方提供的安装脚本，一行命令一键安装即可使用，对于新手和非运维人员非常友好。管理界面友好，通过web界面管理，可以实时查看WAF的运行状态，查看攻击日志事件，首页显示攻击IP地理分布，请求数统计，站点浏览数等PV和UV指标。友好的社区交流，可以通过微信群跟官方技术面对面交流产品使用过程中存在的问题，github提交功能建议，及时了解产品的最新功能更新和Bug修复，站在用户角度做产品。如果issue一经采用，还可以领取产品周边。 功能介绍 二、功能介绍
数据统计攻击事件防护站点黑白名单人机验证频率限制IP组通用配置 数据统计 主要是显示站点请求访问统计数据和防护拦截统计数据，访问IP的归属地理信息，站点的UV和PV信息，以及近30天的访问统计数据。攻击事件 展示所有的攻击事件，包括攻击者IP（IP地理位置国家），拦截次数，攻击发生时间，持续时间。点击事件，可以查询事件详细信息。包括攻击类型（xss等），攻击地址，攻击IP，攻击时间。 防护站点 添加要防护的web站点 配置支持Http和HTTPs站点的防护模式支持 防护、观察、维护防护模式下，防护规则生效，可以阻断攻击事件。观察模式下，不会自动阻断攻击事件，给出攻击事件告警，可以手动阻断攻击事件。维护模式下，网站无法访问，会提出网站维护的页面提示。 黑白名单 是添加防护站点的黑白名单，包括源IP，路径，host，header，body。人机验证 人机验证主要是针对机器人扫描，攻击等行为，增加人机验证页面。频率限制 频率限制主要针对web站点访问频率限制，可以设置高频访问限制，高频攻击限制。IP组 IP组主要是将恶意攻击IP添加到IP组中，用于向长亭社区共享恶意 IP 情报信息。通用配置，用于设置防护模块运行模式，包括观察，平衡，高强度等。 配置是否加入长亭社区恶意 IP 情报共享计划。 2. 部署架构 3.安装部署 配置要求(转自官方网站) 操作系统：Linux指令架构：x86_64软件依赖：Docker 20.10.6 版本以上软件依赖：Docker Compose 2.0.0 版本以上最小化环境：1 核 CPU / 1 GB 内存 / 5 GB 磁盘 通过下面命令查看操作系统配置参数是否满足配置要求 uname -m # 查看指令架构 docker version # 查看 Docker 版本 docker compose version # 查看 Docker Compose 版本 docker-compose version # 同上（兼容老版本 Docker Compose） cat /proc/cpuinfo # 查看 CPU 信息 cat /proc/meminfo # 查看内存信息 df -h # 查看磁盘信息 安装方式 官方提供了三种安装方式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43e0cdc9dc38180be5f4f3f4e5ac6b35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57da949e84f2c08170e7af575f6082c2/" rel="bookmark">
			【性能】什么是CPU密集型计算、IO密集型计算与多进程、多线程、多协程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、什么是CPU密集型计算、IO密集型计算？ CPU密集型（CPU-bound）：
CPU密集型也叫计算密集型，是指I/O在很短的时间就可以完成，CPU需要大量的计算和处理，特点是CPU占用率相当高
例如：压缩解压缩、加密解密、正则表达式搜索IO密集型（I/O bound）:
IO密集型指的是系统运作大部分的状况是CPU在等I/O（硬盘/内存）的读写操作，CPU占用率任然较低。
例如：文件处理程序、网络爬虫程序、读写数据库程序 2、多进程、多线程、多协程的对比 多进程Process(multiprocess) 优点：可以利用多核CPU并行运算缺点：占用资源最多、可启动数目比线程少适用于：CPU密集型计算 多线程Thread(threading) 优点：相比进程，更轻量级、占用资源少缺点： 相比进程：多线程只能并发执行，不能利用多CPU(GIL)相比协程：启动数目有限制，占用内存资源，有线程切换开销 适用于：IO密集型计算、同时运行的任务数目要求不多多协程Coroutine(asynico) 优点：内存开销最少、启动协程数量最多缺点：支持的库有限制（aiohttp vs requests）、代码实现复杂适用于：IO密集型计算、需要超多任务运行、但有现成库的场景 3、怎样根据任务选择对应技术？ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c64185aefe8159edabdb36bf4c705e0/" rel="bookmark">
			Sublime 全选后光标在每一行、全局替换、全局换行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sublime 全选后光标在每一行、全局替换、全局换行 做个记录
多行汇总成一行，以逗号标识分隔 全选后，使用快捷键Ctrl + Shift + L，即可在每一行的后面显示光标，再使用End或Home键进行前后移动，输入逗号再按回车键即可
将逗号分隔的字符串换成每一行独立展示 选中逗号，使用Ctrl + F 或Ctrl + H，再使用快捷键Alt + Enter，即可选中每一个逗号，并在逗号后都会有一个光标，这时就可以删除逗号并使用回车键即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76f7cc8d62d598b54492a309785499b3/" rel="bookmark">
			K8S环境下配置SpringBoot健康检查（活性探针）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K8S环境下配置SpringBoot健康检查（活性探针） k8s 探针配置：具体配置如下后续使用问题参考文章 主要是通过K8S的健康检查探针，对SpringBoot应用进行运行健康监控，检测pod是否存活，从而对pod进行重启之类的操作
k8s 探针配置： kubernetes提供了三种探针（支持exec、tcp和http方式）来探测容器的状态：
LivenessProbe：容器存活性检查，用于判断容器是否健康，告诉 kubelet 一个容器什么时候处于不健康的状态。如果 LivenessProbe 探针探测到容器不健康，则 kubelet 将删除该容器，并根据容器的重启策略做相应的处理。如果一个容器不包含 LivenessProbe 探针，那么 kubelet 认为该容器的 LivenessProbe 探针返回的值永远是 Success；
ReadinessProbe：容器就绪性检查，用于判断容器是否启动完成且准备接收请求。如果ReadinessProbe探针探测到失败，Endpoint Controller 将从 Service 的 Endpoint 中删除包含该容器所在 Pod 的 IP 地址的Endpoint条目。如果容器不提供就绪态探针，则默认状态为 Success。
StartupProbe: 容器启动检查，指示容器中的应用是否已经启动。如果提供了启动探针，则所有其他探针都会被禁用，直到此探针成功为止。如果启动探测失败，kubelet 将杀死容器，而容器依其重启策略进行重启。 如果容器没有提供启动探测，则默认状态为 Success。
三种探针共有配置：
Probe有如下配置字段，可以使用这些字段精确的控制存活和就绪检测的行为：
initialDelaySeconds：容器启动后要等待多少秒后存活和就绪探测器才被初始化，默认是 0 秒，最小值是 0。
periodSeconds：执行探测的时间间隔（单位是秒）。默认是 10 秒。最小值是 1。
timeoutSeconds：探测的超时后等待多少秒。默认值是 1 秒。最小值是 1。
successThreshold：探测器在失败后，被视为成功的最小连续成功数。默认值是 1。 存活和启动探测的这个值必须是 1。最小值是 1。
failureThreshold：当探测失败时，Kubernetes 的重试次数。 存活探测情况下的放弃就意味着重新启动容器。 就绪探测情况下的放弃 Pod 会被打上未就绪的标签。默认值是 3。最小值是 1。
说明：
在 Kubernetes 1.20 版本之前，exec 探针会忽略 timeoutSeconds：探针会无限期地 持续运行，甚至可能超过所配置的限期，直到返回结果为止。这一缺陷在 Kubernetes v1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76f7cc8d62d598b54492a309785499b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc53a1960a60158db4e1a5c5266c7bf4/" rel="bookmark">
			python 中np.squeeze的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当处理数组时，有时候我们希望将形状中维度为1的维度去除，使得数组更加紧凑。np.squeeze函数可以实现这个目的。
1函数参数 numpy.squeeze(a, axis=None) 其中，a表示输入的数组，axis表示要去除的维度的索引或索引列表。如果不指定axis参数，则会去除所有维度为1的维度。
2.常见用法 1.去除所有维度为1的维度 a = np.array([[[1, 2, 3]]]) b = np.squeeze(a) print(b.shape) #输出：(3,) 详细例子：
import numpy as np approx = np.array([[[10, 20]], [[30, 40]], [[50, 60]], [[70, 80]]]) print(approx.shape) # 输出：(1, 4, 2) corner_points = np.squeeze(approx) print(corner_points.shape) # 输出：(4, 2) print(corner_points) 输出：
(1, 4, 2) (4, 2) [[10 20] [30 40] [50 60] [70 80]] 2.去除指定维度的1维度 a = np.array([[[1, 2, 3]]]) b = np.squeeze(a, axis=0) print(b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc53a1960a60158db4e1a5c5266c7bf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/074ed249e938e5638b86e0e165f11e35/" rel="bookmark">
			解决docker拉取镜像时报错Error response from daemon: Get ““: http: server gave HTTP response to HTTPS client
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 场景：新搭建一台服务器，需要拉取公司私有镜像仓库。
例如镜像仓库地址：192.168.1.111:5000
docker拉取私有仓库报如下错误:
Error response from daemon: Get "http://192.168.1.111:5000/v2/": http: server gave HTTP response to HTTPS client 解决方式：
1.编辑docker中的daemon.json文件，没有就创建
vim /etc/docker daemon.json 2.在文件中添加如下内容
{ "insecure-registries": ["192.168.1.111:5000"] } 3. 重新加载daemon
systemctl daemon-reload 4.重启docker
systemctl restart docker 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee52401bbe62e19595463c6465b56349/" rel="bookmark">
			自定义的哈希map
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unordered_map有五个参数，分别是键类型(Key Type)、值类型(Value Type)、哈希函数(Hash Function)、相等键函数(Equal Key Function)和空间分配器(Allocator)。
当我们创建一个unordered_map时，我们需要提供五个参数。
键类型(Key Type)：这是用来定义键的数据类型。键可以是任何数据类型，比如整数、浮点数、字符串等。
值类型(Value Type)：这是用来定义值的数据类型。值可以是任何数据类型，与键的数据类型可以相同，也可以不同。
哈希函数(Hash Function)：这是用来计算键的哈希值的函数。哈希函数将键映射为一个整数值，这个值用来确定键在unordered_map中的位置。哈希函数需要满足一些要求，比如相同的键应该有相同的哈希值。
相等键函数(Equal Key Function)：这是用来判断两个键是否相等的函数。当两个键的哈希值相同时，unordered_map需要使用相等键函数来判断它们是否真正相等。相等键函数需要返回一个bool值，如果两个键相等则返回true，否则返回false。
空间分配器(Allocator)：这是用来分配和释放内存的函数对象。unordered_map使用空间分配器来管理内存，包括为键值对分配内存、释放内存以及重新分配内存等操作。默认情况下，unordered_map使用标准分配器来实现内存管理，但也可以使用自定义的空间分配器。
std::allocator是C++标准库提供的默认的空间分配器。它使用了new和delete操作符来进行内存的分配和释放。
当我们使用std::allocator来分配内存时，它会调用new运算符来分配一块足够大小的原始内存块。std::allocator的allocate函数接收一个size_t类型的参数，表示需要分配的内存块的大小。allocate函数会计算出需要分配的内存块的大小，并调用new运算符来分配内存。然后，allocate函数会返回分配的内存块的指针。
当我们使用std::allocator来释放内存时，它会调用delete运算符来释放先前分配的内存块。std::allocator的deallocate函数接收两个参数，第一个参数是要释放的内存块的指针，第二个参数是内存块的大小。deallocate函数会调用delete运算符来释放内存。std::allocator的分配和释放过程与new和delete运算符的行为一致，可以通过重载new和delete运算符来实现自定义的内存分配和释放逻辑。默认情况下，std::allocator的行为与全局的new和delete运算符一致，可以直接使用。
自定义的空间分配器是指用户可以根据自己的需求定义的分配和释放内存的函数对象。通常情况下，unordered_map使用标准分配器来实现内存管理，即使用std::allocator来分配和释放内存。但是，在特定的情况下，用户可能希望使用不同的内存分配策略或者使用自己实现的内存管理机制。
使用自定义的空间分配器可以实现以下功能： 改善性能：用户可以针对自己的应用场景选择更适合的分配策略，以提高unordered_map的性能。约束资源使用：用户可以通过自定义空间分配器来限制资源的使用，以防止内存泄漏或过度使用内存。支持特殊需求：在某些特殊的场景下，用户可能需要使用特定的内存分配策略或者与其他库兼容的内存管理机制，此时可以通过自定义空间分配器来满足这些需求。 自定义空间分配器需要实现以下两个成员函数： allocate函数：用于分配内存。该函数接受一个size_t类型的参数，表示需要分配的内存块的大小，返回一个指向分配的内存块的指针。deallocate函数：用于释放内存。该函数接受两个参数，第一个参数是要释放的内存块的指针，第二个参数是内存块的大小。 用户可以通过定义自己的空间分配器类，并重载这两个成员函数来实现自定义的空间分配器。在创建unordered_map对象时，可以将自定义的空间分配器作为参数传递给unordered_map的模板参数，以使用自定义的空间分配器。
提供这五个参数可以让我们更好地自定义unordered_map的行为，比如选择合适的键和值类型、调整哈希函数以提高性能、使用自定义的相等键函数来处理复杂的键比较逻辑等。
构建自定义的哈希表：除了键值之外，要设置两个函数，一个是计算键值的hash函数，另一个是比较键值是否相等的函数，这里对应的分别是PersonHash和PersonEqual两个函数。
#include &lt;iostream&gt; #include &lt;unordered_map&gt; class person{ public: enum class name { Li =1, Wu =2, }; name name_=name::Li; }; class ani{ public: enum class sex{ boy = 1, girl = 2, }; sex pet = sex::boy; }; struct PersonHash { std::size_t operator()(const person&amp; p) const { // 使用哈希函数来计算person对象的哈希值 return static_cast&lt;std::size_t&gt;(p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee52401bbe62e19595463c6465b56349/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/208544376492ae9a656914835ae4a7d5/" rel="bookmark">
			数据分析与数据挖掘方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据分析和数据挖掘都可以做为“玩数据”的方法论，两者有很多的共性，也有显著的差异。从分析的目的来看，数据分析一般是对历史数据进行统计学上的一些分析，数据挖掘更侧重于机器对未来的预测，一般应用于分类、聚类、推荐、关联规则等。
数据分析(狭义)与数据挖掘的本质都是一样的，都是从数据里面发现关于业务的知识(有价值的信息)，从而帮助业务运营、改进产品以及帮助企业做更好的决策.
从分析的过程来看，数据分析更侧重于统计学上面的一些方法，经过人的推理演译得到结论;数据挖掘更侧重由机器进行自学习，直接到得到结论。 从分析的结果看，数据分析的结果是准确的统计量，而数据挖掘得到的一般是模糊的结果。 ‘数据分析’的重点是观察数据，‘数据挖掘’的重点是从数据中发现‘知识规则’KDD(Knowledge Discover in Database)。
‘数据分析、数据统计’得出的结论是人的智力活动结果，‘数据挖掘’得出的结论是机器从学习集(或训练集、样本集)发现的知识规则。 ‘数据分析’需要人工建模，‘数据挖掘’自动完成数学建模。
数据挖掘与数据分析的主要区别是什么 1、计算机编程能力的要求 作为数据分析很多情况下需要用到成型的分析工具，比如EXCEL、SPSS，或者SAS、R。很多的数据分析人员做的工作都是从原始数据到各种拆分汇总，再经过分析，最后形成完整的分析报告。当然原始数据可以是别人提供，也可以自己提取(作为一名合格的数据分析师，懂点SQL知识是很有好处的)。 而数据挖掘则需要有编程基础。为什么这样说呢?举两个理由：第一个，目前的数据挖掘方面绝大多数是隶属于计算机系;第二点，在招聘岗位上，国内比较大的公司挂的岗位名称大多数为‘数据挖掘工程师’。从这两点就可以明确看出数据挖掘跟计算机跟编程有很大的联系。
2、在对行业的理解的能力 要想成为一名优秀的数据分析师，对于所从事的行业有比较深的了解和理解是必须要具备的，并且能够将数据与自身的业务紧密结合起来。简单举个例子来说，给你一份业务经营报表，你就能在脑海中勾画出目前经营状况图，能够看出哪里出现了问题。但是，从事数据挖掘不一定要求对行业有这么高的要求。
3、专业知识面的要求 数据分析师出对行业要了解外，还要懂得一些统计学、营销、经济、心理学、社会学等方面的知识，当然能了解数据挖掘的一些知识会更好。数据挖掘工程师则要求要比较熟悉数据库技术、熟悉数据挖掘的各种算法，能够根据业务需求建立数据模型并将模型应用于实际，甚至需要对已有的模型和算法进行优化或者开发新的算法模型。想要成为优秀的数据挖掘工程师，良好的数学、统计学、数据库、编程能力是必不可少的。
总之一句话来概括的话，数据分析师更关注于业务层面，数据挖掘工程师更关注于技术层面。 数据分析师与数据挖掘工程师的相似点：
1、都跟数据打交道。 他们玩的都是数据，如果没有数据或者搜集不到数据，他们都要丢饭碗。
2、知识技能有很多交叉点。 他们都需要懂统计学，懂数据分析一些常用的方法，对数据的敏感度比较好。
3、在职业上他们没有很明显的界限。 很多时候数据分析师也在做挖掘方面的工作，而数据挖掘工程师也会做数据分析的工作，数据分析也有很多时候用到数据挖掘的工具和模型，很多数据分析从业者使用SAS、R就是一个很好的例子。而在做数据挖掘项目时同样需要有人懂业务懂数据，能够根据业务需要提出正确的数据挖掘需求和方案能够提出备选的算法模型，实际上这样的人一脚在数据分析上另一只脚已经在数据挖掘上了。 事实上没有必要将数据分析和数据挖掘分的特别清，但是我们需要看到两者的区别和联系，作为一名数据行业的从业者，要根据自身的特长和爱好规划自己的职业生涯，以寻求自身价值的最大化。
数据分析与数据挖掘的区别 数据分析可以分为广义的数据分析和狭义的数据分析，广义的数据分析就包括狭义的数据分析和数据挖掘，我们常说的数据分析就是指狭义的数据分析。
数据分析(狭义)： (1)定义：简单来说，数据分析就是对数据进行分析。专业的说法，数据分析是指根据分析目的，用适当的统计分析方法及工具，对收集来的数据进行处理与分析，提取有价值的信息，发挥数据的作用。 (2)作用：它主要实现三大作用：现状分析、原因分析、预测分析(定量)。数据分析的目标明确，先做假设，然后通过数据分析来验证假设是否正确，从而得到相应的结论。 (3)方法：主要采用对比分析、分组分析、交叉分析、回归分析等常用分析方法; (4)结果：数据分析一般都是得到一个指标统计量结果，如总和、平均值等，这些指标数据都需要与业务结合进行解读，才能发挥出数据的价值与作用;
数据挖掘： (1)定义：数据挖掘是指从大量的数据中，通过统计学、人工智能、机器学习等方法，挖掘出未知的、且有价值的信息和知识的过程。
(2)作用：数据挖掘主要侧重解决四类问题：分类、聚类、关联和预测(定量、定性)，数据挖掘的重点在寻找未知的模式与规律;如我们常说的数据挖掘案例：啤酒与尿布、安全套与巧克力等，这就是事先未知的，但又是非常有价值的信息;
(3)方法：主要采用决策树、神经网络、关联规则、聚类分析等统计学、人工智能、机器学习等方法进行挖掘;
(4)结果：输出模型或规则，并且可相应得到模型得分或标签，模型得分如流失概率值、总和得分、相似度、预测值等，标签如高中低价值用户、流失与非流失、信用优良中差等; 综合起来，数据分析(狭义)与数据挖掘的本质都是一样的，都是从数据里面发现关于业务的知识(有价值的信息)，从而帮助业务运营、改进产品以及帮助企业做更好的决策。所以数据分析(狭义)与数据挖掘构成广义的数据分析。
题外话 在此疾速成长的科技元年，编程就像是许多人通往无限可能世界的门票。而在编程语言的明星阵容中，Python就像是那位独领风 骚的超级巨星， 以其简洁易懂的语法和强大的功能，脱颖而出，成为全球最炙手可热的编程语言之一。
Python 的迅速崛起对整个行业来说都是极其有利的 ，但“人红是非多”，导致它平添了许许多多的批评，不过依旧挡不住它火爆的发展势头。
在下个十年的剩余时间里，Python 还能如此重要以及保持完整性吗？今天，我们将对事实进行分析，破除一些误解。
如果你对Python感兴趣，想通过学习Python获取更高的薪资，那下面这套Python学习资料一定对你有用！
资料包括：Python安装包+激活码、Python web开发，Python爬虫，Python数据分析，人工智能、机器学习等学习教程。0基础小白也能听懂、看懂，跟着教程走，带你从零基础系统性地学好Python！
​
一、Python所有方向的学习路线
Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python学习软件
工欲善其事，必先利其器。学习Python常用的开发软件都在这里了！
三、Python入门学习视频
还有很多适合0基础入门的学习视频，有了这些视频，轻轻松松上手Python~
四、Python练习题
每节视频课后，都有对应的练习题哦，可以检验学习成果哈哈！
五、Python实战案例
光学理论是没用的，要学会跟着一起敲代码，动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。这份资料也包含在内的哈~
六、Python面试资料
我们学会了Python之后，有了技能就可以出去找工作啦！下面这些面试题是都来自阿里、腾讯、字节等一线互联网大厂，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
七、资料领取
上述完整版Python全套学习资料已经上传CSDN官方，需要的小伙伴可自行微信扫描下方CSDN官方认证二维码免费领取
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1d81908d2876e08b7ceb1ad4d56ce16/" rel="bookmark">
			html转pdf（总结五种方法Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：html转pdf（总结五种方法Java）_泰山码的博客-CSDN博客
html转pdf（总结五种方法Java） Java 实现html转pdf，总结五种方法。
推荐使用wkhtmltopdf,Itext
方法一：使用wkhtmltopdf 1、下载插件wkhtmltopdf
https://wkhtmltopdf.org/downloads.html
2、本机测试
本目录下cmd进入
输入命令 wkhtmltopdf.exe ‪E:\学习文档\百度常用标签.html ‪E:\学习文档\百度常用标签.pdf
3、java代码实现
HtmlToPdf类
import java.io.File; public class HtmlToPdf { // wkhtmltopdf在系统中的路径 private static final String toPdfTool = "‪D:\\wkhtmltopdf\\bin\\wkhtmltopdf.exe"; /** * html转pdf * * @param srcPath html路径，可以是硬盘上的路径，也可以是网络路径 * @param destPath pdf保存路径 * @return 转换成功返回true */ public static boolean convert(String srcPath, String destPath,String toPdfTool){ File file = new File(destPath); File parent = file.getParentFile(); //如果pdf保存路径不存在，则创建路径 if(!parent.exists()){ parent.mkdirs(); } StringBuilder cmd = new StringBuilder(); cmd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1d81908d2876e08b7ceb1ad4d56ce16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db2dbe7b56665b27b7b415d4f71b146a/" rel="bookmark">
			docker通用镜像方法，程序更新时不用重新构建镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决的问题：
有的镜像以来比较多，build一次时间比较长。
解决思路：
把可执行文件所在的目录挂在都镜像中，程序更新时不用重新构建镜像。
更新可执行文件后，重新启动容器就可运行新的程序。
功能 1、在demo目录下添加脚本文件start.sh，里面执行demo.jar文件。
2、将demo目录映射到镜像下的 /workspace目录。
3、Dockerfile文件中默认运行**/workspace目录下的start.sh**脚本。
文件 Dockerfile # 拉取jdk8作为基础镜像 FROM openjdk:8 # 作者 MAINTAINER d &lt;123@qq.com&gt; #修改镜像时区 ENV TZ=Asia/Shanghai RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone ENTRYPOINT ["sh","-c","/workspace/start.sh"] docker_run.sh #!/bin/bash cd $(dirname "$0") docker run --name=common \ -v $(pwd):/workspace \ -t -d $1 start.sh #!/bin/bash cd $(dirname "$0") echo `pwd` java -jar demo_file/demo-app.jar 演示例子 地址 https://gitee.com/yingge2017/docker_common_image.git
使用方法 例子中，demo文件夹子在工程当前目录下。
#1、根据Dockerfile生成镜像,镜像名称为common. docker build -t common .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db2dbe7b56665b27b7b415d4f71b146a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1465e711463a33b66cc112528763c182/" rel="bookmark">
			初学HTML5：音视频、拖拽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 新增标签介绍1、音视频video标签audio标签 2、拖拽设置元素为可拖放true拖动什么 - ondragstart 和 setData()放到何处 - ondragover进行放置 - ondrop和 getData()拖拽例题单个目标的拖拽多个目标的拖拽 新增标签介绍 1、音视频 video标签 在video标签出现之前，如果想在网页中播放视频或者音频数据是非常困难的。H5中video标签可以向使用img显示图片一样简单去播放视频。
属性： src：需要引入的视频资源地址controls：是否显示视频的控件，比如播放、暂停、进度条、音量、全屏autoplay：在视频加载完成后立即播放，最好和muted搭配使用，否则可能导致不能播放muted：是否静音loop：是否循环播放volume：控制视频音量，取值范围0~1duration：视频总时长currentTime：播放进度playbackRate：播放速度paused：当前视频的状态是否为暂停，是则为truewidth：视频宽度（有默认值）height：视频高度（有默认值） 方法： play()：播放pause()：暂停load()：重新加载当前视频 例如：播放视频
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;测试视频video标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 引入视频文件 --&gt; &lt;video src="../FILE/五月天 - 后来的我们.mp4" controls&gt;&lt;/video&gt; &lt;!-- 多个按钮控制视频 --&gt; &lt;div class="btns"&gt; &lt;button&gt;播放&lt;/button&gt; &lt;button&gt;暂停&lt;/button&gt; &lt;button&gt;快进&lt;/button&gt; &lt;button&gt;快退&lt;/button&gt; &lt;button&gt;快倍速&lt;/button&gt; &lt;button&gt;慢倍速&lt;/button&gt; &lt;/div&gt; &lt;!-- /多个按钮控制视频 --&gt; &lt;!-- 单个按钮控制视频播放与暂停、获得播放百分比、显示播放进度 --&gt; &lt;div class="play"&gt; &lt;button id="play"&gt;播放&lt;/button&gt; &lt;button id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1465e711463a33b66cc112528763c182/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05af1bcad4b6d1094193058fbe4e5c83/" rel="bookmark">
			递归实现n的k次方，递归小题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接代码，解释在下面！！
这题既可以用递归写，也有循环的写法，但这里主要说的是递归做法
//主函数可以自己去写这是函数 int Pow(int n, int k) { if(k==0) return 1; else if(k&gt;=1) { return n*Pow(n, k-1); } } 1.做题思路
求n的k次方，n*n*n.....直到k-1为0，那就可以停止此时返回1即可因为n的0次为0
n * pow（n，k-1）就相当于 n *（调用pow函数k - 1）直到k等于将递归返回即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf5a10d6e556b86bc025ef901f2fcae8/" rel="bookmark">
			【vue3】对axios进行封装，方便更改路由并且可以改成局域网ip访问（附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对axios封装是在main.js里面进行封装，因为main.js是一个vue项目的入口
步骤： 在1处创建一个axios实例为http，baseURL是基础地址（根据自己的需求写），写了这个在vue界面调用后端接口时只用在post请求处写路由地址就可以了在2处将创建的axios实例挂到app上在3处，vue页面进行调用后端接口时只写后端路由就好（我后端使用的Django） 代码： import { createApp } from 'vue' import App from './App.vue' import router from './router' import store from './store' import ElementPlus from 'element-plus' import 'element-plus/dist/index.css' import * as ElementPlusIconsVue from '@element-plus/icons-vue' import axios from 'axios' // createApp(App).use(store).use(router).mount('#app') // // 创建基础url const http = axios.create({ baseURL: 'http://127.0.0.1:8000/' }) const app = createApp(App) app.use(router) app.use(ElementPlus) app.use(store) app.config.globalProperties.$http = http app.mount('#app') for (const [key, component] of Object.entries(ElementPlusIconsVue)) { app.component(key, component) } 这是Django服务器启动成功的提示信息。它表示你已经在本地计算机上启动了一个开发服务器，可以通过http://0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf5a10d6e556b86bc025ef901f2fcae8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d131768dafd39cd0243cc510b5b08dc/" rel="bookmark">
			OpenAI全球招外包大军，手把手训练ChatGPT取代码农 ； 码农：我自己「杀」自己
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
OpenAI招了一千多名外包人员，训练AI学会像人类一样一步步思考。如果ChatGPT「学成归来」，码农恐怕真的危了？
码农真的危了！
当时OpenAI也说，ChatGPT最合适的定位，应该是编码辅助工具。
用ChatGPT来debug，效果拔群
ChatGPT有一个强大的优势：我们可以在对话中与系统互动，更详细地对问题进行说明，从而获得正确的答案。
码农：我自己「杀」自己
咱们来排一排，那些会写代码的AI。
谷歌的Pitchfork
AlphaCode：吊打72%程序员
Copilot：代码补全神器
前言 OpenAI招了一千多名外包人员，训练AI学会像人类一样一步步思考。如果ChatGPT「学成归来」，码农恐怕真的危了？ 福利：文末有chat-gpt纯分享，无魔法，无限制 码农真的危了！ 最近有消息称，OpenAI已经在悄悄地训练ChatGPT，让它学习人类的思考过程，从而真正掌握软件工程，彻底代替「初级码农」。
OpenAI招外包大军，教AI学人类思考
会编程的AI，几家硅谷大厂都在做。
DeepMind的AlphaCode，据说「吊打72%人类程序员」，但尚未开放；传闻中谷歌的「神秘项目」Pitchfork，也还在酝酿中；而微软的GitHub Copilot主要是一个代码补全工具。
要说完全代替人类码农，它们还不够格。
但如果真的让ChatGPT学会了用人类思维去编程，这些友商/自家的产品恐怕要被吊打。
而从种种迹象看来，OpenAI似乎正在下一盘大棋。
根据Semafor的报道，在过去的六个月里，OpenAI已经从拉美和东欧等地区招募了大约1000名外包人员，来训练他们的AI码代码。
这个新闻中，有两个「华点」。
首先，为什么地点选在拉美和东欧？这个咱们都明白，现在硅谷的泡沫戳破了，各家互联网大厂都在绞尽脑汁「降本增效」，有的靠裁员，有的就去其他国家找廉价劳动力。
第二个「华点」是，这些外包人员中，很多人并不是计算机专业的毕业生，也不具备高级的编程技能。他们的作用是，编写OpenAI期待实现的「自动化」基本代码。
具体来说，其中的60%从事「数据标注」工作——创建大量的图像、音频片段等信息，用来训练人工智能工具或自动驾驶汽车。
另外的40%则是实打实的程序员，他们正在为OpenAI的模型「手搓」数据，从而让AI学习软件工程任务。
此前，OpenAI一直是用从GitHub上抓取的代码训练其模型。
而这次，OpenAI想建立的数据集中，不仅有代码，还包括背后用自然语言编写的人类解释。
论文地址：https://arxiv.org/abs/2107.03374
对此，Semafor特地采访了一位南美的开发者，而他曾无偿为OpenAI完成了5小时的编码测试。
在这个测试中，他被要求处理两个任务。
首先，他会得到一个编程问题，OpenAI要求他用书面的英语解释自己将如何处理这个问题。
然后，他需要提供一个解决方案。
如果他发现了一个bug，OpenAI就会要求他详细说明问题是什么，应该如何纠正，而不是简单地修复。
「他们很可能是想用一种非常特殊的训练数据来投喂这个模型，在这种情况下，就需要展示人类是如何一步步思考的。」这位开发者说。
此前的ChatGPT，写的代码就被揪出过不少问题。
原因在于，ChatGPT没有任何标记了对错的内部记录，它其实是一个统计模型。ChatGPT的答案，本质上就是从构成GPT-3的互联网数据语料库中收集的概率结果。
当时OpenAI也说，ChatGPT最合适的定位，应该是编码辅助工具。 但想象一下，如果OpenAI真的教会了ChatGPT「像人类一样一步一步思考」，那它完全可以代替一些需要死记硬背的写代码工作，后果就是，一些「初级」码农被彻底淘汰。
现在，硅谷的高管们正在设想这样的产品，让几乎没有编程经验的人士向AI描述自己的创意和愿景，然后就能构建出任何自己想要的东西，无论是一个网站，还是一个游戏。
几天前，特斯拉的前人工智能主管Andrej Karpathy刚刚在推特上说：「最热门的新编程语言是英语」。
用ChatGPT来debug，效果拔群 这可能并不是一个玩笑，比如当红炸子鸡ChatGPT，就很有潜力。
最近，一项来自美因茨大学和伦敦大学学院的研究发现，ChatGPT不仅可以出色地修复bug，而且开发者还能通过对话来显著提高成功率。
研究人员表示，ChatGPT的debug性能与常见的深度学习方法CoCoNut和Codex相差无几，并且明显优于标准的自动程序修复方法（APR）。
论文地址：https://arxiv.org/abs/2301.08653
用ChatGPT来解决代码问题并不新鲜，但与人类对话的独特能力，使它比其他方法和模型更具优势。
为了评估ChatGPT的debug性能，研究人员使用QuixBugs基准的40个纯Python问题对其进行了测试，然后手动检查建议的解决方案是否正确。
由于ChatGPT给出的答案存在一定的随机性，因此研究人员针对每个问题都会单独测试4次。
与其他自动程序修复的基准不同，QuixBugs包含了相对较小的问题（代码行数少），而这非常适合在对话系统中使用。
在测试过程中，研究人员删除了所有的注释，并询问ChatGPT这段代码是否有bug以及如何修复它。
比如，图1中就是一个关于BITCOUNT问题的例子。其中，第1-2行是向ChatGPT提出的需求；从第4行开始是错误的代码片段。
对于这个例子，我们希望ChatGPT的回答能解决第7行的错误，即nˆ= n - 1应该被替换为n &amp;= n - 1。做为回应，ChatGPT要么给出一段修复完的代码，要么给出一个描述告诉我们应该如何修改。
结果显示，ChatGPT解决了40个bug中的19个，与CoCoNut（19）和Codex（21）相当，但标准的APR方法只解决了其中的7个问题。
当然，因为ChatGPT和Codex都是来自于同一个语言模型系列，所以解决问题的数量差不多也就不足为奇了。
此外，如果我们仔细观察结果还可以发现，ChatGPT并不是每次都能解决基准测试中的bug。仅在BUCKETSORT和FLATTEN这两个问题上，四次都发现了bug，而其他的通常只能成功1-2次。
也就是说，用户在实际使用时，可能需要尝试数次才能获得正确的结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d131768dafd39cd0243cc510b5b08dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecc985769e1956aafd7266fd86117db0/" rel="bookmark">
			宝塔部署「免费WAF」长亭雷池防护个人网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址： 宝塔部署长亭waf防护自己的网站
雷池是长亭科技耗时近 10 年倾情打造的 WAF，核心检测能力由智能语义分析算法驱动。
Slogan: 不让黑客越雷池半步。这里是官方地址：长亭雷池 WAF 社区版 (chaitin.cn)。
部署资源 系统版本：Ubuntu Server 20.04 LTS 64bit
规格：CPU - 2核 内存 - 2GB 系统盘 - SSD云硬盘 40GB
部署方式 单机下部署：宝塔负责运维管理网站、长亭WAF负责防护外来攻击
部署开始 安装宝塔 自行部署
安装网站建设必要软件 我这里是静态站所以只需要安装nginx，docker是后边waf安装需要动用到的所以也是必须安装。根据自己的网站环境需要安装即可。
修改默认端口 这里需要修改 nginx 默认监听端口 80（http）443（https）
找到/www/server/panel/vhost/nginx/0.default.conf文件修改如下：
server { listen 81; server_name _; index index.html; root /www/server/nginx/html; } 找到/www/server/panel/vhost/nginx/phpfpm_status.conf文件修改如下：
server { listen 81; server_name 127.0.0.1; allow 127.0.0.1; location /nginx_status { stub_status on; access_log off; } location /phpfpm_52_status { fastcgi_pass unix:/tmp/php-cgi-52.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecc985769e1956aafd7266fd86117db0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/465d5ea95a35fc898330b2ca6f3ca15f/" rel="bookmark">
			最新SSD固态硬盘颗粒QLC、SLC、MLC、TLC详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要
本文从SSD结构出发，详细介绍NAND闪存芯片QLC、SLC、MLC、TLC之间的区别、各自的优缺点以及其适用的人群。
目录
一、剖析SSD
二、什么是NAND闪存
三、单层单元（Single Level Cell，简称SLC）
四、多层单元（Multi Level Cell，简称MLC）
五、三层单元（Triple Level Cell，简称TLC）
六、四层单元（Quad-level cells，简称QLC）
七、总结
八、四种闪存类型的固态硬盘价格
任何尝试过SSD的人，无一不能向您证明SSD领先于传统HDD的优点，伴随着应用程序的加载速度更快、整体效率更高，以及更强的耐用性与稳定性，毫无疑问，SSD终将会成为每一台家庭计算机中的标配。但您是否曾经想过，在同等容量下，为什么某些SSD比其他其他更贵？正如高性能赛车一样，这一切都是关于引擎盖下的学问。
2019最新更新：以往SSD均采用SLC、MLC、TLC芯片架构，而TLC则比较普遍。但科技迅猛发展，用户的需求也日益增长，如今一款新型闪存芯片QLC已面世。QLC（四层单元）的容量更大，价格也更便宜。想要了解更多相关细节，请继续关注QLC（四层单元）的详细信息。
热点推荐 - ADs都叫兽™备份还原-安全快速地把系统迁移至SSD 自动4K对齐 将系统迁移至SSD时，自动进行4K对齐以提高SSD性能。
支持GPT和MBR 迁移系统时，为SSD自动匹配合适的分区格式。
支持NTFS和FAT32 可迁移不同的文件系统格式，一步到位。
备份速度快 可高达3,000MB/分钟的备份速度。
全方位备份方案 支持系统迁移/系统备份/分区备份/硬盘备份/文件备份/磁盘克隆。
剖析SSD
在详细分析这个问题前，我们可能需要先了解一下SSD的内部构造：
A. NAND闪存：SSD储存数据的部分，以非易失性，即断电后仍能保存数据的内存块。
B. DDR内存：少量的易失性内存（需要电源来维护数据）用于缓存未来访问的信息。
C. 主控芯片：连接NAND闪存与计算机之间的主要电子组件。
什么是NAND闪存？
NAND闪存是比传统硬盘驱动器更好的存储设备，它使用的是非易失性存储技术，即断电后仍能保存资料的存储设备。
NAND闪存由多个以（bit）为单位的单元构成，这些位通过电荷被打开或关闭，如何组织这些开关单元来储存在SSD上的数据，也决定了NAND闪存的命名，比如单层单元（SLC）闪存在每个存储单元中包含1个位。
由于SSD电路板规格具有行业标准尺寸，因此同样的单元物理空间下，多层单元（MLC）能使容量翻倍，三层单元（TLC）更能使容量变为三倍，基于这种发展，为SSD趋向大容量开辟了道路。在性能、体积的优势基础上，NAND闪存目前发展的方向便是降低每比特存储成本、提高存储容量，因此就有了后来的四层单元（QLC），每个存储单元有4个bits的格式。
但是，并非单元层数越多就越好，不同层级的单元NAND闪存有不同的特点，您可以通过下面对SLC、MLC、TLC、QLC的介绍，了解自己对不同NAND闪存的基础需求，选择适合自己的SSD。
单层单元 - SLC多层单元 - MLC三层单元 - TLC四层单元 - QLC
单层单元（Single Level Cell，简称SLC）
单层单元闪存俗称SLC，这种类型的闪存在读写数据时具有最为精确，并且还具有持续最长的数据读写寿命的优点。
SLC擦写寿命约在9万到10万次之间。这种类型的闪存由于其使用寿命，准确性和综合性能，在企业市场上十分受众。但由于储存成本高、存储容量相对较小，在家用市场则不太受青睐。
优点：
读写速度最快的NAND闪存芯片规格。与任何其他类型的闪存相比，擦写寿命和读写循环的周期最长。读取/写入错误的发生几率更小，并可在跨度更大的温度范围内正常运行。 缺点：
市场上最昂贵的NAND闪存类型。通常只有较小的容量。 建议使用对象： 需要大量读取/写入周期的工业级负载，例如服务器。
多层单元（Multi Level Cell，简称MLC）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/465d5ea95a35fc898330b2ca6f3ca15f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c19dfbb1f403051b24305b7c35532e1a/" rel="bookmark">
			几种数据标准化的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最小-最大标准化（Min-Max标准化）：
这种方法将数据线性地映射到[0,1]的范围内。公式为：z = (x - min) / (max - min)，其中x是原始数据，min和max分别是原始数据的最小值和最大值。
Z-Score标准化：
这种方法将数据转化为标准正态分布，均值为0，标准差为1。公式为：z = (x - mean) / std，其中x是原始数据，mean是原始数据的均值，std是原始数据的标准差。
小数定标标准化：
这种方法通过移动小数点的位置来将数据映射到[-1,1]的范围内。公式为：z = x / 10^k，其中x是原始数据，k是一个使得所有数据的绝对值最大值小于1的常数。
均值方差标准化：
这种方法将数据转化为均值为0，方差为1的分布。公式为：z = (x - mean) / sqrt(var)，其中x是原始数据，mean是原始数据的均值，var是原始数据的方差。
Sigmoid标准化：
这种方法将数据通过Sigmoid函数映射到[0,1]范围内。公式为：z = 1 / (1 + exp(-x))，其中x是原始数据。
需要根据具体的数据和应用场景选择合适的标准化方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dace5d89db1adb2e35f535d717193ead/" rel="bookmark">
			ES 常用查询命令汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES 常用查询命令汇总 ES 常用查询命令汇总
一、_cat操作
_cat系列提供了一系列查询elasticsearch集群状态的接口。你可以通过执行
curl -XGET localhost:9200/_cat 获取所有_cat系列的操作 /_cat/allocation /_cat/shards /_cat/shards/{index} /_cat/master /_cat/nodes /_cat/indices /_cat/indices/{index} /_cat/segments /_cat/segments/{index} /_cat/count /_cat/count/{index} /_cat/recovery /_cat/recovery/{index} /_cat/health /_cat/pending_tasks /_cat/aliases /_cat/aliases/{alias} /_cat/thread_pool /_cat/plugins /_cat/fielddata /_cat/fielddata/{fields} 以上的命令中，你也可以后面加一个v，让输出内容表格显示表头 二：_cluster系列
1、查询设置集群状态
curl -XGET localhost:9200/_cluster/health?pretty=true pretty=true表示格式化输出 level=indices 表示显示索引状态 level=shards 表示显示分片信息 2、curl -XGET localhost:9200/_cluster/stats?pretty=true 显示集群系统信息，包括CPU JVM等等 3、curl -XGET localhost:9200/_cluster/state?pretty=true 集群的详细信息。包括节点、分片等。 4、curl -XGET localhost:9200/_cluster/pending_tasks?pretty=true 获取集群堆积的任务 5、修改集群配置 举例： curl -XPUT localhost:9200/_cluster/settings -d ‘{ “persistent” : { “discovery.zen.minimum_master_nodes” : 2 } }’ transient 表示临时的，persistent表示永久的 6、curl -XPOST ‘localhost:9200/_cluster/reroute’ -d ‘xxxxxx’ 对shard的手动控制，参考http://zhaoyanblog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dace5d89db1adb2e35f535d717193ead/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c8b2fde8d4a495440aad35a06f45a41/" rel="bookmark">
			Stable Diffusion入门修炼手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 作为新入门的新手，通常安装完Stable Diffusion之后，一打开界面，在文生图输入girl或者dog，结果出来的画面比较糟糕，看起来像素很低，画面不清晰，人物也不怎么美，等等其他问题，总之就觉得自己生成的图片怎么跟别人差距那么大？是不是大家也曾经这样过来过？
今天就来教会大家，如何正确使用Stable Diffusion，掌握基础知识，能正确做出优秀的作品来，首先，先来个基本公式
一个优秀的作品=CheckPoint大模型+vae+优秀的prompt+embeding+Lora一个4k优秀的作品=CheckPoint大模型+vae+优秀的prompt+embeding+Lora+Controlnet(Tile)增加细节+放大算法 主要角色 1、checkpoint（大模型）
这是我们常说的模型，也可以说是底模，必须指定一个才能作画，它是用来控制大整个画面的风格走势的。比如：写实风格，漫画风格等等，文件名后缀一般为.ckpt和.safetensors，模型大小为2G到8G不等。
checkpoint文件放置路径:\models\Stable-diffusion
2、Lora模型
它也是模型之一，它可以使用也可以不使用，它的出现只为了解决大模型能够微调的一种技术，它的作用主要用于雕刻人物、动漫角色、物品的特征、控制画风、固定特征动作等等。文件名后缀一般为.safetensors，大小在20mb到300mb不等，部分Lora会需要触发词来使用,否则效果不明显。
Lora放置路径:\models\lora
3、embedding
这是我们说的prompt集合，它可以用一个特殊表达式词语来代表一连串的关键词，让填写prompt更简单。举个例子，如果我们想要生成一个皮卡丘，通常需要输入很多描述词，如黄毛、老鼠、长耳朵、腮红等等。但是，如果在我们的embedding库中，已经引入皮卡丘的embedding，我们只需要输入皮卡丘。皮卡丘的embedding打包了所有皮卡丘的特征描述，这样我们就不用每次输入很多单词来控制生成的画面了。
embedding文件放置路径:\models\embedding
4、VAE
Vae也是模型之一，但它的作用只是给画面加载一个滤镜的效果，为了就是修正最终输出的图片色彩，如果不加载VAE可能会出现图片特别灰的情况。一般我们直接选用自动模型就可以了，它会自动帮我们解决这类问题。当然也有些特殊情况需要用到VAE来对色彩进行调节。文件后缀一般为.downloading、.safetensors、.ckpt、.pt
VAE文件的放置路径:\models\vae
prompt的使用 prompt的好坏会决定出图的质量，所以为什么有咒语这一说，因为需要很长的prompt来告诉AI具体要的是什么。于是咒语的优化和书写尤为重要，不过不用担心，市场上现在网站上已经出了很多优秀作品，他们的prompt是开源的，可以复制之后来学习，积累自己的prompt词。
propmt：正向提示词，表示在画面中需要出现的元素negative propmt：负面提示词，表示在画面中不想要出现的元素 1、增加权重
增加权重会让Stable Diffusion出图的时候，会优先考虑画当前的关键词，当权重超过2.0之后，会让图片重复出现当前关键词，导致Stable Diffusion发挥失常
(tag)：1.1倍((tag))：1.1x1.1=1.21倍，每套一层括号，额外x1.1倍{tag}：1.05倍{{tag}}：1.05x1.05=1.1025倍，每套一层大括号，额外x1.05倍 当然权重也不是越高越好的
2、减少权重
减少权重会让Stable Diffusion出图的时候，只是作为参考使用，当权重低于0.5的时候表示当前的关键词可有可无
[tag]：0.9倍[[tag]]：0.9x0.9=0.81倍，每套一层括号，额外x0.9倍 3、精准权重
(tag:1.2)：1.2倍(tag:0.9)：0.9倍 4、使用Lora
lora的使用是一个表达式，如下：
lora:bg:1.2：使用bg的Lora模型，权重为1.2lora:bg:1.2,lora:bgV2:1.5：同样的多个Lora的使用也是可以的 市场上开源的Lora风格还是很多，像图上的盲盒风格（第一个），电影风格（最后一个）
5、使用embedding
embedding的使用非常简单，跟书写prompt一样，直接写到提示词上即可，前提是要下载好当前的embedding模型，不需要任何表达式。embedding最常用的例子就是生成的人物的时候，要求必须是完整的2个眼睛1个鼻子2个耳朵1个嘴巴5个手指，同样的也能在负面提示词中增加embedding，还是同样的人物，不能出现坏手，3个手指，4个手指等
很明显可以看出,在NP（negative prompt）中使用EasyNegative模型和没有使用NP的区别
没有EasyNegative：手部明显画的很粗糙，不太像是人的手使用EasyNegative：手部比较正常，细节也是正常可观 prompt的进阶玩法 进阶玩法能更加精准控制prompt生成我们想要的图
1、混合
混合：强制将不同的主体的元素特征进行混合出图，用AND把多种要素强制融合画进去语法：关键词1 AND 关键词2 AND 关键词3举例：1cat:2 AND 1dog AND 1tiger，想要生成一个狗、猫和老虎 2、渐变
渐变：指的是在作画中，将元素进行过渡的过程语法：[from:to:when] when：表示的迭代步数或比例(数值在0-1范围表示比例，1- 表示步数）From：提示词，表示在 when 前的步数渲染 from 提示词to：提示词，表示在 when 后的步数渲染 to 提示词 举例：(1 girl ,[blue hair:red hair:5])：我们希望画一个女孩，能够有红色和蓝色的头发 3、交替渲染
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c8b2fde8d4a495440aad35a06f45a41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88e253c79a771db1f4c68535f615fb57/" rel="bookmark">
			ubuntu禁用锁屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		右上角 --&gt; 系统设置
亮度和锁屏
锁定（关闭）
20230816
文章目录 基于Ubuntu禁用锁屏1. 为何要禁用锁屏？2. 禁用锁屏：命令行方式2.1 gsettings 命令2.2 dconf 命令 3. 禁用锁屏：图形用户界面（GUI）方式3.1 打开"设置"3.2 进入"电源"选项3.3 禁用锁屏 4. 总结 基于Ubuntu禁用锁屏 在本文中，将会讲解如何在Ubuntu系统中禁用锁屏功能。为了确保文章的深度和技术含量，我们会从不同的角度来介绍这个主题，包括使用命令行和图形用户界面（GUI）两种方式。
1. 为何要禁用锁屏？ 首先，可能有些人会问，为什么需要禁用锁屏呢？锁屏功能在很多情况下是非常有用的，因为它可以在用户暂时离开计算机时保护其私人信息。然而，在某些特定的应用场景中，例如在展示或者长时间运行没有人工干预的程序时，锁屏功能可能会带来一些不便。在这种情况下，禁用锁屏就变得非常有用1。
2. 禁用锁屏：命令行方式 2.1 gsettings 命令 gsettings 是一个用于访问GSettings配置系统的命令行工具2。使用以下命令可以禁用锁屏：
gsettings set org.gnome.desktop.screensaver lock-enabled false 如果想要恢复锁屏功能，只需要改变参数false为true即可：
gsettings set org.gnome.desktop.screensaver lock-enabled true 2.2 dconf 命令 dconf 是一个低级别的配置系统。它的主要目的是提供一个后端，GSettings可以用于读取和写入设置3。使用以下命令可以禁用锁屏：
dconf write /org/gnome/desktop/screensaver/lock-enabled false 如果想要恢复锁屏功能，只需要改变参数false为true即可：
dconf write /org/gnome/desktop/screensaver/lock-enabled true 3. 禁用锁屏：图形用户界面（GUI）方式 对于更喜欢使用图形用户界面的用户，也可以通过简单的几步操作禁用锁屏功能。
3.1 打开"设置" 在Ubuntu的应用菜单中找到并打开“设置”。
3.2 进入"电源"选项 在设置的左侧列表中找到并点击“电源”选项。
3.3 禁用锁屏 在"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88e253c79a771db1f4c68535f615fb57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c7bf672d0842ddf256998982e0582ae/" rel="bookmark">
			wireshark 如何修改抓包时间日期显示格式？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视图–&gt; 时间显示格式
这改成秒之后，看起来舒服多了
20230816
文章目录 修改Wireshark抓包时间日期显示格式介绍开始前准备时间戳显示设置打开Wireshark进入“视图”菜单更改时间显示格式更改日期和时间显示格式 结论参考资料 修改Wireshark抓包时间日期显示格式 介绍 Wireshark是一款非常流行的开源网络协议分析器，被广泛用于网络调试、安全性分析、故障排查以及协议或网络应用程序的开发。一个常见的使用场景是捕获网络数据包以进行实时或后续分析。
默认情况下，Wireshark显示的时间戳格式可能并不适合所有情况。本文将解释如何更改Wireshark的时间和日期显示格式，以便于更好地分析和理解数据。
开始前准备 在开始之前，需要确保已经安装了Wireshark。可以从官方网站下载最新版本的Wireshark。
https://www.wireshark.org/download.html 时间戳显示设置 打开Wireshark 首先，启动Wireshark应用程序。主界面将展示当前网络活动的概览。
进入“视图”菜单 在顶部菜单栏中，找到并点击“视图”菜单项。
更改时间显示格式 在弹出的下拉菜单中，选择"时间显示格式"选项。这将打开一个子菜单，列出了所有可用的时间格式选项。
默认情况下，Wireshark使用的是“自上次标记的秒数”。如果希望更改这个设置，可以选择以下选项之一：
日期和时间自开始捕获以来的秒数自上次捕获的包以来的秒数自第一包以来的秒数自上次标记的秒数 选择合适的时间格式后，即可看到主界面的时间戳已经更新为新的格式。
更改日期和时间显示格式 若要更改日期和时间的显示格式，需要进入Wireshark的首选项设置。
在顶部菜单栏中，选择 “Edit” -&gt; “Preferences”在左侧的类别列表中，选择 “Appearance” -&gt; “Columns”在右侧的详细设置区域，找到 “Time format” 选项点击下拉菜单，选择合适的日期和时间格式点击 “OK” 保存设置 以上步骤完成后，日期和时间的显示格式也会立即更新。
结论 本文介绍了如何修改Wireshark中的时间和日期显示格式，以满足不同的需求和场景。这是一个简单但重要的技巧，可以帮助更好地分析网络数据包。
# 这只是一个例子，实际上无法通过Python代码来控制Wireshark的UI import wireshark # 设置时间格式 wireshark.set_time_format("Date and Time") # 设置日期和时间格式 wireshark.set_date_time_format("YYYY-MM-DD HH:MM:SS") 此外，Wireshark还有许多其他强大的功能和设置，可以进一步定制和优化网络数据包的分析过程。欢迎深入学习和探索。
参考资料 Wireshark官方网站：https://www.wireshark.org/Wireshark官方文档：https://www.wireshark.org/docs/ ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c7bf672d0842ddf256998982e0582ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6174c21209f2d6140086870f9707d361/" rel="bookmark">
			【软件测试】随笔系统测试报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主简介：想进大厂的打工人博主主页：@xyk:所属专栏: 软件测试 随笔系统采用 SSM 框架前后端分离的方法实现，本文主要针对功能：登录，注册，注销，写随笔，删除随笔，随笔详情页等编写测试用例并进行手工测试和自动化测试，测试环境为Windows11操作系统，使用 Google Chrome 浏览器进行测试。
测试方法：本文主要采用黑盒测试方法，不关注代码内部实现，通过一些科学的手段，发起测试数据，关注测试执行结果。测试人员通过模拟真实用户的操作，对系统功能进行测试。
目录
文章目录
一、系统测试用例
二、自动化测试
2.1 引入依赖
2.2 测试前驱动准备
2.3 登录页面
2.4 随笔列表页测试
2.5 随笔详情页测试
2.6 写随笔&amp;写草稿测试
2.7 检验发布是否成功测试
2.8 删除新增的随笔测试
2.9 注销测试
2.10 注册测试
三、测试结果
四、兼容性测试
PC
Pad
手机
浏览器
密码保存是否安全
SQL注入
六、网络测试
有网
弱网
断网
七、性能测试
写在最后
一、系统测试用例 测试用例如果有需要，请联系我~~
二、自动化测试 2.1 引入依赖 &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.seleniumhq.selenium/selenium-java --&gt; // selenium依赖 &lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;version&gt;3.141.59&lt;/version&gt; &lt;/dependency&gt; // 保存截图的包 &lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6174c21209f2d6140086870f9707d361/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/254eae250a62a0f3b631cad93950d45b/" rel="bookmark">
			elasticsearch和kibana的安装和启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
文章目录
前言
一、elasticsearch的下载、配置和启动
1、安装JDK
2、elasticsearch安装、配置和启动
二、kibana
前言 本篇介绍elasticsearch和kibana在Linux系统中的安装和启动操作。
一、elasticsearch的下载、配置和启动 1、安装JDK es是使用Java语言开发的引擎，因此在安装es之前首先要安装JDK，在Oracle官网下载Linux的JDK1.8版本，使用FTP工具上传到服务器上，然后使用命令“tar -xzvf JDK压缩包名称“解压。解压后的文件目录如下：
与Windows一样，Linux同样要配置JDK的环境变量。编辑/etc/profile，文件结尾处添加以下内容：
export JAVA_HOME=刚刚解压的JDK文件路径 export CLASSPATH=$:CLASSPATH:$JAVA_HOME/lib/ export PATH=$PATH:$JAVA_HOME/bin 进入刚刚解压的JDK压缩包目录中使用pwd命令可以打印当前工作目录，如下图，因此笔者的JAVA_HOME=/usr/application/java/jdk1.8.0_301。export命令的作用是将变量声明为环境变量，可以看出来其实Linux的环境变量配置方式与Windows并无差别。
环境变量就配置好之后如果直接使用java -version命令验证是否安装成功会出现”-bash: java: command not found“错误信息，原因是虽然我们配置了/etc/profile文件，但是该文件并没有重新执行，环境变量中也就没有JDK路径。使用”source /etc/profile“命令就可以使得我们刚刚的配置生效，再使用java -version命令看到JDK版本信息表示安装成功了。
2、elasticsearch安装、配置和启动 es的下载有两种方式：①在es官网下载然后通过FTP工具上传到服务器上；②在服务器可以联网的情况下，可以直接使用wget命令下载。笔者使用的是云服务器，因此直接使用第二种方式，使用命令“wget --no-check-certificate https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.0.0-linux-x86_64.tar.gz”下载（此处版本不一样路径就不一样，根据个人需要修改）。
然后使用命令“tar -xzvf 压缩包名称”解压刚刚下载的压缩包。解压之后的es文件主要包含以下几个目录：
目录名称说明bin主要用于存放一些可执行文件，包括es的启动脚本elasticsearchconfig主要用于存放一些配置文件，后面详细介绍较重要的配置文件plugins主要用于存放一些插件，包括后面要使用到的中文分词插件ik等lib主要用于存放引用的相关库logs主要用于存放日志 在config目录中包括两个重要的配置文件elasticsearch.yml和jvm.options，其中elasticsearch.yml包括es的端口号、集群、节点名称等配置，jvm.options主要用来配置JVM参数。elasticsearch.yml主要的配置参数以及说明如下：
参数名称说明cluster.name集群名称node.name节点名称node.attr.rac节点的部落属性，部落可跨越多个集群path.data数据存放目录path.logs日志存放目录bootstrap.memory_lock启动后是否锁定内存，设置为true后，es启动时就将占用配置的内存network.host设置对外的ip地址，此处设置为0.0.0.0即可http.port设置对外服务的端口号，一般默认为9200discovery.seed_hosts种子地址列表，用于配置集群节点地址cluster.initial_master_nodes有资格称为主节点的节点名称gateway.recover_after_nodes设置n个节点启动后进行数据恢复 目前我们仅需配置上面中的一些即可，除了以上配置还有其他的一些没有涉及到的，更全的配置项建议查看官网文档。修改elasticsearch.yml文件如下：
#集群名称 cluster.name: my-elasticsearch #节点名称 node.name: node-1 #数据存放目录 path.data: /usr/application/elasticsearch-7.0.0/data #日志存放目录 path.logs: /usr/application/elasticsearch-7.0.0/logs #对外ip地址 network.host: 0.0.0.0 #对外服务端口号 http.port: 9200 cluster.initial_master_nodes: ["node-1"] 启动es其实就是执行bin目录下的elasticsearch脚本，在执行脚本过程中可能会出现各种错误，此处仅列出笔者遇到的错误和解决方法。使用相对路径的方式执行elasticsearch脚本，例如笔者的工作目录在elasticsearch/bin目录下，使用命令”./elasticsearch”执行后报错如下：
出现以上问题的原因是笔者登陆的当前用户是root，而es出于安全原因不能使用root用户启动，因此我们创建一个新的用户。使用命令“useradd -m 用户名”创建新用户，然后使用命令“su 新用户”切换到新用户esuser。
使用esuser启动es，结果报错如下图：
出现以上错误的原因是esuser用户没有权限，我们切换会root用户并使用”chown -R esuser /usr/application/elasticsearch-7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/254eae250a62a0f3b631cad93950d45b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f023effea4cb0f40189fc92aca397d38/" rel="bookmark">
			k8s之Pod控制器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、Pod控制器及其功用二、pod控制器的多种类型2.1 pod容器中的有状态和无状态的区别 三、Deployment 控制器四、SatefulSet 控制器4.1 StatefulSet由以下几个部分组成4.2 为什么要有headless？4.3 为什么要有volumeClaimTemplate？4.4 滚动更新4.5 扩容及缩容4.6 小结 五、DaemonSet 控制器六、Job 控制器七、CronJob 控制器八、总结8.1 Deployment8.2 StatefulSet8.3 DaemonSet8.4 Job8.5 CronJob 一、Pod控制器及其功用 Pod控制器，又称之为工作负载（workload），是用于实现管理pod的中间层，确保pod资源符合预期的状态，pod的资源出现故障时，会尝试进行重启，当根据重启策略无效，则会重新新建pod的资源。
二、pod控制器的多种类型 1、ReplicaSet: 代用户创建指定数量的pod副本，确保pod副本数量符合预期状态，并且支持滚动式自动扩容和缩容功能。
ReplicaSet主要三个组件组成：
（1）用户期望的pod副本数量
（2）标签选择器，判断哪个pod归自己管理
（3）当现存的pod数量不足，会根据pod资源模板进行新建
帮助用户管理无状态的pod资源，精确反应用户定义的目标数量，但是RelicaSet不是直接使用的控制器，而是使用Deployment。
2、Deployment：工作在ReplicaSet之上，用于管理无状态应用，目前来说最好的控制器。支持滚动更新和回滚功能，还提供声明式配置。
ReplicaSet 与Deployment 这两个资源对象逐步替换之前RC的作用。
3、DaemonSet：用于确保集群中的每一个节点只运行特定的pod副本，通常用于实现系统级后台任务。比如ELK服务
特性：服务是无状态的
服务必须是守护进程
4、StatefulSet：管理有状态应用
5、Job：只要完成就立即退出，不需要重启或重建
6、Cronjob：周期性任务控制，不需要持续后台运行
2.1 pod容器中的有状态和无状态的区别 有状态实例
实例之间有差别，每个实例都有自己的独特性，元数据不同，例如etcd，zookeeper
实例之间不对等的关系，以及依靠外部存储的应用无状态实例
deployment认为所有的pod都是一样的
不用考虑顺序的要求
不用考虑在哪个node节点上运行
可以随意扩容和缩容 三、Deployment 控制器 部署无状态应用
管理Pod和ReplicaSet
具有上线部署、副本设定、滚动升级、回滚等功能
提供声明式更新，例如只更新一个新的image
应用场景：web服务
vim nginx-deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment labels: app: nginx spec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f023effea4cb0f40189fc92aca397d38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81f9829c250fcf8ce0e9379f90578124/" rel="bookmark">
			什么是SpringMVC以及和 SpringBoot 的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😀前言
本文是springMVC专栏的--什么是SpringMVC以及和 SpringBoot 的关系
🏠个人主页：[尘觉主页](https://blog.csdn.net/apple_67445472?type=blog)
🧑个人简介：大家好，我是尘觉，希望我的文章可以帮助到大家，您的满意是我的动力😉😉
在csdn获奖荣誉: 🏆csdn城市之星2名
⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　💓Java全栈群星计划top前5
⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　🤗 端午大礼包获得者
💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，感谢大家的观看🥰
如果文章有什么需要改进的地方还请大佬不吝赐教 先在次感谢啦😊
文章目录
什么是SpringMVC已经和 SpringBoot 的关系
SpringMVC 介绍
说明是 MVC
MVC 全称∶ Model 模型、View 视图、 Controller 控制器。
MVC 是一种思想
MVC 示意图
理解和解读
SpringMVC 特点&amp;概述
梳理 Spring SpringMVC SpringBoot 的关系
什么是SpringMVC已经和 SpringBoot 的关系 SpringMVC 介绍 官方文档Web on Servlet Stack (spring.io)
说明是 MVC MVC 全称∶ Model 模型、View 视图、 Controller 控制器。 MVC 最早出现在 JavaEE 三层中的 Web 层，它可以有效的指导 WEB 层的代码如何有效分离，单独工作。View 视图∶只负责数据和界面的显示，不接受任何与显示数据无关的代码，便于程序员和美工的分工合(Vue/JSP/Thymeleaf/HTML)Controller 控制器∶只负责接收请求，调用业务层的代码处理请求，然后派发页面，是一个"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81f9829c250fcf8ce0e9379f90578124/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fd1f71eaff8d05c25c741d0757321a9/" rel="bookmark">
			python控制obs实现无缝切换场景！obs-websocket-py
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
最近一直在研究孪生数字人wav2lip。目前成果可直接输入高清嘴型，2070显卡1分钟音频2.6分钟输出。在直播逻辑上可以做到1比1.3这样，所以现在开始研究直播。在逻辑上涉及到了无缝切换，看到csdn上有一篇文章还要vip解锁。。。那自己研究吧！在这里我们以我现在的逻辑来实现一下无缝切换！
举一个例子
来梳理一下我的逻辑，通过obs推场景1中的一个视频，循环播放一个不说话闭嘴的视频。当生成好说话的视频后控制obs修改场景2的来源视频路径然后自动切换场景2进行播放，然后监听场景2视频播放完毕自动切回场景1不说话的视频~！
来吧！说干就干！
obs-api文档：https://github.com/obsproject/obs-websocket/blob/master/docs/generated/protocol.md#getmediainputstatus
不要问我为什么，因为百度出来的相关现成轮子太少了！最好看文档来选择和实现自己的业务，很简单的！
一、创建obs-ws服务端
二、创建两个场景和每个场景各添加一个视频来源
SceneName场景添加一个MediaSourceNameA来源，添加视频A
SceneName1场景添加一个MediaSourceNameB来源，添加视频A【当数字人视频生成好通过py替换掉这个路径的】
SceneName场景的MediaSourceNameA的视频A设置循环播放。
目的是默认播放推流SceneName场景MediaSourceNameA的视频A，也就是不说话时的视频。
三、python控制obs无缝切换场景
安装依赖
pip install obs-websocket-py 连接obs
# 连接OBS ws = obsws('192.168.31.73', 4455, 'YqShGFfdYaGxG7DG') ws.connect() 这里地址来自这里
工具-》obs-websocket 设置 点击显示连接信息，可以看到ip和密码。
当数字人视频生成好后执行下面代码！
# 修改MediaSourceNameB来源的视频路径 ws.call(requests.SetInputSettings(inputName="MediaSourceNameB", inputSettings={ "local_file": os.path.abspath(video_path) })) # 激活SceneName1场景播放视频 ws.call(requests.SetCurrentProgramScene(sceneName='SceneName1')) 可以监听MediaSourceNameB场景的视频是否播放完毕，当播放完毕切换回SceneName场景的循环播放视频。
while True: time.sleep(0.1) # 监听MediaSourceNameB视频播放状态 status = ws.call(requests.GetMediaInputStatus(inputName="MediaSourceNameB")).datain print(status) # 播放完毕则切换回激活循环播放的SceneName场景视频 if status['mediaState'] == 'OBS_MEDIA_STATE_ENDED': ws.call(requests.SetCurrentProgramScene(sceneName='SceneName')) break 关闭websocket连接
# 断开连接 ws.disconnect() 四、实现自定义逻辑
什么？一头雾水？？？不难，我教你ya！
打开文档
https://github.com/obsproject/obs-websocket/blob/master/docs/generated/protocol.md#getmediainputstatus
比如查询视频播放状态
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fd1f71eaff8d05c25c741d0757321a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1ebbbc931af321c7c34d0cf8f549f2e/" rel="bookmark">
			jmeter上一个线程组变量如何在下一个线程组中使用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、先把需要添加的都加上，实在不会的就去看看新手基础教程，这里就不在一一演示了。
2、首先我们运行一下，看下接口是否OK。我们这里后面接口需要使用的就是这三个变量。
3、因为还没有设置变量并且引用所以后面两个接口不通。
4、先添加一个Debugsampler，然后再运行一下。
5、添加取样器并且把取样器名称改成需要使用的变量名称，后面的根据这样依次修改即可。
6、然后运行，查看取值是否正确。
7、打开函数助手找到setProperty函数，设置函数，自动生成函数字符串。
8、再次添加Dugsampler，修改名称。此步骤很重要，必不可少。
9、检查上面属性设置是否正确，添加属性显示，添加成功后再运行，运行成功后查看结果。
10、打开函数助手找到P函数，设置P函数。 11、设置成功后直接引用即可，哪里需要就放在哪里。
12、设置完成之后，运行一下，查看最后结果。
希望对你有所帮助，谢谢~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e26035a008536c675e6f1f237ffd548b/" rel="bookmark">
			Spring学习笔记之Spring IoC注解式开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 声明Bean的注解Component注解Controller注解Service注解Repository Spring注解的使用选择性实例化Bean负责注入的注解@Value@Autowired与@Quaifier@Resource 全注解式开发 注解的存在主要是为了简化XML的配置。Spring6倡导全注解开发
注解怎么定义，注解中的属性怎么定义？注解怎么使用通过反射机制怎么读取注解
注解怎么定义，注解中的属性怎么定义？ package com.powernode.annotation; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target(value = {ElementType.TYPE}) @Retention(value = RetentionPolicy.RUNTIME) public @interface Component { String value(); } 以上是自定义了一个注解：Component
该注解上面修饰的注解包括：Target注解和Retention注解，这两个注解被称为元注解。
Target注解用来设置Component注解可以出现的位置，以上代表表示Component注解只能用在类和接口上。
Retention注解用来设置Component注解的保持性策略，以上代表Component注解可以被反射机制读取。
String value（）；是Component注解中的一个属性。该属性类型String属性名是value。
//使用User package com.powernode.bean; import com.powernode.annotation.Component; @Component(value = "userBean") public class User { } 语法格式：@注解类型名（属性名=属性值，属性名=属性值，属性名=属性值....）
userBean为什么使用双引号括起来，因为value属性是String类型，字符串
另外如果属性名是value，则在使用的时候可以省略属性名
package com.powernode.bean; import com.powernode.annotation.Component; //@Component(value = "userBean") @Component("userBean") public class User { } 通过反射机制怎么读取注解？
//有注解的Bean package com.powernode.bean; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e26035a008536c675e6f1f237ffd548b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a76648413758accd8e64bdfa06fb6259/" rel="bookmark">
			【k8s】基于Prometheus监控Kubernetes集群安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基于Prometheus监控Kubernetes集群安装部署
一、环境准备
二、部署kubernetes集群
三、部署Prometheus监控平台
四、部署Grafana服务
五、grafana web操作
基于Prometheus监控Kubernetes集群安装部署 一、环境准备 IP地址
主机名
组件
192.168.100.131
k8s-master
kubeadm、kubelet、kubectl、docker-ce
192.168.100.132
k8s-node01
kubeadm、kubelet、kubectl、docker-ce
192.168.100.133
k8s-node02
kubeadm、kubelet、kubectl、docker-ce
注意：所有主机配置推荐CPU：2C+ Memory：2G+
项目拓扑
1、主机初始化配置
所有主机配置禁用防火墙和selinux [root@localhost ~]# setenforce 0 [root@localhost ~]# iptables -F [root@localhost ~]# systemctl stop firewalld [root@localhost ~]# systemctl disable firewalld [root@localhost ~]# systemctl stop NetworkManager [root@localhost ~]# systemctl disable NetworkManager [root@localhost ~]# sed -i '/^SELINUX=/s/enforcing/disabled/' /etc/selinux/config 2、配置主机名并绑定hosts，不同主机名称不同
[root@localhost ~]# hostname k8s-master [root@localhost ~]# bash [root@k8s-master ~]# cat &lt;&lt; EOF &gt;&gt; /etc/hosts 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a76648413758accd8e64bdfa06fb6259/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c310e331dae35ee66187ac976a4c093/" rel="bookmark">
			什么是提示工程（Prompt Engineering）？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示工程（Prompt Engineering）是一种在人工智能（AI）领域中优化和引导模型表现的方法，通过设计和使用特定的文本提示或其他形式的引导来帮助模型生成所需的输出。这种工程方法主要用于生成式AI系统，如自然语言处理和机器翻译等领域。通过有效的提示设计，可以提高用户的使用体验和效率，使系统能够更准确地生成人们所需要的输出成果。
提示工程是一种相对较新的技术，它结合了自然语言处理、机器学习和人机交互等多个领域的知识。这种工程方法的目标是创建高度有效和可控的AI系统，使其能够准确、可靠地执行特定任务。提示工程注重于设计提示语，以充分利用AI模型的能力和灵活性，同时提高用户与系统的交互体验。
在实践中，提示工程需要结合具体的场景和任务进行设计。针对不同的AI模型和应用领域，提示的设计会有所不同。提示可以是给定的输入信息，用于指导模型生成符合要求的输出；也可以是问题或指令，帮助模型解决特定的问题或执行特定的任务。
在自然语言处理领域中，提示工程通常涉及设计用于生成文本的提示语句。例如，在文本摘要任务中，提示可以是给定文章的标题或关键段落，用于指导模型生成符合要求的摘要；在机器翻译任务中，提示可以是源语言句子和目标语言句子之间的映射关系，帮助模型准确地翻译文本。
除了自然语言处理领域，提示工程还在其他领域中发挥着重要作用。例如，在图像识别领域中，提示可以是图像中的特定对象或场景，用于指导模型识别和分类图像。在语音识别领域中，提示可以是语音信号中的特定词语或短语，用于指导模型识别和转录语音。
提示工程具有以下优点：
提高效率和准确性：通过设计有效的提示，可以提高AI模型生成输出成果的效率和准确性。这可以为用户提供更好的使用体验，同时减少错误和不必要的返工。提高交互体验：通过提供明确的引导和指示，提示工程可以帮助用户更轻松地与系统进行交互。这可以减少用户的学习和适应时间，同时提高用户的使用满意度。灵活性和可扩展性：提示工程具有灵活性和可扩展性的优点。随着技术的不断发展和进步，可以轻松地修改和更新提示来适应新的需求和技术变化。 总之，提示工程是一种在人工智能领域中优化和引导模型表现的方法。通过设计和使用特定的文本提示或其他形式的引导来帮助模型生成所需的输出。这种工程方法可以为用户提供更加智能、高效和个性化的交互体验，同时提高AI系统的准确性和可靠性。随着技术的不断发展，提示工程将在更多领域中得到广泛应用和推广。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00b052b2c63fb9afe04991a975046234/" rel="bookmark">
			UEditor 百度富文本编辑器使用 遇到问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小小吐槽 碰到前后不分离项目，富文本使用的UEdtior UEditor 点击上传图片转base64 在ueditor.all.js文件中找到这个 callback()函数 这里使用根据图片的url转成base64
UEditore 粘贴图片转base64 UEditor回显图片（base64） 把ueditor.all.js 中 swictch 循环 case 'img'注释掉
取消自动保存功能 所以最后的解决方法是：
1、ueditor.config.js，enableAutoSave的注释去掉并设置成false，saveInterval的注释也去掉设置成0；
2、修改ueditor.all.js，在'contentchange': function () {函数的第一行添加代码：
if (!me.getOpt('enableAutoSave')) {return;}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30664aef1c54879655b605f77ef5d62f/" rel="bookmark">
			System.ArgumentException: 必须将 Argument 初始化为 false
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# 中使用 Monitor 锁定资源 并获取锁定状态 需要注意 每次获取锁 Monitor.Enter 都要保证 islock1的值为false ,否则就会发生错误
public static bool islock1 = false;
public static void camera1_code(CogImage8Grey img)
{
Monitor.Enter(cam1Object,ref islock1);
******
if (islock1)
{
islock1 = false;
Monitor.Exit(cam1Object);
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1289aa1f20a7303f4b109eb2ba391a42/" rel="bookmark">
			领悟《信号与系统》之 LTI 系统的卷积积分及性质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LTI 系统的卷积积分及性质 一、卷积积分及其性质1. 任意信号的分解2. 任意信号作用下的零状态响应3. 卷积的定义4. 卷积性质1. 代数性质2. f(t)与奇异信号的卷积 （非常重要）3. 卷积的微分和积分4. 卷积时移 5. 常用信号的卷积公式 二、总结重点 笔记主要记录一下卷积定义、性质、微积分、时移运算以及卷积求零状态响应的知识点。 一定要记住卷积定义的公式，基本上性质和微积分、时移都是在定义的基础上推出来的。 一、卷积积分及其性质 1. 任意信号的分解 其实就是利用了微分的数学定义
用 δ(t) 的积分表示信号
2. 任意信号作用下的零状态响应 求任意信号作用下 LTI 连续时间系统的零状态响应，可以先对任意信号进行分解，然后利用 LTI 连续时间系统的线性时不变特性求解。
这个是一种比较简单的求解时域方法。
3. 卷积的定义 我这里没说图解法、我用的很少
f1 与 f2 的卷积积分为：
结合 信号分解的 思想，系统在任意激励信号 f (t)作用下的零状态响应 y (t)f 就可以用卷积积分的方法来求取，即
当已知系统的冲激响应h(t) 和激励信号 f (t)时，通过计算二者卷积积分的方法求取系统的零状态响应 yf(t) 4. 卷积性质 1. 代数性质 交换律：卷积积分是关于 f1(t) 和 f2(t) 对称的。
f1(t) * f2(t) = f2(t) * f1(t)
证明过程：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1289aa1f20a7303f4b109eb2ba391a42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b50c025e17968abd6c5897840d157870/" rel="bookmark">
			揭秘热门工作秘籍：ChatGPT大显身手！轻松提升工作效率的高效Prompt技巧曝光！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
01 背景
福利：文末有chat-gpt纯分享，无魔法，无限制
02 AI 可以帮助程序员做什么？
2.1 技术知识总结
2.2 拆解任务
2.3 阅读代码/优化代码
2.4 代码生成
2.5 生成单测
2.6 更多 AI 应用/插件
AIPRM
Voice Control for ChatGPT
ChatGPT Sidebar
著名应用工具使用体验：Bing Copilot、ChatGPT、Google Bard
Google Bard (LaMDA)：Google 近期发布的AI工具目前只支持英文。特点是能够给出多个回答，而且响应速度很快。集成了 Google it，点击之后会帮你生成一个最适合你的问题的 google 搜索关键词。这算是和 Bing Copilot 反其道而行之，一个是将 chat 集成到搜索里，一个是将搜索集成到了 chat 中。
03 Prompt 能力
3.1 Prompt 是什么？
3.2 Better Prompt
开发者可以利用它的上下文能力，帮助自己纠正语法以及提供更好的 prompt 的训练。
04总结
01 背景 福利：文末有chat-gpt纯分享，无魔法，无限制 尤记得每个月「本月全球最流行编程语言」发布的时候，都会在程序员届掀起腥风血雨。“Java 下降了一名，怎么可能”、“JavaScript 又占据榜首，门槛太低，写个脚本就算用了吗?”、“C# 这种单平台语言也就是闭环生态内的产物了” 这类言论层出不穷，大家也都乐此不疲，已然是以前的流量密码。
然而这一切现在似乎已经悄悄变化了。大家开玩笑说现在使用的最多的编程语言，已经是英语(自然语言)了。
现在 GPT 已经开启了人工智能狂潮。在社交圈里不聊上两句 ChatGPT，感觉不只是要和时代脱节，更是已经被开除 IT 籍了 ～
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b50c025e17968abd6c5897840d157870/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad3af348cb8516c48cfdbf4eb8d2a70f/" rel="bookmark">
			截图工具分享（可截成gif动图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一个截图工具screentogif，windows下直接安装即可使用，详细内容请查看：https://www.screentogif.com/
使用方法如下：
1、打开软件，点击“录像机”
2、拖动边框，选择好合适区域，点击“录制”
3、录制过程中可以暂停，录制完成点击“停止”
4、停止后，选择“文件”
5、点击“另存为”-“保存”，即可输出动态gif截图视频
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94a77a9e15dc1713c0b8dbc1eb3348a2/" rel="bookmark">
			android studio运行项目报错PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderExce
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到问题 android studio今天编译突然就遇到问题：
A problem occurred configuring root project 'android'. &gt; Could not resolve all artifacts for configuration ':classpath'. &gt; Could not download MobSDK2022-2023.0713.1137.jar (com.mob.sdk:MobSDK2022:2023.0713.1137) &gt; Could not get resource 'https://mvn.mob.com/android/com/mob/sdk/MobSDK2022/2023.0713.1137/MobSDK2022-2023.0713.1137.jar'. &gt; Could not GET 'https://mvn.mob.com/android/com/mob/sdk/MobSDK2022/2023.0713.1137/MobSDK2022-2023.0713.1137.jar'. &gt; PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target 解决方案 下载证书，导入到android studio中即可。
步骤如下，以MAC电脑为例：
https://mvn.mob.com/android/com/mob/sdk/MobSDK2022/2023.0713.1137/MobSDK2022-2023.0713.1137.jar 先打开看一下能否正常下载，如果能正常下载说明页面是没问题的。再打开https://mvn.mob.com/ 网站，不用管里面显示的内容。
点击锁图标→连接是安全的 →证书有效→导出
先去到Android studio jdk的证书目录下 cd /Applications/Android Studio.app/Contents/jre/Contents/Home/lib/security 进入security目录后，使用keytool命令导入证书
keytool -import -alias mob -keystore cacerts -file /Downloads/_.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94a77a9e15dc1713c0b8dbc1eb3348a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fca244ed038983d97ca31c4bd5182159/" rel="bookmark">
			基于PyG Temporal的DCRNN（扩散卷积递归神经网络）代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文名称：Diffusion Convolutional Recurrent Neural Network: Data-Driven Traffic Forecasting
论文下载：https://arxiv.org/abs/1707.01926
论文解读： 论文翻译。由于我们这里主要进行论文代码的展示，论文的解读就不进行详细的讲解。
代码 PyG Temporal中提供了大量已经编译好的图卷积递归神经网络模型，DCRNN模型对应的部分如下：
in_channels：代表输入模型进行处理的数据特征的维度，比如想要基于T个历史时间预测T+1时刻道路的交通流量，这里的in_channels=T。
out_channels：经过DCRNN模型处理后输出特征的维度。
K：扩散过程通过在图G上进行随机游走，来聚合节点之间的特征，这个K相当于扩散程度，与GCN中的K相似。
模型主要进行节点的预测任务，给定节点T个时刻的历史特征，通过DCRNN模型来对T+1时刻的节点特征进行预测。节点数为10，节点之间的拓扑结构为随机生成的拓扑结构，通过邻接矩阵A来表示。具体代码实现如下：
import numpy as np import pandas as pd import torch import torch.nn.functional as F import matplotlib.pyplot as plt from sklearn.preprocessing import StandardScaler from sklearn.preprocessing import MinMaxScaler from torch_geometric_temporal.nn.recurrent import DCRNN from torch_geometric_temporal import StaticGraphTemporalSignal from tqdm import tqdm TRAINING_LENGTH = 72 # 载入节点信息并进行预处理 node_cpu0 = pd.read_csv(r'v.2_data/v.2_CPU.csv', header=None)#(10, 1008) node_cpu0 = node_cpu0.transpose()#(1008, 10) node_cpu = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fca244ed038983d97ca31c4bd5182159/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/579edd9fb8f7f87067a228453a6ba102/" rel="bookmark">
			条件熵和信息增益代码&#43;结果展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这篇文章中我们详细的讨论了随机熵、时间无关熵和真实熵，但是他们都是针对单一变量的时间序列进行的处理，无法反映多变量时间序列之间的关系。那么要如何反映两个变量之间是否存在内在联系呢，这里就不得不提到条件熵：
信息熵反映的是随机变量的所有可能取值，即所有可能发生事件所带来的信息量的期望。那么信息熵指的是定义为X给定条件下，Y的条件概率分布的熵对X的数学期望。话不多说直接上代码：
# 计算信息熵 def calc_ent(x): """ calculate shanno ent of x """ x_value_list = set([x[i] for i in range(x.shape[0])]) ent = 0.0 for x_value in x_value_list: p = float(x[x == x_value].shape[0]) / x.shape[0] logp = np.log2(p) ent -= p * logp return ent # 计算条件熵 def calc_condition_ent(x, y): """ calculate ent H(y|x) """ # calc ent(y|x) x_value_list = set([x[i] for i in range(x.shape[0])]) ent = 0.0 for x_value in x_value_list: sub_y = y[x == x_value] temp_ent = calc_ent(sub_y) ent += (float(sub_y.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/579edd9fb8f7f87067a228453a6ba102/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f67ce5705883a1b4f16116134bb031/" rel="bookmark">
			【附安装包】Maple 2023安装教程，数学问题迎刃而解！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件下载
软件：Maple版本：2023
语言：简体中文
大小：3.51G
安装环境：Win11/Win10/Win8/Win7硬件要求：CPU@2.0GHz 内存@4G(或更高）下载通道①百度网盘丨下载链接：
https://pan.baidu.com/s/1Y-NmdmFaF22H9zucZHdNyg?pwd=6789
提取码：6789
软件介绍
Maple是一个通用型的商用计算机代数系统，让数学问题的分析、探索、可视化及求解变得更为简便。包含高级数学计算功能、可视化、专业应用领域等众多新功能，对于数学家、教育工作者、工程师和科学家非常有用。 安装步骤
1.鼠标右击【Maple 2023】压缩包（win11及以上系统需先点击“显示更多选项”）【解压到 Maple 2023】。
2.打开解压后的文件夹，鼠标右击【Setup】选择【以管理员身份运行】。
3.点击【OK】。
4.点击【Next】。
5.选择【I accept……】，点击【Next】。
6.修改路径地址中的第一个字符C可更改安装位置（如：把C改为D软件将安装到D盘），点击【Next】。
7.选择【Yes】，点击【Next】。
8.选择【single user……】，点击【Next】。
9.取消勾选【Enable periodic……】和【Check for ……】，点击【Next】。
10.点击【Next】。
11.安装中……
12.取消勾选【Activate……】，点击【Finish】。
13.打开安装包解压后的【Maple 2023】文件夹，双击打开【Crack】文件夹。
14.选中该文件夹在的两个文件，鼠标右击选择【复制】。
15.鼠标右击桌面【Maple 2023】图标选择【打开文件所在的位置】。
16.点击路径地址中的【Maple 2023】。
17.鼠标右击空白处选择【粘贴】。
18.点击【替换替换目标中的文件】。
19.双击桌面【Maple 2023】图标启动软件。
20.安装成功！
---------------------------END--------------------------- 题外话 “不是只有程序员才要学编程？！”
认真查了一下招聘网站，发现它其实早已变成一项全民的基本技能了。
连国企都纷纷要求大家学Python!
世界飞速发展，互联网、大数据冲击着一切，各行各业对数据分析能力的要求越来越高，这便是工资差距的原因，学习编程顺应了时代的潮流。
在这个大数据时代，从来没有哪一种语言可以像Python一样，在自动化办公、爬虫、数据分析等领域都有众多应用。
更没有哪一种语言，语法如此简洁易读，消除了普通人对于“编程”这一行为的恐惧，从小学生到老奶奶都可以学会。
《2020年职场学习趋势报告》显示，在2020年最受欢迎的技能排行榜，Python排在第一。
它的角色类似于现在Office，成了进入职场的第一项必备技能。
如果你也想增强自己的竞争力，分一笔时代的红利，我的建议是，少加点班，把时间腾出来，去学一学Python。
因为，被誉为“未来十年的职场红利”的Python，赚钱、省钱、找工作、升职加薪简直无所不能！
目前，Python人才需求增速高达**174%，人才缺口高达50万，**部分领域如人工智能、大数据开发， 年薪30万都招不到人！
感兴趣的小伙伴，赠送全套Python学习资料，包含面试题、简历资料等具体看下方。
👉CSDN大礼包🎁：全网最全《Python学习资料》免费赠送🆓！（安全链接，放心点击）
一、Python所有方向的学习路线
Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python必备开发工具
工具都帮大家整理好了，安装就可直接上手！
三、最新Python学习笔记
当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、Python视频合集
观看全面零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例
纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59f67ce5705883a1b4f16116134bb031/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5476d5c3d86325becdfe6a1497e6415d/" rel="bookmark">
			机器学习入门书：动手学机器学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上海交通大学ACM班创办人俞勇教授团队编写，"西瓜书"作者周志华力荐的机器学习入门书：《动手学机器学习》出版啦！
动手学机器学习 本书系统介绍了机器学习的基本内容及其代码实现，是一本着眼于机器学习教学实践的图书。
本书包含4个部分：第一部分为机器学习基础，介绍了机器学习的概念、数学基础、思想方法和简单的机器学习算法；第二部分为参数化模型，讲解线性模型、神经网络等算法；第三部分为非参数化模型，主要讨论支持向量机和决策树模型及其变种；第四部分为无监督模型，涉及聚类、降维、概率图模型等多个方面。本书将机器学习理论和实践相结合，以大量示例和代码带领读者走进机器学习的世界，让读者对机器学习的研究内容、基本原理有基本认识，为后续进一步涉足深度学习打下基础。
本书适合对机器学习感兴趣的专业技术人员和研究人员阅读，同时适合作为人工智能相关专业机器学习课程的教材。
系统梳理机器学习的主干知识
专业评论：
本书从机器学习的基本概念入手，结合sklearn机器学习算法库，以大量示例和代码带领读者走进机器学习的世界。
——周志华 南京大学计算机科学与技术系主任兼人工智能学院院长
本书源自上海交通大学 ACM 班机器学习课程讲义，着力帮助读者融会贯通，深入理解机器学习原理并提高动手实战能力，是培养新一代人工智能实战型人才不可多得的好书。
——朱军 清华大学计算机科学与技术系博世人工智能冠名教授、IEEE会士
本书是全面、系统的机器学习教材，主要介绍机器学习的核心概念及代表性方法。本书不仅涵盖神经网络、集成学习等经典的机器学习理论，还配备可在线运行的代码，帮助读者通过动手实战来加强对机器学习技术的理解。无论是初学者还是行业人士，都能从本书中得到有价值的帮助和指导。
——李文新 北京大学计算机学院教授、北京市教学名师、北京大学计算机实验教学中心主任
本书形态新颖、丰富。纸质图书对机器学习的知识体系进行系统介绍，理论解读视频课程对疑难知识点进行更透彻的讲解，代码支持在线运行、修改，习题帮助读者检验、巩固学习效果，教学课件帮助高校教师备课。本书既能为行业人士自学机器学习提供体系化的学习资源，又能通过动手学的方式帮助高校教师和学生完成机器学习的教学与学习。
——黄萱菁 复旦大学计算机科学技术学院、现代语言学研究院教授
智能化升级已成为当代企业在数字化转型后攀登的新阶梯。为此，需要大量具备专业知识的人工智能人才，他们不仅要深入理解人工智能的理论和算法，更应具备实战能力，以应对实际应用场景中的挑战。本书正是为培养这种实战型人工智能人才而编写的，内容详实、示例丰富、代码清晰，强烈推荐给所有希望深入了解人工智能并进行动手实战的读者。
——刘铁岩 微软杰出首席科学家、微软研究院科学智能中心亚洲区负责人、微软亚洲研究院副院长
上海交通大学ACM班注重培养学生扎实的专业基础和动手实战能力。俞勇老师团队编写的这本书体现了上海交通大学ACM班在人工智能基础模块人才培养方面的特色理念，在此推荐给各位读者。
——陈天奇 卡内基梅隆大学机器学习系、计算机科学系助理教授 本书每一章都由一个Python Notebook组成，Notebook中包括机器学习相关概念定义、理论分析、算法过程和可运行代码。读者可以根据自己的需求白行选择感兴趣的部分阅读。例如，只想学习各个算法的整体思想而不关注具体实现细节的读者，可以只阅读除代码以外的文字部分;已经了解算法原理，只想要动手进行代码实践的读者，可以只关注代码的具体实现部分。
本书面向的读者主要是对机器学习感兴趣的高校学生(不论是本科生还是研究生)、教师、企业研究员及工程师。在阅读本书之前，读者需要掌握一些基本的数学概念和数理统计基础知识（如矩阵运算、概率分布和数值分析方法等)。
本书包含4个部分。第一部分为机器学习基础，主要讲解机器学习的基本概念以及两个最本书包含4个部分.第一部分为机器学习基础，主要讲解机器学习的基本概念以及两个最基础的机器学习算法，即KNN和线性回归，并基于这两个算法讨论机器学习的基本思想和实验原则。这一部分涵盖了机器学习最基础、最主要的原理和实践内容，完成此部分学习后就能在大部分机器学习实践场景中上手解决问题。第二部分为参数化模型，主要讨论监督学习任务的参数化模型，包括线性模型、双线性模型和神经网络。这类方法主要基于数据的损失函数对模型参数求梯度，进而更新模型，在代码实现方面具有共通性。第三部分为非参数化模型，主要关注监督学习的非参数化模型，包括支持向量机、树模型和梯度提升树等。把非参数化模型单独作为一个部分来讨论，能更好地帮助读者从原理和代码方面体会参数化模型和非参数化模型之间的区别和优劣。第四部分为无监督模型，涉及聚类、PCA降维、概率图模型、EM算法和自编码器，旨在从不同任务、不同技术的角度讨论无监督学习，让读者体会无监督学习和监督学习之间的区别。本书的4个部分皆为机器学习的主干知识，希望系统掌握机器学习基本知识的读者都应该学习这些内容。
本书为机器学习的入门读物，也可以作为高校机器学习课程教学中的教材或者辅助材料。
本书提供的代码都是基于Python 3编写的，读者需要具有一定的Python编程基础。我们对本书用到的Python工具库都进行了简要说明。每一份示例代码中都包含可以由读者白行设置的变量，方便读者进行修改并观察相应结果，从而加深对算法的理解。木书的源代码可在仓库https://github.com/boyu-ai/Hands-on-ML中下载。书中会尽可能对一些关键代码进行注释，但我们也深知无法将每行代码都解释清楚，还望读者在代码学习过程中多思考，甚至翻阅一些其他资料，以做到完全理解。
在入门机器学习的基础上，如果读者有兴趣以动手学的形式进一步了解深度学习，推荐阅读《动手学深度学习》;
如果读者有兴趣以动手学的形式进一步了解强化学习，推荐阅读《动手学强化学习》。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0311250523ce13ce830464784036a42/" rel="bookmark">
			Source Insight 搜索不到字符解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图默认设置搜索 只找到一个位置
把whole Words Only 的勾选去掉就可以
调节标识处选择不同的搜索方式，把Whole Words Only勾选去掉就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee1494c9eaefb8d7f0b6f8e2275a5201/" rel="bookmark">
			2023最新版IntelliJ IDEA安装教程（非常详细）从零基础入门到精通，看完这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件下载
软件：JetBrains
版本：2023
语言：中文/英文
大小：4.38G
安装环境：Win11/Win10/Win8/Win7硬件要求：CPU@2.0GHz 内存@4G(或更高）下载通道①百度网盘丨64位下载链接：
https://pan.baidu.com/s/1R23DZr4vW1nEr_4T28jlsw?pwd=6789
提取码：6789
软件介绍
JetBrains 是一家专注于创建智能开发工具的前沿软件公司,包括:行业中领头的 Java IDE – IntelliJ IDEA,以及 Kotlin 编程语言。旗下常用的软件有IntelliJ IDEA、PhpStorm、RubyMine、Rider、WebStorm、goland、CLion、Pycharm，本安装包集成以上8款软件，用户可根据自己的需求选择安装一款或多款。
安装步骤
温馨提示：JetBrains2023压缩包里包含JetBrains旗下8个软件（IntelliJ IDEA、PhpStorm、RubyMine、Rider、WebStorm、goland、CLion、Pycharm），您可以根据自己的需求选择安装一款或多款，8个软件的安装、激活、汉化步骤完全相同，其它产品可完全参考本步骤！
第一部分：JetBrains软件通用安装步骤
1.鼠标右击【JetBrains2023】压缩包（win11及以上系统需先点击“显示更多选项”）选择【解压到 JetBrains2023】。
2.打开解压后的文件夹，鼠标右击需要安装的软件【如：InteaIU-2023.1】选择【以管理员身份运行】。
3.点击【Next】。
4.修改路径地址中的首字符C可更改安装位置（如：将C改为D表示安装到D盘），点击【Next】。
5.勾选所有项目，点击【Next】。
6.点击【Install】。
7.安装中……
8.点击【Finish】。
第二部分：JetBrains软件通用激活步骤
9.打开安装包解压后的【IntelliJ IDEA2023】文件夹，鼠标右击【Crack】选择【解压到当前文件夹】。
10.双击解压出来的【安装】。
11.点击【确定】。
12.点击【确定】。
13.双击桌面【IntelliJ IDEA 2023.1】图标启动软件。
14.点击【OK】。
15.勾选【I confirm……】，点击【Continue】。
16.点击【Don’t Send】。
17.点击【Enter License】。
18.选择【Activation code】（不要关闭该界面继续后面的步骤）。
19.打开安装包解压后的【IntelliJ IDEA2023】文件夹，将【激活码】拖到软件界面（如下图所示）。
20.点击【Activate】。
21.点击【Continue】（若无法点击“Continue”重复步骤13-20，英文版安装成功，中文版继续后面的步骤）。
第三部分：JetBrains通用软件汉化步骤
22.①点击【Plugins】②输入【Chinese】后在键盘上按【Enter】键③点击“Chinese（simplified）”后的【Install】。
23.下载安装中……
24.点击【Restart IDE】。
25.点击【Restart】。
26.安装成功！（禁止更新，否则软件无法运行）
题外话 初入计算机行业的人或者大学计算机相关专业毕业生，很多因缺少实战经验，就业处处碰壁。下面我们来看两组数据：
2023届全国高校毕业生预计达到1158万人，就业形势严峻；
国家网络安全宣传周公布的数据显示，到2027年我国网络安全人员缺口将达327万。
一方面是每年应届毕业生就业形势严峻，一方面是网络安全人才百万缺口。
6月9日，麦可思研究2023年版就业蓝皮书（包括《2023年中国本科生就业报告》《2023年中国高职生就业报告》）正式发布。
2022届大学毕业生月收入较高的前10个专业
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee1494c9eaefb8d7f0b6f8e2275a5201/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78559c30bcda172ee150c5ff4909aa4a/" rel="bookmark">
			afl覆盖信息的处理（afl-llvm-pass-so.c代码分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插桩统计覆盖率的相关部分主要在afl-llvm-pass-so.c中的bool AFLCoverage::runOnModule(Module &amp;M)部分
插桩率设置 在函数开始会有相关变量的初始化工作，但是主要值得关注的是关于inst_ratio_str的设置。inst_ratio_str表示 AFL 应该插桩的基本块的比例。例如，如果 AFL_INST_RATIO 设置为 10，那么 AFL 大约会选择 10% 的基本块进行插桩。如果 AFL_INST_RATIO 未设置，或者解析失败，或者值超出了允许的范围，就会使用默认值 100，即插桩所有的基本块。
/* Decide instrumentation ratio */ char* inst_ratio_str = getenv("AFL_INST_RATIO"); unsigned int inst_ratio = 100; if (inst_ratio_str) { if (sscanf(inst_ratio_str, "%u", &amp;inst_ratio) != 1 || !inst_ratio || inst_ratio &gt; 100) FATAL("Bad value of AFL_INST_RATIO (must be between 1 and 100)"); } 关键全局变量 之后定义了两个关键的全局变量。
AFLMapPtr是一个指针类型的全局变量，指向 AFL 共享内存区域的开始。这个内存区域存储了 AFL 追踪数据（trace_bits），用于在程序运行时记录哪些路径（或更具体地说，哪些基本块转移）已经被执行过。当 AFL 插桩的代码执行时，它会更新这个内存区域的相应部分。
AFLPrevLoc是一个 32 位整数类型的全局变量，存储了上一个执行的基本块的 ID。注意，这个变量是线程局部的，这意味着每个线程都有自己的一份副本。这样做是为了避免在多线程环境下出现数据竞态。当 AFL 插桩的代码执行时，它会用当前基本块的 ID 更新这个变量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78559c30bcda172ee150c5ff4909aa4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a9d71b9bed6d1a04a737561710985ab/" rel="bookmark">
			llvm-dyn_cast模板函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dyn_cast dyn_cast是LLVM中用于执行安全的向下转型（downcasting）的一个模板函数。在C++中，向下转型是将基类的指针或引用转换为派生类的指针或引用。这种转型在运行时进行，如果转型失败（即，如果基类的对象实际上不是派生类的实例），则dyn_cast会返回nullptr。
在LLVM中，dyn_cast常常被用于处理中间表示（Intermediate Representation，IR）的各种不同类型的指令。例如，现在有一个Instruction类型的指针，但我们想知道这个指令是否是一个特定的派生类，比如CallInst（函数调用指令）或ReturnInst（返回指令）。我们可以使用dyn_cast来尝试将Instruction指针转型为这些更具体的类型。
llvm::Instruction *I = ...; // 某种指令 if (auto *CI = llvm::dyn_cast&lt;llvm::CallInst&gt;(I)) { // 如果I实际上是一个CallInst，那么现在CI指向它 // 我们可以安全地使用CallInst的方法 } else { // 如果I不是一个CallInst，那么CI为nullptr // 在这个分支中，我们知道I不是一个函数调用指令 } 这样，dyn_cast提供了一种在运行时安全地执行向下转型的方式，使得我们可以根据对象的实际类型来执行不同的操作。
dyn_cast&lt;CallInst&gt; auto *c = dyn_cast&lt;CallInst&gt;(&amp;I)这段代码什么意思。
在这段代码中，dyn_cast&lt;CallInst&gt;(&amp;I)是一个动态类型转换操作，它尝试将指针&amp;I从Instruction*类型转换为CallInst*类型。
CallInst是LLVM中的一个类，代表了一个函数调用指令。如果&amp;I实际上是一个CallInst（也就是说，这个指令是一个函数调用），那么dyn_cast将会成功，并返回一个指向这个CallInst的指针。如果&amp;I不是一个CallInst，那么dyn_cast将返回nullptr。
CallInst是这些指令类型中的一种，它代表了一个函数调用指令。当在LLVM IR中看到一个CallInst，这意味着在那个点上，一个函数被调用。
例如我们现在有如下的一个代码：
int add(int a, int b) { return a + b; } int main() { int result = add(3, 4); return 0; } 在LLVM IR中，add(3, 4)这个函数调用会被表示为一个CallInst。这个CallInst会包含调用的函数（在这个例子中是add）以及传递给函数的参数（在这个例子中是3和4）。
这种类型转换在处理LLVM IR时非常常见，因为IR中的指令可以有很多不同的类型（例如函数调用、分支、返回等），并且每种类型的指令都有其特定的方法和属性。通过使用dyn_cast，我们可以安全地将指令转换为其实际类型，并访问这些特定的方法和属性。
class llvm::DbgDeclareInst getVariable()：返回此指令所描述的变量。返回的DIVariable对象包含源代码中变量的信息，如其名称和声明它的行号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a9d71b9bed6d1a04a737561710985ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7104e1bd78128f84b1f58b43b7688ddd/" rel="bookmark">
			深度学习Batch Normalization
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		批标准化（Batch Normalization，简称BN）是一种用于深度神经网络的技术，它的主要目的是解决深度学习模型训练过程中的内部协变量偏移问题。简单来说，当我们在训练深度神经网络时，每一层的输入分布都可能会随着前一层参数的更新而发生变化，这种变化会导致训练过程变得不稳定。BN通过对每一层的输入进行标准化，使其均值为0，方差为1，从而使得网络在每一层都能接收到相对稳定的数据分布。
BatchNorm1d 对2d或3d数据进行批标准化（Batch Normlization）操作:
class torch.nn.BatchNorm1d(num_features, eps=1e-05, momentum=0.1, affine=True): 参数：
1.num_features：特征的维度 ( N , L ) − &gt; L ; ( N , C , L ) − &gt; C (N,L) -&gt; L ;(N,C,L) -&gt; C (N,L)−&gt;L;(N,C,L)−&gt;C
2.eps：在分母上添加一个定值，不能趋近于0
3.momentum：动态均值和动态方差所使用的动量，这里的momentum是对均值和方差进行的滑动平均。即 μ 1 = （ 1 − m o m e n t u m ） ∗ μ l a s t + m o m e n t u m ∗ μ μ_1 = （1 - momentum）* μ_{last} + momentum * μ μ1​=（1−momentum）∗μlast​+momentum∗μ，这里μ1为输出值，μ_last为上一次的计算值，μ为真实计算的值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7104e1bd78128f84b1f58b43b7688ddd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2ba0a03699ffb1b48b21c4ef510780d/" rel="bookmark">
			BGP知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BGP简介
边界网关协议BGP（Border Gateway Protocol）是一种实现自治系统AS（Autonomous System）之间的路由可达，并选择最佳路由的距离矢量路由协议。
MP-BGP是对BGP-4进行了扩展，来达到在不同网络中应用的目的，BGP-4原有的消息机制和路由机制并没有改变。MP-BGP在IPv6单播网络上的应用称为BGP4+，在IPv4组播网络上的应用称为MBGP（Multicast BGP）。
目的：
为方便管理规模不断扩大的网络，网络被分成了不同的自治系统。1982年，外部网关协议EGP（Exterior Gateway Protocol）被用于实现在AS之间动态交换路由信息。但是EGP设计得比较简单，只发布网络可达的路由信息，而不对路由信息进行优选，同时也没有考虑环路避免等问题，很快就无法满足网络管理的要求。
BGP是为取代最初的EGP而设计的另一种外部网关协议。不同于最初的EGP，BGP能够进行路由优选、避免路由环路、更高效率的传递路由和维护大量的路由信息。
虽然BGP用于在AS之间传递路由信息，但并不是所有AS之间传递路由信息都需要运行BGP。比如在数据中心上行的连入Internet的出口上，为了避免Internet海量路由对数据中心内部网络的影响，设备采用静态路由代替BGP与外部网络通信。
BGP的优点：
BGP从多方面保证了网络的安全性、灵活性、稳定性、可靠性和高效性。
BGP采用认证和GTSM的方式，保证了网络的安全性。
BGP提供了丰富的路由策略，能够灵活的进行路由选路，并且能指导邻居按策略发布路由。
BGP提供了路由聚合和路由衰减功能由于防止路由震荡，有效提高了网络的稳定性。
BGP使用TCP作为其传输层协议（目的端口号179），并支持与BGP与BFD联动、BGP Tracking和BGP GR和NSR，提高了网络的可靠性。
在邻居数目多、路由量大且大部分邻居具有相同出口的策略的场景下，BGP使用按组打包技术极大的提高了BGP打包发包性能。
BGP原理描述
BGP基本概念：
自治系统ASAutonomous System：
AS是指在一个实体管辖下的拥有相同选路策略的IP网络。BGP网络中的每个AS都被分配一个唯一的AS号，用于区分不同的AS。AS号分为2字节AS号和4字节AS号，其中2字节AS号的范围为1至65535，4字节AS号的范围为1至4294967295。支持4字节AS号的设备能够与支持2字节AS号的设备兼容。
BGP分类：
BGP按照运行方式分为EBGP（External/Exterior BGP）和IBGP（Internal/Interior BGP）。
EBGP：运行于不同AS之间的BGP称为EBGP。为了防止AS间产生环路，当BGP设备接收EBGP对等体发送的路由时，会将带有本地AS号的路由丢弃。
IBGP：运行于同一AS内部的BGP称为IBGP。为了防止AS内产生环路，BGP设备不将从IBGP对等体学到的路由通告给其他IBGP对等体，并与所有IBGP对等体建立全连接。为了解决IBGP对等体的连接数量太多的问题，BGP设计了路由反射器和BGP联盟。
BGP报文交互中的角色：
BGP报文交互中分为Speaker和Peer两种角色。
Speaker：发送BGP报文的设备称为BGP发言者（Speaker），它接收或产生新的报文信息，并发布（Advertise）给其它BGP Speaker。
Peer：相互交换报文的Speaker之间互称对等体（Peer）。若干相关的对等体可以构成对等体组（Peer Group）。
BGP的路由器号（Router ID）：
BGP的Router ID是一个用于标识BGP设备的32位值，通常是IPv4地址的形式，在BGP会话建立时发送的Open报文中携带。对等体之间建立BGP会话时，每个BGP设备都必须有唯一的Router ID，否则对等体之间不能建立BGP连接。
BGP的Router ID在BGP网络中必须是唯一的，可以采用手工配置，也可以让设备自动选取。缺省情况下，BGP选择设备上的Loopback接口的IPv4地址作为BGP的Router ID。如果设备上没有配置Loopback接口，系统会选择接口中最大的IPv4地址作为BGP的Router ID。一旦选出Router ID，除非发生接口地址删除等事件，否则即使配置了更大的地址，也保持原来的Router ID。
BGP工作原理：
BGP对等体的建立、更新和删除等交互过程主要有5种报文、6种状态机和5个原则。
BGP的报文：
BGP对等体间通过以下5种报文进行交互，其中Keepalive报文为周期性发送，其余报文为触发式发送：
Open报文：用于建立BGP对等体连接。
Update报文：用于在对等体之间交换路由信息。
Notification报文：用于中断BGP连接。
Keepalive报文：用于保持BGP连接。
Route-refresh报文：用于在改变路由策略后请求对等体重新发送路由信息。只有支持路由刷新（Route-refresh）能力的BGP设备会发送和响应此报文。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e27a04b4e28b10f0d78508a8f69569a8/" rel="bookmark">
			eNSP：mplsvpn综合实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;Huawei&gt;sys
[Huawei]sys r1
[r1]int lo0
[r1-LoopBack0]ip add 192.168.1.1 24
[r1-LoopBack0]int g 0/0/0
[r1-GigabitEthernet0/0/0]ip add 192.168.2.1 30
[r1]ip route-static 192.168.3.0 30 192.168.2.2
[r1]ip route-static 192.168.4.0 24 192.168.2.2
[Huawei]sys r2
[r2-GigabitEthernet0/0/1]int g 0/0/0
[r2-GigabitEthernet0/0/0]ip add 23.1.1.1 30
[r2-GigabitEthernet0/0/1]int lo0 [r2-LoopBack0]ip add 2.2.2.2 24
[r2]ospf 1 rout 2.2.2.2
[r2-ospf-1]ar 0
[r2-ospf-1-area-0.0.0.0]net 2.2.2.2 0.0.0.0 [r2-ospf-1-area-0.0.0.0]network 23.1.1.1 0.0.0.0
[r2]mpls lsr-id 2.2.2.2
[r2]mpls
[r2-mpls]mpls ldp
[r2-mpls-ldp]q
[r2]int g 0/0/0
[r2-GigabitEthernet0/0/0]mpls
[r2-GigabitEthernet0/0/0]mpls ldp [r2]ip vpn-instance B1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e27a04b4e28b10f0d78508a8f69569a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c585d9918848795ad7a8d5e02d9baec6/" rel="bookmark">
			深度学习中，什么是batch-size？如何设置？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是batch-size? batch-size 是深度学习模型在训练过程中一次性输入给模型的样本数量。它在训练过程中具有重要的意义，影响着训练速度、内存使用以及模型的稳定性等方面。
以下是 batch-size 大小的一些影响和意义：
训练速度：较大的 batch-size 通常可以加快训练速度，因为在每次迭代中处理更多的样本。这可以充分利用高性能计算资源（如GPU）的并行计算能力。然而，过大的 batch-size 可能会导致内存不足而无法训练。
内存使用：较大的 batch-size 需要更多的内存来存储模型参数、梯度和中间计算结果。如果内存不足，训练可能会失败。因此，选择适当的 batch-size 是很重要的。
梯度估计：模型的参数更新是基于对一批样本计算的梯度。较大的 batch-size 可能导致梯度的估计更稳定，但也可能陷入局部最优。
泛化性能：较小的 batch-size 可能有助于模型更好地泛化到新数据，因为它在每次迭代中只考虑了一小部分样本。
优化稳定性：一些优化算法在较大的 batch-size 下可能更稳定，而在较小的 batch-size 下可能更易受到噪声影响。
选择适当的 batch-size 需要在计算资源、模型复杂度、数据分布和训练目标之间进行权衡。通常，可以通过尝试不同的 batch-size 大小并观察训练的收敛性和效果来确定最佳值。
如何设置batch-size? 确定适当的 batch-size 大小没有固定的标准答案，它会根据数据集、模型架构、硬件资源和训练目标等因素而变化。以下是一些常见的 batch-size 设置原则：
小数据集：如果你的数据集很小，通常可以尝试较大的 batch-size，以充分利用计算资源并提高训练速度。但要注意不要让 batch-size 太大，超出了内存限制。
大数据集：对于大型数据集，batch-size 可以相对较大，但同样需要注意内存使用。
探索性设置：在开始训练时，建议使用较小的 batch-size 进行探索性训练，以确保模型能够正常运行，并初步了解训练的效果。
实验性尝试：在探索性训练后，逐步增加 batch-size 来观察训练的收敛性和效果。然后，可以找到一个合适的 batch-size，使得训练速度和内存使用都能够被充分利用。
硬件限制：计算资源是一个重要的考虑因素。如果你的硬件资源有限，可能需要适当降低 batch-size，以确保内存不会耗尽。
模型稳定性：有些模型对于较小的 batch-size 更加稳定，因为它可以减少训练过程中的噪声影响。
最终，选择合适的 batch-size 需要结合实际情况进行实验和测试。建议尝试不同的 batch-size，并观察训练过程中的训练速度、收敛性以及模型的效果，从而找到适合你的任务的最佳设置。
实际应用： 例子：用YOLOv7模型，训练4500张图片，对于batch-size的设置 首先，建议使用8的倍数作为batch-size，因为这样可以提高训练效率。作者还提到，batch-size应该尽量跑满显存，以获得更好的效果。因此，您可以根据您的显卡性能和显存大小来选择16或8作为batch-size。
其次，YOLOv7是一种目标检测模型，通常在训练时需要考虑多个因素，包括数据集大小、模型架构、硬件资源等。选择适当的 batch-size 取决于这些因素的综合考虑。
数据集大小：4500张图片并不是一个很大的数据集，但也不算小。对于中等大小的数据集，batch-size 在 8 到 16 之间是一个常见的范围。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c585d9918848795ad7a8d5e02d9baec6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a10de7b92cfdc065665fa5c8eeec768/" rel="bookmark">
			异常处理的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、异常处理方式1 —— throws · throws：用在方法上，可以将方法内部出现的异常抛出去给本方法的调用者处理。
· 这种方式并不好，发生异常的方法自己不处理异常，如果异常最终抛出去给虚拟机将引起程序死亡。
抛出异常格式：
方法 throws 异常1 ，异常2 ，异常3 ..{
}
或
方法 throws Exception{
}
代表可以抛出一切异常
二、异常处理方式2 —— try…catch · 监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理。
· 这种方式还可以，发生异常的方法自己独立完成异常的处理，程序可以继续往下执行。
格式：
try{ // 监视可能出现异常的代码！
}catch(异常类型1 变量){
// 处理异常
} 建议格式：
try{ // 可能出现异常的代码！
}catch (Exception e){
e.printStackTrace(); // 直接打印异常栈信息
}finally{
//代码异常也要执行的代码
}
Exception可以捕获处理一切异常类型！
三、异常处理方式3 —— 自定义异常 throw new 自定义异常 throw new 异常类名称(构造函数参数);
异常类名称就是已定义的异常类，构造函数参数是为异常类的构造函数提供的参数。它可以为代码中的某个条件设置一个异常，并在需要的位置进行捕获和处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/774b03117b35549788580235e392c41c/" rel="bookmark">
			less和scss的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LESS 和 SASS 的区别 相同点不同点 相同点 1.less和scss都是预处理器，可以拥有变量，运算，继承，嵌套的功能
2.都可以通过自带的插件，转换成相应的css文件
3.都可以参数混入，可以传递参数，就像函数一样
4.嵌套的规则相同，都是class嵌套class
不同点 1.less用@声明变量，scss用$来声明变量
2.less采用@{}的形式变量插值，SCSS采用${}的形式变量插值
3.SCSS支持条件语句，LESS不支持
4.SCSS应用的css文件名必须以‘_’开头（下划线），文件名如果以下划线开头的话，sass会认为改文件是一个应用文件，不会将它转成css文件
5.LESS和SCSS都可以使用&amp;符号表示父选择器，但是SCSS的&amp;符号只能出现在一个组合选择器的开始位置，LESS则没有这个限制
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/102/">«</a>
	<span class="pagination__item pagination__item--current">103/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/104/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>