<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b2abe23b054a3d6f50c35eedab5ceb0/" rel="bookmark">
			Python matplotlib绘图保存图片空白问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在写python用matplotlib绘制折线图的时候遇到了一个问题：
用plt.savefig(’./tmp/first.jpg’)保存图片后打开发现是空白的一张图片：
但是jupyter notebook里面运行显示是正常的
原因：
先写了 plt.show()再写plt.savefig()
在使用plt.show()的时候会生成一张新的空白的画布。这时候再使用plt.savefig(）就会导致保存下来的图片是刚才plt.show()生成的新的画布，所以是空白的。
解决方法：只需要先写plt.savefig(）再写plt.show()就可以了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4334e927a3a5dbdc11eb5e274a8585e/" rel="bookmark">
			设计模式之里氏替换原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		里氏替换原则（Liskov Substitution Principle,简称LSP）: 子类可以替换父类 承有一些优点：
1. 提高代码的重用性，子类拥有父类的方法和属性； 2. 提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性； 缺点：侵入性、不够灵活、高耦合 1. 继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性； 2. 增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成 非常糟糕的结果，要重构大量的代码。 任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，即基类随便怎么改动子类都不受此影响，那么基类才能真正被复用
因为继承带来的侵入性，增加了耦合性，也降低了代码灵活性，父类修改代码，子类也会受到影响，此时就需要里氏替换原则。
子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。子类中可以增加自己特有的方法。当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 a.子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/015a529b0daac14be5ca6682daeee700/" rel="bookmark">
			codefroces中的病毒，这题有很深的trick，你能解开吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，欢迎阅读周末codeforces专题。
我们今天选择的问题是contest 1419的C题，目前有接近8000的人通过了本题。今天这题的难度不大，但是真的很考验思维，一不小心就会踩中陷阱，我个人觉得非常有意思，适合周末动动脑。
题目链接：https://codeforces.com/contest/1419/problem/C
题意 有一个叫做Killjoy的特工发明了一种新型的冠状病毒叫做Convid-2069，专门在codeforces平台上传播。这种病毒通过rating传播，只要两个人的rating一样并且其中一个感染了病毒，那么另外一个也会被感染。
这个病毒一开始的时候只有Killjoy自己感染了，他一共和n个人有联系。由于codeforces会定期举办比赛，参加比赛会改变一个人的rating，由于codeforces的规则，导致所有参赛的人的rating变动的总量为0，也就是说有人升了一定会有人降，大家的总和保持不变。已知Killjoy自己不会参赛，请问最少需要多少次比赛可以将所有人都感染。
对于每一次比赛，可以不必所有人都参与，传染的发生不需要时间，瞬间就可以传染。很容易证明，我们一定可以在有限次比赛当中将所有人都感染。
样例 首先输入一个t表示测试数据的组数( 1 ≤ t ≤ 100 1 \le t \le 100 1≤t≤100)，对于每一组数据第一行输入两个数，分别是n和x。n表示和Killjoy有接触的人的数量，x表示Killjoy自己的rating，( 2 ≤ n ≤ 1 0 3 , − 4000 ≤ x ≤ 4000 2 \le n \le 10^3, -4000 \le x \le 4000 2≤n≤103,−4000≤x≤4000)。
第二行输入n个整数，表示这n个人的rating。要求输出一个整数，表示最少需要的比赛数量( − 4000 ≤ a i ≤ 4000 -4000 \le a_i \le 4000 −4000≤ai​≤4000)。
题解 这道题的思路非常直接，没什么弯弯绕，我们只需要观察一下样例就可以了。样例当中有三组数据刚好对应了三种情况。
我们先来看第一种情况：这n个人的rating都和x相等，那么意味着我们不需要比赛，就可以把所有人都感染了。结果当然是0，这一种非常简单，大家应该都可以想明白。
第二种情况也不难，第二种情况就是虽然大家的rating不全等于x，但是大家的总和等于x * n。也就是说rating大于x的减小到x，小于x的增加到x，刚好可以通过一次比赛让大家全部被感染，那么最终的答案就是1。这对应样例当中的68， 70的情况，x=69，很明显68的增加1，70的减去1，就可以都变成69。
前面两种理清楚了，再来看第三种情况，第三种情况也就是前面两种都不符合的情况。也就是我们通过一次比赛没办法让大家都等于x，不过这并没有什么关系，因为题目当中并没有限制rating的范围。我们完全可以让其中n-1个人全部变成x，由于要保证大家的rating变动之和等于0，所以让最后一个人来完成平衡的角色。
也就是说通过一次比赛，我们可以让n-1个人全部被感染，最后留下一个人。那么不难想出，我们只需要再多用一个回合就可以了。再多一个回合，我们可以让第n个人变成x，让一个已经感染的人来完成平衡。那么，我们用了两个回合就完成了所有人的感染。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/015a529b0daac14be5ca6682daeee700/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f4b5ba7ffd7cc765556aab3dd42cd85/" rel="bookmark">
			搜狗输入法电脑版_今日软件 | 百度网盘联运版、动画壁纸、Bmap、耳萌、小熊录屏、云上阅读、搜狗输入法、IObit Uninstaller...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日软件更新
安卓APP
「百度网盘联运版」10.0.138
# 小米定制版，无广告
▾下载：https://www.lanzoux.com/id0q5kj
「Via」4.0.1 谷歌版
# 简洁轻快手机浏览器
▾下载：https://www.lanzoux.com/id0kwte
「阅读」3.20.00524
# 免费开源文学阅读器
▾下载：https://www.lanzoux.com/id0pqdc
「Bmap」7.3.81
# 纯粹地图应用
▾下载：https://www.lanzoux.com/id0q6lg
「WPS Office」12.5
# 金山出品Office
▾下载：https://www.lanzoux.com/id0q7ja
「口袋扫描仪」2.1.1
# 文档扫描、识别
▾下载：https://www.lanzoux.com/id0ppyh
「搜狗输入法」10.10
# 搜狗词库还是要强大些
▾下载：https://www.lanzoux.com/id0q89g
「多开分身」3.1.5
# APP多开工具
▾下载：https://www.lanzoux.com/id0kxab
「VivaCut」1.4.5
# 视频编辑神器
▾下载：https://www.lanzoux.com/id0q97a
「云上阅读」2.0
# 说漫画搜索软件
▾下载：https://www.lanzoux.com/id0pqnc
「书迷」1.04.05
# 自带书源看小说
▾下载：https://www.lanzoux.com/id0pq3c
「FA重制版」1.5.1
# 把网页生成客户端
▾下载：https://www.lanzoux.com/id0kw3i
「星极多开」3.1.5
# APP多开工具
▾下载：https://www.lanzoux.com/id0kxsj
「火星直播」1.5.39 盒子版
# 比较稳定的电视直播
▾下载：https://www.lanzoux.com/id0kxne
「小熊录屏」2.3.2.1
# 手机屏幕录制工具
▾下载：https://www.lanzoux.com/id0q9zi
「耳萌」2.2.7
# 舒缓压力，助睡眠
▾下载：https://www.lanzoux.com/id0ppha
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f4b5ba7ffd7cc765556aab3dd42cd85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82a32fb86c851960264cbe198cb72c5d/" rel="bookmark">
			java中==和equals的区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在java语言中，equals用来比较两个对象的值是否相等，==用来比较两个对象在内存中地址是否相等。由于equals是object类拥有的方法，所有java中所有类有具有该方法，可自行重写。
String s1 = "string"; String s2 = "string"; String s3 = new String("string"); String s4 = new String("string"); System.out.println(s1==s2);//true System.out.println(s3==s4);//false System.out.println(s1==s3);//false System.out.println(s1==s4);//false System.out.println(s1.equals(s4));//true System.out.println(s3.equals(s4));//true System.out.println(s1.equals(s3));//true java中的String类的equals重写之后如下：
public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82a32fb86c851960264cbe198cb72c5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/045d3b43d5e638fb0a2cd5ee6ca97a82/" rel="bookmark">
			mysql去重复关键字distinct的用法和distinct去重复失效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql去重复关键字distinct的用法和distinct去重复失效问题 一、distinct是什么？ distinct是mysql去重复关键字。 二、使用规则 1.distinct关键字必须在select后面第一位 表里所有数据的去重复 select distinct comptemplate.* from comptemplate 表里所有某个字段的数据去重复 select distinct comptemplate.comptemplate_name from comptemplate 2.distinct去重复的依据 distinct去重复的依据是从select到from里的所有字段, 也就是每一行的数据和所有的数据做对比，如果重复则去除掉。 三.去重复失效 1.distinct关键字错误理解的sql使用 多表关联的错误理解使用，想对comptemplate表的所有重复数据 去重，查出来的数据如下。 select distinct comptemplate.*,tubetemplate.* from comptemplate left join extemplate_tube_relation on extemplate_tube_relation.comptemplate_id = comptemplate.comptemplate_id left join tubetemplate on extemplate_tube_relation.tubetemplate_id = tubetemplate.tubetemplate_id 2.distinct关键字正确理解的sql使用 多表关联的正确理解使用，想对comptemplate表的所有重复数据 去重，查出来的数据如下。 select distinct comptemplate.* from comptemplate left join extemplate_tube_relation on extemplate_tube_relation.comptemplate_id = comptemplate.comptemplate_id left join tubetemplate on extemplate_tube_relation.tubetemplate_id = tubetemplate.tubetemplate_id 3.对比两个使用sql 在select中多了tubetemplate.*，导致无法去重复comptemplate.*。 原因是因为distinct是对一行去重复，也就是select到from里的所有字段, 每一行的数据和所有的数据做对比，如果重复则去除掉。 四.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/045d3b43d5e638fb0a2cd5ee6ca97a82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce6df5d999c3404c0a51535bf0493be7/" rel="bookmark">
			oracle账号共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位小伙伴，在oracle官网下载JDK需要oracle账号，本人提供账号共享，方便大家下载，希望大家不要改密码，方便更多的人。
账号：908344069@qq.com
密码：Java2019
jdk-8u271-linux-x64.tar.gz版本
https://download.oracle.com/otn/java/jdk/8u271-b09/61ae65e088624f5aaa0b1d2d801acb16/jdk-8u271-linux-x64.tar.gz
jdk-8u271-windows-i586.exe版本
https://download.oracle.com/otn/java/jdk/8u271-b09/61ae65e088624f5aaa0b1d2d801acb16/jdk-8u271-windows-i586.exe
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/475bb139c2524b8eefd8ec626b30f82a/" rel="bookmark">
			centos7无法启动firefox解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在centos7上搭建lamp环境中，发现firefox怎么都打不开，可以ping通，但是浏览器怎么都打不开，最后解决了，命令行输入sudo -i firefox，如下图所示:
点击这个
发现并没有什么反应一直转圈
然后我们命令行输入sudo -i firefox
发现可以打开了
在浏览器运行过程中不要关闭命令行，不然会关闭浏览器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/269d83b8cf84d37eb47f21c18a5566cc/" rel="bookmark">
			虚拟化运维如何做到快速故障定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着数据中心的规模越来越大，网络环境也变得更加复杂。在日常运维中，运维部门最为头疼的可能要属故障定位了，由于虚拟化环境的不可见性，导致对虚拟化运维的故障定位更加困难。如何在极短的时间内做好故障定位，并找出故障原因，成为考核运维团队工作效率的一个重要指标。而明辰智航云安的“秒级”故障定位功能一经推出，就成为了运维团队的福音。让我们看看明辰智航云安是如何做到“秒级”故障定位的。
使用根因分析进行高速故障排查
明辰智航云安可对故障进行快速的根本原因分析，将故障排查时间从几天降到1分钟之内，秒级的故障定位，大大减少了故障排查时间，使运维团队可以用更多时间去解决问题。
明辰智航云安利用人工智能学习和行为学习算法从性能基准中识别异常性能指标，不再依靠人力去猜测，为运维团队提供准确的运维数据参考。
通过设置，可以仅在重点关注的问题上获得警报，防止过多警报干扰和误报。
通过明辰智航云安的时间回溯功能，可以轻松检测和解决间歇性发生的故障。
呈现整个数据中心的直观性能视图，避免IT团队之间的相互指责
明辰智航云安可以消除团队之间的指责，并鼓励IT团队之间进行协作以对故障问题进行分类。
明辰智航云安直观的性能视图使IT团队可以一键式访问业务服务中断或性能下降的根本原因。
在影响用户使用体验之前，就可以全面了解应用可能出现的性能问题。
应用与基础架构之间的关联，使得运维团队可以轻松查看影响应用性能的原因，故障排除不再成难题。
智能化的故障发现功能：不再需要盯着电脑来发现问题
明辰智航云安快速发现问题并发出警报，因此您可以以闪电般的速度解决和恢复服务。
即时收到影响到您的业务交易的应用，基础结构和网络问题的警报。
使用明辰智航云安的动态性能基准自动识别异常更改。
可以自动获取电子邮件，系统日志，SNMP警报。
在明辰智航云安强大的秒级故障定位面前，虚拟化运维中棘手的故障定位再也不是什么难题，为运维团队节省了大量的排查故障的时间。明辰智航云安，让虚拟化运维变得简单！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c2fd61c264289ba140b496ec25d3f94/" rel="bookmark">
			简单登录&#43;注册&#43;验证码页面 前后端交互（前端加后端 AJAX局部判断 DRuid连接池 MySQL DBUtils）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单登录+注册+验证码页面 前后端交互（前端加后端 AJAX局部判断 DRuid连接池 MySQL DBUtils） 文章目录 简单登录+注册+验证码页面 前后端交互（前端加后端 AJAX局部判断 DRuid连接池 MySQL DBUtils）问题结构效果图数据库注册页面登录页面登录后页面 代码后端登陆后端注册后端验证码后端跳转页面 前端注册页面登录页面跳转页面与登录后页面 问题 使用axios post 提交数据，后台获取不到 解决 【用 URLSearchParams 传递参数】 let param = new URLSearchParams() param.append('username', 'admin') param.append('pwd', 'admin') axios({ method: 'post', url: '/api/lockServer/search', data: param }) 需要注意的是： `URLSearchParams` 不支持所有的浏览器，但是总体的支持情况还是 OK 的，所以优先推荐这种简单直接的解决方案 结构 效果图 数据库 注册页面 登录页面 登录后页面 代码 后端登陆 工具类mysql package Login; import com.alibaba.druid.pool.DruidDataSourceFactory; import org.apache.commons.dbutils.QueryRunner; import javax.sql.DataSource; import java.io.InputStream; import java.util.Properties; public class DBCon { public QueryRunner con() { InputStream resourceAsStream = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c2fd61c264289ba140b496ec25d3f94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46a54216ee121ce79ae88d6b40e73f3b/" rel="bookmark">
			[Graph Embedding] DeepWalk 论文笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 [Graph Embedding] DeepWalkIntroductionRandom WalksGraph Embedding 与 NLPDeepWalk 算法原理总结 [Graph Embedding] DeepWalk Introduction 图表示学习是将图(Graph/Network)中节点在一个低维的连续的向量空间中表示出来，这种表示能够保留节点与邻居的相似性、节点的社区成员属性等。得到节点的向量表示就可以喂给下游的学习模型进行节点分类，边预测等任务。
DeepWalk作为图表示学习的经典方法之一，核心方法就是通过对一定数量的节点做RandomWalk（随机游走），然后将得到的节点序列作为顶点的向量输入表示，通过使用skip-gram model 进行学习，得到最终的表示。下图为对一个空手道俱乐部成员的social relationship Graph表示到一个二维空间。
Random Walks 所谓随机游走（random walk）就是从一个节点开始随机的选择下一个与当前的节点相邻的节点（提前设定随机游走结束的条件），最终形成一条节点序列。截断随机游走（truncated random walks）就是指长度固定的随机游走。使用随机游走的好处有：
并发性。随机游走可以同时在图上的多个节点上同时进行。适应性。由于图的结构是随时间动态变化的，所以当图变化的时候，不需要对所有节点重新进行随机游走，只需要对与图中变化了的子图有关的节点重新进行随机游走得到新的向量表示就可以。
Graph Embedding 与 NLP 作者发现了对graph上的节点进行随机游走的节点频率与NLP（自然语言处理）中word在文章中的出现频率都满足一样的power-law（幂律分布）。如下图所示：
既然网络（Graph/Network）的特征特性与自然语言处理那么相近，那么我们是否可以将NLP中的词向量的模型用在Graph Embedding中，这就是本文的核心观念。
要想了解DeepWalk的算法原理，需要提前了解NLP中Word Embedding 和 Word2Vec的基本内容，并且要理解其中的一种算法——SkipGram。
DeepWalk 算法原理 DeepWalk算法主要由2部分组成，第一部分是产生节点的随机游走序列，第二部分是参数的更新。算法的流程图如下图所示。
第2步是在构造Hierarchical Softmax（层次Softmax）所需的二叉树，算法中使用到Hierarchical Softmax加速算法的学习，这里不多加阐述。第3步是总的迭代次数，共γ次。每一次迭代（第4步到8步）中，对Graph中的每一个节点进行一次random walk，然后将生成的节点序列作为输入向量，输入SkipGram算法中进行参数的学习。
参数更新如下图所示：
第3步是需要优化的函数，即使得当顶点为 v j v_j vj​时，它所在的random walk序列中的 [ j − w : j + w ] [j - w : j + w] [j−w:j+w]中除了 v j v_j vj​的顶点出现的条件概率最大化（这里使用到的是NLP中的SkipGram算法）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46a54216ee121ce79ae88d6b40e73f3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e48784f7caa5af0c91f2aaaf2a3deff3/" rel="bookmark">
			五、Python复习教程（重点）-爬虫框架实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录导航： 文章目录 目录导航：九、Python网络爬虫进阶实战(上)1. Scrapy框架介绍与安装1.1.认识Scrapy框架Scrapy框架介绍：Scrapy框架的运行原理：Scrapy主要包括了以下组件：Scrapy运行流程大概如下： 1.2 Scrapy的安装：1.3 Scrapy爬虫框架的具体使用步骤如下： 2. Scrapy框架的使用2.1 Scrapy框架的命令介绍Scrapy 命令 分为两种：`全局命令` 和 `项目命令`。全局命令项目命令： Scrapy框架的命令使用：shell命令, 进入scrpay交互环境 2.2 Scrapy框架的使用：① 创建项目② 进入demo项目目录，创建爬虫spider类文件③ 创建Item④ 解析Response⑤ 使用Item Pipeline⑥ 运行： 2.3 Scrapy框架中的POST提交： 3. Selector选择器3.1 直接使用：3.2 Scrapy shell3.3 Xpath选择器：3.4 CSS选择器：3.5 正则匹配： 4. Spider的使用4.1 Spider运行流程：4.2 Spider类分析：4.3 实战案例： 5. Downloader Middleware的使用5.1 使用说明：5.2 自定义Downloader Middleware中间件① process_request(request,spider)② process_response(request, response, spider)③ process_exception(request, exception, spider) 5.3 实战案例： 6. Spider Middleware的使用6.1 激活spider中间件6.2 编写您自己的spider中间件process_spider_input(response, spider)process_spider_output(response, result, spider)process_spider_exception(response, exception, spider)process_start_requests(start_requests, spider) Scrapy框架的配置Settings内置设置参考手册 7. ItemPipeline的使用7.1 如何编写你自己的item pipeline① `process_item(item, spider)`② `open_spider(spider)`③ `close_spider(spider)` 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e48784f7caa5af0c91f2aaaf2a3deff3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fd12dd5175ec7afcc96a90942b2ea2f/" rel="bookmark">
			一、Python复习教程（重点）- 基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录导航： 文章目录 目录导航：一、Python基础1.1 Python安装和使用1.1.1 Python环境搭建1.1.2 运行Python(1) 交互式解释器(2) 命令行脚本(3) 集成开发环境（IDE：Integrated Development Environment）: PyCharm 1.2 Python基础语法1.2.1 输入和输出1.2.2 注释1.2.3 标识符1.2.4 变量1.2.5 行与缩进 1.3 Python运算符(1) Python算术运算符(2) Python比较运算符(3) Python赋值运算符(4) Python位运算符(5) Python逻辑运算符(6) Python成员运算符(7) Python身份运算符(8) Python运算符优先级 1.4 Python数据类型1.4.1 标准数据类型(1) Number（数字）(2) String（字符串）(3) List（列表）(4) Tuple（元组）(5) Set（集合）(6) Dictionary（字典） 1.4.2 Python数据类型转换 1.5 Python分支结构1.5.1 流程控制1.5.2 分支/选择结构(1) 单项分支(2) 双项分支(2) 多项分支(4) 巢状分支 1.6 Python循环结构1.6.1 while型循环1.6.2 for ... in 循环1.6.3 range()函数1.3.7 练习：逆向输出乘法口诀1.6.4 break和continue语句及循环中的else子句 1.7 Python函数1.7.1 认识Python函数1.7.2 函数的定义格式(1) 基本函数格式(2) 带有参数的函数格式(3) 带有默认值的参数(4) 关键字参数(5). 收集参数(6) 多种参数混合**关于返回值的问题 1.7.3 函数文档1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fd12dd5175ec7afcc96a90942b2ea2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88cb4ec9ef4b402c3770cc86abab21db/" rel="bookmark">
			2020-10-26：自定义3个注解解决项目的3个Swagger难题（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://cloud.tencent.com/developer/article/1700641 14天自定义3个注解扩展Swagger的3个功能的经历 14天自定义3个注解扩展Swagger的3个功能的经历.png
前言 （一）本文针对的小伙伴 点开此文章的小伙伴们请注意了，本片文章针对的是对Swagger有一定基础的小伙伴；
你应该具备或者已经具备的：
1、有过Swagger的使用经历；2、了解过Swagger，动手去集成过SpringBoot；3、对自定义注解解决业务需求有想迫切了解的兴趣。4、......。 （二）通过本文能了解或者学到什么 本篇文章是我通过大量的实践，摸索、查资料、Debug源代码一步一步的摸索出来的，整理一份比较详细的资料，以便也有利于他人，少走弯路。
通过本文你将会：
1、了解到SpringBoot项目中如何自定义注解并且使用；2、掌握如何扩展Swagger的功能，并成功的用在项目上；3、了解到自定义注解的流程，以及如果应用的过程；4、少走一些坑。 14天自定义3个注解扩展Swagger的3个功能的经历.png
一、第一部分：基础(可跳过) （一）swagger简介 swagger确实是个好东西。
为什么是个好东西呢？
因为：
1、可以跟据业务代码自动生成相关的api接口文档，尤其用于restful风格中的项目；2、开发人员几乎可以不用专门去维护rest api，这个框架可以自动为你的业务代码生成restfut风格的api；3、而且还提供相应的测试界面，自动显示json格式的响应。4、大大方便了后台开发人员与前端的沟通与联调成本。 因为：
1、可以跟据业务代码自动生成相关的api接口文档，尤其用于restful风格中的项目；2、开发人员几乎可以不用专门去维护rest api，这个框架可以自动为你的业务代码生成restfut风格的api；3、而且还提供相应的测试界面，自动显示json格式的响应。4、大大方便了后台开发人员与前端的沟通与联调成本。 1、springfox-swagger简介 签于swagger的强大功能，java开源界大牛spring框架迅速跟上，它充分利用自已的优势，把swagger集成到自己的项目里，整了一个spring-swagger，后来便演变成springfox。springfox本身只是利用自身的aop的特点，通过plug的方式把swagger集成了进来，它本身对业务api的生成，还是依靠swagger来实现。 关于这个框架的文档，网上的资料比较少，大部分是入门级的简单使用。本人在集成这个框架到自己项目的过程中，遇到了不少坑，为了解决这些坑，我不得不扒开它的源码来看个究竟。此文，就是记述本人在使用springfox过程中对springfox的一些理解以及需要注意的地方。 2、springfox大致原理 springfox的大致原理就是，在项目启动的过程中，spring上下文在初始化的过程，框架自动跟据配置加载一些swagger相关的bean到当前的上下文中，并自动扫描系统中可能需要生成api文档那些类，并生成相应的信息缓存起来。如果项目MVC控制层用的是springMvc那么会自动扫描所有Controller类，跟据这些Controller类中的方法生成相应的api文档。 （二）SpringBoot集成Swagger springfox-swagger-ui依赖并不是必须的，可以使用第三方的UI，也可以自己写一套前端的UI集成进来。 我们就可以使用一个基于bootstrap写的UI。
1、引入相关依赖 &lt;!-- 引入swgger相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springfox的UI。此依赖不是必须的 --&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; --&gt; 截至到目前2020.9.9日springfox-swagger2:2.9.2的版本主要引入了下面这些依赖：
io.swagger:swagger-annotations:1.5.20io.swagger:swagger-models:1.5.20io.springfox:springfox-spi:2.9.2io.springfox:springfox-schema:2.9.2io.springfox:springfox-swagger-common:2.9.2io.springfox:springfox-spring-web:2.9.2com.google.guava:guava:20.0com.fasterxml:classmate:1.3.3org.slf4j:slf4j-api:1.7.24org.springframework.plugin:spring-plugin-core:1.2.0.RELEASEorg.springframework.plugin:spring-plugin-metadata:1.2.0.RELEASEorg.mapstruct:mapstruct:1.2.0.Finalio.springfox:springfox-core:2.9.2net.bytebuddy:byte-buddy:1.8.12 为了页面好看，我们也可以引入这个基于Bootstrap的前端UI：
&lt;!--基于BootStrap的UI框架--&gt; &lt;!--2.x.x版本的swagger-bootstrap-ui引用包方式如下 1.9.x和2.x.x选择一个包引用就行--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;!--在引用时请在maven中央仓库搜索最新版本号--&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; 默认的swagger界面：
引入第三方Bootstrap编写的UI：
2.配置相关配置文件
/** * SwaggerConfig file * zhenghui */ @Configuration @EnableSwagger2 @EnableKnife4j //UI public class Swagger2Config { @Bean public Docket appApi() { return new Docket(DocumentationType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88cb4ec9ef4b402c3770cc86abab21db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35eac2bff82510b26c4251f70cb31293/" rel="bookmark">
			vue遍历map对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构如下图：
遍历方法：两次v-for
&lt;view v-for="(item,key) in rechargeTicketRule" :key="key" class="uni-dialog-content clearfix"&gt; &lt;view class="box" v-for="data in item"&gt; &lt;/view&gt; &lt;/view&gt; 页面展示效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99a272194eb867ea363eec81b5e38d12/" rel="bookmark">
			软件测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件测试分类
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69d2aa0e2a0fa6dcfbca2169a7c1ba1b/" rel="bookmark">
			正则表达式及与字符串相关的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正则表达式 用于定义一些字符串的规则计算机可以根据正则表达式来检查一个字符串是否符合规则，获取将字符串中符合规则的内容提取出来 正则的使用场景 一般情况下，正则额都可以对需要某些规则下的字符进行匹配，从而得到用户输入的字符串是否为系统需要的格式
创建正则表达式的对象（直面量） 语法：
let 变量=new RegExp（“正则表达式”，“匹配模式”）； 例：let reg=new RegExp(“W3School”,“g”);
使用typeof检查正则对象，会返回objectlet result=new RegExp(“a”);//检查 一个字符串是否含有“a”在构造函数中可以传递一个匹配模式作为第二个参数，如果符合则返回true，否则返回false 正则表达式的方法 test（） 使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，如果符合则返回true，否则返回false 使用字面量来创建正则表达式 语法：let 变量=/正则表达式/匹配模式
使用字面量创建更加简单，使用构造函数创建更加灵活
reg=/a|b/; 使用“|”表示或者的意思，检查含a或b[nm…]中括号代表的是一个字符，可以匹配里边所有指定字符之一 reg=/[ab]/; ===reg=/a|b/;reg=/[a-z]/; 任意小写字母reg=/[A-Z]/; 任意大写字母reg=/[A-z]/; 任意字母 === reg=/[A-z]/i;reg=/a[bde]c/; 含有abc或adc或aecreg=/[0-9]/; 任意数字 x{n} 以大括号前的字符为标准匹配n个字符
- {n,m}匹配n到m个字符
- {n,}匹配最少n个字符
注意：正常情况下匹配多少个字符是能匹配多少匹配多少，这是正则表达式的贪婪模式也是默认的模式，如果在后面加上？就变成了非贪婪模式。
例;reg=/[0-9]{11}/ 连续的11位数字（xy） 小括号代表一个整体，也可以认为是节点，方便在匹配到的字符串中再进行分别的字符串提取正则中也有特殊代表符
- \d 代表所有数字
- \w 代表所有英文
- . 代表所有非换行符和制表符以外的一个字符
- \n\r 代表是换行和回车符
- . 代表 .
- \\ 代表 注意：使用构造函数时，由于它的参数是一个字符串，而\是字符串转义字符，如果要使用\则需要使用\\来代替
let reg=new RegExp("\.");正则中也有特殊代表字符数量的代表符 x+ 最少一个x字符等同于x{1,}x? 一个或零个字符，等同于x{0,1}x* 零个或多个字符，等同于x{0,} 正则中也有其他特殊作用的代表符 ^X 指的是以x作为开头x$ 指的是以x结尾的字符串
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69d2aa0e2a0fa6dcfbca2169a7c1ba1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2db15b4516b67401c76cc02050a16b33/" rel="bookmark">
			剑指java面试视频学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		剑指java面试知识点总结 网络基础知识讲解网络知识考点**OSI的“实现”：TCP/IP****说说TCP的三次握手**TCP和UDP的区别TCP的滑动窗口Http相关Socket简介 数据库RedisJVM谈谈你对java的理解注：本篇学习内容来自本人在慕课网购买的剑指Java面试-Offer直通车（有想学的可以分享，微信号：Double_C9） 网络基础知识讲解 网络知识考点 OSI的“实现”：TCP/IP OSI有七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层；TCP/IP有四层：链路层、网络层、传输层、应用层
说说TCP的三次握手 传输控制协议TCP简介
面向连接的、可靠的、基于字节流的传输层通信协议
将应用层的数据流分割成报文段并发送给目标节点的TCP
数据包都有序号，对方收到则则发送ACK确认，未收到则重传
使用校验和来检验数据在传输过程中是否有误
TCP他报文头的TCP Flags中常见6个内容
URG:紧急指针标志
ACK:确认序号标志
PSH:push标志
RST:重置连接标志
SYN:同步序号，用于建立连接过程
FIN:finish标志，用于释放连接
“握手”是为了建立连接，TCP三次握手的流程如下：
在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。
第一次握手：建立连接时，客户端发送SYN包（seq=x）到服务器，并进入SYN_SEND状态，等待服务器确认；
第二次握手：服务器收到SYN包，必须确认客户的SYN包（ack+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
为什么需要三次握手，才能将连接建立起来？
为了初始化sequence number的初始值
首次握手的隐患—SYN超时
问题起因分析
Server收到Client的SYN，回复SYN-ACK的时候未收到ACK确认
Server不断重试直至超时（重试5次，每次等待时间都翻倍，1秒，2秒，4秒，8秒，16秒，32秒），Linux默认等待63秒才断开连接
针对SYN Flood的防护措施
SYN队列满后，通过tcp_syncookies参数回发SYN Cookie
若为正常连接则Client会回发SYN Cookie，直接建立连接
建立连接后，Client出现故障怎么办？
保活机制
向对方发送保活探测报文，如果未收到响应则继续发送
尝试次数达到保活探测数仍未收到响应则中断连接
谈谈TCP的四次挥手
“挥手”是为了终止连接，TCP采用四次挥手来释放连接
第一次挥手：Client发送一个FIN,用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1 状态；
第二次挥手：Server收到FIN后，发送一个ACK给Client,确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态
第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态
第四次握手：Client收到FIN后，Client进入 TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。
为甚么会有TIME_WAIT状态
原因:
确保有足够的时间让对方收到ACK包
避免新旧连接混淆
为什么需要四次挥手（握手）才能断开连接
因为全双工，发送方和接收方都需要FIN报文和ACK报文
服务器出现大量CLOSE_WAIT状态的原因
对方关闭socket连接，我方忙于读或写，没有及时关闭连接
检查代码，特别是释放资源的代码
检查配置，特别是处理请求的线程配置
TCP和UDP的区别 UDP特点
面向非连接
不维护连接状态，支持同时向多个客户端传输相同的消息
数据包报头只有8个字节，额外开销较小
吞吐量只受限于数据生成速率、传输率以及机器性能
尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表
面向报文，不对应用程序提交的报文信息进行拆分或者合并
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2db15b4516b67401c76cc02050a16b33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0620b36489e16c9a68a8ffa99a3a6eda/" rel="bookmark">
			贪便宜给自己带来的麻烦，哈哈。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谈到贪心，我十分的惭愧，回忆自己从懂事到大学，甚至后来工作了，依然带有很深的个人习气。现将我的心路历程与大家分享，一是忏悔，二是希望大家引以为戒。
记得母亲曾经描述过我出生时的情形，生产比较顺利，虽然母亲并没有刻意保养，甚至在怀我时，也干过体力活，但是胎气却十分稳定。和怀我兄长时不同，似乎我注定就要成为母亲的儿子。
后来到了幼儿园，据说也是一个不吃亏的主儿，每逢小女孩路过我的床位，我总是伸手抓人家头发。于是，园里阿姨不免要告状，母亲为了卖人情，不得不时常的给阿姨们送些礼物。而其实在那个时候起，“偷盗，占便宜”的习气就已显露的十分明显了。
记得每逢发糖块时，自己总想多来点。那时候就有多拿小朋友糖果的经历了。可见人的习气很多是与生俱来的。因为我的父母都是非常老实本分的人，也从来没有占人便宜的念头。而我的祖辈，都是“损己利人”型的人，更没有此类习气。居然我能出生在这个家庭中，不知道是多少辈修来的福分。
大了点后，就发现自己本能的对钥匙和锁之类的东西特别感兴趣，当时家里有很多废弃的钥匙，而自己对这类东西很敏感，经常喜欢用旧钥匙去尝试开老锁，而居然真的能开开！现在看来一定是我上辈子做过贼或是锁匠之类的人吧，居然还保存着原来的技能！如果你现在问我人有没有前世，我说肯定有，不然如何解释这与生俱来的能力呢。记得为了吃到爷爷锁在柜子里的点心，居然小小年纪也能用废铁片和剪子，配出钥匙，之后在神不知鬼不觉中享受自己的战利品，而这些动作很隐蔽，所以大人忙于工作基本没精力发现，甚至到了我后来工作学佛了，向家人发露忏悔，母亲才知道我有这种毛病。所以说家庭教育很重要，如不是我出生在这样一个老师本分家庭，可能我长大后会成为社会的大祸害。
就这样，开始时占小便宜的习惯，逐渐演变为偷盗行为，一直延续下来，因为不经常范，而且每次偷盗数量不大，也不贵重，所以一直没有引起长辈的关注。
到了我上小学四五年级的时候，出了一件事，使我开始意识到偷盗后果的严重性。记得我当时的班级里，同学们都有各种好看的笔，圆珠笔、钢笔、油笔，一次一个同学的笔掉到了地上，没有发觉，我正好经过发现了，一时贪心起，就藏了起来，放在自己的包里，不敢拿出来，自己也不敢用，就是藏着。直到后来演变到自己主动将别人的笔碰到地上。之后自己再假装系鞋带而藏起来。由于丢失笔的人越来越多，后来班里的人开始警觉起来了。
真的是天网恢恢，疏而不漏，一次我的准考证（还是别的什么记不清了）找不到了，情急之下，一个小伙伴帮我查找书包，结果把所有笔都找了出来，之后，还示意我是不是偷的，而我死不认账，一直坚持是自己捡的。但当时已经有大惭愧，觉得十分难堪。那一天我都不知是怎么过的。回家后就把所有的其余的笔都扔到了厕所天窗风道里，并决定日后再不范此毛病。
那时起我的体质就有变化了。本来我天生的体质比我哥好，底子硬，结果到了13岁时，却得了肠胃病。在同龄人中，这种现象极为罕见，因为正是长身体嘴最壮的时候，吃啥都应该没事的。而肠胃病的起因也是因为自己贪图好的饮食，与在家养病的表弟争宠而得的报应。于是受尽了折磨，犯病时，肚里如刀剑剜割一样疼痛难忍。犯病时，行住坐卧都不自在，只有在床上跪着才能舒服些。现在明白了，当时跪着的姿势是让自己忏悔反省自己的罪过。由于疾病，以前贪吃的习惯收敛了，体质也变瘦了，当然毕竟是孩子，不太明显，但是到了成年后，消瘦的体态一直都没有改变，可见报应的力量多大。
还有很多平常发生的小事，但是很考验人的贪心的。比如很多次买菜买东西时，小贩多找了钱而没发现，于是自己就天知地知我知、他不知了…，于是，自己也经常被别人天知地知他知、我不知…；遇到地上别人掉的钱（数额不大），自己就欣然接受了，还痒痒自得觉得挺幸运的；还有就是每逢收到假钱时，以前我的做法是再花出去。结果也很快吃了假钱的亏，最明显的一个哑巴亏跟大家分享一下，记得一次是出去办事，手里好像是有100元，我碰到刚去银行取钱回来的大妈，于是跟大妈换了钱，结果等到用钱时发现一张50元的是假的。之后回来找大妈对峙，大妈为人直率，不是那种不善的人。后来因为这个事，还一起带我去店家对峙。银行出错的几率很低，都10多年的老邻居，大妈更不会骗我，中途被人掉包了，究竟问题出在哪里，我一直也没想明白。但是假钱最终留在手里，做纪念了，以后有假钱绝对不敢化了。再害别人。现在就是地上掉了金币也不敢捡了，冥冥之中似乎有无数的眼睛在看着我呢…
后来自己终于安份了好多年。但习气仍然还在，大学期间又犯病了。记得应该是在一个小百货部，二层的，由于店内凌乱，我到了二层趁着店主不注意偷了店里的皮带，之后又忏悔，收敛了一段时间。
工作后偷盗占便宜的习气又起来了，真的习气是如此根深蒂固。
那时我已经工作了，在一家中关村数码销售公司，工资每月也有几千块，但是占便宜的毛病任然很重，单位里公共的用纸、笔还有一些久久不用的电子产品，比如读卡器、文具之类的小物件，不是太贵重的东西，以我职务之便，私自据为己有了。之后发生了一件让我说不清道不明的失窃案，一个以我名义借的存储卡放在桌上，结果被人偷走了。这件事最终怪在我头上，吃了哑巴亏，又被公司扣了200元钱。但是我还是没觉悟，自认倒霉了。因为中关村电子市场小偷很多。大厦里也一样，经常有流动惯犯。
2002年，非典来了！一个从深圳回京的老总朋友也带来了可怕消息，而且说那边已经封城了，很快北京也可能封城，我是个很惜命的人，趁着当时公司年关大量员工离职，我也在一位元老影响下不辞而别了！现在看来，还是太年轻了，不懂规矩，其实正常离职交接也不会损失当月工资了，这就叫报应吧，哎！毕竟表面上还是很得老总信赖的。结果，刚到老家几天，北京就封闭了，所有人都出不去了！在家无事干其实也是很可怕的，职业轨迹的迷茫，方向定位模糊，没人能指引你！反问内心，我究竟喜欢什么？之前的工作很杂乱，仅仅是为了糊口。这回得选择一个有兴趣的工种了。思来想去，最终决定转行影视动画，这也是我小时候的所爱，经过小一年的软件自学，居然机会来了…
命运就是这么奇葩，不久一个前同事居然在北京创业开公司，要做动画片，于是我就成了他的得利员工。不过后来也出了一件事，让我后悔一生！常言道，没有吃不了的苦，只有享不了的福！ 我的这个同事虽然是个老爷们，但经常爱做美容，去个黑头啥的，一次偶然的机会请我也做个美容，说让我也享受一下，当时一念贪心，反正他请客，就享受一下，于是我们就去了附近一家小店，用得也不知道啥护肤品。洗完之后，确实干净了，我还傻呵呵照镜子，结果没过多久鼻子周围就开始发红，一到夏天皮肤油脂一多就红肿，血丝很重，非常不美观，以至于后来做培训老师了，这个病根也没治好，被学生们戏称“红鼻子”老师！而那个同事却丝毫没事！
后来为了治这病冤枉花费了6000多，做过激光去血丝手术，忍者剧痛也至今未愈。 之后我终于觉悟了发重誓，那就是老爷们绝不要做美容我也不治了！现在回头看，因为贪图几十块的享乐，而破坏了 自然平衡 实在罪有应得，更不用说整容改变面貌了！罪过就更大了，自然本来是美的，每个人来到世间，不管美丑相貌都是父母给的，都有命运安排。记得以前看过一个新闻说，一个农村的父母不认整容的子女了！说**“我不认识你！你是谁呀？！”**哎！
再好的美容技术也不过是做做表面文章，试看整容者不但要经受身心痛苦折磨，还要付出巨大费用，也仅仅是换取短暂虚荣！而不断反复的整容后遗症却将伴其一生。现代人是可怜的，因为不懂自然规律 ，又没人教，就免不了要吃大苦头了！有人说，你这算个案吧！毕竟还有很多人没事，我只能说我的福报太小，没那个福分！而其实我算是幸运的，能及时回头，悬崖勒马，免去了日后更多的浪费和折磨。说到底，贪的习气真的太顽固了，而环境里又处处引诱你起贪心，一不留神又犯老毛病，而你以为断了，其实没有。而你总得需要不断经历反复挫折… 难道真的就没救了吗？
直到一次超市里的盗窃经历，让我决定再不犯了，因为已经触犯法律红线了，记得那时是在一个大超市里，毛病又犯了，私自藏起一把10多块钱水果刀。其实自己真不缺那十几块钱。就是贪心毛病一犯时，真的是控制不了。之后就被警卫抓到了，并说要移送公安机关，先记录一下。当时我真的是五雷轰顶，想我一生清白就这样被染污了，真的太不值得。这次下的决心一定要断了偷盗的毛病。之后付了200元罚款，允许我带刀走。但我已无脸再用这个产品，把它默默放回超市了。现在回忆起来，真的感恩这些教育过我的人，感觉都是佛菩萨在帮我悔改。并给我机会改正。
因果的报应也确实在我身上有明显的应验。就是很多好的机会都与我无缘，比如毕业时自己喜欢的工作却不顺利，失去了好几次机会。后来有好几次落户北京的机会，最后总是不了了之。自己看别人投资理财赚钱，自己也投资，结果却老是赔钱，说来也真巧了，我的室友买就赚钱，之后劝我也投资，我一买，我们两就开始一起赔钱，全线套牢，直到亏了8000-10000左右后，自己终于明白了原来财富是命里有的，于是退出了。自己也再不想什么投资理财的事了，不过简朴生活的习惯还是继承了家族传统。不然也攒不下钱理财了。
还有就是总是丢失财物。记得工作后，大概十年前，花了300多元买了铝合金折叠自行车，没想到还没骑两天转眼就丢了，更倒霉的一次，自己监督公司的门面装修，我是公司美工，加班到凌晨，下班时结果发现自行车丢了，又没带钱包手机。那是在凌晨4点左右的北京中关村，连出租车都少了。情急之下，只能用原来的钥匙，在路边找荒废无人认领的破自行车，碰碰运气，之后骑着没气的自行车回家，嘿！居然给迷路了！因为当时我刚搬家到一高层筒子楼，北京的楼都差不多样，我也没记清楚，结果一直骑到了农村野地里，大黑天也没个人影，越走越荒凉，感觉不对，想找路人问问，遇到一面包大哥，结果还没开口就被大哥骂“滚！”直到了凌晨5点多，终于遇到了清扫大街的清洁工大姐，感觉终于遇到救命恩人了，在好心大姐指引下终于回到了住处，结果发现小区过了12点电梯停电，大门锁了，自己没带手机，只能在对讲机里与同住的兄弟通话，把兄弟从睡梦中吵醒给我开门，之后自己爬了16层楼回到住处。自打这次经历后，每逢遇到困难和挫折，我经常用这件事鞭策我，人生最“连续倒霉”的事我都遇到了，还有什么事过不去！看不开！放不下的！哈哈。遇到有朋友烦恼时，我就拿自己开涮，把这个经历跟朋友分享，这种经历可不是啥人都能遇到的，哈哈哈。还有一次是遇到了QQ诈骗，这类欺诈手段早就被大家识破了，而我当时却中招了，直到损失了4000块的时候，才醒悟知道是骗子,报了案但是最终也没结果，可能是此类案件很多，数额又不算巨大吧。（这件事我后来才明白是前世欠了这些人的钱，今世遇到了债主，就失去了理智和判断力，可见业力的能量多大，不过欠的不多就4000，所以一到这个数，就恢复理智了。因此人不可以损害他人利益，今后一定要还的，都是真的，很多的新闻中报到的新奇受骗事件和奇葩人，大家都觉得太不可思议了，人怎么这么没智慧，实不知，每个人只不过是命运的木偶，偿还前生的各种造作产生的果报而已），…
而我之前却一直不知道自己为什么这么背！原来是自己作恶在先，心行不善的恶报而已。现在大众多不信因果报应。实际是因为自己福报较大，一时做了恶事，而没马上报应罢了。而我是属于福报小的人，典型的现世报型！所以能相信因果。接触到佛法后，对照经典中的教戒，才真的明了原因。肠胃病自从吃素后，很少犯了，自从学戒，（不算是持戒，因为自己没有真正受戒，）真心体会到这五条真的是佛陀的大慈大悲。告诉我们如何免除恶缘，而得到幸福的重要原则！只要坚持不贪、不盗之后，自己很少损失财物了，感应非常明显。我说过我是现世报。哈哈。善恶的标准，最基本的就是五戒十善，这是自然规律，不是佛自己定的，是佛陀见到的真相。大家一定要明白。人有福报一切才会顺利，而福报来自于十善，能做一条是一条。决定有好处。如果能懂得一切财物名利都是虚妄，生不带来，死不带去，惟有善恶报应，随我们生生世世，那必定能得一生平安。因果循环生生世世没完没了。生老病死，苦楚无量。惟有老实念佛，心怀感恩，将来升到佛国，也是可能的。
不管有没有信仰，但自然的规律冥冥之中自然在左右着我们，人们常说做事要对得起良心，良心就是德行的根本。只要做到了，必然一生平安。列出德行的根本十条。大家共勉。
十善：
不杀生:（不食肉）,不伤害、杀害、恼害任何有生命的人或小动物。得健康长寿，少病少苦。
不偷盗: 不占任何便宜，或别人不允许的条件下，不私自使用公家或他人的财物。
不邪淫：不参与淫秽类的行为。
不妄语：不说假话，为自己利益。
不两舌：不挑拨是非。
不绮语：花言巧语为自己谋利。
不恶口：不骂人说脏话。
无贪：没有贪任何便宜的念头。
无嗔: 不发脾气、不怨人、不恨人。
无愚痴：能够分清好坏，不执着自己的见解。用清净、平等、理智去应对一切。
希望大家以我为戒。断恶修善，改邪归正。一生吉祥，南无阿弥陀佛。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84c17fbdd878407e384a5d8ed347fde8/" rel="bookmark">
			excel乘法公式怎么输入_使用Excel积函数10例，公式乘除，指数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		乘法运算可以是乘积函数，也可以是Excel中的星号*，但它们不同。乘积函数不仅以单个值作为参数，还以数组和对单元格的引用作为参数，例如，要计算A1到A6中所有值的乘积，不需要逐个编写，只需编写A1:A6；并且只能用星号逐个编写。另外，如何在excel中进行划分？除法有两种计算方法，一种是使用乘积函数，另一种是使用斜杠(/)，其差等于计算乘法。在乘法和除法计算过程中，通常会遇到所有被一个数乘或除的数。它们由Excel提供的函数实现，也可以用Excel的乘法公式或除法公式实现。区别在于：一个是在原始数据中修改，另一个是生成新数据。
一、 Excel产品函数语法 1、表达式：乘积(Number1，[Number2]，…)
2、说明：
产品功能最多只能有255个数字。
B、 如果逻辑值(True和False)直接用作乘积函数的参数，则True转换为1，False转换为0；如果逻辑值位于要引用的数组或单元格中，则忽略它们。
C、 如果要引用的数组或单元格区域包含空格或文本，则在计算时也会忽略它们。
二、 Excel产品函数(Excel中的乘法函数)实例 (一) 两列数相乘的例子
1、如果需要周转。双击单元格E2，将公式=PRODUCT(C2，D2)复制到E2，按回车键，返回2405；选择E2，将鼠标移到E2右下角的单元格填充手柄上，鼠标变为黑体加号(＋)后，双击左键，返回剩余的周转量；操作过程步骤如图1所示：
图1
2、说明：C2和D2是乘法公式=积(C2，D2)中要引用的单元格，这意味着将C2和D2中的数字相乘。
(二) True和False是单元格、数组或直接作为参数的不同值
1、选择单元格B1，输入公式=积(A1:A3)，按enter键，返回3。双击B2，将formula=PRODUCT({3，TRUE，FALSE})复制到B2，按Enter，返回3；双击B3，将同一公式复制到B3，删除两个大括号，按Enter，返回0；操作步骤如图2所示：
图2
2、公式说明：
A、 乘法公式=积(A1:A3)和=积({3，TRUE，FALSE})都返回3，表示逻辑值？(True和False)在引用的单元格和数组中都被忽略。
B、 乘法公式=积(3，TRUE，FALSE)返回0，表示TRUE和FALSE直接用作参数，TRUE转换为1，FALSE转换为0。
(三) 参数是要引用的单元格区域
1、如果需要两列A和B的乘积。双击单元格C1，将公式=PRODUCT(A1:A5，B1:B5)复制到C1，按回车键，返回9.90，操作步骤如图3所示：
图3
2、公式说明：
乘法公式=乘积(A1:A5，B1:B5)乘以A1:A5和B1:B5中的所有数字，即A1*A2*A3*A4*A5*B1*B2*B3*B4*B5。
三、 如何在Excel中与* 1、并以营业额的计算为例。选择单元格E2，输入公式=C2*D2，按回车键，返回2405；再次选择E2，点击E2的单元格填充手柄，返回剩余周转量，操作步骤如图4所示：
图4
2、用*计算乘法时，不能这样做=(C2:C7)*(D2:D7)返回两列数的乘积，这样只能返回C2*D2的乘积。
四、 如何在Excel中进行划分 Excel中没有直接计算除法的功能。除法运算需要乘法函数积，也可以用斜线(/)计算。以下是它们的计算方法。
(一) 如何在Excel中用产品函数进行划分
双击单元格C1，将公式=PRODUCT(A1/B1)复制到C1，按回车键返回20.83；选择C1，双击C1的单元格填充句柄返回剩余结果，操作步骤如图5所示：
图5
(二) 如何在Excel中用斜线(/)划分
选择单元格C1，输入公式=A1/B1，按回车键，返回20.83；再次选择C1，双击C1的单元格填充句柄，返回剩余值的分割结果，操作步骤如图6所示：
图6
提示：默认情况下，Excel除法计算将舍入为多个小数。如果要四舍五入到两位小数，可以按Ctrl+1，打开“格式单元格”窗口，选择“数字”选项卡，然后选择左侧的“数字”，然后在右侧的“小数点”右侧输入2，单击“确定”。
五、 用Excel中的数字乘或除表中的所有数字 (一) 把表中的所有数字乘以一个数
如果要将表中的所有销售额乘以0.2。选择单元格E2，输入0.2，按Enter退出输入状态，再次选择E2，按Ctrl +C复制；选择D2：D7，右键单击它们，在弹出菜单中选择“粘贴特殊”，在“粘贴特殊”窗口中选择“乘法”下，单击“OK”，然后将表中的所有销售额乘以0.2；操作步骤，如图7所示：
图7
(二) 把表中的所有数字除以一个数
如果你想把表中的所有销售额除以2。选择E2，输入2，按下Enter，退出E2状态，再次选择E2，按Ctrl +C复制；选择D2：D7并右键点击它们，然后选择“粘贴特殊”，在打开的窗口中选择“Lead”下的“操作”，点击“OK”，然后D列中的所有销售被2除掉；操作步骤如图8所示：
图8
六、 Excel产品函数的扩展应用实例 (一) If+产品功能组合按标准实现涨价
1、如果你想把水果的价格提高不到3美元10%。双击单元格E2，将公式=IF(C2&lt;3，乘积(C2，(1+10%)，C2)复制到E2，按回车键，返回1.43，因为C2中的1.3符合条件，所以增加了价格；再次选择E2，双击E2的单元格填充句柄，增加了剩余价格的价格；操作步骤如图9所示：
图9
2、公式=如果(C2&lt;5，积(C2，(1+10%)，C2)说明：
A、 C2&lt;5为If的标准，如果标准为真，则价格随产品(C2，(1+10%)增加10%，即C2中的值1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84c17fbdd878407e384a5d8ed347fde8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef3f54682ec4929144819c6ac547b93e/" rel="bookmark">
			Shell脚本入门:环境变量和自定义变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Shell变量：环境变量目标Shell变量的介绍变量类型系统环境变量介绍Shell的配置文件分类环境变量分类查看当前Shell系统环境变量查看Shell变量(系统环境变量+自定义变量+函数)常用系统环境变量 小结 Shell变量：自定义变量目标自定义变量介绍分类自定义局部变量介绍定义与使用变量删除 自定义常量自定义全局变量父子Shell环境介绍自定义全局变量介绍自定义全局变量语法案例需求案例实现步骤案例演示结论 小结 Shell变量：环境变量 目标 1、理解什么是系统环境变量？
2、掌握常用的系统环境变量都有哪些？
Shell变量的介绍 变量用于存储管理临时的数据, 这些数据都是在运行内存中的.
变量类型 系统环境变量自定义变量特殊符号变量 系统环境变量 介绍 是系统提供的共享变量.是linux系统加载Shell的配置文件中定义的变量共享给所有的Shell程序使用
Shell的配置文件分类 1.全局配置文件
/etc/profile
/etc/profile.d/*.sh
/etc/bashrc
2.个人配置文件
当前用户/.bash_profile
当前用户/.bashrc
一般情况下，我们都是直接针对全局配置进行操作。
环境变量分类 在Linux系统中，环境变量按照其作用范围不同大致可以分为系统级环境变量和用户级环境变量。
系统级环境变量：Shell环境加载全局配置文件中的变量共享给所有用户所有Shell程序使用, 全局共享
用户级环境变量：Shell环境加载个人配置文件中的变量共享给当前用户的Shell程序使用, 登录用户使用
查看当前Shell系统环境变量 查看命令
env 效果
查看Shell变量(系统环境变量+自定义变量+函数) 命令
set 效果
常用系统环境变量 变量名称含义PATH与windows环境变量PATH功能一样，设置命令的搜索路径，以冒号为分割HOME当前用户主目录：/rootSHELL当前shell解析器类型：/bin/bashHISTFILE显示当前用户执行命令的历史列表文件：/root/.bash_historyPWD显示当前所在路径：/rootOLDPWD显示之前的路径HOSTNAME显示当前主机名：itheimaHOSTTYPE显示主机的架构，是i386、i686、还是x86、x64等：x86_64LANG设置当前系统语言环境：zh_CN.UTF-8 环境变量输出演示
小结 1.系统环境变量是什么?
是系统提供的环境变量, 通过加载Shell配置文件中变量数据共享给Shell程序使用
2.环境变量的分类?
系统级环境变量, Shell环境加载全局配置文件中定义的变量
用户级环境变量, Shell环境加载个人配置文件中定义的变量
3.env与set区别
env用于查看系统环境变量
set用于查看系统环境变量+自定义变量+函数
4.常用环境变量
变量名称含义PATH命令搜索的目录路径, 与windows的环境变量PATH功能一样LANG查询系统的字符集HISTFILE查询当前用户执行命令的历史列表 Shell变量：自定义变量 目标 理解自定义变量的分类
能够自定义变量进行增\删\改\查
自定义变量介绍 就是自己定义的变量
分类 自定义局部变量自定义常量自定义全局变量 自定义局部变量 介绍 就是定义在一个脚本文件中的变量, 只能在这个脚本文件中使用的变量, 就是局部变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef3f54682ec4929144819c6ac547b93e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad5b2d3bb52c0fe35aab61d048d1e139/" rel="bookmark">
			Linux下lt9611调试总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lt9611是一款mipi转hdmi的芯片，项目中有使用到，分享下调试经验。
参考设计
要先拿到源码，然后进行调试。刚好代码默认有一份驱动，那不就折腾了。适当修改后，接hdmi屏幕进行测试，i2c能正常通信，也能正确解码前端的mipi信号，感觉成功了一半。屏幕也提示检测到了hdmi信号，但黑屏。先让ic进入自测试模式，看输出正不正常，屏幕提示超出范围。
看log，有如下不正常打印
[ 211.152990] [LT9611] lt9611_pll() hdmi pll unlocked, reset pll [ 211.163594] [LT9611] lt9611_pll() hdmi pll unlocked, reset pll [ 211.172848] [LT9611] lt9611_pll() hdmi pll unlocked, reset pll [ 211.182127] [LT9611] lt9611_pll() hdmi pll unlocked, reset pll [ 211.193973] [LT9611] lt9611_pll() hdmi pll unlocked, reset pll 后来，测量27M的晶振，发现没有正常起振(27M的正旋波)，跟参考设计对比，发现贴的电容不是15pF，导致不能起振。
修改后，ic自测显示正常，屏幕也能显示正确的内容。
测试的时候，又出现的随机黑屏的情况，估计得重试调ic的参数。这一步得留给fae了，因为拿不到寄存器说明手册。
硬件检查点:
2k的精密电阻要贴上
27M的晶体要正常起振，由于示波器的探针跟地相当于一个小电容，测量1M电阻的波形时，相当于在15pF的电容处又并了一个电容，会导致波形出不来，当然手上的示波器比较低端，不确定高端的示波器能不能量出来。
参考正确的打印
[ 1475.290967] [LT9611] lt9611_mipi_input_digtal() lt9611 set mipi lanes = 0 [ 1475.302923] [LT9611] lt9611_mipi_input_digtal() lt9611 set mipi ports = 1 [ 1475.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad5b2d3bb52c0fe35aab61d048d1e139/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6f599ac1a0941aaf65108d40868a5f4/" rel="bookmark">
			win10添加网络打印机_windows10安装Hp1010/1012/1015打印机教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 windows10系统安装越来越普遍，升级到Windows10以后，无法直接安装一些老式打印机，比如hp laserjet1010/1012/1015，惠普官方没有相应的驱动，指导方法是通过win10更新，win10更新后最低只支持hp laserjet1018，那么如何安装上述老式打印机呢？网上搜了下都不是很具体，详细方法如下：
从惠普官网下载上述系列打印机的windows-vista驱动(分32位与64位)，下载后备用。 打开控制面板-硬件和声音-查看设备和打印机-添加打印机。 弹出的对话页面直接选择“我所需的打印机未列出”。 弹出的对话框选择最后一项，“通过手动设置添加本地打印机或网络打印机”，点下一步。 接下来选择“使用现有的端口”，端口选择usb001，然后点下一步。 弹出的对话框选择“从磁盘安装”。 弹出的对话框选择第一步下载的驱动里的.inf文件。会发现1010打印机出现到列表里。双击就可以用了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee5d4435b80a7a8c877813ce6ea3eb4/" rel="bookmark">
			【动手学MVG】张正友标定法原理与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 介绍理论基础棋盘格检测TODO: 以后开单章去介绍标定中的角点检测算法。 基本符号图像平面与棋盘格平面之间的单应矩阵 计算 A − T A − 1 A^{-T}A^{-1} A−TA−1计算相机内参矩阵计算相机外参矩阵SVD精调R优化外参 估计镜头的畸变系数估计畸变的初值带畸变的代价函数 TODO : 退化配置标定流程总结（包括算法）TODO：代码实现附录矩阵的F范数 参考文献 介绍 张在论文中把相机标定方法分为两类：摄影测量标定法(Photogrammetric calibration) 和 自标定法(Self-calibration)，
摄影测量标定法(Photogrammetric calibration) ：采用已知尺寸的高精度3D标定物进行标定的方法。该类方法标定结果准确，但是需要昂贵的标定物以及复杂的标定设置。属于该类方法的一些工作如下： O. Faugeras. Three-Dimensional Computer Vision: a Geometric Viewpoint. MIT Press, 1993.R. Y. Tsai. A versatile camera calibration technique for high-accuracy 3D machine vision metrology using off-the-shelf tv cameras and lenses. IEEE Journal of Robotics and Automation, 3(4):323–344, Aug. 1987. 自标定法(Self-calibration) ：不需要任何标定物，只需要在静态场景中移动相机。该类方法标定结果并不总是可靠的，但是标定比较灵活。属于该类方法的一些工作如下： S. Bougnoux. From projective to euclidean space under any practical situation, a criticism of self-calibration.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ee5d4435b80a7a8c877813ce6ea3eb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43c51535009c9552743e3f026dd3c792/" rel="bookmark">
			squeezenet论文详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据原作者翻译，进行部分修改、标注，以方便查阅。文章仅作知识整理、分享，如有侵权请联系作者删除博文，谢谢！
论文地址：aqueezenet论文
SQUEEZENET: ALEXNET-级别精度50X 较少的参数和 &lt; 0.5MB模型大小
摘要 深卷积神经网络 (CNNs) 最近的研究主要集中在提高精度。对于给定的精度级别, 通常可以确定多个 CNN 体系结构, 以达到该精度级别。同样的精度, 较小的 CNN 架构提供至少三优点:
1) 较小的 CNNs 在分布式训练过程中需要跨服务器进行更少的通信。
2) 较小的 CNNs 需要更少的带宽, 将一个新的模型从云端导出到自动汽车。【译者注：这是针对自动驾驶汽车来说的】
3) 较小的 CNNs 提供了在 fpga 和其他内存有限的硬件上部署的可行性。
综上， 我们提出了一个叫做 SqueezeNet 的小型 CNN 架构。SqueezeNet 在 ImageNet 上达到 AlexNet 级精度, 参数减少50倍。此外, 使用模型压缩技术, 我们可以将 SqueezeNet 压缩到小于 0.5MB (比AlexNet小510×).
SqueezeNet 体系结构可在此处下载: https://github.com/DeepScale/SqueezeNet
1、简介 最近对深卷积神经网络 (CNNs) 的研究主要集中在提高计算机视觉数据集的精确度上。对于给定的精度级别, 通常可以用不同的 CNN 体系结构来实现了该精度级别。而具有更少参数的 CNN 体系结构具有以下几个优点:
更高效的分布式训练。服务器之间的通信是分布式 CNN 训练的可扩展性的重要限制因素。对于分布式数据并行训练, 通信开销与模型中的参数数目成正比 (Iandola 等, 2016)。简而言之, 小模型由于需要较少的通信量而得以快速地训练。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43c51535009c9552743e3f026dd3c792/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0ac55613ebd86fdb1e175930bfcd52b/" rel="bookmark">
			JavaEE 企业级分布式高级架构师（二十）RocketMQ学习笔记（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RocketMQ学习笔记 进阶篇消息样例普通消息消息发送发送同步消息发送异步消息单向发送消息三种发送方式的对比 消费消息 顺序消息如何保证顺序顺序的实现MessageListenerOrderly与MessageListenerConcurrently区别 广播消息集群消费模式广播消费模式示例 延时消息介绍第三方存储选型要求RocketMQ中的延时消息实现原理第一步:修改消息Topic名称和队列信息第二步:转发消息到延迟主题的CosumeQueue中第三步:延迟服务消费SCHEDULE_TOPIC_XXXX消息第四步:将信息重新存储到CommitLog中延迟消息存放 批量消息过滤消息TAG模式过滤SQL表达式过滤支持的语法支持的类型 类过滤模式(基于4.2.0版本) 事务消息概念介绍分布式事务消息的优势典型场景交互流程事务消息发送步骤事务消息回查步骤 注意事项示例 进阶篇 消息样例 rocketmq提供丰富的消息类型，满足各种严苛场景下的高级特性需求，当前支持的消息类型涵盖普通消息、顺序消息(全局顺序 / 分区顺序)、分布式事务消息、定时消息/延时消息。java中要使用rocktmq，需要引入依赖： &lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt; &lt;version&gt;4.7.1&lt;/version&gt; &lt;/dependency&gt; 普通消息 普通消息是指消息队列 RocketMQ 版中无特性的消息，区别于有特性的定时和延时消息、顺序消息和事务消息。 消息发送 发送同步消息 原理：同步发送是指消息发送方发出一条消息后，会在收到服务端返回响应之后才发下一条消息的通讯方式。 应用场景：此种方式应用场景非常广泛，例如重要通知邮件、报名短信通知、营销短信系统等。 // 1、封装producer(生产者组), 2、指定nameServer, 3、开启Producer, 4、构造消息、指定tag、设置key, 5、关闭生产者 发送异步消息 原理：异步发送是指发送方发出一条消息后，不等服务端返回响应，接着发送下一条消息的通讯方式。消息队列 RocketMQ 版的异步发送，需要用户实现异步发送回调接口(SendCallback)。消息发送方在发送了一条消息后，不需要等待服务端响应即可发送第二条消息。发送方通过回调接口接收服务端响应，并处理响应结果。 异步场景：异步发送一般用于链路耗时较⻓，对响应时间较为敏感的业务场景，例如用户视频上传后通知启动转码服务，转码完成后通知推送转码结果等。 单向发送消息 原理：发送方只负责发送消息，不等待服务端返回响应且没有回调函数触发，即只发送请求不等待应答。此方式发送消息的过程耗时非常短，一般在微秒级别。 应用场景：适用于某些耗时非常短，但对可靠性要求并不高的场景，例如日志收集。 三种发送方式的对比 下表概括了三者的特点和主要区别： 发送方式发送TPS发送结果反馈可靠性同步发送快有不丢失异步发送快有不丢失单向发送最快无可能丢失 消费消息 顺序消息 顺序消息(FIFO 消息)是消息队列 RocketMQ 版提供的一种严格按照顺序来发布和消费的消息。顺序发布和顺序消费是指对于指定的一个 Topic，生产者按照一定的先后顺序发布消息;消费者按照既定的先后顺序订阅消息，即先发布的消息一定会先被客户端接收到。 如何保证顺序 在MQ的模型中，顺序需要由3个阶段去保障： 消息被发送时保持顺序消息被存储时保持和发送的顺序一致消息被消费时保持和存储的顺序一致 发送时保持顺序意味着对于有顺序要求的消息，用户应该在同一个线程中采用同步的方式发送。存储保持和发送的顺序一致则要求在同一线程中被发送出来的消息A和B，存储时在空间上A一定在B之前。而消费保持和存储一致则要求消息A、B到达Consumer之后必须按照先A后B的顺序被处理。如下图所示：对于两个订单的消息的原始数据：a1、b1、b2、a2、a3、b3（绝对时间下发生的顺序） 在发送时，a订单的消息需要保持a1、a2、a3的顺序，b订单的消息也相同，但是a、b订单之间的消息没有顺序关系，这意味着a、b订单的消息可以在不同的线程中被发送出去。在存储时，需要分别保证a、b订单的消息的顺序，但是a、b订单之间的消息的顺序可以不保证 a1、b1、b2、a2、a3、b3是可以接受的a1、a2、b1、b2、a3、b3也是可以接受的a1、a3、b1、b2、a2、b3是不能接受的 消费时保证顺序的简单方式就是“什么都不做”，不对收到的消息的顺序进行调整，即只要一个分区的消息只由一个线程处理即可；当然，如果a、b在一个分区中，在收到消息后也可以将他们拆分到不同线程中处理，不过要权衡一下收益。 顺序的实现 顺序消息分为全局顺序消息和分区顺序消息。全局顺序：对于指定的一个 Topic，所有消息按照严格的先入先出(First In First Out，简称 FIFO)的顺序进行发布和消费。分区顺序：对于指定的一个 Topic，所有消息根据 Sharding Key 进行区块分区。 同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。Sharding Key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念。 消息生产示例： 消息消费示例： MessageListenerOrderly与MessageListenerConcurrently区别 MessageListenerOrderly：有序消费，同一队列的消息同一时刻只能一个线程消费，可保证消息在同一队列严格有序消费。MessageListenerConcurrently：并发消费 广播消息 集群消费模式 适用场景：适用于消费端集群化部署，每条消息只需要被处理一次的场景。此外，由于消费进度在服务端维护，可靠性更高。具体消费示例如下图所示： 注意事项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0ac55613ebd86fdb1e175930bfcd52b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/282ddf0110dcdea1253f0cde26f196b1/" rel="bookmark">
			CNN基础知识笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://blog.csdn.net/jiaoyangwm/article/details/80011656 https://chtseng.wordpress.com/2017/09/12/%E5%88%9D%E6%8E%A2%E5%8D%B7%E7%A9%8D%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF/
1. 卷积神经网络的概念 上世纪60年代，Hubel等人通过对猫视觉皮层细胞的研究，提出了感受野这个概念，到80年代，Fukushima在感受野概念的基础之上提出了神经认知机的概念，可以看作是卷积神经网络的第一个实现网络，神经认知机将一个视觉模式分解成许多子模式（特征），然后进入分层递阶式相连的特征平面进行处理，它试图将视觉系统模型化，使其能够在即使物体有位移或轻微变形的时候，也能完成识别。
卷积神经网络是多层感知机（MLP）的变种，由生物学家休博尔和维瑟尔在早期关于猫视觉皮层的研究发展而来，视觉皮层的细胞存在一个复杂的构造，这些细胞对视觉输入空间的子区域非常敏感，称之为感受野。
CNN由纽约大学的Yann Lecun于1998年提出，其本质是一个多层感知机，成功的原因在于其所采用的局部连接和权值共享的方式：
减少了权值的数量使得网络易于优化降低了模型的复杂度，即减小了过拟合的风险 该优点在网络的输入是图像时表现的更为明显，使得图像可以直接作为网络的输入，避免了传统识别算法中复杂的特征提取和数据重建的过程，在二维图像的处理过程中有很大的优势，如网络能够自行抽取图像的特征包括颜色、纹理、形状及图像的拓扑结构，在处理二维图像的问题上，特别是识别位移、缩放及其他形式扭曲不变性的应用上具有良好的鲁棒性和运算效率等。
名称特点LeNet5没啥特点-不过是第一个CNN应该要知道AlexNet引入了ReLU和dropout，引入数据增强、池化相互之间有覆盖，三个卷积一个最大池化+三个全连接层VGGNet采用1x1和3x3的卷积核以及2*2的最大池化使得层数变得更深。常用VGGNet-16和VGGNet19Google Inception Net这个在控制了计算量和参数量的同时，获得了比较好的分类性能，和上面相比有几个大的改进：1、去除了最后的全连接层，而是用一个全局的平均池化来取代它； 2、引入Inception Module，这是一个4个分支结合的结构。所有的分支都用到了11的卷积，这是因为11性价比很高，可以用很少的参数达到非线性和特征变换。3、Inception V2第二版将所有的55变成2个33，而且提出来著名的Batch Normalization；4、Inception V3第三版就更变态了，把较大的二维卷积拆成了两个较小的一维卷积，加速运算、减少过拟合，同时还更改了Inception Module的结构。微软ResNet残差神经网络(Residual Neural Network) 1、引入桥路连接结构，可以让神经网络变得非常深
2、ResNet第二个版本将ReLU激活函数变成y=x的线性函数
2.发展过程 1986年Rumelhart等人提出了人工神经网络的反向传播算法，掀起了神经网络在机器学习中的热潮，神经网络中存在大量的参数，存在容易发生过拟合、训练时间长的缺点，但是对比Boosting、Logistic回归、SVM等基于统计学习理论的方法（也可以看做具有一层隐层节点或不含隐层节点的学习模型，被称为浅层模型）来说，具有较大的优越性。
浅层模型为什么效果没有深层模型好？
浅层学习模型通常要由人工的方法来获得好的样本特性，在此基础上进行识别和预测，因此方法的有效性在很大程度上受到特征提取的制约。
深度学习的提出：
2006年，Hinton提出了深度学习，两个主要的观点是：
多隐层的人工神经网络具有优异的特征学习能力，学习到的数据更能反映数据的本质特征有利于可视化或分类深度神经网络在训练上的难度，可以通过逐层无监督训练有效克服 深度学习取得成功的原因：
大规模数据（例如ImageNet）：为深度学习提供了好的训练资源
计算机硬件的飞速发展：特别是GPU的出现，使得训练大规模上网络成为可能
深度学习的思想
深度神经网络的基本思想是通过构建多层网络，对目标进行多层表示，以期通过多层的高层次特征来表示数据的抽象语义信息，获得更好的特征鲁棒性。
什么是卷积神经网络
卷积神经网络是一种带有卷积结构的深度神经网络，卷积结构可以减少深层网络占用的内存量，其三个关键的操作，其一是局部感受野，其二是权值共享，其三是pooling层，有效的减少了网络的参数个数，缓解了模型的过拟合问题。
1）网络结构
**卷积神经网络整体架构：**卷积神经网络是一种多层的监督学习神经网络，隐含层的卷积层和池采样层是实现卷积神经网络特征提取功能的核心模块。该网络模型通过采用梯度下降法最小化损失函数对网络中的权重参数逐层反向调节，通过频繁的迭代训练提高网络的精度。卷积神经网络的低隐层是由卷积层和最大池采样层交替组成，高层是全连接层对应传统多层感知器的隐含层和逻辑回归分类器。第一个全连接层的输入是由卷积层和子采样层进行特征提取得到的特征图像。最后一层输出层是一个分类器，可以采用逻辑回归，Softmax回归甚至是支持向量机对输入图像进行分类。
卷积神经网络结构包括：卷积层，降采样层，全链接层。每一层有多个特征图，每个特征图通过一种卷积滤波器提取输入的一种特征，每个特征图有多个神经元。
输入图像统计和滤波器进行卷积之后，提取该局部特征，一旦该局部特征被提取出来之后，它与其他特征的位置关系也随之确定下来了，每个神经元的输入和前一层的局部感受野相连，每个特征提取层都紧跟一个用来求局部平均与二次提取的计算层，也叫特征映射层，网络的每个计算层由多个特征映射平面组成，平面上所有的神经元的权重相等。
通常将输入层到隐藏层的映射称为一个特征映射，也就是通过卷积层得到特征提取层，经过pooling之后得到特征映射层。
2）局部感受野与权值共享
卷积神经网络的核心思想就是局部感受野、是权值共享和pooling层，以此来达到简化网络参数并使得网络具有一定程度的位移、尺度、缩放、非线性形变稳定性。
局部感受野：由于图像的空间联系是局部的，每个神经元不需要对全部的图像做感受，只需要感受局部特征即可，然后在更高层将这些感受得到的不同的局部神经元综合起来就可以得到全局的信息了，这样可以减少连接的数目。
权值共享：不同神经元之间的参数共享可以减少需要求解的参数，使用多种滤波器去卷积图像就会得到多种特征映射。权值共享其实就是对图像用同样的卷积核进行卷积操作，也就意味着第一个隐藏层的所有神经元所能检测到处于图像不同位置的完全相同的特征。其主要的能力就能检测到不同位置的同一类型特征，也就是卷积网络能很好的适应图像的小范围的平移性，即有较好的平移不变性（比如将输入图像的猫的位置移动之后，同样能够检测到猫的图像）
3）卷积层、下采样层、全连接层
卷积层：因为通过卷积运算我们可以提取出图像的特征，通过卷积运算可以使得原始信号的某些特征增强，并且降低噪声。
用一个可训练的滤波器fx去卷积一个输入的图像（第一阶段是输入的图像，后面的阶段就是卷积特征map了），然后加一个偏置bx，得到卷积层Cx 下采样层：因为对图像进行下采样，可以减少数据处理量同时保留有用信息，采样可以混淆特征的具体位置，因为某个特征找出来之后，它的位置已经不重要了，我们只需要这个特征和其他特征的相对位置，可以应对形变和扭曲带来的同类物体的变化。
每邻域四个像素求和变为一个像素，然后通过标量Wx+1加权，再增加偏置bx+1，然后通过一个sigmoid激活函数，产生一个大概缩小四倍的特征映射图Sx+1 全连接层：采用softmax全连接，得到的激活值即卷积神经网络提取到的图片特征
卷积神经网络相比一般神经网络在图像理解中的优点：
网络结构能够较好的适应图像的结构同时进行特征提取和分类，使得特征提取有助于特征分类权值共享可以减少网络的训练参数，使得神经网络结构变得简单，适应性更强 3、如何利用CNN实现图像识别的任务 输入层读入经过规则化（统一大小）的图像，每一层的每个神经元将前一层的一组小的局部近邻的单元作为输入，也就是局部感受野和权值共享，神经元抽取一些基本的视觉特征，比如边缘、角点等，这些特征之后会被更高层的神经元所使用。卷积神经网络通过卷积操作获得特征图，每个位置，来自不同特征图的单元得到各自不同类型的特征。一个卷积层中通常包含多个具有不同权值向量的特征图，使得能够保留图像更丰富的特征。卷积层后边会连接池化层进行降采样操作，一方面可以降低图像的分辨率，减少参数量，另一方面可以获得平移和形变的鲁棒性。卷积层和池化层的交替分布，使得特征图的数目逐步增多，而且分辨率逐渐降低，是一个双金字塔结构。
4、CNN的特征 1）具有一些传统技术所没有的优点：良好的容错能力、并行处理能力和自学习能力，可处理环境信息复杂，背景知识不清楚，推理规则不明确情况下的问题，允许样品有较大的缺损、畸变，运行速度快，自适应性能好，具有较高的分辨率。它是通过结构重组和减少权值将特征抽取功能融合进多层感知器，省略识别前复杂的图像特征抽取过程。
2）泛化能力要显著优于其它方法，卷积神经网络已被应用于模式分类，物体检测和物体识别等方面。利用卷积神经网络建立模式分类器，将卷积神经网络作为通用的模式分类器，直接用于灰度图像。
3）是一个前溃式神经网络，能从一个二维图像中提取其拓扑结构，采用反向传播算法来优化网络结构，求解网络中的未知参数。
4）一类特别设计用来处理二维数据的多层神经网络。CNN被认为是第一个真正成功的采用多层层次结构网络的具有鲁棒性的深度学习方法。CNN通过挖掘数据中的空间上的相关性，来减少网络中的可训练参数的数量，达到改进前向传播网络的反向传播算法效率，因为CNN需要非常少的数据预处理工作，所以也被认为是一种深度学习的方法。在CNN中，图像中的小块区域（也叫做“局部感知区域”）被当做层次结构中的底层的输入数据，信息通过前向传播经过网络中的各个层，在每一层中都由过滤器构成，以便能够获得观测数据的一些显著特征。因为局部感知区域能够获得一些基础的特征，比如图像中的边界和角落等，这种方法能够提供一定程度对位移、拉伸和旋转的相对不变性。
5）CNN中层次之间的紧密联系和空间信息使得其特别适用于图像的处理和理解，并且能够自动的从图像抽取出丰富的相关特性。
6）CNN通过结合局部感知区域、共享权重、空间或者时间上的降采样来充分利用数据本身包含的局部性等特征，优化网络结构，并且保证一定程度上的位移和变形的不变性。
7）CNN是一种深度的监督学习下的机器学习模型，具有极强的适应性，善于挖掘数据局部特征，提取全局训练特征和分类，它的权值共享结构网络使之更类似于生物神经网络，在模式识别各个领域都取得了很好的成果。
8） CNN可以用来识别位移、缩放及其它形式扭曲不变性的二维或三维图像。CNN的特征提取层参数是通过训练数据学习得到的，所以其避免了人工特征提取，而是从训练数据中进行学习；其次同一特征图的神经元共享权值，减少了网络参数，这也是卷积网络相对于全连接网络的一大优势。共享局部权值这一特殊结构更接近于真实的生物神经网络使CNN在图像处理、语音识别领域有着独特的优越性，另一方面权值共享同时降低了网络的复杂性，且多维输入信号（语音、图像）可以直接输入网络的特点避免了特征提取和分类过程中数据重排的过程。
9）CNN的分类模型与传统模型的不同点在于其可以直接将一幅二维图像输入模型中，接着在输出端即给出分类结果。其优势在于不需复杂的预处理，将特征抽取，模式分类完全放入一个黑匣子中，通过不断的优化来获得网络所需参数，在输出层给出所需分类，网络核心就是网络的结构设计与网络的求解。这种求解结构比以往多种算法性能更高。
10）隐层的参数个数和隐层的神经元个数无关，只和滤波器的大小和滤波器种类的多少有关。隐层的神经元个数,它和原图像，也就是输入的大小（神经元个数）、滤波器的大小和滤波器在图像中的滑动步长都有关。
5、CNN的求解 CNN在本质上是一种输入到输出的映射，它能够学习大量的输入与输出之间的映射关系，而不需要任何输入和输出之间的精确的数学表达式，只要用已知的模式对卷积网络加以训练，网络就具有输入输出对之间的映射能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/282ddf0110dcdea1253f0cde26f196b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f5136938bfd4830d661a74c4fbabae2/" rel="bookmark">
			【经验总结】“投”——如何寻找适合投递的期刊或者会议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 文章写好了就要投稿，对于大部分的投稿，一般是由导师替你把握。但若没有了前人经验，靠自己如何去挑选哪些期刊或者会议适合自己呢？本期的经验总结就是讨论这一点。
本系列主要总结一些工具和方法论，感兴趣可继续阅读以下文章：
【经验总结】“找”——如何找相关领域的文献【经验总结】“读”——如何阅读外文文献【经验总结】“投”——如何寻找适合投递的期刊或者会议 1. 国内——小木虫 这是一个功能非常多的网站，我们在这里主要使用它的社区板块。
期刊 会议 评价 其优点在于它的社交论坛是“活”的，因此有很多经验性的分享。其缺点在于功能过于复杂和同构，不够精准。
2. 国外——Conference Partner (会伴) 无需翻墙，简单注册，计算机专用。
期刊 会议 评价 信息非常的清晰，包含了什么档次、什么期刊、什么时间截止。除此之外，还可以用来查参考文献，比如，某一个期刊官网，某一个会议是第几届。
经验就总结到这里，没错，我就是为了拿1024程序员序章，祝大家节日快乐！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5b571047da0915320537895411e75ab/" rel="bookmark">
			三、Linux 教程-基础命令(181~完)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二、Linux 命令 1. Linux 命令大全 Linux 命令大全
Linux 命令大全1、文件管理 cat chattr chgrp chmod chown cksum cmp diff diffstat file find git gitview indent cut ln less locate lsattr mattrib mc mdel mdir mktemp more mmove mread mren mtools mtoolstest mv od paste patch rcp rm slocate split tee tmpwatch touch umask which cp whereis mcopy mshowfat rhmask scp awk read updatedb 2、文档编辑 col colrm comm csplit ed egrep ex fgrep fmt fold grep ispell jed joe join look mtype pico rgrep sed sort spell tr expr uniq wc let 3、文件传输 lprm lpr lpq lpd bye ftp uuto uupick uucp uucico tftp ncftp ftpshut ftpwho ftpcount 4、磁盘管理 cd df dirs du edquota eject mcd mdeltree mdu mkdir mlabel mmd mrd mzip pwd quota mount mmount rmdir rmt stat tree umount ls quotacheck quotaoff lndir repquota quotaon 5、磁盘维护 badblocks cfdisk dd e2fsck ext2ed fsck fsck.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5b571047da0915320537895411e75ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dffbfcf6ea65215fc775dd915adef320/" rel="bookmark">
			python实现自动化打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这次真的是出于实际需要，想要用python写个小脚本
老板发给我一份包含几百个人信息的pdf文件，如果一份一份打开文件，点打印我感觉要看到眼花。
但是我可是学过python的（虽然面向对象还没有学完），但是调用第三方库是学了呀，如果有别人的代码看看我还是能改改的。 说干就干 查资料，看别人已经写出来的内容 发现调用电脑程序需要用到win32这个库，而且初略的看了下就发现此库非常NB，怎么说，这个库可以同计算机进行交互，比如弹出提示框，或者调用系统内置一些程序。范围太广，而且不是学习目的，以后再讨论。
最终，发现主要用到的两个库是 win32api和win32print（估计这个就是管打印机的）。 安装win32，直接就 pip install pywin32 或者下面这个通过豆瓣镜像安装的
pip install -i http://pypi.douban.com/simple/ pywin32 --trusted-host pypi.douban.com
其他方法类似，pip安装不多说
在查资料，发现基本上都会用到下面这个代码
import win32print import tempfile import win32api def print_file(filename): open(filename,"r") win32api.ShellExecute( 0, "print", filename, '/d:"%s"' % win32print.GetDefaultPrinter(), ".", 0 ) 需要注意，这个代码中filename应该是文件路径，具体到文件
eg,要打印11.pdf文件 C:\Users\mik\Desktop\py_word\11.pdf
下面就容易了，写一个得到全部文件内容的代码，然后调用print_file就行了 path = r"C:\Users\mik\Desktop\打印" for i in os.listdir(path): file_path = os.path.join(path,i) print("你要打印的文件是%s"%i) print_file(file_path) 哈哈，nb，至此大功告成，后来发现，每一个pdf有十几页，而我要把他们都订起来。。。。 下次我可能就要写一个自动订文件打印机的程序了 后记，打印机选择是默认的打印机，我用的是单面打印的打印机，如果是双面打印，可以修改系统默认打印机的设置，这个网上找就行了；我看有的教程需要安装GSPRINT和Ghostscript，并将其添加到系统环境中，但是我并没有安装也可以（如果有特别要求可能要用到“Ghostscript，GhostView”，比如打印特定的页码，这篇文章有涉及可以参考）；当然也在于在最后查找文件的时候写一些小范围，比如只打印word之类的。 if i.endswith(“docx”)：
print_file(file_path)
2020.10.23
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e459d36ac3835fae6df63322694423b6/" rel="bookmark">
			Linux 教程: （Linux基础&#43;命令大全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Linux 基础 1. Linux 简介 1.1 Linux 简介 Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。
Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。
Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。
文章目录
1 Linux 的发行版2 Linux 应用领域3 Linux vs Windows 1.2 Linux 的发行版 Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。
目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。
1.3 Linux 应用领域 今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e459d36ac3835fae6df63322694423b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01ca93cb2acfc1a89ab1bc54455a4ee5/" rel="bookmark">
			Ubuntu 开机慢的问题排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平常使用虚拟机调试，一般不用的时候都是挂起的，方便下次使用。今天搞了一下配置文件，要重启才能生效，然后就重启了，开机10分钟还没好，惊呆了。
看一下开机启动服务耗时
$ systemd-analyze blame
前 5 项就 7 分钟了，第 20 项还是秒级别的。。。
搭建的测试环境一直叠加，没清除，脑壳痛。
解决方法，可以把一些启动项延后启动，或者把不需要的服务关闭/卸载。
在卸载或停止服务之前要先了解一下这个服务的作用，如果是虚拟机的话可以先快照。
以下就根据我的虚拟机做一些说明，如果有不认识的服务，可以先搜一下，看看作用再处理，不确定的服务建议不要动。
1、networking.service
这是网络服务，不能直接停掉，除非不要网络服务，这里推测是服务启动超时引起的，把超时时间设短一点。
$ sudo vim /lib/systemd/system/networking.service
把 TimeoutStartSec 字段的 5 min 改短，这里把 5 分钟改成 10秒，如下：
保存退出，下一次启动就生效了
2、winbind.service 和 nmbd.service
Samba 服务的组件，Samba 是局域网中共享文件和共享打印机的一种通信协议，共享文件也可以通过 ftp 或 ssh 之类的协议完成，不用 Samba 的话可以卸载掉。
卸载 Samba
$ sudo apt-get remove --purge samba
3、docker.service
docket 容器，测试 web 服务的时候用的
卸载命令
$ sudo apt-get remove --purge docker
4、php7.0-fpm.service
PHP 的进程管理器，PHP 的运行环境，测试 discuz！ 论坛的时候安装的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01ca93cb2acfc1a89ab1bc54455a4ee5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f02064554fed1e5ffd45025035e5dfd5/" rel="bookmark">
			AOP面向切面编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AOP底层使用动态代理：
关于代理模式
AOP（术语） 连接点：类里面的方法可以被增强，这些方法称为连接点
切入点：实际被增强的方法称为切入点
通知（增强)：实际增强的逻辑部分称为通知
通知有五种类型：前置通知、后置通知、环绕通知、异常通知、最终通知 切面：把通知应用到切入点的过程
AOP操作（准备） Spring框架一般都是基于AspectJ实现AOP操作
1.什么是AspectJ？
AspectJ不是Spring组成部分，是一个独立的AOP框架，一般和Spring一起使用，进行AOP操作
2.基于AspectJ实现AOP操作：基于xml配置文件进行实现和基于注解方式实现
3.在项目工程里引入AOP相关依赖
4.切入点表达式：知道对哪个类里面的哪个方法进行增强
语法结构：execution（[权限修饰符][返回类型][类全路径][方法名称]([参数列表]））
例子：execution(* com.keji.service.UserServiceImp.*(…))
导入AspectJ依赖后
代码步骤 方式一：使用原生spring API接口实现AOP（主要是Spring API接口实现） 1、创建接口：
public interface UserService { public void add(); public void delete(); public void update(); public void query(); } 2、创建真实角色：
public class UserServiceImp implements UserService{ public void add() { System.out.println("添加一个用户"); } public void delete() { System.out.println("删除一个用户"); } public void update() { System.out.println("修改一个用户！"); } public void query() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f02064554fed1e5ffd45025035e5dfd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/312fd80d52ef2617b48ce0d3c33b1baa/" rel="bookmark">
			Git操作文件的时候手贱了，怎么恢复？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用git的过程当中很难避免的一点就是手贱，因为人嘛总有犯错疏忽的时候，有时候一不小心就操作错了。我也经常遇到这种情况，所以这时候对git的了解和掌握就非常重要，即使操作错了，我们也可以通过git还原到我们希望它变成的状态。下面我们来看几个例子，来实际体验一下git的强大。
不小心add错了 这是一个非常非常容易出现的问题，我自己也经常遇到。有时候编译出了二进制文件，明明知道是不应该添加进git管理的。因为添加进来之后会使得整个repo变得非常大，别人clone和pull都非常费劲。而且前面也说过了，一旦commit之后，即使你删除了，这份文件依然还是会保存在git仓库当中。
所以如果我们发现不小心把一个我们的测试文件也一起add进来了，我们commit了之后才发现。这个时候应该怎么办？
我们来实际操作一下，比如我们创建了一个叫做a.test的文件用来测试。结果测试完成之后忘记了删除，直接commit了。这个时候我们要把它删除，应该怎么做呢？
我们要做的就是把它删除，有人会说我们直接rm -rf删除不行吗？我们试试看就知道了。
这样删除了之后你会发现它会提示你，说这个改动没有被commit，因为我们只是删除了操作系统当中的文件，并没有删除git仓库当中已经储存的文件。所以只是这样删除了之后，即使我们再次commit提交，git会记录成一次对这个文件的删除操作。虽然我们看不到这个文件了，但是它仍然在git当中占据空间。
所以要删除只能使用git rm命令来进行，它会将文件从git版本管理以及文件系统当中一起移除。当我们提交之后，从下一个提交开始，这个文件就不会被存储一份了。
这里有一个小问题是为什么会从下一个版本开始？因为我们做的事情只是从git中删除掉文件，而不是撤销add文件的操作。所以git当中会记录两条，一条是记录了添加文件，一条是删除了文件。比如说我们在add file的commit当中提交了文件，在delete file的commit当中删除了文件，在delete以及之后的提交当中，是没有这个文件的记录的，但是在add file这个commit当中这个记录仍然存在。
所以问题来了，如果我就想把这个文件从git仓库当中完全删除，一点记录都不留下呢？其实也简单，我们只需要在commit的时候加上–amend参数即可。–amend表示不提交新的commit而是在当前的commit上修补，这样相当于add file和delete file的commit合并成了一个，那么这个文件的记录也就不存在了。
不过使用–amend需要小心，如果记录已经push过远程，会导致和远程的记录不吻合。这个时候需要使用git push -f来强行push。但是强行push会覆盖远程的commit，可能导致其他人代码的混乱，是一个非常危险的操作，请一定谨慎。
只想撤销，不想删除 除了我们不小心提交了本该要删除的内容，还有一种很常见的情况是我们的文件是很重要的，但是我们不想提交到git。比如我们编译出来的二进制文件，它们都是要用到的，只是不应该被push到git而已。我们在add了之后才发现add错了文件，于是我们想要撤销，有办法吗？
比如这个时候我们已经add了文件，但是还没有commit，我们想要把这个a.test文件从暂存区删除，这样就不会被记录下来了。我们应该怎么做呢？
其实很简单，也是通过git rm命令。因为这个时候还没有commit，也就是说这个文件还没有被提交进git仓库当中，我们只需要把它从暂存区移除就可以了。如果使用git rm命令，它既会从暂存区移除，也会从本地删除文件。我们不想删除本地的文件，这个时候我们只需要加上一个参数–cached，表示我们只想移除已经缓存在git暂存区的内容。
我们发现这个文件回到了被add之前的状态。
但假如我们不小心已经commit了，已经提交进git仓库了之后才发现，这个时候应该怎么办？
这个时候我们需要做的是撤销这个commit，给我们一次重新来过的机会。我们使用的命令是git reset --soft HEAD^，git reset命令非常危险，我们操作的时候需要谨慎。如果不小心用了–hard参数会回滚所有的操作，直接恢复到某一个commit时的状态。比如说我们当前在version3，我们回到了version1，如果使用–hard操作的话，version2和version3的所有改动都会丢失。因此一定谨慎使用–hard，最好使用–mixed或者是–soft，它不会修改本地的文件。关于这两个的区别，我们将会以后在介绍git reset命令的时候详细介绍。
这里的HEAD指的是当前git节点的指针，HEAD^表示的是上一个版本。当然我们也可以用commitid来代替。
我们发现一切都恢复到了illustrate unstage commit这个提交之前的状态，那么我们只需要从缓存当中删除a.test，再次提交即可。
这么操作完了之后你会发现在git log当中illustrate unstage commit这个提交不见了。的确如此，因为它被我们撤销了，同样，reset操作也会导致本地和远程状态不一样。如果要push的话也需要-f强制进行，这也是一个危险的操作，一定要谨慎。
撤销修改 加入我们想要撤销的不是一个文件，而是一次修改呢？就比如我们git add了之后才发现某一个文件的修改错了，我们想要把它恢复到之前的状态，这时候应该怎么操作呢？
我们在第五篇里加上了一行废话，但是等我们git add了之后才发现第五篇里有这么一个无用的改动。这时候应该怎么操作呢？
这个时候我们想要做的是撤销这个文件的修改，如果我们只是要把它从暂存区中移除来恢复到git add之前的状态，我们可以使用git reset，但是这个文件当中的修改依然还是存在。这个时候我们可以用一个命令叫做checkout，这个命令有很多种用途，我们先介绍其中的一种。
我们可以使用git checkout – filename来回滚某一个文件的改动，注意这个也是一个危险操作，它会直接将文件恢复到之前提交的状态。中间的改动会全部丢失，因此一定要想好了再操作。在git当中有一个原则，只要是提交过的内容几乎都是可以找回的，而没有提交的内容丢失之后就很难找回了，因此对于这种改变没有提交内容的命令，我们一定要小心。
最后我们来看下效果，我们checkout之后，第五篇文章当中的改动真的消失了。不仅是从暂存区消失了，就连文件本身当中的改动也不见了。
到这里我们常见的几种需要撤销改动的场景以及对应的方法就逗介绍完了，对于新手来说，这些命令应该是非常常用的。虽然其中的一些操作说起来危险，但是只要我们想清楚了再操作，三思而后行，是可以避免悲剧发生的。而且操作危险的命令我感觉更加提升我们的能力，因为小心谨慎会逼迫你加深理解。
好了，今天的文章就到这里，衷心祝愿大家每天都有所收获。如果还喜欢今天的内容的话，请来一个三连支持吧~（点赞、关注、转发）
原文链接，求个关注
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb778a8cb5bce9c03174c110ab19f0f4/" rel="bookmark">
			音频通讯协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		音频常用协议说明 IIS协议 I2S(Inter-IC Sound Bus)是飞利浦公司为数字音频设备之间的音频数据传输而制定的一种总线标准。在飞利浦公司的I2S标准中，既规定了硬件接口规范，也规定了数字音频数据的格式。
特点 效率高主要传输音乐 先传高位再传低位。数据的MSB从LRCLK边沿起延迟1 BCLK主要有三个时钟 主时钟 MCLK 系统时钟，一般是12.288MHz 18.432MHz等 ，一般是位时钟（Bclk）的256倍或384倍位时钟 BCLK（也有叫串行 ） 传输一位数据的时钟周期帧时钟 LRCLK 低电平左声道 高电平右声道串行SDDATA 用二进制补码表示的音频数据其他方式 左对齐 数据的MSB在LRCLK边沿起第一个BCLK上升沿 用的比较少右对齐 数据的LSB靠左LRCLK的上升沿 sony使用这种格式电压（TTL） 输出 VL &lt;0.4V VH&gt;2.4V 输入电压 VIL=0.8V VIH=2.0V IIS标准格式
右对齐模式
左对齐模式
PCM 区别于PCM编码吆，也是种通讯协议，主要传送语音。PCM（PCM-clock、PCM-sync、PCM-in、PCM-out）脉冲编码调制，模拟语音信号经过采样量化以及一定数据排列就是PCM。
源自（https://blog.csdn.net/victory08/article/details/52564814）
特点：
1.先高位后低位
2.左右通道或多通道(tdm模式)依次连接 PDM 声音通过声学传感器获得模拟信号，经过AD，得到音频数字信号，然后再经过PDM(Pulse Density Modulation)脉冲密度调制（通俗理解就是利用脉冲的密度来表示模拟信号的强度）
一般MCU接收到PDM需经过以下步骤才能得到音频信号
传输时只需两根线（clk，data）通常clk在1-3Mhz
SPDIF Sony/Philips Digital Interface 是SONY、PHILIPS数字音频接口的简称。
就传输方式而言，SPDIF分为输出（SPDIF OUT）和输入（SPDIF IN）两种.
就传输载体而言，SPDIF又分为同轴和光纤两种，其实信号是相同的.
S/PDIF往往被用来传输压缩过的音频讯号，它由 IEC 61937标准而定制。
它通常被用在支持杜比技术或DTS 环绕效果的家用DVD影院上。
https://blog.csdn.net/qingfengjuechen/article/details/104696568
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1825299facefb9ddf00e201b822fc044/" rel="bookmark">
			Windows环境使用 PyInstaller 打包python  .py文件 安装和使用教程（保姆级别-小白版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看了大多数文章，对于这个问题的描述 都是介绍不完整，没有展示结果。
一下记录我操作的完整过程供参考：
1，CMD安装环境：
pip install pyinstaller
执行过程：
C:\WINDOWS\system32&gt;pip install pyinstaller Collecting pyinstaller Downloading pyinstaller-4.0.tar.gz (3.5 MB) |████████████████████████████████| 3.5 MB 915 kB/s Installing build dependencies ... done Getting requirements to build wheel ... done Preparing wheel metadata ... done Collecting altgraph Downloading altgraph-0.17-py2.py3-none-any.whl (21 kB) Collecting pyinstaller-hooks-contrib&gt;=2020.6 Downloading pyinstaller_hooks_contrib-2020.9-py2.py3-none-any.whl (163 kB) |████████████████████████████████| 163 kB 328 kB/s Requirement already satisfied: pywin32-ctypes&gt;=0.2.0; sys_platform == "win32" in d:\users\tianya\anaconda3\lib\site-packages (from pyinstaller) (0.2.0) Requirement already satisfied: setuptools in d:\users\tianya\anaconda3\lib\site-packages (from pyinstaller) (49.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1825299facefb9ddf00e201b822fc044/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9414d27ccbd30ce7c8418fe5dcb8d8e/" rel="bookmark">
			H5 画布解决跨域问题，画布保存为图片显示在页面上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现功能：uniapp H5 使用画布，绘画完之后保存为图片全屏显示完整实现代码，跨域解决方案。
跨域图片解决方案一：（使用base64编码）网络图片放到画布里面绘画
跨域图片解决方案二：（使用本地图片）本地图片放到画布里面绘画
一：网络图片跨域方案
注：可以把图片转成base64， 在线转换 下面看代码：
代码解析：avatar 是头像地址，用 pathToBase64 转成 Base64 ， base64_aimg 是 Base64 数据，注意画布保存成图片的大小要写成屏幕大小，屏幕大小获取方式：
onLaunch: function(info) { var that=this; uni.getSystemInfo({ success: function (res) { that.windowWidth =res.windowWidth; that.windowHeight =res.windowHeight; console.log('----this---www',this.windowWidth); } }); //网络状态监听 // network(); console.log('App Launch'); }, 画布相关代码
&lt;canvas style="" canvas-id="myCanvas" id="myCanvas"&gt;&lt;/canvas&gt; canvas { background-color: #fff; border: 1px solid #d0d0d0; width: 100vw; height: 100vh; position: absolute; left: 100%; } &lt;template&gt; &lt;!--pages/poster/poster.wxml--&gt; &lt;view class="page"&gt; &lt;canvas style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9414d27ccbd30ce7c8418fe5dcb8d8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79fbbdf7fa768aa9be303cbb8ad6b694/" rel="bookmark">
			numpy whl_Numpy读写二进制数据和NCL二进制数据I/O
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Numpy读写二进制数据 Numpy.fromfile() numpy.fromfile(file, dtype=float, count=-1, sep='')可以高效读取已知数据类型的二进制文件。file表示文件名，dtype表示数据类型(包括大小和字节顺序)，count表示读入数据长度，sep表示文本文件的分隔符，默认为空表示读取二进制数据。
图片来自《利用python进行数据分析》第二版
&gt;&gt;&gt;type = np.float32
&gt;&gt;&gt;data = np.fromfile(file,dtype=type)
&gt;&gt;&gt;lon , lat = data.reshape(2,2288,2288)
&gt;&gt;&gt; lat
array([300., 300., 300., ..., 300., 300., 300.], dtype=float32)
&gt;&gt;&gt; lat.dtype
dtype('float32')
前面提到数据类型除了包括大小，还包括字节顺序。字节顺序是通过对数据类型预先设定""来决定的。""意味着大端法BigEndian(最重要的字节存储在最小的地址，即高位组放在最前面)。这里读入一个BigEndian数据，并强制转换其类型。
&gt;&gt;&gt; cld = np.fromfile(file,dtype="&gt;f4")
&gt;&gt;&gt; cld
array([nan, nan, nan, ..., nan, nan, nan], dtype=float32)
&gt;&gt;&gt; cld.dtype
dtype('&gt;f4') #BigEndian
&gt;&gt;&gt; t2 = np.dtype(")
&gt;&gt;&gt; cld = cld.astype(t2) #强制转换数据类型
&gt;&gt;&gt; cld.dtype
dtype('float32')
NUmpy.tofile() ndarray.tofile(fid, sep=
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb1dfda777f5748e3fbc2338da9d07b6/" rel="bookmark">
			代理模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代理模式 代理模式中，代理类与主体类实现同样的接口，代理类持有实体类的引用，并接受客户端对代理类中实体引用的外部注入，并代理实体类的功能。
注：描述中的这种外部注入形式有个专有技术名词：依赖注入
静态代理模式 角色 抽象角色：一般会使用接口或者抽象类来解决真实角色：被代理的角色代理角色：代理真实角色，一般会有一些附属操作客户：访问代理对象的角色 优点 可以使真实角色更加集中本身的业务，不用去关注一些公共的业务公共业务交给代理角色，实现业务的分工公共业务发生扩展时，方便集中管理 缺点 每多一个真实角色就会产生一个代理角色：代码量会翻倍，开发效率低
代码步骤 1.接口
public interface UsersService { public void add(); public void delete(); public void update(); public void query(); } 2.真实角色
public class UserServiceImp implements UsersService{ public void add() { System.out.println("添加"); } public void delete() { System.out.println("删除"); } public void update() { System.out.println("修改"); } public void query() { System.out.println("查询"); } } 3.代理角色
public class UserServiceProxy implements UsersService{ private UserServiceImp userService; public void setUserService(UserServiceImp userService) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb1dfda777f5748e3fbc2338da9d07b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56b54abaaa228660aa0cb88a2179df92/" rel="bookmark">
			使用＜line＞标签画虚线 stroke-dasharray讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在 &lt;line&gt; 标签中添加 stroke-dasharray 属性便可以实现虚线样式
但是今天在网上找的时候，发现有些网站给出了错误的代码，把 stroke-dasharray 放到了CSS中，这样自然是没有效果的。
正确的做法是放到标签属性中：
&lt;line stroke-dasharray="5,5"&gt;&lt;/line&gt; 此外，这个属性也可以在例如&lt;path&gt;等连线的标签中使用。
属性讲解 stroke-dasharray 属性的参数是一个array，一下大致展示两种：
stroke-dasharray="5,5" //每画5个像素便空5个像素，两个参数与描述顺序相同 stroke-dasharray="5" //效果同上，如果上面两个参数相同，可以这样简写 效果图：
stroke-dasharray="5,3,9,2" //每画5个像素空3个像素，画9个像素空2个像素，以此循环 效果图：
总的来说，就是按照参数中的数组（如"a, b, c, d"），每画a个像素，空b个像素，接着画c个像素，然后空d个像素，一直循环下去。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f7e083f8c509ab48c7594e960e2ec6c/" rel="bookmark">
			Node.js 中path.join()与path.resolve()的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在写代码的时候有时候使用path.join(__dirname,‘dist’)有时候用path.resolve(__dirname,‘dist’)，都是能拼接出来一个绝对路径，但是具体有什么区别呢？
一、path.join()方法
path.join()方法是将多个参数字符串合并成一个路径字符串
console.log(path.join(__dirname,‘a’,‘b’)); 假如当前文件的路径是E:/node/1,那么拼接出来就是E:/node/1/a/b。
console.log(path.join(__dirname,’/a’,’/b’,’…’)); 路径开头的/不会影响拼接，…代表上一级文件，拼接出来的结果是：E:/node/1/a
console.log(path.join(__dirname,‘a’,{},‘b’)); 而且path.join()还会帮我们做路径字符串的校验，当字符串不合法时，会抛出错误：Path must be a string.
二、path.resolve()方法
path.resolve()方法是以程序为根目录，作为起点，根据参数解析出一个绝对路径
以应用程序为根目录
普通字符串代表子目录
/代表绝对路径根目录
console.log(path.resolve()); 得到应用程序启动文件的目录（得到当前执行文件绝对路径） E:\zf\webpack\1\src
console.log(path.resolve(‘a’,’/c’)); E:/c ,因为/斜杠代表根目录，所以得到的就是E:/c
所以我们一般拼接的时候需要小心点使用/斜杠
console.log(path.resolve(__dirname,‘img/so’)); E:\zf\webpack\1\src\img\so 这个就是将文件路径拼接，并不管这个路径是否真实存在。
console.log(path.resolve(‘wwwroot’, ‘static_files/png/’, ‘…/gif/image.gif’)) E:\zf\webpack\1\src\wwwroot\static_files\gif\image.gif
这个是用当前应用程序启动文件绝对路径与后面的所有字符串拼接，因为最开始的字符串不是以/开头的。
…也是代表上一级目录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a92d9b60862f533c1a10929ca71387c1/" rel="bookmark">
			面试余额宝Java技术岗(1-4面题目)：GC&#43;spring&#43;二叉树&#43;Dubbo&#43;线上调优&#43;​​​​数据库索引&#43;mq
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 余额宝一面 JVM 内存分哪几个区，每个区的作用是什么?JVM有哪些回收算法，对应的收集器有哪些？GC 的两种判定方法 ？CMS 收集器与 G1 收集器的特点。hashmap源码问题HashMap、HashMap如何保证线程安全、ConcurrentHashMapHashMap底层结构 put操作讲一下GC 的两种判定方法 ？CMS 收集器与 G1 收集器的特点。java线程同步都有哪几种方式，在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？cas的原理，变量要用哪个关键字修饰，volatile实现的原理。你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？MYSQL 数据库服务器性能分析的方法命令有哪些?什么是通用 SQL 函数？手撕代码：按层次遍历二叉树？Java 配置的方式配置 Springspring中用到了什么, 简述 AOP 和 IOC 概念,aop是怎么实现的？ 第一轮非常重要，第一面能通过，后续被录用的可能性就比较高了，建议系统性的学习面试题目
余额宝二面 自我介绍&amp;项目项目用 Spring 比较多，有没有了解 Spring 的原理？AOP 和 IOC 的原理分布式锁原理CAS 算法，CAS 与 synchronized 的使用情景简洁描述 Mysql 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？分别解决什么问题？dubbo有哪些模块，底层通信的原理？Dubbo 集群的负载均衡有哪些策略？　如果让你实现一个https，你会怎么实现？常用的负载均衡，该怎么用，你能说下吗？常见的分布式事务方案有哪些？Dubbo 的核心功能？如何从0到1设计一个类似Dubbo的RPC框架？ 余额宝三面 再谈谈一致hash算法(redis)？数据库索引，B+树的特性和建树过程。mysql相关的行锁，表锁；乐观锁，悲观锁分布式锁的方案，redis和zookeeper哪个个好，如果是集群部署，高并发情况下哪个性能更好。activeMQ 发送消息的方式有哪些？activeMQ 如何调优设计模式与重构，谈谈你对重构的理解Collections.sort底层排序方式说说 Redis 哈希槽的概念？Redis 集群如何选择数据库？spring cloud的服务注册与发现是怎么设计的？ 余额宝四面 自己参与的项目，技术难度高的有哪些？线上有实际的性能优化经验？从SQL、JVM、架构、数据库四个方面讲讲优化思路，以及如何优先排序？redis的持久化方式，redis3.0原生集群和redis读写分离+哨兵机制区别如果让你实现一个mq，怎么样保证消息不丢失你熟悉哪些中间件，谈谈你对他们的理解，以及对应的使用场景区别？最后，你有什么想问我的？ HR面 你个人的最大的缺点是什么？在工作中和生活中遇见最大的挑战是什么？是如何克服的？未来有什么规划？平时有哪些兴趣爱好 以上就最新蚂蚁余额宝Java面试题，以下20最新整理出的蚂蚁金服资深Java必考题和答案。
答案获取方式 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51084c8714e9b1ea4f530e5e8f706236/" rel="bookmark">
			python面试题搜集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Python面试题搜集（一） 2019 Python最新面试题及答案16道题吐血总结！50道Python面试题集锦（附答案） Python是目前编程领域最受欢迎的语言。在本文中，我将总结Python面试中最常见的50个问题。每道题都提供参考答案，希望能够帮助你在2019年求职面试中脱颖而出，找到一份高薪工作。这些面试题涉及Python基础知识、Python编程、数据分析以及Python函数库等多个方面。
Q1、Python中的列表和元组有什么区别？
Q2、Python的主要功能是什么？
Python是一种解释型语言。与C语言等语言不同，Python不需要在运行之前进行编译。
Python是动态语言，当您声明变量或类似变量时，您不需要声明变量的类型。
Python适合面向对象的编程，因为它允许类的定义以及组合和继承。Python没有访问说明（如C ++的public，private）。
在Python中，函数是第一类对象。它们可以分配给变量。类也是第一类对象
编写Python代码很快，但运行比较慢。Python允许基于C的扩展，例如numpy函数库。
Python可用于许多领域。Web应用程序开发，自动化，数学建模，大数据应用程序等等。它也经常被用作“胶水”代码。
Q3、Python是通用编程语言吗？
Python能够编写脚本，但从一般意义上讲，它被认为是一种通用编程语言。
Q4、Python是如何解释语言的？
Python在运行之前不需要对程序进行解释。因此，Python是一种解释型语言。
Q5、什么是pep？
PEP代表Python Enhancement Proposal。它是一组规则，指定如何格式化Python代码以获得最大可读性。
Q6、如何在Python中管理内存？
python中的内存管理由Python私有堆空间管理。所有Python对象和数据结构都位于私有堆中。程序员无权访问此私有堆。python解释器负责处理这个问题。
Python对象的堆空间分配由Python的内存管理器完成。核心API提供了一些程序员编写代码的工具。
Python还有一个内置的垃圾收集器，它可以回收所有未使用的内存，并使其可用于堆空间。
Q7、Python中的命名空间是什么？
命名空间是一个命名系统，用于确保名称是唯一性，以避免命名冲突。
Q8、什么是PYTHONPATH？
它是导入模块时使用的环境变量。每当导入模块时，也会查找PYTHONPATH以检查各个目录中是否存在导入的模块。解释器使用它来确定要加载的模块。
Q9、什么是python模块？Python中有哪些常用的内置模块？
Python模块是包含Python代码的.py文件。此代码可以是函数类或变量。一些常用的内置模块包括：sys、math、random、data time、JSON。
Q10、Python中的局部变量和全局变量是什么？
全局变量：在函数外或全局空间中声明的变量称为全局变量。这些变量可以由程序中的任何函数访问。
局部变量：在函数内声明的任何变量都称为局部变量。此变量存在于局部空间中，而不是全局空间中。
Q11、python是否区分大小写？
是。Python是一种区分大小写的语言。
Q12、什么是Python中的类型转换？
类型转换是指将一种数据类型转换为另一种数据类型。
int（） - 将任何数据类型转换为整数类型
float（） - 将任何数据类型转换为float类型
ord（） - 将字符转换为整数
hex（） – 将整数转换为十六进制
oct（） - 将整数转换为八进制
tuple（） - 此函数用于转换为元组。
set（） - 此函数在转换为set后返回类型。
list（） - 此函数用于将任何数据类型转换为列表类型。
dict（） - 此函数用于将顺序元组（键，值）转换为字典。
str（） - 用于将整数转换为字符串。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51084c8714e9b1ea4f530e5e8f706236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2202912f51d7e5dcf2c47dd958cb5be8/" rel="bookmark">
			Linux cp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux cp 命令 Linux 命令大全
Linux cp（英文全拼：copy file）命令主要用于复制文件或目录。
语法
cp [options] source dest
或
cp [options] source… directory
参数说明：
-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。
-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。
-f：覆盖已经存在的目标文件而不给出提示。
-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答"y"时目标文件将被覆盖。
-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。
-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。
-l：不复制文件，只是生成链接文件。
实例
使用指令 cp 将当前目录 test/ 下的所有文件复制到新目录 newtest 下，输入如下命令：
$ cp –r test/ newtest
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e8befb9ba344850c5bf121369437e75/" rel="bookmark">
			【简单搜索】POJ 1321棋盘问题 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		棋盘问题：
题目链接：https://vjudge.net/problem/POJ-1321
在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。
Input：
输入含有多组测试数据。
每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n
当为-1 -1时表示输入结束。
随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。
Output：
对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。
简单的回溯搜索（类似经典的八皇后问题）。
这题要得到方案数，因为找不到任何规律，所以只能去枚举所有可行的情况，并统计个数。而通过搜索来枚举是一种比较高效的办法。
1）首先建立全局的数组来存放棋盘：
int chessboard[10][10]; //0表示不能放棋子 1表示可以 2表示已经放了棋子 棋盘上的点显然有三种可能的状态：
①不能放棋子（即空白区域）
②可以放棋子
③可以放棋子但已经放过棋子了
分别用0，1，2记录棋盘上点的状态
2）写一个check函数来判断某个棋盘上的点能不能放棋子
因为数据量较小，直接遍历整个棋盘看看有没有同一行或者同一列的棋子
bool check(int row,int column){ for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if((row==i&amp;&amp;chessboard[i][j]==2)||(column==j&amp;&amp;chessboard[i][j]==2)) return 0; return 1; } 接着就是递归回溯。
第一个变量row的设置目的是按序搜索以避免答案重复
第二个变量step是为了记录已经放置了几颗棋子，当放了k个就结束搜索，答案++
关于回溯，我是这么理解的：
由于递归函数的性质，当向下一层继续深搜时，函数会“放下”当前的函数，先继续往下一层深搜，等到下一层搜索完毕之后再回到当前的函数。
以这道题为例，我们选择一个地方放置棋子，要对其进行标记，然后向下一层深搜。回溯的意思就是，当返回到当前函数后，解除这个标记。因为递归函数写在for循环的内部，解除该标记后就可以去尝试该行的下一个位置了。
void dfs(int row,int step){ if(step==k){ C++; return ; } else{ for(int i=row;i&lt;=n;i++) for(int j=1;j&lt;=n;j++){ if(check(i,j)&amp;&amp;chessboard[i][j]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e8befb9ba344850c5bf121369437e75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65488d663b569c3b5a546839fadec7ae/" rel="bookmark">
			Python爬虫学习第二章-3-使用requests模块实现破解百度翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python爬虫学习第二章-3-使用requests模块实现破解百度翻译 这一节是使用requests模块进行破解百度翻译
1、在这个案例中不是爬取整张页面，而是爬取部分内容，也就是翻译的结果，所以得需要解析（ajax请求可以进行页面局部的刷新，而在这个案例中，页面恰好是输入单词之后进行局部刷新，所以是ajax请求）， 此时对应的请求是一个post请求，并且此请求携带参数。-响应数据是一组json数据
2、步骤：
在这个案例中，我们需要抓取的是翻译后的结果，也就是一部分页面，所以不能对地址栏中的“https://fanyi.baidu.com/?aldtype=16047#auto/zh”发起请求。对于百度翻译这个页面，每输入一个字符页面都会自动进行部分刷新，这是依靠了ajax的请求，所以说需要通过抓包工具（inspect—&gt;network—&gt;XHR）查看Ajax发送的请求，也就是XHR。通过Request Method可以发现是post请求， 所以需要使用requests.post()方法。（也可以用数据解析方法获取局部数据，后边会介绍）
指定了url之后要紧跟着进行UA伪装，也就是
headers = {‘User-Agent’:‘Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36’}，确保发送请求能够成功。
UA伪装结束之后要进行参数处理，当然如果这个请求没有参数的话，可以不用进行处理，携带的参数可以在最下面的From Data中查看。
然后发送请求，定义一个resonance接收响应数据。
从response中获取数据，在这个案例中服务器响应的是json数据，json方法返回的就是一个字典对象，如果确认响应数据是json类型的，才可以使用json方法， 可以在抓包工具中查看Content-Type确定响应数据的类型。
进行持久化存储,因为响应数据是json对象，字典类型的，所以可以直接存放在json的文本文件当中，得先导入json模块。
3、实现的代码：
''' 步骤：指定url即指定网址进行UA伪装；对当前url发起请求，如get请求；获取服务器响应的数据，如显示的页面数据；将爬取到的响应数据进行持久化存储 -此时不是爬取整张页面，而是爬取部分内容，也就是翻译的结果，所以得需要解析（ajax请求可以进行页面局部的刷新） -此时对应的请求是一个post请求，并且此请求携带参数。 -响应数据是一组json数据 ''' import requests import json if __name__=="__main__": #1、指定url post_url = 'https://fanyi.baidu.com/sug' #这个程序中的url需要从抓包工具中获取Ajax请求的url #2、进行UA伪装 headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36' } #在url之后要紧接着进行UA伪装，也是定义一个headers #3、进行post请求的参数处理，同get请求的参数处理，。post方法的data参数所对应的数据是请求所携带的参数，相当于get请求中的params，也应该是一个字典，封装了url的参数 word = input('enter a word:') data = { 'kw':word } #4、请求发送，post请求发送成功之后也会返回一个响应数据，保存在response中 response=requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65488d663b569c3b5a546839fadec7ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c57a9d47b342e697307ca1d5e65c57d/" rel="bookmark">
			利用js求最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法 Math.max
JavaScript 提供了 Math.max 函数返回一组数中的最大值，用法是：
Math.max([value1[,value2, ...]]) 值得注意的是：
如果有任一参数不能被转换为数值，则结果为 NaN。max 是 Math 的静态方法，所以应该像这样使用：Math.max()，而不是作为 Math 实例的方法 (简单的来说，就是不使用 new )如果没有参数，则结果为 -Infinity (注意是负无穷大) 而我们需要分析的是：
1.如果任一参数不能被转换为数值，这就意味着如果参数可以被转换成数字，就是可以进行比较的，比如：
Math.max(true, 0) // 1 Math.max(true, '2', null) // 2 Math.max(1, undefined) // NaN Math.max(1, {}) // NaN 2.如果没有参数，则结果为 -Infinity，对应的，Math.min 函数，如果没有参数，则结果为 Infinity，所以：
var min = Math.min(); var max = Math.max(); console.log(min &gt; max); 了解了 Math.max 方法，我们以求数组最大值的为例，思考有哪些方法可以实现这个需求。
原始方法
最最原始的方法，莫过于循环遍历一遍：
var arr = [6, 4, 1, 8, 2, 11, 23]; var result = arr[0]; for (var i = 1; i &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c57a9d47b342e697307ca1d5e65c57d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02257c71cf1491910d581cf435e9fb52/" rel="bookmark">
			Excel？最强国产开源在线表格 Luckysheet 走红GitHub！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：Python数据科学
目前比较流行的办公应用主要有Excel、WPS、石墨文档等等。
今天，要和大家推荐一款功能强大、配置简单、完全开源的用纯 JavaScript 编写的前端表格库！
Luckysheet具备了大部分Excel中的常用功能，比如文字与单元格的样式调整与公式的使用等。除此之外还提供了独有的复制时转换格式（比如 json 等）以及其他格式的数据导入导出等，可以说Excel具备的常用功能它也都有了。
此外，因为Luckysheet采用纯JavaScript编写，因此它可以嵌入到任何前端项目或应用程序中，便于实现集成和自动化。不过在图表方面现在只支持了常用的ECharts，其他图表框架需要等待以后陆续支持。
目前，Luckysheet已经在GitHub上标星4.2K，累计分支292。
GitHub地址：https://github.com/mengshukeji/Luckysheet/blob/master/README-zh.md
在线文档：https://mengshukeji.gitee.io/luckysheetdocs/zh/
整体架构
首先我们一起来看看Luckysheet的格式，一个完整的Luckysheet表格文件的数据格式为：luckysheetfile，一个表格文件包含若干个sheet文件，对应excel的sheet0、sheet1等。
一个Luckysheet文件的示例如下，该表格包含3个sheet：luckysheetfile = [ {sheet1设置}, {sheet2设置}, {sheet3设置} ] 相当于excel的3个sheet。
文件中的一个sheet的数据luckysheetfile[0]的结构如下：
{ "name": "Cell", //工作表名称 "color": "", //工作表颜色 "index": "0", //工作表索引 "status": "1", //激活状态 "order": "0", //工作表的顺序 "hide": 0,//是否隐藏 "row": 36, //行数 "column": 18, //列数 "config": { "merge":{}, //合并单元格 "rowlen":{}, //表格行高 "columnlen":{}, //表格列宽 "rowhidden":{}, //隐藏行 "colhidden":{}, //隐藏列 "borderInfo":{}, //边框 }, "celldata": [], //初始化使用的单元格数据 "data": [], //更新和存储使用的单元格数据 "scrollLeft": 0, //左右滚动条位置 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02257c71cf1491910d581cf435e9fb52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcabc8e52b2024be4d493dbdd45dbb42/" rel="bookmark">
			lotus 扇区一致性检测 删除错误扇区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lotus 扇区一致性检测 1，POST提交失败2，检测扇区3，扇区188已经上链3.1 查看扇区故障 4，指定扇区检测 1，POST提交失败 ERROR	storageminer	storage/wdpost_run.go:101	runPost failed: running window post failed: github.com/filecoin-project/lotus/storage.(*WindowPoStScheduler).runPost /root/lotus/storage/wdpost_run.go:599 - sanity check failed lotus-miner proving deadlines 1个扇区错误导致整个deadline 0扇区都提交失败
lotus-miner proving deadline 0 2，检测扇区 导出环境变量 export TMPDIR= export FIL_PROOFS_PARENT_CACHE= export FIL_PROOFS_PARAMETER_CACHE= export RUST_LOG=info export FIL_PROOFS_MAXIMIZE_CACHING=1 export FIL_PROOFS_USE_GPU_COLUMN_BUILDER=1 export FIL_PROOFS_USE_GPU_TREE_BUILDER=1 export BELLMAN_CUSTOM_GPU= ./sector-checker checking --sector-size=32G --miner-addr=矿工ID --storage-dir=存储目录 删除错误扇区，重新检测通过 3，扇区188已经上链 # lotus-miner sectors list | grep 188 188 Proving YES NO 1728645 (in 1 year 24 weeks) CC 扇区cache不是74M，从远程节点拷贝cache的74M替换 store/cache# du -sh * | grep -v 74M 416G s-t矿工-188 查找扇区存储位置 lotus-miner storage find 188 远程矿工目录worker/sealed，从远程节点拷贝sealed的32GB替换store/sealed的扇区 scp s-t矿工-188 root@IP:/cephfs/store/sealed # lotus-miner proving deadline 0 Faulty Sectors: [184 186 188 194] 目录store/sealed # md5sum s-t矿工-184 +69a85eaa6fd28784c634a6bcb1d5984c s-t矿工-184 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcabc8e52b2024be4d493dbdd45dbb42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3fc0ff9044d2e65efd8d6dfc8243edb/" rel="bookmark">
			怎么彻底删除电脑上的软件_1个神器彻底删除流氓软件，瞬间清出十几个G，你的电脑有救了！...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​在使用电脑中，我们总会遇到一些流氓软件，不仅严重拖慢了电脑的运行速度，还不定时地弹出一个又一个的“定时炸弹”，毋庸置疑，这些定时炸弹就是各种烦人的广告和弹窗了。尽管我们通过常规的方式把它卸载，但它还会卷土重来。那么对于那些卸载了仍会有文件残留的，我们如何彻底删除呢？
第一阶段：
1、右键点击软件图标，再点击【打开文件所在位置】，或者【属性】，找到软件的安装位置，找到卸载程序，一般可能是 uninstaller ，双击卸载。
2、完成之后，文件夹里还有残余文件，回到上一目录，再删掉整个软件的安装文件夹。
3、如果删不掉，说明软件还有服务在后台运行；打开【任务管理器】，找到相关程序，点击【结束任务】，再次删除即可。
第二阶段：
如果仍然无法删除，说明你可能没有管理员权限，那么接下来就来到第二阶段了！
1、先在右键菜单上添加一个【获取管理员权限】，找到这个文件，双击，即可添加。
2、然后在要删除的文件夹上单击右键，点击【获取管理员权限】，这样一般都能删除。
第三阶段：
1、回到桌面按下 Win+R 键，调出运行命令窗口，输入 “regedit” 调出“注册表编辑器”。
2、点击顶部的【编辑】-【查找】，输入流氓软件的名称，然后在搜索结果中向上拖动滑块，在 Software 路径下，找到软件的注册表文件夹右键删除即可。
第四阶段：
如果这样都不能彻底卸载掉流氓软件，也可以试试第三方软件，比如 Geek Uninstaller ，Geek Uninstaller无需安装，打开软件找到想要卸载的应用，右键点击卸载即可。
看到这里，你学会了吗？
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/348/">«</a>
	<span class="pagination__item pagination__item--current">349/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/350/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>