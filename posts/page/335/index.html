<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb854982149e077e7d461bec7687f4e0/" rel="bookmark">
			go语言生成自定义uuid_Kettle（PDI）转换中输入步骤之生成随机数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 Generate random value(生成随机数)步骤生成随机数、整数、字符串甚至UUID。
选项介绍 生成随机数
Generate random value(生成随机数)步骤有以下选项：
Step name(步骤名称)：在画布上指定Generate random value(生成随机数)步骤的唯一名称。您可以自定义名称或将其保留为默认名称。
字段 name(名称)：字段的名称。
type(类型)：您想要获取的数据类型。
Random number(随机数字)：生成0到1之间的随机数。
Random integer(随机整数)：生成一个随机的32位整数。
Random string (随机字符串)：生成一个随机的64位字符串。
Universally Unique Identifier (UUID)：UUID。
Universally Unique Identifier type 4 (UUID4)：UUID4。
Random Message Authentication Code (HmacMD5)：HmacMD5。
Random Message Authentication Code (HmacSHA1)：HmacSHA1。
示例 双击输入中的生成随机数，添加一个生成随机数步骤。
然后双击添加的步骤进行编辑。
编辑生成生成随机数
然后在字段中输入一个名称random_uuid，类型为UUID，然后点击确定。
设置生成随机值
然后选中添加的生成随机数步骤，点击右键，选择Preview...，最后点击快速启动，即可预览数据。
预览数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3825c02316e78a0512903b87757d54d1/" rel="bookmark">
			Android studio在线调用华为HarmonyOS系统虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好消息！！做安卓开发的朋友可以直接调用华为HarmonyOS系统的虚拟机了！！
最近不是学习鸿蒙开发么，偶然想鸿蒙这个虚拟机DevDco Studio可以直接调用，那AS是不是也可以直接使用，一试还真可以的~
操作也特别简单！
准备工具：
1、Android Sutdio 2、DevEco Studio（华为HarmonyOS开发工具）
3、华为开发者账号
操作步骤：
1、打开DevEco Studio（没有就先安装，直接官网下载）
2、打开到在线虚拟机管理Tools-》HVD-manager
3、选择需要的虚拟机，比如华为P40（这里选的虚拟机都是鸿蒙（HarmonyOS）系统）
第一次打开会先需要登录华为账号。
登录后，直接运行起虚拟机就可以了！
运行起来后是这个样子：
4、然后就可以打开AS开始愉快的使用了！
是不是超级简单~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71849230b796cdc123c4f4f476bfefa3/" rel="bookmark">
			Kotlin Parcelable 相关 @Parcelize 记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Kotlin 1.4.20 及以后 //独立插件 apply plugin: 'kotlin-parcelize' Kotlin 1.3.60 及以后 //扩展插件 包括 @Parcelize 和 kotlinx.android.synthetic(替代findViewById) apply plugin: 'kotlin-android-extensions' //如果只想启用扩展插件里的 parcelize 功能 androidExtensions { features = ["parcelize"] } Kotlin 旧版本 //扩展插件 包括 @Parcelize 和 kotlinx.android.synthetic(替代findViewById) apply plugin: 'kotlin-android-extensions' //如果只想启用扩展插件里的 parcelize 功能 androidExtensions { features = ["parcelize"] } //需要启用实验室功能 androidExtensions { experimental = true } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b97bb7ce2efa512a00a1f84a7966a132/" rel="bookmark">
			The type java.lang.Object cannot be resolved. It is indirectly referenced from required .class files
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用eclipse 创建java工程写代码时报错：The type java.lang.Object cannot be resolved. It is indirectly referenced from required .class files 1、错误原因： 由于eclipse的默认JDK环境与创建java工程设置的相关JDK环境不同导致。
2、解决方案：将eclipse的默认jdk环境设置为1.8（或者创建工程时版本与default版本对应）即可 创建工程时，选择 configure -&gt; 在弹出窗口选择Compiler-&gt;选择对应的jdk版本 应用即可。
相关图片如下：
图：选择configure JRE
图：选择对应版本
图：成功创建
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c87e86f062b1f7b29bd345d37913274/" rel="bookmark">
			匠心独运: python打造GUI图形小窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人类没有孤独的痛苦 一: 爬取b站弹幕图形化界面设计 hello，大家好，又和大家见面啦，我是python学院的热情好市民，用python能做的事情简直如满天星头，人工智能、爬虫、网站开发、数据分析热门行业都可以用python来做，本夜斗小神社则化身为python树洞，一切相关知识都将背化作养分背夜斗小神社这个树洞汲取！喜欢文章的小伙伴可以点点关注哦！绝对不吃亏，绝对不吃亏！
上一篇文章探索了如何爬取bilibili"守护解放西"的弹幕，流程以及思路！这篇文章我想着能不能设计一个图形化界面来实现交互式爬取，那么首先得自己写一个图形化界面吧，开始动手写代码，用的模块是tkinter模块!
需要注意的事项：
图片必须为gif格式的，剩下按照代码及其注释来即可！导入图片, 注意图片的格式只能为gif格式, 不能够盲目修改后缀, 需要用到ps、格式工厂工具转为gif格式!
import tkinter as tk import webbrowser as wb def csdn_url(): wb.open('https://blog.csdn.net/xtreallydance/article/details/112399856') root = tk.Tk() # 窗口 root.title("爬取b站守护解放西弹幕") # 窗口名称 root.geometry("500x380") # 窗口大小 root.resizable(width=True, height=True) # 窗口可变 # bg为背景，fg为字体颜色，font为字体，width为长，height为高，这里的长和高是字符的长和高，比如height=2,就是标签有2个字符这么高 # 在root窗口上贴一个文本信息为api接口的标签 url_address = tk.Label(root, text="api接口: ", fg='red', font=('宋体', 15), width=12, height=2) # 将api接口地址标签贴在窗体(110, 80)的位置上 url_address.place(x=70, y=55, anchor="nw") # 创建输入框----&gt; 用于输入api地url地址 input_url_address = tk.Entry(root, width=30, show=None, font=('Arial', 12), bg='white') # 布局位置 input_url_address.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c87e86f062b1f7b29bd345d37913274/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e3587033e30648a8cc938e63deb0d95/" rel="bookmark">
			联发科有没有高端处理器_联发科再次发力，天玑820官宣数据惊人，或成中高端最强处理器...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		期待中的神U--联发科天玑820终于正式面世，从各媒体和联发科提供的数据来看：天玑820将可能是同级最强5G性能芯片！
据官方表示，天玑820处理器使用目前较强的7nm工艺制造，且继承了全球最顶尖的5G调制解频器，为搭载的终端带来更好的省电方案、更低的功耗；其搭载了旗舰级多核CPU架构，在性能上将远超同级芯片。同时，天玑820还搭载了高能效的独立AI处理器APU3.0。
性能上，天玑820在多任务处理器方面提升明显
从相关数据来看，天玑820的单核性能相比同类型产品跑分高出了7%，小胜一步；多核性能方面的表现更是高达37%，堪称碾压性的性能提升。从这点来看，足够说明联发科对这颗处理器的打造极为成功。
在AI运算能力上，天玑820 AI运算能力更稳定
多任务处理时，天玑820将可以保证流畅稳定不掉帧的视频播放体验，且拍照品质方面也将大大提升，更好的提升终端设备的拍照水平。
这些表现其实都是得益4 个主频高达2.6GHz 的Cortex-A76核心和4 个主频 2.0GHz 的 Cortex-A55 高能效核心组合，在当下，手机终端的游戏体验已经被作为手机体验的一大重要部分，上游芯片厂家必须在这方面有所建树，而天玑820的表现突出的地方正是其高性能的多和架构部分，结合MediaTek HyperEngine 2.0游戏优化引擎，不仅能加速游戏启动和转场，还可以让游戏满帧运行更稳定。
从天玑1000系列到面向中高端的天玑800，再到这次的天玑820系列，联发科终于在2020进入半程之时揭开了自己的野心，向中高端市场出发。从目前来看，联发科为了抢占制高点，必然会在成本上做出让步，即便首发厂家不能有独占期，但成本上的优势也就意味着首发终端产品将可能在定价上游刃有余。
而这，就是Redmi品牌一直以来都在坚持的“宗旨”之一。
天玑820的首发毫无疑问已经被Redmi拿下，这点从Redmi总经理卢伟冰一直在预热甚至出现作为天玑820的“特邀嘉宾”出席就可见一斑。除了硬件上的能力外，即将首发天玑820、即将成为Redmi在2020年的今天的首款爆款产品--Redmi 10X，它还有哪些底牌没有亮出呢？我们拭目以待！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be0adb92ba7e45fc138e2f16484b9613/" rel="bookmark">
			【Vivado那些事】创建不包含源文件的IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候我们想参考官方的源码，但是有些IP怎么也找不到官方的源码，具体原因是什么呢？
下面从下面两种Vivado创建IP的流程看下具体的原因：
所谓“数字积木”，就是Vivado集成开发环境基于IP的 “积木块”设计思想。
VIvado中IP定制化流程如下：
来源UG896
IP目录将来自下面的IP统一到一个环境中，这些IP包括XilinxIP、第三方IP和用户IP。
基于IP-XACT标准，VivadoIP封装器工具提供了独一无二的“重用”特性。IP封装器为Vivado的任何用户提供了一种能力，即将设计流程任意阶段的一个设计进行封装，然后将该IP作为一个系统级的IP进行使用。
创建不包含源文件的IP
上面建立的IP可以很方便操作一下看到源文件，实际使用过程中IP作为知识产权的成果，设计者并不希望公开IP核的源代码，下面将带你建立一个不包含源文件的IP。
第一步：在操作系统下，执行菜单命令【开始】-【所有程序】-【Xilinx Design Tools】-【Vivado2018】点击【Vivado2018】，启动Vivado集成开发环境。
第二步：在“Vivado2018”主界面下，选择“Create New Project”选项，弹出“New Project-Createa New Vivado Project”对话框。
第三步：单击【Next】按钮，弹出“New Project”对话框。在该对话框中，按如下参数进行设置。
(1)Project name：gateip；
(2)Project location：XXX\test；
(3)选中“Create project subdirectory”前面的复选框。
第四步：单击【Next】按钮，弹出“New Project-Project Type”对话框。在该对话框中，按如下参数进行设置。
(1)选中“RTL Project”前面的复选框；
(2)其他按默认设置。
第七步：单击【Next】按钮，弹出“New Project-Default Part”对话框。在该对话框中,选择器件“xc7k325tffg900-2”。
第八步：单击【Next】按钮，弹出“New Project-New Project Summary”对话框。
第九步：单击【Finish】按钮。
至此，完成新工程的创建。
接下来添加文件
第一步：【Flow Navigateor】-【Add source】按钮
弹出“Add Sources“对话框。在该对话框中，单击【Add or crete design source】按钮，弹出“Add Source Files”对话框。在该对话框中，定位到XXXX\source路径。
在该路径下，选择gate.v文件。可以看到在“Add Sources”对话框中添加了gate.v文件，并且注意下面的设置。
gate.v文件
第六步：单击【Finish】按钮。
第七步：Vivado成开发环境界面左侧的“Flow Navigator”窗口中找到并展开“SYNTHESIS”选项。在展开项中，选择“Run Synthesis”选项，Vivado开始对该设计执行综合过程。
第八步：运行完综合过程后，弹出“Synthesis Completed”对话框。在该对话框中，选择“Open Synthesized Design”前面的复选框。
第九步：自动打开综合后的设计。在Vivado当前设计界面底部的“Tel Console”窗口中输入“write_edif F:/FILE/FPGA/ZYNQ/test/gateip/ip/gate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be0adb92ba7e45fc138e2f16484b9613/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6820ea7caf0332032fe4819122b4760/" rel="bookmark">
			Docker基础介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker 基础介绍 什么是Docker Docker是一种基于Linux内核的,属于操作系统层面的虚拟化技术,是一种环境部署工具,本质就是一个软件.
用来发布网站的
这里提一下VM,Vmware虚拟机是基于硬件(CPU,内存,磁盘)的一种虚拟化技术
Docker图解 Docker的优点 当我们需要搭建环境的时候,如果用传统的方式,每一个环境就需要一个服务器,产生的费用会很高,
那么用Docker来搭建:
可以在一台Linux服务器上搭建多个环境(这里的环境指的就是Docker容器)容器之间的隔离性好只要镜像文件还在,那么就算一个Docker容器死亡,也不会影响其他的容器占用磁盘空间小,速度快(秒级)快速完成配置任务,简化了部署方式提升开发效率应用迁移方便 Docker是比较流行的环境部署方式
Docker 三要素 docker 镜像 一种特殊的文件,负责产生容器,是容器所运行的环境
一个镜像可以生成多个容器
一个容器死亡,其他容器可以继续使用
docker 容器 一个小Linux系统或者说一个小型服务器
docker 仓库 在互联网上用来存放dokcer镜像的地方
docker的安装 yum -y update 升级Linux所有组件(-y表示执行过程中都选yes)yum install -y docker 下载dockerreboot 重启系统 启动docker服务 systemctl start docker 启动docker服务systemctl stop docker 停止docker服务systemctl restart docker 重启docker服务systemctl enable docker 开机自动启动docker服务systemctl disable docker 取消开机自启动docker服务 验证docker服务是否启动 docker version
当有两个docker版本号时(C/S),说明启动服务成功
查看docker版本号 docker -v
docker用户管理 需求:普通用户并没有docker使用权限,需要root用户创建docker组,为普通用户提供docker服务
创建docker组
[sudo] groupadd docker (在root用户下不需要使用sudo,sudo表示以管理员身份运行)
注意:这里的组名必须为docker
将普通用户添加docker组
修改/etc/sudoers配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6820ea7caf0332032fe4819122b4760/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fc1aea933319aed5675ddf60d210a55/" rel="bookmark">
			eda多功能时钟设计_Altera FPGACPLD设计 基础篇&#43;高级篇（附随书光盘）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取方法：
微信公众号：OpenFPGA 后台回复
Altera设计
基础篇介绍
《Altera FPGA/CPLD设计(基础篇)》是王诚、蔡海宁、吴继华编著的一本图书。该书可作为高等院校通信工程、电子工程、计算机、微电子与半导体等专业的教材，也可作为硬件工程师和IC工程师的实用工具书，结合作者多年工作经验，系统地介绍了FPGA/CPL的基本设计方法。在介绍FPGA/CPLD概念的基础上，介绍了Altera主流FPGA/CPLD的结构与特点，并通过丰富的实例讲解Quartus II与ModelSim、Synplify Pro等常用EDA工具的开发流程。
第1章　FPGA/CPLD简介　1
1．1　可编程逻辑设计技术简介　1
1．1．1　可编程逻辑器件发展简史　1
1．1．2　可编程逻辑器件分类　2
1．2　FPGA/CPLD的基本结构　3
1．2．1　FPGA的基本结构　3
1．2．2　CPLD的基本结构　7
1．2．3　FPGA和CPLD的比较　9
1．3　FPGA/CPLD的设计流程　10
1．4　FPGA/CPLD的常用开发工具　14
1．5　下一代可编程逻辑设计技术展望　18
1．5．1　下一代可编程逻辑器件硬件上的四大发展趋势　18
1．5．2　下一代EDA软件设计方法发展趋势　24
1．6　小结　27
1．7　问题与思考　28
第2章　Altera FPGA/CPLD的结构　29
2．1　Altera高密度FPGA　29
2．1．1　主流高端FPGA——Stratix IV E/GX/GT　29
2．1．2　内嵌10Gbit/s高速串行收发器的FPGA——Stratix IV GT　50
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fc1aea933319aed5675ddf60d210a55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d54da6a51d5b8e1418c1e0bdaedbaf3c/" rel="bookmark">
			npm有包却down(下载）不下来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一次使用npm踩坑日记
一次协助开发别的公司的项目，拉下来代码，有一个依赖包死活down不下来，报错是该版本找不到。
No matching version found for vue-superset@1.9.2 npm ERR! notarget In most cases you or one of your dependencies are requesting npm ERR! notarget a package version that doesn't exist. 这里报错指出，npm源里没有找到该包。我马上去npm查看是否有对应版本的包，一查发现这个包是该公司内部人员开发的。
刚开始探索方向错误，以为是node和npm的模块依赖造成的，因为是个人开源的包，所以考虑肯定不是很全面。有可能是作者发布的发包的node和Npm版本和我当前使用的造成的差异（我是使用的是很新的版本）。
之所以会这么想，是因为其他同事都运行正常，而他们的node版本都比我的要老。
于是乎我马上卸载Node，安装nvm切换多个Node版本做测试，最后仍是无果。
直到这里，我的注意力更多的都是集中在Node上
然后我就把注意力转到Npm上，开始尝试cnpm，yarn等，但是仍然无果。
知道我使用nrm查看了源，恍然大悟。我使用了国内淘宝的镜像源。上去淘宝镜像一看，果然这个包最新版本并没有从国外npm的源同步，虽然这个包作者跟新也有很久了，淘宝官方也说每隔10分钟会从cnpm源头同步（这里划重点：是cnpm源头也是他家的，我去了，那cnpm源多久同步还是个问题，所以淘宝镜像没有及时同步npm源上的包也情有可原了…)
最后，切换源到国外npm，成功down包，大功告成！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c156c0bbe39a3ccb95fb435f9f620b08/" rel="bookmark">
			via浏览器下载路径_Via安卓浏览器（软件篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 点击蓝字 默默关注 应用简介 Via浏览器app是一款比悦动小、比UC快的浏览器应用，Via浏览器app支持夜间模式、自定义UA、下载、书签、多标签页浏览、HTML5、flash等，而且体积小巧，用起来很舒服，欢迎大家下载体验。 软件亮点
简单与速度带来的浏览体验，耳目一新。 【简单纯粹】极客清爽设计，干净无打扰。 【极速搜索】毫秒级启动，极速网页加载。 【轻快浏览】小体积，低内存，不卡顿。 【安全隐私】沙盒机制，更少权限，无痕浏览。 【清爽省流】广告拦截，节省流量，专注浏览。 【自定义与扩展】资源嗅探，实用插件，各取所需。 这是官网界面 看看这是手机端，界面非常简洁
极简高效的Via浏览器，清爽极速的网页浏览与搜索体验。不超过一张照片的大小，值得一试。 Via浏览器的进阶玩法有哪些？ 自定义浏览器标识ua；广告标记拦截；下载插件；查看网页源码；资源嗅探；导入导出书签；云同步；隐私防追踪；保存网页；离线网页；翻译网页；网页内查找；有图/无图模式... 欢迎一切反馈和建议，如果觉得好用也欢迎推荐给朋友。 资源不断更新中------
公众号后台回复 via 下载 今天的分享就到这里，我们下期见，拜拜!
点分享 点点赞 点在看 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/971b88c7578cc994060e27b057b0b48e/" rel="bookmark">
			二阶魔方万能还原公式_二阶魔方怎么拼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先随意找一块有白色面的角块放底面，然后看这一块其他两个面的颜色，比如是蓝色，就找蓝色和白色的角块。然后让蓝色对着自己，白色向右手就做右手公式，如果白色向左就做左手公式。右手公式是：右上，打左，右下。左手公式是：左上，打右，左下。
第二步以顶面黄色为例，首先摆好位置，如果顶面没有黄色，把黄色面向左。如果顶面有一个黄色，把黄色角块放左下。如果顶面有两个黄色，把有黄色的侧面对住自己。然后记住这个公式：右上，打左，右下，打左，右上，打左两下，右下。
最后让两块颜色相同的面向自己，然后使用下面的公式：右上，后开水，右上，开水两下，右下，后关水，右上，开水两下，右上两下。开水是指面向自己的一面做顺时针转动90度，两下就是转180度。
还原二阶魔方，分为以下三大步骤：1、还原底层角块。2、还原顶面颜色。3、调整最后一层的角块顺序。实际运用的时候，需要根据实际情况灵活调整。
二阶魔方在还原的时候用到的方法有很多，有面先法、二阶魔方EG、二阶魔方色先法、二阶魔方层先法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4621c0d88736364c5197e9c698587f25/" rel="bookmark">
			QT creator 代码中有中文，提示常量中有换行符解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 提示常量中有换行符 在写qt程序时，经常报错“常量中有换行符”导致无法编译成功。
解决方法 第一步：打开一个项目，工具-选项-文本编辑器，在文本编辑器界面的文本编码地方选择
默认编码选择UTF-8；
UTF-8 BOM选择 如果编码是UTF-8则添加；
做完以上操作后点击应用-OK；
第二步：菜单栏点击"编辑"，选择“select encoding”，在文本编码界面选择 UTF-8,然后点击按编码保存。这一步很重要。
第三步：程序中添加
#pragma execution_character_set("utf-8") 效果： #include "mywidget.h" #include &lt;QPushButton&gt; #pragma execution_character_set("utf-8") myWidget::myWidget(QWidget *parent) : QWidget(parent) { QPushButton * btn=new QPushButton; btn-&gt;setParent(this); btn-&gt;setText("按钮"); QPushButton * btn2=new QPushButton("按钮2",this); btn2-&gt;move(200,0); resize(1000,600); setWindowTitle("第一个窗口"); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc5e892e4033d462b8ee92040d4b7dd8/" rel="bookmark">
			Win10家庭版安装组策略gpedit.msc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win10家庭版安装组策略gpedit.msc ①在桌面右键新建一个文本文件（.txt）
②先复制以下内容
@echo off
pushd “%~dp0”
dir /b %systemroot%\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;gp.txt
dir /b %systemroot%\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;gp.txt
for /f %%i in (‘findstr /i . gp.txt 2^&gt;nul’) do dism /online /norestart /add-package:"%systemroot%\servicing\Packages%%i"
pause
③保存到文本文件，改文件后缀名为（.bat），然后以管理员身份运行一下
耐心等待下载文件就可以了。
后缀名不显示的看这里，看图片提示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2092134150e167f65dc6f8c2260f185a/" rel="bookmark">
			马房山实验报告大学Python大作业——YouTube视频趋势分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		武汉理工大学Python高级程序设计大作业——YouTube视频趋势分析 要求任务描述 源代码main_mac.pyconfig.py 要求 数据来源：https://www.kaggle.com/datasnaek/youtube-new
Kaggle提供的数据集包括4个国家的热门YouTube视频的每日记录。每个国家的数据文件为一个CSV文件及一个JSON文件。
任务描述 ① 绘制每个国家指定列的的top10，如category，channel_title等；
② 统计视频发布后上榜的天数；
③ 查看views, likes, dislikes, comment_count的关系；
④ 按月份统计不同国家发布的视频数量，并用柱状图进行可视化。
以及附加要求中还有关联读写数据库、进行数据清洗等要求。
源代码 代码直接cv过去是无法运行的，有一些关于环境的bug。理解为重，酌情cv。
代码参考：数据分析~案例：YouTube视频趋势分析
main_mac.py 在main_mac.py主程序文件中，虽然使用了MySQL数据库，实现了数据库的读写函数，但是实际上并没有从数据库读取或者写入。各位将读取文件的代码片转换成读取MySQL数据库的函数即可。
若使用MySQL Workbench等数据库GUI工具的话，可以直接通过图形界面将.csv文件和.json文件手动导入数据库中，无需代码导入，程序中只需完成读操作即可。
主程序在计算皮尔逊相关系数时，计算量较大，所花费的计算时间会较长，所以运行时在显示相关系数的图像之前需要等待一段时间。
#-*- coding: utf-8 -*- ''' 由于macOS自带且默认使用Python 2.7，这里声明Python版本以避免某些bug； 或者在终端运行时使用python3。 ''' #! python3 import os import platform import pandas as pd import numpy as np import json import matplotlib.pyplot as plt import seaborn as sns from pyecharts import Bar, Line, Overlap from matplotlib.font_manager import FontProperties # import MySQLdb import pymysql import csv import codecs # 由于我使用纯文本编辑器编写，这里使用pysnooper进行调试 import pysnooper # 导入config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2092134150e167f65dc6f8c2260f185a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08c9cc6232aad0fa3c0495109fab8a0d/" rel="bookmark">
			JavaBean基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 JavaBean就是是符合一定规则的java类
有默认的无参构造函数有一系列读写属性，即属性的setXX()和getXX()方法，对于boolean类型的属性允许拥有isXX()需要被序列化并且实现了 Serializable 接口。 使用 在JSP的脚本标识中使用就和普通Java一样
&lt;% Bean tmp = new Bean(); //tmp.setXX("VALUE"); //tmp.isXX(); //tmp.getXX(); %&gt; 与JSP的动作标识结合使用
&lt;jsp:useBean id="" class="" scope="page|request|session|application"/&gt;，id为javabean实例名，class必须为类的完整包名， scope为作用域，默认为page，即当前页面。先在对应scope中寻找有没有重名的实例，如果有返回该实例的引用，否则初始化一个新的javabean
&lt;jsp:setProperty property="" name="" value=""/&gt;，为javabean实例的属性赋值，property为属性名，name为实例名，对应上面的id，value为所赋的值
&lt;jsp:getProperty property="" name=""&gt;，获得实例对应属性值
使用setProperty时，value的值可以是①字符串②表达式。如value="&lt;%=new Date()%&gt;"为字符串时，该值会自动转化为JavaBean属性相应的类型，为表达式时，该表达式的计算结果必须与所要设置的JavaBean属性的类型一致。
如果使用&lt;jsp:setproperty name="Test" property="*"&gt;，如
&lt;jsp:useBean id="user" class="com.caut.bean.Bean"/&gt; &lt;jsp:setProperty property="*" name="user"/&gt; &lt;!-- 或 --&gt; &lt;jsp:useBean id="user" class="com.lyq.bean.User"&gt; &lt;jsp:setProperty property="*" name="user"/&gt; &lt;/jsp:useBean&gt; 代表自动匹配客户端传来的所有参数，即request.getParameter可以获取到的值。
JavaBean中的静态成员变量 考虑下面的例子
package com.lyq.bean; //计数器 public class Counter { private static int count = 0;//注意这里的static public int getCount(){//这里不能用static，否则JSP无法调用 return ++count; } } &lt;body&gt; &lt;jsp:useBean id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08c9cc6232aad0fa3c0495109fab8a0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c1f52895553705522dc544dbda3df4c/" rel="bookmark">
			数学分析第一章第二章知识点概要
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数学分析
第一章：实数集与函数
第二章：数列极限
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ea70f1ec34fcc4f6bd02a4abc610e75/" rel="bookmark">
			文件下载 Content-Disposition中filename中文乱码解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 通过链接直接下载2. 通过数据流下载 1. 通过链接直接下载 后端代码：
response.setCharacterEncoding(StandardCharsets.UTF_8.name()); // 字符集编码 response.setContentType("application/octet-stream"); // 返回内容的MIME类型 response.addHeader("Content-disposition", "attachment;filename=" + fileName + ";filename*=UTF-8" + fileName); // 内容描述 response.addHeader("Access-Control-Allow-Origin", "*"); // 实现跨域 /** * 编码格式转换 * * @param request 请求 * @param pFileName 文件名称 * @return String * @throws UnsupportedEncodingException */ private String encodeChineseDownloadFileName(HttpServletRequest request, String pFileName) throws UnsupportedEncodingException { String filename; String agent = request.getHeader("USER-AGENT"); if (null != agent) { if (-1 != agent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ea70f1ec34fcc4f6bd02a4abc610e75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/194a09a67f6dcca004a0ad8f17085566/" rel="bookmark">
			go语言中获取本机sid、mac地址和cpuid的方法（windows系统下有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在平常工作中可能会遇到需要获取本机mac地址或cpuid的场景，综合网上的办法，亲自试验总结如下：
1.如果只是要查本机sid地址，则很简单，直接在cmd命令窗口中输入命令：
whoami /user 回车即可
2.如果需要在程序中获取mac地址和cpuid，则可以参考以下代码：
package main import ( "fmt" "net" "os/exec" "regexp" ) func main() { var ( mac string cpuid string ) mac = getMac() cpuid = getCpuId() fmt.Println("mac:" + mac) fmt.Println("cpuid:" + cpuid) } func getMac() string { // 获取本机的MAC地址 interfaces, err := net.Interfaces() if err != nil { panic("Poor soul, here is what you got: " + err.Error()) } inter := interfaces[0] mac := inter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/194a09a67f6dcca004a0ad8f17085566/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/411e5a786346eb4498fe474c09b00b96/" rel="bookmark">
			监控摄像头接入流媒体服务器的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要接入流媒体服务器 我们知道，在一些小的应用场合，如社区、中小企业、商超店铺等，布置监控系统并不需要流媒体服务器，直接将摄像头接入硬盘录像机即可。
但是，在一些大型应用场合或一些新型应用场景中，需要将监控视频进行多级传送或远程传送，譬如我们熟知的雪亮工程、明厨亮灶、智慧城市、工业科技园区等，这时流媒体服务器的作用就显得比较突出了。
监控摄像头接入流媒体服务器，一是可以进行长期的、弹性的进行视频存储、查阅和分析使用，二是可以方便的进行多级分发、远程传输和集成到其他业务平台，并且可以在多种终端中调取播放。
监控摄像头接入流媒体服务器的方式 监控摄像头接入流媒体服务器一般有三种方式：
1）使用监控厂家自己的流媒体服务器。这种方式通常要整体采用某一家监控厂商的设备，配置和部署起来比较省事。存在的问题是技术和协议相对封闭，后期扩展性差，无法兼容其他品牌设备，也很难集成到其他业务系统中，用途比较单一，缺少灵活性。
2）使用通用流媒体服务器，采用国际标准ONVIF接入。这种方式优势是大家都采用通用的国际标准，扩展、互通、集成都比较方便，市面上的绝大多数摄像头都支持该规范。缺点是进行视频的多级互联和远程传输的灵活性性对较差，譬如要想将本地摄像头的视频传输到远程，一般需要在本地部署代理设备，增加了实施成本。
3）使用通用流媒体服务器，采用国标GB28181接入。该标准的最新版本是GB/T 28181-2016，用于规范视频监控的信息传输、交换、控制等细节，目前国内主流摄像头也都支持该规范。 使用该规范的优势是，摄像头可以主动连接到远程流媒体服务器平台，能够方便的实现视频的远程传输和多级传输。
总结 总结一下，对于采用ONVIF协议和GB28181标准的流媒体服务器平台具有规范、灵活、易扩展等特点，能够满足新型互联网应用，譬如远程视频监控、多终端分发、业务集成、视频级联传输等。
通常，ONVIF协议适合在一张大局域网中使用，摄像头有固定的IP地址，流媒体服务器可以主动获得摄像头的IP地址并进行注册和接入。GB28181更适合跨网传输和多级传送，譬如远程控制和调用某个局域网中的摄像头，只要摄像头可以接入外网即可，不需要摄像头有固定的IP地址。
ONVIF协议是流媒体服务器主动去连接摄像头，然后进行控制或视频调取，因此在组网时需要流媒体服务器能够访问到摄像头的IP地址。GB28181是摄像头主动向上级平台连接注册，摄像头不需要有固定的外网IP，只要求流媒体服务器有固定的IP地址即可。
支持GB28181的流媒体服务器包括： NTV Media Server G3 和 SRS4，支持ONVIF的包括NTV Media Server G3。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7261096adab7f9a8940f0179abade75/" rel="bookmark">
			1亿数据 redis 内存_redis 数据内存占用分析实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、查看单个redis key占用的空间 -- redis-memory-for-key -s ${host} -p ${port} key_name
redis-memory-for-key -s 10.1.213.170 -p 9002 test 如果redis是用的集群，找到key的槽位所在的节点，port用对应的节点即可。
二、统计redis key 占用及分布
a、第一步：拉取 rdb 二进制文件(rdb文件既redis的db文件)
redis-cli -c -h ${ip} -p ${port} --rdb ${d}.${ip}.${port}.rdb b、解析 rdb 文件为文本，格式内容为：
rdb -c memory ${rdbfile} &gt; ${redkfile} // 解析后redkfile文件的格式 database,type,key,size_in_bytes,encoding,num_elements,len_largest_element c、 awk 统计key的内存分布 (需要预先配置前缀与描述，如果没有统计到的会打印出来)
detail.sh ${redkfile} &gt; ${statfile} 附上脚本 detail.sh
#!/bin/sh filename=$1 cat ${filename} | awk -F ',' ' BEGIN{ total=0; indice["trash"]="测试分类 test@test@test"; for (k in indice) { split(indice[k], ks, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7261096adab7f9a8940f0179abade75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4423e928af94fe0c31b1c723f0805068/" rel="bookmark">
			Linux系统  为什么新增的磁盘无法使用，需要挂载？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于挂载的作用一直不是很清楚，今天在阅读教材时看见了mount这个命令，发现它的用处很隐晦但非常强大。奈何教材说的不明朗，因此在网上整合了一些优秀的解释，看完之后豁然开朗。
提一句Windows下，mount挂载，就是给磁盘分区提供一个盘符（C,D,E,...）。比如插入U盘后系统自动分配给了它I:盘符其实就是挂载，退优盘的时候进行安全弹出，其实就是卸载unmount。
Linux下，不像Windows可以有C,D,E,多个目录，Linux只有一个根目录/。在装系统时，我们分配给linux的所有区都在/下的某个位置，比如/home等等。
插入了新硬盘，分了新磁盘区sdb1。它现在还不属于/。
我们虽然可以在一些图形桌面系统里找到他的位置，浏览管理里面的文件，但在命令行却不知怎么访问它的目录，比如无法使用cd或者ls。也无法在编程时指定一个目录对它操作。
这时提问者使用了 mount /dev/sdb1 ~/Share/ ，把新硬盘的区sdb1挂载到工作目录的~/Share/文件夹下，之后访问这个~/Share/文件夹就相当于访问这个硬盘2的sdb1分区了。对/Share/的任何操作，都相当于对sdb1里文件的操作。
所以Linux下，mount挂载的作用，就是将一个设备（通常是存储设备）挂接到一个已存在的目录上。访问这个目录就是访问该存储设备。
linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。
我们不是有/dev/sdb1 吗，直接对它操作不就行了？这不是它的目录吗？
这不是它的目录。虽然/dev是个目录，但/dev/sdb1不是目录。可以发现ls/dev/sdb1无法执行。/dev/sdb1，是一个类似指针的东西，指向这个分区的原始数据块。mount前，系统并不知道这个数据块哪部分数据代表文件，如何对它们操作。
插入CD，系统其实自动执行了 mount /dev/cdrom /media/cdrom。所以可以直接在/media/cdrom中对CD中的内容进行管理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/534863000d4343cd40883ac6c02b8029/" rel="bookmark">
			Java并发编程（九）JUC原子操作类（原子基本数据类型、原子数组、原子引用类型、原子更新字段类型）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原子操作类 在并发编程中很容易出现并发安全的问题，有一个很简单的例子就是多线程更新变量i=1,比如多个线程执行i++操作，就有可能获取不到正确的值，而这个问题，最常用的方法是通过Synchronized进行控制来达到线程安全的目的。但是由于synchronized是采用的是悲观锁策略，并不是特别高效的一种解决方案。实际上，在J.U.C下的atomic包提供了一系列的操作简单，性能高效，并能保证线程安全的类去更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。atomic包下的这些类都是采用的乐观锁策略去原子更新数据，在java中则是使用CAS操作具体实现。
https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/atomic/package-summary.html
我们将按照下面四大类依次讲解：
原子基本数据类型原子数组原子引用类型原子更新字段类型 1.1 原子基本数据类型 种类 atomic包提供原子更新基本类型的工具类，主要有这些：
AtomicBoolean：以原子更新的方式更新boolean；AtomicInteger：以原子更新的方式更新Integer;AtomicLong：以原子更新的方式更新Long； AtomicInteger常用的方法:
addAndGet(int delta) ：以原子方式将输入的数值与实例中原本的值相加，并返回最后的结果；incrementAndGet() ：以原子的方式将实例中的原值进行加1操作，并返回最终相加后的结果；getAndSet(int newValue)：将实例中的值更新为新值，并返回旧值；getAndIncrement()：以原子的方式将实例中的原值加1，返回的是自增前的旧值； 原理 public final int getAndIncrement() { return unsafe.getAndAddInt(this, valueOffset, 1); } 可以看出，该方法实际上是调用了unsafe实例的getAndAddInt方法，unsafe实例的获取时通过UnSafe类的静态方法getUnsafe获取：
private static final Unsafe unsafe = Unsafe.getUnsafe(); Java中Unsafe类详解
java不能直接访问操作系统底层，而是通过本地方法来访问。Unsafe类提供了硬件级别的原子操作，主要提供了以下功能：
1、通过Unsafe类可以分配内存，可以释放内存；2、可以定位对象某字段的内存位置，也可以修改对象的字段值，即使它是私有的；3、挂起与恢复
将一个线程进行挂起是通过park方法实现的，调用 park后，线程将一直阻塞直到超时或者中断等条件出现。unpark可以终止一个挂起的线程，使其恢复正常。整个并发框架中对线程的挂起操作被封装在 LockSupport类中，LockSupport类中有各种版本pack方法，但最终都调用了Unsafe.park()方法。4、CAS操作 Unsafe类在sun.misc包下，Unsafer类提供了一些底层操作，atomic包下的原子操作类的也主要是通过Unsafe类提供的compareAndSwapInt，compareAndSwapLong等一系列提供CAS操作的方法来进行实现。
atomicInteger借助了UnSafe提供的CAS操作能够保证数据更新的时候是线程安全的，并且由于CAS是采用乐观锁策略，因此，这种数据更新的方法也具有高效性。
AtomicLong的实现原理和AtomicInteger一致，只不过一个针对的是long变量，一个针对的是int变量。而boolean变量的更新类AtomicBoolean类是怎样实现更新的呢?核心方法是 compareAndSet 方法，其源码如下：
public final boolean compareAndSet(boolean expect, boolean update) { int e = expect ? 1 : 0; int u = update ? 1 : 0; return unsafe.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/534863000d4343cd40883ac6c02b8029/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f2fc1dd7ede1df30a25e1702be56f52/" rel="bookmark">
			教大家一个免费复制粘贴百度文库文字的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		教大家一个免费复制粘贴百度文库文字的方法 chrome浏览器装个翻译插件就行了，把要复制的文字框选出来，点一下翻译，然后设置里面调中文-》中文，在复制就ok了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/218146b8cc6d78a48b474cb546ef5def/" rel="bookmark">
			MySQL（三）MySQL-5.7.20 主从复制实战（半同步复制、过滤复制、GTID模式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL-5.7.20二进制主从复制实战（半同步复制、过滤复制、GTID模式） 文章目录 MySQL-5.7.20二进制主从复制实战（半同步复制、过滤复制、GTID模式）一、半同步复制半同步复制的原理半同步复制先决条件半同步复制实战加载sync插件查看插件启动半同步重启从库IO线程查看是否运行 二、过滤复制复制的过滤主要有２种方式复制的优化：下面二项需要在Master上设置：下面六项需要在slave上设置：主从过滤的注意事项：主从复制过滤复制先决条件主从复制过滤复制实战添加配置文件白名单参数重启3308实例查看过滤复制的信息 三、GTID模式GTID优势GTID的限制GTID的工作原理GTID的使用GTID原理pos 与 GTID 有什么区别？GTID模式主从复制实战开启binlog日志与GTID授权重启3306与3309实例查看是否开启GTID创建主从复制用户开启GTID主从复制查看主从复制状态测试GTID模式主从复制效果查看结果 一、半同步复制 半同步复制的原理 半同步复制时，为了保证主库上的每一个Binlog事务都能够被可靠的复制到从库上，主库在每次事务成功提交时，并不及时反馈给前端应用用户，而是等待其中的一个从库也接收到Binlog事务并成功写入中继日志后，出库才返回commit操作成功给客户端。半同步复制保证了事务成功提交后，至少有两份日志记录，一份在主库的Binlog日志上，另一份在至少一个从库的中继日志Relay log上，从而更近一步保证了数据的完整性。
半同步复制先决条件 前文已经有二进制多实例主从复制的文档，本文档不再从新开启主从复制，如果没有开启请点击：二进制主从复制
在做半同步复制前请保证开启了主从同步
半同步复制实战 加载sync插件 [mark_d]注意：主库与从库加载的插件不是同一个！！！[/mark_d]
[root@mysql-manager ~]# mysql -S /opstands/mysql-3307/mysql.sock -e "install plugin rpl_semi_sync_master soname 'semisync_master.so';" [root@mysql-manager ~]# mysql -S /opstands/mysql-3308/mysql.sock -e "install plugin rpl_semi_sync_slave soname 'semisync_slave.so';" 查看插件 [root@mysql-manager ~]# mysql -S /opstands/mysql-3307/mysql.sock -e "show plugins" |grep rpl_semi_sync rpl_semi_sync_master	ACTIVE	REPLICATION	semisync_master.so	GPL [root@mysql-manager ~]# mysql -S /opstands/mysql-3308/mysql.sock -e "show plugins" |grep rpl_semi_sync rpl_semi_sync_slave	ACTIVE	REPLICATION	semisync_slave.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/218146b8cc6d78a48b474cb546ef5def/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c097091f08c0fb02fb46cdbb4b2753ca/" rel="bookmark">
			你真的理解c&#43;&#43;中初始化和赋值这两个概念吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谈一谈我对c++中初始化和赋值的理解 要想说明白这个初始化和赋值的差别，就不得不说到这个构造函数。构造函数是c++面向对象开发中十分重要的一个特性，对构造函数理解的深入，有助于我们对语言底层的工作的了解，同时也会帮助我们看懂他人比较复杂的代码。
正文： ​ 为什么本文要讲初始化和赋值的差别通过构造函数来进行解释说明呢，我们先来回顾一下《c++ primer》上的一句话，这句话出自书的2.2（P39）:
在c++语言中，初始化是一个异常复杂的问题，我们已将反复讨论这个问题，很多程序员对于用=来初始化变量的方式倍感困惑，这种方式容易让人认为初始化是赋值的一种。事实上在c++语言中，初始化和赋值是两个完全不同的操作。
​ 为什么在c++中初始化和赋值是两种不同的操作呢？如果没有学过c++的构造函数以及拷贝构造函数，我相信大多数人都很难理解这两者有哪些区别。通过下面几个例子，也许你能明白为什么是有区别的。
例子1
对变量进行初始化：
/* c++ 11关于初始化有4种方式 int units_sold = 0; int units_sold = {0}; int units_sold {0}; int units_sold (0); 为了与后文相对应，方便读者理解，这里我们选择第四种初始化方式 */ int a(10); //创建一个变量a，数据类型为int整型，并对a进行了初始化，值为10 对变量a进行赋值：
a = 0; //给变量a赋值，a现在的值为0 通过这个例子，你能看出初始化和赋值的差别了吗？（如果没有，别着急，继续往下面看）
例子2
定义一个属于自己的类（class），类的名称叫做my_int:
class my_int { public: //构造函数 my_int() = default; //默认构造函数 my_int(const int&amp; num) { m_num = num; //接受一个int参数的构造函数 } //成员变量 int m_num; }; 用刚刚定义的my_int类去实例化一个对象
my_int b(10); //创建一个对象b，数据类型为my_int，并对b进行了初始化，值为10 对 对象b的值进行修改
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c097091f08c0fb02fb46cdbb4b2753ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1892da0f090827398ca1d67d54f06c6/" rel="bookmark">
			国外云服务器有哪些?国外云服务器大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国外云服务器有哪些?通常被我们所称为国外云服务器是除中国大陆云服务器之外的其它国家和地区的云服务器，比如：美国云服务器、韩国云服务器、日本云服务器等，那么你知道常见的国外云服务器有哪些吗?下面我们就聊聊国外云服务器大全都有哪些国家的云服务器：
一、美洲云服务器
美洲云服务器以美国云服务器举例说明。美国云服务器是香港云服务器之外中国大陆用户使用最多的免备案云服务器。美国云服务器主要优势在于资源丰富，比如IP、带宽规模等。为什么美国云服务器的资源多呢?这个主要归根于IPv4根服务器，在全球一共有着13台IPv4根服务器(1台主根服务器和12台辅根服务器)，其中有9个根服务器在美国(包括主根服务器)，欧洲2个(位于英国和瑞典)，亚洲一个(位于日本)。所以说美国云服务器具有得天独厚的IP和带宽资源。
二、东亚地区的云服务器
东亚地区云服务器主要包括日本云服务器和韩国云服务器。日本是亚洲唯一一个拥有IPv4根服务器的国家，所以在亚洲地区日本云服务器具有一定资源优势。韩国网络是属于全球较好的，网络线路很快，韩国机房的硬件设施也很好，中国大陆访问韩国云服务器的时延较低。但是韩国云服务器的致命缺陷在于其DDoS处理能力较弱，并且沟通不变，问题处理效率较低。
国外云服务器有哪些?国外云服务器大全
三、东南亚地区的云服务器
由于中国大陆与东南亚地区的互联网经济往来。很多外贸企业对东南亚地区的云服务器有一定需求。很多云计算服务商也在东南亚布点，布点地区包括新加坡、菲律宾、柬埔寨、越南、马来西亚、泰国以及南亚的印度。
1、新加披云服务器：新加坡地区的网络速度较快，与韩国网络一样，是全球十大高速网络架构之一，承载着东南亚地区大部分第三方数据中心存储量，同时拥有大量的出口带宽，不管时连接国内还是欧洲地区访问速度都很快。主要拥有大量的出口带宽资源。
2、菲律宾和柬埔寨云服务器：1、柬埔寨的云服务器拥有足够的带宽资源，带宽不分国际与本土，内容限制少、免备案，适合各类交易与网游、页游平台。行业内都明白柬埔寨和菲律宾地区都是BC、DB天堂，政策管理宽松，访问速度和服务器稳定方面也比较可靠，所以成为很多灰色领域的行业选择。
3、越南云服务器：在东南亚地区中，服务器属新加坡与越南服务器最受欢迎，但与新加坡相比，在资源与全球网络线路的速度方面也没办法比较，越南服务器的网络线路只在于东南亚地区访问比较快速，访问欧美地区还是不足。不过越南服务器的优势在于有着充足的带宽与宽松的政策。
4、马来西亚云服务器：马来西亚云服务器支持稳定快速访问的地区有东南亚、澳洲与新西兰等地，从服务器速度稳定方面来看要比韩国、日本服务器更稳定，且不亚于香港与美国服务器，马来西亚服务器优势在于速度稳定、国际带宽资源多以及内容限制较少，版权要求不严，且带宽不分国际与本土区别。
5、泰国云服务器：服务器线路非常稳定，带宽不分国际与本土，访问速度则支持东南亚与中国，适合做网游。
6、印度云服务器：印度云服务器与新加坡云服务器无法相比，它既不是全球十大高速网络架构之一，也没有任何资源优势，印度云服务器优势只在于廉价，免备案与较为稳定的速度。
四、欧洲地区的云服务器
欧洲地区的云服务器非常繁杂，法国、意大利、德国、英国、荷兰、俄罗斯、比利时、土耳其、波兰、西班牙、瑞士、捷克、立陶宛、马其他、保加利亚与塞浦路斯等地区均有云服务器分布等。
五、非洲地区的云服务器
非洲地区云服务器较少，物理服务器更多，包括埃及服务器、南非服务器等。
除去IPv4根服务器之外，在2016年的雪人计划中，由IPv4系统架构基础中建立的25台IPv6根服务器，中国部署了4台IPv6根服务器(1台主根服务器和3台辅根服务器)、美国1台主根与2台辅根服务器、日本1台主根服务器、印度3台辅根服务器、法国3台辅根服务器、德国2台辅根服务器、俄罗斯、意大利、西班牙、奥地利、智利、南非、澳大利亚、瑞士、荷兰各1台辅根服务器。
以上就是国外云服务器有哪些、国外云服务器大全，除中国大陆和中国香港等，所有国外、海外地区的服务器，其中亚洲地区，东南亚地区与美洲地区的美国服务器为重点介绍，主要是介绍国内用户使用较多海外云服务器的地区，由以上可以看出，选择使用国外云服务器主要因素在于国外服务器内容限制少、免备案、价格便宜或者资源充足等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/041a1e72bc92504a47460bb5b0ab93ac/" rel="bookmark">
			ubuntu安装python-pcl点云库、open3d库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pcl点云库在C++中经常使用，而在python python-pcl集成了pcl库中的一部分功能，本文给出python-pcl库在Ubuntu16.04中的安装教程
python-pcl 0.系统准备 申请Ubuntu系统开发机，anaconda配置教程如前述文章 https://blog.csdn.net/qq_38742161/article/details/110921649 1.pcl安装 sudo apt-get install libpcl-dev pcl-tools 2.python-pcl安装 pip install python-pcl 3.其它报错case case1: python-pcl安装后 import报错：ImportError: libpcl_keypoints.so.1.7 。重新执行上述第一步进行pcl安装。
case2：version incompatible：版本限制，本人将python3.7改成python3.6即可。
open3d pip install --user open3d-python
sudo apt-get install libglfw3-dev
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da719827829e7d4500776775ffb97f62/" rel="bookmark">
			前端面试几个基础知识自查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.JS中使用typeof能得到的哪些类型？ &lt;script&gt; // 基本数据类型 // number类型 var num = 1; console.log(typeof num);//返回的是number // string 类型 var str = 'jack'; console.log(typeof str);//返回的是string // boolean类型 var boo =true; console.log(typeof boo);//返回的是boolean // undefined类型 var und ; console.log(typeof und);//返回的是undefined // null类型 var nul =null; console.log(nul); //返回的是null // 可以得出：基本数据类型返回的是自己对应的类型 // 复杂数据类型 // Array类型 var arr = new Array(); console.log(typeof arr); //返回的是object // function类型 var fn = function(){}; console.log(typeof fn); //返回的是function // Object类型 var obj = new Object(); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da719827829e7d4500776775ffb97f62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5c3583bfcc51de4ee921b5679a092cc/" rel="bookmark">
			发送验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$(function() { var init = function() { $('.draw').click(function() { if (examine()) { examineask(); } }) } var btnMsg = "获取验证码", countNum = 60, countFlag = false, intervalTimer = {}; var examine = function() { var phone = $('.phone').val(); if (phone == '') { mui.toast('手机号不能为空', { duration: 'long', type: 'div' }); } else if (!(/^1[3456789]\d{9}$/.test(phone))) { mui.toast('手机号码不正确', { duration: 'long', type: 'div' }); } else { return true; } } var examineask = function() { if (countNum == 60) { countDown(); } else { mui.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5c3583bfcc51de4ee921b5679a092cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b06418d58f1523db491ce6debfb1be56/" rel="bookmark">
			判断拐点的条件_全球危机之中，如何判断拐点的出现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我们现在面对的是一场严重的全球性疫情、社会、金融、经济危机。有专家将这称为一场百年一遇的危机，或许从破坏性来还达不到百年一遇，因为有二战在。但从其特殊性来看，全球社会都被迫部分停摆，甚至可能大规模停摆，确实可以称为百年一遇。因为这场危机是由新冠疫情引发的，同时发生的金融风暴、经济危机都是疫情的并发症，所以疫情发展是关键。如果想要预判这次危机可能的严重性，预判何时会出现拐点，那么就必须先预判疫情的发展走势。 一、疫情的拐点疫情好了，一切才可能好。中国，暂时走出病房，但世界还在感染。目前欧洲和美国是两大疫情重灾区。他们的疫情发展，决定了全球的大势。我个人认为，如果要战胜疫情，在疫苗和特效药出来之前，常规医疗是不能胜任的。防止疫情大规模扩散唯一有效的方法已经在中国和韩国得到验证，就是严格的阶段性社会隔离和良好的社交和卫生习惯。简单来说，就是 宅家+外出口罩+不聚集+洗手。 欧美疫情何时能出现拐点，必须依靠隔离措施的效果。目前各国都已经采取了一定程度的隔离措施(具体力度不详)，能否起作用，只能通过观察其后期的新增确诊数量猜测了。意大利是欧洲最先严重受灾的国家，也是最早采取隔离和停工措施的国家，在3月8日开始宣布陆续进入全国隔离状态，采取的措施先是严控出入境、限制出行、禁止聚集、关闭公共场所，3月23日开始大规模停工。虽然执行的力度有所不足，但随着疫情的恶化，力度也逐渐在加强。 我准备将意大利作为预判欧洲疫情发展的一个头号观测点。如果意大利疫情出现好转信号，同样也能鼓舞欧洲的各国坚持下去。从3月初疫情爆发以来，到3月20日单日新增确诊人数突破5000人，只用了20天。但目前看来意大利已经连续10天新增人数稳定在5000-6500人区间，暂时停止了继续升高的趋势。考虑到3月8日开始采取全国隔离措施，可以暂时认为控制疫情得到了一点进展。不过，也不排除检测力量有限的原因。除非在下一阶段新增数据下降到3000-4000区间，明显小于已确认的检测能力时，那时可以认为意大利疫情得到初步控制。 参考看一下德国，新增数据依然在震荡上升阶段。由于德国具备强大的医疗体系，所以我认为目前新增人数不受检测能力影响，较为可信。 德国3月18日配合欧盟宣布限制非欧盟人员旅游入境，20日开始限制聚集，并关闭一些公共商业场所，但并没有大规模停工，也没有限制人们出行。当然，目前已经有一些大型公司主动停工了。德国采取的措施力度是小于意大利的，效果也有限，所以德国的疫情继续处于扩散中。 虽然有中国样本在先，但是很多国家不愿付出经济损失的成本代价，所以就在尝试各种半隔离措施能否延缓疫情的爆发，只要控制在一个可忍受的范围都行。目前我们尚不清楚何种程度的措施是合适的且必须的，中国模式是肯定有效，但有没有其他折中方案呢？目前不少欧洲国家都属于半隔离措施范围。 我将德国列为半隔离国家观察样本，看看这种力度的措施对控制疫情的效果如何。 如果德国目前的措施依然无法阻止感染人数大增，估计后来还是得采取更全面的措施。 如何判断疫情好转的信号呢？ 1、如果理想状况下，意大利新增确诊人数会在现有平台持续一段时间后，开始出现向下的拐点，降到3000-4000左右的区间，并持续10天以上时间。这是第一信号，希望能在4月份见到这一幕。 2、也许意大利新增确诊人数还没出现下降，但出院人数增长到与新增持平，现存病例数开始见顶，这也是好的信号。 3、当意大利疫情在未来1-2个月内出现好转(换成法国、德国、西班牙等其他欧洲大国也行)，无疑会大大鼓舞西方国家的信心，各国抗击疫情的措施会更有力，疫情有望在陆续得到控制。 4、如果时间拖得太长，那么就算新增确诊人数开始有所下行，但由于数量太庞大，疫情仍不能轻易认为好转。比如说日增达到数万，甚至更多，那么可控性就大大降低。 目前还是有一个积极信号在隐现，就是意大利作为受灾最先的国家，但由于执行隔离措施较其他国家力度要大，时间要早，所以目前新增确诊人数最高的时候是6557人。而疫情爆发要晚一些的德国、西班牙，新增确诊人数反而最高达到8000-9000以上。或许，这是隔离措施产生效果的一个信号吧。 当然，就算出现了第一个好转信号，也要防止变数： 1、相关国家提前放松隔离措施，导致疫情反复。 2、由于疫情持续太久，破坏性太强，相关国家医疗系统崩溃，社会动荡，经济崩溃，最后导致疫情失控。 一般来说，如果欧美疫情在接下来4-5月份控制住，还是在社会可接受范围之内。但如果拖太久，或规模过大，就会超出承受力。 目前还没有任何可信的特效药消息，对于瑞德西韦，我表示信心不足。从2月5日开始700人临床至今，如果对多数病人有效果，就算还没有完成后面的安全性和副作用论证，也应该有消息出来。我也知道新药研发必须严格严谨的流程和态度，但是现在世界的危机程度不亚于世界大战，每一天都有多少万人被感染，每一天可能都有数千人死去，你难道还要跟我说什么没走完正规流程吗？难道就不能特事特办，不能扩大同情用药范围吗？来个万人大规模再临床行不行？来个几万例同情用药行不行？前方战火连天，你还要等研究员写完研究报告等待领导盖章签字批准了才救人吗？ 我只知道，在战场上骨头断了可以用树枝木板绑上，肚子打破了用皮带勒住，总不能因为没有正规的医疗手续和条件，就不救人吧。 特效药如果没有，那么只能等疫苗了。目前估计疫苗最快能在今年年底和明年年初上市，希望能顺利一点。 二、金融危机和经济衰退 假如跨过了疫情这道坎，也不意味着危机过去，因为疫情诱发的金融危机和经济衰退还在等着我们。 1、如果全球疫情能短时间内被控制住，目前各方可接受的时间是4-5月见顶，随后夏季收尾或者降低到比较低水平，那么对经济和金融系统的伤害可能主要集中在3、4、5月，世界咬咬牙也还能挺过去，下半年经济逐步修复，倒也算万幸。 2、如果疫情无法在短期内见顶，然后以较坏的情况维持到下半年，那么经济遭受的伤害就可能是难以在短期内弥补的。甚至有些经济个体因为长期的停工失血过久已经坏死，造成不可逆伤害，就算疫情结束也无法恢复活力，这才是最严重的情况。由此还可能造成社会动荡、国际冲突，金融系统也会受到致命的伤害。 3、还有一种情况，也许疫情能在两个月内见顶，但是扩散规模已经非常大，感染过千万，死亡百万，那么对整个社会的伤害也是无法承受的。这样的伤害可能需要更长的恢复期，短期内经济衰退和金融危机也无法恢复。甚至，这场危机会往更深力度演化。 因此，判断经济衰退和金融危机何时出现拐点，则不能简单以疫情拐点来判断，还要结合疫情的时间跨度和对世界伤害程度，以及整个世界综合因素来判断。 这是一场人类的灾难，有不少人将此称为第三次世界大战。虽然现在只是一场传染性疾病，但我们目前无法预估它会不会将人类社会拖入可怕的深渊。这或许是我们今生至今为止遇到最大的一次考验，最大的一次危机。 我现在只能期盼，奇迹快点到来！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccbe6fb3b34cca95aa99081c60991f44/" rel="bookmark">
			LeetCode 787.K站中转内最便宜的航班
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeetCode 787.K站中转内最便宜的航班 有 n 个城市通过 m 个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。
现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到从 src 到 dst 最多经过 k 站中转的最便宜的价格。 如果没有这样的路线，则输出 -1。
示例 1：
输入:
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 1
输出: 200
解释:
城市航班图如下
从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。
示例 2：
输入:
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccbe6fb3b34cca95aa99081c60991f44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a6bc6aafa1074a1ae302238e835b487/" rel="bookmark">
			MySQL多实例安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
多版本多实例
单版本多实例
问题解决
创建mysql用户及组
root@localhost:~$ groupadd mysql root@localhost:~$ useradd -g mysql mysql root@localhost:~$ passwd mysql Changing password for user mysql. New password: BAD PASSWORD: The password is shorter than 8 characters Retype new password: passwd: all authentication tokens updated successfully. root@localhost:~$ su - mysql mysql@localhost:~$ pwd /home/mysql mysql@localhost:~$ 多版本多实例 以tar包方式为例，首先上传MySQL的压缩包格式安装包
mysql@localhost:~$ ls mysql-8.0.22-el7-x86_64.tar.gz mysql-5.7.26-el7-x86_64.tar.gz mysql@localhost:~$ tar -xvf mysql-8.0.22-el7-x86_64.tar.gz mysql@localhost:~$ tar -xvf mysql-5.7.26-el7-x86_64.tar.gz mysql@localhost:~$ mv mysql-5.7.26-el7-x86_64 mysql-5.7.26 mysql@localhost:~$ mv mysql-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a6bc6aafa1074a1ae302238e835b487/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90f289a0b28b7ea1cd082c6de52866ab/" rel="bookmark">
			安卓dts音频解码_互联网场景化的未来：DTS:X Ultra带来最佳声效体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声音技术的发展，将世界斑斓的感官意识带到了我们身边。
最初将声音运用到荧屏之中，是作为一种辅助元素去吸引观众。但随着技术的不断更迭，声音所发挥的作用远远超过预期，成为了我们日常娱乐不可缺少的组成部分。
生活中，我们可以用自由的声音探索交流，用坚定的声音去触碰思想，更可以用音乐独特的声音拉近灵魂……颠覆传统，DTS:X Ultra玩转黑科技能够在声音中衍生沉浸式的试听技术，给人们带来真正“身临其境”的娱乐体验，是企业长期创新研发的精神与目标。作为全球音频领域的专家，DTS推出了前所未有、适应多场景的沉浸式声音体验技术——DTS:X Ultra。喜好电影，或是对音频技术比较关注的消费者会发现，DTS:X Ultra的命名来自于DTS的另一项技术DTS:X，该技术是开放式的新一代编解码标准，同时也是基于声音对象的多维空间音频技术，主要面向电影和高端家庭娱乐领域。
而DTS:X Ultra则是基于心理声学和HRTF技术的新版演算法，主打游戏和移动领域，能够依据游戏环境来处理耳机和扬声器设备中输出的音频。也就是说，当我们玩游戏时，譬如在大热的绝地求生游戏时，DTS:X Ultra能够根据我们所处的游戏环境，在做出射击等动作时，对游戏的音效进行优化调整，让游戏里的声音听起来更加逼真自然。
DTS一直深耕音频技术领域。就拿沉浸式声音体验场景来说，传统的音频技术厂商一般专注于开发与电影、家庭娱乐等场景有关的音频技术，而DTS在占据了电影和高端家庭娱乐领域绝对优势的情况下，仍试图通过游戏、移动端等多种娱乐领域的外延，进一步扩大沉浸式音频技术的多元化应用场景。
因此，DTS:X Ultra在技术性和功能创新两个方面都颠覆了传统的音频技术，例如：
相比以前传统的音频技术，DTS:X Ultra可以加入到游戏电脑、手机、平板等多种移动设备，支持耳机和内置的扬声器、空间3D音频，包括对Microsoft Spatial Sound(微软空间音效)框架的支持。这意味着我们不仅可以在获得DTS:X Ultra认证的电脑、手机等设备中用到这项技术，只要是Windows 10用户也能够使用。
在经过半年的内部测试，DTS已更新了Windows 10商店中的应用程序，所提供的DTS:X Ultra技术支持所有Windows 10用户使用，用户只需在Windows 10的应用商店中下载DTS Sound Unbound插件后即可使用。DTS Sound Unbound除了支持DTS:X Ultra，还能够解码DTS:X，在内容条件的支持下，给消费者呈现出沉浸式的声音体验。
除了兼容性更强，DTS:X Ultra系统还搭载了6种内容模式，以及500副以上的耳机数据库、个人聆听资料编辑“自定义音频”模式。通过内容自动侦测，可以创建8种个性化声音体验，实现定制化的声音聆听体验。
简单来说就是我们打开DTS:X Ultra系统后，可以选择自己喜欢的声音模式，比如我们追美剧看科幻电影，可以选择提升人声/对白的清晰度；DTS:X Ultra的数字技术可以将人声分离出来进行优化，不用在剧情复杂的场景中，用户非要竖起耳朵或者调高音量才能听的清楚。例如科幻美剧《西部世界》主角在大风中的沙漠中与人对话，打开DTS:X Ultra系统进行选择后，就能及时听到此类场景下清晰的人声效果，让用户可以感受到影视剧视听方面所呈现的最佳演绎效果。
另外，DTS:X Ultra还专为小型扬声器设计，能显著提升音量、增强低音并有效防止失真，为耳机和扬声器线路提供扬声器保护和失真抑制。具体就是在我们玩游戏、看电影、听歌时，DTS:X Ultra的补偿算法会对手机或电脑的扬声器进行声场技术调校，在减少其他杂音出现时，还能享受到立体饱满的真实声场体验。
目前主流的电脑厂家(包括Acer, Asus, Asus ROG, Gigabyte)都有大量电脑和主板等产品支持DTS:X Ultra这一技术。
以ASUS TUF Gaming F15/ F17系列的笔记本电脑为例。在笔记本电脑的Windows10搜索框中输入[DTS:X Ultra]，并点击[打开]选项。通过屏幕上的[电源按钮]可关闭/开启 DTS: X Ultra音效，并同时显示目前播放音频的装置。
同时，页面上有6种模式可供消费者选择，每种模式都可以针对不同的使用环境进行优化，包括特定的游戏环境 (如战略、RPG 角色扮演、射击游戏等)。玩家可依据个人喜好自行设定，如更改虚拟音场类型或个人听力差异的补偿设定等，通过定制化设定满足最佳个人聆听感受。
不仅如此，DTS:X Ultra还秉承了DTS一贯的黑科技，能够以用户为中心，透过重新创建近场和远场的音域，利用游戏所提供的相关数据在指定位置呈现完整的空间音效。
开启DTS空间3D音效，解锁游戏新姿势
什么是空间音效？简单来说，声音是充满各种先进技术的领域，人脑可以通过对声音位置的判断，以一种特定的方式解释听觉信号，对所处环境形成一个认知轮廓，从中辨别自己所处的位置。
然而，世界上大多数声音都是复杂多样的，除了声音的位置，分贝大小、声音传播轨迹等都会影响到人们对周围环境的清晰认知。而空间音效能直接将环绕声道精准对准合适的方位，环境音会根据人的移动而移动，创造出超现实的沉浸式3D音效体验。
这意味着玩家使用DTS:X Ultra时，可以通过沉浸模式的3D渲染，听到身临其境的环绕音效，享受到更加震撼和逼真的娱乐体验。
这个功能主要应用于游戏和娱乐中，而且只需要一副耳机或内置的扬声器即可。过去要想体验到沉浸式的3D音效，至少需要5.1或7.1这样的多个外接音箱设置。如今，使用电脑或者移动设备，利用空间音效和适当配件，就可以根据软件中交互式的场景、声源变化而输出相应变化的音效，增强游戏和影音场景下的听觉体验。
声音作为游戏中不可或缺的重要部分，在游戏中有着极强的表现力，应用也不尽相同。一款游戏的成功离不开声音的支持，拟真的音效能够辅助游戏画面强化场景真实性，让玩家产生强烈的代入感。
试想一下，玩游戏时戴着耳机随意移动位置或扭动头部，耳机里的声音随之发生变化，仿佛身处一个真实的三维场景中。在DTS:X Ultra的帮助下，玩家可以占据一手先机。熟练的玩家在游戏过程中仅凭轻微的声响或技能音效，就能精确定位危险所在，甚至是找到对手的所在位置。通过对危险的感知和敌方的动作进行预判，玩家可以调整走位或转换战术，从而在对战中取得胜利。
要实现沉浸式体验的输出，免不了需要其他硬件产品的支撑。将相关技术集成到移动设备上，并对其进行优化协调也是一个更大的难题，而DTS的解决办法是与移动设备的主流厂家和产品进行紧密合作，打通产业链上下游的各个环节，形成一个以DTS声音技术为核心的完整音频生态圈。
打造音频生态圈，给世界呈现最好的声音
从成立至今，DTS始终致力于为世界呈现更好的声音。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90f289a0b28b7ea1cd082c6de52866ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f02bb867a8e3f51200610ce668678668/" rel="bookmark">
			Winsock库学习2-服务器端编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为服务器创建套接字 所述的getaddrinfo函数被用来确定该值的sockaddr结构
AF_INET用于指定IPv4地址族。SOCK_STREAM用于指定流套接字。IPPROTO_TCP用于指定TCP协议。AI_PASSIVE标志指示调用者打算在对bind函数的调用中使用返回的套接字地址结构。当设置了AI_PASSIVE标志并且getaddrinfo函数的nodename参数为NULL指针时，套接字地址结构的IP地址部分对于IPv4地址设置为INADDR_ANY或对于IPv6地址设置为IN6ADDR_ANY_INIT。27015是与客户端将连接到的服务器关联的端口号。 #define DEFAULT_PORT "27015" struct addrinfo *result = NULL,hints; ZeroMemory(&amp;hints, sizeof (hints)); hints.ai_family = AF_INET; hints.ai_socktype = SOCK_STREAM; hints.ai_protocol = IPPROTO_TCP; hints.ai_flags = AI_PASSIVE; // Resolve the local address and port to be used by the server iResult = getaddrinfo(NULL, DEFAULT_PORT, &amp;hints, &amp;result); if (iResult != 0) { cout &lt;&lt; "WSAStartup failed:" &lt;&lt; iResult &lt;&lt; endl; WSACleanup(); return 1; } 为服务器创建一个名为ListenSocket的SOCKET对象，以侦听客户端连接。
SOCKET ListenSocket = INVALID_SOCKET; 调用套接字函数，并将其值返回到ListenSocket变量。对于此服务器应用程序，请使用调用返回的第一个IP地址获取与addsinfo参数（在hints参数中指定的地址），套接字类型和协议相匹配的getaddrinfo。在此示例中，使用IPv4的地址族，SOCK_STREAM的套接字类型和IPPROTO_TCP的协议请求了IPv4的TCP流套接字。因此，为ListenSocket请求了一个IPv4地址。
如果服务器应用程序希望侦听IPv6，则需要在hints参数中将地址族设置为AF_INET6 。如果服务器要同时监听IPv6和IPv4，则必须创建两个监听套接字，一个用于IPv6，另一个用于IPv4。这两个套接字必须由应用程序分别处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f02bb867a8e3f51200610ce668678668/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20e79d3f4e0ff167189849105576ddb1/" rel="bookmark">
			Arduino Uno 实验15——MQ-135 气体传感器模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MQ-135 气体传感器模块简介(空气质量检测 有害气体检测) MQ135气体传感器所使用的气敏材料是在清洁空气中电导率较低的二氧化锡(SnO2)。当传感器所处环境中存在污染气体时，传感器的电导率随空气中污染气体浓度的增加而增大。MQ135气体传感器对氨气、硫化物、苯系蒸汽的灵敏度高，对烟雾和其它有害气体的监测也很理想。这种传感器可检测多种有害气体，是一款适合多种应用的低成本传感器。
主要用途：家庭和环境的有害气体检测装置
主要芯片：LM393、MQ-135气体传感器
不同气体的型号选择 使用步骤： ①将配套程序下载到相应的开发板中。
②将串口线和模块接入开发板，给开发板上电。
若选择DOUT,TTL高低电平端，输出信号可以直接接单片机IO口或者接一个NPN型三极管去驱动继电器，电位器RP在这里用于调节输出电平跳变的阀值，当传感器检测到被测气体时，比较器LM393管脚2点的电压值，跟传感器检测到气体的浓度成正比，当浓度值超过电位器RP设定的阀值时，比较器2脚的点位高于3脚的点位，这个时候，比较器1脚输出低电平，LED灯亮，R3为LED灯限流电阻，C1为滤波电容。传感器输出低电平，反之，当没有信号的时候，传感器输出高电平，等于电源电压。
若选择AOUT，模拟量输出，那样就不用管电位器了，直接将AOUT脚接AD转换的输入端或者，带有AD功能的单片机，就可以了。根据我们的经验：在正常环境中，即：没有被测气体的环境，设定传感器输出电压值为参考电压，这时，AOUT端的电压在1V左右，当传感器检测到被测气体时，电压每升高0.1V，实际被测气体的浓度增加20ppm（简单的说：1ppm=1mg/kg=1mg/L=1×10-6 常用来表示气体浓度，或者溶液浓度。），根据这个参数就可以在单片机里面将测得的模拟量电压值转换为浓度值。注意：如果您是用来做精密仪器，请购买市场上标准的校准仪器，不然存在误差，因为，输出浓度和电压关系的比值并非线性，而是趋于线性。
③让传感器先预热一分钟。
④把传感器放入含有敏感气体的装置中，模块上的信号指示灯点亮。 把传感器从敏感气体装置中取出，模块上的信号指示灯熄灭。
MQ-135 气体传感器模块的使用 实验一：模拟值和数字值读取 项目要求： 直接读取数字信号和模拟信号的数值。
电路搭建 参考程序 int mqPinDO = 2; int mqPinAO = A0; void setup(){ pinMode(mqPinDO,INPUT); pinMode(mqPinAO,INPUT); Serial.begin(9600); } void loop() { int mqDValue =digitalRead(mqPinDO); Serial.print("mqDValue ="); Serial.println(mqDValue); int mqAValue =analogRead(mqPinAO); Serial.print("mqAValue ="); Serial.println(mqAValue); delay(200); } 实验结果 实验二：未完成 说明:
根据上面手册说明，还与环境的温度和湿度有关，
/**************************************************************************/ /*! @file MQ135.cpp @author G.Krocker (Mad Frog Labs) @license GNU GPLv3 First version of an Arduino Library for the MQ135 gas sensor TODO: Review the correction factor calculation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20e79d3f4e0ff167189849105576ddb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc663afb319f0df9c02abf39c3f7c1b/" rel="bookmark">
			如何避免Puppeteer被反爬
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路 避免Puppeteer的浏览器特征被检测
即去掉 “webdriver” in navigator 特征
方法1 await page.setUserAgent( "Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5") await page.evaluateOnNewDocument('() =&gt;{ Object.defineProperties(navigator,' '{ webdriver:{ get: () =&gt; false } }) }') await page.goto('http://abc.com/') 方法2 await page.goto('http://abc.com/') await page.evaluate(""" () =&gt;{ Object.defineProperties(navigator,{ webdriver:{ get: () =&gt; false } }) } """) 方法3 browser = await launch({'headless': True, 'args': [ '--disable-extensions', '--hide-scrollbars', '--disable-bundled-ppapi-flash', '--mute-audio', '--no-sandbox', '--disable-setuid-sandbox', '--disable-gpu', '--disable-web-security', '--disable-infobars', ], 'ignoreDefaultArgs': ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dc663afb319f0df9c02abf39c3f7c1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85deb1e7b188c28b88c9584ad33316df/" rel="bookmark">
			计算机网络——链路层与局域网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链路层概述 链路层提供的服务 成帧：在每个网络层数据报经链路传送之前，几乎所有的链路层协议都要将其用链路层帧封装起来。链路接入：媒体访问控制（Medium Access Control，MAC）协议规定了帧在链路上传输的规则。对于点对点链路，MAC协议比较简单，即无只要链路空闲，发送方就能够发送帧。对于广播链路，多个节点共享一个链路，使用MAC协议协调多个节点的帧传输。可靠交付：当链路层协议提供可靠交付服务时，它保证无差错地经链路层移动每个网络层数据报。差错检测和纠正：当帧中的一个比特作为1传输时，接收方结点中的链路层硬件可能不正确地将其判断为0反之亦然。流量控制：当帧到达接收节点的速率大于其处理速率，接收方缓冲区产生溢出，帧会丢失。 链路层服务于运输层服务的区别 运输层在端到端的基础上为两个进程之间提供服务。
链路层为一条链路相邻的两个节点之间提供服务。
链路层在何处实现 链路层的主体部分是在网络适配器中实现的，网络适配器有时也称为网络接口卡。位于网络适配器核心的是链路层控制器，该控制器通常是一个实现了许多链路层服务（成帧、链路接入、差错检测等）的专用芯片。因此，链路层控制器的许多功能是用硬件实现的。
在发送端，控制器取得了由协议栈较高层生成并存储在主机内存中的数据报，在链路层帧中封装该数据报（填写该帧的各个字段），然后遵循链路接人协议将该帧传进通信链 路中。
在接收端，控制器接收了整个帧，抽取出网络层数据报。如果链路层执行差错检 测，则需要发送控制器在该帧的首部设置差错检测比特，由接收控制器执行差错检测。
差错检测技术 奇偶校验 发送方只需包含一个附加的比特,选择它的值,使得这D+1个比特中1的总数是偶数（偶校验）。对于奇校验方案，选择校验比特值使得有奇数个1 。
二维奇偶校验方案（差错纠正），包含比特值改变的列和行的校验值都将会出现差错。因此接收方不仅可以检测到出现了单个比特差错的事实，而且还可以利用存在奇偶校验差错的列和行的索引来实际识别 发生差错的比特并糾正它！
检验和 同UDP检验和计算：
发送方的UDP对报文段中的所有16比特字的和进行反码运算， 求和时遇到的任何溢出都被回卷。得到的结果被放在UDP报文段中的检验和字段。
循环冗余监测（CRC） CRC编码操作如下。考虑d比特的数据D，发送结点要将它发送给接收结点。发送方和接收方首先必须协商一个r+1比特模式，称为生成多项式，我们将其表示为G。我们将要求G的最高有效位的比特（最左边）是1。
对于一个给定的数据段发送方要选择r个附加比特，并将它们附加到d上,使得得到的d+ r比特模式（被解释为一个二进制数）用模2算术恰好能被整除。用CRC进行差错检测的过 程因此很简单：接收方用G去除接收到的 比特。如果余数为非零，接收方知道 出现了差错；否则认为数据正确而被接收。
所有CRC计算采用模2算术来做，在加法中不进位，在减法中不借位。这意味着加 法和减法是相同的，而且这两种操作等价于操作数的按位异或(相同为0，不同为1)。
能检测小于r+1位的突发差错、任何奇数个差错。
多路访问链路和协议 如何协调多个发送和接收结点对一个共享广播信道的访问，这就是多路访问问题。
所有结点同时接到多个帧；这就是说，传输的帧在所有的接收方处碰撞了。通常，当碰撞发生时，没有一个接收结点能够有效地获得任何传输的帧；在某种意义下，碰撞帧的信号纠缠在一起。因此，涉及此次碰撞的所有帧都丢失了，在碰撞时间间隔 中的广播信道被浪费了。
我们能够将多路访问协议划分为3种类型之一：信道划分协议, 随机接入协议和轮流协议。
多路访问协议应该具有以下所希望的特性：
当仅有一个节点发送数据时，该节点具有R bps的吞吐量当有M个节点发送数据时，每个节点吞吐量为R/M bps。这不必要求M个节点中的每一个节点总是有R/M的瞬间速率，而是每个节点在一些适当定义的时间间隔内应该有R/M的平均传输速率协议是分散的，这就是说不会因为某个节点故障而使整个系统崩溃。协议是简单的，使实现不昂贵。 信道划分协议 时分多路 TDM将时间划分为时间帧，并进一步划分每个时间帧为N个时隙。然后把每个时隙分配给N个结点中的一个。无论何时某个结点在有分组要发送的时候，它在循环的TDM帧中指派给它的时隙内传输分组比特。 通常，选择的时隙长度应使一个时隙内能够传输单个分组。
频分多路 FDM将R bps信道划分为不同的频段（每个频段具有R/N带宽），并把每个频率分配给N个结点中的一个。因此FDM在单个较大的R bps信道中创建了N个较小的R/N bps信道。FDM也有TDM同样的优点和缺点。它避免了碰撞， 在N个结点之间公平地划分了带宽。然而，FDM也有TDM所具有的主要缺点，也就是限制一个结点只能使用R/N的带宽，即使当它是唯一一个有分组要发送的结点时。
码分多址 CDMA对每个结点分配一种不同的编码。然后每个结点用它唯一的编码来对它发送的数据进行编码。如果精心选择这些编码，CDMA网络具有一种奇妙的特性，即不同的结点能够同时传输，并且它们各自相应的接收方仍能正确接 收发送方编码的数据比特（假设接收方知道发送方的编码），而不在乎其他结点的干扰传输。
随机接入协议 ALOHA（不重要） 时隙ALOHA协议要求所有的结点同步它们的传输，以在每个时隙开始时开始传输。第一个ALOHA协议实际上是一个非时隙、完全分散的协议。在纯ALOHA 中，当一帧首次到达，结点立刻将该 帧完整地传输进广播信道。如果一个传输的帧与一个或多个传输经历了碰撞，这个结点将立即（在完全传输完它的碰撞帧之后）以概率p重传该帧。否则，该结点等待一个帧传输时间。 在此等待之后，它则以概率P传输该帧，或者以概率1-P在另一个帧时间等待（保持空闲）。
CSMA 载波侦听多路访问
传送前先监听，如果信道空闲，传送整个分组。如果信道忙就延迟传送。
特点：
发送前监听，可以减少冲突。
由于传播时延的存在，仍有可能出现冲突，并造成信道浪费。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85deb1e7b188c28b88c9584ad33316df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48df463787f4e1ae7c40c3296d9f010d/" rel="bookmark">
			SpringBoot集成Flowable modeler设计器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 SpringBoot整合Flowable
flowable GitHub仓库：
https://github.com/flowable/flowable-engine
下载源码，或者git clone
找到 modules/flowable-ui-modeler/flowable-ui-modeler-app 模块，拷贝该模块下resource/static/目录下的所有内容至自己项目的resource/static/目录下。
注意：一定要注意源码版本要与项目中的flowable一致，否则会有资源文件获取不到
这里我复制到了 static/modeler/ 目录下
然后启动项目，访问其中的index页面：
http://localhost:10001/modeler/index.html（根据情况修改访问路径）
官方提供首页：
发现少了点东西，f12检查
与官方对比下发现，路径中多了静态资源目录 modeler
我们找到static/modeler/scripts/app-cfg.js 这个文件，做下修改
FLOWABLE.CONFIG = { 'onPremise' : true, 'contextRoot' : "", 'webContextRoot' : "", 'datesLocalization' : false }; 重启访问index.html
路径是对了，但是还是404错误，account请求是获取登录用户信息的，我们可以实现这个请求，返回一个内置用户，去除登录逻辑；
在项目中全局查找/app/rest/account，在static/modeler/scripts/configuration/url-config.js文件中定义的，我们将请求路径修改一下
参考官方modeler的响应
@RestController @RequestMapping("/modeler/app") public class AppRestResource { @GetMapping("/rest/account") public String getAccount() { // 参考官方提供的响应数据 return "{\"id\":\"admin\",\"firstName\":\"Test\",\"lastName\":\"Administrator\",\"email\":\"admin@flowable.org\",\"fullName\":\"Test Administrator\",\"groups\":[],\"privileges\":[\"access-idm\",\"access-rest-api\",\"access-task\",\"access-modeler\",\"access-admin\"]}"; } } 重启再访问
这时虽然页面看起来没有问题，但是一些操作还是无法完成的，再看一下static/modeler/scripts/configuration/url-config.js这个文件，其中有很多请求服务端都没有实现的；两种方法：1、参考源码一个个自己实现；2、引入这些请求的源码包
很显然，选择第二种方式，引入源码包
&lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-ui-modeler-rest&lt;/artifactId&gt; &lt;version&gt;${flowable.version}&lt;/version&gt; &lt;/dependency&gt; 重启访问，发现需要登录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48df463787f4e1ae7c40c3296d9f010d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/263afa7acb5266ebdcecd319dda16f29/" rel="bookmark">
			python学习笔记-12.函数的递归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 函数的递归 函数调用自身的编程技巧成为递归。
1.1 递归的特点 一个函数内部调用自己。
代码特点
函数内部的代码是相同的，只是针对参数不同，处理结果不同。当参数满足一个条件时，函数不再执行。
– 这个非常重要，通常被称为递归的出口，否则会出现死循环！ 举个栗子
def sum_number(num): print(num) # 递归的出口，当参数满足某个条件时，不再执行函数 if num == 1: return # 自己调用自己 sum_number(num - 1) sum_number(3) output：
3
2
1
1.2 递归的案例 – 计算数字累加 需求：
定义一个函数sum_numbers能够接受一个num的整数参数计算1+2+…+num的结果 def sum_numbers(num): # 1.出口 if num == 1: return 1 # 2.数字的累加 num + (1....num-1) # 假设sum_numbers 能够正确的处理(1....num-1)的累加 temp = sum_numbers(num-1) # 两个数字的相加 return num + temp result = sum_numbers(100) print(result) output：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/263afa7acb5266ebdcecd319dda16f29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6802b99cefea2b363d303296165e905/" rel="bookmark">
			Fiddler抓包工具手机添加代理后连不上网解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想看更多算法题，可以扫描上方二维码关注我微信公众号“数据结构和算法”，截止到目前我已经在公众号中更新了500多道算法题，其中部分已经整理成了pdf文档，截止到目前总共有800多页（并且还会不断的增加），可以在公众号中回复关键字“pdf”即可下载。
原文链接：https://blog.csdn.net/shuiziliu1025/article/details/80911811 最近，在工作中需要测试一个监控网络请求的SDK，需要校验该SDK记录的耗时数据的准确性。根据网上大神们提供的工作经验，可以利用Fiddler工具给手机添加代理，来监控手机的一系列网络请求。但是，没想到，路漫漫其修远兮，fiddler工具给手机设置代理之后，手机竟然上不了网了，尝试了N种解决方法，终于给解决了，因此，记录下来以备不时之需。
1、fiddler给手机添加代理
打开fiddler工具-&gt;Tools-&gt;Fiddler Options，记住下面的端口号；
电脑和手机连接同一个网络，确保在一个局域网。电脑端（cmd-ipconfig）查看电脑的ip地址：
其中，ipv4地址就是电脑的ip地址。
手机端设置WLAN种给网络设置代理，选择对应的WLAN，对该网络进行编辑，代理选择手动，主机名填上面电脑ip地址，端口写fiddler提供的端口。
2、手机端用浏览器访问http://IP:端口，观察网络是否访问成功。
3、添加代理后连不上网的解决方法
a、关闭电脑防火墙
b、打开注册表（cmd-regedit），在HKEY_CURRENT_USER\Software\Microsoft\Fiddler2下创建一个DWORD，值置为80（十进制）
编写fiddlerScript rule，点击Rules-&gt;Customize Rules，用Ctrl+F查找OnBeforeRequest方法添加一行代码
if (oSession.host.toLowerCase() == "webserver:8888") { oSession.host = "webserver:80";
}
设置完之后重启Fiddler即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c16ed03a6723eb94d816721af8c99cbc/" rel="bookmark">
			SpringBoot整合Flowable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 引入依赖 flowable-spring-boot-starter-basic
&lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-spring-boot-starter-basic&lt;/artifactId&gt; &lt;version&gt;${flowable.version}&lt;/version&gt; &lt;/dependency&gt; 完整pom
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.16.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;flowable.version&gt;6.4.2&lt;/flowable.version&gt; &lt;slf4j.version&gt;1.7.25&lt;/slf4j.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-spring-boot-starter-basic&lt;/artifactId&gt; &lt;version&gt;${flowable.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c16ed03a6723eb94d816721af8c99cbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6e13681d13270f3dff19990c4eb4194/" rel="bookmark">
			leetcode_86_分隔链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分隔链表 描述 中等
给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。
你应当保留两个分区中每个节点的初始相对位置。
示例
输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3 输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 解题 另外定义两个链表，一条放小于x的，一条放大于等于x的
最后两条接起来
# python # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def partition(self, head: ListNode, x: int) -&gt; ListNode: head_big = ListNode(-1) head_small = ListNode(-1) p_big = head_big p_small = head_small while head: if head.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6e13681d13270f3dff19990c4eb4194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50560bbcd9f59d33ed0d33338cc1e61d/" rel="bookmark">
			立即执行函数详解及常见面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试题引发的思考 一道很经典的面试题：
for(var i = 0; i &lt; 5; i++) { setTimeout(function () { console.log(i) }, 1000) } 输出5个5，因为setTimeout为宏任务，此时全局i为5。
其中一个解决办法是将var改为es6的let, 在es5中就得用立即执行函数来解决
立即执行函数 通常有两种写法：
（function(){})(i)（function(){…}(i))
用立即执行函数来改造上面的代码，让其输出01234 for(let i = 0; i &lt; 5; i++) { setTimeout((function () { console.log(i) })(i), 1000) } 但原理是什么呢？
通过这两个图对比我们可以看到，立即执行函数被推入到宏任务队列后，当开始执行时，立即执行函数有一个作用域，此时存在一个变量就是当时的i，然后就去执行该函数，打印i，在当前函数作用域内没有找到，于是就往父级找，父级为立即执行函数作用域，找到了i，这个关系可以从图中的调用栈信息Call Stack可以看出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fce1b3e34b520afeffb37ce08c7cd66/" rel="bookmark">
			zabbix
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zabbix入门 zabbix有自己的nginx和数据库所以在做之前必须停止nginx和mysqld服务
zabbix官方网站选择你的版本会有相应的下载方法
下载zabbix.tar.gz
tar xf zabbix.tar.gz
cd zabbix
yum -y install *
或者下载依赖的软件包
安装 Zabbix 仓库文件
rpm -Uvh https://repo.zabbix.com/zabbix/5.0/rhel/7/x86_64/zabbix-release-5.0-1.el7.noarch.rpm
安装 Zabbix server 和 agent
yum install zabbix-server-mysql zabbix-agent -y
安装 Zabbix 前端
安装 Red Hat 软件集合
yum install centos-release-scl -y
编辑仓库配置文件 /etc/yum.repos.d/zabbix.repo 并开启 zabbix-frontend repository
[zabbix-frontend]
…
enabled=1
…
开始安装 Zabbix 前端 软件包
yum install zabbix-web-mysql-scl zabbix-nginx-conf-scl -y
上面是环境问题
然后创建数据库 yum5.7版本的数据库 安装修改密码 详情看数据库文档
进入数据库
create database zabbix character set utf8 collate utf8_bin;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fce1b3e34b520afeffb37ce08c7cd66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43ca55dc70834cb481aa93bc3c940d17/" rel="bookmark">
			核密度函数加权直方图的计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本篇博客中，我将与众位看官分享我自己写的关于用核密度函数加权的直方图的计算
欢饮批评指正！！！
核密度函数加权直方图在基于Mean shift的跟踪算法中经常用到。请客官查看我的博客：
样本均值漂移的原理 Mean Shift 原理
常用的核密度函数有
EpanechnikovKernal：
在Mean Shift的迭代过程中用的是上述两个函数的截面函数：
下面是这两个函数(4)和(5)的程序实现：
/*核函数：Epanechnikov Kernal
center: 核函数中心坐标
xy : 在核区域内的某一个点
hx,hy : 核区域在x方向和y方向的半径（或叫 带宽）
*/
static float EpanechnikovKernalFunc(Point2f&amp; center,Point2f&amp; xy,int hx,int hy)
{
//计算点xy到中心center的归一化距离
float distx = (xy.x - center.x)/hx;
float disty = (xy.y - center.y)/hy;
float dist_square = distx*distx + disty*disty;//距离平方
float result = 0.f; //函数要返回的结果
//核区域就是以hx和hy为边长的矩形的内接圆，在该内接圆中的点
//的函数值都不为0，若距离超过核区域，则返回0，
//距离center越近，函数值越大
if(dist_square&gt;=1) {
result = 0.f; }
else
{
//float Cd = CV_PI; //单位圆面积 pi*R^2 ,R==1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43ca55dc70834cb481aa93bc3c940d17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/286c428d2394b07d1f020bcf028e0d09/" rel="bookmark">
			4.创建并调用自动控制器(api)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建应用程序服务后, 通常需要创建API控制器以将此服务公开为HTTP(REST)API端点. 典型的API控制器除了将方法调用重定向到应用程序服务并使用[HttpGet],[HttpPost],[Route]等属性配置REST API之外什么都不做.
ABP可以按照惯例 自动 将你的应用程序服务配置为API控制器. 大多数时候你不关心它的详细配置,但它可以完全被自定义.
ABP在确定服务方法的HTTP Method时使用命名约定:
Get: 如果方法名称以GetList,GetAll或Get开头.Put: 如果方法名称以Put或Update开头.Delete: 如果方法名称以Delete或Remove开头.Post: 如果方法名称以Create,Add,Insert或Post开头.Patch: 如果方法名称以Patch开头.其他情况, Post 为 默认方式. 如果需要为特定方法自定义HTTP Method, 则可以使用标准ASP.NET Core的属性([HttpPost], [HttpGet], [HttpPut]... 等等.). 这需要添加Microsoft.AspNetCore.Mvc.Core的Nuget包.
本篇使用的类库
*****.Application ：编写自动控制器service的地方 *****.HttpApi.Host：启动项目所有控制器存放地。指向swagger
下边我们使用自动api控制器(service)创建几个api，然后在host中去调用
官方文档地址：https://docs.abp.io/zh-Hans/abp/latest/API/Auto-API-Controllers
上一篇文章我们已经建好了表，现在我们在.Application创建自动控制器 1.在.Application类库里创建service
using Microsoft.Extensions.Caching.Distributed; using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using Volo.Abp; using Volo.Abp.Application.Dtos; using Volo.Abp.Application.Services; using Volo.Abp.Caching; using Volo.Abp.Domain.Repositories; namespace Test1111.Books { [RemoteService(IsEnabled = false)]//此注释是将本service的api禁用，因为自动api所有方法名一样只有请求方式不一样不易区分，我们改用host调用service的方法 public class BookAppService : CrudAppService&lt; Book, //The Book entity BookDto, //Used to show books Guid, //Primary key of the book entity PagedAndSortedResultRequestDto, //Used for paging/sorting CreateUpdateBookDto&gt; //Used to create/update a book //IBookAppService //implement the IBookAppService { private readonly IDistributedCache&lt;BookDto&gt; _cache; public BookAppService(IRepository&lt;Book, Guid&gt; repository, IDistributedCache&lt;BookDto&gt; cache) : base(repository) { _cache = cache; } public async Task&lt;BookDto&gt; GetBookAsync(Guid bookId) { return await _cache.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/286c428d2394b07d1f020bcf028e0d09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95286d0290adb7844ecb22afc8c33cd7/" rel="bookmark">
			工字型钢弹性截面模量计算公式_方套方中空夹层钢管混凝土柱与钢混凝土梁单边螺栓端板连接节点数值分析...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击蓝字
关注我们
王静峰　端梦珺　郭　磊　张　猛
摘要：为了揭示方套方中空夹层钢管混凝土柱与钢-混凝土组合梁单边螺栓端板连接的受力性能和破坏机理，通过ABAQUS有限元软件建立了该组合节点的数值分析模型，明确了材料本构关系模型和复杂接触问题。通过水平低周往复荷载试验验证了数值分析模型的准确性，对其破坏模式和滞回曲线进行了评价。考虑了几何参数、材料参数、荷载参数对节点水平荷载-水平位移曲线的影响，讨论了极限承载力和初始刚度的影响规律。研究表明，方套方中空夹层钢管混凝土柱与钢-混凝土组合梁单边螺栓端板连接节点具有良好的抗震性能和受力性能，可应用于高烈度地震区的装配式组合框架；提出的此类型组合节点数值分析方法可用于装配式组合框架的设计与计算。
关键词：方套方中空夹层钢管混凝土柱；单边高强螺栓；端板连接节点；数值模拟；参数分析
Abstract: In order to reveal the mechanical behavior and failure mechanism of blind bolted end-plate connections between square concrete-filled double skin steel tubular(CFDST) columns and steel-concrete composite beams, a finite element(FE) model of this composite joint is built accounting for complex material model and contact interactions. The accuracy of numerical analytical model is verified against the test results under cyclic loads.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95286d0290adb7844ecb22afc8c33cd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a9135bf01dc29c10129a26dd0d91c63/" rel="bookmark">
			Nmap端口扫描的几种状态介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nmap端口扫描的几种状态介绍 1、Nmap Nmap 是一种用来发现网络中主机和服务器的安全扫描工具，从而能够产生一个网络“地图”，为了完成这个功能，Nmap会向每个目标主机发送特定的报文，从而按目标主机返回报文（或者无返回报文）来判断目标主机的属性（如：开放的端口，所使用的操作系统，操作系统的类型等信息）
2、Open Open 端口处于开放状态，例如：当nmap使用TCP SYN对目标主机某一范围的端口进行扫描时，我们知道TCP SYN报文是TCP建立连接的第一步，所以，如果目标主机返回SYN+ACK的报文，我们就认为此端口开放了并且使用了TCP服务。
3、Closed Closed 端口处于关闭状态，例如：TCP SYN类型的扫描，如果返回RST类型的报文，则端口处于管理状态。这里我们值得注意的是关闭的端口也是可以访问的。只是没有上层的服务在监听这个端口，而且，只是在我们扫描的这个时刻为关闭，当我们在另一个时间段进行扫描的时候，这些关闭的端口可能会处于open的状态。
4、Filtered（过滤） Filtered 由于报文无法到达指定的端口，nmap不能够决定端口的开放状态，这主要是由于网络或者主机安装了一些防火墙导致的，当nmap收到icmp报文主机不可达报文（例如 type为3，code为13【communication administratively prohibit】报文）或者目标主机无应答，常常会将目标主机的状态设置为filtered。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a02ef7ebaa0625f4f7de0c52855e890/" rel="bookmark">
			编译原理期末试题(8套含答案)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想看更多算法题，可以扫描上方二维码关注我微信公众号“数据结构和算法”，截止到目前我已经在公众号中更新了500多道算法题，其中部分已经整理成了pdf文档，截止到目前总共有800多页（并且还会不断的增加），可以在公众号中回复关键字“pdf”即可下载。
编译原理期末试题(8套含答案) ，部分截图如下
太多了，就不在一一复制，可以扫描最上面的二维码，关注微信公众“数据结构和算法”，回复编译原理试题的拼音简称byylst即可获得下载地址
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/334/">«</a>
	<span class="pagination__item pagination__item--current">335/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/336/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>