<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b126c965fe8ee62dab6ed8a526f4f812/" rel="bookmark">
			【深度学习&amp;NLP】数据预处理的详细说明（含数据清洗、分词、过滤停用词、实体识别、词性标注、向量化、划分数据集等详细的处理步骤以及一些常用的方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、数据预处理简介
二、进行数据预处理的原因
1、文本中含有不必要的信息和噪声
2、数据可能不一致或者不太规范
3、文本需要标记和分词
4、可能需要词形还原和词干提取 ( 词性标注 )
5、需要将文本向量化处理
三、数据预处理方法介绍及使用样例
1、数据清洗
2、分词
3、停用词过滤
4、词性标注
5、实体识别
6、词向量化
一、数据预处理简介 在深度学习中，数据预处理是一个重要的步骤。原始训练数据中，由于每一维特征的来源以及度量单位不同，会造成特征值的分布范围差异很大。当计算不同样本之间的欧氏距离时，取值范围大的特征会起到主导作用。因此，对于基于相似度比较的机器学习方法，必须先对样本进行预处理，将各维度特征归一化到同一取值区间，并且消除不同特征之间的相关性，才能获得理想的结果。
数据预处理还可以通过数据增强来增加训练样本的多样性，提高模型鲁棒性，避免过拟合，例如， 翻转、旋转、平移、缩放、随机裁剪或补零，色彩抖动等 ( 这些都是在CV当中的一些情况 )；在NLP的任务中，数据预处理又可以通过以下方式来有效地增加训练数据的多样性，避免模型对训练数据的过拟合，提高模型的泛化能力和鲁棒性，例如，同义词替换、随即插入、随即删除、随即交换、随机扰动等，这些方法还可以缓解NLP中数据量不足的问题，提高模型的性能。
二、进行数据预处理的原因 1、文本中含有不必要的信息和噪声 文本数据通常包含大量的无关信息和噪声，如标点符号、HTML标记、停用词、缩写、拼写错误、语法错误等。这些信息和噪声会干扰模型的学习和性能，导致模型预测不准确或低效。通过数据预处理，可以去除这些不必要的信息和噪声，使文本数据更加干净和有用。
2、数据可能不一致或者不太规范 文本数据通常具有多种表现形式和写作风格，如大小写、缩写、单复数、变体词等，在中文中可能存在语义分割的问题，有些词与词之间的界限不清晰、有些词语的多义性和歧义性、还有语法和语义的变化、简体字和繁体字、以及不同民族的文字，所以中文的数据在处理起来可能更加的困难、需要我们更加的小心和细心。这些差异会导致数据不一致和不规范，从而使模型学习变得更加困难。通过数据预处理，可以将文本数据转换为一致和规范的形式，使模型更容易学习和理解。
3、文本需要标记和分词 在NLP中，将文本数据划分为单个标记或单词是很重要的。这可以帮助我们理解文本的含义和结构，以及构建词汇表和语料库。标记化和分词可以将文本数据转换为可操作的形式，从而为模型学习提供基础。这一步中，对中文的处理也比英文要困难，英文的词都是用空格隔开的，而中文的一句话很多时候都是连起来的，所以在分词、词性标注的时候就更加的不容易，不过现在也有像 jieba 这样的比较优秀的中文分词的工具。
4、可能需要词形还原和词干提取 ( 词性标注 ) 在NLP中，有时候我们需要将单词转换为它们的基本形式，这被称为词形还原和词干提取，在中文的NLP中其实词形还原和词干提取用的比较少 ( 在机器翻译和信息检索需要形态学分析的时候可能会用到 )，一般来说中文更多的是使用分词技术和词性标注技术来处理。这可以帮助我们理解单词的含义和关系，以及减少词汇量。通过数据预处理，可以将文本数据中的单词转换为它们的基本形式，从而提高模型的性能和效果。
5、需要将文本向量化处理 NLP中的大多数模型需要将文本数据转换为数字特征向量，这可以使它们与其他机器学习算法兼容。向量化可以帮助我们表示文本数据，并为模型学习提供基础。通过数据预处理，可以将文本数据转换为数字特征向量，使其更加适合于机器学习算法。
NLP中的数据预处理是一个非常重要的步骤，可以帮助我们减少噪声和错误，提高数据的一致性和规范性，转换文本数据为可操作的形式，以及提高模型性能。
三、数据预处理方法介绍及使用样例 这里我们主要介绍在中文的NLP任务中数据预处理每一步所使用的一些方法。
1、数据清洗 数据清洗是指去除数据中不需要的内容，例如HTML标签、数字、特殊符号等。这可以通过正则表达式、字符串匹配和过滤等技术实现。
例：
import re def clean_text(sentence): # 过滤HTML标签 sentence = re.sub(r'&lt;.*?&gt;', '', sentence) # 过滤数字 sentence = re.sub(r'\d+', '', sentence) # 过滤特殊符号 sentence = re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b126c965fe8ee62dab6ed8a526f4f812/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e17cf0b277c1eda75cd3220e12e867f7/" rel="bookmark">
			2、AD新建项目及编辑界面介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、新建项目
1、 在完成安装和汉化工作后，我们开始新项目。第一步，点击“文件-新建-项目”，如下图所示
在弹出的新窗口中分为三个片区
左片区为创建项目的位置，这个位置可以是Altium 365（云端）、Version Ctotrol（用于团队工作的版本控制）、Local Projects（本地项目），为方便使用，一般选择本地文件。
中间片区为项目的类型，AD已经内置了一部分模板，如下图第二行以下的内容。
右片区是创建项目的名称和本地存放位置。
项目不需要预设，可以选择“Default”选项，这样就会生成一个空项目，自行创建原理图和PCB文件。
项目名称和路径设好后，直接点击create，新建一个空白项目
2、在空白项目下自行创建原理图和PCB文件，具体步骤如下：1、在项目名称上面右键（也可以“文件-新的-原理图”），选择添加新的原理图文件。
3、同理，添加PCB文件
二、原理图界面
原理图界面如上图所示，主要有四个工具栏，分别为：
1、项目栏，这里面是项目所用的文件。
2、快捷工具栏，能够方便使用者快速选取需要的指令。
3、器件栏，展示已经安装的库文件和器件，用户可以直接拖拽选取。
4、控制栏，各种指令都在此处，在快捷工具栏中没有的指令，可以在此处选取。
如果刚刚打开的原理图文件不显示器件栏，可以在右下角的Panels中将其拉出，如下图所示，点击
第一个Components即可。
三、PCB界面
1、项目栏，这里面是项目所用的文件。
2、快捷工具栏，能够方便使用者快速选取需要的指令。
3、控制栏，各种指令都在此处，在快捷工具栏中没有的指令，可以在此处选取。
4、器件栏，展示已经安装的库文件和器件，用户可以直接拖拽选取。
5、层叠栏，是PCB文件所特有的，在这个控制栏中，我们可以选择PCB文件的各个“层”，在这里每一层的用途都是不同的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c3f92ad027ab6b676639f7bf9b027ff/" rel="bookmark">
			通过UI显示3D模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、添加一个相机进行对应设置
2、制作一个RanImge，可以根据屏幕的大小显示RawImage的大小
3、设定显示模型的层级
注意模型在摄像机投射范围内，不然会透明显示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9e0eb75d7554050c0f7c53fb4f8e395/" rel="bookmark">
			sql 语句如何比较时间大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一. 注意:
1. 首先需要date_format进行格式化再进行比较。
2.注意：实体名称中的字母大小写
方法二.使用 &lt;![CDATA[&lt;]]&gt; &lt;![CDATA[&gt;=]]&gt; bc.credit_limit &lt;![CDATA[&lt;]]&gt; (doc.total_before_amount+doc.adjust_amount-doc.prepayment_amount) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e07a632cf1949629a5c3d346a2a95291/" rel="bookmark">
			MySQL MyBatis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL从表中随机查一条数据 SELECT * FROM address ORDER BY RAND() LIMIT 1 MySQL查询表是否存在 select count(*) from information_schema.TABLES where table_name = #{tableName} 插入数据插入随机的uuid &lt;insert id="insertComment" parameterType="com.deyi.govaffair.pojo.po.WelfareComment"&gt; &lt;selectKey keyProperty="commentId" order="BEFORE" resultType="String"&gt; select replace(uuid(),'-','') from dual &lt;/selectKey&gt; INSERT INTO welfare_comment (comment_id, project_id, user_id, comment_content, create_time, update_time) VALUES(#{commentId}, #{projectId}, #{userId}, #{commentContent}, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP); &lt;/insert&gt; 时间格式化 SELECT DATE_FORMAT(donation_deadline,'%Y-%m-%d %H:%i:%s') AS donationDeadline FROM sport_config %S, %s 两位数字形式的秒( 00,01, . . ., 59) %i 两位数字形式的分( 00,01, . . .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e07a632cf1949629a5c3d346a2a95291/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afa190fb5da5783a94ee224ec1d72ba0/" rel="bookmark">
			python opencv 人脸识别(第三部分：方框的绘制，实现人脸检测)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开发前准备 pycharm版本：2023.1
python版本：3.7.5
opencv-python版本：4.5.4.60
二、图像上方框的绘制 在图像上绘制方框的代码如下：
import cv2 img = cv2.imread('st.jpg') cv2.imshow('test', img) x, y, w, h = 100, 100, 100, 100 # 具体来说，pt1参数是矩形左上角的点的坐标，pt2参数是矩形右下角的点的坐标。这两个参数共同定义了矩形的位置和大小。 cv2.rectangle(img, pt1=(x, y), pt2=(x + w, y + h), color=(0, 0, 255), thickness=2) cv2.imshow('test', img) cv2.waitKey(0) cv2.destroyAllWindows() 完成效果如下图
cv2.rectangle()函数用于在图像上绘制矩形。pt1和pt2参数是定义矩形的两个对角点，分别表示矩形的左上角和右下角的坐标。
具体来说，pt1参数是矩形左上角的点的坐标，pt2参数是矩形右下角的点的坐标。这两个参数共同定义了矩形的位置和大小。
在上面的代码中，pt1的坐标为(x, y)，表示矩形左上角的点的坐标为(x, y)，pt2的坐标为(x+w, y+h)，表示矩形右下角的点的坐标为(x+w, y+h)。因此，矩形的宽度为w，高度为h。
color参数定义了矩形的颜色，(0, 0, 255)表示蓝色。thickness参数定义了矩形的线宽，这里设置为2。
三、实现简单的人脸检测 实现人脸检测的代码如下：
import cv2 def face_detect_demo(face_img): # 灰度处理图像 gray_img = cv2.cvtColor(face_img, cv2.COLOR_BGR2GRAY) # 选择分类器 face_detect = cv2.CascadeClassifier(r'C:\python\venv\Lib\site-packages\cv2\data\haarcascade_frontalface_alt.xml') # 对灰度图进行特征提取 face = face_detect.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afa190fb5da5783a94ee224ec1d72ba0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e21f1ab62c81166c3a1779defa53d2b/" rel="bookmark">
			Windows小技巧8--VMware workstation虚拟机网络通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows小技巧8--VMware workstation虚拟机网络通信 VMware Workstation（中文名“威睿工作站”）是一款功能强大的桌面虚拟计算机软件，提供用户可在单一的桌面上同时运行不同的操作系统，和进行开发、测试 、部署新的应用程序的最佳解决方案。其使用过程中的网络连接是一个比较重要的问题，笔者本文针对VM的网络通信的几种不同情况加以说明。
1、三种通信模式简介 打开VMware的虚拟网络编辑器，可以发现有三种网络连接类型，别为桥接模式，仅主机模式，NAT模式，其对应的名称依次为VMnet0，VMnet1，VMnet8，如下图所示。
从图中可以看到桥接对外通过本机网卡Realtec***可以实现外网访问，主机模式外部连接为 - 不能实现外网访问 ，NAT模式可以通过NAT来实现外网访问。
笔者台式机A通过静态ip和本地局域网连接，虚拟机B通过仅主机模式进行网络连接，虚拟机C通过NAT方式进行网络连接，各系统间网络连接和通信情况如下表所示：
序号主机名称连接方式互ping状态外网访问1A台式机静态IP可ping通B和C正常2B虚拟机主机模式可ping通A和C无法访问3C虚拟机NAT模式不能ping用户A和B正常 当A为静态时候，若存在D为桥接模式，那么网络启动会失败(通常表现为2、常见问题中的1）)，导致无法虚拟机分配IPv4网络，从而D无法访问外网，也无法和上述ABC通信，由于没有IPv4导致ABC也无法和D通信。
以下1）、2）、3）内容来源于博文 Linux虚拟机的三种网络连接方式，该文总结的比较到位，笔者就不画蛇添足了。
1）桥接：
桥接网络是指本地物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机,所以两个网卡的IP地址也要设置为同一网段。所以当我们要在局域网使用虚拟机，对局域网其他pc提供服务时，例如提供ftp，提供ssh，提供http服务，那么就要选择桥接模式。
2）NAT模式
NAT模式中，就是让虚拟机借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。NAT模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在vmware提供的一个虚拟网络。
NAT和桥接的比较:
(1) NAT模式和桥接模式虚拟机都可以上外网。
(2) 由于NAT的网络在vmware提供的一个虚拟网络里，所以局域网其他主机是无法访问虚拟机的，而宿主机可以访问虚拟机，虚拟机可以访问局域网的所有主机，因为真实的局域网相对于NAT的虚拟网络，就是NAT的虚拟网络的外网，不懂的人可以查查NAT的相关知识。
(3) 桥接模式下，多个虚拟机之间可以互相访问；NAT模式下，多个虚拟机之间也可以相互访问。
如果你建一个虚拟机，只是给自己用，不需要给局域网其他人用，那么可以选择NAT，毕竟NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，只要虚拟机的网路配置是DHCP，那么你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可，就可以让虚拟机联网了。
3）仅主机模式
在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMware Network Adepter VMnet1虚拟网卡来实现的。Host-Only的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能
2、常见问题 该章节主要记录笔者使用时候遇见的一些问题，以及解决方案，后续遇到新问题都会在此处续更。
1）登录Ubuntu系统时候出现A start job is running for Raise network interfaces(xxs /5min xxs)
如下图所示出现该问题后，系统需要等待5min 3s后才能进入系统中，进入后也无法上网且没有分配ipv4地址，该问题产生的原因为网络服务服务没有正常启动，直到网络启动最大时间到达后才启动系统，系统启动后也无法正常分配ipv4地址，导致无法联网，也无法和局域网内机器互ping。
其解决方法为：将本机电脑连接到某个局域网或者路由器，然后本机使用动态分配ip的方法即可正常给虚拟机分配ip，重启虚拟机就不会出现该问题；若本机必须使用静态ip连接到外部网络中，则可以使用nat的方法进行网络连接，也可解决该问题其正常访问网络。
注：笔者在网上看到有相当一部分博文介绍修改参数使Raise network interfaces最长时间缩短，使用参数修改的方法笔者试了一下没有成功，且修改参数也没有解决后续无ipv4的问题，治标不治本，笔者几次尝试后发现该方法可以解决上述问题。若有更好的方法还请留言，以便于相互学习。
2）桥接模式无法上网排查方法
首先查看service中的dhcp、nat等服务是否开启，若未开启则手动开启；其次查看本机是否为静态ip，若本机为静态ip则使用nat方式连接外网。
3）本机没有任何外网连接的情况下建立主机和虚拟机之间的网络通信方法
该情况下无法正常桥接，需要使用host only方法，可为虚拟机建立静态ip，具体方法如下：
当电脑无任何网络的连接的时候，使用nat启动时候也会出现A start job is running for Raise network interfaces(xmin xs / 5min xs)的异常，登录后发现ens33无ipv4网络，此时可以通过配置host only实现网络访问，并且可以使用shell登录主机。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e21f1ab62c81166c3a1779defa53d2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c1e700bbd37f84003fef1f536c4340a/" rel="bookmark">
			跟着ChatGPT学习python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、如何学习python
Python学习的大纲以及基础知识介绍：
Python基础知识 Python的历史和发展Python的优点和缺点Python的安装和配置Python的基本语法和数据类型Python的变量、常量和赋值操作Python的运算符和表达式Python的控制结构，如if语句、while语句和for语句Python的函数和参数Python的模块和包Python的文件操作Python的异常处理 Python高级知识 面向对象编程Python的类和对象Python的继承、多态和封装Python的装饰器和闭包Python的迭代器和生成器Python的多线程和多进程Python的网络编程Python的正则表达式Python的数据库操作Python的Web框架 Python实践项目 使用Python进行数据分析使用Python进行机器学习使用Python进行爬虫使用Python进行Web开发使用Python进行游戏开发使用Python进行物联网开发 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e54270dd4893fa18c414829f9ee82065/" rel="bookmark">
			解决window聚焦照片不自动更新，没有“喜欢吗”信息提示框问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近电脑不知道怎么了，window聚焦自动切换成图片，而且换成window聚焦，喜欢么等提示框也消失了，查了很多的方法，很杂，而且还有比修改注册表的，有个方法可用。需要全程联网，因为需要重新加载图片
1.打开时设置-个性化-锁屏 设置为图片
2.打开下面路径，C:\\用户\\Lenovo\\AppData\\Local\\Packages\\Microsoft.Windows.ContentDelivery…\\Settings\nAppData之前的文件可能不一样，但是大致方向相同，找到用户/User，里面有AppData文件
3.删除setting文件夹的所有内容，这个删除完全没有关系。
4.打开时设置-个性化-锁屏 设置为window聚焦，不要锁屏,等待5分钟左右，再锁屏，看看window聚焦是否恢复正常
5.如果依然是图片，打开时设置-个性化-锁屏 设置为window聚焦，锁屏
6.恢复正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d171025b3803e3748667b85734e995/" rel="bookmark">
			&amp;times转义成×
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 写了个单点登录的接口，要传时间戳
本应该是：
https://***:/data/single/sso?mobile=***&amp;url=***&amp;sign=***&amp;times=*** 却变成了：
https://***:/data/single/sso?mobile=***&amp;url=***&amp;sign=***×=***
https://***:/data/single/sso?mobile=***&amp;url=***&amp;sign=***×=*** 原因：在URL中参数若有&amp;times则会被转成x
解决办法：
1、把&amp;times不放在后面，放在首位
https://***:/data/single/sso?times=***&amp;url=***&amp;sign=***&amp;=mobile*** 2、把&amp;符号转义成html实体,&amp;的实体是%amp;
https://***:/data/single/sso?mobile=***&amp;url=***&amp;sign=***&amp;amp;times=*** 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9e3d6c0103e3f9e2949605cb6f1f35f/" rel="bookmark">
			概率论学习笔记01——随机事件与概率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 随机事件与概率 1. 事件的运算2. 古典概型3. 条件概率4. 独立试验序列 1. 事件的运算 两个事件的差： A − B = A ∩ B ‾ A-B=A \cap \overline B A−B=A∩B
“并”、"交"的结合律、分配律
对偶率：
A ∪ B ‾ = A ‾ ∩ B ‾ \overline{A\cup B}=\overline A\cap \overline B A∪B=A∩B
A ∩ B ‾ = A ‾ ∪ B ‾ \overline{A\cap B}=\overline A\cup \overline B A∩B=A∪B
概率的加法公式（1）：如果事件A与事件B互不相容，则
P ( A ∪ B ) = P ( A ) + P ( B ) P(A\cup B)=P(A)+P(B) P(A∪B)=P(A)+P(B)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9e3d6c0103e3f9e2949605cb6f1f35f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48783c60d0667f17147433d29c740e5f/" rel="bookmark">
			漫谈逆向工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逆向工程，原名Reverse Engineering，简称RE。关于其书面介绍我就不复制粘贴百度百科了，简而言之就是从发布的产品中反向分析其程序逻辑和算法——基于各种目的。
引言 准确地说，逆向工程包括软件逆向工程——即本文所讨论的，也包括硬件逆向工程。那么硬件逆向是怎么做的呢？据我所知，我国的芯片设计水平普遍比国外落后10年。当国外厂商已经成功流片量产X纳米的芯片时候，我们还在XX纳米的研发和难点攻关中挣扎。挣扎的过程之一就是芯片逆向。
一般从代理买到量产芯片后，第一步就是溶解外部封层，使用电子显微镜对电路进行拍摄，俗称拍片；第二步是使用特定工具软件（也是国外的）对照片进行切分，通过人力对自动生成的连线进行修复；第三步是将修复的连线还原成数字电路，再由IC逻辑工程师进行进一步修复；最后组合不同模块的门级电路，还原成硬件描述语言VHDL或者Verilog。之后就和正常的流程一样，开发、测试、模拟、仿真、流片……
扯远了，还是回到主题上来。硬件逆向的成本动辄成百上千万，没有纳税人的支持是玩不起的。但是软件逆向不同，只要一个智力正常的人，研究一两个月，也能上XX破解论坛上分享他们的破解成果了。
这也引出了一个问题，当我们在谈论逆向的时候，我们在谈论的是什么？
软件逆向 二进制逆向就是IDA-Pro + F5一把梭吗？Java逆向就是JADX一把梭吗？很多接触过逆向的新手都知道不是，他们会跳出来反驳，夹杂着一些X86/ARM/MIPS Assembly、Smali、XYZ IR等等让人不明觉厉的词汇。虽然听不懂，但我们也知道他们想表达什么：逆向是一门牵涉甚广的领域。
的确，如果HTML、CSS这些领域是“单关节运动”，那么逆向就是“多关节运动”。前段时间有些使用node写前后端的开发者喜欢自称“全栈工程师”，要按照我的说法，逆向工程师才是当之无愧的全栈。为什么？来看看一个逆向工程师所应该具备的部分技能：
一定的软件开发能力，熟悉数据结构、算法了解各种编程语言，熟悉编译原理熟悉计算机基本原理、操作系统、编译器、链接器熟悉对应平台或者虚拟机的汇编语言(机器码)、中间语言(字节码）... 一个好的逆向工程师，通常也是个不错的开发者。即便现在有各种收费或免费的反编译器，也需要逆向工程师对代码进行梳理、分析、审计。这就意味着逆向者需要站在比开发者更高的角度去审视，甚至比开发者更加理解他们的代码。……
关于初衷 搞逆向这么麻烦，要懂这个，要懂那个，直接劝退了很大一波人。但其实这些只是“术”而已，实际工作中只需要用到一部分子集，甚至只要学会使用商业工具也能干活儿了。在我看来，逆向工程师的核心还是——强烈的好奇心。
或者说，这是大部分网络安全人员(黑客)所具备的特质。因为好奇某个商业软件的功能，或者好奇某个病毒蠕虫的行为，才走向了这条逆向之路。
逆向的过程是枯燥的。与其说逆向是技术活，在我看来更多是体力活。尤其是在分析大型软件的时候，每天改变量名，改函数名，分析树状的调用路径，……很容易让人感到厌烦。
但是对于抱有好奇心的人而言，逆向应该是快乐的。每分析出一个软件或者函数的行为，就仿佛侦探找到关键线索或证据一样兴奋。隐藏的路径越深，知道的人就越少，那么被藏起来的东西也就越有价值。
关于快乐 逆向应该是快乐的，但很多人不想让你快乐。于是有了各种符号加壳、混淆、加密、解释执行(虚拟机)等应用增强方案，来提高逆向工程的难度。这通常是企业中端安全工程师的杰作，或者是使用了安全公司的通用安全加固方案。
所谓的逆向混淆，只有在别人不知道你的方法时才有价值。对于通用的加固，所面临的挑战者甚多，其内部实现很可能已经被扒了个底朝天；而对于企业自研的方案，又通常因为太low而被简单绕过。所以，想让逆向工程师不快乐的人有时候成功了，但是大部分时候还是在逆向工程师手下败下阵来。用一朋友的话来说就是：“程序在我的设备、我的环境里运行，难道它还能上天？”
关于现状 应用程序是不能上天，但是逆向工程师也很难上天。记得柯南里有一句话让我印象深刻——“如果怪盗是富有创造力的艺术家，那么侦探充其量只是吹毛求疵的评论家”。逆向工程做的大部分都是破坏性的工作，而不像开发者那样带来正面价值。
目前社区中做逆向的大多是出于解谜(CTF)、软件破解、游戏外挂等，即便是专门讨论逆向的安全论坛中，对技术细节的探讨也寥寥无几，更多是炫耀和分享自己的“成果”。天下熙熙，皆为利来，天下攘攘，皆为利往，除了闷声发大财地以搞逆向赚钱的工作室外，公开分享的也就只能是为名了。
那么职业做逆向的情况又如何呢？专门做逆向的正经岗位应该是恶意软件分析了，衍生出的团队在商业环境中突出PR宣传安全产品或者情报能力。其他小公司里招聘做逆向的人，要么是分析竞争对手，要么围绕高流量软件的去进行分析、破解、换皮、刷粉养号等等，是在违法犯罪的边缘来回试探。
专门做逆向的情况不多，但是将其作为一门技能去掌握的人也不少。我自己本身也不是专门做逆向的，因为工作需要才去对其进行了解。除了开源软件，也有越来越多闭源软件的漏洞被暴露出来，你不去挖别人自然会去挖。就拿安卓每个月的安全通告来说，带星号的漏洞简直不要太多。
网络安全学习资源分享: 零基础入门
对于从来没有接触过网络安全的同学，我们帮你准备了详细的学习成长路线图。可以说是最科学最系统的学习路线，大家跟着这个大的方向学习准没问题。
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享 (qq.com)
同时每个成长路线对应的板块都有配套的视频提供：
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享 (qq.com)
因篇幅有限，仅展示部分资料，需要点击上方链接即可获取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12e48a4a284b626cbd8bc4a3979cd2ec/" rel="bookmark">
			什么是逆向工程？特点是？应用领域有哪些?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.逆向工程
逆向工程又被称为反求工程(Reverse Engineering)，是一种再现产品设计技术的过程，通过对给定的产品进行逆向研究与分析，从而得出该产品的相关参数及特性，以制造出结构相近、性能更优秀的产品模型。利用三维扫描仪获取被测产品或者模型的数字化信息(点云数据)，在通过逆向软件进行编辑、修改、优化得出CAD模型图，最后通过CAD/CAM技术传送至数控加工机床，生产制造出对应所需模具的技术过程。
2.逆向工程的特点
(1)逆向工程技术具有高效快速的技术特点。在产品设计领域，应用逆向工程开发产品，可以有效缩短产品开发周期降低产品的风险，使产品更趋于系列化和家族化。
(2)逆向工程技术的普适性较强，快捷高效的开发手段使得逆向工程技术可以顺应任何形式的产品开发，技术手段也随着信息化制造技术的发展而改变。如今的逆向工程技术，已经可以通过CAD/CAE强大的造型设计与结构设计能力，实现被扫描物体点云数据模型可以更加精确的实现三维实体参数生成，精准实现从无任何参数信息的物体到数据整合的过程。
3.逆向工程的应用
(1)产品开发领域
针对中小型企业的产品开发，逆向工程能够有效地规避正向产品开发中开发成本高、市场风险大、开发周期长等风险。
(2)破损文物的修复
利用逆向数据获取手段对文物缺损的部位扫描和重构，通过三维数字化快速建立数字模型，最后利用三维打印技术可以将破损的部位1：1复制，从而方便文物修复。
(3)军事装备研制
军事装备包括各式枪械、军用车辆、特种装备等，其技术含量高、品质要求严格。可以对其材料、空气动力学、尺寸等逆向研宄与应用，可以有效满足国防军工产品的开发需求。
(4)模具开发
产品开发中经常会出现设计问题，例如试模时出现的产品注塑件内部断裂、缩水等问题，如果从新修改产品结构将会带来巨大损失。利用逆向工程技术对模具快速数字化，在计算机中直接对现有问题进行修改，可以有效提升模具修改的效率。
(5)家具复杂图案的数字化
在传统家具领域，复杂纹样和图案的采集与应用按照传统绘图方法，不仅工作量大，无法保证图案纹样的复原精确。利用逆向工程对复杂图案和纹样三维扫描，可以快速将图形数字化，精准应用到家具造型设计中。
网络安全学习资源分享: 零基础入门
对于从来没有接触过网络安全的同学，我们帮你准备了详细的学习成长路线图。可以说是最科学最系统的学习路线，大家跟着这个大的方向学习准没问题。
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享 (qq.com)
同时每个成长路线对应的板块都有配套的视频提供：
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享 (qq.com)
因篇幅有限，仅展示部分资料，需要点击上方链接即可获取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff379d0faf875d54addac28887bf3e20/" rel="bookmark">
			在google浏览器使用ie功能（本人目前win11系统正常使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先要科学上网，科学上网，科学上网（不能科学上网的就不用看了） 1.打开下面的链接，这也是我在chrome应用商店逛的时候发现的。
https://chrome.google.com/webstore/detail/ieability-open-in-ie/moffahdcgnjnglbepimcggkjacdmpojc·2.把插件添加到google浏览器操作，这时候根据提示下载这个程序到本地，然后执行它。
3.执行成功是这样的。
4.这时候你就可以在google浏览器打开设置，操作如下
1.点击google右上角的三个点，点击设置
2.这里看到插件已经加载，开启它
3.开启以后的样子是这样的
这是没开启的样子，这里注意看右上角有一个橘色的ie图标，证明插件已经加载了，但是这个页面还是没有使用ie浏览器的 4.然后点击这个橘色的ie图标，页面就成了使用ie加载出来的，别问我为什么页面这么丑，我不知道 。
5.这个页面也是支持ActiveX 控件的
剩下的，就要各位大佬自行发掘了，有什么问题可以留言学习交流
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbc8967b6d25ec592c79546ac334a941/" rel="bookmark">
			6个优化策略，助你降低K8S成本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes 早已成为容器编排引擎的事实标准，而随着 Kubernetes 环境的复杂性持续增长，成本也在不断攀升。CNCF 发布的调查报告《Kubernetes 的 FinOps》显示，68%的受访者表示 Kubernetes 开销正在上涨，并且一半的人所在的组织经历了每年超过20%的开销增长。
因此，Kubernetes 成本管理和优化亟需得到系统管理员的重视。本文我们将了解6个优化 Kubernetes 成本的策略和方法。
1、合理调整 Pod 和节点 降低成本最简单的方式之一是管理 Pod 和节点使用的资源。尽管通常的建议是留有足够的机动空间，但过度配置或允许应用程序无限制地使用资源会带来灾难性的后果。例如，假设一个Pod由于应用程序的错误而消耗了节点的所有可用内存，不必要地利用了资源，这会导致其他 Pod 完全没有资源可用。
为避免这一情况的发生，用户可以在命名空间级别用 Kubernetes 资源配额和限制区间来限制资源利用率。此外，还可以在容器层面上指定资源请求和限制，强制执行容器可以请求多少资源以及资源的最大限制。
节点的大小取决于 Pod 所使用的资源。如果你的工作负载只利用了节点中50%的资源，并且短期内资源使用量不会激增，那么用户可以适当缩小节点的规模以降低成本。
另一个考虑因素是调整在单个节点上可以运行的 Pod 数量。即便在没有硬性限制的情况下，在单个节点上运行大量的 Pod 也会导致资源利用效率低下。鉴于这类情况，一部分K8S的托管服务提供商已经限制了单个节点上可以运行 Pod 的数量。
2、监控集群和基础设施 合理监控集群环境，包括底层或依赖项资源，有助于管理成本。无论你是使用托管的 Kubernetes 集群还是自建的集群，监控资源利用率和总体成本都是降低成本的第一步，这能够让用户一目了然地了解计算、存储、网络利用率等情况，以及成本在它们之间的分布情况。
云厂商通常能够提供内置工具和基本的监控功能。而利用 Prometheus、Kubecost 等工具可以让用户获得更为全面的洞察。近日发布的应用统一部署与管理平台 Seal AppManager 中也内置了成本管理视图，提供 Kubernetes 的资源开销、共享费用（如空闲费用、管理费用）的成本汇算和分摊，并内置多维度成本分析视图为用户提供成本洞察。另外，用户也可以依据集群、项目、应用等维度自定义成本视图。
3、配置弹性伸缩 Kubernetes 支持3类弹性伸缩：
HPA：自动水平伸缩VPA：垂直自动伸缩集群自动伸缩
自动充分利用 Kubernetes 弹性伸缩的特性可以帮助用户以一种简单、高效的方式降低整体 Kubernetes 成本。
HPA 可以监控 Pod 的使用情况，自动调整大小，以保持预期的使用水平。VPA 则可以调整集群中的资源请求和容器限制。自动伸缩会根据需求自动从 Kubernetes 集群中添加或删除节点，它有助于确保工作负载总是有足够的基础设施资源来完成它们的工作，但又不至于让用户最终为闲置的基础设施付费。
现阶段而言，并非所有的 Kubernetes 服务或发行版都支持自动伸缩。但是，如果你所采用的服务支持，那么它可以帮助你大幅降低 Kubernetes 成本。
4、为 K8s 工作负载选择不同的购买策略 对于 AWS 或者 GCP 来说，按需实例是最昂贵的选项。因此，我们应该充分利用预留的实例甚至是 Spot instances（竞价型实例）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbc8967b6d25ec592c79546ac334a941/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad59d4881d5335d39ec11cd9983578d5/" rel="bookmark">
			python 报错：Input type (torch.cuda.FloatTensor) and weight type (torch.FloatTensor) should be the same
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错：Input type (torch.cuda.FloatTensor) and weight type (torch.FloatTensor) should be the same解决方案 在验证所提模型是否正常时我们经常会使用下面的代码：
if __name__ == "__main__": model = MSTransception() # 也可替换为自己的模型 tmp_0 = model(torch.rand(1, 3, 224, 224).cuda()) print(tmp_0.shape) 执行完报错提示：
报错：Input type (torch.cuda.FloatTensor) and weight type (torch.FloatTensor) should be the same 解决办法；
需要在网络模型model = MSTransception(num_classes=9)后面添加设备即可，即；model = MSTransception(num_classes=9).cuda()。注意：并不是所有网络都需要在后面添加**.cuda()**，只有在出现上述错误的时候才用到
if __name__ == "__main__": model = MSTransception().cuda() tmp_0 = model(torch.rand(1, 3, 224, 224).cuda()) print(tmp_0.shape) ——&gt;点关注，不迷路！创作不易，感谢支持！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00fc47149c35b621dd763cf7af0137cf/" rel="bookmark">
			java连接redis及redis应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.连接redis的三种方式 （1）jedis ----------传统项目 ssm
（2）lettuce ------- 被springboot整合
（3）spingboot连接redis
1.1 Jedis 1.1.1 引入jedis依赖 &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;4.3.1&lt;/version&gt; &lt;/dependency&gt; 1.1.2 测试 注意：每次使用jedis对象时 都需要自己创建，当使用完后，需要关闭该对象。===&gt;jedis中也存在连接池.
@Test public void test01(){ Jedis jedis = new Jedis("192.168.61.129",6379); //string类型 String set = jedis.set("k4", "hello java"); System.out.println(set); jedis.get("k4"); Set&lt;String&gt; keys = jedis.keys("*"); System.out.println(keys); //hash类型 Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put("name","lht"); map.put("age","22"); map.put("sex","男"); long k5 = jedis.hset("k5", map); System.out.println(k5); String hget = jedis.hget("k5", "name"); System.out.println(hget); Map&lt;String, String&gt; k51 = jedis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00fc47149c35b621dd763cf7af0137cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b11780e50aa3b50e42bd399c18eaae0/" rel="bookmark">
			Java调用python传数组并获取python返回的值 【在python中做线性回归预测，得到的结果传回java中】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 任务：Java调用python文件，向java传数组，在python中做预测处理，最终获取python返回的值，传回java中1、java代码2、python代码3、结果4、B站演示视频链接 任务：Java调用python文件，向java传数组，在python中做预测处理，最终获取python返回的值，传回java中 1、java代码 package test; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.List; public class test { public static String coalType_list(List&lt;Integer&gt; list_one) { String arr = null; try { // 注意空格不要删除 String sysPython = "F:\\python3.9\\python.exe "; String filePython = "E:\\py\\py.py "; Process proc = Runtime.getRuntime().exec(sysPython + filePython + list_one);// 执行py文件 BufferedReader in = new BufferedReader(new InputStreamReader(proc.getInputStream())); String line = null; while ((line = in.readLine()) != null) { arr = line; } in.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b11780e50aa3b50e42bd399c18eaae0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aada8cdd326af4037ccf32322fa5d82b/" rel="bookmark">
			Linux下抓取usb总线数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、概述二、环境搭建三、实例与测试 一、概述 本文主要讲述的是在Linux环境下如何抓usb数据，就类似于在Windows环境使用bushound，当然该软件只能抓到应用层的的数据，至于usb的底层交互数据比如令牌包握手包等协议数据是看不到的。
二、环境搭建 Linux环境抓取usb总线数据需要先安装usbmon和tcpdump工具，tcpdump工具比较常见，这里说下安装usbmon，实际也比较简单。首先检查是否存在目录 /sys/kernel/debug/usb/usbmon，如果不存在证明没有安装这个工具。
root@Vostro:/sys/kernel/debug/usb# ls devices ehci ohci uhci xhci 我们使用tcpdump -D查看如下（方便后面做一个对比）：
root@Vostro:/sys/bus/usb/devices/1-5# tcpdump -D 1.enp2s0 [Up, Running, Connected] 2.any (Pseudo-device that captures on all interfaces) [Up, Running] 3.lo [Up, Running, Loopback] 4.wlp3s0 [Up, Wireless, Not associated] 5.bluetooth0 (Bluetooth adapter number 0) [Wireless, Association status unknown] 6.bluetooth-monitor (Bluetooth Linux Monitor) [Wireless] 7.nflog (Linux netfilter log (NFLOG) interface) [none] 8.nfqueue (Linux netfilter queue (NFQUEUE) interface) [none] 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aada8cdd326af4037ccf32322fa5d82b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b32b538aed32ed5884605269b17c318c/" rel="bookmark">
			一篇文章学会写SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章主要讲如何写SQL，虽然我在之前有篇文章中写到过数据库的操作和概念，其中有讲到数据库和表的操作语句以及有哪些函数和查询关键字（本篇不赘述），但毕竟理解概念和会实践书写是两码事。。
身为一名测试人员，我在工作中用到最多的sql语句是查询即select，于是用多了就发现写select 远不止想的这么简单，在实际场景中我们最好是能根据不同的需求写出多样的select ，从而提高自己的工作效率，还只会用select * from merchant 语句的已经out了，我们应该学习更多的关键字哦~
1. sql中关键字的书写顺序 首先我们要知道SQL语句中的关键字是有固定顺序的，只有关键字的位置写对了，我们才能写出正确的sql。如下就是最常用select 语句：
select distinct(去重) 需查询的字段名或者函数 (查询展示全部字段可用*)
from 表名(这里的表名和前面的字段名 可以取别名使用)
left/right join 要连接查询的表名 on 连接条件的等值判断
where 子查询的字段过滤条件，不能包含聚合函数的条件
group by 分组的依据 having 分组后信息的过滤条件，可包含聚合函数的条件
order by 排序的字段 limit 限制展示行数
select语句书写及执行结果示例： 简单查询语句：
#查询merchant表并展示全部字段 select * from merchant; #给merchant表取别名为m，查询m表中merchant_id ==10000001的企业名称和创建时间，同时展示m表的全部字段 select m.merchant_name,from_unixtime(m.create_time/1000),m.* from merchant m where merchant_id = 10000001; 使用聚合函数和group by + hanving （后文有讲聚合函数和分组查询
#统计每个tenant下有多少个企业 select tenant_id,count(merchant_id) from merchant group by tenant_id; #筛选出企业个数大于10个的tenant并按企业创建时间倒序排列 select tenant_id,count(merchant_id) from merchant group by tenant_id having count(merchant_id)&gt;10 order by create_time desc; 使用distinct去重（（后文有讲去重查询
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b32b538aed32ed5884605269b17c318c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dd99b4c3d457eb4978725feea68dd7c/" rel="bookmark">
			提取 MNIST_784的特征并进行分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		试着提取MNIST手写数字数据库（https://yann.lecun.com/exdb/mnist/）的一些特征（取部分数据集做训练，如每个数字10张图片做训练），并用某种分类算法对测试数据（10张不同数字图片做测试）进行分类，检查你所获得的分类准确率。‎基于滑动窗口的物体检测方法和基于区域提名的物体检测方法的优缺点各是什么？
答： ‎基于滑动窗口的物体检测方法： 优点：较之其他方法可能更能准确找到目标，减少遗漏，实现较为简单缺点：搜索空间较大，要扫描的窗口较多，计算量大；需要分类的窗口数目过多，导致无法使用复杂的特征和分类器 基于区域提名的物体检测方法： 优点：可以通过选择性搜索找出所有潜在包含目标的区域；计算速度快，召回率高缺点：算法复杂度较高 回顾一下图像的特征有哪些：
颜色特征，边缘、边界特征，兴趣点特征，纹理特征，形状特征
简单一些的就是，颜色特征，边缘特征。
首先构建数据集，并定义计算特征的方法，按照题目要求进行采样
数据集： class DataSet(object): def __init__(self,train_num=10,test_num=10) -&gt; None: self.__train_num=train_num self.__test_num=test_num self.X, self.y = fetch_openml("mnist_784", return_X_y=True, as_frame=False, parser="pandas",data_home='./data',cache=True) self.num2img = {} self.selectParital() def setArgs(self,train_num,test_num): self.__train_num=train_num self.__test_num=test_num self.selectParital() def calNum2img(self): for i,y in enumerate(self.y): self.num2img.setdefault(y,[]).append(i) def selectParital(self): self.calNum2img() trainl = [] testl = [] for i in range(10): samples = rng.sample(self.num2img[str(i)],self.__train_num+self.__test_num) trainl+=samples[:self.__train_num] testl+=samples[self.__train_num:] self.train_partial_x = self.X[trainl,] self.test_partial_x = self.X[testl,] y_f = np.copy(self.y).reshape([-1,1]) self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dd99b4c3d457eb4978725feea68dd7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a60d7f952a4388fb550ea4fbfe35910/" rel="bookmark">
			Linux 时间命令的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显示日历信息：cal命令
格式：cal 【选项】 【月份】【年份】
选项：
-1显示当前月份日历
-3显示前月，当月，下月的日历
-s周日为一个星期的第一天（默认）
-m周一为一个星期的第一天
-y显示当前年份日历
-j显示儒略历
cal 显示本月的日历（cal -s/cal -1）
cal -3显示前一个月、本月和下个月的日历
cal 2023 显示公元2023年的全年日历
cal 6 2023 显示2023年6月的日历
显示和设置系统日期命令、时间：date命令
格式：
date 【选项】【+“日期时间的显示格式”】
常用选项：
-d根据字符串描述，显示制定日期时间
-s根据字符串内容，设置系统日期时间
-r显示指定文件的最后修改时间
date 显示当前日期时间
date -d "50 days"显示50天后的日期
date -d "-50 days"显示50天后的日期
date -d "last week"显示上周的日期时间
date -s "8：00：00"
设置时间为8：00：00
date -s "202304020"（只设置日期当前时间会自动重置为00：00：00）
设置日期为2023年4月20日
date -s "20230420 20:50:00"
设置时间为2023年4月20日20：50：00
date -r "VISO"（引号内加文件名）
显示该文件的最后一次修改时间
扩展：date -f 显示文件中每一行的指定时间
date -u
显示UTC格式时间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a60d7f952a4388fb550ea4fbfe35910/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c612f712b98b3870270869ce0ff5d8d0/" rel="bookmark">
			六、C语言基础——深入理解C语言中的常量与变量：用法、区别及案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常量与变量 一、常量 在整个程序中，值不会发生变化的数据。
在C语言中，常量不能被赋值，只有变量才能被赋值。
1、整型常量 整型常量：用于表示整数值，可以使用十进制、八进制、十六进制等形式表示。
例如：
int num1 = 10; // 十进制整型常量 int num2 = 012; // 八进制整型常量 int num3 = 0xA; // 十六进制整型常量 2、字符型常量 字符型常量：用于表示单个字符，使用单引号(‘’)表示。
例如：
char ch = 'A'; // 字符型常量 3、浮点型常量 浮点型常量：用于表示实数值，包括单精度浮点数和双精度浮点数。
(1)、一般形式：
例如：
float num4 = 3.14; // 单精度浮点型常量 double num5 = 2.718; // 双精度浮点型常量 (2)、指数形式：
[+/-]M.N&lt;e/E&gt;[+/-]T
M：整数部分（1位数）N：小数部分 例如：
3.145e+10 == 3.145 * 10^10	-1.23e-8 = -1.23 * 10^(-8) 345.12 == 3.4512 * 10^2 == +3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c612f712b98b3870270869ce0ff5d8d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca034306f540ca4edf3608ec0a798088/" rel="bookmark">
			三、路由协议——直连路由、静态路由、缺省路由、路由优先级和路由度量、路由冗余和备份（浮动静态路由）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、直连路由（direct）：接口配置好ip地址并up后自动生成的路由1、查看路由表指令：dis ip routing-table2、使用dis ip int brief指令查看结果 二、静态路由（static）1、配置去包路由（目标网段+下一跳）2、配置回包路由 三、缺省路由四、路由优先级和路由度量1、路由优先级（preference）2、常用路由协议的默认优先级3、路由度量（路由开销 cost） 五、路由备份和冗余（浮动静态路由）六、案列：企业双出口冗余 前言 路由器作用：为ip数据包进行路由（选路），路由器会尽可能挑选一个最近最优的路径将报文送往其想去的目的地。
路由表：路由器用来转发数据包的一张“地图”。
一、直连路由（direct）：接口配置好ip地址并up后自动生成的路由 1、查看路由表指令：dis ip routing-table Destination：目标网段
NextHop：下一跳
Interface：出接口（自身的接口）
2、使用dis ip int brief指令查看结果 二、静态路由（static） 1、配置去包路由（目标网段+下一跳） R1:
[R1] ip route-static 192.168.2.0 24 12.1.1.2 R2：
[R2] ip route-static 192.168.2.0 24 23.1.1.3 注意：配置路由的时候，目标网段始终不变。
2、配置回包路由 R3：
[R3] ip route-static 192.168.1.0 24 23.1.1.2 R2 :
[R2] ip route-static 192.168.1.0 24 12.1.1.1 补充：在路由器上进行ping 包，默认情况下，报文的源地址是自己的出接口的地址。
三、缺省路由 常用查看命令：
dis cu：查看所有配置
dis ip routing-table：查看路由表
dis ip int brief：查看接口配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca034306f540ca4edf3608ec0a798088/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6abf2ecf4e72d18351c5616448185eb1/" rel="bookmark">
			python编码错误的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python报错UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-22: ordinal not in range(128)，特别是一些比较老的版本容易出现这个错误，一个特别简单的解决方式是用如下方式启动
PYTHONIOENCODING=utf-8 python test_encode.py 或者配置环境变量
export LC_ALL="en_US.utf8" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee00ce3b2edcd25a761758e37bd03967/" rel="bookmark">
			【Matlab】代码创建word文档如何改变字体颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建一个新的word文档，定义光标
word = actxserver('Word.Application'); document = word.Documents.Add; word.Visible = 1; selection = word.Selection; % 定义光标对象 一种方法，用ColorIndex属性，可以选择几种特定颜色。
selection.Text= '啦啦啦'; selection.Font.ColorIndex = 'wdBlue'; % 蓝色 selection.Start = selection.end;selection.TypeParagraph; selection.Text= '啦啦啦'; selection.Font.ColorIndex = 'wdGreen'; % 绿色 selection.Start = selection.end;selection.TypeParagraph; 类似改变‘wdxx’的可以定义各种颜色。
另一种方法是用RGB属性定义字体颜色，目前没找到方法，求指教
附：以下是 selection.Font 中的所有方法
- AllCaps：返回或设置一个 Variant 类型的值，该值表示指定的字体是否为全大写。
- Animation：返回或设置一个 WdAnimation 类型的值，该值表示指定字体的动画效果。
- Bold：返回或设置一个 Variant 类型的值，该值表示指定的字体是否为粗体。
- Color：返回或设置一个 WdColorIndex 类型的值，该值表示指定字体的颜色。
- ColorIndex：返回或设置一个 WdColorIndex 类型的值，该值表示指定字体的颜色。
- DoubleStrikeThrough：返回或设置一个 Variant 类型的值，该值表示指定字体是否具有双删除线。
- Duplicate：返回一个 Font 对象，该对象代表指定对象的副本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee00ce3b2edcd25a761758e37bd03967/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acc213e25dd48e047b2d2cc3c3e8aae8/" rel="bookmark">
			Ubuntu20.04使用多卡训练HyperNetwork模型和LoRA模型全流程及疑难问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. LoRA模型多卡训练1.1 安装xformer等库1.2 设置路径1.3 多卡训练 二. HyperNetwork模型多卡训练2.1 HyperNetwork通过WebUI训练 疑难报错解决方案多卡训练报错 软硬件配置： CPU: AMD 5800 8core 16Thread GPU: NVIDIA RTX 3090 *1 NVIDIA TITAN RTX *1 OS: Ubuntu20.04 一. LoRA模型多卡训练 1.1 安装xformer等库 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple git clone https://github.com/facebookresearch/xformers/ cd xformers git submodule update --init --recursive export FORCE_CUDA="1" # 进入https://developer.nvidia.com/cuda-gpus#compute # 设置所用显卡对应的Compute Capability，3090和A5000都是8.6 export TORCH_CUDA_ARCH_LIST=8.6 pip install -r requirements.txt pip install -e . 下载训练代码：
https://github.com/derrian-distro/LoRA_Easy_Training_Scripts.git
cd LoRA_Easy_Training_Scripts git submodule init git submodule update cd sd_scripts pip install --upgrade -r requirements.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acc213e25dd48e047b2d2cc3c3e8aae8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d5af7cff46dd5807f560cfadfe11820/" rel="bookmark">
			AutoSar标准下ADC的结果访问（Adc_ReadGroup与Adc_GetStreamLastPointer）的异同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 等待更新中…
文章目录 系列文章目录前言：1、什么是ADC的结果访问2、ADC访问模式：3、AUTOSAR标准配置案例分析3.1 Configuration3.2 图形展示结果指针初始化3.3 使用Adc_GetStreamLastPointer API访问结果：3.4 使用Adc_ReadGroup API访问结果： 3、Adc_GetStreamLastPointer与Adc_ReadGroup比较：4、 运用实例： 前言： 看懂此章，阁下已经跨入炼气期第五层了（滑稽）
1、什么是ADC的结果访问 在Autosar标准中，我们使用标准函数Adc_GetStreamLastPointer与Adc_ReadGroup对AD转换结果进行取值；那么这二者之间有何异同呢
2、ADC访问模式： 1、1 AdcGroupAccessMode----- ADC的Group的访问模式
在ONE-SHOT的转化模式下：
软件触发只能选择SINGLE-ACCESS（单次访问模式）
硬件触发可以选择SINGLE-ACCEESS 或者 STREAMING-ACCESS(线性流访问模式)
3、AUTOSAR标准配置案例分析 配置案例：(来源Autosr标准4.2.2；搞autosar的不看标准文档等于少条腿；网上博主写的文章大家也都是基于标准来写的）
3.1 Configuration group G1中配置两个通道 CH0,CH1 结果指针指向G1_ResultPtr
group G2中配置1个通道 CH2 结果指针指向G2_ResultPtr
group G3中配置1个通道 CH3 结果指针指向G3_ResultPtr
group G1配置为STREAMING模式 AdcStreamingNumSamples(采样数）为3
group G2配置为STREAMING模式 AdcStreamingNumSamples(采样数）为2
group G1配置为SINGLE模式 此时AdcStreamingNumSamples(采样数）为1
NOTE： SINGLE模式相当于配置STREAMING模式时，把AdcStreamingNumSamples设置为1；
3.2 图形展示结果指针初始化 具体表现：
根据下图可以看出：
G1设置了采样数为3，所以在result buffer中，对同一个通道CH0有三个结果；
G2设置了采样数为2，所以在result buffer中，对同一个通道CH0有两个结果；
G2设置为了SINGLE模式（即采样数为1），所以在result buffer中，对同一个通道CH0有一个结果；
3.3 使用Adc_GetStreamLastPointer API访问结果： Adc_GetStreamLastPointer(Adc_GroupType Group,Adc_ValueGroupType** Ptr To SamplePtr)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d5af7cff46dd5807f560cfadfe11820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bf60555d6d8e56492f366000efb1312/" rel="bookmark">
			理解boot menu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 启动菜单 boot menu是一种计算机启动时的菜单，它提供了用户在启动过程中选择不同的引导选项的功能。当计算机打开时，通常会显示一个包含该计算机可用操作系统的列表，例如windows、linux或mac os等等。这个列表还可以显示其他设备，如usb驱动器、cd/dvd驱动器、网络驱动器等，以及各种不同的启动选项。
通过boot menu，您可以选择要启动的设备或选项，例如： 启动某个特定操作系统（如果您有多个安装在计算机上的操作系统）；从usb驱动器或cd/dvd驱动器启动，并安装或运行操作系统；进入计算机的bios设置程序，更改系统设置；进入恢复环境并修复操作系统问题。 通常，您可以通过按下计算机的快捷键（例如f12、esc等）来引导到boot menu。不同品牌和型号的计算机都可能使用不同的快捷键。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d4a5e73318f786443c8c82b0e105252/" rel="bookmark">
			Ant-Design-Vue 日期控件显示英文解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 npm i moment 或 yarn add moment 下载依赖app.vue 添加标签全局包括 &lt;a-config-provider :locale="zhCN"&gt; ... &lt;/a-config-provider&gt; &lt;script&gt; 标签引入 即可 import dayjs from 'dayjs' import 'dayjs/locale/zh-cn' import zhCN from 'ant-design-vue/es/locale/zh_CN'; dayjs.locale('zhCN') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc78f98223dffc0aa2b441bb2ce17b81/" rel="bookmark">
			Linux格式化显示json工具jq
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux格式化显示json工具jq 安装jq格式化显示json读取json文件获取所有的key获取制定key的value值根据条件过滤JSON数据 本地安装jq失败解决办法,离线下载`jq`依赖包`oniguruma` 安装jq # 安装jq dnf install jq -y 格式化显示json echo 'json格式的数据' | jq 读取json文件 # 读取json文件 cat tmp.json | jq 获取所有的key # 获取json中所有的key cat tmp.json |jq -r keys 获取制定key的value值 # cat tmp.json |jq '.key值.key值' cat tmp.json |jq '.location.city' 根据条件过滤JSON数据 # 过滤指定key-value的数据 cat log.json | jq '.[] | select(.location.city == "value")' 本地安装jq失败 本地安装jq时提示: nothing provides libonig.so.5()(64bit) needed by jq-1.6-2.el7.x86_64
解决办法,离线下载jq依赖包oniguruma 到一台有外网的机器上下载oniguruma包,然后拷贝到本地再进行安装
# 下载oniguruma包 yumdownloader --resolve oniguruma # 拷贝到本地机器 scp oniguruma-6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc78f98223dffc0aa2b441bb2ce17b81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4c61ef9a6a9f37a6ef7d4d1ce176fb7/" rel="bookmark">
			Android:通过listview展示SQLite数据库数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MainActivity.java package com.example.myapplication;
import androidx.appcompat.app.AppCompatActivity;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.os.Bundle;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Adapter;
import android.widget.BaseAdapter;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.TextView;
import java.util.ArrayList;
public class MainActivity extends AppCompatActivity {
MyOpenHelper myOpenHelper = null; ListView lv = null; MyAdapter adapter = null; private ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); lv = findViewById(R.id.lv_listview); myOpenHelper = new MyOpenHelper(this); SQLiteDatabase mdb = myOpenHelper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4c61ef9a6a9f37a6ef7d4d1ce176fb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/559c5ee0bddb5f03fcdae18dbfcc1637/" rel="bookmark">
			InstructGPT原理讲解及ChatGPT类开源项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		InstructGPT原理讲解及ChatGPT类开源项目 Generative Pre-Trained Transformer（GPT） 是OpenAI的提出的生成式预训练语言模型，目前已经发布了GPT-1、GPT-2、GPT-3和GPT-4，未来也将发布GPT-5。
最近非常火的ChatGPT是基于InstructGPT提出的，有时候也被叫做GPT3.5。ChatGPT和InstructGPT在模型结构，训练方式上都完全一致，即都使用了指示性学习（Instruction Learning） 和人工反馈的强化学习（Reinforcement Learning from Human Feedback，RLHF） 来指导模型的训练，它们不同的仅仅是采集数据的方式上有所差异。所以要搞懂ChatGPT，我们必须要先读懂InstructGPT。
核心要点：
把语言模型变大并不代表是能够按照用户的意图来做事，这些模型与用户没有alignAI模型落地，安全性和有效性很重要如何将大模型与人类意图相结合。简单的方法是使用用户反馈的监督数据进行fine-tune。我们期望语言模型是helpful、honest、harmless。 相关文献：
Training a Helpful and Harmless Assistant with Reinforcement Learning from Human Feedback
构建了一个数据集，用于评测helpful和harmless：https://github.com/anthropics/hh-rlhf。
本文以GPT-3.5为起始点，关注使用fine-tuning的方法来align用户意图和大模型预训练。采用Reinforcement Learning from Human Feedback（RLHF）：
Google在2017年发表的《Deep Reinforcement Learning from Human Preferences》，人类反馈的强化学习过程如下所示：
InstructionGPT的训练过程：
Step1： 先采样一些demonstration数据，其包括prompt和labeled answer。基于这些标注的数据，对 GPT-3 进行fine-tuning，得到SFT（Supervised Fine-tuning）；雇佣40名标注人员完成prompt的标注（实际可能上百人参与了数据标注和处理）。此时的SFT模型在遵循指令/对话方面已经优于 GPT-3，但不一定符合人类偏好。
Step2： Fine-tuning完之后，再给一个prompt让SFT模型生成出若干结果（生成约4～7个结果，可以通过beam search等方法），例如上图中生成ABCD四种结果，通过人工标注为其排序，例如D&gt;C&gt;A=B，可以得到标注的排序pair；
基于标注的排序结果，训练一个Reward Model：
对多个排序结果，两两组合，形成多个训练数据对。RM模型接受一个输入，给出评价回答质量的分数。这样，对于一对训练数据，调节参数使得高质量回答的打分比低质量的打分要高：
l o s s ( θ ) = − 1 ( K 2 ) E ( x , y w , y l ) ∼ D [ log ⁡ ( σ ( r θ ( x , y w ) − r θ ( x , y l ) ) ) ] loss(\theta) = -\frac{1}{K\choose 2}E_{(x, y_w, y_l)\sim D[\log(\sigma(r_{\theta}(x, y_w) - r_{\theta}(x, y_l)))]} loss(θ)=−(2K​)1​E(x,yw​,yl​)∼D[log(σ(rθ​(x,yw​)−rθ​(x,yl​)))]​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/559c5ee0bddb5f03fcdae18dbfcc1637/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81dd96021b3125a143093f3d3f330ea5/" rel="bookmark">
			请在应用内提供拒绝、关闭定向推送的功能选项，功能选项名称请使用显著区分定向推送服务的字样，如 “个性化推荐关闭按钮“、 “猜你喜欢设置“；或者删除应用内定向推送/广告精准营销功能且应用内栏目、模块等不
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 uniapp打包的app提交到华为应用商城审核驳回原因:大佬们知道怎么改嘛 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efaec9f1594031a1d02df7b8ab1edffe/" rel="bookmark">
			C&#43;&#43; 二元运算符重载-案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二元运算符需要两个参数，下面是二元运算符的实例。我们平常使用的加运算符（ + ）、减运算符（ - ）、乘运算符（ * ）和除运算符（ / ）都属于二元运算符。就像加(+)运算符。
下面的实例演示了如何重载加运算符（ + ）。类似地，您也可以尝试重载减运算符（ - ）和除运算符（ / ）。
#include &lt;iostream&gt; using namespace std; class Box { double length; // 长度 double breadth; // 宽度 double height; // 高度 public: double getVolume(void) { return length * breadth * height; } void setLength( double len ) { length = len; } void setBreadth( double bre ) { breadth = bre; } void setHeight( double hei ) { height = hei; } // 重载 + 运算符，用于把两个 Box 对象相加 Box operator+(const Box&amp; b) { Box box; box.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efaec9f1594031a1d02df7b8ab1edffe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00cf54a345d901818c481cc8147810cf/" rel="bookmark">
			Using keycloak to login node-red
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Notion – The all-in-one workspace for your notes, tasks, wikis, and databases.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16535d7247c433f3d62a366ce64a2fee/" rel="bookmark">
			一个简单的socket信息收发案例,实现客户端发送,服务的接收之间通信功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个简单的socket信息收发案例,实现客户端发送,服务的接收之间通信功能 一.准备 1.服务端的程序准备
# TCP 客户端程序 client.pyfrom from socket import * IP = '127.0.0.1' PORT = 30000 BUFLEN = 512 ​ #实例化一个socket对象 #参数AF INET表示该socket网络层使用IP协议 #参数SOCK STREAM表示该socket传输层使用tCp协议 listenSocket=socket(AF_INET,SOCK_STREAM) #socket绑定地址和端口 listenSocket.bind((IP,PORT)) #使socket处于监听状态，等待客户端的连接请求 #参数5表示最多接受多少个等待连接的客户端 listenSocket.listen(5) print(f'服务端启动成功，在(PORT)端口等待客户端连接，，') dataSocket,addr= listenSocket.accept() print('接受一个客户端连接：',addr) while True: #尝试读取对方发送的消息 #BUFLEN指定从接收缓冲里最多读取多少字节 recved=dataSocket.recv(BUFLEN) ​ #如果返回空bytes,表示对方关闭了连接 #退出循环，结束消息收发 if not recved: break #读取的字节数据是bytes类型，需要解码为字行串 info=recved.decode() print(f'收到对方信息：{info})') #发送的数据类型必须是bytes,所以要编码 dataSocket.send(f'服务端接收到了信息{info}'.encode()) #服务端也调用close()关闭socket dataSocket.close() listenSocket.close() 二.客户端的程序准备 # === TCP 客户端程序 client.pyfrom=== from socket import * IP = '127.0.0.1' SERVER_PORT = 30000 BUFLEN = 512 #实例化一个socket对象，指明协议 dataSocket = socket(AF_INET,SOCK_STREAM) #连接服务端socket dataSocket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16535d7247c433f3d62a366ce64a2fee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5264b7dde6c1b7fdc5b969cf5b6bce08/" rel="bookmark">
			nginx获取第三方ngixn中请求头信息以及判断是否有参数的跳转地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： 1.配置示例2.配置讲解 1.配置示例 user nginx; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; # Load dynamic modules. See /usr/share/doc/nginx/README.dynamic. include /usr/share/nginx/modules/*.conf; events { worker_connections 1024; } http { log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; gzip on; gzip_min_length 1k; gzip_comp_level 1; gzip_vary on; gzip_disable "MSIE [1-6]\."; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php application/javascript application/json; proxy_connect_timeout 300; proxy_send_timeout 300; proxy_read_timeout 300; proxy_buffer_size 16k; proxy_buffers 4 64k; proxy_busy_buffers_size 128k; proxy_temp_file_write_size 128k; # Load modular configuration files from the /etc/nginx/conf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5264b7dde6c1b7fdc5b969cf5b6bce08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1307e3ae686f52e56bdcf22d0bbf5111/" rel="bookmark">
			网站页面太长如何截长图？记录使用Microsoft Edge浏览器截长图的方法。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作步骤：
1、打开网页将滑鼠移到底部
2、F12或者Ctrl+Shift+i打开网页控制台
3、Ctrl+Shift+p打开命令行，输入“Screenshot”
4、选择“捕获全尺寸屏幕截图”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfe5af1c5a6fe7c7fb1a21dfb379ee1a/" rel="bookmark">
			Elasticsearch查询以逗号拼接的字符串类型数据，类似于数据库Mysql和Oracle的find_in_set函数查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例如ES存储库中的ids字段数据如下：
ids131,32,3,41,2,4,5 入参id为3，查询期望返回结果数据为：
result31,32,3,4 Mysql或Oracle实现
&lt;sql id="bean_where_clause"&gt; &lt;where&gt; &lt;trim prefixOverrides="AND"&gt; …… &lt;if test="ids != null"&gt; AND FIND_IN_SET(id, #{ids}) &lt;/if&gt; &lt;/trim&gt; &lt;/where&gt; &lt;/sql&gt; Elasticsearch实现
1、添加逗号的自定义分词器，如comma
2、创建mappings，将字段设置为text类型
3、为该字段指定逗号分词器
{ "settings": { "analysis": { "analyzer": { "comma": { "pattern": ",", "type": "pattern" } } } }, "mappings": { "properties": { "ids": { "type": "text", "analyzer": "comma", "search_analyzer": "comma" } } } } 4、查询方法入参
SearchRequest request = new SearchRequest("ES库名"); BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery(); boolQueryBuilder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfe5af1c5a6fe7c7fb1a21dfb379ee1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/183620096879685f9222a4ced4c11abd/" rel="bookmark">
			手把手带你修复老照片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你家里是否有很多带着故事的老照片呢？
随着时间的流逝，这些照片难免会变模糊，或者有了划痕，今天给大家介绍一种使用程序修复老照片的方法。
教程面向小白，对于有基础的人过程可能略显繁琐。
修复效果如下图所示：
我们需要在电脑中下载安装程序运行环境、修复程序、预训练模型、相关依赖等。这些资料在文末的资源包中都可以找到，且都已经搭建完成，可以直接使用，下载链接在文末。
步骤大概分几步：
安装 Anaconda搭建虚拟环境运行照片修复程序 Anaconda 是一款很方便的软件，我一般用来隔离不同的 Python 虚拟环境，考虑到大家的电脑中的环境可能会有一些问题，所以采用 Anaconda 中的 Python 虚拟环境来运行本次的程序。
接下来我们做详细介绍
1、安装 Anaconda 在安装包中找到 Anaconda 安装程序，右击选择以管理员身份运行。
一路点下一步，除了最后这个页面切记勾选第一项，然后点击 install 安装，耐心等待安装完成。
2、搭建虚拟环境 进入资源包，点击地址栏，输入 cmd，点击回车，进入命令行窗口。
在命令行窗口输入以下命令，点击回车，开始创建虚拟环境，耐心等待完成。
conda create -n fixPhoto python=3.6.13 -y 显示以下界面，进行下一步
执行以下命令，激活刚刚搭建好的环境 fixPhoto
conda activate fixPhoto 执行以下命令，更新 pip
python -m pip install --upgrade pip 执行以下命令，安装需要的依赖，耐心等待安装完成
pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/ 安装完成
3、运行照片修复程序 新建一个文件夹，用来存放修复好的图片（放在其他地方也是可以的），比如 myresult。
先将待修复图片放在一个文件夹内，然后在刚刚的命令行窗口中根据不同情况输入以下指令完成照片修复
之后需要再次修复图片，只需要激活虚拟环境，运行以下指令即可。
没有裂痕的图像修复，也就是图片不清晰，可以用如下指令：
python run.py --input_folder 待修复照片的绝对路径 --output_folder 输出文件夹的绝对路径 --GPU -1 对于裂痕的图片，需要额外增加一个参数，指令如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/183620096879685f9222a4ced4c11abd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6113f55ca7a1c3383d6a490a241f2a0e/" rel="bookmark">
			创建JavaWeb简单项目（超级详细、一看就会）—— 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编写我们这个简单的JavaWeb项目之前，我先来介绍一下本项目的项目环境。
本项目是基于JavaWeb的开发环境，具体使用了以下技术和工具：
JavaWeb：JavaWeb是Java平台上的Web开发技术，它包括了Servlet、JSP、JavaBean、JDBC等技术。
Servlet：Servlet是JavaWeb中的一个组件，它可以接收HTTP请求并响应HTTP响应，是Web应用程序的核心。
JSP：JSP（JavaServer Pages）是JavaWeb中的另一个组件，它允许开发者在HTML页面中嵌入Java代码，以便动态生成页面。
MyBatis：MyBatis是一个Java持久化框架，它可以帮助开发者更方便地使用JDBC访问数据库。
MySQL：MySQL是一个开源的关系型数据库管理系统，它提供了高效、可靠、稳定的数据存储和访问功能。
Maven：Maven是一个Java项目管理和构建工具，它可以自动下载依赖库、编译代码、运行测试等任务。
项目环境准备： IntelliJ IDEA 本文中所演示的IDEA版本为2023.1最新版本
JDK和Tomcat JDK和Tomcat版本的对应关系如下图所示
本文中将使用JDK 19和Tomcat 10.0来做演示。
在JDK和Tomcat的安装中，都需要配置环境变量！！！否则可能Tomcat无法启动。
在IDEA中配置Tomcat 下载和安装Tomcat，并启动Tomcat服务器。在IDEA中打开项目，并在顶部工具栏中选择“Run” -&gt; “Edit Configurations”。在左侧面板中选择“Tomcat Server” -&gt; “Local” -&gt; “Configure”。在“Application Server”选项卡中添加Tomcat安装路径，点击“Apply”保存。在“Deployment”选项卡中，单击“+”图标以添加您的应用程序WAR文件或目录。当一个WAR文件被添加时，它会自动解压并在Tomcat中安装。点击“OK”保存配置。现在可以在IDEA中启动Tomcat了，在菜单栏中选择“Run” -&gt; “Run”的选项，并选择刚才配置的Tomcat配置。 如果配置完成后，IDEA提示没有检测到servlet api，可以通过将相关jar包添加到WEB-INF/lib目录来解决此问题。
到这里我们的准备工作已经完成啦，接着我们开始一步步创建我们的JavaWeb项目。
新建Web项目 1.打开IntelliJ IDEA软件，选择“Create New Project”。
2.在模板界面中，选择“Jakarta EE”，有些版本的是“Java Enterprise”。
3.在“New Project”窗口中，输入项目名称、项目所在路径和项目类型等信息，选择Template为“Web application”，并且选择刚刚配置的Tomcat，然后单击“Next”按钮。
4.在“Java EE Version”窗口中，选择适合你的应用服务器版本以及JAVA版本。如果不确定，可以选择默认值。Servlet是默认勾选上的，如果没有默认勾选也可以选择手动。
5.最后点击"Create"按钮，完成Web项目创建。
如果是第一次创建Web项目，我们的IDEA可能会需要下载或加载一些东西，等进度条加载完成后，即可创建成功。创建完成后，如图所示。
创建完成后，IDEA会为我们自动生成一个Servlet和JSP页面，我们可以试着运行一下。
点击右上角的小三角，启动我们的Tomcat服务器。
启动完后，IDEA会自动在我们的默认浏览器中打开index.jsp。
到这里，我们的第一个JavaWeb项目就建立完成啦。
在下个章节中我会列出几个在创建过程中的常见问题，还有详细的一些代码示例（Servlet请求、连接数据库等）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb924019797bcff8292c11a68eb2c518/" rel="bookmark">
			坦克大战GUI版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计内容：坦克大战GUI版本 1. 设计目标 保留课程设计二完成的坦克大战控制台版本的所有功能，用Qt实现图形界面
以下为课程设计二中实现的功能（略长，可跳过）：
1.1模仿设计四类游戏模型/属性： 游戏地形 砖墙：除四周围墙外均可被一级子弹打穿
海水：坦克和子弹均不可穿越
铁墙：可被二级子弹打穿
森林：坦克和子弹均可穿越，但显示上会被森林覆盖
基地：“★”表示基地中心，被打中则游戏结束
游戏道具 坦克：玩家可以增加一条命。
炸弹：全屏敌人遭到爆炸攻击，全数毁灭。
三种坦克属性： 生命值：即HP，表示坦克可以被子弹命中多少次
攻击力：一方面表现为子弹种类，一级子弹只能打穿砖墙，二级子弹可打穿铁墙；另一方面表现为子弹射速，即子弹的移动速度
移动速度：坦克的移动速度
五种类型的坦克： 轻型坦克：移动速度普通，一级子弹，子弹射速普通，生命值为1
装甲车：移动速度快，一级子弹，子弹射速普通，生命值为2
反坦克炮：移动速度普通，二级子弹，子弹射速快，生命值为2
重型坦克：移动速度普通，一级子弹，子弹射速普通，生命值为3
玩家坦克：移动速度普通，一级子弹，子弹射速普通，生命值为10
1.2实现基本游戏逻辑： 按照一定的策略刷出敌军坦克，敌军坦克随机移动并攻击。玩家控制的坦克在基地旁边刷出
玩家控制的坦克通过灵活移动保卫基地不被摧毁并消灭敌军坦克
游戏过程中在地图上会随机刷出道具，玩家可通过道具强化自己
失败条件：基地被摧毁或者玩家生命耗尽
胜利条件：消灭所有敌军坦克
1.2.1实现当前局的状态栏 显示玩家生命值、敌军剩余坦克数量
游戏结束时显示：
胜负：赢了显示“Win!“，输了显示”Game Over”；
得分：根据玩家消灭的敌方坦克的种类和数量计算得分
1.2.2支持双人模式 游戏开始时选择模式，游戏结束时显示计分板
2. 基本实现效果 初始界面：
2.设计思路 窗口交互和图形界面的实现
2.1窗口的实现： 设计了两个窗口类：MainWindow和subWindow类
MainWindow负责游戏初始界面，subWindow负责游戏开始后的界面
窗口类可以在ui文件中可视化添加控件，并且可以接收控件点击消息、键盘消息等，可以通过为窗口类添加相应事件处理函数来实现交互。
void keyPressEvent(QKeyEvent *ev);//键盘事件处理函数 void on_pushButton_clicked();//pushbutton被按下处理函数 2.2图片和文字的显示： 主要通过QPainter实现图片和文字的绘制，在以下函数中实现：
void paintEvent(QPaintEvent *event); 关于地图的绘制：这里将界面划分为一个个小格，通过map数组记录每个小格需要显示的图片，所以在函数paintEvent中只需读取map数组中的数据即可知道在相应位置应该绘制哪张图片。坦克，子弹或地形发生改变时，调用函数update()即可实现地图的更新。
2.3界面的切换： subWindow中会涉及多个界面，如模式选择界面、游戏进行时的界面、游戏结束后的计分板界面。这里通过设置flag标志位让paintEvent函数知道应该读取哪些数据来绘制界面。例如：游戏结束条件触发时设标志位endflag为1，表示游戏结束，此时paintEvent函数读取玩家击败敌方坦克的数量和分数，并在相应位置显示。
3.游戏逻辑的控制 原来的控制台版本通过设计Control类来控制游戏的初始、进行和结束；但在Qt中因为键盘消息、时钟信号都由窗口类捕捉，所以把游戏逻辑控制部分移到了subWindow类中。
3.1地图上的坦克、子弹变量： 在subWindow类的数据成员中存储着地图上现存的坦克指针（包括地方坦克和玩家坦克），而Tank类的数据成员中有其控制的子弹，通过遍历这些坦克及其控制的子弹并调用其move函数实现这些模型的运动。
约定同一时刻存在的敌方坦克数量最多为3，当有敌方坦克被摧毁并且有备用坦克时，刷新新的敌方坦克。玩家被击中时退回其出生地。
3.2坦克、子弹的移动： 通过设置几个时间间隔不同的时钟QTimer，并将时钟信号与槽函数…_move连接，每隔一段时间调用坦克或子弹的move函数，实现坦克和子弹移速的控制。
3.3整体逻辑的控制： 最最主要的游戏逻辑控制在subWindow中的bullet_move函数中，因为坦克的消亡、玩家坦克血量的减少、基地被摧毁等与游戏结束触发条件相关的事件均由子弹引发。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb924019797bcff8292c11a68eb2c518/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73fcdd03bf3d42090b58b126597a9416/" rel="bookmark">
			Altium Designer (AD)安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载安装包。
链接：https://pan.baidu.com/s/15iM7AlDXJs0QNXh60DI-Og 提取码：e4xo
2、双击运行"Installer.Exe"程序进入软件安装向导，点击next进行下一步。
3、在Select language栏下拉列表中选择“Chinese”语言，然后勾选安装许可协议，再点击Next。
4、按默认目录进行安装，当然，用户也可自行选择软件安装路径，然后耐心等到软件安装，直到显示完成。
5、完成安装，记住这里取消勾选不要运行软件，直接退出向导即可。
6、接下来将补丁文件下的“shfolder.dll”复制到源程序安装目录下；默认安装目录【C:\Program Files\Altium\AD】
7、因为没有在创建桌面快捷方式，所以可以在电脑左下角搜索并打开软件，点击界面中的【Add standalone license file】；
8、将会弹出一个窗口，然后打开软件初始安装包ad211 unis licewnses文件夹，找到.alf文件，单击选中它后再点击打开；
9、软件将会自动显示软件许可有效期至2030年，表示已经成功激活，可免费使用所有功能；
10、接下来进行汉化，点击右上角的齿轮图标，找到General页面，勾选“Use localized resources”，将会弹出一个界面，依次选择OK就可以了；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b99a727ed96d931d27c75dacf5a65596/" rel="bookmark">
			NB智能燃气报警器参数及功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fa41abafef8c7f6c449c46ace47f603/" rel="bookmark">
			AI视频智能分析系统方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20d0cd6fd05153df9c485e615619db67/" rel="bookmark">
			Vivado硬件调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vivado硬件调试 ILA (Integrated Logic Analyzer) 集成逻辑分析仪：监控逻辑内部信号和端口信号。
一、例化ILA添加调试信号 添加IP核
​ 根据要观测信号的属性设置探针属性
创建完成
​ 例化模板
​ 例化;
​
综合实现，生成bit流;
下载bit文件至开发板;
​ 设置触发条件
​ 抓取结果
​ 抓取信号窗口的个数
​ 等待抓取
​ 抓取状态： 调试完后，删除例化的调试模块和IP核，重新生成bit文件。
二、综合后在网表里添加调试信号： 打开综合设计文件，调整窗口为Debug模式；
​ 在”Nets“中选择要调试的信号，右键选择”Mark Debug“；
​ 一些信号可能会被EDA优化，无法显示完整的数据位宽，此时需要在代码中修改，并重新综合。示例如下：
// 添加debug属性，此时EDA不会对该信号进行优化 (* mark_debug = "true" *)reg [24:0] counter; 单击”Set Up Debug“
​ ​ ​ ​ ​ // xdc文件中多出来的完整代码： set_property MARK_DEBUG true [get_nets {Led_OBUF[0]}] set_property MARK_DEBUG true [get_nets {Led_OBUF[1]}] set_property MARK_DEBUG true [get_nets {Led_OBUF[2]}] set_property MARK_DEBUG true [get_nets {Led_OBUF[3]}] set_property MARK_DEBUG true [get_nets Rst_n_IBUF] create_debug_core u_ila_0 ila set_property ALL_PROBE_SAME_MU true [get_debug_cores u_ila_0] set_property ALL_PROBE_SAME_MU_CNT 1 [get_debug_cores u_ila_0] set_property C_ADV_TRIGGER false [get_debug_cores u_ila_0] set_property C_DATA_DEPTH 1024 [get_debug_cores u_ila_0] set_property C_EN_STRG_QUAL false [get_debug_cores u_ila_0] set_property C_INPUT_PIPE_STAGES 0 [get_debug_cores u_ila_0] set_property C_TRIGIN_EN false [get_debug_cores u_ila_0] set_property C_TRIGOUT_EN false [get_debug_cores u_ila_0] set_property port_width 1 [get_debug_ports u_ila_0/clk] connect_debug_port u_ila_0/clk [get_nets [list Clk_IBUF_BUFG]] set_property PROBE_TYPE DATA_AND_TRIGGER [get_debug_ports u_ila_0/probe0] set_property port_width 4 [get_debug_ports u_ila_0/probe0] connect_debug_port u_ila_0/probe0 [get_nets [list {Led_OBUF[0]} {Led_OBUF[1]} {Led_OBUF[2]} {Led_OBUF[3]}]] create_debug_port u_ila_0 probe set_property PROBE_TYPE DATA_AND_TRIGGER [get_debug_ports u_ila_0/probe1] set_property port_width 25 [get_debug_ports u_ila_0/probe1] connect_debug_port u_ila_0/probe1 [get_nets [list {counter[0]} {counter[1]} {counter[2]} {counter[3]} {counter[4]} {counter[5]} {counter[6]} {counter[7]} {counter[8]} {counter[9]} {counter[10]} {counter[11]} {counter[12]} {counter[13]} {counter[14]} {counter[15]} {counter[16]} {counter[17]} {counter[18]} {counter[19]} {counter[20]} {counter[21]} {counter[22]} {counter[23]} {counter[24]}]] create_debug_port u_ila_0 probe set_property PROBE_TYPE DATA_AND_TRIGGER [get_debug_ports u_ila_0/probe2] set_property port_width 1 [get_debug_ports u_ila_0/probe2] connect_debug_port u_ila_0/probe2 [get_nets [list Rst_n_IBUF]] set_property C_CLK_INPUT_FREQ_HZ 300000000 [get_debug_cores dbg_hub] set_property C_ENABLE_CLK_DIVIDER false [get_debug_cores dbg_hub] set_property C_USER_SCAN_CHAIN 1 [get_debug_cores dbg_hub] connect_debug_port dbg_hub/clk [get_nets Clk_IBUF_BUFG] 可以直接在xdc文件中添加所要调试的信号探针。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20d0cd6fd05153df9c485e615619db67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9ad87bc13b5daefe8bc268ec8baee41/" rel="bookmark">
			Docker-Compose部署ELK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker-Compose部署ELK(保姆级教程) 部署elk 创建目录 和文件配置docker-compose并启动打开kibana 1.创建docker-elk目录 （此目录任意 推荐使用此 否则需要更改compose配置） sudo mkdir /opt/docker_elk 2.创建logstash配置文件 sudo mkdir /opt/docker_elk/logstash sudo touch /opt/docker_elk/logstash/logstash.conf 3.配置logstash.conf，其内容如下 input { tcp { mode =&gt; "server" host =&gt; "0.0.0.0" port =&gt; 4560 codec =&gt; json } } output { elasticsearch { hosts =&gt; "es:9200" index =&gt; "logstash-%{+YYYY.MM.dd}" } } 在这里指定了输入的日志的端口是4560，那么下面对外暴露的端口也必须是4560。 此端口为logStash 通信端口 可更改（更改同样修改 compose 配置）
4.创建docker-compose.yml文件 sudo touch /opt/docker_elk/docker-compose.yml 5.配置 docker-compose并启动 sudo cd /opt/docker_elk sudo vi docker-compose.yml 配置内容如下
version: '3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9ad87bc13b5daefe8bc268ec8baee41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/318f9dc208168d16f4f5519d76b01de4/" rel="bookmark">
			python调用C语言接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python调用C语言接口 注：本文所有示例介绍基于linux平台
在底层开发中，一般是使用C或者C++，但是有时候为了开发效率或者在写测试脚本的时候，会经常使用到python，所以这就涉及到一个问题，用C/C++写的底层库，怎么样直接被python来调用？
python作为一门胶水语言，当然有办法来处理这个问题，python提供的方案就是ctypes库。
ctypes ctypes是python的外部函数库，它提供了C语言的兼容类型，而且可以直接调用用C语言封装的动态库。
如果各位有较好的英语水平，可以参考ctypes官方文档，但是我会给出更详细的示例，以便各位更好地理解。
库的封装 C代码如果要能够被python调用，首先我们先得把被调用C接口封装成库，一般是封装成动态库。编译动态库的指令是这样的：
gcc --shared -fPIC -o target.c libtarget.so 在这里，
--shared -fPIC 是编译动态库的选项。
-o 是指定生成动态库的名称
在linux下，一般的命名规则是：静态库为lib.a，动态库为lib.so
target.c为目标文件，在编译时常有更复杂的调用关系和依赖，这里就不详说，有兴趣的朋友可以去了解了解gcc编译规则。
在python中导入库 既然库已经封装好了，那肯定是就想把它用起来。我们可以在python中导入这个库，以导入libtarget.so为例：
import ctypes target = cdll.LoadLibrary("./libtarget.so") 顺带提一下，如果在windows环境下，动态库文件是.dll文件，例如导入libtarget.dll:
import ctypes target = windll.LoadLibrary("./libtarget.dll") 在这里，可以将target看成是动态库的示例，直接可以以变量target来访问动态库中的内容。
LoadLibrary("./libtarget.so")表示导入同目录下的libtarget.so文件。
细心的朋友已经发现了，在导入时，linux环境下使用的是cdll，而windows环境下使用的是windll。
这里涉及到C语言的调用约定，gcc使用的调用约定是cdecl，windows动态库一般使用stdcall调用约定，既然是调用约定，就肯定是关于调用时的规则，他们之间的主要区别就是cdecl调用时由调用者清除被调用函数栈，而stdcall规定由被调用者清除被调用函数栈。
关于这个就不在这里赘述了，有兴趣的朋友可以看看我另外一篇博客：栈帧结构以及函数调用约定
hello world！ 学会了封装动态库，学会了导入库，接下来我们就要动手写一个hello_world,毕竟学会了hello_world就算是入门了。
代码如下：
target.c:
#include &lt;stdio.h&gt; void hello_world(void) { printf("hello downey!!\r\n"); } 编译动态库：
gcc -fPIC --shared target.c -o libtarget.so test.py:
from ctypes import * test = cdll.LoadLibrary("./libtarget.so") test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/318f9dc208168d16f4f5519d76b01de4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f070beaa98ea723d01a2f2f37c0f234f/" rel="bookmark">
			计算机的运算方法--乘法运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
前言一、乘法运算的分类二、乘法运算简介 1.原码一位乘法2.原码两位乘法3.补码一位乘法4.补码两位乘法 前言 在计算机中，乘法运算是一种很重要的的运算，有的机器直接由硬件乘法器完成乘法运算，有的机器内没有乘法器，但可以按机器做乘法运算的方法，用软件编程实现。因此，学习乘法运算有助于乘法器的设计，也有助于乘法编程。
一、乘法运算的分类 简单来说乘法运算基础主要分为四类：1.原码一位乘法，2.原码二位乘法，3.补码一位乘法，4.补码二位乘法。
二、乘法运算简介 1.计算机乘法方式由来 计算机的乘法运算是根据乘法笔算的方式改进得到。
乘法笔算方式特点：1.被乘数A左移多次。
2.4个积位的相加运算。
但是不难发现笔算乘法的方式不适合计算机的运算方式;
1.4个积位难以一次相加。
2.乘积位数增加一倍，造成器材浪费，时间增加。
改进方式：
由此可得：两数相乘的过程可以看为加法和移位的过程两种运算（2^-1可以看做向右移位），这对计算机来说是非常容易实现的。
假定被乘数A = 0.1101， 乘数B = 0.1011。 我们根据上面的分析可以得到下面的步骤过程。
有上述运算过程可以归纳如下：
1.两个n位数相乘需要经过n次加法运算，n次移位。
2.由乘数的末尾来确定被乘数是否与 原部分积相加，然后右移一位，形成行的部分积，同时乘数也右移一位，由次低位作为新的末尾，空出的最高位放部分积的最低位。
3.每次做加法，部分积的最高位和被乘数相加。
2、原码一位乘法 原码乘法的过程和上述数值相乘的过程基本相似，但是有几个注意点：
1：乘积的符号由乘数和被乘数的符号异或得到。
2：乘积的数值由乘数和被乘数的数值绝对值相乘得到。
3：部分积取 n + 1 为来确保过程中绝对值 &gt;= 1 的情况。
4：过程中的部分积的移位全都为逻辑移位。（因为是两个实数相乘没有符号）。
3、原码两位数相乘 为了提高运算速率可以采用原码两位乘法，和原码一位乘法类似，符号位和数值位分开运算，采用两位乘数来决定部分积来提高效率。
我们不难知道两位乘数可以得到四种状态，分别对应了四种操作，如下：
其中的2倍被乘数的操作可以通过左移移位得到。但是三倍被乘数的操作比较难以得到，我们可以把3 = 4 - 1（11 = 100 - 1）；可以先完成减去一倍被乘数的操作，第二步完成加上四倍被乘数的操作。 这样的话我们可以在完成的第一步以后，将“加上四倍被乘数的操作”来记录在Cj触发器中（看作进位），左移两位部分积，高两位乘数+1来完成第二步。
两位乘数结合Cj寄存器共有三位，共有八种情况，如下：
在进行-x*运算的时候，计算机一般都采用+【-x】补来实现，所以在计算过程中参与运算的是操作数绝对值的补码，运算过程的右移操作要遵循补码的移位规则。还有过程中出现的+【2x】补使部分积的绝对值&gt;2,所以采用三位符号位来确保无误，其中最高位为真正的符号位。 此外与原码一位乘法不同的是，如果乘数的位数为偶数那么需要在最高位补00，奇数则补0。这是因为为了避免Cj寄存器存在1的情况未参加运算。所以最后一次运算不需要进行移位。
不难分析，位数为偶数需要做n / 2 + 1 次加法， n / 2 次 移位。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f070beaa98ea723d01a2f2f37c0f234f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/141/">«</a>
	<span class="pagination__item pagination__item--current">142/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/143/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>