<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ddb40a858fdc0a7dee63d645a4737a9/" rel="bookmark">
			【MTK平台】如何正确测量使用蓝牙OPP传输文件时的电流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
在使用蓝牙OPP传输文件的时候，功耗由如下两部分组成：
1.蓝牙controller的功耗
2. AP端CPU的功耗
其中以第二部分对电流测量的影响最大。
这主要是因为，蓝牙OPP传输文件时，需要将文件源做拆分并打包封装。而此时的CPU loading是会受到当时OPP传输的速率影响的。
如果传输速率快的话，CPU loading相应就会重一些，电流会高一些；反之，CPU loading会轻一些，电流也会小一些。
综上述所述，正确测量“蓝牙OPP传输文件”时的电流的方法如下：
一.测量前准备
1.屏蔽室（减小环境对传输速率的影响）
2. 2支以上测试机（排除个别机器RF不良对测试的影响）和1支辅助机
-测试机与辅助机建议开启飞航模式后仅开启BT，若不开飞航模式则请关闭Wifi
-关闭Location: Settings -&gt; Location关闭
-关闭Lift to wake: Settings -&gt; Display -&gt; Lift to wake关闭
3.固定大小的文件（建议文件大小在40～50MB，以便统计传输时间）
4.测量电流时请先将MtkLogger关闭
二.测量时操作
1.除测试机和辅助机外，关闭其他设备的蓝牙和Wifi
2.测试机和辅助机之间距离15 cm左右，且并排平放于桌上
3.开始传输前先开始进行测量电流，确认待机电流无异常
4.发送方发送文件并暗屏，接收方点选确认接收后暗屏，开始计时
5.传输完毕后停止计时，并等待约10秒再停止录制电流
三.测试数据的统计
1.计算文件传输过程中的平均电流（PowerMonitor等tool会完成统计）
2.计算传输速率（文件大小/传输时间）
在做后续对比时，需要确保在传输速率相当的情况下，再来比较平均电流，这样的比较才有意义。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0742025049f3f95ae07ab7847b41b99b/" rel="bookmark">
			【python与机器学习3】感知机和门电路：与门，或门，非门等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 电子和程序里的与门，非门，或门，与非门 ，或非门，异或门
1.1 基础电路
1.2 所有的电路情况
1.3 电路的符号
1.4 各种电路对应的实际电路图
2 各种具体的电路
2.1 与门（and gate）
2.1.1 定义：A&amp;B / A and B
2.1.2 and gate的写法
2.1.3 逻辑展开
2.1.4 电路图形
2.1.5 python 里代码
2.2 或门 （or gate）
2.2.1 定义
2.2.2 写法
2.2.3 逻辑展开
2.2.4 电路图形
2.2.5 python代码
2.3 非门 not gate 2.3.1 定义
2.3.2 写法
2.3.3 逻辑表达式
2.3.4 电路图表示
2.3.5 python代码
2.4 与非门 nand gate (not and gate)
2.4.1 定义
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0742025049f3f95ae07ab7847b41b99b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c5b819ed90516ef257a48b7c0c7e71/" rel="bookmark">
			C&#43;&#43;入门编程四(指针、结构体、const修饰指针(深度理解))
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 指针的基本概念针所占内存空间空指针和野指针const修饰指针指针和数组指针和函数指针、数组、函数结合案例结构体的定义和使用结构体数组结构体指针结构体嵌套结构体结构体做函数参数结构体中 const使用场景结构体案例案例1案例2 基于b站黑马c++视频做的笔记，仅供参考和复习！！！ 指针的基本概念 指针的作用： 可以通过指针间接访问内存
指针中存放的数据是地址，通过地址即门牌号取址来找到对应的存储数据。
内存编号是从0开始记录的，一般用十六进制数字表示。可以利用指针变量保存地址。 指针的进阶可以看看我的另一篇博文
// 1 定义指针 int a = 10; //指针定义的语法： 数据类型 * 指针变量名； int* p;	//变量名叫p，类型为int *，即整数类型的指针 //char *q 代表字符类型的指针 //让指针记录变量a的地址 p = &amp;a; cout &lt;&lt; "a的地址为：" &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; "指针p为：" &lt;&lt; p &lt;&lt; endl; //2 使用指针 //可以通过解引用的方式来找到指针指向的内存 // 指针前加 * 代表解引用，找打指针指向的内存中的数据 *p = 100; cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "*p = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9c5b819ed90516ef257a48b7c0c7e71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01c3dd50ede27766a331ae7ea9fa5e29/" rel="bookmark">
			CAT: LoCalization and IdentiﬁcAtion Cascade Detection Transformer for Open-World Object Detection
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAT: LoCalization and IdentiﬁcAtion Cascade Detection Transformer for Open-World Object Detection 摘要1介绍2 问题定义3 方法3.1 整体架构3.2 级联解耦译码方法3.3 自适应伪标记机制3.4.训练和推理 4，实验4.1 数据集和评估指标4.2 实现细节4.3.与最先进方法的比较4.4 消融实验 5.与先前工作的关系6 总结致谢 for Open-World Object Detection) 摘要 “面向开放世界目标检测（OWOD）作为一个更一般且具有挑战性的目标，要求从已知对象的数据中训练的模型能够检测已知和未知的对象，并逐渐学会识别这些未知对象。现有的采用标准检测框架和固定伪标注机制（PLM）的工作存在以下问题：（i）检测未知对象实质上减少了模型检测已知对象的能力。 （ii）PLM未充分利用输入的先验知识。 （iii）PLM的固定选择方式不能保证模型在正确方向上进行训练。我们观察到，人类在下意识中更倾向于专注于所有前景对象，然后逐一详细识别每个对象，而不是同时定位和识别单个对象，以减轻混淆。这激发了我们提出一种新颖的解决方案，称为CAT：LoCalization和IdentiﬁcAtion Cascade Detection Transformer，通过级联解码的方式通过共享解码器解耦检测过程。与此同时，我们提出了自适应伪标注机制，将模型驱动的PLM与输入驱动的PLM相结合，并自适应地生成强大的未知对象的伪标签，显著提高了CAT检索未知对象的能力。在两个基准测试上的实验证明，即MS-COCO和PASCAL VOC，我们的模型优于最先进的方法。代码公开可用于 https://github.com/xiaomabufei/CAT。”
1介绍 “开放世界目标检测（OWOD）是计算机视觉中更为实际的检测问题，使人工智能（AI）能够更智能地应对真实场景中的更多困难。在OWOD范 paradigm 内，模型的生命周期通过迭代学习过程推动。在每个阶段，仅由已知对象训练的模型需要同时检测已知对象、定位未知对象并将其识别为未知类别。然后，人类注释员逐渐标记其中一些已标记的未知类别。给定这些新添加的注释后，模型将继续在不重新从头开始训练的情况下增量更新其知识。”
最近，Joseph等人[21]提出了一种基于两阶段Faster R-CNN [38]流程的开放世界目标检测器ORE。ORE利用了自动标注步骤来获得训练模型以检测未知对象的伪未知。它学习了一个基于能量的二元分类器，以区分未知类别和已知类别。然而，它的成功在很大程度上依赖于一个保留的验证集，该集合被用来估计基于能量的分类器中未知对象的分布。接着，一些方法[29, 43–45]试图扩展ORE并取得了一些成功。为了缓解ORE中的问题，Gupta等人[17]提出了在合理的情况下使用检测变压器 [4,46] 进行OWOD，并直接利用了DDETR [46]的框架。此外，他们提出了一种基于注意力的PLM，根据注意力分数为未知对象选择伪标签。
对于现有研究，我们发现了以下阻碍问题：
（i）由于包含检测未知对象的任务，模型检测已知对象的能力显著下降。为了减轻已知和未知对象之间的混淆，人们更倾向于拆解开放世界目标检测的过程，而不是像大多数标准检测模型那样同时定位和识别开放世界对象。
（ii）据我们所知，在现有的OWOD PLM中，模型利用已知对象的学习过程引导生成未知对象的伪标签，但不利用输入的先验条件（例如文本、光照等）。结果是，模型无法学习超出数据注释范围的知识。
（iii）PLM的固定选择方式不能保证模型在正确方向上学习检测未知对象，由于伪标签的不确定质量。模型可能更差地检测未知对象。
面对新场景时，人类更倾向于聚焦于所有前景对象，然后详细分析它们[6]，如图1所示。受此启发以及前述观察，我们提出了一种新颖的LoCalization and IdentificAtion Cascade Detection Transformer。CAT包括三个专用组件，即共享变压器解码器、级联解耦解码方式和自适应伪标注机制。通过级联解耦解码方式，共享变压器解码器解耦了定位和识别过程。因此，识别过程对于定位过程的影响被降低。在这种情况下，模型可以更好地定位更多前景对象，从而提高检索未知对象的能力。同时，独立的识别过程使模型能够更有重点地进行识别，从而减轻未知对检测已知对象的影响。在这种解码方式中，前者用于定位，后者用于识别。自适应伪标注机制维护CAT探索超出已知对象知识的能力，并根据模型训练过程自适应调整伪标签生成。我们的贡献可以总结为四点：
我们提出了一种新颖的定位和识别级联检测变压器（CAT），具有出色的检索未知对象的能力，并减轻检测未知对象对已知对象检测的影响。
受人们在面对开放场景时的下意识反应的启发，我们提出了级联解耦解码方式，通过共享解码器解耦了解码过程。
我们引入了一种新颖的伪标注机制，在训练过程中自适应地结合了模型驱动和输入驱动的伪标注，以生成强大的伪标签并探索超出已知对象知识的范围。
我们在两个流行的基准测试上进行了大量实验证明了CAT的有效性。在OWOD、IOD和开放集检测方面，CAT优于最先进的方法。对于OWOD，CAT在未知召回方面相对于SOTA方法实现了9.7%到12.8%的绝对增益。
图1.当面对开放世界中的新场景时，人类会下意识地关注所有前景物体，然后详细识别它们，以减轻已知和未知物体之间的混淆，从而获得清晰的视图。受此启发，我们的CAT利用共享解码器以级联解码的方式将定位和识别过程解耦，其中前一个解码过程用于定位，后者用于识别。
2 问题定义 在时间 𝑡，令 𝐾𝑡 = {1, 2, … , 𝐶} 表示已知对象类别的集合，令 𝑈𝑡 = {𝐶 + 1, …} 表示可能在测试时间遇到的未知类别。已知对象类别 𝐾𝑡 在数据集 𝐷𝑡 = {𝐽𝑡,𝐿𝑡} 中标记，其中 𝐽𝑡 表示输入图像，𝐿𝑡 表示时间 𝑡 的相应标签。训练图像集包括 𝑀 张图像 𝐽𝑡 = {𝑖1,𝑖2, … , 𝑖𝑀} 和相应的标签 𝐿𝑡 = {ℓ1,ℓ2, … , ℓ𝑀}。每个 ℓ𝑖 = {𝑇1,𝑇2, … ,𝑇𝑁} 表示一组具有类别标签 𝑐𝑛 ⊂ 𝐾𝑡 和位置信息的 𝑁 个对象实例，其中 𝑥𝑛,𝑦𝑛,𝑤𝑛,ℎ𝑛 分别表示边界框的中心坐标、宽度和高度。开放世界目标检测去除了传统目标检测中的人为假设和限制，使目标检测任务更贴近实际生活。它要求训练好的模型 𝑀𝑡 不仅能够检测先前遇到的已知类别 𝐶，还能够将未知类别的实例识别为属于未知类别。此外，它要求对象检测器能够增量更新新的知识，并且这个循环在检测器的生命周期内一直进行。在增量更新阶段，由 𝑀𝑡 识别的未知实例被手动注释，并且连同它们相应的训练示例一起，将 𝐷𝑡 更新为 𝐷𝑡+1，将 𝐾𝑡 更新为 𝐾𝑡+1 = {1, 2, … , 𝐶, … , 𝐶 + 𝑛}，模型将这 𝑛 个新类别添加到已知类别中，并在整个数据集 𝐷𝑡+1 上不重新训练的情况下更新为 𝑀𝑡+1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01c3dd50ede27766a331ae7ea9fa5e29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/180fdf484fe6cfc092c217ff4b49ce06/" rel="bookmark">
			TAFFC | 清华大学刘永进教授课题组提出基于情绪字典与注意力机制的多模态情绪分布学习方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与实验室诱发的单一情绪不同，真实世界中人类个体往往在同一时刻展现的多种混合情绪状态，比如悲喜交加、又惊又喜等。清华大学刘永进教授课题组提出一种从多模态数据中学习并预测混合情绪的方法，该项研究于2023年被IEEE Transactions on Affective Computing期刊录用，论文的共同第一作者为刘永进教授指导的博士后刘舫和博士生杨培，刘永进教授指导的博士生舒叶芷、访问学者闫飞博士、硕士毕业生张冠华共同参与了讨论和论文撰写。IEEE Transactions on Affective Computing是国际上情感计算领域内的著名期刊，SCI影响因子为11.2。
全文官方链接：
https://doi.org/10.1109/TAFFC.2023.3334520
多模态情绪分析作为情绪计算的一个重要方向，近年来受到越来越多的关注。大多数现有的多模态情绪识别研究针对的是一个分类任务，目的是为几种不同模态的输入数据（包括多媒体信号和生理信号）的组合分配一个特定的情绪类别。与单一情绪识别相比，越来越多的心理学证据表明，不同的离散情绪可能同时存在，这促进了混合情绪识别研究的发展，即识别基本情绪的混合。
虽然当前的大多数研究将其视为一个多标签分类任务，但在这项工作中，本文关注同时出现积极和消极情绪的挑战性情况，并提出了一种多模态混合情绪识别框架（EmotionDict）。EmotionDict的主要特点包括：
（1）受心理学研究的启发，混合状态可以用基本情绪的组合来表示，将混合情绪识别视为标签分布学习任务。设计情绪字典（Emotion Dictionary）作为在共享的隐空间中的情绪表征。
（2）虽然大多数多模态情绪分布研究建立在多媒体信号（如文本、图像、音频和视频）的基础上，但本文使用生理和显式行为多模态信号，包括脑电（EEG）、外周生理信号和面部视频。多模态信号与中央或外周神经系统以及运动皮层有关，各种模态具有不同的特点。
（3）本文进一步设计了辅助任务来学习各模态的注意力进行多模态融合。在两个数据集上的实验结果表明，本文的方法在混合情绪识别方面超过了现有的最先进的方法。
图 1.多模态情绪分布学习任务示例。
情绪识别已经成为情绪计算领域的一个重要话题，不仅由于它是许多下游任务和应用（例如，媒体分析任务、人机交互和心理治疗）的基础，而且因为情绪在人的心理状态中起着关键作用。目前学术研究中情绪空间主要由两种模型描述：
（1）离散模型，它将情绪状态映射到一组基本情绪类别，如快乐、悲伤、惊讶、恐惧、愤怒和厌恶；
（2）维度模型，它将空间分为“效价-唤醒度”（valence-arousal，VA）维度或“效价-唤醒度-控制度”（valence-arousal-dominance，VAD ）维度，其中效价表示情绪是积极的还是消极的，唤醒度反映情绪的强度，控制度指用户是否可以控制情绪。
离散模型主要面向分类问题，将输入映射到预定义的类别。维度模型试图在连续空间内对情绪建模，能够提供比离散模型更丰富的情绪表示。因此，这两种情绪模型在理解和建模情绪方面具有互补作用。尽管近期的研究在情绪识别方面取得了很有希望的结果，但仍然存在一个重要问题：大多数情绪识别工作只从输入信号中识别出主导情绪，而现有研究表明，用户可以同时以不同的强度体验两个或更多情绪感受。当前的单一情绪识别研究没有考虑到用户情绪的多样性、复杂性和模糊性。本文针对混合情绪，考虑多种基本情绪的强度，改进了基于离散模型的情绪识别方法。混合情绪识别被视为情绪分布学习（emotion distribution learning，EDL）任务。
本文利用了外显行为的面部视频和生理信号，包括脑电（EEG）、光电容积图（PPG）和皮肤电反应（GSR）。虽然多模态信号可以提供补充的情绪信息，但整合涉及不同神经系统部分（运动皮层、中枢和外周神经系统）的多模态信号使得我们的情绪分布学习任务更具挑战性。本文多模态情绪分布学习的动机如下：
（1）由于多模态信息可以从不同的角度反映混合情绪的多个方面，因此提出将混合情绪分析问题作为多模态分布学习任务来解决。考虑到情绪是用户客观感受，在外显行为和生理表现中反映，本文使用脑电、外周生理信号（即PPG和GSR）和面部视频来进行混合情绪分析。
（2）受“情绪的普遍心理进化理论（General Psychoevolutionary Theory of Emotion）”的启发，该理论指出：（i）存在少数基本的、原始的或典型的情绪；（ii）所有其他情绪都是混合或派生状态，即它们以基本情绪的组合、混合或复合形式出现。
图 2. EmotionDict多模态情绪分布学习方法框架。首先，采用一个情绪字典模块将混合情绪分解为一组基本情绪向量的组合和其权重；然后，基于多模态融合设置辅助任务，为情绪字典提供注意力相关的约束，增强情绪分布学习性能；最后，由分类器预测最终的情绪分布结果。
此外，受到深度学习领域的隐空间特征分解和学习方法的启发，提出使用一组基本隐空间向量及其权重的组合来表示每个情绪分布，即提出了一种EmotionDict的情绪分布学习框架，通过在隐空间中学习由一组基本情绪表示组成的情绪字典，为情绪分布学习高效的情绪特征。最后，多模态分析中最重要的问题之一是对每个模态的重要性进行建模并建立恰当的融合机制，而在混合情绪的情况下更加困难，本文进一步设计了一个多模态集成模块，利用情绪字典的注意力机制辅助模态信息融合。
本文的主要贡献如下：（1）将混合情绪分析问题视为一种多模态信号的分布学习任务，其中包括用户的外显行为和生理信号；通过整合外显行为和生理反应，可以提供补充信息来进行情绪识别。提出了一种端到端的混合情绪识别模型EmotionDict用于情绪分布学习任务，可以融合多模态信号以提高情绪分布学习的性能。（2）受到混合情绪可以由一组基本情绪元素表示的启发，在情绪分布学习方法中设计了一个情绪字典模块，将情绪状态的情绪特征分解为一组基本情绪元素和它们在隐空间中的相关权重的加权组合。（3）设计了两个辅助任务作为显式的监督来约束对情绪字典的注意力，利用多模态信号的特征相关性来帮助提取情绪特征，并进一步改善情绪分布学习的性能。此外，这两个辅助任务通过整合异构模态（行为和生理信号）的一致性和多样性信息，改善了多模态特征融合效率。
图 3. 对比方法与本文方法预测的情绪分布结果示例
图 4. 情绪字典中基本情绪元素数量对情绪分布学习性能的影响。三角形表示数值越小越好，圆形表示数值越大越好。
EmotionDict利用用户的外显行为（面部视频）和生理指标（EEG、PPG和GSR）信息的组合作为输入进行情绪分布学习，以上多模态信号可以表示用户情绪的不同方面。大量实验证明，本文提出的情绪分布学习模型在被试依赖和被试独立的设置上均取得了优越的性能。
图 5. DMER数据集上情绪字典可视化图
—— End ——
仅用于学术分享，若侵权请留言，即时删侵！
加入社群 欢迎加入脑机接口社区交流群，
探讨脑机接口领域话题，实时跟踪脑机接口前沿。
加微信群：
添加微信:RoseBrain【备注：姓名+行业/专业】。
加QQ群：913607986
欢迎来稿 1.欢迎来稿。投稿咨询，请联系微信：RoseBrain
2.加入社区成为兼职创作者，请联系微信：RoseBrain
一键三连「分享」、「点赞」和「在看」
不错每一条脑机前沿进展 ~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/165225deedc792531b9cdf912a3a67d1/" rel="bookmark">
			机器学习系列--R语言随机森林进行生存分析（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随机森林（Breiman 2001a）（RF）是一种非参数统计方法，需要没有关于响应的协变关系的分布假设。RF是一种强大的、非线性的技术，通过拟合一组树来稳定预测精度模型估计。随机生存森林（RSF）（Ishwaran和Kogalur，2007；Ishwaraan，Kogalur、Blackstone和Lauer（2008）是Breimans射频技术的延伸从而降低了对时间到事件数据的有效非参数分析。
R语言随机森林进行生存分析需要使用到randomForestSRC包，是对Breimans随机森林的统一处理用于生存、回归和分类问题。randomForestSRC包还有一个用于做图的ggRandomForests包，搭配使用，今天咱们来介绍一下怎么使用randomForestSRC包进行随机森林生存分析，内容有点多，咱们分2章来介绍。
咱们先导入数据和R包
library(ggRandomForests) library(randomForestSRC) library(ggplot2) library("dplyr") pbc&lt;-read.csv("E:/r/test/pbc2.csv",sep=',',header=TRUE) 这是一个胆管炎数据（公众号回复：胆管炎数据2，可以获得数据），years:生存时间，status：结局指标，是否死亡，treatment是否DPCA治疗，age年龄，sex性别，ascites是否有腹水，hepatom是否有肝肿大，spiders是否有蜘蛛痣，edema水肿的级别，bili胆红素，chol胆固醇，albumin白蛋白，copper尿酮，alk碱性磷酸酶，sgot：SGOT评分，trig甘油三酯，platelet血小板，prothrombin凝血酶时间，stage组织学分型
我们对数据处理一下，把treatment这个变量变成因子
pbc$treatment&lt;-factor(pbc$treatment) 接下来咱们把数据分成两组，有treatment数据的为测试组，treatment数据缺失的为对照组。
pbc.trial &lt;- pbc %&gt;% filter(!is.na(treatment)) pbc.test &lt;- pbc %&gt;% filter(is.na(treatment)) 我们先用生存分析做一遍，等下可以和随机森林进行比较，接下来我们用gg_survival对测试组生成生存分析的数据，这个函数挺方便使用的，生成了生存分析的详尽数据
gg_dta &lt;-gg_survival(interval = "years", censor = "status", by = "treatment", data = pbc.trial, conf.int = 0.95) 绘图
plot(gg_dta) + labs(y = "Survival Probability", x = "Observation Time (years)",color = "Treatment", fill = "Treatment") + theme(legend.position = c(0.2, 0.2)) + coord_cartesian(y = c(0, 1.01)) 或者绘制成这种累积风险图
plot(gg_dta, type = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/165225deedc792531b9cdf912a3a67d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ab8380ab2bfc612c4959ffa3c52cbae/" rel="bookmark">
			mysqldump | --lock-tables=false 和 --single-transaction 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		--lock-tables=false 和 --single-transaction 是 `mysqldump` 命令中的两个选项，它们都与如何处理表的锁定有关，但它们的工作方式和用途有所不同。
1. --single-transaction : 这个选项是用来针对支持事务的存储引擎（主要是 InnoDB）的数据库表。当使用这个选项时，`mysqldump` 会在导出开始前启动一个新的事务，以获取数据的一致性视图。因为事务在开始导出时就已经确定了数据的状态，所以之后对数据库的写入不会影响导出的内容。这个选项允许表在导出期间继续进行读写操作，从而避免了长时间的锁定和可能对应用程序造成的中断。 --single-transaction 选项通常用于确保数据导出的一致性而不需要锁表。 2. --lock-tables=false :
这个选项可以用于任何存储引擎，包括不支持事务的 MyISAM。当使用 --lock-tables=false 时，`mysqldump` 不会尝试锁定所有表。这意味着如果在导出过程中有其他的数据库写操作，可能会导致导出数据不一致。这个选项适用于那些无法接受锁定导致的停机时间，同时又可以容忍数据一致性问题的场景。使用这个选项时需要谨慎，因为在导出过程中，没有锁或事务来保证数据的一致性。 在大多数情况下，推荐使用 --single-transaction 选项来确保事务型存储引擎（如 InnoDB）的数据一致性导出，而且不会在导出过程中锁定表。然而，如果您的数据库中包含不支持事务的存储引擎表（如 MyISAM），或者您确定可以接受导出数据的非一致性风险，那么可以使用 --lock-tables=false 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6345f4bdbd0526543324d67d6aaf9970/" rel="bookmark">
			深入理解 golang 中的反射机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是反射
反射的使用方法
反射的应用场景
反射的性能考量
反射的最佳实践
小结
反射机制是计算机科学中的一个重要概念，程序通过反射可以在运行时访问、检测和修改自身的状态和行为。Golang 作为静态类型的编译型语言，虽然在设计上倾向于简洁和高效，但也内置了强大的反射机制。使用反射机制可以使编写更灵活、更强大的程序，但同时也可能导致程序性能下降和代码可读性变差。本文将深入讲解 Golang 的反射机制，帮助大家更好地理解和运用这一强大的特性。
什么是反射 反射机制在 Golang 中是通过 reflect 包来实现的，reflect 包提供了两个主要的类型：reflect.Type 和 reflect.Value。
reflect.Type，在 Golang 中，每个值都有一个对应的类型。类型信息包含了类型的名称、结构体字段等信息。reflect.Type 可以代表 Golang 中的任意类型，无论是基本类型还是用户自定义的类型，甚至是接口类型。reflect.Type 还有有一个重要的方法 Kind()，可以返回类型的种类，如 int、string、struct 等。reflect.Value，reflect.Value 可以表示 Golang 中的任意值。reflect.Value 有许多方法，可以用来获取值的信息，如值的类型、值的字段和方法等。此外，reflect.Value 还可以用来修改值，只要该值是可设置的。 反射的使用方法 获取类型信息，要获取一个变量的类型信息，可以使用 reflect.TypeOf 函数。例如： package main import ( "fmt" "reflect" ) func main() { var x float64 = 3.14 t := reflect.TypeOf(x) fmt.Println("Type:", t) } 上面的代码会输出“Type: float64”，因为变量 x 的类型是 float64。
获取值信息，要获取一个变量的值信息，可以使用 reflect.ValueOf 函数。例如： package main import ( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6345f4bdbd0526543324d67d6aaf9970/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8af8dd6c52729c264a19125c7b3ead71/" rel="bookmark">
			Ubuntu 上 修改swap交换空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		增加交换空间 关闭交换空间。 sudo swapoff -a 查看是否有 swap或swapfile文件（在根目录下）。 sudo dd if=/dev/zero of=/swapfile bs=1G count=16 命令解释sudo执行命令需要超级用户前缀dd用于复制和转换文件的命令if=/dev/zeroif指定输入文件。/dev/zero是一个特殊文件，读取会返回null字节(‘\0’)of=/swapfileof指定输出文件bs=1G设置块大小为1G。表示dd命令每次从输入文件读取1G的数据，然后写入到输出文件。count=16指定要复制块的数量。此命令将创建一个大小为16GB的 /swapfile 文件。 成功输出为
记录了16+0 的读入 记录了16+0 的写出 17179869184字节（17 GB，16 GiB）已复制，32.1801 s，534 MB/s 设置文件交换权限 sudo chmod 600 /swapfile 将文件设置为交换空间 sudo mkswap /swapfile 打开交换空间
sudo swapon -a 使交换空间 在系统重启后依旧生效
在 /etc/fstab 中添加一个条目。 /swapfile none swap sw 0 0 表明 /swapfile 是一个交换文件，类型为none，使用sw作为交换分区类型，并且没有特定的挂在选项（使用默认值）。
打开交换空间
sudo swapon --show 如果一切正常，你应该能够在输出中看到你的交换文件。
最后，确保交换空间的大小不会超过物理内存的大小，否则可能会导致系统性能问题。
确定物理内存
free -g 减小交换空间 关闭交换空间 sudo swapoff -a 使用 fallocate 或 truncate 命令来减小交换文件大小
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8af8dd6c52729c264a19125c7b3ead71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e773ab11319a62930c6cd8d62bdf3f2a/" rel="bookmark">
			解决IDEA上传Git 带有本地编译文件问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA 版本控制推送代码问题 IDEA开发过程中，使用版本控制Git、Svn或其他版本管理工具提交代码到远程经常遇到一些不重要的文件。这些文件是本地的文件，不需要上传，这个时候就需要通过设置，来改变。
问题解决 在IDEA通过设置，忽略这些文件提交代码时出现的文件
步骤
进入idea设置界面
路径：
File 》Settings 》Editor 》 File Types
在“ignore files and folders” 框里加入 *.iml;.idea;target;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa246b513b7bfcd061afe7a16c94c02/" rel="bookmark">
			栈与队列-＞算法实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		综述 用栈实现队列：leetcode232
用队列实现栈：leetcode225
有效的括号：leetcode20
删除字符串中的所有相邻重复项：leetcode1047
逆波兰表达式求值：leetcode150
滑动窗口最大值：leetcode239
前 K 个高频元素：leetcode347
引言 栈与队列 栈是先进后出，队列是先进先出
C++标准库是有多个版本的，其中三个最为普遍的STL版本：
HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。 以下介绍的都是 SGI STL 里面的数据结构
栈和队列提供 push 和 pop 等等接口，不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。
在 SGI STL 默认是使用 deque 来实现的 stack 和 queue，当然 vector 和 list 也可以实现
比如，以 vector 为底层实现 stack：std::stack&lt;int, std::vector&lt;int&gt;&gt; st;
以 list 为底层实现 queue：std::queue&lt;int, std::list&lt;int&gt;&gt; que;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caa246b513b7bfcd061afe7a16c94c02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/117b33c7132a7303c1dbd320a1996fb4/" rel="bookmark">
			MyBatis的注解开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注解开发的缺点 MyBatis可以在接口中直接添加MyBatis注解，完成CRUD。
但注解模式属于硬编码到.java文件中，失去了使用配置文件外部修改的优势，可结合需求选用。
1.mapper public interface UserDao { /** * 查询所有用户 * @return */ @Select("select * from user") public List&lt;User&gt; findAll(); /** * 保存操作 * @param user * @return */ @Insert("insert into user(username,sex,birthday,address)values(#{username},“+ "#{sex},#{birthday},#{address})") @SelectKey(keyColumn="id",keyProperty="id",resultType=Integer.class,before = false,statement = { "select last_insert_id()" }) int saveUser(User user); /** * 更新操作 * @param user * @return */ @Update("update user set username=#{username},address=#{address}," + "sex=#{sex},birthday=#{birthday} where id =#{id} ") void updateUser(User user); /** * 删除用户 * @param id * @return */ @Delete("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/117b33c7132a7303c1dbd320a1996fb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f1127b9c648b7538319d8b0473183f8/" rel="bookmark">
			SpringCloud 整合 Canal&#43;RabbitMQ&#43;Redis 实现数据监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1Canal介绍 Canal 指的是阿里巴巴开源的数据同步工具，用于数据库的实时增量数据订阅和消费。它可以针对 MySQL、MariaDB、Percona、阿里云RDS、Gtid模式下的异构数据同步等情况进行实时增量数据同步。
当前的 canal 支持源端 MySQL 版本包括 5.1.x , 5.5.x , 5.6.x , 5.7.x , 8.0.x
Canal是如何同步数据库数据的呢？
Canal通过伪装成mysql从服务向主服务拉取数据，所以先来了解一下MySQL的主从复制吧
2MySQL主从复制原理 1、从库(slave)会生成两个线程，I/O线程(IOthread)，SQL线程(SQLthread)。
2、当slave的I/O线程连接到master后，会去请求master的二进制日志(binlog)， 此时master会通过logdump(将主库的二进制日志文件内容传输给从库的过程) 给从库传输binlog。
3、 然后slave将拿到的binlog日志依次写入Relaylog(中继日志)的最末端，同时将读取到的Master 的bin-log的文件名和位置记录到master- info文件中，作用为了让slave知道它需要从哪个位置和哪 个日志文件开始同步数据，以保证数据的一致性，并且能够及时获取到master的新的更新操作， 开始数据同步过程。slave不仅在启动时读取 master-info 文件，而且会定期更新该文件中的记 录，以确保记录都是最新的。
4、最后SQL线程会读取Relaylog，并解析为具体操作(比如DDL这种)，来实现主从库的操作一致， 最终实现数据一致；
大致了解完了MySQL的主从复制，接着我们看Canal就简单啦。
3Canal工作原理 1、Canal Server与MySQL建立连接后，会通过模拟mysql slave的交互协议，伪装自己为mysql slave，向mysql master发送dump协议获取数据库的 binlog（二进制日志）文件。
2、Canal Server解析binlog文件，通过网络将解析后的事件传输给消息中间件(Kafka,RabbitMQ等),实现数据的实时同步。
了解完canal的原理后，我们就正式开始RabbitMQ+Canal+Redis实现缓存和数据库数据一致的功能。
4RabbitMQ+Canal+redis工作原理 通过上图很好理解：
APP向数据库进行写操作(比如我们更新商品信息啥的)
Canal监听到数据库发生变化，便会向rabbitMQ传递数据库发生变化的消息。
消费者就可以从rabbitMQ获取这些消息，然后进行删除缓存操作。
下面通过实战让我们更好地理解是如何实现缓存和数据库数据一致性的。
5实战配置 Canal 配置 修改 conf/canal.properties 配置
# 指定模式 canal.serverMode = rabbitMQ # 指定实例,多个实例使用逗号分隔: canal.destinations = example1,example2 canal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f1127b9c648b7538319d8b0473183f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/041fcf6943860116e752e4ce41489ea6/" rel="bookmark">
			【前端框架React】原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React设计思想
1.原生JS React相比于vue来说更接近原生JS，因为在react内部，jsx模板经babel转化后是一个对象，所有的操作都是基于这个对象和其对应的fiber结构来操作的，而vue.js通过编译将templete模板转换成渲染函数(render),执行渲染函数就可以得到一个虚拟节点树。
2.实现和更新原理 React将每个节点转化为fiber对象,最终形成一个fiber树结构，来依次渲染。通过两个fiber的对比来实现更新。这里要说到几个diff算法，分别是tree diff,component diff和element diff。同时更新过程可能会被打断，让优先级更高的任务优先执行(例如浏览器渲染)
TREE DIFF
核心是层次遍历和层级监控。如果同层有节点不同则会删除它的子树进行重新渲染，所以设置state要使粒度合适的小一些。能带来性能上的提升。
COMPONENT DIFF
如果某两个节点不是一个类型则进行TREE DIFF,否则进行ELEMENT DIFF。
ELEMENT DIFF
先根据每个节点的ID进行移位检查比较是不是同一个ID，并得到它如何进行增删查改。
3.单项数据绑定 父传子用props，有子传父的方法，不支持双向绑定，需要手动配置。
4.模板的格式和转换 用jsx指定模板，jsx类似JavaScript的扩展，在函数组件返回jsx,或者class组件的render方法内返回jsx，jsx将转换成对象。
5.关注运行时 React 更像是一种编程运行时。
React 程序通常会输出一个会随时间变化的树。 它有可能是 DOM 树 、iOS 视图层、PDF 原语 ，或者是 JSON 对象 。不过通常我们希望用它来展示 UI 。我们称它为“宿主树”，因为它往往是 React 之外宿主环境中的一部分 —— 就像 DOM 或 iOS 。宿主树通常有它自己的命令式 API 。而 React 就是它上面的那一层。
所以 React到底有什么用呢？非常抽象，它可以帮助你编写可预测的，并且能够操控复杂的宿主树进而响应像用户交互、网络响应、定时器等外部事件的应用程序。
他有以下两个特性
稳定性。 宿主树是相对稳定的，大多数情况的更新并不会从根本上改变其整体结构。如果应用程序每秒都会将其所有可交互的元素重新排列为完全不同的组合，那将会变得难以使用。那个按钮去哪了？为什么我的屏幕在跳舞？
通用性。 宿主树可以被拆分为外观和行为一致的 UI 模式（例如按钮、列表和头像）而不是随机的形状。
这些原则恰好适用于大多数 UI 。 不过当输出没有稳定的“模式”时 React 并不适用。
（其实我没有很理解……可以查看这篇文章，写的很好把React作为UI运行时来使用）
6.实例 （1）创建更新阶段
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/041fcf6943860116e752e4ce41489ea6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b23d3a8f4807162f82720522abe737c0/" rel="bookmark">
			教你在Linux上安装Node并用Electron打包deb和rpm包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows下无法打linux版本的包，如果你要打linux系统的amd64架构需要找一台linux amd64的系统打包，也可以在amd64下打arm架构的包，但是不能运行，需要放到arm架构的系统里才能运行。
下载linux的node环境
Index of /nodejs-release/v18.9.1/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror
上传的服务器解压，也可以用tar解压
我是解压到了 usr/local/node 目录
添加环境变量
echo 'PATH=$PATH:/usr/local/node/bin' &gt;&gt; /etc/profile source /etc/profile 查看是否设置成功 修改镜像 弹出配置文档，i编辑，esc退出编辑模式, :wq写入后退出。
npm config edit electron_mirror=https://npm.taobao.org/mirrors/electron/ electron-builder-binaries_mirror=https://npm.taobao.org/mirrors/electron-builder-binaries/ 如果报错
recordofquestion@1.3.2 dev D:\work\vue\sd_linyi_record &gt; node .electron-vue/dev-runner.js internal/modules/cjs/loader.js:818 throw err; ^ Error: Cannot find module 'electron' 安装：
npm config set registry https://registry.npm.taobao.org
npm install node-sass --save-dev
npm install sass-loader --save-dev
2.下载 Electron + Vite + Vue3+TS 脚手架项目 在linux下打包安装 sudo apt-get install rpm sudo apt-get install fakeroot npm run make 参考Electron详解（二）：基本使用与项目打包_electron 打包-CSDN博客
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b23d3a8f4807162f82720522abe737c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/334c884b02509dc5cec34da508904d05/" rel="bookmark">
			Ubuntu-22.04编译安装FLTK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、FLTK是什么？二、下载源代码三、准备编译环境四、编译五、运行测试程序六、Demo总结 前言 最近在研究FLTK，突然对它感了兴趣，就想使用Clion跑一些项目。经过一下午不断摸索，终于在Linux上跑起来了Demo，现在分享给需要的各位。
CPU：I5 13600KF
OS：Ubuntu-22.04 64bits
一、FLTK是什么？ FLTK (Fast Light Tool Kit 发音为full tick) 是一种使用C++开发的GUI工具包，它可以应用于Unix,Linux,MS-Windows95/98/NT/2000/XP/Vista/7/10/11和MacOS操作系统平台，相 对于其它的许多图形接口开发工具包（如MFC、GTK、QT等），它具有体积很小、速度比较快，且有着更好的移植性。
研究它纯粹是因为移植性还可以，而本身又属于比较轻量化的图形库，如果像开发炫酷的GUI，推荐还是QT5或QT6，这都是后话了。
二、下载源代码 我反正是没找到bin，只找到源代码。
官网下载页面
如果你跟我一样是Ubuntu-22.04，建议你下载1.3.9以后的版本，兼容性会更好，不保证之前的版本可以运行在Ubuntu-22.04上。
三、准备编译环境 我使用的是GNU环境，系统自带的，你可以按照我的步骤，缺什么安装什么。
四、编译 这里使用configure编译，这个比Cmake方便。
这里如果你只需要静态库就什么都不配置，默认安装在/usr/local。
./configure 如果你需要自定义安装目录就使用下面的配置
./configure --prefix=&lt;你的目录&gt; 如果你需要动态库就使用下面的配置
./configure --prefix=&lt;你的目录&gt; --enable-shared=yes 配置好了
make -j4 &amp;&amp; make install 五、运行测试程序 自带了一个测试程序fluid，双击即可运行。成功后大概是长这样。
六、Demo 怎么会没有测试代码呢，要不然别人认为我忽悠呢。这里如果你的系统自带jpeg、png和libz库就不需要使用内建的库了，如果没有就使用内建，运行效果一样的。
CmakeLists.txt
cmake_minimum_required(VERSION 3.10) project(fltk_demo) set(CMAKE_CXX_STANDARD 11) include_directories(include) include_directories(include/FL) include_directories(include/FL/images) link_directories(/opt/fltk-1.3.9/lib) add_executable(fltk_demo main.cpp) target_link_libraries(${PROJECT_NAME} fltk_forms) target_link_libraries(${PROJECT_NAME} fltk_images) target_link_libraries(${PROJECT_NAME} fltk_gl) target_link_libraries(${PROJECT_NAME} fltk) main.cpp
#include &lt;iostream&gt; #include &lt;Fl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/334c884b02509dc5cec34da508904d05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/186e20e66aeefbbecf64fe737cbeafbd/" rel="bookmark">
			Windows基于Mingw编译安装FLTK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、FLTK是什么？二、下载源代码三、准备编译环境四、导入项目到Clion五、修改Cmake配置1.src/CMakeLists.txt2.Cmake/options.cmake3.CMakeLists.txt 六、编译七、运行测试程序八、Demo总结 前言 最近在研究FLTK，突然对它感了兴趣，就想使用Clion跑一些项目，结果基于FLTK源代码编译在Windows11上各种报错。我仔细研究了下ide描述，基本可以确定主要基于VS的配置，MingW官方只是轻描淡写了下，实际编译还是报错。经过一下午不断摸索，终于跑起来了Demo，现在分享给需要的各位。
CPU：I5 13600KF
OS：Windows11 64bits
一、FLTK是什么？ FLTK (Fast Light Tool Kit 发音为full tick) 是一种使用C++开发的GUI工具包，它可以应用于Unix,Linux,MS-Windows95/98/NT/2000/XP/Vista/7/10/11和MacOS操作系统平台，相 对于其它的许多图形接口开发工具包（如MFC、GTK、QT等），它具有体积很小、速度比较快，且有着更好的移植性。
研究它纯粹是因为移植性还可以，而本身又属于比较轻量化的图形库，如果像开发炫酷的GUI，推荐还是QT5或QT6，这都是后话了。
二、下载源代码 我反正是没找到bin，只找到源代码。
官网下载页面
如果你跟我一样是Windows11，建议你下载1.3.9以后的版本，兼容性会更好，不保证之前的版本可以运行在Windows11上。
三、准备编译环境 我使用的是Clion-2023.3.1版本，理论上Clion版本都行，但一定要使用MingW（Clion自带）。
四、导入项目到Clion 为什么导入到Clion，因为本身FLTK就有configure和CmakeLists.txt两个文件，支持两种编译方式。只是configure这种在Linux上使用比较方便，Windows上几乎不行（我没研究透）。所以，今天就基于Cmake构建。
五、修改Cmake配置 源代码里和配置里处处可以看到MSVC的字眼，所以如果想在MingW上编译成功，就必须改些东西，否则链接阶段会报错。
主要更改3个文件，src/CMakeLists.txt、Cmake/options.cmake和CMakeLists.txt。
1.src/CMakeLists.txt 原配置是基于MSVC设置的，要想支持MingW就需要更改区分。
原文：
if (OPTION_USE_SYSTEM_LIBJPEG) target_link_libraries (fltk_images_SHARED ${FLTK_JPEG_LIBRARIES}) else() target_link_libraries (fltk_images_SHARED fltk_jpeg_SHARED) endif (OPTION_USE_SYSTEM_LIBJPEG) if (OPTION_USE_SYSTEM_LIBPNG) target_link_libraries (fltk_images_SHARED ${FLTK_PNG_LIBRARIES}) else() target_link_libraries (fltk_images_SHARED fltk_png_SHARED) endif (OPTION_USE_SYSTEM_LIBPNG) if (OPTION_USE_SYSTEM_ZLIB) target_link_libraries (fltk_images_SHARED ${FLTK_ZLIB_LIBRARIES}) else() target_link_libraries (fltk_images_SHARED fltk_z_SHARED) endif (OPTION_USE_SYSTEM_ZLIB) 改为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/186e20e66aeefbbecf64fe737cbeafbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c320cf2c119e6b2a313dbcbcbd5a3620/" rel="bookmark">
			mysql本人常遇到的错误码及解决办法(31种)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql(本人遇到到错误码及解决办法） 1045ER_ACCESS_DENIED_ERROR 访问被拒绝 数据库服务器/数据库用户名/数据库名/数据库密码错误 2020年03月26日 再次遇到 1045'failed to create new session' 没有空间啦，清理一下空间 2020年06月24日 1045 Access denied for user 'root'@'xxx.xxx.xxx.xxx' (using password: YES) 本地登录密码可能错误，远程登录远程授权没有开 本人是远程权限没开给我(此处本人用途数据表生成modle) 2020年12月29日 本人链接同事数据库，无法用root，后来其创建了新的用户 1048ER_BAD_NULL_ERROR pymysql.err.IntegrityError: (1048, 'Unknown error 1048') 某些字段不能为空(这个bug好难解呀，我与数据表一个一个比对的) 1049ER_BAD_DB_ERROR pymysql.err.InternalError: (1049, 'Unknown error 1049') 连接数据库错误，检查ip，端口，账号，密码，数据库名是否有误 1050ER_TABLE_EXISTS_ERROR 背景：1050, "Table 'crm_userprofile' already exists" ) 处理方法：删除相应的表重建了 一只叫做Unix的猫解决方法 1.主从数据结构中，主库新建a表操作，从库已有a表; 2.单表中，建表重复，建议新建表最好使用 create table xx if no exist; 解决办法： 1.从库drop table a;删除原先表; 2.停掉从库的mysql服务器，mysqladmin -S /tmp/mysql3316.sock -u -p shutdown 关闭数据库 3.重启从库，启动slave模式;/usr/local/mysql/bin/mysqld_safe --defaults-file=/data/mysql/mysql3317/my3317.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c320cf2c119e6b2a313dbcbcbd5a3620/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca77262f2c36174513ca5012d279e187/" rel="bookmark">
			对同一后缀文件批量处理（实用版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 小虎跑实验经常会有很多zip文件需要转存处理，积累了一些文件批量处理方法，现在分享一下。
环境 Linux, Ubuntu, Windows可用。Windows建议指令在powershell执行。
指令 移动：
mv source/*.zip ../target/xiaohu/ mv source/*.{rar,zip} ../target/xiaohu/ 解压：
unzip \*.zip 删除：
rm *.zip 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6332e041452c9f3295a0cd3ddc5280d/" rel="bookmark">
			使用ansible脚本30分钟部署一套生产可用kubernetes集群(最新版 1.28.3 集群二进制部署)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部署要求 1、熟悉 ansible，不熟悉也没关系、按步骤操作即可
2、3台及以上机器，操作系统CentOS(7以上版本)/Ubuntu(18以上版本)，配置好网络，主机名，SSH免密或SSH密码
主机名IP服务角色node01.example.io10.0.2.10master、node、etcdnode02.example.io10.0.2.11node、etcd、ingressnode03.example.io10.0.2.12node、etcd、ingress 3、下载kubernetes和containerd二进制安装文件
k8s master 节点高可用方案 1、采用 haproxy,keepalived 实现 高可用
2、在每个kubelet 节点上运行一个 nginx的 static Pod 对 master节点进行反向代理
部署步骤 1、在ansible节点上安装ansible和git
Clone ansible脚本仓库（订阅专栏后私信开通仓库权限，脚本问题可以一对一解答）
git clone https://gitee.com/yxydde/ansible_k8s.git 2、解压安装包 （github中有网盘链接）
sudo wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -O /usr/local/bin/cfssl sudo wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 -O /usr/local/bin/cfssljson sudo chmod u+x /usr/local/bin/cfssl sudo chmod u+x /usr/local/bin/cfssljson wget https://storage.googleapis.com/kubernetes-release/release/v1.28.3/kubernetes-server-linux-amd64.tar.gz tar -xzf kubernetes-server-linux-amd64.tar.gz sudo mv kubernetes/server/bin/* /usr/local/bin/ wget https://github.com/etcd-io/etcd/releases/download/v3.5.9/etcd-v3.5.9-linux-amd64.tar.gz tar -xzf etcd-v3.5.9-linux-amd64.tar.gz sudo mv etcd-v3.5.9-linux-amd64/{etcd,etcdctl} /usr/local/bin/ sudo mkdir /opt/pkgs/ wget https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6332e041452c9f3295a0cd3ddc5280d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1046058fb579cf294a6f80c4cd77dacc/" rel="bookmark">
			为什么深度学习神经网络可以学习任何东西
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下图你所看到的，是著名的曼德尔布罗特集，我们可以见证这个集合呈现出的复杂形态：
要理解神经网络如何学习曼德尔布罗特集，我们首先需要从最基础的数学概念讲起：什么是函数？函数本质上是一个将输入转化为输出的系统，即从数字到数字的映射。在这里，您输入一个x值，系统就会输出一个y值。我们可以在图表上绘制所有x和y值，形成一条连续的线。重要的是，只要知道了这个函数，就可以针对任意输入x计算出对应的输出y。
但如果我们不知道具体的函数形式，仅仅知道某些x和y值，我们是否能对这个未知函数进行反向推理？如果能构造出这样一个函数，我们就可以用它来估算出不在原始数据集中的x值所对应的y值。即便我们的数据包含一些噪声或随机性，我们仍然能够捕捉到数据的整体模式，从而生成接近真实但不完美的y值。我们需要的，就是一个能够近似真实函数的方法。更具体地说，这正是神经网络所做的。
在探讨神经网络如何学习的过程中，我们首先遇到了一个基本问题：如果我们不完全知道一个函数的形式，只知道它的部分输入和输出值，我们能否对这个函数进行逆向工程？如果能够构造出这样一个函数，那么我们就可以利用它来估算那些不在原始数据集中的输入值所对应的输出值。即便我们手头的数据存在一些随机噪声，我们依然能够捕捉到其中的整体模式，并生成接近真实的输出值，虽然可能不完美。我们所需的，正是一种能近似真实函数的方法，而这正是神经网络的核心功能。
神经网络，从本质上讲，就是一个函数逼近器。它由一系列相互连接的神经元组成，每个神经元都可以接收来自前一层的输入，并产生输出，再传递给下一层。每个神经元的输出不仅仅是输入的简单传递，它是输入经过权重调整、加总并通过激活函数处理后的结果。这些权重和偏差是神经网络学习的关键，它们决定了网络如何响应不同的输入。
通过对这些权重和偏差的不断调整，神经网络能够逐渐学习并逼近复杂的函数。这个过程中，网络不断地尝试、出错、调整，最终找到一种方式，使得它的输出尽可能地接近于真实的函数值。这就是神经网络的魔力所在——它能够学习并模拟出极其复杂的数据模式和函数关系。
在深入了解神经网络如何逼近复杂函数之前，我们首先要认识到其核心——非线性激活函数，如ReLU。这种激活函数的引入，极大地增强了网络处理复杂任务的能力。神经元通过加权输入和偏置调整，生成输出并传递给下一层，这一过程是网络学习的基础。随着学习的进行，网络不断调整其权重和偏置，逐步形成能够区分不同数据点的决策边界。这不仅显示了网络的强大适应性，也体现了它在处理多样化数据集时的多功能性.
在神经网络的学习旅程中，非线性激活函数，发挥着至关重要的作用。这些函数为网络提供了处理复杂问题的必要工具，使得原本只能通过线性组合处理的简单任务得以跨越到处理更高级别的复杂模式。网络通过增加神经元数量，逐步构建能够捕捉复杂数据集的能力，从而有效地逼近所需的目标函数。这一过程不仅揭示了神经网络处理复杂性的能力，而且展现了其学习和逼近目标函数的独特方式。
在神经网络的学习过程中，反向传播算法通过逐步调整网络参数来改进函数的逼近效果。尽管神经网络被证明具有普遍的函数逼近能力，能够以任意精度逼近各类函数，但实际应用中仍然面临一些限制。这些限制包括数据量的充足性、网络规模的可行性，以及对已知函数结构的理解程度。尽管如此，神经网络在处理一些对计算机而言极具挑战性的任务上表现出色，特别是在需要直觉和模糊逻辑的领域，如计算机视觉和自然语言处理，神经网络已经彻底改变了这些领域的面貌。
一种简单而有力的思考世界的方式，通过结合简单的计算，我们可以让计算机构造任何我们想要的功能，神经网络几乎可以学习任何东西。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/736e499994f025efd76fb5c13d7016bd/" rel="bookmark">
			02.配置Kubernetes集群主机清单并对操作系统基本设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装ansible、并编辑主机清单文件 主机名IP服务角色rocky01.examp.io192.168.36.151apiserver/scheduler/controller-manager/kubelet/kube-proxy主节点rocky01.examp.io192.168.36.152apiserver/scheduler/controller-manager/kubelet/kube-proxy主节点rocky01.examp.io192.168.36.153etcd/kubelet/kube-proxy工作节点rocky01.examp.io192.168.36.154etcd/kubelet/kube-proxy工作节点rocky01.examp.io192.168.36.155etcd/kubelet/kube-proxy工作节点docker.examp.io192.168.36.128kubectl/dnsmasq/ansible客户端 网段选择：
虚拟机网段：192.168.36.0/34Pod网络CIDR：10.244.0.0/16Service CIDR：172.20.0.0/16 完成前面的主机和网络规划，现在可以开始进行部署了
首先是Clone ansible脚本仓库
Ansible 脚本仓库（订阅专栏后私信我开通权限） https://gitee.com/yxydde/ansible_k8s.git
# 在客户端节点安装 ansible （CentOS需要安装对应版本的epel源） ~]# yum install ansible -y # Clone Ansible 脚本仓库（里面有联系方式，有疑问可以私信我） https://gitee.com/yxydde/ansible_k8s.git ~]# git clone https://gitee.com/yxydde/ansible_k8s.git ~]# cd ansible_k8s # 配置主机清单文件 ~]# vi example/hosts.multi-node [etcd] 192.168.36.153 NODE_NAME=etcd1 192.168.36.154 NODE_NAME=etcd2 192.168.36.155 NODE_NAME=etcd3 [kube_master] 192.168.36.151 192.168.36.152 [kube_node] 192.168.36.151 192.168.36.152 192.168.36.153 192.168.36.154 192.168.36.155 [ingress_node] 192.168.36.153 192.168.36.154 192.168.36.155 [kube_client] localhost # 可选，使用 haproxy + keepalive 高可用方案是需要进行配置 [ext_lb] 192.168.36.151 ROLE=MASTER PRIORITY=160 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/736e499994f025efd76fb5c13d7016bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4694f7e5d3c37fd7cf3c46a8a548a49c/" rel="bookmark">
			mysql中按字段1去重，按字段2降序排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据举例 sql语句 按字段field4降序排序，按字段field1去重
SELECT tt1.name2,tt1.field1,tt1.field2,tt1.field4 from ( select tt2.name2,tt2.field1,tt2.field2,tt2.field4 from t2 tt2 ORDER BY tt2.field4 DESC ) tt1 GROUP BY tt1.field1 执行结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a414b9f580da565cbf3c3d33d5b6e5bd/" rel="bookmark">
			CrackForest数据集| .mat转为.png
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据集下载 CrackForest数据集
https://github.com/cuilimeng/CrackForest-dataset
转化代码 input_folder = 'xxxxxxxxx' # 输出文件夹路径 output_folder = 'xxxxxxxxx' # 遍历文件夹中的.mat文件 for filename in os.listdir(input_folder): if filename.endswith('.mat'): print(filename) # 构建完整的文件路径 mat_filepath = os.path.join(input_folder, filename) # 从.mat文件中加载数据 mat = scipy.io.loadmat(mat_filepath) np_seg = mat['groundTruth'][0][0][0] (y, x) = np.where(np_seg == 2) np_seg[y, x] = 255 (y, x) = np.where(np_seg == 1) np_seg[y, x] = 0 cv2.imwrite(output_folder+filename+'.png', np_seg) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a37758d9f834a0b2e435270d68ce6db3/" rel="bookmark">
			获取癌症数据-International Agency for Research on Cancer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全球癌症数据探索 - 国际癌症研究机构
在探索癌症的全球影响和趋势时，国际癌症研究机构（IARC）为您提供了最全面、最权威的数据资源。我们的数据库覆盖了全球各地的癌症数据，无论您身在何处，都可以轻松访问并分析这些宝贵的信息。
无需翻墙，您就可以获取到全球范围内的癌症统计数据、流行病学研究和临床试验结果。这些数据来自世界各地的权威机构和科研项目，经过严格的审核和整理，为您提供了一个全面、可靠的癌症数据平台。
此外，我们的数据可视化工具让您能够更直观地了解全球癌症数据的分布和趋势。通过交互式的图表、地图和表格，您可以轻松地分析不同地区、不同类型癌症的数据，以及它们与各种风险因素之间的关系。
作为国际癌症研究机构，我们致力于推动全球范围内的癌症研究合作与交流。我们相信，通过共享数据和研究成果，我们可以更好地理解癌症的本质，并找到更有效的预防和治疗策略。
请访问我们的网站，开启您的全球癌症数据探索之旅。让我们一起为战胜癌症而努力，为全人类的健康福祉做出贡献。
【传送门】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09f6900056d4f1fec8f8486e07f4151b/" rel="bookmark">
			FlinkCDC报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果利用FlinkCDC在同步的时候报这个错误，说明server_id需要指定一个；出现的原因是因为你监听的mysql的表时，有多个相同的server_id监听同一个binlog日志。
Caused by：io.debezium.DebeziumException：A slave with the same server_uuid/server_id as this slave has connected to the master;the first event 'mysql-bin.000187' at 50065784,the last event read from './mysql-bin.000187' at 59990Hy000。
如果是flink sql可以这样指定server-id = 549001：
create table t_table ( id bigint, order_no STRING, age int, name timestamp(3), PRIMARY KEY (id) NOT ENFORCED ) WITH ( 'connector' = 'mysql-cdc', 'hostname' = 'hostname', 'port' = 'port', 'username' = 'username', 'password' = 'password', 'database-name' = 'database', 'table-name' = 't_table', 'scan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09f6900056d4f1fec8f8486e07f4151b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cccec36d8c773eb934887ec65c1836b/" rel="bookmark">
			ubuntu多用户环境dockerbug，卸载重装docker流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前不小心误操作删除重装docker，结果删除没成功，更没法重装，每次apt install都会报一个docker错误，虽然不影响软件的常规安装～但是现在还是需要装一个完整docker，还是选择删除一下，重点是关闭服务，关闭服务就好卸载了。
Process: 32174 ExecStart=/usr/bin/dockerd --graph=/home/hxb/docker/lib/docker (code=exited, status=1/FAILURE)
(pid是动态的，提示是固定的)
为是hqw用户，但是老提示hxb用户，需要卸载docker重装，重装好多次还是同样的错误，卸载重点是“干净”，不干净就会重复报错。
彻底卸载docker 卸载docker
1.删除docker及安装时自动安装的所有包
apt-get autoremove docker docker-ce docker-engine docker.io containerd runc
2.查看docker是否卸载干净
dpkg -l | grep docker
dpkg -l |grep ^rc|awk '{print $2}' |sudo xargs dpkg -P # 删除无用的相关的配置文件
3.删除没有删除的相关插件
apt-get autoremove docker-ce-*
4.删除docker的相关配置&amp;目录
rm -rf /etc/systemd/system/docker.service.d
rm -rf /var/lib/docker
5.确定docker卸载完毕
docker --version
下面是安装docker 更新apt软件包索引： sudo apt update 安装必要的软件包，以允许apt通过HTTPS使用存储库： sudo apt install apt-transport-https ca-certificates curl software-properties-common 添加Docker的官方GPG密钥： curl -fsSL https://download.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cccec36d8c773eb934887ec65c1836b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24b20263e521960bf48f8881f64e289b/" rel="bookmark">
			【机电、机器人方向会议征稿|不限专业|见刊快】2024年机械、 图像与机器人国际会议（IACMIR 2024）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【机电、机器人方向会议征稿|不限专业|见刊快】2024年机械、 图像与机器人国际会议（IACMIR 2024） 2024 International Academic Conference on Machinery, Images, and Robotics
会议将聚焦“机械、成像和机器人”相关的最新研究领域，为国内外大学、科研院所、企事业单位的专家、教授、学者、工程师等提供一个分享专业经验、拓展专业网络、面对面交流新思想的国际平台，并展示研究成果，探索该领域发展中的关键挑战和研究方向。为了促进该领域理论和技术在大学和企业中的发展和应用，以及为参与者建立商业或研究联系，并在未来的职业生涯中寻求全球合作伙伴。
大会主题：（主题包括但不限于这些,更多详细主题请咨询苏老师）
结构强度与鲁棒性
逆向工程
能源机械设备
工程机械设备
自动化工程
机械与机械科学
粉末冶金/铸造/烧结/热工/焊接
高速/精密加工
激光加工技术
CAD/CAM集成技术
计算力学
计算机辅助几何设计与仿真
柔性制造技术与系统
机械动力工程
精密力学与机电一体化
质量可靠性工程
系统动力学与仿真
系统科学与系统工程
信号处理系统的设计与实现
数字信号处理
图像和多 维信号处理
图像/视频处理和编码
调制和信道编码
图像处理和模式识别
3D 和立体成像
图像压缩、编码和加密
雷达图像处理
图像扫描、显示和打印
声纳信号处理
合成、渲染和可视化
人脸识别
曲面造型
信号重建
超分辨率成像
图像形成
计算机图形/动画
彩色、多光谱和高光谱成像
修复和增强
模式识别和机器学习
过滤和多分辨率处理
传感器阵列和多通道处理
医学影像
机器人结构设计与控制
机器人导航、定位与自主控制
生物机电、系统与融合
智能无人系统感知与控制
人-机-环境的自然交互与互动
投稿邮箱：ieee_conf@163.com
投稿完成后联系下方会务组老师查收，避免文章遗漏，以及后续开具增值税普票（专票）、纸质刊物寄送、开具相关证明，检索通知等
投稿须知：
1. 论文必须要有摘要、题目、作者、单位、必要的图标、结果、主要参考文献等。
2. 文章为全英文。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24b20263e521960bf48f8881f64e289b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cacc9773eb932c8ced37818948e1d1e7/" rel="bookmark">
			【Python微信机器人】第六七篇: 封装32位和64位Python hook框架实战打印微信日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录修整 目前的系列目录(后面会根据实际情况变动):
在windows11上编译python将python注入到其他进程并运行注入Python并使用ctypes主动调用进程内的函数和读取内存结构体调用汇编引擎实战发送文本和图片消息(支持32位和64位微信)允许Python加载运行py脚本且支持热加载利用汇编和反汇编引擎写一个x86任意地址hook，实战Hook微信日志封装Detours为dll，用于Python中x64函数 hook，实战Hook微信日志实战32位和64位接收消息和消息防撤回实战读取内存链表结构体(好友列表)做一个僵尸粉检测工具根据bug反馈和建议进行细节上的优化其他功能看心情加 上上篇文章说的以后只更新32位版本这句话收回，以后会同时更新32位和64位的最新版本，已经可以在Python中使用Detours来hook 64位版本。
为了加快进度，第六篇和第七篇同一天发布，这篇文章为使用总结，想知道hook原理的可以看同时间发布的其他几篇文章。
温馨提示：本次发布的这几篇文章都是偏技术，想获取成品直接使用的可以等下一篇文章(实战32位和64位接收消息和消息防撤回)
另外，这篇文章开始建群，请关注github或者公众号菜单栏
封装好的Hook库 32位程序的Hook hook的参数有两个：内存地址和回调函数。回调函数的参数是一个包含x86所有寄存器的结构体指针，没有返回值。结构体的定义如下:
class RegisterContext(Structure): _fields_ = [ ('EFLAGS', DWORD), ('EDI', DWORD), ('ESI', DWORD), ('EBP', DWORD), ('ESP', DWORD), ('EBX', DWORD), ('EDX', DWORD), ('ECX', DWORD), ('EAX', DWORD), ] 一个简单的Hook 示例：
def default_hook_log_callback(pcontext): # 获取指针内容，获取的context就是RegisterContext类型了 context:RegisterContext = pcontext.contents # 取eax寄存器的值 eax = context.EAX print("当前eax寄存器的值: ", eax) addr = 0x100000 hooker = Hook() hooker.hook(addr, hook_log_callback_enter) context这个结构体获取的就是当执行到这个地址时的寄存器的值，这个和你用x32dbg看到的寄存器的值是一样的。值的类型都定义成DWORD，如果寄存器是类型是其他类型，比如字符串或结构体，你需要在Python里做相应的转换，可以参考下面Hook日志的代码
你同样可以在回调函数里修改这个指针中寄存器的值，它会反映到实际的寄存器，案例的话会在消息防撤回那一篇文章演示。
64位的Hook 因为64位hook是封装的Detour，比32位需要多定义一个函数指针，而且只能hook函数。所以hook之前需要知道被Hook的函数参数有几个，类型如果不知道的话，可以像上面一样都定义成c_uint64。
回调函数的参数跟被Hook函数的参数必须一样，如果参数很多，你也可以用*arg来表示，示例代码如下：
def hook_log_callback(*args): print(args) print(kwargs) hooker = Hook() log_addr = 0x100000 c_log_addr = c_uint64(log_addr) lp_log_func = CFUNCTYPE(c_uint64, c_uint64, c_uint64, c_uint64,c_uint64,c_uint64,c_uint64,c_uint64,c_uint64,c_uint64,c_uint64,c_uint64,c_uint64) hooker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cacc9773eb932c8ced37818948e1d1e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e2a69c12f0a901b8983ab1a8be5dfd8/" rel="bookmark">
			FreeRTOS列表与列表项相关知识总结以及列表项的插入与删除实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.列表与列表项概念及结构体介绍 1.1列表项简介 列表相当于链表，列表项相当于节点，FreeRTOS 中的列表是一个双向环形链表
1.2 列表、列表项、迷你列表项结构体 1）列表结构体
typedef struct xLIST
{
listFIRST_LIST_INTEGRITY_CHECK_VALUE /* 校验值 /
volatile UBaseType_t uxNumberOfItems; / 列表中的列表项数量 /
ListItem_t * configLIST_VOLATILE pxIndex / 用于遍历列表项的指针 /
MiniListItem_t xListEnd / 末尾列表项 /
listSECOND_LIST_INTEGRITY_CHECK_VALUE / 校验值 /
} List_t;
列表结构体示意图
2）列表结构体
struct xLIST_ITEM
{
listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE / 用于检测列表项的数据完整性 /
configLIST_VOLATILE TickType_t xItemValue / 列表项的值 /
struct xLIST_ITEM * configLIST_VOLATILE pxNext / 下一个列表项 /
struct xLIST_ITEM * configLIST_VOLATILE pxPrevious / 上一个列表项 /
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e2a69c12f0a901b8983ab1a8be5dfd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0e4e46ae34ec07240cb9ba704e85d39/" rel="bookmark">
			python风格规范之Shadows name ‘XXX‘ from outer scope
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python风格规范之Shadows name 'XXX' from outer scope 规范错误/警告描述规范错误描述(示例)规范错误认知 规范错误/警告描述 Shadows name 'xxx' from outer scope 规范错误描述(示例) def function_1(param_1): print(param_1) if __name__ == '__main__': param_1 = "Mr.Wu" function_1(param_1) 规范错误认知 字面意思是指：函数内的形参名称与外部作用域的名称重合。 python \text{python} python的风格规范中，需要将形参变量与调用该形参的变量名进行区分。
正确示例如下：
def function_1(param_1): print(param_1) if __name__ == '__main__': p_1 = "Mr.Wu" function_1(p_1) 当然，调用函数形参的不一定是某个实参，可能是其他函数的形参。如：
def function_1(param_1): def function_2(param_1): print(param_1) return function_2(param_1) if __name__ == '__main__': p_1 = "Mr.Wu" function_1(p_1) 此时function_1中的形参调用了function_2中的形参param_1，同样需要规避相同名称的问题。正确示例如下：
def function_1(pa_1): def function_2(param_1): print(param_1) return function_2(pa_1) if __name__ == '__main__': p_1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0e4e46ae34ec07240cb9ba704e85d39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/149503f344b2a779b3675d1c577fc5a5/" rel="bookmark">
			系统动力学【替代vinsim的anylogic】做仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vensim vs. AnyLogic: 系统动力学中的对比 在系统动力学领域，Vensim 和 AnyLogic 是两款广泛使用的软件，它们各自拥有独特的特点和优势。以下是这两款软件的详细对比：
Vensim 特点：
专注系统动力学：Vensim 是专为系统动力学设计的，非常适合模拟经济、环境或组织结构中的复杂反馈系统。用户界面：提供简单直观的界面，有助于快速构建和理解模型。图形化模型表示：通过因果回路图和股流图实现直观的模型构建。模型复杂性：适合构建中到高复杂度的模型，特别是需要深入理解系统行为的场合。 优势：
易于学习和使用：对于系统动力学新手或不寻求过度复杂模型的用户来说，Vensim 提供了一个易于入门的平台。强大的模型分析工具：包括灵敏度分析、策略测试等，有助于深入理解模型和系统行为。 心得：
可以用来画流图，比较的方便，做数值模拟个人感觉很鸡肋。 AnyLogic 特点：
多方法建模：支持系统动力学、离散事件和代理人基模型，适用于需要这些方法结合的复杂多层次模型。图形用户界面：拥有现代化和高级的用户界面，虽然上手难度较高，但功能更为强大。高级可视化和动画：在模型的可视化和动画方面表现出色，有助于结果展示和解释。广泛的应用范围：适用于商业流程、供应链、交通、健康保健等多个领域。 优势：
灵活性和多样性：支持多种模型类型和复杂场景的模拟，特别适合于跨学科和复杂系统的研究。强大的集成和自定义功能：允许用户导入外部数据、自定义模型组件，甚至整合其他软件。 心得
虽然贵，但是业余版本足够用。 总结 在选择 Vensim 和 AnyLogic 时，重要的是考虑你的具体需求：
如果你的主要关注点是系统动力学，并且需要一个易于学习和使用的工具，Vensim 是一个很好的选择。如果你需要处理更为复杂的场景，或者需要在一个模型中结合多种模拟方法，AnyLogic 将会是更适合的选择。 每款软件都有其独特的优势，因此，选择哪款软件取决于你的具体项目需求和个人偏好。
扩展
G2, Capterra, 和 GetApp
G2, Capterra, 和 GetApp 是收集软件用户评价和评分的知名网站，可以在这些网站上找到关于 AnyLogic 的用户评论。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5507f3d79743bd88e0e2122061f09668/" rel="bookmark">
			qt中子窗口最小化后再恢复显示，子窗口显示为大白框，看不到任何子控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 qt中子窗口最小化后再恢复显示，子窗口显示为大白框，看不到任何子控件。
原因 暂不明确。
解决办法 从网上找的，重写showEvent(QShowEvent *ev)函数，内容如下：
void MyWindow::showEvent(QShowEvent *ev) { this-&gt;setAttribute(Qt::WA_Mapped); QWidget::showEvent(ev); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e95155bcba026038b0dae35062b0899b/" rel="bookmark">
			原来count(*)是接口性能差的真凶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近我在公司优化过几个慢查询接口的性能，总结了一些心得体会拿出来跟大家一起分享一下，希望对你会有所帮助。
我们使用的数据库是Mysql8，使用的存储引擎是Innodb。这次优化除了优化索引之外，更多的是在优化count(*)。
通常情况下，分页接口一般会查询两次数据库，第一次是获取具体数据，第二次是获取总的记录行数，然后把结果整合之后，再返回。
查询具体数据的sql，比如是这样的：`
select id,name from user limit 1,20; 它没有性能问题。
但另外一条使用count(*)查询总记录行数的sql，例如：
select count(*) from user; 却存在性能差的问题。
为什么会出现这种情况呢？
1 count(*)为什么性能差？ 在Mysql中，count(*)的作用是统计表中记录的总行数。
而count(*)的性能跟存储引擎有直接关系，并非所有的存储引擎，count(*)的性能都很差。
在Mysql中使用最多的存储引擎是：innodb和myisam。
在myisam中会把总行数保存到磁盘上，使用count(*)时，只需要返回那个数据即可，无需额外的计算，所以执行效率很高。
而innodb则不同，由于它支持事务，有MVCC（即多版本并发控制）的存在，在同一个时间点的不同事务中，同一条查询sql，返回的记录行数可能是不确定的。
在innodb使用count(*)时，需要从存储引擎中一行行的读出数据，然后累加起来，所以执行效率很低。
如果表中数据量小还好，一旦表中数据量很大，innodb存储引擎使用count(*)统计数据时，性能就会很差。
2 如何优化count(*)性能？ 从上面得知，既然count(*)存在性能问题，那么我们该如何优化呢？
我们可以从以下几个方面着手。
2.1 增加redis缓存 对于简单的count(*)，比如：统计浏览总次数或者浏览总人数，我们可以直接将接口使用redis缓存起来，没必要实时统计。
当用户打开指定页面时，在缓存中每次都设置成count = count+1即可。
用户第一次访问页面时，redis中的count值设置成1。用户以后每访问一次页面，都让count加1，最后重新设置到redis中。
这样在需要展示数量的地方，从redis中查出count值返回即可。
该场景无需从数据埋点表中使用count(*)实时统计数据，性能将会得到极大的提升。
不过在高并发的情况下，可能会存在缓存和数据库的数据不一致的问题。
但对于统计浏览总次数或者浏览总人数这种业务场景，对数据的准确性要求并不高，容忍数据不一致的情况存在。
2.2 加二级缓存 对于有些业务场景，新增数据很少，大部分是统计数量操作，而且查询条件很多。这时候使用传统的count(*)实时统计数据，性能肯定不会好。
假如在页面中可以通过id、name、状态、时间、来源等，一个或多个条件，统计品牌数量。
这种情况下用户的组合条件比较多，增加联合索引也没用，用户可以选择其中一个或者多个查询条件，有时候联合索引也会失效，只能尽量满足用户使用频率最高的条件增加索引。
也就是有些组合条件可以走索引，有些组合条件没法走索引，这些没法走索引的场景，该如何优化呢？
答：使用二级缓存。
二级缓存其实就是内存缓存。
我们可以使用caffine或者guava实现二级缓存的功能。
目前SpringBoot已经集成了caffine，使用起来非常方便。
只需在需要增加二级缓存的查询方法中，使用@Cacheable注解即可。
@Cacheable(value = "brand", , keyGenerator = "cacheKeyGenerator") public BrandModel getBrand(Condition condition) { return getBrandByCondition(condition); } 然后自定义cacheKeyGenerator，用于指定缓存的key。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e95155bcba026038b0dae35062b0899b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12972e3c3071430de8d83b134a083790/" rel="bookmark">
			03.生成Kubernetes集群证书文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K8S入门学习的难点是集群搭建，集群搭建的难点是tls证书
Kubeadm 部署的集群证书默认是一年，所以在证书到期之前需要进行手动更新（生产环境这样可能有风险）
这里我把证书生成的过程全部用脚本自动生成，默认有效期10年，希望能帮助各位快速入门。
参考的官网文档（官方文档是最权威，也是最原滋原味的解释，希望你先理解下面3个链接内容，也都是中文的，还有疑问可以私信我）
PKI 证书和要求
手动生成证书的方式方法
K8S进程之间的tls通信
1、生成证书文件 ansible_k8s]# ansible-playbook -i example/hosts.multi-node 02.cert.yml PLAY [localhost] ******************************************************************************************************************************************** TASK [Gathering Facts] ******************************************************************************************************************************************** ok: [localhost] TASK [cert : Install cfssl] ******************************************************************************************************************************************** ok: [localhost] =&gt; (item=cfssl) ok: [localhost] =&gt; (item=cfssljson) TASK [cert : Create Local SSL Directory] ******************************************************************************************************************************************** ok: [localhost] TASK [cert : Create Etcd CA config] ******************************************************************************************************************************************** ok: [localhost] =&gt; (item=etcd) TASK [cert : Create Etcd CA CSR] ******************************************************************************************************************************************** ok: [localhost] =&gt; (item=EtcdCA) TASK [cert : Create etcd-ca.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12972e3c3071430de8d83b134a083790/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cafbf5f3d900970d4428a4555cf7c914/" rel="bookmark">
			ubuntu安装anaconda unbuntu安装pycharm ubuntu安装pytorch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年1月今天我们在Ubuntu下安装深度学习环境 Ubantu系统：20.04LTS
安装Ubuntu双系统（Win10双硬盘）2021新版教程
1.ubuntu安装anaconda 第一步：官网下载安装包
anaconda官网下载链接
第二步安装教程1如下：但是安装教程中的最后一步用以下命令替代
echo 'export PATH="~/anaconda3/bin":$PATH' &gt;&gt; ~/.bashrc source ~/.bashrc 安装教程1：Ubuntu18.04 安装 Anaconda3
这个教程2也很全！Ubuntu18.04安装Anaconda(最新最全亲测图文并茂)
注意如果你遇见无法切换python环境，一直激活都是base的python情况下，请看教程2末尾的常见问题！
解决方案如下：
sudo gedit ~/.bashrc # 添加到文件末尾 export PATH="~/anaconda3/bin":$PATH source ~/anaconda3/bin/activate # 终端默认的 python 为 anaconda的 base # 更新激活 source ~/.bashrc 2.ubuntu安装pycharm 第一步：直接使用官网的命令行进行安装：
PyCharm官网链接：Download Pycharm for Linux
第二步：直接使用命令行一键下载，然后在应用里面打开它
# 下载免费的社区版在[命令行]用下面的命令 sudo snap install pycharm-community --classic # 下载付费的专业版在[命令行]用下面的命令 sudo snap install pycharm-professional --classic 第三步：指向anaconda的Base环境（此时默认你已经完成教程1安装好了anaconda）
在命令行输入命令，找到python的位置解释器指向base的环境位置命令如下： # 寻找python环境，在命令行输入以下命令: python -m -site [得到结果]：/home/lab/anaconda3/bin/python 第四步：打开Pycharm在解释器中指定/home/lab/anaconda3/bin/python
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cafbf5f3d900970d4428a4555cf7c914/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f82ff8a6ddf36794f7b5a55fd3e79587/" rel="bookmark">
			C# 窗体置顶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实例链接:Windows窗体置顶C#/wpf编程-C#文档类资源-CSDN下载 //引用 using System.Runtime.InteropServices; using System.Windows.Interop; //GetActiveWindow返回线程的活动窗口，而不是系统的活动窗口。如果要得到用户正在激活的窗口，应该使用 GetForegroundWindow [DllImport("user32.dll", CharSet = CharSet.Auto, ExactSpelling = true)] public static extern IntPtr GetForegroundWindow(); [DllImport("user32.dll ")] //设置窗体置顶 private static extern bool SetForegroundWindow(IntPtr hWnd); [DllImport("User32.dll")] public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow); //窗体句柄 private IntPtr handle = IntPtr.Zero; public IntPtr Handle { get =&gt; handle; set =&gt; handle = value; } private void Window_Loaded(object sender, RoutedEventArgs e) { //方法一 handle = new WindowInteropHelper(this).Handle; SetForegroundWindow(handle); ShowWindow(handle, 3); //SetFormForeground("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f82ff8a6ddf36794f7b5a55fd3e79587/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2dac707d2fe4f68292a25c352da9a06/" rel="bookmark">
			【MATLAB】PSO粒子群优化LSTM（PSO_LSTM）的时间序列预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有意向获取代码，请转文末观看代码获取方式~也可转原文链接获取~
1 基本定义 PSO粒子群优化LSTM（PSO-LSTM）是一种将粒子群优化算法（PSO）与长短期记忆神经网络（LSTM）相结合的混合模型。该算法通过模拟鸟群觅食行为，在解空间中搜索和迭代，以找到全局最优解。
在PSO-LSTM中，每个粒子代表一个LSTM模型的参数组合。粒子的位置表示参数的取值，速度表示参数的更新方向和幅度。粒子群根据个体最优和全局最优的信息进行搜索和更新，通过迭代找到最优的参数组合，从而提高LSTM模型的性能。
具体来说，PSO-LSTM的训练过程包括初始化粒子群、计算适应度、更新粒子位置和速度等步骤。首先，随机生成一组初始参数，并为每个粒子分配初始位置和速度。然后，根据当前参数组合计算适应度，评估模型的性能。接下来，根据粒子群中各个粒子的适应度值和历史最优值，更新粒子的位置和速度。最后，不断迭代以上步骤，直到满足停止条件或达到最大迭代次数。
通过使用粒子群优化算法对LSTM模型进行参数搜索和优化，PSO-LSTM在训练过程中能够更好地避免陷入局部最优，并且能够更快地收敛到全局最优解。实验证明，PSO-LSTM在多个任务和数据集上都取得了较好的性能表现，比传统的LSTM模型具有更好的泛化能力和稳定性。
PSO-LSTM的时间序列预测算法的原理基于以下步骤：
「初始化粒子群」：首先，需要为每个粒子（即一组LSTM参数）设定初始位置和速度。这些初始值通常随机生成，范围根据参数的约束条件确定。
「适应度评估」：对于每个粒子，使用当前的参数配置构建LSTM模型，然后使用该模型对训练数据进行预测。预测误差（通常使用均方误差MSE等指标）即为该粒子的适应度值。
「更新粒子位置和速度」：基于粒子的历史最佳位置和全局最佳位置，更新粒子的速度和位置。这是PSO算法的核心步骤，它利用了鸟群觅食行为的模拟，通过个体和群体信息的交互，引导粒子向最优解的方向移动。
「迭代优化」：重复上述步骤，直到满足停止条件（如达到预设的最大迭代次数，或适应度值达到预设阈值等）。在每次迭代中，都会更新粒子的位置和速度，并重新评估适应度值。
「模型预测」：在训练完成后，使用得到的全局最优参数配置构建最终的LSTM模型，并对测试数据进行预测。
通过这样的流程，PSO-LSTM 能够在搜索空间中找到一组最佳的参数配置，使得 LSTM 模型能够更好地拟合训练数据，并提高预测精度。这种算法结合了群体智能和优化技术的优点，能够在处理复杂和动态的时间序列数据时表现出色。
PSO-LSTM时间序列预测算法的优势主要包括以下几个方面：
「全局搜索能力强」：PSO算法是一种基于种群的优化算法，它利用群体智慧，通过个体之间的信息交流与合作，能够更有效地搜索全局最优解。这避免了传统优化算法容易陷入局部最优的问题。
「参数调整优化效果好」：PSO-LSTM算法能够自动调整LSTM模型的参数，优化模型的性能。相较于传统的手工调整参数方法，PSO-LSTM能够更快地找到最优参数组合，提高预测精度。
「自适应能力强」：PSO-LSTM算法能够根据问题的复杂性和数据的变化自动调整参数和模型结构，具有较强的自适应能力。这使得PSO-LSTM在处理具有不确定性和复杂性的时间序列预测问题时具有更大的优势。
「可扩展性强」：PSO-LSTM算法可以与其他机器学习算法和深度学习算法相结合，形成更加复杂的混合模型。这为解决复杂问题提供了更多的可能性。
「易于实现和理解」：PSO算法相对简单易懂，实现起来较为方便。相较于一些复杂的优化算法，PSO-LSTM算法更加易于理解和实现，降低了算法的应用门槛。
总之，PSO-LSTM时间序列预测算法在全局搜索、参数调整、自适应能力、可扩展性和易实现性等方面具有优势，使得它在处理时间序列预测问题时具有更高的性能和效率。
2 出图效果 附出图效果如下：
附视频教程操作：
【MATLAB】PSO粒子群优化LSTM（PSO
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/360788e921d35779a0d8c28f21b48b8a/" rel="bookmark">
			Ubuntu22.04-安装后Terminal无法调出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考：
Ubuntu20.04 终端打开不了的问题排查_ubuntu终端打不开-CSDN博客
https://blog.csdn.net/u010092716/article/details/130968032
Ubuntu修改locale从而修改语言环境_ubuntu locale-CSDN博客
https://blog.csdn.net/aa1209551258/article/details/81745394
问题描述 Terminal的logo在顶端栏上显示了，但一直转圈，不出现。
解决 第一篇中【Ctrl + Alt + F6 切到命令行界面】，我没成功，但是可以去软件市场下Xterm。下完后重装gnome-terminal和配置locale后，重启也不行。
于是参考第二篇，直接编辑【/etc/default/locale】，再重启，即可调出terminal。
主要是这两行，只要改成这样子就ok了。
LANG=en_US.UTF-8 LANGUAGE=en_US:en 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c64d5f9a1e7ddfd8e44804422a2259ea/" rel="bookmark">
			[MyFramework]用清晰的文件夹路径保存实验数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		精华部分 TIMESTAMP = "{0:_%Y-%m-%d,Time:%H:%M:%S}".format(datetime.now()) args.output = args.output + TIMESTAMP os.makedirs(args.output, exist_ok = True) 效果如上所示；
导入包语句是from datetime import datetime，注意是datetime而不是datatime，里面是date，此处极其容易手抖写错；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69002bde3c7636c26b424360042f793f/" rel="bookmark">
			LaTeX 常见符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LaTeX 符号新手入门 公式中常用集合相关希腊字母 论文中常用花体字母奇奇怪怪的符号 Markdown 下公式对齐大括号分类讨论的公式Markdown 矩阵 Latex 是一种用于排版文档的语言，它可以用特殊的命令来表示数学公式、符号、图形等。具有高效、灵活、易扩展等特点，在计算机科学的各个领域都有广泛的应用。
Typora 数学公式速查
LaTeX 符号 【LaTeX应用】
以下 LATEX 符号照片取自 https://www.cmor-faculty.rice.edu/~heinken/latex/symbols.pdf
新手入门 上标 $a^{b}$ ： a b a^{b} ab，单字符可以省略 {}，多字符不可省略；下标 $a_{b}$ ： a b a_{b} ab​，单字符可以省略 {}，多字符不可省略；求和公式 $\sum_{i=a}^{b} c_i$ ： ∑ i = a b c i \sum_{i=a}^{b} c_i ∑i=ab​ci​分数 $\frac{a}{b}$ ： a b \frac{a}{b} ba​集合 $E_S = \{v_{ti}v_{tj} |(i, j)∈H\}$ ： E S = { v t i v t j ∣ ( i , j ) ∈ H } E_S = \{v_{ti}v_{tj} |(i, j)∈H\} ES​={vti​vtj​∣(i,j)∈H}，注意在 { 和 } 前加 \字体加粗 $\mathbf x$ ： x \mathbf x x向量 $\vec {x}$ ： x ⃗ \vec x x ，单个字母空心 R $\mathbb {R}^n$ ： R n \mathbb {R}^n Rn上取整 $\lceil a^b \rceil$ ： ⌈ a b ⌉ \lceil a^b \rceil ⌈ab⌉下取整 $\lfloor a^b \rfloor$ ： ⌊ a b ⌋ \lfloor a^b \rfloor ⌊ab⌋大型的双竖线 $\left\| \frac{a}{b} \right\|$ ： ∥ a b ∥ \left\| \frac{a}{b} \right\| ​ba​ ​单个字母上面加横线 $\bar A$ ： A ˉ \bar A Aˉ多个字母上面加横线 $\overline {a+b}$ ： a + b ‾ \overline {a+b} a+b​逻辑非 $\sim$ ： ∼ \sim ∼ 举例如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69002bde3c7636c26b424360042f793f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b21fda63d622dbc77efa78892e50898/" rel="bookmark">
			计算机网络:自顶向下方法-第8版-Chapter4-Problems
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 P1ab P2abc P3P4P5ab P6abcde P7abc P8ab P9P10P11P12P13P14P15ab P16P17P18ab P19ab P20P21P22P23P24P25 P1 考虑下列网络。
a. 假定网络是一个数据报网络。写出路由器 A 中的转发表，从而满足所有指向主机 H3 的流量都通过接口 3 转发。
b. 假定网络是一个数据报网络。你能写出路由器 A 中的转发表从而满足其中所有从 H1 指向主机 H3 的流量通过接口 3 转发，而所有从 H2 指向主机 H3 的流量通过接口 4 转发。（提示：这是一个技巧问题）
a 目的地址输出链路H33 b 不可以, 因为转发只依据了传入数据报的目的地址, 如果2个输入数据报的目的Ip一致, 则会转发到同一个输出链路
P2 假设两个分组在完全相同的时刻到达一台路由器的两个不同输入端口。同时假设在该路由器中没有其他分组。
a. 假设这两个分组朝着两个不同的输出端口转发。当交换结构使用一条共享总线时，这两个分组可能在相同时刻通过该交换结构转发吗?
b. 假设这两个分组朝着两个不同的输出端口转发。当交换结构使用经内存交换时，这两个分组可能在相同时刻通过该交换结构转发吗?
c. 假设这两个分组朝着相同的输出端口转发。当交换结构使用纵横式时，这两个分组可能在相同时刻通过该交换结构转发吗?
a 不可能, 总线在任意时刻都最多转发一个分组, 即一次只能通过共享总线传输一个分组
b 不可能，因为通过CPU的系统总线一次只能执行一次内存读/写操作。
c 不可能, 此时这两个分组的其中一个会在输入端口除排队
P3 在4.2.4节中，如果 R s w i t c h R_{switch} Rswitch​是 R l i n e R_{line} Rline​的N倍，即使所有的分组都转发到相同的输出端口，则仅在输入端口将出现微不足道的排队。现在假设 R s w i t c h = R l i n e R_{switch} = R_{line} Rswitch​=Rline​，但所有分组转发到不同的输出端口。令D是传输一个分组的时间。作为D的函数，对分组使用内存、总线和纵横式交换结构，什么时候具有最大的输入排队时延?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b21fda63d622dbc77efa78892e50898/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b3eda9dba74ae791012db2642709ddf/" rel="bookmark">
			ESP32 实现PWM（MicroPython）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、PWM介绍 1.什么是PWM 脉冲宽度调制(PWM)，是英文“Pulse Width Modulation”的缩写，简称脉宽调制，是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术，广泛应用在从测量、通信到功率控制与变换的许多领域中。
2.PWM频率 PWM的频率是指单位时间内PWM方波重复的次数，也就是说一秒钟PWM有多少个周期。
3.PWM周期 周期T=1/f，假设频率f=50Hz，那么推算周期为0.02s即20ms。
4.PWM占空比 PWM的占空比是指一个周期内高电平持续时间与周期的比值，他的单位可以是0%-100%，如果高电平时间占一个周期的时间为一半，那么他的占空比就为50%。
在平时使用PWM时，需要重点关注占空比的大小，他可以实现冲量相等，即占空比≈电压，如果系统电压为5V，占空比为50%，那么可以看成输出电压为2.5V。
二、Python控制PWM 在MicroPython官方文档中：Quick reference for the ESP32 — MicroPython latest documentation，给的示例如下：
from machine import Pin, PWM pwm0 = PWM(Pin(0)) # create PWM object from a pin freq = pwm0.freq() # get current frequency (default 5kHz) pwm0.freq(1000) # set PWM frequency from 1Hz to 40MHz duty = pwm0.duty() # get current duty cycle, range 0-1023 (default 512, 50%) pwm0.duty(256) # set duty cycle from 0 to 1023 as a ratio duty/1023, (now 25%) 在配置占空比时，需要注意几个点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b3eda9dba74ae791012db2642709ddf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6d987b6da666571b17c7166d81cc2a8/" rel="bookmark">
			解决 Chrome 120 开发人员工具 无法粘贴代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发人员工具的新功能 （Chrome 120）
https://developer.chrome.com/blog/new-in-devtools-120?hl=zh-cn
【状况】：
新增 Self-XSS 保护警告
无法顺利无法在开发人员工具（DevTools） console 贴上 代码
正常应该要跳出 提示窗口
但目前windows有碰到状况是没有跳出来
完全无法点击 Allow 允许粘贴代码
Warning: Don’t paste code into the DevTools Console that you don’t understand or haven’t reviewed yourself. This could allow attackers to steal your identity or take control of your computer. Please type ‘allow pasting’ below to allow pasting.
【解决方式1】：
直接在 Console 输入 allow pasting 后 Enter 即可开启 （右键）复制贴上等功能
【解决方式2】：
点击 开发人员工具（DevTools） 右边上方齿轮（设定）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6d987b6da666571b17c7166d81cc2a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f95b429ca440fe6aecb21a26b2e33ab/" rel="bookmark">
			Vue2 实现分类选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css" /&gt; &lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.13/vue.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/npm/@unocss/runtime"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/element-ui/lib/index.js"&gt;&lt;/script&gt; &lt;!-- &lt;link rel="stylesheet" href="./vue/element_ui.css" /&gt; &lt;script src="./vue/vue.js"&gt;&lt;/script&gt; &lt;script src="./vue/unocss.js"&gt;&lt;/script&gt; &lt;script src="./vue/element_ui.js"&gt;&lt;/script&gt; --&gt; &lt;style&gt; * { margin: 0; padding: 0; box-sizing: border-box; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app" class="h-100vh flex justify-center items-center"&gt; &lt;div&gt; &lt;div class="flex items-center gap-20px mb-20px"&gt; &lt;div v-for="(item,i) in cities" @click="index = i" :class="{'text-blue border-blue': i == index}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f95b429ca440fe6aecb21a26b2e33ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10cfcade5009625ed5a1b5e2b6b96a80/" rel="bookmark">
			HarmonyOS鸿蒙应用开发——数据持久化Preferences
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数据持久化简述基本使用与封装测试用例参考 数据持久化简述 数据持久化就是将内存数据通过文件或者数据库的方式保存到设备中。HarmonyOS提供两两种持久化方案：
Preferences：主要用于保存一些配置信息，是通过文本的形式存储的，在使用中会将文本中的数据全量加载到内存中，不太适合存储大量数据的场景。数据库：分为两种，一种是非关系型数据库，数据是键值对的形式存储；另外一种事关系型数据库，数据是行和列的形式存储，提供一个系列的增删改查等SQL操作，适合数据复杂的场景，比如聊天会话记录等等。 基本使用与封装 Preferences提供了获取实例、读、取、删对应操作的方法：
getPreferences(context,name)：获取Preferences实例，name是存储的文件名；get(k)：通过key获取value值；getAll()：获取文件所有的值；put(k,v)：添加值，同一个key会将之前的值覆盖掉，需要通过flush()刷新到文件中；delete(k)：通过key删除对应的value值；clear()：删除所有的存储值。 注意：以上方法都是异步的。
通常会在EntryAbility#onCreate()方法中创建实例，其中context便是EntryAbility的上下文，获取preferences 实例就可以对数据增删改查操作。
// 导入包 import dataPreferences from '@ohos.data.preferences' // 获取实例 let preferences = dataPreferences.getPreferences(context, this.preferencesName) 下面对preferences 进行封装，基本思路：
在获取preferences实例后会将其保存单例中，这个单例是GlobalContext，方便后期可以通过单例直接获取实例；由于get()返回值类型是不确定性，定义一个联合类型的别名ValueType 来接收。
const TAG = "PreferencesUtils" // 默认文件名，可以在构造函数进行修改 const PREFERENCES_NAME = 'yiPreferences' const KEY_PREFERENCES = "preferences" type ValueType = number | string | boolean | Array&lt;number&gt; | Array&lt;string&gt; | Array&lt;boolean&gt;; export class PreferencesUtils{ // preferences的文件名 private preferencesName: string = PREFERENCES_NAME // 用于获取preferences实例的key值，保存到单例中 private keyPreferences: string = KEY_PREFERENCES constructor(name: string = PREFERENCES_NAME, keyP: string = KEY_PREFERENCES) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10cfcade5009625ed5a1b5e2b6b96a80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f20ecdacda49877add41d795d5dcc47/" rel="bookmark">
			洛谷 CSP-J 2021 分糖果&#43;插入排序 个人解答的优化过程以及详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先声明这两道题目第一题很简单，读者可以不看解答自己先做一遍题目，看看能不能获得满分，我就是因为无意识考虑时间复杂度的问题没有获得满分最开始，然后我进行了优化，获得了满分，但是第二题的难度较大，读者可以仔细领会，接下来请看题目：
首先我们来看第一道题分糖果：
样例以及数据范围：
我一开始的思路很简单，那就是从L到R进行枚举，不断更新ans得到最后的答案：
#include&lt;iostream&gt; using namespace std; int n,L,R; int ans=-1; int main(){ cin&gt;&gt;n&gt;&gt;L&gt;&gt;R; for(int i=L;i&lt;=R;i++){ ans=max(ans,i%n); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } 这段代码得不到满分，在极端的情况下会导致超时，不过如果不追求满分的同学的话可以使用，因为这段代码已经有九十分了，然后接下来我进行了优化，我来讲一下我的优化思路：因为很明显我们最后的答案就是1到n-1，所以我们可以考虑引入变量，然后计算出L和R模去n的值以及除去n的值，如果除去n的两个变量相减大于等于1就说明L和R的差必定大于等于n也就意味着存在一个值x属于L到R,让我分到n-1个苹果，亦或者L,R其中一个值模去n得到n-1的话，同样可以判断出能获得n-1个苹果，否则的话我们将模出来的两个变量从小到大进行枚举最后不断更新就可以得到我们想要的答案：
#include&lt;iostream&gt; using namespace std; int n,L,R; int ans=-1; int main(){ cin&gt;&gt;n&gt;&gt;L&gt;&gt;R; if(R-L&gt;=n-1){ cout&lt;&lt;n-1&lt;&lt;endl; return 0; } int t1=L%n,t2=L/n,t3=R%n,t4=R/n; if(t1==n-1 || t3==n-1 || t4-t2&gt;=1){ cout&lt;&lt;n-1&lt;&lt;endl; return 0; } for(int i=min(t1,t3);i&lt;=max(t1,t3);i++){ ans=max(ans,i); } cout&lt;&lt;ans&lt;&lt;endl; return 0; } 好了，接下来是第二题，插入排序：
来看贼长的题干：
样例以及数据范围：
好了接下来来分析一下这一道题目：
这道题目我一开始的想法也就是模拟，首先把该输入的输入了，只不过我们需要引入一个变量数组t，因为如果是操作二的话我们每次都会对数组进行排序但是进行的操作并不会保留，因此我们可以利用这个t变量数组先存下一开始的a数组当操作结束之后再把a数组利用t数组还原：
#include&lt;iostream&gt; using namespace std; int n,q; const int N=10000; int a[N],t[N]; int main(){ cin&gt;&gt;n&gt;&gt;q; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } for(int i=1;i&lt;=q;i++){ int p; cin&gt;&gt;p; if(p==1){ int x,v; cin&gt;&gt;x&gt;&gt;v; a[x]=v; } else { int x; cin&gt;&gt;x; int m=x; for(int j=1;j&lt;=n;j++) t[j]=a[j]; for(int i=2;i&lt;=n;i++){ for(int j=i;j&gt;=1;j--){ if(a[j]&lt;a[j-1]){ if(j==m){ int temp=a[j]; a[j]=a[j-1]; a[j-1]=temp; m=j-1; } else if(j-1==m){ int temp=a[j]; a[j]=a[j-1]; a[j-1]=temp; m=j; } else { int temp=a[j]; a[j]=a[j-1]; a[j-1]=temp; } } } } cout&lt;&lt;m&lt;&lt;endl; for(int k=1;k&lt;=n;k++) a[k]=t[k]; } } return 0; } but，出题人当然不会这么好心让我用模拟的思路就能直接过掉所有测试点，完完全全的超时了：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f20ecdacda49877add41d795d5dcc47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9f7b440b0e7521a2f61ebdd2f302111/" rel="bookmark">
			python网站创建015：jQuery的各种操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们找到标签之后，就要学习jQuery对这个标签都能做哪些操作？
1、样式操作：也就是操作标签的css样式 添加样式：addClass
删除样式：removeClass
判断是否有该样式：hasClass
有则移除，无则添加：toggleClass
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;初识：JavaScript&lt;/title&gt; &lt;meta charset="UTF-8"&gt; &lt;style&gt; .test_style{ background: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="v1"&gt; &lt;div id ='v2'&gt; &lt;h1 id="info1"&gt;&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="../file/jquery-3.7.1.min.js"&gt;&lt;/script&gt; &lt;script&gt; // 添加test_style样式 $(".v1").addClass('.test_style'); // 删除test_style样式 $(".v1").removeClass('.test_style'); // 判断当前标签是否有test_style样式 $(".v1").hasClass('.test_style'); // 有test_style样式的话给你移除， 没有的话给你添加上 $(".v1").toggleClass('.test_style'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 练习：在之前使用DOM和BOM时写了一个关于菜单的展开和收缩功能，如下，这是使用DOM和BOM来完成的
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;初识：JavaScript&lt;/title&gt; &lt;meta charset="UTF-8"&gt; &lt;style&gt; .group{ /*宽度*/ width: 300px; /*边框的边距和颜色*/ border: 1px solid #ddd; } .group .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9f7b440b0e7521a2f61ebdd2f302111/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf5cba88a5453855a3fd8010b504eefd/" rel="bookmark">
			几个图像处理库整理：OpenCV、PIL(pillow)、skimage和GDAL库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要是图像处理的几个库对数据的读取方式存在差异，有的时候经常搞混，没有概念，所以大致整理一下，一是增强印象，二是整理便于查阅。
关于图像读取函数：
1、opencv库，python在引用opencv库时通过import cv2 import cv2 img = cv2.imread('./xxx.jpg') 我测试的一张图片结果：可见opencv读出的数据是numpy数组类型，数据shape维度是[H，W，C]，列（高）和行（宽），读取顺序是BGR，size表示像素数量。主要处理三波段图像或灰度图。
ipdb&gt; type(img) &lt;class 'numpy.ndarray'&gt; ipdb&gt; img.shape (1080, 1920, 3)#列(height)、行（width）和通道数 ipdb&gt; img.size 6220800 ipdb&gt; img array([[[23, 23, 23], [11, 11, 11], [14, 14, 14], ..., [14, 14, 14], [11, 11, 11], [23, 23, 23]], [[10, 10, 10], [ 0, 0, 0], [ 1, 1, 1], ..., [ 1, 1, 1], [ 0, 0, 0], [10, 10, 10]], [[13, 13, 13], [ 1, 1, 1], [ 3, 3, 3], .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf5cba88a5453855a3fd8010b504eefd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fece84adbda2815e7abaeaeb08b13dd8/" rel="bookmark">
			PAT 乙级 1015 德才论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1015 德才论
分数 25
作者 CHEN, Li
单位 浙江大学
宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”
现给出一批考生的德才分数，请根据司马光的理论给出录取排名。
输入格式：
输入第一行给出 3 个正整数，分别为：N（≤10
5
），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到优先录取线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。
随后 N 行，每行给出一位考生的信息，包括：准考证号 德分 才分，其中准考证号为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。
输出格式：
输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。
输入样例：
14 60 80
10000001 64 90
10000002 90 60
10000011 85 80
10000003 85 80
10000004 80 85
10000005 82 77
10000006 83 76
10000007 90 78
10000008 75 79
10000009 59 90
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fece84adbda2815e7abaeaeb08b13dd8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/48/">«</a>
	<span class="pagination__item pagination__item--current">49/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/50/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>