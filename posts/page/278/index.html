<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a500a05bbaca0adbf5dc13f4eec932e2/" rel="bookmark">
			C# 二维数组排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//定义一个2维数组 int[][] array = { new[] { 3, 1 }, new[] { 1, 3 }, new[] { 4, 2 } }; //按数组的第2个数排序 Array.Sort(array, (a, b) =&gt; a[1].CompareTo(b[1])); 输出结果：
{[3,1],[4,2][1,3]} 应用：
LeetCode435.无重叠区间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88552819e56ff3128def70e1623241f5/" rel="bookmark">
			如何将一张Excel表中的数据匹配到另一张表里
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用excel数据表时，有时需要将一张表中的数据匹配到另一张表中进行统计，一般来说表中的数据项不完全相同且表中的数据较多。这时就需要用到VLOOKUP函数进行查找。
函数介绍： VLOOKUP函数一共有四个参数，分别如下：
查找值：就是你要通过那个选项去查找你要的结果。数据表：需要查找的数据表，需要把查找值和要找的结果都包括在内。列序数：从查找值开始到需要查找的结果结束一共几列（查找值为1，该参数为数值）。匹配条件：0或FALSE为精确查找；1或TRUE为大致匹配，该匹配可能不准确。 举例 这里举个例子：这里我们A表中的数据是空白的，需要从B表中进行匹配查找，人工查找显然不太现实，这时使用函数就方便多了。
A表：
B表：
步骤： 1、找到需要查找的选项，点击公式，点击插入函数；
2、这里我们在查找中输入VLOOKUP函数并选中，再点击确定； 3、进去后输入函数第一个参数，这里我们以车牌为基础查找SIM卡号，这里查找值就选B2
然后将鼠标放到数据表参数，选种B表的的前三列（车牌号、车牌颜色、SIM卡号），
然后在输入列序数参数，这个参数表示，车牌号到SIM卡号之间有几列，这里是有3列，我们输入3，最后匹配条件填0即可，最后确定。
4、这样就可以从B表中，找到我们想要的数据。然后在填充所有即可。（填充的话将鼠标放在表格的右下角待鼠标变为小十字双击即可）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/343f78c9bdeb5548e1ba009317b7ea57/" rel="bookmark">
			Window批量修改文件名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需要一个图片组用于帧动画；
1、全选需要修改的文件 ， 在第一个文件处右击选择重命名，修改后是这样的； 这样整体的文件名已经修改，然后需要去除空格和括号；
2、把这两个bat文件放在需要重命名的文件夹下 ， 双击运行； 去空格bat：
@echo off&amp;setlocal enabledelayedexpansion for /f "delims=" %%i in ('dir /s/b *.*') do ( set "foo=%%~nxi" set foo=!foo: =! set foo=!foo: =! ren "%%~fi" "!foo!" ) exit 去括号bat：
@Echo Off&amp;SetLocal ENABLEDELAYEDEXPANSION FOR %%a in (*) do ( echo 正在处理 %%a set "name=%%a" set "name=!name:(=!" set "name=!name:)=!" ren "%%a" "!name!" ) exit 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e8f5c6e94f902b8f4b970df2f003ee8/" rel="bookmark">
			ABAQUS中出现XML parsing failure for job错误怎么解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结论 首先，我遇到的情况，ABAQUS/CAE只是报错了显示Aborted，后台实际上已经自动分析计算完成，且和正常分析得到的结果基本是相同的（暂不考证）。
其次，出现这种错误不一定是job文件的问题，可能是对于不同性能计算机，能够承受【CPU与内存占用情况是否爆表】同时提交的job数量不同。
我的情况分析： 报错信息： #: Error in job Job-1-PoseLHS_014: XML parsing failure for job Job-1-PoseLHS_014. #: Shutting down socket and terminating all further messages. #: Please check the .log, .dat, .sta, or .msg files for information about the status of the job. #: Job Job-1-PoseLHS_014 aborted due to errors. 工作站【CPU@2.3G @2.29G-128G内存】
我用工作站【CPU@2.3G @2.29G-128G内存】只是做简单的模态分析，同时提交100个job就会出现这种情况；
经过测试（多次踩坑），同时提交50/30/20个job都会题主所述错误【可能是CPU不够强悍，配不上这么大内存吧】。
小结 图中Completed是正常分析的结果，Aborted是出现上述情况意外终止的job-22，事实上，ABAQUS/CAE只是显示Aborted，分析计算结果和正常分析的基本相同（暂不考证）。
job管理器显示Aborted的同时遇到的其他情况：
分析结束时（计算机CPU及内存不再占用），job管理器显示的几种情况
【Completed/Running/Aborted/Submitted】
Completed，是正常分析完成的结果；
Running/Aborted，虽然显示如此，实际job已经计算完成且计算结果和Completed基本是相同的（暂不考证）；
Submitted，ABAQUS/CAE未能计算完成，当我关闭GUI界面后，任务管理器会出现【Windows命令处理程序——显示24个】，说明后台自动开始了这几个未完成job的计算；等待计算完后，结果和Completed的分析基本是相同的（暂不考证）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddca4338ff9f442fbc99b27c78e78e39/" rel="bookmark">
			Java中的原子类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是原子类 一个操作是不可中断的，即使是多线程的情况下也可以保证
在java中原子类都被保存在 java.util.concurrent.atomatic 二、原子类的作用 原子类的作用和锁类似，是为了保证并发情况下线程安全，不过原子类相比于锁，有一定的优势。粒度更细，原子变量可以把竞争范围缩小到变量级别，这是我们可以获得的最细粒度的情况了，通常锁的粒度都要大于原子变量的粒度。效率更高，通常使用原子类的效率比使用锁的效率更高，除了高度竞争的情况。 三、原子类纵览 Atomic* 基本类型原子类 AtomicInteger
AtomicLong
AtomicBoolean
Atomic* Array数组类型原子类 AtomicIntegerArray
AtomicLongArray
AtomicReferenceArray
Atomic*Reference 引用类型原子类 AtomicReference
AtomicStampedReference
AtomicMarkableReference
Atomic*FieldUpdate 升级类型原子类 AtomicIntegerFieldupdater
AtomicLongFieldUpdater
AtomicReferenceFieldUpdater
Adder累加器LongAdder、DoubleAdderAccumulator累加器 LongAccumulator
DoubleAccumulator
四、Atomic*基本原子类 以AtomicInteger为例
AtomicIntege 常用方法 get()：获取当前的值getAndSet()：获取当前值big设置新的值getAndIncrement()：获取当前的值并自增getAndDecrement()：获取当前的值并自减getAndAdd(int delta)：获取当前的值，并加上预期的值compareAndSet(int expect,int update)：如果当前的数组等于预期值，则以原子方式将该值设置为输入值(update) 五、Atomic*Reference 引用原子类 AtmoicReference：AtmoicReference类的作用和AtomicInteger并没有本质区别，AtomicInteger可以让一个整数保证原子性，AtmoicReference可以让一个对象保证原子性，当然，AtmoicReference功能明显比AtomicInteger强，因为一个对象里面可以包含很多属性。用法和AtomicInteger类似
六、把普通变量升级为具有原子功能的变量 AtomicIntegerFieldUpdater对普通变量进行升级，使用注意点如下：
可见范围(private的就不可以了)不支持static变量 七、Adder累加器 高并发下LongAdder比AtomicLong效率高，不过本质是空间换时间
竞争激烈的时候，LongAdder把不同线程对应到不同的Cell上进行修改，降低了冲突概率，是多段锁的理念，提高了并发性
LongAdders效率高的原因 AtomicLong每个线程对变量进行修改时都要从本地内存flush到主内存中，然后再从主内存refrsh到另一个线程的本地内存中，如下图
LongAdder就不存在AtomicLong的那种情况，每个线程将变量在自己的内存中做计算，不需要同步到主内存中，如下图
如图中所示，第一个线程的计数器的值也就是ctr' = 1 为1的时候，可能线程2的计数器 ctr'' 的数值已经为3了，他们之间并不存在竞争的关系，所以在加和的过程中，根本不需要同步机制，也不需要flush和refresh，这里也没有一个公共的counter来给所有线程统一计数 LongAdder原理 在内部，这个LongAdder的实现原理和AtomicLong是有不同的，刚才的AtomicLong的实现原理是每一次加法都需要做同步，所以在高并发的时候回导致冲突比较多也就降低了效率
LongAdder每个线程会有自己的一个计数器，仅用来在自己的线程内计数，这样一来就不会和其他线程的计数器干扰
LongAdder将每个线程内的计数器累计分析
LongAdder 引入了分段累加的概念，内部有一个base变量和一个cell[] 数组共同参与计数
base变量：竞争不激烈，直接累加到该变量上
cell[]数组：竞争激烈，各个线程分散累加到自己的槽cell[i] 中
由上面的源码可以看出，当在做累计时cells[i]的值随时可能发生改变，所以最终的求和不是十分的精确
AtomicLong和LongAdder对比 在低争用下，AtomicLong和LongAdder这两个类具有相似的特征，但是在竞争激烈的情况下，LongAdder的预期吞吐量要高得多，但是要消耗更多的空间LongAdder 适合的场景是统计求和和计数的场景，而且LongAdder基本只提供了add方法，而AtomicLong还具有cas方法 八、Accumulator Accumulator就是对Adder的升级 不仅可以做加法操作还可以做其他操作例如：乘法，求最大最小值等
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d6a6b8268e31ef3f39f92922a178922/" rel="bookmark">
			前端-父级设置了display: flex，子级布局出现1个div把一行全占了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54292cc4dad35fe5fffe43a2f7935b7b/" rel="bookmark">
			2021-11-05 springMVC 错误：org.springframework.http.converter.HttpMessageNotWritableException: No conve
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2021-11-05 springMVC 错误：org.springframework.http.converter.HttpMessageNotWritableException: No conve... springMVC返回json格式问题对象转json返回json字符串问题分析总结 springMVC返回json格式问题 对象转json返回json字符串问题分析 在SpringMVC(默认支持jackson)中返回Json字符串需要表明@ResponseBody注解，此时出现了转换异常问题分析：
首先是依赖问题，这里看的别人的文章需要导入两个依赖，但并没有解决我的问题 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;${zsl.jackson.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;${zsl.jackson.version}&lt;/version&gt; &lt;/dependency&gt; 提供get/set方法，最后发现是没有提供get方法导致的（麻了） 总结 导入正确的依赖提供get/set方法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98f5198e4046b1895722e41ea694cf0f/" rel="bookmark">
			vue - props配置项\ mixin\插件\scoped
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		props配置项 功能：让组件接收外部传过来的数据
传递数据：&lt;Demo name="xxx"/&gt;
接收数据：
第一种方式（只接收）：props:['name']
第二种方式（限制类型）：props:{name:String}
第三种方式（限制类型、限制必要性、指定默认值）：
props:{ name:{ type:String, //类型 required:true, //必要性 default:'老王' //默认值 } } 备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。
mixin(混入) 功能：可以把多个组件共用的配置提取成一个混入对象
使用方式：
第一步定义混合：
{ data(){....}, methods:{....} .... } 第二步使用混入：
​ 全局混入：Vue.mixin(xxx)
​ 局部混入：mixins:['xxx']
// mixin.js export const hunhe = { methods: { showName(){ alert(this.name) } }, mounted() { console.log('你好啊！') }, } export const hunhe2 = { data() { return { x:100, y:200 } }, } // main.js //引入Vue import Vue from 'vue' //引入App import App from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98f5198e4046b1895722e41ea694cf0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8c1f22db0e60eb239b5da3594f3bdd3/" rel="bookmark">
			用java制作一个简单的登录界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只有一个界面，不能实现什么功能
import java.awt.GridLayout;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
public class LoginWindow2 extends JFrame {
public LoginWindow2()
{
this.setSize(600,400);
this.setLayout(new GridLayout(4,1));
JLabel jl1=new JLabel("登录",JLabel.CENTER);
JLabel jl2=new JLabel("用户名:");
JTextField jtf1=new JTextField(20);
JPanel jp1=new JPanel();
jp1.add(jl2);
jp1.add(jtf1); JLabel jl3=new JLabel("密码:");
JTextField jtf2=new JTextField(20);
JPanel jp2=new JPanel();
jp2.add(jl3);
jp2.add(jtf2);
JButton jb1=new JButton("登录"); JButton jb2=new JButton("注册");
JPanel jp3=new JPanel();
jp3.add(jb1);
jp3.add(jb2);
this.setTitle("登陆界面");
this.add(jl1);
this.add(jp1);
this.add(jp2);
this.add(jp3);
this.setVisible(true);
this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8c1f22db0e60eb239b5da3594f3bdd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05fd0cbd4dfe155968a8a9dfaa59599f/" rel="bookmark">
			keil5新建STM32工程文件--实践篇手把手教学（以STM32F103为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、文件与文件夹创建1.1 CMSIS文件夹创建1.2 FWLIB文件夹创建1.3 Project文件夹创建1.4 startup文件夹创建1.5 user文件夹创建1.6 readme文件创建 二、keil5工程创建三、芯片支持包下载四、小结 一、文件与文件夹创建 准备工作（参考上一篇博文）：
1、ST标准库的下载如图：
2、创建好如下文件夹：
1.1 CMSIS文件夹创建 在CMSIS文件夹中存放的是我们内核控制相关的文件，可以在之前我们下载好的ST标准库找到，如下图所示将文件复制粘贴进文件夹中：
名称文件所在标准库中的位置core_cm3.c\hen.stsw-stm32054_v3-6-0_v3.6.0\STM32F10x_StdPeriph_Lib_V3.6.0\Libraries\CMSIS\CM3\CoreSupportstm32f10x.h、system_stm32f10x.c\hen.stsw-stm32054_v3-6-0_v3.6.0\STM32F10x_StdPeriph_Lib_V3.6.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10xstm32f10x_conf.h 、stm32f10_it.c\hen.stsw-stm32054_v3-6-0_v3.6.0\STM32F10x_StdPeriph_Lib_V3.6.0\Project\STM32F10x_StdPeriph_Examples\ADC\3ADCs_DMA 由于stm32f10x_conf.h 、stm32f10_it.c\h是异常处理程序和的模板和包含了库配置文件标准库的头文件,直接从ST下载的标准库中的提供的Project里找到，如上述表格路径。
1.2 FWLIB文件夹创建 FWLIB文件夹是存放ST标准库文件的地方，里面有ST编写的提供给用户调用的规范化代码，例如对引脚口、系统时钟、DMA等等的操作，如下所示：
inc存放头文件，src存放的是源文件，可以直接从ST标准库里面复制粘贴
名称文件所在标准库中的位置inc、srcen.stsw-stm32054_v3-6-0_v3.6.0\STM32F10x_StdPeriph_Lib_V3.6.0\Libraries\STM32F10x_StdPeriph_Driver 1.3 Project文件夹创建 Project文件夹和上一篇说的一样这里主要放置的是通过keil5创建项目生成的文件像.uvprojx就是工程文件，以及一些输出文件，这些文件都是创建工程时keil自动生成的文件和文件夹，我们只需要建立一个文件夹存放keil编译时的输出文件即可。
1.4 startup文件夹创建 startup文件夹存放芯片的启动文件，怎么选择对应的芯片的启动文件请参考上一篇理论篇，如图所示：
名称文件所在标准库中的位置startup_stm32f10x_hd.sen.stsw-stm32054_v3-6-0_v3.6.0\STM32F10x_StdPeriph_Lib_V3.6.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm 1.5 user文件夹创建 user文件夹存放用户代码，我们这里先在里面新建main.c和main.h文件供后续keli工程建立时使用，如图所示：
1.6 readme文件创建 readme文件用来指示和注明本工程建立的目的，可以根据后续代码拓展新增加功能，如图是为了本次新建工程所用的工程文件的说明：
至此工程创建前的理论基础和实物基础都已经有了，接下来就是keil5软件里对工程的配置了~
二、keil5工程创建 第一步：打开keil5软件，依次点击Project—New uVision Project,如图所示：
第二步：继第一步后会弹出界面选择保存位置，这里我们将整个工程存放在Project文件夹中工程取名为template，注意工程的后缀名,点击保存,如图所示：
第三步：继第二步后会弹出如下框，是让我们选择芯片，我们用的是STM32F103VE，故依次选择STMicroelectronics—STM32F103—STM32F103VE—OK，这是芯片支持包提供的芯片种类，让编译器知道你用的是什么芯片，如果没有安装STM32F1的芯片支持包是没有芯片可以选择的。芯片支持包的获取见下一章。
第四步：继第三步后会弹出如下界面框Manage Run-Time Environment,可以用来配置 MDK 驱动和ST外设文件等，具体的作用我们后续博文再讲，大家也可以先搜一下他的功能，这里我们先点击Cancel,如下图所示：
完成后，可以在我们的Project文件夹看到keil创建的文件，以后我们就从Project—template进入我们的工程文件。
第五步：第四步后我们的工程就初步建立起来了，可以看到左侧的project项目区没有内容只有默认的文件（Target），接着点击如下按钮，开始在工程里面新建目录，将各个代码分类存放，如图所示：
点击左边区域的Target可以修改名称，这里我们修改为template，同理接着点击中间区域的Source Group1修改名称，点击第三个箭头处的新建按钮可以新建文件，依次建立如下文件，如下图所示：
序号①处是新建文件、②处是删除文件、③是上移选中的文件、④是下移选中的文件，创建完如下图所示的文件后点击OK完成创建，可以在左侧项目目录框看到我们新建好的目录结构，如下图所示：
第六步：接下来就要将我们上一章复制粘贴的文件与工程关联起来放入工程中，首先是把源文件（.c文件）引入工程，还是点击第五步的小按钮，如下图所示：
①先选中CMSIS，然后在②点击，添加文件，弹出界面，我们需要选中CMSIS中的源文件把他们添加进来，同理选中FWLB，点击Add Files…将FWLIB-src下的文件添加进来，添加startup文件时请注意，需要将寻找的类型换成所有文件，因为启动文件是.S结尾的，最后将新建的main.c也添加进user中，如下图所示：
将CMSIS文件夹中的源文件添加进来后，可以看到文件已经在右侧已经放进来了，同理完成后续的添加，如图所示：
FWLIB:
startup:
user:
最后点击下方的OK按钮，完成添加，完成后可以在左侧的项目框中看到我们添加的文件（FWLIB没展开，有点多），如图所示：
第七步：完成了源文件的添加，接着就是头文件的添加，点击魔术棒按钮，如下图所示：
点击后选中C/C++选项卡，在点击Include Paths后面的…按钮打开，如图所示：
点击①处新建后会出来②处空白的框在点击②处的…按钮添加路径，注意头文件的路径需要选择到头文件的根目录，我们把CMSIS、FWLIB-INC、main.h这些文件的路径包含进来。如下图所示：
如添加CMSIS文件夹中的头文件：
最后我们完成添加所有的头文件，点击确定如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05fd0cbd4dfe155968a8a9dfaa59599f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b0533f50cf11d3a50fcb1f83104e2ae/" rel="bookmark">
			Anaconda使用记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Anaconda下载与安装 一、下载安装包 1.打开清华镜像网站
https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/
2.官网
https://www.anaconda.com/products/individual
二、安装 默认安装 三、配置环境变量 1.sysdm.cpl–&gt;高级–&gt;环境变量
添加相应环境变量
例：
C:\software\anaconda3 C:\software\anaconda3\Scripts C:\software\anaconda3\Library\mingw-w64\bin C:\software\anaconda3\Library\bin 2.检查是否安装成功
在cmd 中输入以下命令，若输出版本信息，则安装成功。
conda --version 四、创建环境[命令行】 遇到的问题1：图形化界面，python版本只有python3.8 可以从anaconda的命令行创建
Anaconda Prompt (anaconda3) 1、创建虚拟环境【3.7】
conda create -n name python=3.7【python版本】 2、查看版本
conda version 3、查看环境
conda env list 4、进入环境
activate web[环境名字] 4、安装模块
conda install django=2.0【模块名】 5、将模块更新
conda uodate django 6、查看安装的模块
conda list 7、删除模块
conda remove django 8 切换环境[从创建的环境，切换到base
activate base 9、删除虚拟环境
conda remove -n web --all #--all 删除全部安装包 #-n 名字 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/554cdcf20b0c22044b4a0e7e523bfd75/" rel="bookmark">
			vue&#43;播放直播视频流（websocket的流文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 之前分享的有 rtmp直播流 ，flv直播流的一些方法，这里分享下，播放 websocket的直流的方法，使用的方法是JSMpeg，JSMpeg是JS写的视频、音频解码器，能使用WebGL&amp;Canvas2D渲染以及WebAudio声音输出。 目录： 相关资料：
1、官网入口
2、github
3、官方例子
4、gitee案例
实现效果：
遇到问题：
封装成组件，做视频的墙的效果，但是一页放9个以后，第一个视频会崩溃，查了资料以后，目前暂定支持8个，可能跟电脑配置也有很大的关系，1个使用，4个使用没发现问题
实现步骤：
1、引入配置文件：jsmpeg.min.js，源码看下面
2、main.js中调用该文件
3、页面使用：
template:
js中：
js中 方法二：
api配置：
4、jsmpeg.min.js源码：
相关资料： 1、官网入口 2、github 3、官方例子 4、gitee案例 实现效果： 暂无图片 遇到问题： 封装成组件，做视频的墙的效果，但是一页放9个以后，第一个视频会崩溃，查了资料以后，目前暂定支持8个，可能跟电脑配置也有很大的关系，1个使用，4个使用没发现问题 实现步骤： 1、引入配置文件：jsmpeg.min.js，源码看下面 2、main.js中调用该文件 import '/src/util/jsmpeg.min.js' 3、页面使用： template: &lt;div class="myVideo"&gt; &lt;canvas class="video-canvas" ref="video-canvas" style="width:100%;"&gt;&lt;/canvas&gt; &lt;/div&gt; js中： this.path = 'ws:...' //视频流地址 var canvas = this.$refs['video-canvas'] this.player = new JSMpeg.Player(this.path, { canvas: canvas }) js中 方法二： var player = new JSMpeg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/554cdcf20b0c22044b4a0e7e523bfd75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8538fc1badb490c1b52071c783775e07/" rel="bookmark">
			深度学习网络结构笔记----Depthwise卷积与Pointwise卷积--深度可分卷积-- GoogleNet，Xception，MobileNetv1--v3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1，常规卷积操作
1，什么是Depthwise Convolution
3，什么是Pointwise Convolution
4 ，参数对比
5，Depthwise Separable Convolution（深度可分卷积）
5.1 GoogleNet
5.2 Xception
5.2.1 Xception的演变过程
5.2.2 Xception架构
5.3 MobileNet结构
5.3.1 MobileNet V1的基本结构
5.3.2 MobileNet v2
5.3.3 MobileNet v3
1，常规卷积操作 对于一张5×5像素、三通道彩色输入图片（shape为5×5×3）。经过3×3卷积核的卷积层（假设输出通道数为4，则卷积核shape为3×3×3×4），最终输出4个Feature Map，如果有same padding则尺寸与输入层相同（5×5），如果没有则为尺寸变为3×3。
Depthwise Separable Convolution是将一个完整的卷积运算分解为两步进行，即Depthwise Convolution与Pointwise Convolution。 Depthwise(DW)卷积与Pointwise(PW)卷积，合起来被称作Depthwise Separable Convolution(参见Google的Xception)，该结构和常规卷积操作类似，可用来提取特征，但相比于常规卷积操作，其参数量和运算成本较低。所以在一些轻量级网络中会碰到这种结构如MobileNet。
1，什么是Depthwise Convolution 不同于常规卷积操作，Depthwise Convolution的一个卷积核负责一个通道，一个通道只被一个卷积核卷积。上面所提到的常规卷积每个卷积核是同时操作输入图片的每个通道。
同样是对于一张5×5像素、三通道彩色输入图片（shape为5×5×3），Depthwise Convolution首先经过第一次卷积运算，不同于上面的常规卷积，DW完全是在二维平面内进行。卷积核的数量与上一层的通道数相同（通道和卷积核一一对应）。所以一个三通道的图像经过运算后生成了3个Feature map(如果有same padding则尺寸与输入层相同为5×5)，如下图所示。
Depthwise Convolution完成后的Feature map数量与输入层的通道数相同，无法扩展Feature map。而且这种运算对输入层的每个通道独立进行卷积运算，没有有效的利用不同通道在相同空间位置上的feature信息。因此需要Pointwise Convolution来将这些Feature map进行组合生成新的Feature map。
3，什么是Pointwise Convolution Pointwise Convolution的运算与常规卷积运算非常相似，它的卷积核的尺寸为 1×1×M，M为上一层的通道数。所以这里的卷积运算会将上一步的map在深度方向上进行加权组合，生成新的Feature map。有几个卷积核就有几个输出Feature map。如下图所示。
简而言之，
Depthwise ：就是在depth上面做文章，就是常说的channel ,对不同的channel使用不同的卷积核卷积提取特征
Pointwise：就是正常的卷积方式啦，但是是point的，就是对某一点，某一像素，所以kernel=[1,1]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8538fc1badb490c1b52071c783775e07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64e2aebf36ffde05cca2e187738df217/" rel="bookmark">
			IPD解读——市场管理（MM）方法论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前 言 之前在战略与规划对齐中提到了MM方法论，由于篇幅原因，没有细细解读。今天详细说说一下市场管理。
俗话说“凡事预则立，不预则废”,企业也一样，规划工作是非常重要的，有些中国企业的产品规划没有掌握科学合理的方法，规划也变成了“鬼话”。在产品为王的时代，产品是战略的核心，不管是公司整体战略，还是业务战略均应以产品为主线。华为等一些知名的企业在战略与规划中使用市场管理（Market Management），市场管理流程是华为公司核心流程之一，它运用严格、规范的方法对市场走势及客户的要求及需求进行分析，创建合理的市场细分规则，对要投资和取得领先地位的细分市场进行选择和优先级排序，从而制定可执行的业务活动。通过从业务流程的角度定义确保市场营销取得成功需要执行的活动，制定可盈利、可执行的业务计划和驱动新产品包的开发，此流程能够使公司或产品线的各项举措成功地付诸实施。
俗话还说“方向不对，努力白费”，市场管理流程的目的是为产品线、产品族及产品营销计划实现价值创造提供一致的分析。这样，公司能够通过明智的投资创造最大的价值。它运用严格、规范的方法对市场走势及业务要求及时进行分析，创建合理的市场细分规则，对要投资和取得领先地位的细分市场进行选择和优先级排序，从而制定可执行的业务计划。通过从业务流程的角度定义确保市场营销取得成功需要执行的活动，制定可盈利、可执行的业务计划和驱动新产品包的开发，使一个公司或产品线的各项举措成功地付诸实施。简单来讲就是规避企业在规划中的典型问题,所以市场管理流程对一个力图取得商业成功的组织来说是非常重要的。
MM方法论的基本内容 下面我们将从MM方法论主要角色和MM主要步骤以及MM方法论在企业中的应用几个方面解读MM方法论。
MM方法论主要角色
MM流程的主要角色是IRB/ IPMT、PMT
IRB：投资评审委(Investment Review Board），IRB在EMT制定的总的战略方向指导下进行执行操作的审批和监控，以及做方向上的研究、决策，重点在于理解客户需求，形成解决方案，并推动各产品线、研发、 Marketing、销售、全球技术服务和供应链等部门全流程的协作，制定均衡的业务计划，使EMT重点关注公司范围最关键的问题。
IPMT：产品线集成组合管理团队(Product Line Integrated Portfolio Management Team)，IPMT是IPD体系中的产品投资决策和评审机构，负责制定公司总的使命愿景和战略方向，对各产品线运作进行指导和监控，并推动各产品线、研发、市场、销售、事业部、服务和供应链等部门全流程的协作，制定均衡的公司业务计划，并对新产品线的产生进行决策。
IPMT职责体现在以下几个方面：
1、总体管理职责，包括了开发公司的使命、目标、战略和业务计划并向各产品线发布；审批公司技术、产品路标，确保与公司战略保持一致；审批重要的跨产品线技术投资，并根据需要跨产品线调配资源。
2、 产品线管理职责，包括了发起新的产品线；协调和指导各产品线工作；指导各产品线确定愿景、使命、战略目标和投资优先级；审视、批准和监控各产品线的产品线业务计划，确保各产品线业务计划与客户需求、公司战略保持一致；根据成长性、盈利能力、资源可获得性及风险等因素，审批针对各产品线新的细分市场投资或撤资；管理和监控各产品线新的业务领域和新市场的投资组合，包含产品组合和新市场机会；审批各产品线新产品的引入、退出与过渡；审批预算与资源计划，实现各产品线间的资源优化配置。
PMT:产品线组合管理团队(portfolio Managment Team)，与PDT类似，是跨部门团队。PMT的组成:主任、业务规划、市场分析、需求管理、S-PMT代表或解决方案管理、大客户Marketing代表、区域Marketing代表、国内/国外销售部代表、预测、定价、技术规划、预算/损益、技术服务、订单履行/制造/采购、HR、OPS、执行秘书。
PMT产品线组合管理团队的主要职责：
1、制定和维护产品线业务计划。
执行市场管理流程，制定出产品线业务计划。制定符合公司总体战略与执行模型的产品线战略与执行模型。利用不同使能流程的输出(例如：需求，竞争分析，机会分析等)。
2、制定和维护产品组合与路标。
根据业务计划的输出，形成产品组合。执行PDC模型，将所确定的项目排序。利用不同使能流程的输出(例如：市场与竞争分析，技术趋势发展等)。
3、制定项目任务书（Charter）。
执行项目任务书(Charter)开发流程。制定交付件(Charter及项目背景材料，IO/ SBP)并提交PL-IPMT审批。在PL-IPMT评审项目任务书之前，与产品线相关成员沟通。参与PDT概念阶段的工作，保证从项目开工到概念阶段的平滑过渡。
4、审核产品线的技术路标规划。
根据规划提出修订意见，保技术规划与产品规划的一致性。
5、制定产品线的产品预研规划。
6、纠正措施建议。
对产品线业务计划的执行情况进行评估，向IPMT提出纠正措施建议。
7、成立专项小组。
根据业务开展的需要，PL-PMT可确定相关工作组来处理本产品线的业务提升和机会捕捉，例如：对主要竞争对手/客户，降成本等的深入分析。
MM方法论主要步骤
市场管理（Market Management）流程主要分为6个步骤：
STEP1:理解市场
要想规划要怎么做，为制定计划提供有效的参考依据。通过市场调查、数据收集、竞争分析、自身分析、SWOT分析、市场地图、业务设计评估理解愿景、使命和目标、确定潜在的机会目标。
STEP2:市场细分
制定确定细分市场的标准，即明确我们衡量细分市场的维度、标准和权重，方便能够有效的收集细分市场的数据并度量结果。需要对市场进行细分，然后对细分市场进行调研，初步的细分市场分析，根据细分市场分析明确企业细分市场有哪些。
STEP3:组合分析
针对筛选出的细分市场，采用“理解市场”中阐述的方法，对市场外部环境及企业内部资源能力进行更加深入的研究，做到外部与内部的对齐，以及长中短期的对齐。这也就需要对各细分市场进行优先级排序；明确细分市场跟交付的产品、服务、解决方案之间的对应关系。
STEP4:制定业务战略规划
通过理解市场、细分市场和组合分析，形成了总体规划。之后还需要解决“如何竞争”这一关键命题，业务计划战略的制定是一个从上到下的过程，各细分市场需要根据目标、价值定位及竞争分析制定详细的行动计划确保总体规划的实现，过程中细分市场内部的功能部门相互协同，实现上下对齐，即高层总体规划、中层细分市场规划及基础执行层的一致。
STEP5:融合和优化业务计划
仅仅上下对齐是不够的，还需要左右对齐，即不同细分市场之间或不同职能部门之间的匹配。因此融合和优化业务计划是从上到下，互相结合的过程。最终目的是通过整合并协调各细分市场及职能部门的资源，达到资源的优化配置，避免资源支持不足及浪费。
STEP6:管理业务计划
当完成业务计划制定后，企业需要对业务计划进行闭环管理，监控业务计划的实施以确保计划的正常运行，并根据评估结果对业务计划进行调整，需要时对业务计划进行刷新。
市场管理过程实际上永远没有结束的时候，在实际运作的时候并不是线性、单向的，而是不断循环往复，实现螺旋式上升，就像PDCA一样。因为外部环境在不断地变化，促使管理层不断地评估客户需要和需求，管理层团队可以通过市场管理流程定义的管理体系不断地对以往的投资决策进行审视，并做出适当的调整”。
MM方法论在企业的应用
MM方法论在企业如何应用?
1、将战略与运营的集成--SP与BP的管理思路
2、中长期战略与年度规划--SP与BP的具体操作
3、产品线规划--Roadmap方法论
4、项目任务书规划--charter怎么写
5、技术平台和各领域规划--平台搭建技巧
我们重点聊一下技术平台和各领域规划，技术和平台规划是为平台化开发和支撑中长期战略奠定基础的。平台化开发是先做好准备工作再开发产品（将产品开发和技术开发相对分离）。
这样做可以确保开发过程的稳定性，不会有技术瓶颈而打乱整个开发计划；平台化是将核心技术，成熟技术在不同产品线和不同产品之间共享，这些技术决定了相关产品的主要功能和性能，又能够提高效率，说到底效率是企业的核心竞争力；再回到需求上，我们要清楚的知道技术和平台规划是面向未来的，所以在做这块规划时，要跟战略方向保持一致。最后，技术和平台规划不局限于研发技术，人力资源，供应链，质量等都适用。
产品规划成功落地的关键
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64e2aebf36ffde05cca2e187738df217/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0726df06d811cdb203cf39daaa06d09/" rel="bookmark">
			Chrome handless
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 from selenium import webdriver from selenium.webdriver.chrome.options import Options def share_browser(): chrome_options = Options() chrome_options .add_argument( ' --headless') chrome_options.add_argument( ' --disable-gpu') # path是你自己的chrome浏览器的文件路径 path = r'C:\Program Files\Google\Chrome\Application\chrome.exe' chrome_options. binary_location = path browser = webdriver.Chrome(chrome_options=chrome_options) return browser browser = share_browser() url = 'https: //www.baidu. com' browser.get(url) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4cd8f2bd0dfc5ac5d5840402bc035dc/" rel="bookmark">
			Hive中ORDER BY、SORT BY和DISTRIBUTE BY
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ORDERBY ORDERBY在Hive中的作用同标准SQL中一样，对结果集进行整体排序，ORDER BY 会对结果集进行一个全局排序，所有数据将被放在一个reducer当中处理。
当结果数据量大时，使用ORDER BY不可取，一个reducer处理整个数据集排序进程会很缓慢，不论通过mapreduce.job.reduces参数设置几个reducer，ORDER BY只会使用一个reducer。
SORTBY SORT BY会对被随机（随机分配数据是为了防止数据的倾斜）分配到每个reducer中的数据集进行排序，注意这种排序在单个reducer是有序的，但不是全局有序。
现有一张hive表：
hive (db_test)&gt; select * from new_score; OK new_score.id	new_score.score	new_score.clazz	new_score.department 111	69	class1	department1 112	80	class1	department1 113	74	class1	department1 114	94	class1	department1 115	93	class1	department1 121	74	class2	department1 122	86	class2	department1 123	78	class2	department1 124	70	class2	department1 211	93	class1	department2 212	83	class1	department2 213	94	class1	department2 214	94	class1	department2 215	82	class1	department2 216	74	class1	department2 221	99	class2	department2 222	78	class2	department2 223	74	class2	department2 224	80	class2	department2 225	85	class2	department2 NULL	NULL	NULL	NULL NULL	NULL	NULL	NULL 设置reducer个数为3，并使用SORT BY排序：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4cd8f2bd0dfc5ac5d5840402bc035dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd10d45a6036f57f17fffada558b7c88/" rel="bookmark">
			分享一下秋招经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的秋招结束了。感觉走了很多弯路也有很多幸运的地方。下面关于秋招做一下总结。
下面先流水账记录一下我的秋招。
首先我是2020年10月份开始想准备秋招的，那时候小论文已经写完了。因为疫情原因找工作特别难，焦虑体质的我，非常焦虑。然后，我男朋友告诉我最好找个实习。于是我开始找实习。济南没有什么搞视觉的厂，去了高新区槐荫区，面了两个小公司，都不太满意，而且通勤时间太长。一个做检测带不带安全帽的，一个是做深度学习教育平台的。然后面了浪潮，当时还不会C++，面了一下线上。后来浪潮给我打电话，线上面了一下，就去了浪潮实习了。
2020.11.3号去浪潮实习。做的是模板图像OCR识别，带我的师傅特别好，我非常感激他，他算是我职场第一个老师了，平时放养我，不给我太大压力，还帮我重装系统。他跟我说最好去南方就业，不要留在济南。周围的人基本都是学Java的，因为我们实验室都是学C++和MATLAB，我开始怀疑应该学什么语言。后来这个项目做完了，我就回学校了。正好论文大修。
后来就是放寒假，基本就是玩耍。来年开学我傻了，春招的实习开始了！！当时问了一下去拼多多的师兄怎么搞的，他说要学计算机操作系统等等。我啥都没学啊，抓紧开始学，那时候我的语言也从C++转到了Java。面了美团的客户端，居然坚持到了三面主管问我（你有没有想过之前做机器学习转到开发很容易，但是再转回去就难了。）。面了阿里的一面，全挂了。笔试也不会。后来就根据实习面试经验，开始准备秋招。
学了Java基础、Java并发、计算机网络、操作系统、数据结构与算法、Redis、数据库。刷力扣。就从网上找经典的教材，看哔哩的视频学习。做好笔记。后来，提前批开始了，大概在六月份。我开始广投，结果开发的一个没过。拼多多一面挂，商汤一面挂，美团一面挂。拼多多面试官告诉我，我的问题是算法不行。然后又开始刷剑指offer练习手撕代码。期间投了很多中厂的算法岗。没有想到，从来没有准备的算法居然都过了（？？？）
正式秋招开始了，拿到两个算法的offer之后我就放飞自我，玩耍了一段时间。后来在牛客网上脉脉上看我的offer一片骂声。然后我又开始找工作了。银行运营商啥的，我全投了，还有，绿盟科技等，面试官说我没有项目，不行。招银科技也说我基础不行。就这样我的Java几乎全军覆灭。后来投了苏小研，没有想到苏小研竟然过了。联通软件研究院也过了。后来，在纠结要不要签前面的岗位的时候，我犹豫了很久吧，后来还是签了。
说了好多，对于我秋招，总结如下：
1、要找和自己简历相匹配的职位。我找到的第一份工作就是做OCR的因为我有相应实习，很快就过了。而找春招实习的时候，啥都不会。就凉透了。学Java的一定要有一个Java项目。
2、不要死磕某一个公司。就像我的同学死磕华为，结果今年华为缩招了。
3、要实习。实习的时间，最好是春招的时候，那时候大家基础不好，你可以趁机上岸。有个实习经验非常重要。
4、心态要稳。这个只能靠多练。多面试。慢慢你就不紧张了。而且不要沉在一个面试里出不来。最好记录一下自己的面经。我就不想回忆的类型。
5、信息获取的渠道：牛客网（面经、招聘时间）、offershow（薪资）、脉脉（看公司评价）、知乎（看公司评价）、前程无忧智联招聘（国企）、自己学校的就业信息网、别人学校的就业信息网。
6、早投！！！一定不要想着，我没有准备好，越往后越难。
7、在投之前就确定好哪一个公司想去，哪一个不太想去，因为笔试面试很有可能撞在一起，而且笔试面试很浪费时间，所以最好分清楚自己想去的地方，就认真准备。有很多同学不想去北京，但是投了很多北京，做了笔试，面试的时候就不想去面，这种还不如不面。
8、多交流，和不同人交流，不要自己闷头学。信息一定要灵通。不要错过招聘。
9、想清楚自己想要钱还是稳定。现在的工作分为（不稳定钱多加班、稳定钱少不加班、稳定钱多加班、稳定钱少加班）
能不能接受加班
能不能接受钱少
能不能不稳定
一开始我就想找个不加班的，结果我发现绝大多数都加班，有的加班钱少。最后我决定还是去加班钱多的地方了。
10、国企招聘非常晚，现在十一月份还有面试笔试，黄花菜都凉了好吧。
11、行业比较重要，不要去夕阳行业，比如在线教育和房地产。
12、早刷题，先看算法导论，记住经典题目，再刷剑指offer，再分组刷力扣，做好记录，多刷几遍就明白了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d1c2ceadc7e54f611e71c836c84c29d/" rel="bookmark">
			【嵌入式AI部署】轻量化神经网络精述--MobileNet V1-3、ShuffleNet V1-2、NasNet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：
【嵌入式AI部署&amp;基础网络篇】轻量化神经网络精述--MobileNet V1-3、ShuffleNet V1-2、NasNet
深度神经网络模型被广泛应用在图像分类、物体检测等机器视觉任务中，并取得了巨大成功。然而，由于存储空间和功耗的限制，神经网络模型在嵌入式设备上的存储与计算仍然是一个巨大的挑战。
前面几篇介绍了如何在嵌入式AI芯片上部署神经网络：
【嵌入式AI开发】篇五|实战篇一：STM32cubeIDE上部署神经网络之pytorch搭建指纹识别模型.onnx
在移动端部署深度卷积网络，无论什么视觉任务，选择高精度的计算量少和参数少的骨干网是必经之路。因此，本篇主要跟大家一起简单回顾下轻量化网络的发展历程，把握轻量化网络的发展方向，以更好选择和设计轻量化网络进行移动端部署。
目前的一些主要的轻量化网络及特点如下：
MobileNet V1--2017：提出深度可分离卷积；
MobileNet V2--2018：提出反转残差线性瓶颈块；
MobileNet V3--2019：高效的网络构建模块与互补搜索技术组合；
ShuffleNet V1-2017：结合使用分组卷积和通道混洗操作；
ShuffleNet V2--2018：高效网络设计的四个准则；
NasNet--2017：神经网络结构搜索；
以下按时间顺序一一精述各类轻量化网络的核心，更多细节请参考原论文。
1. NasNet--2017 论文介绍：
《Learning Transferable Architectures for Scalable Image Recognition》 来自Google Brain的一篇著作，是基于前一篇NAS–Neural Architecture Search With Reinforcement Learning 的改进，使得能让机器在小数据集（CIFAR-10数据集）上自动设计出CNN网络，并利用迁移学习技术使得设计的网络能够被很好的迁移到大数据集（ImageNet数据集），同时也可以迁移到其他的计算机视觉任务上（如目标检测）。
论文地址：
https://arxiv.org/pdf/1707.07012.pdf
代码：
https://github.com/tensorflow/models/tree/master/research/slim/nets/nasnet
主要核心点介绍：
（1）延续NAS论文的核心机制使得能够自动产生网络结构； 如上图所示，简而言之就是使用RNN来生成网络结构，然后在数据集上进行训练，根据收敛后的准确率对RNN进行权重调整。
（2）采用resnet和Inception重复使用block结构思想；
如上图所示，NASNet 仅对模型的整体结构进行了设置，具体的模块或神经元并未预定义，而是通过强化学习搜索方法完成的。如序列重复的次数 N 和初始的卷积核形状都是自由参数，用于模型的缩放。
此外， 类似resnet和inception一样，进行基本block的堆叠生成最终网络。因此搜索最优网络的时候，只搜索最优block。这样的好处，1)可以极大的加快搜索速度2)基础block对其他分类，检测问题都具有很好的泛化能力。
（3）设计了新的搜索空间，即NASNet search space，并在实验中搜索得到最优的网络结构NASNet；
该部分是论文的核心所在，如上图所示，每个网络单元由 B块 的网络块（block）组成，在实验中 B=5 。每个块的具体形式如图右侧部分，每个块有并行的两个卷积组成，它们会由控制器决定选择哪些Feature Map作为输入（灰色部分）以及使用哪些运算（黄色部分）来计算输入的Feature Map。最后它们会由控制器决定如何合并这两个Feature Map。在 NASNet 中，由 RNN 构成的控制器使用两个初始的隐藏状态，迭代地对余下的卷积神经元的结构进行预测。具体步骤是：
Step1：从hidden states（前面block中产生的）中选择一个hidden state—hi-1作为输入； Step2：重复step的操作，选择一个hidden state—hi； Step3：为step1中选择的hidden state选择一个操作； Step4：为step2中选择的hidden state选择一个操作； Step5：选择一个方法去连接step3和step4中的输出从而产生一个new hidden state，并将其添加到hidden states中。 其中，步骤3和步骤4可选的运算包括:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d1c2ceadc7e54f611e71c836c84c29d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75ecd78fa841b32b3b4e3962d717ff91/" rel="bookmark">
			excel 公式规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考官网
公式组成 公式还可包含下列所有内容或其中之一：函数、引用、运算符和常量。
函数：PI() 函数返回 pi 值：3.142…引用：A2 返回单元格 A2 中的值。常量：直接输入到公式中的数字或文本值，例如 2。运算符：^（脱字号）运算符表示数字的乘方，而 *（星号）运算符表示数字的乘积。 引用规则 对名为 Marketing 的工作表的引用引用 B1 到 B10 的单元格区域感叹号 (!) 将工作表引用与单元格区域引用分开 注意: 如果引用的工作表中有空格或数字，则需要在工作表名称前后添加单撇号 (’)，如=‘123’!A1 或 =‘January Revenue’!A1。
默认情况下，Excel 使用 A1 引用样式，此样式引用字母标识列（从 A 到 XFD，共 16,384 列）以及数字标识行（从 1 到 1,048,576）。
引用用法列 A 和行 10 交叉处的单元格A10在列 A 和行 10 到行 20 之间的单元格区域A10:A20在行 15 和列 B 到列 E 之间的单元格区域B15:E15行 5 中的全部单元格5:5行 5 到行 10 之间的全部单元格5:10列 H 中的全部单元格H:H列 H 到列 J 之间的全部单元格H:J列 A 到列 E 和行 10 到行 20 之间的单元格区域A10:E20 各种引用方式 相对引用 公式中的相对单元格引用（如 A1）是基于包含公式和单元格引用的单元格的相对位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75ecd78fa841b32b3b4e3962d717ff91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2585fc74cdd8bf504e98b62bad260a27/" rel="bookmark">
			Shell---第五天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、编写函数，实现打印绿色OK和红色FAILED
判断是否有参数，存在为Ok，不存在为FAILED
[root@localhost ~]# vim printcolor.sh #!/bin/bash fun(){ if [ $# -ne 0 ] then echo -e "\033[32m OK \033[0m" else echo -e "\033[31m FAILED \033[0m" fi } read -p "请输入参数：" i fun $i 测试：
2、编写函数，实现判断是否无位置参数，如无参数，提示错误
[root@localhost ~]# vim position.sh #!/bin/bash fun(){ if [ $# -eq 0 ] then echo "无位置参数！" else echo "位置参数为：$@" fi } read -p "请输入参数：" i fun $i 测试：
3、编写函数实现两个数字做为参数，返回最大值
[root@localhost ~]# vim max.sh #!/bin/bash fun(){ if [ $a -gt $b ] then echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2585fc74cdd8bf504e98b62bad260a27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb5dd2ffc91fa3446be4afbae03d8fd3/" rel="bookmark">
			C#，反序列化，找不到程序集，无法加载进行反序列化所需的类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unity给游戏做socket传输数据测试工具遇到的。
找不到程序集，创建和unity程序集同名的项目，Assembly-CSharp。
无法加载进行反序列化所需的类型，添加现有项，把所需要的cs文件从unity项目中导进去。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0daea04325ea3dbb9c0074edb9b1ba93/" rel="bookmark">
			函数的递归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数递归 这是本章的重点内容
目录
函数递归 一．什么是递归？
二．两个例子帮助我们理解递归函数
三．求ｎ的阶乘
四.求第n个斐波那契数。
五.递归的几个练习 一．什么是递归？ 大师 L. Peter Deutsch 说过：To Iterate is Human, to Recurse, Divine.中文译为：
人理解迭代，神理解递归。 人理解迭代，神理解递归。毋庸置疑地，递归确实是一个奇妙的思维方式。 简单理解递归与循环：
递归：你打开面前这扇门，看到屋里面还有一扇门。你走过去，发现手中的钥匙还可以打开它，你推开门，发现里面还有一扇门，你继续打开它。若干次之后，你打开面前的门后，发现只有一间屋子，没有门了。然后，你开始原路返回，每走回一间屋子，你数一次，走到入口的时候，你可以回答出你到底用这你把钥匙打开了几扇门。 循环：你打开面前这扇门，看到屋里面还有一扇门。你走过去，发现手中的钥匙还可以打开它，你推开门，发现里面还有一扇门（若前面两扇门都一样，那么这扇门和前两扇门也一样；如果第二扇门比第一扇门小，那么这扇门也比第二扇门小，你继续打开这扇门，一直这样继续下去直到打开所有的门。但是，入口处的人始终等不到你回去告诉他答案。 递归的内涵
1、定义 (什么是递归？)
在数学与计算机科学中，递归(Recursion)是指在函数的定义中使用函数自身的方法。实际上，递归，顾名思义，其包含了两个意思：递 和 归，这正是递归思想的精华所在。
2、递归思想的内涵(递归的精髓是什么？)
正如上面所描述的场景，递归就是有去（递去）有回（归来），如下图所示。“有去”是指：递归问题必须可以分解为若干个规模较小，与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决，就像上面例子中的钥匙可以打开后面所有门上的锁一样；“有回”是指 : 这些问题的，演化过程是一个从大到小，由近及远的过程，并且会有一个明确的终点(临界点)，一旦到达了这个临界点，就不用再往更小、更远的地方走下去。最后，从这个临界点开始，原路返回到原点，原问题解决。　毋庸置疑地，递归确实是一个奇妙的思维方式。对一些简单的递归问题，我们总是惊叹于递归描述问题的能力和编写代码的简洁，但要想真正领悟递归的精髓、灵活地运用递归思想来解决问题却并不是一件容易的事情。 递归的作用
它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解， 递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。 递归的主要思考方式在于：把大事化小
二．两个例子帮助我们理解递归函数 这里我们举一个具体的例子
接受一个整型值（无符号），按照顺序打印它的每一位。 例如： 输入：123，输出 1 2 3
void print(unsigned int n) { if (n &gt; 9) { print(n / 10); } printf("%d ", n % 10); } int main() { unsigned int num = 0; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0daea04325ea3dbb9c0074edb9b1ba93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d0c306be23e4f8f9d8b7fd7e7c5cae/" rel="bookmark">
			Invalid character found in the request target. The valid characters are defi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上很多说法是：
lsof -i :端口
这是linux的，如果无效说明你没有安装
运行um install lsof -y安装
正确方法（windows）
netstat -ano|findstr 端口号
找到进程号（或者打开任务管理器，kill进程号的java.exe）
taskkill /f /t /im 进程号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8438c8b6c499714ac2df89af9ee620b4/" rel="bookmark">
			Oracle 创建只读用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击跳转https://blog.csdn.net/gmaaa123/article/details/103617021
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d5cc9229ad6eaaa2a4a393cef5eb6b/" rel="bookmark">
			C语言：控制语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		控制语句是C语句五类中的一类，其中，控制语句也可以再分为三类：
1. 条件判断语句or分支语句
2. 循环语句
3. 转向语句
其中，第一类包括 if 语句：这个语句是很常用的，而且用起来也不难，唯一一个可能会被忽视的知识点是悬空 else -- else 是和离它最近的 if 进行匹配；第一类还包括 switch 语句，具体格式如下：
switch（整型表达式）
{
case（整型常量表达式）：
……
break；
……
default（默认，相当于 else）：
……
break；
}
第二类则是包括 do……while 语句；while 语句；for 语句三种，但是他们只是逻辑顺序不同。
其中，在循环语句中，会经常用到以下几个知识点：
1. getchar：获取（输入）一个字符。
2. putchar：输出一个字符。
注：1、2只能针对字符
3. scanf("%s", …) 读取字符串时，遇到空格就会结束（这个经常会忘记！！！）。
对于 for 来说，也有以下几点：
1. for 的初始化，判断，调整三个部分都可以省略。
2. 中间的判断部分如果省略，意味着判断恒为真，就构成了死循环。
3. 如果条件允许，不建议省略 for 循环的3个表达式。
第三类转向语句则包括 break 语句、continue 语句、goto 语句、return 语句
1. break：永久终止循环。
2. continue：跳过本次循环后面的代码，直接跳到 while 语句判断部分，进行下一次循环的入口判断。
3. goto：只能在同一个函数中，不能跨函数跳转。一般情况下是用不到的，但是，在某些场合中用得到，最常见的是终止程序在某些深度嵌套的结构的处理过程，例如：一次跳出两层或多层循环（这种情况 break 是达不到目的的）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dafd13324e5d16fac364041168f321c/" rel="bookmark">
			c&#43;&#43;模板编程-模板静多态-标签分发实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++模板编程里面有一个东西叫 标签分发
这个东西的作用是实现静多态
c++ advance， distance等 很多函数都是基于该技巧实现的
下面基于该技巧实现一个函数
该函数的作用是输出数组
但是我们知道 char buffer[n] 数组， 我们大可不必一个一个 cout 的
下面实现一个萃取，针对 char 特化， 这个萃取的可用实现方式众多
#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;memory&gt; #include &lt;type_traits&gt; using namespace std; // c++模板编程-模板静多态-标签分发实例 template&lt;typename T&gt; struct is_char : public false_type { }; template&lt;&gt; struct is_char&lt;char&gt; : public true_type { }; template&lt;typename T&gt; struct isChar : public is_char&lt;typename remove_cv&lt;T&gt;::type&gt; { }; // 非 char数组输出 template&lt;typename T, size_t N&gt; void printArrayImp(T(&amp;arr)[N], std::false_type) { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dafd13324e5d16fac364041168f321c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b8ee42228c62fb6db10f25c9617a218/" rel="bookmark">
			shell 第五次作业（函数、数组）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、编写函数，实现打印绿色OK和红色FAILED 判断是否有参数，存在为Ok，不存在为FAILED [root@bogon shell]# vim printcolor.sh //脚本内容如下： #!/bin/bash fun(){ if [ $# -ne 0 ] then echo -e "\033[32m OK \033[0m" else echo -e "\033[31m FAILED \033[0m" fi } read -p "请输入参数：" i fun $i 测试
2、编写函数，实现判断是否无位置参数，如无参数，提示错误 [root@bogon shell]# vim weizhi.sh //脚本内容如下： #!/bin/bash fun(){ if [ $# -eq 0 ] then echo "无位置参数！" else echo "位置参数为：$@" fi } read -p "请输入参数：" i fun $i 测试
3、编写函数实现两个数字做为参数，返回最大值 [root@bogon shell]# vim fun_max.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b8ee42228c62fb6db10f25c9617a218/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b290ee9977ce21696d302e9ca76a5fa1/" rel="bookmark">
			聊一聊SpringBoot中酷炫的Banner
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不要着急，最好的总会在最不经意的时候出现。—— 泰戈尔
文章目录 自定义文本banner自定义图片banner隐藏Banner源码浅析 SpringBoot项目在启动的时候，我们可以看到控制台会打印一个Spring的图案，这个是SpringBoot默认的Banner图标。个人觉得Banner对于项目整体实用性其实没那么大，但是生活需要一点酷，工作亦是如此。 默认的banner：
自定义文本banner banner生成网站：http://patorjk.com/software/taag
在src\main\resources目录下创建banner.txt文件，保存banner图案，重启SpringBoot项目就会输出新banner。
SpringBoot默认找寻的文件名是banner.txt，更换文件名会导致找不到banner图案，可以在配置文件中指定banner文件名。
spring.banner.location = classpath:xxx.txt xxx.txt表示banner文件名 SpringBoot提供了一些关于banner颜色和背景颜色以及版本号的获取AnsiColor和AnsiBackground提供了多种颜色供开发者选择。
${AnsiColor.RED} ${AnsiBackground.BRIGHT_BLACK} .__ .__ |__| | | _______ __ ____ ___.__. ____ __ __ | | | | / _ \ \/ // __ \ &lt; | |/ _ \| | \ | | | |_( &lt;_&gt; ) /\ ___/ \___ ( &lt;_&gt; ) | / |__| |____/\____/ \_/ \___ &gt; / ____|\____/|____/ \/ \/ MANIFEST版本号:${application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b290ee9977ce21696d302e9ca76a5fa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32060e78b37f92089e399c1473d8dbd9/" rel="bookmark">
			JS 装饰器（ Decorator ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS 装饰器（ Decorator ） 文章目录 JS 装饰器（ Decorator ）一.概念二.特点三.使用方式1.安装依赖2.配置文件.babelrc3.引入注册babel4.使用 三.装饰器原理`Object.defineProperty()`1.装饰-类2.装饰-类属性（属性，方法，get/set函数）1. 装饰方法2. 装饰类属性（字段）3.装饰getter和setter函数 3.多个装饰器执行顺序4.装饰器不能用于函数 一.概念 说起装饰器之前，先了解一下JS设计模式之装饰器模式。装饰器模式（Decorator Pattern）能够在不改变对象自身的基础上，动态的给某个对象添加额外的职责，不会影响原有的功能。这种类型的设计模式属于结构型设计模式，它是作为现有的类的一个包装
JS 装饰器(Decorator)
装饰器（Decorator）目前仍然处于第2阶段的提案中，提案地址 它可以用来装饰类、方法、属性，然后再进行功能的扩展。
之前在写 React 高阶组件（HOC） 介绍过这个装饰器模式的概念，与接下来我们要讲的，原理是一样的。
二.特点 装饰器是一种函数，写成@函数名的形式,它可以放在类和类方法的定义前面
三.使用方式 在使用装饰器的时候，我们需要引入babel模块transform-decorators-legacy，进行编译！
1.安装依赖 $ npm install @babel/cli @babel/core @babel/plugin-proposal-class-properties @babel/plugin-proposal-decorators @babel/plugin-transform-runtime @babel/preset-env @babel/register babel-loader --save-dev 2.配置文件.babelrc 创建babel 配置文件 .babelrc进行编译
{ "presets": [ "@babel/preset-env" ], "plugins": [ ["@babel/plugin-proposal-decorators", { "legacy": true }], ["@babel/plugin-proposal-class-properties", { "loose" : true }], "@babel/plugin-transform-runtime" ] } 3.引入注册babel 在工程项目的入口文件中引入 @babel/register
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32060e78b37f92089e399c1473d8dbd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b1b09d6940ab4bddb3ba8511aa018d/" rel="bookmark">
			百度文库f12免费复制文章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以往写作文找到好的文章借鉴的时候会发现复制需要付费或者开通会员。
观看此博客，你会学会白嫖付费文章复制！
1、在要复制文字的页面 f12
2、在f12打开的设置里面或者三个竖着的点里面找到 settings
3、把这两个√上
Disable javascript (禁用javascript)
Disable async stack traces
直接复制（如不行就刷新复制）
以谷歌浏览器为例!
其他浏览器同理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc79ea121b49ce3351c944f89d4ac30e/" rel="bookmark">
			spinal HDL - 04 - Spinal HDL - 组件、层次结构和区域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 本文主要介绍了spinal HDL的组件、层次结构和区域。
组件和层次结构（Component and hierarchy） 就像在 VHDL 和 Verilog 中一样，可以定义可用于构建设计层次结构的组件。但是，在 SpinalHDL 中，不需要在实例化时绑定它们的端口：
class AdderCell extends Component { // Declaring external ports in a Bundle called `io` is recommended val io = new Bundle { val a, b, cin = in Bool() val sum, cout = out Bool() } // Do some logic io.sum := io.a ^ io.b ^ io.cin io.cout := (io.a &amp; io.b) | (io.a &amp; io.cin) | (io.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc79ea121b49ce3351c944f89d4ac30e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e1f0971da4d6ba14a129a0cfd2c120b/" rel="bookmark">
			java.lang.IllegalStateException: 提交响应后无法转发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java.lang.IllegalStateException: 提交响应后无法转发 resp.sendRedirect("/login.jsp");
req.getRequestDispatcher("/login.jsp").forward(req,resp);
后面添加return; 即可解决
在没加return之前，页面在执行完页面跳转的时候回继续执行下面的代码
resp.sendRedirect("/login.jsp"); return; //添加后页面就不会向下执行了 req.getRequestDispatcher("/login.jsp").forward(req,resp); return; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5d7635e89d2f61f8c360fed5b43f535/" rel="bookmark">
			牛客选择题错题本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 return i++ 是先 return i 然后 i++，与 赋值语句是一个道理
2、 一个容器类数据结构，读写平均，使用锁机制保证线程安全。如果要综合提高该数据结构的访问性能，最好的办法是______。
只对写操作加锁，不对读操作加锁 读操作不加锁，采用copyOnWrite的方式实现写操作 分区段加锁 无法做到 答案：C A，只对写操作加锁，不对读操作加锁，会造成读到脏数据 B，CopyOnWrite的核心思想是利用高并发往往是读多写少的特性，对读操作不加锁，对写操作，先复制一份新的集合，在新的集合上面修改，然后将新集合赋值给旧的引用。这里读写平均，不适用 C，分段加锁，只在影响读写的地方加锁，锁可以用读写锁，可以提高效率 3、 抽象类方法的访问权限默认都是public。（ ）
正确答案: B 你的答案: A (错误)
正确 错误 关于抽象类 JDK 1.8以前，抽象类的方法默认访问权限为protected JDK 1.8时，抽象类的方法默认访问权限变为default 关于接口 JDK 1.8以前，接口中的方法必须是public的 JDK 1.8时，接口中的方法可以是public的，也可以是default的 JDK 1.9时，接口中的方法可以是private的 4、 将下列哪个代码（A、B、C、D）放入程序中标注的【代码】处将导致编译错误？
class A{ public float getNum(){ return 3.0f; } } public class B extends A{ 【代码】 } 正确答案: B 你的答案: C (错误)
public float getNum(){return 4.0f} public void getNum(){} public void getNum(double d){} public double getNum(float d){return 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5d7635e89d2f61f8c360fed5b43f535/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6a47d6509249e64547029b901150b12/" rel="bookmark">
			五角星代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84b2b85c037f8ff56f24a11968e57997/" rel="bookmark">
			IDEA对项目进行（package）生成jar包出现程序包不存在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误截图
一般出现这个情况是由于项目中引入了外界jar包，并且不是通过maven进行引入的，所以在使用maven进行打包时会出现，找不到程序包的问题。
所以对于解决这个问题，就是通过maven将该包从本地引入到项目中。
第一步：
打开项目底部Terminal命令行输入如下命令
mvn install:install-file -DgroupId=xxxx -DartifactId=xxxx -Dversion=xxxx -Dpackaging=jar -Dfile=C:\Users\Administrator\Desktop\BOOT-INF\lib\http.jar
-DgroupId 对应为 pom 文件中的 groupId
-DartifactId 对应为 pom 文件中的 artifactId
-Dversion 对应为 pom 文件中的 version
-Dpackaging 导入包的类型是jar包的话就是 jar
-Dfile 你下载下来的jar包放的路径
命令中以上五项更换为引入包的相关信息。
注意：如果mvn 提示 “mvn不是内部或外部命令，也不是可运行程序”
就表明是你的maven未注册到系统配置。简单的方法，将maven文件bin目录注册到系统配置的path下（类似于jdk配置bin目录到path）。
第二步
pom文件引入
将图中groupId，artifactId，version更换为第一步中的DgroupId，DartifactId ，Dversion 。引入完成，再进行package,即可解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1194771d63a24b2c4cd80eb2b9b259d/" rel="bookmark">
			zabbix监控服务器交换机item参数参考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		监控服务器
zabbix监控配置流程：
配置主机组、添加主机、添加监控项、模板、手动添加、添加触发器、定义用户媒介、配置告警方式和动作、手动触发告警
先在configuration中的hostname配置主机组，新建host，添加进hostname，在agent interfaces将IP地址改为监控服务器地址，可以在选择合适的templates，然后update
Item：监控采集的项目，例如agent端的cpu、内存等，但是更加具体的来说，比如说cpu使用率，或者是cpu某个核的使用率或者是cpu的空闲率是这样一个十分具体的项，item是由key+参数组成
服务器监控的常用key：
swap空间 system.swap.size[,free] #可用swap空间
system.swap.size[,pfree] #可用swap空间百分比
system.swap.size[,total] #总swap空间
CPU 类似于对应系统中top命令查看CPU显示值
system.cpu.switches #系统文件切换 （bps）
system.cpu.util[&lt;cpu&gt;,&lt;type&gt;,&lt;mode&gt;] #CPU利用率百分比
#cpu - cpu数量 (默认是所有cpu)
#type - 可用值: idle, nice, user (默认), system (windows系统默认值）, iowait, interrupt, softirq,steal
#mode - 可用值: avg1 (一分钟平均，默认值), avg5(5分钟平均, avg15 (15分钟平均值)
system.cpu.util[,user] #CPU的用户态运行时间，百分比形式
system.cpu.util[,nice] #CPU的nice时间，百分比形式
system.cpu.util[,system]#CPU的系统态运行时间，百分比形式
system.cpu.util[,iowait] #CPU的io等待时间，百分比形式
system.cpu.util[,idle] #CPU的空闲时间，百分比形式
system.cpu.util[,interrupt] #CPU的中断时间，百分比形式
system.cpu.util[,steal] #CPU的偷盗的时间，百分比形式
system.cpu.util[,softirq] #CPU的软中断时间，百分比形式
system.cpu.load[&lt;cpu&gt;,&lt;mode&gt;] #CPU负载浮点数
#cpu - 可用值: all (默认), percpu (所有在线cpu的负载)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1194771d63a24b2c4cd80eb2b9b259d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58d3d97695074cdeaac52093db24341b/" rel="bookmark">
			day2_homework
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 2. 从控制台输入用户的月薪，进行运算计算出年薪。打印输出用户的年薪 【注意】当input读取键盘输入的字符是字符类型，而不是数字类型，因此要先转化为int类型，再进行计算。
yuexin=input("请输入月薪") yuexin1=int(yuexin) nianxin=yuexin1*12 print(nianxin) 3. 使用字符串复制，用计算机打印出“爱你一百遍”，打印100 次 a="爱你一百遍" b=a*100 print(b) 4. 将”sxtsxtsxtsxtsxt”字符串中所有的s 输出 【注意】此处调用的是slice切片操作，但注意并不是.slice[ ]，而是字符串后直接跟[ ]
a="sxtsxtsxtsxtsxt" b=a[::3] print(b) 5. a is b是true，因为a和b都满足字母数字下划线的要求，因此启动字符串驻留机制。
c is d 是false，因为他们的id地址不同，=是用来比较id地址的。
6.写出如下代码打印的结果： c = "名字是{name}，年龄是{age}" c.format(age=19,name='高淇') 结果：‘名字是高淇，年龄是19’
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5896034d1628638f2489f518a30213e8/" rel="bookmark">
			HashMap源码-Put详解（HashMap是如何添加元素的）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HashMap是Java中很重要一个部分，内容较多，因此笔者在此将其拆成一个个小块，作为自己学习知识整理的同时，也和广大网友一起讨论。
也因此，在完成系列的学习之前，将以这种小节的形式进行学习分享，并在学习结束后进行整合，排序。
一、HashMap的实际结构 首先，我们必须了解一下HashMap的实际结构：
（图片来自：'是一篇很好的博客，如有时间，希望大家也能花时间在这篇博客中学习一二）https://blog.csdn.net/weixin_39621427/article/details/112096553 如上图所示，HashMap本质是一个数组，其中数组中的每个元素可以指向一套红黑树/一个链表（一定是两种之一）。
在HashMap初始化中，存在一个参数：
树化阈值（TREEIFY_THRESHOLD）：
当数组的节点数超过树化阈（yu，四声）值后 ，会被转化为红黑树的储存结构，可以加快遍历速度。
在源码中，树化阈值被默认设定为8,如下所示：
pubic static final int TREEIFY_THRESHOLD = 8 二、HashMap元素的添加 序 在正常的使用中，我们会这样进行HashMap的初始化和元素的添加：
Map&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put("a",1); 其中，.put方法就是HashMap中添加元素的方法，那么让我们看看其源码是如何实现的吧。
public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 在源码中，我们很容易发现，put方法的实现都在putVal方法中，因此，我们对put方法的重点就在putVal方法中。
putVal方法 查询源码，我们可以看到putVal的源码如下，乍看起来内容较多，在笔者的学习过程中，网络上大部分的资料均是直接开始介绍整套代码的作用，对于初学者来说，需要认知的事情太多，学习起来困难，复习起来更是无从下手，因此，笔者在这里就以初学者的角度开始，转换一下学习的方法。
首先，大致看上去，putVal中包含多个if-else结构，因此，如果我们能将每个if的条件判断弄清楚，那么整个putVal的运行逻辑就一清二楚啦。
final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5896034d1628638f2489f518a30213e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f91fb3ddfcb644acdf232c23f66ab2f7/" rel="bookmark">
			day2笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链式赋值 同一个对象，赋值给多个变量，对象的地址都是一样的
#系列解包赋值（个数必须一致）
a,b,c=4，5，6
相当于a=4，b=5，c=6 使用系列解包赋值实现变量变换 a，b=1，2
a，b=b，a，实现了a和b的互换（和c语言不一样）
常量 python不支持常量
最基本的内置数据类型介绍 整型：整数浮点型：小数布尔型：表示真假，只有true和false 运算 /：浮点数除法（小数）
//：整数除法：取整数
%：模：取余
：幂运算。23=8
divmod()函数：同时得到商和余数。divmod(13，3)，输出（4，1），返回的是一个元组
使用int（）实现类型转换 浮点数直接舍去小数部分。如：int(9.9)结果是：9。布尔值True 转为1，False 转为0。如：int(True)结果是1。 自动转型 整数和浮点数混合运算时，表达式结果自动转型成浮点数。
注意：Google=10**100.
浮点数（float） 浮点数，称为float。
浮点数用
a*b的10 次方形式的科学计数法表示。比如：3.14，表示成：314E-2 或者314e-2。
这些数字在内存中也是按照科学计数法存储。
类型转换和四舍五入 使用float()将其他类型转化成浮点数。
round(value)可以返回四舍五入的值，不会改变原有值，而是产生新的值。
增强型赋值运算符 +=，-=，等，中间不能加空格
时间的表示 unix时间点：1970年1月1日00：00：00开始计时，以毫秒进行计算。
python中可以通过time.time()，获取当前时刻，带微秒精度的浮点数。
布尔值 python3中，把True 和False 定义成了关键字，但他们的本质还是1 和0，甚至可以和数字相加。
比较运算符 逻辑运算符（重要） or：x or y,x为true，不计算y直接返回true，x为false，返回y。
and：x and y，x为true，返回y的值；x为false，则不计算y，直接返回false
not：not x，x为true，返回false；x为false，返回true。
同一运算符 is，is not 一个对象有什么：id，type，value。同一运算符用于比较两个对象的存储单元，之际上比较的是地址，是不是同一个
【注意】is用于判断两个变量引用的对象，是否是同一个，即比较对象的地址。==用于判断引用变量引用的值是否相等。
重点
a和b的值是相等的，但是a is b返回false，因为这两个对象色的地址是不同的，值相同。
整数缓存问题 Python 仅仅对比较小的整数对象进行缓存（范围为[-5, 256]）缓存起来，而并非是所有整数对象。
需要注意的是，这仅仅是在命令行中执行，而在Pycharm 或者保存为文件执行，结果是不一样的，这是因为解释器做了一部分优化(范围是[-5,任意正整数])，这个时候，上边false就会变成true。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f91fb3ddfcb644acdf232c23f66ab2f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fb399c8b506390a91de07876e40ecd6/" rel="bookmark">
			基于websocket的跨平台通信——iPhone/iPad/Mac控制树莓派（二）：Swift控制端搭建，网络延迟显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于websocket的跨平台通信——iPhone/iPad/Mac控制树莓派（二）：Swift控制端搭建 瞎扯不想看我瞎扯直接跳到这思路/接口说明代码实现创建工程以及导入库创建工程导入库 网络延迟计算数据类定义发送（暂时用不上，因为暂时没有发送功能）接收工厂模型网络延迟工厂 WebSocket 说明 基于websocket的跨平台通信——iPhone/iPad/Mac控制树莓派
瞎扯 为什么你要用苹果平台不搞安卓/Windows呢？
主要是苹果生态比较完善，Swift直接跨所有设备，加上我手上没有安卓设备和Win的PC。（PC装的是Ubuntu）
那你跨平台为什么不写前端或者flutter之类的呢？
不会…
不想看我瞎扯直接跳到这 我们先来实现最基本的，网络延迟检测，也就是检测树莓派等设备的数据发送到控制端的网络延迟。
思路/接口说明 接口说明见：基于websocket的跨平台通信——iPhone/iPad/Mac控制树莓派（一）：后端搭建
由于后端只是单纯的做了一个数据转发的功能，控制端和设备端的代码量就要多许多（工厂模型）；而众所周知客户端的项目代码结构有很多种（我倾向于使用Redux），所以这里我只列出核心逻辑代码，UI实现等就省略了。
当然有一点还是要说明的：我的代码使用SwiftUI以及SwiftUI生命周期。
代码实现 创建工程以及导入库 创建工程 我打算在各种苹果设备上都能运行，所以这里选择Multiplatform App：
这里我倾向于勾上Core Data，虽然现在没用上，但万一以后要用也就省了步事。
（git选不选无所谓）
导入库 由于众所周知的网络原因，我无法使用Cocoapods等包管理工具导入；所以我选择用Xcode自带的导入工具本地导入。
打开gitclone，搜索starscream，这是Swift的一个websocket库；或者直接复制地址下载到本地：
git clone https://gitclone.com/github.com/daltoniam/Starscream
然后选择Xcode的File-&gt;Add Packages…
选择下方的Add Local…
选择克隆下来的Starscream文件夹，点击Add Packages：
然后在Xcode中点开.xcodeproj文件，找到图中的位置，点击左下方的+号：
（稍后iOS下面的macOS也要进行相同的操作）
选择Starscream并点击Add：
就可以测试import starscream看看有没有报错了。
网络延迟计算 树莓派发送一个包含当前时间戳（单位：毫秒）的数据，控制端设备接收后用当前时间戳减去接收到的时间戳，即为网络延迟。
不过为了计算方便以及减少数据量，我们只发送毫秒时间戳的后五位，也就是只考虑百秒内的网络延迟，所以接收到的是一个Int值而不是Int64（Long）。
数据类定义 根据后端的接口定义，可以很快的写出发送和接收的数据类：
发送（暂时用不上，因为暂时没有发送功能） // BaseMsg.swift struct BaseMsg: Codable { var type: Int var toPlatform: [String] var msgType: String var msg: String } 接收 // Receive.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fb399c8b506390a91de07876e40ecd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a6f12db773c88d2f7d408454d0308f2/" rel="bookmark">
			阿里云优化求解器mindopt安装配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人在安装mindopt的过程中，由于官网的教程中有些细节写得不详细，遇到了一些问题，所以对此进行了总结，以下是我的安装配置过程（windows平台下）。
一、下载安装 从 求解器SDK下载和安装 (aliyun.com) 中下载 Windows 64-bit/x86 MindOpt 发行版（win64-x86-0.14.0），双击安装文件，根据指引安装即可。
二、配置环境变量 在Windows系统的安装下会自动添加环境变量，如下图所示，若没有则需自己在环境变量的系统变量中添加一下路径。
三、许可证设置（重点） 1.开通服务 访问控制台开通服务。然后会在已购服务列表中获取到LicenseKey。单击开通服务，然后单击购买，选择您需要的时长和进程数。购买以后还可以续费和变配，如下图所示：
然后在左侧点击已购服务列表，便能看到你的LicenseKey
2.配置阿里云鉴权账号 在您的home目录中创建一个名为 mindopt 的文件夹（注意一定是在home下创建一个新的mindopt文件而不是之前下载下来的mindopt的目录），然后在其中保存您的许可证文件。
例如当前登录用户为Administrator 。则需要在文件路径为C:\Users\Administrator下创建mindopt文件然后再在mindopt文件里创建 fl_client.ini文件，并复制粘贴下文的内容示例并修改。
fl_client.ini文件内容如下：
[server] # license server host name = opt.cn-beijing.aliyuncs.com # 请修改为您购买区域的endpoint # license server port 80 if absent port = 443 # license server is https protocol https = true # client side request timeout in second request_timeout = 2 [security] # key for client authentication aliyun_license_key = 您购买服务的LicenseKey信息，见控制台的已购服务列表（开通服务中描述） aliyun_ak_id= 您配置的AccessKey信息 aliyun_ak_secret= 您配置的AccessKey Secret信息 fl_client.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a6f12db773c88d2f7d408454d0308f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bc30ae5db111a8e77da0aef28e4fec6/" rel="bookmark">
			2.服务器部署web服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.看图说话2.开始部署django3.遇到的坑4.声明 #前几天按照文档走了一道，也记录了一下操作过程，其实挖了很多坑，没走通。又捯饬了几天终于在ubuntu成功运行了django+Nginx，记录如下 1.看图说话 首先使用django web开发框架（因为我不会html，css，js等，所以有个好用的开发框架将会开发简单，部署也简单）django使用python作为开发语言，开发完毕作为web应用程序运行在web服务器上，但是我们选择的web服务器例如Nginx，uWSGI都不认识python，所以web应用程序django要和web服务器进行交互则需要通信标准wsgiuWSGI是一种web服务器，它实现了WSGI协议、uwsgi、http等协议，我们选择uWSGI服务器运行django，他们之间使用wsgi协议通信。同时为了提高网页的响应效率，有人采用网页的动静分析措施，比如利用Nguinx服务器处理/响应静态网页，uWSGI服务器响应动态网页。（我仅仅是听说）为了达到动静分离的效果，我又安装了nginx，nginx与uWSGI两个web服务器协同工作则需要通信，他们的通信可以采用socket实现（这两个运行在服务器上的web服务器其实也就是两个运行程序嘛，他们之间相互调用/通信采用一种方法称为socket）客户端，即用户的浏览器方位服务器端时，通过http协议与nginx通信，nginx处理静态请求/响应,然后动态请求/响应交给uWSGI。uWSGI调用python程序（django）处理请求，返回处理结果。 2.开始部署django step1：
#安装django web开发框架 #安装conda的用户主要python和pip对应起来，文中的python和pip3皆是/usr/bin中的可执行程序 #python和pip对应错误可能出现调用包错误的现象 pip3 install django #验证是否安装成功 django-admin.py startproject mysite #创建项目mysite cd mysite #进入项目文件 /usr/bin/python3 runserver 0.0.0.0:8000 #8000端口运行django的测试文件，浏览器打开返回的地址会出现小火箭 #安装uWSGI web服务器 pip3 install uwsgi #验证uwsgi是否安装成功 vim test.py def application(env, start_response): start_response('200 OK', [('Content-Type','text/html')]) return [b"Hello World"] # python3 #return ["Hello World"] # python2 uwsgi --http :8000 --wsgi-file test.py #8000端口运行test测试文件，浏览器打开返回的地址会出现hello world #安装postgresql数据库的以及数据库操作接口 #安装数据库 sudo apt-get install postgresql postgresql-client #安装完毕后，系统会创建一个数据库超级用户 postgres，密码为空 pip3 install psycopg2-binary #验证psycopg2是否安装成功 /usr/bin/python3 &gt;&gt;&gt;import psycopg2 &gt;&gt;&gt;dir(psycopg2) #安装nginx web服务器 #nginx负责静态web页面处理，uWSGI负责动态页面处理，实现动静分离，提高页面响应效率 sudo apt-get install nginx #安装成功nginx会自动启用 #检查nginx sudo service nginx status #或者访问浏览器出现欢迎界面 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bc30ae5db111a8e77da0aef28e4fec6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb6a1ad01236c760f414b3d4e162a889/" rel="bookmark">
			java获取当前日期的前一天,年，月等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Calendar ca = Calendar.getInstance();//得到一个Calendar的实例 ca.setTime(new Date()); //设置时间为当前时间 ca.add(Calendar.YEAR, -1); //年份减1 Date lastMonth = ca.getTime(); //结果 //求前一月ca.add(Calendar.MONTH, -1)， //前一天ca.add(Calendar.DATE, -1) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5d893a1a06021b8388b37de7ee7c8a2/" rel="bookmark">
			RocketMQ集群启动报错：java.lang.RuntimeException: Lock failed,MQ already started
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动RocketMQ集群后报错：
java.lang.RuntimeException: Lock failed,MQ already started at org.apache.rocketmq.store.DefaultMessageStore.start(DefaultMessageStore.java:214) at org.apache.rocketmq.broker.BrokerController.start(BrokerController.java:827) at org.apache.rocketmq.broker.BrokerStartup.start(BrokerStartup.java:64) at org.apache.rocketmq.broker.BrokerStartup.main(BrokerStartup.java:58) 原因：
学习阶段，我们将Master和Slave共同部署在一台机器上，同时配置的storePath又相同，没有进行区分。
解决：
为从节点创建存储文件
mkdir /usr/local/rocketmq/store-s mkdir /usr/local/rocketmq/store-s/commitlog mkdir /usr/local/rocketmq/store-s/consumequeue mkdir /usr/local/rocketmq/store-s/index store-s与Master节点用的目录store区分开。
对Slave配置文件进行修改：
#===================storePath主从节点必须分开==================== #存储路径 storePathRootDir=/usr/local/rocketmq/store-s #commitLog 存储路径 storePathCommitLog=/usr/local/rocketmq/store-s/commitlog #消费队列存储路径存储路径 storePathConsumeQueue=/usr/local/rocketmq/store-s/consumequeue #消息索引存储路径 storePathIndex=/usr/local/rocketmq/store-s/index #checkpoint 文件存储路径 storeCheckpoint=/usr/local/rocketmq/store-s/checkpoint #abort 文件存储路径 abortFile=/usr/local/rocketmq/store-s/abort #===================storePath主从节点必须分开==================== 以上问题解决。
本文仅供个人学习使用，如有不足或错误欢迎指正！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a37ccadc694a84e6c6f84e90a2b8ec7/" rel="bookmark">
			java学习笔记（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
项目一和数组
一、break和continue的补充
continue语句
return语句
二、练习
（1）题目：输出100以内的质数；
（2）找到1000以内的所有完数；
三、项目一：家庭收支记账软件
四、数组
（1）数组的概述
（2）一维数组
（3）二维数组
五、补充
项目一和数组 一、break和continue的补充 continue语句 &gt;continue只能使用在循环结构中；
&gt;continue语句用于跳过其所在循环语句的一次执行，继续下一次循环；
&gt;continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是那一层循环
continue语句用法举例：
public class ContinueTest{ public static void main(String arg[]){ for(int i=0;i&lt;100;i++){ if(i%10==0) continue; System.out.println(i); } } } return语句 &gt;return语句并非专门用于结束循环的，它的功能是结束一个方法；当一个方法执行到一个return语句时，这个方法将被结束。
&gt;与break和continue语句不同的是，return直接结束整个方法，不管这个return处于多少层循环之内。
二、练习 （1）题目：输出100以内的质数； 普通代码：
public class TestProject { public static void main(String[] args) { Scanner input = new Scanner(System.in); for (int i = 2; i &lt;= 100; i++) { //遍历100以内的自然数 boolean isFlag = true;//标识i是否被j除尽，一旦除尽，修改其值 for (int j = 2; j &lt; i; j++) { if (i % j == 0)//i被j除尽 isFlag = false; } if (isFlag == true)//判断标识 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a37ccadc694a84e6c6f84e90a2b8ec7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91efeec6cc6d24f55f31b0328c45ec8e/" rel="bookmark">
			Error creating bean with name ‘org.springframework.security.oauth2.config.annotation.web.configurati
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现以下错误主要原因是加入了资源服务器的配置却没有标识该服务为资源服务器。
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfiguration': Post-processing of merged bean definition failed; nested exception is java.lang.TypeNotPresentException: Type javax.servlet.Filter not present at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:579) ~[spring-beans-5.3.5.jar:5.3.5] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524) ~[spring-beans-5.3.5.jar:5.3.5] at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.5.jar:5.3.5] at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.5.jar:5.3.5] at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.5.jar:5.3.5] at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.5.jar:5.3.5] at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:944) ~[spring-beans-5.3.5.jar:5.3.5] at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:918) ~[spring-context-5.3.5.jar:5.3.5] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) ~[spring-context-5.3.5.jar:5.3.5] at org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext.refresh(ReactiveWebServerApplicationContext.java:63) ~[spring-boot-2.4.4.jar:2.4.4] at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:769) [spring-boot-2.4.4.jar:2.4.4] at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:761) [spring-boot-2.4.4.jar:2.4.4] at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:426) [spring-boot-2.4.4.jar:2.4.4] at org.springframework.boot.SpringApplication.run(SpringApplication.java:326) [spring-boot-2.4.4.jar:2.4.4] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1313) [spring-boot-2.4.4.jar:2.4.4] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1302) [spring-boot-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91efeec6cc6d24f55f31b0328c45ec8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2992cee517eb4a4295819dbb550cf4e/" rel="bookmark">
			AlphaFold2代码阅读（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021SC@SDUSC
前言 看了Evoformer的代码，一如既往地晦涩难懂，所以在看代码的同时阅读了论文，果然感觉好了很多。
一、class EvoformerIteration 1.代码 class EvoformerIteration(hk.Module): def __init__(self, config, global_config, is_extra_msa, name='evoformer_iteration'): super().__init__(name=name) self.config = config self.global_config = global_config self.is_extra_msa = is_extra_msa def __call__(self, activations, masks, is_training=True, safe_key=None): c = self.config gc = self.global_config msa_act, pair_act = activations['msa'], activations['pair'] if safe_key is None: safe_key = prng.SafeKey(hk.next_rng_key()) msa_mask, pair_mask = masks['msa'], masks['pair'] dropout_wrapper_fn = functools.partial( dropout_wrapper, is_training=is_training, global_config=gc) safe_key, *sub_keys = safe_key.split(10) sub_keys = iter(sub_keys) msa_act = dropout_wrapper_fn( MSARowAttentionWithPairBias( c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2992cee517eb4a4295819dbb550cf4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecb6403e0a3e86f72303479bec07c7bf/" rel="bookmark">
			极化SAR影像分类降维方探讨
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地物分类即对遥感影像中的每个像素点进行分类并形成现实的地物目标，一直是极化SAR影像解译中的重要的一环。随着遥感影像数据的迅速增多和分辨率的逐步提高，利用遥感影像技术进行地物分类在城市规划、环境保护、资源管理、测绘等领域中发挥着越来越重要的作用。而分类的效果好坏依赖于所使用的极化特征能否充分表述地物的极化散射特性。
为了有效的从极化SAR影像中提取目标的极化散射特征信息，除了极化数据本身的表征(散射矩阵、Stokes矩阵等)外，还需要通过变换和分解等方式获取更多有利于描述目标本身特性的极化表征，并将提取出极化特征用作极化SAR影像的解译和处理应用。
降维可通过特征选择和特征提取两种方式实现。其中特征选择是指根据某个评价指标从原始特征集种挑选出一个真子集，该过程得到的是新的特征组合而并未产生新的特征，因此对地物的表述能力难以大幅度提高。而特征提取则是指通过线性或者非线性变换将特征从高维空间映射到低维空间，该过程可得到新的特征，能更好的挖掘地物目标的极化散射特性，因此对特征的提取和研究将具有重大价值。
降维过程种不可避免的需要考虑标记样本的使用情况。正确和充足的标记样本需要专业人员手动标注，因而获取耗时、代价昂贵。
极化SAR影像分类是指根据地物目标所对应的像元的差异性将像元划分为不同的类别。而分类的结果既可以提供给测绘人员用于专业制图，又可以作为水体和道路提取、目标检测和识别等应用的中间结果。极化SAR影像分类是遥感应用中重要的研究内容和关键环节，在土地利用、行政规划、水土资源管理、灾害监测与评估、军事目标发现、农作物类型与农作物估产、军事目标发现等方面具有巨大的应用潜力。
极化SAR影像分类的流程一般为:
极化SAR的预处理操作主要是多视处理和抑制相干斑噪声。原始的极化SAR数据的格式通常为单视复数据，多视处理之后就可以通过二阶统计量完全描述全部的极化信息。抑制相干斑噪声主要通过滤波算法来实现。
特征降维在一定程度上能够提升地物目标的判别能力和分类性能。根据特征属性可以将常用的特征划分为：灰度特征、纹理特征、极化特征、空间信息特征/上下文特征等。不同特征对地物目标的辨识能力不同，多特征的随意组合存在信息冗余、维度灾难等问题。此时需要引入降维来获得判别能力强的特征子集或反映目标本质的本征特征。
分类的目的是为了每个像元指定类别标签，其本质可以看作模式识别问题。机器学习中有大量算法在极化SAR影像分类任务中都取得了成功的应用，比如，贝叶斯、K近邻、支持向量机、基于树的分类器、神经网络等。这些算法在极化SAR影像分类应用中都取得了较好的场景分类效果。
传统的基于像素的算法，其结果往往受到噪声的影响，使得具有相似特性的邻域像素其分类结果却不相同。因此可以考虑使用空间约束对结果进行平滑处理以获取更好的效果。比如可以使用马尔可夫随机场模型。
总的来说，极化SAR影像分类的一般流程可归结为“特征表示+分类方法”。
SAR作为一种主动式传感器，能够不受自然条件的制约，随时随地获取数据。SAR传感器所获得的是地物目标对电磁波的散射回波，而不是直接的遥感影像，且通过一定的成像方式对回波进行成像才得到SAR影像。因此要理解SAR影像，首先要先明白SAR的数据表征。
极化SAR通过发射和接收不同极化组合的电磁波的方式来获得后向散射矩阵S，在此期间，入射波的一部分能量会被地面的目标所吸收，一部分能量则会再一次辐射形成电磁波，即入射波和反射波的性质会发生变化。而后向散射矩阵S描述的就是这种发射与接收电磁波之间的转换关系，从而更好地体现极化信息的变化情况，更好地表征和识别地物目标。
在实际的极化SAR应用中，像素的尺寸是大于波长的，即单一像素所记录的信息中包含多个具有一定空间分布的小散射中心，而每个小散射中心都可以用一个散射矩阵来表述，因此一个分辨单元内的散射矩阵丈量值是由该分辨单元内所有散射中心的散射中心的散射矩阵相干叠加而成。引入极化协方差矩阵C和相干矩阵T来更好地应对统计散射效应并准确分析局部散射体。
除了极化数据本身的表征，如散射矩阵S、Stokes矩阵等，我们还需要使用数据变换和分解来获取更多的极化特征，这有利于反映目标本身的性质。而对极化数据所采取的处理方式的差别，则提取出来的极化特征也随之复杂多样。极化特征一般分为，通过极化数据变换得到的极化特征和通过极化分解得到的特征两种类型。其中，通过各通道的幅度、强度、相位以及它们之间的差值比例关系对极化SAR影像中的目标进行表述的特征称为极化数据变换特征，它们具有较为全面的统计特性；而对于原始极化矩阵进行分解得到的特征称为极化分解特征，它则能够更为清楚地描述不同目标的物理散射机制。
注：以上内容选自《面向极化SAR影像分类的降维方法研究》 武汉大学 硕士毕业论文 谢欣芳
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aec86c01340926579b298cf680fda771/" rel="bookmark">
			计算机网络网络层协议之RIP协议、OSPF协议和BGP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、RIP协议 RIP路由信息协议（Routinginformation protocol）是根据距离-向量原理设计的内部网络协议。RIP通过距离向量算法来完成路由表的更新。每个路由表项目都有三个关键数据：＜目的网络N , 距离d,下一跳路由器X&gt;。其要点如下：
1、每个路由器维护自己到其它每一个目的网络的距离（跳数）记录
2. 以距离最短（跳数最小）为评价，不是时间最短
3. 跳数范围1~15，16就认为不可达（由于距离向量具有可能出现环路，16的限制防止数据报不断在网络上循环，减少网络拥塞的可能性，因此也限制了网络的规模）
4. 默认每30秒广播一次RIP 路由更新协议，以动态维护路由表。
5. 不支持子网掩码的RIP 广播，即RIP 中每个网络的子网掩码必须相同
二、OSPF协议 OSPF协议是基于链路状态设计的内部网络协议，该协议有以下特点：
1、OSPF对不同的链路可根据IP 分组的不同服务类型(TOS) 而设置成不同的代价。因此，OSPF对于不同类型的业务可计算出不同的路由， 十分灵活。
2、如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这称为多路径间的负载平衡。
3、 所有在OSPF 路由器之间交换的分组都具有鉴别功能， 因而保证了仅在可信赖的路由器之间交换链路状态信息。
4、支持可变长度的子网划分和无分类编址CIDR 。
5、 每个链路状态都带上一个32位的序号， 序号越大， 状态就越新。
三、BGP协议 BGP边界网关协议是基于路径-向量的外部网络协议。边界网关协议(Border Gateway Protocol, BGP)是不同自治系统的路由器之间交换路由信息的协议，是一种外部网关协议。边界网关协议常用于互联网的网关之间。路由表包含已知路由器的列表、路由器能够达到的地址及到达每个路由器的路径的跳数。
四、三种协议的比较 协议RIPOSPFBGP类型内部内部外部路由算法距离向量链路状态路径－向量传递协议UDPIPTCP路径选择跳数最少代价最低较好， 非最佳交换结点和本结点相邻的路由器网络中的所有路由器和本结点相邻的路由器 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de43ad2ad1dd1ced28d8bb94832e85d/" rel="bookmark">
			五、helm部署 prometheus-operator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、了解Prometheus概念二、认识Prometheus Operator1、安装Prometheus软件1.1、利用helm3进行安装1.2、发布prometheus和Grafana的svc1.3、卸载方法 2、模拟业务监控2.1、模拟发布业务pod2.2、添加servicemonitors采集监控指标2.3、可以通过prometheus查看 3、配置告警3.1、告警模板文件 template.tmpl3.2、config.yaml3.3、创建webhook挂载configmap3.4、配置alertmanager.yaml使用webhook3.5、创建告警3.5、group_wait和repeat_interval讲解3.6、其他相关告警配置参数含义3.7、告警状态含义 4、告警模板讲解4.1、if/else语句4.2、Range语法4.3、比较语法4.4、逻辑运算4.5、内置函数4.6、移除空格4.7、模板数据结构介绍 Prometheus是一个用于监控和告警的开源系统。一开始由Soundcloud开发，后来在2016年，它迁移到CNCF并且称为Kubernetes之后最流行的项目之一。从整个Linux服务器到stand-alone web服务器、数据库服务或一个单独的进程，它都能监控。在Prometheus术语中，它所监控的事物称为目标（Target）。每个目标单元被称为指标（metric）。它以设置好的时间间隔通过http抓取目标，以收集指标并将数据放置在其时序数据库（Time Series Database）中。可以使用PromQL查询语言查询相关target的指标。 一、了解Prometheus概念 组成Prometheus生态的组件：
1、 了解prometheus相关术语：
Prometheus Server：在时序数据库中抓取和存储指标的主要组件
抓取：一种拉取方法以获取指标。它通常以10-60秒的时间间隔抓取。
Target：检索数据的server客户端
服务发现：启用Prometheus，使其能够识别它需要监控的应用程序并在动态环境中拉取指标
Alert Manager：负责处理警报的组件（包括silencing、inhibition、聚合告警信息，并通过邮件、PagerDuty、Slack等方式发送告警通知）。
数据可视化：抓取的数据存储在本地存储中，并使用PromQL直接查询，或通过Grafana dashboard查看。
二、认识Prometheus Operator 根据Prometheus Operator的项目所有者CoreOS称，Prometheus Operator可以配置原生Kubernetes并且可以管理和操作Prometheus和Alertmanager集群。
该Operator引入了以下Kubernetes自定义资源定义（CRDs）：Prometheus、ServiceMonitor、PrometheusRule和Alertmanager。如果你想了解更多内容可以访问链接
1、安装： stable/prometheus-operator Helm chart来安装Prometheus Operator
下载链接：https://github.com/helm/charts/tree/master/stable/prometheus-operator
默认安装程序将会部署以下组件：prometheus-operator、prometheus、alertmanager、node-exporter、kube-state-metrics以及grafana。默认状态下，Prometheus将会抓取Kubernetes的主要组件：kube-apiserver、kube-controller-manager以及etcd。 1、安装Prometheus软件 1.1、利用helm3进行安装 查看helm是否安装，这里使用的是helm3（helm2与helm3有很大区别，需要注意） ~]# helm version version.BuildInfo{Version:"v3.0.0", GitCommit:"e29ce2a54e96cd02ccfce88bee4f58bb6e2a28b6", GitTreeState:"clean", GoVersion:"go1.13.4"} 添加helm仓库 helm repo add stable http://mirror.azure.cn/kubernetes/charts helm repo add prometheus-community https://prometheus-community.github.io/helm-charts helm repo update helm search repo prometheus-community 部署prometheus 如果想要提前自定义配置，可以把chart包下载下来
# helm pull prometheus-community/prometheus-operator（可选）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6de43ad2ad1dd1ced28d8bb94832e85d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/277/">«</a>
	<span class="pagination__item pagination__item--current">278/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/279/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>