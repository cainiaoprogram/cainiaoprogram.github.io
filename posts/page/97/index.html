<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cafb4c2f5c97509ca0ea97259bc793cf/" rel="bookmark">
			css实现右下角√对号选中样式——基础积累
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		css实现右下角√对号选中样式 场景`css`代码如下 CSS选中右下角对勾是一种很有用的技巧，能够让网页更加美观和易于阅读。下面我们来介绍一下如何实现该功能。
首先，我们需要给要选中的对勾设置一个class，这里我们使用.checkmark。然后，我们将其定位到右下角，使用了position:absolute和bottom:0、right:0。接着，我们设置了背景色、文字颜色、高度、宽度、对齐方式、行高、字体大小、圆角等样式。最后，我们使用transform:rotate(45deg)将其旋转45度，得到了对勾的形状。
使用以上CSS代码，就可以实现右下角对勾的样式。当然，我们还可以根据实际需求进行调整，比如调整颜色、大小等等。
场景 最近在写vue后台样式，有个需求就是一个列表，有选中样式。效果图如下：
这个样式可以通过css直接实现：通过伪元素来实现。
css代码如下 .activeCls { position: absolute; right: 0; bottom: 0; &amp;:before { content: ""; position: absolute; right: 0; bottom: 0; border: 12px solid #f90; border-top-color: transparent; border-left-color: transparent; } &amp;:after { content: ""; width: 5px; height: 10px; position: absolute; right: 4px; bottom: 5px; border: 1px solid #fff; border-top-color: transparent; border-left-color: transparent; transform: rotate(45deg); } } 完成！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdce6438229c0a463afb58c4f1ba20a8/" rel="bookmark">
			Rn实现省市区三级联动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		省市区三级联动选择是个很频繁的需求，但是查看了市面上很多插件不是太老不维护就是不满足需求，就试着实现一个
这个功能无任何依赖插件
pca-code.json树型数据来源 Administrative-divisions-of-China
下面只贴了省市区选择的功能，全部代码可参考github area分支
import { useState, useEffect } from 'react' import { View, StyleSheet, FlatList, Text, TouchableOpacity } from 'react-native' import pcaCode from "../assets/pca-code.json" export default (props) =&gt; { const { value } = props const [selected, setSelected] = useState([]) //选择过的省市区 const [options, setOptions] = useState([pcaCode]) //每一级的数据 const [level, setLevel] = useState(0) // 当前展示第几级 useEffect(() =&gt; { if (!value) return let trees = findNodeByCode(pcaCode, value) || [] const select = trees.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdce6438229c0a463afb58c4f1ba20a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57ac56ca3a55b2e67a894fd5f288760f/" rel="bookmark">
			求相同后缀起始位置：2012年408算法题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法思想 分别求出两个链表的长度len1和len2将两个链表以表尾对齐：令指针 p、q 分别指向 str1 和 str2 的头结点，根据len1和len2的长度大小，使指针 p 和 q 所指的结点到表尾的长度相等反复将指针 p 和 q 同步向后移动，并判断它们是否指向同一结点。若 p 和 q 指向同一结点，则该点即为所求的共同后缀的起始位置 算法实现 int LengthOfList(Node* L) { int len = 0; while (L-&gt;next != NULL) { L = L-&gt;next; len++; } return len; } Node* findCommonSuffix(Node* L1, Node* L2) { int len1 = LengthOfList(L1); int len2 = LengthOfList(L2); Node* p, * q; for (p = L1;len1 &gt; len2 ; len1--) { p = p-&gt;next; } for (q = L2; len1 &lt; len2; len2--) { q = q-&gt;next; } while(p!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57ac56ca3a55b2e67a894fd5f288760f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b775bf489dd9299d60227dca1fd5f2f9/" rel="bookmark">
			【C&#43;&#43;】原子类型非线程安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原子类型非线程安全 #include &lt;iostream&gt; #include &lt;thread&gt; int main() { int num = 0; int count = 100000; std::thread thread1([&amp;](){ for(int i = 0; i &lt; count; i++){ num++; } }); std::thread thread2([&amp;](){ for(int i = 0; i &lt; count; i++){ num++; } }); std::thread thread3([&amp;](){ for(int i = 0; i &lt; count; i++){ num++; } }); std::thread thread4([&amp;](){ for(int i = 0; i &lt; count; i++){ num++; } }); thread1.join(); thread2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b775bf489dd9299d60227dca1fd5f2f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/070871ce43a06ef5b1ddfb19bc9dc957/" rel="bookmark">
			IDEA2022社区版搭建web项目，并用maven打包成war包，部署到tomcat9中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.IDEA社区版搭建web项目 问题：
IDEA社区版没有创建Web工程的选项IDEA社区版没有将Web工程打包成war包的选项 1.1 创建普通的java项目，此处不再赘述 1.2 构建web项目的目录结构 1.3 设置编译目录 1.4 在WEN-INF文件夹下新建web.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;display-name&gt;SimpleWebApp&lt;/display-name&gt; &lt;!-- display-name作用是在登录到tomcat管理页面可以看到显示名字 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bes.test.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 此时 http://xmlns.jcp.org/xml/ns/javaee 和 http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd 会报红，原因是没有web.xml的约束文件。tomcat的lib中的servlet-api.jar包含所需的约束文件，因此可以手动导入该jar包，也可以通过pom.xml坐标导入该jar包（我建议通过坐标导入，因为后续通过Maven编译项目时，还是需要在pom.xml文件中导入坐标）。
1.4.1 手动导入servlet-api.jar（方法一） 1.4.2 导入pom.xml文件 1.4.2.1 添加pom.xml文件 web项目添加pom.xml，转变为Maven项目
方式一：手动创建pom.xml文件，然后右键 Add as Maven Project 方式二：点击我的项目， 右键找到Add Framework Support（此方式我行不通）
弹出以下页面，若没有maven，一直下拉，若还没有，检查你的项目中是否已有pom.xml文件，勾选Maven，点击Ok
pom.xml成功创建(已转变成maven项目)，可以添加你的依赖了 1.4.2.2 导入servlet-api.jar坐标（方法二） &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/070871ce43a06ef5b1ddfb19bc9dc957/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f76cbe5b50f5be0e05d77ba7d0460ab8/" rel="bookmark">
			双指针法：2009年408算法题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 算法思想 定义快慢指针fast和slow，先让fast移动到第k个结点，然后再让slow指针与fast指针同时移动，当fast指针移动到表尾时，slow指针就正好指向倒数第k个结点
算法详细实现步骤 定义快慢指针fast，slow让fast指针先移动到第k个结点若此时fast指向NULL，则倒数第k个结点不存在，若不为空，则让slow和fast指针开始同时移动当fast移动到指向NULL时，slow指向倒数第k的结点 int find_Kth_LastEle(Node* L,int k) { Node* fast = L; Node* slow = L; while (k != 0&amp;&amp;fast!=NULL) { fast = fast-&gt;next; k--; } if (fast == NULL) { return 0; } while (fast != NULL) { slow = slow-&gt;next; fast = fast-&gt;next; } cout &lt;&lt; slow-&gt;data; return 1; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4efe38c130d8bdf4cc38e4eaf75558c1/" rel="bookmark">
			Vue3数值动画（NumberAnimation）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果如下图：在线预览 APIs 参数说明类型默认值必传from数值动画起始数值number0falseto数值目标值number1000falseduration数值动画持续时间，单位msnumber3000falseautoplay是否自动开始动画booleantruefalseprecision精度，保留小数点后几位number0falseprefix前缀string‘’falsesuffix后缀string‘’falseseparator千分位分隔符string‘,’falsedecimal小数点字符string‘.’falsevalueStyle数值文本样式CSSProperties{}falsetransition动画过渡效果TransitionFuncTransitionFunc[‘easeInOutCubic’]false Methods 事件名称说明参数play播放动画() =&gt; void Events 事件名称说明参数started动画开始播放() =&gt; voidfinished动画播放完成() =&gt; void 创建数值动画组件NumberAnimation.vue &lt;script setup lang="ts"&gt; import { ref, computed, watchEffect, onMounted, watch } from 'vue' import type { CSSProperties } from 'vue' import { useTransition, TransitionPresets } from '@vueuse/core' enum TransitionFunc { linear = 'linear', easeOutSine = 'easeOutSine', easeInOutSine = 'easeInOutSine', easeInQuad = 'easeInQuad', easeOutQuad = 'easeOutQuad', easeInOutQuad = 'easeInOutQuad', easeInCubic = 'easeInCubic', easeOutCubic = 'easeOutCubic', easeInOutCubic = 'easeInOutCubic', easeInQuart = 'easeInQuart', easeOutQuart = 'easeOutQuart', easeInOutQuart = 'easeInOutQuart', easeInQuint = 'easeInQuint', easeOutQuint = 'easeOutQuint', easeInOutQuint = 'easeInOutQuint', easeInExpo = 'easeInExpo', easeOutExpo = 'easeOutExpo', easeInOutExpo = 'easeInOutExpo', easeInCirc = 'easeInCirc', easeOutCirc = 'easeOutCirc', easeInOutCirc = 'easeInOutCirc', easeInBack = 'easeInBack', easeOutBack = 'easeOutBack', easeInOutBack = 'easeInOutBack' } interface Props { from?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4efe38c130d8bdf4cc38e4eaf75558c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44e67845df54f854ceb1b28f8ed83453/" rel="bookmark">
			（四）mmdetection源码解读：MMCV 核心组件 Registry
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、四大注册器类DATASETS、PIPELINES、MODELS、HOOKS二、四大注册器类实例化过程 一、四大注册器类DATASETS、PIPELINES、MODELS、HOOKS Registry 用于提供全局类注册器功能，Registry 类内部其实维护的是一个全局 key-value 对。通过 Registry 类，用户可以通过字符串方式实例化任何想要的模块。
#先构建全局的 DATASETS 注册器类 ##只是设置了self._name = 'dataset'，self.build_func = build_from_cfg DATASETS = Registry('dataset') #通过装饰器方式作用在想要加入注册器的具体类中 @DATASETS.register_module() class KittiTinyDataset(CustomDataset): ##只是设置了self._name = 'pipeline'，self.build_func = build_from_cfg PIPELINES = Registry('pipeline') #mmdet/models/builder.py MODELS = Registry('models', parent=MMCV_MODELS) #mmcv/runner/hooks/hook.py HOOKS = Registry('hook') 二、四大注册器类实例化过程 通过register_module装饰器， 把key-value添加到字典中self._module_dict[name] = module_class
def register_module(self, name=None, force=False, module=None): '省略。。。' #register_module是用作一种方法 # use it as a normal method: x.register_module(module=SomeClass) if module is not None: self._register_module( module_class=module, module_name=name, force=force) return module #register_module是用作一个装饰器 # use it as a decorator: @x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44e67845df54f854ceb1b28f8ed83453/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83e94aba33037d78c000c1e631fc37d5/" rel="bookmark">
			mysql表操作-约束删除、用户填加、授权和撤权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、表的约束删除
1.查看所有表的约束条件
2.删除主键
3.删除唯一键
4.删除check键值
5.删除check键值
6.删除not null键值并删除check键值
7.删除键外值
8.检查表的约束条件是否存在
二、设置数据库密码策略
1.查看数据库密码的策略
2.修改数据库密码的长度
3.修改数据库密码的安全等级
三、增加用户
1.创建用户testuser1和testuser2密码为123456
2.查看用户是否创建成功
3.登陆到testuser1看是都能登陆
四、用户权限的授权与撤销
1.查看testuser1当前的权限
2.给testuser1赋予增删改查的权限
3.再次查看testuser1的权限
4.登陆用户名为testuser1的数据库，进行检验是否成功，我们发现可以进行增删改查
5.移除用户testuser1的表中的增删改查，并且查询他的权限
6.登陆用户testuser1的数据库,我们虽然可以查看数据库但是不能对表进行增删改查的操作
一、表的约束删除 1.查看所有表的约束条件 show create table student3\G
2.删除主键 alter table students3 drop primary key;
3.删除唯一键 alter table student3 drop index student3_un_1;
4.删除check键值 alter table students drop check student3_chk_1;
5.删除check键值 alter table student3 drop check student3_chk_2;
6.删除not null键值并删除check键值 alter table students modify stu_gender char(1);
alter table students drop check student3_chk_2;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83e94aba33037d78c000c1e631fc37d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efa040089f8000d71134651f1fd4505f/" rel="bookmark">
			【爬虫】7.4. 字体反爬案例分析与爬取实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字体反爬案例分析与爬取实战 文章目录 字体反爬案例分析与爬取实战1. 案例介绍2. 案例分析3. 爬取 本节来分析一个反爬案例，该案例将真实的数据隐藏到字体文件里，即使我们获取了页面源代码，也无法直接提取数据的真实值。
1. 案例介绍 案例网站为https://antispider4.scrape.center/，第一眼看这个网站没有啥特别的，那么我们先用selenium爬取一些信息，例如电影标题、类别、评分等，代码实现如下：
from selenium import webdriver from pyquery import PyQuery as pq from selenium.webdriver.common.by import By from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.support.wait import WebDriverWait browser = webdriver.Chrome() browser.get('https://antispider4.scrape.center/') WebDriverWait(browser, 10) \ .until(EC.presence_of_all_elements_located((By.CSS_SELECTOR, '.item'))) html = browser.page_source doc = pq(html) items = doc('.item') for item in items.items(): name = item('.name').text() categories = [o.text() for o in item('.categories button').items()] score = item('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efa040089f8000d71134651f1fd4505f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bb8277ca39bc52dc53e1d078d5773bb/" rel="bookmark">
			DDIA读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、可靠性、可扩展性、可维护性可靠性定义硬件故障软件错误人为错误 可扩展性定义描述负载描述性能应对负载的方法 可维护性可运维性：人生苦短，关爱运维简单性：管理复杂度可演化性：拥抱变化 二、数据模型与查询语言关系模型与文档模型NoSQL的诞生对象关系不匹配多对一和多对多的关系文档数据库是否在重蹈覆辙？网络模型关系模型与文档数据库相比 关系型数据库与文档数据库在今日的对比哪个数据模型更方便写代码？文档模型中的架构灵活性查询的数据局部性文档和关系数据库的融合 数据查询语言Web上的声明式查询MapReduce查询 图数据模型属性图Cypher查询语言SQL中的图查询三元组存储和SPARQL语义网络 SPARQL查询语言基础：Datalog 本章小结 三、存储与检索驱动数据库的数据结构索引哈希索引SSTables和LSM树构建和维护SSTables用SSTables制作LSM树性能优化 B树让B树更可靠B树优化 比较B树和LSM树LSM树的优点LSM树的缺点 其他索引结构将值存储在索引中多列索引全文搜索和模糊索引在内存中存储一切 事务处理还是分析？数据仓库OLTP数据库和数据仓库之间的分歧 星型和雪花型：分析的模式 列存储列压缩内存带宽和向量处理 列存储中的排序顺序几个不同的排序顺序 写入列存储聚合：数据立方体和物化视图 本章小结 四、数据编码与演化编码数据的格式语言特定的格式JSON，XML和二进制变体二进制编码 Thrift与Protocol Buffers字段标签和模式演变数据类型和模式演变 AvroWriter模式与Reader模式模式演变规则但Writer模式到底是什么？动态生成的模式代码生成和动态类型的语言 模式的优点 数据流的类型数据库中的数据流在不同的时间写入不同的值归档存储 服务中的数据流：REST与RPCWeb服务远程过程调用（RPC）的问题RPC的当前方向数据编码与RPC的演化 消息传递中的数据流消息代理分布式的Actor框架 本章小结 五、数据复制主节点与从节点同步复制与异步复制设置新从库处理节点宕机从库失效：追赶恢复主库失效：故障切换 复制日志的实现基于语句的复制传输预写式日志（WAL）逻辑日志复制（基于行）基于触发器的复制 复制延迟问题读己之写单调读一致前缀读复制延迟的解决方案 多主复制多主复制的应用场景运维多个数据中心需要离线操作的客户端协同编辑 处理写入冲突同步与异步冲突检测避免冲突收敛至一致的状态自定义冲突解决逻辑自动冲突解决什么是冲突？ 多主复制拓扑 无主复制当节点故障时写入数据库读修复和反熵读写的法定人数 法定人数一致性的局限性监控陈旧度 宽松的法定人数与提示移交运维多个数据中心 检测并发写入最后写入胜利（丢弃并发写入）“此前发生”的关系和并发捕获"此前发生"关系合并同时写入的值版本向量 本章小结 六、分区分区与复制键值数据的分区根据键的范围分区根据键的散列分区负载偏斜与热点消除 分区与次级索引基于文档的二级索引进行分区基于关键词的二级索引进行分区 分区再平衡再平衡策略反面教材：hash mod N固定数量的分区动态分区按节点比例分区 运维：手动还是自动再平衡 请求路由执行并行查询 本章小结 七、事务事务的棘手概念ACID的含义原子性一致性隔离性持久性 单对象和多对象操作单对象写入多对象事务的必要性处理错误和中止 弱隔离级别读已提交没有脏读没有脏写实现读已提交 快照隔离和可重复读实现快照隔离观察一致性快照的可见性规则索引和快照隔离可重复读与命名混淆 防止丢失更新原子写显式锁定自动检测丢失的更新比较并设置（CAS）冲突解决和复制 写倾斜与幻读写倾斜的特征写偏差的更多例子导致写倾斜的幻读物化冲突 可串行化真的串行执行在存储过程中封装事务存储过程的优点和缺点分区串行执行小结 两阶段锁定实现两阶段锁两阶段锁定的性能谓词锁索引区间锁 可串行化快照隔离悲观与乐观的并发控制基于过时前提的决策检测旧MVCC读取检测影响之前读取的写入可串行化快照隔离的性能 本章小结 八、分布式系统的挑战故障与部分失效云计算与超级计算机 不可靠的网络真实世界的网络故障检测故障超时与无穷的延迟网络拥塞和排队 同步网络与异步网络网络延迟可以预测吗？ 不可靠的时钟单调钟与日历时钟日历时钟单调钟 时钟同步与准确性依赖同步时钟有序事件的时间戳时钟读数存在置信区间全局快照的同步时钟 进程暂停响应时间保证限制垃圾收集的影响 知识、真相与谎言真相由多数所定义主节点和锁防护令牌 拜占庭故障弱谎言形式 系统模型与现实算法的正确性安全性和活性将系统模型映射到现实世界 本章小结 九、一致性与共识一致性保证线性一致性如何使得系统线性一致？线性一致性与可串行化依赖线性一致性的场景锁定和主节点选举约束和唯一性保证跨信道的时序依赖 实现线性一致的系统线性一致性和法定人数 线性一致性的代价CAP定理线性一致性和网络延迟 顺序保证顺序与因果关系因果顺序不是全序的线性一致性强于因果一致性捕获因果关系 序列号顺序非因果序列号生成器兰伯特时间戳光有时间戳排序还不够 全序广播使用全序广播使用全序广播实现线性一致的存储使用线性一致性存储实现全序广播 分布式事务与共识原子提交与两阶段提交从单节点到分布式原子提交两阶段提交简介系统承诺协调者失效三阶段提交 实践中的分布式事务恰好一次的消息处理XA事务怀疑时持有锁从协调者故障中恢复分布式事务的限制 容错共识共识算法和全序广播单主节点者复制与共识纪元编号和法定人数共识的局限性 成员与协调服务将工作分配给节点服务发现成员资格服务 本章小结 十、批处理十一、流处理十二、数据系统的未来 一、可靠性、可扩展性、可维护性 单个数据工具已经不能满足应用系统的需求，工作被拆分成一系列能被单个工具高效完成的任务。这些子系统（数据库，缓存，mq等）及其组合统称为数据系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bb8277ca39bc52dc53e1d078d5773bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa59d77e6d645c25717f462f23f6f982/" rel="bookmark">
			一张图看懂家庭网络的组网方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一张图看懂家庭网络 画给家里小朋友看的……画完觉得还不错。
另外，介绍一款在线画图工具，非常好用，网址是：
https://excalidraw.com/
最后，简单介绍一下家庭宽带的一些情况：
国内三大电信运营商，分别是电信、移动和联通，要上网基本上都需要通过这几家公司，也有一些地方可能有其他的网络运营商，但这三家的全国各处都有的。想要高质量的网络，就得多花钱，普通家庭网络与专线网络是不一样的，价格差距非常大，数据传输效率也有差别。
家庭网络上行带宽和下行带宽不一样，上行小，下行大，比如家庭一般100M的带宽，其实主要说的就行下行数据传输的速率，但是上行就没这么多了，最多有十分之一。
专线网络上下行速率相差不大，同样的100M的专线，差不多可以做到上下并行50M的程度。
好像一种被叫做非对称网络传输，一种叫对称网络传输。
当然如果不需要提供网络服务，其实正常时候都是下行大于上行的。不管什么样的传输方式，网络带宽都是有瓶颈的，说这个主要是觉得一般是没必要花冤枉钱去买太贵的网络设备的，百把块的千兆路由只要质量过关，家庭上网搓搓有余了。有线网络从稳定性、速率和安全性来讲，都比无线wifi要好得多。现在常见的光纤入户，其实仅仅是网络传输的介质使用了光纤，其实网络传输的技术没太大的变化，而且像GPON其实是共享带宽的方式提供到家庭的，所以你会发现家里的网速有时候快，有时候慢，原因就是共享带宽用的人多被分到的带宽就少，用的人少被分到的带宽就多，所以有些地方拉了光纤其实网速还没以前的网线好。
以往用过的同轴电缆、双绞线等介质其实它们能达到的传输极限速率还是很高的，现在不用了，不是因为提供不了足够的带宽，而是因为成本变高了。玻璃纤维和铜谁的价格更高？WIFI里的2.4G和5G只的是无线传输信号的频率，没有谁更好的区别，所谓的穿透率和传输范围其实就是长短波的区别。WIFI5、WIFI6、WIFI7对一般人其实也没什么区别，包包里的米有限，很难用到极限带宽。 以上只是闲聊，有些说的可能不是很对，勿较真。
都是说给家里边小朋友听的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2b75292d2dc6ea12d158649546dfadc/" rel="bookmark">
			Axure--RP9安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Axure RP 9是一款流行的快速原型设计软件，用于创建交互式原型。它提供了丰富的工具和功能，方便用户设计和演示WEB界面、APP界面以及软件界面等产品的交互效果。Axure RP 9可以帮助产品经理、设计师和开发团队更好地协作，快速验证和改进产品的交互流程和用户体验。它被广泛应用于各个行业和公司，是一个必备的工具之一。 官方安装包下载地址 Axure RP 9 MAC正式版：https://axure.cachefly.net/versions/9-0/AxureRP-Setup-3740.dmg
Axure RP 9 WIN正式版：https://axure.cachefly.net/versions/9-0/AxureRP-Setup-3740.exe
注意：Axure RP 9 MAC正式版为苹果版本，Axure RP 9 WIN正式版为Windows版本
Axure中文汉化包下载地址 点此下载汉化包&gt;&gt;
中文汉化包（可下载可不下载，个人喜好，Axure属于非国产软件，界面为英文版，汉化包可帮助界面展示风格为中文。）
关于兼容性：Axure RP 9可以打开低版本的RP源文件，但是一旦用9编辑保存后，就不能用低版本软件打开了。
第一步 开始安装Axure RP 9
解压完压缩包，点击运行一下exe。
第二步 一直点击蓝色边框既可（Launch Axure Rp9 Beta 可勾选/可不勾选，勾选了的话会自动打开软件）
第三步： 将Axure中文汉化包解压后的lang文件夹复制到你软件所安装的地址位置
第四步： 打开Axure RP9，界面就是中文版的了
第五步： ①启动我们的Axure软件，然后点击“输入授权”
②接着点击“Enter license key”输入许可证密钥
许可证密钥：
​Licensee :Freecrackdownload.com
KEY:5vYpJgQZ431X/G5kp6jpOO8Vi3TySCBnAslTcNcKkszfPH7jaM4eKM8CrALBcEC1
Licensee : yygg329405
KEY: QmNyZyXeMrJU+1yw6XiXZGenOs9R3wV7S+KS7K90yTk=
License:AX9001
KEY：iy9uUKbS7pEZwE5hbHTGigOcu48TdY4JXWbJYHxXLuvAzRL8qmry9J2mS5wXO7y3
Licens:AX9003
KEY：sOujdwe3jIWrmoe9S13mb42hKJWcRBe6L+CZwNsC4OluYXGVPFd+KiQjpdM56fpG
License：123
KEY：K8QL8bMkjnuHoGbUiCEAOTcPPZOyVnJ16h5CNoOoPjm1PeSanFtesYjIRWguJjLtm
License:macwk.com
KEY:WnXKElaO7BLA5KKZh9LpNLl/DsU62fHnnazJt5Gs4FzuOxkwgR3bYQNiSWyk7iVT
License:macwk.com
KEY:Cpvm3Fe/TOnZY2agskB3AxZe8a16QrW+NL2CUY9v9F+jyaOkv2suqshcVC81ZFha
License:macwk.com
KEY:eZZPVm1LL6KcZ6XpOLFfGezpdl9c49EAdOYdoEsNSA2TJGHu7tA5Voyyj+h1nPLo
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dbfceac9e73a114e763fd3d2881ceb0/" rel="bookmark">
			android 8.0以后大部分静态监听无法注册，需要注册动态监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拿监听网络状态来举例子
动态注册网络监听
AndroidManifest中添加权限
&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; 网络监听代码块
public class NetWorkChangeReceiver extends BroadcastReceiver { public NetWorkChangeReceiver() { } @Override public void onReceive(Context context, Intent intent) { Log.d("mile","come in NetWorkChangeReceiver onReceive"); // TODO: This method is called when the BroadcastReceiver is receiving //Toast.makeText(context,"netChanged!",Toast.LENGTH_LONG).show(); ConnectivityManager connectivityManager = (ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo(); if(networkInfo !=null &amp;&amp; networkInfo.isAvailable()) { Toast.makeText(context,"isAvailable!",Toast.LENGTH_LONG).show(); }else { Toast.makeText(context,"unAvailable!",Toast.LENGTH_LONG).show(); } } } public class YuloreApplication extends Application { @Override public void onCreate() { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dbfceac9e73a114e763fd3d2881ceb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81792030b4debd00098318b4753fca4c/" rel="bookmark">
			使用antd mobile的PickerView二次封装成业务所需选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 前言组件选择器视图选择器组件使用示例 注意事项扩展 前言 基于 Vant的checkbox配合popup和input定制选择器 实现一个React的版本
组件库：antd mobile
适用：移动端
UI如下：
功能点：
选择器在弹出层内，取消隐藏，确定带回选项选项展示数据可动态自定义，选项带出数据可动态自定义输入框动态展示输入框分为两个功能：过滤和远程搜索已选项定位到其位置（当选了第三个数据，再打开弹窗时，列表定位到第三个数据） 组件 选择器视图 import {PickerView} from "antd-mobile"; import React from "react"; const Select = (props) =&gt; { const {showOptions, value, setValue} = props; return &lt;PickerView columns={showOptions} value={value} onChange={val =&gt; { setValue(val) }} /&gt; } Select.propTypes = { showOptions: propTypes.array, //选择器列表数据 value: propTypes.oneOfType([ propTypes.string, propTypes.number, propTypes.object, //指定为多种类型的一种 ]), setValue: propTypes.func, }; Select.defaultProps = { showOptions: [], }; export default React.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81792030b4debd00098318b4753fca4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/934b98893986526d05e55a87f0d933d0/" rel="bookmark">
			Mac升级为什么会报错xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误信息通常出现在您的Mac上升级或更新操作系统后，因为Xcode Command Line Tools（Xcode命令行工具）需要重新安装或更新以适应新的操作系统版本。Xcode Command Line Tools包括一些开发工具，如xcrun，用于在Mac上编译和运行各种开发任务。
您可以通过以下步骤来解决这个问题：
打开终端：您可以在“应用程序”文件夹中的“实用工具”中找到终端。
运行以下命令来安装Xcode Command Line Tools：
xcode-select --install 如果弹出对话框询问是否要安装Xcode Command Line Tools，请选择安装。
等待安装完成。安装过程可能需要一些时间，具体取决于您的互联网连接速度。
安装完成后，再次尝试您的升级操作或其他需要Xcode Command Line Tools的操作。
这应该解决您遇到的问题。如果您之前没有安装Xcode Command Line Tools，或者您刚刚升级了操作系统，那么重新安装或更新这些工具是很常见的步骤。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcce06faed222f1d7fec735a8902185c/" rel="bookmark">
			蜀门手游全自动挂机项目，可无限放大脚本教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据关键词提供的内容，我明白你希望我写一篇与游戏挂机脚本教程相关的文章。 下面是一篇关于自动挂机脚本的文章：
标题：探索游戏世界的利器——自动挂机脚本完全教程
正文： 现如今，电子游戏产业蓬勃发展，各种类型的游戏层出不穷。对于许多游戏爱好者来说，不仅仅享受游戏的乐趣，还希望能够快速提升角色等级、获取更多资源和装备。而自动挂机脚本则成为了实现这一目标的利器。
什么是自动挂机脚本？简单来说，它是一种能够模拟玩家操作的程序，可以代替玩家进行游戏中的任务、战斗或采集等重复性操作。相比于传统的手动操作，自动挂机脚本能够提高效率，节省时间和精力。
接下来，我们将分享一个全面的自动挂机脚本教程，帮助那些渴望探索游戏世界的玩家们更好地利用自动挂机脚本。
第一步：选择适合的自动挂机脚本工具 市面上有很多自动挂机脚本工具可供选择，比如著名的XX挂机软件和YY自动脚本。在选择前，需要考虑工具的安全性、稳定性和兼容性等因素，并确保该工具符合游戏操作规则，以避免违反游戏规定。
第二步：了解游戏规则和操作流程 在使用自动挂机脚本之前，要对游戏规则和操作流程有足够的了解。这样可以更好地设置脚本的参数和任务，确保脚本按照期望的方式进行挂机。
第三步：编写自动挂机脚本 使用选择的自动挂机脚本工具，按照教程学习如何编写脚本。通常，脚本编写需要一些基础的编程知识，如脚本语言、逻辑控制和函数调用等。根据自己的需求，可以编写不同类型的脚本，比如战斗脚本、采集脚本、升级脚本等。
第四步：测试和调优 在使用自动挂机脚本之前，一定要进行充分的测试。在模拟环境下运行脚本，观察脚本是否按照预期执行，同时注意游戏客户端的运行情况，确保不会因为脚本导致异常崩溃或网络问题。
测试完成后，根据实际情况进行调优。可能需要调整脚本的执行速度、间隔时间、监听条件等，以确保脚本在游戏中的表现最佳。
最后，使用自动挂机脚本之前，一定要了解游戏公司对于挂机行为的规定。一些游戏会明确禁止挂机，为了避免帐号封禁，确保自己的使用方式符合游戏规定。
总结： 自动挂机脚本作为一个探索游戏世界的利器，可以帮助玩家提升游戏效率和体验。然而，合理使用自动挂机脚本非常重要。要遵循游戏规则，不做违法操作，以免面临帐号封禁等风险。
希望这个自动挂机脚本教程能够帮助到热爱游戏的你！通过合理使用自动挂机脚本，愿你在游戏世界里畅快探索，获得更多的乐趣和成就！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e13c70e88305cca3c94ec32064f1a32/" rel="bookmark">
			通义千问项目制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这一次我们来做一个集成了通义千问的程序，里面还有计算器、翻译等，通义千问支持播报，输入支持图像和文字。
1.申请和开通 1.1.文字识别开通 首先，打开文字识别_OCR 文字识别_图片识别文字_数据智能-阿里云 (aliyun.com)页面并登陆阿里云账号，点击，文字识别服务。接下来在RAM 访问控制 (aliyun.com)页面申请一个AccessKey并牢记。
1.2.通义千问申请 打开API详情_灵积模型服务-阿里云帮助中心 (aliyun.com)，选择申请体验，点击同意，即可申请体验。通过以后，打开API-KEY管理 (aliyun.com)，创建一个apikey并牢记
2.计算器的制作 这个程序保存在python安装路径\Lib目录下，重命名为jsq.py
首先打开阿里云盘分享，下载所需要的文件，之后运行bat文件，安装所需模块。
import PySimpleGUI as sg #引入模块PySimpleGUI a="" #创建变量来保存计算公式 layout=[ [sg.In(key="-I-",disabled=True,size=(18, None))], [sg.T(key="-T-")], [sg.B("c",key="c",size=(2,2)),sg.B("(",key="(",size=(2,2)),sg.B(")",key=")",size=(2,2)),sg.B("**",key="**",size=(2,2))], [sg.B("7",key="7",size=(2,2)),sg.B("8",key="8",size=(2,2)),sg.B("9",key="9",size=(2,2)),sg.B("+",key="+",size=(2,2))], [sg.B("4",key="4",size=(2,2)),sg.B("5",key="5",size=(2,2)),sg.B("6",key="6",size=(2,2)),sg.B("-",key="-",size=(2,2))], [sg.B("1",key="1",size=(2,2)),sg.B("2",key="2",size=(2,2)),sg.B("3",key="3",size=(2,2)),sg.B("*",key="*",size=(2,2))], [sg.B(".",key=".",size=(2,2)),sg.B("0",key="0",size=(2,2)),sg.B("=",key="=",size=(2,2)),sg.B("/",key="/",size=(2,2))] ] #界面布局创建 if 1==1: window=sg.Window('计算器',layout,grab_anywhere=True,disable_minimize=True,keep_on_top=True) #创建界面 while True: event,values=window.read() #刷新 if event==None: break #窗口关闭 if event=="1" or "2" or "3" or "4" or "5" or "6" or "7" or "8" or "9" or "0": window["-I-"].update(value=a+event) a=a+event if event=="c": window["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e13c70e88305cca3c94ec32064f1a32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcbbb87debc1668175d5a45bf9a50a24/" rel="bookmark">
			使用ElementUI表格时，字段超长的tooltips中白色横线问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目前在维护一个vue管理系统的项目，客户发现在鼠标hover表格中一个超长字段时发现字段中间有一条白色的横线挡住了，类似下图：
开始的时候看了一下后端传来的值以及前端表格渲染都没发现问题。查询了各种文档和问了一些前辈都没有相关问题的经验，包括CSDN上也没有搜索到相关内容。自己点开控制台看了一下发现是这个tooltips的一个x-arrow样式造成了影响
把他的display属性设置成none之后这个横线就消失啦。但是整个系统中有上百个表格存在，如果一个一个去改的话无疑工作量是十分大的。 所以需要在elementUI.scss中去进行全局修改，找到elementUI.scss中的.el-tooltip__popper[x-placement^='top'] .popper__arrow::after属性添加一个display:none。
这样就全局解决了这个小问题啦！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b56c87deb665c6d3fc186d0d9fc76c3b/" rel="bookmark">
			amba总线信号总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 axi系列。
信号名axi4axi4-liteaxi4-stream描述源头ACLK 全局时钟信号时钟源ARESETn 全局复位信号，低有效复位源AWID写地址ID，用来标志一组写信号主机AWADDR写地址，给出一次写突发传输的写地址主机AWLEN突发长度，给出突发传输的次数主机AWSIZE突发大小，给出每次突发传输的字节数主机AWBURST突发类型主机AWLOCK总线锁信号，可提供操作的原子性主机AWCACHE内存类型，表明一次传输是怎样通过系统的主机AWPROT 保护类型，表明一次传输的特权级及安全等级主机AWQOS质量服务QoS主机AWREGION区域标志，能实现单一物理接口对应的多个逻辑接口 主机AWUSER用户自定义信号 主机AWVALID有效信号，表明此通道的地址控制信号有效主机AWREADY表明“从”可以接收地址和对应的控制信号从机WID 一次写传输的ID tag主机WDATA写数据主机WSTRB写数据有效的字节线，用来表明哪8bits数据是有效的主机WLAST表明此次传输是最后一个突发传输主机WUSER用户自定义信号主机WVALID写有效，表明此次写有效主机WREADY表明从机可以接收写数据从机BID写响应ID tag从机BRESP 写响应，表明写传输的状态从机 BUSER用户自定义从机BVALID写响应有效从机BREADY 表明主机能够接收写响应主机ARID 读地址ID，用来标志一组写信号主机ARADDR读地址，给出一次写突发传输的读地址主机ARLEN突发长度，给出突发传输的次数主机ARSIZE突发大小，给出每次突发传输的字节数主机ARBURST突发类型主机ARLOCK 总线锁信号，可提供操作的原子性主机ARCACHE 内存类型，表明一次传输是怎样通过系统的主机ARPROT保护类型，表明一次传输的特权级及安全等级主机ARQOS质量服务QoS主机ARREGION 区域标志，能实现单一物理接口对应的多个逻辑接口主机ARUSER用户自定义信号主机ARVALID有效信号，表明此通道的地址控制信号有效主机ARREADY表明“从”可以接收地址和对应的控制信号从机RID读ID tag从机RDATA 读数据从机RRESP 读响应，表明读传输的状态从机RLAST 表明读突发的最后一次传输从机RUSER用户自定义从机RVALID表明此通道信号有效从机RREADY 表明主机能够接收读数据和响应信息主机CSYSREQ系统退出低功耗请求，此信号从“时钟控制器”到“外设”时钟控制器CSYSACK退出低功耗状态确认外设CACTIVE外设请求时钟有效外设 ahb系列
信号对于ahb5和ahb-lite讲是一样的，就是有些功能ahb-lite用不到会设置为固定值。
信号名ahb5ahb-lite信号描述来源HCLK全局时钟信号时钟源HRESETn全局复位信号，低有效复位源HADDR[31:0]32位系统地址主机HBURST[2:0]确定传输是单个传输还是burst传输主机HMASTLOCK若为高则是一个lock 传输。主机HPROT[3:0]判定是否是opcode fetch或者数据传输，是个私有模式还是用户模式主机HPROT[6:4]AHB5 extend_memory_type 的支持主机HSIZE[2:0]一次传输大小，最大传输大小可达1024bits主机HNONSEC确定当前传输是安全传输还是非安全传输主机HEXCLexclusive传输主机HMASTER[3:0]master指定。如果有多个exclusive能力的进程。由内部互联部件来修改来确定每个master都是被指定的。exclusive传输时用的信息。主机HTRANS[1:0]确定传输的类型，IDLE-2‘b00, BUSY-2'b01, NONSEQ-2'b10, SEQ-2'b11主机HWDATA[31:0]写数据，最小的数据bus宽度是32bits主机HWRITE传输方向， 值为高是写，低是读。主机HRDATA[31:0]多slave读回的数据，传给master，最小32bits的数据宽度，不确定。slave-&gt;multiplexor从机HREADYOUThigh的时候是传输结束。low的时候会有新的transfer。从机HRSP传输响应。0-OKAY， 1-ERROR从机HEXOKAY如果ahb5 exclusive传输支持的话，这个标识传输成功还是没成功。0-ERROR，1-OKAY从机HSELxslave选择信号，跟地址同步，会有HSEL_S1,HSEL_S2,HSEL_memory....从机HRDATA[31:0]decoder选中返回给master的读数据multiplexorHREADY1-通知master和多个slave，前一笔的传输完成multiplexorHRESPdecoder选中的传输响应multiplexorHEXOKAYdecoder选中的exclusive传输完成multiplexor apb系列
信号名apb3apb4信号描述来源PCLK有有上升沿传输时钟源PRESETn有有低有效与系统里的nresetn同步PADDR有有最高可达32bitssAPB桥PSELx有有APB桥产生的slave选择信号APB桥PENABLE有有标识下一拍或者几拍后会有APB传输APB桥PWRITE有有1-APB写， 0-APB读APB桥PWDATA有有写数据，PWRITE为高的时候，写数据，最高32bitsAPB桥PRDATA有有选定的slave返回的读数据，当PWRITE为低。最高32bits从机PREADY有有从机用这根信号来回应是个APB 传输从机PSLVERR有有传输错误。APB设备不需要支持这个pin，不支持时，tie成0. 当已有的apb设备和新的apb设备都存在的时候，可以使用这个pin。从机PPROT无有保护类型，支持安全和非安全的传输APB桥PSTRB无有写数据通路上支持稀疏传输APB桥 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/569b8f2b1699599d8a0ca8920a1c34d5/" rel="bookmark">
			Flask Modules - Routes and view functions in Flask
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. **Defining Routes**:
In Flask, routes define the mapping between URL paths and view functions. To define a route, you can use the `@app.route` decorator. For example:
from flask import Flask app = Flask(__name__) @app.route('/') def home(): return 'Welcome to the home page' In the example above, `@app.route('/')` defines a mapping between the root URL ('/') and the `home` view function.
2. **View Functions**:
View functions are Python functions that handle HTTP requests and return HTTP responses.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/569b8f2b1699599d8a0ca8920a1c34d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/008bdd335b7a3651c21ad418430f9ddd/" rel="bookmark">
			LangChain入门(三)-对超长文本进行总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub - liaokongVFX/LangChain-Chinese-Getting-Started-Guide: LangChain 的中文入门教程LangChain 的中文入门教程. Contribute to liaokongVFX/LangChain-Chinese-Getting-Started-Guide development by creating an account on GitHub.https://github.com/liaokongVFX/LangChain-Chinese-Getting-Started-Guide
一、问题：文本超长会超出限制 这时，我们一般会进行对文章进行分段，比如通过 tiktoken 计算并分割，然后将各段发送给 api 进行总结，最后将各段的总结再进行一个全部的总结。
接下来我们使用 LangChain来帮我们处理
二、安装依赖 pip install unstructured pip install pdfplumber 三、使用案例 准备一个超长问题：b.txt
import os from langchain.document_loaders import UnstructuredFileLoader from langchain.chains.summarize import load_summarize_chain from langchain.text_splitter import RecursiveCharacterTextSplitter from langchain import OpenAI # openAI的Key os.environ["OPENAI_API_KEY"] = '**********' # 谷歌搜索的Key os.environ["SERPAPI_API_KEY"] = '**********' # 导入文本 loader = UnstructuredFileLoader(fr"D:\a\program\pythonProject\b.txt") # 将文本转成 Document 对象 document = loader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/008bdd335b7a3651c21ad418430f9ddd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10a318c10ae3dd2c4cb34e154860e121/" rel="bookmark">
			springboot 出现 Cannot resolve MVC View ‘index‘ 问题解决办法，前后端不分离项目前端文件存放位置，已经如何访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 springboot 出现 Cannot resolve MVC View ‘index‘ 问题解决办法，前后端不分离项目前端文件存放位置，已经如何访问 简介：本文讲解，在springboot不分离的项目中，前端的文件存放的位置，和Cannot resolve MVC View ‘index‘ 这个报错怎么处理。
我们需要把html相关的页面放在resource的templates的下面，然后js,css相关的文件需要放在static下面
我现在想要访问这个index.html，需要注意的是@Controller这样才可以，当返回的String的时候的时候不是字符串，而是转到对应的地址，然后这个地址，不写templates。
相关的js文件，放在static下面的时候，不能够加上static这个路径。
这个时候最重要的是，需要加上两个依赖，才可以让代码识别。
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16bfb5df7af8d0d3268de932af2ec870/" rel="bookmark">
			H5如何做页面下拉刷新和上拉加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里以vant为例
结构
&lt;van-pull-refresh v-model="isLoading" success-text="刷新成功" @refresh="onRefresh" &gt; &lt;van-list style="height:100%" v-model="loading" :finished="finished" finished-text="没有更多了" @load="onLoad" &gt; &lt;!-- 内容 --&gt; &lt;div class="box3" v-for="(item, index) in orderList" :key="index"&gt; &lt;div class="item1"&gt;{{item.N?.replace(/[【】[\]]/g, '')}}&lt;/div&gt; &lt;div class="item2"&gt; &lt;div class="text1"&gt; &lt;div class="spn"&gt; &lt;div &gt;订单编码:&lt;/div&gt; &lt;div class="sn"&gt;{{ item.A || '/'}}&lt;/div&gt; &lt;/div&gt; &lt;div class="spn"&gt; &lt;div &gt;提交时间:&lt;/div&gt; &lt;div class="sn"&gt;{{ item.B || '/'}}&lt;/div&gt; &lt;/div&gt; &lt;div class="spn"&gt; &lt;div &gt;当前处理人:&lt;/div&gt; &lt;div class="sn"&gt;{{ item.C || '/'}}&lt;/div&gt; &lt;/div&gt; &lt;div class="spn"&gt; &lt;div &gt;归档时间:&lt;/div&gt; &lt;div class="sn"&gt;{{ item.D || '/'}}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16bfb5df7af8d0d3268de932af2ec870/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0be68d20f2e23e616d2210977802130/" rel="bookmark">
			ngx.shared共享内存操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ngx.shared.DICT.get
语法：value, flags = ngx.shared.DICT:get(key)
获取共享内存上key对应的值。如果key不存在，或者key已经过期，将会返回nil；如果出现错误，那么将会返回nil以及错误信息。
local test= ngx.shared.test
local value, flags = test.get("cronaldo")
返回列表中的flags，是在ngx.shared.DICT.set方法中设置的值，默认值为0. 如果设置的flags为0，那么在这里flags的值将不会被返回。
ngx.shared.DICT.get_stale
语法：value, flags, stale = ngx.shared.DICT:get_stale(key)
与get方法类似，区别在于该方法对于过期的key也会返回，第三个返回参数表明返回的key的值是否已经过期，true表示过期，false表示没有过期。
ngx.shared.DICT.set
语法：success, err, forcible = ngx.shared.DICT:set(key, value, exptime?, flags?)
“无条件”地往共享内存上插入key-value对，这里讲的“无条件”指的是不管待插入的共享内存上是否已经存在相同的key。三个返回值的含义：
success：成功插入为true，插入失败为false
err：操作失败时的错误信息，可能类似"no memory"
forcible：true表明需要通过强制删除（LRU算法）共享内存上其他字典项来实现插入，false表明没有删除共享内存上的字典项来实现插入。
第三个参数exptime表明key的有效期时间，单位是秒（s），默认值为0，表明永远不会过期；flags参数是一个用户标志值，会在调用get方法时同时获取得到。
local test = ngx.shared.test
local succ, err, forcible = test:set("cronaldo", "he is the greatest player!")
ngx.shared.DICT.safe_set
语法：ok, err = ngx.shared.DICT:safe_set(key, value, exptime?, flags?)
与set方法类似，区别在于不会在共享内存用完的情况下，通过强制删除（LRU算法）的方法实现插入。如果内存不足，会直接返回nil和err信息"no memory"
注意：set和safe_set共同点是：如果待插入的key已经存在，那么key对应的原来的值会被新的value覆盖！
ngx.shared.DICT.add
语法：success, err, forcible = ngx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0be68d20f2e23e616d2210977802130/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70820d7198d14c4e504eda16d288b2bc/" rel="bookmark">
			c#using关键字的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/Mona_Zhao/article/details/91363446
using关键字的三种作用：
1. 引用命名空间；
2. 为命名空间或者类型创建别名；
3. 使用using语句。
（1）引用命名空间
类似于c和c++的#include&lt;&gt;, python的import，都是在程序中引入命名空间的类型，而不必制定类型详细的命名空间。
使用方法为：using + 命名空间名称;
（2）为命名空间或者类型创建别名
使用方法为：using + 别名 = 包括详细命名空间信息的具体的类型;s using System; //引用命名空间
using aClass = test1.MyClass; //创建别名
using bClass = test2.MyClass; //创建别名
namespace test1 {
public class MyClass {
public override string ToString() {
return "You are in test1.MyClass";
}
}
}
namespace test2 {
class MyClass {
public override string ToString() {
return "You are in test2.MyClass";
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70820d7198d14c4e504eda16d288b2bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ae06ab9790f55f31ccffd4721d80c90/" rel="bookmark">
			VOSviewer使用方法（详细便捷）附下载网址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VOSviewer使用方法（详细便捷）附下载网址 参考：韦编｜5分钟学会VOSviewer共现网络分析与可视化
VOSviewer 操作指南 简明
文章目录 VOSviewer使用方法（详细便捷）附下载网址简介功能1.Network visualization（聚类视图） 2.Overlay visualization（标签视图）3.Density visualization（密度视图）其他功能 界面介绍：下载地址：功能一：研究热点词聚类 简介 VOSviewer是一款文献计量软件，“Citespace”“Histcite”“VOSviewer”“Pajek”这些都是文献计量软件，VOSviewer是最适合做共现网络的。它也是一种知识图谱可视化软件，可以使用基本的分类聚类方法，可以将文献的关键词进行聚类，从而找到研究的热点。
功能 VOSviewer软件设计的核心思想是“共现聚类”，即两个事物同时出现代表它们之间是相关的；这种相关关系存在多种类型，它们的强度和方向也不一样；基于关系强度与方向的测度指标聚类，可寻找不同类型的团体。
1.Network visualization（聚类视图） Network visualization（聚类视图）解读：圆圈和标签组成一个元素，元素的大小取决于节点的度、连线的强度、被引量等，元素的颜色代表其所属的聚类，不同的聚类用不同的颜色表示，通过该视图可以查看每个单独的聚类，例如通过主题共现发现研究热点的结构分布、通过作者合作发现研究小团体、通过作者耦合网络发现学者对研究主题的异同情况等。
2.Overlay visualization（标签视图） 区别于Networkvisualization的特点是用户可以根据自己的研究需要，通过map file文件中的score或颜色（红、绿、蓝）字段对节点赋予不同的颜色。默认按关键词的平均年份取score值进行颜色映射，可以分析领域内研究趋势的演变。
3.Density visualization（密度视图） 图谱上每一点都会根据该点周围元素的密度来填充颜色，密度越大，越接近红色；相反，密度越小，越接近蓝色。密度大小依赖于周围区域元素的数量以及这些元素的重要性。密度视图可用来快速观察重要领域以及某一领域知识及研究密度情况。
其他功能 除主要的知识图谱可视化功能，VOSviewer还提供了数据清洗、词汇筛选等其他功能。
界面介绍： 网络视图：每一个圆圈的大小代表这个关键字的权重，两个圆圈之间的距离表示了两个圆圈之间的亲缘性，如果亲缘性越强则距离越短，亲缘性越弱则距离越远。圆圈的颜色代表了各自的簇类。 覆盖视图：覆盖视图与网络视图的图的结构是一样的，颜色有区别，所有关键字按照权重着色，并且给与参与者自己着色的方法。只有当设定了条目的属性和关键字相关时，覆盖视图才有用。 密度视图：显示的是项目密度，关键字周围的关键字数越大，则颜色越亮。 第二部分选项面板
Scale：各个项目之间链接的粗细。 Weight: 当项目有多个权重时，可以选择这个下拉框，选择相关的权重展示。 Scores: 只有在覆盖视图中，会根据实际的条目占比，对各项的颜色表示进行调整。 Size variation: 项目的表示大小与权重相关，越大表示权重越大。 max length： 项目的标签显示长度。 Font：下拉框可以显示的文字格式。 Lines: 连线部分
Size Variation ：两个标签之间的连线越粗，则表示两个标签之间的关系约紧密。 Min、Max strength：最大，最小连接线的表示。 Colored lines: 图示是否选用有颜色的线表示。 Curved lines： 图示采用直线还是曲线连接。 下载地址： 首先要安装java。
https://www.vosviewer.com/download
下载时注意下载对应的电脑系统安装包。
解压之后的目录：
双击.exe文件，即可安装运行软件。PDF是使用说明手册。
安装完成之后如下图：
功能一：研究热点词聚类 这个软件支持多种文献导入方式，以web of science为例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ae06ab9790f55f31ccffd4721d80c90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b3f40000d516deffce5e81350de202b/" rel="bookmark">
			Laravel 模型的关联查询 &amp; Debugbar 调试器 &amp; 模型的预加载 ⑩②
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@作者 : SYFStrive
@博客首页 : HomePage
📜： THINK PHP
📌：个人社区（欢迎大佬们加入） 👉：社区链接🔗
📌：觉得文章不错可以点点关注 👉：专栏连接🔗
👉 VUEJS（🔥） 👉 MYSQL（🔥） 👉 微信小程序（🔥） 👉 PHPMYSQL（🔥） 👉 UNIAPP开发（🔥） 目录 PHP LARAVEL 简介PHP LARAVEL 模型的关联查询 关联查询PHP LARAVEL Debugbar 调试器 安装使用PHP LARAVEL 模型的预加载 预加载最后 ⡖⠒⠒⠒⠤⢄⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸ ⠀⠀⠀⡼⠀⠀⠀⠀ ⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢶⣲⡴⣗⣲⡦⢤⡏⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠋⠉⠉⠓⠛⠿⢷⣶⣦⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠘⡇⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡞⠀⠀⠀⠀⠀⠀⠀⢰⠇⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⡴⠊⠉⠳⡄⠀⢀⣀⣀⡀⠀⣸⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⢸⠃⠀⠰⠆⣿⡞⠉⠀⠀⠉⠲⡏⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠈⢧⡀⣀⡴⠛⡇⠀⠈⠃⠀⠀⡗⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣱⠃⡴⠙⠢⠤⣀⠤⡾⠁⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⢀⡇⣇⡼⠁⠀⠀⠀⠀⢰⠃⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⣸⢠⣉⣀⡴⠙⠀⠀⠀⣼⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⡏⠀⠈⠁⠀⠀⠀⠀⢀⡇⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⢸⠃⠀⠀⠀⠀⠀⠀⠀⡼⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⣰⠃⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⣀⠤⠚⣶⡀⢠⠄⡰⠃⣠⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⢀⣠⠔⣋⣷⣠⡞⠀⠉⠙⠛⠋⢩⡀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀ ⠀⡏⢴⠋⠁⠀⣸⠁⠀⠀⠀⠀⠀ ⠀⣹⢦⣶⡛⠳⣄⠀⠀⠀⠀⠀ ⠀⠙⣌⠳⣄⠀⡇ 不能 ⡏⠀⠀ ⠈⠳⡌⣦⠀⠀⠀⠀ ⠀⠀⠈⢳⣈⣻⡇ 白嫖 ⢰⣇⣀⡠⠴⢊⡡⠋⠀⠀⠀⠀ ⠀⠀⠀⠀⠳⢿⡇⠀⠀⠀⠀⠀⠀⢸⣻⣶⡶⠊⠁⠀⠀ ⠀⠀⠀⠀⠀⢠⠟⠙⠓⠒⠒⠒⠒⢾⡛⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⣠⠏⠀⣸⠏⠉⠉⠳⣄⠀⠙⢆⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⡰⠃⠀⡴⠃⠀⠀⠀⠀⠈⢦⡀⠈⠳⡄⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⣸⠳⣤⠎⠀⠀⠀⠀⠀⠀⠀⠀⠙⢄⡤⢯⡀⠀⠀⠀⠀⠀⠀ ⠀⠐⡇⠸⡅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⡆⢳⠀⠀⠀⠀⠀⠀ ⠀⠀⠹⡄⠹⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣇⠸⡆⠀⠀⠀⠀⠀ ⠀⠀⠀⠹⡄⢳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡀⣧⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⢹⡤⠳⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣷⠚⣆⠀⠀⠀⠀ ⠀⠀⠀⡠⠊⠉⠉⢹⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡎⠉⠀⠙⢦⡀⠀ ⠀⠀⠾⠤⠤⠶⠒⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠒⠲⠤⠽ 提示：以下是本篇文章正文内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b3f40000d516deffce5e81350de202b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eecf57e90709b50ad1e26b6df78b6455/" rel="bookmark">
			linux复习笔记01（小滴课堂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装CentOs7系统 点击下一步在自定义硬件中：
我们可以删除我们不使用的，后续如果需要再加上即可。
然后我们就可以开启这台虚拟机了。
我们可以进行下载cetos7.
这里选择简体中文就可以。
时间的设置。
可以开启下网络。
在这里选择设置root密码，我设置的密码是abc123456.
然后让它安装就可以了。
这样我们就登录成功了。
d容易与局域网其它主机引起ip地址冲突。
DHCP服务是指由服务器控制的一段IP地址范围，当客户机登录服务器的时候，会自动获取服务器分配的IP地址与子网掩码。
我们先去重启网卡：
然后我们使用命令：ip addr查看ip：
我们可以看到它的ip地址。
ping命令可以检测网络是否连通：ping ip地址。
我们去ping一下我们的ip地址：
我们发现是可以ping通的。
在外部ping虚拟机也是可以ping通的。
我们发现ping百度也是可以通的。
我们现在把这台虚拟机改成仅主机模式：
当然我们还要像之前那样重启网卡。
然后再查看一下ip地址：
我们的ip地址完全不一样。
我们看一下此时的虚拟机和外部的物理主机能否通信：
我们发现是可以通信的。
外部也可以ping通。
这个我们发现ping不通。
我们ping一下本地Ip：
本地也ping不通。
虚拟机的快速克隆和快照恢复：
我们如果每次都去新建虚拟机，那会很消耗时间的，但是呢，如果我们采用克隆的方式，就会大大的节约时间了。
只有关机的虚拟机才能进行克隆。
在响应的虚拟机上点击右键选择克隆即可。
两台虚拟机是一模一样的呢。
Linux必备命令：
1.cd命令
切换目录：
table键自动补全：
cd -切换回之前的目录。
2. pwd 查看当前所在目录
回到上一层。
3.ls命令
列出当前层级所有目录
ls -l
以列表的形式展示：
ls -ltr 按时间顺序显示
ls -a显示隐藏路径
ls 默认当前路径。
ls -ltr/home 可以查看对应其它的目录，这里是看home目录
可以用这种方式创建文件。
可以用cat命令查看内容。
使用-n可以查看行号。
more命令：
查看大文件内容：
按空格翻页，回车一行一行看，q退出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eecf57e90709b50ad1e26b6df78b6455/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a813230b13c255c43496f47f29564208/" rel="bookmark">
			7. read_excel()函数读取Excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【目录】
文章目录 1. pandas库读取数据2. read_excel()函数读取Excel文件3. 准备工作4. 路径前的`r`是什么5. io参数 = 绝对路径6. io = 相对路径7. sheet_name：要读取的sheet的名称或索引7.1 sheet_name参数 = 名字7.2 sheet_name参数 = 顺序 8. index_col参数指定行索引9. header参数指定列索引10. usecols参数指定读取列11. names参数自定义列名（列表形式）12. 总结 【正文】 学习时间：30分钟。
1. pandas库读取数据 用Pandas里的read_x方法可以读取外部数据。
x表示要读取的文件的格式。
读取xlsx文件用read_excel方法。读取csv文件用read_csv方法。读取txt文件用read_table方法。 2. read_excel()函数读取Excel文件 read_excel()函数是pandas库中用于读取Excel文件的函数。
【语法】
pandas.read_excel(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None) 这里用的语法是调用库的函数：
库名.函数名( ) pandas是库名，这里通常用的是它的简写pd。
read_excel是函数名，在Python中，读取通常都会用到跟read相关的函数。
excel表示要读取的文件类型。
【参数】
io：要读取的Excel文件的路径（字符串）或者可迭代对象，例如文件对象、Excel表格URL、Excel文件中的表名等。sheet_name：要读取的Sheet的名称或索引（默认为0）。header：指定列名所在的行数，默认为0，表示第一行。names：自定义列名（列表形式），如果不指定，则默认使用Excel文件中的列名。index_col：指定作为行索引的列，默认为None，表示不使用任何列作为索引。usecols：指定要读取的列（列表形式），可以是列名或列索引。 3. 准备工作 注意使用read_excel()函数前需先安装pandas库。
在读取文件时首先要确定文件路径，即要读取的文件存在电脑中的哪个文件夹下。
以读取示例.xlsx为列。
我的示例.xlsx的绝对路径如下：
D:\安迪笔记\4.数据分析\7\示例.xlsx 我的示例.xlsx的相对路径如下：
4.数据分析\7\示例.xlsx 注意你的路径和我的不同哦！！！
示例.xlsx文件里有两个表单。
示例.xlsx文件的第1个sheet如下所示：
示例.xlsx文件的第2个sheet如下所示：
4. 路径前的r是什么 file = r"D:\安迪笔记\4.数据分析\7\示例.xlsx" 电脑中的文件路径默认使用\。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a813230b13c255c43496f47f29564208/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c08d507b771f2c606484197526a36c4a/" rel="bookmark">
			yolov5训练加速--一个可能忽视的细节（mmdetection也一样），为什么显卡使用率老是为0？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅讨论节省图片加载时间问题，这里面可能有一些容易忽视的细节。yolov5的训练参数里面有一个--cache，默认是ram，就是把解码后的图片保存在内存中。也可以是disk，就会把解码后的图片保存在硬盘上。
parser.add_argument('--cache', type=str, nargs='?', const='ram', help='--cache images in "ram" (default) or "disk"') 解码后的图片就是numpy数组啦，保存为.npy文件
这里可能有一个问题，保存在硬盘上有啥用？能加速吗？
接下来就稍微展开讨论一下。
一。现象 在训练的时候，有可能会发现显卡使用率不高，甚至有的时候显卡使率用老是为0（用nvidia-smi查看），然后刷地一下升高了，然后又较长时间为0，这时候可能会觉得奇怪，它到底在干啥呢？这个时候如果查看cpu使用率，往往发现cpu占用率一直很高，有几个逻辑cpu始终满负责（用top命令查看）
二。分析 训练的时候无非是几个步骤：
1.加载图片
2.图片预处理，数据增强，比如缩放，旋转，错切等等，还有yolov5常用的mosaic、mixup
3.正向反向，更新梯度等等要用显卡的地方
而1、2两步里面的加载图片其实是一个容易忽略的耗时步骤，加载图片的耗时即磁盘IO耗时和解码图片耗时，这两个耗时都跟图片大小有关系，图片越大，耗时就越长。而磁盘IO又跟你的磁盘性能有关系，磁盘性能相差可能天差地别，比如pcie4.0的SSD和机械硬盘就可能是10倍以上的速度差别，而解码图片这个只跟CPU有关系了，差别不会太大。
所以这里先回前面的问题保存在硬盘上有啥用？能加速吗？-----能，就算解码后图片文件比原图片文件更大，都能加速，只要你用的是高性能的SSD就行，因为它把CPU解码时间完全给省掉了。
另外，其实yolov5每训练一张图片，它不是只读了一张图，它起码会读4张图，因为mosaic数据增强是默认开启的，概率为1，它会把4张图拼成一张（随机中心点），这个暂不详述。然后如果开启了mixup，mixup又会再读4张图，跟之前的4张图做混合，那就是一次读8张图了。（当然如果mixup开的概率不大的话，那就不是每次都读8级图）。总之就是一次最多能读到8张图，那么读图时间成本就翻了8倍了。虽然你可能会说我CPU多核的，我SSD很快，但是你本来开一个较大的batch-size的时候，就已经充分用到了多核性能，现在再乘个8，就不够用啦。
这里要提一下mmdetection里的yolox，它默认是会用到mosaic加mixup的，并且没有概率设置，每次都读8张图，所以给人的感觉就是，这玩意儿训练怎么这么慢？我的显卡为什么一直是0，它在干啥？
注：原生的yolox是可以用缓存的，但mmdetection好像不行，如果你知道怎么用，请告诉我
三。先上结论 1.如果训练图片总量不大，或者服务器内存超高，即完全可以把解码后的图片放内存里，那就充分利用，直接加上--cache参数完事
2.如果读图片的时间不长，它的耗时只占总时间的很少一部分，没什么优化意义那就不用管它。比如：
(1)训练图片都很小，比如大多在200K以下
(2)模型比较大，导致显卡耗时占了大部分，比如用yolov5x的规模训练
(3)只开mosaic，没开mixup，甚至mosaic的概率还调小了
3.如果想节省读图时间，但是内存又装不下。但是你有一个高性能的SSD，那你就可以考虑把解码后的图片缓存在硬盘上。即用--cache disk参数
4.如果想节省读图时间，但是内存装不下，又没有SSD，那怎么办呢？凉拌！买一个SSD不就行了，买不起显卡，还买不起SSD吗，管够！不过还有一点
如果你的训练图片都很大，比如分辨率高，或者压缩率低，你都可以根据训练用到的分辨率直接把原图resize一下，保存为jpg格式，直接保存到npy文件中（具体见续篇），比如你训练的分辨率用的是640（yolov5默认就是640），那你就把图片resize到640（保持宽高比例）就行了，这样你的图片就变小了，那读图时间自然就少了。并且有可能变小之后你的内存装的下了，那速度就起飞了！
此处修正:
1.保存为640jpg是有可能影响训练效果的，可以保存为640分辨率的npy
2.关于读图时间、显卡耗时与总时间的关系，其实不是简单地相加，两者是木桶效应。
具体可以见续篇：
yolov5训练加速--一个可能忽视的细节（mmdetection也一样），为什么显卡使用率老是为0？（续）_kv1830的博客-CSDN博客
四。实验 我其实是用mmdetection的yolox在训练cityscape数据集的时候，发现了这么个问题，cityscape的图片都是2M左右，分辨率是2048乘1024的，然后你再用一个小规模的模型来训练，比如yolox_s，那就会发现训练时间明显长于yolov5s（那是因为yolox开了mixup），而且貌似还没有把图片加内存里的功能。
但是我家里的电脑上没有准备好cityscape的标注文件，我就不用它演示了。我正好有一个之前做一个实验用的超小数据集，训练集一共只有45张图，验证集只有5张图，但是里面的图片都蛮大的，都是2M多，正好用它来试试。之前的实验在如下文章中：
https://blog.csdn.net/ogebgvictor/article/details/128179019
我的显卡是笔记本上的3080，为了增强对比效果，先把mixup打开，概率设为1（复制了一份超参数文件data/hyps/hyp.scratch-low-my.yaml）
注意，我笔记本上只有一个PCIE4.0的SSD，所以我的耗时主要不在磁盘IO上，而是在图片解码上
1.啥也不缓存 python train.py --data earplug_data/dataset.yaml --cfg models/yolov5s.yaml --weights weights/yolov5s.pt --batch-size 8 --epochs 200 --name exp_earplug --hyp data/hyps/hyp.scratch-low-my.yaml 耗时如下，45张图按理来说岂不是飞地一下就没了，这边却耗时在7、8秒左右一轮，而且明显会感觉进度条卡顿(时快，时卡那种，那个0秒的可能不太准）
2.直接装内存里 python train.py --data earplug_data/dataset.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c08d507b771f2c606484197526a36c4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2826c2de4f4db5778d76dd453c36c7f/" rel="bookmark">
			clickhouse三分片一副本集群部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、创建文件夹 /opt/module/clickhouse,将安装包放入文件夹 2.、安装和创建路径并修改用户组和用户名 #数据文件路径： mkdir -p /data/clickhouse/ #日志文件路径： mkdir -p /data/log/clickhouse-server/ #给创建的路径修改用户组和用户名 chown -R clickhouse:clickhouse /data/clickhouse/ chown -R clickhouse:clickhouse /data/log/clickhouse-server/ #如果/data/lib和/data/log/属于bigdata用户，则添加这两个路径other用户的的权限,使clickhouse用户可以访问/data/log和/data/clickhouse的子目录 chmod o+rx /data/log/ chmod o+rx /data/clickhouse/ sudo rpm -ivh *.rpm 3、安装过程中，不用设置登陆密码，直接按enter键 4、修改配置文件/etc/clickhouse-server/config.xml 删除掉&lt;listen_host&gt;两端的注释，使主机可以被外部发现。
修改tcp端口为9123，默认9000端口已被其他程序占用。
修改默认路径
1.数据文件路径：
&lt;path&gt;/data/clickhouse/&lt;/path&gt; 2.日志文件路径：
&lt;log&gt;/data/log/clickhouse-server/clickhouse-server.log&lt;/log&gt; 3.临时文件路径
&lt;tmp_path&gt;/data/clickhouse/tmp/&lt;/tmp_path&gt; 4.配置metrika.xml副配置文件
在config.xml文件中声明metrika.xml文件路径及相关配置
vi /etc/clickhouse-server/metrika.xml &lt;yandex&gt; &lt;clickhouse_remote_servers&gt; &lt;perftest_3shards_1replicas&gt; &lt;shard&gt; &lt;internal_replication&gt;true&lt;/internal_replication&gt; &lt;replica&gt; &lt;host&gt;node1&lt;/host&gt; &lt;port&gt;9123&lt;/port&gt; &lt;/replica&gt; &lt;/shard&gt; &lt;shard&gt; &lt;replica&gt; &lt;internal_replication&gt;true&lt;/internal_replication&gt; &lt;host&gt;node2&lt;/host&gt; &lt;port&gt;9123&lt;/port&gt; &lt;/replica&gt; &lt;/shard&gt; &lt;shard&gt; &lt;internal_replication&gt;true&lt;/internal_replication&gt; &lt;replica&gt; &lt;host&gt;node3&lt;/host&gt; &lt;port&gt;9123&lt;/port&gt; &lt;/replica&gt; &lt;/shard&gt; &lt;/perftest_3shards_1replicas&gt; &lt;/clickhouse_remote_servers&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2826c2de4f4db5778d76dd453c36c7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e933a2aec817f954e5f9806ed70bc8e/" rel="bookmark">
			vue3详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.简介 Vue 3是一种流行的JavaScript框架，用于构建用户界面。它是Vue.js框架的最新版本，于2020年9月正式发布。Vue 3在Vue 2的基础上进行了重大改进和增强，并提供了更好的性能、更好的开发体验和更多的功能。
以下是Vue 3的一些主要特点和改进：
响应式系统：Vue 3使用Proxy对象替代了Vue 2中基于Object.defineProperty的劫持方式。这样的改变使得Vue 3的响应式系统更强大和灵活。它能够捕获更多类型的变更，提供更好的性能，并且能够处理动态添加的属性和删除属性。
组件模型：Vue 3引入了组合式API（Composition API），作为选项式API（Options API）的补充。组合式API允许开发人员更好地组织和复用组件逻辑，通过使用函数来组织代码，而不仅仅依靠选项。这种方式提供了更灵活、组合性更强的组件开发方式。
性能优化：Vue 3采用了虚拟DOM算法的改进，通过静态提升（Static Nodes Hoisting）和基于模块的编译优化，提供了更好的性能。它具有更高的渲染速度、更小的包大小，以及更好的Tree-shaking支持，使您的应用程序更高效。
Teleport组件：Vue 3引入了Teleport组件，它使得在DOM树中的任何位置渲染组件变得更容易。它可以帮助您处理跨组件层级的弹出窗口、对话框和模态框等场景。
TypeScript支持：Vue 3更好地集成了TypeScript，并提供了更准确的类型推断和类型检查。这使得在Vue应用程序中使用TypeScript变得更加流畅和安全。
总体而言，Vue 3在性能、开发体验和功能方面都有明显的改进和增强。它提供了更好的响应式系统、更灵活的组件开发方式和更高的性能，使开发人员能够构建出更高效、易维护和功能丰富的应用程序。
二.使用 安装 1、确定node 版本
2、确定 npm 版本
3、安装 vue3.0
npm install -g @vue/cli 4、 查看 vue脚手架的版本
vue -V 5、 创建项目
vue create my-project (项目名) 6、 选中安装vue3.0
7、运行项目
npm run serve 声明变量 使用响应式变量 在Vue3中，响应式变量是通过ref()和reactive()函数创建的。ref()函数用于创建单一的响应式变量，而reactive()函数则用于创建包含多个属性的响应式对象。
下面是一个例子，演示如何在setup()函数中创建一个响应式变量：
import { ref } from 'vue'; export default { setup() { const count = ref(0); return {count};} }; 在上面的代码中，我们使用了ref()函数来创建一个名为count的响应式变量，并将其初始化为0。然后，在setup()函数中将这个变量返回给模板。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e933a2aec817f954e5f9806ed70bc8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e57b0b72459934ac06c2e0961307792/" rel="bookmark">
			快手查权重抖音查权重QQ查估值三合一工具查询脚本教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人都希望了解自己在社交媒体平台上的权重和影响力，以及一些网络服务的估值情况。而如今，有一款名为“快手查权重抖音查权重QQ查估值三合一工具查询脚本”的工具可以帮助大家实现这一目标。在这篇文章中，我们将为您介绍如何使用这个工具，并了解它的一些功能和用途。
首先，让我们来看看如何使用这个工具来查询平台上的权重和影响力。通过运行这个脚本，您可以输入相应的账号或链接，然后工具会迅速分析该账号在快手、抖音和QQ等平台上的权重和受欢迎程度。这将帮助您了解自己在这些平台上的表现，并据此进行更好的社交媒体策划。
其次，这个工具还可以用于查询一些网络服务的估值情况。比如，通过输入特定的关键词或链接，工具可以分析相关服务的受欢迎程度、用户数量和市场价值，从而帮助人们了解这些服务在市场上的地位和潜在价值。这对于投资者和创业者来说是一个非常有用的指导工具。
除了以上功能，这个工具还具有其他一些实用的附加功能。比如，它可以提供热门关键词和话题的趋势分析，帮助用户抓住最新热点，并在社交媒体上获得更多关注。此外，它还可以提供一些推广策略和建议，让用户能够更好地利用平台上的资源，提高影响力和知名度。
虽然这个工具非常便捷和实用，但我们也要提醒大家，在使用过程中要遵守各平台的规定和法律法规，确保自己的行为合法合规。此外，要注意保护个人信息和隐私，避免泄露敏感信息给不法分子或第三方。
总的来说，“快手查权重抖音查权重QQ查估值三合一工具查询脚本”是一款非常有用的工具，能够帮助用户快速了解自己在社交媒体平台上的权重和影响力，以及一些网络服务的估值情况。通过合理利用这个工具，我们能够更好地规划自己在社交媒体上的发展策略，并抓住市场机遇。希望这篇文章对您有所帮助，祝您在社交媒体领域取得更大的成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68fc1045f4ee07c19bc27b5ddcc893ef/" rel="bookmark">
			【Qt使用TCP通信】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt使用TCP通信 在Qt中，使用TCP进行网络通信主要涉及以下步骤：
创建QTcpSocket对象：QTcpSocket是Qt中用于处理TCP套接字通信的类。需要创建一个QTcpSocket对象，并将其设置为客户端模式。如果需要建立与服务器的连接，可以使用connectToHost()函数。创建QTcpServer对象：QTcpServer是用于处理TCP服务器通信的类。你需要创建一个QTcpServer对象，并监听指定的端口，等待客户端的连接请求。处理连接请求：当有客户端连接请求时，QTcpServer会创建一个新的QTcpSocket对象，并将其分配给客户端。你可以在QTcpServer的newConnection()信号中处理这个连接请求。读写数据：使用QTcpSocket的read()和write()函数可以进行数据的读写操作。你可以在readyRead()信号的槽函数中读取数据，或在写完数据后调用flush()函数确保数据已经发送出去。处理错误：在使用QTcpSocket和QTcpServer时，需要处理可能出现的错误。你可以通过调用QTcpSocket的error()函数或QTcpServer的acceptError()函数来获取错误信息。 下面是一个简单的示例代码，展示了如何使用Qt中的TCP进行网络通信：
客户端代码：
#include &lt;QTcpSocket&gt; void sendData(QTcpSocket *socket) { socket-&gt;write("Hello server!"); socket-&gt;flush(); } int main(int argc, char *argv[]) { QApplication app(argc, argv); QTcpSocket socket; socket.connectToHost("localhost", 1234); if (socket.waitForConnected()) { qDebug() &lt;&lt; "Connected!"; sendData(&amp;socket); while (socket.waitForReadyRead()) { qDebug() &lt;&lt; "Received: " &lt;&lt; socket.readAll(); } } else { qDebug() &lt;&lt; "Failed to connect to host!"; } return app.exec(); } 服务器端代码：
#include &lt;QTcpServer&gt; #include &lt;QTcpSocket&gt; void handleClient(QTcpSocket *socket) { while (socket-&gt;bytesAvailable() &gt; 0) { qDebug() &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68fc1045f4ee07c19bc27b5ddcc893ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec28131186aac7bdca214c130752c092/" rel="bookmark">
			内网穿透实战应用-如何通过内网穿透实现远程发送个人本地搭建的hMailServer的邮件服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 安装hMailServer2. 设置hMailServer3. 客户端安装添加账号4. 测试发送邮件5. 安装cpolar6. 创建公网地址7. 测试远程发送邮件8. 固定连接公网地址9. 测试固定远程地址发送邮件 hMailServer 是一个邮件服务器,通过它我们可以搭建自己的邮件服务,通过cpolar内网映射工具即可实现远程发送邮件,不需要使用公网服务器,不需要域名,而且邮件账号名称可以自定义.
下面以windows 10系统为环境,介绍使用方法:
1. 安装hMailServer 进入官方下载:https://www.hmailserver.com/download,选择最新版本,下载的时候浏览器可能会提示报毒,点击保留即可
下载好后.打开exe文件进行安装,直接点击Next下一步即可,到了设置密码步骤,我们设置一个密码,然后Next下一步完成安装
2. 设置hMailServer 上面我们安装完成了hMailServer,现在设置邮件名称和添加账号,打开hMailServer,点击connect连接本地的服务
提示输入密码,该密码是我们上面设置的密码,输入后点击ok
进入后,我们首先需添加一个邮件主体名称,点击Add domain
这个名称我们可以随便设置,符合一个域名标准格式即可,如abc.com ,123.com , test.com等,我们这边设置test.com测试使用,设置完成点击sava保存
加下来添加账号,点击Domains,然后点击上面我们设置域名主名称下面的Accounts,进入后点击右侧的Add,添加账号
输入账号名称,和密码,名称我们可以自定义,这里我们创建的账号就是我们的邮箱账号,账号和密码就是我们登录邮箱的账号密码
同样的方式,我们再创建一个,方便测试,两个名称不要重复
设置完成后,我们可以看到列表出现了两个用户,服务端就设置完成了
3. 客户端安装添加账号 上面我们设置好了本地自己的邮件服务,现在我们安装客户端测试,这边安装一个Foxmail客户端进行测试,进入官网下载:https://www.foxmail.com/
下载后安装,安装完成打开Foxmail,我们添加邮箱账号,点击其他邮箱
点击手动设置
在页面上我们输入上面创建的账号和密码,服务器地址填写本机地址:127.0.0.1,其他参数默认,输入完点击创建
添加账号成功后我们在左侧看到了我们自己的账号,添加我们创建的第二个账号,点击左侧菜单下面的账号管理
我们看到有个定时收取邮件的按钮,取消勾选,然后点击新建
同样选择其他邮件—手动设置,输入我们上面创建的第二个邮箱账号的账号密码,点击创建
创建后,我们同样勾选定时收取邮件按钮,点击应用即可,账号添加完成
4. 测试发送邮件 我们上面在Foxmail添加了两个账号,现在测试发送邮件,选中一个账号,点击写邮件
收件人填写我们另一个账号,然后输入邮件内容,点击发送
发送完成后,我们点击页面上面收取邮件,即可看到我们发送的邮件,如果点击一次没有出来,可以等10秒再次点击,本地测试发送邮件完成,下面我们配置远程发送邮件
5. 安装cpolar cpolar官网：https://www.cpolar.com/
Windows系统可以直接在官网下载适用于Windows平台的zip压缩包，解压后得到cpolar安装包，然后双击安装包一路默认安装即可。
6. 创建公网地址 cpolar安装成功后，在浏览器上访问cpolar web UI管理界面（默认为本地9200端口），以【 http://本地ip地址:9200 】形式访问，如http://127.0.0.1:9200/，并使用cpolar账号登录
登录成功后，点击左侧的隧道管理——创建隧道,我们先创建第一个隧道,这个隧道是收邮件隧道：
隧道名称：收邮件协议：选择tcp协议本地地址：110（服务端的收邮件端口）端口类型：随机临时TCP端口地区：China vip 点击创建
创建第二个隧道,发邮件隧道
隧道名称：发邮件协议：选择tcp协议本地地址：25（服务端的发邮件端口）端口类型：随机临时TCP端口地区：China vip 创建成功后,点击左侧仪表盘的状态——在线隧道列表，可以看到刚刚创建成功的两个隧道,一个是发邮件,一个收邮件,中间这个就是对应的公网地址,通过这个地址我们就可以实现两个账号远程发送邮件.
7. 测试远程发送邮件 打开我们Forxmail 邮箱客户端,找到我们添加的账号,右键点击设置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec28131186aac7bdca214c130752c092/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/903254bbacb932e4f4614b5d59f04a58/" rel="bookmark">
			AUTOSAR CAN 通讯栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AUTOSAR 发展历史
AUTOSAR CP
AUTOSAR AP
AUTOSAR通信栈位于运行时环境（RTE）与微控制器抽象层（MCAL）之间，其可以简化ECU间的通信服务，
实现不同类型或速率总线间的数据交互。在AUTOSAR通信栈中，位于服务层的有通信模块(Communication，
Com)，诊断通信管理模块（Diagnositic Communication Manager，Dem）、协议数据单元路由模(Protocol Data Unit Router，PduR），协议数据单元复用模块（I-PDU Multiplexer，IpduM）、总线相关的传输模块（如CanTp，LinTp等）以及通信与网络管理相关的模块；位于ECU抽象层的是与总线相关的接口模块（如CanIf，LinIf等）；位于微控制器抽象层的是与总线相关的驱动模块（如Can，Lin等）
AUTOSAR通讯栈对应用层隐藏了与总线相关的协议和报文的属性，以基本的CAN为例：发送数据机制为
RTE-&gt;COM-&gt;PduR-&gt;Canif-&gt;CANDriver ，过程如下：
Com模块获取应用层的信号，经过封装为I-PDU （Interaction Layer Protocol Data Unit）发送到PduR模块
PduR模块路由协议中所指定的I-PDU目标接收模块，将接收的I-PDU经过处理发送给Canif
Canif将信号以L-PDU（Data Link layer Protocol Data Unit）的形式发送给CAN驱动模块
AUTOSAR CAN 通讯模型
COM模块
Com模块位于RTE与PduR之间，其主要功能有：
① 将信号装载到 I-PDU 中发送，从接收到的 I-PDU 中解析出信号 ② 提供信号路由功能，将接收到的 I-PDU 中的信号打包到发送 I-PDU 中 ③ 通讯发送控制（自动 / 停止 I-PDU 组） ④ 发送请求的应答 每个Com I-PDU 需要设定I-PDU的传输方向（ComIPduDirection）、信号处理方式 ComIPduSignalProcessing、类型 ComIPduSignalRef等
PDUR
PduR模块是主要为通讯接口模块，传输协议模块、诊断通讯服务管理模块以及通讯模块提供I-PDU的路由服务，它在通讯协议中起着承上启下的作用，为上层服务基础软件和应用层屏蔽网络细节，使得上层基础软件模块和应用层不用关心运行于那种总线网络之上。同时，PduR模块提供了基于I-PDU的网关功能，使得不同总线之间的通信成为可能
I-PDU 交互层对应的PDU CANTP层往上的都采用的I-PDU
N-PDU 网络层对应的PDU canif与TP层依赖关系 采用N-PDU
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/903254bbacb932e4f4614b5d59f04a58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0afafbee40178f8f04ec5beaa070c86/" rel="bookmark">
			nginx&#43;php&#43;mysql安装以及环境的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、nginx的安装
二、php的下载安装
1.进入到/usr/local/下，下载php的安装包（php的下载网址）
2.解压
3.进入到php-7.4.6下，安装需要的依赖包
4.预编译php
5.编译
6.配置环境变量
7.为php提供配置文件
8.修改php.ini，设置错误信息级别
9.为php-fpm提供配置文件
10.启动php
11.将php-fpm添加至service服务
12.启动php
三、整合nginx和php-fpm
1.修改nginx的配置文件
2.编辑内容如下
3.创建php文件
4.编辑以下内容
5.编辑虚拟机hosts，能让其访问到www.php.com页面
6.内容如下
7.编辑物理主机的hosts文件
8.编辑内容如下
9.启动nginx和php
10.通过物理机访问php页面，www.php.com
11.至此php+nginx搭建完成
12.关闭php-fpm服务
13.卸载php的命令
四、搭建mysql
1.配置mysql的yum源
2.安装mysql源
3.检查是否安装
4.安装mysql的依赖模块
5.安装mysql
6.启动mysql
7.查看状态
8.修改mysql密码
9.编辑以下内容
10.重启mysql
11.修改密码
12.登陆mysql,输入mysql -uroot -p,之后回车
13.输入：flush privileges 刷新一下
14.设置密码
15.设置远程访问
16.刷新一下数据库
17.退出mysql
18.注释掉/etc/my.cnf
20.重启mysql
21.重新登陆mysql
22.mysql至此成功
五、总结
一、nginx的安装 这个我在前面写过，具体请看：
nginx的下载和配置链接
二、php的下载安装 1.进入到/usr/local/下，下载php的安装包（php的下载网址） cd /usr/local/
wget https://www.php.net/distributions/php-7.4.6.tar.gz
2.解压 tar -zxvf php-7.4.6.tar.gz
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0afafbee40178f8f04ec5beaa070c86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ca42d12c6d2b040d7784c6ebbfd3426/" rel="bookmark">
			git status
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入git status后 显示
one branch master
your branch is ahead of ‘origin/master’by 1 commit(use git push to publish your local commits)
nothing to commit, working tree clean
这个消息告诉你关于你的Git仓库的一些信息：
"one branch master" 表示你当前在名为"master"的分支上。
"your branch is ahead of 'origin/master' by 1 commit" 表示你的本地分支比远程仓库的"origin/master"分支领先1个提交。这意味着你在本地有一个或多个提交，但它们还没有被推送到远程仓库。你可以使用 "git push" 命令将这些本地提交推送到远程仓库。
"nothing to commit, working tree clean" 表示你的工作目录没有未提交的更改，它是干净的，没有需要提交的文件。
如果取消本地commit？
要取消本地的提交（commit），你可以使用 git reset 命令。有不同的选项，取决于你希望如何取消提交：
取消最后一次提交（commit）： 如果你只想取消最后一次提交，但保留本地修改，可以使用以下命令
git reset HEAD~1
这会将HEAD指针移到前一次提交，并且你的更改将保留在工作目录中。
取消提交并删除本地更改： 如果你希望完全取消提交并删除本地的更改，可以使用硬重置（hard reset）：
git reset --hard HEAD~1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ca42d12c6d2b040d7784c6ebbfd3426/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2fd3c86c67fa8dde26bfd67740775e0/" rel="bookmark">
			『好书推荐』｜《Effective软件测试》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介 《Effective软件测试》 是一本由清华大学出版社出版的图书，作者是[荷]毛里西奥·阿尼什（Maurício Aniche），译者是朱少民、李洁、张元。是2023年6月新推出的一本书籍。
Maurício Aniche博士是荷兰代尔夫特理工大学软件工程系的助教，并兼任Adyen公司技术部总监。对这位作者的话，大家可能不是很熟悉 。再看下翻译里面的作者，提起朱少民，我还是有点印象的，他出版过《全称软件测试》一书。
推荐理由 我们先看一下该书的目录大纲：
第1章 有效和系统的软件测试第2章 基于需求规格的测试第3章 结构化测试与代码覆盖第4章 契约式设计第5章 基于属性的测试第6章 测试替身和模拟对象第7章 可测试性设计第8章 测试驱动的开发第9章 编写大型测试第10章 测试代码的质量第11章 全书总结 从上面的目录就可以看出来，《Effective软件测试》是一本涵盖软件测试多个领域的实用指南的书籍，涉及黑盒白盒以及契约测试等方方面面的内容。作者Maurício Aniche博士结合他丰富的开发经验以及多年的测试教育经验，从开发者的视角入手编写了此书，旨在帮助更多的开发和测试人员提高测试效率和质量。本书既面向开发者和测开，也面向整个研发过程中的其他相关人员，因为质量不仅仅是测出来的，更多的是构建出来的。本书以测试金字塔模型中的最底层的单元测试为切入点，系统的讲解了如何设计和执行测试，覆盖领域测试、结构化测试、代码建模等各个方面，以自动化测试为主线，将测试的基本理论和工程思想与自动化思路融会贯通。
总之，《Effective软件测试》是一本全面、系统且透彻的软件测试指南，旨在帮助读者掌握实用的测试方法和技巧，提高测试效率和质量。无论你是初学者还是经验丰富的测试工程师，都可以从这本书中获得有益的启示和指导。
另外，我们要注意的是，本书不针对特定的某一类软件或者特定的技术去进行测试，更多的是教给大家一些通用的测试思想和方法。正所谓只要“思想不滑坡，方法总比困难多”。希望读者能从中汲取的是测试思想，在结合自己当前的项目和公司的架构以及流程，去展开相应的一些思考。
最后，从书中选出几句话送给正在阅读本篇文章的读者：
详尽的测试是不可能的要知道何时停止测试缺陷在某个地方更容易发生测试永远不可能完美或充分 适合读者 这本书旨在帮助开发者深入学习测试知识或提升测试技能。如果你已经有多年的软件开发/测试经验，且曾经从事过大量自动化测试工作，但通常是根据直觉来确定要测试哪些场景，那么本书将为你提供系统性的思考方式。
这本书适合各种专业水平的开发者：
初学者可以通过跟随作者提供的代码示例和技术来学习。经验丰富的开发者可以了解他们可能不太熟悉的技术，并从每章的实际讨论中获取知识。如果你想跟着书本中的案例进行练习和学习，那么需要具备一定的java基础，本书中的案例均为java语言为基础进行编写 作者介绍的测试技术主要针对代码编写者，但专业的软件测试人员，即使将程序视为黑匣子，也可以从本书中获益。需要注意的是，本书的视角主要是站在被测试代码的开发者的角度编写的。
购书直达链接 购书传送门：京东网上商城
为感谢粉丝的长期支持，博主将在朋友圈赠送几本该书籍，详情可关注朋友圈参与活动。没有好友的可以+V（xiaobotester）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47853827369473884a67f8c4878906db/" rel="bookmark">
			狂神Spring学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：Spring Spring: 春天 -&gt; 给软件行业带来了春天2002,首次推出了Spring框架的雏形: interface212004年3月24，发布了1.0正式版Rod Johnson -&gt; Spring framework创始人理念：使现有的技术更加容易使用, 本身是一个大杂烩，整合了现有的技术框架Spring是一个开源的免费的框架(容器），是一个轻量级的、非入侵式的框架控制反转（IOC），面向切面编程（AOP）支持事务的处理，对框架整合的支持 Spring就是一个轻量级的控制反转（IOC）和面向切面免除（AOP）的框架
SSH: Struct2 + Spring + Hibernate
SSM: SpringMvc + Spring + MyBatis
pom.xml 依赖
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 二：IOC （一）理论推导 1.UserDao 接口
2.UserDaoImpl 实现类
3.UserService 业务接口
4.UserServiceImpl 业务实现类
在我们之前的业务中，用户的需求可能会影响原来的代码，我们需要根据用户的需求去修改源代码。如果程序代码量十分大，修改一次的成本代价十分昂贵。
使用一个set接口实现,已经发生了革命性的变化。
private UserDao userDao; // 利用set实现动态实现值的注入 public void setUserDao(UserDao userDao) { this.userDao = userDao; } 之前，程序是主动创建对象，控制权在程序员手上使用set注入后，程序不在具有主动性，而是变成了被动的接受对象 思想的差距不是在短期内能够弥补的
这种思想，从本质上解决了问题，程序员不用再去管理对象的创建了。系统的耦合性大大降低，可以更加专注在业务的实现上,这是IOC的原型
程序完全不用动，修改配置xml文件中进行修改，对象由Spring来创建、管理、装配
beans.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47853827369473884a67f8c4878906db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23bdeac2c9616f9bb068cb0c34a697c1/" rel="bookmark">
			关于使用IDEA与Maven创建web工程步骤：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b35f05933c58c9afc54e5e22e1ae1119/" rel="bookmark">
			关于Maven中使用idea发布java项目的步骤：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.新建Maven模块：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41197d3daa3d87ec0f863029d595d36f/" rel="bookmark">
			Weex开发中，实现Vue组件导入Android原生控件，实现Android控件与vue组件的相互通信，以及通信回调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue组件导入原生组件的流程 创建原生组件 需继承WXComponent&lt;原生组件类&gt;，重写initComponentHostView()方法 public class AndroidText extends WXComponent&lt;TextView&gt; { public AndroidText(WXSDKInstance instance, WXVContainer parent, BasicComponentData basicComponentData) { super(instance, parent, basicComponentData); } // 在init方法中提供控件的实例对象 @Override protected TextView initComponentHostView(@NonNull Context context) { TextView textView = new TextView(context); textView.setTextSize(20); return textView; } // 自定义Vue组件中的属性，但Vue组件属性修改时，会回调这个方法进行处理 @WXComponentProp(name = "androidTextColor") public void setAndroidTextColor(String colorText) { getHostView().setText(colorText); getHostView().setTextColor(Color.parseColor(colorText)); } // 自定义Vue组件持有实例时，可调用的方法 @JSMethod public void setSimpleText(String value) { getHostView().setText(value); } } 在application中注册原生组件，说明组件名，和组件类型。 WXSDKEngine.registerComponent("androidText", AndroidText::class.java) 在Vue组建中使用 &lt;template&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41197d3daa3d87ec0f863029d595d36f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/874326c155511e15e0ac16551bbebb8a/" rel="bookmark">
			mac 安装java1.8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载jdk1.8 https://www.oracle.com/java/technologies/downloads/#java8-mac 2、 安装jdk1.8 一路默认，安装后的位置在这儿。
/Library/Java/JavaVirtualMachines/jdk-1.8.jdk
3、配置环境 打开终端，输入命令
sudo vim /etc/profile 添加以下配置。按i进行编辑，按esc退出编辑，按:wq保存并退出。
export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-1.8.jdk/Contents/Home export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 输入命令
source /etc/profile 4、检验 分别输入java -version、javac、echo $JAVA_HOME
java -verson // 返回 java version "1.8.0_381" Java(TM) SE Runtime Environment (build 1.8.0_381-b09) Java HotSpot(TM) 64-Bit Server VM (build 25.381-b09, mixed mode) javac // 返回 用法: javac &lt;options&gt; &lt;source files&gt; 其中, 可能的选项包括: -g 生成所有调试信息 -g:none 不生成任何调试信息 -g:{lines,vars,source} 只生成某些调试信息 -nowarn 不生成任何警告 -verbose 输出有关编译器正在执行的操作的消息 -deprecation 输出使用已过时的 API 的源位置 -classpath &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -cp &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -sourcepath &lt;路径&gt; 指定查找输入源文件的位置 -bootclasspath &lt;路径&gt; 覆盖引导类文件的位置 -extdirs &lt;目录&gt; 覆盖所安装扩展的位置 -endorseddirs &lt;目录&gt; 覆盖签名的标准路径的位置 -proc:{none,only} 控制是否执行注释处理和/或编译。 -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/874326c155511e15e0ac16551bbebb8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25f5aaace7bbd03a681a524049ebc7bc/" rel="bookmark">
			苹果电脑同时使用内外网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司用的有线的内网，自己要用无线的外网。插上网线就不能用wifi，很烦。于是学到了一种插上网线也能使用wifi的方法。
第一步，调整wifi和网线的顺序 系统偏好设置-网络-左下角设定服务顺序，把wifi调到有线网络前面。
第二步，设置本地静态路由，添加内网网段指向对应内网的网关 查看有线网络的子网掩码和路由器
由于我这里只访问一个内网网址，如
10.10.10.10/aaa/bbb/ccc.csp 记住这个网址的IP
10.10.10.10 输入以下命令，把子网掩码、路由器IP写到最后。这样就设置了本地静态路由。
sudo route add -net 10.10.10.10 -netmask 255.255.254.0 20.4.74.1 第三步，配置内网域名和内网DNS解析 vim /etc/hosts 进去会发现这个文件是只读的，需要授权。
chmod -R /etc/hosts 然后再在文件中添加
10.10.10.10 aaa.bbb.com 后面这个aaa.bbb.com是随便写的。
然后就能同时访问内外网了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87b0ba8a500d4c80cd6200961e963ad3/" rel="bookmark">
			手把手教学画ER图（案例学习）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是ER图 ER图（Entity-Relationship Diagram）是一种用于数据建模的工具，它展示了一个系统中各种数据实体之间的关系。ER图通常由实体（Entity）、属性（Attribute）和关系（Relationship）三部分组成。实体描述了系统中的对象，属性描述了实体的特征，关系描述实体之间的联系。ER图是一种图形化的表示方法，有利于团队成员之间的统一理解和沟通，有助于快速设计出一个系统的数据模型。
核心元素 ER图中有以下几个元素：
实体（Entity）：表示现实世界中的一个对象或实体，例如学生、课程、商品等。在ER图中，实体用矩形框表示，框内写上实体的名称。
属性（Attribute）：表示实体的性质或特征，例如学生的姓名、年龄、性别等。在ER图中，属性用椭圆形表示，连在对应的实体上。
关系（Relationship）：表示实体之间的联系，可以是一对一、一对多或多对多关系。在ER图中，关系用菱形表示，菱形上标明关系类型，例如“购买”、“选修”等。
在ER图中，以上几个元素可以组合起来表示系统的各种数据模型，它们之间的连接关系也可以用箭头表示。总之，ER图是一个非常直观、有效的数据建模工具，有助于开发人员理解系统需求并设计出适合的数据库结构。
图形学习 正方形:实体 ER图中的正方形通常代表实体（Entity）。实体是系统中的一个对象或实体，可以是人、物、地点、组织等等。在ER图中，每个实体通常用一个矩形表示，矩形内写上实体的名称。实体通常具有属性（Attribute），也就是实体的特征或属性，例如学生的姓名、年龄、性别等。
椭圆形：属性 属性通常用椭圆形表示，连在对应实体的边上。ER图中的实体和属性是设计数据库结构时必不可少的，因为它们提供了存储和操作数据所需的信息和结构。
棱形：关系 在ER图中，实体之间的关系，以棱形画线关联。
案例学习 学生-老师的案例学习
商场商品案例ER图
关于画ER图不要有什么畏难情绪，先梳理系统的实体，再根据实体找属性，再找实体与实体的关系即可画出对应的项目ER图！
一定要动手动手，画错了，谁说错了会告诉你，你再修改即可，熟能生巧！
希望这篇文章对大家有帮助，点赞关注支持一波！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/635a190f0e86f2a686ddeaa44647a1b7/" rel="bookmark">
			MegaCli创建Raid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、删除Raid配置
(1)查看阵列卡号（适配器编号|Raid卡编号）
/opt/MegaRAID/MegaCli/MegaCli64 -PDList -aALL | grep "Adapter" 1.只有一块Raid卡
(2)查看逻辑盘由哪些物理盘组成、Raid等级多少
/opt/MegaRAID/MegaCli/MegaCli64 -LdPdInfo -aALL | egrep "Target Id|RAID Level|Slot Number|Size " 1.有两块逻辑盘，Raid等级为raid1；
2.分别由Slot0&amp;1组成的L0以及由Slot2&amp;3组成的L1两个逻辑盘。
(3)删除对应的逻辑盘
/opt/MegaRAID/MegaCli/MegaCli64 -cfglddel -L1(Target Id：1) -a0(Adapter #0 —— Raid卡编号) 二、添加Raid配置
(1)查看Raid卡ID号
(2)查看物理盘插槽号
(3)查看Raid卡编号
(4)创建Raid0
-r :指定raid类型（例如：raid10，-r10）
WB ：缓存策略
Direct：缓存策略
[32:1]：指定要操作的硬盘。如要对多个硬盘操作，用逗号“，"隔开,[32:0,32,1]
/opt/MegaRAID/MegaCli/MegaCli64 -CfgLdAdd -r0[32:2,32:3] WB Direct -a0 (5)查看初始化进度
/opt/MegaRAID/MegaCli/MegaCli64 -LDInit -ProgDsply -LALL -aALL (6)检查结果（逻辑盘raid类型）
/opt/MegaRAID/MegaCli/MegaCli64 -LdPdInfo -aALL | egrep "Target Id|RAID Level|Slot Number" MegaCli64 raid对应关系
RAID Level : Primary-0, Secondary-0, RAID Level Qualifier-0 RAID 0 条带化存储 利用率100%
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/635a190f0e86f2a686ddeaa44647a1b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63055430578bbdd5d50542c164a69f57/" rel="bookmark">
			第一章：绪论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.1 系统架构概述 架构是体现在组件中的一个系统的基本组织、它们彼此的关系与环境的关系以及指导它的设计和发展的原则。
系统是组织起来完成某一特定功能火一组功能的组件集。系统这个术语包括了单独的应用程序、传统意义上的系统、子系统、系统之系统、产品线、整个企业及感兴趣的其他集合。系统用于完成其环境中的一个或多个任务。
环境或上下文决定了对这个系统的开发、运作、政策以及会对系统造成其他影响的环境和设置。
任务是由一个或多个利益相关者通过系统达到一些目标的系统的一个用途或操作。
通俗的说，系统架构是系统的一种整体的高层次的结构表示，是系统的骨架和根基，支撑和链接各个部分，包括组件、连接件、约束规范以及指导这些内容设计与演化的原理。系统架构设计的目的是对需要开发的系统进行一系列相关的抽象，用于指导系统各个方面的设计与实现，架构设计在系统开发过程中起着关键性作用，架构设计的优劣决定了系统的健壮性和生命周期的长短。
多年来架构的概念经过不断地演化，目前已形成了不同用途的架构模式，比较典型的架构模型包括分层架构、事件驱动架构、微核架构、微服务架构和云架构等5类。
分层架构 分层架构是最常见的架构，也是事实上的标准结构。这种架构降软件分为若干个水平层，每一层都有清晰的角色和分工，且不需要其他层的细节。层与层之间通过接口进行通信。
表现层：用户界面，负责视觉和用户互动；业务层：实现业务逻辑；持久层：提供数据，存储SQL语句；数据库：保存数据。 事件驱动架构 事件是状态发生变化时软件发出的通知，事件驱动架构是通过事件进行通信的软件架构，它分为以下四个部分：
事件队列：接收事件的入口；分发器：将不同的事件分发到不同的业务逻辑单元；事件通道：分发器与处理器之间的联系渠道；事件处理器：实现业务逻辑，处理完成后会发出事件，触发下一步操作。 微核架构 微核架构也称为插件架构，是指软件的内核相对较小，主要功能和业务逻辑都通过插件实现。内核通常只包含系统允许的最小功能，而插件则是互相独立的，插件之间的通信应该减少到最低，避免出现互相依赖的问题。
微服务架构 微服务架构是服务导向架构的升级，每一个服务都是一个独立的部署单元，这些单元都是分布式且互相解耦的，彼此之间通过远程通信协议联系。
微服务分为三种实现模式：
RESTful API模式：服务通过API提供；RESTful应用模式：服务通过传统的网络协议或应用协议提供，背后通常是一个多功能的应用程序，常见于企业内部；集中消息模式：采用消息代理可以实现消息队列、负载均衡、统一日志和异常处理，缺点是会出现单点失败，消息代理需要做成集群。 云架构 云架构主要解决扩展性和并发的问题，是最容易扩展的架构。它的高扩展性体现在将数据都复制到内存中，变成可复制的内存数据单元，然后将业务处理能力封装成一个个的处理单元。如果访问量增加，则新建处理单元；如果访问量减少，则关闭处理单元。
云架构主要分层两部分：处理单元和虚拟中间件。
处理单元：主要负责实现业务逻辑；虚拟中间件：负责通信、保持会话控制、数据复制、分布式处理和处理单元的部署。 其中虚拟中间件又包含以下四个组件：
消息中间件：主要用于管理用户请求和会话控制，当一个请求进来，由消息中间件决定分配给哪一个处理单元；数据中间件：将数据复制到每一个处理单元，即数据同步，保证每个处理单元都得到相同的数据；处理中间件：可选，如果一个请求涉及不同类型的处理单元，改中间件负责协调处理单元；部署中间件：负责处理单元的启动和关闭，监控负载和响应时间，当负载增加，就新启动处理单元；当负载减少，就关闭处理单元。 1.2 系统架构设计师概述 架构设计师是系统开发的主体角色，他们通过执行一系列的活动来实施架构设计。架构设计通过生成过程形成最终的产品架构，架构设计师的成功是创建架构。
架构设计师是负责系统架构的人，是系统或产品线的设计责任人，是一个负责理解和管理并最终确认和评估非功能性系统需求（如软件的可维护性、性能、复用性、可靠性等），给出开发规范，搭建系统实现的核心架构，对整个软件架构、关键构件和接口进行总体设计兵澄清关键技术细节的高级技术人员。
架构设计师在项目中的主要任务刻概述如下：
领导与协调整个项目中的技术活动，如分析、设计和实施等；推动主要的技术决策ing最终表达为系统架构；确定系统架构，并促使其架构设计的文档化，包括需求、设计、实施和部署等视图。 一个优秀的架构设计师通常可以做到在软件开发知识和业务领域知识之间的平衡，因此架构设计师应该具备以下专业知识：
掌握业务领域的知识；掌握技术领域的知识；掌握设计技能；具备编程能力；具备沟通能力；具备决策能力；知道组织策略。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d4ff6e902a80db13d84f72a2b2eacf9/" rel="bookmark">
			Audacity基本使用操作（一只鱼er~）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载并安装AudaacityAudacity ® | Free, open source, cross-platform audio software for multi-track recording and editing. (audacityteam.org)https://www.audacityteam.org/
安装FFmpeg Download FFmpeghttps://ffmpeg.org/download.html
录制语音和麦克风 1、连接麦克风 通过将麦克风插入适当的端口来连接麦克风。
如果有 USB 麦克风，将其插入 USB 端口。
如果麦克风带有 3.5 毫米插孔，将其插入麦克风输入端口。
如果有 XLR 麦克风，将其插入 XLR-USB 音频接口，然后将接口插入 USB 端口。
确切的详细信息取决于确切计算机型号和麦克风型号。
注意：许多笔记本电脑和笔记本电脑都配备了内置麦克风。虽然它们可能足以将声音录制到可理解的标准，但它们产生的录音往往听起来效果较差。
2. 选择麦克风 从“音频设置”工具栏的可用录音设备列表中选择要录制的麦克风
使用“音频设置”工具栏来选择是用单声道还是立体声录制。
注意：大多数麦克风都是单声道，单声道通常是录音的最佳选择。仅当确实需要方向性时才使用立体声。
3. 测试设置 尝试用正常的音量说话。通常，音量应始终保持在绿色区域（通常，最好在-18和-12 dB之间）。
注意：如果输入音量太低（低于 -42 dB）或过高（通常在红色区域），音频质量可能会受到影响
接下来，进行测试记录。要开始在Audacity中录制声音，只需按红色录制按钮。
录制完成后，通过回听。如果一切顺利，现在应该可以清楚地听到自己的声音。
编辑音频 导入文件 要开始编辑，需要某种声音进行编辑。可以录制一段声音，或者通过将现有声音文件（例如 MP3 或 WAV）拖放到项目窗口中来导入该文件。
即可看到声音波形图：
此波形是歌曲的波形图。蓝色“斑点”越大，部分越响亮。单独的线条（“尖峰”）表示突然和短促的响亮部分，例如咔嗒声、啪啪声、拍手声和鼓声。
删除歌曲的各个部分 要删除音频文件的某个部分，请先通过单击并拖动波形来选择该部分。
选择后，按“del”（删除）键或“backspace”(退格）键将其删除。
音频的移动部分（剪辑） 可以单击剪辑手柄栏上的 + 拖动以移动剪辑。
拆分剪辑 将剪辑拆分为两个独立的剪辑
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d4ff6e902a80db13d84f72a2b2eacf9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/96/">«</a>
	<span class="pagination__item pagination__item--current">97/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/98/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>