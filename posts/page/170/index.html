<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4f3e08b712014d67a1f17a0f876c2a2/" rel="bookmark">
			VSCode 配置 C&#43;&#43; 环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开学了，后面更新速度会更慢，望周知。
接上回: https://blog.csdn.net/orangebench11/article/details/126111356
先说一下, 这个教程不是给完整json复制粘贴, 是要跟教程配置 (放心, 大部分配置都很简单)。
安装VSCode 官网: Visual Studio Code - Code Editing. Redefined
我建议是点 Other downloads 去下 System Installer , 所有用户都可以使用，还可以改安装目录到 D 盘，缺点就是要管理员权限。
同意, 选目录就不说了, 然后这两个建议勾上, 点安装就行了。
扩展 点 安装并重启 。
点 Install , 重启 VSCode 。
如果没弹出的话, 左边找到 Extensions , 点击,
(左边 洛谷 栏和 Github 栏都是扩展)
第一个点 Install , 重启 VSCode 。
然后就变成中文了, 左边找到 插件 , 点击, 搜索 C/C++。
别忘了安装。(颜色变了是改的主题)
开始配置 点打开文件夹, 找个后面放代码的文件夹。
点信任。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4f3e08b712014d67a1f17a0f876c2a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/412c153f702a5ebe742daad595e3974b/" rel="bookmark">
			vue 组件 echarts跳转总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.组件传参：
（1）父组件P 向子组件 C传参，父组件将要传递的参数放在属性中，子组件用props接收，总体包括三步
P 中引用 C
P 中注册 C P 将要传递的参数放在属性中 ，C使用props接收
（2） 子组件向父组件传参，用到了$emit
具体链接：
Vue组件之间如何传参 - 小菜鸟TY - 博客园
echarts组件参数：横纵坐标数据 video组件：视频url或者url列表 时间跳转
2.Echarts 点击跳转
// 处理点击事件并且跳转到相应的百度搜索页面 myChart.on('click', function (params) { window.open('https://www.baidu.com/s?wd=' + encodeURIComponent(params.name)); }); //区分鼠标点击到了哪里 myChart.on('click', function (params) { if (params.componentType === 'markPoint') { // 点击到了 markPoint 上 if (params.seriesIndex === 5) { // 点击到了 index 为 5 的 series 的 markPoint 上。 } } else if (params.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/412c153f702a5ebe742daad595e3974b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b39eb690cb251bf81c22a86eeee43852/" rel="bookmark">
			基于SSM框架实现一个用户系统（登录，用户列表，分页，增删改查，用户角色管理功能）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先搭建一个Maven工程，配置好Tomcat，mybatis等
数据库 tb_role
tb_user
user_role(这里只给了第一个用户管理员限权，可以对其他用户添加管理员，必须要用第一个用户登录)
bean 这三个就不用多说了，直接按照数据库字段的打。
为了实现分页功能，我们需要引入一个类叫PageInfo，代码如下
package com.zhongruan.bean; import java.util.List; public class PageInfo&lt;T&gt; { private List&lt;T&gt; list; private int totalPage; private int size; private int totalCount; private int currentPage; public List&lt;T&gt; getList() { return list; } public void setList(List&lt;T&gt; list) { this.list = list; } public int getTotalPage() { return totalPage; } public void setTotalPage(int totalPage) { this.totalPage = totalPage; } public int getSize() { return size; } public void setSize(int size) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b39eb690cb251bf81c22a86eeee43852/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acf14130882b1e8f9994f9b42d06482c/" rel="bookmark">
			【BUG记录】谷粒商城微博登录重定向地址不匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误码：21322 &lt;a href="https://api.weibo.com/oauth2/authorize?client_id=YOUR APPCODE &amp;response_type=code &amp;redirect_uri=http://auth.taotaolovexuanxuan.com/oauth2.0/weibo/success"&gt;&lt;/a&gt; 尝试过将redirect_url编码方法，无效 玄学解决方法： 点击其他产品创建网页应用，生成对应的App Key ,App Secret,设置授权回调地址和取消授权回调地址
成功跳转实现登录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d33a04cc0e7a6ac414406d92369d2c84/" rel="bookmark">
			Gitlab runner安装和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Runner 分为"指定Runner "和"共享Runner "，共享Runner 适用于所有群组和项目，根据tags标签来匹配并执行（Runner 的标签和.gitlab-ci.yml文件任务里的标签）；指定Runner是项目独享的，可以为某个项目单独配置Runner。以下配置的是共享Runner，指定Runner的配置方式一样，只是Token获取的地方不同。
1、下载地址：https://mirrors.tuna.tsinghua.edu.cn/gitlab-runner/yum/el7/
2、安装
wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-runner/yum/el7/gitlab-runner-15.8.1-1.x86_64.rpm yum -y install gitlab-runner-15.8.1-1.x86_64.rpm #查看运行状态 systemctl status gitlab-runner 3、注册到GitLab
3.1 查看GitLab的runner token 图中Show Runner installation instructions按钮也有安装和注册gitlab Runner的步骤 3.2 执行注册命令
gitlab-runner register --url http://192.168.48.128:8001/ --registration-token _sRaUvmhkgzdbLXJ9Gy1 最后的执行器我选择的是shell，常用的还有docker和kubernetes(k8s)
可以在gitlab后台看到刚才注册的runner：
前面没有输入好的，可以在这里进行修改：
tags选项与.gitlab-ci.yml中的tags对应，多个以逗号分隔。
在某个项目里可以看到共享Runner：
4、创建和执行一个流水线
4.1 在项目根目录下面创建文件，并提交：.gitlab-ci.yml stages: - build - deploy #当master分支变更的时候触发 build: stage: build script: #需要执行的脚本内容，也可以是一个sh脚本文件用于执行。 - echo "hello world build" only: - master tags: - trade_runner #这个标签需要与Runner配置的标签匹配 deploy: stage: deploy script: - echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d33a04cc0e7a6ac414406d92369d2c84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d9a1cb4548116f317e1862b9b9c2044/" rel="bookmark">
			[DiceCTF 2023] rSabin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一点点学习别人的WP，这回看到一个大姥(r3kapig)的帖子，DiceCTF第二名，不过有好多东西一时还理解不了，得慢慢来。
题目 这个题有3个功能：
rsa加密功能，p,q,N未知，e=17低加密指数
解密，不过解密方法比较特别，分别对p,q求nth_root不过未给出nth_root函数，所以不能直接使用。
对flag加密，用PKCS1_OAEP填充。多数情况下低加密指数如果明文比较小会导致加密后比N小或者仅比N大一点，可以通过开根号爆破。但填充后长度基本与N长度一致，爆破无效。
import asyncio import traceback from Crypto.Util.number import getPrime, bytes_to_long from Crypto.Cipher import PKCS1_OAEP from Crypto.PublicKey import RSA from nth_root import nth_root, chinese_remainder # not provided class Server: def __init__(self): e = 17 nbits = 512 p = getPrime(nbits) q = getPrime(nbits) N = p * q self.p = p self.q = q self.N = N self.e = e def encrypt(self, m): assert 0 &lt;= m &lt; self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d9a1cb4548116f317e1862b9b9c2044/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/667e517f848c1f5523fc0fd09adde8af/" rel="bookmark">
			机器视觉——OpenCV案例分析基础（七）（边缘检测和图像轮廓查找）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		边缘检测和图像轮廓查找 一、理论分析二、代码分析2.1 边缘检测2.1.1 Sobel算子2.1.2 Scharr算子2.1.3 Laplacian算子2.1.4 Canny算子去噪梯度非极大值抑制滞后阈值 2.2 特征检测 三、代码文件 一、理论分析 图像的边缘信息通俗来讲变化较大。基于此特征和数字图像的离散信号，我们可以计算图片的差分或梯度。
图像处理中有多种边缘检测的算电子，包括普通一阶差分，Sobel算子，Scharr算子等等，是基于寻找梯度强度。而普通二阶差分中，Laplacian算子其思想是基于过零点检测。
二、代码分析 2.1 边缘检测 2.1.1 Sobel算子 对每一个像素点px，用有右减左侧的特征值。因为对于边缘特征来说，px的值较大。那么值越大的说明其越有可能是边缘特征。
如下图所示，表示计算图像的水平特征。右侧减去左侧数值。
from cv2 import cv2 as cv import numpy as np img = cv.imread(r"./CV-Pictures/sobel.bmp",0) cv.imshow("img",img) sobel_x = cv.Sobel(img,-1,1,0) #-1处理结果代表与原图一致，1代表x，0代表y cv.imshow("sobel_x",sobel_x) cv.waitKey(0) cv.destroyAllWindows() 结果如下，可以看到图像边缘x轴方向，采集只有右侧，因为sobel算法是，右侧减去左侧。那么左侧的点就被算为负值，直接被赋值为0，所以要对处理结果，取绝对值。让负值变为正值。
那么修改代码为：
from cv2 import cv2 as cv import numpy as np img = cv.imread(r"./CV-Pictures/sobel.bmp",0) cv.imshow("img",img) sobel_x = cv.Sobel(img,-1,1,0) sobel_x = cv.convertScaleAbs(sobel_x) cv.imshow("sobel_x",sobel_x) cv.waitKey(0) cv.destroyAllWindows() 代码运行结果如下：
可以看到还是如此，为什么呢？因为Sobel函数默认采用np.uint8数据类型，也就是说没有负值。都自动取0了。所以我们一般不用-1，而用cv.CV_64F
from cv2 import cv2 as cv import numpy as np img = cv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/667e517f848c1f5523fc0fd09adde8af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22ad4269f01a203fb7a3bbd0ca17376d/" rel="bookmark">
			python中items()用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 items() 是 Python 中字典 (dictionary) 内置函数，用于返回字典中所有键值对 (key-value) 的元组列表。
使用方法：
dict.items() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/361e67f547d02ef23120a5be88ac51d0/" rel="bookmark">
			pycharm设置代理访问服务器并解决Pycharm进入debug模式后一直显示collecting data
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pycharm设置代理访问服务器并解决Pycharm进入debug模式后一直显示collecting data 背景
之前一直用pycharm通过ssh链接linux服务器，但是为了安全，工作人员在服务器上加了防火墙，直接连连不上了，需要代理（http proxy）才能连。
所以，用pycharm时，先设http proxy，再设ssh，就能正常链接服务器了。
选用最新版本的pycharm
这点很重要，一定要用新版本的pycharm，新版的pycharm才有设置代理proxy的功能，旧版本没有。在这一点上面卡了很久。
顺便放一下激活pycharm的方法
https://www.bilibili.com/read/cv18039509 打开设置 点击file，再点击setting
设置http proxy 在设置 窗口输入http proxy并搜索，点击HTTP Proxy，点击Manual proxy configuration，点击HTTP，输入相应的配置信息，点击apply。
其中，host name是代理的地址，port number是代理地址的端口号，proxy authentication是代理的账号密码。
设置SSH
在设置 窗口输入ssh并搜索，点击左侧SSH Configurations，点击加号，输入相应的配置信息。点击HTTP/SOCKS Proxy设置代理，如果使用Use global IDE proxy settings，就打勾，就是用刚才配置好的全局代理；如果不使用全局代理，就直接在这里填写代理信息就好了。点击apply。
设置interpreter 点击右下角选择on ssh，点击add new interpreter，点击existing，选择刚才配置好的ssh。
Pycharm进入debug模式后一直显示collecting data的解决办法 debug调式代码的时候，一直显示collecting data
设置-----&gt;搜python debugger----&gt;勾选Gevent compatible-------&gt;点击apply
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be9b3b78df49c83dbe0ed7c7969b8afa/" rel="bookmark">
			ImportError: /lib64/libm.so.6: version `GLIBC_2.23‘ not found问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.环境：Centos7，GCC version 9.1.0，python3.7，TensorFlow1.14.0. 因为/usr/lib64/libstdc++.so.6: version `CXXABI_1.3.8' not found问题，我将GCC版本升级到了9.1.0，但是运行TensorFlow的时候出现了ImportError: /lib64/libm.so.6: version `GLIBC_2.23' not found问题。
GitHub有个降低python版本为3.6.8的解决方案，没有试过，链接在这：https://github.com/tensorflow/tensorflow/issues/28660
解决方案：先升级make，再升级GLIB版本为2.3.0
2.升级make 下载最新的make安装包
wget http://ftp.gnu.org/pub/gnu/make/make-4.3.tar.gz make配置
tar -zxvf make-4.3.tar.gz cd make-4.3 ./configure --prefix=/usr 编译安装
type make make check make install 检查make版本
make -v 3.升级GLIBC版本 查看版本：ldd --version
下载安装包，这里我下载的是2.30版本
glibc的下载链接：http://mirrors.nju.edu.cn/gnu/libc/
wget http://ftp.gnu.org/gnu/glibc/glibc-2.30.tar.gz 解压配置
tar -zxvf glibc-2.30.tar.gz mkdir build cd build # 配置 ../glibc-2.30/configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin 运行配置命令可能出现下面提示，告诉你某个版本太老了，那么更新即可
*** These critical programs are missing or too old: bison
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be9b3b78df49c83dbe0ed7c7969b8afa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9f8cc6d529a08d185b4a6919d67f12b/" rel="bookmark">
			五、多表连接查询——对分组结果进行过滤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五、多表连接查询——对分组结果进行过滤 1.什么是对分组结果进行过滤？ 我们在对数据进行分组之后，得到了一张表，但是表内的数据如果不全是我们想要的，那该怎么办呢？数据过滤可以使用where关键字，但是这个where关键字的动作发生在数据分组汇总之前，此时如果想要对分组汇总之后的数据进行过滤的话，必须使用having关键字【在此处相当于where关键字的作用，但是where发生在数据分组汇总前，having发生在数据分组汇总后】。
2.示例: (1)示例1
将分组汇总后的成绩高于80分的班级取出。
select class,avg(score) as avg_score from grade_score group by class having avg_score&gt;60; select class,avg(score) as avg_score from grade_score group by class having avg_score&gt;80; (2)示例2
将成绩大于80的同学进行分组统计平均分数并且取出平均成绩大于88分的班级与成绩。
第一层过滤where：过滤掉低于80分的同学的成绩。
第二层过滤having：对最终结果过滤掉低于88分的班级。
select class,avg(score) as avg_score from grade_score where score&gt;80 group by class having avg_score&gt;88; 3.where和having的比较 where子句having不能使用聚合函数可以使用聚合函数group by分组汇总之前的过滤操作group by分组汇总之后的过滤操作限制的行数据限制的是分的组 4.MySQL的执行顺序 (1)一个完整的MySQL语法
select [列名/聚合函数(列名)] from 表名1,表名2,...[可以使用内连接或者外连接] where [分组前过滤条件] group by [分组列] having [分组后过滤条件] order by [列(排序条件)]; (2)示例
select class,sum(score) as total_score from grade_score where score&gt;80 group by class having total_score&gt;300 order by total_score desc; 执行顺序：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9f8cc6d529a08d185b4a6919d67f12b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b484a7126f8cb80ba79975a36f272af/" rel="bookmark">
			一维数组（数组）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组 例题：输入n个学生的成绩，求他们的平均成绩，并求出成绩大于平均分的人数 先考虑求平均成绩，代码怎么写？ #include &lt;cstdio&gt; int main() { int n, score, sumn = 0; double aver; scanf("%d", &amp;n); for (int i = 0; i &lt; n; ++i) { //边读边累加求和 scanf("%d", &amp;score); sumn += score; } aver = (double)sumn / n; } 数组的基础代码就是这样的； #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ int n,i,a[100];//n代表的是输入的个数 //i用于for()循环 //a[100]就是数组 scanf("%d",&amp;n);//输入n（n代表要输入n个数） for(i=1;i&lt;=n;i++){//输入范围 scanf("%d",&amp;a[i]);//for()循环输入 } printf("%d",a[n]);//输出第n个数组 return 0; } 数组的概念 数组是连续存储数据的集合。
组成数组的每个数据称为数组的元素数组的每个元素都属于同一种数据类型
一个数组的所有元素在内存中的存储位置是连续的！
定义 int a[10]; //定义能存储10个整形变量的数组，下标是:0~9 char c[100];//定义能存储100个字符变量的数组，下标是:0~99 double f[5];//定义能存储5个双精度实数变量的数组，下标是:0~4 数组的初始化 数组的初始化可以在定义时一并完成，有多种形式： 顺序指定全部元素的初始值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b484a7126f8cb80ba79975a36f272af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e0210768c948bba885ba37672db3c2a/" rel="bookmark">
			基于Matlab的有限元网格自动生成算法 | Q4、Q8、Abaqus单元网格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日给大家带来的主要内容是二维问题下四边形单元有限元网格如何自动生成？
单元网格的形成实际上属于有限元计算中的前处理部分，即确定单元节点信息，当模型较为复杂时，用户可在Abaqus、Ansys等大型商业有限元软件中进行建模，导出网格信息。
当模型较为简单时，如二维平面板模型，用户可基于一些较为基础的网格生成算法，在自己的程序中通过控制模型长、宽等信息，即可生成有限元网格。
看似应用有限，但是在一些比较复杂的领域内，往往需要先在简单的模型中得到理论验证，如此以来，有利于自编程代码的完整性，即前处理、内核计算、后处理于一体。
本篇推文，木木就带着大家学习一下Q4、Q8单元网格的自动生成以及Abaqus网格节点顺序解读。
代码获取： 基于Matlab的有限元网格自动生成算法 | Q4、Q8、Abaqus单元网格
Q4单元网格 单元自动网格划分 如下图所示，为4节点四边形单元网格生成示意图，图中NXE和NYE分别是模型横向和纵向单元个数，dhx和dhy分别是单元的横向、纵向长度。
单元自动网格划分
平面板模型被划分为若干个小矩形区域，共有4个节点，分别是 、、、，一个矩形中是1个四边形单元。
该模型总的单元数目和节点数目分别为 ， 。
网格生成算法代码（纵向排序）
global nnd nel nne nodof eldof n global geom connec dee nf Nodal_loads global Length Width NXE NYE X_origin Y_origin dhx dhy % % nnd = 0; k = 0; % 纵向排序 for i = 1:NXE for j=1:NYE k = k + 1; n1 = j + (i-1)*(NYE + 1); geom(n1,:) = [(i-1)*dhx - X_origin (j-1)*dhy - Y_origin ]; n2 = j + i*(NYE+1); geom(n2,:) = [i*dhx - X_origin (j-1)*dhy - Y_origin ]; n3 = n1 + 1; geom(n3,:) = [(i-1)*dhx - X_origin j*dhy - Y_origin ]; n4 = n2 + 1; geom(n4,:) = [i*dhx- X_origin j*dhy - Y_origin ]; nel = k; connec(nel,:) = [n1 n2 n4 n3]; nnd = n4; end end 代码解读
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e0210768c948bba885ba37672db3c2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72343d6dc373438d8e0ce5042cc9cf7f/" rel="bookmark">
			Git上传项目到gitee(码云)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提前安装好git，自行在码云上注册登录连接本地密钥。
创建远程仓库
先在码云上创建一个仓库，看图：
创建本地仓库
(1.).新建一个空白文件夹当本地仓库，然后打开文件夹，在空白处单击右键选择 Git Bash Here 如图：
(2).在命令行中输入 git init 创建一个本地代码仓库（即初始化）
git init 放入要上传的项目文件
将要上传的文件或文件夹放入新建的文件夹中（不能放空的文件夹，否则无法上传），初始化后的文件夹中就会多出一个.git文件夹，不用动这个文件夹
将文件提交到缓存区
接着在命令行中输入git add . //提交所有文件到缓存区
git add . 将文件提交到本地仓库
然后继续在命令行中输入git commit -m '说明' 提交到本地仓库（说明可以随便写）
git commit -m '说明' 连接本地仓库和远程仓库
(1).去码云中复制ssh地址 克隆-&gt;SSH -&gt;复制
(2).然后继续在命令行输入 git remote add origin +复制的ssh地址
注意：粘贴地址时候，不要直接ctrl v ,容易出错；单击右键选择paste 如果不想放在默认分支中，可以自己新建一个分支，否则默认在master分支，跳过此步
(1).创建本地dev分支 ：git branch 分支名称；
git branch XXX (2).切换到dev分支,再将项目文件到缓存区和本地仓库，即步骤5、6
//切换到dev分支 git checkout dev //将文件提交到缓存区 git add . //将文件提交到本地仓库 git commit -m '说明' 最后输入 git push 推送到托管服务器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72343d6dc373438d8e0ce5042cc9cf7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7211d0bc750a485c4f1691a8ff3128a/" rel="bookmark">
			IDEA登录LeetCode插件失败_无需输入cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 靠谱！原来只是网址变了的锅😅 关闭IDEA；打开C:\Users\huang\AppData\Roaming\JetBrains\IntelliJIdea2021.3\options下的leetcode-config.xml文件；将里面的leetcode-cn.com字段替换成leetcode.cn(有两处)；启动IDEA 点击sign in按钮即可登录，无需cookie
原链接：解决方法原链接 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a029fe2d1eeae70442c03205daa454d8/" rel="bookmark">
			记录一次Flink消费Kafka空转，无法拉取消息，checkpoint也能成功，但是位置点却不提交的异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起因 新起了一个业务,用flink消费实时集市kafka消息，在测试环境跑的好好的，验证也过了，然后上线。
刚上线的当天也好好的，晚上突然在某个点，就拉取不到消息了，上游一直有消息下来，但flink就是没接收到消息，而且checkpoint也能成功，但是消息的位置点却并没有提交，flink处于空转状态，日志也没有任何报错。
经过 根据以往经验，先怀疑某个消息有问题，无法消费。于是通过重置位置点跳过一段offset重启flink,但是效果依然如此。
然后重新申请消费组并重启flink,虽然可以消费一段时间，但是依然会卡到某个点就处于空转的状态。日志依然没有任何有效提示，checkpoint继续。。。。。
然后又检查了集群，看cpu核数，内存等，都没有问题，完全是富足的。
崩溃了，于是询问其他消费这个topic的同事，看看是否他们的消费也是如此，经询问，他们的没有任何问题，消息消费顺畅。
啊，难道是智子在搞我？
于是，我直接对比与同事的代码，终于在maven依赖中看到了我们的不同，他们用的kafka clients版本是2.3.0的，我的版本却是0.8的，终于真相大白。
公司统一封装了一个kafka消费基础包他们里面依赖的0.8，but线上的kafka集群却是2.3的，同事们之前已经遇到这个坑，没想到被我再踩了一次，多么痛的领悟！
结果 flink空转不是flink的问题，而是kafka客户端版本与集群版本不匹配导致的，然而最要命的是在flink空转无法消费时，看不到任何报错信息，都没有排查的方向。你就报个错，或者说直接启动不起来也好啊，关键它还可以消费一段时间。这就不好排查了。
它山之石，可以攻错，今天写下此文，希望为后来的同行提供一个排查问题的方向，虽然这个问题是一个看起来很傻逼的问题，但是一旦遇到了，就真的是遇到了！尤其当人家给你封装个什么jar包，你完全不会考虑有版本的问题。
当然为啥版本不匹配导致这种bug,还没来得及研究。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d335dd7ab4c2807bac7b501b4e86077e/" rel="bookmark">
			协方差、协方差矩阵、马氏距离与欧式距离的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		协方差、协方差矩阵、马氏距离与欧式距离的理解
最近在应用中，总涉及到对马氏距离的使用，而马氏距离中最重要的是协方差矩阵的计算，这些概念困扰了我很久，在查阅资料学习了解后，终于有浅显理解，做了个笔记与大家分享，才疏学浅，若理解有误欢迎批评指正。
一、 方差、协方差、协方差矩阵的概念
在统计学中，方差是单个样本集中，每个样本值与全体样本值的平均数之差的平均值的平均数，反应的是一维数组的离散程度。这里的样本集也可以换成随机变量，随机变量如果是离散的则表示为样本集，如果是连续的则可表示成连续变量，所以方差也称为度量单个随机变量的离散程度的物理量，计算公式如下：
（离散变量/样本集）
var(X)= E[(X−E[X])2]（连续变量）
在概率论和统计中，协方差是对两个随机变量联合分布线性相关程度的一种度量。两个随机变量越线性相关，协方差越大，完全线性无关，协方差为零。定义如下：
cov(X,Y)=E[(X−E[X])(Y−E[Y])]
当X，Y是同一个随机变量时，X与其自身的协方差就是X的方差，可以说方差是协方差的一个特例。
cov(X,X)=E[(X−E[X])(X−E[X])]
或
var(X)=cov(X,X)=E[(X−E[X])2]
由于随机变量的取值范围不同，两个协方差不具备可比性。如X，Y，Z分别是三个随机变量，想要比较X与Y的线性相关程度强，还是X与Z的线性相关程度强，通过cov(X,Y)与cov⁡(X,Z)无法直接比较。定义相关系数η为：
相关系数可以理解成归一化的协方差，将协方差归一化到[-1,1]的区间范围内。这样两协方差直接可以直接比较大小了。
需要注意的是，在实际应用中，变量往往是一些样本组成的离散点集，那么此时样本集的协方差（离散变量的协方差）是样本集的一个统计量，计算公式如下：
cov(X,Y)=1/(m-1) ∑_(i=1)^m▒〖(X_i-X ̅)(Y_i-Y ̅)〗
其中m是表示样本数，X，Y是具有相同样本数的两个变量。协方差永远是计算的两个变量之间的协方差。
当变量数大于等于两个，任意两个变量之间的协方差组成的矩阵就是协方差矩阵，对于n维随机变量X=〖[X_1,X_2,⋯X_n]〗^T，其协方差矩阵为n×n维的矩阵Σ。
很显然，协方差矩阵是对称阵，对角线位置表示每个变量的方差。
同样的，以上表示形式是连续变量的协方差计算公式，如果变量是离散的即样本集的形式，则离散随机变量（样本集）X表示为n×m的矩阵，如下：
X=〖[X_1,X_2,⋯X_n]〗^T, X_i=[x_i1,x_i2,⋯x_im]
则协方差矩阵Σ ̂计算公式如下：
二、协方差、协方差矩阵的计算
在实际计算时，大多是针对样本集的协方差计算。
首先我们分清几个概念，样本、变量、维度、属性等。样本往往都需要多个属性来描述，每个样本都可以看成一个多维随机变量的样本点。也就是说一个变量和一个属性说的是一个概念。同一变量中所有样本表示同一属性，具有同一物理意义与单位。同一变量中所有样本表示同一属性，具有同一物理意义与单位。在计算协方差的时候，一定要分清哪个维度是样本、哪个维度是变量。协方差是计算变量之间的协方差，而非对样本计算，所以协方差矩阵的大小与变量数相同。
样本集：X=〖[X_1,X_2,⋯X_n]〗^T=[■(x_11&amp;⋯&amp;x_1m@⋮&amp;⋱&amp;⋮@x_n1&amp;⋯&amp;x_nm )]
每一行表示一个变量，每一列表示一个样本，n个变量，m个样本。
计算协方差的时候就按照上述公式计算即可，也就是变量减去样本均值与另外一个变量减去样本均值之积的均值。
三、马氏距离与欧式距离的概念
不管是马氏距离还是欧式距离，都是用来表征样本与样本之间的距离大小的统计表征量。请注意与协方差不同的是，此刻是样本与样本之间的计算。
欧式距离的定义公式如下：
马氏距离定义就复杂点了，它是一种有效的计算两个未知样本的相似度的方法。在计算马氏距离前，首先要对多维变量或样本集计算出协方差矩阵，然后就可以计算两个样本点的马氏距离，也可以计算样本与样本集的马氏距离，也可以计算一个样本集本身的马氏距离。详细看下面两张图：
后者图中第一个公式就是计算样本集本身的马氏距离，第二个公式就是计算两个样本之间的马氏距离，协方差矩阵前后的两个向量是一样的，只不过做了个转置。个人理解，如果想做样本到样本集的马氏距离，则可把y换成某个样本集的矩阵向量。
此刻，思考个问题，要计算的样本或样本集服不服从计算协方差矩阵的变量分别呢？或者说计算协方差矩阵的样本集包含要计算马氏距离的样本或样本集吗？
四、 对马氏距离的物理意义（转自bluesliuf）
马氏距离有很多优点： 马氏距离不受量纲的影响，两点之间的马氏距离与原始数据的测量单位无关；由标准化数据和中心化数据(即原始数据与均值之差）计算出的二点之间的马氏距离相同。马氏距离还可以排除变量之间的相关性的干扰。
下面我们来看一个例子：
如果我们以厘米为单位来测量人的身高，以克（g）为单位测量人的体重。每个人被表示为一个两维向量，如一个人身高173cm，体重50000g，表示为（173,50000），根据身高体重的信息来判断体型的相似程度。
我们已知小明（160,60000）；小王（160,59000）；小李（170，60000）。根据常识可以知道小明和小王体型相似。但是如果根据欧几里得距离来判断，小明和小王的距离要远远大于小明和小李之间的距离，即小明和小李体型相似。这是因为不同特征的度量标准之间存在差异而导致判断出错。
以克（g）为单位测量人的体重，数据分布比较分散，即方差大，而以厘米为单位来测量人的身高，数据分布就相对集中，方差小。马氏距离的目的就是把方差归一化，使得特征之间的关系更加符合实际情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a9a9a43f3b376dfee83e0328e335be7/" rel="bookmark">
			IoU Loss综述（IOU,GIOU,CIOU,EIOU,SIOU,WIOU）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		边界框回归（BBR）的损失函数对于目标检测至关重要。它的良好定义将为模型带来显著的性能改进。大多数现有的工作假设训练数据中的样本是高质量的，并侧重于增强BBR损失的拟合能力。
一、L2-norm 最初的基于回归的BBR损失定义为L2-norm，L2-norm损失主要有两个缺点：
1、边界框的坐标（以xt、xb、xl、xr的形式）被优化为四个独立变量。这个假设违背了对象的边界高度相关的事实。简单的分开计算每个变量的回归loss无法反映这种相关性，它会导致预测框的一个或两个边界非常接近GT，但整个边界框是不满足条件的。
2、这种形式的损失函数并不能屏蔽边界框大小的干扰，使得模型对小目标的定位性能较差。
二、IoU loss 论文:《UnitBox: An Advanced Object Detection Network》
在目标检测任务中，使用IoU来测量anchor box与目标box之间的重叠程度。它以比例的形式有效地屏蔽了边界框大小的干扰，使该模型在使用1-IoU作为BBR损失时，能够很好地平衡对大物体和小物体的学习。
IoU loss的函数定义为：
当边界框没有重叠时Liou对Wi求导会等于0，即：
此时Liou的反向投影梯度消失，在训练期间无法更新重叠区域Wi的宽度。
IoU损失会有两个主要的缺点： 1、当预测框与真实框都没有交集时，计算出来的IoU都为0，损失都为1，但是缺失距离信息，预测框与GT相对位置较近时，损失函数应该较小。
2、当预测框和真实框的交并比相同，但是预测框所在位置不同，因为计算出来的损失一样，所以这样并不能判断哪种预测框更加准确。
现有的工作GIOU、DIOU、Focal EIOU、CIOU以及SIOU中考虑了许多与边界框相关的几何因子，并构造了惩罚项Ri来解决这个问题。现有的BBR损失遵循以下范例：
三、GIoU loss 论文：《Generalized Intersection over Union: A Metric and A Loss for Bounding Box Regression》
为了解决IoU loss的第一个问题，即当预测框与真实框都没有交集的时候，计算出来的IoU都为0，损失都为1，引入了一个最小闭包区的概念，即能将预测框和真实框包裹住的最小矩形框
其中紫色框为GT，蓝色框为预测框，绿色的边框则为最小包围框。
GIoU的伪代码：
与IoU相似，GIoU也是一种距离度量，IoU取值[0,1]，GIoU取值范围[-1,1]。在两者重合的时候取最大值1，在两者无交集且无限远的时候取最小值-1，因此GIoU是一个非常好的距离度量指标。与IoU只关注重叠区域不同，GIoU不仅关注重叠区域，还关注其他的非重合区域，能更好的反映两者的重合度。
但是GIoU同时也存在一些问题：
1、当预测框包裹GT时，计算的iou相同，但是质量却不同，对于预测框的中心点靠近GT中心点的情况，loss应该相对小一些
GIoU loss的定义：
四、DIoU/CIoU loss 论文：《Distance-IoU Loss: Faster and Better Learning for Bounding Box Regression》
DIoU为了解决GIoU中存在的问题，作者认为好的检测回归loss应该考虑三个几何度量，预测框和GT框的重叠度、中心点距离、长宽比的一致性。于是在IoU loss和GIoU loss基础上引入预测框和GT框中心点距离作DIoU loss，在DIoU loss基础上引入了预测框的长宽比和GT框的长宽比之间的差异作CIoU loss。此外，将DIoU加入nms替代IoU，提升了nms的鲁棒性。
DIoU定义：
DIoU也存在一个缺点，当真实框和预测框的中心点重合时，但是长宽比不同，交并比一样，CIoU在此基础上增加一个惩罚项。
CIoU定义：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a9a9a43f3b376dfee83e0328e335be7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16fab371e18d7df2ab146ae9e45c9c73/" rel="bookmark">
			vs code代码格式化配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 Prettier - Code formatter 点击左下角 设置 &gt; 设置 &gt; 右上角 打开设置 按钮 &gt; 打开 settings.json
{ // 左侧目录不折叠 "explorer.compactFolders": false, // 选择格式化工具 "[jsonc]": { "editor.defaultFormatter": "esbenp.prettier-vscode" }, "[javascript]": { "editor.defaultFormatter": "esbenp.prettier-vscode" }, // prettier格式化配置 "prettier": { // 句尾添加分号 "semi": false, // 缩进字节数 "tabWidth": 2, // 超过最大值换行 "printWidth": 500, // 使用单引号代替双引号 "singleQuote": true } } vetur格式化vue { // 左侧目录不折叠 "explorer.compactFolders": false, // #每次保存的时候自动格式化 "editor.formatOnSave": true, "editor.fontSize": 16, "editor.tabSize": 2, // 代码提示顺序 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16fab371e18d7df2ab146ae9e45c9c73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/695212dbf51e6cdbfbb572e0d716da3e/" rel="bookmark">
			JDK version和class file version(Class编译版本号)对应关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK version和class file version(Class编译版本号)对应关系
JDK 19 = 63,
JDK 18 = 62,
JDK 17 = 61,
JDK 16 = 60,
JDK 15 = 59,
JDK 14 = 58,
JDK 13 = 57,
JDK 12 = 56,
JDK 11 = 55,
JDK 10 = 54,
JDK 9 = 53,
JDK 8 = 52,
JDK 7 = 51,
JDK 6.0 = 50,
JDK 5.0 = 49,
JDK 1.4 = 48,
JDK 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/695212dbf51e6cdbfbb572e0d716da3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65169d24d7ad42ce615d0b0ae7d6cd78/" rel="bookmark">
			如何实现大文件上传：秒传、断点续传、分片上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 文件上传是一个老生常谈的话题了，在文件相对比较小的情况下，可以直接把文件转化为字节流上传到服务器，但在文件比较大的情况下，用普通的方式进行上传，这可不是一个好的办法，毕竟很少有人会忍受，当文件上传到一半中断后，继续上传却只能重头开始上传，这种让人不爽的体验。那有没有比较好的上传体验呢，答案有的，就是下边要介绍的几种上传方式
详细教程 秒传
1、什么是秒传
通俗的说，你把要上传的东西上传，服务器会先做MD5校验，如果服务器上有一样的东西，它就直接给你个新地址，其实你下载的都是服务器上的同一个文件，想要不秒传，其实只要让MD5改变，就是对文件本身做一下修改（改名字不行），例如一个文本文件，你多加几个字，MD5就变了，就不会秒传了.
2、本文实现的秒传核心逻辑
a、利用redis的set方法存放文件上传状态，其中key为文件上传的md5，value为是否上传完成的标志位，
b、当标志位true为上传已经完成，此时如果有相同文件上传，则进入秒传逻辑。如果标志位为false，则说明还没上传完成，此时需要在调用set的方法，保存块号文件记录的路径，其中key为上传文件md5加一个固定前缀，value为块号文件记录路径
分片上传
1.什么是分片上传
分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（我们称之为Part）来进行分别上传，上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件。
2.分片上传的场景
1.大文件上传
2.网络环境环境不好，存在需要重传风险的场景
断点续传
1、什么是断点续传
断点续传是在下载或上传时，将下载或上传任务（一个文件或一个压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传或者下载未完成的部分，而没有必要从头开始上传或者下载。本文的断点续传主要是针对断点上传场景。
2、应用场景
断点续传可以看成是分片上传的一个衍生，因此可以使用分片上传的场景，都可以使用断点续传。
3、实现断点续传的核心逻辑
在分片上传的过程中，如果因为系统崩溃或者网络中断等异常因素导致上传中断，这时候客户端需要记录上传的进度。在之后支持再次上传时，可以继续从上次上传中断的地方进行继续上传。
为了避免客户端在上传之后的进度数据被删除而导致重新开始从头上传的问题，服务端也可以提供相应的接口便于客户端对已经上传的分片数据进行查询，从而使客户端知道已经上传的分片数据，从而从下一个分片数据开始继续上传。
4、实现流程步骤
a、方案一，常规步骤
将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；
初始化一个分片上传任务，返回本次分片上传唯一标识；
按照一定的策略（串行或并行）发送各个分片数据块；
发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件。
b、方案二、本文实现的步骤
前端（客户端）需要根据固定大小对文件进行分片，请求后端（服务端）时要带上分片序号和大小
服务端创建conf文件用来记录分块位置，conf文件长度为总分片数，每上传一个分块即向conf文件中写入一个127，那么没上传的位置就是默认的0,已上传的就是Byte.MAX_VALUE 127（这步是实现断点续传和秒传的核心步骤）
服务器按照请求数据中给的分片序号和每片分块大小（分片大小是固定且一样的）算出开始位置，与读取到的文件片段数据，写入文件。
5、分片上传/断点上传代码实现
a、前端采用百度提供的webuploader的插件，进行分片。因本文主要介绍服务端代码实现，webuploader如何进行分片，具体实现可以查看如下链接:
http://fex.baidu.com/webuploader/getting-started.html
b、后端用两种方式实现文件写入，一种是用RandomAccessFile，如果对RandomAccessFile不熟悉的朋友，可以查看如下链接:
https://blog.csdn.net/dimudan2015/article/details/81910690
另一种是使用MappedByteBuffer，对MappedByteBuffer不熟悉的朋友，可以查看如下链接进行了解:
https://www.jianshu.com/p/f90866dcbffc
后端进行写入操作的核心代码
a、RandomAccessFile实现方式
@UploadMode(mode = UploadModeEnum.RANDOM_ACCESS) @Slf4j public class RandomAccessUploadStrategy extends SliceUploadTemplate { @Autowired private FilePathUtil filePathUtil; @Value("${upload.chunkSize}") private long defaultChunkSize; @Override public boolean upload(FileUploadRequestDTO param) { RandomAccessFile accessTmpFile = null; try { String uploadDirPath = filePathUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65169d24d7ad42ce615d0b0ae7d6cd78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edca5443298e6df12d543d35320430d8/" rel="bookmark">
			对抗生成网络GAN系列——DCGAN简介及人脸图像生成案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍊作者简介：秃头小苏，致力于用最通俗的语言描述问题
🍊往期回顾：对抗生成网络GAN系列——GAN原理及手写数字生成小案例
🍊近期目标：写好专栏的每一篇文章
🍊支持小苏：点赞👍🏼、收藏⭐、留言📩
文章目录 对抗生成网络GAN系列——DCGAN简介及人脸图像生成案例写在前面DCGAN重点知识把握DCGAN简介DCGAN生成模型、判别模型设计✨✨✨生成网络模型🧅🧅🧅判别模型网络🧅🧅🧅 DCGAN人脸生成实战✨✨✨数据集加载🧅🧅🧅生成模型搭建🧅🧅🧅模型训练🧅🧅🧅 番外篇——使用服务器训练如何保存图片和训练损失✨✨✨小结 本节已录制视频：DCGAN简介及人脸图像生成案例🧨🧨🧨
对抗生成网络GAN系列——DCGAN简介及人脸图像生成案例 写在前面 ​ 前段时间，我已经写过一篇关于GAN的理论讲解，并且结合理论做了一个手写数字生成的小案例，对GAN原理不清楚的可以点击☞☞☞跳转了解详情。🌱🌱🌱
​ 为唤醒大家的记忆，这里我再来用一句话对GAN的原理进行总结：GAN网络即是通过生成器和判别器的不断相互对抗，不断优化，直到判别器难以判断生成器生成图像的真假。
​ 那么接下来我就要开始讲述DCGAN了喔，读到这里我就默认大家对GAN的原理已经掌握了，开始发车。🚖🚖🚖
DCGAN重点知识把握 DCGAN简介 ​ 我们先来看一下DCGAN的全称——Deep Convolutional Genrative Adversarial Networks。这大家应该都能看懂叭，就是说这次我们将生成对抗网络和深度学习结合到一块儿了，现在看这篇文章的一些观点其实觉得是很平常的，没有特别出彩之处，但是这篇文章是在16年发布的，在当时能提出一些思想确实是难得。
​ 其实呢，这篇文章的原理和GAN基本是一样的。不同之处只在生成网络模型和判别网络模型的搭建上，因为这篇文章结合了深度学习嘛，所以在模型搭建中使用了卷积操作【注：在上一篇GAN网络模型搭建中我们只使用的全连接层】。介于此，我不会再介绍DCGAN的原理，重点将放在DCGAN网络模型的搭建上。【注：这样看来DCGAN就很简单了，确实也是这样的。但是大家也不要掉以轻心喔，这里还是有一些细节的，我也是花了很长的时间来阅读文档和做实验来理解的，觉得理解差不多了，才来写了这篇文章。】
​ 那么接下来就来讲讲DCGAN生成模型和判别模型的设计，跟我一起来看看叭！！！
DCGAN生成模型、判别模型设计✨✨✨ ​ 在具体到生成模型和判别模型的设计前，我们先来看论文中给出的一段话，如下图所示：
​ 这里我还是翻译一下，如下图所示：
​ 上图给出了设计生成模型和判别模型的基本准则，后文我们搭建模型时也是严格按照这个来的。【注意上图黄色背景的分数卷积喔，后文会详细叙述】
生成网络模型🧅🧅🧅 ​ 话不多说，直接放论文中生成网络结构图，如下：
图1 生成网络模型 ​ 看到这张图不知道大家是否有几秒的迟疑，反正我当时是这样的，这个结构给人一种熟悉的感觉，但又觉得非常的陌生。好了，不卖关子了，我们一般看到的卷积结构都是特征图的尺寸越来越小，是一个下采样的过程；而这个结构特征图的尺寸越来越大，是一个上采样的过程。那么这个上采样是怎么实现的呢，这就要说到主角分数卷积了。【又可以叫转置卷积（transposed convolution）和反卷积（deconvolution），但是pytorch官方不建议取反卷积的名称，论文中更是说这个叫法是错误的，所以我们尽量不要去用反卷积这个名称，同时后文我会统一用转置卷积来表述，因为这个叫法最多，我认为也是最贴切的】
关于转置卷积的理论可以参考我的这篇博文：转置卷积详解（原理+实验）🥨🥨🥨
判别模型网络🧅🧅🧅 ​ 同样的，直接放出判别模型的网络结构图，如下：【注：这部分原论文中没有给出图例，我自己简单画了一个，没有论文中图示美观，但也大致能表示卷积的过程，望大家见谅】
​ 判别网络真的没什么好讲的，就是传统的卷积操作，对卷积不了解的建议阅读一下我的这篇文章🧨🧨🧨
​ 这里我给出程序执行的网络模型结构的结果，这部分就结束了：
DCGAN人脸生成实战✨✨✨ ​ 这部分我们将来实现一个人脸生成的实战项目，我们先来看一下人脸一步步生成的动画效果，如下图所示：
​ 我们可以看到随着迭代次数增加，人脸生成的效果是越来越好的，说句不怎么恰当的话，最后生成的图片是像个人的。看到这里，是不是都兴致勃勃了呢，下面就让我们一起来学学叭。🏆🏆🏆
​ 秉持着授人以鱼不如授人以渔的原则，这里我就不带大家一句一句的分析代码了，都是比较简单的，官方文档写的也非常详细，我再叙述一篇也没有什么意义。哦，对了，这部分代码参考的是pytorch官网上DCGAN的教程，链接如下：DCGAN实战教程🎈🎈🎈
​ 我来简单介绍一下官方教程的使用，点击上文链接会进入下图的界面：这个界面正常滑动就是对这个项目的解释，包括原理、代码及代码运行结果，大家首先要做的应该是阅读一遍这个文档，基本可以解决大部分的问题。那么接下来对于不明白的就可以点击下图中绿框链接修改一些代码来调试我们不懂的问题，这样基本就都会明白了。【框1是google提供的一个免费的GPU运算平台，就类似是云端的jupyter notebook ，但这个需要梯子，大家自备；框2 是下载notebook到本地；框3是项目的Github地址】
​ 那方法都教给大家了，大家快去试试叭！！！
​ 作为一个负责的博主👨‍🦳👨‍🦳👨‍🦳，当然不会就甩一个链接就走人啦，下面我会帮助大家排查一下代码中的一些难点，大家看完官方文档后如果有不明白的记得回来看看喔。🥂🥂🥂当然，如果有什么不理解的地方且我下文没有提及欢迎评论区讨论交流。🛠🛠🛠
数据集加载🧅🧅🧅 ​ 首先我来说一下数据集的加载，这部分不难，却十分重要。对于我们自己的数据集，我们先用ImageFolder方法创建dataset,代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edca5443298e6df12d543d35320430d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bd1ba132b5af38fbacfe9b7cb293a29/" rel="bookmark">
			STM32CubeMX配置HAL库实现SPI-DMA的递归调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于快速入门STM32CubeMX，可以参考 【STM32】HAL库 STM32CubeMX系列学习教程 —————————— 一、硬件参数与配置： 核心：STM32F407ZET6 外设ADC：ADS1258 数量：3个 ※ 核心与3个ADC使用SPI总线 “一主多从” 方式连接，PCB布线的方式与下图一致。
※ 在电路板上STM32与三个ADS1258在同一直线上分布，STM32在一端，三个ADC依次排布。
※ 离STM32最远ADC的DRDY硬件管脚与STM32的EXTI line4 interrupt连接。
1.1 STM32CubeMX的设置 1.1.1 时钟树配置如下： 1.1.2 ADC输入的CLK由STM32的定时器TIM4控制，时钟树中APB1 Timer Clock = 84MHz，由下图配置生成PWM来当作ADC输入的CLK，CLK的频率为84/8 = 10.5MHz，
1.1.3 使用STM32的SPI3通讯协议，SPI3_RX的DMA Request与DMA1 Stream0连接，SPI3_TX的DMA Request与DMA1 Stream0连接。由于ADS1258的Datasheet中对SPI速率的要求，确定了STM32与ADC之间的SPI通讯速率为5.25MBits/s，即SCLK = 5.25MBits/s
1.2 ADS1258的设置 1.2.1 在整个系统初始化时，STM32向ADS1258发送一系列寄存器指令，将ADS1258的采样模式设置为Auto-Scan Mode、在该模式下使能需要采样的模拟信号输入管脚（已使能管脚按ADS1258 datasheet中的Channel ID，自动转换至待采样的模拟信号输入管脚）。
1.2.2 ADS1258在Auto-Scan Mode的Data Rate的计算公式如下，初始化设置中fclk = 10.5MHz，DR = 10b，TD = 8，CHOP = 0，计算得Data Rate = 5043Hz，即每个ADC的每次采样完成后DRDY引脚输出的信号频率为5043Hz。
二、运行逻辑 2.1 功能概述 在电路设计上，三个ADC的采样启停通过硬件连接由STM32的同步控制，且ADS1258的采样模式为Auto-Scan Mode，因此三个ADC能够同时将预定的输入模拟信号进行采样并转换为数字量，即在任一ADC的两个DRDY信号之间，三个ADC均在硬件上一一对应的模拟信号输入管脚进行采样。在两个DRDY之间，STM32需要通过SPI协议接收三组 4 Bytes 的数字量，为了在接收数据的同时不占用核心的处理，所以选择了非阻塞式的SPI-DMA传输，可以按照三个ADC的硬件摆放顺序，将三组数字量依次且完整接收。
2.2 功能实现 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bd1ba132b5af38fbacfe9b7cb293a29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a2c107141d2207c47e380aa8a7dd6c2/" rel="bookmark">
			Python深度学习实战PyQt5信号与槽的连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文讲解信号与槽的连接机制，详细示范各种类型的信号/槽连接的实现方法，这是图形用户界面的核心内容。还将介绍面向对象的程序设计，这是图形用户界面的基本思想
目录 1. 信号与槽（Signals and slots） 信号与槽机制是 PyQt 的核心机制，用于对象之间的通信，也就是实现函数之间的自动调用。
1.1 信号与槽的原理 简单地说，将信号与槽函数连接后，当信号被触发时，槽函数将被自动调用。
分析这个过程，涉及到几个基本概念和关系：
信号：信号可以是一个动作，也可以是对象的一种状态，用于触发所连接的槽。
槽：槽就是一个函数，可以由连接的信号触发。
发射信号：信号被发射时，自动调用信号连接的槽函数。通常，在对象的状态改变时发射信号。
信号可以带有参数，但必须与槽函数的参数相对应。
一个信号可以连接多个槽函数，多个信号也可以连接到一个槽函数。
一个信号可以连接到另一个信号上。
很多窗口部件（控件）内置了一下信号和槽，可以直接调用。也可以按需求自定义信号和槽。
1.2 信号发送者与槽的接收者 信号的发送者通常是一个控件对象，在控件对象的状态发生变化时发送信号。常见的发送者是图形窗口中的各种控件对象，但也可以是动作对象。
槽的接收者通常也是控件对象。槽函数是一个自定义的槽函数，或控件内置的槽函数。一般地，槽函数也有一个对象作为主体，即对于接受者这个控件对象执行函数定义的操作。例如槽函数执行的功能是关闭，哪么究竟是关闭那个控件呢？关闭对象就是接受者。
为了方便讲解信号与槽的连接，我们用 QtDesigner 在上节设计的图形窗口 uiDemo3.ui 的基础上，增加几个按钮对象和文本行编辑对象：
打开 PyCharm，从 Tools -&gt; ExternalTools -&gt; QtDesigner 打开 QtDesigner，打开 uiDemo3.ui 文件。
鼠标点击选中 QtDesigner 左侧控件栏 Buttons 中的 PushButton，按住鼠标不放，将其拖动到中间的图形界面后松开鼠标，就在图形界面中创建了一个 PushButton 控件。
鼠标点击选中 QtDesigner 左侧控件栏 InputWidget 中的 LineEdit，按住鼠标不放，将其拖动到中间的图形界面后松开鼠标，就在图形界面中创建了一个 LineEdit 控件。
重复以上步骤，再建立几个 PushButton 控件和 LineEdit 控件。
注意在 QtDesigner 右侧 “对象查看器” 中所显示的控件名称和属性，多个 PushButton、LineEdit 被自动赋予不同的命名（objectName），如：LineEdit_1、LineEdit_2、LineEdit_3，这就如同桌子有几个抽屉分别标记为 “抽屉1”、“抽屉2”、“抽屉3” 以便识别。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a2c107141d2207c47e380aa8a7dd6c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10777121b94e41970991bf423a24effd/" rel="bookmark">
			机器学习笔记之生成模型综述(二)监督学习与无监督学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习笔记之生成模型综述——监督学习与无监督学习 引言回顾：生成模型介绍判别方式：生成模型 VS \text{VS} VS 判别模型生成模型的建模手段 监督学习与无监督学习监督学习模型基于监督学习的非概率模型基于监督学习的概率模型 无监督学习基于无监督学习的概率模型基于无监督学习的非概率模型 生成模型介绍 引言 上一节介绍了生成模型的判别方式，本节将从机器学习需要解决的任务——监督学习、无监督学习的角度，对现阶段经典模型进行总结。
回顾：生成模型介绍 判别方式：生成模型 VS \text{VS} VS 判别模型 生成模型( Generative Model \text{Generative Model} Generative Model)的核心判别方式是：建模所关注的对象是否在样本分布自身。例如逻辑回归与朴素贝叶斯分类器。虽然这两个算法均处理基于监督学习的分类任务，并且均是软分类算法，但关注点截然不同：
逻辑回归( Logistic Regression \text{Logistic Regression} Logistic Regression)的底层逻辑是最大熵原理，通过 Sigmoid , Softmax \text{Sigmoid},\text{Softmax} Sigmoid,Softmax函数直接对后验概率 P ( Y ∣ X ) \mathcal P(\mathcal Y \mid \mathcal X) P(Y∣X)进行描述：
以二分类为例，此时 Y \mathcal Y Y服从伯努利分布。
P ( Y ∣ X ) = { Sigmoid ( W T X + b ) Y = 1 1 − Sigmoid ( W T X + b ) Y = 0 \mathcal P(\mathcal Y \mid \mathcal X) = \begin{cases} \text{Sigmoid}(\mathcal W^T\mathcal X + b) \quad \mathcal Y = 1\\ 1 - \text{Sigmoid}(\mathcal W^T\mathcal X + b) \quad \mathcal Y = 0 \end{cases} P(Y∣X)={Sigmoid(WTX+b)Y=11−Sigmoid(WTX+b)Y=0​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10777121b94e41970991bf423a24effd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3605e88c1bb3b50e7fb83759228f02af/" rel="bookmark">
			sass 常见函数的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见函数简介，更多函数列表可看：https://sass-lang.com/documentation/modules 1.Color(颜色函数) sass包含很多操作颜色的函数。例如：lighten() 与 darken()函数可用于调亮或调暗颜色，opacify()函数使颜色透明度减少，transparent()函数使颜色透明度增加，mix()函数可用来混合两种颜色。
p { height: 30px; } .p0 { background-color: #5c7a29; } .p1 { /* 让颜色变亮 lighten($color, $amount) $amount 的取值在0% - 100% 之间 */ background-color: lighten(#5c7a29, 30%); } .p2 { // 让颜色变暗 通常使用color.scale()代替该方案 background-color: darken(#5c7a29, 15%); } .p3 { // 降低颜色透明度 通常使用color.scale()代替该方案 // background-color: opacify(#5c7a29,0.5); background-color: opacify(rgba(#5c7a29, 0.1), 0.5); } 使用
&lt;p&gt;&lt;/p&gt; &lt;p class="p0"&gt;&lt;/p&gt; &lt;p class="p1"&gt;&lt;/p&gt; &lt;p class="p2"&gt;&lt;/p&gt; &lt;p class="p3"&gt;&lt;/p&gt; 2.String（字符串函数） Sass有许多处理字符串的函数，比如向字符串添加引号的quote()、获取字符串长度的string-length()和将内容插入字符串给定位置的string-insert()。
例
p { &amp;:after { content: quote(这是里面的内容); } background-color: unquote($string: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3605e88c1bb3b50e7fb83759228f02af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30dcd0a68575e6bba152d05030dc0011/" rel="bookmark">
			Navicat（1045 - Access denied for user ‘root‘@‘localhost‘ (using password: YES)）得报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先问题得报错显示为这个样子得，那么主要的问题是密码输入错误得问题。
如果再此之前有进行密码得更换那么就是我遇到这个问题所涉及到得解决方法。
点击报错得那个数据库进行左键，找到那个编辑链接
点击编辑链接会看到如下得文本框。
3.在密码出
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b744b5fd8da22fd07beaadda2fac127e/" rel="bookmark">
			window 安装debian的Linux系统&#43;一些环境初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安装：1、安装WSL22、微软商店搜索debian安装：3、也可以官方安装： 二、更改镜像源1、查看debian系统版本：2、修改3、升级 三、安装zsh1：检查2、安装zsh3、安装oh-my-zsh4、安装插件5、配置文件~/.zshrc:6、配置生效： 一、安装： 1、安装WSL2 1、参照之前整理的一篇文章，参考第一步：安装WSL2即可。
https://zhaojiafu.blog.csdn.net/article/details/118501287
2、微软商店搜索debian安装： 3、也可以官方安装： 各个版本下载。
https://www.debian.org/releases/
二、更改镜像源 打开，设置好密码知乎，更改apt镜像源，后续安装提速。
https://developer.aliyun.com/mirror/?spm=a2c6h.13651104.0.d1002.70b027075siJXO
阿里云debian镜像官网
https://developer.aliyun.com/mirror/debian
1、查看debian系统版本： cat /etc/issue # Debian GNU/Linux 11 \n \l 我这个是11.
2、修改 编辑/etc/apt/sources.list文件(需要使用sudo), 在文件最前面添加以下条目(操作前请做好相应备份)
sudo cp /etc/apt/sources.list /etc/apt/sources.list.bat sudo vi /etc/apt/sources.list # 11版本支持，其他参考阿里云镜像官网 deb https://mirrors.aliyun.com/debian/ bullseye main non-free contrib deb-src https://mirrors.aliyun.com/debian/ bullseye main non-free contrib deb https://mirrors.aliyun.com/debian-security/ bullseye-security main deb-src https://mirrors.aliyun.com/debian-security/ bullseye-security main deb https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib deb-src https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib deb https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b744b5fd8da22fd07beaadda2fac127e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d411a1f8f25579b8dc7e5579fc92bd15/" rel="bookmark">
			OpenCV调用工业相机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV调用工业相机 python调用海康工业相机并用opencv显示（整体实现）
python调用Gige网口工业相机 opencv
文章目录 OpenCV调用工业相机前言一、MVS 3.4.1下载二、安装1. 傻瓜式安装，只需记得安装路径即可（环境变量可加可不加）2. 用Pycharm打开3. 创建GigeOpencv.py文件3. 创建AllOpencv.py文件 三、总文件 前言 OpenCV可以简单的调用USB相机，只需通过cap = cv2.VideoCapture(0)即可。
可一旦调用Gige等网口连接的工业相机时，使用cap = cv2.VideoCapture(0)或是cap = cv2.VideoCapture(1)、cap = cv2.VideoCapture(2)等等都无法调用。
通过查阅众多文章后，本人根据自身使用要求整理了一份程序
一、MVS 3.4.1下载 不能使用百度上所能搜到的3.1.0版本，Python编程时缺少参数
直接上链接：MVS3.4.1-for-windows
MVS-2.1.2-for-Linux
二、安装 1. 傻瓜式安装，只需记得安装路径即可（环境变量可加可不加） 2. 用Pycharm打开 若没正确安装
C:\Program Files (x86)\Common Files\MVS\Runtime\Win64_x64里的MvCameraControl.dll可能会缺失
出现该问题就把MvCameraControl.dll复制到上述的Python文件夹
3. 创建GigeOpencv.py文件 import sys import threading import msvcrt import cv2 import numpy as np import time from ctypes import * from MvCameraControl_class import * # from tfoddetect import * g_bExit = False def main(): deviceList = MV_CC_DEVICE_INFO_LIST() # 选择计算机所使用的相机类型，选越多越慢 # tlayerType = MV_GIGE_DEVICE | MV_USB_DEVICE | MV_UNKNOW_DEVICE | MV_1394_DEVICE | MV_CAMERALINK_DEVICE tlayerType = MV_GIGE_DEVICE | MV_USB_DEVICE # ch:枚举设备 | en:Enum device ret = MvCamera.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d411a1f8f25579b8dc7e5579fc92bd15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ca611994941f99db26fb270ad1ca82b/" rel="bookmark">
			STM32笔记_10(ADC—电压采集)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ADC—电压采集 ADC 简介 STM32f103 系列有 3 个 ADC，精度为 12 位，每个 ADC 最多有 16 个外部通道。其中 ADC1 和ADC2 都有 16 个外部通道， ADC3 根据 CPU 引脚的不同通道数也不同，一般都有 8 个外部通道。
ADC 功能框图剖析 电压输入范围 ADC 输入范围为： VREF- ≤ VIN ≤ VREF+。由 VREF-、 VREF+ 、 VDDA 、 VSSA、这四个外部引脚决定。
一般把 VSSA 和 VREF- 接地，把 VREF+ 和 VDDA 接 3V3，得到 ADC 的输入电压范围为： 0~3.3V。
想让输入的电压范围变宽的话，在外部加一个电压调理电路，把需要转换的电压抬升或者降压到 0~3.3V，这样 ADC 就可以测量。
输入通道 STM32 的ADC 多达 18 个通道，其中外部的 16 个通道就是框图中的ADCx_IN0 ,ADCx_IN1… ADCx_IN15。
这十六个通道对应不同的IO口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ca611994941f99db26fb270ad1ca82b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e87b5109806d61d177d78b09bc8861d/" rel="bookmark">
			通俗讲解曲面参数化(三角网格参数化)是怎么做的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		曲面参数化(三角网格参数化) 曲面参数化，平面参数化，表面参数化，三角网格参数化，Surface Parameterization，Planar Parameteriazation，Mesh Parameterization。
上面有这么多的名字，容易看得人糊涂。所以先说一下这篇文章讲的曲面参数化是干嘛的，是找到一个将三维表面或者三维物体压成一张展开的二维平面的方法。如果这是你想了解的内容，那就是找对了方向。
1.曲面参数化的用途 曲面参数化，这个词从字面上看还以为是为曲面找到一个或者一组公式来表达。其实了解完后觉得应该将“参数化”理解为，找到三维面到二维面的映射，作用对象是三角网格曲面，对三角网格曲面进行展开(展开指参数化)，得到结果是从拓扑、角度、三角形面积等上逐一对应的二维平面。
将三维面展开到二维面，这就有许多用途了，最最最常见的用途就是做纹理映射(贴图映射)。
一张贴图是二维的，要把它贴到三维网格面上，可不是像现实中在贴图背面沾点胶水然后一手拍在网格表面上就行的了。在计算机上是需要找到贴图上每个颜色点应该贴到网格面上具体的一个空间坐标点的，而作为中间媒介的就是参数化得到的这张展开的二维面。用下图来说明：
不过能看到本文的应该都知道曲面参数化能干嘛，关心的是曲面参数化怎么做，所以作用就不多说，下面开始说怎么做。
2. 曲面参数化怎么做 先把参数化方法分成两大类，一类是固定边界方法，一类是自由边界方法。用下图理解：
自由边界和固定边界的区别很明显，就是参数化后模型的边界是否对齐圆形或正方形的边界。是否固定都会有各自的较优用途，例如我要做纹理映射的话，我的纹理贴图就是一张正方形图片，那我选择与正方形同胚的方法展开三维模型成正方形，那将纹理对应起来会更保真，大致就是这样的考虑。
那问题来了，模型的边界哪来？
如果是一张三角网格曲面，那本身曲面就会有边界；如果是一个封闭模型，那就自己去切割网格，切割线就作为展开的边界。切割的案例如下：
3.固定边界方法——凸组合方法 先说重心坐标这个概念，先看图：
已知三角形的三个坐标A，B，C。其内部有个点P，P是任意一点，都可以用A，B，C三个点表示，也可以说是能够通过A，B，C三个顶点插值而来。反正就是要找出w1，w2，w3三个权重值就行了。（注意：P点在内部，因此三个权重值相加等于1，而且权重值要求是非负数，这才能让权重w是唯一解。这也叫凸组合。）
反过来就是说如果知道权重值是多少，那么就能求出唯一的P点坐标。
这里的权重是计算内部划分的三个三角形的面积比例来确定的，而这三个权重值就是点P的重心坐标。当然这里P点任意指定，坐标是已知的，因此能算出内部小三角形的面积。三个权重值对应w1，w2，w3三个未知数，然后按算面积比例去列方程组，再加上w1 + w2 + w3 = 1 这条去解方程组就行了。
以上是由重心坐标引出的凸组合的概念，P可以被邻接顶点表示。下面我们开始想做的就是用边界的顶点去表示内部的顶点。
把这个概念延申，上面是计算单个三角形内部点的凸组合，那下面开始多边形的，假如你面对的是一个网格的话，看下图：
P的坐标也是任意给定，而且他的邻接顶点的坐标都是已知数，现在就要求P点的ABCDEF的凸组合，即邻接的权重，你觉得能求吗？
当然可以求，本质还是：　P = w1 * A + w2 * B + w3 * C + w4 * D + w5 * E + w6 * F
而且 w1 + w2 + w3 + w4 + w5 + w6 = 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e87b5109806d61d177d78b09bc8861d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffcd841bab92e74068dd68d63dd8f758/" rel="bookmark">
			我需要解决java代码的报错内容the trustanchors parameter must be non-empty，帮我列出解决的方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个报错的原因可能是你的系统没有配置正确的信任锚，解决方法有：1.检查你的系统是否安装了正确的证书；2.尝试更新你的系统证书；3.检查你的系统是否正确的设置了信任锚；4.尝试清除你的系统缓存；5.重新编译你的java代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcafc89700bcc7fa020ee33bffea8863/" rel="bookmark">
			JS批量处理对象内有相同字段的属性值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 例：
前提对象key值都有 'xxxTime’这样的共同点Object.keys()收集对象key值的数组map遍历属性数组includes判断属性名字是否包含 ‘Time’this.addForm[item]判断属性值是否为空，避免moment返回 Invaild Date
（moment.js或时间处理工具需要判断，可忽略） let keys = Object.keys(this.addForm); keys.map(item =&gt;{ if(item.includes('Time') &amp;&amp; this.addForm[item]){ this.addForm[item] = moment(this.addForm[item]).format('YYYY-MM-HH HH:mm:ss') } }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d014b21aad8f40f05a433982bcac007/" rel="bookmark">
			全栈开发工程师面试题一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.JS的执行流程？（JS的运行机制）
同步任务：在主线程上排队的任务，前一个任务执行完毕，才能执行下一个任务。
异步任务：不进入主线程，是进入任务队列，只有任务队列通知主线程，某个异步就可以开始了，任务才会进入主线程去执行。
异步任务又分为宏任务和微任务：
宏任务：setTimeout，setInterval，整体代码script
微任务：Promise.then
执行顺序：先执行微任务后执行宏任务
JS中的事件循环：
1.先判断是同步任务还是异步任务，先执行同步任务，异步任务进入事件循环中Event Table
2.异步任务在Event Table注册事件，当满足触发条件的时候，会被推入Event Queue
3.同步任务进入到主线程中执行，当主线程中空闲时，才会去Event Queue中看是否有需要执行的异步任务，如果有就推入主线程中执行。
2.页面渲染过程
字节—字符----token----节点----Dom
html—DOM
css----CSSOM
渲染树
布局
绘制
3.浏览器工作原理
1)首先在浏览器中输入url地址
2)dns服务器会根据url地址查找对应的ip地址
3)根据ip地址找到对应的服务器
4)浏览器会通过tcp握手机制跟服务器进行连接
5)但是现在大多数都基于HTTPS协议的,那么会多一道TLS握手机制
建立加密的隧道，保证加密的内容不会被篡改和监听
6)浏览器会发送https请求来获取服务器请求，返回html代码
7)http中会先获取14kb代码
8)构建DOM树
9)构建CSSOM树
10)合并DOM和CSSOM
11)布局
12)绘制
注意：重绘和回流
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9535d87ebafde6f35e5f1d91ccfe0d2d/" rel="bookmark">
			实现history.back()返回后刷新历史页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		history.back()是在浏览器缓存中读取数据，后退到上一页保持原状态。但是如果上一页刚提交了什么东西，有弹框提示的话，那么在返回的时候，弹框会再次显示。
js方法解决:
可以将window.history.back()替换为
window.location.replace(document.referrer) 在大多数情况下，可以理解为返回上一页并刷新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5ea8a7430ab44642ba984750faa0113/" rel="bookmark">
			用C&#43;&#43;代码写一个自动签到程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下面是一个简单的 C 代码示例，实现自动签到功能：
#include &lt;stdio.h&gt; #include &lt;curl/curl.h&gt; int main(void) { CURL *curl; CURLcode res; curl = curl_easy_init(); if(curl) { curl_easy_setopt(curl, CURLOPT_URL, "https://www.example.com/signin"); /* 设置 POST 请求 */ curl_easy_setopt( 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7edda9453755fc3ad753e5c99d7f953/" rel="bookmark">
			静态路由的原理与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、路由概述二、路由器的工作原理三、路由器转发数据包的封装过程四、交换与路由对比五、路由器的基本配置 一、路由概述 路由是指路由器从一个接口上收到数据包，根据数据路由包的目的地址进行定向并转发到另一个接口的过程。路由通常与桥接来对比，在粗心的人看来，它们似乎完成的是同样的事。它们的主要区别在于桥接发生在OSI参考模型的第二层(数据链路层），而路由发生在第三层(网络层)。这一区别使二者在传递信息的过程中使用不同的信息，从而以不同的方式来完成其任务。
路由表存储着指向特定网络地址的路径。路由表中含有网络周边的拓扑信息。路由表建立的主要目标是为了实现路由协议和静态路由选择。路由表包含了路由器进行路由选择时所需要的关键信息。这些信息构成了路由表的总体结构.理解路由表的构成对我们进行路由维护和排错有重要意义，下面将讲述路由表的结构成分：
(1) 目的网络地址(Dest)：用于标识IP包要到达的目的逻辑网络或子网地址。
(2) 掩码(Mask)：与目的地址一起来标识目的主机或路由器所在的网段的地址.将目的地址和网络掩码”逻辑与”后可得到目的主机或路由器所在网段的地址.掩码由若干个连续”1”构成,既可以用点分十进制表示,也可以用掩码中连续”1”的个数来表示。
(3) 下一跳地址(Gw)：与承载路由表的路由器相邻的路由器的端口地址,有时也把路由器的下一跳地址称为路由器的网关地址。
(4) 发送的物理端口(interface)：学习到该路由跳目的接口,也是数据包离开路由器去往目的地将经过的接口.
(5) 路由信息的来源(Owner)：表示该路由信息是如何学习到的.路由表可以由管理员手工建立(静态路由表);也可以由路由选择协议(OSPF)自动建立并维护.路由表不同的建立方式也决定了其中路由信息的不同学习方式。
二、路由器的工作原理 路由器的工作原理就是：当一个数据包被路由器所接收时，路由器检查数据的IP地址，并判断这个数据包是用于它自己的网络还是其它网络。如果路由器判断这个数据包是用于它自己，它就会接收；如果不是用于它自己，这个数据包就会被拒绝。
三、路由器转发数据包的封装过程 假设2个用户第一次连接，互相不知道双方的MAC地址，且路由器也是新的
1.现在Host A想要发送数据给Host B，但是只知道对方的IP地址，于是发出arp广播包。四要素分别为：
源IP 192.168.1.1/24目标IP 192.168.2.2/24源MAC 00-11-12-21-11-11目标MAC ff-ff-ff-ff-ff-ff 2.RA收到后将HostA的MAC地址与对应的接口记录到R1路由表中，后用单播回复Host A，四要素 为
源IP 192.168.1.1/24目标IP 192.168.1.2/24源MAC 00-11-12-21-22-22目标MAC 00-11-12-21-11-11 HostA收到后将网关的MAC地址与接口号记录到arp缓存表中，重新向HostB发送数据帧，四要素为： 源IP 192.168.1.2/24目标IP 192.168.2.2/24源MAC 00-11-12-21-11-11目标MAC 00-11-12-21-22-22 RA的E0端口接收到数据帧 确认MAC 是给自己的 进行解封 ，并在IP层查询路由表 发现 数据包的目标网段是从E1端口转发的，于是将数据包转到E1端口，并在E1发送arp广播，四要素为： 源IP 10.1.1.1/24目标IP 192.168.2.2/24源MAC 00-11-12-21-33-33目标MAC ff-ff-ff-ff-ff-ff 5.RB的E1端口收到广播给RA单播回应arp包，四要素为：
源IP 10.10.1.2/24目标IP 10.1.1.1/24源MAC 00-11-12-21-44-44目标MAC 00-11-12-21-33-33 6.RA 收到后确认mac地址，确定是发给自己的，于是解封，将RB的MAC地址与接口号记录在路由表中，重新封装发送给HOSTB，四要素为：
源IP 192.168.1.1/24目标IP 192.168.2.2/24源MAC 00-11-12-21-33-33目标MAC 00-11-12-21-44-44 7.RB收到后确认MAC地址为自己后，解封，转给E0端口，E0端口查找路由表，没有找到目标IP对应的MAc地址，将数据包丢弃，并发出arp广播：
源IP 192.168.2.1/24目标IP 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7edda9453755fc3ad753e5c99d7f953/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77f5454f402fab792590ec498197a32a/" rel="bookmark">
			IDEA搭建一个完整的SpringBoot工程，成功访问数据库并实现简单登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步:搭建一个完整的springboot工程,并能通过浏览器访问 第二步:成功访问数据库,并实现简单登录 Idea20201.1 + maven 3.6.3 +jdk 8 +mysql 8.0搭建一个完整的springboot项目
第一步:搭建一个完整的springboot工程,并能通过浏览器访问
1.打开IDEA点击File-&gt;new-&gt;project；
2.完善项目信息，组名:nxz，项目名可做修改；最终建的项目名为：springboot-test，src-&gt;main-&gt;java下包名会是：com-&gt;nxz-&gt;springboot-test；注意Type选项是Maven，Java Version是8(匹配1.8jdk)，我第一次搭建的时候没注意，导致后面一直出问题，点击next；
3.Web下勾选Spring Web，有些版本没有这个选项，就选择Spring Web ；Template Englines勾选Thymeleaf；SQL勾选：MySQL Driver，JDBC API 和 MyBatisFramework三项；然后next
4.选择项目路径，点击finish；打开新的窗口；
5.点击右侧的Maven，点击设置（扳手图标）进行项目Maven仓库的配置；
(1）选择本地Maven路径；（2）勾选配置文件后边的选项，然后修改为本地Maven的配置文件，它会根据配置文件直接找到本地仓库位置；
6.配置完后，如果没有自动导包，可以点击左上角重新导包按钮，或者呢个下载按钮，选择下载所有源文件和文档
7.在templates文件下新建index.html页面，作为启动的初始页面；
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;hello&lt;/title&gt; &lt;/head&gt; &lt;body&gt; springboot测试启动页面！ &lt;/body&gt; &lt;/html&gt; 8.在com.nxzspringboot-test下新建controller文件夹，在controller文件夹下建一个简单的HelloController类；（Controller类要添加@Controller注解，项目启动时，SpringBoot会自动扫描加载Controller）注意：有些朋友new选项里面没有Package，选择java文件夹右键，找到Mark Directory as 选择Sources Root，把Java文件夹标记一下，然后再右键新建Controller文件夹就有Package这个选项了
package com.nxz.springboottest.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; @Controller public class HelloController { @RequestMapping("/index") public String sayHello() { return "index"; } } 9.在resources文件夹下application中先配置DataSource基本信息，application文件有两种文件格式，一种是以.properties为后缀，一种是以.yml为后缀的，两种配置方式略有差别，在这我是用.yml后缀的文件格式。右键application文件选择Refact，选择Rename，将后缀改为yml；（同样的注意自己的resources文件夹右下角有没有那个橘黄色小标记，没有的话自己Mark一下，选择resources root）
spring: datasource: name: text #数据库名 url: jdbc:mysql://localhost:3306/ry?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77f5454f402fab792590ec498197a32a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6c44e08a17689737ec144affacdde1e/" rel="bookmark">
			【正点原子FPGA连载】第三章GPIO之EMIO按键控制LED实验 摘自【正点原子】DFZU2EG_4EV MPSoC之嵌入式Vitis开发指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）实验平台：正点原子MPSoC开发板
2）平台购买地址：https://detail.tmall.com/item.htm?id=692450874670
3）全套实验源码+手册+视频下载地址： http://www.openedv.com/thread-340252-1-1.html
第三章GPIO之EMIO按键控制LED实验 PS和外部设备之间的通信主要是通过复用的输入/输出（Multiplexed Input/Output，MIO）实现的。除此之外，PS还可以通过扩展的MIO（Extended MIO，EMIO）来实现与外部设备的连接。EMIO使用了PL的I/O资源，当PS需要扩展超过78个引脚的时候可以用EMIO，也可以用它来连接PL中实现的IP模块。
本章我们将学习GPIO中EMIO接口信号的使用。本章包括以下几个部分：
33.1简介
3.2实验任务
3.3硬件设计
3.4软件设计
3.5下载验证
3.1简介 MPSOC GPIO接口信号被分成六组，分别是从BANK0到BANK5。其中BANK0， BANK1和BANK2共计78个信号通过MIO连接到MPSOC器件的引脚上，这些引脚属于PS端；而BANK3，BANK4和BANK5中共计96个信号则通过EMIO连接到了MPSOC器件的PL端。如下图所示：
图 3.1.1 GPIO框图
在大多数情况下，PS端经由EMIO引出的接口会直接连接到PL端的器件引脚上，通过IO管脚约束来指定所连接PL引脚的位置。通过这种方式，EMIO可以为PS端实现额外的96个输入引脚或96个带有输出使能的输出引脚。EMIO还有一种使用方式，就是用于连接PL内实现的功能模块（IP核），此时PL端的IP作为PS端的一个外部设备。
3.2实验任务
本章的实验任务是使用MPSOC开发板上的两个PS端按键控制PL端LED亮灭，两个PL端按键去控制PS端LED的亮灭。
3.3硬件设计
根据实验任务我们可以画出本次实验的系统框图，如下图所示：
图 3.3.1 系统框图
与《GPIO之MIO控制LED实验》中的系统框图相比，图 3.3.1中的PS端多了EMIO模块。除此之外，因为EMIO使用了PL端的IO资源，所以图中增加了PL部分。PL端与按键和LED相连的引脚直接通过EMIO连接到PS端。
step1：创建Vivado工程
本次实验可以在前一个实验的基础上进行。
1-1 我们打开《GPIO之MIO控制LED实验》中的Vivado工程“gpio_mio”，打开后在菜单栏中选择File &gt; Project &gt; Save As，如下图所示：
图 3.3.2 选择另存为
1-2 在弹出的对话框中输入新的工程名，在Project name一栏输入工程名“gpio_emio”，工程位置保持默认即可，如下图所示：
图 3.3.3 工程另存为
点击“OK”按钮，原先的Vivado工程会关闭，并打开一个新的工程“gpio_emio”。
此时如果我们打开工程所在的路径，即F:\ZYNQ\Embedded_System\gpio_emio，可以看到如下图所示的文件目录：
图 3.3.4 gpio_emio工程目录
此时我们就在gpio_mio工程的基础上得到了一个新的工程gpio_emio，这样就省去了重新搭建硬件的过程。
接下来我们将在《GPIO之MIO控制LED实验》中硬件设计的基础上搭建本次实验的硬件平台。
step2：使用IP Integrator创建Processing System
2-1在Flow Navigator中，点击IP INTEGRATOR下的Open Block Design，如下图所示：
图 3.3.5 打开Block Design
2-2 在Diagram窗口中，双击打开Zynq UltraScale+ MPSoC重定义窗口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6c44e08a17689737ec144affacdde1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80ac57475bd90bff65d89ab9210c1254/" rel="bookmark">
			心肺运动相关资料整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：肺功能相关参数 名称
释义
其他
潮气量(Tidal Volume,VT)
指平静呼吸时每次吸入或呼出的气量。
解剖无效腔/死腔
是指从鼻或口向下到末端细支气管水平的引导气道的总容积。
它包括鼻、口、鼻咽部、喉部、气管、支气管、细支气管和末细支气管。其容积约为150ml.
肺泡无效腔
Alveolar dead space
是指肺泡内不参与O2-CO2交换的空气所占据的空间。
肺泡死亡空间在健康个体中可以忽略不计，但在肺疾病患者中由于通气灌注不匹配可显著增加。
生理无效腔VD
Physiological dead cavity
是解剖无效腔和肺泡无效腔之和，是潮气量中不参与氧(O2)和二氧化碳(CO2)交换的部分。
生理无效腔（Vd/Vt）正常值：
正常人Vd/Vt为25%～33%。
机械（设备）无效腔
指外部呼吸设备中存在的死腔。包括喉罩通气管，气管导管，呼吸呼吸过滤器，呼吸回路y型接头。
尽量将机械死无效腔保持在最低限度，过多的机械死腔对测试者是不利的，也可能是致命的。
肺泡通气量（Alveolar Ventilation，VA）
指每次呼吸进入或呼出肺泡的气量，是直接进行气体交换的有效通气量。
等于（潮气量-无效腔气量）×呼吸频率。如潮气量是500ml，无效腔气量是150ml，则每次呼吸仅使肺泡内气体更新1/7左右。在潮气量减半和呼吸频率加倍或潮气量加倍而呼吸频率减半时，肺通气量保持不变，但是肺泡通气量却发生明显的变化。
每分钟通气量(Minute Ventilation Volume，MV)
指每分钟进或出肺的气体总量
每分钟通气量MV=潮气量VT×呼吸频率RR
每分钟肺泡通气量MVA=（潮气量VT-生理无效腔气量VE）×呼吸频率RR
呼气末二氧化碳ETCO2
呼气终末期呼出的混合肺泡气含有的二氧化碳分压或浓度值。
组织细胞代谢产生的CO2，经毛细血管和静脉运输到肺，在呼气时排出体外，体内二氧化碳产量（VCO2）和肺泡通气量（VA）决定肺泡内二氧化碳分压（PACO2），PACO2=VCO2×0.863/VA，0.863是气体容量转换成压力的常数。稍微偏低于PaCO2.
动脉CO2分压PaCO2
动脉血中物理溶解的CO2产生的张力，正常为35~45mmHg，反应通气功能的主要动脉血气指标。
指溶解在血液中的二氧化碳分子产生的压力，又称二氧化碳张力。
静息值=36-42mmHg，在轻度至中度运动时保持稳定或略有升高，高负荷运动时下降。
静脉血中的CO2分压PvCO2
称“静脉血二氧化碳分压”
PvCO2
2：无效腔概念 3：呼末二氧化碳ETCO2的检测原理 采用吸收光度法、显色法、质谱分析法、拉曼散射分析法对ETCO2进行检测。最常用的CO2监测仪是根据红外线吸收光谱的原理设计而成的，用以测定呼吸气体中的CO2浓度。当呼吸气体经过红外线传感器时，红外线光源的光束透过气体样本，并由红外线检测器测定红外线的光束量，因CO2能吸收特殊波长的红外线(4.3um)，光束量衰减程度与CO2浓度呈正比。最后经过微电脑处理获得PETCO2或呼气末二氧化碳浓度(CETCO2),以数字(mmHg或kPa及%)和CO2图形显示。
ETCO2的检测根据气体取样的不同，临床上常见的红外测量方法可分为旁流和主流两种。
检测方式
释义
优点
缺点
主流
通过测量室内的空气流动，而检测管道是人造气道的一部分。
优点是对气道中的水分、分泌物的影响不大，具有实时监测、无延迟、高准确度的特点。
其不足之处是，连续监测只能在气道封闭的情况下使用，且必须紧固，且易断裂。
旁流
被动流入测量室内，通过抽气泵将所述呼出的气体送到所述测量腔中进行测量。
优势是可以应用于不封闭的气道，取样位置多种多样。
不足之处是取样口容易受到空气中的水蒸气和分泌物的影响，而对于低流量的婴儿，由于吸入取样造成的空气损失，会影响到测量湿度和呼吸机的启动。
4：ETCO2波形分析 4.1 波形解释 二氧化碳测量仪器是以一种波形图（二氧化碳波形图）的形式向临床医生展现数据，该波形图反映的就是测量到的CO₂呼出量。了解二氧化碳波形图的判读就可以将其应用到通气过度或通气不足病患的管理，心肺骤停和气道漏气的预判，麻醉设备相关并发症的识别与排查。相较于其它麻醉监护设备，二氧化碳波形图可以提供更多关于病患状态的信息。
第一阶段(a→b):吸气和呼气的第一部分(来自主气道的气体)。呼气的起始部位是气道中的死腔气，在正常情况下，吸气时没有CO2，在呼气的开始，气体从主气道先呯出(没有CO2)。
第二阶段(b→c):持续呼气，比较笔直，是肺与死腔的混合气。表示气道气体与肺泡气体的混合。呼气中CO2快速升高趋于肺泡气中的含量。
第三阶段(c→d):肺泡呼气，称为肺泡平台期。在正常情况下，二氧化碳曲线是水平或微向上倾斜，称呼气平台，为混合肺泡气，平台终点为呼气末气流，为PETCO2值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80ac57475bd90bff65d89ab9210c1254/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10b34563ed731422e49f31ce0cd726c7/" rel="bookmark">
			VS编译报错 “无法解析的外部链接符号“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VS 2019编译报错，如下：
严重性	代码	说明	项目	文件	行	禁止显示状态 错误	LNK2001	无法解析的外部符号 "public: __cdecl planning::planner::HeadlanturndPath::~HeadlanturndPath(void)" (?? 1HeadlanturndPath@planner@planning@@QEAA@XZ)	HnAlgorithm	如果你已经排查了代码的各种问题，仍然不能解决，这里提供一种特别小白的一种情况。
检查一下你的VS项目中有没有添加相关的.cpp文件和.h文件。如果没有添加，也是编译不通过的。提示无法解析的外部链接符号。需要手动添加。
这种情况千年一遇，被我这个小白遇到了，还困扰了很久不能解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/992b2599c51103edc61833a6a483a38b/" rel="bookmark">
			Vue项目动态设置浏览器title
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 1.浏览器title根据选择的菜单名动态设置。
分析 浏览器的title，可以采用document.title赋值改变，所以改变单个页面可以在页面的钩子函数中使用document.title赋值直接改变！如果要改变所有的页面title明显以上方法不可行！综上可得出浏览器的title是采用document.title在赋值的，所以要想实现浏览器的title更具菜单名改变，就需要获取到菜单名赋值document.title即可，改变所有页面则不能挨个写到页面文件中！需要写到main.js中！菜单名就是在设置页面路由时的meta：{title：’我是菜单名‘}的值 ，要获取到路由相关参数，则需要考虑到路由导航守卫
before Each（to,from,next）{}每次路由跳转都会进入这个钩子，可以在这个钩子进行跳转前的拦截判断
参数说明：
to: 就是从哪个路由来from 到哪里去next（） 放行 实现： 使用 router. before Each 在main.js中获取到路由的title值在通过document.title赋值改变浏览器的title
说明：我项目中的路由的title采用的il8n统一管理，所以to.meta,title获取到的是il8n中的菜单名的对象取值字符串.则需要把il8n引入到main中在通过split方法把to.meta,title的值分割为数组，在通过对象取值把路的中文名匹配出来,如果你的路由名直接是汉字那就直接赋值不需要其他逻辑处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e81641dbc430775e1cb705e3e03541b8/" rel="bookmark">
			BEIT: BERT Pre-Training of Image Transformers论文解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BEIT: BERT Pre-Training of Image Transformers 论文：2106.08254.pdf (arxiv.org)
代码：unilm/beit at master · microsoft/unilm (github.com)
期刊/会议：ICLR 2022
摘要 本文介绍了一种自监督视觉表示模型BEIT，即图像transformer的双向编码器表示。继自然语言处理领域开发的BERT之后，我们提出了一个掩码图像建模(mask image modeling)任务来预训练vision transformer。具体来说，每张图像在我们的预训练中有两个视图，即图像补丁(image patch)(如16×16像素)和视觉标记(visual token)(即离散标记)。我们首先将原始图像“标记化(tokenize)”为视觉标记。然后我们随机屏蔽(randomly mask)一些图像补丁(image patch)，并将它们输入transformer骨干网络。预训练的目标是根据损坏的图像补丁恢复原始视觉标记。在预训练BEIT之后，我们通过在预训练的编码器上附加任务层，直接对下游任务的模型参数进行微调。在图像分类和语义分割上的实验结果表明，该模型与之前的预训练方法相比，取得了较好的效果。
1、简介 Transformer在计算机视觉中取得了良好的性能。然而，实证研究表明，Vision transformer比卷积神经网络需要更多的训练数据。为了解决数据饥饿问题，自监督预训练是利用大规模图像数据的一种有前途的解决方案。针对vision transformer已经探索了几种方法，如对比学习和自蒸馏。
同时，BERT在自然语言处理方面取得了巨大的成功。它的掩码语言建模任务(masked language modeling tasking)首先随机掩码文本中一定比例的token，然后根据损坏文本的Transformer编码结果恢复mask token。在BERT的激励下，我们转向去噪自动编码的思想来预训练vision transformer，这在视觉领域还没有得到很好的研究。直接将BERT-style预训练应用于图像数据具有挑战性。首先，对于vision Transformer的输入单元，即图像patch，没有预先存在的词汇表。因此，我们不能简单地使用一个softmax分类器来预测所有可能的mask patch候选。相比之下，语言词汇，如单词和BPE，定义良好，易于自动编码预测。一个简单的替代方案是将该任务视为一个回归问题，它预测被mask patch的原始像素。然而，这种像素级的恢复任务往往会浪费建模能力在预训练的短程依赖(short-range dependencies)和高频细节(high-frequency detail)。我们的目标是克服上述问题，进行vision transformer的预训练。
在这项工作中，我们介绍了一种自监督视觉表示模型BEIT，它代表图像transformer的双向编码器表示。受BERT的启发，我们提出了一个预训练任务，即掩模图像建模(masked image modeling, MIM)。如图1所示，MIM对每个图像使用了两个视角，image patch和visual token。我们将图像分割成一个由image patch组成的网格，这些patch是Transformer骨干网络的输入表示形式。此外，我们将图像“tokenize”为离散的visual token，这是由离散VAE的潜在代码获得的。在预训练过程中，我们随机mask一定比例的图像patch，并将mask后的图像输入到Transformer。该模型学习恢复原始图像的visual token，而不是mask patch的原始像素。
我们执行自监督学习，然后在两个下游任务(即图像分类和语义分割)上对预训练的BEIT进行微调。实验结果表明，BEIT优于从零开始训练和以前的强自监督模型。此外，BEIT是对有监督的预训练的补充。通过使用ImageNet标签进行中间微调，BEIT的性能可以进一步提高。消融实验表明，我们提出的技术对于图像数据的BERT-style预训练的有效性至关重要。除了性能外，改进的收敛速度和微调的稳定性降低了下游任务的训练成本。此外，我们证明了自监督BEIT可以通过预训练学习合理的语义区域，释放图像中包含的丰富的监督信号。
我们的贡献主要如下：
我们提出了一个掩码图像建模任务，以自监督的方式预训练vision transformer。我们还从变分自编码器(variational autoencoder)的角度进行了理论解释。我们预训练了BEIT，并对下游任务(如图像分类和语义分割)进行广泛的微调实验。我们提出了自监督BEIT的自注意机制学习区分语义区域和对象边界，尽管没有使用任何人工标注。 2、方法 给定一个输入图像 x x x, BEIT将其编码为情景化向量表示。如图1所示，BEIT由掩码图像建模(MIM)任务以自监督学习方式进行预训练。MIM的目标是基于编码向量恢复掩码图像patch。对于下游任务(如图像分类和语义分割)，我们在预先训练的BEIT上附加任务层，并对特定数据集上的参数进行微调。
2.1 图像表征 在我们的方法中，图像有两个表示视图，即image patch和visual token。这两种类型分别用作预训练期间的输入和输出表示。
2.1.1 image patch 二维图像被分割成一系列patch，因此标准Transformer可以直接接受图像数据。形式上，我们将图像 x ∈ R H × W × C x∈\R^{H×W ×C} x∈RH×W×C重塑为 N = H W / P 2 N = HW/P^2 N=HW/P2个patch x p ∈ R N × ( P 2 C ) x^p∈\R^{N×(P^2C)} xp∈RN×(P2C)，其中 C C C为通道数， ( H , W ) (H, W) (H,W)为输入图像分辨率， ( P , P ) (P, P) (P,P)为每个patch的分辨率。将图像patch { x p } i = 1 N \{x^p \}^N_{i=1} {xp}i=1N​平铺成向量并线性投影，这类似于BERT中的词嵌入。图像patch保存原始像素，并用作BEIT的输入特征。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e81641dbc430775e1cb705e3e03541b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86bc32c2590d559923a1e4caeeb29130/" rel="bookmark">
			【C语言】带你回顾C语言全部运算符（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言运算符优先级顺序表1.算数运算符2.移位运算符（1） 左移操作符：（2）右移操作符： 3.位操作符4.赋值运算符5.单目操作符5.1 介绍5.2 sizeof与数组 6.关系操作符7.逻辑操作符8.条件操作符9.逗号表达式10.下标引用、函数调用和结构成员 完结 前言 ​ 🌞🌞想要学好C语言，操作符是非常重要且必不可少的一部分内容，操作符分为算数运算符、移位操作符、位操作符、赋值操作符、单目操作符、关系操作符、逻辑操作符、条件操作符、逗号表达式、下标引用，函数调用和结构成员。
操作符的基本特性 每个操作符都有自己的语义每个操作符都有对应的优先级，如果两个操作符挨在一块，先执行优先级高的操作符，如果优先级相同，取决于他们的结合性。每个操作符都有结合性。 操作符的结合性定义了操作符对操作数执行操作的顺序，例如：右结合性表示该操作符对其操作数从右向左执行操作。 运算符优先级顺序表 1.算数运算符 + - * / % 这是最常见的几个操作符，但还是有一些要注意的点：
（1）对于+、-、*、/来说，如果操作符的两个操作数其中一个操作数是小数，则执行小数运算，如果都为整数，则进行整数运算。
（2）%的两个操作数必须都为整数，否则会报错，其他四个操作符则都可以。
（3）的语言/、%，0不能当除数或者模数 (这应该是个数学问题)。
2.移位运算符 ​ &lt;&lt; &gt;&gt; （&lt;&lt;是向左移位、&gt;&gt;是向右移位） 注意：移位操作符不能移动负数位
（1） 左移操作符： 移位规则：左边抛弃、右边补零。
​ 移位操作符是对操作数的二进制位进行移位，比如对一个int型数据8进行移位的话：
（2）右移操作符： 移位规则：右边抛弃，左边用该值的原符号位填充
​ 右移操作符同理也是对操作数的二进制位向右进行移动，如果是整数，符号位为0，则左面填充0，如果为负数，符号位为1，则左面填充1
3.位操作符 &amp;（按位与） |（按位或） ^（按位异或） (这些操作符的操作数必须为整数) ​ 位操作符，如同名字一样，也是对操作数的二进制位进行对应的操作
一道小的练习题:（可以根据上面表格进行运算）
\#include &lt;stdio.h&gt; int main() { int num1 = 1;	//二进制00000000 00000000 00000000 00000001 int num2 = 2;	//二进制00000000 00000000 00000000 00000010 num1 &amp; num2;	//0 num1 | num2;	//3 num1 ^ num2;	//3 return 0; } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86bc32c2590d559923a1e4caeeb29130/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7b06a573c4037569ee8266f237faabf/" rel="bookmark">
			Python中除法(/或//)操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中分为3种除法：传统除法、精确除法、地板除。 传统除法
如果是整数除法则执行地板除，如果是浮点数除法则执行精确除法。
精确除法
除法总是会返回真实的商，不管操作数是整形还是浮点型。执行from __future__ import division 指令就可以做到这一点。
地板除
从Python2.2开始，增加了一个操作符 // ，以执行地板除：//除法不管操作数为何种数值类型，总是会舍去小数部分，返回数字序列中比真正的商小的最接近的数字。
内建函数divmod()
divmod (a,b)，返回(a//b,a%b)
/或// python中除法的语法形式为：
’/’
’//’
python中除法的类型为：
传统除法(divide)
Floor除法(floor_division)
真除法(true_divide)
除数和被除数的类型组合：
都为整数
一整一浮点
都为浮点
除法的范围结果：
整数
浮点数（取整浮点数，带余数浮点数）
有两种除法运算符：’/’和’//’；
有三种类型的除法：传统除法(divide)、Floor除法(floor_division)和真除法(true_divide)
概括来讲
在Python 3.0中
/现在总是执行真除法，不管操作数的类型，都返回包含任何余数的一个浮点数。
//执行Floor除法，首先肯定为向下取整，并且针对整数操作数返回一个向下取整整数，如果有任何一个操作数是浮点类型，则返回一个向下取整浮点数。
在Python 2.7中
/表示传统除法，如果两个操作数都是整数的话，执行截断的整数除法，返回整数；否则，执行浮点除注(保留余数)，返回浮点数。
//执行Floor除法，首先肯定为向下取整，并且像在Python 3.0中一样工作，并且针对整数操作数返回一个向下取整整数，如果有任何一个操作数是浮点类型，则返回一个向下取整浮点数。
总结：
/在python2.7中表示传统除法，在python3.0中表示真除法
//在python2.7和python3.0中都表示Floor除法
Numpy中除法 divide函数在整数和浮点数除法中均只保留整数部分
true_divide函数与数学中的除法定义更为接近，即返回除法的浮点数结果而不作截断
floor_divide函数总是返回整数结果，相当于先调用divide函数再调用floor函数。floor函数将对浮点数进行向下取整并返回整数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bcd0dc46a6e347ef22cac8d677f5c34/" rel="bookmark">
			python去除马赛克
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果你想去除图像中的马赛克，你可以使用 OpenCV 库中的图像处理功能。你可以对图像进行降噪，然后使用不同的滤波器，例如中值滤波器，来去除马赛克。
代码示例：
import cv2img = cv2.imread("mosaic.jpg") img = cv2.medianBlur(img, 5) cv2.imwrite("mosaic_removed.jpg", img) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa38bafdcad9ac6c03fcb7d10ca448cd/" rel="bookmark">
			Vue3详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue 3 介绍 文章目录 Vue 3 介绍为什么要学习 vue 3Vue3 动机 和 新特性 Vite 的使用vite介绍为什么选 Vite ？Vite 的基本使用Vue3.0项目介绍vscode插件说明 组合式APIcomposition API vs options API体验 composition APIsetup 函数reactive 函数ref 函数script setup语法(★)计算属性computed函数侦听器watch函数钩子函数的使用组件通讯-父传子组件通讯-子传父依赖注入 - provide 和 inject模板中 ref 的使用vue3中废弃了过滤器补充-toRefs 函数 vue-router4基本使用组件中使用route与router vuex4基本使用在组件中使用vuex 为什么要学习 vue 3 为什么要学vue3:
Vue是国内最火的前端框架Vue 3 于 2022 年 2 月 7 日星期一成为新的默认版本! 原文链接：https://blog.vuejs.org/posts/vue-3-as-the-new-default.html中文链接：https://zhuanlan.zhihu.com/p/460055155 Vue3性能更高，体积更小Vue3.0在经过一年的迭代后，越来越好用 官方文档：
vue3官方文档：https://vuejs.org/vue3中文文档：https://v3.cn.vuejs.org/ 目前已支持 vue3 的UI组件库:
element-plus
https://element-plus.gitee.io/#/zh-CN (PC组件库)
Element Plus，一套为开发者、设计师和产品经理准备的基于 Vue 3.0 的桌面端组件库。
vant
https://vant-contrib.gitee.io/vant/v3/#/zh-CN
轻量、可靠的移动端 Vue 组件库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa38bafdcad9ac6c03fcb7d10ca448cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fd87712e3e8a53da59c62ea6cc675f5/" rel="bookmark">
			指针赋值问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近写了个代码，被日本客户指出来有问题，对此做了一项研究。
我最开始的时候写的是：
char *pointer = NULL;
pointer = “string”;
printf(“%s\n”, pointer);
日本客户指出，pointer当前没有分配空间，给它赋值是不规范的操作。
其实这个客户说的也不对，并不是没有分配空间，这个指针变量是有空间的，他的内存大小就是指针变量的大小。第二句话里，将一个字符串常量的地址赋值给了这个指针变量。如果使用时仅仅是用来做打印，那么不会有任何问题。
真正的问题在于，此时如果想修改pointer中的值，就会导致Segmentation fault (core dumped)。
对此，进行进一步的研究与分析：
首先写了一个demo：
#include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() { char *pointer_1 = NULL; char pointer_2[20] = {0}; char pointer_3[] = "string_init"; pointer_1 = "string_init"; //pointer_2 = pointer_3; strcpy(pointer_2, pointer_3); printf("pointer_1: %s, %p\n", pointer_1, pointer_1); printf("pointer_2: %s, %p\n", pointer_2, pointer_2); printf("pointer_3: %s, %p\n", pointer_3, pointer_3); printf("%d\n", *pointer_1); printf("%d\n", *pointer_2); printf("%d\n", *pointer_3); //*pointer_1 = 83; *pointer_2 = 83; *pointer_3 = 84; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fd87712e3e8a53da59c62ea6cc675f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8446495ebd173f532062c224bbd0b74/" rel="bookmark">
			全球化安全生产 &amp; 质量保障体系建设探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：肖刚毅、张俊、李晶磊（全球化业务平台团队）
全球化电商中的业务、技术及架构和国内技术都有一定差异，从安全生产保障和质量保障角度，这些差异带来了更多的挑战，本文将为大家分享安全生产和质量保障相关的经验。
一、前言 作为有丰富国内电商技术沉淀的团队，在服务全球化电商业务中，一方面会自然传承国内电商技术体系去解决电商业务通用问题。另一方面，面对业务、技术、组织、文化、政策等维度差异，促使我们演进新的或更合适的技术体系。比如，国际电商业务发展的阶段特征、海外基础设施特征、国际业务区别国内业务的特征、用户和文化特征、以及更不可控的政策和合规等。在我们摸索多年形成的技术体系中，我们上一篇分享讲解了开发技术和架构相关经验，在本文中，我们想分享技术领域不可或缺的另一大块，安全生产和质量保障相关的经验。
分享技术经验以前，我们先把所服务的全球化电商这个对象，在一些关键维度稍作拆解，也是多年经验对全球化电商的一些关键特征的理解，而这些理解对我们的技术构建是至关重要的。
1.1 业务差异 在业务上，全球化电商主要有本对本和跨境两种最基本的类型。
东南亚电商品牌Lazada就是典型的海外本对本业务，主要实现在国外某国或地区，敏捷的构建一套支持本地买卖家交易的电商系统。这样的模式，决定了商家大部分在海外国本地，币种会相对单一，运营能力需要更加本地化等等。
跨境电商品牌AliExpress就是典型的跨境模式业务，主要实现中国商家能在中国货品优势下通过我们的系统将货物销售给跨境的买家，这里涉及的问题会大不相同。从语言、币种、时差、品类、活动、汇率差、物流、供应链等方面，我们需要有种种差异的技术解决差异的问题。电商业务，主要由电商系统、支付系统、物流系统组成，这三大系统的国际技术实现和国内技术实现都有一定差异。
1.2 技术架构差异 在技术和架构方面，也有显著区别：
基础架构差异：海外电商服务的对象大部分场景是跨国家的，同时海外的硬件设施和国内是有差异的。所以我们的系统要在考虑稳定的前提下，更低成本的实现数据同步、系统可复用、合规等等。这里我们的技术关键词是多单元部署、多机房部署、云原生。这些点对我们构建的质量体系的差异，十分关键。
应用架构差异：在电商技术领域，我们常常是通过不同的应用或微服务，构建出一套大的技术系统网，各个应用依据各自的领域拆分而来。区别国内电商的是，我们的应用或服务需要考虑站点，也就是国家站，甚至一个服务器同时通过多个域名服务多个国家站。除此之外，在应用架构上，敏捷中台如何支持好业务的问题中，我们设计了教堂&amp;集市的应用架构，让应用的灵活度和研发生产关系实现了质的提升。同时，也对如何保障好系统质量和稳定性提高了要求。
研发过程差异：中台需要尽可能抽象和合并电商逻辑，但国家差异化的本质一定会推演出大量国别定制需求，也因此而形成更复杂的组织架构，无论是本对本的业务，还是跨级业务中的本地化运营。所以我们的系统会同时有更多的、更接近电商用户的工程师一起开发。我们需要实现更灵活的应用编排、代码并行编写、隔离发布、流量调度等能力。在更灵活、更大型的研发过程中，质量把控的难度自然上了一个阶梯。
运行态差异：考虑到QPS特征等，在运行态，从成本和效能的角度，我们实现了多租户并行和架构隔离。这也决定了我们系统在复杂度、可测性、问题排查、测试环境、自动化、数据构造等方面的工作会更加复杂。
数据同步差异：即便我们的系统在运行态可能是租户复用的，但在数据上，考虑隐私、安全、合规、性能、可扩展等，我们是按站点进行物理或逻辑隔离的。在跨境场景中，要实现中国的商品在全球可以快速访问，必然需要实现秒级的数据同步能力。这对系统的稳定性带来了难度，也提高了测试用例的复杂性。
这些差异，有的天然由业务属性决定。有的是我们从技术上解决业务或架构问题时带来的新问题。从安全生产保障和质量保障角度，这些差异给我们带来了更多挑战，也是技术创新的机会，这也正是整个全球化技术体系的内核。
二、安全生产体系 2.1 全球化高可用架构概述 系统可用性(Availability) 最早在Patrick O‘Connor的 Practical Reliability Engineering 一书被提出。
其中，MTTR 为 Mean Time To Repair，即系统故障后平均修复时间，表示系统可维护性。MTBF 为 Mean Time Between Failure，即平均非故障时间，表示系统可靠性。
因此，保障系统实现日常态高可用主要分为两个方向：提升MTBF，增加系统非故障时间，通过保持稳定性模式、系统冗余等手段，提升整体系统可靠性&amp;容错性。以及，降低MTTR，缩短故障恢复所需时间，从事故、变更、监控运维等方便，增加系统可维护性。
除了上述两个日常态高可用建设方向，对于大型电商系统，大促时如何在洪峰冲击下保持服务高稳态，大促前又如何在相对短暂的备战阶段摸清系统瓶颈，掌握全局核心链路，也是高可用体系构建中不可忽视的一环。
因此，本文将分为三个领域对全球化高可用架构展开论述：
高可用体系建设
大促稳定性保障建设
应用高可用架构
2.2 高可用体系建设 目前业界通用衡量高可用的标准是1-5-10。1分钟发现，5分钟响应/定位，10分钟恢复。在过往的实践中，1-5-10的达成，非常依赖SRE团队，团队的业务熟悉程度、问题排查手段，实操的熟练程度。不过随着系统的复杂度越来越高，链路依赖关系越来越复杂，1-5-10对SRE团队的要求越来越高。
高可用故障跟业务故障是有一定的区别，高可用故障是有通用性的。围绕着故障，我们可以做有针对性的布防。接下来我们介绍的是在国际化板块，我们围绕着故障定义建设的一套高可用故障体系。
下面我们将从一个交易下单成功率下跌的故障来分析整个高可用体系处理的过程。先假设存在一个故障定义：下单成功率下跌 5%持续10分钟。
2.2.1 一分钟发现 在故障发现的场景，过往是等待下跌了5%持续10分钟才会发出故障通告。SRE团队开始介入问题的处理。
下单成功率下降了 1%、2%的时候，或者下跌了5%持续了5分钟的时候，大家是缺少感知的。我们希望将故障响应的时间提前。提前到系统指标发生异常的时候就开始介入。
我们在系统指标异常发现之后，在故障发生之前，加入了风险预警的机制（图1实线所示）。风险预警由GOC触发，触发后 SRE团队开始介入问题的处理。这样问题很有可能在故障发生时，完成风险的解除。
图1 风险预警流程与原故障应急流程对比
2.2.2 五分钟定位 当问题发现后，我们需要尽快的定位原因。高可用故障，分为两类：变更类与运行类。
这两类故障的定位，都需要知道几个信息：
故障关联的系统有哪些，及其依赖关系？
当前报错是哪个系统导致的，哪个是表象哪个是根因？
故障是否存在相关的变更：时间相关、范围相关？
图2 五分钟定位产品
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8446495ebd173f532062c224bbd0b74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d53952d6db53434bbf977a755621399/" rel="bookmark">
			【cmd命令】输出文件夹下文件名字列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.WIN+R打开命令框，输入cmd进入命令框
2.输入目标文件夹的路径下
3.输入指令：dir /b &gt;list.txt
【list.txt】是将要输出文件名字列表保存下来的文件名
输出结果：
※：【dir /b /s &gt;list.txt】输出所有子目录文件夹和文件名
【全文完】
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/169/">«</a>
	<span class="pagination__item pagination__item--current">170/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/171/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>