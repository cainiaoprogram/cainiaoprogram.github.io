<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0ad57e1d13bff7e1287074b43d38301/" rel="bookmark">
			解决fiddler设置手机代理后无法上网问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不完全解决fiddler设置手机代理后无法上网问题 一、手机代理要设置正确二、修改注册表三、修改Fiddler Rules四、重新启动Fiddler 首先说一下，fiddler的一些设置，如连接设置、端口设置、安装证书等，网上有详细教程，本篇就不说了。本篇的主要内容是解决fiddler设置了 手机代理后无法上网的问题，电脑是 windows系统，软件是Fiddler Classic -------------------------------2022/9/26 分割线----------------------------------
实测部分app能上网，我试了津心办可以正常登录，因为当时coding的时候就是为了爬津心办
一、手机代理要设置正确 手机连接电脑开出的WiFi长按手机的WiFi按钮，选择刚刚连接的WiFi，然后进行代理设置(不同型号的手机找到设置界面的方法稍有不同，请进行对应的搜索)电脑打开cmd，输入ipconfig，找到对应的(无线局域网)ipv4，这就是要输入的代理主机名。以下是我电脑上的截图 输入端口号，默认8888；如果改了，填入改了后的端口号 二、修改注册表 打开注册表(cmd输入regedit等方法都行)，找到计算机\HKEY_CURRENT_USER\Software\Microsoft\Fiddler2这一项右键新建QWORD，输入80 结果如图所示
三、修改Fiddler Rules 打开Fidder Classic，按下Ctrl R组合键，出现如下Fiddler ScriptEditor 2. 按下Ctrl F组合键，输入OnBeforeRequest，按下enter后，输入
if (oSession.host.toLowerCase() == "webserver:8888") { oSession.host = "webserver:80"; } 按下Ctrl S组合键保存 结果如图所示
四、重新启动Fiddler 完成以上三步后，重启fiddler，重新抓包。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/055b8cb83673c3eb254cfdf9df1bf167/" rel="bookmark">
			什么是Web3.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言-Web3时代来临 从下图google近两年Web3关键词搜索量的走势图可以看出，Web3关键词在2021年9月前搜索量比较平缓，突然从2021年10后搜索量骤增，在2022年1月达顶峰，为什么会出现这种现象呢？
原因是期间出现了2个大事件：
1、2021年10月28日，月活破30亿的Facebook正式官宣改名为Meta，元宇宙和Web3等概念正式从币圈破圈；
2、2021年12月8日，美国众议院加密金融听证会有议员喊出“确保Web3.0革命发生在美国”，引发各国政府和企业关注；
另外一个原因就是第二次互联网泡沫的破裂；
众所周知，移动互联网红利已消失殆尽，再靠烧钱抢用户模式大战很难维持下去，每天都有互联网公司裁员倒闭破产，近期倒闭的每日优鲜就是典型例子;
互联网大厂利润日益下滑，裁员潮引发人人自危，对行业充满了担忧；
Web3概念的出圈给互联网人带来了新的希望，大量的互联网大厂离职人员纷纷加入或创业Web3公司，就连Z时代、00后甚至大学生抛弃了互联网大厂，纷纷关注并参与Web3行业，似乎Web3明天就能实现；
国内外互联网大厂为了摆脱发展瓶颈，纷纷注册了元宇宙公司，成立了Web3部门，加入Web3革命的浪潮；
2022年7月13日，上海市政府发布《上海市数字经济发展“十四五”规划》，明确支持发展Web3和元宇宙等新兴行业；
那么到底什么是Web3呢，引发这么多政府、行业牛人、投资机构青睐；
下面从概念和发展历史详细介绍Web3；
要想理解Web3，需要先了解Web是什么
Web是什么 Web全称为World Wide Web，缩写WWW ，即全球广域网，也称为万维网
表现形式:
超文本(Hyper Text)超媒体(Hyper Media)超文本传输协议HTTP(Hyper Text Transfer Protocol)
万维网、因特网和互联网的区别 互联网 &gt; 因特网 &gt; 万维网
互联网：凡是由能彼此通信的设备组成的网络就叫互联网，即使仅有两台机器（计算机、手机等），英文为internet，注意是小写的i；
因特网：因特网是互联网中的一种，使用TCP/IP协议让不同的设备可以彼此通信，由成千上万台设备组成的网络，英文为Internet，注意是大写的i；
因特网主要服务有万维网(WWW)、文件传输（FTP)、电子邮件E-mail、远程登录（Telnet）等
万维网：只要应用层使用的是HTTP协议，就称为万维网，英文为Web；
Web全称为World Wide Web，缩写WWW ，即全球广域网，也称为万维网
Web诞生历史 1946年2月14日，世界第一台现代计算机ENIAC在美国宾夕法尼亚大学诞生1969年最早的互联网(internet)阿帕网(ARPANET)在美国诞生，只连接了4台计算机1983年1月1日，阿帕网和国防数据网络正式改为TCP/IP标准，因特网(Internet)诞生1989年蒂姆·伯纳斯·李（Tim Berners-Lee）开发出世界上第一个Web服务器和第一个Web客户端1991年8月6日蒂姆·伯纳斯·李建立世界上第一个网站http: //info. cern. ch/，万维网Web诞生 什么是Web3.0 2020年，万维网之父Tim Berners Lee说“互联网的精神应该是去中心化的，但现在一些公司已经把互联网当成了垄断联盟”
Web3.0是互联网的下一个时代（价值互联），
本质是去中心化的互联网，把经济体系嵌入到互联网，
基于区块链技术实现价值的流通与重新分配。
Web3.0是一个全面的体系，它要实现从存储、协议、网络、机制、应用以及生产方式、组织方式、分配方式的变革,
它不仅改变了生活（包括金融、认证、票据、政务、版权、溯源、医疗、公益、商务、组织方式等诸多方面），
还延展了想象（如游戏、元宇宙等领域）；
Web3.0不是具体技术，实现它需要用到区块链、人工智能、物联网、通信技术、硬件发展、云计算等技术；
2020年被称为DeFi年，DeFi(Decentralized Finance)去中心化金融2021年被称为NFT年和元宇宙元年2022年被称为DAO年，Web3时代全面开启 Web3 = DeFi + NftFi + GameFi + SocialFi + DAO + 元宇宙 + … + … ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/055b8cb83673c3eb254cfdf9df1bf167/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd4fc00cfebf5c9ee9d14812b1be9e22/" rel="bookmark">
			jsp大文件(百M以上)的上传下载实现技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里只写后端的代码，基本的思想就是，前端将文件分片，然后每次访问上传接口的时候，向后端传入参数：当前为第几块文件，和分片总数
下面直接贴代码吧，一些难懂的我大部分都加上注释了：
上传文件实体类：
看得出来，实体类中已经有很多我们需要的功能了，还有实用的属性。如MD5秒传的信息。
首先是文件数据接收逻辑，负责接收控件上传的文件块数据，然后写到服务器的文件中。控件已经提供了块的索引，大小，MD5和长度信息，我们可以根据需要来灵活进行处理，也可以将文件块的数据保存到分布式存储系统中。
文件初始化部分
第一步：获取RandomAccessFile,随机访问文件类的对象
第二步：调用RandomAccessFile的getChannel()方法，打开文件通道 FileChannel，这块逻辑可以优化，如果以后有分布式存储需求，可以改为分布式存储，减轻单台服务器的压力。
第三步：获取当前是第几个分块，计算文件的最后偏移量
第四步：获取当前文件分块的字节数组，用于获取文件字节长度
第五步：使用文件通道FileChannel类的 map（）方法创建直接字节缓冲器 MappedByteBuffer
第六步：将分块的字节数组放入到当前位置的缓冲区内 mappedByteBuffer.put(byte[] b);
第七步：释放缓冲区
第八步：检查文件是否全部完成上传
文件夹扫描类
存储路径生成类
好了，到此就全部结束了，如果有疑问或批评，欢迎评论和私信，我们一起成长一起学习。
最后放一张实现的效果图
后端代码逻辑大部分是相同的，目前能够支持MySQL,Oracle,SQL。在使用前需要配置一下数据库，可以参考我写的这篇文章：http://blog.ncmem.com/wordpress/2019/08/07/java超大文件上传与下载/ 欢迎入群一起讨论“374992201”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a7d0117077ee6690ec759bfc7a5e8a7/" rel="bookmark">
			‘grep‘ 不是内部或外部命令，也不是可运行的程序或批处理文件。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、输入adb命令二时遇到的问题：
二、简单了解下原因：grep是linux系统下的命令，windows不支持该命令。 三、解决方案
方式一：用findstr代替grep
方式二：命令稍作改动 adb shell "logcat |grep -i displayed" 方式三：先进入adb shell，在shell下再输入命令行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ed1df4d1a5e7481df96cc1306dd5a5c/" rel="bookmark">
			Pytorch清空显存缓冲区(torch.cuda.empty_cache)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 torch.cuda.empty_cache() 因为PyTorch是有缓存区的设置的，意思就是一个Tensor就算被释放了，进程也不会把空闲出来的显存还给GPU，而是等待下一个Tensor来填入这一片被释放的空间。所以我们用nvidia-smi/gpustat看到的显存占用不会减少
用torch.cuda.empty_cache可以清空缓冲区
在程序中加上这句会使速度变慢一些，但是有些情况下会有用，例如程序之前test的时候总是爆显存，然后在循环中加上了这句就不爆了
for i, data in enumerate(data_loader): torch.cuda.empty_cache() img_meta = data['img_meta'][0].data[0] img_name = img_meta[0]['filename'].split('/')[-1] with torch.no_grad(): result = model(return_loss=False, rescale=not show, **data) 如果显存资源比较紧缺，可以在每个epoch开始时释放下不用的显存资源。
torch.cuda.empty_cache() # 释放显存 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fcca269351e80d0a5f1363d541daaa9/" rel="bookmark">
			Python 中的 Plotly 是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Plotly Python 库是一个交互式开源绘图库，支持 40 多种独特的图表类型，涵盖广泛的统计、金融、地理、科学和 3 维用例。
Plotly 的 Python 图形库制作交互式、出版质量的图形。如何制作折线图、散点图、面积图、条形图、误差线、箱线图、直方图、热图、子图、多轴图、极坐标图和气泡图的示例。 Plotly.py是免费和开源的，您可以在 GitHub 上查看源代码、报告问题或贡献。
plotly.express 模块（通常作为 px 导入）包含可以一次创建整个图形的函数，称为 Plotly Express 或 PX。Plotly Express 是 plotly 库的内置部分，是创建最常见图形的推荐起点。每个 Plotly Express 函数在内部使用图形对象并返回一个 plotly.graph_objects.Figure 实例。在整个 plotly 文档中，您会在任何适用页面的顶部找到构建图形的 Plotly Express 方法，然后是有关如何使用图形对象构建相似图形的部分。使用 Plotly Express 在单个函数调用中创建的任何图形都可以单独使用图形对象创建，但代码量要多 5 到 100 倍。
建立在 Plotly JavaScript 库 (plotly.js) 之上，plotly 使 Python 用户能够创建漂亮的基于 Web 的交互式可视化，这些可视化可以显示在 Jupyter 笔记本中，保存到独立的 HTML 文件中，或者作为纯 Python 构建的 Web 的一部分使用 Dash 的应用程序。plotly Python 库有时被称为“ plotly.py ”，以区别于 JavaScript 库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fcca269351e80d0a5f1363d541daaa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5413a2ebb6f76399fe0f3284e3cadd2d/" rel="bookmark">
			【笔记】Canny算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理 Canny算子用于边缘检测，图像的边缘是图像内容变化很快的高频部分。信号变化的快慢可以用梯度直观地表示，因此检测边缘，就是更好地寻找大梯度位置。
Canny算子 Canny算子是由John F. Canny 于 1986年开发出来的一个多级边缘检测算法，被认为是最好的边缘检测算法，在没有特殊要求的情况下，应为首选算法。
Canny同时提出了评估边缘检测算法的标准：
错误更少。检测出尽可能多的边缘，检测出的边缘尽可能都不是误报；响应更少。图中的边缘只响应一次。定位更准。检测出的边缘尽可能靠近图像的真实边缘； Canny算子设计时同样遵循这3条规则，分为4个步骤：
高斯模糊去噪；计算梯度幅值、方向非极大值抑制，去除边缘杂散响应，得到候选边缘迟滞阈值，确定强响应边缘和弱响应边缘，从若相应边缘提取强响应边缘。 模糊去噪 噪声与边缘一样，属于图像中的高频部分，使用高斯模糊、中值模糊等可以有效去除噪声。
计算梯度幅值和方向 这是边缘检测算法的核心与本质。求梯度时，对于连续信号使用求导，对于图像等离散信号使用差分（Sobel算子、Laplace算子等）。此处选用可以生成更粗大明亮边缘的Sobel算子作为示例。
a.选定Sobel算子；
S x = [ − 1 0 + 1 − 2 0 + 2 − 1 0 + 1 ] ， S y = [ − 1 − 2 − 1 0 0 0 + 1 2 + 1 ] S_x=\left[ \begin{matrix} -1 &amp; 0 &amp; +1 \\ -2 &amp; 0 &amp; +2 \\ -1 &amp; 0 &amp; +1 \end{matrix} \right]，S_y=\left[ \begin{matrix} -1 &amp; -2 &amp; -1 \\ 0 &amp; 0 &amp; 0 \\ +1 &amp; 2 &amp; +1 \end{matrix} \right] Sx​=⎣ ⎡​−1−2−1​000​+1+2+1​⎦ ⎤​，Sy​=⎣ ⎡​−10+1​−202​−10+1​⎦ ⎤​b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5413a2ebb6f76399fe0f3284e3cadd2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9733461111b8713c48af0d70ceb7d2e3/" rel="bookmark">
			移动端的AI部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、背景 移动设备相较于 PC ，携带便携，普及率高。近年来，随着移动设备的广泛普及与应用，在移动设备上使用深度学习技术的需求开始涌现。
手机作为最靠近用户、最普及的终端落地，越来越多的算法模型应用到移动端上面，如何高效的把模型部署在移动端成为了急需解决的问题。
1.1、在线模式 在移动端进行简单的预处理之后，然后上传用户数据(图片、文字、语音、视频等)至云端服务器，通过服务器强大的算力得到推理结果，随后将推理结果下发至端设备。
1.2、离线模式 服务器上训练好的模型经过移动端深度学习框架(TensorFlow Lite、NCNN、TNN、MNN、CoreML等)量化压缩、转化后，在移动端设备上进行预测。这种方式在无网络连接的情况下即可实现，保证用户的隐私性。
1.3、不同平台推断差异 在线模式和离线模式的推理平台有所不同，不同平台的推断差异如表1-1所示。
表1-1 不同平台的推断差异
问题维度基于端设备推断基于云端服务器推断延迟性低延时，实时体验由于存在异步通信和传输带宽的影响，有一定的延迟资源能力cpu/gpu处理能力，设备的算力有限，存储空间受限云端服务器的算力强大，储存空间充足网络连接网络不佳的或者没有的情况下，可以离线运行需要网络连接才可以运行成本问题电池电量、下载模型所需要的时间数据传输带宽，公司云端服务器的运营和服务成本隐私问题不需要上传用户数据(图片、视频、语音、文字等)到云端服务器用户数据上传云端服务器，隐私性无法保障 2、部分移动端AI推理框架 2.1、TensorFlowLite １、开源时间：2017年11月(持续更新)
２、开源用户：谷歌
３、GitHub地址
４、简介：
TensorFlow Lite是为了解决TensorFlow在移动平台和嵌入式端过于臃肿而定制开发的轻量级解决方案，是与TensorFlow完全独立的两个项目。TensorFlow Lite则实现了低能耗、低延迟的移动平台机器学习框架，并且使得编译之后的二进制发布版本更小。 TensorFlow Lite不仅支持传统的ARM加速，还为Android Neural Networks API提供了支持，在支持ANN的设备上能提供更好的性能表现。
5、架构
6、优缺点分析
优点
1)、支持Android&amp;ios，跨平台，得益于Tensorflow强大的生态
2)、容易扩展，TFLite增加Tensorflow的算子相对容易
3)、更小二进制文件库大小，依赖少缺点
1)、目前主要支持CNN网络相关算力，对RNN的模型算子的支持偏少
2)、对运算芯片的优化少，没有做针对性优化
3)、仅支持Tensorflow模型的转换，对其他框架训练的模型无法转换 2.2、NCNN 1、开源时间：2017年7月(持续更新)
2、开源用户：腾讯
3、GIthub地址
4、简介：ncnn 从设计之初深刻考虑手机端的部署和使用，无第三方依赖，跨平台，手机端 CPU 的速度快于目前所有已知的开源框架。基于 ncnn，开发者能够将深度学习算法轻松移植到手机端高效执行，开发出人工智能 App。ncnn 目前已在腾讯多款应用中使用，如 QQ、Qzone、微信等。
5、架构
6、优缺点分析
优点
1)、全部由C++实现，无需任何第三方库依赖，跨平台支持Android&amp;ios
2)、优化内存管理和数据结构设计，内存占用低
3)、支持多核并行计算加速
4)、扩展模型设计，支持8bit量化和半精度浮点存储
5)、优化内存管理和数据结构设计，内存占用低缺点
1)、不支持pb模型转换为ncnn模型，只支持Caffe模型的转换
2)、不支持GPU加速 2.3、Paddle-Lite 1、开源时间：2019年8月(持续更新)
2、开源用户：百度
3、GIthub地址
4、简介：Paddle Lite是飞桨基于Paddle Mobile全新升级推出的端侧推理引擎，在多硬件、多平台以及硬件混合调度的支持上更加完备，为包括手机在内的端侧场景的AI应用提供高效轻量的推理能力，有效解决手机算力和内存限制等问题，致力于推动AI应用更广泛的落地。
5、架构
6、优缺点分析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9733461111b8713c48af0d70ceb7d2e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7789a9a88add456871a3265bd5ff76bd/" rel="bookmark">
			什么是图神经网络GNN？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是GNN 一句话概括图神经网络（Graphic Nuaral Network，GNN）：将一个数据（一个图）输入到网络（GNN）中，会得到一个输出数据（同样是图），输出的图和输入的图相比，顶点、边、以及全局信息会发生一些改变。（注意，顶点之间的连接情况不会变，后面进行解释）
类似于一般的神经网络（DNN）一样，会对输入的数据进行改变得到输出数据，不同的是GNN的输入是一个图，输出也是一个图。
二、如何将数据表示成一个图（输入） 图是什么应该都很好理解，就是一些相互连接的顶点，那么，怎样将输入的数据表示成图的形式呢？GNN的输入到底是什么样的呢？
先说结论：GNN的输入包含以下几个部分，（1）顶点信息（2）边信息（3）全局信息（4）顶点之间的连接信息。这几个名词在下面的阅读中会慢慢理解。
为了更加形象的解释，举几个实际的例子：
第一个例子：
一张大小为5x5x3（3表示RGB通道，5x5表示图片长和宽）的图片，我们可以用下面的方法表示成一个图。
首先进行建模：
每一个像素在图中都表示成一个顶点，如果在图片中两个像素点是相邻关系，那么在图中，这两个顶点会有一条边进行相连。下面有个示例图（图1a和图1b）帮助理解，红色框里面的像素点都与2-2相邻，在图中他们之间会有边进行相连。
用数字表达一个图：
（1）每一个像素都有三个通道RGB，我们用一个三维向量来表示每一个顶点，所有顶点向量embedding组成一个顶点特征矩阵。（这里就是一个25x3的矩阵）
（2）顶点的连接信息可以用一个邻接矩阵来表示。（这里就是一个25x25的矩阵）
（3）每条边也用一个有意义的向量embedding来表示（比如像素之间的连接方向用向量表示出来），组成一个边的特征矩阵（72x？的矩阵，？表示每条边的向量维度）
（4）全局信息embedding（比如这个图是否含有环就是一个全局信息）
所以最后输入到GNN中的数据就包括一个顶点特征矩阵、一个邻接矩阵、一个边的特征矩阵以及一个全局信息
图1a 图1b
第二个例子：
有一句话，包含这几个单词：Graphs are all around us。可以用下面的方式表示成一个图。
首先进行建模
就和下面的图2a一样，每个单词表示一个顶点，相邻的两个单词之间会有一条边相连
用数字表达一个图：
（1）每一个单词可以用一个向量embedding来编码，所有单词组成一个单词的特征矩阵
（2）顶点的连接情况可以用一个邻接矩阵来表示
（3）每一条边可以用一个有意义的向量embeddind来表示，所有边向量组成一个边的特征矩阵
（4）全局信息
所以最后输入到GNN中的数据就包括一个顶点特征矩阵、一个邻接矩阵、一个边的特征矩阵以及一个全局信息
总结一下：从上面的例子可以得出，输入到GNN中的一个图包含四个部分，一个顶点的特征矩阵，一个边的特征矩阵，一个顶点连接情况的邻接矩阵以及一个全局信息。
其中顶点的连接情况我们在稍后进行优化表示，用一个邻接表来表示，放弃使用邻接矩阵，这会有一些好处。全局信息比较抽象，会单独有一个部分进行讲解。
现实中还有很多数据可以用图来进行表示，比如在一个社交网络中，各个人物之间的关系。商品推荐系统中，不同客户之间、不同商品之间、以及商品和客户之间的关系。而且这些数据都有一个特点，就是组成非常复杂，这也是图神经网路的优点之一，可以处理极为复杂的网络关系。
三、训练过程 1、训练目标 想要了解GNN的训练过程，我们首先得知道GNN的最终目的是什么。
图上的预测任务一般分为三种类型：对图进行预测（也就是全局信息）、对顶点信息进行预测和对边信息进行预测。
下面举一些例子来形象的解释每一种预测任务
在图级任务中，我们的目标是预测整个图的属性。 例如，对于以图形表示的一句话，我们可能想要预测这句话的语义，是一个陈述句还是一个疑问句，说话的人是高兴的还是生气的，这就是对图的全局信息进行预测。
那边级预测任务呢？
在边级预测任务中，GNN模型可用于预测顶点之间的关系（即每条边的信息）。 例如我们希望预测这些节点中的哪些节点共享一条边或该边的值是什么。
在一场搏击比赛中，现场有很多观众，台上有两个对抗者和一个裁判，我们可以把每个人看作是一个顶点，预测任务就是得出不同顶点之间的关系。我们用一张现场的图片来解释这个过程，图片中包含所有人物。对图2a进行抽象，得到图2b，对其进行预测得到每个人之间的关系（图2c中的每条边的标记）。
​​​​​​
图2a
图2c
最后讲一下顶点级的预测
在顶点预测任务中，我们预测图中每个顶点的一些属性。
一个典型例子是 空手道俱乐部。 该数据集是一个单一的社交网络图，Hi先生（教练）和John H（管理员）之间的争执在空手道俱乐部造成了分裂。 每个空手道练习者是一个顶点，边代表这些成员之间的社交关系。预测问题是在Hi先生（教练）和John H（管理员）争执之后对给定成员是忠于 Mr. Hi （蓝色）还是 John H（红色） 进行分类。 2、GNN网络结构 下面使用消息传递神经网络来构建GNN。 GNN采用“图入图出”架构，也就是说模型将图作为输入，改变图的信息后进行输出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7789a9a88add456871a3265bd5ff76bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2e84dfaa2952d11ae15b323d992c2af/" rel="bookmark">
			【计算机网络】数据链路层（二）—— 差错控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【计算机网络】数据链路层（二）—— 差错控制 一、前言差错从何而来？数据链路层与物理层编码的不同 二、检错编码1. 奇偶校验码2. 循环冗余码（CRC） 三、纠错编码海明码 例题 一、前言 数据链路层的主要作用是差错控制，早期有体现可靠传输
本章主要介绍差错控制相关内容，包含检错编码和纠错编码的介绍，
差错从何而来？ 概括来说，传输中的差错都是由于噪声引起的。
全局性
1.由于线路本身电气特性所产生的随机噪声(热噪声)，是信道固有的，随机存在的。
解决办法：提高信噪比来减少或避免干扰。（对传感器下手）
局部性
2.外界特定的短暂原因所造成的冲击噪声，是产生差错的主要原因。
解决办法：通常利用编码技术来解决。
链路层为网络层提供服务：
数据链路层与物理层编码的不同 数据链路层编码和物理层的数据编码与调制不同。物理层编码针对的是单个比特，解决传输过程中比特的同步等问题，如曼彻斯特编码。而数据链路层的编码针对的是一组比特，它通过冗余码的技术实现一组二进制比特串在传输过程是否出现了差错。
二、检错编码 主要的检错编码分为奇偶校验码与循环冗余码
1. 奇偶校验码 奇偶校验码是奇校验码和偶校验码的统称，是一种最基本的检错码。它由n-1位信息元和1位校验元组成，如果是奇校验码，那么在附加一个校验元后，码长为n 的码字中“1”的个数为奇数;如果是偶校验码，那么在附加一个校验元以后，码长为n的码字中“1”的个数为偶数。
奇偶校验码特点：
只能检查出奇数个比特错误，检错能力为50%。同时并不能知道哪些位错了，也不能发现偶数位的出错情况。
2. 循环冗余码（CRC） 给定一个m bit 的帧或报文,发送器生成一个 r bit 的序列，称为帧检验序列(FCS)。这样所形成的帧将由 m+r 比特组成。发送方和接收方事先商定一个多项式G(x)（最高位和最低位必须为1），使得带检验码的帧刚好能被预先确定的多项式G(x)整除。
假设一个帧有m位，其对应的多项式为Mx)，则计算冗余码的步骤如下:
加0。假设G(x)的阶为 r，在帧的低位端加上 r 个0。模2除。利用模2除法，用G(x)对应的数据串去除1）中计算出的数据串，得到的余数即为冗余码（共 r 位，前面的 0 不可省略)。 注意:循环冗余码(CRC)是具有纠错功能的，只是数据链路层仅使用了它的检错功能，检测到帧出错则直接丢弃，因此本节将 CRC 放在检错编码中介绍。
FCS的生成以及接收端CRC检验都是由硬件实现，处理很迅速，因此不会延误数据的传输。
例：要发送的数据是1101 0110 11，采用CRC校验，生成多项式是10011，那么最终发送的数据应该是？
10011表示成多项式为 X 4 + X 1 + X 0 X^{4}+X^1+X^0 X4+X1+X0，阶数为4
三、纠错编码 海明码 海明码的实现原理是在有效信息位中加入几个校验位形成海明码，并把海明码的每个二进制位分配到几个奇偶校验组中。当某一位出错后，就会引起有关的几个校验位的值发生变化，这不但可以发现错位，而且能指出错位的位置，为自动纠错提供依据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2e84dfaa2952d11ae15b323d992c2af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d75dbb3de0eacad59b6e8952dd383ae/" rel="bookmark">
			laravel-admin搭建后台管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有个搭建后台管理系统的需求，这里选用的是在laravel框架下的laravel-admin扩展，安装步骤如下：
#安装laravel，项目名称temp composer create-project --prefer-dist laravel/laravel temp "5.5.*" 如果提示没安装composer，可执行下述命令，并将其移到指定目录下即可。
# 下载composer.phar curl -sS https://getcomposer.org/installer | php # 移动composer.phar到环境变量，可直接运行 mv composer.phar /usr/bin/composer 再重新执行composer安装命令，执行该命令后需要一些时间，之后会在当前目录下生产temp文件夹，进入该目录后会看到一个.env文件，打开并编辑数据库配置：
DB_HOST=127.0.0.1 DB_PORT=3306 DB_DATABASE=temp DB_USERNAME=root DB_PASSWORD=123456 然后再依次运行一下命令：
#安装laravel-admin扩展 composer require encore/laravel-admin #发布资源 php artisan vendor:publish --provider="Encore\Admin\AdminServiceProvider" #安装 php artisan admin:install 在执行第三步安装时候，碰到了如下问题：
SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key length is 767 bytes (SQL: alter table `users` add unique `users_email_unique`(`email`)) ，这时只需在如下文件中添加这么一句：
use Illuminate\Support\Facades\Schema;//新添加 class AppServiceProvider extends ServiceProvider { public function boot() { Schema::defaultStringLength(191);//新添加 } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d75dbb3de0eacad59b6e8952dd383ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea3840f60a88b251b363f5f35185ee14/" rel="bookmark">
			鸿蒙开发实例 ｜ 分布式涂鸦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN话题挑战赛第2期
参赛话题：学习笔记
本篇文章介绍分布式设备间如何共享涂鸦画板的核心功能。
01、实现涂鸦作品发送至已连接手机 在涂鸦画板中有3个核心功能:
(1) 涂鸦者选择好希望连接的设备后,可以直接把涂鸦成果流转给对应的设备。
(2) 其他设备接收流转的涂鸦后,可以在涂鸦的基础上添加涂鸦或者修改。
(3) 修改后的涂鸦可以继续流转给涂鸦者,或者流转到其他设备上,如电视上。
这3个功能都是在连接好附近的设备后才能实现的。鸿蒙操作系统中对于室内网络的通信提供了对软总线的支持,软总线通过屏蔽设备的连接方式,采用一种最优的方式进行多设备的发现、连接和通信,如图1所示。
■ 图1 华为鸿蒙分布式软总线
在JavaScript框架中提供了FeatureAbility.continueAbility 方法,这种方法实现了设备间应用流转的所有功能。在需要流转的时候,只需保持好设备流转前的数据,在设备流转后,在其他设备上即可恢复流转前缓存的数据。
首先在需要流转的页面添加onStartContinuation和onSaveData这两种方法。流转后还需要用到的方法是onRestoreData和onCompleteContinuation,设备间流转触发的生命周期方法如图2所示,Ability流转方法如代码示例1所示。
■ 图2 鸿蒙Ability流转图
代码示例1 Ability流转方法
transforAbility: async function transfer() { try { await FeatureAbility.continueAbility(0,null) } catch (e) { console.error("迁移出错：" + JSON.stringify(e)) } }, onStartContinuation: function onStartContinuation() { //判断当前的状态是不是适合迁移 console.error("trigger onStartContinuation"); return true; }, onCompleteContinuation: function onCompleteContinuation(code) { //迁移操作完成，code返回结果 console.error("trigger onCompleteContinuation: code = " + code); return true }, onSaveData: function onSaveData(saveData) { //数据保存到savedData中进行迁移。 saveData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea3840f60a88b251b363f5f35185ee14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6e9159adc5dcb6ee1cd9f7abead860f/" rel="bookmark">
			（3/∞)UnityGUI中的Lable和Button组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 UnityGUI中给我们提供了很多用于显示UI界面的静态方法，由于UnityGUI是一个代码驱动的GUI，所以我们没有办法直接在游戏的Scene窗口直接创建，而是通过代码的形式去设置。
想要调用UnityGUI中的静态方法，只能够在继承了Mono脚本的类中的OnGUI函数中调用，这个函数时每帧执行，且我们一般只在其中执行GUI相关界面绘制和操作逻辑，该函数在OnDisable之前，LateUpdate之后执行。
private void OnGUI() { //在其中书写GUI相关代码 即可显示GUI内容 } GUI给我们提供了很多的常用基础控件，它们都是GUI公共类中的静态函数，参数也大同小异。
其中几乎都存在的参数有：
位置参数：Rect参数 x y位置 w h代表尺寸
显示文本：string 参数
图片信息:Texture参数
综合信息: GUIContent参数
自定义样式: GUIStyle参数
每种控件都存在多钟重载，都是各个参数的排列组合，且位置信息和显示信息是必备的参数内容。
例如：
Lable(文本)控件：
我们可以这样使用文本控件，传入一个Rect的实例给Lable或者直接在外部声明一个公开的Rect字段，由Inspector窗口对其进行初始化，达到在Game运行时调试UI的目的。
GUI.Label(new Rect(0, 0, 200, 20),"王嘉然，认识王嘉然",style); GUI.Label(rect, texture); Label控件也存在很多重载方法
//综合使用 GUI.Label(rect2, content); Debug.Log(GUI.tooltip); //自定义样式 //Lable 函数存在很多重载，其中有一个参数就是传递一个Style进去 下面为各个参数在Inspector窗口中的状态
Rect参数
Content参数
style参数
Button控件基本与Lable相同，但Button控件存在一个bool类型返回值，可用于判断按钮是否点击。代码如下：
//基本使用 //在按钮范围内 按下鼠标再抬起鼠标 才算一次点击 才会返回true if (GUI.Button(buttonRect, buttonContent, buttonStyle)) { print("按钮被点击了"); } //只要在长按按钮范围内 按下鼠标 就会一直返回true if (GUI.RepeatButton(buttonRect, buttonContent, buttonStyle)) { print("长按按钮被点击"); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/760d355798a71526dfb40191e09059db/" rel="bookmark">
			react项目热更新自动插入了iframe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近使用create-react-app创建了前端项目，热更新触发后，查看DOM元素发现在整个页面插入了一个iframe，层级很高，会影响查看其他元素。如上图所示：
查阅了一些资料，发现这是一个已知的bug，解决方法是在package.json中安装依赖：
"devDependencies": { "react-error-overlay": "^6.0.9" } 并且在"dependencies": {} 的下面加入：
"dependencies": { ... }, "resolutions": { "react-error-overlay": "6.0.9" }, 这样重新启动项目，热更新后发现就不会再出现那个烦人的iframe了。
参考链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7464b13f1a5555902c45782998664184/" rel="bookmark">
			第四章 教学实施
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01 教学概述
02 教学过程
03 教学方法与原则
04 教学组织形式
05 课堂教学的实施
06 教学关键技能
07 教学评价与反思
01 教学概述 一、教学的概念
二、教学的地位与特点 三、教学的基本任务
四、教学的
一、教学的概念 了解 教师的教与学生的学共同组成的一种双边活动。教学是学校教育的中心工作
二、教学的地位与特点 单选 （一）地位：全面发展教育的基本途径
（二）教学与教育、智育及上课的关系
三、教学的基本任务 单选 （一）引导学生掌握科学文化基础知识和基本技能——首要任务
（二）发展学生智力，培养学生的创造能力和实践能力
（三）发展学生体力，提高学生的健康水平
（四）培养小学生高尚的审美情趣，养成良好的思想品德，形成科学的世界观和良好的个性心理品质
四、教学的意义 单选 教学是学校教学工作的中心工作
总结（教学概述） 02 教学过程 一、教学过程的概念
二、教学过程的本质
三、教学过程的基本规律
一、教学过程的概念 单选 二、教学过程的本质 单选 1.本质：特殊的认识过程
2.表现：间接性、引导性、简捷性、教育性
三、教学过程的基本规律 单选、材料 总结（教学过程） 03 教学原则与方法 一、教学原则 二、教学方法
一、教学原则 重点：单选、简答、材料 思想性（教育性）与科学性相统一原则 理论联系实际原则 直观性原则 启发性原则 循序渐进原则 巩固性原则 量力性原则 因材施教原则 总结（教学原则） 【例】简述理论联系实际原则的贯彻要求？
【参考答案】（易建联运用知识训练乡土教材）
①书本知识的教学要注重联系实际。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7464b13f1a5555902c45782998664184/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/908cd32b997052a550af8e581d164611/" rel="bookmark">
			python数据挖掘学习01：数据归一化与标准化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据归一化与标准化均是数据特征无量纲化处理方式，而无量纲化是指通过一个合适的变量替代，将一个涉及物理量的方程的部分或全部的单位移除，以求简化实验或者计算的目的，是科学研究中一种重要的处理思想。
无量纲处理主要将数据按比例缩放，使之落入一个小的特定区间，一般目的在于：去除数据的单位限制，转化为无量纲的纯数值，便于不同单位或量级的指标能够进行比较和加权。
数据特征无量纲化主要有以下优点：
1、加速模型求解，例如模型使用梯度下降法求最优解时，经过归一化/标准化处理可以加快结果收敛速度；
2、提升模型精度，对于KNN、聚类等算法需要求解样本点之间的距离时，通过特征无量纲化，避免某一特征取值域较大特征主导距离计算，以此提高模型精度。
归一化（Normalization 或 Min-Max Scaling） 数据归一化是将数据x按照最小值中心化后，再按照极差（最大值-最小值）进行缩放，最终数据会被收敛到【0，1】之间。
归一化公式如下：
标准化（Standardization，又称 Z-score normalization） 数据标准化是指数据按均值中心化后，再按照标准差缩放，数据就会服从均值为0，方差为1的标准正态分布。
标准化公式如下：
标准化和归一化区别： 首先标准化和归一化都不会改变数据分布，只是对数据进行线性无量纲处理，通过相应的缩放和平移使数据发生改变，但并没有改变原始数据的排列顺序。
import numpy as np from sklearn.preprocessing import MinMaxScaler from sklearn.preprocessing import StandardScaler import matplotlib.pyplot as plt # 创建数组 data_rn = np.random.randint(-10, 10, 10).reshape(5, 2) plt.subplots(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.plot(data_rn); plt.subplot(1, 2, 2) sns.distplot(data_rn); # 归一化 scales_mm = MinMaxScaler() data_rn_new = scales_mm.fit(data_rn).transform(data_rn) # 标准化 scales_ss = StandardScaler() data_rn_new1 = scales_ss.fit(data_rn).transform(data_rn) plt.subplots(figsize=(10, 4)) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/908cd32b997052a550af8e581d164611/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7b8df2f2148a7b74a485a4bf029fe79/" rel="bookmark">
			Hardware and Software Support for Virtualization读书笔记（一）：定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出于兴趣，最近在看Hardware and Software Support for Virtualization这本书。为了加深对该书和虚拟化主要概念及流程的记忆和理解，计划写几篇文章来进行记录。因为个人职业方向和兴趣有限，文章只能对书中部分内容进行记录和阐释，只能做抛砖引玉和自我参考使用，如果有大佬看到这些文章且有不同意见，欢迎讨论指正。
1. VIRTUALIZATION Virtualization is the application of the layering principle through enforced modularity, whereby the exposed virtual resource is identical to the underlying physical resource being virtualized
以上引文为VIRTUALIZATION（虚拟化）的定义，它主要包括两个基本原则：1)分层，分层通过引入不同层级(layer)，使得部分层级不能直接(即indirection)使用计算机资源，而是一种对资源的抽象。2)强制模块化，某些被抽象出的层级不能直接使用物理资源或得知物理资源的具体使用情况。
1.1 Virtualization in Computer Architecture 虚拟化是计算机架构中的一个基本组成部分，其中一个最典型的例子就是虚拟存储器(virtual memory)。虚拟存储器的实现依赖于MMU（memory management units，内存管理单元），它使得应用程序不能直接使用存储器，而是将硬件的实际物理地址隐藏起来，使应用程序只能通过虚拟地址访问存储器。
1.2 Virtualization within Operating Systems 操作系统将计算机资源如CPU, IO, memory安全地提供给同时执行的多个应用程序，例如，操作系统通过控制MMU，将不同的存储器地址空间提供给多个不同的进程，保证它们可以复用有限的存储空间，但又不会访问其他进程的敏感数据
1.3 Virtualization in I/O subsystems 这一部分，原文中没有进行理论说明。举例来说，硬盘控制器可以通过虚拟化将多个硬盘区域抽象为多个虚拟硬盘供操作系统使用
1.4 Three basic implementations techniques of virtualization 下图给出了实现虚拟化的三种基本技术，这三种技术可以结合起来使用。几乎所有hypervisor都组合使用了multiplexing和emulation。
1.4.1 multiplexing multiplexing（复用）包括空间复用和时间复用两种。空间(space)复用是将某一物理资源切分并分给不同的虚拟化实体（virtual entities），例如，操作系统通过配置MMU来控制虚拟地址到物理地址的映射，将物理地址空间的不同区域划分到不同虚拟地址空间中。时间(time)复用是将同一物理资源在不同时间给不同的虚拟化实体（virtual entities）使用，例如操作系统可以让不同的线程复用CPU资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7b8df2f2148a7b74a485a4bf029fe79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0751e5cf909d767727aade859fe4a88c/" rel="bookmark">
			域策略（7）——禁用本地administrator登录计算机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 策略说明 通常公司域环境中，普通域用户没有管理员权限，不可以随意设置系统和私自安装软件，但是对于有些自己装机经验的人员来说，会通过PE等工具来解锁和重置administrator本地账户，从而用本地账户进入系统，进行配置、安装软件等违规行为。因此可以通过策略禁用本地administrator，从而提高安全性，便于公司运维管理。
策略设置步骤 在域策略服务器上，通过命令gpmc.msc打开域策略编辑器；
此策略用单独的行政部进行演示举例，右键”行政部“——”在这个域中创建GPO并在此处链接“——命名为”禁用本地admin"；
右键“禁用本地admin"——”编辑“；
依次找到：计算机配置——策略——Windows设置——安全设置——本地策略——安全选项，右侧找到”账户：管理员状态“并设置为已禁用；
通过命令 gpupdate /force 强制刷新域策略； gpupdate /force 6. 行政部OU下的所有计算机，均无法通过administrator登录计算机，登录时提示”你的账户已被停用。请向系统管理员咨询“。即使通过PE等工具重置本地administrator密码也无济于事。
end! 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dc7c5f009d1dcb977b738510fce6789/" rel="bookmark">
			实战技巧位运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实战技巧位运算 为什么需要位运算位运算符异或运算(xor)指定位置的位运算位运算实战要点实战 为什么需要位运算 机器采用二进制对数值进行表示、存储和运算
在程序中恰当地使用二进制，可以提高运行效率
位运算符 异或运算(xor) 相同为0，不同为1
也可用“不进位加法”来理解
异或运算的特点与应用:
指定位置的位运算 二进制数的最右边为第0位
获取×在二进制下的第n位（0或者1) :(x &gt;&gt;n)&amp; 1
将×在二进制下的第n位置为1:x |(1&lt;&lt;n)
将×在二进制下的第n位置为0: x&amp;(~(1 &lt;&lt;n))
将×在二进制下的第n位取反:x^(1 &lt;&lt;n)
将×最右边的n位清零:x&amp;(~0&lt;&lt;n)
将×最高位至第n位（含）清零:x&amp;((1&lt;&lt;n)- 1)
位运算实战要点 判断奇偶:
x % 2 == 1 →(x &amp; 1)== 1x% 2 == 0 (x &amp; 1)== 0 .
除以2的幂次:
x/2 → x&gt;&gt; 1mid = (left + right)/ 2; →mid =(left + right) &gt;&gt; 1; lowbit:
得到最低位的1: x &amp;-x或x&amp;(~x+ 1)清零最低位的1∶ x=x &amp;(x- 1) 实战 https://leetcode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dc7c5f009d1dcb977b738510fce6789/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87f2b21673be99fd66e2086da90fbc52/" rel="bookmark">
			使用TensorBoard可视化模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了了解发生的情况，我们在模型训练期间打印一些统计数据，以了解训练是否在进行中。 但是，我们可以做得更好：PyTorch 与 TensorBoard 集成在一起，TensorBoard 是一种工具，用于可视化神经网络训练运行的结果。
读取数据并进行适当的转换（与先前的教程几乎相同）。设置 TensorBoard。写入 TensorBoard。使用 TensorBoard 检查模型架构。使用 TensorBoard 来创建我们在上一个教程中创建的可视化的交互式版本，并使用较少的代码 有两种方法可以检查我们的训练数据在训练模型时如何跟踪其表现在训练后如何评估模型的表现。 # imports import matplotlib.pyplot as plt import numpy as np import torch import torchvision import torchvision.transforms as transforms import torch.nn as nn import torch.nn.functional as F import torch.optim as optim from fontTools.merge import cmap from torch.utils.tensorboard import SummaryWriter #tranforms transform = transforms.Compose( [transforms.ToTensor(), transforms.Normalize((0.5,),(0.5,))]) # datasets trainset = torchvision.datasets.FashionMNIST(',/data', download=True, train=True, transform=transform) testset = torchvision.datasets.FashionMNIST('./data', download=True, train=False, transform=transform) # dataloaders trainloader = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87f2b21673be99fd66e2086da90fbc52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28f64249c916bf80d10891aae479d39b/" rel="bookmark">
			Linux 入门基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Linux环境的安装
1.1常见的三种Linux环境安装
1.2云服务器的操作
1.3XShell
1.4 Linux下新建与删除用户
二、Linux的基本指令和操作
2.1初始Linux必备的三剑客
①pwd指令
②ls指令
③cd指令
2.2理解文件
三、指令
3.1 ls指令
①ls -l&amp;&amp;ls -d
②ls -a
③ls -Rl
3.2 cd &amp;&amp; pwd指令
①pwd指令补充
②cd指令
③ cd -
④ cd ~
3.3mkdir&amp;&amp;touch&amp;&amp;rm指令
①touch&amp;&amp;mkdir指令
②mkdir创建一串目录
③ rm指令
3.4 tree&amp;&amp;whoami指令
①tree指令
②whoami指令
四、工作路径和Windows下的Linux
4.1工作路径
4.2Windows上玩Linux
每日鸡汤：
🚀成功=艰苦劳动+正确方法+少说空话 一、Linux环境的安装 1.1常见的三种Linux环境安装 1、双系统或者把自己的笔记本搞成Linux(严重不推荐、大佬随意)
2、虚拟机(vmware player+centos 7.X)(不推荐) 为什么不推荐呢？虚拟机有它的优点，就是不用花钱，用着也挺舒服，但是到了Linux后期网络部分虚拟机无法联网操作，比较不舒服。
3、使用云服务器（所有的安装问题，全都不用操心，仿真企业环境，方便后期测试）
比较推荐的方式是使用云服务器，老铁可以自行去百度云、腾讯云、华为云等都是可以购买轻量级应用服务器，大学生的话都是有优惠的。
1.2云服务器的操作 1、购买哪一家云服务器，先要注册对应的云服务器账号。博主购买的是腾讯云的云服务器：
比较推荐这一款，实惠而且2G2核的够我们使用了。
2、购买，找到你购买的主机
3、保存一下公网ip
4、重置root密码---一定要做
1.3XShell 购买过云服务器后，怎么使用呢？这类软件比较多，博主比较推荐的是XSHell这款登陆软件。
进入后，界面是这样的：
我们只需要 输入 ssh root@你的公网ip就会跳出一个界面，让我们输入密码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28f64249c916bf80d10891aae479d39b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8492f2c8f995dcb8f93f264077c37421/" rel="bookmark">
			第三章 学校与班级管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 01 学校组织与管理
02 班级与班集体
03 班主任与班主任工作
04 班级活动与班队活动
05 课外活动
02 班级与班集体 一、班级与班集体
二、班级管理
三、班级突发事件的处理
一、班级与班集体 （一）班级 了解 年龄、知识程度相近，有共同的学习任务，有固定人数。 开展教学活动的基本单位
（二）班集体 了解
最早提出班级一词：埃拉斯莫斯
系统论述了班级组织：夸美纽斯
（三）班集体的发展阶段 单选 （四）班集体的形成与培养 简答 【例】简述良好班集体的培养措施。
（1）确定班集体的发展目标。
（2）建立班集体的核心队伍。
（3）建立班集体的正常秩序。
（4）组织形式多样的教育活动。
（5）培养正确的舆论和良好的班风。
二、班级管理 （二）班级管理的模式 了解 （三）班级管理的功能 （四）班级管理的原则 材料 三、班级突发事件的处理 材料【12下、17下材料题】 总结（班级与班集体） 03 班主任与班主任工作 一、班主任 职权影响力+个性/人格影响力
二、班主任工作内容
三、班主任工作的原则
二、班主任的工作内容 【2013下简答】 （一）常规工作 单选、简答 （二）个别教育工作 简答、材料 小结（班主任工作内容） 04 班队活动的类型 单选 05 课外活动 一、课外活动的概念
二、课外活动的内容
三、课外活动的特点
四、课外活动的组织形式
五、开展好课外活动的基本要求
二、课外活动的内容 单选 三、课外活动的特点 单选 四、课外活动的组织形式 单选 五、开展好课外活动的基本要求 简答 总结（课后活动） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4a0011226d3a8db09e173dee760b558/" rel="bookmark">
			OpenBLAS warning这个怎么解决呀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenBLAS warning: precompiled NUM_THREADS exceeded, adding auxiliary array for thread metadata.
Segmentation fault (core dumped)
在做DBSCAN分析，运行后出现这个错误，新手翻译这个warning后也不知道怎么解决，求各位高手相助
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30124051131621dc01a02fccc630eb3b/" rel="bookmark">
			JOIN查询流程与驱动表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 `JOIN` 语句的执行数据准备分别创建表 `t1, t2`表 `t2` 中插入 `1000` 行数据表 `t1` 里插入的是 `100` 行数据 `JOIN` 语句的执行过程`EXPLAIN` 分析语句能不能使用 `JOIN` 语句 为何要用小表驱动大表`JOIN` 查询如何选择驱动表使用 `JOIN` 查询注意点能不能使用 `JOIN` （为何阿里不推荐使用 `JOIN`） JOIN 语句的执行 数据准备 分别创建表 t1, t2 CREATE TABLE `t1` ( `id` int(11) NOT NULL AUTO_INCREMENT, `a` int(11) NOT NULL, `b` int(255) NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `index_a` (`a`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=101 DEFAULT CHARSET=utf8mb4; CREATE TABLE `t2` ( `id` int(11) NOT NULL AUTO_INCREMENT, `a` int(11) NOT NULL, `b` int(255) NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `index_a` (`a`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=1001 DEFAULT CHARSET=utf8mb4; 表 t2 中插入 1000 行数据 -- 创建存储过程 CREATE DEFINER=`root`@`localhost` PROCEDURE `NewProc`(INOUT `i` int) BEGIN DECLARE i INT; SET i = 1; WHILE ( i &lt;= 1000 ) DO INSERT INTO t2 VALUES (i, i, i); SET i = i + 1; END WHILE; END 表 t1 里插入的是 100 行数据 INSERT INTO t1 ( SELECT * FROM t2 WHERE id &lt;= 100 ) JOIN 语句的执行过程 EXPLAIN SELECT * FROM t1 STRAIGHT_JOIN t2 ON ( t1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30124051131621dc01a02fccc630eb3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66581983c47fbfbf75353a6823aa6952/" rel="bookmark">
			BUUCTF admin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开题目链接
看到题目页面，首先先查看源代码，在源代码中看出 you are not admin,便有可能是需要以admin身份登录页面。便想到爆破密码，以admin身份登录界面。回到登录界面，使用账号admin密码123尝试登录，结果没想到密码就是123（有点懵），直接登录，获取到flag。
装作不知道密码，继续做下去。首先查看题目各个页面的源码，看是否会获得到有用的信息。在change页面的源码中查看到hctf的一个url，点进去进入网址
以自己随意注册的账号登进去，查看到session，将在config文件中的secret-key换掉，即可完成session伪造，获得flag。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d0a6edc3b1520a954619d4826dc892e/" rel="bookmark">
			FFmpeg源码分析：avcodec_find_decoder()查找解码器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FFmpeg提供两种方式查找解码器，通过codecId查找avcodec_find_decoder()与通过名字查找avcodec_find_decoder_by_name()。同样地，也提供两种方式查找编码器，通过codecId查找avcodec_find_encoder()与通过名字查找avcodec_find_encoder_by_name()。源码位于libavcodec/allcodecs.c中。
查找编解码器过程如下图所示：
一、查找解码器 1、avcodec_find_decoder
通codecId来查找解码器的方法如下：
AVCodec *avcodec_find_decoder(enum AVCodecID id) { return find_codec(id, av_codec_is_decoder); } 函数体只有一行代码，就是调用find_codec()来查找，第一个参数为codecId，第二个参数为属于解码器类型，具体方法如下：
static AVCodec *find_codec(enum AVCodecID id, int (*x)(const AVCodec *)) { const AVCodec *p, *experimental = NULL; void *i = 0; id = remap_deprecated_codec_id(id); while ((p = av_codec_iterate(&amp;i))) { if (!x(p)) continue; if (p-&gt;id == id) { if (p-&gt;capabilities &amp; AV_CODEC_CAP_EXPERIMENTAL &amp;&amp; !experimental) { experimental = p; } else return (AVCodec*)p; } } return (AVCodec*)experimental; } 可以看到，是通过while循环调用av_codec_iterate()来迭代遍历，获取AVCodec，然后用id判断是否相等。如果id相等，就返回对应的AVCodec。我们来看下av_codec_iterate()的实现：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d0a6edc3b1520a954619d4826dc892e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a43cf2afa726e568433d663b1f07b147/" rel="bookmark">
			一个公司如果某个岗位常年招人，说明这家公司就是有问题的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		--作者“杰克”（趣编程同学） 一个公司如果某个岗位常年招人，说明这家公司就是有问题的
招不到人，说明钱给少了；
薪酬是由供需关系决定的；
而不是价值决定；
舍不得花钱，就自己干；
这个逻辑很简单；
你的工作，赚钱，就是为别人承受苦难，这个必须要付钱；
如果某个工种招不到人，这很明显，原来的钱给少了，前辈们付出了远远超过该薪酬的艰辛；
只是有太多的人认为理所应当。
-----------
因为“理所当然”，所以公司就一直留不住人，一直在招人的状态。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0981318c70f89aa5be38a00cd4bdcd62/" rel="bookmark">
			sklearn机器学习——day19
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sklearn的神经网络
神经网络与人脑的处理过程
sklearn是专注于机器学习的库，它不是专用于深度学习的平台，也不具备处理大型数据的能力，所以sklearn中的神经网络和其他机器学习算法比起来显得有些不受重视，它不具备做真正的深度学习的功能，甚至对一些在深度学习中非常关键的点缺乏关注。
回归单层神经网络：线性回归 w和b称为模型参数，b是偏差，w是回归参数
假设我们使用一个神经网络来表达线性回归的上述过程：
这是一个最简单的神经网络表示图
代码实现“
二分类单层神经网络：sigmoid函数与阶跃函数 多分类单层神经网络：softmax回归 在了解二分类后，我们可以继续将神经网络推广到多分类。在sklearn中，我们曾经学习过逻辑回归做多分类的做法。逻辑回归通过Many-vs-Many (多对多)和One-vs-Rest (一对多)模式来进行多分类。其中，OvR是指将多个标签类别中的一类作为类别1，其他所有类别作为类别0，分别建立多个二分类模型，综合得出多分类结果的方法。
MvM是指把好几个标签类作为1，剩下的几个标签类别作为0，同样分别建立多个二分类模型来得出多分类结果的方法。这两种方法非常有效，尤其是在逻辑回归做多分类的问题上能够解决很多问题，但是对于神经网络却不奏效。
softmax公式：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccac09eb70b19b8bf987a3deaa5a3232/" rel="bookmark">
			torch.cat()函数 ，关于四维tensor维度合并。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：看了关于torch.cat函数的文章，有点乱，自己总结一篇，关于四维tensor合并。
一张图像在计算机中的表示通常为三维tensor（张量），即[channels,height,width] 。也就是一张彩色图片通常有三色通道（R,G,B）组成，高和宽也就是常说的照片大小，比如224x224在图像处理的时候会增加一个变量batch_size,也就是把多少张图片作为一批进行处理。所以就变成了四维张量，即[batch_size,channels,heigth,width],也即是[批量大小，通道数，高，宽]如何判断一个tensor是几维张量最简单的办法就是看中括号数。例如 [[[[1,2,3]]]]，是四维张量。torch.cat()函数,官方文档是这样写的torch.cat(tensors, dim=0, *, out=None)，也就是有两个参数，一个是要合并的张量，一个是在哪个维度上进行合并。 废话少说开始演示。 import torch a=torch.tensor([[[[1,1,1],[2,2,2]]]]) b=torch.tensor([[[[3,3,3],[4,4,4]]]]) print(a.shape,b.shape) #torch.Size([1, 1, 2, 3]) torch.Size([1, 1, 2, 3]) 定义了两个四维张量。维度都为[1,1,2,3]，即批量大小为1，通道为1，高为2，宽为3
import torch a=torch.tensor([[[[1,1,1],[2,2,2]]]]) b=torch.tensor([[[[3,3,3],[4,4,4]]]]) print(a.shape,b.shape) #torch.Size([1, 1, 2, 3]) torch.Size([1, 1, 2, 3]) #在维度0上面进行合并 x=torch.cat((a,b),dim=0) print(x.shape) #torch.Size([2, 1, 2, 3]) 在维度0上进行合并，然后输出维度为[2,1,2,3],所以得出结论 四维张量在0维合并的时候 其实是在批量大小维度上进行合并。
import torch a=torch.tensor([[[[1,1,1],[2,2,2]]]]) b=torch.tensor([[[[3,3,3],[4,4,4]]]]) print(a.shape,b.shape) #torch.Size([1, 1, 2, 3]) torch.Size([1, 1, 2, 3]) #在维度0上面进行合并 x=torch.cat((a,b),dim=0) print(x.shape) #torch.Size([2, 1, 2, 3]) #在维度1上进行合并 x=torch.cat((a,b),dim=1) print(x.shape) #torch.Size([1, 2, 2, 3]) 在1维度上进行合并，输出维度为[1,2,2,3],即在1维上合并是在通道维度上进行合并。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccac09eb70b19b8bf987a3deaa5a3232/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/954f808c7ac96a107400e409b9afc8d1/" rel="bookmark">
			innerHTML和outerHTML有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、区别
1）innerHTML:
从对象的起始位置到终止位置的全部内容, 不包括HTML标签。
2）outerHTML:
除了包含innerHTML的全部内容外, 还包含对象标签本身。
二、例子
&lt;div id="test"&gt;
&lt;span style="color:red"&gt;test1&lt;/span&gt; test2
&lt;/div&gt;
1）innerHTML的值是 &lt;span style="color:red"&gt;test1&lt;/span&gt; test2 2）outerHTML的值是 &lt;div id="test"&gt;&lt;span style="color:red"&gt;test1&lt;/span&gt; test2&lt;/div&gt;
其中，红色部分就是差异之处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c1d292028a98c65e47ef7428d7a8aaa/" rel="bookmark">
			python-----字典（dictionary）---1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字典和列表类似，也是可变序列，不过与列表不同，它是无序的可变序列，保存的内容是以键值对的形式存放的，这类似于我们的新华字典，他可以把拼音和汉字关联起来，通过音节表可以快速找到想要的汉字。其中新华字典的音节表相当于键（key），而对应的汉字就是值。键是唯一的，而值可以是多个。字典在定义一个包含多个命名字段的对象很有用。
说明：python中字典相当于java或者c++中的map对象
字典的特征如下：
1、通过键而不是通过索引来读取。
字典有时也称为关联数组或者散列表（hash），它通过键将一系列的值联系起来，这样就可以通过键从字典中获取指定项，但不能通过索引来获取。
2、字典是任意对象的无需组合
字典是无序的，各项是从左到右随机排序的，即保存在字典中的项没有特定的顺序，这样可以提高查找顺序。
3、字典是可变的，并且可以任意嵌套
字典可以在原处增长或者缩短（无需生成一份副本），并且他支持任意深度嵌套（她的值可以在列表或者其他字典）。
4、字典中的键必须唯一
不允许同一个键出现两次，如果出现两次，则后一个值会被记住。
5、字典中的键必须不可变
字典中的键是不可变的，所以可以使用数字、字符串或者元组，但不能使用列表。
一、字典的创建和删除
定义字典时，每个元素都包含两个部分“键”和“值”。创建字典时，在“键”和“值”之间使用冒号分离，相邻两个元素使用逗号分隔，所有元素放在一个大括号“{}"中。语法格式如下：
dictionary = {'key1':'value1','key2':'value2','key3':'value3','keyn':'valuen',} dictionary:表示字典名称
key1， key2，。。。keyn ：表示元素的键，必须唯一的，并且不可变，例如可以时字符串、数值或者元组
value 1， value2.。。。valuen：表示元素的值，可以是任何数据类型，不是必须唯一。
例
word = {'che':'车','chen':'陈','chi':'吃'} print(word) 执行结果：{'che': '车', 'chen': '陈', 'chi': '吃'}
同列表和元组一样，也可以创建字典。在python中，可以使用下面两种方法创建空列表
word4 = {} #空字典 print(word4) word5 = dict() #空字典 python的dict（）方法除了创建一个空字典外，还可以通过已有数据快速创建字典。主要表现为两种形式。
1、通过映射函数创建字典
语法如下：
dictionary = dict（zip（list1，list2））
dictionary：表示字典的名称；
zip（）函数：用于将多个列表和元组对应位置的元素组合为元组，并返回包含这些内容的zip对象。如果想得到元组，可以将zip对象使用tuple（）函数转换元组。使用列表则用list（）函数转换即可。
list1是生成字典的键，list2是字典的值，如果长度不同，则以最短的为准。
例：
name = ['绮梦','冷一一','香凝','黛蓝'] sign = ['水平座','射手座','双鱼座','双子座'] zip2 = zip(name,sign) word2 = dict(zip2) print(word2) 执行结果：{'绮梦': '水平座', '冷一一': '射手座', '香凝': '双鱼座', '黛蓝': '双子座'}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c1d292028a98c65e47ef7428d7a8aaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/787ad06f7ec6a385584bd16b414b3159/" rel="bookmark">
			SolidWorks好久没用。无法获得下列许可SOLIDWORKS Standard。期望的SolidWorks监控程序已经关闭。 (-97,121,0)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言解决办法步骤一步骤二 总结 前言 SolidWorks好久没用之后再打开又出现无法获得许可的问题（见下图）。到目前为止这个问题我出现过两次，记录一下我是怎么解决的。
提示：以下是本篇文章正文内容，下面方法可供参考
解决办法 步骤一 先点server_remove，再点server_install。进行完上述图片操作后重启SolidWorks，如果仍无法获得许可，见步骤二。
步骤二 运行sw_d，再重复步骤一。重启SolidWorks，如仍报错，请查询其他经验贴。
总结 以上就是今天要讲的内容，本文仅简单介绍了SolidWorks“监控程序已经关闭 (-97,121,0)”的问题。如找不到上述图片中相对应的C盘地址或C:\Program Files (x86)中没有“SolidWorks_Flexnet_Server”文件夹的朋友，可以先看这个帖子：
SOLIDWORKS无法获得下列许可 无效的使用许可号码(-8,544,0) 解决办法大全
（打不卡的复制这个）http://t.csdn.cn/6hE0Q
（打不卡的复制这个）https://blog.csdn.net/qq_43596278/article/details/125115127?spm=1001.2014.3001.5501
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a6e372634f03caa6522ccc3e1dcbbc6/" rel="bookmark">
			有符号数和无符号数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、数值 针对二进制来讲，有 有符号数（signed）和无符号数（unsigned）。
因为计算机无法区分一个二进制数是有符号数还是无符号数，因此我们在定义时要明确该数值是有符号数还是无符号数。
无符号类型需要通过unsigned关键字指定，否则默认为有符号类型。
2、有符号数 2.1 有符号数的定义 是用最高位（即从左往右数的第1位），表示符号（0为正数，1为负数），其余位表示数值大小。有符号数区分正数和负数。如图2.1中，第一行的最高位为0，因此它的十进制数读作22；第二行的最高位为1，因此它的十进制数读作-22。
图2.1
2.2 有符号数的转换 将下列二进制数转化为十进制：
eg1: 已知二进制数：1 1 1 1 1 1 1 1
第一步：先列出表格如下
1
1
1
1
1
1
1
1
-2^7
2^6
2^5
2^4
2^3
2^2
2^1
2^0
第二步：将表格第二行数相加 1 1 1 1 1 1 1 1 ：-2^7+2^6+2^5+2^4+2^3+2^2+2^1+2^0=-1
eg2: 已知二进制数：0 1 0 1 1 0 1 1
第一步：先列出表格如下
0
1
0
1
1
0
1
1
0
2^6
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a6e372634f03caa6522ccc3e1dcbbc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db3a0f1a5cda2fcefb511a82eec2b417/" rel="bookmark">
			git 配置ssh
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git是现在代码管理的一个常用工具，采用两种传输方式 http ssh SSH 比较安全可靠，也不需要每次都输入账号密码，所以我们在使用git时一般采用ssh
配置之前先检查现用ssh秘钥 windows打开Gitbash,linux打开终端，输入
$ ls -al ~/.ssh 如果你看到一下输出，那么说明你已经有ssh秘钥 （以.pub结尾的文件）
total 24 drwxr-xr-x 1 Administrator 197121 0 Sep 23 15:25 . drwxr-xr-x 1 Administrator 197121 0 Sep 23 15:07 .. -rw-r--r-- 1 Administrator 197121 3389 Sep 23 15:07 id_rsa -rw-r--r-- 1 Administrator 197121 750 Sep 23 15:07 id_rsa.pub -rw-r--r-- 1 Administrator 197121 1458 Sep 23 15:25 ssh.ppk 如果你不想用原来的秘钥或者没有秘钥的话，直接进行下一步生成ssh秘钥
windows打开Gitbash,linux打开终端，输入
$ ssh-keygen -t rsa -b 4096 -C "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db3a0f1a5cda2fcefb511a82eec2b417/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb4edb28a72cfe87b8c33f0bc4286567/" rel="bookmark">
			vue项目中 调用 第三方api 如百度地图 跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1- 安装 yarn add vue-baidu-map-v3
2-引入 注册 main.js 文件
import BaiduMap from "vue-baidu-map-v3"; Vue.use(BaiduMap, { ak: "XA5932348T9SXZZZtZZZVtRNWexL11111111111111JSOd2e27AAHzVAAAuSt4bP999Swpmf7", }); 3- public下的index.html 文件
4- 解决 跨域问题 （目前项目中使用的是 第一种方案，开发环境中可以，线上环境的话需要后台配合改下 代理配置）
第一种方案：4.1 src下的api 新建 baidu.js 文件
baidu.js 文件内容复制
export default { init: function () { const AK = "XA593VRNWexLOde7AAHzVAuStbPwpmf7"; //你的AK const BMap_URL = "https://api.map.baidu.com/api?v=2.0&amp;ak=" + AK + "&amp;s=1&amp;callback=onBMapCallback"; return new Promise((resolve, reject) =&gt; { // 如果已加载直接返回 if (typeof BMap !== "undefined") { resolve(BMap); return true; } // 百度地图异步加载回调处理 window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb4edb28a72cfe87b8c33f0bc4286567/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11a7b264d3975df5e46b3dea30a8cef5/" rel="bookmark">
			java文件运行流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解释性语言（“一次编译，到处运行，跨平台“）
java运行流程： 编译 --&gt; 解释 --&gt; 运行
1、java解释性语言，首先通过编译器编译成.class字节码文件。
2、如果在windows平台上运行，则通过windows平台上的java虚拟机（JVM）进行解释。如果运行在linux平台上，则通过linux平台上的java虚拟机进行解释执行。所以说能跨平台，前提是平台上必须要有相匹配的java虚拟机。
拓展：
为啥能跨平台，一次编译到处执行，因为他是解释型语言，还因为有JVM能识别.class文件，机器会将其编译成机器码。
编译型语言：编译 ---&gt; 运行
编译型和解释型两者对比：
编译型语言速度快，执行效率高，但是比较依赖编译器，跨平台性较差
解释型语言每执 行一次都要翻译一次。因此效率比较低。
解释型语言如果要实现一次编译，到处执行，跨平台的前提是平台要有互相匹配的java虚拟机。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a5b2c7a6f53ffb9ee3b039bfff62885/" rel="bookmark">
			[Vue] 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 系列文章目录：
[Vue]目录
老师的课件笔记，不含视频 https://www.aliyundrive.com/s/B8sDe5u56BU
笔记在线版： https://note.youdao.com/s/5vP46EPC
视频：尚硅谷Vue2.0+Vue3.0全套教程丨vuejs从入门到精通
文章目录 前言1. 官网2. 介绍与描述3. Vue的特点3.1. 采用组件化模式，提高代码的复用率，让代码易于维护。3.2. 声明式编码，无需操作DOM，提高开发效率。3.3. 使用虚拟DOM和Diff算法复用DOM3.4. 遵循 MVVM 模式3.5. 编码简洁, 体积小, 运行效率高, 适合移动/PC端开发3.6. 它本身只关注 UI, 也可以引入其它第三方库开发项目 4. vue的特性5. vue的版本6. 学习Vue之前要掌握的JavaScript基础知识 1. 官网 英文官网: https://vuejs.org/中文官网: https://cn.vuejs.org/ 2. 介绍与描述 vue是一套用于动态构建用户界面的渐进式 JavaScript 框架
渐进式：vue可以自底向上逐层的应用
由一个个组件类似拼积木，逐层向上搭建，最后搭建出一个网页作者：尤雨溪 3. Vue的特点 3.1. 采用组件化模式，提高代码的复用率，让代码易于维护。 组件化：
将页面拆分成不同的部分，每个部分为一个组件，每个组件为一个单独的vue文件，每个vue文件的标签、样式、交互进行分开管理提高代码的复用率：当其他的页面也需要使用相同的组件时，直接引入写好的对应的组件即可代码易于维护：每个vue文件不同组件的标签、样式、交互进行单独管理，不会互相影响 3.2. 声明式编码，无需操作DOM，提高开发效率。 命令式编码：即一条命令实现对应的步骤，一个命令一个步骤
声明式编码：只需声明数据，然后将数据写入对应的标签位置即可
3.3. 使用虚拟DOM和Diff算法复用DOM 使用原生js将数据渲染到页面，当数据发生变化时，需要手动进行判断那些数据时新数据，重新进行渲染，或者将页面中的数据先进行删除再重新渲染改变后的数据。
vue会先把数据放到虚拟DOM中，再渲染到页面，当数据发生变化vue会使用Diff算法将新的虚拟DOM与旧虚拟DOM进行比较，数据没有变化的DOM继续复用即不发生改变，而新数据的DOM会将其渲染到页面对应的位置。
3.4. 遵循 MVVM 模式 MVVM是vue实现数据驱动视图和双向数据绑定的核心原理。
它把每个HTML页面拆分成三个部分：
Model：当前页面渲染时所依赖的数据源。
View：当前页面所渲染的DOM结构。
ViewModel：vue实例，MVVM的核心。
MVVM的工作原理：
ViewModel作为MVVM的核心，是它把当前页面的数据源(Model)和页面的结构(View)连接在了一起。
当数据源发生变化时，会被ViewModel监听到，VM会根据最新的数据源自动更新页面的结构。
当表单元素的值发生变化时，也会被VM监听到，VM会把变化过后最新的值自动同步到Model数据源中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a5b2c7a6f53ffb9ee3b039bfff62885/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1225a48918f87fcd91e218babd28d276/" rel="bookmark">
			自监督论文阅读笔记 RingMo: A Remote Sensing Foundation Model with Masked Image Modeling
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习方法促进了遥感 (RS) 图像解释的快速发展。最广泛使用的训练范式是利用 ImageNet 预训练模型来处理指定任务的 RS 数据。然而，存在 自然场景与RS场景之间的领域差距，以及 RS模型泛化能力差 等问题。开发具有通用 RS 特征表示的基础模型是有意义的。由于有大量未标记的数据可用，自监督方法在遥感方面比全监督方法具有更大的发展意义。
然而，目前大多数自监督方法都使用 对比学习，其 性能 对数据增强、附加信息以及正负对的选择很敏感。
在本文中，利用 生成式自监督学习 对 RS 图像的好处，提出了一个名为 RingMo 的遥感基础模型框架，它由两部分组成。
首先，通过从卫星和航空平台收集200万张RS图像，构建一个大规模的数据集，覆盖全球多个场景和物体。其次，提出了一种 针对 复杂 RS 场景中 密集和小型物体的 RS 基础模型训练方法。 本文展示了使用 RingMo 方法在本文的数据集上训练的基础模型在四个下游任务的八个数据集上实现了最先进的模型，证明了所提出框架的有效性。通过深入探索，本文认为 RS 研究人员是时候 拥抱生成式自监督学习 并利用其通用的表示能力 来加速 RS 应用程序的开发了。
近年来，卫星发射的数量呈爆炸式增长[1-6]。根据相关的科学家联盟发布的报告1，截至 2021 年 12 月，有 1,000 多颗地球观测卫星在轨道上运行。随之而来的是 获取大量遥感 (RS) 卫星数据的潜力。例如，珠海一号群卫星每天可以下载近 20TB 的数据[7]。海量的 RS 数据 需要经过处理和分析 才能在应用任务中发挥作用。受益于深度学习，许多利用 RS 数据的任务取得了显著进展 [8-17]。目前，RS图像解译 的一般范式是 加载ImageNet预训练的权重，然后在指定的任务中使用RS数据和标签信息进行模型训练[18-21]。尽管这些方法在特定任务中 针对特定目标 表现良好，但仍存在以下问题。
1）如图1所示，由于自然场景和RS场景的差异，ImageNet预训练的权重存在域偏差，这在一定程度上影响了RS模型的性能。2）由于受限的RS训练数据 只能 提供少量的场景和物体，模型的泛化能力相对较弱，难以适应其他任务。3）为了扩展到更多的目标和任务，研究人员需要不断地注释数据，这降低了实际应用的效率。 综上所述，使用海量的 RS 数据 并设计具有通用 RS 特征表示的基础模型 有望解决上述问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1225a48918f87fcd91e218babd28d276/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/353b6bbf047076f3cc5b25b13cd861d7/" rel="bookmark">
			Android, Switch滑动事件监听实现。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
Switch原生控件是不支持滑动监听的，只有 点击事件，以及状态改变的监听onCheckedChangedListenner().
有些需求是，当用户操作Switch后，我们需要记录用户操作的状态。 如果使用onCheckedChangedListener()的话， 不管用用户通过手势修改了Switch状态还是我们主动给Switch设置状态（初始化，recycler view中的回收）都会触发。
比如， 有一个switch， 用户操作Switch后会根据其状态Call API，API的返回结果会去修正Switch的状态（比如Call API失败了，要还原回Switch的状态）。
在这种情况下， 如果使用OnClickListenr的话是可以实现的， 但只能实现用户的点击事件造成的状态改变，我们知道Switch是可以滑动改变状态的，这就导致滑动不会出发Call API。
如果使用 onCheckChangedListener()，滑动和点击造成的Switch状态改变都可以被监听到，但有个严重问题， 用户点击 -&gt; onCheckedChanged回调方法被触发 -&gt; Call API -&gt; API返回的结果设置 Switch状态（setChecked）-&gt; onCheckedChanged回调方法被触发 -&gt;Call API -&gt; …
解决方案
public class SwipeListenerSwitch extends SwitchMaterial { OnClickListener stateChangedByUserGestureListener; public SwipeListenerSwitch(Context context, AttributeSet attrs) { super(context, attrs); } // This method will be called when the state of the switch is changed due to the user's gesture. @Override public void playSoundEffect(int soundConstant) { if (stateChangedByUserGestureListener !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/353b6bbf047076f3cc5b25b13cd861d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3e6ca8945e1fb6fd2b9cbe9258fdbfe/" rel="bookmark">
			【EFCore学习】EFCore梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CodeFirst模式 微软官网
1、创建一个.NETCore空项目 2、添加相关引用 通过命令进行安装，工具》NuGet包管理》程序包管理控制台
（1）引用 EntityFrameworkCore
Install-Package Microsoft.EntityFrameworkCore （2）引用 EntityFrameworkCore.SqlServer.Tools
Install-Package Microsoft.EntityFrameworkCore.Tools 3、相关配置 （1）配置连接数据库
（2）在Startup.cs中注册服务
其中的BloggingContext就是接下来我们要新建的数据上下文
4、生成数据库 （1）创建实体模型
public class Blog { public int BlogId { get; set; } public string Url { get; set; } public List&lt;Post&gt; Posts { get; } = new List&lt;Post&gt;(); } public class Post { public int PostId { get; set; } public string Title { get; set; } public string Content { get; set; } public int BlogId { get; set; } public Blog Blog { get; set; } } （2）创建上下文
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3e6ca8945e1fb6fd2b9cbe9258fdbfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b4796fe1c6b092e1edda4ddb9792e31/" rel="bookmark">
			哈诺塔问题及其python代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汉诺塔问题 递归 首先讲一讲递归，递归有两个特点：1.调用自身 2.有结束条件
例如：
def fun(x): print(x) fun(x-1) 因不存在结束条件，所以不属于递归
汉诺塔问题 下面言归正传，进入汉诺塔问题，如图所示
目标是把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。
我们的思路是从简单的两个盘子开始： 当只有两个盘子时：
1.把小盘子从A移动到B
2.把大盘子从A移动到C
3.把小盘子从B移动到C
当存在n个盘子时 同理，当存在n个盘子时，我们要借助C来移动，因为必须保证大圆盘在小圆盘下面
1.把n-1个盘子从A经过C移动到B
2.把第n个盘子(最大的)从A移动到C
3.把n-1个盘子从B进过A移动到C
此过程中，除了第二步，其余两步都是可以看成是本来n个盘子减少一个大盘子之后的子问题，仅仅是规模变小，移动的目的地不一样：n个盘子时从A移动到C，这次n-1个盘子是从A经过C移动到B和从B经过A移动到C，因此可采用递归算法
算法实现 def hanoi(n,a,b,c): #把n个盘子从A移动到C if n&gt;0: hanoi(n-1,a,c,b) print("moving from %s to %s" % (a,c)) hanoi(n-1,b,a,c) 我们看一下三个盘子的结果：
移动次数 汉诺塔移动次数的递推式：
H（x-1）= 2H（x）+1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0675db6a99a22e906327ab5bc94ea7ce/" rel="bookmark">
			异常处理的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		处理异常的第一种方式： 在方法声明的位置上使用throws关键字抛出，谁调用这个方法我就抛给谁。抛给调用者来处理。 这种处理异常的态度：上报。 处理异常的第二种方式： 使用try..catch语句对异常进行捕捉。 这个异常不会上报，自己处理了。 异常抛到此处为止，不再上抛了。 注意： 只要异常没有捕捉，采用上报的方式，此方法的后续代码不会执行。 另外需要注意，try语句块中的某一行出现异常，该行后面的代码不会执行。 try..catch捕捉异常之后，后续代码可以执行。 在以后的开发中，处理编译时异常，应该上报还是捕捉呢，怎么选？ 如果希望调用者来处理，选择throws上报。 其他情况使用捕捉的方式。 NullPointerException是运行时异常 import java.io.FileInputStream; import java.io.FileInputStream; import java.io.FileNotFoundException; public class ExceptionTest06 { //一般不建议在main方法上使用throws，因为这个异常如果真正发生了，一定会抛给JVM。JVM只有终止。 //异常处理机制的作用就是增强程序的健壮性。怎么做到异常发生了也不影响程序的执行。所以 //一般main方法中的异常建议使用try..catch进行捕捉。main就不要继续往上抛了。 /* public static void main(String[] args) throws FileNotFoundException { System.out.println("main begin"); m1(); System.out.println("main over"); } */ public static void main(String[] args) { //100/0这是算数异常，这个异常是运行时异常，在编译阶段可以处理也可不处理，编译器不管。 //System.out.println(100/0);//不处理编译器也不管 /*try{ System.out.println(100/0); }catch(ArithmeticException e){ System.out.println("算数异常了！"); }*/ System.out.println("main begin"); try { //try尝试 m1(); //以上代码出现异常，直接进入catch语句块中执行。 System.out.println("hello world!"); } catch (FileNotFoundException e) {//catch后面的好像一个方法的形参。 //这个分支中可以使用e引用，e引用保存的内存地址是那个new出来异常对象的内存地址。 //catch是捕捉异常之后走的分支 //在catch分支中干什么？处理异常。 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0675db6a99a22e906327ab5bc94ea7ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c13c2fab60c3e2e103e4e111945c95ed/" rel="bookmark">
			【设计模式——Adapter模式】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Adapter模式 Adapter（同义词：Wrapper）是最常用的设计模式之一。原因在于， 不兼容接口的适配肯定是软件开发中经常遇到的情况，例如，如果必须集成由另一个团队开发的模块，或者使用第三方库的情况。 Adapter模式的任务说明： 把一个类的接口转换为客户端期望的另一个接口。Adapter可以让因接口不兼容而无法一起工作的类一起工作。 进一步改造关于依赖注入的例子。假设希望使用BoostLog v2（请参阅 http://www.boost.org）进行日志记录，但是我们也希望能够使用其他的日志库替换 BoostLog v2。 解决方案很简单，只需要提供LoggingFacility接口的另一个实现，它将BoostLog 的接口适配到我们使用的接口。 //用BoostTrivialLogAdapter 类实现接口 LoggingFacility
//Boost.Log的Adapter只是LoggingFacility的另一个实现
#include"LoggingFacility.h"
#include&lt;boost/log/trivial.hpp&gt;
class BoostTrivialLogAdapter :public LoggingFacility
{
public:
virtual void writeInfoEntry(std::string entry) override
{
BOOST_LOG_TRIVIAL(info) &lt;&lt; entry;
}
virtual void writeWarnEntry(std::string entry) override
{
BOOST_LOG_TRIVIAL(warn) &lt;&lt; entry;
}
virtual void writeErrorEntry(std::string entry) override
{
BOOST_LOG_TRIVIAL(error) &lt;&lt; entry;
}
};
优点是显而易见的，通过Adapter模式，整个软件系统中只有一个类依赖于第三方日志记录系统。这也意味着，我们的代码不会收到日志所有者特有的语句污染，例如BOOST_LOG_TRIVIAL()。因为Adapter类只是LoggingFacility接口的另一个实现，所以我们也可以使用依赖注入将实例（或者同一个实例）注入想要使用它的所有客户端对象中。
Adapter可以为不兼容的接口提供广泛的适配和转换的可能性。它的适用范围来源于简单的适配，例如操作名称和数据类型的转换，直到支持整个不同的操作集合。在上面的例子中，把对带有一个字符串参数的成员函数的调用，转换成了对stream的插入操作符的调用。
如果要适配的接口很类似，那么接口适配当然很容易。但如果接口之间相差很大，Adapter 的代码实现可能会很复杂。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2185f42c11e254893336190405139acb/" rel="bookmark">
			Finding Missing Cards
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[22231程序设计]课堂练习5：Finding Missing Cards 题目链接
Finding Missing Cards
这道题我们采用打标签的方法可以在线性复杂度内完成。
思考这样的问题：
（1）如何表示是否出现过某一张牌，如何记录花色和数字。
（2）记录之后，我们怎么再次检查输出没有出现过的牌
考虑这样的一张表格（标记矩阵）：
花色012345678910111213Sfalse（无效）truefalsefalsefalsetruefalsefalsefalsefalsefalsefalsefalsefalseHfalse（无效）falsefalsefalsefalsefalsefalsefalsefalsefalsefalsefalsefalsefalseCfalse（无效）truefalsefalsefalsetruefalsefalsefalsefalsefalsefalsefalsefalseDfalse（无效）truefalsefalsefalsetruefalsefalsefalsefalsefalsefalsefalsefalse 以上矩阵表示输入为
S 1 S 5 C 1 C 5 D 1 D 5 在输出的时候，我们只需要遍历这个二维矩阵就可以找到所有没有出现过的牌了。
在此基础上，我们可以很容易运用二维矩阵解决问题，只需要将花色做[0,3]的映射即可。在输入S 5 的时候，我们就可以将二维矩阵的对应位置的布尔值标记为true，即 mat[0][5] = true
然而，如何不运用二维矩阵呢？
最简单的方式就是用四个单独的一维数组，比如命名为 s[N], h[N], c[N], d[N]，其中N为数组的长度，也就是标记矩阵的列数。
也可以将以上的M行N列的标记矩阵(M*N)平铺展开为一个一维数组(M*N)。
那么之前第 i 行，第 j 列的数据，展开到一维数组中就应该是第 i * N + j 个数据。
以下给出最简单的第一种方式的代码
#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; int n; int s[15], h[15], c[15], d[15]; // 标记数组 int main() { cin &gt;&gt; n; while(n --){ // 这个方法可以代替单调的记录循环次数用的 for(int i = 0; i &lt; n; i ++) // 但需要注意的是 while(n--)这样的循环头会导致n的值发生变化，必须要确定之后不用n了 char ch; cin &gt;&gt; ch; // 输入花色 int num; switch(ch){ cin &gt;&gt; num; case 'S': s[num] = true; // 将该元素标记为出现过 break; case 'H': h[num] = true; break; case 'C': c[num] = true; break; case 'D': d[num] = true; break; } } for (int i = 1; i &lt;= 13; i ++){ if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2185f42c11e254893336190405139acb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/293254a3c411cbe533220259e6f8b545/" rel="bookmark">
			安装virtualbox快完成时立即回滚，并提示安装出现严重错误的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题出现原因：因为我个人手贱在控制面板删除过程中点击取消，导致在后来的删除过程中，都会出现回滚操作。也无法在控制面板恢复程序，然后使用了强力卸载软件强制卸载了此软件。但在后续再次安装的过程中，安装程序位置默认是我之前存放软件的位置，安装程序也变成了卸载程序，并且一直回滚和安装报错
问题：安装virtualbox快完成时立即回滚，并提示安装出现严重错误
附：部分报错图片（因为当时未截图，图片部分来自网络）
我个人的解决办法：
1.下载ccleaner软件（下载地址：Thanks for downloading CCleaner） 2.点击工具，在搜索栏中搜索virtualbox，会出现你之前卸载的程序尝试恢复，会提示缺少东西 （第二张图片红色框框位置）无法修复。
3.找到你卸载不掉的VirtualBox版本（上一步ccleaner软件中查看到的VirtualBox版本）
附（VirtualBox官网）：Oracle VM VirtualBox
4.下载好之后，点击windows键+R键出现运行对话框输入cmd命令行。
5.在命令行中执行 xxx.exe --extract命令（xxx为你误删除的VirtualBox软件，点击重命名复制粘贴 即可→图一，图二）
6.之后会出现提示安装选项，选择安装即会出现对话框，也就是我们需要的msi文件存放位置（文 件存放在用户目录/AppData/Temp目录下，具体路径解压过程会有提示→图三）；
图一：
图二：
图三：
7.回到 ccleaner软件选择修复，在刚才缺少文件位置选择图三位置的软件，即可修复成功
8.再在ccleaner软件中选择卸载，即可彻底删除上次误删除的 VirtualBox。
9.之后就可以正常安装所需要的正确安装字自己所需要的VirtualBox版本了，安装就不会再次回滚 了，安装就不会再次回滚了。如果还没有强制删除，可以在控制面板实施在ccleaner软件的操作 即可。希望可以帮助到大家解决问题。
解决思路：
没能通过常规的卸载程序吗，而是通过强力卸载软件卸载就会出现问题。再次安装时，就会出现安装程序位置默认是我之前存放软件的位置，VirtualBox安装程序也变成了卸载程序，并且一直回滚和安装报错。这时候我们就要思考是否有残留，或者VirtualBox软件并没有真正意义的删除，所以我们通过恢复和删除原来的软件，来真正意义的删除VirtualBox软件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/518d9911eac5096a583b27c34436bcef/" rel="bookmark">
			两台电脑如何通过一根网线实现文件高速传输？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何通过一根网线连接两台电脑，并实现文件/数据的互传。
假设需要互传文件的两台电脑分别是A电脑和B电脑，需要将A电脑中的某个文件通过网线传输给B电脑。下面是详细的教程：
第一步，在两台电脑上分别设置其IP地址。
设置A电脑的IP 打开网络和共享中心→更改适配器设置→在对应的以太网那里鼠标右击选择属性→双击Internet协议版本4（TCP/IPv4）
设置A电脑的IP地址、子网掩码和默认网关，如下图所示。注意：默认网关和IP地址前三段必须保持一致，只有最后一段不同，一般情况下。默认网关最后一段都设置为1，而IP地址最后一段只要是1到254中的任一一个数字都可以。
2.设置B电脑的IP
在B电脑上设置B电脑的IP，方法过程同上面A电脑的设置过程相同，区别仅在于B电脑IP地址最后一段必须与A电脑不同，其余设置包括子网掩码、默认网关均要和A电脑保持一样，如下图所示。
第二步，通过ping命令来验证电脑之间是否相通。
首先，要通过网线来连接好两台电脑
然后，在A电脑上，单击桌面左下角开始按钮→在搜索框里输入“cmd”→按enter键→进入cmd界面→输入指令“ping 192.168.1.15”，注意ping和192.168.1.15之间有一个空格，且输入的IP地址“192.168.1.15”为B电脑IP地址→查看ping结果。
其次，在B电脑上，进行同A一样的操作即可，只是要注意在B电脑cmd界面中输入的IP地址是A电脑的IP。
PS：如果遇到ping不同的情况怎么办呢？首先，分别关闭AB电脑的杀毒软件；其次，分别关闭AB电脑的防火墙。经过上面两步，一般情况下ping不通的问题就可以完美解决。
第三步，设置需要传输的文件。
假设，需要将A电脑上的文件传输给B电脑。
首先，在A电脑桌面上新建文件夹“共享文件”→右击属性→然后点击共享→点击高级共享，如下图所示。
把共享文件夹前面的方框勾选上，如下图所示，
然后点击权限，设置共享权限，在这里我所共享的对象是everyone，里面的权限自己选，然后点击确定（读取这个选项一定要勾上，不然共享不了）
第四步，访问共享文件。
在B电脑上，按快捷键WIN+R调出运行窗口，在输入框输入A电脑的IP地址，格式如下：
点击确定按钮，要求输入要访问的A电脑的用户名和密码，如下图所示。点击使用其他账户，输入A电脑的用户名和密码，点击确定后，就可以在B电脑上看到A电脑上的共享文件了。双击共享文件夹，便可以访问A电脑上的共享文件了。
以上就是两台电脑通过网线实现高速传输文件的全部方法了，大家边学习边动手操作吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00d43d68c173fb0c0bf1d1db025ce38f/" rel="bookmark">
			软考信息安全工程师常见问题--关于通过率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于软考向社会开放，报名不设学历资历等条件限制，考试需要各个科目都同时及格才算合格，而且随着IT环境的变化、考试难度的提升，它的通过率并不是很高。软考各级别总平均通过率大约是20%，初级资格的通过率约35%，中级资格的通过率约20%，高级资格的通过率约20%以下。
需要说明的是，看起来软考通过率比较低，但有以下一些原因：
1、软考报名没有设置任何门槛，没有学历、专业、年龄的限制，每一年报名的人有一部分是没有相关基础的；
2、软考毕竟属于国家级考试，出题还是具有一定的难度；同时软考的教材基本都在六七百页，有点还需要扩展知识，如果没有良好的学习习惯，坚定的信念，严于律己的自律精神，是不能坚持下去的，“从入门到放弃”者比比皆是，这部分也会成为通过率的分母；
3、软考成绩不保留，就是说必须一次性通过所有科目，复习不全面的话，很有可能一科及格一科不及格，只有从头再来；
4、缺考人数多，考试的时候您会发现考场中很多位置是空着的，因为报名费便宜，付出的成本低，没有把握或没有学习的临考了发现啥也没准备，就不来白辛苦了，而且还有一部分是没复习好的，但是报着来看看题、体验体验考试氛围的态度来的，这些都会成为“分母”。
5、学习方法不对，如果纯自学没有人指导，很有可能走弯路，不知道重点、考点，时间精力花了，但是方向不对，翻开书好像啥都懂，一看到题就懵圈，考得稀里糊涂。
通过以上原因分析，可以看出，只要您坚定信念、明确目标、坚持学习，再掌握科学的学习方法，那么你就已经战胜了60-70%的人，再此基础上再努努力，做做好人好事积累点运气，您就是通过的那部分人，成为通过率里面的“分子”！
软考信息安全工程师考试中，下午的案例分析是您能否通过考试的关键，案例能通过则整体通过概率就很高，因为从21年考试来看，上午的基础知识考得很简单，下午的案例很难。
和软考文科类考试不一样，信安的案例不是靠背靠记，或者瞎写把卷子写满就能过的，会就是会，不会就是不会，所以打好基础，建立自己的知识体系很重要，至强老师有多年网络安全从业经验，同时熟悉软考的特点，大家有信安考试相关的疑难问题都可以进行咨询。
如大家在学习中遇到问题，欢迎通过邮件2976033@qq.com留言给作者，以便共同探讨。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d89ab806b607d11c565a42a7ba5e7b1/" rel="bookmark">
			VM虚拟机安装Centos7 | 静态ip网络服务配置 | 虚拟化 | 虚拟机运行架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 在学习之前我觉得有必要先介绍一些前置的知识,列如 “虚拟化” 和 “虚拟机” 还有 “虚拟机运行架构”，这样更有利于我们对操作环境的理解
(1).什么是虚拟化 ? VT 就是虚拟化技术（Virtualization Technology）的缩写 是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机 对计算机物理资源的抽象，实现资源的模拟、隔离和共享, 计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。 虚拟化又可以分为 基于平台的平台虚拟化（我们将要学习的场景） 基于操作系统的操作系统虚拟化,这里小编就不细聊了
虚拟化解决的问题 还有很多具体的大家可以查阅文档了解 资源充分利用
环境的高耦合
缩短交付时间
关键负载的高可用性
提高运营效率
系统安全性
(2).什么是虚拟机 ? 虚拟系统通过真机（硬件机）生成现有操作系统的全新虚拟镜像（IOS文件），它有真实Windows系统完全一样的功能，一样的操作体验。进入虚拟系统后，所有操作都是在这个全新虚拟系统里面进行，可以独立安装运行软件，保存数据，拥有自己的独立的桌面（desktop），不会对真正的系统产生任何影响 ，而且具有能够在现有系统与虚拟镜像之间灵活切换的一类操作系统,并且，使用虚拟机的“Undo”（恢复）功能，我可以马上恢复虚拟机到安装软件之前的状态 很适用了我们用来做实验 做测试 和学习。
2.开始 回归主题
想要学习nginx,首先我们需要一个linux的环境,这时最好的方案就是利VMware Workstation 虚拟机 打造一个寄居架构的运行环境来进行学习。
// 本篇博客采用的软件版本 VMware Workstation 16.2.1 // 虚拟机软件 CentOS-7-x86_64-Minimal-1708.iso // centos镜像 这里采用的是Minimal版 没有图形化界面 VMware Workstation虚拟机下载地址 | 官网地址
centos镜像下载地址
虚拟机安装步骤小编在这里就不给大家演示了
（1）虚拟机运行架构 1.寄居架构 这里小编画了一张图 帮助小伙伴们更好的理解 寄居架构
寄居架构 寄生在虚拟机监视器上的环境与宿主互不干扰 所以多用于 实验环境 和 测试环境 当然我们用来学习也是非常不错的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d89ab806b607d11c565a42a7ba5e7b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94cdb0b6f7e97e5cb68ce0ca2be7cf4a/" rel="bookmark">
			mybatis子查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		①普通一对多子查询
一个用户对应多个角色
RoleMapper类：
@Mapper public interface RoleMapper extends BaseMapper&lt;Role&gt; { List&lt;Role&gt; getRolesByHrId(Integer hrId); } RoleMapper.xml:
根据用户id通过中间表查询该用户的所有角色
&lt;resultMap id="BaseResultMap" type="com.***.entity.Role"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;result column="nameZh" property="nameZh"/&gt; &lt;/resultMap&gt; &lt;select id="getRolesByHrId" parameterType="Integer" resultMap="BaseResultMap"&gt; SELECT r.* FROM hr_role hrr LEFT JOIN role r ON hrr.rid = r.id WHERE hrr.hrid = #{hrId} &lt;/select&gt; Hr类:
在实体类中添加一对多的字段属性，由于该属性在数据库中并不存在，故用注解标记。
@TableField(exist = false) private List&lt;Role&gt; roles; HrMapper类：
根据用户名查询角色
@Mapper public interface HrMapper extends BaseMapper&lt;Hr&gt; { Hr loadUserByUsername(String username); } HrMapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94cdb0b6f7e97e5cb68ce0ca2be7cf4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/836d209031c7752ab267dd815e5a8f18/" rel="bookmark">
			minio分布式集群同步Windows
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** 启动命令 */ set MINIO_ROOT_USER=admin set MINIO_ROOT_PASSWORD=admin123 minio.exe server --console-address ":9001" --address ":9091" D:/minIOData /* 启动命令说明 */ 本示例, 两台主机111和222都执行了以上命令,
先将CMD命令行目录前换到minio.exe同目录下
set MINIO_ROOT_USER=admin // 设置控制台管理账号 , 各集群账号密码需要一致
set MINIO_ROOT_PASSWORD=admin123 // 设置控制台管理密码
minio.exe server --console-address “:9001” --address “:9091” // 9001为控制台访问端口, 9091为接口访问端口
D:/minIOData // 本地单节点保存
// 下面的将单节点换成多节点示例, 只能是本机或者局域网, 不可是公网地址或域名 !!! , 多节点每台服务器都要执行一次启动命令 http://192.168.1.12:9091/C:/minIOData ^ // 本机存储目录
http://192.168.1.12:9091/D:/minIOData ^ // 本机存储目录2
http://192.168.1.13:9091/C:/minIOData ^ // 局域网集群ip:端口/存储目录
http://192.168.1.13:9091/D:/minIOData // ^ 为 Windows的cmd命令行的 换行符
/** 集群同步备份1:控制台备份,其中一个删了重来则会出问题,推荐使用下面的方法2 */ 浏览器打开控制台页, 端口为上方配置的–console-address
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/836d209031c7752ab267dd815e5a8f18/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/204/">«</a>
	<span class="pagination__item pagination__item--current">205/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/206/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>