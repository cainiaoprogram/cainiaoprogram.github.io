<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/447e88a2731dc59bdadbc25bdaac0027/" rel="bookmark">
			CVPR2023 SuperYOLO全文翻译（人工校正）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多模态遥感图像中的超分辨率辅助目标检测（SuperYOLO） 单位：西电, 西蒙菲莎大学, 密西西比州立大学
代码：https://github.com/icey-zhang/SuperYOLO
论文：https://arxiv.org/abs/2209.1335
摘要-准确和及时地从遥感图像（RSI）中检测到包含数十个像素的多尺度小物体仍然具有挑战性。现有的解决方案主要是设计复杂的深度神经网络，学习从背景分离的对象的强特征表示，这往往会造成沉重的计算负担。在本文中，我们提出了一种精确而快速的RSI目标检测方法SuperYOLO，该方法融合多模态数据（RGB和IR），利用辅助超分辨率模块（SR）学习对多尺度目标进行高分辨率（HR）目标检测。首先，我们利用对称紧凑的多模态融合（MF）从各种数据中提取互补信息，以改进RSI中小目标检测性能。此外，我们设计了一个简单而灵活的SR分支来学习HR特征表示，可以通过低分辨率（LR）输入区分小物体和大背景，从而进一步提高检测精度。此外，为了避免引入额外的计算，在推理阶段丢弃了SR分支，并且由于LR的输入而减少了网络模型的计算。实验结果表明，在广泛使用的VEDAI RS数据集上，SuperYOLO的准确率为75.09 (对于mAP50)，这比SOTA大型机型如YOLOv5l、YOLOv5x和RS设计的YOLOrs高出10%以上。同时，SuperYOLO的参数大小和GFOLPs比YOLOv的5x小约18倍和3.8倍。与现有的模型相比，我们提出的模型显示出良好的精度和速度权衡。代码将在https://github.com/icey-zhang/SuperYOLO
索引术语——目标检测、多模态遥感图像、超分辨率、特征融合
I. 介绍 目标检测在计算机辅助诊断或自主驾驶等各个领域发挥着重要作用。在过去的几十年里，许多优秀的基于深度神经网络（DNN）的目标检测框架[1]、[2]、[3]、[4] 、[5]在计算机视觉中被提出、更新和优化。由于应用大规模自然数据集的准确注释[6]，[7]，[8]，基于DNN的目标检测框架的精度有了显著的提高。
与自然场景相比，遥感图像（RSIs）中的精确目标检测存在几个重要的挑战。首先，标记样本的数量相对较少，这限制了训练DNN以实现较高的检测精度。其次，RSI中物体的尺寸要小得多，相对于复杂而广阔的背景[9]，[10]，只占几十个像素。此外，这些对象的规模是多样的，有多个类别[11]。如图1 (a)所示，目标车在一个大范围内相当小。如图1 (b)所示，这些物体有大规模的变化，汽车的规模比露营车的规模要小。
目前，大多数目标检测技术都是单独设计和应用于单一的模态信息，如RGB和红外（IR）[12]，[13]。因此，在物体检测方面，由于不同模式[14]之间缺乏互补信息，它识别地球表面物体的能力仍然不足。随着成像技术的蓬勃发展，从多模态中收集的RSIs成为可能，并为提高检测精度提供了机会。例如，如图1所示，两种不同的多模式（RGB和IR）的融合可以有效地提高RSI的检测精度。有时一种模态的分辨率很低，这需要通过技术来提高分辨率来增强信息。近年来，超分辨率技术在[15]、[16]、[17]、[18]等遥感领域显示出了巨大的潜力。由于卷积神经元网络（CNN）的蓬勃发展，遥感图像的分辨率实现了高纹理信息的解释。然而，由于CNN网络的高计算成本，SR网络在实时实际任务中的应用已成为当前研究的热点。
在这项研究中，我们的动机是提出一个机载（on-board）多模态的实时目标检测框架，在不引入额外计算开销的情况下实现高检测精度和高推理速度。受实时紧凑神经网络模型最近进展的启发，我们选择了小尺寸的YOLOv5s [19]结构作为我们的检测基线。它可以降低部署成本，并促进模型的快速部署。考虑到小物体的高分辨率（HR）保留要求，我们在基线YOLOv5s模型中删除了Focus模块，这不仅有利于定义小密集物体的位置，而且提高了检测性能。考虑到不同模态信息下的互补特性，我们提出了一种多模态融合（MF）方案来提高RSI的检测性能。我们评估不同的融合方案（像素级或特征级），并选择像素级融合以实现低计算成本。
最后，我们开发了一个超分辨率（SR）保证（assurance？？）模块，以指导网络生成能够在大背景下识别小物体的HR特征，从而减少RSI中背景污染物体引起的误报。然而，一个简单的SR解可能会显著增加计算成本。因此，我们设置了在训练过程中使用的辅助SR分支，并在推理阶段将其删除，在不增加计算成本的情况下，促进了HR中的空间信息提取。
综上所述，本文有以下贡献。
我们提出了一种计算友好的像素级融合方法，以对称和紧凑的方式双向结合内部信息的方法。与特征级融合相比，它在不牺牲精度的情况下有效地降低了计算成本。我们首次在多模态目标检测中引入了一个辅助的SR分支。我们的方法不仅在有限的检测性能方面取得了突破，而且为研究优秀的HR特征表示提供了一种更灵活的方法，这些特征表示能够通过LR输入从大的背景中区分小目标。考虑到对高质量结果和低质量结果的需求计算成本，SR模块作为一个辅助任务在推理阶段被删除，而不引入额外的计算。SR分支是通用的和可扩展的，可以插入到现有的全卷积网络（FCN）架构中。提出的SuperYOLO显著提高了目标检测性能，在实时多模态目标检测中优于SOTA检测器。与现有的模型相比，我们提出的模型显示出良好的精度-速度平衡。 II. 相关工作
A.使用多模态数据的对象检测
近年来，多模态数据在许多实际应用场景中得到了广泛应用，包括视觉问题回答[20]、自动驾驶车辆[21]、显著性检测[22]和遥感分类[23]。结果发现，结合多模态数据的内部信息可以有效地传输互补特征，避免单一模态的某些信息被遗漏。
在RSI处理领域，存在各种模式（如红绿蓝（RGB）、合成孔径雷达（SAR）、光检测和测距（激光雷达）、红外（IR）、全色（PAN）和多光谱（MS）图像），可以与互补的特性融合，以提高[24]、[25]、[26]等各种任务的性能。例如，额外的红外模态[27]捕获更长的热波长，以提高在困难的天气条件下的检测。曼尼什等人。[27]提出了一种在多模态遥感成像中进行目标检测的实时框架，其中扩展版本进行了中层融合和合并来自多种模式的数据。尽管多传感器融合可以提高检测性能，但其低精度的检测性能和有待提高的计算速度几乎难以满足实时检测任务的要求。
融合方法主要分为三种策略。e., 像素级融合、特征级融合和决策级融合方法[28]。决策级融合方法将最后阶段的检测结果进行融合，由于对不同的多模态分支进行重复计算，可能会消耗大量的计算资源。在遥感领域，主要采用多分支的特征级融合方法。将多模态图像输入到并行分支中，提取不同模态的独立特征，然后将这些特征通过一些操作进行组合，如注意模块或简单连接。随着模式的增加，并行分支带来了重复的计算，这在遥感的实时任务中并不友好。
相比之下，采用像素级融合方法可以减少不必要的计算。在本文中，我们提出的SuperYOLO在像素级进行多模态特征融合，显著降低了空间和信道域的计算成本和设计操作，以提取不同模态的内部信息，从而提高检测精度。
B.目标检测中的超分辨率
在最近的文献中，通过多尺度特征学习[29]、[30]、基于上下文的检测[31]，可以提高小目标检测的性能。这些方法总是提高了网络在不同尺度上的信息表示能力，但忽略了高分辨率的上下文信息保留。按照预处理步骤进行，SR在[32]，[33]中被证明在各种目标检测任务中是有效的。谢梅耶等人。[34]通过RSI的多重分辨率，量化了其对卫星成像检测性能的影响。基于生成式对抗网络（GANs），Courtrai等人 [35]利用SR生成HR图像，并将其输入检测器，以提高其检测性能。拉比等 [36]利用拉普拉斯算子从输入图像中提取边缘，从而增强了对HR图像的重构能力，从而提高了其在目标定位和分类方面的性能。Hong等。[37]引入了循环一致的GAN结构作为一个采用SR网络和改进的更快的R-CNN架构进行检测由SR网络产生的增强图像所产生的车辆。在这些工作中，SR结构的采用已经有效地解决了有关小对象的挑战。然而，与单一检测模型相比，还引入了额外的计算量，这是由于HR设计放大了输入图像的尺度。
最近，王等人 [38]提出了一个SR模块，它可以用LR输入来维护HR表示，同时减少分割任务中的模型计算。受[38]的启发，我们设计了一个SR辅助的分支。与之形成对比，在上述的工作中，SR被实现在开始阶段，辅助SR模块指导检测器高质量HR表示的学习，不仅增强了密集小目标的响应，而且提高了空间中目标检测的性能。此外，在推理阶段删除了SR模块，以避免额外的计算。
III. 基线模型架构 如图2所示，基线YOLOv5网络由两个主要组件组成：主干和头部（包括颈部）。该主干旨在提取低级纹理和高级语义特征。接下来，这些提示（hint??）特征被输入到Head来构建增强的特征金字塔网络，从上到下传递鲁棒的语义特征，并从下到上传播对局部纹理和模式特征的强烈响应。这就解决了物体的不同尺度问题，增强了对不同尺度物体的检测能力。
在图3中利用CSPNet [39]作为骨干来提取特征信息，由大量的采样卷积C-批归一化B-SiLu（CBS）组件和跨阶段部分（CSP）模块组成。CBS由卷积、批处理归一化和激活函数SiLu [40]等操作组成。CSP将前一层的特征映射复制为两个分支，然后通过1x1卷积将信道数减半，从而减少了计算量。对于特征图的两个副本，一个被连接到阶段的末端，另一个被发送到ResNet块或CBS块作为输入。最后，将特征映射的两个副本连接起来，以组合这些特征，然后是一个CBS块。SPP（空间金字塔池）模块[41]由不同内核大小的并行Maxpool层组成，用于提取多尺度深度特征。通过堆叠的CSP、CBS和SPP结构提取底层纹理和高级语义特征。
缺陷1：值得一提的是，引入焦点模块是为了减少计算的数量。如图2（左下角）所示，输入被划分为单独的像素，每隔一段时间进行重建，最后连接到通道维度中。将输入的大小调整到更小的规模，以降低计算成本，加速网络训练和推理速度。然而，这可能会在一定程度上牺牲目标检测精度，特别是对于容易被分辨率的小物体。
缺陷2：已知YOLO的主干采用深度卷积神经网络提取层次特征，步长为2，通过步长提取的特征的大小减半。因此，用于多尺度检测所保留的特征尺寸远小于原始输入图像。例如，当输入图像大小为608时，针对最后一个检测层的输出特征的大小分别为76、38和19。LR特性可能会导致丢失一些小目标。
IV. SuperYOLO结构 如图2所示，我们为我们的SuperYOLO网络架构介绍了三个新的贡献。首先，我们删除了主干网中的焦点模块，并将其替换为一个MF模块，以避免分辨率下降，从而导致精度下降。其次，我们探索了不同的融合方法，并选择了计算效率高的像素级融合来融合RGB和IR模式，以细化不同和互补的信息。最后，我们在训练阶段添加了一个辅助SR模块，它重构HR图像，指导空间维度上的相关主干学习，从而维护HR信息。在推理阶段，丢弃SR分支，以避免引入额外的计算开销。
A.焦点移除
如第三节和图中所示。2（左下），YOLOv5主干网中的Focus模块在空间域上以间隔分割图像，然后重新组织新图像以调整输入图像的大小。具体来说，该操作是为图像中每一组像素的值，然后进行重构，得到更小的互补图像。重建的图像的大小随着通道数量的增加而减小。因此，它会导致小目标的分辨率下降和空间信息损失。考虑到对小目标的检测更依赖于更高的分辨率，因此放弃了Focus模块，用一个MF模块取代（如图4所示）来防止分辨率降低。
B.多模态融合
区分对象的信息越多，目标检测的性能就越好。多模态融合是合并来自不同传感器的不同信息的有效路径。决策级、特征级和像素级的融合是三种主流的融合方法，可以部署在
网络的不同深度。由于决策级融合需要大量的计算，因此在SuperYOLO中不考虑它。
我们提出了一种像素级的多模态融合（MF）来从不同的模态中提取共享的和特殊的信息。MF可以以对称和紧凑的方式双向结合多模态内部信息。如图4所示，对于像素级融合，我们首先将输入的RGB图像和输入的IR图像归一化为两个[0,1]区间。输入模态 XRGB、XIR ∈ R C×H×W 被子采样为 IRGB、IIR ∈ R C× H n × W n，再送入 SE 块提取信道域的内部信息[42]，生成 FRGB、FIR：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/447e88a2731dc59bdadbc25bdaac0027/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/169824b6a50ef01eab35820f46ffe728/" rel="bookmark">
			匿名函数、迭代器对象、内置函数、异常捕获
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、匿名函数二、常见的内置函数1.map()映射2.zip()拉链3.max()最大值 min()最小值4.filter()过滤 三、可迭代对象四、迭代器对象五、for循环内部原理六、异常捕获1.什么是异常2.异常的信息3.异常的类型3.异常的分类4.异常如何进行捕获 一、匿名函数 ''' 匿名函数就是没有名字的函数，需要使用关键字lambda 匿名函数的语法结构： 变量名 = lambda 参数:返回值 参数可以有多个，中间用逗号隔开 匿名函数不管有多复杂的逻辑，也只能写一行 且逻辑执行结束后的内容就是返回值 返回值和正常的函数一样可以是任意数据类型 应用场景 lambda x,y:x+y 匿名函数一般不单独使用，需要配合其他函数一起用，主要用于减少代码 ''' '''正常方式''' def index(x): return x**2 res = index(2) print(res) '''匿名函数''' #单参数 res = lambda x:x**2 print(res(2)) #多参数 res = lambda x,y:x+y print(res(4,5)) #可不赋值 print((lambda a:a+1)(3)) 二、常见的内置函数 1.map()映射 内置函数配合匿名函数使用 1.map()映射 '''# map也像for循环一样把每一个数据值映射出来交给下面的函数名''' 已知现在有一个列表，需要给列表中每个元素开方 ll = [1,2,3,4,5,6] '''正常方式''' # 定义一个空列表 num_list = [] for i in ll: num_list.append(i ** 2) print(num_list) '''函数''' def index(x): return x **2 res = map(index, ll) print(res) # &lt;map object at 0x0000024D961AC3D0&gt; print(list(res)) # 需要转换成对应数据类型 '''匿名函数''' res = map(lambda x: x ** 2, ll) print(list(res)) # 需要转换成对应的数据类型 ''' 底层也是for循环 循环出每一个数据值，把数据值交给函数去处理， 就会返回数据值，依次顺序循环 这就是映射 ''' 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/169824b6a50ef01eab35820f46ffe728/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33bea744574371876c70d0d30d83240e/" rel="bookmark">
			关于《考研数学高分公式》系列的后续及一点说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 在昨天，当我再次登录CSDN时，我惊讶地发现《考研数学高分公式》这一系列的两篇文章竟然拥有超过数万次的阅读量。许多学弟学妹也通过私信向我询问，为什么不再继续更新这个系列了。
未及时回复他们，颇感惭愧。
我仔细考虑之后，决定将这个系列完整地完成下去。
这样做一是为了给自己早已结束的备考生活一个交代，二是希望这些内容能够对学弟学妹们有些许的帮助。
1 初次相见 我还记得那天的样子。我坐在自习室里学习高等数学，看的书是宇哥的《基础30讲》和同济大学的《高等数学》教材。我忘了这两本书是哪一本，这本书的后面附上了好几页的高数公式。当然大部分是不需要记忆的。
后来偶然间得到了一份文档：《积分表公式推导》。这份电子文档非常详细了列出了各种形式的积分公式。而且更重要的是，它的每个公式后面都附上了推导过程。
如获至宝！那时的我似乎想把这些公式全都记忆下来，包括推导过程。因为无论是数一、数二还是数三，若要记住这些公式，很多题目都是瞬间解题，即省去了思考时间，又不至于出错，直接对照着模板写出答案了。
2 开始着手 于是，我向我的好朋友，也是我考研的研友说：以后每天掌握两个公式，并且通过写博客的方式记录这个过程。既能加深印象，又能在帮助到各位不会谋面的研友，给备战考研的枯燥生活中加点乐趣！
比如上面的这两个公式，我估计没有一个老师要求记住它。但是如果你若能记住它的话，你能得到什么呢？答案不言而喻，你会很轻松的写出这个形式的积分结果。更重要的是，如果你亲手去推导的话，你会在过程中记住更多形式的积分公式，掌握更多的积分方法。
你可以看看这篇文章感受一下。
本来计划每天写两个公式，包括自己记住它们和把它们写成博客。
3 实际上 你们也看到了，实际上我只坚持了两天，而且这两天每天只完成了一个公式。现在回想起来颇为好笑。为什么没坚持下去呢？我想了几个原因：
3.1 使用LaTeX编辑公式工作量大。 估计很多人没有用过LaTex。这个排版方式很好用，搞科研、发论文几乎都要用到的工具。
比如上面的这个公式，使用LaTex完整写下来是这个样子的：
条件：(a^2&gt;b^2)：\int{\frac{1}{a+bcosx}dx}=\frac{2}{a+b}\sqrt{\frac{a+b}{a-b}}\arctan(\frac{a+b}{b-a}\tan\frac{x}{2})+C 3.2 自己坚持不下去。 这两个公式看上去没什么工作量，其实不然。
从理清楚思路，到完整清晰地写下它们的步骤，再到编辑成博客，这一套流程下来没有两个小时是完不成的。
而且这两个小时是注意力集中的两小时，是自己每天状态最好的时间。
这个时候已经是十月份了，不足两个月的时间，实在没多余的精力写这个了！
这里向很多网友说声抱歉！
3.3 思想动摇了。 我朋友问我：记这么多公式有用吗？我始终认为是非常有用的。但是凡事要权衡利弊。
当你的复习时间很紧迫时，你就必须进行抉择以使得到的“效益”最大化。
很显然，这个时候再抱着一堆公式记忆、推导显然是不理智的决定。
4 后来呢 后来……我真的不想回忆！说句实话，那段历史真的令我抓狂！
考完数学的那个中午，我觉得我完了！稀里糊涂的做完试题，好几个答题第二问都没答上来。那感觉难以言表，整个考数学的时间段都是不在状态，浑浑噩噩，思路不清。
这造成了很严重的后果。回到宿舍后，我的室友们已经开始了摆烂。他们考数三，数学已经把他们的信心消耗的一干二净。我没抱怨，只是苦笑。原计划吃过午饭后去图书馆记一下专业课（计算机网络、数据结构）的知识点和公式，但是这个时候已经没了心情，觉得肯定考不上了。
按理来说，这个时候应该更加努力的准备下一门考试。但是我没有，信心与耐心被消耗殆尽，开始了摆烂。
这导致了严重的后果。专业课第一个大题就是一道需要用到香农定理公式的题目。可惜……我没记住香农公式。之前复习的时候感觉考它的概率不大，在考前看一下就行。害！
控制好心态，不到最后一刻千万不要放弃！
5 现如今 成绩出来后，倒是让我有点吃惊。比我想象的要高，但是数学和专业课惨不忍睹。调剂到一个不知名高校……
稀里糊涂，现在已经是研二，没啥拿得出手的科研成果，只想着毕业就行了……
昨天我重新登陆CSDN，吃惊的发现《考研数学高分公式》系列的两篇文章，竟高达数万的阅读量，很多学弟学妹私信问我为什么不继续更新了……没有及时回复他们，让我感到很惭愧。于是想着万事有始有终，就抽空把这个系列完成一下，一是给自己的备考生活一个交代，二是希望能帮助到学弟学妹。
6 写给正在准备考研的你们 不到最后一刻，千万不要放弃！
我想告诉你们的是，不到最后一刻千万不要放弃。
这句话听起来似乎有些老生常谈，但却是无数成功者用亲身经历验证过的真理。
在考研的过程中，我们总会遇到各种各样的困难和挫折，有时候甚至会感到绝望。
但是，请记住只有坚持到最后，你才能真正体会到成功的喜悦。
无论考场上遇到怎样的情况，都应该认真对待，沉下心来，不浮不躁。
这，即胜利！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94386d453e2f47586c0682a4d328ca74/" rel="bookmark">
			信息技术--案例分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 信息核心素养2 具备核心素养的学生3 导入原则4 导入方法5 新课讲授方法6 教学方法选择的依据7 教学方法的实施原则8 教学方法的设计意图9 小结10 作业 前言：
分值：本章节的内容在信息技术笔试中占据45分的分值，分别是18题10分，19和20题共30分，总计40分。需要重点背诵，有技巧的背诵
内容：理论知识点记清楚之后，对照着材料的情况，进行分析作答，定位准确，依据合理即可，没有很标准的答案，看自己的文笔
1 信息核心素养 信息意识： 是指个体对信息的敏感度和对信息价值的判断能力 计算思维： 是指个体采用计算机领域的方法，在问题解决方案的过程中新城的一系列思维活动 数字化学习与创新： 是指个体利用数字化资源与工具，有效管理学习资源和学习过程，创造性的解决问题，形成创新作品的能力 信息社会责任： 是指个体在文化修养，道德规范，行为自律等方面应尽的责任 2 具备核心素养的学生 具备信息意识的学生：获取 判断 分享 能够主动的通过合理的方式获取信息 能够敏感的察觉到信息的便捷化，做出合理的判断 能够与团队成员共享信息，实现嘻嘻的最大价值 具备计算思维的学生：建模 算法 迁移 能够采用计算机处理问题的方式建立模型 能够使用合理的算法形成问题解决的方案 能够将计算机处理问题的方法迁移到其他问题的处理上来 具备数字化学习与创新的学生：适应 习惯 技能 能够适应数字化学习的环境 能够养成数字化学习与创新的习惯 能够掌握数字化资源与工具的操作技能 具备信息社会责任的学生：遵守 关注 态度 具备一定的信息意识和信息安全能力，遵守信息法律法规 关注信息技术革命带来的人文问题和环境问题 对信息技术产生的新事物和新概念，具有积极学习的态度，以及了理性判断和负责行动的能力 3 导入原则 口诀：针趣简启 针对性：是指导入的内容与新授的内容要保持一致 趣味性：是指导入要有趣味性，能够引起学生的兴趣 简洁性：导入要言简意赅，合理控制时间，一般不超过分钟 启发性：导入过程中提出问题，引导启发学生思考 4 导入方法 1、温故知新：通过回顾与新知相关的知识点，顺理成章的导入新课 2、生活情形：教师讲述与教学内容有密切关系的生活案例，从而导入新课 3、作品情境：教师展示与新授内容相关的优秀作品或正反两个作，从而导入新课品 4、活动情境：教师组织学生参与和教学内容相关的活动，从而导入新课 5 新课讲授方法 任务驱动法 小组探究法 自主探究法 操作演示法 范例教学法 讲授法 6 教学方法选择的依据 1、依据教学目标：不同层次教学目标的有效达成，需要借助相应的教学方法 2、依据教学内容：不同阶段，不同单元，不同课时的教学内容不同，选择的教学方法也不同 3、依据学生特点：学习者自身的特点直接制约着教师对教学方法的选择 4、依据教师的自身素质：适应了教师的素养条件，并能被教师充分理解和掌握 5、依据教学环境条件：最大限度的发挥教学环境条件的功能和作用 7 教学方法的实施原则 任务驱动法： 1、任务要在一定的情境中呈现，任务要有针对性，趣味性，生活化等特点 2、任务设置的难度要适宜，不能太难或过于简单 3、将较难的任务划分成多个子任务，形成任务梯度和任务链 4、任务要有激励作用，鼓励学生互相合作互相班主完成任务 5、对任务的完成情况进行总结评价，及时梳理理论知识 合作探究法： 探究前： 教师指导分组，按照组内异自组间同质进行分组，一般4-6人为主 教师知道分工，包括和角色分工和任务分工 教师明确讨论课题，讨论时间、讨论要求 探究中： 教师巡视指导，个别问题个别处理，共性问题共性处理 探究后： 小组总结，教师评价 操作演示法： 1、教师在演示的过程中，需要紧密结合画面对难以理解的知识点，进行讲解和说明 2、教师在演示过程中要设置疑问，提出问题，引导学生思考 3、教师在演示完毕之后，学生进行独立操作，进一步加深对操作的理解 4、学生操作过程中，教师要巡视指导，学生操作完毕展示作品，并总结评价 8 教学方法的设计意图 1、突出学生的主体地位 合作探究法 自主探究法 教师将学习的主动权交还给学生，学生能够在亲身实践中提出问题，分析问题，解决问题 2、提高学习兴趣 情境导入 任务驱动法 合作研究法 将理论性的知识蕴含在富有情形的教学活动中，能够拉近本课知识与学生生活经验的距离，提高学生的学习兴趣 任务划分成多个子任务，不仅形成了任务梯度，还给学生提供了较大的研所空间，增强了学生的体验感，提高了学习兴趣 通过合作探究，可以为学生提供讨论和交流的机会，提高了学习兴趣 3、面向全体学生 分层次教学 合作研究 设置分层教学有利于面向全体学生，按照好中差比例分组，学生之间互相帮助，共同提高，分层次教学很好的解决了统一施教与学生程度参差不齐的矛盾， 小组合作研究可以保证全体学生都能参与进来，充分锻炼了学生的合作交流能力，有利于培养学生分析问题和解决问题的能力 4、提高课堂效率 操作演示法 讲授法 通过教师的讲解和演示，学生对于操作有一个初步的了解，学生通过先观察再操作循序渐进的方法，可以提高课堂效率 本科的知识比较抽象，如果让学生谈论探究可能会花费较多的时间和精力，通过教师的讲解，不仅可以降低学习难度，还可以提高课堂效率 9 小结 交流反馈发 在教师的指导下，学生谈心得，谈体会，教师做补充，编口诀 提高学生的积极性，体现教师对于重难点的把我 归纳总结法 教师提供或者与学生共同完成本节课的知识框架 能够做到查缺补漏，学生对本节课的知识框架有一个清晰的了解 作品赏析发 教师出示优秀作品，学生赏析 能够提高学生分析和欣赏美的能力，同时能够对自己的作品进行反思 10 作业 操作类：完成某一生活作品案例 巩固所学知识，做到学以致用 搜集类：所以与本课相关的知识背景 能够拓宽学生的视野和知识面 预习类：预习下节课的知识 为下节课的学习做铺垫，降低学习难度 创作不易，请多多点赞，感谢支持，欢迎指教！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4224d3c1fe58b50797b32b8e9f90e039/" rel="bookmark">
			基于rk3326的ANDROID11 不息屏不锁屏代码修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景
1.硬件平台：RK3326/RK3566
2、操作系统： ANDROID11
取消自动息屏及锁屏界面，修改如下：
二、修改文件：
1、frameworks/base/packages/SettingsProvider/res/values/defaults.xml diff --git a/packages/SettingsProvider/res/values/defaults.xml b/packages/SettingsProvider/res/values/defaults.xml old mode 100644 new mode 100755 index 761d8bcbed00..7b10dcd8c533 --- a/packages/SettingsProvider/res/values/defaults.xml +++ b/packages/SettingsProvider/res/values/defaults.xml @@ -18,7 +18,7 @@ --&gt; &lt;resources&gt; &lt;bool name="def_dim_screen"&gt;true&lt;/bool&gt; - &lt;integer name="def_screen_off_timeout"&gt;60000&lt;/integer&gt; + &lt;integer name="def_screen_off_timeout"&gt;2147483647&lt;/integer&gt; &lt;!-- 取消熄屏，设置为一个非常大的数值，超过2147483647 --&gt; &lt;integer name="def_sleep_timeout"&gt;-1&lt;/integer&gt; &lt;bool name="def_airplane_mode_on"&gt;false&lt;/bool&gt; &lt;bool name="def_theater_mode_on"&gt;false&lt;/bool&gt; @@ -71,7 +71,7 @@ &lt;string name="def_desk_undock_sound" translatable="false"&gt;/product/media/audio/ui/Undock.ogg&lt;/string&gt; &lt;string name="def_car_dock_sound" translatable="false"&gt;/product/media/audio/ui/Dock.ogg&lt;/string&gt; &lt;string name="def_car_undock_sound" translatable="false"&gt;/product/media/audio/ui/Undock.ogg&lt;/string&gt; - &lt;integer name="def_lockscreen_sounds_enabled"&gt;1&lt;/integer&gt; + &lt;integer name="def_lockscreen_sounds_enabled"&gt;0&lt;/integer&gt; &lt;!-- 当解锁或是锁屏时是否播放声音 Settings.System.LOCKSCREEN_SOUNDS_ENABLED 0：不播放 --&gt; &lt;string name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4224d3c1fe58b50797b32b8e9f90e039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cebb5902b4e6d36858eb6a8201ef19e/" rel="bookmark">
			「笔记」OfferCoder：剑指Offer刷题笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		剑指Offer刷题笔记 1. 数组中重复的数字2. 二维数组中的查找3. 替换空格4. 从尾到头打印链表 1. 数组中重复的数字 描述：
在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1
答案：
public int duplicate (int[] numbers) { // write code here if (numbers == null || numbers.length == 0) { return -1; } HashSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;(); for (int i = 0; i &lt; numbers.length; i++) { if (hashSet.contains(numbers[i])) { return numbers[i]; } else { hashSet.add(numbers[i]); } } return -1; } **扩展知识：**hashSet具有唯一性、无序性、允许为空、非线程安全
2. 二维数组中的查找 描述：
在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cebb5902b4e6d36858eb6a8201ef19e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5afdfe0837f64c0a0f32fd555c16116/" rel="bookmark">
			DDoS攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍： 分布拒绝服务（Distributed Denial of Service,DDoS）攻击是一种遍布全球的漏洞攻击方式，采用分布、协作的大规模攻击方式，利用目标系统网络服务功能缺陷或者直接消耗其系统资源，阻止目标为合法用户提供服务，对服务器安全造成相当大的威胁。
目录
一、设置Vmnet 4网卡 网段为：192.168.2.0
二、设置虚拟机kali系统的网卡为vmnet 4
​三、设置kali系统的IP地址为192.168.2.2
四、配置win7的IP地址（192.168.2.3）
五、关闭win7的防火墙
六、打开kali实现与win 7 互通
七、win7操作系统安装wireshark抓包软件
八、实现DOS攻击
九、使用win7系统利于wireshark抓包查看效果
一、设置Vmnet 4网卡 网段为：192.168.2.0 编辑——&gt;虚拟网络编辑器——&gt;添加网络——&gt;vmnet 4——&gt;修改vmnet 4 IP地址为192.168.2.0
二、设置虚拟机kali系统的网卡为vmnet 4 网络适配器--&gt;自定义网卡--&gt;选择vmnet 4
三、设置kali系统的IP地址为192.168.2.2 1、取得root权限
sudo passwd root //给root配置密码 su - root //切换到root 2、设置IP地址
vim /etc/network/interfaces //修改网卡配置文件 3、进入vim后在内容最后两行添加以下内容
auto eth0 iface eth0 inet static address 192.168.2.2 netmask 255.255.255.0 gateway 192.168.2.254 4、重启网卡
/etc/init.d/networking restart 5、重启电脑
reboot 6、查看IP地址
ifconfig 四、配置win7的IP地址（192.168.2.3） 五、关闭win7的防火墙 控制面板 ——&gt; 大图标 ——&gt; 防火墙 ——&gt; 关闭防火墙
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5afdfe0837f64c0a0f32fd555c16116/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93eef2f29da43511508ab7d231d0a92a/" rel="bookmark">
			本特利BENTELY 3500/32 4通道继电器模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要特点：
单刀双掷 (SPDT) 继电器
环氧树脂密封
-22 至 150°F（-30 至 65 °C）工作温度
本特利内华达 3500/32M 继电器模块是一个全高模块，可提供四个继电器输出。任何数量的 4 通道继电器模块都可以放置在瞬态数据接口模块右侧的任何插槽中。4 通道继电器模块的每个输出都可以独立编程以执行投票逻辑。
报警驱动逻辑的编程使用 AND 和 OR 逻辑，并且可以使用报警输入（警报和危险状态）、Not-OK 或来自机架中任何监视器通道或监视器通道的任何组合的单个 PPL。用户使用 3500 机架配置软件对该报警驱动器进行编程，以满足应用的特定需求。
零件号
3500/32-01-00
3500/32-01-01
3500/32-01-02 SPIRAX SARCO BC1100
7.611.414 608109-509
FPC101 E.SC-101
D+P D + P FLC300.3
6MD1031-0AA00
1027448 C40S-0901AA310
AG05-0015 98-50W-IP54-KR/14-B-ABM-S3/09-SW
170869 DFM-40-160-P-A-GF
HSZ01.1-D08-D04-NNNN
6020S0103 IMI7340-04A
IS5110-00 825-0059-1R C
603474-101
MATRIX2021HD
IBILDCAR4810A 2819286
PNC3 ECPNC3-1
E041 E 041 0-10V
PA81 PA 81 ECPA81-0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93eef2f29da43511508ab7d231d0a92a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02106c216476f6aaf1ce67ca77035a44/" rel="bookmark">
			压力传感器PFPL203 3BSE055365R1 NPI-15J-C00903 GE/Nova70M P7620C0042A A1004 A1020 C0040 C0042B LPE9400
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ABB缸压传感器PFPL203，柴油机气缸压力监测ABB Cylmate®系统是对发动机运行状态进行连续监测和分析的综合系 统。v18 0 3 0 18 30 32对气缸压力和曲轴位置的测量，结合ABB先进的数学建模，为用户 提供发动机实时准确的数据。
PFPL203压力传感器，对每个气缸内的压力进行连续测量。这种传感器基于ABB压磁技术，精度高、可靠性高。产品概述Cylmate®压力传感器经过工厂标定，可连续测量燃烧压力：一年365天、每天24小时，全天候运行。无需重新标定。测量精度达到满量程0.5%，经常困扰膜式压力传感器的积碳和热膨胀问题，对ABB压力传感器不会有任何影响。
​
ABB型号名称:PFPL203
原产地:Sweden (SE)
1级包装 总重:2.7 kg
1级包装单元:1 piece
部件类型:New
产品:Unclassified
产品净重:2.7 kg
产品应用类型:Unclassified
仅报价:No
更换产品ID（OLD）:3BSE049030R1
技术信息:PFPL203 Cylmate Pressure Transducer Cable length 4 m. Qty per cylinder =1 For PFPC212, socket with 10-pole contact and two locking handles.
​相关传感器型号
NPI-15J-C00903 GE/Nova 70Mpa 压力传感器
P7620C0042A A1004 A1020 C0040 C0042B C0100A 霍尼韦尔 HONEYWELL 微压差传感器
扎克锅炉压力传感器SAACKE DSF125F001 DSB158F913 DSB140F001 SAUTER 250V
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02106c216476f6aaf1ce67ca77035a44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66f151dc8e9e87b1efa809ccb270fdcc/" rel="bookmark">
			本特利3500/34 TMR电源模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本特利bently 3300 XL 8 mm 电涡流传感器灵敏度（ISF）7.87V/mm (200mV/mil)±5％ ，本特利bently 3300 XL 8 mm 电涡流传感器用于汽轮机、压缩机、风机、水泵、磨煤机、齿轮箱、电机等大中型旋转机械的振动监测，广泛应用于钢铁、电力、冶金、化工、石化等很多行业。本特利3300 XL 8 mm 电涡流传感器系统由3300 XL 8mm 探头、延长电缆和前置器组成。 系统输出正比于探头端部与被测导体表面之间的距离的电压信号。它既能进行静态位移测量又能进行动态振动测量，主要用于油膜轴承机械的振动和位移测量，以及键相位和转速测量 符合美国石油学会（API）670 标准。所有的3300 XL 8mm 电涡流传感器系统都能达到规定的性能标准，并且探头、延伸电缆和前置器具有完全可互换性，不需要单独的匹配组件或工作台校准。
常用型号：
本特利330104-00-05-10-02-00
本特利330104-00-06-10-02-00
本特利330104-00-08-10-02-00
本特利330104-00-09-10-02-00
本特利330104-00-10-10-02-00
检测到的信号可传输至bently 3500/25、3500/40M、3500/40M、3500/42M、3500/50等监测器模块。另外还可连接至bently990/991、2300/20、1900/65A等振动监测仪以及其它振动监测仪器。
本特利bently3300XL 8 mm电涡流传感器振动探头系统监测下列大中型旋转机械：汽轮机、水轮机、风机、压缩机、空分机、涡轮膨胀机 、电动机和发电机、励磁机、齿轮箱、水泵等的振动监测。
广泛应用于发电厂、化工厂、炼油厂、钢铁厂、机械厂、水泵厂、风机厂等企业。
bently3300 XL 8 mm 电涡流传感器系统组成：
bently3300 XL 8mm 探头
bently3300 延伸电缆
bently3300 前置器
bently3300 XL用于轴承机械的轴振动、轴位移、键相位和转速测量，符合美国石油学会（API）制定的670 标准。3300 XL前置器抗无线电干扰能力强，即使安装在玻璃纤维防护罩中，也不会受到附近无线电信号的干扰。
接收非接触式bently3300 XL系列5mm、8mm电涡流探头和延伸电缆的信号。频率响应为0-10kHz，使用三芯现场联线屏蔽电缆，从3300 XL 前置器到监测器的最大长度为305米。电源-17.5Vdc 至-26Vdc，电流最大为12mA，线性范围为2mm，灵敏度为为7.87V/mm (200mV/mil)±5％ ，前置器重量246g，前置器330180-50-00温度范围使用温度-35°C至 +85°C 。
3300 XL 前置器330180-AXX-BXX ， 总长度分别为1m,5m和9m系统，5 米探头只能与5米的前置器配合使用。安装选项为导轨安装和面板安装， 批准机构选项为不要求和危险地区批准。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66f151dc8e9e87b1efa809ccb270fdcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdb45e8531bf969fe959a600fad07224/" rel="bookmark">
			KJ2201X1-BA1 12P3162C092 SLS1508 VS3202逻辑运算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SLS1508 VS3202 KJ2201X1-BA1 12P3162X162 TSI系统超速卡件机械状态监测系统配件 3500监测系统 振动位移模块 3500/42M机械状态监测系统配件 3500监测系统 通讯卡 3500/92振动传感器PR9268/301-000\EPRO通迅卡TCM一4351B电路板SDCS-PIN-4 3ADT314100R1001直调电路板 (ABB) SDCS-PIN-51 3BSE004940R0001胀差板件A6210TSI电源卡BENTLY NEVADA3500/15 AC POWER SUPPLYPLC电源模板 IC200PWR102,GEPLC数字量输入输出模块 IC200MDD840G
EMERSON
1C31223G01
EMERSON
vS3202 SLS1508
Emerson
SE4006P2
EMERSON
VE4006P2
EMERSON
A6500-UM
EMERSON
9199-00002 A6120
EMERSON
1B30023H01 REV6
EMERSON
1B30023H02 REV6
EMERSON
MMS3125/022-020
EMERSON
MVME6100
EMERSON
SE3008 KJ2005X1-MQ213PO072x082
Emerson
VE4001S2T2B4
Emerson
VE4002S1T2B5
EMERSON
KJ4001×1-CA1
EMERSON
1C31169G02
EMERSON
CON041
EMERSON
PR6423/008-110+CON041
EMERSON
PR6423/0OR-010+CON031
EMERSON
KJ2003X1-BB1
EMERSON
A6824 9199-00090
EMERSON
A6410 9199-00005
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdb45e8531bf969fe959a600fad07224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22d5fa8aadd9b157f222456c1f903ec1/" rel="bookmark">
			TCP/IP协议详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/互联网协议）是互联网的基本协议，也是国际互联网络的基础。
TCP/IP 不是指一个协议，也不是 TCP 和 IP 这两个协议的合称，而是一个协议族，包括多个网络协议，比如 IP、ICMP（Internet Control Message Protocol，互联网控制报文协议）、TCP、HTTP（Hyper Text Transfer Protocol，超文本传输协议）、FTP（File Transfer Protocol，文件传输协议）、POP3（Post Office Protocol version 3，邮局协议）等。
TCP/IP 定义了计算机操作系统如何连入互联网，以及数据传输的标准。
TCP/IP 是为了解决不同系统的计算机之间的传输通信而提出的一个标准，不同系统的计算机采用了同一种协议后，就能相互通信，从而能够建立网络连接，实现资源共享和网络通信。就像两个不同国家的人，用同一种语言就能相互交流了。
1. 协议介绍：
TCP/IP协议族包括许多协议，其中一些最重要的包括：
IP协议（Internet Protocol）： 它定义了互联网上的唯一标识符（IP地址），并负责数据包的路由和转发。
TCP协议（Transmission Control Protocol）： 提供可靠的、面向连接的数据传输。它确保数据以正确的顺序到达目标，并具有错误检测和重传机制。
UDP协议（User Datagram Protocol）： 提供无连接的、不可靠的数据传输。它用于一些实时应用程序，如音频和视频流。
ICMP协议（Internet Control Message Protocol）： 用于网络故障诊断和错误报告。
ARP协议（Address Resolution Protocol）： 用于将IP地址映射到物理MAC地址。
HTTP协议（Hypertext Transfer Protocol）： 用于在Web上传输超文本文档，是万维网的基础。
FTP协议（File Transfer Protocol）： 用于文件传输。
SMTP协议（Simple Mail Transfer Protocol）： 用于电子邮件的发送。
DNS协议（Domain Name System）： 用于将域名解析为IP地址。
2. 数据传输：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22d5fa8aadd9b157f222456c1f903ec1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0e71d5851e7d419d6780c7adbabd1c3/" rel="bookmark">
			QT QAxWidget控件 使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文详细的介绍了QAxWidget控件的各种操作，例如：新建界面、使用示例、显示网页、显示pdf、显示Off、源文件详细说明其它文章等等操作。
ActiveX控件是一种可重用的二进制组件，用于在Windows操作系统上提供特定的功能和服务。以下是一些常见的ActiveX控件的示例：1. Internet Explorer Web Browser Control：用于在应用程序中嵌入和显示Web浏览器。2. Microsoft Office组件（如Word、Excel、PowerPoint）：用于在应用程序中嵌入和操作Office文档。3. Windows Media Player Control：用于在应用程序中嵌入和播放音频和视频文件。4. Adobe Flash Player Control：用于在应用程序中嵌入和播放Flash动画和视频。5. Crystal Reports Viewer Control：用于在应用程序中显示和打印Crystal Reports报表6. Windows Common Controls（如TreeView、ListView、ProgressBar）：用于在应用程序中创建常见的用户界面控件。7. Microsoft DataGrid Control：用于在应用程序中显示和编辑数据表格。8. Microsoft Windows Image Acquisition Control：用于在应用程序中获取和处理图像。9. Microsoft Windows Media Encoder Control：用于在应用程序中进行音频和视频编码。
本系列QT全面详解文章目前共有三十八篇，本系列文章较为详细的讲述了QT控件的基础操作和使用，也谢谢大家的关注、点赞、收藏。
本文作者原创，转载请附上文章出处与本文链接。
QT QAxWidget控件 使用详解目录
1 新建界面
2 使用示例
3 显示网页
4 显示pdf
5 显示Off
6 源文件
7 详细说明
8 其它文章
1 新建界面 2 使用示例 // ui-&gt;axWidget-&gt;setControl("{8856F961-340A-11D0-A96B-00C04FD705A2}"); // ui-&gt;axWidget-&gt;dynamicCall("MethodName", "123", "hello"); // QVariant value = ui-&gt;axWidget-&gt;dynamicCall("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0e71d5851e7d419d6780c7adbabd1c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ea1cc74a7ca20f8e8efc6a6af3fbb80/" rel="bookmark">
			Latex之在作者名字后面加上OCRID的图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		\usepackage{orcidlink} \author{Bob\textsuperscript{\orcidlink{0000-0000-0000-0000}}} 效果如图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/267589bce0f64bc27cac331b8765ab5b/" rel="bookmark">
			基于微信小程序的在线学习平台设计与实现-计算机毕业设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收藏关注不迷路，源码文章末
文章目录 前言一、项目介绍二、开发环境三、功能介绍四、核心代码五、效果图六、文章目录 前言 首先,论文一开始便是清楚的论述了系统的研究内容。其次,剖析系统需求分析,弄明白“做什么”,分析包括业务分析和业务流程的分析以及用例分析,更进一步明确系统的需求。然后在明白了系统的需求基础上需要进一步地设计系统,主要包罗软件架构模式、整体功能模块、数据库设计。本项目软件架构选择B/S模式,总体功能模块运用自顶向下的分层思想。再然后就是实现系统并进行代码编写实现功能。论文的最后章节总结一下自己完成本论文和开发本项目的心得和总结。通过在线学习平台小程序将会使在课程视频管理各个方面的工作效率带来实质性的提升。
一、项目介绍 困扰管理层的许多问题当中,在线学习也是不敢忽视的一块。但是管理好在线学习又面临很多麻烦需要解决,例如：如何在工作琐碎,记录繁多的情况下将在线学习的当前情况反应给课程问题管理员决策,等等。在此情况下开发一款在线学习平台小程序，于是乎变得非常合乎时宜。
经过网上调查和搜集数据,我们可以发现在线学习方面的小程序在并不是相当普及,同时在课程视频管理方面的可以有许多改进。实际上如今信息化成为一个未来的趋势或者可以说在当前现代化的城市典范中,信息化已经成为主流,开发一个在线学习平台小程序一方面的可能会更合乎时宜,另一方面来说也可以提高在在线学习方面的效率给相关管理人员的工作带来一定的便利。
二、开发环境 开发语言：Java
框架：springboot
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql 5.7（一定要5.7版本）
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.3.9
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
————————————————
三、功能介绍 小程序整体功能如下图所示：
图 4-1 整体功能模块图
概念模型是对现实中的问题出现的事物的进行描述，ER图是由实体及其关系构成的图，通过E-R图可以清楚地描述系统涉及到的实体之间的相互关系。
用户信息实体图如图4-2所示：
我的实体图如图4-3所示：
图4-3我的实体图
四、核心代码 部分代码：
package com.fc.v2.controller; import com.fc.v2.common.base.BaseController; import io.swagger.annotations.Api; import io.swagger.annotations.ApiOperation; import org.springframework.stereotype.Controller; import org.springframework.ui.ModelMap; import org.springframework.web.bind.annotation.GetMapping; /** * 如果有前台这儿写前台访问方法 * @ClassName: IndexController * @author fuce * @date 2019-10-21 00:15 */ @Api(tags = "首页模块") @Controller public class IndexController extends BaseController{ /** * 前台访问 域名:端口 例如:localhost:80的get请求 * @param map * @return * @author fuce * @Date 2019年11月20日 下午10:55:13 */ @ApiOperation(value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/267589bce0f64bc27cac331b8765ab5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a4e50e18e87c114857f4c1e9ece91c1/" rel="bookmark">
			win11登录界面死循环怎么办 卡在登录微软账户进不了桌面怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有新装windows11系统的用户发现自己卡死在了微软账号的登录界面。之后无法输入任何内容，点击鼠标和键盘也没有任何反应，重新开机还是死循环进入该界面。那么win11卡在登录微软账户进不了桌面该怎么解决呢？今天小编就给大家带来了详细的图文教程，有需要的用户们赶紧来看一下吧。
win11登录界面死循环怎么办 方法一、
1、首先我们可以尝试使用电源键重启电脑，看看能不能通过重启的方式进行解决。
2、如果无法解决的话，连续重启电脑3次以上会进入高级修复选项，然后选择“疑难解答”。
3、进入疑难解答后，再选择其中的“高级选项”。
4、接着在高级选项中选择“卸载更新”就可以了。
方法二、
1、首先重启电脑并按住键盘上的“Shift”键。
2、之后依次选择新界面中的‘查看高级修复选项’----‘疑难解答’----‘高级选项’----‘启动设置’。
3、随后点击右下角的‘重启’选项，在重启出来的安全界面中按下“F4”即可进入安全模式。
4、进入安全模式之后按下快捷键“WIN+R”在对话框中输入cmd。
5、输入netsh winsock reset回车，完成操作后重启电脑即可全部搞定了。
以上就是win11登录界面死循环的解决方法介绍了，希望对各位用户们有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe1cc12d1cfbc7c35850bd1f527e7a5e/" rel="bookmark">
			LVGL(72)-v8--滑块slider
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、slider 简介 1.1 概述 Overview Slider对象看起来像一个带有旋钮的工具条。可以拖动该旋钮来设置一个值。滑块也可以是垂直的或水平的。滑动条在前面我们介绍img控件的时候有个历程有使用到，哪里我们讲述设置样式实现对滑动条的一些样式的设置。
1.2 部分和风格 Parts and Styles LV_PART_MAIN 滑块的背景，它使用了所有典型的背景样式属性。填充使指示符在相应的方向上变小。 LV_PART_INDICATOR 指示器显示滑块的当前状态。还使用了所有典型的背景样式属性。LV_PART_KNOB 按当前值绘制的矩形(或圆)。它还使用所有典型的背景属性来描述旋钮。默认情况下，旋钮为方形(可选半径)，边长等于滑块的较小边。旋钮可以用填充值做得更大。填充值也可以是非对称的。 1.3 使用 Usage 1.3.1 值和范围 Value and range 设置初始值。动画时间由样式的anim_time属性设置。
/** * Set a new value on the slider * @param obj pointer to a slider object * @param value the new value * @param anim LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately */ static inline void lv_slider_set_value(lv_obj_t * obj, int32_t value, lv_anim_enable_t anim) 指定滑块的范围(最小值，最大值)的函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe1cc12d1cfbc7c35850bd1f527e7a5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4713ec36c9f2adb1dfd41fa173bd29ed/" rel="bookmark">
			安装最新版React devtool
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.按照官方文档执行 我这里只想在项目里安装，因此执行的
npm install react-devtools@^4
2.安装完成后，在 package.json里加入启动命令 "script": { "dev": "react-devtools" } 执行npm run dev会弹出一个窗口
如果是全局安装的，则直接执行react-devtools
3.把&lt;script src="http://localhost:8097"&gt;&lt;/script&gt; copy 到项目的index.html中保存，窗口连接项目成功展示调试界面 遇到的问题 在安装react-devtools时，npm报错
可以看到是我的node版本不支持，换成他支持的node版本就OK了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5da79a98963d215543968f0929b50520/" rel="bookmark">
			http状态码简介分类及常见状态码含义详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：http状态码是什么意思
HTTP状态码（英语：HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到 RFC 2518、RFC 2817、RFC 2295、RFC 2774 与 RFC 4918 等规范扩展。所有状态码的第一个数字代表了响应的五种状态之一。所示的消息短语是典型的，但是可以提供任何可读取的替代方案。 除非另有说明，状态码是HTTP / 1.1标准（RFC 7231）的一部分。
二：http状态码有什么用
http状态码的核心作用是Web Server服务器用来告诉客户端，当前的网页请求发生了什么事，或者说当前Web服务器的响应状态。所以HTTP状态码常用来判断和分析当前Web服务器的运行状况。
常用的http状态码：
200 - 服务器成功返回网页
404 - 请求的网页不存在
503 - 服务不可用
三：http状态码在哪里查看
1.浏览器的F12调试（或者右键检查），network查看Status，status就是http返回的状态码。
2.可以使用在线工具，输入网址即可查询HTTP状态，例如站长之家：https://tool.chinaz.com/pagestatus?url=blog.361s.cn
四：HTTP 状态码分类
HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)
2xx
代表请求已成功被服务器接收、理解、并接受，常见的有：
200 OK（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回
201（已创建）：请求成功并且服务器创建了新的资源
202（已创建）：服务器已经接收请求，但尚未处理
203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源
204 No Content（无内容）：服务器成功处理请求，但没有返回任何内容
205（重置内容）：服务器成功处理请求，但没有返回任何内容
206 Patial Content（部分内容）：服务器成功处理了部分请求
3xx
表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向，常见的有：
300（多种选择）：针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择
301 Moved Permanently（永久移动）：请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置
302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5da79a98963d215543968f0929b50520/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/280bbdf8ed706625fe12c3c778db7f8a/" rel="bookmark">
			mysql数据库的全量与增量的备份以及恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、全量备份与恢复
1.全量备份
2.删掉某个数据库
3.全量恢复数据库
二、增量备份与恢复
1.查看增量是否开启，我们发现log_bin开启证明开启了
2.创建一个数据库并创建表中信息
3.插入数据
4.进行一次全量的备份
5.做完备份刷新一下数据库，重新进行写入数据
6.在数据库中增加一条新的数据，删除原来的一条数据
7.删掉其中一个数据库
三、全量、增量的数据库恢复
1.先刷新一下数据库
2.查看数据库之前的所有的数据
3.查看当前使用的数据库
4.查看之前数据的操作，确定在哪里被删除的，我们发现在926时候删除的
5.先进行一个全量恢复
6.查看数据库信息
7.我们看mydb数据发现虽然是进行了全量恢复，但是我们没恢复删除前的数据。
8.将删除数据前的数据记录设置为增量数据
9.进行增量恢复的操作
10.查看数据是否恢复
一、全量备份与恢复 1.全量备份 mysqldump -uroot -proot --databases -default-character-set=utf8mb4 &gt; backup.sql
2.删掉某个数据库 drop database sys;
3.全量恢复数据库 mysql -uroot -proot &lt; backup.sql;
二、增量备份与恢复 1.查看增量是否开启，我们发现log_bin开启证明开启了 show varibles like '%bin%';
2.创建一个数据库并创建表中信息 create table stu_info(
stu_nu int primary key auto_increment,
stu_name varchar(30) not null
) auto_increment=1001;
3.插入数据 insert into stu_info values(null,'张三'),(null,'李四'),(null,'王五');
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/280bbdf8ed706625fe12c3c778db7f8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a09897a9359c7eacf53362b6ce9f2b0/" rel="bookmark">
			【C&#43;&#43;】Visual Studio warning C4819: 该文件包含不能在当前代码页(936)中表示的字符 &amp;&amp; “常量中有换行符”的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一个CMakeLists项目中遇见了这个BUG。代码都是没有问题的。
原因是代码文件的字符编码格式的UTF8无签名的。
打开“文件”菜单下的“高级保存选项”，设置编码 Unicode（utf-8带签名）- 代码页 65001 可以解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fecffc39d720320b2c1173d325d68a9d/" rel="bookmark">
			SpringBoot 集成 SpringSecurity 从入门到深入理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整的目录 介绍 SpringSecurity简述 SpringSecuritySpringSecurity 的主要功能说明 项目源码入门案例项目工程路径第一步：加载依赖第二步：创建核心的配置类第三步：增加controller第三步：启动程序小结界面跳转说明密码生成说明 重点内容扫盲重要的FilterPasswordEncoder 接口UserDetailsService 接口 深入学习案例基础验证案列第一步：加载依赖第二步：初始化 SQL第三步: 添加配置第四步：添加实体类以及对应的 Mapper第五步：增加 controller 进行访问验证第六步：添加自定义的验证逻辑 验证验证一：异常访问验证二：正常登录验证三：异常登录 基于角色的访问控制项目结构添加菜单和角色实体类以及Mapper 文件调整 MyUserDetailsService 实现添加访问接口修改 Security 配置hasRole 的源码相关说明 验证验证一：使用普通用户登录验证验证二：使用管理员账户登录验证 自定义界面访问添加登录界面修改 Security 的配置 验证登录页面验证 自定义错误页面添加错误页面修改 Security 的配置 验证无访问权限验证 自定义主页添加主页修改 Security 的配置 验证验证跳转主页 remember-me 功能介绍修改 Security 配置修改Login页面创建表结构 验证验证 remember-me 功能 原理分析注解使用@Secured注解@PreAuthorize@PostAuthorize 总结 介绍 SpringSecurity 简述 SpringSecurity Spring Security 是 Spring 应用程序的安全框架，它提供了认证、授权、访问控制等安全性功能。在 Spring Boot 应用程序中使用 Spring Security，可以方便地进行安全性配置。
Spring Security最初是一个独立的项目，名为Acegi Security，于2004年首次发布。Acegi Security是针对Spring框架的安全框架，旨在为Java企业应用程序提供基于认证和授权的安全功能。
2010年，Spring Security成为Spring项目的一部分，并开始在Spring框架的生态系统中广泛应用。随着时间的推移，Spring Security逐渐成为Java企业应用程序中最受欢迎的安全框架之一，用于保护Web应用程序、REST API和基于Spring的微服务架构。
在最新版本的Spring Security 5中，该框架已经得到了大量改进和更新，以支持最新的安全标准和技术，如OAuth 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fecffc39d720320b2c1173d325d68a9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/974d0972730c6ffc2b774ff5e33b7937/" rel="bookmark">
			python module - try&amp;except
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 try 和 except 是 Python 中用于处理异常的关键字。异常是在程序执行期间可能出现的错误或异常情况。通过使用 try 和 except，你可以编写代码来捕获和处理这些异常，以避免程序崩溃。
try: # 你的代码，可能会引发异常 result = 10 / 0 # 这里故意引发一个除零异常 except ZeroDivisionError: # 处理特定类型的异常 print("除零异常发生") except Exception as e: # 处理其他类型的异常 print(f"发生了异常：{e}") else: # 如果没有异常发生，执行这里的代码 print("没有异常发生") finally: # 无论是否发生异常，都会执行这里的代码 print("无论如何都会执行的代码") 使用 ZeroDivisionError 捕获了一个特定的异常（除零异常）。如果发生这种异常，程序会执行第一个 except 块中的代码。如果发生其他类型的异常，程序会执行第二个 except 块中的代码。如果没有异常发生，程序会执行 else 块中的代码。无论是否发生异常，finally 块中的代码都会被执行。
注：Python内置了许多异常类型，
ZeroDivisionError：除以零的错误。ValueError：值错误，通常发生在尝试将无效值传递给函数或操作时。TypeError：类型错误，通常发生在操作不兼容的数据类型时。FileNotFoundError：文件未找到错误，通常发生在尝试打开不存在的文件时。MemoryError：内存错误，通常表示程序耗尽了可用的内存资源。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d81485cf82441ef8d878cbe942f92038/" rel="bookmark">
			【Nuxt系列文章】一文读懂Nuxt3的网络请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是刘明，十年创业老兵，开源技术爱好者。
有童鞋问我，Nuxt3如何整合Axios?我的答案是，不要在Nuxt3里整合Axios.
虽说Axios很好用，并且多数同学都已经很熟悉Axios的使用。但是Nuxt3官方团队已经不建议使用Axios。本文将向各位童鞋介绍：
为何官方不推荐Axios如何在Nuxt3中封装类似Axios一样的功能。 Axios的前世今生 Axios的诞生 在早期，浏览器中发起网络请求需要用到XMLHttpRequest 对象,在node后端环境中发起网络请求需要用到http模块。两者写法不一样，用起来也比较复杂。于是Axios对两者做个一个封装，统一了前后端的写法。
对于开发者而言，只要用上了Axios，就不需要再区分是node还是浏览器环境，反正二者写法上都是一样的。不仅如此，Axios还有请求拦截和响应拦截等高级功能。所以，Axios很快就流行起来。Nuxt2也有整合好的Axios模块，并且官方也曾大力推荐。
Axios的落伍 到了Nuxt3,时代变了。
首先是浏览器环境。浏览器原生支持fetch,并且有代替XMLHttpRequest的趋势。
紧接着是Node.2022年2月，Node v17.5发布，引入了对fetch的原生支持。
至此，fetch在前后端大统一了。
回头再看，Axios前端封装XMLHttpRequest后端封装http的做法就完全没有必要了。
如何看待Axios 虽然fetch在前后端大统一，但是还有很多童鞋喜欢使用Axios.这是正常的，毕竟Axios确实很好用，而且很多老项目仍然需要维护。
以至于，我在网上看到一些文章，拿Axios和Fetch进行对比的时候，得出的结论是Axios比fetch好。其实这是一个非常错误的对比。Axios是一个封装好的项目，fetch只是一个原生API.如果非要对比的话，应该拿XMLHttpRequest对象和fetch比或者http模块与fetch比。
随着时间推移，越来越多的新项目会推荐使用fetch.Nuxt3是2022年诞生的新项目，完全放弃使用Axios。
Nuxt3的官方做法 拿Axios和Fetch进行对比并得出结论说Axios更好用，虽然是一个错误的对比。但至少说明一点，fetch要想真正获得认可，应该有一个非常好用的封装。Nuxt3的官方团队考虑到了这一点，将fetch进一步封装，开发了一个新项目叫做ofetch，并且将ofetch集成到Nuxt3中。Nuxt3中有个随处可用的全局对象$fetch,就是ofetch.
我看过ofetch的全部代码，与Axios相比代码量少，Axios有的功能ofetch也基本都有。官方在Nuxt3中默认集成了ofetch,ofetch已经是Nuxt3项目不可缺少的一部分。所以他们自然不再推荐Axios.
如何在Nuxt3中封装出类似Axios一样的功能 在Nuxt3官方文档DataFeching部分，介绍了useFech和$fetch的简单用法，如果是刚刚上手Nuxt3的童鞋，强烈建议仔细阅读此部分。
但是很多项目还需要设置baseURL,还需要请求拦截和相应拦截。这些功能在官方文档中都没有给出代码案例。
实现起来很简单，只需要再写一个useRequest的组合函数即可。在Nuxt3中，组合函数是自动导入的，所以写出来就可以用了。
//文件位置：/composables/useRequest.ts type Response = { url: string; body:any, status: number; type:string, statusText?: string; _data?: any; headers?:object, ok?:boolean, redirected?:boolean, bodyUsed?:boolean, }; type ResponseData={ code:number, msg:string, data:object|object[] } export const useRequest = async (url: string,options:object) =&gt; { const router = useRouter(); //此处是引入了pinia进行状态管理，大家可以根据自己需求进行重写 //const store = useMainStore(); const host = window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d81485cf82441ef8d878cbe942f92038/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f99f78a4ad08a522240d4fe03a0ea766/" rel="bookmark">
			[KeyarchOS]Chkrootkit后门检测工具的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 概述
2 安装环境
2.1 操作系统环境
2.2 Chkrootkit版本
3 安装Chkrootkit
3.1 准备gcc编译环境
3.2 编译安装Chkrootkit
3.3 检测当前版本
4 Chkrootkit基本使用
4.1 运行Chkrootkit
4.2 执行静默扫描
4.3 运行Chkrootkit并保存结果到文件
4.4 以详细模式运行Chkrootkit
4.5 显示可能被感染的项目
4.6 检查系统命令是否受感染
4.7 检查网络接口
1 概述 chkrootkit 是一种开源工具，旨在帮助检测 Linux 系统中是否存在 rootkit 和恶意软件。rootkit 是一种用于隐藏恶意活动的恶意软件，它能够有效地掩盖自身和其他恶意行为，使攻击者可以在受感染的系统上保持持久的访问权限。它通过搜索常见的 rootkit 文件和代码，包括 Linux 内核模块 (LKM) 和用户空间 rootkit，来识别潜在的威胁。当 chkrootkit 扫描完成后，它会生成一个报告，列出任何被发现的可疑文件、隐藏进程和异常端口等。报告提供了识别码、文件路径和详细描述，帮助用户评估系统的安全情况。总之，chkrootkit 是一款可以帮助检测 Linux 系统中 rootkit 和恶意软件的开源工具，它简单易用，可以提供对系统安全性的初步评估。
浪潮信息KOS是浪潮信息基于Linux Kernel、OpenAnolis等开源技术自主研发的一款服务器操作系统，支持x86、ARM等主流架构处理器，性能和稳定性居于行业领先地位，具备成熟的 CentOS 迁移和替换能力，可满足云计算、大数据、分布式存储、人工智能、边缘计算等应用场景需求。详细介绍见官网链接浪潮信息KOS服务器操作系统-服务器操作系统-浪潮信息。
2 安装环境 2.1 操作系统环境 版本信息：KeyarchOS 5.8。
硬件平台：X86_64。
2.2 Chkrootkit版本 chkrootkit version 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f99f78a4ad08a522240d4fe03a0ea766/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/786095ee75f8b4fb1e95010249f1ead7/" rel="bookmark">
			C&#43;&#43;：多态 ( 语法 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多态目录 🍁多态简介🍁构成多态的条件🍂虚函数🍂虚函数重写🍂构成虚函数重写的两个特例🍃派生类中的虚函数的virtual关键字可以省略🔥多态的一道例题 🍃协变（运用场景不多） 🍂关键字 final 和 override🍃final🍃override 🍂重载、重定义(隐藏) 和 重写(覆盖) 🍁抽象类🍂纯虚函数🍂接口继承 和 实现继承 🍁多态简介 多态是C++面向对象三大特性之一，那么多态二字又该如何去理解呢？
在现实生活中，针对同一行为不同对象所体现的事件的不同形态称为多态。
例如：
不同国家的人吃饭的所用的餐具不一样，在我国吃饭用的是筷子；美国等其他欧洲国家吃饭用餐叉；印度更是直接用手抓。去公园买票，普通人买票时需要全票价购买；学生买票时可以半票价购买；针对退伍军人可以优先购票等等。商品售卖，新用户可以享受到九折优惠；老用户可以享受到八折优惠。 🍁构成多态的条件 多态是在继承的基础上实现的，当然C++构成多态还需要满足以下条件：
必须通过基类的指针或是引用去调用虚函数被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写 以上提到构成多态的条件缺一不可，否则构不成多态。
🍂虚函数 在类中被virtual关键字修饰的函数称为虚函数
class Person { public:	virtual void BuyTicket() //被virtual关键字修饰的函数为虚函数 { cout &lt;&lt; "普通人买票-&gt;全票价" &lt;&lt; endl; } }; 🍂虚函数重写 派生继承基类的时候，会将基类的成员和成员函数继承到派生类中，当成派生类中一部分；
在这里先捋清楚两个概念：继承中的重定义 和 多态中虚函数的重写
重定义：承体系中基类和派生类都有独立的作用域。派生类和基类中有同名成员，派生类成员将屏蔽基类对同名成员的直接访问，这种情况叫隐藏，也叫重定义虚函数重写：派生类中有一个跟基类完全相同的虚函数(即派生类虚函数与基类虚函数的返回值类型、函数名字、参数列表完全相同)，称派生类的虚函数重写了基类的虚函数 针对继承中的重定义来说，只要基类和派生类的成员名字相同即构成重定义；
虚函数构成重写的条件较为严格，不仅仅只是虚函数的函数名字相同还包括：虚函数返回值、参数列表等等。
在这里切记不要将重定义与虚函数重写两者概念搞混了。
下面举个构成虚函数重写的示例：
class Person { public:	virtual void BuyTicket() //基类的虚函数 { cout &lt;&lt; "普通人购票-&gt;全票价" &lt;&lt; endl; } }; class Student : public Person { public:	virtual void BuyTicket() //子类的虚函数与基类的虚函数：名字、函数返回值、参数相同；构成虚函数重写 { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/786095ee75f8b4fb1e95010249f1ead7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6b4081788b190996f5a4d8265a311c6/" rel="bookmark">
			Oracle 19c RAC安装时遇到 INS-06006 错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.错误现象 通过执行 gridSetup.sh 配置 19c grid infrastructure 的时候，在 SSH connectivity 步骤，发生如下错误：
[INS-06006] Passwordless SSH connectivity not set up between the following node(s): [&lt;racnode2&gt;] 以上错误是无法被忽略的，因此 CRS 会安装失败。
但 SSH 的配置是成功的，并且 ssh &lt;node_name&gt; date 命令可以在任意节点正确执行，CVU user equivalence 检查也是通过的。
2.错误原因 Linux 下 OpenSSH 版本被升级到 8.x。
注意：OpenSSH 在不同的 OS 平台，可能会有不同的行为，例如在 AIX 平台，OpenSSH 7.5 有这个问题，在 SLES Linux 12 SP4上，OpenSSH_7.2p2 有这个问题。
查看 OpenSSH 版本：
# ssh -V OpenSSH_8.0p1, OpenSSL 1.0.2r 26 Feb 2019 如下的命令在 OpenSSH 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6b4081788b190996f5a4d8265a311c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad165f8898e8e00d1c854aa8b47605c3/" rel="bookmark">
			centos7搭建DNS服务(use)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：centos7搭建DNS服务完整版
CentOS 7 配置DNS服务
Centos7 DNS 服务器配置步骤 --use
一、DNS服务类型 主机记录记录类型记录值ns1A192.168.1.1ns2A192.168.1.2wwwA192.168.1.100bbsCNAMEwwwftpA192.168.1.110mailMX 10192.168.1.120 1.1 服务配置说明： // 正向解析文件 [root@localhost ~]# vim /var/named/ssx.com.hosts $TTL 1D @ IN SOA @ root.ssx.com. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum @ NS dns.ssx.com. @ IN A 10.11.0.133 // 该配置允许访问 ssx.com, 注: 使用时，本注释要删除 dns IN A 10.11.0.133 www IN A 10.11.0.133 smb IN A 10.11.0.133 ftp IN A 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad165f8898e8e00d1c854aa8b47605c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2406f2964c19b34984e3a88562622f9e/" rel="bookmark">
			安装CUDA与CUDNN与Pytorch（最新超级详细图文版本2023年8月最新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装CUDA 1.1、下载安装包 cuda可以认为就是Nvidia为了显卡炼丹搞的一个软件，其下载地址为：CUDA Toolkit 12.2 Update 1 Downloads | NVIDIA Developer
当你点进这个链接的时候，你需要依次选择
1是选择系统，这里选windows
2是选择平台，32位还是64位，其实只支持64位
3是选择系统版本，这里我们选择win10，如果是其他的系统就选择其他的
4是选择本地下载，也就是一次全部下载完然后安装，还是网络下载，即下载一个安装工具，边下载边安装
5是下载，可以看到安装包有3GB
需要注意： 这里我们直接选择了最新版的CUDA，如果你需要别的版本，直接点击这个链接 CUDA Toolkit Archive | NVIDIA Developer
这里面有你需要的版本。
1.2、安装 双击下载好的文件
后面就一路确定就好了，默认的安装位置在
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.2
所以我们需要添加两个系统变量，实际上在安装的时候已经默认添加了，为了防止没有添加成功，这里我们可以看一下
点击属性
主要看有没有这两条，没有的话就新建添加一下。
二、CUDNN安装 2.1、CUDNN下载 下载地址：cuDNN Download | NVIDIA Developer
你要同意他的政策，也就是点击前面的小方块
然后就会出现两个下载选项，我们选择第一个，因为第一个CUDNN对应的CUDA版本是12，我们安装的CUDA版本是12。
如果你需要下载历史版本，点击这个链接 cuDNN Archive | NVIDIA Developer
需要注意： 也许你进这个网站需要登录，这是正常的，我因为之前登录过了，所以没有遇到，需要登录的话就注册个账号然后登录就好了。
2.2、安装 下载好了是一个压缩包，我们解压到当前为止可以得到三个文件夹
把这三个文件夹复制到我们之前的那个CUDA目录下，C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.2，这个目录下也有三个同名文件，把文件复制过来就可以了。
复制完成后，需要添加环境变量，这次我们添加到PATH中，
2.3、验证 怎么知道我们安装的CUDA和CUDNN是正确的呢，需要验证一下，打开CMD，输入命令
nvcc -V 有这些版本号之类的东西基本上验证安装成功了，打开这个地址可以进一步验证
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2406f2964c19b34984e3a88562622f9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c101afd82135c4649656f363e72c9ccf/" rel="bookmark">
			windows下wget: command not found(wget下载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载所需的.exe文件：
下载地址：
https://eternallybored.org/misc/wget/ 根据自己的操作系统版本进行选择
2.将.exe文件放到
C:\Windows\System32 下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/163ac7ef1af98454b7a8ef90a4af65b3/" rel="bookmark">
			@FeignClient使用过程中注意的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：当你需要引入一个第三方包时，三方包中使用的是Spring Cloud OpenFeign下的FeignClient和EnableFeignClients，自己本地使用的是Spring Cloud Netflix Feign下的FeignClient和EnableFeignClients，这时候启动程序，无法扫描到第三方中的被@FeignClient修饰的接口。
原因：使用的是不同包下的Feignclient.
解决方法：在本地新建一个接口，继承第三方中的接口。使用时，使用本地接口注入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3d387e0bf34d0b513a39aef0340a732/" rel="bookmark">
			GStreamer 命令行工具播放音频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 GStreamer是一个非常强大的多媒体处理框架，它提供了许多命令和插件来处理音频、视频和其他类型的媒体数据。以下是一些常用的GStreamer命令和插件：
gst-launch-1.0：用于启动GStreamer管道的命令。你可以使用该命令来创建GStreamer管道，并指定各种插件和媒体源。
filesrc：用于指定要播放的媒体文件的插件。你可以使用该插件来指定媒体文件的路径和名称。
decodebin：用于解码音频和视频数据的插件。该插件会自动检测媒体文件的编码格式，并使用适当的编解码器进行解码。
autoaudiosink：用于输出音频数据的插件。该插件会自动检测可用的音频输出设备，并将音频数据输出到默认的音频设备。
autovideosink：用于输出视频数据的插件。该插件会自动检测可用的视频输出设备，并将视频数据输出到默认的视频设备。
playbin：用于播放音频和视频媒体的插件。你可以使用该插件来播放本地或网络媒体文件，并自动处理解码、显示和播放等任务。
multifilesrc：用于从多个文件中读取音频和视频数据的插件。该插件可以同时读取多个媒体文件，并将它们合并到一个管道中进行播放。
queue：用于管理媒体数据的插件。该插件可以排队媒体数据，以便在管道中平滑地播放媒体文件。
videoconvert：用于转换视频格式的插件。该插件可以将输入的视频格式转换为输出的视频格式，以便在不同的应用程序中使用。
在Linux上，你可以使用GST（GStreamer）命令行工具来播放MP3文件。以下是在终端中播放MP3文件的步骤：
1.使用以下命令安装GStreamer插件包, 这将安装GStreamer的核心插件以及用于播放、编码和解码音频和视频的插件。
sudo apt-get install gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly 2.播放MP3文件：(将 /path/to/your/mp3/file 替换为你要播放的MP3文件的实际路径)
gst-launch-1.0 filesrc location=/path/to/your/mp3/file ! decodebin ! autoaudiosink 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffc551a68469609beb7abb28656390d4/" rel="bookmark">
			《JavaCV图像处理合集》内容介绍和专栏目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专栏介绍 《JavaCV图像处理合集》专栏包含了所有JavaCV教程的合辑版本专栏。 一次订阅，掌握所有JavaCV教程。 根据专栏文章顺序，从入门实战到进阶，循序渐进，快速上手并精通javacv所有图像处理和图像识别开发技术。
《JavaCV图像处理合集》专栏完整包含以下四个专栏所有内容和扩展补充知识：
《JavaCV入门教程》《JavaCV实战教程》《JavaCV进阶opencv图像处理》《JavaCV进阶tesserac字符识别》 《JavaCV图像处理合集》相比全部单独订阅JavaCV专栏价格更优惠。
专栏内容概述 JavaCV入门教程 《JavaCV入门教程》详细介绍了音视频流媒体、图像处理识别等技术的前置知识，JavaCV的基础结构明细以及JavaCV各个结构的说明和用法。通过配合JavaCV实战教程中的实例带领大家全面理解JavaCV。
JavaCV实战教程 《JavaCV实战教程》相比于《JavaCV入门教程》的理论知识讲解，更注重以翔实的实际案例，带领大家一步一步领略JavaCV强大的设备音视频采集（摄像头、麦克风、桌面屏幕）、音视频处理、拉流/推流、视频录制、hls切片、mp4切片、截图、icon图标制作、编解码、视频滤镜特效、GPU硬件加速等实战技术使用。
不仅如此，使用JavaCV可以快速通过sdk接入网络摄像头视频（海康、大华等宇视摄像机）并推流到我们指定的流媒体服务或者，或者也可以利用JavaCV实现自己的流媒体服务（例如：EasyMedia）实现websocket-flv,http-flv,hls等协议的实时视频/录像回放视频转发。
除此以外，利用JavaCV视频滤镜也可以快速实现各种字符叠加，图片叠加，画中画、多视频合流等特效。
JavaCV涉及非常丰富的实战案例内容，更多内容不详细介绍，敬请查看 《JavaCV实战教程》，领略全面的流媒体音视频开发技术。
JavaCV进阶opencv图像处理 《JavaCV进阶opencv图像处理》专栏提供了JavaCV方式调用opencv底层库的方法。
主要讲解了基于opencv技术的javacv图像处理、人脸检测、人脸训练、人脸识别、二维码检测、识别等实际案例，带领大家快速上手javaCV图像处理/识别技术。
注意：因为opencv本身也提供java的api，所以要注意它跟javacv的api是不相通的。如果使用javacv中的其他类库，则必须配合使用JavaCV方式的opencv。
JavaCV进阶tesserac字符识别 《JavaCV进阶tesserac字符识别》详细讲解了JavaCV使用google的tesserac实现检测摄像头或者视频中字符并实现字符识别。
以上就是《JavaCV图像处理合集》专栏的全部内容介绍。
如果对JavaCV技术感兴趣，想要咨询专栏相关内容或者探讨JavaCV开发技术，欢迎一起加入我们的JavaCV流媒体社区群（点击即可加入）。
下面是《JavaCV图像处理合集》专栏目录。
目录 JavaCV入门教程 JavaCV入门指南：序章（看完本章后，不想看原理的小伙伴可直接跳转到《快速上手篇》）
JavaCV入门指南：调用FFmpeg原生API和JavaCV是如何封装了FFmpeg的音视频操作
JavaCV入门指南：调用opencv原生API和JavaCV是如何封装了opencv的图像处理操作
JavaCV入门指南：帧抓取器(FrameGrabber)的原理与应用
JavaCV入门指南：帧录制器/推流器(FrameRecorder)的原理与应用
JavaCV入门指南：帧过滤器(FrameFilter)的原理与应用
JavaCV入门指南：FrameConverter转换工具类及CanvasFrame图像预览工具类（完结篇）
《快速上手篇》（为了区别，单独划分）：
JavaCV入门指南之快速上手篇：快速上手视频拉流、推流、录制文件、录屏、截图和编解码复用解复用等常用音视频处理操作
javaCV实战教程 javacv开发详解之1：调用本机摄像头视频
javaCV开发详解之2：推流器实现，推本地摄像头视频到流媒体服务器以及摄像头录制视频功能实现(基于javaCV-FFMPEG、javaCV-openCV)
javaCV开发详解之3：收流器实现，录制流媒体服务器的rtsp/rtmp视频文件(基于javaCV-FFMPEG)
javaCV开发详解之4：转流器实现（也可作为本地收流器、推流器，新增添加图片及文字水印，视频图像帧保存），实现rtsp/rtmp/本地文件转发到rtmp流媒体服务器(基于javaCV-FFMPEG)
javaCV开发详解之5：录制音频(录制麦克风)到本地文件/流媒体服务器(基于javax.sound、javaCV-FFMPEG)
javaCV开发详解之6：本地音频(话筒设备)和视频(摄像头)抓取、混合并推送(录制)到服务器(本地)
javaCV开发详解之7：让音频转换更加简单，实现通用音频编码格式转换、重采样等音频参数的转换功能（以pcm16le编码的wav转mp3为例）
javaCV开发详解之8：转封装在rtsp转rtmp流中的应用（无须转码，更低的资源消耗，更好的性能，更低延迟）
javaCV开发详解之9：windows下通过vfwcap抓取摄像头画面以及几种摄像头和屏幕画面采集实现截屏录屏比较
java原生实现屏幕设备遍历和屏幕采集（捕获）功能
javaCV开发详解之10：基于dshow调用windows摄像头视频和音频，想要获取屏幕画面首选gdigrab
javaCV开发详解之11：视频文件转gif动态图片实现，也支持摄像机、桌面屏幕、流媒体等视频源转gif
javacv开发详解之11补充篇：使用批量多张图片制作gif动态图
javaCV开发详解之12：视频转apng动态图片实现，支持透明通道，支持摄像机、桌面屏幕、流媒体等视频源转apng动态图
javaCV开发详解之13：使用FFmpeg Filter过滤器处理音视频
javaCV开发详解之14：音频重采样
javaCV开发详解之15：视频帧像素格式转换
javaCV开发详解之16：使用一张图片推流和一张图片录制成视频文件
javaCV开发详解之17：GIF和APNG动态图片推流和录制成视频文件（以gif转mp4为例）
javaCV开发详解之18：音视频转码（音频编解码和视频编解码）
javacv开发详解之19：使用批量多张图片制作apng动态图
JavaCV开发详解之20：如何使用JavaCV制作ico图标，图片和视频生成ico图标，视频流录制ico图标
JavaCV开发详解之21：如何使用JavaCV接入gb28181的ps流并推流到流媒体服务和接入海康大华sdk回调h264/hevc裸流
JavaCV开发详解之22：flv,live_flv格式说明,http-flv拉流和http-flv推流及rtmp拉流和rtmp推流全面分析和开发实战
JavaCV开发详解之23：hls视频录制，m3u8切片录制和fmp4切片录制详解，以拉流rtmp录制hls切片为例
JavaCV开发详解之24：使用javacv保存raw视频像素格式(yuv或者rgb)，并使用ffplay播放raw
JavaCV开发详解之25：简单视频截图，视频文件和rtsp/rtmp/flv/hls等直播流截取一张图片
JavaCV开发详解之26：使用javacv对视频进行连续截图和覆盖截图，支持png,jpg,bmp等格式快速连续截图，适用于视频快照
JavaCV开发详解之27：使用javacv把视频切割成多个视频分片文件，以mp4为例，把视频切割成MP4分片文件
JavaCV开发详解之27补充篇1：使用javacv把音视频切割成多个音频分片文件，以mp3为例，把视频切割成MP3分片文件
JavaCV开发详解之28：如何使用javacv进行多图推流和多图合成视频文件,以批量jpg图片推流rtmp和jpg合成flv视频文件为例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffc551a68469609beb7abb28656390d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa4e0fcf82265d2f2bbd65e6d05b7c8c/" rel="bookmark">
			将阿里云盘挂载到本地磁盘-CloudDrive工具使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CloudDrive是什么？
支持将115、沃家云盘、天翼云盘、阿里云盘、WebDAV挂载到本地并创建本地磁盘。
CloudDrive是一个全方位的云存储管理平台，旨在无缝集成多个云存储服务，将它们统一整合到一个界面中。
使用CloudDrive，您可以轻松管理和访问所有云存储服务，无需在不同的应用程序和界面之间来回切换。
CloudDrive最引人注目的特点是其能够将多个云存储服务挂载为本地磁盘，直接访问文件而无需预先下载。想象一下，您可以将云存储服务当作本地文件系统的一部分来使用，带来的便利性不言而喻。
但这还不是全部 - CloudDrive还提供了高级功能，如快速的云端文件传输、实时的云文件通知和应用级别的权限控制。无论您是高级用户还是普通云存储用户，CloudDrive都能以卓越的效率和易用性让您充分发挥云存储资源的潜力。
使用教程：
1.下载并安装CloudDrive，官网地址：https://www.clouddrive2.com/，Github地址：https://github.com/cloud-fs/cloud-fs.github.io/releases。
2.安装好进入地址：http://localhost:19798/，注册并登录，点击云盘的图标。
3.点击上边电脑图标将添加好的网盘挂载到本地硬盘，选择一个要设置的挂载点，比如我选的F，点击挂载即可。
4.查看此电脑就可以看到我们刚才添加的硬盘了。
整体来说步骤非常简洁，几乎都是傻瓜式操作，没有任何技术含量和难度。
除了Windows之外，CloudDrive还支持Docker、Linux，因此你还能将CloudDrive安装在NAS、服务器、OpenWrt路由器等设备上使用，这样能玩的花式就更多了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edce0b391ff5a78ecda8ec28fefa8d0f/" rel="bookmark">
			A Survey of Graph Neural Networks for Recommender Systems: Challenges, Methods, and Directions
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐系统图神经网络综述：挑战、方法和方向
Journal：ACM Transactions on Recommender Systems (2023)
DOI:10.1145/3568022
推荐系统是当今互联网上最重要的信息服务之一。 最近，图神经网络已成为推荐系统的最先进的新方法。 在本次调查中，我们对基于图神经网络的推荐系统的文献进行了全面的回顾。 我们首先介绍推荐系统和图神经网络的背景和发展历史。 对于推荐系统来说，一般来说，现有作品可以从四个方面进行分类：阶段、场景、目标和应用。 对于图神经网络，现有的方法包括两类：谱模型和空间模型。 然后我们讨论将图神经网络应用于推荐系统的动机，主要包括高阶连通性、数据的结构特性和增强的监督信号。 然后，我们系统地分析了图构建、嵌入传播/聚合、模型优化和计算效率方面的挑战。 之后，我们首先按照上述分类法，对基于图神经网络的推荐系统的大量现有工作进行全面概述。 最后，我们对该领域的开放问题和有希望的未来方向进行了讨论。 我们在 https://github.com/tsinghua-fib-lab/GNN-Recommender-Systems 中总结了代表性论文及其代码存储库。
2 背景 2.1 推荐系统 2.1.1 概述。 在本节中，我们从阶段、场景、目标和应用四个角度介绍推荐系统的背景。 具体来说，在工业应用中，由于系统工程的现实要求，推荐系统总是分为三个阶段：匹配、排序和重新排序，形成标准流程。 每个阶段在数据输入、输出、模型设计等方面都有不同的特点。除了标准阶段外，还有许多具有特殊定义的具体推荐场景。 例如，近二十年来，社交推荐一直备受关注，其定义是基于社交关系改进推荐系统。 最后，不同的推荐系统有不同的目标，其中准确性始终是最重要的，因为它直接决定系统的效用。 最近，推荐系统还被赋予了其他要求，例如推荐多样化的项目以避免无聊的用户体验、确保系统公平对待所有用户、保护用户隐私免受攻击等。在应用方面，GNN 模型可以广泛部署在电子领域。 -商业推荐、兴趣点推荐、新闻推荐、电影推荐、音乐推荐等。 2.1.2 阶段。 项目池，即推荐系统可用的所有项目，通常很大，可以包含数百万个项目。 因此，常见的推荐系统遵循多阶段架构，从大规模项目池中逐步过滤项目，直到最终向用户推荐数十个项目[34, 190]。 一般来说，现代推荐系统由以下三个阶段组成。 2.1.3 场景。 下面我们将详细阐述推荐系统的不同场景，包括社交推荐、顺序推荐、会话推荐、捆绑推荐、跨域推荐和多行为推荐。 2.1.4 目标。 当然，推荐系统最重要的目标是准确性。 接下来，我们将详细阐述另外三个重要的超准确目标，包括多样性、可解释性和公平性。 2.1.5 应用程序。 推荐系统广泛存在于当今的信息服务中，其应用也多种多样，其中具有代表性的有以下几种。 2.2 图神经网络 随着社交网络、分子结构、知识图谱等海量图数据的迅速出现，近年来兴起了一波图神经网络（GNN）研究浪潮[8,47,49, 83、168、229]。 GNN 的兴起主要源于卷积神经网络（CNN）和图表示学习（GRL）的进步[205, 250]。 当应用于常规欧几里得数据（例如图像或文本）时，CNN 在提取局部特征方面非常有效。 然而，对于像图这样的非欧几里得数据，CNN 需要泛化来处理操作对象（例如图像中的像素或图上的节点）大小不固定的情况。 就GRL而言，它的目标是为图节点、边或子图生成低维向量，这些向量表示图的复杂连接结构。 例如，一项开创性的工作 DeepWalk [144]，通过在图上随机游走的生成路径上使用 SkipGram [130] 来学习节点表示。 结合 CNN 和 GRL，开发了各种 GNN 来提取结构信息并学习高级表示。 在后面的部分中，我们将介绍设计 GNN 模型以完成图任务的几个一般和主要阶段，如图 10 所示。具体而言，第 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edce0b391ff5a78ecda8ec28fefa8d0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dce82fdf5719bc2b72eee9a1aa6f3e9c/" rel="bookmark">
			QT QProgressBar控件 使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文详细的介绍了QProgressBar控件的各种操作，例如：新建界面、设置最大最小值、设置进度、返回进度最小值、返回进度最大值、返回当前进度值、重置进度默认值、返回进度条文本、设置进度条文本、设置显示进度条、设置垂直水平、样式表、信号槽、源代码、其它文章等等操作。
QProgressBar（进度条）是Qt框架中的一个小部件，用于可视化显示任务或操作的进度。它通常用于以下情况：1. 显示任务的进度：进度条可以显示任务的完成情况，让用户了解任务的进展。例如，当文件下载或复制过程中，可以使用进度条显示文件的下载或复制进度。2. 反馈长时间运行的操作：当执行需要一些时间的操作时，进度条可以提供反馈，让用户知道操作正在进行中，并显示操作的进度。这可以增加用户体验，避免用户认为应用程序已经崩溃或无响应。3. 控制流程：进度条还可以用作控制流程的一种方式。例如，在游戏中，可以使用进度条来表示角色的生命值或能量条，以便玩家了解角色的状态。通过设置进度条的最小值、最大值和当前值，可以控制进度条的显示范围和进度。进度条可以以水平或垂直方向显示，具体取决于应用程序的需求。总之，QProgressBar是一个用于可视化显示任务或操作进度的小部件，可以提供反馈和控制流程，以增强用户体验。。
本系列QT全面详解文章目前共有三十六篇，本系列文章较为详细的讲述了QT控件的基础操作和使用，也谢谢大家的关注、点赞、收藏。
本文作者原创，转载请附上文章出处与本文链接。
QT QProgressBar控件 使用详解目录
1 新建界面
2 设置最大最小值
3 设置进度
4 返回进度最小值
5 返回进度最大值
6 返回当前进度值
7 重置进度默认值
8 返回进度条文本
9 设置进度条文本
10 设置显示进度条
11 设置垂直水平
12 样式表
13 信号槽
14 源代码
15 其它文章
1 新建界面 2 设置最大最小值 // 设置进度范围的最小值和最大值 ui-&gt;progressBar-&gt;setRange(20,40); 3 设置进度 //设置当前进度的值 ui-&gt;progressBar-&gt;setValue(50); 4 返回进度最小值 //返回进度范围的最小值 miValue = ui-&gt;progressBar-&gt;minimum(); 5 返回进度最大值 //返回进度范围的最大值 miValue = ui-&gt;progressBar-&gt;maximum(); 6 返回当前进度值 //返回当前进度的值 miValue = ui-&gt;progressBar-&gt;value(); 7 重置进度默认值 //重置进度条的值为默认值 ui-&gt;progressBar-&gt;reset(); 8 返回进度条文本 //返回进度条的文本 ui-&gt;progressBar-&gt;text(); 9 设置进度条文本 //设置进度条的文本格式 ui-&gt;progressBar-&gt;setFormat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dce82fdf5719bc2b72eee9a1aa6f3e9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e54cb00defb47751a65285f106af947f/" rel="bookmark">
			MyabtisPlus（高级查询）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Myabtis-Plus（高级查询） 一、列投影（select）： ​ 只想看到查询到的数据中部分字段数据。
例： 查询所有学生信息，返回name age 列。 QueryWrapper&lt;USer&gt; wrapper = new QueryWrapper&lt;&gt;(); 1.wrapper.select("name","age");//----------&gt;查询列集合，将查询数据作为两例。 2.wrapper.select("name,age");//----------&gt;查询列集合，将查询数据作为一例。 usermapper.selectlist(wrapper) 二、排序与分组： 1.1、排序（orderByAsc/orderByDesc）： orderByAsc： 正序排序 等价SQL: select ..from table ORDER BY 字段, ... ASC orderByDesc ：倒序排序 wrapper方法： orderByAsc(R... columns) orderByAsc(boolean condition, R... columns) 效果： orderByAsc("id", "name")---&gt;order by id ASC,name ASC 列：查询所有员工信息按age正序排， 如果age一样， 按id正序排 @Test public void Test0(){ QueryWrapper&lt;Employee&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.orderByAsc("age", "id"); employeeMapper.selectList(wrapper); } //对应sql语句： SELECT id,name,password,email,age,admin,dept_id FROM employee ORDER BY age ASC,id ASC orderByDesc 跟 orderByAsc用法一样， 不过是倒序排 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e54cb00defb47751a65285f106af947f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dcf711a813fa46f7d07588a5a413b3c/" rel="bookmark">
			CubeMx-freeRTOS智能门锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本文基于之前的标准库的写的 freeRTOS小项目练习—智能门锁 用CubeMx进行移植，以此学习CubeMX和HAL库。
目录
一、项目的基本配置
二、配置相关项
三、项目移植
四、模块通信
五、完整项目工程代码
一、项目的基本配置 1、RCC中选择外置晶振
2、SYS中选定Debug方法，Serial Wire
3、配置系统频率，同时要选定外部晶振源HSE、使能CSS。
4、Project Manager
工程名以及保存路径不能含中文选定自己的编译器Toolchain/IDECode Generator中选定用到什么库就复制什么库；选择.c/.h文件分别生成 5、GENERATE CODE
二、配置相关项 1、配置串口printf重定向：记得开启 MicroLIB
#include "usart.h" /* USER CODE BEGIN 0 */ #include &lt;stdio.h&gt; int fputc(int ch, FILE *f)	{ HAL_UART_Transmit(&amp;huart1,(uint8_t *)&amp;ch,1,0xFFFF); return (ch); } /* USER CODE END 0 */ UART_HandleTypeDef huart1; 2、freeRTOS的配置;
MDK的编译器不能使用V6版本会报错：
我这里是将ARM_CM3进行替换(因为我用的103ZET6是Cortex-M3的核)，而非ARM_CM4F(ARM_CM4F目录,是针对Cortex-M4 FPU功能的)，查看port.c的引用路局为可以发现为ARM_CM3
【Keil】CubeMX配置的FreeRTOS利用V6编译出错_ac6 freertos编译不通过_米杰的声音的博客-CSDN博客
参考文章： FreeRTOS+CubeMX系列第一篇——初识FreeRTOS_cubemx freertos_冬瓜~的博客-CSDN博客
CubeMX使用FreeRTOS编程指南_cubemx freertos_Top嵌入式的博客-CSDN博客
继续配置：
Config parameters 堆栈大小设置TOTAL_HEAPS = 15360Advanced settings :Enabled Newlib settingsV10版本的流缓冲区和消息缓冲区（用于数据量大长度不定） 任务优先级的理解 任务优先级分配和修改 这样freeRTOS设置了56个优先级对应配置中的MAX_PRIORITIES FreeRTOS 任务优先级问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dcf711a813fa46f7d07588a5a413b3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf3cfb24899ecc257a8ba5db0c8e385f/" rel="bookmark">
			十一、Redis——分布式缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.1 单点Redis存在的问题
1.2 Redis持久化
1.2.1 RDB持久化方式
1.2.2 AOF持久化方式
1.3 RDB和AOF持久化方式对比分析
1.4 Redis主从集群
1.4.1 搭建Redis主从架构
1.4.2 数据同步原理
1.5 Redis的哨兵 1.5.1 Redis哨兵的作用和原理
1.6 Redis分片集群
1.6.1 分片集群结构
1.6.2 散列插槽
1.6.3 数据迁移 1.1 单点Redis存在的问题 1.2 Redis持久化 1.2.1 RDB持久化方式 RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。
快照文件称为RDB文件，默认是保存在当前运行目录。
Redis停机时会执行一次RDB。
小总结：
RDB方式bgsave的基本流程？
1. fork 主进程得到一个子进程，共享内存空间 2. 子进程读取内存数据并写入新的 RDB 文件 3. 用新 RDB 文件替换旧的 RDB 文件。 RDB会在什么时候执行？save 60 1000代表什么含义？
• 默认是服务停止时。 • 代表 60 秒内至少执行 1000 次修改则触发 RDB RDB的缺点？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf3cfb24899ecc257a8ba5db0c8e385f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b60d3122090c15c36f87c485dbda688/" rel="bookmark">
			MYBATIS-PLUS入门使用、踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载： mybatis-plus入门使用、踩坑记录 - 灰信网（软件开发博客聚合）
首先引入MYBATIS-PLUS依赖： SPRING BOOT项目： &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; SPRING MVC项目： &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; 配置： SPRING BOOT 工程： @MapperScan("com.xxx.mapper") SPRING MVC 工程： 配置 MapperScan &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.baomidou.mybatisplus.samples.quickstart.mapper"/&gt; &lt;/bean&gt; 调整 SqlSessionFactory 为 MyBatis-Plus 的 SqlSessionFactory &lt;bean id="sqlSessionFactory" class="com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; 引入：EXTENDS BASEMAPPER&lt;T&gt; 还有扩展的server方法及实现，可以自己点进去看下
需要用到就对应service继承即可，示例：
public interface UserService extends BaseService&lt;User&gt; { } public class UserServiceImpl extends BaseServiceImpl&lt;UserMapper, User&gt; implements UserService { } 坑一：出现 INVALID BOUND STATEMENT (NOT FOUND) 异常 未去除原有mybatis-spring-boot-starter依赖，导致冲突mapper文件夹未扫描到，加入@MapperScan 坑二：CAUSED BY: JAVA.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b60d3122090c15c36f87c485dbda688/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2af958802b63950c529dc22262a2ca43/" rel="bookmark">
			Maven安装和配置及STS配置Maven&amp;IDEA配置Maven
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.maven环境搭建 1.1 maven下载和修改配置 1.1.1.首先登陆官方网站进行下载：Maven – Download Apache Maven
1.1.2.将下载的压缩包解压”apache-maven-版本-bin.zip”到D盘（解压磁盘目录最好不要包含中文、特殊符号和空格的文件夹下）
路径如下：D:\Program Files\apache-maven-3.6.0
1.1.3.在 maven 解压目录下，建立 repository 本地仓库目录
1.1.4 系统环境变量中配合mvn执行路径
变量名：MAVEN_HOME=D:\Program Files\apache-maven-3.6.0
变量名：Path=;%MAVEN_HOME%\bin
1.1.5.修改maven的核心配置，打开maven安装目录下conf/settings.xml
&lt;!--设定本地仓库的路径--&gt; &lt;localRepository&gt;D:\Program Files\apache-maven-3.6.0\repository&lt;/localRepository&gt; 1.1.5.仓库设定为阿里云的仓库（D:\Program Files\apache-maven-3.6.0\conf\settings.xml 配置文件原代码如下,根据自己安装maven来决定配置文件的路径 ）
maven 阿里云 地址 https://maven.aliyun.com/nexus/content/groups/public/
&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/mirror&gt; &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2af958802b63950c529dc22262a2ca43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb89f4ab752cd7c5d34cfa3f466328fb/" rel="bookmark">
			科研笔记第7期——Matlab 绘制局部放大图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
步骤（1）
步骤（2）
步骤（3）
步骤（4）
步骤（5）
在写作论文时，经常需要对不同方法（仅有略微差别）进行比较，此时需要局部放大图发挥作用。
绘制局部放大图步骤可分为以下几个步骤：
步骤（1） 生成figure结果图
x = 0:pi/100:2*pi; y1 = sin(x); plot(x,y1,'r-o'); hold on y2=sin(x)-0.05; y3=sin(x)+0.05; xlim([0 2*pi]); ylim([-1.5 1.5]); plot(x,y2,'b-v'); plot(x,y3,'m-.'); legend('线型1','线型2','线型3','Location','northeast') 步骤（2） 输入magnify并运行（magnify.m和生成figure结果图的m文件放在同一文件夹下）可在matlab官网下载
function magnify(f1) % %magnify(f1) % % Figure creates a magnification box when under the mouse % position when a button is pressed. Press '+'/'-' while % button pressed to increase/decrease magnification. Press % '&gt;'/'&lt;' while button pressed to increase/decrease box size.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb89f4ab752cd7c5d34cfa3f466328fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c80c03dac8840c77a78fb5609b33777/" rel="bookmark">
			头歌educoder：Python入门之基础语法 第4关：输入输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务描述 本关任务：编写一个对用户输入，进行加减乘除四则运算的程序。
参考答案 if __name__ == "__main__": a = int(input()) b = int(input()) # ********** Begin ********** # print(f"{a} + {b} = {a+b}") print(f"{a} - {b} = {a-b}") print(f"{a} * {b} = {a*b}") print(f"{a} / {b} = {format(a/b,'.6f')}") # ********** End ********** # 相关知识 输出 print的函数的基本使用，在之前的关卡中，已经出现过多次，将要输出的内容放在print()的括号内，就可以输出：
print("hello world") 得到的结果是：hello world
print函数可以同时输出多个内容，只需要将它一起放在print的括号内，并用逗号隔开：
print("hello","world") 得到的结果：hello world
值得注意的是，同时输出的多个内容之间，会有空格隔开。
类似于 C/C++ 的printf，Python 的print也能实现格式化输出，方法是使用%操作符，它会将左边的字符串当做格式字符串，将右边的参数代入格式字符串：
print("100 + 200 = %d" % 300) #左边的%d被替换成右边的300print("A的小写是%s" % "a") #左边的%s被替换成右边的a 得到的结果是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c80c03dac8840c77a78fb5609b33777/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0ef329e8d41b4565487322f9aae5579/" rel="bookmark">
			单元测试方法论（终篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单元测试方法论（下）https://blog.csdn.net/sugelachao/article/details/131422020 11.典型案例分析 这里，只收集了几个经典案例，解决了特定环境下的特定问题。
11.1.测试框架特性导致问题 在编写单元测试用例时，或多或少会遇到一些问题，大多数是由于对测试框架特性不熟悉导致，比如：
Mockito不支持对静态方法、构造方法、final方法、私有方法的模拟；
Mockito的any相关的参数匹配方法并不支持可空参数和空参数；
如果为Mock方法或Mock方法参数不匹配时，会返回默认值（基础类型为 0，对象类型为 null）；
采用Mockito的参数匹配方法或Argument的captor方法时，其它参数不能直接用常量或变量，必须使用Mockito的eq方法包装；
使用when-then语句模拟Spy对象方法会先执行真实方法，应该使用do-when语句；
PowerMock对静态方法、构造方法、final方法、私有方法的模拟需要把对应的类添加到@PrepareForTest注解中；
PowerMock模拟JDK的静态方法、构造方法、final方法、私有方法时，需要把使用这些方法的类加入到@PrepareForTest注解中，从而导致单元测试覆盖率不被统计；
PowerMock使用自定义的类加载器来加载类，可能导致系统类加载器认为有类型转化问题；需要加上@PowerMockIgnore({"javax.crypto.*"})注解，来告诉PowerMock这个包不要用PowerMock的类加载器加载，需要采用系统类加载器来加载；
如果遇到Mock对象静态常量初始化失败，可以利用注解@SuppressStaticInitializationFor抑制静态常量初始化。
……
对于这些问题，可以根据提示信息查阅相关资料解决，这里就不再累述了。
11.2.捕获参数值已变更问题 在编写单元测试用例时，通常采用ArgumentCaptor进行参数捕获，然后对参数对象值进行验证。如果参数对象值没有变更，这个步骤就没有任何问题。但是，如果参数对象值在后续流程中发生变更，就会导致验证参数值失败。
原始代码：
public &lt;T&gt; void readData(RecordReader recordReader, int batchSize, Function&lt;Record, T&gt; dataParser, Predicate&lt;List&lt;T&gt;&gt; dataStorage) { try { // 依次读取数据 Record record; boolean isContinue = true; List&lt;T&gt; dataList = new ArrayList&lt;&gt;(batchSize); while (Objects.nonNull(record = recordReader.read()) &amp;&amp; isContinue) { // 解析添加数据 T data = dataParser.apply(record); if (Objects.nonNull(data)) { dataList.add(data); } // 批量存储数据 if (dataList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0ef329e8d41b4565487322f9aae5579/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a4150b6e7c40cda7c847e81f8a45401/" rel="bookmark">
			单元测试方法论（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 清代杰出思想家章学诚有一句名言：“学必求其心得，业必贵其专精。”
意思是：学习上一定要追求心得体会，事业上一定要贵以专注精深。做技术就是这样，一件事如果做到了极致，就必然会有所心得体会。
上一篇文章《Java单元测试》除了介绍单元测试基础知识外，主要介绍了“为什么要编写单元测试”。很多同学读完后，还是不能快速地编写单元测试用例。而这篇文章，立足于“如何来编写单元测试用例”，能够让同学们“有章可循”，能快速地编写出单元测试用例。
1.编写单元测试用例 1.1.测试框架简介 Mockito是一个单元测试模拟框架，可以让你写出优雅、简洁的单元测试代码。Mockito采用了模拟技术，模拟了一些在应用中依赖的复杂对象，从而把测试对象和依赖对象隔离开来。
PowerMock是一个单元测试模拟框架，是在其它单元测试模拟框架的基础上做出扩展。 通过提供定制的类加载器以及一些字节码篡改技术的应用，PowerMock实现了对静态方法、构造方法、私有方法以及final方法的模拟支持等强大的功能。但是，正因为PowerMock进行了字节码篡改，导致部分单元测试用例并不被JaCoco统计覆盖率。
通过作者多年单元测试的编写经验，优先推荐使用Mockito提供的功能；只有在Mockito提供的功能不能满足需求时，才会采用PowerMock提供的功能；但是，不推荐使用影响JaCoco统计覆盖率的PowerMock功能。在本文中，我们也不会对影响JaCoco统计覆盖率的PowerMock功能进行介绍。
下面，将以Mockito为主、以PowerMock为辅，介绍一下如何编写单元测试用例。
1.2.测试框架引入 为了引入Mockito和PowerMock包，需要在maven项目的pom.xml文件中加入以下包依赖：
&lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-core&lt;/artifactId&gt; &lt;version&gt;${powermock.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-api-mockito2&lt;/artifactId&gt; &lt;version&gt;${powermock.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt; &lt;version&gt;${powermock.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 其中，powermock.version为2.0.9，为当前的最新版本，可根据实际情况修改。在PowerMock包中，已经包含了对应的Mockito和JUnit包，所以无需单独引入Mockito和JUnit包。
1.3.典型代码案例 一个典型的服务代码案例如下：
/** * 用户服务类 */ @Service public class UserService { /** 服务相关 */ /** 用户DAO */ @Autowired private UserDAO userDAO; /** 标识生成器 */ @Autowired private IdGenerator idGenerator; ​ /** 参数相关 */ /** 可以修改 */ @Value("${userService.canModify}") private Boolean canModify; ​ /** * 创建用户 * * @param userCreate 用户创建 * @return 用户标识 */ public Long createUser(UserVO userCreate) { // 获取用户标识 Long userId = userDAO.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a4150b6e7c40cda7c847e81f8a45401/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/474087f57c9475ecbd7a4f59e393c2eb/" rel="bookmark">
			Python - Font()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中的Font()函数实际上是Tkinter图形用户界面库的一部分，用于创建字体对象。Tkinter支持使用字体名称和大小来创建字体对象，但具体可用的字体取决于你的操作系统和安装的字体：
1. "Helvetica" - 也称为"Arial"，是一种常见的无衬线字体。
2. "Times" - 类似于"Times New Roman"，是一种常见的衬线字体。
3. "Courier" - 类似于"Courier New"，是一种等宽字体。
4. "Verdana" - 一种无衬线字体，通常用于Web设计。
5. "Tahoma" - 一种无衬线字体，类似于"Verdana"。
6. "Georgia" - 一种衬线字体，常用于印刷和Web设计。
import tkinter as tk root = tk.Tk() my_font = tk.Font(family="Helvetica", size=12, weight="bold") # 使用字体对象 label = tk.Label(root, text="Hello, World!", font=my_font) label.pack() root.mainloop() 字体的可用性可能因操作系统和安装的字体而异。
Pygame会提供一些常见的字体：
1. "arial" - Arial字体。
2. "couriernew" - Courier New字体，是一种等宽字体。
3. "timesnewroman" - Times New Roman字体，是一种常见的衬线字体。
4. "calibri" - Calibri字体，通常用于Microsoft Office文档。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/474087f57c9475ecbd7a4f59e393c2eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e710ff56b401f32b7d988d17f26a924/" rel="bookmark">
			Pygame Module - event.type()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 在Pygame中，`event.type`代表事件的类型。Pygame支持许多不同类型的事件，用于响应用户的输入、窗口操作等。以下是一些常见的event.type()：
# 1. `pygame.QUIT`：窗口关闭事件，当用户点击窗口的关闭按钮时触发。
# 2. `pygame.KEYDOWN`：键盘按键按下事件，当用户按下一个键盘键时触发。
# 3. `pygame.KEYUP`：键盘按键释放事件，当用户释放一个键盘键时触发。
# 4. `pygame.MOUSEBUTTONDOWN`：鼠标按钮按下事件，当用户按下鼠标按钮时触发。
# 5. `pygame.MOUSEBUTTONUP`：鼠标按钮释放事件，当用户释放鼠标按钮时触发。
# 6. `pygame.MOUSEMOTION`：鼠标移动事件，当用户移动鼠标时触发。
# 7. `pygame.MOUSEWHEEL`：鼠标滚轮事件，当用户滚动鼠标滚轮时触发。
# 8. `pygame.VIDEORESIZE`：窗口大小调整事件，当窗口大小被调整时触发。
# 9. `pygame.USEREVENT`：用户自定义事件，你可以使用`pygame.USEREVENT`作为事件类型来创建自己的自定义事件。
# 10. 其他一些事件类型用于处理音频、定时器、焦点变化等特定情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0dd890e942492cd052355fcc073629c/" rel="bookmark">
			绘制三角波与梯形波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数 使用三角函数及反三角函数
在线编辑运行工具 JupyterLite Retro - Notebook
三角波 import numpy as np import matplotlib.pyplot as plt # 创建一个从-2π到2π（包含2π）的等差数列，步长为0.01 x = np.arange(-4*np.pi, 4*np.pi, 0.01) # 计算y值 y = np.arcsin(np.sin(x)) # 绘制图像 plt.figure(figsize=(8, 6)) plt.plot(x, y) plt.title('y = arcsin(sin(x))') plt.xlabel('x') plt.ylabel('y') plt.grid(True) plt.show() 梯形波 import numpy as np import matplotlib.pyplot as plt # 创建一个从-2π到2π（包含2π）的等差数列，步长为0.01 x = np.arange(-4*np.pi, 4*np.pi, 0.01) # 计算y值 y = np.arcsin(np.sin(x)) # 绘制图像 plt.figure(figsize=(8, 6)) plt.plot(x, y) plt.title('y = arcsin(sin(x))') plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0dd890e942492cd052355fcc073629c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d5186a8dbd55e10e58cb82729ad648b/" rel="bookmark">
			centos screen基础使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		screen 是一个在Linux和Unix系统中非常有用的工具，特别是当你需要在远程服务器上运行长时间运行的任务时。下面是在CentOS 7上使用 screen 的基础指南：
安装 如果你的CentOS系统还没有安装 screen，你可以使用下面的命令来安装：
sudo yum install screen 使用 新建会话
在终端输入 screen 并按回车，这将新建一个 screen 会话。
screen 或者，你可以给新会话一个名称，以便将来容易识别
screen -S session_name 2、会话列表
要查看当前所有的 screen 会话，可以使用：
screen -ls 3、重新连接会话
如果你已经断开了某个 screen 会话，你可以用下面的命令重新连接：
screen -r 如果有多个会话，你需要指定会话名或会话ID：
screen -r session_name_or_ID 如果不能恢复：先screen -d ###
再screen -r ###
4、断开会话
要暂时断开当前会话并返回到主终端，你可以使用：
# 按下 Ctrl + A，然后按 D 5、关闭会话
如果你要结束会话，可以使用：
# 按下 Ctrl + A，然后按 K 或者在会话中直接输入 exit。
删除 screen -S ### -X quit
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d5186a8dbd55e10e58cb82729ad648b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e4bc75fc5e2cb4b774bfe3231f5b279/" rel="bookmark">
			生成正选波形时浮点运算转标幺值定点整数运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于浮点运算占用CPU的运行时间大于定点运算，当我们在一些对时间特别敏感的系统中就需要对小数进行标幺处理，然后用定点整数的方式来进行运算
表1 Q ，S的取整范围
一般的小数的标幺格式采用Q15格式
我这边对0.1~1 标幺得到的数组如下
f_0_1 = 3276,
f_0_2 = 6553,
f_0_3 = 9830,
f_0_4 = 13107,
f_0_5 = 16384,
f_0_6 = 19660,
f_0_7 = 22937,
f_0_8 = 26214,
f_0_9 = 29491,
f_1_0 = 32767
对生成的sine波形进行标幺得到一个整数数组
标幺的乘法运算
设浮点乘法运算的表达式为：
float x, y,z;
z = x*y;
假设经过标幺后的X定值为Qx,y为Qy z为Qz
例如 x= 0.5 y=0.5
则 标幺后 X= 16384 ，Y= 16384 则Z= X*Y&gt;&gt;(15+15-15) =8192
z =Z/32768 = 0.25
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/93/">«</a>
	<span class="pagination__item pagination__item--current">94/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/95/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>