<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a87712029506a8243ba79462e8ec3ccb/" rel="bookmark">
			抖音视频怎么拼接？分享一款功能强大的软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抖音视频怎么拼接？利用软件就很方便，所以抖音视频拼接可以通过操作简单的视频软件来辅助比较简单。就比如万兴喵影，就是一款操作简单、功能齐全的视频编辑器，很适合新手小白和半专业人士。
用万兴喵影做视频拼接，只需要：
首先，在官网下载并安装万兴喵影，然后将其启动；
然后，在媒体库把第一个视频拖到轨道上，接着把第二个视频拖到和第一个视频相同的轨道上；
最后，视频拼接好，只要点击“导出”，就拼接完成了。
如果要拼接多个视频，方法和拼接第一、二个视频一样。
此外，万兴喵影还有其他许多好用的功能：
曲线变速可以一键添加专业的变速效果，给普通的日常片段也能赋予大片效果。
NEWBULE FX提供给用户好莱坞级的3D文字和视觉特效资源。
遮罩功能经过全新优化，可以支持掩蔽关键帧操作了。
高光卡点功能让视频中的高光时刻一键卡点，可以把最亮眼的时刻与他人分享！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1db893a39c585aeaf1254371b14d9be/" rel="bookmark">
			怎么做视频拼接？借助这款软件事半功倍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎么做视频拼接？利用软件，可以快速实现，其实可以拼接视频的软件还是蛮多的，感觉万兴喵影操作起来比较方便。
第一步：在官网下载并安装万兴喵影，打开万兴喵影，点击”文件”选择需要拼接的视频。
第二步：选中视频素材，将视频添加到视频轨道中，再把第二个视频移动到和第一个视频相同的轨道上，多个视频的操作以此类推。
第三步：视频拼接好以后，点击“导出”即可。
万兴喵影内置了很多视频转场效果，可以添加到视频和视频之间，让视频的转场更自然炫酷。
同时，万兴喵影还有滤镜和蒙板提供了丰富的滤镜效果和时下最流行的贴图蒙板；超多文本、字幕、片头标题特效；多种风格的精美动态贴图；内容多样化且齐全的音乐库；支持视频倒放、多种比例、画面裁剪与缩放、无极变速、降噪等多种功能，轻轻松松就能打造视频大片。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4139cfff3ca2d74d20c95422b1847914/" rel="bookmark">
			HarmonyOS应用开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
了解HarmonyOS
一、鸿蒙官方网站
二、前端三大框架： `Vue` `React` `Angular`
三、为什么学习鸿蒙开发
四、鸿蒙系统和安卓系统的关系
五、`HarmonyOS`概述
六、安装开发工具
HarmonyOs 应用开发
一、DevEco Studio开发工具介绍
二、创建项目
三、研究项目目录结构
四、编写页面内容
五、文件中的常用组件
六、组件
1、text组件
2、input组件
3、image组件
4、search组件
七、远程真机测试环境
HarmonyOs项目
一、集合优点
二、`src/main/config.json`基础配置
1、列表渲染
2、发送`http`请求
项目请看网址:
了解HarmonyOS 一、鸿蒙官方网站 网址:华为HarmonyOS智能终端操作系统官网 | 应用设备分布式开发者生态
二、前端三大框架： `Vue` `React` `Angular` `Angular` 2009 - `Google` `Vue` 2014 - 尤雨溪`React` 2015 - `Facebook` 三、为什么学习鸿蒙开发 对于个人 第一次有机会与老程序员同台竞争。逐渐成长为“第一批鸿蒙开发程序员”。对于行业 `MVVM`框架的发展。 简单化。 `ArkUI`框架。对于民族 中国必须有自己的操作系统。世界公认三大基础软件：OS操作系统、DB数据库、IDE开发工具 四、鸿蒙系统和安卓系统的关系 鸿蒙系统可以安装`Android`系统的`.apk`安装文件？
| 厂家 | 操作系统 | 开源环境 |
| -------- | ----------------------------------------------------------------------------- | --------------------- |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4139cfff3ca2d74d20c95422b1847914/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a3dd0d72e1e33a6faed1d89a5a99556/" rel="bookmark">
			Linux命名空间简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、命名空间简介
二、命名空间分类
三、如何创建命名空间
四、Linux可以自动为系统服务创建独立的命名空间
一、命名空间简介 在传统的LIinux系统上，系统资源都是全局的，比如pid、文件、网络等，为了支持容器虚拟化，Linux内核有NameSpace机制，它可以把一组进程的资源隔离起来，比如使用将进程自己的文件映射到特定目录下，不与其他命名空间下的进程共享。
二、命名空间分类 Linux的NameSpace主要分为以下几种：
1、IPC：从2.6.19内核开始，IPC NameSpace用于隔离进程间通讯所需的资源，PID命名空间和IPC命名空间可以组合起来用，只有同一个IPC NameSpace内的进程才进行交互，不同空间进程无法交互；
2、Network：从2.6.24内核开始，Network Namespace为进程提供了一个完全独立的网络协议栈的视图。包括网络设备接口，IPv4和IPv6协议栈，IP路由表，防火墙规则，sockets等等。一个Network Namespace提供了一份独立的网络环境，就跟一个独立的系统一样。
3、Mount：从2.4.19内核开始，每个进程都存在于一个mount Namespace里面，mount Namespace为进程提供了一个文件层次视图。如果不设定这个flag，子进程和父进程将共享一个mount Namespace，其后子进程调用mount或umount将会影响到所有该Namespace内的进程。如果子进程在一个独立的mount Namespace里面，就可以调用mount或umount建立一份新的文件层次视图。
4、PID：从2.6.24内核开始，同一个进程，在不同的命名空间进程号不同，进程命名空间是一个父子结构，子空间对于父空间可见。
5、Use：从2.6.23开始，到3.8版本不再支持，用于隔离用户信息；
6、UTS：从2.6.19内核开始，全称是Unix Timesharing system，包含了运行内核的名称、版本、底层体系结构类型等信。
三、如何创建命名空间 创建一个新的命名空间有以下几种办法：
1、在clone新进程时指定CLONE_NEWPID/CLONE_NEWIPC/CLONE_NEWNS/CLONE_NEWUSER/CLONE_NEWUTS等就能为进程创建新的对应类型的命名空间；
2、setns可以切换进程的命名空间；
3、使用unshared命令，也可以用进程创建新的命名空间；
查看进程所属的命名空间可以使用cat /proc/pid/ns
四、Linux可以自动为系统服务创建独立的命名空间 一般大家都认为在容器环境下，比如docker内才容易出现进程切换到新的命名空间，其实正常情况虚拟机也是会出现的，当我们以系统服务启动某个程序时，需要为该程序配置service文件，其中有这样一个配置项：
#[Service]部分：指定启动行为，包括Type、EnvironmentFile、ExecStart、ExecReload、ExecStop、PrivateTmp。 [Service] PrivateTmp=true 当PrivateTmp设置为true时，会为该进程创建新的Mount NameSpace，然后在新的命名空间中挂载私有的 /tmp 与 /var/tmp 目录，达到不与其他进程共享的目的。
这样做虽然增加了临时文件的安全性，但是进程就无法通过/tmp或/var/tmp目录下的文件通信了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1baa0878785e6eb33f0fc100a10fcfdc/" rel="bookmark">
			微信小程序/uniapp分享功能-代码封装与使用（分享好友或朋友圈-两种方式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方地址：分享 | uni-app官网 一、分享朋友圈-详见uni-app官方文档 注意：更多注意事项见uni-app文档
结果展示：
二、分享好友或者朋友圈-详见微信开放文档 先展示：
实现分享好友
实现分享朋友圈
注意：这两个方法和页面生命周期onLoad（）同一级
详见代码：
onLoad(option) {
this.setPaintOrgIdData(option);
this.getProductData(option);
},
// 微信小程序右上角分享
onShareAppMessage() {
return this.getShareData();
},
// 转发至朋友圈
onShareTimeline() {
return this.getShareData("timeline");
},
methods：{
getShareData(type) {
let title = "分享标题";
// 判断本地是否存在ID---------（这个不重要，目的是为了获取 path）
let paintOrgId = uni.getStorageSync("paintOrgId");
let path = `/pages/index/index`;
if (paintOrgId) {
path = `${path}?id=${paintOrgId}`;
}
let imageUrl = "../../static/images/public/ic_unified_share.png";
if (type == "timeline") {
return {
title,
imageUrl,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1baa0878785e6eb33f0fc100a10fcfdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5875441931a238b435e437f3ed60db91/" rel="bookmark">
			PostgreSQL 循环遍历结果集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DO $$ DECLARE
tmp RECORD;
BEGIN FOR tmp IN SELECT id_,code_,name_ FROM t_ex_device ORDER BY id_ ASC LOOP UPDATE t_ex_device SET name_=chr(int4(random()*26)+65) WHERE id_=tmp.id_;
END LOOP;
END; $$;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2787745eadd7223e25d619a27ebc272c/" rel="bookmark">
			C# Modbus-TCP协议的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、模拟测试界面
2、编程实现
public partial class Form1 : Form { public Form1() { InitializeComponent(); cbbWriteFunction.SelectedIndex = 0; } /// &lt;summary&gt; /// TextBox只允许16进制输入 /// &lt;/summary&gt; /// &lt;param name="sender"&gt;&lt;/param&gt; /// &lt;param name="e"&gt;&lt;/param&gt; private void HexInput_KeyPress(object sender, KeyPressEventArgs e) { // 0-9 a-z A-Z Backsppace按键可输入 if ((e.KeyChar &gt;= '0' &amp;&amp; e.KeyChar &lt;= '9') || (e.KeyChar &gt;= 'a' &amp;&amp; e.KeyChar &lt;= 'f') || (e.KeyChar &gt;= 'A' &amp;&amp; e.KeyChar &lt;= 'F') || e.KeyChar == '\b') { if (e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2787745eadd7223e25d619a27ebc272c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4350867047e7db65fd2890cdb1c32fdb/" rel="bookmark">
			从0开始的高翔SLAM十四讲pangolin库的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 （1）在安装pangolin库前，需要配置以下依赖：
sudo apt install libgl1-mesa-dev sudo apt install libglew-dev sudo apt install cmake （2）下载源码压缩包（注意：我没有使用高翔提供的安装包，会出错）：
git clone https://github.com/stevenlovegrove/Pangolin.git （3）解压下载好的文件并打开它：
unzip Pangolin &amp;&amp; cd Pangolin （4）继续编译，等待安装进程100%：
mkdir build cd build cmake .. make -j4 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f62a02c30a456c62f6c81ff8b0db48e/" rel="bookmark">
			乌班图系统配置环境出现E: 无法获得锁 /var/lib/dpkg/lock-frontend - open (11: 资源暂时不可用)解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当在终端配置环境时，出现以下问题：
E: 无法获得锁 /var/lib/dpkg/lock-frontend - open (11: 资源暂时不可用) E: 无法获取 dpkg 前端锁 (/var/lib/dpkg/lock-frontend)，是否有其他进程正占用它？ 解决方法一：
（1）输入以下命令找到相关进程
ps -e|grep apt-get ps -e|grep apt （2）然后用kill杀掉进程
sudo kill xxxx 解决方法二：
（1）终端输入以下命令，查看
ls /var/lib/dpkg/lock-frontend （2）删除
sudo rm -r -f /var/lib/dpkg/lock-frontend （3）如果接着报错，继续删除
sudo rm -r -f /var/lib/dpkg/lock 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b91d6f8b1b3802dfce2c2e554677b686/" rel="bookmark">
			python语言Django框架搭建学生信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.系统介绍 本系统是基于Django 2.2.3开发的，面向学生信息管理系统。
系统以学生个体为核心向外拓展诸如宿舍、班级、学生组织等一系列组，诸如请假、签到、通知发布等一系列应用。
计划内实现功能有：班级、学生、宿舍三大项为基础的信息管理系统，早检、晨跑、卫检及相应结果查询系统，通知按组发布、公告发布为主的信息发布平台， 课表查询、成绩查询、校园卡流水查询、竞赛通知查询、竞赛组队、图书馆借阅查询、考试安排查询、校内信息发布等一系列功能的整合的学生端应用。
现已初步完成班级、学生、宿舍三大基础模型的搭建、学生事件记录、晨跑统计及查询系统。
注意事项
由于系统以学生、班级、宿舍三大模型为基础，使用系统时应当先对信息进行导入操作，确保导入成功后再进行其他操作。
导入时建议先将班级、宿舍信息导入并确认无误后在对学生信息进行导入。
2.系统思维导图 3.系统成果展示： 4. 环境搭建 安装Django version 2.2.7版本，和依赖包，切记版本需要对得上。
如果遇见版本问题，不懂如何安装的，可以咸鱼下单咨询：
【闲鱼】https://m.tb.cn/h.UR01X7p?tk=3rY2d3oxlU3 CZ0001 「我在闲鱼发布了【python编程解答，需要联系，价格优惠【老客户专属】】」
点击链接直接打开
5.源码百度网盘地址： 链接：https://pan.baidu.com/s/1og4JF6qTyMQ-UFARJ2dpsg?pwd=8dsf
提取码：8dsf
–来自百度网盘超级会员V5的分享
6.数据库配置： 可以更改成自己的数据库地址，只需要更改settings.py的数据库配置
DATABASES = { # 'default': { # # 'ENGINE': 'django.db.backends.sqlite3', # Django 默认的数据库为sqlite3 # # 指定数据库引擎 # 'ENGINE': 'django.db.backends.mysql', # # 指定数据库名 # 'NAME': 'dev3', # # 数据数据用户名 # 'USER': 'root', # 'PASSWORD': 'python', # 数据库密码 # 'HOST': '1.15.135.116', # 数据库主机域名或者ip # 'PORT': 3306 # 数据库的端口 # }, 'default': { # 'ENGINE': 'django.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b91d6f8b1b3802dfce2c2e554677b686/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea19800eac8227b1ae1a264a26dae89b/" rel="bookmark">
			Java实现通讯录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：通讯录非常适合前期需要练习语法的小伙伴，效果非常好。
水再浑浊，只要长久沉淀，依然会分外清澈。
人再愚钝，只要足够努力，一样能改写命运。
此通讯录的功能包括：
1.删除联系人
2.增加联系人
3.展示已有联系人
4.查找联系人
5.排序联系人
6.退出通讯录
public class Main { public static IMainList func(){ AddressList.menu();//打印菜单 Scanner scanner=new Scanner(System.in); System.out.println("请选择-&gt;"); int k= scanner.nextInt(); if(k==1){ return new DeleatePerson();//删除联系人 }else if(k==2) { return new AddPerson();//增加联系人 }else if(k==3){ return new ShowPerson();//展示联系人 }else if(k==4){ return new LookupPerson();//查询联系人 }else if(k==5){ return new SortPerson();//联系人排序 } return null; } public static void main(String[] args) { //AddPerson addPerson=new AddPerson();//创建通信录 AddressList addressList=new AddressList(); while(true) { IMainList iMainList = func();//向上转型，执行通讯录的相关操作 if(iMainList==null){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea19800eac8227b1ae1a264a26dae89b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/367f2aace041133461ec16cbdc21db95/" rel="bookmark">
			150个CMD命令(史上更全cmd命令 net命令)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
cmd命令大全:
net命令
加油各位( •̀ ω •́ )y 期待与君再相逢
150个CMD命令(史上更全cmd命令 net命令)
运行操作cmd命令:开始-运行(或快捷键win+R) -输入cmd-回车(win10系统打开方式:鼠标右键点击开始图标-选择运行)，在命令行里可以看到系统版本、文件系统版本。
cmd命令大全: 1.calc-----------启动计算器
2.certmgr.msc----证书管理实用程序
3.charmap--------启动字符映射表
5.chkdsk.exe-----Chkdsk磁盘检查
6.ciadv.msc------索引服务程序
7.cleanmgr-------垃圾整理
8.cliconfg-------SQL SERVER 客户端网络实用程序
9.Clipbrd--------剪贴板查看器
10.cmd.exe--------cmd命令提示符1
11.compmgmt.msc---计算机管理
12.conf-----------启动netmeeting
13.dcomcnfg-------打开系统组件服务
14.ddeshare-------打开DDE共享设置
15.devmgmt.msc--- 设备管理器
16.dfrg.msc-------磁盘碎片整理程序
17.diskmgmt.msc---磁盘管理实用程序
18.drwtsn32------ 系统医生
19.dvdplay--------DVD播放器
20.dxdiag---------检查DirectX信息
21.explorer-------打开资源管理器
22.eudcedit-------造字程序
23eventvwr-------事件查看器
24.fsmgmt.msc-----共享文件夹管理器
25.gpedit.msc-----组策略
26.iexpress-------木马捆绑工具，系统自带
27.logoff---------注销命令
28.lusrmgrmsc----本机用户和组
29.notepad--------打开记事本
30.magnify--------放大镜实用程序
31.mem.exe--------显示内存使用情况
32.mmc------------打开控制台
33.mobsync--------同步命令
34.mplayer2-------简易widnowsmediaplayer
35.Msconfig.exe---系统配置实用程序
36.mspaint--------画图板
37.mstsC----------远程桌面连接
38.narrator-------屏幕“讲述人”
39.net start messenger----开始信使服务
40.netstat-an----(TC)命令检查接口
41.net stopmessenger-----停止信使服务
42.Nslookup-------IP地址侦测器，是一个监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具
43.ntbackup-------系统备份和还原
44.ntmsmgr.msc----移动存储管理器
45.ntmsoprq.msc---移动存储管理员操作请求
46.odbcad32-------ODBC数据源管理器
47.oobe/msoobe/a----检查XP是否激活
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/367f2aace041133461ec16cbdc21db95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1949594972d6020e775fe12a893c30ad/" rel="bookmark">
			（二）RK3566 Android11固件烧录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇：（一) RK3566 Android11 系统编译
文章目录 1. 固件包烧录步骤2. 固件统一打包3. 固件升级 1. 固件包烧录步骤 烧录工具位置：RKTools/windows/AndroidTool/AndroidTool_Release_v2.84
打开RKDevTool.exe烧录工具，右击导入配置：
导入config.cfg配置文件：
第一次烧录界面显示发现一个MASKROM设备，点击执行进行固件的烧录：
2. 固件统一打包 打包update.img需要在uboot、kernel、android都编译完成的情况下才能打包update.img，所以一般在完整编译的时候使用。编译命令如下图所示：
编译后会在rockdev/Image-rk3566_r/下生成相应的update.img固件。
3. 固件升级 点击升级固件—&gt;固件—&gt;升级
添加对应的固件包：
升级完成界面：
至此固件烧录已完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4f67ac93825129fae78c7886ea8b1a1/" rel="bookmark">
			（一) RK3566 Android11 系统编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RK3566 Android11 编译 1. 准备工作 编译 Android 对机器的配置要求较高，具体配置如下：
（1）64 位 CPU，4 核；
（2）32GB 物理内存+交换内存；
（3）250GB 空闲的磁盘空间。
这里使用的是 Ubuntu 18.04 操作系统，安装编译需要的软件包：
sudo apt-get update sudo apt-get install git gnupg flex bison gperf libsdl1.2-dev \ libesd-java libwxgtk3.0-dev squashfs-tools build-essential zip curl \ libncurses5-dev zlib1g-dev pngcrush schedtool libxml2 libxml2-utils \ xsltproc lzop libc6-dev schedtool g++-multilib lib32z1-dev lib32ncurses5-dev \ lib32readline-dev gcc-multilib libswitch-perl libssl-dev unzip zip device-treecompiler \ liblz4-tool python-pyelftools python3-pyelftools -y 在 Ubuntu 18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4f67ac93825129fae78c7886ea8b1a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa4d8112f179a3d1a339f18608066036/" rel="bookmark">
			centos 修改时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 centos 修改时间1. 查询时间常用命令2. 修改时区3. 修改时间3.1 手动修改时间3.2 联网修改时间 centos 修改时间 Centos系统时间分为系统时间和硬件时间。二者必须都修改，重启系统才会永久生效。
背景
突然不知道什么原因，服务器时间不正确了，参照之前配置的 ntp 同步好像没用不知道为什么。然后本次手动同步还有个疑问，在使用 ntp 同步的时候使用 systemctl status ntpd 查看 ntp 服务如果是 active (running) 启动的那么则使用命令 ntpdate time.windows.com 时会报错 12 Dec 15:34:31 ntpdate[50679]: the NTP socket is in use, exiting 查看说是因为重复启动导致的，所以将 ntp stop 之后在执行 ntpdate time.windows.com 就可以了，然后使用 ps 查看 ntpd 进程也是没有的。目前这里还没查是为什么。
1. 查询时间常用命令 # 查询时间常用命令 [root@master ~]# date 2022年 12月 13日 星期二 10:10:23 CST # 时间+时区 [root@demo169 ~]# date -R Tue, 13 Dec 2022 10:11:07 +0800 # 时区 [root@demo169 ~]# date +%z +0800 [root@demo169 ~]# hwclock -r 2022年12月12日 星期一 15时54分19秒 -0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa4d8112f179a3d1a339f18608066036/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1733373f64e7304022138240bdf9dab5/" rel="bookmark">
			工作中实用的 Git 操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明: 1. 本文为我的个人复习总结, 并非那种从零基础开始普及知识 内容详细全面, 言辞官方的文章
2. 由于是个人总结, 所以用最精简的话语来写文章
3. 若有错误不当之处, 请指出
清空修改: 放弃 工作区 中 dirName 文件夹下的全部修改
命令：git checkout dirName
放弃 工作区 中某个文件的修改
命令：git checkout filename
强制放弃 工作区 和 暂存区 的修改
命令：git checkout -f
以上只能清空全部已修改的问题件, 但是对于新建的文件和文件夹无法清空, 必须组合下面命令;
命令作用: 清空所有新建的文件和文件夹; git clean -d -f
查看未提交的文件等状态信息: git status
版本回退: git reset --hard 版本号
git reset --hard HEAD^^^
git reset --hard HEAD~3
git init: 使文件夹被git管理起来
git log: 查看版本详细信息 即能看出id全称
git reflog: 查看版本简略信息 + 能看到其他操作的id
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1733373f64e7304022138240bdf9dab5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b80df457c20e3772e6a0bbd5baaf3983/" rel="bookmark">
			shell脚本中如何执行外部脚本，如何调用外部脚本中的函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux开发中，经常会编写shell脚本来执行一些任务，通常是一个脚本只做一件事，随着任务的增加，脚本会越来越多，可复用的地方也会逐渐增加，这时就需要提取出脚本中的公共的功能放到一个通用的脚本中，其他脚本都能复用它 在Linux开发中，经常会编写shell脚本来执行一些任务，通常是一个脚本只做一件事，随着任务的增加，脚本会越来越多，可复用的地方也会逐渐增加，这时就需要提取出脚本中的公共的功能放到一个通用的脚本中，其他脚本都能复用它
本篇文章介绍shell脚本中如何执行外部脚本，如何调用外部脚本中的函数，以及脚本复用相关的方法
执行外部脚本的方式
假如在当前目录有 a.sh 脚本，内容如下
#!/bin/bash echo "a.sh..." 在一个脚本中执行外部脚本主要有以下几种方式
source 外部脚本名字
在当前目录下的 b.sh 脚本，内容如下:
#!/bin/bash source a.sh echo "b.sh..." 执行 ./b.sh，结果如下
[root@ecs-centos-7 ~]# ./b.sh a.sh... b.sh... 脚本中 source a.sh 命令 会先执行当前目录下的 a.sh脚本，所以结果会先输出 a.sh…再输出 b.sh脚本本身的打印
点号 外部脚本名字
把 b.sh 脚本中执行a.sh脚本的语句修改成 点号 + 空格 + a.sh ，修改之后的脚本内容如下：
注意：点号和a.sh之间一定要加上空格，否则执行的时候会出错
#!/bin/bash . a.sh echo "b.sh..." 执行 ./b.sh，结果如下
[root@ecs-centos-7 ~]# ./b.sh a.sh... b.sh... 在上述脚本中, . a.sh 会先执行a.sh脚本, 结果会先输出 a.sh…再输出 b.sh…
sh 外部脚本名字
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b80df457c20e3772e6a0bbd5baaf3983/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c28057774f595c94a962c0941d27a35/" rel="bookmark">
			VAE解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VAE VAE(Variational AutoEncoder)变分自编码器到底什么是生成模型VAE核心参考文献 VAE(Variational AutoEncoder)变分自编码器 要讲扩散模型，不得不提VAE。VAE和GAN一样，都是从隐变量 Z Z Z生成目标数据 X X X。
它们假设隐变量服从某种常见的概率分布（比如正态分布），然后希望训练一个模型 X = g ( Z ) X=g(Z) X=g(Z)，这个模型将原来的概率分布映射到训练集的概率分布，也就是分布的变换。注意，VAE和GAN的本质都是概率分布的映射。
tip:关于隐变量解释：
在统计里，隐变量是不可观测的随机变量，我们通常通过可观测变量的样本对隐变量作出推断。举例1： 高斯混合模型中，GMM中隐变量指的是每个observation对应的高斯component，由于产生过程是不可观测的（或者说隐藏的），故得名隐变量。我们可以通过收集样本对隐变量的后验概率进行推断，然后用估计的后验概率来对数据进行聚类。 举例2： 一个人拿着n个袋子，里面有m种颜色不同的球。现在这个人随机地抓球，规则如下：1. 先随机挑一个袋子2. 从这个袋子中随机挑一个球如果你站在这个人旁边，你目睹了整个过程：这个人选了哪个袋子、抓出来的球是什么颜色的。然后你把每次选择的袋子和抓出来的球的颜色都记录下来（样本观察值），那个人不停地抓，你不停地记。最终你就可以通过你的记录，推测出每个袋子里每种球颜色的大致比例。并且你记录的越多，推测的就越准（中心极限定理）。然而，抓球的人觉得这样很不爽，于是决定不告诉你他从哪个袋子里抓的球，只告诉你抓出来的球的颜色是什么。这时候，“选袋子”的过程由于你看不见，其实就相当于是一个隐变量。隐变量在很多地方都是能够出现的。现在我们经常说的隐变量主要强调它的“latent”。所以广义上的隐变量主要就是指“不能被直接观察到，但是对系统的状态和能观察到的输出存在影响的一种东西”。所以说，很多人在研究隐变量。以及设计出各种更优(比如如可解释、可计算距离、可定义运算等性质)的隐变量的表示。
换句话说，大致意思就是先用某种分布随机生成一组隐变量，然后这个隐变量会经过一个生成器生成一组目标数据。VAE和GAN都希望这组数据的分布 X ^ \hat{X} X^和目标分布 X X X尽量接近。
但是这种方法本质上是难以实现，因为“尽量接近”并没有一个确定的关于 X ^ \hat{X} X^和 X X X的相似度的评判标准。换句话说，这种方法的难度就在于，必须去猜测“它们的分布相等吗”这个问题，而缺少真正interpretable的价值判断。
`为什么用KL散度不行？KL散度的公式: D K L ( A ∣ ∣ B ) = ∑ i P A ( x i ) log ⁡ ( P A ( X i ) P B ( x i ) ) = ∑ i [ P A ( x i ) log ⁡ ( P A ( x i ) ) − P A ( x i ) log ⁡ ( P B ( x i ) ) ] D_{KL}(A||B)=\sum_iP_A(x_i)\log(\frac{P_A(X_i)}{P_B(x_i)})=\sum_i[P_A(x_i)\log(P_A(x_i))-P_A(x_i)\log(P_B(x_i))] DKL​(A∣∣B)=i∑​PA​(xi​)log(PB​(xi​)PA​(Xi​)​)=i∑​[PA​(xi​)log(PA​(xi​))−PA​(xi​)log(PB​(xi​))]从公式可以一目了然，因为KL散度是针对两个已知的概率分布求相似度的，而 X ^ \hat{X} X^和 X X X的概率分布目前都是未知。 GAN的做法就是直接把这个度量标准也学过来就行，相当生猛。但是这样做的问题在于依然不interpretable，非常不优雅。VAE的做法就优雅很多了，我们先来看VAE是怎么做的，理解了VAE以后再去理解Diffussion就很自然了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c28057774f595c94a962c0941d27a35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/799ff067303249b79bcef3bebde4e4fc/" rel="bookmark">
			扩散模型组会PPT分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PPT下载地址:
https://github.com/QianJoe/IDDPM/tree/master
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c06267afe4cd25935abf0ccd364d6731/" rel="bookmark">
			扩散模型DDPM的解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DDPM 写在前面1.将生成模型类比为建楼和拆楼1.1 类比1.2 换种思路：先拆楼1.3 建楼的难点 2. 回到拆楼，怎么拆楼？2.1 拆楼的过程 3.现在开始建楼，怎么建楼？3.1 楼的形式？ 4.还有什么问题？方差可能会太大4.1 为什么会有方差大的风险？4.2 想方设法让随机变量变少点 5.怎么生成的6.超参的设置 写在前面 本文基于苏剑林老师的文章，在此基础上加了一点点自己的理解，在公式的推导上步骤进行了补全（苏老师写的已经很好了，只不过我把步骤写全了，让零基础的人更能看懂)。苏老师的文章 1.将生成模型类比为建楼和拆楼 想要做一个像GAN那样的生成模型，它实际上是将一个随机噪声 z z z变换成一个数据样本 x x x的过程。 1.1 类比 随机噪声 z z z类比为砖瓦水泥，样本数据 x x x类比为高楼大厦； z z z到 x x x的变换，相当于 砖瓦水泥建设高楼大厦；生成模型就是一支用原材料建设高楼大厦的施工队，过程很难; 1.2 换种思路：先拆楼 所以我们换种思路：建楼难，我们就先不建楼，改成拆楼，考虑将高楼大厦一步步地拆为砖瓦水泥，这样我们就知道怎么建楼；拆楼的过程：设 x 0 x_0 x0​为建好的高楼大厦（数据样本）， x T x_T xT​为拆好的砖瓦水泥（随机噪声），假设“拆楼”需要 T T T步，整个过程可以表示为 x = x 0 → x 1 → x 2 → . . . → x T − 1 → x T = z (1) x=x_0\rightarrow x_1\rightarrow x_2\rightarrow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c06267afe4cd25935abf0ccd364d6731/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eab19cb719206d1f8bd745f239104d0/" rel="bookmark">
			vue3实现组件数据懒加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是组件数据懒加载 组件数据懒加载指的是当组件进入可视区域后在加载数据，可以使页面数据加载更快和节约资源
2.组件数据懒加载主体思路 使用@vueuse/core中的useIntersectionObserver函数来实现监听进入可视区域行为，但是必须配合vue3.0的组合API方式才能实现
3.项目中代码实现 3.1.首先新建单独文件夹存放数据懒加载方法hooks/index.vue // 提供复用逻辑的函数 import { useIntersectionObserver } from '@/vuese/core' import { ref } from 'vue' /** * 数据懒加载函数 * @param {target} target 监听的目标元素，必须是DOM对象 * @param {apiFn} api函数,需要懒加载的请求 * @returns */ export const uselazyData = (target, apiFn) =&gt; { const result = ref(null); const { stop } = useIntersectionObserver( target, // 监听的目标元素 ([{ isIntersecting }]) =&gt; { // 是否进入可视区 if (isIntersecting) { stop() // 停止监听 // 调用API函数获取数据 apiFn().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0eab19cb719206d1f8bd745f239104d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5b85ab05acd8f589e4698fa724f5a7e/" rel="bookmark">
			基于百度飞桨PaddleOCR的图片文字识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PaddleOCR项目源码：https://github.com/PaddlePaddle/PaddleOCR
飞桨开源文字识别模型套件PaddleOCR，目标是打造丰富、领先、实用的文本识别模型/工具库。最新开源的超轻量PP-OCRv3模型大小仅为16.2M。同时支持中英文识别；支持倾斜、竖排等多种方向文字识别；支持GPU、CPU预测；用户既可以通过PaddleHub很便捷的直接使用该超轻量模型，也可以使用PaddleOCR开源套件训练自己的超轻量模型。
本文基于上述源码，先下下来，主要用来学习，使用PaddleOCR模型，进行测试。
一、编译环境
电脑上装了Anaconda3 + Pycharm + python3.8的环境。就基于此环境。
新建项目时，选择Anaconda3 下的python.exe(python3.8)
二、安装库
因为使用Anaconda3，直接通过其命令终端来安装，加上百度源，速度还是蛮快的。
1、安装安装PaddlePaddle
pip install paddlepaddle -i https://mirror.baidu.com/pypi/simple 2、安装PaddleOCR whl包
pip install "paddleocr&gt;=2.0.1" # 推荐使用2.0.1+版本 安装paddleocr过程中，会出现一些模块安装失败的提示，可以先通过 pip install 模块，安装完了再安装paddleocr。
3、查看安装库的版本：
python -c "import paddle; print(paddle.__version__)" 三、新建项目
注意解释器的选择，见第一步。
1、将Github下载的源码PaddleOCR-release-2.6中的文件夹ppocr、ppstructure、tools拷贝到ocrtest文件夹下；
2、下载PaddleOCR提供的测试图片https://paddleocr.bj.bcebos.com/dygraph_v2.1/ppocr_img.zip，解压后，将fonts文件夹拷贝到ocrtest文件夹下；
3、ocrtest文件夹下新建img文件夹，里面存放“test.jpg”；test.jpg图片可以从2中下载的测试图片里找。
4、新建python文件paddleocr.py，项目结构如下：
代码如下：
# Copyright (c) 2020 PaddlePaddle Authors. All Rights Reserved. # # Licensed under the Apache License, Version 2.0 (the "License"); # you may not use this file except in compliance with the License.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5b85ab05acd8f589e4698fa724f5a7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd7e3d1336a96df3415e4c0fcf418f42/" rel="bookmark">
			记录Python中Tensor size mismatch的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习模型训练完毕之后，在加载模型进行Test验证时，出现以下报错：
RuntimeError: Error(s) in loading state_dict for GWNet: Unexpected key(s) in state_dict: "nodevec1", "nodevec2", "cat_feature_conv.weight", "cat_feature_conv.bias". size mismatch for start_conv.weight: copying a param with shape torch.Size([40, 1, 1, 1]) from checkpoint, the shape in current model is torch.Size([40, 2, 1, 1]). size mismatch for graph_convs.0.final_conv.weight: copying a param with shape torch.Size([40, 280, 1, 1]) from checkpoint, the shape in current model is torch.Size([40, 200, 1, 1]). size mismatch for graph_convs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd7e3d1336a96df3415e4c0fcf418f42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5a0b444ede250a4e0b779b58fc9724d/" rel="bookmark">
			DataWhale - OpenCV教程01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MetaData: Author:Link: https://vxr.xet.tech/s/49dV3oPublisher:Date: 2022-12-12 - 16:28 笔记记录的时间 ✅ 2022-12-12 Tag: 软件技能 计算机视觉的发展历史：
1982年马尔的书《视觉》，将视觉的任务分为两类：重建和识别。2012年，AlexNet 模型赢得了ImageNet 图像分类的比赛冠军。 传统计算机视觉框架：
深度学习计算机视觉框架：
当前业界主流框架的应用：
OpenCV框架 OpenCV模块与架构 图像的理解 灰度图像——单通道图像；
彩色图像——三通道图像。
OpenCV 的三通道图式BGR。
相关简单代码：
# 导入OpenCV库 import cv2 as cv # 导入Numpy库 import numpy as np # OpenCV 中的图像通道是BGR的顺序 def show_image(): image = cv.imread("dog.jpg") cv.imshow("dog", image) cv.waitKey(0) cv.destoryAllWindows() if __name__ == '__main__': show_image() 小细节： cv.waitKey(0)中的 中的K是大写的，如果是小写的会出现错误：
AttributeError: module ‘cv2.cv2’ has no attribute ‘waitkey’
从最最基础的学习opencv和python。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4fd1a9fea68de16ef147102819f83b8/" rel="bookmark">
			Python里面的xlrd模块详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		那我就一下面积个问题对xlrd模块进行学习一下：
1.什么是xlrd模块？
2.为什么使用xlrd模块？
3.怎样使用xlrd模块？
1.什么是xlrd模块？ ♦python操作excel主要用到xlrd和xlwt这两个库，即xlrd是读excel，xlwt是写excel的库。
今天就先来说一下xlrd模块：
一、安装xlrd模块
♦ 到python官网下载xlrd · PyPI模块安装，前提是已经安装了python 环境。
♦或者在cmd窗口 pip install xlrd
二、使用介绍
1、常用单元格中的数据类型
♦ 0. empty（空的）,1 string（text）, 2 number, 3 date, 4 boolean, 5 error， 6 blank（空白表格）
2、导入模块
import xlrd 3、打开Excel文件读取数据
data = xlrd.open_workbook(filename)#文件名以及路径，如果路径或者文件名有中文给前面加一个r拜师原生字符。 4、常用的函数
♦ excel中最重要的方法就是book和sheet的操作
1）获取book中一个工作表
table = data.sheets()[0] #通过索引顺序获取 table = data.sheet_by_index(sheet_indx)) #通过索引顺序获取 table = data.sheet_by_name(sheet_name)#通过名称获取 以上三个函数都会返回一个xlrd.sheet.Sheet()对象 names = data.sheet_names() #返回book中所有工作表的名字 data.sheet_loaded(sheet_name or indx) # 检查某个sheet是否导入完毕 如：
2）行的操作
nrows = table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4fd1a9fea68de16ef147102819f83b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcb8d4e4fccc3188cdcd8280aa0d0ae5/" rel="bookmark">
			IDEA方法模板设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、方法模板的设置位置
File--&gt;settings--&gt;Editor--&gt;File and Code Templates--&gt;Code
JavaDoc Method下追加就可以了
#foreach($param in $PARAMS) * @param $param #end #if($RETURN_TYPE != "void") * @return #end #foreach($param in $TYPE_PARAMS) * @param &lt;$param&gt; #end #foreach($exception in $THROWS) * @throws $exception #end * @author ${USER} * @date ${DATE}-${TIME} * @version 1.0 * @description TODO 此模板设置方法，只是IDEA原生自带的模板设置方法的增强，不同于在Live Templates 中设置的快捷键模板。增强后的模板和原生一样，只要在每个方法声明前，打出文档注释/** 再回车，就会自动识别该方法所有的输入输出的参数，方便修改。
二、类模板的设置位置 File--&gt;settings--&gt;Editor--&gt;File and Code Templates--&gt;Files
Class下自动解析 “File Header.java” 文件，该文件即是Includes下的File Header 文件
可直接修改Files，或在Includes 下的 File Header中修改，这里选择修改File Header文件
/** * @author ${USER} * @date ${DATE}-${TIME} * @version 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcb8d4e4fccc3188cdcd8280aa0d0ae5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f161040ea381e2035c36072fcf917f67/" rel="bookmark">
			年底了还没入门？分享下我的自动驾驶与CV算法工程师成长路线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动驾驶是未来出行的趋势，无论是国家层面还是企业层面都投入巨资研发，期望计算机视觉与AI能够改变出行，推动人类社会进步！随之而来的是海量相关算法、开发、测试岗位需求，汽车人接触的从业者大多是机械、电气、自动化专业的同学，相比于计算机科班来说，缺乏系统的学科知识，入门难，进阶更难！一般来说，入门进阶首先要对领域整体技术框架有所了解，正所谓不谋全局者不足以谋一域！有了这个基础，剩下的就是深耕某一块的内容了，老师答疑解惑！
自动驾驶之心知识星球 自动驾驶之心知识星球是首个以自动驾驶技术栈为主线的交流学习社区，这是一个前沿技术发布和学习的地方！我们汇总了自动驾驶感知（分类、目标检测、语义分割、实例分割、全景分割、关键点检测、车道线检测、3D感知、目标跟踪、多模态、多传感器融合等）、自动驾驶定位建图（高精地图、SLAM）、自动驾驶规划控制、领域技术方案、AI模型部署落地等几乎所有子方向的学习路线！除此之外，还和数十家自动驾驶公司建立了内推渠道，简历直达！这里可以自由提问交流，许多算法工程师和硕博日常活跃，解决问题！初衷是希望能够汇集行业大佬的智慧，在学习和就业上帮到大家！
星球目前有哪些成员？ 星球成员主要来自商汤科技、旷视科技、百度、阿里、网易、Momenta、Intel、Nvidia、大疆、上汽、集度、地平线、华为等业界知名公司，以及苏黎世理工、卡耐基梅隆大学、普渡大学、东京大学、香港科技大学、香港大学、清华大学、上海交大、复旦大学、浙江大学、中科大、南京大学、同济大学、上海科技大学、哈工大等国内外知名高校；
知识星球有哪些模块？ CV图文教程：网络结构可视化、算法原理图解；
视频教程：星球内部技术分享视频、相机标定、伯克利深度学习与计算机视觉、百度优达学城、Apollo自动驾驶、Udacity自动驾驶、MIT自动驾驶、Carla自动驾驶仿真等系列视频课程；
日常paper分享：3D检测、多模态、2D检测、分割、车道线、多任务、多目标跟踪、融合、传感器标定、鱼眼感知与模型、VIT、轻量化等；
职位与面经分享：自动驾驶行业职位分享内推、面经分享；
日常问答交流：和嘉宾星主交流领域学术工业最新进展；
主要面向对象 星球创建的初衷是为了给自动驾驶行业提供一个技术交流平台，包括需要入门的在校本科/硕士/博士生，以及想要转行或者进阶的算法工程人员；除此之外，我们还和许多公司建立了校招/社招内推，包括地平线、百度、蔚来汽车、momenta、赢彻科技、集度、滴滴、Nvidia、高通、纵目科技、魔视智能、斑马汽车、博世、纽劢科技、追势科技、寒武纪等！
如果您是自动驾驶和AI公司的创始人、高管、产品经理、运营人员或者数据/高精地图相关公司，也非常欢迎加入，资源的对接与引进也是我们一直在推动的！我们坚信自动驾驶能够改变人类未来出行，想要加入该行业推动社会进步的小伙伴们，星球内部准备了基础到进阶模块，算法讲解+代码实现，轻松搞定学习！
日常讨论
日常分享
星球主要关注方向 0.自动驾驶顶会与公司 星球内部为大家汇总了CVPR、ECCV、IROS、RSS、TPAMI、IV、ICIP等自动驾驶领域顶会和顶刊，以及图森、智加、主线科技、集度、滴滴、纵目、元戎启行、momenta、蔚来小鹏理想等近80家公司介绍（可以内推！）
1.计算机视觉相关数据集 数据集是AI任务的基石，然而大多数数据集都是国外机构开源，数据量较大，下载速度缓慢，这两个缺点导致很多研究人员在数据获取上为难，为此星球内部已经为大家准备了近30种计算机视觉和自动驾驶相关数据集，包括KITTI、Waymo Open Dataset、Lyft L5、COCO、Semantic3D、A2D2数据集、车道线数据集、车牌数据集、行人检测数据集、红绿灯检测数据集等，一键下载；
2.2D/3D标定工具 星球内部为大家汇总了2D检测、3D点云检测、语义分割、实例分割、3D点云分割、视频检测、交互标定、多传感器标定等工具，可以快速适配到自己项目中。
3.基础学习资料 整理了从深度学习数学基础到图像处理、经典计算机视觉算法、Opencv、Pytorch以及C++、Python、GPU和Cuda近50本pdf学习资料！
4. Backbone与Transformer 主要关注常用的轻量化、高性能backbone，以及视觉transformer结构与优化；
5. 2D目标检测 关注anchor-based、anchor-free、one-stage、two-stage、超全YOLO系列、小目标检测、多任务模型、长尾分布、误检消除、难例挖掘、定位精度优化等内容；该模块汇总检测领域的经典综述和论文，从结构、数据增强策略、采样策略、不均衡问题、半监督、知识蒸馏上展开研究；
6. 分割任务 汇总了常见的2D语义分割、实例分割、全景分割以及3D点云分割SOTA算法，并对分割任务中的边缘轮廓分割模糊不细腻问题展开讨论；
7.车道线检测 对基于检测、分割、分类、关键点、曲线预测、多传感器检测、3D车道线SOTA方法进行了汇总，对车道线遮挡、磨损、不连续问题展开了讨论！
8.鱼眼感知 针对鱼眼和全景相机在自动泊车、近域感知上的应用展开，主要包括相机标定、鱼眼全景相机系统、自动泊车系统、环视数据集、鱼眼深度估计、鱼眼目标检测、鱼眼SLAM、语义分割等方向！
9.目标跟踪 针对单目标和多目标跟踪，基于Siamese Network、Tracking-by-detection、传统滤波+关联算法、end2end等方法进行全面展开阐述，后续更会加入变速情况下的跟踪系统；
10.3D目标检测 从点云和多模态数据3D检测任务展开，基于BEV、点、体素、多camera数据的3D检测方案；
11.传感器标定 主要关注自动驾驶领域常见的Camera、Lidar、Radar、IMU之间的离线、在线标定，多相机、多激光雷达之间的标定，自动标定等；
12.多传感器融合 星球内部汇总了数据级融合、目标级融合、特征级融合、弱融合、不对称融合等多种方案！
13.SLAM与高精地图 汇总了单目SLAM、RGB-D SLAM、激光SLAM、高精地图定位方法、自定位方法！以及领域内最常用的高精地图制作方法！
14.模型压缩与轻量化 汇总了模型压缩、裁剪、量化、权值共享、模型加速、知识蒸馏、量化工具等数十篇干货介绍！
15.模型部署 TensorRT、NCNN、Opencv、MNN方案部署检测、分割、关键点、分类模型实战；
16.其它 在感知定位融合之外，还汇总了大量机器人、自动驾驶规划方法，强化学习在运动规划上的应用、V2X技术，以及图像加速CUDA方法等~
日常讨论交流 欢迎加入 欢迎大家扫码加入自动驾驶之心知识星球，我们诚邀前期成员的加入，一起创造一个全技术栈的自动驾驶开发者社区！星球成员的加入平均每天0.6元，欢迎扫码加入一起学习一起卷！
分享
收藏
点赞
在看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89ff25f2c71159f919caca2ea4291951/" rel="bookmark">
			华为交换机PVID与VLAN ID及TAG 、UNTAG学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、PVID和VLAN ID
1、PVID是端口的属性，端口的标识，具有唯一性，交换机默认未配置Vlan的情况下，因为全局vlan1的原因，所有端口的PVID都是1。如下图：
2、交换机里面display port vlan命令可以查看未配置状态下的pvid，运行display vlan 可以查看缺省vlan 1的情况。如下图：
可见，缺省状态下，所有的端口都在vlan 1中，所有的端口的PVID标识缺省都为1
3、下面看下配置了vlan情况下，PVID的变化及vlan ID的变化，配置命令为
vlan batch 20 30 40
interface GigabitEthernet0/0/1
port link-type trunk
port trunk pvid vlan 20
port trunk allow-pass vlan 20 30 40
interface GigabitEthernet0/0/2
port link-type access
port default vlan 20
interface GigabitEthernet0/0/3
port link-type access
port default vlan 30
interface GigabitEthernet0/0/4
port link-type access
port default vlan 40
可见配置完access类型的接口后,该端口缺省PVID由原来的1变成了配置的所属vlan的Vlan ID，注意标红的命令port trunk pvid vlan 20，配置完Trunk类型的接口，如果手动指定该端口的PVID，则trunk端口的PVID将由原来的PVID=1变成手动配置指定的PVID=20.
另外，通过display port vlan命令可以看出，端口的PVID属性一直存在，不管配置或者未配置PVID都存在，trunk类型的接口下，端口可以有多个vlan，如上面截图中，Trunk link list 列表是1、20、30、40这几个VLan，PVID通过配置可以改变,但是一个端口有且仅有一个PVID。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89ff25f2c71159f919caca2ea4291951/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/210536f0559848c020aa461df87e3d91/" rel="bookmark">
			微信扫码登陆在chrome浏览器失败,浏览器禁止重定向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示浏览器拦截重定向 浏览器会提示：(新版本的浏览器会提示)
Unsafe JavaScript attempt to initiate navigation for frame with URL ‘http://www.xxx.xxx/’ from frame with URL “https://open.weixin.com/xxxxxxx” The frame attempting navigation is targeting its top-level window, but is neither same-origin with its target nor is it processing a user gesture
大概意思是：浏览器监测到了iframe中存在不安全的链接正在尝试进行导航，
1. 再来看微信扫码登陆的js文件：wxLogin.js 2. 该文件中对与iframe处理上述安全问题的属性sendbox是没有添加的 3. iframe默认情况下： 在html5页面中，可以使用iframe的sandbox属性，sandbox后面如果不加任何值，就代表采用默认的安全策略，即：iframe的页面将会被当做一个独自的源，同时不能提交表单，以及执行javascript脚本，也不能让包含iframe的父页面导航到其他地方，所有的插件，如flash,applet等也全部不能起作用。简单说iframe就只剩下一个展示的功能，正如他的名字一样，所有的内容都被放入了一个单独的沙盒。 .
4. sendbox包含的属性及作用： allow-forms 允许进行提交表单 allow-scripts 运行执行脚本 allow-same-origin 允许同域请求,比如ajax,storage allow-top-navigation 允许iframe能够主导window.top进行页面跳转 allow-popups 允许iframe中弹出新窗口,比如,window.open,target=”_blank” allow-pointer-lock 在iframe中可以锁定鼠标，主要和鼠标锁定有关 .
5. 修改wxLogin.js如下： &lt;script src="https://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js"&gt;&lt;/script&gt; &lt;script&gt; !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/210536f0559848c020aa461df87e3d91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ac340e2696f7598592663c601e04d3a/" rel="bookmark">
			TEE/Trustzone学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TEE/Trustzone学习 TEE 可信执行环境 Trusted Execution Environment(TEE) 是一种安全环境，该隔离的安全环境运行在隔离的硬件之上，用来专门处理敏感数据以保证信心安全，其中执行的代码和访问的数据在机密性（没有人可以访问数据）和不可篡改性（没有人可以更改代码及其行为）方面被隔离和保护。
Intel SGX（Intel Software Guard Extensions） 是Intel提供的TEE实现，由于过去十年Intel在市场上的主流位置，Intel SGX也自然而然地成为了最常用的TEE方案之一。在SGX中，用于执行代码的TEE环境被称为Enclave（飞地），在Enclave中的数据可以确保其机密性和完整性；而Intel也提供了一个用于验证某个结果是否由SGX所执行出来，以此确保恶意者伪装成SGX来窃取信息；最后SGX方案提供了更广阔的安全边界，内存数据，包括Bios都无法获取到SGX中的加密数据。
除了Intel SGX外，几乎所有主流的芯片企业都提供了TEE解决方案。在ARM中是TrustZone方案，而在AMD中则是 PSP方案。其它手机端芯片例如联发科，高通等也广泛采取了TEE技术。
Arm的TrustZone技术提供了一种高效的、系统范围的安全方法，它将硬件强制隔离内置于CPU中。
多区域安全是Hex-Five安全创建的第一个RISC-V可信执行环境。
AMD平台安全处理器（PSP）的正式名称是AMD安全技术，是一个集成在AMD微处理器中的可信执行环境子系统。
苹果使用了一种专用处理器SEP（Secure Enclave processor）来实现数据保护、触摸ID和人脸识别等功能。SEP负责处理密钥和其他信息，如生物特征识别，这些信息非常敏感，不会被应用处理器处理。
谷歌也有一个类似的解决方案称为Titan M，这是一些Android Pixel设备上可用的外部芯片，可以实现TEE和处理安全引导、锁屏保护、磁盘加密等功能。
TEE将整个系统环境分为安全环境与 非安全或不受信任的富执行环境（REE，Rich Execution Environment）
TEE操作系统通常由具有较高特权的内核和具有较低特权的多个应用程序（称为可信应用程序，TA，Trusted Applications）组成。TA之间彼此隔离，且与TEE内核隔离。这样一来，如果有应用程序被攻陷，它就无法危害到其他应用程序或TEE内核。
简而言之，一个强大的TEE机制可以实现下述三类隔离：
1、TEE与REE之间的隔离；
2、TA和TEE内核之间的隔离；
3、TA之间的隔离。
为了达到这些安全需求，TEE需要硬件原语的支持，以强制进行隔离。硬件和软件之间的配合是至关重要的，并且需要持续配合。
TEE只接受经过适当授权并由其他授权代码检查的代码来执行。因此，在TEE中，我们需要一个安全引导特性来检查所有操作系统组件（引导加载程序、内核、文件系统、可信应用程序等）的完整性和真实性。这样可以确保在设备关机时没有人篡改操作系统的代码。
TrustZone 在现代计算机中，CPU 通过内存映射手段给每个进程营造一个单独的地址空间来隔离多个进程的代码和数据，通过内核空间和用户空间不同的特权级来隔离操作系统和用户进程的代码和数据。但由于内存中的代码和数据都是明文，容易被同处于内存中的其它应用偷窥，因此出现了扩展的安全模块，应用将加密数据送往安全模块，由安全模块处理完后再返回结果给相应的应用。
TrustZone 是 ARM 针对消费电子设备设计的一种硬件架构，其目的是为消费电子产品构建一个安全框架来抵御各种可能的攻击。
TrustZone 在概念上将 SoC 的硬件和软件资源划分为安全(Secure World) 和 非安全(Normal World) 两个世界。
所有需要保密的操作在安全世界执行（如指纹识别、密码处理、数据加解密、安全认证等），其余操作在非安全世界执行（如用户操作系统、各种应用程序等），安全世界和非安全世界通过一个名为 Monitor Mode的模式进行转换，如图：
在monitor模式下运行时，CPU处于安全状态，可以访问设备的所有外围设备和内存。不在这种模式下运行时，CPU处于非安全状态，只能访问外设的子集和特定范围的物理内存。
处理器架构上，TrustZone 将每个物理核虚拟为两个核，一个非安全核 （Non-secure Core, NS Core），运行非安全世界的代码；和另一个安全核 （Secure Core），运行安全世界的代码。
两个虚拟的核以基于时间片的方式运行，根据需要实时占用物理核，并通过 Monitor Mode 在安全世界和非安全世界之间切换，类似同一CPU下的多应用程序环境，不同的是多应用程序环境下操作系统实现的是进程间切换，而 Trustzone 下的 Monitor Mode 实现了同一 CPU 上两个操作系统间的切换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ac340e2696f7598592663c601e04d3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccbc489642c7e4cd6c90885704f9c813/" rel="bookmark">
			下MFC中对象、句柄、ID之间的区别.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows程序中，有各种各样的资源（窗口、图标、光标），系统在创建这些资源的时候会为他们分配内存，并返回标识这些资源的标识号，即句柄HANDLE（ID）。图标句柄（HICON）、光标句柄（HCURSOR）、画刷句柄（HBRUSH）。
为什么有个窗口对象还要窗口句柄呢？还有什么线程句柄，甚至还有控件ID和进程ID呢？MFC中的对象，比如应用程序对象，视图对象等，是对象就会占用内存空间，我们就可以用指针指向此对象进行访问，但windows还提供了句柄访问，初看好像有点多余，实则不然。如果我们一个进程想访问另一个进程，根据对象指针访问就不行了。我们现在的Windows是一个完全保护的系统，应用程序工作于CPU的保护模式下，引入了虚存技术。每个进程拥有独立的4GB的地址空间，所以在应用程序中的地址是自己眼中的地址，不具有通用性。那么两个进程就不能简单地传个地址就行了，窗体句柄就是windows内核的一种数据结构，不同窗体（可以是不同进程的不同窗体）有不同的窗体句柄，windows通过句柄可以识别不同的窗体对象。那么进程句柄也是全局唯一的么？非也！进程句柄也是在本进程内有效，由创建进程或者打开进程时得到的句柄。进程ID才是全局唯一的。那么控件ID是全局唯一的么？也不是！控件ID代表一个资源，很多时候就是代表一个资源所在的路径及资源名
句柄到底是什么东东呢，指针呢？
其实，句柄并没有什么神奇之处，不管哪种句柄，实际都是一个整数。它标识一种资源，如窗口、位图等等。就象你找一个人，必须知道它的地址一样，如果你要操作一种资源，必须先获得句柄。“取窗口句柄（）”并不是只能取出窗口的句柄，所有窗口控件，如编辑框、标签等都可以用本命令取出自己的句柄，如：编辑框1.取窗口句柄（）或标签1.取窗口句柄（）。控件的句柄同样，任何控件都有它自身的特有属性，句柄也就指它的特有属性（包括共性）。
句柄英文译作HANDLE，HANDLE的本意是把柄，把手的意思，是与操作系统打交道的东东。有人举过比较通俗的例子：你考上了大学，入学后，学校（操作系统）会给你一个学生证号。注意，这个号码是学校指定的，你无法自选。有了这个号码（学生证，假设一证多用）享受学校提供的服务：如你就可以去图书馆借书，去食堂吃饭，去教室上课等 等。但你不能到食堂里买啤酒，因为学校不允许这种服务。而在计算机中系统提供的服务就是API调用了。当你有了HANDLE，就可以理直气壮地向系统提出调用API的服务。而指针的权力就大多了，有了指针你可以到处去喝酒，打架，学校（操作系统）管不着，所以句柄和指针的区别在于句柄只能调用系统提供的服务。而句柄虽然是一个能相互区别的号码，但与我们普通的ID号又有区别，普通的ID号是可以由程序员自己定义的，而句柄不行，它是对象生成时系统指定的，是为了区别系统中存在的各个对象，这个句柄不是由程序员赋给的。
可以引用csdn上一个人的话来说明句柄，指针对象实例之间的关系：
牧童遥指杏花村。牧童的手为指针，杏花村的牌子为句柄，杏花村酒店为对象的实例。
深入探讨句柄
更透彻的说，句柄是一种指向指针的指针。大家都知道，所谓指针是一种内存地址。应用程序启动后，组成这个程序的各对象是住留在内存的。如果简单地理解，似乎我们只要获知这个内存的首地址，那么就可以随时用这个地址访问对象。但是，如果您真的这样认为，那么您就大错特错了。我们知道，Windows是一个以虚拟内存为基础的操作系统。在这种系统环境 下，Windows内存管理器经常在内存中来回移动对象，依此来满足各种应用程序的内存需要。对象被移动意味着它的地址变化了。如果地址总是如此变化，我们该到哪里去找该对象呢? 为了解决这个问题，Windows操作系统为各应用程序腾出一些内存储地址，用来专门登记各应用对象在内存中的地址变化，而这个地址(存储单元的位置)本 身是不变的。Windows内存管理器在移动对象在内存中的位置后，把对象新的地址告知这个句柄地址来保存。这样我们只需记住这个句柄地址就可以间接地知道对象具体在内存中的哪个位置。这个地址是在对象装载(Load)时由系统分配给的，当系统卸载时(Unload)又释放给系统。句柄地址(稳定) ─→记载着对象在内存中的地址─→对象在内存中的地址(不稳定) ─→实际对象 本质：WINDOWS程序中并不是用物理地址来标识一个内存块，文件，任务或动态装入模块的，相反的，WINDOWS API给这些项目分配确定的句柄，并将句柄返回给应用程序，然后通过句柄来进行操作。 但是必须注意的是程序每次从新启动，系统不能保证分配给这个程序的句柄还是原来的那个句柄，而且绝大多数情况的确不一样的。假如我们把进入电影院看电影看 成是一个应用程序的启动运行，那么系统给应用程序分配的句柄总是不一样，这和每次电影院售给我们的门票总是不同的一个座位是一样的道理。
MFC _窗口ID，句柄，指针三者相互转换函数
ID--HANDLE--HWND三者之间的互相转换
id-&gt;句柄 hWnd = ::GetDlgItem(hParentWnd,id);
id-&gt;指针 CWnd::GetDlgItem();
句柄-&gt;id id = GetWindowLong(hWnd,GWL_ID);
句柄-&gt;指针 CWnd *pWnd=CWnd::FromHandle(hWnd);
指针-&gt;ID id = GetWindowLong(pWnd-&gt;GetSafeHwnd,GWL_ID);
GetDlgCtrlID();
指针-&gt;句柄 hWnd=cWnd.GetSafeHandle() or mywnd-&gt;m_hWnd; 指针的使用在编程过程中至关重要，恰到好处并能正确无误的使用指针不但能够提高程序自身的运行效率，而且有助于节省程序执行所需要消耗的资源。指针对应着某个数据在内存空间中的地址，得到了指针就可以自由地修改该数据。句柄代表指针的“指针”，也可以将其比作表中数据项的索引值( 表对应某个进程自身的内存空间 )。句柄是间接的引用对象。
指针和句柄的不同之处：
句柄所指的可以是一个很复杂的结构，并且很有可能与系统有关的，比如上面所说线程的句柄，它指向的就是一个类或者结构，它和系统有很密切的关系。当一个线程由于不可预料的原因而终止时，系统就可以通过句柄来回收它所占用的资料，如CPU，内存等等。反过来想，这些句柄中的某一些，是与系统进行交互用的。
指针它也可以指向一个复杂的结构，但通常是由用户自我定义的，所以一些必需的工作都要由用户自己完成，特别是在删除的时候。
另外需要注意的是句柄往往有自己的存在区限，比如一个进程，如果将其传递到另一个进程中，句柄也就失去了意义( 表中数据项的索引值，索引离开了具体的表也就失去了意义 )。
具体转换：
( 句柄转为指针 )
CWnd* pWnd=FromeHandle(hMyHandle); pWnd-&gt;SetWindowText("Hello World!"); or CWnd* pWnd; pWnd-&gt;Attach(hMyHandle); MFC类中有的还提供了标准方法，比如Window句柄：
static CWnd* PASCAL FromHandle( HWND hWnd ); HWND GetSafeHwnd( ) const; 对于位图： static CBitmap* PASCAL FromHandle( HBITMAP hBitmap ); static CGdiObject* PASCAL FromHandle( HGDIOBJ hObject ); HGDIOBJ GetSafeHandle( ) const;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccbc489642c7e4cd6c90885704f9c813/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c87855b420a96e90b14b84fae347395f/" rel="bookmark">
			Arcgis使用教程（十二）ARCGIS地图制图之比例尺设置参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.加载数据 在Arcmap中加载中国矢量图层数据（中国省级行政区图，国界线两个图层），切换到Layout View窗口，设置地图符号要素并添加比例尺等要素，添加比例尺。
设置的 页面大小是width：33 ；height：29.7 默认比例尺：15000000
参考：https://blog.csdn.net/soderayer/article/details/127953462?spm=1001.2014.3001.5501
2.添加比例尺 Arcmap中比例尺有两种，一种是数值比例尺，一种是线段比例尺。
对应下图中的两种：
3.比例尺参数设置 3.1 数字比例尺 点击上图中的Insert菜单，添加数值比例尺。
我们直接选择第一种，效果如下，我们设置的比例尺是15000000，所以比例尺数值直接就显示为这个值，如果我们缩放图层，比例尺就会跟随变化。
鼠标状态切换到Selecet Element下：
双击地图要素就可以弹出要素属性窗口，如下如是数值比例尺属性设置：
这里参数的这是较为简单，我们不做详述。
3.2 线段比例尺参数 点击Insert菜单插入线段比例尺，Scale Bar
线段比例尺的样式有很多种，如下图：
我们先选择第一种比例尺，效果如下，单位默认为Miles，我们改为Meter显示：
Meter显示参数设置如下，线段比例尺属性这只主要有5种：Format、Frame、Size and Position、Scale and Units、Numbers and Marks。其中后面两种主要用于线段样式的具体设置。
我们缩放线段长度的时候，数字跟随变化，没有默认显示为15000000
3.2.1 Format属性 设置比例尺的样式和文本字体、颜色、大小等。
3.2.2 Frame属性 比例尺边框、背景颜色、阴影设置。
3.2.3 Size and Position属性 比例尺显示尺寸和位置。
3.2.4 Scale and Units属性 设置比例尺的样式，比如分割线数量，子分割线数量，自动调整方法，比例尺显示单位，比例尺Labels和比例尺线段的间隙。 3.2.5 Numbers and Marks属性 数字和标记属性设置。
以下是几种比例尺显示效果：
大家在使用中可以根据自己的喜好进行选择和样式设置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45e3e2fdac1450a64589fbec633e402a/" rel="bookmark">
			Java操作文件的方法大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题 最新工作涉及到文件操作的内容，顺带花点时间把各种业务场景的方法都总结出来，供大家参考
对应Maven依赖、这块提醒千万别倒错包，这块的方法本人都亲测过，如果报错看下依赖是否正确
&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 压缩用的的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.ant&lt;/groupId&gt; &lt;artifactId&gt;ant&lt;/artifactId&gt; &lt;version&gt;1.10.5&lt;/version&gt; &lt;/dependency&gt; 使用方法前建议看方法的注释及代码，是否满足自己的实际需求，必要时调整一下即可
package cn.kgc.itrip.search.test; import org.apache.commons.io.FileUtils; import org.apache.commons.io.IOUtils; import java.io.*; import java.net.MalformedURLException; import java.net.URL; import java.nio.file.Files; import java.nio.file.Paths; import java.util.ArrayList; import java.util.List; /** * 文件操作工具类 * todo 快速构建测试目录及文件：createMoreFiles * todo 检查篇 * 判断路径是文件夹还是文件：isDirectoryOrFile（前提此路径已存在） * 查看文件是否存在:checkFileExist * 检查文件夹是否存在:checkDirectoryExist * 以上两种方法好像差别不太大,都能用来判断文件或者文件夹是否存在 * 判断指定文件夹下是否含有任意文件:isHaveAnyFile（注意此方法忽略了文件夹） * 下面两个挺简单，没啥实用价值忽略掉 * 检查指定文件夹下是否含有某类型文件（通过拿到文件的List，遍历是否存在指定类型即可） * 获取文件夹下所有的文件的数量 * todo 查看篇 * 获取目录下的文件(夹)getDirAllFile * 读取某个目录下所有文件、文件夹:getFilesAll * 返回一个目录(可包括子目录)下的所有文件：getFilesList（返回文件集合） * 返回一个目录(可包括子目录)下的所有目录名称：getDirList（返回文件夹集合） * 获取文件夹下的全部或指定文件格式的文件名称:getFileName * 检测某个目录下是否含有重名文件(夹)：repetitionNum * todo 创建篇--------文件(夹)不存在则创建 * 检查目录是否存在，不存在则创建目录,只会创建目录不会创建文件的呦：createDirectory、 * createDirectory1(改进版)，根据路径不同合理更换方法（路径是目录级别还是文件级别） * 检查目标路径文件是否存在，不存在则创建此目录及文件夹，会创建文件夹及文件：createDirectoryFile * 推荐使用半智能创建目录或是否创建出具体文件：createDirectoryOrFile * 判断文件是否存在如果存在就删除，不存在就新建：createNewFile * todo 复制篇幅----- * 复制文件 copyFile 、 copyFileToWriteFile 效果一致 * 把文件复到一个文件夹：copyFileToDirectory * 把文件夹下所有内容复制到指定文件夹下：copyFilesCope * 复制文夹夹下的指定文件到目标文件夹：copyFileByName * 获取指定文件夹下的指定类型的文件，然后复制到指定的文件夹下：copyFileByType * 实现复制多个文件(夹)到指定目录下如果重名则重命名：copyFileOrDir * todo 删除篇 * 判断文件是否存在如果存在就删除，不存在就新建：createNewFile * 清空指定文件夹下所有内容：delAllFile、removeDirectory(推荐) 不会删除此目录只是清空此目录下的所有内容 * 删除指定文件夹及下所有内容：delFolder 、removeDirectoryAll(推荐) 会删除此文件夹及下面所有内容 * * 上面删除用到依赖包了，下面给出工作中用到的单个文件删除及 * 删除指定路径下的单个文件：deleteFile * 删除指定路径下的多个文件：deleteFileList * 暴力删除，直接删除掉你指定的文件夹及目录下所有内容：deleteDirectoryAll * 删除指定文件夹下指定文件名：circleMethod * 删除指定文件夹下多个指定文件名:delMethod * 删除目标文件夹下指定文件格式的所有文件:circleMethodType * todo 重命名篇 * 检查是否有重名 ：duplicateName * 重名后的新的起名名称:getNewName * 指定文件夹重命名：reNameDirectory(必须在同一文件夹下)不友好，利用复制并命名 * 指定文件重命名：reNameFile(必须在同一文件夹下)，所以不采用，利用边复制边命名 * 解读边复制边命名：文件的简单复制模块就有方法，文件的也简单，你直接复制原目录下的文件夹到另外一个新起好名称的文件夹下即可，就 * 批量命名这块我给出两个代码示例，因为的根据你的具体业务规则来定，不好写活参 * 批量修改文件名字：modifyFileNames （注换相反条件就会批量改文件夹名称） * 批量修改文件名字：recursiveTraversalFolder * * todo 压缩、解压篇----这块内容情况较多写在下面的模块 * 压缩指定文件到指定文件夹 * 压缩指定目录到指定文件夹 * 多个目录的文件压缩到一起到到指定文件夹 * 多个文件或文件夹压缩的同一目录下：方法已在文章末尾提供 * * 常用方法篇 * 获取文件名称前缀与后缀：getFileNameOrType * 返回路径中最后/出现的位置：getLastIndexOfGang * 获取上一级目录：getParentPath * 如果路径不以文件分隔符结尾，自动添加文件分隔符:getNeedPath * 实现动态根据文件夹路径或者文件路径，如果路径不存在则创建此文件， * 并是否创建出文件：createDirectoryOrFile * 修复路径，将 \\ 或 / 等替换为 File.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45e3e2fdac1450a64589fbec633e402a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c23b35e766031edd4b16f7a8e7ef994/" rel="bookmark">
			下载nacos-server-1.1.4安装包，使用mvn打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git官方地址下载nacos-server-1.1.4.zip速度太慢，码云上下载地址没有安装包。采用从码云上下载源码，自行打包。(https://gitee.com/mirrors/Nacos/tree/1.1.4)下载完成之后，进入项目目录如图 下载源码后 ，解压 本地在本文件夹 在dos窗口下利用命令：mvn -Prelease-nacos -DskipTests clean install -U 打包 成功后的地址 . 然后 解压，点击bin下的 start.cmd访问 http://localhost:8848/nacos/#/login nacos/nacos有个bug点：这个原来是6；改成8就可以了。 &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; 点击startup.cmd ，发现无法启动项目（Nacos 启动报错： Please set the JAVA_HOME variable in your environment, We need java(x64)! jdk8 or later）记得设置JavaHome目录（set “JAVA=D:\program_Soft\jdk-15.0.2\bin\java.exe”） D:\JavaProject\houduan000002\github-java-source\chuanzhi_health_Tools
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0d8107810dfdea1a8876fe6e5e20c88/" rel="bookmark">
			【Multisim 14.0】软件安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Multisim简介
主要功能
优点
下载地址
安装步骤 安装失败解决方法
Multisim简介 Multisim是美国国家仪器（NI）有限公司推出的以Windows为基础的仿真工具，适用于板级的模拟/数字电路板的设计工作。它包含了电路原理图的图形输入、电路硬件描述语言输入方式，具有丰富的仿真分析能力。
工程师们可以使用Multisim交互式地搭建电路原理图，并对电路进行仿真。Multisim提炼了SPICE仿真的复杂内容，这样工程师无需懂得深入的SPICE技术就可以很快地进行捕获、仿真和分析新的设计，这也使其更适合电子学教育。通过Multisim和虚拟仪器技术，PCB设计工程师和电子学教育工作者可以完成从理论到原理图捕获与仿真再到原型设计和测试这样一个完整的综合设计流程。
主要功能 构建仿真电路仿真电路环境multi mcu（单片机仿真）FPGA、PLD，CPLD等仿真通信系统分析与设计的模块自动布线模块―PCB设计模块：直观、层板32层、快速自动布线、强制向量和密度直方图 优点 Windows窗口界面直观、操作方便；元器件库丰富；multisim的仪器库比较完善；全面的分析工具。如瞬态分析、时域和频域分析等常规电路分析方法及多种高级分析方法； 下载地址 通过百度网盘分享的文件：Multisim…
链接:https://pan.baidu.com/s/1anudENqMEUgRsAQO9CzSdw?pwd=lbdl 提取码:lbdl
复制这段内容打开「百度网盘APP 即可获取」
安装步骤 第一步：软件下载后右键解压
第二步：打开解压后的Multisim14.0文件夹
第三步：选中NI_Circuit_Design_Suite_14_0.exe右键 以管理员身份运行
第四步：确定
第五步：点击Unzip
等待完成
第六步：确定
第七步：确定
第八步：点击InstallNI CicuitDesign Suite 14.0
第九步：自定义填写点击Next
填写信息时候注意尽量不要使用中文
第十步：点击否
第十一步：点击Browse…修改安装地址介意安装在c盘外的磁盘。推荐安装在D盘 点击 Next
第十二步：点击Next
这里补充一句；我在安装的时候，一直不能跳转到这个界面，重复安装都是这个问题，所以我就用它的卸载软件把它卸载干净。删除软件方法放到文章最后了~
第十三步：点击Next
然后就是漫长的等待安装，安装过程快慢和电脑的性能有一定的关系！
第十四步：点击Next
第十五步：同意协议点击Next
第十六步：点击Next
第十七步：点击Next
第十八步：点击Next
第十九步：点击NO
第二十步：点击RestartLater
第二十一步：在前面解压文件夹中选中NILicense Activator 1.2.exe 右键管理员身份运行
第二十二步：鼠标右击BaseEdition，单击Activate （依次点击Activate）
第二十三步：鼠标右击FullEdition，单击Activate
第二十四步：鼠标右击PowerProEdition单击Activate
第二十五步：鼠标右击FullEdition，左键单击Activate。
第二十六步：鼠标右击PowerProEdition，左键单击Activate
第二十七步：这五个是绿色后点击关闭
第二十八步：复制文件夹（汉化步骤）
第二十九步：在开始菜单栏打开软件鼠标直接拖动在桌面创建快捷方式
创建桌面快捷方式
第三十步：在桌面选中软件右键打开文件位置
第三十一步：找到stringfiles文件双击打开
第三十二步：粘贴前面复制的Chinese-simplified文件夹 （汉化）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0d8107810dfdea1a8876fe6e5e20c88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eb2a5198d2059d3bf7ed0cdcea68bc2/" rel="bookmark">
			Android小项目集合100多个
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是学习和联系Android小项目的使用资料.排名完全是根据 GitHub 搜索 Java 语言选择 (Best Match) 得到的结果, 然后过滤了跟 Android 不相关的项目, 所以排名并不具备任何官方效力, 仅供参考学习, 方便初学者快速了解当前一些流行的 Android 开源库。
文件：url80.ctfile.com/f/25127180-745422874-4fe882?p=551685 (访问密码: 551685)
这啥意思呢？这个字符串序列代表的就是受支持的 HTTP 请求方式。比如，如果此属性返回 GET POST，那么被修饰的对象既支持 HTTP-GET 请求，也支持 HTTP-POST 请求。咱们在写 Web API 时最熟悉的这几个特性类就是实现了 IActionHttpMethodProvider 接口。
复制代码
[HttpGet]
[HttpPost]
[HttpPut]
[HttpDelete]
[HttpHead]
[HttpPatch]
[HttpOptions]
复制代码
这几个特性类不仅实现了 IActionHttpMethodProvider 接口，还实现了 IRouteTemplateProvider。所以它们可以当 [Route] 特性来用，又可以限制 HTTP 请求方式，一举两得。
咱们在实际项目中，如果希望一个操作方法同时支持多种请求方法，可以叠加使用以上特性类。比如
[HttpPut]
[HttpPost]
public float GetAFloat()
还可以自己定义一个特性类，实现 IActionHttpMethodProvider 接口，从 HttpMethods 属性返回一组请求方式。
复制代码
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5eb2a5198d2059d3bf7ed0cdcea68bc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c5f278700fc3c4f9f4fb886c680aecc/" rel="bookmark">
			react原理-transition概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在react18之中，引入了transition的概念。而且有一个新的api和两个新的hooks
startTransitionuseTransitionuseDeferredValue 场景应用：
比如通过输入框输入内容更新列表内容，对于用户来说，输入框输入之后立马反馈的优先级是高过于列表更新的优先级的。但是对于18之前的版本来说，更新没有分优先级，导致如果数据量大，列表更新慢，用户输入在输入框输入内容后很慢才能得到反馈，用户体验差。
而transition可以让列表更新的优先级降低，让用户输入的先处理，然后再处理列表更新。18之后开启了concurrent mode模式，更新也分了优先级的概念。
用法：
setData1(e) startTransition(()=&gt;{ setData2(e) }) 将需要延迟更新的任务放到startTransition去执行，这样里面的更新任务就会被赋予transition的优先级。
setTimeout setTimeout也有类似于延迟更新的效果，比如
setData1(e) setTimeout(()=&gt;{ setData2(e) }, 200) 跟startTransition相比，startTransition的本质是，将任务的优先级降低，所以当用户一致输入的时候，优先级较低的任务，不会阻碍输入框的回显。并且transition的时机，是比setTImeout更加合适的，他会在没有搞优先级任务的情况下，第一时间处理。而setTimeout的时间是人为控制的，不够准确。第二则是，当渲染任务多的时候，setTImeout仍会阻碍搞优先级的任务，因为等延时时间一到，setTImeout里面的任务就会被执行，此时仍会阻止页面的交互。但是transition就不同了，在conCurrent mode下，react将该任务的优先级降低，等到浏览器空闲的时候才会执行。但也不是说startTransition的任务永远不会影响主流程，因为在react中，每个任务都有过期时间，而过渡任务的过期时间比紧急任务长了很多而已，但是当该过渡任务迟迟得不到处理，并且已经过期的时候，react就会先处理这个过期的过渡任务，然后再继续调度。具体可以了解react的schedlue模块。 防抖 输入框的内容经常跟防抖节流打交道，但是其本质也是通过setTimeout，只不过控制了render的次数，而且防抖节流也需要人为的控制时间，而使用startTransition就不需要考虑这么多。 transition功能特性 transition顾名思义过度，状态更新的任务一般有两种，一种是紧急更新任务，比如用户交互行为，点击，输入等等。
而另一种则是过渡更新任务，比如上面列表的更新，这种任务的优先级低于紧急更新任务。
startTransition startTransition(fn) 同步执行，但是fn里面的更新会被标记transition的优先级。也就是优先级更低了。
useTransition startTransition只是用来降低优先级的，也就是过渡，但是过渡了多久我们需要一个状态来知道。useTransition就是用来做这个事情的。
const [isPending, startTransition] = useTransition() startTransition(fn) useTransition返回两个值，第一个就是是否正在过渡到控制变量，第二个就是跟startTransition用法一样的，用来降低任务优先级的函数。但任务处于过渡阶段的时候，isPending为true，告诉开发者，目前该任务正在过渡。
useDeferredValue 上述的startTransition和useTransition本质都是将一些任务的优先级降低。
而useDeferredValue可以让状态滞后更新。实现效果类似于transiton，当紧急的任务执行之后，再得到新的状态，而这个新的状态就是deferredValue。
跟useTransition的区别 同：内部实现一样，都是将任务标记为过渡更新任务。
别：
useTransition是将处理一段逻辑，将任务变为过渡任务，useDeferredValue是将原值通过过渡任务后得到新的值，他是产生一个新的状态。其次就是useDeferredValue的更新会更滞后于useTransition，因为内部是使用useEffect来调用startTranstion的。下面原理环节会讲到。 原理 startTransition startTransition的源码实现
他的本质有点类似于17之前的事件更新，通过开关ReactCurrentBAtchConfig.transition
ReactCurrentBAtchConfig.transition默认值是null，再需要更新过渡任务的时候，将其置为{}，这样startTransition里面的函数执行的时候，就会判断ReactCurrentBAtchConfig.transition以此来将其优先级降低。
useTransition mount更新阶段，执行的函数是mountTransition，update阶段执行的函数是updateTransition
如图是mountTransition，本质很简单，就是通过调用mountState产生一个状态，然后通过startTransition绑定默认参数，调用moutnWorkInProgressHook创建hooks对象，跟其他hook链接，最后这个hooks.memoizedState保存的就是startTransition这个函数。
注意这里的startTransition跟上面的startTransition不一样， 如上，则是useTransition返回的第二个参数，本质就是先调用setPending(ture)，然后切换transitiion上下文，让setPending(false)的更新也变成了过渡任务，这样setPending(false)和callback的任务优先级相同，他们会同时处理。
所以useTransition可以看成useState+startTransition
useDeferredValue useDeferredValue本质也是调用了useState+useEffect，通过监听value值的改变，触发useEffect回调函数的更新，再去切换tranition上下文，更新setValue(value)
所以useDeferredValue可以看成：useState+useEffect+startTransition。
看看react如何通过判断transition上下文。 const [data, setData] = useState({}) startTransition(()=&gt;setData({})) 一般startTransition里面函数，存在着触发更新的动作，比如useState的第二个参数setState，他们会创建update，更新优先级，开始调度。具体可以看hooks实现逻辑
所以重点看看产生update时候的优先级的处理，以setState为例子
useState的第二个参数，实际上是调用dispatchSetState函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c5f278700fc3c4f9f4fb886c680aecc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92d97536b79c91bfae94122bbc6d899b/" rel="bookmark">
			MFC更改窗口/对话框的背景颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、添加事件 打开想要改变背景颜色的窗口类的属性，添加WM_CTLCOLOR消息
二、添加代码 向新建的OnCtlColor函数添加6-13行代码，如下所示
HBRUSH 窗口类名::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) { HBRUSH hbr = 基类名::OnCtlColor(pDC, pWnd, nCtlColor); // TODO: 在此更改 DC 的任何特性 switch (nCtlColor) { case CTLCOLOR_DLG: HBRUSH aBrush; aBrush = CreateSolidBrush(RGB(255, 255, 255)); hbr = aBrush; break; } // TODO: 如果默认的不是所需画笔，则返回另一个画笔 return hbr; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16ca4407037e6db008e01e8bd3e64048/" rel="bookmark">
			年底了还没入门？分享下我的自动驾驶与CV算法工程师成长路线图（双十二巨献）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动驾驶是未来出行的趋势，无论是国家层面还是企业层面都投入巨资研发，期望计算机视觉与AI能够改变出行，推动人类社会进步！随之而来的是海量相关算法、开发、测试岗位需求，汽车人接触的从业者大多是机械、电气、自动化专业的同学，相比于计算机科班来说，缺乏系统的学科知识，入门难，进阶更难！一般来说，入门进阶首先要对领域整体技术框架有所了解，正所谓不谋全局者不足以谋一域！有了这个基础，剩下的就是深耕某一块的内容了，老师答疑解惑！
自动驾驶之心知识星球 自动驾驶之心知识星球是首个以自动驾驶技术栈为主线的交流学习社区，这是一个前沿技术发布和学习的地方！我们汇总了自动驾驶感知（分类、目标检测、语义分割、实例分割、全景分割、关键点检测、车道线检测、3D感知、目标跟踪、多模态、多传感器融合等）、自动驾驶定位建图（高精地图、SLAM）、自动驾驶规划控制、领域技术方案、AI模型部署落地等几乎所有子方向的学习路线！除此之外，还和数十家自动驾驶公司建立了内推渠道，简历直达！这里可以自由提问交流，许多算法工程师和硕博日常活跃，解决问题！初衷是希望能够汇集行业大佬的智慧，在学习和就业上帮到大家！
星球目前有哪些成员？ 星球成员主要来自商汤科技、旷视科技、百度、阿里、网易、Momenta、Intel、Nvidia、大疆、上汽、集度、地平线、华为等业界知名公司，以及苏黎世理工、卡耐基梅隆大学、普渡大学、东京大学、香港科技大学、香港大学、清华大学、上海交大、复旦大学、浙江大学、中科大、南京大学、同济大学、上海科技大学、哈工大等国内外知名高校；
知识星球有哪些模块？ CV图文教程：网络结构可视化、算法原理图解；
视频教程：星球内部技术分享视频、相机标定、伯克利深度学习与计算机视觉、百度优达学城、Apollo自动驾驶、Udacity自动驾驶、MIT自动驾驶、Carla自动驾驶仿真等系列视频课程；
日常paper分享：3D检测、多模态、2D检测、分割、车道线、多任务、多目标跟踪、融合、传感器标定、鱼眼感知与模型、VIT、轻量化等；
职位与面经分享：自动驾驶行业职位分享内推、面经分享；
日常问答交流：和嘉宾星主交流领域学术工业最新进展；
主要面向对象 星球创建的初衷是为了给自动驾驶行业提供一个技术交流平台，包括需要入门的在校本科/硕士/博士生，以及想要转行或者进阶的算法工程人员；除此之外，我们还和许多公司建立了校招/社招内推，包括地平线、百度、蔚来汽车、momenta、赢彻科技、集度、滴滴、Nvidia、高通、纵目科技、魔视智能、斑马汽车、博世、纽劢科技、追势科技、寒武纪等！
如果您是自动驾驶和AI公司的创始人、高管、产品经理、运营人员或者数据/高精地图相关公司，也非常欢迎加入，资源的对接与引进也是我们一直在推动的！我们坚信自动驾驶能够改变人类未来出行，想要加入该行业推动社会进步的小伙伴们，星球内部准备了基础到进阶模块，算法讲解+代码实现，轻松搞定学习！
日常讨论
日常分享
星球主要关注方向 0.自动驾驶顶会与公司 星球内部为大家汇总了CVPR、ECCV、IROS、RSS、TPAMI、IV、ICIP等自动驾驶领域顶会和顶刊，以及图森、智加、主线科技、集度、滴滴、纵目、元戎启行、momenta、蔚来小鹏理想等近80家公司介绍（可以内推！）
1.计算机视觉相关数据集 数据集是AI任务的基石，然而大多数数据集都是国外机构开源，数据量较大，下载速度缓慢，这两个缺点导致很多研究人员在数据获取上为难，为此星球内部已经为大家准备了近30种计算机视觉和自动驾驶相关数据集，包括KITTI、Waymo Open Dataset、Lyft L5、COCO、Semantic3D、A2D2数据集、车道线数据集、车牌数据集、行人检测数据集、红绿灯检测数据集等，一键下载；
2.2D/3D标定工具 星球内部为大家汇总了2D检测、3D点云检测、语义分割、实例分割、3D点云分割、视频检测、交互标定、多传感器标定等工具，可以快速适配到自己项目中。
3.基础学习资料 整理了从深度学习数学基础到图像处理、经典计算机视觉算法、Opencv、Pytorch以及C++、Python、GPU和Cuda近50本pdf学习资料！
4. Backbone与Transformer 主要关注常用的轻量化、高性能backbone，以及视觉transformer结构与优化；
5. 2D目标检测 关注anchor-based、anchor-free、one-stage、two-stage、超全YOLO系列、小目标检测、多任务模型、长尾分布、误检消除、难例挖掘、定位精度优化等内容；该模块汇总检测领域的经典综述和论文，从结构、数据增强策略、采样策略、不均衡问题、半监督、知识蒸馏上展开研究；
6. 分割任务 汇总了常见的2D语义分割、实例分割、全景分割以及3D点云分割SOTA算法，并对分割任务中的边缘轮廓分割模糊不细腻问题展开讨论；
7.车道线检测 对基于检测、分割、分类、关键点、曲线预测、多传感器检测、3D车道线SOTA方法进行了汇总，对车道线遮挡、磨损、不连续问题展开了讨论！
8.鱼眼感知 针对鱼眼和全景相机在自动泊车、近域感知上的应用展开，主要包括相机标定、鱼眼全景相机系统、自动泊车系统、环视数据集、鱼眼深度估计、鱼眼目标检测、鱼眼SLAM、语义分割等方向！
9.目标跟踪 针对单目标和多目标跟踪，基于Siamese Network、Tracking-by-detection、传统滤波+关联算法、end2end等方法进行全面展开阐述，后续更会加入变速情况下的跟踪系统；
10.3D目标检测 从点云和多模态数据3D检测任务展开，基于BEV、点、体素、多camera数据的3D检测方案；
11.传感器标定 主要关注自动驾驶领域常见的Camera、Lidar、Radar、IMU之间的离线、在线标定，多相机、多激光雷达之间的标定，自动标定等；
12.多传感器融合 星球内部汇总了数据级融合、目标级融合、特征级融合、弱融合、不对称融合等多种方案！
13.SLAM与高精地图 汇总了单目SLAM、RGB-D SLAM、激光SLAM、高精地图定位方法、自定位方法！以及领域内最常用的高精地图制作方法！
14.模型压缩与轻量化 汇总了模型压缩、裁剪、量化、权值共享、模型加速、知识蒸馏、量化工具等数十篇干货介绍！
15.模型部署 TensorRT、NCNN、Opencv、MNN方案部署检测、分割、关键点、分类模型实战；
16.其它 在感知定位融合之外，还汇总了大量机器人、自动驾驶规划方法，强化学习在运动规划上的应用、V2X技术，以及图像加速CUDA方法等~
日常讨论交流 欢迎加入 欢迎大家扫码加入自动驾驶之心知识星球，我们诚邀前期成员的加入，一起创造一个全技术栈的自动驾驶开发者社区！星球成员的加入平均每天0.4元，欢迎扫码加入一起学习一起卷！
任何疑问欢迎联系汽车人助理，备注方向+昵称：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1f028c537a65777d4e1daa5b343654e/" rel="bookmark">
			chrome浏览器必备5款插件--各个都好使--chrome基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		办公电脑在使用固定期限后，又到了新换电脑的时候，本次新电脑到手后，在浏览器方面依然选择了已经熟悉的chrome浏览器，有一句话说的对，没有插件的chrome浏览器是没有灵魂的。所以在沿用chrome浏览器后，这次也对前期使用的chrome浏览器插件进行了重新的审视和用途的重新划分。 经过选择后，宣传了以下五款必备chrome插件。
Adblock Plus
免费的广告拦截器，在当前互联网环境下的必选插件。对于常见的联盟广告、专项投放广告等内容广告可以做到有效的过滤，有了Adblock Plus 从此有了干净的浏览环境，这个差价谁用谁知道。
crxMouse Chrome 手势
原名:Gestures for Chrome(TM)汉化版.方便,快捷,充分发掘鼠标的所有操作.功能包括:鼠标手势,超级拖曳,滚轮手势,摇杆手势,平滑滚动,标签页列表等.
从上面的介绍就指导，有了crxMouse插件，可以利用鼠标快速对标签、内容进行操作，真正的浏览圣器。使用crxMouse相当于在冲浪中有了得心应手的冲浪板，相当于划龙舟比赛中有了优秀的船桨。
Infinity 新标签页(Pro)
百万用户选择的新标签页和快速拨号，自由添加网站图标，云端高清壁纸，快速访问书签、天气、笔记、待办事项、扩展管理与历史记录。使你的主页和开始页更加美观和易用
又是一个不得不推荐的chrome插件，可以更好的解决工作过程中经常使用的网址导航功能，当然在这个功能上，结合Infinity插件的壁纸轮换功能，可以在每次打开新标签时都能看到不同的景色、更换不同的心情。
Proxy SwitchySharp
轻松快捷地管理和切换多个代理设置。基于 "Proxy Switchy!" 和 "SwitchyPlus" 开发。
这个chrome插件，不适合在进行更多的介绍，懂的都知道，不懂的请自选GG。
当然，其实还有该软件的升级版本：SwitchyOmega，可以从github进行下载
Tampermonkey
神级chrome插件，油猴；与其说是一个chrome插件，用另外一个词汇来表达可能会准确一些：chrome插件管理工具；利用Tampermonkey插件，可以管理更多的Tampermonkey脚本，每个脚本都可以实现特定的一些功能。
官网地址：Tampermonkey • Home
推荐油猴脚本网站：Greasy Fork - 安全、实用的用户脚本大全
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/116cac6d66624feb6037d2a8822255f9/" rel="bookmark">
			深度学习中有关网络中的参数量(param)计算。附录有浮点计算量(FLOPs)的链接。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 网络中的参数量(param)和浮点计算量(FLOPs)的计算一、网络中的参数量(param)是什么？浮点计算量(FLOPs)是什么？二、如何计算网络中的参数量(param)网络中的参数量(param)的计算卷积层：计算公式： 池化层:全连接层:CONV-&gt;FC 及计算公式FC-&gt;FC 及计算公式 代码展示 附加：参数和模型显存\模型尺寸的关系总结及浮点计算量FLOPs的指引 网络中的参数量(param)和浮点计算量(FLOPs)的计算 可以在我都模板仓库的Utils文件夹中查看具体有关参数量(param)和浮点计算量(FLOPs)的计算代码。
一、网络中的参数量(param)是什么？浮点计算量(FLOPs)是什么？ 网络中的参数量（param）对应与空间Space概念，及空间复杂度。浮点计算量(FLOPs)对应与时间Time概念，对应于时间复杂度。 即，网络参数量（param）和显存密切相关；浮点计算量(FLOPs)和GPU的计算速度相关。
二、如何计算网络中的参数量(param) 网络中的参数量(param)的计算 网络中参数计算需要分为
卷积层： 需要关注的参数为(kernel_size,in_channel,out_channel)
计算公式： 完全版： c o n v _ p a r a m = ( k e r n e l _ s i z e ∗ i n _ c h a n n e l + b i a s ) ∗ o u t _ c h a n n e l conv\_param = (kernel\_size*in\_channel+bias)*out\_channel conv_param=(kernel_size∗in_channel+bias)∗out_channel，默认 b i a s = 1 bias=1 bias=1，out_channel是filter(代表卷积核个数)，且每个卷积核都有对应的bias。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/116cac6d66624feb6037d2a8822255f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02e28afa996c144da6a34b7dd4e00463/" rel="bookmark">
			MySOL(狂殴26K字只为博君一赞)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
MySql三层结构​编辑
SOL语句分类
​编辑
创建数据库
备份与恢复数据库
创建表
​编辑
数据类型
​编辑
数值细节：
字符串细节：（重要）
日期类
一些常用的指令：
表的增删改查（包含去重函数distinct）
Order by排序函数的使用
count（） 、sum （）、AVG（）、Min（）、Max（）的使用
group by + having ——分组函数
字符串函数：
charset——返回字符编码
concat——拼接字符串
Inster（string，substring）
UCASE(string) 将字符串转成大写
LCASE(string) 将字符串转成小写
Replace——替换
Strcmp（‘str1’，‘str2’）——字符串比较，比较原理是str1与str2逐个比较字符。
Substring（str，postion，length）——很有用的这个
关于数学的一些函数
ABS——取绝对值函数
BIN——十进制转二进制
Celling(num)——向上取整
Floor（num）——向下取整
CONV(num，当前进制，目标进制)——进制转换函数
Format(num，i)——保留i位小数（很有用的哦），按四舍五入机制
Rand（seed）；——随机数[0,1)
时间函数
加密函数
流程控制语句
查询加强
where函数
order by
分页查询(很重要，开发一定会用到)
LIMIT int strat，int rows函数——用于分页查询
​编辑
多表查询（重要）
自连接(重要)
子查询（重要）
all和any的使用
多列子查询 练习
复制表 与 去重
和并查询
左外连接和右外连接
主键的细节
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02e28afa996c144da6a34b7dd4e00463/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fad94546269eadf183117654a278412b/" rel="bookmark">
			Python GUI界面点击按钮后显示未响应卡住无法移动的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python GUI界面点击按钮后显示未响应卡住无法移动的解决办法 问题原因解决方法总结 问题 在PythonGUI程序下，当我们使用点击按钮执行事件时，如果执行的函数是比较耗时的操作或者是长时间运行的事件，那么再次点击界面上其他按钮时就会卡死，提示未响应。 _加粗文本
图片: 如图所示
原因 图形化界面的本质是一个循环，主进程执行耗时等待通过不断刷新界面来实现事件的实时响应和更新，如果有一个事件耗时过长，就会导致循环阻塞，界面无法刷新，窗口就会无响应。
比如单次执行耗时过长或for循环或while死循环
下面展示一些 内联代码片。
def create_ftp(): #搭建ftp服务 #功能实现代码略 # 按钮 btn1 = Button(f1, text='开启', command=create_ftp, style="BW.TButton") 上述代码其中create_ftp函数就是长时间执行的事件，在ftp服务开启后，不断循环运行，所以点击按钮1后界面就会卡住显示未响应。
解决方法 使用Python的Threading库，定义一个生成子线程的函数，并由子线程来触发事件
我们可以通过调用一个生成子线程的函数，生成子线程并由子线程完成事件，所以按钮的command参数应该传入这个线程函数，所以我们可以下面这样做
# 定义子线程函数start_thread def start_thread(): # 让create_ftp函数在子线程中运行 thread = threading.Thread(target=create_ftp, args=()) # 下面是设置守护线程：如果在程序中将子线程设置为守护线程，则该子线程会在主线程结束时自动退出 thread.setDaemon(True) thread.start() # 启动线程 def create_ftp(): #搭建ftp服务 代码略 # 这时按钮绑定我们定义的子线程函数 btn1 = Button(f1, text='开启', command=start_thread, style="BW.TButton") 使长时间运行的事件在后台以子线程的方式运行，这样就不会影响我们主线程的循环了。
总结 当按钮事件耗时较长或者需要一直循环运行时，我们可以在原来的“按钮-&gt;事件”之间插入子线程，变成“按钮-&gt;子线程”，“子线程-&gt;事件”，从而实现子线程处理事件。
注：本文转自知乎hwj会幸福 ：原文链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c1a03f71c9e8e65eb35d01b5d74947e/" rel="bookmark">
			nacos注册中心和配置中心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nacos注册中心和配置中心 nacos 一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。
nacos官方文档：https://nacos.io/zh-cn/
相关概念：https://nacos.io/zh-cn/docs/architecture.html
nacos是AP架构,注重可用性和分区容错性，java语言，集群架构的话通过nginx做负载均衡，然后节点之间互相同步数据
本文演示在springcloud中使用nacos
版本对应关系 https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E
nacos注册中心 官方基本示例，和属性介绍：https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-discovery
2.3 核心功能
Nacos Discovery 服务注册：Nacos Client会通过发送REST请求的方式向Nacos Server注册自己的服务，提供自身的元数据，比如ip地址、端口等信息。Nacos Server接收到注册请求后，就会把这些元数据信息存储在一个双层的内存Map中。
服务心跳：在服务注册后，Nacos Client会维护一个定时心跳来持续通知Nacos Server，说明服务一直处于可用状态，防止被剔除。默认5s发送一次心跳。
服务同步：Nacos Server集群之间会互相同步服务实例，用来保证服务信息的一致性。 leader raft
服务发现：服务消费者（Nacos Client）在调用服务提供者的服务时，会发送一个REST请求给Nacos Server，获取上面注册的服务清单，并且缓存在Nacos Client本地，同时会在Nacos Client本地开启一个定时任务定时拉取服务端最新的注册表信息更新到本地缓存
服务健康检查：Nacos Server会开启一个定时任务用来检查注册服务实例的健康情况，对于超过15s没有收到客户端心跳的实例会将它的healthy属性置为false(客户端服务发现时不会发现)，如果某个实例超过30秒没有收到心跳，直接剔除该实例(被剔除的实例如果恢复发送心跳则会重新注册)
主流的注册中心
CAP C 一致性 A可用性 P 分区容错性
项目依赖 &lt;!--nacos-服务注册发现--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; 配置项 官网 ：https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-discovery#%E5%85%B3%E4%BA%8E-nacos-starter-%E6%9B%B4%E5%A4%9A%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9%E4%BF%A1%E6%81%AF
在spring配置文件中配置项，服务端和客户端大致相同
# 应用名称 （nacos会将该名称当做服务名称） , spring.application.name: nacos-producer spring: cloud: nacos: server-addr: 61.171.5.6:30848 # 需要注意的是客户客户端会在此端口+1000的基础上获取通信端口，具体参考nacos安装中的几个端口 discovery: # service: service-consumer #注册的服务名称，不配置，默认取spring.application.name # register-enabled: false #一般会注册成服务提供者和消费者，如果不想成为服务提供者，这里设置false username: nacos # 服务端没有开启认证，这个也不需要 password: nacos # group: nacos-producer1 # 默认使用DEFAULT_GROUP作为分组名称 #service: nacos-producer1 # 默认使用spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c1a03f71c9e8e65eb35d01b5d74947e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4b9056511e1d8f64f533a44b9df6441/" rel="bookmark">
			机器学习笔记：第2章 模型评估与选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、经验误差与过拟合
经验误差/训练误差：学习器在训练集上的误差。
泛化误差：学习器在新样本上的误差。
过拟合：经验误差小但是泛化误差大，则发生过拟合现象。
二、评估方法
模型的选择通常选择泛化误差小的模型，但是泛化误差无法直接获取，因此用测试误差近似泛化误差进行模型评估。 1 划分数据集为训练集和测试集的方法 （进行模型泛化误差的近似估计）
（1）留出法 留出法：将数据集D划分为两个互斥的数据集S和T，分别为训练集和测试集 。满足分层采样，多次划分取平均。一般取数据集的2/3--4/5作为训练集。
（2）交叉验证法
将D划分为k个互斥的子集，每次使用k-1个子集的并集作为训练集S，剩余1个为测试集，从而获得k组训练集/测试集，进行k次训练和验证，最终返回k次的平均值 。
（3）自助法 基于自助采样法，每次从m个样本的数据集D中，进行有放回的随机采样 1个样本拷贝到d中，进行m次操作后得到含有m个样本的d作为训练集，d中未出现的D中的样本作为测试集，评估模型的泛化误差。初始数据量较少，难以划分训练集和测试集时该方法较好。
三、性能度量 性能度量：衡量模型泛化能力的评价标准。
回归任务常用性能度量：均方误差。
分类任务：错误率、精度、查准率、查全率
1 错误率与精度
错误率：E=a/m;a为m个样本中分错的个数
精度：1-错误率
2 查准率和查全率
查准率：亦称召回率。模型预测正例正确的样本数TP（真正例），占模型预测为正例的样本数（TP+FP）的比例：P=TP/(TP+FP)
查全率：模型预测正例真确的样本数TP，占模型总体样本中正例（TP+FN）的比例：P=TP/(TP+FN)
查准率和查全率是一对矛盾的量，一般来说，一个高则另一个低。
PR曲线：查准率和查全率构成的曲线，若一个学习器A的PR曲线包住学习器B的PR曲线，则可断言学习器A的性能优于B。
F1度量：F1是查准率和查全率的调和平均：F1=2×P×R/(P+R)=2×TP/(样例总数+TP-TN）
3 ROC 与AUC
很多学习器为测试样本产生一个实值或概率预测，然后将预测值与分类阈值进行比较，大于阈值为正例，小于该阈值为反例。可以根据预测值将测试样例排序，排在最前面的为最可能是正例的样本，分类过程就相当于在这个排序中以某个截断点将样本分为正反两部分。
ROC曲线：纵轴为真正例率，横轴为假正例率
真正例率：TPR =TP/(TP+FN) 假正例率：FPR=FP/(TN+FP)
AUC=1-Lrank;ROC曲线与轴围成的面积；Lrank为正反例排序损失
4 代价敏感错误率与代价曲线
为权衡不同错误造成的不同损失，可为错误赋予非均等代价。
代价曲线：横轴取值[0-1]的正例概率代价，纵轴为取值[0-1]的归一化代价。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a2711838b8f0f7bd063bfdf337685f2/" rel="bookmark">
			vits官方gituhb项目--模型构建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在完成VITS论文学习后，对github上的官方仓库进行学习，帮助理解算法实现过程中的一些细节；仓库代码基于pytorch实现，链接为https://github.com/jaywalnut310/vits。本笔记主要针对项目中模型构建部分代码进行注释解析，主要涉及仓库项目中的model.py、modules.py、attentions.py文件。
文章目录 model.pymodules.pyattentions.py model.py 本文件基于各个小模块，对整个VITS的各个一阶模块进行定义，最后集成为多周期判别器/MultiPeriodDiscriminator和生成器/SynthesizerTrn，从训练方式来讲是使用了对抗训练，所以要同时训练判别器和生成器，而生成器，主体是基于VAE的架构，其中又涉及到Flow；特别是本文提出的随机时长预测器，也是一个基于VAE架构，又涉及Flow的一个模块。在VAE和FLOW中涉及大量公式推导。对于随机时长预测器的代码，最好对应论文补充材料中的B.3部分中的结构图对比学习，更加直观；随机时长预测器应用的变分数据增广和变分反量化，可参考论文VFlow和Flow++。具体代码如下：
import copy import math import torch from torch import nn from torch.nn import functional as F import commons import modules import attentions import monotonic_align from torch.nn import Conv1d, ConvTranspose1d, AvgPool1d, Conv2d from torch.nn.utils import weight_norm, remove_weight_norm, spectral_norm from commons import init_weights, get_padding # 基于flow的vae架构，优化的是最大似然估计，是学习一个分布；推理时，是从分布中采样音素的持续时间，从而具有随机性，只使用基于flow的解码器预测时长 class StochasticDurationPredictor(nn.Module): def __init__(self, in_channels, filter_channels, kernel_size, p_dropout, n_flows=4, gin_channels=0): ''' @param in_channels:输入的维度，时长预测器的输出是文本编码器后的隐向量h_{text} @param filter_channels: @param kernel_size: @param p_dropout: @param n_flows: @param gin_channels: ''' super().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a2711838b8f0f7bd063bfdf337685f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3642e775d142dd01f631b45fd1813724/" rel="bookmark">
			哥德巴赫猜想（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 （洛谷）P1304 哥德巴赫猜想 #include&lt;stdlib.h&gt; #include&lt;stdio.h&gt; #include&lt;math.h&gt; int main(){ int judge_prime(int n); int n; int i,j,k; scanf("%d",&amp;n); for(i=4;i&lt;=n;i+=2){ for(j=2;j&lt;=n/2;j++){ if(judge_prime(j)&amp;&amp;judge_prime(i-j)){ printf("%d=%d+%d\n",i,j,i-j); break; } } } return 0; } int judge_prime(int n){ //是素数返回1不是返回0 int i,flag=1; for(i=2;i&lt;=sqrt(n);i++){ if(n%i==0){ flag = 0; return flag; } } return flag; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/416d8b2fb5022b5a7a856fd0c9acc0ee/" rel="bookmark">
			Ubantu中用户相关操作(创建用户、设置密码、切换用户、修改用户信息、附加组、删除用户)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 创建用户 【创建后会立即让设置密码】 命令说明useradd创建(添加)用户 useradd命令选项:
选项说明-m自动创建用户主目录,主目录的名字就是用户名-g指定用户所属的用户组，默认不指定会自动创建一个同名的用户组 创建用户效果图:
查看所有用户信息的文件效果图:
说明:
useradd 命令的使用需要使用管理员权限，前面需要加上 sudo创建用户如果不指定用户组，默认会自动创建一个同名的用户组查看用户是否创建成功，可以查看/etc/passwd这个文件查看用户组是否创建成功，可以查看/etc/group这个文件 passwd文件中的每项信息说明,以root:x:0:0:root:/root:/bin/bash为例:
第一个：用户名第二个：密码占位符第三个：uid, 用户id第四个：gid, 用户所在组id第五个：用户描述, 可选，第六个：用户的主目录所在位置第七个：用户所用 shell 的类型，一般由bash或者sh，默认不设置是sh类型 group文件中的每项信息说明, 以laowang:x:1001:为例:
第一个：用户组名第二个：用户组密码占位符，一般Linux系统的用户组都没有密码的第三个：组id id命令查看用户信息:
命令说明id查看用户信息 id命令效果图:
每项信息说明:
uid=1001(laowang) gid=1001(laowang) 组=1001(laowang)
第一个: uid 表示用户id第二个: gid 表示用户组id第三个: 组 表示用户所在的用户组 2. 设置密码 给其它用户设置密码，需要使用: sudo passwd 用户名
3. 切换用户 命令说明su切换用户 语法格式: su - 用户名
切换用户效果图:
在laowang用户使用sudo -s效果图:
解决办法:
给laowang用户设置一个sudo附加组， 需要使用usermod修改用户信息 【新用户不能使用sudo -s 需要修改用户信息】 4. 修改用户信息 命令说明usermod修改用户信息 usermod选项:
命令说明-G设置一个附加组 【可以理解为干爸】-g修改用户组 【增加附加组要在已有sudo权限的用户中添加】
usermod命令效果图:
设置附加组sudo以后，在sudo -s切换到管理员用户效果图:
5. 扩展: 删除附加组 命令说明gpasswd添加和删除附加组信息 gpasswd命令选项: 【-a -d 的使用方法是一样的】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/416d8b2fb5022b5a7a856fd0c9acc0ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d531e4bf75be8c56b7bc76814f8a7680/" rel="bookmark">
			Git安装包（window64版本，附有下载教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装包：
官网下载：Git - Downloading Package
官网下载太慢，很多时候会因为网络问题下载失败。
安装包提供：
https://download.csdn.net/download/a1598452168YY/87263952
下载步骤：
下载流程一直点“Next”，保持默认就可以了， 防止出错，不然万一放在了中文路径下，或者其他地方到时候找不到路径或者出错就不好卸了。
或者想看下载详细步骤请看：（转载）：
Git 的安装教程（详解每个步骤）_Passerby_Wang的博客-CSDN博客_安装git
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78ac48beee8b4d0398f15ed27ee89da5/" rel="bookmark">
			手把手教你实现printf函数（C语言方式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在日常的嵌入式开发过程中，常常会用到格式化输出的功能。比如在LCD屏幕上，显示需要的字符，如果没有格式化输出，用起来将会是十分麻烦。本文运用变参函数的知识，提供一种实现printf的格式化输出的实现方法供大家参考。
实现思路 通过一个个读取需要打印的字符，如果遇到格式化输出的字符，则根据格式化规则，用变参函数的方式取读取到参数，然后将参数拆解输出出来。
参考工程 使用VS17编译的工程：代码打包下载
主要难点为变参函数，下面介绍变参函数。
变参函数学习 1. 定义 即：函数数目可变的函数。
变参函数原型 type VarArgFunc(type FixedArg1, type FixedArg2, …); 参数分两部分：固定参数+数目可变参数。
固定参数：至少一个。
可变参数： 大于等于0个。使用“…”表示。
2. 变参函数举例 printf（及其家族），原型：
int printf(const char* format, ...); 实际调用形式：
printf("string"); printf("%d", i); printf("%s", s); printf("number is %d, string is:%s", i, s); 3.实现原理 使用到的宏： 需要#include &lt;stdarg.h&gt;
C调用约定下可使用va_list系列变参宏实现变参函数，此处va意为variable-argument(可变参数)。
val_list: 原型：
type va_arg(va_list argptr, type); 是在C语言中解决变参问题的一组宏，用于获取不确定个数的参数。
va_start: 原型：
void va_start(va_list argptr,last_parm); 读取可变参数的过程其实就是在栈区中，使用指针,遍历栈区中的参数列表,从低地址到高地址一个一个地把参数内容读出来的过程。实现功能类似变参的初始化。
// vc 6.0定义 #define va_start(ap,v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) ) //ap 为val_list变量。v为最后一个固定参数地址 va_arg： 宏定义：type va_arg (va_list ap, type)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78ac48beee8b4d0398f15ed27ee89da5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/182/">«</a>
	<span class="pagination__item pagination__item--current">183/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/184/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>