<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b608bffc1b90453994a2bdab1dfb4c59/" rel="bookmark">
			Python&#43;Django毕业设计学生信息管理系统（程序&#43;LW&#43;部署）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
SSM + mybatis + Maven + Vue 等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目 6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末)
3.1可行性研究 3.1.1技术可行性分析 经过大学四年的学习，已经掌握了JAVA、Mysql数据库等方面的编程技巧和方法，对于这些技术该有的软硬件配置也是齐全的，能够满足开发的需要。
学生信息管理系统采用的是Mysql作为数据库，可以绝对地保证数据的安全；可以与Mysql数据库进行无缝连接。
所以，学生信息管理系统在技术上是可以实施的。
3.1.2经济可行性分析 本学生信息管理系统是作为毕业设计自己开发的，所以产生的费用微乎其微，系统建成之后可能会为今后的学生信息管理提供便利，并且系统完成之后产生的维护费用也不大。综合计算，所有的开支都不大，所以学生信息管理系统在经济上是不存在问题的。
3.1.3运行可行性分析 运行可行性是指评价和估计新的系统（即学生信息管理系统）给已经存在的系统带来的影响和产生的后果，如工作环境等，还要分析在指定时间内能否按期完成指定的系统开发任务等。
当前，信息化技术已经相当完善，工具之间的整合非常方便。通过框架编程的学习，对框架的使用规则已经掌握，各个功能模块之间的编写、测试和维护，使用Tomcat服务器可以实现系统的B/S结构，所以在运行上是可行的。
综上所述，本学生信息管理系统的开发在技术上、经济上和运行上都是完全可行的。
3.2系统现状分析 系统使用用户的数量直接决定了用户信息管理者的工作量，毫无疑问，管理者的工作量较大较繁琐。通过总结出系统当前对学生管理的工作状态得以下分析：
统筹规划，如果系统在信息化管理中不够全面，缺少综合性、系统性、整体性，那不可避免的需要投入大量人力物力来规划整理信息。引入信息化管理方式无疑可以达到节省信息管理成本的目的，不仅减少资源浪费还可以使学生信息管理变得井井有条，成为市场竞争中的一大优势。
要循序渐进，做事不能心急，一步一个脚印，都不可能一步到位，就算信息管理系统也一样，要让系统发挥最大效率还是应该多调研，多听取用户和管理者的意见，并进行必要的统筹规划，有组织有目的地设计系统功能，团结各个部门发挥主观能动性。
(1)信息安全措施不到位
隐私权神圣不可侵犯，这是中华人民共和国宪法赋予我们的权利，人和人都不能侵犯我们的正当权益，而网络用户信息管理存在极大安全隐患，信息泄露的案列不在少数，加强信息安全措施是完善网络信息管理过程中不可避免的一环。
(2)资源不能充分共享
资源共享是网络的一大特点，没有共享就没有社交，网络也就失去了他应有的魅力，如果能够实现用户信息共享，无疑对于用户的发展存在不可或缺的帮助。
(3)现有系统可扩展性不高。
如今科学技术发展飞速，随着而来的就是技术更新，那势必会给软件更新带来挑战，因此，系统必须具备良好的开放性和可扩充性，为了不落后于时代，这是必备特色之一。
3.3功能需求 需求分析是指详细的分析要解决的问题，弄清楚要解决的问题的要求，最终达到一个什么样的结果。需求分析的最终任务就是对即将要开发的系统的功能、性能等方面进行定义。
学生信息管理系统是一个管理系统，为了宣传的需要，为了给学生和教师提供方便快捷的服务，从而设计了学生信息管理系统。管理员可以通过这个系统把学生信息发布出去，可以方便教师和学生快速地了解最新动态，也可以从中获得多样化的优质服务。
学生信息管理系统的主要包括了管理员，学生和教师三个角色。
学生和教师进入系统可以实现首页，个人中心，通知公告管理，班级信息管理，课程信息管理，学生选课管理，课程成绩管理等功能。
管理员的主要功能包括首页，个人中心，通知公告，学生管理，教师管理，班级信息管理，课程分类管理，课程信息管理，学生选课管理，课程成绩管理等。
3.4系统设计规则与运行环境 软件系统的优劣很大程度上是由系统设计的完善与否决定的。世间万物都必须遵循生老病死的法则，这是大自然的规则不能违反，软件设计也一样需要遵循系统设计规则。因此，在设计过程中必须遵循系统设计规则。
规则如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b608bffc1b90453994a2bdab1dfb4c59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d1576ffb1f9f60d6cc899e26a46c389/" rel="bookmark">
			MYSQL学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
MySQL 1.1为什么要学数据库 1、被迫需求：存数据
2、数据库是所有软件体系中最核心的存在
1.2 什么是数据库 1、 数据库（DBDataBase)
概念：数据仓库，软件，安装在操作系统上，能存500万数据
作用：存贮数据，管理数据
1.3 数据库分类 关系型数据库： MySQL,Oracle,sqlServer,DB2,SQLite
通过表和表之间，行和行之间的关系进行数据的存储
非关系型数据库： Redis,MongDB
以对象存储 ，通过对象的属性来就 决定
1.4 DBMS数据库（数据库管理系统） 数据库的管理软件，科学有效的管理我们的数据。维护和获取数据；
MySQL,数据库管理系统
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hNGqRKsZ-1672974931995)(C:\Users\hedada\AppData\Roaming\Typora\typora-user-images\image-20211119192043588.png)]
1.5 MySQL简介 MySQL是一个关系型数据库管理系统
MySQL是一个精巧的SQL数据库管理系统，而且是开源的数据管理系统。由于它的强大功能、灵活性、丰富的应用编程接口（API）以及精巧的系统结构。
MySQL是一个真正的多用户、多线程SQL数据库服务器
MySQL 主要目标是快速、健壮和易用
1.6 连接数据库 命令行链接
mysql -uroot -proot 连接数据库
update mysql.user set authentication_string=password('root') where user='root' and Host ='localhost'; --修改用户密码
flush privileges; —刷新权限
所有的语句都使用；结尾
show databases; --查看所有数据库
mysql&gt; use school --切换数据库
Database changed
show tables; --查看数据库中所有的表
describe student；–显示数据库中所有表的信息
create database westos;–创建一个数据库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d1576ffb1f9f60d6cc899e26a46c389/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/019fd48e5dabf6a695b2cdd0afd37bb4/" rel="bookmark">
			RabbitMQ 消息确认机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ 消息确认机制 为了保证消息从队列可靠的到达消费者，RabbitMQ 提供了消息确认机制（Message Acknowledgement）。消费者在订阅队列时，可以指定 autoAck 参数，当 autoAck 参数等于 false 时，RabbitMQ 会等待消费者显式地回复确认信号后才从内存（或者磁盘）中移除消息（实际上是先打上删除标记，之后在删除）。当 autoAck 参数等于 true 时，RabbitMQ 会自动把发送出去的消息置为确认，然后从内存（或者磁盘）中删除，而不管消费者是否真正地消费到了这些消息。
采用消息确认机制后，只要设置 autoAck 参数为 false，消费者就有足够的时间处理消息（任务），不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为 RabbitMQ 会一直等待持有消息直到消费者显式调用 Basic.Ack 命令为止。
当autoAck 参数为 false 时，对于 RabbitMQ 服务器端而言，队列中的消息分成了两部分：一部分是等待投递给消费者的消息；一部分是已经投递给消费者，但是还没有收到消费者确认信号的消息。如果 RabbitMQ 服务器端一直没有收到消费者的确认信号，并且消费此消息的消费者已经断开连接，则服务器端会安排该消息重新进入队列，等待投递给下一个消费者（也可能还是原来的那个消费者）。
RabbitMQ 不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息连接是否已经断开，这个设置的原因是 RabbitMQ 允许消费者消费一条消息的时间可以很久很久。
RabbitMQ 的 Web 管理平台上可以看到当前队列中的 “Ready” 状态和 “Unacknowledged” 状态的消息数，分别对应等待投递给消费者的消息数和已经投递给消费者但是未收到确认信号的消息数。
在rabbitmq中，我们可以通过持久化数据，解决rabbitmq服务器异常的数据丢失问题。生产者将消息发送出去之后，消息到底有没有到达 rabbitmq服务器，默认的情况是不知道的，有两种方式：事务机制和confirm 模式 可以做到消息的确认。
事务机制 txSelect: 用户将当前的channel设置成transaction模式
txCommit：用于提交事务
txRollback：回滚事务
当我们使用txSelect提交开始事务之后，我们就可以发布消息给Broke代理服务器，如果txCommit提交成功了，则消息一定到达了Broke了，如果在txCommit执行之前Broker出现异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过txRollback方法进行回滚事务了。
消息生产者：Send /** * 类描述： * 事务机制，消息生产者 * @author cfl * @version 1.0 * @date 2022/10/10 17:07 */ public class Send { public static final String QUEUE_NAME = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/019fd48e5dabf6a695b2cdd0afd37bb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65ca0b83914258bf268aeeefecb3da99/" rel="bookmark">
			ViLT:Vision-and-Language Transformer Withoout Convolution or Region Supervision
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ViLT:Vision-and-Language Transformer Withoout Convolution or Region Supervision 如今，在多模态领域，同样采取先预训练，再进行微调的方式。
解决问题 视觉和语言预训练 (VLP) 提高了各种联合视觉和语言下游任务的性能。之前的工作发现，在视觉方面网络的模型越复杂越好，最终的结果就会越好。即当前的 VLP 方法严重依赖图像特征提取过程，其中大部分涉及区域监督（例如，对象检测）和卷积架构（例如，ResNet）。
作者认为此前的工作存在以下两个问题：
(1) 效率/速度方面存在问题，简单地提取输入特征需要比多模式交互步骤更多的计算；
(2) 表达能力，因为它是视觉嵌入器及其预定义视觉词汇表达能力的上限。仅仅用一个预训练好的模型去抽取特征，模型的表达能力是受限的，由于不是端到端的学习，可能抽取的特征非最优解。
为了解决上述问题，作者提出了一个极简化的模型。
为什么要选择目标检测？ 目标检测是天然的离散化的过程，并且有明确的语义信息，这正是transformer所需要的。下游任务往往和物体有直接的联系，即对物体有依赖性。
虽然大部分数据集可以事先通过目标检测抽取特征。事实上，速率是个十分严重的问题，因为当你在真实世界中，去做这种应用的时候，数据是每时每秒在实时生成的，对于新数据，再做推理的时候，就没有那么多时间来做这种目标检测。
所以，重心就转移到怎么设计一个更轻量更简单的图像特征抽取的方法。 研究方法和创新点 ViLT 是迄今为止最简单的视觉和语言模型架构，因为它委托转换器模块提取和处理视觉特征，而不是单独的深度视觉嵌入器。这种设计本质上会带来显着的运行时间和参数效率。第一次，我们在不使用区域特征或一般的深度卷积视觉嵌入器的情况下，在视觉和语言任务上取得了出色的表现。此外，我们首次凭经验表明，在 VLP 训练方案中前所未有的全词屏蔽和图像增强进一步推动了下游性能。 模态融合方法 single-stream
将image和text输入直接concatenation起来。
dual-stream
对于image和text，各自先各自将自己的输入进行一些处理，充分挖掘单独模态里包含的信息，然后再去在之后的某一个时间点做一个融合。
特征抽取 region featuresgrid featurespatch projection 流程和模块 single-stream
损失函数 Image Text Matching——负对数似然损失+图像文本对齐分数
Masked Language Modeling
预训练数据集 实验结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9937cae4ab5a1b2d0b3562f25087fe66/" rel="bookmark">
			LXMERT:Learning Cross-Modality Encoder Representations from Transformers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 LXMERT:Learning Cross-Modality Encoder Representations from Transformers 视觉-语言推理需要理解视觉概念、语言语义，最重要的是，理解两种模态之间的一致性和关系。
解决问题 针对视觉和语言模态对的大规模预训练和微调的模型。
研究方法和创新点 作者以BERT模型为基础，同时进一步适应于跨模态场景。该跨模态模型专注于学习视觉和语言的交互，特别是对于单个图像及其描述性句子的表示。它由三个Transformer编码器组成，一个对象关系编码器、一个语言编码器和一个跨模态编码器。为了更好的学习视觉和语言之间的跨模态对齐，用五个不同的任务来预训练模型。(1) masked cross-modality language modeling, (2) masked object prediction via RoI-feature regression, (3) masked object prediction via detected-label classification, (4) cross-modality matching, and (5) image question answering。
流程和模块： 模型输入：图像及其相关句子。其中每个图像都表示为一个对象序列，每个句子都表示为一个单词序列。
输入嵌入层 输入嵌入层将输入（图像和句子）转换为两个特征序列（单词句子嵌入和对象图像嵌入）。
编码器 语言编码器、对象关系编码器、交叉模态编码器
训练和损失函数 1、Language Task:Masker Cross-Modality LM掩蔽的跨模态语言模型。
2、Vision Task:Masked Object Prediction——负对数似然函数
RoI-Feature Regression——L2loss
Detected-Label Classification——cross-entropy loss
3、Cross-Modality Tasks
Cross-Modality Matching
Image Question Answering(QA)
预训练数据集 实验结果 消融实验 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6348f915d55e09c760e6bb88ef1b967c/" rel="bookmark">
			电脑录屏怎么把声音录进去，两招教你把声音录进去
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无论是在学习、办公、娱乐都需要用到录屏功能，很多人在录完视频后都会出现视频没有声音的情况。那电脑录屏怎么把声音录进去？方法有多种，比如可以使用系统自带的录屏功能录制视频，再比如也可以选择一款性价比高的录屏软件来录制。
接下来，就由小编来为各位分别演示操作一下。
电脑录屏带声音方法1：使用系统自带录屏功能 不知道大家在需要录屏时会选择什么样的录屏软件来录制。其实，可以直接使用电脑系统自带的录屏来录制视频。那电脑自带的录屏有声音吗？当然有啦；在电脑自带的录屏界面，根据个人调整音量即可录制出带声音的视频。
步骤1：打开电脑系统设置，依次将【游戏】、【Xbox Game Bar】功能打开。
步骤2：使用快捷方式【Win＋G】进入到电脑录屏界面。在界面上根据个人需求，调整【音频】音量的大小，即可录制出带声音的视频。
电脑录屏带声音方法2：使用可以录音的录屏软件 虽然电脑的录屏功能可以录制出带声音的视频，但是它无法录制电脑桌面；当你需要录制时长比较久的，视频就会很大，可能影响保存与使用。
想要录制电脑桌面或者更多自定义区域选择的朋友，可以试试这款录屏软件来录制。这款软件除了可以全屏录制电脑桌面外，也可以自定义录制区域。此外，在录制视频前，还可以对【视频格式】【视频帧率】【视频分辨率】进行设置。可以录制电脑内部声音，也可以录制麦克风声音。
录屏怎么把声音录进去？接下来，小编就跟大家分享这款软件是如何把声音录制进去的，具体操作步骤如下：
步骤1：在浏览器搜索这款软件，并将它安装在电脑上。
备注：软件支持Windows和Mac两个系统使用。软件默认安装在C盘，可以通过自定义将软件安装在其他磁盘。
步骤2：如果有更改录制视频参数的需求，可以在“视频录制”模式界面点击“输出设置”功能；然后，根据录制实际调整视频编码器、格式、清晰度、音频、鼠标、摄像头等参数。
步骤3：在录制前，可以选择全屏录制和自定义录制区域画面。如果有真人出境的需求，还可以将“摄像头”开启。屏幕录屏为什么没声音？那是因为在录制时，没有将声源开启；这里的“扬声器”指的是录制电脑内部声音。“麦克风”为电脑录制外界声音。可以根据个人录制需求，将它们开启并调整音量。同时，可以点击“麦克风”旁边的“三角形”图标，对“麦克风”进行降噪、增强以及试听等功能。然后，点击“REC”即可开始录制带声音的视频。
步骤4：停止录制后，将会跳转到“预览窗口”；可以在“预览窗口”观看带声音的视频。确认视频没有问题，可以通过点击“完成”将视频保存。将会弹出“历史记录”，在“历史记录”列表上可以查看以往录制的视频；此外，有视频处理的需求，可以在“历史窗口”使用“媒体工具”进行压缩、剪辑等处理。
想要录制有声音的视频方法很简单，只需要在录制时将“声音”开启，就录制出带声音的视频了。以上就是今天小编给大家分享的两个录屏怎么把声音录进去的方法啦。想要降低录制出的视频没有声音风险，可以选择更加好的录屏软件来录制视频。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a73ddd0a4a6f83df7dc4eaa811562b0/" rel="bookmark">
			详解KEIL的分散加载文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用分散文件指定栈和堆 ARM C 库提供了该函数的多种实现__user_setup_stackheap()，并且可以从分散文件中提供的信息中自动为您选择正确的一种。
要选择两个区域内存模型，请在名为ARM_LIB_HEAP和的分散文件中定义两个特殊的执行区域ARM_LIB_STACK。两个区域都有该EMPTY属性。这会导致库选择__user_setup_stackheap()使用符号值的非默认实现：
Image$$ARM_LIB_STACK$$Base Image$$ARM_LIB_STACK$$ZI$$Limit Image$$ARM_LIB_HEAP$$Base Image$$ARM_LIB_HEAP$$ZI$$Limit 1234567 只能指定一个ARM_LIB_STACK或ARM_LIB_HEAP区域，并且必须分配一个大小，例如：
ARM_LIB_HEAP 0x20100000 EMPTY 0x100000-0x8000 ; Heap starts at 1MB ; and grows upwards ARM_LIB_STACK 0x20200000 EMPTY -0x8000 ; Stack space starts at the end ; of the 2MB of RAM ; And grows downwards for 32KB 12345 可以通过定义名为单一执行区域使用组合的栈和堆区域ARM_LIB_STACKHEAP，与EMPTY属性。这会导致__user_setup_stackheap()使用符号Image$$ARM_LIB_STACKHEAP$$Base和Image$$ARM_LIB_STACKHEAP$$ZI$$Limit的值。
注意如果您重新实现__user_setup_stackheap()，这将覆盖所有库里面的实现。
创建root执行区 要将区域指定为分散文件中的根区域，您可以：
指定
ABSOLUTE 为执行区的属性（显式或允许它默认），并为第一个执行区和封闭加载区使用相同的地址。要使执行区地址与加载区地址相同，请执行以下任一操作：
为执行区的基地址和加载区的基地址指定相同的数值。
指定+0加载区中第一个执行区的偏移量。如果+0为加载区中的所有后续执行区指定零偏移(+0)，则所有不跟随包含 ZI 的执行区的执行区也是根区。
以下示例显示了隐式定义的根区域：
LR_1 0x040000 ; load region starts at 0x40000 { ; start of execution region descriptions ER_RO 0x040000 ; load address = execution address { * (+RO) ; all RO sections (must include section with ; initial entry point) } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a73ddd0a4a6f83df7dc4eaa811562b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fe9d3c7fa07b09a9da9bdcfb88ada02/" rel="bookmark">
			electron&#43;react&#43;mysql快速构建桌面应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		electron+react+mysql快速构建桌面应用程序 在electron中创建react项目创建react项目安装electron相关模块创建electron文件夹和main.js修改package.json创建.env文件此时electron-react的目录结构启动electron 安装mysql2模块测试安装 利用IPC模块完成数据交互创建预加载文件preload.js修改main.jsreact代码中调用electron API 在electron中创建react项目 创建react项目 npx create-react-app electron-react-ipc-app 安装electron相关模块 npm install electron electron-builder wait-on npm install electron-is-dev concurrently electron-builder：用于为 macOS、Windows 和 Linux 打包和构建准备好分发的 Electron 应用程序，并提供开箱即用的“自动更新”支持。
wait-on：用于等待资源的简单命令行实用程序和 Node.js API，确保开发环境下electron能够访问到react服务。
electron-is-dev：仅在开发期间用于启用调试功能。 这个包必须在 Electron 主进程中使用。
concurrently：同时运行多个命令。像 npm run watch-js 和 npm run watch-less 但更好。
创建electron文件夹和main.js const {app, BrowserWindow} = require('electron'); const isDev = require('electron-is-dev'); const path = require('path'); let win ; function createWindow() { win = new BrowserWindow({ width:800, height:600, }); // const startURL = isDev ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fe9d3c7fa07b09a9da9bdcfb88ada02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b7632b133a0f6d7e5a3e0f2b2bd956b/" rel="bookmark">
			jmeter《关于时间戳 日期调用》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用jmeter函数助手对话框
time：动态生成当天的日期，转化成想要的格式，如：yyyy-MM-dd = 2022-07-28 ，不设置格式的话，就生成一串数组
timeShift()：时间位移函数，根据设置日期、位移量、时间格式，在该函数帮助里面有介绍。如 P DT H M S == +-P 天DT 时H 分M 秒S 例：偏移两天，-p2dt （注意英文符号）
RandomData：添加开始和结束时间，格式:yyyy-MM-dd 在时间段内随机。
dataTimeConvert：时间戳转换为时间，格式化时间：09102022011034 源时间格式：MMddyyyyHHmmss (可以嵌套，源格式可以不填) 目标时间格式：yyyy-MM-dd HH:mm:ss
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd0631b70014fc9b01de212e453ad3e2/" rel="bookmark">
			OpenHarmony--Hi3516DV300设备版本烧写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文单独介绍下Hi3516DV300板子，使用Hitool烧写工具烧写lite版本（L1-小型系统）和inux版本（L2-标准系统），和烧写完板子起不来时，配置启动参数操作参考。
目录
一.烧写工具
二.lite版本烧写
1.烧写
2.启动参数设置
三.Linux版本烧写
1.烧写
2.启动参数设置
3.挂载
四.使用USB烧写
1.安装驱动
2.烧写
​​​​​​​
一.烧写工具 Hitool工具
二.lite版本烧写 1.烧写 最新（2023.1.5）烧写xml：hi3516-liteos烧写.xml
2.启动参数设置 烧写完成后，板子屏幕如果不亮，请用串口工具连接板子，上下电，按CTRL+C，进入hisilicon #，依次输入以下参数：
setenv bootcmd "mmc read 0x0 0x80000000 0x800 0x4800; go 0x80000000"; setenv bootargs "console=ttyAMA0,115200n8 root=emmc fstype=vfat rootaddr=10M rootsize=30M rw"; saveenv reset 三.Linux版本烧写 1.烧写 2.启动参数设置 烧写完成后，板子屏幕如果不亮，请用串口工具连接板子，上下电，按CTRL+C，进入hisilicon #，依次输入以下参数：
setenv bootargs 'mem=128M console=ttyAMA0,115200 root=/dev/mmcblk0p3 ro rootfstype=ext4 rootwait blkdevparts=mmcblk0:1M(boot),9M(kernel),50M(rootfs),50M(userfs)'
setenv bootcmd "mmc read 0x0 0x82000000 0x800 0x4800;bootm 0x82000000"
save
reset
如图：reset重启设备，板子启动成功
3.挂载 1&gt;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd0631b70014fc9b01de212e453ad3e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8a04d8535c02f3c39a963574eeb29c0/" rel="bookmark">
			KITTI数据集可视化（一）：点云多种视图的可视化实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如有错误，恳请指出。
在本地上，可以安装一些软件，比如：Meshlab，CloudCompare等3D查看工具来对点云进行可视化。而这篇博客是将介绍一些代码工具将KITTI数据集进行可视化操作，包括点云鸟瞰图，FOV图，以及标注信息在图像+点云上的显示。
文章目录 1. 数据集准备2. 环境准备3. KITTI数据集可视化4. 点云可视化5. 鸟瞰图可视化 1. 数据集准备 KITTI数据集作为自动驾驶领域的经典数据集之一，比较适合我这样的新手入门。以下资料是为了实现对KITTI数据集的可视化操作。首先在官网下载对应的数据：http://www.cvlibs.net/datasets/kitti/eval_object.php?obj_benchmark=3d，下载后数据的目录文件结构如下所示：
├── dataset │ ├── KITTI │ │ ├── object │ │ │ ├──KITTI │ │ │ ├──ImageSets │ │ │ ├──training │ │ │ ├──calib &amp; velodyne &amp; label_2 &amp; image_2 2. 环境准备 这里使用了一个kitti数据集可视化的开源代码：https://github.com/kuixu/kitti_object_vis，按照以下操作新建一个虚拟环境，并安装所需的工具包。其中千万不要安装python3.7以上的版本，因为vtk不支持。
# 新建python=3.7的虚拟环境 conda create -n kitti_vis python=3.7 # vtk does not support python 3.8 conda activate kitti_vis # 安装opencv, pillow, scipy, matplotlib工具包 pip install opencv-python pillow scipy matplotlib # 安装3D可视化工具包（以下指令会自动安转所需的vtk与pyqt5） conda install mayavi -c conda-forge # 测试 python kitti_object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8a04d8535c02f3c39a963574eeb29c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f92cc3524fab97a75d4f10f7cd6e0238/" rel="bookmark">
			idea配置maven步骤及常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea 配置maven步骤及常见问题 maven 下载maven的配置配置系统环境变量maven本地仓库配置和镜像加速idea 中配置maven的设置常见问题，每次新建项目需要重新手动配置maven的解决 maven 下载 首先，进入它的官网：链接: https://maven.apache.org/download.cgi
选择你想要的版本，我这里因为使用的是idea2021,一开始选择的是3.8.7的，然后版本不匹配，所以推荐大家使用 3.6.2的版本。
选择maven历史版本进入查看其源码包：
然后选择 3.6.3的版本：
选择二进制文件进入：
找到 bin.zip
maven 3.6.2 的链接: https://archive.apache.org/dist/maven/maven-3/3.6.2/binaries/apache-maven-3.6.2-bin.zip
maven的配置 将上面下载的压缩包解压到一个没有中文路径的文件夹下面：
在其目录下新建一个用来当作本地仓库的文件夹，我这里将它命名为 maven-repository
配置系统环境变量 选择我的电脑，点击高级系统设置–&gt;环境变量
新建 MAVEN_HOME 环境变量，它的变量值为安装的maven目录
然后在编辑 Path ，在Path 环境变量里面新建%MAVEN_HOME%\bin
然后一直确定退出即可。
按下 win + R 输入 cmd ,然后输入 mvn -v 查看 maven是否配置成功
出现这样就说明成功啦，接下来开始配置本地仓库和镜像加速
maven本地仓库配置和镜像加速 在conf/settings.xml 更改maven配置
使用 vscode Notepad++或者 文本的方式打开xml，进行编辑
1.找到其中的 localRepository 修改本地仓库位置，标签体中即是刚刚手动创建的仓库位置。
&lt;localRepository&gt;D:\workspace-maven\apache-maven-3.6.2-bin\apache-maven-3.6.2\maven-repository&lt;/localRepository&gt; 2.使用阿里云镜像加速
找到mirrors标签，然后添加如下代码：
&lt;!-- 阿里云加速 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; 现在基本的配置已经改好啦，接下来在idea中更改配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f92cc3524fab97a75d4f10f7cd6e0238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b63f7ee834873362424fc34c2c1e6278/" rel="bookmark">
			Linux系统Shell脚本第三章：for、while循环及脚本实操
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、for循环
1、基本格式
2、类C语言格式
二、while循环
1、基本格式
2、死循环语句
三、跳出循环
1、continue跳出循环
2、break跳出循环
四、常用循环脚本实例
1、循环打印9*9乘法表
2、循环ping测试某个网段网络连通性
3、while死循环实现猜数字游戏
一、for循环 用于已知循环次数的场景
1、基本格式 for 变量名称(注意是名称不是变量$等) [ in 名称范围 ] (可以不写)
do 执行内容 若满足循环则做什么动作
done for循环结束标志
举例： vim a.sh #创建脚本a.sh 脚本内容: #!/bin/bash for i in {1..5} #for循环10次，第一次i=1，第二次i=2以此类推直到i=5 do echo "$i" #循环动作，每次输出$i done #for语句结束标志 bash a.sh #调用shell执行脚本a.sh 执行结果： 1 2 3 4 5 2、类C语言格式 for (( 表达式1 ；表达式2；表达式3 ))
do
执行内容 若满足循环则做什么动作
done for循环结束标志
表达式1：定义变量并赋值
表达式2：决定是否循环
表达式3：决定循环变量如何改变，决定循环什么时候结束
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b63f7ee834873362424fc34c2c1e6278/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/461f0ad9b0728ea019602cb6dfc65e33/" rel="bookmark">
			矢量图eps在word中的使用的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		word中插入矢量图的方法
在写论文时可能需要在word中插入eps矢量图。 微软已在 Office 中关闭对 EPS 图像的支持。
我在网上查询了很多方法,有将eps转换成emf直接插入word的，但显示效果还是不好,依然不是矢量图的效果。记录一个还算可行的：
eps矢量图在word中的使用
如果使用Latex写论文，可以直接使用eps格式的图片；而word只支持VML、WMF、EMF格式的矢量图，不能直接使用eps格式矢量图。
方法一：eps转emf直接插入word（非矢量图）
通过Adobe illustrator将eps图片转为emf并直接插入word，显示效果其实已经很好，放大到500%会有部分失真。此时依然不是矢量图的效果。
方法二：CV大法（矢量图）
1.安装好Adobe illustrator,尽量用新版本。
2.将eps矢量图文件用AI打开，在AI软件中全选矢量图元素，ctrl+c复制，然后到word中Ctrl+V粘贴，这样在word中就得到了矢量图。
注意：利用AI也能打开PDF格式的图片，但是打开后如果有文字，文字字体可能会变化，复制粘贴到word中就不是原模样的图了。
方法三：看到的其他方法，例如在gsview 中打开eps图片，然后复制粘贴。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67e9a31625b6d359ac26435248810603/" rel="bookmark">
			vue页面中使用getElementsByClassName无法获取元素问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 在vue页面中，使用getElementsByClassName获取dom，发觉总是获取不到，返回的数组，空空如也，长度为0。
二、问题分析 据说这是由于vue的机制造成的。 需要等所有内容都挂载完毕才行。具体内容可见参看文章一。要使用nextTick。
我印象中，nextTick好像总是与onMounted一起使用。但其实不是。以下例子中，nextTick就没有跟onMounted放在一起，而是位于外部调用的开关方法，跟随事件而触发。
三、问题解决 以下代码，是一个组件，响应外部调用传过来的参数，展示或隐藏不同的内容，并且执行初始化动作。初始化时，需要使用getElementsByClassName获取dom。初始化方法需要放在nextTick()里执行，才能获取指定class的dom。
&lt;template&gt; &lt;div id="tjContainer"&gt; &lt;div v-if="state.water" class="tj-container"&gt;内容一&lt;/div&gt; &lt;div v-if="state.zone" class="tj-container"&gt;内容二&lt;/div&gt; &lt;div v-if="state.red" class="tj-container"&gt;内容三&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; const state = reactive({ targ: "", water: false, zone: false, red: false, }); const showOrHide = (targ, status) =&gt; { state.targ = targ; const t = targ.toLowerCase(); if (t === "water") state.water = status; else if (t === "zone") state.zone = status; else if (t === "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67e9a31625b6d359ac26435248810603/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ad6c725640e457489c0eb4c6c76f34b/" rel="bookmark">
			如何开发一个性能好的软件系统？(多年工作经验，很有价值)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发一个软件系统，想要性能好，需要好的技术架构、以及代码要写得好。以下是我的一些工作经验。
一、数据库方面
1 索引 [重点]
请注意，一定要重视，一定要知道索引的重要性。否则，上线后系统肯定卡，要么炸。
什么时候建索引？建什么样的索引？
可以在产品需求确认后、编码前、统一建表时把索引设定好确认好，写代码时围绕着这些索引去写查询条件。后期根据实际情况还会有些调整。 也可以在项目代码全部写完后，再统一定索引。根据代码的查询条件以及慢查询，做调整。
理论上，一个软件系统，一定要有主键索引、肯定会有单索引、肯定会有联合索引。常用查询，必须建索引。举个例子，一个订单表，可能就需要 商户id+用户id+创建时间 作为联合索引：alter table order add index u_m(`merchant_id`,`uid`,`create_time`) USING BTREE;
如果把索引弄得好，一张表5000万行数据，没什么压力。比如订单表、账变表、积分流水表。但一定要慎重、小心、认真，因为以后处理问题处理数据的时候会非常耗时，容易搞崩。
注意事项：索引越少越好，千万别说唉呀我每个字段都建了索引，软件怎么还这么慢呢？
关于索引的原理，可以看我另一篇文章：一文掌握MySQL的索引 -- 数据结构(认真排版、简洁易懂)
关于SQL的性能分析，可以看我这篇文章：如何分析MySQL语句的性能(MySQL Explain详解)
2 数据归档
数据量大的表，可以做归档，比如只提供3个月的数据查询。比如移动电话账单，只能查近6个月。
3 写代码查数据时，别用 select * ，请指定要查哪些字段。
原因是：(1) 少查一个字段，内存的节约、速度的提升，都会好不少。(2) select … 指定全部字段，也比select * 的性能要好。(3) 可能会使用覆盖索引，性能极速提升。
4 如果能不用 select count() 就别用。这个性能很差。
前台的接口，提供给用户翻页，用户下拉翻一页，不需要知道总页数。
就算是普通的页码分页组件，也应该问一声，是否可以让用户一直点下一页，点到没有了就是最后一页。
5 慎用 limit
比如 limit 100000000,10 这样系统会直接卡死，性能非常差。有时可以不用 limit, 换一种写法，用主键判断再配合 limit 使用，性能提升非常多，如：where id &gt; 9000000 limit 100
使用场景，这里说两个。
(1) 比如有一个数据中心系统，提供接口给别的系统采集数据，别接受页码、第几页等参数去数据库分页，可以接受一个“last_id”作为参数，然后where id &gt; $last_id limit 100； (2) 分页
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ad6c725640e457489c0eb4c6c76f34b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26a6c005198fe3079b3256ba4fd6dd90/" rel="bookmark">
			前端解决跨域问题（9个方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是跨域？ 跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。
这里说明一下，无法跨域是浏览器对于用户安全的考虑，如果自己写个没有同源策略的浏览器，完全不用考虑跨域问题了。是浏览器的锅，对。
同源策略限制了一下行为：
Cookie、LocalStorage 和 IndexDB 无法读取
DOM 和 JS 对象无法获取
Ajax请求发送不出去
说的更直白一点，就是我们在前端使用ajax发送异步请求，如果这个请求的URL地址与当前地址栏中的URL地址协议不同、域名不同、端口不同时，都成为跨域，
出现跨域问题后，在控制台会出现以下报错：
下面，举几个跨域的栗子：
跨域解决方案 通过jsonp跨域document.domain + iframe跨域location.hash + iframewindow.name + iframe跨域postMessage跨域跨域资源共享（CORS）nginx代理跨域nodejs中间件代理跨域WebSocket协议跨域 一、 通过jsonp跨域
通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。
1）原生实现：
&lt;script&gt; var script = document.createElement('script'); script.type = 'text/javascript'; // 传参并指定回调执行函数为onBack script.src = 'http://www.demo2.com:8080/login?user=admin&amp;callback=onBack'; document.head.appendChild(script); // 回调执行函数 function onBack(res) { alert(JSON.stringify(res)); } &lt;/script&gt; 服务端返回如下（返回时即执行全局函数）：
onBack({"status": true, "user": "admin"}) 2）jquery ajax：
$.ajax({ url: 'http://www.demo2.com:8080/login', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: "onBack", // 自定义回调函数名 data: {} }); 3）vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26a6c005198fe3079b3256ba4fd6dd90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09a4a1bf38cfbdd9dea6fa95f04d27ef/" rel="bookmark">
			SpringData JPA中@OneToMany和@ManyToOne的用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 假设需求场景 在我们开发的过程中，经常出现两个对象存在一对多或多对一的关系。如何在程序在表明这两个对象的关系，以及如何利用这种关系优雅地使用它们。
其实，在javax.persistence包下有这样两个注解——@OneTomany和@ManyToOne，可以为我们所用。
现在，我们假设需要开发一个校园管理系统，管理各大高校的学生。这是一种典型的一对多场景，学校和学生的关系。这里，我们涉及简单的级联保存，查询，删除。
二. 代码实现 2.1 级联存储操作 Student类和School类
@Data @Table @Entity @Accessors(chain = true) public class Student { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String name; @ManyToOne @JoinColumn(name = "school_fk") private School school; } Student类上面的四个注解不做解释，id主键使用自增策略。Student中有个School的实例变量school，表明学生所属的学校。@ManyToOne（多对一注解）代表在学生和学校关系中“多”的那方，学生是“多”的那方，所以在Student类里面使用@ManyToOne。
那么，@ManyToOne中One当然是指学校了，也就是School类。
@JoinColumn(name = “school_fk”)指明School类的主键id在student表中的字段名，如果此注解不存在，生成的student表如下：
@Data @Table @Entity @Accessors(chain = true) public class School { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String name; @OneToMany(mappedBy="school"，cascade = CascadeType.PERSIST) private List&lt;Student&gt; students; } 在School类中，维护一个类型为List的students实例变量。@OneToMany（一对多注解）代表在学生和学校关系中“一”的那方，学校是“一”的那方，所以在School类里面使用@OneToMany。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09a4a1bf38cfbdd9dea6fa95f04d27ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5055cd70594aa0824ff36f4a11a3615d/" rel="bookmark">
			SREXT 实现分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在 linux 中实现 SRv6 SFC 的模型， linux 从4.10版本开始已经支持了 SRv6 协议栈，大部分 SRv6 的转发节点功能都具备。不过目前要使用 SFC ，还有许多服务未支持 SRv6 甚至未支持 IPv6 ，也就是许多服务还是 unaware SRv6 类型的。
为了能让 unaware SRv6 SFC 也能接入，需要有一个代理来完成 SRv6 剥除并且记录通信值如指针等， SREXT 就实现了这个功能。
SREXT 以模块的方式载入内核，维护了一个本地 SID 表，如果是下一跳 SFC 是 unaware 类型，就剥除 SRv6 并记录指针、 SID List 等内容，待下一跳返回后重新封装 SRv6 ，使用记录的 SID List ，和记录的指针值再减一写入 SRH 中。
本文将研究 SREXT 的实现原理。
代码库： https://github.com/netgroup/SRv6-net-prog/tree/kernel-4_18
安装步骤：
$ git clone https://github.com/netgroup/SRv6-net-prog $ cd srv6-net-prog/srext/ $ sudo make $ sudo make install $ sudo depmod -a $ sudo modprobe srext 卸载步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5055cd70594aa0824ff36f4a11a3615d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/541d1678ccb69e83728a4478d7f8d3b4/" rel="bookmark">
			多卡训练中的BN(BatchNorm)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现有框架BatchNorm的实现(DP,DDP)都是只考虑了single gpu。也就是说BN使用的均值和标准差是单个gpu算的，相当于缩小了batchsize。 对于比较消耗显存的训练任务时，往往单卡上的相对批量过小，影响模型的收敛效果。 之前在在图像语义分割的实验中，就发现使用大模型的效果反而变差，实际上就是BN在作怪。 跨卡同步 Batch Normalization 可以使用全局的样本进行归一化，这样相当于‘增大‘了批量大小，这样训练效果不再受到使用 GPU 数量的影响。 最近在图像分割、物体检测的论文中，使用跨卡BN也会显著地提高实验效果，所以跨卡 BN 已然成为竞赛刷分、发论文的必备神器。
但是为什么跨卡同步BN没有成为主流？
1）因为没有sync的需求，因为对于大多数vision问题，单gpu上的mini-batch已经够大了，完全不会影响结果。
2）影响训练速度，BN layer通常是在网络结构里面广泛使用的，这样每次都同步一下GPUs，十分影响训练速度。
从使用的经验来看，如果多卡训练没开BN同步，那么所得的结果和使用单GPU训练得到的结果基本一致，但是训练速度会得到提升。
而如果开了BN同步，训练结果会有将近一个点的提升
当然如果多卡训，但是单张卡上的batchsize就很大了，这样是开BN同步就没有太大作用
开了BN之后会让训练速度变慢，大概是不开5秒，开了8秒的样子
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6bf55153ce1d75380706cece5127a94/" rel="bookmark">
			【SpringBoot集成SpringSecurity】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本笔记内容为狂神说SpringBoot集成SpringSecurity部分
目录
一、介绍
二、环境搭建 1、新建一个初始的springboot项目web模块，thymeleaf模块
2、导入提供的静态资源 3、controller跳转
三、认识SpringSecurity
四、认证和授权
1、导入 Spring Security 依赖
2、编写配置类
3、测试
五、注销及权限控制
1、开启自动配置的注销的功能
2、添加注销按钮
3、导入thymeleaf依赖
4、修改前端页面
5、关闭csrf功能
6、设置角色功能块的认证
7、测试
六、记住我
开启记住我功能
七、定制登录页
1、配置跳转指定登录页
2、修改登录页
3、验证处理
4、在登录页增加记住我的多选框
5、后端验证处理
6、测试
一、介绍 Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。
对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。
参考官网：https://spring.io/projects/spring-security
二、环境搭建 1、新建一个初始的springboot项目web模块，thymeleaf模块 2、导入提供的静态资源 3、controller跳转 @Controller public class RouterController { @RequestMapping({"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6bf55153ce1d75380706cece5127a94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ca8e6b7f9dd7b6eb3fbd25e608b18ae/" rel="bookmark">
			Python 列表list详解（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Python内置函数/方法详解—列表list1、创建列表1.1 使用 [ ] 创建列表1.2 使用 list() 函数 创建(转换为)列表 2、访问列表2.1 下标索引访问2.2 切片访问2.3 for 循环遍历列表2.4 检查项目是否存在2.5 更改列表值2.6 列表连接(合并)/复制2.7 嵌套列表2.8 列表比较 3、内置函数3.1 打印输出 print()3.2 确定列表项目 len()3.3 返回变量类型 type()3.4 转换为列表 list()3.5 元组元素最大/小值 max()、min()3.6 删除列表 del 4、内置方法4.1 添加元素 append()、insert()、extend()4.2 元素出现次数 count()4.3 指定值索引 index()4.4 对列表排序 sort()4.5 复制列表 copy()4.6 颠倒列表顺序 reverse()4.7 删除元素 pop()、remove()、clear() 5、总结 Python内置函数/方法详解—列表list 列表是一个有序且可更改的集合，并且是最常用的 Python 数据类型。在 Python 中，列表是使用方括号 [] 编写的。
1、创建列表 在Python中，列表中元素的数据类型可以不同，可以包含整数、浮点数和复数等，当然，也可以包含列表、元组、字典和集合等。
1.1 使用 [ ] 创建列表 创建一个列表，只需要把逗号分隔的不同数据项使用方括号 [] 括起来即可。
创建空列表 list0 = [] 创建非空列表 list1 = ['Baidu', 'Alibaba', 'Tencent'] 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ca8e6b7f9dd7b6eb3fbd25e608b18ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfdb445f2dc5e75dfa0bd3fd8dad337f/" rel="bookmark">
			【Vue3】表单数据的双向绑定：v-model
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、单行文本框的绑定
二、多行文本区的绑定
三、复选框的绑定
四、单选按钮的绑定
五、下拉列表框的绑定
六、常用的两个修饰符
双向绑定使用v-model="绑定的变量名"
当在视图中改变了文本框的值，模型会把输入的值赋给变量；当模型中的变量值发生改变，视图中会用插值表达式取出模型的值。
一、单行文本框的绑定 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width= , initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="https://unpkg.com/vue@next"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-model="signleText"&gt; &lt;br&gt;&lt;br&gt; &lt;p&gt;文本框输入的内容是：{{ signleText }}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; const obj = { data(){ return{ signleText:'' } } } Vue.createApp(obj).mount('#app') &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 输入内容前：
输入内容后：
二、多行文本区的绑定 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfdb445f2dc5e75dfa0bd3fd8dad337f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87fd6f447a6f9cda9e5e3f6b9f7909b9/" rel="bookmark">
			C语言strstr()函数用法-字符串查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.函数定义 strstr()函数是一个参数为两个字符指针类型，返回值是char*类型的函数。
用于找到子串（str2）在一个字符串（str1）中第一次出现的位置（不包括str2的串结束符），并返回该位置的指针，如果找不到，返回空指针（NULL）。
这里因为传进来的地址指向的内容不会在发生改变，所以我们在两个形参（char*）前加上const。
它包含在string.h头文件中。
char* strstr(const char* str1,const char* str2) 2.代码实现 char* strstr(const char* str1, const char* str2) { assert(str1 &amp;&amp; str2); const char* s1 = str1; const char* s2 = str2; const char* p = str1; while (*p!='\0') { s1 =p ; s2 = str2; while (*s1 != '\0' &amp;&amp; *s2 != '\0' &amp;&amp; *s1 == *s2) { s1++; s2++; } if (*s2 == '\0') { return (char*)p; } p++; } return NULL; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87fd6f447a6f9cda9e5e3f6b9f7909b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ceddc82a6316ef3e5c96355dde986a9/" rel="bookmark">
			Java基础笔记（17）：异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 异常：在Java语言中，将程序执行中发生的不正常情况称为“异常” (开发过程中的语法错误和逻辑错误不是异常)
异常事件分类： Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理
Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：
空指针访问试图读取不存在的文件网络连接中断数组角标越界 解决办法： 遇到错误就终止程序的运行编写程序时，就考虑到错误的 检测、错误消息的提示，以及错误的处理 捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生
运行时异常： 是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响 编译时异常： 是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常对于这类异常，如果程序不处理，可能会带来意想不到的结果 红色：运行时异常
蓝色：编译时异常
常见异常： java.lang.RuntimeException（运行时异常）
ClassCasException（强制类型转换异常）ArrayIndexOutOfBoundsException（数组下标越界异常）NullPointerException（空指针异常）ArithmeticException（算术运算异常）NumberFormatException（数字格式化异常）InputMismatchException（输入不匹配异常） java.io.IOExeption（I/O流异常）
FileNotFoundException（文件访问异常）EOFException（正常运行结束的标志） java.lang.InterruptedException（执行该方法的线程被中断）
java.lang.ClassNotFoundException（无法找到指定的类异常）
java.sql.SQLException（SQL异常）
栈溢出：java.lang.StackOverflowError
堆溢出：java.lang.OutOfMemoryError
异常处理的方式： 一：try-catch-finally 二：throws+异常类型 Java提供的是异常处理的抓抛模型
Java程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为抛出(throw)异常
异常对象的生成： 由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出——自动抛出由开发人员手动创建：Exception exception = new ClassCastException();——创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样 异常处理机制：try-catch： 如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。这一过程称为捕获(catch)异常如果一个异常回到main()方法，并且main()也不处理，则程序运行终止程序员通常只能处理Exception，而对Error无能为力 捕获异常相关信息： getMessage()：获取异常信息，返回字符串
printStackTrace()：获取异常类名和异常信息，以及异常出现在程序中的位置，返回值void
不捕获异常时的情况： 前面使用的异常都是RuntimeException类或是它的子类，这些类的异常的特点是：即使没有使用try和catch捕获，Java自己也能捕获，并且编译通过( 但运行时会发生异常使得程序运行终止 )如果抛出的异常是IOException等类型的非运行时异常，则必须捕获，否则编译错误。也就是说，我们必须处理编译时异常，将异常进行捕捉，转化为运行时异常 异常处理机制：throws 如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类 手动抛出异常： Java异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要使用人工创建并抛出
首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运行环境)可以抛出的异常必须是Throwable或其子类的实例。 用户自定义异常类： 一般地，用户自定义异常类都是RuntimeException的子类自定义异常类通常需要编写几个重载的构造器自定义异常需要提供serialVersionUID自定义的异常通过throw抛出自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6712625aa7d2b4080e34d302203af1e0/" rel="bookmark">
			C语言编程题：寻找孪生素数（附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述：
数学家希尔伯特在1900年国际数学家大会的报告上提出一个“孪生素数猜想”，即： 存在无穷多个素数p，使得p + 2是素数。p和p+2这一对差为2的素数，被称为“孪生素数”。看起来，这个猜想是成立的，我们总能找到很多对孪生素数，例如：3和5,5和7,11和13…… 这一猜想至今还未被证明。现在，对于给定的整数n， 请寻找大于n的最小的一对孪生素数p和q（q=p+2）。
输入样例:100
输出样例:101 103
代码：
#include&lt;stdio.h&gt; #include&lt;math.h&gt; int fun(int n){ int i,k; k=sqrt(n); for(i=2;i&lt;k;i++) if(n%i==0) return 0; else return 1; } int main() { int n,p,q; scanf("%d",&amp;n); p=n+1; q=p+2; while(!(fun(p)&amp;&amp;fun(q))) { p++; if(fun(q)) break; } printf("%d %d",p,q); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f5c8fd12f2da0eb63212bf56b698c6c/" rel="bookmark">
			蓝桥杯真题七段码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： 七段码对应的a、b、c、d、e、f、g分别用数字0,1,2,3,4,5,6表示
一、DFS+check函数 这里与普通的dfs并不相同，因为这里的dfs不要求一定要到达叶子节点，但是dfs方法走了很多多余的路太笨了，这是我最开始的想法。
代码如下：
## a存储七段数码管的邻接矩阵 a = [[1,1,0,0,0,1,0], [1,1,1,0,0,0,1], [0,1,1,1,0,0,1], [0,0,1,1,1,0,0], [0,0,0,1,1,1,1], [1,0,0,0,1,1,1], [0,1,1,0,1,1,1]] ## check函数检查 i是否可以加入light中 def check(light,i): ## 重复加入 if str(i) in light: return False ## light为空怎么加入都对 if len(light) == 0: return True ## 有一个相连即可加入light for j in light: if a[i][int(j)] == 1: return True return False light = [] ## ans 设置成set是为了不重复解，但是感觉dfs还是不太适用于这一题 ans = set() def dfs(k): if k &gt; 7: ## 这里直接返回了，正常的其他dfs到达了叶子节点需要做记录，这里由于不要求到叶子节点直接返回即可 return True for i in range(7): if check(light,i): light.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f5c8fd12f2da0eb63212bf56b698c6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0437e4db70a05bb15b6968322fa3a4c3/" rel="bookmark">
			shell之函数和数组练习案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 函数和数组练习案例1、编写函数，实现打印绿色OK和红色FAILED判断是否有参数，存在为Ok，不存在为FAILED2、编写函数，实现判断是否无位置参数，如无参数，提示错误3、编写函数实现两个数字做为参数，返回最大值4、编写函数，实现两个整数位参数，计算加减乘除。5、将/etc/shadow文件的每一行作为元数赋值给数组6、使用关联数组统计文件/etc/passwd中用户使用的不同类型shell的数量7、使用关联数组按扩展名统计指定目录中文件的数量 函数和数组练习案例 1、编写函数，实现打印绿色OK和红色FAILED判断是否有参数，存在为Ok，不存在为FAILED #!/bin/bash ######################### #File name:1.sh #Version:v1.0 #Email:admin@test.com #Created time:2023-01-03 15:18:02 #Description: ######################### print(){ if [ -z "$1" ];then echo -e "\033[31m failed \033[0m" else echo -e "\033[32m ok \033[0m" fi } 有参数运行结果
print 1
无参数运行结果
print
2、编写函数，实现判断是否无位置参数，如无参数，提示错误 #!/bin/bash ######################### #File name:2.sh #Version:v1.0 #Email:admin@test.com #Created time:2023-01-03 21:43:28 #Description: ######################### set(){ if [ "$#" -eq 0 ] then echo "error" else echo "the function has "$#" parameters" fi } 无参数运行结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0437e4db70a05bb15b6968322fa3a4c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de31f149d5c4c729e7a44e0ec3a9e86f/" rel="bookmark">
			C语言特殊图案之菱形的三种方法---今日笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小小白第一次写CSDN的博客啦！ 第一次写正式的博客，大家凑合看吧，有什么问题可以留言哦。
题目：输出一个如下菱形图 方法一 ，利用循环控制输出。
解题思路：计算出每行包括7个字符，其中有的是空白字符，有的是’ * ‘字符，记下在每行中’ * ‘字符出现的位置。找出空格字符和’ * '字符的位置关系，利用for循环控制输出格式。 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int i,j,k; for(i=0;i&lt;=3;i++) { for(j=0;j&lt;=2-i;j++) printf(" "); for(k=0;k&lt;=2*i;k++) printf("*"); printf("\n"); } for(i=0;i&lt;=2;i++) { for(j=0;j&lt;=i;j++) printf(" "); for(k=0;k&lt;=4-2*i;k++) printf("*"); printf("\n"); } return 0; } 输出如图所示：
2：方法二 ，直接暴力利用输出格式
解题思路：利用字符的格式输出，对输出的域宽进行控制
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { printf("%4c\n",'*'); printf("%5s\n","***"); printf("%6s\n","*****"); printf("%7s\n","*******"); printf("%6s\n","*****"); printf("%6s\n","*****"); printf("%5s\n","***"); printf("%4c\n",'*'); return 0; } 输出如图所示：
3：方法三，利用二维字符数组
解题思路：计算出每行包括7个字符，其中有的是空白字符，有的是’ * ‘字符，记下在每行中’ * '字符出现的位置。定义一个字符型的二维数组，用“初始化列表”进行初始化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de31f149d5c4c729e7a44e0ec3a9e86f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abc093d1c8f63d1b577c2a2aeee2a436/" rel="bookmark">
			python中的extend功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		extend() 函数的功能:
用于在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）
A = [1, 2, 3] B = [['a', 'b']] A.extend([4]) A.extend([5, 6]) B.extend(['c', 'd']) B.extend([['e', 'f']]) print(A) print(B) // output [1, 2, 3, 4, 5, 6] [['a', 'b'], 'c', 'd', ['e', 'f']] extend() 函数、append()函数、+ 与 += 功能比较:
append()是向列表尾部追加一个新元素，列表只占一个索引位，在原有列表上增加。extend()向列表尾部追加一个列表，将列表中的每个元素都追加进来，在原有列表上增加。+与extend()在效果上具有相同的功能，但是实际上生成了一个新的列表来存放这两个列表的和，只能用在两个列表相加上。+=与extend()效果一样。 1. append()：
// append()： A = [1, 2, 3] B = [4, 5, 6] print(A.append(B)) print(A) // output None [1, 2, 3, [4, 5, 6]] 2. extend()：
A = [1, 2, 3] B = [4, 5, 6] print(A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abc093d1c8f63d1b577c2a2aeee2a436/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0c31591c59ebd5c4e60d3edbf78f60f/" rel="bookmark">
			python：pandas模块最全最详细的教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pandas模块介绍 pandas官方文档：https://pandas.pydata.org/pandas-docs/stable/?v=20190307135750
pandas基于Numpy，可以看成是处理文本或者表格数据。pandas中有两个主要的数据结构，其中Series数据结构类似于Numpy中的一维数组，DataFrame类似于多维表格数据结构。
pandas是python数据分析的核心模块。它主要提供了五大功能:
支持文件存取操作，支持数据库(sql)、html、json、pickle、csv(txt、excel)、sas、stata、hdf等。支持增删改查、切片、高阶函数、分组聚合等单表操作，以及和dict、list的互相转换。支持多表拼接合并操作。支持简单的绘图操作。支持简单的统计分析操作。 一、Series数据结构 Series是一种类似于一维数组的对象，由一组数据和一组与之相关的数据标签（索引）组成。
Series比较像列表（数组）和字典的结合体
import numpy as np import pandas as pd df = pd.Series(0, index=['a', 'b', 'c', 'd']) print(df) a 0 b 0 c 0 d 0 dtype: int64 print(df.values) # [0 0 0 0] print(df.index) # Index(['a', 'b', 'c', 'd'], dtype='object') 1 Series支持NumPy模块的特性（下标） 详解方法从ndarray创建SeriesSeries(arr)与标量运算df*2两个Series运算df1+df2索引df[0], df[[1,2,4]]切片df[0:2]通用函数np.abs(df)布尔值过滤df[df&gt;0] arr = np.array([1, 2, 3, 4, np.nan]) print(arr) # [ 1. 2. 3. 4. nan] df = pd.Series(arr, index=['a', 'b', 'c', 'd', 'e']) print(df) # 结果： a 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0c31591c59ebd5c4e60d3edbf78f60f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0998a4f7033f0664bbb06e5e4da2f1de/" rel="bookmark">
			CTFhub之web练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		title: CTFhub之web安全
tags: ctfhub
categories: CTF
author: Abyssaler
1.文件上传之双写后缀 双写绕过原理：
服务端对黑名单中的内容进行处理，且仅处理一次，所以可以通过双写后缀绕过．如，黑名单中有＂php＂字样，上传文件名为＂1.php＂ 上传后文件变成＂1.＂．
如果直接上传111.php的话，会过滤后缀
想到用burp suite抓包改后缀
如图，一开始我想改成111.phpphp，想只过滤一次的话还剩一个php就成功了，结果被无情打脸
后来得知服务端会对后缀名中所有的php进行过滤，所以修改思路
改成这个样子
服务端就只会过滤.pphphp中间的php，剩下的就是111.php了
最后用蚁剑连接
找到flag
2.文件上传之00截断 前置知识: 文件上传漏洞“%00截断”绕过讲解":
https://www.fujieace.com/penetration-test/file-upload-00.html
原理：如果是白名单检测的话，我们可以采用00截断绕过。00截断利用的是php的一个漏洞。在 php&lt;5.3.4 版本中，存储文件时处理文件名的函数认为0x00是终止符。于是在存储文件的时候，当函数读到 0x00(%00) 时，会认为文件已经结束。
例如：我们上传 1.php%00.jpg 时，首先后缀名是合法的jpg格式，可以绕过前端的检测。上传到后端后，后端判断文件名后缀的函数会认为其是一个.jpg格式的文件，可以躲过白名单检测。但是在保存文件时，保存文件时处理文件名的函数在遇到%00字符认为这是终止符，于是丢弃后面的 .jpg，于是我们上传的 1.php%00.jpg 文件最终会被写入 1.php 文件中并存储在服务端。
直接看题 这里直接上传一句话木马文件会显示文件类型不匹配
按F12打开开发者工具查看源代码，发现白名单
分析源代码
if (!empty($_POST['submit'])) { $name = basename($_FILES['file']['name']); $info = pathinfo($name); $ext = $info['extension']; $whitelist = array("jpg", "png", "gif"); if (in_array($ext, $whitelist)) { $des = $_GET['road'] . "/" . rand(10, 99) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0998a4f7033f0664bbb06e5e4da2f1de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3e7fceb9c725002860f059c940f1476/" rel="bookmark">
			记某同事的两次误操作导致Linux瘫痪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我有一个同事, 有两次在项目组服务器上误操作, 差点导致整个Linux服务器报废
第一次问题: 问题复现:
在/data/hadoop 下有一个usr的目录, 为垃圾目录(rpm包解压后产生的)
同事想 删除 ./usr, 但是还好没用 rm -rf, 而是用的 mv /usr /tmp
注意, ./usr 被打成了 /usr, 导致核心目录 /usr 移到了 /tmp/usr
再使用 ls、vim、cat 都发现命令用不了了， 只有原生的 cd、pwd、export 这些命令才能用
但是按 Table 键还是可以补全的来 代替 ls
你肯定想着，用上 绝对路径 是不是就ok了？
不，不行，会报 /lib64/ld-linux-x86-64.so.2: bad ELF interpreter: No such file or directory 的错误
那 export /tmp/usr/bin 到 PATH 环境变量呢?
照样不行, 这样会和用 绝对路径 的方法 报同样错误
更恐怖的, ssh命令也用不了, 意味着现在不能使用新的 XShell 重新连接到服务器了,
一旦你现在已经连上的 Xshell 也断开连接了, 那就再也连不上 Linux 了,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3e7fceb9c725002860f059c940f1476/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/948ce56a46c8ad21f8413457e552f49d/" rel="bookmark">
			seata案例之springcloud&#43;MybatisPlus&#43;nacos&#43;seata
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		seata案例之springcloud+MybatisPlus+nacos+seata
源码
https://gitee.com/tong-exists/springcloud-MybatisPlus-nacos-seata
1 版本 springboot、springcloud、springcloudalibaba、nacos-server、seata-server的版本需要谨慎选择，选择能够兼容的版本。具体参考https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E。
本项目使用的版本
springboot2.6.3springcloud2021.0.1springcloudalibaba2021.0.1.0nacos-server1.4.2seata-server1.4.2 2 搭建springboot+MybatisPlus 2.1业务 用户购买商品的业务逻辑。整个业务逻辑由3个微服务提供支持：
仓储服务：对给定的商品扣除仓储数量。
订单服务：根据采购需求创建订单。
帐户服务：从用户帐户中扣除余额。
2.2数据库表 创建三个数据库account_db、order_db、storage_db
account_db
DROP TABLE IF EXISTS `t_account`; CREATE TABLE `t_account` ( `id` int NOT NULL AUTO_INCREMENT, `user_id` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NULL DEFAULT NULL, `money` int NULL DEFAULT 0, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb3 COLLATE = utf8mb3_general_ci ROW_FORMAT = Dynamic; order_db
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/948ce56a46c8ad21f8413457e552f49d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5660aea45c9d4970dd05ad73a7f8ce82/" rel="bookmark">
			【顺序程序】数字倒序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：从键盘输入一个四位整数，将其各位数字倒序输出。
输入：输入一个四位数。
输出：倒序输出该四位数。
样例输入：1234
样例输出：4321
我的思路：将四位数的四个数字设为s、d、f、g，然后一个个表示。
来自大佬Lyeee_eee的代码：（没有头文件）
int main() { int x,a,b,c,d; scanf("%d",&amp;x); a=x/1000; b=x%1000/100; c=x%100/10; d=x%10; if(d==0 &amp;&amp; c!=0) printf("%d%d%d",c,b,a); else if(d==0 &amp;&amp; c==0) printf("%d%d",b,a); else printf("%d%d%d%d",d,c,b,a); return 0; } 本蒟蒻的代码：
#include&lt;iostream&gt; using namespace std; int main () { int a,b=1000,s,d,f,g;//设四个字母 cin&gt;&gt;a; a&gt;=b; s=a/1000; d=a/100%10; f=a/10%10; g=a%10;//分别表示四个字母 cout&lt;&lt;g&lt;&lt;f&lt;&lt;d&lt;&lt;s; return 0; } 下期见👋
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/949473a5a53e603e83f6a334a474d352/" rel="bookmark">
			前端面试常考 | js原型与原型链
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 什么是原型?二. 什么是原型链? 一. 什么是原型? 在js中所有的引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象。
而在js中的引用类型包括：Object，Array，Date，Function
而所有函数都有一个prototype(原型)属性，属性值是一个普通的对象，也被称为原型对象。
所有引用类型的__proto__属性指向它构造函数的prototype:
var a = [1,2,3]; a.__proto__ === Array.prototype; // true 那么原型有什么作用呢?
可以存放一些属性和方法: Array.prototype.hello=function(){ console.log("hello") } arr = [1, 2, 3] arr.hello() // hello 在javaScript中实现继承: function Father(){ this.firstName="李"; } var father=new Father(); Father.prototype.lastName="名"; function Son(){ this.firstName="张"; this.sex="男"; } // 子类原型继承父类的实例 Son.prototype=father; var son=new Son(); console.log(son.firstName,son.lastName,son.sex) 二. 什么是原型链? 当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。
注意: 如果最顶层还找不到的话就会返回null
列如我们有如下代码：
Object.prototype.age = 18 function Person(name) { this.name = name; } var preson = new Person('nt'); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/949473a5a53e603e83f6a334a474d352/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b708be6f6a6b00a2a4d979f30e669808/" rel="bookmark">
			mac vscode远程ssh免密登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考:http://www.pingtaimeng.com/article/detail/id/1922463
mac、vscode免密码登录远程服务器SSH
主要通过ssh设置
步骤如下
mac本地电脑，```ssh-keygen -t rsa`` 获取密匙
登录远程server服务器，将 本地mac密匙的 id_rsa.pub 写入到 server服务器的.ssh 文件夹的 authorized_keys 文件中，保存接口
cd /
cd ~/.ssh
vim authorized_keys
备注：authorized_keys 新建的服务器是没有这个文件的，直接新建即可
mac既可以实现密码登录 ssh root_account@ip
vscode 设置
vscode 安装
安装插件: remote-ssh
点击左下角 的链接符号，点击config文件
config文件配置
Host cloud
HostName 1.0.0.1
User root
IdentityFile /Users/mac/.ssh/id_rsa
OK
注意IdentityFile的段落是不用引号的
注意这里的HostName User Port IdentityFile不要写错,不然直接会连不上
之后直接连即可
如果无效，不妨本地重新生成一下试试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/859d4541da753239d7651254e5452a1e/" rel="bookmark">
			家庭全光纤万兆网络搭建保姆级攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着时代的进步，万兆设备已经降价到可以被家庭用户接受的程度了，所以部分家庭已经开始考虑10G甚至40G的光网了，但是从电网到光网，有很多不一样的部分。
分名词、设备、施工三部分，光网需要注意的部分全覆盖，篇幅较长，耐心阅读。
01名词
了解光网，需要先解释一下必要的名词和概念，为的是便于我们进行设备的采购，并结合自己的情况，设置光网方案。
1、光纤的种类：光缆、皮线、跳线、尾纤、裸纤
光缆：可以是泛称指所有光纤。
但在网络施工中一般特指外包绝缘层的铠装光纤(加金属层了)，光缆一般内装很多根光纤的信号传输线，可以户外使用，提供了很好的机械强度以保护内部光纤避免损坏。
一般8芯光缆的粗细和5类线相当，而成本比六类线要便宜，所以在家庭网络布线的时候，可以考虑直接使用光缆进行预埋以替代网线，比网线拥有更高的性价比。
山泽(SAMZHE)皮线光纤光缆 室内单模双芯光纤线 2芯2钢丝 白色100米：
山泽(SAMZHE)皮线光纤光缆 室内单模双芯光纤线 2芯2钢丝 白色100米 京东 月销量100 好评率98% 无理由退换 京东配送 官方店 ¥65.9 购买 蝶形光纤：被称为皮线，一般作为预埋使用，强度不错，可以承受较大的拉力，方便布线。基本构造是两根钢丝内夹1-2根光纤芯，外层由塑料绝缘保护，横断面像一只蝴蝶，家里的入户线就是这种。对付这种构造的光纤需要皮线开剥器，可以很轻松的做到不损坏光纤的情况下夹断保护光纤芯的钢丝。
跳线/尾纤：这两种线材一般指软质的光纤，这种线材内部没有钢丝，但是有一层纺织层包裹加固，可以提供一定的机械性能，一般用在室内布线或者家装预埋。所不同的是，尾纤是一端有端子用于连接光缆，而跳线是两端都有端子用于直接连接不同的设备。
这里要说一下各种光纤的接头：
FC 圆型带螺纹(配线架上用的最多)
ST 卡接式圆型
SC 卡接式方型(路由器交换机上用的最多)
PC 微球面研磨抛光
APC 呈8度角并做微球面研磨抛光
MT-RJ 方型,一头双纤收发一体
胜为(shengwei)电信级光纤跳线 SC-SC单模单芯3米入户光纤线：
胜为(shengwei)电信级光纤跳线 SC-SC单模单芯3米入户光纤线 京东 月销量1000 好评率99% 无理由退换 京东配送 官方店 ¥9.9 购买 裸纤：就比较容易理解了，光缆剥到最后一层，没有外防护层的就是裸纤了。
关于线材的名词并不是绝对的，比如我下面这张图就算是一个特例了
家有宠物的，强烈推荐上图这种跳线。
2、冷接器
光纤连接的时候，无需热熔的接口被称为冷接器，里面一般有耦合剂浸泡光纤头，以减低信号阻抗。
SC的冷接子因为电信部门大量采购，所以很便宜，有的才1块钱一个。LC冷接子因为用的少，所以比较贵，大概一个10块钱，一个万兆设备就2个LC头，而且自己接的质量一般不如由工厂加工的好，所以最划算的还是买尾纤。皮线对皮线或尾纤的对接也可以使用皮线冷接子，一个不超过5块钱，而且不用太多额外的设备。V型槽也可以用做皮线或跳线的冷接，但是要配耦合剂，耦合剂大概一瓶10毫升的20块钱左右，进口的贵一点，但是也没多少钱，一瓶10毫升的够接数百个冷接头了，因为每次冷接只需要在光纤端面上沾一点(冷接头耦合剂蒸发了也可以进行补充)
冷接子有型号的区别，一般就是9μm和50μm的两种，对应了单模和多模光纤粗细，其他型号的很少见，也很难买的到。
胜为(shengwei)电信级SC/UPC冷接子 预埋式SC皮线光纤快速连接器：
胜为(shengwei)电信级SC/UPC冷接子 预埋式SC皮线光纤快速连接器 京东 月销量500 好评率99% 无理由退换 京东配送 官方店 ¥39.9 购买 放个模块是为了比较大小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/859d4541da753239d7651254e5452a1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f650523f180c2ffa430632d0672e9550/" rel="bookmark">
			C#文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
文件操作：
File：
FileInfo：
File和FileInfo的主要区别：
文件夹操作：
Directory：
DirectoryInfo：
Directory类和DirectoryInfo类的区别：
数据操作：
读写文件操作的基本步骤：
读取操作：
写入操作：
序列化和反序列化：
序列化：
反序列化：
文件操作： 在C#中可以通过File类和FileInfo类方便地实现创建、移动、复制和删除等操作
File： File.Create(string path)：在指定路径中创建或覆盖一个文件
注意：如果指定路径下已经有此文件，那么原有的会被覆盖
File.Delete(string path)：根据指定路径删除一个文件
注意：此删除是彻底删除，回收站也没有
File.Copy(string oldPath,string newPath)：根据指定路径复制一个文件
参数一：要复制的文件路径
参数二：复制出来的新的文件路径及文件名字
注意：
如果要复制的文件不存在，编辑器会报错；
如果参数一和参数二路径及文件名一样，编辑器会报错；
新复制出来的文件与原来文件大小、里边内容都是一样的。
File.Exists(string path)：判断一个文件是否存在，参数为文件路径，返回值为布尔类型
File.Move(string oldPath,string new Path)：将指定的文件移到新位置（等于剪切一个文件到新的地方）
参数一：原始文件路径；
参数二：新的文件路径及名字。
File.ReadAllBytes()：读取一个文件内容，返回的是这个文件内容的字节数组
File.ReadAllLines(string path,Encoding.encoding)：读取一个文件的所有行，返回包含文件所有行的字符串数组
参数一：文件的路径；
参数二：编码格式，如果不指定编码格式，所输出的文件内容很有可能是乱码
File.ReadAllText(string path,Encoding.encoding)：读取一个文件的所有行，返回包含文件所有行的字符串；
与ReadAllLines区别在于：返回的结果不同；
FileInfo： 属性：
方法：
方法描述AppendText()它用于创建一个StreamWriter类对象，将文本附加到FileInfo的此实例所表示的文件中。CopyTo(String)它用于将现有文件复制到新文件。Create()它用于创建文件。CreateText()它用于创建一个写入新文本文件的StreamWriter类对象。Decrypt()它用于解密由使用加密方法当前帐户加密的文件。Delete()它用于永久删除文件。Encrypt()它用于加密文件，以便只有用于加密文件的帐户才能对其进行解密。GetAccessControl()它用于获取封装访问控制列表(ACL)条目的FileSecurity对象。MoveTo(String)它用于将特定文件移动到新的指定位置。Open(FileMode)它用于以指定的模式来打开文件。OpenRead()它用于创建只读FileStream。OpenText()它用于创建从现有文本文件使用UTF8编码读取的StreamReader类。OpenWrite()它用于创建只写FileStream对象。Refresh()它用于刷新对象的状态。Replace(String,String)用于使用当前FileInfo对象描述的文件替换指定文件的内容。ToString()它用于将路径作为字符串返回。 File和FileInfo的主要区别： File为静态类只包含静态方法，不能被实例化，方法调用方便，但执行效率较低FileInfo为非静态类，必须创建对象，才能调用方法，但执行效率较高 文件夹操作： 在C#中提供了Directory类和DirectoryInfo类用于对磁盘和文件夹进行操作管理，主要包括创建、移动和删除等操作
Directory： Directory.CreateDirectory：创建文件夹，文件夹存在则不操作
Directory.Delete：删除一个文件夹
默认的第二个参数是false，只能删除空目录；第二个参数为true的时候就可以删除文件夹连同文件夹里的所有文件
Directory.Move：移动文件夹位置
Directory.Exists：判断文件夹是否存在,返回布尔类型
Directory.GetFiles：获取目录下的所有文件的路径，返回到字符串数组
第二个参数是筛选出指定格式的文件，如果不填第二个参数，则返回全部文件
Directory.GetDirectories：获取目录下所有文件夹的路径，返回字符串数组
DirectoryInfo： 属性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f650523f180c2ffa430632d0672e9550/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a88c25cdf692b9f6cc3f1b10066ecd8b/" rel="bookmark">
			Syntax Error: Error: PostCSS plugin tailwindcss/autoprefixer requires PostCSS 8.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Syntax Error: Error: PostCSS plugin tailwindcss requires PostCSS 8.Syntax Error: Error: PostCSS plugin autoprefixer requires PostCSS 8.
problem vue中引入tailwindcss 启动时，命令行报错 2 种错误
Syntax Error: Error: PostCSS plugin tailwindcss requires PostCSS 8. Migration guide for end-users: https://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users Syntax Error: Error: PostCSS plugin autoprefixer requires PostCSS 8. Migration guide for end-users: https://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users reason npm包版本不兼容
solution 先删除已安装的npm包 yarn npm 按需选择
yarn remove tailwindcss postcss autoprefixernpm uninstall tailwindcss postcss autoprefixer 再重新安装 yarn npm 按需选择
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a88c25cdf692b9f6cc3f1b10066ecd8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a746a29e5044f90d526ae49047908dbe/" rel="bookmark">
			Android 13 VTS HIDL interface 解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 13 VTS Introduction Android 13已经发布，VTS testcase发生很多变化，在此博客中对其每个测试项目进行流程介绍。
这里先对VTS 做一个介绍：
VTS是vendor test suite简称，意为供应商测试套件。目的是确保Vendor层实现的兼容性，新的Vendor层接口会由供应商测试套件 (VTS) 进行验证。
为了更好理解以上VTS概念，从下面Android camera framework角度进行讲解，最下面一层是HIDL interface是为了让camera service连接芯片厂商实现的HAL layer。Google为了保证Android 上层系统与芯片厂商实现的HAL layer解耦，定义出来HIDL interface。
同时为了保证芯片厂商HAL layer实现HDIL interface的稳定性，所以设计VTS testcase测试。
VTS Testcase Detailed Annotation Android 13 对HAL layer的测试有两种方案，第一种是使用上面介绍的HIDL interface，第二种是AIDL
interface（Android 13 last update），这个博客中只介绍第一种方案。这一部分就是对VTS testcase中所有的测试项进行代码流程梳理，流程过于简单的直接提供pass条件，主要分析HAL3 interface测试项目。 Testcase NameTestcase Function IntroductionnoHal1AfterPPASS:调用mProvider→cameraDeviceNames device vesion vaild and not be device1.0isTorchModeSupportedgetCameraIdListPass：调用mProvider→getCameraIdList 无异常getVendorTagsPass：调用mProvider→getVendorTags 无异常setCallbackgetCameraDeviceInterfacePass：调用mProvider→getCameraDeviceInterface 无异常getResourceCostPass：调用mProvider→getCameraDeviceInterface and device-&gt;getResourceCost 无异常getCameraInfoPass：调用mProvider→getCameraDeviceInterface and device-&gt;getResourceCost 无异常setPreviewWindow（并且对setPreviewWindows function流程进行介绍）startStopPreviewDelayedsystemCameraTest ——————未完待续——————
参考资料 https://blog.csdn.net/qq_45412462/article/details/124077449
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/416d77fd7a09a1aee206825d19d66ace/" rel="bookmark">
			C语言中的32个关键字及含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：数据类型关键字：12个
char,int,short,long,float,double,enum,singed,struct,union,unsinged,void.
char:声明字符型变量或函数
int：声明整型变量或函数
short：声明短整型变量或函数
long：声明长整型变量或函数
float：声明浮点型变量或函数
double：声明双精度浮点型变量或函数
enum：声明枚举型变量或函数（将变量的值一一列出来）
singed：声明有符号类型变量或函数
unsinged:声明无符号类型变量或函数
union:声明共用数据类型
void：声明函数无返回值
2:控制语句关键字12个：
break ,continue do,while,if ,else,goto,return ,switch ,case,default.
break：跳出当前循环
continue：结束当前循环，开始下一轮循环
do:循环语句的循环体
while：循环语句的循环条件
if:条件语句（如果)
else:条件语句否定分支（与if连用）
goto：无条件跳转语句（让程序直接跳转到任意标记的位置）
return：子程序返回语句，循环条件
switch：用于开关语句
case：开关语句的分支
default：开关语句中的默认分支（switch语句种case不成立时要执行的语句）
3:储存关键字4个：auto,exturn,register,static,
auto：声明自动变量 extern:声明变量是在其他文件中（例如在a文件中需要引用b文件中的int v,就用extern int v）
register：声明寄存器变量（变量直接引用寄存器）
static：声明静态变量（静态变量属于静态储存方式，与auto相反）
4:其他关键字4个：const,sizeof,typdef,volatile.
const：声明只读变量（使变量的值不能再被改变）
sizeof:计算数据类型的长度（int float long,short double ...)
typdef:用来给数据类型重新起一个别的名字
volatile:变量在执行过程中可以被隐含的改变；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/153a6103365eb4f05e12b7dbf65a71c5/" rel="bookmark">
			Linux启动redis集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis-server /opt/redis/cluster/7001/redis.conf redis-server /opt/redis/cluster/7002/redis.conf redis-server /opt/redis/cluster/7003/redis.conf redis-server /opt/redis/cluster/7004/redis.conf redis-server /opt/redis/cluster/7005/redis.conf redis-server /opt/redis/cluster/7006/redis.conf 参考文章：http://wjhsh.net/paul8339-p-11987345.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03391d1e1f50e5f152b39eae578ddfbf/" rel="bookmark">
			【台式机DIY】我的第一台台式机&amp;电脑配置清单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 @[toc]【第一台台式机】一、电脑配置清单【电脑小白我科普】一.CPU1.选购：主流品牌2.选购：如何选择3.参数：接口4.参数：频率5.参数：核心和线程6.参数：功耗7.参数：缓存 二.主板1.选购：主流品牌2.选购：如何选择3.参数：接口4.参数：大小5.参数：芯片组6.参数：BIOS 三.内存1.选购：主流品牌2.选购：如何选择3.参数：接口4.参数：CPU支持情况 四.硬盘1.选购：主流品牌2.选购：如何选择3.参数：协议、总线、接口 五.显卡1.选购：主流品牌2.选购：如何选择3.参数：命名4.参数：接口 六.散热器七.电源八.机箱 【第一台台式机】 一、电脑配置清单 用途：日常办公写作、嵌入式开发选择：暂时先不加显卡，主加CPU内存硬盘 硬件型号价格购买平台CPU主板内存硬盘显卡散热器电源机箱 【电脑小白我科普】 一.CPU CPU（central processing unit）：中央处理器 1.选购：主流品牌 Intel 和 AMD
Intel主要产品：Celeron(赛扬)、Pentium(奔腾)、Core（酷睿）、至强（Xeon）
AMD主要产品：Ryzen（锐龙） R3、R5、R7、R9 系列、5000系列
2.选购：如何选择 3.参数：接口 Intel CPU 插槽：LGA1200、LGA1700
AMD CPU 插槽：AM4、AM5
4.参数：频率 基础频率、睿频、超频 5.参数：核心和线程 6.参数：功耗 7.参数：缓存 二.主板 1.选购：主流品牌 一线品牌：华硕、微星、技嘉二线品牌：华擎 2.选购：如何选择 第一步：选CPU第二步：查看CPU对应的主板芯片组第三步：根据芯片组搜索主板 3.参数：接口 4.参数：大小 E-ATX（加强型）、ATX（标准型）、M-ATX（紧凑型）、ITX（迷你型） 5.参数：芯片组 主板芯片组决定主板能搭配什么cpu、能否对cpu超频、决定电脑的扩展性、升级的上限。
Intel ：
AMD ：
6.参数：BIOS BIOS（Basic Input Output System）：基本输入输出系统。主板自带的一个微型操作系统，属于电脑里最底层、最根本的系统。进入BIOS：F2、Del 参考：
主板选购参考：组装电脑哪个主板好？如何选择电脑主板？2022年双十二电脑主板推荐及分析。 - 知乎 (zhihu.com)
主板科普参考：【电脑DIY】从萌新入门到开窍——主板篇 - 知乎 (zhihu.com)
三.内存 1.选购：主流品牌 金士顿、三星 等等等 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03391d1e1f50e5f152b39eae578ddfbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df876760dcc457490d446db8765a9680/" rel="bookmark">
			OpenCV 图像绘图、线条、文字、矩形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是 OpenCV图像视觉入门之路的第8篇文章，本文详细的在图像上面进行了绘制线条、绘制圆、空心圆、实心圆、画矩形、空心矩形、实心矩形、添加英文、添加汉字、绘制多边形等操作。
OpenCV 图像绘图、线条、文字、矩形目录
1 绘制线条
2 绘制圆
2.1 空心圆
2.2 实心圆
3 画矩形
3.1 空心矩形
3.2 实心矩形
4 添加文字
5 添加汉字
6 绘制多边形
1 绘制线条 主要使用了line函数
import cv2 from PIL import Image import matplotlib.pyplot as plt import numpy as np # 按间距中的绿色按钮以运行脚本。 if __name__ == '__main__': image = cv2.imread('D:/Jupyter_Notebooks/0.jpg') image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) # (0, 0) XY点 (800, 512) 终点 (255, 0, 0)颜色 5宽度 cv2.line(image, (0, 0), (800, 512), (255, 0, 0), 5) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df876760dcc457490d446db8765a9680/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7649b1bee27d2360010acce1cd9935c1/" rel="bookmark">
			Shell脚本之——条件语句if详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、test命令1.2、格式1.2、实例操作 二、文件测试2.1、格式：2.2、常用的测试操作符2.3、实例操作 三、整数值比较3.1、格式3.2、常用的测试操作符3.3、实例操作 四、字符串比较4.1、格式4.2、常用的测试操作符4.3、实例操作 五、逻辑测试（三元运算符）5.1、格式5.2、常用的测试操作符5.3、实例操作一5.4、实例操作二 六、if语句6.1、单分支结构6.1.1 格式6.1.2 原理图：6.1.3 实例操作 6.2、双分支结构6.2.1 格式6.2.2 原理图：6.2.3 实例操作一6.2.4 实例操作二 6.3、多分支结构6.3.1 格式6.3.2 原理图：6.3.3 实例操作 七、case语句结构7.1、格式7.2、实例操作一7.3、实例操作二 八、总结 一、test命令 1.2、格式 测试表达式是否成立，若成立返回0，否则返回其他数值。
格式1： test 条件表达式 格式2： [ 条件表达式 ] 1.2、实例操作 二、文件测试 2.1、格式： 操作符 文件名或者目录名　2.2、常用的测试操作符 -d∶ 测试是否为目录（Directory）
-e∶ 测试目录或文件是否存在（Exist）
-f∶ 测试是否为文件（File）
-r∶ 测试当前用户是否有权限读取（Read）
-w∶ 测试当前用户是否有权限写入（Write）
-x∶测试当前用户是否有权限执行（eXcute）
-L∶测试是否为软链接文件
2.3、实例操作 三、整数值比较 3.1、格式 [ 整数1 操作符 整数2 ] 3.2、常用的测试操作符 -eq∶ 等于（Equal） -ne∶ 不等于（Not Equal） -gt∶ 大于（Greater Than） -lt∶ 小于（Lesser Than） -le∶ 小于或等于（Lesser or Equal）· -ge∶ 大于或等于（Greater or Equal） 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7649b1bee27d2360010acce1cd9935c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f9853ab4d1eb9d2babecdcfcc3eaffe/" rel="bookmark">
			C语言及算法设计课程实验三：最简单的C程序设计——顺序程序设计(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言及算法设计课程实验三：最简单的C程序设计——顺序程序设计 一、实验目的二、 实验内容2.1、实验内容1：通过下面的程序掌握各种格式转换符的正确使用方法 三、 实验步骤3.1、顺序程序设计实验题目1：通过下面的程序掌握各种格式转换符的正确使用方法的实验步骤3.1.1、① 输入以下程序：3.1.2、② 运行此程序并分析结果。3.1.3、③ 在此基础上，将程序第10〜14行改为3.1.4、④ 用`sizeof`运算符分别检测程序中各类型的数据占多少字节。 四、 实验总结五、 实验完整程序5.1、顺序程序设计实验题目1：通过下面的程序掌握各种格式转换符的正确使用方法的完整程序 一、实验目的 （1） 掌握c语言中使用最多的一种语句一赋值语句的使用方法。
（2） 掌握各种类型数据的输入输出的方法，能正确使用各种格式转换符。
（3） 进一步掌握编写程序和调试程序的方法。
二、 实验内容 2.1、实验内容1：通过下面的程序掌握各种格式转换符的正确使用方法 （1）通过下面的程序掌握各种格式转换符的正确使用方法。
① 输入以下程序：
#include &lt;stdio.h&gt; int main() { int a, b; float d, e; char cl, c2; double f, g; long m, n; unsigned int p, q; a = 61; b = 62; cl = 'a'; c2 = 'b'; d = 3.56; e = -6.87; f = 3157.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f9853ab4d1eb9d2babecdcfcc3eaffe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4a046a64027fef84d2580acd684ca9c/" rel="bookmark">
			python代码提高图像照度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好的。你可以使用 Python 的 Pillow 库来提高图像的照度。
你可以这样做：
安装 Pillow 库：在终端/命令行中运行 pip install Pillow。
导入库中的相关模块：from PIL import ImageEnhance。
打开图像：image = Image.open("image.jpg")。
创建一个照度增强器：enhancer = ImageEnhance.Brightness(image)。
提高照度：image = enhancer.enhance(1.5)。这里的数字 1.5 表示提高 5
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc92cbd9ef72b05a33a24440053f4a83/" rel="bookmark">
			FPGA知识汇集-串行 RapidIO: 高性能嵌入式互连技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文摘自：德州仪器网站
串行RapidIO: 高性能嵌入式互连技术 | 德州仪器 (http://ti.com.cn)
串行RapidIO针对高性能嵌入式系统芯片间和板间互连而设计，它将是未来十几年中嵌入式系统互连的最佳选择。
本文比较RapidIO和传统互连技术的优点；介绍RapidIO协议架构，包格式，互连拓扑结构以及串行RapidIO物理层规范。介绍串行RapidIO在无线基础设施方面的应用。
RapidIO 与传统嵌入互连方式的比较
随着高性能嵌入式系统的不断发展，芯片间及板间互连对带宽、成本、灵活性及可靠性的要求越来越高，传统的互连方式，如处理器总线、PCI总线和以太网，都难以满足新的需求 。
处理器总线主要用作外部存储器接口，如德州仪器(TI) C6000系列DSP的外部存储器接口，可支持外接同步SDRAM、SBSRAM及FIFO，也可支持异步SRAM、FLASH等。外部存储器接口也可用作与板内FPGA或ASIC芯片互连，这种情况下，FPGA或ASIC模拟一个DSP支持的存储器接口，DSP则把FPGA或ASIC当作存储器来访问。
这类同步接口带宽可达10Gbps，如德州仪器TMS320C6455 DSP的DDR2接口最大带宽为17.066Gbps，SBSRAM接口最大带宽为8.533Gbps。然而，这种接口也存在一些局限性：
接口管脚多，硬件设计困难。常见的DDR2接口有70～80个管脚；只能用于板内互连，无法用于板间互连；不是点对点的对等互连，DSP始终是主设备，其它器件只能做从设备。 PCI是广泛用于计算机内器件互连的技术。传统PCI技术也采样类似于上述存储器接口的并行总线方式，如TMS320C6455 DSP的PCI接口，有32bits数据总线，最高时钟速度为66MHz，共有42个管脚。
最新的串行PCI Express技术采用与串行RapidIO（SRIO， Serial RapidIO）类似的物理层传输技术，使得带宽达到10Gbps左右。
但由于其主要的应用仍是计算机，而且为了兼容传统PCI技术，使得它在嵌入式设备方面的应用具有一定的局限性，如不支持点对点对等通信等。
众所周知，以太网是使用最广泛的局域网互连技术，它也被扩展应用到嵌入式设备互连，但它的局限性也是显而易见的：
不支持硬件纠错，软件协议栈开销较大；打包效率低，有效传输带宽因此而减小；只支持消息传输模式，不支持对对端设备的直接存储器访问(DMA, Direct Memory Access)。 针对嵌入式系统的需求以及传统互连方式的局限性，RapidIO标准按如下目标被制定：
针对嵌入式系统机框内高速互连应用而设计。简化协议及流控机制，限制软件复杂度，使得纠错重传机制乃至整个协议栈易于用硬件实现。提高打包效率，减小传输时延。减少管脚，降低成本。简化交换芯片的实现，避免交换芯片中的包类型解析。分层协议结构，支持多种传输模式，支持多种物理层技术，灵活且易于扩展。 图1展示了RapidIO互连在嵌入式系统中的应用。
图1 RapidIO在嵌入式系统中的应用
表1总结比较了的三种带宽能达到10Gbps的互连技术：以太网，PCI Express和串行RapidIO，从中可以看出串行RapidIO是最适合高性能嵌入式系统互连的技术。
表1 10G级互连技术比较
串行RapidIO协议
RapidIO行业协会成立于2000年，其宗旨是为嵌入式系统开发可靠的，高性能，基于包交换的互连技术。RapidIO协议的简要发展历史是：
2001年初，最初的标准被发布2002年6月，1.2版标准发布2005年6月，1.3版标注发布 串行RapidIO是物理层采用串行差分模拟信号传输的RapidIO标准。SRIO 1.x 标准支持的信号速度为1.25GHz、2.5GHz、3.125GHz；正在制定的RapidIO 2.0标准将支持5GHz、6.25GHz.
目前，几乎所有的嵌入式系统芯片及设备供应商都加入了RapidIO行业协会。德州仪器(TI) 2001年加入该组织，2003年成为领导委员会成员。2005年底，德州仪器(TI)推出第一个集成SRIO（Serial RapidIO）的DSP，后来又陆续推出共5款支持SRIO的DSP，这使得RapidIO的应用全面启动。
RapidIO协议结构及包格式
为了满足灵活性和可扩展性的要求，RapidIO协议分为三层：逻辑层、传输层和物理层。图2说明了RapidIO协议的分层结构。
图2 RapidIO协议分层结构
逻辑层定义了操作协议；传输层定义了包交换、路由和寻址机制；物理层定义了电气特性、链路控制和纠错重传等。
象以太网一样，RapidIO也是基于包交换的互连技术。如图3所示，RapidIO包由包头、可选的载荷数据和16bits CRC校验组成。包头的长度因为包类型不同可能是十几到二十几个字节。每包的载荷数据长度不超过256字节，这有利于减少传输时延，简化硬件实现。
图3 RapidIO包格式
上述包格式定义兼顾了包效率及组包/解包的简单性。RapidIO交换器件仅需解析前后16bits，以及源/目地器件ID，这简化了交换器件的实现。
逻辑层协议
逻辑层定义了操作协议和相应的包格式。RapidIO支持的逻辑层业务主要是：直接IO/DMA （Direct IO/Direct Memory Access）和消息传递（Message Passing）。
直接IO/DMA模式是最简单实用的传输方式，其前提是主设备知道被访问端的存储器映射。在这种模式下，主设备可以直接读写从设备的存储器。直接IO/DMA在被访问端的功能往往完全由硬件实现，所以被访问的器件不会有任何软件负担。从功能上讲，这一特点和德州仪器DSP的传统的主机接口(HPI, Host Port Interface)类似。但和HPI口相比，SRIO（Serial RapidIO）带宽大，管脚少，传输方式更灵活。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc92cbd9ef72b05a33a24440053f4a83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa6d7944d57547640fb399e1c7d004f8/" rel="bookmark">
			【嵌入式STM32环境搭建】Keil5安装和STM32工程模板搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Keil5安装和STM32工程模板 Keil5安装 STM32入门教程-2022持续更新中_哔哩哔哩_bilibili
网盘提取码：8kzh，链接里压缩包的解压密码：32
STM32库函数版工程模板 搭建好模板，以后就可以直接复制工程来修改，方便快速上手
用keil5新建STM32工程（超详细的图解操作）
建工程文件夹 工程就保存在这里了，以后从这里打开
这几个是建工程时生成的文件夹
启动文件夹Start startup启动文件，上电从这里运行
core内核文件
stm32f103x.h描述STM32寄存器和对应地址
system文件主要用来配置时钟
STM32系列命名规则
STM32 F 103 C 6 T 7 xxx　1 2 3 4 5 6 7 8
第1部分：产品系列名，固定为STM32
第2部分：产品类型；F表示这是Flash产品，目前没有其它选项
第3部分：产品子系列；103表示增强型产品，101表示基本型产品
105表示集成一个全速USB 2.0 Host/Device/OTG接口和两个具有先进过滤功能的CAN2.0B控制器，
107表示在STM32F105系列基础增加一个10/100以太
网媒体访问控制器(MAC)，互联型产品，
第4部分：管脚数目；
T=36脚；　C=48脚；　R=64脚；V=100脚；　Z=144脚
第5部分：闪存存储器容量：
6=32K字节；　8=64K字节；　B=128K字节；　C=256K字节
D=384K字节；　E=512K字节
第6部分：封装信息；
H=BGA；T=LQFP；U=VFQFPN
第7部分：工作温度范围；
6=工业级，-40~+85°C
7=工业级，-40~+105°C
第8部分：可选项；此部分可以没有，可以用于标示内部固件版本号。
启动文件的选择 startup_stm32f10x_cl.s 互联型的器件，STM32F105xx，STM32F107xx
startup_stm32f10x_hd.s 大容量的STM32F101xx，STM32F102xx，STM32F103xx
startup_stm32f10x_hd_vl.s 大容量的STM32F100xx
startup_stm32f10x_ld.s 小容量的STM32F101xx，STM32F102xx，STM32F103xx
startup_stm32f10x_ld_vl.s 小容量的STM32F100xx
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa6d7944d57547640fb399e1c7d004f8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/177/">«</a>
	<span class="pagination__item pagination__item--current">178/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/179/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>