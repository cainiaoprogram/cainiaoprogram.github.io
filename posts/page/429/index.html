<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/245370b7c408d2a25ce69949d7894ae6/" rel="bookmark">
			AndroidStudio|左右滑动切换界面效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过Layout控件捕捉onTouch事件，所以要实现OnTouchListener接口；当用户触摸屏幕的时候，会产生许多手势，这里就包括滑动效果。通过GestureDetector类，我们可以识别很多的手势。所以要实现GestureDetector.OnGestureListener接口，将Touch事件传入GestureDetector对象进行处理。 实现两个接口 public class MyActivity extends Activity implements View.OnTouchListener,GestureDetector.OnGest- ureListener { private RelativeLayout mLinearLayout; private GestureDetector mGestureDetector; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_face_idcard_identify); findView(); } 给控件注册OnTouch事件，并且允许响应长点击事件 private void findView() { mLinearLayout = (RelativeLayout) findViewById(R.id.Face_IDCard_Layout); mLinearLayout.setOnTouchListener(this); mLinearLayout.setLongClickable(true); mGestureDetector = new GestureDetector(this, this); } 实现手势识别接口中的方法 //用户按下屏幕就会触发： @Override public boolean onDown(MotionEvent e) { return false; } //短按触摸屏 @Override public void onShowPress(MotionEvent e) { } //点击屏幕后抬起时触发该事件 @Override public boolean onSingleTapUp(MotionEvent e) { return false; } //在屏幕上拖动控件 @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) { return false; } //长按触摸屏 @Override public void onLongPress(MotionEvent e) { } //滑屏，用户按下触摸屏、快速移动后松开，由1个MotionEvent ACTION_DOWN, 多个ACTION_MOVE, 1个 //ACTION_UP触发；参数分别表示：按下事件、抬起事件、x方向移动速度、y方向移动速度。 @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) { final int FLING_MIN_DISTANCE = 100; final int FLING_MIN_VELOCITY = 200; if (Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/245370b7c408d2a25ce69949d7894ae6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdfaf52f1d886d25c8687df493961a44/" rel="bookmark">
			记录一次Ubuntu服务器MySql数据目录迁移操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 日常检查服务器发现磁盘空间有些不足，大目录主要集中在数据库/var/lib/mysql 下。
一. 计划先清理数据库碎片 1. 查看MySql碎片占用空间
SHOW TABLE STATUS LIKE '表名称'; // DATA_FREE为碎片空间 2. 清理碎片
optimize table 表名称; // 此操作会锁表，如果数据量过大费时较长，谨慎使用。有必要时需提前备份数据 // 清理没啥效果，查来查去就是数据太多了。需要添加磁盘，把原有数据移至新磁盘。 二. 开始迁移数据
1. 复制MySql数据至新目录，先查看MySql数据目录地址
show variables like '%dir%'; // datadir 为目录地址 2. 需要复制至新目录
cp -R srcDir desDir 3. 新目录设置权限
chown mysql:mysql -R desDir 4. 修改MySql配置
vi /etc/mysql/my.cnf // datadir = 添加新目录 5. 重启数据库
sudo /etc/init.d/mysql restart 注：如果重启过程中出现新目录无权限等问题，请参照CLICK URL内容。
三. 数据迁移完毕。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/970209d6a6588b1f10e06ebcb2150f21/" rel="bookmark">
			&amp;times被转义为X的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在PHP中，访问api接口的时候，有个参数为timestamp，在url传输中发现&amp;times会被转义为X,因为在输出的时候有些字符是有特殊的含义的，比如 “&lt;” ,” &gt;”这些字符在html中一般是标签的开始与结束，所以在输出的时候，浏览器做了转码，查看源码的时候发现是对的，那么要让浏览器显示是我们需要的字符，解决的办法有将&amp;times写在参数第一个位置，或者将”&amp;”换成”&amp;amp”后面有英文分号“；”，或者直接使用函数htmlspecialchars。这个函数的作用是把预定义的字符 “&lt;” （小于）和 “&gt;” （大于）转换为 HTML 实体，不用你手动替换，系统函数帮你转换。详细见http://www.w3school.com.cn/php/func_string_htmlspecialchars.asp
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d3566260c637c9f2748f28dc25c991f/" rel="bookmark">
			Android 通过网址url获取网址标题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大多数场景下，我们需要展示一个网页并获取标题时，我们会用webview去load这个url，在onReceiveTitle里获取它的标题。但在某些场景下，我们想直接拿到标题但并不想展示这个网页，毕竟webView也是很吃性能的。 首先我们得获取这个url的html文本，然后从html文本中截取出title，这里我们用两种方式来获取
第一种方式 获取html文本代码
public static String getHtmlContent(String urlpath) throws Exception { URL url = new URL(urlpath); HttpURLConnection conn=null; try { conn = (HttpURLConnection) url.openConnection(); conn.setConnectTimeout(6 * 1000); conn.setRequestMethod("GET"); conn.setInstanceFollowRedirects(true); if (conn.getResponseCode() == 200) { LogUtil.logE("success===200"); InputStream inputStream = conn.getInputStream(); byte[] data = readStream(inputStream); String html = new String(data); return html; }else if(conn.getResponseCode()==301||conn.getResponseCode()==302){//重定向 LogUtil.logE("重定向========"+conn.getResponseCode()); String nestUrl=conn.getHeaderField("Location"); LogUtil.logE("重定向==="+nestUrl); return getHtmlContent(nestUrl); } }catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d3566260c637c9f2748f28dc25c991f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac7936b76ecc27c5d8328c5987212e51/" rel="bookmark">
			【算法】归并排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		壹
基本概念：
归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法的一个非常典型的应用。
排序过程：
将序列分成 n 个有序的子序列，将相邻的有序子序列两两合并，并使合并后的序列内部有序，再对合并后的子序列重复进行上述过程，最后得到完全有序的序列。若将两个有序表合并成一个有序表，称为二路归并。
贰
实例讲解：
有数组 R [ 10 ] = { 5 , 4 , 8 , 0 , 9 , 3，2 , 6，7 , 1 }，另建立一个数组 R1 储存排序后的结果。
第一趟排序（颜色相同为一组序列）：
5 , 4 8 , 0
9 , 3 2 , 6 7 , 1
排序后结果：
4 , 5 , 0 , 8 , 3 , 9 , 2 , 6 , 1 , 7
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac7936b76ecc27c5d8328c5987212e51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/940875838fbb302e6a3fd6e906f31f59/" rel="bookmark">
			Visual Studio 2017修改编码UTF-8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 VS 2017隐藏了高级保存功能，导致没办法直接去设置代码编码 UTF-8。
那么我们直接把高级保存功能调用出来即可：
单击“工具”|“自定义”命令，弹出“自定义”对话框。单击“命令”标签，进入“命令”选项卡。在“菜单栏”下拉列表中，选择“文件”选项。单击“添加命令”按钮，弹出“添加命令”对话框。在“类别”列表中，选择“文件”选项；在“命令”列表中，选择“高级保存选项”选项。单击“确定”按钮，关闭“添加命令”对话框。选中“控件”列表中的“高级保存选项”选项，单击“上移”或者“下移”按钮，调整该命令的位置。单击“关闭”按钮，完成“高级保存选项”命令的添加操作。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/705b49dc4a0e7b0b8319853fb5d8a31c/" rel="bookmark">
			汉字的ASCII码对照表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GB2312和GBK每一个汉字由2个字节组成，这2个字节的ASCII码大小分别是： gb2312:
high8 = 0xa1–&gt;0xfe （161 - 254） low8 = 0xa1–&gt;0xfe （161 - 254）
gbk:
high8 = 0x80–&gt;0xfe （128 - 254） low8 = 0x40–&gt;0xfe （64 - 254）
GB2312和GBK的区别：http://zhidao.baidu.com/question/40269499
汉字ASCII对照表的打印方法：
// 打印ASCII汉字编码表 for(int i = 129; i &lt; 256; ++i) // 129 = 0x81 { for(int j = 64; j &lt; 256; ++j) // 64 = 0x40 { char pchar[3]; pchar[0] = i; pchar[1] = j; pchar[2] = '/0'; cout &lt;&lt; pchar &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/705b49dc4a0e7b0b8319853fb5d8a31c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95036232b71d0e7ff4c5971b7259d0d4/" rel="bookmark">
			PyTorch里的多分类损失函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.leanote.com/post/lincent/PyTorch%E9%87%8C%E7%9A%84%E5%A4%9A%E5%88%86%E7%B1%BB%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0-2
最近大热的PyTorch即将推出1.0版，做为各类深度学习任务的最优框架之一，PyTorch提供了丰富的损失函数，而多分类任务用到最多的就是nn.CrossEntropyLoss和nn.NLLLoss了，不妨讨论一下。
nn.CrossEntropyLoss CrossEntropy顾名思义就是交叉熵，概念来自香农的信息论，用于度量两个概率分布间的差异性信息，可以认为是在给定的真实分布下，使用非真实分布的策略消除系统的不确定性所需要付出的努力的大小。交叉熵越小，证明计算出的非真实分布越接近真实分布。
公式如下：
H(p,q)=−∑k=1N(pk∗logqk)H(p,q)=−∑k=1N(pk∗logqk)
在PyTroch的文档中明确指出它和nn.NLLLoss之间的关系，后面我们会进行测试。
This criterion combines nn.LogSoftmax() and nn.NLLLoss() in one single class.
nn.NLLLoss 全名是负对数似然损失函数（Negative Log Likelihood），在PyTorch的文档中有如下说明：
Obtaining log-probabilities in a neural network is easily achieved by adding a LogSoftmax layer in the last layer of your network. You may use CrossEntropyLoss instead, if you prefer not to add an extra layer.
简单来说，如果最后一层做了log softmax处理，那就直接使用nn.NLLLoss，我们动手试试吧。
以下演示基于0.2.1版
首先我们构造一个网络的输出做为我们的预测值，再构造一个真实分布，一起做为损失函数的输入。
#预测值 inputs_tensor = torch.FloatTensor( [ [10, 0, 3,-1, 1], [-1,-2, 0,-3,-4], [-1, 1, 4, 8, 2] ]) #真实值 targets_tensor = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95036232b71d0e7ff4c5971b7259d0d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7ecf7e84a65d540b37aa0351c063d61/" rel="bookmark">
			别跟我谈EF抵抗并发，敢问你到底会不会用EntityFramework
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有些人号称是对EntityFramwork非常了解，认为不就是增、删、该、查么，但是有的时候用出了问题就开始自我开解，我这么用没有任何问题啊，我们都知道在EF 6.x中确实有很多坑，这个时候就借这个缘由洗白了，这不是我的锅，结果EF背上了无名之锅，妄名之冤。是的，您们没有说错，EF 6.x是有很多坑，您避开这些坑不就得了，我只能说这些人太浮于表面不了解基本原理就妄下结论，你到底会不会用EntityFramework啊。好了来，免说我纸上谈兵，我来举两个具体例子，您们看你到底会不会用。
EntityFramework 6.x查询 static void Main(string[] args)
{
using (var ctx = new EfDbContext())
{
ctx.Database.Log = Console.WriteLine;
var code = "Jeffcky";
var order = ctx.Orders.FirstOrDefault(d =&gt; d.Code == code); };
Console.ReadKey();
}
这样的例子用过EF 6.x的童鞋估计用烂了吧，然后查询出来的结果让我们也非常满意至少是达到了我们的预期，我们来看看生成的SQL语句。
请问用EF的您们发现什么没有，在WHERE查询条件加上了一堆没有用的东西，我只是查询Code等于Jeffcky的实体数据，从生成的SQL来看可查询Code等于Jeffcky的也可查询Code等于空的数据，要是我们如下查询，生成如上SQL语句我觉得才是我们所预期的对不对。
using (var ctx = new EfDbContext())
{
ctx.Database.Log = Console.WriteLine;
var code = "Jeffcky";
var orders = ctx.Orders.Where(d =&gt; d.Code == null || d.Code == code).ToList();
};
如果您真的会那么一点点用EntityFramework，那么请至少了解背后生成的SQL语句吧，这是其中之一，那要是我们直接使用值查询呢，您们觉得是否和利用参数生成的SQL语句是一样的呢？
using (var ctx = new EfDbContext())
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7ecf7e84a65d540b37aa0351c063d61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ceb4fc2730010f2f39711f7da6d2f60/" rel="bookmark">
			CentOS 7网卡配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以root权限编辑/etc/sysconfig/network-scripts/ifcfg-eno16777736这个文件
TYPE=Ethernet //网络类型：Ethernet以太网 BOOTPROTO=none //引导协议：自动获取、static静态、none不指定 DEFROUTE=yes //启动默认路由 IPV4_FAILURE_FATAL=no //不启用IPV4错误检测功能 IPV6INIT=yes //启用IPV6协议 IPV6_AUTOCONF=yes //自动配置IPV6地址 IPV6_DEFROUTE=yes //启用IPV6默认路由 IPV6_FAILURE_FATAL=no //不启用IPV6错误检测功能 NAME=eno16777736 // 网卡设备的别名 UUID=90528772-9967-46da-b401-f82b64b4acbc //网卡设备的UUID唯一标识号 DEVICE=eno16777736 // 网卡的设备名称 ONBOOT=yes //开机自动激活网卡 DNS1=6.6.6.6 //DNS域名解析服务器的IP地址 IPADDR=192.168.1.199 //网卡的IP地址 PREFIX=24 //子网掩码 GATEWAY=192.168.1.1 //默认网关IP地址 IPV6_PEERDNS=yes IPV6_PEERROUTES=yes IPADDR=192.168.2.2 #你想要设置的固定IP，理论上192.168.2.2-255之间都可以，请自行验证； NETMASK=255.255.255.0 #子网掩码，不需要修改； GATEWAY=192.168.2.1 #网关，这里是你在“2.配置虚拟机的NAT模式具体地址参数”中的 （2）重启网络服务
service network restart 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30465facdde17fdc12c76f96f5b189ca/" rel="bookmark">
			浅谈常用ADC的工作原理与选型！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在的软件、无线电、数字图像采集都需要有高速的A/D采样保证有效性和精度，一般的测控系统也希望在精度上有所突破，人类数字化的浪潮推动了A/D转换器不断变革，而A/D转换器是人类实现数字化的先锋。A/D转换器发展了30多年，经历了多次的技术革新，从Flash、SAR、积分型ADC，到近年来新发展起来的 ∑-Δ型 和 Pipeline ADC，它们各有其优缺点，能满足不同的应用场合的使用。
ADC的工作原理 模拟信号转换为数字信号,一般分为4个步骤进行,即采样、保持、量化和编码。前2个步骤在采样-保持电路中完成,后两步骤则在ADC中完成。ADC是把经过与标准量比较处理后的模拟量转换成以二进制数值表示的离散信号的转换器。故任何一个模数转换器都需要一个参考模拟量作为转换的标准，比较常见的参考标准为最大的可转换信号大小。而输出的数字量则表示输入信号相对于参考信号的大小。
ADC的分类 1、Σ-Δ ADC
越来越多的应用，诸如过程控制、称重等，都需要高分辨率、高集成度和价格低廉的ADC。新型Σ-Δ转换技术恰好可以满足上述需求。然而，很多设计者并不十分了解这种AD转换技术，因而更愿意选用传统的逐次比较（SAR）型ADC。Σ-Δ转换器的模拟部分非常简单（类似于一个1位ADC），而数字部分要复杂得多，按照功能可划分为数字滤波和抽取单元。由于Σ-Δ型ADC更接近于数字器件，因而其制造成本非常低廉。
Σ-Δ ADC的工作原理
要理解Σ-Δ型ADC的工作原理，首先应对以下概念有所了解：过采样、噪声成形、数字滤波和抽取。1. 过采样 首先，考虑一个传统ADC的频域传输特性。输入一个正弦信号，然后以频率Sf采样，按照Nyquist定理，采样频率至少倍于输入信号。从FFT分析结果可以看到，一个单音和一系列频率分布于DC到S2f间的随机噪声，如图1所示，这就是所谓的量化噪声，主要是由于有限的ADC分辨率而造成的
图1
单音（基频）信号的功率与所有频率的噪声的RMS功率之和的比值就是信号噪声比（SNR）。对于一个N位ADC，SNR可由公式：SNR=6.02N+1.76dB得到。为了改善SNR和更为精确地再现输入信号，对于传统ADC来讲，必须增加位数。
如果将采样频率提高一个过采样系数k，即采样频率为Skf，再来讨论同样的问题，如图2所示，FFT分析显示噪声基线降低了，SNR值虽未改变，但噪声能量却分散到更宽的频率范围。Σ-Δ转换器正是利用了这一原理，具体方法就是在1位ADC之后进行数字滤波。如图3所示，由于大部分噪声位于数字滤波器带宽之外而被滤除，这样，RMS噪声就降低了，使得Σ-Δ转换器能够从一个低分辨率ADC获得宽动态范围
图2
图3
那么，简单的过采样和滤波能否改善SNR呢？一个1位 ADC的SNR为7.78dB（6.02+1.76），每4倍过采样可以使SNR增加6dB，SNR每增加6dB等效于分辨率增加1-bit。这样，采用1位 ADC进行64倍（即34倍）过采样可以获得4位分辨率，而要获得16位分辨率就必须进行154倍过采样，这是不切实际的。Σ-Δ转换器采用噪声成形技术消除了这种局限，使得每4倍过采样可增加高于6dB的SNR.
2、SAR型ADC(又名逐次比较型)
数年以来，逐次逼近型ADC一直是数据采集系统的主要依靠。近期设计改良使这类ADC的采样频率扩展至兆赫领域且分辨率为18位。ADI公司的PulSAR®系列SAR ADC采用内部开关电容技术和自动校准，以CMOS工艺实现18位、2 MSPS性能(AD7641)，而无需进行昂贵的薄膜激光调整。在16位级别，AD7625(6 MSPS)和AD7626(10 MSPS)还代表着突破性的技术。
图4
逐次比较型ADC
1.转换方式直接转换ADC
2.电路结构逐次逼近ADC包括n位逐次比较型A/D转换器如图4所示。它由控制逻辑电路、时序产生器、移位寄存器、D/A转换器及电压比较器组成。图4逐次比较型A/D转换器框图
3.工作原理逐次逼近转换过程和用天平称物重非常相似。天平称重物过程是，从最重的砝码开始试放，与被称物体行进比较，若物体重于砝码，则该砝码保留，否则移去。再加上第二个次重砝码，由物体的重量是否大于砝码的重量决定第二个砝码是留下还是移去。照此一直加到最小一个砝码为止。将所有留下的砝码重量相加，就得此物体的重量。仿照这一思路，逐次比较型A/D转换器，就是将输入模拟信号与不同的参考电压作多次比较，使转换所得的数字量在数值上逐次逼近输入模拟量对应值。
对图4的电路，它由启动脉冲启动后，在第一个时钟脉冲作用下，控制电路使时序产生器的最高位置1，其他位置0，其输出经数据寄存器将1000……0，送入D/A转换器。输入电压首先与D/A器输出电压（VREF/2）相比较，如v1≥VREF/2，比较器输出为1，若vI&lt; VREF/2，则为0。比较结果存于数据寄存器的Dn-1位。然后在第二个CP作用下，移位寄存器的次高位置1，其他低位置0。如最高位已存1，则此时vO=（3/4）VREF。于是v1再与（3/4）VREF相比较，如v1≥（3/4）VREF，则次高位Dn-2存1，否则Dn-2=0；如最高位为0，则vO=VREF/4，与vO比较，如v1≥VREF/4，则Dn-2位存1，否则存0……。以此类推，逐次比较得到输出数字量
总结
SAR ADC架构是一种完善、有效且易于理解的架构，非常适合现代细线CMOS工艺。该架构没有“流水线”延迟，因此非常适合单发和多路复用数据采集应用。CMOS工艺允许添加各种各样的数字功能，如自动通道时序控制和自动校准等。此外，许多SAR ADC拥有片上温度传感器和基准电压源。虽然SAR ADC源自16世纪的数学谜团，但是其仍然是现代多通道数据采集系统所青睐的转换器。
3.flash型ADC
早在上世纪60、70年代，商用_ash转换器就开始出现在仪器仪表和模块中，并在80年代期间快速进军集成电路。单芯片8位_ash ADC成为上世纪80年代数字视频应用的行业标准。如今，_ash转换器主要用作分级“流水线式”ADC中的构建模块。流水线架构的功耗和成本更低，并且能够以数百MHz的采样速率实现8至10位分辨率。因此，功耗较高的独立flash转换器主要用于采样速率超过1 GHz的6位或8位ADC。这些转换器通常采用砷化镓工艺设计。
图5 Flash型ADC原理框图
鉴于其作为高分辨率流水线ADC中构建模式的重要性，还需要了解基础flash转换的基本原理。Flash ADC（有时称为“并行”ADC）是速度最快的ADC，其中使用数个比较器。一个N位flash ADC包括2N个电阻和2N – 1个比较器，具体排列方式如图4所示。每个比较器均从电阻串获得基准电压，且每个基准电压要比链中的下一个基准电压大1 LSB。对于给定输入电压，低于某个点的所有比较器都将出现输入电压高于基准电压且逻辑输出为"1"，而高于该点的所有比较器则都将出现基准电压高于输入电压且逻辑输出为"0"。因此，2N – 1个比较器输出在行为上类似于水银温度计，而该点的输出码有时称为“温度计”码。由于2N – 1个数据输出并不便于实际应用，因此需要经过解码器处理来产生N位二进制输出。
由于flash转换器采用了大量电阻和比较器且限制在低分辨率，因此如果达到较高速度，每个比较器就必须以相对较高的功耗水平运行。因此flash ADC的问题包括分辨率有限、因使用大量高速比较器(尤其是采样速率超过50 MSPS时)而导致功耗较高和相对较大(因此成本较高)的芯片尺寸。此外，基准电阻链的电阻必须保持在较低水平，以便向快速比较器提供足够的偏置电流，因此基准电压源必须提供较大的源电流(通常大于10 mA)。
4、计数ADC
计数ADC虽然不太适合高速应用，但却是高分辨率低频应用的理想之选，特别是结合使用双斜式积分、三斜式积分、四斜式积分等技术时。
图6
计数ADC技术的基本原理是利用一个采样脉冲对模拟信号进行采样，然后设置一个R/S触发器，同时启动一个受控斜坡电压。该斜坡电压与输入进行比较，当二者相等时，就会产生一个脉冲以复位R/S触发器。触发器的输出是一个脉冲，其宽度与采样时刻的模拟信号成正比。该脉宽调制(PWM)脉冲控制一个选通振荡器，选通振荡器输出的脉冲数量代表模拟信号的量化值，通过一个计数器很容易将该脉冲串转换成一个二进制字。Reeves的系统使用600 kHz的主时钟，100:1分频器产生6 kHz的采样脉冲。该系统采用5位计数器，因而采样脉冲之间的100个脉冲中的31个脉冲代表一个满量程信号。显然，可以将该计数扩展到更高的分辨率。
ADC的重要参数及选型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30465facdde17fdc12c76f96f5b189ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6cf46deca6b81fe21988474b973ca05/" rel="bookmark">
			推荐一款实时翻译软件，通过鼠标进行翻译，小巧实用。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于英语不好的朋友们，在阅读英文文档的时候难免出现自己很陌生的单词，这个时候是把单词复制到google、百度、有道？
今天给大家推荐一个小巧又实用的软件——QTranslate(点击访问官网)；
好像在官网的时候要进行一个google账号登陆，登陆以后才能下载最新版(写博客是最新版为6.7.0)，具体能不能下载最新的个人可以先进官网看看，如果下载的时候需要google账号登陆，下方我会给一个网盘地址；
如果有google账号的伙伴就可以在官网进行下载，没有的也不要紧——点击百度云下载安装包； 链接: 密码: ki62
使用技巧及设置： 下文使用QT代替QTranslate哈
1、启动软件以后不会弹出任何窗口，默认直接在右下角的托盘进行显示：
2、右键点击QT—》选择—》基本
在“基本中”几乎是默认设置可以不用管，如果不是默认设置，建议将“第一语言”改为 Chinese(Simplified)简体中文
3、快捷键：
a、在鼠标左键选中文本后，按两次Ctrl 就可以进行翻译了
效果：
可以看到我选择了Translate 按两次 ctrl后，出现了主窗口在这里要 注意一个地方，第二个箭头的位置，前面 google代表翻译的软件，后面English to Chinese 代表英译汉，如果不是，请点击然后进行选择自己想要的翻译。
b、翻译与字典
Ctrl+Q进行翻译：
Ctrl+Shift+Q进行查字典：
也可以在Ctrl+Q出现的框里点击一个字典的图标，也能进行翻译。
注意：翻译或者查询字典的时候，如果没有进行翻译，查看自己是否设置正确，或者点击下方的
软件进行翻译软件的选择：
以上就是常规的设置，其他的功能不影响使用，就不说了。
点击：官网
点击：百度网盘 请输入提取码 密码：haf6
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab0006d6dbf18c35d3598d0bde9ac8fe/" rel="bookmark">
			Spring之AOP在鉴权和日志记录中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鉴权 假设现有需求，要求如下:
可以定制地为某些指定的 HTTP RESTful api 提供权限验证功能.
当调用方的权限不符时, 返回错误.
根据上面所提出的需求, 我们可以进行如下设计:
提供一个特殊的注解 AuthChecker, 这个是一个方法注解, 有此注解所标注的 Controller 需要进行调用方权限的认证.
利用 Spring AOP, 以 @annotation 切点标志符来匹配有注解 AuthChecker 所标注的 joinpoint.
在 aspect中, 简单地检查调用者请求中的 Cookie 中是否有我们指定的 token, 如果有, 则认为此调用者权限合法, 允许调用, 反之权限不合法, 范围错误.
根据上面的设计, 我们来看一下具体的源码吧.
首先是定义一个 AuthChecker 注解:
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface AuthChecker { } AuthChecker 注解是一个方法注解, 它用于标注在需要进行鉴权的服务方法上
有了注解的定义, 那我们再来看一下 aspect 的实现吧:
AuthAspect.java
@Component @Aspect public class AuthAspect { private static final Log LOG = LogFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab0006d6dbf18c35d3598d0bde9ac8fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f309f7df1db7e538a1465d9e69626a1/" rel="bookmark">
			ubuntu ll 命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ubuntu ll命令 1、用过 Redhat 或者Centos 的朋友应该很熟悉 ll 这个命令，就相当于 ls -l，但在 Ubuntu 中要么不能用，要么会显示隐藏文件，看起来很烦。
2、严格来说 ll 不是一个命令，只是命令的别名而已。很多 Linux 用户都使用 bash shell，对普通用户来说用得最多的就是命令补全 (按 tab 键) 和 alias (别名) 功能。Ubuntu 默认建立的用户都用的 bash shell，所以它也支持别名功能。
3、无论ll命令是不能用，还是显示隐藏文件，只需要简单几操作就可以啦 （1）打开用户目录下的 .bashrc文件
$ vim ~/.bashrc （2）找到下面几行
#alias ll='ls -alF' alias la='ls -A' alias l='ls -CF' 去掉 #alias ll=’ls -alF’ 前面的 #，并将第一行改成
alias ll='ls -l' （3）执行以下命令使 .bashrc文件的修改生效
source ~/.bashrc 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26289d523e7d8358d5d49edb6784010b/" rel="bookmark">
			sql性能查询语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查询系统中最耗时的 SQL
select * from ( select * from V$SQLSTATS -- 最耗时的 SQL -- ELAPSED_TIME 指的是总耗时（毫秒），平均耗时 = ELAPSED_TIME/EXECUTIONS -- order by ELAPSED_TIME DESC -- 查询执行次数最多的 SQL -- order by EXECUTIONS DESC -- 读硬盘最多的 SQL -- order by DISK_READS DESC -- 最费 CPU 的 SQL -- order by BUFFER_GETS DESC ) where rownum &lt;=50; 查询次数最多：
select * from (select s.SQL_TEXT, s.EXECUTIONS "执行次数", s.PARSING_USER_ID "用户名", rank() over(order by EXECUTIONS desc) EXEC_RANK from v$sql s left join all_users u on u.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26289d523e7d8358d5d49edb6784010b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fa0fc6f45d60419e13de1bf147469b7/" rel="bookmark">
			Ubuntu 16.04安装docker详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因需要安装opendronemap,而这个依赖于docker,所以记录了一下安装docker的步骤,比较简单.通过apt的docker官方源安装最新的Docker CE(Community Edition)，即Docker社区版，是开发人员和小型团队的理想选择。
另外，如果下载速度过慢，只有几十KB/s，那可能是源有问题。在按照本教程安装的时候，可以选择其他源，具体的方法，评论区有。如果下载速度为0，那可能也是源的问题，也可能是IP的问题。具体原因见下图。
开始安装 由于apt官方库里的docker版本可能比较旧，所以先卸载可能存在的旧版本： $ sudo apt-get remove docker docker-engine docker-ce docker.io 更新apt包索引： $ sudo apt-get update 安装以下包以使apt可以通过HTTPS使用存储库（repository）： $ sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common 添加Docker官方的GPG密钥： $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 使用下面的命令来设置stable存储库： $ sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" 再更新一下apt包索引： $ sudo apt-get update 安装最新版本的Docker CE： $ sudo apt-get install -y docker-ce 验证docker 查看docker服务是否启动： $ systemctl status docker 若未启动，则启动docker服务： $ sudo systemctl start docker 经典的hello world： $ sudo docker run hello-world 有以上输出,表示docker安装成功.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fa0fc6f45d60419e13de1bf147469b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8d02ead81fd5c50aab3ef096469189c/" rel="bookmark">
			java中读出xml中里面配置的属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、xml属性文件书写
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;root&gt; &lt;mapping id="bpm" label=""&gt; &lt;!--bpm地址--&gt; &lt;item key="BMPURL" value="http://127.0.0.1/BpmSite/" desc_en=""/&gt; &lt;item key="a01" value="3dac215391784225a29799cbb8db020b" desc_en=""/&gt; &lt;item key="a02" value="7e798bd9d5b24a619fd1a6a80eb4e10b" desc_en=""/&gt; &lt;item key="a03" value="a96d76616fc34202b53f623fc3a535d5" desc_en=""/&gt; &lt;item key="a04" value="df69b42b060c455baa96d39ac9fb0880" desc_en=""/&gt; &lt;item key="a07" value="0187dcf59cea43bfbcb135776106f571" desc_en=""/&gt; &lt;item key="a05" value="b641fca1cfde49eb824226b2fb979657" desc_en=""/&gt; &lt;item key="a06" value="7f9dfeb4de084003bff0f210326ad5d9" desc_en=""/&gt; &lt;item key="a055" value="a0ca4b6b23e44a20938c5251e0a47639" desc_en=""/&gt; &lt;item key="a066" value="5bbab17158fb40719aa66bd08dc84a8b" desc_en=""/&gt; &lt;item key="a10" value="7a6d0628c63148038549d8356e4614e4" desc_en=""/&gt; &lt;item key="a14" value="eca3c0cec4794d2ea232a8ba8d387e3a" desc_en=""/&gt; &lt;item key="a15" value="28b920cf65d44deb987ee13ee668ae6d" desc_en=""/&gt; &lt;item key="a16" value="877b70e978e641cbb209283dfadb9ee1" desc_en=""/&gt; &lt;item key="a17" value="b6d7df2429fa4906bdf686cebecfa5c5" desc_en=""/&gt; &lt;item key="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8d02ead81fd5c50aab3ef096469189c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fed5253dd47008c40625e85738c8626/" rel="bookmark">
			h3c路由器查看在线用户数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令如下：
display arp all count
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3539cd59fea549a084ba3dd1e00e04d1/" rel="bookmark">
			【Linux】Linux多线程技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux多线程概念 线程的概念 线程是计算机科学中的一个术语，是指运行中的程序的调度单位。一个线程指的是进程中一个单一顺序的控制流，也称为轻量进程。它是系统独立调度和分配的基本单位。同一进程中的多个线程将共享该进程中的全部系统资源，例如文件描述符和信号处理等。一个进程可以有很多线程，每个线程并行执行不同的任务。
线程与进程的区别 根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位；在开销方面：每个进程都必须给它分配独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段。而运行于同一进程的线程使用相同的地址空间，共享大部分数据，启动一个线程的代价也远远小于进程的代价；在通信机制方面：对于不同的进程之间，它们具有独立的数据空间，数据进行传递只能通过通信的方式进行，这种方式不仅耗时，而且不方便。但同一进程下的线程之间共享数据空间，通信很方便且安全；所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）；内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源；包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 Linux的线程实现 Linux系统下的多线程遵循POSIX线程接口，称为pthread。编写Linux下的多线程程序，需要使用头文件pthread.h，连接时需要使用库libpthread.a。Linux下pthread是通过系统调用clone()来实现的。clone()是Linux所特有的系统调用，它的使用方式类似于fork()。
线程创建 int pthread_create(pthread_t * restrict tidp, const pthread_attr_t * restrict attr, void *(* start_rm)(void *), void *restrict arg ); 函数说明：tidp参数是一个指向线程标识符的指针，当线程创建成功后，用来返回创建的线程ID；attr参数用于指定线程的属性，NULL表示使用默认属性；start_rtn参数为一个函数指针，指向线程创建后要调用的函数，这个函数也称为线程函数；arg参数指向传递给线程函数的参数。
返回值：线程创建成功则返回0，发生错误时返回错误码。
因为pthread不是Linux系统的库，所以在进行编译时要加上-lpthread，例如：
# gcc filename -lpthread 在代码中获得当前线程标识符的函数为：pthread_self()。
例子：
#include &lt;pthread.h&gt; void * run(void){ printf("pthread id = %d\n", pthread_self()); return NULL; } int main() { int ret; pthread_t tid; ret = pthread_create(&amp;tid, NULL, run, NULL); if(ret){ printf("pthread create error"); return 1; } } 线程退出 void pthread_exit(void * rval_ptr); 函数说明：rval_ptr参数是线程结束时的返回值，可由其他函数如pthread_join()来获取。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3539cd59fea549a084ba3dd1e00e04d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f962f6dd5e2af0351722f6dd082f8a4a/" rel="bookmark">
			easyui  editor模式  为datagrid的单元格添加点击事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var dangerousInfoTextbox = $('#tbContainer').datagrid('getEditor',{index:target,field:'dangerousInfo'}).target; dangerousInfoTextbox.textbox('textbox').bind("click", function () { $('#undgDialog').dialog('open').dialog('setTitle','危货信息'); }) 因为textbox没有单独的点击事件，例如onclick.... 所以我们可以为此单元格绑定一个点击事件“click”。
首先我们应该对此datagrid开启编辑的模式，以此获取我们需要的单元格，然后对此单元格绑定点击事件。
我的功能是点击表格中的一个textbox打开一个dialog
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e97c5be3b432db6a0cab5a4e908f64ee/" rel="bookmark">
			Andorid音频底层调试工具tinymix，tinyplay，tinycap的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于ALSA架构太过于庞大，对于嵌入式设备而言很多功能用不到，且会增加功耗，所以Android采用了精简后的tinyalsa，tinyalsa相关的底层调试工具常用的有tinymix，tinyplay，tinycap，下面分别介绍他们的使用方法。
tinymix tinymix可以查看系统的音频控件，可直接执行tinymix进行查看。tinymix更多的作用的是用来手动设置控件的值，控件可通过tinymix查看，或者通过mixer_paths.xml进行查看。下面以手动设置speaker相关控件为例进行说明tinymix的使用方法：
mixer_paths.xml文件中speaker相关控件如下：
&lt;path name="speaker"&gt; &lt;ctl name="RX3 MIX1 INP1" value="RX1" /&gt; &lt;ctl name="LINE_OUT" value="Switch" /&gt; &lt;ctl name="SPK" value="Switch" /&gt; &lt;/path&gt; 下面以手动设置speaker相关控件为例进行说明tinymix的使用方法，如下，第一个参数为控件名，第二个参数为控件值
tinymix "RX3 MIX1 INP1" "RX1" tinymix "LINE_OUT" "Switch" tinymix "SPK" "Switch" tinymix加控件名可以查看控件的值，如想查看"LINE_OUT"的值，可执行tinymix "LINE_OUT"
tinyplay 可以使用tinyplay直接进行播放wav格式文件，在播放之前需要先使用tinymix进行相关控件的设置，下面以speaker为例进行说明，注意最后一行需要加上，代表打开I2S的播放控件。
tinymix "RX3 MIX1 INP1" "RX1" tinymix "LINE_OUT" "Switch" tinymix "SPK" "Switch" tinymix "PRI_MI2S_RX Audio Mixer MultiMedia5" "1" 设置好上面控件后，执行tinypaly xxx.wav即可进行音频的播放
tinycap tinycap是用来录音的，使用之前也需要先设置录音相关的控件，以主mix为例进行过说明，注意最后一行是打开I2S的录音控件
tinymix "ADC1 Volume" "6" tinymix "DEC1 MUX" "ADC1" tinymix "IIR1 INP1 MUX"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e97c5be3b432db6a0cab5a4e908f64ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2fca6cacc162177866b1f3bbfde6dbe/" rel="bookmark">
			app版windows95
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近发现一个好玩的应用程序，那就是app版的windows95。
这个程序支持Linux，windows，macos三个系统安装，下载链接在文末。
看到开机画面，想起初中那会，那会有大部分是win98，一个学期也就能去几节课的电脑室，那时候特别渴望能自己有一台。
有4个游戏，都是经典游戏啊
扫雷，当初怎么也玩不明白，就靠运气随便点，也玩不过，但就是能玩到电脑就是开心。
纸牌，现在也不怎么会玩。
最后，来一张沿用至今的“我的电脑”，也是回忆满满。
下载链接：
为了方便，我下载了一份到自己的访问，这样就不用翻墙出去下载了
下载链接：国内服务器下载
githua作者：windows95
阿里云优惠：长期有效
企业高性能云首购5折：点我点我
突发性实例特价，1核1G，1年仅需293：点我查看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c3ae5986ab5d475b6f32af3603c646/" rel="bookmark">
			数据表设计思想，ER图及三范式。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据表设计思想 设计流程 需求分析：根据用户的需求，分析出需要记录的数据
需求设计：根据分析出的数据，设计E-R模型图
详细设计：将E-R模型图转换成数据表
三大范式：使用数据库三大范式的设计思想对数据表进行审核
E-R模型图 概念：Entity-Relationship,实体关系图
组成元素：
举例，将下面三张表用E-R模型图表示出来
三大范式 概念：三大范式是数据库的一种设计规范，主要用来检查我们的数据库是否存在冗余数据。
第一范式：每一列都具有原子性，也就是不能再分割
第二范式：要求每一个表，只描述一件事情
第三范式：要求表中不存在冗余字段
create table Score ( sId int primary key auto_increment, studentId int not null, english float, math float ) create table teacher ( tId int auto_increment primary key, tName varchar(50) not null, tSex char(2), tAge int, tSalary decimal ) create table Class ( cId int auto_increment primary key, cName nvarchar(50) not null, cDesciption text ) create table Student ( SId int auto_increment primary key, SName varchar(50), SGender char(2) not null, SAddress varchar(300), SPhone varchar(100), SAge int, SBirthday datetime, SCardId varchar(18) null, SClassId int not null ) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9601c6d455ad936a8e16c7205f84fde5/" rel="bookmark">
			MyBatis 注解多对多
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例：测试多对多关联 根据数据模型，分别创建t_user、t_order、t_item表。
然后，输入以下测试数据。
程序清单：com.po.User.java
package com.po; public class User { private Integer userId; private String userName; private String userSex; private String userAddress; public Integer getUserId() { return userId; } public void setUserId(Integer userId) { this.userId = userId; } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public String getUserSex() { return userSex; } public void setUserSex(String userSex) { this.userSex = userSex; } public String getUserAddress() { return userAddress; } public void setUserAddress(String userAddress) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9601c6d455ad936a8e16c7205f84fde5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b1a1ce47f8be564cc77bb81b390178f/" rel="bookmark">
			vector函数总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		觉得vector用处蛮多的，所以特地稍微总结一下
1、基本操作 ((1)头文件#include&lt; vector &gt;. (2)创建vector对象，vector&lt; int &gt; vec; (3)尾部插入数字：vec.push_back(a); (4)使用下标访问元素，cout&lt;&lt; vec[0] &lt;&lt; endl;记住下标是从0开始的。 (5)使用迭代器访问元素.
vector&lt;int&gt;::iterator it; for(it=vec.begin();it!=vec.end();it++) cout&lt;&lt;*it&lt;&lt;endl; (6)插入元素： vec.insert(vec.begin()+i,a);在第i+1个元素前面插入a; (7)删除元素： vec.erase(vec.begin()+2);删除第3个元素 vec.erase(vec.begin()+i,vec.end()+j);删除区间[i,j-1];区间从0开始 (8)向量大小:vec.size(); (9)清空:vec.clear();
2、函数 (1) 使用reverse将元素翻转：需要头文件#include&lt; algorithm &gt; reverse(vec.begin(),vec.end());将元素翻转(在vector中，如果一个函数中需要两个迭代器， 一般后一个都不包含.) (2)使用sort排序：需要头文件#include&lt; algorithm &gt;， sort(vec.begin(),vec.end());(默认是按升序排列,即从小到大). 可以通过重写排序比较函数按照降序比较，如下： 定义排序比较函数： bool Comp(const int &amp;a,const int &amp;b) { return a&gt;b; } 调用时:sort(vec.begin(),vec.end(),Comp)，这样就降序排序。
3、vector的创建 vector&lt; int&gt; A; //创建一个空的的容器 vector&lt; int &gt; B(10,100); //创建一个个元素,每个元素值为 vector&lt; int &gt; C(B.begin(),B.end()); //使用迭代器,可以取部分元素创建一个新的容器 vector&lt; int &gt; D(C); //复制构造函数,创建一个完全一样的容器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b1a1ce47f8be564cc77bb81b390178f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/789d392fbeb3f491963bede6b6a869a6/" rel="bookmark">
			字符串/字节互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #bytes object byte = b"byte example" # str object str = "str example" # str to bytes 字符串转字节 bytes(str, encoding="utf8") # bytes to str 字节转字符串 str(bytes, encoding="utf-8") # an alternative method # str to bytes 字符串转为字节 str.encode(str) # bytes to str 字节转为字符串 bytes.decode(bytes) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bdbfbacdc2f19864656d7b9c8975973/" rel="bookmark">
			Latex修改全局字体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果使用的是XeTeX 或者 LuaTeX编译器的话，可以直接使用fontspec宏包。用\setmainfont引入就可以了。
但如果使用的是pdfLatex的话就不适用了，此时修改字体只能针对latex自带的三个字体族，详情可以看这里.
引用原文如下：
These families can generally be grouped into three main categories: serif, sans serif, and monospaced. LaTeX commands generally refer to these with the shorthand rm, sf, and tt respectively.
使用命令
\renewcommand{\familydefault}{&lt;family&gt;} 可以进行字体设置，&lt;family&gt;可以是
\rmdefault\sfdefault\ttdefault 里的其中一个。
对应的效果分别为
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/021f9ab510d8418765fdee8f66706601/" rel="bookmark">
			Java程序员涨薪必备技能（1-3年必看！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作1-3年，当我们向老板提出加薪的时候，或者跳槽去“捡”offer的时候，我们底气够吗？
敢不敢不给涨薪就“挥一挥衣袖，不带走一个bug”？是不是提出要求后你的主管、经理立刻同意，为了把你留住。
然而，现实往往是...
互联网公司面试道路又长且阻，技术面少的两轮，多的五六轮
技术不过硬，其他的都免谈。
如何才能持续成长呢？是每一个程序员都绕不开的话题。
你有没有发现，身边总有人成长的特别快，总是先人一步？
当你正在困惑与技能方向的选择时，他已经掌握了高效率的进阶方法；当你还在苦恼于Bug的调试与修复时，他已经度档一面，处理更为复杂的项目了；当你还在思考自己的技术人生，寻求突破和上升，他已经成为骨干，拿高薪带小团队了。
问题来了，他是怎么做到的？
向大家推荐——程序员进阶小攻略
一、互联网工程与工具
工欲善其事必先利其器，不管是小白，还是资深开发，玩Java技术体系，选择好的工具，提升开发效率和团队协作效率，是必不可少的：
Maven，项目管理
Jenkins，持续集成
Sonar，代码质量管理
Git，版本管理
二：源码分析
学习Java技术体系，流行的框架与组件是必不可少的：
Spring5，做应用必不可少的最新框架
SpringMVC，必不可少的应用框架
MyBatis，玩数据库必不可少的组件
三：并发编程
高并发，高可用，海量数据，没有分布式的架构知识肯定是玩不转的：
四：分布式框架
分布式架构原理
分布式架构策略
分布式中间件
分布式架构实战
五：微服务架构
业务越来越复杂，服务分层，微服务架构是架构升级的必由之路，Java技术体系，和微服务相关的技术有哪些呢？
微服务框架
Spring Cloud
Docker与虚拟容器
如何一起学习，有没有免费资料？
对Java技术，架构技术感兴趣的同学，加木兰小姐姐微信，一起学习，相互讨论，免费获取学习资料。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a96ce5758a3922abfb3fc0b3331bdab/" rel="bookmark">
			CV模型论文公式转换代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cv模型能量函数：
又可写成：
C1、C2公式：
代码：
mu=1；nu=0.003 * 255 * 255；epison=1；step=0.1；pi=3.14159265；
//Img：原图 LSF：生成图
Mat Drc = (epison / pi) / (epison*epison+ LSF.mul(LSF)); //Dirac 函数
//mul函数：mul会计算两个Mat矩阵对应位的乘积，所以要求参与运算的矩阵A的行列和B的行列数一致。计算结果是跟A或B行列数一致的一个Mat矩阵。
Mat Hea = 0.5*(1 + (2 / pi)*atan(LSF/epison)); //Heaviside 函数
//atan：自定义函数计算矩阵的反三角函数
Mat Length = nu*Drc.mul(cur);
Mat Lap;
Laplacian(LSF, Lap, CV_32FC1);//Laplacian调和算子
Mat Penalty = mu*(Lap - cur);
Scalar S1;//Scalar是一个由长度为4的数组作为元素构成的结构体，Scalar最多可以存储四个值，没有提供的值默认是0。如果使用的图像是1通道的，则s.val[0]中存储数据；如果使用的图像是3通道的，则s.val[0]，s.val[1]，s.val[2]中存储数据。
S1 = sum(Hea.mul(Img));
Scalar S2;
S2 = sum(Hea);
float C1 = S1.val[0] / S2.val[0];
Scalar S3;
S3 = sum((1 - Hea).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a96ce5758a3922abfb3fc0b3331bdab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70a5d4d5435fa77bd57b3cc445f92ce4/" rel="bookmark">
			shell 猜商品价格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/bin/bash
aaa=$(expr $RANDOM % 1000)
bbb=0
echo "商品价格为0-999，猜实际价格"
while true
do
read -p "请输入你猜的及价格： " n
((bbb++))
if [ $aaa -eq $n ]
then
echo "恭喜你答对了！！！"
echo "你一共答了$bbb 次"
exit 0
elif [ $n -gt $aaa ]
then
echo "太高了"
else
echo "太低了"
fi
done
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce73a26d16eb2ac64bddb821f069b941/" rel="bookmark">
			微信扫码登陆在chrome浏览器失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 浏览器会提示：(新版本的浏览器会提示) Unsafe JavaScript attempt to initiate navigation for frame with URL ‘http://www.xxx.xxx/’ from frame with URL “https://open.weixin.com/xxxxxxx” The frame attempting navigation is targeting its top-level window, but is neither same-origin with its target nor is it processing a user gesture
大概意思是：浏览器监测到了iframe中存在不安全的链接正在尝试进行导航， 1. 再来看微信扫码登陆的js文件：wxLogin.js 2. 该文件中对与iframe处理上述安全问题的属性sendbox是没有添加的 3. iframe默认情况下：
在html5页面中，可以使用iframe的sandbox属性，&lt;iframe src="http://alibaba.com" sandbox&gt;sandbox后面如果不加任何值，就代表采用默认的安全策略，即：iframe的页面将会被当做一个独自的源，同时不能提交表单，以及执行javascript脚本，也不能让包含iframe的父页面导航到其他地方，所有的插件，如flash,applet等也全部不能起作用。简单说iframe就只剩下一个展示的功能，正如他的名字一样，所有的内容都被放入了一个单独的沙盒。
. 4. sendbox包含的属性及作用：
allow-forms 允许进行提交表单 allow-scripts 运行执行脚本 allow-same-origin 允许同域请求,比如ajax,storage allow-top-navigation 允许iframe能够主导window.top进行页面跳转 allow-popups 允许iframe中弹出新窗口,比如,window.open,target=”_blank” allow-pointer-lock 在iframe中可以锁定鼠标，主要和鼠标锁定有关
. 5. 修改wxLogin.js如下： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f616e40467c70b1a79c66ac646381ca2/" rel="bookmark">
			安卓开发 利用Face&#43;&#43;实现人脸融合效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于最近有个需求，需要人脸融合，如是上网查了以下，发现Face++用的人挺多的，但是移动端的实现的blog都是直接复制他给的demo，还是挺繁琐的，于是自己看着api就写了一个小例子，希望让后面用的人方便一点。
本demo中用的第三方控件有OKHttp，Gson，EasyPermissions
而且人脸融合需要的两个api目前是免费的
上个效果图
步骤 1.先去Face++官网注册一个开发者账户，得到自己的key和Secret
2.导入需要的第三方库
3.查看了解到自己需要的api有
和
4.使用OKHttp去发送请求并得到返回值，具体见API
new Thread(new Runnable() { @Override public void run() { File file = new File(Environment.getExternalStorageDirectory()+"模板文件地址"); File file2 = new File(Environment.getExternalStorageDirectory()+"融合图片地址（人脸）"); OkHttpClient client=new OkHttpClient(); MultipartBody.Builder builder= new MultipartBody.Builder().setType(MultipartBody.FORM); RequestBody requestBody=RequestBody.create(MediaType.parse("application/octet-stream"), file); builder.addFormDataPart("api_key","你的key"); builder.addFormDataPart("api_secret","你的kecret"); builder.addFormDataPart("image_file",file.getName(),requestBody); Request request = new Request.Builder() .url("https://api-cn.faceplusplus.com/facepp/v3/detect") .post( builder.build()) .build(); try { Response response=client.newCall(request).execute(); responseData=response.body().string(); Message message=Message.obtain(); message.what=1; myhandler.sendMessage(message);//可以对返回的值进行查看 } catch (IOException e) { e.printStackTrace(); } //接下来进行人脸融合,file1经过解析得到人脸的坐标，作为模板图（背景） //file2进行融合，脸为file2 Gson gson=new Gson(); //对json数据转化为对象 Image image=gson.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f616e40467c70b1a79c66ac646381ca2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/accd871447f886c317195da1dd8b6247/" rel="bookmark">
			UE4(虚幻4) 教学网站等资源推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚幻官方： 官方网站（2021.6.18更新，中文网站，官方教程（比很多付费的好多了，都有中文字幕））
：https://academy.unrealengine.com/
官方入门学习（中文彩色ppt、案例，练习，学校授课教师必备）：https://share.weiyun.com/5FcA7NY
UE4 官方网站(免费) https://academy.unrealengine.com/
UE4 官方B站(免费无广告)：虚幻引擎官方的个人空间_哔哩哔哩_Bilibili
UE4官方youtube(特殊上.网)：https://www.youtube.com/channel/UCBobmJyzsJ6Ll7UbfhI4iwQ
UE4C++ 官方推荐(收费) https://www.udemy.com/unrealengine-cpp/learn/v4/overview
虚幻论坛网站等：（排名不分先后） 虚幻官方社区（英文中文版都有）：https://forums.unrealengine.com/
引擎世界(原虚幻中国)https://www.engineworld.cn，老牌网站了，专注UE开发的社区
虚幻4百度贴吧：https://tieba.baidu.com/f?ie=utf-8&amp;kw=%E8%99%9A%E5%B9%BB4&amp;fr=search
UnrealEngineClub：http://www.unrealengine.club/
虚幻独立游戏开发：http://www.gamesoho.net/
虚幻收藏：http://www.unrealkit.com/forum.php
CGWell：(部分浏览器报毒)http://bbs.cgwell.com，特效网站，（已关闭）
推荐几个网站： 翰者学院http://www.hanzhe.com/ 蓝图系列比较不错，用的4.18比较新的版本。
siki学院：http://www.sikiedu.com/，讲的课程比较多，项目多，适合新手练手。
模型网站推荐： 具体看这个帖子：https://blog.csdn.net/qq_21153225/article/details/84619043
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91ae43813bf6c61de60d1cdc01e26e54/" rel="bookmark">
			Java的发展历程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么叫做Java？ Java平台和语言最开始只是SUN公司在1990年12月开始研究的一个内部项目。SUN公司的一个叫做帕特里克·诺顿的工程师被自己开发的C和C语言编译器搞得焦头烂额，因为其中的API极其难用。帕特里克决定改用NeXT，同时他也获得了研究公司的一个叫做“Stealth 计划”的项目的机会。
“Stealth 计划”后来改名为“Green计划”，JGosling(詹姆斯·高斯林）和麦克·舍林丹也加入了帕特里克的工作小组。他们和其他几个工程师一起在加利福尼亚州门罗帕克市沙丘路的一个小工作室里面研究开发新技术，瞄准下一代智能家电（如微波炉）的程序设计，SUN公司预料未来科技将在家用电器领域大显身手。团队最初考虑使用C 语言，但是很多成员包括SUN的首席科学家比尔·乔伊，发现C 和可用的API在某些方面存在很大问题。
工作小组使用的是内嵌类型平台，可以用的资源极其有限。很多成员发现C 太复杂以至很多开发者经常错误使用。他们发现C 缺少垃圾回收系统，还有可移植的安全性、分布程序设计、和多线程功能。最后，他们想要一种易于移植到各种设备上的平台。
根据可用的资金，比尔·乔伊决定开发一种集C语言和Mesa语言搭成的新语言，在一份报告上，乔伊把它叫做“未来”，他提议SUN公司的工程师应该在C 的基础上，开发一种面向对象的环境。最初，高斯林试图修改和扩展C 的功能，他自己称这种新语言为C –，但是后来他放弃了。他将要创造出一种全新的语言，被他命名为“Oak”（橡树），以他的办公室外的树而命名。
就像很多开发新技术的秘密的工程一样，工作小组没日没夜地工作到了1992年的夏天，他们能够演示新平台的一部分了，包括Green操作系统，Oak的程序设计语言，类库，和其硬件。最初的尝试是面向一种类PDA设备，被命名为Star7，这种设备有鲜艳的图形界面和被称为“Duke”的智能代理来帮助用户。1992年12月3日，这台设备进行了展示。
同年11月，Green计划被转化成了“FirstPerson有限公司”，一个SUN公司的全资子公司，团队也被重新安排到了帕洛阿尔托。FirstPerson团队对建造一种高度互动的设备感兴趣，当时代华纳发布了一个关于电视机顶盒的征求提议书时（Request for proposal），FirstPerson改变了他们的目标，作为对征求意见书的响应，提出了一个机顶盒平台的提议。但是有线电视业界觉得FirstPerson的平台给予用户过多地控制权，因此FirstPerson的投标败给了SGI。与3DO公司的另外一笔关于机顶盒的交易也没有成功，由于他们的平台不能在电视工业产生任何效益，公司再并回SUN公司。
JAVA应用1994年6、7月间，在经历了一场历时三天的头脑风暴的讨论之后，约翰·盖吉、詹姆斯·高斯林、比尔·乔伊、帕特里克·诺顿、韦恩·罗斯因和埃里克·斯库米，团队决定再一次改变了努力的目标，这次他们决定将该技术应用于万维网。他们认为随着Mosaic浏览器的到来，因特网正在向同样的高度互动的远景演变，而这一远景正是他们在有线电视网中看到的。作为原型，帕特里克·诺顿写了一个小型万维网浏览器，WebRunner，后来改名为HotJava。同年，Oak改名为Java。商标搜索显示，Oak已被一家显卡制造商注册，因此团队找到了一个新名字。这个名字是在很多成员常去的本地咖啡馆中杜撰出来的。名字是不是首字母缩写还不清楚，很大程度上来说不是。虽然有人声称是开发人员名字的组合：James Gosling（詹姆斯·高斯林）Arthur Van Hoff（阿瑟·凡·霍夫）Andy Bechtolsheim（安迪·贝克托克姆），或“Just Another Vague Acronym”（只是另外一个含糊的缩写）。还有一种比较可信的说法是这个名字是出于对咖啡的喜爱，所以以Java咖啡来命名。类文件的前四个字节如果用十六进制阅读的话，分别为CA FE BA BE，就会拼出两个单词“CAFE BABE”（咖啡宝贝）。
1994年10月，HotJava和Java平台为公司高层进行演示。1994年，Java 1.0a版本已经可以提供下载，但是Java和HotJava浏览器的第一次公开发布却是在1995年5月23日SunWorld大会上进行的。SUN公司的科学指导约翰·盖吉宣告Java技术。这个发布是与网景公司的执行副总裁马克·安德森的惊人发布一起进行的，宣布网景将在其浏览器中包含对Java的支持。1996年1月，升阳公司成立了Java业务集团，专门开发Java技术。 JDK的发展历程 1996年1月，Sun公司发布了Java的第一个开发工具包（JDK 1.0），这是Java发展历程中的重要里程碑，标志着Java成为一种独立的开发工具。9月，约8.3万个网页应用了Java技术来制作。10月，Sun公司发布了Java平台的第一个即时（JIT）编译器。
1997年2月，JDK 1.1面世，在随后的3周时间里，达到了22万次的下载量。4月2日，Java One会议召开，参会者逾一万人，创当时全球同类会议规模之纪录。9月，Java Developer Connection社区成员超过10万。
1998年12月8日，第二代Java平台的企业版J2EE发布。1999年6月，Sun公司发布了第二代Java平台（简称为Java2）的3个版本：J2ME（Java2 Micro Edition，Java2平台的微型版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2平台的标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2平台的企业版），应用于基于Java的应用服务器。Java 2平台的发布，是Java发展过程中最重要的一个里程碑，标志着Java的应用开始普及。
1999年4月27日，HotSpot虚拟机发布。HotSpot虚拟机发布时是作为JDK 1.2的附加程序提供的，后来它成为了JDK 1.3及之后所有版本的Sun JDK的默认虚拟机 。
2000年5月，JDK1.3、JDK1.4和J2SE1.3相继发布，几周后其获得了苹果公司Mac OS X的工业标准的支持。2001年9月24日，J2EE1.3发布。2002年2月26日，J2SE1.4发布。自此Java的计算能力有了大幅提升，与J2SE1.3相比，其多了近62%的类和接口。在这些新特性当中，还提供了广泛的XML支持、安全套接字（Socket）支持（通过SSL与TLS协议）、全新的I/OAPI、正则表达式、日志与断言。2004年9月30日，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE 1.5更名为Java SE 5.0（内部版本号1.5.0），代号为“Tiger”，Tiger包含了从1996年发布1.0版本以来的最重大的更新，其中包括泛型支持、基本类型的自动装箱、改进的循环、枚举类型、格式化I/O及可变参数。
2005年6月，在Java One大会上，Sun公司发布了Java SE 6。此时，Java的各种版本已经更名，已取消其中的数字2，如J2EE更名为JavaEE，J2SE更名为JavaSE，J2ME更名为JavaME。
2006年11月13日，Java技术的发明者Sun公司宣布，将Java技术作为免费软件对外发布。Sun公司正式发布的有关Java平台标准版的第一批源代码，以及Java迷你版的可执行源代码。从2007年3月起，全世界所有的开发人员均可对Java源代码进行修改 。
2009年，甲骨文公司宣布收购Sun 。2010年，Java编程语言的共同创始人之一詹姆斯·高斯林从Oracle公司辞职。2011年，甲骨文公司举行了全球性的活动，以庆祝Java7的推出，随后Java7正式发布。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91ae43813bf6c61de60d1cdc01e26e54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9571d0372a5661be971d37d06552aca2/" rel="bookmark">
			【Linux】Linux网络编程（含常见服务器模型，上篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本数据结构介绍 Linux系统是通过提供嵌套字（socket）来进行网络编程的。网络程序通过socket和其他几个函数的调用，会返回一个通用的文件描述符，用户可以将这个描述符看成普通的文件的描述符来操作，这就是Linux的设备无关性的好处。用户可以通过向描述符的读写操作实现网络之间的数据交流。
表示套接口的socket结构体 struct socket { socket_state	state; //指明套接口的连接状态 short	type; unsigned long	flags; struct fasync_struct	*fasync_list; wait_queue_head_t	wait; struct file	*file; //指向sockfs文件系统中的相应文件 struct sock	*sk; //任何协议族都有其特定的套接口特性，该域就指向特定协议族的套接口对象 const struct proto_ops	*ops; //指明可对套接口进行的各种操作 }; 描述套接口通用地址的数据结构sockaddr结构体 由于历史的缘故，在bind、connect等系统调用中，特定于协议的套接口地址结构指针都要强制转换成该通用的套接口地址结构指针。结构形式如下：
struct sockaddr { sa_family_t	sa_family;	/* address family, AF_xxx	*/ char	sa_data[14];	/* 14 bytes of protocol address	*/ }; 描述因特网地址结构的数据结构sockaddr_in（这里局限于IP4）
struct sockaddr_in { sa_family_t	sin_family;	/* 描述协议族	*/ __be16	sin_port;	/* 端口号	*/ struct in_addr	sin_addr;	/* 因特网地址	*/ unsigned char	__pad[__SOCK_SIZE__ - sizeof(short int) - sizeof(unsigned short int) - sizeof(struct in_addr)]; }; 基本网络函数介绍 表头文件 #include &lt;sys/types.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9571d0372a5661be971d37d06552aca2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50114dc3638b1276d0c5284abff4456c/" rel="bookmark">
			python爬虫实战---网易云音乐评论抓取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要是提取网易云音乐中歌曲的评论时间、评论者昵称、评论内容，并把数据写进csv文件里面，读取文件里面存储的评论内容，根据指定的背景图制作词云，抓取目标https://music.163.com/#/song?id=1299557768，2018年八月最热新歌TOP50中的Animal歌曲。
引言 网易云大厂一般都对自己的数据做了很好的加密，一般直接爬取都爬取不到数据，这也是爬取当中一个很头疼的事情，也很绝望。通过浏览器的检查，点击netword中XHR去对网页刷新，会发现其中的一个XHR并对它点击Preview会发现评论就在comments的字段中，XHR的链接：https://music.163.com/weapi/v1/resource/comments/R_SO_4_1299557768?csrf_token=，但直接抓取并没有得到数据，而去分析请求，可以发现是post方式请求，且携带两个参数，params、encSecKey，这两个参数是通过加密的。根据知乎大佬对两个参数的解析，十分膜拜，但是臣妾做不到，但其中的一个回答给了我希望！知乎大佬们的解析：https://www.zhihu.com/question/36081767/answer/140287795。
导入包 import requests---网页请求
import json---格式转换
import csv---数据保存
import time---延时操作
import jieba---分词处理
import numpy---图片的转换
from PIL import Image---图片处理
from wordcloud import WordCloud---词云制作
抓取过程 网页请求
""" json数据接口，需要两个参数，offset和limit，offset的增量为20， limit的固定为20刚好和每一页的20条评论相对应，刚好抓取网页评论的20条评论 http://music.163.com/api/v1/resource/comments/R_SO_4_1299557768?offset=40&amp;limit=20 """ # 网页请求 def get_one_comment(offset): # 设置请求头 headers={ 'Cookie':'_iuqxldmzr_=32; _ntes_nnid=bdaab01e87ee929b3a9a91ea44b5cd45,1534172699282; _ntes_nuid=bdaab01e87ee929b3a9a91ea44b5cd45; __utmc=94650624; WM_TID=M4E4ToHGUg4EetTbOjxEC5J%2BuODh%2B0jj; abt=66; WM_NI=cRw1E4mJtjv9dwKem8xCMaYzUgNNyu8qqM25igmzBYDj%2FJGjHnYTJFFFqen2XIq%2FlCdRUdQxmdIvxSl84%2BvraOwnH1lJboEwOdL6UrZhnx030tzRng9NfOIBNXgIUx7GMUI%3D; WM_NIKE=9ca17ae2e6ffcda170e2e6eeb6b15cf88bb8ade56a8eb48291f97ca5b9e1d2c45bf6ed9cb9e659b1be8e89ca2af0fea7c3b92aa18eb9d2c840af96bc8bf533a8a98586f034bc9d8382dc7297b982affc7ffcafbfaeb13fabb9a39bc15388b6e1abc6628cb297b5c94e869abf86ed3a9c97bfd0ef49a88e9b85d474afbc8797fb59b0e8fcccf57aa391b98fcb3bb096ae90c87d8dbc84d7d87a9ab8a299b339f4acb6b3ed6dfb92aab0cc4a8e88a9aad874f59983b6cc37e2a3; __utma=94650624.827593374.1534172700.1535852507.1535857189.3; __utmz=94650624.1535857189.3.3.utmcsr=baidu|utmccn=(organic)|utmcmd=organic; JSESSIONID-WYYY=kgbbgMKEcRf18SvvxZVqNTmWZD%2Fdn8BpA%2F7aMH7vv4mSpiDaE%5CfkC5xPu5hFv0nk5X7PpvlEJJ97%2BC3WyE5Qv50EW%2FdNPQQPenibqq%2F5IyHkuuMlCTkpkb7TRMl9oBEdFi68ktMI8m%2F5Ilyub4P204bpG0qBv4yx9vvw8CmCJ%2B9vCaSd%3A1535859527007; __utmb=94650624.7.10.1535857189', 'Referer':'https://music.163.com/song?id=1299557768', 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36' } # 字符串拼接 url='http://music.163.com/api/v1/resource/comments/R_SO_4_1299557768?offset='+str(offset)+'&amp;limit=20' try: time.sleep(2) response=requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50114dc3638b1276d0c5284abff4456c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b346dd47a9fce07e2f3a079c6d2e8ce/" rel="bookmark">
			python——csv文件转换为shp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更新 今天发现之前的代码运行会报错，发现shapefile接口有更新，最近比较忙，没有去确认是否是因为python版本不同的问题。之前的代码是基于python2.7的，下面这部分更新后的代码是基于python3的。
#-*-coding:utf-8-*- import shapefile as shp import csv import codecs import os def trans_point(folder, fn, delimiter=','): '''transfer a csv file to shapefile''' # create a point shapefile output_shp = shp.Writer(folder + "%s.shp"%fn.split('.')[0], shp.POINT) # for every record there must be a corresponding geometry. output_shp.autoBalance = 1 # create the field names and data type for each.you can omit fields here # 顺序一定要与下面的保持一致 output_shp.field('photo_url', 'C', 50) # string, max-length output_shp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b346dd47a9fce07e2f3a079c6d2e8ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d01493c97519e96089ecea98666e942e/" rel="bookmark">
			大转盘抽奖的网页版和小程序版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天整理了下以前写的小demo，把大转盘抽奖的代码，整合下，列了网页版和小程序两个版本,这个转盘抽奖的核心是H5的canvas和Css3的translate属性，非常简单，写了网页版和小程序版供大家参考，主要核心代码就是利用canvas画图，完整代码见https://github.com/Elve520/lottery，下载可用
希望给大家带来帮助
//转盘内部绘制 lottery.prototype.getCanvasI=function(){ let itemsArc=360/this.itemsNum //获取大转盘每等分的角度 this.itemsArc=itemsArc let widthI=canvasI.width let heightI=canvasI.height this.w1=parseInt(widthI/2) this.h1=parseInt(heightI/2) this.Items(itemsArc)//每一份扇形的内部绘制 this.mytime=setInterval(this.light.bind(this),1000) } //绘制奖品名称 lottery.prototype.Items=function(e){ let that=this let itemsArc=e//每一分扇形的角度 let Num=that.itemsNum// 等分数量 let text=that.text// 放文字的数组 for(let i=0;i&lt;Num;i++){ ctx.beginPath() ctx.moveTo(that.w1,that.h1) ctx.arc(that.w1,that.h1,that.w1-5,itemsArc * i * Math.PI / 180, (itemsArc + itemsArc * i) * Math.PI / 180)//绘制扇形，注意下一个扇形比上一个扇形多一个itemsArc的角度 ctx.closePath() if (i % 2 == 0) {//绘制偶数扇形和奇数扇形的颜色不同 ctx.fillStyle=that.color[0] } else { ctx.fillStyle=that.color[1] } ctx.fill() ctx.save() ctx.beginPath() ctx.fontSize=12 ctx.fillStyle='#000' ctx.textAlign='center' ctx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d01493c97519e96089ecea98666e942e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fd424ba938025c7fb647776e114b470/" rel="bookmark">
			python爬虫实战---豆瓣电影top250的电影信息抓取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要抓取豆瓣电影top250榜单里面的电影数据，提取的数据包括电影名称、电影的链接、电影的星级、电影引言、电影的评论 人数等。
导入包 from bs4 import BeautifulSoup as bs---进行网页解析 import requests---用于网页请求 import time---用于延长时间,防止过于快速抓取数据，封ip import re---正则表达式使用 import csv---数据存储到csv文件 网页分析 通过浏览器右键点击检查，选择netword和里面XHR刷新来看，我们要提取的数据并不是异步加载的，也不是通过其他加密方式加载的，可以直接把网页的源码爬取下来，在进行解析就可以。
网页结构解析 url的结构： https://movie.douban.com/top250?start=0&amp;filter=，里面的参数start就是对应着哪一页，相当于偏移量，且每次在原来的基础上加25，每次修改start的值就可以获取下一页的信息。
网页结构： 每一部电影的信息都在一个class属性为item的div盒子里面，通过BeautifulSoup的find_all('div',{'class':'item'})来找到该页所有相关的盒子，class属性为hd的div盒子,包含电影链接、电影名称，class属性为start的div盒子,包含星级和评论人数，引言在 class属性为quote的p标签里面。
网页下载 # 获取一页数据 def get_one_page(offset): # 设置请求头 headers={ 'Referer':'https://movie.douban.com/top250?start=0&amp;filter=', 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36' } url='https://movie.douban.com/top250?start='+str(offset)+'&amp;filter=' try: time.sleep(1) response=requests.get(url,headers=headers) # 判断相应状态，200表示请求成功 if response.status_code == 200: return response.content except Exception as e: print('出错!') return None 网页解析 def parse_page(offset): response=get_one_page(offset) if response: # print(response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fd424ba938025c7fb647776e114b470/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee42f07727897d0e492eb3d25088f21/" rel="bookmark">
			select into ...from... 提示 Undeclared variable.....错误的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：https://blog.csdn.net/bestcleaner/article/details/52994469
今天在使用 SELECT INTO FROM 创建mysql数据表的时候，运行相关 sql 语句的时候却一直返回 [Err] 1327 - Undeclared variable: …… 这种错误，实在不解，经过查询关资料才知道，原来 mysql 数据库是不支持 SELECT INTO FROM 这种语句的，但是经过研究是可以通过另外一种变通的方法解决这个问题的，下面就来说说解决这个错误的办法吧！
进过搜索相关资料以及实验结果证实，可以使用
Create table Table2 (Select * from Table1); 这种语句代替
SELECT vale1, value2, value3 into Table2 from Table1; 下面看一个本人实际操作中的例子吧！ create table newusers(SELECT username,password,sex,age,role from users where username like 'z%'); 这个是关联两个表得出一个查询结果，然后将结果插入到一个新创建的表 newusers中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f75f3e569f20b0a38b0826f535d019f2/" rel="bookmark">
			参数类型、返回值类型、基本类型、引用类型之疑点疏通和个人浅见
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引用类型和基本类型的联系和区别： 1、引用数据类型为java两大数据类型之一
2、引用数据型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址，即引用传递。
3、引用数据类型包括：类、接口类型、数组类型、枚举类型、注解类型，字符串型；
4、java另一大数据类型为基本数据类型，其包括包括数值型，字符型和布尔型等；
5、基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上，即价值传递。
二、引用类型作为参数类型的意义？ 当参数列表中有引用类型时，值是按引用传递，传递的其实是该类的对象，可以通过形参调取该类的方法、属性。 三、引用类型作为返回值类型的意义？ 当返回值类型时引用类型时，返回的是该类的对象。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b49fa5093ee99ba191114458211070a/" rel="bookmark">
			统计学中常见的概率密度图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		统计学中常见的概率密度图像 今天复习概率论与数理统计看到常见的几种分布突然有了兴趣，所以尝试着写一写关于matlab画出常见几种概率密度图像（注：有些是从网上搜集整理得到的）
二项分：
二项分布,又称n重伯努力试验 每次实验成功概率为p,失败概率为q=1-p ，则在这n次独立实验中,成功x次的概率y为
clc; clear; x= 0:50; y = binopdf(x,200,0.08);%二项分布概率密度函数 plot(x,y,'--r+');%作图 title('X~B(n=200,p=0.8)的伯努力分布的前50个点的概率分布'); xlabel('试验成功次数x');%x标签 ylabel('y=P\{X=x\}');%y标签 分布
若n个相互独立的随机变量ξ₁，ξ₂，...,ξn ，均服从标准正态分布（也称独立同分布于标准正态分布），则这n个服从标准正态分布的随机变量的平方和构成一新的随机变量，其分布规律称为卡方分布（chi-square distribution）。
n=4;%卡方分布参数: 自由度 P=0.9;%P值 x_xi=chi2inv(P,n); % 根据P值反查临界值 %----绘制卡方分布图-------------- x=0:0.1:15; yd_c=chi2pdf(x,n); %获得相应分布密度值 plot(x,yd_c,'b'),hold on %画图 %绘制分布函数着色部分------------- xxf=0:0.1:x_xi;% 0~临界值 yyf=chi2pdf(xxf,n); fill([xxf,x_xi],[yyf,0],'c') %以蓝色色填充 %添加标注 text(x_xi*1.01,0.01,num2str(x_xi)) %标注临界值 text(10,0.16,['\fontsize{16} x~{\chi}^2' '(4)']) %标注分布名 text(1.5,0.08,'\fontname{隶书}\fontsize{16}\alpha=0.9') %标注P值 title('\chi^2分布图像') hold off 正态分布
正态分布（Normal distribution），也称“常态分布”，又名高斯分布（Gaussian distribution），最早由A.棣莫弗在求二项分布的渐近公式中得到。C.F.高斯在研究测量误差时从另一个角度导出了它。P.S.拉普拉斯和高斯研究了它的性质。是一个在数学、物理及工程等领域都非常重要的概率分布，在统计学的许多方面有着重大的影响力。正态曲线呈钟型，两头低，中间高，左右对称因其曲线呈钟形，因此人们又经常称之为钟形曲线。若随机变量X服从一个数学期望为μ、方差为σ^2的正态分布，记为N(μ，σ^2)。其概率密度函数为正态分布的期望值μ决定了其位置，其标准差σ决定了分布的幅度。当μ = 0,σ = 1时的正态分布是标准正态分布。
clc; clear; mu=3; sigma=0.5; x=mu+sigma*[-3:-1,1:3]; yf=normcdf(x,mu,sigma); P=[yf(4)-yf(3),yf(5)-yf(2),yf(6)-yf(1)]; xd=1:0.1:5; yd=normpdf(xd,mu,sigma); % for k=1:3 xx{k}=x(4-k):sigma/10:x(3+k); yy{k}=normpdf(xx{k},mu,sigma); end subplot(1,3,1),plot(xd,yd,'r'); hold on fill([x(3),xx{1},x(4)],[0,yy{1},0],'c') text(mu-0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b49fa5093ee99ba191114458211070a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dab90864e0eae864f04559b064bcf7b/" rel="bookmark">
			一个Java初学者写的博客（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java简介 java 是一个面向对象（Object Oriented,OO）的编程语言，和其他大多数的 面向对象编程语言一样，都是单根结构，面向对象的最上级水平：万物皆对象。 瞎扯1： （即java 里所有的东西都有共同的‘祖先’ Object），父和子的说法来源于面向 对象三大特征之一的继承，说面向对象其实也就是面向 Object 这个‘祖先’，毕 竟java里所有的东西都是 Object 的后代，这个说法就有点 多态 的意思了，面 向（Object），这个参数 Object 可以是 Object 的任何一个后代，当然我们 自己创建的类也是 Object 的后代。 类和对象 类：（归）类 成员变量，类的属性、特征 成员方法，类的行为、动作 （构造方法，类变成实例时进行的行为/动作） 对象：类具体的例子，类的实例 （构造方法 new 出来的） 类与类之间的关系 泛化： 继承 实现（接口） 依赖： 临时性，很弱 类 A 作为参数在类 B 中使用 关联： 长期性，比依赖强 类 A 是类 B 的一个属性 聚合（弱聚合）： 类 A 是类 B 的一个属性，但是这个属性可有可无 组合（强聚合）： 类 A 是类 B 的一个属性，这个属性必须有，同生命周期 面向对象 封装： 用 private 修饰 成员变量 ，隐藏类内部细节 提供 public 修饰的 getter 和 setter 方法，作为外部访问类内 成员 变量 的入口 （工厂模式就是最好的应用，往下翻有工厂模式） 继承：（分）类 将一些类的 共同属性/行为/特征/动作 抽象出来产生一个父类，便于分类 （值得注意的是java特别符合现实中的伦理道德，每个类只允许有一个父亲， 也就是单继承 extend ） 多态：前提是继承，运行时才会发生（一个LOL战队一般都有有很多个队员，真正 要上场了才知道谁上场谁替补，faker 都替补了:) ） 可以说是有两种： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dab90864e0eae864f04559b064bcf7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f13f5a329dd11fd16221ebc684ef877f/" rel="bookmark">
			我的JAVA面试经验(3年左右工作经验)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言-
致那些迷茫的JAVA面试者（特别是南京的1-4年经验），致那些奋发的年轻人，致自己。写这篇博文主要也是对我的成长道路的记录，面试受挫后的反思，及对自己的勉励。
本人介绍：3年多经验的程序员，坐标南京。
背景：因水平有限，及对部分面试问题记忆及理解有限，可能有些问题并不能表达准确。掌握技术有限，学习主动性一般（虽遇到问题善于思考钻研，但如果没有遇到问题比较放纵自己...被自由，轻松，安逸迷失心智），以及原公司项目背景因素，基本不需要太多新的技术框架支持，更没有涉及消息中间件，高并发分布式等等相关较主流技术，技术体系相对较老。综上导致我对很多新技术并不是太了解。
面试经验背景：基本公司都是按简历掌握技术来问(当然也有超纲不按套路出牌的），如果你简历掌握技术什么都不写，也有可能接到面试邀请，那么面试官问题可能就比较广了，对面试者不利。掌握技术我写了java基础：多线程，io/nio，jvm，集合底层，tcp/ip协议，socket，websocket。spring，springmvc，xml，设计模式，eclipse plugin开发，数据库，前端（基本没有什么人问，面的后端开发，也许熟悉前端也是加分项）了解netty、mybatis、redis（实际就是看了一点点）.
项目经验背景：
1.原公司我所在的部门做的是一款大型工具，web项目。项目周期很长很长，至今还在做，具体不细说，技术上就用了上述我写的部分技术(未涉及redis、netty、mybatis、springmvc)，作为项目经历，该项目竞争力不强。
2.朋友找我做的私活项目，只接触了一个星期左右，朋友就跟接活人闹崩了，然后不了了之。但是我还是把项目写进项目经验了（投递的时候写，自带的纸质简历就把它去掉，以防面试官问到我一脸懵逼...机智如我，当然也有公司不需要你的自带简历，那就没办法，他问到的话我就忽悠，坦白）。实际就是个特别小的项目，用到的技术springmvc，mybatis，redis，activemq，阿里云对象存储等等。这个项目我只稍微了解了一点点springmvc，mybatis，redis最最基本的用法，可以说没啥用。
面试经历（具体录用薪资我就不说明了，只说我对薪资+公司福利满意度。
面试中项目介绍必定要说的，以及项目中的细节问题，这些不细说了。只说技术问题）
按时间先后排序（时间越远遗忘的问题可能越多。很多重复的，将就看吧）
1.小公司
名字忘了。时间久远，只记得有多线程，线程池拒绝策略，jvm调优，tomcat调优，消息中间件，分布式，集群，zookeeper，微服务。sql左连接右连接区别，存储过程。linux。基本全程懵逼，（因为第一次面试，简历技术什么都没写，这货敞开了问）。最后竟然通知我面试通过。
难度-难
公司环境-不满意
薪资福利-不满意
工作内容-不满意（忽悠我刚开始写逻辑代码，以后可能会做微服务，大数据，基本不加班，我是不信的）。
2.软通动力（华为外包）
stringbuffer和stringbuild区别，stringbuild线程不安全体现在哪，你对线程安不安全怎么理解（这个问题发挥空间很大，关键词:全局变量、JVM运行时数据区、可见性、原子性、锁、甚至可以说到多核cpu硬件层面(我是不会的)），arraylist和linkedlist区别，spring ioc，aop作用，原理。springmvc执行流程（这种问题最扯淡），hashmap原理（问的很浅，底层结构，答数组+链表/红黑树。他就没问了），hashmap,hashtable,concurrentHashMap(大致基本说下，他就不问了),hashmap遍历。对大数据有关技术了解多少(答:了解一点，听过hadoop)。其它忘了，总体难度不大。写代码:字符串分割排序(split+冒泡)）。
难度-简单
薪资福利-一般
工作内容-不满意（外包你懂的。有关大数据方面的（这点还可以），更多的是数据清洗）
3.鸿信集团(电信子公司)
一个年纪比较大的面试官，像管理层人员，感觉技术水平有限。基本就问了项目，spring的理解，activemq，没了。笔试，扯淡的笔试题，写了一点走人了。公司整体给人的感觉比较自由松散，适合养老。感觉技术上没有发展空间。
面试建议-别去
4.苏宁
我前后面了4次(因为住的地方就靠着苏宁，没事就顺便去面试打发时间，4个部门，通过了3个)。写一起。
苏宁金服：问的项目业务，公司业务模块（无从下口），为什么要用redis，相比于如memcached,mongodb有什么优势，mybatis，activemq。springmvc有什么好处，为什么要用它,springmvc和struts区别(都不会)...用过什么数据库，有没有做过数据库优化，什么情况下要用到索引，好处是什么，哪些字段适合建立索引，mysql索引底层数据结构了解吗，索引什么情况下会失效，联合索引abc只用了a字段，索引是否会生效。什么情况下要用到多线程，为什么要用，好处。启动多个线程，如何知道他们都运行完毕了。jquery要想取某个节点中的第几个元素怎么写，具体哪个方法（（我看你是闲着蛋疼）答：元素选择器,find,eq）。 总体回答的很不好，感觉他就盯着我写的了解程度的技术问，有为难我降低我薪资要求的意思。最后通知面试通过（也许是真的缺人，也许是我吹牛比较6，画了项目流程图给他）
难度-对于我来说难（其实一般，主要是我实在不太会他问的框架技术）
薪资福利-一般（面的不太好的地方我是不太好意思去的，感觉进去有种抬不起头的感觉）
苏宁易购网站购物车消费者业务线:string为什么是不可变的，重写重载，object类有哪些方法，sleep和wait区别，实现线程的方式，run，start区别，线程有几种状态，synchronize实现原理（这个问题可以说的很多，建议大家往深了看，往深了说，以震慑面试官），与lock区别，还知道哪些锁，说说自旋锁。线程池，线程池等待队列，拒绝策略，死锁产生原因。为什么java可以一次编译，到处运行。事务特性，索引失效，mysql有哪些函数。http和https区别，get和post区别，springbean是单例吗，spring源码看过吗，其中的单例bean是怎么实现的。redis有支持哪些数据结构。servlet怎么取前端参数。（两个面试官，感觉面试官水平有限，一直在想问什么问题，越问越没难度）设计个洗牌算法。线上购物车需要有个标志唯一id，有什么方法实现这个id（uuid，参考jdk中random实现原理，取随机种子）
难度-一般
薪资福利-一般
大数据部门：抽象类接口区别，接口中可以定义成员变量吗，默认是什么类型的变量（public static final），接口中方法权限可以是private吗，接口是否可以写具体实现（答：jdk8开始可以）重写重载区别，线程的实现方式（我已经感觉到这个部门有多缺人了）。sql交并集，事务隔离级别。能调用另一个类的私有方法吗，怎么做。如果线程池执行shutdown或shutdownNow，线程池中线程会中断吗，会出现什么异常，catch处理中该写些什么。用过哪些concurrent包下的类，说说原子类，cas操作可能会存在什么问题。jdk中有哪些设计模式的运用，项目中用了哪些设计模式，treemap中compartor用了什么设计模式，有哪些单例模式的实现方式，springbean是单例吗。如果想要在某些自己指定的某些方法前后打印日志怎么实现（答：自定义注解，问：具体怎么做，答：spring aop的实现思路...），注解实现原理。
面试难度-一般
薪资福利-较满意
苏宁物流部:苏宁最难的一次面试经历，也许是晚上面试，时间充分，安静，面试官比较好发挥，我全程半懵逼，面试官是中年人，看气势最起码经理级别。
servlet和jsp区别，如果没有servlet，jsp怎么跟后端交互（大概是这个意思，没听太懂，一脸懵逼）。springmvc怎么取前端数据，springmvc模式下，如果没有注解怎么取前端参数（答：servlet，requset.getParameter。他问，具体在哪怎么用，也没听太懂，懵逼）。搭建springmvc项目步骤。spirngmvc controller中定义全局hashmap，它是否是线程安全的，为什么。
Io nio区别，nio原理。netty用的多吗。答，不多。
项目中用哪种方式解析xml的 答:jaxb,dom4j,digester。问:jaxp是什么。 答:是jaxb,巴拉巴拉... 问:哦哦，挺好用的
servlet生命周期。tomcat在初始化中做了什么事（答：启动socket服务端...问:没了吗?答:... 很明显该回答的还有很多，想了解的应该是我对tomcat的理解程度，以及是否看过tomcat源码）。是否用过Nginx。过滤器和拦截器的区别。
项目中有用到缓存吗，redis有提供了哪些存储数据结构，redis持久化。
说说java内存模型，新生代老年代算法，你说的新生代老年代属于堆还是栈，还知道哪些gc算法，创建大对象也是在新生代分配吗，（答：直接晋升进入老年代，问：具体多大对象，答：超过eden区大小，问：你是否确定，顿时虚了，后来回去查阅过，我回答的不对，jvm这里的看点很多，涉及到优化）。新生代的算法，说说minor gc,minor gc触发条件。老年代用了什么算法，说说标记整理算法，full gc是否真正回收了废弃对象。有哪些gc策略。你觉得你的项目中如果需要jvm调优你会注重哪个分带的调优，或者说更注重哪种gc调优，为什么，具体怎么做（懵逼，随便吹了下。问：你确定吗？ 顿时又虚了）。
线上系统每天会收到20万级的数据，一个月会有百万条，并且还会递增。你如何设计数据库（答:分库分表，建立索引，问：分库分表对的，还有哪些点，分库分表按什么规则分）。如果查询字段不是分库分表的规则字段，怎么办（他说没事，想到什么说什么，也许你的思路会比我们的更好，你说说看）。沉默许久，不会，没接触过。（后来查了该问题：分库分表多维度查询）问:oracle分页的sql关键字是什么 答:limit 问:不对吧，那是mysql的 答:啊？好吧 问:也许是limit，我也记不清了，可能你说的是对的，回去我得看看。（面试官还算和蔼，其实是rownum）
面试难度- 难
苏宁结束，总结：苏宁大部分部门都非常缺程序员，招人要求相比于其它大点公司要低一些，都会问的同样的问题:能否接受苏宁的加班(部门加班情况不一，按我面试部门了解（加班从多到少:金服-&gt;物流/购物车-&gt;大数据部门），总体加班很多) ，苏宁的软件电商工作在外的名声总体不太好，加班严重，福利一般，晋升难，听说不是太注重员工培养。
5.烽火科技
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f13f5a329dd11fd16221ebc684ef877f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae87d42b65c8217d991560b5307c444e/" rel="bookmark">
			linux ping-测试主机之间网络的连通性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主推荐：更多网络测试相关命令关注 网络测试 收藏linux命令大全
ping命令用来测试主机之间网络的连通性。执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。 语法 ping(选项)(参数) 选项 -d：使用Socket的SO_DEBUG功能； -c&lt;完成次数&gt;：设置完成要求回应的次数； -f：极限检测； -i&lt;间隔秒数&gt;：指定收发信息的间隔时间； -I&lt;网络界面&gt;：使用指定的网络界面送出数据包； -l&lt;前置载入&gt;：设置在送出要求信息之前，先行发出的数据包； -n：只输出数值； -p&lt;范本样式&gt;：设置填满数据包的范本样式； -q：不显示指令执行过程，开头和结尾的相关信息除外； -r：忽略普通的Routing Table，直接将数据包送到远端主机上； -R：记录路由过程； -s&lt;数据包大小&gt;：设置数据包的大小； -t&lt;存活数值&gt;：设置存活数值TTL的大小； -v：详细显示指令的执行过程。 参数 目的主机：指定发送ICMP报文的目的主机。 实例 [root@AY1307311912260196fcZ ~]# ping www.linuxde.net PING host.1.linuxde.net (100.42.212.8) 56(84) bytes of data. 64 bytes from 100-42-212-8.static.webnx.com (100.42.212.8): icmp_seq=1 ttl=50 time=177 ms 64 bytes from 100-42-212-8.static.webnx.com (100.42.212.8): icmp_seq=2 ttl=50 time=178 ms 64 bytes from 100-42-212-8.static.webnx.com (100.42.212.8): icmp_seq=3 ttl=50 time=174 ms 64 bytes from 100-42-212-8.static.webnx.com (100.42.212.8): icmp_seq=4 ttl=50 time=177 ms .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae87d42b65c8217d991560b5307c444e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f38a19b4647b50c7dd01e82200d540e5/" rel="bookmark">
			基于SSM框架的省市二级联动的小项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个小项目是真的搞得我头疼，我提莫做了两天！！废话不多说上代码：
主要是前台js代码比较麻烦后台的代码就省略了。。。
&lt;%@ page language="java" contentType="text/html; charset=UTF-8"
pageEncoding="UTF-8"%&gt;
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%&gt;
&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/"; %&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;省市联动&lt;/title&gt;
&lt;link href="&lt;%=basePath%&gt;/resources/css/bootstrap.min.css" rel="stylesheet"&gt;&lt;/script&gt;
&lt;script src="&lt;%=basePath%&gt;/resources/js/jquery.min.js" rel="stylesheet"&gt;&lt;/script&gt;
&lt;script src="&lt;%=basePath%&gt;/resources/js/bootstrap.min.js" rel="stylesheet"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;script type="text/javascript"&gt;
$(document).ready(function(){ //这里解释一下，由于最开始要从数据库里读取省份的一个list，我一直在想怎么通过事件来触发调用函数，搞了半天，最后才知道jQuery里有一个$(document).ready(function(){}函数，他可以在页面加载时直接运行函数内部代码，所以页面一家在会自动去获取数据库里的省份list
$.ajax({
type:"get",
url:"&lt;%=basePath%&gt;/city/findProvinceList.action",
dataType:"json",
success:function(data) {
$("#province").html("&lt;option value=''&gt;--请选择--");
for(var i = 0;i&lt;data.length;i++){
$("#province").append("&lt;option value='"+data[i]+"'&gt;"+data[i]);
}
},
error:function(data)
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f38a19b4647b50c7dd01e82200d540e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/956ee66bb5978aed3450a27075d6c3cc/" rel="bookmark">
			【路由和交换之H3C自导自演】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		H3C配置自导自演 显示和维护及恢复 1:display display history-command ：查看历史命令记录 display diagnostic-information ：查看系统运行统计信息
display clock :查看当前系统时间
display interface ：查看全部的接口
display version:查看系统的发行版本
display current-cfiguration ：查看运行的配置信息
display ip interface brief:查看接口状态和信息
display saved-configuration :查看起始配置信息
display boot-loader:查看系统应用程序文件
display startup:查看起始配置文件
display this :查看当前视图下生效的配置
display schedule reboot：查看系统的重启时间
display vlan:查看交换机所有配置的vlan
display fib:显示路由转发平面表
dispaly arp:显示arp表的详细信息
display debugging ：显示调试的开关　display ip fast-forwarding cache:显示快速转发表　display interface vlan vlan_id :显示vlan接口的详细配置　display ospf peer:显示ospf邻居表
display ospf lsdb：显示ospf链路状态数据库
display ospf routing:显示ospf路由建立
display ospf error：显示ospf配置中出现的错误
display ospf brief：显示ospf的摘要信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/956ee66bb5978aed3450a27075d6c3cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9562789a0962125e76719c93dd9234c/" rel="bookmark">
			Django学习之三：django-admin 和 项目manage.py程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Django django-admin 和 项目manage.py程序 [TOC]
它俩是什么？ django-admin 是django的命令行工具，用于管理任务。manage.py 是通过django-admin创建项目时为每一个项目创建的管理程序。它和django-admin做相同的工作。除了一些不一样的，需要我们注意： 1. manage.py 会将它所管理的项目的package加入到sys.path列表中。方便通过import查找导入模块或者功能属性。 2. manage.py 会设置环境变量DJANGO_SETTNGS_MODULE，将它设置为当前项目的settings.py位置。 命令程序用法 django-admin &lt;\command&gt; [options] python manage.py &lt;\command&gt; [options] python -m django &lt;\command&gt; [options]
常用命令 Available subcommands:
[auth] 只有当auth模块设置可用时，才可以使用以下命令 changepassword ：修改密码 createsuperuser : 创建超级用户
[contenttypes] 只有当contenttypes激活时 remove_stale_contenttypes
[django] check compilemessages createcachetable dbshell diffsettings dumpdata flush inspectdb loaddata makemessages makemigrations ：创建映射文件 migrate ：将model构建的表迁移到关系数据库中 sendtestemail shell ：运行python交互环境，在django目录环境中，可用于测试django项目代码，主要是会将项目加入到sys.path中，利于测试django项目。 showmigrations sqlflush sqlmigrate： 预览创建数据库的sql ddl语句 sqlsequencereset squashmigrations startapp： 创建新的应用app startproject： 创建新的项目project test testserver
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9562789a0962125e76719c93dd9234c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fc34ea4712f4a956fd7c8df4228145f/" rel="bookmark">
			函数显式参数(Parameters)与隐式参数(Arguments)及传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数显式参数(Parameters)与隐式参数(Arguments) 参数规则 JavaScript 函数定义时显式参数没有指定数据类型。
JavaScript 函数对隐式参数没有进行类型检测。
JavaScript 函数对隐式参数的个数没有进行检测。
默认参数 如果函数在调用时未提供隐式参数，参数会默认设置为： undefined
有时这是可以接受的，但是建议最好为参数设置一个默认值：
通过值传递参数 在函数中调用的参数是函数的隐式参数。
JavaScript 隐式参数通过值来传递：函数仅仅只是获取值。
如果函数修改参数的值，不会修改显式参数的初始值（在函数外定义）。
隐式参数的改变在函数外是不可见的。
通过对象传递参数 在JavaScript中，可以引用对象的值。
因此我们在函数内部修改对象的属性就会修改其初始的值。
修改对象属性可作用于函数外部（全局变量）。
修改对象属性在函数外是可见的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13d7b53533cf21788a4704d4d212b26c/" rel="bookmark">
			linux more-显示文件内容，每次显示一屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主推荐：获取更多 linux文件内容查看命令 收藏：linux命令大全
more命令是一个基于vi编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持vi中的关键字定位操作。more名单中内置了若干快捷键，常用的有H（获得帮助信息），Enter（向下翻滚一行），空格（向下滚动一屏），Q（退出命令）。 该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比：--More--（XX%）可以用下列不同的方法对提示做出回答： 按Space键：显示文本的下一屏内容。 按Enier键：只显示文本的下一行内容。 按斜线符|：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。 按H键：显示帮助屏，该屏上有相关的帮助信息。 按B键：显示上一屏内容。 按Q键：退出rnore命令。 语法 more(语法)(参数) 选项 -&lt;数字&gt;：指定每屏显示的行数； -d：显示“[press space to continue,'q' to quit.]”和“[Press 'h' for instructions]”； -c：不进行滚屏操作。每次刷新这个屏幕； -s：将多个空行压缩成一行显示； -u：禁止下划线； +&lt;数字&gt;：从指定数字的行开始显示。 参数 文件：指定分页显示内容的文件。 实例 显示文件file的内容，但在显示之前先清屏，并且在屏幕的最下方显示完核的百分比。 more -dc file 显示文件file的内容，每10行显示一次，而且在显示之前先清屏。 more -c -10 file 转载于:https://www.cnblogs.com/mayou18/p/9558560.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/428/">«</a>
	<span class="pagination__item pagination__item--current">429/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/430/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>