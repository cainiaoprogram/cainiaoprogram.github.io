<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82c31419308cf42617778a19dc0c0fd0/" rel="bookmark">
			lambda表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 lambda表达式主要用于处理功能接口，这类接口类里只有一个抽象方法
接口类 名字= (参数)-&gt;{方法体}；
一般的用法：
​ interface Ilove{ void like(int a,int b); } ​ Ilove love;//一种接口的多态 love = (a, b) -&gt; { // lambda表达式是重写接口里抽象方法的一种简便写法，=后面表示让该接口实现后的对象给接口变量接收 System.out.println(a); System.out.println(b); }; love.like(45,50); 同时使用lambda表达式相当与是一种对匿名内部类（当然该类肯定也是一个功能接口）的一中简便写法
如下代码：调用.forEach();方法使用匿名内部类构建一个传入该方法中的参数对象，实现aa这个集合中元素的输出
aa.forEach(new Consumer&lt;String&gt;() { //传入方法中的参数是一个类 @Override public void accept(String s) { System.out.println(s); } }); 如下代码：使用lambda表达式的简便写法
aa.forEach((s)-&gt; System.out.println(s));//相当实现一个匿名内部类传入方法中 实现Runnable接口的线程代码示例
//使用lambda表达式来实现Runnable()接口类并调用其中的run方法 new Thread(()-&gt;{ for(int i=0;i&lt;20;i++){ for(int j=0;j&lt;i+1;j++) System.out.print("R"); System.out.println();} }).start(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9163f780ac7c24337423edfc8b05bb0c/" rel="bookmark">
			git学习(二)撤销、回滚操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、已修改未追踪的文件的撤销2、撤回已追踪的文件3、撤回commitgit resetgit revertreset 和 revert区别 1、已修改未追踪的文件的撤销 我们在git学习(一)为项目创建git仓库的基础上进行操作，在README.md中随便写点内容
查看状态
git status 此时我们可以通过以下命令撤回此次修改
git restore README.md 可以发现文件的内容又为空了，也就是修改前的内容
2、撤回已追踪的文件 首先修改README.md的内容 通过git add 命令追踪
git add README.md 撤销追踪的话，即从暂存区去除，可以通过以下命令实现
git restore --staged README.md 3、撤回commit 我们先把修改后的README.md文件提交到本地仓库
那么有两种方式可以对commit进行回滚，分别是
git resetgit revert git reset git reset是将commit 回滚到之前某个版本，将已经commit的文件变为未追踪状态（新添加的文件）、或修改待暂存状态（之前就有的文件，但是后面修改了）
通过如下命令，可以回到上一个版本的状态
git reset HEAD^ git status 可以发现README.md撤回到了已修改未追踪的状态，也就是待用git add 操作加入暂存区的状态
如果要撤销该文件的内容修改，可以看文本章的第一点，如需提交，就git add添加，然后git commit即可
那么为了接下来演示git revert，我们选择commit
git revert 首先，我们在touch一个文件a，然后commit
我们通过git revert命令，反做上上次一次commit，也就是 修改README.md的commit
git revert HEAD^ 此时去查看README.md的内容，发现消失了，也就是说git revert 命令是将之前某一次的commit取消掉，但是不影响取消的commit前后的commit
而git reset是将此次commit后的文件都变为待git add状态
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9163f780ac7c24337423edfc8b05bb0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4980ab2403f7463d9762cc3a1d8e9437/" rel="bookmark">
			git学习(一)为项目创建git仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1、初始化本地仓库2、配置个人信息3、创建文件，添加到暂存区4、将暂存区提交到本地仓库5、设置远程仓库地址，并推送到远程仓库 1、初始化本地仓库 git init 执行后，在当前项目下创建了一个.git文件夹
2、配置个人信息 因为git每次的commit都会带上当前提交人的名字和邮箱，所以需要配置一下
git config --global user.name "lingqi" git config --global user.email "test@qq.com" 我们可以通过如下命令，看是否设置正确，如果设置有误，重新按照上述命令重新设置即可
git config -l 3、创建文件，添加到暂存区 创建一个文件
touch README.md 添加到暂存区
git add README.md 查看文件追踪状态
git status 4、将暂存区提交到本地仓库 git commit -m 'first commit' 5、设置远程仓库地址，并推送到远程仓库 设置远程仓库地址（只需要第一次设置，后面无需设置）
git remote add origin https://gitee.com/linqi_07/git-study.git 将本地仓库的master分支推送到远程主机origin中的master分支
(后面推送到远程仓库只需要git push即可)
git push -u origin "master" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d95f02549b4b65dbad273cc62221daa2/" rel="bookmark">
			ELK--- ELK简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ELK简介特点组件介绍Elastic SearchLogstashKibanaBeatsElastic cloud ELK简介 ELK是一个免费开源的日志分析架构技术栈总称，官网地址：https://www.elastic.co/cn/。主要包含三大基础组件，分别是Elastic Search、Logstash、Kibana。 但是实际上ELK不仅仅适用于日志分析，它还可以支持其它任何数据搜索、分析和收集的场景，日志分析和收集只是更具有代表性，并非唯一性。
架构图如下：
随着ELK的发展，新成员Beats、Elastic cloud加入大家庭，所以就形成了 Elastic Stack。因此ELK是旧的称呼，Elastic Stack是新的名字。
特点 处理方式灵活：Elastic Search是目前最流行的准实时全文检索引擎，具有高速检索大数据的能力。配置简单:安装ELK的每个组件，仅需配置每个组件的一个配置文件即可。因为大量参数已经默认配在系统中，修改想要修改的选项即可。接口简单：采用JSON形式RESTFUL API接受数据并响应，无关语言。性能高效：Elastic Search基于优秀的全文搜索技术Lucene，采用倒排索引，可以轻易地在百亿级别数据量下，搜索出想要的内容，并且是秒级响应。灵活扩展：Elastic Search 和 Logstash 都可以根据集群规模线性拓展， Elastic Search内部自动实现集群协作。数据展现华丽：Kibana作为前端展现工具，图表华丽，配置简单。 组件介绍 Elastic Search Elastic Search是使用Java开发，基于Lucene、分布式、通过Restful方式进 行交互的近实时搜索平台框架。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，Restful风格接口，多数据源，自动搜索负载等。
Logstash Logstash 基于java开发，是一个数据抽取转化工具。一般工作方式为C/S架构，Client端安装在需要收集信息的主机上，Server端负责将收到的各节点日志进行过滤、修改等操作在一并发往Elastic Search或其他组件上去。
Kibana Kibana 基于Node.js，也是一个开源和免费的可视化工具。Kibana可以为 Logstash 和 Elastic Search提供的日志分析友好的 Web 界面，可以汇总、分析和搜索重要数据日志。
Beats Beats 平台集合了多种单一用途数据采集器。它们从成百上千或成千上万台机器和系统向 Logstash 或Elastic Search发送数据。
Beats由如下组成:
Packetbeat：轻量型网络数据采集器，用于深挖网线上传输的数据，了解应用程序动态。Packetbeat 是一款轻量型网络数据包分析器，能够将数据发送至 Logstash 或 Elastic Search。其支持ICMP (v4 and v6)、DNS、 HTTP、MySQL、PostgreSQL、Redis、MongoDB、Memcache等协议。
Filebeat：轻量型日志采集器。当您要面对成百上千、甚至成千上万的服务器、虚拟机和容器生成的日志时，请告别 SSH 吧。Filebeat 将为您提供一种轻量型方法，用于转发和汇总日志与文件，让简单的事情不再繁杂。
Metricbeat： 轻量型指标采集器。Metricbeat 能够以一种轻量型的方式，输送各种系统和服务统计数据，从 CPU 到内存，从 Redis 到 Nginx， 不一而足。可定期获取外部系统的监控指标信息，其可以监控、收集 Apache http、HAProxy、MongoDB、MySQL、Nginx、PostgreSQL、 Redis、System、Zookeeper等服务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d95f02549b4b65dbad273cc62221daa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f3a8eeadaff6e7daccc24b82eb6c8bb/" rel="bookmark">
			Hadoop 集群搭建实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hadoop 集群搭建实战 环境准备：
1. VMware 搭建三台CentOS 7.8主机 2. 静态IP，关闭防火墙，修改主机名，配置免密登录，集群时间同步 3. 在/opt目录下创建文件夹 mkdir -p /opt/apps/software --软件安装包存放目录 mkdir -p /opt/apps/servers --软件安装目录 4. Hadoop下载地址： https://archive.apache.org/dist/hadoop/common/hadoop-2.9.2/ 5. 上传hadoop安装文件到/opt/apps/software 集群规划：
框架hadoop-121hadoop-122hadoop-123HDFSNameNode、DataNodeDataNodeSecondaryNameNode、DataNodeYARNNodeManagerNodeManagerNodeManager、ResourceManager 安装Hadoop 登录hadoop-121节点，进入/opt/apps/software，解压安装文件到/opt/apps/servers
tar -zxvf hadoop-2.9.2.tar.gz -C /opt/apps/servers 查看是否解压成功
ls /opt/apps/servers/ 添加Hadoop到环境变量 vim /etc/profile
# hadoop export HADOOP_HOME=/opt/apps/servers/hadoop-2.9.2 export PATH=$PATH:$HADOOP_HOME/bin export PATH=$PATH:$HADOOP_HOME/sbin 使环境变量生效
source /etc/profile 验证hadoop是否安装成功
hadoop version hadoop安装目录下各个文件
drwxr-xr-x. 2 501 dialout 194 Nov 13 2018 bin drwxr-xr-x. 3 501 dialout 20 Nov 13 2018 etc drwxr-xr-x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f3a8eeadaff6e7daccc24b82eb6c8bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/673070d6a1eb8e60e132f23087d67199/" rel="bookmark">
			postgresq子查询exists/not exists操作符用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. EXISTS 操作符 在 where 子句的 查询条件中，exists 操作符，会在子查询有返回行时，返回true；不论返回几行。
因此，子查询中的查询字段仅写1就好；标准的写法：EXISTS (SELECT 1 FROM tbl WHERE condition)
2. not exists操作符 not exists与exists正好相反，如果子查询没有返回结果，为’TRUE’，否则’FALSE’
3. 例子 子查询返回多条时，可以在 where 子句中 用 IN，来匹配查询条件。
select id, name from user_info WHERE id NOT IN ( select id from vistor_info where amount &gt; 100 ); 【注】：NOT IN的效率非常低，如果可以的话建议使用NOT EXISTS。
查询 user_info 表，且user_info.id为(vistor_info表中存在的且是 vistor_info 表中amount&gt;11的那些id)
SELECT id, name FROM user_info WHERE EXISTS ( SELECT 1 FROM vistor_info WHERE vistor_info.id=user_info.id= AND amount&gt;100 ); ); 查询customer表，且user_info.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/673070d6a1eb8e60e132f23087d67199/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d908174388064b8018485ac5031fd69/" rel="bookmark">
			习题6-8 单词首字母大写 (15 分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本题目要求编写程序，输入一行字符，将每个单词的首字母改为大写后输出。所谓“单词”是指连续不含空格的字符串，各单词之间用空格分隔，空格数可以是多个。
输入格式: 输入给出一行字符。
输出格式: 在一行中输出已输入的字符，其中所有单词的首字母已改为大写。
输入样例: How are you? 结尾无空行
输出样例: How Are You? 结尾无空行
语句的第一个单词首字母已经为大写字母，所以只需要改变剩下的单词的首字母，而在碰到下一个单词前都会有一个空格，就以此来作为我们的判断条件。
#include&lt;stdio.h&gt; int main() { int w = 1; char c; while((c = getchar())!='\n') //如果碰到回车，程序结束 { if(c==' ') //遇到空格，说明下一个字符就是单词首字母 { w = 1; //w发生改变 } else if(w==1) { w = 0; //w复位，为下一次循环准备 if(c&gt;='a'&amp;&amp;c&lt;='z') //如果首字符为小写字母 { c-=32; //小写变大写 } } putchar(c); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/417821592969b23203c9fe7d838cc273/" rel="bookmark">
			目标检测中的数据类别不均衡问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目标检测中的数据类别不均衡问题 1. 问题概述 在目标检测任务中存在各种各样的不均衡问题（参考 目标检测领域中的数据不均衡问题综述），这里仅仅针对数据类别不均衡问题，就是下表的前景类别间不均衡问题，也是我们常说的长尾数据问题。当然这个问题并非是检测任务才有，其他的比如分类任务也是一样存在的，可能有区别的是，对于检测来说，是每个类别的 bbox 数量而不是图片数量。
2. 解决思路 2.1 从数据着手 从数据上来说，哪一类少就增加哪一类，但是如果要去收集代价可能又太大了，有时候甚至是不可能。
重采样（re-sampling）
工程上最廉价的方式，直接对较少的类别数据进行重采样，使得数量增加。
数据合成
简单的比如通过crop &amp; paste 的方式增加少类别样本，甚至是 GAN 等方式。
2.2 从 Loss 着手 重加权（re-weighting）
比如以类别的数量的倒数作为分类 loss 权重。
Focal Loss
2.3 其他方法 上面的方法多是代价比较小的改动就可以带来的提升，但是还有很多其他有效的方法。
迁移学习（transfer learning）：这类方法的基本思路是对多类样本和少类样本分别建模，将学到的多类样本的信息/表示/知识迁移给少类别使用。度量学习（metric learning）：本质上是希望能够学到更好的embedding，对少类附近的boundary/margin更好的建模。元学习/域自适应（meta learning/domain adaptation）：分别对头部和尾部的数据进行不同处理，可以去自适应的学习如何重加权，或是formulate成域自适应问题。解耦特征和分类器（decoupling representation &amp; classifier）：最近的研究发现将特征学习和分类器学习解耦，把不平衡学习分为两个阶段，在特征学习阶段正常采样，在分类器学习阶段平衡采样，可以带来更好的长尾学习结果。这也是目前的最优长尾分类算法。参考 Decoupling representation and classifier for long-tailed recognition。半监督学习预训练
利用无标记数据，半监督学习能够显著提高最后的分类结果。参考数据类别不平衡/长尾分布？不妨利用半监督或自监督学习。 参考 数据类别不平衡/长尾分布？不妨利用半监督或自监督学习 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/402ef9e9f51aeecb9039ccc267d2f81a/" rel="bookmark">
			Docker基础操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Docker介绍
Docker 是一个开源的应用容器引擎，基于 [Go 语言]并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。
2、Docker的组成部分
​ 1.镜像 2.容器 3.仓库
3、镜像
1、查看镜像文件：docker images 2、查看当前运行的容器 ：docker ps -a 3、删除镜像文件：docker rmi 镜像ID
4、使用镜像创建容器：
`$ docker run -t -i ubuntu:14.04 /bin/bash #docker run ：该命令将创建并运行一个容器** 安装完成后，我们可以使用以下命令来运行 nginx 容器： $ docker run --name nginx-test -p 8080:80 -d nginx #启动镜像指定容器名称 以及端口的映射 参数说明： - **--name nginx-test**：容器名称。 - **-p 8080:80**： 端口进行映射，将本地 8080 端口映射到容器内部的 80 端口。 - **-d nginx**： 设置容器在在后台一直运行	5、构建镜像 ​	1.使用Dockerfile配置文件进行镜像文件配置 ​	2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/402ef9e9f51aeecb9039ccc267d2f81a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bf17593f256dce0172c16af5f8664c6/" rel="bookmark">
			Java String 和 String[] 相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、String 转 String[ ] //1.使用split() String[] strs = str.split(","); //2.创建一个String[] 数组，再给这个数组赋值 private String[] strArray(String customerId){ String[] customerIds = new String[1]; customerIds[0] = customerId; return customerIds; } //3. 创建一个List数组，再使用toArray()进行转换 String[] ids = strList.toArray(new String[strList.size()]); 二、String[] 转 String public String doJoin(String[] strings) { String result=String.join(",", strings); return result;	} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edb0f3bb71f95d755f095fa89d8bc14a/" rel="bookmark">
			cv2.polylines
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		box = np.reshape(np.array(box), [-1, 1, 2]).astype(np.int32) image = cv2.polylines(np.array(image), [box], True, (255, 0, 0), 5) 图片路径里不能有中文，不然cv2.polylines会报一些莫名其妙的错误
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0506fce3e2c6d62cc04d59390b16f1cd/" rel="bookmark">
			【OpenCV-Python】29.OpenCV的特征检测——特征匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		29.OpenCV的特征检测——特征匹配
文章目录 前言一、暴力匹配器二、FLANN匹配器三、OpenCV-Python资源下载总结 前言 获得图像的关键点后，可通过计算得到关键点的描述符。关键点描述符可用于图像的特征匹配。通常，在计算图A是否包含图B的特征区域时，将图A称做训练图像，将图B称为查询图像。图A的关键点描述符称为训练描述符，图B的关键点描述符称为查询描述符。
一、暴力匹配器 暴力匹配器使用描述符进行特征比较。在比较时，暴力匹配器首先在查询描述符中取一个关键点的描述符，将其与训练描述符中的所有关键点描述符进行比较，每次比较后会给出一个距离值，距离最小的值对应最佳匹配结果。所有描述符比较完后，匹配器返回匹配结果列表。
OpenCV的cv2.BFMatcher_create()函数用于创建暴力匹配器，其基本格式如下：
bf = cv2.BFMatcher_create([normType[, crossCheck]]) bf为返回的暴力匹配器对象 normType为距离测量类型, 默认为cv2.NORM_L2, 通常, SIFT描述符使用cv2.NORM_L1或cv2.NORM_L2, ORB描述符使用cv2.NORM_HAMMING crossCheck默认为False, 匹配器为每个查询描述符找到k个距离最近的匹配描述符, 为True时, 只返回满足交叉验证条件的匹配结果 暴力匹配器对象的match()方法返回每个关键点的最佳匹配结果，其基本格式如下：
ms = bf.match(des1, des2) ms为返回的结果, 它是一个DMatch对象列表, 每个DMatch对象表示关键点的一个匹配结果, 其dintance属性表示距离, 距离值越小匹配度越高 des1为查询描述符 des2为训练描述符 获得匹配结果后，可调用cv2.drawMatches()函数或cv2.drawMatchesKnn()函数绘制匹配结果图像，其基本格式如下：
outImg = cv2.drawMatches(img1, keypoints1, img2, keypoints2, matches1to2[, matchColor[, singlePointColor[, matchesMask[, flags]]]]) outImg = cv2.drawMatches(img1, keypoints1, img2, keypoints2, matches1to2[, matchColor[, singlePointColor[, matchesMask[, flags]]]]) outImg为返回的绘制结果图像, 图像中查询图像与训练图像中匹配的关键点个两点之间的连线为彩色 img1为查询图像 keypoints1为img1的关键点 img2为训练图像 keypoints2为img2的关键点 matches1to2为img1与img2的匹配结果 matchColor为关键点和链接线的颜色, 默认使用随机颜色 singlePointColor为单个关键点的颜色, 默认使用随机颜色 matchesMask为掩膜, 用于决定绘制哪些匹配结果, 默认为空, 表示绘制所有匹配结果 flags为标志, 可设置为下列参数值: cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0506fce3e2c6d62cc04d59390b16f1cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cef8070394bfb3b912fec1d4a3c139c9/" rel="bookmark">
			机器学习入门（2）之模型评估与选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、误差与拟合
1. 泛化误差与经验误差
2. 损失函数与训练误差
3. 过拟合与欠拟合
4. 过拟合的另一种现象：数据泄露
二、评估方法
1. 留出法
2. 交叉验证法（留一法）
3. 自助法
4. 调参与最终模型
三、性能度量
1. 混淆矩阵
2.准确率
3.精确率（查准率）和召回率（查全率）
4. F1值和Fβ值
5. ROC曲线及其AUC值
6. AUC值的计算
7. 代价敏感错误率与代价曲线
四、比较检验
1.性能比较的三个要素
2.假设检验
（1）估计假设精度
（2）采样理论基础
（3）多次训练/测试的检验-t检验
（4）交叉验证 t 检验
（5）McNemar 检验
（6）Friedman检验与 Nemenyi后续检验
五、偏差与方差
一、误差与拟合 1. 泛化误差与经验误差 泛化误差：在“未来”样本上的误差（generalization error）
经验误差：在训练样本上的误差(training error),也称为训练误差
错误率 ：分类错误的样本数占样本总数的比例(error)
精度 ：1-错误率(accuracy)
我有个小问号？？？？
不是说泛化误差越小越好，那经验误差是否越小越好？
当然不是，因为会出现“过拟合”问题
2. 损失函数与训练误差 2.1 损失函数
损失函数是关于模型计算结果f(x)和样本实际目标结果y的非负实值函数，记作L(y,f(x)).用它来解释模型在每个样本实例上的误差,损失函数的值越小，说明预测值与实际值越接近，即模型的拟合效果越好. 损失函数主要包括以下几种： 0-1损失函数、平方损失函数、绝对损失函数、对数损失函数.
2.2 训练误差
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cef8070394bfb3b912fec1d4a3c139c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c7a7d0ed710d2fbc23f4360551a038a/" rel="bookmark">
			Spark课程设计——电影推荐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目所需数据集及相应信息描述：
数据集：
1、用户评分数据集ratings.dat:包含了大量用户的历史评分数据。
2、样本评分数据集personalRatings.dat:包含了少数几个用户的个性化评分数据，这些数据反映了某个用户的个性化观影喜好。
3、电影数据集movies.dat:包含了每部电影的相关信息。
注意：
之后依次使用数据集1~3表示上述数据集
数据集结构如下：
1、用户ID::电影ID::评分::时间戳
2、用户ID::电影ID::评分::时间戳
3、电影ID::电影名称::电影类型
(1)movies.dat数据集部分展示：
（2）ratings.dat数据集部分展示：
题目要求：
1、根据数据集3，计算每年发行电影的数量，并进行可视化(柱状图)。
2、根据数据集1，计算每部电影的平均分，并进行可视化(柱状图)。
3、根据数据集1，将电影评分离散化，[0,2)为差,[2-4)为良好,[4-5)为优秀，并进行可视化（饼图）。
4、根据数据集3，统计每种类型电影的数量（若一个电影有多个分类，选择第一个），并进行可视化(饼图)。
5、根据数据集1、2，自行挑选用户（用户id），使用协同过滤算法为其推荐十部电影，无需可视化，只需运行结果。
实验思路及代码：
（1）第一小题思路（流程图）：
代码：
//计算每年发行电影的数量 val rdd1 = sc.textFile("C:/Users/ch/Desktop/大学/大三阶段/spark/spark实验/课程设计/题目/实验数据集/movies.txt") //先将每行元素按照::进行分割，然后取出包含年份的那个字段 val rdd2 = rdd1.map(line=&gt;line.split("::")(1)) //获取年份（使用两次反转） val rdd3 = rdd2.map(line=&gt;line.reverse.take(5)) val rdd4 = rdd3.map(line=&gt;line.reverse.take(4)) //计算每年发行电影的数量 val rdd_result = rdd4.map(word=&gt;(word,1)).reduceByKey(_+_) //进行格式化 val rdd_show = rdd_result.map(line=&gt;line._1+"年，有"+line._2+"份电影") //将结果输出到文件夹当中 rdd_show.saveAsTextFile("C:/Users/ch/Desktop/大学/大三阶段/spark/spark实验/课程设计/题目/实验数据集/Test1") 结果展示：
（2）第二小题思路
代码：
//提取每个电影以及对应的评分，形成一个元组 val rdd3_2 = rdd3_1.map(line=&gt;(line.split("::")(1),line.split("::")(2).toInt)) //对应rdd3_2的value进行操作，key不动 val rdd3_3 = rdd3_2.mapValues(x=&gt;(x,1)) //将相同的电影的评分进行求平均 val rdd3_4 = rdd3_3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c7a7d0ed710d2fbc23f4360551a038a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c125fea331decf58ea690fcd21d8539/" rel="bookmark">
			Allegro 转 PADS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先电脑上安装好三个软件。我的是AD21、Cadence16.6、PADS9.5
2、先把BRD文件用AD21直接导入，AD21支持直接导入BRD文件的，然后导出低版本AD即可。
3、再用PADS9.5安装自带的一个转换功率，叫PADS Tanslation，直接导入AD低版本文件转换出PADS的文件即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e90d22e14fbffc43e56d3bacfdeeb3d1/" rel="bookmark">
			Git-将某次commit从一个分支转移到另一个分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用场景：多个分支并行开发的情况下提交到错误的分支上，或者开发版本都已经准备好了，但是release计划有变，需要调整release里面的features，那么我们可以优雅而从容的面对PM的要求。
多个分支并行开发的情况下，将某次commit提交错分支了，那么久需要从A分支将某次commit转移到B分支，可以这样操作
前提：提交错误的分支为A，希望提交到的分支为B
1、首先切换到A分支
git checkout 2、查询错误commit的ID，并拷贝出来
git log 假如：id是 94070bf919891e587351a78bdb2f53e50fecb36a 3、然后切换到B分支
git checkout B 4、将该commit id pick到正确分支
git cherry-pick 94070bf919891e587351a78bdb2f53e50fecb36a 然后再git log，可以看到这个分支上已经有这个commit了，但是commit id却变了，所以这是copy，而不是move，那么原来的还一定存在
5、再切换到A分支
git checkout A git log 会发现原来错误的commit id还是存在的，这时候把这个commit 再去掉
6、去掉错误的commit
如果这个commit是最新的提交，那么可以使用git reset --hard 94070bf919891e587351a78bdb2f53e50fecb36a
毫无痕迹的消失了
如果这个commit id是中间的某次commit，那么使用git revert去回退即可，美中不足的是会增加一条记录，叫做：
7、每个分支分别push
B分支上是新增commit，可以直接git push
A分支上如果使用了git reset回退的，需要git push -f 如果是git revert的可以直接git push
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49c6e14000a6b27784044c805a32aa1b/" rel="bookmark">
			使用idea连接mysql数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、找到idea中MySQL数据库的连接方式
第一步，找到Database第二步，点击"+"第三步，点击Data Source第四步，点击MySQL 2、配置连接
在第一次使用的时候，除了要配置连接，还要配置相应的驱动，否则连接的时候会报错！！！
图中的①②③④⑤分别表示为：
①、连接的名称
②、连接的数据库地址和端口号（连接本地的数据库就默认为localhost，端口号为3306）
③、MySQL数据库的用户名和密码
④、需要连接的数据库名称 URL的输入框中写入：jdbc:mysql://localhost:3306/nacos_config?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8
⑤、配置完成之后，点击测试连接，查看是否连接成功
配置驱动：
3、测试连接
出现绿色的小勾，即表示连接成功，然后点击OK，结束配置
最后点击Database，即可出现刚刚新建的连接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/230192d25d71dbb454fcaece12bdd199/" rel="bookmark">
			layui 直接赋值 重载问题&#43;动态新增table
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题实在是解决的有一些好笑了，记录一下
html，放个table
&lt;table class="layui-hide" id="imagetable" lay-filter="test"&gt;&lt;/table&gt; js
&lt;script&gt; layui.use(['form', 'table',], function () { var form = layui.form; var $ = layui.jquery; var itemImgList = itemInfoData.itemImgList!=null?itemInfoData.itemImgList:{ "id": 0, "imageUrl": "", "sort": 0, }; var table = layui.table; var imagetable = table.render({ elem: '#imagetable', data:itemImgList, limit:1000, cols: [ [{ type: 'checkbox' // field: 'id', // title: '编号' }, { field: 'imageUrl', title: '图片', }, }, { field: 'sort', title: '排序', sort: true }, { title: '操作', toolbar: '#barDemo', minWidth: 200 }] ], toolbar: '#toolbarDemo' //开启头部工具栏，并为其绑定左侧模板 , defaultToolbar: [] //无右侧标题栏功能 , title: '产品组图数据表', id: 'imagetable' }); table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/230192d25d71dbb454fcaece12bdd199/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7378c1defdea2db9adec1564b3482c6e/" rel="bookmark">
			Aspect注解依赖引入（记录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe46be09d5c7a395212c3daa561c92d3/" rel="bookmark">
			M3U8文件格式说明及解决大量拼接ts文件时长不对问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		M3U8 文件简介 m3u8 文件实质是一个播放列表（playlist），其可能是一个媒体播放列表（Media Playlist），或者是一个主列表（Master Playlist）。但无论是哪种播放列表，其内部文字使用的都是 utf-8 编码。
当 m3u8 文件作为媒体播放列表（Meida Playlist）时，其内部信息记录的是一系列媒体片段资源，顺序播放该片段资源，即可完整展示多媒体资源。其格式如下所示：
对于点播来说，客户端只需按顺序下载上述片段资源，依次进行播放即可。而对于直播来说，客户端需要 定时重新请求 该 m3u8 文件，看下是否有新的片段数据需要进行下载并播放。
大量TS文件合成一个文件，总时长变短或变长的问题 例子中的ts文件为本地路径，也可用网络路径。如果大量ts文件在本地，则需要在ts文件所在文件夹创建例子中的m3u8文件，使用ffmpeg命令将大量ts文件拼接成一个文件，文件时长变短或边长，命令如下：
ffmpeg.exe -f concat -safe 0 -i C:/HLS/1A03444D-128D-9A95-58EF-271C4B01A434/file.txt -c copy C:/HLS/1A03444D-128D-9A95-58EF-271C4B01A434/test.mp4
使用cancat 参数进行拼接，可能是拼接问题，导致时长不准确。
解决方法：
书写一个m3u8文件，将大量ts文件按上面的m3u8文件例子进行修改，保存后在使用ffmpeg命令可以合成某一封装格式例如（mp4、ts）等文件，命令如下：
ffmpeg.exe -i C:/HLS/4D26D71D-1834-1AF2-E3AF-317DC7E48F2B/1.m3u8 -c copy C:/HLS/4D26D71D-1834-1AF2-E3AF-317DC7E48F2B/test1.mp4
这时文件时长就会不大不小。
这里如果是通过m3u8下载到本地ts文件，最终需要合成一个大文件时，则用下载的m3u8格式重新书写ts路径。
在书写m3u8文件时，严格按照格式书写：
#EXTINF: 代表这个ts文件的时长
#EXT-X-ENDLIST：表示PlayList的末尾了，它可以在PlayList中任意位置出现，但是只能出现一个。
#EXT-X-TARGETDURATION：指定最大的媒体段时间长（秒）。所以#EXTINF中指定的时间长度必须小于或是等于这个最大
#EXT-X-MEDIA-SEQUENCE：一个media URI并不是必须要包含的，如果没有，默认为0。
#EXT-X-ALLOW-CACHE：是否允许做cache，这个可以在PlayList文件中任意地方出现，并且最多出现一次，作用效果是所有的媒体段。
#EXT-X-VERSION: M3U8的版本号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8effc1abcecc12800a367e4c45a76ff0/" rel="bookmark">
			python创建xlsx文件并写入数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import xlsxwriter excle1 = xlsxwriter.Workbook("filename.xlsx") #创建filename.xlsx文件，没有就重建，有就覆盖 for i in range(10): imgurl = json_data[sit[i]] row = 'A' + str(i + 1) worksheet.write(row, imgurl) #写入数据，row为位置，imgurl为内容 excle1.close() # 关闭xlsx文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0be7cd03b8e800d713f97ccb9bead6d/" rel="bookmark">
			Clion &#43; OpenCV4.5.4 &#43; VS2019配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Clion + OpenCV4.5.4 + VS2019配置详解 环境变量配置创建测试项目编辑CMakefileLists设置OpenCV路径查找模块文件拷贝动态库OpenCV内置变量设置附加目录 测试程序完整CMakefileLists 环境变量配置 下载并安装OpenCV，安装后的目录如下：
本文使用的是VS2019的带的VC16版本的编译器，环境变量配置如下：
创建测试项目 使用Clion创建C++项目，由于使用的OpenCV是VC14的库，创建时语言标准也选择14，如下图所示：
编辑CMakefileLists 设置OpenCV路径 set(OpenCV_DIR $ENV{OPENCV_HOME}/lib/) 查找模块文件 完成上一步之后CMake会进入设置的目录中找到OpenCVConfig.cmake文件，设置CMake需要加载读取的模块，一般第三方模块的命名方式都是xxxxConfig.cmake。
find_package(OpenCV REQUIRED) 拷贝动态库 在测试项目运行时需要将opencv_world454.dll(release)和opencv_world454d.dll(debug)拷贝到.exe文件的同级目录下。
file(GLOB COPY_DLL "$ENV{OPENCV_HOME}/bin/*.dll") file(COPY ${COPY_DLL} DESTINATION ${CMAKE_CURRENT_BINARY_DIR}) 其中${CMAKE_CURRENT_BINARY_DIR}是CMake内置的变量，表示当前项目编译后二进制文件输出路径。
OpenCV内置变量 OpenCV也有一些内置的变量可用，这些变量都是在OpenCVConfig.cmake定义在文件中。
message(STATUS "OpenCV library status:") message(STATUS " config: ${OpenCV_DIR}") message(STATUS " version: ${OpenCV_VERSION}") message(STATUS " libraries: ${OpenCV_LIBS}") message(STATUS " include path: ${OpenCV_INCLUDE_DIRS}") 设置附加目录 在编译时需要将OpenCV的lib文件编译到exe文件中，设置如下：
target_link_libraries(OpenCVCode ${OpenCV_LIBS}) 设置target_link_libraries()函数，一定要在add_executable()前。
测试程序 #include &lt;iostream&gt; #include "opencv2/opencv.hpp" using namespace cv; int main() { Mat src = imread("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0be7cd03b8e800d713f97ccb9bead6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18c1e22e3de1999edb42ef458a9194cb/" rel="bookmark">
			vmware虚拟机安装centos7系统窗口很小问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：centos7窗口很小，居中显示
解决：
1、编辑该虚拟机的显示器，选择自动拉伸，如无此选项，往下；
2、点击vmware菜单的“查看”，找到自动调整大小-自动适应客户机，重启即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73783eff3ff4e516f8902d6f865386e5/" rel="bookmark">
			MOS管基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MOS管，是MOSFET的缩写。MOSFET金属-氧化物半导体场效应晶体管，简称金氧半场效晶体管（Metal-Oxide-Semiconductor Field-Effect Transistor, MOSFET）
场效应管分为结型（JFET）和金属-氧化物-半导体型（MOSFET）两种类型。
JFET的英文全称是Junction Field-Effect Transistor，也分为N沟道和P沟道两种，在实际中几乎不用。
MOSFET英文全称是Metal-Oxide-Semiconductor Field-Effect Transistor，应用广泛，MOSFET一般称MOS管。MOSFET有增强型和耗尽型两大类，增强型和耗尽型每一类下面都有NMOS和PMOS。增强型MOS管的英文为Enhancement MOS或者EMOS，耗尽型MOS管的英文为Depletion MOS或者DMOS。
一般PCB上使用最多的是增强型MOS管，NMOS最多，一般多用在信号控制上，其次是PMOS，多用在电源开关等方面，耗尽型几乎不用。
所以，在实际应用中，应用最多的是增强型NMOS管,其次是增强型PMOS管。
一、MOS管基本参数 1.1、N和P区分 MOS管的源极s、栅极g、漏极d分别对应于三极管的发射极e、基极b、集电极c，它们的作用相似。如下箭头指向G极的为NMOS，箭头背向G极的为PMOS。
由于生产工艺，一般的MOS管会有一个寄生二极管，有的也叫体二极管。从上图可以看出NMOS和PMOS寄生二极管方向不一样，NMOS是由S极→D极，PMOS是由D极→S极。
1.2、基本开关电路 相比于NMOS，PMOS应用较少，主要原因有导通电阻大于NMOS导通电阻，型号少，价格贵等，但在一些特殊的场合也有应用。
1.2.1、MOS管导通条件 MOS管是压控型，导通由G和S极之间压差决定。
对NMOS来说，Vg-Vs&gt;Vgs(th)，即G极和S极的压差大于一定值，MOS管会导通，但是也不能大太多，否则烧坏MOS管，开启电压和其他参数可以看具体器件的SPEC。简单的说，就是NMOS高电平导通。
对PMOS来说，Vs-Vg&gt;Vgs(th)，即S极和G极的压差大于一定值，MOS管会导通，同样的，具体参数看器件的SPEC。简单的说，就是PMOS低电平导通。
1.2.2、导通特性 通过改变 栅极与源极 间的电压差, 就能控制MOS管的关断和导通.
NMOS 导通条件: Ug-Us &gt; Vgs。 Vgs一般是2V左右, 理解为G极比S极要高2V左右时开始导通。 N管常做下管(低端驱动), 因为S极直接接地固定电压时, G极和S极之间的压差容易控制. 而当S极电压不固定时, 栅源电压较难确定, 电路比较麻烦.
PMOS 导通条件: Us-Ug &gt; Vgs, 如果阀值电压为2V, G极比S极低2V就能导通. 一般做上管(高端驱动). 同理, 用S极接VCC 电压固定, 这时G极电压容易计算及控制, 反之, 用S极接负载, S极电压不能稳定, G极电压就更难确定, 电路上也比较麻烦.
1.2.3、MOS管用作开关时在电路中的连接方法 NMOS：D极接输入，S极接输出
PMOS：S极接输入，D极接输出
使用方法如图所示：
对比三极管的使用方法如图：
二、与三极管的区别 三极管是电流控制，MOS管是电压控制，主要有如下的区别：
1，只容许从信号源取少量电流的情况下，选用MOS管；在信号电压较低，有容许从信号源取较多电流的条件下，选用三极管。
2，MOS管是单极性器件（靠一种多数载流子导电），三极管是双极性器件（既有多数载流子，也要少数载流子导电）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73783eff3ff4e516f8902d6f865386e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ec76a1962b1df264870464ebd6b29eb/" rel="bookmark">
			texstudio错误:无法执行命令解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题排查 首先确认安装目录下的确存在这个文件，我用的是ubuntu，所以直接cd到安装目录
cd /usr/local/texlive/2021/bin/x86_64-linux 根据你自己的安装目录来，然后直接查找有无这个文件
ls | grep xelatex 可以看到，是存在这个文件的，所以我们只需要修改texstudio的参数就可以了
问题根本原因 命令行输入xelatex，能够输出，说明环境变量没有问题
然后cd到/bin下面，搜索一下latex
cd /bin ls | grep latex 输出如下：
latex、pdflatex、lualatex都是我在studio里面直接能用的命令，可以发现，这一堆输出中刚好没有发现xelatex，这就是根本原因，同时也说明，texstudio默认直接在bin里面找命令，而如果这个命令在/bin下不存在，那么texstudio就无法编译。
解决问题 知道了问题出在哪，就好办了
解决方法1：软链接 既然bin里面没有，那我们就给他加进去。我觉得理论上是可以的，但是实际上我失败了，所以这里就不说了，有大神感兴趣的可以试试。
解决方法2：修改命令 自带的编译命令是这样的，我们只需要改为绝对路径即可。
我这里不能用的是xelatex，所以改成这样
/usr/local/texlive/2021/bin/x86_64-linux/xelatex -synctex=1 -interaction=nonstopmode %.tex 这样的话texstudio就可以找到路径了。
其他编辑器遇到无法编译的问题，也可以用这个方法解决，就不用手动命令行编译了。
windows解决方法也是一样的，加上路径即可。
其他命令，如pdflatex、latex用不了也是直接指定路径即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75e1876ef7369073676f7beda476d14e/" rel="bookmark">
			PyCharm,idea通过插件database连接带Kerberos的hive
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.目的 PyCharm通过插件database连接带Kerberos的hive
2.异常 我windows已经配置好kerberos,可以kinit通,其其他工具以及可以正常访问，但是通过PyCharm,或者idea等工具报如下错误：Can’t get Kerberos realm.
3.问题解决 原文连接：https://stackoverflow.com/questions/34969204/cant-get-kerberos-realm-on-yarn-cluster
方法：复制‪C:\ProgramData\MIT\Kerberos5\krb5.ini 到 /jre/lib/security 目录并修改后缀，不修改是连接不上的
连接成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e8fb118fc99bb823658ed4938eae478/" rel="bookmark">
			初识区块链
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区块链是技术，比特币是区块链技术的应用。
区块链 区块链是一门技术，其本质是数据库属于信息化行业里面的，但是不止属于信息化行业，(在其他行业也有涉及到)是一个分布式的数字账本技术 区块链特点： 透明可信：
人人记账，保证人人获取完整的信息，从而实现信息透明（透明）
节点间决策的过程共同参与，通过达成共识保证可信的（可信）
防篡改、可追溯：
一旦交易信息被纪录信息被纪录在区块链上，就很难被抹除(防篡改)
区块链上的任意一笔交易都有完整的纪录，纪录下来。（可溯源）
去中心化：
1.就是去“去信任”，不需要依赖第三方节点完成交易的确认，去中心化体系；2.还有私钥作为唯一标识
系统可靠性：
1.节点自由度高，不会影响系统的正常运行；2.支持拜占庭容错问题。
注意：防篡改并不等于不能编辑区块链系统上纪录的内容，只是整个编辑的过程被“日志”的形式被完整的纪录下来的，且不能被修改。
区块链涉及领域： 金融，保险，物流和物联网等都有用到区块链技术
区块链技术是源于比特币的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc00ba1cbf4a664dea9dc2f223f719ae/" rel="bookmark">
			Thread.Sleep(0)的妙用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/JianGuoWan/p/9139698.html
Thread.Sleep(0) 表示挂起0毫秒，你可能觉得没作用，你要写Thread.Sleep(1000) 就有感觉了。似乎毫无意义。
MSDN的说明：指定零 (0) 以指示应挂起此线程以使其他等待线程能够执行。
Thread.Sleep(0) 并非是真的要线程挂起0毫秒，意义在于这次调用Thread.Sleep(0)的当前线程确实的被冻结了一下，让其他线程有机会优先执行。Thread.Sleep(0) 是你的线程暂时放弃cpu，也就是释放一些未用的时间片给其他线程或进程使用，就相当于一个让位动作。
Thread th = new Thread(new ThreadStart(MainForm.StartSplash)); th.Priority = ThreadPriority.AboveNormal; th.Start(); Thread.Sleep(0); base.SetStyle(ControlStyles.OptimizedDoubleBuffer | ControlStyles.AllPaintingInWmPaint | ControlStyles.UserPaint, true); this.Initialize(); Thread th = new Thread(new ThreadStart(MainForm.StartSplash)); th.Priority = ThreadPriority.AboveNormal; th.Start(); Thread.Sleep(0); base.SetStyle(ControlStyles.OptimizedDoubleBuffer | ControlStyles.AllPaintingInWmPaint | ControlStyles.UserPaint, true); this.Initialize(); 在线程中，调用sleep（0）可以释放cpu时间，让线程马上重新回到就绪队列而非等待队列，sleep(0)释放当前线程所剩余的时间片（如果有剩余的话），这样可以让操作系统切换其他线程来执行，提升效率。
我们可能经常会用到 Thread.Sleep 函数来使线程挂起一段时间。那么你有没有正确的理解这个函数的用法呢？
思考下面这两个问题：
假设现在是 2017-4-7 12:00:00.000，如果我调用一下 Thread.Sleep(1000) ，在 2017-4-7 12:00:01.000 的时候，这个线程会 不会被唤醒？某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？ 我们先回顾一下操作系统原理。 操作系统中，CPU竞争有很多种策略。Unix系统使用的是时间片算法，而Windows则属于抢占式的。
在时间片算法中，所有的进程排成一个队列。操作系统按照他们的顺序，给每个进程分配一段时间，即该进程允许运行的时间。如果在 时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程 序所要做的就是维护一张就绪进程列表，，当进程用完它的时间片后，它被移到队列的末尾。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc00ba1cbf4a664dea9dc2f223f719ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c06f22b81457dcca5e2f4a0eb88b35e/" rel="bookmark">
			（二）双线性插值python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 （一）原始图像（二）双线性插值原理（三）python实现1. 安装库2. python程序编写3. 效果4. 工程文件 （一）原始图像 （二）双线性插值原理 一般情况下我们对图像缩放的时候会进行上采样或下采样，上采样常采用插值来实现，本文章使用双线性插值实现图像放大
双线性插值的核心思想是在两个方向上分别进行一次插值，关于下图的解释可以参考百度百科：双线性插值
使用双线性插值注意将目标图形和原图像几何中心重合在计算插值，双线性插值只会使用临近的四个像素点坐标，先求x的单线性插值，再求y的单线性插值
这里举例来说明：
关于中心对齐可以参考：双线性插值,个人认为上面中心对齐时+0.5是因为图像坐标从0开始，所以对于33的图像只有（0 1 2）对应到55的图像（0 1 2 3 4），它们的宽高比为5/3，对于33的2只能到25/3=3.3，永远到不了4这个地方，只能先+0.5才能到4，（2+0.5）*5/3=4.1
（三）python实现 python安装可以参考：python安装
1. 安装库 首先我们需要安装用到的库，按住win+r输入cmd打开dos窗口，输入下面的命令
pip install opencv-python pip install numpy 2. python程序编写 import cv2 # cv2 即opencv的库 import numpy as np #给numpy起别名np，该库Numerical Python是python的数学函数库 #双线性插值实现 def bilinear_interpolation(img,out_dim): src_h,src_w,channels = img.shape dst_h,dst_w = out_dim[1],out_dim[0] print("src_h,src_w= ",src_h,src_w) print("dst_h,dst_w= ",dst_h,dst_w) if src_h == dst_h and src_w == dst_w: return img.copy() dst_img = np.zeros((dst_h,dst_w,3),dtype=np.uint8) scale_x,scale_y = float(src_w)/dst_w,float(src_h)/dst_h for i in range(3): for dst_y in range(dst_h): for dst_x in range (dst_w): #根据几何中心重合找出目标像素的坐标 src_x = (dst_x+0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c06f22b81457dcca5e2f4a0eb88b35e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e938d49291c86f220df758ca97896439/" rel="bookmark">
			钉钉H5微应用开发免登以及接口调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		钉钉H5微应用开发以及接口调试 企业内部应用免登
https://open.dingtalk.com/document/orgapp-server/enterprise-internal-application-logon-free
1. H5微应用免登录开发 开发微应用
需要获取到钉钉企业的ID ，打开https://open-dev.dingtalk.com/ 地址获取，页面右上角的CorpId
钉钉官方提供的微应用免登授权码在线请求：
https://open-dev.dingtalk.com/apiExplorer?spm=ding_open_doc.document.0.0.45642b498W49hm#/jsapi?api=runtime.permission.requestAuthCode
引入钉钉官方提供的js sdk &lt;script src="https://g.alicdn.com/dingding/dingtalk-jsapi/2.13.42/dingtalk.open.js"&gt;&lt;/script&gt;
获取临时登录code免登授权码 dd.runtime.permission.requestAuthCode({
corpId: "企业ID",
onSuccess: function(result) {
result.code; //免登授权码
}
根据获取到的code请求后端接口，进入免登录流程 调试微应用
网页版调试：
https://open.dingtalk.com/document/resourcedownload/h5-micro-application-debugging-tool
RC版调试
https://open.dingtalk.com/document/resourcedownload/h5-debug
推荐使用RC版调试的Android调试包，使用谷歌浏览器打开chrome://inspect 地址进行调试
开发过程中可以使用穿透工具，方便打断点调试，省去发布过程，提高效率。
穿透工具推荐钉钉官方提供的工具
https://open.dingtalk.com/document/resourcedownload/http-intranet-penetration
以及开源的FastTunnel（gitee有源码以及文档
https://gitee.com/Hgui/FastTunnel?_from=gitee_search，目前已有1.9k星）
2. 免登录接口调用 服务端SDK下载:https://open.dingtalk.com/document/resourcedownload/download-server-sdk
.net 的还需要引入nuget包AlibabaCloud.SDK.Dingtalk
官方在线请求api文档：https://open.dingtalk.com/document/resourcedownload/api-explorer
还需要保存H5微应用的appkey以及appsecret在H5微应用控制台可得到
获取accessToken免登凭证，需要h5微应用应用的appkey和appsecret 在线请求地址，含有代码示例
https://open-dev.dingtalk.com/apiExplorer?spm=ding_open_doc.document.0.0.45642b498W49hm#/?devType=org&amp;api=dingtalk.oapi.sso.gettoken
通过免登码获取到用户信息，需要前端提供的code和后端获取到的accesstoken https://open-dev.dingtalk.com/apiExplorer?spm=ding_open_doc.document.0.0.45642b498W49hm#/?devType=org&amp;api=dingtalk.oapi.v2.user.getuserinfo
获取用户详情，需要根据用户信息获取到的userid以及accesstoken(判断用户身份只需要走到第二步就行） https://open-dev.dingtalk.com/apiExplorer?spm=ding_open_doc.document.0.0.51cb3a086Isuuh#/?devType=org&amp;api=dingtalk.oapi.v2.user.get
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/026ef48e86d7428186f43fa497872708/" rel="bookmark">
			C# 获取当前时间戳（正确版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 https://www.cnblogs.com/yinmu/p/11228196.html
第一种：
/// &lt;summary&gt; /// 获取时间戳 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string GetTimeStamp() { TimeSpan ts = DateTime.Now - new DateTime(1970, 1, 1, 0, 0, 0, 0); return Convert.ToInt64(ts.TotalSeconds).ToString(); } 第二种：
/// &lt;summary&gt; /// 获取时间戳 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string GetTimeStamp() { TimeSpan ts = DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, 0); return Convert.ToInt64(ts.TotalMilliseconds).ToString(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86e86d8faf4fb5ca1390693a8d7cb8bd/" rel="bookmark">
			What is the Softmax Function?详解机器学习中的Softmax函数【小白菜可懂】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
定义
公式
计算
Softmax vs Sigmoid
Softmax vs Sigmoid 计算
Softmax vs Argmax
Softmax vs Argmax 计算
应用
神经网络中的Softmax函数
神经网络中的Softmax计算示例
强化学习中的Softmax函数
强化学习中的Softmax计算示例
历史
参考
定义 softmax函数是把K个实值转换为另外K个实值并使K个实值之和为1的函数。输入数值可以是正数/负数/0或者几种的组合，经过softmax函数转换为[0，1]之间的数值，以便于用来描述概率分布。如果一个输入数值很小或负数，softmax函数则将它转换为小的概率值；如果一个输入数值很大，softmax函数则将它转换为大的概率值，每一个转换后的数值都将保持在[0,1]的范围之内。
Softmax函数有时被称为Softargmax函数，或multi-class logistic regression（多类别逻辑回归函数）。这是因为softmax函数是逻辑回归函数的一般化形式，可用来作多种类分类任务，它的公式与常用的逻辑回归sigmoid函数非常相似。Softmax函数这种分类器只能用在类别相互独立不相关的情况下。
很多多层神经网络在倒数第二层结束时输出的结果不便于规整，很难处理。在此，softmax函数正好派上用场，因为它可以把输出的结果数值归一化到概率的分布上，可以展示给用户或者作为输入传给其他系统。因此经常在神经网络的最后一层加上softmax函数。
公式 softmax函数公式如下：
Mathematical definition of the softmax function
所有的zi值是输入vector的元素，可以是任意实值。下面各项是归一化项来保证输出数值之和等于1，也就构成了一个有效的符合逻辑的概率分布。
【Softmax公式符号解释】
输入vector，由（）组成有的zi值是输入vector的元素，可以是任意实值。例如一个神经网络有一个（-0.62,8.12,2.53）的vector输出，这不是一个有效的符合逻辑的概率分布，这正是softmax的用武之地。标准的指数函数被用于输入vector的每一个元素，它输出一个大于0的正值，如果输入负值，则输出结果小，如果输入大正值，则输出结果大。然而，输出结果不会被限定于（0，1）之间，不符合概率分布的要求。公式的分母项是归一化项，它保证函数输出结果值之和为1，且每个输出结果在（0，1）之间，因此构成一个有效的符合逻辑的概率分布。多类别分类器的类别数量。 计算 假设有一个包含三个实值的数组。这些值可能是机器学习模型（神经网络模型）的输出。我们想把这些值转换为概率分布。
首先计算数组每个元素的指数函数值。这是softmax等式的分子项。
这些值还不像是概率值。注意输入元素，尽管8只比5大一点，2981却比148大很多，这是因为指数函数作用。我们能够归一化它们，通过上述三个指数运算后结果的求和来作为softmax等式的分母。
我们看到归一化项主要受z1的影响。
最后，除以归一化项，我们得到了每个元素的softmax输出数值。注意这不是单个的输出数值，而是softmax函数将一个数组转换为同长度的数组，在此长度为3。
经我们检验，三个输出值都是有效的符合逻辑的概率值，它们处于（0，1）之间，且求和为1。
由于指数运算，第一个元素8，softmax函数放大了它的影响力，同时压缩5和0的输出值，降到很小的概率值。
如果你在机器学习模型中使用softmax函数，在解释它为真实概率值之前要谨慎，因为它有一个产生近似于0或1数值的偏向趋势。如果神经网络有一个[8,5,0]输出值，如示例所示，softmax函数将会赋予95%的概率值给第一个类别，但这在实际神经网络预测中存在不确定性。这将会导致神经网络预测有一个很高的置信度，但是预测的结果却不是真实的结果。
Softmax vs Sigmoid 如上所述，softmax函数与sigmoid函数是相似的。softmax运算的是vector，sigmoid运算的是标量。
实际上，sigmoid函数是softmax函数的一种特殊形式，是一种二分类的分类器。我们看到，如果我们设置输入vector为[x,0]，用softmax公式计算第一个元素的输出数值：
分式上下同除以，可得：
可见，当二分类时，sigmoid函数与softmax函数是相等的。计算vector第二个元素的数值是不必要的，因为只有两个概率值且它们和为1。故而，我们用逻辑回归开发一个两个类别的分类器，我们可以使用sigmoid函数，不用去处理vectors。但是，超过两个的/相互独立不相关的类别时须使用softmax函数。
如果超过两个类别但是它们不是相互独立的类别（多标签分类器，举个🌰：一辆骚红色的/敞篷的轿车，打了red/open-body/car三个标签，包含了颜色/框架结构/功能类别三个属性，三个属性至之间的类别便不是相互独立的，可以交叉相互从属）时，分类器必须分解为多个二元分类器，每种使用独有的sigmoid函数。
Softmax vs Sigmoid 计算 我们设定输入vector为[3,0]，将其代入softmax和sigmoid函数。尽管sigmoid函数输入的是标量，我们可以只选择vector第一个元素代入sigmoid函数。
当vector第二个元素被设定为0时，对于vector第一个元素，sigmoid函数和softmax函数给出了相同的数值。因为sigmoid给出的是概率值且两个概率值之和必须是1，所以计算vector的第二个元素的输出值不是必要的。
Softmax vs Argmax 相较于argmax函数，softmax函数被用于是一种平滑的可微的选择。因此softmax函数有时候被更明确地称之为softargmax函数。和softmax函数一样，argmax函数进行vector运算，转换每一个数值到0，除了最大值之外，最大值被转换为1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86e86d8faf4fb5ca1390693a8d7cb8bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4bb0d3f5ee3c112a610306ab48dac1b/" rel="bookmark">
			基于SpringBoot&#43;Vue的音乐网站项目-附源码&#43;报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 项目简介项目功能项目结构项目展示项目地址 项目简介 本音乐网站的客户端和管理端使用 VUE 框架来实现，服务端使用 Spring Boot + MyBatis 来实现，数据库使用了 MySQL。
技术栈 后端 SpringBoot + MyBatis
前端 Vue + Vue-Router + Vuex + Axios + ElementUI git
开发环境 JDK： jdk-8u141 mysql：mysql-5.7.21-1-macos10.13-x86_64 node：v12.4.0 IDE：IntelliJ IDEA 2020、VSCode
项目功能 项目功能 音乐播放 用户登录注册 用户信息编辑、头像修改 歌曲、歌单搜索 歌单打分 歌单、歌曲评论 歌单列表、歌手列表分页显示 歌词同步显示 音乐收藏、下载、拖动控制、音量控制 后台对用户、歌曲、歌手、歌单信息的管理
前端页面使用 Vue渐进式框架完成对页面的模块化设计，使用 JQuery 与 Ajax 进行前端数据处理并用于传输数据。后端逻辑代码由 JavaEE 开发源代码，SpringBoot框架构建项目整合框架，Maven管理项目以及库文件，MySQL 数据库技术进行数据持久化处理。
项目结构 ├── build //webpack相关配置文件
├── config //vue基本配置文件
├── node_modules //包
├── index.html //入口页面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4bb0d3f5ee3c112a610306ab48dac1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2cf8543791f95f92688076050ea092e/" rel="bookmark">
			html&#43;css实现唯美简洁登录页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简介
本案例是html和css实现的唯美简洁的登录界面。纯粹个人一时兴起所写。可以适用于个人博客登录以及其他系统的登录界面，登录title可以随时修改。
2.先看效果。
3.上代码。
代码复制粘贴，修改里面的图片路径就可以直接运行。
4.html页面代码。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;唯美登录页面&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/唯美登录页面.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="bgWrapper"&gt;&lt;/div&gt; &lt;div class="loginWrapper"&gt; &lt;p class="title"&gt;BlogLogin&lt;/p&gt; &lt;div class="inputWrapper"&gt; &lt;label for="uname"&gt;用户名&lt;/label&gt; &lt;p class="user"&gt;&lt;input type="text" name="" id="uname" value="" placeholder="UserId" /&gt;&lt;/p&gt; &lt;label for="ps"&gt;密码&lt;/label&gt; &lt;p class="pwd"&gt;&lt;input type="password" name="" id="ps" value="" placeholder="Password" /&gt;&lt;/p&gt; &lt;p&gt;&lt;button class="btn"&gt;Login&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="shadow"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 5.css代码。
*{ margin: 0px; padding: 0px; } body,html{ width: 100%; height: 100%; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2cf8543791f95f92688076050ea092e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa20d721bcb15c604464557c303e453/" rel="bookmark">
			Node.js的文件读取；包括文本,图片,视频等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Node.js读取文件内容包括同步和异步两种方式。
以下面文档为例,同步异步,视频文档图片方法都一样,
1同步读取 fs.readFileSync(参数1,参数2)
第一个参数,读取文件的路径; 第二个参数,配置信息,读取文件以utf8编码格式显示
读取其中的txt文件;如
方法1:./相对路径读取方法
var data = fs.readFileSync("./被01js读取的文件.txt","utf8");
方法2:__dirname 绝对路径读取方法,是获取该文件的目录路径.用加号拼接:注意,不要再加.
读取成功
二;异步获取 一般都用回调函数完成 fs.readFile(参数1路径,参数2编码格式,回调函数)
如用绝对路径; 回调路径中的参数
err是读取文件错误的信息; 如果没有错误,则返回null;就是假的,空为假;
data 读取文件成功之后获取的数据; fs.readFile(__dirname+"/被01js解析的图片.png","utf8",function(err,data){
if(err){//判断是不是错误,没有错误为空,错误则执行
return console.error(err);//错误信息
}
console.log(data);//文件没有错误,获取读到的数据
})
注意:视频图片解析过来的是一对乱码;和文本不同
文字的话把上面的绝对路径拼接改为文本文件名就可以.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c48fb07e31f8d723e8e8336063841cee/" rel="bookmark">
			网站报错“internal server error”如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个问题不是浏览者造成的，而是你所浏览的网站服务器出现了故障引起的或网站所在服务器正在维护引起，一般来讲，如果对这种错误不加处理的话，会持续不可访问，甚至会显示一片乱码，有经验的程序员，维护时可设置显示该网站正在维护，或者此页无法显示，如果非维护时间出现这个提示，则是服务器真有故障了。
引起这种错误，有以下几种原因： １、数据库问题 网站读写操作都在数据库，数据库如果异常的话，访问不正常，遇到此类情况，通知网站的管理员或网站开发者，让他帮助分析解决，解决完毕后，访问就会正常。 ２、配置问题 有的时候，用户无法访问网站，是因为系统参数的配置有问题，遇到这种情况，找服务器管理人员进行处理，处理完毕，访问就正常了。 3、中毒引起 有的时候，有病毒会改写服务器的一些设置，导致用户无法正常访问，报500的错误，这时需要程序员进行杀毒处理，处理完程序后，系统恢复正常。 4、程序漏洞 当程序员编写的程序不够严谨，出现异常的时候，浏览者也会看到500的错误，解决这种问题的方法是，联系程序开发人员，进行程序跟踪，找到错误所在，然后修改程序，经测试没有问题，重新发布程序，然后系统正常。 5、日常维护 服务器日常维护，进行停机处理，或者更新程序，这时候，浏览者登陆该网站，就会报500的错误，一般等维护更新完毕，启动服务器以后，就自动解决，用户只需要耐心等待即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a0e530d924fc22dfb3fd16271669b80/" rel="bookmark">
			MATLAB 练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 输入一个整数n&lt;10
输入n+2行，如图的图形：核心n行，周边被*号保卫
输入 一个整数
输出 字符图形
样例输入 Copy 4 样例输出 Copy * *A* *BBB* *CCCCC* *DDDDDDD* *********** 分析，该字符图形可以划分为5个部分，首先是第一部分，输出图形左边的空格：
n = input(''); for i = 1:n + 1 for j = 1:n + 2 - i fprintf(' '); % 输出 左边的空格 end fprintf('*'); % 输出左边的 *号 for j = 1:2 * i - 3 fprintf('%c', 'A' + i - 2); % 输出每行的字母 end if i &gt; 1 % 当输入的 行数 大于 n 时， 输出 右边的 * 号 fprintf('*'); end fprintf('\n'); % 每输出一行换行 end for i = 2 * (n + 1) + 1: -1: 1 % 输出 最后一行的 *********** fprintf('*'); end 第一次循环 当 输入为4 时，n = 4，执行第一次循环 i = 1，总共循环5次
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a0e530d924fc22dfb3fd16271669b80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c47e5ac02f265da92c078069a475380/" rel="bookmark">
			b站课堂模式密码破解经历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 为了约束自己玩手机，我设置了课堂模式然后成功的忘掉了密码，本来以为四数密码破解很容易，然鹅…悲剧了
b站只有手机版有课堂模式，pc版没有，于是用雷电模拟器登入b站，尝试用fiddle和burpsuit抓包，但是根本抓不到，关闭网络也能验证，推测应该是在前端验证，尝试去找用户文件，肯定没找到了QAQ，最后只能去找万能的按键精灵，因为手机竖屏嘛，所以第一个字母肯定不是123，相邻的数字肯定不重复，写了一下按键精灵代码，跑了俩小时出来了QAQAQ，还不知道为什么keyPress用不了，只能用KeyUp、KeyDown，而且不知道是不是因为我按键精灵是2014版本的还是知乎上搜到的代码不全，根本就不能用！！！按键码这玩意好坑啊啊啊啊
Dim i1 Dim i2 Dim i3 Dim i4 For i1 = 52 To 57 For i2 = 48 To 57 For i3 = 48 To 57 For i4 = 48 To 57 If i1&lt;&gt;i2 and i2&lt;&gt;i3 and i3&lt;&gt;i4 Then MoveTo 1385, 341 Delay 1599 LeftClick 1 MoveTo 1387, 341 Delay 1074 KeyDown i1,1 Delay 87 KeyUp i1,1 Delay 87 KeyDown i2,1 Delay 87 KeyUp i2,1 Delay 1241 KeyDown i3,1 Delay 96 KeyUp i3,1 Delay 96 KeyDown i4,1 Delay 118 KeyUp i4,1 Delay 118 MoveTo 1424, 436 Delay 1889 LeftDown 1 MoveTo 1424, 437 Delay 69 LeftUp 1 End If Next Next Next Next 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3216badcac8ce1cde5409aabc290db8/" rel="bookmark">
			【scikit-learn】K近邻（KNN）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KNN KNN(K-Nearest Neighbor)是最简单的机器学习算法之一，可以用于分类和回归，是一种监督学习算法。它的思路是这样，如果一个样本在特征空间中的K个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。也就是说，该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。
KNN用于分类 计算待分类点与已知类别的点之间的距离按照距离递增次序排序选取与待分类点距离最小的K个点确定前K个点所在类别的出现次数返回前K个点出现次数最高的类别作为待分类点的预测分类 KNN回归预测 回归中，一般采用平均值法或者加权平均值法
平均值法： 每个邻近样本的权重是一样的，最终预测的结果为所有邻近样本目标属性值的均值
加权平均值法：一般采用权重和距离成反比的方式计算
KNN算法要注意的问题 无论是分类还是回归，KNN算法的几个关键点：
算法超参数K距离度量，特征空间中样本点的距离是样本点间相似程度的反映分类决策规则，少数服从多数。 算法超参数K 如果选择较小的K值，就相当于用较小的邻域中的训练实例进行预测，“学习”的近似误差会减小，只有输入实例较近的训练实例才会对预测结果起作用。但缺点是“学习”的估计误差会增大，预测结果会对近邻实例点非常敏感。如果邻近的实例点恰巧是噪声，预测就会出错。换句话说，K值得减小就意味着整体模型非常复杂，容易发生过拟合。
如果选择较大的K值，就相当于用较大邻域中的训练实例进行预测，其实优点是减少学习的估计误差，但缺点是学习的近似误差会增大。这时与输入实例较远的训练实例也会起预测作用，使预测发生错误，k值的增大就意味着整体的模型变得简单，容易发生欠拟合。可以假定极端条件K=N，那么无论输入实例是什么，都将简单的预测它属于训练实例中最多的类。这时，模型过于简单，完全忽略训练中的大量有用信息，是不可取的。
在应用中，通常采用交叉验证法来选择最优K值。从上面的分析也可以知道，一般K值取得比较小。我们会选取K值在较小的范围，同时在验证集上准确率最高的那一个确定为最终的算法超参数K。
距离度量 常用的距离有三种，分别为曼哈顿距离、欧式距离和闵可夫斯基距离
KNN的优缺点 优点：
1）算法简单，理论成熟，既可以用来做分类也可以用来做回归。
2）可用于非线性分类。
3）没有明显的训练过程，而是在程序开始运行时，把数据集加载到内存后，不需要进行训练，直接进行预测，所以训练时间复杂度为0。
4）由于KNN方法主要靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属的类别，因此对于类域的交叉或重叠较多的待分类样本集来说，KNN方法较其他方法更为适合。
5）该算法比较适用于样本容量比较大的类域的自动分类，而那些样本容量比较小的类域采用这种算法比较容易产生误分类情况。
缺点：
1）需要算每个测试点与训练集的距离，当训练集较大时，计算量相当大，时间复杂度高，特别是特征数量比较大的时候。
2）需要大量的内存，空间复杂度高。
3）样本不平衡问题（即有些类别的样本数量很多，而其它样本的数量很少），对稀有类别的预测准确度低。
4）是lazy learning方法，基本上不学习，导致预测时速度比起逻辑回归之类的算法慢。
实战 ''' 数据集：Mnist 训练集数量：60000 测试集数量：10000（实际使用：10）可更改 ''' import time import numpy as np import sys import os # 导入处于不同目录下的Mnist.load_data parent_path=os.path.dirname(os.path.dirname(sys.argv[0])) # 获取上级目录 sys.path.append(parent_path) # 修改sys.path from torchvision.datasets.mnist import MNIST from torch.utils.data import DataLoader from torchvision import datasets import torchvision import torchvision.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3216badcac8ce1cde5409aabc290db8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ef3813cdbc4644ff0ced20293256a5f/" rel="bookmark">
			亲密数对c&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 键盘输入N，N在2至2000之间，求2至N中的亲密数对，就是A的因子和等于B，B的因子和等于A，且A≠B。 如48和75是亲密数对。48的因子和为2+3+4+6+8+12+16+24=75，而75的因子和为3+5+15+25=48。
输入
只有一行，为一个整数N（ 2&lt;=N&lt;=2000 ）
输出
输出若干行，每行两个整数（用一个空格隔开）。
样例
输入复制
200
输出复制
48 75
75 48
140 195
195 140
说明
请注意，求出的亲密数对的2个数都不应该超过n的范围。
#include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int he(int n) { int i,s=0; for(i=2;i&lt;=sqrt(n);i++){ if(n%i==0){if(n/i!=i) {s=s+n/i+i;} else s=s+i; } } return s; } int main() { int n,i; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ if(i==he(he(i))&amp;&amp;i!=he(i)&amp;&amp;he(i)&lt;=n) cout&lt;&lt;i&lt;&lt;" "&lt;&lt;he(i)&lt;&lt;endl;} } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaeb7e2beb9750a4af9a891fc8c417a2/" rel="bookmark">
			IM服务器：一个使用imserver服务器进行聊天的web端案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该案例中包含一个基于web网页的前端程序，该案例会使用websocket与IM服务器（imserver）进行通信。
一、环境准备 1、下载 “imserver网页调用案例”，并解压到指定目录。
2、进入“web/js”目录中，使用文本编辑器打开“main.js”文件。
修改websocket的连接地址，该地址是IM服务器的地址。
如下图：
注意：IP地址不要填写127.0.0.1，填写ipcoinfg中配置的ip地址。
二、运行服务 1、启动web服务器
双击解压目录中的 HttpServer.exe 程序。
这是一个高性能的web服务器，详情见文章《HttpServer：一款Windows平台下基于IOCP模型的高并发轻量级web服务器》。
启动后目录中web中网页将会发布，默认主页是web目录中的user.html，默认端口是80（可通过配置文件HttpServer.ini进行修改）。
2、启动IM服务器
下载目录
下载该目录中的 imserver.exe 到指定目录中，双击运行即可。
IM服务器的详情见文章《IM服务器：我的千万级即时通信服务器集群》
三、IM聊天 打开浏览器，输入HttpServer运行所在机器的IP地址，出现如下网页：
每个用户都有一个uid，以及当前所在的组id。
点击用户后，组成员之间可群聊。如下图，老师和学生一进行群聊。
写在最后：由于我不会写web程序，该案例是让人帮忙代写，比较仓促，只是为了展示如何利用imserver开发web端的聊天程序，与imserver的通信逻辑都在main.js中，比较简单。
感谢您的阅读！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/019a4cfb9c155e2597ed82b1e289361e/" rel="bookmark">
			SOP是什么？SOP的作用是什么？如何编写SOP？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SOP是由Standard Operation Procedure这三个英文单词的首个字母组合而成。也就是以统一化的标准将操作流程的步骤和要求罗列出来，用于指导和规范日常工作。SOP的核心，就是把特定流程的关键问题细化及量化。
SOP是以文件的方式归纳总结操作人员在实际生产过程中的具体操作步骤和应当要注意的事项，它是车间现场操作人员的作业指导模板，也是质量检验人员用于检测指导工作的依据。
SOP的作用：
1、把企业长期累积的经验技术记录归纳，汇总成简单易懂的标准化文件，即使出现操作人员变动也不会使已有的技术流失。
2、让现场操作人员根据详细的标准，在最快的时间内掌握操作要领，提升上手速度，掌握正确的操作方法
3、操作标准有据可依，更容易找出不良产品产生的原因。
4、真正让车间的生产管理规范起来，生产流程简单标准。为企业竖立良好的形象，取得客户的信赖，提高客户的满意度。也是企业最基础，也最行之有效的管理性技术资料。
很多企业操作者关心的是，如何编写SOP呢？
首先，我们要知道SOP编写要条理清晰、结构规范、简洁形象、具有很强的逻辑性、内容精准、可操作性强，让操作人员容易弄懂，方便上手。
其次，SOP的编写成员要是有经验且实操性较好的一线员工，决不能纸上谈兵。编写小组要有充分的时间和足够的资料进行编写。要和各部门沟通商讨，理论结合实际。
最后，SOP编写完成后，要先进行试运行，检测其在实际操作中的合理性，是否具有可操作性。试运行成功后，要让各部门严格按照SOP进行操作并及时反馈信息。相关人员定期根据反馈的信息进行核查。当车间设备、客户要求发生变更时，生产方法也需随之改变，这时就需对SOP进行及时的更新维护。
编写SOP需要大量的数据统计和分析，仅仅依靠人力操作起来相当困难，所以需要借助专业的软件来完成。如vioovi的工时分析软件，它是国内首款智能工时分析软件，从功能和可操作性来说都是为国内企业量身打造的，非常适用。通过vioovi的智能分析，可以消除无效动作，排列组合视频，形成一套标准化的操作指导分析。
vioovi是一款高新智能软件，它将车间各个流程的操作过程的视频都收集汇总，并将操作流程和员工行为做出数字化改进。各类分析数据的供给有助于企业建立各类 IE数据应用中心，是对企业进行数字化管理的核心工具。
在车间生产、仓库管理、装卸物流等各道工序增加 IE数据中心、工时数据库、标准工时库、视像资料库、标准作业视频库、动作代码库、人力需求分析表、生产计划、产品标准工作时间表、生产能力计算表、视频 SOP等。可将生产力视频监控系统、生产效率计算中心等进一步整合，推动企业在数据化的基础上进行新的精益变革，通过技术融合，实现企业向标准化、数字化、科技化转型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76b26d629b729f2803b1aed2536b6d15/" rel="bookmark">
			单例模式的N种实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是小黑，一名在互联网“苟且”的程序员
关注同名公众号【小黑说Java】，更多干货内容抢先送达，更有不定期抽奖送书活动。
流水不争先，贵在滔滔不绝
如果你自认为已经掌握懒汉式、饿汉式、DCL、IoDH、枚举等单例实现方式，可以直接看最后的打破单例。如果不是，建议你耐心从头看完。
相信你看完本文能让你掌握Java中所有单例模式的设计方式。
单例设计模式是GOF 23中设计模式中常见的设计模式之一，不论是在我们日常开发，还是一些第三方库中几乎都能见到单例模式。包括在面试时初中级的程序员基本都会被问到单例模式。
单例模式的目的主要是为了保证在多线程场景下实例唯一的一种解决方案，实现起来还是比较简单的，但是实现方式各式各样，五花八门，今天小黑带大家梳理下单例模式的7种实现方式，并比较各有什么优缺点。
饿汉式 饿汉式，顾名思义一上来就会创建实例对象，因为很饿嘛，马上就要创建出来。
/** * @author java_xiaohei 公众号：小黑说Java * @ClassName Singleton * @Description 单例设计模式：饿汉式 * @date 2021/9/27 **/ public final class Singleton { // 定义变量时直接初始化 private static Singleton instance = new Singleton(); // 构造方法私有，不允许外部new private Singleton() { } // 外部通过getIntstance获取实例 public static Singleton getInstance() { return instance; } } 饿汉式的关键在于定义instance时直接实例化。通过饿汉式完全可以保证实例对象的线程安全。
但是有一个问题，如果该实例对象被创建之后过了很久才会被访问，那么在访问之前这个对象数据会一直存放在堆内存当中，如果实际场景中单例对象的实例数据很大，将会占用比较多的资源，这种方式则不太合适。
懒汉式 懒汉式相对饿汉式而言，区别的地方主要在创建对象的时机有区别，不会在定义变量时初始化，而是在需要使用时才进行创建。
public final class Singleton { // 定义变量时不做初始化 private static Singleton instance = null; // 构造方法私有，不允许外部new private Singleton() { } // 外部通过getIntstance获取实例 public static Singleton getInstance() { if(instance==null){ instance = new Singleton(); } return instance; } } 这种方式相对饿汉式而言，可以避免在使用对象之前创建对象造成的空间资源浪费。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76b26d629b729f2803b1aed2536b6d15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/272d698c0dfb7665bb2bf6f4a42c2bb8/" rel="bookmark">
			基于TC和netem实现网络异常情况的模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、TC介绍
Linux内核内置了一个TC（Traffic Control）框架，可以实现流量限速，流量整形，策略应用(丢弃，NAT等)。原理大致如下图所示，主要是通过在输出端口处建立一个队列来实现流量控制：
报文分组从输入网卡(入口)接收进来，经过路由的查找，以确定是发给本机的，还是需要转发的。如果是发给本机的，就直接向上递交给上层的协议，比如TCP，如果是转发的，则会从输出网卡(出口)发出。网络流量的控制通常发生在输出网卡处。虽然在路由器的入口处也可以进行流量控制，Linux也具有相关的功能，但一般说来，由于我们无法控制自己网络之外的设备，入口处的流量控制相对较难，反之出口处的流量控制较为容易。
流量控制的一个基本概念是队列(Qdisc)，每个网卡都与一个队列(Qdisc)相联系，每当内核需要将报文分组从网卡发送出去，都会首先将该报文分组添加到该网卡所配置的队列中，由该队列决定报文分组的发送顺序，即所有的流量控制都发生在队列中。
有些队列的功能是非常简单的，它们对报文分组实行先来先走的策略。有些队列则功能复杂，会将不同的报文分组进行排队、分类，并根据不同的原则，以不同的顺序发送队列中的报文分组。为实现这样的功能，这些复杂的队列需要使用不同的过滤器(Filter)来把报文分组分成不同的类别(Class)。这里把这些复杂的队列称为可分类(ClassfuI)的队列。
通常， 要实现功能强大的流量控制，可分类的队列是必不可少的。因此，类别(class)和过滤器(Filter)也是流量控制的另外两个重要的基本概念。图2所示的是一个可分类队列的例子。
使用TC 在Linux中，流量控制都是通过TC这个工具来完成的。通常，要对网卡进行流量控制的配置，需要进行如下的步骤：
为网卡配置一个队列； 在该队列上建立分类； 根据需要建立子队列和子分类； 为每个分类建立过滤器。 具体命令参见https://blog.csdn.net/hexf9632/article/details/118568933
二、netem简介 netem是linux内核提供的Network emulation服务，可以用来模拟广域网下的延迟、丢包、重复、损坏和乱序等问题。2.6版本后的linux发行版都已经在内核中启用了netem，netem内核组件在以下情况下启用：
Networking --&gt; Networking Options --&gt; QoS and/or fair queuing --&gt; Network emulator 重要：netem 是直接添加到网卡上的，也就是说所有从网卡发送出去的包都会收到配置参数的影响！
假如需要回退到正常情况，请谨记下面这个命令：
删除 eth0网卡之前添加的netem配置 tc qdisc del dev eth0 root netem延迟设置
DELAY := delay TIME [ JITTER [ CORRELATION ]]] [ distribution { uniform | normal | pareto | paretonormal } ] TIME：延迟的时间
JITTER：抖动，增加一个随机时间长度，让延迟时间出现在某个范围
CORRELATION：相关，下一个报文延迟时间和上一个报文的相关系数
distribution：分布，延迟的分布模式，可以选择的值有 uniform、normal、pareto 和 paretonormal
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/272d698c0dfb7665bb2bf6f4a42c2bb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aff14f8c16d6fdf278a4dfcd596d5449/" rel="bookmark">
			MySQL：千万级数据删除导致的慢查询优化实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际上个别特殊情况下，MySQL出现慢查询并不是SQL语句的问题，而是它自己生成服务器的负载太高了，导致SQL语句执行很慢。
举个例子，比如现在MySQL服务器的磁盘IO负载特别高，也就是每秒执行大量的高负载的随机IO，但是磁盘本身每秒能执行的随机IO是有限的。结果就导致你正常的SQL语句去磁盘上执行的时候，如何要跑一些随机IO，你的磁盘太繁忙了，顾不上你，导致你本来很快的一个SQL，要等很久才能执行完毕，这个时候就可能导致正常SQL语句也会变成慢查询。除了磁盘以外，还有一个例子就是网络，也许网络负载很高，就可能导致你一个SQL语句要发送到MySQL上去，光是等待一个跟MySQL的连接，都很难，要等很久，或者MySQL自己网络负载太高了，带宽打满，带宽打满之后，你一个SQL也许执行很快，但是它查出来的数据返回给你，网络都发送不出去，此时也会变成慢查询。另外一个是CPU负载，如果CPU负载过高的话，也会导致CPU过于繁忙去执行别的任务了，每时间执行你这个SQL语句，此时也有可能导致SQL语句出现问题的 所以说慢查询本身不一定是SQL导致的，如果你觉得SQL不应该慢查询，结果他那个时间段跑这个SQL就是慢，此时你应该排查一下当时MySQL服务器的负载，尤其看看磁盘、网络以及CPU的负载，是否正常
如果你发现那个时间段MySQL生产服务器的磁盘、网络或者CPU负载特别高，那么可能是服务器负载导致的问题
举个例子，当某个作业瞬间把大批量数据往MySQL里插入，它一瞬间服务器磁盘、网络、CPU负载都会超高。此时你一个正常SQL执行下去，短时间内一定会慢查询的，针对类似的问题，优化手段更多的是控制你导致MySQL覆盖过高的行为，这些行为最好在凌晨低峰期灌入，别影响线上系统运行。
但是如果MySQL服务器的磁盘、网络以及CPU复制正常呢？也就是说不是这个原因导致的。那怎么排查呢？
一方面可以通过执行计划检测SQL是否有问题，另一个就是检测服务器的负载，如果还是不行，第三步就是可以用MySQL profilling工具去细致分析SQL语句的执行过程和耗时。
首先打开这个profiling，使用用set profiling=1这个命令，接着MySQL就会自动记录查询语句的profiling信息了。此时如果执行show profiles命令，就会给你列出各种查询语句的profiling信息，这里很关键的一点是，就是它会记录下来每个查询语句的query id，所以你要针对你需要分析的query找到它对应的query id。然后就可以针对单个查询语句，看一下它的profiling具体信息，使用show profile cpu, block io for query xx，这里的xx是数字，此时就可以看到具体的profile信息了除了cpu以及block io以外，你还可以指定去看这个SQL语句执行时候的其他各项负载和耗时。他这里会给你展示出来SQL语句执行时候的各种耗时，比如磁盘IO的耗时，CPU等待耗时，发送数据耗时，拷贝数据到临时表的耗时，等等吧，反正SQL执行过程中的各种耗时都会展示出来的。 针对上面的这个SQL语句的profiling信息，重点发现了一个问题，他的Sending Data的耗时是最高的，几乎使用了1s的时间，占据了SQL执行耗时的99%，这就很坑爹了
因为其他环节耗时低是可以理解的，毕竟这种简单SQL执行速度真的很快，基本就是10ms级别的，结果跑成了1s，那肯定Sending Data就是罪魁祸首了！
个Sending Data是在干什么呢？MySQL的官方释义如下：为一个SELECT语句读取和处理数据行，同时发送数据给客户端的过程，简单来说就是为你的SELECT语句把数据读出来，同时发送给客户端。
可是为什么这个过程会这么慢呢？profiling确实是提供给我们更多的线索了，但是似乎还是没法解决掉问题。但是毕竟我们已经捕获到了第一个比较异常的点了，就是Sending Data的耗时很高！请大家记住这个线索。
有时候针对MySQL这种复杂数据库软件的调优过程，就跟福尔摩斯破案一样，你要通过各种手段和工具去检查MySQL的各种状态，然后把有异常的一些指标记下来，作为一个线索，当你线索足够多的时候，往往就能够汇总大量的线索整理出一个思路了，那也就是一个破案的时刻了！
接着我们又用了一个命令：show engine innodb status，看一下innodb存储引擎的一些状态，此时发现了一个奇怪的指标，就是history list length这个指标，他的值特别高，达到了上万这个级别。
MySQL中有一个MVCC机制，就是多个事务在对同一个数据，有人写，有人读，此时可以有多种隔离级别。你必须对一个数据都一个多版本快照链条，才能实现各种MVCC和隔离机制。
所以当你有大量事务执行的时候，就会构建这种undo多版本快照链条，此时history list length的值就会很高。然后在事务提交之后，会有一个多版本快照链表的自动purge清理机制，只要有清理，那么这个值就会降低。
一般来说，这个值是不应该过于高的，所以我们在这里注意到了第二个线索，history list length值过高！大量的undo多版本链条数据没被清理！推测很可能就是有的事务长时间运行，所以他的多版本快照不能被purge清理，进而导致了这个history list length的值过高！
也就是说，在大量简单SQL语句变成慢查询的时候，SQL是因为Sending Data环节耗时异常高，同时此时出现了一些长事务长时间运行，大量的频繁更新数据，导致有大量的undo 的多版本快照链条，还无法purge清理。
但是这两个线索之间的关系是什么呢？是第二个线索推导出的事务长时间运行现象的发生，进而导致了第一个线索发现的Sending Data耗时过高的问题吗？可是二者之间的关系是什么呢？是不是还得找到更多的线索还行呢？
后来发现有大量的更新语句在活跃，而且有那种长期活跃的超长事务一直在跑没有结束，结果一问系统负责人，发现他在后台跑了一个定时任务，定时清理数据，结果清理的时候一下子清理了上千万的数据。
这个清理是怎么做的呢？他居然开了一个事务，然后在一个事务里删除上千万数据，导致这个事务一直在运行，然后这种长事务的运行会导致一个问题，那就是你删除的时候仅仅只是对数据加了一个删除标记，事实上并没有彻底删除掉。此时你如果跟长事务同时运行的其他事务里在查询，它在查询的时候可能会把那上千万被标记为删除的数据都扫描一遍的。因为每次扫描到一批数据，都发现标记为删除了，接着就会再继续往下扫描，所以才导致一些查询语句会那么的慢。
那么为什么你启动一个事务，在事务里查询，凭什么就要去扫描之前那个长事务标记
为删除状态的上千万的垃圾数据呢？按说那些数据都被删除了，跟你没关系了，你可以不用去扫描他们啊！
这个问题的关键点就在于，那个删除千万级数据的事务是个长事务！当你启动一个新事务查询的时候，会生成一个Read View，里面包含了大量当前活跃事务的最大id、最小id和事务id集合，然后它有一个判定规则。
总之，你的新事务在查询的时候，会根据Read View去判断哪些数据是你可见的，以及你可见的数据时哪个版本，因为一个数据有一个版本链条，有的时候你可能可见的仅仅是这个数据的一个历史版本而已。
所以正是因为这个长事务一直在运行还在删除大量的数据，而且这些数据仅仅是标记为删除，实际还没删除，所以此时你新开事务的查询是会读到所有被标记为删除的数据的，就会出现千万级的数据扫描，才会造成慢查询！
针对这个问题，其实大家要知道的一点是，永远不要在业务高峰期去运行那种删除大量数据的语句，因为这可能导致一些正常的SQL都变慢查询，因为那些SQL也许会不断扫描你标记为删除的大量数据，好不容易扫描到一批数据，结果发现是标记为删除的，于是继续扫描下去，导致了慢查询！
所以解决方案也很简单，直接kill那个正在删除千万级数据的长事务，所有SQL很快会恢复正常，从此以后，对于大量数据清理全部放在凌晨去执行，那个时候就没什么人使用系统了，所以查询也很少。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb96b61448926ab4e89f137c04cda45a/" rel="bookmark">
			总结16（12.20-12.26）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本周完成了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62a270b555882bd0f9cf40d7096222ef/" rel="bookmark">
			Android adb查看网络连接情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android adb查看网络连接情况 文章目录 Android adb查看网络连接情况Android 使用adb查看网络使用情况主要的adb命令：1、adb shell ifconfig2、adb shell dumpsys connectivity3、adb shell netstat3、adb shell ip ru总结一下： Android 使用adb查看网络使用情况主要的adb命令： adb shell ifconfig //查看配置信息 adb shell dumpsys connectivity //查看连接情况 db shell netstat //查看连接状态和地址 adb shell ip ru //查看路由策略 下面展开说一下几个命令输出后的数据如何分析或者查看。
1、adb shell ifconfig 输入命令，获取到如下信息：
C:\Users\liwenzhi&gt;adb shell ifconfig wlan0 Link encap:Ethernet HWaddr 20:32:33:91:23:9e Driver usb inet addr:192.168.43.53 Bcast:192.168.43.255 Mask:255.255.255.0 inet6 addr: 2409:8955:3848:1a7e:5123:75a1:44e9:d36b/64 Scope: Global inet6 addr: fe80::8ea1:6249:e2e9:1458/64 Scope: Link inet6 addr: 2409:8955:3848:1a7e:9850:3a4a:f949:6b6e/64 Scope: Global UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:409 errors:0 dropped:0 overruns:0 frame:0 TX packets:4295 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:89876 TX bytes:1597990 p2p0 Link encap:Ethernet HWaddr 22:32:33:91:23:9e RX bytes:0 TX bytes:432083 lo Link encap:Local Loopback inet addr:127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62a270b555882bd0f9cf40d7096222ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1992f58dfb3a07e277ad6353efa598aa/" rel="bookmark">
			【html&#43;css&#43;原生js实现炫酷照片展开效果-----女友相册的正确打开方式（详细）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.先看效果。有动画效果，截图效果不大明显。copy代码运行可以展示完整效果。
2.html页面
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;照片展开&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/list.css"/&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="box"&gt; &lt;ul&gt; &lt;li&gt; &lt;div class="wrapper deley"&gt; &lt;div class="bg"&gt;&lt;/div&gt; &lt;h2&gt;image1&lt;/h2&gt; &lt;div class="detaction"&gt; &lt;div class="name"&gt;pic1&lt;/div&gt; &lt;div class="close"&gt;x&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="wrapper deley"&gt; &lt;div class="bg"&gt;&lt;/div&gt; &lt;h2&gt;image1&lt;/h2&gt; &lt;div class="detaction"&gt; &lt;div class="name"&gt;pic2&lt;/div&gt; &lt;div class="close"&gt;x&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="wrapper deley"&gt; &lt;div class="bg"&gt;&lt;/div&gt; &lt;h2&gt;image1&lt;/h2&gt; &lt;div class="detaction"&gt; &lt;div class="name"&gt;pic3&lt;/div&gt; &lt;div class="close"&gt;x&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1992f58dfb3a07e277ad6353efa598aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42bddda3eee477821d0cede52074b3fa/" rel="bookmark">
			行为型设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 行为型设计模式介绍具体设计模式介绍2.1 责任链模式2.2 命令模式2.3 解释器模式2.4 迭代模式2.5 中介者模式2.6 备忘录模式2.7 观察者模式2.8 策略模式2.9 状态模式2.10 访问者模式 一、 行为型设计模式 行为型设计模式介绍 行为型设计模式关注对象之间的通信，为对象之间的通信提供了最佳实践的模板。行为型设计模式主要包括以下的几种设计模式：
责任链模式命令模式解释器模式迭代器模式中介者模式备忘录模式观察者模式状态模式策略模式访问者模式 以下将分别介绍每种设计模式的定义、应用场景、实现，实例，以及分析每种设计模式的优缺点。
具体设计模式介绍 2.1 责任链模式 1．定义：责任链模式为请求创建了一个接收者对象的链，这种模式给予请求的类型，对请求的发送者和接受者进行解耦。本模式通常每个接收者都包含对另一个接收者的引用，如果一个对象不能处理该请求，那么他会把相同的请求传给下一个接收者，以此类推，接收者就连成了一条链，即责任链。
2．应用场景：想要让一个以上的对象邮寄会处理某个请求的时候，为了避免请求的发送者和接收耦合，让多个对象都有可能接受请求，将这些对象连成一条链，并且沿着这条链传递请求，直到由对象处理它为止。
3. 实现：(1) 拦截的类都实现统一的接口。(2) handler里面聚合自己，在handlerRequest里面判断是否何是，如果没有达到条件向下传递，即递归调用自己。具体实现如图2-1所示：
图2-1 责任链模式类图 优点 ：(1) 可以将请求的发送者和接收者解耦。(2) 可以简化对象，因为它不需要知道责任链的结构。(3) 通过改变链内成员或者调用它们的次序，允许动态的新增或者删除责任。缺点：(1) 不容易观察运行时的特征，有碍于除错。(2) 不能保证请求一定被接收。(3) 可能会造成循环调用。具体实例：web中的处理request和response的过滤器，使用了过滤器+递归的方式进行实现。 2.2 命令模式 定义：将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象，命令模式也支持可撤销的操作。应用场景：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但是某些场合，比如需要对行为进行记录，撤销或者重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。实现：定义三个角色：(1) received真正命令的执行对象。 (2) commad (3) invoker使用命令对象的入口。具体类图如2-2: 图2-2命令模式类图	优点：(1) 降低了系统耦合度。 (2) 新的命令可以很容易添加到系统中去。缺点：使用命令模式可能会导致某些系统有过多的具体命令类。具体实例：(1) struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。(2) 现实生活中，服务员和厨房的师傅对应着类图中的Invoker和receiver,命令就是点餐的订单。用户可以直接和服务员提交订单即可。不需要和烤串师傅进行交流。可以动态的撤销、增加一些命令。 2.3 解释器模式 定义：给定一个语言，定义它的文法的表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
应用场景：如果一种特定类型的问题发生的频率足够高，那么肯能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。
实现：
图2-3 解释器模式的类图 优点： (1) 可扩展性比较好，灵活。 (2) 增加了新的解释表达式的方式。 (3) 易于实现简单文法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42bddda3eee477821d0cede52074b3fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53159d51168ab95923c6e841eb3ebe00/" rel="bookmark">
			Part7-4-2 请求和响应优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的：
更快的内容到达时间。
核心思路：
1更好的连接传输效率
2更少的请求数量
3更小的资源大小
4合适的缓存策略
最佳实践：
1减少 DNS 查找：每次主机名的解析都需要一次网络往返，从而增加了请求的延迟时间，同时还会阻塞后续的请求。
2重用 TCP 连接：尽可能的使用持久连接，以消除因 TCP 握手和慢启动导致的延迟。
3减少 HTTP 重定向：HTTP 冲定向需要额外的 DNS 查询、TCP 握手等非常耗时，最佳的重定向次数为0。
4压缩传输的资源：比如 Gzip、图片压缩。
5使用缓存：比如 HTTP 缓存、CDN 缓存、Service Worker 缓存。
6使用 CDN（内容分发网络）：把数据放在离用户地理位置更近的地方，可以明显减少每次 TCP 连接的网络延迟，增大吞吐量。
7删除没有必要请求的资源。
8在客户端缓存资源：缓存必要的应用资源，避免每次都重复请求相同的内容，例如多图片下载可以考虑使用缓存。
9内容在传输前先压缩：传输数据之前应该先压缩应用资源，把要传输的字节减少到最小，在压缩的时候确保对每种不同的资源采用最好的压缩手段。
10消除不必要的请求开销：减少请求的 HTTP 首部数据（比如 HTTP COokie）
11并行处理请求和响应：请求和响应的排队都会导致延迟，可以尝试并行的处理请求和响应（利用多个 HTTP1.1 连接实现并行下载，在可能的情况下使用 HTTP 管道计数）。
12针对协议版本采取优化措施。升级到 HTTP2.0。
13根据需要采用服务端渲染方式。这种方式可以解决 SPA 应用首屏渲染慢的问题。
14采用预渲染的方式快速加载静态页面。页面渲染的极致性能，比较适合静态页面。
DNS 解析 当浏览器从（第三方）服务器请求资源时，必须先将该跨域域名解析为 IP 地址，然后浏览器才能发出请求。此过程称为 DNS 解析。DNS 作为互联网的基础协议，其解析的速度似乎很容易被网站优化人员忽视。现在大多数新浏览器已经针对 DNS 解析进行了优化，比如 DNS 缓存。典型的一次 DNS 解析需要耗费 20-120 毫秒，所花费的时间几乎可以忽略不计，但是当网站中使用的资源依赖于多个不同的域的时候，时间就会成倍的增加，从而增加了网站的加载时间。比如在某些图片较多的页面中，在发起图片加载请求之前预先把域名解析好将会有至少 5% 的图片加载速度提升。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53159d51168ab95923c6e841eb3ebe00/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/268/">«</a>
	<span class="pagination__item pagination__item--current">269/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/270/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>