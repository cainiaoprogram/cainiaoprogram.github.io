<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/578ea0ac12f6134f84096b7e6dc2b8c3/" rel="bookmark">
			安卓开发 自定义ScrollView 实现滚动，停止状态的监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scrollview或者NestScrollView没有提供对其状态的监听（类似Recyclerview的OnScrollListener.onScrollSateChanged接口），只能自己实现。
在百度以后，发现大多数采用的都是新开一个线程，延迟一小段时间来判断是否已经暂停，都是直接在onTouchEvent()的MotionEvent.ACTION_UP中判断是否已经暂停，没有对Fling状态进行判断，所以对于停止的状态是不准确的。
在他们的基础上，本文将对Fling状态进行判断，能得到正确的停止时机。
到达暂停的路径只有两种：
1.ACTION_DOWN-&gt;MOVE-&gt;UP-&gt;停止
2.ACTION_DOWN-&gt;MOVE-&gt;UP-&gt;FLING-&gt;停止
本例子采用两个线程来判断是否停止
如何判断停止：
开监听线程，并且在滚动的时候一直更新改线程中的最后刷新时间，当最后（线程当前时间=刷新时间(外部更新)+200ms）时，判定为停止。
满足上述条件的那一秒可以发送多条SCROLL_STATE_IDLE的监听，但是我们只需要一条，所以需要标志位来控制每次停止只发送一次监听。
对于第一种情况：
MotionUpThread用于判断情况一的停止，MotionUp的时候刷新MotionUpThread中的计时，如果200ms后没有移动，则认为是暂停，发送停止回调。
对于第二种情况：
FlingThread用于判断情况二的停止，MotionUp以后，继续Fling，此时isScroll为true，MotionUpThread不会发送停止的回调。而FlingThread在最后的Fling滚动结束后200ms会发送停止回调。
经过测试，打开关闭该只有该布局的网页，会使内存增加，但是再检查问题的时候也一直没有找到是哪里泄露了，如果有人测试并且发现了问题在哪，请留言告诉我一起交流交流，万分感谢。
以下为代码
public class ScrollViewWithListener extends NestedScrollView { private OnScrollListener mScrollListener; // 是否在触摸状态 private boolean inTouch = false; private FlingThread mFlingThread; private MotionUpThread mMotionUpThread; private MyRunnable mRunnable; //避免一秒内发送多次回调 private boolean isMotionUpRun = false; private boolean isFlingRun = false; //判断是否在滚动 private boolean isScroll = false; private boolean isDestory = false; public ScrollViewWithListener(Context context) { this(context, null); } public ScrollViewWithListener(Context context, AttributeSet attrs) { this(context, attrs, 0); } public ScrollViewWithListener(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); mFlingThread = new FlingThread(this); mFlingThread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/578ea0ac12f6134f84096b7e6dc2b8c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4f9b15423c59341981ef3b8362dd79c/" rel="bookmark">
			node-red 插件使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 java 编写 coap 客户端与服务端
概述：
CoAP是为物联网而生，短小精悍，它底层基于UDP协议的，其它具体参考百度百科，本例子是基于Californium框架。
1、先决条件
java环境
eclipse工具
Maven插件（有最好，不需要手动下载jar引入，没有的话手动引入）
2、下载Californium框架核心jar
californium-core.jar ： 包括CoAP核心部分
element-connector.jar 包括适用于UDP和DTLS的java套接字抽象层
scandium.jar: 包括DTLS
&lt;dependency&gt; &lt;groupId&gt;org.eclipse.californium&lt;/groupId&gt; &lt;artifactId&gt;californium-core&lt;/artifactId&gt; &lt;version&gt;2.0.0-M7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.californium&lt;/groupId&gt; &lt;artifactId&gt;element-connector&lt;/artifactId&gt; &lt;version&gt;2.0.0-M7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.californium&lt;/groupId&gt; &lt;artifactId&gt;scandium&lt;/artifactId&gt; &lt;version&gt;2.0.0-M7&lt;/version&gt; &lt;/dependency&gt; 3、创建java工程或Maven工程，创建一个Server类
import org.eclipse.californium.core.CoapResource; import org.eclipse.californium.core.CoapServer; import org.eclipse.californium.core.coap.CoAP.ResponseCode; import org.eclipse.californium.core.server.resources.CoapExchange; public class HelloCoAPServer { public static void main(String[] args) { CoapServer server = new CoapServer();//主机为localhost 端口为默认端口5683 server.add(new CoapResource("hello"){//创建一个资源为hello 请求格式为 主机：端口\hello @Override public void handleGET(CoapExchange exchange) { //重写处理GET请求的方法 exchange.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4f9b15423c59341981ef3b8362dd79c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33113cec27ea8bc86be4c18892dd913c/" rel="bookmark">
			pytorch报错：RuntimeError: CUDA error: device-side assert triggered
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		训练网络报错：RuntimeError: cuda runtime error (710) : device-side assert triggered at /pytorch/aten/src/THC/generic/THCTensorScatterGather.cu:380
terminate called after throwing an instance of 'c10::Error'
what(): CUDA error: device-side assert triggered (insert_events at /pytorch/c10/cuda/CUDACachingAllocator.cpp:569)
原因：标签（label）越界
方法：输入
CUDA_LAUNCH_BLOCKING=1 python train.py 会出现错误具体产生信息
/pytorch/aten/src/THC/THCTensorScatterGather.cu:188: void THCudaTensor_scatterFillKernel(TensorInfo&lt;Real, IndexType&gt;, TensorInfo&lt;long, IndexType&gt;, Real, int, IndexType) [with IndexType = unsigned int, Real = float, Dims = -1]: block: [72,0,0], thread: [32,0,0] Assertion `indexValue &gt;= 0 &amp;&amp; indexValue &lt; tensor.sizes[dim]` failed. 可以看出是Assertion `indexValue &gt;= 0 &amp;&amp; indexValue &lt; tensor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33113cec27ea8bc86be4c18892dd913c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/519d46ca3692b808976d8a87ff142244/" rel="bookmark">
			C语言--函数指针与指针函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述
简言之，函数指针是一个指针，指向的是一个函数的地址。指针函数是一个函数，是返回值为指针的函数。
2.何谓指针函数？
指针函数本质是一个函数，该函数的返回值是一个指针。
声明格式为：类型标识符* 函数名(参数表)
下面首先是一个普通的函数声明：
int fun(int x, int y); 接下来是一个指针函数的声明：
int* fun(int x, int y); 这和上面那个普通函数声明的唯一区别就是在函数名前面多了一个*号，而这个函数就是一个指针函数。其返回值是一个int类型的指针，是一个地址。
指针函数的几种写法：
int *fun(int x, int y); int * fun(int x, int y); int* fun(int x, int y); 个人感觉最后一种写法最好，*号靠近返回值类型更容易理解，看成返回值为指针的一种特殊函数就OK了。
代码示例：
typedef struct{ int a; int b; }Data; //指针函数 Data* f(int a, int b) { Data *data = new Data; data-&gt;a = a; data-&gt;b = b; return data; } int main(int argc, const char *argv[]) { Data *myData = f(4, 5); std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/519d46ca3692b808976d8a87ff142244/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0d466bf09c671c04de7fb773e09a752/" rel="bookmark">
			问题：AttributeError: module &#39;tensorflow&#39; has no attribute &#39;gfile&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 问题原因与解决方案解决方案1解决方案2 问题 运行如下代码
if not tf.gfile.exists(DATA_DIRECTORY): tf.gfile.makedirs(DATA_DIRECTORY) with tf.gfile.GFile(filepath) as f: 会出现如下问题：
AttributeError: module ‘tensorflow’ has no attribute ‘gfile’
原因与解决方案 问题产生的原因：在当前的版本中，gfile已经定义在io包的file_io.py中。
解决方案1 所以只要改为下面的即可：
if not tf.io.gfile.exists(DATA_DIRECTORY): tf.io.gfile.makedirs(DATA_DIRECTORY) with tf.io.gfile.GFile(filepath) as f: 解决方案2 上面代码其实就是判断给定路径下的文件夹是否存在，如果不存在则创建文件夹。
所以可以用python的os.path来处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b757431eee2a1cce37abf68a14676b8d/" rel="bookmark">
			springboot项目设置热部署，修改java代码不重启项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、快捷键 ctrl+shift+alt+/ 选择Registry 勾选图中选项
二、File --&gt; Setting 设置自动编译
三、修改启动配置
四、引入热部署包
org.springframework.boot
spring-boot-devtools
runtime
true
五、最重要！！！！！！ 这里设置是否重启 ，如果你需要修改java代码就重启就设置为true 不需要重启就设置为false
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f3bf41ffa54e17203fd385159731a0/" rel="bookmark">
			网络摄像机（大华）不知道ip地址怎么办？查询IPC的ip地址？修改IPC的ip地址？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设备需要： 网络摄像机 若干
电脑全家桶 若干
网线 若干
摄像机电源适配器 若干
如果你知道大致IP范围 摄像头直连电脑后，电脑设为同网段IP地址，使用IP扫描工具扫描已知网段。
我这使用MobaXterm进行扫描，当然也可以使用其他IP扫描工具。
输入IP范围，开始扫描即可，不过这个IP段并不大，记得不清楚的话，还是用其他IP扫描工具好了。
如果你的摄像头为DHCP 可以将摄像头接到路由器上，电脑也接路由器，由路由器内置的DHCP服务为你和摄像头分配IP，之后在进行同网段IP扫描，找到摄像头。（路由器分配的IP，登录路由器管理页面 （一般为：192.168.1.1）应该也能看到IP分配列表）
ps：windows可以给pc安装dhcp server软件（https://www.dhcpserver.de/cms/download/），具体使用方法可以参考：DHCPsrv使用方法（经测试可以使用）。网口和摄像头直连，然后等dhcp server给摄像头分配IP后，进行相应操作。
实际操作（针对大华网络摄像机） 1、下载软件 SmartPSS、大华工具管家、ConfigTool（运行大华工具管家，第一个），如果下载不了，可以百度下载一个，自行斟酌。（ps：如果是海康摄像头可以去海康威视官网下载扫描软件 设备网络搜索软件，原理类似）
2、摄像机接电源适配器通电，连网线，网线另一端连电脑上的网口 3、修改ip为自动获取 4、运行SmartPSS客户端，查询设备ip 点击“自动搜索”
先搜到了NVR，我们选中添加
自行设置一个。
添加完后，它自动搜索出了摄像机，这就是摄像机的ip了，记住ip地址。
我也给他添加进去，因为我发生过中途变ip的情况。
可以看到这个了。我们可以退出了。
5、主机和摄像机（交换机）连上局域网，再次修改主机ip为摄像机同网段 摄像头网线连上“交换机”，电脑主机连上局域网，2者通了。
6、运行configtool 搜索设备 点击“搜索设置”
设置为摄像机的那个网段
成功搜索到了摄像机
点击 浏览器图标
web页面出来了
默认用户名是admin，密码 不知道问下别人。（有锁定机制）
登录，成功显示画面
7、修改摄像机ip “设置” -》 “网络设置” -》 “TCP/IP”
模式改为“静态”，就可以修改ip等信息了。
改好后“确定”。
原网址已经访问不到了。
8、再次修改主机ip 改为刚才设置的ip的网段
再访问 刚才配置好的摄像机ip，成功访问
看下配置信息
修改 搜索设置，重新搜索，可以搜索到本机NVR和IPC摄像头了，可喜可贺~
补充： ONVIF官网：https://www.onvif.org/，百度百科
可以使用我们的 ONVIF Device Test Tool 来搜索下我们的摄像机（这个工具官网不提供私人下载，百度下载的话，自行斟酌）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59f3bf41ffa54e17203fd385159731a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a4e3f6b666871a4116b3e535b61def2/" rel="bookmark">
			汇编指令--移位操作SHL、SHR、SAL、SAR以及它们的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逻辑移位: SHL、SHR 算术移位: CAL、CAR 12 无符号数的乘法和除法可以用逻辑移位;
有符号数的乘法和除法可以用算术移位;
汇编语言中 sal(算术左移指令）和shl（逻辑左移指令）指令的区别? 汇编语言中 sal(算术左移指令）和shl（逻辑左移指令）指令的寻址方式、控制移位方式等都一样，区别其实只有一处：
SAL算术移位指令在执行时，实际上把操作数看成有符号数进行移位，最高位符号位移入CF，但本身保持原值；其余位顺序左移，次高位被舍弃。
SHL逻辑移位指令在执行时，实际上把操作数看成无符号数进行移位，所有位顺序左移，最高位移入CF。
举例如下：
MOV AX,8001H;(AX)=1000 0000 0000 0001B
SAL AX,1 ;(AX)=1000 0000 0000 0010B
MOV AX,8001H;(AX)=1000 0000 0000 0001B
SHL AX,1 ;(AX)=0000 0000 0000 0010B
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95a4536d8fab711b3ceb4be2c180c5cf/" rel="bookmark">
			小程序中使用动画的四种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		既然是前端开发，那么页面的动画必然是一个少不了的东西，下面我们就来研究研究小程序的动画是怎么来实现的
1、利用样式实现小程序动画(用法和css用法相识)
wxml 文件
&lt;image class="aniamtion" src="../../images/page4.jfif" style="width:200rpx;height:200rpx; position: relative;"&gt;&lt;/image&gt; wxss文件
.aniamtion { animation: mymove 5s infinite; /* //infinite属性是表示无限循环的意思，没有这个属性的话动画只执行一次。 */ } @keyframes mymove { from { /* left: 0px; */ /* transform: rotate(7deg) skew(50deg) translate(30rpx,30rpx); */ transform: rotate3d(100,200,300,0deg); } to { /* left: 200px; */ /* transform: rotate(7deg) skew(5deg) translate(100rpx,100rpx); */ transform: rotate3d(200,300,400,360deg); } } 2、 用小程序的API来实现动画
用wx.createAnimation(object) 来创建一个动画 --&gt;返回一个animation对象
创建一个动画实例 animation。
onReady: function () { this.animation = wx.createAnimation({ duration:1000, timingFunction:'linear', delay:100, transformOrigin:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95a4536d8fab711b3ceb4be2c180c5cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2b214340d1eada6f69c77c31666f3a9/" rel="bookmark">
			【沃趣科技】MySQL高可用工具Orchestrator系列四：拓扑恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		沃趣科技作为国内领先的数据库云平台解决方案提供商，一直致力于企业级数据库云平台产品的研发，为用户提供高性能、高可用、可扩展的的数据库云环境及不同业务场景需求的数据库平台，满足客户对极致性能、数据安全、容灾备份、业务永续等需求。沃趣科技凭借专业的团队，优质的产品，前沿的技术，贴心的服务赢得了客户的信任与尊重，也获得了市场的认同。
前言 上篇文章讲了orchestrator的探测机制。本篇文章翻译自orchestrator官方文档，讲一讲orchestrator的拓扑恢复。
拓扑恢复 orch能够从一系列故障场景中进行恢复。尤其是，它能够对主库或者中间主库的故障场景进行恢复。
自动和手动
orch支持：
自动恢复（对意外故障采取措施）。
优雅地、有计划地主从切换。
手动恢复。
手动，强制failover。
要求
要运行任何类型的故障转移，拓扑必须支持以下任一种：
Oracle GTID（master_auto_position=1）
MariaDB GTID
Pseudo GTID（伪GTID）
Binlog Servers
什么是恢复
恢复基于故障检测，并且由一系列事件组成：
恢复前的hooks（hook：外部的执行过程或者脚本）。
修复拓扑。
恢复后的hooks。
注意：
恢复前的hooks由用户自己配置。
- 顺序执行。
- 任何一个hook的失败（非零退出码）都将中止故障转移。
拓扑修复是由orch管理的，并且是基于状态，而不是基于配置。orch在考虑到现有拓扑、版本、服务器配置等因素的情况下，会力图尽力而为。
恢复后的hooks也是由用户自己配置。
恢复场景1：中间主库挂掉
一个简单的恢复案例是DeadIntermediateMaster。它的replicas被孤立了，但是当使用了GTID或者Pseudo GTID的情况下，replicas仍然能够被重连到拓扑中。我们可能会选择这样做：
找到已失效的中间主服务器的同级，然后将孤立的副本移到所述同级之下。
从孤立的副本中提升某个副本，使得这个副本成为同级的中间主库，然后将这个副本连接到拓扑。
重置所有的孤立副本。
结合以上部分做法。
实际的实现方式很大程度上取决于拓扑设置（哪些实例设置了log-slave-updates、实例是否有延迟、是否存在复制过滤、mysql的版本等等）。你的拓扑很有可能至少支持以上一种方式（特别是，匹配副本是一个简单的解决方案，除非使用了复制过滤）。
恢复场景2：主库挂掉
从挂掉的主库恢复是一个更为复杂的操作，有很多种原因：
有潜在的运行中断（停电、网络），恢复要尽可能地快。
在恢复过程中，有些servers可能会丢失。orch需要确定会是哪个。
拓扑的状态可能是用户希望阻止恢复。
必须进行主服务发现：应用必须能够与新的主库进行通讯（潜在地被告知主库已经更改了）。
需要找到最合适的replica，将其提升为主库。
- 一个天真的方法是选择最新的副本，但这不一定总是正确的选择。
- 最新的副本不一定有必要的配置来作为其他replica的主库（比如：binlog format、mysql版本、复制过滤器等）。盲目地提升最新的副本为主库，可能会失去副本冗余的能力。
- orch会尝试提升保留最大服务容量的副本为主库。
提升所述副本，接管它的同级。
使它的同级保持最新状态（up to date）。
也许，要做一个二阶段提升；用户可能已经标记了要提升的特定服务器（参考register-candidate命令）。
调用hooks。
主服务发现很大程度上是需要用户去实现的。常见的解决方案有：
基于DNS的发现；orch需要调用能修改DNS入口的hook。
ZooKeeper/Consul KV/etcd/其他基于键值的发现；orch内置了对Consul KV的支持，否则外部的hook必须更新k-v存储系统。
基于proxy的发现；orch会调用外部的hook去更新proxy的配置，或者更新如上所说的Consul/Zk/etcd，这本身就会触发更新proxy的配置。
其他方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2b214340d1eada6f69c77c31666f3a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a389bd0f696bf4cca96c662163d21c04/" rel="bookmark">
			图像透视变换应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 透视变换是将成像投影到一个新的视平面，也称作投影映射。投影变换是三维空间上的非线性变换，可看做是仿射变换的更一般形式，简单讲即通过一个3x3的变换矩阵将原图投影到一个新的视平面(Viewing Plane)，在视觉上的直观表现就是产生或消除了远近感。
OpenCV透视变换的透视变换 1、warpPerspective 利用透视矩阵对图像进行透视变换。
说明
OpenCV提供了warpPerspective( )函数来实现图片的透视变换，只需要输入梯形四个顶点的坐标和目标画布四个角的坐标，即可自动完成转换。核心代码只有两行：首先读取两个坐标数组，计算变换矩阵；然后根据变换矩阵对原图进行透视变换，并输出到目标画布。
函数warpPerspective使用指定的矩阵转换源图像：
dst ( x , y ) = src ( M 11 x + M 12 y + M 13 M 31 x + M 32 y + M 33 , M 21 x + M 22 y + M 23 M 31 x + M 32 y + M 33 ) \texttt{dst} (x,y) = \texttt{src} \left ( \frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} , \frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \right ) dst(x,y)=src(M31​x+M32​y+M33​M11​x+M12​y+M13​​,M31​x+M32​y+M33​M21​x+M22​y+M23​​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a389bd0f696bf4cca96c662163d21c04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bd6fc83b619a986a36f72434667633e/" rel="bookmark">
			CS224n_2019_Assignment1: Exploring Word Vectors Coding Solution
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A1不難，當熱身作業。
Word Vectors Part 1: Count-Based Word Vectors (10 points) Co-Occurrence Question 1.1: Implement distinct_words [code] (2 points) def distinct_words(corpus): """ Determine a list of distinct words for the corpus. Params: corpus (list of list of strings): corpus of documents Return: corpus_words (list of strings): list of distinct words across the corpus, sorted (using python 'sorted' function) num_corpus_words (integer): number of distinct words across the corpus """ corpus_words = [] num_corpus_words = -1 # ------------------ # Write your implementation here.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bd6fc83b619a986a36f72434667633e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e18b8eb446af4ea88f93db0529663a1b/" rel="bookmark">
			IDEA修改及设置快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IDEA修改及设置快捷键 目录 修改快捷键习惯设置快捷键 1. 修改快捷键习惯 1. 点击 File -&gt; Settings… 2. 选择keymap选项卡，在右侧的keymap下拉框中选择合适自己的快捷键 2. 设置快捷键 1. 同一进行如下操作 2. 设置自己的快捷键 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/639474a0f1ccc19cb46e01d563fa52db/" rel="bookmark">
			Anaconda和Pycharm的安装和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Anaconda 是一个基于 Python 的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，装上Anaconda，就相当于把 Python 和一些如 Numpy、Pandas、Scrip、Matplotlib 等常用的库自动安装好了，使得安装比常规 Python 安装要容易。
1.Anaconda下载安装
步骤一：进入官网（https://www.anaconda.com/download/#windows）下载对应正确的版本，这里选择的是Windows 64bit；
步骤二：安装过程省略，基本上一路next ,下图界面时，红框代表将Anaconda路径添加到path环境变量，如果以前安装过，变量会被替换；
步骤三：进入到Anaconda安装目录输入conda list 就可以查询现在安装了哪些库。可以输入 conda update --all 命令，把所有包进行更新。　2.Pycharm下载安装、破解、配置
步骤一：进入官网（http://www.jetbrains.com/pycharm/download/#section=windows）下载对应正确的版本，社区版是免费的； Pycharm_2019.1破解版地址 提取码：tavw
此处安装的破解版：
1. 安装完成，将以下内容添加到hosts 文件中，
0.0.0.0 account.jetbrains.com
0.0.0.0 www.jetbrains.com
2. 使用压缩包中的序列号激活
步骤二：运行Anaconda，首先点击create new project，location为文件存储位置，project interpreter为解释器，也就是Anaconda中的python.exe；
步骤三：设置界面字体大小和代码字体大小，依次选择file--settings--appearance &amp; behaviors--勾选红色框中选项修改界面字体大小，依次选择editor--general--font修改代码字体大小。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ad7eba86d415d8f4de1db2399225462/" rel="bookmark">
			Redis面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Redis存储数据类型？
1）、String
字符串类型是Redis最基本的数据类型，它能够存储任何形式的字符串，可以存储用户的信息，JSON化的对象甚至是一张图片。字符串类型是其他四种类型的基础，其他数据类型从某种角度来说只是组织字符串的形式不同，一个字符串类型的键允许存储的最大数据容量是512MB。
赋值命令：SET key value 如果key已经持有其他值，set就复写旧值，无视类型
取值命令：GET key,当键不存在时会返回空。
MSET k1,k2,k3...同时设置多个键值
MGET k1.k2...同时获得多个键值
Redis的所有命令都是原子操作，原子操作即不可拆分的意思，不会在执行的过程中被其他命令插入打断。
2）、List
列表类型可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素。
列表类型内部是使用双向链表实现的，所以向列表两端添加元素的时间复杂度为O(1)，使用链表的代价是通过索引访问元素比较慢。借助列表类型。Redis还可以作为队列使用。一个列表类型键最多可以容纳2^32-1个元素。
LPUSH key value1,value2...：向列表左边增加元素，返回值为增加元素 后列表的长度
RPUSH key vaule1,value2...：向列表右边增加元素，返回值为增加元素后列表的长度
LPOP key ：从列表左边弹出一个元素。这个命令执行两部操作，第一步是将列表左边的元素从列表中移除，第二步返回被移除的元素值。
RPOP key：从列表右边弹出一个元素
3)、Set
集合中的每个元素都是不同的，且没有顺序，唯一且无序，一个集合类型的键可以存储2^32-1个字符串
集合类型的常用操作是向集合中加入或删除元素，判断某个元素是否存在。
集合类型在Redis内部是使用值为空的hash表来实现的。所以这些操作的时间复杂度都为O(1)
多个集合类型键之间还可以进行并集，交集和差集运算。
SADD key member1,member2...向集合中添加一个或多个元素。如果键不存在则自动创建。返回值是成功加入的元素数量
SREM key member1,member2...从集合中删除一个或多个元素，并返回删除成功的个数。
SMERMBERS key :获取集合中的所有元素。
4）、Hash(散列类型)
hash是一个String类型的field和value的映射表。散列类型适合存储对象。一个散列类型键可以包含2^32-1个字段
HSET key field value：给字段赋值。例如HSET car price 500
HGET key field：获取字段值。例如HGET car price
当HSET执行的是插入操作时（即之前字段不存在）会返回1，当执行的是更新操作时会返回0.还会自动建立。
HMSET key field1 value1 field2 value2...：同时设置多个字段，例如 HMSET car name "bmw" price 5000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ad7eba86d415d8f4de1db2399225462/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a9cf4325c933602a4eeb3fe038f1a31/" rel="bookmark">
			xxxx   was not found. If this view is optional add &#39;@Nullable&#39; (fields) or &#39;@Option
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天在用butterknife遇到如下错误，java.lang.IllegalStateException: Required view 'bt_angle_init' with ID 2131230767 for field 'btAngleInit' was not found. If this view is optional add '@Nullable' (fields) or '@Optional' (methods) annotation. 之前还好好的啊？？？ 把这个控件重布局文件删除后就可以了，经过长时间的怀疑人生，终于在res发现了layout-26这个文件夹里面有个跟layou一样的布局文件，但是这个没有我刚写到那个控件，删layout-26文件夹，果然没问题了。 结论 在app运行的时候是引用了layout-26里面的布局，而我编辑的是layout的内容，这就是报错的问题所在了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1250d7ed1f53484e61691dc491d9abe6/" rel="bookmark">
			报名丨 “中国的城市化、数字技术和创新市场” ——清华大学-麻省理工学院联合训练营开始招募啦...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		世界各地的城市正竞相利用数字技术改造其城市系统，使之更有效率、更可持续、更有弹性和活力。数字技术带来了城市规划、发展、运行、治理等方面快速而深刻的变化。技术创新和城市化正在融合，以形成新的商业模式以及企业，以应对城市挑战。
中国正进行着全球最大规模的城市化，中国也是世界上最大的数字市场。政府鼓励创新，加上中国城市间的动态市场机制，中国已拥有全球近一半的智慧城市试点项目。怎样才能把数字化创新在全球最大的城市化市场落地生根并形成规模？
清华大学恒隆房地产中心与麻省理工未来城市实验室联合推出——“中国的城市化、数字技术和创新市场”训练营。
训练营特色
1、清华大学建设管理系，麻省理工学院未来城市实验室、斯隆商学院教授联合设计课程并授课
2、通过讲座、案例研究、工作坊等形式，提供互动、实用和相关的课程
3、 碧桂园、香港置地、万科、天一集团、嘉铭投资等业内翘楚为学生带来业内创新前沿
4、中国数字市场拥有丰富经验的创始人将成为我们的导师
5、参访中关村独角兽和知名孵化器，与创业同路人交流
6、全英文授课
招募条件
1、清华大学在校生（本科生、研究生、博士生均可报名）
2、对数字技术与中国城市化融合感兴趣
3、有在智能城市或PropTech中发展未来职业的想法
4、创业团队组队报名或个人报名均可
训练营时间：2020年1月6日-10日
地点：清华大学以及参访企业
报名截止时间：2019年12月15日
面试时间：2019年12月17日
请扫码报名
有任何问题请联系张老师：zhangrq5@tsinghua.edu.cn
——END——
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e9cd70fee8469acc2edf64c67bbe43b/" rel="bookmark">
			深度学习之Attention模型详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：Datawhale（ID：Datawhale）
作者：yif
本文8434字41图，建议阅读22分钟。
本文介绍深度学习中的Attention模型。
Attention的产生
起因：《Sequence to Sequence Learning with Neural Networks》
Attention模型的引入原因：
seq2seq将输入序列都压缩成一个固定大小的隐变量，就像我们的压缩文件一样，这个过程是有损压缩的，会迫使丢失许多输入序列中的信息；
存在着难以对齐的问题。比如中译音“我爱你” “I love you”,输入序列中的“我”应该与“I”对齐(贡献最大)，然而在seq2seq模型中，“我”对"I"，"love"，"you"的贡献都是一致的。
Attention的发展
Show, attend and tell: Neural image caption generation with visual attention 本文可以算是第一篇Attention论文。
该任务是实现图文转换。与前面讲述的seq2seq的问题一样，在之前的图文转换任务中也是存在着难以对齐的问题。所谓难以对齐就是毫无重点。
本文提出了两种attention：
sort Attention
hard Attention
本文的模型结构：
将图片通过一个CNN转换成的L D.这里称L个向量为L个注释向量(annotation vector)，D为特征维度，可以认为提取了图片中L个区域的特征。对这L个区域向量加权相加来表示这张图片。由于不同时刻的关注点是不同的，annotation vector还要与decoder中的隐状态进行交互，以便知道下一时刻的关注区域。
这里编码器是VGG，解码器是LSTM。LTSM输入是不同时刻的图片的关注点信息，然后生成当前时刻的单词。
Attention的计算
如上所属，attention的值不仅与annotation vector 有关，还与上一时刻解码器的隐状态有关。因此有：
其中t表示时刻t，i表示第i个区域，a是我们得到的attention weight分布。
f实际上是对齐函数，用于计算对齐的分数，常见的对齐函数有：dot product，general，multilayer perceptron。
1，Soft attention：直接使用attention的权重对L个向量加权相加，这么做的好处是整个问题是可微的，可以利用BP end to end。
2，Hard attention：Hard attention很粗暴，挑出最大权重的向量，剔除其余向量(置0)。显然这种形式的模型是不可微的，为了实现BP，这里采用蒙特卡洛采样的方法来估计模块的梯度。
帮助我们在t时刻选出了第i个向量 是我们最后选中的的向量，引入一个变量 ,当区域i被选中时取值为1，否则为0.则有：
问题如何生成 ,在本文中，将 视为隐变量，为参数是 的多元伯努利分布(伯努利是两点分布)
$$P(s_{t,i}=1|s_{t&lt;j},a)=\alpha_{t,i} $$=""
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e9cd70fee8469acc2edf64c67bbe43b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1d0e2cd3de3b2d0d3b2a94dcf944dd8/" rel="bookmark">
			英特尔AI医疗实战曝光：10倍加速辅助诊断、准确度高达90%
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：机器之心（ID：almosthuman2014）
作者：力琴
本文6078字14图，建议阅读16分钟。
本文介绍英特尔AI医疗落地解决方案。
深耕医疗健康领域 20 年，医疗健康数字化、药物治疗精确化一直是英特尔的重要议题。
每年都有 1800 万人因心血管疾病失去生命，易患疾病排名前三，又称头号健康杀手。
在医院里，心血管内科医生每天都要查看大量的医学影像资料，凭借着自己的经验判读每一张 MRI（心脏磁共振成像检查) 影像，试图从隐秘而复杂的心脏结构中发现心血管疾病病人的患病秘密。
人命关天，尽管他们不敢掉以轻心，但不同医生之间经验有差别，而且长时间工作中谁也无法保证一直处于最佳状态。如今，AI 加入这场医学影像分析游戏，它超长待机永不疲倦，其颗粒度极其细微，熟稔心脏的每一处结构，就连隐藏暗处的线索都能够发现。
在医疗健康领域，AI 被广泛应用于医学影像、辅助诊断、疾病预测、药物研发等多个环节，它们就像汽车里的超级马达，促使各个医疗环节加快效率。
据数据显示，2018 年中国医疗人工智能市场规模达到 200 亿元。这一高速增长得益于中国医疗市场的迫切需求，以及近年来医疗人工智能技术的发展与相关政策的支持。
作为人工智能应用落地最具潜力的领域之一，英特尔将自身软硬件能力、算法能力以及相关应用深入医疗健康领域，协同产业医疗机构、医药公司等多方合作，在推理医学影像、医学影像分析、病理切片分析、药物研发等场景大显身手。
一、人工智能落地医疗
根据 Global Market Insight 的统计数据，药物研发在全球医疗人工智能市场中的占比最大，达到 35%。紧随其后的是医学影像人工智能，占比 25%，并将以超过 40% 的增速发展，预计 2024 年将达到 25 亿美元的规模。
人工智能在医疗健康领域的应用非常广泛，从医学影像、辅助诊断、疾病预测，到健康管理、药物研发等诸多环节，都发挥重要作用。
例如人工智能应用于慢病管理与疾病监测，基于患者体征对 (潜在) 慢性疾病进行风险预估，从而通过早期干预，降低患者的医疗费用。影像辅助诊断方面，帮助放射科医生快速筛除正常影像，提高分析影像的准确度，缩短诊断结果报告时间，提升医疗系统的诊断能力。
现阶段，我国基本成型的医疗影像产品大多处于医院试用阶段，该领域公司基本没有实现盈利；在辅助诊断方面，医学影像、电子病历、导诊机器人是主要应用场景，多为软硬件一体化全套解决方案，目前产品仍处于打磨阶段。国内新药研发仍以仿制药和改良药为主，国内 AI 新药研发主要是人工智能公司与药企合作开发新药。
要解锁 AI 在医疗健康领域的落地困境，需要软硬件配套设备的支撑，AI 算法提高诊断精度，AI 芯片作为底层关键技术，配合先进工艺的硬件设备，三方力量集成，以促进生物技术与信息技术的融合，从而撬动 AI 与医疗大生态。英特尔自身优势与 AI 落地医疗领域的节点正好契合。
二、英特尔软硬兼施
作为一家拥有数据积淀的科技公司，英特尔一直坚持从云到端的产品与技术创新，广泛与合作伙伴共同推动云计算、大数据、人工智能等技术与解决方案的发展。
目前英特尔的硬件产品有英特尔至强可扩展处理器和傲腾数据中心级持久内存和傲腾固态盘等；软件产品有英特尔架构优化的 Caffe 和 TensorFlow，以及 OpenVINO 工具套件等。
第二代英特尔至强可扩展处理器专为数据中心现代化变革而设计，提供比前代产品高出 25%-35% 的性能，且具备多项新特性，能够打造性能更强的敏捷服务和更具价值的功能，进而改善总体拥有成本，提升生产力。
此外，该第二代处理器集成了深度学习加速技术 (矢量神经网络指令 VNNI)，可加速人工智能和深度学习推理，并针对工作负载进行优化。这使其拥有集成 AI 加速能力的 CPU 架构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1d0e2cd3de3b2d0d3b2a94dcf944dd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cde16daa5085ee58ce6d2b4eec4104d/" rel="bookmark">
			dma-buf 由浅入深（五） —— File
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dma-buf 由浅入深（一） —— 最简单的 dma-buf 驱动程序
dma-buf 由浅入深（二） —— kmap / vmap
dma-buf 由浅入深（三） —— map attachment
dma-buf 由浅入深（四） —— mmap
dma-buf 由浅入深（五） —— File
dma-buf 由浅入深（六） —— begin / end cpu_access
dma-buf 由浅入深（七） —— alloc page 版本
dma-buf 由浅入深（八） —— ION 简化版
前言 在上一篇《dma-buf 由浅入深（四）—— mmap》中，曾提到过 dma_buf_fd() 这个函数，该函数用于创建一个新的 fd，并与 dma-buf 的文件关联起来。本篇我们一起来重点学习 dma-buf 与 file 相关的操作接口，以及它们的注意事项。
file 早在第一篇《最简单的 dma-buf 驱动程序》就曾说过，dma-buf 本质上是 buffer 与 file 的结合，不仅如此，该 file 还是个被 open 过的 file。从我们调用 dma_buf_export() 开始，这个 file 就已经被 open 了。而且该 file 还是个匿名文件，因此应用程序无法通过 fd = open(“name”) 的方式来获取它所对应的 fd，只能依托于 exporter 驱动的 ioctl 接口，通过 dma_buf_fd() 来获取，就像上一篇的示例一那样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cde16daa5085ee58ce6d2b4eec4104d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b42d5ce0c6ad9facb154c79921a7e9e4/" rel="bookmark">
			实验6、8254定时/计数器实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验内容
基础部分：
1、编写程序，是8254的计数器1分别工作在方式0、1、2、3下，在示波器上观察各工作方式下OUT1的输出波形。
拓展部分：
2、使用单脉冲开关手动生成8254的输入时钟，观察方式0的输出波形。
3、编写程序，在示波器上显示周期为1s的方波。
4、利用8254方式2或方式3精确定时，控制LED等D7~D0的点亮：
初始时，D7~D0全部熄灭；1秒钟之后点亮D0，再经过1秒D1D0点亮，…，8秒钟之后D7~D0全部点亮。 代码
1
CONUTER0 EQU 0600H CONUTER1 EQU 0602H CONUTER2 EQU 0604H CON8254 EQU 0606H CODE SEGMENT ASSUME CS:CODE START: MOV DX, CON8254 ;MOV AL,70H ;计数器1工作在方式0 ;MOV AL,72H ;方式1 MOV AL,74H ;方式2 ;MOV AL, 76H ;方式3 OUT DX, AL MOV DX, CONUTER1 MOV AL, 00H OUT DX, AL MOV AL, 48H OUT DX, AL AA1: JMP AA1 ;将GATE1置为高电平，运行程序，在示波器中可以看到OUT1输出一段高电平后会输出一个宽度为一个周期的负脉冲。 CODE ENDS END START 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b42d5ce0c6ad9facb154c79921a7e9e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63dc1e3bb906674895faa07e3e650242/" rel="bookmark">
			LT和LTV计算方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转摘自：https://www.jianshu.com/p/d7385275a005
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cabcbdb40356bc85a9d73937eb68a891/" rel="bookmark">
			Android 获取缓存文件的目录，文件的目录，外部存储的目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		getCacheDir()、getFilesDir()、getExternalFilesDir()、getExternalCacheDir()的作用 一.getCacheDir、getCacheDir getCacheDir()方法用于获取/data/data//cache目录
getFilesDir()方法用于获取/data/data//files目录
二.getExternalFilesDir、getExternalCacheDir 应用程序在运行的过程中如果需要向手机上保存数据，一般是把数据保存在SDcard中的。大部分应用是直接在SDCard的根目录下创建一个文件夹，然后把数据保存在该文件夹中。这样当该应用被卸载后，这些数据还保留在SDCard中，留下了垃圾数据。如果你想让你的应用被卸载后，与该应用相关的数据也清除掉，该怎么办呢？
通过Context.getExternalFilesDir()方法可以获取到 SDCard/Android/data/你的应用的包名/files/ 目录，一般放一些长时间保存的数据
通过Context.getExternalCacheDir()方法可以获取到 SDCard/Android/data/你的应用包名/cache/目录，一般存放临时缓存数据.如果使用上面的方法，当你的应用在被用户卸载后，SDCard/Android/data/你的应用的包名/ 这个目录下的所有文件都会被删除，不会留下垃圾信息。
而且上面二个目录分别对应 设置-&gt;应用-&gt;应用详情里面的”清除数据“与”清除缓存“选项
如果要保存下载的内容，就不要放在以上目录下
较优秀的程序都会专门写一个方法来获取缓存地址，如下所示：
public String getDiskCacheDir(Context context) { String cachePath = null; if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) || !Environment.isExternalStorageRemovable()) { cachePath = context.getExternalCacheDir().getPath(); } else { cachePath = context.getCacheDir().getPath(); } return cachePath; } 可以看到，当SD卡存在或者SD卡不可被移除的时候，就调用getExternalCacheDir()方法来获取缓存路径，否则就调用getCacheDir()方法来获取缓存路径。前者获取到的就是 /sdcard/Android/data//cache 这个路径，而后者获取到的是 /data/data//cache 这个路径。
注意：这两种方式的缓存都会在卸载app的时候被系统清理到，而开发者自己在sd卡上建立的缓存文件夹，是不会跟随着app的卸载而被清除掉的。
三.Android开发:filePath放在哪个文件夹 Environment.getDataDirectory() = /data Environment.getDownloadCacheDirectory() = /cache Environment.getExternalStorageDirectory() = /mnt/sdcard Environment.getExternalStoragePublicDirectory(“test”) = /mnt/sdcard/test Environment.getRootDirectory() = /system getPackageCodePath() = /data/app/com.my.app-1.apk getPackageResourcePath() = /data/app/com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cabcbdb40356bc85a9d73937eb68a891/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8860e31f1ab9780b8bdf1d7e211d908e/" rel="bookmark">
			Android java.lang.IllegalStateException: Underflow in restore - more restores than saves
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因：在自定义view里面调用了
c.restore(); 方法来保存画布的bitmap图像；
解决：
c.save();//在之前先写这一句 c.restore(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6771c7b2f2a47f142091d62393d0861a/" rel="bookmark">
			刚转行的运营人做哪些副业更简单，并且更赚钱？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享两个零基础转行的运营人，一位通过副业和积累成了公司高管，年薪45w，一位成了创业的小老板，带领6人团队总收入年薪230w左右
先来一个大纲，方便大家浏览和直接学习到自己想看的那部分
1、他们怎么从零基础转行通过副业做到如此成绩？ 2、分析每一个人的副业过程？ 3、目前适合刚装行的运营新人做的副业有哪些？ 一、他们怎么从零基础转行通过副业做到如此成绩？ 这两位都是四哥身边的朋友，我们先说第一位，年薪45w的运营高管。
我和他是大学认识的，他毕业后就没有从事导游工作，直接自学的视频剪辑和后期制作这方面，后续也就从事一些传统企业的后期工作和制作宣传片工作。那时候他的工资不过是7k多一点，每天还是特别的累
也就在去年，18年的时候抖音是一个火爆年，他找到了我，因为我们的关系一直不错，也知道我是从事运营方面的工作，和我聊聊说，我既然会后期和剪辑，加上目前短视频、自媒体这方面的需求这么大，我不如转行学习一下这方面。我也很赞同他的想法
我也就送了他很多的运营教程让他学习，然后我又劝他报名了一个课程学一下，这样还有人能带你。用一月时间把短视频运营简单的了解一下就去接短视频私活。
因为他有很好的剪辑底子，对于视频的编剧本，拍摄，后期剪辑都不在话下，只要快速对平台的玩法和运营的技巧了解就行，不过这块他到是不少请我吃饭，因为我帮他很多。那时候他还在上班，学完在结合上和我请教，之后利用业余时间找到第一份兼职
他的第一份兼职工作就是北京一家公司的抖音运营，因为这家公司在线下做的很好，但是线上属于刚布局，在加上直接准备投钱做短视频领域，前期的招聘团队很困难，他过来的时候看见这种情况，属于公司对这方面的业务刚起步，感觉想要抓住机会
他针对目前公司的产品和渠道的调研，很快的有了拍摄的想法和每一步的执行和计划，对运营这块虽然是新手，但是制定的初期的短视频方案，在方案执行前，也多次找到我帮他优化方案，为了确保每一步没有什么太大的意外
虽然他是兼职，但是汇报工作直接找总监，因为这位总监对线上的了解属实很少，他是之前的线下运营总监，针对我俩共同改的方案，他们总监看后也没什么意见，直接就执行
短视频方案包括：人员分工、剧本、设备、运营、账号、场地等等特别详细
1个月时间同期运营的10个抖音号有3个都做到了20w粉丝，前后打造了3个上千万的视频，最后收入也是开支的3倍多，也就说是说总投入100万，收获了300万。
不错就因为这一次的业绩直接就被公司挖了过去，继任了线上短视频部的负责人，后续几个月他的付出更辛苦，不断优化方案，跑业务，各处学习请教，盯每一个部门的配合工作，每一个剧本甚至说视频中说的每一句话都必须经过他的多次审核通过才行，对每一项环节都需要严格审核。
经过5个月的时间顺利转行成功，成为线上运营总监
接下来说第二位朋友，刚转行半年就带团6人队创业，团队实现年薪230w左右
他是我的一位发小，上学期间学习不是很好，高中毕业就不上学了，他家是做饭店的，不上学后直接就去家里饭店学习厨师技术了，在转行前在2线城市干厨师，他已经月薪能挣到10k左右，在一家酒店当主厨
之前每次回家的时候都会去他在的酒店吃一顿，关系一直保持都不错，他平时利用业余时间喜欢在一些视频平台发一些做菜的教程，有几个视频还小火了一下，没有特意的去运营，平时也就发一些教程，两个月抖音是11万粉丝，快手是15万粉丝。面对的这样的数据，但是不会变现
也就在上次回家的时候，找到我说，想通过抖音、快手、公众号这种平台做一些线上卖货。我和他说你这个想法很好，现在美食的销量又很不错，再加上你又是专业的，对产品你就可以自己把控，而且美食又属于大众产品，你如果真的能做出来好吃的，通过短视频渠道推广会很容易爆
但是目前你缺少的不是优质的产品，你缺少的是怎么运营，怎么推广出去，怎么得到曝光。最初的时候他准备招聘一个运营，但是由于考虑到预算，前期的成本开销太大，就准备自己学习一下
同样作为发小的我，给他出了一整套的完整的运营方案包括前期、中期、后期方案和一整套的拉新、留存、转化方案、总共两套方案写的很详细，具体执行到每一步骤
然后我又推荐给他看一些运营基础课程，让他在业余时间学习一下。
他当时主要是在快手和抖音和公众号这块分别下手，快手和抖音直接就是录一些做菜的教程，然后引流到直播卖货。公众号主要是玩一些裂变的活动，进行涨粉和拉新
这段时间都算是业余在做，算是熟悉一下方案的流程，这样保持一个月后辞职掉工作，开始正式投入
主要有三种产品：熟食（密封）、调理、下饭菜这三种，全是自己做的，也让大部分人都尝了一下，味道不错
人员：招聘一个摄影、一个后期、剩下的都是产品研发人（厨师）也算是合伙人、创始人是我这位发小，他负责的（运营）
运营渠道：快手、抖音、公众号为主，还有一些微博等等（我也算是前期帮助运营一下和给出方案）
最后通过一年时间实现230w的营业额
二、分析每一个人的副业过程？ 案例1：月薪45w的高管
其实他的顺利转行成功和他的自身因素、机遇这两方面有关
自身因素：首先自己的专业技能和副业很相符，因为他是后期出身，对于做短视频肯定是核心力量，在加上自己这些年积攒的工作经历，自己会编剧本、拍摄、后期，相当于做视频的前中后期都可以
会这些技能就象征做短视频运营的硬技能都会了，但是唯一缺少不会的是运营，也就是说做一个短视频没问题，但是这个视频不会运营，不知道该怎么让他去火
结合他种情况快速学习短视频运营是一个正确的选择，而且他的选择方向很明确，准备要做短视频运营直接就考虑付费学习，他这一点是正确的，有些人就会选择自学，那这种自己去摸索就浪费时间了
机遇：其实说机遇还不如说所有机遇都是自己创造出来的呢？如果说他还在传统行业做后期也是可以的，那为什么他就想做短视频运营了呢，这也肯定和他的平时行业调研有关系，他正赶上去年短视频的爆发年，然后在个时候结合上自己的技能做短视频是很正确的选择
他虽然是抱着副业的心态去，准备接一点私活，但是正赶上这家公司在线上短视频业务布局并且还在招兵买马，虽然是个兼职，但是也很好的把握住了这次机会，在加上各种的帮助，顺利的在兼职过程中做了业绩
在做出业绩的时候还是依旧不懈的努力，像别人请教学习，最后顺利的转行成功，成为线上运营总监
针对他我总结了几句话：
1、对各行各业的调研，最起码是和自己目前所做的行业，相关的行业做调研 2、为了到达目的，投资学习是不在乎的事情 3、努力、负责任、爱学习，包括后期成功后都是不断学习和请教 案例2：带6人团队实现年薪230w
其实他的转行和他的坚持学习、产品过硬这两方面有关
坚持学习：其实能看出来他特别爱学习，包括在学习厨师的过程中他也很刻苦，也就用了6-7年时间吧，就当上了酒店的主厨。其实他的薪水待遇在2线城市已经完全够生活了，但是他还是要创业
他知道我是干运营工作的，最早之前他是没麻烦我，没说创业这些事情，运营这块也没和我学习，他一开始找了别人学习，也花了很多钱，效果不是很明显，自己找的没有别人推荐的更符合自己，比如我现在推荐我会结合他这种情况，给他推荐几个适合他学习的地方，自己的找的话没有考虑那么多，其实转行前在哪里学习也是很关键的
最后他就自己录一些东西，反而效果更好了，这时候才找到了我，如果说他要是能更提前的找到我，他的效果会更好，因为我直接会告诉他怎么执行，视频怎么录，该怎么变现、运营该怎么学。
这就说明一点，他是爱学习的，平时也喜欢观察一些行业的动态
产品过硬：身为主厨的他肯定在厨艺上是有这过人的地方，他做的菜那是相当好吃，这也是产品过硬的因素，我们都知道产品的好坏是竞争的最关键因素，再加上美食属于一个大型的产品市场，竞争力极大。可以看出他的产品在这种情况下，还能拼出一点地位，说明产品还是足够优秀
他们的产品部门，就是厨师部门过硬才导致他们研究的几款产品售卖很好，而且美食这种产品真的是回头客占据很大市场，只要味道过硬，不说独一无二，只要是味道上特殊，适合大众喜欢，销量就差不了
渠道运营在这方面自己维护的也很不错，短视频渠道负责曝光、涨粉。直播负责卖货。公众号负责拉新、留存、活动通知、售后等。
后期和摄影技术也不错。那这种团队和产品就没问题
针对他我总结了几句话：
1、爱学习、多学习是关键 2、产品过硬是关键，说明我们只要有一项看家本领，你就不缺产品 3、团队的协调和自己的努力很关键 三、目前适合刚装行的运营新人做的副业有哪些？ 其实新人能做的副业有很多，我给大家举例几个我做的比较成功的副业有哪些，都是非常适合新人入手的
1、公众号做副业
我运营公众号前1个月完全没有盈利，而且数据极其的差，那时候我做的是“运营干货分享”领域。定位很明确，专业技能也算擅长，但是不盈利，涨粉也很慢
那时候总感觉做微信公众号只要是好好写文章就可以，把内容做好了就能带来传播，可是1个月后粉丝涨了不到2000，每篇文章平均阅读300左右
可是反观的是，我把这些文章放在头条号、百家号等领域涨粉特变快，阅读都是几十万。
其实这就是刚做公众号的一个误区，总是感觉内容是最关键的，其实优质内容只是一个指标，如果结合上玩法就会很快涨粉，变现就会很快
举例我的涨粉套路：
我在各个自媒体平台留下“去微信搜索某某某公众号，回复（资料）就可免费获得海量运营资料”这样的套路持续用了1个月粉丝涨到了5000多，阅读量平均在1000左右
虽晚说这招很常见，但是很实用，而且粉丝很精准，后期我又以这种办法为基础，又专研出了几种涨粉套路，今天就不在这分享了，后续大家需要直接私信我就行
拿公众号变现的方式我选择最快捷的接广告，我是按照预付加后续根据曝光再续付费这样的方式，赚了我在公众号的第一笔钱3000元
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6771c7b2f2a47f142091d62393d0861a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84500b32c221062b23300e5a3cdd12d2/" rel="bookmark">
			基于pynq-2开发板使用vivado hls新建（CNN）SOC系统识别手写体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#一、按照流程建立SOC系统：
##1、自动添加zynq的arm模块（按图一操作）
##2、点击Run Block Automation，工具自动生成DDR接口，连线，再点击validate design
##3、按流程添加HLS生成的IP；
##4、搜索添加IP；
##5、自动连线,依次勾选pool和conv模块，被arm控制
##6、双击zynq框，选择取数据的口；选择hp0；再次自动连线，将arm做为slave连接到卷积和池化模块，让两个电路可以通过arm访问内存
##7、步骤，看图说话，注意点击.bd文件后选择，create HDL wrapper代表生成多少接口
二、生成bit文件
在该文件夹生成 文件 ：pynq_test1\pynq_test1.runs\impl_1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ce55cf4345d410bc6795648d2e415d3/" rel="bookmark">
			【JavaScript 中卷】值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组，字符串和数字是一个程序最基本的组成部分，但在JavaScript中，它们可谓让人喜忧掺半。
本章将介绍JavaScript中的几个内置值类型，让读者深入了解和合理运用它们。
2.1 数组 和其他强类型语言不同，在JavaScript中，数组可以容纳任何类型的值，可以是字符串，数字，对象，甚至是其他数组：
var a = [1, "2", [3]]; a.length; //3 a[0] === 1; //true a[2][0] === 3; //true 对数组声明后即可向其中加入值，不需要预先设定大小： var a = []; a.length; //0 a[0] = 1; a[1] = '2'; a[2] = [3]; a.length; //3 使用delete运算符可以将单元从数组中删除，但是请注意，单元删除后，数组的length属性并不会发生变化。 类数组 有时候需要将类数组转换为真正的数组，这一般通过数组工具函数(indexOf(...)，concat(...)，forEach(...)等)来实现。
第一种方法：
function foo() {
var arr = Array.prototype.slice.call(arguments);
arr.push('bam');
console.log(arr);
}
foo('bar', 'baz'); //['bar', 'baz', 'bam']
如上所示，slice()返回参数列表的一个数组复本。
第二种方法：
var arr = Array.from(arguments); 2.2 字符串 字符串经常被当成字符数组。
例如下面两个值：
var a = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ce55cf4345d410bc6795648d2e415d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/839b1fab9a9a0cb223a459e3e55250a5/" rel="bookmark">
			软件制造工程期末复习知识点汇总（一）——软件工程概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 传统的瀑布式开发
缺点：不能适应需求的动态变更
敏捷开发
概念：一种以人为核心、迭代、循序渐进的开发方法。
力求在很短的周期内开发出产品的核心功能，尽早发布出可用的版本。然后在后续的生产周期内，按照新需求不断迭代升级，完善产品。
实现：SCRUM,XP（极限编程），Crystal Methods、FDD
1.了解软件工程学产生的背景和原因 背景：1960~1970软件危机
时间：1968年
软件危机：在计算机软件的开发和维护过程中所遇到的一系列严重问题
典型表现：
（1）对软件开发成本和进度的估计常常很不准确；
（2）软件成本在计算机系统总成本中所占的比例逐年上升；
（3）软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势 。
（4）软件通常没有适当的文档资料；
（5）软件常常是不可维护的；
（6）软件产品的质量往往靠不住；
（7）用户对“已完成的”软件系统不满意的现象经常发生；
软件≠程序
软件=程序+数据+文档
2.了解软件工程的基本原理、概念和方法 软件工程：是指导计算机软件 开发 和 维护 的一门工程学科。
基本原理：
用分阶段的生命周期计划严格管理
坚持进行阶段评审
实行严格的产品控制
采用现代程序设计技术
开发小组的人员应该少而精
特性：
在软件工程领域中是由具有一种文化背景的人替具有另一种文化背景的人创造产品
开发软件的效率非常重要
软件工程的中心课题：控制复杂性
软件经常变化
软件必须有效地支持它的用户
和谐地合作是开发软件的关键
软件工程包括 技术 和管理 两方面的内容
技术方面：
技术，即方法学（又称范型）
三个要素：方法，工具，过程
方法：
传统方法学（生命周期方法学/结构化范型）：划分为若干个阶段，强调自顶向下，采用 结构化技术 来完成软件；
面向对象方法学：强调主动地多次反复迭代
面向对象方法=类+对象+继承+用消息通信
3.掌握软件生命周期模型 组成：三个时期八个阶段
问题定义：问题是什么=》关于系统规模和目标的报告书
可行性研究：问题是否有解决方案=》系统的高层逻辑模型(数据流图、成本效益分析)，可行性论证报告
需求分析：必须做什么=》系统的逻辑模型(数据流图、数据字典、简要的算法描述)，需求规格说明书
概要设计：如何解决已提出的问题=&gt;系统流程图、成本效益分析,系统体系结构（层次图或结构图）
详细设计：怎样具体实现该系统=》程序流程图、PAD图、N-S图
编码和单元测试：得到正确的程序模块=》代码和测试报告
综合测试：得到符合要求的软件=》测试计划、详细测试方案以及实际测试结果，完整一致的软件配置
软件发布、运行、维护：使系统持久地满足用户的需要=》完整准确的维护记录
其中维护占生命周期的一半以上，维护又细分为：完整性维护（对应用户需求）&gt;适应性维护（软件运行环境）~改正性维护（Bug）&gt;预防性维护（预防Bug）
4.为特定的项目选择适合的模型 软件过程：是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。
软件过程模型： 软件过程模型要点优点缺点适用范围瀑布模型每个阶段都有文档产出文档驱动的有序方法只能通过文档了解产品，交付产品可能不符合客户的要求项目周期较短。需求是预知的，软件实现方法是成熟的；快速原型模型不带反馈环，线性顺序进行，本质是“快速”确保交付的产品符合客户的要求还没有证明无懈可击无完整的需求说明，只有一些基本要求增量模型每一个增量均发布一个可操作产品增大投资的早期回报，能在较短的时间内，提供可完成部分工作的初步产品给用户；要求较高，要求开放的结构，可能退化为建造-修补模型需求经常改变，开发人员数量不够螺旋模型强调风险分析（快速原型+瀑布模型）+风险分析结合上述所有模型的特性，风险驱动开发成本，只能用于大型的内部软件产品，开发者必须精通风险分析和风险排除适用于庞大、复杂并具有高风险的系统。喷泉模型无间隙各个阶段没有明显的界限，开发人员可以同步进行开发。不利于项目的管理，要求严格管理文档，使得审核的难度加大适用于面向对象的软件开发过程。Rational统一过程（RUP）迭代的，以架构为中心的，用例驱动的软件开发方法。四个阶段：初始阶段，精化阶段，构建阶段，移交阶段敏捷过程之极限编程（XP）敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。极限编程（XP）是敏捷过程中最富盛名的一个高适应性，以人为本，以测试为驱动需求模糊，规模小、进度紧、需求变化大、质量要求严的项目。不适合项目团队超过10人的中大型项目，团队人员异地分布的项目；微软过程每一个生命周期发布一个递进的版本，各生命周期持续快速地迭代循环综合了Rational统一过程和敏捷过程的优点对方法、工具和产品等方面不够全面 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb5f4a49845d11092bd8535b0aecf0ae/" rel="bookmark">
			intouch制作历史报警查询（时间查询，筛选关键字）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中，intouch制作历史报警查询已属于标配功能，如何做出按时间以及关键字来进行综合查询，提高历史报警查询效率仍然是一个值得研究的问题，接下来参考网上文章自己总结下如何制作。
1.DTPicker格式制作 首先，时间选择器的安装不再一一演示，（安装32位office系统，从向导中安装date and time picker即可）。然后，选择自定义格式，这里格式十分重要，直接关系到时间查询的准确性（12小时制，24小时制的区别）。
格式如下：yyyy-M-d H:mm:ss
控件时间，设置为上午/下午以区分24小时，时间选择为本地时间。
2020/5/4:备注
%H参数可以直接修改为24小时制
总体效果如下：
2.过滤器编写 过滤器的原理其实很简单，就是利用AlmDbViewCtrl控件本身自带的过滤器属性进行XML文档配置，然后再后台拼凑去过滤器的格式，填充好相应的查询关键字内容即可。
1.首先，编辑好过滤器路径和文件
C:\Program Files (x86)\Wonderware\InTouch\test.xml
2.查看文件格式和内容，试着手动新建一个看看格式。
3.可以利用自定义函数去拼凑相应格式，填写相应内容。
编写quickfunction函数:ALMFILTERSEARCH
FileDelete("C:\Program Files (x86)\Wonderware\InTouch\test.xml"); FileWriteMessage( "C:\Program Files (x86)\Wonderware\InTouch\test.xml",0, HIST_XMLCODE +"&lt;FILTER_FAVORITES&gt;&lt;RECORD&gt;&lt;FILTERNAME&gt;MYFILTER&lt;/FILTERNAME&gt;&lt;ELEMENT&gt;", 0 ); IF HIST_SEARCHINDEX == 1 THEN FileWriteMessage( "C:\Program Files (x86)\Wonderware\InTouch\test.xml",-1, "&lt;NAME&gt;名称&lt;/NAME&gt;&lt;ORIGNAME&gt;Name&lt;/ORIGNAME&gt;&lt;OPERATOR&gt;LIKE&lt;/OPERATOR&gt;&lt;VALUE&gt;%"+CONDITION+"%&lt;/VALUE&gt;&lt;PARENT&gt;0&lt;/PARENT&gt;", 0); ELSE FileWriteMessage( "C:\Program Files (x86)\Wonderware\InTouch\test.xml",-1, "&lt;NAME&gt;报警注释&lt;/NAME&gt;&lt;ORIGNAME&gt;Alarm Comment&lt;/ORIGNAME&gt;&lt;OPERATOR&gt;LIKE&lt;/OPERATOR&gt;&lt;VALUE&gt;%"+CONDITION+"%&lt;/VALUE&gt;&lt;PARENT&gt;0&lt;/PARENT&gt;", 0); ENDIF; FileWriteMessage( "C:\Program Files (x86)\Wonderware\InTouch\test.xml", -1, "&lt;/ELEMENT&gt;&lt;/RECORD&gt;&lt;/FILTER_FAVORITES&gt;", 0 ); #AlmDbViewCtrl1.FilterFavoritesFile = "C:\Program Files (x86)\Wonderware\InTouch\test.xml"; 其中：HIST_XMLCODE为内存消息，存放xml头部消息（&lt;?xml version="1.0" encoding="GB2312"?&gt;）
HIST_SEARCHINDEX为内存整型，单选按钮选择状态（选择标记名为1）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb5f4a49845d11092bd8535b0aecf0ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d24197a1bd2b1027f503fd37ae5ebf06/" rel="bookmark">
			基于概率论的分类方法： 朴素贝叶斯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4.1 基于贝叶斯决策理论的分类方法 优点：在数据较少的情况下仍然有效，可以处理多类别问题。
缺点：对于输入数据的准备方式较为敏感。
适用数据类型：标称型数据。
贝叶斯决策理论
朴素贝叶斯是贝叶斯决策理论的一部分，所以讲述朴素贝叶斯之前有必要快速了解一下贝叶斯决策理论。
贝叶斯决策理论的核心思想，即选择具有最高概率的决策。
如果p1&gt;p2(1,2为两个类别)，那么类别为1.
4.2 条件概率 条件概率==p(a|b)==表示在事件b发生的条件下a发生的概率。
p(a|b)=p(ab)/p(b)
而 p(ab)=p(b|a)p(a)
4.3 使用条件概率来分类 分类准则：
比较P(c1|x, y) 与 P(c2|x, y) 的大小，认为结果属于概率大的类别。P(c1|x, y)表示给定某个由x、y表示的数据点，那么该数据点来自类别c1的概率。
4.4 使用朴素贝叶斯进行文档分类 朴素贝叶斯是贝叶斯分类器的一个扩展，是用于文档分类的常用算法。
两个假设：（1）朴素：特征之间相互独立
（2）每个特征同等重要
朴素贝叶斯分类器通常有两种实现方式：一种基于贝努利模型实现，一种基于多项式模型实现。这里采用前一种实现方式。该实现方式中并不考虑词在文档中出现的次数，只考虑出不出现，因此在这个意义上相当于假设词是等权重的。
4.5 使用 Python 进行文本分类 4.5.1 准备数据：从文本中构建词向量 #创建一些例子 def loadDataSet(): postingList=[['my','dog','has','flea',\ 'problems','help','please'], ['maybe','not','take','him',\ 'to','dog','park','stupid',], ['my','dalmation','is','so','cute',\ 'I','love','him'], ['stop','posting','stupid','worthless','grabage'], ['mr','licks','ate','my','steak','how',\ 'to','stop','him'], ['quit','buying','worthless','dog','food','stupid']] classVec=[0,1,0,1,0,1] #1代表侮辱性文字(stupid) return postingList,classVec #创建包含文档中所有单词（不重复）列表 def createVocabList(dataSet): vocabSet=set([]) #创造一个空集合 for document in dataSet: vocabSet=vocabSet | set(document) #集合并运算 return list(vocabSet) #把单词列表转换为文档向量 def setOfWorld2Vec(vocabList,inputSet): returnVec=[0]*len(vocabList) #创建对应的向量 for word in inputSet: # word 为目标单词 if word in vocabList: returnVec[vocabList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d24197a1bd2b1027f503fd37ae5ebf06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/905455e983127c224ffbfb9fe10f25c4/" rel="bookmark">
			Ubuntu-12.04.5-desktop-i386（32位）下安装arm-linux-gcc-4.4.3.tar.gz（32位） (交叉编译环境配置，同时要保证arm-linux-gcc-4.4.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu-12.04.5-desktop-i386（32位）下安装arm-linux-gcc-4.4.3.tar.gz（32位） (交叉编译环境配置，同时要保证arm-linux-gcc-4.4.3.tar.gz有bin这个文件)
Ubuntu下安装arm-linux-gcc-4.4.3.tar.gz ，其过程如下：
下载arm-linux-gcc-4.4.3.tar.gz 到目录/home/gxj/arm下（这个目录根据自己的情况自行建立）。
1.解压文件
执行命令：`sudo tar -zxvf arm-linux-gcc-4.4.3.tar.gz
2.建立目录
执行命令：sudo mkdir /usr/local/arm
3.复制文件
执行命令：sudo cp -r /home/gxj/arm/gcc-4.4.3 /usr/local/arm
4.添加环境变量（下面vi或vim只用其中一种，我的不能使用vim，所以我使用的是vi）
添加环境变量以下一共有三种方法，分别介绍如下：
方法一：修改/etc/bash.bashrc文件（此文件只对当前用户适用）
执行命令：sudo (vi)vim /etc/bash.bashrc
在最后加上 export PATH=$PATH:/home/gxj/arm/gcc-4.4.3/bin (路径)(注意等号那边不要有空格)
方法二：修改/etc/profile文件（此文件属于系统级别的环境变量，设置在里面的东西对所有用户适用）（推荐使用）
执行命令：sudo (vi)vim /etc/profile
增加路径设置添加如下：
在done的下一行插入 export PATH=$PATH:/usr/local/arm/gcc-4.4.3/bin (路径)(注意等号那边不要有空格)
方法三：修改/etc/environment文件
执行命令：sudo (vi)vim /etc/environment
原文件应为 PATH="/usr/lib/lightdm/lightdm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games"
将其改为PATH="/usr/lib/lightdm/lightdm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/arm/gcc-4.4.3/bin"
根据每个人电脑不一样，原路径有可能不一样，但修改后只是在原路径后面多了一个自己的路径（/usr/local/arm/gcc-4.4.3/bin）
关于环境变量问题：
环境变量是什么？例如path，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。用户通过设置环境变量，来更好的运行进程。
如果上面不加入环境变量，要运行arm-linux-gcc这个程序，则每次都要把arm-linux-gcc的完整路径写出来。/usr/local/arm/gcc-4.4.3/bin arm-linux-gcc 文件名 -o 输出文件名
这样非常的麻烦，所以加到path里面，让电脑知道这个程序在哪里。
5.注册环境变量
立即使新的环境变量生效，不用重启电脑，对应步骤5也有3种方法（上面三种方法对应的生效方法如下）
方法一：source /root/.bashrc 或者 ./etc/bash.bashrc
方法二：source /etc/profile
方法三：立即生效
6.检查是否将路径加入到PATH
执行命令：echo $PATH
显示为/usr/lib/lightdm/lightdm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/arm/gcc-4.4.3/bin则说明已经将交叉编译器的路径加入PATH。至此，交叉编译环境安装完成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/905455e983127c224ffbfb9fe10f25c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8151d385fa3573e2b6bac7c424546a4a/" rel="bookmark">
			MFC设置编辑框背景颜色等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在Dlg.h头文件中添加函数声明 添加
public: HBRUSH OnCtlColor(CDC * pDC, CWnd * pWnd, UINT nCtlColor); 2、重载OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) 即添加ON_WM_CTLCOLOR()
3、编辑OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)函数 3.1 对单个控件操作 HBRUSH C菜单打钩Dlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) { HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor); // TODO: 在此添加控件通知处理程序代码 if (pWnd-&gt;GetDlgCtrlID() == IDC_MESG)	//如果是ID为IDC_MESG的编辑框 { pDC-&gt;SetTextColor(RGB(255, 0, 0)); //设置字体颜色 pDC-&gt;SetBkMode(TRANSPARENT); //设置字体背景为透明 // TODO: Return a different brush if the default is not desired return (HBRUSH)::GetStockObject(BLACK_BRUSH); // 设置背景色 } else return hbr; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8151d385fa3573e2b6bac7c424546a4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daaadcd4bf2abdd463d1b3a21dc9ee35/" rel="bookmark">
			C&#43;&#43;中的“引用”详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在面向对象的程序设计语言中，我们经常听见一些名词，引用，地址，在函数传递参数的时候，我们又经常说值传递，引用传递，最容易让人搞混淆的就是“引用”和“地址”这两个概念了，对于C++和C#来说，引用一词从他们所呈现的表象来看的确很类似，但是本质实际上是不一样的，
C++：引用就是一个变量的别名；
C#：引用可以用指针去理解，虽然C#没有指针，我们经常说某个变量所引用的数据，可以理解为某个变量所指向的数据。
一、先从C语言的交换两个变量说起 C语言中：函数传参有传值和传址两种方式
用swap函数举例：
1.1 传值方式（创建了临时变量存放实参的值）
缺点：不能通过函数形参改变外部实参
优点：不能改变外部的实参
void swap(int left,int right)//此代码不能完成两数的交换 { int tmp = left; left = right; right = tmp; } 2.传址方式（创建了临时变量存放了实参的地址）
缺点：每次访问实参都要解引用
优点：可以改变外部实参
void swap(int* left,int* right) { int tmp = *left; *left = *right; *right = tmp; } 而C++中就引入了引用的概念，下面详细介绍一下C++中的引用
上面的代码就可以写成这样
此时代码中的left和right就是实参的别名，通过交换left和right就能将传过来的实参进行交换。
void swap(int&amp; left,int&amp; right) { int tmp = left; left = right; right = tmp; } 总结：C++通过引用就可以达到C语言的指针作为参数的效果。
二、引用的简单概念 引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。
定义引用类型的格式：
类型 &amp; 引用变量名(对象名) = 引用实体；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daaadcd4bf2abdd463d1b3a21dc9ee35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f651a5d6c410153a4d228176b49bb4e/" rel="bookmark">
			Hibernate 的级联更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hibernate 的级联更新 引言 上一篇文章中，我提到 Hibernate 的查询可以不用 SQL，而本篇，我要分享的是 Hibernate 的实体更新。因为 Hibernate 的这一特性，同样让我在开发的过程中，感受到了省心和劳心。
Hibernate 内实体的四种状态 什么是实体？其实就是对象。而 Hibernate 内的实体分为四种状态：临时态、持久态、游离态、删除态，
临时态(transient)：刚用 new 语句创建，还没有被持久化，并且不处于 Sesssion 的缓存中。处于临时状态的 Java 对象被称为临时对象。
持久态(persistent)：已经被持久化，并且加入到 Session 的缓存中。处于持久化状态的 Java 对象被称为持久化对象。
游离态(detached)：已经被持久化，但不再处于 Session 的缓存中。处于游离状态的 Java 对象被称为游离对象。
删除态(removed)：不再处于 Session 的缓存中，并且 Session 已经计划将其从数据库中删除。处于删除状态的 Java 对象被称为删除对象。
各状态之间的切换，我仅给出一张图进行简单说明，建议想深入了解的朋友查阅有关文章。
持久态下，针对该实体任何属性的更改都会直接影响到数据库表中一条记录对应字段的更新，即与数据库表同步。同步的时机也建议查询下相关文章，不在赘述。
这是很方便的一个特性。举个例子 Book：
public class Book implements Serializable { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) Integer id; @Column(nullable = false, insertable = false, updatable = false) Integer peopleId; @ManyToOne(fetch = FetchType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f651a5d6c410153a4d228176b49bb4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32b768534c7b753e8795e6c94f21d07c/" rel="bookmark">
			Entity Framework Core 数据库优先(DB First)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DB First 1.从Nuget包中安装Entity Framework的依赖 EntityFrameworkCoreEntityFrameworkCore.SqlServerEntityFrameworkCore.Tools 其中Tools依赖包是用于在Nuget包中的管理控制台中执行以下命令之一，该命令是用于从数据库中生成对应的实体类与数据操作对象： Scaffold-DbContext [-Connection] &lt;String&gt; [-Provider] &lt;String&gt; [-OutputDir &lt;String&gt;] [-Context &lt;String&gt;] [-Schemas &lt;String&gt;] [-Tables &lt;String&gt;] [-DataAnnotations] [ -Force] [-Project &lt;String&gt;] [-StartupProject &lt;String&gt;] [-Environment &lt;String&gt;] [&lt;CommonParameters&gt;] 参数介绍： -Connection :
指定数据库的连接字符串。
-Provider :
指定要使用的提供程序。例如，Microsoft.EntityFrameworkCore.SqlServer。
-OutputDir :
指定用于输出类的目录。如果省略，则使用顶级项目目录。
-Context :
指定生成的DbContext类的名称。
-Schemas :
指定要为其生成类的模式。
-Tables :
指定要为其生成类的表。
-DataAnnotations :
使用DataAnnotation属性在可能的情况下配置模型。如果省略，输出代码将仅使用流畅的API。
-Force :
强制脚手架覆盖现有文件。否则，只有在没有输出文件被覆盖的情况下，代码才会继续。
-Project :
指定要使用的项目。如果省略，则使用默认项目。
-StartupProject :
指定要使用的启动项目。如果省略，则使用解决方案的启动项目。
-Environment :
指定要使用的环境。如果省略，则使用“开发”。
-UseDatabaseNames：使用数据库的表名、字段名生成实体类
示例:
Scaffold-DbContext "Server=(localdb)\mssqllocaldb;Database=Blogging;Trusted_Connection=True;" Microsoft.EntityFrameworkCore.SqlServer -UseDatabaseNames -OutputDir Models 在appsetting.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32b768534c7b753e8795e6c94f21d07c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3796bd8520127e9cf7904e0d6307a5d2/" rel="bookmark">
			DruidDataSource配置无效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多时候由于各个jar包的版本问题，很多类的属性字段不同而造成一些配置无效问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8482c62dc11c831e5208f788e5136d9/" rel="bookmark">
			ubuntu gnome下, alt &#43; tab切换窗口时,不要把同组的窗口合并的配置方法&#43;解决ubuntu无法使用root用户启动Google Chrome浏览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装系统编辑器 apt install dconf-editor 运行 dconf-editor 打开 org/gnome/desktop/wm/keybindings &lt;alt&gt; Tab 是放在了 switch-application 里面的. 要把它拿出来, 放到 switch-windows 中.
switch application 就是 把相同的窗口合并.
保存. 立马生效.
修改后的文件：
1.找到Chrome的路径
whereis google-chrome google-chrome: /usr/bin/google-chrome /usr/share/man/man1/google-chrome.1.gz
2.编辑文件
gedit /usr/bin/google-chrome 将 exec -a “ 0 " " 0" " 0""HERE/chrome” “$@” 改为
exec -a "$0" "$HERE/chrome" "$@" --user-data-dir --no-sandbox 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c01d19acb54745dc3c2258b84ce4a3e/" rel="bookmark">
			面向对象之关键字 this
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象之关键字 this 在java 中this可以完成三件事：表示本类属性，表示本类方法，表示当前对象 1、通过this关键字可以明确的去访问一个程用变量
class Hero { //新建一个Hero类 int age; // 类的属性为age public Hero(int age) { this.age = age; //用this.属性表示本类属性。 } public int getAge() { return this.age; } } 可以理解为： 对象名.属性 即 Hero.age ,只不过这里的对象在未创建之前是未知的，内部为空，没有地址，这里用this来表示一个未知对象，当创建新的对象时，this变会获取对象的地址。
2、通过this调用本类构造方法
class Hero { //新建一个Hero类 int age; String name; //新增一个属性 ，名字 public Hero(int age) { this.age = age; //用this.属性表示本类属性。 } public Hero( String name; int age){ this（age）； //this()调用本类方法，调用一个参数为age的本类构造方法 this.name = name; } public int getAge() { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c01d19acb54745dc3c2258b84ce4a3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45834db7fea4cf03fed1f59de1411c14/" rel="bookmark">
			linux中 &gt; 、&gt;&gt; 的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 将history命令执行的结果保存到history.log文件中
[root@gxzs-solr1 ~]# history &gt; history.log （history.log 文件 会自动生成）
[root@gxzs-solr1 ~]# cat history.log 2 执行命令 curl 'xxx' ，将其返回结果保存到 log.log 中
[root@gx-solr1 ~]# curl 'http://192.168.0.110:8983/solr/scan_detail/admin/file?_=1544066402749&amp;contentType=text/plain;charset=utf-8&amp;file=managed-schema&amp;wt=json' &gt; log.log
3 执行命令 cat /etc/hosts , 将其返回结果保存到 hosts.log 中
[root@slave1 ~]# cat /etc/hosts &gt; hosts.log
[root@slave1 ~]# more hosts.log 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4
::1 localhost localhost.localdomain localhost6 localhost6.localdomain6
注意：
使用 &gt; 执行命令时，每次都会新生成一个 &gt; 后面的文件，将之前生成的文件替换掉（文件创建时间也会跟着改变）。
4 使用 &gt;&gt; 向 hosts.log中追加 当前日期
[root@slave1 ~]# echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45834db7fea4cf03fed1f59de1411c14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd64f01a6be7a90581eaffdbb8ed7d87/" rel="bookmark">
			彻底搞定 SpringBoot 整合 Kafka（spring-kafka深入探秘）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 kafka是一个消息队列产品，基于Topic partitions的设计，能达到非常高的消息发送处理性能。Spring创建了一个项目Spring-kafka，封装了Apache 的Kafka-client，用于在Spring项目里快速集成kafka。
除了简单的收发消息外，Spring-kafka还提供了很多高级功能，下面我们就来一一探秘这些用法。
简单集成 引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 添加配置 spring.kafka.producer.bootstrap-servers=127.0.0.1:9092 测试发送和接收 /** * @author: SpringRoot * @date: 2019/5/30 */ @SpringBootApplication @RestController public class Application { private final Logger logger = LoggerFactory.getLogger(Application.class); public static void main(String[] args) { SpringApplication.run(Application.class, args); } @Autowired private KafkaTemplate&lt;Object, Object&gt; template; @GetMapping("/send/{input}") public void sendFoo(@PathVariable String input) { this.template.send("topic_input", input); } @KafkaListener(id = "webGroup", topics = "topic_input") public void listen(String input) { logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd64f01a6be7a90581eaffdbb8ed7d87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77cefc942388dda71bb0803f47e04a92/" rel="bookmark">
			Navicat Premium 使用数据泵向 ORALE 数据库中导入DMP文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.新建个连接，连接oracle数据库_不多说
2.新建用户_此步可省略，你也可以用之前已经有的用户
3.给用户授权（用户名为DMP）
grant all PRIVILEGES to DMP 授权语句
grant dba to DMP
授予DBA权限
4.cmd命令行执行导入命令
imp dip/DMP@localhost/orcl file="D:\XXXX\dmp\1113.dmp" full =y
DMP：用户
@localhost/orcl：数据库地址
D:\XXXX\dmp\1113.dmp：dmp文件路径
遇到问题1：
输入用户名和密码
遇到问题2：
执行授权语句给DMP
遇到问题3：
执行语句授予DBA权限
遇到问题4：
IMP-00003: 遇到 ORACLE 错误 959
ORA-00959: 表空间 ‘xxxx' 不存在
创建相应表空间
遇到问题5：
IMP-00058: 遇到 ORACLE 错误 1659
ORA-01659: 无法分配超出 6 的 MINEXTENTS (在表空间 cccc 中)
将cccc表空间设置为可扩展
个人探索过程记录，想看就看，不想看请随意，完结。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be6982aea1dd2d5c1575ca3ba4821558/" rel="bookmark">
			Golang三种引号详解：单引号、双引号、反引号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引子：Golang借鉴了不少C语言内容。
处理字符串是编程几乎绕不过去的一个问题。
Golang限定字符或者字符串一共三种引号，单引号（'')，双引号("") 以及反引号(``)。反引号就是标准键盘“Esc”按钮下面的那个键。
Golang中的单引号，更类似于C语言中的char类型，其实不能算字符串，因为只能是单个的字符。
Golang中的双引号，才是字符串，单行的，多个字符（字母数字）。
Golang中的反引号，类似Python的三引号，可以这行的字符串，所有转义字符将被忽略... 看个小例子：
package main import ( "fmt" ) func main() { str1 := 'a' //str1 := 'abc' // 会报错的 str2 := "Hello World!" str3 := ` Hi there~ I love Golang! ` fmt.Println(str1) fmt.Println(str2) fmt.Println(str3) } 会者不难。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0683f32f625fb1c3011fb5834ad2e96e/" rel="bookmark">
			从零开始学爬虫(9)——requests模块发送带headers的请求和带参数的请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、发送简单的请求 Requests是用python语言基于urllib编写的，采用的是Apache2 Licensed开源协议的HTTP库。与urllib相比，Requests更加方便，可以节约我们大量的工作，建议爬虫使用Requests库。具体可以参考这篇文章：《Python爬虫之requests库》
下面来完成一个小需求：通过requests向百度首页发送请求，获取百度首页的数据
常用的方法：
response.textresponse.contentresponse.status_coderesponse.request.headersresponse.headers 实现代码：
import requests response = requests.get("http://www.baidu.com") 二、发送带header的请求 在上图中，可以看到返回response.request.headers的时候，默认的user-Agent是python-requests/2.22.0，这个时候，网站就会知道访问自己的家伙是个程序（或者起码不是一个正常的浏览器），然后网站就可能会进行一些欺骗的操作来返回一些虚假的信息给爬虫。
因此，请求带上header的目的就是模拟浏览器，欺骗服务器，获取和浏览器一致的内容
header的形式：字典
例如：
header = { "User-Agent":"Mozilla/5.0(Windows NT 10.0;Win64;x64)AppleWebKit/537.36(KHTML,like Gecko)Chrome/54.0.2840.99 Safari/537.36" } 用法：requests.get(url,headers = header)
效果图：
此时返回的数据才是百度真实的页面源码
发送带参数的请求 当我们使用百度搜索Python的时候，我们看一下他的导航栏会变成什么样子(注意观察，会发现参数与参数之间使用&amp;连接)：
然而在这一堆参数里面，我们尝试着删除那些我们看不懂的参数（这些参数可能是由js生成的），我们留下关键的参数wd=Python，然后我们会发现网页依旧可以搜索到我们想要的数据：
因此，发送带参数的请求时，我们注意下列几点：
参数的形式：字典kw = {‘wd’:‘Python’}用法：requests.get(url,params = kw)注意：url里面不用自己写问号，url写根网址就行 使用实例：
课后题目： 获取新浪首页，查看response.text和response.content.decode()的区别 使用response.text时：
使用content时：
区别在于解码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4467db010469f3ea4adf3f4e2a3ebfb5/" rel="bookmark">
			JSONObject对象常用方法讲解--fromObject和toBean
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 含义 JSONObject.fromObject( ): 从java对象转化为JSONObject对象；
JSONObject.toBean( ): 从JSONObject对象转换为 javaBean 对象。
二. 添加依赖(JSONObject对象必须要用到的) 这里注意下，如果在main方法中创建对象及方法时JSONObject总是显示的红色，如下显示：
JSONObject json = JSONObject.fromObject(m)；
Object bean = JSONObject.toBean(json, User.class)；
那么需要添加下面的依赖到pom文件中。
&lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt; &lt;/dependency&gt; 三. 实例 1.创建实体
public class User { private String username; private String age; private String gender; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getAge() { return age; } public void setAge(String age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4467db010469f3ea4adf3f4e2a3ebfb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f51b24a76ef5deb28c4a0c40f13b598/" rel="bookmark">
			用HTML和CSS实现一个简单的登录界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个有审美的程序猿，我希望自己写的页面能够漂漂亮亮的。今天就分享一个简单又好看的登录界面，只需要一会会儿啦！
先给大家看看成品的样子
简单介绍一下这个登录页面的效果。当我们把鼠标聚焦到两个输入框时，输入框的长度会变大，并且边框的颜色会改变。当鼠标移动到提交按钮的范围内，按钮会给内部填充颜色。
话不多说，我们现在就步入正题：
首先搭建好HTML框架，在里面将自己要在页面上显示的模块都实现 &lt;body&gt; &lt;form class="box" action="Login.html" method="POST"&gt; &lt;h1&gt;Login&lt;/h1&gt; &lt;input type="text" name="" placeholder="Username"&gt; &lt;input type="password" name="" placeholder="password"&gt; &lt;input type="submit" name="" value="Login"&gt; &lt;/form&gt; &lt;/body&gt; 从代码中可以看出来，整个页面就是body里面嵌套了一个表单，表单内部有表单的标题、用户名输入框、密码输入框和提交按钮。
只有HTML的页面是不是超级丑呢
然后就是用CSS让它变好看啦，当然想要有一点点动画效果的话，还是要用到我们大名鼎鼎的CSS3。（说实话有点体会到CSS3的魅力） /* 先给整个页面设置背景颜色还有字体 */ body { margin: 0; padding: 0; font-family: sana-fserif; background: #34495e; } /* 给整个表单设置宽度高度是根据表单中的内容自行收缩的， 并设置定位让整个表单居于页面正中间 */ .box{ width: 300px; padding: 40px; position: absolute; /* 绝对定位，相对于父标签来进行定位 */ top: 50%; left: 50%; transform: translate(-50%,-50%); background: #191919; text-align: center; /*表单中内容居中*/ } transform: translate(-50%,-50%); css3的新特性，在不知道自身宽高的情况下，可以利用它来进行水平垂直居中。当使用：top: 50%;left: 50%; 是以整个表单的左上角为原点，所以表单不处于中心位置，会偏右下一点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f51b24a76ef5deb28c4a0c40f13b598/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdedfa061ed6d798b92dfb77c83a4594/" rel="bookmark">
			Typora页内跳转，真正能用的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Typora页内跳转，真正能用的方法 用Typora写文章时，当一篇文章里的内容很多，我们需要从后面跳到前面去参考之前提到的东西时，我们需要用到页内跳转，所谓页内跳转就是从一篇文章的一个地方跳到该篇文章的另一个地方。
页内跳转有两种情况：
跳转到标题所在位置跳转到非标题所在位置，即页面内任何位置 第一种跳转方法，即跳转到标题所在位置，用Markdown的标准跳转方法即可，而Typora跟它是完全兼容的，即：
[任意文字] (#标题名称) 举个例子：
这是一个三级标题，我们要跳转到这里 现在，我们用上面提到的方法来实现跳转，代码是
[第一种跳转] (#这是一个三级标题，我们要跳转到这里) 第一种跳转
但是，当我想用第二种跳转方法，即跳转到非标题所在位置，即页面内任何位置时，我搜遍了中文互联网，也没搜到如何在Typora里实现，后来搞清楚了，Typora比较特殊，大量文章里提到的用HTML里的span标签来实现是不行的。
后来在Typora里的官方文档里找到了答案：得用a标签！：
上面图片中圈红的即为实现方法，我更喜欢用name那种，因为简单。
知道这个方法后，直接在我想跳转的地方后面添上一段代码即可，比如
其实说的更抽象一点，想要实现跳转，就要告诉代码你要跳转到的具体位置，即给一个锚点，就像船到港后需要抛锚来固定一样。这个具体位置可以是一个URL；具体位置可以是标题，因为标题前面是有若干个“#”的，可以准确定位它；具体位置也可以是一个用HTML标签a定义的锚点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/685a8b10c4aaec6f7b6b18f41a0a62ea/" rel="bookmark">
			破解混淆加固的apk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近研究了下 app逆向安全，感觉客户端还是不安全，android和ios都可以破解，重要的东西还是放服务器，因为服务器相对安全一些。本文只供爱好研究以及安全测试用，如果用于非法，后果自负。
ios的破解我没试过，但是提供一篇文章：
https://www.cnblogs.com/xin-lang/p/8098142.html
android的破解，我也只讲思路，不提供工具，感谢各位破解大神提供的博客和思路。我最后会把我反混淆的思路也写出来。
一、首先是 没加固没混淆的apk。直接用apktools和dex2jar以及jd-gui就可以破解。
二、加固过的apk，首先要进行破壳处理。
破壳的思路很多，其中一种是，虽然加固了，给apk加了一层壳，但程序最终是要把真dex文件写入内存中，在写的时候dump一份内存，就好了。
提供几篇破壳博客。
破解360加固的
https://blog.csdn.net/jiangwei0910410003/article/details/78548069
破解棒棒加固的
https://blog.csdn.net/jiangwei0910410003/article/details/54409957
三、 反混淆
关于反混淆这个，android至少3到 5年工作经验才能挑战，因为这个太考验个人能力了，包括思维以及解决问题的能力。
先说思路。首先是还原项目，虽然代码混淆了，面目全非，但是代码还是可以运行的。所以我们需要先还原android项目，工具就是androidstudio编辑器。挑拣破解后的代码（为啥是挑拣呢，因为破解后好多第三方的代码都会先显示，在项目中加入过多第三方的代码，徒增破解难度，还是得凭借经验去挑拣代码），放入项目工程中，该引用的添加第三方库的引用，android项目环境配置，保证不报错。然后在模拟器或者手机上一点一点调试 代码，然后做注释，用快捷键修改变量名，类名以及方法名。最终代码就变成易读的android工程了。 然后就可以自己增删改了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ba23bd6b986c4c54952d6b736728201/" rel="bookmark">
			TensorFlow学习- GPU显存占满而利用率（util）很低原因&amp;提高方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2080的显卡，跑YOLOv3，显存已经满了，显卡利用率却只有7%
百度了一圈，看到几篇比较靠谱的博客，直接贴链接
参考1：
TensorFlow如何提高GPU训练效率和利用率
分析显卡利用率低的原因是每个训练过程中有些进程是在CPU中执行的，像load下个batch、预处理batch、打印日志、后处理等，并且有的任务cpu和GPU是交替执行的，进一步降低了GPU利用率。
提出了四个方式提高利用率：
1、把代码都用tf的API重写；
2、使用Estimator把大部分代码写进计算图
3、使用th.data预处理数据集，并用tf.records存储
4、用prefetch、parallel mapping使样本并行处理，不让gpu闲着
由于是新手具体的操作过程哈没看懂，详细直接看原文。
参考2：
实验中GPU利用率低的可能的原因：
作者进行试验分析出来是日志的问题，把关于权重和偏差值记录的代码注释掉之后利用率提高了。原因和上一篇差不多。
参考3：
GPU Memory Usage占满而GPU-Util却为0的调试
作者的CPU全满，GPU却是0
通过阅读官方文档分析出原因是 GPU不能计算 float64，算的话就很慢
然后根据文档建议，使用config和warn_float64帮助找到float64的输入；之后试图设定一个cast_policy参数，自动把numpy产生的数组转换成float32失败；最后检查所有numpy调用，全部手动制定dtype=numpy.float32，执行一下某个命令，成功!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d3bcd300913b2b6b9f4e4f39ebba49f/" rel="bookmark">
			MySql表分区的创建与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建表分区 MySql默认是支持表分区的，可以通过语句查询是否开启表分区功能：show plugins ；
创建表分区只需要在创建表的语句后面加上分区语句就可以，例如：
create table user(id int(11) not null,name varchar(32) not null) --正常的创建语句 partition by range(id) --根据表字段id来创建分区 ( partition p0 values less than(10), --第一个分区p0，范围~-9 partition p1 values less than(20), --第二个分区p1，范围10-19 partition p2 values less than(30), --第三个分区p2，范围20-29 partition p3 values less than maxvalue --第四个分区p2，范围30-~ ) --需要注意的是分区字段“id”的取值范围等于分区取值范围 数据存储文件将根据分区被拆分成多份：*.ibd , .frm文件是表格式文件：
新增几条数据后查询可以看到数据已经分散在不同的分区中：
二、表分区的类型 1、RANGE表分区：范围表分区，按照一定的范围值来确定每个分区包含的数据，如上使用的就是range表分区；
partition by range(id) partition p0 values less than()
分区函数使用的字段必须是整数类型（bit, int ,tinyint,bigint等），分区的定义范围必须是连续的，且不能重叠，使用values less than()来定义分区范围，从小到大定义范围。
给分区字段赋值的时候分区字段取值范围不能超过values less than()的取值范围。使用values less than maxvalue来将未来不确定的值放到这个表分区中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d3bcd300913b2b6b9f4e4f39ebba49f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f29de5bfe41b063c2d4c8b010b8f606/" rel="bookmark">
			Python struct使用简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/usr/bin/python # -*- coding: utf-8 -*- # @version: v1.0 # @author: payne fu # @email: bbccaaac@163.com # @file name: test.py # @created time: 2019/11/20 14:31 import struct import struct # 详细使用方法：https://docs.python.org/3.7/library/struct.html?highlight=struct#struct.pack hex_str = "1672824A4925" print(bytes.fromhex(hex_str)) # No padding is added when using non-native size and alignment, e.g. with ‘&lt;’, ‘&gt;’, ‘=’, and ‘!’. # 如：下例会返回8，虽然h占2字节，i占4字节，但由于默认用的native size，所以h会被填充2字节来对齐 print(struct.calcsize('hi')) # 如：下例会返回6，没有填充，=表示非native size print(struct.calcsize('=hi')) # 下面会报错，因为参数2只有6字节 # struct.error: unpack requires a buffer of 8 bytes # print(struct.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f29de5bfe41b063c2d4c8b010b8f606/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/387/">«</a>
	<span class="pagination__item pagination__item--current">388/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/389/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>