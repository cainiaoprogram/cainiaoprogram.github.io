<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f83df51942261105c32f0c1389f80d5/" rel="bookmark">
			select2的基本用法  allowClear
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select2的基本用法 --select2
https://select2.org/
https://select2.org/data-sources/ajax
公司有个项目需要用到类似百度搜索功能的下拉框，自然想到使用select2。
先看下select2的效果图，如下：
下来简单介绍下这个控件的基本用法，主要简单介绍下远程加载数据；
1.首先引入需要的文件:select2.full.js、select2.min.css（4.0.1版本）和jquery.1.8.3及以上.
2.远程加载数据示例
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
$("#simple").select2({
ajax: {
url: 'Handler1.ashx',
dataType: "json",
delay: 250,
data: function (params) {
return {
q: params.term
};
},
processResults: function (data) {
return {
results: data
};
},
cache: true
},
escapeMarkup: function (markup) { return markup; },
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f83df51942261105c32f0c1389f80d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/838d75533dffb0a6074d3f33383ea69b/" rel="bookmark">
			三年Java后端裸辞跳槽面试，却被面试官吊打
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前已经是疫情后面试跳槽阶段，相信有不少程序员蠢蠢欲动，开始出去试试水，想要跳槽涨薪了！有一个朋友就想改变现状，于是找了大量网上的面试题，强行记下之后，开始出去“试水”。
他试水之后回来和我聊天，他目前是在一家传统企业做后端Java开发的，有3年的工作经验，理想是成为一名高级架构师；但是他现在的阶段感觉就是有点尴尬，掌握技术不是很扎实，说懂也啥都会一些；
于是想跳槽换个高薪工作，结果面试官都问了他一些什么源码、算法结构，什么分布式架构，什么性能调优、并发编程之类的东西，虽然看过，但是平时用不着，看了也忘记了，让他讲下原理却回答不上来，结果面试官说他基础太差……
在看过他的简历之后，我建议一些跟他情况类似的朋友，想要往架构师或TL的方向发展的话，那或许你可以看一下我分享给你的这份进阶路线图，主要针对1到5年及以上的Java开发人员，里面的技术包涵了高并发、分布式、微服务、源码分析、高性能等技术，这些也是目前中大型互联网企业比较常用的技术，那么来详细看看。
那么以上专题内容该怎么学习？
为了大家能够顺利进阶中高级、架构师，我特地为大家准备了一套精品Java架构师教程+BAT面试合集，适合1-5年内Java开发人员，希望你学了以后吊打面试官，薪资上升一个台阶。
话不多说直接上干货：
部分资料展示：
资料免费领取方式：点击这儿 找管理小姐姐免费获取！
以上资料如何获得？ 资料免费领取方式：点击这儿 找管理小姐姐免费获取！
最后，祝愿即将跳槽和已经开始求职的大家都能找到一份好的工作！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b0a151243ebb49d37a0a7385268ef11/" rel="bookmark">
			allegro一键换层快捷命令设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		allegro一键换层的快捷键设置,亲测好用,本人从网上找了N久才总结出来的,希望对各位攻城狮有所帮助,需要的自己下载吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ac47834cde8e5b1e241d534a54729db/" rel="bookmark">
			shell-if语句详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		if 条件
then
Command
else
Command
fi 别忘了这个结尾If语句忘了结尾fi
test.sh: line 14: syntax error: unexpected end of fi if 的三种条件表达式
if
command
then
if
函数
then 命令执行成功，等于返回0 （比如grep ,找到匹配）
执行失败，返回非0 （grep,没找到匹配）if [ expression_r_r_r ]
then 表达式结果为真，则返回0，if把0值引向thenif test expression_r_r_r
then 表达式结果为假，则返回非0，if把非0值引向then [ ] &amp;&amp; ——快捷if
[ -f "/etc/shadow" ] &amp;&amp; echo "This computer uses shadow passwors" &amp;&amp; 可以理解为then
如果左边的表达式为真则执行右边的语句 shell的if与c语言if的功能上的区别
shell if c语言if0为真，走then 正好相反，非0走then 不支持整数变量直接if
必须:if [ i –ne 0 ]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ac47834cde8e5b1e241d534a54729db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34bac1346a041256ae888631f80b9bf4/" rel="bookmark">
			flex&#43;bison运行测试一个小例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要测试运行实例的话，前提是保证配好环境变量。环境变量具体配置通过查阅其他博客完成了，接下来演示如何查看是否配置成功：
①进入cmd，输入flex --version
②输入bison --version
我使用codeblocks进行后面的编译，所以先对codeblocks进行一些配置。进入cb：设置-&gt;编译器
点击右边的小三角，拖到最右边：
进入高级选项，会弹出一个确认框，确认：
对.l进行配置：在Source ext.的下拉框中选择l,表示将针对flex文件进行配置，宏命令行下面的编辑框中会显示利用flex命令对.l文件进行处理的命令行（命令及命令参数）。由于CodeBlocks使用的是移植自Linux的MinGW，所以其缺省的命令还是Linux下使用flex的命令。现在我们需要更新为：win_flex -o$file_dir/$file_name.flex.cpp --wincompat $file，其中“$file_dir/$file_name.flex.cpp”是要生成的cpp文件的目录+文件名称。你可以根据你的需要选择由flex生成的文件是什么名字。相应的在Generated files的编辑框中同样修改为“$file_dir/$file_name.flex.cpp”，和前面的生成一致，这样能够让CodeBlocks找到生成的文件进行编译处理。这样.l的配置就完成了:
对.y进行配置：同样在Source ext.的下拉菜单中选择y，进入.y文件的相关配置中，替换原来的配置项为：
win_bison --output=$file_dir/$file_name.tab.cpp --defines=$file_dir/$file_name.tab.h $file(具体可以参考win_bison的帮助，通过win_bison --help）。相应Generate files也修改为$file_dir/$file_name.tab.cpp 和$file_dir/$file_name.tab.h。点击OK即完成配置，这样就可以添加.y和.l到你的工程中了。要记得去重启cb！
接下来进入自己创建好的文件夹中，复制路径，cmd进入命令行，cd 自己的路径，输入type nul&gt;hello.l创建一个hello.l文件：
发现文件夹中生成了文件：
右击以记事本方式打开，然后把lex代码写进去，保存：（注意这里面有.l与.y文件，要分开创建）
hello.l %{ #include &lt;stdlib.h&gt; #include "y.tab.h" %} %% ("hi"|"oi")"\n" { return HI; } ("tchau"|"bye")"\n" { return BYE; } . { yyerror(); } %% int main(void) { yyparse(); return 0; } int yywrap(void) { return 0; } int yyerror(void) { printf("Error\n"); exit(1); } hello.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34bac1346a041256ae888631f80b9bf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8e8c94357962b0ecff4d7380e7b9427/" rel="bookmark">
			NLP 中的Mask全解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Mask的作用处理非定长序列RNN中的MaskAttention中Mask防止标签泄露Transformer中的MaskBERT中的MaskXLNet中的Mask 转载来源：https://zhuanlan.zhihu.com/p/139595546 Mask 在NLP中是一个很常规的操作，也有多种应用的场景和形式，下面尝试从以下几个方面去全（用了夸张的修辞手法）解Mask，并尽可能地辅以图片说明和代码解释： Mask的作用： 处理非定长序列 RNN中的MaskAttention中Mask 防止标签泄露 Transformer中的MaskBERT中的MaskXLNet中的Mask Mask的作用 对于NLP中mask的作用，先上结论：
1、padding mask：处理非定长序列，区分padding和非padding部分，如在RNN等模型和Attention机制中的应用等
2、sequence mask：防止标签泄露，如：Transformer decoder中的mask矩阵，BERT中的[Mask]位，XLNet中的mask矩阵等
PS：padding mask 和 sequence mask非官方命名
处理非定长序列 在NLP中，文本一般是不定长的，所以在进行 batch训练之前，要先进行长度的统一，过长的句子可以通过truncating 截断到固定的长度，过短的句子可以通过 padding 增加到固定的长度，但是 padding 对应的字符只是为了统一长度，并没有实际的价值，因此希望在之后的计算中屏蔽它们，这时候就需要 Mask。
图片参考
上图为中文场景下，一个 batch=5 的，以字为单位的输入矩阵（也可以在分词后以词为单位）和 mask 矩阵，左图已经将文本 padding 到统一长度了，右图中的1表示有效字，0代表无效字。
RNN中的Mask 对于RNN等模型，本身是可以直接处理不定长数据的，因此它不需要提前告知 sequence length，如下是pytorch下的LSTM定义：
nn.LSTM(input_size, hidden_size, *args, **kwargs) 但是在实践中，为了 batch 训练，一般会把不定长的序列 padding 到相同长度，再用 mask 去区分非 padding 部分和 padding 部分。
区分的目的是使得RNN只作用到它实际长度的句子，而不会处理无用的 padding 部分，这样RNN的输出和隐状态都会是对应句子实际的最后一位。另外，对于token级别的任务，也可以通过mask去忽略 padding 部分对应的loss。
不过，在 pytorch 中，对 mask 的具体实现形式不是mask矩阵，而是通过一个句子长度列表来实现的，但本质一样。实现如下，sentence_lens 表示的是这个batch中每一个句子的实际长度。参考
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8e8c94357962b0ecff4d7380e7b9427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f175d4d76eb9940460eb389aaac66320/" rel="bookmark">
			使用Python和Numpy进行波士顿房价预测任务（二）【深度学习入门_学习笔记】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Python和Numpy进行波士顿房价预测任务–详解
目录：
一、数据处理
（1）读入数据
（2）数据形状变换
（3）数据集划分
（4）数据归一化处理
（5）封装成load data函数 二、模型设计
三、训练配置
四、训练过程
（1）梯度下降法
- 使用Numpy进行梯度计算
（2）确定损失函数更小的点
（3）随机梯度下降法
波士顿房价预测是一个经典的机器学习任务，类似于程序员世界的“Hello World”。和大家对房价的普遍认知相同，波士顿地区的房价是由诸多因素影响的。
下载数据集：https://archive.ics.uci.edu/ml/machine-learning-databases/housing/housing.data
该数据集统计了13种可能影响房价的因素和该类型房屋的均价，期望构建一个基于13个因素进行房价预测的模型，如图所示。
对于预测问题，可以根据预测输出的类型是连续的实数值，还是离散的标签，区分为回归任务和分类任务。因为房价是一个连续值，所以房价预测显然是一个回归任务。下面我们尝试用最简单的线性回归模型解决这个问题，并用神经网络来实现这个模型。
线性回归模型
假设房价和各影响因素之间能够用线性关系来描述：
模型的求解即是通过数据拟合出每个wj和b。其中，wj和b分别表示该线性模型的权重和偏置。一维情况下，wj和 b 是直线的斜率和截距。
线性回归模型使用均方误差作为损失函数（Loss），用以衡量预测房价和真实房价的差异，公式如下：
线性回归模型的神经网络结构
神经网络的标准结构中每个神经元由加权和与非线性变换构成，然后将多个神经元分层的摆放并连接形成神经网络。线性回归模型可以认为是神经网络模型的一种极简特例，是一个只有加权和、没有非线性变换的神经元（无需形成网络），如图所示。
构建波士顿房价预测任务的神经网络模型
深度学习不仅实现了实现模型的端到端学习，还推动了人工智能进入工业大生产阶段，产生了标准化、自动化和模块化的通用框架。不同场景的深度学习模型具具备一定的通用性，五个步骤即可完成模型的构建和训练，如图所示。
正是由于深度学习的建模和训练的过程存在通用性，在构建不同的模型时，只有模型三要素不同，其它步骤基本一致，深度学习框架才有用武之地。
一、数据处理 数据处理包含五个部分：数据导入、数据形状变换、数据集划分、数据归一化处理和封装load data函数。数据预处理后，才能被模型调用。
（1）读入数据 通过如下代码读入数据，了解下波士顿房价的数据集结构，数据存放在本地目录下housing.data文件中。
# 导入需要用到的package import numpy as np import json # 读入训练数据 datafile = './housing.data' #注：定位到存放数据目录 data = np.fromfile(datafile, sep=' ') data array([6.320e-03, 1.800e+01, 2.310e+00, …, 3.969e+02, 7.880e+00,1.190e+01])
（2）数据形状变换 由于读入的原始数据是1维的，所有数据都连在一起。因此需要我们将数据的形状进行变换，形成一个2维的矩阵，每行为一个数据样本（14个值），每个数据样本包含13个X（影响房价的特征）和一个Y（该类型房屋的均价）。
# 读入之后的数据被转化成1维array，其中array的第0-13项是第一条数据，第14-27项是第二条数据，以此类推.... # 这里对原始数据做reshape，变成N x 14的形式 feature_names = [ 'CRIM', 'ZN', 'INDUS', 'CHAS', 'NOX', 'RM', 'AGE','DIS', 'RAD', 'TAX', 'PTRATIO', 'B', 'LSTAT', 'MEDV' ] feature_num = len(feature_names) data = data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f175d4d76eb9940460eb389aaac66320/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65f63e77dfcf522a86da078dd25d5a0e/" rel="bookmark">
			在Ubuntu 20.04中安装ROS2最新版本Foxy Fitzroy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ROS2 是新一代机器人操作系统。2020年6月5日，ROS2 的最新版本 Foxy Fitzroy 正式发布了， 支持到2023年的3月！
ROS2 支持的平台 Linux (Ubuntu Focal(20.04))macOSWindows ROS2 真正是跨平台了，ROS1 只支持 Linux。
有大神说，不要搞 ROS1 了，直接上 ROS2 ~~
安装ROS2 我们按照 官方的文档 在 Ubuntu 20.04中安装 ROS2 Foxy Fitzroy：
Setup Locale 确保系统要支持 UTF-8:
sudo locale-gen en_US en_US.UTF-8 sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 export LANG=en_US.UTF-8 Setup Sources 添加ROS2的源：
sudo apt update sudo apt install curl gnupg2 lsb-release # 下面这条语句，我的输出错误： gpg: no valid OpenPGP data found # curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add - # 解决上面的问题，可以换成下面这条语句： $ curl http://repo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65f63e77dfcf522a86da078dd25d5a0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d29005a4e4b8ba9f4646555f5c68d402/" rel="bookmark">
			Ignite和SpringBoot整合时出现Failed to initialize system DB connection......MULTI_THREADED问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 计网实验需要使用SpringBoot+Ignite+JWT完成一个登录并存储用户权限的功能。
前期准备 在github上找了一个源码仓库：Spring Boot整合JWT实现用户认证。和我的需求十分接近，遂下载下来准备在其基础上二次开发。但是其由于是两年前的仓库，一些依赖包的版本到今天已经更新了不少。于是我准备将这些依赖包都更新到新版本，同时使用gradle而非原来的maven作为构建工具。
在问题出现时，和Ignite有关的代码如下：
@Configuration public class IgniteCfg { /** * 初始化ignite节点信息 * @return Ignite */ @Bean public Ignite igniteInstance(){ // 配置一个节点的Configuration IgniteConfiguration cfg = new IgniteConfiguration(); // 设置该节点名称 cfg.setIgniteInstanceName("springDataNode"); // 启用Peer类加载器 cfg.setPeerClassLoadingEnabled(true); // 创建一个Cache的配置，名称为PersonCache CacheConfiguration ccfg = new CacheConfiguration("PersonCache"); // 设置这个Cache的键值对模型 ccfg.setIndexedTypes(Long.class, Person.class); // 把这个Cache放入springDataNode这个Node中 cfg.setCacheConfiguration(ccfg); // Ignite persistence configuration. // 创建一个持久化存储的设置 DataStorageConfiguration storageCfg = new DataStorageConfiguration(); // Enabling the persistence. // 是这个设置允许持久化存储 storageCfg.getDefaultDataRegionConfiguration().setPersistenceEnabled(true); // 设置持久化存储路径 storageCfg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d29005a4e4b8ba9f4646555f5c68d402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb26cd91f1efaf4715f99ac4f6866165/" rel="bookmark">
			IDEA命令行缩短器助你解决此问题：Command line is too long. Shorten command line...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生命太短暂，不要去做一些根本没有人想要的东西。
本文已被https://yourbatman.cn收录；女娲Knife-Initializr工程可公开访问啦；程序员专用网盘https://wangpan.yourbatman.cn；公号后台回复“专栏列表”获取全部小而美的原创技术专栏
你好，我是方向盘(YourBatman、方哥)
目录 前言版本约定 正文控制台首行路径首行路径内容 为何启动抛错Command line is too long原因分析IDEA老版本方案IDEA新版本方案：命令行缩短器jar manifest方式classpath file方式 扩展知识：windows系统命令最大长度思考题 总结 前言 最近遇到两个问题，都是关于IDEA的（言外之意和代码无关），很是让我“生气”呀（关键是浪费时间）。在痛定思痛后，我决定写此专栏，来专门分享/记录使用IntelliJ IDEA过程中遇到的那些奇葩问题和解决方案，以帮助你缩短日常排错时间，这么一思考好像还功德无量呢😄。
IntelliJ IDEA作为Java开发者中最为流行的开发工具（eclipse粉勿喷），熟练掌握它（包括排雷）对提升编码效率能有显著提升。但工具毕竟是工具，这么长时间使用IDEA以来，每个人或多或少的都遇到过关于IDEA七七八八、奇奇怪怪的问题，这些与代码舞棍，但它很容易偷走你的时间，半天又更或者是一天之久。
说明：千万不要忽视对IDEA的研究，因为把它玩熟练了它就相当于你的物理外挂
本专栏内容并非 IDEA教程，而是着眼于分享IDEA使用过程中，那些我遇到（或者大家遇到）的但又不是能够很快速解决，总之就是比较棘手的问题的汇总，有一种错题本的意思有木有。总之就是希望它能够帮助到大家迅速定位or解决问题，避免不必要的时间浪费，毕竟咱们的主业还是敲代码嘛~
版本约定 本文内容若没做特殊说明，均基于以下版本：
IntelliJ IDEA：2020.1.2旗舰版 正文 使用IDEA这么久，虽然之前时不时地的跟IDEA问题“交过手”，但真正促使我决定写此专栏的原因还是源自于前两天使用IDEA启动Spring Boot程序时的这个报错：
Error running 'Application': Command line is too long. Shorten command line for Application or also for Spring Boot default configuration. 说实话这个错误我前所未见，看起来还蛮有意思，因此决定研究一番。这不，把研究结果分享给大家，信息共享。
为了解释好这个问题，我们得先来做些功课，知晓写概念。
控制台首行路径 在IDEA里，你每次启动一个main函数时，控制台第一行输出的“日志”称作为：控制台首行路径。这里，我运行一个最最最简单的程序，看看它长啥样，程序如下：
public class Application { public static void main(String[] args) { System.out.println("Hello world"); } } 运行程序，控制台输出如下截图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb26cd91f1efaf4715f99ac4f6866165/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54cbf7794b386407b9ed1e7393870855/" rel="bookmark">
			ansible命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.comand模块 （默认模块）
用于在远程主机(被管理的主机)上执行某个命令
注：A. 不能变量$HOME和操作等"&lt;"，"&gt;"，"|"，";“和”&amp;"
#在默认家目录下创建一个 ansible.txt的文件 [root@cdhnode1 ~]# ansible all -m command -a " touch ansible.txt " #指定切换到/home/zx目录下，再创建一个ansible.txt的文件 [root@cdhnode1 ~]# ansible all -a "chdir=/home/zx touch ansible.txt " [root@cdhnode1 ~]# ansible all -m command -a " creates=/root/ansible.txt touch ansible2.txt " # 当/home/zx/ansible.txt文件存，就执行删除操作 [root@cdhnode1 ~]# ansible all -m command -a " chdir=/home/zx removes=ansible.txt rm ansible.txt " 2.copy模块
把管理端的数据分发到被管理端服务器上
[root@cdhnode1 ~]# ansible all -m copy -a "src=/root/test.txt dest=/root/ " [root@cdhnode1 ~]# ansible all -m copy -a "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54cbf7794b386407b9ed1e7393870855/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b936ca871f0887059c5a56813ebe3729/" rel="bookmark">
			网页上的文本不让你复制下载？老司机教你几招，轻松免费复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python实战社群
Java实战社群
长按识别下方二维码，按需求添加
扫码关注添加客服
进Python社群▲
扫码关注添加客服
进Java社群▲
作者丨Caesar
来源丨手机电脑双黑客（heikestudio）
无论是在工作中还是在学习中，大家都会遇到网页上的文本无法复制粘贴的情况，然后只能硬着头皮将里面的内容一个个的用键盘敲出来，其实这些被限制的网页时可以复制的，今天就教你几招，让你轻松免费复制。
一、手机端
如果是用手机浏览网页的话，复制起来也比较方便。
1、百度文库复制
如果你需要复制的文本正好在百度文库中，这样就非常好办了，打开这个网页之后，你可以看看右上角有没有【原版】两个字，有的话就点进去，里面的文字都是可以复制粘贴的，对着文字长按2秒，就可以选择文字进行复制了。
2、图片识别文字
如果你浏览的网页右上角没有【原版】两个字，也不可以进行复制粘贴，就用【迅捷PDF转换器】中的【图片识别文字】功能，直接将网页上的文字截图，在手机上打开这个APP，找到图片识别文字功能，点击它并且上传截图，文字就会被提取出来，都是排版好的，用起来也方便。
二、电脑端
办公的时候只用电脑来浏览网页，那么用电脑怎么复制网页里面的文字呢？
1、打印网页
这个方法很简单，也是非常快速的一种方法，选中需要复制的文字，尽量选多一点，然后右键选择【打印】，这时候打印框内就会出现文字的内容，用鼠标选中文字按下【Ctrl+C】进行复制并粘贴就可以了。
2、查看网页源代码
这个方法也是比较方便的，在空白的地方右键点击【查看网页源代码】，进入代码之后，往下滑找到你需要的内容，选中进行复制就可以了。
以上就是小编整理出来的网页复制方法，这些方法亲测过确实是有效的，也希望能够帮到大家，如果你们还知道哪些好用的复制方法，不妨分享出来，大家一起学习学习。
声明：本人分享该教程是希望大家，通过这个教程了解信息安全并提高警惕！本教程仅限于教学使用，不得用于其他用途触犯法律，本人一概不负责，请知悉！
免责声明：本文旨在传递更多市场信息，不构成任何投资建议和其他非法用途。文章仅代表作者观点，不代表手机电脑双黑客立场。以上文章之对于正确的用途，仅适用于学习
程序员专栏 扫码关注填加客服 长按识别下方二维码进群 近期精彩内容推荐： 再见！程序员！！！ 微信号 可以改了 ！！！真事 ！！ 2020 常用的 7 款 MySQL 客户端工具 别再问我Redis内存满了该怎么办了 在看点这里好文分享给更多人↓↓ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4860d4fdc10d7b98a0effdecfc661134/" rel="bookmark">
			单调递增最长子序列问题（动态规划）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 具体描述如下
设计一个O(n2)时间的算法，找出由n个数组成的序列的最长单调递增子序列。
输入格式:
输入有两行： 第一行：n，代表要输入的数列的个数 第二行：n个数，数字之间用空格格开
输出格式:
最长单调递增子序列的长度
输入样例:
在这里给出一组输入。例如：
5
1 3 5 2 9
输出样例:
在这里给出相应的输出。例如：
4
解析：
这道题考虑用动态规划的方法来求解，可以考虑用dp[i]表示以第i个数字结尾的最长子序列长度，那个以第i+1个结尾的最长子序列应该怎么找呢？我们就需要从第1个数字到第i个数字遍历一遍，把数字小于第i+1并且它的dp值最大的那个(用语言描述就是a[x]&lt;a[i+1]&amp;&amp;dp[x]&gt;dp[i+1])，加入找到的是第x个数字，那么dp[i+1]就是dp[x]+1。大体的思路就是酱，具体代码如下
#include&lt;iostream&gt; using namespace std; int main(){ int n,a[1000]; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; int dp[1000]={0},max=1,t; dp[1]=1;//第一个数字的最优解就是1，先赋值 for(int i=2;i&lt;=n;i++){//i从2开始到n遍历，用dp[i]表示以i结尾的最优解 t=0;//每次都要置零，很关键 for(int j=i-1;j&gt;0;j--){ if(a[i]&gt;a[j]&amp;&amp;dp[j]&gt;t){ t=dp[j];//把符合条件的值暂时保存在t中 } } dp[i]=dp[i]+t+1;//这时更新dp[i] if(dp[i]&gt;max) max=dp[i]; } cout&lt;&lt;max&lt;&lt;endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0a720086e46b773d94d5cede6e7e52f/" rel="bookmark">
			用Tkinter打造GUI开发工具（41）Tkinter窗口中嵌套其他应用程序窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Tkinter打造GUI开发工具（41）Tkinter窗口中嵌套其他应用程序窗口
上一篇我们介绍了Tkinter中的真多子窗口设计，如果我们想增加外部的一个Toplevel子窗口，能够套入主窗口中吗？用HP_mtk2当然可以的。
我们甚至能把cmd窗口，股票软件都嵌套到tkinter主窗口中。
下面直接给出代码。
import tkinter as tk import HP_mtk2 as hmtk root = hmtk.MainWindows(picture='img/bj2.jpg') root.geometry('800x600+200+100') root.title('主窗口') w1=root.newsubwin() lb=tk.Label(w1,text='标签') lb.pack(side=tk.TOP) bt=tk.Button(w1,text='按钮') bt.pack() top=tk.Toplevel(root) top.title('外部窗口1') top.geometry('200x100+100+100') root.update() mywin=hmtk.mywindowid() xw=mywin.findwin('外部窗口1') mywin.set_parent(xw['hwnd'],root.myw) xw2=mywin.findwin('cmd') mywin.set_parent(xw2['hwnd'],root.myw) xw3=mywin.findwin('Jupyter') mywin.set_parent(xw3['hwnd'],root.myw) xw4=mywin.findwin('大智慧') mywin.set_parent(xw4['hwnd'],root.myw) root.update() root.mainloop() 看看程序执行结果如下图。
Python 再带的Tkinter GUI库是不是很强大？
#独狼荷蒲qq:2775205
#通通小白python量化群:524949939
#电话微信:18578755056
#通通小白python量化群:524949939
#tkinter,pyqt,gui,Python学习群：647866213
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0af46705ec2ade689babd434dbfd3fbb/" rel="bookmark">
			Java多线程之----主线程会等待子线程结束再结束么，怎么让主线程等待子线程结束呐？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先给出结论：
主线程和子线程之间没有谁先谁后结束这种关联，它们只是各自负责自己的线程任务，如果该线程的任务结束了，该线程自然会结束运行。
talk is cheap,show me the code and the result
1.先来一个好理解的： 下面这个例子中，由于子线程循环了100次，干的活多，走的慢，所以结束的晚。可以看到执行结果，主线程结束后，子线程稍等了一会才结束执行，并没有主线程需要等待子线程结束的情况。
主线程的任务：
1.thread.start 开启子线程
2.System.out.println(Thread.currentThread().getName()+“结束了 ，这是main干的活”); 输出语句
子线程的任务：
for (int i = 0; i &lt; 100; i++) { if (i==99){ System.out.println("我现在是99，这是子线程干的活"); } } //循环100次，并输出语句 也就是说，谁先完成任务，谁就会先运行结束。
public class ThreadOne { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i &lt; 100; i++) { if (i==99){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0af46705ec2ade689babd434dbfd3fbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47361c094e54747db49fcb1c30bacae1/" rel="bookmark">
			SKlearn学习笔记——神经网络概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SKlearn学习笔记——神经网络概述 1 打开深度学习的大门:神经网络概述1.1 打开深度学习的大门1.2 神经网络的基本原理1.3 sklearn中的神经网络 2 neural_network.MLPClassifier2.1 隐藏层与神经元:重要参数hidden_layer_sizes2.2 激活函数:重要参数activation2.3 反向传播与梯度下降 前言： scikit-learn，又写作sklearn，是一个开源的基于python语言的机器学习工具包。它通过NumPy, SciPy和Matplotlib等python数值计算的库实现高效的算法应用，并且涵盖了几乎所有主流机器学习算法。
以下内容整理自 菜菜的机器学习课堂.
sklearn官网链接: 点击这里.
1 打开深度学习的大门:神经网络概述 1.1 打开深度学习的大门 人工神经网络(Artificial Neural Network，ANN)，通常简称为神经网络，是深度学习的基础，它是受到人类大脑 结构启发而诞生的一种算法。神经学家们发现，人类大脑主要由称为神经元的神经细胞组成，通过名为轴突的纤维束 与其他神经元连接在一起。每当神经元从其他的神经元接受到信号，神经元便会受到刺激，此时纤维束会将信号从一 个神经元传递到另一个神经元上。人类正是通过相同的冲动反复地刺激神经元，改变神经元之间的链接的强度来进行 学习。
这其实和我们在过去十二周内经历的机器学习过程非常类似。在机器学习中，我们建模，将特征矩阵输入模型中，然 后算法为我们输出预测结果。只不过在人脑中，数以亿计的神经细胞相互链接来构建一个生物神经网络(一个神经细 胞当然可以和众多个神经细胞相连)，我们的机器学习中，往往只有一个模型或者一种算法在运行。人脑通过构建复 杂的网络可以进行逻辑，语言，情感的学习，相信模拟这种结构的机器也可以有很强大的学习能力，于是人工神经网 络应运而生。
神经网络算法试图模拟生物神经系统的学习过程，以此实现强大的预测性能。不过由于是模仿人类大脑，所以神经网 络的模型复杂度很高也是众所周知。在现实应用中，神经网络可以说是解释性最差的模型之一，商业环境中很少使用 神经网络。然而出了商业分析，还有许多算法应用的部分，其中最重要的是深度学习和人工智能的领域，现在大部分 已经成熟的人工智能技术:图像识别，语音识别等等，背后都是基于神经网络的深度学习算法。因此，作为机器学习 中(可能是)最复杂的，深度学习中基础的算法，神经网络的了解和学习是很有必要的。
1.2 神经网络的基本原理 注意，在这个过程中，有两个非常重要的核心要点:
每个输入的特征会被匹配到一个参数 w ，我们都知道参数向量 中含有的参数数量与我们的特征数目是一致的， 在感知机中也是如此。也就是说，任何基于感知机的算法，必须至少要有参数向量 w 可求。一个线性关系 z ，z 是由参数和输入的数据共同决定的。这个线性关系，往往就是我们的决策边界，或者它也可 以是多元线性回归，逻辑回归等算法的线性表达式激活函数的结果，是基于激活函数本身，参数向量 w 和输入的数据一同计算出来的。也就是说，任何基于感知机的算法，必须要存在一个激活函数。 神经网络就相当于众多感知机的集成，因此，确定激活函数，并找出参数向量 也是神 经网络的计算核心。只不过对 于只运行一次激活函数的感知机来说，神经网络大大增加了的模型的复杂度，激活函数在这个过程中可能被激活非常 多次，参数向量的数量也呈指数级增长。我们来看看神经网络的基本结构:
首先，神经网络有三层。第一层叫做输入层(Input layer)，输入特征矩阵用，因此每个神经元上都是一个特征向 量。极端情况下，如果一个神经网络只训练一个样本，则每个输入层的神经元上都是这个样本的一个特征取值。
最后一层叫做输出层(output layer)，输出预测标签用。如果是回归类，一般输出层只有一个神经元，回归的是所 有输入的样本的标签向量。如果是分类，可能会有多个神经元。二分类有两个神经元，多分类有多个神经元，分别输 出所有输入的样本对应的每个标签分类下的概率。但无论如何，输出层只有一层，是用于输出预测结果用。
输入层和输出层中间的所有层，叫做隐藏层(Hidden layers)，最少一层。也就是说整个神经网络是最少三层。隐 藏层是我们用来让算法学习的网络层级，从更靠近输入层的地方开始叫做"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47361c094e54747db49fcb1c30bacae1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26d6f094c80f18c1b7b69a98e285f043/" rel="bookmark">
			傅里叶变换在图像处理中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基本概念
超详细的图像中傅里叶理解及常用模板
请参考：https://blog.csdn.net/m0_37264397/article/details/70186390
应用一：使用C++、opencv对图像进行傅里叶变换，再根据频谱图对原图进行旋转
频谱图分析测试案例
如何利用numpy和opencv实现图像频谱分析案例
基本概念 傅立叶变换在图像处理中有非常非常的作用。因为不仅傅立叶分析涉及图像处理的很多方面，傅立叶的改进算法，
比如离散余弦变换，gabor与小波在图像处理中也有重要的分量。
印象中，傅立叶变换在图像处理以下几个话题都有重要作用：
1.图像增强与图像去噪
绝大部分噪音都是图像的高频分量，通过低通滤波器来滤除高频——噪声; 边缘也是图像的高频分量，可以通过添加高频分量来增强原始图像的边缘；
2.图像分割之边缘检测
提取图像高频分量
3.图像特征提取：
形状特征：傅里叶描述子
纹理特征：直接通过傅里叶系数来计算纹理特征
其他特征：将提取的特征值进行傅里叶变换来使特征具有平移、伸缩、旋转不变性
4.图像压缩
可以直接通过傅里叶系数来压缩数据；常用的离散余弦变换是傅立叶变换的实变换；
傅立叶变换
傅里叶变换是将时域信号分解为不同频率的正弦信号或余弦函数叠加之和。连续情况下要求原始信号在一个周期内满足绝对可积条件。离散情况下，傅里叶变换一定存在。冈萨雷斯版&lt;图像处理&gt;里面的解释非常形象：一个恰当的比喻是将傅里叶变换比作一个玻璃棱镜。棱镜是可以将光分解为不同颜色的物理仪器，每个成分的颜色由波长（或频率）来决定。傅里叶变换可以看作是数学上的棱镜，将函数基于频率分解为不同的成分。当我们考虑光时,讨论它的光谱或频率谱。同样,傅立叶变换使我们能通过频率成分来分析一个函数。
傅立叶变换有很多优良的性质。比如线性，对称性（可以用在计算信号的傅里叶变换里面）;
时移性：函数在时域中的时移，对应于其在频率域中附加产生的相移，而幅度频谱则保持不变；
频移性：函数在时域中乘以e^jwt，可以使整个频谱搬移w。这个也叫调制定理，通讯里面信号的频分复用需要用到这个特性（将不同的信号调制到不同的频段上同时传输）；
卷积定理：时域卷积等于频域乘积；时域乘积等于频域卷积（附加一个系数）。（图像处理里面这个是个重点）
信号在频率域的表现
在频域中，频率越大说明原始信号变化速度越快；频率越小说明原始信号越平缓。当频率为0时，表示直流信号，没有变化。因此，频率的大小反应了信号的变化快慢。高频分量解释信号的突变部分，而低频分量决定信号的整体形象。
在图像处理中，频域反应了图像在空域灰度变化剧烈程度，也就是图像灰度的变化速度，也就是图像的梯度大小。对图像而言，图像的边缘部分是突变部分，变化较快，因此反应在频域上是高频分量；图像的噪声大部分情况下是高频部分；图像平缓变化部分则为低频分量。也就是说，傅立叶变换提供另外一个角度来观察图像，可以将图像从灰度分布转化到频率分布上来观察图像的特征。书面一点说就是，傅里叶变换提供了一条从空域到频率自由转换的途径。对图像处理而言，以下概念非常的重要：
图像高频分量：图像突变部分；在某些情况下指图像边缘信息，某些情况下指噪声，更多是两者的混合；
低频分量：图像变化平缓的部分，也就是图像轮廓信息
高通滤波器：让图像使低频分量抑制，高频分量通过
低通滤波器：与高通相反，让图像使高频分量抑制，低频分量通过
带通滤波器：使图像在某一部分的频率信息通过，其他过低或过高都抑制
还有个带阻滤波器，是带通的反。
模板运算与卷积定理
在时域内做模板运算，实际上就是对图像进行卷积。模板运算是图像处理一个很重要的处理过程，很多图像处理过程，比如增强/去噪（这两个分不清楚），边缘检测中普遍用到。根据卷积定理，时域卷积等价与频域乘积。因此，在时域内对图像做模板运算就等效于在频域内对图像做滤波处理。
比如说一个均值模板，其频域响应为一个低通滤波器；在时域内对图像作均值滤波就等效于在频域内对图像用均值模板的频域响应对图像的频域响应作一个低通滤波。
图像去噪
图像去噪就是压制图像的噪音部分。因此，如果噪音是高频额，从频域的角度来看，就是需要用一个低通滤波器对图像进行处理。通过低通滤波器可以抑制图像的高频分量。但是这种情况下常常会造成边缘信息的抑制。常见的去噪模板有均值模板，高斯模板等。这两种滤波器都是在局部区域抑制图像的高频分量，模糊图像边缘的同时也抑制了噪声。还有一种非线性滤波-中值滤波器。中值滤波器对脉冲型噪声有很好的去掉。因为脉冲点都是突变的点，排序以后输出中值，那么那些最大点和最小点就可以去掉了。中值滤波对高斯噪音效果较差。
椒盐噪声：对于椒盐采用中值滤波可以很好的去除。用均值也可以取得一定的效果，但是会引起边缘的模糊。
高斯白噪声：白噪音在整个频域的都有分布，好像比较困难。
冈萨雷斯版图像处理P185：算术均值滤波器和几何均值滤波器（尤其是后者）更适合于处理高斯或者均匀的随机噪声。谐波均值滤波器更适合于处理脉冲噪声。
图像增强
有时候感觉图像增强与图像去噪是一对矛盾的过程，图像增强经常是需要增强图像的边缘，以获得更好的显示效果，这就需要增加图像的高频分量。而图像去噪是为了消除图像的噪音，也就是需要抑制高频分量。有时候这两个又是指类似的事情。比如说，消除噪音的同时图像的显示效果显著的提升了，那么，这时候就是同样的意思了。
常见的图像增强方法有对比度拉伸，直方图均衡化，图像锐化等。前面两个是在空域进行基于像素点的变换，后面一个是在频域处理。我理解的锐化就是直接在图像上加上图像高通滤波后的分量，也就是图像的边缘效果。对比度拉伸和直方图均衡化都是为了提高图像的对比度，也就是使图像看起来差异更明显一些，我想，经过这样的处理以后，图像也应该增强了图像的高频分量，使得图像的细节上差异更大。同时也引入了一些噪音。
参考：https://blog.csdn.net/kofsky/article/details/2955823
超详细的图像中傅里叶理解及常用模板 请参考：https://blog.csdn.net/m0_37264397/article/details/70186390 应用一：使用C++、opencv对图像进行傅里叶变换，再根据频谱图对原图进行旋转 原图像：
转化为频率域的幅度图像：
霍夫直线变换找到的直线：
旋转后图像：
更多请参考：https://blog.csdn.net/Lemon_jay/article/details/89404199 。
频谱图分析测试案例 如果输入二维图像数据，则显示的图像是输入的灰度分布，傅立叶频谱是输入的频率分布，频谱图中心对称。
图像频谱即二维频谱图通过对原图像进行水平和竖直两个方向的所有扫描线处一维傅立叶变换的叠加得到
频谱图中以图中心为圆心，圆的相位对应原图中频率分量的相位，半径对应频率高低，低频半径小，高频半径大，中心为直流分量，某点亮度对应该频率能量高低。
测试案例请参考：
https://blog.csdn.net/yimingsilence/article/details/53010837
https://www.jianshu.com/p/d99dbd691176
如何利用numpy和opencv实现图像频谱分析案例 请参考https://blog.csdn.net/weixin_42555985/article/details/99673096
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5398c757d69a718e8a597be4af306ad/" rel="bookmark">
			ROS中对point_cloud旋转平移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要对扫描出来的点云数据标定，通过旋转平移使得其在一个正确的坐标系上
为了实现绕Z轴旋转并使xoy平面平移，矩阵是这样的
cosa -sina 0 x
sina cosa 0 y
0 0 1 0
0 0 0 1
用到了pcl库
订阅需要旋转和平移的值还有需要标定的point_cloud,发布标定后的point_cloud
#include "ros/ros.h" #include &lt;pcl_ros/point_cloud.h&gt; #include &lt;pcl/point_types.h&gt; #include &lt;boost/foreach.hpp&gt; #include "std_msgs/Float64.h" #include &lt;geometry_msgs/Point.h&gt; //点 消息类型 #include &lt;geometry_msgs/PointStamped.h&gt; //可以在rviz中显示 #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include&lt;std_msgs/String.h&gt; #include&lt;geometry_msgs/QuaternionStamped.h&gt; #include &lt;pcl/registration/icp.h&gt; //ICP配准类相关头文件 using namespace std; typedef pcl::PointCloud&lt;pcl::PointXYZ&gt; PointCloud; pcl::PointCloud&lt;pcl::PointXYZ&gt; pc_v; geometry_msgs::Quaternion cp_v; using namespace Eigen; ros::Publisher c_cloud; void calibration(pcl::PointCloud&lt;pcl::PointXYZ&gt; in_pc,geometry_msgs::Quaternion in_cp){ pcl::PointCloud&lt;pcl::PointXYZ&gt; out_pc; MatrixXf rotate(4,4); rotate &lt;&lt; cos(atan(in_cp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5398c757d69a718e8a597be4af306ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c54965a24235528883526d13355f8daa/" rel="bookmark">
			各种归一化层（BatchNorm、LayerNorm、InstanceNorm、GroupNorm、Weight Standardization）及其Pytorch实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BN，LN，IN，GN，WS 从学术化上解释差异：
BatchNorm：batch方向做归一化，算NHW的均值，对小batchsize效果不好；BN主要缺点是对batchsize的大小比较敏感，由于每次计算均值和方差是在一个batch上，所以如果batchsize太小，则计算的均值、方差不足以代表整个数据分布；
LayerNorm：channel方向做归一化，算CHW的均值，主要对RNN作用明显；
InstanceNorm：一个channel内做归一化，算H*W的均值，用在风格化迁移；因为在图像风格化中，生成结果主要依赖于某个图像实例，所以对整个batch归一化不适合图像风格化中，因而对HW做归一化。可以加速模型收敛，并且保持每个图像实例之间的独立。
GroupNorm：将channel方向分group，然后每个group内做归一化，算(C//G)HW的均值；这样与batchsize无关，不受其约束。
SwitchableNorm：将BN、LN、IN结合，赋予权重，让网络自己去学习归一化层应该使用什么方法。
Weight Standardization：权重标准化，2019年约翰霍普金斯大学研究人员提出。
1、BatchNorm torch.nn.BatchNorm1d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
torch.nn.BatchNorm2d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
torch.nn.BatchNorm3d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
BN图示 参数：
num_features： 来自期望输入的特征数，该期望输入的大小为’batch_size × num_features [× width]’
eps： 为保证数值稳定性（分母不能趋近或取0）,给分母加上的值。默认为1e-5。
momentum： 动态均值和动态方差所使用的动量。默认为0.1。
affine： 布尔值，当设为true，给该层添加可学习的仿射变换参数。
track_running_stats：布尔值，当设为true，记录训练过程中的均值和方差；
实现公式：
大部分深度网络通常都会使用 BN 层去加速训练和帮助模型更好收敛。虽然 BN 层非常实用，但从研究者的角度看，依然有一些非常显眼的缺点。比如（1）我们非常缺乏对于 BN 层成功原因的理解；（2）BN 层仅在 batch size 足够大时才有明显的效果，因此不能用在微批次的训练中。虽然现在已经有专门针对微批次训练设计的归一化方法（GN），但图 1 所示，它很难在大批次训练时媲美 BN 的效果。
2、GroupNorm FAIR 团队的吴育昕和何恺明提出了组归一化（Group Normalization，简称 GN）的方法，GN 将信号通道分成一个个组别，并在每个组别内计算归一化的均值和方差，以进行归一化处理。GN 的计算与批量大小无关，而且在批次大小大幅变化时，精度依然稳定。通常来说，在使用 Batch Normalization（以下将简称 BN）时，采用小批次很难训练一个网络，而对于不使用批次的优化方法来说，效果很难媲美采用大批次BN时的训练结果。当使用 Group Normalization（以下将简称 GN），且 batch size 大小为 1 时，仅需要多写两行代码加入权重标准化方法，就能比肩甚至超越大批次BN时的训练效果。 torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c54965a24235528883526d13355f8daa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee39b15fdeb295e903bac091f6d5852/" rel="bookmark">
			【Uni-App】出现Cannot read property ’apply’ of undefined错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误日志如下：
14:47:00.951 [system] [object] {"message":"Cannot read property 'apply' of undefined","stack":"TypeError: Cannot read property 'apply' of...} 当我点击一个按钮的时候，控制台弹出以上日志，看他的message：Cannot read property ‘apply’ of undefined（无法读取未定义的属性“apply”）
&lt;template&gt; &lt;button @click="test"&gt;调试&lt;/button&gt; &lt;/template&gt; &lt;script&gt; export default { methods: {}, test: function() { console.log('sadfas'); } }; &lt;/script&gt; 有基础的可能一眼就会看出
test: function() { console.log('sadfas'); } 这个方法应该写在methods: {},里，而不是放在methods: {},外。
修改后：
&lt;template&gt; &lt;button @click="test"&gt;调试&lt;/button&gt; &lt;/template&gt; &lt;script&gt; export default { methods: { test: function() { console.log('sadfas'); } } }; &lt;/script&gt; 点击按钮后就会正常打印出结果：
14:53:50.098 sadfas at pages/index/index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ee39b15fdeb295e903bac091f6d5852/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1075c658c665e7fbcf2520921692d08a/" rel="bookmark">
			VB打开指定Word文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在VB的“工程”-&gt;“引用”中引用“Microsoft Word 9.0 Object Library
Private Sub Command1_Click()'打开指定的Word文件
Dim wdApp As Word.Application
Dim aDoc As DocumentSet wdApp = New word.Application
Set aDoc = wdApp.Documents.Open(FileName:=“你要打开的Word文件路径及文件名”)
wdApp.Visible = True’设置Word对象可见
End Sub
aDoc.Close’关闭文件
wdApp.Quit’退出Word程序
Set aDoc = Nothing
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b68066618c53b93b0d51c746174ac5c/" rel="bookmark">
			写SQL语句的小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SQL总结写法
SQL的写法无非就是几种,关联查询,子查询,分组函数,各种函数的使用
1.首先根据要做的需求,先分析一下,需要用到哪些查询,例如要用到关联查询,就先把用到的表列出来,比如a,b,c三个表就先写出来,select * from a,b,c 前面的内容可以先放着不用谢,然后找三张表的之间的关联关系,这里要看的连接方式是自然连接,还是左连接,右连接等
2.举例:
select * from a,b,c where a.id = b.aid and b.id = c.bid 关联关系写好了,然后再写查询的内容
select a.name,b.name,sum(c.value) from a,b,c where a.id=b.aid and b.id= c.bid,然后再看有聚合查询,所以需要用到聚合查询,所以需要用到group by 优化一下上面的sql,最终要写成的样子:select a.name,b.name,sum(c.value) from a,b,c where a.id = b.aid and b.id = c.bid group by a.name,b.name,再者有其他排序的,就接着往下写就是了
二、SQL优化总结、避免全面扫描的一些注意事项
1.应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。
2.应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描
可以考虑用union
select id from t where num=10 or Name = 'admin' 可以替换为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b68066618c53b93b0d51c746174ac5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea96aef66b125805c7d555d51547d3b0/" rel="bookmark">
			SAS关于自定义format的小知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		proc format lib=work; value agefmt 11-13 ='小' 14-15='大'; run; data class2; set class; format age agefmt.; run; 要注意格式语句中小小的点，没点SAS会认为是变量。加上点会认为是格式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00e7afdd036ce5e02cf8f15b2e794702/" rel="bookmark">
			随机矩阵stochastic matrix和双随机矩阵 doubly stochastic matrix 和bistochastic matrix
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、随机矩阵 stochastic matrix 定义：
A square matrix P is said to be stochastic if its elements are all nonnegative and all row sums are one.
如果一个方阵P的每一项均为非负的并且每行的和均为1，则称其为随机矩阵stochastic ；
2、双随机矩阵 doubly stochastic matrix 定义：
If in addition to being stochastic, all column sums are one, the matrix is said to be doubly stochastic. An obvious example of a doubly stochastic matrix is the n × n matrix in which each entry is 1/n.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00e7afdd036ce5e02cf8f15b2e794702/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a614928e924293701be2ab501f528c87/" rel="bookmark">
			vue&#43;element-ui实现搜索文字并高亮定位显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先看一下效果，定位到画布上的节点
先上代码
代码模块1
// 搜索框html代码 &lt;el-input placeholder="请输入节点名称" prefix-icon="el-icon-search" v-model="searchNodeInput" @input="changeSearchNodeInput" @keyup.down.native="inputDown" @keyup.up.native="inputUp" @keyup.enter.native="inputDown" clearable &gt; &lt;template slot="append"&gt; &lt;div class="searchRight"&gt; &lt;span class="item"&gt;{{nowNum}}/{{totalNum}}&lt;/span&gt; &lt;el-tooltip class="item" effect="dark" content="上一个" placement="top"&gt; &lt;el-button @click="inputUp" :disabled="inputUpDisable" icon="el-icon-arrow-up" circle type="text"&gt;&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;el-tooltip class="item" effect="dark" content="下一个" placement="top"&gt; &lt;el-button @click="inputDown" :disabled="inputDownDisable" icon="el-icon-arrow-down" circle type="text"&gt;&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;/div&gt; &lt;/template&gt; &lt;/el-input&gt; 其中涉及到的@keyup事件
代码模块2
// 上一个 inputUp () { if (this.totalNum &gt;= 1) { this.inputUpDisable = false if (this.currentNodeIndex === 0) { this.currentNodeIndex = Number(this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a614928e924293701be2ab501f528c87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb43d5df1066b95a94768c5a8bc128ab/" rel="bookmark">
			Java并发学习笔记（九）：Semaphore、CountdownLatch、CyclicBarrier
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JUC 四、Semaphore 1、基本使用 信号量，用来限制能同时访问共享资源的线程上限。
public static void main(String[] args) { //创建Semaphore 对象，参数用户限定共享变量的个数 Semaphore semaphore = new Semaphore(3); //10线程同时运行 for (int i = 0; i &lt; 10; i++) { new Thread(()-&gt;{ try { // 获取许可 semaphore.acquire(); TheadPrint.print("run..."); Thread.sleep(1000); TheadPrint.print("end..."); } catch (InterruptedException e) { e.printStackTrace(); } finally { // 释放许可 semaphore.release(); } }).start(); } } 从下面的结果可以看出，每个时刻最多有三个线程在运行，Semaphore 起到效果
07:35:15.485 c.TestSemaphore [Thread-2] - running... 07:35:15.485 c.TestSemaphore [Thread-1] - running... 07:35:15.485 c.TestSemaphore [Thread-0] - running.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb43d5df1066b95a94768c5a8bc128ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cecdf38a7a2949054fe6c5e15f97ef64/" rel="bookmark">
			dns配置服务器可以解析，客户机无法解析，可以相互ping通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ## **dns配置服务器可以解析，客户机无法解析，可以相互ping通**
问题：
;; connection timed out; trying next origin ;; connection timed out; no servers could be reached 解决方法：关闭防火墙
systemctl stop firewalld
若防火墙无法关闭，出现如下问题
Failed to stop iptables.service: Unit iptables.service not loaded 需要安装iptables
使用如下命令：
yum install iptables-services 然后再关闭防火墙：
systemctl stop firewalld 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b118172e3f9c09d277b47c6b41d8442/" rel="bookmark">
			动态库DLL文件的动态调用和静态调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考百度百科和C++调用DLL有两种方法—静态调用&amp;动态调用
库文件一般指计算机上的一类文件，分两种，一种是静态库，另一种是动态库即DLL(Dynamic Link Library)文件，又叫动态链接库文件。静态库和动态库的区别是：静态库在程序的链接阶段被复制到了程序中；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。使用动态库的优点是系统只需载入一次动态库，不同的程序可以得到内存中相同的动态库的副本，因此节省了很多内存，而且使用动态库也便于模块化更新程序。
一、DLL意义
DLL文件中存放的是各类程序的函数(子过程)实现过程，当程序需要调用函数时需要先载入DLL，然后取得函数的地址，最后进行调用。使用DLL文件的好处是程序不需要在运行之初加载所有代码，只有在程序需要某个函数的时候才从DLL中取出。另外，使用DLL文件还可以减小程序的体积。
二、DLL调用方式
（1） 静态调用
步骤如下:
1、把你的youApp.DLL拷到你目标工程(需调用youApp.DLL的工程)的Debug目录下;
2、把你的youApp.lib拷到你目标工程(需调用youApp.DLL的工程)目录下;
3、把你的youApp.h(包含输出函数的定义)拷到你目标工程(需调用youApp.DLL的工程)目录下;
4、打开你的目标工程选中工程,选择Visual C++的Project主菜单的Settings菜单;
5、执行第4步后，VC将会弹出一个对话框，在对话框的多页显示控件中选择Link页。然后在Object/library modules输入框输入:youApp.lib
6、选择你的目标工程Head Files加入：youApp.h文件;
7、最后在你目标工程(*.cpp,需要调用DLL中的函数)中包含你的:#include “youApp.h”
注：youApp是你DLL的工程名。
.lib是一种文件名后缀，代表的是静态数据连接库，在windows操作系统中起到链接程序和函数（或子过程）的作用，相当于Linux中的.a或.o、.so文件。
LIB文件中存放的是函数调用的信息，数据库有静态数据库（.lib文件）和动态数据库（.dll文件）
一般的动态库程序有lib文件和dll文件。lib文件是必须在编译期就要连接到应用程序中的，而dll文件是运行期才会被调用的。如果有dll文件，那么对应的lib文件一般是一些索引信息，具体的实现在dll文件中。如果只有lib文件，那么这个lib文件静态编译出来的，索引和实现都在其中。
（2） 动态调用
是由编程者用 API 函数加载和卸载 DLL 来达到调用 DLL 的目的，使用上较复杂，但能更加有效地使用内存，是编制大型应用程序时的重要方式。
1、把你的youApp.DLL拷到你目标工程(需调用youApp.DLL的工程)的Debug目录下;
2.、在程序中使用以下代码
{ HINSTANCE hDllInst = LoadLibrary(“youApp.DLL”); if(hDllInst) { typedef DWORD (WINAPI *MYFUNC)(DWORD,DWORD); MYFUNC youFuntionNameAlias = NULL; // youFuntionNameAlias 函数别名 youFuntionNameAlias = (MYFUNC)GetProcAddress (hDllInst,”youFuntionName”); // youFuntionName 在DLL中声明的函数名 if(youFuntionNameAlias) { youFuntionNameAlias(param1,param2); } FreeLibrary(hDllInst); } } 在Windows系统中，与动态库调用有关的函数包括：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b118172e3f9c09d277b47c6b41d8442/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b64c74835d3d675cf1581ae4cd2acc0/" rel="bookmark">
			java8List转String逗号分隔符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java8List转String逗号分隔符 String newStr = permissionList.stream().collect(Collectors.joining(",")); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bbcd7dc78e74e7b72bcf827edc9695c/" rel="bookmark">
			汇编第四集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四集汇编：
段表：GDT LDT
GDT：全局段描述符表 本身放在GDTR这个寄存器；
LDT：
C语言和汇编之间的简单相关内容：
变址寻址：
四要素：
请注意下面的三个变形形式与其相对应的mem表达形式；
这是一个例子；
注意最后的那个（，%edx，2）这种形式；
mov指令：movb,movw,movl;
movs S指令：movsbw;movsbl;movswl;符号位扩展；
movz Z指令：movzbw;movzbl;movzwl;零扩展；
leal Src,Dest 计算一个地址放到dest里面；地址计算指令
编译器用lea来计算地址，不会真的像上面的那样去计算。
我的图呢？上面显示的是常用的双操作数指令；
addl
subl
imill
sall 左移
sarl 算数右移
shrl 逻辑右移
xorl 亦或操作
andl 与操作
orl 或操作
下面展示的是常用的单操作数指令；
incl Dest Dest=Dest+1
decl Dest Dest=Dest-1
negl Dest Dest=-Dest
notl Dest Dest=~Dest （取反）
最多有一个是mem！！！
逻辑运算：
这个是相应的几种数据的大小
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b65539bc4b7ab9a46694ae611cf384a0/" rel="bookmark">
			深度学习之Batch Normalization
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自https://www.cnblogs.com/hutao722/p/9842199.html
Batch Normalization（批量标准化，简称BN）是近些年来深度学习优化中一个重要的手段。BN能带来如下优点：
加速训练过程；可以使用较大的学习率；允许在深层网络中使用sigmoid这种易导致梯度消失的激活函数；具有轻微地正则化效果，以此可以降低dropout的使用。 但为什么BN能够如此有效？让我们来一探究竟。
一、Covariate Shift Convariate shift是BN论文作者提出来的概念，其意是指具有不同分布的输入值对深度网络学习的影响。举个例子，假设我们有一个玫瑰花的深度学习网络，这是一个二分类的网络，1表示识别为玫瑰，0则表示非玫瑰花。我们先看看训练数据集的一部分：
直观来说，玫瑰花的特征表现很明显，都是红色玫瑰花。 再看看训练数据集的另一部分：
很明显，这部分数据的玫瑰花各种颜色都有，其特征分布与上述数据集是不一样的。通过下图我们可以再比较下：
图中右侧部分绿色圆圈指的是玫瑰，红色打叉指的是非玫瑰，蓝色线为深度学习最后训练出来的边界。这张图可以更加直观地比较出两个数据集的特征分布是不一样的，这种不一样也就是所谓的covariate shift，而这种分布不一致将减缓训练速度。
为什么这么说呢？输入值的分布不同，也可以理解为输入特征值的scale差异较大，与权重进行矩阵相乘后，会产生一些偏离较大地差异值；而深度学习网络需要通过训练不断更新完善，那么差异值产生的些许变化都会深深影响后层，偏离越大表现越为明显；因此，对于反向传播来说，这些现象都会导致梯度发散，从而需要更多的训练步骤来抵消scale不同带来的影响，也需要更多地步骤才能最终收敛。
而BN的作用就是将这些输入值进行标准化，降低scale的差异至同一个范围内。这样做的好处在于一方面提高梯度的收敛程度，加快训练速度；另一方面使得每一层可以尽量面对同一特征分布的输入值，减少了变化带来的不确定性，也降低了对后层网路的影响，各层网路变得相对独立。
也许上述的解释可能有些晦涩，让我们通过代码和图像来直观理解。
二、Batch Normalization BN的计算公式如下图所示：
简单地说，通过计算均值和方差后，mini-batch的数据进行标准化，再加上β和γ可以使数据进行移动和缩放。
我们以某个CIFAR-10的数据为例，通过BN的转换来查看数据分布的前后变化，以下为示例代码：
import numpy as np import matplotlib.pyplot as plt import tensorflow.keras.backend as K from tensorflow import keras (train_images, train_labels), (test_images, test_labels) = keras.datasets.cifar10.load_data() # 输入图片尺寸为（32, 32, 3），经flatten后大小为(3072, 1) x = train_images[0].reshape(-1) / 255 print("x:", x.shape) # 假设我们的隐藏层第一层的输出为(1024, 1)，则反推权重大小为(1024, 3072) w = K.eval(K.random_normal_variable(shape=(1024, 3072), mean=0, scale=1)) print("w:", w.shape) # 进行矩阵乘法得到大小为(1024, 1)的集合z z = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b65539bc4b7ab9a46694ae611cf384a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/324862b75a60b10e885210f7a0792761/" rel="bookmark">
			PowerMockito的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PowerMockito经常会结合Mockito使用，先说一下这2个的介绍：
1.Mockito和PowerMockito的简介 Mockito和PowerMockito是什么东西呢？他们有什么作用呢？Mocktio和PowerMockito都是Mock的工具类，主要是Java的类库，Mock就是伪装的意思。他们适用于单元测试中，对于单元测试来说，我们不希望依赖于第三方的组件，比如数据库、Webservice等。在写单元测试的时候，我们如果遇到了这些需要依赖第三方的情况，我们可以使用Mock的技术，伪造出来我们自己想要的结果。对于Java而言，mock的对象主要是Java 方法和 Java类。
下面我就介绍一下怎么使用Mockito和PowerMockito去进行Mock。
2.Mockito和PowerMockito的区别 在我看来，PowerMockito是Mockito的一种增强，他们的PowerMockito可以调用Mockito的方法，但是对于Mocktio不能Mock的对象或者方法，我们可以使用PowerMockito来实现。比如Mockito不能用于static Method, final method, 枚举类， private method，这些我们都可以用PowerMockito来实现，当PowerMockito和mockito结合使用的时候，我们需要考虑兼容性的问题。两者的版本需要兼容。
MockitoPowerMockito2.8.9+2.x2.8.0-2.8.91.7.x2.7.51.7.0RC42.4.01.7.0RC22.0.0-beta - 2.0.42-beta1.6.5-1.7.0RC1.10.8 - 1.10.x1.6.2 - 2.01.9.5-rc1 - 1.9.51.5.0 - 1.5.61.9.0-rc1 &amp; 1.9.01.4.10 - 1.4.121.8.51.3.9 - 1.4.91.8.41.3.7 &amp; 1.3.81.8.31.3.61.8.1 &amp; 1.8.21.3.51.81.31.71.2.5 Ref：https://github.com/powermock/powermock/wiki/Mockito
3.具体用法 本文实现实现需要构造的接口和需要返回值的接口
引入依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-all&lt;/artifactId&gt; &lt;version&gt;2.0.2-beta&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt; &lt;version&gt;1.7.4&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/324862b75a60b10e885210f7a0792761/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bec1edcb36948c48e1f61e995b5a3e8c/" rel="bookmark">
			华人博士提出原型对比学习，非监督学习效果远超MoCo和SimCLR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点上方蓝字视学算法获取更多干货
在右上方 ··· 设为星标 ★，与你不见不散
仅作分享，不代表本公众号立场，侵权联系删除
转载于：新智元
继MoCo和SimCLR之后非监督学习的又一里程碑！Salesforce的华人科学家（Junnan Li）介绍了一种新的非监督式神经网络学习方法，这种方法能够从数百万个未标记的图像中训练深层神经网络，让我们离机器智能又进了一步。 本文提出的原型对比学习(PCL) ，统一了非监督式学习的两个学派: 聚类学习和对比学习。PCL 推动了机器学习和人工智能的圣杯--非监督式学习技术的进步，并向无需人类指导的机器智能迈出了重要的一步。
为什么是非监督学习
深层神经网络在许多方面取得了前所未有的进展，比如图像分类和目标检测。大部分的进步都是由监督式学习 / 标签模式驱动的，得到这么好的性能很大程度上依赖于大量带有人工注释的标签(例如 ImageNet)。
然而，手工标注的成本是十分昂贵的，很难扩大规模。另一方面，互联网上存在着几乎无限量的未标记图片。非监督式学习是唯一适合开发未标记数据这个大金矿的方法。
首先，让我们来谈谈两个流行的非监督式学习算法学派: 聚类和对比学习。
聚类:机器学习中最常见的非监督式学习任务之一。
它是将数据集划分为若干个组的过程，聚类算法将相似的数据点组合在一起，而不同的数据点组合在不同的组中。
在所有的聚类方法中，K 均值是最简单和最流行的方法之一。它是一个迭代算法，目的是将数据集划分为 k 组(聚类) ，其中每个数据点只属于一类，聚类中每个数据点和聚类质心(属于该聚类的所有数据点的算术平均值)平方距离之和最小。
对比学习: 非监督式学习的一个新兴学派
随着深层神经网络的出现，对比非监督式学习已经成为一个流行的方法学派，它训练深层神经网络而不用标签。经过训练的网络能够从图像中提取有意义的特征(表示) ，这将提高其他下游任务的性能。
对比非监督式学习主要是从数据本身学习有用的表征，所以也称为对比自我监督学习。
许多最先进的对比学习方法(例如 MoCo 和 SimCLR )都是基于实例辨别的任务。
实例鉴别训练一个网络来分类两个图像是否来自同一个源图像，如图 1(a)所示。该网络(例如 CNN 编码器)将每个图像裁剪投影到一个嵌入中，并将同源的嵌入彼此拉近，同时将不同源的嵌入分开。通过解决实例识别任务，期望网络学习到一个有用的图像表示。
实例鉴别在无监督表征学习中表现出了良好的性能。然而，它有两个局限性。
首先，利用低层线索就可以区分不同的实例，因此网络不一定学习到有用的语义知识。
其次，如图 1(b)所示，来自同一个类(cat)的图像被视为不同的实例，它们的嵌入被推开。这是不可取的，因为具有相似语义的图像应该具有相似的嵌入。为了解决上述缺点，我们提出了一种无监督表征学习的新方法: 原型对比学习(PCL)。
原型对比学习: 统一对比学习和聚类学习
原型对比学习是无监督表征学习的一种新方法，它综合了对比学习和聚类学习的优点。
在 PCL 中，我们引入了一个「原型」作为由相似图像形成的簇的质心。我们将每个图像分配给不同粒度的多个原型。训练的目标是使每个图像嵌入更接近其相关原型，这是通过最小化一个 ProtoNCE 损失函数来实现的。
在高层次上，PCL 的目标是找到给定观测图像的最大似然估计(MLE)模型参数：
我们引入原型 c 作为与观测数据相关的潜在变量，提出了一种期望最大化算法来求解最大似然估计。在 E-step 中，我们通过执行 K 平均算法估计原型的概率。在 m 步中，我们通过训练模型来最大化似然估计，从而最小化一个 ProtoNCE 损失:
在期望最大化框架下，我们可以证明以前的对比学习方法是 PCL 的一个特例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bec1edcb36948c48e1f61e995b5a3e8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2c0bc1dbb4e815a1db2fd4a2c0811e4/" rel="bookmark">
			Java并发学习笔记（八）：AQS（AbstractQueuedSynchronizer）、ReentrantLock 原理、读写锁使用和原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		J.U.C 一、AQS 原理 1、概述 AQS 全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架
特点：
用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取 锁和释放锁 getState - 获取 state 状态setState - 设置 state 状态compareAndSetState - cas 机制设置 state 状态独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源 提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet 原理：
AQS通过一个int同步状态码，和一个（先进先出）队列来控制多个线程访问资源支持独占和共享两种模式获取同步状态码当线程获取同步状态失败会被加入到同步队列中当线程释放同步状态，会唤醒后继节点来获取同步状态共享模式下的节点获取到同步状态或者释放同步状态时，不仅会唤醒后继节点，还会向后传播，唤醒所有同步节点使用volatile关键字保证状态码在线程间的可见性，CAS操作保证修改状态码过程的原子性。 子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）
tryAcquiretryReleasetryAcquireSharedtryReleaseSharedisHeldExclusively 获取锁的方式：
// 如果获取锁失败 if (!tryAcquire(arg)) { // 入队, 可以选择阻塞当前线程 park unpark } 释放锁的方式：
// 如果释放锁成功 if (tryRelease(arg)) { // 让阻塞线程恢复运行 } 2、使用AQS实现不可重入锁 自定义同步器
/** * 自定义锁(不可重入锁) */ final class MyLock implements Lock { //独占锁,同步器类 class MySync extends AbstractQueuedSynchronizer{ @Override protected boolean tryAcquire(int arg) { if (compareAndSetState(0,1)) { //加锁成功,并设置owner为当前线程 setExclusiveOwnerThread(Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2c0bc1dbb4e815a1db2fd4a2c0811e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da5fe41c477d29385a034993af870e41/" rel="bookmark">
			pytorch之torch.cuda.is_available()——判断GPU可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import torch print(torch.cuda.is_available()) 一般都是在命令行里：
返回True说明GPU可用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e13840774e237935dc13a1de9ae93fb3/" rel="bookmark">
			nodeJS使用UDP传递数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UDP-数据传输 不可靠的、无连接的服务、传输效率高效率要求高、对精准性要求相对低如：在线视频、网络语音电话 nodeJS处理方案–dgram(数据报) dgram模块提供了UDP数据包scoket的实现。官方链接
dgram方法：close、message、listening、error
使用 首先创建一个客户端 client.js，一个服务端server.js两个文件。服务端： const dgram = require('dgram')//引入 // 创建一个socket类，socket就是用来处理网络数据的一个标准 API对象 //通过socket，我们就可以对网络数据进行读取和输出 //新建dgram.Socket类,两种方式 // const socket = new dgram.Socket() const serverSocket = dgram.createSocket('udp4')// udp4 =&gt; ipv4 ,udp6 =&gt; ipv6 //监听服务器开启 serverSocket.on('listening',()=&gt;{ console.log('服务器开启成功，等待数据：'); }) //监听客户端发送的数据 serverSocket.on('message', data =&gt; { console.log('接受的数据：',data.toString());//toString()是为了处理传过来的二进制数据变为字符串 }) //监听指定地址以及端口 serverSocket.bind(12345,'127.0.0.1') 客户端 const dgram = require('dgram') const clientSocket = dgram.createSocket('udp4') //监听指定地址以及端口 //第一个参数是发送数据，第二个参是位端口号，第三个参数为ip地址 clientSocket.send('hello',12345,'127.0.0.1') 总结 使用dgram模块可以实现视频等数据的传播，这儿只是一个简单的数据传递。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0144e7c3f57bd952dc9572c423de85fb/" rel="bookmark">
			创建Spring项目时java.lang.NoClassDefFoundError：org/gradle/api/internal/plugins/DefaultConvention问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 计算机网络需要后台使用SpringBoot.
初始配置 IDEA：2018.12
gradle：6.4.1
jdk：1.8.0
问题 gradle配置依赖时报错
问题分析 查找资料，发现相似问题。
How I can fix this error; java.lang.ClassNotFoundException: org.gradle.api.internal.plugins.DefaultConvention
Caused by: java.lang.ClassNotFoundException: org.gradle.api.internal.plugins.DefaultConvention
推断问题是由于gradle和idea版本问题。
解决方案 将IDEA升级到2020.1
结果 问题解决。
其他（证书问题） 我在上一篇博客中分析SSLHandshakeException时有分析到该错误原因是由于jdk证书不完善，并将相关证书导入了IDEA2018.12。
IDEA2020.1安装完成后，出现了一些窗口询问是否接受证书。
都点击Accept.
之后在IDEA 2020.1中重建项目build success，之后项目便可以正常运行。
这样之后，上一篇文章提到的SSL报错便完全解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9976abd1c1862603bd57c5d42de7c799/" rel="bookmark">
			java ssm获取数据库中datetime类型字段时分秒为0解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题描述，如图，数据库中的字段值
2、取出来返回的值
3、返回前端的值都变成了createTime: "XXXX-XX-XX 00:00:00" 时分秒都为0了
原因：
1、实体声明用了Date类型，这是问题所在
private Date createTime; // 创建时间
区别：
java.util.Date 包含日期
java.util.Time 包含时间
java.util.Timestamp 包含日期和时间
应该用 Timestamp 即 private Timestamp createTime; // 创建时间
2、mybatis中使用&lt;resultMap type="对应实体" id="orderInfoMap"&gt;接收数据，所以会转换格式，
3、如果直接select create_time from table 则不会有此问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da3032811e6f40d11eea934bbc5062fd/" rel="bookmark">
			【MySQL】-SQL-统计数据的表格个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 统计数据库表的数量 SELECT COUNT(*) TABLES, table_schema FROM information_schema.TABLES WHERE table_schema = 'testpass' OR table_schema = 'testquta' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27b4a6896103abe94f7488daf679af8c/" rel="bookmark">
			VTK读取点数据构建点云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;vtkVertexGlyphFilter.h&gt; #include &lt;vtkPolyDataMapper.h&gt; #include &lt;vtkActor.h&gt; #include &lt;vtkRenderer.h&gt; #include &lt;vtkRenderWindow.h&gt; #include &lt;vtkRenderWindowInteractor.h&gt; #include &lt;vtkInteractorStyleTrackballCamera.h&gt; #include &lt;sstream&gt; #include &lt;vtkAutoInit.h&gt; VTK_MODULE_INIT(vtkRenderingOpenGL2); VTK_MODULE_INIT(vtkInteractionStyle); VTK_MODULE_INIT(vtkRenderingVolumeOpenGL2); VTK_MODULE_INIT(vtkRenderingFreeType); int main(int, char* []) { std::string filename = "C:\\Users\\wangjun\\Downloads\\point_data.txt"; std::ifstream filestream(filename.c_str()); std::string line; vtkSmartPointer&lt;vtkPoints&gt; points = vtkSmartPointer&lt;vtkPoints&gt;::New(); while (std::getline(filestream, line)) { double x, y, z; std::stringstream linestream; linestream &lt;&lt; line; linestream &gt;&gt; x &gt;&gt; y &gt;&gt; z; points-&gt;InsertNextPoint(x, y, z); } filestream.close(); vtkSmartPointer&lt;vtkPolyData&gt; polyData = vtkSmartPointer&lt;vtkPolyData&gt;::New(); polyData-&gt;SetPoints(points); vtkSmartPointer&lt;vtkVertexGlyphFilter&gt; glyphFilter = vtkSmartPointer&lt;vtkVertexGlyphFilter&gt;::New(); glyphFilter-&gt;SetInputData(polyData); glyphFilter-&gt;Update(); vtkSmartPointer&lt;vtkPolyDataMapper&gt; mapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New(); mapper-&gt;SetInputConnection(glyphFilter-&gt;GetOutputPort()); vtkSmartPointer&lt;vtkActor&gt; actor = vtkSmartPointer&lt;vtkActor&gt;::New(); actor-&gt;SetMapper(mapper); vtkSmartPointer&lt;vtkRenderer&gt; renderer = vtkSmartPointer&lt;vtkRenderer&gt;::New(); renderer-&gt;AddActor(actor); renderer-&gt;SetBackground(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27b4a6896103abe94f7488daf679af8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05d6c1400de2dc8001d31a46fb605f78/" rel="bookmark">
			使用Azure Kinect Body骨骼构造SMPL三维人体模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.SMPL模型简介 SMPL是通过参数控制的人体模型，可控制的参数为Pose和Shape。总共有24个关节点和10个Shape控制参数，模型及关节索引如下图。
1.1.Pose——旋转向量控制关节点旋转 每个关节通过一个旋转向量控制，如下图为手动控制关节点4绕Z轴旋转90度、关节点19绕Y轴旋转90度的结果。
旋转关节点是在关节点的坐标系下操作的旋转，部位会随着父节点旋转而联动位移旋转。例如上述再绕Z轴旋转-90度，结果如下图。
1.2.Shape——10个Shape参数控制体型 Shape参数是通过PCA提取的10个参数。通过Shape可以控制体型，如下为控制第一个参数为-10和10的结果。通过10个参数控制可以逼近真实人体体型，影响高低、胖瘦、关节长短等。
SMPL的骨骼如下图所示
2.Azure Kinect Body Azure Kinect通过深度图可以检测出稳定的人体关节，关节点及其索引如下图所示。
同样可以获得关节点的旋转，但是每个关节的坐标系独立且方向不全一致，每个关节点的坐标系如下图。
通过Azure Kinect实际采集的骨架绘制结果如下：
3.人体骨骼拟合 3.1.初步对齐 由于SMPL与Azure Kinect坐标系不一致，首先需要将SMPL与Kinect Body移动旋转到同一个位置。未对齐的示意图如下：
根据上述两节的关节对应关系，形成对应的参考点对齐Map。首先将SMPL Joint0与Kinect Body Joint0移动到一起，然后构造 SMPL Joint0-&gt;Joint3 向量 V s Vs Vs 和 Kinect Body Joint0-&gt;Joint1 向量 V k Vk Vk。之后构造 V s Vs Vs 旋转到 V k Vk Vk 的旋转向量。操作SMPL模型进行旋转平移，即完成初步对齐，示意图如下：
3.2.调节参数进行骨骼对齐 设计能量函数为：
E ( β , θ ) = ∑ i = 1 24 ( R θ ( J ( β ) i ) − J k i n e c t , i ) E(\beta,\theta)=\sum_{i=1}^{24}(R_\theta(J(\beta)_i)-J_{kinect,i}) E(β,θ)=i=1∑24​(Rθ​(J(β)i​)−Jkinect,i​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05d6c1400de2dc8001d31a46fb605f78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bec5f7dcbac11ecca7fa2f7e8352a86d/" rel="bookmark">
			数据预处理Part7——特征选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 特征选择：1. 什么是特征选择？2. 为什么要进行特征选择？3. 怎样进行特征选择3.1 Filter过滤法3.1.1 方差过滤a. VarianceThresholdb. 方差过滤对模型的影响: 3.1.2 相关性过滤3.1.2.1 卡方过滤a 卡方过滤b. 选取超参数K 3.1.2.2 F检验3.1.2.3 互信息法 3.1.3 总结 3.2 Embedded嵌入法3.3 Wrapper包装法 4. 总结 特征选择： 1. 什么是特征选择？ 特征选择就是从所有的特征中，选择出有意义，对模型有帮助的特征，以避免必须将所有特征都导入模型去训练的情况。
特征选择完全独立于任何机器学习算法。他是根据各种统计检验中的分数以及相关性的各项指标来选择特征。
2. 为什么要进行特征选择？ 在实际工作中，用于模型中的特征维度往往很高，维度过高会增大模型计算复杂度，而且在这么多维数据中，并不是每个特征对模型的预测都是有效果的，所以需要利用一些方法去除一些不必要特征，从而降低模型的计算复杂度。
3. 怎样进行特征选择 常见的特征选择方法：
过滤法嵌入法包装法降维算法 3.1 Filter过滤法 3.1.1 方差过滤 a. VarianceThreshold Variance：方差。Threshold：阈。这是通过特征本身的方差来筛选特征的类，比如一个特征本身的方差很小，就表示样本在这个特征上基本没有差异，可能特征中的大多数值都一样，甚至整个特征的取值都相同，那这个特征对于样本区分没有什么作用。所以无论接下来的特征工程要做什么，都要优先消除方差为0的特征。
VarianceThreshold中有重要参数threshold，也就是方差的阈值，表示舍弃所有方差小于threshold的特征，不填默认为0，即删除所有的记录都相同的特征。
引包：
import pandas as pd import numpy as np from sklearn.feature_selection import VarianceThreshold 数据加载：
data = pd.read_csv("digit recognizor.csv") data.head() data.shape (42000, 785)
缺失值处理：
data.fillna(0,inplace = True) 切分特征和标签：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bec5f7dcbac11ecca7fa2f7e8352a86d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b8015a66bb3827c235e579bd27a36ec/" rel="bookmark">
			【Mariadb】-Mariadb集群故障节点替换过程（技术支持，请勿转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mariadb 节点故障替换过程 这段时间搭建mariadb集群，老板问我，一个节点坏掉了，能否直接替换，不用重启其他机器，不新加节点。我在网上找了很多资料，都没有一个完整的解决方案。于是自己探索模拟了下，还真被自己试成功了，下面把过程记录了下来。
场景：三台Mariadb集群，假设其中某一台突然出现问题，启动不了，现在用一台新的进行替换。
三台主机
172.20.30.189
172.20.30.190
172.20.30.191
问题主机
172.20.30.190
原先三台机器都正常，如下图所示：
我们先修改下下190的ip，然后reboot一下，发现190从集群节点中消失
下面我们用一台新的机器进行替换，
前提：节点故障之前保存所有节点配置文件最主要的是data目录下的grastate.dat文件(注意：一定要是文件本身，拷贝其中内容无效)
1：修改新节点的主机名和ip，保证与故障节点一致
a:修改主机名，保证与故障主机节点一致
b:修改主机ip，保证与故障主机节点一致
c:重启下网卡服务
systemctl restart network 2：修改本地主机映射关系，将故障节点的信息拷贝上去
3：重启下机器
reboot 4：修改mariadb集群的配置文件，保证相关信息与故障节点一致
vim /etc/my.cnf.d/server.cnf 5:初始数据库
/usr/bin/mysql_install_db --defaults-file=/etc/my.cnf.d/server.cnf --user=mysql --datadir=/usr /local /mysql/data --basedir=/usr 这个可以按照自己配置进行修改
6:将grastate.dat文件拷贝过去
7:给mysql 添加grastate.bat添加操作权限
chown -R mysql /usr/local/mysql/data/grastate.dat chgrp -R mysql /usr/local/mysql/data/grastate.dat 8：重启mariadb集群服务
Service mariadb restart
9:查看节点是否加入集群
10：数据同步完成
检查下了数据，发现数据同步需要一段时间，在这段时间无法插入数据，感觉这个应该是和mariadb（主主集群）机制有关系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d875de2aee262911fa2acfa9846e3ff1/" rel="bookmark">
			彻底解决java.lang.ClassNotFoundException: com.mysql.jdbc.Driver问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java中连接Mysql数据库，注册数据库的驱动时报错，也就是下面这句语句报错。
Class.forName("com.mysql.jdbc.Driver"); 报错为：
java.lang.ClassNotFoundException: com.mysql.jdbc.Driver 问题：没有JDBC的驱动包。
解决方法：
1.去Mysql官网下载最新版的驱动包
2.创建项目环境，导入数据库驱动
在Eclipse中新建一个java项目，使用鼠标右键单击项目名称然后选择【New】→【Folder】，在弹出的窗口中将该文件命名为lib并单击【Finish】按钮将下载好的Mysql数据库驱动文件mysql-connector-java-5.1.49-bin.jar复制到项目lib目录中使用鼠标右键单击该JAR包，在弹出框中选择二【Build Path】→【Add to Build Path】，此时Eclipse会将该JAR包发布到类路径下。加入驱动后的项目结构如图所示：
ok，问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d957b35a8f0259335b0ac7e018395f59/" rel="bookmark">
			Java并发学习笔记（七）：线程池、自定义线程池、任务调度线程池、Tomcat线程池、Fork/Join
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		并发工具 一、线程池 线程池是指管理一组同构工作线程的线程的资源池。
线程池与**工作队列（Work Queue）模切相关，工作队列中保存了所有等待知心的任务。线程池中的工作线程（Work Thread）**的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。
使用线程池的好处是：
通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。当请求到达时，工作线程通常已经存在，因此不会由于等待创建工作线程而延迟任务的执行，从而提高响应性通过适当调节线程池的大小，可以创建足够多的线程以便使处理器保持忙碌状态，同时还可以防止创建过多线程相互竞争资源使应用耗尽内存或失败。 1、自定义线程池 步骤1：自定义拒绝策略接口
//如果队列已满时的拒绝策略接口 @FunctionalInterface interface RejectPolicy&lt;T&gt; { void reject(BlockingQueue&lt;T&gt; blockingQueue, T task); } 步骤2：自定义任务队列
//工作队列 class BlockingQueue&lt;T&gt; { //任务列表 private Deque&lt;T&gt; queue = new ArrayDeque&lt;&gt;(); //锁 private ReentrantLock lock = new ReentrantLock(); //生产者条件变量 private Condition fullWaitSet = lock.newCondition(); //消费者条件变量 private Condition emptyWaitSet = lock.newCondition(); //容量 private int capacity; public BlockingQueue(int capacity) { this.capacity = capacity; } //阻塞获取 public T take() { lock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d957b35a8f0259335b0ac7e018395f59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9483fd30106112e344c1b80d80f00e92/" rel="bookmark">
			Python核心丨字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串 字符串基础 字符串是Python中很常见的一种数据类型，比如日记的打印，函数的注释、数据库的访问、变量的基本操作等等。
描述 字符串是由独立字符组成的一个序列
name = 'jason' city = 'beijing' # 单引号、双引号和三引号的字符串是一模一样的 s1 = 'hello' s2 = "hello" s3 = """hello""" s1 == s2 == s3 True # 内嵌带引号的字符串 "I'm a student" 三引号字符串，主要应用于多行字符串的情景
# 函数注释 def calculate_similarity(item1, item2): """ Calculate similarity between two items Args: item1: 1st item item2: 2nd item Returns: similarity score between item1 and item2 """ 字符串的常用操作 字符串支持索引，切片和遍历 name = 'jason' name[0] 'j' name[1:3] 'as' 遍历字符串相当于遍历字符串中的每个字符 for char in name: print(char) j a s o n 字符串是不可变的（immutable），改变一个字符串内部的字符是错误的，不允许的 s = 'hello' s[0] = 'H' Traceback (most recent call last): File "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9483fd30106112e344c1b80d80f00e92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71194ee446d0796ca1bfbfd838c3bffe/" rel="bookmark">
			解决git@github.com: Permission denied (publickey). fatal: Could not read from remote repository. Pleas
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天用idea提交代码到github上,push后报错
git@github.com: Permission denied (publickey).
fatal: Could not read from remote repository.
Please make sure you have the correct access rights
and the repository exists.
一:原因分析 Permission denied (publickey) 没有权限的publickey ，出现这错误一般是以下两种原因
客户端与服务端未生成 ssh key客户端与服务端的ssh key不匹配 找到问题的原因了，解决办法也就有了，重新生成一次ssh key ，服务端也重新配置一次即可。
二:客户端生成ssh key 在cmd里面输入
ssh-keygen -t rsa -C "xxxxxxxx@qq.com"
ssh-keygen -t rsa -C "youremail@example.com" xxxxxx@qq.com改为自己的邮箱即可，途中会让你输入密码啥的，不需要管，一路回车即可，会生成你的ssh key。（如果重新生成的话会覆盖之前的ssh key。）
三:输入箭头处路径 四:打开id_rsa.pub文件,并且复制内容 配置服务端 五:在github上打开箭头处,点击Setting 六:点击SSH and GPG keys 七:打开你刚刚生成的id_rsa.pub，将里面的内容复制，进入你的github账号，在settings下，SSH and GPG keys下new SSH key，然后将id_rsa.pub里的内容复制到Key中，完成后Add SSH Key。 八:然后添加后入下图所示 九:用idea再次提交文件到 github上,显示提交成功 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eee4ffad426260c0a692bfb7a0f1a518/" rel="bookmark">
			三维数据分析、线激光切片数据分析——VTK显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.项目介绍 利用三维点云对线激光采集的数据进行分析，并对其中凹陷部分进行测量。如下为单线分析。主要目标是测量凹槽到下端平面的距离。
2.运用到的知识点 2.1.最小二乘三维平面拟合 数据点云是通过双目相机对打在目标上的线激光匹配得到的结果，也就是说激光的切面不在XOZ或XOY平面内，为了方便数据分析，将三维点云投影到线激光平面。
通过最小二乘拟合，可以通过采样数据点得到平面方程： z = A x + B y + C z = Ax + By + C z=Ax+By+C
公式推导参考：最小二乘解
//m为采样数据数，大于等于3 Matrix&lt;double&gt; A = new DenseMatrix(m, 3); Matrix&lt;double&gt; b = new DenseMatrix(m, 1); int row = 0; for (int i = 0; i &lt; points.Count; i++) { List&lt;float3&gt; line = points[i]; //将每个点录入矩阵 for (int j = 0; j &lt; line.Count; j++) { float3 value = line[j]; A[row, 0] = value.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eee4ffad426260c0a692bfb7a0f1a518/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/042db0391ec1716c4ce3f4060ef3af9e/" rel="bookmark">
			Jpa是什么——Jpa使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ORM思想1.ORM概述2.为什么要使用ORM3.常见的ORM框架 JPA简介1.JPA概述2.JPA的优势3.JPA与hibernate的关系 JPA入门案例1.搭建开发环境常用注解说明 JPA主键生成策略JPA的API介绍1.Persistence对象2.EntityManagerFactory3.EntityManager4.EntityTransaction ORM思想 1.ORM概述 ORM（Object-Relational Mapping） 表示对象关系映射。在面向对象的软件开发中，通过ORM，就可以把对象映射到关系型数据库中。只要有一套程序能够做到建立对象与数据库的关联，操作对象就可以直接操作数据库数据，就可以说这套程序实现了ORM对象关系映射
简单的说：ORM就是建立实体类和数据库表之间的关系，从而达到操作实体类就相当于操作数据库表的目的。
2.为什么要使用ORM 当实现一个应用程序时（不使用O/R Mapping），我们可能会写特别多数据访问层的代码，从数据库保存数据、修改数据、删除数据，而这些代码都是重复的。而使用ORM则会大大减少重复性代码。对象关系映射（Object Relational Mapping，简称ORM），主要实现程序对象到关系数据库数据的映射。
3.常见的ORM框架 当实现一个应用程序时（不使用O/R Mapping），我们可能会写特别多数据访问层的代码，从数据库保存数据、修改数据、删除数据，而这些代码都是重复的。而使用ORM则会大大减少重复性代码。对象关系映射（Object Relational Mapping，简称ORM），主要实现程序对象到关系数据库数据的映射。
JPA简介 1.JPA概述 JPA的全称是Java Persistence API， 即Java 持久化API，是SUN公司推出的一套基于ORM的规范，内部是由一系列的接口和抽象类构成。JPA通过JDK 5.0注解描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。
2.JPA的优势 1. 标准化
JPA 是 JCP 组织发布的 Java EE 标准之一，因此任何声称符合 JPA 标准的框架都遵循同样的架构，提供相同的访问API，这保证了基于JPA开发的企业应用能够经过少量的修改就能够在不同的JPA框架下运行。
2. 容器级特性的支持
JPA框架中支持大数据集、事务、并发等容器级事务，这使得 JPA 超越了简单持久化框架的局限，在企业应用发挥更大的作用。
3. 简单方便
JPA的主要目标之一就是提供更加简单的编程模型：在JPA框架下创建实体和创建Java 类一样简单，没有任何的约束和限制，只需要使用 javax.persistence.Entity进行注释，JPA的框架和接口也都非常简单，没有太多特别的规则和设计模式的要求，开发者可以很容易的掌握。JPA基于非侵入式原则设计，因此可以很容易的和其它框架或者容器集成
4. 查询能力
JPA的查询语言是面向对象而非面向数据库的，它以面向对象的自然语法构造查询语句，可以看成是Hibernate HQL的等价物。JPA定义了独特的JPQL（Java Persistence Query Language），JPQL是EJB QL的一种扩展，它是针对实体的一种查询语言，操作对象是实体，而不是关系数据库的表，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能够提供的高级查询特性，甚至还能够支持子查询。
5. 高级特性
JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，这样的支持能够让开发者最大限度的使用面向对象的模型设计企业应用，而不需要自行处理这些特性在关系数据库的持久化。
3.JPA与hibernate的关系 JPA规范本质上就是一种ORM规范，注意不是ORM框架——因为JPA并未提供ORM实现，它只是制订了一些规范，提供了一些编程的API接口，但具体实现则由服务厂商来提供实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/042db0391ec1716c4ce3f4060ef3af9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76eb17a142be4cd48a029f48d999c1a5/" rel="bookmark">
			Gradle的环境安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows系统
文章目录 1. Gradle简介2. Gradle下载3. Gradle安装4. 配置5. IDEA配置Gradle 1. Gradle简介 Gradle是源于Apache Ant和Apache Maven概念的项目自动化构建开源工具，它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，抛弃了基于XML的各种繁琐配置。 Gradle是一个基于JVM的构建工具，是一款通用灵活的构建工具，支持maven， Ivy仓库，支持传递性依赖管理，而不需要远程仓库或者是pom.xml和ivy.xml配置文件，基于Groovy，build脚本使用Groovy编写。 面向Java应用为主。当前其支持的语言暂时有Java、Groovy、Kotlin和Scala。 像maven一样的基于约定的构建框架（约定优于配置）。 IDEA 2017.3以上版本支持。 2. Gradle下载 官网下载地址：https://gradle.org/releases/
binary-only：二进制源码Complete：源码和文档 3. Gradle安装 解压 ZIP 文件到想安装到的目录，eg：F:\other\gradle。
4. 配置 配置环境变量
GRADLE_HOME：安装目录。eg: F:\other\gradle\gradle-6.4.1GRADLE_USER_HOME（可不配置）：自定义仓库（可以为Maven的仓库目录)。eg: D:\other\repository1环境变量 Path：%GRADLE_HOME%\bin;
测试是否安装成功：输入快捷键 WIN+ R，输入 cmd，在弹出的窗口输入命令行： gradle -v
配置Gradle仓库源（可不配置）：
在Gradle安装目录下的 init.d 文件夹下，新建一个 init.gradle 文件，里面填写以下配置。 allprojects { repositories { maven { url 'file:///D:/other/repository1'} mavenLocal() maven { name "Alibaba" ; url "https://maven.aliyun.com/repository/public" } maven { name "Bstek" ; url "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76eb17a142be4cd48a029f48d999c1a5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/365/">«</a>
	<span class="pagination__item pagination__item--current">366/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/367/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>