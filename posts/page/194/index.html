<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5279930e66d965c0a7c3c74f34ccf60f/" rel="bookmark">
			跨域-后端过滤器配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 跨域常用方案
1 nginx 反向代理，配置跨域
2 java注解配置跨域 @CrossOrigin
3 java过滤器实现跨域
/** * 通用配置 */ @Configuration public class ResourcesConfig implements WebMvcConfigurer { /** * 跨域配置 */ @Bean public CorsFilter corsFilter() { CorsConfiguration config = new CorsConfiguration(); config.setAllowCredentials(true); // 设置访问源地址 config.addAllowedOriginPattern("*"); // 设置访问源请求头 config.addAllowedHeader("*"); // 设置访问源请求方法 config.addAllowedMethod("*"); // 有效期 1800秒 config.setMaxAge(1800L); // 添加映射路径，拦截一切请求 UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration("/**", config); // 返回新的CorsFilter return new CorsFilter(source); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c6ea9ddac7344e8d3d539ac447675dd/" rel="bookmark">
			在node-red中switch数据的判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在node-red中switch数据的判断
[ { "id": "273ea057.8ffe78", "type": "switch", "z": "72b57a2d.bafa3c", "name": "", "property": "payload", "propertyType": "msg", "rules": [ { "t": "btwn", "v": "1", "vt": "num", "v2": "5000", "v2t": "num" }, { "t": "btwn", "v": "5000", "vt": "num", "v2": "8888", "v2t": "num" } ], "checkall": "true", "repair": false, "outputs": 2, "x": 250, "y": 720, "wires": [ [ "df5c9ebc.5273b8" ], [] ] }, { "id": "65d3b26a.844724", "type": "comment", "z": "72b57a2d.bafa3c", "name": "", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c6ea9ddac7344e8d3d539ac447675dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58f55d552d9dc13c7cc5575844a6523c/" rel="bookmark">
			解决from sklearn时，Script报错cannot import name show_config from numpy以及fetch_openml(‘mnist 784‘)会报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、刚开始是遇到scikit-learn版本问题，报错无法导入fetch_mldata包，这是由于scikit-learn0.20版本过高已经不支持fetch_mldata，需要降低包的版本到0.19.2以下。
我尝试通过pip unistall scikit-learn 和 pip install scikit-learn==0.19.2，但是报错没有Script模块，当时通过pip install Script安装，结果一直报错，cannot import name show_config from numpy。在查找资料（解决Scipy报错ImportError cannot import name show_config from numpy (unknown location）_乌拉队长的博客-CSDN博客）后，发现是numpy 和 Script版本不一致，存在冲突。
2、在尝试重新卸载安装numpy，Script后，还是存在问题，即使参考了另一个博客的把两个版本升到最新版本，也是报错。果断放弃旧版本scikit-learn，卸载并在Anaconda上搜索安装，注意这里不要自己pip / conda 安装卸载scikit-learn，不然还是报错。使用Anaconda安装，它会一次集成安装相应合适的版本的numpy 和 Script。
3、安装scikit-learn，发现调用mnist = fetch_openml('mnist 784')会报错，原因是url存在空格，删除空格后还是报错。于是改成mnist_784，可以下载，但是下载后，在读取其第一张图像数据X[0]时，会报错，显然这是下载时数据就有问题。没有办法，最后通过以下博主链接下载数据到本地再进行读取，终于正常工作了，表示感激，需要的朋友可以点击下载。
mnist = fetch_openml(‘mnist_784‘,version=1)失效的解决方法_GaoZhenwen2的博客-CSDN博客_mnist_784
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ca5eeeee9e8b3af88a1fe5399190837/" rel="bookmark">
			Linux内核编译报错/bin/sh: 1: bison: not found recipe for target ‘scriptskconfigparser.tab.h‘ failed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux内核编译报错recipe for target ‘scriptskconfigparser.tab.h’ failed 错误信息
/bin/sh: 1: bison: not found scripts/Makefile.host:17: recipe for target 'scripts/kconfig/parser.tab.h' failed make[1]: *** [scripts/kconfig/parser.tab.h] Error 127 Makefile:589: recipe for target 'menuconfig' failed make: *** [menuconfig] Error 2 解决方法 按错误提示来
安装bison
sudo apt-get install bison 重新编译测试
ok解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afe34844ac0d73ed27d603b6186932f7/" rel="bookmark">
			Java并发编程知识点总结（七）——原子性、有序性、可见性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这一节来对比下synchronized和volatile关键字在三大性质中的不同。
1. 原子性 原子性是指一个操作是不可中断的，要么全部执行成功，要么全部执行失败。即使在多线程情况下，也能保证不被其它线程干扰。
我们来看下面几个例子
int a = 10; // 1 ++a; // 2 int b = a; // 3 a = a+1; // 4 在上面的三个操作中，只有第一个操作时具有原子性的。第二个自增操作实际上时分为三步的：取a的值、对a的值+1、赋值给a，所以是无法保证原子性的。3、4同理也不具有原子性。
在JMM内存模型中，只有如下8个操作是具有原子性的：
lock(锁定)：作用于主内存中的变量，它把一个变量标识为一个线程独占的状态。unlock(解锁)：作用于主内存中的变量，它把一个处于锁定状态的变量释放出来。read(读取)：作用于主内存中的变量，它把从主内存中读取的变量传送到工作内存，以便后面的load。load(载入)：作用于工作内存的变量，将read操作读取的变量放入工作内存中的变量副本。use(使用)：作用域工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎。assign(赋值)：作用于工作内存中的变量，它把从执行引擎计算的变量赋值给工作内存的变量。store(存储)：作用于工作内存的变量，它把工作内存中的变量值送给主内存中以便随后的write操作。write(操作)：作用于主内存的变量，它把store操作从工作内存中得到的变量值放入主内存中。 值得注意的是：Java内存模型只是要求上述两个操作时顺序执行的而不是连续执行的。也就是说read和load之间可以插入其它指令，store和write可以插入其它指令。例如可以出现这样的顺序：read a,read b,load b,load a。
synchronized synchronized关键字的实现原理是基于monitorenter和monitorexit，其实就相当于lock和unlok的原子性操作。
因此，synchronized是满足原子性的。
volatile 我们来看下面的代码
public class Demo1 { private static volatile int num = 0; public static void add(){ for(int i=0;i&lt;1000;i++){ num++; } } public static void main(String[] args) throws InterruptedException { for(int i=0;i&lt;10;i++){ Thread thread = new Thread(){ @Override public void run() { Demo1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afe34844ac0d73ed27d603b6186932f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbb8f74c10f237b6f7b3ad3ab32cb2d2/" rel="bookmark">
			随机森林分析金融数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 随机森林模型一、随机森林模型1.数据加载 二、数据清洗2.1.删除变量2.2变量数据类型转换2.3划分训练集和测试集 三、随机森林分析3.1建模分析3.2模型优化 总结 随机森林模型 首先：安装需要的几个R语言包：ggplot2，VIM，ggrepel
数据说明：
名称类型描述accountstring现有支票帐户的状态（A11：&lt;0 DM，A12：0 &lt;= x &lt;200 DM，A13：&gt; = 200 DM /至少一年的薪水分配，A14：无支票帐户）durationinteger D持续时间（月）credit_historystringA30：未提取任何信用/已全额偿还所有信用额，A31：已偿还该银行的所有信用额，A32：已到期已偿还的现有信用额，A33：过去的还款延迟，A34：关键帐户/其他信用额现有（不在此银行）purposestringA40 : car (new) A41 : car (used)，A42 : furniture/equipment，A43 : radio/television，A44 : domestic appliances，A45 : repairs，A46 : educationA47 : (vacation - does not exist?)，A48 : retraining，A49 : business，A410 : otherscredit_amountfloatsavingsstring账户/债券储蓄（A61：&lt;100 DM，A62：100 &lt;= x &lt;500 DM，A63：500 &lt;= x &lt;1000 DM，A64：&gt; = 1000 DM，A65：未知/无储蓄账户present_employmentstring71：待业，A72：&lt;1年，A73：1 &lt;= x &lt;4年，A74：4 &lt;= x &lt;7年，A75：…&gt; = 7年installment_ratefloat分期付款率占可支配收入的百分比personalstring个人婚姻状况和性别（A91：男性：离婚/分居，A92：女性：离婚/分居/已婚，A93：男性：单身，A94：男性：已婚/丧偶，A95：女性：单身）other_debtorsstringA101：无，A102：共同申请人，A103：担保人present_residencefloat至今居住propertystringA121：不动产，A122：如果不是，那么A121：建筑协会储蓄协议/人寿保险，A123：如果不是，则A121 / A122：不是属性6的汽车或其他，A124：未知/没有财产agefloat年岁other_installment_plansstringA141：银行，A142：商店，A143：无housingstringA151:租房，A152:自有，A153:免费existing_creditsfloat该银行现有信贷的数量jobstring1:失业/A171 : 非技术人员-非居民，A172:非技术人员-居民，A173:技术人员/官员，A174:管理/个体经营/高度合格的员工/官员dependentsinteger承担赡养费的人数telephonestringA191:无，A192:有，登记在客户名下foreign_workerstringA201: 有, A202: 无customerinteger预测类别：1 =良好，2 =不良 本文利用R语言的广义线性模型和随机森林模型分析网上比较流行的德国信用卡数据，下面的代码可以用来确定申请人是否有信用，以及他（或她）是否对贷款人有良好的信用风险。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbb8f74c10f237b6f7b3ad3ab32cb2d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f63276e2cc9e839150aee8e2cadc157/" rel="bookmark">
			使用AlphaFold2进行蛋白质结构预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
AlphaFold 2，是DeepMind公司的一个人工智能程序。2020年11月30日，该人工智能程序在蛋白质结构预测大赛CASP 14中，对大部分蛋白质结构的预测与真实结构只差一个原子的宽度，达到了人类利用冷冻电子显微镜等复杂仪器观察预测的水平，这是蛋白质结构预测史无前例的巨大进步。这一重大成果虽然没有引起媒体和广大民众的关注，但生物领域的科学家反应强烈。
目前，AlphaFold2的源代码已经在GitHub上公开，而且现在科学家正在利用AlphaFold2对已有的蛋白数据库进行高通量的预测，建立了一些模式生物物种所有蛋白的AlphaFold2预测结构数据库（https://alphafold.ebi.ac.uk/）。
可以看到，虽然利用AlphaFold2预测了这么多生物的数据库，但是并未覆盖所有的蛋白序列数据库，所以只有搭建本地的AlphaFold2服务，你才能用AlphaFold2随心所欲的预测自己研究蛋白的结构。
接下来将给大家介绍AlphaFold2的使用方法，在北鲲云上免安装使用。对于没有Linux基础或本地硬件配置不足的人，仅需1分钟即可成功提交蛋白质结构预测任务，能够省去很多麻烦。
二、在北鲲云使用AlphaFold2进行蛋白质结构预测
选择AlphaFold2 在“应用中心”搜索AlphaFold2软件并选中，在右侧弹出的软件详情栏中点击“提交作业”。
img
选择可视化模板提交 推荐选择可视化“模板提交”的方式提交作业，平台已为AlphaFold2内置了几个可视化模板，按要求填写相应参数即可提交预测任务。
img
填写模板参数，选择硬件配置，提交任务 上传序列文件（.fasta格式），选择运行模式（单体选择monomer，多聚体选择multimer）后即可点击下一步：
img
选择合适的GPU硬件配置后即可点击下一步：
img
查看作业内容汇总并提交任务：
img
查看任务详情与结果 所有通过“模板”提交的作业，都可以在左侧菜单栏“作业管理”功能中查看或者管理作业：
img
对于有Linux基础和本地硬件配置足够的人，本地使用AlphaFold2进行蛋白质预测的方法如下。
配置要求 硬盘至少要3T以上，AlphaFold2训练好的模型加数据库下载下来是428 GB大小的文件，解压后需要2.2T的空间。如果你用reduced_dbs（这个是简化的数据库），那么至少也得有600 GB的硬盘空间。
12个虚拟CPU
内存85GB及以上
1个Nvidia A100 或者Nvidia V100 GPU卡
下载程序需要的数据库、程序和模型 首先你得在github上面把这个AlphaFold2项目（https://github.com/deepmind/alphafold）给下载到一个本地目录，然后进入scripts这个文件夹里面，运行命令download_all_data.sh &lt;下载目录&gt;，程序会自动进行下载。
这个过程大概会下载438GB的文件，得等待很长时间，如果断网的话，你还得把其它的都删掉，重新下载。不建议直接运行这个主程序，可以利用多台机器分个下载。当然你也可以使用下载工具提前下载好，然后再拷贝到服务器上面去解压。
除了pdb_mmcif 这个文件之外，其它的都是可以提前下载。为什么这个文件不行？因为pdb网站并没有提供压缩的mmcif数据库文件，每个都是小文件，必须得用同步的方式把pdb服务器上面的数据库同步到本地才行，这一步建议直接在安装目录上去操作单独脚本下载，不然到时候拷贝和压缩以及解压要花大力气，这个文件夹里面有足足18万个cif文件。
下载完成解压后关注每个文件夹文件大小和文件名是否与上面这张图中列出来的一致。
注意事项：bfd文件夹和small_bfd这两个文件夹是互斥的，大文件夹里面只留一个，bfd是完整的数据库而small_bfd是简化的数据库。如果你的磁盘不够，你就下后者，271.6 GB的bfd文件你就别下了。
安装Docker和NVIDIA Container Toolkit 3.1 安装Docker
参考Docker官方教程：https://docs.docker.com/desktop/install/linux-install/
3.2 安装NVIDIA Container Toolkit
参考NVIDIA官方教程：https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html
3.3 测试是否安装成功
root权限运行：
docker run --rm --gpus all nvidia/cuda:11.0-base nvidia-smi
如果你看到如下图的一个表格，证明你成功了。
使用AlphaFold2 4.1 配置输入输出文件夹路径
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f63276e2cc9e839150aee8e2cadc157/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab3cac20e8417b3bec990c9d934ac6d9/" rel="bookmark">
			golang 时间戳处理及转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* * 描述: 字符转换为时间戳 * * strTime : 格式为 "2018-01-10" * ***************************************************************************/ func StringToTime(strTime string) int64 { //获取本地location strTem := "2006-01-02" timeLocal, _ := time.LoadLocation("Local") theTime, _ := time.ParseInLocation(strTem, strTime, timeLocal) return theTime.Unix() } /* * 描述: 整数转换为时间戳 * ***************************************************************************/ func IntToTime(nTimer int64) time.Time { return time.Unix(nTimer, 0) } /* * 描述: 字符转换为时间戳 * * strTime : 格式为 "2018-01-10 03:04:05" * ***************************************************************************/ func StringToTimeEx(strTime string) int64 { //获取本地location strTem := "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab3cac20e8417b3bec990c9d934ac6d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b286e8181a68ca26254380c78e2ab60c/" rel="bookmark">
			多组两两比较用什么检验方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.T检验
2.LSD检验
3.SNK-q检验
4.Dunnett-t检验
5.其他
1.T检验 两独立样本均数的比较。
2.LSD检验 多个均数之间的两两比较，LSD为最小显著差异(least significant difference)t检验，适用于某一或几对在专业上有非凡价值的均数间差别的比较，提供P值。
3.SNK-q检验 适用于多个均数的两两比较，常用于探索性检验，只告诉有无差异，不提供精确P值。S-N-K方法是一种有效划分相似性子集的方法。该方法适合于各水平观测值个数相等的情况。
4.Dunnett-t检验 适用于几个实验组和对照组的比较。
5.其他 Bonferroni、Tukey等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff8b6ec436ab2ed7f54e91abd5d1ff02/" rel="bookmark">
			JAVA学习日志1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java编程入门 我们需要了解方法的定义方式和相互调用 并且掌握递归调用、 理解和使用数组 、掌握常见类的基本使用，String字符串、Random随机类、Math数学库类和日期类
程序 程序 = 算法 + 数据结构 用户使用编程语言实现问题域到解域的映射，细节描述算法 汇编语言 -- 贴近于硬件设备 高级语言 --C# 、 Java-- 贴近于自然语言 -- 需要编译过程将高级语言所编写的程序转换为计算机能够识 别的 01 码 中级语言 --C Java 一种编程语言、一种开发环境、一种应用环境、一种部署环境 Java 是一种可以撰写跨平台应用程序的面向对象的程序设计语言。 Java 技术具有卓越的通用性、高 效性、平台移植性和安全性( 以牺牲执行效率为代价换取了高安全性 ) ，广泛应用于 PC 、数据中心、 游戏控制台、科学超级计算机、移动电话和互联网，同时拥有全球最大的开发者专业社群 Java 完全面向对象的编程语言，主要用于 Internet 应用程序 Java 既是一种解释执行的语言 ( 先编译后解释执行 ) ，也是一种编译执行的语言 Sun 公司对 Java 编程语言的解释是： Java 编程语言是个简单、面向对象、分布式、解释性、健壮 （鲁棒性）、安全与系统无关、可移植、高性能、多线程和静态的语言 ( 从 JDK8 开始引入了一些动 态语言的特性 ) Java 平台是基于 Java 语言的平台。这样的平台非常流行。因此微软公司推出了与之竞争的 .NET 平台 以及模仿 Java 的 C# 语言 首先将源代码编译成二进制字节码（ bytecode 不是机器语言），然后依赖各种不同平台上的虚拟 机来解释执行字节码。从而实现了【一次编译、到处执行】的跨平台特性。不过，每次的执行编译 后的字节码需要消耗一定的时间，这同时也在一定程度上降低了 Java 程序的性能 Java 是一个开发环境， Java 技术包含一系列的工具：编译器，解释器，文档生成工具，打包工具 等。另外由 Java 2 SDK 提供的 JRE 还包括了一个完整的 Java 集合，如基本语言类， GUI 控件类等 Java 是一个运行环境，它可以从 Oracle 公司提供的 Java 2 SDK 中来搭建运行环境，免费 Java是一种面向对象的语言，是一种与平台无关的语言，是一种健壮的语言。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff8b6ec436ab2ed7f54e91abd5d1ff02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e962339fb08540de0f46494760893d7/" rel="bookmark">
			SAS学习6（freq过程、tabulate过程、univariate过程、plot过程、chart过程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作业题 赌大小，三颗骰子猜数字或者大小
但是这里如果押注大，但是扔出来是3个六，仍然会输
即无论押注大或小如果骰子的旋转结果为三个同号那么算输
具体规则百度吧，挺有意思的
freq过程 画出频数表，tables v，对v变量画频数表
多维的情况：
tabulate过程 制表的同时计算统计量
table a*b 首先a、b都是列方向上的维度，a是控制维度，b是子维度，画出来的图是频数统计
b在前，b变成了控制维度
中间是空格的话，就是分别统计
这个表画出来的时候可能因为宽度超过了显示长度，所以会换行，看起来很乱
所以在前面加上了 设置行宽的语句
这里a和b中间是用的逗号，不是空格
逗号表示不止一个维度，现在有行维度，逗号前有行维度，后面是列维度
例子，主要看制表，table中有一个逗号，那么前面的维度就是grade，也就是行的维度，all就是全部，汇总
列维度是cls和ave，是相乘的，所以cls是主控维度，ave是子维度，
*F=6.2 就是6个字符长度，且小数点后保留两位小数
后面的括号里面是列维度的统计量
N pctn&lt;grade all&gt; pctn是计算百分比，n是频数
ave*（Max MIN）就是计算平均值的最大最小值
/rts中的/不知道是干啥的
RTS=10 就是左上角的各班成绩这里占10个字符，缺省是两个字符，现在是各班成绩，加上两个表格符（竖杠），就是10个字符；这里也决定了行维的宽度
box=‘’ 这里决定了左上角填写什么东西
keylable 就是将统计量替换
（lable是替换列、变量的，keylable是替换标准统计量的）
univariate过程 单一变量统计过程，对某个单变量进行统计
正态性检验，就是检查一堆数据服从正态性的可能性有多大；达到一定阈值（一般是95或者99）就说明很可能是正态分布
plot画统计图，normal做正态性检验，freq画频数表
矩就是 方差的公式中平方变成了n次方，即每个数减均值的n次方的和
矩就是这种类型的计算，均值之列的东西都归位这一类
茎叶图描述了数据散布情况，九个0表示有九个样本取这个值，相当于水平柱形图
盒形图更正规的叫法叫箱线图
正态概率图，如果画出来接近直线，就很可能是正态的
plot过程 散点图，目前用gplot，sgplot更新，目前很少使用
vpercent 垂直方向值为40，水平是60，表示占据一页纸的百分比
y*x 前面是纵坐标，后面是横坐标
vref=0，表示纵坐标等于0画一条直线
这里/不能去掉，否则会报错
画出来的图是字符画，而不是图形界面的风格
图中A代表一个观测点，b代表两个，相对密集
chart过程 饼图，坐标图，目前很少使用了
vbar，v是垂直，bar是柱形图，以sex为变量画垂直柱形图
下面xbar是画水平柱形图
block 是按sex和group两个维度为平面
sumvar是按age画柱形图，类型是平均值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77ef6bcda19a3b888e9dac094836fbe2/" rel="bookmark">
			【mysql】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先右边再左边输入，然后一定要cmd管理员打开，然后emm两个窗口
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19c5970d5ff05b6160507a744f3e51b3/" rel="bookmark">
			c语言中关于八皇后问题的详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		八皇后问题是一个古老而又著名的问题，时间退回到1848年，国际西洋棋棋手马克斯·贝瑟尔提出了这样的一个问题
在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问一共有多少种摆法。
后面陆续有不同的学者提出自己的见解。大数学家高斯认为一共有76种摆法，1854年在柏林的象棋杂志上不同的作者发表了共计40种不同的见解，后来还有人利用图论的方法得出共有92种摆法。
而如今，通过我们的计算机以及编程语言我们可以轻松的解决这个问题。对于一个棋盘，下面我们给一个解法例子方便我们去讨论所有的算法步骤。
当然如果使用暴力解法，那是相当复杂且难以想象的，这里我们推荐一种非常好的回溯算法，也是平时我们学过的递归中的一些算法。
1.首先我们想一想，从第一个皇后开始，每一个皇后可以在8列中任意一列存在，其他皇后在此基础上去找自己可以存在的列，接下来不同的皇后占据不同的行，所以为了满足每个皇后在不同列不同行这个条件，我们可以使用一个循环，让每个皇后从第一行开始递增，找到属于自己的列，然后并用一个数组place去记录此时此刻，8个皇后的位置，如上图就可以用以下方法表示
首先定义一个数组place[8]={0};
通过一些手段得到从第一个皇后开始的列的位置。
得到上图的位置分布place[8]={0，4，7，5，2，6，1，3}；
但是我们如何去知道某一列是否被占用了呢？所以我们还需要一个标记数组，把每一列首先都定义成可以使用的1，如果被占领，则变成0。 在布尔类型中，我们用1代表true，用0代表false
bool flag[8] = { 1,1,1,1,1,1,1,1 };
如果该列是合法的，那此时这个皇后会记住该列：place[n]=col；
该列被记住后，其他列无法使用该列，所以我们需要修改标记: flag[col]=false;
此时稍微简单的一部分我们在逻辑上已经完成了，可是八皇后问题有这么简单嘛？
很显然我们并没有去想到一个合适的方法去把每一列都完美的表达出来，如果对此图不理解可以看完分析再来看此图。
首先我们来表示上对角线：
如何把每一个上对角线表示成独一无二的呢？我们可以用n-col来表示每一条线，则有：
一共十五个数字，那么我们就可以用一个 用一个数组d1[15]={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,}来初始化一个表示上对角线。且要自己明白该数组中的1时从右上角往左下角排的，
但是我们考虑到数组下标不能出现负数，所以我们干脆让n-col变成n-col+7
方便我们接下来来表示占领上对角线，使其每个数字从右上角到左下角为14，13，12........2,1,0。.
知道上对角线之后，下对角线就比较好来表示了：
可以直接用n+col来表示下对角线的每一条，
所以我们也要建立一个数组d2[15]={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,}来表示每条对角线的情况。并自己明白这是从左上角往右下角排的。
每占领一个对角线我们就访问数组把把为占领的1改成已经占领的0。
d1[n - col + 7] = false; //占领上对角线 d2[n +col ] = false; //占领下对角线 因为每一个皇后都有8个列可以去执行，但是具体安排在哪一列我们需要去进行一个循环一次判断
for (col = 0; col &lt; 8; col++) //第一个皇后从第0行的第0列开始 { //每个皇后都有8个列可以走 if (flag[col] &amp;&amp; d1[n - col + 7] &amp;&amp; d2[n + col]) //如果该皇后的位置是合理的	{ //一些方法 } } 此时一个皇后在找到了自己可以占领的位置，接下来就应该去表示第二个皇后的情况了，但是到了最后一个皇后，只要满足情况，我们就不用再讨论下一个皇后，直接打印棋盘就可以了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19c5970d5ff05b6160507a744f3e51b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f62c4b62bfcb94744e65948a15a48a2f/" rel="bookmark">
			功能软件（一）：以IDM对抗百度网盘！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 众所周知，现在网上许多资源都是来自于百度网盘，而百度网盘的下载速度确实令人难以忍受，VIP又要钱，那咋办呢？IDM这款软件很好的解决了这个问题。
准备工作： 首先，你得有这款软件，下载地址如下：IDM下载地址
其次，我们需要用到一款插件Tampermonkey（也就是大家说的油猴），这个我们需要下载到自己的常用浏览器中，以我为例子，我用的是MicrosoftEdge这款浏览器。
1、点击箭头所指的区域，接下来会弹出一个管理拓展的选项，然后点击该选项。
2、在弹出的新界面中直接输入Tampermonkey，直接搜索安装即可。
3、进入油猴界面，搜索简易安装助手
这里有许多版本，本人用的最新版本的，也就是0.3.9版本的，亲测有效
我这里也是随缘选择了图示版本
点击后会弹出一个新界面，这里由于我已经安装过了，所以显示的是重新安装，这个安装几乎是一瞬间就安装完的，并且安装完之后的效果我们利用网页打开百度网盘的链接的时候，会出现一个红色的简易下载助手的按钮
4、开始配置IDM下载常用的属性：设置4线程及修改UA为 netdisk;PC
打开IDM软件，在上方的工具栏找到选项
将连接类型和最大连接数修改为如图所示。
同样在选项下，点击选项卡的下载选项，将UA（用户代理）修改为netdisk;PC(切记，纯英文)
5、这里的话，我们再回到刚才的百度网盘网页版界面。先选中要下载的资料比如我这里下载的就是嵌入式的压缩包，先保存到一个地方
之后会弹出一个选项，点击去看看
在新界面中点击简易下载助手，点击获取直链地址。
6、将地址放在IDM中下载即可。不过要先在IDM中新建一个任务。如图所示，将我们的直链地址放进去即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eae919d7f90f42b503875c352a65e830/" rel="bookmark">
			怎么在Vue3中正确使用ElementPlus，亲测有效，避坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建Vue3项目 vue create vue_element 选择自定义项目创建：
选择这几项（空格选择）
后面的几项全部回车，这里就不做介绍了，大胆回车就行，出了事算我的，除非你有特殊需求。（下面是安装成功后的图片）
二、进入项目，安装Element-Plus （1）我这里用的是WebStorm，在命令行中执行下面代码安卓Element-Plus：
npm install element-plus --save （2） 在main中配置Element-Plus：
import ElementPlus from 'element-plus' import 'element-plus/theme-chalk/index.css' createApp(App).use(store).use(router).use(ElementPlus).mount('#app') 到这里，Element-Plus里面的控件你都可以使用了。
后面讲介绍，如何使用ElementPlus中的Icon控件的配置。
三、配置Icon （1）在终端执行下面代码进行安装：
npm install @element-plus/icons-vue （2）在main中进行配置
import * as ElementPlusIconsVue from '@element-plus/icons-vue' const app = createApp(App) for (const [key, component] of Object.entries(ElementPlusIconsVue)) { app.component(key, component) } app.use(router).use(ElementPlus).mount('#app') 这样就可以使用所有ElementPlus配件了
四、测试运行 （1） 配置一个编译器
(2) 随便找一个ElementPlus用一下子看看。
拿他试一下，直接把代码复制到你的Vue就可以。
结果：
五、Git提交一下 总是报红怎么办？说明提示你修改了没有提交到git里面。有强迫症的看一下。
git add . 后再git status看一下子，这样之后就不报红，并提交到git上面了，如果你要pull到github上，这里就不演示了，已经有点跑题了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6e6403db7770ee405884f2d8a467664/" rel="bookmark">
			基于R-时间序列分析建模过程（模型识别、显著性检验、参数估计、预测等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#模型识别
自相关、偏自相关方法
x&lt;-read.table("E:/A1_8.csv",sep=",",header=T)
overshort &lt;- ts(x$overshort)
x&lt;-x$overshort
plot(overshort)
par(mfrow=c(3,1));
acf(overshort)
pacf(overshort)
#最优子集法
library(TSA)
overshort&lt;-armasubsets(y=overshort,nar=10,nma=10,ar.method="ols")
plot(overshort)
#EACF法
x&lt;-read.table("E:/A1_8.csv",sep=",",header=T)
overshort &lt;- ts(x$overshort)
x&lt;-x$overshort
library(TSA)
eacf(overshort)
#基于AIC,AIC或BIC的最佳模型法
library(forecast)
auto.arima(overshort,ic = "bic")
#参数估计（矩估计、极大似然估计、最小二乘估计）
overshort&lt;-arima(x,order=c(0,0,1),method="CSS-ML")
overshort
#显著性检验()
library(aTSA)
ts.diag(overshort)
t&lt;-abs(overshort$coef)/sqrt(diag(overshort$var.coef))
pt(t,length(overshort)-length(overshort$coef),lower.tail=F)
#模型预测
library(forecast)
overshort&lt;-arima(x)
overshort
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6201e184838636495096a1a89487c35/" rel="bookmark">
			Unet语义分割训练数据集流程（学习记录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先是语义分割，我所学习的内容来自于b站up主Bubbliiiing的课程，感兴趣也可以去看看
目录
一、源码准备
二、训练步骤
我训练的配置环境
win11+cuda11.3+pytorch1.10.2+python3.6.13
一、源码准备 1.源码下载
可以直接到up主对应的github上进行下载，GitHub - bubbliiiing/unet-pytorch: 这是一个unet-pytorch的源码，可以训练自己的模型
他的代码里面进行了中文说明，对小白很友好
2.训练所需要的模型下载
链接: 百度网盘 请输入提取码
提取码: 6n2c
下载完之后放至源码根目录中model_data文件夹，没有就新建一个
二、训练步骤 1.准备数据集
标注教程可看我上一篇文章分割数据集准备——labelme使用教程_道人兄的博客-CSDN博客
2.制作VOC数据集
① 完成步骤1之后，训练前将图片文件和.json放在dataste/before/文件夹下，然后修改json_to_dataset.py文件中的classes，保留background，添加自己的类型
之后便可以在JPEGImages中看到自己的图片，SegmentationClass看到制作好后的标注文件。
②将①图片文件放在VOCdevkit文件夹下的VOC2007文件夹下的JPEGImages中，将标签文件放在VOCdevkit文件夹下的VOC2007文件夹下的SegmentationClass中。运行根目录下的voc_annotation.py，从而生成train.txt和val.txt
3.修改参数
①train.py里的num_classes ，num_classes用于指向检测类别的个数+1！训练自己的数据集必须要修改！
②运行根目录下的train.py文件就可以开始训练啦~
有什么疑问或者建议评论区留言~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99165535329cae26cfdc0a1610fc9f79/" rel="bookmark">
			Pytorch之经典神经网络CNN(Extra-1) —— CNN可视化(查看中间层feature_map)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从ZF-Net开始人们就在研究神经网络和filter的可视化
结合了多篇文章整理了好久，网上写的真的鱼龙混杂，代码具有可操作性的不多.......也或者是我的coding水平还没到？sad.
CNN可视化各层输出的feature map 和
(5条消息) Pytorch(十四) —— 查看中间层feature_map &amp; 卷积核权重可视化_hxxjxw的博客-CSDN博客
一样
import os import torch import torchvision as tv import torchvision.transforms as transforms import torch.nn as nn import torch.optim as optim import argparse import skimage.data import skimage.io import skimage.transform import numpy as np import matplotlib.pyplot as plt import torchvision.models as models from PIL import Image import cv2 #提取某一层网络特征图 class FeatureExtractor(nn.Module): def __init__(self, submodule, extracted_layers): super(FeatureExtractor, self).__init__() self.submodule = submodule self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99165535329cae26cfdc0a1610fc9f79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2db28435f3033e8ef6e488836cb1d26/" rel="bookmark">
			开始使用AspectJ-实现步骤@Aspect，@Before,还有其中的JoinPoint参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始使用AspectJ 1.maven依赖 &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 插件 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 引入 AOP 约束
在 AspectJ 实现 AOP 时，要引入 AOP 的约束。配置文件中使用的 AOP 约束中的标签， 均是 AspectJ 框架使用的，而非 Spring 框架本身在实现
AOP 时使用的。 AspectJ 对于 AOP 的实现有注解和配置文件两种方式，常用是注解方式。
2. AspectJ 基于注解的 AOP 实现(掌握) 项目结构如下：
2.1 实现步骤 Step1：定义业务接口与实现类
接口：
package com.bjpowernode.ba01; public interface SomeService { void doSome(String name,Integer age); } 接口实现类：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2db28435f3033e8ef6e488836cb1d26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ae2ef09cc6fc9fffff5794355db5115/" rel="bookmark">
			第六章 树与二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 树与二叉树1.树的基本概念和术语1.1树的定义：树是（n≥0）个结点的有限集合T。1.2术语1.3树的两个特点1.4树的抽象数据类型 2.二叉树的定义和基本操作3.二叉树的5个性质 （重点）4.二叉树的存储结构4.1 顺序存储 一维数组bt[1..n]4.2链式存储 二叉链表三叉链表 5.二叉树的遍历 （重点）5.1遍历：分为先序、中序、后序5.1.1先序遍历算法5.1.2中序遍历算法5.1.3后序遍历算法 6.由遍历序列确定二叉树 （重点）7.二叉树遍历算法的应用7.1输出二叉树中的结点7.2输出二叉树中的叶子结点7.3统计叶子结点数目方法1:（采用全局变量)方法2:采用递归算法 7.4求二叉树的高度7.5按树状打印二叉树7.6建立二叉链表方式存储的二叉树7.7基于栈的递归消除 8.线索二叉树8.1基本概念8.2建立线索链表8.2.1中序线索化算法8.2.2在线索二叉树中找前驱、后继结点 9.树、森林和二叉树的关系9.1树的存储结构9.1.1双亲表示法9.1.2孩子表示法9.1.3孩子兄弟表示法 9.2树、森林与二叉树的相互转换9.2.1树转换为二叉树1.树转换为二叉树的方法2.结论： 9.2.2森林转换为二叉树方法9.2.3二叉树还原为树或森林 9.3树与森林的遍历9.3.1树的遍历方法主要有以下两种：（1）先根遍历（2）后跟遍历 9.3.2森林的遍历森林的遍历方法有三种：（1）先序遍历（2）中序遍历（3）后序遍历 9.3.3树、二叉树、森林遍历关系对应表： 10.哈夫曼树及其应用 （重点）10.1基本概念10.1.1最优二叉树10.1.2哈夫曼树 10.2构建哈夫曼树（重点）10.2.1哈夫曼树的特点 10.3哈夫曼树的类型定义10.4哈夫曼树的算法实现（难点）10.5哈夫曼树及其应用10.5.1哈夫曼树编码10.5.2如何进行哈夫曼编码？10.5.3结论 10.5.4哈夫曼编码的算法实现 树与二叉树 1.树的基本概念和术语 1.1树的定义：树是（n≥0）个结点的有限集合T。 当n=0时称为空树；当n＞0时，该集合满足如下条件：（1）其中必有一个称为根（root）的特定结点，它没有直接前驱，但有0个或多个直接后继。（2）其余n-1个结点可以划分成m(m≥0)个互不相交的有限集T1，T2，T3，…Tm，其中Ti又是一棵树，称为根root的子树。每棵子树的根结点有且仅有一个直接前驱，但有0个或多个直接后继。 1.2术语 根：即根结点（没有前驱）除根结点外的分支结点统称为内部结点。
结点：包括一个数据元素及若干指向其他结点的分支信息
结点的度：一个结点的子树个数（即分支的个数）
叶子结点：度为0的结点，即无后继结点，也称为终端结点
分支结点：度不为0的结点，也称为非终端结点
结点的层次：从根到该结点的层数（根结点为第一层）
结点的层序编号：将树中的结点按从上到下、从左到右的次序排成一个线性序列，依次给它们编以连续的自然数
树的度：树中所有结点的度的最大值
树的高度（深度）：树中所有结点的层次的最大值
有序树：结点各子树从左至右有序，不能互换（左为第一）
森林：指m（m≥0）棵不相交的树的集合，反之，给森林增加一个统一的根结点，森林就变成一棵树
同构：对两棵树，通过对结点适当地重命名，可以使两棵树完全相等（结点对应相等，对应结点的相关关系也相等），则称这两棵树同构。
孩子结点：一个结点的直接后继
双亲结点：一个结点的直接前驱
兄弟结点：同一双亲结点的孩子结点之前互称
堂兄弟：即双亲位于同一层的结点（但并非同一双亲）
祖先结点：即从根到该结点所经分支的所有结点
子孙结点：一个结点的直接后继和间接后继称为该结点的子孙结点，即该结点下层子树中的任一结点
1.3树的两个特点 1.树的跟结点没有前驱结点，除根结点之外有且只有一个前驱结点2.树中所有结点可以有0个或多个后继结点 1.4树的抽象数据类型 2.二叉树的定义和基本操作 特点：（1）每个结点的度都不大于2； （2）每个结点的孩子结点次序不能任意颠倒（有序树）。 满足以上两个条件的树型结构为二叉树（Binary Tree）二叉树或为空树，或由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。
2.1二叉树与树（普通树、多叉树）的区别：
1.树中结点的最大度数没有限制，而二叉树结点的最大度数为2 2.树的结点无左右之分，而二叉树的结点有左右之分 3.二叉树和树都属于树形结构 4.所有树都能转化为唯一对应的二叉树 2.2二叉树的定义及基本操作
形态：5种
基本操作：
①Initiate(bt);//初始一棵空二叉树 ②Destory (bt);//销毁一棵二叉树 Creat (bt)://创建一棵非空二叉树 ④Empty(bt);//树为空返回TRUE ⑤Root(bt);//求根结点 ⑥Parent(bt,x);//求双亲结点 ⑦LeftChild(bt,x);//求左孩子 ⑧RithtChild(bt,x);//求右孩子 ⑨Traverse(bt);//遍历操作 ⑩Clear(bt);/l将二叉树置为空树 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ae2ef09cc6fc9fffff5794355db5115/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3117c27d22dab56f2c1ce527737b99d2/" rel="bookmark">
			My Publications
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Reviewer of
IEEE Transactions on Pattern Analysis and Machine Intelligence (TPAMI)
IEEE Transactions on Circuits and Systems for Video Technology (TCSVT)
IEEE Transactions on Multimedia (TMM)
IET Computer Vision
=====================================================
* Corresponding Author
⋆ ^\star ⋆ Equal Contribution
2022 《Attention Diversification for Domain Generalization》
Rang Meng ⋆ ^\star ⋆, Xianfeng Li ⋆ ^\star ⋆, Weijie Chen, Shicai Yang, Jie Song, Xinchao Wang, Lei Zhang, Mingli Song, Di Xie, Shiliang Pu*
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3117c27d22dab56f2c1ce527737b99d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c09e79a1d14f3ed9ae797443eac8197/" rel="bookmark">
			[数据结构]----顺序表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.线性表的介绍
2.顺序表
2.1顺序表的概念及结构
2.2静态顺序表
2.3动态顺序表
2.3.1动态顺序表的定义
2.3.2动态顺序表的初始化
2.3.3动态循序表的销毁
2.3.4检查动态顺序表空间,满了则增容
2.3.5动态顺序表的尾插和尾删
2.3.6动态顺序表的头插和头删
2.3.7在动态顺序表中查找某个数
2.3.8动态顺序表在pos位置插入x
2.3.9动态顺序表删除pos位置的值
1.线性表的介绍 线性表（linear list）是n个具有相同特性的数据元素的有限序列。 线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串...
线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，线性表在物理上存储时，通常以数组和链式结构的形式存储 2.顺序表 顺序表是数据结构中给的单独的名字，严格来说顺序表就是数组
2.1顺序表的概念及结构 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。在数组上完成数据的增删查改。
注：顺序表要求数据是连续存储的 、
2.2静态顺序表 使用定长数组存储元素
我们可以用宏（define）来控制数组大小，方便修改数组大小
因为要控制数组是连续存储的 我们需要用size来控制存储顺序
下面是静态顺序表的定义
#define N 100 typedef int DataType typedef struct StaticSeqList { DataType a[N]; int size;// 记录存储多少个有效数据 }SSL; 静态顺序表的增删查改就是数组的移动
静态顺序表的初始化：
void init_SSL(SSL* slt) { slt-&gt;size = 0; } 静态顺序表的后插：
void insert_SSL(SSL* slt, DataType x) { if (slt-&gt;size == N) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c09e79a1d14f3ed9ae797443eac8197/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c619825ffa624a3c69dddbf8e176975/" rel="bookmark">
			uniapp跳转微信小程序（5&#43;app通用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		plus.share.getServices(function(res){ var sweixin = null; for(var i=0;i&lt;res.length;i++){ var t = res[i]; if(t.id == 'weixin'){ sweixin = t; } } if(sweixin){ sweixin.launchMiniProgram({ id: '', type: 0, path:'pages/user/wallet/xunyuji-recharge'//这里是指定页的路径，如需传参直接字符串拼接（首页可以省略） }); } },function(res){ console.log(JSON.stringify(res)); }); 需要用到share模块，去申请微信开放平台，然后在manifest.json里配置微信分享的相关参数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf7b8129f7b98689692a19033c0d9fee/" rel="bookmark">
			Git的常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 环境配置 当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息
设置用户信息 git config --global user.name “你的用户名” git config --global user.email “你的邮箱” 查看配置信息 git config --list git config user.name 通过上面的命令设置的信息会保存在~/.gitconfig文件中
1.2 获取Git仓库 要使用Git对我们的代码进行版本控制，首先需要获得Git仓库
获取Git仓库通常有两种方式： 在本地初始化一个Git仓库 ；从远程仓库克隆
1.2.1在本地初始化一个Git仓库 执行步骤如下：
1. 在电脑的任意位置创建一个空目录（例如repo1）作为我们的本地Git仓库
2. 进入这个目录中，点击右键打开Git bash窗口
3. 执行命令git init 如果在当前目录中看到.git文件夹（此文件夹为隐藏文件夹）则说明Git仓库创建成功
1.2.2从远程仓库克隆 可以通过Git提供的命令从远程仓库进行克隆，将远程仓库克隆到本地
命令形式为：
git clone 远程Git仓库地址 1.3工作目录、暂存区以及版本库概念 为了更好的学习Git，我们需要了解Git相关的一些概念，这些概念在后面的学习中会经常提到
版本库：前面看到的.git隐藏文件夹就是版本库，版本库中存储了很多配置信息、日志信息和文件版本信息等；
工作目录（工作区）：包含.git文件夹的目录就是工作目录，主要用于存放开发的代码
暂存区：.git文件夹中有很多文件，其中有一个index文件就是暂存区，也可以叫做stage。暂存区是一个临时保存 修改文件的地方
1.4 Git工作目录下文件的两种状态 Git工作目录下的文件存在两种状态：
untracked 未跟踪（未被纳入版本控制） tracked 已跟踪（被纳入版本控制） Unmodified 未修改状态 Modified 已修改状态 Staged 已暂存状态 这些文件的状态会随着我们执行Git的命令发生变化
1.5 本地仓库操作 git status 查看文件状态 也可以使用git status –s 使输出信息更加简洁 git add 将未跟踪的文件加入暂存区 将新创建的文件加入暂存区后查看文件状态
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf7b8129f7b98689692a19033c0d9fee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d5daaf06eb9c7a2762377b86023888f/" rel="bookmark">
			打印机脱机恢复正常打印的三种解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在打印文件的时候，有很多的用户遇到了脱机的问题导致了无法继续操作下去，为此我们带来了脱机的几个解决方法，不知道打印机脱机状态怎么恢复正常打印的一起看看。
打印机脱机了怎么恢复打印？ 出现脱机立马检查一下自己的连接数据线是不是有问题，有条件的话可以换一根尝试一下。
要是数据线没什么问题，可以通过以下几种方法来进行解决。
方法一
1、首先打开电脑的“控制面板”。
2、然后在硬件和声音下面点击“查看设备和打印机”。
3、右击你的打印机，选择“删除设备”。
4、点击“是”将其删除。
5、再去点击上方的“添加打印机”。
6、点击下方“我所需的打印机未列出”。
7、勾选“按名称选择共享打印机”，再去点击“浏览”。
8、此时可以去双击选择你的打印机连接电脑，在点击打印机。
9、最后点击下一步，再去点击完成，即可解决脱机问题。
方法二
1、首先看看打印机的有没有打开，不确定的话可以按几次电源键等信号灯闪烁再使用。
2、正常启动之后，点击右下角打印图标打开打印选项。
3、接着点击左上角的“打印机”选择“脱机使用打印机”。
4、也可以点击下面的“取消所有文档”。
5、然后点击上面的“打印服务器属性”。
6、随后选择更新“驱动程序”即可。
7、如果还是不行，可以看看数据线有没有损坏，条件足够可以换一根试试。
方法三
1、首先右击左下角的开始，选择“设备管理器”。
2、之后点击右侧列表中的“打印列队”。
3、在驱动上面右击，点击“更新驱动程序”。
4、最后点击“自动搜索驱动程序”自动检查更新就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70a8546d6e558d2a04cc10f8e9011743/" rel="bookmark">
			深入浅出『汉诺塔』
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0.前言1.游戏规则2.汉诺塔1-3层详解🍑(1)一层汉诺塔🍑(2)二层汉诺塔🍑(3)三层汉诺塔 3.汉诺塔求解思路4.汉诺塔语言实现🍑(1)C语言实现代码🍑(2)Java实现代码🍑由汉诺塔引申出对递归问题的求解 总结 0.前言 大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。一次只移动一片，不管在哪根针上，小片必须在大片上面。
僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。
1.游戏规则 条件： 有A、B、C三根柱子，A柱子按照上小下大放置圆盘。
规则： 每次只能移动1个圆盘，圆盘可在A、B、C三根柱子间任意移动，并且始终保持小盘在大盘上。
目标： 圆盘全部从A柱移动到C柱上，并且圆盘顺序不变，依旧是上小下大。
2.汉诺塔1-3层详解 汉诺塔是一道非常经典的递归问题，对于递归问题的求解，最重要的是找到递归公式，下面我们先通过观察1-3层汉诺塔移动方法，看看能不能找到一些规律。
🍑(1)一层汉诺塔 一层汉诺塔移动方法显然是：
移动第1个圆盘: A -&gt; C
🍑(2)二层汉诺塔 二层汉诺塔移动方法：
移动第1个圆盘: A -&gt; B
移动第2个圆盘: A -&gt; C
移动第1个圆盘: B -&gt; C
🍑(3)三层汉诺塔 动图演示：
三层汉诺塔移动方法：
移动第1个圆盘: A -&gt; C
移动第2个圆盘: A -&gt; B
移动第1个圆盘: C -&gt; B
移动第3个圆盘: A -&gt; C
移动第1个圆盘: B -&gt; A
移动第2个圆盘: B -&gt; C
移动第1个圆盘: A -&gt; C
3.汉诺塔求解思路 观察过上面1-3层的汉诺塔的移动，你有没有找到一些规律呢？经过简单的归纳总结，我们大体可以得到这样的规律：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70a8546d6e558d2a04cc10f8e9011743/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1f37444c8c365f2bb94f8546e4e117e/" rel="bookmark">
			实验一 网络配置与常用网络命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验一 网络配置与常用网络命令 【实验目的】
掌握TCP/IP协议的简单配置以及命令行方式下常用网络命令的使用，了解排除网络故障的基本方法。
【实验内容】
1．查看本机的网络配置；
2．检查本机与服务器的连通性和路径；
3．通过arp命令查看并分析IP地址和MAC地址的关系；
4．分析并写出域名对应的主机IP地址。
【实验基本要求】
(1) 配置本机的IP地址以及实验室环境下网络的子网掩码、默认网关、DNS服务器IP地址；
(2) 根据实验内容及结果，简单叙述ipconfig、ping、tracert、nslookup、netstat、arp等命令的用途；
(3) 链路联通性测试的方法及一般步骤。
实验步骤 实验步骤
一、 查看网络配置
打开DOS窗口，输入ipconfig -all即可查看本机的网络配置。进行此次实验时连接的是WIFI，所以在无线局域网适配器也就是无线网卡下面会有对应的网络配置信息
二、 本机与服务器的连通性
打开DOS窗口，输入ping 124.221.241.13 或者ping osako.top(该域名已解析到124.221.241.13，可以正常访问，服务器也正常运转)，向服务器发送数据包，然后查看统计信息，丢失率为0，说明与外网已联通，与服务器连通性良好。
三、 arp命令
在DOS窗口输入arp -a, 因为数据帧是由源MAC地址和目的MAC地址组成的，如果发送者只知道目的主机的IP地址， 不知道目的主机的MAC地址， 就不能把这个数据包转化成数据帧发走，而ARP就是负责地址解析的， 使用目的主机IP地址来解析对方的MAC地址。
四、 域名与IP
域名和IP之间的关系：域名通过DNS解析成IP地址，即可通过域名访问到相应的服务器(IP)，例如如果拥有域名的话，可以在相应的域名控制台给域名添加解析,相应的二级域名，或者三级域名即可被解析到相应的IP
可以在DOS窗口下面使用nslookup命令，输入nslookup osako.top,即可查看域名对应的主机IP地址
查询域名对应的IP地址还可以在站长工具里面找到SEO综合查询，输入要查询出域名，即可查询到该域名的IP地址，这里以我自己注册的域名为例。域名osako.top 对应主机IP为124.221.241.13
五、配置IP以及其他
点击网络和Internet设置-&gt;更改适配器选项,在网络连接这个界面选择连接的网络,右键点击属性，找到Internet协议版本4(TCP/IPv4)在弹出的窗口中勾选使用下面的IP地址，输入IP地址、子网掩码、默认网关、DNS服务器，然后点击确认。
六、命令
ipconfig命令用于查看本机的网络配置
ping命令用于本机与服务器之间的连通性测试
tracert命令是简单网络诊断工具，探测数据包从源地址到目的地址经过的路由器IP地址
nslookup命令用于查询DNS的记录，查看域名解析是否正常，在网络故障的时候用来诊断网络问题
netstat命令是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息
七、 链路联通性测试的方法及一般步骤
如果电脑使用的是有线连接，先检查网线是否接通、网线是否破损、RJ45接头是否损坏等等情况，以排除因为连接不通而无网的情况。如果电脑使用的是无线连接，检查WIFI或者热点是否可用(存在连接别人WIFI,别人在后台管理界面限制你的设备访问或者限速等情况，还有WIFI本身的问题还有热点因为没有流量而限流等情况)，如果不可用则换一个WIFI或者热点查看网络是否连通以排除其他情况。
3.排除上面两种情况之后，可以打开DOS窗口输入ipconfig -all查看本机IP以及其他网络参数，接下来Ping一下自己电脑的IP地址
如果有信号返回，说明本机的网卡没有问题，反之就检查本机的网卡驱动，首先更新一下网卡驱动，如果问题仍然存在，可以卸载重新安装网卡。
然后Ping一下外网的IP，
如果有信号返回则说明与外网连通性良好，反之检查自己连接的网络是否配置(例如是否登录校园网,是否完成上网认证等等)
4. 如果网络不通，可照以上方法ping一下网关，如果没有数据包返回，则网关或路由设置不对，或者网络服务商根据没提供网络信号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feb1dc129c32ca069d51a92235ebd5d1/" rel="bookmark">
			【C语言】验证哥德巴赫猜想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题来源题目要求如何判断素数？ 主函数完整代码+效果演示写代码中的误解总结 问题来源 这是学校的一个作业，原题如下
题目先给出了哥德巴赫猜想的背景知识（我还真不知道）
2000以内的正偶数都能分解成两个质数（素数）之和
题目要求 下面来梳理一下题目的要求：
输出样式为a=b+c，使用%4d=%4d+%4d输出每行输出4个，每行最后一个输出无空格每个偶数只需要一个结果即可（后续较大的偶数有很多种解） 弄懂了题目要求，下面就来一步一步写代码
如何判断素数？ 在上篇博客里面提到了如何判断素数==&gt;【链接】，这里不再赘述
我们需要搞定的是判断是那两个素数b、c相加等于我们需要的那个数a
因为需要多次判断，这里我们使用自定义函数
int SuShu(int a) { if (a == 1) { return 0;//1不是素数 } int j = 0; for(j = 2; j &lt;=sqrt(a); j++) { if (a % j == 0) { return 0; } } return 1; } 为什么是return1和0呢？
因为在写这段代码的时候，我本来是想判断之后返回一个素数，但是这个方法效率太低
而且写到后面我自己都不会写了，遂放弃。
主函数 最终实现形式：n=a+(n-a)
在自定以函数里面返回的值是1和0
主函数里面就需要内容来接收
if (SuShu(a) &amp;&amp; SuShu(n - a))//判断a和n-a是否都是素数 同时我们需要完成打印4行换一行，以及每行最后一个不能有空格的要求
这时候直接在printf语句里面加空格已经不够了
需要用到判断语句，判断已经打印了几个等式
if (SuShu(a) &amp;&amp; SuShu(n - a)) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/feb1dc129c32ca069d51a92235ebd5d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f518f2882566f8a9b7c1d5446ec20b0/" rel="bookmark">
			查看win10激活状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何查看win10激活状态 命令行模式
输入：“ slmgr.vbs -dlv ” ；可产看 Win10 的激活信息，包括：激活 ID、安装 ID、激活截止日期等信息。
输入：“slmgr.vbs -dli ”；可查看操作系统版本、部分产品密钥、许可证状态等。
输入：“slmgr.vbs -xpr”；可查看命Win10 是否永久激活。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ee2d7684be732987a1cb3e62ec7c497/" rel="bookmark">
			Gitlab调优-备份及恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		调优 gitlab是个内存老虎, 在使用32G无力内存的服务器中, 在默认配置下一直吃满内存, 甚至在使用过程中经常出现各种5xx错误, 然后一看剩余内存就仅剩几百兆...... 然后经过摸索, 终于把内存占用控制在16G左右（吹牛逼了，32G最少了）修改的配置文件内容如下:
[root@gitlab ~]# vi /etc/gitlab/gitlab.rb 进入配置文件，按Go ，然后直接粘贴进去，保存退出。
[root@gitlab ~]# gitlab-ctl reconfigure &amp;&amp; gitlab-ctl restart（并且在前面命令执行成功的情况下，再次执行一个动作，连起来叫生效配置文件，且进行gitlab的重启）
生产环境中最少64g，经过调优后最少给到32g，上不封顶，不吃cpu，存代码完成基本的操作，cpu差不多也按基本的配置16核64G.
备份 gitlab的备份是运维的责任。
首先，gitlab的备份很简单，只需要在gitlab的配置文件中设定一下我们的备份目录，以及备份保存的时间。
如果想恢复，停掉两个进程，然后再去进行备份的一个恢复，把它启动起来就好了。总体的操作流程比较简单。但要明确gitlab什么时候备份，备份多少次？以及备份正常设定的保存时间是多少？
备份时间周期： 30天---60天 因为害怕公司源代码的丢失
备份在gitlab里也称之为迁移，相同版本的gitlab之间可以相互恢复其备份的这些库以及表等等一系列的东西。也就是说我们在A机器的gitlab进行了一次备份到达B机器之后也同样能进行恢复，前提必须保持gitlab的版本是一致的，但是gitlab版本又分为主版本，次版本和修订版本。（我们要保持的是大版本一致）次版本和修订版本不要太多的关注。
由于我们只是备份里面的源代码，一般情况下是不会丢的，代码的安全性还是比较高的，我们要关注一下备份的周期和时长。30-60天之间都是合理的。
[root@gitlab ~]# cd /etc/gitlab/
[root@gitlab gitlab]# vim gitlab.rb 修改配置文件
备份的目录
备份的保存时间，默认情况下，一周也可以，但是每次备份的时长规定在30d-60d。
保存的时长是30天（最少了），而备份的周期已经确定了要多长时间备份一次，那每次保留一个备份也可以，当然在一个月中间出现了，gitlab的代码丢失了，同事那边也没有代码怎么办？
一、可以建立两个gitlab 第一个gitlab专门搞程序员推送上去的代码 第二个让它时刻同步生产上用的gitlab。时刻同步的方式可以给它设定成每一天晚上两三点的时候让它先备份再把备份传到另一台gitlab里，让他在恢复。
可以写一个脚本，脚本里的内容：先运行备份命令，会生成目录，把目录传到对应的机器中，再到对应的机器中去执行远程的命令，让它恢复回去，这就可以避免掉这一个月中间，突然某一天代码全丢了，这种情况的一个发生。正常来说这种情况一般不会遇到，因为它只存储我们公司内部的项目，虽然多，但也不是每一个项目每时每刻都在活动的，不像github，gitlab构建在公司内部，还是比较稳定，只要机器配置给足就OK了。再其次gitlab里真正存的仓库文件，就是一堆文件，不涉及什么数据更改，把gitlab那张磁盘保留住，把磁盘挂到其他磁盘上去运行起来也可以。解决方法比较多，不用担心它真的会丢，有很多种方法能找回来。
挂磁盘是一种，去实时同步是一种，把线上生产环境的代码拉回来也是一种。甚至用一个共享存储也可以，比如上传代码到了gitlab里面，运维再写一个脚本，同步过来的代码再给他同步到ftp上也可以。
【注意】在做任何操作时，一定要备份，稳妥。（包括修改文件时，cp一份）
改完配置文件之后，保存退出，重新将配置文件生效。
[root@gitlab gitlab]# gitlab-ctl reconfigure
对配置生效之后，如果没有报错就重启gitlab里面的一些服务
[root@gitlab gitlab]# gitlab-ctl restart
重启完成之后，去查看一下所有服务是不是启动
[root@gitlab gitlab]# gitlab-ctl status
确定没有问题，去gitlab的空间里看到有项目。如果是502应该是里边服务启动速度比较慢。
再回到gitlab的服务器，使用gitlab的命令对我们的服务进行一个备份操作
[root@gitlab gitlab]# gitlab-rake gitlab:backup:create 创建一个备份（固定的命令）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ee2d7684be732987a1cb3e62ec7c497/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1277ddc40fdb6bbf746ca20c5f61a4bb/" rel="bookmark">
			Vue06/Vue中this.$nextTick( ) 的用法及详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.$nextTick 语法: this.$nextTick( 箭头函数体 ) 作用: this.$nextTick这个方法作用是当数据被修改后使用这个方法 回调函数获取更新后的dom再渲染出来 注意: 1.data改变，更新DOM是异步的 2.获取更新后的DOM方法 this.$nextTick(() =&gt; { 需要更新的DOM } ) 说明: 1.$nextTick是一个异步微任务，等待当前函数的dom渲染结束后执行 2.$nextTick 类似于一个非常高级的定时器 自动追踪DOM更新 更新好了就触发 应用场景: DOM更新是异步的 Vue 响应式的特征 修改数据后 页面会自动更新 而更新DOM这个操作是异步的 这个时候使用 this.$nextTick( 回调函数 ) 回调函数会在下一次 DOM更新完毕后执行 详细: 1.this.$nextTick 将回调延迟到下次DOM更新循环之后执行 在修改数据之后立即使用他 2.this$nextTick 跟全局方法 vue.nextTick一样 不同的是 回调的this 自动绑定到调用他的实列上 3.总的来说 假设我们更改了某个dom元素内部的文本，而这时候我们想直接打印这个更改之后的文本是需要 dom更新之后才会实现的 就像我们把将要打印输出的代码放在 setTimeout(fn, 0) 中 介绍: vue在修改数据后 视图(DOM)不会立刻更新，而是等同一事件循环中的所有数据变化完成之后 在统一进行视图更新 所以 在修改数据更新立马读取DOM是获取不到新数据的 ， 获取到的原来的DOM函数 使用newxtTick 可以获得DOM更新后的数据 在下次DOM更新之后vue会回调nextTick指定的函数 可以在修改数据之后立即使用这个nextTick方法 在指定的函数里获取更新后的DOM 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57ea8c1923a0d0ea9627b8deb76959b4/" rel="bookmark">
			flex的缩写值的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flex的缩写值：flex的缩写值具体使用
flex: initial等同于设置flex: 0 1 auto flex属性的默认值。初始值，常用。
flex:1等同于设置flex: 1 1 0% （推荐）
flex:0等同于设置flex: 0 1 0%
flex:auto等同于设置flex: 1 1 auto
flex:none等同于设置flex: 0 0 auto（推荐）
flex-basis:0%表示建议支持是0，因此，设置flex:0的元素的最终尺寸表现为最小内容宽度；
flex-basis:auto表示固定尺寸由内容决定,最终尺寸通常表现为最大内容宽度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c649783306c3f9a4db0820b60d10626e/" rel="bookmark">
			Red Hat Enterprise Linux9安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1.启动iso镜像进入安装首页2. 选择语言3.进入安装摘要界面4. 选择安装目的地5. 禁用KDUMP6. 软件选择7.网络和主机名8.设置root用户密码9.开始安装10. 重启11. 登录系统12. 挂载系统iso镜像13.配置本地镜像源14.安装软件15. 远程登陆16. 修改静态ip地址17.配置在线镜像源（补充） 前言 之前安装过redhat enterprise linux8的8.4桌面版，最近9也出来了，所以按耐不住想来安装一下9的服务器版本，iso镜像我下载的完整版，有需要的可以在评论区@我，我看到会回复你下载地址的，基本上从7-9的版本都有，这里不建议大家下载boot.iso镜像安装，我试过了，它需要联网注册在线安装，由于镜像的下载地址在国外，所以安装过程很慢，相信大家等不来，完整版安装很快，应该半小时以内就可以安装完成。
1.启动iso镜像进入安装首页 红帽的安装界面还是比较简捷干净的，个人看起来比较舒服，这也是我比较喜欢红帽Linux的一个原因，什么时候中文这里只有简体中文和繁体中文就更好了，大家都懂的…
2. 选择语言 这里语言我就选择简体中文，然后点击继续
3.进入安装摘要界面 4. 选择安装目的地 点击安装摘要界面中的安装目的地，然后点击完成即可
5. 禁用KDUMP 这里我点击KDUMP，进入KDUMP设置页面，然后去掉勾选，点击完成
我习惯禁用，你也可以不禁用
6. 软件选择 点击软件选择进入软件选择界面，大家可以看得到基本环境有五种，附件软件就饿更多了，大家按需选择，我这里基本环境直接选择最小安装，附件软件只添加了个容器管理，红帽里面的容器管理工具是podman,他和docker基本一样使用，命令基本一致，当然你也可以不添加，然后去安装docker
点击完成回到摘要界面
7.网络和主机名 点击网络和主机名，进入网络和主机名设置界面
默认主机名是localhost，当然你也可以自定义，还有就是点击配置按钮进入网络设置界面
进入ip4设置界面后，依次做如下设置，这里是把动态分配ip修改成了静态IP，以后IP地址都不会发生变化，修改完成后点击保存，然后点击完成
8.设置root用户密码 点击root密码，进入root账户密码设置界面，勾选允许root用户使用密码SSH登录，这里新手用户还是建议勾选上，不然后面要通过设置配置文件，对于新手就比较麻烦了，然后点击完成，这里需要点击完成两次
9.开始安装 在安装摘要界面点击开始安装进入系统安装，这里大家就可以喝杯咖啡耐心等待一会了，时间不会太长，大概10分中以内
10. 重启 点击重启系统即可
11. 登录系统 重启之后进入黑窗口登录，因为我这里是最小安装，所以只有命令行登录界面，身为程序员，我是很喜欢命令行界面的，毕竟命令操作确实比桌面操作方便太多
12. 挂载系统iso镜像 执行mount /dev/sr0 /mnt命令挂载系统iso镜像，有时候会出现下面这种情况
执行init 0关机，然后再重新开启虚拟机进入系统，重新挂载即可
此时查看下mnt目录下是有内容的
13.配置本地镜像源 cd /etc/yum.repo/目录，vi local.repo，添加如下内容
[Local-Base] name=Local-Base baseurl=file:///mnt/BaseOS gpgcheck=0 enabled=1 [AppStream] name=AppStream baseurl=file:///mnt/AppStream gpgcheck=0 enabled=1 14.安装软件 这里安装个vim,最小安装刚刚安装好系统是没有vim编辑器的，如下所示安装成功，这一步安装软件一定要在前面的12和13步完成后才可以进行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c649783306c3f9a4db0820b60d10626e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/371aad4e7d763bfd9c07f6362ec82e0b/" rel="bookmark">
			笔记本电脑主板电池没电如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑作为现如今社会人们不可或缺的电子产品之一,对电脑有研究的小伙伴就知道,主板电池存在的主要意义其实是为了给BIOS进行不间断的供电的,如果是主板的话,经常会引发一系列无法开机的故障问题,怎么办呢?下面,小编跟大家说说笔记本电脑主板电池没电怎么办。
工具/原料：
系统版本：win7系统
品牌型号： 宏碁墨舞EX215
方法/步骤：
进入BIOS设置修复或者换电池：
1、笔记本电脑主板电池没电怎么办呢?首先检查电脑的电源风扇是否会转动起来，硬盘有没有自检声，显示器是否变亮，如果这时候电脑显示“CMOS Load Failure”的话。
2、系统提示按“F2”键继续启动，这时不管它，按“Del”进入BIOS设置界面。
3、按下F2键，让系统继续进行引导，如果还是无法进入Windows XP的桌面，再次重启电脑。
4、“Del”键进入BIOS设置界面，这时我们不需要输入密码，可以直接进入了，很显然CMOS电池没电了，需要买了一块新的电池装进其中，并接上所有设备再次把电脑开机，电脑就可以顺利开机啦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/580907f279f417e9c784810b3c2e897d/" rel="bookmark">
			国内打开github慢解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在国内环境，Github经常会遇到打不开的问题，并且有时能打开但是网速好慢，以下是解决办法。
1、通过站长工具找出DNS地址：进入站长工具网站的域名解析网址：http://tool.chinaz.com/dns/ ，在A类型的查询中输入github.com，找出最快的IP地址；
2.找到hosts文件拖到桌面
3.我们将host文件以记事本方式打开，然后在文件底部加上以下文字：
#github 20.205.243.166 github.com 20.205.243.166 gist.github.com 20.205.243.166 assets-cdn.github.com 20.205.243.166 raw.githubusercontent.com 20.205.243.166 gist.githubusercontent.com 20.205.243.166 cloud.githubusercontent.com 20.205.243.166 camo.githubusercontent.com 20.205.243.166 avatars0.githubusercontent.com 20.205.243.166 avatars1.githubusercontent.com 20.205.243.166 avatars2.githubusercontent.com 20.205.243.166 avatars3.githubusercontent.com 20.205.243.166 avatars4.githubusercontent.com 20.205.243.166 avatars5.githubusercontent.com 20.205.243.166 avatars6.githubusercontent.com 20.205.243.166 avatars7.githubusercontent.com 20.205.243.166 avatars8.githubusercontent.com 5：放回原位覆盖
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4594d5d0e09756c249c75291124eb2e3/" rel="bookmark">
			QT debug 日记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误一：debug\***.exe:-1: error: LNK1120: 1 个无法解析的外部命令 ***.obj:-1: error: LNK2019: 无法解析的外部符号 "public: __cdecl ***(void)" (??0BodyInspector@@QEAA@XZ)，函数 "private: void __cdecl ***on_pushButton_4_clicked(void)" (?on_pushButton_4_clicked@**@@AEAAXXZ) 中引用了该符号
解决思路：检查类里面是否有已声明，但是没有定义的函数，大概率是因为函数没有定义！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35d527117d5d3834f45f0b091aa14245/" rel="bookmark">
			idea 配置apache-tomcat-8.5.46和apache-maven-3.8.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA配置 本文转载自:https://juejin.cn/post/7161674584591171615
一、创建普通Java项目 创建一个普通的Java项目
编辑项目名称及路径
项目创建成功
二、配置Tomcat 进入IDEA配置菜单：File-settings
三、配置maven 进入IDEA配置菜单：File-settings，搜索maven
四、构建Maven项目 五、创建Servlet 在pom.xml文件中添加servlet依赖
&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; 创建servlet
设置字符编码，解决中文乱码问题
六、实现登录功能 login.html
Servlet代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6794f2fd314be25a395ecd5833c2e9fa/" rel="bookmark">
			图像分割指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像常用指标：
首先介绍混淆矩阵中的数值：
TP：正确正样本数，即预测为正，实际也为正
TN：正确负样本数，即预测为负，实际也为负
FP：错误正样本数，即预测为正，实际为负
FN：错误负样本数，即预测为负，实际为正
TP+FN：真实正样本总和
FP+TN：真实负样本总和
TP+TN：正确分类样本总和
TP+FP：预测正样本总和
FP+TN：预测负样本总和
Accuary（准确率）：TP+TN / 样本总和
这个指标基本没啥用，毕竟负样本并不关心
Precision(精确率，查准率)：TP/(TP+FP)
正确正样本数比上预测中所有的正样本数。Precision越高，说明误检的越少
Recall（召回率，查全率）：TP/(TP+FN)
正确正样本数比上真实中正样本数，Recall越高，说明漏检越少。
Iou(交并比)：TP / (TP+FP+FN)
交集为TP，并集为预测中的正样本数加预测错误的负样本数
F1分数：2*recall*precision/(recall + precision)
总体衡量recall和Precision，f1表示两种指标同等重要。一般来说，recall和precison都是越大越好，但并不是所有模型都可以做到两者都高，一般都会存在一方高一方低，所以采用f1分数来统一衡量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3d3b6aa5da21164a3044563826d2ec0/" rel="bookmark">
			CENTOS7 Anaconda&#43;Jupyter&#43;Pyspark联合安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、 安装anaconda（在线）
2、 连接jupyter notebook（在线）
3、离线Anaconda配置
4、离线Python环境配置（虚拟环境）
5、 jupyter notebook 连接pyspark
1、 安装anaconda（在线） 1.1、 下载anaconda
1）在终端输入（x86系统）
wget https://repo.anaconda.com/archive/Anaconda3-2020.02-Linux-x86_64.sh 报错
wget：commend not found # 没有wget命令则用yum安装，在终端输入： yum install wget -y 2）在终端输入（Arm系统）
wget https://github.com/Archiconda/build-tools/releases/download/0.2.3/Archiconda3-0.2.3-Linux-aarch64.sh 1.2、 安装，在终端输入
bash Anaconda3-2020.02-Linux-x86_64.sh 点击Enter，出现安装条例，一直Enter键直至出现是否同意，输入yes，最后确定安装位置。
1.3、 激活环境，在终端输入
source ~/.bashrc 1.4、 建立python虚拟环境，在终端输入
conda create -n pytorch(env_name) python==3.7.0 1.5、 激活环境
conda activate pytorch 问题： 1、在1.2步安装过程中可能出现
bunzip2 connot find 解决
yum install bzip2 2、 连接jupyter notebook（在线） 2.1 进入虚拟环境
conda activate pytorch(env_name) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3d3b6aa5da21164a3044563826d2ec0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba11ebc56571cfbdd669bc7d0c28d220/" rel="bookmark">
			MYSQL闪退及DBeaver连接MYSQL出现拒绝连接的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述：
MYSQL闪退；
DBeaver连接MYSQL失败
可能原因是MYSQL服务没有启动
解决方案：
1、使用管理者模式打开CMD
2、进入MYSQL安装目录下的bin目录，并执行mysqld.exe -install
出现 Service successfully installed. 3、重启MYSQL服务，输入net start mysql
结束。
其次，也可以使用win+x，之后按G，启动计算机管理，在服务里启动MYSQL服务。
参考文献：(42条消息) mysql闪退问题_叨咕捣鼓的博客-CSDN博客_mysql闪退 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b948374f3232577fa333dabeb0a99b11/" rel="bookmark">
			前端调式的一般方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端调试方法 目录概述需求： 设计思路实现思路分析1.前端调试2.使用控值台表达式等3.使用控制台debugger,在JS中 Survive by day and develop by night.
talk for import biz , show your perfect code,full busy，skip hardness,make a better result,wait for change,challenge Survive.
happy for hardess to solve denpendies.
目录 概述 前端是应用的一部分，如何做前端调试呢。
需求： 设计思路 实现思路分析 1.前端调试 使用控制台日志
2.使用控值台表达式等 在js 中使用debugger
3.使用控制台debugger,在JS中 在js 中使用debugger
欢迎阅读，各位老铁，如果对你有帮助，点个赞加个关注呗！~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/513e753cc2646509ac327318d5eaad82/" rel="bookmark">
			git checkout到新的分支之后原来未提交的代码找回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git checkout时遇到的问题 当我们使用git进行代码版本管理时，如果本地有多个并行开发的需求的话，我们会时不时地切换不同的分支。当我们基于当前分支做了一些改动，但是并没有执行git commit命令的话，这时如果我们想直接git checkout到另外的分支，那么idea就会弹窗提醒我们，选force checkout或者smart checkout。
两者有何不同 git checkout如果未提交本地代码。则会提示你选force checkout或者smart checkout。
smart checkout会把本地修改的代码先保存到statsh中，再checkout分支。
force checkout在当前分支修改的所有内容都会丢失，只能用以下步骤找回代码(找回后需要自行检查是否有错漏)
所以保险起见我们一般都是选择smart checkout。
不慎点击force checkout后如何找回 force checkout后可以通过以下步骤找回丢失的代码
1.在项目文件夹右键。点击local history-&gt;show history
2.接着找到checkout前的时间
3.右键选项后点击revert或者点击具体的类进行比较分析，把丢失的代码移动过来
本篇文章如有帮助到您，请给「翎野君」点个赞，感谢您的支持。
首发链接：https://www.cnblogs.com/lingyejun/p/16856394.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6135b2be51b5085b67458474e523f85/" rel="bookmark">
			消化性溃疡病人的护理习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.消化性溃疡的主要症状是（）
A.恶心 B.呕吐 C.反酸 D.嗳气 E.上腹痛
2.消化性溃疡最常见的并发症是（）
A.穿孔 B.出血 C.幽门梗阻 D.癌变 E.感染 3.消化性溃疡合并穿孔常见于（）
A.胃溃疡 B.十二指肠溃疡 C.急性糜烂性胃炎 D.急性腐蚀性胃炎 E.慢性萎缩性胃炎
4.消化性溃疡的主要病因是（）
A.金黄色葡萄球菌感染 B.大肠杆菌感染 C.胃粘膜破坏 D.幽门螺杆菌感染 E.结核杆菌感染 5.消化性溃疡合并幽门梗阻患者纤维胃镜检查前须做的准备是（）
A.洗胃 B.向胃内注空气 C.行胃肠减压 D.手术切除梗阻部位 E.肌内注射阿托品
6.消化性溃疡患者术后护理不正确的是 （）
A.术后3小时内每30分钟测量血压 B.观察胃管、伤口引流液的性质和量
C.注意口腔护理 D.禁食期间静脉补偿液体
E.术后拔除胃管后当日可进软食
7.治疗消化性溃疡，应用下列何种药物抑制胃酸和胃蛋白酶分泌最有效（）
A.甲氰咪胍(西咪替丁) B.阿托品 C.硫糖铝 D.前列腺素E, (PGE2) E.氢氧化铝凝胶
8.抑制胃酸药作用最强的药效是（）
A.H2受体拮抗药 B.抗胆碱能药 C.丙谷胺 D.奥美拉唑 E.前列腺素比
9.患者女性，30岁，胃溃疡穿孔行“毕I式胃大部切除术”。术后4天，诉腹部胀痛，恶心，停止排气排便。查体:全腹膨隆，未见肠型，全腹压痛，以中上腹最为显著，轻度肌紧张，肠鸣音消失。T37.8°C, P90次/分钟，BP112/78mmHg，血常规:白细胞12x109/L，中性粒细胞比例0.86;腹部X线平片见肠腔积气及小液气平面。以下护理措施错误的是
A. 禁食、胃肠减压 B.可适当用654-2止痛 C.协助患者取低半坐位 D.及时、准确记录出入水量 E.应用抗菌药预防感染
10.患者男性，46岁，有胃溃疡病史近10年。近2个月疼痛加剧且失去节律性，无呕吐，服用多种抑酸剂不能缓解。查体:腹部平软，上腹部轻压痛， 可扪及肿块，质硬。为确诊病因应首选
A.大便隐血试验 B.X线钡餐检查 C.幽门螺杆菌检查 D.胃镜检查 E.胃液分析
11.患者女性，60岁，有溃疡病史10余年。突然出现呕血约500ml，伴有黑便，急诊入院。查体:神志清楚，血压100/60mmHg，心率110次/分。以下护理措施中正确的是
A.平卧位，头部略抬高 B.三腔二囊管压迫止血 C.呕吐时头偏向-侧，防止误吸和室息D.快速滴入血管加压 E.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6135b2be51b5085b67458474e523f85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9407867a2f0c18c0b99a0af3230597a/" rel="bookmark">
			Selenium启动常用浏览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、webdriver驱动下载
chromedriver驱动下载地址：（根据chrome版本下载）
microsoft-edge驱动下载地址：（根据Edge版本下载）
geckodriver驱动下载地址：
iedriverserver驱动下载地址：（根据selenium版本下载）
二、简单测试
打开Chrome浏览器
打开edge浏览器
打开firefox浏览器
打开IE浏览器 一、webdriver驱动下载 chromedriver驱动下载地址：（根据chrome版本下载） http://chromedriver.storage.googleapis.com/index.html
我当前的谷歌浏览器版本如下：
所以我这里选择107.0.5304.62下载
下载完成后，解压文件可得到chromedriver.exe文件
microsoft-edge驱动下载地址：（根据Edge版本下载） https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/
我的edge版本如下：
我下载了107.0.1418.23版本的驱动
geckodriver驱动下载地址： Releases · mozilla/geckodriver · GitHub
我的firefox是当前最新版本
我下载的也是最新版本的驱动
iedriverserver驱动下载地址：（根据selenium版本下载） http://selenium-release.storage.googleapis.com/index.html
其实我也没看懂我这ie是啥版本，有懂的老师可以科普下。。。
但我找了最近一个有IEDriverServer的3.9版本下载（最开始我下载了x64版本的，但使用selenium打开ie浏览器时报错，百度了一下，据说下载win32的就可以避免这个问题，所以我最后重下了win32版本）
最后我把驱动放在一个文件夹下了，如下图所示：
二、简单测试 我的selenium版本是 4.3.0，不知道大家常用版本是啥。。
打开Chrome浏览器 from selenium import webdriver from selenium.webdriver.chrome.service import Service import time s = Service(r"E:\Programs\Driver\chromedriver.exe") driver = webdriver.Chrome(service=s) time.sleep(3) driver.close() 打开edge浏览器 from selenium import webdriver from selenium.webdriver.edge.service import Service import time s = Service(r"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9407867a2f0c18c0b99a0af3230597a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17aa1b3afeb51b178309b905d48e0a76/" rel="bookmark">
			InfluxDB学习记录（三）——influxdb的flux语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Flux Flux 是 InfluxData 的功能性数据脚本语言，设计用于查询、分析和处理数据，它是InfluxQL 和其他类似 SQL 的查询语言的替代品。
每个 Flux 查询都需要以下内容：
数据源时间范围数据过滤器 Flux代码示例 from(bucket:"example-bucket") |&gt; range(start: -15m) |&gt; filter(fn: (r) =&gt; r._measurement == "cpu" and r._field == "usage_system" and r.cpu == "cpu-total" ) 示例解析 1、定义数据源
Flux的from()函数定义 InfluxDB 数据源。 它需要一个bucket参数。example-bucket就是bucket的名称
from(bucket:"example-bucket") 2、指定时间范围
查询时间序列数据时，Flux 需要一个时间范围。 “无限”查询非常耗费资源，作为一种保护措施， Flux 不会查询没有指定范围的数据库。
|&gt;range()，指定查询的时间范围。 它接受两个参数：start 和stop。
start 值和stop 值可以使用负持续时间是相对值，也可以是使用时间戳的绝对值。
相对范围，相对于“现在”。
// Relative time range with start only. Stop defaults to now. from(bucket:"example-bucket") |&gt; range(start: -1h) // Relative time range with start and stop from(bucket:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17aa1b3afeb51b178309b905d48e0a76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e341451847b6ec5f35b55be21bcd351/" rel="bookmark">
			eclipse 不能使用jdk1.8启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境变量的1.8不用管；
再装一个jdk11；jdk11不用配置到环境变量，
在eclipse.ini文件头上添加以下内容即可；
-vm
/usr/local/jdk-11.0.3/bin/java
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fbcdf8d05c3eee8d7d8b67b3b4ab544/" rel="bookmark">
			echarts map 地图 点击事件 跳转页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//第一种方法
myChart.on('click', function(args) {
if (args.data.name == '江西鹰潭') {
location.href = 'http://www.baidu.com'; }
})
第二种方法
myChart.getZr().on('click', (params) =&gt; {
if (params.target.style.text == '江西鹰潭') {
console.log('666', params.target)
location.href = 'http://www.baidu.com'; //测试效果
}
});
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b54e9cf83fbe9a257033da15329041f/" rel="bookmark">
			【Qualcomm 9x07 mdm-le-2.0】设备树的编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高通qc9x07芯片，mdm-le-2.0平台，关于设备树的编译，除了apps_proc\kernel\msm-3.18\arch\arm\boot\dts目录下的编译之外，在bitbake菜单中也有关于masterDTB需要修改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eaaa3f0a630ffa78487a000ec82f9d6/" rel="bookmark">
			Unity Scene视图显示所有开启射线的UI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 static Vector3[] fourCorners = new Vector3[4]; private void Awake() { // 关闭移动设备上的显示 if (Application.platform == RuntimePlatform.WindowsEditor || Application.platform == RuntimePlatform.OSXEditor) { } else { this.enabled = false; } } void OnDrawGizmos() { foreach (MaskableGraphic g in GameObject.FindObjectsOfType&lt;MaskableGraphic&gt;()) { if (g.raycastTarget) { RectTransform rectTransform = g.transform as RectTransform; rectTransform.GetWorldCorners(fourCorners); Gizmos.color = Color.red; for (int i = 0; i &lt; 4; i++) Gizmos.DrawLine(fourCorners[i], fourCorners[(i + 1) % 4]); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f98f2515f542795bbe7b0384bd1dfed4/" rel="bookmark">
			Scroll View到达底部加载新页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 0是左边/上边,1是右边/下边
scollview.verticalNormalizedPosition = 0;
scollview.horizontalNormalizedPosition = 0;
float timer = 0; void Start() { timer=Time.time; } private void Update() { // 当滑动条到最右边并且时间超过1秒,加载后面的东西 if (scroll.horizontalNormalizedPosition &gt;= 1 &amp;&amp; Time.time - timer &gt; 1 ) { lastTimer = Time.time; Debug.Log("到底了"); } } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/193/">«</a>
	<span class="pagination__item pagination__item--current">194/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/195/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>